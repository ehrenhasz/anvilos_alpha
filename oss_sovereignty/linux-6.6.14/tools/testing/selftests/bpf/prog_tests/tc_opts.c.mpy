{
  "module_name": "tc_opts.c",
  "hash_id": "5066290a8008409593b3f9ee1b9b43552ca627c7d8f00b919a153dd770a29e1a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/tc_opts.c",
  "human_readable_source": "\n \n#include <uapi/linux/if_link.h>\n#include <net/if.h>\n#include <test_progs.h>\n\n#define loopback 1\n#define ping_cmd \"ping -q -c1 -w1 127.0.0.1 > /dev/null\"\n\n#include \"test_tc_link.skel.h\"\n#include \"tc_helpers.h\"\n\nvoid serial_test_tc_opts_basic(void)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, id1, id2;\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[2];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\n\tassert_mprog_count(BPF_TCX_INGRESS, 0);\n\tassert_mprog_count(BPF_TCX_EGRESS, 0);\n\n\tASSERT_EQ(skel->bss->seen_tc1, false, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\n\terr = bpf_prog_attach_opts(fd1, loopback, BPF_TCX_INGRESS, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(BPF_TCX_INGRESS, 1);\n\tassert_mprog_count(BPF_TCX_EGRESS, 0);\n\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, BPF_TCX_INGRESS, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_in;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 2, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\n\terr = bpf_prog_attach_opts(fd2, loopback, BPF_TCX_EGRESS, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_in;\n\n\tassert_mprog_count(BPF_TCX_INGRESS, 1);\n\tassert_mprog_count(BPF_TCX_EGRESS, 1);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, BPF_TCX_EGRESS, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_eg;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 2, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\ncleanup_eg:\n\terr = bpf_prog_detach_opts(fd2, loopback, BPF_TCX_EGRESS, &optd);\n\tASSERT_OK(err, \"prog_detach_eg\");\n\n\tassert_mprog_count(BPF_TCX_INGRESS, 1);\n\tassert_mprog_count(BPF_TCX_EGRESS, 0);\n\ncleanup_in:\n\terr = bpf_prog_detach_opts(fd1, loopback, BPF_TCX_INGRESS, &optd);\n\tASSERT_OK(err, \"prog_detach_in\");\n\n\tassert_mprog_count(BPF_TCX_INGRESS, 0);\n\tassert_mprog_count(BPF_TCX_EGRESS, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nstatic void test_tc_opts_before_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, fd4, id1, id2, id3, id4;\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[5];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\tfd4 = bpf_program__fd(skel->progs.tc4);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\tid4 = id_from_prog_fd(fd4);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id3, id4, \"prog_ids_3_4\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target;\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target2;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = fd2,\n\t);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target2;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target3;\n\n\tASSERT_EQ(optq.count, 3, \"count\");\n\tASSERT_EQ(optq.revision, 4, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id2, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], 0, \"prog_ids[3]\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_id = id1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd4, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target3;\n\n\tassert_mprog_count(target, 4);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target4;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id4, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id1, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id3, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], id2, \"prog_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\n\ncleanup_target4:\n\terr = bpf_prog_detach_opts(fd4, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\ncleanup_target3:\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup_target2:\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\ncleanup_target:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_before(void)\n{\n\ttest_tc_opts_before_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_before_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_after_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, fd4, id1, id2, id3, id4;\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[5];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\tfd4 = bpf_program__fd(skel->progs.tc4);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\tid4 = id_from_prog_fd(fd4);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id3, id4, \"prog_ids_3_4\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target;\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target2;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target2;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target3;\n\n\tASSERT_EQ(optq.count, 3, \"count\");\n\tASSERT_EQ(optq.revision, 4, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id2, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], 0, \"prog_ids[3]\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_id = id2,\n\t);\n\n\terr = bpf_prog_attach_opts(fd4, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target3;\n\n\tassert_mprog_count(target, 4);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target4;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id2, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], id4, \"prog_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\n\ncleanup_target4:\n\terr = bpf_prog_detach_opts(fd4, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target3;\n\n\tASSERT_EQ(optq.count, 3, \"count\");\n\tASSERT_EQ(optq.revision, 6, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id2, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], 0, \"prog_ids[3]\");\n\ncleanup_target3:\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target2;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 7, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\ncleanup_target2:\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 8, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\ncleanup_target:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_after(void)\n{\n\ttest_tc_opts_after_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_after_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_revision_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, id1, id2;\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[3];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.expected_revision = 1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.expected_revision = 1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, -ESTALE, \"prog_attach\"))\n\t\tgoto cleanup_target;\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.expected_revision = 2,\n\t);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target;\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target2;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.expected_revision = 2,\n\t);\n\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_EQ(err, -ESTALE, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup_target2:\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.expected_revision = 3,\n\t);\n\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\ncleanup_target:\n\tLIBBPF_OPTS_RESET(optd);\n\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_revision(void)\n{\n\ttest_tc_opts_revision_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_revision_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_chain_classic(int target, bool chain_tc_old)\n{\n\tLIBBPF_OPTS(bpf_tc_opts, tc_opts, .handle = 1, .priority = 1);\n\tLIBBPF_OPTS(bpf_tc_hook, tc_hook, .ifindex = loopback);\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tbool hook_created = false, tc_attached = false;\n\t__u32 fd1, fd2, fd3, id1, id2, id3;\n\tstruct test_tc_link *skel;\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tif (chain_tc_old) {\n\t\ttc_hook.attach_point = target == BPF_TCX_INGRESS ?\n\t\t\t\t       BPF_TC_INGRESS : BPF_TC_EGRESS;\n\t\terr = bpf_tc_hook_create(&tc_hook);\n\t\tif (err == 0)\n\t\t\thook_created = true;\n\t\terr = err == -EEXIST ? 0 : err;\n\t\tif (!ASSERT_OK(err, \"bpf_tc_hook_create\"))\n\t\t\tgoto cleanup;\n\n\t\ttc_opts.prog_fd = fd3;\n\t\terr = bpf_tc_attach(&tc_hook, &tc_opts);\n\t\tif (!ASSERT_OK(err, \"bpf_tc_attach\"))\n\t\t\tgoto cleanup;\n\t\ttc_attached = true;\n\t}\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_detach;\n\n\tassert_mprog_count(target, 2);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, chain_tc_old, \"seen_tc3\");\n\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tif (!ASSERT_OK(err, \"prog_detach\"))\n\t\tgoto cleanup_detach;\n\n\tassert_mprog_count(target, 1);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, chain_tc_old, \"seen_tc3\");\n\ncleanup_detach:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tif (!ASSERT_OK(err, \"prog_detach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 0);\ncleanup:\n\tif (tc_attached) {\n\t\ttc_opts.flags = tc_opts.prog_fd = tc_opts.prog_id = 0;\n\t\terr = bpf_tc_detach(&tc_hook, &tc_opts);\n\t\tASSERT_OK(err, \"bpf_tc_detach\");\n\t}\n\tif (hook_created) {\n\t\ttc_hook.attach_point = BPF_TC_INGRESS | BPF_TC_EGRESS;\n\t\tbpf_tc_hook_destroy(&tc_hook);\n\t}\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_opts_chain_classic(void)\n{\n\ttest_tc_chain_classic(BPF_TCX_INGRESS, false);\n\ttest_tc_chain_classic(BPF_TCX_EGRESS, false);\n\ttest_tc_chain_classic(BPF_TCX_INGRESS, true);\n\ttest_tc_chain_classic(BPF_TCX_EGRESS, true);\n}\n\nstatic void test_tc_opts_replace_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, id1, id2, id3, detach_fd;\n\t__u32 prog_ids[4], prog_flags[4];\n\tstruct test_tc_link *skel;\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.expected_revision = 1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_id = id1,\n\t\t.expected_revision = 2,\n\t);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target;\n\n\tdetach_fd = fd2;\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_attach_flags = prog_flags;\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_flags, 0, sizeof(prog_flags));\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target2;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id1, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\tASSERT_EQ(optq.prog_attach_flags[0], 0, \"prog_flags[0]\");\n\tASSERT_EQ(optq.prog_attach_flags[1], 0, \"prog_flags[1]\");\n\tASSERT_EQ(optq.prog_attach_flags[2], 0, \"prog_flags[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.replace_prog_fd = fd2,\n\t\t.expected_revision = 3,\n\t);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target2;\n\n\tdetach_fd = fd3;\n\n\tassert_mprog_count(target, 2);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target2;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 4, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id3, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id1, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, false, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE | BPF_F_BEFORE,\n\t\t.replace_prog_fd = fd3,\n\t\t.relative_fd = fd1,\n\t\t.expected_revision = 4,\n\t);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target2;\n\n\tdetach_fd = fd2;\n\n\tassert_mprog_count(target, 2);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target2;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id1, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.replace_prog_fd = fd2,\n\t);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tASSERT_EQ(err, -EEXIST, \"prog_attach\");\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE | BPF_F_AFTER,\n\t\t.replace_prog_fd = fd2,\n\t\t.relative_fd = fd1,\n\t\t.expected_revision = 5,\n\t);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tASSERT_EQ(err, -ERANGE, \"prog_attach\");\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE | BPF_F_AFTER | BPF_F_REPLACE,\n\t\t.replace_prog_fd = fd2,\n\t\t.relative_fd = fd1,\n\t\t.expected_revision = 5,\n\t);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tASSERT_EQ(err, -ERANGE, \"prog_attach\");\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_id = id1,\n\t\t.expected_revision = 5,\n\t);\n\ncleanup_target2:\n\terr = bpf_prog_detach_opts(detach_fd, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\ncleanup_target:\n\tLIBBPF_OPTS_RESET(optd);\n\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_replace(void)\n{\n\ttest_tc_opts_replace_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_replace_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_invalid_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\t__u32 fd1, fd2, id1, id2;\n\tstruct test_tc_link *skel;\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE | BPF_F_AFTER,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -ERANGE, \"prog_attach\");\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE | BPF_F_ID,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -ENOENT, \"prog_attach\");\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_AFTER | BPF_F_ID,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -ENOENT, \"prog_attach\");\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.relative_fd = fd2,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -EINVAL, \"prog_attach\");\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE | BPF_F_AFTER,\n\t\t.relative_fd = fd2,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -ENOENT, \"prog_attach\");\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_ID,\n\t\t.relative_id = id2,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -EINVAL, \"prog_attach\");\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -ENOENT, \"prog_attach\");\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -ENOENT, \"prog_attach\");\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -EEXIST, \"prog_attach\");\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -EEXIST, \"prog_attach\");\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -EEXIST, \"prog_attach\");\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -EINVAL, \"prog_attach_x1\");\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.replace_prog_fd = fd1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tASSERT_EQ(err, -EEXIST, \"prog_attach\");\n\tassert_mprog_count(target, 1);\n\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_invalid(void)\n{\n\ttest_tc_opts_invalid_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_invalid_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_prepend_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, fd4, id1, id2, id3, id4;\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[5];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\tfd4 = bpf_program__fd(skel->progs.tc4);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\tid4 = id_from_prog_fd(fd4);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id3, id4, \"prog_ids_3_4\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target;\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target2;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id1, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target2;\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\terr = bpf_prog_attach_opts(fd4, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target3;\n\n\tassert_mprog_count(target, 4);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target4;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id4, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id2, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], id1, \"prog_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\n\ncleanup_target4:\n\terr = bpf_prog_detach_opts(fd4, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\ncleanup_target3:\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup_target2:\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\ncleanup_target:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_prepend(void)\n{\n\ttest_tc_opts_prepend_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_prepend_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_append_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, fd4, id1, id2, id3, id4;\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[5];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\tfd4 = bpf_program__fd(skel->progs.tc4);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\tid4 = id_from_prog_fd(fd4);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id3, id4, \"prog_ids_3_4\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target;\n\n\tassert_mprog_count(target, 2);\n\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target2;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 3, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, false, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target2;\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\terr = bpf_prog_attach_opts(fd4, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_target3;\n\n\tassert_mprog_count(target, 4);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup_target4;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id3, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], id4, \"prog_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc1, true, \"seen_tc1\");\n\tASSERT_EQ(skel->bss->seen_tc2, true, \"seen_tc2\");\n\tASSERT_EQ(skel->bss->seen_tc3, true, \"seen_tc3\");\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\n\ncleanup_target4:\n\terr = bpf_prog_detach_opts(fd4, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\ncleanup_target3:\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup_target2:\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\ncleanup_target:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_append(void)\n{\n\ttest_tc_opts_append_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_append_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_dev_cleanup_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, fd4, id1, id2, id3, id4;\n\tstruct test_tc_link *skel;\n\tint err, ifindex;\n\n\tASSERT_OK(system(\"ip link add dev tcx_opts1 type veth peer name tcx_opts2\"), \"add veth\");\n\tifindex = if_nametoindex(\"tcx_opts1\");\n\tASSERT_NEQ(ifindex, 0, \"non_zero_ifindex\");\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\tfd4 = bpf_program__fd(skel->progs.tc4);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\tid4 = id_from_prog_fd(fd4);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id3, id4, \"prog_ids_3_4\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count_ifindex(ifindex, target, 0);\n\n\terr = bpf_prog_attach_opts(fd1, ifindex, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count_ifindex(ifindex, target, 1);\n\n\terr = bpf_prog_attach_opts(fd2, ifindex, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup1;\n\n\tassert_mprog_count_ifindex(ifindex, target, 2);\n\n\terr = bpf_prog_attach_opts(fd3, ifindex, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup2;\n\n\tassert_mprog_count_ifindex(ifindex, target, 3);\n\n\terr = bpf_prog_attach_opts(fd4, ifindex, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup3;\n\n\tassert_mprog_count_ifindex(ifindex, target, 4);\n\n\tASSERT_OK(system(\"ip link del dev tcx_opts1\"), \"del veth\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts1\"), 0, \"dev1_removed\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts2\"), 0, \"dev2_removed\");\n\treturn;\ncleanup3:\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count_ifindex(ifindex, target, 2);\ncleanup2:\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count_ifindex(ifindex, target, 1);\ncleanup1:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count_ifindex(ifindex, target, 0);\ncleanup:\n\ttest_tc_link__destroy(skel);\n\n\tASSERT_OK(system(\"ip link del dev tcx_opts1\"), \"del veth\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts1\"), 0, \"dev1_removed\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts2\"), 0, \"dev2_removed\");\n}\n\nvoid serial_test_tc_opts_dev_cleanup(void)\n{\n\ttest_tc_opts_dev_cleanup_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_dev_cleanup_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_mixed_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\t__u32 pid1, pid2, pid3, pid4, lid2, lid4;\n\t__u32 prog_flags[4], link_flags[4];\n\t__u32 prog_ids[4], link_ids[4];\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\tint err, detach_fd;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc3, target),\n\t\t  0, \"tc3_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc4, target),\n\t\t  0, \"tc4_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tpid3 = id_from_prog_fd(bpf_program__fd(skel->progs.tc3));\n\tpid4 = id_from_prog_fd(bpf_program__fd(skel->progs.tc4));\n\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\tASSERT_NEQ(pid3, pid4, \"prog_ids_3_4\");\n\tASSERT_NEQ(pid2, pid3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\terr = bpf_prog_attach_opts(bpf_program__fd(skel->progs.tc1),\n\t\t\t\t   loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tdetach_fd = bpf_program__fd(skel->progs.tc1);\n\n\tassert_mprog_count(target, 1);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup1;\n\tskel->links.tc2 = link;\n\n\tlid2 = id_from_link_fd(bpf_link__fd(skel->links.tc2));\n\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.replace_prog_fd = bpf_program__fd(skel->progs.tc1),\n\t);\n\n\terr = bpf_prog_attach_opts(bpf_program__fd(skel->progs.tc2),\n\t\t\t\t   loopback, target, &opta);\n\tASSERT_EQ(err, -EEXIST, \"prog_attach\");\n\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.replace_prog_fd = bpf_program__fd(skel->progs.tc2),\n\t);\n\n\terr = bpf_prog_attach_opts(bpf_program__fd(skel->progs.tc1),\n\t\t\t\t   loopback, target, &opta);\n\tASSERT_EQ(err, -EEXIST, \"prog_attach\");\n\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.replace_prog_fd = bpf_program__fd(skel->progs.tc2),\n\t);\n\n\terr = bpf_prog_attach_opts(bpf_program__fd(skel->progs.tc3),\n\t\t\t\t   loopback, target, &opta);\n\tASSERT_EQ(err, -EBUSY, \"prog_attach\");\n\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.replace_prog_fd = bpf_program__fd(skel->progs.tc1),\n\t);\n\n\terr = bpf_prog_attach_opts(bpf_program__fd(skel->progs.tc3),\n\t\t\t\t   loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup1;\n\n\tdetach_fd = bpf_program__fd(skel->progs.tc3);\n\n\tassert_mprog_count(target, 2);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc4, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup1;\n\tskel->links.tc4 = link;\n\n\tlid4 = id_from_link_fd(bpf_link__fd(skel->links.tc4));\n\n\tassert_mprog_count(target, 3);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.replace_prog_fd = bpf_program__fd(skel->progs.tc4),\n\t);\n\n\terr = bpf_prog_attach_opts(bpf_program__fd(skel->progs.tc2),\n\t\t\t\t   loopback, target, &opta);\n\tASSERT_EQ(err, -EEXIST, \"prog_attach\");\n\n\toptq.prog_ids = prog_ids;\n\toptq.prog_attach_flags = prog_flags;\n\toptq.link_ids = link_ids;\n\toptq.link_attach_flags = link_flags;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tmemset(prog_flags, 0, sizeof(prog_flags));\n\tmemset(link_ids, 0, sizeof(link_ids));\n\tmemset(link_flags, 0, sizeof(link_flags));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup1;\n\n\tASSERT_EQ(optq.count, 3, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], pid3, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_attach_flags[0], 0, \"prog_flags[0]\");\n\tASSERT_EQ(optq.link_ids[0], 0, \"link_ids[0]\");\n\tASSERT_EQ(optq.link_attach_flags[0], 0, \"link_flags[0]\");\n\tASSERT_EQ(optq.prog_ids[1], pid2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_attach_flags[1], 0, \"prog_flags[1]\");\n\tASSERT_EQ(optq.link_ids[1], lid2, \"link_ids[1]\");\n\tASSERT_EQ(optq.link_attach_flags[1], 0, \"link_flags[1]\");\n\tASSERT_EQ(optq.prog_ids[2], pid4, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_attach_flags[2], 0, \"prog_flags[2]\");\n\tASSERT_EQ(optq.link_ids[2], lid4, \"link_ids[2]\");\n\tASSERT_EQ(optq.link_attach_flags[2], 0, \"link_flags[2]\");\n\tASSERT_EQ(optq.prog_ids[3], 0, \"prog_ids[3]\");\n\tASSERT_EQ(optq.prog_attach_flags[3], 0, \"prog_flags[3]\");\n\tASSERT_EQ(optq.link_ids[3], 0, \"link_ids[3]\");\n\tASSERT_EQ(optq.link_attach_flags[3], 0, \"link_flags[3]\");\n\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\ncleanup1:\n\terr = bpf_prog_detach_opts(detach_fd, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_opts_mixed(void)\n{\n\ttest_tc_opts_mixed_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_mixed_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_demixed_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_tcx_opts, optl);\n\tstruct test_tc_link *skel;\n\tstruct bpf_link *link;\n\t__u32 pid1, pid2;\n\tint err;\n\n\tskel = test_tc_link__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc1, target),\n\t\t  0, \"tc1_attach_type\");\n\tASSERT_EQ(bpf_program__set_expected_attach_type(skel->progs.tc2, target),\n\t\t  0, \"tc2_attach_type\");\n\n\terr = test_tc_link__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tpid1 = id_from_prog_fd(bpf_program__fd(skel->progs.tc1));\n\tpid2 = id_from_prog_fd(bpf_program__fd(skel->progs.tc2));\n\tASSERT_NEQ(pid1, pid2, \"prog_ids_1_2\");\n\n\tassert_mprog_count(target, 0);\n\n\terr = bpf_prog_attach_opts(bpf_program__fd(skel->progs.tc1),\n\t\t\t\t   loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\tlink = bpf_program__attach_tcx(skel->progs.tc2, loopback, &optl);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto cleanup1;\n\tskel->links.tc2 = link;\n\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_EQ(err, -EBUSY, \"prog_detach\");\n\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 1);\n\tgoto cleanup;\n\ncleanup1:\n\terr = bpf_prog_detach_opts(bpf_program__fd(skel->progs.tc1),\n\t\t\t\t   loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_opts_demixed(void)\n{\n\ttest_tc_opts_demixed_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_demixed_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_detach_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, fd4, id1, id2, id3, id4;\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[5];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\tfd4 = bpf_program__fd(skel->progs.tc4);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\tid4 = id_from_prog_fd(fd4);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id3, id4, \"prog_ids_3_4\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup1;\n\n\tassert_mprog_count(target, 2);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup2;\n\n\tassert_mprog_count(target, 3);\n\n\terr = bpf_prog_attach_opts(fd4, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup3;\n\n\tassert_mprog_count(target, 4);\n\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id3, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], id4, \"prog_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 3);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 3, \"count\");\n\tASSERT_EQ(optq.revision, 6, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id4, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], 0, \"prog_ids[3]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 2);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 7, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\tLIBBPF_OPTS_RESET(optd);\n\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_EQ(err, -ENOENT, \"prog_detach\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_EQ(err, -ENOENT, \"prog_detach\");\n\tgoto cleanup;\n\ncleanup4:\n\terr = bpf_prog_detach_opts(fd4, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\ncleanup3:\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup2:\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\ncleanup1:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_detach(void)\n{\n\ttest_tc_opts_detach_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_detach_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_detach_before_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, fd4, id1, id2, id3, id4;\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[5];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\tfd4 = bpf_program__fd(skel->progs.tc4);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\tid4 = id_from_prog_fd(fd4);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id3, id4, \"prog_ids_3_4\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup1;\n\n\tassert_mprog_count(target, 2);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup2;\n\n\tassert_mprog_count(target, 3);\n\n\terr = bpf_prog_attach_opts(fd4, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup3;\n\n\tassert_mprog_count(target, 4);\n\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id3, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], id4, \"prog_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = fd2,\n\t);\n\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 3);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 3, \"count\");\n\tASSERT_EQ(optq.revision, 6, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id2, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id4, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], 0, \"prog_ids[3]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = fd2,\n\t);\n\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_EQ(err, -ENOENT, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = fd4,\n\t);\n\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_EQ(err, -ERANGE, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_EQ(err, -ENOENT, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = fd3,\n\t);\n\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 2);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 7, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id3, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id4, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t\t.relative_fd = fd4,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 1);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 8, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id4, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_BEFORE,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 0);\n\tgoto cleanup;\n\ncleanup4:\n\terr = bpf_prog_detach_opts(fd4, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\ncleanup3:\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup2:\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\ncleanup1:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_detach_before(void)\n{\n\ttest_tc_opts_detach_before_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_detach_before_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_detach_after_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, fd4, id1, id2, id3, id4;\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[5];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\tfd4 = bpf_program__fd(skel->progs.tc4);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\tid4 = id_from_prog_fd(fd4);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id3, id4, \"prog_ids_3_4\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup1;\n\n\tassert_mprog_count(target, 2);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup2;\n\n\tassert_mprog_count(target, 3);\n\n\terr = bpf_prog_attach_opts(fd4, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup3;\n\n\tassert_mprog_count(target, 4);\n\n\toptq.prog_ids = prog_ids;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id3, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], id4, \"prog_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 3);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 3, \"count\");\n\tASSERT_EQ(optq.revision, 6, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id3, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id4, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], 0, \"prog_ids[3]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_EQ(err, -ENOENT, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd4,\n\t);\n\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_EQ(err, -ERANGE, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd3,\n\t);\n\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_EQ(err, -ERANGE, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_EQ(err, -ERANGE, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 2);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 2, \"count\");\n\tASSERT_EQ(optq.revision, 7, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id4, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], 0, \"prog_ids[2]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t\t.relative_fd = fd1,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 1);\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 8, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\n\tLIBBPF_OPTS_RESET(optd,\n\t\t.flags = BPF_F_AFTER,\n\t);\n\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\n\tassert_mprog_count(target, 0);\n\tgoto cleanup;\n\ncleanup4:\n\terr = bpf_prog_detach_opts(fd4, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\ncleanup3:\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup2:\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\ncleanup1:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_detach_after(void)\n{\n\ttest_tc_opts_detach_after_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_detach_after_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_delete_empty(int target, bool chain_tc_old)\n{\n\tLIBBPF_OPTS(bpf_tc_hook, tc_hook, .ifindex = loopback);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tint err;\n\n\tassert_mprog_count(target, 0);\n\tif (chain_tc_old) {\n\t\ttc_hook.attach_point = target == BPF_TCX_INGRESS ?\n\t\t\t\t       BPF_TC_INGRESS : BPF_TC_EGRESS;\n\t\terr = bpf_tc_hook_create(&tc_hook);\n\t\tASSERT_OK(err, \"bpf_tc_hook_create\");\n\t\tassert_mprog_count(target, 0);\n\t}\n\terr = bpf_prog_detach_opts(0, loopback, target, &optd);\n\tASSERT_EQ(err, -ENOENT, \"prog_detach\");\n\tif (chain_tc_old) {\n\t\ttc_hook.attach_point = BPF_TC_INGRESS | BPF_TC_EGRESS;\n\t\tbpf_tc_hook_destroy(&tc_hook);\n\t}\n\tassert_mprog_count(target, 0);\n}\n\nvoid serial_test_tc_opts_delete_empty(void)\n{\n\ttest_tc_opts_delete_empty(BPF_TCX_INGRESS, false);\n\ttest_tc_opts_delete_empty(BPF_TCX_EGRESS, false);\n\ttest_tc_opts_delete_empty(BPF_TCX_INGRESS, true);\n\ttest_tc_opts_delete_empty(BPF_TCX_EGRESS, true);\n}\n\nstatic void test_tc_chain_mixed(int target)\n{\n\tLIBBPF_OPTS(bpf_tc_opts, tc_opts, .handle = 1, .priority = 1);\n\tLIBBPF_OPTS(bpf_tc_hook, tc_hook, .ifindex = loopback);\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\t__u32 fd1, fd2, fd3, id1, id2, id3;\n\tstruct test_tc_link *skel;\n\tint err, detach_fd;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc4);\n\tfd2 = bpf_program__fd(skel->progs.tc5);\n\tfd3 = bpf_program__fd(skel->progs.tc6);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\n\tASSERT_NEQ(id1, id2, \"prog_ids_1_2\");\n\tASSERT_NEQ(id2, id3, \"prog_ids_2_3\");\n\n\tassert_mprog_count(target, 0);\n\n\ttc_hook.attach_point = target == BPF_TCX_INGRESS ?\n\t\t\t       BPF_TC_INGRESS : BPF_TC_EGRESS;\n\terr = bpf_tc_hook_create(&tc_hook);\n\terr = err == -EEXIST ? 0 : err;\n\tif (!ASSERT_OK(err, \"bpf_tc_hook_create\"))\n\t\tgoto cleanup;\n\n\ttc_opts.prog_fd = fd2;\n\terr = bpf_tc_attach(&tc_hook, &tc_opts);\n\tif (!ASSERT_OK(err, \"bpf_tc_attach\"))\n\t\tgoto cleanup_hook;\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_filter;\n\n\tdetach_fd = fd3;\n\n\tassert_mprog_count(target, 1);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\tASSERT_EQ(skel->bss->seen_tc5, false, \"seen_tc5\");\n\tASSERT_EQ(skel->bss->seen_tc6, true, \"seen_tc6\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.flags = BPF_F_REPLACE,\n\t\t.replace_prog_fd = fd3,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup_opts;\n\n\tdetach_fd = fd1;\n\n\tassert_mprog_count(target, 1);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc4, true, \"seen_tc4\");\n\tASSERT_EQ(skel->bss->seen_tc5, true, \"seen_tc5\");\n\tASSERT_EQ(skel->bss->seen_tc6, false, \"seen_tc6\");\n\ncleanup_opts:\n\terr = bpf_prog_detach_opts(detach_fd, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\n\ttc_skel_reset_all_seen(skel);\n\tASSERT_OK(system(ping_cmd), ping_cmd);\n\n\tASSERT_EQ(skel->bss->seen_tc4, false, \"seen_tc4\");\n\tASSERT_EQ(skel->bss->seen_tc5, true, \"seen_tc5\");\n\tASSERT_EQ(skel->bss->seen_tc6, false, \"seen_tc6\");\n\ncleanup_filter:\n\ttc_opts.flags = tc_opts.prog_fd = tc_opts.prog_id = 0;\n\terr = bpf_tc_detach(&tc_hook, &tc_opts);\n\tASSERT_OK(err, \"bpf_tc_detach\");\n\ncleanup_hook:\n\ttc_hook.attach_point = BPF_TC_INGRESS | BPF_TC_EGRESS;\n\tbpf_tc_hook_destroy(&tc_hook);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_chain_mixed(void)\n{\n\ttest_tc_chain_mixed(BPF_TCX_INGRESS);\n\ttest_tc_chain_mixed(BPF_TCX_EGRESS);\n}\n\nstatic int generate_dummy_prog(void)\n{\n\tconst struct bpf_insn prog_insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tconst size_t prog_insn_cnt = sizeof(prog_insns) / sizeof(struct bpf_insn);\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts);\n\tconst size_t log_buf_sz = 256;\n\tchar *log_buf;\n\tint fd = -1;\n\n\tlog_buf = malloc(log_buf_sz);\n\tif (!ASSERT_OK_PTR(log_buf, \"log_buf_alloc\"))\n\t\treturn fd;\n\topts.log_buf = log_buf;\n\topts.log_size = log_buf_sz;\n\n\tlog_buf[0] = '\\0';\n\topts.log_level = 0;\n\tfd = bpf_prog_load(BPF_PROG_TYPE_SCHED_CLS, \"tcx_prog\", \"GPL\",\n\t\t\t   prog_insns, prog_insn_cnt, &opts);\n\tASSERT_STREQ(log_buf, \"\", \"log_0\");\n\tASSERT_GE(fd, 0, \"prog_fd\");\n\tfree(log_buf);\n\treturn fd;\n}\n\nstatic void test_tc_opts_max_target(int target, int flags, bool relative)\n{\n\tint err, ifindex, i, prog_fd, last_fd = -1;\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tconst int max_progs = 63;\n\n\tASSERT_OK(system(\"ip link add dev tcx_opts1 type veth peer name tcx_opts2\"), \"add veth\");\n\tifindex = if_nametoindex(\"tcx_opts1\");\n\tASSERT_NEQ(ifindex, 0, \"non_zero_ifindex\");\n\n\tassert_mprog_count_ifindex(ifindex, target, 0);\n\n\tfor (i = 0; i < max_progs; i++) {\n\t\tprog_fd = generate_dummy_prog();\n\t\tif (!ASSERT_GE(prog_fd, 0, \"dummy_prog\"))\n\t\t\tgoto cleanup;\n\t\terr = bpf_prog_attach_opts(prog_fd, ifindex, target, &opta);\n\t\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\t\tgoto cleanup;\n\t\tassert_mprog_count_ifindex(ifindex, target, i + 1);\n\t\tif (i == max_progs - 1 && relative)\n\t\t\tlast_fd = prog_fd;\n\t\telse\n\t\t\tclose(prog_fd);\n\t}\n\n\tprog_fd = generate_dummy_prog();\n\tif (!ASSERT_GE(prog_fd, 0, \"dummy_prog\"))\n\t\tgoto cleanup;\n\topta.flags = flags;\n\tif (last_fd > 0)\n\t\topta.relative_fd = last_fd;\n\terr = bpf_prog_attach_opts(prog_fd, ifindex, target, &opta);\n\tASSERT_EQ(err, -ERANGE, \"prog_64_attach\");\n\tassert_mprog_count_ifindex(ifindex, target, max_progs);\n\tclose(prog_fd);\ncleanup:\n\tif (last_fd > 0)\n\t\tclose(last_fd);\n\tASSERT_OK(system(\"ip link del dev tcx_opts1\"), \"del veth\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts1\"), 0, \"dev1_removed\");\n\tASSERT_EQ(if_nametoindex(\"tcx_opts2\"), 0, \"dev2_removed\");\n}\n\nvoid serial_test_tc_opts_max(void)\n{\n\ttest_tc_opts_max_target(BPF_TCX_INGRESS, 0, false);\n\ttest_tc_opts_max_target(BPF_TCX_EGRESS, 0, false);\n\n\ttest_tc_opts_max_target(BPF_TCX_INGRESS, BPF_F_BEFORE, false);\n\ttest_tc_opts_max_target(BPF_TCX_EGRESS, BPF_F_BEFORE, true);\n\n\ttest_tc_opts_max_target(BPF_TCX_INGRESS, BPF_F_AFTER, true);\n\ttest_tc_opts_max_target(BPF_TCX_EGRESS, BPF_F_AFTER, false);\n}\n\nstatic void test_tc_opts_query_target(int target)\n{\n\tconst size_t attr_size = offsetofend(union bpf_attr, query);\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\t__u32 fd1, fd2, fd3, fd4, id1, id2, id3, id4;\n\tstruct test_tc_link *skel;\n\tunion bpf_attr attr;\n\t__u32 prog_ids[5];\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tfd2 = bpf_program__fd(skel->progs.tc2);\n\tfd3 = bpf_program__fd(skel->progs.tc3);\n\tfd4 = bpf_program__fd(skel->progs.tc4);\n\n\tid1 = id_from_prog_fd(fd1);\n\tid2 = id_from_prog_fd(fd2);\n\tid3 = id_from_prog_fd(fd3);\n\tid4 = id_from_prog_fd(fd4);\n\n\tassert_mprog_count(target, 0);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.expected_revision = 1,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tassert_mprog_count(target, 1);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.expected_revision = 2,\n\t);\n\n\terr = bpf_prog_attach_opts(fd2, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup1;\n\n\tassert_mprog_count(target, 2);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.expected_revision = 3,\n\t);\n\n\terr = bpf_prog_attach_opts(fd3, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup2;\n\n\tassert_mprog_count(target, 3);\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.expected_revision = 4,\n\t);\n\n\terr = bpf_prog_attach_opts(fd4, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup3;\n\n\tassert_mprog_count(target, 4);\n\n\t \n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids, NULL, \"prog_ids\");\n\tASSERT_EQ(optq.link_ids, NULL, \"link_ids\");\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.prog_ids = prog_ids;\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(optq.count, 4, \"count\");\n\tASSERT_EQ(optq.revision, 5, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(optq.prog_ids[2], id3, \"prog_ids[2]\");\n\tASSERT_EQ(optq.prog_ids[3], id4, \"prog_ids[3]\");\n\tASSERT_EQ(optq.prog_ids[4], 0, \"prog_ids[4]\");\n\tASSERT_EQ(optq.link_ids, NULL, \"link_ids\");\n\n\t \n\tmemset(&attr, 0, attr_size);\n\tattr.query.target_ifindex = loopback;\n\tattr.query.attach_type = target;\n\n\terr = syscall(__NR_bpf, BPF_PROG_QUERY, &attr, attr_size);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(attr.query.count, 4, \"count\");\n\tASSERT_EQ(attr.query.revision, 5, \"revision\");\n\tASSERT_EQ(attr.query.query_flags, 0, \"query_flags\");\n\tASSERT_EQ(attr.query.attach_flags, 0, \"attach_flags\");\n\tASSERT_EQ(attr.query.target_ifindex, loopback, \"target_ifindex\");\n\tASSERT_EQ(attr.query.attach_type, target, \"attach_type\");\n\tASSERT_EQ(attr.query.prog_ids, 0, \"prog_ids\");\n\tASSERT_EQ(attr.query.prog_attach_flags, 0, \"prog_attach_flags\");\n\tASSERT_EQ(attr.query.link_ids, 0, \"link_ids\");\n\tASSERT_EQ(attr.query.link_attach_flags, 0, \"link_attach_flags\");\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\tattr.query.prog_ids = ptr_to_u64(prog_ids);\n\n\terr = syscall(__NR_bpf, BPF_PROG_QUERY, &attr, attr_size);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup4;\n\n\tASSERT_EQ(attr.query.count, 4, \"count\");\n\tASSERT_EQ(attr.query.revision, 5, \"revision\");\n\tASSERT_EQ(attr.query.query_flags, 0, \"query_flags\");\n\tASSERT_EQ(attr.query.attach_flags, 0, \"attach_flags\");\n\tASSERT_EQ(attr.query.target_ifindex, loopback, \"target_ifindex\");\n\tASSERT_EQ(attr.query.attach_type, target, \"attach_type\");\n\tASSERT_EQ(attr.query.prog_ids, ptr_to_u64(prog_ids), \"prog_ids\");\n\tASSERT_EQ(prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(prog_ids[1], id2, \"prog_ids[1]\");\n\tASSERT_EQ(prog_ids[2], id3, \"prog_ids[2]\");\n\tASSERT_EQ(prog_ids[3], id4, \"prog_ids[3]\");\n\tASSERT_EQ(prog_ids[4], 0, \"prog_ids[4]\");\n\tASSERT_EQ(attr.query.prog_attach_flags, 0, \"prog_attach_flags\");\n\tASSERT_EQ(attr.query.link_ids, 0, \"link_ids\");\n\tASSERT_EQ(attr.query.link_attach_flags, 0, \"link_attach_flags\");\n\ncleanup4:\n\terr = bpf_prog_detach_opts(fd4, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 3);\n\ncleanup3:\n\terr = bpf_prog_detach_opts(fd3, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 2);\n\ncleanup2:\n\terr = bpf_prog_detach_opts(fd2, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 1);\n\ncleanup1:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\n\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_query(void)\n{\n\ttest_tc_opts_query_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_query_target(BPF_TCX_EGRESS);\n}\n\nstatic void test_tc_opts_query_attach_target(int target)\n{\n\tLIBBPF_OPTS(bpf_prog_attach_opts, opta);\n\tLIBBPF_OPTS(bpf_prog_detach_opts, optd);\n\tLIBBPF_OPTS(bpf_prog_query_opts, optq);\n\tstruct test_tc_link *skel;\n\t__u32 prog_ids[2];\n\t__u32 fd1, id1;\n\tint err;\n\n\tskel = test_tc_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"skel_load\"))\n\t\tgoto cleanup;\n\n\tfd1 = bpf_program__fd(skel->progs.tc1);\n\tid1 = id_from_prog_fd(fd1);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(optq.count, 0, \"count\");\n\tASSERT_EQ(optq.revision, 1, \"revision\");\n\n\tLIBBPF_OPTS_RESET(opta,\n\t\t.expected_revision = optq.revision,\n\t);\n\n\terr = bpf_prog_attach_opts(fd1, loopback, target, &opta);\n\tif (!ASSERT_EQ(err, 0, \"prog_attach\"))\n\t\tgoto cleanup;\n\n\tmemset(prog_ids, 0, sizeof(prog_ids));\n\toptq.prog_ids = prog_ids;\n\toptq.count = ARRAY_SIZE(prog_ids);\n\n\terr = bpf_prog_query_opts(loopback, target, &optq);\n\tif (!ASSERT_OK(err, \"prog_query\"))\n\t\tgoto cleanup1;\n\n\tASSERT_EQ(optq.count, 1, \"count\");\n\tASSERT_EQ(optq.revision, 2, \"revision\");\n\tASSERT_EQ(optq.prog_ids[0], id1, \"prog_ids[0]\");\n\tASSERT_EQ(optq.prog_ids[1], 0, \"prog_ids[1]\");\n\ncleanup1:\n\terr = bpf_prog_detach_opts(fd1, loopback, target, &optd);\n\tASSERT_OK(err, \"prog_detach\");\n\tassert_mprog_count(target, 0);\ncleanup:\n\ttest_tc_link__destroy(skel);\n}\n\nvoid serial_test_tc_opts_query_attach(void)\n{\n\ttest_tc_opts_query_attach_target(BPF_TCX_INGRESS);\n\ttest_tc_opts_query_attach_target(BPF_TCX_EGRESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}