{
  "module_name": "bpf_loop.c",
  "hash_id": "28da085f5729f1adf258edafcb55abb4a8f7496ca253967076becbc02c4c727b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bpf_loop.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n#include <network_helpers.h>\n#include \"bpf_loop.skel.h\"\n\nstatic void check_nr_loops(struct bpf_loop *skel)\n{\n\tstruct bpf_link *link;\n\n\tlink = bpf_program__attach(skel->progs.test_prog);\n\tif (!ASSERT_OK_PTR(link, \"link\"))\n\t\treturn;\n\n\t \n\tskel->bss->nr_loops = 0;\n\n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->nr_loops_returned, skel->bss->nr_loops,\n\t\t  \"0 loops\");\n\n\t \n\tskel->bss->nr_loops = 500;\n\n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->nr_loops_returned, skel->bss->nr_loops,\n\t\t  \"500 loops\");\n\tASSERT_EQ(skel->bss->g_output, (500 * 499) / 2, \"g_output\");\n\n\t \n\tskel->bss->nr_loops = -1;\n\n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->err, -E2BIG, \"over max limit\");\n\n\tbpf_link__destroy(link);\n}\n\nstatic void check_callback_fn_stop(struct bpf_loop *skel)\n{\n\tstruct bpf_link *link;\n\n\tlink = bpf_program__attach(skel->progs.test_prog);\n\tif (!ASSERT_OK_PTR(link, \"link\"))\n\t\treturn;\n\n\t \n\tskel->bss->nr_loops = 400;\n\tskel->data->stop_index = 50;\n\n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->nr_loops_returned, skel->data->stop_index + 1,\n\t\t  \"nr_loops_returned\");\n\tASSERT_EQ(skel->bss->g_output, (50 * 49) / 2,\n\t\t  \"g_output\");\n\n\tbpf_link__destroy(link);\n}\n\nstatic void check_null_callback_ctx(struct bpf_loop *skel)\n{\n\tstruct bpf_link *link;\n\n\t \n\tlink = bpf_program__attach(skel->progs.prog_null_ctx);\n\tif (!ASSERT_OK_PTR(link, \"link\"))\n\t\treturn;\n\n\tskel->bss->nr_loops = 10;\n\n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->nr_loops_returned, skel->bss->nr_loops,\n\t\t  \"nr_loops_returned\");\n\n\tbpf_link__destroy(link);\n}\n\nstatic void check_invalid_flags(struct bpf_loop *skel)\n{\n\tstruct bpf_link *link;\n\n\t \n\tlink = bpf_program__attach(skel->progs.prog_invalid_flags);\n\tif (!ASSERT_OK_PTR(link, \"link\"))\n\t\treturn;\n\n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->err, -EINVAL, \"err\");\n\n\tbpf_link__destroy(link);\n}\n\nstatic void check_nested_calls(struct bpf_loop *skel)\n{\n\t__u32 nr_loops = 100, nested_callback_nr_loops = 4;\n\tstruct bpf_link *link;\n\n\t \n\tlink = bpf_program__attach(skel->progs.prog_nested_calls);\n\tif (!ASSERT_OK_PTR(link, \"link\"))\n\t\treturn;\n\n\tskel->bss->nr_loops = nr_loops;\n\tskel->bss->nested_callback_nr_loops = nested_callback_nr_loops;\n\n\tusleep(1);\n\n\tASSERT_EQ(skel->bss->nr_loops_returned, nr_loops * nested_callback_nr_loops\n\t\t  * nested_callback_nr_loops, \"nr_loops_returned\");\n\tASSERT_EQ(skel->bss->g_output, (4 * 3) / 2 * nested_callback_nr_loops\n\t\t* nr_loops, \"g_output\");\n\n\tbpf_link__destroy(link);\n}\n\nstatic void check_non_constant_callback(struct bpf_loop *skel)\n{\n\tstruct bpf_link *link =\n\t\tbpf_program__attach(skel->progs.prog_non_constant_callback);\n\n\tif (!ASSERT_OK_PTR(link, \"link\"))\n\t\treturn;\n\n\tskel->bss->callback_selector = 0x0F;\n\tusleep(1);\n\tASSERT_EQ(skel->bss->g_output, 0x0F, \"g_output #1\");\n\n\tskel->bss->callback_selector = 0xF0;\n\tusleep(1);\n\tASSERT_EQ(skel->bss->g_output, 0xF0, \"g_output #2\");\n\n\tbpf_link__destroy(link);\n}\n\nstatic void check_stack(struct bpf_loop *skel)\n{\n\tstruct bpf_link *link = bpf_program__attach(skel->progs.stack_check);\n\tconst int max_key = 12;\n\tint key;\n\tint map_fd;\n\n\tif (!ASSERT_OK_PTR(link, \"link\"))\n\t\treturn;\n\n\tmap_fd = bpf_map__fd(skel->maps.map1);\n\n\tif (!ASSERT_GE(map_fd, 0, \"bpf_map__fd\"))\n\t\tgoto out;\n\n\tfor (key = 1; key <= max_key; ++key) {\n\t\tint val = key;\n\t\tint err = bpf_map_update_elem(map_fd, &key, &val, BPF_NOEXIST);\n\n\t\tif (!ASSERT_OK(err, \"bpf_map_update_elem\"))\n\t\t\tgoto out;\n\t}\n\n\tusleep(1);\n\n\tfor (key = 1; key <= max_key; ++key) {\n\t\tint val;\n\t\tint err = bpf_map_lookup_elem(map_fd, &key, &val);\n\n\t\tif (!ASSERT_OK(err, \"bpf_map_lookup_elem\"))\n\t\t\tgoto out;\n\t\tif (!ASSERT_EQ(val, key + 1, \"bad value in the map\"))\n\t\t\tgoto out;\n\t}\n\nout:\n\tbpf_link__destroy(link);\n}\n\nvoid test_bpf_loop(void)\n{\n\tstruct bpf_loop *skel;\n\n\tskel = bpf_loop__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_loop__open_and_load\"))\n\t\treturn;\n\n\tskel->bss->pid = getpid();\n\n\tif (test__start_subtest(\"check_nr_loops\"))\n\t\tcheck_nr_loops(skel);\n\tif (test__start_subtest(\"check_callback_fn_stop\"))\n\t\tcheck_callback_fn_stop(skel);\n\tif (test__start_subtest(\"check_null_callback_ctx\"))\n\t\tcheck_null_callback_ctx(skel);\n\tif (test__start_subtest(\"check_invalid_flags\"))\n\t\tcheck_invalid_flags(skel);\n\tif (test__start_subtest(\"check_nested_calls\"))\n\t\tcheck_nested_calls(skel);\n\tif (test__start_subtest(\"check_non_constant_callback\"))\n\t\tcheck_non_constant_callback(skel);\n\tif (test__start_subtest(\"check_stack\"))\n\t\tcheck_stack(skel);\n\n\tbpf_loop__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}