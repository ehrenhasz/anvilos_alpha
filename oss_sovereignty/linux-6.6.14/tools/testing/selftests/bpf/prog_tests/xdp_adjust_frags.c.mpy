{
  "module_name": "xdp_adjust_frags.c",
  "hash_id": "168ac23b5a8b70ea119725838cfc909217ebee2c42c2e731698aebcf94f7ee12",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/xdp_adjust_frags.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include <network_helpers.h>\n\nstatic void test_xdp_update_frags(void)\n{\n\tconst char *file = \"./test_xdp_update_frags.bpf.o\";\n\tint err, prog_fd, max_skb_frags, buf_size, num;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\t__u32 *offset;\n\t__u8 *buf;\n\tFILE *f;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts);\n\n\tobj = bpf_object__open(file);\n\tif (libbpf_get_error(obj))\n\t\treturn;\n\n\tprog = bpf_object__next_program(obj, NULL);\n\tif (bpf_object__load(obj))\n\t\treturn;\n\n\tprog_fd = bpf_program__fd(prog);\n\n\tbuf = malloc(128);\n\tif (!ASSERT_OK_PTR(buf, \"alloc buf 128b\"))\n\t\tgoto out;\n\n\tmemset(buf, 0, 128);\n\toffset = (__u32 *)buf;\n\t*offset = 16;\n\tbuf[*offset] = 0xaa;\t\t \n\tbuf[*offset + 15] = 0xaa;\t \n\n\ttopts.data_in = buf;\n\ttopts.data_out = buf;\n\ttopts.data_size_in = 128;\n\ttopts.data_size_out = 128;\n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\n\t \n\tASSERT_OK(err, \"xdp_update_frag\");\n\tASSERT_EQ(topts.retval, XDP_PASS, \"xdp_update_frag retval\");\n\tASSERT_EQ(buf[16], 0xbb, \"xdp_update_frag buf[16]\");\n\tASSERT_EQ(buf[31], 0xbb, \"xdp_update_frag buf[31]\");\n\n\tfree(buf);\n\n\tbuf = malloc(9000);\n\tif (!ASSERT_OK_PTR(buf, \"alloc buf 9Kb\"))\n\t\tgoto out;\n\n\tmemset(buf, 0, 9000);\n\toffset = (__u32 *)buf;\n\t*offset = 5000;\n\tbuf[*offset] = 0xaa;\t\t \n\tbuf[*offset + 15] = 0xaa;\t \n\n\ttopts.data_in = buf;\n\ttopts.data_out = buf;\n\ttopts.data_size_in = 9000;\n\ttopts.data_size_out = 9000;\n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\n\t \n\tASSERT_OK(err, \"xdp_update_frag\");\n\tASSERT_EQ(topts.retval, XDP_PASS, \"xdp_update_frag retval\");\n\tASSERT_EQ(buf[5000], 0xbb, \"xdp_update_frag buf[5000]\");\n\tASSERT_EQ(buf[5015], 0xbb, \"xdp_update_frag buf[5015]\");\n\n\tmemset(buf, 0, 9000);\n\toffset = (__u32 *)buf;\n\t*offset = 3510;\n\tbuf[*offset] = 0xaa;\t\t \n\tbuf[*offset + 15] = 0xaa;\t \n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\n\t \n\tASSERT_OK(err, \"xdp_update_frag\");\n\tASSERT_EQ(topts.retval, XDP_PASS, \"xdp_update_frag retval\");\n\tASSERT_EQ(buf[3510], 0xbb, \"xdp_update_frag buf[3510]\");\n\tASSERT_EQ(buf[3525], 0xbb, \"xdp_update_frag buf[3525]\");\n\n\tmemset(buf, 0, 9000);\n\toffset = (__u32 *)buf;\n\t*offset = 7606;\n\tbuf[*offset] = 0xaa;\t\t \n\tbuf[*offset + 15] = 0xaa;\t \n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\n\t \n\tASSERT_OK(err, \"xdp_update_frag\");\n\tASSERT_EQ(topts.retval, XDP_PASS, \"xdp_update_frag retval\");\n\tASSERT_EQ(buf[7606], 0xbb, \"xdp_update_frag buf[7606]\");\n\tASSERT_EQ(buf[7621], 0xbb, \"xdp_update_frag buf[7621]\");\n\n\tfree(buf);\n\n\t \n\tf = fopen(\"/proc/sys/net/core/max_skb_frags\", \"r\");\n\tif (!ASSERT_OK_PTR(f, \"max_skb_frag file pointer\"))\n\t\tgoto out;\n\n\tnum = fscanf(f, \"%d\", &max_skb_frags);\n\tfclose(f);\n\n\tif (!ASSERT_EQ(num, 1, \"max_skb_frags read failed\"))\n\t\tgoto out;\n\n\t \n\tbuf_size = 4096 + (max_skb_frags + 1) * sysconf(_SC_PAGE_SIZE);\n\tbuf = malloc(buf_size);\n\tif (!ASSERT_OK_PTR(buf, \"alloc buf\"))\n\t\tgoto out;\n\n\tmemset(buf, 0, buf_size);\n\toffset = (__u32 *)buf;\n\t*offset = 16;\n\tbuf[*offset] = 0xaa;\n\tbuf[*offset + 15] = 0xaa;\n\n\ttopts.data_in = buf;\n\ttopts.data_out = buf;\n\ttopts.data_size_in = buf_size;\n\ttopts.data_size_out = buf_size;\n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_EQ(err, -ENOMEM,\n\t\t  \"unsupported buf size, possible non-default /proc/sys/net/core/max_skb_flags?\");\n\tfree(buf);\nout:\n\tbpf_object__close(obj);\n}\n\nvoid test_xdp_adjust_frags(void)\n{\n\tif (test__start_subtest(\"xdp_adjust_frags\"))\n\t\ttest_xdp_update_frags();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}