{
  "module_name": "select_reuseport.c",
  "hash_id": "042579a41a3cacade30992423b6d87d47bf0a6981ab21df915bd4159c1ff2f25",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/select_reuseport.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <string.h>\n#include <errno.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <linux/bpf.h>\n#include <linux/err.h>\n#include <linux/types.h>\n#include <linux/if_ether.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include \"bpf_util.h\"\n\n#include \"test_progs.h\"\n#include \"test_select_reuseport_common.h\"\n\n#define MAX_TEST_NAME 80\n#define MIN_TCPHDR_LEN 20\n#define UDPHDR_LEN 8\n\n#define TCP_SYNCOOKIE_SYSCTL \"/proc/sys/net/ipv4/tcp_syncookies\"\n#define TCP_FO_SYSCTL \"/proc/sys/net/ipv4/tcp_fastopen\"\n#define REUSEPORT_ARRAY_SIZE 32\n\nstatic int result_map, tmp_index_ovr_map, linum_map, data_check_map;\nstatic __u32 expected_results[NR_RESULTS];\nstatic int sk_fds[REUSEPORT_ARRAY_SIZE];\nstatic int reuseport_array = -1, outer_map = -1;\nstatic enum bpf_map_type inner_map_type;\nstatic int select_by_skb_data_prog;\nstatic int saved_tcp_syncookie = -1;\nstatic struct bpf_object *obj;\nstatic int saved_tcp_fo = -1;\nstatic __u32 index_zero;\nstatic int epfd;\n\nstatic union sa46 {\n\tstruct sockaddr_in6 v6;\n\tstruct sockaddr_in v4;\n\tsa_family_t family;\n} srv_sa;\n\n#define RET_IF(condition, tag, format...) ({\t\t\t\t\\\n\tif (CHECK_FAIL(condition)) {\t\t\t\t\t\\\n\t\tprintf(tag \" \" format);\t\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n})\n\n#define RET_ERR(condition, tag, format...) ({\t\t\t\t\\\n\tif (CHECK_FAIL(condition)) {\t\t\t\t\t\\\n\t\tprintf(tag \" \" format);\t\t\t\t\t\\\n\t\treturn -1;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n})\n\nstatic int create_maps(enum bpf_map_type inner_type)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts);\n\n\tinner_map_type = inner_type;\n\n\t \n\treuseport_array = bpf_map_create(inner_type, \"reuseport_array\",\n\t\t\t\t\t sizeof(__u32), sizeof(__u32), REUSEPORT_ARRAY_SIZE, NULL);\n\tRET_ERR(reuseport_array < 0, \"creating reuseport_array\",\n\t\t\"reuseport_array:%d errno:%d\\n\", reuseport_array, errno);\n\n\t \n\topts.inner_map_fd = reuseport_array;\n\touter_map = bpf_map_create(BPF_MAP_TYPE_ARRAY_OF_MAPS, \"outer_map\",\n\t\t\t\t   sizeof(__u32), sizeof(__u32), 1, &opts);\n\tRET_ERR(outer_map < 0, \"creating outer_map\",\n\t\t\"outer_map:%d errno:%d\\n\", outer_map, errno);\n\n\treturn 0;\n}\n\nstatic int prepare_bpf_obj(void)\n{\n\tstruct bpf_program *prog;\n\tstruct bpf_map *map;\n\tint err;\n\n\tobj = bpf_object__open(\"test_select_reuseport_kern.bpf.o\");\n\terr = libbpf_get_error(obj);\n\tRET_ERR(err, \"open test_select_reuseport_kern.bpf.o\",\n\t\t\"obj:%p PTR_ERR(obj):%d\\n\", obj, err);\n\n\tmap = bpf_object__find_map_by_name(obj, \"outer_map\");\n\tRET_ERR(!map, \"find outer_map\", \"!map\\n\");\n\terr = bpf_map__reuse_fd(map, outer_map);\n\tRET_ERR(err, \"reuse outer_map\", \"err:%d\\n\", err);\n\n\terr = bpf_object__load(obj);\n\tRET_ERR(err, \"load bpf_object\", \"err:%d\\n\", err);\n\n\tprog = bpf_object__next_program(obj, NULL);\n\tRET_ERR(!prog, \"get first bpf_program\", \"!prog\\n\");\n\tselect_by_skb_data_prog = bpf_program__fd(prog);\n\tRET_ERR(select_by_skb_data_prog < 0, \"get prog fd\",\n\t\t\"select_by_skb_data_prog:%d\\n\", select_by_skb_data_prog);\n\n\tmap = bpf_object__find_map_by_name(obj, \"result_map\");\n\tRET_ERR(!map, \"find result_map\", \"!map\\n\");\n\tresult_map = bpf_map__fd(map);\n\tRET_ERR(result_map < 0, \"get result_map fd\",\n\t\t\"result_map:%d\\n\", result_map);\n\n\tmap = bpf_object__find_map_by_name(obj, \"tmp_index_ovr_map\");\n\tRET_ERR(!map, \"find tmp_index_ovr_map\\n\", \"!map\");\n\ttmp_index_ovr_map = bpf_map__fd(map);\n\tRET_ERR(tmp_index_ovr_map < 0, \"get tmp_index_ovr_map fd\",\n\t\t\"tmp_index_ovr_map:%d\\n\", tmp_index_ovr_map);\n\n\tmap = bpf_object__find_map_by_name(obj, \"linum_map\");\n\tRET_ERR(!map, \"find linum_map\", \"!map\\n\");\n\tlinum_map = bpf_map__fd(map);\n\tRET_ERR(linum_map < 0, \"get linum_map fd\",\n\t\t\"linum_map:%d\\n\", linum_map);\n\n\tmap = bpf_object__find_map_by_name(obj, \"data_check_map\");\n\tRET_ERR(!map, \"find data_check_map\", \"!map\\n\");\n\tdata_check_map = bpf_map__fd(map);\n\tRET_ERR(data_check_map < 0, \"get data_check_map fd\",\n\t\t\"data_check_map:%d\\n\", data_check_map);\n\n\treturn 0;\n}\n\nstatic void sa46_init_loopback(union sa46 *sa, sa_family_t family)\n{\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->family = family;\n\tif (sa->family == AF_INET6)\n\t\tsa->v6.sin6_addr = in6addr_loopback;\n\telse\n\t\tsa->v4.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n}\n\nstatic void sa46_init_inany(union sa46 *sa, sa_family_t family)\n{\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->family = family;\n\tif (sa->family == AF_INET6)\n\t\tsa->v6.sin6_addr = in6addr_any;\n\telse\n\t\tsa->v4.sin_addr.s_addr = INADDR_ANY;\n}\n\nstatic int read_int_sysctl(const char *sysctl)\n{\n\tchar buf[16];\n\tint fd, ret;\n\n\tfd = open(sysctl, 0);\n\tRET_ERR(fd == -1, \"open(sysctl)\",\n\t\t\"sysctl:%s fd:%d errno:%d\\n\", sysctl, fd, errno);\n\n\tret = read(fd, buf, sizeof(buf));\n\tRET_ERR(ret <= 0, \"read(sysctl)\",\n\t\t\"sysctl:%s ret:%d errno:%d\\n\", sysctl, ret, errno);\n\n\tclose(fd);\n\treturn atoi(buf);\n}\n\nstatic int write_int_sysctl(const char *sysctl, int v)\n{\n\tint fd, ret, size;\n\tchar buf[16];\n\n\tfd = open(sysctl, O_RDWR);\n\tRET_ERR(fd == -1, \"open(sysctl)\",\n\t\t\"sysctl:%s fd:%d errno:%d\\n\", sysctl, fd, errno);\n\n\tsize = snprintf(buf, sizeof(buf), \"%d\", v);\n\tret = write(fd, buf, size);\n\tRET_ERR(ret != size, \"write(sysctl)\",\n\t\t\"sysctl:%s ret:%d size:%d errno:%d\\n\",\n\t\tsysctl, ret, size, errno);\n\n\tclose(fd);\n\treturn 0;\n}\n\nstatic void restore_sysctls(void)\n{\n\tif (saved_tcp_fo != -1)\n\t\twrite_int_sysctl(TCP_FO_SYSCTL, saved_tcp_fo);\n\tif (saved_tcp_syncookie != -1)\n\t\twrite_int_sysctl(TCP_SYNCOOKIE_SYSCTL, saved_tcp_syncookie);\n}\n\nstatic int enable_fastopen(void)\n{\n\tint fo;\n\n\tfo = read_int_sysctl(TCP_FO_SYSCTL);\n\tif (fo < 0)\n\t\treturn -1;\n\n\treturn write_int_sysctl(TCP_FO_SYSCTL, fo | 7);\n}\n\nstatic int enable_syncookie(void)\n{\n\treturn write_int_sysctl(TCP_SYNCOOKIE_SYSCTL, 2);\n}\n\nstatic int disable_syncookie(void)\n{\n\treturn write_int_sysctl(TCP_SYNCOOKIE_SYSCTL, 0);\n}\n\nstatic long get_linum(void)\n{\n\t__u32 linum;\n\tint err;\n\n\terr = bpf_map_lookup_elem(linum_map, &index_zero, &linum);\n\tRET_ERR(err < 0, \"lookup_elem(linum_map)\", \"err:%d errno:%d\\n\",\n\t\terr, errno);\n\n\treturn linum;\n}\n\nstatic void check_data(int type, sa_family_t family, const struct cmd *cmd,\n\t\t       int cli_fd)\n{\n\tstruct data_check expected = {}, result;\n\tunion sa46 cli_sa;\n\tsocklen_t addrlen;\n\tint err;\n\n\taddrlen = sizeof(cli_sa);\n\terr = getsockname(cli_fd, (struct sockaddr *)&cli_sa,\n\t\t\t  &addrlen);\n\tRET_IF(err < 0, \"getsockname(cli_fd)\", \"err:%d errno:%d\\n\",\n\t       err, errno);\n\n\terr = bpf_map_lookup_elem(data_check_map, &index_zero, &result);\n\tRET_IF(err < 0, \"lookup_elem(data_check_map)\", \"err:%d errno:%d\\n\",\n\t       err, errno);\n\n\tif (type == SOCK_STREAM) {\n\t\texpected.len = MIN_TCPHDR_LEN;\n\t\texpected.ip_protocol = IPPROTO_TCP;\n\t} else {\n\t\texpected.len = UDPHDR_LEN;\n\t\texpected.ip_protocol = IPPROTO_UDP;\n\t}\n\n\tif (family == AF_INET6) {\n\t\texpected.eth_protocol = htons(ETH_P_IPV6);\n\t\texpected.bind_inany = !srv_sa.v6.sin6_addr.s6_addr32[3] &&\n\t\t\t!srv_sa.v6.sin6_addr.s6_addr32[2] &&\n\t\t\t!srv_sa.v6.sin6_addr.s6_addr32[1] &&\n\t\t\t!srv_sa.v6.sin6_addr.s6_addr32[0];\n\n\t\tmemcpy(&expected.skb_addrs[0], cli_sa.v6.sin6_addr.s6_addr32,\n\t\t       sizeof(cli_sa.v6.sin6_addr));\n\t\tmemcpy(&expected.skb_addrs[4], &in6addr_loopback,\n\t\t       sizeof(in6addr_loopback));\n\t\texpected.skb_ports[0] = cli_sa.v6.sin6_port;\n\t\texpected.skb_ports[1] = srv_sa.v6.sin6_port;\n\t} else {\n\t\texpected.eth_protocol = htons(ETH_P_IP);\n\t\texpected.bind_inany = !srv_sa.v4.sin_addr.s_addr;\n\n\t\texpected.skb_addrs[0] = cli_sa.v4.sin_addr.s_addr;\n\t\texpected.skb_addrs[1] = htonl(INADDR_LOOPBACK);\n\t\texpected.skb_ports[0] = cli_sa.v4.sin_port;\n\t\texpected.skb_ports[1] = srv_sa.v4.sin_port;\n\t}\n\n\tif (memcmp(&result, &expected, offsetof(struct data_check,\n\t\t\t\t\t\tequal_check_end))) {\n\t\tprintf(\"unexpected data_check\\n\");\n\t\tprintf(\"  result: (0x%x, %u, %u)\\n\",\n\t\t       result.eth_protocol, result.ip_protocol,\n\t\t       result.bind_inany);\n\t\tprintf(\"expected: (0x%x, %u, %u)\\n\",\n\t\t       expected.eth_protocol, expected.ip_protocol,\n\t\t       expected.bind_inany);\n\t\tRET_IF(1, \"data_check result != expected\",\n\t\t       \"bpf_prog_linum:%ld\\n\", get_linum());\n\t}\n\n\tRET_IF(!result.hash, \"data_check result.hash empty\",\n\t       \"result.hash:%u\", result.hash);\n\n\texpected.len += cmd ? sizeof(*cmd) : 0;\n\tif (type == SOCK_STREAM)\n\t\tRET_IF(expected.len > result.len, \"expected.len > result.len\",\n\t\t       \"expected.len:%u result.len:%u bpf_prog_linum:%ld\\n\",\n\t\t       expected.len, result.len, get_linum());\n\telse\n\t\tRET_IF(expected.len != result.len, \"expected.len != result.len\",\n\t\t       \"expected.len:%u result.len:%u bpf_prog_linum:%ld\\n\",\n\t\t       expected.len, result.len, get_linum());\n}\n\nstatic const char *result_to_str(enum result res)\n{\n\tswitch (res) {\n\tcase DROP_ERR_INNER_MAP:\n\t\treturn \"DROP_ERR_INNER_MAP\";\n\tcase DROP_ERR_SKB_DATA:\n\t\treturn \"DROP_ERR_SKB_DATA\";\n\tcase DROP_ERR_SK_SELECT_REUSEPORT:\n\t\treturn \"DROP_ERR_SK_SELECT_REUSEPORT\";\n\tcase DROP_MISC:\n\t\treturn \"DROP_MISC\";\n\tcase PASS:\n\t\treturn \"PASS\";\n\tcase PASS_ERR_SK_SELECT_REUSEPORT:\n\t\treturn \"PASS_ERR_SK_SELECT_REUSEPORT\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic void check_results(void)\n{\n\t__u32 results[NR_RESULTS];\n\t__u32 i, broken = 0;\n\tint err;\n\n\tfor (i = 0; i < NR_RESULTS; i++) {\n\t\terr = bpf_map_lookup_elem(result_map, &i, &results[i]);\n\t\tRET_IF(err < 0, \"lookup_elem(result_map)\",\n\t\t       \"i:%u err:%d errno:%d\\n\", i, err, errno);\n\t}\n\n\tfor (i = 0; i < NR_RESULTS; i++) {\n\t\tif (results[i] != expected_results[i]) {\n\t\t\tbroken = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == NR_RESULTS)\n\t\treturn;\n\n\tprintf(\"unexpected result\\n\");\n\tprintf(\" result: [\");\n\tprintf(\"%u\", results[0]);\n\tfor (i = 1; i < NR_RESULTS; i++)\n\t\tprintf(\", %u\", results[i]);\n\tprintf(\"]\\n\");\n\n\tprintf(\"expected: [\");\n\tprintf(\"%u\", expected_results[0]);\n\tfor (i = 1; i < NR_RESULTS; i++)\n\t\tprintf(\", %u\", expected_results[i]);\n\tprintf(\"]\\n\");\n\n\tprintf(\"mismatch on %s (bpf_prog_linum:%ld)\\n\", result_to_str(broken),\n\t       get_linum());\n\n\tCHECK_FAIL(true);\n}\n\nstatic int send_data(int type, sa_family_t family, void *data, size_t len,\n\t\t     enum result expected)\n{\n\tunion sa46 cli_sa;\n\tint fd, err;\n\n\tfd = socket(family, type, 0);\n\tRET_ERR(fd == -1, \"socket()\", \"fd:%d errno:%d\\n\", fd, errno);\n\n\tsa46_init_loopback(&cli_sa, family);\n\terr = bind(fd, (struct sockaddr *)&cli_sa, sizeof(cli_sa));\n\tRET_ERR(fd == -1, \"bind(cli_sa)\", \"err:%d errno:%d\\n\", err, errno);\n\n\terr = sendto(fd, data, len, MSG_FASTOPEN, (struct sockaddr *)&srv_sa,\n\t\t     sizeof(srv_sa));\n\tRET_ERR(err != len && expected >= PASS,\n\t\t\"sendto()\", \"family:%u err:%d errno:%d expected:%d\\n\",\n\t\tfamily, err, errno, expected);\n\n\treturn fd;\n}\n\nstatic void do_test(int type, sa_family_t family, struct cmd *cmd,\n\t\t    enum result expected)\n{\n\tint nev, srv_fd, cli_fd;\n\tstruct epoll_event ev;\n\tstruct cmd rcv_cmd;\n\tssize_t nread;\n\n\tcli_fd = send_data(type, family, cmd, cmd ? sizeof(*cmd) : 0,\n\t\t\t   expected);\n\tif (cli_fd < 0)\n\t\treturn;\n\tnev = epoll_wait(epfd, &ev, 1, expected >= PASS ? 5 : 0);\n\tRET_IF((nev <= 0 && expected >= PASS) ||\n\t       (nev > 0 && expected < PASS),\n\t       \"nev <> expected\",\n\t       \"nev:%d expected:%d type:%d family:%d data:(%d, %d)\\n\",\n\t       nev, expected, type, family,\n\t       cmd ? cmd->reuseport_index : -1,\n\t       cmd ? cmd->pass_on_failure : -1);\n\tcheck_results();\n\tcheck_data(type, family, cmd, cli_fd);\n\n\tif (expected < PASS)\n\t\treturn;\n\n\tRET_IF(expected != PASS_ERR_SK_SELECT_REUSEPORT &&\n\t       cmd->reuseport_index != ev.data.u32,\n\t       \"check cmd->reuseport_index\",\n\t       \"cmd:(%u, %u) ev.data.u32:%u\\n\",\n\t       cmd->pass_on_failure, cmd->reuseport_index, ev.data.u32);\n\n\tsrv_fd = sk_fds[ev.data.u32];\n\tif (type == SOCK_STREAM) {\n\t\tint new_fd = accept(srv_fd, NULL, 0);\n\n\t\tRET_IF(new_fd == -1, \"accept(srv_fd)\",\n\t\t       \"ev.data.u32:%u new_fd:%d errno:%d\\n\",\n\t\t       ev.data.u32, new_fd, errno);\n\n\t\tnread = recv(new_fd, &rcv_cmd, sizeof(rcv_cmd), MSG_DONTWAIT);\n\t\tRET_IF(nread != sizeof(rcv_cmd),\n\t\t       \"recv(new_fd)\",\n\t\t       \"ev.data.u32:%u nread:%zd sizeof(rcv_cmd):%zu errno:%d\\n\",\n\t\t       ev.data.u32, nread, sizeof(rcv_cmd), errno);\n\n\t\tclose(new_fd);\n\t} else {\n\t\tnread = recv(srv_fd, &rcv_cmd, sizeof(rcv_cmd), MSG_DONTWAIT);\n\t\tRET_IF(nread != sizeof(rcv_cmd),\n\t\t       \"recv(sk_fds)\",\n\t\t       \"ev.data.u32:%u nread:%zd sizeof(rcv_cmd):%zu errno:%d\\n\",\n\t\t       ev.data.u32, nread, sizeof(rcv_cmd), errno);\n\t}\n\n\tclose(cli_fd);\n}\n\nstatic void test_err_inner_map(int type, sa_family_t family)\n{\n\tstruct cmd cmd = {\n\t\t.reuseport_index = 0,\n\t\t.pass_on_failure = 0,\n\t};\n\n\texpected_results[DROP_ERR_INNER_MAP]++;\n\tdo_test(type, family, &cmd, DROP_ERR_INNER_MAP);\n}\n\nstatic void test_err_skb_data(int type, sa_family_t family)\n{\n\texpected_results[DROP_ERR_SKB_DATA]++;\n\tdo_test(type, family, NULL, DROP_ERR_SKB_DATA);\n}\n\nstatic void test_err_sk_select_port(int type, sa_family_t family)\n{\n\tstruct cmd cmd = {\n\t\t.reuseport_index = REUSEPORT_ARRAY_SIZE,\n\t\t.pass_on_failure = 0,\n\t};\n\n\texpected_results[DROP_ERR_SK_SELECT_REUSEPORT]++;\n\tdo_test(type, family, &cmd, DROP_ERR_SK_SELECT_REUSEPORT);\n}\n\nstatic void test_pass(int type, sa_family_t family)\n{\n\tstruct cmd cmd;\n\tint i;\n\n\tcmd.pass_on_failure = 0;\n\tfor (i = 0; i < REUSEPORT_ARRAY_SIZE; i++) {\n\t\texpected_results[PASS]++;\n\t\tcmd.reuseport_index = i;\n\t\tdo_test(type, family, &cmd, PASS);\n\t}\n}\n\nstatic void test_syncookie(int type, sa_family_t family)\n{\n\tint err, tmp_index = 1;\n\tstruct cmd cmd = {\n\t\t.reuseport_index = 0,\n\t\t.pass_on_failure = 0,\n\t};\n\n\t \n\texpected_results[PASS] += 2;\n\tenable_syncookie();\n\t \n\terr = bpf_map_update_elem(tmp_index_ovr_map, &index_zero,\n\t\t\t\t  &tmp_index, BPF_ANY);\n\tRET_IF(err < 0, \"update_elem(tmp_index_ovr_map, 0, 1)\",\n\t       \"err:%d errno:%d\\n\", err, errno);\n\tdo_test(type, family, &cmd, PASS);\n\terr = bpf_map_lookup_elem(tmp_index_ovr_map, &index_zero,\n\t\t\t\t  &tmp_index);\n\tRET_IF(err < 0 || tmp_index >= 0,\n\t       \"lookup_elem(tmp_index_ovr_map)\",\n\t       \"err:%d errno:%d tmp_index:%d\\n\",\n\t       err, errno, tmp_index);\n\tdisable_syncookie();\n}\n\nstatic void test_pass_on_err(int type, sa_family_t family)\n{\n\tstruct cmd cmd = {\n\t\t.reuseport_index = REUSEPORT_ARRAY_SIZE,\n\t\t.pass_on_failure = 1,\n\t};\n\n\texpected_results[PASS_ERR_SK_SELECT_REUSEPORT] += 1;\n\tdo_test(type, family, &cmd, PASS_ERR_SK_SELECT_REUSEPORT);\n}\n\nstatic void test_detach_bpf(int type, sa_family_t family)\n{\n#ifdef SO_DETACH_REUSEPORT_BPF\n\t__u32 nr_run_before = 0, nr_run_after = 0, tmp, i;\n\tstruct epoll_event ev;\n\tint cli_fd, err, nev;\n\tstruct cmd cmd = {};\n\tint optvalue = 0;\n\n\terr = setsockopt(sk_fds[0], SOL_SOCKET, SO_DETACH_REUSEPORT_BPF,\n\t\t\t &optvalue, sizeof(optvalue));\n\tRET_IF(err == -1, \"setsockopt(SO_DETACH_REUSEPORT_BPF)\",\n\t       \"err:%d errno:%d\\n\", err, errno);\n\n\terr = setsockopt(sk_fds[1], SOL_SOCKET, SO_DETACH_REUSEPORT_BPF,\n\t\t\t &optvalue, sizeof(optvalue));\n\tRET_IF(err == 0 || errno != ENOENT,\n\t       \"setsockopt(SO_DETACH_REUSEPORT_BPF)\",\n\t       \"err:%d errno:%d\\n\", err, errno);\n\n\tfor (i = 0; i < NR_RESULTS; i++) {\n\t\terr = bpf_map_lookup_elem(result_map, &i, &tmp);\n\t\tRET_IF(err < 0, \"lookup_elem(result_map)\",\n\t\t       \"i:%u err:%d errno:%d\\n\", i, err, errno);\n\t\tnr_run_before += tmp;\n\t}\n\n\tcli_fd = send_data(type, family, &cmd, sizeof(cmd), PASS);\n\tif (cli_fd < 0)\n\t\treturn;\n\tnev = epoll_wait(epfd, &ev, 1, 5);\n\tRET_IF(nev <= 0, \"nev <= 0\",\n\t       \"nev:%d expected:1 type:%d family:%d data:(0, 0)\\n\",\n\t       nev,  type, family);\n\n\tfor (i = 0; i < NR_RESULTS; i++) {\n\t\terr = bpf_map_lookup_elem(result_map, &i, &tmp);\n\t\tRET_IF(err < 0, \"lookup_elem(result_map)\",\n\t\t       \"i:%u err:%d errno:%d\\n\", i, err, errno);\n\t\tnr_run_after += tmp;\n\t}\n\n\tRET_IF(nr_run_before != nr_run_after,\n\t       \"nr_run_before != nr_run_after\",\n\t       \"nr_run_before:%u nr_run_after:%u\\n\",\n\t       nr_run_before, nr_run_after);\n\n\tclose(cli_fd);\n#else\n\ttest__skip();\n#endif\n}\n\nstatic void prepare_sk_fds(int type, sa_family_t family, bool inany)\n{\n\tconst int first = REUSEPORT_ARRAY_SIZE - 1;\n\tint i, err, optval = 1;\n\tstruct epoll_event ev;\n\tsocklen_t addrlen;\n\n\tif (inany)\n\t\tsa46_init_inany(&srv_sa, family);\n\telse\n\t\tsa46_init_loopback(&srv_sa, family);\n\taddrlen = sizeof(srv_sa);\n\n\t \n\tfor (i = first; i >= 0; i--) {\n\t\tsk_fds[i] = socket(family, type, 0);\n\t\tRET_IF(sk_fds[i] == -1, \"socket()\", \"sk_fds[%d]:%d errno:%d\\n\",\n\t\t       i, sk_fds[i], errno);\n\t\terr = setsockopt(sk_fds[i], SOL_SOCKET, SO_REUSEPORT,\n\t\t\t\t &optval, sizeof(optval));\n\t\tRET_IF(err == -1, \"setsockopt(SO_REUSEPORT)\",\n\t\t       \"sk_fds[%d] err:%d errno:%d\\n\",\n\t\t       i, err, errno);\n\n\t\tif (i == first) {\n\t\t\terr = setsockopt(sk_fds[i], SOL_SOCKET,\n\t\t\t\t\t SO_ATTACH_REUSEPORT_EBPF,\n\t\t\t\t\t &select_by_skb_data_prog,\n\t\t\t\t\t sizeof(select_by_skb_data_prog));\n\t\t\tRET_IF(err < 0, \"setsockopt(SO_ATTACH_REUEPORT_EBPF)\",\n\t\t\t       \"err:%d errno:%d\\n\", err, errno);\n\t\t}\n\n\t\terr = bind(sk_fds[i], (struct sockaddr *)&srv_sa, addrlen);\n\t\tRET_IF(err < 0, \"bind()\", \"sk_fds[%d] err:%d errno:%d\\n\",\n\t\t       i, err, errno);\n\n\t\tif (type == SOCK_STREAM) {\n\t\t\terr = listen(sk_fds[i], 10);\n\t\t\tRET_IF(err < 0, \"listen()\",\n\t\t\t       \"sk_fds[%d] err:%d errno:%d\\n\",\n\t\t\t       i, err, errno);\n\t\t}\n\n\t\terr = bpf_map_update_elem(reuseport_array, &i, &sk_fds[i],\n\t\t\t\t\t  BPF_NOEXIST);\n\t\tRET_IF(err < 0, \"update_elem(reuseport_array)\",\n\t\t       \"sk_fds[%d] err:%d errno:%d\\n\", i, err, errno);\n\n\t\tif (i == first) {\n\t\t\tsocklen_t addrlen = sizeof(srv_sa);\n\n\t\t\terr = getsockname(sk_fds[i], (struct sockaddr *)&srv_sa,\n\t\t\t\t\t  &addrlen);\n\t\t\tRET_IF(err == -1, \"getsockname()\",\n\t\t\t       \"sk_fds[%d] err:%d errno:%d\\n\", i, err, errno);\n\t\t}\n\t}\n\n\tepfd = epoll_create(1);\n\tRET_IF(epfd == -1, \"epoll_create(1)\",\n\t       \"epfd:%d errno:%d\\n\", epfd, errno);\n\n\tev.events = EPOLLIN;\n\tfor (i = 0; i < REUSEPORT_ARRAY_SIZE; i++) {\n\t\tev.data.u32 = i;\n\t\terr = epoll_ctl(epfd, EPOLL_CTL_ADD, sk_fds[i], &ev);\n\t\tRET_IF(err, \"epoll_ctl(EPOLL_CTL_ADD)\", \"sk_fds[%d]\\n\", i);\n\t}\n}\n\nstatic void setup_per_test(int type, sa_family_t family, bool inany,\n\t\t\t   bool no_inner_map)\n{\n\tint ovr = -1, err;\n\n\tprepare_sk_fds(type, family, inany);\n\terr = bpf_map_update_elem(tmp_index_ovr_map, &index_zero, &ovr,\n\t\t\t\t  BPF_ANY);\n\tRET_IF(err < 0, \"update_elem(tmp_index_ovr_map, 0, -1)\",\n\t       \"err:%d errno:%d\\n\", err, errno);\n\n\t \n\tif (no_inner_map)\n\t\treturn;\n\n\terr = bpf_map_update_elem(outer_map, &index_zero, &reuseport_array,\n\t\t\t\t  BPF_ANY);\n\tRET_IF(err < 0, \"update_elem(outer_map, 0, reuseport_array)\",\n\t       \"err:%d errno:%d\\n\", err, errno);\n}\n\nstatic void cleanup_per_test(bool no_inner_map)\n{\n\tint i, err, zero = 0;\n\n\tmemset(expected_results, 0, sizeof(expected_results));\n\n\tfor (i = 0; i < NR_RESULTS; i++) {\n\t\terr = bpf_map_update_elem(result_map, &i, &zero, BPF_ANY);\n\t\tRET_IF(err, \"reset elem in result_map\",\n\t\t       \"i:%u err:%d errno:%d\\n\", i, err, errno);\n\t}\n\n\terr = bpf_map_update_elem(linum_map, &zero, &zero, BPF_ANY);\n\tRET_IF(err, \"reset line number in linum_map\", \"err:%d errno:%d\\n\",\n\t       err, errno);\n\n\tfor (i = 0; i < REUSEPORT_ARRAY_SIZE; i++)\n\t\tclose(sk_fds[i]);\n\tclose(epfd);\n\n\t \n\tif (no_inner_map)\n\t\treturn;\n\n\terr = bpf_map_delete_elem(outer_map, &index_zero);\n\tRET_IF(err < 0, \"delete_elem(outer_map)\",\n\t       \"err:%d errno:%d\\n\", err, errno);\n}\n\nstatic void cleanup(void)\n{\n\tif (outer_map >= 0) {\n\t\tclose(outer_map);\n\t\touter_map = -1;\n\t}\n\n\tif (reuseport_array >= 0) {\n\t\tclose(reuseport_array);\n\t\treuseport_array = -1;\n\t}\n\n\tif (obj) {\n\t\tbpf_object__close(obj);\n\t\tobj = NULL;\n\t}\n\n\tmemset(expected_results, 0, sizeof(expected_results));\n}\n\nstatic const char *maptype_str(enum bpf_map_type type)\n{\n\tswitch (type) {\n\tcase BPF_MAP_TYPE_REUSEPORT_SOCKARRAY:\n\t\treturn \"reuseport_sockarray\";\n\tcase BPF_MAP_TYPE_SOCKMAP:\n\t\treturn \"sockmap\";\n\tcase BPF_MAP_TYPE_SOCKHASH:\n\t\treturn \"sockhash\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *family_str(sa_family_t family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn \"IPv4\";\n\tcase AF_INET6:\n\t\treturn \"IPv6\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *sotype_str(int sotype)\n{\n\tswitch (sotype) {\n\tcase SOCK_STREAM:\n\t\treturn \"TCP\";\n\tcase SOCK_DGRAM:\n\t\treturn \"UDP\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n#define TEST_INIT(fn_, ...) { .fn = fn_, .name = #fn_, __VA_ARGS__ }\n\nstatic void test_config(int sotype, sa_family_t family, bool inany)\n{\n\tconst struct test {\n\t\tvoid (*fn)(int sotype, sa_family_t family);\n\t\tconst char *name;\n\t\tbool no_inner_map;\n\t\tint need_sotype;\n\t} tests[] = {\n\t\tTEST_INIT(test_err_inner_map,\n\t\t\t  .no_inner_map = true),\n\t\tTEST_INIT(test_err_skb_data),\n\t\tTEST_INIT(test_err_sk_select_port),\n\t\tTEST_INIT(test_pass),\n\t\tTEST_INIT(test_syncookie,\n\t\t\t  .need_sotype = SOCK_STREAM),\n\t\tTEST_INIT(test_pass_on_err),\n\t\tTEST_INIT(test_detach_bpf),\n\t};\n\tchar s[MAX_TEST_NAME];\n\tconst struct test *t;\n\n\tfor (t = tests; t < tests + ARRAY_SIZE(tests); t++) {\n\t\tif (t->need_sotype && t->need_sotype != sotype)\n\t\t\tcontinue;  \n\n\t\tsnprintf(s, sizeof(s), \"%s %s/%s %s %s\",\n\t\t\t maptype_str(inner_map_type),\n\t\t\t family_str(family), sotype_str(sotype),\n\t\t\t inany ? \"INANY\" : \"LOOPBACK\", t->name);\n\n\t\tif (!test__start_subtest(s))\n\t\t\tcontinue;\n\n\t\tsetup_per_test(sotype, family, inany, t->no_inner_map);\n\t\tt->fn(sotype, family);\n\t\tcleanup_per_test(t->no_inner_map);\n\t}\n}\n\n#define BIND_INANY true\n\nstatic void test_all(void)\n{\n\tconst struct config {\n\t\tint sotype;\n\t\tsa_family_t family;\n\t\tbool inany;\n\t} configs[] = {\n\t\t{ SOCK_STREAM, AF_INET },\n\t\t{ SOCK_STREAM, AF_INET, BIND_INANY },\n\t\t{ SOCK_STREAM, AF_INET6 },\n\t\t{ SOCK_STREAM, AF_INET6, BIND_INANY },\n\t\t{ SOCK_DGRAM, AF_INET },\n\t\t{ SOCK_DGRAM, AF_INET6 },\n\t};\n\tconst struct config *c;\n\n\tfor (c = configs; c < configs + ARRAY_SIZE(configs); c++)\n\t\ttest_config(c->sotype, c->family, c->inany);\n}\n\nvoid test_map_type(enum bpf_map_type mt)\n{\n\tif (create_maps(mt))\n\t\tgoto out;\n\tif (prepare_bpf_obj())\n\t\tgoto out;\n\n\ttest_all();\nout:\n\tcleanup();\n}\n\nvoid serial_test_select_reuseport(void)\n{\n\tsaved_tcp_fo = read_int_sysctl(TCP_FO_SYSCTL);\n\tif (saved_tcp_fo < 0)\n\t\tgoto out;\n\tsaved_tcp_syncookie = read_int_sysctl(TCP_SYNCOOKIE_SYSCTL);\n\tif (saved_tcp_syncookie < 0)\n\t\tgoto out;\n\n\tif (enable_fastopen())\n\t\tgoto out;\n\tif (disable_syncookie())\n\t\tgoto out;\n\n\ttest_map_type(BPF_MAP_TYPE_REUSEPORT_SOCKARRAY);\n\ttest_map_type(BPF_MAP_TYPE_SOCKMAP);\n\ttest_map_type(BPF_MAP_TYPE_SOCKHASH);\nout:\n\trestore_sysctls();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}