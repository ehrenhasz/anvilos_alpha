{
  "module_name": "bpf_iter.c",
  "hash_id": "7d5f59039ddc5d84d9eb2feb7f443781dd4d1daeb469476309b612dfb05292dd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/bpf_iter.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <task_local_storage_helpers.h>\n#include \"bpf_iter_ipv6_route.skel.h\"\n#include \"bpf_iter_netlink.skel.h\"\n#include \"bpf_iter_bpf_map.skel.h\"\n#include \"bpf_iter_task.skel.h\"\n#include \"bpf_iter_task_stack.skel.h\"\n#include \"bpf_iter_task_file.skel.h\"\n#include \"bpf_iter_task_vma.skel.h\"\n#include \"bpf_iter_task_btf.skel.h\"\n#include \"bpf_iter_tcp4.skel.h\"\n#include \"bpf_iter_tcp6.skel.h\"\n#include \"bpf_iter_udp4.skel.h\"\n#include \"bpf_iter_udp6.skel.h\"\n#include \"bpf_iter_unix.skel.h\"\n#include \"bpf_iter_vma_offset.skel.h\"\n#include \"bpf_iter_test_kern1.skel.h\"\n#include \"bpf_iter_test_kern2.skel.h\"\n#include \"bpf_iter_test_kern3.skel.h\"\n#include \"bpf_iter_test_kern4.skel.h\"\n#include \"bpf_iter_bpf_hash_map.skel.h\"\n#include \"bpf_iter_bpf_percpu_hash_map.skel.h\"\n#include \"bpf_iter_bpf_array_map.skel.h\"\n#include \"bpf_iter_bpf_percpu_array_map.skel.h\"\n#include \"bpf_iter_bpf_sk_storage_helpers.skel.h\"\n#include \"bpf_iter_bpf_sk_storage_map.skel.h\"\n#include \"bpf_iter_test_kern5.skel.h\"\n#include \"bpf_iter_test_kern6.skel.h\"\n#include \"bpf_iter_bpf_link.skel.h\"\n#include \"bpf_iter_ksym.skel.h\"\n#include \"bpf_iter_sockmap.skel.h\"\n\nstatic int duration;\n\nstatic void test_btf_id_or_null(void)\n{\n\tstruct bpf_iter_test_kern3 *skel;\n\n\tskel = bpf_iter_test_kern3__open_and_load();\n\tif (!ASSERT_ERR_PTR(skel, \"bpf_iter_test_kern3__open_and_load\")) {\n\t\tbpf_iter_test_kern3__destroy(skel);\n\t\treturn;\n\t}\n}\n\nstatic void do_dummy_read_opts(struct bpf_program *prog, struct bpf_iter_attach_opts *opts)\n{\n\tstruct bpf_link *link;\n\tchar buf[16] = {};\n\tint iter_fd, len;\n\n\tlink = bpf_program__attach_iter(prog, opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\treturn;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\t \n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tCHECK(len < 0, \"read\", \"read failed: %s\\n\", strerror(errno));\n\n\tclose(iter_fd);\n\nfree_link:\n\tbpf_link__destroy(link);\n}\n\nstatic void do_dummy_read(struct bpf_program *prog)\n{\n\tdo_dummy_read_opts(prog, NULL);\n}\n\nstatic void do_read_map_iter_fd(struct bpf_object_skeleton **skel, struct bpf_program *prog,\n\t\t\t\tstruct bpf_map *map)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_link *link;\n\tchar buf[16] = {};\n\tint iter_fd, len;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.map.map_fd = bpf_map__fd(map);\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(prog, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_map_iter\"))\n\t\treturn;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_map_iter\")) {\n\t\tbpf_link__destroy(link);\n\t\treturn;\n\t}\n\n\t \n\tbpf_link__destroy(link);\n\tbpf_object__destroy_skeleton(*skel);\n\t*skel = NULL;\n\n\t \n\tusleep(100);\n\t \n\tkern_sync_rcu();\n\tkern_sync_rcu();\n\n\t \n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tASSERT_GE(len, 0, \"read_iterator\");\n\n\tclose(iter_fd);\n}\n\nstatic int read_fd_into_buffer(int fd, char *buf, int size)\n{\n\tint bufleft = size;\n\tint len;\n\n\tdo {\n\t\tlen = read(fd, buf, bufleft);\n\t\tif (len > 0) {\n\t\t\tbuf += len;\n\t\t\tbufleft -= len;\n\t\t}\n\t} while (len > 0);\n\n\treturn len < 0 ? len : size - bufleft;\n}\n\nstatic void test_ipv6_route(void)\n{\n\tstruct bpf_iter_ipv6_route *skel;\n\n\tskel = bpf_iter_ipv6_route__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_ipv6_route__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_ipv6_route);\n\n\tbpf_iter_ipv6_route__destroy(skel);\n}\n\nstatic void test_netlink(void)\n{\n\tstruct bpf_iter_netlink *skel;\n\n\tskel = bpf_iter_netlink__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_netlink__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_netlink);\n\n\tbpf_iter_netlink__destroy(skel);\n}\n\nstatic void test_bpf_map(void)\n{\n\tstruct bpf_iter_bpf_map *skel;\n\n\tskel = bpf_iter_bpf_map__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_map__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_bpf_map);\n\n\tbpf_iter_bpf_map__destroy(skel);\n}\n\nstatic void check_bpf_link_info(const struct bpf_program *prog)\n{\n\tLIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_link_info info = {};\n\tstruct bpf_link *link;\n\t__u32 info_len;\n\tint err;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.task.tid = getpid();\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\tlink = bpf_program__attach_iter(prog, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\treturn;\n\n\tinfo_len = sizeof(info);\n\terr = bpf_link_get_info_by_fd(bpf_link__fd(link), &info, &info_len);\n\tASSERT_OK(err, \"bpf_link_get_info_by_fd\");\n\tASSERT_EQ(info.iter.task.tid, getpid(), \"check_task_tid\");\n\n\tbpf_link__destroy(link);\n}\n\nstatic pthread_mutex_t do_nothing_mutex;\n\nstatic void *do_nothing_wait(void *arg)\n{\n\tpthread_mutex_lock(&do_nothing_mutex);\n\tpthread_mutex_unlock(&do_nothing_mutex);\n\n\tpthread_exit(arg);\n}\n\nstatic void test_task_common_nocheck(struct bpf_iter_attach_opts *opts,\n\t\t\t\t     int *num_unknown, int *num_known)\n{\n\tstruct bpf_iter_task *skel;\n\tpthread_t thread_id;\n\tvoid *ret;\n\n\tskel = bpf_iter_task__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_task__open_and_load\"))\n\t\treturn;\n\n\tASSERT_OK(pthread_mutex_lock(&do_nothing_mutex), \"pthread_mutex_lock\");\n\n\tASSERT_OK(pthread_create(&thread_id, NULL, &do_nothing_wait, NULL),\n\t\t  \"pthread_create\");\n\n\tskel->bss->tid = getpid();\n\n\tdo_dummy_read_opts(skel->progs.dump_task, opts);\n\n\t*num_unknown = skel->bss->num_unknown_tid;\n\t*num_known = skel->bss->num_known_tid;\n\n\tASSERT_OK(pthread_mutex_unlock(&do_nothing_mutex), \"pthread_mutex_unlock\");\n\tASSERT_FALSE(pthread_join(thread_id, &ret) || ret != NULL,\n\t\t     \"pthread_join\");\n\n\tbpf_iter_task__destroy(skel);\n}\n\nstatic void test_task_common(struct bpf_iter_attach_opts *opts, int num_unknown, int num_known)\n{\n\tint num_unknown_tid, num_known_tid;\n\n\ttest_task_common_nocheck(opts, &num_unknown_tid, &num_known_tid);\n\tASSERT_EQ(num_unknown_tid, num_unknown, \"check_num_unknown_tid\");\n\tASSERT_EQ(num_known_tid, num_known, \"check_num_known_tid\");\n}\n\nstatic void test_task_tid(void)\n{\n\tLIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\tint num_unknown_tid, num_known_tid;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.task.tid = getpid();\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\ttest_task_common(&opts, 0, 1);\n\n\tlinfo.task.tid = 0;\n\tlinfo.task.pid = getpid();\n\ttest_task_common(&opts, 1, 1);\n\n\ttest_task_common_nocheck(NULL, &num_unknown_tid, &num_known_tid);\n\tASSERT_GT(num_unknown_tid, 1, \"check_num_unknown_tid\");\n\tASSERT_EQ(num_known_tid, 1, \"check_num_known_tid\");\n}\n\nstatic void test_task_pid(void)\n{\n\tLIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.task.pid = getpid();\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\ttest_task_common(&opts, 1, 1);\n}\n\nstatic void test_task_pidfd(void)\n{\n\tLIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\tint pidfd;\n\n\tpidfd = sys_pidfd_open(getpid(), 0);\n\tif (!ASSERT_GT(pidfd, 0, \"sys_pidfd_open\"))\n\t\treturn;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.task.pid_fd = pidfd;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\ttest_task_common(&opts, 1, 1);\n\n\tclose(pidfd);\n}\n\nstatic void test_task_sleepable(void)\n{\n\tstruct bpf_iter_task *skel;\n\n\tskel = bpf_iter_task__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_task__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_task_sleepable);\n\n\tASSERT_GT(skel->bss->num_expected_failure_copy_from_user_task, 0,\n\t\t  \"num_expected_failure_copy_from_user_task\");\n\tASSERT_GT(skel->bss->num_success_copy_from_user_task, 0,\n\t\t  \"num_success_copy_from_user_task\");\n\n\tbpf_iter_task__destroy(skel);\n}\n\nstatic void test_task_stack(void)\n{\n\tstruct bpf_iter_task_stack *skel;\n\n\tskel = bpf_iter_task_stack__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_task_stack__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_task_stack);\n\tdo_dummy_read(skel->progs.get_task_user_stacks);\n\n\tASSERT_EQ(skel->bss->num_user_stacks, 1, \"num_user_stacks\");\n\n\tbpf_iter_task_stack__destroy(skel);\n}\n\nstatic void test_task_file(void)\n{\n\tLIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tstruct bpf_iter_task_file *skel;\n\tunion bpf_iter_link_info linfo;\n\tpthread_t thread_id;\n\tvoid *ret;\n\n\tskel = bpf_iter_task_file__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_task_file__open_and_load\"))\n\t\treturn;\n\n\tskel->bss->tgid = getpid();\n\n\tASSERT_OK(pthread_mutex_lock(&do_nothing_mutex), \"pthread_mutex_lock\");\n\n\tASSERT_OK(pthread_create(&thread_id, NULL, &do_nothing_wait, NULL),\n\t\t  \"pthread_create\");\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.task.tid = getpid();\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\tdo_dummy_read_opts(skel->progs.dump_task_file, &opts);\n\n\tASSERT_EQ(skel->bss->count, 0, \"check_count\");\n\tASSERT_EQ(skel->bss->unique_tgid_count, 1, \"check_unique_tgid_count\");\n\n\tskel->bss->last_tgid = 0;\n\tskel->bss->count = 0;\n\tskel->bss->unique_tgid_count = 0;\n\n\tdo_dummy_read(skel->progs.dump_task_file);\n\n\tASSERT_EQ(skel->bss->count, 0, \"check_count\");\n\tASSERT_GT(skel->bss->unique_tgid_count, 1, \"check_unique_tgid_count\");\n\n\tcheck_bpf_link_info(skel->progs.dump_task_file);\n\n\tASSERT_OK(pthread_mutex_unlock(&do_nothing_mutex), \"pthread_mutex_unlock\");\n\tASSERT_OK(pthread_join(thread_id, &ret), \"pthread_join\");\n\tASSERT_NULL(ret, \"pthread_join\");\n\n\tbpf_iter_task_file__destroy(skel);\n}\n\n#define TASKBUFSZ\t\t32768\n\nstatic char taskbuf[TASKBUFSZ];\n\nstatic int do_btf_read(struct bpf_iter_task_btf *skel)\n{\n\tstruct bpf_program *prog = skel->progs.dump_task_struct;\n\tstruct bpf_iter_task_btf__bss *bss = skel->bss;\n\tint iter_fd = -1, err;\n\tstruct bpf_link *link;\n\tchar *buf = taskbuf;\n\tint ret = 0;\n\n\tlink = bpf_program__attach_iter(prog, NULL);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\treturn ret;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\terr = read_fd_into_buffer(iter_fd, buf, TASKBUFSZ);\n\tif (bss->skip) {\n\t\tprintf(\"%s:SKIP:no __builtin_btf_type_id\\n\", __func__);\n\t\tret = 1;\n\t\ttest__skip();\n\t\tgoto free_link;\n\t}\n\n\tif (CHECK(err < 0, \"read\", \"read failed: %s\\n\", strerror(errno)))\n\t\tgoto free_link;\n\n\tASSERT_HAS_SUBSTR(taskbuf, \"(struct task_struct)\",\n\t      \"check for btf representation of task_struct in iter data\");\nfree_link:\n\tif (iter_fd > 0)\n\t\tclose(iter_fd);\n\tbpf_link__destroy(link);\n\treturn ret;\n}\n\nstatic void test_task_btf(void)\n{\n\tstruct bpf_iter_task_btf__bss *bss;\n\tstruct bpf_iter_task_btf *skel;\n\tint ret;\n\n\tskel = bpf_iter_task_btf__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_task_btf__open_and_load\"))\n\t\treturn;\n\n\tbss = skel->bss;\n\n\tret = do_btf_read(skel);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tif (!ASSERT_NEQ(bss->tasks, 0, \"no task iteration, did BPF program run?\"))\n\t\tgoto cleanup;\n\n\tASSERT_EQ(bss->seq_err, 0, \"check for unexpected err\");\n\ncleanup:\n\tbpf_iter_task_btf__destroy(skel);\n}\n\nstatic void test_tcp4(void)\n{\n\tstruct bpf_iter_tcp4 *skel;\n\n\tskel = bpf_iter_tcp4__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_tcp4__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_tcp4);\n\n\tbpf_iter_tcp4__destroy(skel);\n}\n\nstatic void test_tcp6(void)\n{\n\tstruct bpf_iter_tcp6 *skel;\n\n\tskel = bpf_iter_tcp6__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_tcp6__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_tcp6);\n\n\tbpf_iter_tcp6__destroy(skel);\n}\n\nstatic void test_udp4(void)\n{\n\tstruct bpf_iter_udp4 *skel;\n\n\tskel = bpf_iter_udp4__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_udp4__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_udp4);\n\n\tbpf_iter_udp4__destroy(skel);\n}\n\nstatic void test_udp6(void)\n{\n\tstruct bpf_iter_udp6 *skel;\n\n\tskel = bpf_iter_udp6__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_udp6__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_udp6);\n\n\tbpf_iter_udp6__destroy(skel);\n}\n\nstatic void test_unix(void)\n{\n\tstruct bpf_iter_unix *skel;\n\n\tskel = bpf_iter_unix__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_unix__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_unix);\n\n\tbpf_iter_unix__destroy(skel);\n}\n\n \nstatic int do_read_with_fd(int iter_fd, const char *expected,\n\t\t\t   bool read_one_char)\n{\n\tint len, read_buf_len, start;\n\tchar buf[16] = {};\n\n\tread_buf_len = read_one_char ? 1 : 16;\n\tstart = 0;\n\twhile ((len = read(iter_fd, buf + start, read_buf_len)) > 0) {\n\t\tstart += len;\n\t\tif (CHECK(start >= 16, \"read\", \"read len %d\\n\", len))\n\t\t\treturn -1;\n\t\tread_buf_len = read_one_char ? 1 : 16 - start;\n\t}\n\tif (CHECK(len < 0, \"read\", \"read failed: %s\\n\", strerror(errno)))\n\t\treturn -1;\n\n\tif (!ASSERT_STREQ(buf, expected, \"read\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void test_anon_iter(bool read_one_char)\n{\n\tstruct bpf_iter_test_kern1 *skel;\n\tstruct bpf_link *link;\n\tint iter_fd, err;\n\n\tskel = bpf_iter_test_kern1__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_test_kern1__open_and_load\"))\n\t\treturn;\n\n\terr = bpf_iter_test_kern1__attach(skel);\n\tif (!ASSERT_OK(err, \"bpf_iter_test_kern1__attach\")) {\n\t\tgoto out;\n\t}\n\n\tlink = skel->links.dump_task;\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto out;\n\n\tdo_read_with_fd(iter_fd, \"abcd\", read_one_char);\n\tclose(iter_fd);\n\nout:\n\tbpf_iter_test_kern1__destroy(skel);\n}\n\nstatic int do_read(const char *path, const char *expected)\n{\n\tint err, iter_fd;\n\n\titer_fd = open(path, O_RDONLY);\n\tif (CHECK(iter_fd < 0, \"open\", \"open %s failed: %s\\n\",\n\t\t  path, strerror(errno)))\n\t\treturn -1;\n\n\terr = do_read_with_fd(iter_fd, expected, false);\n\tclose(iter_fd);\n\treturn err;\n}\n\nstatic void test_file_iter(void)\n{\n\tconst char *path = \"/sys/fs/bpf/bpf_iter_test1\";\n\tstruct bpf_iter_test_kern1 *skel1;\n\tstruct bpf_iter_test_kern2 *skel2;\n\tstruct bpf_link *link;\n\tint err;\n\n\tskel1 = bpf_iter_test_kern1__open_and_load();\n\tif (!ASSERT_OK_PTR(skel1, \"bpf_iter_test_kern1__open_and_load\"))\n\t\treturn;\n\n\tlink = bpf_program__attach_iter(skel1->progs.dump_task, NULL);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\t \n\tunlink(path);\n\n\terr = bpf_link__pin(link, path);\n\tif (CHECK(err, \"pin_iter\", \"pin_iter to %s failed: %d\\n\", path, err))\n\t\tgoto free_link;\n\n\terr = do_read(path, \"abcd\");\n\tif (err)\n\t\tgoto unlink_path;\n\n\t \n\tskel2 = bpf_iter_test_kern2__open_and_load();\n\tif (!ASSERT_OK_PTR(skel2, \"bpf_iter_test_kern2__open_and_load\"))\n\t\tgoto unlink_path;\n\n\terr = bpf_link__update_program(link, skel2->progs.dump_task);\n\tif (!ASSERT_OK(err, \"update_prog\"))\n\t\tgoto destroy_skel2;\n\n\tdo_read(path, \"ABCD\");\n\ndestroy_skel2:\n\tbpf_iter_test_kern2__destroy(skel2);\nunlink_path:\n\tunlink(path);\nfree_link:\n\tbpf_link__destroy(link);\nout:\n\tbpf_iter_test_kern1__destroy(skel1);\n}\n\nstatic void test_overflow(bool test_e2big_overflow, bool ret1)\n{\n\t__u32 map_info_len, total_read_len, expected_read_len;\n\tint err, iter_fd, map1_fd, map2_fd, len;\n\tstruct bpf_map_info map_info = {};\n\tstruct bpf_iter_test_kern4 *skel;\n\tstruct bpf_link *link;\n\t__u32 iter_size;\n\tchar *buf;\n\n\tskel = bpf_iter_test_kern4__open();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_test_kern4__open\"))\n\t\treturn;\n\n\t \n\tmap1_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, NULL, 4, 8, 1, NULL);\n\tif (CHECK(map1_fd < 0, \"bpf_map_create\",\n\t\t  \"map_creation failed: %s\\n\", strerror(errno)))\n\t\tgoto out;\n\tmap2_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, NULL, 4, 8, 1, NULL);\n\tif (CHECK(map2_fd < 0, \"bpf_map_create\",\n\t\t  \"map_creation failed: %s\\n\", strerror(errno)))\n\t\tgoto free_map1;\n\n\t \n\titer_size = sysconf(_SC_PAGE_SIZE) << 3;\n\n\tif (test_e2big_overflow) {\n\t\tskel->rodata->print_len = (iter_size + 8) / 8;\n\t\texpected_read_len = 2 * (iter_size + 8);\n\t} else if (!ret1) {\n\t\tskel->rodata->print_len = (iter_size - 8) / 8;\n\t\texpected_read_len = 2 * (iter_size - 8);\n\t} else {\n\t\tskel->rodata->print_len = 1;\n\t\texpected_read_len = 2 * 8;\n\t}\n\tskel->rodata->ret1 = ret1;\n\n\tif (!ASSERT_OK(bpf_iter_test_kern4__load(skel),\n\t\t  \"bpf_iter_test_kern4__load\"))\n\t\tgoto free_map2;\n\n\t \n\tmap_info_len = sizeof(map_info);\n\terr = bpf_map_get_info_by_fd(map1_fd, &map_info, &map_info_len);\n\tif (CHECK(err, \"get_map_info\", \"get map info failed: %s\\n\",\n\t\t  strerror(errno)))\n\t\tgoto free_map2;\n\tskel->bss->map1_id = map_info.id;\n\n\terr = bpf_map_get_info_by_fd(map2_fd, &map_info, &map_info_len);\n\tif (CHECK(err, \"get_map_info\", \"get map info failed: %s\\n\",\n\t\t  strerror(errno)))\n\t\tgoto free_map2;\n\tskel->bss->map2_id = map_info.id;\n\n\tlink = bpf_program__attach_iter(skel->progs.dump_bpf_map, NULL);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto free_map2;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\tbuf = malloc(expected_read_len);\n\tif (!buf)\n\t\tgoto close_iter;\n\n\t \n\ttotal_read_len = 0;\n\tif (test_e2big_overflow) {\n\t\twhile ((len = read(iter_fd, buf, expected_read_len)) > 0)\n\t\t\ttotal_read_len += len;\n\n\t\tCHECK(len != -1 || errno != E2BIG, \"read\",\n\t\t      \"expected ret -1, errno E2BIG, but get ret %d, error %s\\n\",\n\t\t\t  len, strerror(errno));\n\t\tgoto free_buf;\n\t} else if (!ret1) {\n\t\twhile ((len = read(iter_fd, buf, expected_read_len)) > 0)\n\t\t\ttotal_read_len += len;\n\n\t\tif (CHECK(len < 0, \"read\", \"read failed: %s\\n\",\n\t\t\t  strerror(errno)))\n\t\t\tgoto free_buf;\n\t} else {\n\t\tdo {\n\t\t\tlen = read(iter_fd, buf, expected_read_len);\n\t\t\tif (len > 0)\n\t\t\t\ttotal_read_len += len;\n\t\t} while (len > 0 || len == -EAGAIN);\n\n\t\tif (CHECK(len < 0, \"read\", \"read failed: %s\\n\",\n\t\t\t  strerror(errno)))\n\t\t\tgoto free_buf;\n\t}\n\n\tif (!ASSERT_EQ(total_read_len, expected_read_len, \"read\"))\n\t\tgoto free_buf;\n\n\tif (!ASSERT_EQ(skel->bss->map1_accessed, 1, \"map1_accessed\"))\n\t\tgoto free_buf;\n\n\tif (!ASSERT_EQ(skel->bss->map2_accessed, 2, \"map2_accessed\"))\n\t\tgoto free_buf;\n\n\tASSERT_EQ(skel->bss->map2_seqnum1, skel->bss->map2_seqnum2, \"map2_seqnum\");\n\nfree_buf:\n\tfree(buf);\nclose_iter:\n\tclose(iter_fd);\nfree_link:\n\tbpf_link__destroy(link);\nfree_map2:\n\tclose(map2_fd);\nfree_map1:\n\tclose(map1_fd);\nout:\n\tbpf_iter_test_kern4__destroy(skel);\n}\n\nstatic void test_bpf_hash_map(void)\n{\n\t__u32 expected_key_a = 0, expected_key_b = 0;\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tstruct bpf_iter_bpf_hash_map *skel;\n\tint err, i, len, map_fd, iter_fd;\n\tunion bpf_iter_link_info linfo;\n\t__u64 val, expected_val = 0;\n\tstruct bpf_link *link;\n\tstruct key_t {\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\t} key;\n\tchar buf[64];\n\n\tskel = bpf_iter_bpf_hash_map__open();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_hash_map__open\"))\n\t\treturn;\n\n\tskel->bss->in_test_mode = true;\n\n\terr = bpf_iter_bpf_hash_map__load(skel);\n\tif (!ASSERT_OK(err, \"bpf_iter_bpf_hash_map__load\"))\n\t\tgoto out;\n\n\t \n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.map.map_fd = bpf_map__fd(skel->maps.hashmap2);\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(skel->progs.dump_bpf_hash_map, &opts);\n\tif (!ASSERT_ERR_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\tlinfo.map.map_fd = bpf_map__fd(skel->maps.hashmap3);\n\tlink = bpf_program__attach_iter(skel->progs.dump_bpf_hash_map, &opts);\n\tif (!ASSERT_ERR_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\t \n\tmap_fd = bpf_map__fd(skel->maps.hashmap1);\n\tfor (i = 0; i < bpf_map__max_entries(skel->maps.hashmap1); i++) {\n\t\tkey.a = i + 1;\n\t\tkey.b = i + 2;\n\t\tkey.c = i + 3;\n\t\tval = i + 4;\n\t\texpected_key_a += key.a;\n\t\texpected_key_b += key.b;\n\t\texpected_val += val;\n\n\t\terr = bpf_map_update_elem(map_fd, &key, &val, BPF_ANY);\n\t\tif (!ASSERT_OK(err, \"map_update\"))\n\t\t\tgoto out;\n\t}\n\n\t \n\tlinfo.map.map_fd = map_fd;\n\tlink = bpf_program__attach_iter(skel->progs.sleepable_dummy_dump, &opts);\n\tif (!ASSERT_ERR_PTR(link, \"attach_sleepable_prog_to_iter\"))\n\t\tgoto out;\n\n\tlinfo.map.map_fd = map_fd;\n\tlink = bpf_program__attach_iter(skel->progs.dump_bpf_hash_map, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\t \n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tif (CHECK(len < 0, \"read\", \"read failed: %s\\n\", strerror(errno)))\n\t\tgoto close_iter;\n\n\t \n\tif (!ASSERT_EQ(skel->bss->key_sum_a, expected_key_a, \"key_sum_a\"))\n\t\tgoto close_iter;\n\tif (!ASSERT_EQ(skel->bss->key_sum_b, expected_key_b, \"key_sum_b\"))\n\t\tgoto close_iter;\n\tif (!ASSERT_EQ(skel->bss->val_sum, expected_val, \"val_sum\"))\n\t\tgoto close_iter;\n\nclose_iter:\n\tclose(iter_fd);\nfree_link:\n\tbpf_link__destroy(link);\nout:\n\tbpf_iter_bpf_hash_map__destroy(skel);\n}\n\nstatic void test_bpf_percpu_hash_map(void)\n{\n\t__u32 expected_key_a = 0, expected_key_b = 0;\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tstruct bpf_iter_bpf_percpu_hash_map *skel;\n\tint err, i, j, len, map_fd, iter_fd;\n\tunion bpf_iter_link_info linfo;\n\t__u32 expected_val = 0;\n\tstruct bpf_link *link;\n\tstruct key_t {\n\t\tint a;\n\t\tint b;\n\t\tint c;\n\t} key;\n\tchar buf[64];\n\tvoid *val;\n\n\tskel = bpf_iter_bpf_percpu_hash_map__open();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_percpu_hash_map__open\"))\n\t\treturn;\n\n\tskel->rodata->num_cpus = bpf_num_possible_cpus();\n\tval = malloc(8 * bpf_num_possible_cpus());\n\n\terr = bpf_iter_bpf_percpu_hash_map__load(skel);\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_percpu_hash_map__load\"))\n\t\tgoto out;\n\n\t \n\tmap_fd = bpf_map__fd(skel->maps.hashmap1);\n\tfor (i = 0; i < bpf_map__max_entries(skel->maps.hashmap1); i++) {\n\t\tkey.a = i + 1;\n\t\tkey.b = i + 2;\n\t\tkey.c = i + 3;\n\t\texpected_key_a += key.a;\n\t\texpected_key_b += key.b;\n\n\t\tfor (j = 0; j < bpf_num_possible_cpus(); j++) {\n\t\t\t*(__u32 *)(val + j * 8) = i + j;\n\t\t\texpected_val += i + j;\n\t\t}\n\n\t\terr = bpf_map_update_elem(map_fd, &key, val, BPF_ANY);\n\t\tif (!ASSERT_OK(err, \"map_update\"))\n\t\t\tgoto out;\n\t}\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.map.map_fd = map_fd;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(skel->progs.dump_bpf_percpu_hash_map, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\t \n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tif (CHECK(len < 0, \"read\", \"read failed: %s\\n\", strerror(errno)))\n\t\tgoto close_iter;\n\n\t \n\tif (!ASSERT_EQ(skel->bss->key_sum_a, expected_key_a, \"key_sum_a\"))\n\t\tgoto close_iter;\n\tif (!ASSERT_EQ(skel->bss->key_sum_b, expected_key_b, \"key_sum_b\"))\n\t\tgoto close_iter;\n\tif (!ASSERT_EQ(skel->bss->val_sum, expected_val, \"val_sum\"))\n\t\tgoto close_iter;\n\nclose_iter:\n\tclose(iter_fd);\nfree_link:\n\tbpf_link__destroy(link);\nout:\n\tbpf_iter_bpf_percpu_hash_map__destroy(skel);\n\tfree(val);\n}\n\nstatic void test_bpf_array_map(void)\n{\n\t__u64 val, expected_val = 0, res_first_val, first_val = 0;\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\t__u32 key, expected_key = 0, res_first_key;\n\tint err, i, map_fd, hash_fd, iter_fd;\n\tstruct bpf_iter_bpf_array_map *skel;\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_link *link;\n\tchar buf[64] = {};\n\tint len, start;\n\n\tskel = bpf_iter_bpf_array_map__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_array_map__open_and_load\"))\n\t\treturn;\n\n\tmap_fd = bpf_map__fd(skel->maps.arraymap1);\n\tfor (i = 0; i < bpf_map__max_entries(skel->maps.arraymap1); i++) {\n\t\tval = i + 4;\n\t\texpected_key += i;\n\t\texpected_val += val;\n\n\t\tif (i == 0)\n\t\t\tfirst_val = val;\n\n\t\terr = bpf_map_update_elem(map_fd, &i, &val, BPF_ANY);\n\t\tif (!ASSERT_OK(err, \"map_update\"))\n\t\t\tgoto out;\n\t}\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.map.map_fd = map_fd;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(skel->progs.dump_bpf_array_map, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\t \n\tstart = 0;\n\twhile ((len = read(iter_fd, buf + start, sizeof(buf) - start)) > 0)\n\t\tstart += len;\n\tif (CHECK(len < 0, \"read\", \"read failed: %s\\n\", strerror(errno)))\n\t\tgoto close_iter;\n\n\t \n\tres_first_key = *(__u32 *)buf;\n\tres_first_val = *(__u64 *)(buf + sizeof(__u32));\n\tif (CHECK(res_first_key != 0 || res_first_val != first_val,\n\t\t  \"bpf_seq_write\",\n\t\t  \"seq_write failure: first key %u vs expected 0, \"\n\t\t  \" first value %llu vs expected %llu\\n\",\n\t\t  res_first_key, res_first_val, first_val))\n\t\tgoto close_iter;\n\n\tif (!ASSERT_EQ(skel->bss->key_sum, expected_key, \"key_sum\"))\n\t\tgoto close_iter;\n\tif (!ASSERT_EQ(skel->bss->val_sum, expected_val, \"val_sum\"))\n\t\tgoto close_iter;\n\n\thash_fd = bpf_map__fd(skel->maps.hashmap1);\n\tfor (i = 0; i < bpf_map__max_entries(skel->maps.arraymap1); i++) {\n\t\terr = bpf_map_lookup_elem(map_fd, &i, &val);\n\t\tif (!ASSERT_OK(err, \"map_lookup arraymap1\"))\n\t\t\tgoto close_iter;\n\t\tif (!ASSERT_EQ(i, val, \"invalid_val arraymap1\"))\n\t\t\tgoto close_iter;\n\n\t\tval = i + 4;\n\t\terr = bpf_map_lookup_elem(hash_fd, &val, &key);\n\t\tif (!ASSERT_OK(err, \"map_lookup hashmap1\"))\n\t\t\tgoto close_iter;\n\t\tif (!ASSERT_EQ(key, val - 4, \"invalid_val hashmap1\"))\n\t\t\tgoto close_iter;\n\t}\n\nclose_iter:\n\tclose(iter_fd);\nfree_link:\n\tbpf_link__destroy(link);\nout:\n\tbpf_iter_bpf_array_map__destroy(skel);\n}\n\nstatic void test_bpf_array_map_iter_fd(void)\n{\n\tstruct bpf_iter_bpf_array_map *skel;\n\n\tskel = bpf_iter_bpf_array_map__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_array_map__open_and_load\"))\n\t\treturn;\n\n\tdo_read_map_iter_fd(&skel->skeleton, skel->progs.dump_bpf_array_map,\n\t\t\t    skel->maps.arraymap1);\n\n\tbpf_iter_bpf_array_map__destroy(skel);\n}\n\nstatic void test_bpf_percpu_array_map(void)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tstruct bpf_iter_bpf_percpu_array_map *skel;\n\t__u32 expected_key = 0, expected_val = 0;\n\tunion bpf_iter_link_info linfo;\n\tint err, i, j, map_fd, iter_fd;\n\tstruct bpf_link *link;\n\tchar buf[64];\n\tvoid *val;\n\tint len;\n\n\tskel = bpf_iter_bpf_percpu_array_map__open();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_percpu_array_map__open\"))\n\t\treturn;\n\n\tskel->rodata->num_cpus = bpf_num_possible_cpus();\n\tval = malloc(8 * bpf_num_possible_cpus());\n\n\terr = bpf_iter_bpf_percpu_array_map__load(skel);\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_percpu_array_map__load\"))\n\t\tgoto out;\n\n\t \n\tmap_fd = bpf_map__fd(skel->maps.arraymap1);\n\tfor (i = 0; i < bpf_map__max_entries(skel->maps.arraymap1); i++) {\n\t\texpected_key += i;\n\n\t\tfor (j = 0; j < bpf_num_possible_cpus(); j++) {\n\t\t\t*(__u32 *)(val + j * 8) = i + j;\n\t\t\texpected_val += i + j;\n\t\t}\n\n\t\terr = bpf_map_update_elem(map_fd, &i, val, BPF_ANY);\n\t\tif (!ASSERT_OK(err, \"map_update\"))\n\t\t\tgoto out;\n\t}\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.map.map_fd = map_fd;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(skel->progs.dump_bpf_percpu_array_map, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\t \n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tif (CHECK(len < 0, \"read\", \"read failed: %s\\n\", strerror(errno)))\n\t\tgoto close_iter;\n\n\t \n\tif (!ASSERT_EQ(skel->bss->key_sum, expected_key, \"key_sum\"))\n\t\tgoto close_iter;\n\tif (!ASSERT_EQ(skel->bss->val_sum, expected_val, \"val_sum\"))\n\t\tgoto close_iter;\n\nclose_iter:\n\tclose(iter_fd);\nfree_link:\n\tbpf_link__destroy(link);\nout:\n\tbpf_iter_bpf_percpu_array_map__destroy(skel);\n\tfree(val);\n}\n\n \nstatic void test_bpf_sk_storage_delete(void)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tstruct bpf_iter_bpf_sk_storage_helpers *skel;\n\tunion bpf_iter_link_info linfo;\n\tint err, len, map_fd, iter_fd;\n\tstruct bpf_link *link;\n\tint sock_fd = -1;\n\t__u32 val = 42;\n\tchar buf[64];\n\n\tskel = bpf_iter_bpf_sk_storage_helpers__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_sk_storage_helpers__open_and_load\"))\n\t\treturn;\n\n\tmap_fd = bpf_map__fd(skel->maps.sk_stg_map);\n\n\tsock_fd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (!ASSERT_GE(sock_fd, 0, \"socket\"))\n\t\tgoto out;\n\terr = bpf_map_update_elem(map_fd, &sock_fd, &val, BPF_NOEXIST);\n\tif (!ASSERT_OK(err, \"map_update\"))\n\t\tgoto out;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.map.map_fd = map_fd;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(skel->progs.delete_bpf_sk_storage_map,\n\t\t\t\t\t&opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\t \n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tif (CHECK(len < 0, \"read\", \"read failed: %s\\n\", strerror(errno)))\n\t\tgoto close_iter;\n\n\t \n\terr = bpf_map_lookup_elem(map_fd, &sock_fd, &val);\n\tif (CHECK(!err || errno != ENOENT, \"bpf_map_lookup_elem\",\n\t\t  \"map value wasn't deleted (err=%d, errno=%d)\\n\", err, errno))\n\t\tgoto close_iter;\n\nclose_iter:\n\tclose(iter_fd);\nfree_link:\n\tbpf_link__destroy(link);\nout:\n\tif (sock_fd >= 0)\n\t\tclose(sock_fd);\n\tbpf_iter_bpf_sk_storage_helpers__destroy(skel);\n}\n\n \nstatic void test_bpf_sk_storage_get(void)\n{\n\tstruct bpf_iter_bpf_sk_storage_helpers *skel;\n\tint err, map_fd, val = -1;\n\tint sock_fd = -1;\n\n\tskel = bpf_iter_bpf_sk_storage_helpers__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_sk_storage_helpers__open_and_load\"))\n\t\treturn;\n\n\tsock_fd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (!ASSERT_GE(sock_fd, 0, \"socket\"))\n\t\tgoto out;\n\n\terr = listen(sock_fd, 1);\n\tif (!ASSERT_OK(err, \"listen\"))\n\t\tgoto close_socket;\n\n\tmap_fd = bpf_map__fd(skel->maps.sk_stg_map);\n\n\terr = bpf_map_update_elem(map_fd, &sock_fd, &val, BPF_NOEXIST);\n\tif (!ASSERT_OK(err, \"bpf_map_update_elem\"))\n\t\tgoto close_socket;\n\n\tdo_dummy_read(skel->progs.fill_socket_owner);\n\n\terr = bpf_map_lookup_elem(map_fd, &sock_fd, &val);\n\tif (CHECK(err || val != getpid(), \"bpf_map_lookup_elem\",\n\t    \"map value wasn't set correctly (expected %d, got %d, err=%d)\\n\",\n\t    getpid(), val, err))\n\t\tgoto close_socket;\n\n\tdo_dummy_read(skel->progs.negate_socket_local_storage);\n\n\terr = bpf_map_lookup_elem(map_fd, &sock_fd, &val);\n\tCHECK(err || val != -getpid(), \"bpf_map_lookup_elem\",\n\t      \"map value wasn't set correctly (expected %d, got %d, err=%d)\\n\",\n\t      -getpid(), val, err);\n\nclose_socket:\n\tclose(sock_fd);\nout:\n\tbpf_iter_bpf_sk_storage_helpers__destroy(skel);\n}\n\nstatic void test_bpf_sk_stoarge_map_iter_fd(void)\n{\n\tstruct bpf_iter_bpf_sk_storage_map *skel;\n\n\tskel = bpf_iter_bpf_sk_storage_map__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_sk_storage_map__open_and_load\"))\n\t\treturn;\n\n\tdo_read_map_iter_fd(&skel->skeleton, skel->progs.rw_bpf_sk_storage_map,\n\t\t\t    skel->maps.sk_stg_map);\n\n\tbpf_iter_bpf_sk_storage_map__destroy(skel);\n}\n\nstatic void test_bpf_sk_storage_map(void)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tint err, i, len, map_fd, iter_fd, num_sockets;\n\tstruct bpf_iter_bpf_sk_storage_map *skel;\n\tunion bpf_iter_link_info linfo;\n\tint sock_fd[3] = {-1, -1, -1};\n\t__u32 val, expected_val = 0;\n\tstruct bpf_link *link;\n\tchar buf[64];\n\n\tskel = bpf_iter_bpf_sk_storage_map__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_sk_storage_map__open_and_load\"))\n\t\treturn;\n\n\tmap_fd = bpf_map__fd(skel->maps.sk_stg_map);\n\tnum_sockets = ARRAY_SIZE(sock_fd);\n\tfor (i = 0; i < num_sockets; i++) {\n\t\tsock_fd[i] = socket(AF_INET6, SOCK_STREAM, 0);\n\t\tif (!ASSERT_GE(sock_fd[i], 0, \"socket\"))\n\t\t\tgoto out;\n\n\t\tval = i + 1;\n\t\texpected_val += val;\n\n\t\terr = bpf_map_update_elem(map_fd, &sock_fd[i], &val,\n\t\t\t\t\t  BPF_NOEXIST);\n\t\tif (!ASSERT_OK(err, \"map_update\"))\n\t\t\tgoto out;\n\t}\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.map.map_fd = map_fd;\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(skel->progs.oob_write_bpf_sk_storage_map, &opts);\n\terr = libbpf_get_error(link);\n\tif (!ASSERT_EQ(err, -EACCES, \"attach_oob_write_iter\")) {\n\t\tif (!err)\n\t\t\tbpf_link__destroy(link);\n\t\tgoto out;\n\t}\n\n\tlink = bpf_program__attach_iter(skel->progs.rw_bpf_sk_storage_map, &opts);\n\tif (!ASSERT_OK_PTR(link, \"attach_iter\"))\n\t\tgoto out;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(link));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto free_link;\n\n\tskel->bss->to_add_val = time(NULL);\n\t \n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tif (CHECK(len < 0, \"read\", \"read failed: %s\\n\", strerror(errno)))\n\t\tgoto close_iter;\n\n\t \n\tif (!ASSERT_EQ(skel->bss->ipv6_sk_count, num_sockets, \"ipv6_sk_count\"))\n\t\tgoto close_iter;\n\n\tif (!ASSERT_EQ(skel->bss->val_sum, expected_val, \"val_sum\"))\n\t\tgoto close_iter;\n\n\tfor (i = 0; i < num_sockets; i++) {\n\t\terr = bpf_map_lookup_elem(map_fd, &sock_fd[i], &val);\n\t\tif (!ASSERT_OK(err, \"map_lookup\") ||\n\t\t    !ASSERT_EQ(val, i + 1 + skel->bss->to_add_val, \"check_map_value\"))\n\t\t\tbreak;\n\t}\n\nclose_iter:\n\tclose(iter_fd);\nfree_link:\n\tbpf_link__destroy(link);\nout:\n\tfor (i = 0; i < num_sockets; i++) {\n\t\tif (sock_fd[i] >= 0)\n\t\t\tclose(sock_fd[i]);\n\t}\n\tbpf_iter_bpf_sk_storage_map__destroy(skel);\n}\n\nstatic void test_rdonly_buf_out_of_bound(void)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tstruct bpf_iter_test_kern5 *skel;\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_link *link;\n\n\tskel = bpf_iter_test_kern5__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_test_kern5__open_and_load\"))\n\t\treturn;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.map.map_fd = bpf_map__fd(skel->maps.hashmap1);\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\tlink = bpf_program__attach_iter(skel->progs.dump_bpf_hash_map, &opts);\n\tif (!ASSERT_ERR_PTR(link, \"attach_iter\"))\n\t\tbpf_link__destroy(link);\n\n\tbpf_iter_test_kern5__destroy(skel);\n}\n\nstatic void test_buf_neg_offset(void)\n{\n\tstruct bpf_iter_test_kern6 *skel;\n\n\tskel = bpf_iter_test_kern6__open_and_load();\n\tif (!ASSERT_ERR_PTR(skel, \"bpf_iter_test_kern6__open_and_load\"))\n\t\tbpf_iter_test_kern6__destroy(skel);\n}\n\nstatic void test_link_iter(void)\n{\n\tstruct bpf_iter_bpf_link *skel;\n\n\tskel = bpf_iter_bpf_link__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_bpf_link__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_bpf_link);\n\n\tbpf_iter_bpf_link__destroy(skel);\n}\n\nstatic void test_ksym_iter(void)\n{\n\tstruct bpf_iter_ksym *skel;\n\n\tskel = bpf_iter_ksym__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_ksym__open_and_load\"))\n\t\treturn;\n\n\tdo_dummy_read(skel->progs.dump_ksym);\n\n\tbpf_iter_ksym__destroy(skel);\n}\n\n#define CMP_BUFFER_SIZE 1024\nstatic char task_vma_output[CMP_BUFFER_SIZE];\nstatic char proc_maps_output[CMP_BUFFER_SIZE];\n\n \nstatic void str_strip_first_line(char *str)\n{\n\tchar *dst = str, *src = str;\n\n\tdo {\n\t\tif (*src == ' ' || *src == '\\t')\n\t\t\tsrc++;\n\t\telse\n\t\t\t*(dst++) = *(src++);\n\n\t} while (*src != '\\0' && *src != '\\n');\n\n\t*dst = '\\0';\n}\n\nstatic void test_task_vma_common(struct bpf_iter_attach_opts *opts)\n{\n\tint err, iter_fd = -1, proc_maps_fd = -1;\n\tstruct bpf_iter_task_vma *skel;\n\tint len, read_size = 4;\n\tchar maps_path[64];\n\n\tskel = bpf_iter_task_vma__open();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_task_vma__open\"))\n\t\treturn;\n\n\tskel->bss->pid = getpid();\n\tskel->bss->one_task = opts ? 1 : 0;\n\n\terr = bpf_iter_task_vma__load(skel);\n\tif (!ASSERT_OK(err, \"bpf_iter_task_vma__load\"))\n\t\tgoto out;\n\n\tskel->links.proc_maps = bpf_program__attach_iter(\n\t\tskel->progs.proc_maps, opts);\n\n\tif (!ASSERT_OK_PTR(skel->links.proc_maps, \"bpf_program__attach_iter\")) {\n\t\tskel->links.proc_maps = NULL;\n\t\tgoto out;\n\t}\n\n\titer_fd = bpf_iter_create(bpf_link__fd(skel->links.proc_maps));\n\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\tgoto out;\n\n\t \n\tlen = 0;\n\twhile (len < CMP_BUFFER_SIZE) {\n\t\terr = read_fd_into_buffer(iter_fd, task_vma_output + len,\n\t\t\t\t\t  MIN(read_size, CMP_BUFFER_SIZE - len));\n\t\tif (!err)\n\t\t\tbreak;\n\t\tif (!ASSERT_GE(err, 0, \"read_iter_fd\"))\n\t\t\tgoto out;\n\t\tlen += err;\n\t}\n\tif (opts)\n\t\tASSERT_EQ(skel->bss->one_task_error, 0, \"unexpected task\");\n\n\t \n\tsnprintf(maps_path, 64, \"/proc/%u/maps\", skel->bss->pid);\n\tproc_maps_fd = open(maps_path, O_RDONLY);\n\tif (!ASSERT_GE(proc_maps_fd, 0, \"open_proc_maps\"))\n\t\tgoto out;\n\terr = read_fd_into_buffer(proc_maps_fd, proc_maps_output, CMP_BUFFER_SIZE);\n\tif (!ASSERT_GE(err, 0, \"read_prog_maps_fd\"))\n\t\tgoto out;\n\n\t \n\tstr_strip_first_line(task_vma_output);\n\tstr_strip_first_line(proc_maps_output);\n\n\tASSERT_STREQ(task_vma_output, proc_maps_output, \"compare_output\");\n\n\tcheck_bpf_link_info(skel->progs.proc_maps);\n\nout:\n\tclose(proc_maps_fd);\n\tclose(iter_fd);\n\tbpf_iter_task_vma__destroy(skel);\n}\n\nstatic void test_task_vma_dead_task(void)\n{\n\tstruct bpf_iter_task_vma *skel;\n\tint wstatus, child_pid = -1;\n\ttime_t start_tm, cur_tm;\n\tint err, iter_fd = -1;\n\tint wait_sec = 3;\n\n\tskel = bpf_iter_task_vma__open();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_task_vma__open\"))\n\t\treturn;\n\n\tskel->bss->pid = getpid();\n\n\terr = bpf_iter_task_vma__load(skel);\n\tif (!ASSERT_OK(err, \"bpf_iter_task_vma__load\"))\n\t\tgoto out;\n\n\tskel->links.proc_maps = bpf_program__attach_iter(\n\t\tskel->progs.proc_maps, NULL);\n\n\tif (!ASSERT_OK_PTR(skel->links.proc_maps, \"bpf_program__attach_iter\")) {\n\t\tskel->links.proc_maps = NULL;\n\t\tgoto out;\n\t}\n\n\tstart_tm = time(NULL);\n\tcur_tm = start_tm;\n\n\tchild_pid = fork();\n\tif (child_pid == 0) {\n\t\t \n\t\twhile (cur_tm < start_tm + wait_sec) {\n\t\t\tsystem(\"echo > /dev/null\");\n\t\t\tcur_tm = time(NULL);\n\t\t}\n\t\texit(0);\n\t}\n\n\tif (!ASSERT_GE(child_pid, 0, \"fork_child\"))\n\t\tgoto out;\n\n\twhile (cur_tm < start_tm + wait_sec) {\n\t\titer_fd = bpf_iter_create(bpf_link__fd(skel->links.proc_maps));\n\t\tif (!ASSERT_GE(iter_fd, 0, \"create_iter\"))\n\t\t\tgoto out;\n\n\t\t \n\t\twhile (cur_tm < start_tm + wait_sec) {\n\t\t\terr = read_fd_into_buffer(iter_fd, task_vma_output, CMP_BUFFER_SIZE);\n\t\t\tif (!ASSERT_GE(err, 0, \"read_iter_fd\"))\n\t\t\t\tgoto out;\n\n\t\t\tcur_tm = time(NULL);\n\n\t\t\tif (err == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tclose(iter_fd);\n\t\titer_fd = -1;\n\t}\n\n\tcheck_bpf_link_info(skel->progs.proc_maps);\n\nout:\n\twaitpid(child_pid, &wstatus, 0);\n\tclose(iter_fd);\n\tbpf_iter_task_vma__destroy(skel);\n}\n\nvoid test_bpf_sockmap_map_iter_fd(void)\n{\n\tstruct bpf_iter_sockmap *skel;\n\n\tskel = bpf_iter_sockmap__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_sockmap__open_and_load\"))\n\t\treturn;\n\n\tdo_read_map_iter_fd(&skel->skeleton, skel->progs.copy, skel->maps.sockmap);\n\n\tbpf_iter_sockmap__destroy(skel);\n}\n\nstatic void test_task_vma(void)\n{\n\tLIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.task.tid = getpid();\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\ttest_task_vma_common(&opts);\n\ttest_task_vma_common(NULL);\n}\n\n \nstatic noinline int trigger_func(int arg)\n{\n\tasm volatile (\"\");\n\treturn arg + 1;\n}\n\nstatic void test_task_vma_offset_common(struct bpf_iter_attach_opts *opts, bool one_proc)\n{\n\tstruct bpf_iter_vma_offset *skel;\n\tchar buf[16] = {};\n\tint iter_fd, len;\n\tint pgsz, shift;\n\n\tskel = bpf_iter_vma_offset__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"bpf_iter_vma_offset__open_and_load\"))\n\t\treturn;\n\n\tskel->bss->pid = getpid();\n\tskel->bss->address = (uintptr_t)trigger_func;\n\tfor (pgsz = getpagesize(), shift = 0; pgsz > 1; pgsz >>= 1, shift++)\n\t\t;\n\tskel->bss->page_shift = shift;\n\n\tskel->links.get_vma_offset = bpf_program__attach_iter(skel->progs.get_vma_offset, opts);\n\tif (!ASSERT_OK_PTR(skel->links.get_vma_offset, \"attach_iter\"))\n\t\tgoto exit;\n\n\titer_fd = bpf_iter_create(bpf_link__fd(skel->links.get_vma_offset));\n\tif (!ASSERT_GT(iter_fd, 0, \"create_iter\"))\n\t\tgoto exit;\n\n\twhile ((len = read(iter_fd, buf, sizeof(buf))) > 0)\n\t\t;\n\tbuf[15] = 0;\n\tASSERT_EQ(strcmp(buf, \"OK\\n\"), 0, \"strcmp\");\n\n\tASSERT_EQ(skel->bss->offset, get_uprobe_offset(trigger_func), \"offset\");\n\tif (one_proc)\n\t\tASSERT_EQ(skel->bss->unique_tgid_cnt, 1, \"unique_tgid_count\");\n\telse\n\t\tASSERT_GT(skel->bss->unique_tgid_cnt, 1, \"unique_tgid_count\");\n\n\tclose(iter_fd);\n\nexit:\n\tbpf_iter_vma_offset__destroy(skel);\n}\n\nstatic void test_task_vma_offset(void)\n{\n\tLIBBPF_OPTS(bpf_iter_attach_opts, opts);\n\tunion bpf_iter_link_info linfo;\n\n\tmemset(&linfo, 0, sizeof(linfo));\n\tlinfo.task.pid = getpid();\n\topts.link_info = &linfo;\n\topts.link_info_len = sizeof(linfo);\n\n\ttest_task_vma_offset_common(&opts, true);\n\n\tlinfo.task.pid = 0;\n\tlinfo.task.tid = getpid();\n\ttest_task_vma_offset_common(&opts, true);\n\n\ttest_task_vma_offset_common(NULL, false);\n}\n\nvoid test_bpf_iter(void)\n{\n\tASSERT_OK(pthread_mutex_init(&do_nothing_mutex, NULL), \"pthread_mutex_init\");\n\n\tif (test__start_subtest(\"btf_id_or_null\"))\n\t\ttest_btf_id_or_null();\n\tif (test__start_subtest(\"ipv6_route\"))\n\t\ttest_ipv6_route();\n\tif (test__start_subtest(\"netlink\"))\n\t\ttest_netlink();\n\tif (test__start_subtest(\"bpf_map\"))\n\t\ttest_bpf_map();\n\tif (test__start_subtest(\"task_tid\"))\n\t\ttest_task_tid();\n\tif (test__start_subtest(\"task_pid\"))\n\t\ttest_task_pid();\n\tif (test__start_subtest(\"task_pidfd\"))\n\t\ttest_task_pidfd();\n\tif (test__start_subtest(\"task_sleepable\"))\n\t\ttest_task_sleepable();\n\tif (test__start_subtest(\"task_stack\"))\n\t\ttest_task_stack();\n\tif (test__start_subtest(\"task_file\"))\n\t\ttest_task_file();\n\tif (test__start_subtest(\"task_vma\"))\n\t\ttest_task_vma();\n\tif (test__start_subtest(\"task_vma_dead_task\"))\n\t\ttest_task_vma_dead_task();\n\tif (test__start_subtest(\"task_btf\"))\n\t\ttest_task_btf();\n\tif (test__start_subtest(\"tcp4\"))\n\t\ttest_tcp4();\n\tif (test__start_subtest(\"tcp6\"))\n\t\ttest_tcp6();\n\tif (test__start_subtest(\"udp4\"))\n\t\ttest_udp4();\n\tif (test__start_subtest(\"udp6\"))\n\t\ttest_udp6();\n\tif (test__start_subtest(\"unix\"))\n\t\ttest_unix();\n\tif (test__start_subtest(\"anon\"))\n\t\ttest_anon_iter(false);\n\tif (test__start_subtest(\"anon-read-one-char\"))\n\t\ttest_anon_iter(true);\n\tif (test__start_subtest(\"file\"))\n\t\ttest_file_iter();\n\tif (test__start_subtest(\"overflow\"))\n\t\ttest_overflow(false, false);\n\tif (test__start_subtest(\"overflow-e2big\"))\n\t\ttest_overflow(true, false);\n\tif (test__start_subtest(\"prog-ret-1\"))\n\t\ttest_overflow(false, true);\n\tif (test__start_subtest(\"bpf_hash_map\"))\n\t\ttest_bpf_hash_map();\n\tif (test__start_subtest(\"bpf_percpu_hash_map\"))\n\t\ttest_bpf_percpu_hash_map();\n\tif (test__start_subtest(\"bpf_array_map\"))\n\t\ttest_bpf_array_map();\n\tif (test__start_subtest(\"bpf_array_map_iter_fd\"))\n\t\ttest_bpf_array_map_iter_fd();\n\tif (test__start_subtest(\"bpf_percpu_array_map\"))\n\t\ttest_bpf_percpu_array_map();\n\tif (test__start_subtest(\"bpf_sk_storage_map\"))\n\t\ttest_bpf_sk_storage_map();\n\tif (test__start_subtest(\"bpf_sk_storage_map_iter_fd\"))\n\t\ttest_bpf_sk_stoarge_map_iter_fd();\n\tif (test__start_subtest(\"bpf_sk_storage_delete\"))\n\t\ttest_bpf_sk_storage_delete();\n\tif (test__start_subtest(\"bpf_sk_storage_get\"))\n\t\ttest_bpf_sk_storage_get();\n\tif (test__start_subtest(\"rdonly-buf-out-of-bound\"))\n\t\ttest_rdonly_buf_out_of_bound();\n\tif (test__start_subtest(\"buf-neg-offset\"))\n\t\ttest_buf_neg_offset();\n\tif (test__start_subtest(\"link-iter\"))\n\t\ttest_link_iter();\n\tif (test__start_subtest(\"ksym\"))\n\t\ttest_ksym_iter();\n\tif (test__start_subtest(\"bpf_sockmap_map_iter_fd\"))\n\t\ttest_bpf_sockmap_map_iter_fd();\n\tif (test__start_subtest(\"vma_offset\"))\n\t\ttest_task_vma_offset();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}