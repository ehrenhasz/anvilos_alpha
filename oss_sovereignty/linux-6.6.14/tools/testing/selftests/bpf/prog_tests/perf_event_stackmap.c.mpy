{
  "module_name": "perf_event_stackmap.c",
  "hash_id": "02af02b27d35ac6f647410d3bb55605fbaac4ee0484f89ff835b7df723e7e977",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/perf_event_stackmap.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <sched.h>\n#include <test_progs.h>\n#include \"perf_event_stackmap.skel.h\"\n\n#ifndef noinline\n#define noinline __attribute__((noinline))\n#endif\n\nnoinline int func_1(void)\n{\n\tstatic int val = 1;\n\n\tval += 1;\n\n\tusleep(100);\n\treturn val;\n}\n\nnoinline int func_2(void)\n{\n\treturn func_1();\n}\n\nnoinline int func_3(void)\n{\n\treturn func_2();\n}\n\nnoinline int func_4(void)\n{\n\treturn func_3();\n}\n\nnoinline int func_5(void)\n{\n\treturn func_4();\n}\n\nnoinline int func_6(void)\n{\n\tint i, val = 1;\n\n\tfor (i = 0; i < 100; i++)\n\t\tval += func_5();\n\n\treturn val;\n}\n\nvoid test_perf_event_stackmap(void)\n{\n\tstruct perf_event_attr attr = {\n\t\t \n\t\t.type = PERF_TYPE_HARDWARE,\n\t\t.config = PERF_COUNT_HW_CPU_CYCLES,\n\t\t.precise_ip = 2,\n\t\t.sample_type = PERF_SAMPLE_IP | PERF_SAMPLE_BRANCH_STACK |\n\t\t\tPERF_SAMPLE_CALLCHAIN,\n\t\t.branch_sample_type = PERF_SAMPLE_BRANCH_USER |\n\t\t\tPERF_SAMPLE_BRANCH_NO_FLAGS |\n\t\t\tPERF_SAMPLE_BRANCH_NO_CYCLES |\n\t\t\tPERF_SAMPLE_BRANCH_CALL_STACK,\n\t\t.freq = 1,\n\t\t.sample_freq = read_perf_max_sample_freq(),\n\t\t.size = sizeof(struct perf_event_attr),\n\t};\n\tstruct perf_event_stackmap *skel;\n\t__u32 duration = 0;\n\tcpu_set_t cpu_set;\n\tint pmu_fd, err;\n\n\tskel = perf_event_stackmap__open();\n\n\tif (CHECK(!skel, \"skel_open\", \"skeleton open failed\\n\"))\n\t\treturn;\n\n\terr = perf_event_stackmap__load(skel);\n\tif (CHECK(err, \"skel_load\", \"skeleton load failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tCPU_ZERO(&cpu_set);\n\tCPU_SET(0, &cpu_set);\n\terr = pthread_setaffinity_np(pthread_self(), sizeof(cpu_set), &cpu_set);\n\tif (CHECK(err, \"set_affinity\", \"err %d, errno %d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\tpmu_fd = syscall(__NR_perf_event_open, &attr, -1  ,\n\t\t\t 0  , -1  ,\n\t\t\t 0  );\n\tif (pmu_fd < 0) {\n\t\tprintf(\"%s:SKIP:cpu doesn't support the event\\n\", __func__);\n\t\ttest__skip();\n\t\tgoto cleanup;\n\t}\n\n\tskel->links.oncpu = bpf_program__attach_perf_event(skel->progs.oncpu,\n\t\t\t\t\t\t\t   pmu_fd);\n\tif (!ASSERT_OK_PTR(skel->links.oncpu, \"attach_perf_event\")) {\n\t\tclose(pmu_fd);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tfunc_6();\n\n\tCHECK(skel->data->stackid_kernel != 2, \"get_stackid_kernel\", \"failed\\n\");\n\tCHECK(skel->data->stackid_user != 2, \"get_stackid_user\", \"failed\\n\");\n\tCHECK(skel->data->stack_kernel != 2, \"get_stack_kernel\", \"failed\\n\");\n\tCHECK(skel->data->stack_user != 2, \"get_stack_user\", \"failed\\n\");\n\ncleanup:\n\tperf_event_stackmap__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}