{
  "module_name": "for_each.c",
  "hash_id": "52670e7524b726ed173ba679121cf43f1183c267274a5f9a6c99560750b026a2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/for_each.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <network_helpers.h>\n#include \"for_each_hash_map_elem.skel.h\"\n#include \"for_each_array_map_elem.skel.h\"\n#include \"for_each_map_elem_write_key.skel.h\"\n\nstatic unsigned int duration;\n\nstatic void test_hash_map(void)\n{\n\tint i, err, max_entries;\n\tstruct for_each_hash_map_elem *skel;\n\t__u64 *percpu_valbuf = NULL;\n\tsize_t percpu_val_sz;\n\t__u32 key, num_cpus;\n\t__u64 val;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\n\tskel = for_each_hash_map_elem__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"for_each_hash_map_elem__open_and_load\"))\n\t\treturn;\n\n\tmax_entries = bpf_map__max_entries(skel->maps.hashmap);\n\tfor (i = 0; i < max_entries; i++) {\n\t\tkey = i;\n\t\tval = i + 1;\n\t\terr = bpf_map__update_elem(skel->maps.hashmap, &key, sizeof(key),\n\t\t\t\t\t   &val, sizeof(val), BPF_ANY);\n\t\tif (!ASSERT_OK(err, \"map_update\"))\n\t\t\tgoto out;\n\t}\n\n\tnum_cpus = bpf_num_possible_cpus();\n\tpercpu_val_sz = sizeof(__u64) * num_cpus;\n\tpercpu_valbuf = malloc(percpu_val_sz);\n\tif (!ASSERT_OK_PTR(percpu_valbuf, \"percpu_valbuf\"))\n\t\tgoto out;\n\n\tkey = 1;\n\tfor (i = 0; i < num_cpus; i++)\n\t\tpercpu_valbuf[i] = i + 1;\n\terr = bpf_map__update_elem(skel->maps.percpu_map, &key, sizeof(key),\n\t\t\t\t   percpu_valbuf, percpu_val_sz, BPF_ANY);\n\tif (!ASSERT_OK(err, \"percpu_map_update\"))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.test_pkt_access), &topts);\n\tduration = topts.duration;\n\tif (CHECK(err || topts.retval, \"ipv4\", \"err %d errno %d retval %d\\n\",\n\t\t  err, errno, topts.retval))\n\t\tgoto out;\n\n\tASSERT_EQ(skel->bss->hashmap_output, 4, \"hashmap_output\");\n\tASSERT_EQ(skel->bss->hashmap_elems, max_entries, \"hashmap_elems\");\n\n\tkey = 1;\n\terr = bpf_map__lookup_elem(skel->maps.hashmap, &key, sizeof(key), &val, sizeof(val), 0);\n\tASSERT_ERR(err, \"hashmap_lookup\");\n\n\tASSERT_EQ(skel->bss->percpu_called, 1, \"percpu_called\");\n\tASSERT_LT(skel->bss->cpu, num_cpus, \"num_cpus\");\n\tASSERT_EQ(skel->bss->percpu_map_elems, 1, \"percpu_map_elems\");\n\tASSERT_EQ(skel->bss->percpu_key, 1, \"percpu_key\");\n\tASSERT_EQ(skel->bss->percpu_val, skel->bss->cpu + 1, \"percpu_val\");\n\tASSERT_EQ(skel->bss->percpu_output, 100, \"percpu_output\");\nout:\n\tfree(percpu_valbuf);\n\tfor_each_hash_map_elem__destroy(skel);\n}\n\nstatic void test_array_map(void)\n{\n\t__u32 key, num_cpus, max_entries;\n\tint i, err;\n\tstruct for_each_array_map_elem *skel;\n\t__u64 *percpu_valbuf = NULL;\n\tsize_t percpu_val_sz;\n\t__u64 val, expected_total;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.repeat = 1,\n\t);\n\n\tskel = for_each_array_map_elem__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"for_each_array_map_elem__open_and_load\"))\n\t\treturn;\n\n\texpected_total = 0;\n\tmax_entries = bpf_map__max_entries(skel->maps.arraymap);\n\tfor (i = 0; i < max_entries; i++) {\n\t\tkey = i;\n\t\tval = i + 1;\n\t\t \n\t\tif (i != max_entries - 1)\n\t\t\texpected_total += val;\n\t\terr = bpf_map__update_elem(skel->maps.arraymap, &key, sizeof(key),\n\t\t\t\t\t   &val, sizeof(val), BPF_ANY);\n\t\tif (!ASSERT_OK(err, \"map_update\"))\n\t\t\tgoto out;\n\t}\n\n\tnum_cpus = bpf_num_possible_cpus();\n\tpercpu_val_sz = sizeof(__u64) * num_cpus;\n\tpercpu_valbuf = malloc(percpu_val_sz);\n\tif (!ASSERT_OK_PTR(percpu_valbuf, \"percpu_valbuf\"))\n\t\tgoto out;\n\n\tkey = 0;\n\tfor (i = 0; i < num_cpus; i++)\n\t\tpercpu_valbuf[i] = i + 1;\n\terr = bpf_map__update_elem(skel->maps.percpu_map, &key, sizeof(key),\n\t\t\t\t   percpu_valbuf, percpu_val_sz, BPF_ANY);\n\tif (!ASSERT_OK(err, \"percpu_map_update\"))\n\t\tgoto out;\n\n\terr = bpf_prog_test_run_opts(bpf_program__fd(skel->progs.test_pkt_access), &topts);\n\tduration = topts.duration;\n\tif (CHECK(err || topts.retval, \"ipv4\", \"err %d errno %d retval %d\\n\",\n\t\t  err, errno, topts.retval))\n\t\tgoto out;\n\n\tASSERT_EQ(skel->bss->arraymap_output, expected_total, \"array_output\");\n\tASSERT_EQ(skel->bss->cpu + 1, skel->bss->percpu_val, \"percpu_val\");\n\nout:\n\tfree(percpu_valbuf);\n\tfor_each_array_map_elem__destroy(skel);\n}\n\nstatic void test_write_map_key(void)\n{\n\tstruct for_each_map_elem_write_key *skel;\n\n\tskel = for_each_map_elem_write_key__open_and_load();\n\tif (!ASSERT_ERR_PTR(skel, \"for_each_map_elem_write_key__open_and_load\"))\n\t\tfor_each_map_elem_write_key__destroy(skel);\n}\n\nvoid test_for_each(void)\n{\n\tif (test__start_subtest(\"hash_map\"))\n\t\ttest_hash_map();\n\tif (test__start_subtest(\"array_map\"))\n\t\ttest_array_map();\n\tif (test__start_subtest(\"write_map_key\"))\n\t\ttest_write_map_key();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}