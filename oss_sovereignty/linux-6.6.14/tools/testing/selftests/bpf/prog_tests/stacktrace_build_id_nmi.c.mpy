{
  "module_name": "stacktrace_build_id_nmi.c",
  "hash_id": "60a29fd891119d7fcf9e0e6cbf779e032ebee45dac4e06f8922d8fa00c4932ef",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/stacktrace_build_id_nmi.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include \"test_stacktrace_build_id.skel.h\"\n\nvoid test_stacktrace_build_id_nmi(void)\n{\n\tint control_map_fd, stackid_hmap_fd, stackmap_fd;\n\tstruct test_stacktrace_build_id *skel;\n\tint err, pmu_fd;\n\tstruct perf_event_attr attr = {\n\t\t.freq = 1,\n\t\t.type = PERF_TYPE_HARDWARE,\n\t\t.config = PERF_COUNT_HW_CPU_CYCLES,\n\t};\n\t__u32 key, prev_key, val, duration = 0;\n\tchar buf[BPF_BUILD_ID_SIZE];\n\tstruct bpf_stack_build_id id_offs[PERF_MAX_STACK_DEPTH];\n\tint build_id_matches = 0, build_id_size;\n\tint i, retry = 1;\n\n\tattr.sample_freq = read_perf_max_sample_freq();\n\nretry:\n\tskel = test_stacktrace_build_id__open();\n\tif (CHECK(!skel, \"skel_open\", \"skeleton open failed\\n\"))\n\t\treturn;\n\n\t \n\tbpf_program__set_type(skel->progs.oncpu, BPF_PROG_TYPE_PERF_EVENT);\n\n\terr = test_stacktrace_build_id__load(skel);\n\tif (CHECK(err, \"skel_load\", \"skeleton load failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tpmu_fd = syscall(__NR_perf_event_open, &attr, -1  ,\n\t\t\t 0  , -1  ,\n\t\t\t 0  );\n\tif (pmu_fd < 0 && errno == ENOENT) {\n\t\tprintf(\"%s:SKIP:no PERF_COUNT_HW_CPU_CYCLES\\n\", __func__);\n\t\ttest__skip();\n\t\tgoto cleanup;\n\t}\n\tif (CHECK(pmu_fd < 0, \"perf_event_open\", \"err %d errno %d\\n\",\n\t\t  pmu_fd, errno))\n\t\tgoto cleanup;\n\n\tskel->links.oncpu = bpf_program__attach_perf_event(skel->progs.oncpu,\n\t\t\t\t\t\t\t   pmu_fd);\n\tif (!ASSERT_OK_PTR(skel->links.oncpu, \"attach_perf_event\")) {\n\t\tclose(pmu_fd);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tcontrol_map_fd = bpf_map__fd(skel->maps.control_map);\n\tstackid_hmap_fd = bpf_map__fd(skel->maps.stackid_hmap);\n\tstackmap_fd = bpf_map__fd(skel->maps.stackmap);\n\n\tif (CHECK_FAIL(system(\"dd if=/dev/urandom of=/dev/zero count=4 2> /dev/null\")))\n\t\tgoto cleanup;\n\tif (CHECK_FAIL(system(\"taskset 0x1 ./urandom_read 100000\")))\n\t\tgoto cleanup;\n\t \n\tkey = 0;\n\tval = 1;\n\tbpf_map_update_elem(control_map_fd, &key, &val, 0);\n\n\t \n\terr = compare_map_keys(stackid_hmap_fd, stackmap_fd);\n\tif (CHECK(err, \"compare_map_keys stackid_hmap vs. stackmap\",\n\t\t  \"err %d errno %d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\terr = compare_map_keys(stackmap_fd, stackid_hmap_fd);\n\tif (CHECK(err, \"compare_map_keys stackmap vs. stackid_hmap\",\n\t\t  \"err %d errno %d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\tbuild_id_size = read_build_id(\"urandom_read\", buf, sizeof(buf));\n\terr = build_id_size < 0 ? build_id_size : 0;\n\n\tif (CHECK(err, \"get build_id with readelf\",\n\t\t  \"err %d errno %d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\terr = bpf_map__get_next_key(skel->maps.stackmap, NULL, &key, sizeof(key));\n\tif (CHECK(err, \"get_next_key from stackmap\",\n\t\t  \"err %d, errno %d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\tdo {\n\t\terr = bpf_map__lookup_elem(skel->maps.stackmap, &key, sizeof(key),\n\t\t\t\t\t   id_offs, sizeof(id_offs), 0);\n\t\tif (CHECK(err, \"lookup_elem from stackmap\",\n\t\t\t  \"err %d, errno %d\\n\", err, errno))\n\t\t\tgoto cleanup;\n\t\tfor (i = 0; i < PERF_MAX_STACK_DEPTH; ++i)\n\t\t\tif (id_offs[i].status == BPF_STACK_BUILD_ID_VALID &&\n\t\t\t    id_offs[i].offset != 0) {\n\t\t\t\tif (memcmp(buf, id_offs[i].build_id, build_id_size) == 0)\n\t\t\t\t\tbuild_id_matches = 1;\n\t\t\t}\n\t\tprev_key = key;\n\t} while (bpf_map__get_next_key(skel->maps.stackmap, &prev_key, &key, sizeof(key)) == 0);\n\n\t \n\tif (build_id_matches < 1 && retry--) {\n\t\ttest_stacktrace_build_id__destroy(skel);\n\t\tprintf(\"%s:WARN:Didn't find expected build ID from the map, retrying\\n\",\n\t\t       __func__);\n\t\tgoto retry;\n\t}\n\n\tif (CHECK(build_id_matches < 1, \"build id match\",\n\t\t  \"Didn't find expected build ID from the map\\n\"))\n\t\tgoto cleanup;\n\n\t \n\ncleanup:\n\ttest_stacktrace_build_id__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}