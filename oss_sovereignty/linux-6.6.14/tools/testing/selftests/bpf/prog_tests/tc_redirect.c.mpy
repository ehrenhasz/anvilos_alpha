{
  "module_name": "tc_redirect.c",
  "hash_id": "d8b5f435c3ca8bcf1d8d4578ecf22aab856492565a8c21831e1d811d9c44739f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/tc_redirect.c",
  "human_readable_source": "\n\n \n\n#include <arpa/inet.h>\n#include <linux/if_tun.h>\n#include <linux/limits.h>\n#include <linux/sysctl.h>\n#include <linux/time_types.h>\n#include <linux/net_tstamp.h>\n#include <net/if.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"test_progs.h\"\n#include \"network_helpers.h\"\n#include \"test_tc_neigh_fib.skel.h\"\n#include \"test_tc_neigh.skel.h\"\n#include \"test_tc_peer.skel.h\"\n#include \"test_tc_dtime.skel.h\"\n\n#ifndef TCP_TX_DELAY\n#define TCP_TX_DELAY 37\n#endif\n\n#define NS_SRC \"ns_src\"\n#define NS_FWD \"ns_fwd\"\n#define NS_DST \"ns_dst\"\n\n#define IP4_SRC \"172.16.1.100\"\n#define IP4_DST \"172.16.2.100\"\n#define IP4_TUN_SRC \"172.17.1.100\"\n#define IP4_TUN_FWD \"172.17.1.200\"\n#define IP4_PORT 9004\n\n#define IP6_SRC \"0::1:dead:beef:cafe\"\n#define IP6_DST \"0::2:dead:beef:cafe\"\n#define IP6_TUN_SRC \"1::1:dead:beef:cafe\"\n#define IP6_TUN_FWD \"1::2:dead:beef:cafe\"\n#define IP6_PORT 9006\n\n#define IP4_SLL \"169.254.0.1\"\n#define IP4_DLL \"169.254.0.2\"\n#define IP4_NET \"169.254.0.0\"\n\n#define MAC_DST_FWD \"00:11:22:33:44:55\"\n#define MAC_DST \"00:22:33:44:55:66\"\n\n#define IFADDR_STR_LEN 18\n#define PING_ARGS \"-i 0.2 -c 3 -w 10 -q\"\n\n#define TIMEOUT_MILLIS 10000\n#define NSEC_PER_SEC 1000000000ULL\n\n#define log_err(MSG, ...) \\\n\tfprintf(stderr, \"(%s:%d: errno: %s) \" MSG \"\\n\", \\\n\t\t__FILE__, __LINE__, strerror(errno), ##__VA_ARGS__)\n\nstatic const char * const namespaces[] = {NS_SRC, NS_FWD, NS_DST, NULL};\n\nstatic int write_file(const char *path, const char *newval)\n{\n\tFILE *f;\n\n\tf = fopen(path, \"r+\");\n\tif (!f)\n\t\treturn -1;\n\tif (fwrite(newval, strlen(newval), 1, f) != 1) {\n\t\tlog_err(\"writing to %s failed\", path);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tfclose(f);\n\treturn 0;\n}\n\nstatic int netns_setup_namespaces(const char *verb)\n{\n\tconst char * const *ns = namespaces;\n\tchar cmd[128];\n\n\twhile (*ns) {\n\t\tsnprintf(cmd, sizeof(cmd), \"ip netns %s %s\", verb, *ns);\n\t\tif (!ASSERT_OK(system(cmd), cmd))\n\t\t\treturn -1;\n\t\tns++;\n\t}\n\treturn 0;\n}\n\nstatic void netns_setup_namespaces_nofail(const char *verb)\n{\n\tconst char * const *ns = namespaces;\n\tchar cmd[128];\n\n\twhile (*ns) {\n\t\tsnprintf(cmd, sizeof(cmd), \"ip netns %s %s > /dev/null 2>&1\", verb, *ns);\n\t\tsystem(cmd);\n\t\tns++;\n\t}\n}\n\nstruct netns_setup_result {\n\tint ifindex_veth_src;\n\tint ifindex_veth_src_fwd;\n\tint ifindex_veth_dst;\n\tint ifindex_veth_dst_fwd;\n};\n\nstatic int get_ifaddr(const char *name, char *ifaddr)\n{\n\tchar path[PATH_MAX];\n\tFILE *f;\n\tint ret;\n\n\tsnprintf(path, PATH_MAX, \"/sys/class/net/%s/address\", name);\n\tf = fopen(path, \"r\");\n\tif (!ASSERT_OK_PTR(f, path))\n\t\treturn -1;\n\n\tret = fread(ifaddr, 1, IFADDR_STR_LEN, f);\n\tif (!ASSERT_EQ(ret, IFADDR_STR_LEN, \"fread ifaddr\")) {\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\tfclose(f);\n\treturn 0;\n}\n\nstatic int netns_setup_links_and_routes(struct netns_setup_result *result)\n{\n\tstruct nstoken *nstoken = NULL;\n\tchar veth_src_fwd_addr[IFADDR_STR_LEN+1] = {};\n\n\tSYS(fail, \"ip link add veth_src type veth peer name veth_src_fwd\");\n\tSYS(fail, \"ip link add veth_dst type veth peer name veth_dst_fwd\");\n\n\tSYS(fail, \"ip link set veth_dst_fwd address \" MAC_DST_FWD);\n\tSYS(fail, \"ip link set veth_dst address \" MAC_DST);\n\n\tif (get_ifaddr(\"veth_src_fwd\", veth_src_fwd_addr))\n\t\tgoto fail;\n\n\tresult->ifindex_veth_src = if_nametoindex(\"veth_src\");\n\tif (!ASSERT_GT(result->ifindex_veth_src, 0, \"ifindex_veth_src\"))\n\t\tgoto fail;\n\n\tresult->ifindex_veth_src_fwd = if_nametoindex(\"veth_src_fwd\");\n\tif (!ASSERT_GT(result->ifindex_veth_src_fwd, 0, \"ifindex_veth_src_fwd\"))\n\t\tgoto fail;\n\n\tresult->ifindex_veth_dst = if_nametoindex(\"veth_dst\");\n\tif (!ASSERT_GT(result->ifindex_veth_dst, 0, \"ifindex_veth_dst\"))\n\t\tgoto fail;\n\n\tresult->ifindex_veth_dst_fwd = if_nametoindex(\"veth_dst_fwd\");\n\tif (!ASSERT_GT(result->ifindex_veth_dst_fwd, 0, \"ifindex_veth_dst_fwd\"))\n\t\tgoto fail;\n\n\tSYS(fail, \"ip link set veth_src netns \" NS_SRC);\n\tSYS(fail, \"ip link set veth_src_fwd netns \" NS_FWD);\n\tSYS(fail, \"ip link set veth_dst_fwd netns \" NS_FWD);\n\tSYS(fail, \"ip link set veth_dst netns \" NS_DST);\n\n\t \n\tnstoken = open_netns(NS_SRC);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns src\"))\n\t\tgoto fail;\n\n\tSYS(fail, \"ip addr add \" IP4_SRC \"/32 dev veth_src\");\n\tSYS(fail, \"ip addr add \" IP6_SRC \"/128 dev veth_src nodad\");\n\tSYS(fail, \"ip link set dev veth_src up\");\n\n\tSYS(fail, \"ip route add \" IP4_DST \"/32 dev veth_src scope global\");\n\tSYS(fail, \"ip route add \" IP4_NET \"/16 dev veth_src scope global\");\n\tSYS(fail, \"ip route add \" IP6_DST \"/128 dev veth_src scope global\");\n\n\tSYS(fail, \"ip neigh add \" IP4_DST \" dev veth_src lladdr %s\",\n\t    veth_src_fwd_addr);\n\tSYS(fail, \"ip neigh add \" IP6_DST \" dev veth_src lladdr %s\",\n\t    veth_src_fwd_addr);\n\n\tclose_netns(nstoken);\n\n\t \n\tnstoken = open_netns(NS_FWD);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns fwd\"))\n\t\tgoto fail;\n\n\t \n\tSYS(fail, \"ip addr add \" IP4_SLL \"/32 dev veth_src_fwd\");\n\tSYS(fail, \"ip addr add \" IP4_DLL \"/32 dev veth_dst_fwd\");\n\tSYS(fail, \"ip link set dev veth_src_fwd up\");\n\tSYS(fail, \"ip link set dev veth_dst_fwd up\");\n\n\tSYS(fail, \"ip route add \" IP4_SRC \"/32 dev veth_src_fwd scope global\");\n\tSYS(fail, \"ip route add \" IP6_SRC \"/128 dev veth_src_fwd scope global\");\n\tSYS(fail, \"ip route add \" IP4_DST \"/32 dev veth_dst_fwd scope global\");\n\tSYS(fail, \"ip route add \" IP6_DST \"/128 dev veth_dst_fwd scope global\");\n\n\tclose_netns(nstoken);\n\n\t \n\tnstoken = open_netns(NS_DST);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns dst\"))\n\t\tgoto fail;\n\n\tSYS(fail, \"ip addr add \" IP4_DST \"/32 dev veth_dst\");\n\tSYS(fail, \"ip addr add \" IP6_DST \"/128 dev veth_dst nodad\");\n\tSYS(fail, \"ip link set dev veth_dst up\");\n\n\tSYS(fail, \"ip route add \" IP4_SRC \"/32 dev veth_dst scope global\");\n\tSYS(fail, \"ip route add \" IP4_NET \"/16 dev veth_dst scope global\");\n\tSYS(fail, \"ip route add \" IP6_SRC \"/128 dev veth_dst scope global\");\n\n\tSYS(fail, \"ip neigh add \" IP4_SRC \" dev veth_dst lladdr \" MAC_DST_FWD);\n\tSYS(fail, \"ip neigh add \" IP6_SRC \" dev veth_dst lladdr \" MAC_DST_FWD);\n\n\tclose_netns(nstoken);\n\n\treturn 0;\nfail:\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n\treturn -1;\n}\n\nstatic int qdisc_clsact_create(struct bpf_tc_hook *qdisc_hook, int ifindex)\n{\n\tchar err_str[128], ifname[16];\n\tint err;\n\n\tqdisc_hook->ifindex = ifindex;\n\tqdisc_hook->attach_point = BPF_TC_INGRESS | BPF_TC_EGRESS;\n\terr = bpf_tc_hook_create(qdisc_hook);\n\tsnprintf(err_str, sizeof(err_str),\n\t\t \"qdisc add dev %s clsact\",\n\t\t if_indextoname(qdisc_hook->ifindex, ifname) ? : \"<unknown_iface>\");\n\terr_str[sizeof(err_str) - 1] = 0;\n\tASSERT_OK(err, err_str);\n\n\treturn err;\n}\n\nstatic int xgress_filter_add(struct bpf_tc_hook *qdisc_hook,\n\t\t\t     enum bpf_tc_attach_point xgress,\n\t\t\t     const struct bpf_program *prog, int priority)\n{\n\tLIBBPF_OPTS(bpf_tc_opts, tc_attach);\n\tchar err_str[128], ifname[16];\n\tint err;\n\n\tqdisc_hook->attach_point = xgress;\n\ttc_attach.prog_fd = bpf_program__fd(prog);\n\ttc_attach.priority = priority;\n\terr = bpf_tc_attach(qdisc_hook, &tc_attach);\n\tsnprintf(err_str, sizeof(err_str),\n\t\t \"filter add dev %s %s prio %d bpf da %s\",\n\t\t if_indextoname(qdisc_hook->ifindex, ifname) ? : \"<unknown_iface>\",\n\t\t xgress == BPF_TC_INGRESS ? \"ingress\" : \"egress\",\n\t\t priority, bpf_program__name(prog));\n\terr_str[sizeof(err_str) - 1] = 0;\n\tASSERT_OK(err, err_str);\n\n\treturn err;\n}\n\n#define QDISC_CLSACT_CREATE(qdisc_hook, ifindex) ({\t\t\\\n\tif ((err = qdisc_clsact_create(qdisc_hook, ifindex)))\t\\\n\t\tgoto fail;\t\t\t\t\t\\\n})\n\n#define XGRESS_FILTER_ADD(qdisc_hook, xgress, prog, priority) ({\t\t\\\n\tif ((err = xgress_filter_add(qdisc_hook, xgress, prog, priority)))\t\\\n\t\tgoto fail;\t\t\t\t\t\t\t\\\n})\n\nstatic int netns_load_bpf(const struct bpf_program *src_prog,\n\t\t\t  const struct bpf_program *dst_prog,\n\t\t\t  const struct bpf_program *chk_prog,\n\t\t\t  const struct netns_setup_result *setup_result)\n{\n\tLIBBPF_OPTS(bpf_tc_hook, qdisc_veth_src_fwd);\n\tLIBBPF_OPTS(bpf_tc_hook, qdisc_veth_dst_fwd);\n\tint err;\n\n\t \n\tQDISC_CLSACT_CREATE(&qdisc_veth_src_fwd, setup_result->ifindex_veth_src_fwd);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_src_fwd, BPF_TC_INGRESS, src_prog, 0);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_src_fwd, BPF_TC_EGRESS, chk_prog, 0);\n\n\t \n\tQDISC_CLSACT_CREATE(&qdisc_veth_dst_fwd, setup_result->ifindex_veth_dst_fwd);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst_fwd, BPF_TC_INGRESS, dst_prog, 0);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst_fwd, BPF_TC_EGRESS, chk_prog, 0);\n\n\treturn 0;\nfail:\n\treturn -1;\n}\n\nstatic void test_tcp(int family, const char *addr, __u16 port)\n{\n\tint listen_fd = -1, accept_fd = -1, client_fd = -1;\n\tchar buf[] = \"testing testing\";\n\tint n;\n\tstruct nstoken *nstoken;\n\n\tnstoken = open_netns(NS_DST);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns dst\"))\n\t\treturn;\n\n\tlisten_fd = start_server(family, SOCK_STREAM, addr, port, 0);\n\tif (!ASSERT_GE(listen_fd, 0, \"listen\"))\n\t\tgoto done;\n\n\tclose_netns(nstoken);\n\tnstoken = open_netns(NS_SRC);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns src\"))\n\t\tgoto done;\n\n\tclient_fd = connect_to_fd(listen_fd, TIMEOUT_MILLIS);\n\tif (!ASSERT_GE(client_fd, 0, \"connect_to_fd\"))\n\t\tgoto done;\n\n\taccept_fd = accept(listen_fd, NULL, NULL);\n\tif (!ASSERT_GE(accept_fd, 0, \"accept\"))\n\t\tgoto done;\n\n\tif (!ASSERT_OK(settimeo(accept_fd, TIMEOUT_MILLIS), \"settimeo\"))\n\t\tgoto done;\n\n\tn = write(client_fd, buf, sizeof(buf));\n\tif (!ASSERT_EQ(n, sizeof(buf), \"send to server\"))\n\t\tgoto done;\n\n\tn = read(accept_fd, buf, sizeof(buf));\n\tASSERT_EQ(n, sizeof(buf), \"recv from server\");\n\ndone:\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n\tif (listen_fd >= 0)\n\t\tclose(listen_fd);\n\tif (accept_fd >= 0)\n\t\tclose(accept_fd);\n\tif (client_fd >= 0)\n\t\tclose(client_fd);\n}\n\nstatic int test_ping(int family, const char *addr)\n{\n\tSYS(fail, \"ip netns exec \" NS_SRC \" %s \" PING_ARGS \" %s > /dev/null\", ping_command(family), addr);\n\treturn 0;\nfail:\n\treturn -1;\n}\n\nstatic void test_connectivity(void)\n{\n\ttest_tcp(AF_INET, IP4_DST, IP4_PORT);\n\ttest_ping(AF_INET, IP4_DST);\n\ttest_tcp(AF_INET6, IP6_DST, IP6_PORT);\n\ttest_ping(AF_INET6, IP6_DST);\n}\n\nstatic int set_forwarding(bool enable)\n{\n\tint err;\n\n\terr = write_file(\"/proc/sys/net/ipv4/ip_forward\", enable ? \"1\" : \"0\");\n\tif (!ASSERT_OK(err, \"set ipv4.ip_forward=0\"))\n\t\treturn err;\n\n\terr = write_file(\"/proc/sys/net/ipv6/conf/all/forwarding\", enable ? \"1\" : \"0\");\n\tif (!ASSERT_OK(err, \"set ipv6.forwarding=0\"))\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void rcv_tstamp(int fd, const char *expected, size_t s)\n{\n\tstruct __kernel_timespec pkt_ts = {};\n\tchar ctl[CMSG_SPACE(sizeof(pkt_ts))];\n\tstruct timespec now_ts;\n\tstruct msghdr msg = {};\n\t__u64 now_ns, pkt_ns;\n\tstruct cmsghdr *cmsg;\n\tstruct iovec iov;\n\tchar data[32];\n\tint ret;\n\n\tiov.iov_base = data;\n\tiov.iov_len = sizeof(data);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = &ctl;\n\tmsg.msg_controllen = sizeof(ctl);\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (!ASSERT_EQ(ret, s, \"recvmsg\"))\n\t\treturn;\n\tASSERT_STRNEQ(data, expected, s, \"expected rcv data\");\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (cmsg && cmsg->cmsg_level == SOL_SOCKET &&\n\t    cmsg->cmsg_type == SO_TIMESTAMPNS_NEW)\n\t\tmemcpy(&pkt_ts, CMSG_DATA(cmsg), sizeof(pkt_ts));\n\n\tpkt_ns = pkt_ts.tv_sec * NSEC_PER_SEC + pkt_ts.tv_nsec;\n\tASSERT_NEQ(pkt_ns, 0, \"pkt rcv tstamp\");\n\n\tret = clock_gettime(CLOCK_REALTIME, &now_ts);\n\tASSERT_OK(ret, \"clock_gettime\");\n\tnow_ns = now_ts.tv_sec * NSEC_PER_SEC + now_ts.tv_nsec;\n\n\tif (ASSERT_GE(now_ns, pkt_ns, \"check rcv tstamp\"))\n\t\tASSERT_LT(now_ns - pkt_ns, 5 * NSEC_PER_SEC,\n\t\t\t  \"check rcv tstamp\");\n}\n\nstatic void snd_tstamp(int fd, char *b, size_t s)\n{\n\tstruct sock_txtime opt = { .clockid = CLOCK_TAI };\n\tchar ctl[CMSG_SPACE(sizeof(__u64))];\n\tstruct timespec now_ts;\n\tstruct msghdr msg = {};\n\tstruct cmsghdr *cmsg;\n\tstruct iovec iov;\n\t__u64 now_ns;\n\tint ret;\n\n\tret = clock_gettime(CLOCK_TAI, &now_ts);\n\tASSERT_OK(ret, \"clock_get_time(CLOCK_TAI)\");\n\tnow_ns = now_ts.tv_sec * NSEC_PER_SEC + now_ts.tv_nsec;\n\n\tiov.iov_base = b;\n\tiov.iov_len = s;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = &ctl;\n\tmsg.msg_controllen = sizeof(ctl);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_TXTIME;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(now_ns));\n\t*(__u64 *)CMSG_DATA(cmsg) = now_ns;\n\n\tret = setsockopt(fd, SOL_SOCKET, SO_TXTIME, &opt, sizeof(opt));\n\tASSERT_OK(ret, \"setsockopt(SO_TXTIME)\");\n\n\tret = sendmsg(fd, &msg, 0);\n\tASSERT_EQ(ret, s, \"sendmsg\");\n}\n\nstatic void test_inet_dtime(int family, int type, const char *addr, __u16 port)\n{\n\tint opt = 1, accept_fd = -1, client_fd = -1, listen_fd, err;\n\tchar buf[] = \"testing testing\";\n\tstruct nstoken *nstoken;\n\n\tnstoken = open_netns(NS_DST);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns dst\"))\n\t\treturn;\n\tlisten_fd = start_server(family, type, addr, port, 0);\n\tclose_netns(nstoken);\n\n\tif (!ASSERT_GE(listen_fd, 0, \"listen\"))\n\t\treturn;\n\n\t \n\terr = setsockopt(listen_fd, SOL_SOCKET, SO_TIMESTAMPNS_NEW,\n\t\t\t &opt, sizeof(opt));\n\tif (!ASSERT_OK(err, \"setsockopt(SO_TIMESTAMPNS_NEW)\"))\n\t\tgoto done;\n\n\tif (type == SOCK_STREAM) {\n\t\t \n\t\terr = setsockopt(listen_fd, SOL_TCP, TCP_TX_DELAY, &opt,\n\t\t\t\t sizeof(opt));\n\t\tif (!ASSERT_OK(err, \"setsockopt(TCP_TX_DELAY)\"))\n\t\t\tgoto done;\n\t}\n\n\tnstoken = open_netns(NS_SRC);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns src\"))\n\t\tgoto done;\n\tclient_fd = connect_to_fd(listen_fd, TIMEOUT_MILLIS);\n\tclose_netns(nstoken);\n\n\tif (!ASSERT_GE(client_fd, 0, \"connect_to_fd\"))\n\t\tgoto done;\n\n\tif (type == SOCK_STREAM) {\n\t\tint n;\n\n\t\taccept_fd = accept(listen_fd, NULL, NULL);\n\t\tif (!ASSERT_GE(accept_fd, 0, \"accept\"))\n\t\t\tgoto done;\n\n\t\tn = write(client_fd, buf, sizeof(buf));\n\t\tif (!ASSERT_EQ(n, sizeof(buf), \"send to server\"))\n\t\t\tgoto done;\n\t\trcv_tstamp(accept_fd, buf, sizeof(buf));\n\t} else {\n\t\tsnd_tstamp(client_fd, buf, sizeof(buf));\n\t\trcv_tstamp(listen_fd, buf, sizeof(buf));\n\t}\n\ndone:\n\tclose(listen_fd);\n\tif (accept_fd != -1)\n\t\tclose(accept_fd);\n\tif (client_fd != -1)\n\t\tclose(client_fd);\n}\n\nstatic int netns_load_dtime_bpf(struct test_tc_dtime *skel,\n\t\t\t\tconst struct netns_setup_result *setup_result)\n{\n\tLIBBPF_OPTS(bpf_tc_hook, qdisc_veth_src_fwd);\n\tLIBBPF_OPTS(bpf_tc_hook, qdisc_veth_dst_fwd);\n\tLIBBPF_OPTS(bpf_tc_hook, qdisc_veth_src);\n\tLIBBPF_OPTS(bpf_tc_hook, qdisc_veth_dst);\n\tstruct nstoken *nstoken;\n\tint err;\n\n\t \n\tnstoken = open_netns(NS_SRC);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns \" NS_SRC))\n\t\treturn -1;\n\t \n\tQDISC_CLSACT_CREATE(&qdisc_veth_src, setup_result->ifindex_veth_src);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_src, BPF_TC_INGRESS, skel->progs.ingress_host, 0);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_src, BPF_TC_EGRESS, skel->progs.egress_host, 0);\n\tclose_netns(nstoken);\n\n\t \n\tnstoken = open_netns(NS_DST);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns \" NS_DST))\n\t\treturn -1;\n\t \n\tQDISC_CLSACT_CREATE(&qdisc_veth_dst, setup_result->ifindex_veth_dst);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst, BPF_TC_INGRESS, skel->progs.ingress_host, 0);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst, BPF_TC_EGRESS, skel->progs.egress_host, 0);\n\tclose_netns(nstoken);\n\n\t \n\tnstoken = open_netns(NS_FWD);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns \" NS_FWD))\n\t\treturn -1;\n\t \n\tQDISC_CLSACT_CREATE(&qdisc_veth_dst_fwd, setup_result->ifindex_veth_dst_fwd);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst_fwd, BPF_TC_INGRESS,\n\t\t\t  skel->progs.ingress_fwdns_prio100, 100);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst_fwd, BPF_TC_INGRESS,\n\t\t\t  skel->progs.ingress_fwdns_prio101, 101);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst_fwd, BPF_TC_EGRESS,\n\t\t\t  skel->progs.egress_fwdns_prio100, 100);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst_fwd, BPF_TC_EGRESS,\n\t\t\t  skel->progs.egress_fwdns_prio101, 101);\n\n\t \n\tQDISC_CLSACT_CREATE(&qdisc_veth_src_fwd, setup_result->ifindex_veth_src_fwd);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_src_fwd, BPF_TC_INGRESS,\n\t\t\t  skel->progs.ingress_fwdns_prio100, 100);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_src_fwd, BPF_TC_INGRESS,\n\t\t\t  skel->progs.ingress_fwdns_prio101, 101);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_src_fwd, BPF_TC_EGRESS,\n\t\t\t  skel->progs.egress_fwdns_prio100, 100);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_src_fwd, BPF_TC_EGRESS,\n\t\t\t  skel->progs.egress_fwdns_prio101, 101);\n\tclose_netns(nstoken);\n\treturn 0;\n\nfail:\n\tclose_netns(nstoken);\n\treturn err;\n}\n\nenum {\n\tINGRESS_FWDNS_P100,\n\tINGRESS_FWDNS_P101,\n\tEGRESS_FWDNS_P100,\n\tEGRESS_FWDNS_P101,\n\tINGRESS_ENDHOST,\n\tEGRESS_ENDHOST,\n\tSET_DTIME,\n\t__MAX_CNT,\n};\n\nconst char *cnt_names[] = {\n\t\"ingress_fwdns_p100\",\n\t\"ingress_fwdns_p101\",\n\t\"egress_fwdns_p100\",\n\t\"egress_fwdns_p101\",\n\t\"ingress_endhost\",\n\t\"egress_endhost\",\n\t\"set_dtime\",\n};\n\nenum {\n\tTCP_IP6_CLEAR_DTIME,\n\tTCP_IP4,\n\tTCP_IP6,\n\tUDP_IP4,\n\tUDP_IP6,\n\tTCP_IP4_RT_FWD,\n\tTCP_IP6_RT_FWD,\n\tUDP_IP4_RT_FWD,\n\tUDP_IP6_RT_FWD,\n\tUKN_TEST,\n\t__NR_TESTS,\n};\n\nconst char *test_names[] = {\n\t\"tcp ip6 clear dtime\",\n\t\"tcp ip4\",\n\t\"tcp ip6\",\n\t\"udp ip4\",\n\t\"udp ip6\",\n\t\"tcp ip4 rt fwd\",\n\t\"tcp ip6 rt fwd\",\n\t\"udp ip4 rt fwd\",\n\t\"udp ip6 rt fwd\",\n};\n\nstatic const char *dtime_cnt_str(int test, int cnt)\n{\n\tstatic char name[64];\n\n\tsnprintf(name, sizeof(name), \"%s %s\", test_names[test], cnt_names[cnt]);\n\n\treturn name;\n}\n\nstatic const char *dtime_err_str(int test, int cnt)\n{\n\tstatic char name[64];\n\n\tsnprintf(name, sizeof(name), \"%s %s errs\", test_names[test],\n\t\t cnt_names[cnt]);\n\n\treturn name;\n}\n\nstatic void test_tcp_clear_dtime(struct test_tc_dtime *skel)\n{\n\tint i, t = TCP_IP6_CLEAR_DTIME;\n\t__u32 *dtimes = skel->bss->dtimes[t];\n\t__u32 *errs = skel->bss->errs[t];\n\n\tskel->bss->test = t;\n\ttest_inet_dtime(AF_INET6, SOCK_STREAM, IP6_DST, 50000 + t);\n\n\tASSERT_EQ(dtimes[INGRESS_FWDNS_P100], 0,\n\t\t  dtime_cnt_str(t, INGRESS_FWDNS_P100));\n\tASSERT_EQ(dtimes[INGRESS_FWDNS_P101], 0,\n\t\t  dtime_cnt_str(t, INGRESS_FWDNS_P101));\n\tASSERT_GT(dtimes[EGRESS_FWDNS_P100], 0,\n\t\t  dtime_cnt_str(t, EGRESS_FWDNS_P100));\n\tASSERT_EQ(dtimes[EGRESS_FWDNS_P101], 0,\n\t\t  dtime_cnt_str(t, EGRESS_FWDNS_P101));\n\tASSERT_GT(dtimes[EGRESS_ENDHOST], 0,\n\t\t  dtime_cnt_str(t, EGRESS_ENDHOST));\n\tASSERT_GT(dtimes[INGRESS_ENDHOST], 0,\n\t\t  dtime_cnt_str(t, INGRESS_ENDHOST));\n\n\tfor (i = INGRESS_FWDNS_P100; i < __MAX_CNT; i++)\n\t\tASSERT_EQ(errs[i], 0, dtime_err_str(t, i));\n}\n\nstatic void test_tcp_dtime(struct test_tc_dtime *skel, int family, bool bpf_fwd)\n{\n\t__u32 *dtimes, *errs;\n\tconst char *addr;\n\tint i, t;\n\n\tif (family == AF_INET) {\n\t\tt = bpf_fwd ? TCP_IP4 : TCP_IP4_RT_FWD;\n\t\taddr = IP4_DST;\n\t} else {\n\t\tt = bpf_fwd ? TCP_IP6 : TCP_IP6_RT_FWD;\n\t\taddr = IP6_DST;\n\t}\n\n\tdtimes = skel->bss->dtimes[t];\n\terrs = skel->bss->errs[t];\n\n\tskel->bss->test = t;\n\ttest_inet_dtime(family, SOCK_STREAM, addr, 50000 + t);\n\n\t \n\tASSERT_EQ(dtimes[INGRESS_FWDNS_P100], 0,\n\t\t  dtime_cnt_str(t, INGRESS_FWDNS_P100));\n\tfor (i = INGRESS_FWDNS_P101; i < SET_DTIME; i++)\n\t\tASSERT_GT(dtimes[i], 0, dtime_cnt_str(t, i));\n\n\tfor (i = INGRESS_FWDNS_P100; i < __MAX_CNT; i++)\n\t\tASSERT_EQ(errs[i], 0, dtime_err_str(t, i));\n}\n\nstatic void test_udp_dtime(struct test_tc_dtime *skel, int family, bool bpf_fwd)\n{\n\t__u32 *dtimes, *errs;\n\tconst char *addr;\n\tint i, t;\n\n\tif (family == AF_INET) {\n\t\tt = bpf_fwd ? UDP_IP4 : UDP_IP4_RT_FWD;\n\t\taddr = IP4_DST;\n\t} else {\n\t\tt = bpf_fwd ? UDP_IP6 : UDP_IP6_RT_FWD;\n\t\taddr = IP6_DST;\n\t}\n\n\tdtimes = skel->bss->dtimes[t];\n\terrs = skel->bss->errs[t];\n\n\tskel->bss->test = t;\n\ttest_inet_dtime(family, SOCK_DGRAM, addr, 50000 + t);\n\n\tASSERT_EQ(dtimes[INGRESS_FWDNS_P100], 0,\n\t\t  dtime_cnt_str(t, INGRESS_FWDNS_P100));\n\t \n\tASSERT_EQ(dtimes[INGRESS_FWDNS_P101], 0,\n\t\t  dtime_cnt_str(t, INGRESS_FWDNS_P101));\n\tfor (i = EGRESS_FWDNS_P100; i < SET_DTIME; i++)\n\t\tASSERT_GT(dtimes[i], 0, dtime_cnt_str(t, i));\n\n\tfor (i = INGRESS_FWDNS_P100; i < __MAX_CNT; i++)\n\t\tASSERT_EQ(errs[i], 0, dtime_err_str(t, i));\n}\n\nstatic void test_tc_redirect_dtime(struct netns_setup_result *setup_result)\n{\n\tstruct test_tc_dtime *skel;\n\tstruct nstoken *nstoken;\n\tint err;\n\n\tskel = test_tc_dtime__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_tc_dtime__open\"))\n\t\treturn;\n\n\tskel->rodata->IFINDEX_SRC = setup_result->ifindex_veth_src_fwd;\n\tskel->rodata->IFINDEX_DST = setup_result->ifindex_veth_dst_fwd;\n\n\terr = test_tc_dtime__load(skel);\n\tif (!ASSERT_OK(err, \"test_tc_dtime__load\"))\n\t\tgoto done;\n\n\tif (netns_load_dtime_bpf(skel, setup_result))\n\t\tgoto done;\n\n\tnstoken = open_netns(NS_FWD);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns fwd\"))\n\t\tgoto done;\n\terr = set_forwarding(false);\n\tclose_netns(nstoken);\n\tif (!ASSERT_OK(err, \"disable forwarding\"))\n\t\tgoto done;\n\n\ttest_tcp_clear_dtime(skel);\n\n\ttest_tcp_dtime(skel, AF_INET, true);\n\ttest_tcp_dtime(skel, AF_INET6, true);\n\ttest_udp_dtime(skel, AF_INET, true);\n\ttest_udp_dtime(skel, AF_INET6, true);\n\n\t \n\tnstoken = open_netns(NS_FWD);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns fwd\"))\n\t\tgoto done;\n\terr = set_forwarding(true);\n\tclose_netns(nstoken);\n\tif (!ASSERT_OK(err, \"enable forwarding\"))\n\t\tgoto done;\n\n\ttest_tcp_dtime(skel, AF_INET, false);\n\ttest_tcp_dtime(skel, AF_INET6, false);\n\ttest_udp_dtime(skel, AF_INET, false);\n\ttest_udp_dtime(skel, AF_INET6, false);\n\ndone:\n\ttest_tc_dtime__destroy(skel);\n}\n\nstatic void test_tc_redirect_neigh_fib(struct netns_setup_result *setup_result)\n{\n\tstruct nstoken *nstoken = NULL;\n\tstruct test_tc_neigh_fib *skel = NULL;\n\n\tnstoken = open_netns(NS_FWD);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns fwd\"))\n\t\treturn;\n\n\tskel = test_tc_neigh_fib__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_tc_neigh_fib__open\"))\n\t\tgoto done;\n\n\tif (!ASSERT_OK(test_tc_neigh_fib__load(skel), \"test_tc_neigh_fib__load\"))\n\t\tgoto done;\n\n\tif (netns_load_bpf(skel->progs.tc_src, skel->progs.tc_dst,\n\t\t\t   skel->progs.tc_chk, setup_result))\n\t\tgoto done;\n\n\t \n\tif (!ASSERT_OK(set_forwarding(true), \"enable forwarding\"))\n\t\tgoto done;\n\n\ttest_connectivity();\n\ndone:\n\tif (skel)\n\t\ttest_tc_neigh_fib__destroy(skel);\n\tclose_netns(nstoken);\n}\n\nstatic void test_tc_redirect_neigh(struct netns_setup_result *setup_result)\n{\n\tstruct nstoken *nstoken = NULL;\n\tstruct test_tc_neigh *skel = NULL;\n\tint err;\n\n\tnstoken = open_netns(NS_FWD);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns fwd\"))\n\t\treturn;\n\n\tskel = test_tc_neigh__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_tc_neigh__open\"))\n\t\tgoto done;\n\n\tskel->rodata->IFINDEX_SRC = setup_result->ifindex_veth_src_fwd;\n\tskel->rodata->IFINDEX_DST = setup_result->ifindex_veth_dst_fwd;\n\n\terr = test_tc_neigh__load(skel);\n\tif (!ASSERT_OK(err, \"test_tc_neigh__load\"))\n\t\tgoto done;\n\n\tif (netns_load_bpf(skel->progs.tc_src, skel->progs.tc_dst,\n\t\t\t   skel->progs.tc_chk, setup_result))\n\t\tgoto done;\n\n\tif (!ASSERT_OK(set_forwarding(false), \"disable forwarding\"))\n\t\tgoto done;\n\n\ttest_connectivity();\n\ndone:\n\tif (skel)\n\t\ttest_tc_neigh__destroy(skel);\n\tclose_netns(nstoken);\n}\n\nstatic void test_tc_redirect_peer(struct netns_setup_result *setup_result)\n{\n\tstruct nstoken *nstoken;\n\tstruct test_tc_peer *skel;\n\tint err;\n\n\tnstoken = open_netns(NS_FWD);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns fwd\"))\n\t\treturn;\n\n\tskel = test_tc_peer__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_tc_peer__open\"))\n\t\tgoto done;\n\n\tskel->rodata->IFINDEX_SRC = setup_result->ifindex_veth_src_fwd;\n\tskel->rodata->IFINDEX_DST = setup_result->ifindex_veth_dst_fwd;\n\n\terr = test_tc_peer__load(skel);\n\tif (!ASSERT_OK(err, \"test_tc_peer__load\"))\n\t\tgoto done;\n\n\tif (netns_load_bpf(skel->progs.tc_src, skel->progs.tc_dst,\n\t\t\t   skel->progs.tc_chk, setup_result))\n\t\tgoto done;\n\n\tif (!ASSERT_OK(set_forwarding(false), \"disable forwarding\"))\n\t\tgoto done;\n\n\ttest_connectivity();\n\ndone:\n\tif (skel)\n\t\ttest_tc_peer__destroy(skel);\n\tclose_netns(nstoken);\n}\n\nstatic int tun_open(char *name)\n{\n\tstruct ifreq ifr;\n\tint fd, err;\n\n\tfd = open(\"/dev/net/tun\", O_RDWR);\n\tif (!ASSERT_GE(fd, 0, \"open /dev/net/tun\"))\n\t\treturn -1;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\n\tifr.ifr_flags = IFF_TUN | IFF_NO_PI;\n\tif (*name)\n\t\tstrncpy(ifr.ifr_name, name, IFNAMSIZ);\n\n\terr = ioctl(fd, TUNSETIFF, &ifr);\n\tif (!ASSERT_OK(err, \"ioctl TUNSETIFF\"))\n\t\tgoto fail;\n\n\tSYS(fail, \"ip link set dev %s up\", name);\n\n\treturn fd;\nfail:\n\tclose(fd);\n\treturn -1;\n}\n\nenum {\n\tSRC_TO_TARGET = 0,\n\tTARGET_TO_SRC = 1,\n};\n\nstatic int tun_relay_loop(int src_fd, int target_fd)\n{\n\tfd_set rfds, wfds;\n\n\tFD_ZERO(&rfds);\n\tFD_ZERO(&wfds);\n\n\tfor (;;) {\n\t\tchar buf[1500];\n\t\tint direction, nread, nwrite;\n\n\t\tFD_SET(src_fd, &rfds);\n\t\tFD_SET(target_fd, &rfds);\n\n\t\tif (select(1 + MAX(src_fd, target_fd), &rfds, NULL, NULL, NULL) < 0) {\n\t\t\tlog_err(\"select failed\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tdirection = FD_ISSET(src_fd, &rfds) ? SRC_TO_TARGET : TARGET_TO_SRC;\n\n\t\tnread = read(direction == SRC_TO_TARGET ? src_fd : target_fd, buf, sizeof(buf));\n\t\tif (nread < 0) {\n\t\t\tlog_err(\"read failed\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tnwrite = write(direction == SRC_TO_TARGET ? target_fd : src_fd, buf, nread);\n\t\tif (nwrite != nread) {\n\t\t\tlog_err(\"write failed\");\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n\nstatic void test_tc_redirect_peer_l3(struct netns_setup_result *setup_result)\n{\n\tLIBBPF_OPTS(bpf_tc_hook, qdisc_tun_fwd);\n\tLIBBPF_OPTS(bpf_tc_hook, qdisc_veth_dst_fwd);\n\tstruct test_tc_peer *skel = NULL;\n\tstruct nstoken *nstoken = NULL;\n\tint err;\n\tint tunnel_pid = -1;\n\tint src_fd, target_fd = -1;\n\tint ifindex;\n\n\t \n\tnstoken = open_netns(NS_SRC);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns \" NS_SRC))\n\t\treturn;\n\n\tsrc_fd = tun_open(\"tun_src\");\n\tif (!ASSERT_GE(src_fd, 0, \"tun_open tun_src\"))\n\t\tgoto fail;\n\n\tclose_netns(nstoken);\n\n\tnstoken = open_netns(NS_FWD);\n\tif (!ASSERT_OK_PTR(nstoken, \"setns \" NS_FWD))\n\t\tgoto fail;\n\n\ttarget_fd = tun_open(\"tun_fwd\");\n\tif (!ASSERT_GE(target_fd, 0, \"tun_open tun_fwd\"))\n\t\tgoto fail;\n\n\ttunnel_pid = fork();\n\tif (!ASSERT_GE(tunnel_pid, 0, \"fork tun_relay_loop\"))\n\t\tgoto fail;\n\n\tif (tunnel_pid == 0)\n\t\texit(tun_relay_loop(src_fd, target_fd));\n\n\tskel = test_tc_peer__open();\n\tif (!ASSERT_OK_PTR(skel, \"test_tc_peer__open\"))\n\t\tgoto fail;\n\n\tifindex = if_nametoindex(\"tun_fwd\");\n\tif (!ASSERT_GT(ifindex, 0, \"if_indextoname tun_fwd\"))\n\t\tgoto fail;\n\n\tskel->rodata->IFINDEX_SRC = ifindex;\n\tskel->rodata->IFINDEX_DST = setup_result->ifindex_veth_dst_fwd;\n\n\terr = test_tc_peer__load(skel);\n\tif (!ASSERT_OK(err, \"test_tc_peer__load\"))\n\t\tgoto fail;\n\n\t \n\t \n\tQDISC_CLSACT_CREATE(&qdisc_tun_fwd, ifindex);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_tun_fwd, BPF_TC_INGRESS, skel->progs.tc_src_l3, 0);\n\n\t \n\tQDISC_CLSACT_CREATE(&qdisc_veth_dst_fwd, setup_result->ifindex_veth_dst_fwd);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst_fwd, BPF_TC_INGRESS, skel->progs.tc_dst_l3, 0);\n\t \n\tXGRESS_FILTER_ADD(&qdisc_veth_dst_fwd, BPF_TC_EGRESS, skel->progs.tc_chk, 0);\n\n\t \n\tSYS(fail, \"ip -netns \" NS_SRC \" addr add dev tun_src \" IP4_TUN_SRC \"/24\");\n\tSYS(fail, \"ip -netns \" NS_FWD \" addr add dev tun_fwd \" IP4_TUN_FWD \"/24\");\n\n\tSYS(fail, \"ip -netns \" NS_SRC \" addr add dev tun_src \" IP6_TUN_SRC \"/64 nodad\");\n\tSYS(fail, \"ip -netns \" NS_FWD \" addr add dev tun_fwd \" IP6_TUN_FWD \"/64 nodad\");\n\n\tSYS(fail, \"ip -netns \" NS_SRC \" route del \" IP4_DST \"/32 dev veth_src scope global\");\n\tSYS(fail, \"ip -netns \" NS_SRC \" route add \" IP4_DST \"/32 via \" IP4_TUN_FWD\n\t    \" dev tun_src scope global\");\n\tSYS(fail, \"ip -netns \" NS_DST \" route add \" IP4_TUN_SRC \"/32 dev veth_dst scope global\");\n\tSYS(fail, \"ip -netns \" NS_SRC \" route del \" IP6_DST \"/128 dev veth_src scope global\");\n\tSYS(fail, \"ip -netns \" NS_SRC \" route add \" IP6_DST \"/128 via \" IP6_TUN_FWD\n\t    \" dev tun_src scope global\");\n\tSYS(fail, \"ip -netns \" NS_DST \" route add \" IP6_TUN_SRC \"/128 dev veth_dst scope global\");\n\n\tSYS(fail, \"ip -netns \" NS_DST \" neigh add \" IP4_TUN_SRC \" dev veth_dst lladdr \" MAC_DST_FWD);\n\tSYS(fail, \"ip -netns \" NS_DST \" neigh add \" IP6_TUN_SRC \" dev veth_dst lladdr \" MAC_DST_FWD);\n\n\tif (!ASSERT_OK(set_forwarding(false), \"disable forwarding\"))\n\t\tgoto fail;\n\n\ttest_connectivity();\n\nfail:\n\tif (tunnel_pid > 0) {\n\t\tkill(tunnel_pid, SIGTERM);\n\t\twaitpid(tunnel_pid, NULL, 0);\n\t}\n\tif (src_fd >= 0)\n\t\tclose(src_fd);\n\tif (target_fd >= 0)\n\t\tclose(target_fd);\n\tif (skel)\n\t\ttest_tc_peer__destroy(skel);\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n}\n\n#define RUN_TEST(name)                                                                      \\\n\t({                                                                                  \\\n\t\tstruct netns_setup_result setup_result;                                     \\\n\t\tif (test__start_subtest(#name))                                             \\\n\t\t\tif (ASSERT_OK(netns_setup_namespaces(\"add\"), \"setup namespaces\")) { \\\n\t\t\t\tif (ASSERT_OK(netns_setup_links_and_routes(&setup_result),  \\\n\t\t\t\t\t      \"setup links and routes\"))                    \\\n\t\t\t\t\ttest_ ## name(&setup_result);                       \\\n\t\t\t\tnetns_setup_namespaces(\"delete\");                           \\\n\t\t\t}                                                                   \\\n\t})\n\nstatic void *test_tc_redirect_run_tests(void *arg)\n{\n\tnetns_setup_namespaces_nofail(\"delete\");\n\n\tRUN_TEST(tc_redirect_peer);\n\tRUN_TEST(tc_redirect_peer_l3);\n\tRUN_TEST(tc_redirect_neigh);\n\tRUN_TEST(tc_redirect_neigh_fib);\n\tRUN_TEST(tc_redirect_dtime);\n\treturn NULL;\n}\n\nvoid test_tc_redirect(void)\n{\n\tpthread_t test_thread;\n\tint err;\n\n\t \n\terr = pthread_create(&test_thread, NULL, &test_tc_redirect_run_tests, NULL);\n\tif (ASSERT_OK(err, \"pthread_create\"))\n\t\tASSERT_OK(pthread_join(test_thread, NULL), \"pthread_join\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}