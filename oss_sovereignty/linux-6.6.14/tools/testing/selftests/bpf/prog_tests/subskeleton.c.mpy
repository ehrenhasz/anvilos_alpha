{
  "module_name": "subskeleton.c",
  "hash_id": "7c05ee08e33f08d401990096d8effc633791a0cdb13ea75a3e6228e564ff980b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/subskeleton.c",
  "human_readable_source": "\n \n\n#include <test_progs.h>\n#include \"test_subskeleton.skel.h\"\n#include \"test_subskeleton_lib.subskel.h\"\n\nstatic void subskeleton_lib_setup(struct bpf_object *obj)\n{\n\tstruct test_subskeleton_lib *lib = test_subskeleton_lib__open(obj);\n\n\tif (!ASSERT_OK_PTR(lib, \"open subskeleton\"))\n\t\treturn;\n\n\t*lib->rodata.var1 = 1;\n\t*lib->data.var2 = 2;\n\tlib->bss.var3->var3_1 = 3;\n\tlib->bss.var3->var3_2 = 4;\n\n\ttest_subskeleton_lib__destroy(lib);\n}\n\nstatic int subskeleton_lib_subresult(struct bpf_object *obj)\n{\n\tstruct test_subskeleton_lib *lib = test_subskeleton_lib__open(obj);\n\tint result;\n\n\tif (!ASSERT_OK_PTR(lib, \"open subskeleton\"))\n\t\treturn -EINVAL;\n\n\tresult = *lib->bss.libout1;\n\tASSERT_EQ(result, 1 + 2 + 3 + 4 + 5 + 6, \"lib subresult\");\n\n\tASSERT_OK_PTR(lib->progs.lib_perf_handler, \"lib_perf_handler\");\n\tASSERT_STREQ(bpf_program__name(lib->progs.lib_perf_handler),\n\t\t     \"lib_perf_handler\", \"program name\");\n\n\tASSERT_OK_PTR(lib->maps.map1, \"map1\");\n\tASSERT_STREQ(bpf_map__name(lib->maps.map1), \"map1\", \"map name\");\n\n\tASSERT_EQ(*lib->data.var5, 5, \"__weak var5\");\n\tASSERT_EQ(*lib->data.var6, 6, \"extern var6\");\n\tASSERT_TRUE(*lib->kconfig.CONFIG_BPF_SYSCALL, \"CONFIG_BPF_SYSCALL\");\n\n\ttest_subskeleton_lib__destroy(lib);\n\treturn result;\n}\n\nvoid test_subskeleton(void)\n{\n\tint err, result;\n\tstruct test_subskeleton *skel;\n\n\tskel = test_subskeleton__open();\n\tif (!ASSERT_OK_PTR(skel, \"skel_open\"))\n\t\treturn;\n\n\tskel->rodata->rovar1 = 10;\n\tskel->rodata->var1 = 1;\n\tsubskeleton_lib_setup(skel->obj);\n\n\terr = test_subskeleton__load(skel);\n\tif (!ASSERT_OK(err, \"skel_load\"))\n\t\tgoto cleanup;\n\n\terr = test_subskeleton__attach(skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto cleanup;\n\n\t \n\tusleep(1);\n\n\tresult = subskeleton_lib_subresult(skel->obj) * 10;\n\tASSERT_EQ(skel->bss->out1, result, \"unexpected calculation\");\n\ncleanup:\n\ttest_subskeleton__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}