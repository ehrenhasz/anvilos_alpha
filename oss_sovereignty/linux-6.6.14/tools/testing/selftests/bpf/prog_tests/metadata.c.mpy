{
  "module_name": "metadata.c",
  "hash_id": "0cb2a88f7f1e1d9245b643a67a30f50ed53859bcc8762676fb95cb0da77b33ff",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/metadata.c",
  "human_readable_source": "\n\n \n\n#include <test_progs.h>\n#include <cgroup_helpers.h>\n#include <network_helpers.h>\n\n#include \"metadata_unused.skel.h\"\n#include \"metadata_used.skel.h\"\n\nstatic int duration;\n\nstatic int prog_holds_map(int prog_fd, int map_fd)\n{\n\tstruct bpf_prog_info prog_info = {};\n\tstruct bpf_map_info map_info = {};\n\t__u32 prog_info_len;\n\t__u32 map_info_len;\n\t__u32 *map_ids;\n\tint nr_maps;\n\tint ret;\n\tint i;\n\n\tmap_info_len = sizeof(map_info);\n\tret = bpf_map_get_info_by_fd(map_fd, &map_info, &map_info_len);\n\tif (ret)\n\t\treturn -errno;\n\n\tprog_info_len = sizeof(prog_info);\n\tret = bpf_prog_get_info_by_fd(prog_fd, &prog_info, &prog_info_len);\n\tif (ret)\n\t\treturn -errno;\n\n\tmap_ids = calloc(prog_info.nr_map_ids, sizeof(__u32));\n\tif (!map_ids)\n\t\treturn -ENOMEM;\n\n\tnr_maps = prog_info.nr_map_ids;\n\tmemset(&prog_info, 0, sizeof(prog_info));\n\tprog_info.nr_map_ids = nr_maps;\n\tprog_info.map_ids = ptr_to_u64(map_ids);\n\tprog_info_len = sizeof(prog_info);\n\n\tret = bpf_prog_get_info_by_fd(prog_fd, &prog_info, &prog_info_len);\n\tif (ret) {\n\t\tret = -errno;\n\t\tgoto free_map_ids;\n\t}\n\n\tret = -ENOENT;\n\tfor (i = 0; i < prog_info.nr_map_ids; i++) {\n\t\tif (map_ids[i] == map_info.id) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nfree_map_ids:\n\tfree(map_ids);\n\treturn ret;\n}\n\nstatic void test_metadata_unused(void)\n{\n\tstruct metadata_unused *obj;\n\tint err;\n\n\tobj = metadata_unused__open_and_load();\n\tif (CHECK(!obj, \"skel-load\", \"errno %d\", errno))\n\t\treturn;\n\n\terr = prog_holds_map(bpf_program__fd(obj->progs.prog),\n\t\t\t     bpf_map__fd(obj->maps.rodata));\n\tif (CHECK(err, \"prog-holds-rodata\", \"errno: %d\", err))\n\t\treturn;\n\n\t \n\tif (CHECK(strncmp(obj->rodata->bpf_metadata_a, \"foo\",\n\t\t\t  sizeof(obj->rodata->bpf_metadata_a)),\n\t\t  \"bpf_metadata_a\", \"expected \\\"foo\\\", value differ\"))\n\t\tgoto close_bpf_object;\n\tif (CHECK(obj->rodata->bpf_metadata_b != 1, \"bpf_metadata_b\",\n\t\t  \"expected 1, got %d\", obj->rodata->bpf_metadata_b))\n\t\tgoto close_bpf_object;\n\n\t \n\terr = bpf_prog_bind_map(bpf_program__fd(obj->progs.prog),\n\t\t\t\tbpf_map__fd(obj->maps.rodata), NULL);\n\tCHECK(err, \"rebind_map\", \"errno %d, expected 0\", errno);\n\nclose_bpf_object:\n\tmetadata_unused__destroy(obj);\n}\n\nstatic void test_metadata_used(void)\n{\n\tstruct metadata_used *obj;\n\tint err;\n\n\tobj = metadata_used__open_and_load();\n\tif (CHECK(!obj, \"skel-load\", \"errno %d\", errno))\n\t\treturn;\n\n\terr = prog_holds_map(bpf_program__fd(obj->progs.prog),\n\t\t\t     bpf_map__fd(obj->maps.rodata));\n\tif (CHECK(err, \"prog-holds-rodata\", \"errno: %d\", err))\n\t\treturn;\n\n\t \n\tif (CHECK(strncmp(obj->rodata->bpf_metadata_a, \"bar\",\n\t\t\t  sizeof(obj->rodata->bpf_metadata_a)),\n\t\t  \"metadata_a\", \"expected \\\"bar\\\", value differ\"))\n\t\tgoto close_bpf_object;\n\tif (CHECK(obj->rodata->bpf_metadata_b != 2, \"metadata_b\",\n\t\t  \"expected 2, got %d\", obj->rodata->bpf_metadata_b))\n\t\tgoto close_bpf_object;\n\n\t \n\terr = bpf_prog_bind_map(bpf_program__fd(obj->progs.prog),\n\t\t\t\tbpf_map__fd(obj->maps.rodata), NULL);\n\tCHECK(err, \"rebind_map\", \"errno %d, expected 0\", errno);\n\nclose_bpf_object:\n\tmetadata_used__destroy(obj);\n}\n\nvoid test_metadata(void)\n{\n\tif (test__start_subtest(\"unused\"))\n\t\ttest_metadata_unused();\n\n\tif (test__start_subtest(\"used\"))\n\t\ttest_metadata_used();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}