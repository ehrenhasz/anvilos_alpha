{
  "module_name": "sk_lookup.c",
  "hash_id": "c66c76c9e5077e3ac9e572c257e408fd1d7b171b71cc72d6298a3431abb96848",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/sk_lookup.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n#include <arpa/inet.h>\n#include <assert.h>\n#include <errno.h>\n#include <error.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <bpf/libbpf.h>\n#include <bpf/bpf.h>\n\n#include \"test_progs.h\"\n#include \"bpf_util.h\"\n#include \"cgroup_helpers.h\"\n#include \"network_helpers.h\"\n#include \"testing_helpers.h\"\n#include \"test_sk_lookup.skel.h\"\n\n \n#define EXT_IP4\t\t\"127.0.0.1\"\n#define EXT_IP6\t\t\"fd00::1\"\n#define EXT_PORT\t7007\n\n \n#define INT_IP4\t\t\"127.0.0.2\"\n#define INT_IP4_V6\t\"::ffff:127.0.0.2\"\n#define INT_IP6\t\t\"fd00::2\"\n#define INT_PORT\t8008\n\n#define IO_TIMEOUT_SEC\t3\n\nenum server {\n\tSERVER_A = 0,\n\tSERVER_B = 1,\n\tMAX_SERVERS,\n};\n\nenum {\n\tPROG1 = 0,\n\tPROG2,\n};\n\nstruct inet_addr {\n\tconst char *ip;\n\tunsigned short port;\n};\n\nstruct test {\n\tconst char *desc;\n\tstruct bpf_program *lookup_prog;\n\tstruct bpf_program *reuseport_prog;\n\tstruct bpf_map *sock_map;\n\tint sotype;\n\tstruct inet_addr connect_to;\n\tstruct inet_addr listen_at;\n\tenum server accept_on;\n\tbool reuseport_has_conns;  \n};\n\nstatic __u32 duration;\t\t \n\nstatic bool is_ipv6(const char *ip)\n{\n\treturn !!strchr(ip, ':');\n}\n\nstatic int attach_reuseport(int sock_fd, struct bpf_program *reuseport_prog)\n{\n\tint err, prog_fd;\n\n\tprog_fd = bpf_program__fd(reuseport_prog);\n\tif (prog_fd < 0) {\n\t\terrno = -prog_fd;\n\t\treturn -1;\n\t}\n\n\terr = setsockopt(sock_fd, SOL_SOCKET, SO_ATTACH_REUSEPORT_EBPF,\n\t\t\t &prog_fd, sizeof(prog_fd));\n\tif (err)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic socklen_t inetaddr_len(const struct sockaddr_storage *addr)\n{\n\treturn (addr->ss_family == AF_INET ? sizeof(struct sockaddr_in) :\n\t\taddr->ss_family == AF_INET6 ? sizeof(struct sockaddr_in6) : 0);\n}\n\nstatic int make_socket(int sotype, const char *ip, int port,\n\t\t       struct sockaddr_storage *addr)\n{\n\tstruct timeval timeo = { .tv_sec = IO_TIMEOUT_SEC };\n\tint err, family, fd;\n\n\tfamily = is_ipv6(ip) ? AF_INET6 : AF_INET;\n\terr = make_sockaddr(family, ip, port, addr, NULL);\n\tif (CHECK(err, \"make_address\", \"failed\\n\"))\n\t\treturn -1;\n\n\tfd = socket(addr->ss_family, sotype, 0);\n\tif (CHECK(fd < 0, \"socket\", \"failed\\n\")) {\n\t\tlog_err(\"failed to make socket\");\n\t\treturn -1;\n\t}\n\n\terr = setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &timeo, sizeof(timeo));\n\tif (CHECK(err, \"setsockopt(SO_SNDTIMEO)\", \"failed\\n\")) {\n\t\tlog_err(\"failed to set SNDTIMEO\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\terr = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeo, sizeof(timeo));\n\tif (CHECK(err, \"setsockopt(SO_RCVTIMEO)\", \"failed\\n\")) {\n\t\tlog_err(\"failed to set RCVTIMEO\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic int make_server(int sotype, const char *ip, int port,\n\t\t       struct bpf_program *reuseport_prog)\n{\n\tstruct sockaddr_storage addr = {0};\n\tconst int one = 1;\n\tint err, fd = -1;\n\n\tfd = make_socket(sotype, ip, port, &addr);\n\tif (fd < 0)\n\t\treturn -1;\n\n\t \n\tif (sotype == SOCK_DGRAM) {\n\t\terr = setsockopt(fd, SOL_IP, IP_RECVORIGDSTADDR, &one,\n\t\t\t\t sizeof(one));\n\t\tif (CHECK(err, \"setsockopt(IP_RECVORIGDSTADDR)\", \"failed\\n\")) {\n\t\t\tlog_err(\"failed to enable IP_RECVORIGDSTADDR\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (sotype == SOCK_DGRAM && addr.ss_family == AF_INET6) {\n\t\terr = setsockopt(fd, SOL_IPV6, IPV6_RECVORIGDSTADDR, &one,\n\t\t\t\t sizeof(one));\n\t\tif (CHECK(err, \"setsockopt(IPV6_RECVORIGDSTADDR)\", \"failed\\n\")) {\n\t\t\tlog_err(\"failed to enable IPV6_RECVORIGDSTADDR\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (sotype == SOCK_STREAM) {\n\t\terr = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &one,\n\t\t\t\t sizeof(one));\n\t\tif (CHECK(err, \"setsockopt(SO_REUSEADDR)\", \"failed\\n\")) {\n\t\t\tlog_err(\"failed to enable SO_REUSEADDR\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (reuseport_prog) {\n\t\terr = setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &one,\n\t\t\t\t sizeof(one));\n\t\tif (CHECK(err, \"setsockopt(SO_REUSEPORT)\", \"failed\\n\")) {\n\t\t\tlog_err(\"failed to enable SO_REUSEPORT\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\terr = bind(fd, (void *)&addr, inetaddr_len(&addr));\n\tif (CHECK(err, \"bind\", \"failed\\n\")) {\n\t\tlog_err(\"failed to bind listen socket\");\n\t\tgoto fail;\n\t}\n\n\tif (sotype == SOCK_STREAM) {\n\t\terr = listen(fd, SOMAXCONN);\n\t\tif (CHECK(err, \"make_server\", \"listen\")) {\n\t\t\tlog_err(\"failed to listen on port %d\", port);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (reuseport_prog) {\n\t\terr = attach_reuseport(fd, reuseport_prog);\n\t\tif (CHECK(err, \"attach_reuseport\", \"failed\\n\")) {\n\t\t\tlog_err(\"failed to attach reuseport prog\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn fd;\nfail:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic int make_client(int sotype, const char *ip, int port)\n{\n\tstruct sockaddr_storage addr = {0};\n\tint err, fd;\n\n\tfd = make_socket(sotype, ip, port, &addr);\n\tif (fd < 0)\n\t\treturn -1;\n\n\terr = connect(fd, (void *)&addr, inetaddr_len(&addr));\n\tif (CHECK(err, \"make_client\", \"connect\")) {\n\t\tlog_err(\"failed to connect client socket\");\n\t\tgoto fail;\n\t}\n\n\treturn fd;\nfail:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic __u64 socket_cookie(int fd)\n{\n\t__u64 cookie;\n\tsocklen_t cookie_len = sizeof(cookie);\n\n\tif (CHECK(getsockopt(fd, SOL_SOCKET, SO_COOKIE, &cookie, &cookie_len) < 0,\n\t\t  \"getsockopt(SO_COOKIE)\", \"%s\\n\", strerror(errno)))\n\t\treturn 0;\n\treturn cookie;\n}\n\nstatic int fill_sk_lookup_ctx(struct bpf_sk_lookup *ctx, const char *local_ip, __u16 local_port,\n\t\t\t      const char *remote_ip, __u16 remote_port)\n{\n\tvoid *local, *remote;\n\tint err;\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->local_port = local_port;\n\tctx->remote_port = htons(remote_port);\n\n\tif (is_ipv6(local_ip)) {\n\t\tctx->family = AF_INET6;\n\t\tlocal = &ctx->local_ip6[0];\n\t\tremote = &ctx->remote_ip6[0];\n\t} else {\n\t\tctx->family = AF_INET;\n\t\tlocal = &ctx->local_ip4;\n\t\tremote = &ctx->remote_ip4;\n\t}\n\n\terr = inet_pton(ctx->family, local_ip, local);\n\tif (CHECK(err != 1, \"inet_pton\", \"local_ip failed\\n\"))\n\t\treturn 1;\n\n\terr = inet_pton(ctx->family, remote_ip, remote);\n\tif (CHECK(err != 1, \"inet_pton\", \"remote_ip failed\\n\"))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int send_byte(int fd)\n{\n\tssize_t n;\n\n\terrno = 0;\n\tn = send(fd, \"a\", 1, 0);\n\tif (CHECK(n <= 0, \"send_byte\", \"send\")) {\n\t\tlog_err(\"failed/partial send\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int recv_byte(int fd)\n{\n\tchar buf[1];\n\tssize_t n;\n\n\tn = recv(fd, buf, sizeof(buf), 0);\n\tif (CHECK(n <= 0, \"recv_byte\", \"recv\")) {\n\t\tlog_err(\"failed/partial recv\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int tcp_recv_send(int server_fd)\n{\n\tchar buf[1];\n\tint ret, fd;\n\tssize_t n;\n\n\tfd = accept(server_fd, NULL, NULL);\n\tif (CHECK(fd < 0, \"accept\", \"failed\\n\")) {\n\t\tlog_err(\"failed to accept\");\n\t\treturn -1;\n\t}\n\n\tn = recv(fd, buf, sizeof(buf), 0);\n\tif (CHECK(n <= 0, \"recv\", \"failed\\n\")) {\n\t\tlog_err(\"failed/partial recv\");\n\t\tret = -1;\n\t\tgoto close;\n\t}\n\n\tn = send(fd, buf, n, 0);\n\tif (CHECK(n <= 0, \"send\", \"failed\\n\")) {\n\t\tlog_err(\"failed/partial send\");\n\t\tret = -1;\n\t\tgoto close;\n\t}\n\n\tret = 0;\nclose:\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void v4_to_v6(struct sockaddr_storage *ss)\n{\n\tstruct sockaddr_in6 *v6 = (struct sockaddr_in6 *)ss;\n\tstruct sockaddr_in v4 = *(struct sockaddr_in *)ss;\n\n\tv6->sin6_family = AF_INET6;\n\tv6->sin6_port = v4.sin_port;\n\tv6->sin6_addr.s6_addr[10] = 0xff;\n\tv6->sin6_addr.s6_addr[11] = 0xff;\n\tmemcpy(&v6->sin6_addr.s6_addr[12], &v4.sin_addr.s_addr, 4);\n\tmemset(&v6->sin6_addr.s6_addr[0], 0, 10);\n}\n\nstatic int udp_recv_send(int server_fd)\n{\n\tchar cmsg_buf[CMSG_SPACE(sizeof(struct sockaddr_storage))];\n\tstruct sockaddr_storage _src_addr = { 0 };\n\tstruct sockaddr_storage *src_addr = &_src_addr;\n\tstruct sockaddr_storage *dst_addr = NULL;\n\tstruct msghdr msg = { 0 };\n\tstruct iovec iov = { 0 };\n\tstruct cmsghdr *cm;\n\tchar buf[1];\n\tint ret, fd;\n\tssize_t n;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = sizeof(buf);\n\n\tmsg.msg_name = src_addr;\n\tmsg.msg_namelen = sizeof(*src_addr);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = cmsg_buf;\n\tmsg.msg_controllen = sizeof(cmsg_buf);\n\n\terrno = 0;\n\tn = recvmsg(server_fd, &msg, 0);\n\tif (CHECK(n <= 0, \"recvmsg\", \"failed\\n\")) {\n\t\tlog_err(\"failed to receive\");\n\t\treturn -1;\n\t}\n\tif (CHECK(msg.msg_flags & MSG_CTRUNC, \"recvmsg\", \"truncated cmsg\\n\"))\n\t\treturn -1;\n\n\tfor (cm = CMSG_FIRSTHDR(&msg); cm; cm = CMSG_NXTHDR(&msg, cm)) {\n\t\tif ((cm->cmsg_level == SOL_IP &&\n\t\t     cm->cmsg_type == IP_ORIGDSTADDR) ||\n\t\t    (cm->cmsg_level == SOL_IPV6 &&\n\t\t     cm->cmsg_type == IPV6_ORIGDSTADDR)) {\n\t\t\tdst_addr = (struct sockaddr_storage *)CMSG_DATA(cm);\n\t\t\tbreak;\n\t\t}\n\t\tlog_err(\"warning: ignored cmsg at level %d type %d\",\n\t\t\tcm->cmsg_level, cm->cmsg_type);\n\t}\n\tif (CHECK(!dst_addr, \"recvmsg\", \"missing ORIGDSTADDR\\n\"))\n\t\treturn -1;\n\n\t \n\tif (src_addr->ss_family == AF_INET6 &&\n\t    dst_addr->ss_family == AF_INET) {\n\t\tv4_to_v6(dst_addr);\n\t}\n\n\t \n\tfd = socket(dst_addr->ss_family, SOCK_DGRAM, 0);\n\tif (CHECK(fd < 0, \"socket\", \"failed\\n\")) {\n\t\tlog_err(\"failed to create tx socket\");\n\t\treturn -1;\n\t}\n\n\tret = bind(fd, (struct sockaddr *)dst_addr, sizeof(*dst_addr));\n\tif (CHECK(ret, \"bind\", \"failed\\n\")) {\n\t\tlog_err(\"failed to bind tx socket\");\n\t\tgoto out;\n\t}\n\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tn = sendmsg(fd, &msg, 0);\n\tif (CHECK(n <= 0, \"sendmsg\", \"failed\\n\")) {\n\t\tlog_err(\"failed to send echo reply\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tclose(fd);\n\treturn ret;\n}\n\nstatic int tcp_echo_test(int client_fd, int server_fd)\n{\n\tint err;\n\n\terr = send_byte(client_fd);\n\tif (err)\n\t\treturn -1;\n\terr = tcp_recv_send(server_fd);\n\tif (err)\n\t\treturn -1;\n\terr = recv_byte(client_fd);\n\tif (err)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int udp_echo_test(int client_fd, int server_fd)\n{\n\tint err;\n\n\terr = send_byte(client_fd);\n\tif (err)\n\t\treturn -1;\n\terr = udp_recv_send(server_fd);\n\tif (err)\n\t\treturn -1;\n\terr = recv_byte(client_fd);\n\tif (err)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic struct bpf_link *attach_lookup_prog(struct bpf_program *prog)\n{\n\tstruct bpf_link *link;\n\tint net_fd;\n\n\tnet_fd = open(\"/proc/self/ns/net\", O_RDONLY);\n\tif (CHECK(net_fd < 0, \"open\", \"failed\\n\")) {\n\t\tlog_err(\"failed to open /proc/self/ns/net\");\n\t\treturn NULL;\n\t}\n\n\tlink = bpf_program__attach_netns(prog, net_fd);\n\tif (!ASSERT_OK_PTR(link, \"bpf_program__attach_netns\")) {\n\t\terrno = -PTR_ERR(link);\n\t\tlog_err(\"failed to attach program '%s' to netns\",\n\t\t\tbpf_program__name(prog));\n\t\tlink = NULL;\n\t}\n\n\tclose(net_fd);\n\treturn link;\n}\n\nstatic int update_lookup_map(struct bpf_map *map, int index, int sock_fd)\n{\n\tint err, map_fd;\n\tuint64_t value;\n\n\tmap_fd = bpf_map__fd(map);\n\tif (CHECK(map_fd < 0, \"bpf_map__fd\", \"failed\\n\")) {\n\t\terrno = -map_fd;\n\t\tlog_err(\"failed to get map FD\");\n\t\treturn -1;\n\t}\n\n\tvalue = (uint64_t)sock_fd;\n\terr = bpf_map_update_elem(map_fd, &index, &value, BPF_NOEXIST);\n\tif (CHECK(err, \"bpf_map_update_elem\", \"failed\\n\")) {\n\t\tlog_err(\"failed to update redir_map @ %d\", index);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void query_lookup_prog(struct test_sk_lookup *skel)\n{\n\tstruct bpf_link *link[3] = {};\n\tstruct bpf_link_info info;\n\t__u32 attach_flags = 0;\n\t__u32 prog_ids[3] = {};\n\t__u32 prog_cnt = 3;\n\t__u32 prog_id;\n\tint net_fd;\n\tint err;\n\n\tnet_fd = open(\"/proc/self/ns/net\", O_RDONLY);\n\tif (CHECK(net_fd < 0, \"open\", \"failed\\n\")) {\n\t\tlog_err(\"failed to open /proc/self/ns/net\");\n\t\treturn;\n\t}\n\n\tlink[0] = attach_lookup_prog(skel->progs.lookup_pass);\n\tif (!link[0])\n\t\tgoto close;\n\tlink[1] = attach_lookup_prog(skel->progs.lookup_pass);\n\tif (!link[1])\n\t\tgoto detach;\n\tlink[2] = attach_lookup_prog(skel->progs.lookup_drop);\n\tif (!link[2])\n\t\tgoto detach;\n\n\terr = bpf_prog_query(net_fd, BPF_SK_LOOKUP, 0  ,\n\t\t\t     &attach_flags, prog_ids, &prog_cnt);\n\tif (CHECK(err, \"bpf_prog_query\", \"failed\\n\")) {\n\t\tlog_err(\"failed to query lookup prog\");\n\t\tgoto detach;\n\t}\n\n\terrno = 0;\n\tif (CHECK(attach_flags != 0, \"bpf_prog_query\",\n\t\t  \"wrong attach_flags on query: %u\", attach_flags))\n\t\tgoto detach;\n\tif (CHECK(prog_cnt != 3, \"bpf_prog_query\",\n\t\t  \"wrong program count on query: %u\", prog_cnt))\n\t\tgoto detach;\n\tprog_id = link_info_prog_id(link[0], &info);\n\tCHECK(prog_ids[0] != prog_id, \"bpf_prog_query\",\n\t      \"invalid program #0 id on query: %u != %u\\n\",\n\t      prog_ids[0], prog_id);\n\tCHECK(info.netns.netns_ino == 0, \"netns_ino\",\n\t      \"unexpected netns_ino: %u\\n\", info.netns.netns_ino);\n\tprog_id = link_info_prog_id(link[1], &info);\n\tCHECK(prog_ids[1] != prog_id, \"bpf_prog_query\",\n\t      \"invalid program #1 id on query: %u != %u\\n\",\n\t      prog_ids[1], prog_id);\n\tCHECK(info.netns.netns_ino == 0, \"netns_ino\",\n\t      \"unexpected netns_ino: %u\\n\", info.netns.netns_ino);\n\tprog_id = link_info_prog_id(link[2], &info);\n\tCHECK(prog_ids[2] != prog_id, \"bpf_prog_query\",\n\t      \"invalid program #2 id on query: %u != %u\\n\",\n\t      prog_ids[2], prog_id);\n\tCHECK(info.netns.netns_ino == 0, \"netns_ino\",\n\t      \"unexpected netns_ino: %u\\n\", info.netns.netns_ino);\n\n\terr = bpf_link__detach(link[0]);\n\tif (CHECK(err, \"link_detach\", \"failed %d\\n\", err))\n\t\tgoto detach;\n\n\t \n\tprog_id = link_info_prog_id(link[0], &info);\n\tCHECK(prog_ids[0] != prog_id, \"bpf_prog_query\",\n\t      \"invalid program #0 id on query: %u != %u\\n\",\n\t      prog_ids[0], prog_id);\n\tCHECK(info.netns.netns_ino != 0, \"netns_ino\",\n\t      \"unexpected netns_ino: %u\\n\", info.netns.netns_ino);\n\ndetach:\n\tif (link[2])\n\t\tbpf_link__destroy(link[2]);\n\tif (link[1])\n\t\tbpf_link__destroy(link[1]);\n\tif (link[0])\n\t\tbpf_link__destroy(link[0]);\nclose:\n\tclose(net_fd);\n}\n\nstatic void run_lookup_prog(const struct test *t)\n{\n\tint server_fds[] = { [0 ... MAX_SERVERS - 1] = -1 };\n\tint client_fd, reuse_conn_fd = -1;\n\tstruct bpf_link *lookup_link;\n\tint i, err;\n\n\tlookup_link = attach_lookup_prog(t->lookup_prog);\n\tif (!lookup_link)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(server_fds); i++) {\n\t\tserver_fds[i] = make_server(t->sotype, t->listen_at.ip,\n\t\t\t\t\t    t->listen_at.port,\n\t\t\t\t\t    t->reuseport_prog);\n\t\tif (server_fds[i] < 0)\n\t\t\tgoto close;\n\n\t\terr = update_lookup_map(t->sock_map, i, server_fds[i]);\n\t\tif (err)\n\t\t\tgoto close;\n\n\t\t \n\t\tif (!t->reuseport_prog)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (t->reuseport_has_conns) {\n\t\tstruct sockaddr_storage addr = {};\n\t\tsocklen_t len = sizeof(addr);\n\n\t\t \n\t\treuse_conn_fd = make_server(t->sotype, t->listen_at.ip,\n\t\t\t\t\t    t->listen_at.port,\n\t\t\t\t\t    t->reuseport_prog);\n\t\tif (reuse_conn_fd < 0)\n\t\t\tgoto close;\n\n\t\t \n\t\terr = getsockname(reuse_conn_fd, (void *)&addr, &len);\n\t\tif (CHECK(err, \"getsockname\", \"errno %d\\n\", errno))\n\t\t\tgoto close;\n\t\terr = connect(reuse_conn_fd, (void *)&addr, len);\n\t\tif (CHECK(err, \"connect\", \"errno %d\\n\", errno))\n\t\t\tgoto close;\n\t}\n\n\tclient_fd = make_client(t->sotype, t->connect_to.ip, t->connect_to.port);\n\tif (client_fd < 0)\n\t\tgoto close;\n\n\tif (t->sotype == SOCK_STREAM)\n\t\ttcp_echo_test(client_fd, server_fds[t->accept_on]);\n\telse\n\t\tudp_echo_test(client_fd, server_fds[t->accept_on]);\n\n\tclose(client_fd);\nclose:\n\tif (reuse_conn_fd != -1)\n\t\tclose(reuse_conn_fd);\n\tfor (i = 0; i < ARRAY_SIZE(server_fds); i++) {\n\t\tif (server_fds[i] != -1)\n\t\t\tclose(server_fds[i]);\n\t}\n\tbpf_link__destroy(lookup_link);\n}\n\nstatic void test_redirect_lookup(struct test_sk_lookup *skel)\n{\n\tconst struct test tests[] = {\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv4 redir port\",\n\t\t\t.lookup_prog\t= skel->progs.redir_port,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP4, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv4 redir addr\",\n\t\t\t.lookup_prog\t= skel->progs.redir_ip4,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv4 redir with reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t\t.accept_on\t= SERVER_B,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv4 redir skip reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a_no_reuseport,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t\t.accept_on\t= SERVER_A,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv6 redir port\",\n\t\t\t.lookup_prog\t= skel->progs.redir_port,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP6, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv6 redir addr\",\n\t\t\t.lookup_prog\t= skel->progs.redir_ip6,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP6, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv4->IPv6 redir port\",\n\t\t\t.lookup_prog\t= skel->progs.redir_port,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4_V6, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv6 redir with reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP6, INT_PORT },\n\t\t\t.accept_on\t= SERVER_B,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv6 redir skip reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a_no_reuseport,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP6, INT_PORT },\n\t\t\t.accept_on\t= SERVER_A,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv4 redir port\",\n\t\t\t.lookup_prog\t= skel->progs.redir_port,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP4, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv4 redir addr\",\n\t\t\t.lookup_prog\t= skel->progs.redir_ip4,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv4 redir with reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t\t.accept_on\t= SERVER_B,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv4 redir and reuseport with conns\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t\t.accept_on\t= SERVER_B,\n\t\t\t.reuseport_has_conns = true,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv4 redir skip reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a_no_reuseport,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t\t.accept_on\t= SERVER_A,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv6 redir port\",\n\t\t\t.lookup_prog\t= skel->progs.redir_port,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP6, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv6 redir addr\",\n\t\t\t.lookup_prog\t= skel->progs.redir_ip6,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP6, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv4->IPv6 redir port\",\n\t\t\t.lookup_prog\t= skel->progs.redir_port,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.listen_at\t= { INT_IP4_V6, INT_PORT },\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv6 redir and reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP6, INT_PORT },\n\t\t\t.accept_on\t= SERVER_B,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv6 redir and reuseport with conns\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP6, INT_PORT },\n\t\t\t.accept_on\t= SERVER_B,\n\t\t\t.reuseport_has_conns = true,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv6 redir skip reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a_no_reuseport,\n\t\t\t.reuseport_prog\t= skel->progs.select_sock_b,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP6, INT_PORT },\n\t\t\t.accept_on\t= SERVER_A,\n\t\t},\n\t};\n\tconst struct test *t;\n\n\tfor (t = tests; t < tests + ARRAY_SIZE(tests); t++) {\n\t\tif (test__start_subtest(t->desc))\n\t\t\trun_lookup_prog(t);\n\t}\n}\n\nstatic void drop_on_lookup(const struct test *t)\n{\n\tstruct sockaddr_storage dst = {};\n\tint client_fd, server_fd, err;\n\tstruct bpf_link *lookup_link;\n\tssize_t n;\n\n\tlookup_link = attach_lookup_prog(t->lookup_prog);\n\tif (!lookup_link)\n\t\treturn;\n\n\tserver_fd = make_server(t->sotype, t->listen_at.ip, t->listen_at.port,\n\t\t\t\tt->reuseport_prog);\n\tif (server_fd < 0)\n\t\tgoto detach;\n\n\tclient_fd = make_socket(t->sotype, t->connect_to.ip,\n\t\t\t\tt->connect_to.port, &dst);\n\tif (client_fd < 0)\n\t\tgoto close_srv;\n\n\terr = connect(client_fd, (void *)&dst, inetaddr_len(&dst));\n\tif (t->sotype == SOCK_DGRAM) {\n\t\terr = send_byte(client_fd);\n\t\tif (err)\n\t\t\tgoto close_all;\n\n\t\t \n\t\tn = recv(client_fd, NULL, 0, 0);\n\t\terr = n == -1;\n\t}\n\tif (CHECK(!err || errno != ECONNREFUSED, \"connect\",\n\t\t  \"unexpected success or error\\n\"))\n\t\tlog_err(\"expected ECONNREFUSED on connect\");\n\nclose_all:\n\tclose(client_fd);\nclose_srv:\n\tclose(server_fd);\ndetach:\n\tbpf_link__destroy(lookup_link);\n}\n\nstatic void test_drop_on_lookup(struct test_sk_lookup *skel)\n{\n\tconst struct test tests[] = {\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv4 drop on lookup\",\n\t\t\t.lookup_prog\t= skel->progs.lookup_drop,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP4, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv6 drop on lookup\",\n\t\t\t.lookup_prog\t= skel->progs.lookup_drop,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP6, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv4 drop on lookup\",\n\t\t\t.lookup_prog\t= skel->progs.lookup_drop,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP4, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv6 drop on lookup\",\n\t\t\t.lookup_prog\t= skel->progs.lookup_drop,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP6, INT_PORT },\n\t\t},\n\t\t \n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv4 drop on valid ifindex\",\n\t\t\t.lookup_prog\t= skel->progs.check_ifindex,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP4, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv6 drop on valid ifindex\",\n\t\t\t.lookup_prog\t= skel->progs.check_ifindex,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP6, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv4 drop on valid ifindex\",\n\t\t\t.lookup_prog\t= skel->progs.check_ifindex,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP4, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv6 drop on valid ifindex\",\n\t\t\t.lookup_prog\t= skel->progs.check_ifindex,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { EXT_IP6, EXT_PORT },\n\t\t},\n\t};\n\tconst struct test *t;\n\n\tfor (t = tests; t < tests + ARRAY_SIZE(tests); t++) {\n\t\tif (test__start_subtest(t->desc))\n\t\t\tdrop_on_lookup(t);\n\t}\n}\n\nstatic void drop_on_reuseport(const struct test *t)\n{\n\tstruct sockaddr_storage dst = { 0 };\n\tint client, server1, server2, err;\n\tstruct bpf_link *lookup_link;\n\tssize_t n;\n\n\tlookup_link = attach_lookup_prog(t->lookup_prog);\n\tif (!lookup_link)\n\t\treturn;\n\n\tserver1 = make_server(t->sotype, t->listen_at.ip, t->listen_at.port,\n\t\t\t      t->reuseport_prog);\n\tif (server1 < 0)\n\t\tgoto detach;\n\n\terr = update_lookup_map(t->sock_map, SERVER_A, server1);\n\tif (err)\n\t\tgoto detach;\n\n\t \n\tserver2 = make_server(t->sotype, t->connect_to.ip, t->connect_to.port,\n\t\t\t      NULL  );\n\tif (server2 < 0)\n\t\tgoto close_srv1;\n\n\tclient = make_socket(t->sotype, t->connect_to.ip,\n\t\t\t     t->connect_to.port, &dst);\n\tif (client < 0)\n\t\tgoto close_srv2;\n\n\terr = connect(client, (void *)&dst, inetaddr_len(&dst));\n\tif (t->sotype == SOCK_DGRAM) {\n\t\terr = send_byte(client);\n\t\tif (err)\n\t\t\tgoto close_all;\n\n\t\t \n\t\tn = recv(client, NULL, 0, 0);\n\t\terr = n == -1;\n\t}\n\tif (CHECK(!err || errno != ECONNREFUSED, \"connect\",\n\t\t  \"unexpected success or error\\n\"))\n\t\tlog_err(\"expected ECONNREFUSED on connect\");\n\nclose_all:\n\tclose(client);\nclose_srv2:\n\tclose(server2);\nclose_srv1:\n\tclose(server1);\ndetach:\n\tbpf_link__destroy(lookup_link);\n}\n\nstatic void test_drop_on_reuseport(struct test_sk_lookup *skel)\n{\n\tconst struct test tests[] = {\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv4 drop on reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.reuseport_drop,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv6 drop on reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.reuseport_drop,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP6, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"UDP IPv4 drop on reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.reuseport_drop,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_DGRAM,\n\t\t\t.connect_to\t= { EXT_IP4, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"TCP IPv6 drop on reuseport\",\n\t\t\t.lookup_prog\t= skel->progs.select_sock_a,\n\t\t\t.reuseport_prog\t= skel->progs.reuseport_drop,\n\t\t\t.sock_map\t= skel->maps.redir_map,\n\t\t\t.sotype\t\t= SOCK_STREAM,\n\t\t\t.connect_to\t= { EXT_IP6, EXT_PORT },\n\t\t\t.listen_at\t= { INT_IP6, INT_PORT },\n\t\t},\n\t};\n\tconst struct test *t;\n\n\tfor (t = tests; t < tests + ARRAY_SIZE(tests); t++) {\n\t\tif (test__start_subtest(t->desc))\n\t\t\tdrop_on_reuseport(t);\n\t}\n}\n\nstatic void run_sk_assign(struct test_sk_lookup *skel,\n\t\t\t  struct bpf_program *lookup_prog,\n\t\t\t  const char *remote_ip, const char *local_ip)\n{\n\tint server_fds[] = { [0 ... MAX_SERVERS - 1] = -1 };\n\tstruct bpf_sk_lookup ctx;\n\t__u64 server_cookie;\n\tint i, err;\n\n\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, opts,\n\t\t.ctx_in = &ctx,\n\t\t.ctx_size_in = sizeof(ctx),\n\t\t.ctx_out = &ctx,\n\t\t.ctx_size_out = sizeof(ctx),\n\t);\n\n\tif (fill_sk_lookup_ctx(&ctx, local_ip, EXT_PORT, remote_ip, INT_PORT))\n\t\treturn;\n\n\tctx.protocol = IPPROTO_TCP;\n\n\tfor (i = 0; i < ARRAY_SIZE(server_fds); i++) {\n\t\tserver_fds[i] = make_server(SOCK_STREAM, local_ip, 0, NULL);\n\t\tif (server_fds[i] < 0)\n\t\t\tgoto close_servers;\n\n\t\terr = update_lookup_map(skel->maps.redir_map, i,\n\t\t\t\t\tserver_fds[i]);\n\t\tif (err)\n\t\t\tgoto close_servers;\n\t}\n\n\tserver_cookie = socket_cookie(server_fds[SERVER_B]);\n\tif (!server_cookie)\n\t\treturn;\n\n\terr = bpf_prog_test_run_opts(bpf_program__fd(lookup_prog), &opts);\n\tif (CHECK(err, \"test_run\", \"failed with error %d\\n\", errno))\n\t\tgoto close_servers;\n\n\tif (CHECK(ctx.cookie == 0, \"ctx.cookie\", \"no socket selected\\n\"))\n\t\tgoto close_servers;\n\n\tCHECK(ctx.cookie != server_cookie, \"ctx.cookie\",\n\t      \"selected sk %llu instead of %llu\\n\", ctx.cookie, server_cookie);\n\nclose_servers:\n\tfor (i = 0; i < ARRAY_SIZE(server_fds); i++) {\n\t\tif (server_fds[i] != -1)\n\t\t\tclose(server_fds[i]);\n\t}\n}\n\nstatic void run_sk_assign_v4(struct test_sk_lookup *skel,\n\t\t\t     struct bpf_program *lookup_prog)\n{\n\trun_sk_assign(skel, lookup_prog, INT_IP4, EXT_IP4);\n}\n\nstatic void run_sk_assign_v6(struct test_sk_lookup *skel,\n\t\t\t     struct bpf_program *lookup_prog)\n{\n\trun_sk_assign(skel, lookup_prog, INT_IP6, EXT_IP6);\n}\n\nstatic void run_sk_assign_connected(struct test_sk_lookup *skel,\n\t\t\t\t    int sotype)\n{\n\tint err, client_fd, connected_fd, server_fd;\n\tstruct bpf_link *lookup_link;\n\n\tserver_fd = make_server(sotype, EXT_IP4, EXT_PORT, NULL);\n\tif (server_fd < 0)\n\t\treturn;\n\n\tconnected_fd = make_client(sotype, EXT_IP4, EXT_PORT);\n\tif (connected_fd < 0)\n\t\tgoto out_close_server;\n\n\t \n\terr = update_lookup_map(skel->maps.redir_map, SERVER_A, connected_fd);\n\tif (err)\n\t\tgoto out_close_connected;\n\n\tlookup_link = attach_lookup_prog(skel->progs.sk_assign_esocknosupport);\n\tif (!lookup_link)\n\t\tgoto out_close_connected;\n\n\t \n\tclient_fd = make_client(sotype, EXT_IP4, EXT_PORT);\n\tif (client_fd < 0)\n\t\tgoto out_unlink_prog;\n\tif (sotype == SOCK_DGRAM) {\n\t\tsend_byte(client_fd);\n\t\trecv_byte(server_fd);\n\t}\n\n\tclose(client_fd);\nout_unlink_prog:\n\tbpf_link__destroy(lookup_link);\nout_close_connected:\n\tclose(connected_fd);\nout_close_server:\n\tclose(server_fd);\n}\n\nstatic void test_sk_assign_helper(struct test_sk_lookup *skel)\n{\n\tif (test__start_subtest(\"sk_assign returns EEXIST\"))\n\t\trun_sk_assign_v4(skel, skel->progs.sk_assign_eexist);\n\tif (test__start_subtest(\"sk_assign honors F_REPLACE\"))\n\t\trun_sk_assign_v4(skel, skel->progs.sk_assign_replace_flag);\n\tif (test__start_subtest(\"sk_assign accepts NULL socket\"))\n\t\trun_sk_assign_v4(skel, skel->progs.sk_assign_null);\n\tif (test__start_subtest(\"access ctx->sk\"))\n\t\trun_sk_assign_v4(skel, skel->progs.access_ctx_sk);\n\tif (test__start_subtest(\"narrow access to ctx v4\"))\n\t\trun_sk_assign_v4(skel, skel->progs.ctx_narrow_access);\n\tif (test__start_subtest(\"narrow access to ctx v6\"))\n\t\trun_sk_assign_v6(skel, skel->progs.ctx_narrow_access);\n\tif (test__start_subtest(\"sk_assign rejects TCP established\"))\n\t\trun_sk_assign_connected(skel, SOCK_STREAM);\n\tif (test__start_subtest(\"sk_assign rejects UDP connected\"))\n\t\trun_sk_assign_connected(skel, SOCK_DGRAM);\n}\n\nstruct test_multi_prog {\n\tconst char *desc;\n\tstruct bpf_program *prog1;\n\tstruct bpf_program *prog2;\n\tstruct bpf_map *redir_map;\n\tstruct bpf_map *run_map;\n\tint expect_errno;\n\tstruct inet_addr listen_at;\n};\n\nstatic void run_multi_prog_lookup(const struct test_multi_prog *t)\n{\n\tstruct sockaddr_storage dst = {};\n\tint map_fd, server_fd, client_fd;\n\tstruct bpf_link *link1, *link2;\n\tint prog_idx, done, err;\n\n\tmap_fd = bpf_map__fd(t->run_map);\n\n\tdone = 0;\n\tprog_idx = PROG1;\n\terr = bpf_map_update_elem(map_fd, &prog_idx, &done, BPF_ANY);\n\tif (CHECK(err, \"bpf_map_update_elem\", \"failed\\n\"))\n\t\treturn;\n\tprog_idx = PROG2;\n\terr = bpf_map_update_elem(map_fd, &prog_idx, &done, BPF_ANY);\n\tif (CHECK(err, \"bpf_map_update_elem\", \"failed\\n\"))\n\t\treturn;\n\n\tlink1 = attach_lookup_prog(t->prog1);\n\tif (!link1)\n\t\treturn;\n\tlink2 = attach_lookup_prog(t->prog2);\n\tif (!link2)\n\t\tgoto out_unlink1;\n\n\tserver_fd = make_server(SOCK_STREAM, t->listen_at.ip,\n\t\t\t\tt->listen_at.port, NULL);\n\tif (server_fd < 0)\n\t\tgoto out_unlink2;\n\n\terr = update_lookup_map(t->redir_map, SERVER_A, server_fd);\n\tif (err)\n\t\tgoto out_close_server;\n\n\tclient_fd = make_socket(SOCK_STREAM, EXT_IP4, EXT_PORT, &dst);\n\tif (client_fd < 0)\n\t\tgoto out_close_server;\n\n\terr = connect(client_fd, (void *)&dst, inetaddr_len(&dst));\n\tif (CHECK(err && !t->expect_errno, \"connect\",\n\t\t  \"unexpected error %d\\n\", errno))\n\t\tgoto out_close_client;\n\tif (CHECK(err && t->expect_errno && errno != t->expect_errno,\n\t\t  \"connect\", \"unexpected error %d\\n\", errno))\n\t\tgoto out_close_client;\n\n\tdone = 0;\n\tprog_idx = PROG1;\n\terr = bpf_map_lookup_elem(map_fd, &prog_idx, &done);\n\tCHECK(err, \"bpf_map_lookup_elem\", \"failed\\n\");\n\tCHECK(!done, \"bpf_map_lookup_elem\", \"PROG1 !done\\n\");\n\n\tdone = 0;\n\tprog_idx = PROG2;\n\terr = bpf_map_lookup_elem(map_fd, &prog_idx, &done);\n\tCHECK(err, \"bpf_map_lookup_elem\", \"failed\\n\");\n\tCHECK(!done, \"bpf_map_lookup_elem\", \"PROG2 !done\\n\");\n\nout_close_client:\n\tclose(client_fd);\nout_close_server:\n\tclose(server_fd);\nout_unlink2:\n\tbpf_link__destroy(link2);\nout_unlink1:\n\tbpf_link__destroy(link1);\n}\n\nstatic void test_multi_prog_lookup(struct test_sk_lookup *skel)\n{\n\tstruct test_multi_prog tests[] = {\n\t\t{\n\t\t\t.desc\t\t= \"multi prog - pass, pass\",\n\t\t\t.prog1\t\t= skel->progs.multi_prog_pass1,\n\t\t\t.prog2\t\t= skel->progs.multi_prog_pass2,\n\t\t\t.listen_at\t= { EXT_IP4, EXT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"multi prog - drop, drop\",\n\t\t\t.prog1\t\t= skel->progs.multi_prog_drop1,\n\t\t\t.prog2\t\t= skel->progs.multi_prog_drop2,\n\t\t\t.listen_at\t= { EXT_IP4, EXT_PORT },\n\t\t\t.expect_errno\t= ECONNREFUSED,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"multi prog - pass, drop\",\n\t\t\t.prog1\t\t= skel->progs.multi_prog_pass1,\n\t\t\t.prog2\t\t= skel->progs.multi_prog_drop2,\n\t\t\t.listen_at\t= { EXT_IP4, EXT_PORT },\n\t\t\t.expect_errno\t= ECONNREFUSED,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"multi prog - drop, pass\",\n\t\t\t.prog1\t\t= skel->progs.multi_prog_drop1,\n\t\t\t.prog2\t\t= skel->progs.multi_prog_pass2,\n\t\t\t.listen_at\t= { EXT_IP4, EXT_PORT },\n\t\t\t.expect_errno\t= ECONNREFUSED,\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"multi prog - pass, redir\",\n\t\t\t.prog1\t\t= skel->progs.multi_prog_pass1,\n\t\t\t.prog2\t\t= skel->progs.multi_prog_redir2,\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"multi prog - redir, pass\",\n\t\t\t.prog1\t\t= skel->progs.multi_prog_redir1,\n\t\t\t.prog2\t\t= skel->progs.multi_prog_pass2,\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"multi prog - drop, redir\",\n\t\t\t.prog1\t\t= skel->progs.multi_prog_drop1,\n\t\t\t.prog2\t\t= skel->progs.multi_prog_redir2,\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"multi prog - redir, drop\",\n\t\t\t.prog1\t\t= skel->progs.multi_prog_redir1,\n\t\t\t.prog2\t\t= skel->progs.multi_prog_drop2,\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t},\n\t\t{\n\t\t\t.desc\t\t= \"multi prog - redir, redir\",\n\t\t\t.prog1\t\t= skel->progs.multi_prog_redir1,\n\t\t\t.prog2\t\t= skel->progs.multi_prog_redir2,\n\t\t\t.listen_at\t= { INT_IP4, INT_PORT },\n\t\t},\n\t};\n\tstruct test_multi_prog *t;\n\n\tfor (t = tests; t < tests + ARRAY_SIZE(tests); t++) {\n\t\tt->redir_map = skel->maps.redir_map;\n\t\tt->run_map = skel->maps.run_map;\n\t\tif (test__start_subtest(t->desc))\n\t\t\trun_multi_prog_lookup(t);\n\t}\n}\n\nstatic void run_tests(struct test_sk_lookup *skel)\n{\n\tif (test__start_subtest(\"query lookup prog\"))\n\t\tquery_lookup_prog(skel);\n\ttest_redirect_lookup(skel);\n\ttest_drop_on_lookup(skel);\n\ttest_drop_on_reuseport(skel);\n\ttest_sk_assign_helper(skel);\n\ttest_multi_prog_lookup(skel);\n}\n\nstatic int switch_netns(void)\n{\n\tstatic const char * const setup_script[] = {\n\t\t\"ip -6 addr add dev lo \" EXT_IP6 \"/128\",\n\t\t\"ip -6 addr add dev lo \" INT_IP6 \"/128\",\n\t\t\"ip link set dev lo up\",\n\t\tNULL,\n\t};\n\tconst char * const *cmd;\n\tint err;\n\n\terr = unshare(CLONE_NEWNET);\n\tif (CHECK(err, \"unshare\", \"failed\\n\")) {\n\t\tlog_err(\"unshare(CLONE_NEWNET)\");\n\t\treturn -1;\n\t}\n\n\tfor (cmd = setup_script; *cmd; cmd++) {\n\t\terr = system(*cmd);\n\t\tif (CHECK(err, \"system\", \"failed\\n\")) {\n\t\t\tlog_err(\"system(%s)\", *cmd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid test_sk_lookup(void)\n{\n\tstruct test_sk_lookup *skel;\n\tint err;\n\n\terr = switch_netns();\n\tif (err)\n\t\treturn;\n\n\tskel = test_sk_lookup__open_and_load();\n\tif (CHECK(!skel, \"skel open_and_load\", \"failed\\n\"))\n\t\treturn;\n\n\trun_tests(skel);\n\n\ttest_sk_lookup__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}