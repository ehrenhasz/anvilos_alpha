{
  "module_name": "check_mtu.c",
  "hash_id": "19db279c2608e4308fc3e7d8162b890e6df98e47f7522a0b34836dfa185234e1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/check_mtu.c",
  "human_readable_source": "\n \n\n#include <linux/if_link.h>  \n#include <test_progs.h>\n#include \"test_check_mtu.skel.h\"\n#include \"network_helpers.h\"\n\n#include <stdlib.h>\n#include <inttypes.h>\n\n#define IFINDEX_LO 1\n\nstatic __u32 duration;  \n\nstatic int read_mtu_device_lo(void)\n{\n\tconst char *filename = \"/sys/class/net/lo/mtu\";\n\tchar buf[11] = {};\n\tint value, n, fd;\n\n\tfd = open(filename, 0, O_RDONLY);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tn = read(fd, buf, sizeof(buf));\n\tclose(fd);\n\n\tif (n == -1)\n\t\treturn -2;\n\n\tvalue = strtoimax(buf, NULL, 10);\n\tif (errno == ERANGE)\n\t\treturn -3;\n\n\treturn value;\n}\n\nstatic void test_check_mtu_xdp_attach(void)\n{\n\tstruct bpf_link_info link_info;\n\t__u32 link_info_len = sizeof(link_info);\n\tstruct test_check_mtu *skel;\n\tstruct bpf_program *prog;\n\tstruct bpf_link *link;\n\tint err = 0;\n\tint fd;\n\n\tskel = test_check_mtu__open_and_load();\n\tif (CHECK(!skel, \"open and load skel\", \"failed\"))\n\t\treturn;  \n\n\tprog = skel->progs.xdp_use_helper_basic;\n\n\tlink = bpf_program__attach_xdp(prog, IFINDEX_LO);\n\tif (!ASSERT_OK_PTR(link, \"link_attach\"))\n\t\tgoto out;\n\tskel->links.xdp_use_helper_basic = link;\n\n\tmemset(&link_info, 0, sizeof(link_info));\n\tfd = bpf_link__fd(link);\n\terr = bpf_link_get_info_by_fd(fd, &link_info, &link_info_len);\n\tif (CHECK(err, \"link_info\", \"failed: %d\\n\", err))\n\t\tgoto out;\n\n\tCHECK(link_info.type != BPF_LINK_TYPE_XDP, \"link_type\",\n\t      \"got %u != exp %u\\n\", link_info.type, BPF_LINK_TYPE_XDP);\n\tCHECK(link_info.xdp.ifindex != IFINDEX_LO, \"link_ifindex\",\n\t      \"got %u != exp %u\\n\", link_info.xdp.ifindex, IFINDEX_LO);\n\n\terr = bpf_link__detach(link);\n\tCHECK(err, \"link_detach\", \"failed %d\\n\", err);\n\nout:\n\ttest_check_mtu__destroy(skel);\n}\n\nstatic void test_check_mtu_run_xdp(struct test_check_mtu *skel,\n\t\t\t\t   struct bpf_program *prog,\n\t\t\t\t   __u32 mtu_expect)\n{\n\tint retval_expect = XDP_PASS;\n\t__u32 mtu_result = 0;\n\tchar buf[256] = {};\n\tint err, prog_fd = bpf_program__fd(prog);\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.repeat = 1,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.data_out = buf,\n\t\t.data_size_out = sizeof(buf),\n\t);\n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"test_run\");\n\tASSERT_EQ(topts.retval, retval_expect, \"retval\");\n\n\t \n\tmtu_result = skel->bss->global_bpf_mtu_xdp;\n\tASSERT_EQ(mtu_result, mtu_expect, \"MTU-compare-user\");\n}\n\n\nstatic void test_check_mtu_xdp(__u32 mtu, __u32 ifindex)\n{\n\tstruct test_check_mtu *skel;\n\tint err;\n\n\tskel = test_check_mtu__open();\n\tif (CHECK(!skel, \"skel_open\", \"failed\"))\n\t\treturn;\n\n\t \n\tskel->rodata->GLOBAL_USER_MTU = mtu;\n\tskel->rodata->GLOBAL_USER_IFINDEX = ifindex;\n\n\terr = test_check_mtu__load(skel);\n\tif (CHECK(err, \"skel_load\", \"failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\ttest_check_mtu_run_xdp(skel, skel->progs.xdp_use_helper, mtu);\n\ttest_check_mtu_run_xdp(skel, skel->progs.xdp_exceed_mtu, mtu);\n\ttest_check_mtu_run_xdp(skel, skel->progs.xdp_minus_delta, mtu);\n\ttest_check_mtu_run_xdp(skel, skel->progs.xdp_input_len, mtu);\n\ttest_check_mtu_run_xdp(skel, skel->progs.xdp_input_len_exceed, mtu);\n\ncleanup:\n\ttest_check_mtu__destroy(skel);\n}\n\nstatic void test_check_mtu_run_tc(struct test_check_mtu *skel,\n\t\t\t\t  struct bpf_program *prog,\n\t\t\t\t  __u32 mtu_expect)\n{\n\tint retval_expect = BPF_OK;\n\t__u32 mtu_result = 0;\n\tchar buf[256] = {};\n\tint err, prog_fd = bpf_program__fd(prog);\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = &pkt_v4,\n\t\t.data_size_in = sizeof(pkt_v4),\n\t\t.data_out = buf,\n\t\t.data_size_out = sizeof(buf),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_run_opts(prog_fd, &topts);\n\tASSERT_OK(err, \"test_run\");\n\tASSERT_EQ(topts.retval, retval_expect, \"retval\");\n\n\t \n\tmtu_result = skel->bss->global_bpf_mtu_tc;\n\tASSERT_EQ(mtu_result, mtu_expect, \"MTU-compare-user\");\n}\n\n\nstatic void test_check_mtu_tc(__u32 mtu, __u32 ifindex)\n{\n\tstruct test_check_mtu *skel;\n\tint err;\n\n\tskel = test_check_mtu__open();\n\tif (CHECK(!skel, \"skel_open\", \"failed\"))\n\t\treturn;\n\n\t \n\tskel->rodata->GLOBAL_USER_MTU = mtu;\n\tskel->rodata->GLOBAL_USER_IFINDEX = ifindex;\n\n\terr = test_check_mtu__load(skel);\n\tif (CHECK(err, \"skel_load\", \"failed: %d\\n\", err))\n\t\tgoto cleanup;\n\n\ttest_check_mtu_run_tc(skel, skel->progs.tc_use_helper, mtu);\n\ttest_check_mtu_run_tc(skel, skel->progs.tc_exceed_mtu, mtu);\n\ttest_check_mtu_run_tc(skel, skel->progs.tc_exceed_mtu_da, mtu);\n\ttest_check_mtu_run_tc(skel, skel->progs.tc_minus_delta, mtu);\n\ttest_check_mtu_run_tc(skel, skel->progs.tc_input_len, mtu);\n\ttest_check_mtu_run_tc(skel, skel->progs.tc_input_len_exceed, mtu);\ncleanup:\n\ttest_check_mtu__destroy(skel);\n}\n\nvoid serial_test_check_mtu(void)\n{\n\tint mtu_lo;\n\n\tif (test__start_subtest(\"bpf_check_mtu XDP-attach\"))\n\t\ttest_check_mtu_xdp_attach();\n\n\tmtu_lo = read_mtu_device_lo();\n\tif (CHECK(mtu_lo < 0, \"reading MTU value\", \"failed (err:%d)\", mtu_lo))\n\t\treturn;\n\n\tif (test__start_subtest(\"bpf_check_mtu XDP-run\"))\n\t\ttest_check_mtu_xdp(mtu_lo, 0);\n\n\tif (test__start_subtest(\"bpf_check_mtu XDP-run ifindex-lookup\"))\n\t\ttest_check_mtu_xdp(mtu_lo, IFINDEX_LO);\n\n\tif (test__start_subtest(\"bpf_check_mtu TC-run\"))\n\t\ttest_check_mtu_tc(mtu_lo, 0);\n\n\tif (test__start_subtest(\"bpf_check_mtu TC-run ifindex-lookup\"))\n\t\ttest_check_mtu_tc(mtu_lo, IFINDEX_LO);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}