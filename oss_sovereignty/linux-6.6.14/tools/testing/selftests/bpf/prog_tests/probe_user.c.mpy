{
  "module_name": "probe_user.c",
  "hash_id": "e2c4f5c3d7f6df538772ba17a7debcd59f9cfe69e3fc75ef0510fe45f7780e5c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/probe_user.c",
  "human_readable_source": "\n#include <test_progs.h>\n\n \nvoid serial_test_probe_user(void)\n{\n\tstatic const char *const prog_names[] = {\n\t\t\"handle_sys_connect\",\n#if defined(__s390x__)\n\t\t\"handle_sys_socketcall\",\n#endif\n\t};\n\tenum { prog_count = ARRAY_SIZE(prog_names) };\n\tconst char *obj_file = \"./test_probe_user.bpf.o\";\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts, );\n\tint err, results_map_fd, sock_fd, duration = 0;\n\tstruct sockaddr curr, orig, tmp;\n\tstruct sockaddr_in *in = (struct sockaddr_in *)&curr;\n\tstruct bpf_link *kprobe_links[prog_count] = {};\n\tstruct bpf_program *kprobe_progs[prog_count];\n\tstruct bpf_object *obj;\n\tstatic const int zero = 0;\n\tsize_t i;\n\n\tobj = bpf_object__open_file(obj_file, &opts);\n\tif (!ASSERT_OK_PTR(obj, \"obj_open_file\"))\n\t\treturn;\n\n\tfor (i = 0; i < prog_count; i++) {\n\t\tkprobe_progs[i] =\n\t\t\tbpf_object__find_program_by_name(obj, prog_names[i]);\n\t\tif (CHECK(!kprobe_progs[i], \"find_probe\",\n\t\t\t  \"prog '%s' not found\\n\", prog_names[i]))\n\t\t\tgoto cleanup;\n\t}\n\n\terr = bpf_object__load(obj);\n\tif (CHECK(err, \"obj_load\", \"err %d\\n\", err))\n\t\tgoto cleanup;\n\n\tresults_map_fd = bpf_find_map(__func__, obj, \"test_pro.bss\");\n\tif (CHECK(results_map_fd < 0, \"find_bss_map\",\n\t\t  \"err %d\\n\", results_map_fd))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < prog_count; i++) {\n\t\tkprobe_links[i] = bpf_program__attach(kprobe_progs[i]);\n\t\tif (!ASSERT_OK_PTR(kprobe_links[i], \"attach_kprobe\"))\n\t\t\tgoto cleanup;\n\t}\n\n\tmemset(&curr, 0, sizeof(curr));\n\tin->sin_family = AF_INET;\n\tin->sin_port = htons(5555);\n\tin->sin_addr.s_addr = inet_addr(\"255.255.255.255\");\n\tmemcpy(&orig, &curr, sizeof(curr));\n\n\tsock_fd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (CHECK(sock_fd < 0, \"create_sock_fd\", \"err %d\\n\", sock_fd))\n\t\tgoto cleanup;\n\n\tconnect(sock_fd, &curr, sizeof(curr));\n\tclose(sock_fd);\n\n\terr = bpf_map_lookup_elem(results_map_fd, &zero, &tmp);\n\tif (CHECK(err, \"get_kprobe_res\",\n\t\t  \"failed to get kprobe res: %d\\n\", err))\n\t\tgoto cleanup;\n\n\tin = (struct sockaddr_in *)&tmp;\n\tif (CHECK(memcmp(&tmp, &orig, sizeof(orig)), \"check_kprobe_res\",\n\t\t  \"wrong kprobe res from probe read: %s:%u\\n\",\n\t\t  inet_ntoa(in->sin_addr), ntohs(in->sin_port)))\n\t\tgoto cleanup;\n\n\tmemset(&tmp, 0xab, sizeof(tmp));\n\n\tin = (struct sockaddr_in *)&curr;\n\tif (CHECK(memcmp(&curr, &tmp, sizeof(tmp)), \"check_kprobe_res\",\n\t\t  \"wrong kprobe res from probe write: %s:%u\\n\",\n\t\t  inet_ntoa(in->sin_addr), ntohs(in->sin_port)))\n\t\tgoto cleanup;\ncleanup:\n\tfor (i = 0; i < prog_count; i++)\n\t\tbpf_link__destroy(kprobe_links[i]);\n\tbpf_object__close(obj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}