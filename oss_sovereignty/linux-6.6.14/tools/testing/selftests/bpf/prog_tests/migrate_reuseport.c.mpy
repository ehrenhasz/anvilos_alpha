{
  "module_name": "migrate_reuseport.c",
  "hash_id": "8423e3fe825244e1461f5b206115bbf5430b867e299e939976e6530699fecfad",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/migrate_reuseport.c",
  "human_readable_source": "\n \n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"test_progs.h\"\n#include \"test_migrate_reuseport.skel.h\"\n#include \"network_helpers.h\"\n\n#ifndef TCP_FASTOPEN_CONNECT\n#define TCP_FASTOPEN_CONNECT 30\n#endif\n\n#define IFINDEX_LO 1\n\n#define NR_SERVERS 5\n#define NR_CLIENTS (NR_SERVERS * 5)\n#define MIGRATED_TO (NR_SERVERS - 1)\n\n \n#define QLEN (NR_CLIENTS * 5)\n\n#define MSG \"Hello World\\0\"\n#define MSGLEN 12\n\nstatic struct migrate_reuseport_test_case {\n\tconst char *name;\n\t__s64 servers[NR_SERVERS];\n\t__s64 clients[NR_CLIENTS];\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tint family;\n\tint state;\n\tbool drop_ack;\n\tbool expire_synack_timer;\n\tbool fastopen;\n\tstruct bpf_link *link;\n} test_cases[] = {\n\t{\n\t\t.name = \"IPv4 TCP_ESTABLISHED  inet_csk_listen_stop\",\n\t\t.family = AF_INET,\n\t\t.state = BPF_TCP_ESTABLISHED,\n\t\t.drop_ack = false,\n\t\t.expire_synack_timer = false,\n\t\t.fastopen = false,\n\t},\n\t{\n\t\t.name = \"IPv4 TCP_SYN_RECV     inet_csk_listen_stop\",\n\t\t.family = AF_INET,\n\t\t.state = BPF_TCP_SYN_RECV,\n\t\t.drop_ack = true,\n\t\t.expire_synack_timer = false,\n\t\t.fastopen = true,\n\t},\n\t{\n\t\t.name = \"IPv4 TCP_NEW_SYN_RECV reqsk_timer_handler\",\n\t\t.family = AF_INET,\n\t\t.state = BPF_TCP_NEW_SYN_RECV,\n\t\t.drop_ack = true,\n\t\t.expire_synack_timer = true,\n\t\t.fastopen = false,\n\t},\n\t{\n\t\t.name = \"IPv4 TCP_NEW_SYN_RECV inet_csk_complete_hashdance\",\n\t\t.family = AF_INET,\n\t\t.state = BPF_TCP_NEW_SYN_RECV,\n\t\t.drop_ack = true,\n\t\t.expire_synack_timer = false,\n\t\t.fastopen = false,\n\t},\n\t{\n\t\t.name = \"IPv6 TCP_ESTABLISHED  inet_csk_listen_stop\",\n\t\t.family = AF_INET6,\n\t\t.state = BPF_TCP_ESTABLISHED,\n\t\t.drop_ack = false,\n\t\t.expire_synack_timer = false,\n\t\t.fastopen = false,\n\t},\n\t{\n\t\t.name = \"IPv6 TCP_SYN_RECV     inet_csk_listen_stop\",\n\t\t.family = AF_INET6,\n\t\t.state = BPF_TCP_SYN_RECV,\n\t\t.drop_ack = true,\n\t\t.expire_synack_timer = false,\n\t\t.fastopen = true,\n\t},\n\t{\n\t\t.name = \"IPv6 TCP_NEW_SYN_RECV reqsk_timer_handler\",\n\t\t.family = AF_INET6,\n\t\t.state = BPF_TCP_NEW_SYN_RECV,\n\t\t.drop_ack = true,\n\t\t.expire_synack_timer = true,\n\t\t.fastopen = false,\n\t},\n\t{\n\t\t.name = \"IPv6 TCP_NEW_SYN_RECV inet_csk_complete_hashdance\",\n\t\t.family = AF_INET6,\n\t\t.state = BPF_TCP_NEW_SYN_RECV,\n\t\t.drop_ack = true,\n\t\t.expire_synack_timer = false,\n\t\t.fastopen = false,\n\t}\n};\n\nstatic void init_fds(__s64 fds[], int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tfds[i] = -1;\n}\n\nstatic void close_fds(__s64 fds[], int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (fds[i] != -1) {\n\t\t\tclose(fds[i]);\n\t\t\tfds[i] = -1;\n\t\t}\n\t}\n}\n\nstatic int setup_fastopen(char *buf, int size, int *saved_len, bool restore)\n{\n\tint err = 0, fd, len;\n\n\tfd = open(\"/proc/sys/net/ipv4/tcp_fastopen\", O_RDWR);\n\tif (!ASSERT_NEQ(fd, -1, \"open\"))\n\t\treturn -1;\n\n\tif (restore) {\n\t\tlen = write(fd, buf, *saved_len);\n\t\tif (!ASSERT_EQ(len, *saved_len, \"write - restore\"))\n\t\t\terr = -1;\n\t} else {\n\t\t*saved_len = read(fd, buf, size);\n\t\tif (!ASSERT_GE(*saved_len, 1, \"read\")) {\n\t\t\terr = -1;\n\t\t\tgoto close;\n\t\t}\n\n\t\terr = lseek(fd, 0, SEEK_SET);\n\t\tif (!ASSERT_OK(err, \"lseek\"))\n\t\t\tgoto close;\n\n\t\t \n\t\tlen = write(fd, \"519\", 3);\n\t\tif (!ASSERT_EQ(len, 3, \"write - setup\"))\n\t\t\terr = -1;\n\t}\n\nclose:\n\tclose(fd);\n\n\treturn err;\n}\n\nstatic int drop_ack(struct migrate_reuseport_test_case *test_case,\n\t\t    struct test_migrate_reuseport *skel)\n{\n\tif (test_case->family == AF_INET)\n\t\tskel->bss->server_port = ((struct sockaddr_in *)\n\t\t\t\t\t  &test_case->addr)->sin_port;\n\telse\n\t\tskel->bss->server_port = ((struct sockaddr_in6 *)\n\t\t\t\t\t  &test_case->addr)->sin6_port;\n\n\ttest_case->link = bpf_program__attach_xdp(skel->progs.drop_ack,\n\t\t\t\t\t\t  IFINDEX_LO);\n\tif (!ASSERT_OK_PTR(test_case->link, \"bpf_program__attach_xdp\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int pass_ack(struct migrate_reuseport_test_case *test_case)\n{\n\tint err;\n\n\terr = bpf_link__destroy(test_case->link);\n\tif (!ASSERT_OK(err, \"bpf_link__destroy\"))\n\t\treturn -1;\n\n\ttest_case->link = NULL;\n\n\treturn 0;\n}\n\nstatic int start_servers(struct migrate_reuseport_test_case *test_case,\n\t\t\t struct test_migrate_reuseport *skel)\n{\n\tint i, err, prog_fd, reuseport = 1, qlen = QLEN;\n\n\tprog_fd = bpf_program__fd(skel->progs.migrate_reuseport);\n\n\tmake_sockaddr(test_case->family,\n\t\t      test_case->family == AF_INET ? \"127.0.0.1\" : \"::1\", 0,\n\t\t      &test_case->addr, &test_case->addrlen);\n\n\tfor (i = 0; i < NR_SERVERS; i++) {\n\t\ttest_case->servers[i] = socket(test_case->family, SOCK_STREAM,\n\t\t\t\t\t       IPPROTO_TCP);\n\t\tif (!ASSERT_NEQ(test_case->servers[i], -1, \"socket\"))\n\t\t\treturn -1;\n\n\t\terr = setsockopt(test_case->servers[i], SOL_SOCKET,\n\t\t\t\t SO_REUSEPORT, &reuseport, sizeof(reuseport));\n\t\tif (!ASSERT_OK(err, \"setsockopt - SO_REUSEPORT\"))\n\t\t\treturn -1;\n\n\t\terr = bind(test_case->servers[i],\n\t\t\t   (struct sockaddr *)&test_case->addr,\n\t\t\t   test_case->addrlen);\n\t\tif (!ASSERT_OK(err, \"bind\"))\n\t\t\treturn -1;\n\n\t\tif (i == 0) {\n\t\t\terr = setsockopt(test_case->servers[i], SOL_SOCKET,\n\t\t\t\t\t SO_ATTACH_REUSEPORT_EBPF,\n\t\t\t\t\t &prog_fd, sizeof(prog_fd));\n\t\t\tif (!ASSERT_OK(err,\n\t\t\t\t       \"setsockopt - SO_ATTACH_REUSEPORT_EBPF\"))\n\t\t\t\treturn -1;\n\n\t\t\terr = getsockname(test_case->servers[i],\n\t\t\t\t\t  (struct sockaddr *)&test_case->addr,\n\t\t\t\t\t  &test_case->addrlen);\n\t\t\tif (!ASSERT_OK(err, \"getsockname\"))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (test_case->fastopen) {\n\t\t\terr = setsockopt(test_case->servers[i],\n\t\t\t\t\t SOL_TCP, TCP_FASTOPEN,\n\t\t\t\t\t &qlen, sizeof(qlen));\n\t\t\tif (!ASSERT_OK(err, \"setsockopt - TCP_FASTOPEN\"))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (i != MIGRATED_TO) {\n\t\t\terr = listen(test_case->servers[i], qlen);\n\t\t\tif (!ASSERT_OK(err, \"listen\"))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int start_clients(struct migrate_reuseport_test_case *test_case)\n{\n\tchar buf[MSGLEN] = MSG;\n\tint i, err;\n\n\tfor (i = 0; i < NR_CLIENTS; i++) {\n\t\ttest_case->clients[i] = socket(test_case->family, SOCK_STREAM,\n\t\t\t\t\t       IPPROTO_TCP);\n\t\tif (!ASSERT_NEQ(test_case->clients[i], -1, \"socket\"))\n\t\t\treturn -1;\n\n\t\t \n\t\terr = settimeo(test_case->clients[i], 100);\n\t\tif (!ASSERT_OK(err, \"settimeo\"))\n\t\t\treturn -1;\n\n\t\tif (test_case->fastopen) {\n\t\t\tint fastopen = 1;\n\n\t\t\terr = setsockopt(test_case->clients[i], IPPROTO_TCP,\n\t\t\t\t\t TCP_FASTOPEN_CONNECT, &fastopen,\n\t\t\t\t\t sizeof(fastopen));\n\t\t\tif (!ASSERT_OK(err,\n\t\t\t\t       \"setsockopt - TCP_FASTOPEN_CONNECT\"))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\terr = connect(test_case->clients[i],\n\t\t\t      (struct sockaddr *)&test_case->addr,\n\t\t\t      test_case->addrlen);\n\t\tif (!ASSERT_OK(err, \"connect\"))\n\t\t\treturn -1;\n\n\t\terr = write(test_case->clients[i], buf, MSGLEN);\n\t\tif (!ASSERT_EQ(err, MSGLEN, \"write\"))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int update_maps(struct migrate_reuseport_test_case *test_case,\n\t\t       struct test_migrate_reuseport *skel)\n{\n\tint i, err, migrated_to = MIGRATED_TO;\n\tint reuseport_map_fd, migrate_map_fd;\n\t__u64 value;\n\n\treuseport_map_fd = bpf_map__fd(skel->maps.reuseport_map);\n\tmigrate_map_fd = bpf_map__fd(skel->maps.migrate_map);\n\n\tfor (i = 0; i < NR_SERVERS; i++) {\n\t\tvalue = (__u64)test_case->servers[i];\n\t\terr = bpf_map_update_elem(reuseport_map_fd, &i, &value,\n\t\t\t\t\t  BPF_NOEXIST);\n\t\tif (!ASSERT_OK(err, \"bpf_map_update_elem - reuseport_map\"))\n\t\t\treturn -1;\n\n\t\terr = bpf_map_lookup_elem(reuseport_map_fd, &i, &value);\n\t\tif (!ASSERT_OK(err, \"bpf_map_lookup_elem - reuseport_map\"))\n\t\t\treturn -1;\n\n\t\terr = bpf_map_update_elem(migrate_map_fd, &value, &migrated_to,\n\t\t\t\t\t  BPF_NOEXIST);\n\t\tif (!ASSERT_OK(err, \"bpf_map_update_elem - migrate_map\"))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int migrate_dance(struct migrate_reuseport_test_case *test_case)\n{\n\tint i, err;\n\n\t \n\tfor (i = 0; i < MIGRATED_TO; i++) {\n\t\terr = shutdown(test_case->servers[i], SHUT_RDWR);\n\t\tif (!ASSERT_OK(err, \"shutdown\"))\n\t\t\treturn -1;\n\t}\n\n\t \n\tif (test_case->state == BPF_TCP_NEW_SYN_RECV)\n\t\treturn 0;\n\n\t \n\terr = listen(test_case->servers[1], QLEN);\n\tif (!ASSERT_OK(err, \"listen\"))\n\t\treturn -1;\n\n\t \n\terr = shutdown(test_case->servers[MIGRATED_TO], SHUT_RDWR);\n\tif (!ASSERT_OK(err, \"shutdown\"))\n\t\treturn -1;\n\n\t \n\terr = listen(test_case->servers[MIGRATED_TO], QLEN);\n\tif (!ASSERT_OK(err, \"listen\"))\n\t\treturn -1;\n\n\t \n\terr = shutdown(test_case->servers[1], SHUT_RDWR);\n\tif (!ASSERT_OK(err, \"shutdown\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void count_requests(struct migrate_reuseport_test_case *test_case,\n\t\t\t   struct test_migrate_reuseport *skel)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t len = sizeof(addr);\n\tint err, cnt = 0, client;\n\tchar buf[MSGLEN];\n\n\terr = settimeo(test_case->servers[MIGRATED_TO], 4000);\n\tif (!ASSERT_OK(err, \"settimeo\"))\n\t\tgoto out;\n\n\tfor (; cnt < NR_CLIENTS; cnt++) {\n\t\tclient = accept(test_case->servers[MIGRATED_TO],\n\t\t\t\t(struct sockaddr *)&addr, &len);\n\t\tif (!ASSERT_NEQ(client, -1, \"accept\"))\n\t\t\tgoto out;\n\n\t\tmemset(buf, 0, MSGLEN);\n\t\tread(client, &buf, MSGLEN);\n\t\tclose(client);\n\n\t\tif (!ASSERT_STREQ(buf, MSG, \"read\"))\n\t\t\tgoto out;\n\t}\n\nout:\n\tASSERT_EQ(cnt, NR_CLIENTS, \"count in userspace\");\n\n\tswitch (test_case->state) {\n\tcase BPF_TCP_ESTABLISHED:\n\t\tcnt = skel->bss->migrated_at_close;\n\t\tbreak;\n\tcase BPF_TCP_SYN_RECV:\n\t\tcnt = skel->bss->migrated_at_close_fastopen;\n\t\tbreak;\n\tcase BPF_TCP_NEW_SYN_RECV:\n\t\tif (test_case->expire_synack_timer)\n\t\t\tcnt = skel->bss->migrated_at_send_synack;\n\t\telse\n\t\t\tcnt = skel->bss->migrated_at_recv_ack;\n\t\tbreak;\n\tdefault:\n\t\tcnt = 0;\n\t}\n\n\tASSERT_EQ(cnt, NR_CLIENTS, \"count in BPF prog\");\n}\n\nstatic void run_test(struct migrate_reuseport_test_case *test_case,\n\t\t     struct test_migrate_reuseport *skel)\n{\n\tint err, saved_len;\n\tchar buf[16];\n\n\tskel->bss->migrated_at_close = 0;\n\tskel->bss->migrated_at_close_fastopen = 0;\n\tskel->bss->migrated_at_send_synack = 0;\n\tskel->bss->migrated_at_recv_ack = 0;\n\n\tinit_fds(test_case->servers, NR_SERVERS);\n\tinit_fds(test_case->clients, NR_CLIENTS);\n\n\tif (test_case->fastopen) {\n\t\tmemset(buf, 0, sizeof(buf));\n\n\t\terr = setup_fastopen(buf, sizeof(buf), &saved_len, false);\n\t\tif (!ASSERT_OK(err, \"setup_fastopen - setup\"))\n\t\t\treturn;\n\t}\n\n\terr = start_servers(test_case, skel);\n\tif (!ASSERT_OK(err, \"start_servers\"))\n\t\tgoto close_servers;\n\n\tif (test_case->drop_ack) {\n\t\t \n\t\terr = drop_ack(test_case, skel);\n\t\tif (!ASSERT_OK(err, \"drop_ack\"))\n\t\t\tgoto close_servers;\n\t}\n\n\t \n\terr = start_clients(test_case);\n\tif (!ASSERT_OK(err, \"start_clients\"))\n\t\tgoto close_clients;\n\n\terr = listen(test_case->servers[MIGRATED_TO], QLEN);\n\tif (!ASSERT_OK(err, \"listen\"))\n\t\tgoto close_clients;\n\n\terr = update_maps(test_case, skel);\n\tif (!ASSERT_OK(err, \"fill_maps\"))\n\t\tgoto close_clients;\n\n\t \n\terr = migrate_dance(test_case);\n\tif (!ASSERT_OK(err, \"migrate_dance\"))\n\t\tgoto close_clients;\n\n\tif (test_case->expire_synack_timer) {\n\t\t \n\t\tsleep(1);\n\t}\n\n\tif (test_case->link) {\n\t\t \n\t\terr = pass_ack(test_case);\n\t\tif (!ASSERT_OK(err, \"pass_ack\"))\n\t\t\tgoto close_clients;\n\t}\n\n\tcount_requests(test_case, skel);\n\nclose_clients:\n\tclose_fds(test_case->clients, NR_CLIENTS);\n\n\tif (test_case->link) {\n\t\terr = pass_ack(test_case);\n\t\tASSERT_OK(err, \"pass_ack - clean up\");\n\t}\n\nclose_servers:\n\tclose_fds(test_case->servers, NR_SERVERS);\n\n\tif (test_case->fastopen) {\n\t\terr = setup_fastopen(buf, sizeof(buf), &saved_len, true);\n\t\tASSERT_OK(err, \"setup_fastopen - restore\");\n\t}\n}\n\nvoid serial_test_migrate_reuseport(void)\n{\n\tstruct test_migrate_reuseport *skel;\n\tint i;\n\n\tskel = test_migrate_reuseport__open_and_load();\n\tif (!ASSERT_OK_PTR(skel, \"open_and_load\"))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_cases); i++) {\n\t\ttest__start_subtest(test_cases[i].name);\n\t\trun_test(&test_cases[i], skel);\n\t}\n\n\ttest_migrate_reuseport__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}