{
  "module_name": "stacktrace_build_id.c",
  "hash_id": "129f8454724437c20821518f676a7e954600a8e8ccab7726350a3553c2f76901",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/stacktrace_build_id.c",
  "human_readable_source": "\n#include <test_progs.h>\n#include \"test_stacktrace_build_id.skel.h\"\n\nvoid test_stacktrace_build_id(void)\n{\n\n\tint control_map_fd, stackid_hmap_fd, stackmap_fd, stack_amap_fd;\n\tstruct test_stacktrace_build_id *skel;\n\tint err, stack_trace_len, build_id_size;\n\t__u32 key, prev_key, val, duration = 0;\n\tchar buf[BPF_BUILD_ID_SIZE];\n\tstruct bpf_stack_build_id id_offs[PERF_MAX_STACK_DEPTH];\n\tint build_id_matches = 0;\n\tint i, retry = 1;\n\nretry:\n\tskel = test_stacktrace_build_id__open_and_load();\n\tif (CHECK(!skel, \"skel_open_and_load\", \"skeleton open/load failed\\n\"))\n\t\treturn;\n\n\terr = test_stacktrace_build_id__attach(skel);\n\tif (CHECK(err, \"attach_tp\", \"err %d\\n\", err))\n\t\tgoto cleanup;\n\n\t \n\tcontrol_map_fd = bpf_map__fd(skel->maps.control_map);\n\tstackid_hmap_fd = bpf_map__fd(skel->maps.stackid_hmap);\n\tstackmap_fd = bpf_map__fd(skel->maps.stackmap);\n\tstack_amap_fd = bpf_map__fd(skel->maps.stack_amap);\n\n\tif (CHECK_FAIL(system(\"dd if=/dev/urandom of=/dev/zero count=4 2> /dev/null\")))\n\t\tgoto cleanup;\n\tif (CHECK_FAIL(system(\"./urandom_read\")))\n\t\tgoto cleanup;\n\t \n\tkey = 0;\n\tval = 1;\n\tbpf_map_update_elem(control_map_fd, &key, &val, 0);\n\n\t \n\terr = compare_map_keys(stackid_hmap_fd, stackmap_fd);\n\tif (CHECK(err, \"compare_map_keys stackid_hmap vs. stackmap\",\n\t\t  \"err %d errno %d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\terr = compare_map_keys(stackmap_fd, stackid_hmap_fd);\n\tif (CHECK(err, \"compare_map_keys stackmap vs. stackid_hmap\",\n\t\t  \"err %d errno %d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\tbuild_id_size = read_build_id(\"urandom_read\", buf, sizeof(buf));\n\terr = build_id_size < 0 ? build_id_size : 0;\n\n\tif (CHECK(err, \"read_build_id\",\n\t\t  \"err %d errno %d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\terr = bpf_map__get_next_key(skel->maps.stackmap, NULL, &key, sizeof(key));\n\tif (CHECK(err, \"get_next_key from stackmap\",\n\t\t  \"err %d, errno %d\\n\", err, errno))\n\t\tgoto cleanup;\n\n\tdo {\n\t\terr = bpf_map_lookup_elem(stackmap_fd, &key, id_offs);\n\t\tif (CHECK(err, \"lookup_elem from stackmap\",\n\t\t\t  \"err %d, errno %d\\n\", err, errno))\n\t\t\tgoto cleanup;\n\t\tfor (i = 0; i < PERF_MAX_STACK_DEPTH; ++i)\n\t\t\tif (id_offs[i].status == BPF_STACK_BUILD_ID_VALID &&\n\t\t\t    id_offs[i].offset != 0) {\n\t\t\t\tif (memcmp(buf, id_offs[i].build_id, build_id_size) == 0)\n\t\t\t\t\tbuild_id_matches = 1;\n\t\t\t}\n\t\tprev_key = key;\n\t} while (bpf_map__get_next_key(skel->maps.stackmap, &prev_key, &key, sizeof(key)) == 0);\n\n\t \n\tif (build_id_matches < 1 && retry--) {\n\t\ttest_stacktrace_build_id__destroy(skel);\n\t\tprintf(\"%s:WARN:Didn't find expected build ID from the map, retrying\\n\",\n\t\t       __func__);\n\t\tgoto retry;\n\t}\n\n\tif (CHECK(build_id_matches < 1, \"build id match\",\n\t\t  \"Didn't find expected build ID from the map\\n\"))\n\t\tgoto cleanup;\n\n\tstack_trace_len = PERF_MAX_STACK_DEPTH *\n\t\t\t  sizeof(struct bpf_stack_build_id);\n\terr = compare_stack_ips(stackmap_fd, stack_amap_fd, stack_trace_len);\n\tCHECK(err, \"compare_stack_ips stackmap vs. stack_amap\",\n\t      \"err %d errno %d\\n\", err, errno);\n\ncleanup:\n\ttest_stacktrace_build_id__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}