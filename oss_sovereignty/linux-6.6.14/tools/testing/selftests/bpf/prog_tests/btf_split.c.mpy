{
  "module_name": "btf_split.c",
  "hash_id": "bf500d1c9fe98d8a3701474c8add88ee623b6fb9406e897be2cfcf292e23cdd9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/btf_split.c",
  "human_readable_source": "\n \n#include <test_progs.h>\n#include <bpf/btf.h>\n\nstatic char *dump_buf;\nstatic size_t dump_buf_sz;\nstatic FILE *dump_buf_file;\n\nstatic void btf_dump_printf(void *ctx, const char *fmt, va_list args)\n{\n\tvfprintf(ctx, fmt, args);\n}\n\nvoid test_btf_split() {\n\tstruct btf_dump *d = NULL;\n\tconst struct btf_type *t;\n\tstruct btf *btf1, *btf2;\n\tint str_off, i, err;\n\n\tbtf1 = btf__new_empty();\n\tif (!ASSERT_OK_PTR(btf1, \"empty_main_btf\"))\n\t\treturn;\n\n\tbtf__set_pointer_size(btf1, 8);  \n\n\tbtf__add_int(btf1, \"int\", 4, BTF_INT_SIGNED);\t \n\tbtf__add_ptr(btf1, 1);\t\t\t\t \n\n\tbtf__add_struct(btf1, \"s1\", 4);\t\t\t \n\tbtf__add_field(btf1, \"f1\", 1, 0, 0);\t\t \n\t\t\t\t\t\t\t \n\n\tbtf2 = btf__new_empty_split(btf1);\n\tif (!ASSERT_OK_PTR(btf2, \"empty_split_btf\"))\n\t\tgoto cleanup;\n\n\t \n\tASSERT_EQ(btf__pointer_size(btf2), 8, \"inherit_ptr_sz\");\n\n\tstr_off = btf__find_str(btf2, \"int\");\n\tASSERT_NEQ(str_off, -ENOENT, \"str_int_missing\");\n\n\tt = btf__type_by_id(btf2, 1);\n\tif (!ASSERT_OK_PTR(t, \"int_type\"))\n\t\tgoto cleanup;\n\tASSERT_EQ(btf_is_int(t), true, \"int_kind\");\n\tASSERT_STREQ(btf__str_by_offset(btf2, t->name_off), \"int\", \"int_name\");\n\n\tbtf__add_struct(btf2, \"s2\", 16);\t\t \n\tbtf__add_field(btf2, \"f1\", 3, 0, 0);\t\t \n\tbtf__add_field(btf2, \"f2\", 1, 32, 0);\t\t \n\tbtf__add_field(btf2, \"f3\", 2, 64, 0);\t\t \n\t\t\t\t\t\t\t \n\n\tt = btf__type_by_id(btf1, 4);\n\tASSERT_NULL(t, \"split_type_in_main\");\n\n\tt = btf__type_by_id(btf2, 4);\n\tif (!ASSERT_OK_PTR(t, \"split_struct_type\"))\n\t\tgoto cleanup;\n\tASSERT_EQ(btf_is_struct(t), true, \"split_struct_kind\");\n\tASSERT_EQ(btf_vlen(t), 3, \"split_struct_vlen\");\n\tASSERT_STREQ(btf__str_by_offset(btf2, t->name_off), \"s2\", \"split_struct_name\");\n\n\t \n\tdump_buf_file = open_memstream(&dump_buf, &dump_buf_sz);\n\tif (!ASSERT_OK_PTR(dump_buf_file, \"dump_memstream\"))\n\t\treturn;\n\td = btf_dump__new(btf2, btf_dump_printf, dump_buf_file, NULL);\n\tif (!ASSERT_OK_PTR(d, \"btf_dump__new\"))\n\t\tgoto cleanup;\n\tfor (i = 1; i < btf__type_cnt(btf2); i++) {\n\t\terr = btf_dump__dump_type(d, i);\n\t\tASSERT_OK(err, \"dump_type_ok\");\n\t}\n\tfflush(dump_buf_file);\n\tdump_buf[dump_buf_sz] = 0;  \n\tASSERT_STREQ(dump_buf,\n\"struct s1 {\\n\"\n\"\tint f1;\\n\"\n\"};\\n\"\n\"\\n\"\n\"struct s2 {\\n\"\n\"\tstruct s1 f1;\\n\"\n\"\tint f2;\\n\"\n\"\tint *f3;\\n\"\n\"};\\n\\n\", \"c_dump\");\n\ncleanup:\n\tif (dump_buf_file)\n\t\tfclose(dump_buf_file);\n\tfree(dump_buf);\n\tbtf_dump__free(d);\n\tbtf__free(btf1);\n\tbtf__free(btf2);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}