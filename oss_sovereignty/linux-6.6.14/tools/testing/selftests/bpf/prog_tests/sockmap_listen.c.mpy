{
  "module_name": "sockmap_listen.c",
  "hash_id": "96e66216f2712619298c1ce40d7cfe8ac242b3824996ffcfe40a02dce3c806b0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/sockmap_listen.c",
  "human_readable_source": "\n\n \n\n#include <linux/compiler.h>\n#include <errno.h>\n#include <error.h>\n#include <limits.h>\n#include <netinet/in.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/select.h>\n#include <unistd.h>\n#include <linux/vm_sockets.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"bpf_util.h\"\n#include \"test_progs.h\"\n#include \"test_sockmap_listen.skel.h\"\n\n#include \"sockmap_helpers.h\"\n\nstatic void test_insert_invalid(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\tint family, int sotype, int mapfd)\n{\n\tu32 key = 0;\n\tu64 value;\n\tint err;\n\n\tvalue = -1;\n\terr = bpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\tif (!err || errno != EINVAL)\n\t\tFAIL_ERRNO(\"map_update: expected EINVAL\");\n\n\tvalue = INT_MAX;\n\terr = bpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\tif (!err || errno != EBADF)\n\t\tFAIL_ERRNO(\"map_update: expected EBADF\");\n}\n\nstatic void test_insert_opened(struct test_sockmap_listen *skel __always_unused,\n\t\t\t       int family, int sotype, int mapfd)\n{\n\tu32 key = 0;\n\tu64 value;\n\tint err, s;\n\n\ts = xsocket(family, sotype, 0);\n\tif (s == -1)\n\t\treturn;\n\n\terrno = 0;\n\tvalue = s;\n\terr = bpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\tif (sotype == SOCK_STREAM) {\n\t\tif (!err || errno != EOPNOTSUPP)\n\t\t\tFAIL_ERRNO(\"map_update: expected EOPNOTSUPP\");\n\t} else if (err)\n\t\tFAIL_ERRNO(\"map_update: expected success\");\n\txclose(s);\n}\n\nstatic void test_insert_bound(struct test_sockmap_listen *skel __always_unused,\n\t\t\t      int family, int sotype, int mapfd)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t len;\n\tu32 key = 0;\n\tu64 value;\n\tint err, s;\n\n\tinit_addr_loopback(family, &addr, &len);\n\n\ts = xsocket(family, sotype, 0);\n\tif (s == -1)\n\t\treturn;\n\n\terr = xbind(s, sockaddr(&addr), len);\n\tif (err)\n\t\tgoto close;\n\n\terrno = 0;\n\tvalue = s;\n\terr = bpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\tif (!err || errno != EOPNOTSUPP)\n\t\tFAIL_ERRNO(\"map_update: expected EOPNOTSUPP\");\nclose:\n\txclose(s);\n}\n\nstatic void test_insert(struct test_sockmap_listen *skel __always_unused,\n\t\t\tint family, int sotype, int mapfd)\n{\n\tu64 value;\n\tu32 key;\n\tint s;\n\n\ts = socket_loopback(family, sotype);\n\tif (s < 0)\n\t\treturn;\n\n\tkey = 0;\n\tvalue = s;\n\txbpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\txclose(s);\n}\n\nstatic void test_delete_after_insert(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t     int family, int sotype, int mapfd)\n{\n\tu64 value;\n\tu32 key;\n\tint s;\n\n\ts = socket_loopback(family, sotype);\n\tif (s < 0)\n\t\treturn;\n\n\tkey = 0;\n\tvalue = s;\n\txbpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\txbpf_map_delete_elem(mapfd, &key);\n\txclose(s);\n}\n\nstatic void test_delete_after_close(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t    int family, int sotype, int mapfd)\n{\n\tint err, s;\n\tu64 value;\n\tu32 key;\n\n\ts = socket_loopback(family, sotype);\n\tif (s < 0)\n\t\treturn;\n\n\tkey = 0;\n\tvalue = s;\n\txbpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\n\txclose(s);\n\n\terrno = 0;\n\terr = bpf_map_delete_elem(mapfd, &key);\n\tif (!err || (errno != EINVAL && errno != ENOENT))\n\t\t \n\t\tFAIL_ERRNO(\"map_delete: expected EINVAL/EINVAL\");\n}\n\nstatic void test_lookup_after_insert(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t     int family, int sotype, int mapfd)\n{\n\tu64 cookie, value;\n\tsocklen_t len;\n\tu32 key;\n\tint s;\n\n\ts = socket_loopback(family, sotype);\n\tif (s < 0)\n\t\treturn;\n\n\tkey = 0;\n\tvalue = s;\n\txbpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\n\tlen = sizeof(cookie);\n\txgetsockopt(s, SOL_SOCKET, SO_COOKIE, &cookie, &len);\n\n\txbpf_map_lookup_elem(mapfd, &key, &value);\n\n\tif (value != cookie) {\n\t\tFAIL(\"map_lookup: have %#llx, want %#llx\",\n\t\t     (unsigned long long)value, (unsigned long long)cookie);\n\t}\n\n\txclose(s);\n}\n\nstatic void test_lookup_after_delete(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t     int family, int sotype, int mapfd)\n{\n\tint err, s;\n\tu64 value;\n\tu32 key;\n\n\ts = socket_loopback(family, sotype);\n\tif (s < 0)\n\t\treturn;\n\n\tkey = 0;\n\tvalue = s;\n\txbpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\txbpf_map_delete_elem(mapfd, &key);\n\n\terrno = 0;\n\terr = bpf_map_lookup_elem(mapfd, &key, &value);\n\tif (!err || errno != ENOENT)\n\t\tFAIL_ERRNO(\"map_lookup: expected ENOENT\");\n\n\txclose(s);\n}\n\nstatic void test_lookup_32_bit_value(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t     int family, int sotype, int mapfd)\n{\n\tu32 key, value32;\n\tint err, s;\n\n\ts = socket_loopback(family, sotype);\n\tif (s < 0)\n\t\treturn;\n\n\tmapfd = bpf_map_create(BPF_MAP_TYPE_SOCKMAP, NULL, sizeof(key),\n\t\t\t       sizeof(value32), 1, NULL);\n\tif (mapfd < 0) {\n\t\tFAIL_ERRNO(\"map_create\");\n\t\tgoto close;\n\t}\n\n\tkey = 0;\n\tvalue32 = s;\n\txbpf_map_update_elem(mapfd, &key, &value32, BPF_NOEXIST);\n\n\terrno = 0;\n\terr = bpf_map_lookup_elem(mapfd, &key, &value32);\n\tif (!err || errno != ENOSPC)\n\t\tFAIL_ERRNO(\"map_lookup: expected ENOSPC\");\n\n\txclose(mapfd);\nclose:\n\txclose(s);\n}\n\nstatic void test_update_existing(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t int family, int sotype, int mapfd)\n{\n\tint s1, s2;\n\tu64 value;\n\tu32 key;\n\n\ts1 = socket_loopback(family, sotype);\n\tif (s1 < 0)\n\t\treturn;\n\n\ts2 = socket_loopback(family, sotype);\n\tif (s2 < 0)\n\t\tgoto close_s1;\n\n\tkey = 0;\n\tvalue = s1;\n\txbpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\n\tvalue = s2;\n\txbpf_map_update_elem(mapfd, &key, &value, BPF_EXIST);\n\txclose(s2);\nclose_s1:\n\txclose(s1);\n}\n\n \nstatic void do_destroy_orphan_child(int family, int sotype, int mapfd)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t len;\n\tint err, s, c;\n\tu64 value;\n\tu32 key;\n\n\ts = socket_loopback(family, sotype);\n\tif (s < 0)\n\t\treturn;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_srv;\n\n\tkey = 0;\n\tvalue = s;\n\txbpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\n\tc = xsocket(family, sotype, 0);\n\tif (c == -1)\n\t\tgoto close_srv;\n\n\txconnect(c, sockaddr(&addr), len);\n\txclose(c);\nclose_srv:\n\txclose(s);\n}\n\nstatic void test_destroy_orphan_child(struct test_sockmap_listen *skel,\n\t\t\t\t      int family, int sotype, int mapfd)\n{\n\tint msg_verdict = bpf_program__fd(skel->progs.prog_msg_verdict);\n\tint skb_verdict = bpf_program__fd(skel->progs.prog_skb_verdict);\n\tconst struct test {\n\t\tint progfd;\n\t\tenum bpf_attach_type atype;\n\t} tests[] = {\n\t\t{ -1, -1 },\n\t\t{ msg_verdict, BPF_SK_MSG_VERDICT },\n\t\t{ skb_verdict, BPF_SK_SKB_VERDICT },\n\t};\n\tconst struct test *t;\n\n\tfor (t = tests; t < tests + ARRAY_SIZE(tests); t++) {\n\t\tif (t->progfd != -1 &&\n\t\t    xbpf_prog_attach(t->progfd, mapfd, t->atype, 0) != 0)\n\t\t\treturn;\n\n\t\tdo_destroy_orphan_child(family, sotype, mapfd);\n\n\t\tif (t->progfd != -1)\n\t\t\txbpf_prog_detach2(t->progfd, mapfd, t->atype);\n\t}\n}\n\n \nstatic void test_clone_after_delete(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t    int family, int sotype, int mapfd)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t len;\n\tint err, s, c;\n\tu64 value;\n\tu32 key;\n\n\ts = socket_loopback(family, sotype);\n\tif (s < 0)\n\t\treturn;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_srv;\n\n\tkey = 0;\n\tvalue = s;\n\txbpf_map_update_elem(mapfd, &key, &value, BPF_NOEXIST);\n\txbpf_map_delete_elem(mapfd, &key);\n\n\tc = xsocket(family, sotype, 0);\n\tif (c < 0)\n\t\tgoto close_srv;\n\n\txconnect(c, sockaddr(&addr), len);\n\txclose(c);\nclose_srv:\n\txclose(s);\n}\n\n \nstatic void test_accept_after_delete(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t     int family, int sotype, int mapfd)\n{\n\tstruct sockaddr_storage addr;\n\tconst u32 zero = 0;\n\tint err, s, c, p;\n\tsocklen_t len;\n\tu64 value;\n\n\ts = socket_loopback(family, sotype | SOCK_NONBLOCK);\n\tif (s == -1)\n\t\treturn;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_srv;\n\n\tvalue = s;\n\terr = xbpf_map_update_elem(mapfd, &zero, &value, BPF_NOEXIST);\n\tif (err)\n\t\tgoto close_srv;\n\n\tc = xsocket(family, sotype, 0);\n\tif (c == -1)\n\t\tgoto close_srv;\n\n\t \n\terr = xconnect(c, sockaddr(&addr), len);\n\tif (err)\n\t\tgoto close_cli;\n\n\t \n\terr = xbpf_map_delete_elem(mapfd, &zero);\n\tif (err)\n\t\tgoto close_cli;\n\n\tp = xaccept_nonblock(s, NULL, NULL);\n\tif (p == -1)\n\t\tgoto close_cli;\n\n\t \n\tvalue = p;\n\txbpf_map_update_elem(mapfd, &zero, &value, BPF_NOEXIST);\n\n\txclose(p);\nclose_cli:\n\txclose(c);\nclose_srv:\n\txclose(s);\n}\n\n \nstatic void test_accept_before_delete(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t      int family, int sotype, int mapfd)\n{\n\tstruct sockaddr_storage addr;\n\tconst u32 zero = 0, one = 1;\n\tint err, s, c, p;\n\tsocklen_t len;\n\tu64 value;\n\n\ts = socket_loopback(family, sotype | SOCK_NONBLOCK);\n\tif (s == -1)\n\t\treturn;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_srv;\n\n\tvalue = s;\n\terr = xbpf_map_update_elem(mapfd, &zero, &value, BPF_NOEXIST);\n\tif (err)\n\t\tgoto close_srv;\n\n\tc = xsocket(family, sotype, 0);\n\tif (c == -1)\n\t\tgoto close_srv;\n\n\t \n\terr = xconnect(c, sockaddr(&addr), len);\n\tif (err)\n\t\tgoto close_cli;\n\n\tp = xaccept_nonblock(s, NULL, NULL);\n\tif (p == -1)\n\t\tgoto close_cli;\n\n\t \n\tvalue = p;\n\txbpf_map_update_elem(mapfd, &one, &value, BPF_NOEXIST);\n\n\txclose(p);\nclose_cli:\n\txclose(c);\nclose_srv:\n\txclose(s);\n}\n\nstruct connect_accept_ctx {\n\tint sockfd;\n\tunsigned int done;\n\tunsigned int nr_iter;\n};\n\nstatic bool is_thread_done(struct connect_accept_ctx *ctx)\n{\n\treturn READ_ONCE(ctx->done);\n}\n\nstatic void *connect_accept_thread(void *arg)\n{\n\tstruct connect_accept_ctx *ctx = arg;\n\tstruct sockaddr_storage addr;\n\tint family, socktype;\n\tsocklen_t len;\n\tint err, i, s;\n\n\ts = ctx->sockfd;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto done;\n\n\tlen = sizeof(family);\n\terr = xgetsockopt(s, SOL_SOCKET, SO_DOMAIN, &family, &len);\n\tif (err)\n\t\tgoto done;\n\n\tlen = sizeof(socktype);\n\terr = xgetsockopt(s, SOL_SOCKET, SO_TYPE, &socktype, &len);\n\tif (err)\n\t\tgoto done;\n\n\tfor (i = 0; i < ctx->nr_iter; i++) {\n\t\tint c, p;\n\n\t\tc = xsocket(family, socktype, 0);\n\t\tif (c < 0)\n\t\t\tbreak;\n\n\t\terr = xconnect(c, (struct sockaddr *)&addr, sizeof(addr));\n\t\tif (err) {\n\t\t\txclose(c);\n\t\t\tbreak;\n\t\t}\n\n\t\tp = xaccept_nonblock(s, NULL, NULL);\n\t\tif (p < 0) {\n\t\t\txclose(c);\n\t\t\tbreak;\n\t\t}\n\n\t\txclose(p);\n\t\txclose(c);\n\t}\ndone:\n\tWRITE_ONCE(ctx->done, 1);\n\treturn NULL;\n}\n\nstatic void test_syn_recv_insert_delete(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t\tint family, int sotype, int mapfd)\n{\n\tstruct connect_accept_ctx ctx = { 0 };\n\tstruct sockaddr_storage addr;\n\tsocklen_t len;\n\tu32 zero = 0;\n\tpthread_t t;\n\tint err, s;\n\tu64 value;\n\n\ts = socket_loopback(family, sotype | SOCK_NONBLOCK);\n\tif (s < 0)\n\t\treturn;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close;\n\n\tctx.sockfd = s;\n\tctx.nr_iter = 1000;\n\n\terr = xpthread_create(&t, NULL, connect_accept_thread, &ctx);\n\tif (err)\n\t\tgoto close;\n\n\tvalue = s;\n\twhile (!is_thread_done(&ctx)) {\n\t\terr = xbpf_map_update_elem(mapfd, &zero, &value, BPF_NOEXIST);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = xbpf_map_delete_elem(mapfd, &zero);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\txpthread_join(t, NULL);\nclose:\n\txclose(s);\n}\n\nstatic void *listen_thread(void *arg)\n{\n\tstruct sockaddr unspec = { AF_UNSPEC };\n\tstruct connect_accept_ctx *ctx = arg;\n\tint err, i, s;\n\n\ts = ctx->sockfd;\n\n\tfor (i = 0; i < ctx->nr_iter; i++) {\n\t\terr = xlisten(s, 1);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = xconnect(s, &unspec, sizeof(unspec));\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tWRITE_ONCE(ctx->done, 1);\n\treturn NULL;\n}\n\nstatic void test_race_insert_listen(struct test_sockmap_listen *skel __always_unused,\n\t\t\t\t    int family, int socktype, int mapfd)\n{\n\tstruct connect_accept_ctx ctx = { 0 };\n\tconst u32 zero = 0;\n\tconst int one = 1;\n\tpthread_t t;\n\tint err, s;\n\tu64 value;\n\n\ts = xsocket(family, socktype, 0);\n\tif (s < 0)\n\t\treturn;\n\n\terr = xsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));\n\tif (err)\n\t\tgoto close;\n\n\tctx.sockfd = s;\n\tctx.nr_iter = 10000;\n\n\terr = pthread_create(&t, NULL, listen_thread, &ctx);\n\tif (err)\n\t\tgoto close;\n\n\tvalue = s;\n\twhile (!is_thread_done(&ctx)) {\n\t\terr = bpf_map_update_elem(mapfd, &zero, &value, BPF_NOEXIST);\n\t\t \n\t\tif (err && errno != EOPNOTSUPP) {\n\t\t\tFAIL_ERRNO(\"map_update\");\n\t\t\tbreak;\n\t\t}\n\n\t\terr = bpf_map_delete_elem(mapfd, &zero);\n\t\t \n\t\tif (err && errno != EINVAL && errno != ENOENT) {\n\t\t\tFAIL_ERRNO(\"map_delete\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txpthread_join(t, NULL);\nclose:\n\txclose(s);\n}\n\nstatic void zero_verdict_count(int mapfd)\n{\n\tunsigned int zero = 0;\n\tint key;\n\n\tkey = SK_DROP;\n\txbpf_map_update_elem(mapfd, &key, &zero, BPF_ANY);\n\tkey = SK_PASS;\n\txbpf_map_update_elem(mapfd, &key, &zero, BPF_ANY);\n}\n\nenum redir_mode {\n\tREDIR_INGRESS,\n\tREDIR_EGRESS,\n};\n\nstatic const char *redir_mode_str(enum redir_mode mode)\n{\n\tswitch (mode) {\n\tcase REDIR_INGRESS:\n\t\treturn \"ingress\";\n\tcase REDIR_EGRESS:\n\t\treturn \"egress\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic void redir_to_connected(int family, int sotype, int sock_mapfd,\n\t\t\t       int verd_mapfd, enum redir_mode mode)\n{\n\tconst char *log_prefix = redir_mode_str(mode);\n\tint s, c0, c1, p0, p1;\n\tunsigned int pass;\n\tint err, n;\n\tu32 key;\n\tchar b;\n\n\tzero_verdict_count(verd_mapfd);\n\n\ts = socket_loopback(family, sotype | SOCK_NONBLOCK);\n\tif (s < 0)\n\t\treturn;\n\n\terr = create_socket_pairs(s, family, sotype, &c0, &c1, &p0, &p1);\n\tif (err)\n\t\tgoto close_srv;\n\n\terr = add_to_sockmap(sock_mapfd, p0, p1);\n\tif (err)\n\t\tgoto close;\n\n\tn = write(mode == REDIR_INGRESS ? c1 : p1, \"a\", 1);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: write\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete write\", log_prefix);\n\tif (n < 1)\n\t\tgoto close;\n\n\tkey = SK_PASS;\n\terr = xbpf_map_lookup_elem(verd_mapfd, &key, &pass);\n\tif (err)\n\t\tgoto close;\n\tif (pass != 1)\n\t\tFAIL(\"%s: want pass count 1, have %d\", log_prefix, pass);\n\tn = recv_timeout(c0, &b, 1, 0, IO_TIMEOUT_SEC);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: recv_timeout\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete recv\", log_prefix);\n\nclose:\n\txclose(p1);\n\txclose(c1);\n\txclose(p0);\n\txclose(c0);\nclose_srv:\n\txclose(s);\n}\n\nstatic void test_skb_redir_to_connected(struct test_sockmap_listen *skel,\n\t\t\t\t\tstruct bpf_map *inner_map, int family,\n\t\t\t\t\tint sotype)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_stream_verdict);\n\tint parser = bpf_program__fd(skel->progs.prog_stream_parser);\n\tint verdict_map = bpf_map__fd(skel->maps.verdict_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(parser, sock_map, BPF_SK_SKB_STREAM_PARSER, 0);\n\tif (err)\n\t\treturn;\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (err)\n\t\tgoto detach;\n\n\tredir_to_connected(family, sotype, sock_map, verdict_map,\n\t\t\t   REDIR_INGRESS);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_SKB_STREAM_VERDICT);\ndetach:\n\txbpf_prog_detach2(parser, sock_map, BPF_SK_SKB_STREAM_PARSER);\n}\n\nstatic void test_msg_redir_to_connected(struct test_sockmap_listen *skel,\n\t\t\t\t\tstruct bpf_map *inner_map, int family,\n\t\t\t\t\tint sotype)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_msg_verdict);\n\tint verdict_map = bpf_map__fd(skel->maps.verdict_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_MSG_VERDICT, 0);\n\tif (err)\n\t\treturn;\n\n\tredir_to_connected(family, sotype, sock_map, verdict_map, REDIR_EGRESS);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_MSG_VERDICT);\n}\n\nstatic void redir_to_listening(int family, int sotype, int sock_mapfd,\n\t\t\t       int verd_mapfd, enum redir_mode mode)\n{\n\tconst char *log_prefix = redir_mode_str(mode);\n\tstruct sockaddr_storage addr;\n\tint s, c, p, err, n;\n\tunsigned int drop;\n\tsocklen_t len;\n\tu32 key;\n\n\tzero_verdict_count(verd_mapfd);\n\n\ts = socket_loopback(family, sotype | SOCK_NONBLOCK);\n\tif (s < 0)\n\t\treturn;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_srv;\n\n\tc = xsocket(family, sotype, 0);\n\tif (c < 0)\n\t\tgoto close_srv;\n\terr = xconnect(c, sockaddr(&addr), len);\n\tif (err)\n\t\tgoto close_cli;\n\n\tp = xaccept_nonblock(s, NULL, NULL);\n\tif (p < 0)\n\t\tgoto close_cli;\n\n\terr = add_to_sockmap(sock_mapfd, s, p);\n\tif (err)\n\t\tgoto close_peer;\n\n\tn = write(mode == REDIR_INGRESS ? c : p, \"a\", 1);\n\tif (n < 0 && errno != EACCES)\n\t\tFAIL_ERRNO(\"%s: write\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete write\", log_prefix);\n\tif (n < 1)\n\t\tgoto close_peer;\n\n\tkey = SK_DROP;\n\terr = xbpf_map_lookup_elem(verd_mapfd, &key, &drop);\n\tif (err)\n\t\tgoto close_peer;\n\tif (drop != 1)\n\t\tFAIL(\"%s: want drop count 1, have %d\", log_prefix, drop);\n\nclose_peer:\n\txclose(p);\nclose_cli:\n\txclose(c);\nclose_srv:\n\txclose(s);\n}\n\nstatic void test_skb_redir_to_listening(struct test_sockmap_listen *skel,\n\t\t\t\t\tstruct bpf_map *inner_map, int family,\n\t\t\t\t\tint sotype)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_stream_verdict);\n\tint parser = bpf_program__fd(skel->progs.prog_stream_parser);\n\tint verdict_map = bpf_map__fd(skel->maps.verdict_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(parser, sock_map, BPF_SK_SKB_STREAM_PARSER, 0);\n\tif (err)\n\t\treturn;\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (err)\n\t\tgoto detach;\n\n\tredir_to_listening(family, sotype, sock_map, verdict_map,\n\t\t\t   REDIR_INGRESS);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_SKB_STREAM_VERDICT);\ndetach:\n\txbpf_prog_detach2(parser, sock_map, BPF_SK_SKB_STREAM_PARSER);\n}\n\nstatic void test_msg_redir_to_listening(struct test_sockmap_listen *skel,\n\t\t\t\t\tstruct bpf_map *inner_map, int family,\n\t\t\t\t\tint sotype)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_msg_verdict);\n\tint verdict_map = bpf_map__fd(skel->maps.verdict_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_MSG_VERDICT, 0);\n\tif (err)\n\t\treturn;\n\n\tredir_to_listening(family, sotype, sock_map, verdict_map, REDIR_EGRESS);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_MSG_VERDICT);\n}\n\nstatic void redir_partial(int family, int sotype, int sock_map, int parser_map)\n{\n\tint s, c0, c1, p0, p1;\n\tint err, n, key, value;\n\tchar buf[] = \"abc\";\n\n\tkey = 0;\n\tvalue = sizeof(buf) - 1;\n\terr = xbpf_map_update_elem(parser_map, &key, &value, 0);\n\tif (err)\n\t\treturn;\n\n\ts = socket_loopback(family, sotype | SOCK_NONBLOCK);\n\tif (s < 0)\n\t\tgoto clean_parser_map;\n\n\terr = create_socket_pairs(s, family, sotype, &c0, &c1, &p0, &p1);\n\tif (err)\n\t\tgoto close_srv;\n\n\terr = add_to_sockmap(sock_map, p0, p1);\n\tif (err)\n\t\tgoto close;\n\n\tn = xsend(c1, buf, sizeof(buf), 0);\n\tif (n < sizeof(buf))\n\t\tFAIL(\"incomplete write\");\n\n\tn = xrecv_nonblock(c0, buf, sizeof(buf), 0);\n\tif (n != sizeof(buf) - 1)\n\t\tFAIL(\"expect %zu, received %d\", sizeof(buf) - 1, n);\n\nclose:\n\txclose(c0);\n\txclose(p0);\n\txclose(c1);\n\txclose(p1);\nclose_srv:\n\txclose(s);\n\nclean_parser_map:\n\tkey = 0;\n\tvalue = 0;\n\txbpf_map_update_elem(parser_map, &key, &value, 0);\n}\n\nstatic void test_skb_redir_partial(struct test_sockmap_listen *skel,\n\t\t\t\t   struct bpf_map *inner_map, int family,\n\t\t\t\t   int sotype)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_stream_verdict);\n\tint parser = bpf_program__fd(skel->progs.prog_stream_parser);\n\tint parser_map = bpf_map__fd(skel->maps.parser_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(parser, sock_map, BPF_SK_SKB_STREAM_PARSER, 0);\n\tif (err)\n\t\treturn;\n\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (err)\n\t\tgoto detach;\n\n\tredir_partial(family, sotype, sock_map, parser_map);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_SKB_STREAM_VERDICT);\ndetach:\n\txbpf_prog_detach2(parser, sock_map, BPF_SK_SKB_STREAM_PARSER);\n}\n\nstatic void test_reuseport_select_listening(int family, int sotype,\n\t\t\t\t\t    int sock_map, int verd_map,\n\t\t\t\t\t    int reuseport_prog)\n{\n\tstruct sockaddr_storage addr;\n\tunsigned int pass;\n\tint s, c, err;\n\tsocklen_t len;\n\tu64 value;\n\tu32 key;\n\n\tzero_verdict_count(verd_map);\n\n\ts = socket_loopback_reuseport(family, sotype | SOCK_NONBLOCK,\n\t\t\t\t      reuseport_prog);\n\tif (s < 0)\n\t\treturn;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_srv;\n\n\tkey = 0;\n\tvalue = s;\n\terr = xbpf_map_update_elem(sock_map, &key, &value, BPF_NOEXIST);\n\tif (err)\n\t\tgoto close_srv;\n\n\tc = xsocket(family, sotype, 0);\n\tif (c < 0)\n\t\tgoto close_srv;\n\terr = xconnect(c, sockaddr(&addr), len);\n\tif (err)\n\t\tgoto close_cli;\n\n\tif (sotype == SOCK_STREAM) {\n\t\tint p;\n\n\t\tp = xaccept_nonblock(s, NULL, NULL);\n\t\tif (p < 0)\n\t\t\tgoto close_cli;\n\t\txclose(p);\n\t} else {\n\t\tchar b = 'a';\n\t\tssize_t n;\n\n\t\tn = xsend(c, &b, sizeof(b), 0);\n\t\tif (n == -1)\n\t\t\tgoto close_cli;\n\n\t\tn = xrecv_nonblock(s, &b, sizeof(b), 0);\n\t\tif (n == -1)\n\t\t\tgoto close_cli;\n\t}\n\n\tkey = SK_PASS;\n\terr = xbpf_map_lookup_elem(verd_map, &key, &pass);\n\tif (err)\n\t\tgoto close_cli;\n\tif (pass != 1)\n\t\tFAIL(\"want pass count 1, have %d\", pass);\n\nclose_cli:\n\txclose(c);\nclose_srv:\n\txclose(s);\n}\n\nstatic void test_reuseport_select_connected(int family, int sotype,\n\t\t\t\t\t    int sock_map, int verd_map,\n\t\t\t\t\t    int reuseport_prog)\n{\n\tstruct sockaddr_storage addr;\n\tint s, c0, c1, p0, err;\n\tunsigned int drop;\n\tsocklen_t len;\n\tu64 value;\n\tu32 key;\n\n\tzero_verdict_count(verd_map);\n\n\ts = socket_loopback_reuseport(family, sotype, reuseport_prog);\n\tif (s < 0)\n\t\treturn;\n\n\t \n\tkey = 0;\n\tvalue = s;\n\terr = xbpf_map_update_elem(sock_map, &key, &value, BPF_NOEXIST);\n\tif (err)\n\t\tgoto close_srv;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_srv;\n\n\tc0 = xsocket(family, sotype, 0);\n\tif (c0 < 0)\n\t\tgoto close_srv;\n\n\terr = xconnect(c0, sockaddr(&addr), len);\n\tif (err)\n\t\tgoto close_cli0;\n\n\tif (sotype == SOCK_STREAM) {\n\t\tp0 = xaccept_nonblock(s, NULL, NULL);\n\t\tif (p0 < 0)\n\t\t\tgoto close_cli0;\n\t} else {\n\t\tp0 = xsocket(family, sotype, 0);\n\t\tif (p0 < 0)\n\t\t\tgoto close_cli0;\n\n\t\tlen = sizeof(addr);\n\t\terr = xgetsockname(c0, sockaddr(&addr), &len);\n\t\tif (err)\n\t\t\tgoto close_cli0;\n\n\t\terr = xconnect(p0, sockaddr(&addr), len);\n\t\tif (err)\n\t\t\tgoto close_cli0;\n\t}\n\n\t \n\tkey = 0;\n\tvalue = p0;\n\terr = xbpf_map_update_elem(sock_map, &key, &value, BPF_EXIST);\n\tif (err)\n\t\tgoto close_peer0;\n\n\tc1 = xsocket(family, sotype, 0);\n\tif (c1 < 0)\n\t\tgoto close_peer0;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(s, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_srv;\n\n\terrno = 0;\n\terr = connect(c1, sockaddr(&addr), len);\n\tif (sotype == SOCK_DGRAM) {\n\t\tchar b = 'a';\n\t\tssize_t n;\n\n\t\tn = xsend(c1, &b, sizeof(b), 0);\n\t\tif (n == -1)\n\t\t\tgoto close_cli1;\n\n\t\tn = recv_timeout(c1, &b, sizeof(b), 0, IO_TIMEOUT_SEC);\n\t\terr = n == -1;\n\t}\n\tif (!err || errno != ECONNREFUSED)\n\t\tFAIL_ERRNO(\"connect: expected ECONNREFUSED\");\n\n\tkey = SK_DROP;\n\terr = xbpf_map_lookup_elem(verd_map, &key, &drop);\n\tif (err)\n\t\tgoto close_cli1;\n\tif (drop != 1)\n\t\tFAIL(\"want drop count 1, have %d\", drop);\n\nclose_cli1:\n\txclose(c1);\nclose_peer0:\n\txclose(p0);\nclose_cli0:\n\txclose(c0);\nclose_srv:\n\txclose(s);\n}\n\n \nstatic void test_reuseport_mixed_groups(int family, int sotype, int sock_map,\n\t\t\t\t\tint verd_map, int reuseport_prog)\n{\n\tstruct sockaddr_storage addr;\n\tint s1, s2, c, err;\n\tunsigned int drop;\n\tsocklen_t len;\n\tu32 key;\n\n\tzero_verdict_count(verd_map);\n\n\t \n\ts1 = socket_loopback_reuseport(family, sotype, reuseport_prog);\n\tif (s1 < 0)\n\t\treturn;\n\n\ts2 = socket_loopback_reuseport(family, sotype, reuseport_prog);\n\tif (s2 < 0)\n\t\tgoto close_srv1;\n\n\terr = add_to_sockmap(sock_map, s1, s2);\n\tif (err)\n\t\tgoto close_srv2;\n\n\t \n\tlen = sizeof(addr);\n\terr = xgetsockname(s2, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_srv2;\n\n\tc = xsocket(family, sotype, 0);\n\tif (c < 0)\n\t\tgoto close_srv2;\n\n\terr = connect(c, sockaddr(&addr), len);\n\tif (sotype == SOCK_DGRAM) {\n\t\tchar b = 'a';\n\t\tssize_t n;\n\n\t\tn = xsend(c, &b, sizeof(b), 0);\n\t\tif (n == -1)\n\t\t\tgoto close_cli;\n\n\t\tn = recv_timeout(c, &b, sizeof(b), 0, IO_TIMEOUT_SEC);\n\t\terr = n == -1;\n\t}\n\tif (!err || errno != ECONNREFUSED) {\n\t\tFAIL_ERRNO(\"connect: expected ECONNREFUSED\");\n\t\tgoto close_cli;\n\t}\n\n\t \n\tkey = SK_DROP;\n\terr = xbpf_map_lookup_elem(verd_map, &key, &drop);\n\tif (err)\n\t\tgoto close_cli;\n\tif (drop != 1)\n\t\tFAIL(\"want drop count 1, have %d\", drop);\n\nclose_cli:\n\txclose(c);\nclose_srv2:\n\txclose(s2);\nclose_srv1:\n\txclose(s1);\n}\n\n#define TEST(fn, ...)                                                          \\\n\t{                                                                      \\\n\t\tfn, #fn, __VA_ARGS__                                           \\\n\t}\n\nstatic void test_ops_cleanup(const struct bpf_map *map)\n{\n\tint err, mapfd;\n\tu32 key;\n\n\tmapfd = bpf_map__fd(map);\n\n\tfor (key = 0; key < bpf_map__max_entries(map); key++) {\n\t\terr = bpf_map_delete_elem(mapfd, &key);\n\t\tif (err && errno != EINVAL && errno != ENOENT)\n\t\t\tFAIL_ERRNO(\"map_delete: expected EINVAL/ENOENT\");\n\t}\n}\n\nstatic const char *family_str(sa_family_t family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn \"IPv4\";\n\tcase AF_INET6:\n\t\treturn \"IPv6\";\n\tcase AF_UNIX:\n\t\treturn \"Unix\";\n\tcase AF_VSOCK:\n\t\treturn \"VSOCK\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *map_type_str(const struct bpf_map *map)\n{\n\tint type;\n\n\tif (!map)\n\t\treturn \"invalid\";\n\ttype = bpf_map__type(map);\n\n\tswitch (type) {\n\tcase BPF_MAP_TYPE_SOCKMAP:\n\t\treturn \"sockmap\";\n\tcase BPF_MAP_TYPE_SOCKHASH:\n\t\treturn \"sockhash\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *sotype_str(int sotype)\n{\n\tswitch (sotype) {\n\tcase SOCK_DGRAM:\n\t\treturn \"UDP\";\n\tcase SOCK_STREAM:\n\t\treturn \"TCP\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic void test_ops(struct test_sockmap_listen *skel, struct bpf_map *map,\n\t\t     int family, int sotype)\n{\n\tconst struct op_test {\n\t\tvoid (*fn)(struct test_sockmap_listen *skel,\n\t\t\t   int family, int sotype, int mapfd);\n\t\tconst char *name;\n\t\tint sotype;\n\t} tests[] = {\n\t\t \n\t\tTEST(test_insert_invalid),\n\t\tTEST(test_insert_opened),\n\t\tTEST(test_insert_bound, SOCK_STREAM),\n\t\tTEST(test_insert),\n\t\t \n\t\tTEST(test_delete_after_insert),\n\t\tTEST(test_delete_after_close),\n\t\t \n\t\tTEST(test_lookup_after_insert),\n\t\tTEST(test_lookup_after_delete),\n\t\tTEST(test_lookup_32_bit_value),\n\t\t \n\t\tTEST(test_update_existing),\n\t\t \n\t\tTEST(test_destroy_orphan_child, SOCK_STREAM),\n\t\tTEST(test_syn_recv_insert_delete, SOCK_STREAM),\n\t\tTEST(test_race_insert_listen, SOCK_STREAM),\n\t\t \n\t\tTEST(test_clone_after_delete, SOCK_STREAM),\n\t\tTEST(test_accept_after_delete, SOCK_STREAM),\n\t\tTEST(test_accept_before_delete, SOCK_STREAM),\n\t};\n\tconst char *family_name, *map_name, *sotype_name;\n\tconst struct op_test *t;\n\tchar s[MAX_TEST_NAME];\n\tint map_fd;\n\n\tfamily_name = family_str(family);\n\tmap_name = map_type_str(map);\n\tsotype_name = sotype_str(sotype);\n\tmap_fd = bpf_map__fd(map);\n\n\tfor (t = tests; t < tests + ARRAY_SIZE(tests); t++) {\n\t\tsnprintf(s, sizeof(s), \"%s %s %s %s\", map_name, family_name,\n\t\t\t sotype_name, t->name);\n\n\t\tif (t->sotype != 0 && t->sotype != sotype)\n\t\t\tcontinue;\n\n\t\tif (!test__start_subtest(s))\n\t\t\tcontinue;\n\n\t\tt->fn(skel, family, sotype, map_fd);\n\t\ttest_ops_cleanup(map);\n\t}\n}\n\nstatic void test_redir(struct test_sockmap_listen *skel, struct bpf_map *map,\n\t\t       int family, int sotype)\n{\n\tconst struct redir_test {\n\t\tvoid (*fn)(struct test_sockmap_listen *skel,\n\t\t\t   struct bpf_map *map, int family, int sotype);\n\t\tconst char *name;\n\t} tests[] = {\n\t\tTEST(test_skb_redir_to_connected),\n\t\tTEST(test_skb_redir_to_listening),\n\t\tTEST(test_skb_redir_partial),\n\t\tTEST(test_msg_redir_to_connected),\n\t\tTEST(test_msg_redir_to_listening),\n\t};\n\tconst char *family_name, *map_name;\n\tconst struct redir_test *t;\n\tchar s[MAX_TEST_NAME];\n\n\tfamily_name = family_str(family);\n\tmap_name = map_type_str(map);\n\n\tfor (t = tests; t < tests + ARRAY_SIZE(tests); t++) {\n\t\tsnprintf(s, sizeof(s), \"%s %s %s\", map_name, family_name,\n\t\t\t t->name);\n\n\t\tif (!test__start_subtest(s))\n\t\t\tcontinue;\n\n\t\tt->fn(skel, map, family, sotype);\n\t}\n}\n\nstatic void unix_redir_to_connected(int sotype, int sock_mapfd,\n\t\t\t       int verd_mapfd, enum redir_mode mode)\n{\n\tconst char *log_prefix = redir_mode_str(mode);\n\tint c0, c1, p0, p1;\n\tunsigned int pass;\n\tint err, n;\n\tint sfd[2];\n\tu32 key;\n\tchar b;\n\n\tzero_verdict_count(verd_mapfd);\n\n\tif (socketpair(AF_UNIX, sotype | SOCK_NONBLOCK, 0, sfd))\n\t\treturn;\n\tc0 = sfd[0], p0 = sfd[1];\n\n\tif (socketpair(AF_UNIX, sotype | SOCK_NONBLOCK, 0, sfd))\n\t\tgoto close0;\n\tc1 = sfd[0], p1 = sfd[1];\n\n\terr = add_to_sockmap(sock_mapfd, p0, p1);\n\tif (err)\n\t\tgoto close;\n\n\tn = write(c1, \"a\", 1);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: write\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete write\", log_prefix);\n\tif (n < 1)\n\t\tgoto close;\n\n\tkey = SK_PASS;\n\terr = xbpf_map_lookup_elem(verd_mapfd, &key, &pass);\n\tif (err)\n\t\tgoto close;\n\tif (pass != 1)\n\t\tFAIL(\"%s: want pass count 1, have %d\", log_prefix, pass);\n\n\tn = recv_timeout(mode == REDIR_INGRESS ? p0 : c0, &b, 1, 0, IO_TIMEOUT_SEC);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: recv_timeout\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete recv\", log_prefix);\n\nclose:\n\txclose(c1);\n\txclose(p1);\nclose0:\n\txclose(c0);\n\txclose(p0);\n}\n\nstatic void unix_skb_redir_to_connected(struct test_sockmap_listen *skel,\n\t\t\t\t\tstruct bpf_map *inner_map, int sotype)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_skb_verdict);\n\tint verdict_map = bpf_map__fd(skel->maps.verdict_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_SKB_VERDICT, 0);\n\tif (err)\n\t\treturn;\n\n\tskel->bss->test_ingress = false;\n\tunix_redir_to_connected(sotype, sock_map, verdict_map, REDIR_EGRESS);\n\tskel->bss->test_ingress = true;\n\tunix_redir_to_connected(sotype, sock_map, verdict_map, REDIR_INGRESS);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_SKB_VERDICT);\n}\n\nstatic void test_unix_redir(struct test_sockmap_listen *skel, struct bpf_map *map,\n\t\t\t    int sotype)\n{\n\tconst char *family_name, *map_name;\n\tchar s[MAX_TEST_NAME];\n\n\tfamily_name = family_str(AF_UNIX);\n\tmap_name = map_type_str(map);\n\tsnprintf(s, sizeof(s), \"%s %s %s\", map_name, family_name, __func__);\n\tif (!test__start_subtest(s))\n\t\treturn;\n\tunix_skb_redir_to_connected(skel, map, sotype);\n}\n\n \nstatic int vsock_socketpair_connectible(int sotype, int *v0, int *v1)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t len = sizeof(addr);\n\tint s, p, c;\n\n\ts = socket_loopback(AF_VSOCK, sotype);\n\tif (s < 0)\n\t\treturn -1;\n\n\tc = xsocket(AF_VSOCK, sotype | SOCK_NONBLOCK, 0);\n\tif (c == -1)\n\t\tgoto close_srv;\n\n\tif (getsockname(s, sockaddr(&addr), &len) < 0)\n\t\tgoto close_cli;\n\n\tif (connect(c, sockaddr(&addr), len) < 0 && errno != EINPROGRESS) {\n\t\tFAIL_ERRNO(\"connect\");\n\t\tgoto close_cli;\n\t}\n\n\tlen = sizeof(addr);\n\tp = accept_timeout(s, sockaddr(&addr), &len, IO_TIMEOUT_SEC);\n\tif (p < 0)\n\t\tgoto close_cli;\n\n\tif (poll_connect(c, IO_TIMEOUT_SEC) < 0) {\n\t\tFAIL_ERRNO(\"poll_connect\");\n\t\tgoto close_acc;\n\t}\n\n\t*v0 = p;\n\t*v1 = c;\n\n\treturn 0;\n\nclose_acc:\n\tclose(p);\nclose_cli:\n\tclose(c);\nclose_srv:\n\tclose(s);\n\n\treturn -1;\n}\n\nstatic void vsock_unix_redir_connectible(int sock_mapfd, int verd_mapfd,\n\t\t\t\t\t enum redir_mode mode, int sotype)\n{\n\tconst char *log_prefix = redir_mode_str(mode);\n\tchar a = 'a', b = 'b';\n\tint u0, u1, v0, v1;\n\tint sfd[2];\n\tunsigned int pass;\n\tint err, n;\n\tu32 key;\n\n\tzero_verdict_count(verd_mapfd);\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0, sfd))\n\t\treturn;\n\n\tu0 = sfd[0];\n\tu1 = sfd[1];\n\n\terr = vsock_socketpair_connectible(sotype, &v0, &v1);\n\tif (err) {\n\t\tFAIL(\"vsock_socketpair_connectible() failed\");\n\t\tgoto close_uds;\n\t}\n\n\terr = add_to_sockmap(sock_mapfd, u0, v0);\n\tif (err) {\n\t\tFAIL(\"add_to_sockmap failed\");\n\t\tgoto close_vsock;\n\t}\n\n\tn = write(v1, &a, sizeof(a));\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: write\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete write\", log_prefix);\n\tif (n < 1)\n\t\tgoto out;\n\n\tn = xrecv_nonblock(mode == REDIR_INGRESS ? u0 : u1, &b, sizeof(b), 0);\n\tif (n < 0)\n\t\tFAIL(\"%s: recv() err, errno=%d\", log_prefix, errno);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete recv\", log_prefix);\n\tif (b != a)\n\t\tFAIL(\"%s: vsock socket map failed, %c != %c\", log_prefix, a, b);\n\n\tkey = SK_PASS;\n\terr = xbpf_map_lookup_elem(verd_mapfd, &key, &pass);\n\tif (err)\n\t\tgoto out;\n\tif (pass != 1)\n\t\tFAIL(\"%s: want pass count 1, have %d\", log_prefix, pass);\nout:\n\tkey = 0;\n\tbpf_map_delete_elem(sock_mapfd, &key);\n\tkey = 1;\n\tbpf_map_delete_elem(sock_mapfd, &key);\n\nclose_vsock:\n\tclose(v0);\n\tclose(v1);\n\nclose_uds:\n\tclose(u0);\n\tclose(u1);\n}\n\nstatic void vsock_unix_skb_redir_connectible(struct test_sockmap_listen *skel,\n\t\t\t\t\t     struct bpf_map *inner_map,\n\t\t\t\t\t     int sotype)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_skb_verdict);\n\tint verdict_map = bpf_map__fd(skel->maps.verdict_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_SKB_VERDICT, 0);\n\tif (err)\n\t\treturn;\n\n\tskel->bss->test_ingress = false;\n\tvsock_unix_redir_connectible(sock_map, verdict_map, REDIR_EGRESS, sotype);\n\tskel->bss->test_ingress = true;\n\tvsock_unix_redir_connectible(sock_map, verdict_map, REDIR_INGRESS, sotype);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_SKB_VERDICT);\n}\n\nstatic void test_vsock_redir(struct test_sockmap_listen *skel, struct bpf_map *map)\n{\n\tconst char *family_name, *map_name;\n\tchar s[MAX_TEST_NAME];\n\n\tfamily_name = family_str(AF_VSOCK);\n\tmap_name = map_type_str(map);\n\tsnprintf(s, sizeof(s), \"%s %s %s\", map_name, family_name, __func__);\n\tif (!test__start_subtest(s))\n\t\treturn;\n\n\tvsock_unix_skb_redir_connectible(skel, map, SOCK_STREAM);\n\tvsock_unix_skb_redir_connectible(skel, map, SOCK_SEQPACKET);\n}\n\nstatic void test_reuseport(struct test_sockmap_listen *skel,\n\t\t\t   struct bpf_map *map, int family, int sotype)\n{\n\tconst struct reuseport_test {\n\t\tvoid (*fn)(int family, int sotype, int socket_map,\n\t\t\t   int verdict_map, int reuseport_prog);\n\t\tconst char *name;\n\t\tint sotype;\n\t} tests[] = {\n\t\tTEST(test_reuseport_select_listening),\n\t\tTEST(test_reuseport_select_connected),\n\t\tTEST(test_reuseport_mixed_groups),\n\t};\n\tint socket_map, verdict_map, reuseport_prog;\n\tconst char *family_name, *map_name, *sotype_name;\n\tconst struct reuseport_test *t;\n\tchar s[MAX_TEST_NAME];\n\n\tfamily_name = family_str(family);\n\tmap_name = map_type_str(map);\n\tsotype_name = sotype_str(sotype);\n\n\tsocket_map = bpf_map__fd(map);\n\tverdict_map = bpf_map__fd(skel->maps.verdict_map);\n\treuseport_prog = bpf_program__fd(skel->progs.prog_reuseport);\n\n\tfor (t = tests; t < tests + ARRAY_SIZE(tests); t++) {\n\t\tsnprintf(s, sizeof(s), \"%s %s %s %s\", map_name, family_name,\n\t\t\t sotype_name, t->name);\n\n\t\tif (t->sotype != 0 && t->sotype != sotype)\n\t\t\tcontinue;\n\n\t\tif (!test__start_subtest(s))\n\t\t\tcontinue;\n\n\t\tt->fn(family, sotype, socket_map, verdict_map, reuseport_prog);\n\t}\n}\n\nstatic int inet_socketpair(int family, int type, int *s, int *c)\n{\n\tstruct sockaddr_storage addr;\n\tsocklen_t len;\n\tint p0, c0;\n\tint err;\n\n\tp0 = socket_loopback(family, type | SOCK_NONBLOCK);\n\tif (p0 < 0)\n\t\treturn p0;\n\n\tlen = sizeof(addr);\n\terr = xgetsockname(p0, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_peer0;\n\n\tc0 = xsocket(family, type | SOCK_NONBLOCK, 0);\n\tif (c0 < 0) {\n\t\terr = c0;\n\t\tgoto close_peer0;\n\t}\n\terr = xconnect(c0, sockaddr(&addr), len);\n\tif (err)\n\t\tgoto close_cli0;\n\terr = xgetsockname(c0, sockaddr(&addr), &len);\n\tif (err)\n\t\tgoto close_cli0;\n\terr = xconnect(p0, sockaddr(&addr), len);\n\tif (err)\n\t\tgoto close_cli0;\n\n\t*s = p0;\n\t*c = c0;\n\treturn 0;\n\nclose_cli0:\n\txclose(c0);\nclose_peer0:\n\txclose(p0);\n\treturn err;\n}\n\nstatic void udp_redir_to_connected(int family, int sock_mapfd, int verd_mapfd,\n\t\t\t\t   enum redir_mode mode)\n{\n\tconst char *log_prefix = redir_mode_str(mode);\n\tint c0, c1, p0, p1;\n\tunsigned int pass;\n\tint err, n;\n\tu32 key;\n\tchar b;\n\n\tzero_verdict_count(verd_mapfd);\n\n\terr = inet_socketpair(family, SOCK_DGRAM, &p0, &c0);\n\tif (err)\n\t\treturn;\n\terr = inet_socketpair(family, SOCK_DGRAM, &p1, &c1);\n\tif (err)\n\t\tgoto close_cli0;\n\n\terr = add_to_sockmap(sock_mapfd, p0, p1);\n\tif (err)\n\t\tgoto close_cli1;\n\n\tn = write(c1, \"a\", 1);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: write\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete write\", log_prefix);\n\tif (n < 1)\n\t\tgoto close_cli1;\n\n\tkey = SK_PASS;\n\terr = xbpf_map_lookup_elem(verd_mapfd, &key, &pass);\n\tif (err)\n\t\tgoto close_cli1;\n\tif (pass != 1)\n\t\tFAIL(\"%s: want pass count 1, have %d\", log_prefix, pass);\n\n\tn = recv_timeout(mode == REDIR_INGRESS ? p0 : c0, &b, 1, 0, IO_TIMEOUT_SEC);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: recv_timeout\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete recv\", log_prefix);\n\nclose_cli1:\n\txclose(c1);\n\txclose(p1);\nclose_cli0:\n\txclose(c0);\n\txclose(p0);\n}\n\nstatic void udp_skb_redir_to_connected(struct test_sockmap_listen *skel,\n\t\t\t\t       struct bpf_map *inner_map, int family)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_skb_verdict);\n\tint verdict_map = bpf_map__fd(skel->maps.verdict_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_SKB_VERDICT, 0);\n\tif (err)\n\t\treturn;\n\n\tskel->bss->test_ingress = false;\n\tudp_redir_to_connected(family, sock_map, verdict_map, REDIR_EGRESS);\n\tskel->bss->test_ingress = true;\n\tudp_redir_to_connected(family, sock_map, verdict_map, REDIR_INGRESS);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_SKB_VERDICT);\n}\n\nstatic void test_udp_redir(struct test_sockmap_listen *skel, struct bpf_map *map,\n\t\t\t   int family)\n{\n\tconst char *family_name, *map_name;\n\tchar s[MAX_TEST_NAME];\n\n\tfamily_name = family_str(family);\n\tmap_name = map_type_str(map);\n\tsnprintf(s, sizeof(s), \"%s %s %s\", map_name, family_name, __func__);\n\tif (!test__start_subtest(s))\n\t\treturn;\n\tudp_skb_redir_to_connected(skel, map, family);\n}\n\nstatic void inet_unix_redir_to_connected(int family, int type, int sock_mapfd,\n\t\t\t\t\tint verd_mapfd, enum redir_mode mode)\n{\n\tconst char *log_prefix = redir_mode_str(mode);\n\tint c0, c1, p0, p1;\n\tunsigned int pass;\n\tint err, n;\n\tint sfd[2];\n\tu32 key;\n\tchar b;\n\n\tzero_verdict_count(verd_mapfd);\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM | SOCK_NONBLOCK, 0, sfd))\n\t\treturn;\n\tc0 = sfd[0], p0 = sfd[1];\n\n\terr = inet_socketpair(family, SOCK_DGRAM, &p1, &c1);\n\tif (err)\n\t\tgoto close;\n\n\terr = add_to_sockmap(sock_mapfd, p0, p1);\n\tif (err)\n\t\tgoto close_cli1;\n\n\tn = write(c1, \"a\", 1);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: write\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete write\", log_prefix);\n\tif (n < 1)\n\t\tgoto close_cli1;\n\n\tkey = SK_PASS;\n\terr = xbpf_map_lookup_elem(verd_mapfd, &key, &pass);\n\tif (err)\n\t\tgoto close_cli1;\n\tif (pass != 1)\n\t\tFAIL(\"%s: want pass count 1, have %d\", log_prefix, pass);\n\n\tn = recv_timeout(mode == REDIR_INGRESS ? p0 : c0, &b, 1, 0, IO_TIMEOUT_SEC);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: recv_timeout\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete recv\", log_prefix);\n\nclose_cli1:\n\txclose(c1);\n\txclose(p1);\nclose:\n\txclose(c0);\n\txclose(p0);\n}\n\nstatic void inet_unix_skb_redir_to_connected(struct test_sockmap_listen *skel,\n\t\t\t\t\t    struct bpf_map *inner_map, int family)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_skb_verdict);\n\tint verdict_map = bpf_map__fd(skel->maps.verdict_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_SKB_VERDICT, 0);\n\tif (err)\n\t\treturn;\n\n\tskel->bss->test_ingress = false;\n\tinet_unix_redir_to_connected(family, SOCK_DGRAM, sock_map, verdict_map,\n\t\t\t\t    REDIR_EGRESS);\n\tinet_unix_redir_to_connected(family, SOCK_STREAM, sock_map, verdict_map,\n\t\t\t\t    REDIR_EGRESS);\n\tskel->bss->test_ingress = true;\n\tinet_unix_redir_to_connected(family, SOCK_DGRAM, sock_map, verdict_map,\n\t\t\t\t    REDIR_INGRESS);\n\tinet_unix_redir_to_connected(family, SOCK_STREAM, sock_map, verdict_map,\n\t\t\t\t    REDIR_INGRESS);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_SKB_VERDICT);\n}\n\nstatic void unix_inet_redir_to_connected(int family, int type, int sock_mapfd,\n\t\t\t\t\tint verd_mapfd, enum redir_mode mode)\n{\n\tconst char *log_prefix = redir_mode_str(mode);\n\tint c0, c1, p0, p1;\n\tunsigned int pass;\n\tint err, n;\n\tint sfd[2];\n\tu32 key;\n\tchar b;\n\n\tzero_verdict_count(verd_mapfd);\n\n\terr = inet_socketpair(family, SOCK_DGRAM, &p0, &c0);\n\tif (err)\n\t\treturn;\n\n\tif (socketpair(AF_UNIX, SOCK_DGRAM | SOCK_NONBLOCK, 0, sfd))\n\t\tgoto close_cli0;\n\tc1 = sfd[0], p1 = sfd[1];\n\n\terr = add_to_sockmap(sock_mapfd, p0, p1);\n\tif (err)\n\t\tgoto close;\n\n\tn = write(c1, \"a\", 1);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: write\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete write\", log_prefix);\n\tif (n < 1)\n\t\tgoto close;\n\n\tkey = SK_PASS;\n\terr = xbpf_map_lookup_elem(verd_mapfd, &key, &pass);\n\tif (err)\n\t\tgoto close;\n\tif (pass != 1)\n\t\tFAIL(\"%s: want pass count 1, have %d\", log_prefix, pass);\n\n\tn = recv_timeout(mode == REDIR_INGRESS ? p0 : c0, &b, 1, 0, IO_TIMEOUT_SEC);\n\tif (n < 0)\n\t\tFAIL_ERRNO(\"%s: recv_timeout\", log_prefix);\n\tif (n == 0)\n\t\tFAIL(\"%s: incomplete recv\", log_prefix);\n\nclose:\n\txclose(c1);\n\txclose(p1);\nclose_cli0:\n\txclose(c0);\n\txclose(p0);\n\n}\n\nstatic void unix_inet_skb_redir_to_connected(struct test_sockmap_listen *skel,\n\t\t\t\t\t    struct bpf_map *inner_map, int family)\n{\n\tint verdict = bpf_program__fd(skel->progs.prog_skb_verdict);\n\tint verdict_map = bpf_map__fd(skel->maps.verdict_map);\n\tint sock_map = bpf_map__fd(inner_map);\n\tint err;\n\n\terr = xbpf_prog_attach(verdict, sock_map, BPF_SK_SKB_VERDICT, 0);\n\tif (err)\n\t\treturn;\n\n\tskel->bss->test_ingress = false;\n\tunix_inet_redir_to_connected(family, SOCK_DGRAM, sock_map, verdict_map,\n\t\t\t\t     REDIR_EGRESS);\n\tunix_inet_redir_to_connected(family, SOCK_STREAM, sock_map, verdict_map,\n\t\t\t\t     REDIR_EGRESS);\n\tskel->bss->test_ingress = true;\n\tunix_inet_redir_to_connected(family, SOCK_DGRAM, sock_map, verdict_map,\n\t\t\t\t     REDIR_INGRESS);\n\tunix_inet_redir_to_connected(family, SOCK_STREAM, sock_map, verdict_map,\n\t\t\t\t     REDIR_INGRESS);\n\n\txbpf_prog_detach2(verdict, sock_map, BPF_SK_SKB_VERDICT);\n}\n\nstatic void test_udp_unix_redir(struct test_sockmap_listen *skel, struct bpf_map *map,\n\t\t\t\tint family)\n{\n\tconst char *family_name, *map_name;\n\tchar s[MAX_TEST_NAME];\n\n\tfamily_name = family_str(family);\n\tmap_name = map_type_str(map);\n\tsnprintf(s, sizeof(s), \"%s %s %s\", map_name, family_name, __func__);\n\tif (!test__start_subtest(s))\n\t\treturn;\n\tinet_unix_skb_redir_to_connected(skel, map, family);\n\tunix_inet_skb_redir_to_connected(skel, map, family);\n}\n\nstatic void run_tests(struct test_sockmap_listen *skel, struct bpf_map *map,\n\t\t      int family)\n{\n\ttest_ops(skel, map, family, SOCK_STREAM);\n\ttest_ops(skel, map, family, SOCK_DGRAM);\n\ttest_redir(skel, map, family, SOCK_STREAM);\n\ttest_reuseport(skel, map, family, SOCK_STREAM);\n\ttest_reuseport(skel, map, family, SOCK_DGRAM);\n\ttest_udp_redir(skel, map, family);\n\ttest_udp_unix_redir(skel, map, family);\n}\n\nvoid serial_test_sockmap_listen(void)\n{\n\tstruct test_sockmap_listen *skel;\n\n\tskel = test_sockmap_listen__open_and_load();\n\tif (!skel) {\n\t\tFAIL(\"skeleton open/load failed\");\n\t\treturn;\n\t}\n\n\tskel->bss->test_sockmap = true;\n\trun_tests(skel, skel->maps.sock_map, AF_INET);\n\trun_tests(skel, skel->maps.sock_map, AF_INET6);\n\ttest_unix_redir(skel, skel->maps.sock_map, SOCK_DGRAM);\n\ttest_unix_redir(skel, skel->maps.sock_map, SOCK_STREAM);\n\ttest_vsock_redir(skel, skel->maps.sock_map);\n\n\tskel->bss->test_sockmap = false;\n\trun_tests(skel, skel->maps.sock_hash, AF_INET);\n\trun_tests(skel, skel->maps.sock_hash, AF_INET6);\n\ttest_unix_redir(skel, skel->maps.sock_hash, SOCK_DGRAM);\n\ttest_unix_redir(skel, skel->maps.sock_hash, SOCK_STREAM);\n\ttest_vsock_redir(skel, skel->maps.sock_hash);\n\n\ttest_sockmap_listen__destroy(skel);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}