{
  "module_name": "mptcp.c",
  "hash_id": "da0638a89c16cf8f6ed8ae1007270495f7d2d0bbb701d0fdeddbbea91a76e7ae",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/prog_tests/mptcp.c",
  "human_readable_source": "\n \n \n\n#include <linux/const.h>\n#include <netinet/in.h>\n#include <test_progs.h>\n#include \"cgroup_helpers.h\"\n#include \"network_helpers.h\"\n#include \"mptcp_sock.skel.h\"\n#include \"mptcpify.skel.h\"\n\n#define NS_TEST \"mptcp_ns\"\n\n#ifndef IPPROTO_MPTCP\n#define IPPROTO_MPTCP 262\n#endif\n\n#ifndef SOL_MPTCP\n#define SOL_MPTCP 284\n#endif\n#ifndef MPTCP_INFO\n#define MPTCP_INFO\t\t1\n#endif\n#ifndef MPTCP_INFO_FLAG_FALLBACK\n#define MPTCP_INFO_FLAG_FALLBACK\t\t_BITUL(0)\n#endif\n#ifndef MPTCP_INFO_FLAG_REMOTE_KEY_RECEIVED\n#define MPTCP_INFO_FLAG_REMOTE_KEY_RECEIVED\t_BITUL(1)\n#endif\n\n#ifndef TCP_CA_NAME_MAX\n#define TCP_CA_NAME_MAX\t16\n#endif\n\nstruct __mptcp_info {\n\t__u8\tmptcpi_subflows;\n\t__u8\tmptcpi_add_addr_signal;\n\t__u8\tmptcpi_add_addr_accepted;\n\t__u8\tmptcpi_subflows_max;\n\t__u8\tmptcpi_add_addr_signal_max;\n\t__u8\tmptcpi_add_addr_accepted_max;\n\t__u32\tmptcpi_flags;\n\t__u32\tmptcpi_token;\n\t__u64\tmptcpi_write_seq;\n\t__u64\tmptcpi_snd_una;\n\t__u64\tmptcpi_rcv_nxt;\n\t__u8\tmptcpi_local_addr_used;\n\t__u8\tmptcpi_local_addr_max;\n\t__u8\tmptcpi_csum_enabled;\n\t__u32\tmptcpi_retransmits;\n\t__u64\tmptcpi_bytes_retrans;\n\t__u64\tmptcpi_bytes_sent;\n\t__u64\tmptcpi_bytes_received;\n\t__u64\tmptcpi_bytes_acked;\n};\n\nstruct mptcp_storage {\n\t__u32 invoked;\n\t__u32 is_mptcp;\n\tstruct sock *sk;\n\t__u32 token;\n\tstruct sock *first;\n\tchar ca_name[TCP_CA_NAME_MAX];\n};\n\nstatic struct nstoken *create_netns(void)\n{\n\tSYS(fail, \"ip netns add %s\", NS_TEST);\n\tSYS(fail, \"ip -net %s link set dev lo up\", NS_TEST);\n\n\treturn open_netns(NS_TEST);\nfail:\n\treturn NULL;\n}\n\nstatic void cleanup_netns(struct nstoken *nstoken)\n{\n\tif (nstoken)\n\t\tclose_netns(nstoken);\n\n\tSYS_NOFAIL(\"ip netns del %s &> /dev/null\", NS_TEST);\n}\n\nstatic int verify_tsk(int map_fd, int client_fd)\n{\n\tint err, cfd = client_fd;\n\tstruct mptcp_storage val;\n\n\terr = bpf_map_lookup_elem(map_fd, &cfd, &val);\n\tif (!ASSERT_OK(err, \"bpf_map_lookup_elem\"))\n\t\treturn err;\n\n\tif (!ASSERT_EQ(val.invoked, 1, \"unexpected invoked count\"))\n\t\terr++;\n\n\tif (!ASSERT_EQ(val.is_mptcp, 0, \"unexpected is_mptcp\"))\n\t\terr++;\n\n\treturn err;\n}\n\nstatic void get_msk_ca_name(char ca_name[])\n{\n\tsize_t len;\n\tint fd;\n\n\tfd = open(\"/proc/sys/net/ipv4/tcp_congestion_control\", O_RDONLY);\n\tif (!ASSERT_GE(fd, 0, \"failed to open tcp_congestion_control\"))\n\t\treturn;\n\n\tlen = read(fd, ca_name, TCP_CA_NAME_MAX);\n\tif (!ASSERT_GT(len, 0, \"failed to read ca_name\"))\n\t\tgoto err;\n\n\tif (len > 0 && ca_name[len - 1] == '\\n')\n\t\tca_name[len - 1] = '\\0';\n\nerr:\n\tclose(fd);\n}\n\nstatic int verify_msk(int map_fd, int client_fd, __u32 token)\n{\n\tchar ca_name[TCP_CA_NAME_MAX];\n\tint err, cfd = client_fd;\n\tstruct mptcp_storage val;\n\n\tif (!ASSERT_GT(token, 0, \"invalid token\"))\n\t\treturn -1;\n\n\tget_msk_ca_name(ca_name);\n\n\terr = bpf_map_lookup_elem(map_fd, &cfd, &val);\n\tif (!ASSERT_OK(err, \"bpf_map_lookup_elem\"))\n\t\treturn err;\n\n\tif (!ASSERT_EQ(val.invoked, 1, \"unexpected invoked count\"))\n\t\terr++;\n\n\tif (!ASSERT_EQ(val.is_mptcp, 1, \"unexpected is_mptcp\"))\n\t\terr++;\n\n\tif (!ASSERT_EQ(val.token, token, \"unexpected token\"))\n\t\terr++;\n\n\tif (!ASSERT_EQ(val.first, val.sk, \"unexpected first\"))\n\t\terr++;\n\n\tif (!ASSERT_STRNEQ(val.ca_name, ca_name, TCP_CA_NAME_MAX, \"unexpected ca_name\"))\n\t\terr++;\n\n\treturn err;\n}\n\nstatic int run_test(int cgroup_fd, int server_fd, bool is_mptcp)\n{\n\tint client_fd, prog_fd, map_fd, err;\n\tstruct mptcp_sock *sock_skel;\n\n\tsock_skel = mptcp_sock__open_and_load();\n\tif (!ASSERT_OK_PTR(sock_skel, \"skel_open_load\"))\n\t\treturn libbpf_get_error(sock_skel);\n\n\terr = mptcp_sock__attach(sock_skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto out;\n\n\tprog_fd = bpf_program__fd(sock_skel->progs._sockops);\n\tmap_fd = bpf_map__fd(sock_skel->maps.socket_storage_map);\n\terr = bpf_prog_attach(prog_fd, cgroup_fd, BPF_CGROUP_SOCK_OPS, 0);\n\tif (!ASSERT_OK(err, \"bpf_prog_attach\"))\n\t\tgoto out;\n\n\tclient_fd = connect_to_fd(server_fd, 0);\n\tif (!ASSERT_GE(client_fd, 0, \"connect to fd\")) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\terr += is_mptcp ? verify_msk(map_fd, client_fd, sock_skel->bss->token) :\n\t\t\t  verify_tsk(map_fd, client_fd);\n\n\tclose(client_fd);\n\nout:\n\tmptcp_sock__destroy(sock_skel);\n\treturn err;\n}\n\nstatic void test_base(void)\n{\n\tstruct nstoken *nstoken = NULL;\n\tint server_fd, cgroup_fd;\n\n\tcgroup_fd = test__join_cgroup(\"/mptcp\");\n\tif (!ASSERT_GE(cgroup_fd, 0, \"test__join_cgroup\"))\n\t\treturn;\n\n\tnstoken = create_netns();\n\tif (!ASSERT_OK_PTR(nstoken, \"create_netns\"))\n\t\tgoto fail;\n\n\t \n\tserver_fd = start_server(AF_INET, SOCK_STREAM, NULL, 0, 0);\n\tif (!ASSERT_GE(server_fd, 0, \"start_server\"))\n\t\tgoto with_mptcp;\n\n\tASSERT_OK(run_test(cgroup_fd, server_fd, false), \"run_test tcp\");\n\n\tclose(server_fd);\n\nwith_mptcp:\n\t \n\tserver_fd = start_mptcp_server(AF_INET, NULL, 0, 0);\n\tif (!ASSERT_GE(server_fd, 0, \"start_mptcp_server\"))\n\t\tgoto fail;\n\n\tASSERT_OK(run_test(cgroup_fd, server_fd, true), \"run_test mptcp\");\n\n\tclose(server_fd);\n\nfail:\n\tcleanup_netns(nstoken);\n\tclose(cgroup_fd);\n}\n\nstatic void send_byte(int fd)\n{\n\tchar b = 0x55;\n\n\tASSERT_EQ(write(fd, &b, sizeof(b)), 1, \"send single byte\");\n}\n\nstatic int verify_mptcpify(int server_fd, int client_fd)\n{\n\tstruct __mptcp_info info;\n\tsocklen_t optlen;\n\tint protocol;\n\tint err = 0;\n\n\toptlen = sizeof(protocol);\n\tif (!ASSERT_OK(getsockopt(server_fd, SOL_SOCKET, SO_PROTOCOL, &protocol, &optlen),\n\t\t       \"getsockopt(SOL_PROTOCOL)\"))\n\t\treturn -1;\n\n\tif (!ASSERT_EQ(protocol, IPPROTO_MPTCP, \"protocol isn't MPTCP\"))\n\t\terr++;\n\n\toptlen = sizeof(info);\n\tif (!ASSERT_OK(getsockopt(client_fd, SOL_MPTCP, MPTCP_INFO, &info, &optlen),\n\t\t       \"getsockopt(MPTCP_INFO)\"))\n\t\treturn -1;\n\n\tif (!ASSERT_GE(info.mptcpi_flags, 0, \"unexpected mptcpi_flags\"))\n\t\terr++;\n\tif (!ASSERT_FALSE(info.mptcpi_flags & MPTCP_INFO_FLAG_FALLBACK,\n\t\t\t  \"MPTCP fallback\"))\n\t\terr++;\n\tif (!ASSERT_TRUE(info.mptcpi_flags & MPTCP_INFO_FLAG_REMOTE_KEY_RECEIVED,\n\t\t\t \"no remote key received\"))\n\t\terr++;\n\n\treturn err;\n}\n\nstatic int run_mptcpify(int cgroup_fd)\n{\n\tint server_fd, client_fd, err = 0;\n\tstruct mptcpify *mptcpify_skel;\n\n\tmptcpify_skel = mptcpify__open_and_load();\n\tif (!ASSERT_OK_PTR(mptcpify_skel, \"skel_open_load\"))\n\t\treturn libbpf_get_error(mptcpify_skel);\n\n\terr = mptcpify__attach(mptcpify_skel);\n\tif (!ASSERT_OK(err, \"skel_attach\"))\n\t\tgoto out;\n\n\t \n\tserver_fd = start_server(AF_INET, SOCK_STREAM, NULL, 0, 0);\n\tif (!ASSERT_GE(server_fd, 0, \"start_server\")) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tclient_fd = connect_to_fd(server_fd, 0);\n\tif (!ASSERT_GE(client_fd, 0, \"connect to fd\")) {\n\t\terr = -EIO;\n\t\tgoto close_server;\n\t}\n\n\tsend_byte(client_fd);\n\n\terr = verify_mptcpify(server_fd, client_fd);\n\n\tclose(client_fd);\nclose_server:\n\tclose(server_fd);\nout:\n\tmptcpify__destroy(mptcpify_skel);\n\treturn err;\n}\n\nstatic void test_mptcpify(void)\n{\n\tstruct nstoken *nstoken = NULL;\n\tint cgroup_fd;\n\n\tcgroup_fd = test__join_cgroup(\"/mptcpify\");\n\tif (!ASSERT_GE(cgroup_fd, 0, \"test__join_cgroup\"))\n\t\treturn;\n\n\tnstoken = create_netns();\n\tif (!ASSERT_OK_PTR(nstoken, \"create_netns\"))\n\t\tgoto fail;\n\n\tASSERT_OK(run_mptcpify(cgroup_fd), \"run_mptcpify\");\n\nfail:\n\tcleanup_netns(nstoken);\n\tclose(cgroup_fd);\n}\n\nvoid test_mptcp(void)\n{\n\tif (test__start_subtest(\"base\"))\n\t\ttest_base();\n\tif (test__start_subtest(\"mptcpify\"))\n\t\ttest_mptcpify();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}