{
  "module_name": "test_progs.h",
  "hash_id": "b6aded3258832277099393d7273d4bdfb13c2aef67fb5dc333224a5dbbc2abc8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_progs.h",
  "human_readable_source": " \n#ifndef __TEST_PROGS_H\n#define __TEST_PROGS_H\n\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <time.h>\n#include <signal.h>\n\n#include <linux/types.h>\ntypedef __u16 __sum16;\n#include <arpa/inet.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/filter.h>\n#include <linux/perf_event.h>\n#include <linux/socket.h>\n#include <linux/unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <linux/bpf.h>\n#include <linux/err.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"test_iptunnel_common.h\"\n#include \"bpf_util.h\"\n#include <bpf/bpf_endian.h>\n#include \"trace_helpers.h\"\n#include \"testing_helpers.h\"\n\nenum verbosity {\n\tVERBOSE_NONE,\n\tVERBOSE_NORMAL,\n\tVERBOSE_VERY,\n\tVERBOSE_SUPER,\n};\n\nstruct test_filter {\n\tchar *name;\n\tchar **subtests;\n\tint subtest_cnt;\n};\n\nstruct test_filter_set {\n\tstruct test_filter *tests;\n\tint cnt;\n};\n\nstruct test_selector {\n\tstruct test_filter_set whitelist;\n\tstruct test_filter_set blacklist;\n\tbool *num_set;\n\tint num_set_len;\n};\n\nstruct subtest_state {\n\tchar *name;\n\tsize_t log_cnt;\n\tchar *log_buf;\n\tint error_cnt;\n\tbool skipped;\n\tbool filtered;\n\n\tFILE *stdout;\n};\n\nstruct test_state {\n\tbool tested;\n\tbool force_log;\n\n\tint error_cnt;\n\tint skip_cnt;\n\tint sub_succ_cnt;\n\n\tstruct subtest_state *subtest_states;\n\tint subtest_num;\n\n\tsize_t log_cnt;\n\tchar *log_buf;\n\n\tFILE *stdout;\n};\n\nstruct test_env {\n\tstruct test_selector test_selector;\n\tstruct test_selector subtest_selector;\n\tbool verifier_stats;\n\tbool debug;\n\tenum verbosity verbosity;\n\n\tbool jit_enabled;\n\tbool has_testmod;\n\tbool get_test_cnt;\n\tbool list_test_names;\n\n\tstruct prog_test_def *test;  \n\tstruct test_state *test_state;  \n\tstruct subtest_state *subtest_state;  \n\n\tFILE *stdout;\n\tFILE *stderr;\n\tint nr_cpus;\n\tFILE *json;\n\n\tint succ_cnt;  \n\tint sub_succ_cnt;  \n\tint fail_cnt;  \n\tint skip_cnt;  \n\n\tint saved_netns_fd;\n\tint workers;  \n\tint worker_id;  \n\tpid_t *worker_pids;  \n\tint *worker_socks;  \n\tint *worker_current_test;  \n};\n\n#define MAX_LOG_TRUNK_SIZE 8192\n#define MAX_SUBTEST_NAME 1024\nenum msg_type {\n\tMSG_DO_TEST = 0,\n\tMSG_TEST_DONE = 1,\n\tMSG_TEST_LOG = 2,\n\tMSG_SUBTEST_DONE = 3,\n\tMSG_EXIT = 255,\n};\nstruct msg {\n\tenum msg_type type;\n\tunion {\n\t\tstruct {\n\t\t\tint num;\n\t\t} do_test;\n\t\tstruct {\n\t\t\tint num;\n\t\t\tint sub_succ_cnt;\n\t\t\tint error_cnt;\n\t\t\tint skip_cnt;\n\t\t\tbool have_log;\n\t\t\tint subtest_num;\n\t\t} test_done;\n\t\tstruct {\n\t\t\tchar log_buf[MAX_LOG_TRUNK_SIZE + 1];\n\t\t\tbool is_last;\n\t\t} test_log;\n\t\tstruct {\n\t\t\tint num;\n\t\t\tchar name[MAX_SUBTEST_NAME + 1];\n\t\t\tint error_cnt;\n\t\t\tbool skipped;\n\t\t\tbool filtered;\n\t\t\tbool have_log;\n\t\t} subtest_done;\n\t};\n};\n\nextern struct test_env env;\n\nvoid test__force_log(void);\nbool test__start_subtest(const char *name);\nvoid test__end_subtest(void);\nvoid test__skip(void);\nvoid test__fail(void);\nint test__join_cgroup(const char *path);\n\n#define PRINT_FAIL(format...)                                                  \\\n\t({                                                                     \\\n\t\ttest__fail();                                                  \\\n\t\tfprintf(stdout, \"%s:FAIL:%d \", __func__, __LINE__);            \\\n\t\tfprintf(stdout, ##format);                                     \\\n\t})\n\n#define _CHECK(condition, tag, duration, format...) ({\t\t\t\\\n\tint __ret = !!(condition);\t\t\t\t\t\\\n\tint __save_errno = errno;\t\t\t\t\t\\\n\tif (__ret) {\t\t\t\t\t\t\t\\\n\t\ttest__fail();\t\t\t\t\t\t\\\n\t\tfprintf(stdout, \"%s:FAIL:%s \", __func__, tag);\t\t\\\n\t\tfprintf(stdout, ##format);\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tfprintf(stdout, \"%s:PASS:%s %d nsec\\n\",\t\t\t\\\n\t\t       __func__, tag, duration);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\terrno = __save_errno;\t\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define CHECK_FAIL(condition) ({\t\t\t\t\t\\\n\tint __ret = !!(condition);\t\t\t\t\t\\\n\tint __save_errno = errno;\t\t\t\t\t\\\n\tif (__ret) {\t\t\t\t\t\t\t\\\n\t\ttest__fail();\t\t\t\t\t\t\\\n\t\tfprintf(stdout, \"%s:FAIL:%d\\n\", __func__, __LINE__);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\terrno = __save_errno;\t\t\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define CHECK(condition, tag, format...) \\\n\t_CHECK(condition, tag, duration, format)\n#define CHECK_ATTR(condition, tag, format...) \\\n\t_CHECK(condition, tag, tattr.duration, format)\n\n#define ASSERT_FAIL(fmt, args...) ({\t\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tCHECK(false, \"\", fmt\"\\n\", ##args);\t\t\t\t\\\n\tfalse;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_TRUE(actual, name) ({\t\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tbool ___ok = (actual);\t\t\t\t\t\t\\\n\tCHECK(!___ok, (name), \"unexpected %s: got FALSE\\n\", (name));\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_FALSE(actual, name) ({\t\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tbool ___ok = !(actual);\t\t\t\t\t\t\\\n\tCHECK(!___ok, (name), \"unexpected %s: got TRUE\\n\", (name));\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_EQ(actual, expected, name) ({\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\ttypeof(actual) ___act = (actual);\t\t\t\t\\\n\ttypeof(expected) ___exp = (expected);\t\t\t\t\\\n\tbool ___ok = ___act == ___exp;\t\t\t\t\t\\\n\tCHECK(!___ok, (name),\t\t\t\t\t\t\\\n\t      \"unexpected %s: actual %lld != expected %lld\\n\",\t\t\\\n\t      (name), (long long)(___act), (long long)(___exp));\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_NEQ(actual, expected, name) ({\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\ttypeof(actual) ___act = (actual);\t\t\t\t\\\n\ttypeof(expected) ___exp = (expected);\t\t\t\t\\\n\tbool ___ok = ___act != ___exp;\t\t\t\t\t\\\n\tCHECK(!___ok, (name),\t\t\t\t\t\t\\\n\t      \"unexpected %s: actual %lld == expected %lld\\n\",\t\t\\\n\t      (name), (long long)(___act), (long long)(___exp));\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_LT(actual, expected, name) ({\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\ttypeof(actual) ___act = (actual);\t\t\t\t\\\n\ttypeof(expected) ___exp = (expected);\t\t\t\t\\\n\tbool ___ok = ___act < ___exp;\t\t\t\t\t\\\n\tCHECK(!___ok, (name),\t\t\t\t\t\t\\\n\t      \"unexpected %s: actual %lld >= expected %lld\\n\",\t\t\\\n\t      (name), (long long)(___act), (long long)(___exp));\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_LE(actual, expected, name) ({\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\ttypeof(actual) ___act = (actual);\t\t\t\t\\\n\ttypeof(expected) ___exp = (expected);\t\t\t\t\\\n\tbool ___ok = ___act <= ___exp;\t\t\t\t\t\\\n\tCHECK(!___ok, (name),\t\t\t\t\t\t\\\n\t      \"unexpected %s: actual %lld > expected %lld\\n\",\t\t\\\n\t      (name), (long long)(___act), (long long)(___exp));\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_GT(actual, expected, name) ({\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\ttypeof(actual) ___act = (actual);\t\t\t\t\\\n\ttypeof(expected) ___exp = (expected);\t\t\t\t\\\n\tbool ___ok = ___act > ___exp;\t\t\t\t\t\\\n\tCHECK(!___ok, (name),\t\t\t\t\t\t\\\n\t      \"unexpected %s: actual %lld <= expected %lld\\n\",\t\t\\\n\t      (name), (long long)(___act), (long long)(___exp));\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_GE(actual, expected, name) ({\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\ttypeof(actual) ___act = (actual);\t\t\t\t\\\n\ttypeof(expected) ___exp = (expected);\t\t\t\t\\\n\tbool ___ok = ___act >= ___exp;\t\t\t\t\t\\\n\tCHECK(!___ok, (name),\t\t\t\t\t\t\\\n\t      \"unexpected %s: actual %lld < expected %lld\\n\",\t\t\\\n\t      (name), (long long)(___act), (long long)(___exp));\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_STREQ(actual, expected, name) ({\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tconst char *___act = actual;\t\t\t\t\t\\\n\tconst char *___exp = expected;\t\t\t\t\t\\\n\tbool ___ok = strcmp(___act, ___exp) == 0;\t\t\t\\\n\tCHECK(!___ok, (name),\t\t\t\t\t\t\\\n\t      \"unexpected %s: actual '%s' != expected '%s'\\n\",\t\t\\\n\t      (name), ___act, ___exp);\t\t\t\t\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_STRNEQ(actual, expected, len, name) ({\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tconst char *___act = actual;\t\t\t\t\t\\\n\tconst char *___exp = expected;\t\t\t\t\t\\\n\tint ___len = len;\t\t\t\t\t\t\\\n\tbool ___ok = strncmp(___act, ___exp, ___len) == 0;\t\t\\\n\tCHECK(!___ok, (name),\t\t\t\t\t\t\\\n\t      \"unexpected %s: actual '%.*s' != expected '%.*s'\\n\",\t\\\n\t      (name), ___len, ___act, ___len, ___exp);\t\t\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_HAS_SUBSTR(str, substr, name) ({\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tconst char *___str = str;\t\t\t\t\t\\\n\tconst char *___substr = substr;\t\t\t\t\t\\\n\tbool ___ok = strstr(___str, ___substr) != NULL;\t\t\t\\\n\tCHECK(!___ok, (name),\t\t\t\t\t\t\\\n\t      \"unexpected %s: '%s' is not a substring of '%s'\\n\",\t\\\n\t      (name), ___substr, ___str);\t\t\t\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_OK(res, name) ({\t\t\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tlong long ___res = (res);\t\t\t\t\t\\\n\tbool ___ok = ___res == 0;\t\t\t\t\t\\\n\tCHECK(!___ok, (name), \"unexpected error: %lld (errno %d)\\n\",\t\\\n\t      ___res, errno);\t\t\t\t\t\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_ERR(res, name) ({\t\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tlong long ___res = (res);\t\t\t\t\t\\\n\tbool ___ok = ___res < 0;\t\t\t\t\t\\\n\tCHECK(!___ok, (name), \"unexpected success: %lld\\n\", ___res);\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_NULL(ptr, name) ({\t\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tconst void *___res = (ptr);\t\t\t\t\t\\\n\tbool ___ok = !___res;\t\t\t\t\t\t\\\n\tCHECK(!___ok, (name), \"unexpected pointer: %p\\n\", ___res);\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_OK_PTR(ptr, name) ({\t\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tconst void *___res = (ptr);\t\t\t\t\t\\\n\tint ___err = libbpf_get_error(___res);\t\t\t\t\\\n\tbool ___ok = ___err == 0;\t\t\t\t\t\\\n\tCHECK(!___ok, (name), \"unexpected error: %d\\n\", ___err);\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define ASSERT_ERR_PTR(ptr, name) ({\t\t\t\t\t\\\n\tstatic int duration = 0;\t\t\t\t\t\\\n\tconst void *___res = (ptr);\t\t\t\t\t\\\n\tint ___err = libbpf_get_error(___res);\t\t\t\t\\\n\tbool ___ok = ___err != 0;\t\t\t\t\t\\\n\tCHECK(!___ok, (name), \"unexpected pointer: %p\\n\", ___res);\t\\\n\t___ok;\t\t\t\t\t\t\t\t\\\n})\n\n#define SYS(goto_label, fmt, ...)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tchar cmd[1024];\t\t\t\t\t\t\\\n\t\tsnprintf(cmd, sizeof(cmd), fmt, ##__VA_ARGS__);\t\t\\\n\t\tif (!ASSERT_OK(system(cmd), cmd))\t\t\t\\\n\t\t\tgoto goto_label;\t\t\t\t\\\n\t})\n\n#define SYS_NOFAIL(fmt, ...)\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tchar cmd[1024];\t\t\t\t\t\t\\\n\t\tsnprintf(cmd, sizeof(cmd), fmt, ##__VA_ARGS__);\t\t\\\n\t\tsystem(cmd);\t\t\t\t\t\t\\\n\t})\n\nstatic inline __u64 ptr_to_u64(const void *ptr)\n{\n\treturn (__u64) (unsigned long) ptr;\n}\n\nstatic inline void *u64_to_ptr(__u64 ptr)\n{\n\treturn (void *) (unsigned long) ptr;\n}\n\nint bpf_find_map(const char *test, struct bpf_object *obj, const char *name);\nint compare_map_keys(int map1_fd, int map2_fd);\nint compare_stack_ips(int smap_fd, int amap_fd, int stack_trace_len);\nint trigger_module_test_read(int read_sz);\nint trigger_module_test_write(int write_sz);\nint write_sysctl(const char *sysctl, const char *value);\nint get_bpf_max_tramp_links_from(struct btf *btf);\nint get_bpf_max_tramp_links(void);\n\n#ifdef __x86_64__\n#define SYS_NANOSLEEP_KPROBE_NAME \"__x64_sys_nanosleep\"\n#elif defined(__s390x__)\n#define SYS_NANOSLEEP_KPROBE_NAME \"__s390x_sys_nanosleep\"\n#elif defined(__aarch64__)\n#define SYS_NANOSLEEP_KPROBE_NAME \"__arm64_sys_nanosleep\"\n#elif defined(__riscv)\n#define SYS_NANOSLEEP_KPROBE_NAME \"__riscv_sys_nanosleep\"\n#else\n#define SYS_NANOSLEEP_KPROBE_NAME \"sys_nanosleep\"\n#endif\n\n#define BPF_TESTMOD_TEST_FILE \"/sys/kernel/bpf_testmod\"\n\ntypedef int (*pre_execution_cb)(struct bpf_object *obj);\n\nstruct test_loader {\n\tchar *log_buf;\n\tsize_t log_buf_sz;\n\tsize_t next_match_pos;\n\tpre_execution_cb pre_execution_cb;\n\n\tstruct bpf_object *obj;\n};\n\nstatic inline void test_loader__set_pre_execution_cb(struct test_loader *tester,\n\t\t\t\t\t\t     pre_execution_cb cb)\n{\n\ttester->pre_execution_cb = cb;\n}\n\ntypedef const void *(*skel_elf_bytes_fn)(size_t *sz);\n\nextern void test_loader__run_subtests(struct test_loader *tester,\n\t\t\t\t      const char *skel_name,\n\t\t\t\t      skel_elf_bytes_fn elf_bytes_factory);\n\nextern void test_loader_fini(struct test_loader *tester);\n\n#define RUN_TESTS(skel) ({\t\t\t\t\t\t       \\\n\tstruct test_loader tester = {};\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\ttest_loader__run_subtests(&tester, #skel, skel##__elf_bytes);\t       \\\n\ttest_loader_fini(&tester);\t\t\t\t\t       \\\n})\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}