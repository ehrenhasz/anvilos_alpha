{
  "module_name": "test_lpm_map.c",
  "hash_id": "a85bccf0f19dc0d3b44d928492ec01db10ae8dc1cd40dfe4fed4114dc190ad10",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_lpm_map.c",
  "human_readable_source": "\n \n\n#include <assert.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <linux/bpf.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n\n#include <bpf/bpf.h>\n\n#include \"bpf_util.h\"\n\nstruct tlpm_node {\n\tstruct tlpm_node *next;\n\tsize_t n_bits;\n\tuint8_t key[];\n};\n\nstatic struct tlpm_node *tlpm_match(struct tlpm_node *list,\n\t\t\t\t    const uint8_t *key,\n\t\t\t\t    size_t n_bits);\n\nstatic struct tlpm_node *tlpm_add(struct tlpm_node *list,\n\t\t\t\t  const uint8_t *key,\n\t\t\t\t  size_t n_bits)\n{\n\tstruct tlpm_node *node;\n\tsize_t n;\n\n\tn = (n_bits + 7) / 8;\n\n\t \n\tnode = tlpm_match(list, key, n_bits);\n\tif (node && node->n_bits == n_bits) {\n\t\tmemcpy(node->key, key, n);\n\t\treturn list;\n\t}\n\n\t \n\n\tnode = malloc(sizeof(*node) + n);\n\tassert(node);\n\n\tnode->next = list;\n\tnode->n_bits = n_bits;\n\tmemcpy(node->key, key, n);\n\n\treturn node;\n}\n\nstatic void tlpm_clear(struct tlpm_node *list)\n{\n\tstruct tlpm_node *node;\n\n\t \n\n\twhile ((node = list)) {\n\t\tlist = list->next;\n\t\tfree(node);\n\t}\n}\n\nstatic struct tlpm_node *tlpm_match(struct tlpm_node *list,\n\t\t\t\t    const uint8_t *key,\n\t\t\t\t    size_t n_bits)\n{\n\tstruct tlpm_node *best = NULL;\n\tsize_t i;\n\n\t \n\n\tfor ( ; list; list = list->next) {\n\t\tfor (i = 0; i < n_bits && i < list->n_bits; ++i) {\n\t\t\tif ((key[i / 8] & (1 << (7 - i % 8))) !=\n\t\t\t    (list->key[i / 8] & (1 << (7 - i % 8))))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= list->n_bits) {\n\t\t\tif (!best || i > best->n_bits)\n\t\t\t\tbest = list;\n\t\t}\n\t}\n\n\treturn best;\n}\n\nstatic struct tlpm_node *tlpm_delete(struct tlpm_node *list,\n\t\t\t\t     const uint8_t *key,\n\t\t\t\t     size_t n_bits)\n{\n\tstruct tlpm_node *best = tlpm_match(list, key, n_bits);\n\tstruct tlpm_node *node;\n\n\tif (!best || best->n_bits != n_bits)\n\t\treturn list;\n\n\tif (best == list) {\n\t\tnode = best->next;\n\t\tfree(best);\n\t\treturn node;\n\t}\n\n\tfor (node = list; node; node = node->next) {\n\t\tif (node->next == best) {\n\t\t\tnode->next = best->next;\n\t\t\tfree(best);\n\t\t\treturn list;\n\t\t}\n\t}\n\t \n\tassert(0);\n\treturn list;\n}\n\nstatic void test_lpm_basic(void)\n{\n\tstruct tlpm_node *list = NULL, *t1, *t2;\n\n\t \n\n\tassert(!tlpm_match(list, (uint8_t[]){ 0xff }, 8));\n\n\tt1 = list = tlpm_add(list, (uint8_t[]){ 0xff }, 8);\n\tassert(t1 == tlpm_match(list, (uint8_t[]){ 0xff }, 8));\n\tassert(t1 == tlpm_match(list, (uint8_t[]){ 0xff, 0xff }, 16));\n\tassert(t1 == tlpm_match(list, (uint8_t[]){ 0xff, 0x00 }, 16));\n\tassert(!tlpm_match(list, (uint8_t[]){ 0x7f }, 8));\n\tassert(!tlpm_match(list, (uint8_t[]){ 0xfe }, 8));\n\tassert(!tlpm_match(list, (uint8_t[]){ 0xff }, 7));\n\n\tt2 = list = tlpm_add(list, (uint8_t[]){ 0xff, 0xff }, 16);\n\tassert(t1 == tlpm_match(list, (uint8_t[]){ 0xff }, 8));\n\tassert(t2 == tlpm_match(list, (uint8_t[]){ 0xff, 0xff }, 16));\n\tassert(t1 == tlpm_match(list, (uint8_t[]){ 0xff, 0xff }, 15));\n\tassert(!tlpm_match(list, (uint8_t[]){ 0x7f, 0xff }, 16));\n\n\tlist = tlpm_delete(list, (uint8_t[]){ 0xff, 0xff }, 16);\n\tassert(t1 == tlpm_match(list, (uint8_t[]){ 0xff }, 8));\n\tassert(t1 == tlpm_match(list, (uint8_t[]){ 0xff, 0xff }, 16));\n\n\tlist = tlpm_delete(list, (uint8_t[]){ 0xff }, 8);\n\tassert(!tlpm_match(list, (uint8_t[]){ 0xff }, 8));\n\n\ttlpm_clear(list);\n}\n\nstatic void test_lpm_order(void)\n{\n\tstruct tlpm_node *t1, *t2, *l1 = NULL, *l2 = NULL;\n\tsize_t i, j;\n\n\t \n\n\tfor (i = 0; i < (1 << 12); ++i)\n\t\tl1 = tlpm_add(l1, (uint8_t[]){\n\t\t\t\t\trand() % 0xff,\n\t\t\t\t\trand() % 0xff,\n\t\t\t\t}, rand() % 16 + 1);\n\n\tfor (t1 = l1; t1; t1 = t1->next)\n\t\tl2 = tlpm_add(l2, t1->key, t1->n_bits);\n\n\tfor (i = 0; i < (1 << 8); ++i) {\n\t\tuint8_t key[] = { rand() % 0xff, rand() % 0xff };\n\n\t\tt1 = tlpm_match(l1, key, 16);\n\t\tt2 = tlpm_match(l2, key, 16);\n\n\t\tassert(!t1 == !t2);\n\t\tif (t1) {\n\t\t\tassert(t1->n_bits == t2->n_bits);\n\t\t\tfor (j = 0; j < t1->n_bits; ++j)\n\t\t\t\tassert((t1->key[j / 8] & (1 << (7 - j % 8))) ==\n\t\t\t\t       (t2->key[j / 8] & (1 << (7 - j % 8))));\n\t\t}\n\t}\n\n\ttlpm_clear(l1);\n\ttlpm_clear(l2);\n}\n\nstatic void test_lpm_map(int keysize)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts, .map_flags = BPF_F_NO_PREALLOC);\n\tvolatile size_t n_matches, n_matches_after_delete;\n\tsize_t i, j, n_nodes, n_lookups;\n\tstruct tlpm_node *t, *list = NULL;\n\tstruct bpf_lpm_trie_key *key;\n\tuint8_t *data, *value;\n\tint r, map;\n\n\t \n\n\tn_matches = 0;\n\tn_matches_after_delete = 0;\n\tn_nodes = 1 << 8;\n\tn_lookups = 1 << 16;\n\n\tdata = alloca(keysize);\n\tmemset(data, 0, keysize);\n\n\tvalue = alloca(keysize + 1);\n\tmemset(value, 0, keysize + 1);\n\n\tkey = alloca(sizeof(*key) + keysize);\n\tmemset(key, 0, sizeof(*key) + keysize);\n\n\tmap = bpf_map_create(BPF_MAP_TYPE_LPM_TRIE, NULL,\n\t\t\t     sizeof(*key) + keysize,\n\t\t\t     keysize + 1,\n\t\t\t     4096,\n\t\t\t     &opts);\n\tassert(map >= 0);\n\n\tfor (i = 0; i < n_nodes; ++i) {\n\t\tfor (j = 0; j < keysize; ++j)\n\t\t\tvalue[j] = rand() & 0xff;\n\t\tvalue[keysize] = rand() % (8 * keysize + 1);\n\n\t\tlist = tlpm_add(list, value, value[keysize]);\n\n\t\tkey->prefixlen = value[keysize];\n\t\tmemcpy(key->data, value, keysize);\n\t\tr = bpf_map_update_elem(map, key, value, 0);\n\t\tassert(!r);\n\t}\n\n\tfor (i = 0; i < n_lookups; ++i) {\n\t\tfor (j = 0; j < keysize; ++j)\n\t\t\tdata[j] = rand() & 0xff;\n\n\t\tt = tlpm_match(list, data, 8 * keysize);\n\n\t\tkey->prefixlen = 8 * keysize;\n\t\tmemcpy(key->data, data, keysize);\n\t\tr = bpf_map_lookup_elem(map, key, value);\n\t\tassert(!r || errno == ENOENT);\n\t\tassert(!t == !!r);\n\n\t\tif (t) {\n\t\t\t++n_matches;\n\t\t\tassert(t->n_bits == value[keysize]);\n\t\t\tfor (j = 0; j < t->n_bits; ++j)\n\t\t\t\tassert((t->key[j / 8] & (1 << (7 - j % 8))) ==\n\t\t\t\t       (value[j / 8] & (1 << (7 - j % 8))));\n\t\t}\n\t}\n\n\t \n\tfor (i = 0, t = list; t; i++, t = t->next)\n\t\t;\n\tfor (j = 0; j < i / 2; ++j) {\n\t\tkey->prefixlen = list->n_bits;\n\t\tmemcpy(key->data, list->key, keysize);\n\t\tr = bpf_map_delete_elem(map, key);\n\t\tassert(!r);\n\t\tlist = tlpm_delete(list, list->key, list->n_bits);\n\t\tassert(list);\n\t}\n\tfor (i = 0; i < n_lookups; ++i) {\n\t\tfor (j = 0; j < keysize; ++j)\n\t\t\tdata[j] = rand() & 0xff;\n\n\t\tt = tlpm_match(list, data, 8 * keysize);\n\n\t\tkey->prefixlen = 8 * keysize;\n\t\tmemcpy(key->data, data, keysize);\n\t\tr = bpf_map_lookup_elem(map, key, value);\n\t\tassert(!r || errno == ENOENT);\n\t\tassert(!t == !!r);\n\n\t\tif (t) {\n\t\t\t++n_matches_after_delete;\n\t\t\tassert(t->n_bits == value[keysize]);\n\t\t\tfor (j = 0; j < t->n_bits; ++j)\n\t\t\t\tassert((t->key[j / 8] & (1 << (7 - j % 8))) ==\n\t\t\t\t       (value[j / 8] & (1 << (7 - j % 8))));\n\t\t}\n\t}\n\n\tclose(map);\n\ttlpm_clear(list);\n\n\t \n}\n\n \n\nstatic void test_lpm_ipaddr(void)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts, .map_flags = BPF_F_NO_PREALLOC);\n\tstruct bpf_lpm_trie_key *key_ipv4;\n\tstruct bpf_lpm_trie_key *key_ipv6;\n\tsize_t key_size_ipv4;\n\tsize_t key_size_ipv6;\n\tint map_fd_ipv4;\n\tint map_fd_ipv6;\n\t__u64 value;\n\n\tkey_size_ipv4 = sizeof(*key_ipv4) + sizeof(__u32);\n\tkey_size_ipv6 = sizeof(*key_ipv6) + sizeof(__u32) * 4;\n\tkey_ipv4 = alloca(key_size_ipv4);\n\tkey_ipv6 = alloca(key_size_ipv6);\n\n\tmap_fd_ipv4 = bpf_map_create(BPF_MAP_TYPE_LPM_TRIE, NULL,\n\t\t\t\t     key_size_ipv4, sizeof(value),\n\t\t\t\t     100, &opts);\n\tassert(map_fd_ipv4 >= 0);\n\n\tmap_fd_ipv6 = bpf_map_create(BPF_MAP_TYPE_LPM_TRIE, NULL,\n\t\t\t\t     key_size_ipv6, sizeof(value),\n\t\t\t\t     100, &opts);\n\tassert(map_fd_ipv6 >= 0);\n\n\t \n\tvalue = 1;\n\tkey_ipv4->prefixlen = 16;\n\tinet_pton(AF_INET, \"192.168.0.0\", key_ipv4->data);\n\tassert(bpf_map_update_elem(map_fd_ipv4, key_ipv4, &value, 0) == 0);\n\n\tvalue = 2;\n\tkey_ipv4->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.0.0\", key_ipv4->data);\n\tassert(bpf_map_update_elem(map_fd_ipv4, key_ipv4, &value, 0) == 0);\n\n\tvalue = 3;\n\tkey_ipv4->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.128.0\", key_ipv4->data);\n\tassert(bpf_map_update_elem(map_fd_ipv4, key_ipv4, &value, 0) == 0);\n\n\tvalue = 5;\n\tkey_ipv4->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.1.0\", key_ipv4->data);\n\tassert(bpf_map_update_elem(map_fd_ipv4, key_ipv4, &value, 0) == 0);\n\n\tvalue = 4;\n\tkey_ipv4->prefixlen = 23;\n\tinet_pton(AF_INET, \"192.168.0.0\", key_ipv4->data);\n\tassert(bpf_map_update_elem(map_fd_ipv4, key_ipv4, &value, 0) == 0);\n\n\tvalue = 0xdeadbeef;\n\tkey_ipv6->prefixlen = 64;\n\tinet_pton(AF_INET6, \"2a00:1450:4001:814::200e\", key_ipv6->data);\n\tassert(bpf_map_update_elem(map_fd_ipv6, key_ipv6, &value, 0) == 0);\n\n\t \n\tkey_ipv4->prefixlen = 32;\n\tkey_ipv6->prefixlen = 128;\n\n\t \n\tinet_pton(AF_INET, \"192.168.128.23\", key_ipv4->data);\n\tassert(bpf_map_lookup_elem(map_fd_ipv4, key_ipv4, &value) == 0);\n\tassert(value == 3);\n\n\tinet_pton(AF_INET, \"192.168.0.1\", key_ipv4->data);\n\tassert(bpf_map_lookup_elem(map_fd_ipv4, key_ipv4, &value) == 0);\n\tassert(value == 2);\n\n\tinet_pton(AF_INET6, \"2a00:1450:4001:814::\", key_ipv6->data);\n\tassert(bpf_map_lookup_elem(map_fd_ipv6, key_ipv6, &value) == 0);\n\tassert(value == 0xdeadbeef);\n\n\tinet_pton(AF_INET6, \"2a00:1450:4001:814::1\", key_ipv6->data);\n\tassert(bpf_map_lookup_elem(map_fd_ipv6, key_ipv6, &value) == 0);\n\tassert(value == 0xdeadbeef);\n\n\t \n\tinet_pton(AF_INET, \"10.0.0.1\", key_ipv4->data);\n\tassert(bpf_map_lookup_elem(map_fd_ipv4, key_ipv4, &value) == -ENOENT);\n\n\tinet_pton(AF_INET, \"11.11.11.11\", key_ipv4->data);\n\tassert(bpf_map_lookup_elem(map_fd_ipv4, key_ipv4, &value) == -ENOENT);\n\n\tinet_pton(AF_INET6, \"2a00:ffff::\", key_ipv6->data);\n\tassert(bpf_map_lookup_elem(map_fd_ipv6, key_ipv6, &value) == -ENOENT);\n\n\tclose(map_fd_ipv4);\n\tclose(map_fd_ipv6);\n}\n\nstatic void test_lpm_delete(void)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts, .map_flags = BPF_F_NO_PREALLOC);\n\tstruct bpf_lpm_trie_key *key;\n\tsize_t key_size;\n\tint map_fd;\n\t__u64 value;\n\n\tkey_size = sizeof(*key) + sizeof(__u32);\n\tkey = alloca(key_size);\n\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_LPM_TRIE, NULL,\n\t\t\t\tkey_size, sizeof(value),\n\t\t\t\t100, &opts);\n\tassert(map_fd >= 0);\n\n\t \n\tvalue = 1;\n\tkey->prefixlen = 16;\n\tinet_pton(AF_INET, \"192.168.0.0\", key->data);\n\tassert(bpf_map_update_elem(map_fd, key, &value, 0) == 0);\n\n\tvalue = 2;\n\tkey->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.0.0\", key->data);\n\tassert(bpf_map_update_elem(map_fd, key, &value, 0) == 0);\n\n\tvalue = 3;\n\tkey->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.128.0\", key->data);\n\tassert(bpf_map_update_elem(map_fd, key, &value, 0) == 0);\n\n\tvalue = 4;\n\tkey->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.1.0\", key->data);\n\tassert(bpf_map_update_elem(map_fd, key, &value, 0) == 0);\n\n\t \n\tkey->prefixlen = 32;\n\tinet_pton(AF_INET, \"10.0.0.1\", key->data);\n\tassert(bpf_map_lookup_elem(map_fd, key, &value) == -ENOENT);\n\n\tkey->prefixlen = 30; \n\tinet_pton(AF_INET, \"192.255.0.0\", key->data);\n\tassert(bpf_map_delete_elem(map_fd, key) == -ENOENT);\n\n\tkey->prefixlen = 16; \n\tinet_pton(AF_INET, \"192.255.0.0\", key->data);\n\tassert(bpf_map_delete_elem(map_fd, key) == -ENOENT);\n\n\t \n\tkey->prefixlen = 32;\n\tinet_pton(AF_INET, \"192.168.0.1\", key->data);\n\tassert(bpf_map_lookup_elem(map_fd, key, &value) == 0);\n\tassert(value == 2);\n\n\t \n\tkey->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.0.0\", key->data);\n\tassert(bpf_map_delete_elem(map_fd, key) == 0);\n\n\tkey->prefixlen = 32;\n\tinet_pton(AF_INET, \"192.168.0.1\", key->data);\n\tassert(bpf_map_lookup_elem(map_fd, key, &value) == 0);\n\tassert(value == 1);\n\n\t \n\tkey->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.1.0\", key->data);\n\tassert(bpf_map_delete_elem(map_fd, key) == 0);\n\n\tkey->prefixlen = 32;\n\tinet_pton(AF_INET, \"192.168.1.1\", key->data);\n\tassert(bpf_map_lookup_elem(map_fd, key, &value) == 0);\n\tassert(value == 1);\n\n\t \n\tkey->prefixlen = 16;\n\tinet_pton(AF_INET, \"192.168.0.0\", key->data);\n\tassert(bpf_map_delete_elem(map_fd, key) == 0);\n\n\tkey->prefixlen = 32;\n\tinet_pton(AF_INET, \"192.168.128.1\", key->data);\n\tassert(bpf_map_lookup_elem(map_fd, key, &value) == 0);\n\tassert(value == 3);\n\n\t \n\tkey->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.128.0\", key->data);\n\tassert(bpf_map_delete_elem(map_fd, key) == 0);\n\n\tkey->prefixlen = 32;\n\tinet_pton(AF_INET, \"192.168.128.1\", key->data);\n\tassert(bpf_map_lookup_elem(map_fd, key, &value) == -ENOENT);\n\n\tclose(map_fd);\n}\n\nstatic void test_lpm_get_next_key(void)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts, .map_flags = BPF_F_NO_PREALLOC);\n\tstruct bpf_lpm_trie_key *key_p, *next_key_p;\n\tsize_t key_size;\n\t__u32 value = 0;\n\tint map_fd;\n\n\tkey_size = sizeof(*key_p) + sizeof(__u32);\n\tkey_p = alloca(key_size);\n\tnext_key_p = alloca(key_size);\n\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_LPM_TRIE, NULL, key_size, sizeof(value), 100, &opts);\n\tassert(map_fd >= 0);\n\n\t \n\tassert(bpf_map_get_next_key(map_fd, NULL, key_p) == -ENOENT);\n\n\t \n\tkey_p->prefixlen = 16;\n\tinet_pton(AF_INET, \"192.168.0.0\", key_p->data);\n\tassert(bpf_map_update_elem(map_fd, key_p, &value, 0) == 0);\n\n\tmemset(key_p, 0, key_size);\n\tassert(bpf_map_get_next_key(map_fd, NULL, key_p) == 0);\n\tassert(key_p->prefixlen == 16 && key_p->data[0] == 192 &&\n\t       key_p->data[1] == 168);\n\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == -ENOENT);\n\n\t \n\tkey_p->prefixlen = 8;\n\tassert(bpf_map_get_next_key(map_fd, NULL, key_p) == 0);\n\tassert(key_p->prefixlen == 16 && key_p->data[0] == 192 &&\n\t       key_p->data[1] == 168);\n\n\t \n\tkey_p->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.128.0\", key_p->data);\n\tassert(bpf_map_update_elem(map_fd, key_p, &value, 0) == 0);\n\n\tmemset(key_p, 0, key_size);\n\tassert(bpf_map_get_next_key(map_fd, NULL, key_p) == 0);\n\tassert(key_p->prefixlen == 24 && key_p->data[0] == 192 &&\n\t       key_p->data[1] == 168 && key_p->data[2] == 128);\n\n\tmemset(next_key_p, 0, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 16 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == -ENOENT);\n\n\t \n\tkey_p->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.0.0\", key_p->data);\n\tassert(bpf_map_update_elem(map_fd, key_p, &value, 0) == 0);\n\n\tmemset(key_p, 0, key_size);\n\tassert(bpf_map_get_next_key(map_fd, NULL, key_p) == 0);\n\tassert(key_p->prefixlen == 24 && key_p->data[0] == 192 &&\n\t       key_p->data[1] == 168 && key_p->data[2] == 0);\n\n\tmemset(next_key_p, 0, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 24 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168 && next_key_p->data[2] == 128);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 16 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == -ENOENT);\n\n\t \n\tkey_p->prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.1.0\", key_p->data);\n\tassert(bpf_map_update_elem(map_fd, key_p, &value, 0) == 0);\n\n\tmemset(key_p, 0, key_size);\n\tassert(bpf_map_get_next_key(map_fd, NULL, key_p) == 0);\n\tassert(key_p->prefixlen == 24 && key_p->data[0] == 192 &&\n\t       key_p->data[1] == 168 && key_p->data[2] == 0);\n\n\tmemset(next_key_p, 0, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 24 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168 && next_key_p->data[2] == 1);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 24 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168 && next_key_p->data[2] == 128);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 16 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == -ENOENT);\n\n\t \n\tkey_p->prefixlen = 28;\n\tinet_pton(AF_INET, \"192.168.1.128\", key_p->data);\n\tassert(bpf_map_update_elem(map_fd, key_p, &value, 0) == 0);\n\n\tmemset(key_p, 0, key_size);\n\tassert(bpf_map_get_next_key(map_fd, NULL, key_p) == 0);\n\tassert(key_p->prefixlen == 24 && key_p->data[0] == 192 &&\n\t       key_p->data[1] == 168 && key_p->data[2] == 0);\n\n\tmemset(next_key_p, 0, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 28 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168 && next_key_p->data[2] == 1 &&\n\t       next_key_p->data[3] == 128);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 24 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168 && next_key_p->data[2] == 1);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 24 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168 && next_key_p->data[2] == 128);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 16 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168);\n\n\tmemcpy(key_p, next_key_p, key_size);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == -ENOENT);\n\n\t \n\tkey_p->prefixlen = 22;\n\tinet_pton(AF_INET, \"192.168.1.0\", key_p->data);\n\tassert(bpf_map_get_next_key(map_fd, key_p, next_key_p) == 0);\n\tassert(next_key_p->prefixlen == 24 && next_key_p->data[0] == 192 &&\n\t       next_key_p->data[1] == 168 && next_key_p->data[2] == 0);\n\n\tclose(map_fd);\n}\n\n#define MAX_TEST_KEYS\t4\nstruct lpm_mt_test_info {\n\tint cmd;  \n\tint iter;\n\tint map_fd;\n\tstruct {\n\t\t__u32 prefixlen;\n\t\t__u32 data;\n\t} key[MAX_TEST_KEYS];\n};\n\nstatic void *lpm_test_command(void *arg)\n{\n\tint i, j, ret, iter, key_size;\n\tstruct lpm_mt_test_info *info = arg;\n\tstruct bpf_lpm_trie_key *key_p;\n\n\tkey_size = sizeof(struct bpf_lpm_trie_key) + sizeof(__u32);\n\tkey_p = alloca(key_size);\n\tfor (iter = 0; iter < info->iter; iter++)\n\t\tfor (i = 0; i < MAX_TEST_KEYS; i++) {\n\t\t\t \n\t\t\tj = (iter < (info->iter / 2)) ? i : MAX_TEST_KEYS - i - 1;\n\t\t\tkey_p->prefixlen = info->key[j].prefixlen;\n\t\t\tmemcpy(key_p->data, &info->key[j].data, sizeof(__u32));\n\t\t\tif (info->cmd == 0) {\n\t\t\t\t__u32 value = j;\n\t\t\t\t \n\t\t\t\tassert(bpf_map_update_elem(info->map_fd, key_p, &value, 0) == 0);\n\t\t\t} else if (info->cmd == 1) {\n\t\t\t\tret = bpf_map_delete_elem(info->map_fd, key_p);\n\t\t\t\tassert(ret == 0 || errno == ENOENT);\n\t\t\t} else if (info->cmd == 2) {\n\t\t\t\t__u32 value;\n\t\t\t\tret = bpf_map_lookup_elem(info->map_fd, key_p, &value);\n\t\t\t\tassert(ret == 0 || errno == ENOENT);\n\t\t\t} else {\n\t\t\t\tstruct bpf_lpm_trie_key *next_key_p = alloca(key_size);\n\t\t\t\tret = bpf_map_get_next_key(info->map_fd, key_p, next_key_p);\n\t\t\t\tassert(ret == 0 || errno == ENOENT || errno == ENOMEM);\n\t\t\t}\n\t\t}\n\n\t\n\tpthread_exit((void *)info);\n}\n\nstatic void setup_lpm_mt_test_info(struct lpm_mt_test_info *info, int map_fd)\n{\n\tinfo->iter = 2000;\n\tinfo->map_fd = map_fd;\n\tinfo->key[0].prefixlen = 16;\n\tinet_pton(AF_INET, \"192.168.0.0\", &info->key[0].data);\n\tinfo->key[1].prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.0.0\", &info->key[1].data);\n\tinfo->key[2].prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.128.0\", &info->key[2].data);\n\tinfo->key[3].prefixlen = 24;\n\tinet_pton(AF_INET, \"192.168.1.0\", &info->key[3].data);\n}\n\nstatic void test_lpm_multi_thread(void)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts, .map_flags = BPF_F_NO_PREALLOC);\n\tstruct lpm_mt_test_info info[4];\n\tsize_t key_size, value_size;\n\tpthread_t thread_id[4];\n\tint i, map_fd;\n\tvoid *ret;\n\n\t \n\tvalue_size = sizeof(__u32);\n\tkey_size = sizeof(struct bpf_lpm_trie_key) + value_size;\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_LPM_TRIE, NULL, key_size, value_size, 100, &opts);\n\n\t \n\tsetup_lpm_mt_test_info(&info[0], map_fd);\n\tfor (i = 0; i < 4; i++) {\n\t\tif (i != 0)\n\t\t\tmemcpy(&info[i], &info[0], sizeof(info[i]));\n\t\tinfo[i].cmd = i;\n\t\tassert(pthread_create(&thread_id[i], NULL, &lpm_test_command, &info[i]) == 0);\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tassert(pthread_join(thread_id[i], &ret) == 0 && ret == (void *)&info[i]);\n\n\tclose(map_fd);\n}\n\nint main(void)\n{\n\tint i;\n\n\t \n\tsrand(0xf00ba1);\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\ttest_lpm_basic();\n\ttest_lpm_order();\n\n\t \n\tfor (i = 1; i <= 16; ++i)\n\t\ttest_lpm_map(i);\n\n\ttest_lpm_ipaddr();\n\ttest_lpm_delete();\n\ttest_lpm_get_next_key();\n\ttest_lpm_multi_thread();\n\n\tprintf(\"test_lpm: OK\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}