{
  "module_name": "cgroup_helpers.c",
  "hash_id": "39f121b619c83eebbdd28a80ccd2a879c708776618916cb537527a0e7b873a60",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/cgroup_helpers.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sched.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <linux/sched.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <ftw.h>\n\n#include \"cgroup_helpers.h\"\n#include \"bpf_util.h\"\n\n \n\n#define WALK_FD_LIMIT\t\t\t16\n\n#define CGROUP_MOUNT_PATH\t\t\"/mnt\"\n#define CGROUP_MOUNT_DFLT\t\t\"/sys/fs/cgroup\"\n#define NETCLS_MOUNT_PATH\t\tCGROUP_MOUNT_DFLT \"/net_cls\"\n#define CGROUP_WORK_DIR\t\t\t\"/cgroup-test-work-dir\"\n\n#define format_cgroup_path_pid(buf, path, pid) \\\n\tsnprintf(buf, sizeof(buf), \"%s%s%d%s\", CGROUP_MOUNT_PATH, \\\n\tCGROUP_WORK_DIR, pid, path)\n\n#define format_cgroup_path(buf, path) \\\n\tformat_cgroup_path_pid(buf, path, getpid())\n\n#define format_parent_cgroup_path(buf, path) \\\n\tformat_cgroup_path_pid(buf, path, getppid())\n\n#define format_classid_path(buf)\t\t\t\t\\\n\tsnprintf(buf, sizeof(buf), \"%s%s\", NETCLS_MOUNT_PATH,\t\\\n\t\t CGROUP_WORK_DIR)\n\nstatic int __enable_controllers(const char *cgroup_path, const char *controllers)\n{\n\tchar path[PATH_MAX + 1];\n\tchar enable[PATH_MAX + 1];\n\tchar *c, *c2;\n\tint fd, cfd;\n\tssize_t len;\n\n\t \n\tif (!controllers) {\n\t\tsnprintf(path, sizeof(path), \"%s/cgroup.controllers\",\n\t\t\t cgroup_path);\n\t\tfd = open(path, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tlog_err(\"Opening cgroup.controllers: %s\", path);\n\t\t\treturn 1;\n\t\t}\n\t\tlen = read(fd, enable, sizeof(enable) - 1);\n\t\tif (len < 0) {\n\t\t\tclose(fd);\n\t\t\tlog_err(\"Reading cgroup.controllers: %s\", path);\n\t\t\treturn 1;\n\t\t} else if (len == 0) {  \n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\t\tenable[len] = 0;\n\t\tclose(fd);\n\t} else {\n\t\tbpf_strlcpy(enable, controllers, sizeof(enable));\n\t}\n\n\tsnprintf(path, sizeof(path), \"%s/cgroup.subtree_control\", cgroup_path);\n\tcfd = open(path, O_RDWR);\n\tif (cfd < 0) {\n\t\tlog_err(\"Opening cgroup.subtree_control: %s\", path);\n\t\treturn 1;\n\t}\n\n\tfor (c = strtok_r(enable, \" \", &c2); c; c = strtok_r(NULL, \" \", &c2)) {\n\t\tif (dprintf(cfd, \"+%s\\n\", c) <= 0) {\n\t\t\tlog_err(\"Enabling controller %s: %s\", c, path);\n\t\t\tclose(cfd);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tclose(cfd);\n\treturn 0;\n}\n\n \nint enable_controllers(const char *relative_path, const char *controllers)\n{\n\tchar cgroup_path[PATH_MAX + 1];\n\n\tformat_cgroup_path(cgroup_path, relative_path);\n\treturn __enable_controllers(cgroup_path, controllers);\n}\n\nstatic int __write_cgroup_file(const char *cgroup_path, const char *file,\n\t\t\t       const char *buf)\n{\n\tchar file_path[PATH_MAX + 1];\n\tint fd;\n\n\tsnprintf(file_path, sizeof(file_path), \"%s/%s\", cgroup_path, file);\n\tfd = open(file_path, O_RDWR);\n\tif (fd < 0) {\n\t\tlog_err(\"Opening %s\", file_path);\n\t\treturn 1;\n\t}\n\n\tif (dprintf(fd, \"%s\", buf) <= 0) {\n\t\tlog_err(\"Writing to %s\", file_path);\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\tclose(fd);\n\treturn 0;\n}\n\n \nint write_cgroup_file(const char *relative_path, const char *file,\n\t\t      const char *buf)\n{\n\tchar cgroup_path[PATH_MAX - 24];\n\n\tformat_cgroup_path(cgroup_path, relative_path);\n\treturn __write_cgroup_file(cgroup_path, file, buf);\n}\n\n \nint write_cgroup_file_parent(const char *relative_path, const char *file,\n\t\t\t     const char *buf)\n{\n\tchar cgroup_path[PATH_MAX - 24];\n\n\tformat_parent_cgroup_path(cgroup_path, relative_path);\n\treturn __write_cgroup_file(cgroup_path, file, buf);\n}\n\n \nint setup_cgroup_environment(void)\n{\n\tchar cgroup_workdir[PATH_MAX - 24];\n\n\tformat_cgroup_path(cgroup_workdir, \"\");\n\n\tif (unshare(CLONE_NEWNS)) {\n\t\tlog_err(\"unshare\");\n\t\treturn 1;\n\t}\n\n\tif (mount(\"none\", \"/\", NULL, MS_REC | MS_PRIVATE, NULL)) {\n\t\tlog_err(\"mount fakeroot\");\n\t\treturn 1;\n\t}\n\n\tif (mount(\"none\", CGROUP_MOUNT_PATH, \"cgroup2\", 0, NULL) && errno != EBUSY) {\n\t\tlog_err(\"mount cgroup2\");\n\t\treturn 1;\n\t}\n\n\t \n\tcleanup_cgroup_environment();\n\n\tif (mkdir(cgroup_workdir, 0777) && errno != EEXIST) {\n\t\tlog_err(\"mkdir cgroup work dir\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (__enable_controllers(CGROUP_MOUNT_PATH, NULL) ||\n\t    __enable_controllers(cgroup_workdir, NULL))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int nftwfunc(const char *filename, const struct stat *statptr,\n\t\t    int fileflags, struct FTW *pfwt)\n{\n\tif ((fileflags & FTW_D) && rmdir(filename))\n\t\tlog_err(\"Removing cgroup: %s\", filename);\n\treturn 0;\n}\n\nstatic int join_cgroup_from_top(const char *cgroup_path)\n{\n\tchar cgroup_procs_path[PATH_MAX + 1];\n\tpid_t pid = getpid();\n\tint fd, rc = 0;\n\n\tsnprintf(cgroup_procs_path, sizeof(cgroup_procs_path),\n\t\t \"%s/cgroup.procs\", cgroup_path);\n\n\tfd = open(cgroup_procs_path, O_WRONLY);\n\tif (fd < 0) {\n\t\tlog_err(\"Opening Cgroup Procs: %s\", cgroup_procs_path);\n\t\treturn 1;\n\t}\n\n\tif (dprintf(fd, \"%d\\n\", pid) < 0) {\n\t\tlog_err(\"Joining Cgroup\");\n\t\trc = 1;\n\t}\n\n\tclose(fd);\n\treturn rc;\n}\n\n \nint join_cgroup(const char *relative_path)\n{\n\tchar cgroup_path[PATH_MAX + 1];\n\n\tformat_cgroup_path(cgroup_path, relative_path);\n\treturn join_cgroup_from_top(cgroup_path);\n}\n\n \nint join_root_cgroup(void)\n{\n\treturn join_cgroup_from_top(CGROUP_MOUNT_PATH);\n}\n\n \nint join_parent_cgroup(const char *relative_path)\n{\n\tchar cgroup_path[PATH_MAX + 1];\n\n\tformat_parent_cgroup_path(cgroup_path, relative_path);\n\treturn join_cgroup_from_top(cgroup_path);\n}\n\n \nvoid cleanup_cgroup_environment(void)\n{\n\tchar cgroup_workdir[PATH_MAX + 1];\n\n\tformat_cgroup_path(cgroup_workdir, \"\");\n\tjoin_cgroup_from_top(CGROUP_MOUNT_PATH);\n\tnftw(cgroup_workdir, nftwfunc, WALK_FD_LIMIT, FTW_DEPTH | FTW_MOUNT);\n}\n\n \nint get_root_cgroup(void)\n{\n\tint fd;\n\n\tfd = open(CGROUP_MOUNT_PATH, O_RDONLY);\n\tif (fd < 0) {\n\t\tlog_err(\"Opening root cgroup\");\n\t\treturn -1;\n\t}\n\treturn fd;\n}\n\n \nvoid remove_cgroup(const char *relative_path)\n{\n\tchar cgroup_path[PATH_MAX + 1];\n\n\tformat_cgroup_path(cgroup_path, relative_path);\n\tif (rmdir(cgroup_path))\n\t\tlog_err(\"rmdiring cgroup %s .. %s\", relative_path, cgroup_path);\n}\n\n \nint create_and_get_cgroup(const char *relative_path)\n{\n\tchar cgroup_path[PATH_MAX + 1];\n\tint fd;\n\n\tformat_cgroup_path(cgroup_path, relative_path);\n\tif (mkdir(cgroup_path, 0777) && errno != EEXIST) {\n\t\tlog_err(\"mkdiring cgroup %s .. %s\", relative_path, cgroup_path);\n\t\treturn -1;\n\t}\n\n\tfd = open(cgroup_path, O_RDONLY);\n\tif (fd < 0) {\n\t\tlog_err(\"Opening Cgroup\");\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\n \nunsigned long long get_cgroup_id(const char *relative_path)\n{\n\tint dirfd, err, flags, mount_id, fhsize;\n\tunion {\n\t\tunsigned long long cgid;\n\t\tunsigned char raw_bytes[8];\n\t} id;\n\tchar cgroup_workdir[PATH_MAX + 1];\n\tstruct file_handle *fhp, *fhp2;\n\tunsigned long long ret = 0;\n\n\tformat_cgroup_path(cgroup_workdir, relative_path);\n\n\tdirfd = AT_FDCWD;\n\tflags = 0;\n\tfhsize = sizeof(*fhp);\n\tfhp = calloc(1, fhsize);\n\tif (!fhp) {\n\t\tlog_err(\"calloc\");\n\t\treturn 0;\n\t}\n\terr = name_to_handle_at(dirfd, cgroup_workdir, fhp, &mount_id, flags);\n\tif (err >= 0 || fhp->handle_bytes != 8) {\n\t\tlog_err(\"name_to_handle_at\");\n\t\tgoto free_mem;\n\t}\n\n\tfhsize = sizeof(struct file_handle) + fhp->handle_bytes;\n\tfhp2 = realloc(fhp, fhsize);\n\tif (!fhp2) {\n\t\tlog_err(\"realloc\");\n\t\tgoto free_mem;\n\t}\n\terr = name_to_handle_at(dirfd, cgroup_workdir, fhp2, &mount_id, flags);\n\tfhp = fhp2;\n\tif (err < 0) {\n\t\tlog_err(\"name_to_handle_at\");\n\t\tgoto free_mem;\n\t}\n\n\tmemcpy(id.raw_bytes, fhp->f_handle, 8);\n\tret = id.cgid;\n\nfree_mem:\n\tfree(fhp);\n\treturn ret;\n}\n\nint cgroup_setup_and_join(const char *path) {\n\tint cg_fd;\n\n\tif (setup_cgroup_environment()) {\n\t\tfprintf(stderr, \"Failed to setup cgroup environment\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcg_fd = create_and_get_cgroup(path);\n\tif (cg_fd < 0) {\n\t\tfprintf(stderr, \"Failed to create test cgroup\\n\");\n\t\tcleanup_cgroup_environment();\n\t\treturn cg_fd;\n\t}\n\n\tif (join_cgroup(path)) {\n\t\tfprintf(stderr, \"Failed to join cgroup\\n\");\n\t\tcleanup_cgroup_environment();\n\t\treturn -EINVAL;\n\t}\n\treturn cg_fd;\n}\n\n \nint setup_classid_environment(void)\n{\n\tchar cgroup_workdir[PATH_MAX + 1];\n\n\tformat_classid_path(cgroup_workdir);\n\n\tif (mount(\"tmpfs\", CGROUP_MOUNT_DFLT, \"tmpfs\", 0, NULL) &&\n\t    errno != EBUSY) {\n\t\tlog_err(\"mount cgroup base\");\n\t\treturn 1;\n\t}\n\n\tif (mkdir(NETCLS_MOUNT_PATH, 0777) && errno != EEXIST) {\n\t\tlog_err(\"mkdir cgroup net_cls\");\n\t\treturn 1;\n\t}\n\n\tif (mount(\"net_cls\", NETCLS_MOUNT_PATH, \"cgroup\", 0, \"net_cls\") &&\n\t    errno != EBUSY) {\n\t\tlog_err(\"mount cgroup net_cls\");\n\t\treturn 1;\n\t}\n\n\tcleanup_classid_environment();\n\n\tif (mkdir(cgroup_workdir, 0777) && errno != EEXIST) {\n\t\tlog_err(\"mkdir cgroup work dir\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nint set_classid(unsigned int id)\n{\n\tchar cgroup_workdir[PATH_MAX - 42];\n\tchar cgroup_classid_path[PATH_MAX + 1];\n\tint fd, rc = 0;\n\n\tformat_classid_path(cgroup_workdir);\n\tsnprintf(cgroup_classid_path, sizeof(cgroup_classid_path),\n\t\t \"%s/net_cls.classid\", cgroup_workdir);\n\n\tfd = open(cgroup_classid_path, O_WRONLY);\n\tif (fd < 0) {\n\t\tlog_err(\"Opening cgroup classid: %s\", cgroup_classid_path);\n\t\treturn 1;\n\t}\n\n\tif (dprintf(fd, \"%u\\n\", id) < 0) {\n\t\tlog_err(\"Setting cgroup classid\");\n\t\trc = 1;\n\t}\n\n\tclose(fd);\n\treturn rc;\n}\n\n \nint join_classid(void)\n{\n\tchar cgroup_workdir[PATH_MAX + 1];\n\n\tformat_classid_path(cgroup_workdir);\n\treturn join_cgroup_from_top(cgroup_workdir);\n}\n\n \nvoid cleanup_classid_environment(void)\n{\n\tchar cgroup_workdir[PATH_MAX + 1];\n\n\tformat_classid_path(cgroup_workdir);\n\tjoin_cgroup_from_top(NETCLS_MOUNT_PATH);\n\tnftw(cgroup_workdir, nftwfunc, WALK_FD_LIMIT, FTW_DEPTH | FTW_MOUNT);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}