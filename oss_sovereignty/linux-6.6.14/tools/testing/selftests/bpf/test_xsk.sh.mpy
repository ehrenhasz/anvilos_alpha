{
  "module_name": "test_xsk.sh",
  "hash_id": "782c5c1495e4cc83722779fe09889f9e4b1c26b7dffdb2915fa1eea51211adb4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_xsk.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# Copyright(c) 2020 Intel Corporation, Weqaar Janjua <weqaar.a.janjua@intel.com>\n\n# AF_XDP selftests based on veth\n#\n# End-to-end AF_XDP over Veth test\n#\n# Topology:\n# ---------\n#                 -----------\n#               _ | Process | _\n#              /  -----------  \\\n#             /        |        \\\n#            /         |         \\\n#      -----------     |     -----------\n#      | Thread1 |     |     | Thread2 |\n#      -----------     |     -----------\n#           |          |          |\n#      -----------     |     -----------\n#      |  xskX   |     |     |  xskY   |\n#      -----------     |     -----------\n#           |          |          |\n#      -----------     |     ----------\n#      |  vethX  | --------- |  vethY |\n#      -----------   peer    ----------\n#\n# AF_XDP is an address family optimized for high performance packet processing,\n# it is XDP\u2019s user-space interface.\n#\n# An AF_XDP socket is linked to a single UMEM which is a region of virtual\n# contiguous memory, divided into equal-sized frames.\n#\n# Refer to AF_XDP Kernel Documentation for detailed information:\n# https://www.kernel.org/doc/html/latest/networking/af_xdp.html\n#\n# Prerequisites setup by script:\n#\n#   Set up veth interfaces as per the topology shown ^^:\n#   * setup two veth interfaces\n#   ** veth<xxxx>\n#   ** veth<yyyy>\n#   *** xxxx and yyyy are randomly generated 4 digit numbers used to avoid\n#       conflict with any existing interface\n#   * tests the veth and xsk layers of the topology\n#\n# See the source xskxceiver.c for information on each test\n#\n# Kernel configuration:\n# ---------------------\n# See \"config\" file for recommended kernel config options.\n#\n# Turn on XDP sockets and veth support when compiling i.e.\n# \tNetworking support -->\n# \t\tNetworking options -->\n# \t\t\t[ * ] XDP sockets\n#\n# Executing Tests:\n# ----------------\n# Must run with CAP_NET_ADMIN capability.\n#\n# Run:\n#   sudo ./test_xsk.sh\n#\n# If running from kselftests:\n#   sudo make run_tests\n#\n# Run with verbose output:\n#   sudo ./test_xsk.sh -v\n#\n# Set up veth interfaces and leave them up so xskxceiver can be launched in a debugger:\n#   sudo ./test_xsk.sh -d\n#\n# Run test suite for physical device in loopback mode\n#   sudo ./test_xsk.sh -i IFACE\n\n. xsk_prereqs.sh\n\nETH=\"\"\n\nwhile getopts \"vi:d\" flag\ndo\n\tcase \"${flag}\" in\n\t\tv) verbose=1;;\n\t\td) debug=1;;\n\t\ti) ETH=${OPTARG};;\n\tesac\ndone\n\nTEST_NAME=\"PREREQUISITES\"\n\nURANDOM=/dev/urandom\n[ ! -e \"${URANDOM}\" ] && { echo \"${URANDOM} not found. Skipping tests.\"; test_exit $ksft_fail; }\n\nVETH0_POSTFIX=$(cat ${URANDOM} | tr -dc '0-9' | fold -w 256 | head -n 1 | head --bytes 4)\nVETH0=ve${VETH0_POSTFIX}\nVETH1_POSTFIX=$(cat ${URANDOM} | tr -dc '0-9' | fold -w 256 | head -n 1 | head --bytes 4)\nVETH1=ve${VETH1_POSTFIX}\nMTU=1500\n\ntrap ctrl_c INT\n\nfunction ctrl_c() {\n        cleanup_exit ${VETH0} ${VETH1}\n\texit 1\n}\n\nsetup_vethPairs() {\n\tif [[ $verbose -eq 1 ]]; then\n\t        echo \"setting up ${VETH0}\"\n\tfi\n\tip link add ${VETH0} numtxqueues 4 numrxqueues 4 type veth peer name ${VETH1} numtxqueues 4 numrxqueues 4\n\tif [ -f /proc/net/if_inet6 ]; then\n\t\techo 1 > /proc/sys/net/ipv6/conf/${VETH0}/disable_ipv6\n\t\techo 1 > /proc/sys/net/ipv6/conf/${VETH1}/disable_ipv6\n\tfi\n\tif [[ $verbose -eq 1 ]]; then\n\t        echo \"setting up ${VETH1}\"\n\tfi\n\n\tif [[ $busy_poll -eq 1 ]]; then\n\t        echo 2 > /sys/class/net/${VETH0}/napi_defer_hard_irqs\n\t\techo 200000 > /sys/class/net/${VETH0}/gro_flush_timeout\n\t\techo 2 > /sys/class/net/${VETH1}/napi_defer_hard_irqs\n\t\techo 200000 > /sys/class/net/${VETH1}/gro_flush_timeout\n\tfi\n\n\tip link set ${VETH1} mtu ${MTU}\n\tip link set ${VETH0} mtu ${MTU}\n\tip link set ${VETH1} up\n\tip link set ${VETH0} up\n}\n\nif [ ! -z $ETH ]; then\n\tVETH0=${ETH}\n\tVETH1=${ETH}\nelse\n\tvalidate_root_exec\n\tvalidate_veth_support ${VETH0}\n\tvalidate_ip_utility\n\tsetup_vethPairs\n\n\tretval=$?\n\tif [ $retval -ne 0 ]; then\n\t\ttest_status $retval \"${TEST_NAME}\"\n\t\tcleanup_exit ${VETH0} ${VETH1}\n\t\texit $retval\n\tfi\nfi\n\n\nif [[ $verbose -eq 1 ]]; then\n\tARGS+=\"-v \"\nfi\n\nretval=$?\ntest_status $retval \"${TEST_NAME}\"\n\n## START TESTS\n\nstatusList=()\n\nTEST_NAME=\"XSK_SELFTESTS_${VETH0}_SOFTIRQ\"\n\nif [[ $debug -eq 1 ]]; then\n    echo \"-i\" ${VETH0} \"-i\" ${VETH1}\n    exit\nfi\n\nexec_xskxceiver\n\nif [ -z $ETH ]; then\n\tcleanup_exit ${VETH0} ${VETH1}\nelse\n\tcleanup_iface ${ETH} ${MTU}\nfi\n\nTEST_NAME=\"XSK_SELFTESTS_${VETH0}_BUSY_POLL\"\nbusy_poll=1\n\nif [ -z $ETH ]; then\n\tsetup_vethPairs\nfi\nexec_xskxceiver\n\n## END TESTS\n\nif [ -z $ETH ]; then\n\tcleanup_exit ${VETH0} ${VETH1}\nelse\n\tcleanup_iface ${ETH} ${MTU}\nfi\n\nfailures=0\necho -e \"\\nSummary:\"\nfor i in \"${!statusList[@]}\"\ndo\n\tif [ ${statusList[$i]} -ne 0 ]; then\n\t        test_status ${statusList[$i]} ${nameList[$i]}\n\t\tfailures=1\n\tfi\ndone\n\nif [ $failures -eq 0 ]; then\n        echo \"All tests successful!\"\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}