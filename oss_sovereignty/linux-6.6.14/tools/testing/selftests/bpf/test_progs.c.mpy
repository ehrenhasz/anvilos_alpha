{
  "module_name": "test_progs.c",
  "hash_id": "1c092ea2ba3121f8477df6ab4cccc84f10094a1d9ccd187d085c9a52634c49be",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_progs.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include \"test_progs.h\"\n#include \"testing_helpers.h\"\n#include \"cgroup_helpers.h\"\n#include <argp.h>\n#include <pthread.h>\n#include <sched.h>\n#include <signal.h>\n#include <string.h>\n#include <execinfo.h>  \n#include <sys/sysinfo.h>  \n#include <netinet/in.h>\n#include <sys/select.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <bpf/btf.h>\n#include \"json_writer.h\"\n\nstatic bool verbose(void)\n{\n\treturn env.verbosity > VERBOSE_NONE;\n}\n\nstatic void stdio_hijack_init(char **log_buf, size_t *log_cnt)\n{\n#ifdef __GLIBC__\n\tif (verbose() && env.worker_id == -1) {\n\t\t \n\t\treturn;\n\t}\n\n\tfflush(stdout);\n\tfflush(stderr);\n\n\tstdout = open_memstream(log_buf, log_cnt);\n\tif (!stdout) {\n\t\tstdout = env.stdout;\n\t\tperror(\"open_memstream\");\n\t\treturn;\n\t}\n\n\tif (env.subtest_state)\n\t\tenv.subtest_state->stdout = stdout;\n\telse\n\t\tenv.test_state->stdout = stdout;\n\n\tstderr = stdout;\n#endif\n}\n\nstatic void stdio_hijack(char **log_buf, size_t *log_cnt)\n{\n#ifdef __GLIBC__\n\tif (verbose() && env.worker_id == -1) {\n\t\t \n\t\treturn;\n\t}\n\n\tenv.stdout = stdout;\n\tenv.stderr = stderr;\n\n\tstdio_hijack_init(log_buf, log_cnt);\n#endif\n}\n\nstatic void stdio_restore_cleanup(void)\n{\n#ifdef __GLIBC__\n\tif (verbose() && env.worker_id == -1) {\n\t\t \n\t\treturn;\n\t}\n\n\tfflush(stdout);\n\n\tif (env.subtest_state) {\n\t\tfclose(env.subtest_state->stdout);\n\t\tenv.subtest_state->stdout = NULL;\n\t\tstdout = env.test_state->stdout;\n\t\tstderr = env.test_state->stdout;\n\t} else {\n\t\tfclose(env.test_state->stdout);\n\t\tenv.test_state->stdout = NULL;\n\t}\n#endif\n}\n\nstatic void stdio_restore(void)\n{\n#ifdef __GLIBC__\n\tif (verbose() && env.worker_id == -1) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (stdout == env.stdout)\n\t\treturn;\n\n\tstdio_restore_cleanup();\n\n\tstdout = env.stdout;\n\tstderr = env.stderr;\n#endif\n}\n\n \nstatic bool glob_match(const char *str, const char *pat)\n{\n\twhile (*str && *pat && *pat != '*') {\n\t\tif (*str != *pat)\n\t\t\treturn false;\n\t\tstr++;\n\t\tpat++;\n\t}\n\t \n\tif (*pat == '*') {\n\t\twhile (*pat == '*')\n\t\t\tpat++;\n\t\tif (!*pat)  \n\t\t\treturn true;\n\t\twhile (*str)\n\t\t\tif (glob_match(str++, pat))\n\t\t\t\treturn true;\n\t}\n\treturn !*str && !*pat;\n}\n\n#define EXIT_NO_TEST\t\t2\n#define EXIT_ERR_SETUP_INFRA\t3\n\n \nstruct test_env env = {};\n\nstruct prog_test_def {\n\tconst char *test_name;\n\tint test_num;\n\tvoid (*run_test)(void);\n\tvoid (*run_serial_test)(void);\n\tbool should_run;\n\tbool need_cgroup_cleanup;\n};\n\n \nint usleep(useconds_t usec)\n{\n\tstruct timespec ts = {\n\t\t.tv_sec = usec / 1000000,\n\t\t.tv_nsec = (usec % 1000000) * 1000,\n\t};\n\n\treturn syscall(__NR_nanosleep, &ts, NULL);\n}\n\nstatic bool should_run(struct test_selector *sel, int num, const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < sel->blacklist.cnt; i++) {\n\t\tif (glob_match(name, sel->blacklist.tests[i].name) &&\n\t\t    !sel->blacklist.tests[i].subtest_cnt)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < sel->whitelist.cnt; i++) {\n\t\tif (glob_match(name, sel->whitelist.tests[i].name))\n\t\t\treturn true;\n\t}\n\n\tif (!sel->whitelist.cnt && !sel->num_set)\n\t\treturn true;\n\n\treturn num < sel->num_set_len && sel->num_set[num];\n}\n\nstatic bool should_run_subtest(struct test_selector *sel,\n\t\t\t       struct test_selector *subtest_sel,\n\t\t\t       int subtest_num,\n\t\t\t       const char *test_name,\n\t\t\t       const char *subtest_name)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sel->blacklist.cnt; i++) {\n\t\tif (glob_match(test_name, sel->blacklist.tests[i].name)) {\n\t\t\tif (!sel->blacklist.tests[i].subtest_cnt)\n\t\t\t\treturn false;\n\n\t\t\tfor (j = 0; j < sel->blacklist.tests[i].subtest_cnt; j++) {\n\t\t\t\tif (glob_match(subtest_name,\n\t\t\t\t\t       sel->blacklist.tests[i].subtests[j]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < sel->whitelist.cnt; i++) {\n\t\tif (glob_match(test_name, sel->whitelist.tests[i].name)) {\n\t\t\tif (!sel->whitelist.tests[i].subtest_cnt)\n\t\t\t\treturn true;\n\n\t\t\tfor (j = 0; j < sel->whitelist.tests[i].subtest_cnt; j++) {\n\t\t\t\tif (glob_match(subtest_name,\n\t\t\t\t\t       sel->whitelist.tests[i].subtests[j]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!sel->whitelist.cnt && !subtest_sel->num_set)\n\t\treturn true;\n\n\treturn subtest_num < subtest_sel->num_set_len && subtest_sel->num_set[subtest_num];\n}\n\nstatic char *test_result(bool failed, bool skipped)\n{\n\treturn failed ? \"FAIL\" : (skipped ? \"SKIP\" : \"OK\");\n}\n\n#define TEST_NUM_WIDTH 7\n\nstatic void print_test_result(const struct prog_test_def *test, const struct test_state *test_state)\n{\n\tint skipped_cnt = test_state->skip_cnt;\n\tint subtests_cnt = test_state->subtest_num;\n\n\tfprintf(env.stdout, \"#%-*d %s:\", TEST_NUM_WIDTH, test->test_num, test->test_name);\n\tif (test_state->error_cnt)\n\t\tfprintf(env.stdout, \"FAIL\");\n\telse if (!skipped_cnt)\n\t\tfprintf(env.stdout, \"OK\");\n\telse if (skipped_cnt == subtests_cnt || !subtests_cnt)\n\t\tfprintf(env.stdout, \"SKIP\");\n\telse\n\t\tfprintf(env.stdout, \"OK (SKIP: %d/%d)\", skipped_cnt, subtests_cnt);\n\n\tfprintf(env.stdout, \"\\n\");\n}\n\nstatic void print_test_log(char *log_buf, size_t log_cnt)\n{\n\tlog_buf[log_cnt] = '\\0';\n\tfprintf(env.stdout, \"%s\", log_buf);\n\tif (log_buf[log_cnt - 1] != '\\n')\n\t\tfprintf(env.stdout, \"\\n\");\n}\n\nstatic void print_subtest_name(int test_num, int subtest_num,\n\t\t\t       const char *test_name, char *subtest_name,\n\t\t\t       char *result)\n{\n\tchar test_num_str[TEST_NUM_WIDTH + 1];\n\n\tsnprintf(test_num_str, sizeof(test_num_str), \"%d/%d\", test_num, subtest_num);\n\n\tfprintf(env.stdout, \"#%-*s %s/%s\",\n\t\tTEST_NUM_WIDTH, test_num_str,\n\t\ttest_name, subtest_name);\n\n\tif (result)\n\t\tfprintf(env.stdout, \":%s\", result);\n\n\tfprintf(env.stdout, \"\\n\");\n}\n\nstatic void jsonw_write_log_message(json_writer_t *w, char *log_buf, size_t log_cnt)\n{\n\t \n\tif (log_cnt) {\n\t\tjsonw_string_field(w, \"message\", log_buf);\n\t} else {\n\t\tjsonw_string_field(w, \"message\", \"\");\n\t}\n}\n\nstatic void dump_test_log(const struct prog_test_def *test,\n\t\t\t  const struct test_state *test_state,\n\t\t\t  bool skip_ok_subtests,\n\t\t\t  bool par_exec_result,\n\t\t\t  json_writer_t *w)\n{\n\tbool test_failed = test_state->error_cnt > 0;\n\tbool force_log = test_state->force_log;\n\tbool print_test = verbose() || force_log || test_failed;\n\tint i;\n\tstruct subtest_state *subtest_state;\n\tbool subtest_failed;\n\tbool subtest_filtered;\n\tbool print_subtest;\n\n\t \n\tif (env.worker_id != -1)\n\t\treturn;\n\n\t \n\tif (verbose() && !par_exec_result)\n\t\treturn;\n\n\tif (test_state->log_cnt && print_test)\n\t\tprint_test_log(test_state->log_buf, test_state->log_cnt);\n\n\tif (w && print_test) {\n\t\tjsonw_start_object(w);\n\t\tjsonw_string_field(w, \"name\", test->test_name);\n\t\tjsonw_uint_field(w, \"number\", test->test_num);\n\t\tjsonw_write_log_message(w, test_state->log_buf, test_state->log_cnt);\n\t\tjsonw_bool_field(w, \"failed\", test_failed);\n\t\tjsonw_name(w, \"subtests\");\n\t\tjsonw_start_array(w);\n\t}\n\n\tfor (i = 0; i < test_state->subtest_num; i++) {\n\t\tsubtest_state = &test_state->subtest_states[i];\n\t\tsubtest_failed = subtest_state->error_cnt;\n\t\tsubtest_filtered = subtest_state->filtered;\n\t\tprint_subtest = verbose() || force_log || subtest_failed;\n\n\t\tif ((skip_ok_subtests && !subtest_failed) || subtest_filtered)\n\t\t\tcontinue;\n\n\t\tif (subtest_state->log_cnt && print_subtest) {\n\t\t\tprint_test_log(subtest_state->log_buf,\n\t\t\t\t       subtest_state->log_cnt);\n\t\t}\n\n\t\tprint_subtest_name(test->test_num, i + 1,\n\t\t\t\t   test->test_name, subtest_state->name,\n\t\t\t\t   test_result(subtest_state->error_cnt,\n\t\t\t\t\t       subtest_state->skipped));\n\n\t\tif (w && print_subtest) {\n\t\t\tjsonw_start_object(w);\n\t\t\tjsonw_string_field(w, \"name\", subtest_state->name);\n\t\t\tjsonw_uint_field(w, \"number\", i+1);\n\t\t\tjsonw_write_log_message(w, subtest_state->log_buf, subtest_state->log_cnt);\n\t\t\tjsonw_bool_field(w, \"failed\", subtest_failed);\n\t\t\tjsonw_end_object(w);\n\t\t}\n\t}\n\n\tif (w && print_test) {\n\t\tjsonw_end_array(w);\n\t\tjsonw_end_object(w);\n\t}\n\n\tprint_test_result(test, test_state);\n}\n\nstatic void stdio_restore(void);\n\n \nstatic void reset_affinity(void)\n{\n\tcpu_set_t cpuset;\n\tint i, err;\n\n\tCPU_ZERO(&cpuset);\n\tfor (i = 0; i < env.nr_cpus; i++)\n\t\tCPU_SET(i, &cpuset);\n\n\terr = sched_setaffinity(0, sizeof(cpuset), &cpuset);\n\tif (err < 0) {\n\t\tstdio_restore();\n\t\tfprintf(stderr, \"Failed to reset process affinity: %d!\\n\", err);\n\t\texit(EXIT_ERR_SETUP_INFRA);\n\t}\n\terr = pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);\n\tif (err < 0) {\n\t\tstdio_restore();\n\t\tfprintf(stderr, \"Failed to reset thread affinity: %d!\\n\", err);\n\t\texit(EXIT_ERR_SETUP_INFRA);\n\t}\n}\n\nstatic void save_netns(void)\n{\n\tenv.saved_netns_fd = open(\"/proc/self/ns/net\", O_RDONLY);\n\tif (env.saved_netns_fd == -1) {\n\t\tperror(\"open(/proc/self/ns/net)\");\n\t\texit(EXIT_ERR_SETUP_INFRA);\n\t}\n}\n\nstatic void restore_netns(void)\n{\n\tif (setns(env.saved_netns_fd, CLONE_NEWNET) == -1) {\n\t\tstdio_restore();\n\t\tperror(\"setns(CLONE_NEWNS)\");\n\t\texit(EXIT_ERR_SETUP_INFRA);\n\t}\n}\n\nvoid test__end_subtest(void)\n{\n\tstruct prog_test_def *test = env.test;\n\tstruct test_state *test_state = env.test_state;\n\tstruct subtest_state *subtest_state = env.subtest_state;\n\n\tif (subtest_state->error_cnt) {\n\t\ttest_state->error_cnt++;\n\t} else {\n\t\tif (!subtest_state->skipped)\n\t\t\ttest_state->sub_succ_cnt++;\n\t\telse\n\t\t\ttest_state->skip_cnt++;\n\t}\n\n\tif (verbose() && !env.workers)\n\t\tprint_subtest_name(test->test_num, test_state->subtest_num,\n\t\t\t\t   test->test_name, subtest_state->name,\n\t\t\t\t   test_result(subtest_state->error_cnt,\n\t\t\t\t\t       subtest_state->skipped));\n\n\tstdio_restore_cleanup();\n\tenv.subtest_state = NULL;\n}\n\nbool test__start_subtest(const char *subtest_name)\n{\n\tstruct prog_test_def *test = env.test;\n\tstruct test_state *state = env.test_state;\n\tstruct subtest_state *subtest_state;\n\tsize_t sub_state_size = sizeof(*subtest_state);\n\n\tif (env.subtest_state)\n\t\ttest__end_subtest();\n\n\tstate->subtest_num++;\n\tstate->subtest_states =\n\t\trealloc(state->subtest_states,\n\t\t\tstate->subtest_num * sub_state_size);\n\tif (!state->subtest_states) {\n\t\tfprintf(stderr, \"Not enough memory to allocate subtest result\\n\");\n\t\treturn false;\n\t}\n\n\tsubtest_state = &state->subtest_states[state->subtest_num - 1];\n\n\tmemset(subtest_state, 0, sub_state_size);\n\n\tif (!subtest_name || !subtest_name[0]) {\n\t\tfprintf(env.stderr,\n\t\t\t\"Subtest #%d didn't provide sub-test name!\\n\",\n\t\t\tstate->subtest_num);\n\t\treturn false;\n\t}\n\n\tsubtest_state->name = strdup(subtest_name);\n\tif (!subtest_state->name) {\n\t\tfprintf(env.stderr,\n\t\t\t\"Subtest #%d: failed to copy subtest name!\\n\",\n\t\t\tstate->subtest_num);\n\t\treturn false;\n\t}\n\n\tif (!should_run_subtest(&env.test_selector,\n\t\t\t\t&env.subtest_selector,\n\t\t\t\tstate->subtest_num,\n\t\t\t\ttest->test_name,\n\t\t\t\tsubtest_name)) {\n\t\tsubtest_state->filtered = true;\n\t\treturn false;\n\t}\n\n\tenv.subtest_state = subtest_state;\n\tstdio_hijack_init(&subtest_state->log_buf, &subtest_state->log_cnt);\n\n\treturn true;\n}\n\nvoid test__force_log(void)\n{\n\tenv.test_state->force_log = true;\n}\n\nvoid test__skip(void)\n{\n\tif (env.subtest_state)\n\t\tenv.subtest_state->skipped = true;\n\telse\n\t\tenv.test_state->skip_cnt++;\n}\n\nvoid test__fail(void)\n{\n\tif (env.subtest_state)\n\t\tenv.subtest_state->error_cnt++;\n\telse\n\t\tenv.test_state->error_cnt++;\n}\n\nint test__join_cgroup(const char *path)\n{\n\tint fd;\n\n\tif (!env.test->need_cgroup_cleanup) {\n\t\tif (setup_cgroup_environment()) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"#%d %s: Failed to setup cgroup environment\\n\",\n\t\t\t\tenv.test->test_num, env.test->test_name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tenv.test->need_cgroup_cleanup = true;\n\t}\n\n\tfd = create_and_get_cgroup(path);\n\tif (fd < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"#%d %s: Failed to create cgroup '%s' (errno=%d)\\n\",\n\t\t\tenv.test->test_num, env.test->test_name, path, errno);\n\t\treturn fd;\n\t}\n\n\tif (join_cgroup(path)) {\n\t\tfprintf(stderr,\n\t\t\t\"#%d %s: Failed to join cgroup '%s' (errno=%d)\\n\",\n\t\t\tenv.test->test_num, env.test->test_name, path, errno);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nint bpf_find_map(const char *test, struct bpf_object *obj, const char *name)\n{\n\tstruct bpf_map *map;\n\n\tmap = bpf_object__find_map_by_name(obj, name);\n\tif (!map) {\n\t\tfprintf(stdout, \"%s:FAIL:map '%s' not found\\n\", test, name);\n\t\ttest__fail();\n\t\treturn -1;\n\t}\n\treturn bpf_map__fd(map);\n}\n\nstatic bool is_jit_enabled(void)\n{\n\tconst char *jit_sysctl = \"/proc/sys/net/core/bpf_jit_enable\";\n\tbool enabled = false;\n\tint sysctl_fd;\n\n\tsysctl_fd = open(jit_sysctl, 0, O_RDONLY);\n\tif (sysctl_fd != -1) {\n\t\tchar tmpc;\n\n\t\tif (read(sysctl_fd, &tmpc, sizeof(tmpc)) == 1)\n\t\t\tenabled = (tmpc != '0');\n\t\tclose(sysctl_fd);\n\t}\n\n\treturn enabled;\n}\n\nint compare_map_keys(int map1_fd, int map2_fd)\n{\n\t__u32 key, next_key;\n\tchar val_buf[PERF_MAX_STACK_DEPTH *\n\t\t     sizeof(struct bpf_stack_build_id)];\n\tint err;\n\n\terr = bpf_map_get_next_key(map1_fd, NULL, &key);\n\tif (err)\n\t\treturn err;\n\terr = bpf_map_lookup_elem(map2_fd, &key, val_buf);\n\tif (err)\n\t\treturn err;\n\n\twhile (bpf_map_get_next_key(map1_fd, &key, &next_key) == 0) {\n\t\terr = bpf_map_lookup_elem(map2_fd, &next_key, val_buf);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tkey = next_key;\n\t}\n\tif (errno != ENOENT)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint compare_stack_ips(int smap_fd, int amap_fd, int stack_trace_len)\n{\n\t__u32 key, next_key, *cur_key_p, *next_key_p;\n\tchar *val_buf1, *val_buf2;\n\tint i, err = 0;\n\n\tval_buf1 = malloc(stack_trace_len);\n\tval_buf2 = malloc(stack_trace_len);\n\tcur_key_p = NULL;\n\tnext_key_p = &key;\n\twhile (bpf_map_get_next_key(smap_fd, cur_key_p, next_key_p) == 0) {\n\t\terr = bpf_map_lookup_elem(smap_fd, next_key_p, val_buf1);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = bpf_map_lookup_elem(amap_fd, next_key_p, val_buf2);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tfor (i = 0; i < stack_trace_len; i++) {\n\t\t\tif (val_buf1[i] != val_buf2[i]) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tkey = *next_key_p;\n\t\tcur_key_p = &key;\n\t\tnext_key_p = &next_key;\n\t}\n\tif (errno != ENOENT)\n\t\terr = -1;\n\nout:\n\tfree(val_buf1);\n\tfree(val_buf2);\n\treturn err;\n}\n\n \n#define DEFINE_TEST(name)\t\t\t\t\\\n\textern void test_##name(void) __weak;\t\t\\\n\textern void serial_test_##name(void) __weak;\n#include <prog_tests/tests.h>\n#undef DEFINE_TEST\n\nstatic struct prog_test_def prog_test_defs[] = {\n#define DEFINE_TEST(name) {\t\t\t\\\n\t.test_name = #name,\t\t\t\\\n\t.run_test = &test_##name,\t\t\\\n\t.run_serial_test = &serial_test_##name,\t\\\n},\n#include <prog_tests/tests.h>\n#undef DEFINE_TEST\n};\n\nstatic const int prog_test_cnt = ARRAY_SIZE(prog_test_defs);\n\nstatic struct test_state test_states[ARRAY_SIZE(prog_test_defs)];\n\nconst char *argp_program_version = \"test_progs 0.1\";\nconst char *argp_program_bug_address = \"<bpf@vger.kernel.org>\";\nstatic const char argp_program_doc[] =\n\"BPF selftests test runner\\v\"\n\"Options accepting the NAMES parameter take either a comma-separated list\\n\"\n\"of test names, or a filename prefixed with @. The file contains one name\\n\"\n\"(or wildcard pattern) per line, and comments beginning with # are ignored.\\n\"\n\"\\n\"\n\"These options can be passed repeatedly to read multiple files.\\n\";\n\nenum ARG_KEYS {\n\tARG_TEST_NUM = 'n',\n\tARG_TEST_NAME = 't',\n\tARG_TEST_NAME_BLACKLIST = 'b',\n\tARG_VERIFIER_STATS = 's',\n\tARG_VERBOSE = 'v',\n\tARG_GET_TEST_CNT = 'c',\n\tARG_LIST_TEST_NAMES = 'l',\n\tARG_TEST_NAME_GLOB_ALLOWLIST = 'a',\n\tARG_TEST_NAME_GLOB_DENYLIST = 'd',\n\tARG_NUM_WORKERS = 'j',\n\tARG_DEBUG = -1,\n\tARG_JSON_SUMMARY = 'J'\n};\n\nstatic const struct argp_option opts[] = {\n\t{ \"num\", ARG_TEST_NUM, \"NUM\", 0,\n\t  \"Run test number NUM only \" },\n\t{ \"name\", ARG_TEST_NAME, \"NAMES\", 0,\n\t  \"Run tests with names containing any string from NAMES list\" },\n\t{ \"name-blacklist\", ARG_TEST_NAME_BLACKLIST, \"NAMES\", 0,\n\t  \"Don't run tests with names containing any string from NAMES list\" },\n\t{ \"verifier-stats\", ARG_VERIFIER_STATS, NULL, 0,\n\t  \"Output verifier statistics\", },\n\t{ \"verbose\", ARG_VERBOSE, \"LEVEL\", OPTION_ARG_OPTIONAL,\n\t  \"Verbose output (use -vv or -vvv for progressively verbose output)\" },\n\t{ \"count\", ARG_GET_TEST_CNT, NULL, 0,\n\t  \"Get number of selected top-level tests \" },\n\t{ \"list\", ARG_LIST_TEST_NAMES, NULL, 0,\n\t  \"List test names that would run (without running them) \" },\n\t{ \"allow\", ARG_TEST_NAME_GLOB_ALLOWLIST, \"NAMES\", 0,\n\t  \"Run tests with name matching the pattern (supports '*' wildcard).\" },\n\t{ \"deny\", ARG_TEST_NAME_GLOB_DENYLIST, \"NAMES\", 0,\n\t  \"Don't run tests with name matching the pattern (supports '*' wildcard).\" },\n\t{ \"workers\", ARG_NUM_WORKERS, \"WORKERS\", OPTION_ARG_OPTIONAL,\n\t  \"Number of workers to run in parallel, default to number of cpus.\" },\n\t{ \"debug\", ARG_DEBUG, NULL, 0,\n\t  \"print extra debug information for test_progs.\" },\n\t{ \"json-summary\", ARG_JSON_SUMMARY, \"FILE\", 0, \"Write report in json format to this file.\"},\n\t{},\n};\n\nstatic int libbpf_print_fn(enum libbpf_print_level level,\n\t\t\t   const char *format, va_list args)\n{\n\tif (env.verbosity < VERBOSE_VERY && level == LIBBPF_DEBUG)\n\t\treturn 0;\n\tvfprintf(stdout, format, args);\n\treturn 0;\n}\n\nstatic void free_test_filter_set(const struct test_filter_set *set)\n{\n\tint i, j;\n\n\tif (!set)\n\t\treturn;\n\n\tfor (i = 0; i < set->cnt; i++) {\n\t\tfree((void *)set->tests[i].name);\n\t\tfor (j = 0; j < set->tests[i].subtest_cnt; j++)\n\t\t\tfree((void *)set->tests[i].subtests[j]);\n\n\t\tfree((void *)set->tests[i].subtests);\n\t}\n\n\tfree((void *)set->tests);\n}\n\nstatic void free_test_selector(struct test_selector *test_selector)\n{\n\tfree_test_filter_set(&test_selector->blacklist);\n\tfree_test_filter_set(&test_selector->whitelist);\n\tfree(test_selector->num_set);\n}\n\nextern int extra_prog_load_log_flags;\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tstruct test_env *env = state->input;\n\tint err = 0;\n\n\tswitch (key) {\n\tcase ARG_TEST_NUM: {\n\t\tchar *subtest_str = strchr(arg, '/');\n\n\t\tif (subtest_str) {\n\t\t\t*subtest_str = '\\0';\n\t\t\tif (parse_num_list(subtest_str + 1,\n\t\t\t\t\t   &env->subtest_selector.num_set,\n\t\t\t\t\t   &env->subtest_selector.num_set_len)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Failed to parse subtest numbers.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (parse_num_list(arg, &env->test_selector.num_set,\n\t\t\t\t   &env->test_selector.num_set_len)) {\n\t\t\tfprintf(stderr, \"Failed to parse test numbers.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARG_TEST_NAME_GLOB_ALLOWLIST:\n\tcase ARG_TEST_NAME: {\n\t\tif (arg[0] == '@')\n\t\t\terr = parse_test_list_file(arg + 1,\n\t\t\t\t\t\t   &env->test_selector.whitelist,\n\t\t\t\t\t\t   key == ARG_TEST_NAME_GLOB_ALLOWLIST);\n\t\telse\n\t\t\terr = parse_test_list(arg,\n\t\t\t\t\t      &env->test_selector.whitelist,\n\t\t\t\t\t      key == ARG_TEST_NAME_GLOB_ALLOWLIST);\n\n\t\tbreak;\n\t}\n\tcase ARG_TEST_NAME_GLOB_DENYLIST:\n\tcase ARG_TEST_NAME_BLACKLIST: {\n\t\tif (arg[0] == '@')\n\t\t\terr = parse_test_list_file(arg + 1,\n\t\t\t\t\t\t   &env->test_selector.blacklist,\n\t\t\t\t\t\t   key == ARG_TEST_NAME_GLOB_DENYLIST);\n\t\telse\n\t\t\terr = parse_test_list(arg,\n\t\t\t\t\t      &env->test_selector.blacklist,\n\t\t\t\t\t      key == ARG_TEST_NAME_GLOB_DENYLIST);\n\n\t\tbreak;\n\t}\n\tcase ARG_VERIFIER_STATS:\n\t\tenv->verifier_stats = true;\n\t\tbreak;\n\tcase ARG_VERBOSE:\n\t\tenv->verbosity = VERBOSE_NORMAL;\n\t\tif (arg) {\n\t\t\tif (strcmp(arg, \"v\") == 0) {\n\t\t\t\tenv->verbosity = VERBOSE_VERY;\n\t\t\t\textra_prog_load_log_flags = 1;\n\t\t\t} else if (strcmp(arg, \"vv\") == 0) {\n\t\t\t\tenv->verbosity = VERBOSE_SUPER;\n\t\t\t\textra_prog_load_log_flags = 2;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Unrecognized verbosity setting ('%s'), only -v and -vv are supported\\n\",\n\t\t\t\t\targ);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (verbose()) {\n\t\t\tif (setenv(\"SELFTESTS_VERBOSE\", \"1\", 1) == -1) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Unable to setenv SELFTESTS_VERBOSE=1 (errno=%d)\",\n\t\t\t\t\terrno);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase ARG_GET_TEST_CNT:\n\t\tenv->get_test_cnt = true;\n\t\tbreak;\n\tcase ARG_LIST_TEST_NAMES:\n\t\tenv->list_test_names = true;\n\t\tbreak;\n\tcase ARG_NUM_WORKERS:\n\t\tif (arg) {\n\t\t\tenv->workers = atoi(arg);\n\t\t\tif (!env->workers) {\n\t\t\t\tfprintf(stderr, \"Invalid number of worker: %s.\", arg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tenv->workers = get_nprocs();\n\t\t}\n\t\tbreak;\n\tcase ARG_DEBUG:\n\t\tenv->debug = true;\n\t\tbreak;\n\tcase ARG_JSON_SUMMARY:\n\t\tenv->json = fopen(arg, \"w\");\n\t\tif (env->json == NULL) {\n\t\t\tperror(\"Failed to open json summary file\");\n\t\t\treturn -errno;\n\t\t}\n\t\tbreak;\n\tcase ARGP_KEY_ARG:\n\t\targp_usage(state);\n\t\tbreak;\n\tcase ARGP_KEY_END:\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\treturn err;\n}\n\n \nint cd_flavor_subdir(const char *exec_name)\n{\n\t \n\tconst char *flavor = strrchr(exec_name, '/');\n\n\tif (!flavor)\n\t\tflavor = exec_name;\n\telse\n\t\tflavor++;\n\n\tflavor = strrchr(flavor, '-');\n\tif (!flavor)\n\t\treturn 0;\n\tflavor++;\n\tif (verbose())\n\t\tfprintf(stdout,\t\"Switching to flavor '%s' subdirectory...\\n\", flavor);\n\n\treturn chdir(flavor);\n}\n\nint trigger_module_test_read(int read_sz)\n{\n\tint fd, err;\n\n\tfd = open(BPF_TESTMOD_TEST_FILE, O_RDONLY);\n\terr = -errno;\n\tif (!ASSERT_GE(fd, 0, \"testmod_file_open\"))\n\t\treturn err;\n\n\tread(fd, NULL, read_sz);\n\tclose(fd);\n\n\treturn 0;\n}\n\nint trigger_module_test_write(int write_sz)\n{\n\tint fd, err;\n\tchar *buf = malloc(write_sz);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemset(buf, 'a', write_sz);\n\tbuf[write_sz-1] = '\\0';\n\n\tfd = open(BPF_TESTMOD_TEST_FILE, O_WRONLY);\n\terr = -errno;\n\tif (!ASSERT_GE(fd, 0, \"testmod_file_open\")) {\n\t\tfree(buf);\n\t\treturn err;\n\t}\n\n\twrite(fd, buf, write_sz);\n\tclose(fd);\n\tfree(buf);\n\treturn 0;\n}\n\nint write_sysctl(const char *sysctl, const char *value)\n{\n\tint fd, err, len;\n\n\tfd = open(sysctl, O_WRONLY);\n\tif (!ASSERT_NEQ(fd, -1, \"open sysctl\"))\n\t\treturn -1;\n\n\tlen = strlen(value);\n\terr = write(fd, value, len);\n\tclose(fd);\n\tif (!ASSERT_EQ(err, len, \"write sysctl\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint get_bpf_max_tramp_links_from(struct btf *btf)\n{\n\tconst struct btf_enum *e;\n\tconst struct btf_type *t;\n\t__u32 i, type_cnt;\n\tconst char *name;\n\t__u16 j, vlen;\n\n\tfor (i = 1, type_cnt = btf__type_cnt(btf); i < type_cnt; i++) {\n\t\tt = btf__type_by_id(btf, i);\n\t\tif (!t || !btf_is_enum(t) || t->name_off)\n\t\t\tcontinue;\n\t\te = btf_enum(t);\n\t\tfor (j = 0, vlen = btf_vlen(t); j < vlen; j++, e++) {\n\t\t\tname = btf__str_by_offset(btf, e->name_off);\n\t\t\tif (name && !strcmp(name, \"BPF_MAX_TRAMP_LINKS\"))\n\t\t\t\treturn e->val;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint get_bpf_max_tramp_links(void)\n{\n\tstruct btf *vmlinux_btf;\n\tint ret;\n\n\tvmlinux_btf = btf__load_vmlinux_btf();\n\tif (!ASSERT_OK_PTR(vmlinux_btf, \"vmlinux btf\"))\n\t\treturn -1;\n\tret = get_bpf_max_tramp_links_from(vmlinux_btf);\n\tbtf__free(vmlinux_btf);\n\n\treturn ret;\n}\n\n#define MAX_BACKTRACE_SZ 128\nvoid crash_handler(int signum)\n{\n\tvoid *bt[MAX_BACKTRACE_SZ];\n\tsize_t sz;\n\n\tsz = backtrace(bt, ARRAY_SIZE(bt));\n\n\tif (env.stdout)\n\t\tstdio_restore();\n\tif (env.test) {\n\t\tenv.test_state->error_cnt++;\n\t\tdump_test_log(env.test, env.test_state, true, false, NULL);\n\t}\n\tif (env.worker_id != -1)\n\t\tfprintf(stderr, \"[%d]: \", env.worker_id);\n\tfprintf(stderr, \"Caught signal #%d!\\nStack trace:\\n\", signum);\n\tbacktrace_symbols_fd(bt, sz, STDERR_FILENO);\n}\n\nstatic void sigint_handler(int signum)\n{\n\tint i;\n\n\tfor (i = 0; i < env.workers; i++)\n\t\tif (env.worker_socks[i] > 0)\n\t\t\tclose(env.worker_socks[i]);\n}\n\nstatic int current_test_idx;\nstatic pthread_mutex_t current_test_lock;\nstatic pthread_mutex_t stdout_output_lock;\n\nstatic inline const char *str_msg(const struct msg *msg, char *buf)\n{\n\tswitch (msg->type) {\n\tcase MSG_DO_TEST:\n\t\tsprintf(buf, \"MSG_DO_TEST %d\", msg->do_test.num);\n\t\tbreak;\n\tcase MSG_TEST_DONE:\n\t\tsprintf(buf, \"MSG_TEST_DONE %d (log: %d)\",\n\t\t\tmsg->test_done.num,\n\t\t\tmsg->test_done.have_log);\n\t\tbreak;\n\tcase MSG_SUBTEST_DONE:\n\t\tsprintf(buf, \"MSG_SUBTEST_DONE %d (log: %d)\",\n\t\t\tmsg->subtest_done.num,\n\t\t\tmsg->subtest_done.have_log);\n\t\tbreak;\n\tcase MSG_TEST_LOG:\n\t\tsprintf(buf, \"MSG_TEST_LOG (cnt: %zu, last: %d)\",\n\t\t\tstrlen(msg->test_log.log_buf),\n\t\t\tmsg->test_log.is_last);\n\t\tbreak;\n\tcase MSG_EXIT:\n\t\tsprintf(buf, \"MSG_EXIT\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(buf, \"UNKNOWN\");\n\t\tbreak;\n\t}\n\n\treturn buf;\n}\n\nstatic int send_message(int sock, const struct msg *msg)\n{\n\tchar buf[256];\n\n\tif (env.debug)\n\t\tfprintf(stderr, \"Sending msg: %s\\n\", str_msg(msg, buf));\n\treturn send(sock, msg, sizeof(*msg), 0);\n}\n\nstatic int recv_message(int sock, struct msg *msg)\n{\n\tint ret;\n\tchar buf[256];\n\n\tmemset(msg, 0, sizeof(*msg));\n\tret = recv(sock, msg, sizeof(*msg), 0);\n\tif (ret >= 0) {\n\t\tif (env.debug)\n\t\t\tfprintf(stderr, \"Received msg: %s\\n\", str_msg(msg, buf));\n\t}\n\treturn ret;\n}\n\nstatic void run_one_test(int test_num)\n{\n\tstruct prog_test_def *test = &prog_test_defs[test_num];\n\tstruct test_state *state = &test_states[test_num];\n\n\tenv.test = test;\n\tenv.test_state = state;\n\n\tstdio_hijack(&state->log_buf, &state->log_cnt);\n\n\tif (test->run_test)\n\t\ttest->run_test();\n\telse if (test->run_serial_test)\n\t\ttest->run_serial_test();\n\n\t \n\tif (env.subtest_state)\n\t\ttest__end_subtest();\n\n\tstate->tested = true;\n\n\tif (verbose() && env.worker_id == -1)\n\t\tprint_test_result(test, state);\n\n\treset_affinity();\n\trestore_netns();\n\tif (test->need_cgroup_cleanup)\n\t\tcleanup_cgroup_environment();\n\n\tstdio_restore();\n\n\tdump_test_log(test, state, false, false, NULL);\n}\n\nstruct dispatch_data {\n\tint worker_id;\n\tint sock_fd;\n};\n\nstatic int read_prog_test_msg(int sock_fd, struct msg *msg, enum msg_type type)\n{\n\tif (recv_message(sock_fd, msg) < 0)\n\t\treturn 1;\n\n\tif (msg->type != type) {\n\t\tprintf(\"%s: unexpected message type %d. expected %d\\n\", __func__, msg->type, type);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int dispatch_thread_read_log(int sock_fd, char **log_buf, size_t *log_cnt)\n{\n\tFILE *log_fp = NULL;\n\tint result = 0;\n\n\tlog_fp = open_memstream(log_buf, log_cnt);\n\tif (!log_fp)\n\t\treturn 1;\n\n\twhile (true) {\n\t\tstruct msg msg;\n\n\t\tif (read_prog_test_msg(sock_fd, &msg, MSG_TEST_LOG)) {\n\t\t\tresult = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfprintf(log_fp, \"%s\", msg.test_log.log_buf);\n\t\tif (msg.test_log.is_last)\n\t\t\tbreak;\n\t}\n\nout:\n\tfclose(log_fp);\n\tlog_fp = NULL;\n\treturn result;\n}\n\nstatic int dispatch_thread_send_subtests(int sock_fd, struct test_state *state)\n{\n\tstruct msg msg;\n\tstruct subtest_state *subtest_state;\n\tint subtest_num = state->subtest_num;\n\n\tstate->subtest_states = malloc(subtest_num * sizeof(*subtest_state));\n\n\tfor (int i = 0; i < subtest_num; i++) {\n\t\tsubtest_state = &state->subtest_states[i];\n\n\t\tmemset(subtest_state, 0, sizeof(*subtest_state));\n\n\t\tif (read_prog_test_msg(sock_fd, &msg, MSG_SUBTEST_DONE))\n\t\t\treturn 1;\n\n\t\tsubtest_state->name = strdup(msg.subtest_done.name);\n\t\tsubtest_state->error_cnt = msg.subtest_done.error_cnt;\n\t\tsubtest_state->skipped = msg.subtest_done.skipped;\n\t\tsubtest_state->filtered = msg.subtest_done.filtered;\n\n\t\t \n\t\tif (msg.subtest_done.have_log)\n\t\t\tif (dispatch_thread_read_log(sock_fd,\n\t\t\t\t\t\t     &subtest_state->log_buf,\n\t\t\t\t\t\t     &subtest_state->log_cnt))\n\t\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void *dispatch_thread(void *ctx)\n{\n\tstruct dispatch_data *data = ctx;\n\tint sock_fd;\n\n\tsock_fd = data->sock_fd;\n\n\twhile (true) {\n\t\tint test_to_run = -1;\n\t\tstruct prog_test_def *test;\n\t\tstruct test_state *state;\n\n\t\t \n\t\t{\n\t\t\tpthread_mutex_lock(&current_test_lock);\n\n\t\t\tif (current_test_idx >= prog_test_cnt) {\n\t\t\t\tpthread_mutex_unlock(&current_test_lock);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\ttest = &prog_test_defs[current_test_idx];\n\t\t\ttest_to_run = current_test_idx;\n\t\t\tcurrent_test_idx++;\n\n\t\t\tpthread_mutex_unlock(&current_test_lock);\n\t\t}\n\n\t\tif (!test->should_run || test->run_serial_test)\n\t\t\tcontinue;\n\n\t\t \n\t\t{\n\t\t\tstruct msg msg_do_test;\n\n\t\t\tmemset(&msg_do_test, 0, sizeof(msg_do_test));\n\t\t\tmsg_do_test.type = MSG_DO_TEST;\n\t\t\tmsg_do_test.do_test.num = test_to_run;\n\t\t\tif (send_message(sock_fd, &msg_do_test) < 0) {\n\t\t\t\tperror(\"Fail to send command\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tenv.worker_current_test[data->worker_id] = test_to_run;\n\t\t}\n\n\t\t \n\t\tdo {\n\t\t\tstruct msg msg;\n\n\t\t\tif (read_prog_test_msg(sock_fd, &msg, MSG_TEST_DONE))\n\t\t\t\tgoto error;\n\t\t\tif (test_to_run != msg.test_done.num)\n\t\t\t\tgoto error;\n\n\t\t\tstate = &test_states[test_to_run];\n\t\t\tstate->tested = true;\n\t\t\tstate->error_cnt = msg.test_done.error_cnt;\n\t\t\tstate->skip_cnt = msg.test_done.skip_cnt;\n\t\t\tstate->sub_succ_cnt = msg.test_done.sub_succ_cnt;\n\t\t\tstate->subtest_num = msg.test_done.subtest_num;\n\n\t\t\t \n\t\t\tif (msg.test_done.have_log) {\n\t\t\t\tif (dispatch_thread_read_log(sock_fd,\n\t\t\t\t\t\t\t     &state->log_buf,\n\t\t\t\t\t\t\t     &state->log_cnt))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!state->subtest_num)\n\t\t\t\tbreak;\n\n\t\t\tif (dispatch_thread_send_subtests(sock_fd, state))\n\t\t\t\tgoto error;\n\t\t} while (false);\n\n\t\tpthread_mutex_lock(&stdout_output_lock);\n\t\tdump_test_log(test, state, false, true, NULL);\n\t\tpthread_mutex_unlock(&stdout_output_lock);\n\t}  \nerror:\n\tif (env.debug)\n\t\tfprintf(stderr, \"[%d]: Protocol/IO error: %s.\\n\", data->worker_id, strerror(errno));\n\ndone:\n\t{\n\t\tstruct msg msg_exit;\n\n\t\tmsg_exit.type = MSG_EXIT;\n\t\tif (send_message(sock_fd, &msg_exit) < 0) {\n\t\t\tif (env.debug)\n\t\t\t\tfprintf(stderr, \"[%d]: send_message msg_exit: %s.\\n\",\n\t\t\t\t\tdata->worker_id, strerror(errno));\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void calculate_summary_and_print_errors(struct test_env *env)\n{\n\tint i;\n\tint succ_cnt = 0, fail_cnt = 0, sub_succ_cnt = 0, skip_cnt = 0;\n\tjson_writer_t *w = NULL;\n\n\tfor (i = 0; i < prog_test_cnt; i++) {\n\t\tstruct test_state *state = &test_states[i];\n\n\t\tif (!state->tested)\n\t\t\tcontinue;\n\n\t\tsub_succ_cnt += state->sub_succ_cnt;\n\t\tskip_cnt += state->skip_cnt;\n\n\t\tif (state->error_cnt)\n\t\t\tfail_cnt++;\n\t\telse\n\t\t\tsucc_cnt++;\n\t}\n\n\tif (env->json) {\n\t\tw = jsonw_new(env->json);\n\t\tif (!w)\n\t\t\tfprintf(env->stderr, \"Failed to create new JSON stream.\");\n\t}\n\n\tif (w) {\n\t\tjsonw_start_object(w);\n\t\tjsonw_uint_field(w, \"success\", succ_cnt);\n\t\tjsonw_uint_field(w, \"success_subtest\", sub_succ_cnt);\n\t\tjsonw_uint_field(w, \"skipped\", skip_cnt);\n\t\tjsonw_uint_field(w, \"failed\", fail_cnt);\n\t\tjsonw_name(w, \"results\");\n\t\tjsonw_start_array(w);\n\t}\n\n\t \n\tif (!verbose() && fail_cnt) {\n\t\tprintf(\"\\nAll error logs:\\n\");\n\n\t\t \n\t\tfor (i = 0; i < prog_test_cnt; i++) {\n\t\t\tstruct prog_test_def *test = &prog_test_defs[i];\n\t\t\tstruct test_state *state = &test_states[i];\n\n\t\t\tif (!state->tested || !state->error_cnt)\n\t\t\t\tcontinue;\n\n\t\t\tdump_test_log(test, state, true, true, w);\n\t\t}\n\t}\n\n\tif (w) {\n\t\tjsonw_end_array(w);\n\t\tjsonw_end_object(w);\n\t\tjsonw_destroy(&w);\n\t}\n\n\tif (env->json)\n\t\tfclose(env->json);\n\n\tprintf(\"Summary: %d/%d PASSED, %d SKIPPED, %d FAILED\\n\",\n\t       succ_cnt, sub_succ_cnt, skip_cnt, fail_cnt);\n\n\tenv->succ_cnt = succ_cnt;\n\tenv->sub_succ_cnt = sub_succ_cnt;\n\tenv->fail_cnt = fail_cnt;\n\tenv->skip_cnt = skip_cnt;\n}\n\nstatic void server_main(void)\n{\n\tpthread_t *dispatcher_threads;\n\tstruct dispatch_data *data;\n\tstruct sigaction sigact_int = {\n\t\t.sa_handler = sigint_handler,\n\t\t.sa_flags = SA_RESETHAND,\n\t};\n\tint i;\n\n\tsigaction(SIGINT, &sigact_int, NULL);\n\n\tdispatcher_threads = calloc(sizeof(pthread_t), env.workers);\n\tdata = calloc(sizeof(struct dispatch_data), env.workers);\n\n\tenv.worker_current_test = calloc(sizeof(int), env.workers);\n\tfor (i = 0; i < env.workers; i++) {\n\t\tint rc;\n\n\t\tdata[i].worker_id = i;\n\t\tdata[i].sock_fd = env.worker_socks[i];\n\t\trc = pthread_create(&dispatcher_threads[i], NULL, dispatch_thread, &data[i]);\n\t\tif (rc < 0) {\n\t\t\tperror(\"Failed to launch dispatcher thread\");\n\t\t\texit(EXIT_ERR_SETUP_INFRA);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < env.workers; i++) {\n\t\twhile (true) {\n\t\t\tint ret = pthread_tryjoin_np(dispatcher_threads[i], NULL);\n\n\t\t\tif (!ret) {\n\t\t\t\tbreak;\n\t\t\t} else if (ret == EBUSY) {\n\t\t\t\tif (env.debug)\n\t\t\t\t\tfprintf(stderr, \"Still waiting for thread %d (test %d).\\n\",\n\t\t\t\t\t\ti,  env.worker_current_test[i] + 1);\n\t\t\t\tusleep(1000 * 1000);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unexpected error joining dispatcher thread: %d\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(dispatcher_threads);\n\tfree(env.worker_current_test);\n\tfree(data);\n\n\t \n\tsave_netns();\n\n\tfor (int i = 0; i < prog_test_cnt; i++) {\n\t\tstruct prog_test_def *test = &prog_test_defs[i];\n\n\t\tif (!test->should_run || !test->run_serial_test)\n\t\t\tcontinue;\n\n\t\trun_one_test(i);\n\t}\n\n\t \n\tfflush(stderr);\n\tfflush(stdout);\n\n\tcalculate_summary_and_print_errors(&env);\n\n\t \n\tfor (i = 0; i < env.workers; i++) {\n\t\tint wstatus, pid;\n\n\t\tpid = waitpid(env.worker_pids[i], &wstatus, 0);\n\t\tif (pid != env.worker_pids[i])\n\t\t\tperror(\"Unable to reap worker\");\n\t}\n}\n\nstatic void worker_main_send_log(int sock, char *log_buf, size_t log_cnt)\n{\n\tchar *src;\n\tsize_t slen;\n\n\tsrc = log_buf;\n\tslen = log_cnt;\n\twhile (slen) {\n\t\tstruct msg msg_log;\n\t\tchar *dest;\n\t\tsize_t len;\n\n\t\tmemset(&msg_log, 0, sizeof(msg_log));\n\t\tmsg_log.type = MSG_TEST_LOG;\n\t\tdest = msg_log.test_log.log_buf;\n\t\tlen = slen >= MAX_LOG_TRUNK_SIZE ? MAX_LOG_TRUNK_SIZE : slen;\n\t\tmemcpy(dest, src, len);\n\n\t\tsrc += len;\n\t\tslen -= len;\n\t\tif (!slen)\n\t\t\tmsg_log.test_log.is_last = true;\n\n\t\tassert(send_message(sock, &msg_log) >= 0);\n\t}\n}\n\nstatic void free_subtest_state(struct subtest_state *state)\n{\n\tif (state->log_buf) {\n\t\tfree(state->log_buf);\n\t\tstate->log_buf = NULL;\n\t\tstate->log_cnt = 0;\n\t}\n\tfree(state->name);\n\tstate->name = NULL;\n}\n\nstatic int worker_main_send_subtests(int sock, struct test_state *state)\n{\n\tint i, result = 0;\n\tstruct msg msg;\n\tstruct subtest_state *subtest_state;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type = MSG_SUBTEST_DONE;\n\n\tfor (i = 0; i < state->subtest_num; i++) {\n\t\tsubtest_state = &state->subtest_states[i];\n\n\t\tmsg.subtest_done.num = i;\n\n\t\tstrncpy(msg.subtest_done.name, subtest_state->name, MAX_SUBTEST_NAME);\n\n\t\tmsg.subtest_done.error_cnt = subtest_state->error_cnt;\n\t\tmsg.subtest_done.skipped = subtest_state->skipped;\n\t\tmsg.subtest_done.filtered = subtest_state->filtered;\n\t\tmsg.subtest_done.have_log = false;\n\n\t\tif (verbose() || state->force_log || subtest_state->error_cnt) {\n\t\t\tif (subtest_state->log_cnt)\n\t\t\t\tmsg.subtest_done.have_log = true;\n\t\t}\n\n\t\tif (send_message(sock, &msg) < 0) {\n\t\t\tperror(\"Fail to send message done\");\n\t\t\tresult = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (msg.subtest_done.have_log)\n\t\t\tworker_main_send_log(sock, subtest_state->log_buf, subtest_state->log_cnt);\n\n\t\tfree_subtest_state(subtest_state);\n\t\tfree(subtest_state->name);\n\t}\n\nout:\n\tfor (; i < state->subtest_num; i++)\n\t\tfree_subtest_state(&state->subtest_states[i]);\n\tfree(state->subtest_states);\n\treturn result;\n}\n\nstatic int worker_main(int sock)\n{\n\tsave_netns();\n\n\twhile (true) {\n\t\t \n\t\tstruct msg msg;\n\n\t\tif (recv_message(sock, &msg) < 0)\n\t\t\tgoto out;\n\n\t\tswitch (msg.type) {\n\t\tcase MSG_EXIT:\n\t\t\tif (env.debug)\n\t\t\t\tfprintf(stderr, \"[%d]: worker exit.\\n\",\n\t\t\t\t\tenv.worker_id);\n\t\t\tgoto out;\n\t\tcase MSG_DO_TEST: {\n\t\t\tint test_to_run = msg.do_test.num;\n\t\t\tstruct prog_test_def *test = &prog_test_defs[test_to_run];\n\t\t\tstruct test_state *state = &test_states[test_to_run];\n\t\t\tstruct msg msg;\n\n\t\t\tif (env.debug)\n\t\t\t\tfprintf(stderr, \"[%d]: #%d:%s running.\\n\",\n\t\t\t\t\tenv.worker_id,\n\t\t\t\t\ttest_to_run + 1,\n\t\t\t\t\ttest->test_name);\n\n\t\t\trun_one_test(test_to_run);\n\n\t\t\tmemset(&msg, 0, sizeof(msg));\n\t\t\tmsg.type = MSG_TEST_DONE;\n\t\t\tmsg.test_done.num = test_to_run;\n\t\t\tmsg.test_done.error_cnt = state->error_cnt;\n\t\t\tmsg.test_done.skip_cnt = state->skip_cnt;\n\t\t\tmsg.test_done.sub_succ_cnt = state->sub_succ_cnt;\n\t\t\tmsg.test_done.subtest_num = state->subtest_num;\n\t\t\tmsg.test_done.have_log = false;\n\n\t\t\tif (verbose() || state->force_log || state->error_cnt) {\n\t\t\t\tif (state->log_cnt)\n\t\t\t\t\tmsg.test_done.have_log = true;\n\t\t\t}\n\t\t\tif (send_message(sock, &msg) < 0) {\n\t\t\t\tperror(\"Fail to send message done\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (msg.test_done.have_log)\n\t\t\t\tworker_main_send_log(sock, state->log_buf, state->log_cnt);\n\n\t\t\tif (state->log_buf) {\n\t\t\t\tfree(state->log_buf);\n\t\t\t\tstate->log_buf = NULL;\n\t\t\t\tstate->log_cnt = 0;\n\t\t\t}\n\n\t\t\tif (state->subtest_num)\n\t\t\t\tif (worker_main_send_subtests(sock, state))\n\t\t\t\t\tgoto out;\n\n\t\t\tif (env.debug)\n\t\t\t\tfprintf(stderr, \"[%d]: #%d:%s done.\\n\",\n\t\t\t\t\tenv.worker_id,\n\t\t\t\t\ttest_to_run + 1,\n\t\t\t\t\ttest->test_name);\n\t\t\tbreak;\n\t\t}  \n\t\tdefault:\n\t\t\tif (env.debug)\n\t\t\t\tfprintf(stderr, \"[%d]: unknown message.\\n\",  env.worker_id);\n\t\t\treturn -1;\n\t\t}\n\t}\nout:\n\treturn 0;\n}\n\nstatic void free_test_states(void)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(prog_test_defs); i++) {\n\t\tstruct test_state *test_state = &test_states[i];\n\n\t\tfor (j = 0; j < test_state->subtest_num; j++)\n\t\t\tfree_subtest_state(&test_state->subtest_states[j]);\n\n\t\tfree(test_state->subtest_states);\n\t\tfree(test_state->log_buf);\n\t\ttest_state->subtest_states = NULL;\n\t\ttest_state->log_buf = NULL;\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tstatic const struct argp argp = {\n\t\t.options = opts,\n\t\t.parser = parse_arg,\n\t\t.doc = argp_program_doc,\n\t};\n\tstruct sigaction sigact = {\n\t\t.sa_handler = crash_handler,\n\t\t.sa_flags = SA_RESETHAND,\n\t\t};\n\tint err, i;\n\n\tsigaction(SIGSEGV, &sigact, NULL);\n\n\terr = argp_parse(&argp, argc, argv, 0, NULL, &env);\n\tif (err)\n\t\treturn err;\n\n\terr = cd_flavor_subdir(argv[0]);\n\tif (err)\n\t\treturn err;\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\tlibbpf_set_print(libbpf_print_fn);\n\n\tsrand(time(NULL));\n\n\tenv.jit_enabled = is_jit_enabled();\n\tenv.nr_cpus = libbpf_num_possible_cpus();\n\tif (env.nr_cpus < 0) {\n\t\tfprintf(stderr, \"Failed to get number of CPUs: %d!\\n\",\n\t\t\tenv.nr_cpus);\n\t\treturn -1;\n\t}\n\n\tenv.stdout = stdout;\n\tenv.stderr = stderr;\n\n\tenv.has_testmod = true;\n\tif (!env.list_test_names) {\n\t\t \n\t\tunload_bpf_testmod(verbose());\n\n\t\tif (load_bpf_testmod(verbose())) {\n\t\t\tfprintf(env.stderr, \"WARNING! Selftests relying on bpf_testmod.ko will be skipped.\\n\");\n\t\t\tenv.has_testmod = false;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < prog_test_cnt; i++) {\n\t\tstruct prog_test_def *test = &prog_test_defs[i];\n\n\t\ttest->test_num = i + 1;\n\t\ttest->should_run = should_run(&env.test_selector,\n\t\t\t\t\t      test->test_num, test->test_name);\n\n\t\tif ((test->run_test == NULL && test->run_serial_test == NULL) ||\n\t\t    (test->run_test != NULL && test->run_serial_test != NULL)) {\n\t\t\tfprintf(stderr, \"Test %d:%s must have either test_%s() or serial_test_%sl() defined.\\n\",\n\t\t\t\ttest->test_num, test->test_name, test->test_name, test->test_name);\n\t\t\texit(EXIT_ERR_SETUP_INFRA);\n\t\t}\n\t}\n\n\t \n\tif (env.get_test_cnt || env.list_test_names)\n\t\tenv.workers = 0;\n\n\t \n\tenv.worker_id = -1;  \n\tif (env.workers) {\n\t\tenv.worker_pids = calloc(sizeof(__pid_t), env.workers);\n\t\tenv.worker_socks = calloc(sizeof(int), env.workers);\n\t\tif (env.debug)\n\t\t\tfprintf(stdout, \"Launching %d workers.\\n\", env.workers);\n\t\tfor (i = 0; i < env.workers; i++) {\n\t\t\tint sv[2];\n\t\t\tpid_t pid;\n\n\t\t\tif (socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, sv) < 0) {\n\t\t\t\tperror(\"Fail to create worker socket\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\tperror(\"Failed to fork worker\");\n\t\t\t\treturn -1;\n\t\t\t} else if (pid != 0) {  \n\t\t\t\tclose(sv[1]);\n\t\t\t\tenv.worker_pids[i] = pid;\n\t\t\t\tenv.worker_socks[i] = sv[0];\n\t\t\t} else {  \n\t\t\t\tclose(sv[0]);\n\t\t\t\tenv.worker_id = i;\n\t\t\t\treturn worker_main(sv[1]);\n\t\t\t}\n\t\t}\n\n\t\tif (env.worker_id == -1) {\n\t\t\tserver_main();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\n\t \n\tsave_netns();\n\n\tfor (i = 0; i < prog_test_cnt; i++) {\n\t\tstruct prog_test_def *test = &prog_test_defs[i];\n\n\t\tif (!test->should_run)\n\t\t\tcontinue;\n\n\t\tif (env.get_test_cnt) {\n\t\t\tenv.succ_cnt++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (env.list_test_names) {\n\t\t\tfprintf(env.stdout, \"%s\\n\", test->test_name);\n\t\t\tenv.succ_cnt++;\n\t\t\tcontinue;\n\t\t}\n\n\t\trun_one_test(i);\n\t}\n\n\tif (env.get_test_cnt) {\n\t\tprintf(\"%d\\n\", env.succ_cnt);\n\t\tgoto out;\n\t}\n\n\tif (env.list_test_names)\n\t\tgoto out;\n\n\tcalculate_summary_and_print_errors(&env);\n\n\tclose(env.saved_netns_fd);\nout:\n\tif (!env.list_test_names && env.has_testmod)\n\t\tunload_bpf_testmod(verbose());\n\n\tfree_test_selector(&env.test_selector);\n\tfree_test_selector(&env.subtest_selector);\n\tfree_test_states();\n\n\tif (env.succ_cnt + env.fail_cnt + env.skip_cnt == 0)\n\t\treturn EXIT_NO_TEST;\n\n\treturn env.fail_cnt ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}