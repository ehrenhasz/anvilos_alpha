{
  "module_name": "xdp_synproxy.c",
  "hash_id": "38757d1d0b34f591f323c579193d700fd5dd68a8d799b43a0b16b4015dd2cf5b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/xdp_synproxy.c",
  "human_readable_source": "\n \n\n#include <stdnoreturn.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <net/if.h>\n#include <linux/if_link.h>\n#include <linux/limits.h>\n\nstatic unsigned int ifindex;\nstatic __u32 attached_prog_id;\nstatic bool attached_tc;\n\nstatic void noreturn cleanup(int sig)\n{\n\tLIBBPF_OPTS(bpf_xdp_attach_opts, opts);\n\tint prog_fd;\n\tint err;\n\n\tif (attached_prog_id == 0)\n\t\texit(0);\n\n\tif (attached_tc) {\n\t\tLIBBPF_OPTS(bpf_tc_hook, hook,\n\t\t\t    .ifindex = ifindex,\n\t\t\t    .attach_point = BPF_TC_INGRESS);\n\n\t\terr = bpf_tc_hook_destroy(&hook);\n\t\tif (err < 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_tc_hook_destroy: %s\\n\", strerror(-err));\n\t\t\tfprintf(stderr, \"Failed to destroy the TC hook\\n\");\n\t\t\texit(1);\n\t\t}\n\t\texit(0);\n\t}\n\n\tprog_fd = bpf_prog_get_fd_by_id(attached_prog_id);\n\tif (prog_fd < 0) {\n\t\tfprintf(stderr, \"Error: bpf_prog_get_fd_by_id: %s\\n\", strerror(-prog_fd));\n\t\terr = bpf_xdp_attach(ifindex, -1, 0, NULL);\n\t\tif (err < 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_set_link_xdp_fd: %s\\n\", strerror(-err));\n\t\t\tfprintf(stderr, \"Failed to detach XDP program\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\topts.old_prog_fd = prog_fd;\n\t\terr = bpf_xdp_attach(ifindex, -1, XDP_FLAGS_REPLACE, &opts);\n\t\tclose(prog_fd);\n\t\tif (err < 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_set_link_xdp_fd_opts: %s\\n\", strerror(-err));\n\t\t\t \n\t\t\tif (err != -EEXIST) {\n\t\t\t\tfprintf(stderr, \"Failed to detach XDP program\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\texit(0);\n}\n\nstatic noreturn void usage(const char *progname)\n{\n\tfprintf(stderr, \"Usage: %s [--iface <iface>|--prog <prog_id>] [--mss4 <mss ipv4> --mss6 <mss ipv6> --wscale <wscale> --ttl <ttl>] [--ports <port1>,<port2>,...] [--single] [--tc]\\n\",\n\t\tprogname);\n\texit(1);\n}\n\nstatic unsigned long parse_arg_ul(const char *progname, const char *arg, unsigned long limit)\n{\n\tunsigned long res;\n\tchar *endptr;\n\n\terrno = 0;\n\tres = strtoul(arg, &endptr, 10);\n\tif (errno != 0 || *endptr != '\\0' || arg[0] == '\\0' || res > limit)\n\t\tusage(progname);\n\n\treturn res;\n}\n\nstatic void parse_options(int argc, char *argv[], unsigned int *ifindex, __u32 *prog_id,\n\t\t\t  __u64 *tcpipopts, char **ports, bool *single, bool *tc)\n{\n\tstatic struct option long_options[] = {\n\t\t{ \"help\", no_argument, NULL, 'h' },\n\t\t{ \"iface\", required_argument, NULL, 'i' },\n\t\t{ \"prog\", required_argument, NULL, 'x' },\n\t\t{ \"mss4\", required_argument, NULL, 4 },\n\t\t{ \"mss6\", required_argument, NULL, 6 },\n\t\t{ \"wscale\", required_argument, NULL, 'w' },\n\t\t{ \"ttl\", required_argument, NULL, 't' },\n\t\t{ \"ports\", required_argument, NULL, 'p' },\n\t\t{ \"single\", no_argument, NULL, 's' },\n\t\t{ \"tc\", no_argument, NULL, 'c' },\n\t\t{ NULL, 0, NULL, 0 },\n\t};\n\tunsigned long mss4, wscale, ttl;\n\tunsigned long long mss6;\n\tunsigned int tcpipopts_mask = 0;\n\n\tif (argc < 2)\n\t\tusage(argv[0]);\n\n\t*ifindex = 0;\n\t*prog_id = 0;\n\t*tcpipopts = 0;\n\t*ports = NULL;\n\t*single = false;\n\t*tc = false;\n\n\twhile (true) {\n\t\tint opt;\n\n\t\topt = getopt_long(argc, argv, \"\", long_options, NULL);\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\t*ifindex = if_nametoindex(optarg);\n\t\t\tif (*ifindex == 0)\n\t\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\t*prog_id = parse_arg_ul(argv[0], optarg, UINT32_MAX);\n\t\t\tif (*prog_id == 0)\n\t\t\t\tusage(argv[0]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmss4 = parse_arg_ul(argv[0], optarg, UINT16_MAX);\n\t\t\ttcpipopts_mask |= 1 << 0;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tmss6 = parse_arg_ul(argv[0], optarg, UINT16_MAX);\n\t\t\ttcpipopts_mask |= 1 << 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twscale = parse_arg_ul(argv[0], optarg, 14);\n\t\t\ttcpipopts_mask |= 1 << 2;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tttl = parse_arg_ul(argv[0], optarg, UINT8_MAX);\n\t\t\ttcpipopts_mask |= 1 << 3;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\t*ports = optarg;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\t*single = true;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\t*tc = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\tif (optind < argc)\n\t\tusage(argv[0]);\n\n\tif (tcpipopts_mask == 0xf) {\n\t\tif (mss4 == 0 || mss6 == 0 || wscale == 0 || ttl == 0)\n\t\t\tusage(argv[0]);\n\t\t*tcpipopts = (mss6 << 32) | (ttl << 24) | (wscale << 16) | mss4;\n\t} else if (tcpipopts_mask != 0) {\n\t\tusage(argv[0]);\n\t}\n\n\tif (*ifindex != 0 && *prog_id != 0)\n\t\tusage(argv[0]);\n\tif (*ifindex == 0 && *prog_id == 0)\n\t\tusage(argv[0]);\n}\n\nstatic int syncookie_attach(const char *argv0, unsigned int ifindex, bool tc)\n{\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tchar xdp_filename[PATH_MAX];\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tint prog_fd;\n\tint err;\n\n\tsnprintf(xdp_filename, sizeof(xdp_filename), \"%s_kern.bpf.o\", argv0);\n\tobj = bpf_object__open_file(xdp_filename, NULL);\n\terr = libbpf_get_error(obj);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"Error: bpf_object__open_file: %s\\n\", strerror(-err));\n\t\treturn err;\n\t}\n\n\terr = bpf_object__load(obj);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"Error: bpf_object__open_file: %s\\n\", strerror(-err));\n\t\treturn err;\n\t}\n\n\tprog = bpf_object__find_program_by_name(obj, tc ? \"syncookie_tc\" : \"syncookie_xdp\");\n\tif (!prog) {\n\t\tfprintf(stderr, \"Error: bpf_object__find_program_by_name: program was not found\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tprog_fd = bpf_program__fd(prog);\n\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"Error: bpf_prog_get_info_by_fd: %s\\n\",\n\t\t\tstrerror(-err));\n\t\tgoto out;\n\t}\n\tattached_tc = tc;\n\tattached_prog_id = info.id;\n\tsignal(SIGINT, cleanup);\n\tsignal(SIGTERM, cleanup);\n\tif (tc) {\n\t\tLIBBPF_OPTS(bpf_tc_hook, hook,\n\t\t\t    .ifindex = ifindex,\n\t\t\t    .attach_point = BPF_TC_INGRESS);\n\t\tLIBBPF_OPTS(bpf_tc_opts, opts,\n\t\t\t    .handle = 1,\n\t\t\t    .priority = 1,\n\t\t\t    .prog_fd = prog_fd);\n\n\t\terr = bpf_tc_hook_create(&hook);\n\t\tif (err < 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_tc_hook_create: %s\\n\",\n\t\t\t\tstrerror(-err));\n\t\t\tgoto fail;\n\t\t}\n\t\terr = bpf_tc_attach(&hook, &opts);\n\t\tif (err < 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_tc_attach: %s\\n\",\n\t\t\t\tstrerror(-err));\n\t\t\tgoto fail;\n\t\t}\n\n\t} else {\n\t\terr = bpf_xdp_attach(ifindex, prog_fd,\n\t\t\t\t     XDP_FLAGS_UPDATE_IF_NOEXIST, NULL);\n\t\tif (err < 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_set_link_xdp_fd: %s\\n\",\n\t\t\t\tstrerror(-err));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\terr = 0;\nout:\n\tbpf_object__close(obj);\n\treturn err;\nfail:\n\tsignal(SIGINT, SIG_DFL);\n\tsignal(SIGTERM, SIG_DFL);\n\tattached_prog_id = 0;\n\tgoto out;\n}\n\nstatic int syncookie_open_bpf_maps(__u32 prog_id, int *values_map_fd, int *ports_map_fd)\n{\n\tstruct bpf_prog_info prog_info;\n\t__u32 map_ids[8];\n\t__u32 info_len;\n\tint prog_fd;\n\tint err;\n\tint i;\n\n\t*values_map_fd = -1;\n\t*ports_map_fd = -1;\n\n\tprog_fd = bpf_prog_get_fd_by_id(prog_id);\n\tif (prog_fd < 0) {\n\t\tfprintf(stderr, \"Error: bpf_prog_get_fd_by_id: %s\\n\", strerror(-prog_fd));\n\t\treturn prog_fd;\n\t}\n\n\tprog_info = (struct bpf_prog_info) {\n\t\t.nr_map_ids = 8,\n\t\t.map_ids = (__u64)(unsigned long)map_ids,\n\t};\n\tinfo_len = sizeof(prog_info);\n\n\terr = bpf_prog_get_info_by_fd(prog_fd, &prog_info, &info_len);\n\tif (err != 0) {\n\t\tfprintf(stderr, \"Error: bpf_prog_get_info_by_fd: %s\\n\",\n\t\t\tstrerror(-err));\n\t\tgoto out;\n\t}\n\n\tif (prog_info.nr_map_ids < 2) {\n\t\tfprintf(stderr, \"Error: Found %u BPF maps, expected at least 2\\n\",\n\t\t\tprog_info.nr_map_ids);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < prog_info.nr_map_ids; i++) {\n\t\tstruct bpf_map_info map_info = {};\n\t\tint map_fd;\n\n\t\terr = bpf_map_get_fd_by_id(map_ids[i]);\n\t\tif (err < 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_map_get_fd_by_id: %s\\n\", strerror(-err));\n\t\t\tgoto err_close_map_fds;\n\t\t}\n\t\tmap_fd = err;\n\n\t\tinfo_len = sizeof(map_info);\n\t\terr = bpf_map_get_info_by_fd(map_fd, &map_info, &info_len);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_map_get_info_by_fd: %s\\n\",\n\t\t\t\tstrerror(-err));\n\t\t\tclose(map_fd);\n\t\t\tgoto err_close_map_fds;\n\t\t}\n\t\tif (strcmp(map_info.name, \"values\") == 0) {\n\t\t\t*values_map_fd = map_fd;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(map_info.name, \"allowed_ports\") == 0) {\n\t\t\t*ports_map_fd = map_fd;\n\t\t\tcontinue;\n\t\t}\n\t\tclose(map_fd);\n\t}\n\n\tif (*values_map_fd != -1 && *ports_map_fd != -1) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = -ENOENT;\n\nerr_close_map_fds:\n\tif (*values_map_fd != -1)\n\t\tclose(*values_map_fd);\n\tif (*ports_map_fd != -1)\n\t\tclose(*ports_map_fd);\n\t*values_map_fd = -1;\n\t*ports_map_fd = -1;\n\nout:\n\tclose(prog_fd);\n\treturn err;\n}\n\nint main(int argc, char *argv[])\n{\n\tint values_map_fd, ports_map_fd;\n\t__u64 tcpipopts;\n\tbool firstiter;\n\t__u64 prevcnt;\n\t__u32 prog_id;\n\tchar *ports;\n\tbool single;\n\tint err = 0;\n\tbool tc;\n\n\tparse_options(argc, argv, &ifindex, &prog_id, &tcpipopts, &ports,\n\t\t      &single, &tc);\n\n\tif (prog_id == 0) {\n\t\tif (!tc) {\n\t\t\terr = bpf_xdp_query_id(ifindex, 0, &prog_id);\n\t\t\tif (err < 0) {\n\t\t\t\tfprintf(stderr, \"Error: bpf_get_link_xdp_id: %s\\n\",\n\t\t\t\t\tstrerror(-err));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (prog_id == 0) {\n\t\t\terr = syncookie_attach(argv[0], ifindex, tc);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\tprog_id = attached_prog_id;\n\t\t}\n\t}\n\n\terr = syncookie_open_bpf_maps(prog_id, &values_map_fd, &ports_map_fd);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (ports) {\n\t\t__u16 port_last = 0;\n\t\t__u32 port_idx = 0;\n\t\tchar *p = ports;\n\n\t\tfprintf(stderr, \"Replacing allowed ports\\n\");\n\n\t\twhile (p && *p != '\\0') {\n\t\t\tchar *token = strsep(&p, \",\");\n\t\t\t__u16 port;\n\n\t\t\tport = parse_arg_ul(argv[0], token, UINT16_MAX);\n\t\t\terr = bpf_map_update_elem(ports_map_fd, &port_idx, &port, BPF_ANY);\n\t\t\tif (err != 0) {\n\t\t\t\tfprintf(stderr, \"Error: bpf_map_update_elem: %s\\n\", strerror(-err));\n\t\t\t\tfprintf(stderr, \"Failed to add port %u (index %u)\\n\",\n\t\t\t\t\tport, port_idx);\n\t\t\t\tgoto out_close_maps;\n\t\t\t}\n\t\t\tfprintf(stderr, \"Added port %u\\n\", port);\n\t\t\tport_idx++;\n\t\t}\n\t\terr = bpf_map_update_elem(ports_map_fd, &port_idx, &port_last, BPF_ANY);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_map_update_elem: %s\\n\", strerror(-err));\n\t\t\tfprintf(stderr, \"Failed to add the terminator value 0 (index %u)\\n\",\n\t\t\t\tport_idx);\n\t\t\tgoto out_close_maps;\n\t\t}\n\t}\n\n\tif (tcpipopts) {\n\t\t__u32 key = 0;\n\n\t\tfprintf(stderr, \"Replacing TCP/IP options\\n\");\n\n\t\terr = bpf_map_update_elem(values_map_fd, &key, &tcpipopts, BPF_ANY);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_map_update_elem: %s\\n\", strerror(-err));\n\t\t\tgoto out_close_maps;\n\t\t}\n\t}\n\n\tif ((ports || tcpipopts) && attached_prog_id == 0 && !single)\n\t\tgoto out_close_maps;\n\n\tprevcnt = 0;\n\tfirstiter = true;\n\twhile (true) {\n\t\t__u32 key = 1;\n\t\t__u64 value;\n\n\t\terr = bpf_map_lookup_elem(values_map_fd, &key, &value);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"Error: bpf_map_lookup_elem: %s\\n\", strerror(-err));\n\t\t\tgoto out_close_maps;\n\t\t}\n\t\tif (firstiter) {\n\t\t\tprevcnt = value;\n\t\t\tfirstiter = false;\n\t\t}\n\t\tif (single) {\n\t\t\tprintf(\"Total SYNACKs generated: %llu\\n\", value);\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"SYNACKs generated: %llu (total %llu)\\n\", value - prevcnt, value);\n\t\tprevcnt = value;\n\t\tsleep(1);\n\t}\n\nout_close_maps:\n\tclose(values_map_fd);\n\tclose(ports_map_fd);\nout:\n\treturn err == 0 ? 0 : 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}