{
  "module_name": "xdp_redirect_multi.c",
  "hash_id": "61821889727d6406bc83684547c549eae74f3079e7e7da8cb23a266ca6e4e28b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/xdp_redirect_multi.c",
  "human_readable_source": "\n#include <linux/bpf.h>\n#include <linux/if_link.h>\n#include <assert.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <net/if.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n#include \"bpf_util.h\"\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#define MAX_IFACE_NUM 32\n#define MAX_INDEX_NUM 1024\n\nstatic __u32 xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;\nstatic int ifaces[MAX_IFACE_NUM] = {};\n\nstatic void int_exit(int sig)\n{\n\t__u32 prog_id = 0;\n\tint i;\n\n\tfor (i = 0; ifaces[i] > 0; i++) {\n\t\tif (bpf_xdp_query_id(ifaces[i], xdp_flags, &prog_id)) {\n\t\t\tprintf(\"bpf_xdp_query_id failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (prog_id)\n\t\t\tbpf_xdp_detach(ifaces[i], xdp_flags, NULL);\n\t}\n\n\texit(0);\n}\n\nstatic int get_mac_addr(unsigned int ifindex, void *mac_addr)\n{\n\tchar ifname[IF_NAMESIZE];\n\tstruct ifreq ifr;\n\tint fd, ret = -1;\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0)\n\t\treturn ret;\n\n\tif (!if_indextoname(ifindex, ifname))\n\t\tgoto err_out;\n\n\tstrcpy(ifr.ifr_name, ifname);\n\n\tif (ioctl(fd, SIOCGIFHWADDR, &ifr) != 0)\n\t\tgoto err_out;\n\n\tmemcpy(mac_addr, ifr.ifr_hwaddr.sa_data, 6 * sizeof(char));\n\tret = 0;\n\nerr_out:\n\tclose(fd);\n\treturn ret;\n}\n\nstatic void usage(const char *prog)\n{\n\tfprintf(stderr,\n\t\t\"usage: %s [OPTS] <IFNAME|IFINDEX> <IFNAME|IFINDEX> ...\\n\"\n\t\t\"OPTS:\\n\"\n\t\t\"    -S    use skb-mode\\n\"\n\t\t\"    -N    enforce native mode\\n\"\n\t\t\"    -F    force loading prog\\n\"\n\t\t\"    -X    load xdp program on egress\\n\",\n\t\tprog);\n}\n\nint main(int argc, char **argv)\n{\n\tint prog_fd, group_all, mac_map;\n\tstruct bpf_program *ingress_prog, *egress_prog;\n\tint i, err, ret, opt, egress_prog_fd = 0;\n\tstruct bpf_devmap_val devmap_val;\n\tbool attach_egress_prog = false;\n\tunsigned char mac_addr[6];\n\tchar ifname[IF_NAMESIZE];\n\tstruct bpf_object *obj;\n\tunsigned int ifindex;\n\tchar filename[256];\n\n\twhile ((opt = getopt(argc, argv, \"SNFX\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'S':\n\t\t\txdp_flags |= XDP_FLAGS_SKB_MODE;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\t \n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\txdp_flags &= ~XDP_FLAGS_UPDATE_IF_NOEXIST;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tattach_egress_prog = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(basename(argv[0]));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!(xdp_flags & XDP_FLAGS_SKB_MODE)) {\n\t\txdp_flags |= XDP_FLAGS_DRV_MODE;\n\t} else if (attach_egress_prog) {\n\t\tprintf(\"Load xdp program on egress with SKB mode not supported yet\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (optind == argc) {\n\t\tprintf(\"usage: %s <IFNAME|IFINDEX> <IFNAME|IFINDEX> ...\\n\", argv[0]);\n\t\tgoto err_out;\n\t}\n\n\tprintf(\"Get interfaces:\");\n\tfor (i = 0; i < MAX_IFACE_NUM && argv[optind + i]; i++) {\n\t\tifaces[i] = if_nametoindex(argv[optind + i]);\n\t\tif (!ifaces[i])\n\t\t\tifaces[i] = strtoul(argv[optind + i], NULL, 0);\n\t\tif (!if_indextoname(ifaces[i], ifname)) {\n\t\t\tperror(\"Invalid interface name or i\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tif (ifaces[i] > MAX_INDEX_NUM) {\n\t\t\tprintf(\" interface index too large\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tprintf(\" %d\", ifaces[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.bpf.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\terr = libbpf_get_error(obj);\n\tif (err)\n\t\tgoto err_out;\n\terr = bpf_object__load(obj);\n\tif (err)\n\t\tgoto err_out;\n\tprog_fd = bpf_program__fd(bpf_object__next_program(obj, NULL));\n\n\tif (attach_egress_prog)\n\t\tgroup_all = bpf_object__find_map_fd_by_name(obj, \"map_egress\");\n\telse\n\t\tgroup_all = bpf_object__find_map_fd_by_name(obj, \"map_all\");\n\tmac_map = bpf_object__find_map_fd_by_name(obj, \"mac_map\");\n\n\tif (group_all < 0 || mac_map < 0) {\n\t\tprintf(\"bpf_object__find_map_fd_by_name failed\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (attach_egress_prog) {\n\t\t \n\t\tingress_prog = bpf_object__find_program_by_name(obj, \"xdp_redirect_map_all_prog\");\n\t\tegress_prog = bpf_object__find_program_by_name(obj, \"xdp_devmap_prog\");\n\t\tif (!ingress_prog || !egress_prog) {\n\t\t\tprintf(\"finding ingress/egress_prog in obj file failed\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tprog_fd = bpf_program__fd(ingress_prog);\n\t\tegress_prog_fd = bpf_program__fd(egress_prog);\n\t\tif (prog_fd < 0 || egress_prog_fd < 0) {\n\t\t\tprintf(\"find egress_prog fd failed\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tsignal(SIGINT, int_exit);\n\tsignal(SIGTERM, int_exit);\n\n\t \n\tfor (i = 0; ifaces[i] > 0; i++) {\n\t\tifindex = ifaces[i];\n\n\t\tif (attach_egress_prog) {\n\t\t\tret = get_mac_addr(ifindex, mac_addr);\n\t\t\tif (ret < 0) {\n\t\t\t\tprintf(\"get interface %d mac failed\\n\", ifindex);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tret = bpf_map_update_elem(mac_map, &ifindex, mac_addr, 0);\n\t\t\tif (ret) {\n\t\t\t\tperror(\"bpf_update_elem mac_map failed\\n\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdevmap_val.ifindex = ifindex;\n\t\tdevmap_val.bpf_prog.fd = egress_prog_fd;\n\t\tret = bpf_map_update_elem(group_all, &ifindex, &devmap_val, 0);\n\t\tif (ret) {\n\t\t\tperror(\"bpf_map_update_elem\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\tret = bpf_xdp_attach(ifindex, prog_fd, xdp_flags, NULL);\n\t\tif (ret) {\n\t\t\tprintf(\"Set xdp fd failed on %d\\n\", ifindex);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t \n\tsleep(999);\n\n\treturn 0;\n\nerr_out:\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}