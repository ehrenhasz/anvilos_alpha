{
  "module_name": "xdp_features.c",
  "hash_id": "a318ecbc043fda0e828b1fc27271b8660a764b29dd967a2d715020595fc6cde5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/xdp_features.c",
  "human_readable_source": "\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/netdev.h>\n#include <linux/if_link.h>\n#include <signal.h>\n#include <argp.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <pthread.h>\n\n#include <network_helpers.h>\n\n#include \"xdp_features.skel.h\"\n#include \"xdp_features.h\"\n\n#define RED(str)\t\"\\033[0;31m\" str \"\\033[0m\"\n#define GREEN(str)\t\"\\033[0;32m\" str \"\\033[0m\"\n#define YELLOW(str)\t\"\\033[0;33m\" str \"\\033[0m\"\n\nstatic struct env {\n\tbool verbosity;\n\tchar ifname[IF_NAMESIZE];\n\tint ifindex;\n\tbool is_tester;\n\tstruct {\n\t\tenum netdev_xdp_act drv_feature;\n\t\tenum xdp_action action;\n\t} feature;\n\tstruct sockaddr_storage dut_ctrl_addr;\n\tstruct sockaddr_storage dut_addr;\n\tstruct sockaddr_storage tester_addr;\n} env;\n\n#define BUFSIZE\t\t128\n\nvoid test__fail(void) {   }\n\nstatic int libbpf_print_fn(enum libbpf_print_level level,\n\t\t\t   const char *format, va_list args)\n{\n\tif (level == LIBBPF_DEBUG && !env.verbosity)\n\t\treturn 0;\n\treturn vfprintf(stderr, format, args);\n}\n\nstatic volatile bool exiting;\n\nstatic void sig_handler(int sig)\n{\n\texiting = true;\n}\n\nconst char *argp_program_version = \"xdp-features 0.0\";\nconst char argp_program_doc[] =\n\"XDP features detection application.\\n\"\n\"\\n\"\n\"XDP features application checks the XDP advertised features match detected ones.\\n\"\n\"\\n\"\n\"USAGE: ./xdp-features [-vt] [-f <xdp-feature>] [-D <dut-data-ip>] [-T <tester-data-ip>] [-C <dut-ctrl-ip>] <iface-name>\\n\"\n\"\\n\"\n\"dut-data-ip, tester-data-ip, dut-ctrl-ip: IPv6 or IPv4-mapped-IPv6 addresses;\\n\"\n\"\\n\"\n\"XDP features\\n:\"\n\"- XDP_PASS\\n\"\n\"- XDP_DROP\\n\"\n\"- XDP_ABORTED\\n\"\n\"- XDP_REDIRECT\\n\"\n\"- XDP_NDO_XMIT\\n\"\n\"- XDP_TX\\n\";\n\nstatic const struct argp_option opts[] = {\n\t{ \"verbose\", 'v', NULL, 0, \"Verbose debug output\" },\n\t{ \"tester\", 't', NULL, 0, \"Tester mode\" },\n\t{ \"feature\", 'f', \"XDP-FEATURE\", 0, \"XDP feature to test\" },\n\t{ \"dut_data_ip\", 'D', \"DUT-DATA-IP\", 0, \"DUT IP data channel\" },\n\t{ \"dut_ctrl_ip\", 'C', \"DUT-CTRL-IP\", 0, \"DUT IP control channel\" },\n\t{ \"tester_data_ip\", 'T', \"TESTER-DATA-IP\", 0, \"Tester IP data channel\" },\n\t{},\n};\n\nstatic int get_xdp_feature(const char *arg)\n{\n\tif (!strcmp(arg, \"XDP_PASS\")) {\n\t\tenv.feature.action = XDP_PASS;\n\t\tenv.feature.drv_feature = NETDEV_XDP_ACT_BASIC;\n\t} else if (!strcmp(arg, \"XDP_DROP\")) {\n\t\tenv.feature.drv_feature = NETDEV_XDP_ACT_BASIC;\n\t\tenv.feature.action = XDP_DROP;\n\t} else if (!strcmp(arg, \"XDP_ABORTED\")) {\n\t\tenv.feature.drv_feature = NETDEV_XDP_ACT_BASIC;\n\t\tenv.feature.action = XDP_ABORTED;\n\t} else if (!strcmp(arg, \"XDP_TX\")) {\n\t\tenv.feature.drv_feature = NETDEV_XDP_ACT_BASIC;\n\t\tenv.feature.action = XDP_TX;\n\t} else if (!strcmp(arg, \"XDP_REDIRECT\")) {\n\t\tenv.feature.drv_feature = NETDEV_XDP_ACT_REDIRECT;\n\t\tenv.feature.action = XDP_REDIRECT;\n\t} else if (!strcmp(arg, \"XDP_NDO_XMIT\")) {\n\t\tenv.feature.drv_feature = NETDEV_XDP_ACT_NDO_XMIT;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic char *get_xdp_feature_str(void)\n{\n\tswitch (env.feature.action) {\n\tcase XDP_PASS:\n\t\treturn YELLOW(\"XDP_PASS\");\n\tcase XDP_DROP:\n\t\treturn YELLOW(\"XDP_DROP\");\n\tcase XDP_ABORTED:\n\t\treturn YELLOW(\"XDP_ABORTED\");\n\tcase XDP_TX:\n\t\treturn YELLOW(\"XDP_TX\");\n\tcase XDP_REDIRECT:\n\t\treturn YELLOW(\"XDP_REDIRECT\");\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (env.feature.drv_feature == NETDEV_XDP_ACT_NDO_XMIT)\n\t\treturn YELLOW(\"XDP_NDO_XMIT\");\n\n\treturn \"\";\n}\n\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n\tswitch (key) {\n\tcase 'v':\n\t\tenv.verbosity = true;\n\t\tbreak;\n\tcase 't':\n\t\tenv.is_tester = true;\n\t\tbreak;\n\tcase 'f':\n\t\tif (get_xdp_feature(arg) < 0) {\n\t\t\tfprintf(stderr, \"Invalid xdp feature: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t\treturn ARGP_ERR_UNKNOWN;\n\t\t}\n\t\tbreak;\n\tcase 'D':\n\t\tif (make_sockaddr(AF_INET6, arg, DUT_ECHO_PORT,\n\t\t\t\t  &env.dut_addr, NULL)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Invalid address assigned to the Device Under Test: %s\\n\",\n\t\t\t\targ);\n\t\t\treturn ARGP_ERR_UNKNOWN;\n\t\t}\n\t\tbreak;\n\tcase 'C':\n\t\tif (make_sockaddr(AF_INET6, arg, DUT_CTRL_PORT,\n\t\t\t\t  &env.dut_ctrl_addr, NULL)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Invalid address assigned to the Device Under Test: %s\\n\",\n\t\t\t\targ);\n\t\t\treturn ARGP_ERR_UNKNOWN;\n\t\t}\n\t\tbreak;\n\tcase 'T':\n\t\tif (make_sockaddr(AF_INET6, arg, 0, &env.tester_addr, NULL)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Invalid address assigned to the Tester device: %s\\n\",\n\t\t\t\targ);\n\t\t\treturn ARGP_ERR_UNKNOWN;\n\t\t}\n\t\tbreak;\n\tcase ARGP_KEY_ARG:\n\t\terrno = 0;\n\t\tif (strlen(arg) >= IF_NAMESIZE) {\n\t\t\tfprintf(stderr, \"Invalid device name: %s\\n\", arg);\n\t\t\targp_usage(state);\n\t\t\treturn ARGP_ERR_UNKNOWN;\n\t\t}\n\n\t\tenv.ifindex = if_nametoindex(arg);\n\t\tif (!env.ifindex)\n\t\t\tenv.ifindex = strtoul(arg, NULL, 0);\n\t\tif (!env.ifindex || !if_indextoname(env.ifindex, env.ifname)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Bad interface index or name (%d): %s\\n\",\n\t\t\t\terrno, strerror(errno));\n\t\t\targp_usage(state);\n\t\t\treturn ARGP_ERR_UNKNOWN;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct argp argp = {\n\t.options = opts,\n\t.parser = parse_arg,\n\t.doc = argp_program_doc,\n};\n\nstatic void set_env_default(void)\n{\n\tenv.feature.drv_feature = NETDEV_XDP_ACT_NDO_XMIT;\n\tenv.feature.action = -EINVAL;\n\tenv.ifindex = -ENODEV;\n\tstrcpy(env.ifname, \"unknown\");\n\tmake_sockaddr(AF_INET6, \"::ffff:127.0.0.1\", DUT_CTRL_PORT,\n\t\t      &env.dut_ctrl_addr, NULL);\n\tmake_sockaddr(AF_INET6, \"::ffff:127.0.0.1\", DUT_ECHO_PORT,\n\t\t      &env.dut_addr, NULL);\n\tmake_sockaddr(AF_INET6, \"::ffff:127.0.0.1\", 0, &env.tester_addr, NULL);\n}\n\nstatic void *dut_echo_thread(void *arg)\n{\n\tunsigned char buf[sizeof(struct tlv_hdr)];\n\tint sockfd = *(int *)arg;\n\n\twhile (!exiting) {\n\t\tstruct tlv_hdr *tlv = (struct tlv_hdr *)buf;\n\t\tstruct sockaddr_storage addr;\n\t\tsocklen_t addrlen;\n\t\tsize_t n;\n\n\t\tn = recvfrom(sockfd, buf, sizeof(buf), MSG_WAITALL,\n\t\t\t     (struct sockaddr *)&addr, &addrlen);\n\t\tif (n != ntohs(tlv->len))\n\t\t\tcontinue;\n\n\t\tif (ntohs(tlv->type) != CMD_ECHO)\n\t\t\tcontinue;\n\n\t\tsendto(sockfd, buf, sizeof(buf), MSG_NOSIGNAL | MSG_CONFIRM,\n\t\t       (struct sockaddr *)&addr, addrlen);\n\t}\n\n\tpthread_exit((void *)0);\n\tclose(sockfd);\n\n\treturn NULL;\n}\n\nstatic int dut_run_echo_thread(pthread_t *t, int *sockfd)\n{\n\tint err;\n\n\tsockfd = start_reuseport_server(AF_INET6, SOCK_DGRAM, NULL,\n\t\t\t\t\tDUT_ECHO_PORT, 0, 1);\n\tif (!sockfd) {\n\t\tfprintf(stderr,\n\t\t\t\"Failed creating data UDP socket on device %s\\n\",\n\t\t\tenv.ifname);\n\t\treturn -errno;\n\t}\n\n\t \n\terr = pthread_create(t, NULL, dut_echo_thread, sockfd);\n\tif (err) {\n\t\tfprintf(stderr,\n\t\t\t\"Failed creating data UDP thread on device %s: %s\\n\",\n\t\t\tenv.ifname, strerror(-err));\n\t\tfree_fds(sockfd, 1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dut_attach_xdp_prog(struct xdp_features *skel, int flags)\n{\n\tenum xdp_action action = env.feature.action;\n\tstruct bpf_program *prog;\n\tunsigned int key = 0;\n\tint err, fd = 0;\n\n\tif (env.feature.drv_feature == NETDEV_XDP_ACT_NDO_XMIT) {\n\t\tstruct bpf_devmap_val entry = {\n\t\t\t.ifindex = env.ifindex,\n\t\t};\n\n\t\terr = bpf_map__update_elem(skel->maps.dev_map,\n\t\t\t\t\t   &key, sizeof(key),\n\t\t\t\t\t   &entry, sizeof(entry), 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tfd = bpf_program__fd(skel->progs.xdp_do_redirect_cpumap);\n\t\taction = XDP_REDIRECT;\n\t}\n\n\tswitch (action) {\n\tcase XDP_TX:\n\t\tprog = skel->progs.xdp_do_tx;\n\t\tbreak;\n\tcase XDP_DROP:\n\t\tprog = skel->progs.xdp_do_drop;\n\t\tbreak;\n\tcase XDP_ABORTED:\n\t\tprog = skel->progs.xdp_do_aborted;\n\t\tbreak;\n\tcase XDP_PASS:\n\t\tprog = skel->progs.xdp_do_pass;\n\t\tbreak;\n\tcase XDP_REDIRECT: {\n\t\tstruct bpf_cpumap_val entry = {\n\t\t\t.qsize = 2048,\n\t\t\t.bpf_prog.fd = fd,\n\t\t};\n\n\t\terr = bpf_map__update_elem(skel->maps.cpu_map,\n\t\t\t\t\t   &key, sizeof(key),\n\t\t\t\t\t   &entry, sizeof(entry), 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tprog = skel->progs.xdp_do_redirect;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = bpf_xdp_attach(env.ifindex, bpf_program__fd(prog), flags, NULL);\n\tif (err)\n\t\tfprintf(stderr, \"Failed attaching XDP program to device %s\\n\",\n\t\t\tenv.ifname);\n\treturn err;\n}\n\nstatic int recv_msg(int sockfd, void *buf, size_t bufsize, void *val,\n\t\t    size_t val_size)\n{\n\tstruct tlv_hdr *tlv = (struct tlv_hdr *)buf;\n\tsize_t len;\n\n\tlen = recv(sockfd, buf, bufsize, 0);\n\tif (len != ntohs(tlv->len) || len < sizeof(*tlv))\n\t\treturn -EINVAL;\n\n\tif (val) {\n\t\tlen -= sizeof(*tlv);\n\t\tif (len > val_size)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(val, tlv->data, len);\n\t}\n\n\treturn 0;\n}\n\nstatic int dut_run(struct xdp_features *skel)\n{\n\tint flags = XDP_FLAGS_UPDATE_IF_NOEXIST | XDP_FLAGS_DRV_MODE;\n\tint state, err, *sockfd, ctrl_sockfd, echo_sockfd;\n\tstruct sockaddr_storage ctrl_addr;\n\tpthread_t dut_thread;\n\tsocklen_t addrlen;\n\n\tsockfd = start_reuseport_server(AF_INET6, SOCK_STREAM, NULL,\n\t\t\t\t\tDUT_CTRL_PORT, 0, 1);\n\tif (!sockfd) {\n\t\tfprintf(stderr,\n\t\t\t\"Failed creating control socket on device %s\\n\", env.ifname);\n\t\treturn -errno;\n\t}\n\n\tctrl_sockfd = accept(*sockfd, (struct sockaddr *)&ctrl_addr, &addrlen);\n\tif (ctrl_sockfd < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"Failed accepting connections on device %s control socket\\n\",\n\t\t\tenv.ifname);\n\t\tfree_fds(sockfd, 1);\n\t\treturn -errno;\n\t}\n\n\t \n\twhile (!exiting) {\n\t\tunsigned char buf[BUFSIZE] = {};\n\t\tstruct tlv_hdr *tlv = (struct tlv_hdr *)buf;\n\n\t\terr = recv_msg(ctrl_sockfd, buf, BUFSIZE, NULL, 0);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tswitch (ntohs(tlv->type)) {\n\t\tcase CMD_START: {\n\t\t\tif (state == CMD_START)\n\t\t\t\tcontinue;\n\n\t\t\tstate = CMD_START;\n\t\t\t \n\t\t\terr = dut_attach_xdp_prog(skel, flags);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\terr = dut_run_echo_thread(&dut_thread, &echo_sockfd);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\ttlv->type = htons(CMD_ACK);\n\t\t\ttlv->len = htons(sizeof(*tlv));\n\t\t\terr = send(ctrl_sockfd, buf, sizeof(*tlv), 0);\n\t\t\tif (err < 0)\n\t\t\t\tgoto end_thread;\n\t\t\tbreak;\n\t\t}\n\t\tcase CMD_STOP:\n\t\t\tif (state != CMD_START)\n\t\t\t\tbreak;\n\n\t\t\tstate = CMD_STOP;\n\n\t\t\texiting = true;\n\t\t\tbpf_xdp_detach(env.ifindex, flags, NULL);\n\n\t\t\ttlv->type = htons(CMD_ACK);\n\t\t\ttlv->len = htons(sizeof(*tlv));\n\t\t\terr = send(ctrl_sockfd, buf, sizeof(*tlv), 0);\n\t\t\tgoto end_thread;\n\t\tcase CMD_GET_XDP_CAP: {\n\t\t\tLIBBPF_OPTS(bpf_xdp_query_opts, opts);\n\t\t\tunsigned long long val;\n\t\t\tsize_t n;\n\n\t\t\terr = bpf_xdp_query(env.ifindex, XDP_FLAGS_DRV_MODE,\n\t\t\t\t\t    &opts);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Failed querying XDP cap for device %s\\n\",\n\t\t\t\t\tenv.ifname);\n\t\t\t\tgoto end_thread;\n\t\t\t}\n\n\t\t\ttlv->type = htons(CMD_ACK);\n\t\t\tn = sizeof(*tlv) + sizeof(opts.feature_flags);\n\t\t\ttlv->len = htons(n);\n\n\t\t\tval = htobe64(opts.feature_flags);\n\t\t\tmemcpy(tlv->data, &val, sizeof(val));\n\n\t\t\terr = send(ctrl_sockfd, buf, n, 0);\n\t\t\tif (err < 0)\n\t\t\t\tgoto end_thread;\n\t\t\tbreak;\n\t\t}\n\t\tcase CMD_GET_STATS: {\n\t\t\tunsigned int key = 0, val;\n\t\t\tsize_t n;\n\n\t\t\terr = bpf_map__lookup_elem(skel->maps.dut_stats,\n\t\t\t\t\t\t   &key, sizeof(key),\n\t\t\t\t\t\t   &val, sizeof(val), 0);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bpf_map_lookup_elem failed (%d)\\n\", err);\n\t\t\t\tgoto end_thread;\n\t\t\t}\n\n\t\t\ttlv->type = htons(CMD_ACK);\n\t\t\tn = sizeof(*tlv) + sizeof(val);\n\t\t\ttlv->len = htons(n);\n\n\t\t\tval = htonl(val);\n\t\t\tmemcpy(tlv->data, &val, sizeof(val));\n\n\t\t\terr = send(ctrl_sockfd, buf, n, 0);\n\t\t\tif (err < 0)\n\t\t\t\tgoto end_thread;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nend_thread:\n\tpthread_join(dut_thread, NULL);\nout:\n\tbpf_xdp_detach(env.ifindex, flags, NULL);\n\tclose(ctrl_sockfd);\n\tfree_fds(sockfd, 1);\n\n\treturn err;\n}\n\nstatic bool tester_collect_detected_cap(struct xdp_features *skel,\n\t\t\t\t\tunsigned int dut_stats)\n{\n\tunsigned int err, key = 0, val;\n\n\tif (!dut_stats)\n\t\treturn false;\n\n\terr = bpf_map__lookup_elem(skel->maps.stats, &key, sizeof(key),\n\t\t\t\t   &val, sizeof(val), 0);\n\tif (err) {\n\t\tfprintf(stderr, \"bpf_map_lookup_elem failed (%d)\\n\", err);\n\t\treturn false;\n\t}\n\n\tswitch (env.feature.action) {\n\tcase XDP_PASS:\n\tcase XDP_TX:\n\tcase XDP_REDIRECT:\n\t\treturn val > 0;\n\tcase XDP_DROP:\n\tcase XDP_ABORTED:\n\t\treturn val == 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (env.feature.drv_feature == NETDEV_XDP_ACT_NDO_XMIT)\n\t\treturn val > 0;\n\n\treturn false;\n}\n\nstatic int send_and_recv_msg(int sockfd, enum test_commands cmd, void *val,\n\t\t\t     size_t val_size)\n{\n\tunsigned char buf[BUFSIZE] = {};\n\tstruct tlv_hdr *tlv = (struct tlv_hdr *)buf;\n\tint err;\n\n\ttlv->type = htons(cmd);\n\ttlv->len = htons(sizeof(*tlv));\n\n\terr = send(sockfd, buf, sizeof(*tlv), 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = recv_msg(sockfd, buf, BUFSIZE, val, val_size);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn ntohs(tlv->type) == CMD_ACK ? 0 : -EINVAL;\n}\n\nstatic int send_echo_msg(void)\n{\n\tunsigned char buf[sizeof(struct tlv_hdr)];\n\tstruct tlv_hdr *tlv = (struct tlv_hdr *)buf;\n\tint sockfd, n;\n\n\tsockfd = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (sockfd < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"Failed creating data UDP socket on device %s\\n\",\n\t\t\tenv.ifname);\n\t\treturn -errno;\n\t}\n\n\ttlv->type = htons(CMD_ECHO);\n\ttlv->len = htons(sizeof(*tlv));\n\n\tn = sendto(sockfd, buf, sizeof(*tlv), MSG_NOSIGNAL | MSG_CONFIRM,\n\t\t   (struct sockaddr *)&env.dut_addr, sizeof(env.dut_addr));\n\tclose(sockfd);\n\n\treturn n == ntohs(tlv->len) ? 0 : -EINVAL;\n}\n\nstatic int tester_run(struct xdp_features *skel)\n{\n\tint flags = XDP_FLAGS_UPDATE_IF_NOEXIST | XDP_FLAGS_DRV_MODE;\n\tunsigned long long advertised_feature;\n\tstruct bpf_program *prog;\n\tunsigned int stats;\n\tint i, err, sockfd;\n\tbool detected_cap;\n\n\tsockfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (sockfd < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"Failed creating tester service control socket\\n\");\n\t\treturn -errno;\n\t}\n\n\tif (settimeo(sockfd, 1000) < 0)\n\t\treturn -EINVAL;\n\n\terr = connect(sockfd, (struct sockaddr *)&env.dut_ctrl_addr,\n\t\t      sizeof(env.dut_ctrl_addr));\n\tif (err) {\n\t\tfprintf(stderr,\n\t\t\t\"Failed connecting to the Device Under Test control socket\\n\");\n\t\treturn -errno;\n\t}\n\n\terr = send_and_recv_msg(sockfd, CMD_GET_XDP_CAP, &advertised_feature,\n\t\t\t\tsizeof(advertised_feature));\n\tif (err < 0) {\n\t\tclose(sockfd);\n\t\treturn err;\n\t}\n\n\tadvertised_feature = be64toh(advertised_feature);\n\n\tif (env.feature.drv_feature == NETDEV_XDP_ACT_NDO_XMIT ||\n\t    env.feature.action == XDP_TX)\n\t\tprog = skel->progs.xdp_tester_check_tx;\n\telse\n\t\tprog = skel->progs.xdp_tester_check_rx;\n\n\terr = bpf_xdp_attach(env.ifindex, bpf_program__fd(prog), flags, NULL);\n\tif (err) {\n\t\tfprintf(stderr, \"Failed attaching XDP program to device %s\\n\",\n\t\t\tenv.ifname);\n\t\tgoto out;\n\t}\n\n\terr = send_and_recv_msg(sockfd, CMD_START, NULL, 0);\n\tif (err)\n\t\tgoto out;\n\n\tfor (i = 0; i < 10 && !exiting; i++) {\n\t\terr = send_echo_msg();\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tsleep(1);\n\t}\n\n\terr = send_and_recv_msg(sockfd, CMD_GET_STATS, &stats, sizeof(stats));\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = send_and_recv_msg(sockfd, CMD_STOP, NULL, 0);\n\t \n\tsend_echo_msg();\n\n\tdetected_cap = tester_collect_detected_cap(skel, ntohl(stats));\n\n\tfprintf(stdout, \"Feature %s: [%s][%s]\\n\", get_xdp_feature_str(),\n\t\tdetected_cap ? GREEN(\"DETECTED\") : RED(\"NOT DETECTED\"),\n\t\tenv.feature.drv_feature & advertised_feature ? GREEN(\"ADVERTISED\")\n\t\t\t\t\t\t\t     : RED(\"NOT ADVERTISED\"));\nout:\n\tbpf_xdp_detach(env.ifindex, flags, NULL);\n\tclose(sockfd);\n\treturn err < 0 ? err : 0;\n}\n\nint main(int argc, char **argv)\n{\n\tstruct xdp_features *skel;\n\tint err;\n\n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\tlibbpf_set_print(libbpf_print_fn);\n\n\tsignal(SIGINT, sig_handler);\n\tsignal(SIGTERM, sig_handler);\n\n\tset_env_default();\n\n\t \n\terr = argp_parse(&argp, argc, argv, 0, NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (env.ifindex < 0) {\n\t\tfprintf(stderr, \"Invalid device name %s\\n\", env.ifname);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tskel = xdp_features__open();\n\tif (!skel) {\n\t\tfprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tskel->rodata->tester_addr =\n\t\t((struct sockaddr_in6 *)&env.tester_addr)->sin6_addr;\n\tskel->rodata->dut_addr =\n\t\t((struct sockaddr_in6 *)&env.dut_addr)->sin6_addr;\n\n\t \n\terr = xdp_features__load(skel);\n\tif (err) {\n\t\tfprintf(stderr, \"Failed to load and verify BPF skeleton\\n\");\n\t\tgoto cleanup;\n\t}\n\n\terr = xdp_features__attach(skel);\n\tif (err) {\n\t\tfprintf(stderr, \"Failed to attach BPF skeleton\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tif (env.is_tester) {\n\t\t \n\t\tfprintf(stdout, \"Starting tester service on device %s\\n\",\n\t\t\tenv.ifname);\n\t\terr = tester_run(skel);\n\t} else {\n\t\t \n\t\tfprintf(stdout, \"Starting test on device %s\\n\", env.ifname);\n\t\terr = dut_run(skel);\n\t}\n\ncleanup:\n\txdp_features__destroy(skel);\n\n\treturn err < 0 ? -err : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}