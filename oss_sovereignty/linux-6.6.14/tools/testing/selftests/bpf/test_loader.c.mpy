{
  "module_name": "test_loader.c",
  "hash_id": "62ca58629582c04b0f422982e9a81e893aebcd5b10f69296dd235abcd9c4cc82",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_loader.c",
  "human_readable_source": "\n \n#include <linux/capability.h>\n#include <stdlib.h>\n#include <test_progs.h>\n#include <bpf/btf.h>\n\n#include \"autoconf_helper.h\"\n#include \"unpriv_helpers.h\"\n#include \"cap_helpers.h\"\n\n#define str_has_pfx(str, pfx) \\\n\t(strncmp(str, pfx, __builtin_constant_p(pfx) ? sizeof(pfx) - 1 : strlen(pfx)) == 0)\n\n#define TEST_LOADER_LOG_BUF_SZ 1048576\n\n#define TEST_TAG_EXPECT_FAILURE \"comment:test_expect_failure\"\n#define TEST_TAG_EXPECT_SUCCESS \"comment:test_expect_success\"\n#define TEST_TAG_EXPECT_MSG_PFX \"comment:test_expect_msg=\"\n#define TEST_TAG_EXPECT_FAILURE_UNPRIV \"comment:test_expect_failure_unpriv\"\n#define TEST_TAG_EXPECT_SUCCESS_UNPRIV \"comment:test_expect_success_unpriv\"\n#define TEST_TAG_EXPECT_MSG_PFX_UNPRIV \"comment:test_expect_msg_unpriv=\"\n#define TEST_TAG_LOG_LEVEL_PFX \"comment:test_log_level=\"\n#define TEST_TAG_PROG_FLAGS_PFX \"comment:test_prog_flags=\"\n#define TEST_TAG_DESCRIPTION_PFX \"comment:test_description=\"\n#define TEST_TAG_RETVAL_PFX \"comment:test_retval=\"\n#define TEST_TAG_RETVAL_PFX_UNPRIV \"comment:test_retval_unpriv=\"\n#define TEST_TAG_AUXILIARY \"comment:test_auxiliary\"\n#define TEST_TAG_AUXILIARY_UNPRIV \"comment:test_auxiliary_unpriv\"\n\n \n#define POINTER_VALUE\t0xcafe4all\n#define TEST_DATA_LEN\t64\n\n#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n#define EFFICIENT_UNALIGNED_ACCESS 1\n#else\n#define EFFICIENT_UNALIGNED_ACCESS 0\n#endif\n\nstatic int sysctl_unpriv_disabled = -1;\n\nenum mode {\n\tPRIV = 1,\n\tUNPRIV = 2\n};\n\nstruct test_subspec {\n\tchar *name;\n\tbool expect_failure;\n\tconst char **expect_msgs;\n\tsize_t expect_msg_cnt;\n\tint retval;\n\tbool execute;\n};\n\nstruct test_spec {\n\tconst char *prog_name;\n\tstruct test_subspec priv;\n\tstruct test_subspec unpriv;\n\tint log_level;\n\tint prog_flags;\n\tint mode_mask;\n\tbool auxiliary;\n\tbool valid;\n};\n\nstatic int tester_init(struct test_loader *tester)\n{\n\tif (!tester->log_buf) {\n\t\ttester->log_buf_sz = TEST_LOADER_LOG_BUF_SZ;\n\t\ttester->log_buf = malloc(tester->log_buf_sz);\n\t\tif (!ASSERT_OK_PTR(tester->log_buf, \"tester_log_buf\"))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid test_loader_fini(struct test_loader *tester)\n{\n\tif (!tester)\n\t\treturn;\n\n\tfree(tester->log_buf);\n}\n\nstatic void free_test_spec(struct test_spec *spec)\n{\n\tfree(spec->priv.name);\n\tfree(spec->unpriv.name);\n\tfree(spec->priv.expect_msgs);\n\tfree(spec->unpriv.expect_msgs);\n\n\tspec->priv.name = NULL;\n\tspec->unpriv.name = NULL;\n\tspec->priv.expect_msgs = NULL;\n\tspec->unpriv.expect_msgs = NULL;\n}\n\nstatic int push_msg(const char *msg, struct test_subspec *subspec)\n{\n\tvoid *tmp;\n\n\ttmp = realloc(subspec->expect_msgs, (1 + subspec->expect_msg_cnt) * sizeof(void *));\n\tif (!tmp) {\n\t\tASSERT_FAIL(\"failed to realloc memory for messages\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsubspec->expect_msgs = tmp;\n\tsubspec->expect_msgs[subspec->expect_msg_cnt++] = msg;\n\n\treturn 0;\n}\n\nstatic int parse_int(const char *str, int *val, const char *name)\n{\n\tchar *end;\n\tlong tmp;\n\n\terrno = 0;\n\tif (str_has_pfx(str, \"0x\"))\n\t\ttmp = strtol(str + 2, &end, 16);\n\telse\n\t\ttmp = strtol(str, &end, 10);\n\tif (errno || end[0] != '\\0') {\n\t\tPRINT_FAIL(\"failed to parse %s from '%s'\\n\", name, str);\n\t\treturn -EINVAL;\n\t}\n\t*val = tmp;\n\treturn 0;\n}\n\nstatic int parse_retval(const char *str, int *val, const char *name)\n{\n\tstruct {\n\t\tchar *name;\n\t\tint val;\n\t} named_values[] = {\n\t\t{ \"INT_MIN\"      , INT_MIN },\n\t\t{ \"POINTER_VALUE\", POINTER_VALUE },\n\t\t{ \"TEST_DATA_LEN\", TEST_DATA_LEN },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(named_values); ++i) {\n\t\tif (strcmp(str, named_values[i].name) != 0)\n\t\t\tcontinue;\n\t\t*val = named_values[i].val;\n\t\treturn 0;\n\t}\n\n\treturn parse_int(str, val, name);\n}\n\n \nstatic int parse_test_spec(struct test_loader *tester,\n\t\t\t   struct bpf_object *obj,\n\t\t\t   struct bpf_program *prog,\n\t\t\t   struct test_spec *spec)\n{\n\tconst char *description = NULL;\n\tbool has_unpriv_result = false;\n\tbool has_unpriv_retval = false;\n\tint func_id, i, err = 0;\n\tstruct btf *btf;\n\n\tmemset(spec, 0, sizeof(*spec));\n\n\tspec->prog_name = bpf_program__name(prog);\n\n\tbtf = bpf_object__btf(obj);\n\tif (!btf) {\n\t\tASSERT_FAIL(\"BPF object has no BTF\");\n\t\treturn -EINVAL;\n\t}\n\n\tfunc_id = btf__find_by_name_kind(btf, spec->prog_name, BTF_KIND_FUNC);\n\tif (func_id < 0) {\n\t\tASSERT_FAIL(\"failed to find FUNC BTF type for '%s'\", spec->prog_name);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 1; i < btf__type_cnt(btf); i++) {\n\t\tconst char *s, *val, *msg;\n\t\tconst struct btf_type *t;\n\t\tint tmp;\n\n\t\tt = btf__type_by_id(btf, i);\n\t\tif (!btf_is_decl_tag(t))\n\t\t\tcontinue;\n\n\t\tif (t->type != func_id || btf_decl_tag(t)->component_idx != -1)\n\t\t\tcontinue;\n\n\t\ts = btf__str_by_offset(btf, t->name_off);\n\t\tif (str_has_pfx(s, TEST_TAG_DESCRIPTION_PFX)) {\n\t\t\tdescription = s + sizeof(TEST_TAG_DESCRIPTION_PFX) - 1;\n\t\t} else if (strcmp(s, TEST_TAG_EXPECT_FAILURE) == 0) {\n\t\t\tspec->priv.expect_failure = true;\n\t\t\tspec->mode_mask |= PRIV;\n\t\t} else if (strcmp(s, TEST_TAG_EXPECT_SUCCESS) == 0) {\n\t\t\tspec->priv.expect_failure = false;\n\t\t\tspec->mode_mask |= PRIV;\n\t\t} else if (strcmp(s, TEST_TAG_EXPECT_FAILURE_UNPRIV) == 0) {\n\t\t\tspec->unpriv.expect_failure = true;\n\t\t\tspec->mode_mask |= UNPRIV;\n\t\t\thas_unpriv_result = true;\n\t\t} else if (strcmp(s, TEST_TAG_EXPECT_SUCCESS_UNPRIV) == 0) {\n\t\t\tspec->unpriv.expect_failure = false;\n\t\t\tspec->mode_mask |= UNPRIV;\n\t\t\thas_unpriv_result = true;\n\t\t} else if (strcmp(s, TEST_TAG_AUXILIARY) == 0) {\n\t\t\tspec->auxiliary = true;\n\t\t\tspec->mode_mask |= PRIV;\n\t\t} else if (strcmp(s, TEST_TAG_AUXILIARY_UNPRIV) == 0) {\n\t\t\tspec->auxiliary = true;\n\t\t\tspec->mode_mask |= UNPRIV;\n\t\t} else if (str_has_pfx(s, TEST_TAG_EXPECT_MSG_PFX)) {\n\t\t\tmsg = s + sizeof(TEST_TAG_EXPECT_MSG_PFX) - 1;\n\t\t\terr = push_msg(msg, &spec->priv);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tspec->mode_mask |= PRIV;\n\t\t} else if (str_has_pfx(s, TEST_TAG_EXPECT_MSG_PFX_UNPRIV)) {\n\t\t\tmsg = s + sizeof(TEST_TAG_EXPECT_MSG_PFX_UNPRIV) - 1;\n\t\t\terr = push_msg(msg, &spec->unpriv);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tspec->mode_mask |= UNPRIV;\n\t\t} else if (str_has_pfx(s, TEST_TAG_RETVAL_PFX)) {\n\t\t\tval = s + sizeof(TEST_TAG_RETVAL_PFX) - 1;\n\t\t\terr = parse_retval(val, &spec->priv.retval, \"__retval\");\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tspec->priv.execute = true;\n\t\t\tspec->mode_mask |= PRIV;\n\t\t} else if (str_has_pfx(s, TEST_TAG_RETVAL_PFX_UNPRIV)) {\n\t\t\tval = s + sizeof(TEST_TAG_RETVAL_PFX_UNPRIV) - 1;\n\t\t\terr = parse_retval(val, &spec->unpriv.retval, \"__retval_unpriv\");\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tspec->mode_mask |= UNPRIV;\n\t\t\tspec->unpriv.execute = true;\n\t\t\thas_unpriv_retval = true;\n\t\t} else if (str_has_pfx(s, TEST_TAG_LOG_LEVEL_PFX)) {\n\t\t\tval = s + sizeof(TEST_TAG_LOG_LEVEL_PFX) - 1;\n\t\t\terr = parse_int(val, &spec->log_level, \"test log level\");\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t} else if (str_has_pfx(s, TEST_TAG_PROG_FLAGS_PFX)) {\n\t\t\tval = s + sizeof(TEST_TAG_PROG_FLAGS_PFX) - 1;\n\t\t\tif (strcmp(val, \"BPF_F_STRICT_ALIGNMENT\") == 0) {\n\t\t\t\tspec->prog_flags |= BPF_F_STRICT_ALIGNMENT;\n\t\t\t} else if (strcmp(val, \"BPF_F_ANY_ALIGNMENT\") == 0) {\n\t\t\t\tspec->prog_flags |= BPF_F_ANY_ALIGNMENT;\n\t\t\t} else if (strcmp(val, \"BPF_F_TEST_RND_HI32\") == 0) {\n\t\t\t\tspec->prog_flags |= BPF_F_TEST_RND_HI32;\n\t\t\t} else if (strcmp(val, \"BPF_F_TEST_STATE_FREQ\") == 0) {\n\t\t\t\tspec->prog_flags |= BPF_F_TEST_STATE_FREQ;\n\t\t\t} else if (strcmp(val, \"BPF_F_SLEEPABLE\") == 0) {\n\t\t\t\tspec->prog_flags |= BPF_F_SLEEPABLE;\n\t\t\t} else if (strcmp(val, \"BPF_F_XDP_HAS_FRAGS\") == 0) {\n\t\t\t\tspec->prog_flags |= BPF_F_XDP_HAS_FRAGS;\n\t\t\t} else   {\n\t\t\t\terr = parse_int(val, &tmp, \"test prog flags\");\n\t\t\t\tif (err)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tspec->prog_flags |= tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (spec->mode_mask == 0)\n\t\tspec->mode_mask = PRIV;\n\n\tif (!description)\n\t\tdescription = spec->prog_name;\n\n\tif (spec->mode_mask & PRIV) {\n\t\tspec->priv.name = strdup(description);\n\t\tif (!spec->priv.name) {\n\t\t\tPRINT_FAIL(\"failed to allocate memory for priv.name\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (spec->mode_mask & UNPRIV) {\n\t\tint descr_len = strlen(description);\n\t\tconst char *suffix = \" @unpriv\";\n\t\tchar *name;\n\n\t\tname = malloc(descr_len + strlen(suffix) + 1);\n\t\tif (!name) {\n\t\t\tPRINT_FAIL(\"failed to allocate memory for unpriv.name\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tstrcpy(name, description);\n\t\tstrcpy(&name[descr_len], suffix);\n\t\tspec->unpriv.name = name;\n\t}\n\n\tif (spec->mode_mask & (PRIV | UNPRIV)) {\n\t\tif (!has_unpriv_result)\n\t\t\tspec->unpriv.expect_failure = spec->priv.expect_failure;\n\n\t\tif (!has_unpriv_retval) {\n\t\t\tspec->unpriv.retval = spec->priv.retval;\n\t\t\tspec->unpriv.execute = spec->priv.execute;\n\t\t}\n\n\t\tif (!spec->unpriv.expect_msgs) {\n\t\t\tsize_t sz = spec->priv.expect_msg_cnt * sizeof(void *);\n\n\t\t\tspec->unpriv.expect_msgs = malloc(sz);\n\t\t\tif (!spec->unpriv.expect_msgs) {\n\t\t\t\tPRINT_FAIL(\"failed to allocate memory for unpriv.expect_msgs\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tmemcpy(spec->unpriv.expect_msgs, spec->priv.expect_msgs, sz);\n\t\t\tspec->unpriv.expect_msg_cnt = spec->priv.expect_msg_cnt;\n\t\t}\n\t}\n\n\tspec->valid = true;\n\n\treturn 0;\n\ncleanup:\n\tfree_test_spec(spec);\n\treturn err;\n}\n\nstatic void prepare_case(struct test_loader *tester,\n\t\t\t struct test_spec *spec,\n\t\t\t struct bpf_object *obj,\n\t\t\t struct bpf_program *prog)\n{\n\tint min_log_level = 0, prog_flags;\n\n\tif (env.verbosity > VERBOSE_NONE)\n\t\tmin_log_level = 1;\n\tif (env.verbosity > VERBOSE_VERY)\n\t\tmin_log_level = 2;\n\n\tbpf_program__set_log_buf(prog, tester->log_buf, tester->log_buf_sz);\n\n\t \n\tif ((spec->log_level & 3) < min_log_level)\n\t\tbpf_program__set_log_level(prog, (spec->log_level & 4) | min_log_level);\n\telse\n\t\tbpf_program__set_log_level(prog, spec->log_level);\n\n\tprog_flags = bpf_program__flags(prog);\n\tbpf_program__set_flags(prog, prog_flags | spec->prog_flags);\n\n\ttester->log_buf[0] = '\\0';\n\ttester->next_match_pos = 0;\n}\n\nstatic void emit_verifier_log(const char *log_buf, bool force)\n{\n\tif (!force && env.verbosity == VERBOSE_NONE)\n\t\treturn;\n\tfprintf(stdout, \"VERIFIER LOG:\\n=============\\n%s=============\\n\", log_buf);\n}\n\nstatic void validate_case(struct test_loader *tester,\n\t\t\t  struct test_subspec *subspec,\n\t\t\t  struct bpf_object *obj,\n\t\t\t  struct bpf_program *prog,\n\t\t\t  int load_err)\n{\n\tint i, j;\n\n\tfor (i = 0; i < subspec->expect_msg_cnt; i++) {\n\t\tchar *match;\n\t\tconst char *expect_msg;\n\n\t\texpect_msg = subspec->expect_msgs[i];\n\n\t\tmatch = strstr(tester->log_buf + tester->next_match_pos, expect_msg);\n\t\tif (!ASSERT_OK_PTR(match, \"expect_msg\")) {\n\t\t\t \n\t\t\tif (env.verbosity == VERBOSE_NONE)\n\t\t\t\temit_verifier_log(tester->log_buf, true  );\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"MATCHED  MSG: '%s'\\n\", subspec->expect_msgs[j]);\n\t\t\tfprintf(stderr, \"EXPECTED MSG: '%s'\\n\", expect_msg);\n\t\t\treturn;\n\t\t}\n\n\t\ttester->next_match_pos = match - tester->log_buf + strlen(expect_msg);\n\t}\n}\n\nstruct cap_state {\n\t__u64 old_caps;\n\tbool initialized;\n};\n\nstatic int drop_capabilities(struct cap_state *caps)\n{\n\tconst __u64 caps_to_drop = (1ULL << CAP_SYS_ADMIN | 1ULL << CAP_NET_ADMIN |\n\t\t\t\t    1ULL << CAP_PERFMON   | 1ULL << CAP_BPF);\n\tint err;\n\n\terr = cap_disable_effective(caps_to_drop, &caps->old_caps);\n\tif (err) {\n\t\tPRINT_FAIL(\"failed to drop capabilities: %i, %s\\n\", err, strerror(err));\n\t\treturn err;\n\t}\n\n\tcaps->initialized = true;\n\treturn 0;\n}\n\nstatic int restore_capabilities(struct cap_state *caps)\n{\n\tint err;\n\n\tif (!caps->initialized)\n\t\treturn 0;\n\n\terr = cap_enable_effective(caps->old_caps, NULL);\n\tif (err)\n\t\tPRINT_FAIL(\"failed to restore capabilities: %i, %s\\n\", err, strerror(err));\n\tcaps->initialized = false;\n\treturn err;\n}\n\nstatic bool can_execute_unpriv(struct test_loader *tester, struct test_spec *spec)\n{\n\tif (sysctl_unpriv_disabled < 0)\n\t\tsysctl_unpriv_disabled = get_unpriv_disabled() ? 1 : 0;\n\tif (sysctl_unpriv_disabled)\n\t\treturn false;\n\tif ((spec->prog_flags & BPF_F_ANY_ALIGNMENT) && !EFFICIENT_UNALIGNED_ACCESS)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool is_unpriv_capable_map(struct bpf_map *map)\n{\n\tenum bpf_map_type type;\n\t__u32 flags;\n\n\ttype = bpf_map__type(map);\n\n\tswitch (type) {\n\tcase BPF_MAP_TYPE_HASH:\n\tcase BPF_MAP_TYPE_PERCPU_HASH:\n\tcase BPF_MAP_TYPE_HASH_OF_MAPS:\n\t\tflags = bpf_map__map_flags(map);\n\t\treturn !(flags & BPF_F_ZERO_SEED);\n\tcase BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE:\n\tcase BPF_MAP_TYPE_ARRAY:\n\tcase BPF_MAP_TYPE_RINGBUF:\n\tcase BPF_MAP_TYPE_PROG_ARRAY:\n\tcase BPF_MAP_TYPE_CGROUP_ARRAY:\n\tcase BPF_MAP_TYPE_PERCPU_ARRAY:\n\tcase BPF_MAP_TYPE_USER_RINGBUF:\n\tcase BPF_MAP_TYPE_ARRAY_OF_MAPS:\n\tcase BPF_MAP_TYPE_CGROUP_STORAGE:\n\tcase BPF_MAP_TYPE_PERF_EVENT_ARRAY:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int do_prog_test_run(int fd_prog, int *retval)\n{\n\t__u8 tmp_out[TEST_DATA_LEN << 2] = {};\n\t__u8 tmp_in[TEST_DATA_LEN] = {};\n\tint err, saved_errno;\n\tLIBBPF_OPTS(bpf_test_run_opts, topts,\n\t\t.data_in = tmp_in,\n\t\t.data_size_in = sizeof(tmp_in),\n\t\t.data_out = tmp_out,\n\t\t.data_size_out = sizeof(tmp_out),\n\t\t.repeat = 1,\n\t);\n\n\terr = bpf_prog_test_run_opts(fd_prog, &topts);\n\tsaved_errno = errno;\n\n\tif (err) {\n\t\tPRINT_FAIL(\"FAIL: Unexpected bpf_prog_test_run error: %d (%s) \",\n\t\t\t   saved_errno, strerror(saved_errno));\n\t\treturn err;\n\t}\n\n\tASSERT_OK(0, \"bpf_prog_test_run\");\n\t*retval = topts.retval;\n\n\treturn 0;\n}\n\nstatic bool should_do_test_run(struct test_spec *spec, struct test_subspec *subspec)\n{\n\tif (!subspec->execute)\n\t\treturn false;\n\n\tif (subspec->expect_failure)\n\t\treturn false;\n\n\tif ((spec->prog_flags & BPF_F_ANY_ALIGNMENT) && !EFFICIENT_UNALIGNED_ACCESS) {\n\t\tif (env.verbosity != VERBOSE_NONE)\n\t\t\tprintf(\"alignment prevents execution\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic noinline\nvoid run_subtest(struct test_loader *tester,\n\t\t struct bpf_object_open_opts *open_opts,\n\t\t const void *obj_bytes,\n\t\t size_t obj_byte_cnt,\n\t\t struct test_spec *specs,\n\t\t struct test_spec *spec,\n\t\t bool unpriv)\n{\n\tstruct test_subspec *subspec = unpriv ? &spec->unpriv : &spec->priv;\n\tstruct bpf_program *tprog, *tprog_iter;\n\tstruct test_spec *spec_iter;\n\tstruct cap_state caps = {};\n\tstruct bpf_object *tobj;\n\tstruct bpf_map *map;\n\tint retval, err, i;\n\tbool should_load;\n\n\tif (!test__start_subtest(subspec->name))\n\t\treturn;\n\n\tif (unpriv) {\n\t\tif (!can_execute_unpriv(tester, spec)) {\n\t\t\ttest__skip();\n\t\t\ttest__end_subtest();\n\t\t\treturn;\n\t\t}\n\t\tif (drop_capabilities(&caps)) {\n\t\t\ttest__end_subtest();\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttobj = bpf_object__open_mem(obj_bytes, obj_byte_cnt, open_opts);\n\tif (!ASSERT_OK_PTR(tobj, \"obj_open_mem\"))  \n\t\tgoto subtest_cleanup;\n\n\ti = 0;\n\tbpf_object__for_each_program(tprog_iter, tobj) {\n\t\tspec_iter = &specs[i++];\n\t\tshould_load = false;\n\n\t\tif (spec_iter->valid) {\n\t\t\tif (strcmp(bpf_program__name(tprog_iter), spec->prog_name) == 0) {\n\t\t\t\ttprog = tprog_iter;\n\t\t\t\tshould_load = true;\n\t\t\t}\n\n\t\t\tif (spec_iter->auxiliary &&\n\t\t\t    spec_iter->mode_mask & (unpriv ? UNPRIV : PRIV))\n\t\t\t\tshould_load = true;\n\t\t}\n\n\t\tbpf_program__set_autoload(tprog_iter, should_load);\n\t}\n\n\tprepare_case(tester, spec, tobj, tprog);\n\n\t \n\tbpf_object__for_each_map(map, tobj)\n\t\tbpf_map__set_autocreate(map, !unpriv || is_unpriv_capable_map(map));\n\n\terr = bpf_object__load(tobj);\n\tif (subspec->expect_failure) {\n\t\tif (!ASSERT_ERR(err, \"unexpected_load_success\")) {\n\t\t\temit_verifier_log(tester->log_buf, false  );\n\t\t\tgoto tobj_cleanup;\n\t\t}\n\t} else {\n\t\tif (!ASSERT_OK(err, \"unexpected_load_failure\")) {\n\t\t\temit_verifier_log(tester->log_buf, true  );\n\t\t\tgoto tobj_cleanup;\n\t\t}\n\t}\n\n\temit_verifier_log(tester->log_buf, false  );\n\tvalidate_case(tester, subspec, tobj, tprog, err);\n\n\tif (should_do_test_run(spec, subspec)) {\n\t\t \n\t\tif (restore_capabilities(&caps))\n\t\t\tgoto tobj_cleanup;\n\n\t\tif (tester->pre_execution_cb) {\n\t\t\terr = tester->pre_execution_cb(tobj);\n\t\t\tif (err) {\n\t\t\t\tPRINT_FAIL(\"pre_execution_cb failed: %d\\n\", err);\n\t\t\t\tgoto tobj_cleanup;\n\t\t\t}\n\t\t}\n\n\t\tdo_prog_test_run(bpf_program__fd(tprog), &retval);\n\t\tif (retval != subspec->retval && subspec->retval != POINTER_VALUE) {\n\t\t\tPRINT_FAIL(\"Unexpected retval: %d != %d\\n\", retval, subspec->retval);\n\t\t\tgoto tobj_cleanup;\n\t\t}\n\t}\n\ntobj_cleanup:\n\tbpf_object__close(tobj);\nsubtest_cleanup:\n\ttest__end_subtest();\n\trestore_capabilities(&caps);\n}\n\nstatic void process_subtest(struct test_loader *tester,\n\t\t\t    const char *skel_name,\n\t\t\t    skel_elf_bytes_fn elf_bytes_factory)\n{\n\tLIBBPF_OPTS(bpf_object_open_opts, open_opts, .object_name = skel_name);\n\tstruct test_spec *specs = NULL;\n\tstruct bpf_object *obj = NULL;\n\tstruct bpf_program *prog;\n\tconst void *obj_bytes;\n\tint err, i, nr_progs;\n\tsize_t obj_byte_cnt;\n\n\tif (tester_init(tester) < 0)\n\t\treturn;  \n\n\tobj_bytes = elf_bytes_factory(&obj_byte_cnt);\n\tobj = bpf_object__open_mem(obj_bytes, obj_byte_cnt, &open_opts);\n\tif (!ASSERT_OK_PTR(obj, \"obj_open_mem\"))\n\t\treturn;\n\n\tnr_progs = 0;\n\tbpf_object__for_each_program(prog, obj)\n\t\t++nr_progs;\n\n\tspecs = calloc(nr_progs, sizeof(struct test_spec));\n\tif (!ASSERT_OK_PTR(specs, \"Can't alloc specs array\"))\n\t\treturn;\n\n\ti = 0;\n\tbpf_object__for_each_program(prog, obj) {\n\t\t \n\t\terr = parse_test_spec(tester, obj, prog, &specs[i++]);\n\t\tif (err)\n\t\t\tPRINT_FAIL(\"Can't parse test spec for program '%s'\\n\",\n\t\t\t\t   bpf_program__name(prog));\n\t}\n\n\ti = 0;\n\tbpf_object__for_each_program(prog, obj) {\n\t\tstruct test_spec *spec = &specs[i++];\n\n\t\tif (!spec->valid || spec->auxiliary)\n\t\t\tcontinue;\n\n\t\tif (spec->mode_mask & PRIV)\n\t\t\trun_subtest(tester, &open_opts, obj_bytes, obj_byte_cnt,\n\t\t\t\t    specs, spec, false);\n\t\tif (spec->mode_mask & UNPRIV)\n\t\t\trun_subtest(tester, &open_opts, obj_bytes, obj_byte_cnt,\n\t\t\t\t    specs, spec, true);\n\n\t}\n\n\tfor (i = 0; i < nr_progs; ++i)\n\t\tfree_test_spec(&specs[i]);\n\tfree(specs);\n\tbpf_object__close(obj);\n}\n\nvoid test_loader__run_subtests(struct test_loader *tester,\n\t\t\t       const char *skel_name,\n\t\t\t       skel_elf_bytes_fn elf_bytes_factory)\n{\n\t \n\tprocess_subtest(tester, skel_name, elf_bytes_factory);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}