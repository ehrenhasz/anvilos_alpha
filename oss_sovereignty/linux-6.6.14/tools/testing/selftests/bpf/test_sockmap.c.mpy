{
  "module_name": "test_sockmap.c",
  "hash_id": "f2601c96036ed30ceb046369a1e60efbd6da3476553a34b550d7bd30a77601d5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_sockmap.c",
  "human_readable_source": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/select.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <sched.h>\n\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/sendfile.h>\n\n#include <linux/netlink.h>\n#include <linux/socket.h>\n#include <linux/sock_diag.h>\n#include <linux/bpf.h>\n#include <linux/if_link.h>\n#include <linux/tls.h>\n#include <assert.h>\n#include <libgen.h>\n\n#include <getopt.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"bpf_util.h\"\n#include \"cgroup_helpers.h\"\n\nint running;\nstatic void running_handler(int a);\n\n#ifndef TCP_ULP\n# define TCP_ULP 31\n#endif\n#ifndef SOL_TLS\n# define SOL_TLS 282\n#endif\n\n \n#define S1_PORT 10000\n#define S2_PORT 10001\n\n#define BPF_SOCKMAP_FILENAME  \"test_sockmap_kern.bpf.o\"\n#define BPF_SOCKHASH_FILENAME \"test_sockhash_kern.bpf.o\"\n#define CG_PATH \"/sockmap\"\n\n \nint s1, s2, c1, c2, p1, p2;\nint test_cnt;\nint passed;\nint failed;\nint map_fd[9];\nstruct bpf_map *maps[9];\nint prog_fd[11];\n\nint txmsg_pass;\nint txmsg_redir;\nint txmsg_drop;\nint txmsg_apply;\nint txmsg_cork;\nint txmsg_start;\nint txmsg_end;\nint txmsg_start_push;\nint txmsg_end_push;\nint txmsg_start_pop;\nint txmsg_pop;\nint txmsg_ingress;\nint txmsg_redir_skb;\nint txmsg_ktls_skb;\nint txmsg_ktls_skb_drop;\nint txmsg_ktls_skb_redir;\nint ktls;\nint peek_flag;\nint skb_use_parser;\nint txmsg_omit_skb_parser;\n\nstatic const struct option long_options[] = {\n\t{\"help\",\tno_argument,\t\tNULL, 'h' },\n\t{\"cgroup\",\trequired_argument,\tNULL, 'c' },\n\t{\"rate\",\trequired_argument,\tNULL, 'r' },\n\t{\"verbose\",\toptional_argument,\tNULL, 'v' },\n\t{\"iov_count\",\trequired_argument,\tNULL, 'i' },\n\t{\"length\",\trequired_argument,\tNULL, 'l' },\n\t{\"test\",\trequired_argument,\tNULL, 't' },\n\t{\"data_test\",   no_argument,\t\tNULL, 'd' },\n\t{\"txmsg\",\t\tno_argument,\t&txmsg_pass,  1  },\n\t{\"txmsg_redir\",\t\tno_argument,\t&txmsg_redir, 1  },\n\t{\"txmsg_drop\",\t\tno_argument,\t&txmsg_drop, 1 },\n\t{\"txmsg_apply\",\trequired_argument,\tNULL, 'a'},\n\t{\"txmsg_cork\",\trequired_argument,\tNULL, 'k'},\n\t{\"txmsg_start\", required_argument,\tNULL, 's'},\n\t{\"txmsg_end\",\trequired_argument,\tNULL, 'e'},\n\t{\"txmsg_start_push\", required_argument,\tNULL, 'p'},\n\t{\"txmsg_end_push\",   required_argument,\tNULL, 'q'},\n\t{\"txmsg_start_pop\",  required_argument,\tNULL, 'w'},\n\t{\"txmsg_pop\",\t     required_argument,\tNULL, 'x'},\n\t{\"txmsg_ingress\", no_argument,\t\t&txmsg_ingress, 1 },\n\t{\"txmsg_redir_skb\", no_argument,\t&txmsg_redir_skb, 1 },\n\t{\"ktls\", no_argument,\t\t\t&ktls, 1 },\n\t{\"peek\", no_argument,\t\t\t&peek_flag, 1 },\n\t{\"txmsg_omit_skb_parser\", no_argument,      &txmsg_omit_skb_parser, 1},\n\t{\"whitelist\", required_argument,\tNULL, 'n' },\n\t{\"blacklist\", required_argument,\tNULL, 'b' },\n\t{0, 0, NULL, 0 }\n};\n\nstruct test_env {\n\tconst char *type;\n\tconst char *subtest;\n\tconst char *prepend;\n\n\tint test_num;\n\tint subtest_num;\n\n\tint succ_cnt;\n\tint fail_cnt;\n\tint fail_last;\n};\n\nstruct test_env env;\n\nstruct sockmap_options {\n\tint verbose;\n\tbool base;\n\tbool sendpage;\n\tbool data_test;\n\tbool drop_expected;\n\tbool check_recved_len;\n\tbool tx_wait_mem;\n\tint iov_count;\n\tint iov_length;\n\tint rate;\n\tchar *map;\n\tchar *whitelist;\n\tchar *blacklist;\n\tchar *prepend;\n};\n\nstruct _test {\n\tchar *title;\n\tvoid (*tester)(int cg_fd, struct sockmap_options *opt);\n};\n\nstatic void test_start(void)\n{\n\tenv.subtest_num++;\n}\n\nstatic void test_fail(void)\n{\n\tenv.fail_cnt++;\n}\n\nstatic void test_pass(void)\n{\n\tenv.succ_cnt++;\n}\n\nstatic void test_reset(void)\n{\n\ttxmsg_start = txmsg_end = 0;\n\ttxmsg_start_pop = txmsg_pop = 0;\n\ttxmsg_start_push = txmsg_end_push = 0;\n\ttxmsg_pass = txmsg_drop = txmsg_redir = 0;\n\ttxmsg_apply = txmsg_cork = 0;\n\ttxmsg_ingress = txmsg_redir_skb = 0;\n\ttxmsg_ktls_skb = txmsg_ktls_skb_drop = txmsg_ktls_skb_redir = 0;\n\ttxmsg_omit_skb_parser = 0;\n\tskb_use_parser = 0;\n}\n\nstatic int test_start_subtest(const struct _test *t, struct sockmap_options *o)\n{\n\tenv.type = o->map;\n\tenv.subtest = t->title;\n\tenv.prepend = o->prepend;\n\tenv.test_num++;\n\tenv.subtest_num = 0;\n\tenv.fail_last = env.fail_cnt;\n\ttest_reset();\n\treturn 0;\n}\n\nstatic void test_end_subtest(void)\n{\n\tint error = env.fail_cnt - env.fail_last;\n\tint type = strcmp(env.type, BPF_SOCKMAP_FILENAME);\n\n\tif (!error)\n\t\ttest_pass();\n\n\tfprintf(stdout, \"#%2d/%2d %8s:%s:%s:%s\\n\",\n\t\tenv.test_num, env.subtest_num,\n\t\t!type ? \"sockmap\" : \"sockhash\",\n\t\tenv.prepend ? : \"\",\n\t\tenv.subtest, error ? \"FAIL\" : \"OK\");\n}\n\nstatic void test_print_results(void)\n{\n\tfprintf(stdout, \"Pass: %d Fail: %d\\n\",\n\t\tenv.succ_cnt, env.fail_cnt);\n}\n\nstatic void usage(char *argv[])\n{\n\tint i;\n\n\tprintf(\" Usage: %s --cgroup <cgroup_path>\\n\", argv[0]);\n\tprintf(\" options:\\n\");\n\tfor (i = 0; long_options[i].name != 0; i++) {\n\t\tprintf(\" --%-12s\", long_options[i].name);\n\t\tif (long_options[i].flag != NULL)\n\t\t\tprintf(\" flag (internal value:%d)\\n\",\n\t\t\t\t*long_options[i].flag);\n\t\telse\n\t\t\tprintf(\" -%c\\n\", long_options[i].val);\n\t}\n\tprintf(\"\\n\");\n}\n\nchar *sock_to_string(int s)\n{\n\tif (s == c1)\n\t\treturn \"client1\";\n\telse if (s == c2)\n\t\treturn \"client2\";\n\telse if (s == s1)\n\t\treturn \"server1\";\n\telse if (s == s2)\n\t\treturn \"server2\";\n\telse if (s == p1)\n\t\treturn \"peer1\";\n\telse if (s == p2)\n\t\treturn \"peer2\";\n\telse\n\t\treturn \"unknown\";\n}\n\nstatic int sockmap_init_ktls(int verbose, int s)\n{\n\tstruct tls12_crypto_info_aes_gcm_128 tls_tx = {\n\t\t.info = {\n\t\t\t.version     = TLS_1_2_VERSION,\n\t\t\t.cipher_type = TLS_CIPHER_AES_GCM_128,\n\t\t},\n\t};\n\tstruct tls12_crypto_info_aes_gcm_128 tls_rx = {\n\t\t.info = {\n\t\t\t.version     = TLS_1_2_VERSION,\n\t\t\t.cipher_type = TLS_CIPHER_AES_GCM_128,\n\t\t},\n\t};\n\tint so_buf = 6553500;\n\tint err;\n\n\terr = setsockopt(s, 6, TCP_ULP, \"tls\", sizeof(\"tls\"));\n\tif (err) {\n\t\tfprintf(stderr, \"setsockopt: TCP_ULP(%s) failed with error %i\\n\", sock_to_string(s), err);\n\t\treturn -EINVAL;\n\t}\n\terr = setsockopt(s, SOL_TLS, TLS_TX, (void *)&tls_tx, sizeof(tls_tx));\n\tif (err) {\n\t\tfprintf(stderr, \"setsockopt: TLS_TX(%s) failed with error %i\\n\", sock_to_string(s), err);\n\t\treturn -EINVAL;\n\t}\n\terr = setsockopt(s, SOL_TLS, TLS_RX, (void *)&tls_rx, sizeof(tls_rx));\n\tif (err) {\n\t\tfprintf(stderr, \"setsockopt: TLS_RX(%s) failed with error %i\\n\", sock_to_string(s), err);\n\t\treturn -EINVAL;\n\t}\n\terr = setsockopt(s, SOL_SOCKET, SO_SNDBUF, &so_buf, sizeof(so_buf));\n\tif (err) {\n\t\tfprintf(stderr, \"setsockopt: (%s) failed sndbuf with error %i\\n\", sock_to_string(s), err);\n\t\treturn -EINVAL;\n\t}\n\terr = setsockopt(s, SOL_SOCKET, SO_RCVBUF, &so_buf, sizeof(so_buf));\n\tif (err) {\n\t\tfprintf(stderr, \"setsockopt: (%s) failed rcvbuf with error %i\\n\", sock_to_string(s), err);\n\t\treturn -EINVAL;\n\t}\n\n\tif (verbose)\n\t\tfprintf(stdout, \"socket(%s) kTLS enabled\\n\", sock_to_string(s));\n\treturn 0;\n}\nstatic int sockmap_init_sockets(int verbose)\n{\n\tint i, err, one = 1;\n\tstruct sockaddr_in addr;\n\tint *fds[4] = {&s1, &s2, &c1, &c2};\n\n\ts1 = s2 = p1 = p2 = c1 = c2 = 0;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\t*fds[i] = socket(AF_INET, SOCK_STREAM, 0);\n\t\tif (*fds[i] < 0) {\n\t\t\tperror(\"socket s1 failed()\");\n\t\t\treturn errno;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\terr = setsockopt(*fds[i], SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t (char *)&one, sizeof(one));\n\t\tif (err) {\n\t\t\tperror(\"setsockopt failed()\");\n\t\t\treturn errno;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\terr = ioctl(*fds[i], FIONBIO, (char *)&one);\n\t\tif (err < 0) {\n\t\t\tperror(\"ioctl s1 failed()\");\n\t\t\treturn errno;\n\t\t}\n\t}\n\n\t \n\tmemset(&addr, 0, sizeof(struct sockaddr_in));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n\taddr.sin_port = htons(S1_PORT);\n\terr = bind(s1, (struct sockaddr *)&addr, sizeof(addr));\n\tif (err < 0) {\n\t\tperror(\"bind s1 failed()\");\n\t\treturn errno;\n\t}\n\n\taddr.sin_port = htons(S2_PORT);\n\terr = bind(s2, (struct sockaddr *)&addr, sizeof(addr));\n\tif (err < 0) {\n\t\tperror(\"bind s2 failed()\");\n\t\treturn errno;\n\t}\n\n\t \n\taddr.sin_port = htons(S1_PORT);\n\terr = listen(s1, 32);\n\tif (err < 0) {\n\t\tperror(\"listen s1 failed()\");\n\t\treturn errno;\n\t}\n\n\taddr.sin_port = htons(S2_PORT);\n\terr = listen(s2, 32);\n\tif (err < 0) {\n\t\tperror(\"listen s1 failed()\");\n\t\treturn errno;\n\t}\n\n\t \n\taddr.sin_port = htons(S1_PORT);\n\terr = connect(c1, (struct sockaddr *)&addr, sizeof(addr));\n\tif (err < 0 && errno != EINPROGRESS) {\n\t\tperror(\"connect c1 failed()\");\n\t\treturn errno;\n\t}\n\n\taddr.sin_port = htons(S2_PORT);\n\terr = connect(c2, (struct sockaddr *)&addr, sizeof(addr));\n\tif (err < 0 && errno != EINPROGRESS) {\n\t\tperror(\"connect c2 failed()\");\n\t\treturn errno;\n\t} else if (err < 0) {\n\t\terr = 0;\n\t}\n\n\t \n\tp1 = accept(s1, NULL, NULL);\n\tif (p1 < 0) {\n\t\tperror(\"accept s1 failed()\");\n\t\treturn errno;\n\t}\n\n\tp2 = accept(s2, NULL, NULL);\n\tif (p2 < 0) {\n\t\tperror(\"accept s1 failed()\");\n\t\treturn errno;\n\t}\n\n\tif (verbose > 1) {\n\t\tprintf(\"connected sockets: c1 <-> p1, c2 <-> p2\\n\");\n\t\tprintf(\"cgroups binding: c1(%i) <-> s1(%i) - - - c2(%i) <-> s2(%i)\\n\",\n\t\t\tc1, s1, c2, s2);\n\t}\n\treturn 0;\n}\n\nstruct msg_stats {\n\tsize_t bytes_sent;\n\tsize_t bytes_recvd;\n\tstruct timespec start;\n\tstruct timespec end;\n};\n\nstatic int msg_loop_sendpage(int fd, int iov_length, int cnt,\n\t\t\t     struct msg_stats *s,\n\t\t\t     struct sockmap_options *opt)\n{\n\tbool drop = opt->drop_expected;\n\tunsigned char k = 0;\n\tFILE *file;\n\tint i, fp;\n\n\tfile = tmpfile();\n\tif (!file) {\n\t\tperror(\"create file for sendpage\");\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < iov_length * cnt; i++, k++)\n\t\tfwrite(&k, sizeof(char), 1, file);\n\tfflush(file);\n\tfseek(file, 0, SEEK_SET);\n\n\tfp = fileno(file);\n\n\tclock_gettime(CLOCK_MONOTONIC, &s->start);\n\tfor (i = 0; i < cnt; i++) {\n\t\tint sent;\n\n\t\terrno = 0;\n\t\tsent = sendfile(fd, fp, NULL, iov_length);\n\n\t\tif (!drop && sent < 0) {\n\t\t\tperror(\"sendpage loop error\");\n\t\t\tfclose(file);\n\t\t\treturn sent;\n\t\t} else if (drop && sent >= 0) {\n\t\t\tprintf(\"sendpage loop error expected: %i errno %i\\n\",\n\t\t\t       sent, errno);\n\t\t\tfclose(file);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (sent > 0)\n\t\t\ts->bytes_sent += sent;\n\t}\n\tclock_gettime(CLOCK_MONOTONIC, &s->end);\n\tfclose(file);\n\treturn 0;\n}\n\nstatic void msg_free_iov(struct msghdr *msg)\n{\n\tint i;\n\n\tfor (i = 0; i < msg->msg_iovlen; i++)\n\t\tfree(msg->msg_iov[i].iov_base);\n\tfree(msg->msg_iov);\n\tmsg->msg_iov = NULL;\n\tmsg->msg_iovlen = 0;\n}\n\nstatic int msg_alloc_iov(struct msghdr *msg,\n\t\t\t int iov_count, int iov_length,\n\t\t\t bool data, bool xmit)\n{\n\tunsigned char k = 0;\n\tstruct iovec *iov;\n\tint i;\n\n\tiov = calloc(iov_count, sizeof(struct iovec));\n\tif (!iov)\n\t\treturn errno;\n\n\tfor (i = 0; i < iov_count; i++) {\n\t\tunsigned char *d = calloc(iov_length, sizeof(char));\n\n\t\tif (!d) {\n\t\t\tfprintf(stderr, \"iov_count %i/%i OOM\\n\", i, iov_count);\n\t\t\tgoto unwind_iov;\n\t\t}\n\t\tiov[i].iov_base = d;\n\t\tiov[i].iov_len = iov_length;\n\n\t\tif (data && xmit) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < iov_length; j++)\n\t\t\t\td[j] = k++;\n\t\t}\n\t}\n\n\tmsg->msg_iov = iov;\n\tmsg->msg_iovlen = iov_count;\n\n\treturn 0;\nunwind_iov:\n\tfor (i--; i >= 0 ; i--)\n\t\tfree(msg->msg_iov[i].iov_base);\n\treturn -ENOMEM;\n}\n\nstatic int msg_verify_data(struct msghdr *msg, int size, int chunk_sz)\n{\n\tint i, j = 0, bytes_cnt = 0;\n\tunsigned char k = 0;\n\n\tfor (i = 0; i < msg->msg_iovlen; i++) {\n\t\tunsigned char *d = msg->msg_iov[i].iov_base;\n\n\t\t \n\t\tif (i == 0 && txmsg_ktls_skb) {\n\t\t\tif (msg->msg_iov[i].iov_len < 4)\n\t\t\t\treturn -EIO;\n\t\t\tif (memcmp(d, \"PASS\", 4) != 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"detected skb data error with skb ingress update @iov[%i]:%i \\\"%02x %02x %02x %02x\\\" != \\\"PASS\\\"\\n\",\n\t\t\t\t\ti, 0, d[0], d[1], d[2], d[3]);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tj = 4;  \n\t\t}\n\n\t\tfor (; j < msg->msg_iov[i].iov_len && size; j++) {\n\t\t\tif (d[j] != k++) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"detected data corruption @iov[%i]:%i %02x != %02x, %02x ?= %02x\\n\",\n\t\t\t\t\ti, j, d[j], k - 1, d[j+1], k);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tbytes_cnt++;\n\t\t\tif (bytes_cnt == chunk_sz) {\n\t\t\t\tk = 0;\n\t\t\t\tbytes_cnt = 0;\n\t\t\t}\n\t\t\tsize--;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int msg_loop(int fd, int iov_count, int iov_length, int cnt,\n\t\t    struct msg_stats *s, bool tx,\n\t\t    struct sockmap_options *opt)\n{\n\tstruct msghdr msg = {0}, msg_peek = {0};\n\tint err, i, flags = MSG_NOSIGNAL;\n\tbool drop = opt->drop_expected;\n\tbool data = opt->data_test;\n\tint iov_alloc_length = iov_length;\n\n\tif (!tx && opt->check_recved_len)\n\t\tiov_alloc_length *= 2;\n\n\terr = msg_alloc_iov(&msg, iov_count, iov_alloc_length, data, tx);\n\tif (err)\n\t\tgoto out_errno;\n\tif (peek_flag) {\n\t\terr = msg_alloc_iov(&msg_peek, iov_count, iov_length, data, tx);\n\t\tif (err)\n\t\t\tgoto out_errno;\n\t}\n\n\tif (tx) {\n\t\tclock_gettime(CLOCK_MONOTONIC, &s->start);\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tint sent;\n\n\t\t\terrno = 0;\n\t\t\tsent = sendmsg(fd, &msg, flags);\n\n\t\t\tif (!drop && sent < 0) {\n\t\t\t\tif (opt->tx_wait_mem && errno == EACCES) {\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tgoto out_errno;\n\t\t\t\t}\n\t\t\t\tperror(\"sendmsg loop error\");\n\t\t\t\tgoto out_errno;\n\t\t\t} else if (drop && sent >= 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"sendmsg loop error expected: %i errno %i\\n\",\n\t\t\t\t\tsent, errno);\n\t\t\t\terrno = -EIO;\n\t\t\t\tgoto out_errno;\n\t\t\t}\n\t\t\tif (sent > 0)\n\t\t\t\ts->bytes_sent += sent;\n\t\t}\n\t\tclock_gettime(CLOCK_MONOTONIC, &s->end);\n\t} else {\n\t\tint slct, recvp = 0, recv, max_fd = fd;\n\t\tfloat total_bytes, txmsg_pop_total;\n\t\tint fd_flags = O_NONBLOCK;\n\t\tstruct timeval timeout;\n\t\tfd_set w;\n\n\t\tfcntl(fd, fd_flags);\n\t\t \n\t\ttotal_bytes = (float)iov_count * (float)iov_length * (float)cnt;\n\t\tif (txmsg_apply)\n\t\t\ttxmsg_pop_total = txmsg_pop * (total_bytes / txmsg_apply);\n\t\telse\n\t\t\ttxmsg_pop_total = txmsg_pop * cnt;\n\t\ttotal_bytes -= txmsg_pop_total;\n\t\terr = clock_gettime(CLOCK_MONOTONIC, &s->start);\n\t\tif (err < 0)\n\t\t\tperror(\"recv start time\");\n\t\twhile (s->bytes_recvd < total_bytes) {\n\t\t\tif (txmsg_cork) {\n\t\t\t\ttimeout.tv_sec = 0;\n\t\t\t\ttimeout.tv_usec = 300000;\n\t\t\t} else {\n\t\t\t\ttimeout.tv_sec = 3;\n\t\t\t\ttimeout.tv_usec = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tFD_ZERO(&w);\n\t\t\tFD_SET(fd, &w);\n\n\t\t\tslct = select(max_fd + 1, &w, NULL, NULL, &timeout);\n\t\t\tif (slct == -1) {\n\t\t\t\tperror(\"select()\");\n\t\t\t\tclock_gettime(CLOCK_MONOTONIC, &s->end);\n\t\t\t\tgoto out_errno;\n\t\t\t} else if (!slct) {\n\t\t\t\tif (opt->verbose)\n\t\t\t\t\tfprintf(stderr, \"unexpected timeout: recved %zu/%f pop_total %f\\n\", s->bytes_recvd, total_bytes, txmsg_pop_total);\n\t\t\t\terrno = -EIO;\n\t\t\t\tclock_gettime(CLOCK_MONOTONIC, &s->end);\n\t\t\t\tgoto out_errno;\n\t\t\t}\n\n\t\t\tif (opt->tx_wait_mem) {\n\t\t\t\tFD_ZERO(&w);\n\t\t\t\tFD_SET(fd, &w);\n\t\t\t\tslct = select(max_fd + 1, NULL, NULL, &w, &timeout);\n\t\t\t\terrno = 0;\n\t\t\t\tclose(fd);\n\t\t\t\tgoto out_errno;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tif (peek_flag) {\n\t\t\t\tflags |= MSG_PEEK;\n\t\t\t\trecvp = recvmsg(fd, &msg_peek, flags);\n\t\t\t\tif (recvp < 0) {\n\t\t\t\t\tif (errno != EWOULDBLOCK) {\n\t\t\t\t\t\tclock_gettime(CLOCK_MONOTONIC, &s->end);\n\t\t\t\t\t\tgoto out_errno;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tflags = 0;\n\t\t\t}\n\n\t\t\trecv = recvmsg(fd, &msg, flags);\n\t\t\tif (recv < 0) {\n\t\t\t\tif (errno != EWOULDBLOCK) {\n\t\t\t\t\tclock_gettime(CLOCK_MONOTONIC, &s->end);\n\t\t\t\t\tperror(\"recv failed()\");\n\t\t\t\t\tgoto out_errno;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts->bytes_recvd += recv;\n\n\t\t\tif (opt->check_recved_len && s->bytes_recvd > total_bytes) {\n\t\t\t\terrno = EMSGSIZE;\n\t\t\t\tfprintf(stderr, \"recv failed(), bytes_recvd:%zd, total_bytes:%f\\n\",\n\t\t\t\t\t\ts->bytes_recvd, total_bytes);\n\t\t\t\tgoto out_errno;\n\t\t\t}\n\n\t\t\tif (data) {\n\t\t\t\tint chunk_sz = opt->sendpage ?\n\t\t\t\t\t\tiov_length * cnt :\n\t\t\t\t\t\tiov_length * iov_count;\n\n\t\t\t\terrno = msg_verify_data(&msg, recv, chunk_sz);\n\t\t\t\tif (errno) {\n\t\t\t\t\tperror(\"data verify msg failed\");\n\t\t\t\t\tgoto out_errno;\n\t\t\t\t}\n\t\t\t\tif (recvp) {\n\t\t\t\t\terrno = msg_verify_data(&msg_peek,\n\t\t\t\t\t\t\t\trecvp,\n\t\t\t\t\t\t\t\tchunk_sz);\n\t\t\t\t\tif (errno) {\n\t\t\t\t\t\tperror(\"data verify msg_peek failed\");\n\t\t\t\t\t\tgoto out_errno;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclock_gettime(CLOCK_MONOTONIC, &s->end);\n\t}\n\n\tmsg_free_iov(&msg);\n\tmsg_free_iov(&msg_peek);\n\treturn err;\nout_errno:\n\tmsg_free_iov(&msg);\n\tmsg_free_iov(&msg_peek);\n\treturn errno;\n}\n\nstatic float giga = 1000000000;\n\nstatic inline float sentBps(struct msg_stats s)\n{\n\treturn s.bytes_sent / (s.end.tv_sec - s.start.tv_sec);\n}\n\nstatic inline float recvdBps(struct msg_stats s)\n{\n\treturn s.bytes_recvd / (s.end.tv_sec - s.start.tv_sec);\n}\n\nstatic int sendmsg_test(struct sockmap_options *opt)\n{\n\tfloat sent_Bps = 0, recvd_Bps = 0;\n\tint rx_fd, txpid, rxpid, err = 0;\n\tstruct msg_stats s = {0};\n\tint iov_count = opt->iov_count;\n\tint iov_buf = opt->iov_length;\n\tint rx_status, tx_status;\n\tint cnt = opt->rate;\n\n\terrno = 0;\n\n\tif (opt->base)\n\t\trx_fd = p1;\n\telse\n\t\trx_fd = p2;\n\n\tif (ktls) {\n\t\t \n\t\tif (!txmsg_redir || txmsg_ingress) {\n\t\t\terr = sockmap_init_ktls(opt->verbose, rx_fd);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = sockmap_init_ktls(opt->verbose, c1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (opt->tx_wait_mem) {\n\t\tstruct timeval timeout;\n\t\tint rxtx_buf_len = 1024;\n\n\t\ttimeout.tv_sec = 3;\n\t\ttimeout.tv_usec = 0;\n\n\t\terr = setsockopt(c2, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(struct timeval));\n\t\terr |= setsockopt(c2, SOL_SOCKET, SO_SNDBUFFORCE, &rxtx_buf_len, sizeof(int));\n\t\terr |= setsockopt(p2, SOL_SOCKET, SO_RCVBUFFORCE, &rxtx_buf_len, sizeof(int));\n\t\tif (err) {\n\t\t\tperror(\"setsockopt failed()\");\n\t\t\treturn errno;\n\t\t}\n\t}\n\n\trxpid = fork();\n\tif (rxpid == 0) {\n\t\tif (txmsg_pop || txmsg_start_pop)\n\t\t\tiov_buf -= (txmsg_pop - txmsg_start_pop + 1);\n\t\tif (opt->drop_expected || txmsg_ktls_skb_drop)\n\t\t\t_exit(0);\n\n\t\tif (!iov_buf)  \n\t\t\t_exit(0);\n\n\t\tif (opt->sendpage)\n\t\t\tiov_count = 1;\n\t\terr = msg_loop(rx_fd, iov_count, iov_buf,\n\t\t\t       cnt, &s, false, opt);\n\t\tif (opt->verbose > 1)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"msg_loop_rx: iov_count %i iov_buf %i cnt %i err %i\\n\",\n\t\t\t\tiov_count, iov_buf, cnt, err);\n\t\tif (s.end.tv_sec - s.start.tv_sec) {\n\t\t\tsent_Bps = sentBps(s);\n\t\t\trecvd_Bps = recvdBps(s);\n\t\t}\n\t\tif (opt->verbose > 1)\n\t\t\tfprintf(stdout,\n\t\t\t\t\"rx_sendmsg: TX: %zuB %fB/s %fGB/s RX: %zuB %fB/s %fGB/s %s\\n\",\n\t\t\t\ts.bytes_sent, sent_Bps, sent_Bps/giga,\n\t\t\t\ts.bytes_recvd, recvd_Bps, recvd_Bps/giga,\n\t\t\t\tpeek_flag ? \"(peek_msg)\" : \"\");\n\t\tif (err && txmsg_cork)\n\t\t\terr = 0;\n\t\texit(err ? 1 : 0);\n\t} else if (rxpid == -1) {\n\t\tperror(\"msg_loop_rx\");\n\t\treturn errno;\n\t}\n\n\tif (opt->tx_wait_mem)\n\t\tclose(c2);\n\n\ttxpid = fork();\n\tif (txpid == 0) {\n\t\tif (opt->sendpage)\n\t\t\terr = msg_loop_sendpage(c1, iov_buf, cnt, &s, opt);\n\t\telse\n\t\t\terr = msg_loop(c1, iov_count, iov_buf,\n\t\t\t\t       cnt, &s, true, opt);\n\n\t\tif (err)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"msg_loop_tx: iov_count %i iov_buf %i cnt %i err %i\\n\",\n\t\t\t\tiov_count, iov_buf, cnt, err);\n\t\tif (s.end.tv_sec - s.start.tv_sec) {\n\t\t\tsent_Bps = sentBps(s);\n\t\t\trecvd_Bps = recvdBps(s);\n\t\t}\n\t\tif (opt->verbose > 1)\n\t\t\tfprintf(stdout,\n\t\t\t\t\"tx_sendmsg: TX: %zuB %fB/s %f GB/s RX: %zuB %fB/s %fGB/s\\n\",\n\t\t\t\ts.bytes_sent, sent_Bps, sent_Bps/giga,\n\t\t\t\ts.bytes_recvd, recvd_Bps, recvd_Bps/giga);\n\t\texit(err ? 1 : 0);\n\t} else if (txpid == -1) {\n\t\tperror(\"msg_loop_tx\");\n\t\treturn errno;\n\t}\n\n\tassert(waitpid(rxpid, &rx_status, 0) == rxpid);\n\tassert(waitpid(txpid, &tx_status, 0) == txpid);\n\tif (WIFEXITED(rx_status)) {\n\t\terr = WEXITSTATUS(rx_status);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"rx thread exited with err %d.\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (WIFEXITED(tx_status)) {\n\t\terr = WEXITSTATUS(tx_status);\n\t\tif (err)\n\t\t\tfprintf(stderr, \"tx thread exited with err %d.\\n\", err);\n\t}\nout:\n\treturn err;\n}\n\nstatic int forever_ping_pong(int rate, struct sockmap_options *opt)\n{\n\tstruct timeval timeout;\n\tchar buf[1024] = {0};\n\tint sc;\n\n\ttimeout.tv_sec = 10;\n\ttimeout.tv_usec = 0;\n\n\t \n\tsc = send(c1, buf, sizeof(buf), 0);\n\tif (sc < 0) {\n\t\tperror(\"send failed()\");\n\t\treturn sc;\n\t}\n\n\tdo {\n\t\tint s, rc, i, max_fd = p2;\n\t\tfd_set w;\n\n\t\t \n\t\tFD_ZERO(&w);\n\t\tFD_SET(c1, &w);\n\t\tFD_SET(c2, &w);\n\t\tFD_SET(p1, &w);\n\t\tFD_SET(p2, &w);\n\n\t\ts = select(max_fd + 1, &w, NULL, NULL, &timeout);\n\t\tif (s == -1) {\n\t\t\tperror(\"select()\");\n\t\t\tbreak;\n\t\t} else if (!s) {\n\t\t\tfprintf(stderr, \"unexpected timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i <= max_fd && s > 0; ++i) {\n\t\t\tif (!FD_ISSET(i, &w))\n\t\t\t\tcontinue;\n\n\t\t\ts--;\n\n\t\t\trc = recv(i, buf, sizeof(buf), 0);\n\t\t\tif (rc < 0) {\n\t\t\t\tif (errno != EWOULDBLOCK) {\n\t\t\t\t\tperror(\"recv failed()\");\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rc == 0) {\n\t\t\t\tclose(i);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsc = send(i, buf, rc, 0);\n\t\t\tif (sc < 0) {\n\t\t\t\tperror(\"send failed()\");\n\t\t\t\treturn sc;\n\t\t\t}\n\t\t}\n\n\t\tif (rate)\n\t\t\tsleep(rate);\n\n\t\tif (opt->verbose) {\n\t\t\tprintf(\".\");\n\t\t\tfflush(stdout);\n\n\t\t}\n\t} while (running);\n\n\treturn 0;\n}\n\nenum {\n\tSELFTESTS,\n\tPING_PONG,\n\tSENDMSG,\n\tBASE,\n\tBASE_SENDPAGE,\n\tSENDPAGE,\n};\n\nstatic int run_options(struct sockmap_options *options, int cg_fd,  int test)\n{\n\tint i, key, next_key, err, tx_prog_fd = -1, zero = 0;\n\n\t \n\tif (test == BASE || test == BASE_SENDPAGE)\n\t\tgoto run;\n\n\t \n\tif (!txmsg_omit_skb_parser) {\n\t\terr = bpf_prog_attach(prog_fd[0], map_fd[0],\n\t\t\t\t      BPF_SK_SKB_STREAM_PARSER, 0);\n\t\tif (err) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"ERROR: bpf_prog_attach (sockmap %i->%i): %d (%s)\\n\",\n\t\t\t\tprog_fd[0], map_fd[0], err, strerror(errno));\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = bpf_prog_attach(prog_fd[1], map_fd[0],\n\t\t\t\tBPF_SK_SKB_STREAM_VERDICT, 0);\n\tif (err) {\n\t\tfprintf(stderr, \"ERROR: bpf_prog_attach (sockmap): %d (%s)\\n\",\n\t\t\terr, strerror(errno));\n\t\treturn err;\n\t}\n\n\t \n\tif (txmsg_ktls_skb) {\n\t\tif (!txmsg_omit_skb_parser) {\n\t\t\terr = bpf_prog_attach(prog_fd[0], map_fd[8],\n\t\t\t\t\t      BPF_SK_SKB_STREAM_PARSER, 0);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_prog_attach (TLS sockmap %i->%i): %d (%s)\\n\",\n\t\t\t\t\tprog_fd[0], map_fd[8], err, strerror(errno));\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\terr = bpf_prog_attach(prog_fd[2], map_fd[8],\n\t\t\t\t      BPF_SK_SKB_STREAM_VERDICT, 0);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"ERROR: bpf_prog_attach (TLS sockmap): %d (%s)\\n\",\n\t\t\t\terr, strerror(errno));\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = bpf_prog_attach(prog_fd[3], cg_fd, BPF_CGROUP_SOCK_OPS, 0);\n\tif (err) {\n\t\tfprintf(stderr, \"ERROR: bpf_prog_attach (groups): %d (%s)\\n\",\n\t\t\terr, strerror(errno));\n\t\treturn err;\n\t}\n\nrun:\n\terr = sockmap_init_sockets(options->verbose);\n\tif (err) {\n\t\tfprintf(stderr, \"ERROR: test socket failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t \n\tif (txmsg_pass)\n\t\ttx_prog_fd = prog_fd[4];\n\telse if (txmsg_redir)\n\t\ttx_prog_fd = prog_fd[5];\n\telse if (txmsg_apply)\n\t\ttx_prog_fd = prog_fd[6];\n\telse if (txmsg_cork)\n\t\ttx_prog_fd = prog_fd[7];\n\telse if (txmsg_drop)\n\t\ttx_prog_fd = prog_fd[8];\n\telse\n\t\ttx_prog_fd = 0;\n\n\tif (tx_prog_fd) {\n\t\tint redir_fd, i = 0;\n\n\t\terr = bpf_prog_attach(tx_prog_fd,\n\t\t\t\t      map_fd[1], BPF_SK_MSG_VERDICT, 0);\n\t\tif (err) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"ERROR: bpf_prog_attach (txmsg): %d (%s)\\n\",\n\t\t\t\terr, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = bpf_map_update_elem(map_fd[1], &i, &c1, BPF_ANY);\n\t\tif (err) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"ERROR: bpf_map_update_elem (txmsg):  %d (%s\\n\",\n\t\t\t\terr, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (txmsg_redir)\n\t\t\tredir_fd = c2;\n\t\telse\n\t\t\tredir_fd = c1;\n\n\t\terr = bpf_map_update_elem(map_fd[2], &i, &redir_fd, BPF_ANY);\n\t\tif (err) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"ERROR: bpf_map_update_elem (txmsg):  %d (%s\\n\",\n\t\t\t\terr, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (txmsg_apply) {\n\t\t\terr = bpf_map_update_elem(map_fd[3],\n\t\t\t\t\t\t  &i, &txmsg_apply, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (apply_bytes):  %d (%s\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (txmsg_cork) {\n\t\t\terr = bpf_map_update_elem(map_fd[4],\n\t\t\t\t\t\t  &i, &txmsg_cork, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (cork_bytes):  %d (%s\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (txmsg_start) {\n\t\t\terr = bpf_map_update_elem(map_fd[5],\n\t\t\t\t\t\t  &i, &txmsg_start, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (txmsg_start):  %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (txmsg_end) {\n\t\t\ti = 1;\n\t\t\terr = bpf_map_update_elem(map_fd[5],\n\t\t\t\t\t\t  &i, &txmsg_end, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (txmsg_end):  %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (txmsg_start_push) {\n\t\t\ti = 2;\n\t\t\terr = bpf_map_update_elem(map_fd[5],\n\t\t\t\t\t\t  &i, &txmsg_start_push, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (txmsg_start_push):  %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (txmsg_end_push) {\n\t\t\ti = 3;\n\t\t\terr = bpf_map_update_elem(map_fd[5],\n\t\t\t\t\t\t  &i, &txmsg_end_push, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem %i@%i (txmsg_end_push):  %d (%s)\\n\",\n\t\t\t\t\ttxmsg_end_push, i, err, strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (txmsg_start_pop) {\n\t\t\ti = 4;\n\t\t\terr = bpf_map_update_elem(map_fd[5],\n\t\t\t\t\t\t  &i, &txmsg_start_pop, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem %i@%i (txmsg_start_pop):  %d (%s)\\n\",\n\t\t\t\t\ttxmsg_start_pop, i, err, strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\ti = 4;\n\t\t\tbpf_map_update_elem(map_fd[5],\n\t\t\t\t\t\t  &i, &txmsg_start_pop, BPF_ANY);\n\t\t}\n\n\t\tif (txmsg_pop) {\n\t\t\ti = 5;\n\t\t\terr = bpf_map_update_elem(map_fd[5],\n\t\t\t\t\t\t  &i, &txmsg_pop, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem %i@%i (txmsg_pop):  %d (%s)\\n\",\n\t\t\t\t\ttxmsg_pop, i, err, strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\ti = 5;\n\t\t\tbpf_map_update_elem(map_fd[5],\n\t\t\t\t\t    &i, &txmsg_pop, BPF_ANY);\n\n\t\t}\n\n\t\tif (txmsg_ingress) {\n\t\t\tint in = BPF_F_INGRESS;\n\n\t\t\ti = 0;\n\t\t\terr = bpf_map_update_elem(map_fd[6], &i, &in, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (txmsg_ingress): %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t}\n\t\t\ti = 1;\n\t\t\terr = bpf_map_update_elem(map_fd[1], &i, &p1, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (p1 txmsg): %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t}\n\t\t\terr = bpf_map_update_elem(map_fd[2], &i, &p1, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (p1 redir): %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t}\n\n\t\t\ti = 2;\n\t\t\terr = bpf_map_update_elem(map_fd[2], &i, &p2, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (p2 txmsg): %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t}\n\t\t}\n\n\t\tif (txmsg_ktls_skb) {\n\t\t\tint ingress = BPF_F_INGRESS;\n\n\t\t\ti = 0;\n\t\t\terr = bpf_map_update_elem(map_fd[8], &i, &p2, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (c1 sockmap): %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t}\n\n\t\t\tif (txmsg_ktls_skb_redir) {\n\t\t\t\ti = 1;\n\t\t\t\terr = bpf_map_update_elem(map_fd[7],\n\t\t\t\t\t\t\t  &i, &ingress, BPF_ANY);\n\t\t\t\tif (err) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"ERROR: bpf_map_update_elem (txmsg_ingress): %d (%s)\\n\",\n\t\t\t\t\t\terr, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (txmsg_ktls_skb_drop) {\n\t\t\t\ti = 1;\n\t\t\t\terr = bpf_map_update_elem(map_fd[7], &i, &i, BPF_ANY);\n\t\t\t}\n\t\t}\n\n\t\tif (txmsg_redir_skb) {\n\t\t\tint skb_fd = (test == SENDMSG || test == SENDPAGE) ?\n\t\t\t\t\tp2 : p1;\n\t\t\tint ingress = BPF_F_INGRESS;\n\n\t\t\ti = 0;\n\t\t\terr = bpf_map_update_elem(map_fd[7],\n\t\t\t\t\t\t  &i, &ingress, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (txmsg_ingress): %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t}\n\n\t\t\ti = 3;\n\t\t\terr = bpf_map_update_elem(map_fd[0], &i, &skb_fd, BPF_ANY);\n\t\t\tif (err) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: bpf_map_update_elem (c1 sockmap): %d (%s)\\n\",\n\t\t\t\t\terr, strerror(errno));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (skb_use_parser) {\n\t\ti = 2;\n\t\terr = bpf_map_update_elem(map_fd[7], &i, &skb_use_parser, BPF_ANY);\n\t}\n\n\tif (txmsg_drop)\n\t\toptions->drop_expected = true;\n\n\tif (test == PING_PONG)\n\t\terr = forever_ping_pong(options->rate, options);\n\telse if (test == SENDMSG) {\n\t\toptions->base = false;\n\t\toptions->sendpage = false;\n\t\terr = sendmsg_test(options);\n\t} else if (test == SENDPAGE) {\n\t\toptions->base = false;\n\t\toptions->sendpage = true;\n\t\terr = sendmsg_test(options);\n\t} else if (test == BASE) {\n\t\toptions->base = true;\n\t\toptions->sendpage = false;\n\t\terr = sendmsg_test(options);\n\t} else if (test == BASE_SENDPAGE) {\n\t\toptions->base = true;\n\t\toptions->sendpage = true;\n\t\terr = sendmsg_test(options);\n\t} else\n\t\tfprintf(stderr, \"unknown test\\n\");\nout:\n\t \n\tbpf_prog_detach2(prog_fd[3], cg_fd, BPF_CGROUP_SOCK_OPS);\n\tbpf_prog_detach2(prog_fd[0], map_fd[0], BPF_SK_SKB_STREAM_PARSER);\n\tbpf_prog_detach2(prog_fd[1], map_fd[0], BPF_SK_SKB_STREAM_VERDICT);\n\tbpf_prog_detach2(prog_fd[0], map_fd[8], BPF_SK_SKB_STREAM_PARSER);\n\tbpf_prog_detach2(prog_fd[2], map_fd[8], BPF_SK_SKB_STREAM_VERDICT);\n\n\tif (tx_prog_fd >= 0)\n\t\tbpf_prog_detach2(tx_prog_fd, map_fd[1], BPF_SK_MSG_VERDICT);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tkey = next_key = 0;\n\t\tbpf_map_update_elem(map_fd[i], &key, &zero, BPF_ANY);\n\t\twhile (bpf_map_get_next_key(map_fd[i], &key, &next_key) == 0) {\n\t\t\tbpf_map_update_elem(map_fd[i], &key, &zero, BPF_ANY);\n\t\t\tkey = next_key;\n\t\t}\n\t}\n\n\tclose(s1);\n\tclose(s2);\n\tclose(p1);\n\tclose(p2);\n\tclose(c1);\n\tclose(c2);\n\treturn err;\n}\n\nstatic char *test_to_str(int test)\n{\n\tswitch (test) {\n\tcase SENDMSG:\n\t\treturn \"sendmsg\";\n\tcase SENDPAGE:\n\t\treturn \"sendpage\";\n\t}\n\treturn \"unknown\";\n}\n\nstatic void append_str(char *dst, const char *src, size_t dst_cap)\n{\n\tsize_t avail = dst_cap - strlen(dst);\n\n\tif (avail <= 1)  \n\t\treturn;\n\n\tstrncat(dst, src, avail - 1);  \n}\n\n#define OPTSTRING 60\nstatic void test_options(char *options)\n{\n\tchar tstr[OPTSTRING];\n\n\tmemset(options, 0, OPTSTRING);\n\n\tif (txmsg_pass)\n\t\tappend_str(options, \"pass,\", OPTSTRING);\n\tif (txmsg_redir)\n\t\tappend_str(options, \"redir,\", OPTSTRING);\n\tif (txmsg_drop)\n\t\tappend_str(options, \"drop,\", OPTSTRING);\n\tif (txmsg_apply) {\n\t\tsnprintf(tstr, OPTSTRING, \"apply %d,\", txmsg_apply);\n\t\tappend_str(options, tstr, OPTSTRING);\n\t}\n\tif (txmsg_cork) {\n\t\tsnprintf(tstr, OPTSTRING, \"cork %d,\", txmsg_cork);\n\t\tappend_str(options, tstr, OPTSTRING);\n\t}\n\tif (txmsg_start) {\n\t\tsnprintf(tstr, OPTSTRING, \"start %d,\", txmsg_start);\n\t\tappend_str(options, tstr, OPTSTRING);\n\t}\n\tif (txmsg_end) {\n\t\tsnprintf(tstr, OPTSTRING, \"end %d,\", txmsg_end);\n\t\tappend_str(options, tstr, OPTSTRING);\n\t}\n\tif (txmsg_start_pop) {\n\t\tsnprintf(tstr, OPTSTRING, \"pop (%d,%d),\",\n\t\t\t txmsg_start_pop, txmsg_start_pop + txmsg_pop);\n\t\tappend_str(options, tstr, OPTSTRING);\n\t}\n\tif (txmsg_ingress)\n\t\tappend_str(options, \"ingress,\", OPTSTRING);\n\tif (txmsg_redir_skb)\n\t\tappend_str(options, \"redir_skb,\", OPTSTRING);\n\tif (txmsg_ktls_skb)\n\t\tappend_str(options, \"ktls_skb,\", OPTSTRING);\n\tif (ktls)\n\t\tappend_str(options, \"ktls,\", OPTSTRING);\n\tif (peek_flag)\n\t\tappend_str(options, \"peek,\", OPTSTRING);\n}\n\nstatic int __test_exec(int cgrp, int test, struct sockmap_options *opt)\n{\n\tchar *options = calloc(OPTSTRING, sizeof(char));\n\tint err;\n\n\tif (test == SENDPAGE)\n\t\topt->sendpage = true;\n\telse\n\t\topt->sendpage = false;\n\n\tif (txmsg_drop)\n\t\topt->drop_expected = true;\n\telse\n\t\topt->drop_expected = false;\n\n\ttest_options(options);\n\n\tif (opt->verbose) {\n\t\tfprintf(stdout,\n\t\t\t\" [TEST %i]: (%i, %i, %i, %s, %s): \",\n\t\t\ttest_cnt, opt->rate, opt->iov_count, opt->iov_length,\n\t\t\ttest_to_str(test), options);\n\t\tfflush(stdout);\n\t}\n\terr = run_options(opt, cgrp, test);\n\tif (opt->verbose)\n\t\tfprintf(stdout, \" %s\\n\", !err ? \"PASS\" : \"FAILED\");\n\ttest_cnt++;\n\t!err ? passed++ : failed++;\n\tfree(options);\n\treturn err;\n}\n\nstatic void test_exec(int cgrp, struct sockmap_options *opt)\n{\n\tint type = strcmp(opt->map, BPF_SOCKMAP_FILENAME);\n\tint err;\n\n\tif (type == 0) {\n\t\ttest_start();\n\t\terr = __test_exec(cgrp, SENDMSG, opt);\n\t\tif (err)\n\t\t\ttest_fail();\n\t} else {\n\t\ttest_start();\n\t\terr = __test_exec(cgrp, SENDPAGE, opt);\n\t\tif (err)\n\t\t\ttest_fail();\n\t}\n}\n\nstatic void test_send_one(struct sockmap_options *opt, int cgrp)\n{\n\topt->iov_length = 1;\n\topt->iov_count = 1;\n\topt->rate = 1;\n\ttest_exec(cgrp, opt);\n\n\topt->iov_length = 1;\n\topt->iov_count = 1024;\n\topt->rate = 1;\n\ttest_exec(cgrp, opt);\n\n\topt->iov_length = 1024;\n\topt->iov_count = 1;\n\topt->rate = 1;\n\ttest_exec(cgrp, opt);\n\n}\n\nstatic void test_send_many(struct sockmap_options *opt, int cgrp)\n{\n\topt->iov_length = 3;\n\topt->iov_count = 1;\n\topt->rate = 512;\n\ttest_exec(cgrp, opt);\n\n\topt->rate = 100;\n\topt->iov_count = 1;\n\topt->iov_length = 5;\n\ttest_exec(cgrp, opt);\n}\n\nstatic void test_send_large(struct sockmap_options *opt, int cgrp)\n{\n\topt->iov_length = 256;\n\topt->iov_count = 1024;\n\topt->rate = 2;\n\ttest_exec(cgrp, opt);\n}\n\nstatic void test_send(struct sockmap_options *opt, int cgrp)\n{\n\ttest_send_one(opt, cgrp);\n\ttest_send_many(opt, cgrp);\n\ttest_send_large(opt, cgrp);\n\tsched_yield();\n}\n\nstatic void test_txmsg_pass(int cgrp, struct sockmap_options *opt)\n{\n\t \n\ttxmsg_pass = 1;\n\ttest_send(opt, cgrp);\n}\n\nstatic void test_txmsg_redir(int cgrp, struct sockmap_options *opt)\n{\n\ttxmsg_redir = 1;\n\ttest_send(opt, cgrp);\n}\n\nstatic void test_txmsg_redir_wait_sndmem(int cgrp, struct sockmap_options *opt)\n{\n\ttxmsg_redir = 1;\n\topt->tx_wait_mem = true;\n\ttest_send_large(opt, cgrp);\n\topt->tx_wait_mem = false;\n}\n\nstatic void test_txmsg_drop(int cgrp, struct sockmap_options *opt)\n{\n\ttxmsg_drop = 1;\n\ttest_send(opt, cgrp);\n}\n\nstatic void test_txmsg_ingress_redir(int cgrp, struct sockmap_options *opt)\n{\n\ttxmsg_pass = txmsg_drop = 0;\n\ttxmsg_ingress = txmsg_redir = 1;\n\ttest_send(opt, cgrp);\n}\n\nstatic void test_txmsg_skb(int cgrp, struct sockmap_options *opt)\n{\n\tbool data = opt->data_test;\n\tint k = ktls;\n\n\topt->data_test = true;\n\tktls = 1;\n\n\ttxmsg_pass = txmsg_drop = 0;\n\ttxmsg_ingress = txmsg_redir = 0;\n\ttxmsg_ktls_skb = 1;\n\ttxmsg_pass = 1;\n\n\t \n\topt->iov_length = 100;\n\topt->iov_count = 1;\n\topt->rate = 1;\n\ttest_exec(cgrp, opt);\n\n\ttxmsg_ktls_skb_drop = 1;\n\ttest_exec(cgrp, opt);\n\n\ttxmsg_ktls_skb_drop = 0;\n\ttxmsg_ktls_skb_redir = 1;\n\ttest_exec(cgrp, opt);\n\ttxmsg_ktls_skb_redir = 0;\n\n\t \n\ttxmsg_omit_skb_parser = 1;\n\tktls = 0;\n\ttxmsg_ktls_skb = 0;\n\ttest_exec(cgrp, opt);\n\n\ttxmsg_ktls_skb_drop = 1;\n\ttest_exec(cgrp, opt);\n\ttxmsg_ktls_skb_drop = 0;\n\n\ttxmsg_ktls_skb_redir = 1;\n\ttest_exec(cgrp, opt);\n\n\tktls = 1;\n\ttest_exec(cgrp, opt);\n\ttxmsg_omit_skb_parser = 0;\n\n\topt->data_test = data;\n\tktls = k;\n}\n\n \nstatic void test_txmsg_cork_hangs(int cgrp, struct sockmap_options *opt)\n{\n\ttxmsg_pass = 1;\n\ttxmsg_redir = 0;\n\ttxmsg_cork = 4097;\n\ttxmsg_apply = 4097;\n\ttest_send_large(opt, cgrp);\n\n\ttxmsg_pass = 0;\n\ttxmsg_redir = 1;\n\ttxmsg_apply = 0;\n\ttxmsg_cork = 4097;\n\ttest_send_large(opt, cgrp);\n\n\ttxmsg_pass = 0;\n\ttxmsg_redir = 1;\n\ttxmsg_apply = 4097;\n\ttxmsg_cork = 4097;\n\ttest_send_large(opt, cgrp);\n}\n\nstatic void test_txmsg_pull(int cgrp, struct sockmap_options *opt)\n{\n\t \n\ttxmsg_start = 1;\n\ttxmsg_end = 2;\n\ttest_send(opt, cgrp);\n\n\t \n\ttxmsg_start = 4096;\n\ttxmsg_end = 9182;\n\ttest_send_large(opt, cgrp);\n\n\t \n\ttxmsg_redir = 0;\n\ttxmsg_start = 1;\n\ttxmsg_end = 2;\n\ttest_send(opt, cgrp);\n\n\t \n\ttxmsg_redir = 0;\n\ttxmsg_cork = 512;\n\ttxmsg_start = 1;\n\ttxmsg_end = 2;\n\ttest_send_many(opt, cgrp);\n\n\t \n\ttxmsg_redir = 1;\n\ttxmsg_cork = 512;\n\ttxmsg_start = 1;\n\ttxmsg_end = 2;\n\ttest_send_many(opt, cgrp);\n}\n\nstatic void test_txmsg_pop(int cgrp, struct sockmap_options *opt)\n{\n\t \n\ttxmsg_start_pop = 1;\n\ttxmsg_pop = 2;\n\ttest_send_many(opt, cgrp);\n\n\t \n\ttxmsg_start_pop = 4096;\n\ttxmsg_pop = 4096;\n\ttest_send_large(opt, cgrp);\n\n\t \n\ttxmsg_redir = 1;\n\ttxmsg_start_pop = 1;\n\ttxmsg_pop = 2;\n\ttest_send_many(opt, cgrp);\n\n\t \n\ttxmsg_redir = 0;\n\ttxmsg_cork = 512;\n\ttxmsg_start_pop = 1;\n\ttxmsg_pop = 2;\n\ttest_send_many(opt, cgrp);\n\n\t \n\ttxmsg_redir = 1;\n\ttxmsg_cork = 4;\n\ttxmsg_start_pop = 1;\n\ttxmsg_pop = 2;\n\ttest_send_many(opt, cgrp);\n}\n\nstatic void test_txmsg_push(int cgrp, struct sockmap_options *opt)\n{\n\t \n\ttxmsg_start_push = 1;\n\ttxmsg_end_push = 1;\n\ttest_send(opt, cgrp);\n\n\t \n\ttxmsg_start_push = 4096;\n\ttxmsg_end_push = 4096;\n\ttest_send_large(opt, cgrp);\n\n\t \n\ttxmsg_redir = 1;\n\ttxmsg_start_push = 1;\n\ttxmsg_end_push = 2;\n\ttest_send_many(opt, cgrp);\n\n\t \n\ttxmsg_redir = 0;\n\ttxmsg_cork = 512;\n\ttxmsg_start_push = 1;\n\ttxmsg_end_push = 2;\n\ttest_send_many(opt, cgrp);\n}\n\nstatic void test_txmsg_push_pop(int cgrp, struct sockmap_options *opt)\n{\n\ttxmsg_start_push = 1;\n\ttxmsg_end_push = 10;\n\ttxmsg_start_pop = 5;\n\ttxmsg_pop = 4;\n\ttest_send_large(opt, cgrp);\n}\n\nstatic void test_txmsg_apply(int cgrp, struct sockmap_options *opt)\n{\n\ttxmsg_pass = 1;\n\ttxmsg_redir = 0;\n\ttxmsg_ingress = 0;\n\ttxmsg_apply = 1;\n\ttxmsg_cork = 0;\n\ttest_send_one(opt, cgrp);\n\n\ttxmsg_pass = 0;\n\ttxmsg_redir = 1;\n\ttxmsg_ingress = 0;\n\ttxmsg_apply = 1;\n\ttxmsg_cork = 0;\n\ttest_send_one(opt, cgrp);\n\n\ttxmsg_pass = 0;\n\ttxmsg_redir = 1;\n\ttxmsg_ingress = 1;\n\ttxmsg_apply = 1;\n\ttxmsg_cork = 0;\n\ttest_send_one(opt, cgrp);\n\n\ttxmsg_pass = 1;\n\ttxmsg_redir = 0;\n\ttxmsg_ingress = 0;\n\ttxmsg_apply = 1024;\n\ttxmsg_cork = 0;\n\ttest_send_large(opt, cgrp);\n\n\ttxmsg_pass = 0;\n\ttxmsg_redir = 1;\n\ttxmsg_ingress = 0;\n\ttxmsg_apply = 1024;\n\ttxmsg_cork = 0;\n\ttest_send_large(opt, cgrp);\n\n\ttxmsg_pass = 0;\n\ttxmsg_redir = 1;\n\ttxmsg_ingress = 1;\n\ttxmsg_apply = 1024;\n\ttxmsg_cork = 0;\n\ttest_send_large(opt, cgrp);\n}\n\nstatic void test_txmsg_cork(int cgrp, struct sockmap_options *opt)\n{\n\ttxmsg_pass = 1;\n\ttxmsg_redir = 0;\n\ttxmsg_apply = 0;\n\ttxmsg_cork = 1;\n\ttest_send(opt, cgrp);\n\n\ttxmsg_pass = 1;\n\ttxmsg_redir = 0;\n\ttxmsg_apply = 1;\n\ttxmsg_cork = 1;\n\ttest_send(opt, cgrp);\n}\n\nstatic void test_txmsg_ingress_parser(int cgrp, struct sockmap_options *opt)\n{\n\ttxmsg_pass = 1;\n\tskb_use_parser = 512;\n\tif (ktls == 1)\n\t\tskb_use_parser = 570;\n\topt->iov_length = 256;\n\topt->iov_count = 1;\n\topt->rate = 2;\n\ttest_exec(cgrp, opt);\n}\n\nstatic void test_txmsg_ingress_parser2(int cgrp, struct sockmap_options *opt)\n{\n\tif (ktls == 1)\n\t\treturn;\n\tskb_use_parser = 10;\n\topt->iov_length = 20;\n\topt->iov_count = 1;\n\topt->rate = 1;\n\topt->check_recved_len = true;\n\ttest_exec(cgrp, opt);\n\topt->check_recved_len = false;\n}\n\nchar *map_names[] = {\n\t\"sock_map\",\n\t\"sock_map_txmsg\",\n\t\"sock_map_redir\",\n\t\"sock_apply_bytes\",\n\t\"sock_cork_bytes\",\n\t\"sock_bytes\",\n\t\"sock_redir_flags\",\n\t\"sock_skb_opts\",\n\t\"tls_sock_map\",\n};\n\nint prog_attach_type[] = {\n\tBPF_SK_SKB_STREAM_PARSER,\n\tBPF_SK_SKB_STREAM_VERDICT,\n\tBPF_SK_SKB_STREAM_VERDICT,\n\tBPF_CGROUP_SOCK_OPS,\n\tBPF_SK_MSG_VERDICT,\n\tBPF_SK_MSG_VERDICT,\n\tBPF_SK_MSG_VERDICT,\n\tBPF_SK_MSG_VERDICT,\n\tBPF_SK_MSG_VERDICT,\n\tBPF_SK_MSG_VERDICT,\n\tBPF_SK_MSG_VERDICT,\n};\n\nint prog_type[] = {\n\tBPF_PROG_TYPE_SK_SKB,\n\tBPF_PROG_TYPE_SK_SKB,\n\tBPF_PROG_TYPE_SK_SKB,\n\tBPF_PROG_TYPE_SOCK_OPS,\n\tBPF_PROG_TYPE_SK_MSG,\n\tBPF_PROG_TYPE_SK_MSG,\n\tBPF_PROG_TYPE_SK_MSG,\n\tBPF_PROG_TYPE_SK_MSG,\n\tBPF_PROG_TYPE_SK_MSG,\n\tBPF_PROG_TYPE_SK_MSG,\n\tBPF_PROG_TYPE_SK_MSG,\n};\n\nstatic int populate_progs(char *bpf_file)\n{\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tint i = 0;\n\tlong err;\n\n\tobj = bpf_object__open(bpf_file);\n\terr = libbpf_get_error(obj);\n\tif (err) {\n\t\tchar err_buf[256];\n\n\t\tlibbpf_strerror(err, err_buf, sizeof(err_buf));\n\t\tprintf(\"Unable to load eBPF objects in file '%s' : %s\\n\",\n\t\t       bpf_file, err_buf);\n\t\treturn -1;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tbpf_program__set_type(prog, prog_type[i]);\n\t\tbpf_program__set_expected_attach_type(prog,\n\t\t\t\t\t\t      prog_attach_type[i]);\n\t\ti++;\n\t}\n\n\ti = bpf_object__load(obj);\n\ti = 0;\n\tbpf_object__for_each_program(prog, obj) {\n\t\tprog_fd[i] = bpf_program__fd(prog);\n\t\ti++;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(map_fd); i++) {\n\t\tmaps[i] = bpf_object__find_map_by_name(obj, map_names[i]);\n\t\tmap_fd[i] = bpf_map__fd(maps[i]);\n\t\tif (map_fd[i] < 0) {\n\t\t\tfprintf(stderr, \"load_bpf_file: (%i) %s\\n\",\n\t\t\t\tmap_fd[i], strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct _test test[] = {\n\t{\"txmsg test passthrough\", test_txmsg_pass},\n\t{\"txmsg test redirect\", test_txmsg_redir},\n\t{\"txmsg test redirect wait send mem\", test_txmsg_redir_wait_sndmem},\n\t{\"txmsg test drop\", test_txmsg_drop},\n\t{\"txmsg test ingress redirect\", test_txmsg_ingress_redir},\n\t{\"txmsg test skb\", test_txmsg_skb},\n\t{\"txmsg test apply\", test_txmsg_apply},\n\t{\"txmsg test cork\", test_txmsg_cork},\n\t{\"txmsg test hanging corks\", test_txmsg_cork_hangs},\n\t{\"txmsg test push_data\", test_txmsg_push},\n\t{\"txmsg test pull-data\", test_txmsg_pull},\n\t{\"txmsg test pop-data\", test_txmsg_pop},\n\t{\"txmsg test push/pop data\", test_txmsg_push_pop},\n\t{\"txmsg test ingress parser\", test_txmsg_ingress_parser},\n\t{\"txmsg test ingress parser2\", test_txmsg_ingress_parser2},\n};\n\nstatic int check_whitelist(struct _test *t, struct sockmap_options *opt)\n{\n\tchar *entry, *ptr;\n\n\tif (!opt->whitelist)\n\t\treturn 0;\n\tptr = strdup(opt->whitelist);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tentry = strtok(ptr, \",\");\n\twhile (entry) {\n\t\tif ((opt->prepend && strstr(opt->prepend, entry) != 0) ||\n\t\t    strstr(opt->map, entry) != 0 ||\n\t\t    strstr(t->title, entry) != 0)\n\t\t\treturn 0;\n\t\tentry = strtok(NULL, \",\");\n\t}\n\treturn -EINVAL;\n}\n\nstatic int check_blacklist(struct _test *t, struct sockmap_options *opt)\n{\n\tchar *entry, *ptr;\n\n\tif (!opt->blacklist)\n\t\treturn -EINVAL;\n\tptr = strdup(opt->blacklist);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tentry = strtok(ptr, \",\");\n\twhile (entry) {\n\t\tif ((opt->prepend && strstr(opt->prepend, entry) != 0) ||\n\t\t    strstr(opt->map, entry) != 0 ||\n\t\t    strstr(t->title, entry) != 0)\n\t\t\treturn 0;\n\t\tentry = strtok(NULL, \",\");\n\t}\n\treturn -EINVAL;\n}\n\nstatic int __test_selftests(int cg_fd, struct sockmap_options *opt)\n{\n\tint i, err;\n\n\terr = populate_progs(opt->map);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"ERROR: (%i) load bpf failed\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(test); i++) {\n\t\tstruct _test t = test[i];\n\n\t\tif (check_whitelist(&t, opt) != 0)\n\t\t\tcontinue;\n\t\tif (check_blacklist(&t, opt) == 0)\n\t\t\tcontinue;\n\n\t\ttest_start_subtest(&t, opt);\n\t\tt.tester(cg_fd, opt);\n\t\ttest_end_subtest();\n\t}\n\n\treturn err;\n}\n\nstatic void test_selftests_sockmap(int cg_fd, struct sockmap_options *opt)\n{\n\topt->map = BPF_SOCKMAP_FILENAME;\n\t__test_selftests(cg_fd, opt);\n}\n\nstatic void test_selftests_sockhash(int cg_fd, struct sockmap_options *opt)\n{\n\topt->map = BPF_SOCKHASH_FILENAME;\n\t__test_selftests(cg_fd, opt);\n}\n\nstatic void test_selftests_ktls(int cg_fd, struct sockmap_options *opt)\n{\n\topt->map = BPF_SOCKHASH_FILENAME;\n\topt->prepend = \"ktls\";\n\tktls = 1;\n\t__test_selftests(cg_fd, opt);\n\tktls = 0;\n}\n\nstatic int test_selftest(int cg_fd, struct sockmap_options *opt)\n{\n\n\ttest_selftests_sockmap(cg_fd, opt);\n\ttest_selftests_sockhash(cg_fd, opt);\n\ttest_selftests_ktls(cg_fd, opt);\n\ttest_print_results();\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint iov_count = 1, length = 1024, rate = 1;\n\tstruct sockmap_options options = {0};\n\tint opt, longindex, err, cg_fd = 0;\n\tchar *bpf_file = BPF_SOCKMAP_FILENAME;\n\tint test = SELFTESTS;\n\tbool cg_created = 0;\n\n\twhile ((opt = getopt_long(argc, argv, \":dhv:c:r:i:l:t:p:q:n:b:\",\n\t\t\t\t  long_options, &longindex)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\ttxmsg_start = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\ttxmsg_end = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttxmsg_start_push = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\ttxmsg_end_push = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttxmsg_start_pop = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\ttxmsg_pop = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\ttxmsg_apply = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\ttxmsg_cork = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcg_fd = open(optarg, O_DIRECTORY, O_RDONLY);\n\t\t\tif (cg_fd < 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"ERROR: (%i) open cg path failed: %s\\n\",\n\t\t\t\t\tcg_fd, optarg);\n\t\t\t\treturn cg_fd;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trate = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\toptions.verbose = 1;\n\t\t\tif (optarg)\n\t\t\t\toptions.verbose = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tiov_count = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlength = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\toptions.data_test = true;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (strcmp(optarg, \"ping\") == 0) {\n\t\t\t\ttest = PING_PONG;\n\t\t\t} else if (strcmp(optarg, \"sendmsg\") == 0) {\n\t\t\t\ttest = SENDMSG;\n\t\t\t} else if (strcmp(optarg, \"base\") == 0) {\n\t\t\t\ttest = BASE;\n\t\t\t} else if (strcmp(optarg, \"base_sendpage\") == 0) {\n\t\t\t\ttest = BASE_SENDPAGE;\n\t\t\t} else if (strcmp(optarg, \"sendpage\") == 0) {\n\t\t\t\ttest = SENDPAGE;\n\t\t\t} else {\n\t\t\t\tusage(argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\toptions.whitelist = strdup(optarg);\n\t\t\tif (!options.whitelist)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\toptions.blacklist = strdup(optarg);\n\t\t\tif (!options.blacklist)\n\t\t\t\treturn -ENOMEM;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage(argv);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!cg_fd) {\n\t\tcg_fd = cgroup_setup_and_join(CG_PATH);\n\t\tif (cg_fd < 0)\n\t\t\treturn cg_fd;\n\t\tcg_created = 1;\n\t}\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\tif (test == SELFTESTS) {\n\t\terr = test_selftest(cg_fd, &options);\n\t\tgoto out;\n\t}\n\n\terr = populate_progs(bpf_file);\n\tif (err) {\n\t\tfprintf(stderr, \"populate program: (%s) %s\\n\",\n\t\t\tbpf_file, strerror(errno));\n\t\treturn 1;\n\t}\n\trunning = 1;\n\n\t \n\tsignal(SIGINT, running_handler);\n\n\toptions.iov_count = iov_count;\n\toptions.iov_length = length;\n\toptions.rate = rate;\n\n\terr = run_options(&options, cg_fd, test);\nout:\n\tif (options.whitelist)\n\t\tfree(options.whitelist);\n\tif (options.blacklist)\n\t\tfree(options.blacklist);\n\tif (cg_created)\n\t\tcleanup_cgroup_environment();\n\tclose(cg_fd);\n\treturn err;\n}\n\nvoid running_handler(int a)\n{\n\trunning = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}