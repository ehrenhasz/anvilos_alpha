{
  "module_name": "test_lwt_seg6local.sh",
  "hash_id": "05c07aec414368690dec9487d5339481de57ab29f7e408292cbfbb9012f3ae66",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_lwt_seg6local.sh",
  "human_readable_source": "#!/bin/bash\n# Connects 6 network namespaces through veths.\n# Each NS may have different IPv6 global scope addresses :\n#   NS1 ---- NS2 ---- NS3 ---- NS4 ---- NS5 ---- NS6\n# fb00::1           fd00::1  fd00::2  fd00::3  fb00::6\n#                   fc42::1           fd00::4\n#\n# All IPv6 packets going to fb00::/16 through NS2 will be encapsulated in a\n# IPv6 header with a Segment Routing Header, with segments :\n# \tfd00::1 -> fd00::2 -> fd00::3 -> fd00::4\n#\n# 3 fd00::/16 IPv6 addresses are binded to seg6local End.BPF actions :\n# - fd00::1 : add a TLV, change the flags and apply a End.X action to fc42::1\n# - fd00::2 : remove the TLV, change the flags, add a tag\n# - fd00::3 : apply an End.T action to fd00::4, through routing table 117\n#\n# fd00::4 is a simple Segment Routing node decapsulating the inner IPv6 packet.\n# Each End.BPF action will validate the operations applied on the SRH by the\n# previous BPF program in the chain, otherwise the packet is dropped.\n#\n# An UDP datagram is sent from fb00::1 to fb00::6. The test succeeds if this\n# datagram can be read on NS6 when binding to fb00::6.\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nBPF_FILE=\"test_lwt_seg6local.bpf.o\"\nreadonly NS1=\"ns1-$(mktemp -u XXXXXX)\"\nreadonly NS2=\"ns2-$(mktemp -u XXXXXX)\"\nreadonly NS3=\"ns3-$(mktemp -u XXXXXX)\"\nreadonly NS4=\"ns4-$(mktemp -u XXXXXX)\"\nreadonly NS5=\"ns5-$(mktemp -u XXXXXX)\"\nreadonly NS6=\"ns6-$(mktemp -u XXXXXX)\"\n\nmsg=\"skip all tests:\"\nif [ $UID != 0 ]; then\n\techo $msg please run this as root >&2\n\texit $ksft_skip\nfi\n\nTMP_FILE=\"/tmp/selftest_lwt_seg6local.txt\"\n\ncleanup()\n{\n\tif [ \"$?\" = \"0\" ]; then\n\t\techo \"selftests: test_lwt_seg6local [PASS]\";\n\telse\n\t\techo \"selftests: test_lwt_seg6local [FAILED]\";\n\tfi\n\n\tset +e\n\tip netns del ${NS1} 2> /dev/null\n\tip netns del ${NS2} 2> /dev/null\n\tip netns del ${NS3} 2> /dev/null\n\tip netns del ${NS4} 2> /dev/null\n\tip netns del ${NS5} 2> /dev/null\n\tip netns del ${NS6} 2> /dev/null\n\trm -f $TMP_FILE\n}\n\nset -e\n\nip netns add ${NS1}\nip netns add ${NS2}\nip netns add ${NS3}\nip netns add ${NS4}\nip netns add ${NS5}\nip netns add ${NS6}\n\ntrap cleanup 0 2 3 6 9\n\nip link add veth1 type veth peer name veth2\nip link add veth3 type veth peer name veth4\nip link add veth5 type veth peer name veth6\nip link add veth7 type veth peer name veth8\nip link add veth9 type veth peer name veth10\n\nip link set veth1 netns ${NS1}\nip link set veth2 netns ${NS2}\nip link set veth3 netns ${NS2}\nip link set veth4 netns ${NS3}\nip link set veth5 netns ${NS3}\nip link set veth6 netns ${NS4}\nip link set veth7 netns ${NS4}\nip link set veth8 netns ${NS5}\nip link set veth9 netns ${NS5}\nip link set veth10 netns ${NS6}\n\nip netns exec ${NS1} ip link set dev veth1 up\nip netns exec ${NS2} ip link set dev veth2 up\nip netns exec ${NS2} ip link set dev veth3 up\nip netns exec ${NS3} ip link set dev veth4 up\nip netns exec ${NS3} ip link set dev veth5 up\nip netns exec ${NS4} ip link set dev veth6 up\nip netns exec ${NS4} ip link set dev veth7 up\nip netns exec ${NS5} ip link set dev veth8 up\nip netns exec ${NS5} ip link set dev veth9 up\nip netns exec ${NS6} ip link set dev veth10 up\nip netns exec ${NS6} ip link set dev lo up\n\n# All link scope addresses and routes required between veths\nip netns exec ${NS1} ip -6 addr add fb00::12/16 dev veth1 scope link\nip netns exec ${NS1} ip -6 route add fb00::21 dev veth1 scope link\nip netns exec ${NS2} ip -6 addr add fb00::21/16 dev veth2 scope link\nip netns exec ${NS2} ip -6 addr add fb00::34/16 dev veth3 scope link\nip netns exec ${NS2} ip -6 route add fb00::43 dev veth3 scope link\nip netns exec ${NS3} ip -6 route add fb00::65 dev veth5 scope link\nip netns exec ${NS3} ip -6 addr add fb00::43/16 dev veth4 scope link\nip netns exec ${NS3} ip -6 addr add fb00::56/16 dev veth5 scope link\nip netns exec ${NS4} ip -6 addr add fb00::65/16 dev veth6 scope link\nip netns exec ${NS4} ip -6 addr add fb00::78/16 dev veth7 scope link\nip netns exec ${NS4} ip -6 route add fb00::87 dev veth7 scope link\nip netns exec ${NS5} ip -6 addr add fb00::87/16 dev veth8 scope link\nip netns exec ${NS5} ip -6 addr add fb00::910/16 dev veth9 scope link\nip netns exec ${NS5} ip -6 route add fb00::109 dev veth9 scope link\nip netns exec ${NS5} ip -6 route add fb00::109 table 117 dev veth9 scope link\nip netns exec ${NS6} ip -6 addr add fb00::109/16 dev veth10 scope link\n\nip netns exec ${NS1} ip -6 addr add fb00::1/16 dev lo\nip netns exec ${NS1} ip -6 route add fb00::6 dev veth1 via fb00::21\n\nip netns exec ${NS2} ip -6 route add fb00::6 encap bpf in obj ${BPF_FILE} sec encap_srh dev veth2\nip netns exec ${NS2} ip -6 route add fd00::1 dev veth3 via fb00::43 scope link\n\nip netns exec ${NS3} ip -6 route add fc42::1 dev veth5 via fb00::65\nip netns exec ${NS3} ip -6 route add fd00::1 encap seg6local action End.BPF endpoint obj ${BPF_FILE} sec add_egr_x dev veth4\n\nip netns exec ${NS4} ip -6 route add fd00::2 encap seg6local action End.BPF endpoint obj ${BPF_FILE} sec pop_egr dev veth6\nip netns exec ${NS4} ip -6 addr add fc42::1 dev lo\nip netns exec ${NS4} ip -6 route add fd00::3 dev veth7 via fb00::87\n\nip netns exec ${NS5} ip -6 route add fd00::4 table 117 dev veth9 via fb00::109\nip netns exec ${NS5} ip -6 route add fd00::3 encap seg6local action End.BPF endpoint obj ${BPF_FILE} sec inspect_t dev veth8\n\nip netns exec ${NS6} ip -6 addr add fb00::6/16 dev lo\nip netns exec ${NS6} ip -6 addr add fd00::4/16 dev lo\n\nip netns exec ${NS1} sysctl net.ipv6.conf.all.forwarding=1 > /dev/null\nip netns exec ${NS2} sysctl net.ipv6.conf.all.forwarding=1 > /dev/null\nip netns exec ${NS3} sysctl net.ipv6.conf.all.forwarding=1 > /dev/null\nip netns exec ${NS4} sysctl net.ipv6.conf.all.forwarding=1 > /dev/null\nip netns exec ${NS5} sysctl net.ipv6.conf.all.forwarding=1 > /dev/null\n\nip netns exec ${NS6} sysctl net.ipv6.conf.all.seg6_enabled=1 > /dev/null\nip netns exec ${NS6} sysctl net.ipv6.conf.lo.seg6_enabled=1 > /dev/null\nip netns exec ${NS6} sysctl net.ipv6.conf.veth10.seg6_enabled=1 > /dev/null\n\nip netns exec ${NS6} nc -l -6 -u -d 7330 > $TMP_FILE &\nip netns exec ${NS1} bash -c \"echo 'foobar' | nc -w0 -6 -u -p 2121 -s fb00::1 fb00::6 7330\"\nsleep 5 # wait enough time to ensure the UDP datagram arrived to the last segment\nkill -TERM $!\n\nif [[ $(< $TMP_FILE) != \"foobar\" ]]; then\n\texit 1\nfi\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}