{
  "module_name": "generate_udp_fragments.py",
  "hash_id": "640d598581e51c7f3b5b136a138ed55c72b57fce6a0267b7b34386bd200f85a2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/generate_udp_fragments.py",
  "human_readable_source": "#!/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n\n\"\"\"\nThis script helps generate fragmented UDP packets.\n\nWhile it is technically possible to dynamically generate\nfragmented packets in C, it is much harder to read and write\nsaid code. `scapy` is relatively industry standard and really\neasy to read / write.\n\nSo we choose to write this script that generates a valid C\nheader. Rerun script and commit generated file after any\nmodifications.\n\"\"\"\n\nimport argparse\nimport os\n\nfrom scapy.all import *\n\n\n# These constants must stay in sync with `ip_check_defrag.c`\nVETH1_ADDR = \"172.16.1.200\"\nVETH0_ADDR6 = \"fc00::100\"\nVETH1_ADDR6 = \"fc00::200\"\nCLIENT_PORT = 48878\nSERVER_PORT = 48879\nMAGIC_MESSAGE = \"THIS IS THE ORIGINAL MESSAGE, PLEASE REASSEMBLE ME\"\n\n\ndef print_header(f):\n    f.write(\"// SPDX-License-Identifier: GPL-2.0\\n\")\n    f.write(\"/* DO NOT EDIT -- this file is generated */\\n\")\n    f.write(\"\\n\")\n    f.write(\"#ifndef _IP_CHECK_DEFRAG_FRAGS_H\\n\")\n    f.write(\"#define _IP_CHECK_DEFRAG_FRAGS_H\\n\")\n    f.write(\"\\n\")\n    f.write(\"#include <stdint.h>\\n\")\n    f.write(\"\\n\")\n\n\ndef print_frags(f, frags, v6):\n    for idx, frag in enumerate(frags):\n        # 10 bytes per line to keep width in check\n        chunks = [frag[i : i + 10] for i in range(0, len(frag), 10)]\n        chunks_fmted = [\", \".join([str(hex(b)) for b in chunk]) for chunk in chunks]\n        suffix = \"6\" if v6 else \"\"\n\n        f.write(f\"static uint8_t frag{suffix}_{idx}[] = {{\\n\")\n        for chunk in chunks_fmted:\n            f.write(f\"\\t{chunk},\\n\")\n        f.write(f\"}};\\n\")\n\n\ndef print_trailer(f):\n    f.write(\"\\n\")\n    f.write(\"#endif /* _IP_CHECK_DEFRAG_FRAGS_H */\\n\")\n\n\ndef main(f):\n    # srcip of 0 is filled in by IP_HDRINCL\n    sip = \"0.0.0.0\"\n    sip6 = VETH0_ADDR6\n    dip = VETH1_ADDR\n    dip6 = VETH1_ADDR6\n    sport = CLIENT_PORT\n    dport = SERVER_PORT\n    payload = MAGIC_MESSAGE.encode()\n\n    # Disable UDPv4 checksums to keep code simpler\n    pkt = IP(src=sip,dst=dip) / UDP(sport=sport,dport=dport,chksum=0) / Raw(load=payload)\n    # UDPv6 requires a checksum\n    # Also pin the ipv6 fragment header ID, otherwise it's a random value\n    pkt6 = IPv6(src=sip6,dst=dip6) / IPv6ExtHdrFragment(id=0xBEEF) / UDP(sport=sport,dport=dport) / Raw(load=payload)\n\n    frags = [f.build() for f in pkt.fragment(24)]\n    frags6 = [f.build() for f in fragment6(pkt6, 72)]\n\n    print_header(f)\n    print_frags(f, frags, False)\n    print_frags(f, frags6, True)\n    print_trailer(f)\n\n\nif __name__ == \"__main__\":\n    dir = os.path.dirname(os.path.realpath(__file__))\n    header = f\"{dir}/ip_check_defrag_frags.h\"\n    with open(header, \"w\") as f:\n        main(f)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}