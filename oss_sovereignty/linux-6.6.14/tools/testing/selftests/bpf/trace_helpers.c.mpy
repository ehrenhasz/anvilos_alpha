{
  "module_name": "trace_helpers.c",
  "hash_id": "a16f5cf70ea75ec4d5c116e48ed13d3adcee9c9d2ffdec764422a8af3527fe6a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/trace_helpers.c",
  "human_readable_source": "\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <poll.h>\n#include <unistd.h>\n#include <linux/perf_event.h>\n#include <sys/mman.h>\n#include \"trace_helpers.h\"\n#include <linux/limits.h>\n#include <libelf.h>\n#include <gelf.h>\n\n#define TRACEFS_PIPE\t\"/sys/kernel/tracing/trace_pipe\"\n#define DEBUGFS_PIPE\t\"/sys/kernel/debug/tracing/trace_pipe\"\n\n#define MAX_SYMS 400000\nstatic struct ksym syms[MAX_SYMS];\nstatic int sym_cnt;\n\nstatic int ksym_cmp(const void *p1, const void *p2)\n{\n\treturn ((struct ksym *)p1)->addr - ((struct ksym *)p2)->addr;\n}\n\nint load_kallsyms_refresh(void)\n{\n\tFILE *f;\n\tchar func[256], buf[256];\n\tchar symbol;\n\tvoid *addr;\n\tint i = 0;\n\n\tsym_cnt = 0;\n\n\tf = fopen(\"/proc/kallsyms\", \"r\");\n\tif (!f)\n\t\treturn -ENOENT;\n\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\tif (sscanf(buf, \"%p %c %s\", &addr, &symbol, func) != 3)\n\t\t\tbreak;\n\t\tif (!addr)\n\t\t\tcontinue;\n\t\tif (i >= MAX_SYMS)\n\t\t\treturn -EFBIG;\n\n\t\tsyms[i].addr = (long) addr;\n\t\tsyms[i].name = strdup(func);\n\t\ti++;\n\t}\n\tfclose(f);\n\tsym_cnt = i;\n\tqsort(syms, sym_cnt, sizeof(struct ksym), ksym_cmp);\n\treturn 0;\n}\n\nint load_kallsyms(void)\n{\n\t \n\tif (sym_cnt)\n\t\treturn 0;\n\treturn load_kallsyms_refresh();\n}\n\nstruct ksym *ksym_search(long key)\n{\n\tint start = 0, end = sym_cnt;\n\tint result;\n\n\t \n\tif (sym_cnt <= 0)\n\t\treturn NULL;\n\n\twhile (start < end) {\n\t\tsize_t mid = start + (end - start) / 2;\n\n\t\tresult = key - syms[mid].addr;\n\t\tif (result < 0)\n\t\t\tend = mid;\n\t\telse if (result > 0)\n\t\t\tstart = mid + 1;\n\t\telse\n\t\t\treturn &syms[mid];\n\t}\n\n\tif (start >= 1 && syms[start - 1].addr < key &&\n\t    key < syms[start].addr)\n\t\t \n\t\treturn &syms[start - 1];\n\n\t \n\treturn &syms[0];\n}\n\nlong ksym_get_addr(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < sym_cnt; i++) {\n\t\tif (strcmp(syms[i].name, name) == 0)\n\t\t\treturn syms[i].addr;\n\t}\n\n\treturn 0;\n}\n\n \nint kallsyms_find(const char *sym, unsigned long long *addr)\n{\n\tchar type, name[500];\n\tunsigned long long value;\n\tint err = 0;\n\tFILE *f;\n\n\tf = fopen(\"/proc/kallsyms\", \"r\");\n\tif (!f)\n\t\treturn -EINVAL;\n\n\twhile (fscanf(f, \"%llx %c %499s%*[^\\n]\\n\", &value, &type, name) > 0) {\n\t\tif (strcmp(name, sym) == 0) {\n\t\t\t*addr = value;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = -ENOENT;\n\nout:\n\tfclose(f);\n\treturn err;\n}\n\nvoid read_trace_pipe(void)\n{\n\tint trace_fd;\n\n\tif (access(TRACEFS_PIPE, F_OK) == 0)\n\t\ttrace_fd = open(TRACEFS_PIPE, O_RDONLY, 0);\n\telse\n\t\ttrace_fd = open(DEBUGFS_PIPE, O_RDONLY, 0);\n\tif (trace_fd < 0)\n\t\treturn;\n\n\twhile (1) {\n\t\tstatic char buf[4096];\n\t\tssize_t sz;\n\n\t\tsz = read(trace_fd, buf, sizeof(buf) - 1);\n\t\tif (sz > 0) {\n\t\t\tbuf[sz] = 0;\n\t\t\tputs(buf);\n\t\t}\n\t}\n}\n\nssize_t get_uprobe_offset(const void *addr)\n{\n\tsize_t start, end, base;\n\tchar buf[256];\n\tbool found = false;\n\tFILE *f;\n\n\tf = fopen(\"/proc/self/maps\", \"r\");\n\tif (!f)\n\t\treturn -errno;\n\n\twhile (fscanf(f, \"%zx-%zx %s %zx %*[^\\n]\\n\", &start, &end, buf, &base) == 4) {\n\t\tif (buf[2] == 'x' && (uintptr_t)addr >= start && (uintptr_t)addr < end) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(f);\n\n\tif (!found)\n\t\treturn -ESRCH;\n\n#if defined(__powerpc64__) && defined(_CALL_ELF) && _CALL_ELF == 2\n\n#define OP_RT_RA_MASK   0xffff0000UL\n#define LIS_R2          0x3c400000UL\n#define ADDIS_R2_R12    0x3c4c0000UL\n#define ADDI_R2_R2      0x38420000UL\n\n\t \n\t{\n\t\tconst u32 *insn = (const u32 *)(uintptr_t)addr;\n\n\t\tif ((((*insn & OP_RT_RA_MASK) == ADDIS_R2_R12) ||\n\t\t     ((*insn & OP_RT_RA_MASK) == LIS_R2)) &&\n\t\t    ((*(insn + 1) & OP_RT_RA_MASK) == ADDI_R2_R2))\n\t\t\treturn (uintptr_t)(insn + 2) - start + base;\n\t}\n#endif\n\treturn (uintptr_t)addr - start + base;\n}\n\nssize_t get_rel_offset(uintptr_t addr)\n{\n\tsize_t start, end, offset;\n\tchar buf[256];\n\tFILE *f;\n\n\tf = fopen(\"/proc/self/maps\", \"r\");\n\tif (!f)\n\t\treturn -errno;\n\n\twhile (fscanf(f, \"%zx-%zx %s %zx %*[^\\n]\\n\", &start, &end, buf, &offset) == 4) {\n\t\tif (addr >= start && addr < end) {\n\t\t\tfclose(f);\n\t\t\treturn (size_t)addr - start + offset;\n\t\t}\n\t}\n\n\tfclose(f);\n\treturn -EINVAL;\n}\n\nstatic int\nparse_build_id_buf(const void *note_start, Elf32_Word note_size, char *build_id)\n{\n\tElf32_Word note_offs = 0;\n\n\twhile (note_offs + sizeof(Elf32_Nhdr) < note_size) {\n\t\tElf32_Nhdr *nhdr = (Elf32_Nhdr *)(note_start + note_offs);\n\n\t\tif (nhdr->n_type == 3 && nhdr->n_namesz == sizeof(\"GNU\") &&\n\t\t    !strcmp((char *)(nhdr + 1), \"GNU\") && nhdr->n_descsz > 0 &&\n\t\t    nhdr->n_descsz <= BPF_BUILD_ID_SIZE) {\n\t\t\tmemcpy(build_id, note_start + note_offs +\n\t\t\t       ALIGN(sizeof(\"GNU\"), 4) + sizeof(Elf32_Nhdr), nhdr->n_descsz);\n\t\t\tmemset(build_id + nhdr->n_descsz, 0, BPF_BUILD_ID_SIZE - nhdr->n_descsz);\n\t\t\treturn (int) nhdr->n_descsz;\n\t\t}\n\n\t\tnote_offs = note_offs + sizeof(Elf32_Nhdr) +\n\t\t\t   ALIGN(nhdr->n_namesz, 4) + ALIGN(nhdr->n_descsz, 4);\n\t}\n\n\treturn -ENOENT;\n}\n\n \nint read_build_id(const char *path, char *build_id, size_t size)\n{\n\tint fd, err = -EINVAL;\n\tElf *elf = NULL;\n\tGElf_Ehdr ehdr;\n\tsize_t max, i;\n\n\tif (size < BPF_BUILD_ID_SIZE)\n\t\treturn -EINVAL;\n\n\tfd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\t(void)elf_version(EV_CURRENT);\n\n\telf = elf_begin(fd, ELF_C_READ_MMAP, NULL);\n\tif (!elf)\n\t\tgoto out;\n\tif (elf_kind(elf) != ELF_K_ELF)\n\t\tgoto out;\n\tif (!gelf_getehdr(elf, &ehdr))\n\t\tgoto out;\n\n\tfor (i = 0; i < ehdr.e_phnum; i++) {\n\t\tGElf_Phdr mem, *phdr;\n\t\tchar *data;\n\n\t\tphdr = gelf_getphdr(elf, i, &mem);\n\t\tif (!phdr)\n\t\t\tgoto out;\n\t\tif (phdr->p_type != PT_NOTE)\n\t\t\tcontinue;\n\t\tdata = elf_rawfile(elf, &max);\n\t\tif (!data)\n\t\t\tgoto out;\n\t\tif (phdr->p_offset + phdr->p_memsz > max)\n\t\t\tgoto out;\n\t\terr = parse_build_id_buf(data + phdr->p_offset, phdr->p_memsz, build_id);\n\t\tif (err > 0)\n\t\t\tbreak;\n\t}\n\nout:\n\tif (elf)\n\t\telf_end(elf);\n\tclose(fd);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}