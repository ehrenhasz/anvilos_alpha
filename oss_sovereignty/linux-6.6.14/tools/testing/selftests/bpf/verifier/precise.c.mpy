{
  "module_name": "precise.c",
  "hash_id": "98b990570b51e02a324eaf6e9471c44c38704e4f3a7962f8423e3c402332d2f9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/verifier/precise.c",
  "human_readable_source": "{\n\t\"precise: test 1\",\n\t.insns = {\n\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_FP),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\n\tBPF_ST_MEM(BPF_DW, BPF_REG_FP, -8, 0),\n\tBPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\n\tBPF_MOV64_REG(BPF_REG_9, BPF_REG_0),\n\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_FP),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\n\tBPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\n\tBPF_MOV64_REG(BPF_REG_8, BPF_REG_0),\n\n\tBPF_ALU64_REG(BPF_SUB, BPF_REG_9, BPF_REG_8),  \n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_9),\n\tBPF_JMP_IMM(BPF_JLT, BPF_REG_2, 8, 1),\n\tBPF_EXIT_INSN(),\n\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1),  \n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_FP),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -8),\n\tBPF_MOV64_IMM(BPF_REG_3, 0),\n\tBPF_EMIT_CALL(BPF_FUNC_probe_read_kernel),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.fixup_map_array_48b = { 1 },\n\t.result = VERBOSE_ACCEPT,\n\t.errstr =\n\t\"mark_precise: frame0: last_idx 26 first_idx 20\\\n\tmark_precise: frame0: regs=r2 stack= before 25\\\n\tmark_precise: frame0: regs=r2 stack= before 24\\\n\tmark_precise: frame0: regs=r2 stack= before 23\\\n\tmark_precise: frame0: regs=r2 stack= before 22\\\n\tmark_precise: frame0: regs=r2 stack= before 20\\\n\tmark_precise: frame0: parent state regs=r2 stack=:\\\n\tmark_precise: frame0: last_idx 19 first_idx 10\\\n\tmark_precise: frame0: regs=r2,r9 stack= before 19\\\n\tmark_precise: frame0: regs=r9 stack= before 18\\\n\tmark_precise: frame0: regs=r8,r9 stack= before 17\\\n\tmark_precise: frame0: regs=r0,r9 stack= before 15\\\n\tmark_precise: frame0: regs=r0,r9 stack= before 14\\\n\tmark_precise: frame0: regs=r9 stack= before 13\\\n\tmark_precise: frame0: regs=r9 stack= before 12\\\n\tmark_precise: frame0: regs=r9 stack= before 11\\\n\tmark_precise: frame0: regs=r9 stack= before 10\\\n\tmark_precise: frame0: parent state regs= stack=:\",\n},\n{\n\t\"precise: test 2\",\n\t.insns = {\n\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_FP),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\n\tBPF_ST_MEM(BPF_DW, BPF_REG_FP, -8, 0),\n\tBPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\n\tBPF_MOV64_REG(BPF_REG_9, BPF_REG_0),\n\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_FP),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\n\tBPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\n\tBPF_MOV64_REG(BPF_REG_8, BPF_REG_0),\n\n\tBPF_ALU64_REG(BPF_SUB, BPF_REG_9, BPF_REG_8), /* map_value_ptr -= map_value_ptr */\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_9),\n\tBPF_JMP_IMM(BPF_JLT, BPF_REG_2, 8, 1),\n\tBPF_EXIT_INSN(),\n\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 1), /* R2=scalar(umin=1, umax=8) */\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_FP),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -8),\n\tBPF_MOV64_IMM(BPF_REG_3, 0),\n\tBPF_EMIT_CALL(BPF_FUNC_probe_read_kernel),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_TRACEPOINT,\n\t.fixup_map_array_48b = { 1 },\n\t.result = VERBOSE_ACCEPT,\n\t.flags = BPF_F_TEST_STATE_FREQ,\n\t.errstr =\n\t\"26: (85) call bpf_probe_read_kernel#113\\\n\tmark_precise: frame0: last_idx 26 first_idx 22\\\n\tmark_precise: frame0: regs=r2 stack= before 25\\\n\tmark_precise: frame0: regs=r2 stack= before 24\\\n\tmark_precise: frame0: regs=r2 stack= before 23\\\n\tmark_precise: frame0: regs=r2 stack= before 22\\\n\tmark_precise: frame0: parent state regs=r2 stack=:\\\n\tmark_precise: frame0: last_idx 20 first_idx 20\\\n\tmark_precise: frame0: regs=r2,r9 stack= before 20\\\n\tmark_precise: frame0: parent state regs=r2,r9 stack=:\\\n\tmark_precise: frame0: last_idx 19 first_idx 17\\\n\tmark_precise: frame0: regs=r2,r9 stack= before 19\\\n\tmark_precise: frame0: regs=r9 stack= before 18\\\n\tmark_precise: frame0: regs=r8,r9 stack= before 17\\\n\tmark_precise: frame0: parent state regs= stack=:\",\n},\n{\n\t\"precise: cross frame pruning\",\n\t.insns = {\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_get_prandom_u32),\n\tBPF_MOV64_IMM(BPF_REG_8, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_MOV64_IMM(BPF_REG_8, 1),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_get_prandom_u32),\n\tBPF_MOV64_IMM(BPF_REG_9, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_MOV64_IMM(BPF_REG_9, 1),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 1, 0, 4),\n\tBPF_JMP_IMM(BPF_JEQ, BPF_REG_8, 1, 1),\n\tBPF_LDX_MEM(BPF_B, BPF_REG_1, BPF_REG_2, 0),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_EXIT_INSN(),\n\tBPF_JMP_IMM(BPF_JEQ, BPF_REG_1, 0, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_XDP,\n\t.flags = BPF_F_TEST_STATE_FREQ,\n\t.errstr = \"!read_ok\",\n\t.result = REJECT,\n},\n{\n\t\"precise: ST insn causing spi > allocated_stack\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_3, BPF_REG_10),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_3, 123, 0),\n\tBPF_ST_MEM(BPF_DW, BPF_REG_3, -8, 0),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_10, -8),\n\tBPF_MOV64_IMM(BPF_REG_0, -1),\n\tBPF_JMP_REG(BPF_JGT, BPF_REG_4, BPF_REG_0, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_XDP,\n\t.flags = BPF_F_TEST_STATE_FREQ,\n\t.errstr = \"mark_precise: frame0: last_idx 5 first_idx 5\\\n\tmark_precise: frame0: parent state regs=r4 stack=:\\\n\tmark_precise: frame0: last_idx 4 first_idx 2\\\n\tmark_precise: frame0: regs=r4 stack= before 4\\\n\tmark_precise: frame0: regs=r4 stack= before 3\\\n\tmark_precise: frame0: regs= stack=-8 before 2\\\n\tmark_precise: frame0: falling back to forcing all scalars precise\\\n\tforce_precise: frame0: forcing r0 to be precise\\\n\tmark_precise: frame0: last_idx 5 first_idx 5\\\n\tmark_precise: frame0: parent state regs= stack=:\",\n\t.result = VERBOSE_ACCEPT,\n\t.retval = -1,\n},\n{\n\t\"precise: STX insn causing spi > allocated_stack\",\n\t.insns = {\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_get_prandom_u32),\n\tBPF_MOV64_REG(BPF_REG_3, BPF_REG_10),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_3, 123, 0),\n\tBPF_STX_MEM(BPF_DW, BPF_REG_3, BPF_REG_0, -8),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_10, -8),\n\tBPF_MOV64_IMM(BPF_REG_0, -1),\n\tBPF_JMP_REG(BPF_JGT, BPF_REG_4, BPF_REG_0, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_XDP,\n\t.flags = BPF_F_TEST_STATE_FREQ,\n\t.errstr = \"mark_precise: frame0: last_idx 6 first_idx 6\\\n\tmark_precise: frame0: parent state regs=r4 stack=:\\\n\tmark_precise: frame0: last_idx 5 first_idx 3\\\n\tmark_precise: frame0: regs=r4 stack= before 5\\\n\tmark_precise: frame0: regs=r4 stack= before 4\\\n\tmark_precise: frame0: regs= stack=-8 before 3\\\n\tmark_precise: frame0: falling back to forcing all scalars precise\\\n\tforce_precise: frame0: forcing r0 to be precise\\\n\tforce_precise: frame0: forcing r0 to be precise\\\n\tforce_precise: frame0: forcing r0 to be precise\\\n\tforce_precise: frame0: forcing r0 to be precise\\\n\tmark_precise: frame0: last_idx 6 first_idx 6\\\n\tmark_precise: frame0: parent state regs= stack=:\",\n\t.result = VERBOSE_ACCEPT,\n\t.retval = -1,\n},\n{\n\t\"precise: mark_chain_precision for ARG_CONST_ALLOC_SIZE_OR_ZERO\",\n\t.insns = {\n\tBPF_LDX_MEM(BPF_W, BPF_REG_4, BPF_REG_1, offsetof(struct xdp_md, ingress_ifindex)),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_MOV64_IMM(BPF_REG_2, 1),\n\tBPF_MOV64_IMM(BPF_REG_3, 0),\n\tBPF_JMP_IMM(BPF_JEQ, BPF_REG_4, 0, 1),\n\tBPF_MOV64_IMM(BPF_REG_2, 0x1000),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_reserve),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_0),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 42),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_ringbuf_submit),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.fixup_map_ringbuf = { 1 },\n\t.prog_type = BPF_PROG_TYPE_XDP,\n\t.flags = BPF_F_TEST_STATE_FREQ | F_NEEDS_EFFICIENT_UNALIGNED_ACCESS,\n\t.errstr = \"invalid access to memory, mem_size=1 off=42 size=8\",\n\t.result = REJECT,\n},\n{\n\t\"precise: program doesn't prematurely prune branches\",\n\t.insns = {\n\t\tBPF_ALU64_IMM(BPF_MOV, BPF_REG_6, 0x400),\n\t\tBPF_ALU64_IMM(BPF_MOV, BPF_REG_7, 0),\n\t\tBPF_ALU64_IMM(BPF_MOV, BPF_REG_8, 0),\n\t\tBPF_ALU64_IMM(BPF_MOV, BPF_REG_9, 0x80000000),\n\t\tBPF_ALU64_IMM(BPF_MOD, BPF_REG_6, 0x401),\n\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 0),\n\t\tBPF_JMP_REG(BPF_JLE, BPF_REG_6, BPF_REG_9, 2),\n\t\tBPF_ALU64_IMM(BPF_MOD, BPF_REG_6, 1),\n\t\tBPF_ALU64_IMM(BPF_MOV, BPF_REG_9, 0),\n\t\tBPF_JMP_REG(BPF_JLE, BPF_REG_6, BPF_REG_9, 1),\n\t\tBPF_ALU64_IMM(BPF_MOV, BPF_REG_6, 0),\n\t\tBPF_ALU64_IMM(BPF_MOV, BPF_REG_0, 0),\n\t\tBPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),\n\t\tBPF_LD_MAP_FD(BPF_REG_4, 0),\n\t\tBPF_ALU64_REG(BPF_MOV, BPF_REG_1, BPF_REG_4),\n\t\tBPF_ALU64_REG(BPF_MOV, BPF_REG_2, BPF_REG_10),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\t\tBPF_EXIT_INSN(),\n\t\tBPF_ALU64_IMM(BPF_RSH, BPF_REG_6, 10),\n\t\tBPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 8192),\n\t\tBPF_ALU64_REG(BPF_MOV, BPF_REG_1, BPF_REG_0),\n\t\tBPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_6),\n\t\tBPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_0, 0),\n\t\tBPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_3, 0),\n\t\tBPF_EXIT_INSN(),\n\t},\n\t.fixup_map_array_48b = { 13 },\n\t.prog_type = BPF_PROG_TYPE_XDP,\n\t.result = REJECT,\n\t.errstr = \"register with unbounded min value is not allowed\",\n},\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}