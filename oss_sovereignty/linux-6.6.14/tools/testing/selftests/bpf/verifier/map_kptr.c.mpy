{
  "module_name": "map_kptr.c",
  "hash_id": "7e475e81aee84f55ab38e07162bcf7a7e7ad8a0a8af6c65924f503274ac95ec1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/verifier/map_kptr.c",
  "human_readable_source": " \n{\n\t\"map_kptr: BPF_ST imm != 0\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"BPF_ST imm must be 0 when storing to kptr at off=0\",\n},\n{\n\t\"map_kptr: size != bpf_size_to_bytes(BPF_DW)\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ST_MEM(BPF_W, BPF_REG_0, 0, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"kptr access size must be BPF_DW\",\n},\n{\n\t\"map_kptr: map_value non-const var_off\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_MOV64_REG(BPF_REG_3, BPF_REG_0),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_2, 0),\n\tBPF_JMP_IMM(BPF_JLE, BPF_REG_2, 4, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_JMP_IMM(BPF_JGE, BPF_REG_2, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ALU64_REG(BPF_ADD, BPF_REG_3, BPF_REG_2),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_3, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"kptr access cannot have variable offset\",\n\t.flags = F_NEEDS_EFFICIENT_UNALIGNED_ACCESS,\n},\n{\n\t\"map_kptr: bpf_kptr_xchg non-const var_off\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_MOV64_REG(BPF_REG_3, BPF_REG_0),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_2, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_2, 0),\n\tBPF_JMP_IMM(BPF_JLE, BPF_REG_2, 4, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_JMP_IMM(BPF_JGE, BPF_REG_2, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ALU64_REG(BPF_ADD, BPF_REG_3, BPF_REG_2),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_3),\n\tBPF_MOV64_IMM(BPF_REG_2, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_kptr_xchg),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"R1 doesn't have constant offset. kptr has to be at the constant offset\",\n},\n{\n\t\"map_kptr: unaligned boundary load/store\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 7),\n\tBPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"kptr access misaligned expected=0 off=7\",\n\t.flags = F_NEEDS_EFFICIENT_UNALIGNED_ACCESS,\n},\n{\n\t\"map_kptr: reject var_off != 0\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_1, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_1, 0),\n\tBPF_JMP_IMM(BPF_JLE, BPF_REG_2, 4, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_JMP_IMM(BPF_JGE, BPF_REG_2, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),\n\tBPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"variable untrusted_ptr_ access var_off=(0x0; 0x7) disallowed\",\n},\n \n{\n\t\"map_kptr: unref: reject btf_struct_ids_match == false\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_1, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 4),\n\tBPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"invalid kptr access, R1 type=untrusted_ptr_prog_test_ref_kfunc expected=ptr_prog_test\",\n},\n{\n\t\"map_kptr: unref: loaded pointer marked as untrusted\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0),\n\tBPF_LDX_MEM(BPF_W, BPF_REG_0, BPF_REG_0, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"R0 invalid mem access 'untrusted_ptr_or_null_'\",\n},\n{\n\t\"map_kptr: unref: correct in kernel type size\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 32),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"access beyond struct prog_test_ref_kfunc at off 32 size 8\",\n},\n{\n\t\"map_kptr: unref: inherit PTR_UNTRUSTED on struct walk\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, 16),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_this_cpu_ptr),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"R1 type=untrusted_ptr_ expected=percpu_ptr_\",\n},\n{\n\t\"map_kptr: unref: no reference state created\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = ACCEPT,\n},\n{\n\t\"map_kptr: unref: bpf_kptr_xchg rejected\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_0),\n\tBPF_MOV64_IMM(BPF_REG_2, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_kptr_xchg),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"off=0 kptr isn't referenced kptr\",\n},\n \n{\n\t\"map_kptr: ref: loaded pointer marked as untrusted\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_MOV64_IMM(BPF_REG_1, 0),\n\tBPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, 8),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_this_cpu_ptr),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"R1 type=rcu_ptr_or_null_ expected=percpu_ptr_\",\n},\n{\n\t\"map_kptr: ref: reject off != 0\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 8),\n\tBPF_MOV64_REG(BPF_REG_7, BPF_REG_0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_0),\n\tBPF_MOV64_IMM(BPF_REG_2, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_kptr_xchg),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_7),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 8),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 8),\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_kptr_xchg),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"invalid kptr access, R2 type=ptr_prog_test_ref_kfunc expected=ptr_prog_test_member\",\n},\n{\n\t\"map_kptr: ref: reference state created and released on xchg\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 8),\n\tBPF_MOV64_REG(BPF_REG_7, BPF_REG_0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_10),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -8),\n\tBPF_ST_MEM(BPF_DW, BPF_REG_1, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, BPF_PSEUDO_KFUNC_CALL, 0, 0),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_7),\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_kptr_xchg),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"Unreleased reference id=5 alloc_insn=20\",\n\t.fixup_kfunc_btf_id = {\n\t\t{ \"bpf_kfunc_call_test_acquire\", 15 },\n\t}\n},\n{\n\t\"map_kptr: ref: reject STX\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_MOV64_REG(BPF_REG_1, 0),\n\tBPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, 8),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"store to referenced kptr disallowed\",\n},\n{\n\t\"map_kptr: ref: reject ST\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_ST_MEM(BPF_DW, BPF_REG_0, 8, 0),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"store to referenced kptr disallowed\",\n},\n{\n\t\"map_kptr: reject helper access to kptr\",\n\t.insns = {\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\tBPF_LD_MAP_FD(BPF_REG_6, 0),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),\n\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\tBPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\tBPF_EXIT_INSN(),\n\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 2),\n\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_0),\n\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_delete_elem),\n\tBPF_EXIT_INSN(),\n\t},\n\t.prog_type = BPF_PROG_TYPE_SCHED_CLS,\n\t.fixup_map_kptr = { 1 },\n\t.result = REJECT,\n\t.errstr = \"kptr cannot be accessed indirectly by helper\",\n},\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}