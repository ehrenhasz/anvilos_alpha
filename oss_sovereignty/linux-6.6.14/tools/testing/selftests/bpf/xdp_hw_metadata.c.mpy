{
  "module_name": "xdp_hw_metadata.c",
  "hash_id": "4a20416e93d348528e6f51e17e9f4178d4f9f7d8792b2222f48769675668c0b1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/xdp_hw_metadata.c",
  "human_readable_source": "\n\n \n\n#include <test_progs.h>\n#include <network_helpers.h>\n#include \"xdp_hw_metadata.skel.h\"\n#include \"xsk.h\"\n\n#include <error.h>\n#include <linux/errqueue.h>\n#include <linux/if_link.h>\n#include <linux/net_tstamp.h>\n#include <linux/udp.h>\n#include <linux/sockios.h>\n#include <sys/mman.h>\n#include <net/if.h>\n#include <poll.h>\n#include <time.h>\n\n#include \"xdp_metadata.h\"\n\n#define UMEM_NUM 16\n#define UMEM_FRAME_SIZE XSK_UMEM__DEFAULT_FRAME_SIZE\n#define UMEM_SIZE (UMEM_FRAME_SIZE * UMEM_NUM)\n#define XDP_FLAGS (XDP_FLAGS_DRV_MODE | XDP_FLAGS_REPLACE)\n\nstruct xsk {\n\tvoid *umem_area;\n\tstruct xsk_umem *umem;\n\tstruct xsk_ring_prod fill;\n\tstruct xsk_ring_cons comp;\n\tstruct xsk_ring_prod tx;\n\tstruct xsk_ring_cons rx;\n\tstruct xsk_socket *socket;\n};\n\nstruct xdp_hw_metadata *bpf_obj;\nstruct xsk *rx_xsk;\nconst char *ifname;\nint ifindex;\nint rxq;\n\nvoid test__fail(void) {   }\n\nstatic int open_xsk(int ifindex, struct xsk *xsk, __u32 queue_id)\n{\n\tint mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE;\n\tconst struct xsk_socket_config socket_config = {\n\t\t.rx_size = XSK_RING_PROD__DEFAULT_NUM_DESCS,\n\t\t.tx_size = XSK_RING_PROD__DEFAULT_NUM_DESCS,\n\t\t.bind_flags = XDP_COPY,\n\t};\n\tconst struct xsk_umem_config umem_config = {\n\t\t.fill_size = XSK_RING_PROD__DEFAULT_NUM_DESCS,\n\t\t.comp_size = XSK_RING_CONS__DEFAULT_NUM_DESCS,\n\t\t.frame_size = XSK_UMEM__DEFAULT_FRAME_SIZE,\n\t\t.flags = XDP_UMEM_UNALIGNED_CHUNK_FLAG,\n\t};\n\t__u32 idx;\n\tu64 addr;\n\tint ret;\n\tint i;\n\n\txsk->umem_area = mmap(NULL, UMEM_SIZE, PROT_READ | PROT_WRITE, mmap_flags, -1, 0);\n\tif (xsk->umem_area == MAP_FAILED)\n\t\treturn -ENOMEM;\n\n\tret = xsk_umem__create(&xsk->umem,\n\t\t\t       xsk->umem_area, UMEM_SIZE,\n\t\t\t       &xsk->fill,\n\t\t\t       &xsk->comp,\n\t\t\t       &umem_config);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xsk_socket__create(&xsk->socket, ifindex, queue_id,\n\t\t\t\t xsk->umem,\n\t\t\t\t &xsk->rx,\n\t\t\t\t &xsk->tx,\n\t\t\t\t &socket_config);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tfor (i = 0; i < UMEM_NUM / 2; i++) {\n\t\taddr = i * UMEM_FRAME_SIZE;\n\t\tprintf(\"%p: tx_desc[%d] -> %lx\\n\", xsk, i, addr);\n\t}\n\n\t \n\n\tret = xsk_ring_prod__reserve(&xsk->fill, UMEM_NUM / 2, &idx);\n\tfor (i = 0; i < UMEM_NUM / 2; i++) {\n\t\taddr = (UMEM_NUM / 2 + i) * UMEM_FRAME_SIZE;\n\t\tprintf(\"%p: rx_desc[%d] -> %lx\\n\", xsk, i, addr);\n\t\t*xsk_ring_prod__fill_addr(&xsk->fill, i) = addr;\n\t}\n\txsk_ring_prod__submit(&xsk->fill, ret);\n\n\treturn 0;\n}\n\nstatic void close_xsk(struct xsk *xsk)\n{\n\tif (xsk->umem)\n\t\txsk_umem__delete(xsk->umem);\n\tif (xsk->socket)\n\t\txsk_socket__delete(xsk->socket);\n\tmunmap(xsk->umem_area, UMEM_SIZE);\n}\n\nstatic void refill_rx(struct xsk *xsk, __u64 addr)\n{\n\t__u32 idx;\n\n\tif (xsk_ring_prod__reserve(&xsk->fill, 1, &idx) == 1) {\n\t\tprintf(\"%p: complete idx=%u addr=%llx\\n\", xsk, idx, addr);\n\t\t*xsk_ring_prod__fill_addr(&xsk->fill, idx) = addr;\n\t\txsk_ring_prod__submit(&xsk->fill, 1);\n\t}\n}\n\n#define NANOSEC_PER_SEC 1000000000  \nstatic __u64 gettime(clockid_t clock_id)\n{\n\tstruct timespec t;\n\tint res;\n\n\t \n\tres = clock_gettime(clock_id, &t);\n\n\tif (res < 0)\n\t\terror(res, errno, \"Error with clock_gettime()\");\n\n\treturn (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;\n}\n\nstatic void verify_xdp_metadata(void *data, clockid_t clock_id)\n{\n\tstruct xdp_meta *meta;\n\n\tmeta = data - sizeof(*meta);\n\n\tif (meta->rx_hash_err < 0)\n\t\tprintf(\"No rx_hash err=%d\\n\", meta->rx_hash_err);\n\telse\n\t\tprintf(\"rx_hash: 0x%X with RSS type:0x%X\\n\",\n\t\t       meta->rx_hash, meta->rx_hash_type);\n\n\tprintf(\"rx_timestamp:  %llu (sec:%0.4f)\\n\", meta->rx_timestamp,\n\t       (double)meta->rx_timestamp / NANOSEC_PER_SEC);\n\tif (meta->rx_timestamp) {\n\t\t__u64 usr_clock = gettime(clock_id);\n\t\t__u64 xdp_clock = meta->xdp_timestamp;\n\t\t__s64 delta_X = xdp_clock - meta->rx_timestamp;\n\t\t__s64 delta_X2U = usr_clock - xdp_clock;\n\n\t\tprintf(\"XDP RX-time:   %llu (sec:%0.4f) delta sec:%0.4f (%0.3f usec)\\n\",\n\t\t       xdp_clock, (double)xdp_clock / NANOSEC_PER_SEC,\n\t\t       (double)delta_X / NANOSEC_PER_SEC,\n\t\t       (double)delta_X / 1000);\n\n\t\tprintf(\"AF_XDP time:   %llu (sec:%0.4f) delta sec:%0.4f (%0.3f usec)\\n\",\n\t\t       usr_clock, (double)usr_clock / NANOSEC_PER_SEC,\n\t\t       (double)delta_X2U / NANOSEC_PER_SEC,\n\t\t       (double)delta_X2U / 1000);\n\t}\n\n}\n\nstatic void verify_skb_metadata(int fd)\n{\n\tchar cmsg_buf[1024];\n\tchar packet_buf[128];\n\n\tstruct scm_timestamping *ts;\n\tstruct iovec packet_iov;\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr hdr;\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.msg_iov = &packet_iov;\n\thdr.msg_iovlen = 1;\n\tpacket_iov.iov_base = packet_buf;\n\tpacket_iov.iov_len = sizeof(packet_buf);\n\n\thdr.msg_control = cmsg_buf;\n\thdr.msg_controllen = sizeof(cmsg_buf);\n\n\tif (recvmsg(fd, &hdr, 0) < 0)\n\t\terror(1, errno, \"recvmsg\");\n\n\tfor (cmsg = CMSG_FIRSTHDR(&hdr); cmsg != NULL;\n\t     cmsg = CMSG_NXTHDR(&hdr, cmsg)) {\n\n\t\tif (cmsg->cmsg_level != SOL_SOCKET)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase SCM_TIMESTAMPING:\n\t\t\tts = (struct scm_timestamping *)CMSG_DATA(cmsg);\n\t\t\tif (ts->ts[2].tv_sec || ts->ts[2].tv_nsec) {\n\t\t\t\tprintf(\"found skb hwtstamp = %lu.%lu\\n\",\n\t\t\t\t       ts->ts[2].tv_sec, ts->ts[2].tv_nsec);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"skb hwtstamp is not found!\\n\");\n}\n\nstatic int verify_metadata(struct xsk *rx_xsk, int rxq, int server_fd, clockid_t clock_id)\n{\n\tconst struct xdp_desc *rx_desc;\n\tstruct pollfd fds[rxq + 1];\n\t__u64 comp_addr;\n\t__u64 addr;\n\t__u32 idx;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < rxq; i++) {\n\t\tfds[i].fd = xsk_socket__fd(rx_xsk[i].socket);\n\t\tfds[i].events = POLLIN;\n\t\tfds[i].revents = 0;\n\t}\n\n\tfds[rxq].fd = server_fd;\n\tfds[rxq].events = POLLIN;\n\tfds[rxq].revents = 0;\n\n\twhile (true) {\n\t\terrno = 0;\n\t\tret = poll(fds, rxq + 1, 1000);\n\t\tprintf(\"poll: %d (%d) skip=%llu fail=%llu redir=%llu\\n\",\n\t\t       ret, errno, bpf_obj->bss->pkts_skip,\n\t\t       bpf_obj->bss->pkts_fail, bpf_obj->bss->pkts_redir);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret == 0)\n\t\t\tcontinue;\n\n\t\tif (fds[rxq].revents)\n\t\t\tverify_skb_metadata(server_fd);\n\n\t\tfor (i = 0; i < rxq; i++) {\n\t\t\tif (fds[i].revents == 0)\n\t\t\t\tcontinue;\n\n\t\t\tstruct xsk *xsk = &rx_xsk[i];\n\n\t\t\tret = xsk_ring_cons__peek(&xsk->rx, 1, &idx);\n\t\t\tprintf(\"xsk_ring_cons__peek: %d\\n\", ret);\n\t\t\tif (ret != 1)\n\t\t\t\tcontinue;\n\n\t\t\trx_desc = xsk_ring_cons__rx_desc(&xsk->rx, idx);\n\t\t\tcomp_addr = xsk_umem__extract_addr(rx_desc->addr);\n\t\t\taddr = xsk_umem__add_offset_to_addr(rx_desc->addr);\n\t\t\tprintf(\"%p: rx_desc[%u]->addr=%llx addr=%llx comp_addr=%llx\\n\",\n\t\t\t       xsk, idx, rx_desc->addr, addr, comp_addr);\n\t\t\tverify_xdp_metadata(xsk_umem__get_data(xsk->umem_area, addr),\n\t\t\t\t\t    clock_id);\n\t\t\txsk_ring_cons__release(&xsk->rx, 1);\n\t\t\trefill_rx(xsk, comp_addr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct ethtool_channels {\n\t__u32\tcmd;\n\t__u32\tmax_rx;\n\t__u32\tmax_tx;\n\t__u32\tmax_other;\n\t__u32\tmax_combined;\n\t__u32\trx_count;\n\t__u32\ttx_count;\n\t__u32\tother_count;\n\t__u32\tcombined_count;\n};\n\n#define ETHTOOL_GCHANNELS\t0x0000003c  \n\nstatic int rxq_num(const char *ifname)\n{\n\tstruct ethtool_channels ch = {\n\t\t.cmd = ETHTOOL_GCHANNELS,\n\t};\n\n\tstruct ifreq ifr = {\n\t\t.ifr_data = (void *)&ch,\n\t};\n\tstrncpy(ifr.ifr_name, ifname, IF_NAMESIZE - 1);\n\tint fd, ret;\n\n\tfd = socket(AF_UNIX, SOCK_DGRAM, 0);\n\tif (fd < 0)\n\t\terror(1, errno, \"socket\");\n\n\tret = ioctl(fd, SIOCETHTOOL, &ifr);\n\tif (ret < 0)\n\t\terror(1, errno, \"ioctl(SIOCETHTOOL)\");\n\n\tclose(fd);\n\n\treturn ch.rx_count + ch.combined_count;\n}\n\nstatic void hwtstamp_ioctl(int op, const char *ifname, struct hwtstamp_config *cfg)\n{\n\tstruct ifreq ifr = {\n\t\t.ifr_data = (void *)cfg,\n\t};\n\tstrncpy(ifr.ifr_name, ifname, IF_NAMESIZE - 1);\n\tint fd, ret;\n\n\tfd = socket(AF_UNIX, SOCK_DGRAM, 0);\n\tif (fd < 0)\n\t\terror(1, errno, \"socket\");\n\n\tret = ioctl(fd, op, &ifr);\n\tif (ret < 0)\n\t\terror(1, errno, \"ioctl(%d)\", op);\n\n\tclose(fd);\n}\n\nstatic struct hwtstamp_config saved_hwtstamp_cfg;\nstatic const char *saved_hwtstamp_ifname;\n\nstatic void hwtstamp_restore(void)\n{\n\thwtstamp_ioctl(SIOCSHWTSTAMP, saved_hwtstamp_ifname, &saved_hwtstamp_cfg);\n}\n\nstatic void hwtstamp_enable(const char *ifname)\n{\n\tstruct hwtstamp_config cfg = {\n\t\t.rx_filter = HWTSTAMP_FILTER_ALL,\n\t};\n\n\thwtstamp_ioctl(SIOCGHWTSTAMP, ifname, &saved_hwtstamp_cfg);\n\tsaved_hwtstamp_ifname = strdup(ifname);\n\tatexit(hwtstamp_restore);\n\n\thwtstamp_ioctl(SIOCSHWTSTAMP, ifname, &cfg);\n}\n\nstatic void cleanup(void)\n{\n\tLIBBPF_OPTS(bpf_xdp_attach_opts, opts);\n\tint ret;\n\tint i;\n\n\tif (bpf_obj) {\n\t\topts.old_prog_fd = bpf_program__fd(bpf_obj->progs.rx);\n\t\tif (opts.old_prog_fd >= 0) {\n\t\t\tprintf(\"detaching bpf program....\\n\");\n\t\t\tret = bpf_xdp_detach(ifindex, XDP_FLAGS, &opts);\n\t\t\tif (ret)\n\t\t\t\tprintf(\"failed to detach XDP program: %d\\n\", ret);\n\t\t}\n\t}\n\n\tfor (i = 0; i < rxq; i++)\n\t\tclose_xsk(&rx_xsk[i]);\n\n\tif (bpf_obj)\n\t\txdp_hw_metadata__destroy(bpf_obj);\n}\n\nstatic void handle_signal(int sig)\n{\n\t \n}\n\nstatic void timestamping_enable(int fd, int val)\n{\n\tint ret;\n\n\tret = setsockopt(fd, SOL_SOCKET, SO_TIMESTAMPING, &val, sizeof(val));\n\tif (ret < 0)\n\t\terror(1, errno, \"setsockopt(SO_TIMESTAMPING)\");\n}\n\nint main(int argc, char *argv[])\n{\n\tclockid_t clock_id = CLOCK_TAI;\n\tint server_fd = -1;\n\tint ret;\n\tint i;\n\n\tstruct bpf_program *prog;\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"pass device name\\n\");\n\t\treturn -1;\n\t}\n\n\tifname = argv[1];\n\tifindex = if_nametoindex(ifname);\n\trxq = rxq_num(ifname);\n\n\tprintf(\"rxq: %d\\n\", rxq);\n\n\thwtstamp_enable(ifname);\n\n\trx_xsk = malloc(sizeof(struct xsk) * rxq);\n\tif (!rx_xsk)\n\t\terror(1, ENOMEM, \"malloc\");\n\n\tfor (i = 0; i < rxq; i++) {\n\t\tprintf(\"open_xsk(%s, %p, %d)\\n\", ifname, &rx_xsk[i], i);\n\t\tret = open_xsk(ifindex, &rx_xsk[i], i);\n\t\tif (ret)\n\t\t\terror(1, -ret, \"open_xsk\");\n\n\t\tprintf(\"xsk_socket__fd() -> %d\\n\", xsk_socket__fd(rx_xsk[i].socket));\n\t}\n\n\tprintf(\"open bpf program...\\n\");\n\tbpf_obj = xdp_hw_metadata__open();\n\tif (libbpf_get_error(bpf_obj))\n\t\terror(1, libbpf_get_error(bpf_obj), \"xdp_hw_metadata__open\");\n\n\tprog = bpf_object__find_program_by_name(bpf_obj->obj, \"rx\");\n\tbpf_program__set_ifindex(prog, ifindex);\n\tbpf_program__set_flags(prog, BPF_F_XDP_DEV_BOUND_ONLY);\n\n\tprintf(\"load bpf program...\\n\");\n\tret = xdp_hw_metadata__load(bpf_obj);\n\tif (ret)\n\t\terror(1, -ret, \"xdp_hw_metadata__load\");\n\n\tprintf(\"prepare skb endpoint...\\n\");\n\tserver_fd = start_server(AF_INET6, SOCK_DGRAM, NULL, 9092, 1000);\n\tif (server_fd < 0)\n\t\terror(1, errno, \"start_server\");\n\ttimestamping_enable(server_fd,\n\t\t\t    SOF_TIMESTAMPING_SOFTWARE |\n\t\t\t    SOF_TIMESTAMPING_RAW_HARDWARE);\n\n\tprintf(\"prepare xsk map...\\n\");\n\tfor (i = 0; i < rxq; i++) {\n\t\tint sock_fd = xsk_socket__fd(rx_xsk[i].socket);\n\t\t__u32 queue_id = i;\n\n\t\tprintf(\"map[%d] = %d\\n\", queue_id, sock_fd);\n\t\tret = bpf_map_update_elem(bpf_map__fd(bpf_obj->maps.xsk), &queue_id, &sock_fd, 0);\n\t\tif (ret)\n\t\t\terror(1, -ret, \"bpf_map_update_elem\");\n\t}\n\n\tprintf(\"attach bpf program...\\n\");\n\tret = bpf_xdp_attach(ifindex,\n\t\t\t     bpf_program__fd(bpf_obj->progs.rx),\n\t\t\t     XDP_FLAGS, NULL);\n\tif (ret)\n\t\terror(1, -ret, \"bpf_xdp_attach\");\n\n\tsignal(SIGINT, handle_signal);\n\tret = verify_metadata(rx_xsk, rxq, server_fd, clock_id);\n\tclose(server_fd);\n\tcleanup();\n\tif (ret)\n\t\terror(1, -ret, \"verify_metadata\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}