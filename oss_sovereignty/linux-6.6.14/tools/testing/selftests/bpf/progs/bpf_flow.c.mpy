{
  "module_name": "bpf_flow.c",
  "hash_id": "0391b39d6b5a152daa064bc93484a17d126826cf3039e599865cbab6bbc76fa0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/bpf_flow.c",
  "human_readable_source": "\n#include <limits.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <linux/pkt_cls.h>\n#include <linux/bpf.h>\n#include <linux/in.h>\n#include <linux/if_ether.h>\n#include <linux/icmp.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_packet.h>\n#include <sys/socket.h>\n#include <linux/if_tunnel.h>\n#include <linux/mpls.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#define PROG(F) PROG_(F, _##F)\n#define PROG_(NUM, NAME) SEC(\"flow_dissector\") int flow_dissector_##NUM\n\n#define FLOW_CONTINUE_SADDR 0x7f00007f  \n\n \n#define IP\t\t0\n#define IPV6\t\t1\n#define IPV6OP\t\t2  \n#define IPV6FR\t\t3  \n#define MPLS\t\t4\n#define VLAN\t\t5\n#define MAX_PROG\t6\n\n#define IP_MF\t\t0x2000\n#define IP_OFFSET\t0x1FFF\n#define IP6_MF\t\t0x0001\n#define IP6_OFFSET\t0xFFF8\n\nstruct vlan_hdr {\n\t__be16 h_vlan_TCI;\n\t__be16 h_vlan_encapsulated_proto;\n};\n\nstruct gre_hdr {\n\t__be16 flags;\n\t__be16 proto;\n};\n\nstruct frag_hdr {\n\t__u8 nexthdr;\n\t__u8 reserved;\n\t__be16 frag_off;\n\t__be32 identification;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__uint(max_entries, MAX_PROG);\n\t__uint(key_size, sizeof(__u32));\n\t__uint(value_size, sizeof(__u32));\n} jmp_table SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1024);\n\t__type(key, __u32);\n\t__type(value, struct bpf_flow_keys);\n} last_dissection SEC(\".maps\");\n\nstatic __always_inline int export_flow_keys(struct bpf_flow_keys *keys,\n\t\t\t\t\t    int ret)\n{\n\t__u32 key = (__u32)(keys->sport) << 16 | keys->dport;\n\tstruct bpf_flow_keys val;\n\n\tmemcpy(&val, keys, sizeof(val));\n\tbpf_map_update_elem(&last_dissection, &key, &val, BPF_ANY);\n\treturn ret;\n}\n\n#define IPV6_FLOWLABEL_MASK\t\t__bpf_constant_htonl(0x000FFFFF)\nstatic inline __be32 ip6_flowlabel(const struct ipv6hdr *hdr)\n{\n\treturn *(__be32 *)hdr & IPV6_FLOWLABEL_MASK;\n}\n\nstatic __always_inline void *bpf_flow_dissect_get_header(struct __sk_buff *skb,\n\t\t\t\t\t\t\t __u16 hdr_size,\n\t\t\t\t\t\t\t void *buffer)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tvoid *data = (void *)(long)skb->data;\n\t__u16 thoff = skb->flow_keys->thoff;\n\t__u8 *hdr;\n\n\t \n\tif (thoff > (USHRT_MAX - hdr_size))\n\t\treturn NULL;\n\n\thdr = data + thoff;\n\tif (hdr + hdr_size <= data_end)\n\t\treturn hdr;\n\n\tif (bpf_skb_load_bytes(skb, thoff, buffer, hdr_size))\n\t\treturn NULL;\n\n\treturn buffer;\n}\n\n \nstatic __always_inline int parse_eth_proto(struct __sk_buff *skb, __be16 proto)\n{\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\n\tswitch (proto) {\n\tcase bpf_htons(ETH_P_IP):\n\t\tbpf_tail_call_static(skb, &jmp_table, IP);\n\t\tbreak;\n\tcase bpf_htons(ETH_P_IPV6):\n\t\tbpf_tail_call_static(skb, &jmp_table, IPV6);\n\t\tbreak;\n\tcase bpf_htons(ETH_P_MPLS_MC):\n\tcase bpf_htons(ETH_P_MPLS_UC):\n\t\tbpf_tail_call_static(skb, &jmp_table, MPLS);\n\t\tbreak;\n\tcase bpf_htons(ETH_P_8021Q):\n\tcase bpf_htons(ETH_P_8021AD):\n\t\tbpf_tail_call_static(skb, &jmp_table, VLAN);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn export_flow_keys(keys, BPF_DROP);\n\t}\n\n\treturn export_flow_keys(keys, BPF_DROP);\n}\n\nSEC(\"flow_dissector\")\nint _dissect(struct __sk_buff *skb)\n{\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\n\tif (keys->n_proto == bpf_htons(ETH_P_IP)) {\n\t\t \n\t\tstruct iphdr *iph, _iph;\n\n\t\tiph = bpf_flow_dissect_get_header(skb, sizeof(*iph), &_iph);\n\t\tif (iph && iph->ihl == 5 &&\n\t\t    iph->saddr == bpf_htonl(FLOW_CONTINUE_SADDR)) {\n\t\t\treturn BPF_FLOW_DISSECTOR_CONTINUE;\n\t\t}\n\t}\n\n\treturn parse_eth_proto(skb, keys->n_proto);\n}\n\n \nstatic __always_inline int parse_ip_proto(struct __sk_buff *skb, __u8 proto)\n{\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tstruct icmphdr *icmp, _icmp;\n\tstruct gre_hdr *gre, _gre;\n\tstruct ethhdr *eth, _eth;\n\tstruct tcphdr *tcp, _tcp;\n\tstruct udphdr *udp, _udp;\n\n\tswitch (proto) {\n\tcase IPPROTO_ICMP:\n\t\ticmp = bpf_flow_dissect_get_header(skb, sizeof(*icmp), &_icmp);\n\t\tif (!icmp)\n\t\t\treturn export_flow_keys(keys, BPF_DROP);\n\t\treturn export_flow_keys(keys, BPF_OK);\n\tcase IPPROTO_IPIP:\n\t\tkeys->is_encap = true;\n\t\tif (keys->flags & BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP)\n\t\t\treturn export_flow_keys(keys, BPF_OK);\n\n\t\treturn parse_eth_proto(skb, bpf_htons(ETH_P_IP));\n\tcase IPPROTO_IPV6:\n\t\tkeys->is_encap = true;\n\t\tif (keys->flags & BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP)\n\t\t\treturn export_flow_keys(keys, BPF_OK);\n\n\t\treturn parse_eth_proto(skb, bpf_htons(ETH_P_IPV6));\n\tcase IPPROTO_GRE:\n\t\tgre = bpf_flow_dissect_get_header(skb, sizeof(*gre), &_gre);\n\t\tif (!gre)\n\t\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t\tif (bpf_htons(gre->flags & GRE_VERSION))\n\t\t\t \n\t\t\treturn export_flow_keys(keys, BPF_OK);\n\n\t\tkeys->thoff += sizeof(*gre);  \n\t\tif (GRE_IS_CSUM(gre->flags))\n\t\t\tkeys->thoff += 4;  \n\t\tif (GRE_IS_KEY(gre->flags))\n\t\t\tkeys->thoff += 4;  \n\t\tif (GRE_IS_SEQ(gre->flags))\n\t\t\tkeys->thoff += 4;  \n\n\t\tkeys->is_encap = true;\n\t\tif (keys->flags & BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP)\n\t\t\treturn export_flow_keys(keys, BPF_OK);\n\n\t\tif (gre->proto == bpf_htons(ETH_P_TEB)) {\n\t\t\teth = bpf_flow_dissect_get_header(skb, sizeof(*eth),\n\t\t\t\t\t\t\t  &_eth);\n\t\t\tif (!eth)\n\t\t\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t\t\tkeys->thoff += sizeof(*eth);\n\n\t\t\treturn parse_eth_proto(skb, eth->h_proto);\n\t\t} else {\n\t\t\treturn parse_eth_proto(skb, gre->proto);\n\t\t}\n\tcase IPPROTO_TCP:\n\t\ttcp = bpf_flow_dissect_get_header(skb, sizeof(*tcp), &_tcp);\n\t\tif (!tcp)\n\t\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t\tif (tcp->doff < 5)\n\t\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t\tif ((__u8 *)tcp + (tcp->doff << 2) > data_end)\n\t\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t\tkeys->sport = tcp->source;\n\t\tkeys->dport = tcp->dest;\n\t\treturn export_flow_keys(keys, BPF_OK);\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\t\tudp = bpf_flow_dissect_get_header(skb, sizeof(*udp), &_udp);\n\t\tif (!udp)\n\t\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t\tkeys->sport = udp->source;\n\t\tkeys->dport = udp->dest;\n\t\treturn export_flow_keys(keys, BPF_OK);\n\tdefault:\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\t}\n\n\treturn export_flow_keys(keys, BPF_DROP);\n}\n\nstatic __always_inline int parse_ipv6_proto(struct __sk_buff *skb, __u8 nexthdr)\n{\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\n\tswitch (nexthdr) {\n\tcase IPPROTO_HOPOPTS:\n\tcase IPPROTO_DSTOPTS:\n\t\tbpf_tail_call_static(skb, &jmp_table, IPV6OP);\n\t\tbreak;\n\tcase IPPROTO_FRAGMENT:\n\t\tbpf_tail_call_static(skb, &jmp_table, IPV6FR);\n\t\tbreak;\n\tdefault:\n\t\treturn parse_ip_proto(skb, nexthdr);\n\t}\n\n\treturn export_flow_keys(keys, BPF_DROP);\n}\n\nPROG(IP)(struct __sk_buff *skb)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\tvoid *data = (void *)(long)skb->data;\n\tstruct iphdr *iph, _iph;\n\tbool done = false;\n\n\tiph = bpf_flow_dissect_get_header(skb, sizeof(*iph), &_iph);\n\tif (!iph)\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t \n\tif (iph->ihl < 5)\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\tkeys->addr_proto = ETH_P_IP;\n\tkeys->ipv4_src = iph->saddr;\n\tkeys->ipv4_dst = iph->daddr;\n\tkeys->ip_proto = iph->protocol;\n\n\tkeys->thoff += iph->ihl << 2;\n\tif (data + keys->thoff > data_end)\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\tif (iph->frag_off & bpf_htons(IP_MF | IP_OFFSET)) {\n\t\tkeys->is_frag = true;\n\t\tif (iph->frag_off & bpf_htons(IP_OFFSET)) {\n\t\t\t \n\t\t\tdone = true;\n\t\t} else {\n\t\t\tkeys->is_first_frag = true;\n\t\t\t \n\t\t\tif (!(keys->flags &\n\t\t\t      BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG))\n\t\t\t\tdone = true;\n\t\t}\n\t}\n\n\tif (done)\n\t\treturn export_flow_keys(keys, BPF_OK);\n\n\treturn parse_ip_proto(skb, iph->protocol);\n}\n\nPROG(IPV6)(struct __sk_buff *skb)\n{\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\tstruct ipv6hdr *ip6h, _ip6h;\n\n\tip6h = bpf_flow_dissect_get_header(skb, sizeof(*ip6h), &_ip6h);\n\tif (!ip6h)\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\tkeys->addr_proto = ETH_P_IPV6;\n\tmemcpy(&keys->ipv6_src, &ip6h->saddr, 2*sizeof(ip6h->saddr));\n\n\tkeys->thoff += sizeof(struct ipv6hdr);\n\tkeys->ip_proto = ip6h->nexthdr;\n\tkeys->flow_label = ip6_flowlabel(ip6h);\n\n\tif (keys->flow_label && keys->flags & BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL)\n\t\treturn export_flow_keys(keys, BPF_OK);\n\n\treturn parse_ipv6_proto(skb, ip6h->nexthdr);\n}\n\nPROG(IPV6OP)(struct __sk_buff *skb)\n{\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\tstruct ipv6_opt_hdr *ip6h, _ip6h;\n\n\tip6h = bpf_flow_dissect_get_header(skb, sizeof(*ip6h), &_ip6h);\n\tif (!ip6h)\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t \n\tkeys->thoff += (1 + ip6h->hdrlen) << 3;\n\tkeys->ip_proto = ip6h->nexthdr;\n\n\treturn parse_ipv6_proto(skb, ip6h->nexthdr);\n}\n\nPROG(IPV6FR)(struct __sk_buff *skb)\n{\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\tstruct frag_hdr *fragh, _fragh;\n\n\tfragh = bpf_flow_dissect_get_header(skb, sizeof(*fragh), &_fragh);\n\tif (!fragh)\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\tkeys->thoff += sizeof(*fragh);\n\tkeys->is_frag = true;\n\tkeys->ip_proto = fragh->nexthdr;\n\n\tif (!(fragh->frag_off & bpf_htons(IP6_OFFSET))) {\n\t\tkeys->is_first_frag = true;\n\n\t\t \n\t\tif (!(keys->flags & BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG))\n\t\t\treturn export_flow_keys(keys, BPF_OK);\n\t} else {\n\t\treturn export_flow_keys(keys, BPF_OK);\n\t}\n\n\treturn parse_ipv6_proto(skb, fragh->nexthdr);\n}\n\nPROG(MPLS)(struct __sk_buff *skb)\n{\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\tstruct mpls_label *mpls, _mpls;\n\n\tmpls = bpf_flow_dissect_get_header(skb, sizeof(*mpls), &_mpls);\n\tif (!mpls)\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\treturn export_flow_keys(keys, BPF_OK);\n}\n\nPROG(VLAN)(struct __sk_buff *skb)\n{\n\tstruct bpf_flow_keys *keys = skb->flow_keys;\n\tstruct vlan_hdr *vlan, _vlan;\n\n\t \n\tif (keys->n_proto == bpf_htons(ETH_P_8021AD)) {\n\t\tvlan = bpf_flow_dissect_get_header(skb, sizeof(*vlan), &_vlan);\n\t\tif (!vlan)\n\t\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t\tif (vlan->h_vlan_encapsulated_proto != bpf_htons(ETH_P_8021Q))\n\t\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\t\tkeys->nhoff += sizeof(*vlan);\n\t\tkeys->thoff += sizeof(*vlan);\n\t}\n\n\tvlan = bpf_flow_dissect_get_header(skb, sizeof(*vlan), &_vlan);\n\tif (!vlan)\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\tkeys->nhoff += sizeof(*vlan);\n\tkeys->thoff += sizeof(*vlan);\n\t \n\tif (vlan->h_vlan_encapsulated_proto == bpf_htons(ETH_P_8021AD) ||\n\t    vlan->h_vlan_encapsulated_proto == bpf_htons(ETH_P_8021Q))\n\t\treturn export_flow_keys(keys, BPF_DROP);\n\n\tkeys->n_proto = vlan->h_vlan_encapsulated_proto;\n\treturn parse_eth_proto(skb, vlan->h_vlan_encapsulated_proto);\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}