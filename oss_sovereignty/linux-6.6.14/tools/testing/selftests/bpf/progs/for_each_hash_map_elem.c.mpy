{
  "module_name": "for_each_hash_map_elem.c",
  "hash_id": "b102baf28a2f1ef190af003f1dc2c4ac74fcc5e08dc5bb4d3907a94d893e1154",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/for_each_hash_map_elem.c",
  "human_readable_source": "\n \n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 3);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} hashmap SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} percpu_map SEC(\".maps\");\n\nstruct callback_ctx {\n\tstruct __sk_buff *ctx;\n\tint input;\n\tint output;\n};\n\nstatic __u64\ncheck_hash_elem(struct bpf_map *map, __u32 *key, __u64 *val,\n\t\tstruct callback_ctx *data)\n{\n\tstruct __sk_buff *skb = data->ctx;\n\t__u32 k;\n\t__u64 v;\n\n\tif (skb) {\n\t\tk = *key;\n\t\tv = *val;\n\t\tif (skb->len == 10000 && k == 10 && v == 10)\n\t\t\tdata->output = 3;  \n\t\telse\n\t\t\tdata->output = 4;\n\t} else {\n\t\tdata->output = data->input;\n\t\tbpf_map_delete_elem(map, key);\n\t}\n\n\treturn 0;\n}\n\n__u32 cpu = 0;\n__u32 percpu_called = 0;\n__u32 percpu_key = 0;\n__u64 percpu_val = 0;\nint percpu_output = 0;\n\nstatic __u64\ncheck_percpu_elem(struct bpf_map *map, __u32 *key, __u64 *val,\n\t\t  struct callback_ctx *unused)\n{\n\tstruct callback_ctx data;\n\n\tpercpu_called++;\n\tcpu = bpf_get_smp_processor_id();\n\tpercpu_key = *key;\n\tpercpu_val = *val;\n\n\tdata.ctx = 0;\n\tdata.input = 100;\n\tdata.output = 0;\n\tbpf_for_each_map_elem(&hashmap, check_hash_elem, &data, 0);\n\tpercpu_output = data.output;\n\n\treturn 0;\n}\n\nint hashmap_output = 0;\nint hashmap_elems = 0;\nint percpu_map_elems = 0;\n\nSEC(\"tc\")\nint test_pkt_access(struct __sk_buff *skb)\n{\n\tstruct callback_ctx data;\n\n\tdata.ctx = skb;\n\tdata.input = 10;\n\tdata.output = 0;\n\thashmap_elems = bpf_for_each_map_elem(&hashmap, check_hash_elem, &data, 0);\n\thashmap_output = data.output;\n\n\tpercpu_map_elems = bpf_for_each_map_elem(&percpu_map, check_percpu_elem,\n\t\t\t\t\t\t (void *)0, 0);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}