{
  "module_name": "test_xdp.c",
  "hash_id": "eb28315ba178d6a90e48b4e4470e654fe79aad690336f7e59966dfcc3c79c58b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_xdp.c",
  "human_readable_source": " \n#include <stddef.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/in.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/pkt_cls.h>\n#include <sys/socket.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"test_iptunnel_common.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(max_entries, 256);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} rxcnt SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, MAX_IPTNL_ENTRIES);\n\t__type(key, struct vip);\n\t__type(value, struct iptnl_info);\n} vip2tnl SEC(\".maps\");\n\nstatic __always_inline void count_tx(__u32 protocol)\n{\n\t__u64 *rxcnt_count;\n\n\trxcnt_count = bpf_map_lookup_elem(&rxcnt, &protocol);\n\tif (rxcnt_count)\n\t\t*rxcnt_count += 1;\n}\n\nstatic __always_inline int get_dport(void *trans_data, void *data_end,\n\t\t\t\t     __u8 protocol)\n{\n\tstruct tcphdr *th;\n\tstruct udphdr *uh;\n\n\tswitch (protocol) {\n\tcase IPPROTO_TCP:\n\t\tth = (struct tcphdr *)trans_data;\n\t\tif (th + 1 > data_end)\n\t\t\treturn -1;\n\t\treturn th->dest;\n\tcase IPPROTO_UDP:\n\t\tuh = (struct udphdr *)trans_data;\n\t\tif (uh + 1 > data_end)\n\t\t\treturn -1;\n\t\treturn uh->dest;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic __always_inline void set_ethhdr(struct ethhdr *new_eth,\n\t\t\t\t       const struct ethhdr *old_eth,\n\t\t\t\t       const struct iptnl_info *tnl,\n\t\t\t\t       __be16 h_proto)\n{\n\tmemcpy(new_eth->h_source, old_eth->h_dest, sizeof(new_eth->h_source));\n\tmemcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));\n\tnew_eth->h_proto = h_proto;\n}\n\nstatic __always_inline int handle_ipv4(struct xdp_md *xdp)\n{\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\tvoid *data = (void *)(long)xdp->data;\n\tstruct iptnl_info *tnl;\n\tstruct ethhdr *new_eth;\n\tstruct ethhdr *old_eth;\n\tstruct iphdr *iph = data + sizeof(struct ethhdr);\n\t__u16 *next_iph;\n\t__u16 payload_len;\n\tstruct vip vip = {};\n\tint dport;\n\t__u32 csum = 0;\n\tint i;\n\n\tif (iph + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\tdport = get_dport(iph + 1, data_end, iph->protocol);\n\tif (dport == -1)\n\t\treturn XDP_DROP;\n\n\tvip.protocol = iph->protocol;\n\tvip.family = AF_INET;\n\tvip.daddr.v4 = iph->daddr;\n\tvip.dport = dport;\n\tpayload_len = bpf_ntohs(iph->tot_len);\n\n\ttnl = bpf_map_lookup_elem(&vip2tnl, &vip);\n\t \n\tif (!tnl || tnl->family != AF_INET)\n\t\treturn XDP_PASS;\n\n\tif (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct iphdr)))\n\t\treturn XDP_DROP;\n\n\tdata = (void *)(long)xdp->data;\n\tdata_end = (void *)(long)xdp->data_end;\n\n\tnew_eth = data;\n\tiph = data + sizeof(*new_eth);\n\told_eth = data + sizeof(*iph);\n\n\tif (new_eth + 1 > data_end ||\n\t    old_eth + 1 > data_end ||\n\t    iph + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\tset_ethhdr(new_eth, old_eth, tnl, bpf_htons(ETH_P_IP));\n\n\tiph->version = 4;\n\tiph->ihl = sizeof(*iph) >> 2;\n\tiph->frag_off =\t0;\n\tiph->protocol = IPPROTO_IPIP;\n\tiph->check = 0;\n\tiph->tos = 0;\n\tiph->tot_len = bpf_htons(payload_len + sizeof(*iph));\n\tiph->daddr = tnl->daddr.v4;\n\tiph->saddr = tnl->saddr.v4;\n\tiph->ttl = 8;\n\n\tnext_iph = (__u16 *)iph;\n#pragma clang loop unroll(full)\n\tfor (i = 0; i < sizeof(*iph) >> 1; i++)\n\t\tcsum += *next_iph++;\n\n\tiph->check = ~((csum & 0xffff) + (csum >> 16));\n\n\tcount_tx(vip.protocol);\n\n\treturn XDP_TX;\n}\n\nstatic __always_inline int handle_ipv6(struct xdp_md *xdp)\n{\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\tvoid *data = (void *)(long)xdp->data;\n\tstruct iptnl_info *tnl;\n\tstruct ethhdr *new_eth;\n\tstruct ethhdr *old_eth;\n\tstruct ipv6hdr *ip6h = data + sizeof(struct ethhdr);\n\t__u16 payload_len;\n\tstruct vip vip = {};\n\tint dport;\n\n\tif (ip6h + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\tdport = get_dport(ip6h + 1, data_end, ip6h->nexthdr);\n\tif (dport == -1)\n\t\treturn XDP_DROP;\n\n\tvip.protocol = ip6h->nexthdr;\n\tvip.family = AF_INET6;\n\tmemcpy(vip.daddr.v6, ip6h->daddr.s6_addr32, sizeof(vip.daddr));\n\tvip.dport = dport;\n\tpayload_len = ip6h->payload_len;\n\n\ttnl = bpf_map_lookup_elem(&vip2tnl, &vip);\n\t \n\tif (!tnl || tnl->family != AF_INET6)\n\t\treturn XDP_PASS;\n\n\tif (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct ipv6hdr)))\n\t\treturn XDP_DROP;\n\n\tdata = (void *)(long)xdp->data;\n\tdata_end = (void *)(long)xdp->data_end;\n\n\tnew_eth = data;\n\tip6h = data + sizeof(*new_eth);\n\told_eth = data + sizeof(*ip6h);\n\n\tif (new_eth + 1 > data_end || old_eth + 1 > data_end ||\n\t    ip6h + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\tset_ethhdr(new_eth, old_eth, tnl, bpf_htons(ETH_P_IPV6));\n\n\tip6h->version = 6;\n\tip6h->priority = 0;\n\tmemset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));\n\tip6h->payload_len = bpf_htons(bpf_ntohs(payload_len) + sizeof(*ip6h));\n\tip6h->nexthdr = IPPROTO_IPV6;\n\tip6h->hop_limit = 8;\n\tmemcpy(ip6h->saddr.s6_addr32, tnl->saddr.v6, sizeof(tnl->saddr.v6));\n\tmemcpy(ip6h->daddr.s6_addr32, tnl->daddr.v6, sizeof(tnl->daddr.v6));\n\n\tcount_tx(vip.protocol);\n\n\treturn XDP_TX;\n}\n\nSEC(\"xdp\")\nint _xdp_tx_iptunnel(struct xdp_md *xdp)\n{\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\tvoid *data = (void *)(long)xdp->data;\n\tstruct ethhdr *eth = data;\n\t__u16 h_proto;\n\n\tif (eth + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\th_proto = eth->h_proto;\n\n\tif (h_proto == bpf_htons(ETH_P_IP))\n\t\treturn handle_ipv4(xdp);\n\telse if (h_proto == bpf_htons(ETH_P_IPV6))\n\n\t\treturn handle_ipv6(xdp);\n\telse\n\t\treturn XDP_DROP;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}