{
  "module_name": "test_tcpbpf_kern.c",
  "hash_id": "52282dd4a16895ba30f33eb38e122f77a913ece7e2eb7e0a259058c1bf2a8d82",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tcpbpf_kern.c",
  "human_readable_source": "\n#include <stddef.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/tcp.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"bpf_tcp_helpers.h\"\n#include \"test_tcpbpf.h\"\n\nstruct tcpbpf_globals global = {};\n\n \n#ifndef SOL_TCP\n#define SOL_TCP 6\n#endif\n\nstatic __always_inline int get_tp_window_clamp(struct bpf_sock_ops *skops)\n{\n\tstruct bpf_sock *sk;\n\tstruct tcp_sock *tp;\n\n\tsk = skops->sk;\n\tif (!sk)\n\t\treturn -1;\n\ttp = bpf_skc_to_tcp_sock(sk);\n\tif (!tp)\n\t\treturn -1;\n\treturn tp->window_clamp;\n}\n\nSEC(\"sockops\")\nint bpf_testcb(struct bpf_sock_ops *skops)\n{\n\tchar header[sizeof(struct ipv6hdr) + sizeof(struct tcphdr)];\n\tstruct bpf_sock_ops *reuse = skops;\n\tstruct tcphdr *thdr;\n\tint window_clamp = 9216;\n\tint save_syn = 1;\n\tint rv = -1;\n\tint v = 0;\n\tint op;\n\n\t \n\tasm volatile (\n\t\t\"%[reuse] = *(u32 *)(%[reuse] +96)\"\n\t\t: [reuse] \"+r\"(reuse)\n\t\t:);\n\n\tasm volatile (\n\t\t\"%[op] = *(u32 *)(%[skops] +96)\"\n\t\t: [op] \"+r\"(op)\n\t\t: [skops] \"r\"(skops)\n\t\t:);\n\n\tasm volatile (\n\t\t\"r9 = %[skops];\\n\"\n\t\t\"r8 = *(u32 *)(r9 +164);\\n\"\n\t\t\"*(u32 *)(r9 +164) = r8;\\n\"\n\t\t:: [skops] \"r\"(skops)\n\t\t: \"r9\", \"r8\");\n\n\tasm volatile (\n\t\t\"r1 = %[skops];\\n\"\n\t\t\"r1 = *(u64 *)(r1 +184);\\n\"\n\t\t\"if r1 == 0 goto +1;\\n\"\n\t\t\"r1 = *(u32 *)(r1 +4);\\n\"\n\t\t:: [skops] \"r\"(skops):\"r1\");\n\n\tasm volatile (\n\t\t\"r9 = %[skops];\\n\"\n\t\t\"r9 = *(u64 *)(r9 +184);\\n\"\n\t\t\"if r9 == 0 goto +1;\\n\"\n\t\t\"r9 = *(u32 *)(r9 +4);\\n\"\n\t\t:: [skops] \"r\"(skops):\"r9\");\n\n\tasm volatile (\n\t\t\"r1 = %[skops];\\n\"\n\t\t\"r2 = *(u64 *)(r1 +184);\\n\"\n\t\t\"if r2 == 0 goto +1;\\n\"\n\t\t\"r2 = *(u32 *)(r2 +4);\\n\"\n\t\t:: [skops] \"r\"(skops):\"r1\", \"r2\");\n\n\top = (int) skops->op;\n\n\tglobal.event_map |= (1 << op);\n\n\tswitch (op) {\n\tcase BPF_SOCK_OPS_TCP_CONNECT_CB:\n\t\trv = bpf_setsockopt(skops, SOL_TCP, TCP_WINDOW_CLAMP,\n\t\t\t\t    &window_clamp, sizeof(window_clamp));\n\t\tglobal.window_clamp_client = get_tp_window_clamp(skops);\n\t\tbreak;\n\tcase BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:\n\t\t \n\t\tglobal.bad_cb_test_rv = bpf_sock_ops_cb_flags_set(skops, 0x80);\n\t\t \n\t\tglobal.good_cb_test_rv = bpf_sock_ops_cb_flags_set(skops,\n\t\t\t\t\t\t BPF_SOCK_OPS_STATE_CB_FLAG);\n\t\tbreak;\n\tcase BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB:\n\t\tskops->sk_txhash = 0x12345f;\n\t\tv = 0xff;\n\t\trv = bpf_setsockopt(skops, SOL_IPV6, IPV6_TCLASS, &v,\n\t\t\t\t    sizeof(v));\n\t\tif (skops->family == AF_INET6) {\n\t\t\tv = bpf_getsockopt(skops, IPPROTO_TCP, TCP_SAVED_SYN,\n\t\t\t\t\t   header, (sizeof(struct ipv6hdr) +\n\t\t\t\t\t\t    sizeof(struct tcphdr)));\n\t\t\tif (!v) {\n\t\t\t\tint offset = sizeof(struct ipv6hdr);\n\n\t\t\t\tthdr = (struct tcphdr *)(header + offset);\n\t\t\t\tv = thdr->syn;\n\n\t\t\t\tglobal.tcp_saved_syn = v;\n\t\t\t}\n\t\t}\n\t\trv = bpf_setsockopt(skops, SOL_TCP, TCP_WINDOW_CLAMP,\n\t\t\t\t    &window_clamp, sizeof(window_clamp));\n\n\t\tglobal.window_clamp_server = get_tp_window_clamp(skops);\n\t\tbreak;\n\tcase BPF_SOCK_OPS_RTO_CB:\n\t\tbreak;\n\tcase BPF_SOCK_OPS_RETRANS_CB:\n\t\tbreak;\n\tcase BPF_SOCK_OPS_STATE_CB:\n\t\tif (skops->args[1] == BPF_TCP_CLOSE) {\n\t\t\tif (skops->args[0] == BPF_TCP_LISTEN) {\n\t\t\t\tglobal.num_listen++;\n\t\t\t} else {\n\t\t\t\tglobal.total_retrans = skops->total_retrans;\n\t\t\t\tglobal.data_segs_in = skops->data_segs_in;\n\t\t\t\tglobal.data_segs_out = skops->data_segs_out;\n\t\t\t\tglobal.bytes_received = skops->bytes_received;\n\t\t\t\tglobal.bytes_acked = skops->bytes_acked;\n\t\t\t}\n\t\t\tglobal.num_close_events++;\n\t\t}\n\t\tbreak;\n\tcase BPF_SOCK_OPS_TCP_LISTEN_CB:\n\t\tbpf_sock_ops_cb_flags_set(skops, BPF_SOCK_OPS_STATE_CB_FLAG);\n\t\tv = bpf_setsockopt(skops, IPPROTO_TCP, TCP_SAVE_SYN,\n\t\t\t\t   &save_syn, sizeof(save_syn));\n\t\t \n\t\tglobal.tcp_save_syn = v;\n\t\tbreak;\n\tdefault:\n\t\trv = -1;\n\t}\n\tskops->reply = rv;\n\treturn 1;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}