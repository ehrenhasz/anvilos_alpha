{
  "module_name": "bind6_prog.c",
  "hash_id": "841505d37d4136124e2f95fc6bc6d325d9876e388ae3ee45829f9a8f5024091b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/bind6_prog.c",
  "human_readable_source": "\n\n#include <string.h>\n\n#include <linux/stddef.h>\n#include <linux/bpf.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/if.h>\n#include <errno.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#define SERV6_IP_0\t\t0xfaceb00c  \n#define SERV6_IP_1\t\t0x12345678\n#define SERV6_IP_2\t\t0x00000000\n#define SERV6_IP_3\t\t0x0000abcd\n#define SERV6_PORT\t\t6060\n#define SERV6_REWRITE_IP_0\t0x00000000\n#define SERV6_REWRITE_IP_1\t0x00000000\n#define SERV6_REWRITE_IP_2\t0x00000000\n#define SERV6_REWRITE_IP_3\t0x00000001\n#define SERV6_REWRITE_PORT\t6666\n\n#ifndef IFNAMSIZ\n#define IFNAMSIZ 16\n#endif\n\nstatic __inline int bind_to_device(struct bpf_sock_addr *ctx)\n{\n\tchar veth1[IFNAMSIZ] = \"test_sock_addr1\";\n\tchar veth2[IFNAMSIZ] = \"test_sock_addr2\";\n\tchar missing[IFNAMSIZ] = \"nonexistent_dev\";\n\tchar del_bind[IFNAMSIZ] = \"\";\n\tint veth1_idx, veth2_idx;\n\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t   &veth1, sizeof(veth1)))\n\t\treturn 1;\n\tif (bpf_getsockopt(ctx, SOL_SOCKET, SO_BINDTOIFINDEX,\n\t\t\t   &veth1_idx, sizeof(veth1_idx)) || !veth1_idx)\n\t\treturn 1;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t   &veth2, sizeof(veth2)))\n\t\treturn 1;\n\tif (bpf_getsockopt(ctx, SOL_SOCKET, SO_BINDTOIFINDEX,\n\t\t\t   &veth2_idx, sizeof(veth2_idx)) || !veth2_idx ||\n\t    veth1_idx == veth2_idx)\n\t\treturn 1;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t   &missing, sizeof(missing)) != -ENODEV)\n\t\treturn 1;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTOIFINDEX,\n\t\t\t   &veth1_idx, sizeof(veth1_idx)))\n\t\treturn 1;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t   &del_bind, sizeof(del_bind)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic __inline int bind_reuseport(struct bpf_sock_addr *ctx)\n{\n\tint val = 1;\n\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t   &val, sizeof(val)))\n\t\treturn 1;\n\tif (bpf_getsockopt(ctx, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t   &val, sizeof(val)) || !val)\n\t\treturn 1;\n\tval = 0;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t   &val, sizeof(val)))\n\t\treturn 1;\n\tif (bpf_getsockopt(ctx, SOL_SOCKET, SO_REUSEPORT,\n\t\t\t   &val, sizeof(val)) || val)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic __inline int misc_opts(struct bpf_sock_addr *ctx, int opt)\n{\n\tint old, tmp, new = 0xeb9f;\n\n\t \n\tif (bpf_getsockopt(ctx, SOL_SOCKET, opt, &old, sizeof(old)) ||\n\t    old == new)\n\t\treturn 1;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, opt, &new, sizeof(new)))\n\t\treturn 1;\n\tif (bpf_getsockopt(ctx, SOL_SOCKET, opt, &tmp, sizeof(tmp)) ||\n\t    tmp != new)\n\t\treturn 1;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, opt, &old, sizeof(old)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nSEC(\"cgroup/bind6\")\nint bind_v6_prog(struct bpf_sock_addr *ctx)\n{\n\tstruct bpf_sock *sk;\n\t__u32 user_ip6;\n\t__u16 user_port;\n\tint i;\n\n\tsk = ctx->sk;\n\tif (!sk)\n\t\treturn 0;\n\n\tif (sk->family != AF_INET6)\n\t\treturn 0;\n\n\tif (ctx->type != SOCK_STREAM && ctx->type != SOCK_DGRAM)\n\t\treturn 0;\n\n\tif (ctx->user_ip6[0] != bpf_htonl(SERV6_IP_0) ||\n\t    ctx->user_ip6[1] != bpf_htonl(SERV6_IP_1) ||\n\t    ctx->user_ip6[2] != bpf_htonl(SERV6_IP_2) ||\n\t    ctx->user_ip6[3] != bpf_htonl(SERV6_IP_3) ||\n\t    ctx->user_port != bpf_htons(SERV6_PORT))\n\t\treturn 0;\n\n\t\n\tfor (i = 0; i < 4; i++) {\n\t\tuser_ip6 = 0;\n\t\tuser_ip6 |= ((volatile __u8 *)&ctx->user_ip6[i])[0] << 0;\n\t\tuser_ip6 |= ((volatile __u8 *)&ctx->user_ip6[i])[1] << 8;\n\t\tuser_ip6 |= ((volatile __u8 *)&ctx->user_ip6[i])[2] << 16;\n\t\tuser_ip6 |= ((volatile __u8 *)&ctx->user_ip6[i])[3] << 24;\n\t\tif (ctx->user_ip6[i] != user_ip6)\n\t\t\treturn 0;\n\t}\n\n\tuser_port = 0;\n\tuser_port |= ((volatile __u8 *)&ctx->user_port)[0] << 0;\n\tuser_port |= ((volatile __u8 *)&ctx->user_port)[1] << 8;\n\tif (ctx->user_port != user_port)\n\t\treturn 0;\n\n\t\n\tfor (i = 0; i < 4; i++) {\n\t\tuser_ip6 = 0;\n\t\tuser_ip6 |= ((volatile __u16 *)&ctx->user_ip6[i])[0] << 0;\n\t\tuser_ip6 |= ((volatile __u16 *)&ctx->user_ip6[i])[1] << 16;\n\t\tif (ctx->user_ip6[i] != user_ip6)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (bind_to_device(ctx))\n\t\treturn 0;\n\n\t \n\tif (misc_opts(ctx, SO_MARK) || misc_opts(ctx, SO_PRIORITY))\n\t\treturn 0;\n\n\t \n\tif (bind_reuseport(ctx))\n\t\treturn 0;\n\n\tctx->user_ip6[0] = bpf_htonl(SERV6_REWRITE_IP_0);\n\tctx->user_ip6[1] = bpf_htonl(SERV6_REWRITE_IP_1);\n\tctx->user_ip6[2] = bpf_htonl(SERV6_REWRITE_IP_2);\n\tctx->user_ip6[3] = bpf_htonl(SERV6_REWRITE_IP_3);\n\tctx->user_port = bpf_htons(SERV6_REWRITE_PORT);\n\n\treturn 1;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}