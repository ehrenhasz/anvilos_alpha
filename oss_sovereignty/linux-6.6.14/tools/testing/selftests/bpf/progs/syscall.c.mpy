{
  "module_name": "syscall.c",
  "hash_id": "be786177a7129a4a9c92a974018335f88307b2384ae909fc1ce92e1d9dd595e0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/syscall.c",
  "human_readable_source": "\n \n#include <linux/stddef.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <../../../tools/include/linux/filter.h>\n#include <linux/btf.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct args {\n\t__u64 log_buf;\n\t__u32 log_size;\n\tint max_entries;\n\tint map_fd;\n\tint prog_fd;\n\tint btf_fd;\n};\n\n#define BTF_INFO_ENC(kind, kind_flag, vlen) \\\n\t((!!(kind_flag) << 31) | ((kind) << 24) | ((vlen) & BTF_MAX_VLEN))\n#define BTF_TYPE_ENC(name, info, size_or_type) (name), (info), (size_or_type)\n#define BTF_INT_ENC(encoding, bits_offset, nr_bits) \\\n\t((encoding) << 24 | (bits_offset) << 16 | (nr_bits))\n#define BTF_TYPE_INT_ENC(name, encoding, bits_offset, bits, sz) \\\n\tBTF_TYPE_ENC(name, BTF_INFO_ENC(BTF_KIND_INT, 0, 0), sz), \\\n\tBTF_INT_ENC(encoding, bits_offset, bits)\n\nstatic int btf_load(void)\n{\n\tstruct btf_blob {\n\t\tstruct btf_header btf_hdr;\n\t\t__u32 types[8];\n\t\t__u32 str;\n\t} raw_btf = {\n\t\t.btf_hdr = {\n\t\t\t.magic = BTF_MAGIC,\n\t\t\t.version = BTF_VERSION,\n\t\t\t.hdr_len = sizeof(struct btf_header),\n\t\t\t.type_len = sizeof(__u32) * 8,\n\t\t\t.str_off = sizeof(__u32) * 8,\n\t\t\t.str_len = sizeof(__u32),\n\t\t},\n\t\t.types = {\n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 64, 8),   \n\t\t\t \n\t\t\tBTF_TYPE_INT_ENC(0, 0, 0, 64, 8),   \n\t\t},\n\t};\n\tstatic union bpf_attr btf_load_attr = {\n\t\t.btf_size = sizeof(raw_btf),\n\t};\n\n\tbtf_load_attr.btf = (long)&raw_btf;\n\treturn bpf_sys_bpf(BPF_BTF_LOAD, &btf_load_attr, sizeof(btf_load_attr));\n}\n\nSEC(\"syscall\")\nint bpf_prog(struct args *ctx)\n{\n\tstatic char license[] = \"GPL\";\n\tstatic struct bpf_insn insns[] = {\n\t\tBPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),\n\t\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\n\t\tBPF_LD_MAP_FD(BPF_REG_1, 0),\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tstatic union bpf_attr map_create_attr = {\n\t\t.map_type = BPF_MAP_TYPE_HASH,\n\t\t.key_size = 8,\n\t\t.value_size = 8,\n\t\t.btf_key_type_id = 1,\n\t\t.btf_value_type_id = 2,\n\t};\n\tstatic union bpf_attr map_update_attr = { .map_fd = 1, };\n\tstatic __u64 key = 12;\n\tstatic __u64 value = 34;\n\tstatic union bpf_attr prog_load_attr = {\n\t\t.prog_type = BPF_PROG_TYPE_XDP,\n\t\t.insn_cnt = sizeof(insns) / sizeof(insns[0]),\n\t};\n\tint ret;\n\n\tret = btf_load();\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tctx->btf_fd = ret;\n\tmap_create_attr.max_entries = ctx->max_entries;\n\tmap_create_attr.btf_fd = ret;\n\n\tprog_load_attr.license = (long) license;\n\tprog_load_attr.insns = (long) insns;\n\tprog_load_attr.log_buf = ctx->log_buf;\n\tprog_load_attr.log_size = ctx->log_size;\n\tprog_load_attr.log_level = 1;\n\n\tret = bpf_sys_bpf(BPF_MAP_CREATE, &map_create_attr, sizeof(map_create_attr));\n\tif (ret <= 0)\n\t\treturn ret;\n\tctx->map_fd = ret;\n\tinsns[3].imm = ret;\n\n\tmap_update_attr.map_fd = ret;\n\tmap_update_attr.key = (long) &key;\n\tmap_update_attr.value = (long) &value;\n\tret = bpf_sys_bpf(BPF_MAP_UPDATE_ELEM, &map_update_attr, sizeof(map_update_attr));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bpf_sys_bpf(BPF_PROG_LOAD, &prog_load_attr, sizeof(prog_load_attr));\n\tif (ret <= 0)\n\t\treturn ret;\n\tctx->prog_fd = ret;\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}