{
  "module_name": "xdp_synproxy_kern.c",
  "hash_id": "b3c188d23ed3b1bc4c0072e1a65cd172df22a9178dfdbd6e5ed42b34e64793f2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/xdp_synproxy_kern.c",
  "human_readable_source": "\n \n\n#include \"vmlinux.h\"\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include <asm/errno.h>\n\n#define TC_ACT_OK 0\n#define TC_ACT_SHOT 2\n\n#define NSEC_PER_SEC 1000000000L\n\n#define ETH_ALEN 6\n#define ETH_P_IP 0x0800\n#define ETH_P_IPV6 0x86DD\n\n#define tcp_flag_word(tp) (((union tcp_word_hdr *)(tp))->words[3])\n\n#define IP_DF 0x4000\n#define IP_MF 0x2000\n#define IP_OFFSET 0x1fff\n\n#define NEXTHDR_TCP 6\n\n#define TCPOPT_NOP 1\n#define TCPOPT_EOL 0\n#define TCPOPT_MSS 2\n#define TCPOPT_WINDOW 3\n#define TCPOPT_SACK_PERM 4\n#define TCPOPT_TIMESTAMP 8\n\n#define TCPOLEN_MSS 4\n#define TCPOLEN_WINDOW 3\n#define TCPOLEN_SACK_PERM 2\n#define TCPOLEN_TIMESTAMP 10\n\n#define TCP_TS_HZ 1000\n#define TS_OPT_WSCALE_MASK 0xf\n#define TS_OPT_SACK (1 << 4)\n#define TS_OPT_ECN (1 << 5)\n#define TSBITS 6\n#define TSMASK (((__u32)1 << TSBITS) - 1)\n#define TCP_MAX_WSCALE 14U\n\n#define IPV4_MAXLEN 60\n#define TCP_MAXLEN 60\n\n#define DEFAULT_MSS4 1460\n#define DEFAULT_MSS6 1440\n#define DEFAULT_WSCALE 7\n#define DEFAULT_TTL 64\n#define MAX_ALLOWED_PORTS 8\n\n#define swap(a, b) \\\n\tdo { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)\n\n#define __get_unaligned_t(type, ptr) ({\t\t\t\t\t\t\\\n\tconst struct { type x; } __attribute__((__packed__)) *__pptr = (typeof(__pptr))(ptr); \\\n\t__pptr->x;\t\t\t\t\t\t\t\t\\\n})\n\n#define get_unaligned(ptr) __get_unaligned_t(typeof(*(ptr)), (ptr))\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, __u32);\n\t__type(value, __u64);\n\t__uint(max_entries, 2);\n} values SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, __u32);\n\t__type(value, __u16);\n\t__uint(max_entries, MAX_ALLOWED_PORTS);\n} allowed_ports SEC(\".maps\");\n\n \n\nstruct bpf_ct_opts___local {\n\ts32 netns_id;\n\ts32 error;\n\tu8 l4proto;\n\tu8 dir;\n\tu8 reserved[2];\n} __attribute__((preserve_access_index));\n\n#define BPF_F_CURRENT_NETNS (-1)\n\nextern struct nf_conn *bpf_xdp_ct_lookup(struct xdp_md *xdp_ctx,\n\t\t\t\t\t struct bpf_sock_tuple *bpf_tuple,\n\t\t\t\t\t __u32 len_tuple,\n\t\t\t\t\t struct bpf_ct_opts___local *opts,\n\t\t\t\t\t __u32 len_opts) __ksym;\n\nextern struct nf_conn *bpf_skb_ct_lookup(struct __sk_buff *skb_ctx,\n\t\t\t\t\t struct bpf_sock_tuple *bpf_tuple,\n\t\t\t\t\t u32 len_tuple,\n\t\t\t\t\t struct bpf_ct_opts___local *opts,\n\t\t\t\t\t u32 len_opts) __ksym;\n\nextern void bpf_ct_release(struct nf_conn *ct) __ksym;\n\nstatic __always_inline void swap_eth_addr(__u8 *a, __u8 *b)\n{\n\t__u8 tmp[ETH_ALEN];\n\n\t__builtin_memcpy(tmp, a, ETH_ALEN);\n\t__builtin_memcpy(a, b, ETH_ALEN);\n\t__builtin_memcpy(b, tmp, ETH_ALEN);\n}\n\nstatic __always_inline __u16 csum_fold(__u32 csum)\n{\n\tcsum = (csum & 0xffff) + (csum >> 16);\n\tcsum = (csum & 0xffff) + (csum >> 16);\n\treturn (__u16)~csum;\n}\n\nstatic __always_inline __u16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,\n\t\t\t\t\t       __u32 len, __u8 proto,\n\t\t\t\t\t       __u32 csum)\n{\n\t__u64 s = csum;\n\n\ts += (__u32)saddr;\n\ts += (__u32)daddr;\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\ts += proto + len;\n#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\ts += (proto + len) << 8;\n#else\n#error Unknown endian\n#endif\n\ts = (s & 0xffffffff) + (s >> 32);\n\ts = (s & 0xffffffff) + (s >> 32);\n\n\treturn csum_fold((__u32)s);\n}\n\nstatic __always_inline __u16 csum_ipv6_magic(const struct in6_addr *saddr,\n\t\t\t\t\t     const struct in6_addr *daddr,\n\t\t\t\t\t     __u32 len, __u8 proto, __u32 csum)\n{\n\t__u64 sum = csum;\n\tint i;\n\n#pragma unroll\n\tfor (i = 0; i < 4; i++)\n\t\tsum += (__u32)saddr->in6_u.u6_addr32[i];\n\n#pragma unroll\n\tfor (i = 0; i < 4; i++)\n\t\tsum += (__u32)daddr->in6_u.u6_addr32[i];\n\n\t \n\tsum += bpf_htonl(len);\n\tsum += bpf_htonl(proto);\n\n\tsum = (sum & 0xffffffff) + (sum >> 32);\n\tsum = (sum & 0xffffffff) + (sum >> 32);\n\n\treturn csum_fold((__u32)sum);\n}\n\nstatic __always_inline __u64 tcp_clock_ns(void)\n{\n\treturn bpf_ktime_get_ns();\n}\n\nstatic __always_inline __u32 tcp_ns_to_ts(__u64 ns)\n{\n\treturn ns / (NSEC_PER_SEC / TCP_TS_HZ);\n}\n\nstatic __always_inline __u32 tcp_time_stamp_raw(void)\n{\n\treturn tcp_ns_to_ts(tcp_clock_ns());\n}\n\nstruct tcpopt_context {\n\t__u8 *ptr;\n\t__u8 *end;\n\tvoid *data_end;\n\t__be32 *tsecr;\n\t__u8 wscale;\n\tbool option_timestamp;\n\tbool option_sack;\n};\n\nstatic int tscookie_tcpopt_parse(struct tcpopt_context *ctx)\n{\n\t__u8 opcode, opsize;\n\n\tif (ctx->ptr >= ctx->end)\n\t\treturn 1;\n\tif (ctx->ptr >= ctx->data_end)\n\t\treturn 1;\n\n\topcode = ctx->ptr[0];\n\n\tif (opcode == TCPOPT_EOL)\n\t\treturn 1;\n\tif (opcode == TCPOPT_NOP) {\n\t\t++ctx->ptr;\n\t\treturn 0;\n\t}\n\n\tif (ctx->ptr + 1 >= ctx->end)\n\t\treturn 1;\n\tif (ctx->ptr + 1 >= ctx->data_end)\n\t\treturn 1;\n\topsize = ctx->ptr[1];\n\tif (opsize < 2)\n\t\treturn 1;\n\n\tif (ctx->ptr + opsize > ctx->end)\n\t\treturn 1;\n\n\tswitch (opcode) {\n\tcase TCPOPT_WINDOW:\n\t\tif (opsize == TCPOLEN_WINDOW && ctx->ptr + TCPOLEN_WINDOW <= ctx->data_end)\n\t\t\tctx->wscale = ctx->ptr[2] < TCP_MAX_WSCALE ? ctx->ptr[2] : TCP_MAX_WSCALE;\n\t\tbreak;\n\tcase TCPOPT_TIMESTAMP:\n\t\tif (opsize == TCPOLEN_TIMESTAMP && ctx->ptr + TCPOLEN_TIMESTAMP <= ctx->data_end) {\n\t\t\tctx->option_timestamp = true;\n\t\t\t \n\t\t\t*ctx->tsecr = get_unaligned((__be32 *)(ctx->ptr + 2));\n\t\t}\n\t\tbreak;\n\tcase TCPOPT_SACK_PERM:\n\t\tif (opsize == TCPOLEN_SACK_PERM)\n\t\t\tctx->option_sack = true;\n\t\tbreak;\n\t}\n\n\tctx->ptr += opsize;\n\n\treturn 0;\n}\n\nstatic int tscookie_tcpopt_parse_batch(__u32 index, void *context)\n{\n\tint i;\n\n\tfor (i = 0; i < 7; i++)\n\t\tif (tscookie_tcpopt_parse(context))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic __always_inline bool tscookie_init(struct tcphdr *tcp_header,\n\t\t\t\t\t  __u16 tcp_len, __be32 *tsval,\n\t\t\t\t\t  __be32 *tsecr, void *data_end)\n{\n\tstruct tcpopt_context loop_ctx = {\n\t\t.ptr = (__u8 *)(tcp_header + 1),\n\t\t.end = (__u8 *)tcp_header + tcp_len,\n\t\t.data_end = data_end,\n\t\t.tsecr = tsecr,\n\t\t.wscale = TS_OPT_WSCALE_MASK,\n\t\t.option_timestamp = false,\n\t\t.option_sack = false,\n\t};\n\tu32 cookie;\n\n\tbpf_loop(6, tscookie_tcpopt_parse_batch, &loop_ctx, 0);\n\n\tif (!loop_ctx.option_timestamp)\n\t\treturn false;\n\n\tcookie = tcp_time_stamp_raw() & ~TSMASK;\n\tcookie |= loop_ctx.wscale & TS_OPT_WSCALE_MASK;\n\tif (loop_ctx.option_sack)\n\t\tcookie |= TS_OPT_SACK;\n\tif (tcp_header->ece && tcp_header->cwr)\n\t\tcookie |= TS_OPT_ECN;\n\t*tsval = bpf_htonl(cookie);\n\n\treturn true;\n}\n\nstatic __always_inline void values_get_tcpipopts(__u16 *mss, __u8 *wscale,\n\t\t\t\t\t\t __u8 *ttl, bool ipv6)\n{\n\t__u32 key = 0;\n\t__u64 *value;\n\n\tvalue = bpf_map_lookup_elem(&values, &key);\n\tif (value && *value != 0) {\n\t\tif (ipv6)\n\t\t\t*mss = (*value >> 32) & 0xffff;\n\t\telse\n\t\t\t*mss = *value & 0xffff;\n\t\t*wscale = (*value >> 16) & 0xf;\n\t\t*ttl = (*value >> 24) & 0xff;\n\t\treturn;\n\t}\n\n\t*mss = ipv6 ? DEFAULT_MSS6 : DEFAULT_MSS4;\n\t*wscale = DEFAULT_WSCALE;\n\t*ttl = DEFAULT_TTL;\n}\n\nstatic __always_inline void values_inc_synacks(void)\n{\n\t__u32 key = 1;\n\t__u64 *value;\n\n\tvalue = bpf_map_lookup_elem(&values, &key);\n\tif (value)\n\t\t__sync_fetch_and_add(value, 1);\n}\n\nstatic __always_inline bool check_port_allowed(__u16 port)\n{\n\t__u32 i;\n\n\tfor (i = 0; i < MAX_ALLOWED_PORTS; i++) {\n\t\t__u32 key = i;\n\t\t__u16 *value;\n\n\t\tvalue = bpf_map_lookup_elem(&allowed_ports, &key);\n\n\t\tif (!value)\n\t\t\tbreak;\n\t\t \n\t\tif (*value == 0)\n\t\t\tbreak;\n\n\t\tif (*value == port)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstruct header_pointers {\n\tstruct ethhdr *eth;\n\tstruct iphdr *ipv4;\n\tstruct ipv6hdr *ipv6;\n\tstruct tcphdr *tcp;\n\t__u16 tcp_len;\n};\n\nstatic __always_inline int tcp_dissect(void *data, void *data_end,\n\t\t\t\t       struct header_pointers *hdr)\n{\n\thdr->eth = data;\n\tif (hdr->eth + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\tswitch (bpf_ntohs(hdr->eth->h_proto)) {\n\tcase ETH_P_IP:\n\t\thdr->ipv6 = NULL;\n\n\t\thdr->ipv4 = (void *)hdr->eth + sizeof(*hdr->eth);\n\t\tif (hdr->ipv4 + 1 > data_end)\n\t\t\treturn XDP_DROP;\n\t\tif (hdr->ipv4->ihl * 4 < sizeof(*hdr->ipv4))\n\t\t\treturn XDP_DROP;\n\t\tif (hdr->ipv4->version != 4)\n\t\t\treturn XDP_DROP;\n\n\t\tif (hdr->ipv4->protocol != IPPROTO_TCP)\n\t\t\treturn XDP_PASS;\n\n\t\thdr->tcp = (void *)hdr->ipv4 + hdr->ipv4->ihl * 4;\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\thdr->ipv4 = NULL;\n\n\t\thdr->ipv6 = (void *)hdr->eth + sizeof(*hdr->eth);\n\t\tif (hdr->ipv6 + 1 > data_end)\n\t\t\treturn XDP_DROP;\n\t\tif (hdr->ipv6->version != 6)\n\t\t\treturn XDP_DROP;\n\n\t\t \n\t\tif (hdr->ipv6->nexthdr != NEXTHDR_TCP)\n\t\t\treturn XDP_PASS;\n\n\t\thdr->tcp = (void *)hdr->ipv6 + sizeof(*hdr->ipv6);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn XDP_PASS;\n\t}\n\n\tif (hdr->tcp + 1 > data_end)\n\t\treturn XDP_DROP;\n\thdr->tcp_len = hdr->tcp->doff * 4;\n\tif (hdr->tcp_len < sizeof(*hdr->tcp))\n\t\treturn XDP_DROP;\n\n\treturn XDP_TX;\n}\n\nstatic __always_inline int tcp_lookup(void *ctx, struct header_pointers *hdr, bool xdp)\n{\n\tstruct bpf_ct_opts___local ct_lookup_opts = {\n\t\t.netns_id = BPF_F_CURRENT_NETNS,\n\t\t.l4proto = IPPROTO_TCP,\n\t};\n\tstruct bpf_sock_tuple tup = {};\n\tstruct nf_conn *ct;\n\t__u32 tup_size;\n\n\tif (hdr->ipv4) {\n\t\t \n\t\tif ((hdr->ipv4->frag_off & bpf_htons(IP_DF | IP_MF | IP_OFFSET)) != bpf_htons(IP_DF))\n\t\t\treturn XDP_DROP;\n\n\t\ttup.ipv4.saddr = hdr->ipv4->saddr;\n\t\ttup.ipv4.daddr = hdr->ipv4->daddr;\n\t\ttup.ipv4.sport = hdr->tcp->source;\n\t\ttup.ipv4.dport = hdr->tcp->dest;\n\t\ttup_size = sizeof(tup.ipv4);\n\t} else if (hdr->ipv6) {\n\t\t__builtin_memcpy(tup.ipv6.saddr, &hdr->ipv6->saddr, sizeof(tup.ipv6.saddr));\n\t\t__builtin_memcpy(tup.ipv6.daddr, &hdr->ipv6->daddr, sizeof(tup.ipv6.daddr));\n\t\ttup.ipv6.sport = hdr->tcp->source;\n\t\ttup.ipv6.dport = hdr->tcp->dest;\n\t\ttup_size = sizeof(tup.ipv6);\n\t} else {\n\t\t \n\t\treturn XDP_ABORTED;\n\t}\n\tif (xdp)\n\t\tct = bpf_xdp_ct_lookup(ctx, &tup, tup_size, &ct_lookup_opts, sizeof(ct_lookup_opts));\n\telse\n\t\tct = bpf_skb_ct_lookup(ctx, &tup, tup_size, &ct_lookup_opts, sizeof(ct_lookup_opts));\n\tif (ct) {\n\t\tunsigned long status = ct->status;\n\n\t\tbpf_ct_release(ct);\n\t\tif (status & IPS_CONFIRMED)\n\t\t\treturn XDP_PASS;\n\t} else if (ct_lookup_opts.error != -ENOENT) {\n\t\treturn XDP_ABORTED;\n\t}\n\n\t \n\treturn XDP_TX;\n}\n\nstatic __always_inline __u8 tcp_mkoptions(__be32 *buf, __be32 *tsopt, __u16 mss,\n\t\t\t\t\t  __u8 wscale)\n{\n\t__be32 *start = buf;\n\n\t*buf++ = bpf_htonl((TCPOPT_MSS << 24) | (TCPOLEN_MSS << 16) | mss);\n\n\tif (!tsopt)\n\t\treturn buf - start;\n\n\tif (tsopt[0] & bpf_htonl(1 << 4))\n\t\t*buf++ = bpf_htonl((TCPOPT_SACK_PERM << 24) |\n\t\t\t\t   (TCPOLEN_SACK_PERM << 16) |\n\t\t\t\t   (TCPOPT_TIMESTAMP << 8) |\n\t\t\t\t   TCPOLEN_TIMESTAMP);\n\telse\n\t\t*buf++ = bpf_htonl((TCPOPT_NOP << 24) |\n\t\t\t\t   (TCPOPT_NOP << 16) |\n\t\t\t\t   (TCPOPT_TIMESTAMP << 8) |\n\t\t\t\t   TCPOLEN_TIMESTAMP);\n\t*buf++ = tsopt[0];\n\t*buf++ = tsopt[1];\n\n\tif ((tsopt[0] & bpf_htonl(0xf)) != bpf_htonl(0xf))\n\t\t*buf++ = bpf_htonl((TCPOPT_NOP << 24) |\n\t\t\t\t   (TCPOPT_WINDOW << 16) |\n\t\t\t\t   (TCPOLEN_WINDOW << 8) |\n\t\t\t\t   wscale);\n\n\treturn buf - start;\n}\n\nstatic __always_inline void tcp_gen_synack(struct tcphdr *tcp_header,\n\t\t\t\t\t   __u32 cookie, __be32 *tsopt,\n\t\t\t\t\t   __u16 mss, __u8 wscale)\n{\n\tvoid *tcp_options;\n\n\ttcp_flag_word(tcp_header) = TCP_FLAG_SYN | TCP_FLAG_ACK;\n\tif (tsopt && (tsopt[0] & bpf_htonl(1 << 5)))\n\t\ttcp_flag_word(tcp_header) |= TCP_FLAG_ECE;\n\ttcp_header->doff = 5;  \n\tswap(tcp_header->source, tcp_header->dest);\n\ttcp_header->ack_seq = bpf_htonl(bpf_ntohl(tcp_header->seq) + 1);\n\ttcp_header->seq = bpf_htonl(cookie);\n\ttcp_header->window = 0;\n\ttcp_header->urg_ptr = 0;\n\ttcp_header->check = 0;  \n\n\ttcp_options = (void *)(tcp_header + 1);\n\ttcp_header->doff += tcp_mkoptions(tcp_options, tsopt, mss, wscale);\n}\n\nstatic __always_inline void tcpv4_gen_synack(struct header_pointers *hdr,\n\t\t\t\t\t     __u32 cookie, __be32 *tsopt)\n{\n\t__u8 wscale;\n\t__u16 mss;\n\t__u8 ttl;\n\n\tvalues_get_tcpipopts(&mss, &wscale, &ttl, false);\n\n\tswap_eth_addr(hdr->eth->h_source, hdr->eth->h_dest);\n\n\tswap(hdr->ipv4->saddr, hdr->ipv4->daddr);\n\thdr->ipv4->check = 0;  \n\thdr->ipv4->tos = 0;\n\thdr->ipv4->id = 0;\n\thdr->ipv4->ttl = ttl;\n\n\ttcp_gen_synack(hdr->tcp, cookie, tsopt, mss, wscale);\n\n\thdr->tcp_len = hdr->tcp->doff * 4;\n\thdr->ipv4->tot_len = bpf_htons(sizeof(*hdr->ipv4) + hdr->tcp_len);\n}\n\nstatic __always_inline void tcpv6_gen_synack(struct header_pointers *hdr,\n\t\t\t\t\t     __u32 cookie, __be32 *tsopt)\n{\n\t__u8 wscale;\n\t__u16 mss;\n\t__u8 ttl;\n\n\tvalues_get_tcpipopts(&mss, &wscale, &ttl, true);\n\n\tswap_eth_addr(hdr->eth->h_source, hdr->eth->h_dest);\n\n\tswap(hdr->ipv6->saddr, hdr->ipv6->daddr);\n\t*(__be32 *)hdr->ipv6 = bpf_htonl(0x60000000);\n\thdr->ipv6->hop_limit = ttl;\n\n\ttcp_gen_synack(hdr->tcp, cookie, tsopt, mss, wscale);\n\n\thdr->tcp_len = hdr->tcp->doff * 4;\n\thdr->ipv6->payload_len = bpf_htons(hdr->tcp_len);\n}\n\nstatic __always_inline int syncookie_handle_syn(struct header_pointers *hdr,\n\t\t\t\t\t\tvoid *ctx,\n\t\t\t\t\t\tvoid *data, void *data_end,\n\t\t\t\t\t\tbool xdp)\n{\n\t__u32 old_pkt_size, new_pkt_size;\n\t \n\t__be32 * volatile tsopt = NULL;\n\t__be32 tsopt_buf[2] = {};\n\t__u16 ip_len;\n\t__u32 cookie;\n\t__s64 value;\n\n\t \n\tif (hdr->tcp->fin || hdr->tcp->rst)\n\t\treturn XDP_DROP;\n\n\t \n\tif (!check_port_allowed(bpf_ntohs(hdr->tcp->dest)))\n\t\treturn XDP_DROP;\n\n\tif (hdr->ipv4) {\n\t\t \n\t\tvalue = bpf_csum_diff(0, 0, (void *)hdr->ipv4, hdr->ipv4->ihl * 4, 0);\n\t\tif (value < 0)\n\t\t\treturn XDP_ABORTED;\n\t\tif (csum_fold(value) != 0)\n\t\t\treturn XDP_DROP;  \n\n\t\tvalue = bpf_csum_diff(0, 0, (void *)hdr->tcp, hdr->tcp_len, 0);\n\t\tif (value < 0)\n\t\t\treturn XDP_ABORTED;\n\t\tif (csum_tcpudp_magic(hdr->ipv4->saddr, hdr->ipv4->daddr,\n\t\t\t\t      hdr->tcp_len, IPPROTO_TCP, value) != 0)\n\t\t\treturn XDP_DROP;  \n\n\t\tip_len = sizeof(*hdr->ipv4);\n\n\t\tvalue = bpf_tcp_raw_gen_syncookie_ipv4(hdr->ipv4, hdr->tcp,\n\t\t\t\t\t\t       hdr->tcp_len);\n\t} else if (hdr->ipv6) {\n\t\t \n\t\tvalue = bpf_csum_diff(0, 0, (void *)hdr->tcp, hdr->tcp_len, 0);\n\t\tif (value < 0)\n\t\t\treturn XDP_ABORTED;\n\t\tif (csum_ipv6_magic(&hdr->ipv6->saddr, &hdr->ipv6->daddr,\n\t\t\t\t    hdr->tcp_len, IPPROTO_TCP, value) != 0)\n\t\t\treturn XDP_DROP;  \n\n\t\tip_len = sizeof(*hdr->ipv6);\n\n\t\tvalue = bpf_tcp_raw_gen_syncookie_ipv6(hdr->ipv6, hdr->tcp,\n\t\t\t\t\t\t       hdr->tcp_len);\n\t} else {\n\t\treturn XDP_ABORTED;\n\t}\n\n\tif (value < 0)\n\t\treturn XDP_ABORTED;\n\tcookie = (__u32)value;\n\n\tif (tscookie_init((void *)hdr->tcp, hdr->tcp_len,\n\t\t\t  &tsopt_buf[0], &tsopt_buf[1], data_end))\n\t\ttsopt = tsopt_buf;\n\n\t \n\tif (data + sizeof(*hdr->eth) + ip_len + TCP_MAXLEN > data_end)\n\t\treturn XDP_ABORTED;\n\n\tif (hdr->ipv4) {\n\t\tif (hdr->ipv4->ihl * 4 > sizeof(*hdr->ipv4)) {\n\t\t\tstruct tcphdr *new_tcp_header;\n\n\t\t\tnew_tcp_header = data + sizeof(*hdr->eth) + sizeof(*hdr->ipv4);\n\t\t\t__builtin_memmove(new_tcp_header, hdr->tcp, sizeof(*hdr->tcp));\n\t\t\thdr->tcp = new_tcp_header;\n\n\t\t\thdr->ipv4->ihl = sizeof(*hdr->ipv4) / 4;\n\t\t}\n\n\t\ttcpv4_gen_synack(hdr, cookie, tsopt);\n\t} else if (hdr->ipv6) {\n\t\ttcpv6_gen_synack(hdr, cookie, tsopt);\n\t} else {\n\t\treturn XDP_ABORTED;\n\t}\n\n\t \n\thdr->tcp->check = 0;\n\tvalue = bpf_csum_diff(0, 0, (void *)hdr->tcp, hdr->tcp_len, 0);\n\tif (value < 0)\n\t\treturn XDP_ABORTED;\n\tif (hdr->ipv4) {\n\t\thdr->tcp->check = csum_tcpudp_magic(hdr->ipv4->saddr,\n\t\t\t\t\t\t    hdr->ipv4->daddr,\n\t\t\t\t\t\t    hdr->tcp_len,\n\t\t\t\t\t\t    IPPROTO_TCP,\n\t\t\t\t\t\t    value);\n\n\t\thdr->ipv4->check = 0;\n\t\tvalue = bpf_csum_diff(0, 0, (void *)hdr->ipv4, sizeof(*hdr->ipv4), 0);\n\t\tif (value < 0)\n\t\t\treturn XDP_ABORTED;\n\t\thdr->ipv4->check = csum_fold(value);\n\t} else if (hdr->ipv6) {\n\t\thdr->tcp->check = csum_ipv6_magic(&hdr->ipv6->saddr,\n\t\t\t\t\t\t  &hdr->ipv6->daddr,\n\t\t\t\t\t\t  hdr->tcp_len,\n\t\t\t\t\t\t  IPPROTO_TCP,\n\t\t\t\t\t\t  value);\n\t} else {\n\t\treturn XDP_ABORTED;\n\t}\n\n\t \n\told_pkt_size = data_end - data;\n\tnew_pkt_size = sizeof(*hdr->eth) + ip_len + hdr->tcp->doff * 4;\n\tif (xdp) {\n\t\tif (bpf_xdp_adjust_tail(ctx, new_pkt_size - old_pkt_size))\n\t\t\treturn XDP_ABORTED;\n\t} else {\n\t\tif (bpf_skb_change_tail(ctx, new_pkt_size, 0))\n\t\t\treturn XDP_ABORTED;\n\t}\n\n\tvalues_inc_synacks();\n\n\treturn XDP_TX;\n}\n\nstatic __always_inline int syncookie_handle_ack(struct header_pointers *hdr)\n{\n\tint err;\n\n\tif (hdr->tcp->rst)\n\t\treturn XDP_DROP;\n\n\tif (hdr->ipv4)\n\t\terr = bpf_tcp_raw_check_syncookie_ipv4(hdr->ipv4, hdr->tcp);\n\telse if (hdr->ipv6)\n\t\terr = bpf_tcp_raw_check_syncookie_ipv6(hdr->ipv6, hdr->tcp);\n\telse\n\t\treturn XDP_ABORTED;\n\tif (err)\n\t\treturn XDP_DROP;\n\n\treturn XDP_PASS;\n}\n\nstatic __always_inline int syncookie_part1(void *ctx, void *data, void *data_end,\n\t\t\t\t\t   struct header_pointers *hdr, bool xdp)\n{\n\tint ret;\n\n\tret = tcp_dissect(data, data_end, hdr);\n\tif (ret != XDP_TX)\n\t\treturn ret;\n\n\tret = tcp_lookup(ctx, hdr, xdp);\n\tif (ret != XDP_TX)\n\t\treturn ret;\n\n\t \n\n\tif ((hdr->tcp->syn ^ hdr->tcp->ack) != 1)\n\t\treturn XDP_DROP;\n\n\t \n\tif (xdp) {\n\t\tif (bpf_xdp_adjust_tail(ctx, TCP_MAXLEN - hdr->tcp_len))\n\t\t\treturn XDP_ABORTED;\n\t} else {\n\t\t \n\t\tvolatile u64 old_len = data_end - data;\n\n\t\tif (bpf_skb_change_tail(ctx, old_len + TCP_MAXLEN - hdr->tcp_len, 0))\n\t\t\treturn XDP_ABORTED;\n\t}\n\n\treturn XDP_TX;\n}\n\nstatic __always_inline int syncookie_part2(void *ctx, void *data, void *data_end,\n\t\t\t\t\t   struct header_pointers *hdr, bool xdp)\n{\n\tif (hdr->ipv4) {\n\t\thdr->eth = data;\n\t\thdr->ipv4 = (void *)hdr->eth + sizeof(*hdr->eth);\n\t\t \n\t\tif ((void *)hdr->ipv4 + IPV4_MAXLEN > data_end)\n\t\t\treturn XDP_ABORTED;\n\t\thdr->tcp = (void *)hdr->ipv4 + hdr->ipv4->ihl * 4;\n\t} else if (hdr->ipv6) {\n\t\thdr->eth = data;\n\t\thdr->ipv6 = (void *)hdr->eth + sizeof(*hdr->eth);\n\t\thdr->tcp = (void *)hdr->ipv6 + sizeof(*hdr->ipv6);\n\t} else {\n\t\treturn XDP_ABORTED;\n\t}\n\n\tif ((void *)hdr->tcp + TCP_MAXLEN > data_end)\n\t\treturn XDP_ABORTED;\n\n\t \n\thdr->tcp_len = hdr->tcp->doff * 4;\n\tif (hdr->tcp_len < sizeof(*hdr->tcp))\n\t\treturn XDP_ABORTED;\n\n\treturn hdr->tcp->syn ? syncookie_handle_syn(hdr, ctx, data, data_end, xdp) :\n\t\t\t       syncookie_handle_ack(hdr);\n}\n\nSEC(\"xdp\")\nint syncookie_xdp(struct xdp_md *ctx)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct header_pointers hdr;\n\tint ret;\n\n\tret = syncookie_part1(ctx, data, data_end, &hdr, true);\n\tif (ret != XDP_TX)\n\t\treturn ret;\n\n\tdata_end = (void *)(long)ctx->data_end;\n\tdata = (void *)(long)ctx->data;\n\n\treturn syncookie_part2(ctx, data, data_end, &hdr, true);\n}\n\nSEC(\"tc\")\nint syncookie_tc(struct __sk_buff *skb)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tvoid *data = (void *)(long)skb->data;\n\tstruct header_pointers hdr;\n\tint ret;\n\n\tret = syncookie_part1(skb, data, data_end, &hdr, false);\n\tif (ret != XDP_TX)\n\t\treturn ret == XDP_PASS ? TC_ACT_OK : TC_ACT_SHOT;\n\n\tdata_end = (void *)(long)skb->data_end;\n\tdata = (void *)(long)skb->data;\n\n\tret = syncookie_part2(skb, data, data_end, &hdr, false);\n\tswitch (ret) {\n\tcase XDP_PASS:\n\t\treturn TC_ACT_OK;\n\tcase XDP_TX:\n\t\treturn bpf_redirect(skb->ifindex, 0);\n\tdefault:\n\t\treturn TC_ACT_SHOT;\n\t}\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}