{
  "module_name": "verifier_netfilter_ctx.c",
  "hash_id": "eef494c0ae92fdfa07708ac3484808f279e74af5f2938c5ea2ac91acb5043ae1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_netfilter_ctx.c",
  "human_readable_source": "\n\n#include \"vmlinux.h\"\n\n#include \"bpf_misc.h\"\n\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n\nSEC(\"netfilter\")\n__description(\"netfilter invalid context access, size too short\")\n__failure __msg(\"invalid bpf_context access\")\n__naked void with_invalid_ctx_access_test1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u8*)(r1 + %[__bpf_nf_ctx_state]);\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__bpf_nf_ctx_state, offsetof(struct bpf_nf_ctx, state))\n\t: __clobber_all);\n}\n\nSEC(\"netfilter\")\n__description(\"netfilter invalid context access, size too short\")\n__failure __msg(\"invalid bpf_context access\")\n__naked void with_invalid_ctx_access_test2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u16*)(r1 + %[__bpf_nf_ctx_skb]);\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__bpf_nf_ctx_skb, offsetof(struct bpf_nf_ctx, skb))\n\t: __clobber_all);\n}\n\nSEC(\"netfilter\")\n__description(\"netfilter invalid context access, past end of ctx\")\n__failure __msg(\"invalid bpf_context access\")\n__naked void with_invalid_ctx_access_test3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + %[__bpf_nf_ctx_size]);\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__bpf_nf_ctx_size, sizeof(struct bpf_nf_ctx))\n\t: __clobber_all);\n}\n\nSEC(\"netfilter\")\n__description(\"netfilter invalid context, write\")\n__failure __msg(\"invalid bpf_context access\")\n__naked void with_invalid_ctx_access_test4(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r1;\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__bpf_nf_ctx_skb, offsetof(struct bpf_nf_ctx, skb))\n\t: __clobber_all);\n}\n\n#define NF_DROP 0\n#define NF_ACCEPT 1\n\nSEC(\"netfilter\")\n__description(\"netfilter valid context read and invalid write\")\n__failure __msg(\"only read is supported\")\nint with_invalid_ctx_access_test5(struct bpf_nf_ctx *ctx)\n{\n\tstruct nf_hook_state *state = (void *)ctx->state;\n\n\tstate->sk = NULL;\n\treturn NF_ACCEPT;\n}\n\nextern int bpf_dynptr_from_skb(struct sk_buff *skb, __u64 flags,\n                               struct bpf_dynptr *ptr__uninit) __ksym;\nextern void *bpf_dynptr_slice(const struct bpf_dynptr *ptr, uint32_t offset,\n                                   void *buffer, uint32_t buffer__sz) __ksym;\n\nSEC(\"netfilter\")\n__description(\"netfilter test prog with skb and state read access\")\n__success __failure_unpriv\n__retval(0)\nint with_valid_ctx_access_test6(struct bpf_nf_ctx *ctx)\n{\n\tconst struct nf_hook_state *state = ctx->state;\n\tstruct sk_buff *skb = ctx->skb;\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tu8 buffer_iph[20] = {};\n\tu8 buffer_th[40] = {};\n\tstruct bpf_dynptr ptr;\n\tuint8_t ihl;\n\n\tif (skb->len <= 20 || bpf_dynptr_from_skb(skb, 0, &ptr))\n\t\treturn NF_ACCEPT;\n\n\tiph = bpf_dynptr_slice(&ptr, 0, buffer_iph, sizeof(buffer_iph));\n\tif (!iph)\n\t\treturn NF_ACCEPT;\n\n\tif (state->pf != 2)\n\t\treturn NF_ACCEPT;\n\n\tihl = iph->ihl << 2;\n\n\tth = bpf_dynptr_slice(&ptr, ihl, buffer_th, sizeof(buffer_th));\n\tif (!th)\n\t\treturn NF_ACCEPT;\n\n\treturn th->dest == bpf_htons(22) ? NF_ACCEPT : NF_DROP;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}