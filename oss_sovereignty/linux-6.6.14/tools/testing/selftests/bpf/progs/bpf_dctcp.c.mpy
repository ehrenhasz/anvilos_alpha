{
  "module_name": "bpf_dctcp.c",
  "hash_id": "0e8e4402d70ed0514a848e44ff21132c43ed05504bbd1ef7a0072d0225c69bfc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/bpf_dctcp.c",
  "human_readable_source": "\n \n\n \n\n#include <stddef.h>\n#include <linux/bpf.h>\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/tcp.h>\n#include <errno.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include \"bpf_tcp_helpers.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nvolatile const char fallback[TCP_CA_NAME_MAX];\nconst char bpf_dctcp[] = \"bpf_dctcp\";\nconst char tcp_cdg[] = \"cdg\";\nchar cc_res[TCP_CA_NAME_MAX];\nint tcp_cdg_res = 0;\nint stg_result = 0;\nint ebusy_cnt = 0;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, int);\n} sk_stg_map SEC(\".maps\");\n\n#define DCTCP_MAX_ALPHA\t1024U\n\nstruct dctcp {\n\t__u32 old_delivered;\n\t__u32 old_delivered_ce;\n\t__u32 prior_rcv_nxt;\n\t__u32 dctcp_alpha;\n\t__u32 next_seq;\n\t__u32 ce_state;\n\t__u32 loss_cwnd;\n};\n\nstatic unsigned int dctcp_shift_g = 4;  \nstatic unsigned int dctcp_alpha_on_init = DCTCP_MAX_ALPHA;\n\nstatic __always_inline void dctcp_reset(const struct tcp_sock *tp,\n\t\t\t\t\tstruct dctcp *ca)\n{\n\tca->next_seq = tp->snd_nxt;\n\n\tca->old_delivered = tp->delivered;\n\tca->old_delivered_ce = tp->delivered_ce;\n}\n\nSEC(\"struct_ops/dctcp_init\")\nvoid BPF_PROG(dctcp_init, struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\tint *stg;\n\n\tif (!(tp->ecn_flags & TCP_ECN_OK) && fallback[0]) {\n\t\t \n\t\tif (bpf_setsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t\t   (void *)fallback, sizeof(fallback)) == -EBUSY)\n\t\t\tebusy_cnt++;\n\n\t\t \n\t\tif (bpf_setsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t\t   (void *)bpf_dctcp, sizeof(bpf_dctcp)) == -EBUSY)\n\t\t\tebusy_cnt++;\n\n\t\t \n\t\tif (bpf_setsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t\t   (void *)fallback, sizeof(fallback)) == -EBUSY)\n\t\t\tebusy_cnt++;\n\n\t\t \n\t\ttcp_cdg_res = bpf_setsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t\t\t     (void *)tcp_cdg, sizeof(tcp_cdg));\n\t\tbpf_getsockopt(sk, SOL_TCP, TCP_CONGESTION,\n\t\t\t       (void *)cc_res, sizeof(cc_res));\n\t\treturn;\n\t}\n\n\tca->prior_rcv_nxt = tp->rcv_nxt;\n\tca->dctcp_alpha = min(dctcp_alpha_on_init, DCTCP_MAX_ALPHA);\n\tca->loss_cwnd = 0;\n\tca->ce_state = 0;\n\n\tstg = bpf_sk_storage_get(&sk_stg_map, (void *)tp, NULL, 0);\n\tif (stg) {\n\t\tstg_result = *stg;\n\t\tbpf_sk_storage_delete(&sk_stg_map, (void *)tp);\n\t}\n\tdctcp_reset(tp, ca);\n}\n\nSEC(\"struct_ops/dctcp_ssthresh\")\n__u32 BPF_PROG(dctcp_ssthresh, struct sock *sk)\n{\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->loss_cwnd = tp->snd_cwnd;\n\treturn max(tp->snd_cwnd - ((tp->snd_cwnd * ca->dctcp_alpha) >> 11U), 2U);\n}\n\nSEC(\"struct_ops/dctcp_update_alpha\")\nvoid BPF_PROG(dctcp_update_alpha, struct sock *sk, __u32 flags)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\n\t \n\tif (!before(tp->snd_una, ca->next_seq)) {\n\t\t__u32 delivered_ce = tp->delivered_ce - ca->old_delivered_ce;\n\t\t__u32 alpha = ca->dctcp_alpha;\n\n\t\t \n\n\t\talpha -= min_not_zero(alpha, alpha >> dctcp_shift_g);\n\t\tif (delivered_ce) {\n\t\t\t__u32 delivered = tp->delivered - ca->old_delivered;\n\n\t\t\t \n\t\t\tdelivered_ce <<= (10 - dctcp_shift_g);\n\t\t\tdelivered_ce /= max(1U, delivered);\n\n\t\t\talpha = min(alpha + delivered_ce, DCTCP_MAX_ALPHA);\n\t\t}\n\t\tca->dctcp_alpha = alpha;\n\t\tdctcp_reset(tp, ca);\n\t}\n}\n\nstatic __always_inline void dctcp_react_to_loss(struct sock *sk)\n{\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->loss_cwnd = tp->snd_cwnd;\n\ttp->snd_ssthresh = max(tp->snd_cwnd >> 1U, 2U);\n}\n\nSEC(\"struct_ops/dctcp_state\")\nvoid BPF_PROG(dctcp_state, struct sock *sk, __u8 new_state)\n{\n\tif (new_state == TCP_CA_Recovery &&\n\t    new_state != BPF_CORE_READ_BITFIELD(inet_csk(sk), icsk_ca_state))\n\t\tdctcp_react_to_loss(sk);\n\t \n}\n\nstatic __always_inline void dctcp_ece_ack_cwr(struct sock *sk, __u32 ce_state)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (ce_state == 1)\n\t\ttp->ecn_flags |= TCP_ECN_DEMAND_CWR;\n\telse\n\t\ttp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;\n}\n\n \nstatic __always_inline\nvoid dctcp_ece_ack_update(struct sock *sk, enum tcp_ca_event evt,\n\t\t\t  __u32 *prior_rcv_nxt, __u32 *ce_state)\n{\n\t__u32 new_ce_state = (evt == CA_EVENT_ECN_IS_CE) ? 1 : 0;\n\n\tif (*ce_state != new_ce_state) {\n\t\t \n\t\tif (inet_csk(sk)->icsk_ack.pending & ICSK_ACK_TIMER) {\n\t\t\tdctcp_ece_ack_cwr(sk, *ce_state);\n\t\t\tbpf_tcp_send_ack(sk, *prior_rcv_nxt);\n\t\t}\n\t\tinet_csk(sk)->icsk_ack.pending |= ICSK_ACK_NOW;\n\t}\n\t*prior_rcv_nxt = tcp_sk(sk)->rcv_nxt;\n\t*ce_state = new_ce_state;\n\tdctcp_ece_ack_cwr(sk, new_ce_state);\n}\n\nSEC(\"struct_ops/dctcp_cwnd_event\")\nvoid BPF_PROG(dctcp_cwnd_event, struct sock *sk, enum tcp_ca_event ev)\n{\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\n\tswitch (ev) {\n\tcase CA_EVENT_ECN_IS_CE:\n\tcase CA_EVENT_ECN_NO_CE:\n\t\tdctcp_ece_ack_update(sk, ev, &ca->prior_rcv_nxt, &ca->ce_state);\n\t\tbreak;\n\tcase CA_EVENT_LOSS:\n\t\tdctcp_react_to_loss(sk);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nSEC(\"struct_ops/dctcp_cwnd_undo\")\n__u32 BPF_PROG(dctcp_cwnd_undo, struct sock *sk)\n{\n\tconst struct dctcp *ca = inet_csk_ca(sk);\n\n\treturn max(tcp_sk(sk)->snd_cwnd, ca->loss_cwnd);\n}\n\nextern void tcp_reno_cong_avoid(struct sock *sk, __u32 ack, __u32 acked) __ksym;\n\nSEC(\"struct_ops/dctcp_reno_cong_avoid\")\nvoid BPF_PROG(dctcp_cong_avoid, struct sock *sk, __u32 ack, __u32 acked)\n{\n\ttcp_reno_cong_avoid(sk, ack, acked);\n}\n\nSEC(\".struct_ops\")\nstruct tcp_congestion_ops dctcp_nouse = {\n\t.init\t\t= (void *)dctcp_init,\n\t.set_state\t= (void *)dctcp_state,\n\t.flags\t\t= TCP_CONG_NEEDS_ECN,\n\t.name\t\t= \"bpf_dctcp_nouse\",\n};\n\nSEC(\".struct_ops\")\nstruct tcp_congestion_ops dctcp = {\n\t.init\t\t= (void *)dctcp_init,\n\t.in_ack_event   = (void *)dctcp_update_alpha,\n\t.cwnd_event\t= (void *)dctcp_cwnd_event,\n\t.ssthresh\t= (void *)dctcp_ssthresh,\n\t.cong_avoid\t= (void *)dctcp_cong_avoid,\n\t.undo_cwnd\t= (void *)dctcp_cwnd_undo,\n\t.set_state\t= (void *)dctcp_state,\n\t.flags\t\t= TCP_CONG_NEEDS_ECN,\n\t.name\t\t= \"bpf_dctcp\",\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}