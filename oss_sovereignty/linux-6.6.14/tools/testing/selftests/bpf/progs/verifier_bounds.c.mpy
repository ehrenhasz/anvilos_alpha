{
  "module_name": "verifier_bounds.c",
  "hash_id": "6f8a44bd4fd930fb6ccd1927e572db87cabb24dcc41e702c543ff4903ee08253",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_bounds.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, long long);\n} map_hash_8b SEC(\".maps\");\n\nSEC(\"socket\")\n__description(\"subtraction bounds (map value) variant 1\")\n__failure __msg(\"R0 max value is outside of the allowed memory range\")\n__failure_unpriv\n__naked void bounds_map_value_variant_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u8*)(r0 + 0);\t\t\t\t\\\n\tif r1 > 0xff goto l0_%=;\t\t\t\\\n\tr3 = *(u8*)(r0 + 1);\t\t\t\t\\\n\tif r3 > 0xff goto l0_%=;\t\t\t\\\n\tr1 -= r3;\t\t\t\t\t\\\n\tr1 >>= 56;\t\t\t\t\t\\\n\tr0 += r1;\t\t\t\t\t\\\n\tr0 = *(u8*)(r0 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"subtraction bounds (map value) variant 2\")\n__failure\n__msg(\"R0 min value is negative, either use unsigned index or do a if (index >=0) check.\")\n__msg_unpriv(\"R1 has unknown scalar with mixed signed bounds\")\n__naked void bounds_map_value_variant_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u8*)(r0 + 0);\t\t\t\t\\\n\tif r1 > 0xff goto l0_%=;\t\t\t\\\n\tr3 = *(u8*)(r0 + 1);\t\t\t\t\\\n\tif r3 > 0xff goto l0_%=;\t\t\t\\\n\tr1 -= r3;\t\t\t\t\t\\\n\tr0 += r1;\t\t\t\t\t\\\n\tr0 = *(u8*)(r0 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"check subtraction on pointers for unpriv\")\n__success __failure_unpriv __msg_unpriv(\"R9 pointer -= pointer prohibited\")\n__retval(0)\n__naked void subtraction_on_pointers_for_unpriv(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr6 = 9;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r6;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tr9 = r10;\t\t\t\t\t\\\n\tr9 -= r0;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr6 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r6;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\t*(u64*)(r0 + 0) = r9;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check based on zero-extended MOV\")\n__success __success_unpriv __retval(0)\n__naked void based_on_zero_extended_mov(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\\\n\tw2 = 0xffffffff;\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr2 >>= 32;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr0 += r2;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr0 = *(u8*)(r0 + 0);\t\t\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check based on sign-extended MOV. test1\")\n__failure __msg(\"map_value pointer and 4294967295\")\n__failure_unpriv\n__naked void on_sign_extended_mov_test1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\\\n\tr2 = 0xffffffff;\t\t\t\t\\\n\t \t\t\t\t\\\n\tr2 >>= 32;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr0 += r2;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr0 = *(u8*)(r0 + 0);\t\t\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check based on sign-extended MOV. test2\")\n__failure __msg(\"R0 min value is outside of the allowed memory range\")\n__failure_unpriv\n__naked void on_sign_extended_mov_test2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\\\n\tr2 = 0xffffffff;\t\t\t\t\\\n\t \t\t\t\t\\\n\tr2 >>= 36;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr0 += r2;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr0 = *(u8*)(r0 + 0);\t\t\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"bounds check based on reg_off + var_off + insn_off. test1\")\n__failure __msg(\"value_size=8 off=1073741825\")\n__naked void var_off_insn_off_test1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_mark]);\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr6 &= 1;\t\t\t\t\t\\\n\tr6 += %[__imm_0];\t\t\t\t\\\n\tr0 += r6;\t\t\t\t\t\\\n\tr0 += %[__imm_0];\t\t\t\t\\\nl0_%=:\tr0 = *(u8*)(r0 + 3);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b),\n\t  __imm_const(__imm_0, (1 << 29) - 1),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"bounds check based on reg_off + var_off + insn_off. test2\")\n__failure __msg(\"value 1073741823\")\n__naked void var_off_insn_off_test2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_mark]);\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr6 &= 1;\t\t\t\t\t\\\n\tr6 += %[__imm_0];\t\t\t\t\\\n\tr0 += r6;\t\t\t\t\t\\\n\tr0 += %[__imm_1];\t\t\t\t\\\nl0_%=:\tr0 = *(u8*)(r0 + 3);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b),\n\t  __imm_const(__imm_0, (1 << 30) - 1),\n\t  __imm_const(__imm_1, (1 << 29) - 1),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check after truncation of non-boundary-crossing range\")\n__success __success_unpriv __retval(0)\n__naked void of_non_boundary_crossing_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\t\\\n\tr1 = *(u8*)(r0 + 0);\t\t\t\t\\\n\tr2 = 1;\t\t\t\t\t\t\\\n\t \t\t\t\\\n\tr2 <<= 36;\t\t\t\t\t\\\n\t \t\\\n\tr1 += r2;\t\t\t\t\t\\\n\t \t\\\n\tr1 += 0x7fffffff;\t\t\t\t\\\n\t \t\t\t\t\\\n\tw1 -= 0x7fffffff;\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr1 >>= 8;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr0 += r1;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr0 = *(u8*)(r0 + 0);\t\t\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check after truncation of boundary-crossing range (1)\")\n__failure\n/* not actually fully unbounded, but the bound is very high */\n__msg(\"value -4294967168 makes map_value pointer be out of bounds\")\n__failure_unpriv\n__naked void of_boundary_crossing_range_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\t\\\n\tr1 = *(u8*)(r0 + 0);\t\t\t\t\\\n\tr1 += %[__imm_0];\t\t\t\t\\\n\t \t\t\\\n\tr1 += %[__imm_0];\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tw1 += 0;\t\t\t\t\t\\\n\tr1 -= %[__imm_0];\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr1 -= %[__imm_0];\t\t\t\t\\\n\t \t\t\\\n\tr0 += r1;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b),\n\t  __imm_const(__imm_0, 0xffffff80 >> 1)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check after truncation of boundary-crossing range (2)\")\n__failure __msg(\"value -4294967168 makes map_value pointer be out of bounds\")\n__failure_unpriv\n__naked void of_boundary_crossing_range_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\t\\\n\tr1 = *(u8*)(r0 + 0);\t\t\t\t\\\n\tr1 += %[__imm_0];\t\t\t\t\\\n\t \t\t\\\n\tr1 += %[__imm_0];\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tw1 = w1;\t\t\t\t\t\\\n\tr1 -= %[__imm_0];\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr1 -= %[__imm_0];\t\t\t\t\\\n\t \t\t\\\n\tr0 += r1;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b),\n\t  __imm_const(__imm_0, 0xffffff80 >> 1)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check after wrapping 32-bit addition\")\n__success __success_unpriv __retval(0)\n__naked void after_wrapping_32_bit_addition(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\t\\\n\tr1 = 0x7fffffff;\t\t\t\t\\\n\t \t\t\t\t\\\n\tr1 += 0x7fffffff;\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tw1 += 2;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr0 += r1;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr0 = *(u8*)(r0 + 0);\t\t\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check after shift with oversized count operand\")\n__failure __msg(\"R0 max value is outside of the allowed memory range\")\n__failure_unpriv\n__naked void shift_with_oversized_count_operand(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = 32;\t\t\t\t\t\\\n\tr1 = 1;\t\t\t\t\t\t\\\n\t \t\t\\\n\tw1 <<= w2;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr1 &= 0xffff;\t\t\t\t\t\\\n\t \t\\\n\tr0 += r1;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr0 = *(u8*)(r0 + 0);\t\t\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check after right shift of maybe-negative number\")\n__failure __msg(\"R0 unbounded memory access\")\n__failure_unpriv\n__naked void shift_of_maybe_negative_number(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\t\\\n\tr1 = *(u8*)(r0 + 0);\t\t\t\t\\\n\t \t\t\t\\\n\tr1 -= 1;\t\t\t\t\t\\\n\t \t\t\\\n\tr1 >>= 8;\t\t\t\t\t\\\n\t \t\t\\\n\tr1 >>= 8;\t\t\t\t\t\\\n\t \t\\\n\tr0 += r1;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr0 = *(u8*)(r0 + 0);\t\t\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check after 32-bit right shift with 64-bit input\")\n__failure __msg(\"math between map_value pointer and 4294967294 is not allowed\")\n__failure_unpriv\n__naked void shift_with_64_bit_input(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = 2;\t\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tr1 <<= 31;\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tw1 >>= 31;\t\t\t\t\t\\\n\t \t\t\t\\\n\tw1 -= 2;\t\t\t\t\t\\\n\t \t\t\\\n\tr0 += r1;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check map access with off+size signed 32bit overflow. test1\")\n__failure __msg(\"map_value pointer and 2147483646\")\n__failure_unpriv\n__naked void size_signed_32bit_overflow_test1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr0 += 0x7ffffffe;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl1_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check map access with off+size signed 32bit overflow. test2\")\n__failure __msg(\"pointer offset 1073741822\")\n__msg_unpriv(\"R0 pointer arithmetic of map value goes out of range\")\n__naked void size_signed_32bit_overflow_test2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr0 += 0x1fffffff;\t\t\t\t\\\n\tr0 += 0x1fffffff;\t\t\t\t\\\n\tr0 += 0x1fffffff;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl1_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check map access with off+size signed 32bit overflow. test3\")\n__failure __msg(\"pointer offset -1073741822\")\n__msg_unpriv(\"R0 pointer arithmetic of map value goes out of range\")\n__naked void size_signed_32bit_overflow_test3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr0 -= 0x1fffffff;\t\t\t\t\\\n\tr0 -= 0x1fffffff;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 2);\t\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl1_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check map access with off+size signed 32bit overflow. test4\")\n__failure __msg(\"map_value pointer and 1000000000000\")\n__failure_unpriv\n__naked void size_signed_32bit_overflow_test4(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr1 = 1000000;\t\t\t\t\t\\\n\tr1 *= 1000000;\t\t\t\t\t\\\n\tr0 += r1;\t\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 2);\t\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl1_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check mixed 32bit and 64bit arithmetic. test1\")\n__success __failure_unpriv __msg_unpriv(\"R0 invalid mem access 'scalar'\")\n__retval(0)\n__naked void _32bit_and_64bit_arithmetic_test1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\tr1 = -1;\t\t\t\t\t\\\n\tr1 <<= 32;\t\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\t \t\t\t\\\n\tif w1 > 1 goto l0_%=;\t\t\t\t\\\n\t \t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\tif w1 > 2 goto l0_%=;\t\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\t \t\\\n\tr0 = *(u64*)(r0 - 1);\t\t\t\t\\\nl1_%=:\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check mixed 32bit and 64bit arithmetic. test2\")\n__success __failure_unpriv __msg_unpriv(\"R0 invalid mem access 'scalar'\")\n__retval(0)\n__naked void _32bit_and_64bit_arithmetic_test2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\tr1 = -1;\t\t\t\t\t\\\n\tr1 <<= 32;\t\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = 3;\t\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tw1 += 1;\t\t\t\t\t\\\n\t \t\\\n\tif r1 > r2 goto l0_%=;\t\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\t \t\\\n\tr0 = *(u64*)(r0 - 1);\t\t\t\t\\\nl1_%=:\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"assigning 32bit bounds to 64bit for wA = 0, wB = wA\")\n__success __retval(0) __flag(BPF_F_ANY_ALIGNMENT)\n__naked void for_wa_0_wb_wa(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr8 = *(u32*)(r1 + %[__sk_buff_data_end]);\t\\\n\tr7 = *(u32*)(r1 + %[__sk_buff_data]);\t\t\\\n\tw9 = 0;\t\t\t\t\t\t\\\n\tw2 = w9;\t\t\t\t\t\\\n\tr6 = r7;\t\t\t\t\t\\\n\tr6 += r2;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr3 += 8;\t\t\t\t\t\\\n\tif r3 > r8 goto l0_%=;\t\t\t\t\\\n\tr5 = *(u32*)(r6 + 0);\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_data, offsetof(struct __sk_buff, data)),\n\t  __imm_const(__sk_buff_data_end, offsetof(struct __sk_buff, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check for reg = 0, reg xor 1\")\n__success __failure_unpriv\n__msg_unpriv(\"R0 min value is outside of the allowed memory range\")\n__retval(0)\n__naked void reg_0_reg_xor_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr1 = 0;\t\t\t\t\t\t\\\n\tr1 ^= 1;\t\t\t\t\t\\\n\tif r1 != 0 goto l1_%=;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 8);\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check for reg32 = 0, reg32 xor 1\")\n__success __failure_unpriv\n__msg_unpriv(\"R0 min value is outside of the allowed memory range\")\n__retval(0)\n__naked void reg32_0_reg32_xor_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tw1 = 0;\t\t\t\t\t\t\\\n\tw1 ^= 1;\t\t\t\t\t\\\n\tif w1 != 0 goto l1_%=;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 8);\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check for reg = 2, reg xor 3\")\n__success __failure_unpriv\n__msg_unpriv(\"R0 min value is outside of the allowed memory range\")\n__retval(0)\n__naked void reg_2_reg_xor_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr1 = 2;\t\t\t\t\t\t\\\n\tr1 ^= 3;\t\t\t\t\t\\\n\tif r1 > 0 goto l1_%=;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 8);\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check for reg = any, reg xor 3\")\n__failure __msg(\"invalid access to map value\")\n__msg_unpriv(\"invalid access to map value\")\n__naked void reg_any_reg_xor_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr1 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tr1 ^= 3;\t\t\t\t\t\\\n\tif r1 != 0 goto l1_%=;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 8);\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check for reg32 = any, reg32 xor 3\")\n__failure __msg(\"invalid access to map value\")\n__msg_unpriv(\"invalid access to map value\")\n__naked void reg32_any_reg32_xor_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr1 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tw1 ^= 3;\t\t\t\t\t\\\n\tif w1 != 0 goto l1_%=;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 8);\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check for reg > 0, reg xor 3\")\n__success __failure_unpriv\n__msg_unpriv(\"R0 min value is outside of the allowed memory range\")\n__retval(0)\n__naked void reg_0_reg_xor_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr1 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tif r1 <= 0 goto l1_%=;\t\t\t\t\\\n\tr1 ^= 3;\t\t\t\t\t\\\n\tif r1 >= 0 goto l1_%=;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 8);\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds check for reg32 > 0, reg32 xor 3\")\n__success __failure_unpriv\n__msg_unpriv(\"R0 min value is outside of the allowed memory range\")\n__retval(0)\n__naked void reg32_0_reg32_xor_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr1 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tif w1 <= 0 goto l1_%=;\t\t\t\t\\\n\tw1 ^= 3;\t\t\t\t\t\\\n\tif w1 >= 0 goto l1_%=;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 8);\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds checks after 32-bit truncation. test 1\")\n__success __failure_unpriv __msg_unpriv(\"R0 leaks addr\")\n__retval(0)\n__naked void _32_bit_truncation_test_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\t \\\n\tif r1 == 0 goto l1_%=;\t\t\t\t\\\n\tif r1 > 0x7fffffff goto l0_%=;\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"bounds checks after 32-bit truncation. test 2\")\n__success __failure_unpriv __msg_unpriv(\"R0 leaks addr\")\n__retval(0)\n__naked void _32_bit_truncation_test_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r1 s< 1 goto l1_%=;\t\t\t\t\\\n\tif w1 s< 0 goto l0_%=;\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"xdp\")\n__description(\"bound check with JMP_JLT for crossing 64-bit signed boundary\")\n__success __retval(0)\n__naked void crossing_64_bit_signed_boundary_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[xdp_md_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[xdp_md_data_end]);\t\t\\\n\tr1 = r2;\t\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\tif r1 > r3 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u8*)(r2 + 0);\t\t\t\t\\\n\tr0 = 0x7fffffffffffff10 ll;\t\t\t\\\n\tr1 += r0;\t\t\t\t\t\\\n\tr0 = 0x8000000000000000 ll;\t\t\t\\\nl1_%=:\tr0 += 1;\t\t\t\t\t\\\n\t \\\n\tif r0 < r1 goto l1_%=;\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(xdp_md_data, offsetof(struct xdp_md, data)),\n\t  __imm_const(xdp_md_data_end, offsetof(struct xdp_md, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"xdp\")\n__description(\"bound check with JMP_JSLT for crossing 64-bit signed boundary\")\n__success __retval(0)\n__naked void crossing_64_bit_signed_boundary_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[xdp_md_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[xdp_md_data_end]);\t\t\\\n\tr1 = r2;\t\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\tif r1 > r3 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u8*)(r2 + 0);\t\t\t\t\\\n\tr0 = 0x7fffffffffffff10 ll;\t\t\t\\\n\tr1 += r0;\t\t\t\t\t\\\n\tr2 = 0x8000000000000fff ll;\t\t\t\\\n\tr0 = 0x8000000000000000 ll;\t\t\t\\\nl1_%=:\tr0 += 1;\t\t\t\t\t\\\n\tif r0 s> r2 goto l0_%=;\t\t\t\t\\\n\t \t\\\n\tif r0 s< r1 goto l1_%=;\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(xdp_md_data, offsetof(struct xdp_md, data)),\n\t  __imm_const(xdp_md_data_end, offsetof(struct xdp_md, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"xdp\")\n__description(\"bound check for loop upper bound greater than U32_MAX\")\n__success __retval(0)\n__naked void bound_greater_than_u32_max(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[xdp_md_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[xdp_md_data_end]);\t\t\\\n\tr1 = r2;\t\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\tif r1 > r3 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u8*)(r2 + 0);\t\t\t\t\\\n\tr0 = 0x100000000 ll;\t\t\t\t\\\n\tr1 += r0;\t\t\t\t\t\\\n\tr0 = 0x100000000 ll;\t\t\t\t\\\nl1_%=:\tr0 += 1;\t\t\t\t\t\\\n\tif r0 < r1 goto l1_%=;\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(xdp_md_data, offsetof(struct xdp_md, data)),\n\t  __imm_const(xdp_md_data_end, offsetof(struct xdp_md, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"xdp\")\n__description(\"bound check with JMP32_JLT for crossing 32-bit signed boundary\")\n__success __retval(0)\n__naked void crossing_32_bit_signed_boundary_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[xdp_md_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[xdp_md_data_end]);\t\t\\\n\tr1 = r2;\t\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\tif r1 > r3 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u8*)(r2 + 0);\t\t\t\t\\\n\tw0 = 0x7fffff10;\t\t\t\t\\\n\tw1 += w0;\t\t\t\t\t\\\n\tw0 = 0x80000000;\t\t\t\t\\\nl1_%=:\tw0 += 1;\t\t\t\t\t\\\n\t \t\\\n\tif w0 < w1 goto l1_%=;\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(xdp_md_data, offsetof(struct xdp_md, data)),\n\t  __imm_const(xdp_md_data_end, offsetof(struct xdp_md, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"xdp\")\n__description(\"bound check with JMP32_JSLT for crossing 32-bit signed boundary\")\n__success __retval(0)\n__naked void crossing_32_bit_signed_boundary_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[xdp_md_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[xdp_md_data_end]);\t\t\\\n\tr1 = r2;\t\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\tif r1 > r3 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u8*)(r2 + 0);\t\t\t\t\\\n\tw0 = 0x7fffff10;\t\t\t\t\\\n\tw1 += w0;\t\t\t\t\t\\\n\tw2 = 0x80000fff;\t\t\t\t\\\n\tw0 = 0x80000000;\t\t\t\t\\\nl1_%=:\tw0 += 1;\t\t\t\t\t\\\n\tif w0 s> w2 goto l0_%=;\t\t\t\t\\\n\t \t\\\n\tif w0 s< w1 goto l1_%=;\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(xdp_md_data, offsetof(struct xdp_md, data)),\n\t  __imm_const(xdp_md_data_end, offsetof(struct xdp_md, data_end))\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}