{
  "module_name": "test_tunnel_kern.c",
  "hash_id": "5620450841f3abc728226e77cb2ec5bb2d550658e11acd6dcef7fab10d2386b0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tunnel_kern.c",
  "human_readable_source": "\n \n#include <stddef.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/if_tunnel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/icmp.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/pkt_cls.h>\n#include <linux/erspan.h>\n#include <linux/udp.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#define log_err(__ret) bpf_printk(\"ERROR line:%d ret:%d\\n\", __LINE__, __ret)\n\n#define VXLAN_UDP_PORT 4789\n\n \n#define ASSIGNED_ADDR_VETH1 0xac1001c8\n\nstruct geneve_opt {\n\t__be16\topt_class;\n\t__u8\ttype;\n\t__u8\tlength:5;\n\t__u8\tr3:1;\n\t__u8\tr2:1;\n\t__u8\tr1:1;\n\t__u8\topt_data[8];  \n};\n\nstruct vxlanhdr {\n\t__be32 vx_flags;\n\t__be32 vx_vni;\n} __attribute__((packed));\n\nstruct vxlan_metadata {\n\t__u32     gbp;\n};\n\nstruct bpf_fou_encap {\n\t__be16 sport;\n\t__be16 dport;\n};\n\nenum bpf_fou_encap_type {\n\tFOU_BPF_ENCAP_FOU,\n\tFOU_BPF_ENCAP_GUE,\n};\n\nint bpf_skb_set_fou_encap(struct __sk_buff *skb_ctx,\n\t\t\t  struct bpf_fou_encap *encap, int type) __ksym;\nint bpf_skb_get_fou_encap(struct __sk_buff *skb_ctx,\n\t\t\t  struct bpf_fou_encap *encap) __ksym;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} local_ip_map SEC(\".maps\");\n\nSEC(\"tc\")\nint gre_set_tunnel(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key;\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.remote_ipv4 = 0xac100164;  \n\tkey.tunnel_id = 2;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_ZERO_CSUM_TX | BPF_F_SEQ_NUMBER);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint gre_set_tunnel_no_key(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key;\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.remote_ipv4 = 0xac100164;  \n\tkey.tunnel_ttl = 64;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_ZERO_CSUM_TX | BPF_F_SEQ_NUMBER |\n\t\t\t\t     BPF_F_NO_TUNNEL_KEY);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint gre_get_tunnel(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tbpf_printk(\"key %d remote ip 0x%x\\n\", key.tunnel_id, key.remote_ipv4);\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip6gretap_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tint ret;\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.remote_ipv6[3] = bpf_htonl(0x11);  \n\tkey.tunnel_id = 2;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\tkey.tunnel_label = 0xabcde;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6 | BPF_F_ZERO_CSUM_TX |\n\t\t\t\t     BPF_F_SEQ_NUMBER);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip6gretap_get_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tint ret;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tbpf_printk(\"key %d remote ip6 ::%x label %x\\n\",\n\t\t   key.tunnel_id, key.remote_ipv6[3], key.tunnel_label);\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint erspan_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tstruct erspan_metadata md;\n\tint ret;\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.remote_ipv4 = 0xac100164;  \n\tkey.tunnel_id = 2;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_ZERO_CSUM_TX);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\t__builtin_memset(&md, 0, sizeof(md));\n#ifdef ERSPAN_V1\n\tmd.version = 1;\n\tmd.u.index = bpf_htonl(123);\n#else\n\t__u8 direction = 1;\n\t__u8 hwid = 7;\n\n\tmd.version = 2;\n\tmd.u.md2.dir = direction;\n\tmd.u.md2.hwid = hwid & 0xf;\n\tmd.u.md2.hwid_upper = (hwid >> 4) & 0x3;\n#endif\n\n\tret = bpf_skb_set_tunnel_opt(skb, &md, sizeof(md));\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint erspan_get_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tstruct erspan_metadata md;\n\tint ret;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tret = bpf_skb_get_tunnel_opt(skb, &md, sizeof(md));\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tbpf_printk(\"key %d remote ip 0x%x erspan version %d\\n\",\n\t\t   key.tunnel_id, key.remote_ipv4, md.version);\n\n#ifdef ERSPAN_V1\n\tindex = bpf_ntohl(md.u.index);\n\tbpf_printk(\"\\tindex %x\\n\", index);\n#else\n\tbpf_printk(\"\\tdirection %d hwid %x timestamp %u\\n\",\n\t\t   md.u.md2.dir,\n\t\t   (md.u.md2.hwid_upper << 4) + md.u.md2.hwid,\n\t\t   bpf_ntohl(md.u.md2.timestamp));\n#endif\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip4ip6erspan_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tstruct erspan_metadata md;\n\tint ret;\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.remote_ipv6[3] = bpf_htonl(0x11);\n\tkey.tunnel_id = 2;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\t__builtin_memset(&md, 0, sizeof(md));\n\n#ifdef ERSPAN_V1\n\tmd.u.index = bpf_htonl(123);\n\tmd.version = 1;\n#else\n\t__u8 direction = 0;\n\t__u8 hwid = 17;\n\n\tmd.version = 2;\n\tmd.u.md2.dir = direction;\n\tmd.u.md2.hwid = hwid & 0xf;\n\tmd.u.md2.hwid_upper = (hwid >> 4) & 0x3;\n#endif\n\n\tret = bpf_skb_set_tunnel_opt(skb, &md, sizeof(md));\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip4ip6erspan_get_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tstruct erspan_metadata md;\n\tint ret;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tret = bpf_skb_get_tunnel_opt(skb, &md, sizeof(md));\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tbpf_printk(\"ip6erspan get key %d remote ip6 ::%x erspan version %d\\n\",\n\t\t   key.tunnel_id, key.remote_ipv4, md.version);\n\n#ifdef ERSPAN_V1\n\tindex = bpf_ntohl(md.u.index);\n\tbpf_printk(\"\\tindex %x\\n\", index);\n#else\n\tbpf_printk(\"\\tdirection %d hwid %x timestamp %u\\n\",\n\t\t   md.u.md2.dir,\n\t\t   (md.u.md2.hwid_upper << 4) + md.u.md2.hwid,\n\t\t   bpf_ntohl(md.u.md2.timestamp));\n#endif\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint vxlan_set_tunnel_dst(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tstruct vxlan_metadata md;\n\t__u32 index = 0;\n\t__u32 *local_ip = NULL;\n\tint ret = 0;\n\n\tlocal_ip = bpf_map_lookup_elem(&local_ip_map, &index);\n\tif (!local_ip) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.local_ipv4 = 0xac100164;  \n\tkey.remote_ipv4 = *local_ip;\n\tkey.tunnel_id = 2;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_ZERO_CSUM_TX);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tmd.gbp = 0x800FF;  \n\tret = bpf_skb_set_tunnel_opt(skb, &md, sizeof(md));\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint vxlan_set_tunnel_src(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tstruct vxlan_metadata md;\n\t__u32 index = 0;\n\t__u32 *local_ip = NULL;\n\tint ret = 0;\n\n\tlocal_ip = bpf_map_lookup_elem(&local_ip_map, &index);\n\tif (!local_ip) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.local_ipv4 = *local_ip;\n\tkey.remote_ipv4 = 0xac100164;  \n\tkey.tunnel_id = 2;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_ZERO_CSUM_TX);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tmd.gbp = 0x800FF;  \n\tret = bpf_skb_set_tunnel_opt(skb, &md, sizeof(md));\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint vxlan_get_tunnel_src(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key;\n\tstruct vxlan_metadata md;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_FLAGS);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tret = bpf_skb_get_tunnel_opt(skb, &md, sizeof(md));\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tif (key.local_ipv4 != ASSIGNED_ADDR_VETH1 || md.gbp != 0x800FF ||\n\t    !(key.tunnel_flags & TUNNEL_KEY) ||\n\t    (key.tunnel_flags & TUNNEL_CSUM)) {\n\t\tbpf_printk(\"vxlan key %d local ip 0x%x remote ip 0x%x gbp 0x%x flags 0x%x\\n\",\n\t\t\t   key.tunnel_id, key.local_ipv4,\n\t\t\t   key.remote_ipv4, md.gbp,\n\t\t\t   bpf_ntohs(key.tunnel_flags));\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint veth_set_outer_dst(struct __sk_buff *skb)\n{\n\tstruct ethhdr *eth = (struct ethhdr *)(long)skb->data;\n\t__u32 assigned_ip = bpf_htonl(ASSIGNED_ADDR_VETH1);\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tstruct udphdr *udph;\n\tstruct iphdr *iph;\n\tint ret = 0;\n\t__s64 csum;\n\n\tif ((void *)eth + sizeof(*eth) > data_end) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tif (eth->h_proto != bpf_htons(ETH_P_IP))\n\t\treturn TC_ACT_OK;\n\n\tiph = (struct iphdr *)(eth + 1);\n\tif ((void *)iph + sizeof(*iph) > data_end) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\tif (iph->protocol != IPPROTO_UDP)\n\t\treturn TC_ACT_OK;\n\n\tudph = (struct udphdr *)(iph + 1);\n\tif ((void *)udph + sizeof(*udph) > data_end) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\tif (udph->dest != bpf_htons(VXLAN_UDP_PORT))\n\t\treturn TC_ACT_OK;\n\n\tif (iph->daddr != assigned_ip) {\n\t\tcsum = bpf_csum_diff(&iph->daddr, sizeof(__u32), &assigned_ip,\n\t\t\t\t     sizeof(__u32), 0);\n\t\tif (bpf_skb_store_bytes(skb, ETH_HLEN + offsetof(struct iphdr, daddr),\n\t\t\t\t\t&assigned_ip, sizeof(__u32), 0) < 0) {\n\t\t\tlog_err(ret);\n\t\t\treturn TC_ACT_SHOT;\n\t\t}\n\t\tif (bpf_l3_csum_replace(skb, ETH_HLEN + offsetof(struct iphdr, check),\n\t\t\t\t\t0, csum, 0) < 0) {\n\t\t\tlog_err(ret);\n\t\t\treturn TC_ACT_SHOT;\n\t\t}\n\t\tbpf_skb_change_type(skb, PACKET_HOST);\n\t}\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip6vxlan_set_tunnel_dst(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\t__u32 index = 0;\n\t__u32 *local_ip;\n\tint ret = 0;\n\n\tlocal_ip = bpf_map_lookup_elem(&local_ip_map, &index);\n\tif (!local_ip) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.local_ipv6[3] = bpf_htonl(0x11);  \n\tkey.remote_ipv6[3] = bpf_htonl(*local_ip);\n\tkey.tunnel_id = 22;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip6vxlan_set_tunnel_src(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\t__u32 index = 0;\n\t__u32 *local_ip;\n\tint ret = 0;\n\n\tlocal_ip = bpf_map_lookup_elem(&local_ip_map, &index);\n\tif (!local_ip) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.local_ipv6[3] = bpf_htonl(*local_ip);\n\tkey.remote_ipv6[3] = bpf_htonl(0x11);  \n\tkey.tunnel_id = 22;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip6vxlan_get_tunnel_src(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\t__u32 index = 0;\n\t__u32 *local_ip;\n\tint ret = 0;\n\n\tlocal_ip = bpf_map_lookup_elem(&local_ip_map, &index);\n\tif (!local_ip) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6 | BPF_F_TUNINFO_FLAGS);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tif (bpf_ntohl(key.local_ipv6[3]) != *local_ip ||\n\t    !(key.tunnel_flags & TUNNEL_KEY) ||\n\t    !(key.tunnel_flags & TUNNEL_CSUM)) {\n\t\tbpf_printk(\"ip6vxlan key %d local ip6 ::%x remote ip6 ::%x label 0x%x flags 0x%x\\n\",\n\t\t\t   key.tunnel_id, bpf_ntohl(key.local_ipv6[3]),\n\t\t\t   bpf_ntohl(key.remote_ipv6[3]), key.tunnel_label,\n\t\t\t   bpf_ntohs(key.tunnel_flags));\n\t\tbpf_printk(\"local_ip 0x%x\\n\", *local_ip);\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint geneve_set_tunnel(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key;\n\tstruct geneve_opt gopt;\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.remote_ipv4 = 0xac100164;  \n\tkey.tunnel_id = 2;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\n\t__builtin_memset(&gopt, 0x0, sizeof(gopt));\n\tgopt.opt_class = bpf_htons(0x102);  \n\tgopt.type = 0x08;\n\tgopt.r1 = 0;\n\tgopt.r2 = 0;\n\tgopt.r3 = 0;\n\tgopt.length = 2;  \n\t*(int *) &gopt.opt_data = bpf_htonl(0xdeadbeef);\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_ZERO_CSUM_TX);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tret = bpf_skb_set_tunnel_opt(skb, &gopt, sizeof(gopt));\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint geneve_get_tunnel(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key;\n\tstruct geneve_opt gopt;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tret = bpf_skb_get_tunnel_opt(skb, &gopt, sizeof(gopt));\n\tif (ret < 0)\n\t\tgopt.opt_class = 0;\n\n\tbpf_printk(\"key %d remote ip 0x%x geneve class 0x%x\\n\",\n\t\t   key.tunnel_id, key.remote_ipv4, gopt.opt_class);\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip6geneve_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tstruct geneve_opt gopt;\n\tint ret;\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.remote_ipv6[3] = bpf_htonl(0x11);  \n\tkey.tunnel_id = 22;\n\tkey.tunnel_tos = 0;\n\tkey.tunnel_ttl = 64;\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\t__builtin_memset(&gopt, 0x0, sizeof(gopt));\n\tgopt.opt_class = bpf_htons(0x102);  \n\tgopt.type = 0x08;\n\tgopt.r1 = 0;\n\tgopt.r2 = 0;\n\tgopt.r3 = 0;\n\tgopt.length = 2;  \n\t*(int *) &gopt.opt_data = bpf_htonl(0xfeedbeef);\n\n\tret = bpf_skb_set_tunnel_opt(skb, &gopt, sizeof(gopt));\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip6geneve_get_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key;\n\tstruct geneve_opt gopt;\n\tint ret;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tret = bpf_skb_get_tunnel_opt(skb, &gopt, sizeof(gopt));\n\tif (ret < 0)\n\t\tgopt.opt_class = 0;\n\n\tbpf_printk(\"key %d remote ip 0x%x geneve class 0x%x\\n\",\n\t\t   key.tunnel_id, key.remote_ipv4, gopt.opt_class);\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ipip_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct iphdr *iph = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint ret;\n\n\t \n\tif (data + sizeof(*iph) > data_end) {\n\t\tlog_err(1);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tkey.tunnel_ttl = 64;\n\tif (iph->protocol == IPPROTO_ICMP) {\n\t\tkey.remote_ipv4 = 0xac100164;  \n\t}\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ipip_get_tunnel(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tbpf_printk(\"remote ip 0x%x\\n\", key.remote_ipv4);\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ipip_gue_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key = {};\n\tstruct bpf_fou_encap encap = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct iphdr *iph = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint ret;\n\n\tif (data + sizeof(*iph) > data_end) {\n\t\tlog_err(1);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tkey.tunnel_ttl = 64;\n\tif (iph->protocol == IPPROTO_ICMP)\n\t\tkey.remote_ipv4 = 0xac100164;  \n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tencap.sport = 0;\n\tencap.dport = bpf_htons(5555);\n\n\tret = bpf_skb_set_fou_encap(skb, &encap, FOU_BPF_ENCAP_GUE);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ipip_fou_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key = {};\n\tstruct bpf_fou_encap encap = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct iphdr *iph = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint ret;\n\n\tif (data + sizeof(*iph) > data_end) {\n\t\tlog_err(1);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tkey.tunnel_ttl = 64;\n\tif (iph->protocol == IPPROTO_ICMP)\n\t\tkey.remote_ipv4 = 0xac100164;  \n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tencap.sport = 0;\n\tencap.dport = bpf_htons(5555);\n\n\tret = bpf_skb_set_fou_encap(skb, &encap, FOU_BPF_ENCAP_FOU);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ipip_encap_get_tunnel(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key = {};\n\tstruct bpf_fou_encap encap = {};\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tret = bpf_skb_get_fou_encap(skb, &encap);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tif (bpf_ntohs(encap.dport) != 5555)\n\t\treturn TC_ACT_SHOT;\n\n\tbpf_printk(\"%d remote ip 0x%x, sport %d, dport %d\\n\", ret,\n\t\t   key.remote_ipv4, bpf_ntohs(encap.sport),\n\t\t   bpf_ntohs(encap.dport));\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ipip6_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct iphdr *iph = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint ret;\n\n\t \n\tif (data + sizeof(*iph) > data_end) {\n\t\tlog_err(1);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\t__builtin_memset(&key, 0x0, sizeof(key));\n\tkey.tunnel_ttl = 64;\n\tif (iph->protocol == IPPROTO_ICMP) {\n\t\tkey.remote_ipv6[3] = bpf_htonl(0x11);  \n\t}\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ipip6_get_tunnel(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tbpf_printk(\"remote ip6 %x::%x\\n\", bpf_htonl(key.remote_ipv6[0]),\n\t\t   bpf_htonl(key.remote_ipv6[3]));\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip6ip6_set_tunnel(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key key = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct ipv6hdr *iph = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint ret;\n\n\t \n\tif (data + sizeof(*iph) > data_end) {\n\t\tlog_err(1);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tkey.tunnel_ttl = 64;\n\tif (iph->nexthdr == 58  ) {\n\t\tkey.remote_ipv6[3] = bpf_htonl(0x11);  \n\t}\n\n\tret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint ip6ip6_get_tunnel(struct __sk_buff *skb)\n{\n\tint ret;\n\tstruct bpf_tunnel_key key;\n\n\tret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key),\n\t\t\t\t     BPF_F_TUNINFO_IPV6);\n\tif (ret < 0) {\n\t\tlog_err(ret);\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tbpf_printk(\"remote ip6 %x::%x\\n\", bpf_htonl(key.remote_ipv6[0]),\n\t\t   bpf_htonl(key.remote_ipv6[3]));\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint xfrm_get_state(struct __sk_buff *skb)\n{\n\tstruct bpf_xfrm_state x;\n\tint ret;\n\n\tret = bpf_skb_get_xfrm_state(skb, 0, &x, sizeof(x), 0);\n\tif (ret < 0)\n\t\treturn TC_ACT_OK;\n\n\tbpf_printk(\"reqid %d spi 0x%x remote ip 0x%x\\n\",\n\t\t   x.reqid, bpf_ntohl(x.spi),\n\t\t   bpf_ntohl(x.remote_ipv4));\n\treturn TC_ACT_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}