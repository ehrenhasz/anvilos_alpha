{
  "module_name": "test_tcp_estats.c",
  "hash_id": "4349b7288a1b13436f1eb3870b6da0cc9703f3644443a16aafca0c9cf9bd3452",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tcp_estats.c",
  "human_readable_source": " \n\n \n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/ipv6.h>\n#include <linux/version.h>\n#include <sys/socket.h>\n#include <bpf/bpf_helpers.h>\n\n#define _(P) ({typeof(P) val = 0; bpf_probe_read_kernel(&val, sizeof(val), &P); val;})\n#define TCP_ESTATS_MAGIC 0xBAADBEEF\n\n \ntypedef __u32 __bitwise __portpair;\ntypedef __u64 __bitwise __addrpair;\n\nstruct sock_common {\n\tunsigned short\t\tskc_family;\n\tunion {\n\t\t__addrpair\tskc_addrpair;\n\t\tstruct {\n\t\t\t__be32\tskc_daddr;\n\t\t\t__be32\tskc_rcv_saddr;\n\t\t};\n\t};\n\tunion {\n\t\t__portpair\tskc_portpair;\n\t\tstruct {\n\t\t\t__be16\tskc_dport;\n\t\t\t__u16\tskc_num;\n\t\t};\n\t};\n\tstruct in6_addr\t\tskc_v6_daddr;\n\tstruct in6_addr\t\tskc_v6_rcv_saddr;\n};\n\nstruct sock {\n\tstruct sock_common\t__sk_common;\n#define sk_family\t\t__sk_common.skc_family\n#define sk_v6_daddr\t\t__sk_common.skc_v6_daddr\n#define sk_v6_rcv_saddr\t\t__sk_common.skc_v6_rcv_saddr\n};\n\nstruct inet_sock {\n\tstruct sock\t\tsk;\n#define inet_daddr\t\tsk.__sk_common.skc_daddr\n#define inet_dport\t\tsk.__sk_common.skc_dport\n\t__be32\t\t\tinet_saddr;\n\t__be16\t\t\tinet_sport;\n};\n\nstruct pt_regs {\n\tlong di;\n};\n\nstatic inline struct inet_sock *inet_sk(const struct sock *sk)\n{\n\treturn (struct inet_sock *)sk;\n}\n\n \nenum tcp_estats_addrtype {\n\tTCP_ESTATS_ADDRTYPE_IPV4 = 1,\n\tTCP_ESTATS_ADDRTYPE_IPV6 = 2\n};\n\nenum tcp_estats_event_type {\n\tTCP_ESTATS_ESTABLISH,\n\tTCP_ESTATS_PERIODIC,\n\tTCP_ESTATS_TIMEOUT,\n\tTCP_ESTATS_RETRANSMIT_TIMEOUT,\n\tTCP_ESTATS_RETRANSMIT_OTHER,\n\tTCP_ESTATS_SYN_RETRANSMIT,\n\tTCP_ESTATS_SYNACK_RETRANSMIT,\n\tTCP_ESTATS_TERM,\n\tTCP_ESTATS_TX_RESET,\n\tTCP_ESTATS_RX_RESET,\n\tTCP_ESTATS_WRITE_TIMEOUT,\n\tTCP_ESTATS_CONN_TIMEOUT,\n\tTCP_ESTATS_ACK_LATENCY,\n\tTCP_ESTATS_NEVENTS,\n};\n\nstruct tcp_estats_event {\n\tint pid;\n\tint cpu;\n\tunsigned long ts;\n\tunsigned int magic;\n\tenum tcp_estats_event_type event_type;\n};\n\n \nstruct tcp_estats_conn_id {\n\tunsigned int localaddressType;\n\tstruct {\n\t\tunsigned char data[16];\n\t} localaddress;\n\tstruct {\n\t\tunsigned char data[16];\n\t} remaddress;\n\tunsigned short    localport;\n\tunsigned short    remport;\n} __attribute__((__packed__));\n\nstruct tcp_estats_basic_event {\n\tstruct tcp_estats_event event;\n\tstruct tcp_estats_conn_id conn_id;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1024);\n\t__type(key, __u32);\n\t__type(value, struct tcp_estats_basic_event);\n} ev_record_map SEC(\".maps\");\n\nstruct dummy_tracepoint_args {\n\tunsigned long long pad;\n\tstruct sock *sock;\n};\n\nstatic __always_inline void tcp_estats_ev_init(struct tcp_estats_event *event,\n\t\t\t\t\t       enum tcp_estats_event_type type)\n{\n\tevent->magic = TCP_ESTATS_MAGIC;\n\tevent->ts = bpf_ktime_get_ns();\n\tevent->event_type = type;\n}\n\nstatic __always_inline void unaligned_u32_set(unsigned char *to, __u8 *from)\n{\n\tto[0] = _(from[0]);\n\tto[1] = _(from[1]);\n\tto[2] = _(from[2]);\n\tto[3] = _(from[3]);\n}\n\nstatic __always_inline void conn_id_ipv4_init(struct tcp_estats_conn_id *conn_id,\n\t\t\t\t\t      __be32 *saddr, __be32 *daddr)\n{\n\tconn_id->localaddressType = TCP_ESTATS_ADDRTYPE_IPV4;\n\n\tunaligned_u32_set(conn_id->localaddress.data, (__u8 *)saddr);\n\tunaligned_u32_set(conn_id->remaddress.data, (__u8 *)daddr);\n}\n\nstatic __always_inline void conn_id_ipv6_init(struct tcp_estats_conn_id *conn_id,\n\t\t\t\t\t      __be32 *saddr, __be32 *daddr)\n{\n\tconn_id->localaddressType = TCP_ESTATS_ADDRTYPE_IPV6;\n\n\tunaligned_u32_set(conn_id->localaddress.data, (__u8 *)saddr);\n\tunaligned_u32_set(conn_id->localaddress.data + sizeof(__u32),\n\t\t\t  (__u8 *)(saddr + 1));\n\tunaligned_u32_set(conn_id->localaddress.data + sizeof(__u32) * 2,\n\t\t\t  (__u8 *)(saddr + 2));\n\tunaligned_u32_set(conn_id->localaddress.data + sizeof(__u32) * 3,\n\t\t\t  (__u8 *)(saddr + 3));\n\n\tunaligned_u32_set(conn_id->remaddress.data,\n\t\t\t  (__u8 *)(daddr));\n\tunaligned_u32_set(conn_id->remaddress.data + sizeof(__u32),\n\t\t\t  (__u8 *)(daddr + 1));\n\tunaligned_u32_set(conn_id->remaddress.data + sizeof(__u32) * 2,\n\t\t\t  (__u8 *)(daddr + 2));\n\tunaligned_u32_set(conn_id->remaddress.data + sizeof(__u32) * 3,\n\t\t\t  (__u8 *)(daddr + 3));\n}\n\nstatic __always_inline void tcp_estats_conn_id_init(struct tcp_estats_conn_id *conn_id,\n\t\t\t\t\t\t    struct sock *sk)\n{\n\tconn_id->localport = _(inet_sk(sk)->inet_sport);\n\tconn_id->remport = _(inet_sk(sk)->inet_dport);\n\n\tif (_(sk->sk_family) == AF_INET6)\n\t\tconn_id_ipv6_init(conn_id,\n\t\t\t\t  sk->sk_v6_rcv_saddr.s6_addr32,\n\t\t\t\t  sk->sk_v6_daddr.s6_addr32);\n\telse\n\t\tconn_id_ipv4_init(conn_id,\n\t\t\t\t  &inet_sk(sk)->inet_saddr,\n\t\t\t\t  &inet_sk(sk)->inet_daddr);\n}\n\nstatic __always_inline void tcp_estats_init(struct sock *sk,\n\t\t\t\t\t    struct tcp_estats_event *event,\n\t\t\t\t\t    struct tcp_estats_conn_id *conn_id,\n\t\t\t\t\t    enum tcp_estats_event_type type)\n{\n\ttcp_estats_ev_init(event, type);\n\ttcp_estats_conn_id_init(conn_id, sk);\n}\n\nstatic __always_inline void send_basic_event(struct sock *sk,\n\t\t\t\t\t     enum tcp_estats_event_type type)\n{\n\tstruct tcp_estats_basic_event ev;\n\t__u32 key = bpf_get_prandom_u32();\n\n\tmemset(&ev, 0, sizeof(ev));\n\ttcp_estats_init(sk, &ev.event, &ev.conn_id, type);\n\tbpf_map_update_elem(&ev_record_map, &key, &ev, BPF_ANY);\n}\n\nSEC(\"tp/dummy/tracepoint\")\nint _dummy_tracepoint(struct dummy_tracepoint_args *arg)\n{\n\tif (!arg->sock)\n\t\treturn 0;\n\n\tsend_basic_event(arg->sock, TCP_ESTATS_TX_RESET);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}