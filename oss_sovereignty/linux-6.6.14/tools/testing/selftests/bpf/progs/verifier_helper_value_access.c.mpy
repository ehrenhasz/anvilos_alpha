{
  "module_name": "verifier_helper_value_access.c",
  "hash_id": "be21551e3bfd406ef7b1b3283c38aa02f708b96090c3e91442913611d8a0ffca",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_helper_value_access.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nstruct other_val {\n\tlong long foo;\n\tlong long bar;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, struct other_val);\n} map_hash_16b SEC(\".maps\");\n\n#define MAX_ENTRIES 11\n\nstruct test_val {\n\tunsigned int index;\n\tint foo[MAX_ENTRIES];\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, struct test_val);\n} map_hash_48b SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, long long);\n} map_hash_8b SEC(\".maps\");\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: full range\")\n__success\n__naked void access_to_map_full_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = %[sizeof_test_val];\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(sizeof_test_val, sizeof(struct test_val))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: partial range\")\n__success\n__naked void access_to_map_partial_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = 8;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: empty range\")\n__failure __msg(\"invalid access to map value, value_size=48 off=0 size=0\")\n__naked void access_to_map_empty_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_trace_printk];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_trace_printk),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: out-of-bound range\")\n__failure __msg(\"invalid access to map value, value_size=48 off=0 size=56\")\n__naked void map_out_of_bound_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = %[__imm_0];\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) + 8)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: negative range\")\n__failure __msg(\"R2 min value is negative\")\n__naked void access_to_map_negative_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = -8;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const imm): full range\")\n__success\n__naked void via_const_imm_full_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr1 += %[test_val_foo];\t\t\t\t\\\n\tr2 = %[__imm_0];\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) - offsetof(struct test_val, foo)),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const imm): partial range\")\n__success\n__naked void via_const_imm_partial_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr1 += %[test_val_foo];\t\t\t\t\\\n\tr2 = 8;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const imm): empty range\")\n__failure __msg(\"invalid access to map value, value_size=48 off=4 size=0\")\n__naked void via_const_imm_empty_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr1 += %[test_val_foo];\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_trace_printk];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_trace_printk),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const imm): out-of-bound range\")\n__failure __msg(\"invalid access to map value, value_size=48 off=4 size=52\")\n__naked void imm_out_of_bound_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr1 += %[test_val_foo];\t\t\t\t\\\n\tr2 = %[__imm_0];\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) - offsetof(struct test_val, foo) + 8),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const imm): negative range (> adjustment)\")\n__failure __msg(\"R2 min value is negative\")\n__naked void const_imm_negative_range_adjustment_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr1 += %[test_val_foo];\t\t\t\t\\\n\tr2 = -8;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const imm): negative range (< adjustment)\")\n__failure __msg(\"R2 min value is negative\")\n__naked void const_imm_negative_range_adjustment_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr1 += %[test_val_foo];\t\t\t\t\\\n\tr2 = -1;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const reg): full range\")\n__success\n__naked void via_const_reg_full_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = %[test_val_foo];\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = %[__imm_0];\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) - offsetof(struct test_val, foo)),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const reg): partial range\")\n__success\n__naked void via_const_reg_partial_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = %[test_val_foo];\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = 8;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const reg): empty range\")\n__failure __msg(\"R1 min value is outside of the allowed memory range\")\n__naked void via_const_reg_empty_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_trace_printk];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_trace_printk),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const reg): out-of-bound range\")\n__failure __msg(\"invalid access to map value, value_size=48 off=4 size=52\")\n__naked void reg_out_of_bound_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = %[test_val_foo];\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = %[__imm_0];\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) - offsetof(struct test_val, foo) + 8),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const reg): negative range (> adjustment)\")\n__failure __msg(\"R2 min value is negative\")\n__naked void const_reg_negative_range_adjustment_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = %[test_val_foo];\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = -8;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via const reg): negative range (< adjustment)\")\n__failure __msg(\"R2 min value is negative\")\n__naked void const_reg_negative_range_adjustment_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = %[test_val_foo];\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = -1;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via variable): full range\")\n__success\n__naked void map_via_variable_full_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 > %[test_val_foo] goto l0_%=;\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = %[__imm_0];\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) - offsetof(struct test_val, foo)),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via variable): partial range\")\n__success\n__naked void map_via_variable_partial_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 > %[test_val_foo] goto l0_%=;\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = 8;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via variable): empty range\")\n__failure __msg(\"R1 min value is outside of the allowed memory range\")\n__naked void map_via_variable_empty_range(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 > %[test_val_foo] goto l0_%=;\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_trace_printk];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_trace_printk),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via variable): no max check\")\n__failure __msg(\"R1 unbounded memory access\")\n__naked void via_variable_no_max_check_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = 1;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to adjusted map (via variable): wrong max check\")\n__failure __msg(\"invalid access to map value, value_size=48 off=4 size=45\")\n__naked void via_variable_wrong_max_check_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 > %[test_val_foo] goto l0_%=;\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr2 = %[__imm_0];\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) - offsetof(struct test_val, foo) + 1),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using <, good access\")\n__success\n__naked void bounds_check_using_good_access_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 < 32 goto l1_%=;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\nl1_%=:\tr1 += r3;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using <, bad access\")\n__failure __msg(\"R1 unbounded memory access\")\n__naked void bounds_check_using_bad_access_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 < 32 goto l1_%=;\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using <=, good access\")\n__success\n__naked void bounds_check_using_good_access_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 <= 32 goto l1_%=;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\nl1_%=:\tr1 += r3;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using <=, bad access\")\n__failure __msg(\"R1 unbounded memory access\")\n__naked void bounds_check_using_bad_access_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 <= 32 goto l1_%=;\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using s<, good access\")\n__success\n__naked void check_using_s_good_access_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 s< 32 goto l1_%=;\t\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\nl1_%=:\tif r3 s< 0 goto l2_%=;\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using s<, good access 2\")\n__success\n__naked void using_s_good_access_2_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 s< 32 goto l1_%=;\t\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\nl1_%=:\tif r3 s< -3 goto l2_%=;\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using s<, bad access\")\n__failure __msg(\"R1 min value is negative\")\n__naked void check_using_s_bad_access_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tif r3 s< 32 goto l1_%=;\t\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\nl1_%=:\tif r3 s< -3 goto l2_%=;\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using s<=, good access\")\n__success\n__naked void check_using_s_good_access_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 s<= 32 goto l1_%=;\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\nl1_%=:\tif r3 s<= 0 goto l2_%=;\t\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using s<=, good access 2\")\n__success\n__naked void using_s_good_access_2_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 s<= 32 goto l1_%=;\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\nl1_%=:\tif r3 s<= -3 goto l2_%=;\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to map: bounds check using s<=, bad access\")\n__failure __msg(\"R1 min value is negative\")\n__naked void check_using_s_bad_access_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr3 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tif r3 s<= 32 goto l1_%=;\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\nl1_%=:\tif r3 s<= -3 goto l2_%=;\t\t\t\\\n\tr1 += r3;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r1 + 0) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map lookup helper access to map\")\n__success\n__naked void lookup_helper_access_to_map(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map update helper access to map\")\n__success\n__naked void update_helper_access_to_map(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tr3 = r0;\t\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_update_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_map_update_elem),\n\t  __imm_addr(map_hash_16b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map update helper access to map: wrong size\")\n__failure __msg(\"invalid access to map value, value_size=8 off=0 size=16\")\n__naked void access_to_map_wrong_size(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tr3 = r0;\t\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_update_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_map_update_elem),\n\t  __imm_addr(map_hash_16b),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map helper access to adjusted map (via const imm)\")\n__success\n__naked void adjusted_map_via_const_imm(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr2 += %[other_val_bar];\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b),\n\t  __imm_const(other_val_bar, offsetof(struct other_val, bar))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map helper access to adjusted map (via const imm): out-of-bound 1\")\n__failure __msg(\"invalid access to map value, value_size=16 off=12 size=8\")\n__naked void imm_out_of_bound_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr2 += %[__imm_0];\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b),\n\t  __imm_const(__imm_0, sizeof(struct other_val) - 4)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map helper access to adjusted map (via const imm): out-of-bound 2\")\n__failure __msg(\"invalid access to map value, value_size=16 off=-4 size=8\")\n__naked void imm_out_of_bound_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr2 += -4;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map helper access to adjusted map (via const reg)\")\n__success\n__naked void adjusted_map_via_const_reg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr3 = %[other_val_bar];\t\t\t\t\\\n\tr2 += r3;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b),\n\t  __imm_const(other_val_bar, offsetof(struct other_val, bar))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map helper access to adjusted map (via const reg): out-of-bound 1\")\n__failure __msg(\"invalid access to map value, value_size=16 off=12 size=8\")\n__naked void reg_out_of_bound_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr3 = %[__imm_0];\t\t\t\t\\\n\tr2 += r3;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b),\n\t  __imm_const(__imm_0, sizeof(struct other_val) - 4)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map helper access to adjusted map (via const reg): out-of-bound 2\")\n__failure __msg(\"invalid access to map value, value_size=16 off=-4 size=8\")\n__naked void reg_out_of_bound_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr3 = -4;\t\t\t\t\t\\\n\tr2 += r3;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map helper access to adjusted map (via variable)\")\n__success\n__naked void to_adjusted_map_via_variable(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 > %[other_val_bar] goto l0_%=;\t\t\\\n\tr2 += r3;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b),\n\t  __imm_const(other_val_bar, offsetof(struct other_val, bar))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map helper access to adjusted map (via variable): no max check\")\n__failure\n__msg(\"R2 unbounded memory access, make sure to bounds check any such access\")\n__naked void via_variable_no_max_check_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr2 += r3;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"map helper access to adjusted map (via variable): wrong max check\")\n__failure __msg(\"invalid access to map value, value_size=16 off=9 size=8\")\n__naked void via_variable_wrong_max_check_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r0;\t\t\t\t\t\\\n\tr3 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tif r3 > %[__imm_0] goto l0_%=;\t\t\t\\\n\tr2 += r3;\t\t\t\t\t\\\n\tr1 = %[map_hash_16b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_16b),\n\t  __imm_const(__imm_0, offsetof(struct other_val, bar) + 1)\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}