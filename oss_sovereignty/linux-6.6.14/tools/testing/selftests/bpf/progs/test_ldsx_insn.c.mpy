{
  "module_name": "test_ldsx_insn.c",
  "hash_id": "e0192723a09650cdcab9099ef80d038b970c1feeee7a18ab096f6ac85b0e4211",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_ldsx_insn.c",
  "human_readable_source": "\n \n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\n#if (defined(__TARGET_ARCH_arm64) || defined(__TARGET_ARCH_x86) || \\\n     (defined(__TARGET_ARCH_riscv) && __riscv_xlen == 64)) && __clang_major__ >= 18\nconst volatile int skip = 0;\n#else\nconst volatile int skip = 1;\n#endif\n\nvolatile const short val1 = -1;\nvolatile const int val2 = -1;\nshort val3 = -1;\nint val4 = -1;\nint done1, done2, ret1, ret2;\n\nSEC(\"?raw_tp/sys_enter\")\nint rdonly_map_prog(const void *ctx)\n{\n\tif (done1)\n\t\treturn 0;\n\n\tdone1 = 1;\n\t \n\tif (val1 == val2)\n\t\tret1 = 1;\n\treturn 0;\n\n}\n\nSEC(\"?raw_tp/sys_enter\")\nint map_val_prog(const void *ctx)\n{\n\tif (done2)\n\t\treturn 0;\n\n\tdone2 = 1;\n\t \n\tif (val3 == val4)\n\t\tret2 = 1;\n\treturn 0;\n\n}\n\nstruct bpf_testmod_struct_arg_1 {\n\tint a;\n};\n\nlong long int_member;\n\nSEC(\"?fentry/bpf_testmod_test_arg_ptr_to_struct\")\nint BPF_PROG2(test_ptr_struct_arg, struct bpf_testmod_struct_arg_1 *, p)\n{\n\t \n\tint_member = p->a;\n        return 0;\n}\n\nlong long set_optlen, set_retval;\n\nSEC(\"?cgroup/getsockopt\")\nint _getsockopt(volatile struct bpf_sockopt *ctx)\n{\n\tint old_optlen, old_retval;\n\n\told_optlen = ctx->optlen;\n\told_retval = ctx->retval;\n\n\tctx->optlen = -1;\n\tctx->retval = -1;\n\n\t \n\tset_optlen = ctx->optlen;\n\tset_retval = ctx->retval;\n\n\tctx->optlen = old_optlen;\n\tctx->retval = old_retval;\n\n\treturn 0;\n}\n\nlong long set_mark;\n\nSEC(\"?tc\")\nint _tc(volatile struct __sk_buff *skb)\n{\n\tlong long tmp_mark;\n\tint old_mark;\n\n\told_mark = skb->mark;\n\n\tskb->mark = 0xf6fe;\n\n\t \n#if __clang_major__ >= 18\n\t \n\tasm volatile (\"r1 = *(s8 *)(%[ctx] + %[off_mark])\\n\\t\"\n\t\t      \"%[tmp_mark] = r1\"\n\t\t      : [tmp_mark]\"=r\"(tmp_mark)\n\t\t      : [ctx]\"r\"(skb),\n\t\t\t[off_mark]\"i\"(offsetof(struct __sk_buff, mark))\n\t\t      : \"r1\");\n#else\n\ttmp_mark = (char)skb->mark;\n#endif\n\tset_mark = tmp_mark;\n\n\tskb->mark = old_mark;\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}