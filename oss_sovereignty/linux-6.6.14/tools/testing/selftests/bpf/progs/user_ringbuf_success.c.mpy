{
  "module_name": "user_ringbuf_success.c",
  "hash_id": "296c17be2e31f44a5dc6a1ad1ee5c071a6aba0ad1baed46b2039a94970add0f6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/user_ringbuf_success.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n#include \"test_user_ringbuf.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_USER_RINGBUF);\n} user_ringbuf SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_RINGBUF);\n} kernel_ringbuf SEC(\".maps\");\n\n \nint pid, err, val;\n\nint read = 0;\n\n \n__u64 kern_mutated = 0;\n__u64 user_mutated = 0;\n__u64 expected_user_mutated = 0;\n\nstatic int\nis_test_process(void)\n{\n\tint cur_pid = bpf_get_current_pid_tgid() >> 32;\n\n\treturn cur_pid == pid;\n}\n\nstatic long\nrecord_sample(struct bpf_dynptr *dynptr, void *context)\n{\n\tconst struct sample *sample = NULL;\n\tstruct sample stack_sample;\n\tint status;\n\tstatic int num_calls;\n\n\tif (num_calls++ % 2 == 0) {\n\t\tstatus = bpf_dynptr_read(&stack_sample, sizeof(stack_sample), dynptr, 0, 0);\n\t\tif (status) {\n\t\t\tbpf_printk(\"bpf_dynptr_read() failed: %d\\n\", status);\n\t\t\terr = 1;\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tsample = bpf_dynptr_data(dynptr, 0, sizeof(*sample));\n\t\tif (!sample) {\n\t\t\tbpf_printk(\"Unexpectedly failed to get sample\\n\");\n\t\t\terr = 2;\n\t\t\treturn 1;\n\t\t}\n\t\tstack_sample = *sample;\n\t}\n\n\t__sync_fetch_and_add(&read, 1);\n\treturn 0;\n}\n\nstatic void\nhandle_sample_msg(const struct test_msg *msg)\n{\n\tswitch (msg->msg_op) {\n\tcase TEST_MSG_OP_INC64:\n\t\tkern_mutated += msg->operand_64;\n\t\tbreak;\n\tcase TEST_MSG_OP_INC32:\n\t\tkern_mutated += msg->operand_32;\n\t\tbreak;\n\tcase TEST_MSG_OP_MUL64:\n\t\tkern_mutated *= msg->operand_64;\n\t\tbreak;\n\tcase TEST_MSG_OP_MUL32:\n\t\tkern_mutated *= msg->operand_32;\n\t\tbreak;\n\tdefault:\n\t\tbpf_printk(\"Unrecognized op %d\\n\", msg->msg_op);\n\t\terr = 2;\n\t}\n}\n\nstatic long\nread_protocol_msg(struct bpf_dynptr *dynptr, void *context)\n{\n\tconst struct test_msg *msg = NULL;\n\n\tmsg = bpf_dynptr_data(dynptr, 0, sizeof(*msg));\n\tif (!msg) {\n\t\terr = 1;\n\t\tbpf_printk(\"Unexpectedly failed to get msg\\n\");\n\t\treturn 0;\n\t}\n\n\thandle_sample_msg(msg);\n\n\treturn 0;\n}\n\nstatic int publish_next_kern_msg(__u32 index, void *context)\n{\n\tstruct test_msg *msg = NULL;\n\tint operand_64 = TEST_OP_64;\n\tint operand_32 = TEST_OP_32;\n\n\tmsg = bpf_ringbuf_reserve(&kernel_ringbuf, sizeof(*msg), 0);\n\tif (!msg) {\n\t\terr = 4;\n\t\treturn 1;\n\t}\n\n\tswitch (index % TEST_MSG_OP_NUM_OPS) {\n\tcase TEST_MSG_OP_INC64:\n\t\tmsg->operand_64 = operand_64;\n\t\tmsg->msg_op = TEST_MSG_OP_INC64;\n\t\texpected_user_mutated += operand_64;\n\t\tbreak;\n\tcase TEST_MSG_OP_INC32:\n\t\tmsg->operand_32 = operand_32;\n\t\tmsg->msg_op = TEST_MSG_OP_INC32;\n\t\texpected_user_mutated += operand_32;\n\t\tbreak;\n\tcase TEST_MSG_OP_MUL64:\n\t\tmsg->operand_64 = operand_64;\n\t\tmsg->msg_op = TEST_MSG_OP_MUL64;\n\t\texpected_user_mutated *= operand_64;\n\t\tbreak;\n\tcase TEST_MSG_OP_MUL32:\n\t\tmsg->operand_32 = operand_32;\n\t\tmsg->msg_op = TEST_MSG_OP_MUL32;\n\t\texpected_user_mutated *= operand_32;\n\t\tbreak;\n\tdefault:\n\t\tbpf_ringbuf_discard(msg, 0);\n\t\terr = 5;\n\t\treturn 1;\n\t}\n\n\tbpf_ringbuf_submit(msg, 0);\n\n\treturn 0;\n}\n\nstatic void\npublish_kern_messages(void)\n{\n\tif (expected_user_mutated != user_mutated) {\n\t\tbpf_printk(\"%lu != %lu\\n\", expected_user_mutated, user_mutated);\n\t\terr = 3;\n\t\treturn;\n\t}\n\n\tbpf_loop(8, publish_next_kern_msg, NULL, 0);\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_prctl\")\nint test_user_ringbuf_protocol(void *ctx)\n{\n\tlong status = 0;\n\n\tif (!is_test_process())\n\t\treturn 0;\n\n\tstatus = bpf_user_ringbuf_drain(&user_ringbuf, read_protocol_msg, NULL, 0);\n\tif (status < 0) {\n\t\tbpf_printk(\"Drain returned: %ld\\n\", status);\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tpublish_kern_messages();\n\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_getpgid\")\nint test_user_ringbuf(void *ctx)\n{\n\tif (!is_test_process())\n\t\treturn 0;\n\n\terr = bpf_user_ringbuf_drain(&user_ringbuf, record_sample, NULL, 0);\n\n\treturn 0;\n}\n\nstatic long\ndo_nothing_cb(struct bpf_dynptr *dynptr, void *context)\n{\n\t__sync_fetch_and_add(&read, 1);\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_prlimit64\")\nint test_user_ringbuf_epoll(void *ctx)\n{\n\tlong num_samples;\n\n\tif (!is_test_process())\n\t\treturn 0;\n\n\tnum_samples = bpf_user_ringbuf_drain(&user_ringbuf, do_nothing_cb, NULL, 0);\n\tif (num_samples <= 0)\n\t\terr = 1;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}