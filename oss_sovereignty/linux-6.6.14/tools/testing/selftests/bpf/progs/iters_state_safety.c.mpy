{
  "module_name": "iters_state_safety.c",
  "hash_id": "3c1ce9870821b6e32f96f6d525c6834681b251c43562f9ab7fa0e9a03ce0efcd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/iters_state_safety.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n#define ITER_HELPERS\t\t\t\t\t\t\\\n\t  __imm(bpf_iter_num_new),\t\t\t\t\\\n\t  __imm(bpf_iter_num_next),\t\t\t\t\\\n\t  __imm(bpf_iter_num_destroy)\n\nSEC(\"?raw_tp\")\n__success\nint force_clang_to_emit_btf_for_externs(void *ctx)\n{\n\t \n\tbpf_repeat(0);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__success __log_level(2)\n__msg(\"fp-8_w=iter_num(ref_id=1,state=active,depth=0)\")\nint create_and_destroy(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"Unreleased reference id=1\")\nint create_and_forget_to_destroy_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"expected an initialized iter_num as arg #1\")\nint destroy_without_creating_fail(void *ctx)\n{\n\t \n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"expected an initialized iter_num as arg #1\")\nint compromise_iter_w_direct_write_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\n\t\t \n\t\t\"*(u64 *)(%[iter] + 0) = r0;\"\n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"Unreleased reference id=1\")\nint compromise_iter_w_direct_write_and_skip_destroy_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\n\t\t \n\t\t\"*(u64 *)(%[iter] + 0) = r0;\"\n\n\t\t \n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"expected an initialized iter_num as arg #1\")\nint compromise_iter_w_helper_write_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r1 += 7;\"\n\t\t\"r2 = 1;\"\n\t\t\"r3 = 0;\"  \n\t\t\"call %[bpf_probe_read_kernel];\"\n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS, __imm(bpf_probe_read_kernel)\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nstatic __noinline void subprog_with_iter(void)\n{\n\tstruct bpf_iter_num iter;\n\n\tbpf_iter_num_new(&iter, 0, 1);\n\n\treturn;\n}\n\nSEC(\"?raw_tp\")\n__failure\n \n__msg(\"returning from callee:\")\n__msg(\"Unreleased reference id=1\")\nint leak_iter_from_subprog_fail(void *ctx)\n{\n\tsubprog_with_iter();\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__success __log_level(2)\n__msg(\"fp-8_w=iter_num(ref_id=1,state=active,depth=0)\")\nint valid_stack_reuse(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\n\t\t \n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"expected uninitialized iter_num as arg #1\")\nint double_create_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"expected an initialized iter_num as arg #1\")\nint double_destroy_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"expected an initialized iter_num as arg #1\")\nint next_without_new_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_next];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"expected an initialized iter_num as arg #1\")\nint next_after_destroy_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_next];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"invalid read from stack\")\nint __naked read_from_iter_slot_fail(void)\n{\n\tasm volatile (\n\t\t \n\t\t\"r6 = r10;\"\n\t\t\"r6 += -24;\"\n\n\t\t \n\t\t\"r1 = r6;\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\n\t\t \n\t\t\"r7 = *(u64 *)(r6 + 0);\"\n\t\t\"r8 = *(u64 *)(r6 + 8);\"\n\n\t\t \n\t\t\"r1 = r6;\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\n\t\t \n\t\t\"r0 = r7;\"\n\t\t\"if r7 > r8 goto +1;\"\n\t\t\"r0 = r8;\"\n\t\t\"exit;\"\n\t\t:\n\t\t: ITER_HELPERS\n\t\t: __clobber_common, \"r6\", \"r7\", \"r8\"\n\t);\n}\n\nint zero;\n\nSEC(\"?raw_tp\")\n__failure\n__flag(BPF_F_TEST_STATE_FREQ)\n__msg(\"Unreleased reference\")\nint stacksafe_should_not_conflate_stack_spill_and_iter(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"call %[bpf_get_prandom_u32];\"\n\t\t\"r6 = r0;\"\n\t\t\"call %[bpf_get_prandom_u32];\"\n\t\t\"r7 = r0;\"\n\n\t\t\"if r6 > r7 goto bad;\"  \n\n\t\t \n\t\t\"*(u64 *)(%[iter] + 0) = r6;\"\n\n\t\t\"goto skip_bad;\"\n\n\t\"bad:\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\n\t\t \n\t\t\"*(u64 *)(%[iter] + 0) = r6;\"\n\n\t\"skip_bad:\"\n\t\t\"goto +0;\"  \n\n\t\t \n\t\t\"*(u64 *)(%[iter] + 0) = r6;\"\n\t\t:\n\t\t: __imm_ptr(iter),\n\t\t  __imm_addr(zero),\n\t\t  __imm(bpf_get_prandom_u32),\n\t\t  __imm(bpf_dynptr_from_mem),\n\t\t  ITER_HELPERS\n\t\t: __clobber_common, \"r6\", \"r7\"\n\t);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}