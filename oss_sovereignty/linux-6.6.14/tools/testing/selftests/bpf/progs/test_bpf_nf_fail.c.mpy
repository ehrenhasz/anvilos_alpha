{
  "module_name": "test_bpf_nf_fail.c",
  "hash_id": "22160c1955120efd793a11296c5e448721f4faca2b4dbefa86cbac6a90eeb69c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_bpf_nf_fail.c",
  "human_readable_source": "\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n\nstruct nf_conn;\n\nstruct bpf_ct_opts___local {\n\ts32 netns_id;\n\ts32 error;\n\tu8 l4proto;\n\tu8 reserved[3];\n} __attribute__((preserve_access_index));\n\nstruct nf_conn *bpf_skb_ct_alloc(struct __sk_buff *, struct bpf_sock_tuple *, u32,\n\t\t\t\t struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_skb_ct_lookup(struct __sk_buff *, struct bpf_sock_tuple *, u32,\n\t\t\t\t  struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_ct_insert_entry(struct nf_conn *) __ksym;\nvoid bpf_ct_release(struct nf_conn *) __ksym;\nvoid bpf_ct_set_timeout(struct nf_conn *, u32) __ksym;\nint bpf_ct_change_timeout(struct nf_conn *, u32) __ksym;\nint bpf_ct_set_status(struct nf_conn *, u32) __ksym;\nint bpf_ct_change_status(struct nf_conn *, u32) __ksym;\n\nSEC(\"?tc\")\nint alloc_release(struct __sk_buff *ctx)\n{\n\tstruct bpf_ct_opts___local opts = {};\n\tstruct bpf_sock_tuple tup = {};\n\tstruct nf_conn *ct;\n\n\tct = bpf_skb_ct_alloc(ctx, &tup, sizeof(tup.ipv4), &opts, sizeof(opts));\n\tif (!ct)\n\t\treturn 0;\n\tbpf_ct_release(ct);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint insert_insert(struct __sk_buff *ctx)\n{\n\tstruct bpf_ct_opts___local opts = {};\n\tstruct bpf_sock_tuple tup = {};\n\tstruct nf_conn *ct;\n\n\tct = bpf_skb_ct_alloc(ctx, &tup, sizeof(tup.ipv4), &opts, sizeof(opts));\n\tif (!ct)\n\t\treturn 0;\n\tct = bpf_ct_insert_entry(ct);\n\tif (!ct)\n\t\treturn 0;\n\tct = bpf_ct_insert_entry(ct);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint lookup_insert(struct __sk_buff *ctx)\n{\n\tstruct bpf_ct_opts___local opts = {};\n\tstruct bpf_sock_tuple tup = {};\n\tstruct nf_conn *ct;\n\n\tct = bpf_skb_ct_lookup(ctx, &tup, sizeof(tup.ipv4), &opts, sizeof(opts));\n\tif (!ct)\n\t\treturn 0;\n\tbpf_ct_insert_entry(ct);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint write_not_allowlisted_field(struct __sk_buff *ctx)\n{\n\tstruct bpf_ct_opts___local opts = {};\n\tstruct bpf_sock_tuple tup = {};\n\tstruct nf_conn *ct;\n\n\tct = bpf_skb_ct_lookup(ctx, &tup, sizeof(tup.ipv4), &opts, sizeof(opts));\n\tif (!ct)\n\t\treturn 0;\n\tct->status = 0xF00;\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint set_timeout_after_insert(struct __sk_buff *ctx)\n{\n\tstruct bpf_ct_opts___local opts = {};\n\tstruct bpf_sock_tuple tup = {};\n\tstruct nf_conn *ct;\n\n\tct = bpf_skb_ct_alloc(ctx, &tup, sizeof(tup.ipv4), &opts, sizeof(opts));\n\tif (!ct)\n\t\treturn 0;\n\tct = bpf_ct_insert_entry(ct);\n\tif (!ct)\n\t\treturn 0;\n\tbpf_ct_set_timeout(ct, 0);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint set_status_after_insert(struct __sk_buff *ctx)\n{\n\tstruct bpf_ct_opts___local opts = {};\n\tstruct bpf_sock_tuple tup = {};\n\tstruct nf_conn *ct;\n\n\tct = bpf_skb_ct_alloc(ctx, &tup, sizeof(tup.ipv4), &opts, sizeof(opts));\n\tif (!ct)\n\t\treturn 0;\n\tct = bpf_ct_insert_entry(ct);\n\tif (!ct)\n\t\treturn 0;\n\tbpf_ct_set_status(ct, 0);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint change_timeout_after_alloc(struct __sk_buff *ctx)\n{\n\tstruct bpf_ct_opts___local opts = {};\n\tstruct bpf_sock_tuple tup = {};\n\tstruct nf_conn *ct;\n\n\tct = bpf_skb_ct_alloc(ctx, &tup, sizeof(tup.ipv4), &opts, sizeof(opts));\n\tif (!ct)\n\t\treturn 0;\n\tbpf_ct_change_timeout(ct, 0);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint change_status_after_alloc(struct __sk_buff *ctx)\n{\n\tstruct bpf_ct_opts___local opts = {};\n\tstruct bpf_sock_tuple tup = {};\n\tstruct nf_conn *ct;\n\n\tct = bpf_skb_ct_alloc(ctx, &tup, sizeof(tup.ipv4), &opts, sizeof(opts));\n\tif (!ct)\n\t\treturn 0;\n\tbpf_ct_change_status(ct, 0);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}