{
  "module_name": "test_sk_lookup.c",
  "hash_id": "9bdd02acc6a7b5acd7166a240def8cfc0b32679e400ff9d2e7186b5c64397249",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_sk_lookup.c",
  "human_readable_source": "\n\n\n#include <errno.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <linux/bpf.h>\n#include <linux/in.h>\n#include <sys/socket.h>\n\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_helpers.h>\n\n#define IP4(a, b, c, d)\t\t\t\t\t\\\n\tbpf_htonl((((__u32)(a) & 0xffU) << 24) |\t\\\n\t\t  (((__u32)(b) & 0xffU) << 16) |\t\\\n\t\t  (((__u32)(c) & 0xffU) <<  8) |\t\\\n\t\t  (((__u32)(d) & 0xffU) <<  0))\n#define IP6(aaaa, bbbb, cccc, dddd)\t\t\t\\\n\t{ bpf_htonl(aaaa), bpf_htonl(bbbb), bpf_htonl(cccc), bpf_htonl(dddd) }\n\n \n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#define LSE_INDEX(index, size) (index)\n#else\n#define LSE_INDEX(index, size) ((size) - (index) - 1)\n#endif\n#define LSB(value, index)\t\t\t\t\\\n\t(((__u8 *)&(value))[LSE_INDEX((index), sizeof(value))])\n#define LSW(value, index)\t\t\t\t\\\n\t(((__u16 *)&(value))[LSE_INDEX((index), sizeof(value) / 2)])\n\n#define MAX_SOCKS 32\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKMAP);\n\t__uint(max_entries, MAX_SOCKS);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} redir_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 2);\n\t__type(key, int);\n\t__type(value, int);\n} run_map SEC(\".maps\");\n\nenum {\n\tPROG1 = 0,\n\tPROG2,\n};\n\nenum {\n\tSERVER_A = 0,\n\tSERVER_B,\n};\n\n \nstatic const int KEY_PROG1 = PROG1;\nstatic const int KEY_PROG2 = PROG2;\nstatic const int PROG_DONE = 1;\n\nstatic const __u32 KEY_SERVER_A = SERVER_A;\nstatic const __u32 KEY_SERVER_B = SERVER_B;\n\nstatic const __u16 SRC_PORT = bpf_htons(8008);\nstatic const __u32 SRC_IP4 = IP4(127, 0, 0, 2);\nstatic const __u32 SRC_IP6[] = IP6(0xfd000000, 0x0, 0x0, 0x00000002);\n\nstatic const __u16 DST_PORT = 7007;  \nstatic const __u32 DST_IP4 = IP4(127, 0, 0, 1);\nstatic const __u32 DST_IP6[] = IP6(0xfd000000, 0x0, 0x0, 0x00000001);\n\nSEC(\"sk_lookup\")\nint lookup_pass(struct bpf_sk_lookup *ctx)\n{\n\treturn SK_PASS;\n}\n\nSEC(\"sk_lookup\")\nint lookup_drop(struct bpf_sk_lookup *ctx)\n{\n\treturn SK_DROP;\n}\n\nSEC(\"sk_lookup\")\nint check_ifindex(struct bpf_sk_lookup *ctx)\n{\n\tif (ctx->ingress_ifindex == 1)\n\t\treturn SK_DROP;\n\treturn SK_PASS;\n}\n\nSEC(\"sk_reuseport\")\nint reuseport_pass(struct sk_reuseport_md *ctx)\n{\n\treturn SK_PASS;\n}\n\nSEC(\"sk_reuseport\")\nint reuseport_drop(struct sk_reuseport_md *ctx)\n{\n\treturn SK_DROP;\n}\n\n \nSEC(\"sk_lookup\")\nint redir_port(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err;\n\n\tif (ctx->local_port != DST_PORT)\n\t\treturn SK_PASS;\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\treturn SK_PASS;\n\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tbpf_sk_release(sk);\n\treturn err ? SK_DROP : SK_PASS;\n}\n\n \nSEC(\"sk_lookup\")\nint redir_ip4(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err;\n\n\tif (ctx->family != AF_INET)\n\t\treturn SK_PASS;\n\tif (ctx->local_port != DST_PORT)\n\t\treturn SK_PASS;\n\tif (ctx->local_ip4 != DST_IP4)\n\t\treturn SK_PASS;\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\treturn SK_PASS;\n\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tbpf_sk_release(sk);\n\treturn err ? SK_DROP : SK_PASS;\n}\n\n \nSEC(\"sk_lookup\")\nint redir_ip6(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err;\n\n\tif (ctx->family != AF_INET6)\n\t\treturn SK_PASS;\n\tif (ctx->local_port != DST_PORT)\n\t\treturn SK_PASS;\n\tif (ctx->local_ip6[0] != DST_IP6[0] ||\n\t    ctx->local_ip6[1] != DST_IP6[1] ||\n\t    ctx->local_ip6[2] != DST_IP6[2] ||\n\t    ctx->local_ip6[3] != DST_IP6[3])\n\t\treturn SK_PASS;\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\treturn SK_PASS;\n\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tbpf_sk_release(sk);\n\treturn err ? SK_DROP : SK_PASS;\n}\n\nSEC(\"sk_lookup\")\nint select_sock_a(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err;\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\treturn SK_PASS;\n\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tbpf_sk_release(sk);\n\treturn err ? SK_DROP : SK_PASS;\n}\n\nSEC(\"sk_lookup\")\nint select_sock_a_no_reuseport(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err;\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\treturn SK_DROP;\n\n\terr = bpf_sk_assign(ctx, sk, BPF_SK_LOOKUP_F_NO_REUSEPORT);\n\tbpf_sk_release(sk);\n\treturn err ? SK_DROP : SK_PASS;\n}\n\nSEC(\"sk_reuseport\")\nint select_sock_b(struct sk_reuseport_md *ctx)\n{\n\t__u32 key = KEY_SERVER_B;\n\tint err;\n\n\terr = bpf_sk_select_reuseport(ctx, &redir_map, &key, 0);\n\treturn err ? SK_DROP : SK_PASS;\n}\n\n \nSEC(\"sk_lookup\")\nint sk_assign_eexist(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err, ret;\n\n\tret = SK_DROP;\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_B);\n\tif (!sk)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tif (err)\n\t\tgoto out;\n\tbpf_sk_release(sk);\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tif (err != -EEXIST) {\n\t\tbpf_printk(\"sk_assign returned %d, expected %d\\n\",\n\t\t\t   err, -EEXIST);\n\t\tgoto out;\n\t}\n\n\tret = SK_PASS;  \nout:\n\tif (sk)\n\t\tbpf_sk_release(sk);\n\treturn ret;\n}\n\n \nSEC(\"sk_lookup\")\nint sk_assign_replace_flag(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err, ret;\n\n\tret = SK_DROP;\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tif (err)\n\t\tgoto out;\n\tbpf_sk_release(sk);\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_B);\n\tif (!sk)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, sk, BPF_SK_LOOKUP_F_REPLACE);\n\tif (err) {\n\t\tbpf_printk(\"sk_assign returned %d, expected 0\\n\", err);\n\t\tgoto out;\n\t}\n\n\tret = SK_PASS;  \nout:\n\tif (sk)\n\t\tbpf_sk_release(sk);\n\treturn ret;\n}\n\n \nSEC(\"sk_lookup\")\nint sk_assign_null(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk = NULL;\n\tint err, ret;\n\n\tret = SK_DROP;\n\n\terr = bpf_sk_assign(ctx, NULL, 0);\n\tif (err) {\n\t\tbpf_printk(\"sk_assign returned %d, expected 0\\n\", err);\n\t\tgoto out;\n\t}\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_B);\n\tif (!sk)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, sk, BPF_SK_LOOKUP_F_REPLACE);\n\tif (err) {\n\t\tbpf_printk(\"sk_assign returned %d, expected 0\\n\", err);\n\t\tgoto out;\n\t}\n\n\tif (ctx->sk != sk)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, NULL, 0);\n\tif (err != -EEXIST)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, NULL, BPF_SK_LOOKUP_F_REPLACE);\n\tif (err)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, sk, BPF_SK_LOOKUP_F_REPLACE);\n\tif (err)\n\t\tgoto out;\n\n\tret = SK_PASS;  \nout:\n\tif (sk)\n\t\tbpf_sk_release(sk);\n\treturn ret;\n}\n\n \nSEC(\"sk_lookup\")\nint access_ctx_sk(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk1 = NULL, *sk2 = NULL;\n\tint err, ret;\n\n\tret = SK_DROP;\n\n\t \n\tif (ctx->sk && ctx->sk->family != AF_INET)\n\t\tgoto out;\n\n\t \n\tsk1 = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk1)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, sk1, 0);\n\tif (err)\n\t\tgoto out;\n\tif (ctx->sk != sk1)\n\t\tgoto out;\n\n\t \n\tif (ctx->sk->family != AF_INET ||\n\t    ctx->sk->type != SOCK_STREAM ||\n\t    ctx->sk->state != BPF_TCP_LISTEN)\n\t\tgoto out;\n\n\t \n\terr = bpf_sk_assign(ctx, NULL, BPF_SK_LOOKUP_F_REPLACE);\n\tif (err)\n\t\tgoto out;\n\tif (ctx->sk)\n\t\tgoto out;\n\n\t \n\tsk2 = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_B);\n\tif (!sk2)\n\t\tgoto out;\n\terr = bpf_sk_assign(ctx, sk2, BPF_SK_LOOKUP_F_REPLACE);\n\tif (err)\n\t\tgoto out;\n\tif (ctx->sk != sk2)\n\t\tgoto out;\n\n\t \n\tif (ctx->sk->family != AF_INET ||\n\t    ctx->sk->type != SOCK_STREAM ||\n\t    ctx->sk->state != BPF_TCP_LISTEN)\n\t\tgoto out;\n\n\tret = SK_PASS;  \nout:\n\tif (sk1)\n\t\tbpf_sk_release(sk1);\n\tif (sk2)\n\t\tbpf_sk_release(sk2);\n\treturn ret;\n}\n\n \nSEC(\"sk_lookup\")\nint ctx_narrow_access(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\t__u32 val_u32;\n\tbool v4;\n\n\tv4 = (ctx->family == AF_INET);\n\n\t \n\tif (LSB(ctx->family, 0) != (v4 ? AF_INET : AF_INET6) ||\n\t    LSB(ctx->family, 1) != 0 || LSB(ctx->family, 2) != 0 || LSB(ctx->family, 3) != 0)\n\t\treturn SK_DROP;\n\tif (LSW(ctx->family, 0) != (v4 ? AF_INET : AF_INET6))\n\t\treturn SK_DROP;\n\n\t \n\tif (LSB(ctx->protocol, 0) != IPPROTO_TCP ||\n\t    LSB(ctx->protocol, 1) != 0 || LSB(ctx->protocol, 2) != 0 || LSB(ctx->protocol, 3) != 0)\n\t\treturn SK_DROP;\n\tif (LSW(ctx->protocol, 0) != IPPROTO_TCP)\n\t\treturn SK_DROP;\n\n\t \n\tif (LSB(ctx->remote_port, 0) != ((SRC_PORT >> 0) & 0xff) ||\n\t    LSB(ctx->remote_port, 1) != ((SRC_PORT >> 8) & 0xff))\n\t\treturn SK_DROP;\n\tif (LSW(ctx->remote_port, 0) != SRC_PORT)\n\t\treturn SK_DROP;\n\n\t \n\tval_u32 = *(__u32 *)&ctx->remote_port;\n\tif (val_u32 != SRC_PORT)\n\t\treturn SK_DROP;\n\n\t \n\tif (LSB(ctx->local_port, 0) != ((DST_PORT >> 0) & 0xff) ||\n\t    LSB(ctx->local_port, 1) != ((DST_PORT >> 8) & 0xff) ||\n\t    LSB(ctx->local_port, 2) != 0 || LSB(ctx->local_port, 3) != 0)\n\t\treturn SK_DROP;\n\tif (LSW(ctx->local_port, 0) != DST_PORT)\n\t\treturn SK_DROP;\n\n\t \n\tif (v4) {\n\t\t \n\t\tif (LSB(ctx->remote_ip4, 0) != ((SRC_IP4 >> 0) & 0xff) ||\n\t\t    LSB(ctx->remote_ip4, 1) != ((SRC_IP4 >> 8) & 0xff) ||\n\t\t    LSB(ctx->remote_ip4, 2) != ((SRC_IP4 >> 16) & 0xff) ||\n\t\t    LSB(ctx->remote_ip4, 3) != ((SRC_IP4 >> 24) & 0xff))\n\t\t\treturn SK_DROP;\n\t\tif (LSW(ctx->remote_ip4, 0) != ((SRC_IP4 >> 0) & 0xffff) ||\n\t\t    LSW(ctx->remote_ip4, 1) != ((SRC_IP4 >> 16) & 0xffff))\n\t\t\treturn SK_DROP;\n\n\t\t \n\t\tif (LSB(ctx->local_ip4, 0) != ((DST_IP4 >> 0) & 0xff) ||\n\t\t    LSB(ctx->local_ip4, 1) != ((DST_IP4 >> 8) & 0xff) ||\n\t\t    LSB(ctx->local_ip4, 2) != ((DST_IP4 >> 16) & 0xff) ||\n\t\t    LSB(ctx->local_ip4, 3) != ((DST_IP4 >> 24) & 0xff))\n\t\t\treturn SK_DROP;\n\t\tif (LSW(ctx->local_ip4, 0) != ((DST_IP4 >> 0) & 0xffff) ||\n\t\t    LSW(ctx->local_ip4, 1) != ((DST_IP4 >> 16) & 0xffff))\n\t\t\treturn SK_DROP;\n\t} else {\n\t\t \n\t\tif (LSB(ctx->remote_ip4, 0) != 0 || LSB(ctx->remote_ip4, 1) != 0 ||\n\t\t    LSB(ctx->remote_ip4, 2) != 0 || LSB(ctx->remote_ip4, 3) != 0)\n\t\t\treturn SK_DROP;\n\t\tif (LSW(ctx->remote_ip4, 0) != 0 || LSW(ctx->remote_ip4, 1) != 0)\n\t\t\treturn SK_DROP;\n\n\t\tif (LSB(ctx->local_ip4, 0) != 0 || LSB(ctx->local_ip4, 1) != 0 ||\n\t\t    LSB(ctx->local_ip4, 2) != 0 || LSB(ctx->local_ip4, 3) != 0)\n\t\t\treturn SK_DROP;\n\t\tif (LSW(ctx->local_ip4, 0) != 0 || LSW(ctx->local_ip4, 1) != 0)\n\t\t\treturn SK_DROP;\n\t}\n\n\t \n\tif (!v4) {\n\t\t \n\t\tif (LSB(ctx->remote_ip6[0], 0) != ((SRC_IP6[0] >> 0) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[0], 1) != ((SRC_IP6[0] >> 8) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[0], 2) != ((SRC_IP6[0] >> 16) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[0], 3) != ((SRC_IP6[0] >> 24) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[1], 0) != ((SRC_IP6[1] >> 0) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[1], 1) != ((SRC_IP6[1] >> 8) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[1], 2) != ((SRC_IP6[1] >> 16) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[1], 3) != ((SRC_IP6[1] >> 24) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[2], 0) != ((SRC_IP6[2] >> 0) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[2], 1) != ((SRC_IP6[2] >> 8) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[2], 2) != ((SRC_IP6[2] >> 16) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[2], 3) != ((SRC_IP6[2] >> 24) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[3], 0) != ((SRC_IP6[3] >> 0) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[3], 1) != ((SRC_IP6[3] >> 8) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[3], 2) != ((SRC_IP6[3] >> 16) & 0xff) ||\n\t\t    LSB(ctx->remote_ip6[3], 3) != ((SRC_IP6[3] >> 24) & 0xff))\n\t\t\treturn SK_DROP;\n\t\tif (LSW(ctx->remote_ip6[0], 0) != ((SRC_IP6[0] >> 0) & 0xffff) ||\n\t\t    LSW(ctx->remote_ip6[0], 1) != ((SRC_IP6[0] >> 16) & 0xffff) ||\n\t\t    LSW(ctx->remote_ip6[1], 0) != ((SRC_IP6[1] >> 0) & 0xffff) ||\n\t\t    LSW(ctx->remote_ip6[1], 1) != ((SRC_IP6[1] >> 16) & 0xffff) ||\n\t\t    LSW(ctx->remote_ip6[2], 0) != ((SRC_IP6[2] >> 0) & 0xffff) ||\n\t\t    LSW(ctx->remote_ip6[2], 1) != ((SRC_IP6[2] >> 16) & 0xffff) ||\n\t\t    LSW(ctx->remote_ip6[3], 0) != ((SRC_IP6[3] >> 0) & 0xffff) ||\n\t\t    LSW(ctx->remote_ip6[3], 1) != ((SRC_IP6[3] >> 16) & 0xffff))\n\t\t\treturn SK_DROP;\n\t\t \n\t\tif (LSB(ctx->local_ip6[0], 0) != ((DST_IP6[0] >> 0) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[0], 1) != ((DST_IP6[0] >> 8) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[0], 2) != ((DST_IP6[0] >> 16) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[0], 3) != ((DST_IP6[0] >> 24) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[1], 0) != ((DST_IP6[1] >> 0) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[1], 1) != ((DST_IP6[1] >> 8) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[1], 2) != ((DST_IP6[1] >> 16) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[1], 3) != ((DST_IP6[1] >> 24) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[2], 0) != ((DST_IP6[2] >> 0) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[2], 1) != ((DST_IP6[2] >> 8) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[2], 2) != ((DST_IP6[2] >> 16) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[2], 3) != ((DST_IP6[2] >> 24) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[3], 0) != ((DST_IP6[3] >> 0) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[3], 1) != ((DST_IP6[3] >> 8) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[3], 2) != ((DST_IP6[3] >> 16) & 0xff) ||\n\t\t    LSB(ctx->local_ip6[3], 3) != ((DST_IP6[3] >> 24) & 0xff))\n\t\t\treturn SK_DROP;\n\t\tif (LSW(ctx->local_ip6[0], 0) != ((DST_IP6[0] >> 0) & 0xffff) ||\n\t\t    LSW(ctx->local_ip6[0], 1) != ((DST_IP6[0] >> 16) & 0xffff) ||\n\t\t    LSW(ctx->local_ip6[1], 0) != ((DST_IP6[1] >> 0) & 0xffff) ||\n\t\t    LSW(ctx->local_ip6[1], 1) != ((DST_IP6[1] >> 16) & 0xffff) ||\n\t\t    LSW(ctx->local_ip6[2], 0) != ((DST_IP6[2] >> 0) & 0xffff) ||\n\t\t    LSW(ctx->local_ip6[2], 1) != ((DST_IP6[2] >> 16) & 0xffff) ||\n\t\t    LSW(ctx->local_ip6[3], 0) != ((DST_IP6[3] >> 0) & 0xffff) ||\n\t\t    LSW(ctx->local_ip6[3], 1) != ((DST_IP6[3] >> 16) & 0xffff))\n\t\t\treturn SK_DROP;\n\t} else {\n\t\t \n\t\tif (LSB(ctx->remote_ip6[0], 0) != 0 || LSB(ctx->remote_ip6[0], 1) != 0 ||\n\t\t    LSB(ctx->remote_ip6[0], 2) != 0 || LSB(ctx->remote_ip6[0], 3) != 0 ||\n\t\t    LSB(ctx->remote_ip6[1], 0) != 0 || LSB(ctx->remote_ip6[1], 1) != 0 ||\n\t\t    LSB(ctx->remote_ip6[1], 2) != 0 || LSB(ctx->remote_ip6[1], 3) != 0 ||\n\t\t    LSB(ctx->remote_ip6[2], 0) != 0 || LSB(ctx->remote_ip6[2], 1) != 0 ||\n\t\t    LSB(ctx->remote_ip6[2], 2) != 0 || LSB(ctx->remote_ip6[2], 3) != 0 ||\n\t\t    LSB(ctx->remote_ip6[3], 0) != 0 || LSB(ctx->remote_ip6[3], 1) != 0 ||\n\t\t    LSB(ctx->remote_ip6[3], 2) != 0 || LSB(ctx->remote_ip6[3], 3) != 0)\n\t\t\treturn SK_DROP;\n\t\tif (LSW(ctx->remote_ip6[0], 0) != 0 || LSW(ctx->remote_ip6[0], 1) != 0 ||\n\t\t    LSW(ctx->remote_ip6[1], 0) != 0 || LSW(ctx->remote_ip6[1], 1) != 0 ||\n\t\t    LSW(ctx->remote_ip6[2], 0) != 0 || LSW(ctx->remote_ip6[2], 1) != 0 ||\n\t\t    LSW(ctx->remote_ip6[3], 0) != 0 || LSW(ctx->remote_ip6[3], 1) != 0)\n\t\t\treturn SK_DROP;\n\n\t\tif (LSB(ctx->local_ip6[0], 0) != 0 || LSB(ctx->local_ip6[0], 1) != 0 ||\n\t\t    LSB(ctx->local_ip6[0], 2) != 0 || LSB(ctx->local_ip6[0], 3) != 0 ||\n\t\t    LSB(ctx->local_ip6[1], 0) != 0 || LSB(ctx->local_ip6[1], 1) != 0 ||\n\t\t    LSB(ctx->local_ip6[1], 2) != 0 || LSB(ctx->local_ip6[1], 3) != 0 ||\n\t\t    LSB(ctx->local_ip6[2], 0) != 0 || LSB(ctx->local_ip6[2], 1) != 0 ||\n\t\t    LSB(ctx->local_ip6[2], 2) != 0 || LSB(ctx->local_ip6[2], 3) != 0 ||\n\t\t    LSB(ctx->local_ip6[3], 0) != 0 || LSB(ctx->local_ip6[3], 1) != 0 ||\n\t\t    LSB(ctx->local_ip6[3], 2) != 0 || LSB(ctx->local_ip6[3], 3) != 0)\n\t\t\treturn SK_DROP;\n\t\tif (LSW(ctx->remote_ip6[0], 0) != 0 || LSW(ctx->remote_ip6[0], 1) != 0 ||\n\t\t    LSW(ctx->remote_ip6[1], 0) != 0 || LSW(ctx->remote_ip6[1], 1) != 0 ||\n\t\t    LSW(ctx->remote_ip6[2], 0) != 0 || LSW(ctx->remote_ip6[2], 1) != 0 ||\n\t\t    LSW(ctx->remote_ip6[3], 0) != 0 || LSW(ctx->remote_ip6[3], 1) != 0)\n\t\t\treturn SK_DROP;\n\t}\n\n\t \n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_B);\n\tif (sk) {\n\t\tbpf_sk_assign(ctx, sk, 0);\n\t\tbpf_sk_release(sk);\n\t}\n\treturn SK_PASS;\n}\n\n \nSEC(\"sk_lookup\")\nint sk_assign_esocknosupport(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err, ret;\n\n\tret = SK_DROP;\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\tgoto out;\n\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tif (err != -ESOCKTNOSUPPORT) {\n\t\tbpf_printk(\"sk_assign returned %d, expected %d\\n\",\n\t\t\t   err, -ESOCKTNOSUPPORT);\n\t\tgoto out;\n\t}\n\n\tret = SK_PASS;  \nout:\n\tif (sk)\n\t\tbpf_sk_release(sk);\n\treturn ret;\n}\n\nSEC(\"sk_lookup\")\nint multi_prog_pass1(struct bpf_sk_lookup *ctx)\n{\n\tbpf_map_update_elem(&run_map, &KEY_PROG1, &PROG_DONE, BPF_ANY);\n\treturn SK_PASS;\n}\n\nSEC(\"sk_lookup\")\nint multi_prog_pass2(struct bpf_sk_lookup *ctx)\n{\n\tbpf_map_update_elem(&run_map, &KEY_PROG2, &PROG_DONE, BPF_ANY);\n\treturn SK_PASS;\n}\n\nSEC(\"sk_lookup\")\nint multi_prog_drop1(struct bpf_sk_lookup *ctx)\n{\n\tbpf_map_update_elem(&run_map, &KEY_PROG1, &PROG_DONE, BPF_ANY);\n\treturn SK_DROP;\n}\n\nSEC(\"sk_lookup\")\nint multi_prog_drop2(struct bpf_sk_lookup *ctx)\n{\n\tbpf_map_update_elem(&run_map, &KEY_PROG2, &PROG_DONE, BPF_ANY);\n\treturn SK_DROP;\n}\n\nstatic __always_inline int select_server_a(struct bpf_sk_lookup *ctx)\n{\n\tstruct bpf_sock *sk;\n\tint err;\n\n\tsk = bpf_map_lookup_elem(&redir_map, &KEY_SERVER_A);\n\tif (!sk)\n\t\treturn SK_DROP;\n\n\terr = bpf_sk_assign(ctx, sk, 0);\n\tbpf_sk_release(sk);\n\tif (err)\n\t\treturn SK_DROP;\n\n\treturn SK_PASS;\n}\n\nSEC(\"sk_lookup\")\nint multi_prog_redir1(struct bpf_sk_lookup *ctx)\n{\n\t(void)select_server_a(ctx);\n\tbpf_map_update_elem(&run_map, &KEY_PROG1, &PROG_DONE, BPF_ANY);\n\treturn SK_PASS;\n}\n\nSEC(\"sk_lookup\")\nint multi_prog_redir2(struct bpf_sk_lookup *ctx)\n{\n\t(void)select_server_a(ctx);\n\tbpf_map_update_elem(&run_map, &KEY_PROG2, &PROG_DONE, BPF_ANY);\n\treturn SK_PASS;\n}\n\nchar _license[] SEC(\"license\") = \"Dual BSD/GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}