{
  "module_name": "kfree_skb.c",
  "hash_id": "5a6d19cd08fc7695c9556a20180f3ab64c8683970c9dfd2f25f0aa1209bbab77",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/kfree_skb.c",
  "human_readable_source": "\n\n#include <linux/bpf.h>\n#include <stdbool.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_tracing.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n\t__type(key, int);\n\t__type(value, int);\n} perf_buf_map SEC(\".maps\");\n\n#define _(P) (__builtin_preserve_access_index(P))\n\n \nstruct callback_head {\n\tstruct callback_head *next;\n\tvoid (*func)(struct callback_head *head);\n};\nstruct dev_ifalias {\n\tstruct callback_head rcuhead;\n};\n\nstruct net_device   {\n\tint ifindex;\n\tstruct dev_ifalias *ifalias;\n};\n\ntypedef struct {\n        int counter;\n} atomic_t;\ntypedef struct refcount_struct {\n        atomic_t refs;\n} refcount_t;\n\nstruct sk_buff {\n\t \n\tunsigned int len, data_len;\n\t__u16 mac_len, hdr_len, queue_mapping;\n\tstruct net_device *dev;\n\t \n\trefcount_t users;\n\tunsigned char *data;\n\tchar __pkt_type_offset[0];\n\tchar cb[48];\n};\n\nstruct meta {\n\tint ifindex;\n\t__u32 cb32_0;\n\t__u8 cb8_0;\n};\n\n \nSEC(\"tp_btf/kfree_skb\")\nint BPF_PROG(trace_kfree_skb, struct sk_buff *skb, void *location)\n{\n\tstruct net_device *dev;\n\tstruct callback_head *ptr;\n\tvoid *func;\n\tint users;\n\tunsigned char *data;\n\tunsigned short pkt_data;\n\tstruct meta meta = {};\n\tchar pkt_type;\n\t__u32 *cb32;\n\t__u8 *cb8;\n\n\t__builtin_preserve_access_index(({\n\t\tusers = skb->users.refs.counter;\n\t\tdata = skb->data;\n\t\tdev = skb->dev;\n\t\tptr = dev->ifalias->rcuhead.next;\n\t\tfunc = ptr->func;\n\t\tcb8 = (__u8 *)&skb->cb;\n\t\tcb32 = (__u32 *)&skb->cb;\n\t}));\n\n\tmeta.ifindex = _(dev->ifindex);\n\tmeta.cb8_0 = cb8[8];\n\tmeta.cb32_0 = cb32[2];\n\n\tbpf_probe_read_kernel(&pkt_type, sizeof(pkt_type), _(&skb->__pkt_type_offset));\n\tpkt_type &= 7;\n\n\t \n\tbpf_probe_read_kernel(&pkt_data, sizeof(pkt_data), data + 12);\n\n\tbpf_printk(\"rcuhead.next %llx func %llx\\n\", ptr, func);\n\tbpf_printk(\"skb->len %d users %d pkt_type %x\\n\",\n\t\t   _(skb->len), users, pkt_type);\n\tbpf_printk(\"skb->queue_mapping %d\\n\", _(skb->queue_mapping));\n\tbpf_printk(\"dev->ifindex %d data %llx pkt_data %x\\n\",\n\t\t   meta.ifindex, data, pkt_data);\n\tbpf_printk(\"cb8_0:%x cb32_0:%x\\n\", meta.cb8_0, meta.cb32_0);\n\n\tif (users != 1 || pkt_data != bpf_htons(0x86dd) || meta.ifindex != 1)\n\t\t \n\t\treturn 0;\n\n\t \n\tbpf_skb_output(skb, &perf_buf_map, (72ull << 32) | BPF_F_CURRENT_CPU,\n\t\t       &meta, sizeof(meta));\n\treturn 0;\n}\n\nstruct {\n\tbool fentry_test_ok;\n\tbool fexit_test_ok;\n} result = {};\n\nSEC(\"fentry/eth_type_trans\")\nint BPF_PROG(fentry_eth_type_trans, struct sk_buff *skb, struct net_device *dev,\n\t     unsigned short protocol)\n{\n\tint len, ifindex;\n\n\t__builtin_preserve_access_index(({\n\t\tlen = skb->len;\n\t\tifindex = dev->ifindex;\n\t}));\n\n\t \n\tif (len != 74 || ifindex != 1)\n\t\treturn 0;\n\tresult.fentry_test_ok = true;\n\treturn 0;\n}\n\nSEC(\"fexit/eth_type_trans\")\nint BPF_PROG(fexit_eth_type_trans, struct sk_buff *skb, struct net_device *dev,\n\t     unsigned short protocol)\n{\n\tint len, ifindex;\n\n\t__builtin_preserve_access_index(({\n\t\tlen = skb->len;\n\t\tifindex = dev->ifindex;\n\t}));\n\n\t \n\tif (len != 60 || protocol != bpf_htons(0x86dd) || ifindex != 1)\n\t\treturn 0;\n\tresult.fexit_test_ok = true;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}