{
  "module_name": "test_l4lb_noinline_dynptr.c",
  "hash_id": "5422f34454329f90ee5e2fcb0068d06ec0f3bb4878a82c5d4ed367f9725fbd59",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_l4lb_noinline_dynptr.c",
  "human_readable_source": "\n\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <linux/pkt_cls.h>\n#include <linux/bpf.h>\n#include <linux/in.h>\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <bpf/bpf_helpers.h>\n#include \"test_iptunnel_common.h\"\n#include <bpf/bpf_endian.h>\n\n#include \"bpf_kfuncs.h\"\n\nstatic __always_inline __u32 rol32(__u32 word, unsigned int shift)\n{\n\treturn (word << shift) | (word >> ((-shift) & 31));\n}\n\n \n#define __jhash_mix(a, b, c)\t\t\t\\\n{\t\t\t\t\t\t\\\n\ta -= c;  a ^= rol32(c, 4);  c += b;\t\\\n\tb -= a;  b ^= rol32(a, 6);  a += c;\t\\\n\tc -= b;  c ^= rol32(b, 8);  b += a;\t\\\n\ta -= c;  a ^= rol32(c, 16); c += b;\t\\\n\tb -= a;  b ^= rol32(a, 19); a += c;\t\\\n\tc -= b;  c ^= rol32(b, 4);  b += a;\t\\\n}\n\n#define __jhash_final(a, b, c)\t\t\t\\\n{\t\t\t\t\t\t\\\n\tc ^= b; c -= rol32(b, 14);\t\t\\\n\ta ^= c; a -= rol32(c, 11);\t\t\\\n\tb ^= a; b -= rol32(a, 25);\t\t\\\n\tc ^= b; c -= rol32(b, 16);\t\t\\\n\ta ^= c; a -= rol32(c, 4);\t\t\\\n\tb ^= a; b -= rol32(a, 14);\t\t\\\n\tc ^= b; c -= rol32(b, 24);\t\t\\\n}\n\n#define JHASH_INITVAL\t\t0xdeadbeef\n\ntypedef unsigned int u32;\n\nstatic __noinline u32 jhash(const void *key, u32 length, u32 initval)\n{\n\tu32 a, b, c;\n\tconst unsigned char *k = key;\n\n\ta = b = c = JHASH_INITVAL + length + initval;\n\n\twhile (length > 12) {\n\t\ta += *(u32 *)(k);\n\t\tb += *(u32 *)(k + 4);\n\t\tc += *(u32 *)(k + 8);\n\t\t__jhash_mix(a, b, c);\n\t\tlength -= 12;\n\t\tk += 12;\n\t}\n\tswitch (length) {\n\tcase 12: c += (u32)k[11]<<24;\n\tcase 11: c += (u32)k[10]<<16;\n\tcase 10: c += (u32)k[9]<<8;\n\tcase 9:  c += k[8];\n\tcase 8:  b += (u32)k[7]<<24;\n\tcase 7:  b += (u32)k[6]<<16;\n\tcase 6:  b += (u32)k[5]<<8;\n\tcase 5:  b += k[4];\n\tcase 4:  a += (u32)k[3]<<24;\n\tcase 3:  a += (u32)k[2]<<16;\n\tcase 2:  a += (u32)k[1]<<8;\n\tcase 1:  a += k[0];\n\t\t __jhash_final(a, b, c);\n\tcase 0:  \n\t\tbreak;\n\t}\n\n\treturn c;\n}\n\nstatic __noinline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)\n{\n\ta += initval;\n\tb += initval;\n\tc += initval;\n\t__jhash_final(a, b, c);\n\treturn c;\n}\n\nstatic __noinline u32 jhash_2words(u32 a, u32 b, u32 initval)\n{\n\treturn __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 << 2));\n}\n\n#define PCKT_FRAGMENTED 65343\n#define IPV4_HDR_LEN_NO_OPT 20\n#define IPV4_PLUS_ICMP_HDR 28\n#define IPV6_PLUS_ICMP_HDR 48\n#define RING_SIZE 2\n#define MAX_VIPS 12\n#define MAX_REALS 5\n#define CTL_MAP_SIZE 16\n#define CH_RINGS_SIZE (MAX_VIPS * RING_SIZE)\n#define F_IPV6 (1 << 0)\n#define F_HASH_NO_SRC_PORT (1 << 0)\n#define F_ICMP (1 << 0)\n#define F_SYN_SET (1 << 1)\n\nstruct packet_description {\n\tunion {\n\t\t__be32 src;\n\t\t__be32 srcv6[4];\n\t};\n\tunion {\n\t\t__be32 dst;\n\t\t__be32 dstv6[4];\n\t};\n\tunion {\n\t\t__u32 ports;\n\t\t__u16 port16[2];\n\t};\n\t__u8 proto;\n\t__u8 flags;\n};\n\nstruct ctl_value {\n\tunion {\n\t\t__u64 value;\n\t\t__u32 ifindex;\n\t\t__u8 mac[6];\n\t};\n};\n\nstruct vip_meta {\n\t__u32 flags;\n\t__u32 vip_num;\n};\n\nstruct real_definition {\n\tunion {\n\t\t__be32 dst;\n\t\t__be32 dstv6[4];\n\t};\n\t__u8 flags;\n};\n\nstruct vip_stats {\n\t__u64 bytes;\n\t__u64 pkts;\n};\n\nstruct eth_hdr {\n\tunsigned char eth_dest[ETH_ALEN];\n\tunsigned char eth_source[ETH_ALEN];\n\tunsigned short eth_proto;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, MAX_VIPS);\n\t__type(key, struct vip);\n\t__type(value, struct vip_meta);\n} vip_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, CH_RINGS_SIZE);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} ch_rings SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, MAX_REALS);\n\t__type(key, __u32);\n\t__type(value, struct real_definition);\n} reals SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(max_entries, MAX_VIPS);\n\t__type(key, __u32);\n\t__type(value, struct vip_stats);\n} stats SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, CTL_MAP_SIZE);\n\t__type(key, __u32);\n\t__type(value, struct ctl_value);\n} ctl_array SEC(\".maps\");\n\nstatic __noinline __u32 get_packet_hash(struct packet_description *pckt, bool ipv6)\n{\n\tif (ipv6)\n\t\treturn jhash_2words(jhash(pckt->srcv6, 16, MAX_VIPS),\n\t\t\t\t    pckt->ports, CH_RINGS_SIZE);\n\telse\n\t\treturn jhash_2words(pckt->src, pckt->ports, CH_RINGS_SIZE);\n}\n\nstatic __noinline bool get_packet_dst(struct real_definition **real,\n\t\t\t\t      struct packet_description *pckt,\n\t\t\t\t      struct vip_meta *vip_info,\n\t\t\t\t      bool is_ipv6)\n{\n\t__u32 hash = get_packet_hash(pckt, is_ipv6);\n\t__u32 key = RING_SIZE * vip_info->vip_num + hash % RING_SIZE;\n\t__u32 *real_pos;\n\n\tif (hash != 0x358459b7    &&\n\t    hash != 0x2f4bc6bb  )\n\t\treturn false;\n\n\treal_pos = bpf_map_lookup_elem(&ch_rings, &key);\n\tif (!real_pos)\n\t\treturn false;\n\tkey = *real_pos;\n\t*real = bpf_map_lookup_elem(&reals, &key);\n\tif (!(*real))\n\t\treturn false;\n\treturn true;\n}\n\nstatic __noinline int parse_icmpv6(struct bpf_dynptr *skb_ptr, __u64 off,\n\t\t\t\t   struct packet_description *pckt)\n{\n\t__u8 buffer[sizeof(struct ipv6hdr)] = {};\n\tstruct icmp6hdr *icmp_hdr;\n\tstruct ipv6hdr *ip6h;\n\n\ticmp_hdr = bpf_dynptr_slice(skb_ptr, off, buffer, sizeof(buffer));\n\tif (!icmp_hdr)\n\t\treturn TC_ACT_SHOT;\n\n\tif (icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG)\n\t\treturn TC_ACT_OK;\n\toff += sizeof(struct icmp6hdr);\n\tip6h = bpf_dynptr_slice(skb_ptr, off, buffer, sizeof(buffer));\n\tif (!ip6h)\n\t\treturn TC_ACT_SHOT;\n\tpckt->proto = ip6h->nexthdr;\n\tpckt->flags |= F_ICMP;\n\tmemcpy(pckt->srcv6, ip6h->daddr.s6_addr32, 16);\n\tmemcpy(pckt->dstv6, ip6h->saddr.s6_addr32, 16);\n\treturn TC_ACT_UNSPEC;\n}\n\nstatic __noinline int parse_icmp(struct bpf_dynptr *skb_ptr, __u64 off,\n\t\t\t\t struct packet_description *pckt)\n{\n\t__u8 buffer_icmp[sizeof(struct iphdr)] = {};\n\t__u8 buffer_ip[sizeof(struct iphdr)] = {};\n\tstruct icmphdr *icmp_hdr;\n\tstruct iphdr *iph;\n\n\ticmp_hdr = bpf_dynptr_slice(skb_ptr, off, buffer_icmp, sizeof(buffer_icmp));\n\tif (!icmp_hdr)\n\t\treturn TC_ACT_SHOT;\n\tif (icmp_hdr->type != ICMP_DEST_UNREACH ||\n\t    icmp_hdr->code != ICMP_FRAG_NEEDED)\n\t\treturn TC_ACT_OK;\n\toff += sizeof(struct icmphdr);\n\tiph = bpf_dynptr_slice(skb_ptr, off, buffer_ip, sizeof(buffer_ip));\n\tif (!iph || iph->ihl != 5)\n\t\treturn TC_ACT_SHOT;\n\tpckt->proto = iph->protocol;\n\tpckt->flags |= F_ICMP;\n\tpckt->src = iph->daddr;\n\tpckt->dst = iph->saddr;\n\treturn TC_ACT_UNSPEC;\n}\n\nstatic __noinline bool parse_udp(struct bpf_dynptr *skb_ptr, __u64 off,\n\t\t\t\t struct packet_description *pckt)\n{\n\t__u8 buffer[sizeof(struct udphdr)] = {};\n\tstruct udphdr *udp;\n\n\tudp = bpf_dynptr_slice(skb_ptr, off, buffer, sizeof(buffer));\n\tif (!udp)\n\t\treturn false;\n\n\tif (!(pckt->flags & F_ICMP)) {\n\t\tpckt->port16[0] = udp->source;\n\t\tpckt->port16[1] = udp->dest;\n\t} else {\n\t\tpckt->port16[0] = udp->dest;\n\t\tpckt->port16[1] = udp->source;\n\t}\n\treturn true;\n}\n\nstatic __noinline bool parse_tcp(struct bpf_dynptr *skb_ptr, __u64 off,\n\t\t\t\t struct packet_description *pckt)\n{\n\t__u8 buffer[sizeof(struct tcphdr)] = {};\n\tstruct tcphdr *tcp;\n\n\ttcp = bpf_dynptr_slice(skb_ptr, off, buffer, sizeof(buffer));\n\tif (!tcp)\n\t\treturn false;\n\n\tif (tcp->syn)\n\t\tpckt->flags |= F_SYN_SET;\n\n\tif (!(pckt->flags & F_ICMP)) {\n\t\tpckt->port16[0] = tcp->source;\n\t\tpckt->port16[1] = tcp->dest;\n\t} else {\n\t\tpckt->port16[0] = tcp->dest;\n\t\tpckt->port16[1] = tcp->source;\n\t}\n\treturn true;\n}\n\nstatic __noinline int process_packet(struct bpf_dynptr *skb_ptr,\n\t\t\t\t     struct eth_hdr *eth, __u64 off,\n\t\t\t\t     bool is_ipv6, struct __sk_buff *skb)\n{\n\tstruct packet_description pckt = {};\n\tstruct bpf_tunnel_key tkey = {};\n\tstruct vip_stats *data_stats;\n\tstruct real_definition *dst;\n\tstruct vip_meta *vip_info;\n\tstruct ctl_value *cval;\n\t__u32 v4_intf_pos = 1;\n\t__u32 v6_intf_pos = 2;\n\tstruct ipv6hdr *ip6h;\n\tstruct vip vip = {};\n\tstruct iphdr *iph;\n\tint tun_flag = 0;\n\t__u16 pkt_bytes;\n\t__u64 iph_len;\n\t__u32 ifindex;\n\t__u8 protocol;\n\t__u32 vip_num;\n\tint action;\n\n\ttkey.tunnel_ttl = 64;\n\tif (is_ipv6) {\n\t\t__u8 buffer[sizeof(struct ipv6hdr)] = {};\n\n\t\tip6h = bpf_dynptr_slice(skb_ptr, off, buffer, sizeof(buffer));\n\t\tif (!ip6h)\n\t\t\treturn TC_ACT_SHOT;\n\n\t\tiph_len = sizeof(struct ipv6hdr);\n\t\tprotocol = ip6h->nexthdr;\n\t\tpckt.proto = protocol;\n\t\tpkt_bytes = bpf_ntohs(ip6h->payload_len);\n\t\toff += iph_len;\n\t\tif (protocol == IPPROTO_FRAGMENT) {\n\t\t\treturn TC_ACT_SHOT;\n\t\t} else if (protocol == IPPROTO_ICMPV6) {\n\t\t\taction = parse_icmpv6(skb_ptr, off, &pckt);\n\t\t\tif (action >= 0)\n\t\t\t\treturn action;\n\t\t\toff += IPV6_PLUS_ICMP_HDR;\n\t\t} else {\n\t\t\tmemcpy(pckt.srcv6, ip6h->saddr.s6_addr32, 16);\n\t\t\tmemcpy(pckt.dstv6, ip6h->daddr.s6_addr32, 16);\n\t\t}\n\t} else {\n\t\t__u8 buffer[sizeof(struct iphdr)] = {};\n\n\t\tiph = bpf_dynptr_slice(skb_ptr, off, buffer, sizeof(buffer));\n\t\tif (!iph || iph->ihl != 5)\n\t\t\treturn TC_ACT_SHOT;\n\n\t\tprotocol = iph->protocol;\n\t\tpckt.proto = protocol;\n\t\tpkt_bytes = bpf_ntohs(iph->tot_len);\n\t\toff += IPV4_HDR_LEN_NO_OPT;\n\n\t\tif (iph->frag_off & PCKT_FRAGMENTED)\n\t\t\treturn TC_ACT_SHOT;\n\t\tif (protocol == IPPROTO_ICMP) {\n\t\t\taction = parse_icmp(skb_ptr, off, &pckt);\n\t\t\tif (action >= 0)\n\t\t\t\treturn action;\n\t\t\toff += IPV4_PLUS_ICMP_HDR;\n\t\t} else {\n\t\t\tpckt.src = iph->saddr;\n\t\t\tpckt.dst = iph->daddr;\n\t\t}\n\t}\n\tprotocol = pckt.proto;\n\n\tif (protocol == IPPROTO_TCP) {\n\t\tif (!parse_tcp(skb_ptr, off, &pckt))\n\t\t\treturn TC_ACT_SHOT;\n\t} else if (protocol == IPPROTO_UDP) {\n\t\tif (!parse_udp(skb_ptr, off, &pckt))\n\t\t\treturn TC_ACT_SHOT;\n\t} else {\n\t\treturn TC_ACT_SHOT;\n\t}\n\n\tif (is_ipv6)\n\t\tmemcpy(vip.daddr.v6, pckt.dstv6, 16);\n\telse\n\t\tvip.daddr.v4 = pckt.dst;\n\n\tvip.dport = pckt.port16[1];\n\tvip.protocol = pckt.proto;\n\tvip_info = bpf_map_lookup_elem(&vip_map, &vip);\n\tif (!vip_info) {\n\t\tvip.dport = 0;\n\t\tvip_info = bpf_map_lookup_elem(&vip_map, &vip);\n\t\tif (!vip_info)\n\t\t\treturn TC_ACT_SHOT;\n\t\tpckt.port16[1] = 0;\n\t}\n\n\tif (vip_info->flags & F_HASH_NO_SRC_PORT)\n\t\tpckt.port16[0] = 0;\n\n\tif (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6))\n\t\treturn TC_ACT_SHOT;\n\n\tif (dst->flags & F_IPV6) {\n\t\tcval = bpf_map_lookup_elem(&ctl_array, &v6_intf_pos);\n\t\tif (!cval)\n\t\t\treturn TC_ACT_SHOT;\n\t\tifindex = cval->ifindex;\n\t\tmemcpy(tkey.remote_ipv6, dst->dstv6, 16);\n\t\ttun_flag = BPF_F_TUNINFO_IPV6;\n\t} else {\n\t\tcval = bpf_map_lookup_elem(&ctl_array, &v4_intf_pos);\n\t\tif (!cval)\n\t\t\treturn TC_ACT_SHOT;\n\t\tifindex = cval->ifindex;\n\t\ttkey.remote_ipv4 = dst->dst;\n\t}\n\tvip_num = vip_info->vip_num;\n\tdata_stats = bpf_map_lookup_elem(&stats, &vip_num);\n\tif (!data_stats)\n\t\treturn TC_ACT_SHOT;\n\tdata_stats->pkts++;\n\tdata_stats->bytes += pkt_bytes;\n\tbpf_skb_set_tunnel_key(skb, &tkey, sizeof(tkey), tun_flag);\n\t*(u32 *)eth->eth_dest = tkey.remote_ipv4;\n\treturn bpf_redirect(ifindex, 0);\n}\n\nSEC(\"tc\")\nint balancer_ingress(struct __sk_buff *ctx)\n{\n\t__u8 buffer[sizeof(struct eth_hdr)] = {};\n\tstruct bpf_dynptr ptr;\n\tstruct eth_hdr *eth;\n\t__u32 eth_proto;\n\t__u32 nh_off;\n\tint err;\n\n\tnh_off = sizeof(struct eth_hdr);\n\n\tbpf_dynptr_from_skb(ctx, 0, &ptr);\n\teth = bpf_dynptr_slice_rdwr(&ptr, 0, buffer, sizeof(buffer));\n\tif (!eth)\n\t\treturn TC_ACT_SHOT;\n\teth_proto = eth->eth_proto;\n\tif (eth_proto == bpf_htons(ETH_P_IP))\n\t\terr = process_packet(&ptr, eth, nh_off, false, ctx);\n\telse if (eth_proto == bpf_htons(ETH_P_IPV6))\n\t\terr = process_packet(&ptr, eth, nh_off, true, ctx);\n\telse\n\t\treturn TC_ACT_SHOT;\n\n\tif (eth == buffer)\n\t\tbpf_dynptr_write(&ptr, 0, buffer, sizeof(buffer), 0);\n\n\treturn err;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}