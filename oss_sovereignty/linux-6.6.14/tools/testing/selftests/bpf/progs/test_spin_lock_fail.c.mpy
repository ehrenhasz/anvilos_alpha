{
  "module_name": "test_spin_lock_fail.c",
  "hash_id": "3f527ee56e56ec9d05fdb29fbf99178d1c6812704bbd5f41966d30285f85d112",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_spin_lock_fail.c",
  "human_readable_source": "\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_experimental.h\"\n\nstruct foo {\n\tstruct bpf_spin_lock lock;\n\tint data;\n};\n\nstruct array_map {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, int);\n\t__type(value, struct foo);\n\t__uint(max_entries, 1);\n} array_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n\t__array(values, struct array_map);\n} map_of_maps SEC(\".maps\") = {\n\t.values = {\n\t\t[0] = &array_map,\n\t},\n};\n\nSEC(\".data.A\") struct bpf_spin_lock lockA;\nSEC(\".data.B\") struct bpf_spin_lock lockB;\n\nSEC(\"?tc\")\nint lock_id_kptr_preserve(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tbpf_this_cpu_ptr(f);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint lock_id_global_zero(void *ctx)\n{\n\tbpf_this_cpu_ptr(&lockA);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint lock_id_mapval_preserve(void *ctx)\n{\n\tstruct foo *f;\n\tint key = 0;\n\n\tf = bpf_map_lookup_elem(&array_map, &key);\n\tif (!f)\n\t\treturn 0;\n\tbpf_this_cpu_ptr(f);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint lock_id_innermapval_preserve(void *ctx)\n{\n\tstruct foo *f;\n\tint key = 0;\n\tvoid *map;\n\n\tmap = bpf_map_lookup_elem(&map_of_maps, &key);\n\tif (!map)\n\t\treturn 0;\n\tf = bpf_map_lookup_elem(map, &key);\n\tif (!f)\n\t\treturn 0;\n\tbpf_this_cpu_ptr(f);\n\treturn 0;\n}\n\n#define CHECK(test, A, B)                                      \\\n\tSEC(\"?tc\")                                             \\\n\tint lock_id_mismatch_##test(void *ctx)                 \\\n\t{                                                      \\\n\t\tstruct foo *f1, *f2, *v, *iv;                  \\\n\t\tint key = 0;                                   \\\n\t\tvoid *map;                                     \\\n                                                               \\\n\t\tmap = bpf_map_lookup_elem(&map_of_maps, &key); \\\n\t\tif (!map)                                      \\\n\t\t\treturn 0;                              \\\n\t\tiv = bpf_map_lookup_elem(map, &key);           \\\n\t\tif (!iv)                                       \\\n\t\t\treturn 0;                              \\\n\t\tv = bpf_map_lookup_elem(&array_map, &key);     \\\n\t\tif (!v)                                        \\\n\t\t\treturn 0;                              \\\n\t\tf1 = bpf_obj_new(typeof(*f1));                 \\\n\t\tif (!f1)                                       \\\n\t\t\treturn 0;                              \\\n\t\tf2 = bpf_obj_new(typeof(*f2));                 \\\n\t\tif (!f2) {                                     \\\n\t\t\tbpf_obj_drop(f1);                      \\\n\t\t\treturn 0;                              \\\n\t\t}                                              \\\n\t\tbpf_spin_lock(A);                              \\\n\t\tbpf_spin_unlock(B);                            \\\n\t\treturn 0;                                      \\\n\t}\n\nCHECK(kptr_kptr, &f1->lock, &f2->lock);\nCHECK(kptr_global, &f1->lock, &lockA);\nCHECK(kptr_mapval, &f1->lock, &v->lock);\nCHECK(kptr_innermapval, &f1->lock, &iv->lock);\n\nCHECK(global_global, &lockA, &lockB);\nCHECK(global_kptr, &lockA, &f1->lock);\nCHECK(global_mapval, &lockA, &v->lock);\nCHECK(global_innermapval, &lockA, &iv->lock);\n\nSEC(\"?tc\")\nint lock_id_mismatch_mapval_mapval(void *ctx)\n{\n\tstruct foo *f1, *f2;\n\tint key = 0;\n\n\tf1 = bpf_map_lookup_elem(&array_map, &key);\n\tif (!f1)\n\t\treturn 0;\n\tf2 = bpf_map_lookup_elem(&array_map, &key);\n\tif (!f2)\n\t\treturn 0;\n\n\tbpf_spin_lock(&f1->lock);\n\tf1->data = 42;\n\tbpf_spin_unlock(&f2->lock);\n\n\treturn 0;\n}\n\nCHECK(mapval_kptr, &v->lock, &f1->lock);\nCHECK(mapval_global, &v->lock, &lockB);\nCHECK(mapval_innermapval, &v->lock, &iv->lock);\n\nSEC(\"?tc\")\nint lock_id_mismatch_innermapval_innermapval1(void *ctx)\n{\n\tstruct foo *f1, *f2;\n\tint key = 0;\n\tvoid *map;\n\n\tmap = bpf_map_lookup_elem(&map_of_maps, &key);\n\tif (!map)\n\t\treturn 0;\n\tf1 = bpf_map_lookup_elem(map, &key);\n\tif (!f1)\n\t\treturn 0;\n\tf2 = bpf_map_lookup_elem(map, &key);\n\tif (!f2)\n\t\treturn 0;\n\n\tbpf_spin_lock(&f1->lock);\n\tf1->data = 42;\n\tbpf_spin_unlock(&f2->lock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint lock_id_mismatch_innermapval_innermapval2(void *ctx)\n{\n\tstruct foo *f1, *f2;\n\tint key = 0;\n\tvoid *map;\n\n\tmap = bpf_map_lookup_elem(&map_of_maps, &key);\n\tif (!map)\n\t\treturn 0;\n\tf1 = bpf_map_lookup_elem(map, &key);\n\tif (!f1)\n\t\treturn 0;\n\tmap = bpf_map_lookup_elem(&map_of_maps, &key);\n\tif (!map)\n\t\treturn 0;\n\tf2 = bpf_map_lookup_elem(map, &key);\n\tif (!f2)\n\t\treturn 0;\n\n\tbpf_spin_lock(&f1->lock);\n\tf1->data = 42;\n\tbpf_spin_unlock(&f2->lock);\n\n\treturn 0;\n}\n\nCHECK(innermapval_kptr, &iv->lock, &f1->lock);\nCHECK(innermapval_global, &iv->lock, &lockA);\nCHECK(innermapval_mapval, &iv->lock, &v->lock);\n\n#undef CHECK\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}