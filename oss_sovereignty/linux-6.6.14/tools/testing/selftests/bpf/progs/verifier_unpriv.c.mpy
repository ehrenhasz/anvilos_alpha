{
  "module_name": "verifier_unpriv.c",
  "hash_id": "cdbeac8028926eddc3e3b272b7e23cf1cba0611985e757b203e1fdfaa4e09441",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_unpriv.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"../../../include/linux/filter.h\"\n#include \"bpf_misc.h\"\n\n#define BPF_SK_LOOKUP(func) \\\n\t  \\\n\t\"r2 = 0;\"\t\t\t\\\n\t\"*(u32*)(r10 - 8) = r2;\"\t\\\n\t\"*(u64*)(r10 - 16) = r2;\"\t\\\n\t\"*(u64*)(r10 - 24) = r2;\"\t\\\n\t\"*(u64*)(r10 - 32) = r2;\"\t\\\n\t\"*(u64*)(r10 - 40) = r2;\"\t\\\n\t\"*(u64*)(r10 - 48) = r2;\"\t\\\n\t  \\\n\t\"r2 = r10;\"\t\t\t\\\n\t\"r2 += -48;\"\t\t\t\\\n\t\"r3 = %[sizeof_bpf_sock_tuple];\"\\\n\t\"r4 = 0;\"\t\t\t\\\n\t\"r5 = 0;\"\t\t\t\\\n\t\"call %[\" #func \"];\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, long long);\n} map_hash_8b SEC(\".maps\");\n\nvoid dummy_prog_42_socket(void);\nvoid dummy_prog_24_socket(void);\nvoid dummy_prog_loop1_socket(void);\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__uint(max_entries, 4);\n\t__uint(key_size, sizeof(int));\n\t__array(values, void (void));\n} map_prog1_socket SEC(\".maps\") = {\n\t.values = {\n\t\t[0] = (void *)&dummy_prog_42_socket,\n\t\t[1] = (void *)&dummy_prog_loop1_socket,\n\t\t[2] = (void *)&dummy_prog_24_socket,\n\t},\n};\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_42_socket(void)\n{\n\tasm volatile (\"r0 = 42; exit;\");\n}\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_24_socket(void)\n{\n\tasm volatile (\"r0 = 24; exit;\");\n}\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_loop1_socket(void)\n{\n\tasm volatile (\"\t\t\t\\\n\tr3 = 1;\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\\\n\tcall %[bpf_tail_call];\t\t\\\n\tr0 = 41;\t\t\t\\\n\texit;\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: return pointer\")\n__success __failure_unpriv __msg_unpriv(\"R0 leaks addr\")\n__retval(POINTER_VALUE)\n__naked void unpriv_return_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = r10;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: add const to pointer\")\n__success __success_unpriv __retval(0)\n__naked void unpriv_add_const_to_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 += 8;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: add pointer to pointer\")\n__failure __msg(\"R1 pointer += pointer\")\n__failure_unpriv\n__naked void unpriv_add_pointer_to_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 += r10;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: neg pointer\")\n__success __failure_unpriv __msg_unpriv(\"R1 pointer arithmetic\")\n__retval(0)\n__naked void unpriv_neg_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = -r1;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: cmp pointer with const\")\n__success __failure_unpriv __msg_unpriv(\"R1 pointer comparison\")\n__retval(0)\n__naked void unpriv_cmp_pointer_with_const(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tif r1 == 0 goto l0_%=;\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: cmp pointer with pointer\")\n__success __failure_unpriv __msg_unpriv(\"R10 pointer comparison\")\n__retval(0)\n__naked void unpriv_cmp_pointer_with_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tif r1 == r10 goto l0_%=;\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"unpriv: check that printk is disallowed\")\n__success\n__naked void check_that_printk_is_disallowed(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -8;\t\t\t\t\t\\\n\tr2 = 8;\t\t\t\t\t\t\\\n\tr3 = r1;\t\t\t\t\t\\\n\tcall %[bpf_trace_printk];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_trace_printk)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: pass pointer to helper function\")\n__success __failure_unpriv __msg_unpriv(\"R4 leaks addr\")\n__retval(0)\n__naked void pass_pointer_to_helper_function(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tr3 = r2;\t\t\t\t\t\\\n\tr4 = r2;\t\t\t\t\t\\\n\tcall %[bpf_map_update_elem];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_update_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: indirectly pass pointer on stack to helper function\")\n__success __failure_unpriv\n__msg_unpriv(\"invalid indirect read from stack R2 off -8+0 size 8\")\n__retval(0)\n__naked void on_stack_to_helper_function(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r10;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: mangle pointer on stack 1\")\n__success __failure_unpriv __msg_unpriv(\"attempt to corrupt spilled\")\n__retval(0)\n__naked void mangle_pointer_on_stack_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r10;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: mangle pointer on stack 2\")\n__success __failure_unpriv __msg_unpriv(\"attempt to corrupt spilled\")\n__retval(0)\n__naked void mangle_pointer_on_stack_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r10;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u8*)(r10 - 1) = r0;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: read pointer from stack in small chunks\")\n__failure __msg(\"invalid size\")\n__failure_unpriv\n__naked void from_stack_in_small_chunks(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r10;\t\t\t\t\\\n\tr0 = *(u32*)(r10 - 8);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: write pointer into ctx\")\n__failure __msg(\"invalid bpf_context access\")\n__failure_unpriv __msg_unpriv(\"R1 leaks addr\")\n__naked void unpriv_write_pointer_into_ctx(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t*(u64*)(r1 + 0) = r1;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: spill/fill of ctx\")\n__success __success_unpriv __retval(0)\n__naked void unpriv_spill_fill_of_ctx(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\n\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"unpriv: spill/fill of ctx 2\")\n__success __retval(0)\n__naked void spill_fill_of_ctx_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\n\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\tcall %[bpf_get_hash_recalc];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_hash_recalc)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"unpriv: spill/fill of ctx 3\")\n__failure __msg(\"R1 type=fp expected=ctx\")\n__naked void spill_fill_of_ctx_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r10;\t\t\t\t\\\n\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\tcall %[bpf_get_hash_recalc];\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_hash_recalc)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"unpriv: spill/fill of ctx 4\")\n__failure __msg(\"R1 type=scalar expected=ctx\")\n__naked void spill_fill_of_ctx_4(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\tlock *(u64 *)(r10 - 8) += r0;\t\t\t\\\n\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\tcall %[bpf_get_hash_recalc];\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_hash_recalc)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"unpriv: spill/fill of different pointers stx\")\n__failure __msg(\"same insn cannot be used with different pointers\")\n__naked void fill_of_different_pointers_stx(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr3 = 42;\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tif r1 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -16;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r2;\t\t\t\t\\\nl0_%=:\tif r1 != 0 goto l1_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\nl1_%=:\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\t*(u32*)(r1 + %[__sk_buff_mark]) = r3;\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark))\n\t: __clobber_all);\n}\n\n/* Same as above, but use BPF_ST_MEM to save 42\n * instead of BPF_STX_MEM.\n */\nSEC(\"tc\")\n__description(\"unpriv: spill/fill of different pointers st\")\n__failure __msg(\"same insn cannot be used with different pointers\")\n__naked void fill_of_different_pointers_st(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tif r1 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -16;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r2;\t\t\t\t\\\nl0_%=:\tif r1 != 0 goto l1_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\nl1_%=:\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\t.8byte %[st_mem];\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark)),\n\t  __imm_insn(st_mem,\n\t\t     BPF_ST_MEM(BPF_W, BPF_REG_1, offsetof(struct __sk_buff, mark), 42))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"unpriv: spill/fill of different pointers stx - ctx and sock\")\n__failure __msg(\"type=ctx expected=sock\")\n__naked void pointers_stx_ctx_and_sock(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr8 = r1;\t\t\t\t\t\\\n\t \\\n\"\tBPF_SK_LOOKUP(bpf_sk_lookup_tcp)\n\"\tr2 = r0;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\t \t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr1 = r8;\t\t\t\t\t\\\n\t \t\t\\\n\tif r1 == 0 goto l0_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r2;\t\t\t\t\\\nl0_%=:\t \t\t\t\\\n\tif r1 != 0 goto l1_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\nl1_%=:\t \t\t\\\n\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\t \t\t\t\t\\\n\tr3 = 42;\t\t\t\t\t\\\n\t*(u32*)(r1 + %[__sk_buff_mark]) = r3;\t\t\\\n\t \t\t\\\n\tif r1 == 0 goto l2_%=;\t\t\t\t\\\n\tcall %[bpf_sk_release];\t\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_sk_lookup_tcp),\n\t  __imm(bpf_sk_release),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark)),\n\t  __imm_const(sizeof_bpf_sock_tuple, sizeof(struct bpf_sock_tuple))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"unpriv: spill/fill of different pointers stx - leak sock\")\n__failure\n//.errstr = \"same insn cannot be used with different pointers\",\n__msg(\"Unreleased reference\")\n__naked void different_pointers_stx_leak_sock(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr8 = r1;\t\t\t\t\t\\\n\t \\\n\"\tBPF_SK_LOOKUP(bpf_sk_lookup_tcp)\n\"\tr2 = r0;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\t \t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr1 = r8;\t\t\t\t\t\\\n\t \t\t\\\n\tif r1 == 0 goto l0_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r2;\t\t\t\t\\\nl0_%=:\t \t\t\t\\\n\tif r1 != 0 goto l1_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\nl1_%=:\t \t\t\\\n\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\t \t\t\t\t\\\n\tr3 = 42;\t\t\t\t\t\\\n\t*(u32*)(r1 + %[__sk_buff_mark]) = r3;\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_sk_lookup_tcp),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark)),\n\t  __imm_const(sizeof_bpf_sock_tuple, sizeof(struct bpf_sock_tuple))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"unpriv: spill/fill of different pointers stx - sock and ctx (read)\")\n__failure __msg(\"same insn cannot be used with different pointers\")\n__naked void stx_sock_and_ctx_read(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr8 = r1;\t\t\t\t\t\\\n\t \\\n\"\tBPF_SK_LOOKUP(bpf_sk_lookup_tcp)\n\"\tr2 = r0;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\t \t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr1 = r8;\t\t\t\t\t\\\n\t \t\t\t\\\n\tif r1 == 0 goto l0_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\nl0_%=:\t \t\t\t\\\n\tif r1 != 0 goto l1_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r2;\t\t\t\t\\\nl1_%=:\t \t\t\\\n\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\t \\\n\tif r1 == 0 goto l2_%=;\t\t\t\t\\\n\tr3 = *(u32*)(r1 + %[bpf_sock_mark]);\t\t\\\n\tcall %[bpf_sk_release];\t\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_sk_lookup_tcp),\n\t  __imm(bpf_sk_release),\n\t  __imm_const(bpf_sock_mark, offsetof(struct bpf_sock, mark)),\n\t  __imm_const(sizeof_bpf_sock_tuple, sizeof(struct bpf_sock_tuple))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"unpriv: spill/fill of different pointers stx - sock and ctx (write)\")\n__failure\n//.errstr = \"same insn cannot be used with different pointers\",\n__msg(\"cannot write into sock\")\n__naked void stx_sock_and_ctx_write(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr8 = r1;\t\t\t\t\t\\\n\t \\\n\"\tBPF_SK_LOOKUP(bpf_sk_lookup_tcp)\n\"\tr2 = r0;\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\t \t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr1 = r8;\t\t\t\t\t\\\n\t \t\t\t\\\n\tif r1 == 0 goto l0_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\nl0_%=:\t \t\t\t\\\n\tif r1 != 0 goto l1_%=;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r2;\t\t\t\t\\\nl1_%=:\t \t\t\\\n\tr1 = *(u64*)(r6 + 0);\t\t\t\t\\\n\t \\\n\tif r1 == 0 goto l2_%=;\t\t\t\t\\\n\tr3 = 42;\t\t\t\t\t\\\n\t*(u32*)(r1 + %[bpf_sock_mark]) = r3;\t\t\\\n\tcall %[bpf_sk_release];\t\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_sk_lookup_tcp),\n\t  __imm(bpf_sk_release),\n\t  __imm_const(bpf_sock_mark, offsetof(struct bpf_sock, mark)),\n\t  __imm_const(sizeof_bpf_sock_tuple, sizeof(struct bpf_sock_tuple))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: write pointer into map elem value\")\n__success __failure_unpriv __msg_unpriv(\"R0 leaks addr\")\n__retval(0)\n__naked void pointer_into_map_elem_value(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t*(u64*)(r0 + 0) = r0;\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"alu32: mov u32 const\")\n__success __failure_unpriv __msg_unpriv(\"R7 invalid mem access 'scalar'\")\n__retval(0)\n__naked void alu32_mov_u32_const(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tw7 = 0;\t\t\t\t\t\t\\\n\tw7 &= 1;\t\t\t\t\t\\\n\tw0 = w7;\t\t\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr0 = *(u64*)(r7 + 0);\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: partial copy of pointer\")\n__success __failure_unpriv __msg_unpriv(\"R10 partial copy\")\n__retval(0)\n__naked void unpriv_partial_copy_of_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tw1 = w10;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: pass pointer to tail_call\")\n__success __failure_unpriv __msg_unpriv(\"R3 leaks addr into helper\")\n__retval(0)\n__naked void pass_pointer_to_tail_call(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr3 = r1;\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: cmp map pointer with zero\")\n__success __failure_unpriv __msg_unpriv(\"R1 pointer comparison\")\n__retval(0)\n__naked void cmp_map_pointer_with_zero(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tif r1 == 0 goto l0_%=;\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: write into frame pointer\")\n__failure __msg(\"frame pointer is read only\")\n__failure_unpriv\n__naked void unpriv_write_into_frame_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr10 = r1;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: spill/fill frame pointer\")\n__failure __msg(\"frame pointer is read only\")\n__failure_unpriv\n__naked void unpriv_spill_fill_frame_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r10;\t\t\t\t\\\n\tr10 = *(u64*)(r6 + 0);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: cmp of frame pointer\")\n__success __failure_unpriv __msg_unpriv(\"R10 pointer comparison\")\n__retval(0)\n__naked void unpriv_cmp_of_frame_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tif r10 == 0 goto l0_%=;\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: adding of fp, reg\")\n__success __failure_unpriv\n__msg_unpriv(\"R1 stack pointer arithmetic goes out of range\")\n__retval(0)\n__naked void unpriv_adding_of_fp_reg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\tr1 += r10;\t\t\t\t\t\\\n\t*(u64*)(r1 - 8) = r0;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: adding of fp, imm\")\n__success __failure_unpriv\n__msg_unpriv(\"R1 stack pointer arithmetic goes out of range\")\n__retval(0)\n__naked void unpriv_adding_of_fp_imm(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += 0;\t\t\t\t\t\\\n\t*(u64*)(r1 - 8) = r0;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"unpriv: cmp of stack pointer\")\n__success __failure_unpriv __msg_unpriv(\"R2 pointer comparison\")\n__retval(0)\n__naked void unpriv_cmp_of_stack_pointer(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tif r2 == 0 goto l0_%=;\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}