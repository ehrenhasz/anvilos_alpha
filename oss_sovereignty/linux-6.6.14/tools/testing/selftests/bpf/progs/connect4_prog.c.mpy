{
  "module_name": "connect4_prog.c",
  "hash_id": "a0ec30c34f2cd85c41938e0c74ca6a228748bb6e096f2656cbe75640c705d525",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/connect4_prog.c",
  "human_readable_source": "\n\n\n#include <string.h>\n\n#include <linux/stddef.h>\n#include <linux/bpf.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/tcp.h>\n#include <linux/if.h>\n#include <errno.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#include \"bpf_tcp_helpers.h\"\n\n#define SRC_REWRITE_IP4\t\t0x7f000004U\n#define DST_REWRITE_IP4\t\t0x7f000001U\n#define DST_REWRITE_PORT4\t4444\n\n#ifndef TCP_CA_NAME_MAX\n#define TCP_CA_NAME_MAX 16\n#endif\n\n#ifndef TCP_NOTSENT_LOWAT\n#define TCP_NOTSENT_LOWAT 25\n#endif\n\n#ifndef IFNAMSIZ\n#define IFNAMSIZ 16\n#endif\n\n__attribute__ ((noinline)) __weak\nint do_bind(struct bpf_sock_addr *ctx)\n{\n\tstruct sockaddr_in sa = {};\n\n\tsa.sin_family = AF_INET;\n\tsa.sin_port = bpf_htons(0);\n\tsa.sin_addr.s_addr = bpf_htonl(SRC_REWRITE_IP4);\n\n\tif (bpf_bind(ctx, (struct sockaddr *)&sa, sizeof(sa)) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic __inline int verify_cc(struct bpf_sock_addr *ctx,\n\t\t\t      char expected[TCP_CA_NAME_MAX])\n{\n\tchar buf[TCP_CA_NAME_MAX];\n\tint i;\n\n\tif (bpf_getsockopt(ctx, SOL_TCP, TCP_CONGESTION, &buf, sizeof(buf)))\n\t\treturn 1;\n\n\tfor (i = 0; i < TCP_CA_NAME_MAX; i++) {\n\t\tif (buf[i] != expected[i])\n\t\t\treturn 1;\n\t\tif (buf[i] == 0)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic __inline int set_cc(struct bpf_sock_addr *ctx)\n{\n\tchar reno[TCP_CA_NAME_MAX] = \"reno\";\n\tchar cubic[TCP_CA_NAME_MAX] = \"cubic\";\n\n\tif (bpf_setsockopt(ctx, SOL_TCP, TCP_CONGESTION, &reno, sizeof(reno)))\n\t\treturn 1;\n\tif (verify_cc(ctx, reno))\n\t\treturn 1;\n\n\tif (bpf_setsockopt(ctx, SOL_TCP, TCP_CONGESTION, &cubic, sizeof(cubic)))\n\t\treturn 1;\n\tif (verify_cc(ctx, cubic))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic __inline int bind_to_device(struct bpf_sock_addr *ctx)\n{\n\tchar veth1[IFNAMSIZ] = \"test_sock_addr1\";\n\tchar veth2[IFNAMSIZ] = \"test_sock_addr2\";\n\tchar missing[IFNAMSIZ] = \"nonexistent_dev\";\n\tchar del_bind[IFNAMSIZ] = \"\";\n\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t\t&veth1, sizeof(veth1)))\n\t\treturn 1;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t\t&veth2, sizeof(veth2)))\n\t\treturn 1;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t\t&missing, sizeof(missing)) != -ENODEV)\n\t\treturn 1;\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t\t&del_bind, sizeof(del_bind)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic __inline int set_keepalive(struct bpf_sock_addr *ctx)\n{\n\tint zero = 0, one = 1;\n\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_KEEPALIVE, &one, sizeof(one)))\n\t\treturn 1;\n\tif (ctx->type == SOCK_STREAM) {\n\t\tif (bpf_setsockopt(ctx, SOL_TCP, TCP_KEEPIDLE, &one, sizeof(one)))\n\t\t\treturn 1;\n\t\tif (bpf_setsockopt(ctx, SOL_TCP, TCP_KEEPINTVL, &one, sizeof(one)))\n\t\t\treturn 1;\n\t\tif (bpf_setsockopt(ctx, SOL_TCP, TCP_KEEPCNT, &one, sizeof(one)))\n\t\t\treturn 1;\n\t\tif (bpf_setsockopt(ctx, SOL_TCP, TCP_SYNCNT, &one, sizeof(one)))\n\t\t\treturn 1;\n\t\tif (bpf_setsockopt(ctx, SOL_TCP, TCP_USER_TIMEOUT, &one, sizeof(one)))\n\t\t\treturn 1;\n\t}\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_KEEPALIVE, &zero, sizeof(zero)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic __inline int set_notsent_lowat(struct bpf_sock_addr *ctx)\n{\n\tint lowat = 65535;\n\n\tif (ctx->type == SOCK_STREAM) {\n\t\tif (bpf_setsockopt(ctx, SOL_TCP, TCP_NOTSENT_LOWAT, &lowat, sizeof(lowat)))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nSEC(\"cgroup/connect4\")\nint connect_v4_prog(struct bpf_sock_addr *ctx)\n{\n\tstruct bpf_sock_tuple tuple = {};\n\tstruct bpf_sock *sk;\n\n\t \n\tmemset(&tuple.ipv4.saddr, 0, sizeof(tuple.ipv4.saddr));\n\tmemset(&tuple.ipv4.sport, 0, sizeof(tuple.ipv4.sport));\n\n\ttuple.ipv4.daddr = bpf_htonl(DST_REWRITE_IP4);\n\ttuple.ipv4.dport = bpf_htons(DST_REWRITE_PORT4);\n\n\t \n\tif (bind_to_device(ctx))\n\t\treturn 0;\n\n\tif (set_keepalive(ctx))\n\t\treturn 0;\n\n\tif (set_notsent_lowat(ctx))\n\t\treturn 0;\n\n\tif (ctx->type != SOCK_STREAM && ctx->type != SOCK_DGRAM)\n\t\treturn 0;\n\telse if (ctx->type == SOCK_STREAM)\n\t\tsk = bpf_sk_lookup_tcp(ctx, &tuple, sizeof(tuple.ipv4),\n\t\t\t\t       BPF_F_CURRENT_NETNS, 0);\n\telse\n\t\tsk = bpf_sk_lookup_udp(ctx, &tuple, sizeof(tuple.ipv4),\n\t\t\t\t       BPF_F_CURRENT_NETNS, 0);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tif (sk->src_ip4 != tuple.ipv4.daddr ||\n\t    sk->src_port != DST_REWRITE_PORT4) {\n\t\tbpf_sk_release(sk);\n\t\treturn 0;\n\t}\n\n\tbpf_sk_release(sk);\n\n\t \n\tif (ctx->type == SOCK_STREAM && set_cc(ctx))\n\t\treturn 0;\n\n\t \n\tctx->user_ip4 = bpf_htonl(DST_REWRITE_IP4);\n\tctx->user_port = bpf_htons(DST_REWRITE_PORT4);\n\n\treturn do_bind(ctx) ? 1 : 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}