{
  "module_name": "local_storage.c",
  "hash_id": "e3fce39aebac1db009a5d4e0afcc0601cdca1613d3067c34a3b3f95370d34930",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/local_storage.c",
  "human_readable_source": "\n\n \n\n#include \"vmlinux.h\"\n#include <errno.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n#define DUMMY_STORAGE_VALUE 0xdeadbeef\n\nint monitored_pid = 0;\nint inode_storage_result = -1;\nint sk_storage_result = -1;\nint task_storage_result = -1;\n\nstruct local_storage {\n\tstruct inode *exec_inode;\n\t__u32 value;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_INODE_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct local_storage);\n} inode_storage_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC | BPF_F_CLONE);\n\t__type(key, int);\n\t__type(value, struct local_storage);\n} sk_storage_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC | BPF_F_CLONE);\n\t__type(key, int);\n\t__type(value, struct local_storage);\n} sk_storage_map2 SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_TASK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct local_storage);\n} task_storage_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_TASK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct local_storage);\n} task_storage_map2 SEC(\".maps\");\n\nSEC(\"lsm/inode_unlink\")\nint BPF_PROG(unlink_hook, struct inode *dir, struct dentry *victim)\n{\n\t__u32 pid = bpf_get_current_pid_tgid() >> 32;\n\tstruct bpf_local_storage *local_storage;\n\tstruct local_storage *storage;\n\tstruct task_struct *task;\n\tbool is_self_unlink;\n\n\tif (pid != monitored_pid)\n\t\treturn 0;\n\n\ttask = bpf_get_current_task_btf();\n\tif (!task)\n\t\treturn 0;\n\n\ttask_storage_result = -1;\n\n\tstorage = bpf_task_storage_get(&task_storage_map, task, 0, 0);\n\tif (!storage)\n\t\treturn 0;\n\n\t \n\tis_self_unlink = storage->exec_inode == victim->d_inode;\n\n\tstorage = bpf_task_storage_get(&task_storage_map2, task, 0,\n\t\t\t\t       BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (!storage || storage->value)\n\t\treturn 0;\n\n\tif (bpf_task_storage_delete(&task_storage_map, task))\n\t\treturn 0;\n\n\t \n\tlocal_storage = task->bpf_storage;\n\tif (!local_storage || local_storage->smap)\n\t\treturn 0;\n\n\ttask_storage_result = 0;\n\n\treturn is_self_unlink ? -EPERM : 0;\n}\n\nSEC(\"lsm.s/inode_rename\")\nint BPF_PROG(inode_rename, struct inode *old_dir, struct dentry *old_dentry,\n\t     struct inode *new_dir, struct dentry *new_dentry,\n\t     unsigned int flags)\n{\n\tstruct local_storage *storage;\n\tint err;\n\n\t \n\tbpf_inode_storage_get(&inode_storage_map, new_dentry->d_inode, 0,\n\t\t\t      BPF_LOCAL_STORAGE_GET_F_CREATE);\n\n\tstorage = bpf_inode_storage_get(&inode_storage_map, old_dentry->d_inode,\n\t\t\t\t\t0, 0);\n\tif (!storage)\n\t\treturn 0;\n\n\tif (storage->value != DUMMY_STORAGE_VALUE)\n\t\tinode_storage_result = -1;\n\n\terr = bpf_inode_storage_delete(&inode_storage_map, old_dentry->d_inode);\n\tif (!err)\n\t\tinode_storage_result = err;\n\n\treturn 0;\n}\n\nSEC(\"lsm.s/socket_bind\")\nint BPF_PROG(socket_bind, struct socket *sock, struct sockaddr *address,\n\t     int addrlen)\n{\n\t__u32 pid = bpf_get_current_pid_tgid() >> 32;\n\tstruct local_storage *storage;\n\n\tif (pid != monitored_pid)\n\t\treturn 0;\n\n\tstorage = bpf_sk_storage_get(&sk_storage_map, sock->sk, 0, 0);\n\tif (!storage)\n\t\treturn 0;\n\n\tsk_storage_result = -1;\n\tif (storage->value != DUMMY_STORAGE_VALUE)\n\t\treturn 0;\n\n\t \n\tstorage = bpf_sk_storage_get(&sk_storage_map2, sock->sk, 0,\n\t\t\t\t     BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (!storage)\n\t\treturn 0;\n\n\tif (bpf_sk_storage_delete(&sk_storage_map2, sock->sk))\n\t\treturn 0;\n\n\tstorage = bpf_sk_storage_get(&sk_storage_map2, sock->sk, 0,\n\t\t\t\t     BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (!storage)\n\t\treturn 0;\n\n\tif (bpf_sk_storage_delete(&sk_storage_map, sock->sk))\n\t\treturn 0;\n\n\t \n\tif (!sock->sk->sk_bpf_storage || sock->sk->sk_bpf_storage->smap)\n\t\treturn 0;\n\n\tsk_storage_result = 0;\n\treturn 0;\n}\n\nSEC(\"lsm.s/socket_post_create\")\nint BPF_PROG(socket_post_create, struct socket *sock, int family, int type,\n\t     int protocol, int kern)\n{\n\t__u32 pid = bpf_get_current_pid_tgid() >> 32;\n\tstruct local_storage *storage;\n\n\tif (pid != monitored_pid)\n\t\treturn 0;\n\n\tstorage = bpf_sk_storage_get(&sk_storage_map, sock->sk, 0,\n\t\t\t\t     BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (!storage)\n\t\treturn 0;\n\n\tstorage->value = DUMMY_STORAGE_VALUE;\n\n\treturn 0;\n}\n\n \nSEC(\"lsm.s/bprm_committed_creds\")\nvoid BPF_PROG(exec, struct linux_binprm *bprm)\n{\n\t__u32 pid = bpf_get_current_pid_tgid() >> 32;\n\tstruct local_storage *storage;\n\n\tif (pid != monitored_pid)\n\t\treturn;\n\n\tstorage = bpf_task_storage_get(&task_storage_map,\n\t\t\t\t       bpf_get_current_task_btf(), 0,\n\t\t\t\t       BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (storage)\n\t\tstorage->exec_inode = bprm->file->f_inode;\n\n\tstorage = bpf_inode_storage_get(&inode_storage_map, bprm->file->f_inode,\n\t\t\t\t\t0, BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (!storage)\n\t\treturn;\n\n\tstorage->value = DUMMY_STORAGE_VALUE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}