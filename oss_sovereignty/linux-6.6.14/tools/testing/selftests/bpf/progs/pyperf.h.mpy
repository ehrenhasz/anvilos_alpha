{
  "module_name": "pyperf.h",
  "hash_id": "d5c7b5851fb5eef09a2d4848370a8a02879e706ed38a9f3020fb09c4c0cf6160",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/pyperf.h",
  "human_readable_source": "\n\n#include <linux/sched.h>\n#include <linux/ptrace.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\n#define FUNCTION_NAME_LEN 64\n#define FILE_NAME_LEN 128\n#define TASK_COMM_LEN 16\n\ntypedef struct {\n\tint PyThreadState_frame;\n\tint PyThreadState_thread;\n\tint PyFrameObject_back;\n\tint PyFrameObject_code;\n\tint PyFrameObject_lineno;\n\tint PyCodeObject_filename;\n\tint PyCodeObject_name;\n\tint String_data;\n\tint String_size;\n} OffsetConfig;\n\ntypedef struct {\n\tuintptr_t current_state_addr;\n\tuintptr_t tls_key_addr;\n\tOffsetConfig offsets;\n\tbool use_tls;\n} PidData;\n\ntypedef struct {\n\tuint32_t success;\n} Stats;\n\ntypedef struct {\n\tchar name[FUNCTION_NAME_LEN];\n\tchar file[FILE_NAME_LEN];\n} Symbol;\n\ntypedef struct {\n\tuint32_t pid;\n\tuint32_t tid;\n\tchar comm[TASK_COMM_LEN];\n\tint32_t kernel_stack_id;\n\tint32_t user_stack_id;\n\tbool thread_current;\n\tbool pthread_match;\n\tbool stack_complete;\n\tint16_t stack_len;\n\tint32_t stack[STACK_MAX_LEN];\n\n\tint has_meta;\n\tint metadata;\n\tchar dummy_safeguard;\n} Event;\n\n\ntypedef int pid_t;\n\ntypedef struct {\n\tvoid* f_back; \n\tvoid* f_code; \n\tvoid* co_filename; \n\tvoid* co_name; \n} FrameData;\n\n#ifdef SUBPROGS\n__noinline\n#else\n__always_inline\n#endif\nstatic void *get_thread_state(void *tls_base, PidData *pidData)\n{\n\tvoid* thread_state;\n\tint key;\n\n\tbpf_probe_read_user(&key, sizeof(key), (void*)(long)pidData->tls_key_addr);\n\tbpf_probe_read_user(&thread_state, sizeof(thread_state),\n\t\t\t    tls_base + 0x310 + key * 0x10 + 0x08);\n\treturn thread_state;\n}\n\nstatic __always_inline bool get_frame_data(void *frame_ptr, PidData *pidData,\n\t\t\t\t\t   FrameData *frame, Symbol *symbol)\n{\n\t\n\tbpf_probe_read_user(&frame->f_back,\n\t\t\t    sizeof(frame->f_back),\n\t\t\t    frame_ptr + pidData->offsets.PyFrameObject_back);\n\tbpf_probe_read_user(&frame->f_code,\n\t\t\t    sizeof(frame->f_code),\n\t\t\t    frame_ptr + pidData->offsets.PyFrameObject_code);\n\n\t\n\tif (!frame->f_code)\n\t\treturn false;\n\tbpf_probe_read_user(&frame->co_filename,\n\t\t\t    sizeof(frame->co_filename),\n\t\t\t    frame->f_code + pidData->offsets.PyCodeObject_filename);\n\tbpf_probe_read_user(&frame->co_name,\n\t\t\t    sizeof(frame->co_name),\n\t\t\t    frame->f_code + pidData->offsets.PyCodeObject_name);\n\t\n\tif (frame->co_filename)\n\t\tbpf_probe_read_user_str(&symbol->file,\n\t\t\t\t\tsizeof(symbol->file),\n\t\t\t\t\tframe->co_filename +\n\t\t\t\t\tpidData->offsets.String_data);\n\tif (frame->co_name)\n\t\tbpf_probe_read_user_str(&symbol->name,\n\t\t\t\t\tsizeof(symbol->name),\n\t\t\t\t\tframe->co_name +\n\t\t\t\t\tpidData->offsets.String_data);\n\treturn true;\n}\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, PidData);\n} pidmap SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, Event);\n} eventmap SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, Symbol);\n\t__type(value, int);\n} symbolmap SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, Stats);\n} statsmap SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n\t__uint(max_entries, 32);\n\t__uint(key_size, sizeof(int));\n\t__uint(value_size, sizeof(int));\n} perfmap SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_STACK_TRACE);\n\t__uint(max_entries, 1000);\n\t__uint(key_size, sizeof(int));\n\t__uint(value_size, sizeof(long long) * 127);\n} stackmap SEC(\".maps\");\n\n#ifdef USE_BPF_LOOP\nstruct process_frame_ctx {\n\tint cur_cpu;\n\tint32_t *symbol_counter;\n\tvoid *frame_ptr;\n\tFrameData *frame;\n\tPidData *pidData;\n\tSymbol *sym;\n\tEvent *event;\n\tbool done;\n};\n\nstatic int process_frame_callback(__u32 i, struct process_frame_ctx *ctx)\n{\n\tint zero = 0;\n\tvoid *frame_ptr = ctx->frame_ptr;\n\tPidData *pidData = ctx->pidData;\n\tFrameData *frame = ctx->frame;\n\tint32_t *symbol_counter = ctx->symbol_counter;\n\tint cur_cpu = ctx->cur_cpu;\n\tEvent *event = ctx->event;\n\tSymbol *sym = ctx->sym;\n\n\tif (frame_ptr && get_frame_data(frame_ptr, pidData, frame, sym)) {\n\t\tint32_t new_symbol_id = *symbol_counter * 64 + cur_cpu;\n\t\tint32_t *symbol_id = bpf_map_lookup_elem(&symbolmap, sym);\n\n\t\tif (!symbol_id) {\n\t\t\tbpf_map_update_elem(&symbolmap, sym, &zero, 0);\n\t\t\tsymbol_id = bpf_map_lookup_elem(&symbolmap, sym);\n\t\t\tif (!symbol_id) {\n\t\t\t\tctx->done = true;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (*symbol_id == new_symbol_id)\n\t\t\t(*symbol_counter)++;\n\n\t\tbarrier_var(i);\n\t\tif (i >= STACK_MAX_LEN)\n\t\t\treturn 1;\n\n\t\tevent->stack[i] = *symbol_id;\n\n\t\tevent->stack_len = i + 1;\n\t\tframe_ptr = frame->f_back;\n\t}\n\treturn 0;\n}\n#endif  \n\n#ifdef GLOBAL_FUNC\n__noinline\n#elif defined(SUBPROGS)\nstatic __noinline\n#else\nstatic __always_inline\n#endif\nint __on_event(struct bpf_raw_tracepoint_args *ctx)\n{\n\tuint64_t pid_tgid = bpf_get_current_pid_tgid();\n\tpid_t pid = (pid_t)(pid_tgid >> 32);\n\tPidData* pidData = bpf_map_lookup_elem(&pidmap, &pid);\n\tif (!pidData)\n\t\treturn 0;\n\n\tint zero = 0;\n\tEvent* event = bpf_map_lookup_elem(&eventmap, &zero);\n\tif (!event)\n\t\treturn 0;\n\n\tevent->pid = pid;\n\n\tevent->tid = (pid_t)pid_tgid;\n\tbpf_get_current_comm(&event->comm, sizeof(event->comm));\n\n\tevent->user_stack_id = bpf_get_stackid(ctx, &stackmap, BPF_F_USER_STACK);\n\tevent->kernel_stack_id = bpf_get_stackid(ctx, &stackmap, 0);\n\n\tvoid* thread_state_current = (void*)0;\n\tbpf_probe_read_user(&thread_state_current,\n\t\t\t    sizeof(thread_state_current),\n\t\t\t    (void*)(long)pidData->current_state_addr);\n\n\tstruct task_struct* task = (struct task_struct*)bpf_get_current_task();\n\tvoid* tls_base = (void*)task;\n\n\tvoid* thread_state = pidData->use_tls ? get_thread_state(tls_base, pidData)\n\t\t: thread_state_current;\n\tevent->thread_current = thread_state == thread_state_current;\n\n\tif (pidData->use_tls) {\n\t\tuint64_t pthread_created;\n\t\tuint64_t pthread_self;\n\t\tbpf_probe_read_user(&pthread_self, sizeof(pthread_self),\n\t\t\t\t    tls_base + 0x10);\n\n\t\tbpf_probe_read_user(&pthread_created,\n\t\t\t\t    sizeof(pthread_created),\n\t\t\t\t    thread_state +\n\t\t\t\t    pidData->offsets.PyThreadState_thread);\n\t\tevent->pthread_match = pthread_created == pthread_self;\n\t} else {\n\t\tevent->pthread_match = 1;\n\t}\n\n\tif (event->pthread_match || !pidData->use_tls) {\n\t\tvoid* frame_ptr;\n\t\tFrameData frame;\n\t\tSymbol sym = {};\n\t\tint cur_cpu = bpf_get_smp_processor_id();\n\n\t\tbpf_probe_read_user(&frame_ptr,\n\t\t\t\t    sizeof(frame_ptr),\n\t\t\t\t    thread_state +\n\t\t\t\t    pidData->offsets.PyThreadState_frame);\n\n\t\tint32_t* symbol_counter = bpf_map_lookup_elem(&symbolmap, &sym);\n\t\tif (symbol_counter == NULL)\n\t\t\treturn 0;\n#ifdef USE_BPF_LOOP\n\tstruct process_frame_ctx ctx = {\n\t\t.cur_cpu = cur_cpu,\n\t\t.symbol_counter = symbol_counter,\n\t\t.frame_ptr = frame_ptr,\n\t\t.frame = &frame,\n\t\t.pidData = pidData,\n\t\t.sym = &sym,\n\t\t.event = event,\n\t};\n\n\tbpf_loop(STACK_MAX_LEN, process_frame_callback, &ctx, 0);\n\tif (ctx.done)\n\t\treturn 0;\n#else\n#if defined(USE_ITER)\n \n#elif defined(NO_UNROLL)\n#pragma clang loop unroll(disable)\n#elif defined(UNROLL_COUNT)\n#pragma clang loop unroll_count(UNROLL_COUNT)\n#else\n#pragma clang loop unroll(full)\n#endif  \n\t\t \n#ifdef USE_ITER\n\t\tint i;\n\t\tbpf_for(i, 0, STACK_MAX_LEN) {\n#else  \n\t\tfor (int i = 0; i < STACK_MAX_LEN; ++i) {\n#endif\n\t\t\tif (frame_ptr && get_frame_data(frame_ptr, pidData, &frame, &sym)) {\n\t\t\t\tint32_t new_symbol_id = *symbol_counter * 64 + cur_cpu;\n\t\t\t\tint32_t *symbol_id = bpf_map_lookup_elem(&symbolmap, &sym);\n\t\t\t\tif (!symbol_id) {\n\t\t\t\t\tbpf_map_update_elem(&symbolmap, &sym, &zero, 0);\n\t\t\t\t\tsymbol_id = bpf_map_lookup_elem(&symbolmap, &sym);\n\t\t\t\t\tif (!symbol_id)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (*symbol_id == new_symbol_id)\n\t\t\t\t\t(*symbol_counter)++;\n\t\t\t\tevent->stack[i] = *symbol_id;\n\t\t\t\tevent->stack_len = i + 1;\n\t\t\t\tframe_ptr = frame.f_back;\n\t\t\t}\n\t\t}\n#endif  \n\t\tevent->stack_complete = frame_ptr == NULL;\n\t} else {\n\t\tevent->stack_complete = 1;\n\t}\n\n\tStats* stats = bpf_map_lookup_elem(&statsmap, &zero);\n\tif (stats)\n\t\tstats->success++;\n\n\tevent->has_meta = 0;\n\tbpf_perf_event_output(ctx, &perfmap, 0, event, offsetof(Event, metadata));\n\treturn 0;\n}\n\nSEC(\"raw_tracepoint/kfree_skb\")\nint on_event(struct bpf_raw_tracepoint_args* ctx)\n{\n\tint ret = 0;\n\tret |= __on_event(ctx);\n\tret |= __on_event(ctx);\n\tret |= __on_event(ctx);\n\tret |= __on_event(ctx);\n\tret |= __on_event(ctx);\n\treturn ret;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}