{
  "module_name": "test_bpf_ma.c",
  "hash_id": "a5822663884303eae43ffba5d7e8856333c54c5171d6536c0596232447a1b54a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_bpf_ma.c",
  "human_readable_source": "\n \n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n\n#include \"bpf_experimental.h\"\n#include \"bpf_misc.h\"\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n#endif\n\nstruct generic_map_value {\n\tvoid *data;\n};\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nconst unsigned int data_sizes[] = {8, 16, 32, 64, 96, 128, 192, 256, 512, 1024, 2048, 4096};\nconst volatile unsigned int data_btf_ids[ARRAY_SIZE(data_sizes)] = {};\n\nint err = 0;\nint pid = 0;\n\n#define DEFINE_ARRAY_WITH_KPTR(_size) \\\n\tstruct bin_data_##_size { \\\n\t\tchar data[_size - sizeof(void *)]; \\\n\t}; \\\n\tstruct map_value_##_size { \\\n\t\tstruct bin_data_##_size __kptr * data; \\\n\t\t  \\\n\t\tstruct bin_data_##_size not_used; \\\n\t}; \\\n\tstruct { \\\n\t\t__uint(type, BPF_MAP_TYPE_ARRAY); \\\n\t\t__type(key, int); \\\n\t\t__type(value, struct map_value_##_size); \\\n\t\t__uint(max_entries, 128); \\\n\t} array_##_size SEC(\".maps\");\n\nstatic __always_inline void batch_alloc_free(struct bpf_map *map, unsigned int batch,\n\t\t\t\t\t     unsigned int idx)\n{\n\tstruct generic_map_value *value;\n\tunsigned int i, key;\n\tvoid *old, *new;\n\n\tfor (i = 0; i < batch; i++) {\n\t\tkey = i;\n\t\tvalue = bpf_map_lookup_elem(map, &key);\n\t\tif (!value) {\n\t\t\terr = 1;\n\t\t\treturn;\n\t\t}\n\t\tnew = bpf_obj_new_impl(data_btf_ids[idx], NULL);\n\t\tif (!new) {\n\t\t\terr = 2;\n\t\t\treturn;\n\t\t}\n\t\told = bpf_kptr_xchg(&value->data, new);\n\t\tif (old) {\n\t\t\tbpf_obj_drop(old);\n\t\t\terr = 3;\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < batch; i++) {\n\t\tkey = i;\n\t\tvalue = bpf_map_lookup_elem(map, &key);\n\t\tif (!value) {\n\t\t\terr = 4;\n\t\t\treturn;\n\t\t}\n\t\told = bpf_kptr_xchg(&value->data, NULL);\n\t\tif (!old) {\n\t\t\terr = 5;\n\t\t\treturn;\n\t\t}\n\t\tbpf_obj_drop(old);\n\t}\n}\n\n#define CALL_BATCH_ALLOC_FREE(size, batch, idx) \\\n\tbatch_alloc_free((struct bpf_map *)(&array_##size), batch, idx)\n\nDEFINE_ARRAY_WITH_KPTR(8);\nDEFINE_ARRAY_WITH_KPTR(16);\nDEFINE_ARRAY_WITH_KPTR(32);\nDEFINE_ARRAY_WITH_KPTR(64);\nDEFINE_ARRAY_WITH_KPTR(96);\nDEFINE_ARRAY_WITH_KPTR(128);\nDEFINE_ARRAY_WITH_KPTR(192);\nDEFINE_ARRAY_WITH_KPTR(256);\nDEFINE_ARRAY_WITH_KPTR(512);\nDEFINE_ARRAY_WITH_KPTR(1024);\nDEFINE_ARRAY_WITH_KPTR(2048);\nDEFINE_ARRAY_WITH_KPTR(4096);\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_nanosleep\")\nint test_bpf_mem_alloc_free(void *ctx)\n{\n\tif ((u32)bpf_get_current_pid_tgid() != pid)\n\t\treturn 0;\n\n\t \n\tCALL_BATCH_ALLOC_FREE(8, 128, 0);\n\tCALL_BATCH_ALLOC_FREE(16, 128, 1);\n\tCALL_BATCH_ALLOC_FREE(32, 128, 2);\n\tCALL_BATCH_ALLOC_FREE(64, 128, 3);\n\tCALL_BATCH_ALLOC_FREE(96, 128, 4);\n\tCALL_BATCH_ALLOC_FREE(128, 128, 5);\n\tCALL_BATCH_ALLOC_FREE(192, 128, 6);\n\tCALL_BATCH_ALLOC_FREE(256, 128, 7);\n\tCALL_BATCH_ALLOC_FREE(512, 64, 8);\n\tCALL_BATCH_ALLOC_FREE(1024, 32, 9);\n\tCALL_BATCH_ALLOC_FREE(2048, 16, 10);\n\tCALL_BATCH_ALLOC_FREE(4096, 8, 11);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}