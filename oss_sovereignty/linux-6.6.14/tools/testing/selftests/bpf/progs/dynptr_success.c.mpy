{
  "module_name": "dynptr_success.c",
  "hash_id": "567c5db3c315787f519209b109d3785e7c0b570caa9014b6348ef87f6ce8b4fb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/dynptr_success.c",
  "human_readable_source": "\n \n\n#include <string.h>\n#include <stdbool.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n#include \"bpf_kfuncs.h\"\n#include \"errno.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nint pid, err, val;\n\nstruct sample {\n\tint pid;\n\tint seq;\n\tlong value;\n\tchar comm[16];\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_RINGBUF);\n\t__uint(max_entries, 4096);\n} ringbuf SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} array_map SEC(\".maps\");\n\nSEC(\"?tp/syscalls/sys_enter_nanosleep\")\nint test_read_write(void *ctx)\n{\n\tchar write_data[64] = \"hello there, world!!\";\n\tchar read_data[64] = {};\n\tstruct bpf_dynptr ptr;\n\tint i;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, sizeof(write_data), 0, &ptr);\n\n\t \n\terr = bpf_dynptr_write(&ptr, 0, write_data, sizeof(write_data), 0);\n\n\t \n\terr = err ?: bpf_dynptr_read(read_data, sizeof(read_data), &ptr, 0, 0);\n\n\t \n\tfor (i = 0; i < sizeof(read_data); i++) {\n\t\tif (read_data[i] != write_data[i]) {\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n\nSEC(\"?tp/syscalls/sys_enter_nanosleep\")\nint test_dynptr_data(void *ctx)\n{\n\t__u32 key = 0, val = 235, *map_val;\n\tstruct bpf_dynptr ptr;\n\t__u32 map_val_size;\n\tvoid *data;\n\n\tmap_val_size = sizeof(*map_val);\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tbpf_map_update_elem(&array_map, &key, &val, 0);\n\n\tmap_val = bpf_map_lookup_elem(&array_map, &key);\n\tif (!map_val) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tbpf_dynptr_from_mem(map_val, map_val_size, 0, &ptr);\n\n\t \n\tdata = bpf_dynptr_data(&ptr, map_val_size + 1, 1);\n\tif (data) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\t \n\tdata = bpf_dynptr_data(&ptr, 0, map_val_size + 1);\n\tif (data) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tdata = bpf_dynptr_data(&ptr, 0, sizeof(__u32));\n\tif (!data) {\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\t*(__u32 *)data = 999;\n\n\terr = bpf_probe_read_kernel(&val, sizeof(val), data);\n\tif (err)\n\t\treturn 0;\n\n\tif (val != *(int *)data)\n\t\terr = 5;\n\n\treturn 0;\n}\n\nstatic int ringbuf_callback(__u32 index, void *data)\n{\n\tstruct sample *sample;\n\n\tstruct bpf_dynptr *ptr = (struct bpf_dynptr *)data;\n\n\tsample = bpf_dynptr_data(ptr, 0, sizeof(*sample));\n\tif (!sample)\n\t\terr = 2;\n\telse\n\t\tsample->pid += index;\n\n\treturn 0;\n}\n\nSEC(\"?tp/syscalls/sys_enter_nanosleep\")\nint test_ringbuf(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct sample *sample;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tval = 100;\n\n\t \n\terr = bpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\tsample = err ? NULL : bpf_dynptr_data(&ptr, 0, sizeof(*sample));\n\tif (!sample) {\n\t\terr = 1;\n\t\tgoto done;\n\t}\n\n\tsample->pid = 10;\n\n\t \n\tbpf_loop(10, ringbuf_callback, &ptr, 0);\n\n\tif (sample->pid != 55)\n\t\terr = 2;\n\ndone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n\nSEC(\"?cgroup_skb/egress\")\nint test_skb_readonly(struct __sk_buff *skb)\n{\n\t__u8 write_data[2] = {1, 2};\n\tstruct bpf_dynptr ptr;\n\tint ret;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr)) {\n\t\terr = 1;\n\t\treturn 1;\n\t}\n\n\t \n\tret = bpf_dynptr_write(&ptr, 0, write_data, sizeof(write_data), 0);\n\tif (ret != -EINVAL) {\n\t\terr = 2;\n\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n\nSEC(\"?cgroup_skb/egress\")\nint test_dynptr_skb_data(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\t__u64 *data;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr)) {\n\t\terr = 1;\n\t\treturn 1;\n\t}\n\n\t \n\tdata = bpf_dynptr_data(&ptr, 0, 1);\n\tif (data) {\n\t\terr = 2;\n\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n\nSEC(\"tp/syscalls/sys_enter_nanosleep\")\nint test_adjust(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\t__u32 bytes = 64;\n\t__u32 off = 10;\n\t__u32 trim = 15;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\terr = bpf_ringbuf_reserve_dynptr(&ringbuf, bytes, 0, &ptr);\n\tif (err) {\n\t\terr = 1;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_size(&ptr) != bytes) {\n\t\terr = 2;\n\t\tgoto done;\n\t}\n\n\t \n\terr = bpf_dynptr_adjust(&ptr, off, bpf_dynptr_size(&ptr));\n\tif (err) {\n\t\terr = 3;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_size(&ptr) != bytes - off) {\n\t\terr = 4;\n\t\tgoto done;\n\t}\n\n\t \n\terr = bpf_dynptr_adjust(&ptr, off, 15);\n\tif (err) {\n\t\terr = 5;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bpf_dynptr_size(&ptr) != trim - off) {\n\t\terr = 6;\n\t\tgoto done;\n\t}\n\ndone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_nanosleep\")\nint test_adjust_err(void *ctx)\n{\n\tchar write_data[45] = \"hello there, world!!\";\n\tstruct bpf_dynptr ptr;\n\t__u32 size = 64;\n\t__u32 off = 20;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, size, 0, &ptr)) {\n\t\terr = 1;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bpf_dynptr_adjust(&ptr, 5, 1) != -EINVAL) {\n\t\terr = 2;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bpf_dynptr_adjust(&ptr, size + 1, size + 1) != -ERANGE) {\n\t\terr = 3;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bpf_dynptr_adjust(&ptr, 0, size + 1) != -ERANGE) {\n\t\terr = 4;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_adjust(&ptr, off, size)) {\n\t\terr = 5;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bpf_dynptr_write(&ptr, 0, &write_data, sizeof(write_data), 0) != -E2BIG) {\n\t\terr = 6;\n\t\tgoto done;\n\t}\n\n\t \n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\treturn 0;\n\ndone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_nanosleep\")\nint test_zero_size_dynptr(void *ctx)\n{\n\tchar write_data = 'x', read_data;\n\tstruct bpf_dynptr ptr;\n\t__u32 size = 64;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, size, 0, &ptr)) {\n\t\terr = 1;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bpf_dynptr_adjust(&ptr, size, size)) {\n\t\terr = 2;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bpf_dynptr_read(&read_data, sizeof(read_data), &ptr, 0, 0) != -E2BIG) {\n\t\terr = 3;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_write(&ptr, 0, &write_data, sizeof(write_data), 0) != -E2BIG) {\n\t\terr = 4;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bpf_dynptr_read(&read_data, 0, &ptr, 0, 0)) {\n\t\terr = 5;\n\t\tgoto done;\n\t}\n\n\tif (bpf_dynptr_write(&ptr, 0, &write_data, 0, 0)) {\n\t\terr = 6;\n\t\tgoto done;\n\t}\n\n\terr = 0;\n\ndone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_nanosleep\")\nint test_dynptr_is_null(void *ctx)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr ptr2;\n\t__u64 size = 4;\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\t \n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, size, 123, &ptr1) != -EINVAL) {\n\t\terr = 1;\n\t\tgoto exit_early;\n\t}\n\n\t \n\tif (!bpf_dynptr_is_null(&ptr1)) {\n\t\terr = 2;\n\t\tgoto exit_early;\n\t}\n\n\t \n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, size, 0, &ptr2)) {\n\t\terr = 3;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (bpf_dynptr_is_null(&ptr2)) {\n\t\terr = 4;\n\t\tgoto exit;\n\t}\n\nexit:\n\tbpf_ringbuf_discard_dynptr(&ptr2, 0);\nexit_early:\n\tbpf_ringbuf_discard_dynptr(&ptr1, 0);\n\treturn 0;\n}\n\nSEC(\"cgroup_skb/egress\")\nint test_dynptr_is_rdonly(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr ptr2;\n\tstruct bpf_dynptr ptr3;\n\n\t \n\tif (bpf_dynptr_from_skb(skb, 123, &ptr1) != -EINVAL) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\t \n\tif (bpf_dynptr_is_rdonly(&ptr1)) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\t \n\tif (bpf_dynptr_from_skb(skb, 0, &ptr2)) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!bpf_dynptr_is_rdonly(&ptr2)) {\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\t \n\tif (bpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &ptr3)) {\n\t\terr = 5;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bpf_dynptr_is_rdonly(&ptr3)) {\n\t\terr = 6;\n\t\tgoto done;\n\t}\n\ndone:\n\tbpf_ringbuf_discard_dynptr(&ptr3, 0);\n\treturn 0;\n}\n\nSEC(\"cgroup_skb/egress\")\nint test_dynptr_clone(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr ptr2;\n\t__u32 off = 2, size;\n\n\t \n\tif (bpf_dynptr_from_skb(skb, 0, &ptr1)) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tif (bpf_dynptr_adjust(&ptr1, off, bpf_dynptr_size(&ptr1))) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\t \n\tif (bpf_dynptr_clone(&ptr1, &ptr2)) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tsize = bpf_dynptr_size(&ptr1);\n\n\t \n\tif (bpf_dynptr_size(&ptr2) != size) {\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\tif (bpf_dynptr_is_rdonly(&ptr2) != bpf_dynptr_is_rdonly(&ptr1)) {\n\t\terr = 5;\n\t\treturn 0;\n\t}\n\n\t \n\tbpf_dynptr_adjust(&ptr1, 5, 5);\n\n\t \n\tif (bpf_dynptr_size(&ptr2) != size) {\n\t\terr = 6;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nSEC(\"?cgroup_skb/egress\")\nint test_dynptr_skb_no_buff(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\t__u64 *data;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr)) {\n\t\terr = 1;\n\t\treturn 1;\n\t}\n\n\t \n\tdata = bpf_dynptr_slice(&ptr, 0, NULL, 1);\n\n\treturn !!data;\n}\n\nSEC(\"?cgroup_skb/egress\")\nint test_dynptr_skb_strcmp(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tchar *data;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr)) {\n\t\terr = 1;\n\t\treturn 1;\n\t}\n\n\t \n\tdata = bpf_dynptr_slice(&ptr, 0, NULL, 10);\n\tif (data) {\n\t\tbpf_strncmp(data, 10, \"foo\");\n\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}