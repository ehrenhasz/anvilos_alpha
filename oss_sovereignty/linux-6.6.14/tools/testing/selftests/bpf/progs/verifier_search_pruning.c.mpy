{
  "module_name": "verifier_search_pruning.c",
  "hash_id": "d62a9caba5c8642e5eb742c90252b647af91d558663324553ec3b02cfd113fe8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_search_pruning.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\n#define MAX_ENTRIES 11\n\nstruct test_val {\n\tunsigned int index;\n\tint foo[MAX_ENTRIES];\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, struct test_val);\n} map_hash_48b SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, long long);\n} map_hash_8b SEC(\".maps\");\n\nSEC(\"socket\")\n__description(\"pointer/scalar confusion in state equality check (way 1)\")\n__success __failure_unpriv __msg_unpriv(\"R0 leaks addr as return value\")\n__retval(POINTER_VALUE)\n__naked void state_equality_check_way_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr0 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr0 = r10;\t\t\t\t\t\\\nl1_%=:\tgoto l2_%=;\t\t\t\t\t\\\nl2_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"pointer/scalar confusion in state equality check (way 2)\")\n__success __failure_unpriv __msg_unpriv(\"R0 leaks addr as return value\")\n__retval(POINTER_VALUE)\n__naked void state_equality_check_way_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\tr0 = r10;\t\t\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr0 = *(u64*)(r0 + 0);\t\t\t\t\\\nl1_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"lwt_in\")\n__description(\"liveness pruning and write screening\")\n__failure __msg(\"R0 !read_ok\")\n__naked void liveness_pruning_and_write_screening(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \\\n\tif r2 >= 0 goto l0_%=;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\tif r2 >= 0 goto l1_%=;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\nl1_%=:\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"varlen_map_value_access pruning\")\n__failure __msg(\"R0 unbounded memory access\")\n__failure_unpriv __msg_unpriv(\"R0 leaks addr\")\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void varlen_map_value_access_pruning(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tw2 = %[max_entries];\t\t\t\t\\\n\tif r2 s> r1 goto l1_%=;\t\t\t\t\\\n\tw1 = 0;\t\t\t\t\t\t\\\nl1_%=:\tw1 <<= 2;\t\t\t\t\t\\\n\tr0 += r1;\t\t\t\t\t\\\n\tgoto l2_%=;\t\t\t\t\t\\\nl2_%=:\tr1 = %[test_val_foo];\t\t\t\t\\\n\t*(u64*)(r0 + 0) = r1;\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(max_entries, MAX_ENTRIES),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"search pruning: all branches should be verified (nop operation)\")\n__failure __msg(\"R6 invalid mem access 'scalar'\")\n__naked void should_be_verified_nop_operation(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr3 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tif r3 == 0xbeef goto l1_%=;\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tgoto l2_%=;\t\t\t\t\t\\\nl1_%=:\tr4 = 1;\t\t\t\t\t\t\\\nl2_%=:\t*(u64*)(r10 - 16) = r4;\t\t\t\t\\\n\tcall %[bpf_ktime_get_ns];\t\t\t\\\n\tr5 = *(u64*)(r10 - 16);\t\t\t\t\\\n\tif r5 == 0 goto l0_%=;\t\t\t\t\\\n\tr6 = 0;\t\t\t\t\t\t\\\n\tr1 = 0xdead;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_ktime_get_ns),\n\t  __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"search pruning: all branches should be verified (invalid stack access)\")\n/* in privileged mode reads from uninitialized stack locations are permitted */\n__success __failure_unpriv\n__msg_unpriv(\"invalid read from stack off -16+0 size 8\")\n__retval(0)\n__naked void be_verified_invalid_stack_access(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr3 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r3 == 0xbeef goto l1_%=;\t\t\t\\\n\t*(u64*)(r10 - 16) = r4;\t\t\t\t\\\n\tgoto l2_%=;\t\t\t\t\t\\\nl1_%=:\t*(u64*)(r10 - 24) = r4;\t\t\t\t\\\nl2_%=:\tcall %[bpf_ktime_get_ns];\t\t\t\\\n\tr5 = *(u64*)(r10 - 16);\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_ktime_get_ns),\n\t  __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"precision tracking for u32 spill/fill\")\n__failure __msg(\"R0 min value is outside of the allowed memory range\")\n__naked void tracking_for_u32_spill_fill(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr7 = r1;\t\t\t\t\t\\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tw6 = 32;\t\t\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tw6 = 4;\t\t\t\t\t\t\\\nl0_%=:\t \\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tif r0 == 0 goto l1_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\nl1_%=:\t \t\t\t\t\\\n\t*(u32*)(r10 - 8) = r6;\t\t\t\t\\\n\tr8 = *(u32*)(r10 - 8);\t\t\t\t\\\n\t \t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 16) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -16;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l2_%=;\t\t\t\t\\\n\tr0 += r8;\t\t\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_prandom_u32),\n\t  __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"precision tracking for u32 spills, u64 fill\")\n__failure __msg(\"div by zero\")\n__naked void for_u32_spills_u64_fill(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tr6 = r0;\t\t\t\t\t\\\n\tw7 = 0xffffffff;\t\t\t\t\\\n\t \\\n\tr3 = 1;\t\t\t\t\t\t\\\n\tr3 = 1;\t\t\t\t\t\t\\\n\tr3 = 1;\t\t\t\t\t\t\\\n\tr3 = 1;\t\t\t\t\t\t\\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr3 = 1;\t\t\t\t\t\t\\\nl0_%=:\tw3 /= 0;\t\t\t\t\t\\\n\t \t\t\t\\\n\t*(u32*)(r10 - 4) = r6;\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r7;\t\t\t\t\\\n\tr8 = *(u64*)(r10 - 8);\t\t\t\t\\\n\t \\\n\tif r8 != 0xffffffff goto l1_%=;\t\t\t\\\n\tr3 = 1;\t\t\t\t\t\t\\\nl1_%=:\t \t\t\t\t\t\t\\\n\tif r8 == 0xffffffff goto l2_%=;\t\t\t\\\n\t \\\n\tw3 /= 0;\t\t\t\t\t\\\nl2_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_prandom_u32)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"allocated_stack\")\n__success __msg(\"processed 15 insns\")\n__success_unpriv __msg_unpriv(\"\") __log_level(1) __retval(0)\n__naked void allocated_stack(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r1;\t\t\t\t\t\\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tr7 = r0;\t\t\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r6;\t\t\t\t\\\n\tr6 = *(u64*)(r10 - 8);\t\t\t\t\\\n\t*(u8*)(r10 - 9) = r7;\t\t\t\t\\\n\tr7 = *(u8*)(r10 - 9);\t\t\t\t\\\nl0_%=:\tif r0 != 0 goto l1_%=;\t\t\t\t\\\nl1_%=:\tif r0 != 0 goto l2_%=;\t\t\t\t\\\nl2_%=:\tif r0 != 0 goto l3_%=;\t\t\t\t\\\nl3_%=:\tif r0 != 0 goto l4_%=;\t\t\t\t\\\nl4_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_prandom_u32)\n\t: __clobber_all);\n}\n\n/* The test performs a conditional 64-bit write to a stack location\n * fp[-8], this is followed by an unconditional 8-bit write to fp[-8],\n * then data is read from fp[-8]. This sequence is unsafe.\n *\n * The test would be mistakenly marked as safe w/o dst register parent\n * preservation in verifier.c:copy_register_state() function.\n *\n * Note the usage of BPF_F_TEST_STATE_FREQ to force creation of the\n * checkpoint state after conditional 64-bit assignment.\n */\n\nSEC(\"socket\")\n__description(\"write tracking and register parent chain bug\")\n/* in privileged mode reads from uninitialized stack locations are permitted */\n__success __failure_unpriv\n__msg_unpriv(\"invalid read from stack off -8+1 size 8\")\n__retval(0) __flag(BPF_F_TEST_STATE_FREQ)\n__naked void and_register_parent_chain_bug(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\tcall %[bpf_ktime_get_ns];\t\t\t\\\n\tr6 = r0;\t\t\t\t\t\\\n\t \t\t\t\\\n\tcall %[bpf_ktime_get_ns];\t\t\t\\\n\t \t\t\t\\\n\tif r0 > r6 goto l0_%=;\t\t\t\t\\\n\t \t\t\\\n\tr0 = 0xdeadbeef;\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\nl0_%=:\tr1 = 42;\t\t\t\t\t\\\n\t*(u8*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = *(u64*)(r10 - 8);\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_ktime_get_ns)\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}