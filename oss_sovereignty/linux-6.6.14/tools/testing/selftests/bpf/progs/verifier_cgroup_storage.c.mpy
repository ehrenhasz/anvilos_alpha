{
  "module_name": "verifier_cgroup_storage.c",
  "hash_id": "1dfb424b2ca7b33372670f27a3d4d4f9dffde9e9b7696bd0533cdbaecb0e7dff",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_cgroup_storage.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"../../../include/linux/filter.h\"\n#include \"bpf_misc.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_CGROUP_STORAGE);\n\t__uint(max_entries, 0);\n\t__type(key, struct bpf_cgroup_storage_key);\n\t__type(value, char[TEST_DATA_LEN]);\n} cgroup_storage SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, long long);\n} map_hash_8b SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE);\n\t__uint(max_entries, 0);\n\t__type(key, struct bpf_cgroup_storage_key);\n\t__type(value, char[64]);\n} percpu_cgroup_storage SEC(\".maps\");\n\nSEC(\"cgroup/skb\")\n__description(\"valid cgroup storage access\")\n__success __success_unpriv __retval(0)\n__naked void valid_cgroup_storage_access(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr1 = %[cgroup_storage] ll;\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(cgroup_storage)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid cgroup storage access 1\")\n__failure __msg(\"cannot pass map_type 1 into func bpf_get_local_storage\")\n__failure_unpriv\n__naked void invalid_cgroup_storage_access_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid cgroup storage access 2\")\n__failure __msg(\"fd 1 is not pointing to valid bpf_map\")\n__failure_unpriv\n__naked void invalid_cgroup_storage_access_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t.8byte %[ld_map_fd];\t\t\t\t\\\n\t.8byte 0;\t\t\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_insn(ld_map_fd, BPF_RAW_INSN(BPF_LD | BPF_DW | BPF_IMM, BPF_REG_1, BPF_PSEUDO_MAP_FD, 0, 1))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid cgroup storage access 3\")\n__failure __msg(\"invalid access to map value, value_size=64 off=256 size=4\")\n__failure_unpriv\n__naked void invalid_cgroup_storage_access_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr1 = %[cgroup_storage] ll;\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 256);\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(cgroup_storage)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid cgroup storage access 4\")\n__failure __msg(\"invalid access to map value, value_size=64 off=-2 size=4\")\n__failure_unpriv\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void invalid_cgroup_storage_access_4(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr1 = %[cgroup_storage] ll;\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 - 2);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(cgroup_storage)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid cgroup storage access 5\")\n__failure __msg(\"get_local_storage() doesn't support non-zero flags\")\n__failure_unpriv\n__naked void invalid_cgroup_storage_access_5(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 7;\t\t\t\t\t\t\\\n\tr1 = %[cgroup_storage] ll;\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(cgroup_storage)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid cgroup storage access 6\")\n__failure __msg(\"get_local_storage() doesn't support non-zero flags\")\n__msg_unpriv(\"R2 leaks addr into helper function\")\n__naked void invalid_cgroup_storage_access_6(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r1;\t\t\t\t\t\\\n\tr1 = %[cgroup_storage] ll;\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(cgroup_storage)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"valid per-cpu cgroup storage access\")\n__success __success_unpriv __retval(0)\n__naked void per_cpu_cgroup_storage_access(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr1 = %[percpu_cgroup_storage] ll;\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(percpu_cgroup_storage)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid per-cpu cgroup storage access 1\")\n__failure __msg(\"cannot pass map_type 1 into func bpf_get_local_storage\")\n__failure_unpriv\n__naked void cpu_cgroup_storage_access_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid per-cpu cgroup storage access 2\")\n__failure __msg(\"fd 1 is not pointing to valid bpf_map\")\n__failure_unpriv\n__naked void cpu_cgroup_storage_access_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t.8byte %[ld_map_fd];\t\t\t\t\\\n\t.8byte 0;\t\t\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_insn(ld_map_fd, BPF_RAW_INSN(BPF_LD | BPF_DW | BPF_IMM, BPF_REG_1, BPF_PSEUDO_MAP_FD, 0, 1))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid per-cpu cgroup storage access 3\")\n__failure __msg(\"invalid access to map value, value_size=64 off=256 size=4\")\n__failure_unpriv\n__naked void cpu_cgroup_storage_access_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr1 = %[percpu_cgroup_storage] ll;\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 256);\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(percpu_cgroup_storage)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid per-cpu cgroup storage access 4\")\n__failure __msg(\"invalid access to map value, value_size=64 off=-2 size=4\")\n__failure_unpriv\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void cpu_cgroup_storage_access_4(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr1 = %[cgroup_storage] ll;\t\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 - 2);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr1 += 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(cgroup_storage)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid per-cpu cgroup storage access 5\")\n__failure __msg(\"get_local_storage() doesn't support non-zero flags\")\n__failure_unpriv\n__naked void cpu_cgroup_storage_access_5(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 7;\t\t\t\t\t\t\\\n\tr1 = %[percpu_cgroup_storage] ll;\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(percpu_cgroup_storage)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid per-cpu cgroup storage access 6\")\n__failure __msg(\"get_local_storage() doesn't support non-zero flags\")\n__msg_unpriv(\"R2 leaks addr into helper function\")\n__naked void cpu_cgroup_storage_access_6(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r1;\t\t\t\t\t\\\n\tr1 = %[percpu_cgroup_storage] ll;\t\t\\\n\tcall %[bpf_get_local_storage];\t\t\t\\\n\tr1 = *(u32*)(r0 + 0);\t\t\t\t\\\n\tr0 = r1;\t\t\t\t\t\\\n\tr0 &= 1;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_local_storage),\n\t  __imm_addr(percpu_cgroup_storage)\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}