{
  "module_name": "sock_destroy_prog.c",
  "hash_id": "d35b83993e8bbb3cc92dfb93ee2a0bdf48d9c045568d2fafa4e4e3c60f650810",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/sock_destroy_prog.c",
  "human_readable_source": "\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#include \"bpf_tracing_net.h\"\n\n__be16 serv_port = 0;\n\nint bpf_sock_destroy(struct sock_common *sk) __ksym;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} tcp_conn_sockets SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} udp_conn_sockets SEC(\".maps\");\n\nSEC(\"cgroup/connect6\")\nint sock_connect(struct bpf_sock_addr *ctx)\n{\n\t__u64 sock_cookie = 0;\n\tint key = 0;\n\t__u32 keyc = 0;\n\n\tif (ctx->family != AF_INET6 || ctx->user_family != AF_INET6)\n\t\treturn 1;\n\n\tsock_cookie = bpf_get_socket_cookie(ctx);\n\tif (ctx->protocol == IPPROTO_TCP)\n\t\tbpf_map_update_elem(&tcp_conn_sockets, &key, &sock_cookie, 0);\n\telse if (ctx->protocol == IPPROTO_UDP)\n\t\tbpf_map_update_elem(&udp_conn_sockets, &keyc, &sock_cookie, 0);\n\telse\n\t\treturn 1;\n\n\treturn 1;\n}\n\nSEC(\"iter/tcp\")\nint iter_tcp6_client(struct bpf_iter__tcp *ctx)\n{\n\tstruct sock_common *sk_common = ctx->sk_common;\n\t__u64 sock_cookie = 0;\n\t__u64 *val;\n\tint key = 0;\n\n\tif (!sk_common)\n\t\treturn 0;\n\n\tif (sk_common->skc_family != AF_INET6)\n\t\treturn 0;\n\n\tsock_cookie  = bpf_get_socket_cookie(sk_common);\n\tval = bpf_map_lookup_elem(&tcp_conn_sockets, &key);\n\tif (!val)\n\t\treturn 0;\n\t \n\tif (sock_cookie == *val)\n\t\tbpf_sock_destroy(sk_common);\n\n\treturn 0;\n}\n\nSEC(\"iter/tcp\")\nint iter_tcp6_server(struct bpf_iter__tcp *ctx)\n{\n\tstruct sock_common *sk_common = ctx->sk_common;\n\tconst struct inet_connection_sock *icsk;\n\tconst struct inet_sock *inet;\n\tstruct tcp6_sock *tcp_sk;\n\t__be16 srcp;\n\n\tif (!sk_common)\n\t\treturn 0;\n\n\tif (sk_common->skc_family != AF_INET6)\n\t\treturn 0;\n\n\ttcp_sk = bpf_skc_to_tcp6_sock(sk_common);\n\tif (!tcp_sk)\n\t\treturn 0;\n\n\ticsk = &tcp_sk->tcp.inet_conn;\n\tinet = &icsk->icsk_inet;\n\tsrcp = inet->inet_sport;\n\n\t \n\tif (srcp == serv_port)\n\t\tbpf_sock_destroy(sk_common);\n\n\treturn 0;\n}\n\n\nSEC(\"iter/udp\")\nint iter_udp6_client(struct bpf_iter__udp *ctx)\n{\n\tstruct udp_sock *udp_sk = ctx->udp_sk;\n\tstruct sock *sk = (struct sock *) udp_sk;\n\t__u64 sock_cookie = 0, *val;\n\tint key = 0;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsock_cookie  = bpf_get_socket_cookie(sk);\n\tval = bpf_map_lookup_elem(&udp_conn_sockets, &key);\n\tif (!val)\n\t\treturn 0;\n\t \n\tif (sock_cookie == *val)\n\t\tbpf_sock_destroy((struct sock_common *)sk);\n\n\treturn 0;\n}\n\nSEC(\"iter/udp\")\nint iter_udp6_server(struct bpf_iter__udp *ctx)\n{\n\tstruct udp_sock *udp_sk = ctx->udp_sk;\n\tstruct sock *sk = (struct sock *) udp_sk;\n\tstruct inet_sock *inet;\n\t__be16 srcp;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tinet = &udp_sk->inet;\n\tsrcp = inet->inet_sport;\n\tif (srcp == serv_port)\n\t\tbpf_sock_destroy((struct sock_common *)sk);\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}