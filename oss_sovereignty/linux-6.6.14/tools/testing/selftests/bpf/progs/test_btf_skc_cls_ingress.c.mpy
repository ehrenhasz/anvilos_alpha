{
  "module_name": "test_btf_skc_cls_ingress.c",
  "hash_id": "13f271bbfb299821b73ff6f1062d16188bee62d7926115d91082e46c9087a803",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_btf_skc_cls_ingress.c",
  "human_readable_source": "\n \n\n#include <string.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <linux/stddef.h>\n#include <linux/bpf.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/if_ether.h>\n#include <linux/pkt_cls.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"bpf_tcp_helpers.h\"\n\nstruct sockaddr_in6 srv_sa6 = {};\n__u16 listen_tp_sport = 0;\n__u16 req_sk_sport = 0;\n__u32 recv_cookie = 0;\n__u32 gen_cookie = 0;\n__u32 linum = 0;\n\n#define LOG() ({ if (!linum) linum = __LINE__; })\n\nstatic void test_syncookie_helper(struct ipv6hdr *ip6h, struct tcphdr *th,\n\t\t\t\t  struct tcp_sock *tp,\n\t\t\t\t  struct __sk_buff *skb)\n{\n\tif (th->syn) {\n\t\t__s64 mss_cookie;\n\t\tvoid *data_end;\n\n\t\tdata_end = (void *)(long)(skb->data_end);\n\n\t\tif (th->doff * 4 != 40) {\n\t\t\tLOG();\n\t\t\treturn;\n\t\t}\n\n\t\tif ((void *)th + 40 > data_end) {\n\t\t\tLOG();\n\t\t\treturn;\n\t\t}\n\n\t\tmss_cookie = bpf_tcp_gen_syncookie(tp, ip6h, sizeof(*ip6h),\n\t\t\t\t\t\t   th, 40);\n\t\tif (mss_cookie < 0) {\n\t\t\tif (mss_cookie != -ENOENT)\n\t\t\t\tLOG();\n\t\t} else {\n\t\t\tgen_cookie = (__u32)mss_cookie;\n\t\t}\n\t} else if (gen_cookie) {\n\t\t \n\t\tint ret = bpf_tcp_check_syncookie(tp, ip6h, sizeof(*ip6h),\n\t\t\t\t\t\t  th, sizeof(*th));\n\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOENT)\n\t\t\t\tLOG();\n\t\t} else {\n\t\t\trecv_cookie = bpf_ntohl(th->ack_seq) - 1;\n\t\t}\n\t}\n}\n\nstatic int handle_ip6_tcp(struct ipv6hdr *ip6h, struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple *tuple;\n\tstruct bpf_sock *bpf_skc;\n\tunsigned int tuple_len;\n\tstruct tcphdr *th;\n\tvoid *data_end;\n\n\tdata_end = (void *)(long)(skb->data_end);\n\n\tth = (struct tcphdr *)(ip6h + 1);\n\tif (th + 1 > data_end)\n\t\treturn TC_ACT_OK;\n\n\t \n\tif (th->dest != srv_sa6.sin6_port)\n\t\treturn TC_ACT_OK;\n\n\ttuple_len = sizeof(tuple->ipv6);\n\ttuple = (struct bpf_sock_tuple *)&ip6h->saddr;\n\tif ((void *)tuple + tuple_len > data_end) {\n\t\tLOG();\n\t\treturn TC_ACT_OK;\n\t}\n\n\tbpf_skc = bpf_skc_lookup_tcp(skb, tuple, tuple_len,\n\t\t\t\t     BPF_F_CURRENT_NETNS, 0);\n\tif (!bpf_skc) {\n\t\tLOG();\n\t\treturn TC_ACT_OK;\n\t}\n\n\tif (bpf_skc->state == BPF_TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req_sk;\n\n\t\treq_sk = (struct request_sock *)bpf_skc_to_tcp_request_sock(bpf_skc);\n\t\tif (!req_sk) {\n\t\t\tLOG();\n\t\t\tgoto release;\n\t\t}\n\n\t\tif (bpf_sk_assign(skb, req_sk, 0)) {\n\t\t\tLOG();\n\t\t\tgoto release;\n\t\t}\n\n\t\treq_sk_sport = req_sk->__req_common.skc_num;\n\n\t\tbpf_sk_release(req_sk);\n\t\treturn TC_ACT_OK;\n\t} else if (bpf_skc->state == BPF_TCP_LISTEN) {\n\t\tstruct tcp_sock *tp;\n\n\t\ttp = bpf_skc_to_tcp_sock(bpf_skc);\n\t\tif (!tp) {\n\t\t\tLOG();\n\t\t\tgoto release;\n\t\t}\n\n\t\tif (bpf_sk_assign(skb, tp, 0)) {\n\t\t\tLOG();\n\t\t\tgoto release;\n\t\t}\n\n\t\tlisten_tp_sport = tp->inet_conn.icsk_inet.sk.__sk_common.skc_num;\n\n\t\ttest_syncookie_helper(ip6h, th, tp, skb);\n\t\tbpf_sk_release(tp);\n\t\treturn TC_ACT_OK;\n\t}\n\n\tif (bpf_sk_assign(skb, bpf_skc, 0))\n\t\tLOG();\n\nrelease:\n\tbpf_sk_release(bpf_skc);\n\treturn TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint cls_ingress(struct __sk_buff *skb)\n{\n\tstruct ipv6hdr *ip6h;\n\tstruct ethhdr *eth;\n\tvoid *data_end;\n\n\tdata_end = (void *)(long)(skb->data_end);\n\n\teth = (struct ethhdr *)(long)(skb->data);\n\tif (eth + 1 > data_end)\n\t\treturn TC_ACT_OK;\n\n\tif (eth->h_proto != bpf_htons(ETH_P_IPV6))\n\t\treturn TC_ACT_OK;\n\n\tip6h = (struct ipv6hdr *)(eth + 1);\n\tif (ip6h + 1 > data_end)\n\t\treturn TC_ACT_OK;\n\n\tif (ip6h->nexthdr == IPPROTO_TCP)\n\t\treturn handle_ip6_tcp(ip6h, skb);\n\n\treturn TC_ACT_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}