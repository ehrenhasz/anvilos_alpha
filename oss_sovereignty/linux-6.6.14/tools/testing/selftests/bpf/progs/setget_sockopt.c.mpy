{
  "module_name": "setget_sockopt.c",
  "hash_id": "a2e0a5c45b0b6f15b6f1ca587f48ca7a26d3722d280db04c90c127054e9c814a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/setget_sockopt.c",
  "human_readable_source": "\n \n\n#include \"vmlinux.h\"\n#include \"bpf_tracing_net.h\"\n#include <bpf/bpf_core_read.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n#endif\n\nextern unsigned long CONFIG_HZ __kconfig;\n\nconst volatile char veth[IFNAMSIZ];\nconst volatile int veth_ifindex;\n\nint nr_listen;\nint nr_passive;\nint nr_active;\nint nr_connect;\nint nr_binddev;\nint nr_socket_post_create;\nint nr_fin_wait1;\n\nstruct sockopt_test {\n\tint opt;\n\tint new;\n\tint restore;\n\tint expected;\n\tint tcp_expected;\n\tunsigned int flip:1;\n};\n\nstatic const char not_exist_cc[] = \"not_exist\";\nstatic const char cubic_cc[] = \"cubic\";\nstatic const char reno_cc[] = \"reno\";\n\nstatic const struct sockopt_test sol_socket_tests[] = {\n\t{ .opt = SO_REUSEADDR, .flip = 1, },\n\t{ .opt = SO_SNDBUF, .new = 8123, .expected = 8123 * 2, },\n\t{ .opt = SO_RCVBUF, .new = 8123, .expected = 8123 * 2, },\n\t{ .opt = SO_KEEPALIVE, .flip = 1, },\n\t{ .opt = SO_PRIORITY, .new = 0xeb9f, .expected = 0xeb9f, },\n\t{ .opt = SO_REUSEPORT, .flip = 1, },\n\t{ .opt = SO_RCVLOWAT, .new = 8123, .expected = 8123, },\n\t{ .opt = SO_MARK, .new = 0xeb9f, .expected = 0xeb9f, },\n\t{ .opt = SO_MAX_PACING_RATE, .new = 0xeb9f, .expected = 0xeb9f, },\n\t{ .opt = SO_TXREHASH, .flip = 1, },\n\t{ .opt = 0, },\n};\n\nstatic const struct sockopt_test sol_tcp_tests[] = {\n\t{ .opt = TCP_NODELAY, .flip = 1, },\n\t{ .opt = TCP_KEEPIDLE, .new = 123, .expected = 123, .restore = 321, },\n\t{ .opt = TCP_KEEPINTVL, .new = 123, .expected = 123, .restore = 321, },\n\t{ .opt = TCP_KEEPCNT, .new = 123, .expected = 123, .restore = 124, },\n\t{ .opt = TCP_SYNCNT, .new = 123, .expected = 123, .restore = 124, },\n\t{ .opt = TCP_WINDOW_CLAMP, .new = 8123, .expected = 8123, .restore = 8124, },\n\t{ .opt = TCP_CONGESTION, },\n\t{ .opt = TCP_THIN_LINEAR_TIMEOUTS, .flip = 1, },\n\t{ .opt = TCP_USER_TIMEOUT, .new = 123400, .expected = 123400, },\n\t{ .opt = TCP_NOTSENT_LOWAT, .new = 1314, .expected = 1314, },\n\t{ .opt = 0, },\n};\n\nstatic const struct sockopt_test sol_ip_tests[] = {\n\t{ .opt = IP_TOS, .new = 0xe1, .expected = 0xe1, .tcp_expected = 0xe0, },\n\t{ .opt = 0, },\n};\n\nstatic const struct sockopt_test sol_ipv6_tests[] = {\n\t{ .opt = IPV6_TCLASS, .new = 0xe1, .expected = 0xe1, .tcp_expected = 0xe0, },\n\t{ .opt = IPV6_AUTOFLOWLABEL, .flip = 1, },\n\t{ .opt = 0, },\n};\n\nstruct loop_ctx {\n\tvoid *ctx;\n\tstruct sock *sk;\n};\n\nstatic int bpf_test_sockopt_flip(void *ctx, struct sock *sk,\n\t\t\t\t const struct sockopt_test *t,\n\t\t\t\t int level)\n{\n\tint old, tmp, new, opt = t->opt;\n\n\topt = t->opt;\n\n\tif (bpf_getsockopt(ctx, level, opt, &old, sizeof(old)))\n\t\treturn 1;\n\t \n\tif (level == SOL_SOCKET && opt == SO_TXREHASH && old != 0 && old != 1)\n\t\told = 1;\n\n\tnew = !old;\n\tif (bpf_setsockopt(ctx, level, opt, &new, sizeof(new)))\n\t\treturn 1;\n\tif (bpf_getsockopt(ctx, level, opt, &tmp, sizeof(tmp)) ||\n\t    tmp != new)\n\t\treturn 1;\n\n\tif (bpf_setsockopt(ctx, level, opt, &old, sizeof(old)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int bpf_test_sockopt_int(void *ctx, struct sock *sk,\n\t\t\t\tconst struct sockopt_test *t,\n\t\t\t\tint level)\n{\n\tint old, tmp, new, expected, opt;\n\n\topt = t->opt;\n\tnew = t->new;\n\tif (sk->sk_type == SOCK_STREAM && t->tcp_expected)\n\t\texpected = t->tcp_expected;\n\telse\n\t\texpected = t->expected;\n\n\tif (bpf_getsockopt(ctx, level, opt, &old, sizeof(old)) ||\n\t    old == new)\n\t\treturn 1;\n\n\tif (bpf_setsockopt(ctx, level, opt, &new, sizeof(new)))\n\t\treturn 1;\n\tif (bpf_getsockopt(ctx, level, opt, &tmp, sizeof(tmp)) ||\n\t    tmp != expected)\n\t\treturn 1;\n\n\tif (t->restore)\n\t\told = t->restore;\n\tif (bpf_setsockopt(ctx, level, opt, &old, sizeof(old)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int bpf_test_socket_sockopt(__u32 i, struct loop_ctx *lc)\n{\n\tconst struct sockopt_test *t;\n\n\tif (i >= ARRAY_SIZE(sol_socket_tests))\n\t\treturn 1;\n\n\tt = &sol_socket_tests[i];\n\tif (!t->opt)\n\t\treturn 1;\n\n\tif (t->flip)\n\t\treturn bpf_test_sockopt_flip(lc->ctx, lc->sk, t, SOL_SOCKET);\n\n\treturn bpf_test_sockopt_int(lc->ctx, lc->sk, t, SOL_SOCKET);\n}\n\nstatic int bpf_test_ip_sockopt(__u32 i, struct loop_ctx *lc)\n{\n\tconst struct sockopt_test *t;\n\n\tif (i >= ARRAY_SIZE(sol_ip_tests))\n\t\treturn 1;\n\n\tt = &sol_ip_tests[i];\n\tif (!t->opt)\n\t\treturn 1;\n\n\tif (t->flip)\n\t\treturn bpf_test_sockopt_flip(lc->ctx, lc->sk, t, IPPROTO_IP);\n\n\treturn bpf_test_sockopt_int(lc->ctx, lc->sk, t, IPPROTO_IP);\n}\n\nstatic int bpf_test_ipv6_sockopt(__u32 i, struct loop_ctx *lc)\n{\n\tconst struct sockopt_test *t;\n\n\tif (i >= ARRAY_SIZE(sol_ipv6_tests))\n\t\treturn 1;\n\n\tt = &sol_ipv6_tests[i];\n\tif (!t->opt)\n\t\treturn 1;\n\n\tif (t->flip)\n\t\treturn bpf_test_sockopt_flip(lc->ctx, lc->sk, t, IPPROTO_IPV6);\n\n\treturn bpf_test_sockopt_int(lc->ctx, lc->sk, t, IPPROTO_IPV6);\n}\n\nstatic int bpf_test_tcp_sockopt(__u32 i, struct loop_ctx *lc)\n{\n\tconst struct sockopt_test *t;\n\tstruct sock *sk;\n\tvoid *ctx;\n\n\tif (i >= ARRAY_SIZE(sol_tcp_tests))\n\t\treturn 1;\n\n\tt = &sol_tcp_tests[i];\n\tif (!t->opt)\n\t\treturn 1;\n\n\tctx = lc->ctx;\n\tsk = lc->sk;\n\n\tif (t->opt == TCP_CONGESTION) {\n\t\tchar old_cc[16], tmp_cc[16];\n\t\tconst char *new_cc;\n\t\tint new_cc_len;\n\n\t\tif (!bpf_setsockopt(ctx, IPPROTO_TCP, TCP_CONGESTION,\n\t\t\t\t    (void *)not_exist_cc, sizeof(not_exist_cc)))\n\t\t\treturn 1;\n\t\tif (bpf_getsockopt(ctx, IPPROTO_TCP, TCP_CONGESTION, old_cc, sizeof(old_cc)))\n\t\t\treturn 1;\n\t\tif (!bpf_strncmp(old_cc, sizeof(old_cc), cubic_cc)) {\n\t\t\tnew_cc = reno_cc;\n\t\t\tnew_cc_len = sizeof(reno_cc);\n\t\t} else {\n\t\t\tnew_cc = cubic_cc;\n\t\t\tnew_cc_len = sizeof(cubic_cc);\n\t\t}\n\t\tif (bpf_setsockopt(ctx, IPPROTO_TCP, TCP_CONGESTION, (void *)new_cc,\n\t\t\t\t   new_cc_len))\n\t\t\treturn 1;\n\t\tif (bpf_getsockopt(ctx, IPPROTO_TCP, TCP_CONGESTION, tmp_cc, sizeof(tmp_cc)))\n\t\t\treturn 1;\n\t\tif (bpf_strncmp(tmp_cc, sizeof(tmp_cc), new_cc))\n\t\t\treturn 1;\n\t\tif (bpf_setsockopt(ctx, IPPROTO_TCP, TCP_CONGESTION, old_cc, sizeof(old_cc)))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (t->flip)\n\t\treturn bpf_test_sockopt_flip(ctx, sk, t, IPPROTO_TCP);\n\n\treturn bpf_test_sockopt_int(ctx, sk, t, IPPROTO_TCP);\n}\n\nstatic int bpf_test_sockopt(void *ctx, struct sock *sk)\n{\n\tstruct loop_ctx lc = { .ctx = ctx, .sk = sk, };\n\t__u16 family, proto;\n\tint n;\n\n\tfamily = sk->sk_family;\n\tproto = sk->sk_protocol;\n\n\tn = bpf_loop(ARRAY_SIZE(sol_socket_tests), bpf_test_socket_sockopt, &lc, 0);\n\tif (n != ARRAY_SIZE(sol_socket_tests))\n\t\treturn -1;\n\n\tif (proto == IPPROTO_TCP) {\n\t\tn = bpf_loop(ARRAY_SIZE(sol_tcp_tests), bpf_test_tcp_sockopt, &lc, 0);\n\t\tif (n != ARRAY_SIZE(sol_tcp_tests))\n\t\t\treturn -1;\n\t}\n\n\tif (family == AF_INET) {\n\t\tn = bpf_loop(ARRAY_SIZE(sol_ip_tests), bpf_test_ip_sockopt, &lc, 0);\n\t\tif (n != ARRAY_SIZE(sol_ip_tests))\n\t\t\treturn -1;\n\t} else {\n\t\tn = bpf_loop(ARRAY_SIZE(sol_ipv6_tests), bpf_test_ipv6_sockopt, &lc, 0);\n\t\tif (n != ARRAY_SIZE(sol_ipv6_tests))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int binddev_test(void *ctx)\n{\n\tconst char empty_ifname[] = \"\";\n\tint ifindex, zero = 0;\n\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t   (void *)veth, sizeof(veth)))\n\t\treturn -1;\n\tif (bpf_getsockopt(ctx, SOL_SOCKET, SO_BINDTOIFINDEX,\n\t\t\t   &ifindex, sizeof(int)) ||\n\t    ifindex != veth_ifindex)\n\t\treturn -1;\n\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t   (void *)empty_ifname, sizeof(empty_ifname)))\n\t\treturn -1;\n\tif (bpf_getsockopt(ctx, SOL_SOCKET, SO_BINDTOIFINDEX,\n\t\t\t   &ifindex, sizeof(int)) ||\n\t    ifindex != 0)\n\t\treturn -1;\n\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTOIFINDEX,\n\t\t\t   (void *)&veth_ifindex, sizeof(int)))\n\t\treturn -1;\n\tif (bpf_getsockopt(ctx, SOL_SOCKET, SO_BINDTOIFINDEX,\n\t\t\t   &ifindex, sizeof(int)) ||\n\t    ifindex != veth_ifindex)\n\t\treturn -1;\n\n\tif (bpf_setsockopt(ctx, SOL_SOCKET, SO_BINDTOIFINDEX,\n\t\t\t   &zero, sizeof(int)))\n\t\treturn -1;\n\tif (bpf_getsockopt(ctx, SOL_SOCKET, SO_BINDTOIFINDEX,\n\t\t\t   &ifindex, sizeof(int)) ||\n\t    ifindex != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int test_tcp_maxseg(void *ctx, struct sock *sk)\n{\n\tint val = 1314, tmp;\n\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn bpf_setsockopt(ctx, IPPROTO_TCP, TCP_MAXSEG,\n\t\t\t\t      &val, sizeof(val));\n\n\tif (bpf_getsockopt(ctx, IPPROTO_TCP, TCP_MAXSEG, &tmp, sizeof(tmp)) ||\n\t    tmp > val)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int test_tcp_saved_syn(void *ctx, struct sock *sk)\n{\n\t__u8 saved_syn[20];\n\tint one = 1;\n\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn bpf_setsockopt(ctx, IPPROTO_TCP, TCP_SAVE_SYN,\n\t\t\t\t      &one, sizeof(one));\n\n\treturn bpf_getsockopt(ctx, IPPROTO_TCP, TCP_SAVED_SYN,\n\t\t\t      saved_syn, sizeof(saved_syn));\n}\n\nSEC(\"lsm_cgroup/socket_post_create\")\nint BPF_PROG(socket_post_create, struct socket *sock, int family,\n\t     int type, int protocol, int kern)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\treturn 1;\n\n\tnr_socket_post_create += !bpf_test_sockopt(sk, sk);\n\tnr_binddev += !binddev_test(sk);\n\n\treturn 1;\n}\n\nSEC(\"sockops\")\nint skops_sockopt(struct bpf_sock_ops *skops)\n{\n\tstruct bpf_sock *bpf_sk = skops->sk;\n\tstruct sock *sk;\n\n\tif (!bpf_sk)\n\t\treturn 1;\n\n\tsk = (struct sock *)bpf_skc_to_tcp_sock(bpf_sk);\n\tif (!sk)\n\t\treturn 1;\n\n\tswitch (skops->op) {\n\tcase BPF_SOCK_OPS_TCP_LISTEN_CB:\n\t\tnr_listen += !(bpf_test_sockopt(skops, sk) ||\n\t\t\t       test_tcp_maxseg(skops, sk) ||\n\t\t\t       test_tcp_saved_syn(skops, sk));\n\t\tbreak;\n\tcase BPF_SOCK_OPS_TCP_CONNECT_CB:\n\t\tnr_connect += !(bpf_test_sockopt(skops, sk) ||\n\t\t\t\ttest_tcp_maxseg(skops, sk));\n\t\tbreak;\n\tcase BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:\n\t\tnr_active += !(bpf_test_sockopt(skops, sk) ||\n\t\t\t       test_tcp_maxseg(skops, sk));\n\t\tbreak;\n\tcase BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB:\n\t\tnr_passive += !(bpf_test_sockopt(skops, sk) ||\n\t\t\t\ttest_tcp_maxseg(skops, sk) ||\n\t\t\t\ttest_tcp_saved_syn(skops, sk));\n\t\tbpf_sock_ops_cb_flags_set(skops,\n\t\t\t\t\t  skops->bpf_sock_ops_cb_flags |\n\t\t\t\t\t  BPF_SOCK_OPS_STATE_CB_FLAG);\n\t\tbreak;\n\tcase BPF_SOCK_OPS_STATE_CB:\n\t\tif (skops->args[1] == BPF_TCP_CLOSE_WAIT)\n\t\t\tnr_fin_wait1 += !bpf_test_sockopt(skops, sk);\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}