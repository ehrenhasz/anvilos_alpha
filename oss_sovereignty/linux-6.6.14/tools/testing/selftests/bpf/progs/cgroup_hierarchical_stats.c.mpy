{
  "module_name": "cgroup_hierarchical_stats.c",
  "hash_id": "8e41a115d9f44451250f37e4d60f826479143cc57657077462dbd9f7cfb11e6b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/cgroup_hierarchical_stats.c",
  "human_readable_source": "\n \n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct percpu_attach_counter {\n\t \n\t__u64 prev;\n\t \n\t__u64 state;\n};\n\nstruct attach_counter {\n\t \n\t__u64 pending;\n\t \n\t__u64 state;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_HASH);\n\t__uint(max_entries, 1024);\n\t__type(key, __u64);\n\t__type(value, struct percpu_attach_counter);\n} percpu_attach_counters SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1024);\n\t__type(key, __u64);\n\t__type(value, struct attach_counter);\n} attach_counters SEC(\".maps\");\n\nextern void cgroup_rstat_updated(struct cgroup *cgrp, int cpu) __ksym;\nextern void cgroup_rstat_flush(struct cgroup *cgrp) __ksym;\n\nstatic uint64_t cgroup_id(struct cgroup *cgrp)\n{\n\treturn cgrp->kn->id;\n}\n\nstatic int create_percpu_attach_counter(__u64 cg_id, __u64 state)\n{\n\tstruct percpu_attach_counter pcpu_init = {.state = state, .prev = 0};\n\n\treturn bpf_map_update_elem(&percpu_attach_counters, &cg_id,\n\t\t\t\t   &pcpu_init, BPF_NOEXIST);\n}\n\nstatic int create_attach_counter(__u64 cg_id, __u64 state, __u64 pending)\n{\n\tstruct attach_counter init = {.state = state, .pending = pending};\n\n\treturn bpf_map_update_elem(&attach_counters, &cg_id,\n\t\t\t\t   &init, BPF_NOEXIST);\n}\n\nSEC(\"fentry/cgroup_attach_task\")\nint BPF_PROG(counter, struct cgroup *dst_cgrp, struct task_struct *leader,\n\t     bool threadgroup)\n{\n\t__u64 cg_id = cgroup_id(dst_cgrp);\n\tstruct percpu_attach_counter *pcpu_counter = bpf_map_lookup_elem(\n\t\t\t&percpu_attach_counters,\n\t\t\t&cg_id);\n\n\tif (pcpu_counter)\n\t\tpcpu_counter->state += 1;\n\telse if (create_percpu_attach_counter(cg_id, 1))\n\t\treturn 0;\n\n\tcgroup_rstat_updated(dst_cgrp, bpf_get_smp_processor_id());\n\treturn 0;\n}\n\nSEC(\"fentry/bpf_rstat_flush\")\nint BPF_PROG(flusher, struct cgroup *cgrp, struct cgroup *parent, int cpu)\n{\n\tstruct percpu_attach_counter *pcpu_counter;\n\tstruct attach_counter *total_counter, *parent_counter;\n\t__u64 cg_id = cgroup_id(cgrp);\n\t__u64 parent_cg_id = parent ? cgroup_id(parent) : 0;\n\t__u64 state;\n\t__u64 delta = 0;\n\n\t \n\tpcpu_counter = bpf_map_lookup_percpu_elem(&percpu_attach_counters,\n\t\t\t\t\t\t  &cg_id, cpu);\n\tif (pcpu_counter) {\n\t\tstate = pcpu_counter->state;\n\t\tdelta += state - pcpu_counter->prev;\n\t\tpcpu_counter->prev = state;\n\t}\n\n\ttotal_counter = bpf_map_lookup_elem(&attach_counters, &cg_id);\n\tif (!total_counter) {\n\t\tif (create_attach_counter(cg_id, delta, 0))\n\t\t\treturn 0;\n\t\tgoto update_parent;\n\t}\n\n\t \n\tif (total_counter->pending) {\n\t\tdelta += total_counter->pending;\n\t\ttotal_counter->pending = 0;\n\t}\n\n\t \n\ttotal_counter->state += delta;\n\nupdate_parent:\n\t \n\tif (!delta || !parent_cg_id)\n\t\treturn 0;\n\n\t \n\tparent_counter = bpf_map_lookup_elem(&attach_counters,\n\t\t\t\t\t     &parent_cg_id);\n\tif (parent_counter)\n\t\tparent_counter->pending += delta;\n\telse\n\t\tcreate_attach_counter(parent_cg_id, 0, delta);\n\treturn 0;\n}\n\nSEC(\"iter.s/cgroup\")\nint BPF_PROG(dumper, struct bpf_iter_meta *meta, struct cgroup *cgrp)\n{\n\tstruct seq_file *seq = meta->seq;\n\tstruct attach_counter *total_counter;\n\t__u64 cg_id = cgrp ? cgroup_id(cgrp) : 0;\n\n\t \n\tif (!cg_id)\n\t\treturn 1;\n\n\t \n\tcgroup_rstat_flush(cgrp);\n\n\ttotal_counter = bpf_map_lookup_elem(&attach_counters, &cg_id);\n\tif (!total_counter) {\n\t\tBPF_SEQ_PRINTF(seq, \"cg_id: %llu, attach_counter: 0\\n\",\n\t\t\t       cg_id);\n\t} else {\n\t\tBPF_SEQ_PRINTF(seq, \"cg_id: %llu, attach_counter: %llu\\n\",\n\t\t\t       cg_id, total_counter->state);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}