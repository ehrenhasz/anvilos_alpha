{
  "module_name": "linked_list.c",
  "hash_id": "688f94fd69fe51388644a66bd83d346b5a86f9fcf5bc6712cd044d90ae363f5a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/linked_list.c",
  "human_readable_source": "\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_experimental.h\"\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n#endif\n\n#include \"linked_list.h\"\n\nstatic __always_inline\nint list_push_pop(struct bpf_spin_lock *lock, struct bpf_list_head *head, bool leave_in_map)\n{\n\tstruct bpf_list_node *n;\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 2;\n\n\tbpf_spin_lock(lock);\n\tn = bpf_list_pop_front(head);\n\tbpf_spin_unlock(lock);\n\tif (n) {\n\t\tbpf_obj_drop(container_of(n, struct foo, node2));\n\t\tbpf_obj_drop(f);\n\t\treturn 3;\n\t}\n\n\tbpf_spin_lock(lock);\n\tn = bpf_list_pop_back(head);\n\tbpf_spin_unlock(lock);\n\tif (n) {\n\t\tbpf_obj_drop(container_of(n, struct foo, node2));\n\t\tbpf_obj_drop(f);\n\t\treturn 4;\n\t}\n\n\n\tbpf_spin_lock(lock);\n\tf->data = 42;\n\tbpf_list_push_front(head, &f->node2);\n\tbpf_spin_unlock(lock);\n\tif (leave_in_map)\n\t\treturn 0;\n\tbpf_spin_lock(lock);\n\tn = bpf_list_pop_back(head);\n\tbpf_spin_unlock(lock);\n\tif (!n)\n\t\treturn 5;\n\tf = container_of(n, struct foo, node2);\n\tif (f->data != 42) {\n\t\tbpf_obj_drop(f);\n\t\treturn 6;\n\t}\n\n\tbpf_spin_lock(lock);\n\tf->data = 13;\n\tbpf_list_push_front(head, &f->node2);\n\tbpf_spin_unlock(lock);\n\tbpf_spin_lock(lock);\n\tn = bpf_list_pop_front(head);\n\tbpf_spin_unlock(lock);\n\tif (!n)\n\t\treturn 7;\n\tf = container_of(n, struct foo, node2);\n\tif (f->data != 13) {\n\t\tbpf_obj_drop(f);\n\t\treturn 8;\n\t}\n\tbpf_obj_drop(f);\n\n\tbpf_spin_lock(lock);\n\tn = bpf_list_pop_front(head);\n\tbpf_spin_unlock(lock);\n\tif (n) {\n\t\tbpf_obj_drop(container_of(n, struct foo, node2));\n\t\treturn 9;\n\t}\n\n\tbpf_spin_lock(lock);\n\tn = bpf_list_pop_back(head);\n\tbpf_spin_unlock(lock);\n\tif (n) {\n\t\tbpf_obj_drop(container_of(n, struct foo, node2));\n\t\treturn 10;\n\t}\n\treturn 0;\n}\n\n\nstatic __always_inline\nint list_push_pop_multiple(struct bpf_spin_lock *lock, struct bpf_list_head *head, bool leave_in_map)\n{\n\tstruct bpf_list_node *n;\n\tstruct foo *f[200], *pf;\n\tint i;\n\n\t \n\tif (ARRAY_SIZE(f) % 2)\n\t\treturn 10;\n\n\tfor (i = 0; i < ARRAY_SIZE(f); i += 2) {\n\t\tf[i] = bpf_obj_new(typeof(**f));\n\t\tif (!f[i])\n\t\t\treturn 2;\n\t\tf[i]->data = i;\n\n\t\tf[i + 1] = bpf_obj_new(typeof(**f));\n\t\tif (!f[i + 1]) {\n\t\t\tbpf_obj_drop(f[i]);\n\t\t\treturn 9;\n\t\t}\n\t\tf[i + 1]->data = i + 1;\n\n\t\tbpf_spin_lock(lock);\n\t\tbpf_list_push_front(head, &f[i]->node2);\n\t\tbpf_list_push_front(head, &f[i + 1]->node2);\n\t\tbpf_spin_unlock(lock);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(f); i++) {\n\t\tbpf_spin_lock(lock);\n\t\tn = bpf_list_pop_front(head);\n\t\tbpf_spin_unlock(lock);\n\t\tif (!n)\n\t\t\treturn 3;\n\t\tpf = container_of(n, struct foo, node2);\n\t\tif (pf->data != (ARRAY_SIZE(f) - i - 1)) {\n\t\t\tbpf_obj_drop(pf);\n\t\t\treturn 4;\n\t\t}\n\t\tbpf_spin_lock(lock);\n\t\tbpf_list_push_back(head, &pf->node2);\n\t\tbpf_spin_unlock(lock);\n\t}\n\n\tif (leave_in_map)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(f); i++) {\n\t\tbpf_spin_lock(lock);\n\t\tn = bpf_list_pop_back(head);\n\t\tbpf_spin_unlock(lock);\n\t\tif (!n)\n\t\t\treturn 5;\n\t\tpf = container_of(n, struct foo, node2);\n\t\tif (pf->data != i) {\n\t\t\tbpf_obj_drop(pf);\n\t\t\treturn 6;\n\t\t}\n\t\tbpf_obj_drop(pf);\n\t}\n\tbpf_spin_lock(lock);\n\tn = bpf_list_pop_back(head);\n\tbpf_spin_unlock(lock);\n\tif (n) {\n\t\tbpf_obj_drop(container_of(n, struct foo, node2));\n\t\treturn 7;\n\t}\n\n\tbpf_spin_lock(lock);\n\tn = bpf_list_pop_front(head);\n\tbpf_spin_unlock(lock);\n\tif (n) {\n\t\tbpf_obj_drop(container_of(n, struct foo, node2));\n\t\treturn 8;\n\t}\n\treturn 0;\n}\n\nstatic __always_inline\nint list_in_list(struct bpf_spin_lock *lock, struct bpf_list_head *head, bool leave_in_map)\n{\n\tstruct bpf_list_node *n;\n\tstruct bar *ba[8], *b;\n\tstruct foo *f;\n\tint i;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 2;\n\tfor (i = 0; i < ARRAY_SIZE(ba); i++) {\n\t\tb = bpf_obj_new(typeof(*b));\n\t\tif (!b) {\n\t\t\tbpf_obj_drop(f);\n\t\t\treturn 3;\n\t\t}\n\t\tb->data = i;\n\t\tbpf_spin_lock(&f->lock);\n\t\tbpf_list_push_back(&f->head, &b->node);\n\t\tbpf_spin_unlock(&f->lock);\n\t}\n\n\tbpf_spin_lock(lock);\n\tf->data = 42;\n\tbpf_list_push_front(head, &f->node2);\n\tbpf_spin_unlock(lock);\n\n\tif (leave_in_map)\n\t\treturn 0;\n\n\tbpf_spin_lock(lock);\n\tn = bpf_list_pop_front(head);\n\tbpf_spin_unlock(lock);\n\tif (!n)\n\t\treturn 4;\n\tf = container_of(n, struct foo, node2);\n\tif (f->data != 42) {\n\t\tbpf_obj_drop(f);\n\t\treturn 5;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ba); i++) {\n\t\tbpf_spin_lock(&f->lock);\n\t\tn = bpf_list_pop_front(&f->head);\n\t\tbpf_spin_unlock(&f->lock);\n\t\tif (!n) {\n\t\t\tbpf_obj_drop(f);\n\t\t\treturn 6;\n\t\t}\n\t\tb = container_of(n, struct bar, node);\n\t\tif (b->data != i) {\n\t\t\tbpf_obj_drop(f);\n\t\t\tbpf_obj_drop(b);\n\t\t\treturn 7;\n\t\t}\n\t\tbpf_obj_drop(b);\n\t}\n\tbpf_spin_lock(&f->lock);\n\tn = bpf_list_pop_front(&f->head);\n\tbpf_spin_unlock(&f->lock);\n\tif (n) {\n\t\tbpf_obj_drop(f);\n\t\tbpf_obj_drop(container_of(n, struct bar, node));\n\t\treturn 8;\n\t}\n\tbpf_obj_drop(f);\n\treturn 0;\n}\n\nstatic __always_inline\nint test_list_push_pop(struct bpf_spin_lock *lock, struct bpf_list_head *head)\n{\n\tint ret;\n\n\tret = list_push_pop(lock, head, false);\n\tif (ret)\n\t\treturn ret;\n\treturn list_push_pop(lock, head, true);\n}\n\nstatic __always_inline\nint test_list_push_pop_multiple(struct bpf_spin_lock *lock, struct bpf_list_head *head)\n{\n\tint ret;\n\n\tret = list_push_pop_multiple(lock, head, false);\n\tif (ret)\n\t\treturn ret;\n\treturn list_push_pop_multiple(lock, head, true);\n}\n\nstatic __always_inline\nint test_list_in_list(struct bpf_spin_lock *lock, struct bpf_list_head *head)\n{\n\tint ret;\n\n\tret = list_in_list(lock, head, false);\n\tif (ret)\n\t\treturn ret;\n\treturn list_in_list(lock, head, true);\n}\n\nSEC(\"tc\")\nint map_list_push_pop(void *ctx)\n{\n\tstruct map_value *v;\n\n\tv = bpf_map_lookup_elem(&array_map, &(int){0});\n\tif (!v)\n\t\treturn 1;\n\treturn test_list_push_pop(&v->lock, &v->head);\n}\n\nSEC(\"tc\")\nint inner_map_list_push_pop(void *ctx)\n{\n\tstruct map_value *v;\n\tvoid *map;\n\n\tmap = bpf_map_lookup_elem(&map_of_maps, &(int){0});\n\tif (!map)\n\t\treturn 1;\n\tv = bpf_map_lookup_elem(map, &(int){0});\n\tif (!v)\n\t\treturn 1;\n\treturn test_list_push_pop(&v->lock, &v->head);\n}\n\nSEC(\"tc\")\nint global_list_push_pop(void *ctx)\n{\n\treturn test_list_push_pop(&glock, &ghead);\n}\n\nSEC(\"tc\")\nint map_list_push_pop_multiple(void *ctx)\n{\n\tstruct map_value *v;\n\n\tv = bpf_map_lookup_elem(&array_map, &(int){0});\n\tif (!v)\n\t\treturn 1;\n\treturn test_list_push_pop_multiple(&v->lock, &v->head);\n}\n\nSEC(\"tc\")\nint inner_map_list_push_pop_multiple(void *ctx)\n{\n\tstruct map_value *v;\n\tvoid *map;\n\n\tmap = bpf_map_lookup_elem(&map_of_maps, &(int){0});\n\tif (!map)\n\t\treturn 1;\n\tv = bpf_map_lookup_elem(map, &(int){0});\n\tif (!v)\n\t\treturn 1;\n\treturn test_list_push_pop_multiple(&v->lock, &v->head);\n}\n\nSEC(\"tc\")\nint global_list_push_pop_multiple(void *ctx)\n{\n\tint ret;\n\n\tret = list_push_pop_multiple(&glock, &ghead, false);\n\tif (ret)\n\t\treturn ret;\n\treturn list_push_pop_multiple(&glock, &ghead, true);\n}\n\nSEC(\"tc\")\nint map_list_in_list(void *ctx)\n{\n\tstruct map_value *v;\n\n\tv = bpf_map_lookup_elem(&array_map, &(int){0});\n\tif (!v)\n\t\treturn 1;\n\treturn test_list_in_list(&v->lock, &v->head);\n}\n\nSEC(\"tc\")\nint inner_map_list_in_list(void *ctx)\n{\n\tstruct map_value *v;\n\tvoid *map;\n\n\tmap = bpf_map_lookup_elem(&map_of_maps, &(int){0});\n\tif (!map)\n\t\treturn 1;\n\tv = bpf_map_lookup_elem(map, &(int){0});\n\tif (!v)\n\t\treturn 1;\n\treturn test_list_in_list(&v->lock, &v->head);\n}\n\nSEC(\"tc\")\nint global_list_in_list(void *ctx)\n{\n\treturn test_list_in_list(&glock, &ghead);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}