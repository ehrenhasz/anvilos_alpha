{
  "module_name": "test_lwt_ip_encap.c",
  "hash_id": "6283f4a2cf0c3dfe710740b847f67c0f34662ec55e3aad90b6c32096efdb64d3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_lwt_ip_encap.c",
  "human_readable_source": "\n#include <stddef.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\nstruct grehdr {\n\t__be16 flags;\n\t__be16 protocol;\n};\n\nSEC(\"encap_gre\")\nint bpf_lwt_encap_gre(struct __sk_buff *skb)\n{\n\tstruct encap_hdr {\n\t\tstruct iphdr iph;\n\t\tstruct grehdr greh;\n\t} hdr;\n\tint err;\n\n\tmemset(&hdr, 0, sizeof(struct encap_hdr));\n\n\thdr.iph.ihl = 5;\n\thdr.iph.version = 4;\n\thdr.iph.ttl = 0x40;\n\thdr.iph.protocol = 47;   \n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\thdr.iph.saddr = 0x640110ac;   \n\thdr.iph.daddr = 0x641010ac;   \n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\thdr.iph.saddr = 0xac100164;   \n\thdr.iph.daddr = 0xac101064;   \n#else\n#error \"Fix your compiler's __BYTE_ORDER__?!\"\n#endif\n\thdr.iph.tot_len = bpf_htons(skb->len + sizeof(struct encap_hdr));\n\n\thdr.greh.protocol = skb->protocol;\n\n\terr = bpf_lwt_push_encap(skb, BPF_LWT_ENCAP_IP, &hdr,\n\t\t\t\t sizeof(struct encap_hdr));\n\tif (err)\n\t\treturn BPF_DROP;\n\n\treturn BPF_LWT_REROUTE;\n}\n\nSEC(\"encap_gre6\")\nint bpf_lwt_encap_gre6(struct __sk_buff *skb)\n{\n\tstruct encap_hdr {\n\t\tstruct ipv6hdr ip6hdr;\n\t\tstruct grehdr greh;\n\t} hdr;\n\tint err;\n\n\tmemset(&hdr, 0, sizeof(struct encap_hdr));\n\n\thdr.ip6hdr.version = 6;\n\thdr.ip6hdr.payload_len = bpf_htons(skb->len + sizeof(struct grehdr));\n\thdr.ip6hdr.nexthdr = 47;   \n\thdr.ip6hdr.hop_limit = 0x40;\n\t \n\thdr.ip6hdr.saddr.s6_addr[0] = 0xfb;\n\thdr.ip6hdr.saddr.s6_addr[1] = 1;\n\thdr.ip6hdr.saddr.s6_addr[15] = 1;\n\t \n\thdr.ip6hdr.daddr.s6_addr[0] = 0xfb;\n\thdr.ip6hdr.daddr.s6_addr[1] = 0x10;\n\thdr.ip6hdr.daddr.s6_addr[15] = 1;\n\n\thdr.greh.protocol = skb->protocol;\n\n\terr = bpf_lwt_push_encap(skb, BPF_LWT_ENCAP_IP, &hdr,\n\t\t\t\t sizeof(struct encap_hdr));\n\tif (err)\n\t\treturn BPF_DROP;\n\n\treturn BPF_LWT_REROUTE;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}