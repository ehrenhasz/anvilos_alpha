{
  "module_name": "core_kern.c",
  "hash_id": "18277af5f527ed072719215cc6572404d8df1a422b3913e4686b9033070ac364",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/core_kern.c",
  "human_readable_source": "\n \n#include \"vmlinux.h\"\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\n#define ATTR __always_inline\n#include \"test_jhash.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, u32);\n\t__type(value, u32);\n\t__uint(max_entries, 256);\n} array1 SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, u32);\n\t__type(value, u32);\n\t__uint(max_entries, 256);\n} array2 SEC(\".maps\");\n\nstatic __noinline int randmap(int v, const struct net_device *dev)\n{\n\tstruct bpf_map *map = (struct bpf_map *)&array1;\n\tint key = bpf_get_prandom_u32() & 0xff;\n\tint *val;\n\n\tif (bpf_get_prandom_u32() & 1)\n\t\tmap = (struct bpf_map *)&array2;\n\n\tval = bpf_map_lookup_elem(map, &key);\n\tif (val)\n\t\t*val = bpf_get_prandom_u32() + v + dev->mtu;\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/xdp_devmap_xmit\")\nint BPF_PROG(tp_xdp_devmap_xmit_multi, const struct net_device\n\t     *from_dev, const struct net_device *to_dev, int sent, int drops,\n\t     int err)\n{\n\treturn randmap(from_dev->ifindex, from_dev);\n}\n\nSEC(\"fentry/eth_type_trans\")\nint BPF_PROG(fentry_eth_type_trans, struct sk_buff *skb,\n\t     struct net_device *dev, unsigned short protocol)\n{\n\treturn randmap(dev->ifindex + skb->len, dev);\n}\n\nSEC(\"fexit/eth_type_trans\")\nint BPF_PROG(fexit_eth_type_trans, struct sk_buff *skb,\n\t     struct net_device *dev, unsigned short protocol)\n{\n\treturn randmap(dev->ifindex + skb->len, dev);\n}\n\nvolatile const int never;\n\nstruct __sk_bUfF   {\n\tint len;\n} __attribute__((preserve_access_index));\n\nstruct bpf_testmod_test_read_ctx   {\n\tsize_t len;\n} __attribute__((preserve_access_index));\n\nSEC(\"tc\")\nint balancer_ingress(struct __sk_buff *ctx)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tvoid *ptr;\n\tint nh_off, i = 0;\n\n\tnh_off = 14;\n\n\t \n#define C do { \\\n\tptr = data + i; \\\n\tif (ptr + nh_off > data_end) \\\n\t\tbreak; \\\n\tctx->tc_index = jhash(ptr, nh_off, ctx->cb[0] + i++); \\\n\tif (never) { \\\n\t\t  \\\n\t\ti += ((struct __sk_bUfF *)ctx)->len; \\\n\t\t  \\\n\t\ti += ((struct bpf_testmod_test_read_ctx *)ctx)->len; \\\n\t} \\\n\t} while (0);\n#define C30 C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;C;\n\tC30;C30;C30;  \n\treturn 0;\n}\n\ntypedef int (*func_proto_typedef___match)(long);\ntypedef int (*func_proto_typedef___doesnt_match)(char *);\ntypedef int (*func_proto_typedef_nested1)(func_proto_typedef___match);\n\nint proto_out[3];\n\nSEC(\"raw_tracepoint/sys_enter\")\nint core_relo_proto(void *ctx)\n{\n\tproto_out[0] = bpf_core_type_exists(func_proto_typedef___match);\n\tproto_out[1] = bpf_core_type_exists(func_proto_typedef___doesnt_match);\n\tproto_out[2] = bpf_core_type_exists(func_proto_typedef_nested1);\n\n\treturn 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}