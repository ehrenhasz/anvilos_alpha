{
  "module_name": "test_xdp_noinline.c",
  "hash_id": "9ceb7b12b99973ceb6a7cef9914d7ff4ae8dcb9f23c7edb87264b97202aa082c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_xdp_noinline.c",
  "human_readable_source": "\n\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <linux/pkt_cls.h>\n#include <linux/bpf.h>\n#include <linux/in.h>\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\nstatic __always_inline __u32 rol32(__u32 word, unsigned int shift)\n{\n\treturn (word << shift) | (word >> ((-shift) & 31));\n}\n\n \n#define __jhash_mix(a, b, c)\t\t\t\\\n{\t\t\t\t\t\t\\\n\ta -= c;  a ^= rol32(c, 4);  c += b;\t\\\n\tb -= a;  b ^= rol32(a, 6);  a += c;\t\\\n\tc -= b;  c ^= rol32(b, 8);  b += a;\t\\\n\ta -= c;  a ^= rol32(c, 16); c += b;\t\\\n\tb -= a;  b ^= rol32(a, 19); a += c;\t\\\n\tc -= b;  c ^= rol32(b, 4);  b += a;\t\\\n}\n\n#define __jhash_final(a, b, c)\t\t\t\\\n{\t\t\t\t\t\t\\\n\tc ^= b; c -= rol32(b, 14);\t\t\\\n\ta ^= c; a -= rol32(c, 11);\t\t\\\n\tb ^= a; b -= rol32(a, 25);\t\t\\\n\tc ^= b; c -= rol32(b, 16);\t\t\\\n\ta ^= c; a -= rol32(c, 4);\t\t\\\n\tb ^= a; b -= rol32(a, 14);\t\t\\\n\tc ^= b; c -= rol32(b, 24);\t\t\\\n}\n\n#define JHASH_INITVAL\t\t0xdeadbeef\n\ntypedef unsigned int u32;\n\nstatic __noinline\nu32 jhash(const void *key, u32 length, u32 initval)\n{\n\tu32 a, b, c;\n\tconst unsigned char *k = key;\n\n\ta = b = c = JHASH_INITVAL + length + initval;\n\n\twhile (length > 12) {\n\t\ta += *(u32 *)(k);\n\t\tb += *(u32 *)(k + 4);\n\t\tc += *(u32 *)(k + 8);\n\t\t__jhash_mix(a, b, c);\n\t\tlength -= 12;\n\t\tk += 12;\n\t}\n\tswitch (length) {\n\tcase 12: c += (u32)k[11]<<24;\n\tcase 11: c += (u32)k[10]<<16;\n\tcase 10: c += (u32)k[9]<<8;\n\tcase 9:  c += k[8];\n\tcase 8:  b += (u32)k[7]<<24;\n\tcase 7:  b += (u32)k[6]<<16;\n\tcase 6:  b += (u32)k[5]<<8;\n\tcase 5:  b += k[4];\n\tcase 4:  a += (u32)k[3]<<24;\n\tcase 3:  a += (u32)k[2]<<16;\n\tcase 2:  a += (u32)k[1]<<8;\n\tcase 1:  a += k[0];\n\t\t __jhash_final(a, b, c);\n\tcase 0:  \n\t\tbreak;\n\t}\n\n\treturn c;\n}\n\n__noinline\nu32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)\n{\n\ta += initval;\n\tb += initval;\n\tc += initval;\n\t__jhash_final(a, b, c);\n\treturn c;\n}\n\n__noinline\nu32 jhash_2words(u32 a, u32 b, u32 initval)\n{\n\treturn __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 << 2));\n}\n\nstruct flow_key {\n\tunion {\n\t\t__be32 src;\n\t\t__be32 srcv6[4];\n\t};\n\tunion {\n\t\t__be32 dst;\n\t\t__be32 dstv6[4];\n\t};\n\tunion {\n\t\t__u32 ports;\n\t\t__u16 port16[2];\n\t};\n\t__u8 proto;\n};\n\nstruct packet_description {\n\tstruct flow_key flow;\n\t__u8 flags;\n};\n\nstruct ctl_value {\n\tunion {\n\t\t__u64 value;\n\t\t__u32 ifindex;\n\t\t__u8 mac[6];\n\t};\n};\n\nstruct vip_definition {\n\tunion {\n\t\t__be32 vip;\n\t\t__be32 vipv6[4];\n\t};\n\t__u16 port;\n\t__u16 family;\n\t__u8 proto;\n};\n\nstruct vip_meta {\n\t__u32 flags;\n\t__u32 vip_num;\n};\n\nstruct real_pos_lru {\n\t__u32 pos;\n\t__u64 atime;\n};\n\nstruct real_definition {\n\tunion {\n\t\t__be32 dst;\n\t\t__be32 dstv6[4];\n\t};\n\t__u8 flags;\n};\n\nstruct lb_stats {\n\t__u64 v2;\n\t__u64 v1;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 512);\n\t__type(key, struct vip_definition);\n\t__type(value, struct vip_meta);\n} vip_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_LRU_HASH);\n\t__uint(max_entries, 300);\n\t__uint(map_flags, 1U << 1);\n\t__type(key, struct flow_key);\n\t__type(value, struct real_pos_lru);\n} lru_cache SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 12 * 655);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} ch_rings SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 40);\n\t__type(key, __u32);\n\t__type(value, struct real_definition);\n} reals SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(max_entries, 515);\n\t__type(key, __u32);\n\t__type(value, struct lb_stats);\n} stats SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 16);\n\t__type(key, __u32);\n\t__type(value, struct ctl_value);\n} ctl_array SEC(\".maps\");\n\nstruct eth_hdr {\n\tunsigned char eth_dest[6];\n\tunsigned char eth_source[6];\n\tunsigned short eth_proto;\n};\n\nstatic __noinline __u64 calc_offset(bool is_ipv6, bool is_icmp)\n{\n\t__u64 off = sizeof(struct eth_hdr);\n\tif (is_ipv6) {\n\t\toff += sizeof(struct ipv6hdr);\n\t\tif (is_icmp)\n\t\t\toff += sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr);\n\t} else {\n\t\toff += sizeof(struct iphdr);\n\t\tif (is_icmp)\n\t\t\toff += sizeof(struct icmphdr) + sizeof(struct iphdr);\n\t}\n\treturn off;\n}\n\nstatic __attribute__ ((noinline))\nbool parse_udp(void *data, void *data_end,\n\t       bool is_ipv6, struct packet_description *pckt)\n{\n\n\tbool is_icmp = !((pckt->flags & (1 << 0)) == 0);\n\t__u64 off = calc_offset(is_ipv6, is_icmp);\n\tstruct udphdr *udp;\n\tudp = data + off;\n\n\tif (udp + 1 > data_end)\n\t\treturn false;\n\tif (!is_icmp) {\n\t\tpckt->flow.port16[0] = udp->source;\n\t\tpckt->flow.port16[1] = udp->dest;\n\t} else {\n\t\tpckt->flow.port16[0] = udp->dest;\n\t\tpckt->flow.port16[1] = udp->source;\n\t}\n\treturn true;\n}\n\nstatic __attribute__ ((noinline))\nbool parse_tcp(void *data, void *data_end,\n\t       bool is_ipv6, struct packet_description *pckt)\n{\n\n\tbool is_icmp = !((pckt->flags & (1 << 0)) == 0);\n\t__u64 off = calc_offset(is_ipv6, is_icmp);\n\tstruct tcphdr *tcp;\n\n\ttcp = data + off;\n\tif (tcp + 1 > data_end)\n\t\treturn false;\n\tif (tcp->syn)\n\t\tpckt->flags |= (1 << 1);\n\tif (!is_icmp) {\n\t\tpckt->flow.port16[0] = tcp->source;\n\t\tpckt->flow.port16[1] = tcp->dest;\n\t} else {\n\t\tpckt->flow.port16[0] = tcp->dest;\n\t\tpckt->flow.port16[1] = tcp->source;\n\t}\n\treturn true;\n}\n\nstatic __attribute__ ((noinline))\nbool encap_v6(struct xdp_md *xdp, struct ctl_value *cval,\n\t      struct packet_description *pckt,\n\t      struct real_definition *dst, __u32 pkt_bytes)\n{\n\tstruct eth_hdr *new_eth;\n\tstruct eth_hdr *old_eth;\n\tstruct ipv6hdr *ip6h;\n\t__u32 ip_suffix;\n\tvoid *data_end;\n\tvoid *data;\n\n\tif (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct ipv6hdr)))\n\t\treturn false;\n\tdata = (void *)(long)xdp->data;\n\tdata_end = (void *)(long)xdp->data_end;\n\tnew_eth = data;\n\tip6h = data + sizeof(struct eth_hdr);\n\told_eth = data + sizeof(struct ipv6hdr);\n\tif (new_eth + 1 > data_end ||\n\t    old_eth + 1 > data_end || ip6h + 1 > data_end)\n\t\treturn false;\n\tmemcpy(new_eth->eth_dest, cval->mac, 6);\n\tmemcpy(new_eth->eth_source, old_eth->eth_dest, 6);\n\tnew_eth->eth_proto = 56710;\n\tip6h->version = 6;\n\tip6h->priority = 0;\n\tmemset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));\n\n\tip6h->nexthdr = IPPROTO_IPV6;\n\tip_suffix = pckt->flow.srcv6[3] ^ pckt->flow.port16[0];\n\tip6h->payload_len =\n\t    bpf_htons(pkt_bytes + sizeof(struct ipv6hdr));\n\tip6h->hop_limit = 4;\n\n\tip6h->saddr.in6_u.u6_addr32[0] = 1;\n\tip6h->saddr.in6_u.u6_addr32[1] = 2;\n\tip6h->saddr.in6_u.u6_addr32[2] = 3;\n\tip6h->saddr.in6_u.u6_addr32[3] = ip_suffix;\n\tmemcpy(ip6h->daddr.in6_u.u6_addr32, dst->dstv6, 16);\n\treturn true;\n}\n\nstatic __attribute__ ((noinline))\nbool encap_v4(struct xdp_md *xdp, struct ctl_value *cval,\n\t      struct packet_description *pckt,\n\t      struct real_definition *dst, __u32 pkt_bytes)\n{\n\n\t__u32 ip_suffix = bpf_ntohs(pckt->flow.port16[0]);\n\tstruct eth_hdr *new_eth;\n\tstruct eth_hdr *old_eth;\n\t__u16 *next_iph_u16;\n\tstruct iphdr *iph;\n\t__u32 csum = 0;\n\tvoid *data_end;\n\tvoid *data;\n\n\tip_suffix <<= 15;\n\tip_suffix ^= pckt->flow.src;\n\tif (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct iphdr)))\n\t\treturn false;\n\tdata = (void *)(long)xdp->data;\n\tdata_end = (void *)(long)xdp->data_end;\n\tnew_eth = data;\n\tiph = data + sizeof(struct eth_hdr);\n\told_eth = data + sizeof(struct iphdr);\n\tif (new_eth + 1 > data_end ||\n\t    old_eth + 1 > data_end || iph + 1 > data_end)\n\t\treturn false;\n\tmemcpy(new_eth->eth_dest, cval->mac, 6);\n\tmemcpy(new_eth->eth_source, old_eth->eth_dest, 6);\n\tnew_eth->eth_proto = 8;\n\tiph->version = 4;\n\tiph->ihl = 5;\n\tiph->frag_off = 0;\n\tiph->protocol = IPPROTO_IPIP;\n\tiph->check = 0;\n\tiph->tos = 1;\n\tiph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n\t \n\n\tiph->saddr = ((0xFFFF0000 & ip_suffix) | 4268) ^ dst->dst;\n\tiph->ttl = 4;\n\n\tnext_iph_u16 = (__u16 *) iph;\n#pragma clang loop unroll(full)\n\tfor (int i = 0; i < sizeof(struct iphdr) >> 1; i++)\n\t\tcsum += *next_iph_u16++;\n\tiph->check = ~((csum & 0xffff) + (csum >> 16));\n\tif (bpf_xdp_adjust_head(xdp, (int)sizeof(struct iphdr)))\n\t\treturn false;\n\treturn true;\n}\n\nstatic __attribute__ ((noinline))\nint swap_mac_and_send(void *data, void *data_end)\n{\n\tunsigned char tmp_mac[6];\n\tstruct eth_hdr *eth;\n\n\teth = data;\n\tmemcpy(tmp_mac, eth->eth_source, 6);\n\tmemcpy(eth->eth_source, eth->eth_dest, 6);\n\tmemcpy(eth->eth_dest, tmp_mac, 6);\n\treturn XDP_TX;\n}\n\nstatic __attribute__ ((noinline))\nint send_icmp_reply(void *data, void *data_end)\n{\n\tstruct icmphdr *icmp_hdr;\n\t__u16 *next_iph_u16;\n\t__u32 tmp_addr = 0;\n\tstruct iphdr *iph;\n\t__u32 csum = 0;\n\t__u64 off = 0;\n\n\tif (data + sizeof(struct eth_hdr)\n\t     + sizeof(struct iphdr) + sizeof(struct icmphdr) > data_end)\n\t\treturn XDP_DROP;\n\toff += sizeof(struct eth_hdr);\n\tiph = data + off;\n\toff += sizeof(struct iphdr);\n\ticmp_hdr = data + off;\n\ticmp_hdr->type = 0;\n\ticmp_hdr->checksum += 0x0007;\n\tiph->ttl = 4;\n\ttmp_addr = iph->daddr;\n\tiph->daddr = iph->saddr;\n\tiph->saddr = tmp_addr;\n\tiph->check = 0;\n\tnext_iph_u16 = (__u16 *) iph;\n#pragma clang loop unroll(full)\n\tfor (int i = 0; i < sizeof(struct iphdr) >> 1; i++)\n\t\tcsum += *next_iph_u16++;\n\tiph->check = ~((csum & 0xffff) + (csum >> 16));\n\treturn swap_mac_and_send(data, data_end);\n}\n\nstatic __attribute__ ((noinline))\nint send_icmp6_reply(void *data, void *data_end)\n{\n\tstruct icmp6hdr *icmp_hdr;\n\tstruct ipv6hdr *ip6h;\n\t__be32 tmp_addr[4];\n\t__u64 off = 0;\n\n\tif (data + sizeof(struct eth_hdr)\n\t     + sizeof(struct ipv6hdr) + sizeof(struct icmp6hdr) > data_end)\n\t\treturn XDP_DROP;\n\toff += sizeof(struct eth_hdr);\n\tip6h = data + off;\n\toff += sizeof(struct ipv6hdr);\n\ticmp_hdr = data + off;\n\ticmp_hdr->icmp6_type = 129;\n\ticmp_hdr->icmp6_cksum -= 0x0001;\n\tip6h->hop_limit = 4;\n\tmemcpy(tmp_addr, ip6h->saddr.in6_u.u6_addr32, 16);\n\tmemcpy(ip6h->saddr.in6_u.u6_addr32, ip6h->daddr.in6_u.u6_addr32, 16);\n\tmemcpy(ip6h->daddr.in6_u.u6_addr32, tmp_addr, 16);\n\treturn swap_mac_and_send(data, data_end);\n}\n\nstatic __attribute__ ((noinline))\nint parse_icmpv6(void *data, void *data_end, __u64 off,\n\t\t struct packet_description *pckt)\n{\n\tstruct icmp6hdr *icmp_hdr;\n\tstruct ipv6hdr *ip6h;\n\n\ticmp_hdr = data + off;\n\tif (icmp_hdr + 1 > data_end)\n\t\treturn XDP_DROP;\n\tif (icmp_hdr->icmp6_type == 128)\n\t\treturn send_icmp6_reply(data, data_end);\n\tif (icmp_hdr->icmp6_type != 3)\n\t\treturn XDP_PASS;\n\toff += sizeof(struct icmp6hdr);\n\tip6h = data + off;\n\tif (ip6h + 1 > data_end)\n\t\treturn XDP_DROP;\n\tpckt->flow.proto = ip6h->nexthdr;\n\tpckt->flags |= (1 << 0);\n\tmemcpy(pckt->flow.srcv6, ip6h->daddr.in6_u.u6_addr32, 16);\n\tmemcpy(pckt->flow.dstv6, ip6h->saddr.in6_u.u6_addr32, 16);\n\treturn -1;\n}\n\nstatic __attribute__ ((noinline))\nint parse_icmp(void *data, void *data_end, __u64 off,\n\t       struct packet_description *pckt)\n{\n\tstruct icmphdr *icmp_hdr;\n\tstruct iphdr *iph;\n\n\ticmp_hdr = data + off;\n\tif (icmp_hdr + 1 > data_end)\n\t\treturn XDP_DROP;\n\tif (icmp_hdr->type == 8)\n\t\treturn send_icmp_reply(data, data_end);\n\tif ((icmp_hdr->type != 3) || (icmp_hdr->code != 4))\n\t\treturn XDP_PASS;\n\toff += sizeof(struct icmphdr);\n\tiph = data + off;\n\tif (iph + 1 > data_end)\n\t\treturn XDP_DROP;\n\tif (iph->ihl != 5)\n\t\treturn XDP_DROP;\n\tpckt->flow.proto = iph->protocol;\n\tpckt->flags |= (1 << 0);\n\tpckt->flow.src = iph->daddr;\n\tpckt->flow.dst = iph->saddr;\n\treturn -1;\n}\n\nstatic __attribute__ ((noinline))\n__u32 get_packet_hash(struct packet_description *pckt,\n\t\t      bool hash_16bytes)\n{\n\tif (hash_16bytes)\n\t\treturn jhash_2words(jhash(pckt->flow.srcv6, 16, 12),\n\t\t\t\t    pckt->flow.ports, 24);\n\telse\n\t\treturn jhash_2words(pckt->flow.src, pckt->flow.ports,\n\t\t\t\t    24);\n}\n\n__attribute__ ((noinline))\nstatic bool get_packet_dst(struct real_definition **real,\n\t\t\t   struct packet_description *pckt,\n\t\t\t   struct vip_meta *vip_info,\n\t\t\t   bool is_ipv6, void *lru_map)\n{\n\tstruct real_pos_lru new_dst_lru = { };\n\tbool hash_16bytes = is_ipv6;\n\t__u32 *real_pos, hash, key;\n\t__u64 cur_time;\n\n\tif (vip_info->flags & (1 << 2))\n\t\thash_16bytes = 1;\n\tif (vip_info->flags & (1 << 3)) {\n\t\tpckt->flow.port16[0] = pckt->flow.port16[1];\n\t\tmemset(pckt->flow.srcv6, 0, 16);\n\t}\n\thash = get_packet_hash(pckt, hash_16bytes);\n\tif (hash != 0x358459b7    &&\n\t    hash != 0x2f4bc6bb  )\n\t\treturn false;\n\tkey = 2 * vip_info->vip_num + hash % 2;\n\treal_pos = bpf_map_lookup_elem(&ch_rings, &key);\n\tif (!real_pos)\n\t\treturn false;\n\tkey = *real_pos;\n\t*real = bpf_map_lookup_elem(&reals, &key);\n\tif (!(*real))\n\t\treturn false;\n\tif (!(vip_info->flags & (1 << 1))) {\n\t\t__u32 conn_rate_key = 512 + 2;\n\t\tstruct lb_stats *conn_rate_stats =\n\t\t    bpf_map_lookup_elem(&stats, &conn_rate_key);\n\n\t\tif (!conn_rate_stats)\n\t\t\treturn true;\n\t\tcur_time = bpf_ktime_get_ns();\n\t\tif ((cur_time - conn_rate_stats->v2) >> 32 > 0xffFFFF) {\n\t\t\tconn_rate_stats->v1 = 1;\n\t\t\tconn_rate_stats->v2 = cur_time;\n\t\t} else {\n\t\t\tconn_rate_stats->v1 += 1;\n\t\t\tif (conn_rate_stats->v1 >= 1)\n\t\t\t\treturn true;\n\t\t}\n\t\tif (pckt->flow.proto == IPPROTO_UDP)\n\t\t\tnew_dst_lru.atime = cur_time;\n\t\tnew_dst_lru.pos = key;\n\t\tbpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, 0);\n\t}\n\treturn true;\n}\n\n__attribute__ ((noinline))\nstatic void connection_table_lookup(struct real_definition **real,\n\t\t\t\t    struct packet_description *pckt,\n\t\t\t\t    void *lru_map)\n{\n\n\tstruct real_pos_lru *dst_lru;\n\t__u64 cur_time;\n\t__u32 key;\n\n\tdst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);\n\tif (!dst_lru)\n\t\treturn;\n\tif (pckt->flow.proto == IPPROTO_UDP) {\n\t\tcur_time = bpf_ktime_get_ns();\n\t\tif (cur_time - dst_lru->atime > 300000)\n\t\t\treturn;\n\t\tdst_lru->atime = cur_time;\n\t}\n\tkey = dst_lru->pos;\n\t*real = bpf_map_lookup_elem(&reals, &key);\n}\n\n \n__attribute__ ((noinline))\nstatic int process_l3_headers_v6(struct packet_description *pckt,\n\t\t\t\t __u8 *protocol, __u64 off,\n\t\t\t\t __u16 *pkt_bytes, void *data,\n\t\t\t\t void *data_end)\n{\n\tstruct ipv6hdr *ip6h;\n\t__u64 iph_len;\n\tint action;\n\n\tip6h = data + off;\n\tif (ip6h + 1 > data_end)\n\t\treturn XDP_DROP;\n\tiph_len = sizeof(struct ipv6hdr);\n\t*protocol = ip6h->nexthdr;\n\tpckt->flow.proto = *protocol;\n\t*pkt_bytes = bpf_ntohs(ip6h->payload_len);\n\toff += iph_len;\n\tif (*protocol == 45) {\n\t\treturn XDP_DROP;\n\t} else if (*protocol == 59) {\n\t\taction = parse_icmpv6(data, data_end, off, pckt);\n\t\tif (action >= 0)\n\t\t\treturn action;\n\t} else {\n\t\tmemcpy(pckt->flow.srcv6, ip6h->saddr.in6_u.u6_addr32, 16);\n\t\tmemcpy(pckt->flow.dstv6, ip6h->daddr.in6_u.u6_addr32, 16);\n\t}\n\treturn -1;\n}\n\n__attribute__ ((noinline))\nstatic int process_l3_headers_v4(struct packet_description *pckt,\n\t\t\t\t __u8 *protocol, __u64 off,\n\t\t\t\t __u16 *pkt_bytes, void *data,\n\t\t\t\t void *data_end)\n{\n\tstruct iphdr *iph;\n\tint action;\n\n\tiph = data + off;\n\tif (iph + 1 > data_end)\n\t\treturn XDP_DROP;\n\tif (iph->ihl != 5)\n\t\treturn XDP_DROP;\n\t*protocol = iph->protocol;\n\tpckt->flow.proto = *protocol;\n\t*pkt_bytes = bpf_ntohs(iph->tot_len);\n\toff += 20;\n\tif (iph->frag_off & 65343)\n\t\treturn XDP_DROP;\n\tif (*protocol == IPPROTO_ICMP) {\n\t\taction = parse_icmp(data, data_end, off, pckt);\n\t\tif (action >= 0)\n\t\t\treturn action;\n\t} else {\n\t\tpckt->flow.src = iph->saddr;\n\t\tpckt->flow.dst = iph->daddr;\n\t}\n\treturn -1;\n}\n\n__attribute__ ((noinline))\nstatic int process_packet(void *data, __u64 off, void *data_end,\n\t\t\t  bool is_ipv6, struct xdp_md *xdp)\n{\n\n\tstruct real_definition *dst = NULL;\n\tstruct packet_description pckt = { };\n\tstruct vip_definition vip = { };\n\tstruct lb_stats *data_stats;\n\tvoid *lru_map = &lru_cache;\n\tstruct vip_meta *vip_info;\n\t__u32 lru_stats_key = 513;\n\t__u32 mac_addr_pos = 0;\n\t__u32 stats_key = 512;\n\tstruct ctl_value *cval;\n\t__u16 pkt_bytes;\n\t__u8 protocol;\n\t__u32 vip_num;\n\tint action;\n\n\tif (is_ipv6)\n\t\taction = process_l3_headers_v6(&pckt, &protocol, off,\n\t\t\t\t\t       &pkt_bytes, data, data_end);\n\telse\n\t\taction = process_l3_headers_v4(&pckt, &protocol, off,\n\t\t\t\t\t       &pkt_bytes, data, data_end);\n\tif (action >= 0)\n\t\treturn action;\n\tprotocol = pckt.flow.proto;\n\tif (protocol == IPPROTO_TCP) {\n\t\tif (!parse_tcp(data, data_end, is_ipv6, &pckt))\n\t\t\treturn XDP_DROP;\n\t} else if (protocol == IPPROTO_UDP) {\n\t\tif (!parse_udp(data, data_end, is_ipv6, &pckt))\n\t\t\treturn XDP_DROP;\n\t} else {\n\t\treturn XDP_TX;\n\t}\n\n\tif (is_ipv6)\n\t\tmemcpy(vip.vipv6, pckt.flow.dstv6, 16);\n\telse\n\t\tvip.vip = pckt.flow.dst;\n\tvip.port = pckt.flow.port16[1];\n\tvip.proto = pckt.flow.proto;\n\tvip_info = bpf_map_lookup_elem(&vip_map, &vip);\n\tif (!vip_info) {\n\t\tvip.port = 0;\n\t\tvip_info = bpf_map_lookup_elem(&vip_map, &vip);\n\t\tif (!vip_info)\n\t\t\treturn XDP_PASS;\n\t\tif (!(vip_info->flags & (1 << 4)))\n\t\t\tpckt.flow.port16[1] = 0;\n\t}\n\tif (data_end - data > 1400)\n\t\treturn XDP_DROP;\n\tdata_stats = bpf_map_lookup_elem(&stats, &stats_key);\n\tif (!data_stats)\n\t\treturn XDP_DROP;\n\tdata_stats->v1 += 1;\n\tif (!dst) {\n\t\tif (vip_info->flags & (1 << 0))\n\t\t\tpckt.flow.port16[0] = 0;\n\t\tif (!(pckt.flags & (1 << 1)) && !(vip_info->flags & (1 << 1)))\n\t\t\tconnection_table_lookup(&dst, &pckt, lru_map);\n\t\tif (dst)\n\t\t\tgoto out;\n\t\tif (pckt.flow.proto == IPPROTO_TCP) {\n\t\t\tstruct lb_stats *lru_stats =\n\t\t\t    bpf_map_lookup_elem(&stats, &lru_stats_key);\n\n\t\t\tif (!lru_stats)\n\t\t\t\treturn XDP_DROP;\n\t\t\tif (pckt.flags & (1 << 1))\n\t\t\t\tlru_stats->v1 += 1;\n\t\t\telse\n\t\t\t\tlru_stats->v2 += 1;\n\t\t}\n\t\tif (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6, lru_map))\n\t\t\treturn XDP_DROP;\n\t\tdata_stats->v2 += 1;\n\t}\nout:\n\tcval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos);\n\tif (!cval)\n\t\treturn XDP_DROP;\n\tif (dst->flags & (1 << 0)) {\n\t\tif (!encap_v6(xdp, cval, &pckt, dst, pkt_bytes))\n\t\t\treturn XDP_DROP;\n\t} else {\n\t\tif (!encap_v4(xdp, cval, &pckt, dst, pkt_bytes))\n\t\t\treturn XDP_DROP;\n\t}\n\tvip_num = vip_info->vip_num;\n\tdata_stats = bpf_map_lookup_elem(&stats, &vip_num);\n\tif (!data_stats)\n\t\treturn XDP_DROP;\n\tdata_stats->v1 += 1;\n\tdata_stats->v2 += pkt_bytes;\n\n\tdata = (void *)(long)xdp->data;\n\tdata_end = (void *)(long)xdp->data_end;\n\tif (data + 4 > data_end)\n\t\treturn XDP_DROP;\n\t*(u32 *)data = dst->dst;\n\treturn XDP_DROP;\n}\n\nSEC(\"xdp\")\nint balancer_ingress_v4(struct xdp_md *ctx)\n{\n\tvoid *data = (void *)(long)ctx->data;\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tstruct eth_hdr *eth = data;\n\t__u32 eth_proto;\n\t__u32 nh_off;\n\n\tnh_off = sizeof(struct eth_hdr);\n\tif (data + nh_off > data_end)\n\t\treturn XDP_DROP;\n\teth_proto = bpf_ntohs(eth->eth_proto);\n\tif (eth_proto == ETH_P_IP)\n\t\treturn process_packet(data, nh_off, data_end, 0, ctx);\n\telse\n\t\treturn XDP_DROP;\n}\n\nSEC(\"xdp\")\nint balancer_ingress_v6(struct xdp_md *ctx)\n{\n\tvoid *data = (void *)(long)ctx->data;\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tstruct eth_hdr *eth = data;\n\t__u32 eth_proto;\n\t__u32 nh_off;\n\n\tnh_off = sizeof(struct eth_hdr);\n\tif (data + nh_off > data_end)\n\t\treturn XDP_DROP;\n\teth_proto = bpf_ntohs(eth->eth_proto);\n\tif (eth_proto == ETH_P_IPV6)\n\t\treturn process_packet(data, nh_off, data_end, 1, ctx);\n\telse\n\t\treturn XDP_DROP;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}