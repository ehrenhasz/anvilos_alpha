{
  "module_name": "test_sk_lookup_kern.c",
  "hash_id": "b4827d1f12d593c732f115769cc433d999086ad5d3d69ffe02a6598f78317b62",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_sk_lookup_kern.c",
  "human_readable_source": " \n\n\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/pkt_cls.h>\n#include <linux/tcp.h>\n#include <sys/socket.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n \nstatic struct bpf_sock_tuple *get_tuple(void *data, __u64 nh_off,\n\t\t\t\t\tvoid *data_end, __u16 eth_proto,\n\t\t\t\t\tbool *ipv4)\n{\n\tstruct bpf_sock_tuple *result;\n\t__u64 ihl_len = 0;\n\t__u8 proto = 0;\n\n\tif (eth_proto == bpf_htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph = (struct iphdr *)(data + nh_off);\n\n\t\tif (iph + 1 > data_end)\n\t\t\treturn NULL;\n\t\tihl_len = iph->ihl * 4;\n\t\tproto = iph->protocol;\n\t\t*ipv4 = true;\n\t\tresult = (struct bpf_sock_tuple *)&iph->saddr;\n\t} else if (eth_proto == bpf_htons(ETH_P_IPV6)) {\n\t\tstruct ipv6hdr *ip6h = (struct ipv6hdr *)(data + nh_off);\n\n\t\tif (ip6h + 1 > data_end)\n\t\t\treturn NULL;\n\t\tihl_len = sizeof(*ip6h);\n\t\tproto = ip6h->nexthdr;\n\t\t*ipv4 = true;\n\t\tresult = (struct bpf_sock_tuple *)&ip6h->saddr;\n\t}\n\n\tif (data + nh_off + ihl_len > data_end || proto != IPPROTO_TCP)\n\t\treturn NULL;\n\n\treturn result;\n}\n\nSEC(\"?tc\")\nint sk_lookup_success(struct __sk_buff *skb)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tvoid *data = (void *)(long)skb->data;\n\tstruct ethhdr *eth = (struct ethhdr *)(data);\n\tstruct bpf_sock_tuple *tuple;\n\tstruct bpf_sock *sk;\n\tsize_t tuple_len;\n\tbool ipv4;\n\n\tif (eth + 1 > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\ttuple = get_tuple(data, sizeof(*eth), data_end, eth->h_proto, &ipv4);\n\tif (!tuple || tuple + sizeof *tuple > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\ttuple_len = ipv4 ? sizeof(tuple->ipv4) : sizeof(tuple->ipv6);\n\tsk = bpf_sk_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n\tbpf_printk(\"sk=%d\\n\", sk ? 1 : 0);\n\tif (sk)\n\t\tbpf_sk_release(sk);\n\treturn sk ? TC_ACT_OK : TC_ACT_UNSPEC;\n}\n\nSEC(\"?tc\")\nint sk_lookup_success_simple(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple tuple = {};\n\tstruct bpf_sock *sk;\n\n\tsk = bpf_sk_lookup_tcp(skb, &tuple, sizeof(tuple), BPF_F_CURRENT_NETNS, 0);\n\tif (sk)\n\t\tbpf_sk_release(sk);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint err_use_after_free(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple tuple = {};\n\tstruct bpf_sock *sk;\n\t__u32 family = 0;\n\n\tsk = bpf_sk_lookup_tcp(skb, &tuple, sizeof(tuple), BPF_F_CURRENT_NETNS, 0);\n\tif (sk) {\n\t\tbpf_sk_release(sk);\n\t\tfamily = sk->family;\n\t}\n\treturn family;\n}\n\nSEC(\"?tc\")\nint err_modify_sk_pointer(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple tuple = {};\n\tstruct bpf_sock *sk;\n\n\tsk = bpf_sk_lookup_tcp(skb, &tuple, sizeof(tuple), BPF_F_CURRENT_NETNS, 0);\n\tif (sk) {\n\t\tsk += 1;\n\t\tbpf_sk_release(sk);\n\t}\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint err_modify_sk_or_null_pointer(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple tuple = {};\n\tstruct bpf_sock *sk;\n\n\tsk = bpf_sk_lookup_tcp(skb, &tuple, sizeof(tuple), BPF_F_CURRENT_NETNS, 0);\n\tsk += 1;\n\tif (sk)\n\t\tbpf_sk_release(sk);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint err_no_release(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple tuple = {};\n\n\tbpf_sk_lookup_tcp(skb, &tuple, sizeof(tuple), BPF_F_CURRENT_NETNS, 0);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint err_release_twice(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple tuple = {};\n\tstruct bpf_sock *sk;\n\n\tsk = bpf_sk_lookup_tcp(skb, &tuple, sizeof(tuple), BPF_F_CURRENT_NETNS, 0);\n\tbpf_sk_release(sk);\n\tbpf_sk_release(sk);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint err_release_unchecked(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple tuple = {};\n\tstruct bpf_sock *sk;\n\n\tsk = bpf_sk_lookup_tcp(skb, &tuple, sizeof(tuple), BPF_F_CURRENT_NETNS, 0);\n\tbpf_sk_release(sk);\n\treturn 0;\n}\n\nvoid lookup_no_release(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple tuple = {};\n\tbpf_sk_lookup_tcp(skb, &tuple, sizeof(tuple), BPF_F_CURRENT_NETNS, 0);\n}\n\nSEC(\"?tc\")\nint err_no_release_subcall(struct __sk_buff *skb)\n{\n\tlookup_no_release(skb);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}