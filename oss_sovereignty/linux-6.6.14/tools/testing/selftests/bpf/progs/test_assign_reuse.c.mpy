{
  "module_name": "test_assign_reuse.c",
  "hash_id": "104d297fc4b40ac5e6fa0bc248c069cd6512babc16ccc8d3e913162662c41d9d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_assign_reuse.c",
  "human_readable_source": "\n \n#include <stdbool.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_helpers.h>\n#include <linux/pkt_cls.h>\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n\n__u64 sk_cookie_seen;\n__u64 reuseport_executed;\nunion {\n\tstruct tcphdr tcp;\n\tstruct udphdr udp;\n} headers;\n\nconst volatile __u16 dest_port;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKMAP);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} sk_map SEC(\".maps\");\n\nSEC(\"sk_reuseport\")\nint reuse_accept(struct sk_reuseport_md *ctx)\n{\n\treuseport_executed++;\n\n\tif (ctx->ip_protocol == IPPROTO_TCP) {\n\t\tif (ctx->data + sizeof(headers.tcp) > ctx->data_end)\n\t\t\treturn SK_DROP;\n\n\t\tif (__builtin_memcmp(&headers.tcp, ctx->data, sizeof(headers.tcp)) != 0)\n\t\t\treturn SK_DROP;\n\t} else if (ctx->ip_protocol == IPPROTO_UDP) {\n\t\tif (ctx->data + sizeof(headers.udp) > ctx->data_end)\n\t\t\treturn SK_DROP;\n\n\t\tif (__builtin_memcmp(&headers.udp, ctx->data, sizeof(headers.udp)) != 0)\n\t\t\treturn SK_DROP;\n\t} else {\n\t\treturn SK_DROP;\n\t}\n\n\tsk_cookie_seen = bpf_get_socket_cookie(ctx->sk);\n\treturn SK_PASS;\n}\n\nSEC(\"sk_reuseport\")\nint reuse_drop(struct sk_reuseport_md *ctx)\n{\n\treuseport_executed++;\n\tsk_cookie_seen = 0;\n\treturn SK_DROP;\n}\n\nstatic int\nassign_sk(struct __sk_buff *skb)\n{\n\tint zero = 0, ret = 0;\n\tstruct bpf_sock *sk;\n\n\tsk = bpf_map_lookup_elem(&sk_map, &zero);\n\tif (!sk)\n\t\treturn TC_ACT_SHOT;\n\tret = bpf_sk_assign(skb, sk, 0);\n\tbpf_sk_release(sk);\n\treturn ret ? TC_ACT_SHOT : TC_ACT_OK;\n}\n\nstatic bool\nmaybe_assign_tcp(struct __sk_buff *skb, struct tcphdr *th)\n{\n\tif (th + 1 > (void *)(long)(skb->data_end))\n\t\treturn TC_ACT_SHOT;\n\n\tif (!th->syn || th->ack || th->dest != bpf_htons(dest_port))\n\t\treturn TC_ACT_OK;\n\n\t__builtin_memcpy(&headers.tcp, th, sizeof(headers.tcp));\n\treturn assign_sk(skb);\n}\n\nstatic bool\nmaybe_assign_udp(struct __sk_buff *skb, struct udphdr *uh)\n{\n\tif (uh + 1 > (void *)(long)(skb->data_end))\n\t\treturn TC_ACT_SHOT;\n\n\tif (uh->dest != bpf_htons(dest_port))\n\t\treturn TC_ACT_OK;\n\n\t__builtin_memcpy(&headers.udp, uh, sizeof(headers.udp));\n\treturn assign_sk(skb);\n}\n\nSEC(\"tc\")\nint tc_main(struct __sk_buff *skb)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tvoid *data = (void *)(long)skb->data;\n\tstruct ethhdr *eth;\n\n\teth = (struct ethhdr *)(data);\n\tif (eth + 1 > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tif (eth->h_proto == bpf_htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph = (struct iphdr *)(data + sizeof(*eth));\n\n\t\tif (iph + 1 > data_end)\n\t\t\treturn TC_ACT_SHOT;\n\n\t\tif (iph->protocol == IPPROTO_TCP)\n\t\t\treturn maybe_assign_tcp(skb, (struct tcphdr *)(iph + 1));\n\t\telse if (iph->protocol == IPPROTO_UDP)\n\t\t\treturn maybe_assign_udp(skb, (struct udphdr *)(iph + 1));\n\t\telse\n\t\t\treturn TC_ACT_SHOT;\n\t} else {\n\t\tstruct ipv6hdr *ip6h = (struct ipv6hdr *)(data + sizeof(*eth));\n\n\t\tif (ip6h + 1 > data_end)\n\t\t\treturn TC_ACT_SHOT;\n\n\t\tif (ip6h->nexthdr == IPPROTO_TCP)\n\t\t\treturn maybe_assign_tcp(skb, (struct tcphdr *)(ip6h + 1));\n\t\telse if (ip6h->nexthdr == IPPROTO_UDP)\n\t\t\treturn maybe_assign_udp(skb, (struct udphdr *)(ip6h + 1));\n\t\telse\n\t\t\treturn TC_ACT_SHOT;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}