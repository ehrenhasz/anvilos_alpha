{
  "module_name": "sk_storage_omem_uncharge.c",
  "hash_id": "7afffa1d06a95661843f41b44c372bffb3b54907f5f984e68eeed8e5cc01dbff",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/sk_storage_omem_uncharge.c",
  "human_readable_source": "\n \n#include \"vmlinux.h\"\n#include \"bpf_tracing_net.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\nvoid *local_storage_ptr = NULL;\nvoid *sk_ptr = NULL;\nint cookie_found = 0;\n__u64 cookie = 0;\n__u32 omem = 0;\n\nvoid *bpf_rdonly_cast(void *, __u32) __ksym;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, int);\n} sk_storage SEC(\".maps\");\n\nSEC(\"fexit/bpf_local_storage_destroy\")\nint BPF_PROG(bpf_local_storage_destroy, struct bpf_local_storage *local_storage)\n{\n\tstruct sock *sk;\n\n\tif (local_storage_ptr != local_storage)\n\t\treturn 0;\n\n\tsk = bpf_rdonly_cast(sk_ptr, bpf_core_type_id_kernel(struct sock));\n\tif (sk->sk_cookie.counter != cookie)\n\t\treturn 0;\n\n\tcookie_found++;\n\tomem = sk->sk_omem_alloc.counter;\n\tlocal_storage_ptr = NULL;\n\n\treturn 0;\n}\n\nSEC(\"fentry/inet6_sock_destruct\")\nint BPF_PROG(inet6_sock_destruct, struct sock *sk)\n{\n\tint *value;\n\n\tif (!cookie || sk->sk_cookie.counter != cookie)\n\t\treturn 0;\n\n\tvalue = bpf_sk_storage_get(&sk_storage, sk, 0, 0);\n\tif (value && *value == 0xdeadbeef) {\n\t\tcookie_found++;\n\t\tsk_ptr = sk;\n\t\tlocal_storage_ptr = sk->sk_bpf_storage;\n\t}\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}