{
  "module_name": "sockopt_inherit.c",
  "hash_id": "e04251c94ac424759fec45f56ea6161302fd0d40971033914988bab7b4a4c016",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/sockopt_inherit.c",
  "human_readable_source": "\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n#define SOL_CUSTOM\t\t\t0xdeadbeef\n#define CUSTOM_INHERIT1\t\t\t0\n#define CUSTOM_INHERIT2\t\t\t1\n#define CUSTOM_LISTENER\t\t\t2\n\n__u32 page_size = 0;\n\nstruct sockopt_inherit {\n\t__u8 val;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC | BPF_F_CLONE);\n\t__type(key, int);\n\t__type(value, struct sockopt_inherit);\n} cloned1_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC | BPF_F_CLONE);\n\t__type(key, int);\n\t__type(value, struct sockopt_inherit);\n} cloned2_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct sockopt_inherit);\n} listener_only_map SEC(\".maps\");\n\nstatic __inline struct sockopt_inherit *get_storage(struct bpf_sockopt *ctx)\n{\n\tif (ctx->optname == CUSTOM_INHERIT1)\n\t\treturn bpf_sk_storage_get(&cloned1_map, ctx->sk, 0,\n\t\t\t\t\t  BPF_SK_STORAGE_GET_F_CREATE);\n\telse if (ctx->optname == CUSTOM_INHERIT2)\n\t\treturn bpf_sk_storage_get(&cloned2_map, ctx->sk, 0,\n\t\t\t\t\t  BPF_SK_STORAGE_GET_F_CREATE);\n\telse\n\t\treturn bpf_sk_storage_get(&listener_only_map, ctx->sk, 0,\n\t\t\t\t\t  BPF_SK_STORAGE_GET_F_CREATE);\n}\n\nSEC(\"cgroup/getsockopt\")\nint _getsockopt(struct bpf_sockopt *ctx)\n{\n\t__u8 *optval_end = ctx->optval_end;\n\tstruct sockopt_inherit *storage;\n\t__u8 *optval = ctx->optval;\n\n\tif (ctx->level != SOL_CUSTOM)\n\t\tgoto out;  \n\n\tif (optval + 1 > optval_end)\n\t\treturn 0;  \n\n\tstorage = get_storage(ctx);\n\tif (!storage)\n\t\treturn 0;  \n\n\tctx->retval = 0;  \n\n\toptval[0] = storage->val;\n\tctx->optlen = 1;\n\n\treturn 1;\n\nout:\n\t \n\tif (ctx->optlen > page_size)\n\t\tctx->optlen = 0;\n\treturn 1;\n}\n\nSEC(\"cgroup/setsockopt\")\nint _setsockopt(struct bpf_sockopt *ctx)\n{\n\t__u8 *optval_end = ctx->optval_end;\n\tstruct sockopt_inherit *storage;\n\t__u8 *optval = ctx->optval;\n\n\tif (ctx->level != SOL_CUSTOM)\n\t\tgoto out;  \n\n\tif (optval + 1 > optval_end)\n\t\treturn 0;  \n\n\tstorage = get_storage(ctx);\n\tif (!storage)\n\t\treturn 0;  \n\n\tstorage->val = optval[0];\n\tctx->optlen = -1;\n\n\treturn 1;\n\nout:\n\t \n\tif (ctx->optlen > page_size)\n\t\tctx->optlen = 0;\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}