{
  "module_name": "test_sockmap_listen.c",
  "hash_id": "2f4adce296f92d30bdbcb6425ef56003a5d3c6f2b56ae81327ffed24cc7e6442",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_sockmap_listen.c",
  "human_readable_source": "\n\n\n#include <errno.h>\n#include <stdbool.h>\n#include <linux/bpf.h>\n\n#include <bpf/bpf_helpers.h>\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKMAP);\n\t__uint(max_entries, 2);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} sock_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKHASH);\n\t__uint(max_entries, 2);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} sock_hash SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 2);\n\t__type(key, int);\n\t__type(value, unsigned int);\n} verdict_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n} parser_map SEC(\".maps\");\n\nbool test_sockmap = false;  \nbool test_ingress = false;  \n\nSEC(\"sk_skb/stream_parser\")\nint prog_stream_parser(struct __sk_buff *skb)\n{\n\tint *value;\n\t__u32 key = 0;\n\n\tvalue = bpf_map_lookup_elem(&parser_map, &key);\n\tif (value && *value)\n\t\treturn *value;\n\n\treturn skb->len;\n}\n\nSEC(\"sk_skb/stream_verdict\")\nint prog_stream_verdict(struct __sk_buff *skb)\n{\n\tunsigned int *count;\n\t__u32 zero = 0;\n\tint verdict;\n\n\tif (test_sockmap)\n\t\tverdict = bpf_sk_redirect_map(skb, &sock_map, zero, 0);\n\telse\n\t\tverdict = bpf_sk_redirect_hash(skb, &sock_hash, &zero, 0);\n\n\tcount = bpf_map_lookup_elem(&verdict_map, &verdict);\n\tif (count)\n\t\t(*count)++;\n\n\treturn verdict;\n}\n\nSEC(\"sk_skb\")\nint prog_skb_verdict(struct __sk_buff *skb)\n{\n\tunsigned int *count;\n\t__u32 zero = 0;\n\tint verdict;\n\n\tif (test_sockmap)\n\t\tverdict = bpf_sk_redirect_map(skb, &sock_map, zero,\n\t\t\t\t\t      test_ingress ? BPF_F_INGRESS : 0);\n\telse\n\t\tverdict = bpf_sk_redirect_hash(skb, &sock_hash, &zero,\n\t\t\t\t\t       test_ingress ? BPF_F_INGRESS : 0);\n\n\tcount = bpf_map_lookup_elem(&verdict_map, &verdict);\n\tif (count)\n\t\t(*count)++;\n\n\treturn verdict;\n}\n\nSEC(\"sk_msg\")\nint prog_msg_verdict(struct sk_msg_md *msg)\n{\n\tunsigned int *count;\n\t__u32 zero = 0;\n\tint verdict;\n\n\tif (test_sockmap)\n\t\tverdict = bpf_msg_redirect_map(msg, &sock_map, zero, 0);\n\telse\n\t\tverdict = bpf_msg_redirect_hash(msg, &sock_hash, &zero, 0);\n\n\tcount = bpf_map_lookup_elem(&verdict_map, &verdict);\n\tif (count)\n\t\t(*count)++;\n\n\treturn verdict;\n}\n\nSEC(\"sk_reuseport\")\nint prog_reuseport(struct sk_reuseport_md *reuse)\n{\n\tunsigned int *count;\n\tint err, verdict;\n\t__u32 zero = 0;\n\n\tif (test_sockmap)\n\t\terr = bpf_sk_select_reuseport(reuse, &sock_map, &zero, 0);\n\telse\n\t\terr = bpf_sk_select_reuseport(reuse, &sock_hash, &zero, 0);\n\tverdict = err ? SK_DROP : SK_PASS;\n\n\tcount = bpf_map_lookup_elem(&verdict_map, &verdict);\n\tif (count)\n\t\t(*count)++;\n\n\treturn verdict;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}