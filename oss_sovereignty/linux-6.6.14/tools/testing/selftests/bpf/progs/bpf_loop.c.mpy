{
  "module_name": "bpf_loop.c",
  "hash_id": "0f07c2b3cc841de7a7b4dcc682e74469d62d7bbd0722d96c25f4a93c11960efe",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/bpf_loop.c",
  "human_readable_source": "\n \n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct callback_ctx {\n\tint output;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 32);\n\t__type(key, int);\n\t__type(value, int);\n} map1 SEC(\".maps\");\n\n \nu32 nested_callback_nr_loops;\nu32 stop_index = -1;\nu32 nr_loops;\nint pid;\nint callback_selector;\n\n \nint nr_loops_returned;\nint g_output;\nint err;\n\nstatic int callback(__u32 index, void *data)\n{\n\tstruct callback_ctx *ctx = data;\n\n\tif (index >= stop_index)\n\t\treturn 1;\n\n\tctx->output += index;\n\n\treturn 0;\n}\n\nstatic int empty_callback(__u32 index, void *data)\n{\n\treturn 0;\n}\n\nstatic int nested_callback2(__u32 index, void *data)\n{\n\tnr_loops_returned += bpf_loop(nested_callback_nr_loops, callback, data, 0);\n\n\treturn 0;\n}\n\nstatic int nested_callback1(__u32 index, void *data)\n{\n\tbpf_loop(nested_callback_nr_loops, nested_callback2, data, 0);\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_nanosleep\")\nint test_prog(void *ctx)\n{\n\tstruct callback_ctx data = {};\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tnr_loops_returned = bpf_loop(nr_loops, callback, &data, 0);\n\n\tif (nr_loops_returned < 0)\n\t\terr = nr_loops_returned;\n\telse\n\t\tg_output = data.output;\n\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_nanosleep\")\nint prog_null_ctx(void *ctx)\n{\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tnr_loops_returned = bpf_loop(nr_loops, empty_callback, NULL, 0);\n\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_nanosleep\")\nint prog_invalid_flags(void *ctx)\n{\n\tstruct callback_ctx data = {};\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\terr = bpf_loop(nr_loops, callback, &data, 1);\n\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_nanosleep\")\nint prog_nested_calls(void *ctx)\n{\n\tstruct callback_ctx data = {};\n\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tnr_loops_returned = 0;\n\tbpf_loop(nr_loops, nested_callback1, &data, 0);\n\n\tg_output = data.output;\n\n\treturn 0;\n}\n\nstatic int callback_set_f0(int i, void *ctx)\n{\n\tg_output = 0xF0;\n\treturn 0;\n}\n\nstatic int callback_set_0f(int i, void *ctx)\n{\n\tg_output = 0x0F;\n\treturn 0;\n}\n\n \nSEC(\"fentry/\" SYS_PREFIX \"sys_nanosleep\")\nint prog_non_constant_callback(void *ctx)\n{\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tint (*callback)(int i, void *ctx);\n\n\tg_output = 0;\n\n\tif (callback_selector == 0x0F)\n\t\tcallback = callback_set_0f;\n\telse\n\t\tcallback = callback_set_f0;\n\n\tbpf_loop(1, callback, NULL, 0);\n\n\treturn 0;\n}\n\nstatic int stack_check_inner_callback(void *ctx)\n{\n\treturn 0;\n}\n\nstatic int map1_lookup_elem(int key)\n{\n\tint *val = bpf_map_lookup_elem(&map1, &key);\n\n\treturn val ? *val : -1;\n}\n\nstatic void map1_update_elem(int key, int val)\n{\n\tbpf_map_update_elem(&map1, &key, &val, BPF_ANY);\n}\n\nstatic int stack_check_outer_callback(void *ctx)\n{\n\tint a = map1_lookup_elem(1);\n\tint b = map1_lookup_elem(2);\n\tint c = map1_lookup_elem(3);\n\tint d = map1_lookup_elem(4);\n\tint e = map1_lookup_elem(5);\n\tint f = map1_lookup_elem(6);\n\n\tbpf_loop(1, stack_check_inner_callback, NULL, 0);\n\n\tmap1_update_elem(1, a + 1);\n\tmap1_update_elem(2, b + 1);\n\tmap1_update_elem(3, c + 1);\n\tmap1_update_elem(4, d + 1);\n\tmap1_update_elem(5, e + 1);\n\tmap1_update_elem(6, f + 1);\n\n\treturn 0;\n}\n\n \nSEC(\"fentry/\" SYS_PREFIX \"sys_nanosleep\")\nint stack_check(void *ctx)\n{\n\tif (bpf_get_current_pid_tgid() >> 32 != pid)\n\t\treturn 0;\n\n\tint a = map1_lookup_elem(7);\n\tint b = map1_lookup_elem(8);\n\tint c = map1_lookup_elem(9);\n\tint d = map1_lookup_elem(10);\n\tint e = map1_lookup_elem(11);\n\tint f = map1_lookup_elem(12);\n\n\tbpf_loop(1, stack_check_outer_callback, NULL, 0);\n\n\tmap1_update_elem(7,  a + 1);\n\tmap1_update_elem(8, b + 1);\n\tmap1_update_elem(9, c + 1);\n\tmap1_update_elem(10, d + 1);\n\tmap1_update_elem(11, e + 1);\n\tmap1_update_elem(12, f + 1);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}