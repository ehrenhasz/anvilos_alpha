{
  "module_name": "dynptr_fail.c",
  "hash_id": "f95e7671d5b2811fe9459222c054e8af96725a64d8a689ee45157053e17a75f0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/dynptr_fail.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <string.h>\n#include <stdbool.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <linux/if_ether.h>\n#include \"bpf_misc.h\"\n#include \"bpf_kfuncs.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct test_info {\n\tint x;\n\tstruct bpf_dynptr ptr;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, struct bpf_dynptr);\n} array_map1 SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, struct test_info);\n} array_map2 SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} array_map3 SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} array_map4 SEC(\".maps\");\n\nstruct sample {\n\tint pid;\n\tlong value;\n\tchar comm[16];\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_RINGBUF);\n\t__uint(max_entries, 4096);\n} ringbuf SEC(\".maps\");\n\nint err, val;\n\nstatic int get_map_val_dynptr(struct bpf_dynptr *ptr)\n{\n\t__u32 key = 0, *map_val;\n\n\tbpf_map_update_elem(&array_map3, &key, &val, 0);\n\n\tmap_val = bpf_map_lookup_elem(&array_map3, &key);\n\tif (!map_val)\n\t\treturn -ENOENT;\n\n\tbpf_dynptr_from_mem(map_val, sizeof(*map_val), 0, ptr);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"Unreleased reference id=2\")\nint ringbuf_missing_release1(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\t \n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"Unreleased reference id=4\")\nint ringbuf_missing_release2(void *ctx)\n{\n\tstruct bpf_dynptr ptr1, ptr2;\n\tstruct sample *sample;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, sizeof(*sample), 0, &ptr1);\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, sizeof(*sample), 0, &ptr2);\n\n\tsample = bpf_dynptr_data(&ptr1, 0, sizeof(*sample));\n\tif (!sample) {\n\t\tbpf_ringbuf_discard_dynptr(&ptr1, 0);\n\t\tbpf_ringbuf_discard_dynptr(&ptr2, 0);\n\t\treturn 0;\n\t}\n\n\tbpf_ringbuf_submit_dynptr(&ptr1, 0);\n\n\t \n\n\treturn 0;\n}\n\nstatic int missing_release_callback_fn(__u32 index, void *data)\n{\n\tstruct bpf_dynptr ptr;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\t \n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"Unreleased reference id\")\nint ringbuf_missing_release_callback(void *ctx)\n{\n\tbpf_loop(10, missing_release_callback_fn, NULL, 0);\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"arg 1 is an unacquired reference\")\nint ringbuf_release_uninit_dynptr(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\t \n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #3\")\nint use_after_invalid(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tchar read_data[64];\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, sizeof(read_data), 0, &ptr);\n\n\tbpf_dynptr_read(read_data, sizeof(read_data), &ptr, 0, 0);\n\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\t \n\tbpf_dynptr_read(read_data, sizeof(read_data), &ptr, 0, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"type=mem expected=ringbuf_mem\")\nint ringbuf_invalid_api(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct sample *sample;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, sizeof(*sample), 0, &ptr);\n\tsample = bpf_dynptr_data(&ptr, 0, sizeof(*sample));\n\tif (!sample)\n\t\tgoto done;\n\n\tsample->pid = 123;\n\n\t \n\tbpf_ringbuf_submit(sample, 0);\n\ndone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid indirect read from stack\")\nint add_dynptr_to_map1(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tint key = 0;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\t \n\tbpf_map_update_elem(&array_map1, &key, &ptr, 0);\n\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid indirect read from stack\")\nint add_dynptr_to_map2(void *ctx)\n{\n\tstruct test_info x;\n\tint key = 0;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &x.ptr);\n\n\t \n\tbpf_map_update_elem(&array_map2, &key, &x, 0);\n\n\tbpf_ringbuf_submit_dynptr(&x.ptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"value is outside of the allowed memory range\")\nint data_slice_out_of_bounds_ringbuf(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tvoid *data;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 8, 0, &ptr);\n\n\tdata  = bpf_dynptr_data(&ptr, 0, 8);\n\tif (!data)\n\t\tgoto done;\n\n\t \n\tval = *((char *)data + 8);\n\ndone:\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\treturn 0;\n}\n\n \nSEC(\"?tc\")\n__failure __msg(\"value is outside of the allowed memory range\")\nint data_slice_out_of_bounds_skb(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\tchar buffer[sizeof(*hdr)] = {};\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\n\thdr = bpf_dynptr_slice_rdwr(&ptr, 0, buffer, sizeof(buffer));\n\tif (!hdr)\n\t\treturn SK_DROP;\n\n\t \n\t*(__u8*)(hdr + 1) = 1;\n\n\treturn SK_PASS;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"value is outside of the allowed memory range\")\nint data_slice_out_of_bounds_map_value(void *ctx)\n{\n\t__u32 map_val;\n\tstruct bpf_dynptr ptr;\n\tvoid *data;\n\n\tget_map_val_dynptr(&ptr);\n\n\tdata  = bpf_dynptr_data(&ptr, 0, sizeof(map_val));\n\tif (!data)\n\t\treturn 0;\n\n\t \n\tval = *((char *)data + (sizeof(map_val) + 1));\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint data_slice_use_after_release1(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct sample *sample;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, sizeof(*sample), 0, &ptr);\n\tsample = bpf_dynptr_data(&ptr, 0, sizeof(*sample));\n\tif (!sample)\n\t\tgoto done;\n\n\tsample->pid = 123;\n\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\t \n\tval = sample->pid;\n\n\treturn 0;\n\ndone:\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint data_slice_use_after_release2(void *ctx)\n{\n\tstruct bpf_dynptr ptr1, ptr2;\n\tstruct sample *sample;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &ptr1);\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, sizeof(*sample), 0, &ptr2);\n\n\tsample = bpf_dynptr_data(&ptr2, 0, sizeof(*sample));\n\tif (!sample)\n\t\tgoto done;\n\n\tsample->pid = 23;\n\n\tbpf_ringbuf_submit_dynptr(&ptr2, 0);\n\n\t \n\tsample->pid = 23;\n\n\tbpf_ringbuf_submit_dynptr(&ptr1, 0);\n\n\treturn 0;\n\ndone:\n\tbpf_ringbuf_discard_dynptr(&ptr2, 0);\n\tbpf_ringbuf_discard_dynptr(&ptr1, 0);\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'mem_or_null'\")\nint data_slice_missing_null_check1(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tvoid *data;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 8, 0, &ptr);\n\n\tdata  = bpf_dynptr_data(&ptr, 0, 8);\n\n\t \n\n\t \n\t*(__u8 *)data = 3;\n\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'mem_or_null'\")\nint data_slice_missing_null_check2(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\t__u64 *data1, *data2;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 16, 0, &ptr);\n\n\tdata1 = bpf_dynptr_data(&ptr, 0, 8);\n\tdata2 = bpf_dynptr_data(&ptr, 0, 8);\n\tif (data1)\n\t\t \n\t\t*data2 = 3;\n\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid indirect read from stack\")\nint invalid_helper1(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\tget_map_val_dynptr(&ptr);\n\n\t \n\tbpf_strncmp((const char *)&ptr, sizeof(ptr), \"hello!\");\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"cannot pass in dynptr at an offset=-8\")\nint invalid_helper2(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tchar read_data[64];\n\n\tget_map_val_dynptr(&ptr);\n\n\t \n\tbpf_dynptr_read(read_data, sizeof(read_data), (void *)&ptr + 8, 0, 0);\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #1\")\nint invalid_write1(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tvoid *data;\n\t__u8 x = 0;\n\n\tget_map_val_dynptr(&ptr);\n\n\tmemcpy(&ptr, &x, sizeof(x));\n\n\t \n\tdata = bpf_dynptr_data(&ptr, 0, 1);\n\t__sink(data);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"cannot overwrite referenced dynptr\")\nint invalid_write2(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tchar read_data[64];\n\t__u8 x = 0;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &ptr);\n\n\tmemcpy((void *)&ptr + 8, &x, sizeof(x));\n\n\t \n\tbpf_dynptr_read(read_data, sizeof(read_data), &ptr, 0, 0);\n\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"cannot overwrite referenced dynptr\")\nint invalid_write3(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tchar stack_buf[16];\n\tunsigned long len;\n\t__u8 x = 0;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 8, 0, &ptr);\n\n\tmemcpy(stack_buf, &val, sizeof(val));\n\tlen = stack_buf[0] & 0xf;\n\n\tmemcpy((void *)&ptr + len, &x, sizeof(x));\n\n\t \n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\treturn 0;\n}\n\nstatic int invalid_write4_callback(__u32 index, void *data)\n{\n\t*(__u32 *)data = 123;\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"cannot overwrite referenced dynptr\")\nint invalid_write4(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &ptr);\n\n\tbpf_loop(10, invalid_write4_callback, &ptr, 0);\n\n\t \n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\treturn 0;\n}\n\n \nstruct bpf_dynptr global_dynptr;\n\nSEC(\"?raw_tp\")\n__failure __msg(\"type=map_value expected=fp\")\nint global(void *ctx)\n{\n\t \n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 16, 0, &global_dynptr);\n\n\tbpf_ringbuf_discard_dynptr(&global_dynptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid read from stack\")\nint invalid_read1(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &ptr);\n\n\t \n\tval = *(int *)&ptr;\n\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"cannot pass in dynptr at an offset\")\nint invalid_read2(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tchar read_data[64];\n\n\tget_map_val_dynptr(&ptr);\n\n\t \n\tbpf_dynptr_read(read_data, sizeof(read_data), (void *)&ptr + 1, 0, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid read from stack\")\nint invalid_read3(void *ctx)\n{\n\tstruct bpf_dynptr ptr1, ptr2;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 16, 0, &ptr1);\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 16, 0, &ptr2);\n\n\t \n\tmemcpy(&val, (void *)&ptr1 + 8, sizeof(val));\n\n\tbpf_ringbuf_discard_dynptr(&ptr1, 0);\n\tbpf_ringbuf_discard_dynptr(&ptr2, 0);\n\n\treturn 0;\n}\n\nstatic int invalid_read4_callback(__u32 index, void *data)\n{\n\t \n\tval = *(__u32 *)data;\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid read from stack\")\nint invalid_read4(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &ptr);\n\n\tbpf_loop(10, invalid_read4_callback, &ptr, 0);\n\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"cannot pass in dynptr at an offset=0\")\nint invalid_offset(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\t \n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &ptr + 1);\n\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"arg 1 is an unacquired reference\")\nint release_twice(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 16, 0, &ptr);\n\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\n\t \n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\n\treturn 0;\n}\n\nstatic int release_twice_callback_fn(__u32 index, void *data)\n{\n\t \n\tbpf_ringbuf_discard_dynptr(data, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"arg 1 is an unacquired reference\")\nint release_twice_callback(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 32, 0, &ptr);\n\n\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\n\tbpf_loop(10, release_twice_callback_fn, &ptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"Unsupported reg type fp for bpf_dynptr_from_mem data\")\nint dynptr_from_mem_invalid_api(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tint x = 0;\n\n\t \n\tbpf_dynptr_from_mem(&x, sizeof(x), 0, &ptr);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"cannot overwrite referenced dynptr\") __log_level(2)\nint dynptr_pruning_overwrite(struct __sk_buff *ctx)\n{\n\tasm volatile (\n\t\t\"r9 = 0xeB9F;\t\t\t\t\\\n\t\t r6 = %[ringbuf] ll;\t\t\t\\\n\t\t r1 = r6;\t\t\t\t\\\n\t\t r2 = 8;\t\t\t\t\\\n\t\t r3 = 0;\t\t\t\t\\\n\t\t r4 = r10;\t\t\t\t\\\n\t\t r4 += -16;\t\t\t\t\\\n\t\t call %[bpf_ringbuf_reserve_dynptr];\t\\\n\t\t if r0 == 0 goto pjmp1;\t\t\t\\\n\t\t goto pjmp2;\t\t\t\t\\\n\tpjmp1:\t\t\t\t\t\t\\\n\t\t *(u64 *)(r10 - 16) = r9;\t\t\\\n\tpjmp2:\t\t\t\t\t\t\\\n\t\t r1 = r10;\t\t\t\t\\\n\t\t r1 += -16;\t\t\t\t\\\n\t\t r2 = 0;\t\t\t\t\\\n\t\t call %[bpf_ringbuf_discard_dynptr];\t\"\n\t\t:\n\t\t: __imm(bpf_ringbuf_reserve_dynptr),\n\t\t  __imm(bpf_ringbuf_discard_dynptr),\n\t\t  __imm_addr(ringbuf)\n\t\t: __clobber_all\n\t);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__success __msg(\"12: safe\") __log_level(2)\nint dynptr_pruning_stacksafe(struct __sk_buff *ctx)\n{\n\tasm volatile (\n\t\t\"r9 = 0xeB9F;\t\t\t\t\\\n\t\t r6 = %[ringbuf] ll;\t\t\t\\\n\t\t r1 = r6;\t\t\t\t\\\n\t\t r2 = 8;\t\t\t\t\\\n\t\t r3 = 0;\t\t\t\t\\\n\t\t r4 = r10;\t\t\t\t\\\n\t\t r4 += -16;\t\t\t\t\\\n\t\t call %[bpf_ringbuf_reserve_dynptr];\t\\\n\t\t if r0 == 0 goto stjmp1;\t\t\\\n\t\t goto stjmp2;\t\t\t\t\\\n\tstjmp1:\t\t\t\t\t\t\\\n\t\t r9 = r9;\t\t\t\t\\\n\tstjmp2:\t\t\t\t\t\t\\\n\t\t r1 = r10;\t\t\t\t\\\n\t\t r1 += -16;\t\t\t\t\\\n\t\t r2 = 0;\t\t\t\t\\\n\t\t call %[bpf_ringbuf_discard_dynptr];\t\"\n\t\t:\n\t\t: __imm(bpf_ringbuf_reserve_dynptr),\n\t\t  __imm(bpf_ringbuf_discard_dynptr),\n\t\t  __imm_addr(ringbuf)\n\t\t: __clobber_all\n\t);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"cannot overwrite referenced dynptr\") __log_level(2)\nint dynptr_pruning_type_confusion(struct __sk_buff *ctx)\n{\n\tasm volatile (\n\t\t\"r6 = %[array_map4] ll;\t\t\t\\\n\t\t r7 = %[ringbuf] ll;\t\t\t\\\n\t\t r1 = r6;\t\t\t\t\\\n\t\t r2 = r10;\t\t\t\t\\\n\t\t r2 += -8;\t\t\t\t\\\n\t\t r9 = 0;\t\t\t\t\\\n\t\t *(u64 *)(r2 + 0) = r9;\t\t\t\\\n\t\t r3 = r10;\t\t\t\t\\\n\t\t r3 += -24;\t\t\t\t\\\n\t\t r9 = 0xeB9FeB9F;\t\t\t\\\n\t\t *(u64 *)(r10 - 16) = r9;\t\t\\\n\t\t *(u64 *)(r10 - 24) = r9;\t\t\\\n\t\t r9 = 0;\t\t\t\t\\\n\t\t r4 = 0;\t\t\t\t\\\n\t\t r8 = r2;\t\t\t\t\\\n\t\t call %[bpf_map_update_elem];\t\t\\\n\t\t r1 = r6;\t\t\t\t\\\n\t\t r2 = r8;\t\t\t\t\\\n\t\t call %[bpf_map_lookup_elem];\t\t\\\n\t\t if r0 != 0 goto tjmp1;\t\t\t\\\n\t\t exit;\t\t\t\t\t\\\n\ttjmp1:\t\t\t\t\t\t\\\n\t\t r8 = r0;\t\t\t\t\\\n\t\t r1 = r7;\t\t\t\t\\\n\t\t r2 = 8;\t\t\t\t\\\n\t\t r3 = 0;\t\t\t\t\\\n\t\t r4 = r10;\t\t\t\t\\\n\t\t r4 += -16;\t\t\t\t\\\n\t\t r0 = *(u64 *)(r0 + 0);\t\t\t\\\n\t\t call %[bpf_ringbuf_reserve_dynptr];\t\\\n\t\t if r0 == 0 goto tjmp2;\t\t\t\\\n\t\t r8 = r8;\t\t\t\t\\\n\t\t r8 = r8;\t\t\t\t\\\n\t\t r8 = r8;\t\t\t\t\\\n\t\t r8 = r8;\t\t\t\t\\\n\t\t r8 = r8;\t\t\t\t\\\n\t\t r8 = r8;\t\t\t\t\\\n\t\t r8 = r8;\t\t\t\t\\\n\t\t goto tjmp3;\t\t\t\t\\\n\ttjmp2:\t\t\t\t\t\t\\\n\t\t *(u64 *)(r10 - 8) = r9;\t\t\\\n\t\t *(u64 *)(r10 - 16) = r9;\t\t\\\n\t\t r1 = r8;\t\t\t\t\\\n\t\t r1 += 8;\t\t\t\t\\\n\t\t r2 = 0;\t\t\t\t\\\n\t\t r3 = 0;\t\t\t\t\\\n\t\t r4 = r10;\t\t\t\t\\\n\t\t r4 += -16;\t\t\t\t\\\n\t\t call %[bpf_dynptr_from_mem];\t\t\\\n\ttjmp3:\t\t\t\t\t\t\\\n\t\t r1 = r10;\t\t\t\t\\\n\t\t r1 += -16;\t\t\t\t\\\n\t\t r2 = 0;\t\t\t\t\\\n\t\t call %[bpf_ringbuf_discard_dynptr];\t\"\n\t\t:\n\t\t: __imm(bpf_map_update_elem),\n\t\t  __imm(bpf_map_lookup_elem),\n\t\t  __imm(bpf_ringbuf_reserve_dynptr),\n\t\t  __imm(bpf_dynptr_from_mem),\n\t\t  __imm(bpf_ringbuf_discard_dynptr),\n\t\t  __imm_addr(array_map4),\n\t\t  __imm_addr(ringbuf)\n\t\t: __clobber_all\n\t);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"dynptr has to be at a constant offset\") __log_level(2)\nint dynptr_var_off_overwrite(struct __sk_buff *ctx)\n{\n\tasm volatile (\n\t\t\"r9 = 16;\t\t\t\t\\\n\t\t *(u32 *)(r10 - 4) = r9;\t\t\\\n\t\t r8 = *(u32 *)(r10 - 4);\t\t\\\n\t\t if r8 >= 0 goto vjmp1;\t\t\t\\\n\t\t r0 = 1;\t\t\t\t\\\n\t\t exit;\t\t\t\t\t\\\n\tvjmp1:\t\t\t\t\t\t\\\n\t\t if r8 <= 16 goto vjmp2;\t\t\\\n\t\t r0 = 1;\t\t\t\t\\\n\t\t exit;\t\t\t\t\t\\\n\tvjmp2:\t\t\t\t\t\t\\\n\t\t r8 &= 16;\t\t\t\t\\\n\t\t r1 = %[ringbuf] ll;\t\t\t\\\n\t\t r2 = 8;\t\t\t\t\\\n\t\t r3 = 0;\t\t\t\t\\\n\t\t r4 = r10;\t\t\t\t\\\n\t\t r4 += -32;\t\t\t\t\\\n\t\t r4 += r8;\t\t\t\t\\\n\t\t call %[bpf_ringbuf_reserve_dynptr];\t\\\n\t\t r9 = 0xeB9F;\t\t\t\t\\\n\t\t *(u64 *)(r10 - 16) = r9;\t\t\\\n\t\t r1 = r10;\t\t\t\t\\\n\t\t r1 += -32;\t\t\t\t\\\n\t\t r1 += r8;\t\t\t\t\\\n\t\t r2 = 0;\t\t\t\t\\\n\t\t call %[bpf_ringbuf_discard_dynptr];\t\"\n\t\t:\n\t\t: __imm(bpf_ringbuf_reserve_dynptr),\n\t\t  __imm(bpf_ringbuf_discard_dynptr),\n\t\t  __imm_addr(ringbuf)\n\t\t: __clobber_all\n\t);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"cannot overwrite referenced dynptr\") __log_level(2)\nint dynptr_partial_slot_invalidate(struct __sk_buff *ctx)\n{\n\tasm volatile (\n\t\t\"r6 = %[ringbuf] ll;\t\t\t\\\n\t\t r7 = %[array_map4] ll;\t\t\t\\\n\t\t r1 = r7;\t\t\t\t\\\n\t\t r2 = r10;\t\t\t\t\\\n\t\t r2 += -8;\t\t\t\t\\\n\t\t r9 = 0;\t\t\t\t\\\n\t\t *(u64 *)(r2 + 0) = r9;\t\t\t\\\n\t\t r3 = r2;\t\t\t\t\\\n\t\t r4 = 0;\t\t\t\t\\\n\t\t r8 = r2;\t\t\t\t\\\n\t\t call %[bpf_map_update_elem];\t\t\\\n\t\t r1 = r7;\t\t\t\t\\\n\t\t r2 = r8;\t\t\t\t\\\n\t\t call %[bpf_map_lookup_elem];\t\t\\\n\t\t if r0 != 0 goto sjmp1;\t\t\t\\\n\t\t exit;\t\t\t\t\t\\\n\tsjmp1:\t\t\t\t\t\t\\\n\t\t r7 = r0;\t\t\t\t\\\n\t\t r1 = r6;\t\t\t\t\\\n\t\t r2 = 8;\t\t\t\t\\\n\t\t r3 = 0;\t\t\t\t\\\n\t\t r4 = r10;\t\t\t\t\\\n\t\t r4 += -24;\t\t\t\t\\\n\t\t call %[bpf_ringbuf_reserve_dynptr];\t\\\n\t\t *(u64 *)(r10 - 16) = r9;\t\t\\\n\t\t r1 = r7;\t\t\t\t\\\n\t\t r2 = 8;\t\t\t\t\\\n\t\t r3 = 0;\t\t\t\t\\\n\t\t r4 = r10;\t\t\t\t\\\n\t\t r4 += -16;\t\t\t\t\\\n\t\t call %[bpf_dynptr_from_mem];\t\t\\\n\t\t r1 = r10;\t\t\t\t\\\n\t\t r1 += -512;\t\t\t\t\\\n\t\t r2 = 488;\t\t\t\t\\\n\t\t r3 = r10;\t\t\t\t\\\n\t\t r3 += -24;\t\t\t\t\\\n\t\t r4 = 0;\t\t\t\t\\\n\t\t r5 = 0;\t\t\t\t\\\n\t\t call %[bpf_dynptr_read];\t\t\\\n\t\t r8 = 1;\t\t\t\t\\\n\t\t if r0 != 0 goto sjmp2;\t\t\t\\\n\t\t r8 = 0;\t\t\t\t\\\n\tsjmp2:\t\t\t\t\t\t\\\n\t\t r1 = r10;\t\t\t\t\\\n\t\t r1 += -24;\t\t\t\t\\\n\t\t r2 = 0;\t\t\t\t\\\n\t\t call %[bpf_ringbuf_discard_dynptr];\t\"\n\t\t:\n\t\t: __imm(bpf_map_update_elem),\n\t\t  __imm(bpf_map_lookup_elem),\n\t\t  __imm(bpf_ringbuf_reserve_dynptr),\n\t\t  __imm(bpf_ringbuf_discard_dynptr),\n\t\t  __imm(bpf_dynptr_from_mem),\n\t\t  __imm(bpf_dynptr_read),\n\t\t  __imm_addr(ringbuf),\n\t\t  __imm_addr(array_map4)\n\t\t: __clobber_all\n\t);\n\treturn 0;\n}\n\n/* Test that it is allowed to overwrite unreferenced dynptr. */\nSEC(\"?raw_tp\")\n__success\nint dynptr_overwrite_unref(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\tif (get_map_val_dynptr(&ptr))\n\t\treturn 0;\n\tif (get_map_val_dynptr(&ptr))\n\t\treturn 0;\n\tif (get_map_val_dynptr(&ptr))\n\t\treturn 0;\n\n\treturn 0;\n}\n\n/* Test that slices are invalidated on reinitializing a dynptr. */\nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint dynptr_invalidate_slice_reinit(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\t__u8 *p;\n\n\tif (get_map_val_dynptr(&ptr))\n\t\treturn 0;\n\tp = bpf_dynptr_data(&ptr, 0, 1);\n\tif (!p)\n\t\treturn 0;\n\tif (get_map_val_dynptr(&ptr))\n\t\treturn 0;\n\t/* this should fail */\n\treturn *p;\n}\n\n/* Invalidation of dynptr slices on destruction of dynptr should not miss\n * mem_or_null pointers.\n */\nSEC(\"?raw_tp\")\n__failure __msg(\"R1 type=scalar expected=percpu_ptr_\")\nint dynptr_invalidate_slice_or_null(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\t__u8 *p;\n\n\tif (get_map_val_dynptr(&ptr))\n\t\treturn 0;\n\n\tp = bpf_dynptr_data(&ptr, 0, 1);\n\t*(__u8 *)&ptr = 0;\n\t/* this should fail */\n\tbpf_this_cpu_ptr(p);\n\treturn 0;\n}\n\n/* Destruction of dynptr should also any slices obtained from it */\nSEC(\"?raw_tp\")\n__failure __msg(\"R7 invalid mem access 'scalar'\")\nint dynptr_invalidate_slice_failure(void *ctx)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr ptr2;\n\t__u8 *p1, *p2;\n\n\tif (get_map_val_dynptr(&ptr1))\n\t\treturn 0;\n\tif (get_map_val_dynptr(&ptr2))\n\t\treturn 0;\n\n\tp1 = bpf_dynptr_data(&ptr1, 0, 1);\n\tif (!p1)\n\t\treturn 0;\n\tp2 = bpf_dynptr_data(&ptr2, 0, 1);\n\tif (!p2)\n\t\treturn 0;\n\n\t*(__u8 *)&ptr1 = 0;\n\t/* this should fail */\n\treturn *p1;\n}\n\n/* Invalidation of slices should be scoped and should not prevent dereferencing\n * slices of another dynptr after destroying unrelated dynptr\n */\nSEC(\"?raw_tp\")\n__success\nint dynptr_invalidate_slice_success(void *ctx)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr ptr2;\n\t__u8 *p1, *p2;\n\n\tif (get_map_val_dynptr(&ptr1))\n\t\treturn 1;\n\tif (get_map_val_dynptr(&ptr2))\n\t\treturn 1;\n\n\tp1 = bpf_dynptr_data(&ptr1, 0, 1);\n\tif (!p1)\n\t\treturn 1;\n\tp2 = bpf_dynptr_data(&ptr2, 0, 1);\n\tif (!p2)\n\t\treturn 1;\n\n\t*(__u8 *)&ptr1 = 0;\n\treturn *p2;\n}\n\n/* Overwriting referenced dynptr should be rejected */\nSEC(\"?raw_tp\")\n__failure __msg(\"cannot overwrite referenced dynptr\")\nint dynptr_overwrite_ref(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &ptr);\n\t/* this should fail */\n\tif (get_map_val_dynptr(&ptr))\n\t\tbpf_ringbuf_discard_dynptr(&ptr, 0);\n\treturn 0;\n}\n\n/* Reject writes to dynptr slot from bpf_dynptr_read */\nSEC(\"?raw_tp\")\n__failure __msg(\"potential write to dynptr at off=-16\")\nint dynptr_read_into_slot(void *ctx)\n{\n\tunion {\n\t\tstruct {\n\t\t\tchar _pad[48];\n\t\t\tstruct bpf_dynptr ptr;\n\t\t};\n\t\tchar buf[64];\n\t} data;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &data.ptr);\n\t/* this should fail */\n\tbpf_dynptr_read(data.buf, sizeof(data.buf), &data.ptr, 0, 0);\n\n\treturn 0;\n}\n\n/* bpf_dynptr_slice()s are read-only and cannot be written to */\nSEC(\"?tc\")\n__failure __msg(\"R0 cannot write into rdonly_mem\")\nint skb_invalid_slice_write(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\tchar buffer[sizeof(*hdr)] = {};\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\n\thdr = bpf_dynptr_slice(&ptr, 0, buffer, sizeof(buffer));\n\tif (!hdr)\n\t\treturn SK_DROP;\n\n\t/* this should fail */\n\thdr->h_proto = 1;\n\n\treturn SK_PASS;\n}\n\n/* The read-only data slice is invalidated whenever a helper changes packet data */\nSEC(\"?tc\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint skb_invalid_data_slice1(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\tchar buffer[sizeof(*hdr)] = {};\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\n\thdr = bpf_dynptr_slice(&ptr, 0, buffer, sizeof(buffer));\n\tif (!hdr)\n\t\treturn SK_DROP;\n\n\tval = hdr->h_proto;\n\n\tif (bpf_skb_pull_data(skb, skb->len))\n\t\treturn SK_DROP;\n\n\t/* this should fail */\n\tval = hdr->h_proto;\n\n\treturn SK_PASS;\n}\n\n/* The read-write data slice is invalidated whenever a helper changes packet data */\nSEC(\"?tc\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint skb_invalid_data_slice2(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\tchar buffer[sizeof(*hdr)] = {};\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\n\thdr = bpf_dynptr_slice_rdwr(&ptr, 0, buffer, sizeof(buffer));\n\tif (!hdr)\n\t\treturn SK_DROP;\n\n\thdr->h_proto = 123;\n\n\tif (bpf_skb_pull_data(skb, skb->len))\n\t\treturn SK_DROP;\n\n\t/* this should fail */\n\thdr->h_proto = 1;\n\n\treturn SK_PASS;\n}\n\n/* The read-only data slice is invalidated whenever bpf_dynptr_write() is called */\nSEC(\"?tc\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint skb_invalid_data_slice3(struct __sk_buff *skb)\n{\n\tchar write_data[64] = \"hello there, world!!\";\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\tchar buffer[sizeof(*hdr)] = {};\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\n\thdr = bpf_dynptr_slice(&ptr, 0, buffer, sizeof(buffer));\n\tif (!hdr)\n\t\treturn SK_DROP;\n\n\tval = hdr->h_proto;\n\n\tbpf_dynptr_write(&ptr, 0, write_data, sizeof(write_data), 0);\n\n\t/* this should fail */\n\tval = hdr->h_proto;\n\n\treturn SK_PASS;\n}\n\n/* The read-write data slice is invalidated whenever bpf_dynptr_write() is called */\nSEC(\"?tc\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint skb_invalid_data_slice4(struct __sk_buff *skb)\n{\n\tchar write_data[64] = \"hello there, world!!\";\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\tchar buffer[sizeof(*hdr)] = {};\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\thdr = bpf_dynptr_slice_rdwr(&ptr, 0, buffer, sizeof(buffer));\n\tif (!hdr)\n\t\treturn SK_DROP;\n\n\thdr->h_proto = 123;\n\n\tbpf_dynptr_write(&ptr, 0, write_data, sizeof(write_data), 0);\n\n\t/* this should fail */\n\thdr->h_proto = 1;\n\n\treturn SK_PASS;\n}\n\n/* The read-only data slice is invalidated whenever a helper changes packet data */\nSEC(\"?xdp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint xdp_invalid_data_slice1(struct xdp_md *xdp)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\tchar buffer[sizeof(*hdr)] = {};\n\n\tbpf_dynptr_from_xdp(xdp, 0, &ptr);\n\thdr = bpf_dynptr_slice(&ptr, 0, buffer, sizeof(buffer));\n\tif (!hdr)\n\t\treturn SK_DROP;\n\n\tval = hdr->h_proto;\n\n\tif (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(*hdr)))\n\t\treturn XDP_DROP;\n\n\t/* this should fail */\n\tval = hdr->h_proto;\n\n\treturn XDP_PASS;\n}\n\n/* The read-write data slice is invalidated whenever a helper changes packet data */\nSEC(\"?xdp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint xdp_invalid_data_slice2(struct xdp_md *xdp)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\tchar buffer[sizeof(*hdr)] = {};\n\n\tbpf_dynptr_from_xdp(xdp, 0, &ptr);\n\thdr = bpf_dynptr_slice_rdwr(&ptr, 0, buffer, sizeof(buffer));\n\tif (!hdr)\n\t\treturn SK_DROP;\n\n\thdr->h_proto = 9;\n\n\tif (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(*hdr)))\n\t\treturn XDP_DROP;\n\n\t/* this should fail */\n\thdr->h_proto = 1;\n\n\treturn XDP_PASS;\n}\n\n/* Only supported prog type can create skb-type dynptrs */\nSEC(\"?raw_tp\")\n__failure __msg(\"calling kernel function bpf_dynptr_from_skb is not allowed\")\nint skb_invalid_ctx(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\t/* this should fail */\n\tbpf_dynptr_from_skb(ctx, 0, &ptr);\n\n\treturn 0;\n}\n\n/* Reject writes to dynptr slot for uninit arg */\nSEC(\"?raw_tp\")\n__failure __msg(\"potential write to dynptr at off=-16\")\nint uninit_write_into_slot(void *ctx)\n{\n\tstruct {\n\t\tchar buf[64];\n\t\tstruct bpf_dynptr ptr;\n\t} data;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 80, 0, &data.ptr);\n\t/* this should fail */\n\tbpf_get_current_comm(data.buf, 80);\n\n\treturn 0;\n}\n\n/* Only supported prog type can create xdp-type dynptrs */\nSEC(\"?raw_tp\")\n__failure __msg(\"calling kernel function bpf_dynptr_from_xdp is not allowed\")\nint xdp_invalid_ctx(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\t/* this should fail */\n\tbpf_dynptr_from_xdp(ctx, 0, &ptr);\n\n\treturn 0;\n}\n\n__u32 hdr_size = sizeof(struct ethhdr);\n/* Can't pass in variable-sized len to bpf_dynptr_slice */\nSEC(\"?tc\")\n__failure __msg(\"unbounded memory access\")\nint dynptr_slice_var_len1(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\tchar buffer[sizeof(*hdr)] = {};\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\n\t/* this should fail */\n\thdr = bpf_dynptr_slice(&ptr, 0, buffer, hdr_size);\n\tif (!hdr)\n\t\treturn SK_DROP;\n\n\treturn SK_PASS;\n}\n\n/* Can't pass in variable-sized len to bpf_dynptr_slice */\nSEC(\"?tc\")\n__failure __msg(\"must be a known constant\")\nint dynptr_slice_var_len2(struct __sk_buff *skb)\n{\n\tchar buffer[sizeof(struct ethhdr)] = {};\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\n\tif (hdr_size <= sizeof(buffer)) {\n\t\t/* this should fail */\n\t\thdr = bpf_dynptr_slice_rdwr(&ptr, 0, buffer, hdr_size);\n\t\tif (!hdr)\n\t\t\treturn SK_DROP;\n\t\thdr->h_proto = 12;\n\t}\n\n\treturn SK_PASS;\n}\n\nstatic int callback(__u32 index, void *data)\n{\n        *(__u32 *)data = 123;\n\n        return 0;\n}\n\n/* If the dynptr is written into in a callback function, its data\n * slices should be invalidated as well.\n */\nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint invalid_data_slices(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\t__u32 *slice;\n\n\tif (get_map_val_dynptr(&ptr))\n\t\treturn 0;\n\n\tslice = bpf_dynptr_data(&ptr, 0, sizeof(__u32));\n\tif (!slice)\n\t\treturn 0;\n\n\tbpf_loop(10, callback, &ptr, 0);\n\n\t/* this should fail */\n\t*slice = 1;\n\n\treturn 0;\n}\n\n/* Program types that don't allow writes to packet data should fail if\n * bpf_dynptr_slice_rdwr is called\n */\nSEC(\"cgroup_skb/ingress\")\n__failure __msg(\"the prog does not allow writes to packet data\")\nint invalid_slice_rdwr_rdonly(struct __sk_buff *skb)\n{\n\tchar buffer[sizeof(struct ethhdr)] = {};\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\n\t/* this should fail since cgroup_skb doesn't allow\n\t * changing packet data\n\t */\n\thdr = bpf_dynptr_slice_rdwr(&ptr, 0, buffer, sizeof(buffer));\n\t__sink(hdr);\n\n\treturn 0;\n}\n\n/* bpf_dynptr_adjust can only be called on initialized dynptrs */\nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #1\")\nint dynptr_adjust_invalid(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\t/* this should fail */\n\tbpf_dynptr_adjust(&ptr, 1, 2);\n\n\treturn 0;\n}\n\n/* bpf_dynptr_is_null can only be called on initialized dynptrs */\nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #1\")\nint dynptr_is_null_invalid(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\t/* this should fail */\n\tbpf_dynptr_is_null(&ptr);\n\n\treturn 0;\n}\n\n/* bpf_dynptr_is_rdonly can only be called on initialized dynptrs */\nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #1\")\nint dynptr_is_rdonly_invalid(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\t/* this should fail */\n\tbpf_dynptr_is_rdonly(&ptr);\n\n\treturn 0;\n}\n\n/* bpf_dynptr_size can only be called on initialized dynptrs */\nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #1\")\nint dynptr_size_invalid(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\n\t/* this should fail */\n\tbpf_dynptr_size(&ptr);\n\n\treturn 0;\n}\n\n/* Only initialized dynptrs can be cloned */\nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #1\")\nint clone_invalid1(void *ctx)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr ptr2;\n\n\t/* this should fail */\n\tbpf_dynptr_clone(&ptr1, &ptr2);\n\n\treturn 0;\n}\n\n/* Can't overwrite an existing dynptr when cloning */\nSEC(\"?xdp\")\n__failure __msg(\"cannot overwrite referenced dynptr\")\nint clone_invalid2(struct xdp_md *xdp)\n{\n\tstruct bpf_dynptr ptr1;\n\tstruct bpf_dynptr clone;\n\n\tbpf_dynptr_from_xdp(xdp, 0, &ptr1);\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 64, 0, &clone);\n\n\t/* this should fail */\n\tbpf_dynptr_clone(&ptr1, &clone);\n\n\tbpf_ringbuf_submit_dynptr(&clone, 0);\n\n\treturn 0;\n}\n\n/* Invalidating a dynptr should invalidate its clones */\nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #3\")\nint clone_invalidate1(void *ctx)\n{\n\tstruct bpf_dynptr clone;\n\tstruct bpf_dynptr ptr;\n\tchar read_data[64];\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\tbpf_dynptr_clone(&ptr, &clone);\n\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\t/* this should fail */\n\tbpf_dynptr_read(read_data, sizeof(read_data), &clone, 0, 0);\n\n\treturn 0;\n}\n\n/* Invalidating a dynptr should invalidate its parent */\nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #3\")\nint clone_invalidate2(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct bpf_dynptr clone;\n\tchar read_data[64];\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\tbpf_dynptr_clone(&ptr, &clone);\n\n\tbpf_ringbuf_submit_dynptr(&clone, 0);\n\n\t/* this should fail */\n\tbpf_dynptr_read(read_data, sizeof(read_data), &ptr, 0, 0);\n\n\treturn 0;\n}\n\n/* Invalidating a dynptr should invalidate its siblings */\nSEC(\"?raw_tp\")\n__failure __msg(\"Expected an initialized dynptr as arg #3\")\nint clone_invalidate3(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct bpf_dynptr clone1;\n\tstruct bpf_dynptr clone2;\n\tchar read_data[64];\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\tbpf_dynptr_clone(&ptr, &clone1);\n\n\tbpf_dynptr_clone(&ptr, &clone2);\n\n\tbpf_ringbuf_submit_dynptr(&clone2, 0);\n\n\t/* this should fail */\n\tbpf_dynptr_read(read_data, sizeof(read_data), &clone1, 0, 0);\n\n\treturn 0;\n}\n\n/* Invalidating a dynptr should invalidate any data slices\n * of its clones\n */\nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint clone_invalidate4(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct bpf_dynptr clone;\n\tint *data;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\tbpf_dynptr_clone(&ptr, &clone);\n\tdata = bpf_dynptr_data(&clone, 0, sizeof(val));\n\tif (!data)\n\t\treturn 0;\n\n\tbpf_ringbuf_submit_dynptr(&ptr, 0);\n\n\t/* this should fail */\n\t*data = 123;\n\n\treturn 0;\n}\n\n/* Invalidating a dynptr should invalidate any data slices\n * of its parent\n */\nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint clone_invalidate5(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct bpf_dynptr clone;\n\tint *data;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\tdata = bpf_dynptr_data(&ptr, 0, sizeof(val));\n\tif (!data)\n\t\treturn 0;\n\n\tbpf_dynptr_clone(&ptr, &clone);\n\n\tbpf_ringbuf_submit_dynptr(&clone, 0);\n\n\t/* this should fail */\n\t*data = 123;\n\n\treturn 0;\n}\n\n/* Invalidating a dynptr should invalidate any data slices\n * of its sibling\n */\nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint clone_invalidate6(void *ctx)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct bpf_dynptr clone1;\n\tstruct bpf_dynptr clone2;\n\tint *data;\n\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, val, 0, &ptr);\n\n\tbpf_dynptr_clone(&ptr, &clone1);\n\n\tbpf_dynptr_clone(&ptr, &clone2);\n\n\tdata = bpf_dynptr_data(&clone1, 0, sizeof(val));\n\tif (!data)\n\t\treturn 0;\n\n\tbpf_ringbuf_submit_dynptr(&clone2, 0);\n\n\t/* this should fail */\n\t*data = 123;\n\n\treturn 0;\n}\n\n/* A skb clone's data slices should be invalid anytime packet data changes */\nSEC(\"?tc\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint clone_skb_packet_data(struct __sk_buff *skb)\n{\n\tchar buffer[sizeof(__u32)] = {};\n\tstruct bpf_dynptr clone;\n\tstruct bpf_dynptr ptr;\n\t__u32 *data;\n\n\tbpf_dynptr_from_skb(skb, 0, &ptr);\n\n\tbpf_dynptr_clone(&ptr, &clone);\n\tdata = bpf_dynptr_slice_rdwr(&clone, 0, buffer, sizeof(buffer));\n\tif (!data)\n\t\treturn XDP_DROP;\n\n\tif (bpf_skb_pull_data(skb, skb->len))\n\t\treturn SK_DROP;\n\n\t/* this should fail */\n\t*data = 123;\n\n\treturn 0;\n}\n\n/* A xdp clone's data slices should be invalid anytime packet data changes */\nSEC(\"?xdp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint clone_xdp_packet_data(struct xdp_md *xdp)\n{\n\tchar buffer[sizeof(__u32)] = {};\n\tstruct bpf_dynptr clone;\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *hdr;\n\t__u32 *data;\n\n\tbpf_dynptr_from_xdp(xdp, 0, &ptr);\n\n\tbpf_dynptr_clone(&ptr, &clone);\n\tdata = bpf_dynptr_slice_rdwr(&clone, 0, buffer, sizeof(buffer));\n\tif (!data)\n\t\treturn XDP_DROP;\n\n\tif (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(*hdr)))\n\t\treturn XDP_DROP;\n\n\t/* this should fail */\n\t*data = 123;\n\n\treturn 0;\n}\n\n/* Buffers that are provided must be sufficiently long */\nSEC(\"?cgroup_skb/egress\")\n__failure __msg(\"memory, len pair leads to invalid memory access\")\nint test_dynptr_skb_small_buff(struct __sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tchar buffer[8] = {};\n\t__u64 *data;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr)) {\n\t\terr = 1;\n\t\treturn 1;\n\t}\n\n\t \n\tdata = bpf_dynptr_slice(&ptr, 0, buffer, 9);\n\n\treturn !!data;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}