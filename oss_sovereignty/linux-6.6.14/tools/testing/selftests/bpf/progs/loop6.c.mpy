{
  "module_name": "loop6.c",
  "hash_id": "36d9c23b913427c52f7388da2bd4722045a4651da663859b4af9681a1c71a168",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/loop6.c",
  "human_readable_source": "\n\n#include <linux/ptrace.h>\n#include <stddef.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include \"bpf_misc.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n \n#define VIRTIO_MAX_SGS\t6\n\n \n#define WORKAROUND\n#ifdef WORKAROUND\n#define SG_MAX\t\t10\n#else\n \n#define SG_MAX\t\t128\n#endif\n\n#define SG_CHAIN\t0x01UL\n#define SG_END\t\t0x02UL\n\nstruct scatterlist {\n\tunsigned long   page_link;\n\tunsigned int    offset;\n\tunsigned int    length;\n};\n\n#define sg_is_chain(sg)\t\t((sg)->page_link & SG_CHAIN)\n#define sg_is_last(sg)\t\t((sg)->page_link & SG_END)\n#define sg_chain_ptr(sg)\t\\\n\t((struct scatterlist *) ((sg)->page_link & ~(SG_CHAIN | SG_END)))\n\nstatic inline struct scatterlist *__sg_next(struct scatterlist *sgp)\n{\n\tstruct scatterlist sg;\n\n\tbpf_probe_read_kernel(&sg, sizeof(sg), sgp);\n\tif (sg_is_last(&sg))\n\t\treturn NULL;\n\n\tsgp++;\n\n\tbpf_probe_read_kernel(&sg, sizeof(sg), sgp);\n\tif (sg_is_chain(&sg))\n\t\tsgp = sg_chain_ptr(&sg);\n\n\treturn sgp;\n}\n\nstatic inline struct scatterlist *get_sgp(struct scatterlist **sgs, int i)\n{\n\tstruct scatterlist *sgp;\n\n\tbpf_probe_read_kernel(&sgp, sizeof(sgp), sgs + i);\n\treturn sgp;\n}\n\nint config = 0;\nint result = 0;\n\nSEC(\"kprobe/virtqueue_add_sgs\")\nint BPF_KPROBE(trace_virtqueue_add_sgs, void *unused, struct scatterlist **sgs,\n\t       unsigned int out_sgs, unsigned int in_sgs)\n{\n\tstruct scatterlist *sgp = NULL;\n\t__u64 length1 = 0, length2 = 0;\n\tunsigned int i, n, len;\n\n\tif (config != 0)\n\t\treturn 0;\n\n\tfor (i = 0; (i < VIRTIO_MAX_SGS) && (i < out_sgs); i++) {\n\t\t__sink(out_sgs);\n\t\tfor (n = 0, sgp = get_sgp(sgs, i); sgp && (n < SG_MAX);\n\t\t     sgp = __sg_next(sgp)) {\n\t\t\tbpf_probe_read_kernel(&len, sizeof(len), &sgp->length);\n\t\t\tlength1 += len;\n\t\t\tn++;\n\t\t}\n\t}\n\n\tfor (i = 0; (i < VIRTIO_MAX_SGS) && (i < in_sgs); i++) {\n\t\t__sink(in_sgs);\n\t\tfor (n = 0, sgp = get_sgp(sgs, i); sgp && (n < SG_MAX);\n\t\t     sgp = __sg_next(sgp)) {\n\t\t\tbpf_probe_read_kernel(&len, sizeof(len), &sgp->length);\n\t\t\tlength2 += len;\n\t\t\tn++;\n\t\t}\n\t}\n\n\tconfig = 1;\n\tresult = length2 - length1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}