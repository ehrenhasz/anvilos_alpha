{
  "module_name": "xdp_features.c",
  "hash_id": "b6f7e12fae9c72c61be1d87c354de2c8d6fbd55780d59c5581ec46f6f20fa8e3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/xdp_features.c",
  "human_readable_source": "\n\n#include <stdbool.h>\n#include <linux/bpf.h>\n#include <linux/netdev.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_tracing.h>\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/udp.h>\n#include <asm-generic/errno-base.h>\n\n#include \"xdp_features.h\"\n\n#define ipv6_addr_equal(a, b)\t((a).s6_addr32[0] == (b).s6_addr32[0] &&\t\\\n\t\t\t\t (a).s6_addr32[1] == (b).s6_addr32[1] &&\t\\\n\t\t\t\t (a).s6_addr32[2] == (b).s6_addr32[2] &&\t\\\n\t\t\t\t (a).s6_addr32[3] == (b).s6_addr32[3])\n\nstruct net_device;\nstruct bpf_prog;\n\nstruct xdp_cpumap_stats {\n\tunsigned int redirect;\n\tunsigned int pass;\n\tunsigned int drop;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, __u32);\n\t__type(value, __u32);\n\t__uint(max_entries, 1);\n} stats SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, __u32);\n\t__type(value, __u32);\n\t__uint(max_entries, 1);\n} dut_stats SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_CPUMAP);\n\t__uint(key_size, sizeof(__u32));\n\t__uint(value_size, sizeof(struct bpf_cpumap_val));\n\t__uint(max_entries, 1);\n} cpu_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_DEVMAP);\n\t__uint(key_size, sizeof(__u32));\n\t__uint(value_size, sizeof(struct bpf_devmap_val));\n\t__uint(max_entries, 1);\n} dev_map SEC(\".maps\");\n\nconst volatile struct in6_addr tester_addr;\nconst volatile struct in6_addr dut_addr;\n\nstatic __always_inline int\nxdp_process_echo_packet(struct xdp_md *xdp, bool dut)\n{\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\tvoid *data = (void *)(long)xdp->data;\n\tstruct ethhdr *eh = data;\n\tstruct tlv_hdr *tlv;\n\tstruct udphdr *uh;\n\t__be16 port;\n\n\tif (eh + 1 > (struct ethhdr *)data_end)\n\t\treturn -EINVAL;\n\n\tif (eh->h_proto == bpf_htons(ETH_P_IP)) {\n\t\tstruct iphdr *ih = (struct iphdr *)(eh + 1);\n\t\t__be32 saddr = dut ? tester_addr.s6_addr32[3]\n\t\t\t\t   : dut_addr.s6_addr32[3];\n\t\t__be32 daddr = dut ? dut_addr.s6_addr32[3]\n\t\t\t\t   : tester_addr.s6_addr32[3];\n\n\t\tih = (struct iphdr *)(eh + 1);\n\t\tif (ih + 1 > (struct iphdr *)data_end)\n\t\t\treturn -EINVAL;\n\n\t\tif (saddr != ih->saddr)\n\t\t\treturn -EINVAL;\n\n\t\tif (daddr != ih->daddr)\n\t\t\treturn -EINVAL;\n\n\t\tif (ih->protocol != IPPROTO_UDP)\n\t\t\treturn -EINVAL;\n\n\t\tuh = (struct udphdr *)(ih + 1);\n\t} else if (eh->h_proto == bpf_htons(ETH_P_IPV6)) {\n\t\tstruct in6_addr saddr = dut ? tester_addr : dut_addr;\n\t\tstruct in6_addr daddr = dut ? dut_addr : tester_addr;\n\t\tstruct ipv6hdr *ih6 = (struct ipv6hdr *)(eh + 1);\n\n\t\tif (ih6 + 1 > (struct ipv6hdr *)data_end)\n\t\t\treturn -EINVAL;\n\n\t\tif (!ipv6_addr_equal(saddr, ih6->saddr))\n\t\t\treturn -EINVAL;\n\n\t\tif (!ipv6_addr_equal(daddr, ih6->daddr))\n\t\t\treturn -EINVAL;\n\n\t\tif (ih6->nexthdr != IPPROTO_UDP)\n\t\t\treturn -EINVAL;\n\n\t\tuh = (struct udphdr *)(ih6 + 1);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (uh + 1 > (struct udphdr *)data_end)\n\t\treturn -EINVAL;\n\n\tport = dut ? uh->dest : uh->source;\n\tif (port != bpf_htons(DUT_ECHO_PORT))\n\t\treturn -EINVAL;\n\n\ttlv = (struct tlv_hdr *)(uh + 1);\n\tif (tlv + 1 > data_end)\n\t\treturn -EINVAL;\n\n\treturn bpf_htons(tlv->type) == CMD_ECHO ? 0 : -EINVAL;\n}\n\nstatic __always_inline int\nxdp_update_stats(struct xdp_md *xdp, bool tx, bool dut)\n{\n\t__u32 *val, key = 0;\n\n\tif (xdp_process_echo_packet(xdp, tx))\n\t\treturn -EINVAL;\n\n\tif (dut)\n\t\tval = bpf_map_lookup_elem(&dut_stats, &key);\n\telse\n\t\tval = bpf_map_lookup_elem(&stats, &key);\n\n\tif (val)\n\t\t__sync_add_and_fetch(val, 1);\n\n\treturn 0;\n}\n\n \n\nSEC(\"xdp\")\nint xdp_tester_check_tx(struct xdp_md *xdp)\n{\n\txdp_update_stats(xdp, true, false);\n\n\treturn XDP_PASS;\n}\n\nSEC(\"xdp\")\nint xdp_tester_check_rx(struct xdp_md *xdp)\n{\n\txdp_update_stats(xdp, false, false);\n\n\treturn XDP_PASS;\n}\n\n \n\nSEC(\"xdp\")\nint xdp_do_pass(struct xdp_md *xdp)\n{\n\txdp_update_stats(xdp, true, true);\n\n\treturn XDP_PASS;\n}\n\nSEC(\"xdp\")\nint xdp_do_drop(struct xdp_md *xdp)\n{\n\tif (xdp_update_stats(xdp, true, true))\n\t\treturn XDP_PASS;\n\n\treturn XDP_DROP;\n}\n\nSEC(\"xdp\")\nint xdp_do_aborted(struct xdp_md *xdp)\n{\n\tif (xdp_process_echo_packet(xdp, true))\n\t\treturn XDP_PASS;\n\n\treturn XDP_ABORTED;\n}\n\nSEC(\"xdp\")\nint xdp_do_tx(struct xdp_md *xdp)\n{\n\tvoid *data = (void *)(long)xdp->data;\n\tstruct ethhdr *eh = data;\n\t__u8 tmp_mac[ETH_ALEN];\n\n\tif (xdp_update_stats(xdp, true, true))\n\t\treturn XDP_PASS;\n\n\t__builtin_memcpy(tmp_mac, eh->h_source, ETH_ALEN);\n\t__builtin_memcpy(eh->h_source, eh->h_dest, ETH_ALEN);\n\t__builtin_memcpy(eh->h_dest, tmp_mac, ETH_ALEN);\n\n\treturn XDP_TX;\n}\n\nSEC(\"xdp\")\nint xdp_do_redirect(struct xdp_md *xdp)\n{\n\tif (xdp_process_echo_packet(xdp, true))\n\t\treturn XDP_PASS;\n\n\treturn bpf_redirect_map(&cpu_map, 0, 0);\n}\n\nSEC(\"tp_btf/xdp_exception\")\nint BPF_PROG(xdp_exception, const struct net_device *dev,\n\t     const struct bpf_prog *xdp, __u32 act)\n{\n\t__u32 *val, key = 0;\n\n\tval = bpf_map_lookup_elem(&dut_stats, &key);\n\tif (val)\n\t\t__sync_add_and_fetch(val, 1);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/xdp_cpumap_kthread\")\nint BPF_PROG(tp_xdp_cpumap_kthread, int map_id, unsigned int processed,\n\t     unsigned int drops, int sched, struct xdp_cpumap_stats *xdp_stats)\n{\n\t__u32 *val, key = 0;\n\n\tval = bpf_map_lookup_elem(&dut_stats, &key);\n\tif (val)\n\t\t__sync_add_and_fetch(val, 1);\n\n\treturn 0;\n}\n\nSEC(\"xdp/cpumap\")\nint xdp_do_redirect_cpumap(struct xdp_md *xdp)\n{\n\tvoid *data = (void *)(long)xdp->data;\n\tstruct ethhdr *eh = data;\n\t__u8 tmp_mac[ETH_ALEN];\n\n\tif (xdp_process_echo_packet(xdp, true))\n\t\treturn XDP_PASS;\n\n\t__builtin_memcpy(tmp_mac, eh->h_source, ETH_ALEN);\n\t__builtin_memcpy(eh->h_source, eh->h_dest, ETH_ALEN);\n\t__builtin_memcpy(eh->h_dest, tmp_mac, ETH_ALEN);\n\n\treturn bpf_redirect_map(&dev_map, 0, 0);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}