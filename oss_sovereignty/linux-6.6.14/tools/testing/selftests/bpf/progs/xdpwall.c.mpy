{
  "module_name": "xdpwall.c",
  "hash_id": "325c0db1b92fb37a2d530549ccdd67dea3db1c8adac2e996cf333cf4089e68dd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/xdpwall.c",
  "human_readable_source": "\n \n#include <stdbool.h>\n#include <stdint.h>\n#include <linux/stddef.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/bpf.h>\n#include <linux/types.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_helpers.h>\n\nenum pkt_parse_err {\n\tNO_ERR,\n\tBAD_IP6_HDR,\n\tBAD_IP4GUE_HDR,\n\tBAD_IP6GUE_HDR,\n};\n\nenum pkt_flag {\n\tTUNNEL = 0x1,\n\tTCP_SYN = 0x2,\n\tQUIC_INITIAL_FLAG = 0x4,\n\tTCP_ACK = 0x8,\n\tTCP_RST = 0x10\n};\n\nstruct v4_lpm_key {\n\t__u32 prefixlen;\n\t__u32 src;\n};\n\nstruct v4_lpm_val {\n\tstruct v4_lpm_key key;\n\t__u8 val;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 16);\n\t__type(key, struct in6_addr);\n\t__type(value, bool);\n} v6_addr_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 16);\n\t__type(key, __u32);\n\t__type(value, bool);\n} v4_addr_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_LPM_TRIE);\n\t__uint(max_entries, 16);\n\t__uint(key_size, sizeof(struct v4_lpm_key));\n\t__uint(value_size, sizeof(struct v4_lpm_val));\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n} v4_lpm_val_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 16);\n\t__type(key, int);\n\t__type(value, __u8);\n} tcp_port_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 16);\n\t__type(key, int);\n\t__type(value, __u16);\n} udp_port_map SEC(\".maps\");\n\nenum ip_type { V4 = 1, V6 = 2 };\n\nstruct fw_match_info {\n\t__u8 v4_src_ip_match;\n\t__u8 v6_src_ip_match;\n\t__u8 v4_src_prefix_match;\n\t__u8 v4_dst_prefix_match;\n\t__u8 tcp_dp_match;\n\t__u16 udp_sp_match;\n\t__u16 udp_dp_match;\n\tbool is_tcp;\n\tbool is_tcp_syn;\n};\n\nstruct pkt_info {\n\tenum ip_type type;\n\tunion {\n\t\tstruct iphdr *ipv4;\n\t\tstruct ipv6hdr *ipv6;\n\t} ip;\n\tint sport;\n\tint dport;\n\t__u16 trans_hdr_offset;\n\t__u8 proto;\n\t__u8 flags;\n};\n\nstatic __always_inline struct ethhdr *parse_ethhdr(void *data, void *data_end)\n{\n\tstruct ethhdr *eth = data;\n\n\tif (eth + 1 > data_end)\n\t\treturn NULL;\n\n\treturn eth;\n}\n\nstatic __always_inline __u8 filter_ipv6_addr(const struct in6_addr *ipv6addr)\n{\n\t__u8 *leaf;\n\n\tleaf = bpf_map_lookup_elem(&v6_addr_map, ipv6addr);\n\n\treturn leaf ? *leaf : 0;\n}\n\nstatic __always_inline __u8 filter_ipv4_addr(const __u32 ipaddr)\n{\n\t__u8 *leaf;\n\n\tleaf = bpf_map_lookup_elem(&v4_addr_map, &ipaddr);\n\n\treturn leaf ? *leaf : 0;\n}\n\nstatic __always_inline __u8 filter_ipv4_lpm(const __u32 ipaddr)\n{\n\tstruct v4_lpm_key v4_key = {};\n\tstruct v4_lpm_val *lpm_val;\n\n\tv4_key.src = ipaddr;\n\tv4_key.prefixlen = 32;\n\n\tlpm_val = bpf_map_lookup_elem(&v4_lpm_val_map, &v4_key);\n\n\treturn lpm_val ? lpm_val->val : 0;\n}\n\n\nstatic __always_inline void\nfilter_src_dst_ip(struct pkt_info* info, struct fw_match_info* match_info)\n{\n\tif (info->type == V6) {\n\t\tmatch_info->v6_src_ip_match =\n\t\t\tfilter_ipv6_addr(&info->ip.ipv6->saddr);\n\t} else if (info->type == V4) {\n\t\tmatch_info->v4_src_ip_match =\n\t\t\tfilter_ipv4_addr(info->ip.ipv4->saddr);\n\t\tmatch_info->v4_src_prefix_match =\n\t\t\tfilter_ipv4_lpm(info->ip.ipv4->saddr);\n\t\tmatch_info->v4_dst_prefix_match =\n\t\t\tfilter_ipv4_lpm(info->ip.ipv4->daddr);\n\t}\n}\n\nstatic __always_inline void *\nget_transport_hdr(__u16 offset, void *data, void *data_end)\n{\n\tif (offset > 255 || data + offset > data_end)\n\t\treturn NULL;\n\n\treturn data + offset;\n}\n\nstatic __always_inline bool tcphdr_only_contains_flag(struct tcphdr *tcp,\n\t\t\t\t\t\t      __u32 FLAG)\n{\n\treturn (tcp_flag_word(tcp) &\n\t\t(TCP_FLAG_ACK | TCP_FLAG_RST | TCP_FLAG_SYN | TCP_FLAG_FIN)) == FLAG;\n}\n\nstatic __always_inline void set_tcp_flags(struct pkt_info *info,\n\t\t\t\t\t  struct tcphdr *tcp) {\n\tif (tcphdr_only_contains_flag(tcp, TCP_FLAG_SYN))\n\t\tinfo->flags |= TCP_SYN;\n\telse if (tcphdr_only_contains_flag(tcp, TCP_FLAG_ACK))\n\t\tinfo->flags |= TCP_ACK;\n\telse if (tcphdr_only_contains_flag(tcp, TCP_FLAG_RST))\n\t\tinfo->flags |= TCP_RST;\n}\n\nstatic __always_inline bool\nparse_tcp(struct pkt_info *info, void *transport_hdr, void *data_end)\n{\n\tstruct tcphdr *tcp = transport_hdr;\n\n\tif (tcp + 1 > data_end)\n\t\treturn false;\n\n\tinfo->sport = bpf_ntohs(tcp->source);\n\tinfo->dport = bpf_ntohs(tcp->dest);\n\tset_tcp_flags(info, tcp);\n\n\treturn true;\n}\n\nstatic __always_inline bool\nparse_udp(struct pkt_info *info, void *transport_hdr, void *data_end)\n{\n\tstruct udphdr *udp = transport_hdr;\n\n\tif (udp + 1 > data_end)\n\t\treturn false;\n\n\tinfo->sport = bpf_ntohs(udp->source);\n\tinfo->dport = bpf_ntohs(udp->dest);\n\n\treturn true;\n}\n\nstatic __always_inline __u8 filter_tcp_port(int port)\n{\n\t__u8 *leaf = bpf_map_lookup_elem(&tcp_port_map, &port);\n\n\treturn leaf ? *leaf : 0;\n}\n\nstatic __always_inline __u16 filter_udp_port(int port)\n{\n\t__u16 *leaf = bpf_map_lookup_elem(&udp_port_map, &port);\n\n\treturn leaf ? *leaf : 0;\n}\n\nstatic __always_inline bool\nfilter_transport_hdr(void *transport_hdr, void *data_end,\n\t\t     struct pkt_info *info, struct fw_match_info *match_info)\n{\n\tif (info->proto == IPPROTO_TCP) {\n\t\tif (!parse_tcp(info, transport_hdr, data_end))\n\t\t\treturn false;\n\n\t\tmatch_info->is_tcp = true;\n\t\tmatch_info->is_tcp_syn = (info->flags & TCP_SYN) > 0;\n\n\t\tmatch_info->tcp_dp_match = filter_tcp_port(info->dport);\n\t} else if (info->proto == IPPROTO_UDP) {\n\t\tif (!parse_udp(info, transport_hdr, data_end))\n\t\t\treturn false;\n\n\t\tmatch_info->udp_dp_match = filter_udp_port(info->dport);\n\t\tmatch_info->udp_sp_match = filter_udp_port(info->sport);\n\t}\n\n\treturn true;\n}\n\nstatic __always_inline __u8\nparse_gue_v6(struct pkt_info *info, struct ipv6hdr *ip6h, void *data_end)\n{\n\tstruct udphdr *udp = (struct udphdr *)(ip6h + 1);\n\tvoid *encap_data = udp + 1;\n\n\tif (udp + 1 > data_end)\n\t\treturn BAD_IP6_HDR;\n\n\tif (udp->dest != bpf_htons(6666))\n\t\treturn NO_ERR;\n\n\tinfo->flags |= TUNNEL;\n\n\tif (encap_data + 1 > data_end)\n\t\treturn BAD_IP6GUE_HDR;\n\n\tif (*(__u8 *)encap_data & 0x30) {\n\t\tstruct ipv6hdr *inner_ip6h = encap_data;\n\n\t\tif (inner_ip6h + 1 > data_end)\n\t\t\treturn BAD_IP6GUE_HDR;\n\n\t\tinfo->type = V6;\n\t\tinfo->proto = inner_ip6h->nexthdr;\n\t\tinfo->ip.ipv6 = inner_ip6h;\n\t\tinfo->trans_hdr_offset += sizeof(struct ipv6hdr) + sizeof(struct udphdr);\n\t} else {\n\t\tstruct iphdr *inner_ip4h = encap_data;\n\n\t\tif (inner_ip4h + 1 > data_end)\n\t\t\treturn BAD_IP6GUE_HDR;\n\n\t\tinfo->type = V4;\n\t\tinfo->proto = inner_ip4h->protocol;\n\t\tinfo->ip.ipv4 = inner_ip4h;\n\t\tinfo->trans_hdr_offset += sizeof(struct iphdr) + sizeof(struct udphdr);\n\t}\n\n\treturn NO_ERR;\n}\n\nstatic __always_inline __u8 parse_ipv6_gue(struct pkt_info *info,\n\t\t\t\t\t   void *data, void *data_end)\n{\n\tstruct ipv6hdr *ip6h = data + sizeof(struct ethhdr);\n\n\tif (ip6h + 1 > data_end)\n\t\treturn BAD_IP6_HDR;\n\n\tinfo->proto = ip6h->nexthdr;\n\tinfo->ip.ipv6 = ip6h;\n\tinfo->type = V6;\n\tinfo->trans_hdr_offset = sizeof(struct ethhdr) + sizeof(struct ipv6hdr);\n\n\tif (info->proto == IPPROTO_UDP)\n\t\treturn parse_gue_v6(info, ip6h, data_end);\n\n\treturn NO_ERR;\n}\n\nSEC(\"xdp\")\nint edgewall(struct xdp_md *ctx)\n{\n\tvoid *data_end = (void *)(long)(ctx->data_end);\n\tvoid *data = (void *)(long)(ctx->data);\n\tstruct fw_match_info match_info = {};\n\tstruct pkt_info info = {};\n\tvoid *transport_hdr;\n\tstruct ethhdr *eth;\n\tbool filter_res;\n\t__u32 proto;\n\n\teth = parse_ethhdr(data, data_end);\n\tif (!eth)\n\t\treturn XDP_DROP;\n\n\tproto = eth->h_proto;\n\tif (proto != bpf_htons(ETH_P_IPV6))\n\t\treturn XDP_DROP;\n\n\tif (parse_ipv6_gue(&info, data, data_end))\n\t\treturn XDP_DROP;\n\n\tif (info.proto == IPPROTO_ICMPV6)\n\t\treturn XDP_PASS;\n\n\tif (info.proto != IPPROTO_TCP && info.proto != IPPROTO_UDP)\n\t\treturn XDP_DROP;\n\n\tfilter_src_dst_ip(&info, &match_info);\n\n\ttransport_hdr = get_transport_hdr(info.trans_hdr_offset, data,\n\t\t\t\t\t  data_end);\n\tif (!transport_hdr)\n\t\treturn XDP_DROP;\n\n\tfilter_res = filter_transport_hdr(transport_hdr, data_end,\n\t\t\t\t\t  &info, &match_info);\n\tif (!filter_res)\n\t\treturn XDP_DROP;\n\n\tif (match_info.is_tcp && !match_info.is_tcp_syn)\n\t\treturn XDP_PASS;\n\n\treturn XDP_DROP;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}