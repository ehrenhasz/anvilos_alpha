{
  "module_name": "atomics.c",
  "hash_id": "7dfe92490cd17d5f00cdf04ab001a595dcf6277c34830a5c7f65c61952f88c7d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/atomics.c",
  "human_readable_source": "\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <stdbool.h>\n\n#ifdef ENABLE_ATOMICS_TESTS\nbool skip_tests __attribute((__section__(\".data\"))) = false;\n#else\nbool skip_tests = true;\n#endif\n\n__u32 pid = 0;\n\n__u64 add64_value = 1;\n__u64 add64_result = 0;\n__u32 add32_value = 1;\n__u32 add32_result = 0;\n__u64 add_stack_value_copy = 0;\n__u64 add_stack_result = 0;\n__u64 add_noreturn_value = 1;\n\nSEC(\"raw_tp/sys_enter\")\nint add(const void *ctx)\n{\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n#ifdef ENABLE_ATOMICS_TESTS\n\t__u64 add_stack_value = 1;\n\n\tadd64_result = __sync_fetch_and_add(&add64_value, 2);\n\tadd32_result = __sync_fetch_and_add(&add32_value, 2);\n\tadd_stack_result = __sync_fetch_and_add(&add_stack_value, 2);\n\tadd_stack_value_copy = add_stack_value;\n\t__sync_fetch_and_add(&add_noreturn_value, 2);\n#endif\n\n\treturn 0;\n}\n\n__s64 sub64_value = 1;\n__s64 sub64_result = 0;\n__s32 sub32_value = 1;\n__s32 sub32_result = 0;\n__s64 sub_stack_value_copy = 0;\n__s64 sub_stack_result = 0;\n__s64 sub_noreturn_value = 1;\n\nSEC(\"raw_tp/sys_enter\")\nint sub(const void *ctx)\n{\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n#ifdef ENABLE_ATOMICS_TESTS\n\t__u64 sub_stack_value = 1;\n\n\tsub64_result = __sync_fetch_and_sub(&sub64_value, 2);\n\tsub32_result = __sync_fetch_and_sub(&sub32_value, 2);\n\tsub_stack_result = __sync_fetch_and_sub(&sub_stack_value, 2);\n\tsub_stack_value_copy = sub_stack_value;\n\t__sync_fetch_and_sub(&sub_noreturn_value, 2);\n#endif\n\n\treturn 0;\n}\n\n__u64 and64_value = (0x110ull << 32);\n__u64 and64_result = 0;\n__u32 and32_value = 0x110;\n__u32 and32_result = 0;\n__u64 and_noreturn_value = (0x110ull << 32);\n\nSEC(\"raw_tp/sys_enter\")\nint and(const void *ctx)\n{\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n#ifdef ENABLE_ATOMICS_TESTS\n\n\tand64_result = __sync_fetch_and_and(&and64_value, 0x011ull << 32);\n\tand32_result = __sync_fetch_and_and(&and32_value, 0x011);\n\t__sync_fetch_and_and(&and_noreturn_value, 0x011ull << 32);\n#endif\n\n\treturn 0;\n}\n\n__u64 or64_value = (0x110ull << 32);\n__u64 or64_result = 0;\n__u32 or32_value = 0x110;\n__u32 or32_result = 0;\n__u64 or_noreturn_value = (0x110ull << 32);\n\nSEC(\"raw_tp/sys_enter\")\nint or(const void *ctx)\n{\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n#ifdef ENABLE_ATOMICS_TESTS\n\tor64_result = __sync_fetch_and_or(&or64_value, 0x011ull << 32);\n\tor32_result = __sync_fetch_and_or(&or32_value, 0x011);\n\t__sync_fetch_and_or(&or_noreturn_value, 0x011ull << 32);\n#endif\n\n\treturn 0;\n}\n\n__u64 xor64_value = (0x110ull << 32);\n__u64 xor64_result = 0;\n__u32 xor32_value = 0x110;\n__u32 xor32_result = 0;\n__u64 xor_noreturn_value = (0x110ull << 32);\n\nSEC(\"raw_tp/sys_enter\")\nint xor(const void *ctx)\n{\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n#ifdef ENABLE_ATOMICS_TESTS\n\txor64_result = __sync_fetch_and_xor(&xor64_value, 0x011ull << 32);\n\txor32_result = __sync_fetch_and_xor(&xor32_value, 0x011);\n\t__sync_fetch_and_xor(&xor_noreturn_value, 0x011ull << 32);\n#endif\n\n\treturn 0;\n}\n\n__u64 cmpxchg64_value = 1;\n__u64 cmpxchg64_result_fail = 0;\n__u64 cmpxchg64_result_succeed = 0;\n__u32 cmpxchg32_value = 1;\n__u32 cmpxchg32_result_fail = 0;\n__u32 cmpxchg32_result_succeed = 0;\n\nSEC(\"raw_tp/sys_enter\")\nint cmpxchg(const void *ctx)\n{\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n#ifdef ENABLE_ATOMICS_TESTS\n\tcmpxchg64_result_fail = __sync_val_compare_and_swap(&cmpxchg64_value, 0, 3);\n\tcmpxchg64_result_succeed = __sync_val_compare_and_swap(&cmpxchg64_value, 1, 2);\n\n\tcmpxchg32_result_fail = __sync_val_compare_and_swap(&cmpxchg32_value, 0, 3);\n\tcmpxchg32_result_succeed = __sync_val_compare_and_swap(&cmpxchg32_value, 1, 2);\n#endif\n\n\treturn 0;\n}\n\n__u64 xchg64_value = 1;\n__u64 xchg64_result = 0;\n__u32 xchg32_value = 1;\n__u32 xchg32_result = 0;\n\nSEC(\"raw_tp/sys_enter\")\nint xchg(const void *ctx)\n{\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n#ifdef ENABLE_ATOMICS_TESTS\n\t__u64 val64 = 2;\n\t__u32 val32 = 2;\n\n\txchg64_result = __sync_lock_test_and_set(&xchg64_value, val64);\n\txchg32_result = __sync_lock_test_and_set(&xchg32_value, val32);\n#endif\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}