{
  "module_name": "timer.c",
  "hash_id": "ed81467a2bca9ac93ebcebe1745e0330e8c69e5e8f183729182ed347d95d5e38",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/timer.c",
  "human_readable_source": "\n \n#include <linux/bpf.h>\n#include <time.h>\n#include <errno.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_tcp_helpers.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\nstruct hmap_elem {\n\tint counter;\n\tstruct bpf_timer timer;\n\tstruct bpf_spin_lock lock;  \n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1000);\n\t__type(key, int);\n\t__type(value, struct hmap_elem);\n} hmap SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__uint(max_entries, 1000);\n\t__type(key, int);\n\t__type(value, struct hmap_elem);\n} hmap_malloc SEC(\".maps\");\n\nstruct elem {\n\tstruct bpf_timer t;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 2);\n\t__type(key, int);\n\t__type(value, struct elem);\n} array SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_LRU_HASH);\n\t__uint(max_entries, 4);\n\t__type(key, int);\n\t__type(value, struct elem);\n} lru SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, struct elem);\n} abs_timer SEC(\".maps\");\n\n__u64 bss_data;\n__u64 abs_data;\n__u64 err;\n__u64 ok;\n__u64 callback_check = 52;\n__u64 callback2_check = 52;\n\n#define ARRAY 1\n#define HTAB 2\n#define HTAB_MALLOC 3\n#define LRU 4\n\n \nstatic int timer_cb1(void *map, int *key, struct bpf_timer *timer)\n{\n\t \n\tbss_data += 5;\n\n\t \n\tif (*key == ARRAY) {\n\t\tstruct bpf_timer *lru_timer;\n\t\tint lru_key = LRU;\n\n\t\t \n\t\tif (bpf_timer_start(timer, 1ull << 35, 0) != 0)\n\t\t\terr |= 1;\n\n\t\tlru_timer = bpf_map_lookup_elem(&lru, &lru_key);\n\t\tif (!lru_timer)\n\t\t\treturn 0;\n\t\tbpf_timer_set_callback(lru_timer, timer_cb1);\n\t\tif (bpf_timer_start(lru_timer, 0, 0) != 0)\n\t\t\terr |= 2;\n\t} else if (*key == LRU) {\n\t\tint lru_key, i;\n\n\t\tfor (i = LRU + 1;\n\t\t     i <= 100   ;\n\t\t     i++) {\n\t\t\tstruct elem init = {};\n\n\t\t\t \n\t\t\tlru_key = i;\n\n\t\t\t \n\t\t\tbpf_map_update_elem(map, &lru_key, &init, 0);\n\t\t\t \n\t\t\tbpf_map_lookup_elem(map, &lru_key);\n\n\t\t\t \n\t\t\tif (*key != LRU)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (bpf_timer_cancel(timer) != -EINVAL)\n\t\t\terr |= 4;\n\t\tok |= 1;\n\t}\n\treturn 0;\n}\n\nSEC(\"fentry/bpf_fentry_test1\")\nint BPF_PROG2(test1, int, a)\n{\n\tstruct bpf_timer *arr_timer, *lru_timer;\n\tstruct elem init = {};\n\tint lru_key = LRU;\n\tint array_key = ARRAY;\n\n\tarr_timer = bpf_map_lookup_elem(&array, &array_key);\n\tif (!arr_timer)\n\t\treturn 0;\n\tbpf_timer_init(arr_timer, &array, CLOCK_MONOTONIC);\n\n\tbpf_map_update_elem(&lru, &lru_key, &init, 0);\n\tlru_timer = bpf_map_lookup_elem(&lru, &lru_key);\n\tif (!lru_timer)\n\t\treturn 0;\n\tbpf_timer_init(lru_timer, &lru, CLOCK_MONOTONIC);\n\n\tbpf_timer_set_callback(arr_timer, timer_cb1);\n\tbpf_timer_start(arr_timer, 0  , 0);\n\n\t \n\tarray_key = 0;\n\tarr_timer = bpf_map_lookup_elem(&array, &array_key);\n\tif (!arr_timer)\n\t\treturn 0;\n\tbpf_timer_init(arr_timer, &array, CLOCK_MONOTONIC);\n\treturn 0;\n}\n\n \nstatic int timer_cb2(void *map, int *key, struct hmap_elem *val)\n{\n\tif (*key == HTAB)\n\t\tcallback_check--;\n\telse\n\t\tcallback2_check--;\n\tif (val->counter > 0 && --val->counter) {\n\t\t \n\t\tbpf_timer_start(&val->timer, 1000, 0);\n\t} else if (*key == HTAB) {\n\t\tstruct bpf_timer *arr_timer;\n\t\tint array_key = ARRAY;\n\n\t\t \n\t\tarr_timer = bpf_map_lookup_elem(&array, &array_key);\n\t\tif (!arr_timer)\n\t\t\treturn 0;\n\t\tif (bpf_timer_cancel(arr_timer) != 1)\n\t\t\t \n\t\t\terr |= 8;\n\n\t\t \n\t\tif (bpf_timer_cancel(&val->timer) != -EDEADLK)\n\t\t\terr |= 16;\n\n\t\t \n\t\tbpf_map_delete_elem(map, key);\n\n\t\t \n\t\tif (bpf_timer_start(&val->timer, 1000, 0) != -EINVAL)\n\t\t\terr |= 32;\n\t\tok |= 2;\n\t} else {\n\t\tif (*key != HTAB_MALLOC)\n\t\t\terr |= 64;\n\n\t\t \n\t\tif (bpf_timer_cancel(&val->timer) != -EDEADLK)\n\t\t\terr |= 128;\n\n\t\t \n\t\tbpf_map_delete_elem(map, key);\n\n\t\tok |= 4;\n\t}\n\treturn 0;\n}\n\nint bpf_timer_test(void)\n{\n\tstruct hmap_elem *val;\n\tint key = HTAB, key_malloc = HTAB_MALLOC;\n\n\tval = bpf_map_lookup_elem(&hmap, &key);\n\tif (val) {\n\t\tif (bpf_timer_init(&val->timer, &hmap, CLOCK_BOOTTIME) != 0)\n\t\t\terr |= 512;\n\t\tbpf_timer_set_callback(&val->timer, timer_cb2);\n\t\tbpf_timer_start(&val->timer, 1000, 0);\n\t}\n\tval = bpf_map_lookup_elem(&hmap_malloc, &key_malloc);\n\tif (val) {\n\t\tif (bpf_timer_init(&val->timer, &hmap_malloc, CLOCK_BOOTTIME) != 0)\n\t\t\terr |= 1024;\n\t\tbpf_timer_set_callback(&val->timer, timer_cb2);\n\t\tbpf_timer_start(&val->timer, 1000, 0);\n\t}\n\treturn 0;\n}\n\nSEC(\"fentry/bpf_fentry_test2\")\nint BPF_PROG2(test2, int, a, int, b)\n{\n\tstruct hmap_elem init = {}, *val;\n\tint key = HTAB, key_malloc = HTAB_MALLOC;\n\n\tinit.counter = 10;  \n\tbpf_map_update_elem(&hmap, &key, &init, 0);\n\tval = bpf_map_lookup_elem(&hmap, &key);\n\tif (val)\n\t\tbpf_timer_init(&val->timer, &hmap, CLOCK_BOOTTIME);\n\t \n\tbpf_map_update_elem(&hmap, &key, &init, 0);\n\n\tbpf_map_update_elem(&hmap_malloc, &key_malloc, &init, 0);\n\tval = bpf_map_lookup_elem(&hmap_malloc, &key_malloc);\n\tif (val)\n\t\tbpf_timer_init(&val->timer, &hmap_malloc, CLOCK_BOOTTIME);\n\t \n\tbpf_map_update_elem(&hmap_malloc, &key_malloc, &init, 0);\n\n\t \n\tkey = 0;\n\tbpf_map_update_elem(&hmap, &key, &init, 0);\n\tval = bpf_map_lookup_elem(&hmap, &key);\n\tif (val)\n\t\tbpf_timer_init(&val->timer, &hmap, CLOCK_BOOTTIME);\n\tbpf_map_delete_elem(&hmap, &key);\n\tbpf_map_update_elem(&hmap, &key, &init, 0);\n\tval = bpf_map_lookup_elem(&hmap, &key);\n\tif (val)\n\t\tbpf_timer_init(&val->timer, &hmap, CLOCK_BOOTTIME);\n\n\t \n\tkey_malloc = 0;\n\tbpf_map_update_elem(&hmap_malloc, &key_malloc, &init, 0);\n\tval = bpf_map_lookup_elem(&hmap_malloc, &key_malloc);\n\tif (val)\n\t\tbpf_timer_init(&val->timer, &hmap_malloc, CLOCK_BOOTTIME);\n\tbpf_map_delete_elem(&hmap_malloc, &key_malloc);\n\tbpf_map_update_elem(&hmap_malloc, &key_malloc, &init, 0);\n\tval = bpf_map_lookup_elem(&hmap_malloc, &key_malloc);\n\tif (val)\n\t\tbpf_timer_init(&val->timer, &hmap_malloc, CLOCK_BOOTTIME);\n\n\treturn bpf_timer_test();\n}\n\n \nstatic int timer_cb3(void *map, int *key, struct bpf_timer *timer)\n{\n\tabs_data += 6;\n\n\tif (abs_data < 12) {\n\t\tbpf_timer_start(timer, bpf_ktime_get_boot_ns() + 1000,\n\t\t\t\tBPF_F_TIMER_ABS);\n\t} else {\n\t\t \n\t\tbpf_timer_start(timer, bpf_ktime_get_boot_ns() + (1ull << 35),\n\t\t\t\tBPF_F_TIMER_ABS);\n\t}\n\n\treturn 0;\n}\n\nSEC(\"fentry/bpf_fentry_test3\")\nint BPF_PROG2(test3, int, a)\n{\n\tint key = 0;\n\tstruct bpf_timer *timer;\n\n\tbpf_printk(\"test3\");\n\n\ttimer = bpf_map_lookup_elem(&abs_timer, &key);\n\tif (timer) {\n\t\tif (bpf_timer_init(timer, &abs_timer, CLOCK_BOOTTIME) != 0)\n\t\t\terr |= 2048;\n\t\tbpf_timer_set_callback(timer, timer_cb3);\n\t\tbpf_timer_start(timer, bpf_ktime_get_boot_ns() + 1000,\n\t\t\t\tBPF_F_TIMER_ABS);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}