{
  "module_name": "cgrp_kfunc_success.c",
  "hash_id": "d6772f3b2fc342184538774a3f1d743f144462aaab295133dc798af7b72b538b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/cgrp_kfunc_success.c",
  "human_readable_source": "\n \n\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n\n#include \"cgrp_kfunc_common.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nint err, pid, invocations;\n\n \n\nstatic bool is_test_kfunc_task(void)\n{\n\tint cur_pid = bpf_get_current_pid_tgid() >> 32;\n\tbool same = pid == cur_pid;\n\n\tif (same)\n\t\t__sync_fetch_and_add(&invocations, 1);\n\n\treturn same;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\nint BPF_PROG(test_cgrp_acquire_release_argument, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *acquired;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tacquired = bpf_cgroup_acquire(cgrp);\n\tif (!acquired)\n\t\terr = 1;\n\telse\n\t\tbpf_cgroup_release(acquired);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\nint BPF_PROG(test_cgrp_acquire_leave_in_map, struct cgroup *cgrp, const char *path)\n{\n\tlong status;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tstatus = cgrps_kfunc_map_insert(cgrp);\n\tif (status)\n\t\terr = 1;\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\nint BPF_PROG(test_cgrp_xchg_release, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *kptr, *cg;\n\tstruct __cgrps_kfunc_map_value *v;\n\tlong status;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tstatus = cgrps_kfunc_map_insert(cgrp);\n\tif (status) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tv = cgrps_kfunc_map_value_lookup(cgrp);\n\tif (!v) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\tkptr = v->cgrp;\n\tif (!kptr) {\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\tcg = bpf_cgroup_ancestor(kptr, 1);\n\tif (cg)\t \n\t\tbpf_cgroup_release(cg);\n\n\tkptr = bpf_kptr_xchg(&v->cgrp, NULL);\n\tif (!kptr) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tbpf_cgroup_release(kptr);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\nint BPF_PROG(test_cgrp_get_release, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *kptr;\n\tstruct __cgrps_kfunc_map_value *v;\n\tlong status;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tstatus = cgrps_kfunc_map_insert(cgrp);\n\tif (status) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tv = cgrps_kfunc_map_value_lookup(cgrp);\n\tif (!v) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\tbpf_rcu_read_lock();\n\tkptr = v->cgrp;\n\tif (!kptr)\n\t\terr = 3;\n\tbpf_rcu_read_unlock();\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\nint BPF_PROG(test_cgrp_get_ancestors, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *self, *ancestor1, *invalid;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tself = bpf_cgroup_ancestor(cgrp, cgrp->level);\n\tif (!self) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tif (self->self.id != cgrp->self.id) {\n\t\tbpf_cgroup_release(self);\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\tbpf_cgroup_release(self);\n\n\tancestor1 = bpf_cgroup_ancestor(cgrp, cgrp->level - 1);\n\tif (!ancestor1) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\tbpf_cgroup_release(ancestor1);\n\n\tinvalid = bpf_cgroup_ancestor(cgrp, 10000);\n\tif (invalid) {\n\t\tbpf_cgroup_release(invalid);\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\tinvalid = bpf_cgroup_ancestor(cgrp, -1);\n\tif (invalid) {\n\t\tbpf_cgroup_release(invalid);\n\t\terr = 5;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\nint BPF_PROG(test_cgrp_from_id, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *parent, *res;\n\tu64 parent_cgid;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\t \n\tparent = bpf_cgroup_ancestor(cgrp, cgrp->level - 1);\n\tif (!parent) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tparent_cgid = parent->kn->id;\n\tbpf_cgroup_release(parent);\n\n\tres = bpf_cgroup_from_id(parent_cgid);\n\tif (!res) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\tbpf_cgroup_release(res);\n\n\tif (res != parent) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tres = bpf_cgroup_from_id((u64)-1);\n\tif (res) {\n\t\tbpf_cgroup_release(res);\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}