{
  "module_name": "netif_receive_skb.c",
  "hash_id": "55998128fa539d6f892538b4a84a8b09cc9ab0111823c9d254f6c5d80d8854c1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/netif_receive_skb.c",
  "human_readable_source": "\n \n\n#include \"btf_ptr.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\n#include <errno.h>\n\nlong ret = 0;\nint num_subtests = 0;\nint ran_subtests = 0;\nbool skip = false;\n\n#define STRSIZE\t\t\t2048\n#define EXPECTED_STRSIZE\t256\n\n#if defined(bpf_target_s390)\n \n#define BADPTR\t\t\t((void *)0xFFFFFFFFFFFFF000ULL)\n#else\n#define BADPTR\t\t\t0\n#endif\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(x)\t(sizeof(x) / sizeof((x)[0]))\n#endif\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, char[STRSIZE]);\n} strdata SEC(\".maps\");\n\nstatic int __strncmp(const void *m1, const void *m2, size_t len)\n{\n\tconst unsigned char *s1 = m1;\n\tconst unsigned char *s2 = m2;\n\tint i, delta = 0;\n\n\tfor (i = 0; i < len; i++) {\n\t\tdelta = s1[i] - s2[i];\n\t\tif (delta || s1[i] == 0 || s2[i] == 0)\n\t\t\tbreak;\n\t}\n\treturn delta;\n}\n\n#if __has_builtin(__builtin_btf_type_id)\n#define\tTEST_BTF(_str, _type, _flags, _expected, ...)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic const char _expectedval[EXPECTED_STRSIZE] =\t\\\n\t\t\t\t\t\t\t_expected;\t\\\n\t\t__u64 _hflags = _flags | BTF_F_COMPACT;\t\t\t\\\n\t\tstatic _type _ptrdata = __VA_ARGS__;\t\t\t\\\n\t\tstatic struct btf_ptr _ptr = { };\t\t\t\\\n\t\tint _cmp;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t++num_subtests;\t\t\t\t\t\t\\\n\t\tif (ret < 0)\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t++ran_subtests;\t\t\t\t\t\t\\\n\t\t_ptr.ptr = &_ptrdata;\t\t\t\t\t\\\n\t\t_ptr.type_id = bpf_core_type_id_kernel(_type);\t\t\\\n\t\tif (_ptr.type_id <= 0) {\t\t\t\t\\\n\t\t\tret = -EINVAL;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tret = bpf_snprintf_btf(_str, STRSIZE,\t\t\t\\\n\t\t\t\t       &_ptr, sizeof(_ptr), _hflags);\t\\\n\t\tif (ret)\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t_cmp = __strncmp(_str, _expectedval, EXPECTED_STRSIZE);\t\\\n\t\tif (_cmp != 0) {\t\t\t\t\t\\\n\t\t\tbpf_printk(\"(%d) got %s\", _cmp, _str);\t\t\\\n\t\t\tbpf_printk(\"(%d) expected %s\", _cmp,\t\t\\\n\t\t\t\t   _expectedval);\t\t\t\\\n\t\t\tret = -EBADMSG;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n#endif\n\n \n#define TEST_BTF_C(_str, _type, _flags, ...)\t\t\t\t\\\n\tTEST_BTF(_str, _type, _flags, \"(\" #_type \")\" #__VA_ARGS__,\t\\\n\t\t __VA_ARGS__)\n\n \nSEC(\"tp_btf/netif_receive_skb\")\nint BPF_PROG(trace_netif_receive_skb, struct sk_buff *skb)\n{\n\tstatic __u64 flags[] = { 0, BTF_F_COMPACT, BTF_F_ZERO, BTF_F_PTR_RAW,\n\t\t\t\t BTF_F_NONAME, BTF_F_COMPACT | BTF_F_ZERO |\n\t\t\t\t BTF_F_PTR_RAW | BTF_F_NONAME };\n\tstatic struct btf_ptr p = { };\n\t__u32 key = 0;\n\tint i, __ret;\n\tchar *str;\n\n#if __has_builtin(__builtin_btf_type_id)\n\tstr = bpf_map_lookup_elem(&strdata, &key);\n\tif (!str)\n\t\treturn 0;\n\n\t \n\tp.type_id = bpf_core_type_id_kernel(struct sk_buff);\n\tp.ptr = skb;\n\tfor (i = 0; i < ARRAY_SIZE(flags); i++) {\n\t\t++num_subtests;\n\t\tret = bpf_snprintf_btf(str, STRSIZE, &p, sizeof(p), 0);\n\t\tif (ret < 0)\n\t\t\tbpf_printk(\"returned %d when writing skb\", ret);\n\t\t++ran_subtests;\n\t}\n\n\t \n\tp.ptr = BADPTR;\n\t__ret = bpf_snprintf_btf(str, STRSIZE, &p, sizeof(p), 0);\n\tif (__ret >= 0) {\n\t\tbpf_printk(\"printing %llx should generate error, got (%d)\",\n\t\t\t   (unsigned long long)BADPTR, __ret);\n\t\tret = -ERANGE;\n\t}\n\n\t \n\n\t \n\tTEST_BTF_C(str, int, 0, 1234);\n\tTEST_BTF(str, int, BTF_F_NONAME, \"1234\", 1234);\n\t \n\tTEST_BTF(str, int, 0, \"(int)0\", 0);\n\tTEST_BTF(str, int, BTF_F_NONAME, \"0\", 0);\n\tTEST_BTF(str, int, BTF_F_ZERO, \"(int)0\", 0);\n\tTEST_BTF(str, int, BTF_F_NONAME | BTF_F_ZERO, \"0\", 0);\n\tTEST_BTF_C(str, int, 0, -4567);\n\tTEST_BTF(str, int, BTF_F_NONAME, \"-4567\", -4567);\n\n\t \n\tTEST_BTF_C(str, char, 0, 100);\n\tTEST_BTF(str, char, BTF_F_NONAME, \"100\", 100);\n\t \n\tTEST_BTF(str, char, 0, \"(char)0\", 0);\n\tTEST_BTF(str, char, BTF_F_NONAME, \"0\", 0);\n\tTEST_BTF(str, char, BTF_F_ZERO, \"(char)0\", 0);\n\tTEST_BTF(str, char, BTF_F_NONAME | BTF_F_ZERO, \"0\", 0);\n\n\t \n\tTEST_BTF_C(str, uint64_t, 0, 100);\n\tTEST_BTF(str, u64, BTF_F_NONAME, \"1\", 1);\n\t \n\tTEST_BTF(str, u64, 0, \"(u64)0\", 0);\n\tTEST_BTF(str, u64, BTF_F_NONAME, \"0\", 0);\n\tTEST_BTF(str, u64, BTF_F_ZERO, \"(u64)0\", 0);\n\tTEST_BTF(str, u64, BTF_F_NONAME|BTF_F_ZERO, \"0\", 0);\n\n\t \n\tTEST_BTF_C(str, atomic_t, 0, {.counter = (int)1,});\n\tTEST_BTF(str, atomic_t, BTF_F_NONAME, \"{1,}\", {.counter = 1,});\n\t \n\tTEST_BTF(str, atomic_t, 0, \"(atomic_t){}\", {.counter = 0,});\n\tTEST_BTF(str, atomic_t, BTF_F_NONAME, \"{}\", {.counter = 0,});\n\tTEST_BTF(str, atomic_t, BTF_F_ZERO, \"(atomic_t){.counter = (int)0,}\",\n\t\t {.counter = 0,});\n\tTEST_BTF(str, atomic_t, BTF_F_NONAME|BTF_F_ZERO,\n\t\t \"{0,}\", {.counter = 0,});\n\n\t \n\tTEST_BTF_C(str, enum bpf_cmd, 0, BPF_MAP_CREATE);\n\tTEST_BTF(str, enum bpf_cmd, 0, \"(enum bpf_cmd)BPF_MAP_CREATE\", 0);\n\tTEST_BTF(str, enum bpf_cmd, BTF_F_NONAME, \"BPF_MAP_CREATE\",\n\t\t BPF_MAP_CREATE);\n\tTEST_BTF(str, enum bpf_cmd, BTF_F_NONAME|BTF_F_ZERO,\n\t\t \"BPF_MAP_CREATE\", 0);\n\n\tTEST_BTF(str, enum bpf_cmd, BTF_F_ZERO, \"(enum bpf_cmd)BPF_MAP_CREATE\",\n\t\t BPF_MAP_CREATE);\n\tTEST_BTF(str, enum bpf_cmd, BTF_F_NONAME|BTF_F_ZERO,\n\t\t \"BPF_MAP_CREATE\", BPF_MAP_CREATE);\n\tTEST_BTF_C(str, enum bpf_cmd, 0, 2000);\n\tTEST_BTF(str, enum bpf_cmd, BTF_F_NONAME, \"2000\", 2000);\n\n\t \n\tTEST_BTF_C(str, struct btf_enum, 0,\n\t\t   {.name_off = (__u32)3,.val = (__s32)-1,});\n\tTEST_BTF(str, struct btf_enum, BTF_F_NONAME, \"{3,-1,}\",\n\t\t { .name_off = 3, .val = -1,});\n\tTEST_BTF(str, struct btf_enum, BTF_F_NONAME, \"{-1,}\",\n\t\t { .name_off = 0, .val = -1,});\n\tTEST_BTF(str, struct btf_enum, BTF_F_NONAME|BTF_F_ZERO, \"{0,-1,}\",\n\t\t { .name_off = 0, .val = -1,});\n\t \n\tTEST_BTF(str, struct btf_enum, 0, \"(struct btf_enum){}\",\n\t\t { .name_off = 0, .val = 0,});\n\tTEST_BTF(str, struct btf_enum, BTF_F_NONAME, \"{}\",\n\t\t { .name_off = 0, .val = 0,});\n\tTEST_BTF(str, struct btf_enum, BTF_F_ZERO,\n\t\t \"(struct btf_enum){.name_off = (__u32)0,.val = (__s32)0,}\",\n\t\t { .name_off = 0, .val = 0,});\n\n\t \n\tTEST_BTF(str, struct list_head, BTF_F_PTR_RAW,\n\t\t \"(struct list_head){.next = (struct list_head *)0x0000000000000001,}\",\n\t\t { .next = (struct list_head *)1 });\n\t \n\tTEST_BTF(str, struct list_head, BTF_F_PTR_RAW,\n\t\t \"(struct list_head){}\",\n\t\t { .next = (struct list_head *)0 });\n\n\t \n\tTEST_BTF(str, struct bpf_prog_info, 0,\n\t\t \"(struct bpf_prog_info){.name = (char[])['f','o','o',],}\",\n\t\t { .name = \"foo\",});\n\tTEST_BTF(str, struct bpf_prog_info, BTF_F_NONAME,\n\t\t \"{['f','o','o',],}\",\n\t\t {.name = \"foo\",});\n\t \n\tTEST_BTF(str, struct bpf_prog_info, 0,\n\t\t \"(struct bpf_prog_info){}\",\n\t\t {.name = {'\\0', 'f', 'o', 'o'}});\n\t \n\tTEST_BTF(str, struct bpf_prog_info, 0,\n\t\t \"(struct bpf_prog_info){.name = (char[])[1,2,3,],}\",\n\t\t { .name = {1, 2, 3, 0}});\n\n\t \n\tTEST_BTF(str, struct __sk_buff, 0,\n\t\t \"(struct __sk_buff){.cb = (__u32[])[1,2,3,4,5,],}\",\n\t\t { .cb = {1, 2, 3, 4, 5,},});\n\tTEST_BTF(str, struct __sk_buff, BTF_F_NONAME,\n\t\t \"{[1,2,3,4,5,],}\",\n\t\t { .cb = { 1, 2, 3, 4, 5},});\n\t \n\tTEST_BTF(str, struct __sk_buff, 0,\n\t\t \"(struct __sk_buff){.cb = (__u32[])[1,],}\",\n\t\t { .cb = { 0, 0, 1, 0, 0},});\n\n\t \n\tTEST_BTF_C(str, struct bpf_insn, 0,\n\t\t   {.code = (__u8)1,.dst_reg = (__u8)0x2,.src_reg = (__u8)0x3,.off = (__s16)4,.imm = (__s32)5,});\n\tTEST_BTF(str, struct bpf_insn, BTF_F_NONAME, \"{1,0x2,0x3,4,5,}\",\n\t\t {.code = 1, .dst_reg = 0x2, .src_reg = 0x3, .off = 4,\n\t\t  .imm = 5,});\n#else\n\tskip = true;\n#endif\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}