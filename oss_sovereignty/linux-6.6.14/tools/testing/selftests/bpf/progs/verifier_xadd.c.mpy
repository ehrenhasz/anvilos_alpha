{
  "module_name": "verifier_xadd.c",
  "hash_id": "d4d0c8bca91546ce592f9c4c380540e7d590df3a90b1f61ed479bfe442846b75",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_xadd.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, long long);\n} map_hash_8b SEC(\".maps\");\n\nSEC(\"tc\")\n__description(\"xadd/w check unaligned stack\")\n__failure __msg(\"misaligned stack access off\")\n__naked void xadd_w_check_unaligned_stack(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\tlock *(u32 *)(r10 - 7) += w0;\t\t\t\\\n\tr0 = *(u64*)(r10 - 8);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"xadd/w check unaligned map\")\n__failure __msg(\"misaligned value access off\")\n__naked void xadd_w_check_unaligned_map(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr1 = 1;\t\t\t\t\t\t\\\n\tlock *(u32 *)(r0 + 3) += w1;\t\t\t\\\n\tr0 = *(u32*)(r0 + 3);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"xdp\")\n__description(\"xadd/w check unaligned pkt\")\n__failure __msg(\"BPF_ATOMIC stores into R2 pkt is not allowed\")\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void xadd_w_check_unaligned_pkt(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[xdp_md_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[xdp_md_data_end]);\t\t\\\n\tr1 = r2;\t\t\t\t\t\\\n\tr1 += 8;\t\t\t\t\t\\\n\tif r1 < r3 goto l0_%=;\t\t\t\t\\\n\tr0 = 99;\t\t\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr0 = 1;\t\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u32*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u32*)(r2 + 3) = r1;\t\t\t\t\\\n\tlock *(u32 *)(r2 + 1) += w0;\t\t\t\\\n\tlock *(u32 *)(r2 + 2) += w0;\t\t\t\\\n\tr0 = *(u32*)(r2 + 1);\t\t\t\t\\\nl1_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(xdp_md_data, offsetof(struct xdp_md, data)),\n\t  __imm_const(xdp_md_data_end, offsetof(struct xdp_md, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"xadd/w check whether src/dst got mangled, 1\")\n__success __retval(3)\n__naked void src_dst_got_mangled_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\tr6 = r0;\t\t\t\t\t\\\n\tr7 = r10;\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\tlock *(u64 *)(r10 - 8) += r0;\t\t\t\\\n\tlock *(u64 *)(r10 - 8) += r0;\t\t\t\\\n\tif r6 != r0 goto l0_%=;\t\t\t\t\\\n\tif r7 != r10 goto l0_%=;\t\t\t\\\n\tr0 = *(u64*)(r10 - 8);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr0 = 42;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"xadd/w check whether src/dst got mangled, 2\")\n__success __retval(3)\n__naked void src_dst_got_mangled_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\tr6 = r0;\t\t\t\t\t\\\n\tr7 = r10;\t\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r0;\t\t\t\t\\\n\tlock *(u32 *)(r10 - 8) += w0;\t\t\t\\\n\tlock *(u32 *)(r10 - 8) += w0;\t\t\t\\\n\tif r6 != r0 goto l0_%=;\t\t\t\t\\\n\tif r7 != r10 goto l0_%=;\t\t\t\\\n\tr0 = *(u32*)(r10 - 8);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\tr0 = 42;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}