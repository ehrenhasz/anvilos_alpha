{
  "module_name": "test_xdp_vlan.c",
  "hash_id": "9dce46c4d5cedd0a36c361eea211c7d140a0c0f6736ad0499f33c7d653fb4dee",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_xdp_vlan.c",
  "human_readable_source": " \n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/in.h>\n#include <linux/pkt_cls.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n \nstruct _vlan_hdr {\n\t__be16 h_vlan_TCI;\n\t__be16 h_vlan_encapsulated_proto;\n};\n#define VLAN_PRIO_MASK\t\t0xe000  \n#define VLAN_PRIO_SHIFT\t\t13\n#define VLAN_CFI_MASK\t\t0x1000  \n#define VLAN_TAG_PRESENT\tVLAN_CFI_MASK\n#define VLAN_VID_MASK\t\t0x0fff  \n#define VLAN_N_VID\t\t4096\n\nstruct parse_pkt {\n\t__u16 l3_proto;\n\t__u16 l3_offset;\n\t__u16 vlan_outer;\n\t__u16 vlan_inner;\n\t__u8  vlan_outer_offset;\n\t__u8  vlan_inner_offset;\n};\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstatic __always_inline\nbool parse_eth_frame(struct ethhdr *eth, void *data_end, struct parse_pkt *pkt)\n{\n\t__u16 eth_type;\n\t__u8 offset;\n\n\toffset = sizeof(*eth);\n\t \n\tif ((void *)eth + offset + (2*sizeof(struct _vlan_hdr)) > data_end)\n\t\treturn false;\n\n\teth_type = eth->h_proto;\n\n\t \n\tif (eth_type == bpf_htons(ETH_P_8021Q)\n\t    || eth_type == bpf_htons(ETH_P_8021AD)) {\n\t\tstruct _vlan_hdr *vlan_hdr;\n\n\t\tvlan_hdr = (void *)eth + offset;\n\t\tpkt->vlan_outer_offset = offset;\n\t\tpkt->vlan_outer = bpf_ntohs(vlan_hdr->h_vlan_TCI)\n\t\t\t\t& VLAN_VID_MASK;\n\t\teth_type        = vlan_hdr->h_vlan_encapsulated_proto;\n\t\toffset += sizeof(*vlan_hdr);\n\t}\n\n\t \n\tif (eth_type == bpf_htons(ETH_P_8021Q)\n\t    || eth_type == bpf_htons(ETH_P_8021AD)) {\n\t\tstruct _vlan_hdr *vlan_hdr;\n\n\t\tvlan_hdr = (void *)eth + offset;\n\t\tpkt->vlan_inner_offset = offset;\n\t\tpkt->vlan_inner = bpf_ntohs(vlan_hdr->h_vlan_TCI)\n\t\t\t\t& VLAN_VID_MASK;\n\t\teth_type        = vlan_hdr->h_vlan_encapsulated_proto;\n\t\toffset += sizeof(*vlan_hdr);\n\t}\n\n\tpkt->l3_proto = bpf_ntohs(eth_type);  \n\tpkt->l3_offset = offset;\n\n\treturn true;\n}\n\n \n#define TESTVLAN 4011  \n\n\nSEC(\"xdp_drop_vlan_4011\")\nint  xdp_prognum0(struct xdp_md *ctx)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data     = (void *)(long)ctx->data;\n\tstruct parse_pkt pkt = { 0 };\n\n\tif (!parse_eth_frame(data, data_end, &pkt))\n\t\treturn XDP_ABORTED;\n\n\t \n\tif (pkt.vlan_outer == TESTVLAN)\n\t\treturn XDP_ABORTED;\n\t \n\treturn XDP_PASS;\n}\n \n\n \n#define TO_VLAN\t0\n\nSEC(\"xdp_vlan_change\")\nint  xdp_prognum1(struct xdp_md *ctx)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data     = (void *)(long)ctx->data;\n\tstruct parse_pkt pkt = { 0 };\n\n\tif (!parse_eth_frame(data, data_end, &pkt))\n\t\treturn XDP_ABORTED;\n\n\t \n\tif (pkt.vlan_outer == TESTVLAN) {\n\t\tstruct _vlan_hdr *vlan_hdr = data + pkt.vlan_outer_offset;\n\n\t\t \n\t\tvlan_hdr->h_vlan_TCI =\n\t\t\tbpf_htons((bpf_ntohs(vlan_hdr->h_vlan_TCI) & 0xf000)\n\t\t\t\t  | TO_VLAN);\n\t}\n\n\treturn XDP_PASS;\n}\n\n \n\n#ifndef ETH_ALEN  \n#define ETH_ALEN\t6\t \n#endif\n#define VLAN_HDR_SZ\t4\t \n\nSEC(\"xdp_vlan_remove_outer\")\nint  xdp_prognum2(struct xdp_md *ctx)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data     = (void *)(long)ctx->data;\n\tstruct parse_pkt pkt = { 0 };\n\tchar *dest;\n\n\tif (!parse_eth_frame(data, data_end, &pkt))\n\t\treturn XDP_ABORTED;\n\n\t \n\tif (pkt.vlan_outer_offset == 0)\n\t\treturn XDP_PASS;\n\n\t \n\tdest = data;\n\tdest += VLAN_HDR_SZ;\n\t \n\t__builtin_memmove(dest, data, ETH_ALEN * 2);\n\t \n\n\t \n\tbpf_xdp_adjust_head(ctx, VLAN_HDR_SZ);\n\n\treturn XDP_PASS;\n}\n\nstatic __always_inline\nvoid shift_mac_4bytes_32bit(void *data)\n{\n\t__u32 *p = data;\n\n\t \n\tp[3] = p[2];\n\tp[2] = p[1];\n\tp[1] = p[0];\n}\n\nSEC(\"xdp_vlan_remove_outer2\")\nint  xdp_prognum3(struct xdp_md *ctx)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data     = (void *)(long)ctx->data;\n\tstruct ethhdr *orig_eth = data;\n\tstruct parse_pkt pkt = { 0 };\n\n\tif (!parse_eth_frame(orig_eth, data_end, &pkt))\n\t\treturn XDP_ABORTED;\n\n\t \n\tif (pkt.vlan_outer_offset == 0)\n\t\treturn XDP_PASS;\n\n\t \n\tshift_mac_4bytes_32bit(data);\n\n\t \n\tbpf_xdp_adjust_head(ctx, VLAN_HDR_SZ);\n\n\treturn XDP_PASS;\n}\n\n \n\nSEC(\"tc_vlan_push\")\nint _tc_progA(struct __sk_buff *ctx)\n{\n\tbpf_skb_vlan_push(ctx, bpf_htons(ETH_P_8021Q), TESTVLAN);\n\n\treturn TC_ACT_OK;\n}\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}