{
  "module_name": "linked_list_fail.c",
  "hash_id": "2fc146881f0b0922a8bafbd71ddf66a8d021d68feb74650b2d8a50030da66b00",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/linked_list_fail.c",
  "human_readable_source": "\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_experimental.h\"\n\n#include \"linked_list.h\"\n\n#define INIT                                                  \\\n\tstruct map_value *v, *v2, *iv, *iv2;                  \\\n\tstruct foo *f, *f1, *f2;                              \\\n\tstruct bar *b;                                        \\\n\tvoid *map;                                            \\\n                                                              \\\n\tmap = bpf_map_lookup_elem(&map_of_maps, &(int){ 0 }); \\\n\tif (!map)                                             \\\n\t\treturn 0;                                     \\\n\tv = bpf_map_lookup_elem(&array_map, &(int){ 0 });     \\\n\tif (!v)                                               \\\n\t\treturn 0;                                     \\\n\tv2 = bpf_map_lookup_elem(&array_map, &(int){ 0 });    \\\n\tif (!v2)                                              \\\n\t\treturn 0;                                     \\\n\tiv = bpf_map_lookup_elem(map, &(int){ 0 });           \\\n\tif (!iv)                                              \\\n\t\treturn 0;                                     \\\n\tiv2 = bpf_map_lookup_elem(map, &(int){ 0 });          \\\n\tif (!iv2)                                             \\\n\t\treturn 0;                                     \\\n\tf = bpf_obj_new(typeof(*f));                          \\\n\tif (!f)                                               \\\n\t\treturn 0;                                     \\\n\tf1 = f;                                               \\\n\tf2 = bpf_obj_new(typeof(*f2));                        \\\n\tif (!f2) {                                            \\\n\t\tbpf_obj_drop(f1);                             \\\n\t\treturn 0;                                     \\\n\t}                                                     \\\n\tb = bpf_obj_new(typeof(*b));                          \\\n\tif (!b) {                                             \\\n\t\tbpf_obj_drop(f2);                             \\\n\t\tbpf_obj_drop(f1);                             \\\n\t\treturn 0;                                     \\\n\t}\n\n#define CHECK(test, op, hexpr)                              \\\n\tSEC(\"?tc\")                                          \\\n\tint test##_missing_lock_##op(void *ctx)             \\\n\t{                                                   \\\n\t\tINIT;                                       \\\n\t\tvoid (*p)(void *) = (void *)&bpf_list_##op; \\\n\t\tp(hexpr);                                   \\\n\t\treturn 0;                                   \\\n\t}\n\nCHECK(kptr, pop_front, &f->head);\nCHECK(kptr, pop_back, &f->head);\n\nCHECK(global, pop_front, &ghead);\nCHECK(global, pop_back, &ghead);\n\nCHECK(map, pop_front, &v->head);\nCHECK(map, pop_back, &v->head);\n\nCHECK(inner_map, pop_front, &iv->head);\nCHECK(inner_map, pop_back, &iv->head);\n\n#undef CHECK\n\n#define CHECK(test, op, hexpr, nexpr)\t\t\t\t\t\\\n\tSEC(\"?tc\")\t\t\t\t\t\t\t\\\n\tint test##_missing_lock_##op(void *ctx)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tINIT;\t\t\t\t\t\t\t\\\n\t\tbpf_list_##op(hexpr, nexpr);\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t}\n\nCHECK(kptr, push_front, &f->head, &b->node);\nCHECK(kptr, push_back, &f->head, &b->node);\n\nCHECK(global, push_front, &ghead, &f->node2);\nCHECK(global, push_back, &ghead, &f->node2);\n\nCHECK(map, push_front, &v->head, &f->node2);\nCHECK(map, push_back, &v->head, &f->node2);\n\nCHECK(inner_map, push_front, &iv->head, &f->node2);\nCHECK(inner_map, push_back, &iv->head, &f->node2);\n\n#undef CHECK\n\n#define CHECK(test, op, lexpr, hexpr)                       \\\n\tSEC(\"?tc\")                                          \\\n\tint test##_incorrect_lock_##op(void *ctx)           \\\n\t{                                                   \\\n\t\tINIT;                                       \\\n\t\tvoid (*p)(void *) = (void *)&bpf_list_##op; \\\n\t\tbpf_spin_lock(lexpr);                       \\\n\t\tp(hexpr);                                   \\\n\t\treturn 0;                                   \\\n\t}\n\n#define CHECK_OP(op)                                           \\\n\tCHECK(kptr_kptr, op, &f1->lock, &f2->head);            \\\n\tCHECK(kptr_global, op, &f1->lock, &ghead);             \\\n\tCHECK(kptr_map, op, &f1->lock, &v->head);              \\\n\tCHECK(kptr_inner_map, op, &f1->lock, &iv->head);       \\\n                                                               \\\n\tCHECK(global_global, op, &glock2, &ghead);             \\\n\tCHECK(global_kptr, op, &glock, &f1->head);             \\\n\tCHECK(global_map, op, &glock, &v->head);               \\\n\tCHECK(global_inner_map, op, &glock, &iv->head);        \\\n                                                               \\\n\tCHECK(map_map, op, &v->lock, &v2->head);               \\\n\tCHECK(map_kptr, op, &v->lock, &f2->head);              \\\n\tCHECK(map_global, op, &v->lock, &ghead);               \\\n\tCHECK(map_inner_map, op, &v->lock, &iv->head);         \\\n                                                               \\\n\tCHECK(inner_map_inner_map, op, &iv->lock, &iv2->head); \\\n\tCHECK(inner_map_kptr, op, &iv->lock, &f2->head);       \\\n\tCHECK(inner_map_global, op, &iv->lock, &ghead);        \\\n\tCHECK(inner_map_map, op, &iv->lock, &v->head);\n\nCHECK_OP(pop_front);\nCHECK_OP(pop_back);\n\n#undef CHECK\n#undef CHECK_OP\n\n#define CHECK(test, op, lexpr, hexpr, nexpr)\t\t\t\t\\\n\tSEC(\"?tc\")\t\t\t\t\t\t\t\\\n\tint test##_incorrect_lock_##op(void *ctx)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tINIT;\t\t\t\t\t\t\t\\\n\t\tbpf_spin_lock(lexpr);\t\t\t\t\t\\\n\t\tbpf_list_##op(hexpr, nexpr);\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t}\n\n#define CHECK_OP(op)\t\t\t\t\t\t\t\\\n\tCHECK(kptr_kptr, op, &f1->lock, &f2->head, &b->node);\t\t\\\n\tCHECK(kptr_global, op, &f1->lock, &ghead, &f->node2);\t\t\\\n\tCHECK(kptr_map, op, &f1->lock, &v->head, &f->node2);\t\t\\\n\tCHECK(kptr_inner_map, op, &f1->lock, &iv->head, &f->node2);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tCHECK(global_global, op, &glock2, &ghead, &f->node2);\t\t\\\n\tCHECK(global_kptr, op, &glock, &f1->head, &b->node);\t\t\\\n\tCHECK(global_map, op, &glock, &v->head, &f->node2);\t\t\\\n\tCHECK(global_inner_map, op, &glock, &iv->head, &f->node2);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tCHECK(map_map, op, &v->lock, &v2->head, &f->node2);\t\t\\\n\tCHECK(map_kptr, op, &v->lock, &f2->head, &b->node);\t\t\\\n\tCHECK(map_global, op, &v->lock, &ghead, &f->node2);\t\t\\\n\tCHECK(map_inner_map, op, &v->lock, &iv->head, &f->node2);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tCHECK(inner_map_inner_map, op, &iv->lock, &iv2->head, &f->node2);\\\n\tCHECK(inner_map_kptr, op, &iv->lock, &f2->head, &b->node);\t\\\n\tCHECK(inner_map_global, op, &iv->lock, &ghead, &f->node2);\t\\\n\tCHECK(inner_map_map, op, &iv->lock, &v->head, &f->node2);\n\nCHECK_OP(push_front);\nCHECK_OP(push_back);\n\n#undef CHECK\n#undef CHECK_OP\n#undef INIT\n\nSEC(\"?kprobe/xyz\")\nint map_compat_kprobe(void *ctx)\n{\n\tbpf_list_push_front(&ghead, NULL);\n\treturn 0;\n}\n\nSEC(\"?kretprobe/xyz\")\nint map_compat_kretprobe(void *ctx)\n{\n\tbpf_list_push_front(&ghead, NULL);\n\treturn 0;\n}\n\nSEC(\"?tracepoint/xyz\")\nint map_compat_tp(void *ctx)\n{\n\tbpf_list_push_front(&ghead, NULL);\n\treturn 0;\n}\n\nSEC(\"?perf_event\")\nint map_compat_perf(void *ctx)\n{\n\tbpf_list_push_front(&ghead, NULL);\n\treturn 0;\n}\n\nSEC(\"?raw_tp/xyz\")\nint map_compat_raw_tp(void *ctx)\n{\n\tbpf_list_push_front(&ghead, NULL);\n\treturn 0;\n}\n\nSEC(\"?raw_tp.w/xyz\")\nint map_compat_raw_tp_w(void *ctx)\n{\n\tbpf_list_push_front(&ghead, NULL);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint obj_type_id_oor(void *ctx)\n{\n\tbpf_obj_new_impl(~0UL, NULL);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint obj_new_no_composite(void *ctx)\n{\n\tbpf_obj_new_impl(bpf_core_type_id_local(int), (void *)42);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint obj_new_no_struct(void *ctx)\n{\n\n\tbpf_obj_new(union { int data; unsigned udata; });\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint obj_drop_non_zero_off(void *ctx)\n{\n\tvoid *f;\n\n\tf = bpf_obj_new(struct foo);\n\tif (!f)\n\t\treturn 0;\n\tbpf_obj_drop(f+1);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint new_null_ret(void *ctx)\n{\n\treturn bpf_obj_new(struct foo)->data;\n}\n\nSEC(\"?tc\")\nint obj_new_acq(void *ctx)\n{\n\tbpf_obj_new(struct foo);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint use_after_drop(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tbpf_obj_drop(f);\n\treturn f->data;\n}\n\nSEC(\"?tc\")\nint ptr_walk_scalar(void *ctx)\n{\n\tstruct test1 {\n\t\tstruct test2 {\n\t\t\tstruct test2 *next;\n\t\t} *ptr;\n\t} *p;\n\n\tp = bpf_obj_new(typeof(*p));\n\tif (!p)\n\t\treturn 0;\n\tbpf_this_cpu_ptr(p->ptr);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint direct_read_lock(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\treturn *(int *)&f->lock;\n}\n\nSEC(\"?tc\")\nint direct_write_lock(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\t*(int *)&f->lock = 0;\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint direct_read_head(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\treturn *(int *)&f->head;\n}\n\nSEC(\"?tc\")\nint direct_write_head(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\t*(int *)&f->head = 0;\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint direct_read_node(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\treturn *(int *)&f->node2;\n}\n\nSEC(\"?tc\")\nint direct_write_node(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\t*(int *)&f->node2 = 0;\n\treturn 0;\n}\n\nstatic __always_inline\nint use_after_unlock(bool push_front)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tf->data = 42;\n\tif (push_front)\n\t\tbpf_list_push_front(&ghead, &f->node2);\n\telse\n\t\tbpf_list_push_back(&ghead, &f->node2);\n\tbpf_spin_unlock(&glock);\n\n\treturn f->data;\n}\n\nSEC(\"?tc\")\nint use_after_unlock_push_front(void *ctx)\n{\n\treturn use_after_unlock(true);\n}\n\nSEC(\"?tc\")\nint use_after_unlock_push_back(void *ctx)\n{\n\treturn use_after_unlock(false);\n}\n\nstatic __always_inline\nint list_double_add(bool push_front)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tif (push_front) {\n\t\tbpf_list_push_front(&ghead, &f->node2);\n\t\tbpf_list_push_front(&ghead, &f->node2);\n\t} else {\n\t\tbpf_list_push_back(&ghead, &f->node2);\n\t\tbpf_list_push_back(&ghead, &f->node2);\n\t}\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint double_push_front(void *ctx)\n{\n\treturn list_double_add(true);\n}\n\nSEC(\"?tc\")\nint double_push_back(void *ctx)\n{\n\treturn list_double_add(false);\n}\n\nSEC(\"?tc\")\nint no_node_value_type(void *ctx)\n{\n\tvoid *p;\n\n\tp = bpf_obj_new(struct { int data; });\n\tif (!p)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tbpf_list_push_front(&ghead, p);\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint incorrect_value_type(void *ctx)\n{\n\tstruct bar *b;\n\n\tb = bpf_obj_new(typeof(*b));\n\tif (!b)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tbpf_list_push_front(&ghead, &b->node);\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint incorrect_node_var_off(struct __sk_buff *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tbpf_list_push_front(&ghead, (void *)&f->node2 + ctx->protocol);\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint incorrect_node_off1(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tbpf_list_push_front(&ghead, (void *)&f->node2 + 1);\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint incorrect_node_off2(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tbpf_list_push_front(&ghead, &f->node);\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint no_head_type(void *ctx)\n{\n\tvoid *p;\n\n\tp = bpf_obj_new(typeof(struct { int data; }));\n\tif (!p)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tbpf_list_push_front(p, NULL);\n\tbpf_spin_lock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint incorrect_head_var_off1(struct __sk_buff *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tbpf_list_push_front((void *)&ghead + ctx->protocol, &f->node2);\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint incorrect_head_var_off2(struct __sk_buff *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tbpf_spin_lock(&glock);\n\tbpf_list_push_front((void *)&f->head + ctx->protocol, &f->node2);\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint incorrect_head_off1(void *ctx)\n{\n\tstruct foo *f;\n\tstruct bar *b;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\tb = bpf_obj_new(typeof(*b));\n\tif (!b) {\n\t\tbpf_obj_drop(f);\n\t\treturn 0;\n\t}\n\n\tbpf_spin_lock(&f->lock);\n\tbpf_list_push_front((void *)&f->head + 1, &b->node);\n\tbpf_spin_unlock(&f->lock);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint incorrect_head_off2(void *ctx)\n{\n\tstruct foo *f;\n\n\tf = bpf_obj_new(typeof(*f));\n\tif (!f)\n\t\treturn 0;\n\n\tbpf_spin_lock(&glock);\n\tbpf_list_push_front((void *)&ghead + 1, &f->node2);\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nstatic __always_inline\nint pop_ptr_off(void *(*op)(void *head))\n{\n\tstruct {\n\t\tstruct bpf_list_head head __contains(foo, node2);\n\t\tstruct bpf_spin_lock lock;\n\t} *p;\n\tstruct bpf_list_node *n;\n\n\tp = bpf_obj_new(typeof(*p));\n\tif (!p)\n\t\treturn 0;\n\tbpf_spin_lock(&p->lock);\n\tn = op(&p->head);\n\tbpf_spin_unlock(&p->lock);\n\n\tif (!n)\n\t\treturn 0;\n\tbpf_spin_lock((void *)n);\n\treturn 0;\n}\n\nSEC(\"?tc\")\nint pop_front_off(void *ctx)\n{\n\treturn pop_ptr_off((void *)bpf_list_pop_front);\n}\n\nSEC(\"?tc\")\nint pop_back_off(void *ctx)\n{\n\treturn pop_ptr_off((void *)bpf_list_pop_back);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}