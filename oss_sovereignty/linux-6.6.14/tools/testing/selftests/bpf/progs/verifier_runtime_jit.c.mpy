{
  "module_name": "verifier_runtime_jit.c",
  "hash_id": "c5f36f431a5d694426f47d6f703cfa76a63fc09acb51c8b3309dcd191d1b8ed4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_runtime_jit.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nvoid dummy_prog_42_socket(void);\nvoid dummy_prog_24_socket(void);\nvoid dummy_prog_loop1_socket(void);\nvoid dummy_prog_loop2_socket(void);\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__uint(max_entries, 4);\n\t__uint(key_size, sizeof(int));\n\t__array(values, void (void));\n} map_prog1_socket SEC(\".maps\") = {\n\t.values = {\n\t\t[0] = (void *)&dummy_prog_42_socket,\n\t\t[1] = (void *)&dummy_prog_loop1_socket,\n\t\t[2] = (void *)&dummy_prog_24_socket,\n\t},\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__uint(max_entries, 8);\n\t__uint(key_size, sizeof(int));\n\t__array(values, void (void));\n} map_prog2_socket SEC(\".maps\") = {\n\t.values = {\n\t\t[1] = (void *)&dummy_prog_loop2_socket,\n\t\t[2] = (void *)&dummy_prog_24_socket,\n\t\t[7] = (void *)&dummy_prog_42_socket,\n\t},\n};\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_42_socket(void)\n{\n\tasm volatile (\"r0 = 42; exit;\");\n}\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_24_socket(void)\n{\n\tasm volatile (\"r0 = 24; exit;\");\n}\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_loop1_socket(void)\n{\n\tasm volatile (\"\t\t\t\\\n\tr3 = 1;\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\\\n\tcall %[bpf_tail_call];\t\t\\\n\tr0 = 41;\t\t\t\\\n\texit;\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_loop2_socket(void)\n{\n\tasm volatile (\"\t\t\t\\\n\tr3 = 1;\t\t\t\t\\\n\tr2 = %[map_prog2_socket] ll;\t\\\n\tcall %[bpf_tail_call];\t\t\\\n\tr0 = 41;\t\t\t\\\n\texit;\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog2_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, prog once\")\n__success __success_unpriv __retval(42)\n__naked void call_within_bounds_prog_once(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, prog loop\")\n__success __success_unpriv __retval(41)\n__naked void call_within_bounds_prog_loop(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr3 = 1;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, no prog\")\n__success __success_unpriv __retval(1)\n__naked void call_within_bounds_no_prog(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr3 = 3;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, key 2\")\n__success __success_unpriv __retval(24)\n__naked void call_within_bounds_key_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr3 = 2;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, key 2 / key 2, first branch\")\n__success __success_unpriv __retval(24)\n__naked void _2_key_2_first_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 13;\t\t\t\t\t\\\n\t*(u8*)(r1 + %[__sk_buff_cb_0]) = r0;\t\t\\\n\tr0 = *(u8*)(r1 + %[__sk_buff_cb_0]);\t\t\\\n\tif r0 == 13 goto l0_%=;\t\t\t\t\\\n\tr3 = 2;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr3 = 2;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\nl1_%=:\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket),\n\t  __imm_const(__sk_buff_cb_0, offsetof(struct __sk_buff, cb[0]))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, key 2 / key 2, second branch\")\n__success __success_unpriv __retval(24)\n__naked void _2_key_2_second_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 14;\t\t\t\t\t\\\n\t*(u8*)(r1 + %[__sk_buff_cb_0]) = r0;\t\t\\\n\tr0 = *(u8*)(r1 + %[__sk_buff_cb_0]);\t\t\\\n\tif r0 == 13 goto l0_%=;\t\t\t\t\\\n\tr3 = 2;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr3 = 2;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\nl1_%=:\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket),\n\t  __imm_const(__sk_buff_cb_0, offsetof(struct __sk_buff, cb[0]))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, key 0 / key 2, first branch\")\n__success __success_unpriv __retval(24)\n__naked void _0_key_2_first_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 13;\t\t\t\t\t\\\n\t*(u8*)(r1 + %[__sk_buff_cb_0]) = r0;\t\t\\\n\tr0 = *(u8*)(r1 + %[__sk_buff_cb_0]);\t\t\\\n\tif r0 == 13 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr3 = 2;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\nl1_%=:\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket),\n\t  __imm_const(__sk_buff_cb_0, offsetof(struct __sk_buff, cb[0]))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, key 0 / key 2, second branch\")\n__success __success_unpriv __retval(42)\n__naked void _0_key_2_second_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 14;\t\t\t\t\t\\\n\t*(u8*)(r1 + %[__sk_buff_cb_0]) = r0;\t\t\\\n\tr0 = *(u8*)(r1 + %[__sk_buff_cb_0]);\t\t\\\n\tif r0 == 13 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr3 = 2;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\nl1_%=:\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket),\n\t  __imm_const(__sk_buff_cb_0, offsetof(struct __sk_buff, cb[0]))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, different maps, first branch\")\n__success __failure_unpriv __msg_unpriv(\"tail_call abusing map_ptr\")\n__retval(1)\n__naked void bounds_different_maps_first_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 13;\t\t\t\t\t\\\n\t*(u8*)(r1 + %[__sk_buff_cb_0]) = r0;\t\t\\\n\tr0 = *(u8*)(r1 + %[__sk_buff_cb_0]);\t\t\\\n\tif r0 == 13 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr3 = 0;\t\t\t\t\t\t\\\n\tr2 = %[map_prog2_socket] ll;\t\t\t\\\nl1_%=:\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket),\n\t  __imm_addr(map_prog2_socket),\n\t  __imm_const(__sk_buff_cb_0, offsetof(struct __sk_buff, cb[0]))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call within bounds, different maps, second branch\")\n__success __failure_unpriv __msg_unpriv(\"tail_call abusing map_ptr\")\n__retval(42)\n__naked void bounds_different_maps_second_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 14;\t\t\t\t\t\\\n\t*(u8*)(r1 + %[__sk_buff_cb_0]) = r0;\t\t\\\n\tr0 = *(u8*)(r1 + %[__sk_buff_cb_0]);\t\t\\\n\tif r0 == 13 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr3 = 0;\t\t\t\t\t\t\\\n\tr2 = %[map_prog2_socket] ll;\t\t\t\\\nl1_%=:\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket),\n\t  __imm_addr(map_prog2_socket),\n\t  __imm_const(__sk_buff_cb_0, offsetof(struct __sk_buff, cb[0]))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: tail_call out of bounds\")\n__success __success_unpriv __retval(2)\n__naked void tail_call_out_of_bounds(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr3 = 256;\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 2;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: pass negative index to tail_call\")\n__success __success_unpriv __retval(2)\n__naked void negative_index_to_tail_call(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr3 = -1;\t\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 2;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"runtime/jit: pass > 32bit index to tail_call\")\n__success __success_unpriv __retval(42)\n/* Verifier rewrite for unpriv skips tail call here. */\n__retval_unpriv(2)\n__naked void _32bit_index_to_tail_call(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr3 = 0x100000000 ll;\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 2;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}