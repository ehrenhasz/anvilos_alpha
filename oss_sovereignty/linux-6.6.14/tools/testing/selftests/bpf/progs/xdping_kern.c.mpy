{
  "module_name": "xdping_kern.c",
  "hash_id": "e3021c6a72cdc196d39312873314a282473affd4e407071532e01aebaa359749",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/xdping_kern.c",
  "human_readable_source": "\n \n\n#define KBUILD_MODNAME \"foo\"\n#include <stddef.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/icmp.h>\n#include <linux/in.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#include \"xdping.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 256);\n\t__type(key, __u32);\n\t__type(value, struct pinginfo);\n} ping_map SEC(\".maps\");\n\nstatic __always_inline void swap_src_dst_mac(void *data)\n{\n\tunsigned short *p = data;\n\tunsigned short dst[3];\n\n\tdst[0] = p[0];\n\tdst[1] = p[1];\n\tdst[2] = p[2];\n\tp[0] = p[3];\n\tp[1] = p[4];\n\tp[2] = p[5];\n\tp[3] = dst[0];\n\tp[4] = dst[1];\n\tp[5] = dst[2];\n}\n\nstatic __always_inline __u16 csum_fold_helper(__wsum sum)\n{\n\tsum = (sum & 0xffff) + (sum >> 16);\n\treturn ~((sum & 0xffff) + (sum >> 16));\n}\n\nstatic __always_inline __u16 ipv4_csum(void *data_start, int data_size)\n{\n\t__wsum sum;\n\n\tsum = bpf_csum_diff(0, 0, data_start, data_size, 0);\n\treturn csum_fold_helper(sum);\n}\n\n#define ICMP_ECHO_LEN\t\t64\n\nstatic __always_inline int icmp_check(struct xdp_md *ctx, int type)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct ethhdr *eth = data;\n\tstruct icmphdr *icmph;\n\tstruct iphdr *iph;\n\n\tif (data + sizeof(*eth) + sizeof(*iph) + ICMP_ECHO_LEN > data_end)\n\t\treturn XDP_PASS;\n\n\tif (eth->h_proto != bpf_htons(ETH_P_IP))\n\t\treturn XDP_PASS;\n\n\tiph = data + sizeof(*eth);\n\n\tif (iph->protocol != IPPROTO_ICMP)\n\t\treturn XDP_PASS;\n\n\tif (bpf_ntohs(iph->tot_len) - sizeof(*iph) != ICMP_ECHO_LEN)\n\t\treturn XDP_PASS;\n\n\ticmph = data + sizeof(*eth) + sizeof(*iph);\n\n\tif (icmph->type != type)\n\t\treturn XDP_PASS;\n\n\treturn XDP_TX;\n}\n\nSEC(\"xdp\")\nint xdping_client(struct xdp_md *ctx)\n{\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct pinginfo *pinginfo = NULL;\n\tstruct ethhdr *eth = data;\n\tstruct icmphdr *icmph;\n\tstruct iphdr *iph;\n\t__u64 recvtime;\n\t__be32 raddr;\n\t__be16 seq;\n\tint ret;\n\t__u8 i;\n\n\tret = icmp_check(ctx, ICMP_ECHOREPLY);\n\n\tif (ret != XDP_TX)\n\t\treturn ret;\n\n\tiph = data + sizeof(*eth);\n\ticmph = data + sizeof(*eth) + sizeof(*iph);\n\traddr = iph->saddr;\n\n\t \n\trecvtime = bpf_ktime_get_ns();\n\tpinginfo = bpf_map_lookup_elem(&ping_map, &raddr);\n\tif (!pinginfo || pinginfo->seq != icmph->un.echo.sequence)\n\t\treturn XDP_PASS;\n\n\tif (pinginfo->start) {\n#pragma clang loop unroll(full)\n\t\tfor (i = 0; i < XDPING_MAX_COUNT; i++) {\n\t\t\tif (pinginfo->times[i] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (i < XDPING_MAX_COUNT) {\n\t\t\tpinginfo->times[i] = recvtime -\n\t\t\t\t\t     pinginfo->start;\n\t\t\tpinginfo->start = 0;\n\t\t\ti++;\n\t\t}\n\t\t \n\t\tif (i == pinginfo->count || i == XDPING_MAX_COUNT)\n\t\t\treturn XDP_PASS;\n\t}\n\n\t \n\tswap_src_dst_mac(data);\n\tiph->saddr = iph->daddr;\n\tiph->daddr = raddr;\n\ticmph->type = ICMP_ECHO;\n\tseq = bpf_htons(bpf_ntohs(icmph->un.echo.sequence) + 1);\n\ticmph->un.echo.sequence = seq;\n\ticmph->checksum = 0;\n\ticmph->checksum = ipv4_csum(icmph, ICMP_ECHO_LEN);\n\n\tpinginfo->seq = seq;\n\tpinginfo->start = bpf_ktime_get_ns();\n\n\treturn XDP_TX;\n}\n\nSEC(\"xdp\")\nint xdping_server(struct xdp_md *ctx)\n{\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct ethhdr *eth = data;\n\tstruct icmphdr *icmph;\n\tstruct iphdr *iph;\n\t__be32 raddr;\n\tint ret;\n\n\tret = icmp_check(ctx, ICMP_ECHO);\n\n\tif (ret != XDP_TX)\n\t\treturn ret;\n\n\tiph = data + sizeof(*eth);\n\ticmph = data + sizeof(*eth) + sizeof(*iph);\n\traddr = iph->saddr;\n\n\t \n\tswap_src_dst_mac(data);\n\tiph->saddr = iph->daddr;\n\tiph->daddr = raddr;\n\ticmph->type = ICMP_ECHOREPLY;\n\ticmph->checksum = 0;\n\ticmph->checksum = ipv4_csum(icmph, ICMP_ECHO_LEN);\n\n\treturn XDP_TX;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}