{
  "module_name": "test_sk_storage_tracing.c",
  "hash_id": "c9cd4b060e45129820645e6c6a6e22d94f88e1cc4bd49e44b8128af9f29b9aa6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_sk_storage_tracing.c",
  "human_readable_source": "\n \n\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n#include <bpf/bpf_helpers.h>\n\nstruct sk_stg {\n\t__u32 pid;\n\t__u32 last_notclose_state;\n\tchar comm[16];\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct sk_stg);\n} sk_stg_map SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, int);\n} del_sk_stg_map SEC(\".maps\");\n\nchar task_comm[16] = \"\";\n\nSEC(\"tp_btf/inet_sock_set_state\")\nint BPF_PROG(trace_inet_sock_set_state, struct sock *sk, int oldstate,\n\t     int newstate)\n{\n\tstruct sk_stg *stg;\n\n\tif (newstate == BPF_TCP_CLOSE)\n\t\treturn 0;\n\n\tstg = bpf_sk_storage_get(&sk_stg_map, sk, 0,\n\t\t\t\t BPF_SK_STORAGE_GET_F_CREATE);\n\tif (!stg)\n\t\treturn 0;\n\n\tstg->last_notclose_state = newstate;\n\n\tbpf_sk_storage_delete(&del_sk_stg_map, sk);\n\n\treturn 0;\n}\n\nstatic void set_task_info(struct sock *sk)\n{\n\tstruct task_struct *task;\n\tstruct sk_stg *stg;\n\n\tstg = bpf_sk_storage_get(&sk_stg_map, sk, 0,\n\t\t\t\t BPF_SK_STORAGE_GET_F_CREATE);\n\tif (!stg)\n\t\treturn;\n\n\tstg->pid = bpf_get_current_pid_tgid();\n\n\ttask = (struct task_struct *)bpf_get_current_task();\n\tbpf_core_read_str(&stg->comm, sizeof(stg->comm), &task->comm);\n\tbpf_core_read_str(&task_comm, sizeof(task_comm), &task->comm);\n}\n\nSEC(\"fentry/inet_csk_listen_start\")\nint BPF_PROG(trace_inet_csk_listen_start, struct sock *sk)\n{\n\tset_task_info(sk);\n\n\treturn 0;\n}\n\nSEC(\"fentry/tcp_connect\")\nint BPF_PROG(trace_tcp_connect, struct sock *sk)\n{\n\tset_task_info(sk);\n\n\treturn 0;\n}\n\nSEC(\"fexit/inet_csk_accept\")\nint BPF_PROG(inet_csk_accept, struct sock *sk, int flags, int *err, bool kern,\n\t     struct sock *accepted_sk)\n{\n\tset_task_info(accepted_sk);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/tcp_retransmit_synack\")\nint BPF_PROG(tcp_retransmit_synack, struct sock* sk, struct request_sock* req)\n{\n\t \n\tbpf_sk_storage_get(&sk_stg_map, sk, 0, 0);\n\tbpf_sk_storage_get(&sk_stg_map, req->sk, 0, 0);\n\treturn 0;\n}\n\nSEC(\"tp_btf/tcp_bad_csum\")\nint BPF_PROG(tcp_bad_csum, struct sk_buff* skb)\n{\n\tbpf_sk_storage_get(&sk_stg_map, skb->sk, 0, 0);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}