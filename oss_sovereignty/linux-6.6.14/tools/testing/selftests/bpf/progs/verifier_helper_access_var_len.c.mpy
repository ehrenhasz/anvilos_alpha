{
  "module_name": "verifier_helper_access_var_len.c",
  "hash_id": "0bd9e0dc15a63086dafc8f2250afc9a20659290a1f2c4cddbc5ae4c91fb246f8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_helper_access_var_len.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\n#define MAX_ENTRIES 11\n\nstruct test_val {\n\tunsigned int index;\n\tint foo[MAX_ENTRIES];\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, struct test_val);\n} map_hash_48b SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, long long);\n} map_hash_8b SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_RINGBUF);\n\t__uint(max_entries, 4096);\n} map_ringbuf SEC(\".maps\");\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: stack, bitwise AND + JMP, correct bounds\")\n__success\n__naked void bitwise_and_jmp_correct_bounds(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -64;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 64) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 56) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 48) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 40) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 32) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 24) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 16) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\tr2 = 16;\t\t\t\t\t\\\n\t*(u64*)(r1 - 128) = r2;\t\t\t\t\\\n\tr2 = *(u64*)(r1 - 128);\t\t\t\t\\\n\tr2 &= 64;\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 >= r2 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"helper access to variable memory: stack, bitwise AND, zero included\")\n/* in privileged mode reads from uninitialized stack locations are permitted */\n__success __failure_unpriv\n__msg_unpriv(\"invalid indirect read from stack R2 off -64+0 size 64\")\n__retval(0)\n__naked void stack_bitwise_and_zero_included(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\tr6 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 128) = r6;\t\t\t\\\n\t \t\t\t\\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tr3 = r0;\t\t\t\t\t\\\n\t \\\n\tr3 &= 64;\t\t\t\t\t\\\n\tr1 = %[map_ringbuf] ll;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -64;\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tcall %[bpf_ringbuf_output];\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_prandom_u32),\n\t  __imm(bpf_ringbuf_output),\n\t  __imm_addr(map_ringbuf)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: stack, bitwise AND + JMP, wrong max\")\n__failure __msg(\"invalid indirect access to stack R1 off=-64 size=65\")\n__naked void bitwise_and_jmp_wrong_max(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + 8);\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -64;\t\t\t\t\t\\\n\t*(u64*)(r1 - 128) = r2;\t\t\t\t\\\n\tr2 = *(u64*)(r1 - 128);\t\t\t\t\\\n\tr2 &= 65;\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 >= r2 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: stack, JMP, correct bounds\")\n__success\n__naked void memory_stack_jmp_correct_bounds(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -64;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 64) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 56) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 48) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 40) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 32) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 24) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 16) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\tr2 = 16;\t\t\t\t\t\\\n\t*(u64*)(r1 - 128) = r2;\t\t\t\t\\\n\tr2 = *(u64*)(r1 - 128);\t\t\t\t\\\n\tif r2 > 64 goto l0_%=;\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 >= r2 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: stack, JMP (signed), correct bounds\")\n__success\n__naked void stack_jmp_signed_correct_bounds(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -64;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 64) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 56) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 48) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 40) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 32) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 24) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 16) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\tr2 = 16;\t\t\t\t\t\\\n\t*(u64*)(r1 - 128) = r2;\t\t\t\t\\\n\tr2 = *(u64*)(r1 - 128);\t\t\t\t\\\n\tif r2 s> 64 goto l0_%=;\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 s>= r2 goto l0_%=;\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: stack, JMP, bounds + offset\")\n__failure __msg(\"invalid indirect access to stack R1 off=-64 size=65\")\n__naked void memory_stack_jmp_bounds_offset(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + 8);\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -64;\t\t\t\t\t\\\n\t*(u64*)(r1 - 128) = r2;\t\t\t\t\\\n\tr2 = *(u64*)(r1 - 128);\t\t\t\t\\\n\tif r2 > 64 goto l0_%=;\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 >= r2 goto l0_%=;\t\t\t\t\\\n\tr2 += 1;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: stack, JMP, wrong max\")\n__failure __msg(\"invalid indirect access to stack R1 off=-64 size=65\")\n__naked void memory_stack_jmp_wrong_max(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + 8);\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -64;\t\t\t\t\t\\\n\t*(u64*)(r1 - 128) = r2;\t\t\t\t\\\n\tr2 = *(u64*)(r1 - 128);\t\t\t\t\\\n\tif r2 > 65 goto l0_%=;\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 >= r2 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: stack, JMP, no max check\")\n__failure\n/* because max wasn't checked, signed min is negative */\n__msg(\"R2 min value is negative, either use unsigned or 'var &= const'\")\n__naked void stack_jmp_no_max_check(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + 8);\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -64;\t\t\t\t\t\\\n\t*(u64*)(r1 - 128) = r2;\t\t\t\t\\\n\tr2 = *(u64*)(r1 - 128);\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 >= r2 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"helper access to variable memory: stack, JMP, no min check\")\n/* in privileged mode reads from uninitialized stack locations are permitted */\n__success __failure_unpriv\n__msg_unpriv(\"invalid indirect read from stack R2 off -64+0 size 64\")\n__retval(0)\n__naked void stack_jmp_no_min_check(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\tr6 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 128) = r6;\t\t\t\\\n\t \t\t\t\\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tr3 = r0;\t\t\t\t\t\\\n\t \t\\\n\tif r3 > 64 goto l0_%=;\t\t\t\t\\\n\tr1 = %[map_ringbuf] ll;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -64;\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tcall %[bpf_ringbuf_output];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_prandom_u32),\n\t  __imm(bpf_ringbuf_output),\n\t  __imm_addr(map_ringbuf)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: stack, JMP (signed), no min check\")\n__failure __msg(\"R2 min value is negative\")\n__naked void jmp_signed_no_min_check(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + 8);\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -64;\t\t\t\t\t\\\n\t*(u64*)(r1 - 128) = r2;\t\t\t\t\\\n\tr2 = *(u64*)(r1 - 128);\t\t\t\t\\\n\tif r2 s> 64 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: map, JMP, correct bounds\")\n__success\n__naked void memory_map_jmp_correct_bounds(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = %[sizeof_test_val];\t\t\t\\\n\t*(u64*)(r10 - 128) = r2;\t\t\t\\\n\tr2 = *(u64*)(r10 - 128);\t\t\t\\\n\tif r2 s> %[sizeof_test_val] goto l1_%=;\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 s>= r2 goto l1_%=;\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(sizeof_test_val, sizeof(struct test_val))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: map, JMP, wrong max\")\n__failure __msg(\"invalid access to map value, value_size=48 off=0 size=49\")\n__naked void memory_map_jmp_wrong_max(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = *(u64*)(r1 + 8);\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = r6;\t\t\t\t\t\\\n\t*(u64*)(r10 - 128) = r2;\t\t\t\\\n\tr2 = *(u64*)(r10 - 128);\t\t\t\\\n\tif r2 s> %[__imm_0] goto l1_%=;\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 s>= r2 goto l1_%=;\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) + 1)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: map adjusted, JMP, correct bounds\")\n__success\n__naked void map_adjusted_jmp_correct_bounds(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr1 += 20;\t\t\t\t\t\\\n\tr2 = %[sizeof_test_val];\t\t\t\\\n\t*(u64*)(r10 - 128) = r2;\t\t\t\\\n\tr2 = *(u64*)(r10 - 128);\t\t\t\\\n\tif r2 s> %[__imm_0] goto l1_%=;\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 s>= r2 goto l1_%=;\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) - 20),\n\t  __imm_const(sizeof_test_val, sizeof(struct test_val))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: map adjusted, JMP, wrong max\")\n__failure __msg(\"R1 min value is outside of the allowed memory range\")\n__naked void map_adjusted_jmp_wrong_max(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = *(u64*)(r1 + 8);\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r1;\t\t\t\t\\\n\tr1 = %[map_hash_48b] ll;\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr1 += 20;\t\t\t\t\t\\\n\tr2 = r6;\t\t\t\t\t\\\n\t*(u64*)(r10 - 128) = r2;\t\t\t\\\n\tr2 = *(u64*)(r10 - 128);\t\t\t\\\n\tif r2 s> %[__imm_0] goto l1_%=;\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tif r4 s>= r2 goto l1_%=;\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_48b),\n\t  __imm_const(__imm_0, sizeof(struct test_val) - 19)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"helper access to variable memory: size = 0 allowed on NULL (ARG_PTR_TO_MEM_OR_NULL)\")\n__success __retval(0)\n__naked void ptr_to_mem_or_null_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tr5 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_csum_diff];\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_csum_diff)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"helper access to variable memory: size > 0 not allowed on NULL (ARG_PTR_TO_MEM_OR_NULL)\")\n__failure __msg(\"R1 type=scalar expected=fp\")\n__naked void ptr_to_mem_or_null_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 128) = r2;\t\t\t\\\n\tr2 = *(u64*)(r10 - 128);\t\t\t\\\n\tr2 &= 64;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tr5 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_csum_diff];\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_csum_diff)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"helper access to variable memory: size = 0 allowed on != NULL stack pointer (ARG_PTR_TO_MEM_OR_NULL)\")\n__success __retval(0)\n__naked void ptr_to_mem_or_null_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -8;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r1 + 0) = r2;\t\t\t\t\\\n\tr2 &= 8;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tr5 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_csum_diff];\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_csum_diff)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"helper access to variable memory: size = 0 allowed on != NULL map pointer (ARG_PTR_TO_MEM_OR_NULL)\")\n__success __retval(0)\n__naked void ptr_to_mem_or_null_4(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tr5 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_csum_diff];\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_csum_diff),\n\t  __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"helper access to variable memory: size possible = 0 allowed on != NULL stack pointer (ARG_PTR_TO_MEM_OR_NULL)\")\n__success __retval(0)\n__naked void ptr_to_mem_or_null_5(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tif r2 > 8 goto l0_%=;\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -8;\t\t\t\t\t\\\n\t*(u64*)(r1 + 0) = r2;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tr5 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_csum_diff];\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_csum_diff),\n\t  __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"helper access to variable memory: size possible = 0 allowed on != NULL map pointer (ARG_PTR_TO_MEM_OR_NULL)\")\n__success __retval(0)\n__naked void ptr_to_mem_or_null_6(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tif r2 > 8 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tr5 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_csum_diff];\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_csum_diff),\n\t  __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"helper access to variable memory: size possible = 0 allowed on != NULL packet pointer (ARG_PTR_TO_MEM_OR_NULL)\")\n__success __retval(0)\n/* csum_diff of 64-byte packet */\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void ptr_to_mem_or_null_7(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[__sk_buff_data_end]);\t\\\n\tr0 = r6;\t\t\t\t\t\\\n\tr0 += 8;\t\t\t\t\t\\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tr2 = *(u64*)(r6 + 0);\t\t\t\t\\\n\tif r2 > 8 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tr5 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_csum_diff];\t\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_csum_diff),\n\t  __imm_const(__sk_buff_data, offsetof(struct __sk_buff, data)),\n\t  __imm_const(__sk_buff_data_end, offsetof(struct __sk_buff, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: size = 0 not allowed on NULL (!ARG_PTR_TO_MEM_OR_NULL)\")\n__failure __msg(\"R1 type=scalar expected=fp\")\n__naked void ptr_to_mem_or_null_8(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: size > 0 not allowed on NULL (!ARG_PTR_TO_MEM_OR_NULL)\")\n__failure __msg(\"R1 type=scalar expected=fp\")\n__naked void ptr_to_mem_or_null_9(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\tr2 = 1;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: size = 0 allowed on != NULL stack pointer (!ARG_PTR_TO_MEM_OR_NULL)\")\n__success\n__naked void ptr_to_mem_or_null_10(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -8;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: size = 0 allowed on != NULL map pointer (!ARG_PTR_TO_MEM_OR_NULL)\")\n__success\n__naked void ptr_to_mem_or_null_11(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: size possible = 0 allowed on != NULL stack pointer (!ARG_PTR_TO_MEM_OR_NULL)\")\n__success\n__naked void ptr_to_mem_or_null_12(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tif r2 > 8 goto l0_%=;\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 += -8;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: size possible = 0 allowed on != NULL map pointer (!ARG_PTR_TO_MEM_OR_NULL)\")\n__success\n__naked void ptr_to_mem_or_null_13(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\tr1 = r0;\t\t\t\t\t\\\n\tr2 = *(u64*)(r0 + 0);\t\t\t\t\\\n\tif r2 > 8 goto l0_%=;\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\nl0_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm(bpf_probe_read_kernel),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"helper access to variable memory: 8 bytes leak\")\n/* in privileged mode reads from uninitialized stack locations are permitted */\n__success __failure_unpriv\n__msg_unpriv(\"invalid indirect read from stack R2 off -64+32 size 64\")\n__retval(0)\n__naked void variable_memory_8_bytes_leak(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\tr6 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 128) = r6;\t\t\t\\\n\t \t\t\t\\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tr3 = r0;\t\t\t\t\t\\\n\tr1 = %[map_ringbuf] ll;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -64;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 64) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 56) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 48) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 40) = r0;\t\t\t\t\\\n\t \t\t\\\n\t*(u64*)(r10 - 24) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 16) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\t \t\t\t\\\n\tr3 &= 63;\t\t\t\t\t\\\n\tr3 += 1;\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tcall %[bpf_ringbuf_output];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_prandom_u32),\n\t  __imm(bpf_ringbuf_output),\n\t  __imm_addr(map_ringbuf)\n\t: __clobber_all);\n}\n\nSEC(\"tracepoint\")\n__description(\"helper access to variable memory: 8 bytes no leak (init memory)\")\n__success\n__naked void bytes_no_leak_init_memory(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 64) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 56) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 48) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 40) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 32) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 24) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 16) = r0;\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\tr1 += -64;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tr2 &= 32;\t\t\t\t\t\\\n\tr2 += 32;\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_probe_read_kernel];\t\t\t\\\n\tr1 = *(u64*)(r10 - 16);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_probe_read_kernel)\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}