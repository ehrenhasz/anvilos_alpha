{
  "module_name": "uprobe_multi.c",
  "hash_id": "29e9d9b91a3661e0907eb9bdbb03c9e571b60e0ae455dd455e35bc168b1e1a20",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/uprobe_multi.c",
  "human_readable_source": "\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <stdbool.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n__u64 uprobe_multi_func_1_addr = 0;\n__u64 uprobe_multi_func_2_addr = 0;\n__u64 uprobe_multi_func_3_addr = 0;\n\n__u64 uprobe_multi_func_1_result = 0;\n__u64 uprobe_multi_func_2_result = 0;\n__u64 uprobe_multi_func_3_result = 0;\n\n__u64 uretprobe_multi_func_1_result = 0;\n__u64 uretprobe_multi_func_2_result = 0;\n__u64 uretprobe_multi_func_3_result = 0;\n\n__u64 uprobe_multi_sleep_result = 0;\n\nint pid = 0;\nint child_pid = 0;\n\nbool test_cookie = false;\nvoid *user_ptr = 0;\n\nstatic __always_inline bool verify_sleepable_user_copy(void)\n{\n\tchar data[9];\n\n\tbpf_copy_from_user(data, sizeof(data), user_ptr);\n\treturn bpf_strncmp(data, sizeof(data), \"test_data\") == 0;\n}\n\nstatic void uprobe_multi_check(void *ctx, bool is_return, bool is_sleep)\n{\n\tchild_pid = bpf_get_current_pid_tgid() >> 32;\n\n\tif (pid && child_pid != pid)\n\t\treturn;\n\n\t__u64 cookie = test_cookie ? bpf_get_attach_cookie(ctx) : 0;\n\t__u64 addr = bpf_get_func_ip(ctx);\n\n#define SET(__var, __addr, __cookie) ({\t\t\t\\\n\tif (addr == __addr &&\t\t\t\t\\\n\t   (!test_cookie || (cookie == __cookie)))\t\\\n\t\t__var += 1;\t\t\t\t\\\n})\n\n\tif (is_return) {\n\t\tSET(uretprobe_multi_func_1_result, uprobe_multi_func_1_addr, 2);\n\t\tSET(uretprobe_multi_func_2_result, uprobe_multi_func_2_addr, 3);\n\t\tSET(uretprobe_multi_func_3_result, uprobe_multi_func_3_addr, 1);\n\t} else {\n\t\tSET(uprobe_multi_func_1_result, uprobe_multi_func_1_addr, 3);\n\t\tSET(uprobe_multi_func_2_result, uprobe_multi_func_2_addr, 1);\n\t\tSET(uprobe_multi_func_3_result, uprobe_multi_func_3_addr, 2);\n\t}\n\n#undef SET\n\n\tif (is_sleep && verify_sleepable_user_copy())\n\t\tuprobe_multi_sleep_result += 1;\n}\n\nSEC(\"uprobe.multi//proc/self/exe:uprobe_multi_func_*\")\nint uprobe(struct pt_regs *ctx)\n{\n\tuprobe_multi_check(ctx, false, false);\n\treturn 0;\n}\n\nSEC(\"uretprobe.multi//proc/self/exe:uprobe_multi_func_*\")\nint uretprobe(struct pt_regs *ctx)\n{\n\tuprobe_multi_check(ctx, true, false);\n\treturn 0;\n}\n\nSEC(\"uprobe.multi.s//proc/self/exe:uprobe_multi_func_*\")\nint uprobe_sleep(struct pt_regs *ctx)\n{\n\tuprobe_multi_check(ctx, false, true);\n\treturn 0;\n}\n\nSEC(\"uretprobe.multi.s//proc/self/exe:uprobe_multi_func_*\")\nint uretprobe_sleep(struct pt_regs *ctx)\n{\n\tuprobe_multi_check(ctx, true, true);\n\treturn 0;\n}\n\nSEC(\"uprobe.multi//proc/self/exe:uprobe_multi_func_*\")\nint uprobe_extra(struct pt_regs *ctx)\n{\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}