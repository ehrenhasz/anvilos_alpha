{
  "module_name": "map_kptr_fail.c",
  "hash_id": "3b4e0f6484b38bd5db9cc13bb6b448da5a74fcadebc84e674808816cb5297372",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/map_kptr_fail.c",
  "human_readable_source": "\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_misc.h\"\n#include \"../bpf_testmod/bpf_testmod_kfunc.h\"\n\nstruct map_value {\n\tchar buf[8];\n\tstruct prog_test_ref_kfunc __kptr_untrusted *unref_ptr;\n\tstruct prog_test_ref_kfunc __kptr *ref_ptr;\n\tstruct prog_test_member __kptr *ref_memb_ptr;\n};\n\nstruct array_map {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, int);\n\t__type(value, struct map_value);\n\t__uint(max_entries, 1);\n} array_map SEC(\".maps\");\n\nSEC(\"?tc\")\n__failure __msg(\"kptr access size must be BPF_DW\")\nint size_not_bpf_dw(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\t*(u32 *)&v->unref_ptr = 0;\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"kptr access cannot have variable offset\")\nint non_const_var_off(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0, id;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tid = ctx->protocol;\n\tif (id < 4 || id > 12)\n\t\treturn 0;\n\t*(u64 *)((void *)v + id) = 0;\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"R1 doesn't have constant offset. kptr has to be\")\nint non_const_var_off_kptr_xchg(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0, id;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tid = ctx->protocol;\n\tif (id < 4 || id > 12)\n\t\treturn 0;\n\tbpf_kptr_xchg((void *)v + id, NULL);\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"kptr access misaligned expected=8 off=7\")\nint misaligned_access_write(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\t*(void **)((void *)v + 7) = NULL;\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"kptr access misaligned expected=8 off=1\")\nint misaligned_access_read(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\treturn *(u64 *)((void *)v + 1);\n}\n\nSEC(\"?tc\")\n__failure __msg(\"variable untrusted_ptr_ access var_off=(0x0; 0x1e0)\")\nint reject_var_off_store(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *unref_ptr;\n\tstruct map_value *v;\n\tint key = 0, id;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tunref_ptr = v->unref_ptr;\n\tif (!unref_ptr)\n\t\treturn 0;\n\tid = ctx->protocol;\n\tif (id < 4 || id > 12)\n\t\treturn 0;\n\tunref_ptr += id;\n\tv->unref_ptr = unref_ptr;\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"invalid kptr access, R1 type=untrusted_ptr_prog_test_ref_kfunc\")\nint reject_bad_type_match(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *unref_ptr;\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tunref_ptr = v->unref_ptr;\n\tif (!unref_ptr)\n\t\treturn 0;\n\tunref_ptr = (void *)unref_ptr + 4;\n\tv->unref_ptr = unref_ptr;\n\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"R1 type=untrusted_ptr_or_null_ expected=percpu_ptr_\")\nint marked_as_untrusted_or_null(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tbpf_this_cpu_ptr(v->unref_ptr);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"access beyond struct prog_test_ref_kfunc at off 32 size 4\")\nint correct_btf_id_check_size(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *p;\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tp = v->unref_ptr;\n\tif (!p)\n\t\treturn 0;\n\treturn *(int *)((void *)p + bpf_core_type_size(struct prog_test_ref_kfunc));\n}\n\nSEC(\"?tc\")\n__failure __msg(\"R1 type=untrusted_ptr_ expected=percpu_ptr_\")\nint inherit_untrusted_on_walk(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *unref_ptr;\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tunref_ptr = v->unref_ptr;\n\tif (!unref_ptr)\n\t\treturn 0;\n\tunref_ptr = unref_ptr->next;\n\tbpf_this_cpu_ptr(unref_ptr);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"off=8 kptr isn't referenced kptr\")\nint reject_kptr_xchg_on_unref(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tbpf_kptr_xchg(&v->unref_ptr, NULL);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"R1 type=rcu_ptr_or_null_ expected=percpu_ptr_\")\nint mark_ref_as_untrusted_or_null(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tbpf_this_cpu_ptr(v->ref_ptr);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"store to referenced kptr disallowed\")\nint reject_untrusted_store_to_ref(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *p;\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tp = v->ref_ptr;\n\tif (!p)\n\t\treturn 0;\n\t \n\t*(struct prog_test_ref_kfunc * volatile *)&v->ref_ptr = p;\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"R2 must be referenced\")\nint reject_untrusted_xchg(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *p;\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tp = v->ref_ptr;\n\tif (!p)\n\t\treturn 0;\n\tbpf_kptr_xchg(&v->ref_ptr, p);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure\n__msg(\"invalid kptr access, R2 type=ptr_prog_test_ref_kfunc expected=ptr_prog_test_member\")\nint reject_bad_type_xchg(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *ref_ptr;\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tref_ptr = bpf_kfunc_call_test_acquire(&(unsigned long){0});\n\tif (!ref_ptr)\n\t\treturn 0;\n\tbpf_kptr_xchg(&v->ref_memb_ptr, ref_ptr);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"invalid kptr access, R2 type=ptr_prog_test_ref_kfunc\")\nint reject_member_of_ref_xchg(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *ref_ptr;\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tref_ptr = bpf_kfunc_call_test_acquire(&(unsigned long){0});\n\tif (!ref_ptr)\n\t\treturn 0;\n\tbpf_kptr_xchg(&v->ref_memb_ptr, &ref_ptr->memb);\n\treturn 0;\n}\n\nSEC(\"?syscall\")\n__failure __msg(\"kptr cannot be accessed indirectly by helper\")\nint reject_indirect_helper_access(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tbpf_get_current_comm(v, sizeof(v->buf) + 1);\n\treturn 0;\n}\n\n__noinline\nint write_func(int *p)\n{\n\treturn p ? *p = 42 : 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"kptr cannot be accessed indirectly by helper\")\nint reject_indirect_global_func_access(struct __sk_buff *ctx)\n{\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\treturn write_func((void *)v + 5);\n}\n\nSEC(\"?tc\")\n__failure __msg(\"Unreleased reference id=5 alloc_insn=\")\nint kptr_xchg_ref_state(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *p;\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tp = bpf_kfunc_call_test_acquire(&(unsigned long){0});\n\tif (!p)\n\t\treturn 0;\n\tbpf_kptr_xchg(&v->ref_ptr, p);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"Possibly NULL pointer passed to helper arg2\")\nint kptr_xchg_possibly_null(struct __sk_buff *ctx)\n{\n\tstruct prog_test_ref_kfunc *p;\n\tstruct map_value *v;\n\tint key = 0;\n\n\tv = bpf_map_lookup_elem(&array_map, &key);\n\tif (!v)\n\t\treturn 0;\n\n\tp = bpf_kfunc_call_test_acquire(&(unsigned long){0});\n\n\t \n\tp = bpf_kptr_xchg(&v->ref_ptr, p);\n\tif (p)\n\t\tbpf_kfunc_call_test_release(p);\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}