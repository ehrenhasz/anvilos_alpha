{
  "module_name": "test_parse_tcp_hdr_opt_dynptr.c",
  "hash_id": "5e21239a570d045568d279f906473848d29e3b4502ba5d28cc0f078ff5c24d1c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_parse_tcp_hdr_opt_dynptr.c",
  "human_readable_source": "\n\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <linux/tcp.h>\n#include <stdbool.h>\n#include <linux/ipv6.h>\n#include <linux/if_ether.h>\n#include \"test_tcp_hdr_options.h\"\n#include \"bpf_kfuncs.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n \nconst __u32 tcp_hdr_opt_kind_tpr = 0xFD;\n \nconst __u32 tcp_hdr_opt_len_tpr = 6;\n \nconst __u32 tcp_hdr_opt_max_opt_checks = 15;\n\n__u32 server_id;\n\nstatic int parse_hdr_opt(struct bpf_dynptr *ptr, __u32 *off, __u8 *hdr_bytes_remaining,\n\t\t\t __u32 *server_id)\n{\n\t__u8 kind, hdr_len;\n\t__u8 buffer[sizeof(kind) + sizeof(hdr_len) + sizeof(*server_id)];\n\t__u8 *data;\n\n\t__builtin_memset(buffer, 0, sizeof(buffer));\n\n\tdata = bpf_dynptr_slice(ptr, *off, buffer, sizeof(buffer));\n\tif (!data)\n\t\treturn -1;\n\n\tkind = data[0];\n\n\tif (kind == TCPOPT_EOL)\n\t\treturn -1;\n\n\tif (kind == TCPOPT_NOP) {\n\t\t*off += 1;\n\t\t*hdr_bytes_remaining -= 1;\n\t\treturn 0;\n\t}\n\n\tif (*hdr_bytes_remaining < 2)\n\t\treturn -1;\n\n\thdr_len = data[1];\n\tif (hdr_len > *hdr_bytes_remaining)\n\t\treturn -1;\n\n\tif (kind == tcp_hdr_opt_kind_tpr) {\n\t\tif (hdr_len != tcp_hdr_opt_len_tpr)\n\t\t\treturn -1;\n\n\t\t__builtin_memcpy(server_id, (__u32 *)(data + 2), sizeof(*server_id));\n\t\treturn 1;\n\t}\n\n\t*off += hdr_len;\n\t*hdr_bytes_remaining -= hdr_len;\n\treturn 0;\n}\n\nSEC(\"xdp\")\nint xdp_ingress_v6(struct xdp_md *xdp)\n{\n\t__u8 buffer[sizeof(struct tcphdr)] = {};\n\t__u8 hdr_bytes_remaining;\n\tstruct tcphdr *tcp_hdr;\n\t__u8 tcp_hdr_opt_len;\n\tint err = 0;\n\t__u32 off;\n\n\tstruct bpf_dynptr ptr;\n\n\tbpf_dynptr_from_xdp(xdp, 0, &ptr);\n\n\toff = sizeof(struct ethhdr) + sizeof(struct ipv6hdr);\n\n\ttcp_hdr = bpf_dynptr_slice(&ptr, off, buffer, sizeof(buffer));\n\tif (!tcp_hdr)\n\t\treturn XDP_DROP;\n\n\ttcp_hdr_opt_len = (tcp_hdr->doff * 4) - sizeof(struct tcphdr);\n\tif (tcp_hdr_opt_len < tcp_hdr_opt_len_tpr)\n\t\treturn XDP_DROP;\n\n\thdr_bytes_remaining = tcp_hdr_opt_len;\n\n\toff += sizeof(struct tcphdr);\n\n\t \n\tfor (int i = 0; i < tcp_hdr_opt_max_opt_checks; i++) {\n\t\terr = parse_hdr_opt(&ptr, &off, &hdr_bytes_remaining, &server_id);\n\n\t\tif (err || !hdr_bytes_remaining)\n\t\t\tbreak;\n\t}\n\n\tif (!server_id)\n\t\treturn XDP_DROP;\n\n\treturn XDP_PASS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}