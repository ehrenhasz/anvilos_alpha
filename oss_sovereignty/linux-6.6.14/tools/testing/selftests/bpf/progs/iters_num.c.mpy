{
  "module_name": "iters_num.c",
  "hash_id": "6d474f9bd1f0b87fbc4aafe30bd98d3ce08138f0f403343b29faf5febc15502a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/iters_num.c",
  "human_readable_source": "\n \n\n#include <limits.h>\n#include <linux/errno.h>\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nconst volatile __s64 exp_empty_zero = 0 + 1;\n__s64 res_empty_zero;\n\nSEC(\"raw_tp/sys_enter\")\nint num_empty_zero(const void *ctx)\n{\n\t__s64 sum = 0, i;\n\n\tbpf_for(i, 0, 0) sum += i;\n\tres_empty_zero = 1 + sum;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_empty_int_min = 0 + 2;\n__s64 res_empty_int_min;\n\nSEC(\"raw_tp/sys_enter\")\nint num_empty_int_min(const void *ctx)\n{\n\t__s64 sum = 0, i;\n\n\tbpf_for(i, INT_MIN, INT_MIN) sum += i;\n\tres_empty_int_min = 2 + sum;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_empty_int_max = 0 + 3;\n__s64 res_empty_int_max;\n\nSEC(\"raw_tp/sys_enter\")\nint num_empty_int_max(const void *ctx)\n{\n\t__s64 sum = 0, i;\n\n\tbpf_for(i, INT_MAX, INT_MAX) sum += i;\n\tres_empty_int_max = 3 + sum;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_empty_minus_one = 0 + 4;\n__s64 res_empty_minus_one;\n\nSEC(\"raw_tp/sys_enter\")\nint num_empty_minus_one(const void *ctx)\n{\n\t__s64 sum = 0, i;\n\n\tbpf_for(i, -1, -1) sum += i;\n\tres_empty_minus_one = 4 + sum;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_simple_sum = 9 * 10 / 2;\n__s64 res_simple_sum;\n\nSEC(\"raw_tp/sys_enter\")\nint num_simple_sum(const void *ctx)\n{\n\t__s64 sum = 0, i;\n\n\tbpf_for(i, 0, 10) sum += i;\n\tres_simple_sum = sum;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_neg_sum = -11 * 10 / 2;\n__s64 res_neg_sum;\n\nSEC(\"raw_tp/sys_enter\")\nint num_neg_sum(const void *ctx)\n{\n\t__s64 sum = 0, i;\n\n\tbpf_for(i, -10, 0) sum += i;\n\tres_neg_sum = sum;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_very_neg_sum = INT_MIN + (__s64)(INT_MIN + 1);\n__s64 res_very_neg_sum;\n\nSEC(\"raw_tp/sys_enter\")\nint num_very_neg_sum(const void *ctx)\n{\n\t__s64 sum = 0, i;\n\n\tbpf_for(i, INT_MIN, INT_MIN + 2) sum += i;\n\tres_very_neg_sum = sum;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_very_big_sum = (__s64)(INT_MAX - 1) + (__s64)(INT_MAX - 2);\n__s64 res_very_big_sum;\n\nSEC(\"raw_tp/sys_enter\")\nint num_very_big_sum(const void *ctx)\n{\n\t__s64 sum = 0, i;\n\n\tbpf_for(i, INT_MAX - 2, INT_MAX) sum += i;\n\tres_very_big_sum = sum;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_neg_pos_sum = -3;\n__s64 res_neg_pos_sum;\n\nSEC(\"raw_tp/sys_enter\")\nint num_neg_pos_sum(const void *ctx)\n{\n\t__s64 sum = 0, i;\n\n\tbpf_for(i, -3, 3) sum += i;\n\tres_neg_pos_sum = sum;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_invalid_range = -EINVAL;\n__s64 res_invalid_range;\n\nSEC(\"raw_tp/sys_enter\")\nint num_invalid_range(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\n\tres_invalid_range = bpf_iter_num_new(&it, 1, 0);\n\tbpf_iter_num_destroy(&it);\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_max_range = 0 + 10;\n__s64 res_max_range;\n\nSEC(\"raw_tp/sys_enter\")\nint num_max_range(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\n\tres_max_range = 10 + bpf_iter_num_new(&it, 0, BPF_MAX_LOOPS);\n\tbpf_iter_num_destroy(&it);\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_e2big_range = -E2BIG;\n__s64 res_e2big_range;\n\nSEC(\"raw_tp/sys_enter\")\nint num_e2big_range(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\n\tres_e2big_range = bpf_iter_num_new(&it, -1, BPF_MAX_LOOPS);\n\tbpf_iter_num_destroy(&it);\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_succ_elem_cnt = 10;\n__s64 res_succ_elem_cnt;\n\nSEC(\"raw_tp/sys_enter\")\nint num_succ_elem_cnt(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint cnt = 0, *v;\n\n\tbpf_iter_num_new(&it, 0, 10);\n\twhile ((v = bpf_iter_num_next(&it))) {\n\t\tcnt++;\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\tres_succ_elem_cnt = cnt;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_overfetched_elem_cnt = 5;\n__s64 res_overfetched_elem_cnt;\n\nSEC(\"raw_tp/sys_enter\")\nint num_overfetched_elem_cnt(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint cnt = 0, *v, i;\n\n\tbpf_iter_num_new(&it, 0, 5);\n\tfor (i = 0; i < 10; i++) {\n\t\tv = bpf_iter_num_next(&it);\n\t\tif (v)\n\t\t\tcnt++;\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\tres_overfetched_elem_cnt = cnt;\n\n\treturn 0;\n}\n\nconst volatile __s64 exp_fail_elem_cnt = 20 + 0;\n__s64 res_fail_elem_cnt;\n\nSEC(\"raw_tp/sys_enter\")\nint num_fail_elem_cnt(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint cnt = 0, *v, i;\n\n\tbpf_iter_num_new(&it, 100, 10);\n\tfor (i = 0; i < 10; i++) {\n\t\tv = bpf_iter_num_next(&it);\n\t\tif (v)\n\t\t\tcnt++;\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\tres_fail_elem_cnt = 20 + cnt;\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}