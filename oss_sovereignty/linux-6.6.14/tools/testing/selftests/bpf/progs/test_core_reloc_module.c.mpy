{
  "module_name": "test_core_reloc_module.c",
  "hash_id": "8cb31f57951d6ef477d06eba8ecfd4fdcfbf081350e52ffb77666244b53c948f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_core_reloc_module.c",
  "human_readable_source": "\n \n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include <bpf/bpf_tracing.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct bpf_testmod_test_read_ctx {\n\t \n\tsize_t len;\n\tchar *buf;\n\tloff_t off;\n} __attribute__((preserve_access_index));\n\nstruct {\n\tchar in[256];\n\tchar out[256];\n\tbool skip;\n\tuint64_t my_pid_tgid;\n} data = {};\n\nstruct core_reloc_module_output {\n\tlong long len;\n\tlong long off;\n\tint read_ctx_sz;\n\tbool read_ctx_exists;\n\tbool buf_exists;\n\tbool len_exists;\n\tbool off_exists;\n\t \n\tchar comm[sizeof(\"test_progs\")];\n\tint comm_len;\n};\n\nSEC(\"raw_tp/bpf_testmod_test_read\")\nint BPF_PROG(test_core_module_probed,\n\t     struct task_struct *task,\n\t     struct bpf_testmod_test_read_ctx *read_ctx)\n{\n#if __has_builtin(__builtin_preserve_enum_value)\n\tstruct core_reloc_module_output *out = (void *)&data.out;\n\t__u64 pid_tgid = bpf_get_current_pid_tgid();\n\t__u32 real_tgid = (__u32)(pid_tgid >> 32);\n\t__u32 real_pid = (__u32)pid_tgid;\n\n\tif (data.my_pid_tgid != pid_tgid)\n\t\treturn 0;\n\n\tif (BPF_CORE_READ(task, pid) != real_pid || BPF_CORE_READ(task, tgid) != real_tgid)\n\t\treturn 0;\n\n\tout->len = BPF_CORE_READ(read_ctx, len);\n\tout->off = BPF_CORE_READ(read_ctx, off);\n\n\tout->read_ctx_sz = bpf_core_type_size(struct bpf_testmod_test_read_ctx);\n\tout->read_ctx_exists = bpf_core_type_exists(struct bpf_testmod_test_read_ctx);\n\tout->buf_exists = bpf_core_field_exists(read_ctx->buf);\n\tout->off_exists = bpf_core_field_exists(read_ctx->off);\n\tout->len_exists = bpf_core_field_exists(read_ctx->len);\n\n\tout->comm_len = BPF_CORE_READ_STR_INTO(&out->comm, task, comm);\n#else\n\tdata.skip = true;\n#endif\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/bpf_testmod_test_read\")\nint BPF_PROG(test_core_module_direct,\n\t     struct task_struct *task,\n\t     struct bpf_testmod_test_read_ctx *read_ctx)\n{\n#if __has_builtin(__builtin_preserve_enum_value)\n\tstruct core_reloc_module_output *out = (void *)&data.out;\n\t__u64 pid_tgid = bpf_get_current_pid_tgid();\n\t__u32 real_tgid = (__u32)(pid_tgid >> 32);\n\t__u32 real_pid = (__u32)pid_tgid;\n\n\tif (data.my_pid_tgid != pid_tgid)\n\t\treturn 0;\n\n\tif (task->pid != real_pid || task->tgid != real_tgid)\n\t\treturn 0;\n\n\tout->len = read_ctx->len;\n\tout->off = read_ctx->off;\n\n\tout->read_ctx_sz = bpf_core_type_size(struct bpf_testmod_test_read_ctx);\n\tout->read_ctx_exists = bpf_core_type_exists(struct bpf_testmod_test_read_ctx);\n\tout->buf_exists = bpf_core_field_exists(read_ctx->buf);\n\tout->off_exists = bpf_core_field_exists(read_ctx->off);\n\tout->len_exists = bpf_core_field_exists(read_ctx->len);\n\n\tout->comm_len = BPF_CORE_READ_STR_INTO(&out->comm, task, comm);\n#else\n\tdata.skip = true;\n#endif\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}