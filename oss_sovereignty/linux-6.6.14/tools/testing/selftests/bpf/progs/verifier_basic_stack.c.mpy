{
  "module_name": "verifier_basic_stack.c",
  "hash_id": "63604aeafc496137c5dccdb9bbfe975a730829ce8a3c8d98ba929db8dc6bad1b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_basic_stack.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, long long);\n} map_hash_8b SEC(\".maps\");\n\nSEC(\"socket\")\n__description(\"stack out of bounds\")\n__failure __msg(\"invalid write to stack\")\n__failure_unpriv\n__naked void stack_out_of_bounds(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 + 8) = r1;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"uninitialized stack1\")\n__success __log_level(4) __msg(\"stack depth 8\")\n__failure_unpriv __msg_unpriv(\"invalid indirect read from stack\")\n__naked void uninitialized_stack1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"uninitialized stack2\")\n__success __log_level(4) __msg(\"stack depth 8\")\n__failure_unpriv __msg_unpriv(\"invalid read from stack\")\n__naked void uninitialized_stack2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr0 = *(u64*)(r2 - 8);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"invalid fp arithmetic\")\n__failure __msg(\"R1 subtraction from stack pointer\")\n__failure_unpriv\n__naked void invalid_fp_arithmetic(void)\n{\n\t/* If this gets ever changed, make sure JITs can deal with it. */\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\tr1 = r10;\t\t\t\t\t\\\n\tr1 -= 8;\t\t\t\t\t\\\n\t*(u64*)(r1 + 0) = r0;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"non-invalid fp arithmetic\")\n__success __success_unpriv __retval(0)\n__naked void non_invalid_fp_arithmetic(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"misaligned read from stack\")\n__failure __msg(\"misaligned stack access\")\n__failure_unpriv\n__naked void misaligned_read_from_stack(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr0 = *(u64*)(r2 - 4);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}