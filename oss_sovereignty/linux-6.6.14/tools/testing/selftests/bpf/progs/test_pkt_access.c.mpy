{
  "module_name": "test_pkt_access.c",
  "hash_id": "a38d5c580661ac9336cdb767fb5f6e48b3ecddb78a73fc1acbab53b4966f9586",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_pkt_access.c",
  "human_readable_source": "\n \n#include <stddef.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/pkt_cls.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"bpf_misc.h\"\n\n \nstatic __attribute__ ((noinline))\nint test_pkt_access_subprog1(volatile struct __sk_buff *skb)\n{\n\treturn skb->len * 2;\n}\n\nstatic __attribute__ ((noinline))\nint test_pkt_access_subprog2(int val, volatile struct __sk_buff *skb)\n{\n\treturn skb->len * val;\n}\n\n#define MAX_STACK (512 - 2 * 32)\n\n__attribute__ ((noinline))\nint get_skb_len(struct __sk_buff *skb)\n{\n\tvolatile char buf[MAX_STACK] = {};\n\n\t__sink(buf[MAX_STACK - 1]);\n\n\treturn skb->len;\n}\n\n__attribute__ ((noinline))\nint get_constant(long val)\n{\n\treturn val - 122;\n}\n\nint get_skb_ifindex(int, struct __sk_buff *skb, int);\n\n__attribute__ ((noinline))\nint test_pkt_access_subprog3(int val, struct __sk_buff *skb)\n{\n\treturn get_skb_len(skb) * get_skb_ifindex(val, skb, get_constant(123));\n}\n\n__attribute__ ((noinline))\nint get_skb_ifindex(int val, struct __sk_buff *skb, int var)\n{\n\tvolatile char buf[MAX_STACK] = {};\n\n\t__sink(buf[MAX_STACK - 1]);\n\n\treturn skb->ifindex * val * var;\n}\n\n__attribute__ ((noinline))\nint test_pkt_write_access_subprog(struct __sk_buff *skb, __u32 off)\n{\n\tvoid *data = (void *)(long)skb->data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tstruct tcphdr *tcp = NULL;\n\n\tif (off > sizeof(struct ethhdr) + sizeof(struct ipv6hdr))\n\t\treturn -1;\n\n\ttcp = data + off;\n\tif (tcp + 1 > data_end)\n\t\treturn -1;\n\t \n\ttcp->check++;\n\treturn 0;\n}\n\nSEC(\"tc\")\nint test_pkt_access(struct __sk_buff *skb)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tvoid *data = (void *)(long)skb->data;\n\tstruct ethhdr *eth = (struct ethhdr *)(data);\n\tstruct tcphdr *tcp = NULL;\n\t__u8 proto = 255;\n\t__u64 ihl_len;\n\n\tif (eth + 1 > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tif (eth->h_proto == bpf_htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph = (struct iphdr *)(eth + 1);\n\n\t\tif (iph + 1 > data_end)\n\t\t\treturn TC_ACT_SHOT;\n\t\tihl_len = iph->ihl * 4;\n\t\tproto = iph->protocol;\n\t\ttcp = (struct tcphdr *)((void *)(iph) + ihl_len);\n\t} else if (eth->h_proto == bpf_htons(ETH_P_IPV6)) {\n\t\tstruct ipv6hdr *ip6h = (struct ipv6hdr *)(eth + 1);\n\n\t\tif (ip6h + 1 > data_end)\n\t\t\treturn TC_ACT_SHOT;\n\t\tihl_len = sizeof(*ip6h);\n\t\tproto = ip6h->nexthdr;\n\t\ttcp = (struct tcphdr *)((void *)(ip6h) + ihl_len);\n\t}\n\n\tif (test_pkt_access_subprog1(skb) != skb->len * 2)\n\t\treturn TC_ACT_SHOT;\n\tif (test_pkt_access_subprog2(2, skb) != skb->len * 2)\n\t\treturn TC_ACT_SHOT;\n\tif (test_pkt_access_subprog3(3, skb) != skb->len * 3 * skb->ifindex)\n\t\treturn TC_ACT_SHOT;\n\tif (tcp) {\n\t\tif (test_pkt_write_access_subprog(skb, (void *)tcp - data))\n\t\t\treturn TC_ACT_SHOT;\n\t\tif (((void *)(tcp) + 20) > data_end || proto != 6)\n\t\t\treturn TC_ACT_SHOT;\n\t\tbarrier();  \n\t\tif (((void *)(tcp) + 18) > data_end)\n\t\t\treturn TC_ACT_SHOT;\n\t\tif (tcp->urg_ptr == 123)\n\t\t\treturn TC_ACT_OK;\n\t}\n\n\treturn TC_ACT_UNSPEC;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}