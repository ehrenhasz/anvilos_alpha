{
  "module_name": "verifier_spill_fill.c",
  "hash_id": "18700c9832f99dcbc8703b6f91f14202408dd0d14b1646ec5bd21d8167a3991c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_spill_fill.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_RINGBUF);\n\t__uint(max_entries, 4096);\n} map_ringbuf SEC(\".maps\");\n\nSEC(\"socket\")\n__description(\"check valid spill/fill\")\n__success __failure_unpriv __msg_unpriv(\"R0 leaks addr\")\n__retval(POINTER_VALUE)\n__naked void check_valid_spill_fill(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u64*)(r10 - 8);\t\t\t\t\\\n\t \t\\\n\t \\\n\tr0 = r2;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"check valid spill/fill, skb mark\")\n__success __success_unpriv __retval(0)\n__naked void valid_spill_fill_skb_mark(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r1;\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r6;\t\t\t\t\\\n\tr0 = *(u64*)(r10 - 8);\t\t\t\t\\\n\tr0 = *(u32*)(r0 + %[__sk_buff_mark]);\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"check valid spill/fill, ptr to mem\")\n__success __success_unpriv __retval(0)\n__naked void spill_fill_ptr_to_mem(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr1 = %[map_ringbuf] ll;\t\t\t\t\\\n\tr2 = 8;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_ringbuf_reserve];\t\t\t\\\n\t \\\n\tr6 = r0;\t\t\t\t\t\\\n\t \\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\\\n\t*(u64*)(r10 - 8) = r6;\t\t\t\t\\\n\t \t\t\t\\\n\tr7 = *(u64*)(r10 - 8);\t\t\t\t\\\n\t \t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r7 + 0) = r1;\t\t\t\t\\\n\t \t\\\n\tr1 = r7;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_ringbuf_submit];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_ringbuf_reserve),\n\t  __imm(bpf_ringbuf_submit),\n\t  __imm_addr(map_ringbuf)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"check with invalid reg offset 0\")\n__failure __msg(\"R0 pointer arithmetic on ringbuf_mem_or_null prohibited\")\n__failure_unpriv\n__naked void with_invalid_reg_offset_0(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr1 = %[map_ringbuf] ll;\t\t\t\t\\\n\tr2 = 8;\t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_ringbuf_reserve];\t\t\t\\\n\t \\\n\tr6 = r0;\t\t\t\t\t\\\n\t \t\\\n\tr0 += 1;\t\t\t\t\t\\\n\t \\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u32*)(r6 + 0) = r1;\t\t\t\t\\\n\t \t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_ringbuf_submit];\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_ringbuf_reserve),\n\t  __imm(bpf_ringbuf_submit),\n\t  __imm_addr(map_ringbuf)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"check corrupted spill/fill\")\n__failure __msg(\"R0 invalid mem access 'scalar'\")\n__msg_unpriv(\"attempt to corrupt spilled\")\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void check_corrupted_spill_fill(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\t \t\t\\\n\tr0 = 0x23;\t\t\t\t\t\\\n\t*(u8*)(r10 - 7) = r0;\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr0 = *(u64*)(r10 - 8);\t\t\t\t\\\n\t \t\t\t\\\n\tr0 = *(u64*)(r0 + 8);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"check corrupted spill/fill, LSB\")\n__success __failure_unpriv __msg_unpriv(\"attempt to corrupt spilled\")\n__retval(POINTER_VALUE)\n__naked void check_corrupted_spill_fill_lsb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr0 = 0xcafe;\t\t\t\t\t\\\n\t*(u16*)(r10 - 8) = r0;\t\t\t\t\\\n\tr0 = *(u64*)(r10 - 8);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"check corrupted spill/fill, MSB\")\n__success __failure_unpriv __msg_unpriv(\"attempt to corrupt spilled\")\n__retval(POINTER_VALUE)\n__naked void check_corrupted_spill_fill_msb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r1;\t\t\t\t\\\n\tr0 = 0x12345678;\t\t\t\t\\\n\t*(u32*)(r10 - 4) = r0;\t\t\t\t\\\n\tr0 = *(u64*)(r10 - 8);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"Spill and refill a u32 const scalar.  Offset to skb->data\")\n__success __retval(0)\n__naked void scalar_offset_to_skb_data_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__sk_buff_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[__sk_buff_data_end]);\t\\\n\tw4 = 20;\t\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r4;\t\t\t\t\\\n\tr4 = *(u32*)(r10 - 8);\t\t\t\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\t \t\\\n\tr0 += r4;\t\t\t\t\t\\\n\t \\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\t \\\n\tr0 = *(u32*)(r2 + 0);\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_data, offsetof(struct __sk_buff, data)),\n\t  __imm_const(__sk_buff_data_end, offsetof(struct __sk_buff, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"Spill a u32 const, refill from another half of the uninit u32 from the stack\")\n/* in privileged mode reads from uninitialized stack locations are permitted */\n__success __failure_unpriv\n__msg_unpriv(\"invalid read from stack off -4+0 size 4\")\n__retval(0)\n__naked void uninit_u32_from_the_stack(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tw4 = 20;\t\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r4;\t\t\t\t\\\n\t \t\\\n\tr4 = *(u32*)(r10 - 4);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"Spill a u32 const scalar.  Refill as u16.  Offset to skb->data\")\n__failure __msg(\"invalid access to packet\")\n__naked void u16_offset_to_skb_data(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__sk_buff_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[__sk_buff_data_end]);\t\\\n\tw4 = 20;\t\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r4;\t\t\t\t\\\n\tr4 = *(u16*)(r10 - 8);\t\t\t\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\t \\\n\tr0 += r4;\t\t\t\t\t\\\n\t \\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\t \\\n\tr0 = *(u32*)(r2 + 0);\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_data, offsetof(struct __sk_buff, data)),\n\t  __imm_const(__sk_buff_data_end, offsetof(struct __sk_buff, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"Spill u32 const scalars.  Refill as u64.  Offset to skb->data\")\n__failure __msg(\"invalid access to packet\")\n__naked void u64_offset_to_skb_data(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__sk_buff_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[__sk_buff_data_end]);\t\\\n\tw6 = 0;\t\t\t\t\t\t\\\n\tw7 = 20;\t\t\t\t\t\\\n\t*(u32*)(r10 - 4) = r6;\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r7;\t\t\t\t\\\n\tr4 = *(u16*)(r10 - 8);\t\t\t\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\t \\\n\tr0 += r4;\t\t\t\t\t\\\n\t \\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\t \\\n\tr0 = *(u32*)(r2 + 0);\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_data, offsetof(struct __sk_buff, data)),\n\t  __imm_const(__sk_buff_data_end, offsetof(struct __sk_buff, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"Spill a u32 const scalar.  Refill as u16 from fp-6.  Offset to skb->data\")\n__failure __msg(\"invalid access to packet\")\n__naked void _6_offset_to_skb_data(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__sk_buff_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[__sk_buff_data_end]);\t\\\n\tw4 = 20;\t\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r4;\t\t\t\t\\\n\tr4 = *(u16*)(r10 - 6);\t\t\t\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\t \\\n\tr0 += r4;\t\t\t\t\t\\\n\t \\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\t \\\n\tr0 = *(u32*)(r2 + 0);\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_data, offsetof(struct __sk_buff, data)),\n\t  __imm_const(__sk_buff_data_end, offsetof(struct __sk_buff, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"Spill and refill a u32 const scalar at non 8byte aligned stack addr.  Offset to skb->data\")\n__failure __msg(\"invalid access to packet\")\n__naked void addr_offset_to_skb_data(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__sk_buff_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[__sk_buff_data_end]);\t\\\n\tw4 = 20;\t\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r4;\t\t\t\t\\\n\t*(u32*)(r10 - 4) = r4;\t\t\t\t\\\n\tr4 = *(u32*)(r10 - 4);\t\t\t\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\t \\\n\tr0 += r4;\t\t\t\t\t\\\n\t \\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\t \\\n\tr0 = *(u32*)(r2 + 0);\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_data, offsetof(struct __sk_buff, data)),\n\t  __imm_const(__sk_buff_data_end, offsetof(struct __sk_buff, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"Spill and refill a umax=40 bounded scalar.  Offset to skb->data\")\n__success __retval(0)\n__naked void scalar_offset_to_skb_data_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__sk_buff_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[__sk_buff_data_end]);\t\\\n\tr4 = *(u64*)(r1 + %[__sk_buff_tstamp]);\t\t\\\n\tif r4 <= 40 goto l0_%=;\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\nl0_%=:\t \t\t\\\n\t*(u32*)(r10 - 8) = r4;\t\t\t\t\\\n\t \t\t\t\\\n\tr4 = *(u32*)(r10 - 8);\t\t\t\t\\\n\t \t\t\\\n\tr2 += r4;\t\t\t\t\t\\\n\t \t\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\t \t\\\n\tr2 += 20;\t\t\t\t\t\\\n\t \\\n\tif r2 > r3 goto l1_%=;\t\t\t\t\\\n\t \\\n\tr0 = *(u32*)(r0 + 0);\t\t\t\t\\\nl1_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_data, offsetof(struct __sk_buff, data)),\n\t  __imm_const(__sk_buff_data_end, offsetof(struct __sk_buff, data_end)),\n\t  __imm_const(__sk_buff_tstamp, offsetof(struct __sk_buff, tstamp))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"Spill a u32 scalar at fp-4 and then at fp-8\")\n__success __retval(0)\n__naked void and_then_at_fp_8(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tw4 = 4321;\t\t\t\t\t\\\n\t*(u32*)(r10 - 4) = r4;\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r4;\t\t\t\t\\\n\tr4 = *(u64*)(r10 - 8);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"xdp\")\n__description(\"32-bit spill of 64-bit reg should clear ID\")\n__failure __msg(\"math between ctx pointer and 4294967295 is not allowed\")\n__naked void spill_32bit_of_64bit_fail(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r1;\t\t\t\t\t\\\n\t \\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tr0 &= 0x8;\t\t\t\t\t\\\n\t \t\t\\\n\tr1 = 0xffffffff;\t\t\t\t\\\n\tr1 <<= 32;\t\t\t\t\t\\\n\tr1 += r0;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = r1;\t\t\t\t\t\\\n\t \\\n\t*(u32*)(r10 - 8) = r1;\t\t\t\t\\\n\t \t\t\\\n\tr2 = *(u32*)(r10 - 8);\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tif r2 != r3 goto l0_%=;\t\t\t\t\\\nl0_%=:\tr1 >>= 32;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr6 += r1;\t\t\t\t\t\\\n\tr0 = *(u32*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_prandom_u32)\n\t: __clobber_all);\n}\n\nSEC(\"xdp\")\n__description(\"16-bit spill of 32-bit reg should clear ID\")\n__failure __msg(\"dereference of modified ctx ptr R6 off=65535 disallowed\")\n__naked void spill_16bit_of_32bit_fail(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = r1;\t\t\t\t\t\\\n\t \\\n\tcall %[bpf_get_prandom_u32];\t\t\t\\\n\tr0 &= 0x8;\t\t\t\t\t\\\n\t \t\t\\\n\tw1 = 0xffff0000;\t\t\t\t\\\n\tr1 += r0;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = r1;\t\t\t\t\t\\\n\t \\\n\t*(u16*)(r10 - 8) = r1;\t\t\t\t\\\n\t \t\t\\\n\tr2 = *(u16*)(r10 - 8);\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr3 = 0;\t\t\t\t\t\t\\\n\tif r2 != r3 goto l0_%=;\t\t\t\t\\\nl0_%=:\tr1 >>= 16;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr6 += r1;\t\t\t\t\t\\\n\tr0 = *(u32*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_get_prandom_u32)\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}