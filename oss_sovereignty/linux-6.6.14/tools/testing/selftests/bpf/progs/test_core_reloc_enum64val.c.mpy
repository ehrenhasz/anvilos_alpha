{
  "module_name": "test_core_reloc_enum64val.c",
  "hash_id": "6255ef668768ddc79e9f50b0b4c0d7d8b0dcdb20897472be0b8495b73369395a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_core_reloc_enum64val.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct {\n\tchar in[256];\n\tchar out[256];\n\tbool skip;\n} data = {};\n\nenum named_unsigned_enum64 {\n\tUNSIGNED_ENUM64_VAL1 = 0x1ffffffffULL,\n\tUNSIGNED_ENUM64_VAL2 = 0x2ffffffffULL,\n\tUNSIGNED_ENUM64_VAL3 = 0x3ffffffffULL,\n};\n\nenum named_signed_enum64 {\n\tSIGNED_ENUM64_VAL1 = 0x1ffffffffLL,\n\tSIGNED_ENUM64_VAL2 = -2,\n\tSIGNED_ENUM64_VAL3 = 0x3ffffffffLL,\n};\n\nstruct core_reloc_enum64val_output {\n\tbool unsigned_val1_exists;\n\tbool unsigned_val2_exists;\n\tbool unsigned_val3_exists;\n\tbool signed_val1_exists;\n\tbool signed_val2_exists;\n\tbool signed_val3_exists;\n\n\tlong unsigned_val1;\n\tlong unsigned_val2;\n\tlong signed_val1;\n\tlong signed_val2;\n};\n\nSEC(\"raw_tracepoint/sys_enter\")\nint test_core_enum64val(void *ctx)\n{\n#if __clang_major__ >= 15\n\tstruct core_reloc_enum64val_output *out = (void *)&data.out;\n\tenum named_unsigned_enum64 named_unsigned = 0;\n\tenum named_signed_enum64 named_signed = 0;\n\n\tout->unsigned_val1_exists = bpf_core_enum_value_exists(named_unsigned, UNSIGNED_ENUM64_VAL1);\n\tout->unsigned_val2_exists = bpf_core_enum_value_exists(enum named_unsigned_enum64, UNSIGNED_ENUM64_VAL2);\n\tout->unsigned_val3_exists = bpf_core_enum_value_exists(enum named_unsigned_enum64, UNSIGNED_ENUM64_VAL3);\n\tout->signed_val1_exists = bpf_core_enum_value_exists(named_signed, SIGNED_ENUM64_VAL1);\n\tout->signed_val2_exists = bpf_core_enum_value_exists(enum named_signed_enum64, SIGNED_ENUM64_VAL2);\n\tout->signed_val3_exists = bpf_core_enum_value_exists(enum named_signed_enum64, SIGNED_ENUM64_VAL3);\n\n\tout->unsigned_val1 = bpf_core_enum_value(named_unsigned, UNSIGNED_ENUM64_VAL1);\n\tout->unsigned_val2 = bpf_core_enum_value(named_unsigned, UNSIGNED_ENUM64_VAL2);\n\tout->signed_val1 = bpf_core_enum_value(named_signed, SIGNED_ENUM64_VAL1);\n\tout->signed_val2 = bpf_core_enum_value(named_signed, SIGNED_ENUM64_VAL2);\n\t \n\n#else\n\tdata.skip = true;\n#endif\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}