{
  "module_name": "rbtree.c",
  "hash_id": "f70493780387e98b976a4fec0bebe3a729b17cdc31e58cb1128adfffcafbcb75",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/rbtree.c",
  "human_readable_source": "\n \n\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_experimental.h\"\n\nstruct node_data {\n\tlong key;\n\tlong data;\n\tstruct bpf_rb_node node;\n};\n\nlong less_callback_ran = -1;\nlong removed_key = -1;\nlong first_data[2] = {-1, -1};\n\n#define private(name) SEC(\".data.\" #name) __hidden __attribute__((aligned(8)))\nprivate(A) struct bpf_spin_lock glock;\nprivate(A) struct bpf_rb_root groot __contains(node_data, node);\n\nstatic bool less(struct bpf_rb_node *a, const struct bpf_rb_node *b)\n{\n\tstruct node_data *node_a;\n\tstruct node_data *node_b;\n\n\tnode_a = container_of(a, struct node_data, node);\n\tnode_b = container_of(b, struct node_data, node);\n\tless_callback_ran = 1;\n\n\treturn node_a->key < node_b->key;\n}\n\nstatic long __add_three(struct bpf_rb_root *root, struct bpf_spin_lock *lock)\n{\n\tstruct node_data *n, *m;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\tn->key = 5;\n\n\tm = bpf_obj_new(typeof(*m));\n\tif (!m) {\n\t\tbpf_obj_drop(n);\n\t\treturn 2;\n\t}\n\tm->key = 1;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\tbpf_rbtree_add(&groot, &m->node, less);\n\tbpf_spin_unlock(&glock);\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 3;\n\tn->key = 3;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\tbpf_spin_unlock(&glock);\n\treturn 0;\n}\n\nSEC(\"tc\")\nlong rbtree_add_nodes(void *ctx)\n{\n\treturn __add_three(&groot, &glock);\n}\n\nSEC(\"tc\")\nlong rbtree_add_and_remove(void *ctx)\n{\n\tstruct bpf_rb_node *res = NULL;\n\tstruct node_data *n, *m = NULL;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\tgoto err_out;\n\tn->key = 5;\n\n\tm = bpf_obj_new(typeof(*m));\n\tif (!m)\n\t\tgoto err_out;\n\tm->key = 3;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\tbpf_rbtree_add(&groot, &m->node, less);\n\tres = bpf_rbtree_remove(&groot, &n->node);\n\tbpf_spin_unlock(&glock);\n\n\tif (!res)\n\t\treturn 1;\n\n\tn = container_of(res, struct node_data, node);\n\tremoved_key = n->key;\n\tbpf_obj_drop(n);\n\n\treturn 0;\nerr_out:\n\tif (n)\n\t\tbpf_obj_drop(n);\n\tif (m)\n\t\tbpf_obj_drop(m);\n\treturn 1;\n}\n\nSEC(\"tc\")\nlong rbtree_first_and_remove(void *ctx)\n{\n\tstruct bpf_rb_node *res = NULL;\n\tstruct node_data *n, *m, *o;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\tn->key = 3;\n\tn->data = 4;\n\n\tm = bpf_obj_new(typeof(*m));\n\tif (!m)\n\t\tgoto err_out;\n\tm->key = 5;\n\tm->data = 6;\n\n\to = bpf_obj_new(typeof(*o));\n\tif (!o)\n\t\tgoto err_out;\n\to->key = 1;\n\to->data = 2;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\tbpf_rbtree_add(&groot, &m->node, less);\n\tbpf_rbtree_add(&groot, &o->node, less);\n\n\tres = bpf_rbtree_first(&groot);\n\tif (!res) {\n\t\tbpf_spin_unlock(&glock);\n\t\treturn 2;\n\t}\n\n\to = container_of(res, struct node_data, node);\n\tfirst_data[0] = o->data;\n\n\tres = bpf_rbtree_remove(&groot, &o->node);\n\tbpf_spin_unlock(&glock);\n\n\tif (!res)\n\t\treturn 5;\n\n\to = container_of(res, struct node_data, node);\n\tremoved_key = o->key;\n\tbpf_obj_drop(o);\n\n\tbpf_spin_lock(&glock);\n\tres = bpf_rbtree_first(&groot);\n\tif (!res) {\n\t\tbpf_spin_unlock(&glock);\n\t\treturn 3;\n\t}\n\n\to = container_of(res, struct node_data, node);\n\tfirst_data[1] = o->data;\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\nerr_out:\n\tif (n)\n\t\tbpf_obj_drop(n);\n\tif (m)\n\t\tbpf_obj_drop(m);\n\treturn 1;\n}\n\nSEC(\"tc\")\nlong rbtree_api_release_aliasing(void *ctx)\n{\n\tstruct node_data *n, *m, *o;\n\tstruct bpf_rb_node *res, *res2;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\tn->key = 41;\n\tn->data = 42;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\tbpf_spin_unlock(&glock);\n\n\tbpf_spin_lock(&glock);\n\n\t \n\tres = bpf_rbtree_first(&groot);\n\tif (!res)\n\t\tgoto err_out;\n\to = container_of(res, struct node_data, node);\n\n\tres = bpf_rbtree_first(&groot);\n\tif (!res)\n\t\tgoto err_out;\n\tm = container_of(res, struct node_data, node);\n\n\tres = bpf_rbtree_remove(&groot, &m->node);\n\t \n\tres2 = bpf_rbtree_remove(&groot, &o->node);\n\n\tbpf_spin_unlock(&glock);\n\n\tif (res) {\n\t\to = container_of(res, struct node_data, node);\n\t\tfirst_data[0] = o->data;\n\t\tbpf_obj_drop(o);\n\t}\n\tif (res2) {\n\t\t \n\t\tm = container_of(res2, struct node_data, node);\n\t\tfirst_data[1] = m->data;\n\t\tbpf_obj_drop(m);\n\t}\n\treturn 0;\n\nerr_out:\n\tbpf_spin_unlock(&glock);\n\treturn 1;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}