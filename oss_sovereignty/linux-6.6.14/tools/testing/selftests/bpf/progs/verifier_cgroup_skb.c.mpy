{
  "module_name": "verifier_cgroup_skb.c",
  "hash_id": "2223ede73308ca5c71c7bcd237bfa3d50048d72ac71de54d7fb6186ff855b803",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_cgroup_skb.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nSEC(\"cgroup/skb\")\n__description(\"direct packet read test#1 for CGROUP_SKB\")\n__success __failure_unpriv\n__msg_unpriv(\"invalid bpf_context access off=76 size=4\")\n__retval(0)\n__naked void test_1_for_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__sk_buff_data]);\t\t\\\n\tr3 = *(u32*)(r1 + %[__sk_buff_data_end]);\t\\\n\tr4 = *(u32*)(r1 + %[__sk_buff_len]);\t\t\\\n\tr5 = *(u32*)(r1 + %[__sk_buff_pkt_type]);\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_mark]);\t\t\\\n\t*(u32*)(r1 + %[__sk_buff_mark]) = r6;\t\t\\\n\tr7 = *(u32*)(r1 + %[__sk_buff_queue_mapping]);\t\\\n\tr8 = *(u32*)(r1 + %[__sk_buff_protocol]);\t\\\n\tr9 = *(u32*)(r1 + %[__sk_buff_vlan_present]);\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\tr0 += 8;\t\t\t\t\t\\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\tr0 = *(u8*)(r2 + 0);\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_data, offsetof(struct __sk_buff, data)),\n\t  __imm_const(__sk_buff_data_end, offsetof(struct __sk_buff, data_end)),\n\t  __imm_const(__sk_buff_len, offsetof(struct __sk_buff, len)),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark)),\n\t  __imm_const(__sk_buff_pkt_type, offsetof(struct __sk_buff, pkt_type)),\n\t  __imm_const(__sk_buff_protocol, offsetof(struct __sk_buff, protocol)),\n\t  __imm_const(__sk_buff_queue_mapping, offsetof(struct __sk_buff, queue_mapping)),\n\t  __imm_const(__sk_buff_vlan_present, offsetof(struct __sk_buff, vlan_present))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"direct packet read test#2 for CGROUP_SKB\")\n__success __success_unpriv __retval(0)\n__naked void test_2_for_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr4 = *(u32*)(r1 + %[__sk_buff_vlan_tci]);\t\\\n\tr5 = *(u32*)(r1 + %[__sk_buff_vlan_proto]);\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_priority]);\t\\\n\t*(u32*)(r1 + %[__sk_buff_priority]) = r6;\t\\\n\tr7 = *(u32*)(r1 + %[__sk_buff_ingress_ifindex]);\\\n\tr8 = *(u32*)(r1 + %[__sk_buff_tc_index]);\t\\\n\tr9 = *(u32*)(r1 + %[__sk_buff_hash]);\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_hash, offsetof(struct __sk_buff, hash)),\n\t  __imm_const(__sk_buff_ingress_ifindex, offsetof(struct __sk_buff, ingress_ifindex)),\n\t  __imm_const(__sk_buff_priority, offsetof(struct __sk_buff, priority)),\n\t  __imm_const(__sk_buff_tc_index, offsetof(struct __sk_buff, tc_index)),\n\t  __imm_const(__sk_buff_vlan_proto, offsetof(struct __sk_buff, vlan_proto)),\n\t  __imm_const(__sk_buff_vlan_tci, offsetof(struct __sk_buff, vlan_tci))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"direct packet read test#3 for CGROUP_SKB\")\n__success __success_unpriv __retval(0)\n__naked void test_3_for_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr4 = *(u32*)(r1 + %[__sk_buff_cb_0]);\t\t\\\n\tr5 = *(u32*)(r1 + %[__sk_buff_cb_1]);\t\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_cb_2]);\t\t\\\n\tr7 = *(u32*)(r1 + %[__sk_buff_cb_3]);\t\t\\\n\tr8 = *(u32*)(r1 + %[__sk_buff_cb_4]);\t\t\\\n\tr9 = *(u32*)(r1 + %[__sk_buff_napi_id]);\t\\\n\t*(u32*)(r1 + %[__sk_buff_cb_0]) = r4;\t\t\\\n\t*(u32*)(r1 + %[__sk_buff_cb_1]) = r5;\t\t\\\n\t*(u32*)(r1 + %[__sk_buff_cb_2]) = r6;\t\t\\\n\t*(u32*)(r1 + %[__sk_buff_cb_3]) = r7;\t\t\\\n\t*(u32*)(r1 + %[__sk_buff_cb_4]) = r8;\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_cb_0, offsetof(struct __sk_buff, cb[0])),\n\t  __imm_const(__sk_buff_cb_1, offsetof(struct __sk_buff, cb[1])),\n\t  __imm_const(__sk_buff_cb_2, offsetof(struct __sk_buff, cb[2])),\n\t  __imm_const(__sk_buff_cb_3, offsetof(struct __sk_buff, cb[3])),\n\t  __imm_const(__sk_buff_cb_4, offsetof(struct __sk_buff, cb[4])),\n\t  __imm_const(__sk_buff_napi_id, offsetof(struct __sk_buff, napi_id))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"direct packet read test#4 for CGROUP_SKB\")\n__success __success_unpriv __retval(0)\n__naked void test_4_for_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__sk_buff_family]);\t\t\\\n\tr3 = *(u32*)(r1 + %[__sk_buff_remote_ip4]);\t\\\n\tr4 = *(u32*)(r1 + %[__sk_buff_local_ip4]);\t\\\n\tr5 = *(u32*)(r1 + %[__sk_buff_remote_ip6_0]);\t\\\n\tr5 = *(u32*)(r1 + %[__sk_buff_remote_ip6_1]);\t\\\n\tr5 = *(u32*)(r1 + %[__sk_buff_remote_ip6_2]);\t\\\n\tr5 = *(u32*)(r1 + %[__sk_buff_remote_ip6_3]);\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_local_ip6_0]);\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_local_ip6_1]);\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_local_ip6_2]);\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_local_ip6_3]);\t\\\n\tr7 = *(u32*)(r1 + %[__sk_buff_remote_port]);\t\\\n\tr8 = *(u32*)(r1 + %[__sk_buff_local_port]);\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_family, offsetof(struct __sk_buff, family)),\n\t  __imm_const(__sk_buff_local_ip4, offsetof(struct __sk_buff, local_ip4)),\n\t  __imm_const(__sk_buff_local_ip6_0, offsetof(struct __sk_buff, local_ip6[0])),\n\t  __imm_const(__sk_buff_local_ip6_1, offsetof(struct __sk_buff, local_ip6[1])),\n\t  __imm_const(__sk_buff_local_ip6_2, offsetof(struct __sk_buff, local_ip6[2])),\n\t  __imm_const(__sk_buff_local_ip6_3, offsetof(struct __sk_buff, local_ip6[3])),\n\t  __imm_const(__sk_buff_local_port, offsetof(struct __sk_buff, local_port)),\n\t  __imm_const(__sk_buff_remote_ip4, offsetof(struct __sk_buff, remote_ip4)),\n\t  __imm_const(__sk_buff_remote_ip6_0, offsetof(struct __sk_buff, remote_ip6[0])),\n\t  __imm_const(__sk_buff_remote_ip6_1, offsetof(struct __sk_buff, remote_ip6[1])),\n\t  __imm_const(__sk_buff_remote_ip6_2, offsetof(struct __sk_buff, remote_ip6[2])),\n\t  __imm_const(__sk_buff_remote_ip6_3, offsetof(struct __sk_buff, remote_ip6[3])),\n\t  __imm_const(__sk_buff_remote_port, offsetof(struct __sk_buff, remote_port))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid access of tc_classid for CGROUP_SKB\")\n__failure __msg(\"invalid bpf_context access\")\n__failure_unpriv\n__naked void tc_classid_for_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[__sk_buff_tc_classid]);\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_tc_classid, offsetof(struct __sk_buff, tc_classid))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid access of data_meta for CGROUP_SKB\")\n__failure __msg(\"invalid bpf_context access\")\n__failure_unpriv\n__naked void data_meta_for_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[__sk_buff_data_meta]);\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_data_meta, offsetof(struct __sk_buff, data_meta))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid access of flow_keys for CGROUP_SKB\")\n__failure __msg(\"invalid bpf_context access\")\n__failure_unpriv\n__naked void flow_keys_for_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[__sk_buff_flow_keys]);\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_flow_keys, offsetof(struct __sk_buff, flow_keys))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"invalid write access to napi_id for CGROUP_SKB\")\n__failure __msg(\"invalid bpf_context access\")\n__failure_unpriv\n__naked void napi_id_for_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr9 = *(u32*)(r1 + %[__sk_buff_napi_id]);\t\\\n\t*(u32*)(r1 + %[__sk_buff_napi_id]) = r9;\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_napi_id, offsetof(struct __sk_buff, napi_id))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"write tstamp from CGROUP_SKB\")\n__success __failure_unpriv\n__msg_unpriv(\"invalid bpf_context access off=152 size=8\")\n__retval(0)\n__naked void write_tstamp_from_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r1 + %[__sk_buff_tstamp]) = r0;\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_tstamp, offsetof(struct __sk_buff, tstamp))\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"read tstamp from CGROUP_SKB\")\n__success __success_unpriv __retval(0)\n__naked void read_tstamp_from_cgroup_skb(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u64*)(r1 + %[__sk_buff_tstamp]);\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__sk_buff_tstamp, offsetof(struct __sk_buff, tstamp))\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}