{
  "module_name": "test_tcp_hdr_options.c",
  "hash_id": "6bbdfa48c58521a5b4adb303739fdf2819a15878cf5980986196f73e1cae8bac",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tcp_hdr_options.c",
  "human_readable_source": "\n \n\n#include <stddef.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <linux/tcp.h>\n#include <linux/socket.h>\n#include <linux/bpf.h>\n#include <linux/types.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#define BPF_PROG_TEST_TCP_HDR_OPTIONS\n#include \"test_tcp_hdr_options.h\"\n\n#ifndef sizeof_field\n#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))\n#endif\n\n__u8 test_kind = TCPOPT_EXP;\n__u16 test_magic = 0xeB9F;\n__u32 inherit_cb_flags = 0;\n\nstruct bpf_test_option passive_synack_out = {};\nstruct bpf_test_option passive_fin_out\t= {};\n\nstruct bpf_test_option passive_estab_in = {};\nstruct bpf_test_option passive_fin_in\t= {};\n\nstruct bpf_test_option active_syn_out\t= {};\nstruct bpf_test_option active_fin_out\t= {};\n\nstruct bpf_test_option active_estab_in\t= {};\nstruct bpf_test_option active_fin_in\t= {};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct hdr_stg);\n} hdr_stg_map SEC(\".maps\");\n\nstatic bool skops_want_cookie(const struct bpf_sock_ops *skops)\n{\n\treturn skops->args[0] == BPF_WRITE_HDR_TCP_SYNACK_COOKIE;\n}\n\nstatic bool skops_current_mss(const struct bpf_sock_ops *skops)\n{\n\treturn skops->args[0] == BPF_WRITE_HDR_TCP_CURRENT_MSS;\n}\n\nstatic __u8 option_total_len(__u8 flags)\n{\n\t__u8 i, len = 1;  \n\n\tif (!flags)\n\t\treturn 0;\n\n\t \n\tfor (i = OPTION_RESEND + 1; i < __NR_OPTION_FLAGS; i++)\n\t\tlen += !!TEST_OPTION_FLAGS(flags, i);\n\n\tif (test_kind == TCPOPT_EXP)\n\t\treturn len + TCP_BPF_EXPOPT_BASE_LEN;\n\telse\n\t\treturn len + 2;  \n}\n\nstatic void write_test_option(const struct bpf_test_option *test_opt,\n\t\t\t      __u8 *data)\n{\n\t__u8 offset = 0;\n\n\tdata[offset++] = test_opt->flags;\n\tif (TEST_OPTION_FLAGS(test_opt->flags, OPTION_MAX_DELACK_MS))\n\t\tdata[offset++] = test_opt->max_delack_ms;\n\n\tif (TEST_OPTION_FLAGS(test_opt->flags, OPTION_RAND))\n\t\tdata[offset++] = test_opt->rand;\n}\n\nstatic int store_option(struct bpf_sock_ops *skops,\n\t\t\tconst struct bpf_test_option *test_opt)\n{\n\tunion {\n\t\tstruct tcp_exprm_opt exprm;\n\t\tstruct tcp_opt regular;\n\t} write_opt;\n\tint err;\n\n\tif (test_kind == TCPOPT_EXP) {\n\t\twrite_opt.exprm.kind = TCPOPT_EXP;\n\t\twrite_opt.exprm.len = option_total_len(test_opt->flags);\n\t\twrite_opt.exprm.magic = __bpf_htons(test_magic);\n\t\twrite_opt.exprm.data32 = 0;\n\t\twrite_test_option(test_opt, write_opt.exprm.data);\n\t\terr = bpf_store_hdr_opt(skops, &write_opt.exprm,\n\t\t\t\t\tsizeof(write_opt.exprm), 0);\n\t} else {\n\t\twrite_opt.regular.kind = test_kind;\n\t\twrite_opt.regular.len = option_total_len(test_opt->flags);\n\t\twrite_opt.regular.data32 = 0;\n\t\twrite_test_option(test_opt, write_opt.regular.data);\n\t\terr = bpf_store_hdr_opt(skops, &write_opt.regular,\n\t\t\t\t\tsizeof(write_opt.regular), 0);\n\t}\n\n\tif (err)\n\t\tRET_CG_ERR(err);\n\n\treturn CG_OK;\n}\n\nstatic int parse_test_option(struct bpf_test_option *opt, const __u8 *start)\n{\n\topt->flags = *start++;\n\n\tif (TEST_OPTION_FLAGS(opt->flags, OPTION_MAX_DELACK_MS))\n\t\topt->max_delack_ms = *start++;\n\n\tif (TEST_OPTION_FLAGS(opt->flags, OPTION_RAND))\n\t\topt->rand = *start++;\n\n\treturn 0;\n}\n\nstatic int load_option(struct bpf_sock_ops *skops,\n\t\t       struct bpf_test_option *test_opt, bool from_syn)\n{\n\tunion {\n\t\tstruct tcp_exprm_opt exprm;\n\t\tstruct tcp_opt regular;\n\t} search_opt;\n\tint ret, load_flags = from_syn ? BPF_LOAD_HDR_OPT_TCP_SYN : 0;\n\n\tif (test_kind == TCPOPT_EXP) {\n\t\tsearch_opt.exprm.kind = TCPOPT_EXP;\n\t\tsearch_opt.exprm.len = 4;\n\t\tsearch_opt.exprm.magic = __bpf_htons(test_magic);\n\t\tsearch_opt.exprm.data32 = 0;\n\t\tret = bpf_load_hdr_opt(skops, &search_opt.exprm,\n\t\t\t\t       sizeof(search_opt.exprm), load_flags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn parse_test_option(test_opt, search_opt.exprm.data);\n\t} else {\n\t\tsearch_opt.regular.kind = test_kind;\n\t\tsearch_opt.regular.len = 0;\n\t\tsearch_opt.regular.data32 = 0;\n\t\tret = bpf_load_hdr_opt(skops, &search_opt.regular,\n\t\t\t\t       sizeof(search_opt.regular), load_flags);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn parse_test_option(test_opt, search_opt.regular.data);\n\t}\n}\n\nstatic int synack_opt_len(struct bpf_sock_ops *skops)\n{\n\tstruct bpf_test_option test_opt = {};\n\t__u8 optlen;\n\tint err;\n\n\tif (!passive_synack_out.flags)\n\t\treturn CG_OK;\n\n\terr = load_option(skops, &test_opt, true);\n\n\t \n\tif (err == -ENOMSG)\n\t\treturn CG_OK;\n\n\tif (err)\n\t\tRET_CG_ERR(err);\n\n\toptlen = option_total_len(passive_synack_out.flags);\n\tif (optlen) {\n\t\terr = bpf_reserve_hdr_opt(skops, optlen, 0);\n\t\tif (err)\n\t\t\tRET_CG_ERR(err);\n\t}\n\n\treturn CG_OK;\n}\n\nstatic int write_synack_opt(struct bpf_sock_ops *skops)\n{\n\tstruct bpf_test_option opt;\n\n\tif (!passive_synack_out.flags)\n\t\t \n\t\tRET_CG_ERR(0);\n\n\topt = passive_synack_out;\n\tif (skops_want_cookie(skops))\n\t\tSET_OPTION_FLAGS(opt.flags, OPTION_RESEND);\n\n\treturn store_option(skops, &opt);\n}\n\nstatic int syn_opt_len(struct bpf_sock_ops *skops)\n{\n\t__u8 optlen;\n\tint err;\n\n\tif (!active_syn_out.flags)\n\t\treturn CG_OK;\n\n\toptlen = option_total_len(active_syn_out.flags);\n\tif (optlen) {\n\t\terr = bpf_reserve_hdr_opt(skops, optlen, 0);\n\t\tif (err)\n\t\t\tRET_CG_ERR(err);\n\t}\n\n\treturn CG_OK;\n}\n\nstatic int write_syn_opt(struct bpf_sock_ops *skops)\n{\n\tif (!active_syn_out.flags)\n\t\tRET_CG_ERR(0);\n\n\treturn store_option(skops, &active_syn_out);\n}\n\nstatic int fin_opt_len(struct bpf_sock_ops *skops)\n{\n\tstruct bpf_test_option *opt;\n\tstruct hdr_stg *hdr_stg;\n\t__u8 optlen;\n\tint err;\n\n\tif (!skops->sk)\n\t\tRET_CG_ERR(0);\n\n\thdr_stg = bpf_sk_storage_get(&hdr_stg_map, skops->sk, NULL, 0);\n\tif (!hdr_stg)\n\t\tRET_CG_ERR(0);\n\n\tif (hdr_stg->active)\n\t\topt = &active_fin_out;\n\telse\n\t\topt = &passive_fin_out;\n\n\toptlen = option_total_len(opt->flags);\n\tif (optlen) {\n\t\terr = bpf_reserve_hdr_opt(skops, optlen, 0);\n\t\tif (err)\n\t\t\tRET_CG_ERR(err);\n\t}\n\n\treturn CG_OK;\n}\n\nstatic int write_fin_opt(struct bpf_sock_ops *skops)\n{\n\tstruct bpf_test_option *opt;\n\tstruct hdr_stg *hdr_stg;\n\n\tif (!skops->sk)\n\t\tRET_CG_ERR(0);\n\n\thdr_stg = bpf_sk_storage_get(&hdr_stg_map, skops->sk, NULL, 0);\n\tif (!hdr_stg)\n\t\tRET_CG_ERR(0);\n\n\tif (hdr_stg->active)\n\t\topt = &active_fin_out;\n\telse\n\t\topt = &passive_fin_out;\n\n\tif (!opt->flags)\n\t\tRET_CG_ERR(0);\n\n\treturn store_option(skops, opt);\n}\n\nstatic int resend_in_ack(struct bpf_sock_ops *skops)\n{\n\tstruct hdr_stg *hdr_stg;\n\n\tif (!skops->sk)\n\t\treturn -1;\n\n\thdr_stg = bpf_sk_storage_get(&hdr_stg_map, skops->sk, NULL, 0);\n\tif (!hdr_stg)\n\t\treturn -1;\n\n\treturn !!hdr_stg->resend_syn;\n}\n\nstatic int nodata_opt_len(struct bpf_sock_ops *skops)\n{\n\tint resend;\n\n\tresend = resend_in_ack(skops);\n\tif (resend < 0)\n\t\tRET_CG_ERR(0);\n\n\tif (resend)\n\t\treturn syn_opt_len(skops);\n\n\treturn CG_OK;\n}\n\nstatic int write_nodata_opt(struct bpf_sock_ops *skops)\n{\n\tint resend;\n\n\tresend = resend_in_ack(skops);\n\tif (resend < 0)\n\t\tRET_CG_ERR(0);\n\n\tif (resend)\n\t\treturn write_syn_opt(skops);\n\n\treturn CG_OK;\n}\n\nstatic int data_opt_len(struct bpf_sock_ops *skops)\n{\n\t \n\treturn nodata_opt_len(skops);\n}\n\nstatic int write_data_opt(struct bpf_sock_ops *skops)\n{\n\treturn write_nodata_opt(skops);\n}\n\nstatic int current_mss_opt_len(struct bpf_sock_ops *skops)\n{\n\t \n\tint err;\n\n\terr = bpf_reserve_hdr_opt(skops, option_total_len(OPTION_MASK), 0);\n\tif (err)\n\t\tRET_CG_ERR(err);\n\n\treturn CG_OK;\n}\n\nstatic int handle_hdr_opt_len(struct bpf_sock_ops *skops)\n{\n\t__u8 tcp_flags = skops_tcp_flags(skops);\n\n\tif ((tcp_flags & TCPHDR_SYNACK) == TCPHDR_SYNACK)\n\t\treturn synack_opt_len(skops);\n\n\tif (tcp_flags & TCPHDR_SYN)\n\t\treturn syn_opt_len(skops);\n\n\tif (tcp_flags & TCPHDR_FIN)\n\t\treturn fin_opt_len(skops);\n\n\tif (skops_current_mss(skops))\n\t\t \n\t\treturn current_mss_opt_len(skops);\n\n\tif (skops->skb_len)\n\t\treturn data_opt_len(skops);\n\n\treturn nodata_opt_len(skops);\n}\n\nstatic int handle_write_hdr_opt(struct bpf_sock_ops *skops)\n{\n\t__u8 tcp_flags = skops_tcp_flags(skops);\n\tstruct tcphdr *th;\n\n\tif ((tcp_flags & TCPHDR_SYNACK) == TCPHDR_SYNACK)\n\t\treturn write_synack_opt(skops);\n\n\tif (tcp_flags & TCPHDR_SYN)\n\t\treturn write_syn_opt(skops);\n\n\tif (tcp_flags & TCPHDR_FIN)\n\t\treturn write_fin_opt(skops);\n\n\tth = skops->skb_data;\n\tif (th + 1 > skops->skb_data_end)\n\t\tRET_CG_ERR(0);\n\n\tif (skops->skb_len > tcp_hdrlen(th))\n\t\treturn write_data_opt(skops);\n\n\treturn write_nodata_opt(skops);\n}\n\nstatic int set_delack_max(struct bpf_sock_ops *skops, __u8 max_delack_ms)\n{\n\t__u32 max_delack_us = max_delack_ms * 1000;\n\n\treturn bpf_setsockopt(skops, SOL_TCP, TCP_BPF_DELACK_MAX,\n\t\t\t      &max_delack_us, sizeof(max_delack_us));\n}\n\nstatic int set_rto_min(struct bpf_sock_ops *skops, __u8 peer_max_delack_ms)\n{\n\t__u32 min_rto_us = peer_max_delack_ms * 1000;\n\n\treturn bpf_setsockopt(skops, SOL_TCP, TCP_BPF_RTO_MIN, &min_rto_us,\n\t\t\t      sizeof(min_rto_us));\n}\n\nstatic int handle_active_estab(struct bpf_sock_ops *skops)\n{\n\tstruct hdr_stg init_stg = {\n\t\t.active = true,\n\t};\n\tint err;\n\n\terr = load_option(skops, &active_estab_in, false);\n\tif (err && err != -ENOMSG)\n\t\tRET_CG_ERR(err);\n\n\tinit_stg.resend_syn = TEST_OPTION_FLAGS(active_estab_in.flags,\n\t\t\t\t\t\tOPTION_RESEND);\n\tif (!skops->sk || !bpf_sk_storage_get(&hdr_stg_map, skops->sk,\n\t\t\t\t\t      &init_stg,\n\t\t\t\t\t      BPF_SK_STORAGE_GET_F_CREATE))\n\t\tRET_CG_ERR(0);\n\n\tif (init_stg.resend_syn)\n\t\t \n\t\tset_parse_all_hdr_cb_flags(skops);\n\telse if (!active_fin_out.flags)\n\t\t \n\t\tclear_hdr_cb_flags(skops);\n\n\tif (active_syn_out.max_delack_ms) {\n\t\terr = set_delack_max(skops, active_syn_out.max_delack_ms);\n\t\tif (err)\n\t\t\tRET_CG_ERR(err);\n\t}\n\n\tif (active_estab_in.max_delack_ms) {\n\t\terr = set_rto_min(skops, active_estab_in.max_delack_ms);\n\t\tif (err)\n\t\t\tRET_CG_ERR(err);\n\t}\n\n\treturn CG_OK;\n}\n\nstatic int handle_passive_estab(struct bpf_sock_ops *skops)\n{\n\tstruct hdr_stg init_stg = {};\n\tstruct tcphdr *th;\n\tint err;\n\n\tinherit_cb_flags = skops->bpf_sock_ops_cb_flags;\n\n\terr = load_option(skops, &passive_estab_in, true);\n\tif (err == -ENOENT) {\n\t\t \n\t\terr = load_option(skops, &passive_estab_in, false);\n\t\tinit_stg.syncookie = true;\n\t}\n\n\t \n\tif (err && err != -ENOMSG)\n\t\tRET_CG_ERR(err);\n\n\tth = skops->skb_data;\n\tif (th + 1 > skops->skb_data_end)\n\t\tRET_CG_ERR(0);\n\n\tif (th->syn) {\n\t\t \n\n\t\t \n\t\tset_parse_all_hdr_cb_flags(skops);\n\t\tinit_stg.fastopen = true;\n\t} else if (!passive_fin_out.flags) {\n\t\t \n\t\tclear_hdr_cb_flags(skops);\n\t}\n\n\tif (!skops->sk ||\n\t    !bpf_sk_storage_get(&hdr_stg_map, skops->sk, &init_stg,\n\t\t\t\tBPF_SK_STORAGE_GET_F_CREATE))\n\t\tRET_CG_ERR(0);\n\n\tif (passive_synack_out.max_delack_ms) {\n\t\terr = set_delack_max(skops, passive_synack_out.max_delack_ms);\n\t\tif (err)\n\t\t\tRET_CG_ERR(err);\n\t}\n\n\tif (passive_estab_in.max_delack_ms) {\n\t\terr = set_rto_min(skops, passive_estab_in.max_delack_ms);\n\t\tif (err)\n\t\t\tRET_CG_ERR(err);\n\t}\n\n\treturn CG_OK;\n}\n\nstatic int handle_parse_hdr(struct bpf_sock_ops *skops)\n{\n\tstruct hdr_stg *hdr_stg;\n\tstruct tcphdr *th;\n\n\tif (!skops->sk)\n\t\tRET_CG_ERR(0);\n\n\tth = skops->skb_data;\n\tif (th + 1 > skops->skb_data_end)\n\t\tRET_CG_ERR(0);\n\n\thdr_stg = bpf_sk_storage_get(&hdr_stg_map, skops->sk, NULL, 0);\n\tif (!hdr_stg)\n\t\tRET_CG_ERR(0);\n\n\tif (hdr_stg->resend_syn || hdr_stg->fastopen)\n\t\t \n\t\tclear_parse_all_hdr_cb_flags(skops);\n\n\tif (hdr_stg->resend_syn && !active_fin_out.flags)\n\t\t \n\t\tclear_hdr_cb_flags(skops);\n\n\tif (hdr_stg->fastopen && !passive_fin_out.flags)\n\t\t \n\t\tclear_hdr_cb_flags(skops);\n\n\tif (th->fin) {\n\t\tstruct bpf_test_option *fin_opt;\n\t\tint err;\n\n\t\tif (hdr_stg->active)\n\t\t\tfin_opt = &active_fin_in;\n\t\telse\n\t\t\tfin_opt = &passive_fin_in;\n\n\t\terr = load_option(skops, fin_opt, false);\n\t\tif (err && err != -ENOMSG)\n\t\t\tRET_CG_ERR(err);\n\t}\n\n\treturn CG_OK;\n}\n\nSEC(\"sockops\")\nint estab(struct bpf_sock_ops *skops)\n{\n\tint true_val = 1;\n\n\tswitch (skops->op) {\n\tcase BPF_SOCK_OPS_TCP_LISTEN_CB:\n\t\tbpf_setsockopt(skops, SOL_TCP, TCP_SAVE_SYN,\n\t\t\t       &true_val, sizeof(true_val));\n\t\tset_hdr_cb_flags(skops, BPF_SOCK_OPS_STATE_CB_FLAG);\n\t\tbreak;\n\tcase BPF_SOCK_OPS_TCP_CONNECT_CB:\n\t\tset_hdr_cb_flags(skops, 0);\n\t\tbreak;\n\tcase BPF_SOCK_OPS_PARSE_HDR_OPT_CB:\n\t\treturn handle_parse_hdr(skops);\n\tcase BPF_SOCK_OPS_HDR_OPT_LEN_CB:\n\t\treturn handle_hdr_opt_len(skops);\n\tcase BPF_SOCK_OPS_WRITE_HDR_OPT_CB:\n\t\treturn handle_write_hdr_opt(skops);\n\tcase BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB:\n\t\treturn handle_passive_estab(skops);\n\tcase BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:\n\t\treturn handle_active_estab(skops);\n\t}\n\n\treturn CG_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}