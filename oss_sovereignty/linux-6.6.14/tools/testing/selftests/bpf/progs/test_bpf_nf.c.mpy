{
  "module_name": "test_bpf_nf.c",
  "hash_id": "839802cd6db4f058405285581db4b52b0dc3498fdff1d520b0ee1f808908fdb0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_bpf_nf.c",
  "human_readable_source": "\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#define EAFNOSUPPORT 97\n#define EPROTO 71\n#define ENONET 64\n#define EINVAL 22\n#define ENOENT 2\n\nextern unsigned long CONFIG_HZ __kconfig;\n\nint test_einval_bpf_tuple = 0;\nint test_einval_reserved = 0;\nint test_einval_netns_id = 0;\nint test_einval_len_opts = 0;\nint test_eproto_l4proto = 0;\nint test_enonet_netns_id = 0;\nint test_enoent_lookup = 0;\nint test_eafnosupport = 0;\nint test_alloc_entry = -EINVAL;\nint test_insert_entry = -EAFNOSUPPORT;\nint test_succ_lookup = -ENOENT;\nu32 test_delta_timeout = 0;\nu32 test_status = 0;\nu32 test_insert_lookup_mark = 0;\nint test_snat_addr = -EINVAL;\nint test_dnat_addr = -EINVAL;\n__be32 saddr = 0;\n__be16 sport = 0;\n__be32 daddr = 0;\n__be16 dport = 0;\nint test_exist_lookup = -ENOENT;\nu32 test_exist_lookup_mark = 0;\n\nenum nf_nat_manip_type___local {\n\tNF_NAT_MANIP_SRC___local,\n\tNF_NAT_MANIP_DST___local\n};\n\nstruct nf_conn;\n\nstruct bpf_ct_opts___local {\n\ts32 netns_id;\n\ts32 error;\n\tu8 l4proto;\n\tu8 reserved[3];\n} __attribute__((preserve_access_index));\n\nstruct nf_conn *bpf_xdp_ct_alloc(struct xdp_md *, struct bpf_sock_tuple *, u32,\n\t\t\t\t struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_xdp_ct_lookup(struct xdp_md *, struct bpf_sock_tuple *, u32,\n\t\t\t\t  struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_skb_ct_alloc(struct __sk_buff *, struct bpf_sock_tuple *, u32,\n\t\t\t\t struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_skb_ct_lookup(struct __sk_buff *, struct bpf_sock_tuple *, u32,\n\t\t\t\t  struct bpf_ct_opts___local *, u32) __ksym;\nstruct nf_conn *bpf_ct_insert_entry(struct nf_conn *) __ksym;\nvoid bpf_ct_release(struct nf_conn *) __ksym;\nvoid bpf_ct_set_timeout(struct nf_conn *, u32) __ksym;\nint bpf_ct_change_timeout(struct nf_conn *, u32) __ksym;\nint bpf_ct_set_status(struct nf_conn *, u32) __ksym;\nint bpf_ct_change_status(struct nf_conn *, u32) __ksym;\nint bpf_ct_set_nat_info(struct nf_conn *, union nf_inet_addr *,\n\t\t\tint port, enum nf_nat_manip_type___local) __ksym;\n\nstatic __always_inline void\nnf_ct_test(struct nf_conn *(*lookup_fn)(void *, struct bpf_sock_tuple *, u32,\n\t\t\t\t\tstruct bpf_ct_opts___local *, u32),\n\t   struct nf_conn *(*alloc_fn)(void *, struct bpf_sock_tuple *, u32,\n\t\t\t\t       struct bpf_ct_opts___local *, u32),\n\t   void *ctx)\n{\n\tstruct bpf_ct_opts___local opts_def = { .l4proto = IPPROTO_TCP, .netns_id = -1 };\n\tstruct bpf_sock_tuple bpf_tuple;\n\tstruct nf_conn *ct;\n\n\t__builtin_memset(&bpf_tuple, 0, sizeof(bpf_tuple.ipv4));\n\n\tct = lookup_fn(ctx, NULL, 0, &opts_def, sizeof(opts_def));\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_einval_bpf_tuple = opts_def.error;\n\n\topts_def.reserved[0] = 1;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\topts_def.reserved[0] = 0;\n\topts_def.l4proto = IPPROTO_TCP;\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_einval_reserved = opts_def.error;\n\n\topts_def.netns_id = -2;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\topts_def.netns_id = -1;\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_einval_netns_id = opts_def.error;\n\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def) - 1);\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_einval_len_opts = opts_def.error;\n\n\topts_def.l4proto = IPPROTO_ICMP;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\topts_def.l4proto = IPPROTO_TCP;\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_eproto_l4proto = opts_def.error;\n\n\topts_def.netns_id = 0xf00f;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\topts_def.netns_id = -1;\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_enonet_netns_id = opts_def.error;\n\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_enoent_lookup = opts_def.error;\n\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4) - 1, &opts_def,\n\t\t       sizeof(opts_def));\n\tif (ct)\n\t\tbpf_ct_release(ct);\n\telse\n\t\ttest_eafnosupport = opts_def.error;\n\n\tbpf_tuple.ipv4.saddr = bpf_get_prandom_u32();  \n\tbpf_tuple.ipv4.daddr = bpf_get_prandom_u32();  \n\tbpf_tuple.ipv4.sport = bpf_get_prandom_u32();  \n\tbpf_tuple.ipv4.dport = bpf_get_prandom_u32();  \n\n\tct = alloc_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t      sizeof(opts_def));\n\tif (ct) {\n\t\t__u16 sport = bpf_get_prandom_u32();\n\t\t__u16 dport = bpf_get_prandom_u32();\n\t\tunion nf_inet_addr saddr = {};\n\t\tunion nf_inet_addr daddr = {};\n\t\tstruct nf_conn *ct_ins;\n\n\t\tbpf_ct_set_timeout(ct, 10000);\n\t\tct->mark = 77;\n\n\t\t \n\t\tsaddr.ip = bpf_get_prandom_u32();\n\t\tbpf_ct_set_nat_info(ct, &saddr, sport, NF_NAT_MANIP_SRC___local);\n\t\t \n\t\tdaddr.ip = bpf_get_prandom_u32();\n\t\tbpf_ct_set_nat_info(ct, &daddr, dport, NF_NAT_MANIP_DST___local);\n\n\t\tct_ins = bpf_ct_insert_entry(ct);\n\t\tif (ct_ins) {\n\t\t\tstruct nf_conn *ct_lk;\n\n\t\t\tct_lk = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4),\n\t\t\t\t\t  &opts_def, sizeof(opts_def));\n\t\t\tif (ct_lk) {\n\t\t\t\tstruct nf_conntrack_tuple *tuple;\n\n\t\t\t\t \n\t\t\t\ttuple = &ct_lk->tuplehash[IP_CT_DIR_REPLY].tuple;\n\t\t\t\tif (tuple->dst.u3.ip == saddr.ip &&\n\t\t\t\t    tuple->dst.u.all == bpf_htons(sport))\n\t\t\t\t\ttest_snat_addr = 0;\n\t\t\t\tif (tuple->src.u3.ip == daddr.ip &&\n\t\t\t\t    tuple->src.u.all == bpf_htons(dport))\n\t\t\t\t\ttest_dnat_addr = 0;\n\n\t\t\t\t \n\t\t\t\tbpf_ct_change_timeout(ct_lk, 10000);\n\t\t\t\ttest_delta_timeout = ct_lk->timeout - bpf_jiffies64();\n\t\t\t\ttest_delta_timeout /= CONFIG_HZ;\n\t\t\t\ttest_insert_lookup_mark = ct_lk->mark;\n\t\t\t\tbpf_ct_change_status(ct_lk,\n\t\t\t\t\t\t     IPS_CONFIRMED | IPS_SEEN_REPLY);\n\t\t\t\ttest_status = ct_lk->status;\n\n\t\t\t\tbpf_ct_release(ct_lk);\n\t\t\t\ttest_succ_lookup = 0;\n\t\t\t}\n\t\t\tbpf_ct_release(ct_ins);\n\t\t\ttest_insert_entry = 0;\n\t\t}\n\t\ttest_alloc_entry = 0;\n\t}\n\n\tbpf_tuple.ipv4.saddr = saddr;\n\tbpf_tuple.ipv4.daddr = daddr;\n\tbpf_tuple.ipv4.sport = sport;\n\tbpf_tuple.ipv4.dport = dport;\n\tct = lookup_fn(ctx, &bpf_tuple, sizeof(bpf_tuple.ipv4), &opts_def,\n\t\t       sizeof(opts_def));\n\tif (ct) {\n\t\ttest_exist_lookup = 0;\n\t\tif (ct->mark == 42) {\n\t\t\tct->mark++;\n\t\t\ttest_exist_lookup_mark = ct->mark;\n\t\t}\n\t\tbpf_ct_release(ct);\n\t} else {\n\t\ttest_exist_lookup = opts_def.error;\n\t}\n}\n\nSEC(\"xdp\")\nint nf_xdp_ct_test(struct xdp_md *ctx)\n{\n\tnf_ct_test((void *)bpf_xdp_ct_lookup, (void *)bpf_xdp_ct_alloc, ctx);\n\treturn 0;\n}\n\nSEC(\"tc\")\nint nf_skb_ct_test(struct __sk_buff *ctx)\n{\n\tnf_ct_test((void *)bpf_skb_ct_lookup, (void *)bpf_skb_ct_alloc, ctx);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}