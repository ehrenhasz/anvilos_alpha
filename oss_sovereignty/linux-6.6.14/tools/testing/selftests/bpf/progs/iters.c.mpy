{
  "module_name": "iters.c",
  "hash_id": "2e214367bc06a65db3a5e2e0b2018cc8fb3b0357feba466e49f7dda8fbf90947",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/iters.c",
  "human_readable_source": "\n \n\n#include <stdbool.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n\nstatic volatile int zero = 0;\n\nint my_pid;\nint arr[256];\nint small_arr[16] SEC(\".data.small_arr\");\n\n#ifdef REAL_TEST\n#define MY_PID_GUARD() if (my_pid != (bpf_get_current_pid_tgid() >> 32)) return 0\n#else\n#define MY_PID_GUARD() ({ })\n#endif\n\nSEC(\"?raw_tp\")\n__failure __msg(\"math between map_value pointer and register with unbounded min value is not allowed\")\nint iter_err_unsafe_c_loop(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint *v, i = zero;  \n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 0, 1000);\n\twhile ((v = bpf_iter_num_next(&it))) {\n\t\ti++;\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\tsmall_arr[i] = 123;  \n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"unbounded memory access\")\nint iter_err_unsafe_asm_loop(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\n\tMY_PID_GUARD();\n\n\tasm volatile (\n\t\t\"r6 = %[zero];\"  \n\t\t\"r1 = %[it];\"  \n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"r4 = 1;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\t\"loop:\"\n\t\t\"r1 = %[it];\"\n\t\t\"call %[bpf_iter_num_next];\"\n\t\t\"if r0 == 0 goto out;\"\n\t\t\"r6 += 1;\"\n\t\t\"goto loop;\"\n\t\"out:\"\n\t\t\"r1 = %[it];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t\"r1 = %[small_arr];\"\n\t\t\"r2 = r6;\"\n\t\t\"r2 <<= 2;\"\n\t\t\"r1 += r2;\"\n\t\t\"*(u32 *)(r1 + 0) = r6;\"  \n\t\t:\n\t\t: [it]\"r\"(&it),\n\t\t  [small_arr]\"p\"(small_arr),\n\t\t  [zero]\"p\"(zero),\n\t\t  __imm(bpf_iter_num_new),\n\t\t  __imm(bpf_iter_num_next),\n\t\t  __imm(bpf_iter_num_destroy)\n\t\t: __clobber_common, \"r6\"\n\t);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_while_loop(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint *v;\n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 0, 3);\n\twhile ((v = bpf_iter_num_next(&it))) {\n\t\tbpf_printk(\"ITER_BASIC: E1 VAL: v=%d\", *v);\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_while_loop_auto_cleanup(const void *ctx)\n{\n\t__attribute__((cleanup(bpf_iter_num_destroy))) struct bpf_iter_num it;\n\tint *v;\n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 0, 3);\n\twhile ((v = bpf_iter_num_next(&it))) {\n\t\tbpf_printk(\"ITER_BASIC: E1 VAL: v=%d\", *v);\n\t}\n\t \n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_for_loop(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint *v;\n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 5, 10);\n\tfor (v = bpf_iter_num_next(&it); v; v = bpf_iter_num_next(&it)) {\n\t\tbpf_printk(\"ITER_BASIC: E2 VAL: v=%d\", *v);\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_bpf_for_each_macro(const void *ctx)\n{\n\tint *v;\n\n\tMY_PID_GUARD();\n\n\tbpf_for_each(num, v, 5, 10) {\n\t\tbpf_printk(\"ITER_BASIC: E2 VAL: v=%d\", *v);\n\t}\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_bpf_for_macro(const void *ctx)\n{\n\tint i;\n\n\tMY_PID_GUARD();\n\n\tbpf_for(i, 5, 10) {\n\t\tbpf_printk(\"ITER_BASIC: E2 VAL: v=%d\", i);\n\t}\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_pragma_unroll_loop(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint *v, i;\n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 0, 2);\n#pragma nounroll\n\tfor (i = 0; i < 3; i++) {\n\t\tv = bpf_iter_num_next(&it);\n\t\tbpf_printk(\"ITER_BASIC: E3 VAL: i=%d v=%d\", i, v ? *v : -1);\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_manual_unroll_loop(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint *v;\n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 100, 200);\n\tv = bpf_iter_num_next(&it);\n\tbpf_printk(\"ITER_BASIC: E4 VAL: v=%d\", v ? *v : -1);\n\tv = bpf_iter_num_next(&it);\n\tbpf_printk(\"ITER_BASIC: E4 VAL: v=%d\", v ? *v : -1);\n\tv = bpf_iter_num_next(&it);\n\tbpf_printk(\"ITER_BASIC: E4 VAL: v=%d\", v ? *v : -1);\n\tv = bpf_iter_num_next(&it);\n\tbpf_printk(\"ITER_BASIC: E4 VAL: v=%d\\n\", v ? *v : -1);\n\tbpf_iter_num_destroy(&it);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_multiple_sequential_loops(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint *v, i;\n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 0, 3);\n\twhile ((v = bpf_iter_num_next(&it))) {\n\t\tbpf_printk(\"ITER_BASIC: E1 VAL: v=%d\", *v);\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\tbpf_iter_num_new(&it, 5, 10);\n\tfor (v = bpf_iter_num_next(&it); v; v = bpf_iter_num_next(&it)) {\n\t\tbpf_printk(\"ITER_BASIC: E2 VAL: v=%d\", *v);\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\tbpf_iter_num_new(&it, 0, 2);\n#pragma nounroll\n\tfor (i = 0; i < 3; i++) {\n\t\tv = bpf_iter_num_next(&it);\n\t\tbpf_printk(\"ITER_BASIC: E3 VAL: i=%d v=%d\", i, v ? *v : -1);\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\tbpf_iter_num_new(&it, 100, 200);\n\tv = bpf_iter_num_next(&it);\n\tbpf_printk(\"ITER_BASIC: E4 VAL: v=%d\", v ? *v : -1);\n\tv = bpf_iter_num_next(&it);\n\tbpf_printk(\"ITER_BASIC: E4 VAL: v=%d\", v ? *v : -1);\n\tv = bpf_iter_num_next(&it);\n\tbpf_printk(\"ITER_BASIC: E4 VAL: v=%d\", v ? *v : -1);\n\tv = bpf_iter_num_next(&it);\n\tbpf_printk(\"ITER_BASIC: E4 VAL: v=%d\\n\", v ? *v : -1);\n\tbpf_iter_num_destroy(&it);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_limit_cond_break_loop(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint *v, i = 0, sum = 0;\n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 0, 10);\n\twhile ((v = bpf_iter_num_next(&it))) {\n\t\tbpf_printk(\"ITER_SIMPLE: i=%d v=%d\", i, *v);\n\t\tsum += *v;\n\n\t\ti++;\n\t\tif (i > 3)\n\t\t\tbreak;\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\tbpf_printk(\"ITER_SIMPLE: sum=%d\\n\", sum);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_obfuscate_counter(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint *v, sum = 0;\n\t \n\tint i = zero;\n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 0, 10);\n\twhile ((v = bpf_iter_num_next(&it))) {\n\t\tint x;\n\n\t\ti += 1;\n\n\t\t \n\t\tif (i == 1)\n\t\t\tx = 123;\n\t\telse\n\t\t\tx = i * 3 + 1;\n\n\t\tbpf_printk(\"ITER_OBFUSCATE_COUNTER: i=%d v=%d x=%d\", i, *v, x);\n\n\t\tsum += x;\n\t}\n\tbpf_iter_num_destroy(&it);\n\n\tbpf_printk(\"ITER_OBFUSCATE_COUNTER: sum=%d\\n\", sum);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_search_loop(const void *ctx)\n{\n\tstruct bpf_iter_num it;\n\tint *v, *elem = NULL;\n\tbool found = false;\n\n\tMY_PID_GUARD();\n\n\tbpf_iter_num_new(&it, 0, 10);\n\n\twhile ((v = bpf_iter_num_next(&it))) {\n\t\tbpf_printk(\"ITER_SEARCH_LOOP: v=%d\", *v);\n\n\t\tif (*v == 2) {\n\t\t\tfound = true;\n\t\t\telem = v;\n\t\t\tbarrier_var(elem);\n\t\t}\n\t}\n\n\t \n\n\tif (found)\n\t\t \n\t\tbpf_printk(\"ITER_SEARCH_LOOP: FOUND IT = %d!\\n\", *elem);\n\telse\n\t\tbpf_printk(\"ITER_SEARCH_LOOP: NOT FOUND IT!\\n\");\n\n\tbpf_iter_num_destroy(&it);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_array_fill(const void *ctx)\n{\n\tint sum, i;\n\n\tMY_PID_GUARD();\n\n\tbpf_for(i, 0, ARRAY_SIZE(arr)) {\n\t\tarr[i] = i * 2;\n\t}\n\n\tsum = 0;\n\tbpf_for(i, 0, ARRAY_SIZE(arr)) {\n\t\tsum += arr[i];\n\t}\n\n\tbpf_printk(\"ITER_ARRAY_FILL: sum=%d (should be %d)\\n\", sum, 255 * 256);\n\n\treturn 0;\n}\n\nstatic int arr2d[4][5];\nstatic int arr2d_row_sums[4];\nstatic int arr2d_col_sums[5];\n\nSEC(\"raw_tp\")\n__success\nint iter_nested_iters(const void *ctx)\n{\n\tint sum, row, col;\n\n\tMY_PID_GUARD();\n\n\tbpf_for(row, 0, ARRAY_SIZE(arr2d)) {\n\t\tbpf_for( col, 0, ARRAY_SIZE(arr2d[0])) {\n\t\t\tarr2d[row][col] = row * col;\n\t\t}\n\t}\n\n\t \n\tsum = 0;\n\tbpf_for(row, 0, ARRAY_SIZE(arr2d)) {\n\t\tarr2d_row_sums[row] = 0;\n\t}\n\tbpf_for(col, 0, ARRAY_SIZE(arr2d[0])) {\n\t\tarr2d_col_sums[col] = 0;\n\t}\n\n\t \n\tbpf_for(row, 0, ARRAY_SIZE(arr2d)) {\n\t\tbpf_for(col, 0, ARRAY_SIZE(arr2d[0])) {\n\t\t\tsum += arr2d[row][col];\n\t\t\tarr2d_row_sums[row] += arr2d[row][col];\n\t\t\tarr2d_col_sums[col] += arr2d[row][col];\n\t\t}\n\t}\n\n\tbpf_printk(\"ITER_NESTED_ITERS: total sum=%d\", sum);\n\tbpf_for(row, 0, ARRAY_SIZE(arr2d)) {\n\t\tbpf_printk(\"ITER_NESTED_ITERS: row #%d sum=%d\", row, arr2d_row_sums[row]);\n\t}\n\tbpf_for(col, 0, ARRAY_SIZE(arr2d[0])) {\n\t\tbpf_printk(\"ITER_NESTED_ITERS: col #%d sum=%d%s\",\n\t\t\t   col, arr2d_col_sums[col],\n\t\t\t   col == ARRAY_SIZE(arr2d[0]) - 1 ? \"\\n\" : \"\");\n\t}\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_nested_deeply_iters(const void *ctx)\n{\n\tint sum = 0;\n\n\tMY_PID_GUARD();\n\n\tbpf_repeat(10) {\n\t\tbpf_repeat(10) {\n\t\t\tbpf_repeat(10) {\n\t\t\t\tbpf_repeat(10) {\n\t\t\t\t\tbpf_repeat(10) {\n\t\t\t\t\t\tsum += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\tbreak;\n\t}\n\n\treturn sum;\n}\n\nstatic __noinline void fill_inner_dimension(int row)\n{\n\tint col;\n\n\tbpf_for(col, 0, ARRAY_SIZE(arr2d[0])) {\n\t\tarr2d[row][col] = row * col;\n\t}\n}\n\nstatic __noinline int sum_inner_dimension(int row)\n{\n\tint sum = 0, col;\n\n\tbpf_for(col, 0, ARRAY_SIZE(arr2d[0])) {\n\t\tsum += arr2d[row][col];\n\t\tarr2d_row_sums[row] += arr2d[row][col];\n\t\tarr2d_col_sums[col] += arr2d[row][col];\n\t}\n\n\treturn sum;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_subprog_iters(const void *ctx)\n{\n\tint sum, row, col;\n\n\tMY_PID_GUARD();\n\n\tbpf_for(row, 0, ARRAY_SIZE(arr2d)) {\n\t\tfill_inner_dimension(row);\n\t}\n\n\t \n\tsum = 0;\n\tbpf_for(row, 0, ARRAY_SIZE(arr2d)) {\n\t\tarr2d_row_sums[row] = 0;\n\t}\n\tbpf_for(col, 0, ARRAY_SIZE(arr2d[0])) {\n\t\tarr2d_col_sums[col] = 0;\n\t}\n\n\t \n\tbpf_for(row, 0, ARRAY_SIZE(arr2d)) {\n\t\tsum += sum_inner_dimension(row);\n\t}\n\n\tbpf_printk(\"ITER_SUBPROG_ITERS: total sum=%d\", sum);\n\tbpf_for(row, 0, ARRAY_SIZE(arr2d)) {\n\t\tbpf_printk(\"ITER_SUBPROG_ITERS: row #%d sum=%d\",\n\t\t\t   row, arr2d_row_sums[row]);\n\t}\n\tbpf_for(col, 0, ARRAY_SIZE(arr2d[0])) {\n\t\tbpf_printk(\"ITER_SUBPROG_ITERS: col #%d sum=%d%s\",\n\t\t\t   col, arr2d_col_sums[col],\n\t\t\t   col == ARRAY_SIZE(arr2d[0]) - 1 ? \"\\n\" : \"\");\n\t}\n\n\treturn 0;\n}\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, int);\n\t__type(value, int);\n\t__uint(max_entries, 1000);\n} arr_map SEC(\".maps\");\n\nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint iter_err_too_permissive1(const void *ctx)\n{\n\tint *map_val = NULL;\n\tint key = 0;\n\n\tMY_PID_GUARD();\n\n\tmap_val = bpf_map_lookup_elem(&arr_map, &key);\n\tif (!map_val)\n\t\treturn 0;\n\n\tbpf_repeat(1000000) {\n\t\tmap_val = NULL;\n\t}\n\n\t*map_val = 123;\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'map_value_or_null'\")\nint iter_err_too_permissive2(const void *ctx)\n{\n\tint *map_val = NULL;\n\tint key = 0;\n\n\tMY_PID_GUARD();\n\n\tmap_val = bpf_map_lookup_elem(&arr_map, &key);\n\tif (!map_val)\n\t\treturn 0;\n\n\tbpf_repeat(1000000) {\n\t\tmap_val = bpf_map_lookup_elem(&arr_map, &key);\n\t}\n\n\t*map_val = 123;\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'map_value_or_null'\")\nint iter_err_too_permissive3(const void *ctx)\n{\n\tint *map_val = NULL;\n\tint key = 0;\n\tbool found = false;\n\n\tMY_PID_GUARD();\n\n\tbpf_repeat(1000000) {\n\t\tmap_val = bpf_map_lookup_elem(&arr_map, &key);\n\t\tfound = true;\n\t}\n\n\tif (found)\n\t\t*map_val = 123;\n\n\treturn 0;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_tricky_but_fine(const void *ctx)\n{\n\tint *map_val = NULL;\n\tint key = 0;\n\tbool found = false;\n\n\tMY_PID_GUARD();\n\n\tbpf_repeat(1000000) {\n\t\tmap_val = bpf_map_lookup_elem(&arr_map, &key);\n\t\tif (map_val) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found)\n\t\t*map_val = 123;\n\n\treturn 0;\n}\n\n#define __bpf_memzero(p, sz) bpf_probe_read_kernel((p), (sz), 0)\n\nSEC(\"raw_tp\")\n__success\nint iter_stack_array_loop(const void *ctx)\n{\n\tlong arr1[16], arr2[16], sum = 0;\n\tint i;\n\n\tMY_PID_GUARD();\n\n\t \n\t__bpf_memzero(arr1, sizeof(arr1));\n\t__bpf_memzero(arr2, sizeof(arr1));\n\n\t \n\tbpf_for(i, 0, ARRAY_SIZE(arr1)) {\n\t\tif (i & 1) {\n\t\t\tarr1[i] = i;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tarr2[i] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbpf_for(i, 0, ARRAY_SIZE(arr1)) {\n\t\tsum += arr1[i] + arr2[i];\n\t}\n\n\treturn sum;\n}\n\nstatic __noinline void fill(struct bpf_iter_num *it, int *arr, __u32 n, int mul)\n{\n\tint *t, i;\n\n\twhile ((t = bpf_iter_num_next(it))) {\n\t\ti = *t;\n\t\tif (i >= n)\n\t\t\tbreak;\n\t\tarr[i] =  i * mul;\n\t}\n}\n\nstatic __noinline int sum(struct bpf_iter_num *it, int *arr, __u32 n)\n{\n\tint *t, i, sum = 0;;\n\n\twhile ((t = bpf_iter_num_next(it))) {\n\t\ti = *t;\n\t\tif (i >= n)\n\t\t\tbreak;\n\t\tsum += arr[i];\n\t}\n\n\treturn sum;\n}\n\nSEC(\"raw_tp\")\n__success\nint iter_pass_iter_ptr_to_subprog(const void *ctx)\n{\n\tint arr1[16], arr2[32];\n\tstruct bpf_iter_num it;\n\tint n, sum1, sum2;\n\n\tMY_PID_GUARD();\n\n\t \n\tn = ARRAY_SIZE(arr1);\n\tbpf_iter_num_new(&it, 0, n);\n\tfill(&it, arr1, n, 2);\n\tbpf_iter_num_destroy(&it);\n\n\t \n\tn = ARRAY_SIZE(arr2);\n\tbpf_iter_num_new(&it, 0, n);\n\tfill(&it, arr2, n, 10);\n\tbpf_iter_num_destroy(&it);\n\n\t \n\tn = ARRAY_SIZE(arr1);\n\tbpf_iter_num_new(&it, 0, n);\n\tsum1 = sum(&it, arr1, n);\n\tbpf_iter_num_destroy(&it);\n\n\t \n\tn = ARRAY_SIZE(arr2);\n\tbpf_iter_num_new(&it, 0, n);\n\tsum2 = sum(&it, arr2, n);\n\tbpf_iter_num_destroy(&it);\n\n\tbpf_printk(\"sum1=%d, sum2=%d\", sum1, sum2);\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}