{
  "module_name": "cpumask_common.h",
  "hash_id": "ddf524146787ee7188f463d224d87ebd5be202262018e9a842389c5ff393aa1c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/cpumask_common.h",
  "human_readable_source": " \n \n\n#ifndef _CPUMASK_COMMON_H\n#define _CPUMASK_COMMON_H\n\n#include \"errno.h\"\n#include <stdbool.h>\n\nint err;\n\n#define private(name) SEC(\".bss.\" #name) __hidden __attribute__((aligned(8)))\nprivate(MASK) static struct bpf_cpumask __kptr * global_mask;\n\nstruct __cpumask_map_value {\n\tstruct bpf_cpumask __kptr * cpumask;\n};\n\nstruct array_map {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, int);\n\t__type(value, struct __cpumask_map_value);\n\t__uint(max_entries, 1);\n} __cpumask_map SEC(\".maps\");\n\nstruct bpf_cpumask *bpf_cpumask_create(void) __ksym;\nvoid bpf_cpumask_release(struct bpf_cpumask *cpumask) __ksym;\nstruct bpf_cpumask *bpf_cpumask_acquire(struct bpf_cpumask *cpumask) __ksym;\nu32 bpf_cpumask_first(const struct cpumask *cpumask) __ksym;\nu32 bpf_cpumask_first_zero(const struct cpumask *cpumask) __ksym;\nu32 bpf_cpumask_first_and(const struct cpumask *src1,\n\t\t\t  const struct cpumask *src2) __ksym;\nvoid bpf_cpumask_set_cpu(u32 cpu, struct bpf_cpumask *cpumask) __ksym;\nvoid bpf_cpumask_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask) __ksym;\nbool bpf_cpumask_test_cpu(u32 cpu, const struct cpumask *cpumask) __ksym;\nbool bpf_cpumask_test_and_set_cpu(u32 cpu, struct bpf_cpumask *cpumask) __ksym;\nbool bpf_cpumask_test_and_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask) __ksym;\nvoid bpf_cpumask_setall(struct bpf_cpumask *cpumask) __ksym;\nvoid bpf_cpumask_clear(struct bpf_cpumask *cpumask) __ksym;\nbool bpf_cpumask_and(struct bpf_cpumask *cpumask,\n\t\t     const struct cpumask *src1,\n\t\t     const struct cpumask *src2) __ksym;\nvoid bpf_cpumask_or(struct bpf_cpumask *cpumask,\n\t\t    const struct cpumask *src1,\n\t\t    const struct cpumask *src2) __ksym;\nvoid bpf_cpumask_xor(struct bpf_cpumask *cpumask,\n\t\t     const struct cpumask *src1,\n\t\t     const struct cpumask *src2) __ksym;\nbool bpf_cpumask_equal(const struct cpumask *src1, const struct cpumask *src2) __ksym;\nbool bpf_cpumask_intersects(const struct cpumask *src1, const struct cpumask *src2) __ksym;\nbool bpf_cpumask_subset(const struct cpumask *src1, const struct cpumask *src2) __ksym;\nbool bpf_cpumask_empty(const struct cpumask *cpumask) __ksym;\nbool bpf_cpumask_full(const struct cpumask *cpumask) __ksym;\nvoid bpf_cpumask_copy(struct bpf_cpumask *dst, const struct cpumask *src) __ksym;\nu32 bpf_cpumask_any_distribute(const struct cpumask *src) __ksym;\nu32 bpf_cpumask_any_and_distribute(const struct cpumask *src1, const struct cpumask *src2) __ksym;\n\nvoid bpf_rcu_read_lock(void) __ksym;\nvoid bpf_rcu_read_unlock(void) __ksym;\n\nstatic inline const struct cpumask *cast(struct bpf_cpumask *cpumask)\n{\n\treturn (const struct cpumask *)cpumask;\n}\n\nstatic inline struct bpf_cpumask *create_cpumask(void)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\tcpumask = bpf_cpumask_create();\n\tif (!cpumask) {\n\t\terr = 1;\n\t\treturn NULL;\n\t}\n\n\tif (!bpf_cpumask_empty(cast(cpumask))) {\n\t\terr = 2;\n\t\tbpf_cpumask_release(cpumask);\n\t\treturn NULL;\n\t}\n\n\treturn cpumask;\n}\n\nstatic inline struct __cpumask_map_value *cpumask_map_value_lookup(void)\n{\n\tu32 key = 0;\n\n\treturn bpf_map_lookup_elem(&__cpumask_map, &key);\n}\n\nstatic inline int cpumask_map_insert(struct bpf_cpumask *mask)\n{\n\tstruct __cpumask_map_value local, *v;\n\tlong status;\n\tstruct bpf_cpumask *old;\n\tu32 key = 0;\n\n\tlocal.cpumask = NULL;\n\tstatus = bpf_map_update_elem(&__cpumask_map, &key, &local, 0);\n\tif (status) {\n\t\tbpf_cpumask_release(mask);\n\t\treturn status;\n\t}\n\n\tv = bpf_map_lookup_elem(&__cpumask_map, &key);\n\tif (!v) {\n\t\tbpf_cpumask_release(mask);\n\t\treturn -ENOENT;\n\t}\n\n\told = bpf_kptr_xchg(&v->cpumask, mask);\n\tif (old) {\n\t\tbpf_cpumask_release(old);\n\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}