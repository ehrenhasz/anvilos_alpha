{
  "module_name": "test_spin_lock.c",
  "hash_id": "41aa30fde1468d7cd159201ccfb0c1aeddb0d4a93cee36fcbd73923b4951c694",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_spin_lock.c",
  "human_readable_source": "\n\n#include <linux/bpf.h>\n#include <linux/version.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nstruct hmap_elem {\n\tvolatile int cnt;\n\tstruct bpf_spin_lock lock;\n\tint test_padding;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, struct hmap_elem);\n} hmap SEC(\".maps\");\n\nstruct cls_elem {\n\tstruct bpf_spin_lock lock;\n\tvolatile int cnt;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_CGROUP_STORAGE);\n\t__type(key, struct bpf_cgroup_storage_key);\n\t__type(value, struct cls_elem);\n} cls_map SEC(\".maps\");\n\nstruct bpf_vqueue {\n\tstruct bpf_spin_lock lock;\n\t \n\tunsigned long long lasttime;\n\tint credit;\n\tunsigned int rate;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, struct bpf_vqueue);\n} vqueue SEC(\".maps\");\n\n#define CREDIT_PER_NS(delta, rate) (((delta) * rate) >> 20)\n\nSEC(\"cgroup_skb/ingress\")\nint bpf_spin_lock_test(struct __sk_buff *skb)\n{\n\tvolatile int credit = 0, max_credit = 100, pkt_len = 64;\n\tstruct hmap_elem zero = {}, *val;\n\tunsigned long long curtime;\n\tstruct bpf_vqueue *q;\n\tstruct cls_elem *cls;\n\tint key = 0;\n\tint err = 0;\n\n\tval = bpf_map_lookup_elem(&hmap, &key);\n\tif (!val) {\n\t\tbpf_map_update_elem(&hmap, &key, &zero, 0);\n\t\tval = bpf_map_lookup_elem(&hmap, &key);\n\t\tif (!val) {\n\t\t\terr = 1;\n\t\t\tgoto err;\n\t\t}\n\t}\n\t \n\tbpf_spin_lock(&val->lock);\n\tif (val->cnt)\n\t\tval->cnt--;\n\telse\n\t\tval->cnt++;\n\tif (val->cnt != 0 && val->cnt != 1)\n\t\terr = 1;\n\tbpf_spin_unlock(&val->lock);\n\n\t \n\tq = bpf_map_lookup_elem(&vqueue, &key);\n\tif (!q)\n\t\tgoto err;\n\tcurtime = bpf_ktime_get_ns();\n\tbpf_spin_lock(&q->lock);\n\tq->credit += CREDIT_PER_NS(curtime - q->lasttime, q->rate);\n\tq->lasttime = curtime;\n\tif (q->credit > max_credit)\n\t\tq->credit = max_credit;\n\tq->credit -= pkt_len;\n\tcredit = q->credit;\n\tbpf_spin_unlock(&q->lock);\n\n\t__sink(credit);\n\n\t \n\tcls = bpf_get_local_storage(&cls_map, 0);\n\tbpf_spin_lock(&cls->lock);\n\tcls->cnt++;\n\tbpf_spin_unlock(&cls->lock);\n\nerr:\n\treturn err;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}