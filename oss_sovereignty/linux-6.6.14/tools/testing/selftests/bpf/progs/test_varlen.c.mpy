{
  "module_name": "test_varlen.c",
  "hash_id": "365e9cca0de8d265c0f54aabfedc41908f8d56d035b13f9e09a6a4930fc494bc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_varlen.c",
  "human_readable_source": "\n \n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\n#define MAX_LEN 256\n\nchar buf_in1[MAX_LEN] = {};\nchar buf_in2[MAX_LEN] = {};\n\nint test_pid = 0;\nbool capture = false;\n\n \n__u64 payload1_len1 = 0;\n__u64 payload1_len2 = 0;\n__u64 total1 = 0;\nchar payload1[MAX_LEN + MAX_LEN] = {};\n__u64 ret_bad_read = 0;\n\n \nint payload2_len1 = -1;\nint payload2_len2 = -1;\nint total2 = -1;\nchar payload2[MAX_LEN + MAX_LEN] = { 1 };\n\nint payload3_len1 = -1;\nint payload3_len2 = -1;\nint total3= -1;\nchar payload3[MAX_LEN + MAX_LEN] = { 1 };\n\nint payload4_len1 = -1;\nint payload4_len2 = -1;\nint total4= -1;\nchar payload4[MAX_LEN + MAX_LEN] = { 1 };\n\nchar payload_bad[5] = { 0x42, 0x42, 0x42, 0x42, 0x42 };\n\nSEC(\"raw_tp/sys_enter\")\nint handler64_unsigned(void *regs)\n{\n\tint pid = bpf_get_current_pid_tgid() >> 32;\n\tvoid *payload = payload1;\n\tlong len;\n\n\t \n\tif (test_pid != pid || !capture)\n\t\treturn 0;\n\n\tlen = bpf_probe_read_kernel_str(payload, MAX_LEN, &buf_in1[0]);\n\tif (len >= 0) {\n\t\tpayload += len;\n\t\tpayload1_len1 = len;\n\t}\n\n\tlen = bpf_probe_read_kernel_str(payload, MAX_LEN, &buf_in2[0]);\n\tif (len >= 0) {\n\t\tpayload += len;\n\t\tpayload1_len2 = len;\n\t}\n\n\ttotal1 = payload - (void *)payload1;\n\n\tret_bad_read = bpf_probe_read_kernel_str(payload_bad + 2, 1, (void *) -1);\n\n\treturn 0;\n}\n\nSEC(\"raw_tp/sys_exit\")\nint handler64_signed(void *regs)\n{\n\tint pid = bpf_get_current_pid_tgid() >> 32;\n\tvoid *payload = payload3;\n\tlong len;\n\n\t \n\tif (test_pid != pid || !capture)\n\t\treturn 0;\n\n\tlen = bpf_probe_read_kernel_str(payload, MAX_LEN, &buf_in1[0]);\n\tif (len >= 0) {\n\t\tpayload += len;\n\t\tpayload3_len1 = len;\n\t}\n\tlen = bpf_probe_read_kernel_str(payload, MAX_LEN, &buf_in2[0]);\n\tif (len >= 0) {\n\t\tpayload += len;\n\t\tpayload3_len2 = len;\n\t}\n\ttotal3 = payload - (void *)payload3;\n\n\treturn 0;\n}\n\nSEC(\"tp/raw_syscalls/sys_enter\")\nint handler32_unsigned(void *regs)\n{\n\tint pid = bpf_get_current_pid_tgid() >> 32;\n\tvoid *payload = payload2;\n\tu32 len;\n\n\t \n\tif (test_pid != pid || !capture)\n\t\treturn 0;\n\n\tlen = bpf_probe_read_kernel_str(payload, MAX_LEN, &buf_in1[0]);\n\tif (len <= MAX_LEN) {\n\t\tpayload += len;\n\t\tpayload2_len1 = len;\n\t}\n\n\tlen = bpf_probe_read_kernel_str(payload, MAX_LEN, &buf_in2[0]);\n\tif (len <= MAX_LEN) {\n\t\tpayload += len;\n\t\tpayload2_len2 = len;\n\t}\n\n\ttotal2 = payload - (void *)payload2;\n\n\treturn 0;\n}\n\nSEC(\"tp/raw_syscalls/sys_exit\")\nint handler32_signed(void *regs)\n{\n\tint pid = bpf_get_current_pid_tgid() >> 32;\n\tvoid *payload = payload4;\n\tlong len;\n\n\t \n\tif (test_pid != pid || !capture)\n\t\treturn 0;\n\n\tlen = bpf_probe_read_kernel_str(payload, MAX_LEN, &buf_in1[0]);\n\tif (len >= 0) {\n\t\tpayload += len;\n\t\tpayload4_len1 = len;\n\t}\n\tlen = bpf_probe_read_kernel_str(payload, MAX_LEN, &buf_in2[0]);\n\tif (len >= 0) {\n\t\tpayload += len;\n\t\tpayload4_len2 = len;\n\t}\n\ttotal4 = payload - (void *)payload4;\n\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_exit_getpid\")\nint handler_exit(void *regs)\n{\n\tlong bla;\n\n\tif (bpf_probe_read_kernel(&bla, sizeof(bla), 0))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}