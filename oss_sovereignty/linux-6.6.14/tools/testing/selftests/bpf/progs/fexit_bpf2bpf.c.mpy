{
  "module_name": "fexit_bpf2bpf.c",
  "hash_id": "3453eb6df20c0bd1136d037c9bd6cd2ddb076a437d5216a3e42ce03a34114770",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/fexit_bpf2bpf.c",
  "human_readable_source": "\n \n#include <linux/stddef.h>\n#include <linux/if_ether.h>\n#include <linux/ipv6.h>\n#include <linux/bpf.h>\n#include <linux/tcp.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_tracing.h>\n\nstruct sk_buff {\n\tunsigned int len;\n};\n\n__u64 test_result = 0;\nSEC(\"fexit/test_pkt_access\")\nint BPF_PROG(test_main, struct sk_buff *skb, int ret)\n{\n\tint len;\n\n\t__builtin_preserve_access_index(({\n\t\tlen = skb->len;\n\t}));\n\tif (len != 74 || ret != 0)\n\t\treturn 0;\n\ttest_result = 1;\n\treturn 0;\n}\n\n__u64 test_result_subprog1 = 0;\nSEC(\"fexit/test_pkt_access_subprog1\")\nint BPF_PROG(test_subprog1, struct sk_buff *skb, int ret)\n{\n\tint len;\n\n\t__builtin_preserve_access_index(({\n\t\tlen = skb->len;\n\t}));\n\tif (len != 74 || ret != 148)\n\t\treturn 0;\n\ttest_result_subprog1 = 1;\n\treturn 0;\n}\n\n \nstruct args_subprog2 {\n\t__u64 args[5];\n\t__u64 ret;\n};\n__u64 test_result_subprog2 = 0;\nSEC(\"fexit/test_pkt_access_subprog2\")\nint test_subprog2(struct args_subprog2 *ctx)\n{\n\tstruct sk_buff *skb = (void *)ctx->args[0];\n\t__u64 ret;\n\tint len;\n\n\tbpf_probe_read_kernel(&len, sizeof(len),\n\t\t\t      __builtin_preserve_access_index(&skb->len));\n\n\tret = ctx->ret;\n\t \n\tret = (__u32) ret;\n\tif (len != 74 || ret != 148)\n\t\treturn 0;\n\ttest_result_subprog2 = 1;\n\treturn 0;\n}\n\n__u64 test_result_subprog3 = 0;\nSEC(\"fexit/test_pkt_access_subprog3\")\nint BPF_PROG(test_subprog3, int val, struct sk_buff *skb, int ret)\n{\n\tint len;\n\n\t__builtin_preserve_access_index(({\n\t\tlen = skb->len;\n\t}));\n\tif (len != 74 || ret != 74 * val || val != 3)\n\t\treturn 0;\n\ttest_result_subprog3 = 1;\n\treturn 0;\n}\n\n__u64 test_get_skb_len = 0;\nSEC(\"freplace/get_skb_len\")\nint new_get_skb_len(struct __sk_buff *skb)\n{\n\tint len = skb->len;\n\n\tif (len != 74)\n\t\treturn 0;\n\ttest_get_skb_len = 1;\n\treturn 74;  \n}\n\n__u64 test_get_skb_ifindex = 0;\nSEC(\"freplace/get_skb_ifindex\")\nint new_get_skb_ifindex(int val, struct __sk_buff *skb, int var)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tvoid *data = (void *)(long)skb->data;\n\tstruct ipv6hdr ip6, *ip6p;\n\tint ifindex = skb->ifindex;\n\n\t \n\tif (data + 14 + sizeof(ip6) > data_end)\n\t\treturn 0;\n\tip6p = data + 14;\n\n\tif (ip6p->nexthdr != 6 || ip6p->payload_len != __bpf_constant_htons(123))\n\t\treturn 0;\n\n\t \n\tif (bpf_skb_load_bytes(skb, 14, &ip6, sizeof(ip6)) < 0)\n\t\treturn 0;\n\tip6p = &ip6;\n\tif (ip6p->nexthdr != 6 || ip6p->payload_len != __bpf_constant_htons(123))\n\t\treturn 0;\n\n\tif (ifindex != 1 || val != 3 || var != 1)\n\t\treturn 0;\n\ttest_get_skb_ifindex = 1;\n\treturn 3;  \n}\n\nvolatile __u64 test_get_constant = 0;\nSEC(\"freplace/get_constant\")\nint new_get_constant(long val)\n{\n\tif (val != 123)\n\t\treturn 0;\n\ttest_get_constant = 1;\n\treturn test_get_constant;  \n}\n\n__u64 test_pkt_write_access_subprog = 0;\nSEC(\"freplace/test_pkt_write_access_subprog\")\nint new_test_pkt_write_access_subprog(struct __sk_buff *skb, __u32 off)\n{\n\n\tvoid *data = (void *)(long)skb->data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tstruct tcphdr *tcp;\n\n\tif (off > sizeof(struct ethhdr) + sizeof(struct ipv6hdr))\n\t\treturn -1;\n\n\ttcp = data + off;\n\tif (tcp + 1 > data_end)\n\t\treturn -1;\n\n\t \n\ttcp->check++;\n\ttcp->syn = 0;\n\n\ttest_pkt_write_access_subprog = 1;\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}