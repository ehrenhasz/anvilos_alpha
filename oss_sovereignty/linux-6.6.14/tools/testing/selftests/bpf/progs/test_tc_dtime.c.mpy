{
  "module_name": "test_tc_dtime.c",
  "hash_id": "ed90e9a9313022fa6a39b36a02ffc835c6f3ca140bcd8c82ac08cc4753ba1677",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tc_dtime.c",
  "human_readable_source": "\n\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <linux/bpf.h>\n#include <linux/stddef.h>\n#include <linux/pkt_cls.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n \n\n#define ctx_ptr(field)\t\t(void *)(long)(field)\n\n#define ip4_src\t\t\t__bpf_htonl(0xac100164)  \n#define ip4_dst\t\t\t__bpf_htonl(0xac100264)  \n\n#define ip6_src\t\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \\\n\t\t\t\t  0x00, 0x01, 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe }\n#define ip6_dst\t\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \\\n\t\t\t\t  0x00, 0x02, 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe }\n\n#define v6_equal(a, b)\t\t(a.s6_addr32[0] == b.s6_addr32[0] && \\\n\t\t\t\t a.s6_addr32[1] == b.s6_addr32[1] && \\\n\t\t\t\t a.s6_addr32[2] == b.s6_addr32[2] && \\\n\t\t\t\t a.s6_addr32[3] == b.s6_addr32[3])\n\nvolatile const __u32 IFINDEX_SRC;\nvolatile const __u32 IFINDEX_DST;\n\n#define EGRESS_ENDHOST_MAGIC\t0x0b9fbeef\n#define INGRESS_FWDNS_MAGIC\t0x1b9fbeef\n#define EGRESS_FWDNS_MAGIC\t0x2b9fbeef\n\nenum {\n\tINGRESS_FWDNS_P100,\n\tINGRESS_FWDNS_P101,\n\tEGRESS_FWDNS_P100,\n\tEGRESS_FWDNS_P101,\n\tINGRESS_ENDHOST,\n\tEGRESS_ENDHOST,\n\tSET_DTIME,\n\t__MAX_CNT,\n};\n\nenum {\n\tTCP_IP6_CLEAR_DTIME,\n\tTCP_IP4,\n\tTCP_IP6,\n\tUDP_IP4,\n\tUDP_IP6,\n\tTCP_IP4_RT_FWD,\n\tTCP_IP6_RT_FWD,\n\tUDP_IP4_RT_FWD,\n\tUDP_IP6_RT_FWD,\n\tUKN_TEST,\n\t__NR_TESTS,\n};\n\nenum {\n\tSRC_NS = 1,\n\tDST_NS,\n};\n\n__u32 dtimes[__NR_TESTS][__MAX_CNT] = {};\n__u32 errs[__NR_TESTS][__MAX_CNT] = {};\n__u32 test = 0;\n\nstatic void inc_dtimes(__u32 idx)\n{\n\tif (test < __NR_TESTS)\n\t\tdtimes[test][idx]++;\n\telse\n\t\tdtimes[UKN_TEST][idx]++;\n}\n\nstatic void inc_errs(__u32 idx)\n{\n\tif (test < __NR_TESTS)\n\t\terrs[test][idx]++;\n\telse\n\t\terrs[UKN_TEST][idx]++;\n}\n\nstatic int skb_proto(int type)\n{\n\treturn type & 0xff;\n}\n\nstatic int skb_ns(int type)\n{\n\treturn (type >> 8) & 0xff;\n}\n\nstatic bool fwdns_clear_dtime(void)\n{\n\treturn test == TCP_IP6_CLEAR_DTIME;\n}\n\nstatic bool bpf_fwd(void)\n{\n\treturn test < TCP_IP4_RT_FWD;\n}\n\nstatic __u8 get_proto(void)\n{\n\tswitch (test) {\n\tcase UDP_IP4:\n\tcase UDP_IP6:\n\tcase UDP_IP4_RT_FWD:\n\tcase UDP_IP6_RT_FWD:\n\t\treturn IPPROTO_UDP;\n\tdefault:\n\t\treturn IPPROTO_TCP;\n\t}\n}\n\n \nstatic int skb_get_type(struct __sk_buff *skb)\n{\n\t__u16 dst_ns_port = __bpf_htons(50000 + test);\n\tvoid *data_end = ctx_ptr(skb->data_end);\n\tvoid *data = ctx_ptr(skb->data);\n\t__u8 inet_proto = 0, ns = 0;\n\tstruct ipv6hdr *ip6h;\n\t__u16 sport, dport;\n\tstruct iphdr *iph;\n\tstruct tcphdr *th;\n\tstruct udphdr *uh;\n\tvoid *trans;\n\n\tswitch (skb->protocol) {\n\tcase __bpf_htons(ETH_P_IP):\n\t\tiph = data + sizeof(struct ethhdr);\n\t\tif (iph + 1 > data_end)\n\t\t\treturn -1;\n\t\tif (iph->saddr == ip4_src)\n\t\t\tns = SRC_NS;\n\t\telse if (iph->saddr == ip4_dst)\n\t\t\tns = DST_NS;\n\t\tinet_proto = iph->protocol;\n\t\ttrans = iph + 1;\n\t\tbreak;\n\tcase __bpf_htons(ETH_P_IPV6):\n\t\tip6h = data + sizeof(struct ethhdr);\n\t\tif (ip6h + 1 > data_end)\n\t\t\treturn -1;\n\t\tif (v6_equal(ip6h->saddr, (struct in6_addr){{ip6_src}}))\n\t\t\tns = SRC_NS;\n\t\telse if (v6_equal(ip6h->saddr, (struct in6_addr){{ip6_dst}}))\n\t\t\tns = DST_NS;\n\t\tinet_proto = ip6h->nexthdr;\n\t\ttrans = ip6h + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tif (!ns || inet_proto != get_proto())\n\t\treturn 0;\n\n\tswitch (inet_proto) {\n\tcase IPPROTO_TCP:\n\t\tth = trans;\n\t\tif (th + 1 > data_end)\n\t\t\treturn -1;\n\t\tsport = th->source;\n\t\tdport = th->dest;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tuh = trans;\n\t\tif (uh + 1 > data_end)\n\t\t\treturn -1;\n\t\tsport = uh->source;\n\t\tdport = uh->dest;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tif ((ns == SRC_NS && dport == dst_ns_port) ||\n\t    (ns == DST_NS && sport == dst_ns_port))\n\t\treturn (ns << 8 | inet_proto);\n\n\treturn 0;\n}\n\n \nSEC(\"tc\")\nint egress_host(struct __sk_buff *skb)\n{\n\tint skb_type;\n\n\tskb_type = skb_get_type(skb);\n\tif (skb_type == -1)\n\t\treturn TC_ACT_SHOT;\n\tif (!skb_type)\n\t\treturn TC_ACT_OK;\n\n\tif (skb_proto(skb_type) == IPPROTO_TCP) {\n\t\tif (skb->tstamp_type == BPF_SKB_TSTAMP_DELIVERY_MONO &&\n\t\t    skb->tstamp)\n\t\t\tinc_dtimes(EGRESS_ENDHOST);\n\t\telse\n\t\t\tinc_errs(EGRESS_ENDHOST);\n\t} else {\n\t\tif (skb->tstamp_type == BPF_SKB_TSTAMP_UNSPEC &&\n\t\t    skb->tstamp)\n\t\t\tinc_dtimes(EGRESS_ENDHOST);\n\t\telse\n\t\t\tinc_errs(EGRESS_ENDHOST);\n\t}\n\n\tskb->tstamp = EGRESS_ENDHOST_MAGIC;\n\n\treturn TC_ACT_OK;\n}\n\n \nSEC(\"tc\")\nint ingress_host(struct __sk_buff *skb)\n{\n\tint skb_type;\n\n\tskb_type = skb_get_type(skb);\n\tif (skb_type == -1)\n\t\treturn TC_ACT_SHOT;\n\tif (!skb_type)\n\t\treturn TC_ACT_OK;\n\n\tif (skb->tstamp_type == BPF_SKB_TSTAMP_DELIVERY_MONO &&\n\t    skb->tstamp == EGRESS_FWDNS_MAGIC)\n\t\tinc_dtimes(INGRESS_ENDHOST);\n\telse\n\t\tinc_errs(INGRESS_ENDHOST);\n\n\treturn TC_ACT_OK;\n}\n\n \nSEC(\"tc\")\nint ingress_fwdns_prio100(struct __sk_buff *skb)\n{\n\tint skb_type;\n\n\tskb_type = skb_get_type(skb);\n\tif (skb_type == -1)\n\t\treturn TC_ACT_SHOT;\n\tif (!skb_type)\n\t\treturn TC_ACT_OK;\n\n\t \n\tif (skb->tstamp == EGRESS_ENDHOST_MAGIC)\n\t\tinc_errs(INGRESS_FWDNS_P100);\n\n\tif (fwdns_clear_dtime())\n\t\tskb->tstamp = 0;\n\n\treturn TC_ACT_UNSPEC;\n}\n\n \nSEC(\"tc\")\nint egress_fwdns_prio100(struct __sk_buff *skb)\n{\n\tint skb_type;\n\n\tskb_type = skb_get_type(skb);\n\tif (skb_type == -1)\n\t\treturn TC_ACT_SHOT;\n\tif (!skb_type)\n\t\treturn TC_ACT_OK;\n\n\t \n\tif (skb->tstamp == INGRESS_FWDNS_MAGIC)\n\t\tinc_dtimes(EGRESS_FWDNS_P100);\n\telse\n\t\tinc_errs(EGRESS_FWDNS_P100);\n\n\tif (fwdns_clear_dtime())\n\t\tskb->tstamp = 0;\n\n\treturn TC_ACT_UNSPEC;\n}\n\n \nSEC(\"tc\")\nint ingress_fwdns_prio101(struct __sk_buff *skb)\n{\n\t__u64 expected_dtime = EGRESS_ENDHOST_MAGIC;\n\tint skb_type;\n\n\tskb_type = skb_get_type(skb);\n\tif (skb_type == -1 || !skb_type)\n\t\t \n\t\treturn TC_ACT_SHOT;\n\n\tif (skb_proto(skb_type) == IPPROTO_UDP)\n\t\texpected_dtime = 0;\n\n\tif (skb->tstamp_type) {\n\t\tif (fwdns_clear_dtime() ||\n\t\t    skb->tstamp_type != BPF_SKB_TSTAMP_DELIVERY_MONO ||\n\t\t    skb->tstamp != expected_dtime)\n\t\t\tinc_errs(INGRESS_FWDNS_P101);\n\t\telse\n\t\t\tinc_dtimes(INGRESS_FWDNS_P101);\n\t} else {\n\t\tif (!fwdns_clear_dtime() && expected_dtime)\n\t\t\tinc_errs(INGRESS_FWDNS_P101);\n\t}\n\n\tif (skb->tstamp_type == BPF_SKB_TSTAMP_DELIVERY_MONO) {\n\t\tskb->tstamp = INGRESS_FWDNS_MAGIC;\n\t} else {\n\t\tif (bpf_skb_set_tstamp(skb, INGRESS_FWDNS_MAGIC,\n\t\t\t\t       BPF_SKB_TSTAMP_DELIVERY_MONO))\n\t\t\tinc_errs(SET_DTIME);\n\t\tif (!bpf_skb_set_tstamp(skb, INGRESS_FWDNS_MAGIC,\n\t\t\t\t\tBPF_SKB_TSTAMP_UNSPEC))\n\t\t\tinc_errs(SET_DTIME);\n\t}\n\n\tif (skb_ns(skb_type) == SRC_NS)\n\t\treturn bpf_fwd() ?\n\t\t\tbpf_redirect_neigh(IFINDEX_DST, NULL, 0, 0) : TC_ACT_OK;\n\telse\n\t\treturn bpf_fwd() ?\n\t\t\tbpf_redirect_neigh(IFINDEX_SRC, NULL, 0, 0) : TC_ACT_OK;\n}\n\n \nSEC(\"tc\")\nint egress_fwdns_prio101(struct __sk_buff *skb)\n{\n\tint skb_type;\n\n\tskb_type = skb_get_type(skb);\n\tif (skb_type == -1 || !skb_type)\n\t\t \n\t\treturn TC_ACT_SHOT;\n\n\tif (skb->tstamp_type) {\n\t\tif (fwdns_clear_dtime() ||\n\t\t    skb->tstamp_type != BPF_SKB_TSTAMP_DELIVERY_MONO ||\n\t\t    skb->tstamp != INGRESS_FWDNS_MAGIC)\n\t\t\tinc_errs(EGRESS_FWDNS_P101);\n\t\telse\n\t\t\tinc_dtimes(EGRESS_FWDNS_P101);\n\t} else {\n\t\tif (!fwdns_clear_dtime())\n\t\t\tinc_errs(EGRESS_FWDNS_P101);\n\t}\n\n\tif (skb->tstamp_type == BPF_SKB_TSTAMP_DELIVERY_MONO) {\n\t\tskb->tstamp = EGRESS_FWDNS_MAGIC;\n\t} else {\n\t\tif (bpf_skb_set_tstamp(skb, EGRESS_FWDNS_MAGIC,\n\t\t\t\t       BPF_SKB_TSTAMP_DELIVERY_MONO))\n\t\t\tinc_errs(SET_DTIME);\n\t\tif (!bpf_skb_set_tstamp(skb, INGRESS_FWDNS_MAGIC,\n\t\t\t\t\tBPF_SKB_TSTAMP_UNSPEC))\n\t\t\tinc_errs(SET_DTIME);\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}