{
  "module_name": "iters_looping.c",
  "hash_id": "e49f7e33377e8124f97c4a42435757c4f1063c8f4966b0b316aab31881929dd4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/iters_looping.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n#define ITER_HELPERS\t\t\t\t\t\t\\\n\t  __imm(bpf_iter_num_new),\t\t\t\t\\\n\t  __imm(bpf_iter_num_next),\t\t\t\t\\\n\t  __imm(bpf_iter_num_destroy)\n\nSEC(\"?raw_tp\")\n__success\nint force_clang_to_emit_btf_for_externs(void *ctx)\n{\n\t \n\tbpf_repeat(0);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__success\nint consume_first_item_only(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_next];\"\n\n\t\t\"if r0 == 0 goto +1;\"\n\t\t\"r0 = *(u32 *)(r0 + 0);\"\n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"R0 invalid mem access 'scalar'\")\nint missing_null_check_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_next];\"\n\n\t\t \n\t\t\"r1 = *(u32 *)(r0 + 0);\"\n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure\n__msg(\"invalid access to memory, mem_size=4 off=0 size=8\")\n__msg(\"R0 min value is outside of the allowed memory range\")\nint wrong_sized_read_fail(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 1000;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_next];\"\n\n\t\t\"if r0 == 0 goto +1;\"\n\t\t \n\t\t\"r0 = *(u64 *)(r0 + 0);\"\n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common\n\t);\n\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__success __log_level(2)\n__flag(BPF_F_TEST_STATE_FREQ)\nint simplest_loop(void *ctx)\n{\n\tstruct bpf_iter_num iter;\n\n\tasm volatile (\n\t\t\"r6 = 0;\"  \n\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"r2 = 0;\"\n\t\t\"r3 = 10;\"\n\t\t\"call %[bpf_iter_num_new];\"\n\n\t\"1:\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_next];\"\n\n\t\t\"if r0 == 0 goto 2f;\"\n\t\t\"r0 = *(u32 *)(r0 + 0);\"\n\t\t\"r6 += r0;\"  \n\t\t\"goto 1b;\"\n\n\t\"2:\"\n\t\t \n\t\t\"r1 = %[iter];\"\n\t\t\"call %[bpf_iter_num_destroy];\"\n\t\t:\n\t\t: __imm_ptr(iter), ITER_HELPERS\n\t\t: __clobber_common, \"r6\"\n\t);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}