{
  "module_name": "test_sock_fields.c",
  "hash_id": "beef6601923c39de5e62d3c6b425841a878bd1612933ea1a1240479360244b8d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_sock_fields.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <netinet/in.h>\n#include <stdbool.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"bpf_tcp_helpers.h\"\n\nenum bpf_linum_array_idx {\n\tEGRESS_LINUM_IDX,\n\tINGRESS_LINUM_IDX,\n\tREAD_SK_DST_PORT_LINUM_IDX,\n\t__NR_BPF_LINUM_ARRAY_IDX,\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, __NR_BPF_LINUM_ARRAY_IDX);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} linum_map SEC(\".maps\");\n\nstruct bpf_spinlock_cnt {\n\tstruct bpf_spin_lock lock;\n\t__u32 cnt;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct bpf_spinlock_cnt);\n} sk_pkt_out_cnt SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct bpf_spinlock_cnt);\n} sk_pkt_out_cnt10 SEC(\".maps\");\n\nstruct bpf_tcp_sock listen_tp = {};\nstruct sockaddr_in6 srv_sa6 = {};\nstruct bpf_tcp_sock cli_tp = {};\nstruct bpf_tcp_sock srv_tp = {};\nstruct bpf_sock listen_sk = {};\nstruct bpf_sock srv_sk = {};\nstruct bpf_sock cli_sk = {};\n__u64 parent_cg_id = 0;\n__u64 child_cg_id = 0;\n__u64 lsndtime = 0;\n\nstatic bool is_loopback6(__u32 *a6)\n{\n\treturn !a6[0] && !a6[1] && !a6[2] && a6[3] == bpf_htonl(1);\n}\n\nstatic void skcpy(struct bpf_sock *dst,\n\t\t  const struct bpf_sock *src)\n{\n\tdst->bound_dev_if = src->bound_dev_if;\n\tdst->family = src->family;\n\tdst->type = src->type;\n\tdst->protocol = src->protocol;\n\tdst->mark = src->mark;\n\tdst->priority = src->priority;\n\tdst->src_ip4 = src->src_ip4;\n\tdst->src_ip6[0] = src->src_ip6[0];\n\tdst->src_ip6[1] = src->src_ip6[1];\n\tdst->src_ip6[2] = src->src_ip6[2];\n\tdst->src_ip6[3] = src->src_ip6[3];\n\tdst->src_port = src->src_port;\n\tdst->dst_ip4 = src->dst_ip4;\n\tdst->dst_ip6[0] = src->dst_ip6[0];\n\tdst->dst_ip6[1] = src->dst_ip6[1];\n\tdst->dst_ip6[2] = src->dst_ip6[2];\n\tdst->dst_ip6[3] = src->dst_ip6[3];\n\tdst->dst_port = src->dst_port;\n\tdst->state = src->state;\n}\n\nstatic void tpcpy(struct bpf_tcp_sock *dst,\n\t\t  const struct bpf_tcp_sock *src)\n{\n\tdst->snd_cwnd = src->snd_cwnd;\n\tdst->srtt_us = src->srtt_us;\n\tdst->rtt_min = src->rtt_min;\n\tdst->snd_ssthresh = src->snd_ssthresh;\n\tdst->rcv_nxt = src->rcv_nxt;\n\tdst->snd_nxt = src->snd_nxt;\n\tdst->snd_una = src->snd_una;\n\tdst->mss_cache = src->mss_cache;\n\tdst->ecn_flags = src->ecn_flags;\n\tdst->rate_delivered = src->rate_delivered;\n\tdst->rate_interval_us = src->rate_interval_us;\n\tdst->packets_out = src->packets_out;\n\tdst->retrans_out = src->retrans_out;\n\tdst->total_retrans = src->total_retrans;\n\tdst->segs_in = src->segs_in;\n\tdst->data_segs_in = src->data_segs_in;\n\tdst->segs_out = src->segs_out;\n\tdst->data_segs_out = src->data_segs_out;\n\tdst->lost_out = src->lost_out;\n\tdst->sacked_out = src->sacked_out;\n\tdst->bytes_received = src->bytes_received;\n\tdst->bytes_acked = src->bytes_acked;\n}\n\n \n#define CG_OK 1\n\n#define RET_LOG() ({\t\t\t\t\t\t\\\n\tlinum = __LINE__;\t\t\t\t\t\\\n\tbpf_map_update_elem(&linum_map, &linum_idx, &linum, BPF_ANY);\t\\\n\treturn CG_OK;\t\t\t\t\t\t\\\n})\n\nSEC(\"cgroup_skb/egress\")\nint egress_read_sock_fields(struct __sk_buff *skb)\n{\n\tstruct bpf_spinlock_cnt cli_cnt_init = { .lock = {}, .cnt = 0xeB9F };\n\tstruct bpf_spinlock_cnt *pkt_out_cnt, *pkt_out_cnt10;\n\tstruct bpf_tcp_sock *tp, *tp_ret;\n\tstruct bpf_sock *sk, *sk_ret;\n\t__u32 linum, linum_idx;\n\tstruct tcp_sock *ktp;\n\n\tlinum_idx = EGRESS_LINUM_IDX;\n\n\tsk = skb->sk;\n\tif (!sk)\n\t\tRET_LOG();\n\n\t \n\tif (sk->family != AF_INET6 || !is_loopback6(sk->src_ip6) ||\n\t    sk->state == BPF_TCP_LISTEN)\n\t\treturn CG_OK;\n\n\tif (sk->src_port == bpf_ntohs(srv_sa6.sin6_port)) {\n\t\t \n\t\tsk_ret = &srv_sk;\n\t\ttp_ret = &srv_tp;\n\t} else if (sk->dst_port == srv_sa6.sin6_port) {\n\t\t \n\t\tsk_ret = &cli_sk;\n\t\ttp_ret = &cli_tp;\n\t} else {\n\t\t \n\t\treturn CG_OK;\n\t}\n\n\t \n\tsk = bpf_sk_fullsock(sk);\n\tif (!sk)\n\t\tRET_LOG();\n\n\t \n\tif (sk->protocol != IPPROTO_TCP)\n\t\treturn CG_OK;\n\n\ttp = bpf_tcp_sock(sk);\n\tif (!tp)\n\t\tRET_LOG();\n\n\tskcpy(sk_ret, sk);\n\ttpcpy(tp_ret, tp);\n\n\tif (sk_ret == &srv_sk) {\n\t\tktp = bpf_skc_to_tcp_sock(sk);\n\n\t\tif (!ktp)\n\t\t\tRET_LOG();\n\n\t\tlsndtime = ktp->lsndtime;\n\n\t\tchild_cg_id = bpf_sk_cgroup_id(ktp);\n\t\tif (!child_cg_id)\n\t\t\tRET_LOG();\n\n\t\tparent_cg_id = bpf_sk_ancestor_cgroup_id(ktp, 2);\n\t\tif (!parent_cg_id)\n\t\t\tRET_LOG();\n\n\t\t \n\t\tpkt_out_cnt = bpf_sk_storage_get(&sk_pkt_out_cnt, ktp, 0, 0);\n\t\tpkt_out_cnt10 = bpf_sk_storage_get(&sk_pkt_out_cnt10, ktp,\n\t\t\t\t\t\t   0, 0);\n\t} else {\n\t\tpkt_out_cnt = bpf_sk_storage_get(&sk_pkt_out_cnt, sk,\n\t\t\t\t\t\t &cli_cnt_init,\n\t\t\t\t\t\t BPF_SK_STORAGE_GET_F_CREATE);\n\t\tpkt_out_cnt10 = bpf_sk_storage_get(&sk_pkt_out_cnt10,\n\t\t\t\t\t\t   sk, &cli_cnt_init,\n\t\t\t\t\t\t   BPF_SK_STORAGE_GET_F_CREATE);\n\t}\n\n\tif (!pkt_out_cnt || !pkt_out_cnt10)\n\t\tRET_LOG();\n\n\t \n\tpkt_out_cnt->cnt += 1;\n\tbpf_spin_lock(&pkt_out_cnt10->lock);\n\tpkt_out_cnt10->cnt += 10;\n\tbpf_spin_unlock(&pkt_out_cnt10->lock);\n\n\treturn CG_OK;\n}\n\nSEC(\"cgroup_skb/ingress\")\nint ingress_read_sock_fields(struct __sk_buff *skb)\n{\n\tstruct bpf_tcp_sock *tp;\n\t__u32 linum, linum_idx;\n\tstruct bpf_sock *sk;\n\n\tlinum_idx = INGRESS_LINUM_IDX;\n\n\tsk = skb->sk;\n\tif (!sk)\n\t\tRET_LOG();\n\n\t \n\tif (sk->family != AF_INET6 || !is_loopback6(sk->src_ip6) ||\n\t    sk->src_port != bpf_ntohs(srv_sa6.sin6_port))\n\t\treturn CG_OK;\n\n\t \n\tif (sk->state != BPF_TCP_LISTEN)\n\t\treturn CG_OK;\n\n\t \n\tsk = bpf_sk_fullsock(sk);\n\tif (!sk)\n\t\tRET_LOG();\n\n\ttp = bpf_tcp_sock(sk);\n\tif (!tp)\n\t\tRET_LOG();\n\n\tskcpy(&listen_sk, sk);\n\ttpcpy(&listen_tp, tp);\n\n\treturn CG_OK;\n}\n\n \nstatic __noinline bool sk_dst_port__load_word(struct bpf_sock *sk)\n{\n\t__u32 *word = (__u32 *)&sk->dst_port;\n\treturn word[0] == bpf_htons(0xcafe);\n}\n\nstatic __noinline bool sk_dst_port__load_half(struct bpf_sock *sk)\n{\n\t__u16 *half;\n\n\tasm volatile (\"\");\n\thalf = (__u16 *)&sk->dst_port;\n\treturn half[0] == bpf_htons(0xcafe);\n}\n\nstatic __noinline bool sk_dst_port__load_byte(struct bpf_sock *sk)\n{\n\t__u8 *byte = (__u8 *)&sk->dst_port;\n\treturn byte[0] == 0xca && byte[1] == 0xfe;\n}\n\nSEC(\"cgroup_skb/egress\")\nint read_sk_dst_port(struct __sk_buff *skb)\n{\n\t__u32 linum, linum_idx;\n\tstruct bpf_sock *sk;\n\n\tlinum_idx = READ_SK_DST_PORT_LINUM_IDX;\n\n\tsk = skb->sk;\n\tif (!sk)\n\t\tRET_LOG();\n\n\t \n\tif (sk->state != BPF_TCP_SYN_SENT)\n\t\treturn CG_OK;\n\n\tif (!sk_dst_port__load_word(sk))\n\t\tRET_LOG();\n\tif (!sk_dst_port__load_half(sk))\n\t\tRET_LOG();\n\tif (!sk_dst_port__load_byte(sk))\n\t\tRET_LOG();\n\n\treturn CG_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}