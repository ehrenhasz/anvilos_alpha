{
  "module_name": "test_map_ops.c",
  "hash_id": "6adff2c15bade9c346b0c5f3b31940d7f09b0a7595966721e99de7f2283e85bf",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_map_ops.c",
  "human_readable_source": "\n \n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n} hash_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_STACK);\n\t__uint(max_entries, 1);\n\t__type(value, int);\n} stack_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n} array_map SEC(\".maps\");\n\nconst volatile pid_t pid;\nlong err = 0;\n\nstatic u64 callback(u64 map, u64 key, u64 val, u64 ctx, u64 flags)\n{\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_getpid\")\nint map_update(void *ctx)\n{\n\tconst int key = 0;\n\tconst int val = 1;\n\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n\n\terr = bpf_map_update_elem(&hash_map, &key, &val, BPF_NOEXIST);\n\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_getppid\")\nint map_delete(void *ctx)\n{\n\tconst int key = 0;\n\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n\n\terr = bpf_map_delete_elem(&hash_map, &key);\n\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_getuid\")\nint map_push(void *ctx)\n{\n\tconst int val = 1;\n\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n\n\terr = bpf_map_push_elem(&stack_map, &val, 0);\n\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_geteuid\")\nint map_pop(void *ctx)\n{\n\tint val;\n\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n\n\terr = bpf_map_pop_elem(&stack_map, &val);\n\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_getgid\")\nint map_peek(void *ctx)\n{\n\tint val;\n\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n\n\terr = bpf_map_peek_elem(&stack_map, &val);\n\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_gettid\")\nint map_for_each_pass(void *ctx)\n{\n\tconst int key = 0;\n\tconst int val = 1;\n\tconst u64 flags = 0;\n\tint callback_ctx;\n\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n\n\tbpf_map_update_elem(&array_map, &key, &val, flags);\n\n\terr = bpf_for_each_map_elem(&array_map, callback, &callback_ctx, flags);\n\n\treturn 0;\n}\n\nSEC(\"tp/syscalls/sys_enter_getpgid\")\nint map_for_each_fail(void *ctx)\n{\n\tconst int key = 0;\n\tconst int val = 1;\n\tconst u64 flags = BPF_NOEXIST;\n\tint callback_ctx;\n\n\tif (pid != (bpf_get_current_pid_tgid() >> 32))\n\t\treturn 0;\n\n\tbpf_map_update_elem(&array_map, &key, &val, flags);\n\n\t \n\terr = bpf_for_each_map_elem(&array_map, callback, &callback_ctx, flags);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}