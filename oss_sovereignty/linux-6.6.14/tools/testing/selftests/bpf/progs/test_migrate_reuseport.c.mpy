{
  "module_name": "test_migrate_reuseport.c",
  "hash_id": "ae2c9e8c2c9b02a2e4e205d53574b1f7d256979faa08b932f0ece8e64c76126e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_migrate_reuseport.c",
  "human_readable_source": "\n \n\n#include <stddef.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/in.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_helpers.h>\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_REUSEPORT_SOCKARRAY);\n\t__uint(max_entries, 256);\n\t__type(key, int);\n\t__type(value, __u64);\n} reuseport_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 256);\n\t__type(key, __u64);\n\t__type(value, int);\n} migrate_map SEC(\".maps\");\n\nint migrated_at_close = 0;\nint migrated_at_close_fastopen = 0;\nint migrated_at_send_synack = 0;\nint migrated_at_recv_ack = 0;\n__be16 server_port;\n\nSEC(\"xdp\")\nint drop_ack(struct xdp_md *xdp)\n{\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\tvoid *data = (void *)(long)xdp->data;\n\tstruct ethhdr *eth = data;\n\tstruct tcphdr *tcp = NULL;\n\n\tif (eth + 1 > data_end)\n\t\tgoto pass;\n\n\tswitch (bpf_ntohs(eth->h_proto)) {\n\tcase ETH_P_IP: {\n\t\tstruct iphdr *ip = (struct iphdr *)(eth + 1);\n\n\t\tif (ip + 1 > data_end)\n\t\t\tgoto pass;\n\n\t\tif (ip->protocol != IPPROTO_TCP)\n\t\t\tgoto pass;\n\n\t\ttcp = (struct tcphdr *)((void *)ip + ip->ihl * 4);\n\t\tbreak;\n\t}\n\tcase ETH_P_IPV6: {\n\t\tstruct ipv6hdr *ipv6 = (struct ipv6hdr *)(eth + 1);\n\n\t\tif (ipv6 + 1 > data_end)\n\t\t\tgoto pass;\n\n\t\tif (ipv6->nexthdr != IPPROTO_TCP)\n\t\t\tgoto pass;\n\n\t\ttcp = (struct tcphdr *)(ipv6 + 1);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tgoto pass;\n\t}\n\n\tif (tcp + 1 > data_end)\n\t\tgoto pass;\n\n\tif (tcp->dest != server_port)\n\t\tgoto pass;\n\n\tif (!tcp->syn && tcp->ack)\n\t\treturn XDP_DROP;\n\npass:\n\treturn XDP_PASS;\n}\n\nSEC(\"sk_reuseport/migrate\")\nint migrate_reuseport(struct sk_reuseport_md *reuse_md)\n{\n\tint *key, flags = 0, state, err;\n\t__u64 cookie;\n\n\tif (!reuse_md->migrating_sk)\n\t\treturn SK_PASS;\n\n\tstate = reuse_md->migrating_sk->state;\n\tcookie = bpf_get_socket_cookie(reuse_md->sk);\n\n\tkey = bpf_map_lookup_elem(&migrate_map, &cookie);\n\tif (!key)\n\t\treturn SK_DROP;\n\n\terr = bpf_sk_select_reuseport(reuse_md, &reuseport_map, key, flags);\n\tif (err)\n\t\treturn SK_PASS;\n\n\tswitch (state) {\n\tcase BPF_TCP_ESTABLISHED:\n\t\t__sync_fetch_and_add(&migrated_at_close, 1);\n\t\tbreak;\n\tcase BPF_TCP_SYN_RECV:\n\t\t__sync_fetch_and_add(&migrated_at_close_fastopen, 1);\n\t\tbreak;\n\tcase BPF_TCP_NEW_SYN_RECV:\n\t\tif (!reuse_md->len)\n\t\t\t__sync_fetch_and_add(&migrated_at_send_synack, 1);\n\t\telse\n\t\t\t__sync_fetch_and_add(&migrated_at_recv_ack, 1);\n\t\tbreak;\n\t}\n\n\treturn SK_PASS;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}