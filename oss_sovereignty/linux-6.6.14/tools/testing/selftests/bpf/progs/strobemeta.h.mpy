{
  "module_name": "strobemeta.h",
  "hash_id": "9b995ad03fce31644a082fc3bb5880f40015a42cd0a5c13b40207f628d4b4f75",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/strobemeta.h",
  "human_readable_source": "\n\n\n#include <stdint.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <linux/bpf.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <bpf/bpf_helpers.h>\n\ntypedef uint32_t pid_t;\nstruct task_struct {};\n\n#define TASK_COMM_LEN 16\n#define PERF_MAX_STACK_DEPTH 127\n\n#define STROBE_TYPE_INVALID 0\n#define STROBE_TYPE_INT 1\n#define STROBE_TYPE_STR 2\n#define STROBE_TYPE_MAP 3\n\n#define STACK_TABLE_EPOCH_SHIFT 20\n#define STROBE_MAX_STR_LEN 1\n#define STROBE_MAX_CFGS 32\n#define STROBE_MAX_PAYLOAD\t\t\t\t\t\t\\\n\t(STROBE_MAX_STRS * STROBE_MAX_STR_LEN +\t\t\t\t\\\n\tSTROBE_MAX_MAPS * (1 + STROBE_MAX_MAP_ENTRIES * 2) * STROBE_MAX_STR_LEN)\n\nstruct strobe_value_header {\n\t \n\tuint16_t len;\n\t \n\tuint8_t _reserved[6];\n};\n\n \nstruct strobe_value_generic {\n\tstruct strobe_value_header header;\n\tunion {\n\t\tint64_t val;\n\t\tvoid *ptr;\n\t};\n};\n\nstruct strobe_value_int {\n\tstruct strobe_value_header header;\n\tint64_t value;\n};\n\nstruct strobe_value_str {\n\tstruct strobe_value_header header;\n\tconst char* value;\n};\n\nstruct strobe_value_map {\n\tstruct strobe_value_header header;\n\tconst struct strobe_map_raw* value;\n};\n\nstruct strobe_map_entry {\n\tconst char* key;\n\tconst char* val;\n};\n\n \nstruct strobe_map_raw {\n\t \n\tint64_t id;\n\t \n\tint64_t cnt;\n\t \n\tconst char* tag;\n\t \n\tstruct strobe_map_entry entries[STROBE_MAX_MAP_ENTRIES];\n};\n\n \n#define TLS_NOT_SET -1\n#define TLS_LOCAL_EXEC 0\n#define TLS_IMM_EXEC 1\n#define TLS_GENERAL_DYN 2\n\n \nstruct strobe_value_loc {\n\t \n\tint64_t tls_mode;\n\t \n\tint64_t offset;\n};\n\nstruct strobemeta_cfg {\n\tint64_t req_meta_idx;\n\tstruct strobe_value_loc int_locs[STROBE_MAX_INTS];\n\tstruct strobe_value_loc str_locs[STROBE_MAX_STRS];\n\tstruct strobe_value_loc map_locs[STROBE_MAX_MAPS];\n};\n\nstruct strobe_map_descr {\n\tuint64_t id;\n\tint16_t tag_len;\n\t \n\tint16_t cnt;\n\t \n\tuint16_t key_lens[STROBE_MAX_MAP_ENTRIES];\n\tuint16_t val_lens[STROBE_MAX_MAP_ENTRIES];\n};\n\nstruct strobemeta_payload {\n\t \n\tint64_t req_id;\n\tuint8_t req_meta_valid;\n\t \n\tuint64_t int_vals_set_mask;\n\tint64_t int_vals[STROBE_MAX_INTS];\n\t \n\tuint16_t str_lens[STROBE_MAX_STRS];\n\t \n\tstruct strobe_map_descr map_descrs[STROBE_MAX_MAPS];\n\t \n\tchar payload[STROBE_MAX_PAYLOAD];\n};\n\nstruct strobelight_bpf_sample {\n\tuint64_t ktime;\n\tchar comm[TASK_COMM_LEN];\n\tpid_t pid;\n\tint user_stack_id;\n\tint kernel_stack_id;\n\tint has_meta;\n\tstruct strobemeta_payload metadata;\n\t \n\tchar dummy_safeguard;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n\t__uint(max_entries, 32);\n\t__uint(key_size, sizeof(int));\n\t__uint(value_size, sizeof(int));\n} samples SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_STACK_TRACE);\n\t__uint(max_entries, 16);\n\t__uint(key_size, sizeof(uint32_t));\n\t__uint(value_size, sizeof(uint64_t) * PERF_MAX_STACK_DEPTH);\n} stacks_0 SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_STACK_TRACE);\n\t__uint(max_entries, 16);\n\t__uint(key_size, sizeof(uint32_t));\n\t__uint(value_size, sizeof(uint64_t) * PERF_MAX_STACK_DEPTH);\n} stacks_1 SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, uint32_t);\n\t__type(value, struct strobelight_bpf_sample);\n} sample_heap SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(max_entries, STROBE_MAX_CFGS);\n\t__type(key, pid_t);\n\t__type(value, struct strobemeta_cfg);\n} strobemeta_cfgs SEC(\".maps\");\n\n \n \ntypedef union dtv {\n\tsize_t counter;\n\tstruct {\n\t\tvoid* val;\n\t\tbool is_static;\n\t} pointer;\n} dtv_t;\n\n \n \nstruct tcbhead {\n\tvoid* tcb;\n\tdtv_t* dtv;\n};\n\n \nstruct tls_index {\n\tuint64_t module;\n\tuint64_t offset;\n};\n\n#ifdef SUBPROGS\n__noinline\n#else\n__always_inline\n#endif\nstatic void *calc_location(struct strobe_value_loc *loc, void *tls_base)\n{\n\t \n\tif (loc->tls_mode <= TLS_LOCAL_EXEC) {\n\t\t \n\t\tvoid *addr = tls_base + loc->offset;\n\t\t \n\t\treturn (void *)((loc->tls_mode + 1) * (int64_t)addr);\n\t}\n\t \n\tstruct tls_index tls_index;\n\tdtv_t *dtv;\n\tvoid *tls_ptr;\n\n\tbpf_probe_read_user(&tls_index, sizeof(struct tls_index),\n\t\t\t    (void *)loc->offset);\n\t \n\tif (tls_index.module > 0) {\n\t\t \n\t\tbpf_probe_read_user(&dtv, sizeof(dtv),\n\t\t\t\t    &((struct tcbhead *)tls_base)->dtv);\n\t\tdtv += tls_index.module;\n\t} else {\n\t\tdtv = NULL;\n\t}\n\tbpf_probe_read_user(&tls_ptr, sizeof(void *), dtv);\n\t \n\treturn tls_ptr && tls_ptr != (void *)-1\n\t\t? tls_ptr + tls_index.offset\n\t\t: NULL;\n}\n\n#ifdef SUBPROGS\n__noinline\n#else\n__always_inline\n#endif\nstatic void read_int_var(struct strobemeta_cfg *cfg,\n\t\t\t size_t idx, void *tls_base,\n\t\t\t struct strobe_value_generic *value,\n\t\t\t struct strobemeta_payload *data)\n{\n\tvoid *location = calc_location(&cfg->int_locs[idx], tls_base);\n\tif (!location)\n\t\treturn;\n\n\tbpf_probe_read_user(value, sizeof(struct strobe_value_generic), location);\n\tdata->int_vals[idx] = value->val;\n\tif (value->header.len)\n\t\tdata->int_vals_set_mask |= (1 << idx);\n}\n\nstatic __always_inline uint64_t read_str_var(struct strobemeta_cfg *cfg,\n\t\t\t\t\t     size_t idx, void *tls_base,\n\t\t\t\t\t     struct strobe_value_generic *value,\n\t\t\t\t\t     struct strobemeta_payload *data,\n\t\t\t\t\t     void *payload)\n{\n\tvoid *location;\n\tuint64_t len;\n\n\tdata->str_lens[idx] = 0;\n\tlocation = calc_location(&cfg->str_locs[idx], tls_base);\n\tif (!location)\n\t\treturn 0;\n\n\tbpf_probe_read_user(value, sizeof(struct strobe_value_generic), location);\n\tlen = bpf_probe_read_user_str(payload, STROBE_MAX_STR_LEN, value->ptr);\n\t \n\tif (len > STROBE_MAX_STR_LEN)\n\t\treturn 0;\n\n\tdata->str_lens[idx] = len;\n\treturn len;\n}\n\nstatic __always_inline void *read_map_var(struct strobemeta_cfg *cfg,\n\t\t\t\t\t  size_t idx, void *tls_base,\n\t\t\t\t\t  struct strobe_value_generic *value,\n\t\t\t\t\t  struct strobemeta_payload *data,\n\t\t\t\t\t  void *payload)\n{\n\tstruct strobe_map_descr* descr = &data->map_descrs[idx];\n\tstruct strobe_map_raw map;\n\tvoid *location;\n\tuint64_t len;\n\n\tdescr->tag_len = 0;  \n\tdescr->cnt = -1;  \n\n\tlocation = calc_location(&cfg->map_locs[idx], tls_base);\n\tif (!location)\n\t\treturn payload;\n\n\tbpf_probe_read_user(value, sizeof(struct strobe_value_generic), location);\n\tif (bpf_probe_read_user(&map, sizeof(struct strobe_map_raw), value->ptr))\n\t\treturn payload;\n\n\tdescr->id = map.id;\n\tdescr->cnt = map.cnt;\n\tif (cfg->req_meta_idx == idx) {\n\t\tdata->req_id = map.id;\n\t\tdata->req_meta_valid = 1;\n\t}\n\n\tlen = bpf_probe_read_user_str(payload, STROBE_MAX_STR_LEN, map.tag);\n\tif (len <= STROBE_MAX_STR_LEN) {\n\t\tdescr->tag_len = len;\n\t\tpayload += len;\n\t}\n\n#ifdef NO_UNROLL\n#pragma clang loop unroll(disable)\n#else\n#pragma unroll\n#endif\n\tfor (int i = 0; i < STROBE_MAX_MAP_ENTRIES; ++i) {\n\t\tif (i >= map.cnt)\n\t\t\tbreak;\n\n\t\tdescr->key_lens[i] = 0;\n\t\tlen = bpf_probe_read_user_str(payload, STROBE_MAX_STR_LEN,\n\t\t\t\t\t      map.entries[i].key);\n\t\tif (len <= STROBE_MAX_STR_LEN) {\n\t\t\tdescr->key_lens[i] = len;\n\t\t\tpayload += len;\n\t\t}\n\t\tdescr->val_lens[i] = 0;\n\t\tlen = bpf_probe_read_user_str(payload, STROBE_MAX_STR_LEN,\n\t\t\t\t\t      map.entries[i].val);\n\t\tif (len <= STROBE_MAX_STR_LEN) {\n\t\t\tdescr->val_lens[i] = len;\n\t\t\tpayload += len;\n\t\t}\n\t}\n\n\treturn payload;\n}\n\n#ifdef USE_BPF_LOOP\nenum read_type {\n\tREAD_INT_VAR,\n\tREAD_MAP_VAR,\n\tREAD_STR_VAR,\n};\n\nstruct read_var_ctx {\n\tstruct strobemeta_payload *data;\n\tvoid *tls_base;\n\tstruct strobemeta_cfg *cfg;\n\tvoid *payload;\n\t \n\tstruct strobe_value_generic *value;\n\tenum read_type type;\n};\n\nstatic int read_var_callback(__u32 index, struct read_var_ctx *ctx)\n{\n\tswitch (ctx->type) {\n\tcase READ_INT_VAR:\n\t\tif (index >= STROBE_MAX_INTS)\n\t\t\treturn 1;\n\t\tread_int_var(ctx->cfg, index, ctx->tls_base, ctx->value, ctx->data);\n\t\tbreak;\n\tcase READ_MAP_VAR:\n\t\tif (index >= STROBE_MAX_MAPS)\n\t\t\treturn 1;\n\t\tctx->payload = read_map_var(ctx->cfg, index, ctx->tls_base,\n\t\t\t\t\t    ctx->value, ctx->data, ctx->payload);\n\t\tbreak;\n\tcase READ_STR_VAR:\n\t\tif (index >= STROBE_MAX_STRS)\n\t\t\treturn 1;\n\t\tctx->payload += read_str_var(ctx->cfg, index, ctx->tls_base,\n\t\t\t\t\t     ctx->value, ctx->data, ctx->payload);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif  \n\n \n#ifdef SUBPROGS\n__noinline\n#else\n__always_inline\n#endif\nstatic void *read_strobe_meta(struct task_struct *task,\n\t\t\t      struct strobemeta_payload *data)\n{\n\tpid_t pid = bpf_get_current_pid_tgid() >> 32;\n\tstruct strobe_value_generic value = {0};\n\tstruct strobemeta_cfg *cfg;\n\tvoid *tls_base, *payload;\n\n\tcfg = bpf_map_lookup_elem(&strobemeta_cfgs, &pid);\n\tif (!cfg)\n\t\treturn NULL;\n\n\tdata->int_vals_set_mask = 0;\n\tdata->req_meta_valid = 0;\n\tpayload = data->payload;\n\t \n\ttls_base = (void *)task;\n\n#ifdef USE_BPF_LOOP\n\tstruct read_var_ctx ctx = {\n\t\t.cfg = cfg,\n\t\t.tls_base = tls_base,\n\t\t.value = &value,\n\t\t.data = data,\n\t\t.payload = payload,\n\t};\n\tint err;\n\n\tctx.type = READ_INT_VAR;\n\terr = bpf_loop(STROBE_MAX_INTS, read_var_callback, &ctx, 0);\n\tif (err != STROBE_MAX_INTS)\n\t\treturn NULL;\n\n\tctx.type = READ_STR_VAR;\n\terr = bpf_loop(STROBE_MAX_STRS, read_var_callback, &ctx, 0);\n\tif (err != STROBE_MAX_STRS)\n\t\treturn NULL;\n\n\tctx.type = READ_MAP_VAR;\n\terr = bpf_loop(STROBE_MAX_MAPS, read_var_callback, &ctx, 0);\n\tif (err != STROBE_MAX_MAPS)\n\t\treturn NULL;\n#else\n#ifdef NO_UNROLL\n#pragma clang loop unroll(disable)\n#else\n#pragma unroll\n#endif  \n\tfor (int i = 0; i < STROBE_MAX_INTS; ++i) {\n\t\tread_int_var(cfg, i, tls_base, &value, data);\n\t}\n#ifdef NO_UNROLL\n#pragma clang loop unroll(disable)\n#else\n#pragma unroll\n#endif  \n\tfor (int i = 0; i < STROBE_MAX_STRS; ++i) {\n\t\tpayload += read_str_var(cfg, i, tls_base, &value, data, payload);\n\t}\n#ifdef NO_UNROLL\n#pragma clang loop unroll(disable)\n#else\n#pragma unroll\n#endif  \n\tfor (int i = 0; i < STROBE_MAX_MAPS; ++i) {\n\t\tpayload = read_map_var(cfg, i, tls_base, &value, data, payload);\n\t}\n#endif  \n\n\t \n\treturn payload;\n}\n\nSEC(\"raw_tracepoint/kfree_skb\")\nint on_event(struct pt_regs *ctx) {\n\tpid_t pid =  bpf_get_current_pid_tgid() >> 32;\n\tstruct strobelight_bpf_sample* sample;\n\tstruct task_struct *task;\n\tuint32_t zero = 0;\n\tuint64_t ktime_ns;\n\tvoid *sample_end;\n\n\tsample = bpf_map_lookup_elem(&sample_heap, &zero);\n\tif (!sample)\n\t\treturn 0;  \n\n\tsample->pid = pid;\n\tbpf_get_current_comm(&sample->comm, TASK_COMM_LEN);\n\tktime_ns = bpf_ktime_get_ns();\n\tsample->ktime = ktime_ns;\n\n\ttask = (struct task_struct *)bpf_get_current_task();\n\tsample_end = read_strobe_meta(task, &sample->metadata);\n\tsample->has_meta = sample_end != NULL;\n\tsample_end = sample_end ? : &sample->metadata;\n\n\tif ((ktime_ns >> STACK_TABLE_EPOCH_SHIFT) & 1) {\n\t\tsample->kernel_stack_id = bpf_get_stackid(ctx, &stacks_1, 0);\n\t\tsample->user_stack_id = bpf_get_stackid(ctx, &stacks_1, BPF_F_USER_STACK);\n\t} else {\n\t\tsample->kernel_stack_id = bpf_get_stackid(ctx, &stacks_0, 0);\n\t\tsample->user_stack_id = bpf_get_stackid(ctx, &stacks_0, BPF_F_USER_STACK);\n\t}\n\n\tuint64_t sample_size = sample_end - (void *)sample;\n\t \n\tif (sample_size < sizeof(struct strobelight_bpf_sample))\n\t\tbpf_perf_event_output(ctx, &samples, 0, sample, 1 + sample_size);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}