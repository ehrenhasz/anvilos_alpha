{
  "module_name": "verifier_raw_stack.c",
  "hash_id": "16fb14290a3c0709816109a65ca8b1f03b0e0756d50b6221c53c218520de7d54",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_raw_stack.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nSEC(\"socket\")\n__description(\"raw_stack: no skb_load_bytes\")\n__success\n__failure_unpriv __msg_unpriv(\"invalid read from stack R6 off=-8 size=8\")\n__naked void stack_no_skb_load_bytes(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 8;\t\t\t\t\t\t\\\n\t \t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, negative len\")\n__failure __msg(\"R4 min value is negative\")\n__naked void skb_load_bytes_negative_len(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = -8;\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, negative len 2\")\n__failure __msg(\"R4 min value is negative\")\n__naked void load_bytes_negative_len_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = %[__imm_0];\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes),\n\t  __imm_const(__imm_0, ~0)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, zero len\")\n__failure __msg(\"invalid zero-sized read\")\n__naked void skb_load_bytes_zero_len(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, no init\")\n__success __retval(0)\n__naked void skb_load_bytes_no_init(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 8;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, init\")\n__success __retval(0)\n__naked void stack_skb_load_bytes_init(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\tr3 = 0xcafe;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r3;\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 8;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, spilled regs around bounds\")\n__success __retval(0)\n__naked void bytes_spilled_regs_around_bounds(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -16;\t\t\t\t\t\\\n\t*(u64*)(r6 - 8) = r1;\t\t\t\t\\\n\t*(u64*)(r6 + 8) = r1;\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 8;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 - 8);\t\t\t\t\\\n\tr2 = *(u64*)(r6 + 8);\t\t\t\t\\\n\tr0 = *(u32*)(r0 + %[__sk_buff_mark]);\t\t\\\n\tr2 = *(u32*)(r2 + %[__sk_buff_priority]);\t\\\n\tr0 += r2;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark)),\n\t  __imm_const(__sk_buff_priority, offsetof(struct __sk_buff, priority))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, spilled regs corruption\")\n__failure __msg(\"R0 invalid mem access 'scalar'\")\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void load_bytes_spilled_regs_corruption(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -8;\t\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 8;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\tr0 = *(u32*)(r0 + %[__sk_buff_mark]);\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, spilled regs corruption 2\")\n__failure __msg(\"R3 invalid mem access 'scalar'\")\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void bytes_spilled_regs_corruption_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -16;\t\t\t\t\t\\\n\t*(u64*)(r6 - 8) = r1;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\n\t*(u64*)(r6 + 8) = r1;\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 8;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 - 8);\t\t\t\t\\\n\tr2 = *(u64*)(r6 + 8);\t\t\t\t\\\n\tr3 = *(u64*)(r6 + 0);\t\t\t\t\\\n\tr0 = *(u32*)(r0 + %[__sk_buff_mark]);\t\t\\\n\tr2 = *(u32*)(r2 + %[__sk_buff_priority]);\t\\\n\tr0 += r2;\t\t\t\t\t\\\n\tr3 = *(u32*)(r3 + %[__sk_buff_pkt_type]);\t\\\n\tr0 += r3;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark)),\n\t  __imm_const(__sk_buff_pkt_type, offsetof(struct __sk_buff, pkt_type)),\n\t  __imm_const(__sk_buff_priority, offsetof(struct __sk_buff, priority))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, spilled regs + data\")\n__success __retval(0)\n__naked void load_bytes_spilled_regs_data(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -16;\t\t\t\t\t\\\n\t*(u64*)(r6 - 8) = r1;\t\t\t\t\\\n\t*(u64*)(r6 + 0) = r1;\t\t\t\t\\\n\t*(u64*)(r6 + 8) = r1;\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 8;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 - 8);\t\t\t\t\\\n\tr2 = *(u64*)(r6 + 8);\t\t\t\t\\\n\tr3 = *(u64*)(r6 + 0);\t\t\t\t\\\n\tr0 = *(u32*)(r0 + %[__sk_buff_mark]);\t\t\\\n\tr2 = *(u32*)(r2 + %[__sk_buff_priority]);\t\\\n\tr0 += r2;\t\t\t\t\t\\\n\tr0 += r3;\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark)),\n\t  __imm_const(__sk_buff_priority, offsetof(struct __sk_buff, priority))\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, invalid access 1\")\n__failure __msg(\"invalid indirect access to stack R3 off=-513 size=8\")\n__naked void load_bytes_invalid_access_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -513;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 8;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, invalid access 2\")\n__failure __msg(\"invalid indirect access to stack R3 off=-1 size=8\")\n__naked void load_bytes_invalid_access_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -1;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 8;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, invalid access 3\")\n__failure __msg(\"R4 min value is negative\")\n__naked void load_bytes_invalid_access_3(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += 0xffffffff;\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 0xffffffff;\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, invalid access 4\")\n__failure\n__msg(\"R4 unbounded memory access, use 'var &= const' or 'if (var < const)'\")\n__naked void load_bytes_invalid_access_4(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -1;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 0x7fffffff;\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, invalid access 5\")\n__failure\n__msg(\"R4 unbounded memory access, use 'var &= const' or 'if (var < const)'\")\n__naked void load_bytes_invalid_access_5(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -512;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 0x7fffffff;\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, invalid access 6\")\n__failure __msg(\"invalid zero-sized read\")\n__naked void load_bytes_invalid_access_6(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -512;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"raw_stack: skb_load_bytes, large access\")\n__success __retval(0)\n__naked void skb_load_bytes_large_access(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 4;\t\t\t\t\t\t\\\n\tr6 = r10;\t\t\t\t\t\\\n\tr6 += -512;\t\t\t\t\t\\\n\tr3 = r6;\t\t\t\t\t\\\n\tr4 = 512;\t\t\t\t\t\\\n\tcall %[bpf_skb_load_bytes];\t\t\t\\\n\tr0 = *(u64*)(r6 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_skb_load_bytes)\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}