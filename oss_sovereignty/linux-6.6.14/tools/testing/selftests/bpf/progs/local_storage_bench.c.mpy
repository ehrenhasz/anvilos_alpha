{
  "module_name": "local_storage_bench.c",
  "hash_id": "eeca3878f3ad11e5492c4a6d4560a91bb2170b30c6707a7a739e36b674008af1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/local_storage_bench.c",
  "human_readable_source": "\n \n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\n#define HASHMAP_SZ 4194304\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, 1000);\n\t__type(key, int);\n\t__type(value, int);\n\t__array(values, struct {\n\t\t__uint(type, BPF_MAP_TYPE_TASK_STORAGE);\n\t\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t\t__type(key, int);\n\t\t__type(value, int);\n\t});\n} array_of_local_storage_maps SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, 1000);\n\t__type(key, int);\n\t__type(value, int);\n\t__array(values, struct {\n\t\t__uint(type, BPF_MAP_TYPE_HASH);\n\t\t__uint(max_entries, HASHMAP_SZ);\n\t\t__type(key, int);\n\t\t__type(value, int);\n\t});\n} array_of_hash_maps SEC(\".maps\");\n\nlong important_hits;\nlong hits;\n\n \nconst volatile unsigned int use_hashmap;\nconst volatile unsigned int hashmap_num_keys;\nconst volatile unsigned int num_maps;\nconst volatile unsigned int interleave;\n\nstruct loop_ctx {\n\tstruct task_struct *task;\n\tlong loop_hits;\n\tlong loop_important_hits;\n};\n\nstatic int do_lookup(unsigned int elem, struct loop_ctx *lctx)\n{\n\tvoid *map, *inner_map;\n\tint idx = 0;\n\n\tif (use_hashmap)\n\t\tmap = &array_of_hash_maps;\n\telse\n\t\tmap = &array_of_local_storage_maps;\n\n\tinner_map = bpf_map_lookup_elem(map, &elem);\n\tif (!inner_map)\n\t\treturn -1;\n\n\tif (use_hashmap) {\n\t\tidx = bpf_get_prandom_u32() % hashmap_num_keys;\n\t\tbpf_map_lookup_elem(inner_map, &idx);\n\t} else {\n\t\tbpf_task_storage_get(inner_map, lctx->task, &idx,\n\t\t\t\t     BPF_LOCAL_STORAGE_GET_F_CREATE);\n\t}\n\n\tlctx->loop_hits++;\n\tif (!elem)\n\t\tlctx->loop_important_hits++;\n\treturn 0;\n}\n\nstatic long loop(u32 index, void *ctx)\n{\n\tstruct loop_ctx *lctx = (struct loop_ctx *)ctx;\n\tunsigned int map_idx = index % num_maps;\n\n\tdo_lookup(map_idx, lctx);\n\tif (interleave && map_idx % 3 == 0)\n\t\tdo_lookup(0, lctx);\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_getpgid\")\nint get_local(void *ctx)\n{\n\tstruct loop_ctx lctx;\n\n\tlctx.task = bpf_get_current_task_btf();\n\tlctx.loop_hits = 0;\n\tlctx.loop_important_hits = 0;\n\tbpf_loop(10000, &loop, &lctx, 0);\n\t__sync_add_and_fetch(&hits, lctx.loop_hits);\n\t__sync_add_and_fetch(&important_hits, lctx.loop_important_hits);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}