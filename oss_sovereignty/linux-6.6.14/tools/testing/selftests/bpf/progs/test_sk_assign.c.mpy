{
  "module_name": "test_sk_assign.c",
  "hash_id": "b60258dc26a72c6993cb107b4a094abaeb0909ba384cf8a4318813a863004431",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_sk_assign.c",
  "human_readable_source": "\n\n\n\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/pkt_cls.h>\n#include <linux/tcp.h>\n#include <sys/socket.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"bpf_misc.h\"\n\n#if defined(IPROUTE2_HAVE_LIBBPF)\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_SOCKMAP);\n\t__type(key, int);\n\t__type(value, __u64);\n\t__uint(pinning, LIBBPF_PIN_BY_NAME);\n\t__uint(max_entries, 1);\n} server_map SEC(\".maps\");\n#else\n \n#define PIN_GLOBAL_NS 2\n\n \nstruct {\n\t__u32 type;\n\t__u32 size_key;\n\t__u32 size_value;\n\t__u32 max_elem;\n\t__u32 flags;\n\t__u32 id;\n\t__u32 pinning;\n} server_map SEC(\"maps\") = {\n\t.type = BPF_MAP_TYPE_SOCKMAP,\n\t.size_key = sizeof(int),\n\t.size_value  = sizeof(__u64),\n\t.max_elem = 1,\n\t.pinning = PIN_GLOBAL_NS,\n};\n#endif\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n \nstatic inline struct bpf_sock_tuple *\nget_tuple(struct __sk_buff *skb, bool *ipv4, bool *tcp)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tvoid *data = (void *)(long)skb->data;\n\tstruct bpf_sock_tuple *result;\n\tstruct ethhdr *eth;\n\t__u8 proto = 0;\n\t__u64 ihl_len;\n\n\teth = (struct ethhdr *)(data);\n\tif (eth + 1 > data_end)\n\t\treturn NULL;\n\n\tif (eth->h_proto == bpf_htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph = (struct iphdr *)(data + sizeof(*eth));\n\n\t\tif (iph + 1 > data_end)\n\t\t\treturn NULL;\n\t\tif (iph->ihl != 5)\n\t\t\t \n\t\t\treturn NULL;\n\t\tihl_len = iph->ihl * 4;\n\t\tproto = iph->protocol;\n\t\t*ipv4 = true;\n\t\tresult = (struct bpf_sock_tuple *)&iph->saddr;\n\t} else if (eth->h_proto == bpf_htons(ETH_P_IPV6)) {\n\t\tstruct ipv6hdr *ip6h = (struct ipv6hdr *)(data + sizeof(*eth));\n\n\t\tif (ip6h + 1 > data_end)\n\t\t\treturn NULL;\n\t\tihl_len = sizeof(*ip6h);\n\t\tproto = ip6h->nexthdr;\n\t\t*ipv4 = false;\n\t\tresult = (struct bpf_sock_tuple *)&ip6h->saddr;\n\t} else {\n\t\treturn (struct bpf_sock_tuple *)data;\n\t}\n\n\tif (proto != IPPROTO_TCP && proto != IPPROTO_UDP)\n\t\treturn NULL;\n\n\t*tcp = (proto == IPPROTO_TCP);\n\t__sink(ihl_len);\n\treturn result;\n}\n\nstatic inline int\nhandle_udp(struct __sk_buff *skb, struct bpf_sock_tuple *tuple, bool ipv4)\n{\n\tstruct bpf_sock *sk;\n\tconst int zero = 0;\n\tsize_t tuple_len;\n\t__be16 dport;\n\tint ret;\n\n\ttuple_len = ipv4 ? sizeof(tuple->ipv4) : sizeof(tuple->ipv6);\n\tif ((void *)tuple + tuple_len > (void *)(long)skb->data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tsk = bpf_sk_lookup_udp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n\tif (sk)\n\t\tgoto assign;\n\n\tdport = ipv4 ? tuple->ipv4.dport : tuple->ipv6.dport;\n\tif (dport != bpf_htons(4321))\n\t\treturn TC_ACT_OK;\n\n\tsk = bpf_map_lookup_elem(&server_map, &zero);\n\tif (!sk)\n\t\treturn TC_ACT_SHOT;\n\nassign:\n\tret = bpf_sk_assign(skb, sk, 0);\n\tbpf_sk_release(sk);\n\treturn ret;\n}\n\nstatic inline int\nhandle_tcp(struct __sk_buff *skb, struct bpf_sock_tuple *tuple, bool ipv4)\n{\n\tstruct bpf_sock *sk;\n\tconst int zero = 0;\n\tsize_t tuple_len;\n\t__be16 dport;\n\tint ret;\n\n\ttuple_len = ipv4 ? sizeof(tuple->ipv4) : sizeof(tuple->ipv6);\n\tif ((void *)tuple + tuple_len > (void *)(long)skb->data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tsk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n\tif (sk) {\n\t\tif (sk->state != BPF_TCP_LISTEN)\n\t\t\tgoto assign;\n\t\tbpf_sk_release(sk);\n\t}\n\n\tdport = ipv4 ? tuple->ipv4.dport : tuple->ipv6.dport;\n\tif (dport != bpf_htons(4321))\n\t\treturn TC_ACT_OK;\n\n\tsk = bpf_map_lookup_elem(&server_map, &zero);\n\tif (!sk)\n\t\treturn TC_ACT_SHOT;\n\n\tif (sk->state != BPF_TCP_LISTEN) {\n\t\tbpf_sk_release(sk);\n\t\treturn TC_ACT_SHOT;\n\t}\n\nassign:\n\tret = bpf_sk_assign(skb, sk, 0);\n\tbpf_sk_release(sk);\n\treturn ret;\n}\n\nSEC(\"tc\")\nint bpf_sk_assign_test(struct __sk_buff *skb)\n{\n\tstruct bpf_sock_tuple *tuple;\n\tbool ipv4 = false;\n\tbool tcp = false;\n\tint ret = 0;\n\n\ttuple = get_tuple(skb, &ipv4, &tcp);\n\tif (!tuple)\n\t\treturn TC_ACT_SHOT;\n\n\t \n\tif (tcp)\n\t\tret = handle_tcp(skb, tuple, ipv4);\n\telse\n\t\tret = handle_udp(skb, tuple, ipv4);\n\n\treturn ret == 0 ? TC_ACT_OK : TC_ACT_SHOT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}