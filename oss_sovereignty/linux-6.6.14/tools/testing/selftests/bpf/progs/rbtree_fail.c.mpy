{
  "module_name": "rbtree_fail.c",
  "hash_id": "334377355bc627c966f0283973489eb9271c09bf9858ee1629e19b997d627fd6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/rbtree_fail.c",
  "human_readable_source": "\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_experimental.h\"\n#include \"bpf_misc.h\"\n\nstruct node_data {\n\tlong key;\n\tlong data;\n\tstruct bpf_rb_node node;\n};\n\n#define private(name) SEC(\".data.\" #name) __hidden __attribute__((aligned(8)))\nprivate(A) struct bpf_spin_lock glock;\nprivate(A) struct bpf_rb_root groot __contains(node_data, node);\nprivate(A) struct bpf_rb_root groot2 __contains(node_data, node);\n\nstatic bool less(struct bpf_rb_node *a, const struct bpf_rb_node *b)\n{\n\tstruct node_data *node_a;\n\tstruct node_data *node_b;\n\n\tnode_a = container_of(a, struct node_data, node);\n\tnode_b = container_of(b, struct node_data, node);\n\n\treturn node_a->key < node_b->key;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"bpf_spin_lock at off=16 must be held for bpf_rb_root\")\nlong rbtree_api_nolock_add(void *ctx)\n{\n\tstruct node_data *n;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\tbpf_rbtree_add(&groot, &n->node, less);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"bpf_spin_lock at off=16 must be held for bpf_rb_root\")\nlong rbtree_api_nolock_remove(void *ctx)\n{\n\tstruct node_data *n;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\tbpf_spin_unlock(&glock);\n\n\tbpf_rbtree_remove(&groot, &n->node);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"bpf_spin_lock at off=16 must be held for bpf_rb_root\")\nlong rbtree_api_nolock_first(void *ctx)\n{\n\tbpf_rbtree_first(&groot);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"rbtree_remove node input must be non-owning ref\")\nlong rbtree_api_remove_unadded_node(void *ctx)\n{\n\tstruct node_data *n, *m;\n\tstruct bpf_rb_node *res;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\tm = bpf_obj_new(typeof(*m));\n\tif (!m) {\n\t\tbpf_obj_drop(n);\n\t\treturn 1;\n\t}\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\n\t \n\tres = bpf_rbtree_remove(&groot, &n->node);\n\tn = container_of(res, struct node_data, node);\n\n\t \n\tres = bpf_rbtree_remove(&groot, &m->node);\n\tm = container_of(res, struct node_data, node);\n\tbpf_spin_unlock(&glock);\n\n\tif (n)\n\t\tbpf_obj_drop(n);\n\tif (m)\n\t\tbpf_obj_drop(m);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"Unreleased reference id=3 alloc_insn=10\")\nlong rbtree_api_remove_no_drop(void *ctx)\n{\n\tstruct bpf_rb_node *res;\n\tstruct node_data *n;\n\n\tbpf_spin_lock(&glock);\n\tres = bpf_rbtree_first(&groot);\n\tif (!res)\n\t\tgoto unlock_err;\n\n\tres = bpf_rbtree_remove(&groot, res);\n\n\tif (res) {\n\t\tn = container_of(res, struct node_data, node);\n\t\t__sink(n);\n\t}\n\tbpf_spin_unlock(&glock);\n\n\t \n\treturn 0;\n\nunlock_err:\n\tbpf_spin_unlock(&glock);\n\treturn 1;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"arg#1 expected pointer to allocated object\")\nlong rbtree_api_add_to_multiple_trees(void *ctx)\n{\n\tstruct node_data *n;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\n\t \n\tbpf_rbtree_add(&groot2, &n->node, less);\n\tbpf_spin_unlock(&glock);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"dereference of modified ptr_or_null_ ptr R2 off=16 disallowed\")\nlong rbtree_api_use_unchecked_remove_retval(void *ctx)\n{\n\tstruct bpf_rb_node *res;\n\n\tbpf_spin_lock(&glock);\n\n\tres = bpf_rbtree_first(&groot);\n\tif (!res)\n\t\tgoto err_out;\n\tres = bpf_rbtree_remove(&groot, res);\n\n\tbpf_spin_unlock(&glock);\n\n\tbpf_spin_lock(&glock);\n\t \n\tbpf_rbtree_add(&groot, res, less);\n\tbpf_spin_unlock(&glock);\n\treturn 0;\n\nerr_out:\n\tbpf_spin_unlock(&glock);\n\treturn 1;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"rbtree_remove node input must be non-owning ref\")\nlong rbtree_api_add_release_unlock_escape(void *ctx)\n{\n\tstruct node_data *n;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\tbpf_spin_unlock(&glock);\n\n\tbpf_spin_lock(&glock);\n\t \n\tbpf_rbtree_remove(&groot, &n->node);\n\tbpf_spin_unlock(&glock);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"rbtree_remove node input must be non-owning ref\")\nlong rbtree_api_first_release_unlock_escape(void *ctx)\n{\n\tstruct bpf_rb_node *res;\n\tstruct node_data *n;\n\n\tbpf_spin_lock(&glock);\n\tres = bpf_rbtree_first(&groot);\n\tif (!res) {\n\t\tbpf_spin_unlock(&glock);\n\t\treturn 1;\n\t}\n\tn = container_of(res, struct node_data, node);\n\tbpf_spin_unlock(&glock);\n\n\tbpf_spin_lock(&glock);\n\t \n\tbpf_rbtree_remove(&groot, &n->node);\n\tbpf_spin_unlock(&glock);\n\treturn 0;\n}\n\nstatic bool less__bad_fn_call_add(struct bpf_rb_node *a, const struct bpf_rb_node *b)\n{\n\tstruct node_data *node_a;\n\tstruct node_data *node_b;\n\n\tnode_a = container_of(a, struct node_data, node);\n\tnode_b = container_of(b, struct node_data, node);\n\tbpf_rbtree_add(&groot, &node_a->node, less);\n\n\treturn node_a->key < node_b->key;\n}\n\nstatic bool less__bad_fn_call_remove(struct bpf_rb_node *a, const struct bpf_rb_node *b)\n{\n\tstruct node_data *node_a;\n\tstruct node_data *node_b;\n\n\tnode_a = container_of(a, struct node_data, node);\n\tnode_b = container_of(b, struct node_data, node);\n\tbpf_rbtree_remove(&groot, &node_a->node);\n\n\treturn node_a->key < node_b->key;\n}\n\nstatic bool less__bad_fn_call_first_unlock_after(struct bpf_rb_node *a, const struct bpf_rb_node *b)\n{\n\tstruct node_data *node_a;\n\tstruct node_data *node_b;\n\n\tnode_a = container_of(a, struct node_data, node);\n\tnode_b = container_of(b, struct node_data, node);\n\tbpf_rbtree_first(&groot);\n\tbpf_spin_unlock(&glock);\n\n\treturn node_a->key < node_b->key;\n}\n\nstatic __always_inline\nlong add_with_cb(bool (cb)(struct bpf_rb_node *a, const struct bpf_rb_node *b))\n{\n\tstruct node_data *n;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, cb);\n\tbpf_spin_unlock(&glock);\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"arg#1 expected pointer to allocated object\")\nlong rbtree_api_add_bad_cb_bad_fn_call_add(void *ctx)\n{\n\treturn add_with_cb(less__bad_fn_call_add);\n}\n\nSEC(\"?tc\")\n__failure __msg(\"rbtree_remove not allowed in rbtree cb\")\nlong rbtree_api_add_bad_cb_bad_fn_call_remove(void *ctx)\n{\n\treturn add_with_cb(less__bad_fn_call_remove);\n}\n\nSEC(\"?tc\")\n__failure __msg(\"can't spin_{lock,unlock} in rbtree cb\")\nlong rbtree_api_add_bad_cb_bad_fn_call_first_unlock_after(void *ctx)\n{\n\treturn add_with_cb(less__bad_fn_call_first_unlock_after);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}