{
  "module_name": "cgroup_tcp_skb.c",
  "hash_id": "5f5b9b0b9081ffef94217e0c12f47dc12c42f38fa346fb2b4708cffd8991dfc8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/cgroup_tcp_skb.c",
  "human_readable_source": "\n \n#include <linux/bpf.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_helpers.h>\n\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include \"cgroup_tcp_skb.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n__u16 g_sock_port = 0;\n__u32 g_sock_state = 0;\nint g_unexpected = 0;\n__u32 g_packet_count = 0;\n\nint needed_tcp_pkt(struct __sk_buff *skb, struct tcphdr *tcph)\n{\n\tstruct ipv6hdr ip6h;\n\n\tif (skb->protocol != bpf_htons(ETH_P_IPV6))\n\t\treturn 0;\n\tif (bpf_skb_load_bytes(skb, 0, &ip6h, sizeof(ip6h)))\n\t\treturn 0;\n\n\tif (ip6h.nexthdr != IPPROTO_TCP)\n\t\treturn 0;\n\n\tif (bpf_skb_load_bytes(skb, sizeof(ip6h), tcph, sizeof(*tcph)))\n\t\treturn 0;\n\n\tif (tcph->source != bpf_htons(g_sock_port) &&\n\t    tcph->dest != bpf_htons(g_sock_port))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int egress_accept(struct tcphdr *tcph)\n{\n\tif (g_sock_state ==  SYN_RECV_SENDING_SYN_ACK) {\n\t\tif (tcph->fin || !tcph->syn || !tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = SYN_RECV;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ingress_accept(struct tcphdr *tcph)\n{\n\tswitch (g_sock_state) {\n\tcase INIT:\n\t\tif (!tcph->syn || tcph->fin || tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = SYN_RECV_SENDING_SYN_ACK;\n\t\tbreak;\n\tcase SYN_RECV:\n\t\tif (tcph->fin || tcph->syn || !tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = ESTABLISHED;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int egress_connect(struct tcphdr *tcph)\n{\n\tif (g_sock_state == INIT) {\n\t\tif (!tcph->syn || tcph->fin || tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = SYN_SENT;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ingress_connect(struct tcphdr *tcph)\n{\n\tif (g_sock_state == SYN_SENT) {\n\t\tif (tcph->fin || !tcph->syn || !tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = ESTABLISHED;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int egress_close_remote(struct tcphdr *tcph)\n{\n\tswitch (g_sock_state) {\n\tcase ESTABLISHED:\n\t\tbreak;\n\tcase CLOSE_WAIT_SENDING_ACK:\n\t\tif (tcph->fin || tcph->syn || !tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = CLOSE_WAIT;\n\t\tbreak;\n\tcase CLOSE_WAIT:\n\t\tif (!tcph->fin)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = LAST_ACK;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int ingress_close_remote(struct tcphdr *tcph)\n{\n\tswitch (g_sock_state) {\n\tcase ESTABLISHED:\n\t\tif (tcph->fin)\n\t\t\tg_sock_state = CLOSE_WAIT_SENDING_ACK;\n\t\tbreak;\n\tcase LAST_ACK:\n\t\tif (tcph->fin || tcph->syn || !tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = CLOSED;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int egress_close_local(struct tcphdr *tcph)\n{\n\tswitch (g_sock_state) {\n\tcase ESTABLISHED:\n\t\tif (tcph->fin)\n\t\t\tg_sock_state = FIN_WAIT1;\n\t\tbreak;\n\tcase TIME_WAIT_SENDING_ACK:\n\t\tif (tcph->fin || tcph->syn || !tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = TIME_WAIT;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int ingress_close_local(struct tcphdr *tcph)\n{\n\tswitch (g_sock_state) {\n\tcase ESTABLISHED:\n\t\tbreak;\n\tcase FIN_WAIT1:\n\t\tif (tcph->fin || tcph->syn || !tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = FIN_WAIT2;\n\t\tbreak;\n\tcase FIN_WAIT2:\n\t\tif (!tcph->fin || tcph->syn || !tcph->ack)\n\t\t\tg_unexpected++;\n\t\telse\n\t\t\tg_sock_state = TIME_WAIT_SENDING_ACK;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nSEC(\"cgroup_skb/egress\")\nint server_egress(struct __sk_buff *skb)\n{\n\tstruct tcphdr tcph;\n\n\tif (!needed_tcp_pkt(skb, &tcph))\n\t\treturn 1;\n\n\tg_packet_count++;\n\n\t \n\tif (egress_accept(&tcph) || egress_close_remote(&tcph))\n\t\treturn 1;\n\n\tg_unexpected++;\n\treturn 1;\n}\n\n \nSEC(\"cgroup_skb/ingress\")\nint server_ingress(struct __sk_buff *skb)\n{\n\tstruct tcphdr tcph;\n\n\tif (!needed_tcp_pkt(skb, &tcph))\n\t\treturn 1;\n\n\tg_packet_count++;\n\n\t \n\tif (ingress_accept(&tcph) || ingress_close_remote(&tcph))\n\t\treturn 1;\n\n\tg_unexpected++;\n\treturn 1;\n}\n\n \nSEC(\"cgroup_skb/egress\")\nint server_egress_srv(struct __sk_buff *skb)\n{\n\tstruct tcphdr tcph;\n\n\tif (!needed_tcp_pkt(skb, &tcph))\n\t\treturn 1;\n\n\tg_packet_count++;\n\n\t \n\tif (egress_accept(&tcph) || egress_close_local(&tcph))\n\t\treturn 1;\n\n\tg_unexpected++;\n\treturn 1;\n}\n\n \nSEC(\"cgroup_skb/ingress\")\nint server_ingress_srv(struct __sk_buff *skb)\n{\n\tstruct tcphdr tcph;\n\n\tif (!needed_tcp_pkt(skb, &tcph))\n\t\treturn 1;\n\n\tg_packet_count++;\n\n\t \n\tif (ingress_accept(&tcph) || ingress_close_local(&tcph))\n\t\treturn 1;\n\n\tg_unexpected++;\n\treturn 1;\n}\n\n \nSEC(\"cgroup_skb/egress\")\nint client_egress_srv(struct __sk_buff *skb)\n{\n\tstruct tcphdr tcph;\n\n\tif (!needed_tcp_pkt(skb, &tcph))\n\t\treturn 1;\n\n\tg_packet_count++;\n\n\t \n\tif (egress_connect(&tcph) || egress_close_remote(&tcph))\n\t\treturn 1;\n\n\tg_unexpected++;\n\treturn 1;\n}\n\n \nSEC(\"cgroup_skb/ingress\")\nint client_ingress_srv(struct __sk_buff *skb)\n{\n\tstruct tcphdr tcph;\n\n\tif (!needed_tcp_pkt(skb, &tcph))\n\t\treturn 1;\n\n\tg_packet_count++;\n\n\t \n\tif (ingress_connect(&tcph) || ingress_close_remote(&tcph))\n\t\treturn 1;\n\n\tg_unexpected++;\n\treturn 1;\n}\n\n \nSEC(\"cgroup_skb/egress\")\nint client_egress(struct __sk_buff *skb)\n{\n\tstruct tcphdr tcph;\n\n\tif (!needed_tcp_pkt(skb, &tcph))\n\t\treturn 1;\n\n\tg_packet_count++;\n\n\t \n\tif (egress_connect(&tcph) || egress_close_local(&tcph))\n\t\treturn 1;\n\n\tg_unexpected++;\n\treturn 1;\n}\n\n \nSEC(\"cgroup_skb/ingress\")\nint client_ingress(struct __sk_buff *skb)\n{\n\tstruct tcphdr tcph;\n\n\tif (!needed_tcp_pkt(skb, &tcph))\n\t\treturn 1;\n\n\tg_packet_count++;\n\n\t \n\tif (ingress_connect(&tcph) || ingress_close_local(&tcph))\n\t\treturn 1;\n\n\tg_unexpected++;\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}