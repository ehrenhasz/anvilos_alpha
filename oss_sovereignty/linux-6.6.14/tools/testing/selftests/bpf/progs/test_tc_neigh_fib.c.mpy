{
  "module_name": "test_tc_neigh_fib.c",
  "hash_id": "128f06b19961b210851115861c9a81b7713dca383ad41cd5e8927cfc07872f8d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tc_neigh_fib.c",
  "human_readable_source": "\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n#include <linux/bpf.h>\n#include <linux/stddef.h>\n#include <linux/pkt_cls.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#ifndef ctx_ptr\n# define ctx_ptr(field)\t\t(void *)(long)(field)\n#endif\n\n#define AF_INET 2\n#define AF_INET6 10\n\nstatic __always_inline int fill_fib_params_v4(struct __sk_buff *skb,\n\t\t\t\t\t      struct bpf_fib_lookup *fib_params)\n{\n\tvoid *data_end = ctx_ptr(skb->data_end);\n\tvoid *data = ctx_ptr(skb->data);\n\tstruct iphdr *ip4h;\n\n\tif (data + sizeof(struct ethhdr) > data_end)\n\t\treturn -1;\n\n\tip4h = (struct iphdr *)(data + sizeof(struct ethhdr));\n\tif ((void *)(ip4h + 1) > data_end)\n\t\treturn -1;\n\n\tfib_params->family = AF_INET;\n\tfib_params->tos = ip4h->tos;\n\tfib_params->l4_protocol = ip4h->protocol;\n\tfib_params->sport = 0;\n\tfib_params->dport = 0;\n\tfib_params->tot_len = bpf_ntohs(ip4h->tot_len);\n\tfib_params->ipv4_src = ip4h->saddr;\n\tfib_params->ipv4_dst = ip4h->daddr;\n\n\treturn 0;\n}\n\nstatic __always_inline int fill_fib_params_v6(struct __sk_buff *skb,\n\t\t\t\t\t      struct bpf_fib_lookup *fib_params)\n{\n\tstruct in6_addr *src = (struct in6_addr *)fib_params->ipv6_src;\n\tstruct in6_addr *dst = (struct in6_addr *)fib_params->ipv6_dst;\n\tvoid *data_end = ctx_ptr(skb->data_end);\n\tvoid *data = ctx_ptr(skb->data);\n\tstruct ipv6hdr *ip6h;\n\n\tif (data + sizeof(struct ethhdr) > data_end)\n\t\treturn -1;\n\n\tip6h = (struct ipv6hdr *)(data + sizeof(struct ethhdr));\n\tif ((void *)(ip6h + 1) > data_end)\n\t\treturn -1;\n\n\tfib_params->family = AF_INET6;\n\tfib_params->flowinfo = 0;\n\tfib_params->l4_protocol = ip6h->nexthdr;\n\tfib_params->sport = 0;\n\tfib_params->dport = 0;\n\tfib_params->tot_len = bpf_ntohs(ip6h->payload_len);\n\t*src = ip6h->saddr;\n\t*dst = ip6h->daddr;\n\n\treturn 0;\n}\n\nSEC(\"tc\")\nint tc_chk(struct __sk_buff *skb)\n{\n\tvoid *data_end = ctx_ptr(skb->data_end);\n\tvoid *data = ctx_ptr(skb->data);\n\t__u32 *raw = data;\n\n\tif (data + sizeof(struct ethhdr) > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\treturn !raw[0] && !raw[1] && !raw[2] ? TC_ACT_SHOT : TC_ACT_OK;\n}\n\nstatic __always_inline int tc_redir(struct __sk_buff *skb)\n{\n\tstruct bpf_fib_lookup fib_params = { .ifindex = skb->ingress_ifindex };\n\t__u8 zero[ETH_ALEN * 2];\n\tint ret = -1;\n\n\tswitch (skb->protocol) {\n\tcase __bpf_constant_htons(ETH_P_IP):\n\t\tret = fill_fib_params_v4(skb, &fib_params);\n\t\tbreak;\n\tcase __bpf_constant_htons(ETH_P_IPV6):\n\t\tret = fill_fib_params_v6(skb, &fib_params);\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn TC_ACT_OK;\n\n\tret = bpf_fib_lookup(skb, &fib_params, sizeof(fib_params), 0);\n\tif (ret == BPF_FIB_LKUP_RET_NOT_FWDED || ret < 0)\n\t\treturn TC_ACT_OK;\n\n\t__builtin_memset(&zero, 0, sizeof(zero));\n\tif (bpf_skb_store_bytes(skb, 0, &zero, sizeof(zero), 0) < 0)\n\t\treturn TC_ACT_SHOT;\n\n\tif (ret == BPF_FIB_LKUP_RET_NO_NEIGH) {\n\t\tstruct bpf_redir_neigh nh_params = {};\n\n\t\tnh_params.nh_family = fib_params.family;\n\t\t__builtin_memcpy(&nh_params.ipv6_nh, &fib_params.ipv6_dst,\n\t\t\t\t sizeof(nh_params.ipv6_nh));\n\n\t\treturn bpf_redirect_neigh(fib_params.ifindex, &nh_params,\n\t\t\t\t\t  sizeof(nh_params), 0);\n\n\t} else if (ret == BPF_FIB_LKUP_RET_SUCCESS) {\n\t\tvoid *data_end = ctx_ptr(skb->data_end);\n\t\tstruct ethhdr *eth = ctx_ptr(skb->data);\n\n\t\tif (eth + 1 > data_end)\n\t\t\treturn TC_ACT_SHOT;\n\n\t\t__builtin_memcpy(eth->h_dest, fib_params.dmac, ETH_ALEN);\n\t\t__builtin_memcpy(eth->h_source, fib_params.smac, ETH_ALEN);\n\n\t\treturn bpf_redirect(fib_params.ifindex, 0);\n\t}\n\n\treturn TC_ACT_SHOT;\n}\n\n \nSEC(\"tc\")\nint tc_dst(struct __sk_buff *skb)\n{\n\treturn tc_redir(skb);\n}\n\nSEC(\"tc\")\nint tc_src(struct __sk_buff *skb)\n{\n\treturn tc_redir(skb);\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}