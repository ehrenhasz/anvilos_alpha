{
  "module_name": "bloom_filter_bench.c",
  "hash_id": "e990130ef331ffe0f86554c8a12e6cc99fb0286f9d5f138882b113dd0aefd78e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/bloom_filter_bench.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <linux/bpf.h>\n#include <stdbool.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct bpf_map;\n\n__u8 rand_vals[2500000];\nconst __u32 nr_rand_bytes = 2500000;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(key_size, sizeof(__u32));\n\t \n} array_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_BLOOM_FILTER);\n\t \n\t__uint(map_extra, 3);\n} bloom_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t \n} hashmap SEC(\".maps\");\n\nstruct callback_ctx {\n\tstruct bpf_map *map;\n\tbool update;\n};\n\n \nstruct {\n\t__u32 stats[3];\n} __attribute__((__aligned__(256))) percpu_stats[256];\n\nconst __u32 hit_key  = 0;\nconst __u32 drop_key  = 1;\nconst __u32 false_hit_key = 2;\n\n__u8 value_size;\n\nconst volatile bool hashmap_use_bloom;\nconst volatile bool count_false_hits;\n\nint error = 0;\n\nstatic __always_inline void log_result(__u32 key)\n{\n\t__u32 cpu = bpf_get_smp_processor_id();\n\n\tpercpu_stats[cpu & 255].stats[key]++;\n}\n\nstatic __u64\nbloom_callback(struct bpf_map *map, __u32 *key, void *val,\n\t       struct callback_ctx *data)\n{\n\tint err;\n\n\tif (data->update)\n\t\terr = bpf_map_push_elem(data->map, val, 0);\n\telse\n\t\terr = bpf_map_peek_elem(data->map, val);\n\n\tif (err) {\n\t\terror |= 1;\n\t\treturn 1;  \n\t}\n\n\tlog_result(hit_key);\n\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_getpgid\")\nint bloom_lookup(void *ctx)\n{\n\tstruct callback_ctx data;\n\n\tdata.map = (struct bpf_map *)&bloom_map;\n\tdata.update = false;\n\n\tbpf_for_each_map_elem(&array_map, bloom_callback, &data, 0);\n\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_getpgid\")\nint bloom_update(void *ctx)\n{\n\tstruct callback_ctx data;\n\n\tdata.map = (struct bpf_map *)&bloom_map;\n\tdata.update = true;\n\n\tbpf_for_each_map_elem(&array_map, bloom_callback, &data, 0);\n\n\treturn 0;\n}\n\nSEC(\"fentry/\" SYS_PREFIX \"sys_getpgid\")\nint bloom_hashmap_lookup(void *ctx)\n{\n\t__u64 *result;\n\tint i, err;\n\n\t__u32 index = bpf_get_prandom_u32();\n\t__u32 bitmask = (1ULL << 21) - 1;\n\n\tfor (i = 0; i < 1024; i++, index += value_size) {\n\t\tindex = index & bitmask;\n\n\t\tif (hashmap_use_bloom) {\n\t\t\terr = bpf_map_peek_elem(&bloom_map,\n\t\t\t\t\t\trand_vals + index);\n\t\t\tif (err) {\n\t\t\t\tif (err != -ENOENT) {\n\t\t\t\t\terror |= 2;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tlog_result(hit_key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tresult = bpf_map_lookup_elem(&hashmap,\n\t\t\t\t\t     rand_vals + index);\n\t\tif (result) {\n\t\t\tlog_result(hit_key);\n\t\t} else {\n\t\t\tif (hashmap_use_bloom && count_false_hits)\n\t\t\t\tlog_result(false_hit_key);\n\t\t\tlog_result(drop_key);\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}