{
  "module_name": "test_xdp_do_redirect.c",
  "hash_id": "27cc07730ad46fbb63b05c0057fa9a2cf9f8a20ef7e9cdc0ca30b0f28721ff75",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_xdp_do_redirect.c",
  "human_readable_source": "\n#include <vmlinux.h>\n#include <bpf/bpf_helpers.h>\n\n#define ETH_ALEN 6\n#define HDR_SZ (sizeof(struct ethhdr) + sizeof(struct ipv6hdr) + sizeof(struct udphdr))\n\n \nenum frame_mark {\n\tMARK_XMIT\t= 0U,\n\tMARK_IN\t\t= 0x42,\n\tMARK_SKB\t= 0x45,\n};\n\nconst volatile int ifindex_out;\nconst volatile int ifindex_in;\nconst volatile __u8 expect_dst[ETH_ALEN];\nvolatile int pkts_seen_xdp = 0;\nvolatile int pkts_seen_zero = 0;\nvolatile int pkts_seen_tc = 0;\nvolatile int retcode = XDP_REDIRECT;\n\nSEC(\"xdp\")\nint xdp_redirect(struct xdp_md *xdp)\n{\n\t__u32 *metadata = (void *)(long)xdp->data_meta;\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\tvoid *data = (void *)(long)xdp->data;\n\n\t__u8 *payload = data + HDR_SZ;\n\tint ret = retcode;\n\n\tif (payload + 1 > data_end)\n\t\treturn XDP_ABORTED;\n\n\tif (xdp->ingress_ifindex != ifindex_in)\n\t\treturn XDP_ABORTED;\n\n\tif (metadata + 1 > data)\n\t\treturn XDP_ABORTED;\n\n\tif (*metadata != 0x42)\n\t\treturn XDP_ABORTED;\n\n\tif (*payload == MARK_XMIT)\n\t\tpkts_seen_zero++;\n\n\t*payload = MARK_IN;\n\n\tif (bpf_xdp_adjust_meta(xdp, sizeof(__u64)))\n\t\treturn XDP_ABORTED;\n\n\tif (retcode > XDP_PASS)\n\t\tretcode--;\n\n\tif (ret == XDP_REDIRECT)\n\t\treturn bpf_redirect(ifindex_out, 0);\n\n\treturn ret;\n}\n\nstatic bool check_pkt(void *data, void *data_end, const __u32 mark)\n{\n\tstruct ipv6hdr *iph = data + sizeof(struct ethhdr);\n\t__u8 *payload = data + HDR_SZ;\n\n\tif (payload + 1 > data_end)\n\t\treturn false;\n\n\tif (iph->nexthdr != IPPROTO_UDP || *payload != MARK_IN)\n\t\treturn false;\n\n\t \n\t*payload = mark;\n\treturn true;\n}\n\nSEC(\"xdp\")\nint xdp_count_pkts(struct xdp_md *xdp)\n{\n\tvoid *data = (void *)(long)xdp->data;\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\n\tif (check_pkt(data, data_end, MARK_XMIT))\n\t\tpkts_seen_xdp++;\n\n\t \n\treturn XDP_DROP;\n}\n\nSEC(\"tc\")\nint tc_count_pkts(struct __sk_buff *skb)\n{\n\tvoid *data = (void *)(long)skb->data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\n\tif (check_pkt(data, data_end, MARK_SKB))\n\t\tpkts_seen_tc++;\n\n\t \n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}