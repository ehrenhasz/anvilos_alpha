{
  "module_name": "test_tcp_check_syncookie_kern.c",
  "hash_id": "a518bc8b11d83f548b8f36e1e9229e8e9639d1f736b3fb60265a00099b586c90",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tcp_check_syncookie_kern.c",
  "human_readable_source": "\n\n\n\n#include <string.h>\n\n#include <linux/bpf.h>\n#include <linux/pkt_cls.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <sys/socket.h>\n#include <linux/tcp.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, __u32);\n\t__type(value, __u32);\n\t__uint(max_entries, 3);\n} results SEC(\".maps\");\n\nstatic __always_inline __s64 gen_syncookie(void *data_end, struct bpf_sock *sk,\n\t\t\t\t\t   void *iph, __u32 ip_size,\n\t\t\t\t\t   struct tcphdr *tcph)\n{\n\t__u32 thlen = tcph->doff * 4;\n\n\tif (tcph->syn && !tcph->ack) {\n\t\t\n\t\tif (thlen != 24)\n\t\t\treturn 0;\n\n\t\tif ((void *)tcph + thlen > data_end)\n\t\t\treturn 0;\n\n\t\treturn bpf_tcp_gen_syncookie(sk, iph, ip_size, tcph, thlen);\n\t}\n\treturn 0;\n}\n\nstatic __always_inline void check_syncookie(void *ctx, void *data,\n\t\t\t\t\t    void *data_end)\n{\n\tstruct bpf_sock_tuple tup;\n\tstruct bpf_sock *sk;\n\tstruct ethhdr *ethh;\n\tstruct iphdr *ipv4h;\n\tstruct ipv6hdr *ipv6h;\n\tstruct tcphdr *tcph;\n\tint ret;\n\t__u32 key_mss = 2;\n\t__u32 key_gen = 1;\n\t__u32 key = 0;\n\t__s64 seq_mss;\n\n\tethh = data;\n\tif (ethh + 1 > data_end)\n\t\treturn;\n\n\tswitch (bpf_ntohs(ethh->h_proto)) {\n\tcase ETH_P_IP:\n\t\tipv4h = data + sizeof(struct ethhdr);\n\t\tif (ipv4h + 1 > data_end)\n\t\t\treturn;\n\n\t\tif (ipv4h->ihl != 5)\n\t\t\treturn;\n\n\t\ttcph = data + sizeof(struct ethhdr) + sizeof(struct iphdr);\n\t\tif (tcph + 1 > data_end)\n\t\t\treturn;\n\n\t\ttup.ipv4.saddr = ipv4h->saddr;\n\t\ttup.ipv4.daddr = ipv4h->daddr;\n\t\ttup.ipv4.sport = tcph->source;\n\t\ttup.ipv4.dport = tcph->dest;\n\n\t\tsk = bpf_skc_lookup_tcp(ctx, &tup, sizeof(tup.ipv4),\n\t\t\t\t\tBPF_F_CURRENT_NETNS, 0);\n\t\tif (!sk)\n\t\t\treturn;\n\n\t\tif (sk->state != BPF_TCP_LISTEN)\n\t\t\tgoto release;\n\n\t\tseq_mss = gen_syncookie(data_end, sk, ipv4h, sizeof(*ipv4h),\n\t\t\t\t\ttcph);\n\n\t\tret = bpf_tcp_check_syncookie(sk, ipv4h, sizeof(*ipv4h),\n\t\t\t\t\t      tcph, sizeof(*tcph));\n\t\tbreak;\n\n\tcase ETH_P_IPV6:\n\t\tipv6h = data + sizeof(struct ethhdr);\n\t\tif (ipv6h + 1 > data_end)\n\t\t\treturn;\n\n\t\tif (ipv6h->nexthdr != IPPROTO_TCP)\n\t\t\treturn;\n\n\t\ttcph = data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr);\n\t\tif (tcph + 1 > data_end)\n\t\t\treturn;\n\n\t\tmemcpy(tup.ipv6.saddr, &ipv6h->saddr, sizeof(tup.ipv6.saddr));\n\t\tmemcpy(tup.ipv6.daddr, &ipv6h->daddr, sizeof(tup.ipv6.daddr));\n\t\ttup.ipv6.sport = tcph->source;\n\t\ttup.ipv6.dport = tcph->dest;\n\n\t\tsk = bpf_skc_lookup_tcp(ctx, &tup, sizeof(tup.ipv6),\n\t\t\t\t\tBPF_F_CURRENT_NETNS, 0);\n\t\tif (!sk)\n\t\t\treturn;\n\n\t\tif (sk->state != BPF_TCP_LISTEN)\n\t\t\tgoto release;\n\n\t\tseq_mss = gen_syncookie(data_end, sk, ipv6h, sizeof(*ipv6h),\n\t\t\t\t\ttcph);\n\n\t\tret = bpf_tcp_check_syncookie(sk, ipv6h, sizeof(*ipv6h),\n\t\t\t\t\t      tcph, sizeof(*tcph));\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (seq_mss > 0) {\n\t\t__u32 cookie = (__u32)seq_mss;\n\t\t__u32 mss = seq_mss >> 32;\n\n\t\tbpf_map_update_elem(&results, &key_gen, &cookie, 0);\n\t\tbpf_map_update_elem(&results, &key_mss, &mss, 0);\n\t}\n\n\tif (ret == 0) {\n\t\t__u32 cookie = bpf_ntohl(tcph->ack_seq) - 1;\n\n\t\tbpf_map_update_elem(&results, &key, &cookie, 0);\n\t}\n\nrelease:\n\tbpf_sk_release(sk);\n}\n\nSEC(\"tc\")\nint check_syncookie_clsact(struct __sk_buff *skb)\n{\n\tcheck_syncookie(skb, (void *)(long)skb->data,\n\t\t\t(void *)(long)skb->data_end);\n\treturn TC_ACT_OK;\n}\n\nSEC(\"xdp\")\nint check_syncookie_xdp(struct xdp_md *ctx)\n{\n\tcheck_syncookie(ctx, (void *)(long)ctx->data,\n\t\t\t(void *)(long)ctx->data_end);\n\treturn XDP_PASS;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}