{
  "module_name": "verifier_map_ptr_mixing.c",
  "hash_id": "6afa4a1de680c96c282969646b7d7e150ccf232961fda272a9701634a8c84118",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_map_ptr_mixing.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\n#define MAX_ENTRIES 11\n\nstruct test_val {\n\tunsigned int index;\n\tint foo[MAX_ENTRIES];\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, struct test_val);\n} map_array_48b SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, struct test_val);\n} map_hash_48b SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n\t__array(values, struct {\n\t\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t\t__uint(max_entries, 1);\n\t\t__type(key, int);\n\t\t__type(value, int);\n\t});\n} map_in_map SEC(\".maps\");\n\nvoid dummy_prog_42_socket(void);\nvoid dummy_prog_24_socket(void);\nvoid dummy_prog_loop1_socket(void);\nvoid dummy_prog_loop2_socket(void);\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__uint(max_entries, 4);\n\t__uint(key_size, sizeof(int));\n\t__array(values, void (void));\n} map_prog1_socket SEC(\".maps\") = {\n\t.values = {\n\t\t[0] = (void *)&dummy_prog_42_socket,\n\t\t[1] = (void *)&dummy_prog_loop1_socket,\n\t\t[2] = (void *)&dummy_prog_24_socket,\n\t},\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__uint(max_entries, 8);\n\t__uint(key_size, sizeof(int));\n\t__array(values, void (void));\n} map_prog2_socket SEC(\".maps\") = {\n\t.values = {\n\t\t[1] = (void *)&dummy_prog_loop2_socket,\n\t\t[2] = (void *)&dummy_prog_24_socket,\n\t\t[7] = (void *)&dummy_prog_42_socket,\n\t},\n};\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_42_socket(void)\n{\n\tasm volatile (\"r0 = 42; exit;\");\n}\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_24_socket(void)\n{\n\tasm volatile (\"r0 = 24; exit;\");\n}\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_loop1_socket(void)\n{\n\tasm volatile (\"\t\t\t\\\n\tr3 = 1;\t\t\t\t\\\n\tr2 = %[map_prog1_socket] ll;\t\\\n\tcall %[bpf_tail_call];\t\t\\\n\tr0 = 41;\t\t\t\\\n\texit;\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__auxiliary __auxiliary_unpriv\n__naked void dummy_prog_loop2_socket(void)\n{\n\tasm volatile (\"\t\t\t\\\n\tr3 = 1;\t\t\t\t\\\n\tr2 = %[map_prog2_socket] ll;\t\\\n\tcall %[bpf_tail_call];\t\t\\\n\tr0 = 41;\t\t\t\\\n\texit;\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog2_socket)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"calls: two calls returning different map pointers for lookup (hash, array)\")\n__success __retval(1)\n__naked void pointers_for_lookup_hash_array(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tif r1 != 0 goto l0_%=;\t\t\t\t\\\n\tcall pointers_for_lookup_hash_array__1;\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tcall pointers_for_lookup_hash_array__2;\t\t\\\nl1_%=:\tr1 = r0;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r2;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l2_%=;\t\t\t\t\\\n\tr1 = %[test_val_foo];\t\t\t\t\\\n\t*(u64*)(r0 + 0) = r1;\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\nl2_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nstatic __naked __noinline __attribute__((used))\nvoid pointers_for_lookup_hash_array__1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = %[map_hash_48b] ll;\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_addr(map_hash_48b)\n\t: __clobber_all);\n}\n\nstatic __naked __noinline __attribute__((used))\nvoid pointers_for_lookup_hash_array__2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = %[map_array_48b] ll;\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_addr(map_array_48b)\n\t: __clobber_all);\n}\n\nSEC(\"tc\")\n__description(\"calls: two calls returning different map pointers for lookup (hash, map in map)\")\n__failure __msg(\"only read from bpf_array is supported\")\n__naked void lookup_hash_map_in_map(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tif r1 != 0 goto l0_%=;\t\t\t\t\\\n\tcall lookup_hash_map_in_map__1;\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tcall lookup_hash_map_in_map__2;\t\t\t\\\nl1_%=:\tr1 = r0;\t\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r2;\t\t\t\t\\\n\tr2 = r10;\t\t\t\t\t\\\n\tr2 += -8;\t\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tif r0 == 0 goto l2_%=;\t\t\t\t\\\n\tr1 = %[test_val_foo];\t\t\t\t\\\n\t*(u64*)(r0 + 0) = r1;\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\nl2_%=:\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_const(test_val_foo, offsetof(struct test_val, foo))\n\t: __clobber_all);\n}\n\nstatic __naked __noinline __attribute__((used))\nvoid lookup_hash_map_in_map__1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = %[map_array_48b] ll;\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_addr(map_array_48b)\n\t: __clobber_all);\n}\n\nstatic __naked __noinline __attribute__((used))\nvoid lookup_hash_map_in_map__2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = %[map_in_map] ll;\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_addr(map_in_map)\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"cond: two branches returning different map pointers for lookup (tail, tail)\")\n__success __failure_unpriv __msg_unpriv(\"tail_call abusing map_ptr\")\n__retval(42)\n__naked void pointers_for_lookup_tail_tail_1(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_mark]);\t\t\\\n\tif r6 != 0 goto l0_%=;\t\t\t\t\\\n\tr2 = %[map_prog2_socket] ll;\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr2 = %[map_prog1_socket] ll;\t\t\t\\\nl1_%=:\tr3 = 7;\t\t\t\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog1_socket),\n\t  __imm_addr(map_prog2_socket),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark))\n\t: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"cond: two branches returning same map pointers for lookup (tail, tail)\")\n__success __success_unpriv __retval(42)\n__naked void pointers_for_lookup_tail_tail_2(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr6 = *(u32*)(r1 + %[__sk_buff_mark]);\t\t\\\n\tif r6 == 0 goto l0_%=;\t\t\t\t\\\n\tr2 = %[map_prog2_socket] ll;\t\t\t\\\n\tgoto l1_%=;\t\t\t\t\t\\\nl0_%=:\tr2 = %[map_prog2_socket] ll;\t\t\t\\\nl1_%=:\tr3 = 7;\t\t\t\t\t\t\\\n\tcall %[bpf_tail_call];\t\t\t\t\\\n\tr0 = 1;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_tail_call),\n\t  __imm_addr(map_prog2_socket),\n\t  __imm_const(__sk_buff_mark, offsetof(struct __sk_buff, mark))\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}