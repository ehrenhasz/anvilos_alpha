{
  "module_name": "user_ringbuf_fail.c",
  "hash_id": "652f60e8a0674a7ee753fb409db051b9534d49902b4a953859ce110b0b73f83d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/user_ringbuf_fail.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct sample {\n\tint pid;\n\tint seq;\n\tlong value;\n\tchar comm[16];\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_USER_RINGBUF);\n\t__uint(max_entries, 4096);\n} user_ringbuf SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_RINGBUF);\n\t__uint(max_entries, 2);\n} ringbuf SEC(\".maps\");\n\nstatic int map_value;\n\nstatic long\nbad_access1(struct bpf_dynptr *dynptr, void *context)\n{\n\tconst struct sample *sample;\n\n\tsample = bpf_dynptr_data(dynptr - 1, 0, sizeof(*sample));\n\tbpf_printk(\"Was able to pass bad pointer %lx\\n\", (__u64)dynptr - 1);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"negative offset dynptr_ptr ptr\")\nint user_ringbuf_callback_bad_access1(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, bad_access1, NULL, 0);\n\n\treturn 0;\n}\n\nstatic long\nbad_access2(struct bpf_dynptr *dynptr, void *context)\n{\n\tconst struct sample *sample;\n\n\tsample = bpf_dynptr_data(dynptr + 1, 0, sizeof(*sample));\n\tbpf_printk(\"Was able to pass bad pointer %lx\\n\", (__u64)dynptr + 1);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"dereference of modified dynptr_ptr ptr\")\nint user_ringbuf_callback_bad_access2(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, bad_access2, NULL, 0);\n\n\treturn 0;\n}\n\nstatic long\nwrite_forbidden(struct bpf_dynptr *dynptr, void *context)\n{\n\t*((long *)dynptr) = 0;\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'dynptr_ptr'\")\nint user_ringbuf_callback_write_forbidden(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, write_forbidden, NULL, 0);\n\n\treturn 0;\n}\n\nstatic long\nnull_context_write(struct bpf_dynptr *dynptr, void *context)\n{\n\t*((__u64 *)context) = 0;\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint user_ringbuf_callback_null_context_write(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, null_context_write, NULL, 0);\n\n\treturn 0;\n}\n\nstatic long\nnull_context_read(struct bpf_dynptr *dynptr, void *context)\n{\n\t__u64 id = *((__u64 *)context);\n\n\tbpf_printk(\"Read id %lu\\n\", id);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"invalid mem access 'scalar'\")\nint user_ringbuf_callback_null_context_read(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, null_context_read, NULL, 0);\n\n\treturn 0;\n}\n\nstatic long\ntry_discard_dynptr(struct bpf_dynptr *dynptr, void *context)\n{\n\tbpf_ringbuf_discard_dynptr(dynptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"cannot release unowned const bpf_dynptr\")\nint user_ringbuf_callback_discard_dynptr(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, try_discard_dynptr, NULL, 0);\n\n\treturn 0;\n}\n\nstatic long\ntry_submit_dynptr(struct bpf_dynptr *dynptr, void *context)\n{\n\tbpf_ringbuf_submit_dynptr(dynptr, 0);\n\n\treturn 0;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"cannot release unowned const bpf_dynptr\")\nint user_ringbuf_callback_submit_dynptr(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, try_submit_dynptr, NULL, 0);\n\n\treturn 0;\n}\n\nstatic long\ninvalid_drain_callback_return(struct bpf_dynptr *dynptr, void *context)\n{\n\treturn 2;\n}\n\n \nSEC(\"?raw_tp\")\n__failure __msg(\"At callback return the register R0 has value\")\nint user_ringbuf_callback_invalid_return(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, invalid_drain_callback_return, NULL, 0);\n\n\treturn 0;\n}\n\nstatic long\ntry_reinit_dynptr_mem(struct bpf_dynptr *dynptr, void *context)\n{\n\tbpf_dynptr_from_mem(&map_value, 4, 0, dynptr);\n\treturn 0;\n}\n\nstatic long\ntry_reinit_dynptr_ringbuf(struct bpf_dynptr *dynptr, void *context)\n{\n\tbpf_ringbuf_reserve_dynptr(&ringbuf, 8, 0, dynptr);\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"Dynptr has to be an uninitialized dynptr\")\nint user_ringbuf_callback_reinit_dynptr_mem(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, try_reinit_dynptr_mem, NULL, 0);\n\treturn 0;\n}\n\nSEC(\"?raw_tp\")\n__failure __msg(\"Dynptr has to be an uninitialized dynptr\")\nint user_ringbuf_callback_reinit_dynptr_ringbuf(void *ctx)\n{\n\tbpf_user_ringbuf_drain(&user_ringbuf, try_reinit_dynptr_ringbuf, NULL, 0);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}