{
  "module_name": "test_tc_neigh.c",
  "hash_id": "e7016177b78ebcbfb7d70e871091eaf2fde0d448eb1ab104f5a05d88b2941268",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tc_neigh.c",
  "human_readable_source": "\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#include <linux/bpf.h>\n#include <linux/stddef.h>\n#include <linux/pkt_cls.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#ifndef ctx_ptr\n# define ctx_ptr(field)\t\t(void *)(long)(field)\n#endif\n\n#define ip4_src\t\t\t0xac100164  \n#define ip4_dst\t\t\t0xac100264  \n\n#define ip6_src\t\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \\\n\t\t\t\t  0x00, 0x01, 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe }\n#define ip6_dst\t\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \\\n\t\t\t\t  0x00, 0x02, 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe }\n\n#ifndef v6_equal\n# define v6_equal(a, b)\t\t(a.s6_addr32[0] == b.s6_addr32[0] && \\\n\t\t\t\t a.s6_addr32[1] == b.s6_addr32[1] && \\\n\t\t\t\t a.s6_addr32[2] == b.s6_addr32[2] && \\\n\t\t\t\t a.s6_addr32[3] == b.s6_addr32[3])\n#endif\n\nvolatile const __u32 IFINDEX_SRC;\nvolatile const __u32 IFINDEX_DST;\n\nstatic __always_inline bool is_remote_ep_v4(struct __sk_buff *skb,\n\t\t\t\t\t    __be32 addr)\n{\n\tvoid *data_end = ctx_ptr(skb->data_end);\n\tvoid *data = ctx_ptr(skb->data);\n\tstruct iphdr *ip4h;\n\n\tif (data + sizeof(struct ethhdr) > data_end)\n\t\treturn false;\n\n\tip4h = (struct iphdr *)(data + sizeof(struct ethhdr));\n\tif ((void *)(ip4h + 1) > data_end)\n\t\treturn false;\n\n\treturn ip4h->daddr == addr;\n}\n\nstatic __always_inline bool is_remote_ep_v6(struct __sk_buff *skb,\n\t\t\t\t\t    struct in6_addr addr)\n{\n\tvoid *data_end = ctx_ptr(skb->data_end);\n\tvoid *data = ctx_ptr(skb->data);\n\tstruct ipv6hdr *ip6h;\n\n\tif (data + sizeof(struct ethhdr) > data_end)\n\t\treturn false;\n\n\tip6h = (struct ipv6hdr *)(data + sizeof(struct ethhdr));\n\tif ((void *)(ip6h + 1) > data_end)\n\t\treturn false;\n\n\treturn v6_equal(ip6h->daddr, addr);\n}\n\nSEC(\"tc\")\nint tc_chk(struct __sk_buff *skb)\n{\n\tvoid *data_end = ctx_ptr(skb->data_end);\n\tvoid *data = ctx_ptr(skb->data);\n\t__u32 *raw = data;\n\n\tif (data + sizeof(struct ethhdr) > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\treturn !raw[0] && !raw[1] && !raw[2] ? TC_ACT_SHOT : TC_ACT_OK;\n}\n\nSEC(\"tc\")\nint tc_dst(struct __sk_buff *skb)\n{\n\t__u8 zero[ETH_ALEN * 2];\n\tbool redirect = false;\n\n\tswitch (skb->protocol) {\n\tcase __bpf_constant_htons(ETH_P_IP):\n\t\tredirect = is_remote_ep_v4(skb, __bpf_constant_htonl(ip4_src));\n\t\tbreak;\n\tcase __bpf_constant_htons(ETH_P_IPV6):\n\t\tredirect = is_remote_ep_v6(skb, (struct in6_addr){{ip6_src}});\n\t\tbreak;\n\t}\n\n\tif (!redirect)\n\t\treturn TC_ACT_OK;\n\n\t__builtin_memset(&zero, 0, sizeof(zero));\n\tif (bpf_skb_store_bytes(skb, 0, &zero, sizeof(zero), 0) < 0)\n\t\treturn TC_ACT_SHOT;\n\n\treturn bpf_redirect_neigh(IFINDEX_SRC, NULL, 0, 0);\n}\n\nSEC(\"tc\")\nint tc_src(struct __sk_buff *skb)\n{\n\t__u8 zero[ETH_ALEN * 2];\n\tbool redirect = false;\n\n\tswitch (skb->protocol) {\n\tcase __bpf_constant_htons(ETH_P_IP):\n\t\tredirect = is_remote_ep_v4(skb, __bpf_constant_htonl(ip4_dst));\n\t\tbreak;\n\tcase __bpf_constant_htons(ETH_P_IPV6):\n\t\tredirect = is_remote_ep_v6(skb, (struct in6_addr){{ip6_dst}});\n\t\tbreak;\n\t}\n\n\tif (!redirect)\n\t\treturn TC_ACT_OK;\n\n\t__builtin_memset(&zero, 0, sizeof(zero));\n\tif (bpf_skb_store_bytes(skb, 0, &zero, sizeof(zero), 0) < 0)\n\t\treturn TC_ACT_SHOT;\n\n\treturn bpf_redirect_neigh(IFINDEX_DST, NULL, 0, 0);\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}