{
  "module_name": "test_misc_tcp_hdr_options.c",
  "hash_id": "d5bb2083e4652629f1f69f30046bfcab9699f56591b152440f7f9098489b899c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_misc_tcp_hdr_options.c",
  "human_readable_source": "\n \n\n#include <stddef.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/socket.h>\n#include <linux/bpf.h>\n#include <linux/types.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#define BPF_PROG_TEST_TCP_HDR_OPTIONS\n#include \"test_tcp_hdr_options.h\"\n\n__u16 last_addr16_n = __bpf_htons(1);\n__u16 active_lport_n = 0;\n__u16 active_lport_h = 0;\n__u16 passive_lport_n = 0;\n__u16 passive_lport_h = 0;\n\n \nunsigned int nr_pure_ack = 0;\nunsigned int nr_data = 0;\nunsigned int nr_syn = 0;\nunsigned int nr_fin = 0;\nunsigned int nr_hwtstamp = 0;\n\n \nstatic int __check_active_hdr_in(struct bpf_sock_ops *skops, bool check_syn)\n{\n\tunion {\n\t\tstruct tcphdr th;\n\t\tstruct ipv6hdr ip6;\n\t\tstruct tcp_exprm_opt exprm_opt;\n\t\tstruct tcp_opt reg_opt;\n\t\t__u8 data[100];  \n\t} hdr = {};\n\t__u64 load_flags = check_syn ? BPF_LOAD_HDR_OPT_TCP_SYN : 0;\n\tstruct tcphdr *pth;\n\tint ret;\n\n\thdr.reg_opt.kind = 0xB9;\n\n\t \n\tret = bpf_load_hdr_opt(skops, &hdr.reg_opt, 2, load_flags);\n\tif (ret != -ENOSPC)\n\t\tRET_CG_ERR(ret);\n\n\t \n\thdr.reg_opt.len = 4;\n\tret = bpf_load_hdr_opt(skops, &hdr.reg_opt, sizeof(hdr.reg_opt),\n\t\t\t       load_flags);\n\tif (ret != -EINVAL)\n\t\tRET_CG_ERR(ret);\n\n\thdr.reg_opt.len = 0;\n\tret = bpf_load_hdr_opt(skops, &hdr.reg_opt, sizeof(hdr.reg_opt),\n\t\t\t       load_flags);\n\tif (ret != 4 || hdr.reg_opt.len != 4 || hdr.reg_opt.kind != 0xB9 ||\n\t    hdr.reg_opt.data[0] != 0xfa || hdr.reg_opt.data[1] != 0xce)\n\t\tRET_CG_ERR(ret);\n\n\t \n\thdr.exprm_opt.kind = TCPOPT_EXP;\n\thdr.exprm_opt.len = 5;\n\thdr.exprm_opt.magic = 0;\n\tret = bpf_load_hdr_opt(skops, &hdr.exprm_opt, sizeof(hdr.exprm_opt),\n\t\t\t       load_flags);\n\tif (ret != -EINVAL)\n\t\tRET_CG_ERR(ret);\n\n\t \n\thdr.exprm_opt.len = 4;\n\tret = bpf_load_hdr_opt(skops, &hdr.exprm_opt, sizeof(hdr.exprm_opt),\n\t\t\t       load_flags);\n\tif (ret != -ENOMSG)\n\t\tRET_CG_ERR(ret);\n\n\thdr.exprm_opt.magic = __bpf_htons(0xeB9F);\n\tret = bpf_load_hdr_opt(skops, &hdr.exprm_opt, sizeof(hdr.exprm_opt),\n\t\t\t       load_flags);\n\tif (ret != 4 || hdr.exprm_opt.len != 4 ||\n\t    hdr.exprm_opt.kind != TCPOPT_EXP ||\n\t    hdr.exprm_opt.magic != __bpf_htons(0xeB9F))\n\t\tRET_CG_ERR(ret);\n\n\tif (!check_syn)\n\t\treturn CG_OK;\n\n\t \n\tret = bpf_getsockopt(skops, SOL_TCP, TCP_BPF_SYN_IP, &hdr.ip6,\n\t\t\t     sizeof(hdr.ip6));\n\tif (ret != -ENOSPC)\n\t\tRET_CG_ERR(ret);\n\n\tif (hdr.ip6.saddr.s6_addr16[7] != last_addr16_n ||\n\t    hdr.ip6.daddr.s6_addr16[7] != last_addr16_n)\n\t\tRET_CG_ERR(0);\n\n\tret = bpf_getsockopt(skops, SOL_TCP, TCP_BPF_SYN_IP, &hdr, sizeof(hdr));\n\tif (ret < 0)\n\t\tRET_CG_ERR(ret);\n\n\tpth = (struct tcphdr *)(&hdr.ip6 + 1);\n\tif (pth->dest != passive_lport_n || pth->source != active_lport_n)\n\t\tRET_CG_ERR(0);\n\n\tret = bpf_getsockopt(skops, SOL_TCP, TCP_BPF_SYN, &hdr, sizeof(hdr));\n\tif (ret < 0)\n\t\tRET_CG_ERR(ret);\n\n\tif (hdr.th.dest != passive_lport_n || hdr.th.source != active_lport_n)\n\t\tRET_CG_ERR(0);\n\n\treturn CG_OK;\n}\n\nstatic int check_active_syn_in(struct bpf_sock_ops *skops)\n{\n\treturn __check_active_hdr_in(skops, true);\n}\n\nstatic int check_active_hdr_in(struct bpf_sock_ops *skops)\n{\n\tstruct tcphdr *th;\n\n\tif (__check_active_hdr_in(skops, false) == CG_ERR)\n\t\treturn CG_ERR;\n\n\tth = skops->skb_data;\n\tif (th + 1 > skops->skb_data_end)\n\t\tRET_CG_ERR(0);\n\n\tif (tcp_hdrlen(th) < skops->skb_len)\n\t\tnr_data++;\n\n\tif (th->fin)\n\t\tnr_fin++;\n\n\tif (th->ack && !th->fin && tcp_hdrlen(th) == skops->skb_len)\n\t\tnr_pure_ack++;\n\n\tif (skops->skb_hwtstamp)\n\t\tnr_hwtstamp++;\n\n\treturn CG_OK;\n}\n\nstatic int active_opt_len(struct bpf_sock_ops *skops)\n{\n\tint err;\n\n\t \n\terr = bpf_reserve_hdr_opt(skops, 12, 0);\n\tif (err)\n\t\tRET_CG_ERR(err);\n\n\treturn CG_OK;\n}\n\nstatic int write_active_opt(struct bpf_sock_ops *skops)\n{\n\tstruct tcp_exprm_opt exprm_opt = {};\n\tstruct tcp_opt win_scale_opt = {};\n\tstruct tcp_opt reg_opt = {};\n\tstruct tcphdr *th;\n\tint err, ret;\n\n\texprm_opt.kind = TCPOPT_EXP;\n\texprm_opt.len = 4;\n\texprm_opt.magic = __bpf_htons(0xeB9F);\n\n\treg_opt.kind = 0xB9;\n\treg_opt.len = 4;\n\treg_opt.data[0] = 0xfa;\n\treg_opt.data[1] = 0xce;\n\n\twin_scale_opt.kind = TCPOPT_WINDOW;\n\n\terr = bpf_store_hdr_opt(skops, &exprm_opt, sizeof(exprm_opt), 0);\n\tif (err)\n\t\tRET_CG_ERR(err);\n\n\t \n\terr = bpf_store_hdr_opt(skops, &exprm_opt, sizeof(exprm_opt), 0);\n\tif (err != -EEXIST)\n\t\tRET_CG_ERR(err);\n\n\terr = bpf_store_hdr_opt(skops, &reg_opt, sizeof(reg_opt), 0);\n\tif (err)\n\t\tRET_CG_ERR(err);\n\terr = bpf_store_hdr_opt(skops, &reg_opt, sizeof(reg_opt), 0);\n\tif (err != -EEXIST)\n\t\tRET_CG_ERR(err);\n\n\t \n\tret = bpf_load_hdr_opt(skops, &exprm_opt, sizeof(exprm_opt), 0);\n\tif (ret != 4 || exprm_opt.len != 4 || exprm_opt.kind != TCPOPT_EXP ||\n\t    exprm_opt.magic != __bpf_htons(0xeB9F))\n\t\tRET_CG_ERR(ret);\n\n\treg_opt.len = 0;\n\tret = bpf_load_hdr_opt(skops, &reg_opt, sizeof(reg_opt), 0);\n\tif (ret != 4 || reg_opt.len != 4 || reg_opt.kind != 0xB9 ||\n\t    reg_opt.data[0] != 0xfa || reg_opt.data[1] != 0xce)\n\t\tRET_CG_ERR(ret);\n\n\tth = skops->skb_data;\n\tif (th + 1 > skops->skb_data_end)\n\t\tRET_CG_ERR(0);\n\n\tif (th->syn) {\n\t\tactive_lport_h = skops->local_port;\n\t\tactive_lport_n = th->source;\n\n\t\t \n\t\tret = bpf_load_hdr_opt(skops, &win_scale_opt,\n\t\t\t\t       sizeof(win_scale_opt), 0);\n\t\tif (ret != 3 || win_scale_opt.len != 3 ||\n\t\t    win_scale_opt.kind != TCPOPT_WINDOW)\n\t\t\tRET_CG_ERR(ret);\n\n\t\t \n\t\terr = bpf_store_hdr_opt(skops, &win_scale_opt,\n\t\t\t\t\tsizeof(win_scale_opt), 0);\n\t\tif (err != -EEXIST)\n\t\t\tRET_CG_ERR(err);\n\t}\n\n\treturn CG_OK;\n}\n\nstatic int handle_hdr_opt_len(struct bpf_sock_ops *skops)\n{\n\t__u8 tcp_flags = skops_tcp_flags(skops);\n\n\tif ((tcp_flags & TCPHDR_SYNACK) == TCPHDR_SYNACK)\n\t\t \n\t\treturn check_active_syn_in(skops);\n\n\t \n\tif (skops->local_port == passive_lport_h)\n\t\tRET_CG_ERR(0);\n\n\treturn active_opt_len(skops);\n}\n\nstatic int handle_write_hdr_opt(struct bpf_sock_ops *skops)\n{\n\tif (skops->local_port == passive_lport_h)\n\t\tRET_CG_ERR(0);\n\n\treturn write_active_opt(skops);\n}\n\nstatic int handle_parse_hdr(struct bpf_sock_ops *skops)\n{\n\t \n\tif (skops->local_port == active_lport_h)\n\t\tRET_CG_ERR(0);\n\n\treturn check_active_hdr_in(skops);\n}\n\nstatic int handle_passive_estab(struct bpf_sock_ops *skops)\n{\n\tint err;\n\n\t \n\tbpf_sock_ops_cb_flags_set(skops,\n\t\t\t\t  skops->bpf_sock_ops_cb_flags &\n\t\t\t\t  ~BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG);\n\n\t \n\terr = check_active_syn_in(skops);\n\tif (err == CG_ERR)\n\t\treturn err;\n\n\tnr_syn++;\n\n\t \n\treturn check_active_hdr_in(skops);\n}\n\nSEC(\"sockops\")\nint misc_estab(struct bpf_sock_ops *skops)\n{\n\tint true_val = 1;\n\n\tswitch (skops->op) {\n\tcase BPF_SOCK_OPS_TCP_LISTEN_CB:\n\t\tpassive_lport_h = skops->local_port;\n\t\tpassive_lport_n = __bpf_htons(passive_lport_h);\n\t\tbpf_setsockopt(skops, SOL_TCP, TCP_SAVE_SYN,\n\t\t\t       &true_val, sizeof(true_val));\n\t\tset_hdr_cb_flags(skops, 0);\n\t\tbreak;\n\tcase BPF_SOCK_OPS_TCP_CONNECT_CB:\n\t\tset_hdr_cb_flags(skops, 0);\n\t\tbreak;\n\tcase BPF_SOCK_OPS_PARSE_HDR_OPT_CB:\n\t\treturn handle_parse_hdr(skops);\n\tcase BPF_SOCK_OPS_HDR_OPT_LEN_CB:\n\t\treturn handle_hdr_opt_len(skops);\n\tcase BPF_SOCK_OPS_WRITE_HDR_OPT_CB:\n\t\treturn handle_write_hdr_opt(skops);\n\tcase BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB:\n\t\treturn handle_passive_estab(skops);\n\t}\n\n\treturn CG_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}