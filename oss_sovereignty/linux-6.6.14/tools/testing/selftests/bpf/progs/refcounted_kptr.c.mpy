{
  "module_name": "refcounted_kptr.c",
  "hash_id": "145400a0888fa2bc69982c5cebe2c03f658ffb5eed75e9a109187f4908974cfb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/refcounted_kptr.c",
  "human_readable_source": "\n \n\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_misc.h\"\n#include \"bpf_experimental.h\"\n\nextern void bpf_rcu_read_lock(void) __ksym;\nextern void bpf_rcu_read_unlock(void) __ksym;\n\nstruct node_data {\n\tlong key;\n\tlong list_data;\n\tstruct bpf_rb_node r;\n\tstruct bpf_list_node l;\n\tstruct bpf_refcount ref;\n};\n\nstruct map_value {\n\tstruct node_data __kptr *node;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, int);\n\t__type(value, struct map_value);\n\t__uint(max_entries, 2);\n} stashed_nodes SEC(\".maps\");\n\nstruct node_acquire {\n\tlong key;\n\tlong data;\n\tstruct bpf_rb_node node;\n\tstruct bpf_refcount refcount;\n};\n\n#define private(name) SEC(\".bss.\" #name) __hidden __attribute__((aligned(8)))\nprivate(A) struct bpf_spin_lock lock;\nprivate(A) struct bpf_rb_root root __contains(node_data, r);\nprivate(A) struct bpf_list_head head __contains(node_data, l);\n\nprivate(B) struct bpf_spin_lock alock;\nprivate(B) struct bpf_rb_root aroot __contains(node_acquire, node);\n\nprivate(C) struct bpf_spin_lock block;\nprivate(C) struct bpf_rb_root broot __contains(node_data, r);\n\nstatic bool less(struct bpf_rb_node *node_a, const struct bpf_rb_node *node_b)\n{\n\tstruct node_data *a;\n\tstruct node_data *b;\n\n\ta = container_of(node_a, struct node_data, r);\n\tb = container_of(node_b, struct node_data, r);\n\n\treturn a->key < b->key;\n}\n\nstatic bool less_a(struct bpf_rb_node *a, const struct bpf_rb_node *b)\n{\n\tstruct node_acquire *node_a;\n\tstruct node_acquire *node_b;\n\n\tnode_a = container_of(a, struct node_acquire, node);\n\tnode_b = container_of(b, struct node_acquire, node);\n\n\treturn node_a->key < node_b->key;\n}\n\nstatic long __insert_in_tree_and_list(struct bpf_list_head *head,\n\t\t\t\t      struct bpf_rb_root *root,\n\t\t\t\t      struct bpf_spin_lock *lock)\n{\n\tstruct node_data *n, *m;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn -1;\n\n\tm = bpf_refcount_acquire(n);\n\tm->key = 123;\n\tm->list_data = 456;\n\n\tbpf_spin_lock(lock);\n\tif (bpf_rbtree_add(root, &n->r, less)) {\n\t\t \n\t\tbpf_spin_unlock(lock);\n\t\tbpf_obj_drop(m);\n\t\treturn -2;\n\t}\n\tbpf_spin_unlock(lock);\n\n\tbpf_spin_lock(lock);\n\tif (bpf_list_push_front(head, &m->l)) {\n\t\t \n\t\tbpf_spin_unlock(lock);\n\t\treturn -3;\n\t}\n\tbpf_spin_unlock(lock);\n\treturn 0;\n}\n\nstatic long __stash_map_insert_tree(int idx, int val, struct bpf_rb_root *root,\n\t\t\t\t    struct bpf_spin_lock *lock)\n{\n\tstruct map_value *mapval;\n\tstruct node_data *n, *m;\n\n\tmapval = bpf_map_lookup_elem(&stashed_nodes, &idx);\n\tif (!mapval)\n\t\treturn -1;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn -2;\n\n\tn->key = val;\n\tm = bpf_refcount_acquire(n);\n\n\tn = bpf_kptr_xchg(&mapval->node, n);\n\tif (n) {\n\t\tbpf_obj_drop(n);\n\t\tbpf_obj_drop(m);\n\t\treturn -3;\n\t}\n\n\tbpf_spin_lock(lock);\n\tif (bpf_rbtree_add(root, &m->r, less)) {\n\t\t \n\t\tbpf_spin_unlock(lock);\n\t\treturn -4;\n\t}\n\tbpf_spin_unlock(lock);\n\treturn 0;\n}\n\nstatic long __read_from_tree(struct bpf_rb_root *root,\n\t\t\t     struct bpf_spin_lock *lock,\n\t\t\t     bool remove_from_tree)\n{\n\tstruct bpf_rb_node *rb;\n\tstruct node_data *n;\n\tlong res = -99;\n\n\tbpf_spin_lock(lock);\n\n\trb = bpf_rbtree_first(root);\n\tif (!rb) {\n\t\tbpf_spin_unlock(lock);\n\t\treturn -1;\n\t}\n\n\tn = container_of(rb, struct node_data, r);\n\tres = n->key;\n\n\tif (!remove_from_tree) {\n\t\tbpf_spin_unlock(lock);\n\t\treturn res;\n\t}\n\n\trb = bpf_rbtree_remove(root, rb);\n\tbpf_spin_unlock(lock);\n\tif (!rb)\n\t\treturn -2;\n\tn = container_of(rb, struct node_data, r);\n\tbpf_obj_drop(n);\n\treturn res;\n}\n\nstatic long __read_from_list(struct bpf_list_head *head,\n\t\t\t     struct bpf_spin_lock *lock,\n\t\t\t     bool remove_from_list)\n{\n\tstruct bpf_list_node *l;\n\tstruct node_data *n;\n\tlong res = -99;\n\n\tbpf_spin_lock(lock);\n\n\tl = bpf_list_pop_front(head);\n\tif (!l) {\n\t\tbpf_spin_unlock(lock);\n\t\treturn -1;\n\t}\n\n\tn = container_of(l, struct node_data, l);\n\tres = n->list_data;\n\n\tif (!remove_from_list) {\n\t\tif (bpf_list_push_back(head, &n->l)) {\n\t\t\tbpf_spin_unlock(lock);\n\t\t\treturn -2;\n\t\t}\n\t}\n\n\tbpf_spin_unlock(lock);\n\n\tif (remove_from_list)\n\t\tbpf_obj_drop(n);\n\treturn res;\n}\n\nstatic long __read_from_unstash(int idx)\n{\n\tstruct node_data *n = NULL;\n\tstruct map_value *mapval;\n\tlong val = -99;\n\n\tmapval = bpf_map_lookup_elem(&stashed_nodes, &idx);\n\tif (!mapval)\n\t\treturn -1;\n\n\tn = bpf_kptr_xchg(&mapval->node, n);\n\tif (!n)\n\t\treturn -2;\n\n\tval = n->key;\n\tbpf_obj_drop(n);\n\treturn val;\n}\n\n#define INSERT_READ_BOTH(rem_tree, rem_list, desc)\t\t\t\\\nSEC(\"tc\")\t\t\t\t\t\t\t\t\\\n__description(desc)\t\t\t\t\t\t\t\\\n__success __retval(579)\t\t\t\t\t\t\t\\\nlong insert_and_remove_tree_##rem_tree##_list_##rem_list(void *ctx)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tlong err, tree_data, list_data;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __insert_in_tree_and_list(&head, &root, &lock);\t\t\\\n\tif (err)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __read_from_tree(&root, &lock, rem_tree);\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\ttree_data = err;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __read_from_list(&head, &lock, rem_list);\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tlist_data = err;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn tree_data + list_data;\t\t\t\t\t\\\n}\n\n \nINSERT_READ_BOTH(true, true, \"insert_read_both: remove from tree + list\");\nINSERT_READ_BOTH(false, false, \"insert_read_both: remove from neither\");\nINSERT_READ_BOTH(true, false, \"insert_read_both: remove from tree\");\nINSERT_READ_BOTH(false, true, \"insert_read_both: remove from list\");\n\n#undef INSERT_READ_BOTH\n#define INSERT_READ_BOTH(rem_tree, rem_list, desc)\t\t\t\\\nSEC(\"tc\")\t\t\t\t\t\t\t\t\\\n__description(desc)\t\t\t\t\t\t\t\\\n__success __retval(579)\t\t\t\t\t\t\t\\\nlong insert_and_remove_lf_tree_##rem_tree##_list_##rem_list(void *ctx)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tlong err, tree_data, list_data;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __insert_in_tree_and_list(&head, &root, &lock);\t\t\\\n\tif (err)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __read_from_list(&head, &lock, rem_list);\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tlist_data = err;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __read_from_tree(&root, &lock, rem_tree);\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\ttree_data = err;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn tree_data + list_data;\t\t\t\t\t\\\n}\n\n \nINSERT_READ_BOTH(true, true, \"insert_read_both_list_first: remove from tree + list\");\nINSERT_READ_BOTH(false, false, \"insert_read_both_list_first: remove from neither\");\nINSERT_READ_BOTH(true, false, \"insert_read_both_list_first: remove from tree\");\nINSERT_READ_BOTH(false, true, \"insert_read_both_list_first: remove from list\");\n\n#define INSERT_DOUBLE_READ_AND_DEL(read_fn, read_root, desc)\t\t\\\nSEC(\"tc\")\t\t\t\t\t\t\t\t\\\n__description(desc)\t\t\t\t\t\t\t\\\n__success __retval(-1)\t\t\t\t\t\t\t\\\nlong insert_double_##read_fn##_and_del_##read_root(void *ctx)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tlong err, list_data;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __insert_in_tree_and_list(&head, &root, &lock);\t\t\\\n\tif (err)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = read_fn(&read_root, &lock, true);\t\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tlist_data = err;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = read_fn(&read_root, &lock, true);\t\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn err + list_data;\t\t\t\t\t\t\\\n}\n\n \nINSERT_DOUBLE_READ_AND_DEL(__read_from_tree, root, \"insert_double_del: 2x read-and-del from tree\");\nINSERT_DOUBLE_READ_AND_DEL(__read_from_list, head, \"insert_double_del: 2x read-and-del from list\");\n\n#define INSERT_STASH_READ(rem_tree, desc)\t\t\t\t\\\nSEC(\"tc\")\t\t\t\t\t\t\t\t\\\n__description(desc)\t\t\t\t\t\t\t\\\n__success __retval(84)\t\t\t\t\t\t\t\\\nlong insert_rbtree_and_stash__del_tree_##rem_tree(void *ctx)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tlong err, tree_data, map_data;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __stash_map_insert_tree(0, 42, &root, &lock);\t\t\\\n\tif (err)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __read_from_tree(&root, &lock, rem_tree);\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\ttree_data = err;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = __read_from_unstash(0);\t\t\t\t\t\\\n\tif (err < 0)\t\t\t\t\t\t\t\\\n\t\treturn err;\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tmap_data = err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn tree_data + map_data;\t\t\t\t\t\\\n}\n\n \nINSERT_STASH_READ(true, \"insert_stash_read: remove from tree\");\nINSERT_STASH_READ(false, \"insert_stash_read: don't remove from tree\");\n\nSEC(\"tc\")\n__success\nlong rbtree_refcounted_node_ref_escapes(void *ctx)\n{\n\tstruct node_acquire *n, *m;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\tbpf_spin_lock(&alock);\n\tbpf_rbtree_add(&aroot, &n->node, less_a);\n\tm = bpf_refcount_acquire(n);\n\tbpf_spin_unlock(&alock);\n\tif (!m)\n\t\treturn 2;\n\n\tm->key = 2;\n\tbpf_obj_drop(m);\n\treturn 0;\n}\n\nSEC(\"tc\")\n__success\nlong rbtree_refcounted_node_ref_escapes_owning_input(void *ctx)\n{\n\tstruct node_acquire *n, *m;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\tm = bpf_refcount_acquire(n);\n\tm->key = 2;\n\n\tbpf_spin_lock(&alock);\n\tbpf_rbtree_add(&aroot, &n->node, less_a);\n\tbpf_spin_unlock(&alock);\n\n\tbpf_obj_drop(m);\n\n\treturn 0;\n}\n\nstatic long __stash_map_empty_xchg(struct node_data *n, int idx)\n{\n\tstruct map_value *mapval = bpf_map_lookup_elem(&stashed_nodes, &idx);\n\n\tif (!mapval) {\n\t\tbpf_obj_drop(n);\n\t\treturn 1;\n\t}\n\tn = bpf_kptr_xchg(&mapval->node, n);\n\tif (n) {\n\t\tbpf_obj_drop(n);\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nSEC(\"tc\")\nlong rbtree_wrong_owner_remove_fail_a1(void *ctx)\n{\n\tstruct node_data *n, *m;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\tm = bpf_refcount_acquire(n);\n\n\tif (__stash_map_empty_xchg(n, 0)) {\n\t\tbpf_obj_drop(m);\n\t\treturn 2;\n\t}\n\n\tif (__stash_map_empty_xchg(m, 1))\n\t\treturn 3;\n\n\treturn 0;\n}\n\nSEC(\"tc\")\nlong rbtree_wrong_owner_remove_fail_b(void *ctx)\n{\n\tstruct map_value *mapval;\n\tstruct node_data *n;\n\tint idx = 0;\n\n\tmapval = bpf_map_lookup_elem(&stashed_nodes, &idx);\n\tif (!mapval)\n\t\treturn 1;\n\n\tn = bpf_kptr_xchg(&mapval->node, NULL);\n\tif (!n)\n\t\treturn 2;\n\n\tbpf_spin_lock(&block);\n\n\tbpf_rbtree_add(&broot, &n->r, less);\n\n\tbpf_spin_unlock(&block);\n\treturn 0;\n}\n\nSEC(\"tc\")\nlong rbtree_wrong_owner_remove_fail_a2(void *ctx)\n{\n\tstruct map_value *mapval;\n\tstruct bpf_rb_node *res;\n\tstruct node_data *m;\n\tint idx = 1;\n\n\tmapval = bpf_map_lookup_elem(&stashed_nodes, &idx);\n\tif (!mapval)\n\t\treturn 1;\n\n\tm = bpf_kptr_xchg(&mapval->node, NULL);\n\tif (!m)\n\t\treturn 2;\n\tbpf_spin_lock(&lock);\n\n\t \n\tbpf_list_push_back(&head, &m->l);\n\tres = bpf_rbtree_remove(&root, &m->r);\n\n\tbpf_spin_unlock(&lock);\n\tif (res) {\n\t\tbpf_obj_drop(container_of(res, struct node_data, r));\n\t\treturn 3;\n\t}\n\treturn 0;\n}\n\nSEC(\"?fentry.s/bpf_testmod_test_read\")\n__success\nint BPF_PROG(rbtree_sleepable_rcu,\n\t     struct file *file, struct kobject *kobj,\n\t     struct bin_attribute *bin_attr, char *buf, loff_t off, size_t len)\n{\n\tstruct bpf_rb_node *rb;\n\tstruct node_data *n, *m = NULL;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 0;\n\n\tbpf_rcu_read_lock();\n\tbpf_spin_lock(&lock);\n\tbpf_rbtree_add(&root, &n->r, less);\n\trb = bpf_rbtree_first(&root);\n\tif (!rb)\n\t\tgoto err_out;\n\n\trb = bpf_rbtree_remove(&root, rb);\n\tif (!rb)\n\t\tgoto err_out;\n\n\tm = container_of(rb, struct node_data, r);\n\nerr_out:\n\tbpf_spin_unlock(&lock);\n\tbpf_rcu_read_unlock();\n\tif (m)\n\t\tbpf_obj_drop(m);\n\treturn 0;\n}\n\nSEC(\"?fentry.s/bpf_testmod_test_read\")\n__success\nint BPF_PROG(rbtree_sleepable_rcu_no_explicit_rcu_lock,\n\t     struct file *file, struct kobject *kobj,\n\t     struct bin_attribute *bin_attr, char *buf, loff_t off, size_t len)\n{\n\tstruct bpf_rb_node *rb;\n\tstruct node_data *n, *m = NULL;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 0;\n\n\t \n\tbpf_spin_lock(&lock);\n\tbpf_rbtree_add(&root, &n->r, less);\n\trb = bpf_rbtree_first(&root);\n\tif (!rb)\n\t\tgoto err_out;\n\n\trb = bpf_rbtree_remove(&root, rb);\n\tif (!rb)\n\t\tgoto err_out;\n\n\tm = container_of(rb, struct node_data, r);\n\nerr_out:\n\tbpf_spin_unlock(&lock);\n\t \n\tif (m)\n\t\tbpf_obj_drop(m);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}