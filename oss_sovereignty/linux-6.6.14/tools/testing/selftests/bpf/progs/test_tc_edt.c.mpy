{
  "module_name": "test_tc_edt.c",
  "hash_id": "6cba846ead5310831b98bcb75f316f9b9aab7154d0dcdbb5f2d9db640937772b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tc_edt.c",
  "human_readable_source": "\n#include <stdint.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/stddef.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/pkt_cls.h>\n#include <linux/tcp.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n \n#define TIME_HORIZON_NS (2000 * 1000 * 1000)\n#define NS_PER_SEC 1000000000\n#define ECN_HORIZON_NS 5000000\n#define THROTTLE_RATE_BPS (5 * 1000 * 1000)\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, uint32_t);\n\t__type(value, uint64_t);\n\t__uint(max_entries, 1);\n} flow_map SEC(\".maps\");\n\nstatic inline int throttle_flow(struct __sk_buff *skb)\n{\n\tint key = 0;\n\tuint64_t *last_tstamp = bpf_map_lookup_elem(&flow_map, &key);\n\tuint64_t delay_ns = ((uint64_t)skb->len) * NS_PER_SEC /\n\t\t\tTHROTTLE_RATE_BPS;\n\tuint64_t now = bpf_ktime_get_ns();\n\tuint64_t tstamp, next_tstamp = 0;\n\n\tif (last_tstamp)\n\t\tnext_tstamp = *last_tstamp + delay_ns;\n\n\ttstamp = skb->tstamp;\n\tif (tstamp < now)\n\t\ttstamp = now;\n\n\t \n\tif (next_tstamp <= tstamp) {\n\t\tif (bpf_map_update_elem(&flow_map, &key, &tstamp, BPF_ANY))\n\t\t\treturn TC_ACT_SHOT;\n\t\treturn TC_ACT_OK;\n\t}\n\n\t \n\tif (next_tstamp - now >= TIME_HORIZON_NS)\n\t\treturn TC_ACT_SHOT;\n\n\t \n\tif (next_tstamp - now >= ECN_HORIZON_NS)\n\t\tbpf_skb_ecn_set_ce(skb);\n\n\tif (bpf_map_update_elem(&flow_map, &key, &next_tstamp, BPF_EXIST))\n\t\treturn TC_ACT_SHOT;\n\tskb->tstamp = next_tstamp;\n\n\treturn TC_ACT_OK;\n}\n\nstatic inline int handle_tcp(struct __sk_buff *skb, struct tcphdr *tcp)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\n\t \n\tif ((void *)(tcp + 1) > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tif (tcp->dest == bpf_htons(9000))\n\t\treturn throttle_flow(skb);\n\n\treturn TC_ACT_OK;\n}\n\nstatic inline int handle_ipv4(struct __sk_buff *skb)\n{\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tvoid *data = (void *)(long)skb->data;\n\tstruct iphdr *iph;\n\tuint32_t ihl;\n\n\t \n\tif (data + sizeof(struct ethhdr) > data_end)\n\t\treturn TC_ACT_SHOT;\n\tiph = (struct iphdr *)(data + sizeof(struct ethhdr));\n\tif ((void *)(iph + 1) > data_end)\n\t\treturn TC_ACT_SHOT;\n\tihl = iph->ihl * 4;\n\tif (((void *)iph) + ihl > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tif (iph->protocol == IPPROTO_TCP)\n\t\treturn handle_tcp(skb, (struct tcphdr *)(((void *)iph) + ihl));\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"cls_test\") int tc_prog(struct __sk_buff *skb)\n{\n\tif (skb->protocol == bpf_htons(ETH_P_IP))\n\t\treturn handle_ipv4(skb);\n\n\treturn TC_ACT_OK;\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}