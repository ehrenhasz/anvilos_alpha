{
  "module_name": "verifier_var_off.c",
  "hash_id": "cbed1c388f8d42bdd8f91b9e75985a6e82e83ad32262ebc65f26dd3ebd4f906b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_var_off.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, 1);\n\t__type(key, long long);\n\t__type(value, long long);\n} map_hash_8b SEC(\".maps\");\n\nSEC(\"lwt_in\")\n__description(\"variable-offset ctx access\")\n__failure __msg(\"variable ctx access var_off=(0x0; 0x4)\")\n__naked void variable_offset_ctx_access(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 4;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr1 += r2;\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tr0 = *(u32*)(r1 + 0);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"variable-offset stack read, priv vs unpriv\")\n__success __failure_unpriv\n__msg_unpriv(\"R2 variable stack access prohibited for !root\")\n__retval(0)\n__naked void stack_read_priv_vs_unpriv(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 4;\t\t\t\t\t\\\n\tr2 -= 8;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr2 += r10;\t\t\t\t\t\\\n\t \t\t\\\n\tr0 = *(u32*)(r2 + 0);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"variable-offset stack read, uninitialized\")\n__success\n__failure_unpriv __msg_unpriv(\"R2 variable stack access prohibited for !root\")\n__naked void variable_offset_stack_read_uninitialized(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 4;\t\t\t\t\t\\\n\tr2 -= 8;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr2 += r10;\t\t\t\t\t\\\n\t \t\t\\\n\tr0 = *(u32*)(r2 + 0);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"variable-offset stack write, priv vs unpriv\")\n__success\n/* Check that the maximum stack depth is correctly maintained according to the\n * maximum possible variable offset.\n */\n__log_level(4) __msg(\"stack depth 16\")\n__failure_unpriv\n/* Variable stack access is rejected for unprivileged.\n */\n__msg_unpriv(\"R2 variable stack access prohibited for !root\")\n__retval(0)\n__naked void stack_write_priv_vs_unpriv(void)\n{\n\tasm volatile (\"                               \\\n\t                     \\\n\tr2 = *(u32*)(r1 + 0);                         \\\n\t         \\\n\tr2 &= 8;                                      \\\n\tr2 -= 16;                                     \\\n\t                                            \\\n\tr2 += r10;                                    \\\n\t         \\\n\tr0 = 0;                                       \\\n\t*(u64*)(r2 + 0) = r0;                         \\\n\texit;                                         \\\n\"\t::: __clobber_all);\n}\n\n/* Similar to the previous test, but this time also perform a read from the\n * address written to with a variable offset. The read is allowed, showing that,\n * after a variable-offset write, a priviledged program can read the slots that\n * were in the range of that write (even if the verifier doesn't actually know if\n * the slot being read was really written to or not.\n *\n * Despite this test being mostly a superset, the previous test is also kept for\n * the sake of it checking the stack depth in the case where there is no read.\n */\nSEC(\"socket\")\n__description(\"variable-offset stack write followed by read\")\n__success\n/* Check that the maximum stack depth is correctly maintained according to the\n * maximum possible variable offset.\n */\n__log_level(4) __msg(\"stack depth 16\")\n__failure_unpriv\n__msg_unpriv(\"R2 variable stack access prohibited for !root\")\n__retval(0)\n__naked void stack_write_followed_by_read(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 8;\t\t\t\t\t\\\n\tr2 -= 16;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr2 += r10;\t\t\t\t\t\\\n\t \t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r0;\t\t\t\t\\\n\t  \\\n\tr3 = *(u64*)(r2 + 0);\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t::: __clobber_all);\n}\n\nSEC(\"socket\")\n__description(\"variable-offset stack write clobbers spilled regs\")\n__failure\n/* In the priviledged case, dereferencing a spilled-and-then-filled\n * register is rejected because the previous variable offset stack\n * write might have overwritten the spilled pointer (i.e. we lose track\n * of the spilled register when we analyze the write).\n */\n__msg(\"R2 invalid mem access 'scalar'\")\n__failure_unpriv\n/* The unprivileged case is not too interesting; variable\n * stack access is rejected.\n */\n__msg_unpriv(\"R2 variable stack access prohibited for !root\")\n__naked void stack_write_clobbers_spilled_regs(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr6 = 0;\t\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tr0 = %[map_hash_8b] ll;\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 8;\t\t\t\t\t\\\n\tr2 -= 16;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr2 += r10;\t\t\t\t\t\\\n\t \t\t\\\n\t*(u64*)(r10 - 8) = r0;\t\t\t\t\\\n\t \\\n\tr0 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r2 + 0) = r0;\t\t\t\t\\\n\t \t\t\\\n\tr2 = *(u64*)(r10 - 8);\t\t\t\t\\\n\t \t\\\n\tr0 = *(u64*)(r2 + 8);\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"sockops\")\n__description(\"indirect variable-offset stack access, unbounded\")\n__failure __msg(\"invalid unbounded variable-offset indirect access to stack R4\")\n__naked void variable_offset_stack_access_unbounded(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = 6;\t\t\t\t\t\t\\\n\tr3 = 28;\t\t\t\t\t\\\n\t \t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 16) = r4;\t\t\t\t\\\n\tr4 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r4;\t\t\t\t\\\n\t \t\t\t\\\n\tr4 = *(u64*)(r1 + %[bpf_sock_ops_bytes_received]);\\\n\t \\\n\tif r4 s< 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr4 -= 16;\t\t\t\t\t\\\n\tr4 += r10;\t\t\t\t\t\\\n\tr5 = 8;\t\t\t\t\t\t\\\n\t \t\t\\\n\tcall %[bpf_getsockopt];\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_getsockopt),\n\t  __imm_const(bpf_sock_ops_bytes_received, offsetof(struct bpf_sock_ops, bytes_received))\n\t: __clobber_all);\n}\n\nSEC(\"lwt_in\")\n__description(\"indirect variable-offset stack access, max out of bound\")\n__failure __msg(\"invalid variable-offset indirect access to stack R2\")\n__naked void access_max_out_of_bound(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r2;\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 4;\t\t\t\t\t\\\n\tr2 -= 8;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr2 += r10;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"lwt_in\")\n__description(\"indirect variable-offset stack access, min out of bound\")\n__failure __msg(\"invalid variable-offset indirect access to stack R2\")\n__naked void access_min_out_of_bound(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r2;\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 4;\t\t\t\t\t\\\n\tr2 -= 516;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr2 += r10;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"indirect variable-offset stack access, min_off < min_initialized\")\n__success\n__failure_unpriv __msg_unpriv(\"R2 variable stack access prohibited for !root\")\n__naked void access_min_off_min_initialized(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r2;\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 4;\t\t\t\t\t\\\n\tr2 -= 16;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr2 += r10;\t\t\t\t\t\\\n\t \t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"cgroup/skb\")\n__description(\"indirect variable-offset stack access, priv vs unpriv\")\n__success __failure_unpriv\n__msg_unpriv(\"R2 variable stack access prohibited for !root\")\n__retval(0)\n__naked void stack_access_priv_vs_unpriv(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 16) = r2;\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r2;\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 4;\t\t\t\t\t\\\n\tr2 -= 16;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr2 += r10;\t\t\t\t\t\\\n\t \t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nSEC(\"lwt_in\")\n__description(\"indirect variable-offset stack access, ok\")\n__success __retval(0)\n__naked void variable_offset_stack_access_ok(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 16) = r2;\t\t\t\t\\\n\tr2 = 0;\t\t\t\t\t\t\\\n\t*(u64*)(r10 - 8) = r2;\t\t\t\t\\\n\t \t\t\t\\\n\tr2 = *(u32*)(r1 + 0);\t\t\t\t\\\n\t \t\t\\\n\tr2 &= 4;\t\t\t\t\t\\\n\tr2 -= 16;\t\t\t\t\t\\\n\t \t\t\t\t\t\t\\\n\tr2 += r10;\t\t\t\t\t\\\n\t \t\t\\\n\tr1 = %[map_hash_8b] ll;\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_hash_8b)\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}