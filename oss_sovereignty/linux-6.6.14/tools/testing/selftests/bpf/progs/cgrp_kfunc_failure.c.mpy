{
  "module_name": "cgrp_kfunc_failure.c",
  "hash_id": "190780c94cfa25786994d498c1ed953f6b47c97720609e9b18a68fc409dcc72b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/cgrp_kfunc_failure.c",
  "human_readable_source": "\n \n\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n\n#include \"bpf_misc.h\"\n#include \"cgrp_kfunc_common.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n \n\nstatic struct __cgrps_kfunc_map_value *insert_lookup_cgrp(struct cgroup *cgrp)\n{\n\tint status;\n\n\tstatus = cgrps_kfunc_map_insert(cgrp);\n\tif (status)\n\t\treturn NULL;\n\n\treturn cgrps_kfunc_map_value_lookup(cgrp);\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"Possibly NULL pointer passed to trusted arg0\")\nint BPF_PROG(cgrp_kfunc_acquire_untrusted, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *acquired;\n\tstruct __cgrps_kfunc_map_value *v;\n\n\tv = insert_lookup_cgrp(cgrp);\n\tif (!v)\n\t\treturn 0;\n\n\t \n\tacquired = bpf_cgroup_acquire(v->cgrp);\n\tif (acquired)\n\t\tbpf_cgroup_release(acquired);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"Possibly NULL pointer passed to trusted arg0\")\nint BPF_PROG(cgrp_kfunc_acquire_no_null_check, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *acquired;\n\n\tacquired = bpf_cgroup_acquire(cgrp);\n\t \n\tbpf_cgroup_release(acquired);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"arg#0 pointer type STRUCT cgroup must point\")\nint BPF_PROG(cgrp_kfunc_acquire_fp, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *acquired, *stack_cgrp = (struct cgroup *)&path;\n\n\t \n\tacquired = bpf_cgroup_acquire((struct cgroup *)&stack_cgrp);\n\tif (acquired)\n\t\tbpf_cgroup_release(acquired);\n\n\treturn 0;\n}\n\nSEC(\"kretprobe/cgroup_destroy_locked\")\n__failure __msg(\"reg type unsupported for arg#0 function\")\nint BPF_PROG(cgrp_kfunc_acquire_unsafe_kretprobe, struct cgroup *cgrp)\n{\n\tstruct cgroup *acquired;\n\n\t \n\tacquired = bpf_cgroup_acquire(cgrp);\n\tif (acquired)\n\t\tbpf_cgroup_release(acquired);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"cgrp_kfunc_acquire_trusted_walked\")\nint BPF_PROG(cgrp_kfunc_acquire_trusted_walked, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *acquired;\n\n\t \n\tacquired = bpf_cgroup_acquire(cgrp->old_dom_cgrp);\n\tif (acquired)\n\t\tbpf_cgroup_release(acquired);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"Possibly NULL pointer passed to trusted arg0\")\nint BPF_PROG(cgrp_kfunc_acquire_null, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *acquired;\n\n\t \n\tacquired = bpf_cgroup_acquire(NULL);\n\tif (acquired)\n\t\tbpf_cgroup_release(acquired);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"Unreleased reference\")\nint BPF_PROG(cgrp_kfunc_acquire_unreleased, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *acquired;\n\n\tacquired = bpf_cgroup_acquire(cgrp);\n\n\t \n\t__sink(acquired);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"Unreleased reference\")\nint BPF_PROG(cgrp_kfunc_xchg_unreleased, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *kptr;\n\tstruct __cgrps_kfunc_map_value *v;\n\n\tv = insert_lookup_cgrp(cgrp);\n\tif (!v)\n\t\treturn 0;\n\n\tkptr = bpf_kptr_xchg(&v->cgrp, NULL);\n\tif (!kptr)\n\t\treturn 0;\n\n\t \n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"must be referenced or trusted\")\nint BPF_PROG(cgrp_kfunc_rcu_get_release, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *kptr;\n\tstruct __cgrps_kfunc_map_value *v;\n\n\tv = insert_lookup_cgrp(cgrp);\n\tif (!v)\n\t\treturn 0;\n\n\tbpf_rcu_read_lock();\n\tkptr = v->cgrp;\n\tif (kptr)\n\t\t \n\t\tbpf_cgroup_release(kptr);\n\tbpf_rcu_read_unlock();\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"Possibly NULL pointer passed to trusted arg0\")\nint BPF_PROG(cgrp_kfunc_release_untrusted, struct cgroup *cgrp, const char *path)\n{\n\tstruct __cgrps_kfunc_map_value *v;\n\n\tv = insert_lookup_cgrp(cgrp);\n\tif (!v)\n\t\treturn 0;\n\n\t \n\tbpf_cgroup_release(v->cgrp);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"arg#0 pointer type STRUCT cgroup must point\")\nint BPF_PROG(cgrp_kfunc_release_fp, struct cgroup *cgrp, const char *path)\n{\n\tstruct cgroup *acquired = (struct cgroup *)&path;\n\n\t \n\tbpf_cgroup_release(acquired);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"Possibly NULL pointer passed to trusted arg0\")\nint BPF_PROG(cgrp_kfunc_release_null, struct cgroup *cgrp, const char *path)\n{\n\tstruct __cgrps_kfunc_map_value local, *v;\n\tlong status;\n\tstruct cgroup *acquired, *old;\n\ts32 id;\n\n\tstatus = bpf_probe_read_kernel(&id, sizeof(id), &cgrp->self.id);\n\tif (status)\n\t\treturn 0;\n\n\tlocal.cgrp = NULL;\n\tstatus = bpf_map_update_elem(&__cgrps_kfunc_map, &id, &local, BPF_NOEXIST);\n\tif (status)\n\t\treturn status;\n\n\tv = bpf_map_lookup_elem(&__cgrps_kfunc_map, &id);\n\tif (!v)\n\t\treturn -ENOENT;\n\n\tacquired = bpf_cgroup_acquire(cgrp);\n\tif (!acquired)\n\t\treturn -ENOENT;\n\n\told = bpf_kptr_xchg(&v->cgrp, acquired);\n\n\t \n\tbpf_cgroup_release(old);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/cgroup_mkdir\")\n__failure __msg(\"release kernel function bpf_cgroup_release expects\")\nint BPF_PROG(cgrp_kfunc_release_unacquired, struct cgroup *cgrp, const char *path)\n{\n\t \n\tbpf_cgroup_release(cgrp);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}