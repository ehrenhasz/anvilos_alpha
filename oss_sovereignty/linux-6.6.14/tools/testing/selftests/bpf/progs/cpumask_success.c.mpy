{
  "module_name": "cpumask_success.c",
  "hash_id": "3d8c84a7d14b25b46a8f6198f9dccb710281a81fc059086787fa5de18f8c5233",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/cpumask_success.c",
  "human_readable_source": "\n \n\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n\n#include \"bpf_misc.h\"\n#include \"cpumask_common.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nint pid, nr_cpus;\n\nstatic bool is_test_task(void)\n{\n\tint cur_pid = bpf_get_current_pid_tgid() >> 32;\n\n\treturn pid == cur_pid;\n}\n\nstatic bool create_cpumask_set(struct bpf_cpumask **out1,\n\t\t\t       struct bpf_cpumask **out2,\n\t\t\t       struct bpf_cpumask **out3,\n\t\t\t       struct bpf_cpumask **out4)\n{\n\tstruct bpf_cpumask *mask1, *mask2, *mask3, *mask4;\n\n\tmask1 = create_cpumask();\n\tif (!mask1)\n\t\treturn false;\n\n\tmask2 = create_cpumask();\n\tif (!mask2) {\n\t\tbpf_cpumask_release(mask1);\n\t\terr = 3;\n\t\treturn false;\n\t}\n\n\tmask3 = create_cpumask();\n\tif (!mask3) {\n\t\tbpf_cpumask_release(mask1);\n\t\tbpf_cpumask_release(mask2);\n\t\terr = 4;\n\t\treturn false;\n\t}\n\n\tmask4 = create_cpumask();\n\tif (!mask4) {\n\t\tbpf_cpumask_release(mask1);\n\t\tbpf_cpumask_release(mask2);\n\t\tbpf_cpumask_release(mask3);\n\t\terr = 5;\n\t\treturn false;\n\t}\n\n\t*out1 = mask1;\n\t*out2 = mask2;\n\t*out3 = mask3;\n\t*out4 = mask4;\n\n\treturn true;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_alloc_free_cpumask, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tcpumask = create_cpumask();\n\tif (!cpumask)\n\t\treturn 0;\n\n\tbpf_cpumask_release(cpumask);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_set_clear_cpu, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tcpumask = create_cpumask();\n\tif (!cpumask)\n\t\treturn 0;\n\n\tbpf_cpumask_set_cpu(0, cpumask);\n\tif (!bpf_cpumask_test_cpu(0, cast(cpumask))) {\n\t\terr = 3;\n\t\tgoto release_exit;\n\t}\n\n\tbpf_cpumask_clear_cpu(0, cpumask);\n\tif (bpf_cpumask_test_cpu(0, cast(cpumask))) {\n\t\terr = 4;\n\t\tgoto release_exit;\n\t}\n\nrelease_exit:\n\tbpf_cpumask_release(cpumask);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_setall_clear_cpu, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tcpumask = create_cpumask();\n\tif (!cpumask)\n\t\treturn 0;\n\n\tbpf_cpumask_setall(cpumask);\n\tif (!bpf_cpumask_full(cast(cpumask))) {\n\t\terr = 3;\n\t\tgoto release_exit;\n\t}\n\n\tbpf_cpumask_clear(cpumask);\n\tif (!bpf_cpumask_empty(cast(cpumask))) {\n\t\terr = 4;\n\t\tgoto release_exit;\n\t}\n\nrelease_exit:\n\tbpf_cpumask_release(cpumask);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_first_firstzero_cpu, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tcpumask = create_cpumask();\n\tif (!cpumask)\n\t\treturn 0;\n\n\tif (bpf_cpumask_first(cast(cpumask)) < nr_cpus) {\n\t\terr = 3;\n\t\tgoto release_exit;\n\t}\n\n\tif (bpf_cpumask_first_zero(cast(cpumask)) != 0) {\n\t\tbpf_printk(\"first zero: %d\", bpf_cpumask_first_zero(cast(cpumask)));\n\t\terr = 4;\n\t\tgoto release_exit;\n\t}\n\n\tbpf_cpumask_set_cpu(0, cpumask);\n\tif (bpf_cpumask_first(cast(cpumask)) != 0) {\n\t\terr = 5;\n\t\tgoto release_exit;\n\t}\n\n\tif (bpf_cpumask_first_zero(cast(cpumask)) != 1) {\n\t\terr = 6;\n\t\tgoto release_exit;\n\t}\n\nrelease_exit:\n\tbpf_cpumask_release(cpumask);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_firstand_nocpu, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *mask1, *mask2;\n\tu32 first;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tmask1 = create_cpumask();\n\tif (!mask1)\n\t\treturn 0;\n\n\tmask2 = create_cpumask();\n\tif (!mask2)\n\t\tgoto release_exit;\n\n\tbpf_cpumask_set_cpu(0, mask1);\n\tbpf_cpumask_set_cpu(1, mask2);\n\n\tfirst = bpf_cpumask_first_and(cast(mask1), cast(mask2));\n\tif (first <= 1)\n\t\terr = 3;\n\nrelease_exit:\n\tif (mask1)\n\t\tbpf_cpumask_release(mask1);\n\tif (mask2)\n\t\tbpf_cpumask_release(mask2);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_test_and_set_clear, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tcpumask = create_cpumask();\n\tif (!cpumask)\n\t\treturn 0;\n\n\tif (bpf_cpumask_test_and_set_cpu(0, cpumask)) {\n\t\terr = 3;\n\t\tgoto release_exit;\n\t}\n\n\tif (!bpf_cpumask_test_and_set_cpu(0, cpumask)) {\n\t\terr = 4;\n\t\tgoto release_exit;\n\t}\n\n\tif (!bpf_cpumask_test_and_clear_cpu(0, cpumask)) {\n\t\terr = 5;\n\t\tgoto release_exit;\n\t}\n\nrelease_exit:\n\tbpf_cpumask_release(cpumask);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_and_or_xor, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *mask1, *mask2, *dst1, *dst2;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tif (!create_cpumask_set(&mask1, &mask2, &dst1, &dst2))\n\t\treturn 0;\n\n\tbpf_cpumask_set_cpu(0, mask1);\n\tbpf_cpumask_set_cpu(1, mask2);\n\n\tif (bpf_cpumask_and(dst1, cast(mask1), cast(mask2))) {\n\t\terr = 6;\n\t\tgoto release_exit;\n\t}\n\tif (!bpf_cpumask_empty(cast(dst1))) {\n\t\terr = 7;\n\t\tgoto release_exit;\n\t}\n\n\tbpf_cpumask_or(dst1, cast(mask1), cast(mask2));\n\tif (!bpf_cpumask_test_cpu(0, cast(dst1))) {\n\t\terr = 8;\n\t\tgoto release_exit;\n\t}\n\tif (!bpf_cpumask_test_cpu(1, cast(dst1))) {\n\t\terr = 9;\n\t\tgoto release_exit;\n\t}\n\n\tbpf_cpumask_xor(dst2, cast(mask1), cast(mask2));\n\tif (!bpf_cpumask_equal(cast(dst1), cast(dst2))) {\n\t\terr = 10;\n\t\tgoto release_exit;\n\t}\n\nrelease_exit:\n\tbpf_cpumask_release(mask1);\n\tbpf_cpumask_release(mask2);\n\tbpf_cpumask_release(dst1);\n\tbpf_cpumask_release(dst2);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_intersects_subset, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *mask1, *mask2, *dst1, *dst2;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tif (!create_cpumask_set(&mask1, &mask2, &dst1, &dst2))\n\t\treturn 0;\n\n\tbpf_cpumask_set_cpu(0, mask1);\n\tbpf_cpumask_set_cpu(1, mask2);\n\tif (bpf_cpumask_intersects(cast(mask1), cast(mask2))) {\n\t\terr = 6;\n\t\tgoto release_exit;\n\t}\n\n\tbpf_cpumask_or(dst1, cast(mask1), cast(mask2));\n\tif (!bpf_cpumask_subset(cast(mask1), cast(dst1))) {\n\t\terr = 7;\n\t\tgoto release_exit;\n\t}\n\n\tif (!bpf_cpumask_subset(cast(mask2), cast(dst1))) {\n\t\terr = 8;\n\t\tgoto release_exit;\n\t}\n\n\tif (bpf_cpumask_subset(cast(dst1), cast(mask1))) {\n\t\terr = 9;\n\t\tgoto release_exit;\n\t}\n\nrelease_exit:\n\tbpf_cpumask_release(mask1);\n\tbpf_cpumask_release(mask2);\n\tbpf_cpumask_release(dst1);\n\tbpf_cpumask_release(dst2);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_copy_any_anyand, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *mask1, *mask2, *dst1, *dst2;\n\tu32 cpu;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tif (!create_cpumask_set(&mask1, &mask2, &dst1, &dst2))\n\t\treturn 0;\n\n\tbpf_cpumask_set_cpu(0, mask1);\n\tbpf_cpumask_set_cpu(1, mask2);\n\tbpf_cpumask_or(dst1, cast(mask1), cast(mask2));\n\n\tcpu = bpf_cpumask_any_distribute(cast(mask1));\n\tif (cpu != 0) {\n\t\terr = 6;\n\t\tgoto release_exit;\n\t}\n\n\tcpu = bpf_cpumask_any_distribute(cast(dst2));\n\tif (cpu < nr_cpus) {\n\t\terr = 7;\n\t\tgoto release_exit;\n\t}\n\n\tbpf_cpumask_copy(dst2, cast(dst1));\n\tif (!bpf_cpumask_equal(cast(dst1), cast(dst2))) {\n\t\terr = 8;\n\t\tgoto release_exit;\n\t}\n\n\tcpu = bpf_cpumask_any_distribute(cast(dst2));\n\tif (cpu > 1) {\n\t\terr = 9;\n\t\tgoto release_exit;\n\t}\n\n\tcpu = bpf_cpumask_any_and_distribute(cast(mask1), cast(mask2));\n\tif (cpu < nr_cpus) {\n\t\terr = 10;\n\t\tgoto release_exit;\n\t}\n\nrelease_exit:\n\tbpf_cpumask_release(mask1);\n\tbpf_cpumask_release(mask2);\n\tbpf_cpumask_release(dst1);\n\tbpf_cpumask_release(dst2);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_insert_leave, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\tcpumask = create_cpumask();\n\tif (!cpumask)\n\t\treturn 0;\n\n\tif (cpumask_map_insert(cpumask))\n\t\terr = 3;\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_insert_remove_release, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\tstruct __cpumask_map_value *v;\n\n\tcpumask = create_cpumask();\n\tif (!cpumask)\n\t\treturn 0;\n\n\tif (cpumask_map_insert(cpumask)) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tv = cpumask_map_value_lookup();\n\tif (!v) {\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\tcpumask = bpf_kptr_xchg(&v->cpumask, NULL);\n\tif (cpumask)\n\t\tbpf_cpumask_release(cpumask);\n\telse\n\t\terr = 5;\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_global_mask_rcu, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *local, *prev;\n\n\tif (!is_test_task())\n\t\treturn 0;\n\n\tlocal = create_cpumask();\n\tif (!local)\n\t\treturn 0;\n\n\tprev = bpf_kptr_xchg(&global_mask, local);\n\tif (prev) {\n\t\tbpf_cpumask_release(prev);\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tbpf_rcu_read_lock();\n\tlocal = global_mask;\n\tif (!local) {\n\t\terr = 4;\n\t\tbpf_rcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tbpf_cpumask_test_cpu(0, (const struct cpumask *)local);\n\tbpf_rcu_read_unlock();\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\n__success\nint BPF_PROG(test_refcount_null_tracking, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *mask1, *mask2;\n\n\tmask1 = bpf_cpumask_create();\n\tmask2 = bpf_cpumask_create();\n\n\tif (!mask1 || !mask2)\n\t\tgoto free_masks_return;\n\n\tbpf_cpumask_test_cpu(0, (const struct cpumask *)mask1);\n\tbpf_cpumask_test_cpu(0, (const struct cpumask *)mask2);\n\nfree_masks_return:\n\tif (mask1)\n\t\tbpf_cpumask_release(mask1);\n\tif (mask2)\n\t\tbpf_cpumask_release(mask2);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}