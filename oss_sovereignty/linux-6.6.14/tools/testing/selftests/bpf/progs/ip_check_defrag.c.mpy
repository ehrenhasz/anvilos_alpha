{
  "module_name": "ip_check_defrag.c",
  "hash_id": "526882beb2917d2fade2017d79d1028023bcc01f48f367b446c7ee813a3f9ed0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/ip_check_defrag.c",
  "human_readable_source": "\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"bpf_tracing_net.h\"\n\n#define NF_DROP\t\t\t0\n#define NF_ACCEPT\t\t1\n#define ETH_P_IP\t\t0x0800\n#define ETH_P_IPV6\t\t0x86DD\n#define IP_MF\t\t\t0x2000\n#define IP_OFFSET\t\t0x1FFF\n#define NEXTHDR_FRAGMENT\t44\n\nextern int bpf_dynptr_from_skb(struct sk_buff *skb, __u64 flags,\n\t\t\t      struct bpf_dynptr *ptr__uninit) __ksym;\nextern void *bpf_dynptr_slice(const struct bpf_dynptr *ptr, uint32_t offset,\n\t\t\t      void *buffer, uint32_t buffer__sz) __ksym;\n\nvolatile int shootdowns = 0;\n\nstatic bool is_frag_v4(struct iphdr *iph)\n{\n\tint offset;\n\tint flags;\n\n\toffset = bpf_ntohs(iph->frag_off);\n\tflags = offset & ~IP_OFFSET;\n\toffset &= IP_OFFSET;\n\toffset <<= 3;\n\n\treturn (flags & IP_MF) || offset;\n}\n\nstatic bool is_frag_v6(struct ipv6hdr *ip6h)\n{\n\t \n\treturn ip6h->nexthdr == NEXTHDR_FRAGMENT;\n}\n\nstatic int handle_v4(struct sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tu8 iph_buf[20] = {};\n\tstruct iphdr *iph;\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr))\n\t\treturn NF_DROP;\n\n\tiph = bpf_dynptr_slice(&ptr, 0, iph_buf, sizeof(iph_buf));\n\tif (!iph)\n\t\treturn NF_DROP;\n\n\t \n\tif (is_frag_v4(iph)) {\n\t\tshootdowns++;\n\t\treturn NF_DROP;\n\t}\n\n\treturn NF_ACCEPT;\n}\n\nstatic int handle_v6(struct sk_buff *skb)\n{\n\tstruct bpf_dynptr ptr;\n\tstruct ipv6hdr *ip6h;\n\tu8 ip6h_buf[40] = {};\n\n\tif (bpf_dynptr_from_skb(skb, 0, &ptr))\n\t\treturn NF_DROP;\n\n\tip6h = bpf_dynptr_slice(&ptr, 0, ip6h_buf, sizeof(ip6h_buf));\n\tif (!ip6h)\n\t\treturn NF_DROP;\n\n\t \n\tif (is_frag_v6(ip6h)) {\n\t\tshootdowns++;\n\t\treturn NF_DROP;\n\t}\n\n\treturn NF_ACCEPT;\n}\n\nSEC(\"netfilter\")\nint defrag(struct bpf_nf_ctx *ctx)\n{\n\tstruct sk_buff *skb = ctx->skb;\n\n\tswitch (bpf_ntohs(skb->protocol)) {\n\tcase ETH_P_IP:\n\t\treturn handle_v4(skb);\n\tcase ETH_P_IPV6:\n\t\treturn handle_v6(skb);\n\tdefault:\n\t\treturn NF_ACCEPT;\n\t}\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}