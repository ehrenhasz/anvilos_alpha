{
  "module_name": "test_sockmap_kern.h",
  "hash_id": "71ab7fc2276cf27202b326b3675359e55f41d2999c096dff2d26f2ade1c43df2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_sockmap_kern.h",
  "human_readable_source": " \n \n\nstruct {\n\t__uint(type, TEST_MAP_TYPE);\n\t__uint(max_entries, 20);\n\t__uint(key_size, sizeof(int));\n\t__uint(value_size, sizeof(int));\n} sock_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, TEST_MAP_TYPE);\n\t__uint(max_entries, 20);\n\t__uint(key_size, sizeof(int));\n\t__uint(value_size, sizeof(int));\n} sock_map_txmsg SEC(\".maps\");\n\nstruct {\n\t__uint(type, TEST_MAP_TYPE);\n\t__uint(max_entries, 20);\n\t__uint(key_size, sizeof(int));\n\t__uint(value_size, sizeof(int));\n} sock_map_redir SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n} sock_apply_bytes SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n} sock_cork_bytes SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 6);\n\t__type(key, int);\n\t__type(value, int);\n} sock_bytes SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n} sock_redir_flags SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 3);\n\t__type(key, int);\n\t__type(value, int);\n} sock_skb_opts SEC(\".maps\");\n\nstruct {\n\t__uint(type, TEST_MAP_TYPE);\n\t__uint(max_entries, 20);\n\t__uint(key_size, sizeof(int));\n\t__uint(value_size, sizeof(int));\n} tls_sock_map SEC(\".maps\");\n\nSEC(\"sk_skb1\")\nint bpf_prog1(struct __sk_buff *skb)\n{\n\tint *f, two = 2;\n\n\tf = bpf_map_lookup_elem(&sock_skb_opts, &two);\n\tif (f && *f) {\n\t\treturn *f;\n\t}\n\treturn skb->len;\n}\n\nSEC(\"sk_skb2\")\nint bpf_prog2(struct __sk_buff *skb)\n{\n\t__u32 lport = skb->local_port;\n\t__u32 rport = skb->remote_port;\n\tint len, *f, ret, zero = 0;\n\t__u64 flags = 0;\n\n\t__sink(rport);\n\tif (lport == 10000)\n\t\tret = 10;\n\telse\n\t\tret = 1;\n\n\tlen = (__u32)skb->data_end - (__u32)skb->data;\n\t__sink(len);\n\n\tf = bpf_map_lookup_elem(&sock_skb_opts, &zero);\n\tif (f && *f) {\n\t\tret = 3;\n\t\tflags = *f;\n\t}\n\n#ifdef SOCKMAP\n\treturn bpf_sk_redirect_map(skb, &sock_map, ret, flags);\n#else\n\treturn bpf_sk_redirect_hash(skb, &sock_map, &ret, flags);\n#endif\n\n}\n\nstatic inline void bpf_write_pass(struct __sk_buff *skb, int offset)\n{\n\tint err = bpf_skb_pull_data(skb, 6 + offset);\n\tvoid *data_end;\n\tchar *c;\n\n\tif (err)\n\t\treturn;\n\n\tc = (char *)(long)skb->data;\n\tdata_end = (void *)(long)skb->data_end;\n\n\tif (c + 5 + offset < data_end)\n\t\tmemcpy(c + offset, \"PASS\", 4);\n}\n\nSEC(\"sk_skb3\")\nint bpf_prog3(struct __sk_buff *skb)\n{\n\tint err, *f, ret = SK_PASS;\n\tconst int one = 1;\n\n\tf = bpf_map_lookup_elem(&sock_skb_opts, &one);\n\tif (f && *f) {\n\t\t__u64 flags = 0;\n\n\t\tret = 0;\n\t\tflags = *f;\n\n\t\terr = bpf_skb_adjust_room(skb, -13, 0, 0);\n\t\tif (err)\n\t\t\treturn SK_DROP;\n\t\terr = bpf_skb_adjust_room(skb, 4, 0, 0);\n\t\tif (err)\n\t\t\treturn SK_DROP;\n\t\tbpf_write_pass(skb, 0);\n#ifdef SOCKMAP\n\t\treturn bpf_sk_redirect_map(skb, &tls_sock_map, ret, flags);\n#else\n\t\treturn bpf_sk_redirect_hash(skb, &tls_sock_map, &ret, flags);\n#endif\n\t}\n\tf = bpf_map_lookup_elem(&sock_skb_opts, &one);\n\tif (f && *f)\n\t\tret = SK_DROP;\n\terr = bpf_skb_adjust_room(skb, 4, 0, 0);\n\tif (err)\n\t\treturn SK_DROP;\n\tbpf_write_pass(skb, 13);\n\treturn ret;\n}\n\nSEC(\"sockops\")\nint bpf_sockmap(struct bpf_sock_ops *skops)\n{\n\t__u32 lport, rport;\n\tint op, ret;\n\n\top = (int) skops->op;\n\n\tswitch (op) {\n\tcase BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB:\n\t\tlport = skops->local_port;\n\t\trport = skops->remote_port;\n\n\t\tif (lport == 10000) {\n\t\t\tret = 1;\n#ifdef SOCKMAP\n\t\t\tbpf_sock_map_update(skops, &sock_map, &ret,\n\t\t\t\t\t\t  BPF_NOEXIST);\n#else\n\t\t\tbpf_sock_hash_update(skops, &sock_map, &ret,\n\t\t\t\t\t\t   BPF_NOEXIST);\n#endif\n\t\t}\n\t\tbreak;\n\tcase BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:\n\t\tlport = skops->local_port;\n\t\trport = skops->remote_port;\n\n\t\tif (bpf_ntohl(rport) == 10001) {\n\t\t\tret = 10;\n#ifdef SOCKMAP\n\t\t\tbpf_sock_map_update(skops, &sock_map, &ret,\n\t\t\t\t\t\t  BPF_NOEXIST);\n#else\n\t\t\tbpf_sock_hash_update(skops, &sock_map, &ret,\n\t\t\t\t\t\t   BPF_NOEXIST);\n#endif\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nSEC(\"sk_msg1\")\nint bpf_prog4(struct sk_msg_md *msg)\n{\n\tint *bytes, zero = 0, one = 1, two = 2, three = 3, four = 4, five = 5;\n\tint *start, *end, *start_push, *end_push, *start_pop, *pop, err = 0;\n\n\tbytes = bpf_map_lookup_elem(&sock_apply_bytes, &zero);\n\tif (bytes)\n\t\tbpf_msg_apply_bytes(msg, *bytes);\n\tbytes = bpf_map_lookup_elem(&sock_cork_bytes, &zero);\n\tif (bytes)\n\t\tbpf_msg_cork_bytes(msg, *bytes);\n\tstart = bpf_map_lookup_elem(&sock_bytes, &zero);\n\tend = bpf_map_lookup_elem(&sock_bytes, &one);\n\tif (start && end)\n\t\tbpf_msg_pull_data(msg, *start, *end, 0);\n\tstart_push = bpf_map_lookup_elem(&sock_bytes, &two);\n\tend_push = bpf_map_lookup_elem(&sock_bytes, &three);\n\tif (start_push && end_push) {\n\t\terr = bpf_msg_push_data(msg, *start_push, *end_push, 0);\n\t\tif (err)\n\t\t\treturn SK_DROP;\n\t}\n\tstart_pop = bpf_map_lookup_elem(&sock_bytes, &four);\n\tpop = bpf_map_lookup_elem(&sock_bytes, &five);\n\tif (start_pop && pop)\n\t\tbpf_msg_pop_data(msg, *start_pop, *pop, 0);\n\treturn SK_PASS;\n}\n\nSEC(\"sk_msg2\")\nint bpf_prog6(struct sk_msg_md *msg)\n{\n\tint zero = 0, one = 1, two = 2, three = 3, four = 4, five = 5, key = 0;\n\tint *bytes, *start, *end, *start_push, *end_push, *start_pop, *pop, *f;\n\tint err = 0;\n\t__u64 flags = 0;\n\n\tbytes = bpf_map_lookup_elem(&sock_apply_bytes, &zero);\n\tif (bytes)\n\t\tbpf_msg_apply_bytes(msg, *bytes);\n\tbytes = bpf_map_lookup_elem(&sock_cork_bytes, &zero);\n\tif (bytes)\n\t\tbpf_msg_cork_bytes(msg, *bytes);\n\n\tstart = bpf_map_lookup_elem(&sock_bytes, &zero);\n\tend = bpf_map_lookup_elem(&sock_bytes, &one);\n\tif (start && end)\n\t\tbpf_msg_pull_data(msg, *start, *end, 0);\n\n\tstart_push = bpf_map_lookup_elem(&sock_bytes, &two);\n\tend_push = bpf_map_lookup_elem(&sock_bytes, &three);\n\tif (start_push && end_push) {\n\t\terr = bpf_msg_push_data(msg, *start_push, *end_push, 0);\n\t\tif (err)\n\t\t\treturn SK_DROP;\n\t}\n\n\tstart_pop = bpf_map_lookup_elem(&sock_bytes, &four);\n\tpop = bpf_map_lookup_elem(&sock_bytes, &five);\n\tif (start_pop && pop)\n\t\tbpf_msg_pop_data(msg, *start_pop, *pop, 0);\n\n\tf = bpf_map_lookup_elem(&sock_redir_flags, &zero);\n\tif (f && *f) {\n\t\tkey = 2;\n\t\tflags = *f;\n\t}\n#ifdef SOCKMAP\n\treturn bpf_msg_redirect_map(msg, &sock_map_redir, key, flags);\n#else\n\treturn bpf_msg_redirect_hash(msg, &sock_map_redir, &key, flags);\n#endif\n}\n\nSEC(\"sk_msg3\")\nint bpf_prog8(struct sk_msg_md *msg)\n{\n\tvoid *data_end = (void *)(long) msg->data_end;\n\tvoid *data = (void *)(long) msg->data;\n\tint ret = 0, *bytes, zero = 0;\n\n\tbytes = bpf_map_lookup_elem(&sock_apply_bytes, &zero);\n\tif (bytes) {\n\t\tret = bpf_msg_apply_bytes(msg, *bytes);\n\t\tif (ret)\n\t\t\treturn SK_DROP;\n\t} else {\n\t\treturn SK_DROP;\n\t}\n\n\t__sink(data_end);\n\t__sink(data);\n\n\treturn SK_PASS;\n}\nSEC(\"sk_msg4\")\nint bpf_prog9(struct sk_msg_md *msg)\n{\n\tvoid *data_end = (void *)(long) msg->data_end;\n\tvoid *data = (void *)(long) msg->data;\n\tint ret = 0, *bytes, zero = 0;\n\n\tbytes = bpf_map_lookup_elem(&sock_cork_bytes, &zero);\n\tif (bytes) {\n\t\tif (((__u64)data_end - (__u64)data) >= *bytes)\n\t\t\treturn SK_PASS;\n\t\tret = bpf_msg_cork_bytes(msg, *bytes);\n\t\tif (ret)\n\t\t\treturn SK_DROP;\n\t}\n\treturn SK_PASS;\n}\n\nSEC(\"sk_msg5\")\nint bpf_prog10(struct sk_msg_md *msg)\n{\n\tint *bytes, *start, *end, *start_push, *end_push, *start_pop, *pop;\n\tint zero = 0, one = 1, two = 2, three = 3, four = 4, five = 5, err = 0;\n\n\tbytes = bpf_map_lookup_elem(&sock_apply_bytes, &zero);\n\tif (bytes)\n\t\tbpf_msg_apply_bytes(msg, *bytes);\n\tbytes = bpf_map_lookup_elem(&sock_cork_bytes, &zero);\n\tif (bytes)\n\t\tbpf_msg_cork_bytes(msg, *bytes);\n\tstart = bpf_map_lookup_elem(&sock_bytes, &zero);\n\tend = bpf_map_lookup_elem(&sock_bytes, &one);\n\tif (start && end)\n\t\tbpf_msg_pull_data(msg, *start, *end, 0);\n\tstart_push = bpf_map_lookup_elem(&sock_bytes, &two);\n\tend_push = bpf_map_lookup_elem(&sock_bytes, &three);\n\tif (start_push && end_push) {\n\t\terr = bpf_msg_push_data(msg, *start_push, *end_push, 0);\n\t\tif (err)\n\t\t\treturn SK_PASS;\n\t}\n\tstart_pop = bpf_map_lookup_elem(&sock_bytes, &four);\n\tpop = bpf_map_lookup_elem(&sock_bytes, &five);\n\tif (start_pop && pop)\n\t\tbpf_msg_pop_data(msg, *start_pop, *pop, 0);\n\treturn SK_DROP;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}