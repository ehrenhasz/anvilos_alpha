{
  "module_name": "sockopt_sk.c",
  "hash_id": "502a4bed3ad0d3ccfa57bbaa7d49b02e724486d6e66fe03f4ac0b6d20da6844c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/sockopt_sk.c",
  "human_readable_source": "\n#include <string.h>\n#include <linux/tcp.h>\n#include <linux/bpf.h>\n#include <netinet/in.h>\n#include <bpf/bpf_helpers.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nint page_size = 0;  \n\n#ifndef SOL_TCP\n#define SOL_TCP IPPROTO_TCP\n#endif\n\n#define SOL_CUSTOM\t\t\t0xdeadbeef\n\nstruct sockopt_sk {\n\t__u8 val;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_SK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct sockopt_sk);\n} socket_storage_map SEC(\".maps\");\n\nSEC(\"cgroup/getsockopt\")\nint _getsockopt(struct bpf_sockopt *ctx)\n{\n\t__u8 *optval_end = ctx->optval_end;\n\t__u8 *optval = ctx->optval;\n\tstruct sockopt_sk *storage;\n\tstruct bpf_sock *sk;\n\n\t \n\tsk = ctx->sk;\n\tif (sk && sk->family == AF_NETLINK)\n\t\tgoto out;\n\n\t \n\tif (bpf_get_netns_cookie(NULL) == 0)\n\t\treturn 0;\n\n\tif (bpf_get_netns_cookie(ctx) == 0)\n\t\treturn 0;\n\n\tif (ctx->level == SOL_IP && ctx->optname == IP_TOS) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (ctx->level == SOL_SOCKET && ctx->optname == SO_SNDBUF) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (ctx->level == SOL_TCP && ctx->optname == TCP_CONGESTION) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (ctx->level == SOL_TCP && ctx->optname == TCP_ZEROCOPY_RECEIVE) {\n\t\t \n\n\t\t \n\t\tif (optval + sizeof(__u64) > optval_end)\n\t\t\treturn 0;  \n\n\t\tif (((struct tcp_zerocopy_receive *)optval)->address != 0)\n\t\t\treturn 0;  \n\n\t\tgoto out;\n\t}\n\n\tif (ctx->level == SOL_IP && ctx->optname == IP_FREEBIND) {\n\t\tif (optval + 1 > optval_end)\n\t\t\treturn 0;  \n\n\t\tctx->retval = 0;  \n\n\t\t \n\t\toptval[0] = 0x55;\n\t\tctx->optlen = 1;\n\n\t\t \n\t\tif (optval_end - optval != page_size)\n\t\t\treturn 0;  \n\n\t\treturn 1;\n\t}\n\n\tif (ctx->level != SOL_CUSTOM)\n\t\treturn 0;  \n\n\tif (optval + 1 > optval_end)\n\t\treturn 0;  \n\n\tstorage = bpf_sk_storage_get(&socket_storage_map, ctx->sk, 0,\n\t\t\t\t     BPF_SK_STORAGE_GET_F_CREATE);\n\tif (!storage)\n\t\treturn 0;  \n\n\tif (!ctx->retval)\n\t\treturn 0;  \n\tctx->retval = 0;  \n\n\toptval[0] = storage->val;\n\tctx->optlen = 1;\n\n\treturn 1;\n\nout:\n\t \n\tif (ctx->optlen > page_size)\n\t\tctx->optlen = 0;\n\treturn 1;\n}\n\nSEC(\"cgroup/setsockopt\")\nint _setsockopt(struct bpf_sockopt *ctx)\n{\n\t__u8 *optval_end = ctx->optval_end;\n\t__u8 *optval = ctx->optval;\n\tstruct sockopt_sk *storage;\n\tstruct bpf_sock *sk;\n\n\t \n\tsk = ctx->sk;\n\tif (sk && sk->family == AF_NETLINK)\n\t\tgoto out;\n\n\t \n\tif (bpf_get_netns_cookie(NULL) == 0)\n\t\treturn 0;\n\n\tif (bpf_get_netns_cookie(ctx) == 0)\n\t\treturn 0;\n\n\tif (ctx->level == SOL_IP && ctx->optname == IP_TOS) {\n\t\t \n\t\tctx->optlen = 0;  \n\t\treturn 1;\n\t}\n\n\tif (ctx->level == SOL_SOCKET && ctx->optname == SO_SNDBUF) {\n\t\t \n\n\t\tif (optval + sizeof(__u32) > optval_end)\n\t\t\treturn 0;  \n\n\t\t*(__u32 *)optval = 0x55AA;\n\t\tctx->optlen = 4;\n\n\t\treturn 1;\n\t}\n\n\tif (ctx->level == SOL_TCP && ctx->optname == TCP_CONGESTION) {\n\t\t \n\n\t\tif (optval + 5 > optval_end)\n\t\t\treturn 0;  \n\n\t\tmemcpy(optval, \"cubic\", 5);\n\t\tctx->optlen = 5;\n\n\t\treturn 1;\n\t}\n\n\tif (ctx->level == SOL_IP && ctx->optname == IP_FREEBIND) {\n\t\t \n\t\tif (ctx->optlen != page_size * 2)\n\t\t\treturn 0;  \n\n\t\tif (optval + 1 > optval_end)\n\t\t\treturn 0;  \n\n\t\t \n\t\toptval[0] = 0;\n\t\tctx->optlen = 1;\n\n\t\t \n\t\tif (optval_end - optval != page_size)\n\t\t\treturn 0;  \n\n\t\treturn 1;\n\t}\n\n\tif (ctx->level != SOL_CUSTOM)\n\t\treturn 0;  \n\n\tif (optval + 1 > optval_end)\n\t\treturn 0;  \n\n\tstorage = bpf_sk_storage_get(&socket_storage_map, ctx->sk, 0,\n\t\t\t\t     BPF_SK_STORAGE_GET_F_CREATE);\n\tif (!storage)\n\t\treturn 0;  \n\n\tstorage->val = optval[0];\n\tctx->optlen = -1;  \n\n\treturn 1;\n\nout:\n\t \n\tif (ctx->optlen > page_size)\n\t\tctx->optlen = 0;\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}