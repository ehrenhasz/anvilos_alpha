{
  "module_name": "verifier_ctx_sk_msg.c",
  "hash_id": "d7acb4078350a7e886f7c474b077db3fa99969733b338996f74f8f4ad5aa0301",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_ctx_sk_msg.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nSEC(\"sk_msg\")\n__description(\"valid access family in SK_MSG\")\n__success\n__naked void access_family_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_family]);\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_family, offsetof(struct sk_msg_md, family))\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"valid access remote_ip4 in SK_MSG\")\n__success\n__naked void remote_ip4_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_remote_ip4]);\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_remote_ip4, offsetof(struct sk_msg_md, remote_ip4))\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"valid access local_ip4 in SK_MSG\")\n__success\n__naked void local_ip4_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_local_ip4]);\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_local_ip4, offsetof(struct sk_msg_md, local_ip4))\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"valid access remote_port in SK_MSG\")\n__success\n__naked void remote_port_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_remote_port]);\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_remote_port, offsetof(struct sk_msg_md, remote_port))\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"valid access local_port in SK_MSG\")\n__success\n__naked void local_port_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_local_port]);\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_local_port, offsetof(struct sk_msg_md, local_port))\n\t: __clobber_all);\n}\n\nSEC(\"sk_skb\")\n__description(\"valid access remote_ip6 in SK_MSG\")\n__success\n__naked void remote_ip6_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_remote_ip6_0]);\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_remote_ip6_1]);\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_remote_ip6_2]);\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_remote_ip6_3]);\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_remote_ip6_0, offsetof(struct sk_msg_md, remote_ip6[0])),\n\t  __imm_const(sk_msg_md_remote_ip6_1, offsetof(struct sk_msg_md, remote_ip6[1])),\n\t  __imm_const(sk_msg_md_remote_ip6_2, offsetof(struct sk_msg_md, remote_ip6[2])),\n\t  __imm_const(sk_msg_md_remote_ip6_3, offsetof(struct sk_msg_md, remote_ip6[3]))\n\t: __clobber_all);\n}\n\nSEC(\"sk_skb\")\n__description(\"valid access local_ip6 in SK_MSG\")\n__success\n__naked void local_ip6_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_local_ip6_0]);\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_local_ip6_1]);\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_local_ip6_2]);\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_local_ip6_3]);\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_local_ip6_0, offsetof(struct sk_msg_md, local_ip6[0])),\n\t  __imm_const(sk_msg_md_local_ip6_1, offsetof(struct sk_msg_md, local_ip6[1])),\n\t  __imm_const(sk_msg_md_local_ip6_2, offsetof(struct sk_msg_md, local_ip6[2])),\n\t  __imm_const(sk_msg_md_local_ip6_3, offsetof(struct sk_msg_md, local_ip6[3]))\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"valid access size in SK_MSG\")\n__success\n__naked void access_size_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr0 = *(u32*)(r1 + %[sk_msg_md_size]);\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_size, offsetof(struct sk_msg_md, size))\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"invalid 64B read of size in SK_MSG\")\n__failure __msg(\"invalid bpf_context access\")\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void of_size_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + %[sk_msg_md_size]);\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_size, offsetof(struct sk_msg_md, size))\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"invalid read past end of SK_MSG\")\n__failure __msg(\"invalid bpf_context access\")\n__naked void past_end_of_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__imm_0]);\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__imm_0, offsetof(struct sk_msg_md, size) + 4)\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"invalid read offset in SK_MSG\")\n__failure __msg(\"invalid bpf_context access\")\n__flag(BPF_F_ANY_ALIGNMENT)\n__naked void read_offset_in_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u32*)(r1 + %[__imm_0]);\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(__imm_0, offsetof(struct sk_msg_md, family) + 1)\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"direct packet read for SK_MSG\")\n__success\n__naked void packet_read_for_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + %[sk_msg_md_data]);\t\t\\\n\tr3 = *(u64*)(r1 + %[sk_msg_md_data_end]);\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\tr0 += 8;\t\t\t\t\t\\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\tr0 = *(u8*)(r2 + 0);\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_data, offsetof(struct sk_msg_md, data)),\n\t  __imm_const(sk_msg_md_data_end, offsetof(struct sk_msg_md, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"direct packet write for SK_MSG\")\n__success\n__naked void packet_write_for_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + %[sk_msg_md_data]);\t\t\\\n\tr3 = *(u64*)(r1 + %[sk_msg_md_data_end]);\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\tr0 += 8;\t\t\t\t\t\\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\t*(u8*)(r2 + 0) = r2;\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_data, offsetof(struct sk_msg_md, data)),\n\t  __imm_const(sk_msg_md_data_end, offsetof(struct sk_msg_md, data_end))\n\t: __clobber_all);\n}\n\nSEC(\"sk_msg\")\n__description(\"overlapping checks for direct packet access SK_MSG\")\n__success\n__naked void direct_packet_access_sk_msg(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\tr2 = *(u64*)(r1 + %[sk_msg_md_data]);\t\t\\\n\tr3 = *(u64*)(r1 + %[sk_msg_md_data_end]);\t\\\n\tr0 = r2;\t\t\t\t\t\\\n\tr0 += 8;\t\t\t\t\t\\\n\tif r0 > r3 goto l0_%=;\t\t\t\t\\\n\tr1 = r2;\t\t\t\t\t\\\n\tr1 += 6;\t\t\t\t\t\\\n\tif r1 > r3 goto l0_%=;\t\t\t\t\\\n\tr0 = *(u16*)(r2 + 6);\t\t\t\t\\\nl0_%=:\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm_const(sk_msg_md_data, offsetof(struct sk_msg_md, data)),\n\t  __imm_const(sk_msg_md_data_end, offsetof(struct sk_msg_md, data_end))\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}