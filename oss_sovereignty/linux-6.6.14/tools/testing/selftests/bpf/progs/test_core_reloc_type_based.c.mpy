{
  "module_name": "test_core_reloc_type_based.c",
  "hash_id": "e16c95323a1884a9266b90c2e9e380c0c19d2efbea4ef390fab0b03a667408df",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_core_reloc_type_based.c",
  "human_readable_source": "\n\n\n#include <linux/bpf.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nstruct {\n\tchar in[256];\n\tchar out[256];\n\tbool skip;\n} data = {};\n\nstruct a_struct {\n\tint x;\n};\n\nstruct a_complex_struct {\n\tunion {\n\t\tstruct a_struct *a;\n\t\tvoid *b;\n\t} x;\n\tvolatile long y;\n};\n\nunion a_union {\n\tint y;\n\tint z;\n};\n\ntypedef struct a_struct named_struct_typedef;\n\ntypedef struct { int x, y, z; } anon_struct_typedef;\n\ntypedef struct {\n\tint a, b, c;\n} *struct_ptr_typedef;\n\nenum an_enum {\n\tAN_ENUM_VAL1 = 1,\n\tAN_ENUM_VAL2 = 2,\n\tAN_ENUM_VAL3 = 3,\n};\n\ntypedef int int_typedef;\n\ntypedef enum { TYPEDEF_ENUM_VAL1, TYPEDEF_ENUM_VAL2 } enum_typedef;\n\ntypedef void *void_ptr_typedef;\ntypedef int *restrict restrict_ptr_typedef;\n\ntypedef int (*func_proto_typedef)(long);\n\ntypedef char arr_typedef[20];\n\nstruct core_reloc_type_based_output {\n\tbool struct_exists;\n\tbool complex_struct_exists;\n\tbool union_exists;\n\tbool enum_exists;\n\tbool typedef_named_struct_exists;\n\tbool typedef_anon_struct_exists;\n\tbool typedef_struct_ptr_exists;\n\tbool typedef_int_exists;\n\tbool typedef_enum_exists;\n\tbool typedef_void_ptr_exists;\n\tbool typedef_restrict_ptr_exists;\n\tbool typedef_func_proto_exists;\n\tbool typedef_arr_exists;\n\n\tbool struct_matches;\n\tbool complex_struct_matches;\n\tbool union_matches;\n\tbool enum_matches;\n\tbool typedef_named_struct_matches;\n\tbool typedef_anon_struct_matches;\n\tbool typedef_struct_ptr_matches;\n\tbool typedef_int_matches;\n\tbool typedef_enum_matches;\n\tbool typedef_void_ptr_matches;\n\tbool typedef_restrict_ptr_matches;\n\tbool typedef_func_proto_matches;\n\tbool typedef_arr_matches;\n\n\tint struct_sz;\n\tint union_sz;\n\tint enum_sz;\n\tint typedef_named_struct_sz;\n\tint typedef_anon_struct_sz;\n\tint typedef_struct_ptr_sz;\n\tint typedef_int_sz;\n\tint typedef_enum_sz;\n\tint typedef_void_ptr_sz;\n\tint typedef_func_proto_sz;\n\tint typedef_arr_sz;\n};\n\nSEC(\"raw_tracepoint/sys_enter\")\nint test_core_type_based(void *ctx)\n{\n\t \n#if __has_builtin(__builtin_preserve_type_info) && __clang_major__ >= 15\n\tstruct core_reloc_type_based_output *out = (void *)&data.out;\n\n\tout->struct_exists = bpf_core_type_exists(struct a_struct);\n\tout->complex_struct_exists = bpf_core_type_exists(struct a_complex_struct);\n\tout->union_exists = bpf_core_type_exists(union a_union);\n\tout->enum_exists = bpf_core_type_exists(enum an_enum);\n\tout->typedef_named_struct_exists = bpf_core_type_exists(named_struct_typedef);\n\tout->typedef_anon_struct_exists = bpf_core_type_exists(anon_struct_typedef);\n\tout->typedef_struct_ptr_exists = bpf_core_type_exists(struct_ptr_typedef);\n\tout->typedef_int_exists = bpf_core_type_exists(int_typedef);\n\tout->typedef_enum_exists = bpf_core_type_exists(enum_typedef);\n\tout->typedef_void_ptr_exists = bpf_core_type_exists(void_ptr_typedef);\n\tout->typedef_restrict_ptr_exists = bpf_core_type_exists(restrict_ptr_typedef);\n\tout->typedef_func_proto_exists = bpf_core_type_exists(func_proto_typedef);\n\tout->typedef_arr_exists = bpf_core_type_exists(arr_typedef);\n\n\tout->struct_matches = bpf_core_type_matches(struct a_struct);\n\tout->complex_struct_matches = bpf_core_type_matches(struct a_complex_struct);\n\tout->union_matches = bpf_core_type_matches(union a_union);\n\tout->enum_matches = bpf_core_type_matches(enum an_enum);\n\tout->typedef_named_struct_matches = bpf_core_type_matches(named_struct_typedef);\n\tout->typedef_anon_struct_matches = bpf_core_type_matches(anon_struct_typedef);\n\tout->typedef_struct_ptr_matches = bpf_core_type_matches(struct_ptr_typedef);\n\tout->typedef_int_matches = bpf_core_type_matches(int_typedef);\n\tout->typedef_enum_matches = bpf_core_type_matches(enum_typedef);\n\tout->typedef_void_ptr_matches = bpf_core_type_matches(void_ptr_typedef);\n\tout->typedef_restrict_ptr_matches = bpf_core_type_matches(restrict_ptr_typedef);\n\tout->typedef_func_proto_matches = bpf_core_type_matches(func_proto_typedef);\n\tout->typedef_arr_matches = bpf_core_type_matches(arr_typedef);\n\n\tout->struct_sz = bpf_core_type_size(struct a_struct);\n\tout->union_sz = bpf_core_type_size(union a_union);\n\tout->enum_sz = bpf_core_type_size(enum an_enum);\n\tout->typedef_named_struct_sz = bpf_core_type_size(named_struct_typedef);\n\tout->typedef_anon_struct_sz = bpf_core_type_size(anon_struct_typedef);\n\tout->typedef_struct_ptr_sz = bpf_core_type_size(struct_ptr_typedef);\n\tout->typedef_int_sz = bpf_core_type_size(int_typedef);\n\tout->typedef_enum_sz = bpf_core_type_size(enum_typedef);\n\tout->typedef_void_ptr_sz = bpf_core_type_size(void_ptr_typedef);\n\tout->typedef_func_proto_sz = bpf_core_type_size(func_proto_typedef);\n\tout->typedef_arr_sz = bpf_core_type_size(arr_typedef);\n#else\n\tdata.skip = true;\n#endif\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}