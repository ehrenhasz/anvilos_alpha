{
  "module_name": "test_xdp_dynptr.c",
  "hash_id": "7c2a7812e584b4bd039307eb56cffaa1182f98749cdfda64db33d5a7c0509f5a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_xdp_dynptr.c",
  "human_readable_source": "\n \n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/in.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/pkt_cls.h>\n#include <sys/socket.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n#include \"test_iptunnel_common.h\"\n#include \"bpf_kfuncs.h\"\n\nconst size_t tcphdr_sz = sizeof(struct tcphdr);\nconst size_t udphdr_sz = sizeof(struct udphdr);\nconst size_t ethhdr_sz = sizeof(struct ethhdr);\nconst size_t iphdr_sz = sizeof(struct iphdr);\nconst size_t ipv6hdr_sz = sizeof(struct ipv6hdr);\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\t__uint(max_entries, 256);\n\t__type(key, __u32);\n\t__type(value, __u64);\n} rxcnt SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(max_entries, MAX_IPTNL_ENTRIES);\n\t__type(key, struct vip);\n\t__type(value, struct iptnl_info);\n} vip2tnl SEC(\".maps\");\n\nstatic __always_inline void count_tx(__u32 protocol)\n{\n\t__u64 *rxcnt_count;\n\n\trxcnt_count = bpf_map_lookup_elem(&rxcnt, &protocol);\n\tif (rxcnt_count)\n\t\t*rxcnt_count += 1;\n}\n\nstatic __always_inline int get_dport(void *trans_data, __u8 protocol)\n{\n\tstruct tcphdr *th;\n\tstruct udphdr *uh;\n\n\tswitch (protocol) {\n\tcase IPPROTO_TCP:\n\t\tth = (struct tcphdr *)trans_data;\n\t\treturn th->dest;\n\tcase IPPROTO_UDP:\n\t\tuh = (struct udphdr *)trans_data;\n\t\treturn uh->dest;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic __always_inline void set_ethhdr(struct ethhdr *new_eth,\n\t\t\t\t       const struct ethhdr *old_eth,\n\t\t\t\t       const struct iptnl_info *tnl,\n\t\t\t\t       __be16 h_proto)\n{\n\tmemcpy(new_eth->h_source, old_eth->h_dest, sizeof(new_eth->h_source));\n\tmemcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));\n\tnew_eth->h_proto = h_proto;\n}\n\nstatic __always_inline int handle_ipv4(struct xdp_md *xdp, struct bpf_dynptr *xdp_ptr)\n{\n\t__u8 eth_buffer[ethhdr_sz + iphdr_sz + ethhdr_sz];\n\t__u8 iph_buffer_tcp[iphdr_sz + tcphdr_sz];\n\t__u8 iph_buffer_udp[iphdr_sz + udphdr_sz];\n\tstruct bpf_dynptr new_xdp_ptr;\n\tstruct iptnl_info *tnl;\n\tstruct ethhdr *new_eth;\n\tstruct ethhdr *old_eth;\n\tstruct iphdr *iph;\n\t__u16 *next_iph;\n\t__u16 payload_len;\n\tstruct vip vip = {};\n\tint dport;\n\t__u32 csum = 0;\n\tint i;\n\n\t__builtin_memset(eth_buffer, 0, sizeof(eth_buffer));\n\t__builtin_memset(iph_buffer_tcp, 0, sizeof(iph_buffer_tcp));\n\t__builtin_memset(iph_buffer_udp, 0, sizeof(iph_buffer_udp));\n\n\tif (ethhdr_sz + iphdr_sz + tcphdr_sz > xdp->data_end - xdp->data)\n\t\tiph = bpf_dynptr_slice(xdp_ptr, ethhdr_sz, iph_buffer_udp, sizeof(iph_buffer_udp));\n\telse\n\t\tiph = bpf_dynptr_slice(xdp_ptr, ethhdr_sz, iph_buffer_tcp, sizeof(iph_buffer_tcp));\n\n\tif (!iph)\n\t\treturn XDP_DROP;\n\n\tdport = get_dport(iph + 1, iph->protocol);\n\tif (dport == -1)\n\t\treturn XDP_DROP;\n\n\tvip.protocol = iph->protocol;\n\tvip.family = AF_INET;\n\tvip.daddr.v4 = iph->daddr;\n\tvip.dport = dport;\n\tpayload_len = bpf_ntohs(iph->tot_len);\n\n\ttnl = bpf_map_lookup_elem(&vip2tnl, &vip);\n\t \n\tif (!tnl || tnl->family != AF_INET)\n\t\treturn XDP_PASS;\n\n\tif (bpf_xdp_adjust_head(xdp, 0 - (int)iphdr_sz))\n\t\treturn XDP_DROP;\n\n\tbpf_dynptr_from_xdp(xdp, 0, &new_xdp_ptr);\n\tnew_eth = bpf_dynptr_slice_rdwr(&new_xdp_ptr, 0, eth_buffer, sizeof(eth_buffer));\n\tif (!new_eth)\n\t\treturn XDP_DROP;\n\n\tiph = (struct iphdr *)(new_eth + 1);\n\told_eth = (struct ethhdr *)(iph + 1);\n\n\tset_ethhdr(new_eth, old_eth, tnl, bpf_htons(ETH_P_IP));\n\n\tif (new_eth == eth_buffer)\n\t\tbpf_dynptr_write(&new_xdp_ptr, 0, eth_buffer, sizeof(eth_buffer), 0);\n\n\tiph->version = 4;\n\tiph->ihl = iphdr_sz >> 2;\n\tiph->frag_off =\t0;\n\tiph->protocol = IPPROTO_IPIP;\n\tiph->check = 0;\n\tiph->tos = 0;\n\tiph->tot_len = bpf_htons(payload_len + iphdr_sz);\n\tiph->daddr = tnl->daddr.v4;\n\tiph->saddr = tnl->saddr.v4;\n\tiph->ttl = 8;\n\n\tnext_iph = (__u16 *)iph;\n\tfor (i = 0; i < iphdr_sz >> 1; i++)\n\t\tcsum += *next_iph++;\n\n\tiph->check = ~((csum & 0xffff) + (csum >> 16));\n\n\tcount_tx(vip.protocol);\n\n\treturn XDP_TX;\n}\n\nstatic __always_inline int handle_ipv6(struct xdp_md *xdp, struct bpf_dynptr *xdp_ptr)\n{\n\t__u8 eth_buffer[ethhdr_sz + ipv6hdr_sz + ethhdr_sz];\n\t__u8 ip6h_buffer_tcp[ipv6hdr_sz + tcphdr_sz];\n\t__u8 ip6h_buffer_udp[ipv6hdr_sz + udphdr_sz];\n\tstruct bpf_dynptr new_xdp_ptr;\n\tstruct iptnl_info *tnl;\n\tstruct ethhdr *new_eth;\n\tstruct ethhdr *old_eth;\n\tstruct ipv6hdr *ip6h;\n\t__u16 payload_len;\n\tstruct vip vip = {};\n\tint dport;\n\n\t__builtin_memset(eth_buffer, 0, sizeof(eth_buffer));\n\t__builtin_memset(ip6h_buffer_tcp, 0, sizeof(ip6h_buffer_tcp));\n\t__builtin_memset(ip6h_buffer_udp, 0, sizeof(ip6h_buffer_udp));\n\n\tif (ethhdr_sz + iphdr_sz + tcphdr_sz > xdp->data_end - xdp->data)\n\t\tip6h = bpf_dynptr_slice(xdp_ptr, ethhdr_sz, ip6h_buffer_udp, sizeof(ip6h_buffer_udp));\n\telse\n\t\tip6h = bpf_dynptr_slice(xdp_ptr, ethhdr_sz, ip6h_buffer_tcp, sizeof(ip6h_buffer_tcp));\n\n\tif (!ip6h)\n\t\treturn XDP_DROP;\n\n\tdport = get_dport(ip6h + 1, ip6h->nexthdr);\n\tif (dport == -1)\n\t\treturn XDP_DROP;\n\n\tvip.protocol = ip6h->nexthdr;\n\tvip.family = AF_INET6;\n\tmemcpy(vip.daddr.v6, ip6h->daddr.s6_addr32, sizeof(vip.daddr));\n\tvip.dport = dport;\n\tpayload_len = ip6h->payload_len;\n\n\ttnl = bpf_map_lookup_elem(&vip2tnl, &vip);\n\t \n\tif (!tnl || tnl->family != AF_INET6)\n\t\treturn XDP_PASS;\n\n\tif (bpf_xdp_adjust_head(xdp, 0 - (int)ipv6hdr_sz))\n\t\treturn XDP_DROP;\n\n\tbpf_dynptr_from_xdp(xdp, 0, &new_xdp_ptr);\n\tnew_eth = bpf_dynptr_slice_rdwr(&new_xdp_ptr, 0, eth_buffer, sizeof(eth_buffer));\n\tif (!new_eth)\n\t\treturn XDP_DROP;\n\n\tip6h = (struct ipv6hdr *)(new_eth + 1);\n\told_eth = (struct ethhdr *)(ip6h + 1);\n\n\tset_ethhdr(new_eth, old_eth, tnl, bpf_htons(ETH_P_IPV6));\n\n\tif (new_eth == eth_buffer)\n\t\tbpf_dynptr_write(&new_xdp_ptr, 0, eth_buffer, sizeof(eth_buffer), 0);\n\n\tip6h->version = 6;\n\tip6h->priority = 0;\n\tmemset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));\n\tip6h->payload_len = bpf_htons(bpf_ntohs(payload_len) + ipv6hdr_sz);\n\tip6h->nexthdr = IPPROTO_IPV6;\n\tip6h->hop_limit = 8;\n\tmemcpy(ip6h->saddr.s6_addr32, tnl->saddr.v6, sizeof(tnl->saddr.v6));\n\tmemcpy(ip6h->daddr.s6_addr32, tnl->daddr.v6, sizeof(tnl->daddr.v6));\n\n\tcount_tx(vip.protocol);\n\n\treturn XDP_TX;\n}\n\nSEC(\"xdp\")\nint _xdp_tx_iptunnel(struct xdp_md *xdp)\n{\n\t__u8 buffer[ethhdr_sz];\n\tstruct bpf_dynptr ptr;\n\tstruct ethhdr *eth;\n\t__u16 h_proto;\n\n\t__builtin_memset(buffer, 0, sizeof(buffer));\n\n\tbpf_dynptr_from_xdp(xdp, 0, &ptr);\n\teth = bpf_dynptr_slice(&ptr, 0, buffer, sizeof(buffer));\n\tif (!eth)\n\t\treturn XDP_DROP;\n\n\th_proto = eth->h_proto;\n\n\tif (h_proto == bpf_htons(ETH_P_IP))\n\t\treturn handle_ipv4(xdp, &ptr);\n\telse if (h_proto == bpf_htons(ETH_P_IPV6))\n\n\t\treturn handle_ipv6(xdp, &ptr);\n\telse\n\t\treturn XDP_DROP;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}