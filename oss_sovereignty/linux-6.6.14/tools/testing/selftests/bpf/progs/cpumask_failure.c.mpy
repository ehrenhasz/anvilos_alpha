{
  "module_name": "cpumask_failure.c",
  "hash_id": "5299f2d34f11c19e1e086f32ba26420bbfebbfc78b178fd932dee8de985df5a4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/cpumask_failure.c",
  "human_readable_source": "\n \n\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\n#include \"cpumask_common.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n \n\nSEC(\"tp_btf/task_newtask\")\n__failure __msg(\"Unreleased reference\")\nint BPF_PROG(test_alloc_no_release, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\tcpumask = create_cpumask();\n\t__sink(cpumask);\n\n\t \n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\n__failure __msg(\"NULL pointer passed to trusted arg0\")\nint BPF_PROG(test_alloc_double_release, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\tcpumask = create_cpumask();\n\n\t \n\tbpf_cpumask_release(cpumask);\n\tbpf_cpumask_release(cpumask);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\n__failure __msg(\"must be referenced\")\nint BPF_PROG(test_acquire_wrong_cpumask, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\t \n\tcpumask = bpf_cpumask_acquire((struct bpf_cpumask *)task->cpus_ptr);\n\t__sink(cpumask);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\n__failure __msg(\"bpf_cpumask_set_cpu args#1 expected pointer to STRUCT bpf_cpumask\")\nint BPF_PROG(test_mutate_cpumask, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\n\t \n\tbpf_cpumask_set_cpu(0, (struct bpf_cpumask *)task->cpus_ptr);\n\t__sink(cpumask);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\n__failure __msg(\"Unreleased reference\")\nint BPF_PROG(test_insert_remove_no_release, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *cpumask;\n\tstruct __cpumask_map_value *v;\n\n\tcpumask = create_cpumask();\n\tif (!cpumask)\n\t\treturn 0;\n\n\tif (cpumask_map_insert(cpumask))\n\t\treturn 0;\n\n\tv = cpumask_map_value_lookup();\n\tif (!v)\n\t\treturn 0;\n\n\tcpumask = bpf_kptr_xchg(&v->cpumask, NULL);\n\n\t \n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\n__failure __msg(\"NULL pointer passed to trusted arg0\")\nint BPF_PROG(test_cpumask_null, struct task_struct *task, u64 clone_flags)\n{\n   \n\tbpf_cpumask_empty(NULL);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\n__failure __msg(\"R2 must be a rcu pointer\")\nint BPF_PROG(test_global_mask_out_of_rcu, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *local, *prev;\n\n\tlocal = create_cpumask();\n\tif (!local)\n\t\treturn 0;\n\n\tprev = bpf_kptr_xchg(&global_mask, local);\n\tif (prev) {\n\t\tbpf_cpumask_release(prev);\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tbpf_rcu_read_lock();\n\tlocal = global_mask;\n\tif (!local) {\n\t\terr = 4;\n\t\tbpf_rcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tbpf_rcu_read_unlock();\n\n\t \n\n\tbpf_cpumask_test_cpu(0, (const struct cpumask *)local);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\n__failure __msg(\"NULL pointer passed to trusted arg1\")\nint BPF_PROG(test_global_mask_no_null_check, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *local, *prev;\n\n\tlocal = create_cpumask();\n\tif (!local)\n\t\treturn 0;\n\n\tprev = bpf_kptr_xchg(&global_mask, local);\n\tif (prev) {\n\t\tbpf_cpumask_release(prev);\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tbpf_rcu_read_lock();\n\tlocal = global_mask;\n\n\t \n\tbpf_cpumask_test_cpu(0, (const struct cpumask *)local);\n\n\tbpf_rcu_read_unlock();\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\n__failure __msg(\"Possibly NULL pointer passed to helper arg2\")\nint BPF_PROG(test_global_mask_rcu_no_null_check, struct task_struct *task, u64 clone_flags)\n{\n\tstruct bpf_cpumask *prev, *curr;\n\n\tcurr = bpf_cpumask_create();\n\tif (!curr)\n\t\treturn 0;\n\n\tprev = bpf_kptr_xchg(&global_mask, curr);\n\tif (prev)\n\t\tbpf_cpumask_release(prev);\n\n\tbpf_rcu_read_lock();\n\tcurr = global_mask;\n\t \n\tprev = bpf_kptr_xchg(&global_mask, curr);\n\tbpf_rcu_read_unlock();\n\tif (prev)\n\t\tbpf_cpumask_release(prev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}