{
  "module_name": "test_btf_map_in_map.c",
  "hash_id": "6ec6e7605d382dd35beb763acca982cf99a123aa855bf2fa1ca37810e9686813",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_btf_map_in_map.c",
  "human_readable_source": " \n \n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n\nstruct inner_map {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n} inner_map1 SEC(\".maps\"),\n  inner_map2 SEC(\".maps\");\n\nstruct inner_map_sz2 {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 2);\n\t__type(key, int);\n\t__type(value, int);\n} inner_map_sz2 SEC(\".maps\");\n\nstruct outer_arr {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, 3);\n\t__type(key, int);\n\t__type(value, int);\n\t \n\t__array(values, struct {\n\t\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t\t \n\t\t__uint(max_entries, 1);\n\t\t__type(key, int);\n\t\t__type(value, int);\n\t});\n} outer_arr SEC(\".maps\") = {\n\t \n\t.values = { (void *)&inner_map1, 0, (void *)&inner_map2 },\n};\n\nstruct inner_map_sz3 {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(map_flags, BPF_F_INNER_MAP);\n\t__uint(max_entries, 3);\n\t__type(key, int);\n\t__type(value, int);\n} inner_map3 SEC(\".maps\"),\n  inner_map4 SEC(\".maps\");\n\nstruct inner_map_sz4 {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(map_flags, BPF_F_INNER_MAP);\n\t__uint(max_entries, 5);\n\t__type(key, int);\n\t__type(value, int);\n} inner_map5 SEC(\".maps\");\n\nstruct outer_arr_dyn {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, 3);\n\t__type(key, int);\n\t__type(value, int);\n\t__array(values, struct {\n\t\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t\t__uint(map_flags, BPF_F_INNER_MAP);\n\t\t__uint(max_entries, 1);\n\t\t__type(key, int);\n\t\t__type(value, int);\n\t});\n} outer_arr_dyn SEC(\".maps\") = {\n\t.values = {\n\t\t[0] = (void *)&inner_map3,\n\t\t[1] = (void *)&inner_map4,\n\t\t[2] = (void *)&inner_map5,\n\t},\n};\n\nstruct outer_hash {\n\t__uint(type, BPF_MAP_TYPE_HASH_OF_MAPS);\n\t__uint(max_entries, 5);\n\t__type(key, int);\n\t \n\t__array(values, struct inner_map);\n} outer_hash SEC(\".maps\") = {\n\t.values = {\n\t\t[0] = &inner_map2,\n\t\t[4] = &inner_map1,\n\t},\n};\n\nstruct sockarr_sz1 {\n\t__uint(type, BPF_MAP_TYPE_REUSEPORT_SOCKARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n} sockarr_sz1 SEC(\".maps\");\n\nstruct sockarr_sz2 {\n\t__uint(type, BPF_MAP_TYPE_REUSEPORT_SOCKARRAY);\n\t__uint(max_entries, 2);\n\t__type(key, int);\n\t__type(value, int);\n} sockarr_sz2 SEC(\".maps\");\n\nstruct outer_sockarr_sz1 {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n\t__array(values, struct sockarr_sz1);\n} outer_sockarr SEC(\".maps\") = {\n\t.values = { (void *)&sockarr_sz1 },\n};\n\nint input = 0;\n\nSEC(\"raw_tp/sys_enter\")\nint handle__sys_enter(void *ctx)\n{\n\tstruct inner_map *inner_map;\n\tint key = 0, val;\n\n\tinner_map = bpf_map_lookup_elem(&outer_arr, &key);\n\tif (!inner_map)\n\t\treturn 1;\n\tval = input;\n\tbpf_map_update_elem(inner_map, &key, &val, 0);\n\n\tinner_map = bpf_map_lookup_elem(&outer_hash, &key);\n\tif (!inner_map)\n\t\treturn 1;\n\tval = input + 1;\n\tbpf_map_update_elem(inner_map, &key, &val, 0);\n\n\tinner_map = bpf_map_lookup_elem(&outer_arr_dyn, &key);\n\tif (!inner_map)\n\t\treturn 1;\n\tval = input + 2;\n\tbpf_map_update_elem(inner_map, &key, &val, 0);\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}