{
  "module_name": "test_select_reuseport_kern.c",
  "hash_id": "59fcbed0ff32411c8dbb5f3ed82eafdac2246a3982d03ee04a9444d0a714f036",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_select_reuseport_kern.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/bpf.h>\n#include <linux/types.h>\n#include <linux/if_ether.h>\n\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_helpers.h>\n#include \"test_select_reuseport_common.h\"\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} outer_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, NR_RESULTS);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} result_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, int);\n} tmp_index_ovr_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} linum_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, __u32);\n\t__type(value, struct data_check);\n} data_check_map SEC(\".maps\");\n\n#define GOTO_DONE(_result) ({\t\t\t\\\n\tresult = (_result);\t\t\t\\\n\tlinum = __LINE__;\t\t\t\\\n\tgoto done;\t\t\t\t\\\n})\n\nSEC(\"sk_reuseport\")\nint _select_by_skb_data(struct sk_reuseport_md *reuse_md)\n{\n\t__u32 linum, index = 0, flags = 0, index_zero = 0;\n\t__u32 *result_cnt;\n\tstruct data_check data_check = {};\n\tstruct cmd *cmd, cmd_copy;\n\tvoid *data, *data_end;\n\tvoid *reuseport_array;\n\tenum result result;\n\tint *index_ovr;\n\tint err;\n\n\tdata = reuse_md->data;\n\tdata_end = reuse_md->data_end;\n\tdata_check.len = reuse_md->len;\n\tdata_check.eth_protocol = reuse_md->eth_protocol;\n\tdata_check.ip_protocol = reuse_md->ip_protocol;\n\tdata_check.hash = reuse_md->hash;\n\tdata_check.bind_inany = reuse_md->bind_inany;\n\tif (data_check.eth_protocol == bpf_htons(ETH_P_IP)) {\n\t\tif (bpf_skb_load_bytes_relative(reuse_md,\n\t\t\t\t\t\toffsetof(struct iphdr, saddr),\n\t\t\t\t\t\tdata_check.skb_addrs, 8,\n\t\t\t\t\t\tBPF_HDR_START_NET))\n\t\t\tGOTO_DONE(DROP_MISC);\n\t} else {\n\t\tif (bpf_skb_load_bytes_relative(reuse_md,\n\t\t\t\t\t\toffsetof(struct ipv6hdr, saddr),\n\t\t\t\t\t\tdata_check.skb_addrs, 32,\n\t\t\t\t\t\tBPF_HDR_START_NET))\n\t\t\tGOTO_DONE(DROP_MISC);\n\t}\n\n\t \n\tif (data_check.ip_protocol == IPPROTO_TCP) {\n\t\tstruct tcphdr *th = data;\n\n\t\tif (th + 1 > data_end)\n\t\t\tGOTO_DONE(DROP_MISC);\n\n\t\tdata_check.skb_ports[0] = th->source;\n\t\tdata_check.skb_ports[1] = th->dest;\n\n\t\tif (th->fin)\n\t\t\t \n\t\t\treturn SK_PASS;\n\n\t\tif ((th->doff << 2) + sizeof(*cmd) > data_check.len)\n\t\t\tGOTO_DONE(DROP_ERR_SKB_DATA);\n\t\tif (bpf_skb_load_bytes(reuse_md, th->doff << 2, &cmd_copy,\n\t\t\t\t       sizeof(cmd_copy)))\n\t\t\tGOTO_DONE(DROP_MISC);\n\t\tcmd = &cmd_copy;\n\t} else if (data_check.ip_protocol == IPPROTO_UDP) {\n\t\tstruct udphdr *uh = data;\n\n\t\tif (uh + 1 > data_end)\n\t\t\tGOTO_DONE(DROP_MISC);\n\n\t\tdata_check.skb_ports[0] = uh->source;\n\t\tdata_check.skb_ports[1] = uh->dest;\n\n\t\tif (sizeof(struct udphdr) + sizeof(*cmd) > data_check.len)\n\t\t\tGOTO_DONE(DROP_ERR_SKB_DATA);\n\t\tif (data + sizeof(struct udphdr) + sizeof(*cmd) > data_end) {\n\t\t\tif (bpf_skb_load_bytes(reuse_md, sizeof(struct udphdr),\n\t\t\t\t\t       &cmd_copy, sizeof(cmd_copy)))\n\t\t\t\tGOTO_DONE(DROP_MISC);\n\t\t\tcmd = &cmd_copy;\n\t\t} else {\n\t\t\tcmd = data + sizeof(struct udphdr);\n\t\t}\n\t} else {\n\t\tGOTO_DONE(DROP_MISC);\n\t}\n\n\treuseport_array = bpf_map_lookup_elem(&outer_map, &index_zero);\n\tif (!reuseport_array)\n\t\tGOTO_DONE(DROP_ERR_INNER_MAP);\n\n\tindex = cmd->reuseport_index;\n\tindex_ovr = bpf_map_lookup_elem(&tmp_index_ovr_map, &index_zero);\n\tif (!index_ovr)\n\t\tGOTO_DONE(DROP_MISC);\n\n\tif (*index_ovr != -1) {\n\t\tindex = *index_ovr;\n\t\t*index_ovr = -1;\n\t}\n\terr = bpf_sk_select_reuseport(reuse_md, reuseport_array, &index,\n\t\t\t\t      flags);\n\tif (!err)\n\t\tGOTO_DONE(PASS);\n\n\tif (cmd->pass_on_failure)\n\t\tGOTO_DONE(PASS_ERR_SK_SELECT_REUSEPORT);\n\telse\n\t\tGOTO_DONE(DROP_ERR_SK_SELECT_REUSEPORT);\n\ndone:\n\tresult_cnt = bpf_map_lookup_elem(&result_map, &result);\n\tif (!result_cnt)\n\t\treturn SK_DROP;\n\n\tbpf_map_update_elem(&linum_map, &index_zero, &linum, BPF_ANY);\n\tbpf_map_update_elem(&data_check_map, &index_zero, &data_check, BPF_ANY);\n\n\t(*result_cnt)++;\n\treturn result < PASS ? SK_DROP : SK_PASS;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}