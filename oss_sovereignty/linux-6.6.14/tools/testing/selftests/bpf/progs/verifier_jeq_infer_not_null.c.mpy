{
  "module_name": "verifier_jeq_infer_not_null.c",
  "hash_id": "95d64338d1427d24edb8aed26243f904fb214e7e5b483eb1bcb5c81ae050b381",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/verifier_jeq_infer_not_null.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_misc.h\"\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_XSKMAP);\n\t__uint(max_entries, 1);\n\t__type(key, int);\n\t__type(value, int);\n} map_xskmap SEC(\".maps\");\n\n \nSEC(\"cgroup/skb\")\n__description(\"jne/jeq infer not null, PTR_TO_SOCKET_OR_NULL -> PTR_TO_SOCKET for JNE false branch\")\n__success __failure_unpriv __msg_unpriv(\"R7 pointer comparison\")\n__retval(0)\n__naked void socket_for_jne_false_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tr6 = *(u64*)(r1 + %[__sk_buff_sk]);\t\t\\\n\t \t\t\t\\\n\tif r6 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tcall %[bpf_sk_fullsock];\t\t\t\\\n\tr7 = r0;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tcall %[bpf_sk_fullsock];\t\t\t\\\n\t \t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\\\n\tif r0 != r7 goto l0_%=;\t\t \\\n\tr0 = *(u32*)(r7 + %[bpf_sock_type]);\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_sk_fullsock),\n\t  __imm_const(__sk_buff_sk, offsetof(struct __sk_buff, sk)),\n\t  __imm_const(bpf_sock_type, offsetof(struct bpf_sock, type))\n\t: __clobber_all);\n}\n\n/* Same as above, but verify that another branch of JNE still\n * prohibits access to PTR_MAYBE_NULL.\n */\nSEC(\"cgroup/skb\")\n__description(\"jne/jeq infer not null, PTR_TO_SOCKET_OR_NULL unchanged for JNE true branch\")\n__failure __msg(\"R7 invalid mem access 'sock_or_null'\")\n__failure_unpriv __msg_unpriv(\"R7 pointer comparison\")\n__naked void unchanged_for_jne_true_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tr6 = *(u64*)(r1 + %[__sk_buff_sk]);\t\t\\\n\t \t\t\t\\\n\tif r6 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tcall %[bpf_sk_fullsock];\t\t\t\\\n\tr7 = r0;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tcall %[bpf_sk_fullsock];\t\t\t\\\n\t \t\t\t\\\n\tif r0 != 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\\\n\tif r0 != r7 goto l1_%=;\t\t \\\n\tgoto l0_%=;\t\t\t\t\t\\\nl1_%=:\t \t\t\t\t\\\n\tr0 = *(u32*)(r7 + %[bpf_sock_type]);\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_sk_fullsock),\n\t  __imm_const(__sk_buff_sk, offsetof(struct __sk_buff, sk)),\n\t  __imm_const(bpf_sock_type, offsetof(struct bpf_sock, type))\n\t: __clobber_all);\n}\n\n/* Same as a first test, but not null should be inferred for JEQ branch */\nSEC(\"cgroup/skb\")\n__description(\"jne/jeq infer not null, PTR_TO_SOCKET_OR_NULL -> PTR_TO_SOCKET for JEQ true branch\")\n__success __failure_unpriv __msg_unpriv(\"R7 pointer comparison\")\n__retval(0)\n__naked void socket_for_jeq_true_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tr6 = *(u64*)(r1 + %[__sk_buff_sk]);\t\t\\\n\t \t\t\t\\\n\tif r6 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tcall %[bpf_sk_fullsock];\t\t\t\\\n\tr7 = r0;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tcall %[bpf_sk_fullsock];\t\t\t\\\n\t \t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\\\n\tif r0 == r7 goto l1_%=;\t\t \\\n\tgoto l0_%=;\t\t\t\t\t\\\nl1_%=:\t \t\t\t\t\\\n\tr0 = *(u32*)(r7 + %[bpf_sock_type]);\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_sk_fullsock),\n\t  __imm_const(__sk_buff_sk, offsetof(struct __sk_buff, sk)),\n\t  __imm_const(bpf_sock_type, offsetof(struct bpf_sock, type))\n\t: __clobber_all);\n}\n\n/* Same as above, but verify that another branch of JNE still\n * prohibits access to PTR_MAYBE_NULL.\n */\nSEC(\"cgroup/skb\")\n__description(\"jne/jeq infer not null, PTR_TO_SOCKET_OR_NULL unchanged for JEQ false branch\")\n__failure __msg(\"R7 invalid mem access 'sock_or_null'\")\n__failure_unpriv __msg_unpriv(\"R7 pointer comparison\")\n__naked void unchanged_for_jeq_false_branch(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tr6 = *(u64*)(r1 + %[__sk_buff_sk]);\t\t\\\n\t \t\t\t\\\n\tif r6 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tcall %[bpf_sk_fullsock];\t\t\t\\\n\tr7 = r0;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr1 = r6;\t\t\t\t\t\\\n\tcall %[bpf_sk_fullsock];\t\t\t\\\n\t \t\t\t\\\n\tif r0 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\\\n\tif r0 == r7 goto l0_%=;\t\t \\\n\tr0 = *(u32*)(r7 + %[bpf_sock_type]);\t\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_sk_fullsock),\n\t  __imm_const(__sk_buff_sk, offsetof(struct __sk_buff, sk)),\n\t  __imm_const(bpf_sock_type, offsetof(struct bpf_sock, type))\n\t: __clobber_all);\n}\n\n/* Maps are treated in a different branch of `mark_ptr_not_null_reg`,\n * so separate test for maps case.\n */\nSEC(\"xdp\")\n__description(\"jne/jeq infer not null, PTR_TO_MAP_VALUE_OR_NULL -> PTR_TO_MAP_VALUE\")\n__success __retval(0)\n__naked void null_ptr_to_map_value(void)\n{\n\tasm volatile (\"\t\t\t\t\t\\\n\t \t\t\\\n\tr1 = 0;\t\t\t\t\t\t\\\n\t*(u32*)(r10 - 8) = r1;\t\t\t\t\\\n\tr9 = r10;\t\t\t\t\t\\\n\tr9 += -8;\t\t\t\t\t\\\n\t \t\t\t\\\n\tr8 = %[map_xskmap] ll;\t\t\t\t\\\n\t \t\t\\\n\tr1 = r8;\t\t\t\t\t\\\n\tr2 = r9;\t\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tr6 = r0;\t\t\t\t\t\\\n\t \t\t\\\n\tr1 = r8;\t\t\t\t\t\\\n\tr2 = r9;\t\t\t\t\t\\\n\tcall %[bpf_map_lookup_elem];\t\t\t\\\n\tr7 = r0;\t\t\t\t\t\\\n\t \t\t\t\\\n\tif r6 == 0 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\\\n\tif r6 != r7 goto l0_%=;\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tr0 = *(u32*)(r7 + %[bpf_xdp_sock_queue_id]);\t\\\nl0_%=:\t \t\t\t\t\t\\\n\tr0 = 0;\t\t\t\t\t\t\\\n\texit;\t\t\t\t\t\t\\\n\"\t:\n\t: __imm(bpf_map_lookup_elem),\n\t  __imm_addr(map_xskmap),\n\t  __imm_const(bpf_xdp_sock_queue_id, offsetof(struct bpf_xdp_sock, queue_id))\n\t: __clobber_all);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}