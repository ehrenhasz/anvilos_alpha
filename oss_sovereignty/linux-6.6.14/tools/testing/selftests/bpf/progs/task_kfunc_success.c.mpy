{
  "module_name": "task_kfunc_success.c",
  "hash_id": "a416116ffd4e5c6ac6c0b53387768e1b570a8e43fc814afa825b2e9b9cd27ecd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/task_kfunc_success.c",
  "human_readable_source": "\n \n\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n\n#include \"task_kfunc_common.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\nint err, pid;\n\n \n\nstruct task_struct *bpf_task_acquire(struct task_struct *p) __ksym __weak;\n\nstruct task_struct *bpf_task_acquire___one(struct task_struct *task) __ksym __weak;\n \nstruct task_struct *bpf_task_acquire___two(struct task_struct *p, void *ctx) __ksym __weak;\n \nstruct task_struct *bpf_task_acquire___three(void *ctx) __ksym __weak;\n\nvoid invalid_kfunc(void) __ksym __weak;\nvoid bpf_testmod_test_mod_kfunc(int i) __ksym __weak;\n\nstatic bool is_test_kfunc_task(void)\n{\n\tint cur_pid = bpf_get_current_pid_tgid() >> 32;\n\n\treturn pid == cur_pid;\n}\n\nstatic int test_acquire_release(struct task_struct *task)\n{\n\tstruct task_struct *acquired = NULL;\n\n\tif (!bpf_ksym_exists(bpf_task_acquire)) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\tif (!bpf_ksym_exists(bpf_testmod_test_mod_kfunc)) {\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\tif (bpf_ksym_exists(invalid_kfunc)) {\n\t\t \n\t\terr = 5;\n\t\tasm volatile (\"goto -1\");  \n\t}\n\n\tacquired = bpf_task_acquire(task);\n\tif (acquired)\n\t\tbpf_task_release(acquired);\n\telse\n\t\terr = 6;\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_kfunc_flavor_relo, struct task_struct *task, u64 clone_flags)\n{\n\tstruct task_struct *acquired = NULL;\n\tint fake_ctx = 42;\n\n\tif (bpf_ksym_exists(bpf_task_acquire___one)) {\n\t\tacquired = bpf_task_acquire___one(task);\n\t} else if (bpf_ksym_exists(bpf_task_acquire___two)) {\n\t\t \n\t\tacquired = bpf_task_acquire___two(task, &fake_ctx);\n\t\terr = 3;\n\t\treturn 0;\n\t} else if (bpf_ksym_exists(bpf_task_acquire___three)) {\n\t\t \n\t\tacquired = bpf_task_acquire___three(&fake_ctx);\n\t\terr = 4;\n\t\treturn 0;\n\t}\n\n\tif (acquired)\n\t\tbpf_task_release(acquired);\n\telse\n\t\terr = 5;\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_kfunc_flavor_relo_not_found, struct task_struct *task, u64 clone_flags)\n{\n\t \n\tif (bpf_ksym_exists(bpf_task_acquire___two))\n\t\terr = 1;\n\telse if (bpf_ksym_exists(bpf_task_acquire___three))\n\t\terr = 2;\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_acquire_release_argument, struct task_struct *task, u64 clone_flags)\n{\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\treturn test_acquire_release(task);\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_acquire_release_current, struct task_struct *task, u64 clone_flags)\n{\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\treturn test_acquire_release(bpf_get_current_task_btf());\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_acquire_leave_in_map, struct task_struct *task, u64 clone_flags)\n{\n\tlong status;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tstatus = tasks_kfunc_map_insert(task);\n\tif (status)\n\t\terr = 1;\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_xchg_release, struct task_struct *task, u64 clone_flags)\n{\n\tstruct task_struct *kptr;\n\tstruct __tasks_kfunc_map_value *v;\n\tlong status;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tstatus = tasks_kfunc_map_insert(task);\n\tif (status) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tv = tasks_kfunc_map_value_lookup(task);\n\tif (!v) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\tkptr = bpf_kptr_xchg(&v->task, NULL);\n\tif (!kptr) {\n\t\terr = 3;\n\t\treturn 0;\n\t}\n\n\tbpf_task_release(kptr);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_map_acquire_release, struct task_struct *task, u64 clone_flags)\n{\n\tstruct task_struct *kptr;\n\tstruct __tasks_kfunc_map_value *v;\n\tlong status;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tstatus = tasks_kfunc_map_insert(task);\n\tif (status) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tv = tasks_kfunc_map_value_lookup(task);\n\tif (!v) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\tbpf_rcu_read_lock();\n\tkptr = v->task;\n\tif (!kptr) {\n\t\terr = 3;\n\t} else {\n\t\tkptr = bpf_task_acquire(kptr);\n\t\tif (!kptr)\n\t\t\terr = 4;\n\t\telse\n\t\t\tbpf_task_release(kptr);\n\t}\n\tbpf_rcu_read_unlock();\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_current_acquire_release, struct task_struct *task, u64 clone_flags)\n{\n\tstruct task_struct *current, *acquired;\n\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tcurrent = bpf_get_current_task_btf();\n\tacquired = bpf_task_acquire(current);\n\tif (acquired)\n\t\tbpf_task_release(acquired);\n\telse\n\t\terr = 1;\n\n\treturn 0;\n}\n\nstatic void lookup_compare_pid(const struct task_struct *p)\n{\n\tstruct task_struct *acquired;\n\n\tacquired = bpf_task_from_pid(p->pid);\n\tif (!acquired) {\n\t\terr = 1;\n\t\treturn;\n\t}\n\n\tif (acquired->pid != p->pid)\n\t\terr = 2;\n\tbpf_task_release(acquired);\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_from_pid_arg, struct task_struct *task, u64 clone_flags)\n{\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tlookup_compare_pid(task);\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_from_pid_current, struct task_struct *task, u64 clone_flags)\n{\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tlookup_compare_pid(bpf_get_current_task_btf());\n\treturn 0;\n}\n\nstatic int is_pid_lookup_valid(s32 pid)\n{\n\tstruct task_struct *acquired;\n\n\tacquired = bpf_task_from_pid(pid);\n\tif (acquired) {\n\t\tbpf_task_release(acquired);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(test_task_from_pid_invalid, struct task_struct *task, u64 clone_flags)\n{\n\tif (!is_test_kfunc_task())\n\t\treturn 0;\n\n\tbpf_strncmp(task->comm, 12, \"foo\");\n\tbpf_strncmp(task->comm, 16, \"foo\");\n\tbpf_strncmp(&task->comm[8], 4, \"foo\");\n\n\tif (is_pid_lookup_valid(-1)) {\n\t\terr = 1;\n\t\treturn 0;\n\t}\n\n\tif (is_pid_lookup_valid(0xcafef00d)) {\n\t\terr = 2;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint BPF_PROG(task_kfunc_acquire_trusted_walked, struct task_struct *task, u64 clone_flags)\n{\n\tstruct task_struct *acquired;\n\n\t \n\tacquired = bpf_task_acquire(task->group_leader);\n\tif (acquired)\n\t\tbpf_task_release(acquired);\n\telse\n\t\terr = 1;\n\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}