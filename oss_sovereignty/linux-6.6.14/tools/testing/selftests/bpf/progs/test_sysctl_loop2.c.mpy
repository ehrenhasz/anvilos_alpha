{
  "module_name": "test_sysctl_loop2.c",
  "hash_id": "aff3b8839bac8e87587528a5612ab6aa84acb5e47cbe57a53e7c31cb3d43ea1f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_sysctl_loop2.c",
  "human_readable_source": "\n\n\n#include <stdint.h>\n#include <string.h>\n\n#include <linux/stddef.h>\n#include <linux/bpf.h>\n\n#include <bpf/bpf_helpers.h>\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n#endif\n\n \n#define TCP_MEM_LOOPS 20   \n#define MAX_ULONG_STR_LEN 7\n#define MAX_VALUE_STR_LEN (TCP_MEM_LOOPS * MAX_ULONG_STR_LEN)\n\nconst char tcp_mem_name[] = \"net/ipv4/tcp_mem/very_very_very_very_long_pointless_string_to_stress_byte_loop\";\nstatic __attribute__((noinline)) int is_tcp_mem(struct bpf_sysctl *ctx)\n{\n\tunsigned char i;\n\tchar name[sizeof(tcp_mem_name)];\n\tint ret;\n\n\tmemset(name, 0, sizeof(name));\n\tret = bpf_sysctl_get_name(ctx, name, sizeof(name), 0);\n\tif (ret < 0 || ret != sizeof(tcp_mem_name) - 1)\n\t\treturn 0;\n\n#pragma clang loop unroll(disable)\n\tfor (i = 0; i < sizeof(tcp_mem_name); ++i)\n\t\tif (name[i] != tcp_mem_name[i])\n\t\t\treturn 0;\n\n\treturn 1;\n}\n\n\nSEC(\"cgroup/sysctl\")\nint sysctl_tcp_mem(struct bpf_sysctl *ctx)\n{\n\tunsigned long tcp_mem[TCP_MEM_LOOPS] = {};\n\tchar value[MAX_VALUE_STR_LEN];\n\tunsigned char i, off = 0;\n\tint ret;\n\n\tif (ctx->write)\n\t\treturn 0;\n\n\tif (!is_tcp_mem(ctx))\n\t\treturn 0;\n\n\tret = bpf_sysctl_get_current_value(ctx, value, MAX_VALUE_STR_LEN);\n\tif (ret < 0 || ret >= MAX_VALUE_STR_LEN)\n\t\treturn 0;\n\n#pragma clang loop unroll(disable)\n\tfor (i = 0; i < ARRAY_SIZE(tcp_mem); ++i) {\n\t\tret = bpf_strtoul(value + off, MAX_ULONG_STR_LEN, 0,\n\t\t\t\t  tcp_mem + i);\n\t\tif (ret <= 0 || ret > MAX_ULONG_STR_LEN)\n\t\t\treturn 0;\n\t\toff += ret & MAX_ULONG_STR_LEN;\n\t}\n\n\treturn tcp_mem[0] < tcp_mem[1] && tcp_mem[1] < tcp_mem[2];\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}