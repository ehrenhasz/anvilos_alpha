{
  "module_name": "test_tc_tunnel.c",
  "hash_id": "8f58aefff3331619c9edad36682bf3b9ae9c3423d80e7e8192fc5b7d7c3f0f2d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_tc_tunnel.c",
  "human_readable_source": "\n\n \n\n#include <stdbool.h>\n#include <string.h>\n\n#include <linux/stddef.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/mpls.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/pkt_cls.h>\n#include <linux/types.h>\n\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_helpers.h>\n\nstatic const int cfg_port = 8000;\n\nstatic const int cfg_udp_src = 20000;\n\n#define\tL2_PAD_SZ\t(sizeof(struct vxlanhdr) + ETH_HLEN)\n\n#define\tUDP_PORT\t\t5555\n#define\tMPLS_OVER_UDP_PORT\t6635\n#define\tETH_OVER_UDP_PORT\t7777\n#define\tVXLAN_UDP_PORT\t\t8472\n\n#define\tEXTPROTO_VXLAN\t0x1\n\n#define\tVXLAN_N_VID     (1u << 24)\n#define\tVXLAN_VNI_MASK\tbpf_htonl((VXLAN_N_VID - 1) << 8)\n#define\tVXLAN_FLAGS     0x8\n#define\tVXLAN_VNI       1\n\n#ifndef NEXTHDR_DEST\n#define NEXTHDR_DEST\t60\n#endif\n\n \nstatic const __u32 mpls_label = __bpf_constant_htonl(1000 << 12 |\n\t\t\t\t\t\t     MPLS_LS_S_MASK | 0xff);\n\nstruct vxlanhdr {\n\t__be32 vx_flags;\n\t__be32 vx_vni;\n} __attribute__((packed));\n\nstruct gre_hdr {\n\t__be16 flags;\n\t__be16 protocol;\n} __attribute__((packed));\n\nunion l4hdr {\n\tstruct udphdr udp;\n\tstruct gre_hdr gre;\n};\n\nstruct v4hdr {\n\tstruct iphdr ip;\n\tunion l4hdr l4hdr;\n\t__u8 pad[L2_PAD_SZ];\t\t \n} __attribute__((packed));\n\nstruct v6hdr {\n\tstruct ipv6hdr ip;\n\tunion l4hdr l4hdr;\n\t__u8 pad[L2_PAD_SZ];\t\t \n} __attribute__((packed));\n\nstatic __always_inline void set_ipv4_csum(struct iphdr *iph)\n{\n\t__u16 *iph16 = (__u16 *)iph;\n\t__u32 csum;\n\tint i;\n\n\tiph->check = 0;\n\n#pragma clang loop unroll(full)\n\tfor (i = 0, csum = 0; i < sizeof(*iph) >> 1; i++)\n\t\tcsum += *iph16++;\n\n\tiph->check = ~((csum & 0xffff) + (csum >> 16));\n}\n\nstatic __always_inline int __encap_ipv4(struct __sk_buff *skb, __u8 encap_proto,\n\t\t\t\t\t__u16 l2_proto, __u16 ext_proto)\n{\n\t__u16 udp_dst = UDP_PORT;\n\tstruct iphdr iph_inner;\n\tstruct v4hdr h_outer;\n\tstruct tcphdr tcph;\n\tint olen, l2_len;\n\t__u8 *l2_hdr = NULL;\n\tint tcp_off;\n\t__u64 flags;\n\n\t \n\tif (encap_proto == IPPROTO_IPV6) {\n\t\tconst __u32 saddr = (192 << 24) | (168 << 16) | (1 << 8) | 1;\n\t\tconst __u32 daddr = (192 << 24) | (168 << 16) | (1 << 8) | 2;\n\t\tstruct ipv6hdr iph6_inner;\n\n\t\t \n\t\tif (bpf_skb_load_bytes(skb, ETH_HLEN, &iph6_inner,\n\t\t\t\t       sizeof(iph6_inner)) < 0)\n\t\t\treturn TC_ACT_OK;\n\n\t\t \n\t\tmemset(&iph_inner, 0, sizeof(iph_inner));\n\t\tiph_inner.version = 4;\n\t\tiph_inner.ihl = 5;\n\t\tiph_inner.tot_len = bpf_htons(sizeof(iph6_inner) +\n\t\t\t\t    bpf_ntohs(iph6_inner.payload_len));\n\t\tiph_inner.ttl = iph6_inner.hop_limit - 1;\n\t\tiph_inner.protocol = iph6_inner.nexthdr;\n\t\tiph_inner.saddr = __bpf_constant_htonl(saddr);\n\t\tiph_inner.daddr = __bpf_constant_htonl(daddr);\n\n\t\ttcp_off = sizeof(iph6_inner);\n\t} else {\n\t\tif (bpf_skb_load_bytes(skb, ETH_HLEN, &iph_inner,\n\t\t\t\t       sizeof(iph_inner)) < 0)\n\t\t\treturn TC_ACT_OK;\n\n\t\ttcp_off = sizeof(iph_inner);\n\t}\n\n\t \n\tif (iph_inner.ihl != 5 || iph_inner.protocol != IPPROTO_TCP)\n\t\treturn TC_ACT_OK;\n\n\tif (bpf_skb_load_bytes(skb, ETH_HLEN + tcp_off,\n\t\t\t       &tcph, sizeof(tcph)) < 0)\n\t\treturn TC_ACT_OK;\n\n\tif (tcph.dest != __bpf_constant_htons(cfg_port))\n\t\treturn TC_ACT_OK;\n\n\tolen = sizeof(h_outer.ip);\n\tl2_len = 0;\n\n\tflags = BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4;\n\n\tswitch (l2_proto) {\n\tcase ETH_P_MPLS_UC:\n\t\tl2_len = sizeof(mpls_label);\n\t\tudp_dst = MPLS_OVER_UDP_PORT;\n\t\tbreak;\n\tcase ETH_P_TEB:\n\t\tl2_len = ETH_HLEN;\n\t\tif (ext_proto & EXTPROTO_VXLAN) {\n\t\t\tudp_dst = VXLAN_UDP_PORT;\n\t\t\tl2_len += sizeof(struct vxlanhdr);\n\t\t} else\n\t\t\tudp_dst = ETH_OVER_UDP_PORT;\n\t\tbreak;\n\t}\n\tflags |= BPF_F_ADJ_ROOM_ENCAP_L2(l2_len);\n\n\tswitch (encap_proto) {\n\tcase IPPROTO_GRE:\n\t\tflags |= BPF_F_ADJ_ROOM_ENCAP_L4_GRE;\n\t\tolen += sizeof(h_outer.l4hdr.gre);\n\t\th_outer.l4hdr.gre.protocol = bpf_htons(l2_proto);\n\t\th_outer.l4hdr.gre.flags = 0;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tflags |= BPF_F_ADJ_ROOM_ENCAP_L4_UDP;\n\t\tolen += sizeof(h_outer.l4hdr.udp);\n\t\th_outer.l4hdr.udp.source = __bpf_constant_htons(cfg_udp_src);\n\t\th_outer.l4hdr.udp.dest = bpf_htons(udp_dst);\n\t\th_outer.l4hdr.udp.check = 0;\n\t\th_outer.l4hdr.udp.len = bpf_htons(bpf_ntohs(iph_inner.tot_len) +\n\t\t\t\t\t\t  sizeof(h_outer.l4hdr.udp) +\n\t\t\t\t\t\t  l2_len);\n\t\tbreak;\n\tcase IPPROTO_IPIP:\n\tcase IPPROTO_IPV6:\n\t\tbreak;\n\tdefault:\n\t\treturn TC_ACT_OK;\n\t}\n\n\t \n\tl2_hdr = (__u8 *)&h_outer + olen;\n\tswitch (l2_proto) {\n\tcase ETH_P_MPLS_UC:\n\t\t*(__u32 *)l2_hdr = mpls_label;\n\t\tbreak;\n\tcase ETH_P_TEB:\n\t\tflags |= BPF_F_ADJ_ROOM_ENCAP_L2_ETH;\n\n\t\tif (ext_proto & EXTPROTO_VXLAN) {\n\t\t\tstruct vxlanhdr *vxlan_hdr = (struct vxlanhdr *)l2_hdr;\n\n\t\t\tvxlan_hdr->vx_flags = VXLAN_FLAGS;\n\t\t\tvxlan_hdr->vx_vni = bpf_htonl((VXLAN_VNI & VXLAN_VNI_MASK) << 8);\n\n\t\t\tl2_hdr += sizeof(struct vxlanhdr);\n\t\t}\n\n\t\tif (bpf_skb_load_bytes(skb, 0, l2_hdr, ETH_HLEN))\n\t\t\treturn TC_ACT_SHOT;\n\n\t\tbreak;\n\t}\n\tolen += l2_len;\n\n\t \n\tif (bpf_skb_adjust_room(skb, olen, BPF_ADJ_ROOM_MAC, flags))\n\t\treturn TC_ACT_SHOT;\n\n\t \n\th_outer.ip = iph_inner;\n\th_outer.ip.tot_len = bpf_htons(olen +\n\t\t\t\t       bpf_ntohs(h_outer.ip.tot_len));\n\th_outer.ip.protocol = encap_proto;\n\n\tset_ipv4_csum((void *)&h_outer.ip);\n\n\t \n\tif (bpf_skb_store_bytes(skb, ETH_HLEN, &h_outer, olen,\n\t\t\t\tBPF_F_INVALIDATE_HASH) < 0)\n\t\treturn TC_ACT_SHOT;\n\n\t \n\tif (encap_proto == IPPROTO_IPV6) {\n\t\tstruct ethhdr eth;\n\n\t\tif (bpf_skb_load_bytes(skb, 0, &eth, sizeof(eth)) < 0)\n\t\t\treturn TC_ACT_SHOT;\n\t\teth.h_proto = bpf_htons(ETH_P_IP);\n\t\tif (bpf_skb_store_bytes(skb, 0, &eth, sizeof(eth), 0) < 0)\n\t\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nstatic __always_inline int encap_ipv4(struct __sk_buff *skb, __u8 encap_proto,\n\t\t\t\t      __u16 l2_proto)\n{\n\treturn __encap_ipv4(skb, encap_proto, l2_proto, 0);\n}\n\nstatic __always_inline int __encap_ipv6(struct __sk_buff *skb, __u8 encap_proto,\n\t\t\t\t\t__u16 l2_proto, __u16 ext_proto)\n{\n\t__u16 udp_dst = UDP_PORT;\n\tstruct ipv6hdr iph_inner;\n\tstruct v6hdr h_outer;\n\tstruct tcphdr tcph;\n\tint olen, l2_len;\n\t__u8 *l2_hdr = NULL;\n\t__u16 tot_len;\n\t__u64 flags;\n\n\tif (bpf_skb_load_bytes(skb, ETH_HLEN, &iph_inner,\n\t\t\t       sizeof(iph_inner)) < 0)\n\t\treturn TC_ACT_OK;\n\n\t \n\tif (bpf_skb_load_bytes(skb, ETH_HLEN + sizeof(iph_inner),\n\t\t\t       &tcph, sizeof(tcph)) < 0)\n\t\treturn TC_ACT_OK;\n\n\tif (tcph.dest != __bpf_constant_htons(cfg_port))\n\t\treturn TC_ACT_OK;\n\n\tolen = sizeof(h_outer.ip);\n\tl2_len = 0;\n\n\tflags = BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6;\n\n\tswitch (l2_proto) {\n\tcase ETH_P_MPLS_UC:\n\t\tl2_len = sizeof(mpls_label);\n\t\tudp_dst = MPLS_OVER_UDP_PORT;\n\t\tbreak;\n\tcase ETH_P_TEB:\n\t\tl2_len = ETH_HLEN;\n\t\tif (ext_proto & EXTPROTO_VXLAN) {\n\t\t\tudp_dst = VXLAN_UDP_PORT;\n\t\t\tl2_len += sizeof(struct vxlanhdr);\n\t\t} else\n\t\t\tudp_dst = ETH_OVER_UDP_PORT;\n\t\tbreak;\n\t}\n\tflags |= BPF_F_ADJ_ROOM_ENCAP_L2(l2_len);\n\n\tswitch (encap_proto) {\n\tcase IPPROTO_GRE:\n\t\tflags |= BPF_F_ADJ_ROOM_ENCAP_L4_GRE;\n\t\tolen += sizeof(h_outer.l4hdr.gre);\n\t\th_outer.l4hdr.gre.protocol = bpf_htons(l2_proto);\n\t\th_outer.l4hdr.gre.flags = 0;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tflags |= BPF_F_ADJ_ROOM_ENCAP_L4_UDP;\n\t\tolen += sizeof(h_outer.l4hdr.udp);\n\t\th_outer.l4hdr.udp.source = __bpf_constant_htons(cfg_udp_src);\n\t\th_outer.l4hdr.udp.dest = bpf_htons(udp_dst);\n\t\ttot_len = bpf_ntohs(iph_inner.payload_len) + sizeof(iph_inner) +\n\t\t\t  sizeof(h_outer.l4hdr.udp) + l2_len;\n\t\th_outer.l4hdr.udp.check = 0;\n\t\th_outer.l4hdr.udp.len = bpf_htons(tot_len);\n\t\tbreak;\n\tcase IPPROTO_IPV6:\n\t\tbreak;\n\tdefault:\n\t\treturn TC_ACT_OK;\n\t}\n\n\t \n\tl2_hdr = (__u8 *)&h_outer + olen;\n\tswitch (l2_proto) {\n\tcase ETH_P_MPLS_UC:\n\t\t*(__u32 *)l2_hdr = mpls_label;\n\t\tbreak;\n\tcase ETH_P_TEB:\n\t\tflags |= BPF_F_ADJ_ROOM_ENCAP_L2_ETH;\n\n\t\tif (ext_proto & EXTPROTO_VXLAN) {\n\t\t\tstruct vxlanhdr *vxlan_hdr = (struct vxlanhdr *)l2_hdr;\n\n\t\t\tvxlan_hdr->vx_flags = VXLAN_FLAGS;\n\t\t\tvxlan_hdr->vx_vni = bpf_htonl((VXLAN_VNI & VXLAN_VNI_MASK) << 8);\n\n\t\t\tl2_hdr += sizeof(struct vxlanhdr);\n\t\t}\n\n\t\tif (bpf_skb_load_bytes(skb, 0, l2_hdr, ETH_HLEN))\n\t\t\treturn TC_ACT_SHOT;\n\t\tbreak;\n\t}\n\tolen += l2_len;\n\n\t \n\tif (bpf_skb_adjust_room(skb, olen, BPF_ADJ_ROOM_MAC, flags))\n\t\treturn TC_ACT_SHOT;\n\n\t \n\th_outer.ip = iph_inner;\n\th_outer.ip.payload_len = bpf_htons(olen +\n\t\t\t\t\t   bpf_ntohs(h_outer.ip.payload_len));\n\n\th_outer.ip.nexthdr = encap_proto;\n\n\t \n\tif (bpf_skb_store_bytes(skb, ETH_HLEN, &h_outer, olen,\n\t\t\t\tBPF_F_INVALIDATE_HASH) < 0)\n\t\treturn TC_ACT_SHOT;\n\n\treturn TC_ACT_OK;\n}\n\nstatic int encap_ipv6_ipip6(struct __sk_buff *skb)\n{\n\tstruct iphdr iph_inner;\n\tstruct v6hdr h_outer;\n\tstruct tcphdr tcph;\n\tstruct ethhdr eth;\n\t__u64 flags;\n\tint olen;\n\n\tif (bpf_skb_load_bytes(skb, ETH_HLEN, &iph_inner,\n\t\t\t       sizeof(iph_inner)) < 0)\n\t\treturn TC_ACT_OK;\n\n\t \n\tif (bpf_skb_load_bytes(skb, ETH_HLEN + (iph_inner.ihl << 2),\n\t\t\t       &tcph, sizeof(tcph)) < 0)\n\t\treturn TC_ACT_OK;\n\n\tif (tcph.dest != __bpf_constant_htons(cfg_port))\n\t\treturn TC_ACT_OK;\n\n\tolen = sizeof(h_outer.ip);\n\n\tflags = BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6;\n\n\t \n\tif (bpf_skb_adjust_room(skb, olen, BPF_ADJ_ROOM_MAC, flags))\n\t\treturn TC_ACT_SHOT;\n\n\t \n\tmemset(&h_outer.ip, 0, sizeof(h_outer.ip));\n\th_outer.ip.version = 6;\n\th_outer.ip.hop_limit = iph_inner.ttl;\n\th_outer.ip.saddr.s6_addr[1] = 0xfd;\n\th_outer.ip.saddr.s6_addr[15] = 1;\n\th_outer.ip.daddr.s6_addr[1] = 0xfd;\n\th_outer.ip.daddr.s6_addr[15] = 2;\n\th_outer.ip.payload_len = iph_inner.tot_len;\n\th_outer.ip.nexthdr = IPPROTO_IPIP;\n\n\t \n\tif (bpf_skb_store_bytes(skb, ETH_HLEN, &h_outer, olen,\n\t\t\t\tBPF_F_INVALIDATE_HASH) < 0)\n\t\treturn TC_ACT_SHOT;\n\n\t \n\tif (bpf_skb_load_bytes(skb, 0, &eth, sizeof(eth)) < 0)\n\t\treturn TC_ACT_SHOT;\n\teth.h_proto = bpf_htons(ETH_P_IPV6);\n\tif (bpf_skb_store_bytes(skb, 0, &eth, sizeof(eth), 0) < 0)\n\t\treturn TC_ACT_SHOT;\n\n\treturn TC_ACT_OK;\n}\n\nstatic __always_inline int encap_ipv6(struct __sk_buff *skb, __u8 encap_proto,\n\t\t\t\t      __u16 l2_proto)\n{\n\treturn __encap_ipv6(skb, encap_proto, l2_proto, 0);\n}\n\nSEC(\"encap_ipip_none\")\nint __encap_ipip_none(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IP))\n\t\treturn encap_ipv4(skb, IPPROTO_IPIP, ETH_P_IP);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_gre_none\")\nint __encap_gre_none(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IP))\n\t\treturn encap_ipv4(skb, IPPROTO_GRE, ETH_P_IP);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_gre_mpls\")\nint __encap_gre_mpls(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IP))\n\t\treturn encap_ipv4(skb, IPPROTO_GRE, ETH_P_MPLS_UC);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_gre_eth\")\nint __encap_gre_eth(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IP))\n\t\treturn encap_ipv4(skb, IPPROTO_GRE, ETH_P_TEB);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_udp_none\")\nint __encap_udp_none(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IP))\n\t\treturn encap_ipv4(skb, IPPROTO_UDP, ETH_P_IP);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_udp_mpls\")\nint __encap_udp_mpls(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IP))\n\t\treturn encap_ipv4(skb, IPPROTO_UDP, ETH_P_MPLS_UC);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_udp_eth\")\nint __encap_udp_eth(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IP))\n\t\treturn encap_ipv4(skb, IPPROTO_UDP, ETH_P_TEB);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_vxlan_eth\")\nint __encap_vxlan_eth(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IP))\n\t\treturn __encap_ipv4(skb, IPPROTO_UDP,\n\t\t\t\t    ETH_P_TEB,\n\t\t\t\t    EXTPROTO_VXLAN);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_sit_none\")\nint __encap_sit_none(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IPV6))\n\t\treturn encap_ipv4(skb, IPPROTO_IPV6, ETH_P_IP);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_ip6tnl_none\")\nint __encap_ip6tnl_none(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IPV6))\n\t\treturn encap_ipv6(skb, IPPROTO_IPV6, ETH_P_IPV6);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_ipip6_none\")\nint __encap_ipip6_none(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IP))\n\t\treturn encap_ipv6_ipip6(skb);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_ip6gre_none\")\nint __encap_ip6gre_none(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IPV6))\n\t\treturn encap_ipv6(skb, IPPROTO_GRE, ETH_P_IPV6);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_ip6gre_mpls\")\nint __encap_ip6gre_mpls(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IPV6))\n\t\treturn encap_ipv6(skb, IPPROTO_GRE, ETH_P_MPLS_UC);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_ip6gre_eth\")\nint __encap_ip6gre_eth(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IPV6))\n\t\treturn encap_ipv6(skb, IPPROTO_GRE, ETH_P_TEB);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_ip6udp_none\")\nint __encap_ip6udp_none(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IPV6))\n\t\treturn encap_ipv6(skb, IPPROTO_UDP, ETH_P_IPV6);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_ip6udp_mpls\")\nint __encap_ip6udp_mpls(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IPV6))\n\t\treturn encap_ipv6(skb, IPPROTO_UDP, ETH_P_MPLS_UC);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_ip6udp_eth\")\nint __encap_ip6udp_eth(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IPV6))\n\t\treturn encap_ipv6(skb, IPPROTO_UDP, ETH_P_TEB);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nSEC(\"encap_ip6vxlan_eth\")\nint __encap_ip6vxlan_eth(struct __sk_buff *skb)\n{\n\tif (skb->protocol == __bpf_constant_htons(ETH_P_IPV6))\n\t\treturn __encap_ipv6(skb, IPPROTO_UDP,\n\t\t\t\t    ETH_P_TEB,\n\t\t\t\t    EXTPROTO_VXLAN);\n\telse\n\t\treturn TC_ACT_OK;\n}\n\nstatic int decap_internal(struct __sk_buff *skb, int off, int len, char proto)\n{\n\t__u64 flags = BPF_F_ADJ_ROOM_FIXED_GSO;\n\tstruct ipv6_opt_hdr ip6_opt_hdr;\n\tstruct gre_hdr greh;\n\tstruct udphdr udph;\n\tint olen = len;\n\n\tswitch (proto) {\n\tcase IPPROTO_IPIP:\n\t\tflags |= BPF_F_ADJ_ROOM_DECAP_L3_IPV4;\n\t\tbreak;\n\tcase IPPROTO_IPV6:\n\t\tflags |= BPF_F_ADJ_ROOM_DECAP_L3_IPV6;\n\t\tbreak;\n\tcase NEXTHDR_DEST:\n\t\tif (bpf_skb_load_bytes(skb, off + len, &ip6_opt_hdr,\n\t\t\t\t       sizeof(ip6_opt_hdr)) < 0)\n\t\t\treturn TC_ACT_OK;\n\t\tswitch (ip6_opt_hdr.nexthdr) {\n\t\tcase IPPROTO_IPIP:\n\t\t\tflags |= BPF_F_ADJ_ROOM_DECAP_L3_IPV4;\n\t\t\tbreak;\n\t\tcase IPPROTO_IPV6:\n\t\t\tflags |= BPF_F_ADJ_ROOM_DECAP_L3_IPV6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn TC_ACT_OK;\n\t\t}\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tolen += sizeof(struct gre_hdr);\n\t\tif (bpf_skb_load_bytes(skb, off + len, &greh, sizeof(greh)) < 0)\n\t\t\treturn TC_ACT_OK;\n\t\tswitch (bpf_ntohs(greh.protocol)) {\n\t\tcase ETH_P_MPLS_UC:\n\t\t\tolen += sizeof(mpls_label);\n\t\t\tbreak;\n\t\tcase ETH_P_TEB:\n\t\t\tolen += ETH_HLEN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tolen += sizeof(struct udphdr);\n\t\tif (bpf_skb_load_bytes(skb, off + len, &udph, sizeof(udph)) < 0)\n\t\t\treturn TC_ACT_OK;\n\t\tswitch (bpf_ntohs(udph.dest)) {\n\t\tcase MPLS_OVER_UDP_PORT:\n\t\t\tolen += sizeof(mpls_label);\n\t\t\tbreak;\n\t\tcase ETH_OVER_UDP_PORT:\n\t\t\tolen += ETH_HLEN;\n\t\t\tbreak;\n\t\tcase VXLAN_UDP_PORT:\n\t\t\tolen += ETH_HLEN + sizeof(struct vxlanhdr);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn TC_ACT_OK;\n\t}\n\n\tif (bpf_skb_adjust_room(skb, -olen, BPF_ADJ_ROOM_MAC, flags))\n\t\treturn TC_ACT_SHOT;\n\n\treturn TC_ACT_OK;\n}\n\nstatic int decap_ipv4(struct __sk_buff *skb)\n{\n\tstruct iphdr iph_outer;\n\n\tif (bpf_skb_load_bytes(skb, ETH_HLEN, &iph_outer,\n\t\t\t       sizeof(iph_outer)) < 0)\n\t\treturn TC_ACT_OK;\n\n\tif (iph_outer.ihl != 5)\n\t\treturn TC_ACT_OK;\n\n\treturn decap_internal(skb, ETH_HLEN, sizeof(iph_outer),\n\t\t\t      iph_outer.protocol);\n}\n\nstatic int decap_ipv6(struct __sk_buff *skb)\n{\n\tstruct ipv6hdr iph_outer;\n\n\tif (bpf_skb_load_bytes(skb, ETH_HLEN, &iph_outer,\n\t\t\t       sizeof(iph_outer)) < 0)\n\t\treturn TC_ACT_OK;\n\n\treturn decap_internal(skb, ETH_HLEN, sizeof(iph_outer),\n\t\t\t      iph_outer.nexthdr);\n}\n\nSEC(\"decap\")\nint decap_f(struct __sk_buff *skb)\n{\n\tswitch (skb->protocol) {\n\tcase __bpf_constant_htons(ETH_P_IP):\n\t\treturn decap_ipv4(skb);\n\tcase __bpf_constant_htons(ETH_P_IPV6):\n\t\treturn decap_ipv6(skb);\n\tdefault:\n\t\t \n\t\treturn TC_ACT_OK;\n\t}\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}