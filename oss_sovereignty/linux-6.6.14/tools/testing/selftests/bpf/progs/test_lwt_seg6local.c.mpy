{
  "module_name": "test_lwt_seg6local.c",
  "hash_id": "98be19d62e0ef1636eabe497a705a0556538f465a9492384c540050be05f9dba",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_lwt_seg6local.c",
  "human_readable_source": "#include <stddef.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <linux/seg6_local.h>\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n \n#define cursor_advance(_cursor, _len) \\\n\t({ void *_tmp = _cursor; _cursor += _len; _tmp; })\n\n#define SR6_FLAG_ALERT (1 << 4)\n\n#define BPF_PACKET_HEADER __attribute__((packed))\n\nstruct ip6_t {\n\tunsigned int ver:4;\n\tunsigned int priority:8;\n\tunsigned int flow_label:20;\n\tunsigned short payload_len;\n\tunsigned char next_header;\n\tunsigned char hop_limit;\n\tunsigned long long src_hi;\n\tunsigned long long src_lo;\n\tunsigned long long dst_hi;\n\tunsigned long long dst_lo;\n} BPF_PACKET_HEADER;\n\nstruct ip6_addr_t {\n\tunsigned long long hi;\n\tunsigned long long lo;\n} BPF_PACKET_HEADER;\n\nstruct ip6_srh_t {\n\tunsigned char nexthdr;\n\tunsigned char hdrlen;\n\tunsigned char type;\n\tunsigned char segments_left;\n\tunsigned char first_segment;\n\tunsigned char flags;\n\tunsigned short tag;\n\n\tstruct ip6_addr_t segments[0];\n} BPF_PACKET_HEADER;\n\nstruct sr6_tlv_t {\n\tunsigned char type;\n\tunsigned char len;\n\tunsigned char value[0];\n} BPF_PACKET_HEADER;\n\nstatic __always_inline struct ip6_srh_t *get_srh(struct __sk_buff *skb)\n{\n\tvoid *cursor, *data_end;\n\tstruct ip6_srh_t *srh;\n\tstruct ip6_t *ip;\n\tuint8_t *ipver;\n\n\tdata_end = (void *)(long)skb->data_end;\n\tcursor = (void *)(long)skb->data;\n\tipver = (uint8_t *)cursor;\n\n\tif ((void *)ipver + sizeof(*ipver) > data_end)\n\t\treturn NULL;\n\n\tif ((*ipver >> 4) != 6)\n\t\treturn NULL;\n\n\tip = cursor_advance(cursor, sizeof(*ip));\n\tif ((void *)ip + sizeof(*ip) > data_end)\n\t\treturn NULL;\n\n\tif (ip->next_header != 43)\n\t\treturn NULL;\n\n\tsrh = cursor_advance(cursor, sizeof(*srh));\n\tif ((void *)srh + sizeof(*srh) > data_end)\n\t\treturn NULL;\n\n\tif (srh->type != 4)\n\t\treturn NULL;\n\n\treturn srh;\n}\n\nstatic __always_inline\nint update_tlv_pad(struct __sk_buff *skb, uint32_t new_pad,\n\t\t   uint32_t old_pad, uint32_t pad_off)\n{\n\tint err;\n\n\tif (new_pad != old_pad) {\n\t\terr = bpf_lwt_seg6_adjust_srh(skb, pad_off,\n\t\t\t\t\t  (int) new_pad - (int) old_pad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (new_pad > 0) {\n\t\tchar pad_tlv_buf[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t\t\t0, 0, 0};\n\t\tstruct sr6_tlv_t *pad_tlv = (struct sr6_tlv_t *) pad_tlv_buf;\n\n\t\tpad_tlv->type = SR6_TLV_PADDING;\n\t\tpad_tlv->len = new_pad - 2;\n\n\t\terr = bpf_lwt_seg6_store_bytes(skb, pad_off,\n\t\t\t\t\t       (void *)pad_tlv_buf, new_pad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic __always_inline\nint is_valid_tlv_boundary(struct __sk_buff *skb, struct ip6_srh_t *srh,\n\t\t\t  uint32_t *tlv_off, uint32_t *pad_size,\n\t\t\t  uint32_t *pad_off)\n{\n\tuint32_t srh_off, cur_off;\n\tint offset_valid = 0;\n\tint err;\n\n\tsrh_off = (char *)srh - (char *)(long)skb->data;\n\t\n\tcur_off = srh_off + sizeof(*srh) +\n\t\tsizeof(struct ip6_addr_t) * (srh->first_segment + 1);\n\n\t*pad_off = 0;\n\n\t\n\t#pragma clang loop unroll(full)\n\tfor (int i = 0; i < 10; i++) {\n\t\tstruct sr6_tlv_t tlv;\n\n\t\tif (cur_off == *tlv_off)\n\t\t\toffset_valid = 1;\n\n\t\tif (cur_off >= srh_off + ((srh->hdrlen + 1) << 3))\n\t\t\tbreak;\n\n\t\terr = bpf_skb_load_bytes(skb, cur_off, &tlv, sizeof(tlv));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (tlv.type == SR6_TLV_PADDING) {\n\t\t\t*pad_size = tlv.len + sizeof(tlv);\n\t\t\t*pad_off = cur_off;\n\n\t\t\tif (*tlv_off == srh_off) {\n\t\t\t\t*tlv_off = cur_off;\n\t\t\t\toffset_valid = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t} else if (tlv.type == SR6_TLV_HMAC) {\n\t\t\tbreak;\n\t\t}\n\n\t\tcur_off += sizeof(tlv) + tlv.len;\n\t} \n\n\tif (*pad_off == 0)\n\t\t*pad_off = cur_off;\n\n\tif (*tlv_off == -1)\n\t\t*tlv_off = cur_off;\n\telse if (!offset_valid)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic __always_inline\nint add_tlv(struct __sk_buff *skb, struct ip6_srh_t *srh, uint32_t tlv_off,\n\t    struct sr6_tlv_t *itlv, uint8_t tlv_size)\n{\n\tuint32_t srh_off = (char *)srh - (char *)(long)skb->data;\n\tuint8_t len_remaining, new_pad;\n\tuint32_t pad_off = 0;\n\tuint32_t pad_size = 0;\n\tuint32_t partial_srh_len;\n\tint err;\n\n\tif (tlv_off != -1)\n\t\ttlv_off += srh_off;\n\n\tif (itlv->type == SR6_TLV_PADDING || itlv->type == SR6_TLV_HMAC)\n\t\treturn -EINVAL;\n\n\terr = is_valid_tlv_boundary(skb, srh, &tlv_off, &pad_size, &pad_off);\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_lwt_seg6_adjust_srh(skb, tlv_off, sizeof(*itlv) + itlv->len);\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_lwt_seg6_store_bytes(skb, tlv_off, (void *)itlv, tlv_size);\n\tif (err)\n\t\treturn err;\n\n\t\n\t\n\tpad_off += sizeof(*itlv) + itlv->len;\n\tpartial_srh_len = pad_off - srh_off;\n\tlen_remaining = partial_srh_len % 8;\n\tnew_pad = 8 - len_remaining;\n\n\tif (new_pad == 1) \n\t\tnew_pad = 9;\n\telse if (new_pad == 8)\n\t\tnew_pad = 0;\n\n\treturn update_tlv_pad(skb, new_pad, pad_size, pad_off);\n}\n\nstatic __always_inline\nint delete_tlv(struct __sk_buff *skb, struct ip6_srh_t *srh,\n\t       uint32_t tlv_off)\n{\n\tuint32_t srh_off = (char *)srh - (char *)(long)skb->data;\n\tuint8_t len_remaining, new_pad;\n\tuint32_t partial_srh_len;\n\tuint32_t pad_off = 0;\n\tuint32_t pad_size = 0;\n\tstruct sr6_tlv_t tlv;\n\tint err;\n\n\ttlv_off += srh_off;\n\n\terr = is_valid_tlv_boundary(skb, srh, &tlv_off, &pad_size, &pad_off);\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_skb_load_bytes(skb, tlv_off, &tlv, sizeof(tlv));\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_lwt_seg6_adjust_srh(skb, tlv_off, -(sizeof(tlv) + tlv.len));\n\tif (err)\n\t\treturn err;\n\n\tpad_off -= sizeof(tlv) + tlv.len;\n\tpartial_srh_len = pad_off - srh_off;\n\tlen_remaining = partial_srh_len % 8;\n\tnew_pad = 8 - len_remaining;\n\tif (new_pad == 1) \n\t\tnew_pad = 9;\n\telse if (new_pad == 8)\n\t\tnew_pad = 0;\n\n\treturn update_tlv_pad(skb, new_pad, pad_size, pad_off);\n}\n\nstatic __always_inline\nint has_egr_tlv(struct __sk_buff *skb, struct ip6_srh_t *srh)\n{\n\tint tlv_offset = sizeof(struct ip6_t) + sizeof(struct ip6_srh_t) +\n\t\t((srh->first_segment + 1) << 4);\n\tstruct sr6_tlv_t tlv;\n\n\tif (bpf_skb_load_bytes(skb, tlv_offset, &tlv, sizeof(struct sr6_tlv_t)))\n\t\treturn 0;\n\n\tif (tlv.type == SR6_TLV_EGRESS && tlv.len == 18) {\n\t\tstruct ip6_addr_t egr_addr;\n\n\t\tif (bpf_skb_load_bytes(skb, tlv_offset + 4, &egr_addr, 16))\n\t\t\treturn 0;\n\n\t\t\n\t\tif (bpf_be64_to_cpu(egr_addr.hi) == 0xfd00000000000000 &&\n\t\t    bpf_be64_to_cpu(egr_addr.lo) == 0x4)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n\nSEC(\"encap_srh\")\nint __encap_srh(struct __sk_buff *skb)\n{\n\tunsigned long long hi = 0xfd00000000000000;\n\tstruct ip6_addr_t *seg;\n\tstruct ip6_srh_t *srh;\n\tchar srh_buf[72]; \n\tint err;\n\n\tsrh = (struct ip6_srh_t *)srh_buf;\n\tsrh->nexthdr = 0;\n\tsrh->hdrlen = 8;\n\tsrh->type = 4;\n\tsrh->segments_left = 3;\n\tsrh->first_segment = 3;\n\tsrh->flags = 0;\n\tsrh->tag = 0;\n\n\tseg = (struct ip6_addr_t *)((char *)srh + sizeof(*srh));\n\n\t#pragma clang loop unroll(full)\n\tfor (unsigned long long lo = 0; lo < 4; lo++) {\n\t\tseg->lo = bpf_cpu_to_be64(4 - lo);\n\t\tseg->hi = bpf_cpu_to_be64(hi);\n\t\tseg = (struct ip6_addr_t *)((char *)seg + sizeof(*seg));\n\t}\n\n\terr = bpf_lwt_push_encap(skb, 0, (void *)srh, sizeof(srh_buf));\n\tif (err)\n\t\treturn BPF_DROP;\n\n\treturn BPF_REDIRECT;\n}\n\n\n\nSEC(\"add_egr_x\")\nint __add_egr_x(struct __sk_buff *skb)\n{\n\tunsigned long long hi = 0xfc42000000000000;\n\tunsigned long long lo = 0x1;\n\tstruct ip6_srh_t *srh = get_srh(skb);\n\tuint8_t new_flags = SR6_FLAG_ALERT;\n\tstruct ip6_addr_t addr;\n\tint err, offset;\n\n\tif (srh == NULL)\n\t\treturn BPF_DROP;\n\n\tuint8_t tlv[20] = {2, 18, 0, 0, 0xfd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\t\t\t   0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4};\n\n\terr = add_tlv(skb, srh, (srh->hdrlen+1) << 3,\n\t\t      (struct sr6_tlv_t *)&tlv, 20);\n\tif (err)\n\t\treturn BPF_DROP;\n\n\toffset = sizeof(struct ip6_t) + offsetof(struct ip6_srh_t, flags);\n\terr = bpf_lwt_seg6_store_bytes(skb, offset,\n\t\t\t\t       (void *)&new_flags, sizeof(new_flags));\n\tif (err)\n\t\treturn BPF_DROP;\n\n\taddr.lo = bpf_cpu_to_be64(lo);\n\taddr.hi = bpf_cpu_to_be64(hi);\n\terr = bpf_lwt_seg6_action(skb, SEG6_LOCAL_ACTION_END_X,\n\t\t\t\t  (void *)&addr, sizeof(addr));\n\tif (err)\n\t\treturn BPF_DROP;\n\treturn BPF_REDIRECT;\n}\n\n\n\nSEC(\"pop_egr\")\nint __pop_egr(struct __sk_buff *skb)\n{\n\tstruct ip6_srh_t *srh = get_srh(skb);\n\tuint16_t new_tag = bpf_htons(2442);\n\tuint8_t new_flags = 0;\n\tint err, offset;\n\n\tif (srh == NULL)\n\t\treturn BPF_DROP;\n\n\tif (srh->flags != SR6_FLAG_ALERT)\n\t\treturn BPF_DROP;\n\n\tif (srh->hdrlen != 11) \n\t\treturn BPF_DROP;\n\n\tif (!has_egr_tlv(skb, srh))\n\t\treturn BPF_DROP;\n\n\terr = delete_tlv(skb, srh, 8 + (srh->first_segment + 1) * 16);\n\tif (err)\n\t\treturn BPF_DROP;\n\n\toffset = sizeof(struct ip6_t) + offsetof(struct ip6_srh_t, flags);\n\tif (bpf_lwt_seg6_store_bytes(skb, offset, (void *)&new_flags,\n\t\t\t\t     sizeof(new_flags)))\n\t\treturn BPF_DROP;\n\n\toffset = sizeof(struct ip6_t) + offsetof(struct ip6_srh_t, tag);\n\tif (bpf_lwt_seg6_store_bytes(skb, offset, (void *)&new_tag,\n\t\t\t\t     sizeof(new_tag)))\n\t\treturn BPF_DROP;\n\n\treturn BPF_OK;\n}\n\n\n\nSEC(\"inspect_t\")\nint __inspect_t(struct __sk_buff *skb)\n{\n\tstruct ip6_srh_t *srh = get_srh(skb);\n\tint table = 117;\n\tint err;\n\n\tif (srh == NULL)\n\t\treturn BPF_DROP;\n\n\tif (srh->flags != 0)\n\t\treturn BPF_DROP;\n\n\tif (srh->tag != bpf_htons(2442))\n\t\treturn BPF_DROP;\n\n\tif (srh->hdrlen != 8) \n\t\treturn BPF_DROP;\n\n\terr = bpf_lwt_seg6_action(skb, SEG6_LOCAL_ACTION_END_T,\n\t\t\t\t  (void *)&table, sizeof(table));\n\n\tif (err)\n\t\treturn BPF_DROP;\n\n\treturn BPF_REDIRECT;\n}\n\nchar __license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}