{
  "module_name": "xdp_hw_metadata.c",
  "hash_id": "9e8af80924f067bace3b622b619047b4943a7ddaeb38d75c982bc1298232b762",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/xdp_hw_metadata.c",
  "human_readable_source": "\n\n#include <vmlinux.h>\n#include \"xdp_metadata.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_XSKMAP);\n\t__uint(max_entries, 256);\n\t__type(key, __u32);\n\t__type(value, __u32);\n} xsk SEC(\".maps\");\n\n__u64 pkts_skip = 0;\n__u64 pkts_fail = 0;\n__u64 pkts_redir = 0;\n\nextern int bpf_xdp_metadata_rx_timestamp(const struct xdp_md *ctx,\n\t\t\t\t\t __u64 *timestamp) __ksym;\nextern int bpf_xdp_metadata_rx_hash(const struct xdp_md *ctx, __u32 *hash,\n\t\t\t\t    enum xdp_rss_hash_type *rss_type) __ksym;\n\nSEC(\"xdp\")\nint rx(struct xdp_md *ctx)\n{\n\tvoid *data, *data_meta, *data_end;\n\tstruct ipv6hdr *ip6h = NULL;\n\tstruct ethhdr *eth = NULL;\n\tstruct udphdr *udp = NULL;\n\tstruct iphdr *iph = NULL;\n\tstruct xdp_meta *meta;\n\tint err;\n\n\tdata = (void *)(long)ctx->data;\n\tdata_end = (void *)(long)ctx->data_end;\n\teth = data;\n\tif (eth + 1 < data_end) {\n\t\tif (eth->h_proto == bpf_htons(ETH_P_IP)) {\n\t\t\tiph = (void *)(eth + 1);\n\t\t\tif (iph + 1 < data_end && iph->protocol == IPPROTO_UDP)\n\t\t\t\tudp = (void *)(iph + 1);\n\t\t}\n\t\tif (eth->h_proto == bpf_htons(ETH_P_IPV6)) {\n\t\t\tip6h = (void *)(eth + 1);\n\t\t\tif (ip6h + 1 < data_end && ip6h->nexthdr == IPPROTO_UDP)\n\t\t\t\tudp = (void *)(ip6h + 1);\n\t\t}\n\t\tif (udp && udp + 1 > data_end)\n\t\t\tudp = NULL;\n\t}\n\n\tif (!udp) {\n\t\t__sync_add_and_fetch(&pkts_skip, 1);\n\t\treturn XDP_PASS;\n\t}\n\n\t \n\tif (udp->dest != bpf_htons(9091)) {\n\t\t__sync_add_and_fetch(&pkts_skip, 1);\n\t\treturn XDP_PASS;\n\t}\n\n\terr = bpf_xdp_adjust_meta(ctx, -(int)sizeof(struct xdp_meta));\n\tif (err) {\n\t\t__sync_add_and_fetch(&pkts_fail, 1);\n\t\treturn XDP_PASS;\n\t}\n\n\tdata = (void *)(long)ctx->data;\n\tdata_meta = (void *)(long)ctx->data_meta;\n\tmeta = data_meta;\n\n\tif (meta + 1 > data) {\n\t\t__sync_add_and_fetch(&pkts_fail, 1);\n\t\treturn XDP_PASS;\n\t}\n\n\terr = bpf_xdp_metadata_rx_timestamp(ctx, &meta->rx_timestamp);\n\tif (!err)\n\t\tmeta->xdp_timestamp = bpf_ktime_get_tai_ns();\n\telse\n\t\tmeta->rx_timestamp = 0;  \n\n\terr = bpf_xdp_metadata_rx_hash(ctx, &meta->rx_hash, &meta->rx_hash_type);\n\tif (err < 0)\n\t\tmeta->rx_hash_err = err;  \n\n\t__sync_add_and_fetch(&pkts_redir, 1);\n\treturn bpf_redirect_map(&xsk, ctx->rx_queue_index, XDP_PASS);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}