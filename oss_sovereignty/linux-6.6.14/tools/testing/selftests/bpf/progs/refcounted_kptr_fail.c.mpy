{
  "module_name": "refcounted_kptr_fail.c",
  "hash_id": "24ff874cd79a33e5d32c1de891250e6764a336ecdff8158fda41204f2f8c4c2b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/refcounted_kptr_fail.c",
  "human_readable_source": "\n#include <vmlinux.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n#include \"bpf_experimental.h\"\n#include \"bpf_misc.h\"\n\nstruct node_acquire {\n\tlong key;\n\tlong data;\n\tstruct bpf_rb_node node;\n\tstruct bpf_refcount refcount;\n};\n\nextern void bpf_rcu_read_lock(void) __ksym;\nextern void bpf_rcu_read_unlock(void) __ksym;\n\n#define private(name) SEC(\".data.\" #name) __hidden __attribute__((aligned(8)))\nprivate(A) struct bpf_spin_lock glock;\nprivate(A) struct bpf_rb_root groot __contains(node_acquire, node);\n\nstatic bool less(struct bpf_rb_node *a, const struct bpf_rb_node *b)\n{\n\tstruct node_acquire *node_a;\n\tstruct node_acquire *node_b;\n\n\tnode_a = container_of(a, struct node_acquire, node);\n\tnode_b = container_of(b, struct node_acquire, node);\n\n\treturn node_a->key < node_b->key;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"Unreleased reference id=4 alloc_insn=21\")\nlong rbtree_refcounted_node_ref_escapes(void *ctx)\n{\n\tstruct node_acquire *n, *m;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\t \n\tm = bpf_refcount_acquire(n);\n\tbpf_spin_unlock(&glock);\n\tif (!m)\n\t\treturn 2;\n\n\tm->key = 2;\n\treturn 0;\n}\n\nSEC(\"?tc\")\n__failure __msg(\"Unreleased reference id=3 alloc_insn=9\")\nlong rbtree_refcounted_node_ref_escapes_owning_input(void *ctx)\n{\n\tstruct node_acquire *n, *m;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 1;\n\n\t \n\tm = bpf_refcount_acquire(n);\n\tm->key = 2;\n\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\tbpf_spin_unlock(&glock);\n\n\treturn 0;\n}\n\nSEC(\"?fentry.s/bpf_testmod_test_read\")\n__failure __msg(\"function calls are not allowed while holding a lock\")\nint BPF_PROG(rbtree_fail_sleepable_lock_across_rcu,\n\t     struct file *file, struct kobject *kobj,\n\t     struct bin_attribute *bin_attr, char *buf, loff_t off, size_t len)\n{\n\tstruct node_acquire *n;\n\n\tn = bpf_obj_new(typeof(*n));\n\tif (!n)\n\t\treturn 0;\n\n\t \n\tbpf_rcu_read_lock();\n\tbpf_spin_lock(&glock);\n\tbpf_rbtree_add(&groot, &n->node, less);\n\tbpf_rcu_read_unlock();\n\n\tbpf_rcu_read_lock();\n\tbpf_spin_unlock(&glock);\n\tbpf_rcu_read_unlock();\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}