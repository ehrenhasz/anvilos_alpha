{
  "module_name": "test_parse_tcp_hdr_opt.c",
  "hash_id": "a6371b9406e4741c00f3ece8c94ebe5f4d4a81e62aff175d6c9247db31362e9f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/progs/test_parse_tcp_hdr_opt.c",
  "human_readable_source": "\n\n \n\n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <linux/tcp.h>\n#include <stdbool.h>\n#include <linux/ipv6.h>\n#include <linux/if_ether.h>\n#include \"test_tcp_hdr_options.h\"\n\nchar _license[] SEC(\"license\") = \"GPL\";\n\n \nconst __u32 tcp_hdr_opt_kind_tpr = 0xFD;\n \nconst __u32 tcp_hdr_opt_len_tpr = 6;\n \nconst __u32 tcp_hdr_opt_max_opt_checks = 15;\n\n__u32 server_id;\n\nstruct hdr_opt_state {\n\t__u32 server_id;\n\t__u8 byte_offset;\n\t__u8 hdr_bytes_remaining;\n};\n\nstatic int parse_hdr_opt(const struct xdp_md *xdp, struct hdr_opt_state *state)\n{\n\tconst void *data = (void *)(long)xdp->data;\n\tconst void *data_end = (void *)(long)xdp->data_end;\n\t__u8 *tcp_opt, kind, hdr_len;\n\n\ttcp_opt = (__u8 *)(data + state->byte_offset);\n\tif (tcp_opt + 1 > data_end)\n\t\treturn -1;\n\n\tkind = tcp_opt[0];\n\n\tif (kind == TCPOPT_EOL)\n\t\treturn -1;\n\n\tif (kind == TCPOPT_NOP) {\n\t\tstate->hdr_bytes_remaining--;\n\t\tstate->byte_offset++;\n\t\treturn 0;\n\t}\n\n\tif (state->hdr_bytes_remaining < 2 ||\n\t    tcp_opt + sizeof(__u8) + sizeof(__u8) > data_end)\n\t\treturn -1;\n\n\thdr_len = tcp_opt[1];\n\tif (hdr_len > state->hdr_bytes_remaining)\n\t\treturn -1;\n\n\tif (kind == tcp_hdr_opt_kind_tpr) {\n\t\tif (hdr_len != tcp_hdr_opt_len_tpr)\n\t\t\treturn -1;\n\n\t\tif (tcp_opt + tcp_hdr_opt_len_tpr > data_end)\n\t\t\treturn -1;\n\n\t\tstate->server_id = *(__u32 *)&tcp_opt[2];\n\t\treturn 1;\n\t}\n\n\tstate->hdr_bytes_remaining -= hdr_len;\n\tstate->byte_offset += hdr_len;\n\treturn 0;\n}\n\nSEC(\"xdp\")\nint xdp_ingress_v6(struct xdp_md *xdp)\n{\n\tconst void *data = (void *)(long)xdp->data;\n\tconst void *data_end = (void *)(long)xdp->data_end;\n\tstruct hdr_opt_state opt_state = {};\n\t__u8 tcp_hdr_opt_len = 0;\n\tstruct tcphdr *tcp_hdr;\n\t__u64 tcp_offset = 0;\n\tint err;\n\n\ttcp_offset = sizeof(struct ethhdr) + sizeof(struct ipv6hdr);\n\ttcp_hdr = (struct tcphdr *)(data + tcp_offset);\n\tif (tcp_hdr + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\ttcp_hdr_opt_len = (tcp_hdr->doff * 4) - sizeof(struct tcphdr);\n\tif (tcp_hdr_opt_len < tcp_hdr_opt_len_tpr)\n\t\treturn XDP_DROP;\n\n\topt_state.hdr_bytes_remaining = tcp_hdr_opt_len;\n\topt_state.byte_offset = sizeof(struct tcphdr) + tcp_offset;\n\n\t \n\tfor (int i = 0; i < tcp_hdr_opt_max_opt_checks; i++) {\n\t\terr = parse_hdr_opt(xdp, &opt_state);\n\n\t\tif (err || !opt_state.hdr_bytes_remaining)\n\t\t\tbreak;\n\t}\n\n\tif (!opt_state.server_id)\n\t\treturn XDP_DROP;\n\n\tserver_id = opt_state.server_id;\n\n\treturn XDP_PASS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}