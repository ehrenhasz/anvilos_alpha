{
  "module_name": "test_offload.py",
  "hash_id": "9a77339b8fdecbe4441baec706064b200f20d4ee9bab4433381e3a057f87bc4a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_offload.py",
  "human_readable_source": "#!/usr/bin/env python3\n\n# Copyright (C) 2017 Netronome Systems, Inc.\n# Copyright (c) 2019 Mellanox Technologies. All rights reserved\n#\n# This software is licensed under the GNU General License Version 2,\n# June 1991 as shown in the file COPYING in the top-level directory of this\n# source tree.\n#\n# THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\"\n# WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,\n# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE\n# OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME\n# THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nfrom datetime import datetime\nimport argparse\nimport errno\nimport json\nimport os\nimport pprint\nimport random\nimport re\nimport stat\nimport string\nimport struct\nimport subprocess\nimport time\nimport traceback\n\nlogfile = None\nlog_level = 1\nskip_extack = False\nbpf_test_dir = os.path.dirname(os.path.realpath(__file__))\npp = pprint.PrettyPrinter()\ndevs = [] # devices we created for clean up\nfiles = [] # files to be removed\nnetns = [] # net namespaces to be removed\n\ndef log_get_sec(level=0):\n    return \"*\" * (log_level + level)\n\ndef log_level_inc(add=1):\n    global log_level\n    log_level += add\n\ndef log_level_dec(sub=1):\n    global log_level\n    log_level -= sub\n\ndef log_level_set(level):\n    global log_level\n    log_level = level\n\ndef log(header, data, level=None):\n    \"\"\"\n    Output to an optional log.\n    \"\"\"\n    if logfile is None:\n        return\n    if level is not None:\n        log_level_set(level)\n\n    if not isinstance(data, str):\n        data = pp.pformat(data)\n\n    if len(header):\n        logfile.write(\"\\n\" + log_get_sec() + \" \")\n        logfile.write(header)\n    if len(header) and len(data.strip()):\n        logfile.write(\"\\n\")\n    logfile.write(data)\n\ndef skip(cond, msg):\n    if not cond:\n        return\n    print(\"SKIP: \" + msg)\n    log(\"SKIP: \" + msg, \"\", level=1)\n    os.sys.exit(0)\n\ndef fail(cond, msg):\n    if not cond:\n        return\n    print(\"FAIL: \" + msg)\n    tb = \"\".join(traceback.extract_stack().format())\n    print(tb)\n    log(\"FAIL: \" + msg, tb, level=1)\n    os.sys.exit(1)\n\ndef start_test(msg):\n    log(msg, \"\", level=1)\n    log_level_inc()\n    print(msg)\n\ndef cmd(cmd, shell=True, include_stderr=False, background=False, fail=True):\n    \"\"\"\n    Run a command in subprocess and return tuple of (retval, stdout);\n    optionally return stderr as well as third value.\n    \"\"\"\n    proc = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE,\n                            stderr=subprocess.PIPE)\n    if background:\n        msg = \"%s START: %s\" % (log_get_sec(1),\n                                datetime.now().strftime(\"%H:%M:%S.%f\"))\n        log(\"BKG \" + proc.args, msg)\n        return proc\n\n    return cmd_result(proc, include_stderr=include_stderr, fail=fail)\n\ndef cmd_result(proc, include_stderr=False, fail=False):\n    stdout, stderr = proc.communicate()\n    stdout = stdout.decode(\"utf-8\")\n    stderr = stderr.decode(\"utf-8\")\n    proc.stdout.close()\n    proc.stderr.close()\n\n    stderr = \"\\n\" + stderr\n    if stderr[-1] == \"\\n\":\n        stderr = stderr[:-1]\n\n    sec = log_get_sec(1)\n    log(\"CMD \" + proc.args,\n        \"RETCODE: %d\\n%s STDOUT:\\n%s%s STDERR:%s\\n%s END: %s\" %\n        (proc.returncode, sec, stdout, sec, stderr,\n         sec, datetime.now().strftime(\"%H:%M:%S.%f\")))\n\n    if proc.returncode != 0 and fail:\n        if len(stderr) > 0 and stderr[-1] == \"\\n\":\n            stderr = stderr[:-1]\n        raise Exception(\"Command failed: %s\\n%s\" % (proc.args, stderr))\n\n    if include_stderr:\n        return proc.returncode, stdout, stderr\n    else:\n        return proc.returncode, stdout\n\ndef rm(f):\n    cmd(\"rm -f %s\" % (f))\n    if f in files:\n        files.remove(f)\n\ndef tool(name, args, flags, JSON=True, ns=\"\", fail=True, include_stderr=False):\n    params = \"\"\n    if JSON:\n        params += \"%s \" % (flags[\"json\"])\n\n    if ns != \"\":\n        ns = \"ip netns exec %s \" % (ns)\n\n    if include_stderr:\n        ret, stdout, stderr = cmd(ns + name + \" \" + params + args,\n                                  fail=fail, include_stderr=True)\n    else:\n        ret, stdout = cmd(ns + name + \" \" + params + args,\n                          fail=fail, include_stderr=False)\n\n    if JSON and len(stdout.strip()) != 0:\n        out = json.loads(stdout)\n    else:\n        out = stdout\n\n    if include_stderr:\n        return ret, out, stderr\n    else:\n        return ret, out\n\ndef bpftool(args, JSON=True, ns=\"\", fail=True, include_stderr=False):\n    return tool(\"bpftool\", args, {\"json\":\"-p\"}, JSON=JSON, ns=ns,\n                fail=fail, include_stderr=include_stderr)\n\ndef bpftool_prog_list(expected=None, ns=\"\"):\n    _, progs = bpftool(\"prog show\", JSON=True, ns=ns, fail=True)\n    # Remove the base progs\n    for p in base_progs:\n        if p in progs:\n            progs.remove(p)\n    if expected is not None:\n        if len(progs) != expected:\n            fail(True, \"%d BPF programs loaded, expected %d\" %\n                 (len(progs), expected))\n    return progs\n\ndef bpftool_map_list(expected=None, ns=\"\"):\n    _, maps = bpftool(\"map show\", JSON=True, ns=ns, fail=True)\n    # Remove the base maps\n    maps = [m for m in maps if m not in base_maps and m.get('name') and m.get('name') not in base_map_names]\n    if expected is not None:\n        if len(maps) != expected:\n            fail(True, \"%d BPF maps loaded, expected %d\" %\n                 (len(maps), expected))\n    return maps\n\ndef bpftool_prog_list_wait(expected=0, n_retry=20):\n    for i in range(n_retry):\n        nprogs = len(bpftool_prog_list())\n        if nprogs == expected:\n            return\n        time.sleep(0.05)\n    raise Exception(\"Time out waiting for program counts to stabilize want %d, have %d\" % (expected, nprogs))\n\ndef bpftool_map_list_wait(expected=0, n_retry=20):\n    for i in range(n_retry):\n        nmaps = len(bpftool_map_list())\n        if nmaps == expected:\n            return\n        time.sleep(0.05)\n    raise Exception(\"Time out waiting for map counts to stabilize want %d, have %d\" % (expected, nmaps))\n\ndef bpftool_prog_load(sample, file_name, maps=[], prog_type=\"xdp\", dev=None,\n                      fail=True, include_stderr=False):\n    args = \"prog load %s %s\" % (os.path.join(bpf_test_dir, sample), file_name)\n    if prog_type is not None:\n        args += \" type \" + prog_type\n    if dev is not None:\n        args += \" dev \" + dev\n    if len(maps):\n        args += \" map \" + \" map \".join(maps)\n\n    res = bpftool(args, fail=fail, include_stderr=include_stderr)\n    if res[0] == 0:\n        files.append(file_name)\n    return res\n\ndef ip(args, force=False, JSON=True, ns=\"\", fail=True, include_stderr=False):\n    if force:\n        args = \"-force \" + args\n    return tool(\"ip\", args, {\"json\":\"-j\"}, JSON=JSON, ns=ns,\n                fail=fail, include_stderr=include_stderr)\n\ndef tc(args, JSON=True, ns=\"\", fail=True, include_stderr=False):\n    return tool(\"tc\", args, {\"json\":\"-p\"}, JSON=JSON, ns=ns,\n                fail=fail, include_stderr=include_stderr)\n\ndef ethtool(dev, opt, args, fail=True):\n    return cmd(\"ethtool %s %s %s\" % (opt, dev[\"ifname\"], args), fail=fail)\n\ndef bpf_obj(name, sec=\".text\", path=bpf_test_dir,):\n    return \"obj %s sec %s\" % (os.path.join(path, name), sec)\n\ndef bpf_pinned(name):\n    return \"pinned %s\" % (name)\n\ndef bpf_bytecode(bytecode):\n    return \"bytecode \\\"%s\\\"\" % (bytecode)\n\ndef mknetns(n_retry=10):\n    for i in range(n_retry):\n        name = ''.join([random.choice(string.ascii_letters) for i in range(8)])\n        ret, _ = ip(\"netns add %s\" % (name), fail=False)\n        if ret == 0:\n            netns.append(name)\n            return name\n    return None\n\ndef int2str(fmt, val):\n    ret = []\n    for b in struct.pack(fmt, val):\n        ret.append(int(b))\n    return \" \".join(map(lambda x: str(x), ret))\n\ndef str2int(strtab):\n    inttab = []\n    for i in strtab:\n        inttab.append(int(i, 16))\n    ba = bytearray(inttab)\n    if len(strtab) == 4:\n        fmt = \"I\"\n    elif len(strtab) == 8:\n        fmt = \"Q\"\n    else:\n        raise Exception(\"String array of len %d can't be unpacked to an int\" %\n                        (len(strtab)))\n    return struct.unpack(fmt, ba)[0]\n\nclass DebugfsDir:\n    \"\"\"\n    Class for accessing DebugFS directories as a dictionary.\n    \"\"\"\n\n    def __init__(self, path):\n        self.path = path\n        self._dict = self._debugfs_dir_read(path)\n\n    def __len__(self):\n        return len(self._dict.keys())\n\n    def __getitem__(self, key):\n        if type(key) is int:\n            key = list(self._dict.keys())[key]\n        return self._dict[key]\n\n    def __setitem__(self, key, value):\n        log(\"DebugFS set %s = %s\" % (key, value), \"\")\n        log_level_inc()\n\n        cmd(\"echo '%s' > %s/%s\" % (value, self.path, key))\n        log_level_dec()\n\n        _, out = cmd('cat %s/%s' % (self.path, key))\n        self._dict[key] = out.strip()\n\n    def _debugfs_dir_read(self, path):\n        dfs = {}\n\n        log(\"DebugFS state for %s\" % (path), \"\")\n        log_level_inc(add=2)\n\n        _, out = cmd('ls ' + path)\n        for f in out.split():\n            if f == \"ports\":\n                continue\n\n            p = os.path.join(path, f)\n            if not os.stat(p).st_mode & stat.S_IRUSR:\n                continue\n\n            if os.path.isfile(p):\n                # We need to init trap_flow_action_cookie before read it\n                if f == \"trap_flow_action_cookie\":\n                    cmd('echo deadbeef > %s/%s' % (path, f))\n                _, out = cmd('cat %s/%s' % (path, f))\n                dfs[f] = out.strip()\n            elif os.path.isdir(p):\n                dfs[f] = DebugfsDir(p)\n            else:\n                raise Exception(\"%s is neither file nor directory\" % (p))\n\n        log_level_dec()\n        log(\"DebugFS state\", dfs)\n        log_level_dec()\n\n        return dfs\n\nclass NetdevSimDev:\n    \"\"\"\n    Class for netdevsim bus device and its attributes.\n    \"\"\"\n    @staticmethod\n    def ctrl_write(path, val):\n        fullpath = os.path.join(\"/sys/bus/netdevsim/\", path)\n        try:\n            with open(fullpath, \"w\") as f:\n                f.write(val)\n        except OSError as e:\n            log(\"WRITE %s: %r\" % (fullpath, val), -e.errno)\n            raise e\n        log(\"WRITE %s: %r\" % (fullpath, val), 0)\n\n    def __init__(self, port_count=1):\n        addr = 0\n        while True:\n            try:\n                self.ctrl_write(\"new_device\", \"%u %u\" % (addr, port_count))\n            except OSError as e:\n                if e.errno == errno.ENOSPC:\n                    addr += 1\n                    continue\n                raise e\n            break\n        self.addr = addr\n\n        # As probe of netdevsim device might happen from a workqueue,\n        # so wait here until all netdevs appear.\n        self.wait_for_netdevs(port_count)\n\n        ret, out = cmd(\"udevadm settle\", fail=False)\n        if ret:\n            raise Exception(\"udevadm settle failed\")\n        ifnames = self.get_ifnames()\n\n        devs.append(self)\n        self.dfs_dir = \"/sys/kernel/debug/netdevsim/netdevsim%u/\" % addr\n\n        self.nsims = []\n        for port_index in range(port_count):\n            self.nsims.append(NetdevSim(self, port_index, ifnames[port_index]))\n\n    def get_ifnames(self):\n        ifnames = []\n        listdir = os.listdir(\"/sys/bus/netdevsim/devices/netdevsim%u/net/\" % self.addr)\n        for ifname in listdir:\n            ifnames.append(ifname)\n        ifnames.sort()\n        return ifnames\n\n    def wait_for_netdevs(self, port_count):\n        timeout = 5\n        timeout_start = time.time()\n\n        while True:\n            try:\n                ifnames = self.get_ifnames()\n            except FileNotFoundError as e:\n                ifnames = []\n            if len(ifnames) == port_count:\n                break\n            if time.time() < timeout_start + timeout:\n                continue\n            raise Exception(\"netdevices did not appear within timeout\")\n\n    def dfs_num_bound_progs(self):\n        path = os.path.join(self.dfs_dir, \"bpf_bound_progs\")\n        _, progs = cmd('ls %s' % (path))\n        return len(progs.split())\n\n    def dfs_get_bound_progs(self, expected):\n        progs = DebugfsDir(os.path.join(self.dfs_dir, \"bpf_bound_progs\"))\n        if expected is not None:\n            if len(progs) != expected:\n                fail(True, \"%d BPF programs bound, expected %d\" %\n                     (len(progs), expected))\n        return progs\n\n    def remove(self):\n        self.ctrl_write(\"del_device\", \"%u\" % (self.addr, ))\n        devs.remove(self)\n\n    def remove_nsim(self, nsim):\n        self.nsims.remove(nsim)\n        self.ctrl_write(\"devices/netdevsim%u/del_port\" % (self.addr, ),\n                        \"%u\" % (nsim.port_index, ))\n\nclass NetdevSim:\n    \"\"\"\n    Class for netdevsim netdevice and its attributes.\n    \"\"\"\n\n    def __init__(self, nsimdev, port_index, ifname):\n        # In case udev renamed the netdev to according to new schema,\n        # check if the name matches the port_index.\n        nsimnamere = re.compile(\"eni\\d+np(\\d+)\")\n        match = nsimnamere.match(ifname)\n        if match and int(match.groups()[0]) != port_index + 1:\n            raise Exception(\"netdevice name mismatches the expected one\")\n\n        self.nsimdev = nsimdev\n        self.port_index = port_index\n        self.ns = \"\"\n        self.dfs_dir = \"%s/ports/%u/\" % (nsimdev.dfs_dir, port_index)\n        self.dfs_refresh()\n        _, [self.dev] = ip(\"link show dev %s\" % ifname)\n\n    def __getitem__(self, key):\n        return self.dev[key]\n\n    def remove(self):\n        self.nsimdev.remove_nsim(self)\n\n    def dfs_refresh(self):\n        self.dfs = DebugfsDir(self.dfs_dir)\n        return self.dfs\n\n    def dfs_read(self, f):\n        path = os.path.join(self.dfs_dir, f)\n        _, data = cmd('cat %s' % (path))\n        return data.strip()\n\n    def wait_for_flush(self, bound=0, total=0, n_retry=20):\n        for i in range(n_retry):\n            nbound = self.nsimdev.dfs_num_bound_progs()\n            nprogs = len(bpftool_prog_list())\n            if nbound == bound and nprogs == total:\n                return\n            time.sleep(0.05)\n        raise Exception(\"Time out waiting for program counts to stabilize want %d/%d, have %d bound, %d loaded\" % (bound, total, nbound, nprogs))\n\n    def set_ns(self, ns):\n        name = \"1\" if ns == \"\" else ns\n        ip(\"link set dev %s netns %s\" % (self.dev[\"ifname\"], name), ns=self.ns)\n        self.ns = ns\n\n    def set_mtu(self, mtu, fail=True):\n        return ip(\"link set dev %s mtu %d\" % (self.dev[\"ifname\"], mtu),\n                  fail=fail)\n\n    def set_xdp(self, bpf, mode, force=False, JSON=True, verbose=False,\n                fail=True, include_stderr=False):\n        if verbose:\n            bpf += \" verbose\"\n        return ip(\"link set dev %s xdp%s %s\" % (self.dev[\"ifname\"], mode, bpf),\n                  force=force, JSON=JSON,\n                  fail=fail, include_stderr=include_stderr)\n\n    def unset_xdp(self, mode, force=False, JSON=True,\n                  fail=True, include_stderr=False):\n        return ip(\"link set dev %s xdp%s off\" % (self.dev[\"ifname\"], mode),\n                  force=force, JSON=JSON,\n                  fail=fail, include_stderr=include_stderr)\n\n    def ip_link_show(self, xdp):\n        _, link = ip(\"link show dev %s\" % (self['ifname']))\n        if len(link) > 1:\n            raise Exception(\"Multiple objects on ip link show\")\n        if len(link) < 1:\n            return {}\n        fail(xdp != \"xdp\" in link,\n             \"XDP program not reporting in iplink (reported %s, expected %s)\" %\n             (\"xdp\" in link, xdp))\n        return link[0]\n\n    def tc_add_ingress(self):\n        tc(\"qdisc add dev %s ingress\" % (self['ifname']))\n\n    def tc_del_ingress(self):\n        tc(\"qdisc del dev %s ingress\" % (self['ifname']))\n\n    def tc_flush_filters(self, bound=0, total=0):\n        self.tc_del_ingress()\n        self.tc_add_ingress()\n        self.wait_for_flush(bound=bound, total=total)\n\n    def tc_show_ingress(self, expected=None):\n        # No JSON support, oh well...\n        flags = [\"skip_sw\", \"skip_hw\", \"in_hw\"]\n        named = [\"protocol\", \"pref\", \"chain\", \"handle\", \"id\", \"tag\"]\n\n        args = \"-s filter show dev %s ingress\" % (self['ifname'])\n        _, out = tc(args, JSON=False)\n\n        filters = []\n        lines = out.split('\\n')\n        for line in lines:\n            words = line.split()\n            if \"handle\" not in words:\n                continue\n            fltr = {}\n            for flag in flags:\n                fltr[flag] = flag in words\n            for name in named:\n                try:\n                    idx = words.index(name)\n                    fltr[name] = words[idx + 1]\n                except ValueError:\n                    pass\n            filters.append(fltr)\n\n        if expected is not None:\n            fail(len(filters) != expected,\n                 \"%d ingress filters loaded, expected %d\" %\n                 (len(filters), expected))\n        return filters\n\n    def cls_filter_op(self, op, qdisc=\"ingress\", prio=None, handle=None,\n                      chain=None, cls=\"\", params=\"\",\n                      fail=True, include_stderr=False):\n        spec = \"\"\n        if prio is not None:\n            spec += \" prio %d\" % (prio)\n        if handle:\n            spec += \" handle %s\" % (handle)\n        if chain is not None:\n            spec += \" chain %d\" % (chain)\n\n        return tc(\"filter {op} dev {dev} {qdisc} {spec} {cls} {params}\"\\\n                  .format(op=op, dev=self['ifname'], qdisc=qdisc, spec=spec,\n                          cls=cls, params=params),\n                  fail=fail, include_stderr=include_stderr)\n\n    def cls_bpf_add_filter(self, bpf, op=\"add\", prio=None, handle=None,\n                           chain=None, da=False, verbose=False,\n                           skip_sw=False, skip_hw=False,\n                           fail=True, include_stderr=False):\n        cls = \"bpf \" + bpf\n\n        params = \"\"\n        if da:\n            params += \" da\"\n        if verbose:\n            params += \" verbose\"\n        if skip_sw:\n            params += \" skip_sw\"\n        if skip_hw:\n            params += \" skip_hw\"\n\n        return self.cls_filter_op(op=op, prio=prio, handle=handle, cls=cls,\n                                  chain=chain, params=params,\n                                  fail=fail, include_stderr=include_stderr)\n\n    def set_ethtool_tc_offloads(self, enable, fail=True):\n        args = \"hw-tc-offload %s\" % (\"on\" if enable else \"off\")\n        return ethtool(self, \"-K\", args, fail=fail)\n\n################################################################################\ndef clean_up():\n    global files, netns, devs\n\n    for dev in devs:\n        dev.remove()\n    for f in files:\n        cmd(\"rm -f %s\" % (f))\n    for ns in netns:\n        cmd(\"ip netns delete %s\" % (ns))\n    files = []\n    netns = []\n\ndef pin_prog(file_name, idx=0):\n    progs = bpftool_prog_list(expected=(idx + 1))\n    prog = progs[idx]\n    bpftool(\"prog pin id %d %s\" % (prog[\"id\"], file_name))\n    files.append(file_name)\n\n    return file_name, bpf_pinned(file_name)\n\ndef pin_map(file_name, idx=0, expected=1):\n    maps = bpftool_map_list(expected=expected)\n    m = maps[idx]\n    bpftool(\"map pin id %d %s\" % (m[\"id\"], file_name))\n    files.append(file_name)\n\n    return file_name, bpf_pinned(file_name)\n\ndef check_dev_info_removed(prog_file=None, map_file=None):\n    bpftool_prog_list(expected=0)\n    ret, err = bpftool(\"prog show pin %s\" % (prog_file), fail=False)\n    fail(ret == 0, \"Showing prog with removed device did not fail\")\n    fail(err[\"error\"].find(\"No such device\") == -1,\n         \"Showing prog with removed device expected ENODEV, error is %s\" %\n         (err[\"error\"]))\n\n    bpftool_map_list(expected=0)\n    ret, err = bpftool(\"map show pin %s\" % (map_file), fail=False)\n    fail(ret == 0, \"Showing map with removed device did not fail\")\n    fail(err[\"error\"].find(\"No such device\") == -1,\n         \"Showing map with removed device expected ENODEV, error is %s\" %\n         (err[\"error\"]))\n\ndef check_dev_info(other_ns, ns, prog_file=None, map_file=None, removed=False):\n    progs = bpftool_prog_list(expected=1, ns=ns)\n    prog = progs[0]\n\n    fail(\"dev\" not in prog.keys(), \"Device parameters not reported\")\n    dev = prog[\"dev\"]\n    fail(\"ifindex\" not in dev.keys(), \"Device parameters not reported\")\n    fail(\"ns_dev\" not in dev.keys(), \"Device parameters not reported\")\n    fail(\"ns_inode\" not in dev.keys(), \"Device parameters not reported\")\n\n    if not other_ns:\n        fail(\"ifname\" not in dev.keys(), \"Ifname not reported\")\n        fail(dev[\"ifname\"] != sim[\"ifname\"],\n             \"Ifname incorrect %s vs %s\" % (dev[\"ifname\"], sim[\"ifname\"]))\n    else:\n        fail(\"ifname\" in dev.keys(), \"Ifname is reported for other ns\")\n\n    maps = bpftool_map_list(expected=2, ns=ns)\n    for m in maps:\n        fail(\"dev\" not in m.keys(), \"Device parameters not reported\")\n        fail(dev != m[\"dev\"], \"Map's device different than program's\")\n\ndef check_extack(output, reference, args):\n    if skip_extack:\n        return\n    lines = output.split(\"\\n\")\n    comp = len(lines) >= 2 and lines[1] == 'Error: ' + reference\n    fail(not comp, \"Missing or incorrect netlink extack message\")\n\ndef check_extack_nsim(output, reference, args):\n    check_extack(output, \"netdevsim: \" + reference, args)\n\ndef check_no_extack(res, needle):\n    fail((res[1] + res[2]).count(needle) or (res[1] + res[2]).count(\"Warning:\"),\n         \"Found '%s' in command output, leaky extack?\" % (needle))\n\ndef check_verifier_log(output, reference):\n    lines = output.split(\"\\n\")\n    for l in reversed(lines):\n        if l == reference:\n            return\n    fail(True, \"Missing or incorrect message from netdevsim in verifier log\")\n\ndef check_multi_basic(two_xdps):\n    fail(two_xdps[\"mode\"] != 4, \"Bad mode reported with multiple programs\")\n    fail(\"prog\" in two_xdps, \"Base program reported in multi program mode\")\n    fail(len(two_xdps[\"attached\"]) != 2,\n         \"Wrong attached program count with two programs\")\n    fail(two_xdps[\"attached\"][0][\"prog\"][\"id\"] ==\n         two_xdps[\"attached\"][1][\"prog\"][\"id\"],\n         \"Offloaded and other programs have the same id\")\n\ndef test_spurios_extack(sim, obj, skip_hw, needle):\n    res = sim.cls_bpf_add_filter(obj, prio=1, handle=1, skip_hw=skip_hw,\n                                 include_stderr=True)\n    check_no_extack(res, needle)\n    res = sim.cls_bpf_add_filter(obj, op=\"replace\", prio=1, handle=1,\n                                 skip_hw=skip_hw, include_stderr=True)\n    check_no_extack(res, needle)\n    res = sim.cls_filter_op(op=\"delete\", prio=1, handle=1, cls=\"bpf\",\n                            include_stderr=True)\n    check_no_extack(res, needle)\n\ndef test_multi_prog(simdev, sim, obj, modename, modeid):\n    start_test(\"Test multi-attachment XDP - %s + offload...\" %\n               (modename or \"default\", ))\n    sim.set_xdp(obj, \"offload\")\n    xdp = sim.ip_link_show(xdp=True)[\"xdp\"]\n    offloaded = sim.dfs_read(\"bpf_offloaded_id\")\n    fail(\"prog\" not in xdp, \"Base program not reported in single program mode\")\n    fail(len(xdp[\"attached\"]) != 1,\n         \"Wrong attached program count with one program\")\n\n    sim.set_xdp(obj, modename)\n    two_xdps = sim.ip_link_show(xdp=True)[\"xdp\"]\n\n    fail(xdp[\"attached\"][0] not in two_xdps[\"attached\"],\n         \"Offload program not reported after other activated\")\n    check_multi_basic(two_xdps)\n\n    offloaded2 = sim.dfs_read(\"bpf_offloaded_id\")\n    fail(offloaded != offloaded2,\n         \"Offload ID changed after loading other program\")\n\n    start_test(\"Test multi-attachment XDP - replace...\")\n    ret, _, err = sim.set_xdp(obj, \"offload\", fail=False, include_stderr=True)\n    fail(ret == 0, \"Replaced one of programs without -force\")\n    check_extack(err, \"XDP program already attached.\", args)\n\n    start_test(\"Test multi-attachment XDP - remove without mode...\")\n    ret, _, err = sim.unset_xdp(\"\", force=True,\n                                fail=False, include_stderr=True)\n    fail(ret == 0, \"Removed program without a mode flag\")\n    check_extack(err, \"More than one program loaded, unset mode is ambiguous.\", args)\n\n    sim.unset_xdp(\"offload\")\n    xdp = sim.ip_link_show(xdp=True)[\"xdp\"]\n    offloaded = sim.dfs_read(\"bpf_offloaded_id\")\n\n    fail(xdp[\"mode\"] != modeid, \"Bad mode reported after multiple programs\")\n    fail(\"prog\" not in xdp,\n         \"Base program not reported after multi program mode\")\n    fail(xdp[\"attached\"][0] not in two_xdps[\"attached\"],\n         \"Offload program not reported after other activated\")\n    fail(len(xdp[\"attached\"]) != 1,\n         \"Wrong attached program count with remaining programs\")\n    fail(offloaded != \"0\", \"Offload ID reported with only other program left\")\n\n    start_test(\"Test multi-attachment XDP - reattach...\")\n    sim.set_xdp(obj, \"offload\")\n    two_xdps = sim.ip_link_show(xdp=True)[\"xdp\"]\n\n    fail(xdp[\"attached\"][0] not in two_xdps[\"attached\"],\n         \"Other program not reported after offload activated\")\n    check_multi_basic(two_xdps)\n\n    start_test(\"Test multi-attachment XDP - device remove...\")\n    simdev.remove()\n\n    simdev = NetdevSimDev()\n    sim, = simdev.nsims\n    sim.set_ethtool_tc_offloads(True)\n    return [simdev, sim]\n\n# Parse command line\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--log\", help=\"output verbose log to given file\")\nargs = parser.parse_args()\nif args.log:\n    logfile = open(args.log, 'w+')\n    logfile.write(\"# -*-Org-*-\")\n\nlog(\"Prepare...\", \"\", level=1)\nlog_level_inc()\n\n# Check permissions\nskip(os.getuid() != 0, \"test must be run as root\")\n\n# Check tools\nret, progs = bpftool(\"prog\", fail=False)\nskip(ret != 0, \"bpftool not installed\")\nbase_progs = progs\n_, base_maps = bpftool(\"map\")\nbase_map_names = [\n    'pid_iter.rodata', # created on each bpftool invocation\n    'libbpf_det_bind', # created on each bpftool invocation\n]\n\n# Check netdevsim\nif not os.path.isdir(\"/sys/bus/netdevsim/\"):\n    ret, out = cmd(\"modprobe netdevsim\", fail=False)\n    skip(ret != 0, \"netdevsim module could not be loaded\")\n\n# Check debugfs\n_, out = cmd(\"mount\")\nif out.find(\"/sys/kernel/debug type debugfs\") == -1:\n    cmd(\"mount -t debugfs none /sys/kernel/debug\")\n\n# Check samples are compiled\nsamples = [\"sample_ret0.bpf.o\", \"sample_map_ret0.bpf.o\"]\nfor s in samples:\n    ret, out = cmd(\"ls %s/%s\" % (bpf_test_dir, s), fail=False)\n    skip(ret != 0, \"sample %s/%s not found, please compile it\" %\n         (bpf_test_dir, s))\n\n# Check if iproute2 is built with libmnl (needed by extack support)\n_, _, err = cmd(\"tc qdisc delete dev lo handle 0\",\n                fail=False, include_stderr=True)\nif err.find(\"Error: Failed to find qdisc with specified handle.\") == -1:\n    print(\"Warning: no extack message in iproute2 output, libmnl missing?\")\n    log(\"Warning: no extack message in iproute2 output, libmnl missing?\", \"\")\n    skip_extack = True\n\n# Check if net namespaces seem to work\nns = mknetns()\nskip(ns is None, \"Could not create a net namespace\")\ncmd(\"ip netns delete %s\" % (ns))\nnetns = []\n\ntry:\n    obj = bpf_obj(\"sample_ret0.bpf.o\")\n    bytecode = bpf_bytecode(\"1,6 0 0 4294967295,\")\n\n    start_test(\"Test destruction of generic XDP...\")\n    simdev = NetdevSimDev()\n    sim, = simdev.nsims\n    sim.set_xdp(obj, \"generic\")\n    simdev.remove()\n    bpftool_prog_list_wait(expected=0)\n\n    simdev = NetdevSimDev()\n    sim, = simdev.nsims\n    sim.tc_add_ingress()\n\n    start_test(\"Test TC non-offloaded...\")\n    ret, _ = sim.cls_bpf_add_filter(obj, skip_hw=True, fail=False)\n    fail(ret != 0, \"Software TC filter did not load\")\n\n    start_test(\"Test TC non-offloaded isn't getting bound...\")\n    ret, _ = sim.cls_bpf_add_filter(obj, fail=False)\n    fail(ret != 0, \"Software TC filter did not load\")\n    simdev.dfs_get_bound_progs(expected=0)\n\n    sim.tc_flush_filters()\n\n    start_test(\"Test TC offloads are off by default...\")\n    ret, _, err = sim.cls_bpf_add_filter(obj, skip_sw=True,\n                                         fail=False, include_stderr=True)\n    fail(ret == 0, \"TC filter loaded without enabling TC offloads\")\n    check_extack(err, \"TC offload is disabled on net device.\", args)\n    sim.wait_for_flush()\n\n    sim.set_ethtool_tc_offloads(True)\n    sim.dfs[\"bpf_tc_non_bound_accept\"] = \"Y\"\n\n    start_test(\"Test TC offload by default...\")\n    ret, _ = sim.cls_bpf_add_filter(obj, fail=False)\n    fail(ret != 0, \"Software TC filter did not load\")\n    simdev.dfs_get_bound_progs(expected=0)\n    ingress = sim.tc_show_ingress(expected=1)\n    fltr = ingress[0]\n    fail(not fltr[\"in_hw\"], \"Filter not offloaded by default\")\n\n    sim.tc_flush_filters()\n\n    start_test(\"Test TC cBPF bytcode tries offload by default...\")\n    ret, _ = sim.cls_bpf_add_filter(bytecode, fail=False)\n    fail(ret != 0, \"Software TC filter did not load\")\n    simdev.dfs_get_bound_progs(expected=0)\n    ingress = sim.tc_show_ingress(expected=1)\n    fltr = ingress[0]\n    fail(not fltr[\"in_hw\"], \"Bytecode not offloaded by default\")\n\n    sim.tc_flush_filters()\n    sim.dfs[\"bpf_tc_non_bound_accept\"] = \"N\"\n\n    start_test(\"Test TC cBPF unbound bytecode doesn't offload...\")\n    ret, _, err = sim.cls_bpf_add_filter(bytecode, skip_sw=True,\n                                         fail=False, include_stderr=True)\n    fail(ret == 0, \"TC bytecode loaded for offload\")\n    check_extack_nsim(err, \"netdevsim configured to reject unbound programs.\",\n                      args)\n    sim.wait_for_flush()\n\n    start_test(\"Test non-0 chain offload...\")\n    ret, _, err = sim.cls_bpf_add_filter(obj, chain=1, prio=1, handle=1,\n                                         skip_sw=True,\n                                         fail=False, include_stderr=True)\n    fail(ret == 0, \"Offloaded a filter to chain other than 0\")\n    check_extack(err, \"Driver supports only offload of chain 0.\", args)\n    sim.tc_flush_filters()\n\n    start_test(\"Test TC replace...\")\n    sim.cls_bpf_add_filter(obj, prio=1, handle=1)\n    sim.cls_bpf_add_filter(obj, op=\"replace\", prio=1, handle=1)\n    sim.cls_filter_op(op=\"delete\", prio=1, handle=1, cls=\"bpf\")\n\n    sim.cls_bpf_add_filter(obj, prio=1, handle=1, skip_sw=True)\n    sim.cls_bpf_add_filter(obj, op=\"replace\", prio=1, handle=1, skip_sw=True)\n    sim.cls_filter_op(op=\"delete\", prio=1, handle=1, cls=\"bpf\")\n\n    sim.cls_bpf_add_filter(obj, prio=1, handle=1, skip_hw=True)\n    sim.cls_bpf_add_filter(obj, op=\"replace\", prio=1, handle=1, skip_hw=True)\n    sim.cls_filter_op(op=\"delete\", prio=1, handle=1, cls=\"bpf\")\n\n    start_test(\"Test TC replace bad flags...\")\n    for i in range(3):\n        for j in range(3):\n            ret, _ = sim.cls_bpf_add_filter(obj, op=\"replace\", prio=1, handle=1,\n                                            skip_sw=(j == 1), skip_hw=(j == 2),\n                                            fail=False)\n            fail(bool(ret) != bool(j),\n                 \"Software TC incorrect load in replace test, iteration %d\" %\n                 (j))\n        sim.cls_filter_op(op=\"delete\", prio=1, handle=1, cls=\"bpf\")\n\n    start_test(\"Test spurious extack from the driver...\")\n    test_spurios_extack(sim, obj, False, \"netdevsim\")\n    test_spurios_extack(sim, obj, True, \"netdevsim\")\n\n    sim.set_ethtool_tc_offloads(False)\n\n    test_spurios_extack(sim, obj, False, \"TC offload is disabled\")\n    test_spurios_extack(sim, obj, True, \"TC offload is disabled\")\n\n    sim.set_ethtool_tc_offloads(True)\n\n    sim.tc_flush_filters()\n\n    start_test(\"Test TC offloads failure...\")\n    sim.dfs[\"dev/bpf_bind_verifier_accept\"] = 0\n    ret, _, err = sim.cls_bpf_add_filter(obj, verbose=True, skip_sw=True,\n                                         fail=False, include_stderr=True)\n    fail(ret == 0, \"TC filter did not reject with TC offloads enabled\")\n    check_verifier_log(err, \"[netdevsim] Hello from netdevsim!\")\n    sim.dfs[\"dev/bpf_bind_verifier_accept\"] = 1\n\n    start_test(\"Test TC offloads work...\")\n    ret, _, err = sim.cls_bpf_add_filter(obj, verbose=True, skip_sw=True,\n                                         fail=False, include_stderr=True)\n    fail(ret != 0, \"TC filter did not load with TC offloads enabled\")\n\n    start_test(\"Test TC offload basics...\")\n    dfs = simdev.dfs_get_bound_progs(expected=1)\n    progs = bpftool_prog_list(expected=1)\n    ingress = sim.tc_show_ingress(expected=1)\n\n    dprog = dfs[0]\n    prog = progs[0]\n    fltr = ingress[0]\n    fail(fltr[\"skip_hw\"], \"TC does reports 'skip_hw' on offloaded filter\")\n    fail(not fltr[\"in_hw\"], \"TC does not report 'in_hw' for offloaded filter\")\n    fail(not fltr[\"skip_sw\"], \"TC does not report 'skip_sw' back\")\n\n    start_test(\"Test TC offload is device-bound...\")\n    fail(str(prog[\"id\"]) != fltr[\"id\"], \"Program IDs don't match\")\n    fail(prog[\"tag\"] != fltr[\"tag\"], \"Program tags don't match\")\n    fail(fltr[\"id\"] != dprog[\"id\"], \"Program IDs don't match\")\n    fail(dprog[\"state\"] != \"xlated\", \"Offloaded program state not translated\")\n    fail(dprog[\"loaded\"] != \"Y\", \"Offloaded program is not loaded\")\n\n    start_test(\"Test disabling TC offloads is rejected while filters installed...\")\n    ret, _ = sim.set_ethtool_tc_offloads(False, fail=False)\n    fail(ret == 0, \"Driver should refuse to disable TC offloads with filters installed...\")\n    sim.set_ethtool_tc_offloads(True)\n\n    start_test(\"Test qdisc removal frees things...\")\n    sim.tc_flush_filters()\n    sim.tc_show_ingress(expected=0)\n\n    start_test(\"Test disabling TC offloads is OK without filters...\")\n    ret, _ = sim.set_ethtool_tc_offloads(False, fail=False)\n    fail(ret != 0,\n         \"Driver refused to disable TC offloads without filters installed...\")\n\n    sim.set_ethtool_tc_offloads(True)\n\n    start_test(\"Test destroying device gets rid of TC filters...\")\n    sim.cls_bpf_add_filter(obj, skip_sw=True)\n    simdev.remove()\n    bpftool_prog_list_wait(expected=0)\n\n    simdev = NetdevSimDev()\n    sim, = simdev.nsims\n    sim.set_ethtool_tc_offloads(True)\n\n    start_test(\"Test destroying device gets rid of XDP...\")\n    sim.set_xdp(obj, \"offload\")\n    simdev.remove()\n    bpftool_prog_list_wait(expected=0)\n\n    simdev = NetdevSimDev()\n    sim, = simdev.nsims\n    sim.set_ethtool_tc_offloads(True)\n\n    start_test(\"Test XDP prog reporting...\")\n    sim.set_xdp(obj, \"drv\")\n    ipl = sim.ip_link_show(xdp=True)\n    progs = bpftool_prog_list(expected=1)\n    fail(ipl[\"xdp\"][\"prog\"][\"id\"] != progs[0][\"id\"],\n         \"Loaded program has wrong ID\")\n\n    start_test(\"Test XDP prog replace without force...\")\n    ret, _ = sim.set_xdp(obj, \"drv\", fail=False)\n    fail(ret == 0, \"Replaced XDP program without -force\")\n    sim.wait_for_flush(total=1)\n\n    start_test(\"Test XDP prog replace with force...\")\n    ret, _ = sim.set_xdp(obj, \"drv\", force=True, fail=False)\n    fail(ret != 0, \"Could not replace XDP program with -force\")\n    bpftool_prog_list_wait(expected=1)\n    ipl = sim.ip_link_show(xdp=True)\n    progs = bpftool_prog_list(expected=1)\n    fail(ipl[\"xdp\"][\"prog\"][\"id\"] != progs[0][\"id\"],\n         \"Loaded program has wrong ID\")\n    fail(\"dev\" in progs[0].keys(),\n         \"Device parameters reported for non-offloaded program\")\n\n    start_test(\"Test XDP prog replace with bad flags...\")\n    ret, _, err = sim.set_xdp(obj, \"generic\", force=True,\n                              fail=False, include_stderr=True)\n    fail(ret == 0, \"Replaced XDP program with a program in different mode\")\n    check_extack(err,\n                 \"Native and generic XDP can't be active at the same time.\",\n                 args)\n\n    start_test(\"Test MTU restrictions...\")\n    ret, _ = sim.set_mtu(9000, fail=False)\n    fail(ret == 0,\n         \"Driver should refuse to increase MTU to 9000 with XDP loaded...\")\n    sim.unset_xdp(\"drv\")\n    bpftool_prog_list_wait(expected=0)\n    sim.set_mtu(9000)\n    ret, _, err = sim.set_xdp(obj, \"drv\", fail=False, include_stderr=True)\n    fail(ret == 0, \"Driver should refuse to load program with MTU of 9000...\")\n    check_extack_nsim(err, \"MTU too large w/ XDP enabled.\", args)\n    sim.set_mtu(1500)\n\n    sim.wait_for_flush()\n    start_test(\"Test non-offload XDP attaching to HW...\")\n    bpftool_prog_load(\"sample_ret0.bpf.o\", \"/sys/fs/bpf/nooffload\")\n    nooffload = bpf_pinned(\"/sys/fs/bpf/nooffload\")\n    ret, _, err = sim.set_xdp(nooffload, \"offload\",\n                              fail=False, include_stderr=True)\n    fail(ret == 0, \"attached non-offloaded XDP program to HW\")\n    check_extack_nsim(err, \"xdpoffload of non-bound program.\", args)\n    rm(\"/sys/fs/bpf/nooffload\")\n\n    start_test(\"Test offload XDP attaching to drv...\")\n    bpftool_prog_load(\"sample_ret0.bpf.o\", \"/sys/fs/bpf/offload\",\n                      dev=sim['ifname'])\n    offload = bpf_pinned(\"/sys/fs/bpf/offload\")\n    ret, _, err = sim.set_xdp(offload, \"drv\", fail=False, include_stderr=True)\n    fail(ret == 0, \"attached offloaded XDP program to drv\")\n    check_extack(err, \"Using offloaded program without HW_MODE flag is not supported.\", args)\n    rm(\"/sys/fs/bpf/offload\")\n    sim.wait_for_flush()\n\n    start_test(\"Test XDP load failure...\")\n    sim.dfs[\"dev/bpf_bind_verifier_accept\"] = 0\n    ret, _, err = bpftool_prog_load(\"sample_ret0.bpf.o\", \"/sys/fs/bpf/offload\",\n                                 dev=sim['ifname'], fail=False, include_stderr=True)\n    fail(ret == 0, \"verifier should fail on load\")\n    check_verifier_log(err, \"[netdevsim] Hello from netdevsim!\")\n    sim.dfs[\"dev/bpf_bind_verifier_accept\"] = 1\n    sim.wait_for_flush()\n\n    start_test(\"Test XDP offload...\")\n    _, _, err = sim.set_xdp(obj, \"offload\", verbose=True, include_stderr=True)\n    ipl = sim.ip_link_show(xdp=True)\n    link_xdp = ipl[\"xdp\"][\"prog\"]\n    progs = bpftool_prog_list(expected=1)\n    prog = progs[0]\n    fail(link_xdp[\"id\"] != prog[\"id\"], \"Loaded program has wrong ID\")\n\n    start_test(\"Test XDP offload is device bound...\")\n    dfs = simdev.dfs_get_bound_progs(expected=1)\n    dprog = dfs[0]\n\n    fail(prog[\"id\"] != link_xdp[\"id\"], \"Program IDs don't match\")\n    fail(prog[\"tag\"] != link_xdp[\"tag\"], \"Program tags don't match\")\n    fail(str(link_xdp[\"id\"]) != dprog[\"id\"], \"Program IDs don't match\")\n    fail(dprog[\"state\"] != \"xlated\", \"Offloaded program state not translated\")\n    fail(dprog[\"loaded\"] != \"Y\", \"Offloaded program is not loaded\")\n\n    start_test(\"Test removing XDP program many times...\")\n    sim.unset_xdp(\"offload\")\n    sim.unset_xdp(\"offload\")\n    sim.unset_xdp(\"drv\")\n    sim.unset_xdp(\"drv\")\n    sim.unset_xdp(\"\")\n    sim.unset_xdp(\"\")\n    bpftool_prog_list_wait(expected=0)\n\n    start_test(\"Test attempt to use a program for a wrong device...\")\n    simdev2 = NetdevSimDev()\n    sim2, = simdev2.nsims\n    sim2.set_xdp(obj, \"offload\")\n    pin_file, pinned = pin_prog(\"/sys/fs/bpf/tmp\")\n\n    ret, _, err = sim.set_xdp(pinned, \"offload\",\n                              fail=False, include_stderr=True)\n    fail(ret == 0, \"Pinned program loaded for a different device accepted\")\n    check_extack(err, \"Program bound to different device.\", args)\n    simdev2.remove()\n    ret, _, err = sim.set_xdp(pinned, \"offload\",\n                              fail=False, include_stderr=True)\n    fail(ret == 0, \"Pinned program loaded for a removed device accepted\")\n    check_extack(err, \"Program bound to different device.\", args)\n    rm(pin_file)\n    bpftool_prog_list_wait(expected=0)\n\n    simdev, sim = test_multi_prog(simdev, sim, obj, \"\", 1)\n    simdev, sim = test_multi_prog(simdev, sim, obj, \"drv\", 1)\n    simdev, sim = test_multi_prog(simdev, sim, obj, \"generic\", 2)\n\n    start_test(\"Test mixing of TC and XDP...\")\n    sim.tc_add_ingress()\n    sim.set_xdp(obj, \"offload\")\n    ret, _, err = sim.cls_bpf_add_filter(obj, skip_sw=True,\n                                         fail=False, include_stderr=True)\n    fail(ret == 0, \"Loading TC when XDP active should fail\")\n    check_extack_nsim(err, \"driver and netdev offload states mismatch.\", args)\n    sim.unset_xdp(\"offload\")\n    sim.wait_for_flush()\n\n    sim.cls_bpf_add_filter(obj, skip_sw=True)\n    ret, _, err = sim.set_xdp(obj, \"offload\", fail=False, include_stderr=True)\n    fail(ret == 0, \"Loading XDP when TC active should fail\")\n    check_extack_nsim(err, \"TC program is already loaded.\", args)\n\n    start_test(\"Test binding TC from pinned...\")\n    pin_file, pinned = pin_prog(\"/sys/fs/bpf/tmp\")\n    sim.tc_flush_filters(bound=1, total=1)\n    sim.cls_bpf_add_filter(pinned, da=True, skip_sw=True)\n    sim.tc_flush_filters(bound=1, total=1)\n\n    start_test(\"Test binding XDP from pinned...\")\n    sim.set_xdp(obj, \"offload\")\n    pin_file, pinned = pin_prog(\"/sys/fs/bpf/tmp2\", idx=1)\n\n    sim.set_xdp(pinned, \"offload\", force=True)\n    sim.unset_xdp(\"offload\")\n    sim.set_xdp(pinned, \"offload\", force=True)\n    sim.unset_xdp(\"offload\")\n\n    start_test(\"Test offload of wrong type fails...\")\n    ret, _ = sim.cls_bpf_add_filter(pinned, da=True, skip_sw=True, fail=False)\n    fail(ret == 0, \"Managed to attach XDP program to TC\")\n\n    start_test(\"Test asking for TC offload of two filters...\")\n    sim.cls_bpf_add_filter(obj, da=True, skip_sw=True)\n    ret, _, err = sim.cls_bpf_add_filter(obj, da=True, skip_sw=True,\n                                         fail=False, include_stderr=True)\n    fail(ret == 0, \"Managed to offload two TC filters at the same time\")\n    check_extack_nsim(err, \"driver and netdev offload states mismatch.\", args)\n\n    sim.tc_flush_filters(bound=2, total=2)\n\n    start_test(\"Test if netdev removal waits for translation...\")\n    delay_msec = 500\n    sim.dfs[\"dev/bpf_bind_verifier_delay\"] = delay_msec\n    start = time.time()\n    cmd_line = \"tc filter add dev %s ingress bpf %s da skip_sw\" % \\\n               (sim['ifname'], obj)\n    tc_proc = cmd(cmd_line, background=True, fail=False)\n    # Wait for the verifier to start\n    while simdev.dfs_num_bound_progs() <= 2:\n        pass\n    simdev.remove()\n    end = time.time()\n    ret, _ = cmd_result(tc_proc, fail=False)\n    time_diff = end - start\n    log(\"Time\", \"start:\\t%s\\nend:\\t%s\\ndiff:\\t%s\" % (start, end, time_diff))\n\n    fail(ret == 0, \"Managed to load TC filter on a unregistering device\")\n    delay_sec = delay_msec * 0.001\n    fail(time_diff < delay_sec, \"Removal process took %s, expected %s\" %\n         (time_diff, delay_sec))\n\n    # Remove all pinned files and reinstantiate the netdev\n    clean_up()\n    bpftool_prog_list_wait(expected=0)\n\n    simdev = NetdevSimDev()\n    sim, = simdev.nsims\n    map_obj = bpf_obj(\"sample_map_ret0.bpf.o\")\n    start_test(\"Test loading program with maps...\")\n    sim.set_xdp(map_obj, \"offload\", JSON=False) # map fixup msg breaks JSON\n\n    start_test(\"Test bpftool bound info reporting (own ns)...\")\n    check_dev_info(False, \"\")\n\n    start_test(\"Test bpftool bound info reporting (other ns)...\")\n    ns = mknetns()\n    sim.set_ns(ns)\n    check_dev_info(True, \"\")\n\n    start_test(\"Test bpftool bound info reporting (remote ns)...\")\n    check_dev_info(False, ns)\n\n    start_test(\"Test bpftool bound info reporting (back to own ns)...\")\n    sim.set_ns(\"\")\n    check_dev_info(False, \"\")\n\n    prog_file, _ = pin_prog(\"/sys/fs/bpf/tmp_prog\")\n    map_file, _ = pin_map(\"/sys/fs/bpf/tmp_map\", idx=1, expected=2)\n    simdev.remove()\n\n    start_test(\"Test bpftool bound info reporting (removed dev)...\")\n    check_dev_info_removed(prog_file=prog_file, map_file=map_file)\n\n    # Remove all pinned files and reinstantiate the netdev\n    clean_up()\n    bpftool_prog_list_wait(expected=0)\n\n    simdev = NetdevSimDev()\n    sim, = simdev.nsims\n\n    start_test(\"Test map update (no flags)...\")\n    sim.set_xdp(map_obj, \"offload\", JSON=False) # map fixup msg breaks JSON\n    maps = bpftool_map_list(expected=2)\n    array = maps[0] if maps[0][\"type\"] == \"array\" else maps[1]\n    htab = maps[0] if maps[0][\"type\"] == \"hash\" else maps[1]\n    for m in maps:\n        for i in range(2):\n            bpftool(\"map update id %d key %s value %s\" %\n                    (m[\"id\"], int2str(\"I\", i), int2str(\"Q\", i * 3)))\n\n    for m in maps:\n        ret, _ = bpftool(\"map update id %d key %s value %s\" %\n                         (m[\"id\"], int2str(\"I\", 3), int2str(\"Q\", 3 * 3)),\n                         fail=False)\n        fail(ret == 0, \"added too many entries\")\n\n    start_test(\"Test map update (exists)...\")\n    for m in maps:\n        for i in range(2):\n            bpftool(\"map update id %d key %s value %s exist\" %\n                    (m[\"id\"], int2str(\"I\", i), int2str(\"Q\", i * 3)))\n\n    for m in maps:\n        ret, err = bpftool(\"map update id %d key %s value %s exist\" %\n                           (m[\"id\"], int2str(\"I\", 3), int2str(\"Q\", 3 * 3)),\n                           fail=False)\n        fail(ret == 0, \"updated non-existing key\")\n        fail(err[\"error\"].find(\"No such file or directory\") == -1,\n             \"expected ENOENT, error is '%s'\" % (err[\"error\"]))\n\n    start_test(\"Test map update (noexist)...\")\n    for m in maps:\n        for i in range(2):\n            ret, err = bpftool(\"map update id %d key %s value %s noexist\" %\n                               (m[\"id\"], int2str(\"I\", i), int2str(\"Q\", i * 3)),\n                               fail=False)\n        fail(ret == 0, \"updated existing key\")\n        fail(err[\"error\"].find(\"File exists\") == -1,\n             \"expected EEXIST, error is '%s'\" % (err[\"error\"]))\n\n    start_test(\"Test map dump...\")\n    for m in maps:\n        _, entries = bpftool(\"map dump id %d\" % (m[\"id\"]))\n        for i in range(2):\n            key = str2int(entries[i][\"key\"])\n            fail(key != i, \"expected key %d, got %d\" % (key, i))\n            val = str2int(entries[i][\"value\"])\n            fail(val != i * 3, \"expected value %d, got %d\" % (val, i * 3))\n\n    start_test(\"Test map getnext...\")\n    for m in maps:\n        _, entry = bpftool(\"map getnext id %d\" % (m[\"id\"]))\n        key = str2int(entry[\"next_key\"])\n        fail(key != 0, \"next key %d, expected %d\" % (key, 0))\n        _, entry = bpftool(\"map getnext id %d key %s\" %\n                           (m[\"id\"], int2str(\"I\", 0)))\n        key = str2int(entry[\"next_key\"])\n        fail(key != 1, \"next key %d, expected %d\" % (key, 1))\n        ret, err = bpftool(\"map getnext id %d key %s\" %\n                           (m[\"id\"], int2str(\"I\", 1)), fail=False)\n        fail(ret == 0, \"got next key past the end of map\")\n        fail(err[\"error\"].find(\"No such file or directory\") == -1,\n             \"expected ENOENT, error is '%s'\" % (err[\"error\"]))\n\n    start_test(\"Test map delete (htab)...\")\n    for i in range(2):\n        bpftool(\"map delete id %d key %s\" % (htab[\"id\"], int2str(\"I\", i)))\n\n    start_test(\"Test map delete (array)...\")\n    for i in range(2):\n        ret, err = bpftool(\"map delete id %d key %s\" %\n                           (htab[\"id\"], int2str(\"I\", i)), fail=False)\n        fail(ret == 0, \"removed entry from an array\")\n        fail(err[\"error\"].find(\"No such file or directory\") == -1,\n             \"expected ENOENT, error is '%s'\" % (err[\"error\"]))\n\n    start_test(\"Test map remove...\")\n    sim.unset_xdp(\"offload\")\n    bpftool_map_list_wait(expected=0)\n    simdev.remove()\n\n    simdev = NetdevSimDev()\n    sim, = simdev.nsims\n    sim.set_xdp(map_obj, \"offload\", JSON=False) # map fixup msg breaks JSON\n    simdev.remove()\n    bpftool_map_list_wait(expected=0)\n\n    start_test(\"Test map creation fail path...\")\n    simdev = NetdevSimDev()\n    sim, = simdev.nsims\n    sim.dfs[\"bpf_map_accept\"] = \"N\"\n    ret, _ = sim.set_xdp(map_obj, \"offload\", JSON=False, fail=False)\n    fail(ret == 0,\n         \"netdevsim didn't refuse to create a map with offload disabled\")\n\n    simdev.remove()\n\n    start_test(\"Test multi-dev ASIC program reuse...\")\n    simdevA = NetdevSimDev()\n    simA, = simdevA.nsims\n    simdevB = NetdevSimDev(3)\n    simB1, simB2, simB3 = simdevB.nsims\n    sims = (simA, simB1, simB2, simB3)\n    simB = (simB1, simB2, simB3)\n\n    bpftool_prog_load(\"sample_map_ret0.bpf.o\", \"/sys/fs/bpf/nsimA\",\n                      dev=simA['ifname'])\n    progA = bpf_pinned(\"/sys/fs/bpf/nsimA\")\n    bpftool_prog_load(\"sample_map_ret0.bpf.o\", \"/sys/fs/bpf/nsimB\",\n                      dev=simB1['ifname'])\n    progB = bpf_pinned(\"/sys/fs/bpf/nsimB\")\n\n    simA.set_xdp(progA, \"offload\", JSON=False)\n    for d in simdevB.nsims:\n        d.set_xdp(progB, \"offload\", JSON=False)\n\n    start_test(\"Test multi-dev ASIC cross-dev replace...\")\n    ret, _ = simA.set_xdp(progB, \"offload\", force=True, JSON=False, fail=False)\n    fail(ret == 0, \"cross-ASIC program allowed\")\n    for d in simdevB.nsims:\n        ret, _ = d.set_xdp(progA, \"offload\", force=True, JSON=False, fail=False)\n        fail(ret == 0, \"cross-ASIC program allowed\")\n\n    start_test(\"Test multi-dev ASIC cross-dev install...\")\n    for d in sims:\n        d.unset_xdp(\"offload\")\n\n    ret, _, err = simA.set_xdp(progB, \"offload\", force=True, JSON=False,\n                               fail=False, include_stderr=True)\n    fail(ret == 0, \"cross-ASIC program allowed\")\n    check_extack(err, \"Program bound to different device.\", args)\n    for d in simdevB.nsims:\n        ret, _, err = d.set_xdp(progA, \"offload\", force=True, JSON=False,\n                                fail=False, include_stderr=True)\n        fail(ret == 0, \"cross-ASIC program allowed\")\n        check_extack(err, \"Program bound to different device.\", args)\n\n    start_test(\"Test multi-dev ASIC cross-dev map reuse...\")\n\n    mapA = bpftool(\"prog show %s\" % (progA))[1][\"map_ids\"][0]\n    mapB = bpftool(\"prog show %s\" % (progB))[1][\"map_ids\"][0]\n\n    ret, _ = bpftool_prog_load(\"sample_map_ret0.bpf.o\", \"/sys/fs/bpf/nsimB_\",\n                               dev=simB3['ifname'],\n                               maps=[\"idx 0 id %d\" % (mapB)],\n                               fail=False)\n    fail(ret != 0, \"couldn't reuse a map on the same ASIC\")\n    rm(\"/sys/fs/bpf/nsimB_\")\n\n    ret, _, err = bpftool_prog_load(\"sample_map_ret0.bpf.o\", \"/sys/fs/bpf/nsimA_\",\n                                    dev=simA['ifname'],\n                                    maps=[\"idx 0 id %d\" % (mapB)],\n                                    fail=False, include_stderr=True)\n    fail(ret == 0, \"could reuse a map on a different ASIC\")\n    fail(err.count(\"offload device mismatch between prog and map\") == 0,\n         \"error message missing for cross-ASIC map\")\n\n    ret, _, err = bpftool_prog_load(\"sample_map_ret0.bpf.o\", \"/sys/fs/bpf/nsimB_\",\n                                    dev=simB1['ifname'],\n                                    maps=[\"idx 0 id %d\" % (mapA)],\n                                    fail=False, include_stderr=True)\n    fail(ret == 0, \"could reuse a map on a different ASIC\")\n    fail(err.count(\"offload device mismatch between prog and map\") == 0,\n         \"error message missing for cross-ASIC map\")\n\n    start_test(\"Test multi-dev ASIC cross-dev destruction...\")\n    bpftool_prog_list_wait(expected=2)\n\n    simdevA.remove()\n    bpftool_prog_list_wait(expected=1)\n\n    ifnameB = bpftool(\"prog show %s\" % (progB))[1][\"dev\"][\"ifname\"]\n    fail(ifnameB != simB1['ifname'], \"program not bound to original device\")\n    simB1.remove()\n    bpftool_prog_list_wait(expected=1)\n\n    start_test(\"Test multi-dev ASIC cross-dev destruction - move...\")\n    ifnameB = bpftool(\"prog show %s\" % (progB))[1][\"dev\"][\"ifname\"]\n    fail(ifnameB not in (simB2['ifname'], simB3['ifname']),\n         \"program not bound to remaining devices\")\n\n    simB2.remove()\n    ifnameB = bpftool(\"prog show %s\" % (progB))[1][\"dev\"][\"ifname\"]\n    fail(ifnameB != simB3['ifname'], \"program not bound to remaining device\")\n\n    simB3.remove()\n    simdevB.remove()\n    bpftool_prog_list_wait(expected=0)\n\n    start_test(\"Test multi-dev ASIC cross-dev destruction - orphaned...\")\n    ret, out = bpftool(\"prog show %s\" % (progB), fail=False)\n    fail(ret == 0, \"got information about orphaned program\")\n    fail(\"error\" not in out, \"no error reported for get info on orphaned\")\n    fail(out[\"error\"] != \"can't get prog info: No such device\",\n         \"wrong error for get info on orphaned\")\n\n    print(\"%s: OK\" % (os.path.basename(__file__)))\n\nfinally:\n    log(\"Clean up...\", \"\", level=1)\n    log_level_inc()\n    clean_up()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}