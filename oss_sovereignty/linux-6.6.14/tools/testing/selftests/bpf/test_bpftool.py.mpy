{
  "module_name": "test_bpftool.py",
  "hash_id": "d3cac4b750216bef62698e7bb2135dbf05c85951f2e8686169a7187f073ff393",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/test_bpftool.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n# Copyright (c) 2020 SUSE LLC.\n\nimport collections\nimport functools\nimport json\nimport os\nimport socket\nimport subprocess\nimport unittest\n\n\n# Add the source tree of bpftool and /usr/local/sbin to PATH\ncur_dir = os.path.dirname(os.path.realpath(__file__))\nbpftool_dir = os.path.abspath(os.path.join(cur_dir, \"..\", \"..\", \"..\", \"..\",\n                                           \"tools\", \"bpf\", \"bpftool\"))\nos.environ[\"PATH\"] = bpftool_dir + \":/usr/local/sbin:\" + os.environ[\"PATH\"]\n\n\nclass IfaceNotFoundError(Exception):\n    pass\n\n\nclass UnprivilegedUserError(Exception):\n    pass\n\n\ndef _bpftool(args, json=True):\n    _args = [\"bpftool\"]\n    if json:\n        _args.append(\"-j\")\n    _args.extend(args)\n\n    return subprocess.check_output(_args)\n\n\ndef bpftool(args):\n    return _bpftool(args, json=False).decode(\"utf-8\")\n\n\ndef bpftool_json(args):\n    res = _bpftool(args)\n    return json.loads(res)\n\n\ndef get_default_iface():\n    for iface in socket.if_nameindex():\n        if iface[1] != \"lo\":\n            return iface[1]\n    raise IfaceNotFoundError(\"Could not find any network interface to probe\")\n\n\ndef default_iface(f):\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        iface = get_default_iface()\n        return f(*args, iface, **kwargs)\n    return wrapper\n\nDMESG_EMITTING_HELPERS = [\n        \"bpf_probe_write_user\",\n        \"bpf_trace_printk\",\n        \"bpf_trace_vprintk\",\n    ]\n\nclass TestBpftool(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        if os.getuid() != 0:\n            raise UnprivilegedUserError(\n                \"This test suite needs root privileges\")\n\n    @default_iface\n    def test_feature_dev_json(self, iface):\n        unexpected_helpers = DMESG_EMITTING_HELPERS\n        expected_keys = [\n            \"syscall_config\",\n            \"program_types\",\n            \"map_types\",\n            \"helpers\",\n            \"misc\",\n        ]\n\n        res = bpftool_json([\"feature\", \"probe\", \"dev\", iface])\n        # Check if the result has all expected keys.\n        self.assertCountEqual(res.keys(), expected_keys)\n        # Check if unexpected helpers are not included in helpers probes\n        # result.\n        for helpers in res[\"helpers\"].values():\n            for unexpected_helper in unexpected_helpers:\n                self.assertNotIn(unexpected_helper, helpers)\n\n    def test_feature_kernel(self):\n        test_cases = [\n            bpftool_json([\"feature\", \"probe\", \"kernel\"]),\n            bpftool_json([\"feature\", \"probe\"]),\n            bpftool_json([\"feature\"]),\n        ]\n        unexpected_helpers = DMESG_EMITTING_HELPERS\n        expected_keys = [\n            \"syscall_config\",\n            \"system_config\",\n            \"program_types\",\n            \"map_types\",\n            \"helpers\",\n            \"misc\",\n        ]\n\n        for tc in test_cases:\n            # Check if the result has all expected keys.\n            self.assertCountEqual(tc.keys(), expected_keys)\n            # Check if unexpected helpers are not included in helpers probes\n            # result.\n            for helpers in tc[\"helpers\"].values():\n                for unexpected_helper in unexpected_helpers:\n                    self.assertNotIn(unexpected_helper, helpers)\n\n    def test_feature_kernel_full(self):\n        test_cases = [\n            bpftool_json([\"feature\", \"probe\", \"kernel\", \"full\"]),\n            bpftool_json([\"feature\", \"probe\", \"full\"]),\n        ]\n        expected_helpers = DMESG_EMITTING_HELPERS\n\n        for tc in test_cases:\n            # Check if expected helpers are included at least once in any\n            # helpers list for any program type. Unfortunately we cannot assume\n            # that they will be included in all program types or a specific\n            # subset of programs. It depends on the kernel version and\n            # configuration.\n            found_helpers = False\n\n            for helpers in tc[\"helpers\"].values():\n                if all(expected_helper in helpers\n                       for expected_helper in expected_helpers):\n                    found_helpers = True\n                    break\n\n            self.assertTrue(found_helpers)\n\n    def test_feature_kernel_full_vs_not_full(self):\n        full_res = bpftool_json([\"feature\", \"probe\", \"full\"])\n        not_full_res = bpftool_json([\"feature\", \"probe\"])\n        not_full_set = set()\n        full_set = set()\n\n        for helpers in full_res[\"helpers\"].values():\n            for helper in helpers:\n                full_set.add(helper)\n\n        for helpers in not_full_res[\"helpers\"].values():\n            for helper in helpers:\n                not_full_set.add(helper)\n\n        self.assertCountEqual(full_set - not_full_set,\n                              set(DMESG_EMITTING_HELPERS))\n        self.assertCountEqual(not_full_set - full_set, set())\n\n    def test_feature_macros(self):\n        expected_patterns = [\n            r\"/\\*\\*\\* System call availability \\*\\*\\*/\",\n            r\"#define HAVE_BPF_SYSCALL\",\n            r\"/\\*\\*\\* eBPF program types \\*\\*\\*/\",\n            r\"#define HAVE.*PROG_TYPE\",\n            r\"/\\*\\*\\* eBPF map types \\*\\*\\*/\",\n            r\"#define HAVE.*MAP_TYPE\",\n            r\"/\\*\\*\\* eBPF helper functions \\*\\*\\*/\",\n            r\"#define HAVE.*HELPER\",\n            r\"/\\*\\*\\* eBPF misc features \\*\\*\\*/\",\n        ]\n\n        res = bpftool([\"feature\", \"probe\", \"macros\"])\n        for pattern in expected_patterns:\n            self.assertRegex(res, pattern)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}