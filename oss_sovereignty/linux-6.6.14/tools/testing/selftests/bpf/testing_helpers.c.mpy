{
  "module_name": "testing_helpers.c",
  "hash_id": "cd94a05b52fb41af93554acf6788899e54e4336a9a94795d9efb54c8ceb03d7f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/bpf/testing_helpers.c",
  "human_readable_source": "\n \n \n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include \"test_progs.h\"\n#include \"testing_helpers.h\"\n#include <linux/membarrier.h>\n\nint parse_num_list(const char *s, bool **num_set, int *num_set_len)\n{\n\tint i, set_len = 0, new_len, num, start = 0, end = -1;\n\tbool *set = NULL, *tmp, parsing_end = false;\n\tchar *next;\n\n\twhile (s[0]) {\n\t\terrno = 0;\n\t\tnum = strtol(s, &next, 10);\n\t\tif (errno)\n\t\t\treturn -errno;\n\n\t\tif (parsing_end)\n\t\t\tend = num;\n\t\telse\n\t\t\tstart = num;\n\n\t\tif (!parsing_end && *next == '-') {\n\t\t\ts = next + 1;\n\t\t\tparsing_end = true;\n\t\t\tcontinue;\n\t\t} else if (*next == ',') {\n\t\t\tparsing_end = false;\n\t\t\ts = next + 1;\n\t\t\tend = num;\n\t\t} else if (*next == '\\0') {\n\t\t\tparsing_end = false;\n\t\t\ts = next;\n\t\t\tend = num;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (start > end)\n\t\t\treturn -EINVAL;\n\n\t\tif (end + 1 > set_len) {\n\t\t\tnew_len = end + 1;\n\t\t\ttmp = realloc(set, new_len);\n\t\t\tif (!tmp) {\n\t\t\t\tfree(set);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tfor (i = set_len; i < start; i++)\n\t\t\t\ttmp[i] = false;\n\t\t\tset = tmp;\n\t\t\tset_len = new_len;\n\t\t}\n\t\tfor (i = start; i <= end; i++)\n\t\t\tset[i] = true;\n\t}\n\n\tif (!set || parsing_end)\n\t\treturn -EINVAL;\n\n\t*num_set = set;\n\t*num_set_len = set_len;\n\n\treturn 0;\n}\n\nstatic int do_insert_test(struct test_filter_set *set,\n\t\t\t  char *test_str,\n\t\t\t  char *subtest_str)\n{\n\tstruct test_filter *tmp, *test;\n\tchar **ctmp;\n\tint i;\n\n\tfor (i = 0; i < set->cnt; i++) {\n\t\ttest = &set->tests[i];\n\n\t\tif (strcmp(test_str, test->name) == 0) {\n\t\t\tfree(test_str);\n\t\t\tgoto subtest;\n\t\t}\n\t}\n\n\ttmp = realloc(set->tests, sizeof(*test) * (set->cnt + 1));\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tset->tests = tmp;\n\ttest = &set->tests[set->cnt];\n\n\ttest->name = test_str;\n\ttest->subtests = NULL;\n\ttest->subtest_cnt = 0;\n\n\tset->cnt++;\n\nsubtest:\n\tif (!subtest_str)\n\t\treturn 0;\n\n\tfor (i = 0; i < test->subtest_cnt; i++) {\n\t\tif (strcmp(subtest_str, test->subtests[i]) == 0) {\n\t\t\tfree(subtest_str);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tctmp = realloc(test->subtests,\n\t\t       sizeof(*test->subtests) * (test->subtest_cnt + 1));\n\tif (!ctmp)\n\t\treturn -ENOMEM;\n\n\ttest->subtests = ctmp;\n\ttest->subtests[test->subtest_cnt] = subtest_str;\n\n\ttest->subtest_cnt++;\n\n\treturn 0;\n}\n\nstatic int insert_test(struct test_filter_set *set,\n\t\t       char *test_spec,\n\t\t       bool is_glob_pattern)\n{\n\tchar *pattern, *subtest_str, *ext_test_str, *ext_subtest_str = NULL;\n\tint glob_chars = 0;\n\n\tif (is_glob_pattern) {\n\t\tpattern = \"%s\";\n\t} else {\n\t\tpattern = \"*%s*\";\n\t\tglob_chars = 2;\n\t}\n\n\tsubtest_str = strchr(test_spec, '/');\n\tif (subtest_str) {\n\t\t*subtest_str = '\\0';\n\t\tsubtest_str += 1;\n\t}\n\n\text_test_str = malloc(strlen(test_spec) + glob_chars + 1);\n\tif (!ext_test_str)\n\t\tgoto err;\n\n\tsprintf(ext_test_str, pattern, test_spec);\n\n\tif (subtest_str) {\n\t\text_subtest_str = malloc(strlen(subtest_str) + glob_chars + 1);\n\t\tif (!ext_subtest_str)\n\t\t\tgoto err;\n\n\t\tsprintf(ext_subtest_str, pattern, subtest_str);\n\t}\n\n\treturn do_insert_test(set, ext_test_str, ext_subtest_str);\n\nerr:\n\tfree(ext_test_str);\n\tfree(ext_subtest_str);\n\n\treturn -ENOMEM;\n}\n\nint parse_test_list_file(const char *path,\n\t\t\t struct test_filter_set *set,\n\t\t\t bool is_glob_pattern)\n{\n\tchar *buf = NULL, *capture_start, *capture_end, *scan_end;\n\tsize_t buflen = 0;\n\tint err = 0;\n\tFILE *f;\n\n\tf = fopen(path, \"r\");\n\tif (!f) {\n\t\terr = -errno;\n\t\tfprintf(stderr, \"Failed to open '%s': %d\\n\", path, err);\n\t\treturn err;\n\t}\n\n\twhile (getline(&buf, &buflen, f) != -1) {\n\t\tcapture_start = buf;\n\n\t\twhile (isspace(*capture_start))\n\t\t\t++capture_start;\n\n\t\tcapture_end = capture_start;\n\t\tscan_end = capture_start;\n\n\t\twhile (*scan_end && *scan_end != '#') {\n\t\t\tif (!isspace(*scan_end))\n\t\t\t\tcapture_end = scan_end;\n\n\t\t\t++scan_end;\n\t\t}\n\n\t\tif (capture_end == capture_start)\n\t\t\tcontinue;\n\n\t\t*(++capture_end) = '\\0';\n\n\t\terr = insert_test(set, capture_start, is_glob_pattern);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tfclose(f);\n\treturn err;\n}\n\nint parse_test_list(const char *s,\n\t\t    struct test_filter_set *set,\n\t\t    bool is_glob_pattern)\n{\n\tchar *input, *state = NULL, *test_spec;\n\tint err = 0;\n\n\tinput = strdup(s);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\twhile ((test_spec = strtok_r(state ? NULL : input, \",\", &state))) {\n\t\terr = insert_test(set, test_spec, is_glob_pattern);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tfree(input);\n\treturn err;\n}\n\n__u32 link_info_prog_id(const struct bpf_link *link, struct bpf_link_info *info)\n{\n\t__u32 info_len = sizeof(*info);\n\tint err;\n\n\tmemset(info, 0, sizeof(*info));\n\terr = bpf_link_get_info_by_fd(bpf_link__fd(link), info, &info_len);\n\tif (err) {\n\t\tprintf(\"failed to get link info: %d\\n\", -errno);\n\t\treturn 0;\n\t}\n\treturn info->prog_id;\n}\n\nint extra_prog_load_log_flags = 0;\n\nint bpf_prog_test_load(const char *file, enum bpf_prog_type type,\n\t\t       struct bpf_object **pobj, int *prog_fd)\n{\n\tLIBBPF_OPTS(bpf_object_open_opts, opts,\n\t\t.kernel_log_level = extra_prog_load_log_flags,\n\t);\n\tstruct bpf_object *obj;\n\tstruct bpf_program *prog;\n\t__u32 flags;\n\tint err;\n\n\tobj = bpf_object__open_file(file, &opts);\n\tif (!obj)\n\t\treturn -errno;\n\n\tprog = bpf_object__next_program(obj, NULL);\n\tif (!prog) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\n\tif (type != BPF_PROG_TYPE_UNSPEC && bpf_program__type(prog) != type)\n\t\tbpf_program__set_type(prog, type);\n\n\tflags = bpf_program__flags(prog) | BPF_F_TEST_RND_HI32;\n\tbpf_program__set_flags(prog, flags);\n\n\terr = bpf_object__load(obj);\n\tif (err)\n\t\tgoto err_out;\n\n\t*pobj = obj;\n\t*prog_fd = bpf_program__fd(prog);\n\n\treturn 0;\nerr_out:\n\tbpf_object__close(obj);\n\treturn err;\n}\n\nint bpf_test_load_program(enum bpf_prog_type type, const struct bpf_insn *insns,\n\t\t\t  size_t insns_cnt, const char *license,\n\t\t\t  __u32 kern_version, char *log_buf,\n\t\t\t  size_t log_buf_sz)\n{\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts,\n\t\t.kern_version = kern_version,\n\t\t.prog_flags = BPF_F_TEST_RND_HI32,\n\t\t.log_level = extra_prog_load_log_flags,\n\t\t.log_buf = log_buf,\n\t\t.log_size = log_buf_sz,\n\t);\n\n\treturn bpf_prog_load(type, NULL, license, insns, insns_cnt, &opts);\n}\n\n__u64 read_perf_max_sample_freq(void)\n{\n\t__u64 sample_freq = 5000;  \n\tFILE *f;\n\n\tf = fopen(\"/proc/sys/kernel/perf_event_max_sample_rate\", \"r\");\n\tif (f == NULL) {\n\t\tprintf(\"Failed to open /proc/sys/kernel/perf_event_max_sample_rate: err %d\\n\"\n\t\t       \"return default value: 5000\\n\", -errno);\n\t\treturn sample_freq;\n\t}\n\tif (fscanf(f, \"%llu\", &sample_freq) != 1) {\n\t\tprintf(\"Failed to parse /proc/sys/kernel/perf_event_max_sample_rate: err %d\\n\"\n\t\t       \"return default value: 5000\\n\", -errno);\n\t}\n\n\tfclose(f);\n\treturn sample_freq;\n}\n\nstatic int finit_module(int fd, const char *param_values, int flags)\n{\n\treturn syscall(__NR_finit_module, fd, param_values, flags);\n}\n\nstatic int delete_module(const char *name, int flags)\n{\n\treturn syscall(__NR_delete_module, name, flags);\n}\n\nint unload_bpf_testmod(bool verbose)\n{\n\tif (kern_sync_rcu())\n\t\tfprintf(stdout, \"Failed to trigger kernel-side RCU sync!\\n\");\n\tif (delete_module(\"bpf_testmod\", 0)) {\n\t\tif (errno == ENOENT) {\n\t\t\tif (verbose)\n\t\t\t\tfprintf(stdout, \"bpf_testmod.ko is already unloaded.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tfprintf(stdout, \"Failed to unload bpf_testmod.ko from kernel: %d\\n\", -errno);\n\t\treturn -1;\n\t}\n\tif (verbose)\n\t\tfprintf(stdout, \"Successfully unloaded bpf_testmod.ko.\\n\");\n\treturn 0;\n}\n\nint load_bpf_testmod(bool verbose)\n{\n\tint fd;\n\n\tif (verbose)\n\t\tfprintf(stdout, \"Loading bpf_testmod.ko...\\n\");\n\n\tfd = open(\"bpf_testmod.ko\", O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stdout, \"Can't find bpf_testmod.ko kernel module: %d\\n\", -errno);\n\t\treturn -ENOENT;\n\t}\n\tif (finit_module(fd, \"\", 0)) {\n\t\tfprintf(stdout, \"Failed to load bpf_testmod.ko into the kernel: %d\\n\", -errno);\n\t\tclose(fd);\n\t\treturn -EINVAL;\n\t}\n\tclose(fd);\n\n\tif (verbose)\n\t\tfprintf(stdout, \"Successfully loaded bpf_testmod.ko.\\n\");\n\treturn 0;\n}\n\n \nint kern_sync_rcu(void)\n{\n\treturn syscall(__NR_membarrier, MEMBARRIER_CMD_SHARED, 0, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}