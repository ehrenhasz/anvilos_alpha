{
  "module_name": "fuse_test.c",
  "hash_id": "c85d3b54ca825876ed599f14cf518b258f7724da1adb27b43e7451443b87d8b9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/memfd/fuse_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#define __EXPORTED_HEADERS__\n\n#include <errno.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <linux/falloc.h>\n#include <fcntl.h>\n#include <linux/memfd.h>\n#include <linux/types.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"common.h\"\n\n#define MFD_DEF_SIZE 8192\n#define STACK_SIZE 65536\n\nstatic size_t mfd_def_size = MFD_DEF_SIZE;\n\nstatic int mfd_assert_new(const char *name, loff_t sz, unsigned int flags)\n{\n\tint r, fd;\n\n\tfd = sys_memfd_create(name, flags);\n\tif (fd < 0) {\n\t\tprintf(\"memfd_create(\\\"%s\\\", %u) failed: %m\\n\",\n\t\t       name, flags);\n\t\tabort();\n\t}\n\n\tr = ftruncate(fd, sz);\n\tif (r < 0) {\n\t\tprintf(\"ftruncate(%llu) failed: %m\\n\", (unsigned long long)sz);\n\t\tabort();\n\t}\n\n\treturn fd;\n}\n\nstatic __u64 mfd_assert_get_seals(int fd)\n{\n\tlong r;\n\n\tr = fcntl(fd, F_GET_SEALS);\n\tif (r < 0) {\n\t\tprintf(\"GET_SEALS(%d) failed: %m\\n\", fd);\n\t\tabort();\n\t}\n\n\treturn r;\n}\n\nstatic void mfd_assert_has_seals(int fd, __u64 seals)\n{\n\t__u64 s;\n\n\ts = mfd_assert_get_seals(fd);\n\tif (s != seals) {\n\t\tprintf(\"%llu != %llu = GET_SEALS(%d)\\n\",\n\t\t       (unsigned long long)seals, (unsigned long long)s, fd);\n\t\tabort();\n\t}\n}\n\nstatic void mfd_assert_add_seals(int fd, __u64 seals)\n{\n\tlong r;\n\t__u64 s;\n\n\ts = mfd_assert_get_seals(fd);\n\tr = fcntl(fd, F_ADD_SEALS, seals);\n\tif (r < 0) {\n\t\tprintf(\"ADD_SEALS(%d, %llu -> %llu) failed: %m\\n\",\n\t\t       fd, (unsigned long long)s, (unsigned long long)seals);\n\t\tabort();\n\t}\n}\n\nstatic int mfd_busy_add_seals(int fd, __u64 seals)\n{\n\tlong r;\n\t__u64 s;\n\n\tr = fcntl(fd, F_GET_SEALS);\n\tif (r < 0)\n\t\ts = 0;\n\telse\n\t\ts = r;\n\n\tr = fcntl(fd, F_ADD_SEALS, seals);\n\tif (r < 0 && errno != EBUSY) {\n\t\tprintf(\"ADD_SEALS(%d, %llu -> %llu) didn't fail as expected with EBUSY: %m\\n\",\n\t\t       fd, (unsigned long long)s, (unsigned long long)seals);\n\t\tabort();\n\t}\n\n\treturn r;\n}\n\nstatic void *mfd_assert_mmap_shared(int fd)\n{\n\tvoid *p;\n\n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ | PROT_WRITE,\n\t\t MAP_SHARED,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\treturn p;\n}\n\nstatic void *mfd_assert_mmap_private(int fd)\n{\n\tvoid *p;\n\n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\treturn p;\n}\n\nstatic int global_mfd = -1;\nstatic void *global_p = NULL;\n\nstatic int sealing_thread_fn(void *arg)\n{\n\tint sig, r;\n\n\t \n\n\t \n\tusleep(200000);\n\n\t \n\tmunmap(global_p, mfd_def_size);\n\n\t \n\tr = mfd_busy_add_seals(global_mfd, F_SEAL_WRITE);\n\tif (r >= 0) {\n\t\tprintf(\"HURRAY! This kernel fixed GUP races!\\n\");\n\t} else {\n\t\t \n\t\tsleep(1);\n\n\t\t \n\t\tmfd_assert_add_seals(global_mfd, F_SEAL_WRITE);\n\t}\n\n\treturn 0;\n}\n\nstatic pid_t spawn_sealing_thread(void)\n{\n\tuint8_t *stack;\n\tpid_t pid;\n\n\tstack = malloc(STACK_SIZE);\n\tif (!stack) {\n\t\tprintf(\"malloc(STACK_SIZE) failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tpid = clone(sealing_thread_fn,\n\t\t    stack + STACK_SIZE,\n\t\t    SIGCHLD | CLONE_FILES | CLONE_FS | CLONE_VM,\n\t\t    NULL);\n\tif (pid < 0) {\n\t\tprintf(\"clone() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\treturn pid;\n}\n\nstatic void join_sealing_thread(pid_t pid)\n{\n\twaitpid(pid, NULL, 0);\n}\n\nint main(int argc, char **argv)\n{\n\tchar *zero;\n\tint fd, mfd, r;\n\tvoid *p;\n\tint was_sealed;\n\tpid_t pid;\n\n\tif (argc < 2) {\n\t\tprintf(\"error: please pass path to file in fuse_mnt mount-point\\n\");\n\t\tabort();\n\t}\n\n\tif (argc >= 3) {\n\t\tif (!strcmp(argv[2], \"hugetlbfs\")) {\n\t\t\tunsigned long hpage_size = default_huge_page_size();\n\n\t\t\tif (!hpage_size) {\n\t\t\t\tprintf(\"Unable to determine huge page size\\n\");\n\t\t\t\tabort();\n\t\t\t}\n\n\t\t\thugetlbfs_test = 1;\n\t\t\tmfd_def_size = hpage_size * 2;\n\t\t} else {\n\t\t\tprintf(\"Unknown option: %s\\n\", argv[2]);\n\t\t\tabort();\n\t\t}\n\t}\n\n\tzero = calloc(sizeof(*zero), mfd_def_size);\n\n\t \n\tprintf(\"opening: %s\\n\", argv[1]);\n\tfd = open(argv[1], O_RDONLY | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tprintf(\"cannot open(\\\"%s\\\"): %m\\n\", argv[1]);\n\t\tabort();\n\t}\n\n\t \n\tmfd = mfd_assert_new(\"kern_memfd_fuse\",\n\t\t\t     mfd_def_size,\n\t\t\t     MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\n\t \n\tp = mfd_assert_mmap_shared(mfd);\n\n\t \n\tglobal_mfd = mfd;\n\tglobal_p = p;\n\tpid = spawn_sealing_thread();\n\n\t \n\tr = read(fd, p, mfd_def_size);\n\tif (r < 0) {\n\t\tprintf(\"read() failed: %m\\n\");\n\t\tabort();\n\t} else if (!r) {\n\t\tprintf(\"unexpected EOF on read()\\n\");\n\t\tabort();\n\t}\n\n\twas_sealed = mfd_assert_get_seals(mfd) & F_SEAL_WRITE;\n\n\t \n\tjoin_sealing_thread(pid);\n\tmfd_assert_has_seals(mfd, F_SEAL_WRITE);\n\n\t \n\n\tp = mfd_assert_mmap_private(mfd);\n\tif (was_sealed && memcmp(p, zero, mfd_def_size)) {\n\t\tprintf(\"memfd sealed during read() but data not discarded\\n\");\n\t\tabort();\n\t} else if (!was_sealed && !memcmp(p, zero, mfd_def_size)) {\n\t\tprintf(\"memfd sealed after read() but data discarded\\n\");\n\t\tabort();\n\t}\n\n\tclose(mfd);\n\tclose(fd);\n\n\tprintf(\"fuse: DONE\\n\");\n\tfree(zero);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}