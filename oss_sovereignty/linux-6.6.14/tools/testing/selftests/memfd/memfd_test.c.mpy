{
  "module_name": "memfd_test.c",
  "hash_id": "6ea6fe3e6c9f139624ec789ed9d9f9824012ab50057838d79dadedb95d42ca84",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/memfd/memfd_test.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#define __EXPORTED_HEADERS__\n\n#include <errno.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <linux/falloc.h>\n#include <fcntl.h>\n#include <linux/memfd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <ctype.h>\n\n#include \"common.h\"\n\n#define MEMFD_STR\t\"memfd:\"\n#define MEMFD_HUGE_STR\t\"memfd-hugetlb:\"\n#define SHARED_FT_STR\t\"(shared file-table)\"\n\n#define MFD_DEF_SIZE 8192\n#define STACK_SIZE 65536\n\n#define F_SEAL_EXEC\t0x0020\n\n#define F_WX_SEALS (F_SEAL_SHRINK | \\\n\t\t    F_SEAL_GROW | \\\n\t\t    F_SEAL_WRITE | \\\n\t\t    F_SEAL_FUTURE_WRITE | \\\n\t\t    F_SEAL_EXEC)\n\n#define MFD_NOEXEC_SEAL\t0x0008U\n\n \nstatic size_t mfd_def_size = MFD_DEF_SIZE;\nstatic const char *memfd_str = MEMFD_STR;\nstatic int newpid_thread_fn2(void *arg);\nstatic void join_newpid_thread(pid_t pid);\n\nstatic ssize_t fd2name(int fd, char *buf, size_t bufsize)\n{\n\tchar buf1[PATH_MAX];\n\tint size;\n\tssize_t nbytes;\n\n\tsize = snprintf(buf1, PATH_MAX, \"/proc/self/fd/%d\", fd);\n\tif (size < 0) {\n\t\tprintf(\"snprintf(%d) failed on %m\\n\", fd);\n\t\tabort();\n\t}\n\n\t \n\tnbytes = readlink(buf1, buf, bufsize-1);\n\tif (nbytes == -1) {\n\t\tprintf(\"readlink(%s) failed %m\\n\", buf1);\n\t\tabort();\n\t}\n\tbuf[nbytes] = '\\0';\n\treturn nbytes;\n}\n\nstatic int mfd_assert_new(const char *name, loff_t sz, unsigned int flags)\n{\n\tint r, fd;\n\n\tfd = sys_memfd_create(name, flags);\n\tif (fd < 0) {\n\t\tprintf(\"memfd_create(\\\"%s\\\", %u) failed: %m\\n\",\n\t\t       name, flags);\n\t\tabort();\n\t}\n\n\tr = ftruncate(fd, sz);\n\tif (r < 0) {\n\t\tprintf(\"ftruncate(%llu) failed: %m\\n\", (unsigned long long)sz);\n\t\tabort();\n\t}\n\n\treturn fd;\n}\n\nstatic void sysctl_assert_write(const char *val)\n{\n\tint fd = open(\"/proc/sys/vm/memfd_noexec\", O_WRONLY | O_CLOEXEC);\n\n\tif (fd < 0) {\n\t\tprintf(\"open sysctl failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tif (write(fd, val, strlen(val)) < 0) {\n\t\tprintf(\"write sysctl %s failed: %m\\n\", val);\n\t\tabort();\n\t}\n}\n\nstatic void sysctl_fail_write(const char *val)\n{\n\tint fd = open(\"/proc/sys/vm/memfd_noexec\", O_WRONLY | O_CLOEXEC);\n\n\tif (fd < 0) {\n\t\tprintf(\"open sysctl failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tif (write(fd, val, strlen(val)) >= 0) {\n\t\tprintf(\"write sysctl %s succeeded, but failure expected\\n\",\n\t\t\t\tval);\n\t\tabort();\n\t}\n}\n\nstatic void sysctl_assert_equal(const char *val)\n{\n\tchar *p, buf[128] = {};\n\tint fd = open(\"/proc/sys/vm/memfd_noexec\", O_RDONLY | O_CLOEXEC);\n\n\tif (fd < 0) {\n\t\tprintf(\"open sysctl failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tif (read(fd, buf, sizeof(buf)) < 0) {\n\t\tprintf(\"read sysctl failed: %m\\n\");\n\t\tabort();\n\t}\n\n\t \n\tp = buf;\n\twhile (!isspace(*p))\n\t\tp++;\n\t*p = '\\0';\n\n\tif (strcmp(buf, val) != 0) {\n\t\tprintf(\"unexpected sysctl value: expected %s, got %s\\n\", val, buf);\n\t\tabort();\n\t}\n}\n\nstatic int mfd_assert_reopen_fd(int fd_in)\n{\n\tint fd;\n\tchar path[100];\n\n\tsprintf(path, \"/proc/self/fd/%d\", fd_in);\n\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\tprintf(\"re-open of existing fd %d failed\\n\", fd_in);\n\t\tabort();\n\t}\n\n\treturn fd;\n}\n\nstatic void mfd_fail_new(const char *name, unsigned int flags)\n{\n\tint r;\n\n\tr = sys_memfd_create(name, flags);\n\tif (r >= 0) {\n\t\tprintf(\"memfd_create(\\\"%s\\\", %u) succeeded, but failure expected\\n\",\n\t\t       name, flags);\n\t\tclose(r);\n\t\tabort();\n\t}\n}\n\nstatic unsigned int mfd_assert_get_seals(int fd)\n{\n\tint r;\n\n\tr = fcntl(fd, F_GET_SEALS);\n\tif (r < 0) {\n\t\tprintf(\"GET_SEALS(%d) failed: %m\\n\", fd);\n\t\tabort();\n\t}\n\n\treturn (unsigned int)r;\n}\n\nstatic void mfd_assert_has_seals(int fd, unsigned int seals)\n{\n\tchar buf[PATH_MAX];\n\tint nbytes;\n\tunsigned int s;\n\tfd2name(fd, buf, PATH_MAX);\n\n\ts = mfd_assert_get_seals(fd);\n\tif (s != seals) {\n\t\tprintf(\"%u != %u = GET_SEALS(%s)\\n\", seals, s, buf);\n\t\tabort();\n\t}\n}\n\nstatic void mfd_assert_add_seals(int fd, unsigned int seals)\n{\n\tint r;\n\tunsigned int s;\n\n\ts = mfd_assert_get_seals(fd);\n\tr = fcntl(fd, F_ADD_SEALS, seals);\n\tif (r < 0) {\n\t\tprintf(\"ADD_SEALS(%d, %u -> %u) failed: %m\\n\", fd, s, seals);\n\t\tabort();\n\t}\n}\n\nstatic void mfd_fail_add_seals(int fd, unsigned int seals)\n{\n\tint r;\n\tunsigned int s;\n\n\tr = fcntl(fd, F_GET_SEALS);\n\tif (r < 0)\n\t\ts = 0;\n\telse\n\t\ts = (unsigned int)r;\n\n\tr = fcntl(fd, F_ADD_SEALS, seals);\n\tif (r >= 0) {\n\t\tprintf(\"ADD_SEALS(%d, %u -> %u) didn't fail as expected\\n\",\n\t\t\t\tfd, s, seals);\n\t\tabort();\n\t}\n}\n\nstatic void mfd_assert_size(int fd, size_t size)\n{\n\tstruct stat st;\n\tint r;\n\n\tr = fstat(fd, &st);\n\tif (r < 0) {\n\t\tprintf(\"fstat(%d) failed: %m\\n\", fd);\n\t\tabort();\n\t} else if (st.st_size != size) {\n\t\tprintf(\"wrong file size %lld, but expected %lld\\n\",\n\t\t       (long long)st.st_size, (long long)size);\n\t\tabort();\n\t}\n}\n\nstatic int mfd_assert_dup(int fd)\n{\n\tint r;\n\n\tr = dup(fd);\n\tif (r < 0) {\n\t\tprintf(\"dup(%d) failed: %m\\n\", fd);\n\t\tabort();\n\t}\n\n\treturn r;\n}\n\nstatic void *mfd_assert_mmap_shared(int fd)\n{\n\tvoid *p;\n\n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ | PROT_WRITE,\n\t\t MAP_SHARED,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\treturn p;\n}\n\nstatic void *mfd_assert_mmap_private(int fd)\n{\n\tvoid *p;\n\n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ,\n\t\t MAP_PRIVATE,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\treturn p;\n}\n\nstatic int mfd_assert_open(int fd, int flags, mode_t mode)\n{\n\tchar buf[512];\n\tint r;\n\n\tsprintf(buf, \"/proc/self/fd/%d\", fd);\n\tr = open(buf, flags, mode);\n\tif (r < 0) {\n\t\tprintf(\"open(%s) failed: %m\\n\", buf);\n\t\tabort();\n\t}\n\n\treturn r;\n}\n\nstatic void mfd_fail_open(int fd, int flags, mode_t mode)\n{\n\tchar buf[512];\n\tint r;\n\n\tsprintf(buf, \"/proc/self/fd/%d\", fd);\n\tr = open(buf, flags, mode);\n\tif (r >= 0) {\n\t\tprintf(\"open(%s) didn't fail as expected\\n\", buf);\n\t\tabort();\n\t}\n}\n\nstatic void mfd_assert_read(int fd)\n{\n\tchar buf[16];\n\tvoid *p;\n\tssize_t l;\n\n\tl = read(fd, buf, sizeof(buf));\n\tif (l != sizeof(buf)) {\n\t\tprintf(\"read() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\t \n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ,\n\t\t MAP_PRIVATE,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\tmunmap(p, mfd_def_size);\n\n\t \n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\tmunmap(p, mfd_def_size);\n}\n\n \nstatic void mfd_assert_read_shared(int fd)\n{\n\tvoid *p;\n\n\t \n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ,\n\t\t MAP_SHARED,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\tmunmap(p, mfd_def_size);\n}\n\nstatic void mfd_assert_fork_private_write(int fd)\n{\n\tint *p;\n\tpid_t pid;\n\n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tp[0] = 22;\n\n\tpid = fork();\n\tif (pid == 0) {\n\t\tp[0] = 33;\n\t\texit(0);\n\t} else {\n\t\twaitpid(pid, NULL, 0);\n\n\t\tif (p[0] != 22) {\n\t\t\tprintf(\"MAP_PRIVATE copy-on-write failed: %m\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\n\tmunmap(p, mfd_def_size);\n}\n\nstatic void mfd_assert_write(int fd)\n{\n\tssize_t l;\n\tvoid *p;\n\tint r;\n\n\t \n\tif (!hugetlbfs_test) {\n\t\t \n\t\tl = write(fd, \"\\0\\0\\0\\0\", 4);\n\t\tif (l != 4) {\n\t\t\tprintf(\"write() failed: %m\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\n\t \n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ | PROT_WRITE,\n\t\t MAP_SHARED,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\t*(char *)p = 0;\n\tmunmap(p, mfd_def_size);\n\n\t \n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_WRITE,\n\t\t MAP_SHARED,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\t*(char *)p = 0;\n\tmunmap(p, mfd_def_size);\n\n\t \n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ,\n\t\t MAP_SHARED,\n\t\t fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"mmap() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tr = mprotect(p, mfd_def_size, PROT_READ | PROT_WRITE);\n\tif (r < 0) {\n\t\tprintf(\"mprotect() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\t*(char *)p = 0;\n\tmunmap(p, mfd_def_size);\n\n\t \n\tr = fallocate(fd,\n\t\t      FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t      0,\n\t\t      mfd_def_size);\n\tif (r < 0) {\n\t\tprintf(\"fallocate(PUNCH_HOLE) failed: %m\\n\");\n\t\tabort();\n\t}\n}\n\nstatic void mfd_fail_write(int fd)\n{\n\tssize_t l;\n\tvoid *p;\n\tint r;\n\n\t \n\tl = write(fd, \"data\", 4);\n\tif (l != -EPERM) {\n\t\tprintf(\"expected EPERM on write(), but got %d: %m\\n\", (int)l);\n\t\tabort();\n\t}\n\n\t \n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ | PROT_WRITE,\n\t\t MAP_SHARED,\n\t\t fd,\n\t\t 0);\n\tif (p != MAP_FAILED) {\n\t\tprintf(\"mmap() didn't fail as expected\\n\");\n\t\tabort();\n\t}\n\n\t \n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_WRITE,\n\t\t MAP_SHARED,\n\t\t fd,\n\t\t 0);\n\tif (p != MAP_FAILED) {\n\t\tprintf(\"mmap() didn't fail as expected\\n\");\n\t\tabort();\n\t}\n\n\t \n\tp = mmap(NULL,\n\t\t mfd_def_size,\n\t\t PROT_READ,\n\t\t MAP_SHARED,\n\t\t fd,\n\t\t 0);\n\tif (p != MAP_FAILED) {\n\t\tr = mprotect(p, mfd_def_size, PROT_READ | PROT_WRITE);\n\t\tif (r >= 0) {\n\t\t\tprintf(\"mmap()+mprotect() didn't fail as expected\\n\");\n\t\t\tabort();\n\t\t}\n\t\tmunmap(p, mfd_def_size);\n\t}\n\n\t \n\tr = fallocate(fd,\n\t\t      FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t      0,\n\t\t      mfd_def_size);\n\tif (r >= 0) {\n\t\tprintf(\"fallocate(PUNCH_HOLE) didn't fail as expected\\n\");\n\t\tabort();\n\t}\n}\n\nstatic void mfd_assert_shrink(int fd)\n{\n\tint r, fd2;\n\n\tr = ftruncate(fd, mfd_def_size / 2);\n\tif (r < 0) {\n\t\tprintf(\"ftruncate(SHRINK) failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tmfd_assert_size(fd, mfd_def_size / 2);\n\n\tfd2 = mfd_assert_open(fd,\n\t\t\t      O_RDWR | O_CREAT | O_TRUNC,\n\t\t\t      S_IRUSR | S_IWUSR);\n\tclose(fd2);\n\n\tmfd_assert_size(fd, 0);\n}\n\nstatic void mfd_fail_shrink(int fd)\n{\n\tint r;\n\n\tr = ftruncate(fd, mfd_def_size / 2);\n\tif (r >= 0) {\n\t\tprintf(\"ftruncate(SHRINK) didn't fail as expected\\n\");\n\t\tabort();\n\t}\n\n\tmfd_fail_open(fd,\n\t\t      O_RDWR | O_CREAT | O_TRUNC,\n\t\t      S_IRUSR | S_IWUSR);\n}\n\nstatic void mfd_assert_grow(int fd)\n{\n\tint r;\n\n\tr = ftruncate(fd, mfd_def_size * 2);\n\tif (r < 0) {\n\t\tprintf(\"ftruncate(GROW) failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tmfd_assert_size(fd, mfd_def_size * 2);\n\n\tr = fallocate(fd,\n\t\t      0,\n\t\t      0,\n\t\t      mfd_def_size * 4);\n\tif (r < 0) {\n\t\tprintf(\"fallocate(ALLOC) failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tmfd_assert_size(fd, mfd_def_size * 4);\n}\n\nstatic void mfd_fail_grow(int fd)\n{\n\tint r;\n\n\tr = ftruncate(fd, mfd_def_size * 2);\n\tif (r >= 0) {\n\t\tprintf(\"ftruncate(GROW) didn't fail as expected\\n\");\n\t\tabort();\n\t}\n\n\tr = fallocate(fd,\n\t\t      0,\n\t\t      0,\n\t\t      mfd_def_size * 4);\n\tif (r >= 0) {\n\t\tprintf(\"fallocate(ALLOC) didn't fail as expected\\n\");\n\t\tabort();\n\t}\n}\n\nstatic void mfd_assert_grow_write(int fd)\n{\n\tstatic char *buf;\n\tssize_t l;\n\n\t \n\tif (hugetlbfs_test)\n\t\treturn;\n\n\tbuf = malloc(mfd_def_size * 8);\n\tif (!buf) {\n\t\tprintf(\"malloc(%zu) failed: %m\\n\", mfd_def_size * 8);\n\t\tabort();\n\t}\n\n\tl = pwrite(fd, buf, mfd_def_size * 8, 0);\n\tif (l != (mfd_def_size * 8)) {\n\t\tprintf(\"pwrite() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tmfd_assert_size(fd, mfd_def_size * 8);\n}\n\nstatic void mfd_fail_grow_write(int fd)\n{\n\tstatic char *buf;\n\tssize_t l;\n\n\t \n\tif (hugetlbfs_test)\n\t\treturn;\n\n\tbuf = malloc(mfd_def_size * 8);\n\tif (!buf) {\n\t\tprintf(\"malloc(%zu) failed: %m\\n\", mfd_def_size * 8);\n\t\tabort();\n\t}\n\n\tl = pwrite(fd, buf, mfd_def_size * 8, 0);\n\tif (l == (mfd_def_size * 8)) {\n\t\tprintf(\"pwrite() didn't fail as expected\\n\");\n\t\tabort();\n\t}\n}\n\nstatic void mfd_assert_mode(int fd, int mode)\n{\n\tstruct stat st;\n\tchar buf[PATH_MAX];\n\tint nbytes;\n\n\tfd2name(fd, buf, PATH_MAX);\n\n\tif (fstat(fd, &st) < 0) {\n\t\tprintf(\"fstat(%s) failed: %m\\n\", buf);\n\t\tabort();\n\t}\n\n\tif ((st.st_mode & 07777) != mode) {\n\t\tprintf(\"fstat(%s) wrong file mode 0%04o, but expected 0%04o\\n\",\n\t\t       buf, (int)st.st_mode & 07777, mode);\n\t\tabort();\n\t}\n}\n\nstatic void mfd_assert_chmod(int fd, int mode)\n{\n\tchar buf[PATH_MAX];\n\tint nbytes;\n\n\tfd2name(fd, buf, PATH_MAX);\n\n\tif (fchmod(fd, mode) < 0) {\n\t\tprintf(\"fchmod(%s, 0%04o) failed: %m\\n\", buf, mode);\n\t\tabort();\n\t}\n\n\tmfd_assert_mode(fd, mode);\n}\n\nstatic void mfd_fail_chmod(int fd, int mode)\n{\n\tstruct stat st;\n\tchar buf[PATH_MAX];\n\tint nbytes;\n\n\tfd2name(fd, buf, PATH_MAX);\n\n\tif (fstat(fd, &st) < 0) {\n\t\tprintf(\"fstat(%s) failed: %m\\n\", buf);\n\t\tabort();\n\t}\n\n\tif (fchmod(fd, mode) == 0) {\n\t\tprintf(\"fchmod(%s, 0%04o) didn't fail as expected\\n\",\n\t\t       buf, mode);\n\t\tabort();\n\t}\n\n\t \n\tmfd_assert_mode(fd, st.st_mode & 07777);\n}\n\nstatic int idle_thread_fn(void *arg)\n{\n\tsigset_t set;\n\tint sig;\n\n\t \n\tsigemptyset(&set);\n\tsigaddset(&set, SIGTERM);\n\tsigwait(&set, &sig);\n\n\treturn 0;\n}\n\nstatic pid_t spawn_thread(unsigned int flags, int (*fn)(void *), void *arg)\n{\n\tuint8_t *stack;\n\tpid_t pid;\n\n\tstack = malloc(STACK_SIZE);\n\tif (!stack) {\n\t\tprintf(\"malloc(STACK_SIZE) failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tpid = clone(fn, stack + STACK_SIZE, SIGCHLD | flags, arg);\n\tif (pid < 0) {\n\t\tprintf(\"clone() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\treturn pid;\n}\n\nstatic void join_thread(pid_t pid)\n{\n\tint wstatus;\n\n\tif (waitpid(pid, &wstatus, 0) < 0) {\n\t\tprintf(\"newpid thread: waitpid() failed: %m\\n\");\n\t\tabort();\n\t}\n\n\tif (WIFEXITED(wstatus) && WEXITSTATUS(wstatus) != 0) {\n\t\tprintf(\"newpid thread: exited with non-zero error code %d\\n\",\n\t\t       WEXITSTATUS(wstatus));\n\t\tabort();\n\t}\n\n\tif (WIFSIGNALED(wstatus)) {\n\t\tprintf(\"newpid thread: killed by signal %d\\n\",\n\t\t       WTERMSIG(wstatus));\n\t\tabort();\n\t}\n}\n\nstatic pid_t spawn_idle_thread(unsigned int flags)\n{\n\treturn spawn_thread(flags, idle_thread_fn, NULL);\n}\n\nstatic void join_idle_thread(pid_t pid)\n{\n\tkill(pid, SIGTERM);\n\twaitpid(pid, NULL, 0);\n}\n\n \nstatic void test_create(void)\n{\n\tchar buf[2048];\n\tint fd;\n\n\tprintf(\"%s CREATE\\n\", memfd_str);\n\n\t \n\tmfd_fail_new(NULL, 0);\n\n\t \n\tmemset(buf, 0xff, sizeof(buf));\n\tmfd_fail_new(buf, 0);\n\n\t \n\tmemset(buf, 0xff, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = 0;\n\tmfd_fail_new(buf, 0);\n\n\t \n\tfd = mfd_assert_new(\"\", 0, 0);\n\tclose(fd);\n\n\t \n\tmfd_fail_new(\"\", 0x0100);\n\tmfd_fail_new(\"\", ~MFD_CLOEXEC);\n\tmfd_fail_new(\"\", ~MFD_ALLOW_SEALING);\n\tmfd_fail_new(\"\", ~0);\n\tmfd_fail_new(\"\", 0x80000000U);\n\n\t \n\tmfd_fail_new(\"\", MFD_EXEC | MFD_NOEXEC_SEAL);\n\n\t \n\tfd = mfd_assert_new(\"\", 0, MFD_CLOEXEC);\n\tclose(fd);\n\n\t \n\tfd = mfd_assert_new(\"\", 0, MFD_ALLOW_SEALING);\n\tclose(fd);\n\n\t \n\tfd = mfd_assert_new(\"\", 0, MFD_ALLOW_SEALING | MFD_CLOEXEC);\n\tclose(fd);\n}\n\n \nstatic void test_basic(void)\n{\n\tint fd;\n\n\tprintf(\"%s BASIC\\n\", memfd_str);\n\n\tfd = mfd_assert_new(\"kern_memfd_basic\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\n\t \n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_add_seals(fd, F_SEAL_SHRINK |\n\t\t\t\t F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_SHRINK |\n\t\t\t\t F_SEAL_WRITE);\n\n\t \n\tmfd_assert_add_seals(fd, F_SEAL_SHRINK |\n\t\t\t\t F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_SHRINK |\n\t\t\t\t F_SEAL_WRITE);\n\n\t \n\tmfd_assert_add_seals(fd, F_SEAL_GROW | F_SEAL_SEAL);\n\tmfd_assert_has_seals(fd, F_SEAL_SHRINK |\n\t\t\t\t F_SEAL_GROW |\n\t\t\t\t F_SEAL_WRITE |\n\t\t\t\t F_SEAL_SEAL);\n\n\t \n\tmfd_fail_add_seals(fd, F_SEAL_GROW);\n\tmfd_fail_add_seals(fd, 0);\n\n\tclose(fd);\n\n\t \n\tfd = mfd_assert_new(\"kern_memfd_basic\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC);\n\tmfd_assert_has_seals(fd, F_SEAL_SEAL);\n\tmfd_fail_add_seals(fd, F_SEAL_SHRINK |\n\t\t\t       F_SEAL_GROW |\n\t\t\t       F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_SEAL);\n\tclose(fd);\n}\n\n \nstatic void test_seal_write(void)\n{\n\tint fd;\n\n\tprintf(\"%s SEAL-WRITE\\n\", memfd_str);\n\n\tfd = mfd_assert_new(\"kern_memfd_seal_write\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_add_seals(fd, F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_WRITE);\n\n\tmfd_assert_read(fd);\n\tmfd_fail_write(fd);\n\tmfd_assert_shrink(fd);\n\tmfd_assert_grow(fd);\n\tmfd_fail_grow_write(fd);\n\n\tclose(fd);\n}\n\n \nstatic void test_seal_future_write(void)\n{\n\tint fd, fd2;\n\tvoid *p;\n\n\tprintf(\"%s SEAL-FUTURE-WRITE\\n\", memfd_str);\n\n\tfd = mfd_assert_new(\"kern_memfd_seal_future_write\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\n\tp = mfd_assert_mmap_shared(fd);\n\n\tmfd_assert_has_seals(fd, 0);\n\n\tmfd_assert_add_seals(fd, F_SEAL_FUTURE_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_FUTURE_WRITE);\n\n\t \n\tmfd_assert_read(fd);\n\tmfd_assert_read_shared(fd);\n\tmfd_fail_write(fd);\n\n\tfd2 = mfd_assert_reopen_fd(fd);\n\t \n\tmfd_assert_read(fd2);\n\tmfd_assert_read_shared(fd2);\n\tmfd_fail_write(fd2);\n\n\tmfd_assert_fork_private_write(fd);\n\n\tmunmap(p, mfd_def_size);\n\tclose(fd2);\n\tclose(fd);\n}\n\n \nstatic void test_seal_shrink(void)\n{\n\tint fd;\n\n\tprintf(\"%s SEAL-SHRINK\\n\", memfd_str);\n\n\tfd = mfd_assert_new(\"kern_memfd_seal_shrink\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_add_seals(fd, F_SEAL_SHRINK);\n\tmfd_assert_has_seals(fd, F_SEAL_SHRINK);\n\n\tmfd_assert_read(fd);\n\tmfd_assert_write(fd);\n\tmfd_fail_shrink(fd);\n\tmfd_assert_grow(fd);\n\tmfd_assert_grow_write(fd);\n\n\tclose(fd);\n}\n\n \nstatic void test_seal_grow(void)\n{\n\tint fd;\n\n\tprintf(\"%s SEAL-GROW\\n\", memfd_str);\n\n\tfd = mfd_assert_new(\"kern_memfd_seal_grow\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_add_seals(fd, F_SEAL_GROW);\n\tmfd_assert_has_seals(fd, F_SEAL_GROW);\n\n\tmfd_assert_read(fd);\n\tmfd_assert_write(fd);\n\tmfd_assert_shrink(fd);\n\tmfd_fail_grow(fd);\n\tmfd_fail_grow_write(fd);\n\n\tclose(fd);\n}\n\n \nstatic void test_seal_resize(void)\n{\n\tint fd;\n\n\tprintf(\"%s SEAL-RESIZE\\n\", memfd_str);\n\n\tfd = mfd_assert_new(\"kern_memfd_seal_resize\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_add_seals(fd, F_SEAL_SHRINK | F_SEAL_GROW);\n\tmfd_assert_has_seals(fd, F_SEAL_SHRINK | F_SEAL_GROW);\n\n\tmfd_assert_read(fd);\n\tmfd_assert_write(fd);\n\tmfd_fail_shrink(fd);\n\tmfd_fail_grow(fd);\n\tmfd_fail_grow_write(fd);\n\n\tclose(fd);\n}\n\n \nstatic void test_exec_seal(void)\n{\n\tint fd;\n\n\tprintf(\"%s SEAL-EXEC\\n\", memfd_str);\n\n\tprintf(\"%s\tApply SEAL_EXEC\\n\", memfd_str);\n\tfd = mfd_assert_new(\"kern_memfd_seal_exec\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING | MFD_EXEC);\n\n\tmfd_assert_mode(fd, 0777);\n\tmfd_assert_chmod(fd, 0644);\n\n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_add_seals(fd, F_SEAL_EXEC);\n\tmfd_assert_has_seals(fd, F_SEAL_EXEC);\n\n\tmfd_assert_chmod(fd, 0600);\n\tmfd_fail_chmod(fd, 0777);\n\tmfd_fail_chmod(fd, 0670);\n\tmfd_fail_chmod(fd, 0605);\n\tmfd_fail_chmod(fd, 0700);\n\tmfd_fail_chmod(fd, 0100);\n\tmfd_assert_chmod(fd, 0666);\n\tmfd_assert_write(fd);\n\tclose(fd);\n\n\tprintf(\"%s\tApply ALL_SEALS\\n\", memfd_str);\n\tfd = mfd_assert_new(\"kern_memfd_seal_exec\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING | MFD_EXEC);\n\n\tmfd_assert_mode(fd, 0777);\n\tmfd_assert_chmod(fd, 0700);\n\n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_add_seals(fd, F_SEAL_EXEC);\n\tmfd_assert_has_seals(fd, F_WX_SEALS);\n\n\tmfd_fail_chmod(fd, 0711);\n\tmfd_fail_chmod(fd, 0600);\n\tmfd_fail_write(fd);\n\tclose(fd);\n}\n\n \nstatic void test_exec_no_seal(void)\n{\n\tint fd;\n\n\tprintf(\"%s EXEC_NO_SEAL\\n\", memfd_str);\n\n\t \n\tfd = mfd_assert_new(\"kern_memfd_exec_no_sealing\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_EXEC);\n\tmfd_assert_mode(fd, 0777);\n\tmfd_assert_has_seals(fd, F_SEAL_SEAL);\n\tmfd_assert_chmod(fd, 0666);\n\tclose(fd);\n}\n\n \nstatic void test_noexec_seal(void)\n{\n\tint fd;\n\n\tprintf(\"%s NOEXEC_SEAL\\n\", memfd_str);\n\n\t \n\tfd = mfd_assert_new(\"kern_memfd_noexec\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING | MFD_NOEXEC_SEAL);\n\tmfd_assert_mode(fd, 0666);\n\tmfd_assert_has_seals(fd, F_SEAL_EXEC);\n\tmfd_fail_chmod(fd, 0777);\n\tclose(fd);\n\n\t \n\tfd = mfd_assert_new(\"kern_memfd_noexec\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_NOEXEC_SEAL);\n\tmfd_assert_mode(fd, 0666);\n\tmfd_assert_has_seals(fd, F_SEAL_EXEC);\n\tmfd_fail_chmod(fd, 0777);\n\tclose(fd);\n}\n\nstatic void test_sysctl_sysctl0(void)\n{\n\tint fd;\n\n\tsysctl_assert_equal(\"0\");\n\n\tfd = mfd_assert_new(\"kern_memfd_sysctl_0_dfl\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_mode(fd, 0777);\n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_chmod(fd, 0644);\n\tclose(fd);\n}\n\nstatic void test_sysctl_set_sysctl0(void)\n{\n\tsysctl_assert_write(\"0\");\n\ttest_sysctl_sysctl0();\n}\n\nstatic void test_sysctl_sysctl1(void)\n{\n\tint fd;\n\n\tsysctl_assert_equal(\"1\");\n\n\tfd = mfd_assert_new(\"kern_memfd_sysctl_1_dfl\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_mode(fd, 0666);\n\tmfd_assert_has_seals(fd, F_SEAL_EXEC);\n\tmfd_fail_chmod(fd, 0777);\n\tclose(fd);\n\n\tfd = mfd_assert_new(\"kern_memfd_sysctl_1_exec\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_EXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_mode(fd, 0777);\n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_chmod(fd, 0644);\n\tclose(fd);\n\n\tfd = mfd_assert_new(\"kern_memfd_sysctl_1_noexec\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_NOEXEC_SEAL | MFD_ALLOW_SEALING);\n\tmfd_assert_mode(fd, 0666);\n\tmfd_assert_has_seals(fd, F_SEAL_EXEC);\n\tmfd_fail_chmod(fd, 0777);\n\tclose(fd);\n}\n\nstatic void test_sysctl_set_sysctl1(void)\n{\n\tsysctl_assert_write(\"1\");\n\ttest_sysctl_sysctl1();\n}\n\nstatic void test_sysctl_sysctl2(void)\n{\n\tint fd;\n\n\tsysctl_assert_equal(\"2\");\n\n\tfd = mfd_assert_new(\"kern_memfd_sysctl_2_dfl\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_mode(fd, 0666);\n\tmfd_assert_has_seals(fd, F_SEAL_EXEC);\n\tmfd_fail_chmod(fd, 0777);\n\tclose(fd);\n\n\tmfd_fail_new(\"kern_memfd_sysctl_2_exec\",\n\t\t     MFD_CLOEXEC | MFD_EXEC | MFD_ALLOW_SEALING);\n\n\tfd = mfd_assert_new(\"kern_memfd_sysctl_2_noexec\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_NOEXEC_SEAL | MFD_ALLOW_SEALING);\n\tmfd_assert_mode(fd, 0666);\n\tmfd_assert_has_seals(fd, F_SEAL_EXEC);\n\tmfd_fail_chmod(fd, 0777);\n\tclose(fd);\n}\n\nstatic void test_sysctl_set_sysctl2(void)\n{\n\tsysctl_assert_write(\"2\");\n\ttest_sysctl_sysctl2();\n}\n\nstatic int sysctl_simple_child(void *arg)\n{\n\tint fd;\n\tint pid;\n\n\tprintf(\"%s sysctl 0\\n\", memfd_str);\n\ttest_sysctl_set_sysctl0();\n\n\tprintf(\"%s sysctl 1\\n\", memfd_str);\n\ttest_sysctl_set_sysctl1();\n\n\tprintf(\"%s sysctl 0\\n\", memfd_str);\n\ttest_sysctl_set_sysctl0();\n\n\tprintf(\"%s sysctl 2\\n\", memfd_str);\n\ttest_sysctl_set_sysctl2();\n\n\tprintf(\"%s sysctl 1\\n\", memfd_str);\n\ttest_sysctl_set_sysctl1();\n\n\tprintf(\"%s sysctl 0\\n\", memfd_str);\n\ttest_sysctl_set_sysctl0();\n\n\treturn 0;\n}\n\n \nstatic void test_sysctl_simple(void)\n{\n\tint pid = spawn_thread(CLONE_NEWPID, sysctl_simple_child, NULL);\n\n\tjoin_thread(pid);\n}\n\nstatic int sysctl_nested(void *arg)\n{\n\tvoid (*fn)(void) = arg;\n\n\tfn();\n\treturn 0;\n}\n\nstatic int sysctl_nested_wait(void *arg)\n{\n\t \n\tkill(getpid(), SIGSTOP);\n\treturn sysctl_nested(arg);\n}\n\nstatic void test_sysctl_sysctl1_failset(void)\n{\n\tsysctl_fail_write(\"0\");\n\ttest_sysctl_sysctl1();\n}\n\nstatic void test_sysctl_sysctl2_failset(void)\n{\n\tsysctl_fail_write(\"1\");\n\ttest_sysctl_sysctl2();\n\n\tsysctl_fail_write(\"0\");\n\ttest_sysctl_sysctl2();\n}\n\nstatic int sysctl_nested_child(void *arg)\n{\n\tint fd;\n\tint pid;\n\n\tprintf(\"%s nested sysctl 0\\n\", memfd_str);\n\tsysctl_assert_write(\"0\");\n\t \n\tpid = spawn_thread(CLONE_NEWPID, sysctl_simple_child, NULL);\n\tjoin_thread(pid);\n\n\tprintf(\"%s nested sysctl 1\\n\", memfd_str);\n\tsysctl_assert_write(\"1\");\n\t \n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested, test_sysctl_sysctl1);\n\tjoin_thread(pid);\n\t \n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested,\n\t\t\t   test_sysctl_sysctl1_failset);\n\tjoin_thread(pid);\n\t \n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested,\n\t\t\t   test_sysctl_set_sysctl2);\n\tjoin_thread(pid);\n\t \n\ttest_sysctl_sysctl1();\n\n\tprintf(\"%s nested sysctl 2\\n\", memfd_str);\n\tsysctl_assert_write(\"2\");\n\t \n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested, test_sysctl_sysctl2);\n\tjoin_thread(pid);\n\t \n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested,\n\t\t\t   test_sysctl_sysctl2_failset);\n\tjoin_thread(pid);\n\n\t \n\tprintf(\"%s nested sysctl 0 -> 1 after fork\\n\", memfd_str);\n\tsysctl_assert_write(\"0\");\n\n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested_wait,\n\t\t\t   test_sysctl_sysctl1_failset);\n\tsysctl_assert_write(\"1\");\n\tkill(pid, SIGCONT);\n\tjoin_thread(pid);\n\n\tprintf(\"%s nested sysctl 0 -> 2 after fork\\n\", memfd_str);\n\tsysctl_assert_write(\"0\");\n\n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested_wait,\n\t\t\t   test_sysctl_sysctl2_failset);\n\tsysctl_assert_write(\"2\");\n\tkill(pid, SIGCONT);\n\tjoin_thread(pid);\n\n\t \n\tprintf(\"%s nested sysctl 2 -> 1 after fork\\n\", memfd_str);\n\tsysctl_assert_write(\"2\");\n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested_wait,\n\t\t\t   test_sysctl_sysctl2);\n\tsysctl_assert_write(\"1\");\n\tkill(pid, SIGCONT);\n\tjoin_thread(pid);\n\n\tprintf(\"%s nested sysctl 2 -> 0 after fork\\n\", memfd_str);\n\tsysctl_assert_write(\"2\");\n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested_wait,\n\t\t\t   test_sysctl_sysctl2);\n\tsysctl_assert_write(\"0\");\n\tkill(pid, SIGCONT);\n\tjoin_thread(pid);\n\n\tprintf(\"%s nested sysctl 1 -> 0 after fork\\n\", memfd_str);\n\tsysctl_assert_write(\"1\");\n\tpid = spawn_thread(CLONE_NEWPID, sysctl_nested_wait,\n\t\t\t   test_sysctl_sysctl1);\n\tsysctl_assert_write(\"0\");\n\tkill(pid, SIGCONT);\n\tjoin_thread(pid);\n\n\treturn 0;\n}\n\n \nstatic void test_sysctl_nested(void)\n{\n\tint pid = spawn_thread(CLONE_NEWPID, sysctl_nested_child, NULL);\n\n\tjoin_thread(pid);\n}\n\n \nstatic void test_share_dup(char *banner, char *b_suffix)\n{\n\tint fd, fd2;\n\n\tprintf(\"%s %s %s\\n\", memfd_str, banner, b_suffix);\n\n\tfd = mfd_assert_new(\"kern_memfd_share_dup\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_has_seals(fd, 0);\n\n\tfd2 = mfd_assert_dup(fd);\n\tmfd_assert_has_seals(fd2, 0);\n\n\tmfd_assert_add_seals(fd, F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd2, F_SEAL_WRITE);\n\n\tmfd_assert_add_seals(fd2, F_SEAL_SHRINK);\n\tmfd_assert_has_seals(fd, F_SEAL_WRITE | F_SEAL_SHRINK);\n\tmfd_assert_has_seals(fd2, F_SEAL_WRITE | F_SEAL_SHRINK);\n\n\tmfd_assert_add_seals(fd, F_SEAL_SEAL);\n\tmfd_assert_has_seals(fd, F_SEAL_WRITE | F_SEAL_SHRINK | F_SEAL_SEAL);\n\tmfd_assert_has_seals(fd2, F_SEAL_WRITE | F_SEAL_SHRINK | F_SEAL_SEAL);\n\n\tmfd_fail_add_seals(fd, F_SEAL_GROW);\n\tmfd_fail_add_seals(fd2, F_SEAL_GROW);\n\tmfd_fail_add_seals(fd, F_SEAL_SEAL);\n\tmfd_fail_add_seals(fd2, F_SEAL_SEAL);\n\n\tclose(fd2);\n\n\tmfd_fail_add_seals(fd, F_SEAL_GROW);\n\tclose(fd);\n}\n\n \nstatic void test_share_mmap(char *banner, char *b_suffix)\n{\n\tint fd;\n\tvoid *p;\n\n\tprintf(\"%s %s %s\\n\", memfd_str,  banner, b_suffix);\n\n\tfd = mfd_assert_new(\"kern_memfd_share_mmap\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_has_seals(fd, 0);\n\n\t \n\tp = mfd_assert_mmap_shared(fd);\n\tmfd_fail_add_seals(fd, F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, 0);\n\tmfd_assert_add_seals(fd, F_SEAL_SHRINK);\n\tmfd_assert_has_seals(fd, F_SEAL_SHRINK);\n\tmunmap(p, mfd_def_size);\n\n\t \n\tp = mfd_assert_mmap_private(fd);\n\tmfd_assert_add_seals(fd, F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_WRITE | F_SEAL_SHRINK);\n\tmunmap(p, mfd_def_size);\n\n\tclose(fd);\n}\n\n \nstatic void test_share_open(char *banner, char *b_suffix)\n{\n\tint fd, fd2;\n\n\tprintf(\"%s %s %s\\n\", memfd_str, banner, b_suffix);\n\n\tfd = mfd_assert_new(\"kern_memfd_share_open\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_has_seals(fd, 0);\n\n\tfd2 = mfd_assert_open(fd, O_RDWR, 0);\n\tmfd_assert_add_seals(fd, F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd2, F_SEAL_WRITE);\n\n\tmfd_assert_add_seals(fd2, F_SEAL_SHRINK);\n\tmfd_assert_has_seals(fd, F_SEAL_WRITE | F_SEAL_SHRINK);\n\tmfd_assert_has_seals(fd2, F_SEAL_WRITE | F_SEAL_SHRINK);\n\n\tclose(fd);\n\tfd = mfd_assert_open(fd2, O_RDONLY, 0);\n\n\tmfd_fail_add_seals(fd, F_SEAL_SEAL);\n\tmfd_assert_has_seals(fd, F_SEAL_WRITE | F_SEAL_SHRINK);\n\tmfd_assert_has_seals(fd2, F_SEAL_WRITE | F_SEAL_SHRINK);\n\n\tclose(fd2);\n\tfd2 = mfd_assert_open(fd, O_RDWR, 0);\n\n\tmfd_assert_add_seals(fd2, F_SEAL_SEAL);\n\tmfd_assert_has_seals(fd, F_SEAL_WRITE | F_SEAL_SHRINK | F_SEAL_SEAL);\n\tmfd_assert_has_seals(fd2, F_SEAL_WRITE | F_SEAL_SHRINK | F_SEAL_SEAL);\n\n\tclose(fd2);\n\tclose(fd);\n}\n\n \nstatic void test_share_fork(char *banner, char *b_suffix)\n{\n\tint fd;\n\tpid_t pid;\n\n\tprintf(\"%s %s %s\\n\", memfd_str, banner, b_suffix);\n\n\tfd = mfd_assert_new(\"kern_memfd_share_fork\",\n\t\t\t    mfd_def_size,\n\t\t\t    MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\tmfd_assert_has_seals(fd, 0);\n\n\tpid = spawn_idle_thread(0);\n\tmfd_assert_add_seals(fd, F_SEAL_SEAL);\n\tmfd_assert_has_seals(fd, F_SEAL_SEAL);\n\n\tmfd_fail_add_seals(fd, F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_SEAL);\n\n\tjoin_idle_thread(pid);\n\n\tmfd_fail_add_seals(fd, F_SEAL_WRITE);\n\tmfd_assert_has_seals(fd, F_SEAL_SEAL);\n\n\tclose(fd);\n}\n\nint main(int argc, char **argv)\n{\n\tpid_t pid;\n\n\tif (argc == 2) {\n\t\tif (!strcmp(argv[1], \"hugetlbfs\")) {\n\t\t\tunsigned long hpage_size = default_huge_page_size();\n\n\t\t\tif (!hpage_size) {\n\t\t\t\tprintf(\"Unable to determine huge page size\\n\");\n\t\t\t\tabort();\n\t\t\t}\n\n\t\t\thugetlbfs_test = 1;\n\t\t\tmemfd_str = MEMFD_HUGE_STR;\n\t\t\tmfd_def_size = hpage_size * 2;\n\t\t} else {\n\t\t\tprintf(\"Unknown option: %s\\n\", argv[1]);\n\t\t\tabort();\n\t\t}\n\t}\n\n\ttest_create();\n\ttest_basic();\n\ttest_exec_seal();\n\ttest_exec_no_seal();\n\ttest_noexec_seal();\n\n\ttest_seal_write();\n\ttest_seal_future_write();\n\ttest_seal_shrink();\n\ttest_seal_grow();\n\ttest_seal_resize();\n\n\ttest_sysctl_simple();\n\ttest_sysctl_nested();\n\n\ttest_share_dup(\"SHARE-DUP\", \"\");\n\ttest_share_mmap(\"SHARE-MMAP\", \"\");\n\ttest_share_open(\"SHARE-OPEN\", \"\");\n\ttest_share_fork(\"SHARE-FORK\", \"\");\n\n\t \n\tpid = spawn_idle_thread(CLONE_FILES | CLONE_FS | CLONE_VM);\n\ttest_share_dup(\"SHARE-DUP\", SHARED_FT_STR);\n\ttest_share_mmap(\"SHARE-MMAP\", SHARED_FT_STR);\n\ttest_share_open(\"SHARE-OPEN\", SHARED_FT_STR);\n\ttest_share_fork(\"SHARE-FORK\", SHARED_FT_STR);\n\tjoin_idle_thread(pid);\n\n\tprintf(\"memfd: DONE\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}