{
  "module_name": "ftrace_test.c",
  "hash_id": "bb789e2477df41a5282a37c39c1b610d89497d6a6f5f63a381e29cf4633ee352",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/user_events/ftrace_test.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <linux/user_events.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <unistd.h>\n\n#include \"../kselftest_harness.h\"\n#include \"user_events_selftests.h\"\n\nconst char *data_file = \"/sys/kernel/tracing/user_events_data\";\nconst char *status_file = \"/sys/kernel/tracing/user_events_status\";\nconst char *enable_file = \"/sys/kernel/tracing/events/user_events/__test_event/enable\";\nconst char *trace_file = \"/sys/kernel/tracing/trace\";\nconst char *fmt_file = \"/sys/kernel/tracing/events/user_events/__test_event/format\";\n\nstatic int trace_bytes(void)\n{\n\tint fd = open(trace_file, O_RDONLY);\n\tchar buf[256];\n\tint bytes = 0, got;\n\n\tif (fd == -1)\n\t\treturn -1;\n\n\twhile (true) {\n\t\tgot = read(fd, buf, sizeof(buf));\n\n\t\tif (got == -1)\n\t\t\treturn -1;\n\n\t\tif (got == 0)\n\t\t\tbreak;\n\n\t\tbytes += got;\n\t}\n\n\tclose(fd);\n\n\treturn bytes;\n}\n\nstatic int skip_until_empty_line(FILE *fp)\n{\n\tint c, last = 0;\n\n\twhile (true) {\n\t\tc = getc(fp);\n\n\t\tif (c == EOF)\n\t\t\tbreak;\n\n\t\tif (last == '\\n' && c == '\\n')\n\t\t\treturn 0;\n\n\t\tlast = c;\n\t}\n\n\treturn -1;\n}\n\nstatic int get_print_fmt(char *buffer, int len)\n{\n\tFILE *fp = fopen(fmt_file, \"r\");\n\tchar *newline;\n\n\tif (!fp)\n\t\treturn -1;\n\n\t \n\tif (skip_until_empty_line(fp) < 0)\n\t\tgoto err;\n\n\t \n\tif (skip_until_empty_line(fp) < 0)\n\t\tgoto err;\n\n\t \n\tif (fgets(buffer, len, fp) == NULL)\n\t\tgoto err;\n\n\tnewline = strchr(buffer, '\\n');\n\n\tif (newline)\n\t\t*newline = '\\0';\n\n\tfclose(fp);\n\n\treturn 0;\nerr:\n\tfclose(fp);\n\n\treturn -1;\n}\n\nstatic bool wait_for_delete(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 1000; ++i) {\n\t\tint fd = open(enable_file, O_RDONLY);\n\n\t\tif (fd == -1)\n\t\t\treturn true;\n\n\t\tclose(fd);\n\t\tusleep(1000);\n\t}\n\n\treturn false;\n}\n\nstatic int clear(int *check)\n{\n\tstruct user_unreg unreg = {0};\n\tint fd;\n\n\tunreg.size = sizeof(unreg);\n\tunreg.disable_bit = 31;\n\tunreg.disable_addr = (__u64)check;\n\n\tfd = open(data_file, O_RDWR);\n\n\tif (fd == -1)\n\t\treturn -1;\n\n\tif (ioctl(fd, DIAG_IOCSUNREG, &unreg) == -1)\n\t\tif (errno != ENOENT)\n\t\t\tgoto fail;\n\n\tif (ioctl(fd, DIAG_IOCSDEL, \"__test_event\") == -1) {\n\t\tif (errno == EBUSY) {\n\t\t\tif (!wait_for_delete())\n\t\t\t\tgoto fail;\n\t\t} else if (errno != ENOENT)\n\t\t\tgoto fail;\n\t}\n\n\tclose(fd);\n\n\treturn 0;\nfail:\n\tclose(fd);\n\n\treturn -1;\n}\n\nstatic int check_print_fmt(const char *event, const char *expected, int *check)\n{\n\tstruct user_reg reg = {0};\n\tchar print_fmt[256];\n\tint ret;\n\tint fd;\n\n\t \n\tret = clear(check);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tfd = open(data_file, O_RDWR);\n\n\tif (fd == -1)\n\t\treturn fd;\n\n\treg.size = sizeof(reg);\n\treg.name_args = (__u64)event;\n\treg.enable_bit = 31;\n\treg.enable_addr = (__u64)check;\n\treg.enable_size = sizeof(*check);\n\n\t \n\tret = ioctl(fd, DIAG_IOCSREG, &reg);\n\n\tif (ret != 0) {\n\t\tclose(fd);\n\t\tprintf(\"Reg failed in fmt\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = get_print_fmt(print_fmt, sizeof(print_fmt));\n\n\tclose(fd);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn strcmp(print_fmt, expected);\n}\n\nFIXTURE(user) {\n\tint status_fd;\n\tint data_fd;\n\tint enable_fd;\n\tint check;\n\tbool umount;\n};\n\nFIXTURE_SETUP(user) {\n\tUSER_EVENT_FIXTURE_SETUP(return, self->umount);\n\n\tself->status_fd = open(status_file, O_RDONLY);\n\tASSERT_NE(-1, self->status_fd);\n\n\tself->data_fd = open(data_file, O_RDWR);\n\tASSERT_NE(-1, self->data_fd);\n\n\tself->enable_fd = -1;\n}\n\nFIXTURE_TEARDOWN(user) {\n\tUSER_EVENT_FIXTURE_TEARDOWN(self->umount);\n\n\tclose(self->status_fd);\n\tclose(self->data_fd);\n\n\tif (self->enable_fd != -1) {\n\t\twrite(self->enable_fd, \"0\", sizeof(\"0\"));\n\t\tclose(self->enable_fd);\n\t}\n\n\tif (clear(&self->check) != 0)\n\t\tprintf(\"WARNING: Clear didn't work!\\n\");\n}\n\nTEST_F(user, register_events) {\n\tstruct user_reg reg = {0};\n\tstruct user_unreg unreg = {0};\n\n\treg.size = sizeof(reg);\n\treg.name_args = (__u64)\"__test_event u32 field1; u32 field2\";\n\treg.enable_bit = 31;\n\treg.enable_addr = (__u64)&self->check;\n\treg.enable_size = sizeof(self->check);\n\n\tunreg.size = sizeof(unreg);\n\tunreg.disable_bit = 31;\n\tunreg.disable_addr = (__u64)&self->check;\n\n\t \n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(0, reg.write_index);\n\n\t \n\tASSERT_EQ(-1, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(EADDRINUSE, errno);\n\n\t \n\treg.enable_bit = 30;\n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(0, reg.write_index);\n\n\t \n\treg.enable_bit = 29;\n\treg.name_args = (__u64)\"__test_event u32 field1;\";\n\tASSERT_EQ(-1, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(EADDRINUSE, errno);\n\n\t \n\tself->enable_fd = open(enable_file, O_RDWR);\n\tASSERT_NE(-1, self->enable_fd);\n\tASSERT_NE(-1, write(self->enable_fd, \"0\", sizeof(\"0\")))\n\n\t \n\tASSERT_NE(-1, write(self->enable_fd, \"1\", sizeof(\"1\")))\n\tASSERT_EQ(1 << reg.enable_bit, self->check);\n\n\t \n\tASSERT_NE(-1, write(self->enable_fd, \"0\", sizeof(\"0\")))\n\tASSERT_EQ(0, self->check);\n\n\t \n\tASSERT_EQ(-1, ioctl(self->data_fd, DIAG_IOCSDEL, \"__test_event\"));\n\tASSERT_EQ(EBUSY, errno);\n\n\t \n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSUNREG, &unreg));\n\tunreg.disable_bit = 30;\n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSUNREG, &unreg));\n\n\t \n\tclose(self->data_fd);\n\n\tASSERT_EQ(true, wait_for_delete());\n}\n\nTEST_F(user, write_events) {\n\tstruct user_reg reg = {0};\n\tstruct iovec io[3];\n\t__u32 field1, field2;\n\tint before = 0, after = 0;\n\n\treg.size = sizeof(reg);\n\treg.name_args = (__u64)\"__test_event u32 field1; u32 field2\";\n\treg.enable_bit = 31;\n\treg.enable_addr = (__u64)&self->check;\n\treg.enable_size = sizeof(self->check);\n\n\tfield1 = 1;\n\tfield2 = 2;\n\n\tio[0].iov_base = &reg.write_index;\n\tio[0].iov_len = sizeof(reg.write_index);\n\tio[1].iov_base = &field1;\n\tio[1].iov_len = sizeof(field1);\n\tio[2].iov_base = &field2;\n\tio[2].iov_len = sizeof(field2);\n\n\t \n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(0, reg.write_index);\n\tASSERT_EQ(0, self->check);\n\n\t \n\tio[0].iov_base = &field2;\n\tio[0].iov_len = sizeof(field2);\n\tASSERT_EQ(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tASSERT_EQ(ENOENT, errno);\n\tio[0].iov_base = &reg.write_index;\n\tio[0].iov_len = sizeof(reg.write_index);\n\n\t \n\tASSERT_EQ(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tASSERT_EQ(EBADF, errno);\n\n\t \n\tself->enable_fd = open(enable_file, O_RDWR);\n\tASSERT_NE(-1, write(self->enable_fd, \"1\", sizeof(\"1\")))\n\n\t \n\tASSERT_NE(1 << reg.enable_bit, self->check);\n\n\t \n\tbefore = trace_bytes();\n\tASSERT_NE(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tafter = trace_bytes();\n\tASSERT_GT(after, before);\n\n\t \n\treg.write_index = -1;\n\tASSERT_EQ(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tASSERT_EQ(EINVAL, errno);\n}\n\nTEST_F(user, write_empty_events) {\n\tstruct user_reg reg = {0};\n\tstruct iovec io[1];\n\tint before = 0, after = 0;\n\n\treg.size = sizeof(reg);\n\treg.name_args = (__u64)\"__test_event\";\n\treg.enable_bit = 31;\n\treg.enable_addr = (__u64)&self->check;\n\treg.enable_size = sizeof(self->check);\n\n\tio[0].iov_base = &reg.write_index;\n\tio[0].iov_len = sizeof(reg.write_index);\n\n\t \n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(0, reg.write_index);\n\tASSERT_EQ(0, self->check);\n\n\t \n\tself->enable_fd = open(enable_file, O_RDWR);\n\tASSERT_NE(-1, write(self->enable_fd, \"1\", sizeof(\"1\")))\n\n\t \n\tASSERT_EQ(1 << reg.enable_bit, self->check);\n\n\t \n\tbefore = trace_bytes();\n\tASSERT_NE(-1, writev(self->data_fd, (const struct iovec *)io, 1));\n\tafter = trace_bytes();\n\tASSERT_GT(after, before);\n}\n\nTEST_F(user, write_fault) {\n\tstruct user_reg reg = {0};\n\tstruct iovec io[2];\n\tint l = sizeof(__u64);\n\tvoid *anon;\n\n\treg.size = sizeof(reg);\n\treg.name_args = (__u64)\"__test_event u64 anon\";\n\treg.enable_bit = 31;\n\treg.enable_addr = (__u64)&self->check;\n\treg.enable_size = sizeof(self->check);\n\n\tanon = mmap(NULL, l, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tASSERT_NE(MAP_FAILED, anon);\n\n\tio[0].iov_base = &reg.write_index;\n\tio[0].iov_len = sizeof(reg.write_index);\n\tio[1].iov_base = anon;\n\tio[1].iov_len = l;\n\n\t \n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(0, reg.write_index);\n\n\t \n\tself->enable_fd = open(enable_file, O_RDWR);\n\tASSERT_NE(-1, write(self->enable_fd, \"1\", sizeof(\"1\")))\n\n\t \n\tASSERT_NE(-1, writev(self->data_fd, (const struct iovec *)io, 2));\n\n\t \n\tASSERT_EQ(0, madvise(anon, l, MADV_DONTNEED));\n\tASSERT_NE(-1, writev(self->data_fd, (const struct iovec *)io, 2));\n\tASSERT_EQ(0, munmap(anon, l));\n}\n\nTEST_F(user, write_validator) {\n\tstruct user_reg reg = {0};\n\tstruct iovec io[3];\n\tint loc, bytes;\n\tchar data[8];\n\tint before = 0, after = 0;\n\n\treg.size = sizeof(reg);\n\treg.name_args = (__u64)\"__test_event __rel_loc char[] data\";\n\treg.enable_bit = 31;\n\treg.enable_addr = (__u64)&self->check;\n\treg.enable_size = sizeof(self->check);\n\n\t \n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(0, reg.write_index);\n\tASSERT_EQ(0, self->check);\n\n\tio[0].iov_base = &reg.write_index;\n\tio[0].iov_len = sizeof(reg.write_index);\n\tio[1].iov_base = &loc;\n\tio[1].iov_len = sizeof(loc);\n\tio[2].iov_base = data;\n\tbytes = snprintf(data, sizeof(data), \"Test\") + 1;\n\tio[2].iov_len = bytes;\n\n\t \n\tASSERT_EQ(-1, writev(self->data_fd, (const struct iovec *)io, 1));\n\tASSERT_EQ(EINVAL, errno);\n\n\t \n\tself->enable_fd = open(enable_file, O_RDWR);\n\tASSERT_NE(-1, write(self->enable_fd, \"1\", sizeof(\"1\")))\n\n\t \n\tASSERT_EQ(1 << reg.enable_bit, self->check);\n\n\t \n\tbefore = trace_bytes();\n\tloc = DYN_LOC(0, bytes);\n\tASSERT_NE(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tafter = trace_bytes();\n\tASSERT_GT(after, before);\n\n\t \n\tloc = DYN_LOC(1024, bytes);\n\tASSERT_EQ(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tASSERT_EQ(EFAULT, errno);\n\n\t \n\tloc = DYN_LOC(1, bytes);\n\tASSERT_EQ(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tASSERT_EQ(EFAULT, errno);\n\n\t \n\tloc = DYN_LOC(0, bytes + 1024);\n\tASSERT_EQ(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tASSERT_EQ(EFAULT, errno);\n\n\t \n\tloc = DYN_LOC(0, bytes + 1);\n\tASSERT_EQ(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tASSERT_EQ(EFAULT, errno);\n\n\t \n\tmemset(data, 'A', sizeof(data));\n\tloc = DYN_LOC(0, bytes);\n\tASSERT_EQ(-1, writev(self->data_fd, (const struct iovec *)io, 3));\n\tASSERT_EQ(EFAULT, errno);\n}\n\nTEST_F(user, print_fmt) {\n\tint ret;\n\n\tret = check_print_fmt(\"__test_event __rel_loc char[] data\",\n\t\t\t      \"print fmt: \\\"data=%s\\\", __get_rel_str(data)\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event __data_loc char[] data\",\n\t\t\t      \"print fmt: \\\"data=%s\\\", __get_str(data)\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event s64 data\",\n\t\t\t      \"print fmt: \\\"data=%lld\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event u64 data\",\n\t\t\t      \"print fmt: \\\"data=%llu\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event s32 data\",\n\t\t\t      \"print fmt: \\\"data=%d\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event u32 data\",\n\t\t\t      \"print fmt: \\\"data=%u\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event int data\",\n\t\t\t      \"print fmt: \\\"data=%d\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event unsigned int data\",\n\t\t\t      \"print fmt: \\\"data=%u\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event s16 data\",\n\t\t\t      \"print fmt: \\\"data=%d\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event u16 data\",\n\t\t\t      \"print fmt: \\\"data=%u\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event short data\",\n\t\t\t      \"print fmt: \\\"data=%d\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event unsigned short data\",\n\t\t\t      \"print fmt: \\\"data=%u\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event s8 data\",\n\t\t\t      \"print fmt: \\\"data=%d\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event u8 data\",\n\t\t\t      \"print fmt: \\\"data=%u\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event char data\",\n\t\t\t      \"print fmt: \\\"data=%d\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event unsigned char data\",\n\t\t\t      \"print fmt: \\\"data=%u\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n\n\tret = check_print_fmt(\"__test_event char[4] data\",\n\t\t\t      \"print fmt: \\\"data=%s\\\", REC->data\",\n\t\t\t      &self->check);\n\tASSERT_EQ(0, ret);\n}\n\nint main(int argc, char **argv)\n{\n\treturn test_harness_run(argc, argv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}