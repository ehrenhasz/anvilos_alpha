{
  "module_name": "abi_test.c",
  "hash_id": "a1f8ef6d0006f95d5af0e6505269d0bac4fd13aa8feeefa287163001b84ffaba",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/user_events/abi_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <sched.h>\n\n#include <errno.h>\n#include <linux/user_events.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <asm/unistd.h>\n\n#include \"../kselftest_harness.h\"\n#include \"user_events_selftests.h\"\n\nconst char *data_file = \"/sys/kernel/tracing/user_events_data\";\nconst char *enable_file = \"/sys/kernel/tracing/events/user_events/__abi_event/enable\";\n\nstatic int change_event(bool enable)\n{\n\tint fd = open(enable_file, O_RDWR);\n\tint ret;\n\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (enable)\n\t\tret = write(fd, \"1\", 1);\n\telse\n\t\tret = write(fd, \"0\", 1);\n\n\tclose(fd);\n\n\tif (ret == 1)\n\t\tret = 0;\n\telse\n\t\tret = -1;\n\n\treturn ret;\n}\n\nstatic int reg_enable(void *enable, int size, int bit)\n{\n\tstruct user_reg reg = {0};\n\tint fd = open(data_file, O_RDWR);\n\tint ret;\n\n\tif (fd < 0)\n\t\treturn -1;\n\n\treg.size = sizeof(reg);\n\treg.name_args = (__u64)\"__abi_event\";\n\treg.enable_bit = bit;\n\treg.enable_addr = (__u64)enable;\n\treg.enable_size = size;\n\n\tret = ioctl(fd, DIAG_IOCSREG, &reg);\n\n\tclose(fd);\n\n\treturn ret;\n}\n\nstatic int reg_disable(void *enable, int bit)\n{\n\tstruct user_unreg reg = {0};\n\tint fd = open(data_file, O_RDWR);\n\tint ret;\n\n\tif (fd < 0)\n\t\treturn -1;\n\n\treg.size = sizeof(reg);\n\treg.disable_bit = bit;\n\treg.disable_addr = (__u64)enable;\n\n\tret = ioctl(fd, DIAG_IOCSUNREG, &reg);\n\n\tclose(fd);\n\n\treturn ret;\n}\n\nFIXTURE(user) {\n\tint check;\n\tlong check_long;\n\tbool umount;\n};\n\nFIXTURE_SETUP(user) {\n\tUSER_EVENT_FIXTURE_SETUP(return, self->umount);\n\n\tchange_event(false);\n\tself->check = 0;\n\tself->check_long = 0;\n}\n\nFIXTURE_TEARDOWN(user) {\n\tUSER_EVENT_FIXTURE_TEARDOWN(self->umount);\n}\n\nTEST_F(user, enablement) {\n\t \n\tASSERT_EQ(0, self->check);\n\tASSERT_EQ(0, reg_enable(&self->check, sizeof(int), 0));\n\tASSERT_EQ(0, change_event(true));\n\tASSERT_EQ(1, self->check);\n\tASSERT_EQ(0, change_event(false));\n\tASSERT_EQ(0, self->check);\n\n\t \n\tASSERT_EQ(0, change_event(true));\n\tASSERT_EQ(1, self->check);\n\tASSERT_EQ(0, reg_disable(&self->check, 0));\n\tASSERT_EQ(0, self->check);\n\n\t \n\tASSERT_EQ(0, change_event(true));\n\tASSERT_EQ(0, self->check);\n\tASSERT_EQ(0, change_event(false));\n}\n\nTEST_F(user, bit_sizes) {\n\t \n\tASSERT_EQ(0, reg_enable(&self->check, sizeof(int), 0));\n\tASSERT_EQ(0, reg_enable(&self->check, sizeof(int), 31));\n\tASSERT_NE(0, reg_enable(&self->check, sizeof(int), 32));\n\tASSERT_EQ(0, reg_disable(&self->check, 0));\n\tASSERT_EQ(0, reg_disable(&self->check, 31));\n\n#if BITS_PER_LONG == 8\n\t \n\tASSERT_EQ(0, reg_enable(&self->check_long, sizeof(long), 63));\n\tASSERT_NE(0, reg_enable(&self->check_long, sizeof(long), 64));\n\tASSERT_EQ(0, reg_disable(&self->check_long, 63));\n#endif\n\n\t \n\tASSERT_NE(0, reg_enable(&self->check, 1, 0));\n\tASSERT_NE(0, reg_enable(&self->check, 2, 0));\n\tASSERT_NE(0, reg_enable(&self->check, 3, 0));\n\tASSERT_NE(0, reg_enable(&self->check, 5, 0));\n\tASSERT_NE(0, reg_enable(&self->check, 6, 0));\n\tASSERT_NE(0, reg_enable(&self->check, 7, 0));\n\tASSERT_NE(0, reg_enable(&self->check, 9, 0));\n\tASSERT_NE(0, reg_enable(&self->check, 128, 0));\n}\n\nTEST_F(user, forks) {\n\tint i;\n\n\t \n\tASSERT_EQ(0, reg_enable(&self->check, sizeof(int), 0));\n\tASSERT_EQ(0, self->check);\n\n\tif (fork() == 0) {\n\t\t \n\t\tself->check = 0;\n\n\t\t \n\t\tfor (i = 0; i < 10; ++i) {\n\t\t\tusleep(100000);\n\n\t\t\tif (self->check)\n\t\t\t\texit(0);\n\t\t}\n\n\t\texit(1);\n\t}\n\n\t \n\tusleep(100000);\n\tASSERT_EQ(0, change_event(true));\n\n\tASSERT_NE(-1, wait(&i));\n\tASSERT_EQ(0, WEXITSTATUS(i));\n\n\t \n\tif (fork() == 0)\n\t\texit(reg_disable(&self->check, 0));\n\n\tASSERT_NE(-1, wait(&i));\n\tASSERT_EQ(0, WEXITSTATUS(i));\n\tASSERT_EQ(1, self->check);\n\tASSERT_EQ(0, change_event(false));\n\tASSERT_EQ(0, self->check);\n}\n\n \nstatic int clone_check(void *check)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tusleep(100000);\n\n\t\tif (*(int *)check)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nTEST_F(user, clones) {\n\tint i, stack_size = 4096;\n\tvoid *stack = mmap(NULL, stack_size, PROT_READ | PROT_WRITE,\n\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK,\n\t\t\t   -1, 0);\n\n\tASSERT_NE(MAP_FAILED, stack);\n\tASSERT_EQ(0, reg_enable(&self->check, sizeof(int), 0));\n\tASSERT_EQ(0, self->check);\n\n\t \n\tASSERT_NE(-1, clone(&clone_check, stack + stack_size,\n\t\t\t    CLONE_VM | SIGCHLD, &self->check));\n\n\tASSERT_EQ(0, change_event(true));\n\tASSERT_NE(-1, wait(&i));\n\tASSERT_EQ(0, WEXITSTATUS(i));\n\tmunmap(stack, stack_size);\n\tASSERT_EQ(0, change_event(false));\n}\n\nint main(int argc, char **argv)\n{\n\treturn test_harness_run(argc, argv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}