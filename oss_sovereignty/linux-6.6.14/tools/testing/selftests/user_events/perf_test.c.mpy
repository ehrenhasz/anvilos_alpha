{
  "module_name": "perf_test.c",
  "hash_id": "c9ba4a9419b523fa2e6b74670986034b9a06c53a0000682022cf5dab1bcf8a8c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/user_events/perf_test.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <linux/user_events.h>\n#include <linux/perf_event.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <asm/unistd.h>\n\n#include \"../kselftest_harness.h\"\n#include \"user_events_selftests.h\"\n\nconst char *data_file = \"/sys/kernel/tracing/user_events_data\";\nconst char *id_file = \"/sys/kernel/tracing/events/user_events/__test_event/id\";\nconst char *fmt_file = \"/sys/kernel/tracing/events/user_events/__test_event/format\";\n\nstruct event {\n\t__u32 index;\n\t__u32 field1;\n\t__u32 field2;\n};\n\nstatic long perf_event_open(struct perf_event_attr *pe, pid_t pid,\n\t\t\t    int cpu, int group_fd, unsigned long flags)\n{\n\treturn syscall(__NR_perf_event_open, pe, pid, cpu, group_fd, flags);\n}\n\nstatic int get_id(void)\n{\n\tFILE *fp = fopen(id_file, \"r\");\n\tint ret, id = 0;\n\n\tif (!fp)\n\t\treturn -1;\n\n\tret = fscanf(fp, \"%d\", &id);\n\tfclose(fp);\n\n\tif (ret != 1)\n\t\treturn -1;\n\n\treturn id;\n}\n\nstatic int get_offset(void)\n{\n\tFILE *fp = fopen(fmt_file, \"r\");\n\tint ret, c, last = 0, offset = 0;\n\n\tif (!fp)\n\t\treturn -1;\n\n\t \n\twhile (true) {\n\t\tc = getc(fp);\n\n\t\tif (c == EOF)\n\t\t\tbreak;\n\n\t\tif (last == '\\n' && c == '\\n')\n\t\t\tbreak;\n\n\t\tlast = c;\n\t}\n\n\tret = fscanf(fp, \"\\tfield:u32 field1;\\toffset:%d;\", &offset);\n\tfclose(fp);\n\n\tif (ret != 1)\n\t\treturn -1;\n\n\treturn offset;\n}\n\nstatic int clear(int *check)\n{\n\tstruct user_unreg unreg = {0};\n\n\tunreg.size = sizeof(unreg);\n\tunreg.disable_bit = 31;\n\tunreg.disable_addr = (__u64)check;\n\n\tint fd = open(data_file, O_RDWR);\n\n\tif (fd == -1)\n\t\treturn -1;\n\n\tif (ioctl(fd, DIAG_IOCSUNREG, &unreg) == -1)\n\t\tif (errno != ENOENT)\n\t\t\treturn -1;\n\n\tif (ioctl(fd, DIAG_IOCSDEL, \"__test_event\") == -1)\n\t\tif (errno != ENOENT)\n\t\t\treturn -1;\n\n\tclose(fd);\n\n\treturn 0;\n}\n\nFIXTURE(user) {\n\tint data_fd;\n\tint check;\n\tbool umount;\n};\n\nFIXTURE_SETUP(user) {\n\tUSER_EVENT_FIXTURE_SETUP(return, self->umount);\n\n\tself->data_fd = open(data_file, O_RDWR);\n\tASSERT_NE(-1, self->data_fd);\n}\n\nFIXTURE_TEARDOWN(user) {\n\tUSER_EVENT_FIXTURE_TEARDOWN(self->umount);\n\n\tclose(self->data_fd);\n\n\tif (clear(&self->check) != 0)\n\t\tprintf(\"WARNING: Clear didn't work!\\n\");\n}\n\nTEST_F(user, perf_write) {\n\tstruct perf_event_attr pe = {0};\n\tstruct user_reg reg = {0};\n\tstruct event event;\n\tstruct perf_event_mmap_page *perf_page;\n\tint page_size = sysconf(_SC_PAGESIZE);\n\tint id, fd, offset;\n\t__u32 *val;\n\n\treg.size = sizeof(reg);\n\treg.name_args = (__u64)\"__test_event u32 field1; u32 field2\";\n\treg.enable_bit = 31;\n\treg.enable_addr = (__u64)&self->check;\n\treg.enable_size = sizeof(self->check);\n\n\t \n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(0, reg.write_index);\n\tASSERT_EQ(0, self->check);\n\n\t \n\tid = get_id();\n\tASSERT_NE(-1, id);\n\toffset = get_offset();\n\tASSERT_NE(-1, offset);\n\n\tpe.type = PERF_TYPE_TRACEPOINT;\n\tpe.size = sizeof(pe);\n\tpe.config = id;\n\tpe.sample_type = PERF_SAMPLE_RAW;\n\tpe.sample_period = 1;\n\tpe.wakeup_events = 1;\n\n\t \n\tfd = perf_event_open(&pe, 0, -1, -1, 0);\n\tASSERT_NE(-1, fd);\n\n\tperf_page = mmap(NULL, page_size * 2, PROT_READ, MAP_SHARED, fd, 0);\n\tASSERT_NE(MAP_FAILED, perf_page);\n\n\t \n\tASSERT_EQ(1 << reg.enable_bit, self->check);\n\n\tevent.index = reg.write_index;\n\tevent.field1 = 0xc001;\n\tevent.field2 = 0xc01a;\n\n\t \n\tASSERT_NE(-1, write(self->data_fd, &event, sizeof(event)));\n\tval = (void *)(((char *)perf_page) + perf_page->data_offset);\n\tASSERT_EQ(PERF_RECORD_SAMPLE, *val);\n\t \n\tval += 3;\n\tval = (void *)((char *)val) + offset;\n\t \n\tASSERT_EQ(event.field1, *val++);\n\tASSERT_EQ(event.field2, *val++);\n\n\tmunmap(perf_page, page_size * 2);\n\tclose(fd);\n\n\t \n\tASSERT_EQ(0, self->check);\n}\n\nTEST_F(user, perf_empty_events) {\n\tstruct perf_event_attr pe = {0};\n\tstruct user_reg reg = {0};\n\tstruct perf_event_mmap_page *perf_page;\n\tint page_size = sysconf(_SC_PAGESIZE);\n\tint id, fd;\n\t__u32 *val;\n\n\treg.size = sizeof(reg);\n\treg.name_args = (__u64)\"__test_event\";\n\treg.enable_bit = 31;\n\treg.enable_addr = (__u64)&self->check;\n\treg.enable_size = sizeof(self->check);\n\n\t \n\tASSERT_EQ(0, ioctl(self->data_fd, DIAG_IOCSREG, &reg));\n\tASSERT_EQ(0, reg.write_index);\n\tASSERT_EQ(0, self->check);\n\n\t \n\tid = get_id();\n\tASSERT_NE(-1, id);\n\n\tpe.type = PERF_TYPE_TRACEPOINT;\n\tpe.size = sizeof(pe);\n\tpe.config = id;\n\tpe.sample_type = PERF_SAMPLE_RAW;\n\tpe.sample_period = 1;\n\tpe.wakeup_events = 1;\n\n\t \n\tfd = perf_event_open(&pe, 0, -1, -1, 0);\n\tASSERT_NE(-1, fd);\n\n\tperf_page = mmap(NULL, page_size * 2, PROT_READ, MAP_SHARED, fd, 0);\n\tASSERT_NE(MAP_FAILED, perf_page);\n\n\t \n\tASSERT_EQ(1 << reg.enable_bit, self->check);\n\n\t \n\tASSERT_NE(-1, write(self->data_fd, &reg.write_index,\n\t\t\t\t\tsizeof(reg.write_index)));\n\tval = (void *)(((char *)perf_page) + perf_page->data_offset);\n\tASSERT_EQ(PERF_RECORD_SAMPLE, *val);\n\n\tmunmap(perf_page, page_size * 2);\n\tclose(fd);\n\n\t \n\tASSERT_EQ(0, self->check);\n}\n\nint main(int argc, char **argv)\n{\n\treturn test_harness_run(argc, argv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}