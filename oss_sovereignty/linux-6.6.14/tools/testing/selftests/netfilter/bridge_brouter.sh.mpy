{
  "module_name": "bridge_brouter.sh",
  "hash_id": "66fa54a6fa805cd38a5da70da1d64c00d0f526970e2e5d1d26af820f7853dc70",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/bridge_brouter.sh",
  "human_readable_source": "#!/bin/bash\n#\n# This test is for bridge 'brouting', i.e. make some packets being routed\n# rather than getting bridged even though they arrive on interface that is\n# part of a bridge.\n\n#           eth0    br0     eth0\n# setup is: ns1 <-> ns0 <-> ns2\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nret=0\n\nebtables -V > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ebtables\"\n\texit $ksft_skip\nfi\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nip netns add ns0\nip netns add ns1\nip netns add ns2\n\nip link add veth0 netns ns0 type veth peer name eth0 netns ns1\nif [ $? -ne 0 ]; then\n\techo \"SKIP: Can't create veth device\"\n\texit $ksft_skip\nfi\nip link add veth1 netns ns0 type veth peer name eth0 netns ns2\n\nip -net ns0 link set lo up\nip -net ns0 link set veth0 up\nip -net ns0 link set veth1 up\n\nip -net ns0 link add br0 type bridge\nif [ $? -ne 0 ]; then\n\techo \"SKIP: Can't create bridge br0\"\n\texit $ksft_skip\nfi\n\nip -net ns0 link set veth0 master br0\nip -net ns0 link set veth1 master br0\nip -net ns0 link set br0 up\nip -net ns0 addr add 10.0.0.1/24 dev br0\n\n# place both in same subnet, ns1 and ns2 connected via ns0:br0\nfor i in 1 2; do\n  ip -net ns$i link set lo up\n  ip -net ns$i link set eth0 up\n  ip -net ns$i addr add 10.0.0.1$i/24 dev eth0\ndone\n\ntest_ebtables_broute()\n{\n\tlocal cipt\n\n\t# redirect is needed so the dstmac is rewritten to the bridge itself,\n\t# ip stack won't process OTHERHOST (foreign unicast mac) packets.\n\tip netns exec ns0 ebtables -t broute -A BROUTING -p ipv4 --ip-protocol icmp -j redirect --redirect-target=DROP\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: Could not add ebtables broute redirect rule\"\n\t\treturn $ksft_skip\n\tfi\n\n\t# ping netns1, expected to not work (ip forwarding is off)\n\tip netns exec ns1 ping -q -c 1 10.0.0.12 > /dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\techo \"ERROR: ping works, should have failed\" 1>&2\n\t\treturn 1\n\tfi\n\n\t# enable forwarding on both interfaces.\n\t# neither needs an ip address, but at least the bridge needs\n\t# an ip address in same network segment as ns1 and ns2 (ns0\n\t# needs to be able to determine route for to-be-forwarded packet).\n\tip netns exec ns0 sysctl -q net.ipv4.conf.veth0.forwarding=1\n\tip netns exec ns0 sysctl -q net.ipv4.conf.veth1.forwarding=1\n\n\tsleep 1\n\n\tip netns exec ns1 ping -q -c 1 10.0.0.12 > /dev/null\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: ping did not work, but it should (broute+forward)\" 1>&2\n\t\treturn 1\n\tfi\n\n\techo \"PASS: ns1/ns2 connectivity with active broute rule\"\n\tip netns exec ns0 ebtables -t broute -F\n\n\t# ping netns1, expected to work (frames are bridged)\n\tip netns exec ns1 ping -q -c 1 10.0.0.12 > /dev/null\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: ping did not work, but it should (bridged)\" 1>&2\n\t\treturn 1\n\tfi\n\n\tip netns exec ns0 ebtables -t filter -A FORWARD -p ipv4 --ip-protocol icmp -j DROP\n\n\t# ping netns1, expected to not work (DROP in bridge forward)\n\tip netns exec ns1 ping -q -c 1 10.0.0.12 > /dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\techo \"ERROR: ping works, should have failed (icmp forward drop)\" 1>&2\n\t\treturn 1\n\tfi\n\n\t# re-activate brouter\n\tip netns exec ns0 ebtables -t broute -A BROUTING -p ipv4 --ip-protocol icmp -j redirect --redirect-target=DROP\n\n\tip netns exec ns2 ping -q -c 1 10.0.0.11 > /dev/null\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: ping did not work, but it should (broute+forward 2)\" 1>&2\n\t\treturn 1\n\tfi\n\n\techo \"PASS: ns1/ns2 connectivity with active broute rule and bridge forward drop\"\n\treturn 0\n}\n\n# test basic connectivity\nip netns exec ns1 ping -c 1 -q 10.0.0.12 > /dev/null\nif [ $? -ne 0 ]; then\n    echo \"ERROR: Could not reach ns2 from ns1\" 1>&2\n    ret=1\nfi\n\nip netns exec ns2 ping -c 1 -q 10.0.0.11 > /dev/null\nif [ $? -ne 0 ]; then\n    echo \"ERROR: Could not reach ns1 from ns2\" 1>&2\n    ret=1\nfi\n\nif [ $ret -eq 0 ];then\n    echo \"PASS: netns connectivity: ns1 and ns2 can reach each other\"\nfi\n\ntest_ebtables_broute\nret=$?\nfor i in 0 1 2; do ip netns del ns$i;done\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}