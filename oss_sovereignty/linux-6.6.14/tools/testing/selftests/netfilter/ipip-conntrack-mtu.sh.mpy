{
  "module_name": "ipip-conntrack-mtu.sh",
  "hash_id": "7a777ea626c0c54cc03187b757ecff83ba589261b78345aa03626c3f117b5829",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/ipip-conntrack-mtu.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\n# Conntrack needs to reassemble fragments in order to have complete\n# packets for rule matching.  Reassembly can lead to packet loss.\n\n# Consider the following setup:\n#            +--------+       +---------+       +--------+\n#            |Router A|-------|Wanrouter|-------|Router B|\n#            |        |.IPIP..|         |..IPIP.|        |\n#            +--------+       +---------+       +--------+\n#           /                  mtu 1400                   \\\n#          /                                               \\\n#+--------+                                                 +--------+\n#|Client A|                                                 |Client B|\n#|        |                                                 |        |\n#+--------+                                                 +--------+\n\n# Router A and Router B use IPIP tunnel interfaces to tunnel traffic\n# between Client A and Client B over WAN. Wanrouter has MTU 1400 set\n# on its interfaces.\n\nrnd=$(mktemp -u XXXXXXXX)\nrx=$(mktemp)\n\nr_a=\"ns-ra-$rnd\"\nr_b=\"ns-rb-$rnd\"\nr_w=\"ns-rw-$rnd\"\nc_a=\"ns-ca-$rnd\"\nc_b=\"ns-cb-$rnd\"\n\nchecktool (){\n\tif ! $1 > /dev/null 2>&1; then\n\t\techo \"SKIP: Could not $2\"\n\t\texit $ksft_skip\n\tfi\n}\n\nchecktool \"iptables --version\" \"run test without iptables\"\nchecktool \"ip -Version\" \"run test without ip tool\"\nchecktool \"which socat\" \"run test without socat\"\nchecktool \"ip netns add ${r_a}\" \"create net namespace\"\n\nfor n in ${r_b} ${r_w} ${c_a} ${c_b};do\n\tip netns add ${n}\ndone\n\ncleanup() {\n\tfor n in ${r_a} ${r_b} ${r_w} ${c_a} ${c_b};do\n\t\tip netns del ${n}\n\tdone\n\trm -f ${rx}\n}\n\ntrap cleanup EXIT\n\ntest_path() {\n\tmsg=\"$1\"\n\n\tip netns exec ${c_b} socat -t 3 - udp4-listen:5000,reuseaddr > ${rx} < /dev/null &\n\n\tsleep 1\n\tfor i in 1 2 3; do\n\t\thead -c1400 /dev/zero | tr \"\\000\" \"a\" | \\\n\t\t\tip netns exec ${c_a} socat -t 1 -u STDIN UDP:192.168.20.2:5000\n\tdone\n\n\twait\n\n\tbytes=$(wc -c < ${rx})\n\n\tif [ $bytes -eq 1400 ];then\n\t\techo \"OK: PMTU $msg connection tracking\"\n\telse\n\t\techo \"FAIL: PMTU $msg connection tracking: got $bytes, expected 1400\"\n\t\texit 1\n\tfi\n}\n\n# Detailed setup for Router A\n# ---------------------------\n# Interfaces:\n# eth0: 10.2.2.1/24\n# eth1: 192.168.10.1/24\n# ipip0: No IP address, local 10.2.2.1 remote 10.4.4.1\n# Routes:\n# 192.168.20.0/24 dev ipip0    (192.168.20.0/24 is subnet of Client B)\n# 10.4.4.1 via 10.2.2.254      (Router B via Wanrouter)\n# No iptables rules at all.\n\nip link add veth0 netns ${r_a} type veth peer name veth0 netns ${r_w}\nip link add veth1 netns ${r_a} type veth peer name veth0 netns ${c_a}\n\nl_addr=\"10.2.2.1\"\nr_addr=\"10.4.4.1\"\nip netns exec ${r_a} ip link add ipip0 type ipip local ${l_addr} remote ${r_addr} mode ipip || exit $ksft_skip\n\nfor dev in lo veth0 veth1 ipip0; do\n    ip -net ${r_a} link set $dev up\ndone\n\nip -net ${r_a} addr add 10.2.2.1/24 dev veth0\nip -net ${r_a} addr add 192.168.10.1/24 dev veth1\n\nip -net ${r_a} route add 192.168.20.0/24 dev ipip0\nip -net ${r_a} route add 10.4.4.0/24 via 10.2.2.254\n\nip netns exec ${r_a} sysctl -q net.ipv4.conf.all.forwarding=1 > /dev/null\n\n# Detailed setup for Router B\n# ---------------------------\n# Interfaces:\n# eth0: 10.4.4.1/24\n# eth1: 192.168.20.1/24\n# ipip0: No IP address, local 10.4.4.1 remote 10.2.2.1\n# Routes:\n# 192.168.10.0/24 dev ipip0    (192.168.10.0/24 is subnet of Client A)\n# 10.2.2.1 via 10.4.4.254      (Router A via Wanrouter)\n# No iptables rules at all.\n\nip link add veth0 netns ${r_b} type veth peer name veth1 netns ${r_w}\nip link add veth1 netns ${r_b} type veth peer name veth0 netns ${c_b}\n\nl_addr=\"10.4.4.1\"\nr_addr=\"10.2.2.1\"\n\nip netns exec ${r_b} ip link add ipip0 type ipip local ${l_addr} remote ${r_addr} mode ipip || exit $ksft_skip\n\nfor dev in lo veth0 veth1 ipip0; do\n\tip -net ${r_b} link set $dev up\ndone\n\nip -net ${r_b} addr add 10.4.4.1/24 dev veth0\nip -net ${r_b} addr add 192.168.20.1/24 dev veth1\n\nip -net ${r_b} route add 192.168.10.0/24 dev ipip0\nip -net ${r_b} route add 10.2.2.0/24 via 10.4.4.254\nip netns exec ${r_b} sysctl -q net.ipv4.conf.all.forwarding=1 > /dev/null\n\n# Client A\nip -net ${c_a} addr add 192.168.10.2/24 dev veth0\nip -net ${c_a} link set dev lo up\nip -net ${c_a} link set dev veth0 up\nip -net ${c_a} route add default via 192.168.10.1\n\n# Client A\nip -net ${c_b} addr add 192.168.20.2/24 dev veth0\nip -net ${c_b} link set dev veth0 up\nip -net ${c_b} link set dev lo up\nip -net ${c_b} route add default via 192.168.20.1\n\n# Wan\nip -net ${r_w} addr add 10.2.2.254/24 dev veth0\nip -net ${r_w} addr add 10.4.4.254/24 dev veth1\n\nip -net ${r_w} link set dev lo up\nip -net ${r_w} link set dev veth0 up mtu 1400\nip -net ${r_w} link set dev veth1 up mtu 1400\n\nip -net ${r_a} link set dev veth0 mtu 1400\nip -net ${r_b} link set dev veth0 mtu 1400\n\nip netns exec ${r_w} sysctl -q net.ipv4.conf.all.forwarding=1 > /dev/null\n\n# Path MTU discovery\n# ------------------\n# Running tracepath from Client A to Client B shows PMTU discovery is working\n# as expected:\n#\n# clienta:~# tracepath 192.168.20.2\n# 1?: [LOCALHOST]                      pmtu 1500\n# 1:  192.168.10.1                                          0.867ms\n# 1:  192.168.10.1                                          0.302ms\n# 2:  192.168.10.1                                          0.312ms pmtu 1480\n# 2:  no reply\n# 3:  192.168.10.1                                          0.510ms pmtu 1380\n# 3:  192.168.20.2                                          2.320ms reached\n# Resume: pmtu 1380 hops 3 back 3\n\n# ip netns exec ${c_a} traceroute --mtu 192.168.20.2\n\n# Router A has learned PMTU (1400) to Router B from Wanrouter.\n# Client A has learned PMTU (1400 - IPIP overhead = 1380) to Client B\n# from Router A.\n\n#Send large UDP packet\n#---------------------\n#Now we send a 1400 bytes UDP packet from Client A to Client B:\n\n# clienta:~# head -c1400 /dev/zero | tr \"\\000\" \"a\" | socat -u STDIN UDP:192.168.20.2:5000\ntest_path \"without\"\n\n# The IPv4 stack on Client A already knows the PMTU to Client B, so the\n# UDP packet is sent as two fragments (1380 + 20). Router A forwards the\n# fragments between eth1 and ipip0. The fragments fit into the tunnel and\n# reach their destination.\n\n#When sending the large UDP packet again, Router A now reassembles the\n#fragments before routing the packet over ipip0. The resulting IPIP\n#packet is too big (1400) for the tunnel PMTU (1380) to Router B, it is\n#dropped on Router A before sending.\n\nip netns exec ${r_a} iptables -A FORWARD -m conntrack --ctstate NEW\ntest_path \"with\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}