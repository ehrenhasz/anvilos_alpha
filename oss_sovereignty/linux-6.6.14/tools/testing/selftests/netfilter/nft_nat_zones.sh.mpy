{
  "module_name": "nft_nat_zones.sh",
  "hash_id": "2dc6d246950a43a097e7c3dbdd632ec0c16fca6c1ad195383a4f3b25384ddf45",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/nft_nat_zones.sh",
  "human_readable_source": "#!/bin/bash\n#\n# Test connection tracking zone and NAT source port reallocation support.\n#\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\n# Don't increase too much, 2000 clients should work\n# just fine but script can then take several minutes with\n# KASAN/debug builds.\nmaxclients=100\n\nhave_iperf=1\nret=0\n\n# client1---.\n#            veth1-.\n#                  |\n#               NAT Gateway --veth0--> Server\n#                  | |\n#            veth2-' |\n# client2---'        |\n#  ....              |\n# clientX----vethX---'\n\n# All clients share identical IP address.\n# NAT Gateway uses policy routing and conntrack zones to isolate client\n# namespaces.  Each client connects to Server, each with colliding tuples:\n#   clientsaddr:10000 -> serveraddr:dport\n#   NAT Gateway is supposed to do port reallocation for each of the\n#   connections.\n\nsfx=$(mktemp -u \"XXXXXXXX\")\ngw=\"ns-gw-$sfx\"\ncl1=\"ns-cl1-$sfx\"\ncl2=\"ns-cl2-$sfx\"\nsrv=\"ns-srv-$sfx\"\n\nv4gc1=$(sysctl -n net.ipv4.neigh.default.gc_thresh1 2>/dev/null)\nv4gc2=$(sysctl -n net.ipv4.neigh.default.gc_thresh2 2>/dev/null)\nv4gc3=$(sysctl -n net.ipv4.neigh.default.gc_thresh3 2>/dev/null)\nv6gc1=$(sysctl -n net.ipv6.neigh.default.gc_thresh1 2>/dev/null)\nv6gc2=$(sysctl -n net.ipv6.neigh.default.gc_thresh2 2>/dev/null)\nv6gc3=$(sysctl -n net.ipv6.neigh.default.gc_thresh3 2>/dev/null)\n\ncleanup()\n{\n\tip netns del $gw\n\tip netns del $srv\n\tfor i in $(seq 1 $maxclients); do\n\t\tip netns del ns-cl$i-$sfx 2>/dev/null\n\tdone\n\n\tsysctl -q net.ipv4.neigh.default.gc_thresh1=$v4gc1 2>/dev/null\n\tsysctl -q net.ipv4.neigh.default.gc_thresh2=$v4gc2 2>/dev/null\n\tsysctl -q net.ipv4.neigh.default.gc_thresh3=$v4gc3 2>/dev/null\n\tsysctl -q net.ipv6.neigh.default.gc_thresh1=$v6gc1 2>/dev/null\n\tsysctl -q net.ipv6.neigh.default.gc_thresh2=$v6gc2 2>/dev/null\n\tsysctl -q net.ipv6.neigh.default.gc_thresh3=$v6gc3 2>/dev/null\n}\n\nnft --version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without nft tool\"\n\texit $ksft_skip\nfi\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nconntrack -V > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without conntrack tool\"\n\texit $ksft_skip\nfi\n\niperf3 -v >/dev/null 2>&1\nif [ $? -ne 0 ];then\n\thave_iperf=0\nfi\n\nip netns add \"$gw\"\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not create net namespace $gw\"\n\texit $ksft_skip\nfi\nip -net \"$gw\" link set lo up\n\ntrap cleanup EXIT\n\nip netns add \"$srv\"\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not create server netns $srv\"\n\texit $ksft_skip\nfi\n\nip link add veth0 netns \"$gw\" type veth peer name eth0 netns \"$srv\"\nip -net \"$gw\" link set veth0 up\nip -net \"$srv\" link set lo up\nip -net \"$srv\" link set eth0 up\n\nsysctl -q net.ipv6.neigh.default.gc_thresh1=512  2>/dev/null\nsysctl -q net.ipv6.neigh.default.gc_thresh2=1024 2>/dev/null\nsysctl -q net.ipv6.neigh.default.gc_thresh3=4096 2>/dev/null\nsysctl -q net.ipv4.neigh.default.gc_thresh1=512  2>/dev/null\nsysctl -q net.ipv4.neigh.default.gc_thresh2=1024 2>/dev/null\nsysctl -q net.ipv4.neigh.default.gc_thresh3=4096 2>/dev/null\n\nfor i in $(seq 1 $maxclients);do\n  cl=\"ns-cl$i-$sfx\"\n\n  ip netns add \"$cl\"\n  if [ $? -ne 0 ];then\n     echo \"SKIP: Could not create client netns $cl\"\n     exit $ksft_skip\n  fi\n  ip link add veth$i netns \"$gw\" type veth peer name eth0 netns \"$cl\" > /dev/null 2>&1\n  if [ $? -ne 0 ];then\n    echo \"SKIP: No virtual ethernet pair device support in kernel\"\n    exit $ksft_skip\n  fi\ndone\n\nfor i in $(seq 1 $maxclients);do\n  cl=\"ns-cl$i-$sfx\"\n  echo netns exec \"$cl\" ip link set lo up\n  echo netns exec \"$cl\" ip link set eth0 up\n  echo netns exec \"$cl\" sysctl -q net.ipv4.tcp_syn_retries=2\n  echo netns exec \"$gw\" ip link set veth$i up\n  echo netns exec \"$gw\" sysctl -q net.ipv4.conf.veth$i.arp_ignore=2\n  echo netns exec \"$gw\" sysctl -q net.ipv4.conf.veth$i.rp_filter=0\n\n  # clients have same IP addresses.\n  echo netns exec \"$cl\" ip addr add 10.1.0.3/24 dev eth0\n  echo netns exec \"$cl\" ip addr add dead:1::3/64 dev eth0\n  echo netns exec \"$cl\" ip route add default via 10.1.0.2 dev eth0\n  echo netns exec \"$cl\" ip route add default via dead:1::2 dev eth0\n\n  # NB: same addresses on client-facing interfaces.\n  echo netns exec \"$gw\" ip addr add 10.1.0.2/24 dev veth$i\n  echo netns exec \"$gw\" ip addr add dead:1::2/64 dev veth$i\n\n  # gw: policy routing\n  echo netns exec \"$gw\" ip route add 10.1.0.0/24 dev veth$i table $((1000+i))\n  echo netns exec \"$gw\" ip route add dead:1::0/64 dev veth$i table $((1000+i))\n  echo netns exec \"$gw\" ip route add 10.3.0.0/24 dev veth0 table $((1000+i))\n  echo netns exec \"$gw\" ip route add dead:3::0/64 dev veth0 table $((1000+i))\n  echo netns exec \"$gw\" ip rule add fwmark $i lookup $((1000+i))\ndone | ip -batch /dev/stdin\n\nip -net \"$gw\" addr add 10.3.0.1/24 dev veth0\nip -net \"$gw\" addr add dead:3::1/64 dev veth0\n\nip -net \"$srv\" addr add 10.3.0.99/24 dev eth0\nip -net \"$srv\" addr add dead:3::99/64 dev eth0\n\nip netns exec $gw nft -f /dev/stdin<<EOF\ntable inet raw {\n\tmap iiftomark {\n\t\ttype ifname : mark\n\t}\n\n\tmap iiftozone {\n\t\ttypeof iifname : ct zone\n\t}\n\n\tset inicmp {\n\t\tflags dynamic\n\t\ttype ipv4_addr . ifname . ipv4_addr\n\t}\n\tset inflows {\n\t\tflags dynamic\n\t\ttype ipv4_addr . inet_service . ifname . ipv4_addr . inet_service\n\t}\n\n\tset inflows6 {\n\t\tflags dynamic\n\t\ttype ipv6_addr . inet_service . ifname . ipv6_addr . inet_service\n\t}\n\n\tchain prerouting {\n\t\ttype filter hook prerouting priority -64000; policy accept;\n\t\tct original zone set meta iifname map @iiftozone\n\t\tmeta mark set meta iifname map @iiftomark\n\n\t\ttcp flags & (syn|ack) == ack add @inflows { ip saddr . tcp sport . meta iifname . ip daddr . tcp dport counter }\n\t\tadd @inflows6 { ip6 saddr . tcp sport . meta iifname . ip6 daddr . tcp dport counter }\n\t\tip protocol icmp add @inicmp { ip saddr . meta iifname . ip daddr counter }\n\t}\n\n\tchain nat_postrouting {\n\t\ttype nat hook postrouting priority 0; policy accept;\n                ct mark set meta mark meta oifname veth0 masquerade\n\t}\n\n\tchain mangle_prerouting {\n\t\ttype filter hook prerouting priority -100; policy accept;\n\t\tct direction reply meta mark set ct mark\n\t}\n}\nEOF\n\n( echo add element inet raw iiftomark \\{\n\tfor i in $(seq 1 $((maxclients-1))); do\n\t\techo \\\"veth$i\\\" : $i,\n\tdone\n\techo \\\"veth$maxclients\\\" : $maxclients \\}\n\techo add element inet raw iiftozone \\{\n\tfor i in $(seq 1 $((maxclients-1))); do\n\t\techo \\\"veth$i\\\" : $i,\n\tdone\n\techo \\\"veth$maxclients\\\" : $maxclients \\}\n) | ip netns exec $gw nft -f /dev/stdin\n\nip netns exec \"$gw\" sysctl -q net.ipv4.conf.all.forwarding=1 > /dev/null\nip netns exec \"$gw\" sysctl -q net.ipv6.conf.all.forwarding=1 > /dev/null\nip netns exec \"$gw\" sysctl -q net.ipv4.conf.all.rp_filter=0 >/dev/null\n\n# useful for debugging: allows to use 'ping' from clients to gateway.\nip netns exec \"$gw\" sysctl -q net.ipv4.fwmark_reflect=1 > /dev/null\nip netns exec \"$gw\" sysctl -q net.ipv6.fwmark_reflect=1 > /dev/null\n\nfor i in $(seq 1 $maxclients); do\n  cl=\"ns-cl$i-$sfx\"\n  ip netns exec $cl ping -i 0.5 -q -c 3 10.3.0.99 > /dev/null 2>&1 &\n  if [ $? -ne 0 ]; then\n     echo FAIL: Ping failure from $cl 1>&2\n     ret=1\n     break\n  fi\ndone\n\nwait\n\nfor i in $(seq 1 $maxclients); do\n   ip netns exec $gw nft get element inet raw inicmp \"{ 10.1.0.3 . \\\"veth$i\\\" . 10.3.0.99 }\" | grep -q \"{ 10.1.0.3 . \\\"veth$i\\\" . 10.3.0.99 counter packets 3 bytes 252 }\"\n   if [ $? -ne 0 ];then\n      ret=1\n      echo \"FAIL: counter icmp mismatch for veth$i\" 1>&2\n      ip netns exec $gw nft get element inet raw inicmp \"{ 10.1.0.3 . \\\"veth$i\\\" . 10.3.0.99 }\" 1>&2\n      break\n   fi\ndone\n\nip netns exec $gw nft get element inet raw inicmp \"{ 10.3.0.99 . \\\"veth0\\\" . 10.3.0.1 }\" | grep -q \"{ 10.3.0.99 . \\\"veth0\\\" . 10.3.0.1 counter packets $((3 * $maxclients)) bytes $((252 * $maxclients)) }\"\nif [ $? -ne 0 ];then\n    ret=1\n    echo \"FAIL: counter icmp mismatch for veth0: { 10.3.0.99 . \\\"veth0\\\" . 10.3.0.1 counter packets $((3 * $maxclients)) bytes $((252 * $maxclients)) }\"\n    ip netns exec $gw nft get element inet raw inicmp \"{ 10.3.99 . \\\"veth0\\\" . 10.3.0.1 }\" 1>&2\nfi\n\nif  [ $ret -eq 0 ]; then\n\techo \"PASS: ping test from all $maxclients namespaces\"\nfi\n\nif [ $have_iperf -eq 0 ];then\n\techo \"SKIP: iperf3 not installed\"\n\tif [ $ret -ne 0 ];then\n\t    exit $ret\n\tfi\n\texit $ksft_skip\nfi\n\nip netns exec $srv iperf3 -s > /dev/null 2>&1 &\niperfpid=$!\nsleep 1\n\nfor i in $(seq 1 $maxclients); do\n  if [ $ret -ne 0 ]; then\n     break\n  fi\n  cl=\"ns-cl$i-$sfx\"\n  ip netns exec $cl iperf3 -c 10.3.0.99 --cport 10000 -n 1 > /dev/null\n  if [ $? -ne 0 ]; then\n     echo FAIL: Failure to connect for $cl 1>&2\n     ip netns exec $gw conntrack -S 1>&2\n     ret=1\n  fi\ndone\nif [ $ret -eq 0 ];then\n\techo \"PASS: iperf3 connections for all $maxclients net namespaces\"\nfi\n\nkill $iperfpid\nwait\n\nfor i in $(seq 1 $maxclients); do\n   ip netns exec $gw nft get element inet raw inflows \"{ 10.1.0.3 . 10000 . \\\"veth$i\\\" . 10.3.0.99 . 5201 }\" > /dev/null\n   if [ $? -ne 0 ];then\n      ret=1\n      echo \"FAIL: can't find expected tcp entry for veth$i\" 1>&2\n      break\n   fi\ndone\nif [ $ret -eq 0 ];then\n\techo \"PASS: Found client connection for all $maxclients net namespaces\"\nfi\n\nip netns exec $gw nft get element inet raw inflows \"{ 10.3.0.99 . 5201 . \\\"veth0\\\" . 10.3.0.1 . 10000 }\" > /dev/null\nif [ $? -ne 0 ];then\n    ret=1\n    echo \"FAIL: cannot find return entry on veth0\" 1>&2\nfi\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}