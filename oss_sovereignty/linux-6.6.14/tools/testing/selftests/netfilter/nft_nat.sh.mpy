{
  "module_name": "nft_nat.sh",
  "hash_id": "70e88ec0f9b1c4e5389f55ce2ed29a66c2a26132b20c64ac2ede6c8ac2fbeec3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/nft_nat.sh",
  "human_readable_source": "#!/bin/bash\n#\n# This test is for basic NAT functionality: snat, dnat, redirect, masquerade.\n#\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nret=0\ntest_inet_nat=true\n\nsfx=$(mktemp -u \"XXXXXXXX\")\nns0=\"ns0-$sfx\"\nns1=\"ns1-$sfx\"\nns2=\"ns2-$sfx\"\n\ncleanup()\n{\n\tfor i in 0 1 2; do ip netns del ns$i-\"$sfx\";done\n}\n\nnft --version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without nft tool\"\n\texit $ksft_skip\nfi\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nip netns add \"$ns0\"\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not create net namespace $ns0\"\n\texit $ksft_skip\nfi\n\ntrap cleanup EXIT\n\nip netns add \"$ns1\"\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not create net namespace $ns1\"\n\texit $ksft_skip\nfi\n\nip netns add \"$ns2\"\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not create net namespace $ns2\"\n\texit $ksft_skip\nfi\n\nip link add veth0 netns \"$ns0\" type veth peer name eth0 netns \"$ns1\" > /dev/null 2>&1\nif [ $? -ne 0 ];then\n    echo \"SKIP: No virtual ethernet pair device support in kernel\"\n    exit $ksft_skip\nfi\nip link add veth1 netns \"$ns0\" type veth peer name eth0 netns \"$ns2\"\n\nip -net \"$ns0\" link set lo up\nip -net \"$ns0\" link set veth0 up\nip -net \"$ns0\" addr add 10.0.1.1/24 dev veth0\nip -net \"$ns0\" addr add dead:1::1/64 dev veth0\n\nip -net \"$ns0\" link set veth1 up\nip -net \"$ns0\" addr add 10.0.2.1/24 dev veth1\nip -net \"$ns0\" addr add dead:2::1/64 dev veth1\n\nfor i in 1 2; do\n  ip -net ns$i-$sfx link set lo up\n  ip -net ns$i-$sfx link set eth0 up\n  ip -net ns$i-$sfx addr add 10.0.$i.99/24 dev eth0\n  ip -net ns$i-$sfx route add default via 10.0.$i.1\n  ip -net ns$i-$sfx addr add dead:$i::99/64 dev eth0\n  ip -net ns$i-$sfx route add default via dead:$i::1\ndone\n\nbad_counter()\n{\n\tlocal ns=$1\n\tlocal counter=$2\n\tlocal expect=$3\n\tlocal tag=$4\n\n\techo \"ERROR: $counter counter in $ns has unexpected value (expected $expect) at $tag\" 1>&2\n\tip netns exec $ns nft list counter inet filter $counter 1>&2\n}\n\ncheck_counters()\n{\n\tns=$1\n\tlocal lret=0\n\n\tcnt=$(ip netns exec $ns nft list counter inet filter ns0in | grep -q \"packets 1 bytes 84\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter $ns ns0in \"packets 1 bytes 84\" \"check_counters 1\"\n\t\tlret=1\n\tfi\n\tcnt=$(ip netns exec $ns nft list counter inet filter ns0out | grep -q \"packets 1 bytes 84\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter $ns ns0out \"packets 1 bytes 84\" \"check_counters 2\"\n\t\tlret=1\n\tfi\n\n\texpect=\"packets 1 bytes 104\"\n\tcnt=$(ip netns exec $ns nft list counter inet filter ns0in6 | grep -q \"$expect\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter $ns ns0in6 \"$expect\" \"check_counters 3\"\n\t\tlret=1\n\tfi\n\tcnt=$(ip netns exec $ns nft list counter inet filter ns0out6 | grep -q \"$expect\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter $ns ns0out6 \"$expect\" \"check_counters 4\"\n\t\tlret=1\n\tfi\n\n\treturn $lret\n}\n\ncheck_ns0_counters()\n{\n\tlocal ns=$1\n\tlocal lret=0\n\n\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns0in | grep -q \"packets 0 bytes 0\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter \"$ns0\" ns0in \"packets 0 bytes 0\" \"check_ns0_counters 1\"\n\t\tlret=1\n\tfi\n\n\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns0in6 | grep -q \"packets 0 bytes 0\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter \"$ns0\" ns0in6 \"packets 0 bytes 0\"\n\t\tlret=1\n\tfi\n\n\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns0out | grep -q \"packets 0 bytes 0\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter \"$ns0\" ns0out \"packets 0 bytes 0\" \"check_ns0_counters 2\"\n\t\tlret=1\n\tfi\n\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns0out6 | grep -q \"packets 0 bytes 0\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter \"$ns0\" ns0out6 \"packets 0 bytes 0\" \"check_ns0_counters3 \"\n\t\tlret=1\n\tfi\n\n\tfor dir in \"in\" \"out\" ; do\n\t\texpect=\"packets 1 bytes 84\"\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ${ns}${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" $ns$dir \"$expect\" \"check_ns0_counters 4\"\n\t\t\tlret=1\n\t\tfi\n\n\t\texpect=\"packets 1 bytes 104\"\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ${ns}${dir}6 | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" $ns$dir6 \"$expect\" \"check_ns0_counters 5\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\treturn $lret\n}\n\nreset_counters()\n{\n\tfor i in 0 1 2;do\n\t\tip netns exec ns$i-$sfx nft reset counters inet > /dev/null\n\tdone\n}\n\ntest_local_dnat6()\n{\n\tlocal family=$1\n\tlocal lret=0\n\tlocal IPF=\"\"\n\n\tif [ $family = \"inet\" ];then\n\t\tIPF=\"ip6\"\n\tfi\n\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family nat {\n\tchain output {\n\t\ttype nat hook output priority 0; policy accept;\n\t\tip6 daddr dead:1::99 dnat $IPF to dead:2::99\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: Could not add add $family dnat hook\"\n\t\treturn $ksft_skip\n\tfi\n\n\t# ping netns1, expect rewrite to netns2\n\tip netns exec \"$ns0\" ping -q -c 1 dead:1::99 > /dev/null\n\tif [ $? -ne 0 ]; then\n\t\tlret=1\n\t\techo \"ERROR: ping6 failed\"\n\t\treturn $lret\n\tfi\n\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns1$dir \"$expect\" \"test_local_dnat6 1\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\texpect=\"packets 1 bytes 104\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns2$dir \"$expect\" \"test_local_dnat6 2\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# expect 0 count in ns1\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns0${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_local_dnat6 3\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# expect 1 packet in ns2\n\texpect=\"packets 1 bytes 104\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns0${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns0$dir \"$expect\" \"test_local_dnat6 4\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\ttest $lret -eq 0 && echo \"PASS: ipv6 ping to $ns1 was $family NATted to $ns2\"\n\tip netns exec \"$ns0\" nft flush chain ip6 nat output\n\n\treturn $lret\n}\n\ntest_local_dnat()\n{\n\tlocal family=$1\n\tlocal lret=0\n\tlocal IPF=\"\"\n\n\tif [ $family = \"inet\" ];then\n\t\tIPF=\"ip\"\n\tfi\n\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF 2>/dev/null\ntable $family nat {\n\tchain output {\n\t\ttype nat hook output priority 0; policy accept;\n\t\tip daddr 10.0.1.99 dnat $IPF to 10.0.2.99\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\tif [ $family = \"inet\" ];then\n\t\t\techo \"SKIP: inet nat tests\"\n\t\t\ttest_inet_nat=false\n\t\t\treturn $ksft_skip\n\t\tfi\n\t\techo \"SKIP: Could not add add $family dnat hook\"\n\t\treturn $ksft_skip\n\tfi\n\n\t# ping netns1, expect rewrite to netns2\n\tip netns exec \"$ns0\" ping -q -c 1 10.0.1.99 > /dev/null\n\tif [ $? -ne 0 ]; then\n\t\tlret=1\n\t\techo \"ERROR: ping failed\"\n\t\treturn $lret\n\tfi\n\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns1$dir \"$expect\" \"test_local_dnat 1\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\texpect=\"packets 1 bytes 84\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns2$dir \"$expect\" \"test_local_dnat 2\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# expect 0 count in ns1\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns0${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_local_dnat 3\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# expect 1 packet in ns2\n\texpect=\"packets 1 bytes 84\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns0${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns0$dir \"$expect\" \"test_local_dnat 4\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\ttest $lret -eq 0 && echo \"PASS: ping to $ns1 was $family NATted to $ns2\"\n\n\tip netns exec \"$ns0\" nft flush chain $family nat output\n\n\treset_counters\n\tip netns exec \"$ns0\" ping -q -c 1 10.0.1.99 > /dev/null\n\tif [ $? -ne 0 ]; then\n\t\tlret=1\n\t\techo \"ERROR: ping failed\"\n\t\treturn $lret\n\tfi\n\n\texpect=\"packets 1 bytes 84\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns1$dir \"$expect\" \"test_local_dnat 5\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns2$dir \"$expect\" \"test_local_dnat 6\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# expect 1 count in ns1\n\texpect=\"packets 1 bytes 84\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns0${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns0$dir \"$expect\" \"test_local_dnat 7\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# expect 0 packet in ns2\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns0${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns0$dir \"$expect\" \"test_local_dnat 8\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\ttest $lret -eq 0 && echo \"PASS: ping to $ns1 OK after $family nat output chain flush\"\n\n\treturn $lret\n}\n\ntest_local_dnat_portonly()\n{\n\tlocal family=$1\n\tlocal daddr=$2\n\tlocal lret=0\n\tlocal sr_s\n\tlocal sr_r\n\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family nat {\n\tchain output {\n\t\ttype nat hook output priority 0; policy accept;\n\t\tmeta l4proto tcp dnat to :2000\n\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\tif [ $family = \"inet\" ];then\n\t\t\techo \"SKIP: inet port test\"\n\t\t\ttest_inet_nat=false\n\t\t\treturn\n\t\tfi\n\t\techo \"SKIP: Could not add $family dnat hook\"\n\t\treturn\n\tfi\n\n\techo SERVER-$family | ip netns exec \"$ns1\" timeout 5 socat -u STDIN TCP-LISTEN:2000 &\n\tsc_s=$!\n\n\tsleep 1\n\n\tresult=$(ip netns exec \"$ns0\" timeout 1 socat TCP:$daddr:2000 STDOUT)\n\n\tif [ \"$result\" = \"SERVER-inet\" ];then\n\t\techo \"PASS: inet port rewrite without l3 address\"\n\telse\n\t\techo \"ERROR: inet port rewrite\"\n\t\tret=1\n\tfi\n}\n\ntest_masquerade6()\n{\n\tlocal family=$1\n\tlocal natflags=$2\n\tlocal lret=0\n\n\tip netns exec \"$ns0\" sysctl net.ipv6.conf.all.forwarding=1 > /dev/null\n\n\tip netns exec \"$ns2\" ping -q -c 1 dead:1::99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2 via ipv6\"\n\t\treturn 1\n\t\tlret=1\n\tfi\n\n\texpect=\"packets 1 bytes 104\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns2$dir \"$expect\" \"test_masquerade6 1\"\n\t\t\tlret=1\n\t\tfi\n\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns1$dir \"$expect\" \"test_masquerade6 2\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\treset_counters\n\n# add masquerading rule\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family nat {\n\tchain postrouting {\n\t\ttype nat hook postrouting priority 0; policy accept;\n\t\tmeta oif veth0 masquerade $natflags\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: Could not add add $family masquerade hook\"\n\t\treturn $ksft_skip\n\tfi\n\n\tip netns exec \"$ns2\" ping -q -c 1 dead:1::99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2 with active $family masquerade $natflags\"\n\t\tlret=1\n\tfi\n\n\t# ns1 should have seen packets from ns0, due to masquerade\n\texpect=\"packets 1 bytes 104\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns0${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_masquerade6 3\"\n\t\t\tlret=1\n\t\tfi\n\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns1$dir \"$expect\" \"test_masquerade6 4\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# ns1 should not have seen packets from ns2, due to masquerade\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_masquerade6 5\"\n\t\t\tlret=1\n\t\tfi\n\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns1$dir \"$expect\" \"test_masquerade6 6\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\tip netns exec \"$ns2\" ping -q -c 1 dead:1::99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2 with active ipv6 masquerade $natflags (attempt 2)\"\n\t\tlret=1\n\tfi\n\n\tip netns exec \"$ns0\" nft flush chain $family nat postrouting\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: Could not flush $family nat postrouting\" 1>&2\n\t\tlret=1\n\tfi\n\n\ttest $lret -eq 0 && echo \"PASS: $family IPv6 masquerade $natflags for $ns2\"\n\n\treturn $lret\n}\n\ntest_masquerade()\n{\n\tlocal family=$1\n\tlocal natflags=$2\n\tlocal lret=0\n\n\tip netns exec \"$ns0\" sysctl net.ipv4.conf.veth0.forwarding=1 > /dev/null\n\tip netns exec \"$ns0\" sysctl net.ipv4.conf.veth1.forwarding=1 > /dev/null\n\n\tip netns exec \"$ns2\" ping -q -c 1 10.0.1.99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from \"$ns2\" $natflags\"\n\t\tlret=1\n\tfi\n\n\texpect=\"packets 1 bytes 84\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns2$dir \"$expect\" \"test_masquerade 1\"\n\t\t\tlret=1\n\t\tfi\n\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns1$dir \"$expect\" \"test_masquerade 2\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\treset_counters\n\n# add masquerading rule\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family nat {\n\tchain postrouting {\n\t\ttype nat hook postrouting priority 0; policy accept;\n\t\tmeta oif veth0 masquerade $natflags\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: Could not add add $family masquerade hook\"\n\t\treturn $ksft_skip\n\tfi\n\n\tip netns exec \"$ns2\" ping -q -c 1 10.0.1.99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2 with active $family masquerade $natflags\"\n\t\tlret=1\n\tfi\n\n\t# ns1 should have seen packets from ns0, due to masquerade\n\texpect=\"packets 1 bytes 84\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns0${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_masquerade 3\"\n\t\t\tlret=1\n\t\tfi\n\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns1$dir \"$expect\" \"test_masquerade 4\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# ns1 should not have seen packets from ns2, due to masquerade\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_masquerade 5\"\n\t\t\tlret=1\n\t\tfi\n\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns1$dir \"$expect\" \"test_masquerade 6\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\tip netns exec \"$ns2\" ping -q -c 1 10.0.1.99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2 with active ip masquerade $natflags (attempt 2)\"\n\t\tlret=1\n\tfi\n\n\tip netns exec \"$ns0\" nft flush chain $family nat postrouting\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: Could not flush $family nat postrouting\" 1>&2\n\t\tlret=1\n\tfi\n\n\ttest $lret -eq 0 && echo \"PASS: $family IP masquerade $natflags for $ns2\"\n\n\treturn $lret\n}\n\ntest_redirect6()\n{\n\tlocal family=$1\n\tlocal lret=0\n\n\tip netns exec \"$ns0\" sysctl net.ipv6.conf.all.forwarding=1 > /dev/null\n\n\tip netns exec \"$ns2\" ping -q -c 1 dead:1::99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannnot ping $ns1 from $ns2 via ipv6\"\n\t\tlret=1\n\tfi\n\n\texpect=\"packets 1 bytes 104\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns2$dir \"$expect\" \"test_redirect6 1\"\n\t\t\tlret=1\n\t\tfi\n\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns1$dir \"$expect\" \"test_redirect6 2\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\treset_counters\n\n# add redirect rule\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family nat {\n\tchain prerouting {\n\t\ttype nat hook prerouting priority 0; policy accept;\n\t\tmeta iif veth1 meta l4proto icmpv6 ip6 saddr dead:2::99 ip6 daddr dead:1::99 redirect\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: Could not add add $family redirect hook\"\n\t\treturn $ksft_skip\n\tfi\n\n\tip netns exec \"$ns2\" ping -q -c 1 dead:1::99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2 via ipv6 with active $family redirect\"\n\t\tlret=1\n\tfi\n\n\t# ns1 should have seen no packets from ns2, due to redirection\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_redirect6 3\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# ns0 should have seen packets from ns2, due to masquerade\n\texpect=\"packets 1 bytes 104\"\n\tfor dir in \"in6\" \"out6\" ; do\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_redirect6 4\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\tip netns exec \"$ns0\" nft delete table $family nat\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: Could not delete $family nat table\" 1>&2\n\t\tlret=1\n\tfi\n\n\ttest $lret -eq 0 && echo \"PASS: $family IPv6 redirection for $ns2\"\n\n\treturn $lret\n}\n\ntest_redirect()\n{\n\tlocal family=$1\n\tlocal lret=0\n\n\tip netns exec \"$ns0\" sysctl net.ipv4.conf.veth0.forwarding=1 > /dev/null\n\tip netns exec \"$ns0\" sysctl net.ipv4.conf.veth1.forwarding=1 > /dev/null\n\n\tip netns exec \"$ns2\" ping -q -c 1 10.0.1.99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2\"\n\t\tlret=1\n\tfi\n\n\texpect=\"packets 1 bytes 84\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" $ns2$dir \"$expect\" \"test_redirect 1\"\n\t\t\tlret=1\n\t\tfi\n\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns1$dir \"$expect\" \"test_redirect 2\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\treset_counters\n\n# add redirect rule\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family nat {\n\tchain prerouting {\n\t\ttype nat hook prerouting priority 0; policy accept;\n\t\tmeta iif veth1 ip protocol icmp ip saddr 10.0.2.99 ip daddr 10.0.1.99 redirect\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: Could not add add $family redirect hook\"\n\t\treturn $ksft_skip\n\tfi\n\n\tip netns exec \"$ns2\" ping -q -c 1 10.0.1.99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2 with active $family ip redirect\"\n\t\tlret=1\n\tfi\n\n\t# ns1 should have seen no packets from ns2, due to redirection\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in\" \"out\" ; do\n\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_redirect 3\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# ns0 should have seen packets from ns2, due to masquerade\n\texpect=\"packets 1 bytes 84\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns0$dir \"$expect\" \"test_redirect 4\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\tip netns exec \"$ns0\" nft delete table $family nat\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: Could not delete $family nat table\" 1>&2\n\t\tlret=1\n\tfi\n\n\ttest $lret -eq 0 && echo \"PASS: $family IP redirection for $ns2\"\n\n\treturn $lret\n}\n\n# test port shadowing.\n# create two listening services, one on router (ns0), one\n# on client (ns2), which is masqueraded from ns1 point of view.\n# ns2 sends udp packet coming from service port to ns1, on a highport.\n# Later, if n1 uses same highport to connect to ns0:service, packet\n# might be port-forwarded to ns2 instead.\n\n# second argument tells if we expect the 'fake-entry' to take effect\n# (CLIENT) or not (ROUTER).\ntest_port_shadow()\n{\n\tlocal test=$1\n\tlocal expect=$2\n\tlocal daddrc=\"10.0.1.99\"\n\tlocal daddrs=\"10.0.1.1\"\n\tlocal result=\"\"\n\tlocal logmsg=\"\"\n\n\t# make shadow entry, from client (ns2), going to (ns1), port 41404, sport 1405.\n\techo \"fake-entry\" | ip netns exec \"$ns2\" timeout 1 socat -u STDIN UDP:\"$daddrc\":41404,sourceport=1405\n\n\techo ROUTER | ip netns exec \"$ns0\" timeout 5 socat -u STDIN UDP4-LISTEN:1405 &\n\tsc_r=$!\n\n\techo CLIENT | ip netns exec \"$ns2\" timeout 5 socat -u STDIN UDP4-LISTEN:1405,reuseport &\n\tsc_c=$!\n\n\tsleep 0.3\n\n\t# ns1 tries to connect to ns0:1405.  With default settings this should connect\n\t# to client, it matches the conntrack entry created above.\n\n\tresult=$(echo \"data\" | ip netns exec \"$ns1\" timeout 1 socat - UDP:\"$daddrs\":1405,sourceport=41404)\n\n\tif [ \"$result\" = \"$expect\" ] ;then\n\t\techo \"PASS: portshadow test $test: got reply from ${expect}${logmsg}\"\n\telse\n\t\techo \"ERROR: portshadow test $test: got reply from \\\"$result\\\", not $expect as intended\"\n\t\tret=1\n\tfi\n\n\tkill $sc_r $sc_c 2>/dev/null\n\n\t# flush udp entries for next test round, if any\n\tip netns exec \"$ns0\" conntrack -F >/dev/null 2>&1\n}\n\n# This prevents port shadow of router service via packet filter,\n# packets claiming to originate from service port from internal\n# network are dropped.\ntest_port_shadow_filter()\n{\n\tlocal family=$1\n\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family filter {\n\tchain forward {\n\t\ttype filter hook forward priority 0; policy accept;\n\t\tmeta iif veth1 udp sport 1405 drop\n\t}\n}\nEOF\n\ttest_port_shadow \"port-filter\" \"ROUTER\"\n\n\tip netns exec \"$ns0\" nft delete table $family filter\n}\n\n# This prevents port shadow of router service via notrack.\ntest_port_shadow_notrack()\n{\n\tlocal family=$1\n\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family raw {\n\tchain prerouting {\n\t\ttype filter hook prerouting priority -300; policy accept;\n\t\tmeta iif veth0 udp dport 1405 notrack\n\t}\n\tchain output {\n\t\ttype filter hook output priority -300; policy accept;\n\t\tmeta oif veth0 udp sport 1405 notrack\n\t}\n}\nEOF\n\ttest_port_shadow \"port-notrack\" \"ROUTER\"\n\n\tip netns exec \"$ns0\" nft delete table $family raw\n}\n\n# This prevents port shadow of router service via sport remap.\ntest_port_shadow_pat()\n{\n\tlocal family=$1\n\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family pat {\n\tchain postrouting {\n\t\ttype nat hook postrouting priority -1; policy accept;\n\t\tmeta iif veth1 udp sport <= 1405 masquerade to : 1406-65535 random\n\t}\n}\nEOF\n\ttest_port_shadow \"pat\" \"ROUTER\"\n\n\tip netns exec \"$ns0\" nft delete table $family pat\n}\n\ntest_port_shadowing()\n{\n\tlocal family=\"ip\"\n\n\tconntrack -h >/dev/null 2>&1\n\tif [ $? -ne 0 ];then\n\t\techo \"SKIP: Could not run nat port shadowing test without conntrack tool\"\n\t\treturn\n\tfi\n\n\tsocat -h > /dev/null 2>&1\n\tif [ $? -ne 0 ];then\n\t\techo \"SKIP: Could not run nat port shadowing test without socat tool\"\n\t\treturn\n\tfi\n\n\tip netns exec \"$ns0\" sysctl net.ipv4.conf.veth0.forwarding=1 > /dev/null\n\tip netns exec \"$ns0\" sysctl net.ipv4.conf.veth1.forwarding=1 > /dev/null\n\n\tip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable $family nat {\n\tchain postrouting {\n\t\ttype nat hook postrouting priority 0; policy accept;\n\t\tmeta oif veth0 masquerade\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: Could not add add $family masquerade hook\"\n\t\treturn $ksft_skip\n\tfi\n\n\t# test default behaviour. Packet from ns1 to ns0 is redirected to ns2.\n\ttest_port_shadow \"default\" \"CLIENT\"\n\n\t# test packet filter based mitigation: prevent forwarding of\n\t# packets claiming to come from the service port.\n\ttest_port_shadow_filter \"$family\"\n\n\t# test conntrack based mitigation: connections going or coming\n\t# from router:service bypass connection tracking.\n\ttest_port_shadow_notrack \"$family\"\n\n\t# test nat based mitigation: fowarded packets coming from service port\n\t# are masqueraded with random highport.\n\ttest_port_shadow_pat \"$family\"\n\n\tip netns exec \"$ns0\" nft delete table $family nat\n}\n\ntest_stateless_nat_ip()\n{\n\tlocal lret=0\n\n\tip netns exec \"$ns0\" sysctl net.ipv4.conf.veth0.forwarding=1 > /dev/null\n\tip netns exec \"$ns0\" sysctl net.ipv4.conf.veth1.forwarding=1 > /dev/null\n\n\tip netns exec \"$ns2\" ping -q -c 1 10.0.1.99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2 before loading stateless rules\"\n\t\treturn 1\n\tfi\n\nip netns exec \"$ns0\" nft -f /dev/stdin <<EOF\ntable ip stateless {\n\tmap xlate_in {\n\t\ttypeof meta iifname . ip saddr . ip daddr : ip daddr\n\t\telements = {\n\t\t\t\"veth1\" . 10.0.2.99 . 10.0.1.99 : 10.0.2.2,\n\t\t}\n\t}\n\tmap xlate_out {\n\t\ttypeof meta iifname . ip saddr . ip daddr : ip daddr\n\t\telements = {\n\t\t\t\"veth0\" . 10.0.1.99 . 10.0.2.2 : 10.0.2.99\n\t\t}\n\t}\n\n\tchain prerouting {\n\t\ttype filter hook prerouting priority -400; policy accept;\n\t\tip saddr set meta iifname . ip saddr . ip daddr map @xlate_in\n\t\tip daddr set meta iifname . ip saddr . ip daddr map @xlate_out\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: Could not add ip statless rules\"\n\t\treturn $ksft_skip\n\tfi\n\n\treset_counters\n\n\tip netns exec \"$ns2\" ping -q -c 1 10.0.1.99 > /dev/null # ping ns2->ns1\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: cannot ping $ns1 from $ns2 with stateless rules\"\n\t\tlret=1\n\tfi\n\n\t# ns1 should have seen packets from .2.2, due to stateless rewrite.\n\texpect=\"packets 1 bytes 84\"\n\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns0insl | grep -q \"$expect\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter \"$ns1\" ns0insl \"$expect\" \"test_stateless 1\"\n\t\tlret=1\n\tfi\n\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns2\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns2\" ns1$dir \"$expect\" \"test_stateless 2\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\t# ns1 should not have seen packets from ns2, due to masquerade\n\texpect=\"packets 0 bytes 0\"\n\tfor dir in \"in\" \"out\" ; do\n\t\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns2${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns1\" ns0$dir \"$expect\" \"test_stateless 3\"\n\t\t\tlret=1\n\t\tfi\n\n\t\tcnt=$(ip netns exec \"$ns0\" nft list counter inet filter ns1${dir} | grep -q \"$expect\")\n\t\tif [ $? -ne 0 ]; then\n\t\t\tbad_counter \"$ns0\" ns1$dir \"$expect\" \"test_stateless 4\"\n\t\t\tlret=1\n\t\tfi\n\tdone\n\n\treset_counters\n\n\tsocat -h > /dev/null 2>&1\n\tif [ $? -ne 0 ];then\n\t\techo \"SKIP: Could not run stateless nat frag test without socat tool\"\n\t\tif [ $lret -eq 0 ]; then\n\t\t\treturn $ksft_skip\n\t\tfi\n\n\t\tip netns exec \"$ns0\" nft delete table ip stateless\n\t\treturn $lret\n\tfi\n\n\tlocal tmpfile=$(mktemp)\n\tdd if=/dev/urandom of=$tmpfile bs=4096 count=1 2>/dev/null\n\n\tlocal outfile=$(mktemp)\n\tip netns exec \"$ns1\" timeout 3 socat -u UDP4-RECV:4233 OPEN:$outfile < /dev/null &\n\tsc_r=$!\n\n\tsleep 1\n\t# re-do with large ping -> ip fragmentation\n\tip netns exec \"$ns2\" timeout 3 socat - UDP4-SENDTO:\"10.0.1.99:4233\" < \"$tmpfile\" > /dev/null\n\tif [ $? -ne 0 ] ; then\n\t\techo \"ERROR: failed to test udp $ns1 to $ns2 with stateless ip nat\" 1>&2\n\t\tlret=1\n\tfi\n\n\twait\n\n\tcmp \"$tmpfile\" \"$outfile\"\n\tif [ $? -ne 0 ]; then\n\t\tls -l \"$tmpfile\" \"$outfile\"\n\t\techo \"ERROR: in and output file mismatch when checking udp with stateless nat\" 1>&2\n\t\tlret=1\n\tfi\n\n\trm -f \"$tmpfile\" \"$outfile\"\n\n\t# ns1 should have seen packets from 2.2, due to stateless rewrite.\n\texpect=\"packets 3 bytes 4164\"\n\tcnt=$(ip netns exec \"$ns1\" nft list counter inet filter ns0insl | grep -q \"$expect\")\n\tif [ $? -ne 0 ]; then\n\t\tbad_counter \"$ns1\" ns0insl \"$expect\" \"test_stateless 5\"\n\t\tlret=1\n\tfi\n\n\tip netns exec \"$ns0\" nft delete table ip stateless\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: Could not delete table ip stateless\" 1>&2\n\t\tlret=1\n\tfi\n\n\ttest $lret -eq 0 && echo \"PASS: IP statless for $ns2\"\n\n\treturn $lret\n}\n\n# ip netns exec \"$ns0\" ping -c 1 -q 10.0.$i.99\nfor i in 0 1 2; do\nip netns exec ns$i-$sfx nft -f /dev/stdin <<EOF\ntable inet filter {\n\tcounter ns0in {}\n\tcounter ns1in {}\n\tcounter ns2in {}\n\n\tcounter ns0out {}\n\tcounter ns1out {}\n\tcounter ns2out {}\n\n\tcounter ns0in6 {}\n\tcounter ns1in6 {}\n\tcounter ns2in6 {}\n\n\tcounter ns0out6 {}\n\tcounter ns1out6 {}\n\tcounter ns2out6 {}\n\n\tmap nsincounter {\n\t\ttype ipv4_addr : counter\n\t\telements = { 10.0.1.1 : \"ns0in\",\n\t\t\t     10.0.2.1 : \"ns0in\",\n\t\t\t     10.0.1.99 : \"ns1in\",\n\t\t\t     10.0.2.99 : \"ns2in\" }\n\t}\n\n\tmap nsincounter6 {\n\t\ttype ipv6_addr : counter\n\t\telements = { dead:1::1 : \"ns0in6\",\n\t\t\t     dead:2::1 : \"ns0in6\",\n\t\t\t     dead:1::99 : \"ns1in6\",\n\t\t\t     dead:2::99 : \"ns2in6\" }\n\t}\n\n\tmap nsoutcounter {\n\t\ttype ipv4_addr : counter\n\t\telements = { 10.0.1.1 : \"ns0out\",\n\t\t\t     10.0.2.1 : \"ns0out\",\n\t\t\t     10.0.1.99: \"ns1out\",\n\t\t\t     10.0.2.99: \"ns2out\" }\n\t}\n\n\tmap nsoutcounter6 {\n\t\ttype ipv6_addr : counter\n\t\telements = { dead:1::1 : \"ns0out6\",\n\t\t\t     dead:2::1 : \"ns0out6\",\n\t\t\t     dead:1::99 : \"ns1out6\",\n\t\t\t     dead:2::99 : \"ns2out6\" }\n\t}\n\n\tchain input {\n\t\ttype filter hook input priority 0; policy accept;\n\t\tcounter name ip saddr map @nsincounter\n\t\ticmpv6 type { \"echo-request\", \"echo-reply\" } counter name ip6 saddr map @nsincounter6\n\t}\n\tchain output {\n\t\ttype filter hook output priority 0; policy accept;\n\t\tcounter name ip daddr map @nsoutcounter\n\t\ticmpv6 type { \"echo-request\", \"echo-reply\" } counter name ip6 daddr map @nsoutcounter6\n\t}\n}\nEOF\ndone\n\n# special case for stateless nat check, counter needs to\n# be done before (input) ip defragmentation\nip netns exec ns1-$sfx nft -f /dev/stdin <<EOF\ntable inet filter {\n\tcounter ns0insl {}\n\n\tchain pre {\n\t\ttype filter hook prerouting priority -400; policy accept;\n\t\tip saddr 10.0.2.2 counter name \"ns0insl\"\n\t}\n}\nEOF\n\nsleep 3\n# test basic connectivity\nfor i in 1 2; do\n  ip netns exec \"$ns0\" ping -c 1 -q 10.0.$i.99 > /dev/null\n  if [ $? -ne 0 ];then\n  \techo \"ERROR: Could not reach other namespace(s)\" 1>&2\n\tret=1\n  fi\n\n  ip netns exec \"$ns0\" ping -c 1 -q dead:$i::99 > /dev/null\n  if [ $? -ne 0 ];then\n\techo \"ERROR: Could not reach other namespace(s) via ipv6\" 1>&2\n\tret=1\n  fi\n  check_counters ns$i-$sfx\n  if [ $? -ne 0 ]; then\n\tret=1\n  fi\n\n  check_ns0_counters ns$i\n  if [ $? -ne 0 ]; then\n\tret=1\n  fi\n  reset_counters\ndone\n\nif [ $ret -eq 0 ];then\n\techo \"PASS: netns routing/connectivity: $ns0 can reach $ns1 and $ns2\"\nfi\n\nreset_counters\ntest_local_dnat ip\ntest_local_dnat6 ip6\n\nreset_counters\ntest_local_dnat_portonly inet 10.0.1.99\n\nreset_counters\n$test_inet_nat && test_local_dnat inet\n$test_inet_nat && test_local_dnat6 inet\n\nfor flags in \"\" \"fully-random\"; do\nreset_counters\ntest_masquerade ip $flags\ntest_masquerade6 ip6 $flags\nreset_counters\n$test_inet_nat && test_masquerade inet $flags\n$test_inet_nat && test_masquerade6 inet $flags\ndone\n\nreset_counters\ntest_redirect ip\ntest_redirect6 ip6\nreset_counters\n$test_inet_nat && test_redirect inet\n$test_inet_nat && test_redirect6 inet\n\ntest_port_shadowing\ntest_stateless_nat_ip\n\nif [ $ret -ne 0 ];then\n\techo -n \"FAIL: \"\n\tnft --version\nfi\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}