{
  "module_name": "nft_synproxy.sh",
  "hash_id": "16cb712fad06019a6a593957ebff93a1cff95696da47bf38d4ba41a12148b86c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/nft_synproxy.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nret=0\n\nrnd=$(mktemp -u XXXXXXXX)\nnsr=\"nsr-$rnd\"\t# synproxy machine\nns1=\"ns1-$rnd\"  # iperf client\nns2=\"ns2-$rnd\"  # iperf server\n\nchecktool (){\n\tif ! $1 > /dev/null 2>&1; then\n\t\techo \"SKIP: Could not $2\"\n\t\texit $ksft_skip\n\tfi\n}\n\nchecktool \"nft --version\" \"run test without nft tool\"\nchecktool \"ip -Version\" \"run test without ip tool\"\nchecktool \"iperf3 --version\" \"run test without iperf3\"\nchecktool \"ip netns add $nsr\" \"create net namespace\"\n\nmodprobe -q nf_conntrack\n\nip netns add $ns1\nip netns add $ns2\n\ncleanup() {\n\tip netns pids $ns1 | xargs kill 2>/dev/null\n\tip netns pids $ns2 | xargs kill 2>/dev/null\n\tip netns del $ns1\n\tip netns del $ns2\n\n\tip netns del $nsr\n}\n\ntrap cleanup EXIT\n\nip link add veth0 netns $nsr type veth peer name eth0 netns $ns1\nip link add veth1 netns $nsr type veth peer name eth0 netns $ns2\n\nfor dev in lo veth0 veth1; do\nip -net $nsr link set $dev up\ndone\n\nip -net $nsr addr add 10.0.1.1/24 dev veth0\nip -net $nsr addr add 10.0.2.1/24 dev veth1\n\nip netns exec $nsr sysctl -q net.ipv4.conf.veth0.forwarding=1\nip netns exec $nsr sysctl -q net.ipv4.conf.veth1.forwarding=1\nip netns exec $nsr sysctl -q net.netfilter.nf_conntrack_tcp_loose=0\n\nfor n in $ns1 $ns2; do\n  ip -net $n link set lo up\n  ip -net $n link set eth0 up\ndone\nip -net $ns1 addr add 10.0.1.99/24 dev eth0\nip -net $ns2 addr add 10.0.2.99/24 dev eth0\nip -net $ns1 route add default via 10.0.1.1\nip -net $ns2 route add default via 10.0.2.1\n\n# test basic connectivity\nif ! ip netns exec $ns1 ping -c 1 -q 10.0.2.99 > /dev/null; then\n  echo \"ERROR: $ns1 cannot reach $ns2\" 1>&2\n  exit 1\nfi\n\nif ! ip netns exec $ns2 ping -c 1 -q 10.0.1.99 > /dev/null; then\n  echo \"ERROR: $ns2 cannot reach $ns1\" 1>&2\n  exit 1\nfi\n\nip netns exec $ns2 iperf3 -s > /dev/null 2>&1 &\n# ip netns exec $nsr tcpdump -vvv -n -i veth1 tcp | head -n 10 &\n\nsleep 1\n\nip netns exec $nsr nft -f - <<EOF\ntable inet filter {\n   chain prerouting {\n      type filter hook prerouting priority -300; policy accept;\n      meta iif veth0 tcp flags syn counter notrack\n   }\n\n  chain forward {\n      type filter hook forward priority 0; policy accept;\n\n      ct state new,established counter accept\n\n      meta iif veth0 meta l4proto tcp ct state untracked,invalid synproxy mss 1460 sack-perm timestamp\n\n      ct state invalid counter drop\n\n      # make ns2 unreachable w.o. tcp synproxy\n      tcp flags syn counter drop\n   }\n}\nEOF\nif [ $? -ne 0 ]; then\n\techo \"SKIP: Cannot add nft synproxy\"\n\texit $ksft_skip\nfi\n\nip netns exec $ns1 timeout 5 iperf3 -c 10.0.2.99 -n $((1 * 1024 * 1024)) > /dev/null\n\nif [ $? -ne 0 ]; then\n\techo \"FAIL: iperf3 returned an error\" 1>&2\n\tret=$?\n\tip netns exec $nsr nft list ruleset\nelse\n\techo \"PASS: synproxy connection successful\"\nfi\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}