{
  "module_name": "conntrack_vrf.sh",
  "hash_id": "6a42d506da4151f599554731ac21570ceae7947aa5f4ec9e87cf59a6aeaa3f59",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/conntrack_vrf.sh",
  "human_readable_source": "#!/bin/sh\n\n# This script demonstrates interaction of conntrack and vrf.\n# The vrf driver calls the netfilter hooks again, with oif/iif\n# pointing at the VRF device.\n#\n# For ingress, this means first iteration has iifname of lower/real\n# device.  In this script, thats veth0.\n# Second iteration is iifname set to vrf device, tvrf in this script.\n#\n# For egress, this is reversed: first iteration has the vrf device,\n# second iteration is done with the lower/real/veth0 device.\n#\n# test_ct_zone_in demonstrates unexpected change of nftables\n# behavior # caused by commit 09e856d54bda5f28 \"vrf: Reset skb conntrack\n# connection on VRF rcv\"\n#\n# It was possible to assign conntrack zone to a packet (or mark it for\n# `notracking`) in the prerouting chain before conntrack, based on real iif.\n#\n# After the change, the zone assignment is lost and the zone is assigned based\n# on the VRF master interface (in case such a rule exists).\n# assignment is lost. Instead, assignment based on the `iif` matching\n# Thus it is impossible to distinguish packets based on the original\n# interface.\n#\n# test_masquerade_vrf and test_masquerade_veth0 demonstrate the problem\n# that was supposed to be fixed by the commit mentioned above to make sure\n# that any fix to test case 1 won't break masquerade again.\n\nksft_skip=4\n\nIP0=172.30.30.1\nIP1=172.30.30.2\nPFXL=30\nret=0\n\nsfx=$(mktemp -u \"XXXXXXXX\")\nns0=\"ns0-$sfx\"\nns1=\"ns1-$sfx\"\n\ncleanup()\n{\n\tip netns pids $ns0 | xargs kill 2>/dev/null\n\tip netns pids $ns1 | xargs kill 2>/dev/null\n\n\tip netns del $ns0 $ns1\n}\n\nnft --version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without nft tool\"\n\texit $ksft_skip\nfi\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nip netns add \"$ns0\"\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not create net namespace $ns0\"\n\texit $ksft_skip\nfi\nip netns add \"$ns1\"\n\ntrap cleanup EXIT\n\nip netns exec $ns0 sysctl -q -w net.ipv4.conf.default.rp_filter=0\nip netns exec $ns0 sysctl -q -w net.ipv4.conf.all.rp_filter=0\nip netns exec $ns0 sysctl -q -w net.ipv4.conf.all.rp_filter=0\n\nip link add veth0 netns \"$ns0\" type veth peer name veth0 netns \"$ns1\" > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not add veth device\"\n\texit $ksft_skip\nfi\n\nip -net $ns0 li add tvrf type vrf table 9876\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not add vrf device\"\n\texit $ksft_skip\nfi\n\nip -net $ns0 li set lo up\n\nip -net $ns0 li set veth0 master tvrf\nip -net $ns0 li set tvrf up\nip -net $ns0 li set veth0 up\nip -net $ns1 li set veth0 up\n\nip -net $ns0 addr add $IP0/$PFXL dev veth0\nip -net $ns1 addr add $IP1/$PFXL dev veth0\n\nip netns exec $ns1 iperf3 -s > /dev/null 2>&1&\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not start iperf3\"\n\texit $ksft_skip\nfi\n\n# test vrf ingress handling.\n# The incoming connection should be placed in conntrack zone 1,\n# as decided by the first iteration of the ruleset.\ntest_ct_zone_in()\n{\nip netns exec $ns0 nft -f - <<EOF\ntable testct {\n\tchain rawpre {\n\t\ttype filter hook prerouting priority raw;\n\n\t\tiif { veth0, tvrf } counter meta nftrace set 1\n\t\tiif veth0 counter ct zone set 1 counter return\n\t\tiif tvrf counter ct zone set 2 counter return\n\t\tip protocol icmp counter\n\t\tnotrack counter\n\t}\n\n\tchain rawout {\n\t\ttype filter hook output priority raw;\n\n\t\toif veth0 counter ct zone set 1 counter return\n\t\toif tvrf counter ct zone set 2 counter return\n\t\tnotrack counter\n\t}\n}\nEOF\n\tip netns exec $ns1 ping -W 1 -c 1 -I veth0 $IP0 > /dev/null\n\n\t# should be in zone 1, not zone 2\n\tcount=$(ip netns exec $ns0 conntrack -L -s $IP1 -d $IP0 -p icmp --zone 1 2>/dev/null | wc -l)\n\tif [ $count -eq 1 ]; then\n\t\techo \"PASS: entry found in conntrack zone 1\"\n\telse\n\t\techo \"FAIL: entry not found in conntrack zone 1\"\n\t\tcount=$(ip netns exec $ns0 conntrack -L -s $IP1 -d $IP0 -p icmp --zone 2 2> /dev/null | wc -l)\n\t\tif [ $count -eq 1 ]; then\n\t\t\techo \"FAIL: entry found in zone 2 instead\"\n\t\telse\n\t\t\techo \"FAIL: entry not in zone 1 or 2, dumping table\"\n\t\t\tip netns exec $ns0 conntrack -L\n\t\t\tip netns exec $ns0 nft list ruleset\n\t\tfi\n\tfi\n}\n\n# add masq rule that gets evaluated w. outif set to vrf device.\n# This tests the first iteration of the packet through conntrack,\n# oifname is the vrf device.\ntest_masquerade_vrf()\n{\n\tlocal qdisc=$1\n\n\tif [ \"$qdisc\" != \"default\" ]; then\n\t\ttc -net $ns0 qdisc add dev tvrf root $qdisc\n\tfi\n\n\tip netns exec $ns0 conntrack -F 2>/dev/null\n\nip netns exec $ns0 nft -f - <<EOF\nflush ruleset\ntable ip nat {\n\tchain rawout {\n\t\ttype filter hook output priority raw;\n\n\t\toif tvrf ct state untracked counter\n\t}\n\tchain postrouting2 {\n\t\ttype filter hook postrouting priority mangle;\n\n\t\toif tvrf ct state untracked counter\n\t}\n\tchain postrouting {\n\t\ttype nat hook postrouting priority 0;\n\t\t# NB: masquerade should always be combined with 'oif(name) bla',\n\t\t# lack of this is intentional here, we want to exercise double-snat.\n\t\tip saddr 172.30.30.0/30 counter masquerade random\n\t}\n}\nEOF\n\tip netns exec $ns0 ip vrf exec tvrf iperf3 -t 1 -c $IP1 >/dev/null\n\tif [ $? -ne 0 ]; then\n\t\techo \"FAIL: iperf3 connect failure with masquerade + sport rewrite on vrf device\"\n\t\tret=1\n\t\treturn\n\tfi\n\n\t# must also check that nat table was evaluated on second (lower device) iteration.\n\tip netns exec $ns0 nft list table ip nat |grep -q 'counter packets 2' &&\n\tip netns exec $ns0 nft list table ip nat |grep -q 'untracked counter packets [1-9]'\n\tif [ $? -eq 0 ]; then\n\t\techo \"PASS: iperf3 connect with masquerade + sport rewrite on vrf device ($qdisc qdisc)\"\n\telse\n\t\techo \"FAIL: vrf rules have unexpected counter value\"\n\t\tret=1\n\tfi\n\n\tif [ \"$qdisc\" != \"default\" ]; then\n\t\ttc -net $ns0 qdisc del dev tvrf root\n\tfi\n}\n\n# add masq rule that gets evaluated w. outif set to veth device.\n# This tests the 2nd iteration of the packet through conntrack,\n# oifname is the lower device (veth0 in this case).\ntest_masquerade_veth()\n{\n\tip netns exec $ns0 conntrack -F 2>/dev/null\nip netns exec $ns0 nft -f - <<EOF\nflush ruleset\ntable ip nat {\n\tchain postrouting {\n\t\ttype nat hook postrouting priority 0;\n\t\tmeta oif veth0 ip saddr 172.30.30.0/30 counter masquerade random\n\t}\n}\nEOF\n\tip netns exec $ns0 ip vrf exec tvrf iperf3 -t 1 -c $IP1 > /dev/null\n\tif [ $? -ne 0 ]; then\n\t\techo \"FAIL: iperf3 connect failure with masquerade + sport rewrite on veth device\"\n\t\tret=1\n\t\treturn\n\tfi\n\n\t# must also check that nat table was evaluated on second (lower device) iteration.\n\tip netns exec $ns0 nft list table ip nat |grep -q 'counter packets 2'\n\tif [ $? -eq 0 ]; then\n\t\techo \"PASS: iperf3 connect with masquerade + sport rewrite on veth device\"\n\telse\n\t\techo \"FAIL: vrf masq rule has unexpected counter value\"\n\t\tret=1\n\tfi\n}\n\ntest_ct_zone_in\ntest_masquerade_vrf \"default\"\ntest_masquerade_vrf \"pfifo\"\ntest_masquerade_veth\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}