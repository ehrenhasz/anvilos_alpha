{
  "module_name": "nft_trans_stress.sh",
  "hash_id": "5e3602f0c7d26bb9e432739903a090f87ecdfb4a455f8ebe875b1975398a8aae",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/nft_trans_stress.sh",
  "human_readable_source": "#!/bin/bash\n#\n# This test is for stress-testing the nf_tables config plane path vs.\n# packet path processing: Make sure we never release rules that are\n# still visible to other cpus.\n#\n# set -e\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\ntestns=testns-$(mktemp -u \"XXXXXXXX\")\ntmp=\"\"\n\ntables=\"foo bar baz quux\"\nglobal_ret=0\neret=0\nlret=0\n\ncleanup() {\n\tip netns pids \"$testns\" | xargs kill 2>/dev/null\n\tip netns del \"$testns\"\n\n\trm -f \"$tmp\"\n}\n\ncheck_result()\n{\n\tlocal r=$1\n\tlocal OK=\"PASS\"\n\n\tif [ $r -ne 0 ] ;then\n\t\tOK=\"FAIL\"\n\t\tglobal_ret=$r\n\tfi\n\n\techo \"$OK: nft $2 test returned $r\"\n\n\teret=0\n}\n\nnft --version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without nft tool\"\n\texit $ksft_skip\nfi\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\ntrap cleanup EXIT\ntmp=$(mktemp)\n\nfor table in $tables; do\n\techo add table inet \"$table\" >> \"$tmp\"\n\techo flush table inet \"$table\" >> \"$tmp\"\n\n\techo \"add chain inet $table INPUT { type filter hook input priority 0; }\" >> \"$tmp\"\n\techo \"add chain inet $table OUTPUT { type filter hook output priority 0; }\" >> \"$tmp\"\n\tfor c in $(seq 1 400); do\n\t\tchain=$(printf \"chain%03u\" \"$c\")\n\t\techo \"add chain inet $table $chain\" >> \"$tmp\"\n\tdone\n\n\tfor c in $(seq 1 400); do\n\t\tchain=$(printf \"chain%03u\" \"$c\")\n\t\tfor BASE in INPUT OUTPUT; do\n\t\t\techo \"add rule inet $table $BASE counter jump $chain\" >> \"$tmp\"\n\t\tdone\n\t\techo \"add rule inet $table $chain counter return\" >> \"$tmp\"\n\tdone\ndone\n\nip netns add \"$testns\"\nip -netns \"$testns\" link set lo up\n\nlscpu | grep ^CPU\\(s\\): | ( read cpu cpunum ;\ncpunum=$((cpunum-1))\nfor i in $(seq 0 $cpunum);do\n\tmask=$(printf 0x%x $((1<<$i)))\n        ip netns exec \"$testns\" taskset $mask ping -4 127.0.0.1 -fq > /dev/null &\n        ip netns exec \"$testns\" taskset $mask ping -6 ::1 -fq > /dev/null &\ndone)\n\nsleep 1\n\nip netns exec \"$testns\" nft -f \"$tmp\"\nfor i in $(seq 1 10) ; do ip netns exec \"$testns\" nft -f \"$tmp\" & done\n\nfor table in $tables;do\n\trandsleep=$((RANDOM%2))\n\tsleep $randsleep\n\tip netns exec \"$testns\" nft delete table inet $table\n\tlret=$?\n\tif [ $lret -ne 0 ]; then\n\t\teret=$lret\n\tfi\ndone\n\ncheck_result $eret \"add/delete\"\n\nfor i in $(seq 1 10) ; do\n\t(echo \"flush ruleset\"; cat \"$tmp\") | ip netns exec \"$testns\" nft -f /dev/stdin\n\n\tlret=$?\n\tif [ $lret -ne 0 ]; then\n\t\teret=$lret\n\tfi\ndone\n\ncheck_result $eret \"reload\"\n\nfor i in $(seq 1 10) ; do\n\t(echo \"flush ruleset\"; cat \"$tmp\"\n\t echo \"insert rule inet foo INPUT meta nftrace set 1\"\n\t echo \"insert rule inet foo OUTPUT meta nftrace set 1\"\n\t ) | ip netns exec \"$testns\" nft -f /dev/stdin\n\tlret=$?\n\tif [ $lret -ne 0 ]; then\n\t\teret=$lret\n\tfi\n\n\t(echo \"flush ruleset\"; cat \"$tmp\"\n\t ) | ip netns exec \"$testns\" nft -f /dev/stdin\n\n\tlret=$?\n\tif [ $lret -ne 0 ]; then\n\t\teret=$lret\n\tfi\ndone\n\ncheck_result $eret \"add/delete with nftrace enabled\"\n\necho \"insert rule inet foo INPUT meta nftrace set 1\" >> $tmp\necho \"insert rule inet foo OUTPUT meta nftrace set 1\" >> $tmp\n\nfor i in $(seq 1 10) ; do\n\t(echo \"flush ruleset\"; cat \"$tmp\") | ip netns exec \"$testns\" nft -f /dev/stdin\n\n\tlret=$?\n\tif [ $lret -ne 0 ]; then\n\t\teret=1\n\tfi\ndone\n\ncheck_result $lret \"add/delete with nftrace enabled\"\n\nexit $global_ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}