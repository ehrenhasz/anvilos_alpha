{
  "module_name": "audit_logread.c",
  "hash_id": "f74b9f2ffb4dada9d41d1e2be9690151defb41449bd148a04969493eccb88497",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/audit_logread.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <linux/audit.h>\n#include <linux/netlink.h>\n\nstatic int fd;\n\n#define MAX_AUDIT_MESSAGE_LENGTH\t8970\nstruct audit_message {\n\tstruct nlmsghdr nlh;\n\tunion {\n\t\tstruct audit_status s;\n\t\tchar data[MAX_AUDIT_MESSAGE_LENGTH];\n\t} u;\n};\n\nint audit_recv(int fd, struct audit_message *rep)\n{\n\tstruct sockaddr_nl addr;\n\tsocklen_t addrlen = sizeof(addr);\n\tint ret;\n\n\tdo {\n\t\tret = recvfrom(fd, rep, sizeof(*rep), 0,\n\t\t\t       (struct sockaddr *)&addr, &addrlen);\n\t} while (ret < 0 && errno == EINTR);\n\n\tif (ret < 0 ||\n\t    addrlen != sizeof(addr) ||\n\t    addr.nl_pid != 0 ||\n\t    rep->nlh.nlmsg_type == NLMSG_ERROR)  \n\t\treturn -1;\n\n\treturn ret;\n}\n\nint audit_send(int fd, uint16_t type, uint32_t key, uint32_t val)\n{\n\tstatic int seq = 0;\n\tstruct audit_message msg = {\n\t\t.nlh = {\n\t\t\t.nlmsg_len   = NLMSG_SPACE(sizeof(msg.u.s)),\n\t\t\t.nlmsg_type  = type,\n\t\t\t.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK,\n\t\t\t.nlmsg_seq   = ++seq,\n\t\t},\n\t\t.u.s = {\n\t\t\t.mask    = key,\n\t\t\t.enabled = key == AUDIT_STATUS_ENABLED ? val : 0,\n\t\t\t.pid     = key == AUDIT_STATUS_PID ? val : 0,\n\t\t}\n\t};\n\tstruct sockaddr_nl addr = {\n\t\t.nl_family = AF_NETLINK,\n\t};\n\tint ret;\n\n\tdo {\n\t\tret = sendto(fd, &msg, msg.nlh.nlmsg_len, 0,\n\t\t\t     (struct sockaddr *)&addr, sizeof(addr));\n\t} while (ret < 0 && errno == EINTR);\n\n\tif (ret != (int)msg.nlh.nlmsg_len)\n\t\treturn -1;\n\treturn 0;\n}\n\nint audit_set(int fd, uint32_t key, uint32_t val)\n{\n\tstruct audit_message rep = { 0 };\n\tint ret;\n\n\tret = audit_send(fd, AUDIT_SET, key, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = audit_recv(fd, &rep);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nint readlog(int fd)\n{\n\tstruct audit_message rep = { 0 };\n\tint ret = audit_recv(fd, &rep);\n\tconst char *sep = \"\";\n\tchar *k, *v;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (rep.nlh.nlmsg_type != AUDIT_NETFILTER_CFG)\n\t\treturn 0;\n\n\t \n\tstrtok(rep.u.data, \" \");\n\n\twhile ((k = strtok(NULL, \"=\"))) {\n\t\tv = strtok(NULL, \" \");\n\n\t\t \n\t\tif (!strcmp(k, \"pid\") ||\n\t\t    !strcmp(k, \"comm\") ||\n\t\t    !strcmp(k, \"subj\"))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!strcmp(k, \"table\"))\n\t\t\t*strchrnul(v, ':') = '\\0';\n\n\t\tprintf(\"%s%s=%s\", sep, k, v);\n\t\tsep = \" \";\n\t}\n\tif (*sep) {\n\t\tprintf(\"\\n\");\n\t\tfflush(stdout);\n\t}\n\treturn 0;\n}\n\nvoid cleanup(int sig)\n{\n\taudit_set(fd, AUDIT_STATUS_ENABLED, 0);\n\tclose(fd);\n\tif (sig)\n\t\texit(0);\n}\n\nint main(int argc, char **argv)\n{\n\tstruct sigaction act = {\n\t\t.sa_handler = cleanup,\n\t};\n\n\tfd = socket(PF_NETLINK, SOCK_RAW, NETLINK_AUDIT);\n\tif (fd < 0) {\n\t\tperror(\"Can't open netlink socket\");\n\t\treturn -1;\n\t}\n\n\tif (sigaction(SIGTERM, &act, NULL) < 0 ||\n\t    sigaction(SIGINT, &act, NULL) < 0) {\n\t\tperror(\"Can't set signal handler\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\taudit_set(fd, AUDIT_STATUS_ENABLED, 1);\n\taudit_set(fd, AUDIT_STATUS_PID, getpid());\n\n\twhile (1)\n\t\treadlog(fd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}