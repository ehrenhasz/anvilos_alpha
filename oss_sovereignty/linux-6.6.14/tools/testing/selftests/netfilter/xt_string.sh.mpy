{
  "module_name": "xt_string.sh",
  "hash_id": "ef8d733d9b6ea1ebcd06756af73f5903e721d10679350ff8faf1710ab8f048b0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/xt_string.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# return code to signal skipped test\nksft_skip=4\nrc=0\n\nif ! iptables --version >/dev/null 2>&1; then\n\techo \"SKIP: Test needs iptables\"\n\texit $ksft_skip\nfi\nif ! ip -V >/dev/null 2>&1; then\n\techo \"SKIP: Test needs iproute2\"\n\texit $ksft_skip\nfi\nif ! nc -h >/dev/null 2>&1; then\n\techo \"SKIP: Test needs netcat\"\n\texit $ksft_skip\nfi\n\npattern=\"foo bar baz\"\npatlen=11\nhdrlen=$((20 + 8)) # IPv4 + UDP\nns=\"ns-$(mktemp -u XXXXXXXX)\"\ntrap 'ip netns del $ns' EXIT\nip netns add \"$ns\"\nip -net \"$ns\" link add d0 type dummy\nip -net \"$ns\" link set d0 up\nip -net \"$ns\" addr add 10.1.2.1/24 dev d0\n\n#ip netns exec \"$ns\" tcpdump -npXi d0 &\n#tcpdump_pid=$!\n#trap 'kill $tcpdump_pid; ip netns del $ns' EXIT\n\nadd_rule() { # (alg, from, to)\n\tip netns exec \"$ns\" \\\n\t\tiptables -A OUTPUT -o d0 -m string \\\n\t\t\t--string \"$pattern\" --algo $1 --from $2 --to $3\n}\nshowrules() { # ()\n\tip netns exec \"$ns\" iptables -v -S OUTPUT | grep '^-A'\n}\nzerorules() {\n\tip netns exec \"$ns\" iptables -Z OUTPUT\n}\ncountrule() { # (pattern)\n\tshowrules | grep -c -- \"$*\"\n}\nsend() { # (offset)\n\t( for ((i = 0; i < $1 - $hdrlen; i++)); do\n\t\tprintf \" \"\n\t  done\n\t  printf \"$pattern\"\n\t) | ip netns exec \"$ns\" nc -w 1 -u 10.1.2.2 27374\n}\n\nadd_rule bm 1000 1500\nadd_rule bm 1400 1600\nadd_rule kmp 1000 1500\nadd_rule kmp 1400 1600\n\nzerorules\nsend 0\nsend $((1000 - $patlen))\nif [ $(countrule -c 0 0) -ne 4 ]; then\n\techo \"FAIL: rules match data before --from\"\n\tshowrules\n\t((rc--))\nfi\n\nzerorules\nsend 1000\nsend $((1400 - $patlen))\nif [ $(countrule -c 2) -ne 2 ]; then\n\techo \"FAIL: only two rules should match at low offset\"\n\tshowrules\n\t((rc--))\nfi\n\nzerorules\nsend $((1500 - $patlen))\nif [ $(countrule -c 1) -ne 4 ]; then\n\techo \"FAIL: all rules should match at end of packet\"\n\tshowrules\n\t((rc--))\nfi\n\nzerorules\nsend 1495\nif [ $(countrule -c 1) -ne 1 ]; then\n\techo \"FAIL: only kmp with proper --to should match pattern spanning fragments\"\n\tshowrules\n\t((rc--))\nfi\n\nzerorules\nsend 1500\nif [ $(countrule -c 1) -ne 2 ]; then\n\techo \"FAIL: two rules should match pattern at start of second fragment\"\n\tshowrules\n\t((rc--))\nfi\n\nzerorules\nsend $((1600 - $patlen))\nif [ $(countrule -c 1) -ne 2 ]; then\n\techo \"FAIL: two rules should match pattern at end of largest --to\"\n\tshowrules\n\t((rc--))\nfi\n\nzerorules\nsend $((1600 - $patlen + 1))\nif [ $(countrule -c 1) -ne 0 ]; then\n\techo \"FAIL: no rules should match pattern extending largest --to\"\n\tshowrules\n\t((rc--))\nfi\n\nzerorules\nsend 1600\nif [ $(countrule -c 1) -ne 0 ]; then\n\techo \"FAIL: no rule should match pattern past largest --to\"\n\tshowrules\n\t((rc--))\nfi\n\nexit $rc\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}