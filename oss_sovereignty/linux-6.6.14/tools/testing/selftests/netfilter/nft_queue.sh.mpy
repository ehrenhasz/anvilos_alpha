{
  "module_name": "nft_queue.sh",
  "hash_id": "cfefbea6182d08b53d2a848d9d7cdfec88fe52f94f0b294be3d32c95e3354027",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/nft_queue.sh",
  "human_readable_source": "#!/bin/bash\n#\n# This tests nf_queue:\n# 1. can process packets from all hooks\n# 2. support running nfqueue from more than one base chain\n#\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nret=0\n\nsfx=$(mktemp -u \"XXXXXXXX\")\nns1=\"ns1-$sfx\"\nns2=\"ns2-$sfx\"\nnsrouter=\"nsrouter-$sfx\"\ntimeout=4\n\ncleanup()\n{\n\tip netns pids ${ns1} | xargs kill 2>/dev/null\n\tip netns pids ${ns2} | xargs kill 2>/dev/null\n\tip netns pids ${nsrouter} | xargs kill 2>/dev/null\n\n\tip netns del ${ns1}\n\tip netns del ${ns2}\n\tip netns del ${nsrouter}\n\trm -f \"$TMPFILE0\"\n\trm -f \"$TMPFILE1\"\n\trm -f \"$TMPFILE2\" \"$TMPFILE3\"\n}\n\nnft --version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without nft tool\"\n\texit $ksft_skip\nfi\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nip netns add ${nsrouter}\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not create net namespace\"\n\texit $ksft_skip\nfi\n\nTMPFILE0=$(mktemp)\nTMPFILE1=$(mktemp)\nTMPFILE2=$(mktemp)\nTMPFILE3=$(mktemp)\ntrap cleanup EXIT\n\nip netns add ${ns1}\nip netns add ${ns2}\n\nip link add veth0 netns ${nsrouter} type veth peer name eth0 netns ${ns1} > /dev/null 2>&1\nif [ $? -ne 0 ];then\n    echo \"SKIP: No virtual ethernet pair device support in kernel\"\n    exit $ksft_skip\nfi\nip link add veth1 netns ${nsrouter} type veth peer name eth0 netns ${ns2}\n\nip -net ${nsrouter} link set lo up\nip -net ${nsrouter} link set veth0 up\nip -net ${nsrouter} addr add 10.0.1.1/24 dev veth0\nip -net ${nsrouter} addr add dead:1::1/64 dev veth0\n\nip -net ${nsrouter} link set veth1 up\nip -net ${nsrouter} addr add 10.0.2.1/24 dev veth1\nip -net ${nsrouter} addr add dead:2::1/64 dev veth1\n\nip -net ${ns1} link set lo up\nip -net ${ns1} link set eth0 up\n\nip -net ${ns2} link set lo up\nip -net ${ns2} link set eth0 up\n\nip -net ${ns1} addr add 10.0.1.99/24 dev eth0\nip -net ${ns1} addr add dead:1::99/64 dev eth0\nip -net ${ns1} route add default via 10.0.1.1\nip -net ${ns1} route add default via dead:1::1\n\nip -net ${ns2} addr add 10.0.2.99/24 dev eth0\nip -net ${ns2} addr add dead:2::99/64 dev eth0\nip -net ${ns2} route add default via 10.0.2.1\nip -net ${ns2} route add default via dead:2::1\n\nload_ruleset() {\n\tlocal name=$1\n\tlocal prio=$2\n\nip netns exec ${nsrouter} nft -f /dev/stdin <<EOF\ntable inet $name {\n\tchain nfq {\n\t\tip protocol icmp queue bypass\n\t\ticmpv6 type { \"echo-request\", \"echo-reply\" } queue num 1 bypass\n\t}\n\tchain pre {\n\t\ttype filter hook prerouting priority $prio; policy accept;\n\t\tjump nfq\n\t}\n\tchain input {\n\t\ttype filter hook input priority $prio; policy accept;\n\t\tjump nfq\n\t}\n\tchain forward {\n\t\ttype filter hook forward priority $prio; policy accept;\n\t\ttcp dport 12345 queue num 2\n\t\tjump nfq\n\t}\n\tchain output {\n\t\ttype filter hook output priority $prio; policy accept;\n\t\ttcp dport 12345 queue num 3\n\t\ttcp sport 23456 queue num 3\n\t\tjump nfq\n\t}\n\tchain post {\n\t\ttype filter hook postrouting priority $prio; policy accept;\n\t\tjump nfq\n\t}\n}\nEOF\n}\n\nload_counter_ruleset() {\n\tlocal prio=$1\n\nip netns exec ${nsrouter} nft -f /dev/stdin <<EOF\ntable inet countrules {\n\tchain pre {\n\t\ttype filter hook prerouting priority $prio; policy accept;\n\t\tcounter\n\t}\n\tchain input {\n\t\ttype filter hook input priority $prio; policy accept;\n\t\tcounter\n\t}\n\tchain forward {\n\t\ttype filter hook forward priority $prio; policy accept;\n\t\tcounter\n\t}\n\tchain output {\n\t\ttype filter hook output priority $prio; policy accept;\n\t\tcounter\n\t}\n\tchain post {\n\t\ttype filter hook postrouting priority $prio; policy accept;\n\t\tcounter\n\t}\n}\nEOF\n}\n\ntest_ping() {\n  ip netns exec ${ns1} ping -c 1 -q 10.0.2.99 > /dev/null\n  if [ $? -ne 0 ];then\n\treturn 1\n  fi\n\n  ip netns exec ${ns1} ping -c 1 -q dead:2::99 > /dev/null\n  if [ $? -ne 0 ];then\n\treturn 1\n  fi\n\n  return 0\n}\n\ntest_ping_router() {\n  ip netns exec ${ns1} ping -c 1 -q 10.0.2.1 > /dev/null\n  if [ $? -ne 0 ];then\n\treturn 1\n  fi\n\n  ip netns exec ${ns1} ping -c 1 -q dead:2::1 > /dev/null\n  if [ $? -ne 0 ];then\n\treturn 1\n  fi\n\n  return 0\n}\n\ntest_queue_blackhole() {\n\tlocal proto=$1\n\nip netns exec ${nsrouter} nft -f /dev/stdin <<EOF\ntable $proto blackh {\n\tchain forward {\n\ttype filter hook forward priority 0; policy accept;\n\t\tqueue num 600\n\t}\n}\nEOF\n\tif [ $proto = \"ip\" ] ;then\n\t\tip netns exec ${ns1} ping -W 2 -c 1 -q 10.0.2.99 > /dev/null\n\t\tlret=$?\n\telif [ $proto = \"ip6\" ]; then\n\t\tip netns exec ${ns1} ping -W 2 -c 1 -q dead:2::99 > /dev/null\n\t\tlret=$?\n\telse\n\t\tlret=111\n\tfi\n\n\t# queue without bypass keyword should drop traffic if no listener exists.\n\tif [ $lret -eq 0 ];then\n\t\techo \"FAIL: $proto expected failure, got $lret\" 1>&2\n\t\texit 1\n\tfi\n\n\tip netns exec ${nsrouter} nft delete table $proto blackh\n\tif [ $? -ne 0 ] ;then\n\t        echo \"FAIL: $proto: Could not delete blackh table\"\n\t        exit 1\n\tfi\n\n        echo \"PASS: $proto: statement with no listener results in packet drop\"\n}\n\ntest_queue()\n{\n\tlocal expected=$1\n\tlocal last=\"\"\n\n\t# spawn nf-queue listeners\n\tip netns exec ${nsrouter} ./nf-queue -c -q 0 -t $timeout > \"$TMPFILE0\" &\n\tip netns exec ${nsrouter} ./nf-queue -c -q 1 -t $timeout > \"$TMPFILE1\" &\n\tsleep 1\n\ttest_ping\n\tret=$?\n\tif [ $ret -ne 0 ];then\n\t\techo \"FAIL: netns routing/connectivity with active listener on queue $queue: $ret\" 1>&2\n\t\texit $ret\n\tfi\n\n\ttest_ping_router\n\tret=$?\n\tif [ $ret -ne 0 ];then\n\t\techo \"FAIL: netns router unreachable listener on queue $queue: $ret\" 1>&2\n\t\texit $ret\n\tfi\n\n\twait\n\tret=$?\n\n\tfor file in $TMPFILE0 $TMPFILE1; do\n\t\tlast=$(tail -n1 \"$file\")\n\t\tif [ x\"$last\" != x\"$expected packets total\" ]; then\n\t\t\techo \"FAIL: Expected $expected packets total, but got $last\" 1>&2\n\t\t\tcat \"$file\" 1>&2\n\n\t\t\tip netns exec ${nsrouter} nft list ruleset\n\t\t\texit 1\n\t\tfi\n\tdone\n\n\techo \"PASS: Expected and received $last\"\n}\n\ntest_tcp_forward()\n{\n\tip netns exec ${nsrouter} ./nf-queue -q 2 -t $timeout &\n\tlocal nfqpid=$!\n\n\ttmpfile=$(mktemp) || exit 1\n\tdd conv=sparse status=none if=/dev/zero bs=1M count=200 of=$tmpfile\n\tip netns exec ${ns2} nc -w 5 -l -p 12345 <\"$tmpfile\" >/dev/null &\n\tlocal rpid=$!\n\n\tsleep 1\n\tip netns exec ${ns1} nc -w 5 10.0.2.99 12345 <\"$tmpfile\" >/dev/null &\n\n\trm -f \"$tmpfile\"\n\n\twait $rpid\n\twait $lpid\n\t[ $? -eq 0 ] && echo \"PASS: tcp and nfqueue in forward chain\"\n}\n\ntest_tcp_localhost()\n{\n\ttmpfile=$(mktemp) || exit 1\n\n\tdd conv=sparse status=none if=/dev/zero bs=1M count=200 of=$tmpfile\n\tip netns exec ${nsrouter} nc -w 5 -l -p 12345 <\"$tmpfile\" >/dev/null &\n\tlocal rpid=$!\n\n\tip netns exec ${nsrouter} ./nf-queue -q 3 -t $timeout &\n\tlocal nfqpid=$!\n\n\tsleep 1\n\tip netns exec ${nsrouter} nc -w 5 127.0.0.1 12345 <\"$tmpfile\" > /dev/null\n\trm -f \"$tmpfile\"\n\n\twait $rpid\n\t[ $? -eq 0 ] && echo \"PASS: tcp via loopback\"\n\twait 2>/dev/null\n}\n\ntest_tcp_localhost_connectclose()\n{\n\ttmpfile=$(mktemp) || exit 1\n\n\tip netns exec ${nsrouter} ./connect_close -p 23456 -t $timeout &\n\n\tip netns exec ${nsrouter} ./nf-queue -q 3 -t $timeout &\n\tlocal nfqpid=$!\n\n\tsleep 1\n\trm -f \"$tmpfile\"\n\n\twait $rpid\n\t[ $? -eq 0 ] && echo \"PASS: tcp via loopback with connect/close\"\n\twait 2>/dev/null\n}\n\ntest_tcp_localhost_requeue()\n{\nip netns exec ${nsrouter} nft -f /dev/stdin <<EOF\nflush ruleset\ntable inet filter {\n\tchain output {\n\t\ttype filter hook output priority 0; policy accept;\n\t\ttcp dport 12345 limit rate 1/second burst 1 packets counter queue num 0\n\t}\n\tchain post {\n\t\ttype filter hook postrouting priority 0; policy accept;\n\t\ttcp dport 12345 limit rate 1/second burst 1 packets counter queue num 0\n\t}\n}\nEOF\n\ttmpfile=$(mktemp) || exit 1\n\tdd conv=sparse status=none if=/dev/zero bs=1M count=200 of=$tmpfile\n\tip netns exec ${nsrouter} nc -w 5 -l -p 12345 <\"$tmpfile\" >/dev/null &\n\tlocal rpid=$!\n\n\tip netns exec ${nsrouter} ./nf-queue -c -q 1 -t $timeout > \"$TMPFILE2\" &\n\n\t# nfqueue 1 will be called via output hook.  But this time,\n        # re-queue the packet to nfqueue program on queue 2.\n\tip netns exec ${nsrouter} ./nf-queue -G -d 150 -c -q 0 -Q 1 -t $timeout > \"$TMPFILE3\" &\n\n\tsleep 1\n\tip netns exec ${nsrouter} nc -w 5 127.0.0.1 12345 <\"$tmpfile\" > /dev/null\n\trm -f \"$tmpfile\"\n\n\twait\n\n\tif ! diff -u \"$TMPFILE2\" \"$TMPFILE3\" ; then\n\t\techo \"FAIL: lost packets during requeue?!\" 1>&2\n\t\treturn\n\tfi\n\n\techo \"PASS: tcp via loopback and re-queueing\"\n}\n\ntest_icmp_vrf() {\n\tip -net $ns1 link add tvrf type vrf table 9876\n\tif [ $? -ne 0 ];then\n\t\techo \"SKIP: Could not add vrf device\"\n\t\treturn\n\tfi\n\n\tip -net $ns1 li set eth0 master tvrf\n\tip -net $ns1 li set tvrf up\n\n\tip -net $ns1 route add 10.0.2.0/24 via 10.0.1.1 dev eth0 table 9876\nip netns exec ${ns1} nft -f /dev/stdin <<EOF\nflush ruleset\ntable inet filter {\n\tchain output {\n\t\ttype filter hook output priority 0; policy accept;\n\t\tmeta oifname \"tvrf\" icmp type echo-request counter queue num 1\n\t\tmeta oifname \"eth0\" icmp type echo-request counter queue num 1\n\t}\n\tchain post {\n\t\ttype filter hook postrouting priority 0; policy accept;\n\t\tmeta oifname \"tvrf\" icmp type echo-request counter queue num 1\n\t\tmeta oifname \"eth0\" icmp type echo-request counter queue num 1\n\t}\n}\nEOF\n\tip netns exec ${ns1} ./nf-queue -q 1 -t $timeout &\n\tlocal nfqpid=$!\n\n\tsleep 1\n\tip netns exec ${ns1} ip vrf exec tvrf ping -c 1 10.0.2.99 > /dev/null\n\n\tfor n in output post; do\n\t\tfor d in tvrf eth0; do\n\t\t\tip netns exec ${ns1} nft list chain inet filter $n | grep -q \"oifname \\\"$d\\\" icmp type echo-request counter packets 1\"\n\t\t\tif [ $? -ne 0 ] ; then\n\t\t\t\techo \"FAIL: chain $n: icmp packet counter mismatch for device $d\" 1>&2\n\t\t\t\tip netns exec ${ns1} nft list ruleset\n\t\t\t\tret=1\n\t\t\t\treturn\n\t\t\tfi\n\t\tdone\n\tdone\n\n\twait $nfqpid\n\t[ $? -eq 0 ] && echo \"PASS: icmp+nfqueue via vrf\"\n\twait 2>/dev/null\n}\n\nip netns exec ${nsrouter} sysctl net.ipv6.conf.all.forwarding=1 > /dev/null\nip netns exec ${nsrouter} sysctl net.ipv4.conf.veth0.forwarding=1 > /dev/null\nip netns exec ${nsrouter} sysctl net.ipv4.conf.veth1.forwarding=1 > /dev/null\n\nload_ruleset \"filter\" 0\n\nsleep 3\n\ntest_ping\nret=$?\nif [ $ret -eq 0 ];then\n\t# queue bypass works (rules were skipped, no listener)\n\techo \"PASS: ${ns1} can reach ${ns2}\"\nelse\n\techo \"FAIL: ${ns1} cannot reach ${ns2}: $ret\" 1>&2\n\texit $ret\nfi\n\ntest_queue_blackhole ip\ntest_queue_blackhole ip6\n\n# dummy ruleset to add base chains between the\n# queueing rules.  We don't want the second reinject\n# to re-execute the old hooks.\nload_counter_ruleset 10\n\n# we are hooking all: prerouting/input/forward/output/postrouting.\n# we ping ${ns2} from ${ns1} via ${nsrouter} using ipv4 and ipv6, so:\n# 1x icmp prerouting,forward,postrouting -> 3 queue events (6 incl. reply).\n# 1x icmp prerouting,input,output postrouting -> 4 queue events incl. reply.\n# so we expect that userspace program receives 10 packets.\ntest_queue 10\n\n# same.  We queue to a second program as well.\nload_ruleset \"filter2\" 20\ntest_queue 20\n\ntest_tcp_forward\ntest_tcp_localhost\ntest_tcp_localhost_connectclose\ntest_tcp_localhost_requeue\ntest_icmp_vrf\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}