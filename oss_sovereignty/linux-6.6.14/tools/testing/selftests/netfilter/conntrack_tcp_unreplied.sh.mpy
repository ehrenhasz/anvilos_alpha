{
  "module_name": "conntrack_tcp_unreplied.sh",
  "hash_id": "3244a3689bf786fdc9a92fc3da93e0d296878ea08d57294df8a730bb4a7cf0ac",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/conntrack_tcp_unreplied.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Check that UNREPLIED tcp conntrack will eventually timeout.\n#\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nret=0\n\nwaittime=20\nsfx=$(mktemp -u \"XXXXXXXX\")\nns1=\"ns1-$sfx\"\nns2=\"ns2-$sfx\"\n\nnft --version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without nft tool\"\n\texit $ksft_skip\nfi\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\ncleanup() {\n\tip netns pids $ns1 | xargs kill 2>/dev/null\n\tip netns pids $ns2 | xargs kill 2>/dev/null\n\n\tip netns del $ns1\n\tip netns del $ns2\n}\n\nipv4() {\n    echo -n 192.168.$1.2\n}\n\ncheck_counter()\n{\n\tns=$1\n\tname=$2\n\texpect=$3\n\tlocal lret=0\n\n\tcnt=$(ip netns exec $ns2 nft list counter inet filter \"$name\" | grep -q \"$expect\")\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: counter $name in $ns2 has unexpected value (expected $expect)\" 1>&2\n\t\tip netns exec $ns2 nft list counter inet filter \"$name\" 1>&2\n\t\tlret=1\n\tfi\n\n\treturn $lret\n}\n\n# Create test namespaces\nip netns add $ns1 || exit 1\n\ntrap cleanup EXIT\n\nip netns add $ns2 || exit 1\n\n# Connect the namespace to the host using a veth pair\nip -net $ns1 link add name veth1 type veth peer name veth2\nip -net $ns1 link set netns $ns2 dev veth2\n\nip -net $ns1 link set up dev lo\nip -net $ns2 link set up dev lo\nip -net $ns1 link set up dev veth1\nip -net $ns2 link set up dev veth2\n\nip -net $ns2 addr add 10.11.11.2/24 dev veth2\nip -net $ns2 route add default via 10.11.11.1\n\nip netns exec $ns2 sysctl -q net.ipv4.conf.veth2.forwarding=1\n\n# add a rule inside NS so we enable conntrack\nip netns exec $ns1 iptables -A INPUT -m state --state established,related -j ACCEPT\n\nip -net $ns1 addr add 10.11.11.1/24 dev veth1\nip -net $ns1 route add 10.99.99.99 via 10.11.11.2\n\n# Check connectivity works\nip netns exec $ns1 ping -q -c 2 10.11.11.2 >/dev/null || exit 1\n\nip netns exec $ns2 nc -l -p 8080 < /dev/null &\n\n# however, conntrack entries are there\n\nip netns exec $ns2 nft -f - <<EOF\ntable inet filter {\n\tcounter connreq { }\n\tcounter redir { }\n\tchain input {\n\t\ttype filter hook input priority 0; policy accept;\n\t\tct state new tcp flags syn ip daddr 10.99.99.99 tcp dport 80 counter name \"connreq\" accept\n\t\tct state new ct status dnat tcp dport 8080 counter name \"redir\" accept\n\t}\n}\nEOF\nif [ $? -ne 0 ]; then\n\techo \"ERROR: Could not load nft rules\"\n\texit 1\nfi\n\nip netns exec $ns2 sysctl -q net.netfilter.nf_conntrack_tcp_timeout_syn_sent=10\n\necho \"INFO: connect $ns1 -> $ns2 to the virtual ip\"\nip netns exec $ns1 bash -c 'while true ; do\n\tnc -p 60000 10.99.99.99 80\n\tsleep 1\n\tdone' &\n\nsleep 1\n\nip netns exec $ns2 nft -f - <<EOF\ntable inet nat {\n\tchain prerouting {\n\t\ttype nat hook prerouting priority 0; policy accept;\n\t\tip daddr 10.99.99.99 tcp dport 80 redirect to :8080\n\t}\n}\nEOF\nif [ $? -ne 0 ]; then\n\techo \"ERROR: Could not load nat redirect\"\n\texit 1\nfi\n\ncount=$(ip netns exec $ns2 conntrack -L -p tcp --dport 80 2>/dev/null | wc -l)\nif [ $count -eq 0 ]; then\n\techo \"ERROR: $ns2 did not pick up tcp connection from peer\"\n\texit 1\nfi\n\necho \"INFO: NAT redirect added in ns $ns2, waiting for $waittime seconds for nat to take effect\"\nfor i in $(seq 1 $waittime); do\n\techo -n \".\"\n\n\tsleep 1\n\n\tcount=$(ip netns exec $ns2 conntrack -L -p tcp --reply-port-src 8080 2>/dev/null | wc -l)\n\tif [ $count -gt 0 ]; then\n\t\techo\n\t\techo \"PASS: redirection took effect after $i seconds\"\n\t\tbreak\n\tfi\n\n\tm=$((i%20))\n\tif [ $m -eq 0 ]; then\n\t\techo \" waited for $i seconds\"\n\tfi\ndone\n\nexpect=\"packets 1 bytes 60\"\ncheck_counter \"$ns2\" \"redir\" \"$expect\"\nif [ $? -ne 0 ]; then\n\tret=1\nfi\n\nif [ $ret -eq 0 ];then\n\techo \"PASS: redirection counter has expected values\"\nelse\n\techo \"ERROR: no tcp connection was redirected\"\nfi\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}