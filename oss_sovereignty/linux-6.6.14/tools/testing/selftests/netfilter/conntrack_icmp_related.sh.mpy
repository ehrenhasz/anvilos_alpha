{
  "module_name": "conntrack_icmp_related.sh",
  "hash_id": "4bafd0241176b282c6935d0ba473d9803e7883aaa0b0479164522aed04ebaccf",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/conntrack_icmp_related.sh",
  "human_readable_source": "#!/bin/bash\n#\n# check that ICMP df-needed/pkttoobig icmp are set are set as related\n# state\n#\n# Setup is:\n#\n# nsclient1 -> nsrouter1 -> nsrouter2 -> nsclient2\n# MTU 1500, except for nsrouter2 <-> nsclient2 link (1280).\n# ping nsclient2 from nsclient1, checking that conntrack did set RELATED\n# 'fragmentation needed' icmp packet.\n#\n# In addition, nsrouter1 will perform IP masquerading, i.e. also\n# check the icmp errors are propagated to the correct host as per\n# nat of \"established\" icmp-echo \"connection\".\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nret=0\n\nnft --version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without nft tool\"\n\texit $ksft_skip\nfi\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\ncleanup() {\n\tfor i in 1 2;do ip netns del nsclient$i;done\n\tfor i in 1 2;do ip netns del nsrouter$i;done\n}\n\ntrap cleanup EXIT\n\nipv4() {\n    echo -n 192.168.$1.2\n}\n\nipv6 () {\n    echo -n dead:$1::2\n}\n\ncheck_counter()\n{\n\tns=$1\n\tname=$2\n\texpect=$3\n\tlocal lret=0\n\n\tcnt=$(ip netns exec $ns nft list counter inet filter \"$name\" | grep -q \"$expect\")\n\tif [ $? -ne 0 ]; then\n\t\techo \"ERROR: counter $name in $ns has unexpected value (expected $expect)\" 1>&2\n\t\tip netns exec $ns nft list counter inet filter \"$name\" 1>&2\n\t\tlret=1\n\tfi\n\n\treturn $lret\n}\n\ncheck_unknown()\n{\n\texpect=\"packets 0 bytes 0\"\n\tfor n in nsclient1 nsclient2 nsrouter1 nsrouter2; do\n\t\tcheck_counter $n \"unknown\" \"$expect\"\n\t\tif [ $? -ne 0 ] ;then\n\t\t\treturn 1\n\t\tfi\n\tdone\n\n\treturn 0\n}\n\nfor n in nsclient1 nsclient2 nsrouter1 nsrouter2; do\n  ip netns add $n\n  ip -net $n link set lo up\ndone\n\nDEV=veth0\nip link add $DEV netns nsclient1 type veth peer name eth1 netns nsrouter1\nDEV=veth0\nip link add $DEV netns nsclient2 type veth peer name eth1 netns nsrouter2\n\nDEV=veth0\nip link add $DEV netns nsrouter1 type veth peer name eth2 netns nsrouter2\n\nDEV=veth0\nfor i in 1 2; do\n    ip -net nsclient$i link set $DEV up\n    ip -net nsclient$i addr add $(ipv4 $i)/24 dev $DEV\n    ip -net nsclient$i addr add $(ipv6 $i)/64 dev $DEV\ndone\n\nip -net nsrouter1 link set eth1 up\nip -net nsrouter1 link set veth0 up\n\nip -net nsrouter2 link set eth1 up\nip -net nsrouter2 link set eth2 up\n\nip -net nsclient1 route add default via 192.168.1.1\nip -net nsclient1 -6 route add default via dead:1::1\n\nip -net nsclient2 route add default via 192.168.2.1\nip -net nsclient2 route add default via dead:2::1\n\ni=3\nip -net nsrouter1 addr add 192.168.1.1/24 dev eth1\nip -net nsrouter1 addr add 192.168.3.1/24 dev veth0\nip -net nsrouter1 addr add dead:1::1/64 dev eth1\nip -net nsrouter1 addr add dead:3::1/64 dev veth0\nip -net nsrouter1 route add default via 192.168.3.10\nip -net nsrouter1 -6 route add default via dead:3::10\n\nip -net nsrouter2 addr add 192.168.2.1/24 dev eth1\nip -net nsrouter2 addr add 192.168.3.10/24 dev eth2\nip -net nsrouter2 addr add dead:2::1/64 dev eth1\nip -net nsrouter2 addr add dead:3::10/64 dev eth2\nip -net nsrouter2 route add default via 192.168.3.1\nip -net nsrouter2 route add default via dead:3::1\n\nsleep 2\nfor i in 4 6; do\n\tip netns exec nsrouter1 sysctl -q net.ipv$i.conf.all.forwarding=1\n\tip netns exec nsrouter2 sysctl -q net.ipv$i.conf.all.forwarding=1\ndone\n\nfor netns in nsrouter1 nsrouter2; do\nip netns exec $netns nft -f - <<EOF\ntable inet filter {\n\tcounter unknown { }\n\tcounter related { }\n\tchain forward {\n\t\ttype filter hook forward priority 0; policy accept;\n\t\tmeta l4proto icmpv6 icmpv6 type \"packet-too-big\" ct state \"related\" counter name \"related\" accept\n\t\tmeta l4proto icmp icmp type \"destination-unreachable\" ct state \"related\" counter name \"related\" accept\n\t\tmeta l4proto { icmp, icmpv6 } ct state new,established accept\n\t\tcounter name \"unknown\" drop\n\t}\n}\nEOF\ndone\n\nip netns exec nsclient1 nft -f - <<EOF\ntable inet filter {\n\tcounter unknown { }\n\tcounter related { }\n\tcounter redir4 { }\n\tcounter redir6 { }\n\tchain input {\n\t\ttype filter hook input priority 0; policy accept;\n\n\t\ticmp type \"redirect\" ct state \"related\" counter name \"redir4\" accept\n\t\ticmpv6 type \"nd-redirect\" ct state \"related\" counter name \"redir6\" accept\n\n\t\tmeta l4proto { icmp, icmpv6 } ct state established,untracked accept\n\t\tmeta l4proto { icmp, icmpv6 } ct state \"related\" counter name \"related\" accept\n\n\t\tcounter name \"unknown\" drop\n\t}\n}\nEOF\n\nip netns exec nsclient2 nft -f - <<EOF\ntable inet filter {\n\tcounter unknown { }\n\tcounter new { }\n\tcounter established { }\n\n\tchain input {\n\t\ttype filter hook input priority 0; policy accept;\n\t\tmeta l4proto { icmp, icmpv6 } ct state established,untracked accept\n\n\t\tmeta l4proto { icmp, icmpv6 } ct state \"new\" counter name \"new\" accept\n\t\tmeta l4proto { icmp, icmpv6 } ct state \"established\" counter name \"established\" accept\n\t\tcounter name \"unknown\" drop\n\t}\n\tchain output {\n\t\ttype filter hook output priority 0; policy accept;\n\t\tmeta l4proto { icmp, icmpv6 } ct state established,untracked accept\n\n\t\tmeta l4proto { icmp, icmpv6 } ct state \"new\" counter name \"new\"\n\t\tmeta l4proto { icmp, icmpv6 } ct state \"established\" counter name \"established\"\n\t\tcounter name \"unknown\" drop\n\t}\n}\nEOF\n\n\n# make sure NAT core rewrites adress of icmp error if nat is used according to\n# conntrack nat information (icmp error will be directed at nsrouter1 address,\n# but it needs to be routed to nsclient1 address).\nip netns exec nsrouter1 nft -f - <<EOF\ntable ip nat {\n\tchain postrouting {\n\t\ttype nat hook postrouting priority 0; policy accept;\n\t\tip protocol icmp oifname \"veth0\" counter masquerade\n\t}\n}\ntable ip6 nat {\n\tchain postrouting {\n\t\ttype nat hook postrouting priority 0; policy accept;\n\t\tip6 nexthdr icmpv6 oifname \"veth0\" counter masquerade\n\t}\n}\nEOF\n\nip netns exec nsrouter2 ip link set eth1  mtu 1280\nip netns exec nsclient2 ip link set veth0 mtu 1280\nsleep 1\n\nip netns exec nsclient1 ping -c 1 -s 1000 -q -M do 192.168.2.2 >/dev/null\nif [ $? -ne 0 ]; then\n\techo \"ERROR: netns ip routing/connectivity broken\" 1>&2\n\tcleanup\n\texit 1\nfi\nip netns exec nsclient1 ping6 -q -c 1 -s 1000 dead:2::2 >/dev/null\nif [ $? -ne 0 ]; then\n\techo \"ERROR: netns ipv6 routing/connectivity broken\" 1>&2\n\tcleanup\n\texit 1\nfi\n\ncheck_unknown\nif [ $? -ne 0 ]; then\n\tret=1\nfi\n\nexpect=\"packets 0 bytes 0\"\nfor netns in nsrouter1 nsrouter2 nsclient1;do\n\tcheck_counter \"$netns\" \"related\" \"$expect\"\n\tif [ $? -ne 0 ]; then\n\t\tret=1\n\tfi\ndone\n\nexpect=\"packets 2 bytes 2076\"\ncheck_counter nsclient2 \"new\" \"$expect\"\nif [ $? -ne 0 ]; then\n\tret=1\nfi\n\nip netns exec nsclient1 ping -q -c 1 -s 1300 -M do 192.168.2.2 > /dev/null\nif [ $? -eq 0 ]; then\n\techo \"ERROR: ping should have failed with PMTU too big error\" 1>&2\n\tret=1\nfi\n\n# nsrouter2 should have generated the icmp error, so\n# related counter should be 0 (its in forward).\nexpect=\"packets 0 bytes 0\"\ncheck_counter \"nsrouter2\" \"related\" \"$expect\"\nif [ $? -ne 0 ]; then\n\tret=1\nfi\n\n# but nsrouter1 should have seen it, same for nsclient1.\nexpect=\"packets 1 bytes 576\"\nfor netns in nsrouter1 nsclient1;do\n\tcheck_counter \"$netns\" \"related\" \"$expect\"\n\tif [ $? -ne 0 ]; then\n\t\tret=1\n\tfi\ndone\n\nip netns exec nsclient1 ping6 -c 1 -s 1300 dead:2::2 > /dev/null\nif [ $? -eq 0 ]; then\n\techo \"ERROR: ping6 should have failed with PMTU too big error\" 1>&2\n\tret=1\nfi\n\nexpect=\"packets 2 bytes 1856\"\nfor netns in nsrouter1 nsclient1;do\n\tcheck_counter \"$netns\" \"related\" \"$expect\"\n\tif [ $? -ne 0 ]; then\n\t\tret=1\n\tfi\ndone\n\nif [ $ret -eq 0 ];then\n\techo \"PASS: icmp mtu error had RELATED state\"\nelse\n\techo \"ERROR: icmp error RELATED state test has failed\"\nfi\n\n# add 'bad' route,  expect icmp REDIRECT to be generated\nip netns exec nsclient1 ip route add 192.168.1.42 via 192.168.1.1\nip netns exec nsclient1 ip route add dead:1::42 via dead:1::1\n\nip netns exec \"nsclient1\" ping -q -c 2 192.168.1.42 > /dev/null\n\nexpect=\"packets 1 bytes 112\"\ncheck_counter nsclient1 \"redir4\" \"$expect\"\nif [ $? -ne 0 ];then\n\tret=1\nfi\n\nip netns exec \"nsclient1\" ping -c 1 dead:1::42 > /dev/null\nexpect=\"packets 1 bytes 192\"\ncheck_counter nsclient1 \"redir6\" \"$expect\"\nif [ $? -ne 0 ];then\n\tret=1\nfi\n\nif [ $ret -eq 0 ];then\n\techo \"PASS: icmp redirects had RELATED state\"\nelse\n\techo \"ERROR: icmp redirect RELATED state test has failed\"\nfi\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}