{
  "module_name": "nf-queue.c",
  "hash_id": "52bda05f2cb8c62578ca02d90d8898054e318806f2efd9bec6088d470252395f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/nf-queue.c",
  "human_readable_source": "\n\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n#include <arpa/inet.h>\n\n#include <libmnl/libmnl.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_queue.h>\n\nstruct options {\n\tbool count_packets;\n\tbool gso_enabled;\n\tint verbose;\n\tunsigned int queue_num;\n\tunsigned int timeout;\n\tuint32_t verdict;\n\tuint32_t delay_ms;\n};\n\nstatic unsigned int queue_stats[5];\nstatic struct options opts;\n\nstatic void help(const char *p)\n{\n\tprintf(\"Usage: %s [-c|-v [-vv] ] [-t timeout] [-q queue_num] [-Qdst_queue ] [ -d ms_delay ] [-G]\\n\", p);\n}\n\nstatic int parse_attr_cb(const struct nlattr *attr, void *data)\n{\n\tconst struct nlattr **tb = data;\n\tint type = mnl_attr_get_type(attr);\n\n\t \n\tif (mnl_attr_type_valid(attr, NFQA_MAX) < 0)\n\t\treturn MNL_CB_OK;\n\n\tswitch (type) {\n\tcase NFQA_MARK:\n\tcase NFQA_IFINDEX_INDEV:\n\tcase NFQA_IFINDEX_OUTDEV:\n\tcase NFQA_IFINDEX_PHYSINDEV:\n\tcase NFQA_IFINDEX_PHYSOUTDEV:\n\t\tif (mnl_attr_validate(attr, MNL_TYPE_U32) < 0) {\n\t\t\tperror(\"mnl_attr_validate\");\n\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t\tbreak;\n\tcase NFQA_TIMESTAMP:\n\t\tif (mnl_attr_validate2(attr, MNL_TYPE_UNSPEC,\n\t\t    sizeof(struct nfqnl_msg_packet_timestamp)) < 0) {\n\t\t\tperror(\"mnl_attr_validate2\");\n\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t\tbreak;\n\tcase NFQA_HWADDR:\n\t\tif (mnl_attr_validate2(attr, MNL_TYPE_UNSPEC,\n\t\t    sizeof(struct nfqnl_msg_packet_hw)) < 0) {\n\t\t\tperror(\"mnl_attr_validate2\");\n\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\t\tbreak;\n\tcase NFQA_PAYLOAD:\n\t\tbreak;\n\t}\n\ttb[type] = attr;\n\treturn MNL_CB_OK;\n}\n\nstatic int queue_cb(const struct nlmsghdr *nlh, void *data)\n{\n\tstruct nlattr *tb[NFQA_MAX+1] = { 0 };\n\tstruct nfqnl_msg_packet_hdr *ph = NULL;\n\tuint32_t id = 0;\n\n\t(void)data;\n\n\tmnl_attr_parse(nlh, sizeof(struct nfgenmsg), parse_attr_cb, tb);\n\tif (tb[NFQA_PACKET_HDR]) {\n\t\tph = mnl_attr_get_payload(tb[NFQA_PACKET_HDR]);\n\t\tid = ntohl(ph->packet_id);\n\n\t\tif (opts.verbose > 0)\n\t\t\tprintf(\"packet hook=%u, hwproto 0x%x\",\n\t\t\t\tntohs(ph->hw_protocol), ph->hook);\n\n\t\tif (ph->hook >= 5) {\n\t\t\tfprintf(stderr, \"Unknown hook %d\\n\", ph->hook);\n\t\t\treturn MNL_CB_ERROR;\n\t\t}\n\n\t\tif (opts.verbose > 0) {\n\t\t\tuint32_t skbinfo = 0;\n\n\t\t\tif (tb[NFQA_SKB_INFO])\n\t\t\t\tskbinfo = ntohl(mnl_attr_get_u32(tb[NFQA_SKB_INFO]));\n\t\t\tif (skbinfo & NFQA_SKB_CSUMNOTREADY)\n\t\t\t\tprintf(\" csumnotready\");\n\t\t\tif (skbinfo & NFQA_SKB_GSO)\n\t\t\t\tprintf(\" gso\");\n\t\t\tif (skbinfo & NFQA_SKB_CSUM_NOTVERIFIED)\n\t\t\t\tprintf(\" csumnotverified\");\n\t\t\tputs(\"\");\n\t\t}\n\n\t\tif (opts.count_packets)\n\t\t\tqueue_stats[ph->hook]++;\n\t}\n\n\treturn MNL_CB_OK + id;\n}\n\nstatic struct nlmsghdr *\nnfq_build_cfg_request(char *buf, uint8_t command, int queue_num)\n{\n\tstruct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);\n\tstruct nfqnl_msg_config_cmd cmd = {\n\t\t.command = command,\n\t\t.pf = htons(AF_INET),\n\t};\n\tstruct nfgenmsg *nfg;\n\n\tnlh->nlmsg_type\t= (NFNL_SUBSYS_QUEUE << 8) | NFQNL_MSG_CONFIG;\n\tnlh->nlmsg_flags = NLM_F_REQUEST;\n\n\tnfg = mnl_nlmsg_put_extra_header(nlh, sizeof(*nfg));\n\n\tnfg->nfgen_family = AF_UNSPEC;\n\tnfg->version = NFNETLINK_V0;\n\tnfg->res_id = htons(queue_num);\n\n\tmnl_attr_put(nlh, NFQA_CFG_CMD, sizeof(cmd), &cmd);\n\n\treturn nlh;\n}\n\nstatic struct nlmsghdr *\nnfq_build_cfg_params(char *buf, uint8_t mode, int range, int queue_num)\n{\n\tstruct nlmsghdr *nlh = mnl_nlmsg_put_header(buf);\n\tstruct nfqnl_msg_config_params params = {\n\t\t.copy_range = htonl(range),\n\t\t.copy_mode = mode,\n\t};\n\tstruct nfgenmsg *nfg;\n\n\tnlh->nlmsg_type\t= (NFNL_SUBSYS_QUEUE << 8) | NFQNL_MSG_CONFIG;\n\tnlh->nlmsg_flags = NLM_F_REQUEST;\n\n\tnfg = mnl_nlmsg_put_extra_header(nlh, sizeof(*nfg));\n\tnfg->nfgen_family = AF_UNSPEC;\n\tnfg->version = NFNETLINK_V0;\n\tnfg->res_id = htons(queue_num);\n\n\tmnl_attr_put(nlh, NFQA_CFG_PARAMS, sizeof(params), &params);\n\n\treturn nlh;\n}\n\nstatic struct nlmsghdr *\nnfq_build_verdict(char *buf, int id, int queue_num, uint32_t verd)\n{\n\tstruct nfqnl_msg_verdict_hdr vh = {\n\t\t.verdict = htonl(verd),\n\t\t.id = htonl(id),\n\t};\n\tstruct nlmsghdr *nlh;\n\tstruct nfgenmsg *nfg;\n\n\tnlh = mnl_nlmsg_put_header(buf);\n\tnlh->nlmsg_type = (NFNL_SUBSYS_QUEUE << 8) | NFQNL_MSG_VERDICT;\n\tnlh->nlmsg_flags = NLM_F_REQUEST;\n\tnfg = mnl_nlmsg_put_extra_header(nlh, sizeof(*nfg));\n\tnfg->nfgen_family = AF_UNSPEC;\n\tnfg->version = NFNETLINK_V0;\n\tnfg->res_id = htons(queue_num);\n\n\tmnl_attr_put(nlh, NFQA_VERDICT_HDR, sizeof(vh), &vh);\n\n\treturn nlh;\n}\n\nstatic void print_stats(void)\n{\n\tunsigned int last, total;\n\tint i;\n\n\ttotal = 0;\n\tlast = queue_stats[0];\n\n\tfor (i = 0; i < 5; i++) {\n\t\tprintf(\"hook %d packets %08u\\n\", i, queue_stats[i]);\n\t\tlast = queue_stats[i];\n\t\ttotal += last;\n\t}\n\n\tprintf(\"%u packets total\\n\", total);\n}\n\nstruct mnl_socket *open_queue(void)\n{\n\tchar buf[MNL_SOCKET_BUFFER_SIZE];\n\tunsigned int queue_num;\n\tstruct mnl_socket *nl;\n\tstruct nlmsghdr *nlh;\n\tstruct timeval tv;\n\tuint32_t flags;\n\n\tnl = mnl_socket_open(NETLINK_NETFILTER);\n\tif (nl == NULL) {\n\t\tperror(\"mnl_socket_open\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {\n\t\tperror(\"mnl_socket_bind\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tqueue_num = opts.queue_num;\n\tnlh = nfq_build_cfg_request(buf, NFQNL_CFG_CMD_BIND, queue_num);\n\n\tif (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {\n\t\tperror(\"mnl_socket_sendto\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tnlh = nfq_build_cfg_params(buf, NFQNL_COPY_PACKET, 0xFFFF, queue_num);\n\n\tflags = opts.gso_enabled ? NFQA_CFG_F_GSO : 0;\n\tflags |= NFQA_CFG_F_UID_GID;\n\tmnl_attr_put_u32(nlh, NFQA_CFG_FLAGS, htonl(flags));\n\tmnl_attr_put_u32(nlh, NFQA_CFG_MASK, htonl(flags));\n\n\tif (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {\n\t\tperror(\"mnl_socket_sendto\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemset(&tv, 0, sizeof(tv));\n\ttv.tv_sec = opts.timeout;\n\tif (opts.timeout && setsockopt(mnl_socket_get_fd(nl),\n\t\t\t\t       SOL_SOCKET, SO_RCVTIMEO,\n\t\t\t\t       &tv, sizeof(tv))) {\n\t\tperror(\"setsockopt(SO_RCVTIMEO)\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn nl;\n}\n\nstatic void sleep_ms(uint32_t delay)\n{\n\tstruct timespec ts = { .tv_sec = delay / 1000 };\n\n\tdelay %= 1000;\n\n\tts.tv_nsec = delay * 1000llu * 1000llu;\n\n\tnanosleep(&ts, NULL);\n}\n\nstatic int mainloop(void)\n{\n\tunsigned int buflen = 64 * 1024 + MNL_SOCKET_BUFFER_SIZE;\n\tstruct mnl_socket *nl;\n\tstruct nlmsghdr *nlh;\n\tunsigned int portid;\n\tchar *buf;\n\tint ret;\n\n\tbuf = malloc(buflen);\n\tif (!buf) {\n\t\tperror(\"malloc\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tnl = open_queue();\n\tportid = mnl_socket_get_portid(nl);\n\n\tfor (;;) {\n\t\tuint32_t id;\n\n\t\tret = mnl_socket_recvfrom(nl, buf, buflen);\n\t\tif (ret == -1) {\n\t\t\tif (errno == ENOBUFS || errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tif (errno == EAGAIN) {\n\t\t\t\terrno = 0;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tperror(\"mnl_socket_recvfrom\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tret = mnl_cb_run(buf, ret, 0, portid, queue_cb, NULL);\n\t\tif (ret < 0) {\n\t\t\tperror(\"mnl_cb_run\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tid = ret - MNL_CB_OK;\n\t\tif (opts.delay_ms)\n\t\t\tsleep_ms(opts.delay_ms);\n\n\t\tnlh = nfq_build_verdict(buf, id, opts.queue_num, opts.verdict);\n\t\tif (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {\n\t\t\tperror(\"mnl_socket_sendto\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tmnl_socket_close(nl);\n\n\treturn ret;\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"chvt:q:Q:d:G\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\topts.count_packets = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thelp(argv[0]);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\topts.queue_num = atoi(optarg);\n\t\t\tif (opts.queue_num > 0xffff)\n\t\t\t\topts.queue_num = 0;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\topts.verdict = atoi(optarg);\n\t\t\tif (opts.verdict > 0xffff) {\n\t\t\t\tfprintf(stderr, \"Expected destination queue number\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\topts.verdict <<= 16;\n\t\t\topts.verdict |= NF_QUEUE;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\topts.delay_ms = atoi(optarg);\n\t\t\tif (opts.delay_ms == 0) {\n\t\t\t\tfprintf(stderr, \"Expected nonzero delay (in milliseconds)\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\topts.timeout = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\topts.gso_enabled = false;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\topts.verbose++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opts.verdict != NF_ACCEPT && (opts.verdict >> 16 == opts.queue_num)) {\n\t\tfprintf(stderr, \"Cannot use same destination and source queue\\n\");\n\t\texit(1);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret;\n\n\topts.verdict = NF_ACCEPT;\n\topts.gso_enabled = true;\n\n\tparse_opts(argc, argv);\n\n\tret = mainloop();\n\tif (opts.count_packets)\n\t\tprint_stats();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}