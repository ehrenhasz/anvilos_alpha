{
  "module_name": "connect_close.c",
  "hash_id": "7e8372a129ef21ba05db86c10a379e1f8189409e0760077a91c4411b7d5f4458",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/connect_close.c",
  "human_readable_source": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <signal.h>\n\n#include <arpa/inet.h>\n#include <sys/socket.h>\n\n#define PORT 12345\n#define RUNTIME 10\n\nstatic struct {\n\tunsigned int timeout;\n\tunsigned int port;\n} opts = {\n\t.timeout = RUNTIME,\n\t.port = PORT,\n};\n\nstatic void handler(int sig)\n{\n\t_exit(sig == SIGALRM ? 0 : 1);\n}\n\nstatic void set_timeout(void)\n{\n\tstruct sigaction action = {\n\t\t.sa_handler = handler,\n\t};\n\n\tsigaction(SIGALRM, &action, NULL);\n\n\talarm(opts.timeout);\n}\n\nstatic void do_connect(const struct sockaddr_in *dst)\n{\n\tint s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n\tif (s >= 0)\n\t\tfcntl(s, F_SETFL, O_NONBLOCK);\n\n\tconnect(s, (struct sockaddr *)dst, sizeof(*dst));\n\tclose(s);\n}\n\nstatic void do_accept(const struct sockaddr_in *src)\n{\n\tint c, one = 1, s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n\tif (s < 0)\n\t\treturn;\n\n\tsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));\n\tsetsockopt(s, SOL_SOCKET, SO_REUSEPORT, &one, sizeof(one));\n\n\tbind(s, (struct sockaddr *)src, sizeof(*src));\n\n\tlisten(s, 16);\n\n\tc = accept(s, NULL, NULL);\n\tif (c >= 0)\n\t\tclose(c);\n\n\tclose(s);\n}\n\nstatic int accept_loop(void)\n{\n\tstruct sockaddr_in src = {\n\t\t.sin_family = AF_INET,\n\t\t.sin_port = htons(opts.port),\n\t};\n\n\tinet_pton(AF_INET, \"127.0.0.1\", &src.sin_addr);\n\n\tset_timeout();\n\n\tfor (;;)\n\t\tdo_accept(&src);\n\n\treturn 1;\n}\n\nstatic int connect_loop(void)\n{\n\tstruct sockaddr_in dst = {\n\t\t.sin_family = AF_INET,\n\t\t.sin_port = htons(opts.port),\n\t};\n\n\tinet_pton(AF_INET, \"127.0.0.1\", &dst.sin_addr);\n\n\tset_timeout();\n\n\tfor (;;)\n\t\tdo_connect(&dst);\n\n\treturn 1;\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"t:p:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 't':\n\t\t\topts.timeout = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\topts.port = atoi(optarg);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tpid_t p;\n\n\tparse_opts(argc, argv);\n\n\tp = fork();\n\tif (p < 0)\n\t\treturn 111;\n\n\tif (p > 0)\n\t\treturn accept_loop();\n\n\treturn connect_loop();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}