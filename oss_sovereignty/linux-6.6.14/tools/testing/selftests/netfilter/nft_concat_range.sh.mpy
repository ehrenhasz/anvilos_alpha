{
  "module_name": "nft_concat_range.sh",
  "hash_id": "b2195b7a9cb09d2ab7e866bcc48d6de84bda9cd6d39bda7427fd7d0586a30b29",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/nft_concat_range.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# nft_concat_range.sh - Tests for sets with concatenation of ranged fields\n#\n# Copyright (c) 2019 Red Hat GmbH\n#\n# Author: Stefano Brivio <sbrivio@redhat.com>\n#\n# shellcheck disable=SC2154,SC2034,SC2016,SC2030,SC2031\n# ^ Configuration and templates sourced with eval, counters reused in subshells\n\nKSELFTEST_SKIP=4\n\n# Available test groups:\n# - reported_issues: check for issues that were reported in the past\n# - correctness: check that packets match given entries, and only those\n# - concurrency: attempt races between insertion, deletion and lookup\n# - timeout: check that packets match entries until they expire\n# - performance: estimate matching rate, compare with rbtree and hash baselines\nTESTS=\"reported_issues correctness concurrency timeout\"\n[ \"${quicktest}\" != \"1\" ] && TESTS=\"${TESTS} performance\"\n\n# Set types, defined by TYPE_ variables below\nTYPES=\"net_port port_net net6_port port_proto net6_port_mac net6_port_mac_proto\n       net_port_net net_mac mac_net net_mac_icmp net6_mac_icmp\n       net6_port_net6_port net_port_mac_proto_net\"\n\n# Reported bugs, also described by TYPE_ variables below\nBUGS=\"flush_remove_add reload\"\n\n# List of possible paths to pktgen script from kernel tree for performance tests\nPKTGEN_SCRIPT_PATHS=\"\n\t../../../../samples/pktgen/pktgen_bench_xmit_mode_netif_receive.sh\n\tpktgen/pktgen_bench_xmit_mode_netif_receive.sh\"\n\n# Definition of set types:\n# display\tdisplay text for test report\n# type_spec\tnftables set type specifier\n# chain_spec\tnftables type specifier for rules mapping to set\n# dst\t\tcall sequence of format_*() functions for destination fields\n# src\t\tcall sequence of format_*() functions for source fields\n# start\t\tinitial integer used to generate addresses and ports\n# count\t\tcount of entries to generate and match\n# src_delta\tnumber summed to destination generator for source fields\n# tools\t\tlist of tools for correctness and timeout tests, any can be used\n# proto\t\tL4 protocol of test packets\n#\n# race_repeat\trace attempts per thread, 0 disables concurrency test for type\n# flood_tools\tlist of tools for concurrency tests, any can be used\n# flood_proto\tL4 protocol of test packets for concurrency tests\n# flood_spec\tnftables type specifier for concurrency tests\n#\n# perf_duration\tduration of single pktgen injection test\n# perf_spec\tnftables type specifier for performance tests\n# perf_dst\tformat_*() functions for destination fields in performance test\n# perf_src\tformat_*() functions for source fields in performance test\n# perf_entries\tnumber of set entries for performance test\n# perf_proto\tL3 protocol of test packets\nTYPE_net_port=\"\ndisplay\t\tnet,port\ntype_spec\tipv4_addr . inet_service\nchain_spec\tip daddr . udp dport\ndst\t\taddr4 port\nsrc\t\t \nstart\t\t1\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip nc bash\nproto\t\tudp\n\nrace_repeat\t3\nflood_tools\tiperf3 iperf netperf\nflood_proto\tudp\nflood_spec\tip daddr . udp dport\n\nperf_duration\t5\nperf_spec\tip daddr . udp dport\nperf_dst\taddr4 port\nperf_src\t \nperf_entries\t1000\nperf_proto\tipv4\n\"\n\nTYPE_port_net=\"\ndisplay\t\tport,net\ntype_spec\tinet_service . ipv4_addr\nchain_spec\tudp dport . ip daddr\ndst\t\tport addr4\nsrc\t\t \nstart\t\t1\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp\n\nrace_repeat\t3\nflood_tools\tiperf3 iperf netperf\nflood_proto\tudp\nflood_spec\tudp dport . ip daddr\n\nperf_duration\t5\nperf_spec\tudp dport . ip daddr\nperf_dst\tport addr4\nperf_src\t \nperf_entries\t100\nperf_proto\tipv4\n\"\n\nTYPE_net6_port=\"\ndisplay\t\tnet6,port\ntype_spec\tipv6_addr . inet_service\nchain_spec\tip6 daddr . udp dport\ndst\t\taddr6 port\nsrc\t\t \nstart\t\t10\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp6\n\nrace_repeat\t3\nflood_tools\tiperf3 iperf netperf\nflood_proto\ttcp6\nflood_spec\tip6 daddr . udp dport\n\nperf_duration\t5\nperf_spec\tip6 daddr . udp dport\nperf_dst\taddr6 port\nperf_src\t \nperf_entries\t1000\nperf_proto\tipv6\n\"\n\nTYPE_port_proto=\"\ndisplay\t\tport,proto\ntype_spec\tinet_service . inet_proto\nchain_spec\tudp dport . meta l4proto\ndst\t\tport proto\nsrc\t\t \nstart\t\t1\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp\n\nrace_repeat\t0\n\nperf_duration\t5\nperf_spec\tudp dport . meta l4proto\nperf_dst\tport proto\nperf_src\t \nperf_entries\t30000\nperf_proto\tipv4\n\"\n\nTYPE_net6_port_mac=\"\ndisplay\t\tnet6,port,mac\ntype_spec\tipv6_addr . inet_service . ether_addr\nchain_spec\tip6 daddr . udp dport . ether saddr\ndst\t\taddr6 port\nsrc\t\tmac\nstart\t\t10\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp6\n\nrace_repeat\t0\n\nperf_duration\t5\nperf_spec\tip6 daddr . udp dport . ether daddr\nperf_dst\taddr6 port mac\nperf_src\t \nperf_entries\t10\nperf_proto\tipv6\n\"\n\nTYPE_net6_port_mac_proto=\"\ndisplay\t\tnet6,port,mac,proto\ntype_spec\tipv6_addr . inet_service . ether_addr . inet_proto\nchain_spec\tip6 daddr . udp dport . ether saddr . meta l4proto\ndst\t\taddr6 port\nsrc\t\tmac proto\nstart\t\t10\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp6\n\nrace_repeat\t0\n\nperf_duration\t5\nperf_spec\tip6 daddr . udp dport . ether daddr . meta l4proto\nperf_dst\taddr6 port mac proto\nperf_src\t \nperf_entries\t1000\nperf_proto\tipv6\n\"\n\nTYPE_net_port_net=\"\ndisplay\t\tnet,port,net\ntype_spec\tipv4_addr . inet_service . ipv4_addr\nchain_spec\tip daddr . udp dport . ip saddr\ndst\t\taddr4 port\nsrc\t\taddr4\nstart\t\t1\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp\n\nrace_repeat\t3\nflood_tools\tiperf3 iperf netperf\nflood_proto\ttcp\nflood_spec\tip daddr . udp dport . ip saddr\n\nperf_duration\t0\n\"\n\nTYPE_net6_port_net6_port=\"\ndisplay\t\tnet6,port,net6,port\ntype_spec\tipv6_addr . inet_service . ipv6_addr . inet_service\nchain_spec\tip6 daddr . udp dport . ip6 saddr . udp sport\ndst\t\taddr6 port\nsrc\t\taddr6 port\nstart\t\t10\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc\nproto\t\tudp6\n\nrace_repeat\t3\nflood_tools\tiperf3 iperf netperf\nflood_proto\ttcp6\nflood_spec\tip6 daddr . tcp dport . ip6 saddr . tcp sport\n\nperf_duration\t0\n\"\n\nTYPE_net_port_mac_proto_net=\"\ndisplay\t\tnet,port,mac,proto,net\ntype_spec\tipv4_addr . inet_service . ether_addr . inet_proto . ipv4_addr\nchain_spec\tip daddr . udp dport . ether saddr . meta l4proto . ip saddr\ndst\t\taddr4 port\nsrc\t\tmac proto addr4\nstart\t\t1\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp\n\nrace_repeat\t0\n\nperf_duration\t0\n\"\n\nTYPE_net_mac=\"\ndisplay\t\tnet,mac\ntype_spec\tipv4_addr . ether_addr\nchain_spec\tip daddr . ether saddr\ndst\t\taddr4\nsrc\t\tmac\nstart\t\t1\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp\n\nrace_repeat\t0\n\nperf_duration\t5\nperf_spec\tip daddr . ether daddr\nperf_dst\taddr4 mac\nperf_src\t \nperf_entries\t1000\nperf_proto\tipv4\n\"\n\nTYPE_mac_net=\"\ndisplay\t\tmac,net\ntype_spec\tether_addr . ipv4_addr\nchain_spec\tether saddr . ip saddr\ndst\t\t \nsrc\t\tmac addr4\nstart\t\t1\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp\n\nrace_repeat\t0\n\nperf_duration\t0\n\"\n\nTYPE_net_mac_icmp=\"\ndisplay\t\tnet,mac - ICMP\ntype_spec\tipv4_addr . ether_addr\nchain_spec\tip daddr . ether saddr\ndst\t\taddr4\nsrc\t\tmac\nstart\t\t1\ncount\t\t5\nsrc_delta\t2000\ntools\t\tping\nproto\t\ticmp\n\nrace_repeat\t0\n\nperf_duration\t0\n\"\n\nTYPE_net6_mac_icmp=\"\ndisplay\t\tnet6,mac - ICMPv6\ntype_spec\tipv6_addr . ether_addr\nchain_spec\tip6 daddr . ether saddr\ndst\t\taddr6\nsrc\t\tmac\nstart\t\t10\ncount\t\t50\nsrc_delta\t2000\ntools\t\tping\nproto\t\ticmp6\n\nrace_repeat\t0\n\nperf_duration\t0\n\"\n\nTYPE_net_port_proto_net=\"\ndisplay\t\tnet,port,proto,net\ntype_spec\tipv4_addr . inet_service . inet_proto . ipv4_addr\nchain_spec\tip daddr . udp dport . meta l4proto . ip saddr\ndst\t\taddr4 port proto\nsrc\t\taddr4\nstart\t\t1\ncount\t\t5\nsrc_delta\t2000\ntools\t\tsendip socat nc\nproto\t\tudp\n\nrace_repeat\t3\nflood_tools\tiperf3 iperf netperf\nflood_proto\ttcp\nflood_spec\tip daddr . tcp dport . meta l4proto . ip saddr\n\nperf_duration\t0\n\"\n\n# Definition of tests for bugs reported in the past:\n# display\tdisplay text for test report\nTYPE_flush_remove_add=\"\ndisplay\t\tAdd two elements, flush, re-add\n\"\n\nTYPE_reload=\"\ndisplay\t\tnet,mac with reload\ntype_spec\tipv4_addr . ether_addr\nchain_spec\tip daddr . ether saddr\ndst\t\taddr4\nsrc\t\tmac\nstart\t\t1\ncount\t\t1\nsrc_delta\t2000\ntools\t\tsendip socat nc bash\nproto\t\tudp\n\nrace_repeat\t0\n\nperf_duration\t0\n\"\n\n# Set template for all tests, types and rules are filled in depending on test\nset_template='\nflush ruleset\n\ntable inet filter {\n\tcounter test {\n\t\tpackets 0 bytes 0\n\t}\n\n\tset test {\n\t\ttype ${type_spec}\n\t\tflags interval,timeout\n\t}\n\n\tchain input {\n\t\ttype filter hook prerouting priority 0; policy accept;\n\t\t${chain_spec} @test counter name \\\"test\\\"\n\t}\n}\n\ntable netdev perf {\n\tcounter test {\n\t\tpackets 0 bytes 0\n\t}\n\n\tcounter match {\n\t\tpackets 0 bytes 0\n\t}\n\n\tset test {\n\t\ttype ${type_spec}\n\t\tflags interval\n\t}\n\n\tset norange {\n\t\ttype ${type_spec}\n\t}\n\n\tset noconcat {\n\t\ttype ${type_spec%% *}\n\t\tflags interval\n\t}\n\n\tchain test {\n\t\ttype filter hook ingress device veth_a priority 0;\n\t}\n}\n'\n\nerr_buf=\ninfo_buf=\n\n# Append string to error buffer\nerr() {\n\terr_buf=\"${err_buf}${1}\n\"\n}\n\n# Append string to information buffer\ninfo() {\n\tinfo_buf=\"${info_buf}${1}\n\"\n}\n\n# Flush error buffer to stdout\nerr_flush() {\n\tprintf \"%s\" \"${err_buf}\"\n\terr_buf=\n}\n\n# Flush information buffer to stdout\ninfo_flush() {\n\tprintf \"%s\" \"${info_buf}\"\n\tinfo_buf=\n}\n\n# Setup veth pair: this namespace receives traffic, B generates it\nsetup_veth() {\n\tip netns add B\n\tip link add veth_a type veth peer name veth_b || return 1\n\n\tip link set veth_a up\n\tip link set veth_b netns B\n\n\tip -n B link set veth_b up\n\n\tip addr add dev veth_a 10.0.0.1\n\tip route add default dev veth_a\n\n\tip -6 addr add fe80::1/64 dev veth_a nodad\n\tip -6 addr add 2001:db8::1/64 dev veth_a nodad\n\tip -6 route add default dev veth_a\n\n\tip -n B route add default dev veth_b\n\n\tip -6 -n B addr add fe80::2/64 dev veth_b nodad\n\tip -6 -n B addr add 2001:db8::2/64 dev veth_b nodad\n\tip -6 -n B route add default dev veth_b\n\n\tB() {\n\t\tip netns exec B \"$@\" >/dev/null 2>&1\n\t}\n\n\tsleep 2\n}\n\n# Fill in set template and initialise set\nsetup_set() {\n\teval \"echo \\\"${set_template}\\\"\" | nft -f -\n}\n\n# Check that at least one of the needed tools is available\ncheck_tools() {\n\t[ -z \"${tools}\" ] && return 0\n\n\t__tools=\n\tfor tool in ${tools}; do\n\t\tif [ \"${tool}\" = \"nc\" ] && [ \"${proto}\" = \"udp6\" ] && \\\n\t\t   ! nc -u -w0 1.1.1.1 1 2>/dev/null; then\n\t\t\t# Some GNU netcat builds might not support IPv6\n\t\t\t__tools=\"${__tools} netcat-openbsd\"\n\t\t\tcontinue\n\t\tfi\n\t\t__tools=\"${__tools} ${tool}\"\n\n\t\tcommand -v \"${tool}\" >/dev/null && return 0\n\tdone\n\terr \"need one of:${__tools}, skipping\" && return 1\n}\n\n# Set up function to send ICMP packets\nsetup_send_icmp() {\n\tsend_icmp() {\n\t\tB ping -c1 -W1 \"${dst_addr4}\" >/dev/null 2>&1\n\t}\n}\n\n# Set up function to send ICMPv6 packets\nsetup_send_icmp6() {\n\tif command -v ping6 >/dev/null; then\n\t\tsend_icmp6() {\n\t\t\tip -6 addr add \"${dst_addr6}\" dev veth_a nodad \\\n\t\t\t\t2>/dev/null\n\t\t\tB ping6 -q -c1 -W1 \"${dst_addr6}\"\n\t\t}\n\telse\n\t\tsend_icmp6() {\n\t\t\tip -6 addr add \"${dst_addr6}\" dev veth_a nodad \\\n\t\t\t\t2>/dev/null\n\t\t\tB ping -q -6 -c1 -W1 \"${dst_addr6}\"\n\t\t}\n\tfi\n}\n\n# Set up function to send single UDP packets on IPv4\nsetup_send_udp() {\n\tif command -v sendip >/dev/null; then\n\t\tsend_udp() {\n\t\t\t[ -n \"${src_port}\" ] && src_port=\"-us ${src_port}\"\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-ud ${dst_port}\"\n\t\t\t[ -n \"${src_addr4}\" ] && src_addr4=\"-is ${src_addr4}\"\n\n\t\t\t# shellcheck disable=SC2086 # sendip needs split options\n\t\t\tB sendip -p ipv4 -p udp ${src_addr4} ${src_port} \\\n\t\t\t\t\t\t${dst_port} \"${dst_addr4}\"\n\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t\tsrc_addr4=\n\t\t}\n\telif command -v socat -v >/dev/null; then\n\t\tsend_udp() {\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr4}\" dev veth_b\n\t\t\t\t__socatbind=\",bind=${src_addr4}\"\n\t\t\t\tif [ -n \"${src_port}\" ];then\n\t\t\t\t\t__socatbind=\"${__socatbind}:${src_port}\"\n\t\t\t\tfi\n\t\t\tfi\n\n\t\t\tip addr add \"${dst_addr4}\" dev veth_a 2>/dev/null\n\t\t\t[ -z \"${dst_port}\" ] && dst_port=12345\n\n\t\t\techo \"test4\" | B socat -t 0.01 STDIN UDP4-DATAGRAM:${dst_addr4}:${dst_port}\"${__socatbind}\"\n\n\t\t\tsrc_addr4=\n\t\t\tsrc_port=\n\t\t}\n\telif command -v nc >/dev/null; then\n\t\tif nc -u -w0 1.1.1.1 1 2>/dev/null; then\n\t\t\t# OpenBSD netcat\n\t\t\tnc_opt=\"-w0\"\n\t\telse\n\t\t\t# GNU netcat\n\t\t\tnc_opt=\"-q0\"\n\t\tfi\n\n\t\tsend_udp() {\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr4}\" dev veth_b\n\t\t\t\t__src_addr4=\"-s ${src_addr4}\"\n\t\t\tfi\n\t\t\tip addr add \"${dst_addr4}\" dev veth_a 2>/dev/null\n\t\t\t[ -n \"${src_port}\" ] && src_port=\"-p ${src_port}\"\n\n\t\t\techo \"\" | B nc -u \"${nc_opt}\" \"${__src_addr4}\" \\\n\t\t\t\t  \"${src_port}\" \"${dst_addr4}\" \"${dst_port}\"\n\n\t\t\tsrc_addr4=\n\t\t\tsrc_port=\n\t\t}\n\telif [ -z \"$(bash -c 'type -p')\" ]; then\n\t\tsend_udp() {\n\t\t\tip addr add \"${dst_addr4}\" dev veth_a 2>/dev/null\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr4}/16\" dev veth_b\n\t\t\t\tB ip route add default dev veth_b\n\t\t\tfi\n\n\t\t\tB bash -c \"echo > /dev/udp/${dst_addr4}/${dst_port}\"\n\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr del \"${src_addr4}/16\" dev veth_b\n\t\t\tfi\n\t\t\tsrc_addr4=\n\t\t}\n\telse\n\t\treturn 1\n\tfi\n}\n\n# Set up function to send single UDP packets on IPv6\nsetup_send_udp6() {\n\tif command -v sendip >/dev/null; then\n\t\tsend_udp6() {\n\t\t\t[ -n \"${src_port}\" ] && src_port=\"-us ${src_port}\"\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-ud ${dst_port}\"\n\t\t\tif [ -n \"${src_addr6}\" ]; then\n\t\t\t\tsrc_addr6=\"-6s ${src_addr6}\"\n\t\t\telse\n\t\t\t\tsrc_addr6=\"-6s 2001:db8::2\"\n\t\t\tfi\n\t\t\tip -6 addr add \"${dst_addr6}\" dev veth_a nodad \\\n\t\t\t\t2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB sendip -p ipv6 -p udp ${src_addr6} ${src_port} \\\n\t\t\t\t\t\t${dst_port} \"${dst_addr6}\"\n\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t\tsrc_addr6=\n\t\t}\n\telif command -v socat -v >/dev/null; then\n\t\tsend_udp6() {\n\t\t\tip -6 addr add \"${dst_addr6}\" dev veth_a nodad \\\n\t\t\t\t2>/dev/null\n\n\t\t\t__socatbind6=\n\n\t\t\tif [ -n \"${src_addr6}\" ]; then\n\t\t\t\tif [ -n \"${src_addr6} != \"${src_addr6_added} ]; then\n\t\t\t\t\tB ip addr add \"${src_addr6}\" dev veth_b nodad\n\n\t\t\t\t\tsrc_addr6_added=${src_addr6}\n\t\t\t\tfi\n\n\t\t\t\t__socatbind6=\",bind=[${src_addr6}]\"\n\n\t\t\t\tif [ -n \"${src_port}\" ] ;then\n\t\t\t\t\t__socatbind6=\"${__socatbind6}:${src_port}\"\n\t\t\t\tfi\n\t\t\tfi\n\n\t\t\techo \"test6\" | B socat -t 0.01 STDIN UDP6-DATAGRAM:[${dst_addr6}]:${dst_port}\"${__socatbind6}\"\n\t\t}\n\telif command -v nc >/dev/null && nc -u -w0 1.1.1.1 1 2>/dev/null; then\n\t\t# GNU netcat might not work with IPv6, try next tool\n\t\tsend_udp6() {\n\t\t\tip -6 addr add \"${dst_addr6}\" dev veth_a nodad \\\n\t\t\t\t2>/dev/null\n\t\t\tif [ -n \"${src_addr6}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr6}\" dev veth_b nodad\n\t\t\telse\n\t\t\t\tsrc_addr6=\"2001:db8::2\"\n\t\t\tfi\n\t\t\t[ -n \"${src_port}\" ] && src_port=\"-p ${src_port}\"\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\techo \"\" | B nc -u w0 \"-s${src_addr6}\" ${src_port} \\\n\t\t\t\t\t       ${dst_addr6} ${dst_port}\n\n\t\t\tsrc_addr6=\n\t\t\tsrc_port=\n\t\t}\n\telif [ -z \"$(bash -c 'type -p')\" ]; then\n\t\tsend_udp6() {\n\t\t\tip -6 addr add \"${dst_addr6}\" dev veth_a nodad \\\n\t\t\t\t2>/dev/null\n\t\t\tB ip addr add \"${src_addr6}\" dev veth_b nodad\n\t\t\tB bash -c \"echo > /dev/udp/${dst_addr6}/${dst_port}\"\n\t\t\tip -6 addr del \"${dst_addr6}\" dev veth_a 2>/dev/null\n\t\t}\n\telse\n\t\treturn 1\n\tfi\n}\n\n# Set up function to send TCP traffic on IPv4\nsetup_flood_tcp() {\n\tif command -v iperf3 >/dev/null; then\n\t\tflood_tcp() {\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-p ${dst_port}\"\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr4}/16\" dev veth_b\n\t\t\t\tsrc_addr4=\"-B ${src_addr4}\"\n\t\t\telse\n\t\t\t\tB ip addr add dev veth_b 10.0.0.2\n\t\t\t\tsrc_addr4=\"-B 10.0.0.2\"\n\t\t\tfi\n\t\t\tif [ -n \"${src_port}\" ]; then\n\t\t\t\tsrc_port=\"--cport ${src_port}\"\n\t\t\tfi\n\t\t\tB ip route add default dev veth_b 2>/dev/null\n\t\t\tip addr add \"${dst_addr4}\" dev veth_a 2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tiperf3 -s -DB \"${dst_addr4}\" ${dst_port} >/dev/null 2>&1\n\t\t\tsleep 2\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB iperf3 -c \"${dst_addr4}\" ${dst_port} ${src_port} \\\n\t\t\t\t${src_addr4} -l16 -t 1000\n\n\t\t\tsrc_addr4=\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t}\n\telif command -v iperf >/dev/null; then\n\t\tflood_tcp() {\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-p ${dst_port}\"\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr4}/16\" dev veth_b\n\t\t\t\tsrc_addr4=\"-B ${src_addr4}\"\n\t\t\telse\n\t\t\t\tB ip addr add dev veth_b 10.0.0.2 2>/dev/null\n\t\t\t\tsrc_addr4=\"-B 10.0.0.2\"\n\t\t\tfi\n\t\t\tif [ -n \"${src_port}\" ]; then\n\t\t\t\tsrc_addr4=\"${src_addr4}:${src_port}\"\n\t\t\tfi\n\t\t\tB ip route add default dev veth_b\n\t\t\tip addr add \"${dst_addr4}\" dev veth_a 2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tiperf -s -DB \"${dst_addr4}\" ${dst_port} >/dev/null 2>&1\n\t\t\tsleep 2\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB iperf -c \"${dst_addr4}\" ${dst_port} ${src_addr4} \\\n\t\t\t\t-l20 -t 1000\n\n\t\t\tsrc_addr4=\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t}\n\telif command -v netperf >/dev/null; then\n\t\tflood_tcp() {\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-p ${dst_port}\"\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr4}/16\" dev veth_b\n\t\t\telse\n\t\t\t\tB ip addr add dev veth_b 10.0.0.2\n\t\t\t\tsrc_addr4=\"10.0.0.2\"\n\t\t\tfi\n\t\t\tif [ -n \"${src_port}\" ]; then\n\t\t\t\tdst_port=\"${dst_port},${src_port}\"\n\t\t\tfi\n\t\t\tB ip route add default dev veth_b\n\t\t\tip addr add \"${dst_addr4}\" dev veth_a 2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tnetserver -4 ${dst_port} -L \"${dst_addr4}\" \\\n\t\t\t\t>/dev/null 2>&1\n\t\t\tsleep 2\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB netperf -4 -H \"${dst_addr4}\" ${dst_port} \\\n\t\t\t\t-L \"${src_addr4}\" -l 1000 -t TCP_STREAM\n\n\t\t\tsrc_addr4=\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t}\n\telse\n\t\treturn 1\n\tfi\n}\n\n# Set up function to send TCP traffic on IPv6\nsetup_flood_tcp6() {\n\tif command -v iperf3 >/dev/null; then\n\t\tflood_tcp6() {\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-p ${dst_port}\"\n\t\t\tif [ -n \"${src_addr6}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr6}\" dev veth_b nodad\n\t\t\t\tsrc_addr6=\"-B ${src_addr6}\"\n\t\t\telse\n\t\t\t\tsrc_addr6=\"-B 2001:db8::2\"\n\t\t\tfi\n\t\t\tif [ -n \"${src_port}\" ]; then\n\t\t\t\tsrc_port=\"--cport ${src_port}\"\n\t\t\tfi\n\t\t\tB ip route add default dev veth_b\n\t\t\tip -6 addr add \"${dst_addr6}\" dev veth_a nodad \\\n\t\t\t\t2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tiperf3 -s -DB \"${dst_addr6}\" ${dst_port} >/dev/null 2>&1\n\t\t\tsleep 2\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB iperf3 -c \"${dst_addr6}\" ${dst_port} \\\n\t\t\t\t${src_port} ${src_addr6} -l16 -t 1000\n\n\t\t\tsrc_addr6=\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t}\n\telif command -v iperf >/dev/null; then\n\t\tflood_tcp6() {\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-p ${dst_port}\"\n\t\t\tif [ -n \"${src_addr6}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr6}\" dev veth_b nodad\n\t\t\t\tsrc_addr6=\"-B ${src_addr6}\"\n\t\t\telse\n\t\t\t\tsrc_addr6=\"-B 2001:db8::2\"\n\t\t\tfi\n\t\t\tif [ -n \"${src_port}\" ]; then\n\t\t\t\tsrc_addr6=\"${src_addr6}:${src_port}\"\n\t\t\tfi\n\t\t\tB ip route add default dev veth_b\n\t\t\tip -6 addr add \"${dst_addr6}\" dev veth_a nodad \\\n\t\t\t\t2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tiperf -s -VDB \"${dst_addr6}\" ${dst_port} >/dev/null 2>&1\n\t\t\tsleep 2\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB iperf -c \"${dst_addr6}\" -V ${dst_port} \\\n\t\t\t\t${src_addr6} -l1 -t 1000\n\n\t\t\tsrc_addr6=\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t}\n\telif command -v netperf >/dev/null; then\n\t\tflood_tcp6() {\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-p ${dst_port}\"\n\t\t\tif [ -n \"${src_addr6}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr6}\" dev veth_b nodad\n\t\t\telse\n\t\t\t\tsrc_addr6=\"2001:db8::2\"\n\t\t\tfi\n\t\t\tif [ -n \"${src_port}\" ]; then\n\t\t\t\tdst_port=\"${dst_port},${src_port}\"\n\t\t\tfi\n\t\t\tB ip route add default dev veth_b\n\t\t\tip -6 addr add \"${dst_addr6}\" dev veth_a nodad \\\n\t\t\t\t2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tnetserver -6 ${dst_port} -L \"${dst_addr6}\" \\\n\t\t\t\t>/dev/null 2>&1\n\t\t\tsleep 2\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB netperf -6 -H \"${dst_addr6}\" ${dst_port} \\\n\t\t\t\t-L \"${src_addr6}\" -l 1000 -t TCP_STREAM\n\n\t\t\tsrc_addr6=\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t}\n\telse\n\t\treturn 1\n\tfi\n}\n\n# Set up function to send UDP traffic on IPv4\nsetup_flood_udp() {\n\tif command -v iperf3 >/dev/null; then\n\t\tflood_udp() {\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-p ${dst_port}\"\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr4}/16\" dev veth_b\n\t\t\t\tsrc_addr4=\"-B ${src_addr4}\"\n\t\t\telse\n\t\t\t\tB ip addr add dev veth_b 10.0.0.2 2>/dev/null\n\t\t\t\tsrc_addr4=\"-B 10.0.0.2\"\n\t\t\tfi\n\t\t\tif [ -n \"${src_port}\" ]; then\n\t\t\t\tsrc_port=\"--cport ${src_port}\"\n\t\t\tfi\n\t\t\tB ip route add default dev veth_b\n\t\t\tip addr add \"${dst_addr4}\" dev veth_a 2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tiperf3 -s -DB \"${dst_addr4}\" ${dst_port}\n\t\t\tsleep 2\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB iperf3 -u -c \"${dst_addr4}\" -Z -b 100M -l16 -t1000 \\\n\t\t\t\t${dst_port} ${src_port} ${src_addr4}\n\n\t\t\tsrc_addr4=\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t}\n\telif command -v iperf >/dev/null; then\n\t\tflood_udp() {\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-p ${dst_port}\"\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr4}/16\" dev veth_b\n\t\t\t\tsrc_addr4=\"-B ${src_addr4}\"\n\t\t\telse\n\t\t\t\tB ip addr add dev veth_b 10.0.0.2\n\t\t\t\tsrc_addr4=\"-B 10.0.0.2\"\n\t\t\tfi\n\t\t\tif [ -n \"${src_port}\" ]; then\n\t\t\t\tsrc_addr4=\"${src_addr4}:${src_port}\"\n\t\t\tfi\n\t\t\tB ip route add default dev veth_b\n\t\t\tip addr add \"${dst_addr4}\" dev veth_a 2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tiperf -u -sDB \"${dst_addr4}\" ${dst_port} >/dev/null 2>&1\n\t\t\tsleep 2\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB iperf -u -c \"${dst_addr4}\" -b 100M -l1 -t1000 \\\n\t\t\t\t${dst_port} ${src_addr4}\n\n\t\t\tsrc_addr4=\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t}\n\telif command -v netperf >/dev/null; then\n\t\tflood_udp() {\n\t\t\t[ -n \"${dst_port}\" ] && dst_port=\"-p ${dst_port}\"\n\t\t\tif [ -n \"${src_addr4}\" ]; then\n\t\t\t\tB ip addr add \"${src_addr4}/16\" dev veth_b\n\t\t\telse\n\t\t\t\tB ip addr add dev veth_b 10.0.0.2\n\t\t\t\tsrc_addr4=\"10.0.0.2\"\n\t\t\tfi\n\t\t\tif [ -n \"${src_port}\" ]; then\n\t\t\t\tdst_port=\"${dst_port},${src_port}\"\n\t\t\tfi\n\t\t\tB ip route add default dev veth_b\n\t\t\tip addr add \"${dst_addr4}\" dev veth_a 2>/dev/null\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tnetserver -4 ${dst_port} -L \"${dst_addr4}\" \\\n\t\t\t\t>/dev/null 2>&1\n\t\t\tsleep 2\n\n\t\t\t# shellcheck disable=SC2086 # this needs split options\n\t\t\tB netperf -4 -H \"${dst_addr4}\" ${dst_port} \\\n\t\t\t\t-L \"${src_addr4}\" -l 1000 -t UDP_STREAM\n\n\t\t\tsrc_addr4=\n\t\t\tsrc_port=\n\t\t\tdst_port=\n\t\t}\n\telse\n\t\treturn 1\n\tfi\n}\n\n# Find pktgen script and set up function to start pktgen injection\nsetup_perf() {\n\tfor pktgen_script_path in ${PKTGEN_SCRIPT_PATHS} __notfound; do\n\t\tcommand -v \"${pktgen_script_path}\" >/dev/null && break\n\tdone\n\t[ \"${pktgen_script_path}\" = \"__notfound\" ] && return 1\n\n\tperf_ipv4() {\n\t\t${pktgen_script_path} -s80 \\\n\t\t\t-i veth_a -d \"${dst_addr4}\" -p \"${dst_port}\" \\\n\t\t\t-m \"${dst_mac}\" \\\n\t\t\t-t $(($(nproc) / 5 + 1)) -b10000 -n0 2>/dev/null &\n\t\tperf_pid=$!\n\t}\n\tperf_ipv6() {\n\t\tIP6=6 ${pktgen_script_path} -s100 \\\n\t\t\t-i veth_a -d \"${dst_addr6}\" -p \"${dst_port}\" \\\n\t\t\t-m \"${dst_mac}\" \\\n\t\t\t-t $(($(nproc) / 5 + 1)) -b10000 -n0 2>/dev/null &\n\t\tperf_pid=$!\n\t}\n}\n\n# Clean up before each test\ncleanup() {\n\tnft reset counter inet filter test\t>/dev/null 2>&1\n\tnft flush ruleset\t\t\t>/dev/null 2>&1\n\tip link del dummy0\t\t\t2>/dev/null\n\tip route del default\t\t\t2>/dev/null\n\tip -6 route del default\t\t\t2>/dev/null\n\tip netns del B\t\t\t\t2>/dev/null\n\tip link del veth_a\t\t\t2>/dev/null\n\ttimeout=\n\tkillall iperf3\t\t\t\t2>/dev/null\n\tkillall iperf\t\t\t\t2>/dev/null\n\tkillall netperf\t\t\t\t2>/dev/null\n\tkillall netserver\t\t\t2>/dev/null\n\trm -f ${tmp}\n\tsleep 2\n}\n\n# Entry point for setup functions\nsetup() {\n\tif [ \"$(id -u)\" -ne 0 ]; then\n\t\techo \"  need to run as root\"\n\t\texit ${KSELFTEST_SKIP}\n\tfi\n\n\tcleanup\n\tcheck_tools || return 1\n\tfor arg do\n\t\tif ! eval setup_\"${arg}\"; then\n\t\t\terr \"  ${arg} not supported\"\n\t\t\treturn 1\n\t\tfi\n\tdone\n}\n\n# Format integer into IPv4 address, summing 10.0.0.5 (arbitrary) to it\nformat_addr4() {\n\ta=$((${1} + 16777216 * 10 + 5))\n\tprintf \"%i.%i.%i.%i\"\t\t\t\t\t\t\\\n\t       \"$((a / 16777216))\" \"$((a % 16777216 / 65536))\"\t\\\n\t       \"$((a % 65536 / 256))\" \"$((a % 256))\"\n}\n\n# Format integer into IPv6 address, summing 2001:db8:: to it\nformat_addr6() {\n\tprintf \"2001:db8::%04x:%04x\" \"$((${1} / 65536))\" \"$((${1} % 65536))\"\n}\n\n# Format integer into EUI-48 address, summing 00:01:00:00:00:00 to it\nformat_mac() {\n\tprintf \"00:01:%02x:%02x:%02x:%02x\" \\\n\t       \"$((${1} / 16777216))\" \"$((${1} % 16777216 / 65536))\"\t\\\n\t       \"$((${1} % 65536 / 256))\" \"$((${1} % 256))\"\n}\n\n# Format integer into port, avoid 0 port\nformat_port() {\n\tprintf \"%i\" \"$((${1} % 65534 + 1))\"\n}\n\n# Drop suffixed '6' from L4 protocol, if any\nformat_proto() {\n\tprintf \"%s\" \"${proto}\" | tr -d 6\n}\n\n# Format destination and source fields into nft concatenated type\nformat() {\n\t__start=\n\t__end=\n\t__expr=\"{ \"\n\n\tfor f in ${dst}; do\n\t\t[ \"${__expr}\" != \"{ \" ] && __expr=\"${__expr} . \"\n\n\t\t__start=\"$(eval format_\"${f}\" \"${start}\")\"\n\t\t__end=\"$(eval format_\"${f}\" \"${end}\")\"\n\n\t\tif [ \"${f}\" = \"proto\" ]; then\n\t\t\t__expr=\"${__expr}${__start}\"\n\t\telse\n\t\t\t__expr=\"${__expr}${__start}-${__end}\"\n\t\tfi\n\tdone\n\tfor f in ${src}; do\n\t\t[ \"${__expr}\" != \"{ \" ] && __expr=\"${__expr} . \"\n\n\t\t__start=\"$(eval format_\"${f}\" \"${srcstart}\")\"\n\t\t__end=\"$(eval format_\"${f}\" \"${srcend}\")\"\n\n\t\tif [ \"${f}\" = \"proto\" ]; then\n\t\t\t__expr=\"${__expr}${__start}\"\n\t\telse\n\t\t\t__expr=\"${__expr}${__start}-${__end}\"\n\t\tfi\n\tdone\n\n\tif [ -n \"${timeout}\" ]; then\n\t\techo \"${__expr} timeout ${timeout}s }\"\n\telse\n\t\techo \"${__expr} }\"\n\tfi\n}\n\n# Format destination and source fields into nft type, start element only\nformat_norange() {\n\t__expr=\"{ \"\n\n\tfor f in ${dst}; do\n\t\t[ \"${__expr}\" != \"{ \" ] && __expr=\"${__expr} . \"\n\n\t\t__expr=\"${__expr}$(eval format_\"${f}\" \"${start}\")\"\n\tdone\n\tfor f in ${src}; do\n\t\t__expr=\"${__expr} . $(eval format_\"${f}\" \"${start}\")\"\n\tdone\n\n\techo \"${__expr} }\"\n}\n\n# Format first destination field into nft type\nformat_noconcat() {\n\tfor f in ${dst}; do\n\t\t__start=\"$(eval format_\"${f}\" \"${start}\")\"\n\t\t__end=\"$(eval format_\"${f}\" \"${end}\")\"\n\n\t\tif [ \"${f}\" = \"proto\" ]; then\n\t\t\techo \"{ ${__start} }\"\n\t\telse\n\t\t\techo \"{ ${__start}-${__end} }\"\n\t\tfi\n\t\treturn\n\tdone\n}\n\n# Add single entry to 'test' set in 'inet filter' table\nadd() {\n\tif ! nft add element inet filter test \"${1}\"; then\n\t\terr \"Failed to add ${1} given ruleset:\"\n\t\terr \"$(nft -a list ruleset)\"\n\t\treturn 1\n\tfi\n}\n\n# Format and output entries for sets in 'netdev perf' table\nadd_perf() {\n\tif [ \"${1}\" = \"test\" ]; then\n\t\techo \"add element netdev perf test $(format)\"\n\telif [ \"${1}\" = \"norange\" ]; then\n\t\techo \"add element netdev perf norange $(format_norange)\"\n\telif [ \"${1}\" = \"noconcat\" ]; then\n\t\techo \"add element netdev perf noconcat $(format_noconcat)\"\n\tfi\n}\n\n# Add single entry to 'norange' set in 'netdev perf' table\nadd_perf_norange() {\n\tif ! nft add element netdev perf norange \"${1}\"; then\n\t\terr \"Failed to add ${1} given ruleset:\"\n\t\terr \"$(nft -a list ruleset)\"\n\t\treturn 1\n\tfi\n}\n\n# Add single entry to 'noconcat' set in 'netdev perf' table\nadd_perf_noconcat() {\n\tif ! nft add element netdev perf noconcat \"${1}\"; then\n\t\terr \"Failed to add ${1} given ruleset:\"\n\t\terr \"$(nft -a list ruleset)\"\n\t\treturn 1\n\tfi\n}\n\n# Delete single entry from set\ndel() {\n\tif ! nft delete element inet filter test \"${1}\"; then\n\t\terr \"Failed to delete ${1} given ruleset:\"\n\t\terr \"$(nft -a list ruleset)\"\n\t\treturn 1\n\tfi\n}\n\n# Return packet count from 'test' counter in 'inet filter' table\ncount_packets() {\n\tfound=0\n\tfor token in $(nft list counter inet filter test); do\n\t\t[ ${found} -eq 1 ] && echo \"${token}\" && return\n\t\t[ \"${token}\" = \"packets\" ] && found=1\n\tdone\n}\n\n# Return packet count from 'test' counter in 'netdev perf' table\ncount_perf_packets() {\n\tfound=0\n\tfor token in $(nft list counter netdev perf test); do\n\t\t[ ${found} -eq 1 ] && echo \"${token}\" && return\n\t\t[ \"${token}\" = \"packets\" ] && found=1\n\tdone\n}\n\n# Set MAC addresses, send traffic according to specifier\nflood() {\n\tip link set veth_a address \"$(format_mac \"${1}\")\"\n\tip -n B link set veth_b address \"$(format_mac \"${2}\")\"\n\n\tfor f in ${dst}; do\n\t\teval dst_\"$f\"=\\$\\(format_\\$f \"${1}\"\\)\n\tdone\n\tfor f in ${src}; do\n\t\teval src_\"$f\"=\\$\\(format_\\$f \"${2}\"\\)\n\tdone\n\teval flood_\\$proto\n}\n\n# Set MAC addresses, start pktgen injection\nperf() {\n\tdst_mac=\"$(format_mac \"${1}\")\"\n\tip link set veth_a address \"${dst_mac}\"\n\n\tfor f in ${dst}; do\n\t\teval dst_\"$f\"=\\$\\(format_\\$f \"${1}\"\\)\n\tdone\n\tfor f in ${src}; do\n\t\teval src_\"$f\"=\\$\\(format_\\$f \"${2}\"\\)\n\tdone\n\teval perf_\\$perf_proto\n}\n\n# Set MAC addresses, send single packet, check that it matches, reset counter\nsend_match() {\n\tip link set veth_a address \"$(format_mac \"${1}\")\"\n\tip -n B link set veth_b address \"$(format_mac \"${2}\")\"\n\n\tfor f in ${dst}; do\n\t\teval dst_\"$f\"=\\$\\(format_\\$f \"${1}\"\\)\n\tdone\n\tfor f in ${src}; do\n\t\teval src_\"$f\"=\\$\\(format_\\$f \"${2}\"\\)\n\tdone\n\teval send_\\$proto\n\tif [ \"$(count_packets)\" != \"1\" ]; then\n\t\terr \"${proto} packet to:\"\n\t\terr \"  $(for f in ${dst}; do\n\t\t\t eval format_\\$f \"${1}\"; printf ' '; done)\"\n\t\terr \"from:\"\n\t\terr \"  $(for f in ${src}; do\n\t\t\t eval format_\\$f \"${2}\"; printf ' '; done)\"\n\t\terr \"should have matched ruleset:\"\n\t\terr \"$(nft -a list ruleset)\"\n\t\treturn 1\n\tfi\n\tnft reset counter inet filter test >/dev/null\n}\n\n# Set MAC addresses, send single packet, check that it doesn't match\nsend_nomatch() {\n\tip link set veth_a address \"$(format_mac \"${1}\")\"\n\tip -n B link set veth_b address \"$(format_mac \"${2}\")\"\n\n\tfor f in ${dst}; do\n\t\teval dst_\"$f\"=\\$\\(format_\\$f \"${1}\"\\)\n\tdone\n\tfor f in ${src}; do\n\t\teval src_\"$f\"=\\$\\(format_\\$f \"${2}\"\\)\n\tdone\n\teval send_\\$proto\n\tif [ \"$(count_packets)\" != \"0\" ]; then\n\t\terr \"${proto} packet to:\"\n\t\terr \"  $(for f in ${dst}; do\n\t\t\t eval format_\\$f \"${1}\"; printf ' '; done)\"\n\t\terr \"from:\"\n\t\terr \"  $(for f in ${src}; do\n\t\t\t eval format_\\$f \"${2}\"; printf ' '; done)\"\n\t\terr \"should not have matched ruleset:\"\n\t\terr \"$(nft -a list ruleset)\"\n\t\treturn 1\n\tfi\n}\n\n# Correctness test template:\n# - add ranged element, check that packets match it\n# - check that packets outside range don't match it\n# - remove some elements, check that packets don't match anymore\ntest_correctness() {\n\tsetup veth send_\"${proto}\" set || return ${KSELFTEST_SKIP}\n\n\trange_size=1\n\tfor i in $(seq \"${start}\" $((start + count))); do\n\t\tend=$((start + range_size))\n\n\t\t# Avoid negative or zero-sized port ranges\n\t\tif [ $((end / 65534)) -gt $((start / 65534)) ]; then\n\t\t\tstart=${end}\n\t\t\tend=$((end + 1))\n\t\tfi\n\t\tsrcstart=$((start + src_delta))\n\t\tsrcend=$((end + src_delta))\n\n\t\tadd \"$(format)\" || return 1\n\t\tfor j in $(seq ${start} $((range_size / 2 + 1)) ${end}); do\n\t\t\tsend_match \"${j}\" $((j + src_delta)) || return 1\n\t\tdone\n\t\tsend_nomatch $((end + 1)) $((end + 1 + src_delta)) || return 1\n\n\t\t# Delete elements now and then\n\t\tif [ $((i % 3)) -eq 0 ]; then\n\t\t\tdel \"$(format)\" || return 1\n\t\t\tfor j in $(seq ${start} \\\n\t\t\t\t   $((range_size / 2 + 1)) ${end}); do\n\t\t\t\tsend_nomatch \"${j}\" $((j + src_delta)) \\\n\t\t\t\t\t|| return 1\n\t\t\tdone\n\t\tfi\n\n\t\trange_size=$((range_size + 1))\n\t\tstart=$((end + range_size))\n\tdone\n}\n\n# Concurrency test template:\n# - add all the elements\n# - start a thread for each physical thread that:\n#   - adds all the elements\n#   - flushes the set\n#   - adds all the elements\n#   - flushes the entire ruleset\n#   - adds the set back\n#   - adds all the elements\n#   - delete all the elements\ntest_concurrency() {\n\tproto=${flood_proto}\n\ttools=${flood_tools}\n\tchain_spec=${flood_spec}\n\tsetup veth flood_\"${proto}\" set || return ${KSELFTEST_SKIP}\n\n\trange_size=1\n\tcstart=${start}\n\tflood_pids=\n\tfor i in $(seq ${start} $((start + count))); do\n\t\tend=$((start + range_size))\n\t\tsrcstart=$((start + src_delta))\n\t\tsrcend=$((end + src_delta))\n\n\t\tadd \"$(format)\" || return 1\n\n\t\tflood \"${i}\" $((i + src_delta)) & flood_pids=\"${flood_pids} $!\"\n\n\t\trange_size=$((range_size + 1))\n\t\tstart=$((end + range_size))\n\tdone\n\n\tsleep 10\n\n\tpids=\n\tfor c in $(seq 1 \"$(nproc)\"); do (\n\t\tfor r in $(seq 1 \"${race_repeat}\"); do\n\t\t\trange_size=1\n\n\t\t\t# $start needs to be local to this subshell\n\t\t\t# shellcheck disable=SC2030\n\t\t\tstart=${cstart}\n\t\t\tfor i in $(seq ${start} $((start + count))); do\n\t\t\t\tend=$((start + range_size))\n\t\t\t\tsrcstart=$((start + src_delta))\n\t\t\t\tsrcend=$((end + src_delta))\n\n\t\t\t\tadd \"$(format)\" 2>/dev/null\n\n\t\t\t\trange_size=$((range_size + 1))\n\t\t\t\tstart=$((end + range_size))\n\t\t\tdone\n\n\t\t\tnft flush inet filter test 2>/dev/null\n\n\t\t\trange_size=1\n\t\t\tstart=${cstart}\n\t\t\tfor i in $(seq ${start} $((start + count))); do\n\t\t\t\tend=$((start + range_size))\n\t\t\t\tsrcstart=$((start + src_delta))\n\t\t\t\tsrcend=$((end + src_delta))\n\n\t\t\t\tadd \"$(format)\" 2>/dev/null\n\n\t\t\t\trange_size=$((range_size + 1))\n\t\t\t\tstart=$((end + range_size))\n\t\t\tdone\n\n\t\t\tnft flush ruleset\n\t\t\tsetup set 2>/dev/null\n\n\t\t\trange_size=1\n\t\t\tstart=${cstart}\n\t\t\tfor i in $(seq ${start} $((start + count))); do\n\t\t\t\tend=$((start + range_size))\n\t\t\t\tsrcstart=$((start + src_delta))\n\t\t\t\tsrcend=$((end + src_delta))\n\n\t\t\t\tadd \"$(format)\" 2>/dev/null\n\n\t\t\t\trange_size=$((range_size + 1))\n\t\t\t\tstart=$((end + range_size))\n\t\t\tdone\n\n\t\t\trange_size=1\n\t\t\tstart=${cstart}\n\t\t\tfor i in $(seq ${start} $((start + count))); do\n\t\t\t\tend=$((start + range_size))\n\t\t\t\tsrcstart=$((start + src_delta))\n\t\t\t\tsrcend=$((end + src_delta))\n\n\t\t\t\tdel \"$(format)\" 2>/dev/null\n\n\t\t\t\trange_size=$((range_size + 1))\n\t\t\t\tstart=$((end + range_size))\n\t\t\tdone\n\t\tdone\n\t) & pids=\"${pids} $!\"\n\tdone\n\n\t# shellcheck disable=SC2046,SC2086 # word splitting wanted here\n\twait $(for pid in ${pids}; do echo ${pid}; done)\n\t# shellcheck disable=SC2046,SC2086\n\tkill $(for pid in ${flood_pids}; do echo ${pid}; done) 2>/dev/null\n\t# shellcheck disable=SC2046,SC2086\n\twait $(for pid in ${flood_pids}; do echo ${pid}; done) 2>/dev/null\n\n\treturn 0\n}\n\n# Timeout test template:\n# - add all the elements with 3s timeout while checking that packets match\n# - wait 3s after the last insertion, check that packets don't match any entry\ntest_timeout() {\n\tsetup veth send_\"${proto}\" set || return ${KSELFTEST_SKIP}\n\n\ttimeout=3\n\trange_size=1\n\tfor i in $(seq \"${start}\" $((start + count))); do\n\t\tend=$((start + range_size))\n\t\tsrcstart=$((start + src_delta))\n\t\tsrcend=$((end + src_delta))\n\n\t\tadd \"$(format)\" || return 1\n\n\t\tfor j in $(seq ${start} $((range_size / 2 + 1)) ${end}); do\n\t\t\tsend_match \"${j}\" $((j + src_delta)) || return 1\n\t\tdone\n\n\t\trange_size=$((range_size + 1))\n\t\tstart=$((end + range_size))\n\tdone\n\tsleep 3\n\tfor i in $(seq ${start} $((start + count))); do\n\t\tend=$((start + range_size))\n\t\tsrcstart=$((start + src_delta))\n\t\tsrcend=$((end + src_delta))\n\n\t\tfor j in $(seq ${start} $((range_size / 2 + 1)) ${end}); do\n\t\t\tsend_nomatch \"${j}\" $((j + src_delta)) || return 1\n\t\tdone\n\n\t\trange_size=$((range_size + 1))\n\t\tstart=$((end + range_size))\n\tdone\n}\n\n# Performance test template:\n# - add concatenated ranged entries\n# - add non-ranged concatenated entries (for hash set matching rate baseline)\n# - add ranged entries with first field only (for rbhash baseline)\n# - start pktgen injection directly on device rx path of this namespace\n# - measure drop only rate, hash and rbtree baselines, then matching rate\ntest_performance() {\n\tchain_spec=${perf_spec}\n\tdst=\"${perf_dst}\"\n\tsrc=\"${perf_src}\"\n\tsetup veth perf set || return ${KSELFTEST_SKIP}\n\n\tfirst=${start}\n\trange_size=1\n\tfor set in test norange noconcat; do\n\t\tstart=${first}\n\t\tfor i in $(seq ${start} $((start + perf_entries))); do\n\t\t\tend=$((start + range_size))\n\t\t\tsrcstart=$((start + src_delta))\n\t\t\tsrcend=$((end + src_delta))\n\n\t\t\tif [ $((end / 65534)) -gt $((start / 65534)) ]; then\n\t\t\t\tstart=${end}\n\t\t\t\tend=$((end + 1))\n\t\t\telif [ ${start} -eq ${end} ]; then\n\t\t\t\tend=$((start + 1))\n\t\t\tfi\n\n\t\t\tadd_perf ${set}\n\n\t\t\tstart=$((end + range_size))\n\t\tdone > \"${tmp}\"\n\t\tnft -f \"${tmp}\"\n\tdone\n\n\tperf $((end - 1)) ${srcstart}\n\n\tsleep 2\n\n\tnft add rule netdev perf test counter name \\\"test\\\" drop\n\tnft reset counter netdev perf test >/dev/null 2>&1\n\tsleep \"${perf_duration}\"\n\tpps=\"$(printf %10s $(($(count_perf_packets) / perf_duration)))\"\n\tinfo \"    baseline (drop from netdev hook):            ${pps}pps\"\n\thandle=\"$(nft -a list chain netdev perf test | grep counter)\"\n\thandle=\"${handle##* }\"\n\tnft delete rule netdev perf test handle \"${handle}\"\n\n\tnft add rule \"netdev perf test ${chain_spec} @norange \\\n\t\tcounter name \\\"test\\\" drop\"\n\tnft reset counter netdev perf test >/dev/null 2>&1\n\tsleep \"${perf_duration}\"\n\tpps=\"$(printf %10s $(($(count_perf_packets) / perf_duration)))\"\n\tinfo \"    baseline hash (non-ranged entries):          ${pps}pps\"\n\thandle=\"$(nft -a list chain netdev perf test | grep counter)\"\n\thandle=\"${handle##* }\"\n\tnft delete rule netdev perf test handle \"${handle}\"\n\n\tnft add rule \"netdev perf test ${chain_spec%%. *} @noconcat \\\n\t\tcounter name \\\"test\\\" drop\"\n\tnft reset counter netdev perf test >/dev/null 2>&1\n\tsleep \"${perf_duration}\"\n\tpps=\"$(printf %10s $(($(count_perf_packets) / perf_duration)))\"\n\tinfo \"    baseline rbtree (match on first field only): ${pps}pps\"\n\thandle=\"$(nft -a list chain netdev perf test | grep counter)\"\n\thandle=\"${handle##* }\"\n\tnft delete rule netdev perf test handle \"${handle}\"\n\n\tnft add rule \"netdev perf test ${chain_spec} @test \\\n\t\tcounter name \\\"test\\\" drop\"\n\tnft reset counter netdev perf test >/dev/null 2>&1\n\tsleep \"${perf_duration}\"\n\tpps=\"$(printf %10s $(($(count_perf_packets) / perf_duration)))\"\n\tp5=\"$(printf %5s \"${perf_entries}\")\"\n\tinfo \"    set with ${p5} full, ranged entries:         ${pps}pps\"\n\tkill \"${perf_pid}\"\n}\n\ntest_bug_flush_remove_add() {\n\tset_cmd='{ set s { type ipv4_addr . inet_service; flags interval; }; }'\n\telem1='{ 10.0.0.1 . 22-25, 10.0.0.1 . 10-20 }'\n\telem2='{ 10.0.0.1 . 10-20, 10.0.0.1 . 22-25 }'\n\tfor i in `seq 1 100`; do\n\t\tnft add table t ${set_cmd}\t|| return ${KSELFTEST_SKIP}\n\t\tnft add element t s ${elem1}\t2>/dev/null || return 1\n\t\tnft flush set t s\t\t2>/dev/null || return 1\n\t\tnft add element t s ${elem2}\t2>/dev/null || return 1\n\tdone\n\tnft flush ruleset\n}\n\n# - add ranged element, check that packets match it\n# - reload the set, check packets still match\ntest_bug_reload() {\n\tsetup veth send_\"${proto}\" set || return ${KSELFTEST_SKIP}\n\trstart=${start}\n\n\trange_size=1\n\tfor i in $(seq \"${start}\" $((start + count))); do\n\t\tend=$((start + range_size))\n\n\t\t# Avoid negative or zero-sized port ranges\n\t\tif [ $((end / 65534)) -gt $((start / 65534)) ]; then\n\t\t\tstart=${end}\n\t\t\tend=$((end + 1))\n\t\tfi\n\t\tsrcstart=$((start + src_delta))\n\t\tsrcend=$((end + src_delta))\n\n\t\tadd \"$(format)\" || return 1\n\t\trange_size=$((range_size + 1))\n\t\tstart=$((end + range_size))\n\tdone\n\n\t# check kernel does allocate pcpu sctrach map\n\t# for reload with no elemet add/delete\n\t( echo flush set inet filter test ;\n\t  nft list set inet filter test ) | nft -f -\n\n\tstart=${rstart}\n\trange_size=1\n\n\tfor i in $(seq \"${start}\" $((start + count))); do\n\t\tend=$((start + range_size))\n\n\t\t# Avoid negative or zero-sized port ranges\n\t\tif [ $((end / 65534)) -gt $((start / 65534)) ]; then\n\t\t\tstart=${end}\n\t\t\tend=$((end + 1))\n\t\tfi\n\t\tsrcstart=$((start + src_delta))\n\t\tsrcend=$((end + src_delta))\n\n\t\tfor j in $(seq ${start} $((range_size / 2 + 1)) ${end}); do\n\t\t\tsend_match \"${j}\" $((j + src_delta)) || return 1\n\t\tdone\n\n\t\trange_size=$((range_size + 1))\n\t\tstart=$((end + range_size))\n\tdone\n\n\tnft flush ruleset\n}\n\ntest_reported_issues() {\n\teval test_bug_\"${subtest}\"\n}\n\n# Run everything in a separate network namespace\n[ \"${1}\" != \"run\" ] && { unshare -n \"${0}\" run; exit $?; }\ntmp=\"$(mktemp)\"\ntrap cleanup EXIT\n\n# Entry point for test runs\npassed=0\nfor name in ${TESTS}; do\n\tprintf \"TEST: %s\\n\" \"$(echo ${name} | tr '_' ' ')\"\n\tif [ \"${name}\" = \"reported_issues\" ]; then\n\t\tSUBTESTS=\"${BUGS}\"\n\telse\n\t\tSUBTESTS=\"${TYPES}\"\n\tfi\n\n\tfor subtest in ${SUBTESTS}; do\n\t\teval desc=\\$TYPE_\"${subtest}\"\n\t\tIFS='\n'\n\t\tfor __line in ${desc}; do\n\t\t\t# shellcheck disable=SC2086\n\t\t\teval ${__line%%\t*}=\\\"${__line##*\t}\\\";\n\t\tdone\n\t\tIFS=' \t\n'\n\n\t\tif [ \"${name}\" = \"concurrency\" ] && \\\n\t\t   [ \"${race_repeat}\" = \"0\" ]; then\n\t\t\tcontinue\n\t\tfi\n\t\tif [ \"${name}\" = \"performance\" ] && \\\n\t\t   [ \"${perf_duration}\" = \"0\" ]; then\n\t\t\tcontinue\n\t\tfi\n\n\t\tprintf \"  %-60s  \" \"${display}\"\n\t\teval test_\"${name}\"\n\t\tret=$?\n\n\t\tif [ $ret -eq 0 ]; then\n\t\t\tprintf \"[ OK ]\\n\"\n\t\t\tinfo_flush\n\t\t\tpassed=$((passed + 1))\n\t\telif [ $ret -eq 1 ]; then\n\t\t\tprintf \"[FAIL]\\n\"\n\t\t\terr_flush\n\t\t\texit 1\n\t\telif [ $ret -eq ${KSELFTEST_SKIP} ]; then\n\t\t\tprintf \"[SKIP]\\n\"\n\t\t\terr_flush\n\t\tfi\n\tdone\ndone\n\n[ ${passed} -eq 0 ] && exit ${KSELFTEST_SKIP} || exit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}