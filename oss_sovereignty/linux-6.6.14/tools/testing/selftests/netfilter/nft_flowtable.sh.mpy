{
  "module_name": "nft_flowtable.sh",
  "hash_id": "ecd8bba5432ee0818c06bf30fb10d68a403b32ec1f5d6ffa8a674ac2720c8a26",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/nft_flowtable.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# This tests basic flowtable functionality.\n# Creates following default topology:\n#\n# Originator (MTU 9000) <-Router1-> MTU 1500 <-Router2-> Responder (MTU 2000)\n# Router1 is the one doing flow offloading, Router2 has no special\n# purpose other than having a link that is smaller than either Originator\n# and responder, i.e. TCPMSS announced values are too large and will still\n# result in fragmentation and/or PMTU discovery.\n#\n# You can check with different Orgininator/Link/Responder MTU eg:\n# nft_flowtable.sh -o8000 -l1500 -r2000\n#\n\nsfx=$(mktemp -u \"XXXXXXXX\")\nns1=\"ns1-$sfx\"\nns2=\"ns2-$sfx\"\nnsr1=\"nsr1-$sfx\"\nnsr2=\"nsr2-$sfx\"\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nret=0\n\nnsin=\"\"\nns1out=\"\"\nns2out=\"\"\n\nlog_netns=$(sysctl -n net.netfilter.nf_log_all_netns)\n\nchecktool (){\n\tif ! $1 > /dev/null 2>&1; then\n\t\techo \"SKIP: Could not $2\"\n\t\texit $ksft_skip\n\tfi\n}\n\nchecktool \"nft --version\" \"run test without nft tool\"\nchecktool \"ip -Version\" \"run test without ip tool\"\nchecktool \"which nc\" \"run test without nc (netcat)\"\nchecktool \"ip netns add $nsr1\" \"create net namespace $nsr1\"\n\nip netns add $ns1\nip netns add $ns2\nip netns add $nsr2\n\ncleanup() {\n\tip netns del $ns1\n\tip netns del $ns2\n\tip netns del $nsr1\n\tip netns del $nsr2\n\n\trm -f \"$nsin\" \"$ns1out\" \"$ns2out\"\n\n\t[ $log_netns -eq 0 ] && sysctl -q net.netfilter.nf_log_all_netns=$log_netns\n}\n\ntrap cleanup EXIT\n\nsysctl -q net.netfilter.nf_log_all_netns=1\n\nip link add veth0 netns $nsr1 type veth peer name eth0 netns $ns1\nip link add veth1 netns $nsr1 type veth peer name veth0 netns $nsr2\n\nip link add veth1 netns $nsr2 type veth peer name eth0 netns $ns2\n\nfor dev in lo veth0 veth1; do\n    ip -net $nsr1 link set $dev up\n    ip -net $nsr2 link set $dev up\ndone\n\nip -net $nsr1 addr add 10.0.1.1/24 dev veth0\nip -net $nsr1 addr add dead:1::1/64 dev veth0\n\nip -net $nsr2 addr add 10.0.2.1/24 dev veth1\nip -net $nsr2 addr add dead:2::1/64 dev veth1\n\n# set different MTUs so we need to push packets coming from ns1 (large MTU)\n# to ns2 (smaller MTU) to stack either to perform fragmentation (ip_no_pmtu_disc=1),\n# or to do PTMU discovery (send ICMP error back to originator).\n# ns2 is going via nsr2 with a smaller mtu, so that TCPMSS announced by both peers\n# is NOT the lowest link mtu.\n\nomtu=9000\nlmtu=1500\nrmtu=2000\n\nusage(){\n\techo \"nft_flowtable.sh [OPTIONS]\"\n\techo\n\techo \"MTU options\"\n\techo \"   -o originator\"\n\techo \"   -l link\"\n\techo \"   -r responder\"\n\texit 1\n}\n\nwhile getopts \"o:l:r:\" o\ndo\n\tcase $o in\n\t\to) omtu=$OPTARG;;\n\t\tl) lmtu=$OPTARG;;\n\t\tr) rmtu=$OPTARG;;\n\t\t*) usage;;\n\tesac\ndone\n\nif ! ip -net $nsr1 link set veth0 mtu $omtu; then\n\texit 1\nfi\n\nip -net $ns1 link set eth0 mtu $omtu\n\nif ! ip -net $nsr2 link set veth1 mtu $rmtu; then\n\texit 1\nfi\n\nip -net $ns2 link set eth0 mtu $rmtu\n\n# transfer-net between nsr1 and nsr2.\n# these addresses are not used for connections.\nip -net $nsr1 addr add 192.168.10.1/24 dev veth1\nip -net $nsr1 addr add fee1:2::1/64 dev veth1\n\nip -net $nsr2 addr add 192.168.10.2/24 dev veth0\nip -net $nsr2 addr add fee1:2::2/64 dev veth0\n\nfor i in 0 1; do\n  ip netns exec $nsr1 sysctl net.ipv4.conf.veth$i.forwarding=1 > /dev/null\n  ip netns exec $nsr2 sysctl net.ipv4.conf.veth$i.forwarding=1 > /dev/null\ndone\n\nfor ns in $ns1 $ns2;do\n  ip -net $ns link set lo up\n  ip -net $ns link set eth0 up\n\n  if ! ip netns exec $ns sysctl net.ipv4.tcp_no_metrics_save=1 > /dev/null; then\n\techo \"ERROR: Check Originator/Responder values (problem during address addition)\"\n\texit 1\n  fi\n  # don't set ip DF bit for first two tests\n  ip netns exec $ns sysctl net.ipv4.ip_no_pmtu_disc=1 > /dev/null\ndone\n\nip -net $ns1 addr add 10.0.1.99/24 dev eth0\nip -net $ns2 addr add 10.0.2.99/24 dev eth0\nip -net $ns1 route add default via 10.0.1.1\nip -net $ns2 route add default via 10.0.2.1\nip -net $ns1 addr add dead:1::99/64 dev eth0\nip -net $ns2 addr add dead:2::99/64 dev eth0\nip -net $ns1 route add default via dead:1::1\nip -net $ns2 route add default via dead:2::1\n\nip -net $nsr1 route add default via 192.168.10.2\nip -net $nsr2 route add default via 192.168.10.1\n\nip netns exec $nsr1 nft -f - <<EOF\ntable inet filter {\n  flowtable f1 {\n     hook ingress priority 0\n     devices = { veth0, veth1 }\n   }\n\n   counter routed_orig { }\n   counter routed_repl { }\n\n   chain forward {\n      type filter hook forward priority 0; policy drop;\n\n      # flow offloaded? Tag ct with mark 1, so we can detect when it fails.\n      meta oif \"veth1\" tcp dport 12345 ct mark set 1 flow add @f1 counter name routed_orig accept\n\n      # count packets supposedly offloaded as per direction.\n      ct mark 1 counter name ct direction map { original : routed_orig, reply : routed_repl } accept\n\n      ct state established,related accept\n\n      meta nfproto ipv4 meta l4proto icmp accept\n      meta nfproto ipv6 meta l4proto icmpv6 accept\n   }\n}\nEOF\n\nif [ $? -ne 0 ]; then\n\techo \"SKIP: Could not load nft ruleset\"\n\texit $ksft_skip\nfi\n\nip netns exec $ns2 nft -f - <<EOF\ntable inet filter {\n   counter ip4dscp0 { }\n   counter ip4dscp3 { }\n\n   chain input {\n      type filter hook input priority 0; policy accept;\n      meta l4proto tcp goto {\n\t      ip dscp cs3 counter name ip4dscp3 accept\n\t      ip dscp 0 counter name ip4dscp0 accept\n      }\n   }\n}\nEOF\n\nif [ $? -ne 0 ]; then\n\techo \"SKIP: Could not load nft ruleset\"\n\texit $ksft_skip\nfi\n\n# test basic connectivity\nif ! ip netns exec $ns1 ping -c 1 -q 10.0.2.99 > /dev/null; then\n  echo \"ERROR: $ns1 cannot reach ns2\" 1>&2\n  exit 1\nfi\n\nif ! ip netns exec $ns2 ping -c 1 -q 10.0.1.99 > /dev/null; then\n  echo \"ERROR: $ns2 cannot reach $ns1\" 1>&2\n  exit 1\nfi\n\nif [ $ret -eq 0 ];then\n\techo \"PASS: netns routing/connectivity: $ns1 can reach $ns2\"\nfi\n\nnsin=$(mktemp)\nns1out=$(mktemp)\nns2out=$(mktemp)\n\nmake_file()\n{\n\tname=$1\n\n\tSIZE=$((RANDOM % (1024 * 128)))\n\tSIZE=$((SIZE + (1024 * 8)))\n\tTSIZE=$((SIZE * 1024))\n\n\tdd if=/dev/urandom of=\"$name\" bs=1024 count=$SIZE 2> /dev/null\n\n\tSIZE=$((RANDOM % 1024))\n\tSIZE=$((SIZE + 128))\n\tTSIZE=$((TSIZE + SIZE))\n\tdd if=/dev/urandom conf=notrunc of=\"$name\" bs=1 count=$SIZE 2> /dev/null\n}\n\ncheck_counters()\n{\n\tlocal what=$1\n\tlocal ok=1\n\n\tlocal orig=$(ip netns exec $nsr1 nft reset counter inet filter routed_orig | grep packets)\n\tlocal repl=$(ip netns exec $nsr1 nft reset counter inet filter routed_repl | grep packets)\n\n\tlocal orig_cnt=${orig#*bytes}\n\tlocal repl_cnt=${repl#*bytes}\n\n\tlocal fs=$(du -sb $nsin)\n\tlocal max_orig=${fs%%/*}\n\tlocal max_repl=$((max_orig/4))\n\n\tif [ $orig_cnt -gt $max_orig ];then\n\t\techo \"FAIL: $what: original counter $orig_cnt exceeds expected value $max_orig\" 1>&2\n\t\tret=1\n\t\tok=0\n\tfi\n\n\tif [ $repl_cnt -gt $max_repl ];then\n\t\techo \"FAIL: $what: reply counter $repl_cnt exceeds expected value $max_repl\" 1>&2\n\t\tret=1\n\t\tok=0\n\tfi\n\n\tif [ $ok -eq 1 ]; then\n\t\techo \"PASS: $what\"\n\tfi\n}\n\ncheck_dscp()\n{\n\tlocal what=$1\n\tlocal ok=1\n\n\tlocal counter=$(ip netns exec $ns2 nft reset counter inet filter ip4dscp3 | grep packets)\n\n\tlocal pc4=${counter%*bytes*}\n\tlocal pc4=${pc4#*packets}\n\n\tlocal counter=$(ip netns exec $ns2 nft reset counter inet filter ip4dscp0 | grep packets)\n\tlocal pc4z=${counter%*bytes*}\n\tlocal pc4z=${pc4z#*packets}\n\n\tcase \"$what\" in\n\t\"dscp_none\")\n\t\tif [ $pc4 -gt 0 ] || [ $pc4z -eq 0 ]; then\n\t\t\techo \"FAIL: dscp counters do not match, expected dscp3 == 0, dscp0 > 0, but got $pc4,$pc4z\" 1>&2\n\t\t\tret=1\n\t\t\tok=0\n\t\tfi\n\t\t;;\n\t\"dscp_fwd\")\n\t\tif [ $pc4 -eq 0 ] || [ $pc4z -eq 0 ]; then\n\t\t\techo \"FAIL: dscp counters do not match, expected dscp3 and dscp0 > 0 but got $pc4,$pc4z\" 1>&2\n\t\t\tret=1\n\t\t\tok=0\n\t\tfi\n\t\t;;\n\t\"dscp_ingress\")\n\t\tif [ $pc4 -eq 0 ] || [ $pc4z -gt 0 ]; then\n\t\t\techo \"FAIL: dscp counters do not match, expected dscp3 > 0, dscp0 == 0 but got $pc4,$pc4z\" 1>&2\n\t\t\tret=1\n\t\t\tok=0\n\t\tfi\n\t\t;;\n\t\"dscp_egress\")\n\t\tif [ $pc4 -eq 0 ] || [ $pc4z -gt 0 ]; then\n\t\t\techo \"FAIL: dscp counters do not match, expected dscp3 > 0, dscp0 == 0 but got $pc4,$pc4z\" 1>&2\n\t\t\tret=1\n\t\t\tok=0\n\t\tfi\n\t\t;;\n\t*)\n\t\techo \"FAIL: Unknown DSCP check\" 1>&2\n\t\tret=1\n\t\tok=0\n\tesac\n\n\tif [ $ok -eq 1 ] ;then\n\t\techo \"PASS: $what: dscp packet counters match\"\n\tfi\n}\n\ncheck_transfer()\n{\n\tin=$1\n\tout=$2\n\twhat=$3\n\n\tif ! cmp \"$in\" \"$out\" > /dev/null 2>&1; then\n\t\techo \"FAIL: file mismatch for $what\" 1>&2\n\t\tls -l \"$in\"\n\t\tls -l \"$out\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\ntest_tcp_forwarding_ip()\n{\n\tlocal nsa=$1\n\tlocal nsb=$2\n\tlocal dstip=$3\n\tlocal dstport=$4\n\tlocal lret=0\n\n\tip netns exec $nsb nc -w 5 -l -p 12345 < \"$nsin\" > \"$ns2out\" &\n\tlpid=$!\n\n\tsleep 1\n\tip netns exec $nsa nc -w 4 \"$dstip\" \"$dstport\" < \"$nsin\" > \"$ns1out\" &\n\tcpid=$!\n\n\tsleep 1\n\n\tprev=\"$(ls -l $ns1out $ns2out)\"\n\tsleep 1\n\n\twhile [[ \"$prev\" != \"$(ls -l $ns1out $ns2out)\" ]]; do\n\t\tsleep 1;\n\t\tprev=\"$(ls -l $ns1out $ns2out)\"\n\tdone\n\n\tif test -d /proc/\"$lpid\"/; then\n\t\tkill $lpid\n\tfi\n\n\tif test -d /proc/\"$cpid\"/; then\n\t\tkill $cpid\n\tfi\n\n\twait $lpid\n\twait $cpid\n\n\tif ! check_transfer \"$nsin\" \"$ns2out\" \"ns1 -> ns2\"; then\n\t\tlret=1\n\tfi\n\n\tif ! check_transfer \"$nsin\" \"$ns1out\" \"ns1 <- ns2\"; then\n\t\tlret=1\n\tfi\n\n\treturn $lret\n}\n\ntest_tcp_forwarding()\n{\n\ttest_tcp_forwarding_ip \"$1\" \"$2\" 10.0.2.99 12345\n\n\treturn $?\n}\n\ntest_tcp_forwarding_set_dscp()\n{\n\tcheck_dscp \"dscp_none\"\n\nip netns exec $nsr1 nft -f - <<EOF\ntable netdev dscpmangle {\n   chain setdscp0 {\n      type filter hook ingress device \"veth0\" priority 0; policy accept\n\tip dscp set cs3\n  }\n}\nEOF\nif [ $? -eq 0 ]; then\n\ttest_tcp_forwarding_ip \"$1\" \"$2\"  10.0.2.99 12345\n\tcheck_dscp \"dscp_ingress\"\n\n\tip netns exec $nsr1 nft delete table netdev dscpmangle\nelse\n\techo \"SKIP: Could not load netdev:ingress for veth0\"\nfi\n\nip netns exec $nsr1 nft -f - <<EOF\ntable netdev dscpmangle {\n   chain setdscp0 {\n      type filter hook egress device \"veth1\" priority 0; policy accept\n      ip dscp set cs3\n  }\n}\nEOF\nif [ $? -eq 0 ]; then\n\ttest_tcp_forwarding_ip \"$1\" \"$2\"  10.0.2.99 12345\n\tcheck_dscp \"dscp_egress\"\n\n\tip netns exec $nsr1 nft flush table netdev dscpmangle\nelse\n\techo \"SKIP: Could not load netdev:egress for veth1\"\nfi\n\n\t# partial.  If flowtable really works, then both dscp-is-0 and dscp-is-cs3\n\t# counters should have seen packets (before and after ft offload kicks in).\n\tip netns exec $nsr1 nft -a insert rule inet filter forward ip dscp set cs3\n\ttest_tcp_forwarding_ip \"$1\" \"$2\"  10.0.2.99 12345\n\tcheck_dscp \"dscp_fwd\"\n}\n\ntest_tcp_forwarding_nat()\n{\n\tlocal lret\n\tlocal pmtu\n\n\ttest_tcp_forwarding_ip \"$1\" \"$2\" 10.0.2.99 12345\n\tlret=$?\n\n\tpmtu=$3\n\twhat=$4\n\n\tif [ $lret -eq 0 ] ; then\n\t\tif [ $pmtu -eq 1 ] ;then\n\t\t\tcheck_counters \"flow offload for ns1/ns2 with masquerade and pmtu discovery $what\"\n\t\telse\n\t\t\techo \"PASS: flow offload for ns1/ns2 with masquerade $what\"\n\t\tfi\n\n\t\ttest_tcp_forwarding_ip \"$1\" \"$2\" 10.6.6.6 1666\n\t\tlret=$?\n\t\tif [ $pmtu -eq 1 ] ;then\n\t\t\tcheck_counters \"flow offload for ns1/ns2 with dnat and pmtu discovery $what\"\n\t\telif [ $lret -eq 0 ] ; then\n\t\t\techo \"PASS: flow offload for ns1/ns2 with dnat $what\"\n\t\tfi\n\tfi\n\n\treturn $lret\n}\n\nmake_file \"$nsin\"\n\n# First test:\n# No PMTU discovery, nsr1 is expected to fragment packets from ns1 to ns2 as needed.\n# Due to MTU mismatch in both directions, all packets (except small packets like pure\n# acks) have to be handled by normal forwarding path.  Therefore, packet counters\n# are not checked.\nif test_tcp_forwarding $ns1 $ns2; then\n\techo \"PASS: flow offloaded for ns1/ns2\"\nelse\n\techo \"FAIL: flow offload for ns1/ns2:\" 1>&2\n\tip netns exec $nsr1 nft list ruleset\n\tret=1\nfi\n\n# delete default route, i.e. ns2 won't be able to reach ns1 and\n# will depend on ns1 being masqueraded in nsr1.\n# expect ns1 has nsr1 address.\nip -net $ns2 route del default via 10.0.2.1\nip -net $ns2 route del default via dead:2::1\nip -net $ns2 route add 192.168.10.1 via 10.0.2.1\n\n# Second test:\n# Same, but with NAT enabled.  Same as in first test: we expect normal forward path\n# to handle most packets.\nip netns exec $nsr1 nft -f - <<EOF\ntable ip nat {\n   chain prerouting {\n      type nat hook prerouting priority 0; policy accept;\n      meta iif \"veth0\" ip daddr 10.6.6.6 tcp dport 1666 counter dnat ip to 10.0.2.99:12345\n   }\n\n   chain postrouting {\n      type nat hook postrouting priority 0; policy accept;\n      meta oifname \"veth1\" counter masquerade\n   }\n}\nEOF\n\nif ! test_tcp_forwarding_set_dscp $ns1 $ns2 0 \"\"; then\n\techo \"FAIL: flow offload for ns1/ns2 with dscp update\" 1>&2\n\texit 0\nfi\n\nif ! test_tcp_forwarding_nat $ns1 $ns2 0 \"\"; then\n\techo \"FAIL: flow offload for ns1/ns2 with NAT\" 1>&2\n\tip netns exec $nsr1 nft list ruleset\n\tret=1\nfi\n\n# Third test:\n# Same as second test, but with PMTU discovery enabled. This\n# means that we expect the fastpath to handle packets as soon\n# as the endpoints adjust the packet size.\nip netns exec $ns1 sysctl net.ipv4.ip_no_pmtu_disc=0 > /dev/null\nip netns exec $ns2 sysctl net.ipv4.ip_no_pmtu_disc=0 > /dev/null\n\n# reset counters.\n# With pmtu in-place we'll also check that nft counters\n# are lower than file size and packets were forwarded via flowtable layer.\n# For earlier tests (large mtus), packets cannot be handled via flowtable\n# (except pure acks and other small packets).\nip netns exec $nsr1 nft reset counters table inet filter >/dev/null\n\nif ! test_tcp_forwarding_nat $ns1 $ns2 1 \"\"; then\n\techo \"FAIL: flow offload for ns1/ns2 with NAT and pmtu discovery\" 1>&2\n\tip netns exec $nsr1 nft list ruleset\nfi\n\n# Another test:\n# Add bridge interface br0 to Router1, with NAT enabled.\nip -net $nsr1 link add name br0 type bridge\nip -net $nsr1 addr flush dev veth0\nip -net $nsr1 link set up dev veth0\nip -net $nsr1 link set veth0 master br0\nip -net $nsr1 addr add 10.0.1.1/24 dev br0\nip -net $nsr1 addr add dead:1::1/64 dev br0\nip -net $nsr1 link set up dev br0\n\nip netns exec $nsr1 sysctl net.ipv4.conf.br0.forwarding=1 > /dev/null\n\n# br0 with NAT enabled.\nip netns exec $nsr1 nft -f - <<EOF\nflush table ip nat\ntable ip nat {\n   chain prerouting {\n      type nat hook prerouting priority 0; policy accept;\n      meta iif \"br0\" ip daddr 10.6.6.6 tcp dport 1666 counter dnat ip to 10.0.2.99:12345\n   }\n\n   chain postrouting {\n      type nat hook postrouting priority 0; policy accept;\n      meta oifname \"veth1\" counter masquerade\n   }\n}\nEOF\n\nif ! test_tcp_forwarding_nat $ns1 $ns2 1 \"on bridge\"; then\n\techo \"FAIL: flow offload for ns1/ns2 with bridge NAT\" 1>&2\n\tip netns exec $nsr1 nft list ruleset\n\tret=1\nfi\n\n\n# Another test:\n# Add bridge interface br0 to Router1, with NAT and VLAN.\nip -net $nsr1 link set veth0 nomaster\nip -net $nsr1 link set down dev veth0\nip -net $nsr1 link add link veth0 name veth0.10 type vlan id 10\nip -net $nsr1 link set up dev veth0\nip -net $nsr1 link set up dev veth0.10\nip -net $nsr1 link set veth0.10 master br0\n\nip -net $ns1 addr flush dev eth0\nip -net $ns1 link add link eth0 name eth0.10 type vlan id 10\nip -net $ns1 link set eth0 up\nip -net $ns1 link set eth0.10 up\nip -net $ns1 addr add 10.0.1.99/24 dev eth0.10\nip -net $ns1 route add default via 10.0.1.1\nip -net $ns1 addr add dead:1::99/64 dev eth0.10\n\nif ! test_tcp_forwarding_nat $ns1 $ns2 1 \"bridge and VLAN\"; then\n\techo \"FAIL: flow offload for ns1/ns2 with bridge NAT and VLAN\" 1>&2\n\tip netns exec $nsr1 nft list ruleset\n\tret=1\nfi\n\n# restore test topology (remove bridge and VLAN)\nip -net $nsr1 link set veth0 nomaster\nip -net $nsr1 link set veth0 down\nip -net $nsr1 link set veth0.10 down\nip -net $nsr1 link delete veth0.10 type vlan\nip -net $nsr1 link delete br0 type bridge\nip -net $ns1 addr flush dev eth0.10\nip -net $ns1 link set eth0.10 down\nip -net $ns1 link set eth0 down\nip -net $ns1 link delete eth0.10 type vlan\n\n# restore address in ns1 and nsr1\nip -net $ns1 link set eth0 up\nip -net $ns1 addr add 10.0.1.99/24 dev eth0\nip -net $ns1 route add default via 10.0.1.1\nip -net $ns1 addr add dead:1::99/64 dev eth0\nip -net $ns1 route add default via dead:1::1\nip -net $nsr1 addr add 10.0.1.1/24 dev veth0\nip -net $nsr1 addr add dead:1::1/64 dev veth0\nip -net $nsr1 link set up dev veth0\n\nKEY_SHA=\"0x\"$(ps -af | sha1sum | cut -d \" \" -f 1)\nKEY_AES=\"0x\"$(ps -af | md5sum | cut -d \" \" -f 1)\nSPI1=$RANDOM\nSPI2=$RANDOM\n\nif [ $SPI1 -eq $SPI2 ]; then\n\tSPI2=$((SPI2+1))\nfi\n\ndo_esp() {\n    local ns=$1\n    local me=$2\n    local remote=$3\n    local lnet=$4\n    local rnet=$5\n    local spi_out=$6\n    local spi_in=$7\n\n    ip -net $ns xfrm state add src $remote dst $me proto esp spi $spi_in  enc aes $KEY_AES  auth sha1 $KEY_SHA mode tunnel sel src $rnet dst $lnet\n    ip -net $ns xfrm state add src $me  dst $remote proto esp spi $spi_out enc aes $KEY_AES auth sha1 $KEY_SHA mode tunnel sel src $lnet dst $rnet\n\n    # to encrypt packets as they go out (includes forwarded packets that need encapsulation)\n    ip -net $ns xfrm policy add src $lnet dst $rnet dir out tmpl src $me dst $remote proto esp mode tunnel priority 1 action allow\n    # to fwd decrypted packets after esp processing:\n    ip -net $ns xfrm policy add src $rnet dst $lnet dir fwd tmpl src $remote dst $me proto esp mode tunnel priority 1 action allow\n\n}\n\ndo_esp $nsr1 192.168.10.1 192.168.10.2 10.0.1.0/24 10.0.2.0/24 $SPI1 $SPI2\n\ndo_esp $nsr2 192.168.10.2 192.168.10.1 10.0.2.0/24 10.0.1.0/24 $SPI2 $SPI1\n\nip netns exec $nsr1 nft delete table ip nat\n\n# restore default routes\nip -net $ns2 route del 192.168.10.1 via 10.0.2.1\nip -net $ns2 route add default via 10.0.2.1\nip -net $ns2 route add default via dead:2::1\n\nif test_tcp_forwarding $ns1 $ns2; then\n\tcheck_counters \"ipsec tunnel mode for ns1/ns2\"\nelse\n\techo \"FAIL: ipsec tunnel mode for ns1/ns2\"\n\tip netns exec $nsr1 nft list ruleset 1>&2\n\tip netns exec $nsr1 cat /proc/net/xfrm_stat 1>&2\nfi\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}