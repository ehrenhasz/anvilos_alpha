{
  "module_name": "nft_fib.sh",
  "hash_id": "5c55496f75ac8d4ade3422decb1cd81dce4aa015b68d19721ed949e67a561a5d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/nft_fib.sh",
  "human_readable_source": "#!/bin/bash\n#\n# This tests the fib expression.\n#\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nret=0\n\nsfx=$(mktemp -u \"XXXXXXXX\")\nns1=\"ns1-$sfx\"\nns2=\"ns2-$sfx\"\nnsrouter=\"nsrouter-$sfx\"\ntimeout=4\n\nlog_netns=$(sysctl -n net.netfilter.nf_log_all_netns)\n\ncleanup()\n{\n\tip netns del ${ns1}\n\tip netns del ${ns2}\n\tip netns del ${nsrouter}\n\n\t[ $log_netns -eq 0 ] && sysctl -q net.netfilter.nf_log_all_netns=$log_netns\n}\n\nnft --version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without nft tool\"\n\texit $ksft_skip\nfi\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nip netns add ${nsrouter}\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not create net namespace\"\n\texit $ksft_skip\nfi\n\ntrap cleanup EXIT\n\ndmesg | grep -q ' nft_rpfilter: '\nif [ $? -eq 0 ]; then\n\tdmesg -c | grep ' nft_rpfilter: '\n\techo \"WARN: a previous test run has failed\" 1>&2\nfi\n\nsysctl -q net.netfilter.nf_log_all_netns=1\nip netns add ${ns1}\nip netns add ${ns2}\n\nload_ruleset() {\n\tlocal netns=$1\n\nip netns exec ${netns} nft -f /dev/stdin <<EOF\ntable inet filter {\n\tchain prerouting {\n\t\ttype filter hook prerouting priority 0; policy accept;\n\t        fib saddr . iif oif missing counter log prefix \"$netns nft_rpfilter: \" drop\n\t}\n}\nEOF\n}\n\nload_pbr_ruleset() {\n\tlocal netns=$1\n\nip netns exec ${netns} nft -f /dev/stdin <<EOF\ntable inet filter {\n\tchain forward {\n\t\ttype filter hook forward priority raw;\n\t\tfib saddr . iif oif gt 0 accept\n\t\tlog drop\n\t}\n}\nEOF\n}\n\nload_ruleset_count() {\n\tlocal netns=$1\n\nip netns exec ${netns} nft -f /dev/stdin <<EOF\ntable inet filter {\n\tchain prerouting {\n\t\ttype filter hook prerouting priority 0; policy accept;\n\t\tip daddr 1.1.1.1 fib saddr . iif oif missing counter drop\n\t\tip6 daddr 1c3::c01d fib saddr . iif oif missing counter drop\n\t}\n}\nEOF\n}\n\ncheck_drops() {\n\tdmesg | grep -q ' nft_rpfilter: '\n\tif [ $? -eq 0 ]; then\n\t\tdmesg | grep ' nft_rpfilter: '\n\t\techo \"FAIL: rpfilter did drop packets\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\ncheck_fib_counter() {\n\tlocal want=$1\n\tlocal ns=$2\n\tlocal address=$3\n\n\tline=$(ip netns exec ${ns} nft list table inet filter | grep 'fib saddr . iif' | grep $address | grep \"packets $want\" )\n\tret=$?\n\n\tif [ $ret -ne 0 ];then\n\t\techo \"Netns $ns fib counter doesn't match expected packet count of $want for $address\" 1>&2\n\t\tip netns exec ${ns} nft list table inet filter\n\t\treturn 1\n\tfi\n\n\tif [ $want -gt 0 ]; then\n\t\techo \"PASS: fib expression did drop packets for $address\"\n\tfi\n\n\treturn 0\n}\n\nload_ruleset ${nsrouter}\nload_ruleset ${ns1}\nload_ruleset ${ns2}\n\nip link add veth0 netns ${nsrouter} type veth peer name eth0 netns ${ns1} > /dev/null 2>&1\nif [ $? -ne 0 ];then\n    echo \"SKIP: No virtual ethernet pair device support in kernel\"\n    exit $ksft_skip\nfi\nip link add veth1 netns ${nsrouter} type veth peer name eth0 netns ${ns2}\n\nip -net ${nsrouter} link set lo up\nip -net ${nsrouter} link set veth0 up\nip -net ${nsrouter} addr add 10.0.1.1/24 dev veth0\nip -net ${nsrouter} addr add dead:1::1/64 dev veth0\n\nip -net ${nsrouter} link set veth1 up\nip -net ${nsrouter} addr add 10.0.2.1/24 dev veth1\nip -net ${nsrouter} addr add dead:2::1/64 dev veth1\n\nip -net ${ns1} link set lo up\nip -net ${ns1} link set eth0 up\n\nip -net ${ns2} link set lo up\nip -net ${ns2} link set eth0 up\n\nip -net ${ns1} addr add 10.0.1.99/24 dev eth0\nip -net ${ns1} addr add dead:1::99/64 dev eth0\nip -net ${ns1} route add default via 10.0.1.1\nip -net ${ns1} route add default via dead:1::1\n\nip -net ${ns2} addr add 10.0.2.99/24 dev eth0\nip -net ${ns2} addr add dead:2::99/64 dev eth0\nip -net ${ns2} route add default via 10.0.2.1\nip -net ${ns2} route add default via dead:2::1\n\ntest_ping() {\n  local daddr4=$1\n  local daddr6=$2\n\n  ip netns exec ${ns1} ping -c 1 -q $daddr4 > /dev/null\n  ret=$?\n  if [ $ret -ne 0 ];then\n\tcheck_drops\n\techo \"FAIL: ${ns1} cannot reach $daddr4, ret $ret\" 1>&2\n\treturn 1\n  fi\n\n  ip netns exec ${ns1} ping -c 3 -q $daddr6 > /dev/null\n  ret=$?\n  if [ $ret -ne 0 ];then\n\tcheck_drops\n\techo \"FAIL: ${ns1} cannot reach $daddr6, ret $ret\" 1>&2\n\treturn 1\n  fi\n\n  return 0\n}\n\nip netns exec ${nsrouter} sysctl net.ipv6.conf.all.forwarding=1 > /dev/null\nip netns exec ${nsrouter} sysctl net.ipv4.conf.veth0.forwarding=1 > /dev/null\nip netns exec ${nsrouter} sysctl net.ipv4.conf.veth1.forwarding=1 > /dev/null\nip netns exec ${nsrouter} sysctl net.ipv4.conf.all.rp_filter=0 > /dev/null\nip netns exec ${nsrouter} sysctl net.ipv4.conf.veth0.rp_filter=0 > /dev/null\n\nsleep 3\n\ntest_ping 10.0.2.1 dead:2::1 || exit 1\ncheck_drops || exit 1\n\ntest_ping 10.0.2.99 dead:2::99 || exit 1\ncheck_drops || exit 1\n\necho \"PASS: fib expression did not cause unwanted packet drops\"\n\nip netns exec ${nsrouter} nft flush table inet filter\n\nip -net ${ns1} route del default\nip -net ${ns1} -6 route del default\n\nip -net ${ns1} addr del 10.0.1.99/24 dev eth0\nip -net ${ns1} addr del dead:1::99/64 dev eth0\n\nip -net ${ns1} addr add 10.0.2.99/24 dev eth0\nip -net ${ns1} addr add dead:2::99/64 dev eth0\n\nip -net ${ns1} route add default via 10.0.2.1\nip -net ${ns1} -6 route add default via dead:2::1\n\nip -net ${nsrouter} addr add dead:2::1/64 dev veth0\n\n# switch to ruleset that doesn't log, this time\n# its expected that this does drop the packets.\nload_ruleset_count ${nsrouter}\n\n# ns1 has a default route, but nsrouter does not.\n# must not check return value, ping to 1.1.1.1 will\n# fail.\ncheck_fib_counter 0 ${nsrouter} 1.1.1.1 || exit 1\ncheck_fib_counter 0 ${nsrouter} 1c3::c01d || exit 1\n\nip netns exec ${ns1} ping -c 1 -W 1 -q 1.1.1.1 > /dev/null\ncheck_fib_counter 1 ${nsrouter} 1.1.1.1 || exit 1\n\nsleep 2\nip netns exec ${ns1} ping -c 3 -q 1c3::c01d > /dev/null\ncheck_fib_counter 3 ${nsrouter} 1c3::c01d || exit 1\n\n# delete all rules\nip netns exec ${ns1} nft flush ruleset\nip netns exec ${ns2} nft flush ruleset\nip netns exec ${nsrouter} nft flush ruleset\n\nip -net ${ns1} addr add 10.0.1.99/24 dev eth0\nip -net ${ns1} addr add dead:1::99/64 dev eth0\n\nip -net ${ns1} addr del 10.0.2.99/24 dev eth0\nip -net ${ns1} addr del dead:2::99/64 dev eth0\n\nip -net ${nsrouter} addr del dead:2::1/64 dev veth0\n\n# ... pbr ruleset for the router, check iif+oif.\nload_pbr_ruleset ${nsrouter}\nif [ $? -ne 0 ] ; then\n\techo \"SKIP: Could not load fib forward ruleset\"\n\texit $ksft_skip\nfi\n\nip -net ${nsrouter} rule add from all table 128\nip -net ${nsrouter} rule add from all iif veth0 table 129\nip -net ${nsrouter} route add table 128 to 10.0.1.0/24 dev veth0\nip -net ${nsrouter} route add table 129 to 10.0.2.0/24 dev veth1\n\n# drop main ipv4 table\nip -net ${nsrouter} -4 rule delete table main\n\ntest_ping 10.0.2.99 dead:2::99\nif [ $? -ne 0 ] ; then\n\tip -net ${nsrouter} nft list ruleset\n\techo \"FAIL: fib mismatch in pbr setup\"\n\texit 1\nfi\n\necho \"PASS: fib expression forward check with policy based routing\"\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}