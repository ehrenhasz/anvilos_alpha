{
  "module_name": "rpath.sh",
  "hash_id": "0cd29fbc7bfe86dea083e4ec607e5d0566ba4d1f90cf12538598f58acf6752ce",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/netfilter/rpath.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# return code to signal skipped test\nksft_skip=4\n\n# search for legacy iptables (it uses the xtables extensions\nif iptables-legacy --version >/dev/null 2>&1; then\n\tiptables='iptables-legacy'\nelif iptables --version >/dev/null 2>&1; then\n\tiptables='iptables'\nelse\n\tiptables=''\nfi\n\nif ip6tables-legacy --version >/dev/null 2>&1; then\n\tip6tables='ip6tables-legacy'\nelif ip6tables --version >/dev/null 2>&1; then\n\tip6tables='ip6tables'\nelse\n\tip6tables=''\nfi\n\nif nft --version >/dev/null 2>&1; then\n\tnft='nft'\nelse\n\tnft=''\nfi\n\nif [ -z \"$iptables$ip6tables$nft\" ]; then\n\techo \"SKIP: Test needs iptables, ip6tables or nft\"\n\texit $ksft_skip\nfi\n\nsfx=$(mktemp -u \"XXXXXXXX\")\nns1=\"ns1-$sfx\"\nns2=\"ns2-$sfx\"\ntrap \"ip netns del $ns1; ip netns del $ns2\" EXIT\n\n# create two netns, disable rp_filter in ns2 and\n# keep IPv6 address when moving into VRF\nip netns add \"$ns1\"\nip netns add \"$ns2\"\nip netns exec \"$ns2\" sysctl -q net.ipv4.conf.all.rp_filter=0\nip netns exec \"$ns2\" sysctl -q net.ipv4.conf.default.rp_filter=0\nip netns exec \"$ns2\" sysctl -q net.ipv6.conf.all.keep_addr_on_down=1\n\n# a standard connection between the netns, should not trigger rp filter\nip -net \"$ns1\" link add v0 type veth peer name v0 netns \"$ns2\"\nip -net \"$ns1\" link set v0 up; ip -net \"$ns2\" link set v0 up\nip -net \"$ns1\" a a 192.168.23.2/24 dev v0\nip -net \"$ns2\" a a 192.168.23.1/24 dev v0\nip -net \"$ns1\" a a fec0:23::2/64 dev v0 nodad\nip -net \"$ns2\" a a fec0:23::1/64 dev v0 nodad\n\n# rp filter testing: ns1 sends packets via v0 which ns2 would route back via d0\nip -net \"$ns2\" link add d0 type dummy\nip -net \"$ns2\" link set d0 up\nip -net \"$ns1\" a a 192.168.42.2/24 dev v0\nip -net \"$ns2\" a a 192.168.42.1/24 dev d0\nip -net \"$ns1\" a a fec0:42::2/64 dev v0 nodad\nip -net \"$ns2\" a a fec0:42::1/64 dev d0 nodad\n\n# firewall matches to test\n[ -n \"$iptables\" ] && {\n\tcommon='-t raw -A PREROUTING -s 192.168.0.0/16'\n\tip netns exec \"$ns2\" \"$iptables\" $common -m rpfilter\n\tip netns exec \"$ns2\" \"$iptables\" $common -m rpfilter --invert\n}\n[ -n \"$ip6tables\" ] && {\n\tcommon='-t raw -A PREROUTING -s fec0::/16'\n\tip netns exec \"$ns2\" \"$ip6tables\" $common -m rpfilter\n\tip netns exec \"$ns2\" \"$ip6tables\" $common -m rpfilter --invert\n}\n[ -n \"$nft\" ] && ip netns exec \"$ns2\" $nft -f - <<EOF\ntable inet t {\n\tchain c {\n\t\ttype filter hook prerouting priority raw;\n\t\tip saddr 192.168.0.0/16 fib saddr . iif oif exists counter\n\t\tip6 saddr fec0::/16 fib saddr . iif oif exists counter\n\t}\n}\nEOF\n\ndie() {\n\techo \"FAIL: $*\"\n\t#ip netns exec \"$ns2\" \"$iptables\" -t raw -vS\n\t#ip netns exec \"$ns2\" \"$ip6tables\" -t raw -vS\n\t#ip netns exec \"$ns2\" nft list ruleset\n\texit 1\n}\n\n# check rule counters, return true if rule did not match\nipt_zero_rule() { # (command)\n\t[ -n \"$1\" ] || return 0\n\tip netns exec \"$ns2\" \"$1\" -t raw -vS | grep -q -- \"-m rpfilter -c 0 0\"\n}\nipt_zero_reverse_rule() { # (command)\n\t[ -n \"$1\" ] || return 0\n\tip netns exec \"$ns2\" \"$1\" -t raw -vS | \\\n\t\tgrep -q -- \"-m rpfilter --invert -c 0 0\"\n}\nnft_zero_rule() { # (family)\n\t[ -n \"$nft\" ] || return 0\n\tip netns exec \"$ns2\" \"$nft\" list chain inet t c | \\\n\t\tgrep -q \"$1 saddr .* counter packets 0 bytes 0\"\n}\n\nnetns_ping() { # (netns, args...)\n\tlocal netns=\"$1\"\n\tshift\n\tip netns exec \"$netns\" ping -q -c 1 -W 1 \"$@\" >/dev/null\n}\n\nclear_counters() {\n\t[ -n \"$iptables\" ] && ip netns exec \"$ns2\" \"$iptables\" -t raw -Z\n\t[ -n \"$ip6tables\" ] && ip netns exec \"$ns2\" \"$ip6tables\" -t raw -Z\n\tif [ -n \"$nft\" ]; then\n\t\t(\n\t\t\techo \"delete table inet t\";\n\t\t\tip netns exec \"$ns2\" $nft -s list table inet t;\n\t\t) | ip netns exec \"$ns2\" $nft -f -\n\tfi\n}\n\ntestrun() {\n\tclear_counters\n\n\t# test 1: martian traffic should fail rpfilter matches\n\tnetns_ping \"$ns1\" -I v0 192.168.42.1 && \\\n\t\tdie \"martian ping 192.168.42.1 succeeded\"\n\tnetns_ping \"$ns1\" -I v0 fec0:42::1 && \\\n\t\tdie \"martian ping fec0:42::1 succeeded\"\n\n\tipt_zero_rule \"$iptables\" || die \"iptables matched martian\"\n\tipt_zero_rule \"$ip6tables\" || die \"ip6tables matched martian\"\n\tipt_zero_reverse_rule \"$iptables\" && die \"iptables not matched martian\"\n\tipt_zero_reverse_rule \"$ip6tables\" && die \"ip6tables not matched martian\"\n\tnft_zero_rule ip || die \"nft IPv4 matched martian\"\n\tnft_zero_rule ip6 || die \"nft IPv6 matched martian\"\n\n\tclear_counters\n\n\t# test 2: rpfilter match should pass for regular traffic\n\tnetns_ping \"$ns1\" 192.168.23.1 || \\\n\t\tdie \"regular ping 192.168.23.1 failed\"\n\tnetns_ping \"$ns1\" fec0:23::1 || \\\n\t\tdie \"regular ping fec0:23::1 failed\"\n\n\tipt_zero_rule \"$iptables\" && die \"iptables match not effective\"\n\tipt_zero_rule \"$ip6tables\" && die \"ip6tables match not effective\"\n\tipt_zero_reverse_rule \"$iptables\" || die \"iptables match over-effective\"\n\tipt_zero_reverse_rule \"$ip6tables\" || die \"ip6tables match over-effective\"\n\tnft_zero_rule ip && die \"nft IPv4 match not effective\"\n\tnft_zero_rule ip6 && die \"nft IPv6 match not effective\"\n\n}\n\ntestrun\n\n# repeat test with vrf device in $ns2\nip -net \"$ns2\" link add vrf0 type vrf table 10\nip -net \"$ns2\" link set vrf0 up\nip -net \"$ns2\" link set v0 master vrf0\n\ntestrun\n\necho \"PASS: netfilter reverse path match works as intended\"\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}