{
  "module_name": "remove_on_exec.c",
  "hash_id": "25d8a9cec8aae95700f6434094051d559c4231a4e9d628c6f58d09a2daadf6f0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/perf_events/remove_on_exec.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n \n#include <sys/types.h>\n#include <asm/siginfo.h>\n#define __have_siginfo_t 1\n#define __have_sigval_t 1\n#define __have_sigevent_t 1\n#define __siginfo_t_defined\n#define __sigval_t_defined\n#define __sigevent_t_defined\n#define _BITS_SIGINFO_CONSTS_H 1\n#define _BITS_SIGEVENT_CONSTS_H 1\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <linux/perf_event.h>\n#include <pthread.h>\n#include <signal.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n\n#include \"../kselftest_harness.h\"\n\nstatic volatile int signal_count;\n\nstatic struct perf_event_attr make_event_attr(void)\n{\n\tstruct perf_event_attr attr = {\n\t\t.type\t\t= PERF_TYPE_HARDWARE,\n\t\t.size\t\t= sizeof(attr),\n\t\t.config\t\t= PERF_COUNT_HW_INSTRUCTIONS,\n\t\t.sample_period\t= 1000,\n\t\t.exclude_kernel = 1,\n\t\t.exclude_hv\t= 1,\n\t\t.disabled\t= 1,\n\t\t.inherit\t= 1,\n\t\t \n\t\t.remove_on_exec = 1,\n\t\t.sigtrap\t= 1,\n\t};\n\treturn attr;\n}\n\nstatic void sigtrap_handler(int signum, siginfo_t *info, void *ucontext)\n{\n\tif (info->si_code != TRAP_PERF) {\n\t\tfprintf(stderr, \"%s: unexpected si_code %d\\n\", __func__, info->si_code);\n\t\treturn;\n\t}\n\n\tsignal_count++;\n}\n\nFIXTURE(remove_on_exec)\n{\n\tstruct sigaction oldact;\n\tint fd;\n};\n\nFIXTURE_SETUP(remove_on_exec)\n{\n\tstruct perf_event_attr attr = make_event_attr();\n\tstruct sigaction action = {};\n\n\tsignal_count = 0;\n\n\t \n\taction.sa_flags = SA_SIGINFO | SA_NODEFER;\n\taction.sa_sigaction = sigtrap_handler;\n\tsigemptyset(&action.sa_mask);\n\tASSERT_EQ(sigaction(SIGTRAP, &action, &self->oldact), 0);\n\n\t \n\tself->fd = syscall(__NR_perf_event_open, &attr, 0, -1, -1, PERF_FLAG_FD_CLOEXEC);\n\tASSERT_NE(self->fd, -1);\n}\n\nFIXTURE_TEARDOWN(remove_on_exec)\n{\n\tclose(self->fd);\n\tsigaction(SIGTRAP, &self->oldact, NULL);\n}\n\n \nTEST_F(remove_on_exec, fork_only)\n{\n\tint status;\n\tpid_t pid = fork();\n\n\tif (pid == 0) {\n\t\tASSERT_EQ(signal_count, 0);\n\t\tASSERT_EQ(ioctl(self->fd, PERF_EVENT_IOC_ENABLE, 0), 0);\n\t\twhile (!signal_count);\n\t\t_exit(42);\n\t}\n\n\twhile (!signal_count);  \n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(WEXITSTATUS(status), 42);\n}\n\n \nTEST_F(remove_on_exec, fork_exec_then_enable)\n{\n\tpid_t pid_exec, pid_only_fork;\n\tint pipefd[2];\n\tint tmp;\n\n\t \n\tpid_only_fork = fork();\n\tif (pid_only_fork == 0) {\n\t\t \n\t\twhile (!signal_count);\n\t\t_exit(42);\n\t}\n\n\tASSERT_NE(pipe(pipefd), -1);\n\tpid_exec = fork();\n\tif (pid_exec == 0) {\n\t\tASSERT_NE(dup2(pipefd[1], STDOUT_FILENO), -1);\n\t\tclose(pipefd[0]);\n\t\texecl(\"/proc/self/exe\", \"exec_child\", NULL);\n\t\t_exit((perror(\"exec failed\"), 1));\n\t}\n\tclose(pipefd[1]);\n\n\tASSERT_EQ(waitpid(pid_exec, &tmp, WNOHANG), 0);  \n\t \n\tEXPECT_EQ(read(pipefd[0], &tmp, sizeof(int)), sizeof(int));\n\tEXPECT_EQ(tmp, 42);\n\tclose(pipefd[0]);\n\t \n\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_ENABLE, 0), 0);\n\t \n\tusleep(100000);  \n\tEXPECT_EQ(waitpid(pid_exec, &tmp, WNOHANG), 0);  \n\tEXPECT_EQ(kill(pid_exec, SIGKILL), 0);\n\n\t \n\ttmp = signal_count;\n\twhile (signal_count == tmp);  \n\t \n\tEXPECT_EQ(waitpid(pid_only_fork, &tmp, 0), pid_only_fork);\n\tEXPECT_EQ(WEXITSTATUS(tmp), 42);\n}\n\n \nTEST_F(remove_on_exec, enable_then_fork_exec)\n{\n\tpid_t pid_exec;\n\tint tmp;\n\n\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_ENABLE, 0), 0);\n\n\tpid_exec = fork();\n\tif (pid_exec == 0) {\n\t\texecl(\"/proc/self/exe\", \"exec_child\", NULL);\n\t\t_exit((perror(\"exec failed\"), 1));\n\t}\n\n\t \n\tusleep(100000);  \n\tEXPECT_EQ(waitpid(pid_exec, &tmp, WNOHANG), 0);  \n\tEXPECT_EQ(kill(pid_exec, SIGKILL), 0);\n\n\t \n\ttmp = signal_count;\n\twhile (signal_count == tmp);  \n}\n\nTEST_F(remove_on_exec, exec_stress)\n{\n\tpid_t pids[30];\n\tint i, tmp;\n\n\tfor (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++) {\n\t\tpids[i] = fork();\n\t\tif (pids[i] == 0) {\n\t\t\texecl(\"/proc/self/exe\", \"exec_child\", NULL);\n\t\t\t_exit((perror(\"exec failed\"), 1));\n\t\t}\n\n\t\t \n\t\tif (i > 10)\n\t\t\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_ENABLE, 0), 0);\n\t}\n\n\tusleep(100000);  \n\n\tfor (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++) {\n\t\t \n\t\tEXPECT_EQ(waitpid(pids[i], &tmp, WNOHANG), 0);\n\t\tEXPECT_EQ(kill(pids[i], SIGKILL), 0);\n\t}\n\n\t \n\ttmp = signal_count;\n\twhile (signal_count == tmp);\n}\n\n \nstatic void exec_child(void)\n{\n\tstruct sigaction action = {};\n\tconst int val = 42;\n\n\t \n\taction.sa_flags = SA_SIGINFO | SA_NODEFER;\n\taction.sa_sigaction = sigtrap_handler;\n\tsigemptyset(&action.sa_mask);\n\tif (sigaction(SIGTRAP, &action, NULL))\n\t\t_exit((perror(\"sigaction failed\"), 1));\n\n\t \n\tif (write(STDOUT_FILENO, &val, sizeof(int)) == -1)\n\t\t_exit((perror(\"write failed\"), 1));\n\n\t \n\twhile (!signal_count);\n}\n\n#define main test_main\nTEST_HARNESS_MAIN\n#undef main\nint main(int argc, char *argv[])\n{\n\tif (!strcmp(argv[0], \"exec_child\")) {\n\t\texec_child();\n\t\treturn 1;\n\t}\n\n\treturn test_main(argc, argv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}