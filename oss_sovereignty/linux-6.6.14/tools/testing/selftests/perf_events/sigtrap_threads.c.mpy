{
  "module_name": "sigtrap_threads.c",
  "hash_id": "eac717bb73936ea70e8b02b6724051af57012511723c8d485a08703ea45bc1b4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/perf_events/sigtrap_threads.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n \n#include <sys/types.h>\n#include <asm/siginfo.h>\n#define __have_siginfo_t 1\n#define __have_sigval_t 1\n#define __have_sigevent_t 1\n#define __siginfo_t_defined\n#define __sigval_t_defined\n#define __sigevent_t_defined\n#define _BITS_SIGINFO_CONSTS_H 1\n#define _BITS_SIGEVENT_CONSTS_H 1\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/perf_event.h>\n#include <pthread.h>\n#include <signal.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n\n#include \"../kselftest_harness.h\"\n\n#define NUM_THREADS 5\n\n \nstatic struct {\n\tint tids_want_signal;\t\t \n\tint signal_count;\t\t \n\tvolatile int iterate_on;\t \n\tsiginfo_t first_siginfo;\t \n} ctx;\n\n \n#define TEST_SIG_DATA(addr, id) (~(unsigned long)(addr) + id)\n\nstatic struct perf_event_attr make_event_attr(bool enabled, volatile void *addr,\n\t\t\t\t\t      unsigned long id)\n{\n\tstruct perf_event_attr attr = {\n\t\t.type\t\t= PERF_TYPE_BREAKPOINT,\n\t\t.size\t\t= sizeof(attr),\n\t\t.sample_period\t= 1,\n\t\t.disabled\t= !enabled,\n\t\t.bp_addr\t= (unsigned long)addr,\n\t\t.bp_type\t= HW_BREAKPOINT_RW,\n\t\t.bp_len\t\t= HW_BREAKPOINT_LEN_1,\n\t\t.inherit\t= 1,  \n\t\t.inherit_thread = 1,  \n\t\t.remove_on_exec = 1,  \n\t\t.sigtrap\t= 1,  \n\t\t.sig_data\t= TEST_SIG_DATA(addr, id),\n\t\t.exclude_kernel = 1,  \n\t\t.exclude_hv     = 1,  \n\t};\n\treturn attr;\n}\n\nstatic void sigtrap_handler(int signum, siginfo_t *info, void *ucontext)\n{\n\tif (info->si_code != TRAP_PERF) {\n\t\tfprintf(stderr, \"%s: unexpected si_code %d\\n\", __func__, info->si_code);\n\t\treturn;\n\t}\n\n\t \n\tif (!__atomic_fetch_add(&ctx.signal_count, 1, __ATOMIC_RELAXED))\n\t\tctx.first_siginfo = *info;\n\t__atomic_fetch_sub(&ctx.tids_want_signal, syscall(__NR_gettid), __ATOMIC_RELAXED);\n}\n\nstatic void *test_thread(void *arg)\n{\n\tpthread_barrier_t *barrier = (pthread_barrier_t *)arg;\n\tpid_t tid = syscall(__NR_gettid);\n\tint iter;\n\tint i;\n\n\tpthread_barrier_wait(barrier);\n\n\t__atomic_fetch_add(&ctx.tids_want_signal, tid, __ATOMIC_RELAXED);\n\titer = ctx.iterate_on;  \n\tif (iter >= 0) {\n\t\tfor (i = 0; i < iter - 1; i++) {\n\t\t\t__atomic_fetch_add(&ctx.tids_want_signal, tid, __ATOMIC_RELAXED);\n\t\t\tctx.iterate_on = iter;  \n\t\t}\n\t} else {\n\t\twhile (ctx.iterate_on);\n\t}\n\n\treturn NULL;\n}\n\nFIXTURE(sigtrap_threads)\n{\n\tstruct sigaction oldact;\n\tpthread_t threads[NUM_THREADS];\n\tpthread_barrier_t barrier;\n\tint fd;\n};\n\nFIXTURE_SETUP(sigtrap_threads)\n{\n\tstruct perf_event_attr attr = make_event_attr(false, &ctx.iterate_on, 0);\n\tstruct sigaction action = {};\n\tint i;\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\n\t \n\taction.sa_flags = SA_SIGINFO | SA_NODEFER;\n\taction.sa_sigaction = sigtrap_handler;\n\tsigemptyset(&action.sa_mask);\n\tASSERT_EQ(sigaction(SIGTRAP, &action, &self->oldact), 0);\n\n\t \n\tself->fd = syscall(__NR_perf_event_open, &attr, 0, -1, -1, PERF_FLAG_FD_CLOEXEC);\n\tASSERT_NE(self->fd, -1);\n\n\t \n\tpthread_barrier_init(&self->barrier, NULL, NUM_THREADS + 1);\n\tfor (i = 0; i < NUM_THREADS; i++)\n\t\tASSERT_EQ(pthread_create(&self->threads[i], NULL, test_thread, &self->barrier), 0);\n}\n\nFIXTURE_TEARDOWN(sigtrap_threads)\n{\n\tpthread_barrier_destroy(&self->barrier);\n\tclose(self->fd);\n\tsigaction(SIGTRAP, &self->oldact, NULL);\n}\n\nstatic void run_test_threads(struct __test_metadata *_metadata,\n\t\t\t     FIXTURE_DATA(sigtrap_threads) *self)\n{\n\tint i;\n\n\tpthread_barrier_wait(&self->barrier);\n\tfor (i = 0; i < NUM_THREADS; i++)\n\t\tASSERT_EQ(pthread_join(self->threads[i], NULL), 0);\n}\n\nTEST_F(sigtrap_threads, remain_disabled)\n{\n\trun_test_threads(_metadata, self);\n\tEXPECT_EQ(ctx.signal_count, 0);\n\tEXPECT_NE(ctx.tids_want_signal, 0);\n}\n\nTEST_F(sigtrap_threads, enable_event)\n{\n\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_ENABLE, 0), 0);\n\trun_test_threads(_metadata, self);\n\n\tEXPECT_EQ(ctx.signal_count, NUM_THREADS);\n\tEXPECT_EQ(ctx.tids_want_signal, 0);\n\tEXPECT_EQ(ctx.first_siginfo.si_addr, &ctx.iterate_on);\n\tEXPECT_EQ(ctx.first_siginfo.si_perf_type, PERF_TYPE_BREAKPOINT);\n\tEXPECT_EQ(ctx.first_siginfo.si_perf_data, TEST_SIG_DATA(&ctx.iterate_on, 0));\n\n\t \n\tctx.iterate_on = 0;\n\tEXPECT_EQ(ctx.signal_count, NUM_THREADS + 1);\n}\n\n \nTEST_F(sigtrap_threads, modify_and_enable_event)\n{\n\tstruct perf_event_attr new_attr = make_event_attr(true, &ctx.iterate_on, 42);\n\n\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_MODIFY_ATTRIBUTES, &new_attr), 0);\n\trun_test_threads(_metadata, self);\n\n\tEXPECT_EQ(ctx.signal_count, NUM_THREADS);\n\tEXPECT_EQ(ctx.tids_want_signal, 0);\n\tEXPECT_EQ(ctx.first_siginfo.si_addr, &ctx.iterate_on);\n\tEXPECT_EQ(ctx.first_siginfo.si_perf_type, PERF_TYPE_BREAKPOINT);\n\tEXPECT_EQ(ctx.first_siginfo.si_perf_data, TEST_SIG_DATA(&ctx.iterate_on, 42));\n\n\t \n\tctx.iterate_on = 0;\n\tEXPECT_EQ(ctx.signal_count, NUM_THREADS + 1);\n}\n\n \nTEST_F(sigtrap_threads, signal_stress)\n{\n\tctx.iterate_on = 3000;\n\n\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_ENABLE, 0), 0);\n\trun_test_threads(_metadata, self);\n\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_DISABLE, 0), 0);\n\n\tEXPECT_EQ(ctx.signal_count, NUM_THREADS * ctx.iterate_on);\n\tEXPECT_EQ(ctx.tids_want_signal, 0);\n\tEXPECT_EQ(ctx.first_siginfo.si_addr, &ctx.iterate_on);\n\tEXPECT_EQ(ctx.first_siginfo.si_perf_type, PERF_TYPE_BREAKPOINT);\n\tEXPECT_EQ(ctx.first_siginfo.si_perf_data, TEST_SIG_DATA(&ctx.iterate_on, 0));\n}\n\nTEST_F(sigtrap_threads, signal_stress_with_disable)\n{\n\tconst int target_count = NUM_THREADS * 3000;\n\tint i;\n\n\tctx.iterate_on = -1;\n\n\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_ENABLE, 0), 0);\n\tpthread_barrier_wait(&self->barrier);\n\twhile (__atomic_load_n(&ctx.signal_count, __ATOMIC_RELAXED) < target_count) {\n\t\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_DISABLE, 0), 0);\n\t\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_ENABLE, 0), 0);\n\t}\n\tctx.iterate_on = 0;\n\tfor (i = 0; i < NUM_THREADS; i++)\n\t\tASSERT_EQ(pthread_join(self->threads[i], NULL), 0);\n\tEXPECT_EQ(ioctl(self->fd, PERF_EVENT_IOC_DISABLE, 0), 0);\n\n\tEXPECT_EQ(ctx.first_siginfo.si_addr, &ctx.iterate_on);\n\tEXPECT_EQ(ctx.first_siginfo.si_perf_type, PERF_TYPE_BREAKPOINT);\n\tEXPECT_EQ(ctx.first_siginfo.si_perf_data, TEST_SIG_DATA(&ctx.iterate_on, 0));\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}