{
  "module_name": "binfmt_script.py",
  "hash_id": "a3282fc90358fd814064f9eb54228c80f1c4350a375a26382adbee39df4c489b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/exec/binfmt_script.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test that truncation of bprm->buf doesn't cause unexpected execs paths, along\n# with various other pathological cases.\nimport os, subprocess\n\n# Relevant commits\n#\n# b5372fe5dc84 (\"exec: load_script: Do not exec truncated interpreter path\")\n# 6eb3c3d0a52d (\"exec: increase BINPRM_BUF_SIZE to 256\")\n\n# BINPRM_BUF_SIZE\nSIZE=256\n\nNAME_MAX=int(subprocess.check_output([\"getconf\", \"NAME_MAX\", \".\"]))\n\ntest_num=0\n\ncode='''#!/usr/bin/perl\nprint \"Executed interpreter! Args:\\n\";\nprint \"0 : '$0'\\n\";\n$counter = 1;\nforeach my $a (@ARGV) {\n    print \"$counter : '$a'\\n\";\n    $counter++;\n}\n'''\n\n##\n# test - produce a binfmt_script hashbang line for testing\n#\n# @size:     bytes for bprm->buf line, including hashbang but not newline\n# @good:     whether this script is expected to execute correctly\n# @hashbang: the special 2 bytes for running binfmt_script\n# @leading:  any leading whitespace before the executable path\n# @root:     start of executable pathname\n# @target:   end of executable pathname\n# @arg:      bytes following the executable pathname\n# @fill:     character to fill between @root and @target to reach @size bytes\n# @newline:  character to use as newline, not counted towards @size\n# ...\ndef test(name, size, good=True, leading=\"\", root=\"./\", target=\"/perl\",\n                     fill=\"A\", arg=\"\", newline=\"\\n\", hashbang=\"#!\"):\n    global test_num, tests, NAME_MAX\n    test_num += 1\n    if test_num > tests:\n        raise ValueError(\"more binfmt_script tests than expected! (want %d, expected %d)\"\n                         % (test_num, tests))\n\n    middle = \"\"\n    remaining = size - len(hashbang) - len(leading) - len(root) - len(target) - len(arg)\n    # The middle of the pathname must not exceed NAME_MAX\n    while remaining >= NAME_MAX:\n        middle += fill * (NAME_MAX - 1)\n        middle += '/'\n        remaining -= NAME_MAX\n    middle += fill * remaining\n\n    dirpath = root + middle\n    binary = dirpath + target\n    if len(target):\n        os.makedirs(dirpath, mode=0o755, exist_ok=True)\n        open(binary, \"w\").write(code)\n        os.chmod(binary, 0o755)\n\n    buf=hashbang + leading + root + middle + target + arg + newline\n    if len(newline) > 0:\n        buf += 'echo this is not really perl\\n'\n\n    script = \"binfmt_script-%s\" % (name)\n    open(script, \"w\").write(buf)\n    os.chmod(script, 0o755)\n\n    proc = subprocess.Popen([\"./%s\" % (script)], shell=True,\n                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    stdout = proc.communicate()[0]\n\n    if proc.returncode == 0 and b'Executed interpreter' in stdout:\n        if good:\n            print(\"ok %d - binfmt_script %s (successful good exec)\"\n                  % (test_num, name))\n        else:\n            print(\"not ok %d - binfmt_script %s succeeded when it should have failed\"\n                  % (test_num, name))\n    else:\n        if good:\n            print(\"not ok %d - binfmt_script %s failed when it should have succeeded (rc:%d)\"\n                  % (test_num, name, proc.returncode))\n        else:\n            print(\"ok %d - binfmt_script %s (correctly failed bad exec)\"\n                  % (test_num, name))\n\n    # Clean up crazy binaries\n    os.unlink(script)\n    if len(target):\n        elements = binary.split('/')\n        os.unlink(binary)\n        elements.pop()\n        while len(elements) > 1:\n            os.rmdir(\"/\".join(elements))\n            elements.pop()\n\ntests=27\nprint(\"TAP version 1.3\")\nprint(\"1..%d\" % (tests))\n\n### FAIL (8 tests)\n\n# Entire path is well past the BINFMT_BUF_SIZE.\ntest(name=\"too-big\",        size=SIZE+80, good=False)\n# Path is right at max size, making it impossible to tell if it was truncated.\ntest(name=\"exact\",          size=SIZE,    good=False)\n# Same as above, but with leading whitespace.\ntest(name=\"exact-space\",    size=SIZE,    good=False, leading=\" \")\n# Huge buffer of only whitespace.\ntest(name=\"whitespace-too-big\", size=SIZE+71, good=False, root=\"\",\n                                              fill=\" \", target=\"\")\n# A good path, but it gets truncated due to leading whitespace.\ntest(name=\"truncated\",      size=SIZE+17, good=False, leading=\" \" * 19)\n# Entirely empty except for #!\ntest(name=\"empty\",          size=2,       good=False, root=\"\",\n                                          fill=\"\", target=\"\", newline=\"\")\n# Within size, but entirely spaces\ntest(name=\"spaces\",         size=SIZE-1,  good=False, root=\"\", fill=\" \",\n                                          target=\"\", newline=\"\")\n# Newline before binary.\ntest(name=\"newline-prefix\", size=SIZE-1,  good=False, leading=\"\\n\",\n                                          root=\"\", fill=\" \", target=\"\")\n\n### ok (19 tests)\n\n# The original test case that was broken by commit:\n# 8099b047ecc4 (\"exec: load_script: don't blindly truncate shebang string\")\ntest(name=\"test.pl\",        size=439, leading=\" \",\n     root=\"./nix/store/bwav8kz8b3y471wjsybgzw84mrh4js9-perl-5.28.1/bin\",\n     arg=\" -I/nix/store/x6yyav38jgr924nkna62q3pkp0dgmzlx-perl5.28.1-File-Slurp-9999.25/lib/perl5/site_perl -I/nix/store/ha8v67sl8dac92r9z07vzr4gv1y9nwqz-perl5.28.1-Net-DBus-1.1.0/lib/perl5/site_perl -I/nix/store/dcrkvnjmwh69ljsvpbdjjdnqgwx90a9d-perl5.28.1-XML-Parser-2.44/lib/perl5/site_perl -I/nix/store/rmji88k2zz7h4zg97385bygcydrf2q8h-perl5.28.1-XML-Twig-3.52/lib/perl5/site_perl\")\n# One byte under size, leaving newline visible.\ntest(name=\"one-under\",           size=SIZE-1)\n# Two bytes under size, leaving newline visible.\ntest(name=\"two-under\",           size=SIZE-2)\n# Exact size, but trailing whitespace visible instead of newline\ntest(name=\"exact-trunc-whitespace\", size=SIZE, arg=\" \")\n# Exact size, but trailing space and first arg char visible instead of newline.\ntest(name=\"exact-trunc-arg\",     size=SIZE, arg=\" f\")\n# One bute under, with confirmed non-truncated arg since newline now visible.\ntest(name=\"one-under-full-arg\",  size=SIZE-1, arg=\" f\")\n# Short read buffer by one byte.\ntest(name=\"one-under-no-nl\",     size=SIZE-1, newline=\"\")\n# Short read buffer by half buffer size.\ntest(name=\"half-under-no-nl\",    size=int(SIZE/2), newline=\"\")\n# One byte under with whitespace arg. leaving wenline visible.\ntest(name=\"one-under-trunc-arg\", size=SIZE-1, arg=\" \")\n# One byte under with whitespace leading. leaving wenline visible.\ntest(name=\"one-under-leading\",   size=SIZE-1, leading=\" \")\n# One byte under with whitespace leading and as arg. leaving newline visible.\ntest(name=\"one-under-leading-trunc-arg\",  size=SIZE-1, leading=\" \", arg=\" \")\n# Same as above, but with 2 bytes under\ntest(name=\"two-under-no-nl\",     size=SIZE-2, newline=\"\")\ntest(name=\"two-under-trunc-arg\", size=SIZE-2, arg=\" \")\ntest(name=\"two-under-leading\",   size=SIZE-2, leading=\" \")\ntest(name=\"two-under-leading-trunc-arg\",   size=SIZE-2, leading=\" \", arg=\" \")\n# Same as above, but with buffer half filled\ntest(name=\"two-under-no-nl\",     size=int(SIZE/2), newline=\"\")\ntest(name=\"two-under-trunc-arg\", size=int(SIZE/2), arg=\" \")\ntest(name=\"two-under-leading\",   size=int(SIZE/2), leading=\" \")\ntest(name=\"two-under-lead-trunc-arg\", size=int(SIZE/2), leading=\" \", arg=\" \")\n\nif test_num != tests:\n    raise ValueError(\"fewer binfmt_script tests than expected! (ran %d, expected %d\"\n                     % (test_num, tests))\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}