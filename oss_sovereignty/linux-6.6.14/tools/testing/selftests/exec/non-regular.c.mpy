{
  "module_name": "non-regular.c",
  "hash_id": "8999e7090d37ee95c3c39c94c40d345c83c9ef8e4ff6515750e1d1753f0c2e18",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/exec/non-regular.c",
  "human_readable_source": "\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/sysmacros.h>\n#include <sys/types.h>\n\n#include \"../kselftest_harness.h\"\n\n \nvoid rm(struct __test_metadata *_metadata, const char *pathname,\n\tint is_dir)\n{\n\tint rc;\n\n\tif (is_dir)\n\t\trc = rmdir(pathname);\n\telse\n\t\trc = unlink(pathname);\n\n\tif (rc < 0) {\n\t\tASSERT_EQ(errno, ENOENT) {\n\t\t\tTH_LOG(\"Not ENOENT: %s\", pathname);\n\t\t}\n\t} else {\n\t\tASSERT_EQ(rc, 0) {\n\t\t\tTH_LOG(\"Failed to remove: %s\", pathname);\n\t\t}\n\t}\n}\n\nFIXTURE(file) {\n\tchar *pathname;\n\tint is_dir;\n};\n\nFIXTURE_VARIANT(file)\n{\n\tconst char *name;\n\tint expected;\n\tint is_dir;\n\tvoid (*setup)(struct __test_metadata *_metadata,\n\t\t      FIXTURE_DATA(file) *self,\n\t\t      const FIXTURE_VARIANT(file) *variant);\n\tint major, minor, mode;  \n};\n\nvoid setup_link(struct __test_metadata *_metadata,\n\t\tFIXTURE_DATA(file) *self,\n\t\tconst FIXTURE_VARIANT(file) *variant)\n{\n\tconst char * const paths[] = {\n\t\t\"/bin/true\",\n\t\t\"/usr/bin/true\",\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(paths); i++) {\n\t\tif (access(paths[i], X_OK) == 0) {\n\t\t\tASSERT_EQ(symlink(paths[i], self->pathname), 0);\n\t\t\treturn;\n\t\t}\n\t}\n\tASSERT_EQ(1, 0) {\n\t\tTH_LOG(\"Could not find viable 'true' binary\");\n\t}\n}\n\nFIXTURE_VARIANT_ADD(file, S_IFLNK)\n{\n\t.name = \"S_IFLNK\",\n\t.expected = ELOOP,\n\t.setup = setup_link,\n};\n\nvoid setup_dir(struct __test_metadata *_metadata,\n\t       FIXTURE_DATA(file) *self,\n\t       const FIXTURE_VARIANT(file) *variant)\n{\n\tASSERT_EQ(mkdir(self->pathname, 0755), 0);\n}\n\nFIXTURE_VARIANT_ADD(file, S_IFDIR)\n{\n\t.name = \"S_IFDIR\",\n\t.is_dir = 1,\n\t.expected = EACCES,\n\t.setup = setup_dir,\n};\n\nvoid setup_node(struct __test_metadata *_metadata,\n\t\tFIXTURE_DATA(file) *self,\n\t\tconst FIXTURE_VARIANT(file) *variant)\n{\n\tdev_t dev;\n\tint rc;\n\n\tdev = makedev(variant->major, variant->minor);\n\trc = mknod(self->pathname, 0755 | variant->mode, dev);\n\tASSERT_EQ(rc, 0) {\n\t\tif (errno == EPERM)\n\t\t\tSKIP(return, \"Please run as root; cannot mknod(%s)\",\n\t\t\t\tvariant->name);\n\t}\n}\n\nFIXTURE_VARIANT_ADD(file, S_IFBLK)\n{\n\t.name = \"S_IFBLK\",\n\t.expected = EACCES,\n\t.setup = setup_node,\n\t \n\t.major = 7,\n\t.minor = 0,\n\t.mode = S_IFBLK,\n};\n\nFIXTURE_VARIANT_ADD(file, S_IFCHR)\n{\n\t.name = \"S_IFCHR\",\n\t.expected = EACCES,\n\t.setup = setup_node,\n\t \n\t.major = 1,\n\t.minor = 5,\n\t.mode = S_IFCHR,\n};\n\nvoid setup_fifo(struct __test_metadata *_metadata,\n\t\tFIXTURE_DATA(file) *self,\n\t\tconst FIXTURE_VARIANT(file) *variant)\n{\n\tASSERT_EQ(mkfifo(self->pathname, 0755), 0);\n}\n\nFIXTURE_VARIANT_ADD(file, S_IFIFO)\n{\n\t.name = \"S_IFIFO\",\n\t.expected = EACCES,\n\t.setup = setup_fifo,\n};\n\nFIXTURE_SETUP(file)\n{\n\tASSERT_GT(asprintf(&self->pathname, \"%s.test\", variant->name), 6);\n\tself->is_dir = variant->is_dir;\n\n\trm(_metadata, self->pathname, variant->is_dir);\n\tvariant->setup(_metadata, self, variant);\n}\n\nFIXTURE_TEARDOWN(file)\n{\n\trm(_metadata, self->pathname, self->is_dir);\n}\n\nTEST_F(file, exec_errno)\n{\n\tchar * const argv[2] = { (char * const)self->pathname, NULL };\n\n\tEXPECT_LT(execv(argv[0], argv), 0);\n\tEXPECT_EQ(errno, variant->expected);\n}\n\n \nFIXTURE(sock)\n{\n\tint fd;\n};\n\nFIXTURE_SETUP(sock)\n{\n\tself->fd = socket(AF_INET, SOCK_STREAM, 0);\n\tASSERT_GE(self->fd, 0);\n}\n\nFIXTURE_TEARDOWN(sock)\n{\n\tif (self->fd >= 0)\n\t\tASSERT_EQ(close(self->fd), 0);\n}\n\nTEST_F(sock, exec_errno)\n{\n\tchar * const argv[2] = { \" magic socket \", NULL };\n\tchar * const envp[1] = { NULL };\n\n\tEXPECT_LT(fexecve(self->fd, argv, envp), 0);\n\tEXPECT_EQ(errno, EACCES);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}