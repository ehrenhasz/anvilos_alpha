{
  "module_name": "execveat.c",
  "hash_id": "77cbcf3f38896538dfe09b483cb67affc6eeafcdc02c814868fed4fb440064f5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/exec/execveat.c",
  "human_readable_source": "\n \n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE   \n#endif\n#include <sys/sendfile.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"../kselftest.h\"\n\nstatic char longpath[2 * PATH_MAX] = \"\";\nstatic char *envp[] = { \"IN_TEST=yes\", NULL, NULL };\nstatic char *argv[] = { \"execveat\", \"99\", NULL };\n\nstatic int execveat_(int fd, const char *path, char **argv, char **envp,\n\t\t     int flags)\n{\n#ifdef __NR_execveat\n\treturn syscall(__NR_execveat, fd, path, argv, envp, flags);\n#else\n\terrno = ENOSYS;\n\treturn -1;\n#endif\n}\n\n#define check_execveat_fail(fd, path, flags, errno)\t\\\n\t_check_execveat_fail(fd, path, flags, errno, #errno)\nstatic int _check_execveat_fail(int fd, const char *path, int flags,\n\t\t\t\tint expected_errno, const char *errno_str)\n{\n\tint rc;\n\n\terrno = 0;\n\tprintf(\"Check failure of execveat(%d, '%s', %d) with %s... \",\n\t\tfd, path?:\"(null)\", flags, errno_str);\n\trc = execveat_(fd, path, argv, envp, flags);\n\n\tif (rc > 0) {\n\t\tprintf(\"[FAIL] (unexpected success from execveat(2))\\n\");\n\t\treturn 1;\n\t}\n\tif (errno != expected_errno) {\n\t\tprintf(\"[FAIL] (expected errno %d (%s) not %d (%s)\\n\",\n\t\t\texpected_errno, strerror(expected_errno),\n\t\t\terrno, strerror(errno));\n\t\treturn 1;\n\t}\n\tprintf(\"[OK]\\n\");\n\treturn 0;\n}\n\nstatic int check_execveat_invoked_rc(int fd, const char *path, int flags,\n\t\t\t\t     int expected_rc, int expected_rc2)\n{\n\tint status;\n\tint rc;\n\tpid_t child;\n\tint pathlen = path ? strlen(path) : 0;\n\n\tif (pathlen > 40)\n\t\tprintf(\"Check success of execveat(%d, '%.20s...%s', %d)... \",\n\t\t\tfd, path, (path + pathlen - 20), flags);\n\telse\n\t\tprintf(\"Check success of execveat(%d, '%s', %d)... \",\n\t\t\tfd, path?:\"(null)\", flags);\n\tchild = fork();\n\tif (child < 0) {\n\t\tprintf(\"[FAIL] (fork() failed)\\n\");\n\t\treturn 1;\n\t}\n\tif (child == 0) {\n\t\t \n\t\trc = execveat_(fd, path, argv, envp, flags);\n\t\tprintf(\"[FAIL]: execveat() failed, rc=%d errno=%d (%s)\\n\",\n\t\t\trc, errno, strerror(errno));\n\t\texit(1);   \n\t}\n\t \n\trc = waitpid(child, &status, 0);\n\tif (rc != child) {\n\t\tprintf(\"[FAIL] (waitpid(%d,...) returned %d)\\n\", child, rc);\n\t\treturn 1;\n\t}\n\tif (!WIFEXITED(status)) {\n\t\tprintf(\"[FAIL] (child %d did not exit cleanly, status=%08x)\\n\",\n\t\t\tchild, status);\n\t\treturn 1;\n\t}\n\tif ((WEXITSTATUS(status) != expected_rc) &&\n\t    (WEXITSTATUS(status) != expected_rc2)) {\n\t\tprintf(\"[FAIL] (child %d exited with %d not %d nor %d)\\n\",\n\t\t\tchild, WEXITSTATUS(status), expected_rc, expected_rc2);\n\t\treturn 1;\n\t}\n\tprintf(\"[OK]\\n\");\n\treturn 0;\n}\n\nstatic int check_execveat(int fd, const char *path, int flags)\n{\n\treturn check_execveat_invoked_rc(fd, path, flags, 99, 99);\n}\n\nstatic char *concat(const char *left, const char *right)\n{\n\tchar *result = malloc(strlen(left) + strlen(right) + 1);\n\n\tstrcpy(result, left);\n\tstrcat(result, right);\n\treturn result;\n}\n\nstatic int open_or_die(const char *filename, int flags)\n{\n\tint fd = open(filename, flags);\n\n\tif (fd < 0) {\n\t\tprintf(\"Failed to open '%s'; \"\n\t\t\t\"check prerequisites are available\\n\", filename);\n\t\texit(1);\n\t}\n\treturn fd;\n}\n\nstatic void exe_cp(const char *src, const char *dest)\n{\n\tint in_fd = open_or_die(src, O_RDONLY);\n\tint out_fd = open(dest, O_RDWR|O_CREAT|O_TRUNC, 0755);\n\tstruct stat info;\n\n\tfstat(in_fd, &info);\n\tsendfile(out_fd, in_fd, NULL, info.st_size);\n\tclose(in_fd);\n\tclose(out_fd);\n}\n\n#define XX_DIR_LEN 200\nstatic int check_execveat_pathmax(int root_dfd, const char *src, int is_script)\n{\n\tint fail = 0;\n\tint ii, count, len;\n\tchar longname[XX_DIR_LEN + 1];\n\tint fd;\n\n\tif (*longpath == '\\0') {\n\t\t \n\t\tchar *cwd = getcwd(NULL, 0);\n\n\t\tif (!cwd) {\n\t\t\tprintf(\"Failed to getcwd(), errno=%d (%s)\\n\",\n\t\t\t       errno, strerror(errno));\n\t\t\treturn 2;\n\t\t}\n\t\tstrcpy(longpath, cwd);\n\t\tstrcat(longpath, \"/\");\n\t\tmemset(longname, 'x', XX_DIR_LEN - 1);\n\t\tlongname[XX_DIR_LEN - 1] = '/';\n\t\tlongname[XX_DIR_LEN] = '\\0';\n\t\tcount = (PATH_MAX - 3 - strlen(cwd)) / XX_DIR_LEN;\n\t\tfor (ii = 0; ii < count; ii++) {\n\t\t\tstrcat(longpath, longname);\n\t\t\tmkdir(longpath, 0755);\n\t\t}\n\t\tlen = (PATH_MAX - 3 - strlen(cwd)) - (count * XX_DIR_LEN);\n\t\tif (len <= 0)\n\t\t\tlen = 1;\n\t\tmemset(longname, 'y', len);\n\t\tlongname[len] = '\\0';\n\t\tstrcat(longpath, longname);\n\t\tfree(cwd);\n\t}\n\texe_cp(src, longpath);\n\n\t \n\tfd = open(longpath, O_RDONLY);\n\tif (fd > 0) {\n\t\tprintf(\"Invoke copy of '%s' via filename of length %zu:\\n\",\n\t\t\tsrc, strlen(longpath));\n\t\tfail += check_execveat(fd, \"\", AT_EMPTY_PATH);\n\t} else {\n\t\tprintf(\"Failed to open length %zu filename, errno=%d (%s)\\n\",\n\t\t\tstrlen(longpath), errno, strerror(errno));\n\t\tfail++;\n\t}\n\n\t \n\tif (is_script)\n\t\tfail += check_execveat_invoked_rc(root_dfd, longpath + 1, 0,\n\t\t\t\t\t\t  127, 126);\n\telse\n\t\tfail += check_execveat(root_dfd, longpath + 1, 0);\n\n\treturn fail;\n}\n\nstatic int run_tests(void)\n{\n\tint fail = 0;\n\tchar *fullname = realpath(\"execveat\", NULL);\n\tchar *fullname_script = realpath(\"script\", NULL);\n\tchar *fullname_symlink = concat(fullname, \".symlink\");\n\tint subdir_dfd = open_or_die(\"subdir\", O_DIRECTORY|O_RDONLY);\n\tint subdir_dfd_ephemeral = open_or_die(\"subdir.ephemeral\",\n\t\t\t\t\t       O_DIRECTORY|O_RDONLY);\n\tint dot_dfd = open_or_die(\".\", O_DIRECTORY|O_RDONLY);\n\tint root_dfd = open_or_die(\"/\", O_DIRECTORY|O_RDONLY);\n\tint dot_dfd_path = open_or_die(\".\", O_DIRECTORY|O_RDONLY|O_PATH);\n\tint dot_dfd_cloexec = open_or_die(\".\", O_DIRECTORY|O_RDONLY|O_CLOEXEC);\n\tint fd = open_or_die(\"execveat\", O_RDONLY);\n\tint fd_path = open_or_die(\"execveat\", O_RDONLY|O_PATH);\n\tint fd_symlink = open_or_die(\"execveat.symlink\", O_RDONLY);\n\tint fd_denatured = open_or_die(\"execveat.denatured\", O_RDONLY);\n\tint fd_denatured_path = open_or_die(\"execveat.denatured\",\n\t\t\t\t\t    O_RDONLY|O_PATH);\n\tint fd_script = open_or_die(\"script\", O_RDONLY);\n\tint fd_ephemeral = open_or_die(\"execveat.ephemeral\", O_RDONLY);\n\tint fd_ephemeral_path = open_or_die(\"execveat.path.ephemeral\",\n\t\t\t\t\t    O_RDONLY|O_PATH);\n\tint fd_script_ephemeral = open_or_die(\"script.ephemeral\", O_RDONLY);\n\tint fd_cloexec = open_or_die(\"execveat\", O_RDONLY|O_CLOEXEC);\n\tint fd_script_cloexec = open_or_die(\"script\", O_RDONLY|O_CLOEXEC);\n\n\t \n\terrno = 0;\n\texecveat_(-1, NULL, NULL, NULL, 0);\n\tif (errno == ENOSYS) {\n\t\tksft_exit_skip(\n\t\t\t\"ENOSYS calling execveat - no kernel support?\\n\");\n\t}\n\n\t \n\tlseek(fd, 10, SEEK_SET);\n\n\t \n\t \n\tfail += check_execveat(subdir_dfd, \"../execveat\", 0);\n\tfail += check_execveat(dot_dfd, \"execveat\", 0);\n\tfail += check_execveat(dot_dfd_path, \"execveat\", 0);\n\t \n\tfail += check_execveat(AT_FDCWD, fullname, 0);\n\t \n\tfail += check_execveat(99, fullname, 0);\n\t \n\tfail += check_execveat(fd, \"\", AT_EMPTY_PATH);\n\t \n\tfail += check_execveat(fd_cloexec, \"\", AT_EMPTY_PATH);\n\t \n\tfail += check_execveat(fd_path, \"\", AT_EMPTY_PATH);\n\n\t \n\t \n\trename(\"execveat.ephemeral\", \"execveat.moved\");\n\tfail += check_execveat(fd_ephemeral, \"\", AT_EMPTY_PATH);\n\t \n\tunlink(\"execveat.moved\");  \n\tfail += check_execveat(fd_ephemeral, \"\", AT_EMPTY_PATH);\n\n\t \n\t \n\tunlink(\"execveat.path.ephemeral\");\n\tfail += check_execveat(fd_ephemeral_path, \"\", AT_EMPTY_PATH);\n\n\t \n\tfail += check_execveat_fail(fd, \"\", 0, ENOENT);\n\tfail += check_execveat_fail(fd, NULL, AT_EMPTY_PATH, EFAULT);\n\n\t \n\t \n\tfail += check_execveat(dot_dfd, \"execveat.symlink\", 0);\n\tfail += check_execveat(dot_dfd_path, \"execveat.symlink\", 0);\n\t \n\tfail += check_execveat(AT_FDCWD, fullname_symlink, 0);\n\t \n\tfail += check_execveat(fd_symlink, \"\", AT_EMPTY_PATH);\n\tfail += check_execveat(fd_symlink, \"\",\n\t\t\t       AT_EMPTY_PATH|AT_SYMLINK_NOFOLLOW);\n\n\t \n\t \n\tfail += check_execveat_fail(dot_dfd, \"execveat.symlink\",\n\t\t\t\t    AT_SYMLINK_NOFOLLOW, ELOOP);\n\tfail += check_execveat_fail(dot_dfd_path, \"execveat.symlink\",\n\t\t\t\t    AT_SYMLINK_NOFOLLOW, ELOOP);\n\t \n\tfail += check_execveat_fail(AT_FDCWD, fullname_symlink,\n\t\t\t\t    AT_SYMLINK_NOFOLLOW, ELOOP);\n\n\t \n\tfail += check_execveat_fail(dot_dfd, \"pipe\", 0, EACCES);\n\tunlink(\"pipe\");\n\n\t \n\t \n\tfail += check_execveat(subdir_dfd, \"../script\", 0);\n\tfail += check_execveat(dot_dfd, \"script\", 0);\n\tfail += check_execveat(dot_dfd_path, \"script\", 0);\n\t \n\tfail += check_execveat(AT_FDCWD, fullname_script, 0);\n\t \n\tfail += check_execveat(fd_script, \"\", AT_EMPTY_PATH);\n\tfail += check_execveat(fd_script, \"\",\n\t\t\t       AT_EMPTY_PATH|AT_SYMLINK_NOFOLLOW);\n\t \n\tfail += check_execveat_fail(fd_script_cloexec, \"\", AT_EMPTY_PATH,\n\t\t\t\t    ENOENT);\n\tfail += check_execveat_fail(dot_dfd_cloexec, \"script\", 0, ENOENT);\n\n\t \n\t \n\trename(\"script.ephemeral\", \"script.moved\");\n\tfail += check_execveat(fd_script_ephemeral, \"\", AT_EMPTY_PATH);\n\t \n\tunlink(\"script.moved\");  \n\tfail += check_execveat(fd_script_ephemeral, \"\", AT_EMPTY_PATH);\n\n\t \n\trename(\"subdir.ephemeral\", \"subdir.moved\");\n\tfail += check_execveat(subdir_dfd_ephemeral, \"../script\", 0);\n\tfail += check_execveat(subdir_dfd_ephemeral, \"script\", 0);\n\t \n\tunlink(\"subdir.moved/script\");\n\tunlink(\"subdir.moved\");\n\t \n\tfail += check_execveat(subdir_dfd_ephemeral, \"../script\", 0);\n\tfail += check_execveat_fail(subdir_dfd_ephemeral, \"script\", 0, ENOENT);\n\n\t \n\tfail += check_execveat_fail(dot_dfd, \"execveat\", 0xFFFF, EINVAL);\n\t \n\tfail += check_execveat_fail(dot_dfd, \"no-such-file\", 0, ENOENT);\n\tfail += check_execveat_fail(dot_dfd_path, \"no-such-file\", 0, ENOENT);\n\tfail += check_execveat_fail(AT_FDCWD, \"no-such-file\", 0, ENOENT);\n\t \n\tfail += check_execveat_fail(dot_dfd, \"\", AT_EMPTY_PATH, EACCES);\n\t \n\tfail += check_execveat_fail(dot_dfd, \"Makefile\", 0, EACCES);\n\tfail += check_execveat_fail(fd_denatured, \"\", AT_EMPTY_PATH, EACCES);\n\tfail += check_execveat_fail(fd_denatured_path, \"\", AT_EMPTY_PATH,\n\t\t\t\t    EACCES);\n\t \n\tfail += check_execveat_fail(99, \"\", AT_EMPTY_PATH, EBADF);\n\tfail += check_execveat_fail(99, \"execveat\", 0, EBADF);\n\t \n\tfail += check_execveat_fail(fd, \"execveat\", 0, ENOTDIR);\n\n\tfail += check_execveat_pathmax(root_dfd, \"execveat\", 0);\n\tfail += check_execveat_pathmax(root_dfd, \"script\", 1);\n\treturn fail;\n}\n\nstatic void prerequisites(void)\n{\n\tint fd;\n\tconst char *script = \"#!/bin/sh\\nexit $*\\n\";\n\n\t \n\texe_cp(\"execveat\", \"execveat.ephemeral\");\n\texe_cp(\"execveat\", \"execveat.path.ephemeral\");\n\texe_cp(\"script\", \"script.ephemeral\");\n\tmkdir(\"subdir.ephemeral\", 0755);\n\n\tfd = open(\"subdir.ephemeral/script\", O_RDWR|O_CREAT|O_TRUNC, 0755);\n\twrite(fd, script, strlen(script));\n\tclose(fd);\n\n\tmkfifo(\"pipe\", 0755);\n}\n\nint main(int argc, char **argv)\n{\n\tint ii;\n\tint rc;\n\tconst char *verbose = getenv(\"VERBOSE\");\n\n\tif (argc >= 2) {\n\t\t \n\t\tconst char *in_test = getenv(\"IN_TEST\");\n\n\t\tif (verbose) {\n\t\t\tprintf(\"  invoked with:\");\n\t\t\tfor (ii = 0; ii < argc; ii++)\n\t\t\t\tprintf(\" [%d]='%s'\", ii, argv[ii]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\t \n\t\tif (!in_test || strcmp(in_test, \"yes\") != 0) {\n\t\t\tprintf(\"[FAIL] (no IN_TEST=yes in env)\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\trc = atoi(argv[argc - 1]);\n\t\tfflush(stdout);\n\t} else {\n\t\tprerequisites();\n\t\tif (verbose)\n\t\t\tenvp[1] = \"VERBOSE=1\";\n\t\trc = run_tests();\n\t\tif (rc > 0)\n\t\t\tprintf(\"%d tests failed\\n\", rc);\n\t}\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}