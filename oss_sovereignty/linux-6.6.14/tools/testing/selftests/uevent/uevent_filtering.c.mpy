{
  "module_name": "uevent_filtering.c",
  "hash_id": "7b8cee19f4774eb14c8f681fdf75cebe8ed9c225d9aa81eb915604dfe33a4194",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/uevent/uevent_filtering.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/netlink.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <sys/socket.h>\n#include <sched.h>\n#include <sys/eventfd.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"../kselftest_harness.h\"\n\n#define __DEV_FULL \"/sys/devices/virtual/mem/full/uevent\"\n#define __UEVENT_BUFFER_SIZE (2048 * 2)\n#define __UEVENT_HEADER \"add@/devices/virtual/mem/full\"\n#define __UEVENT_HEADER_LEN sizeof(\"add@/devices/virtual/mem/full\")\n#define __UEVENT_LISTEN_ALL -1\n\nssize_t read_nointr(int fd, void *buf, size_t count)\n{\n\tssize_t ret;\n\nagain:\n\tret = read(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\n\treturn ret;\n}\n\nssize_t write_nointr(int fd, const void *buf, size_t count)\n{\n\tssize_t ret;\n\nagain:\n\tret = write(fd, buf, count);\n\tif (ret < 0 && errno == EINTR)\n\t\tgoto again;\n\n\treturn ret;\n}\n\nint wait_for_pid(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\n\t\treturn -1;\n\t}\n\n\tif (ret != pid)\n\t\tgoto again;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int uevent_listener(unsigned long post_flags, bool expect_uevent,\n\t\t\t   int sync_fd)\n{\n\tint sk_fd, ret;\n\tsocklen_t sk_addr_len;\n\tint fret = -1, rcv_buf_sz = __UEVENT_BUFFER_SIZE;\n\tuint64_t sync_add = 1;\n\tstruct sockaddr_nl sk_addr = { 0 }, rcv_addr = { 0 };\n\tchar buf[__UEVENT_BUFFER_SIZE] = { 0 };\n\tstruct iovec iov = { buf, __UEVENT_BUFFER_SIZE };\n\tchar control[CMSG_SPACE(sizeof(struct ucred))];\n\tstruct msghdr hdr = {\n\t\t&rcv_addr, sizeof(rcv_addr), &iov, 1,\n\t\tcontrol,   sizeof(control),  0,\n\t};\n\n\tsk_fd = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC,\n\t\t       NETLINK_KOBJECT_UEVENT);\n\tif (sk_fd < 0) {\n\t\tfprintf(stderr, \"%s - Failed to open uevent socket\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = setsockopt(sk_fd, SOL_SOCKET, SO_RCVBUF, &rcv_buf_sz,\n\t\t\t sizeof(rcv_buf_sz));\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"%s - Failed to set socket options\\n\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\n\tsk_addr.nl_family = AF_NETLINK;\n\tsk_addr.nl_groups = __UEVENT_LISTEN_ALL;\n\n\tsk_addr_len = sizeof(sk_addr);\n\tret = bind(sk_fd, (struct sockaddr *)&sk_addr, sk_addr_len);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"%s - Failed to bind socket\\n\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\n\tret = getsockname(sk_fd, (struct sockaddr *)&sk_addr, &sk_addr_len);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"%s - Failed to retrieve socket name\\n\", strerror(errno));\n\t\tgoto on_error;\n\t}\n\n\tif ((size_t)sk_addr_len != sizeof(sk_addr)) {\n\t\tfprintf(stderr, \"Invalid socket address size\\n\");\n\t\tgoto on_error;\n\t}\n\n\tif (post_flags & CLONE_NEWUSER) {\n\t\tret = unshare(CLONE_NEWUSER);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s - Failed to unshare user namespace\\n\",\n\t\t\t\tstrerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tif (post_flags & CLONE_NEWNET) {\n\t\tret = unshare(CLONE_NEWNET);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s - Failed to unshare network namespace\\n\",\n\t\t\t\tstrerror(errno));\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tret = write_nointr(sync_fd, &sync_add, sizeof(sync_add));\n\tclose(sync_fd);\n\tif (ret != sizeof(sync_add)) {\n\t\tfprintf(stderr, \"Failed to synchronize with parent process\\n\");\n\t\tgoto on_error;\n\t}\n\n\tfret = 0;\n\tfor (;;) {\n\t\tssize_t r;\n\n\t\tr = recvmsg(sk_fd, &hdr, 0);\n\t\tif (r <= 0) {\n\t\t\tfprintf(stderr, \"%s - Failed to receive uevent\\n\", strerror(errno));\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (memcmp(buf, \"libudev\", 8) == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (memcmp(buf, __UEVENT_HEADER, __UEVENT_HEADER_LEN) != 0)\n\t\t\tcontinue;\n\n\t\tif (!expect_uevent) {\n\t\t\tfprintf(stderr, \"Received unexpected uevent:\\n\");\n\t\t\tret = -1;\n\t\t}\n\n\t\tif (TH_LOG_ENABLED) {\n\t\t\t \n\t\t\t(void)write_nointr(STDERR_FILENO, buf, r);\n\t\t\t(void)write_nointr(STDERR_FILENO, \"\\n\", 1);\n\t\t}\n\n\t\tbreak;\n\t}\n\non_error:\n\tclose(sk_fd);\n\n\treturn fret;\n}\n\nint trigger_uevent(unsigned int times)\n{\n\tint fd, ret;\n\tunsigned int i;\n\n\tfd = open(__DEV_FULL, O_RDWR | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tif (errno != ENOENT)\n\t\t\treturn -EINVAL;\n\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < times; i++) {\n\t\tret = write_nointr(fd, \"add\\n\", sizeof(\"add\\n\") - 1);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Failed to trigger uevent\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tclose(fd);\n\n\treturn ret;\n}\n\nint set_death_signal(void)\n{\n\tint ret;\n\tpid_t ppid;\n\n\tret = prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t \n\tppid = getppid();\n\tif (ppid == 1) {\n\t\tpid_t self;\n\n\t\tself = getpid();\n\t\tret = kill(self, SIGKILL);\n\t}\n\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int do_test(unsigned long pre_flags, unsigned long post_flags,\n\t\t   bool expect_uevent, int sync_fd)\n{\n\tint ret;\n\tuint64_t wait_val;\n\tpid_t pid;\n\tsigset_t mask;\n\tsigset_t orig_mask;\n\tstruct timespec timeout;\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGCHLD);\n\n\tret = sigprocmask(SIG_BLOCK, &mask, &orig_mask);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"%s- Failed to block SIGCHLD\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tfprintf(stderr, \"%s - Failed to fork() new process\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (pid == 0) {\n\t\t \n\t\tret = set_death_signal();\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Failed to set PR_SET_PDEATHSIG to SIGKILL\\n\");\n\t\t\t_exit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (pre_flags & CLONE_NEWUSER) {\n\t\t\tret = unshare(CLONE_NEWUSER);\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s - Failed to unshare user namespace\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\t\t_exit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\n\t\tif (pre_flags & CLONE_NEWNET) {\n\t\t\tret = unshare(CLONE_NEWNET);\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s - Failed to unshare network namespace\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\t\t_exit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\n\t\tif (uevent_listener(post_flags, expect_uevent, sync_fd) < 0)\n\t\t\t_exit(EXIT_FAILURE);\n\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\n\tret = read_nointr(sync_fd, &wait_val, sizeof(wait_val));\n\tif (ret != sizeof(wait_val)) {\n\t\tfprintf(stderr, \"Failed to synchronize with child process\\n\");\n\t\t_exit(EXIT_FAILURE);\n\t}\n\n\t \n\tret = trigger_uevent(10);\n\tif (ret < 0)\n\t\tfprintf(stderr, \"Failed triggering uevents\\n\");\n\n\t \n\ttimeout.tv_sec = 2;\n\ttimeout.tv_nsec = 0;\n\nagain:\n\tret = sigtimedwait(&mask, NULL, &timeout);\n\tif (ret < 0) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\n\t\tif (!expect_uevent)\n\t\t\tret = kill(pid, SIGTERM);  \n\t\telse\n\t\t\tret = kill(pid, SIGUSR1);  \n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn ret;\n}\n\nstatic void signal_handler(int sig)\n{\n\tif (sig == SIGTERM)\n\t\t_exit(EXIT_SUCCESS);\n\n\t_exit(EXIT_FAILURE);\n}\n\nTEST(uevent_filtering)\n{\n\tint ret, sync_fd;\n\tstruct sigaction act;\n\n\tif (geteuid()) {\n\t\tTH_LOG(\"Uevent filtering tests require root privileges. Skipping test\");\n\t\t_exit(KSFT_SKIP);\n\t}\n\n\tret = access(__DEV_FULL, F_OK);\n\tEXPECT_EQ(0, ret) {\n\t\tif (errno == ENOENT) {\n\t\t\tTH_LOG(__DEV_FULL \" does not exist. Skipping test\");\n\t\t\t_exit(KSFT_SKIP);\n\t\t}\n\n\t\t_exit(KSFT_FAIL);\n\t}\n\n\tact.sa_handler = signal_handler;\n\tact.sa_flags = 0;\n\tsigemptyset(&act.sa_mask);\n\n\tret = sigaction(SIGTERM, &act, NULL);\n\tASSERT_EQ(0, ret);\n\n\tsync_fd = eventfd(0, EFD_CLOEXEC);\n\tASSERT_GE(sync_fd, 0);\n\n\t \n\tret = do_test(0, 0, true, sync_fd);\n\tASSERT_EQ(0, ret) {\n\t\tgoto do_cleanup;\n\t}\n\n\t \n\tret = do_test(CLONE_NEWNET, 0, true, sync_fd);\n\tASSERT_EQ(0, ret) {\n\t\tgoto do_cleanup;\n\t}\n\n\t \n\tret = do_test(CLONE_NEWUSER, 0, true, sync_fd);\n\tASSERT_EQ(0, ret) {\n\t\tgoto do_cleanup;\n\t}\n\n\t \n\tret = do_test(CLONE_NEWUSER | CLONE_NEWNET, 0, false, sync_fd);\n\tASSERT_EQ(0, ret) {\n\t\tgoto do_cleanup;\n\t}\n\n\t \n\tret = do_test(0, CLONE_NEWNET, true, sync_fd);\n\tASSERT_EQ(0, ret) {\n\t\tgoto do_cleanup;\n\t}\n\n\t \n\tret = do_test(0, CLONE_NEWUSER, true, sync_fd);\n\tASSERT_EQ(0, ret) {\n\t\tgoto do_cleanup;\n\t}\n\n\t \n\tret = do_test(0, CLONE_NEWUSER | CLONE_NEWNET, true, sync_fd);\n\tASSERT_EQ(0, ret) {\n\t\tgoto do_cleanup;\n\t}\n\ndo_cleanup:\n\tclose(sync_fd);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}