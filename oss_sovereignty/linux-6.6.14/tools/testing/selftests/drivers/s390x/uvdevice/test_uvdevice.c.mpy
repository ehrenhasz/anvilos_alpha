{
  "module_name": "test_uvdevice.c",
  "hash_id": "25e0bb63251328bda50d6b6f1484031b688663aefa6f0ce2b1f584d0809d0e4c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/s390x/uvdevice/test_uvdevice.c",
  "human_readable_source": "\n \n\n#include <stdint.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n\n#include <asm/uvdevice.h>\n\n#include \"../../../kselftest_harness.h\"\n\n#define UV_PATH  \"/dev/uv\"\n#define BUFFER_SIZE 0x200\nFIXTURE(uvio_fixture) {\n\tint uv_fd;\n\tstruct uvio_ioctl_cb uvio_ioctl;\n\tuint8_t buffer[BUFFER_SIZE];\n\t__u64 fault_page;\n};\n\nFIXTURE_VARIANT(uvio_fixture) {\n\tunsigned long ioctl_cmd;\n\tuint32_t arg_size;\n};\n\nFIXTURE_VARIANT_ADD(uvio_fixture, att) {\n\t.ioctl_cmd = UVIO_IOCTL_ATT,\n\t.arg_size = sizeof(struct uvio_attest),\n};\n\nFIXTURE_SETUP(uvio_fixture)\n{\n\tself->uv_fd = open(UV_PATH, O_ACCMODE);\n\n\tself->uvio_ioctl.argument_addr = (__u64)self->buffer;\n\tself->uvio_ioctl.argument_len = variant->arg_size;\n\tself->fault_page =\n\t\t(__u64)mmap(NULL, (size_t)getpagesize(), PROT_NONE, MAP_ANONYMOUS, -1, 0);\n}\n\nFIXTURE_TEARDOWN(uvio_fixture)\n{\n\tif (self->uv_fd)\n\t\tclose(self->uv_fd);\n\tmunmap((void *)self->fault_page, (size_t)getpagesize());\n}\n\nTEST_F(uvio_fixture, fault_ioctl_arg)\n{\n\tint rc, errno_cache;\n\n\trc = ioctl(self->uv_fd, variant->ioctl_cmd, NULL);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EFAULT);\n\n\trc = ioctl(self->uv_fd, variant->ioctl_cmd, self->fault_page);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EFAULT);\n}\n\nTEST_F(uvio_fixture, fault_uvio_arg)\n{\n\tint rc, errno_cache;\n\n\tself->uvio_ioctl.argument_addr = 0;\n\trc = ioctl(self->uv_fd, variant->ioctl_cmd, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EFAULT);\n\n\tself->uvio_ioctl.argument_addr = self->fault_page;\n\trc = ioctl(self->uv_fd, variant->ioctl_cmd, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EFAULT);\n}\n\n \nTEST_F(uvio_fixture, inval_ioctl_cb)\n{\n\tint rc, errno_cache;\n\n\tself->uvio_ioctl.argument_len = 0;\n\trc = ioctl(self->uv_fd, variant->ioctl_cmd, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EINVAL);\n\n\tself->uvio_ioctl.argument_len = (uint32_t)-1;\n\trc = ioctl(self->uv_fd, variant->ioctl_cmd, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EINVAL);\n\tself->uvio_ioctl.argument_len = variant->arg_size;\n\n\tself->uvio_ioctl.flags = (uint32_t)-1;\n\trc = ioctl(self->uv_fd, variant->ioctl_cmd, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EINVAL);\n\tself->uvio_ioctl.flags = 0;\n\n\tmemset(self->uvio_ioctl.reserved14, 0xff, sizeof(self->uvio_ioctl.reserved14));\n\trc = ioctl(self->uv_fd, variant->ioctl_cmd, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EINVAL);\n\n\tmemset(&self->uvio_ioctl, 0x11, sizeof(self->uvio_ioctl));\n\trc = ioctl(self->uv_fd, variant->ioctl_cmd, &self->uvio_ioctl);\n\tASSERT_EQ(rc, -1);\n}\n\nTEST_F(uvio_fixture, inval_ioctl_cmd)\n{\n\tint rc, errno_cache;\n\tuint8_t nr = _IOC_NR(variant->ioctl_cmd);\n\tunsigned long cmds[] = {\n\t\t_IOWR('a', nr, struct uvio_ioctl_cb),\n\t\t_IOWR(UVIO_TYPE_UVC, nr, int),\n\t\t_IO(UVIO_TYPE_UVC, nr),\n\t\t_IOR(UVIO_TYPE_UVC, nr, struct uvio_ioctl_cb),\n\t\t_IOW(UVIO_TYPE_UVC, nr, struct uvio_ioctl_cb),\n\t};\n\n\tfor (size_t i = 0; i < ARRAY_SIZE(cmds); i++) {\n\t\trc = ioctl(self->uv_fd, cmds[i], &self->uvio_ioctl);\n\t\terrno_cache = errno;\n\t\tASSERT_EQ(rc, -1);\n\t\tASSERT_EQ(errno_cache, ENOTTY);\n\t}\n}\n\nstruct test_attest_buffer {\n\tuint8_t arcb[0x180];\n\tuint8_t meas[64];\n\tuint8_t add[32];\n};\n\nFIXTURE(attest_fixture) {\n\tint uv_fd;\n\tstruct uvio_ioctl_cb uvio_ioctl;\n\tstruct uvio_attest uvio_attest;\n\tstruct test_attest_buffer attest_buffer;\n\t__u64 fault_page;\n};\n\nFIXTURE_SETUP(attest_fixture)\n{\n\tself->uv_fd = open(UV_PATH, O_ACCMODE);\n\n\tself->uvio_ioctl.argument_addr = (__u64)&self->uvio_attest;\n\tself->uvio_ioctl.argument_len = sizeof(self->uvio_attest);\n\n\tself->uvio_attest.arcb_addr = (__u64)&self->attest_buffer.arcb;\n\tself->uvio_attest.arcb_len = sizeof(self->attest_buffer.arcb);\n\n\tself->uvio_attest.meas_addr = (__u64)&self->attest_buffer.meas;\n\tself->uvio_attest.meas_len = sizeof(self->attest_buffer.meas);\n\n\tself->uvio_attest.add_data_addr = (__u64)&self->attest_buffer.add;\n\tself->uvio_attest.add_data_len = sizeof(self->attest_buffer.add);\n\tself->fault_page =\n\t\t(__u64)mmap(NULL, (size_t)getpagesize(), PROT_NONE, MAP_ANONYMOUS, -1, 0);\n}\n\nFIXTURE_TEARDOWN(attest_fixture)\n{\n\tif (self->uv_fd)\n\t\tclose(self->uv_fd);\n\tmunmap((void *)self->fault_page, (size_t)getpagesize());\n}\n\nstatic void att_inval_sizes_test(uint32_t *size, uint32_t max_size, bool test_zero,\n\t\t\t\t struct __test_metadata *_metadata,\n\t\t\t\t FIXTURE_DATA(attest_fixture) *self)\n{\n\tint rc, errno_cache;\n\tuint32_t tmp = *size;\n\n\tif (test_zero) {\n\t\t*size = 0;\n\t\trc = ioctl(self->uv_fd, UVIO_IOCTL_ATT, &self->uvio_ioctl);\n\t\terrno_cache = errno;\n\t\tASSERT_EQ(rc, -1);\n\t\tASSERT_EQ(errno_cache, EINVAL);\n\t}\n\t*size = max_size + 1;\n\trc = ioctl(self->uv_fd, UVIO_IOCTL_ATT, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EINVAL);\n\t*size = tmp;\n}\n\n \nTEST_F(attest_fixture, att_inval_request)\n{\n\tint rc, errno_cache;\n\n\tatt_inval_sizes_test(&self->uvio_attest.add_data_len, UVIO_ATT_ADDITIONAL_MAX_LEN,\n\t\t\t     false, _metadata, self);\n\tatt_inval_sizes_test(&self->uvio_attest.meas_len, UVIO_ATT_MEASUREMENT_MAX_LEN,\n\t\t\t     true, _metadata, self);\n\tatt_inval_sizes_test(&self->uvio_attest.arcb_len, UVIO_ATT_ARCB_MAX_LEN,\n\t\t\t     true, _metadata, self);\n\n\tself->uvio_attest.reserved136 = (uint16_t)-1;\n\trc = ioctl(self->uv_fd, UVIO_IOCTL_ATT, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EINVAL);\n\n\tmemset(&self->uvio_attest, 0x11, sizeof(self->uvio_attest));\n\trc = ioctl(self->uv_fd, UVIO_IOCTL_ATT, &self->uvio_ioctl);\n\tASSERT_EQ(rc, -1);\n}\n\nstatic void att_inval_addr_test(__u64 *addr, struct __test_metadata *_metadata,\n\t\t\t\tFIXTURE_DATA(attest_fixture) *self)\n{\n\tint rc, errno_cache;\n\t__u64 tmp = *addr;\n\n\t*addr = 0;\n\trc = ioctl(self->uv_fd, UVIO_IOCTL_ATT, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EFAULT);\n\t*addr = self->fault_page;\n\trc = ioctl(self->uv_fd, UVIO_IOCTL_ATT, &self->uvio_ioctl);\n\terrno_cache = errno;\n\tASSERT_EQ(rc, -1);\n\tASSERT_EQ(errno_cache, EFAULT);\n\t*addr = tmp;\n}\n\nTEST_F(attest_fixture, att_inval_addr)\n{\n\tatt_inval_addr_test(&self->uvio_attest.arcb_addr, _metadata, self);\n\tatt_inval_addr_test(&self->uvio_attest.add_data_addr, _metadata, self);\n\tatt_inval_addr_test(&self->uvio_attest.meas_addr, _metadata, self);\n}\n\nstatic void __attribute__((constructor)) __constructor_order_last(void)\n{\n\tif (!__constructor_order)\n\t\t__constructor_order = _CONSTRUCTOR_ORDER_BACKWARD;\n}\n\nint main(int argc, char **argv)\n{\n\tint fd = open(UV_PATH, O_ACCMODE);\n\n\tif (fd < 0)\n\t\tksft_exit_skip(\"No uv-device or cannot access \" UV_PATH  \"\\n\"\n\t\t\t       \"Enable CONFIG_S390_UV_UAPI and check the access rights on \"\n\t\t\t       UV_PATH \".\\n\");\n\tclose(fd);\n\treturn test_harness_run(argc, argv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}