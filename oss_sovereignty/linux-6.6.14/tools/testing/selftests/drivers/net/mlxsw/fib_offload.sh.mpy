{
  "module_name": "fib_offload.sh",
  "hash_id": "f2b58c66421d473e9d923ca7b556a5d5f7ad5aee95416b200a9753ad2fe18451",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/fib_offload.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test unicast FIB offload indication.\n\nlib_dir=$(dirname $0)/../../../net/forwarding\n\nALL_TESTS=\"\n\tipv6_route_add\n\tipv6_route_replace\n\tipv6_route_nexthop_group_share\n\tipv6_route_rate\n\"\nNUM_NETIFS=4\nsource $lib_dir/lib.sh\nsource $lib_dir/devlink_lib.sh\n\ntor1_create()\n{\n\tsimple_if_init $tor1_p1 2001:db8:1::2/128 2001:db8:1::3/128\n}\n\ntor1_destroy()\n{\n\tsimple_if_fini $tor1_p1 2001:db8:1::2/128 2001:db8:1::3/128\n}\n\ntor2_create()\n{\n\tsimple_if_init $tor2_p1 2001:db8:2::2/128 2001:db8:2::3/128\n}\n\ntor2_destroy()\n{\n\tsimple_if_fini $tor2_p1 2001:db8:2::2/128 2001:db8:2::3/128\n}\n\nspine_create()\n{\n\tip link set dev $spine_p1 up\n\tip link set dev $spine_p2 up\n\n\t__addr_add_del $spine_p1 add 2001:db8:1::1/64\n\t__addr_add_del $spine_p2 add 2001:db8:2::1/64\n}\n\nspine_destroy()\n{\n\t__addr_add_del $spine_p2 del 2001:db8:2::1/64\n\t__addr_add_del $spine_p1 del 2001:db8:1::1/64\n\n\tip link set dev $spine_p2 down\n\tip link set dev $spine_p1 down\n}\n\nipv6_offload_check()\n{\n\tlocal pfx=\"$1\"; shift\n\tlocal expected_num=$1; shift\n\tlocal num\n\n\t# Try to avoid races with route offload\n\tsleep .1\n\n\tnum=$(ip -6 route show match ${pfx} | grep \"offload\" | wc -l)\n\n\tif [ $num -eq $expected_num ]; then\n\t\treturn 0\n\tfi\n\n\treturn 1\n}\n\nipv6_route_add_prefix()\n{\n\tRET=0\n\n\t# Add a prefix route and check that it is offloaded.\n\tip -6 route add 2001:db8:3::/64 dev $spine_p1 metric 100\n\tipv6_offload_check \"2001:db8:3::/64 dev $spine_p1 metric 100\" 1\n\tcheck_err $? \"prefix route not offloaded\"\n\n\t# Append an identical prefix route with an higher metric and check that\n\t# offload indication did not change.\n\tip -6 route append 2001:db8:3::/64 dev $spine_p1 metric 200\n\tipv6_offload_check \"2001:db8:3::/64 dev $spine_p1 metric 100\" 1\n\tcheck_err $? \"lowest metric not offloaded after append\"\n\tipv6_offload_check \"2001:db8:3::/64 dev $spine_p1 metric 200\" 0\n\tcheck_err $? \"highest metric offloaded when should not\"\n\n\t# Prepend an identical prefix route with lower metric and check that\n\t# it is offloaded and the others are not.\n\tip -6 route append 2001:db8:3::/64 dev $spine_p1 metric 10\n\tipv6_offload_check \"2001:db8:3::/64 dev $spine_p1 metric 10\" 1\n\tcheck_err $? \"lowest metric not offloaded after prepend\"\n\tipv6_offload_check \"2001:db8:3::/64 dev $spine_p1 metric 100\" 0\n\tcheck_err $? \"mid metric offloaded when should not\"\n\tipv6_offload_check \"2001:db8:3::/64 dev $spine_p1 metric 200\" 0\n\tcheck_err $? \"highest metric offloaded when should not\"\n\n\t# Delete the routes and add the same route with a different nexthop\n\t# device. Check that it is offloaded.\n\tip -6 route flush 2001:db8:3::/64 dev $spine_p1\n\tip -6 route add 2001:db8:3::/64 dev $spine_p2\n\tipv6_offload_check \"2001:db8:3::/64 dev $spine_p2\" 1\n\n\tlog_test \"IPv6 prefix route add\"\n\n\tip -6 route flush 2001:db8:3::/64\n}\n\nipv6_route_add_mpath()\n{\n\tRET=0\n\n\t# Add a multipath route and check that it is offloaded.\n\tip -6 route add 2001:db8:3::/64 metric 100 \\\n\t\tnexthop via 2001:db8:1::2 dev $spine_p1 \\\n\t\tnexthop via 2001:db8:2::2 dev $spine_p2\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 2\n\tcheck_err $? \"multipath route not offloaded when should\"\n\n\t# Append another nexthop and check that it is offloaded as well.\n\tip -6 route append 2001:db8:3::/64 metric 100 \\\n\t\tnexthop via 2001:db8:1::3 dev $spine_p1\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 3\n\tcheck_err $? \"appended nexthop not offloaded when should\"\n\n\t# Mimic route replace by removing the route and adding it back with\n\t# only two nexthops.\n\tip -6 route del 2001:db8:3::/64\n\tip -6 route add 2001:db8:3::/64 metric 100 \\\n\t\tnexthop via 2001:db8:1::2 dev $spine_p1 \\\n\t\tnexthop via 2001:db8:2::2 dev $spine_p2\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 2\n\tcheck_err $? \"multipath route not offloaded after delete & add\"\n\n\t# Append a nexthop with an higher metric and check that the offload\n\t# indication did not change.\n\tip -6 route append 2001:db8:3::/64 metric 200 \\\n\t\tnexthop via 2001:db8:1::3 dev $spine_p1\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 2\n\tcheck_err $? \"lowest metric not offloaded after append\"\n\tipv6_offload_check \"2001:db8:3::/64 metric 200\" 0\n\tcheck_err $? \"highest metric offloaded when should not\"\n\n\t# Prepend a nexthop with a lower metric and check that it is offloaded\n\t# and the others are not.\n\tip -6 route append 2001:db8:3::/64 metric 10 \\\n\t\tnexthop via 2001:db8:1::3 dev $spine_p1\n\tipv6_offload_check \"2001:db8:3::/64 metric 10\" 1\n\tcheck_err $? \"lowest metric not offloaded after prepend\"\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 0\n\tcheck_err $? \"mid metric offloaded when should not\"\n\tipv6_offload_check \"2001:db8:3::/64 metric 200\" 0\n\tcheck_err $? \"highest metric offloaded when should not\"\n\n\tlog_test \"IPv6 multipath route add\"\n\n\tip -6 route flush 2001:db8:3::/64\n}\n\nipv6_route_add()\n{\n\tipv6_route_add_prefix\n\tipv6_route_add_mpath\n}\n\nipv6_route_replace()\n{\n\tRET=0\n\n\t# Replace prefix route with prefix route.\n\tip -6 route add 2001:db8:3::/64 metric 100 dev $spine_p1\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 1\n\tcheck_err $? \"prefix route not offloaded when should\"\n\tip -6 route replace 2001:db8:3::/64 metric 100 dev $spine_p2\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 1\n\tcheck_err $? \"prefix route not offloaded after replace\"\n\n\t# Replace prefix route with multipath route.\n\tip -6 route replace 2001:db8:3::/64 metric 100 \\\n\t\tnexthop via 2001:db8:1::2 dev $spine_p1 \\\n\t\tnexthop via 2001:db8:2::2 dev $spine_p2\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 2\n\tcheck_err $? \"multipath route not offloaded after replace\"\n\n\t# Replace multipath route with prefix route. A prefix route cannot\n\t# replace a multipath route, so it is appended.\n\tip -6 route replace 2001:db8:3::/64 metric 100 dev $spine_p1\n\tipv6_offload_check \"2001:db8:3::/64 metric 100 dev $spine_p1\" 0\n\tcheck_err $? \"prefix route offloaded after 'replacing' multipath route\"\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 2\n\tcheck_err $? \"multipath route not offloaded after being 'replaced' by prefix route\"\n\n\t# Replace multipath route with multipath route.\n\tip -6 route replace 2001:db8:3::/64 metric 100 \\\n\t\tnexthop via 2001:db8:1::3 dev $spine_p1 \\\n\t\tnexthop via 2001:db8:2::3 dev $spine_p2\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 2\n\tcheck_err $? \"multipath route not offloaded after replacing multipath route\"\n\n\t# Replace a non-existing multipath route with a multipath route and\n\t# check that it is appended and not offloaded.\n\tip -6 route replace 2001:db8:3::/64 metric 200 \\\n\t\tnexthop via 2001:db8:1::3 dev $spine_p1 \\\n\t\tnexthop via 2001:db8:2::3 dev $spine_p2\n\tipv6_offload_check \"2001:db8:3::/64 metric 100\" 2\n\tcheck_err $? \"multipath route not offloaded after non-existing route was 'replaced'\"\n\tipv6_offload_check \"2001:db8:3::/64 metric 200\" 0\n\tcheck_err $? \"multipath route offloaded after 'replacing' non-existing route\"\n\n\tlog_test \"IPv6 route replace\"\n\n\tip -6 route flush 2001:db8:3::/64\n}\n\nipv6_route_nexthop_group_share()\n{\n\tRET=0\n\n\t# The driver consolidates identical nexthop groups in order to reduce\n\t# the resource usage in its adjacency table. Check that the deletion\n\t# of one multipath route using the group does not affect the other.\n\tip -6 route add 2001:db8:3::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev $spine_p1 \\\n\t\tnexthop via 2001:db8:2::2 dev $spine_p2\n\tip -6 route add 2001:db8:4::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev $spine_p1 \\\n\t\tnexthop via 2001:db8:2::2 dev $spine_p2\n\tipv6_offload_check \"2001:db8:3::/64\" 2\n\tcheck_err $? \"multipath route not offloaded when should\"\n\tipv6_offload_check \"2001:db8:4::/64\" 2\n\tcheck_err $? \"multipath route not offloaded when should\"\n\tip -6 route del 2001:db8:3::/64\n\tipv6_offload_check \"2001:db8:4::/64\" 2\n\tcheck_err $? \"multipath route not offloaded after deletion of route sharing the nexthop group\"\n\n\t# Check that after unsharing a nexthop group the routes are still\n\t# marked as offloaded.\n\tip -6 route add 2001:db8:3::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev $spine_p1 \\\n\t\tnexthop via 2001:db8:2::2 dev $spine_p2\n\tip -6 route del 2001:db8:4::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev $spine_p1\n\tipv6_offload_check \"2001:db8:4::/64\" 1\n\tcheck_err $? \"singlepath route not offloaded after unsharing the nexthop group\"\n\tipv6_offload_check \"2001:db8:3::/64\" 2\n\tcheck_err $? \"multipath route not offloaded after unsharing the nexthop group\"\n\n\tlog_test \"IPv6 nexthop group sharing\"\n\n\tip -6 route flush 2001:db8:3::/64\n\tip -6 route flush 2001:db8:4::/64\n}\n\nipv6_route_rate()\n{\n\tlocal batch_dir=$(mktemp -d)\n\tlocal num_rts=$((40 * 1024))\n\tlocal num_nhs=16\n\tlocal total\n\tlocal start\n\tlocal diff\n\tlocal end\n\tlocal nhs\n\tlocal i\n\n\tRET=0\n\n\t# Prepare 40K /64 multipath routes with 16 nexthops each and check how\n\t# long it takes to add them. A limit of 60 seconds is set. It is much\n\t# higher than insertion should take and meant to flag a serious\n\t# regression.\n\ttotal=$((nums_nhs * num_rts))\n\n\tfor i in $(seq 1 $num_nhs); do\n\t\tip -6 address add 2001:db8:1::10:$i/128 dev $tor1_p1\n\t\tnexthops+=\" nexthop via 2001:db8:1::10:$i dev $spine_p1\"\n\tdone\n\n\tfor i in $(seq 1 $num_rts); do\n\t\techo \"route add 2001:db8:8:$(printf \"%x\" $i)::/64$nexthops\" \\\n\t\t\t>> $batch_dir/add.batch\n\t\techo \"route del 2001:db8:8:$(printf \"%x\" $i)::/64$nexthops\" \\\n\t\t\t>> $batch_dir/del.batch\n\tdone\n\n\tstart=$(date +%s.%N)\n\n\tip -batch $batch_dir/add.batch\n\tcount=$(ip -6 route show | grep offload | wc -l)\n\twhile [ $count -lt $total ]; do\n\t\tsleep .01\n\t\tcount=$(ip -6 route show | grep offload | wc -l)\n\tdone\n\n\tend=$(date +%s.%N)\n\n\tdiff=$(echo \"$end - $start\" | bc -l)\n\ttest \"$(echo \"$diff > 60\" | bc -l)\" -eq 0\n\tcheck_err $? \"route insertion took too long\"\n\tlog_info \"inserted $num_rts routes in $diff seconds\"\n\n\tlog_test \"IPv6 routes insertion rate\"\n\n\tip -batch $batch_dir/del.batch\n\tfor i in $(seq 1 $num_nhs); do\n\t\tip -6 address del 2001:db8:1::10:$i/128 dev $tor1_p1\n\tdone\n\trm -rf $batch_dir\n}\n\nsetup_prepare()\n{\n\tspine_p1=${NETIFS[p1]}\n\ttor1_p1=${NETIFS[p2]}\n\n\tspine_p2=${NETIFS[p3]}\n\ttor2_p1=${NETIFS[p4]}\n\n\tvrf_prepare\n\tforwarding_enable\n\n\ttor1_create\n\ttor2_create\n\tspine_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tspine_destroy\n\ttor2_destroy\n\ttor1_destroy\n\n\tforwarding_restore\n\tvrf_cleanup\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}