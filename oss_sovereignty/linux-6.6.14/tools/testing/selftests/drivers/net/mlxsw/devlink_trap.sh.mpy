{
  "module_name": "devlink_trap.sh",
  "hash_id": "e6f472df328b2e12a0b10f52d39588e45b26d9e9a6f7f3bcdeced968460e68bc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/devlink_trap.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test generic devlink-trap functionality over mlxsw. These tests are not\n# specific to a single trap, but do not check the devlink-trap common\n# infrastructure either.\n\nlib_dir=$(dirname $0)/../../../net/forwarding\n\nALL_TESTS=\"\n\tdev_del_test\n\"\nNUM_NETIFS=4\nsource $lib_dir/tc_common.sh\nsource $lib_dir/lib.sh\nsource $lib_dir/devlink_lib.sh\n\nh1_create()\n{\n\tsimple_if_init $h1\n}\n\nh1_destroy()\n{\n\tsimple_if_fini $h1\n}\n\nh2_create()\n{\n\tsimple_if_init $h2\n}\n\nh2_destroy()\n{\n\tsimple_if_fini $h2\n}\n\nswitch_create()\n{\n\tip link add dev br0 type bridge vlan_filtering 1 mcast_snooping 0\n\n\tip link set dev $swp1 master br0\n\tip link set dev $swp2 master br0\n\n\tip link set dev br0 up\n\tip link set dev $swp1 up\n\tip link set dev $swp2 up\n}\n\nswitch_destroy()\n{\n\tip link set dev $swp2 down\n\tip link set dev $swp1 down\n\n\tip link del dev br0\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\n\tswitch_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tswitch_destroy\n\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n}\n\ndev_del_test()\n{\n\tlocal trap_name=\"source_mac_is_multicast\"\n\tlocal smac=01:02:03:04:05:06\n\tlocal num_iter=5\n\tlocal mz_pid\n\tlocal i\n\n\t$MZ $h1 -c 0 -p 100 -a $smac -b bcast -t ip -q &\n\tmz_pid=$!\n\n\t# The purpose of this test is to make sure we correctly dismantle a\n\t# port while packets are trapped from it. This is done by reloading the\n\t# the driver while the 'ingress_smac_mc_drop' trap is triggered.\n\tRET=0\n\n\tfor i in $(seq 1 $num_iter); do\n\t\tlog_info \"Iteration $i / $num_iter\"\n\n\t\tdevlink_trap_action_set $trap_name \"trap\"\n\t\tsleep 1\n\n\t\tdevlink_reload\n\t\t# Allow netdevices to be re-created following the reload\n\t\tsleep 20\n\n\t\tcleanup\n\t\tsetup_prepare\n\t\tsetup_wait\n\tdone\n\n\tlog_test \"Device delete\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}