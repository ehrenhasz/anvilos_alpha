{
  "module_name": "vxlan_flooding_ipv6.sh",
  "hash_id": "caa0bf59fd6f4e121ec0dd04f1477d3651a2feef376d00b951a946992f3e8375",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/vxlan_flooding_ipv6.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test VxLAN flooding. The device stores flood records in a singly linked list\n# where each record stores up to four IPv6 addresses of remote VTEPs. The test\n# verifies that packets are correctly flooded in various cases such as deletion\n# of a record in the middle of the list.\n#\n# +-----------------------+\n# | H1 (vrf)              |\n# |    + $h1              |\n# |    | 2001:db8:1::1/64 |\n# +----|------------------+\n#      |\n# +----|----------------------------------------------------------------------+\n# | SW |                                                                      |\n# | +--|--------------------------------------------------------------------+ |\n# | |  + $swp1                   BR0 (802.1d)                               | |\n# | |                                                                       | |\n# | |  + vxlan0 (vxlan)                                                     | |\n# | |    local 2001:db8:2::1                                                | |\n# | |    remote 2001:db8:2::{2..17}                                         | |\n# | |    id 10 dstport 4789                                                 | |\n# | +-----------------------------------------------------------------------+ |\n# |                                                                           |\n# |  2001:db8:2::0/64 via 2001:db8:3::2                                       |\n# |                                                                           |\n# |    + $rp1                                                                 |\n# |    | 2001:db8:3::1/64                                                     |\n# +----|----------------------------------------------------------------------+\n#      |\n# +----|--------------------------------------------------------+\n# |    |                                               R2 (vrf) |\n# |    + $rp2                                                   |\n# |      2001:db8:3::2/64                                       |\n# |                                                             |\n# +-------------------------------------------------------------+\n\nlib_dir=$(dirname $0)/../../../../net/forwarding\n\nALL_TESTS=\"flooding_test\"\nNUM_NETIFS=4\nsource $lib_dir/tc_common.sh\nsource $lib_dir/lib.sh\n\nh1_create()\n{\n\tsimple_if_init $h1 2001:db8:1::1/64\n}\n\nh1_destroy()\n{\n\tsimple_if_fini $h1 2001:db8:1::1/64\n}\n\nswitch_create()\n{\n\t# Make sure the bridge uses the MAC address of the local port and\n\t# not that of the VxLAN's device\n\tip link add dev br0 type bridge mcast_snooping 0\n\tip link set dev br0 address $(mac_get $swp1)\n\n\tip link add name vxlan0 type vxlan id 10 nolearning \\\n\t\tudp6zerocsumrx udp6zerocsumtx ttl 20 tos inherit \\\n\t\tlocal 2001:db8:2::1 dstport 4789\n\n\tip address add 2001:db8:2::1/128 dev lo\n\n\tip link set dev $swp1 master br0\n\tip link set dev vxlan0 master br0\n\n\tip link set dev br0 up\n\tip link set dev $swp1 up\n\tip link set dev vxlan0 up\n}\n\nswitch_destroy()\n{\n\tip link set dev vxlan0 down\n\tip link set dev $swp1 down\n\tip link set dev br0 down\n\n\tip link set dev vxlan0 nomaster\n\tip link set dev $swp1 nomaster\n\n\tip address del 2001:db8:2::1/128 dev lo\n\n\tip link del dev vxlan0\n\n\tip link del dev br0\n}\n\nrouter1_create()\n{\n\t# This router is in the default VRF, where the VxLAN device is\n\t# performing the L3 lookup\n\tip link set dev $rp1 up\n\tip address add 2001:db8:3::1/64 dev $rp1\n\tip route add 2001:db8:2::0/64 via 2001:db8:3::2\n}\n\nrouter1_destroy()\n{\n\tip route del 2001:db8:2::0/64 via 2001:db8:3::2\n\tip address del 2001:db8:3::1/64 dev $rp1\n\tip link set dev $rp1 down\n}\n\nrouter2_create()\n{\n\t# This router is not in the default VRF, so use simple_if_init()\n\tsimple_if_init $rp2 2001:db8:3::2/64\n}\n\nrouter2_destroy()\n{\n\tsimple_if_fini $rp2 2001:db8:3::2/64\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\trp1=${NETIFS[p3]}\n\trp2=${NETIFS[p4]}\n\n\tvrf_prepare\n\n\th1_create\n\n\tswitch_create\n\n\trouter1_create\n\trouter2_create\n\n\tforwarding_enable\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tforwarding_restore\n\n\trouter2_destroy\n\trouter1_destroy\n\n\tswitch_destroy\n\n\th1_destroy\n\n\tvrf_cleanup\n}\n\nflooding_remotes_add()\n{\n\tlocal num_remotes=$1\n\tlocal lsb\n\tlocal i\n\n\t# Prevent unwanted packets from entering the bridge and interfering\n\t# with the test.\n\ttc qdisc add dev br0 clsact\n\ttc filter add dev br0 egress protocol all pref 1 handle 1 \\\n\t\tmatchall skip_hw action drop\n\ttc qdisc add dev $h1 clsact\n\ttc filter add dev $h1 egress protocol all pref 1 handle 1 \\\n\t\tflower skip_hw dst_mac de:ad:be:ef:13:37 action pass\n\ttc filter add dev $h1 egress protocol all pref 2 handle 2 \\\n\t\tmatchall skip_hw action drop\n\n\tfor i in $(eval echo {1..$num_remotes}); do\n\t\tlsb=$((i + 1))\n\n\t\tbridge fdb append 00:00:00:00:00:00 dev vxlan0 self \\\n\t\t\tdst 2001:db8:2::$lsb\n\tdone\n}\n\nflooding_filters_add()\n{\n\tlocal num_remotes=$1\n\tlocal lsb\n\tlocal i\n\n\ttc qdisc add dev $rp2 clsact\n\n\tfor i in $(eval echo {1..$num_remotes}); do\n\t\tlsb=$((i + 1))\n\n\t\ttc filter add dev $rp2 ingress protocol ipv6 pref $i handle $i \\\n\t\t\tflower ip_proto udp dst_ip 2001:db8:2::$lsb \\\n\t\t\tdst_port 4789 skip_sw action drop\n\tdone\n}\n\nflooding_filters_del()\n{\n\tlocal num_remotes=$1\n\tlocal i\n\n\tfor i in $(eval echo {1..$num_remotes}); do\n\t\ttc filter del dev $rp2 ingress protocol ipv6 pref $i \\\n\t\t\thandle $i flower\n\tdone\n\n\ttc qdisc del dev $rp2 clsact\n\n\ttc filter del dev $h1 egress protocol all pref 2 handle 2 matchall\n\ttc filter del dev $h1 egress protocol all pref 1 handle 1 flower\n\ttc qdisc del dev $h1 clsact\n\ttc filter del dev br0 egress protocol all pref 1 handle 1 matchall\n\ttc qdisc del dev br0 clsact\n}\n\nflooding_check_packets()\n{\n\tlocal packets=(\"$@\")\n\tlocal num_remotes=${#packets[@]}\n\tlocal i\n\n\tfor i in $(eval echo {1..$num_remotes}); do\n\t\ttc_check_packets \"dev $rp2 ingress\" $i ${packets[i - 1]}\n\t\tcheck_err $? \"remote $i - did not get expected number of packets\"\n\tdone\n}\n\nflooding_test()\n{\n\t# Use 16 remote VTEPs that will be stored in 4 records. The array\n\t# 'packets' will store how many packets are expected to be received\n\t# by each remote VTEP at each stage of the test\n\tdeclare -a packets=(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n\tlocal num_remotes=16\n\n\tRET=0\n\n\t# Add FDB entries for remote VTEPs and corresponding tc filters on the\n\t# ingress of the nexthop router. These filters will count how many\n\t# packets were flooded to each remote VTEP\n\tflooding_remotes_add $num_remotes\n\tflooding_filters_add $num_remotes\n\n\t# Send one packet and make sure it is flooded to all the remote VTEPs\n\t$MZ $h1 -q -p 64 -b de:ad:be:ef:13:37 -t ip -c 1\n\tflooding_check_packets \"${packets[@]}\"\n\tlog_test \"flood after 1 packet\"\n\n\t# Delete the third record which corresponds to VTEPs with LSB 10..13\n\t# and check that packet is flooded correctly when we remove a record\n\t# from the middle of the list\n\tRET=0\n\n\tpackets=(2 2 2 2 2 2 2 2 1 1 1 1 2 2 2 2)\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::10\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::11\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::12\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::13\n\n\t$MZ $h1 -q -p 64 -b de:ad:be:ef:13:37 -t ip -c 1\n\tflooding_check_packets \"${packets[@]}\"\n\tlog_test \"flood after 2 packets\"\n\n\t# Delete the first record and make sure the packet is flooded correctly\n\tRET=0\n\n\tpackets=(2 2 2 2 3 3 3 3 1 1 1 1 3 3 3 3)\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::2\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::3\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::4\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::5\n\n\t$MZ $h1 -q -p 64 -b de:ad:be:ef:13:37 -t ip -c 1\n\tflooding_check_packets \"${packets[@]}\"\n\tlog_test \"flood after 3 packets\"\n\n\t# Delete the last record and make sure the packet is flooded correctly\n\tRET=0\n\n\tpackets=(2 2 2 2 4 4 4 4 1 1 1 1 3 3 3 3)\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::14\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::15\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::16\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::17\n\n\t$MZ -6 $h1 -q -p 64 -b de:ad:be:ef:13:37 -t ip -c 1\n\tflooding_check_packets \"${packets[@]}\"\n\tlog_test \"flood after 4 packets\"\n\n\t# Delete the last record, one entry at a time and make sure single\n\t# entries are correctly removed\n\tRET=0\n\n\tpackets=(2 2 2 2 4 5 5 5 1 1 1 1 3 3 3 3)\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::6\n\n\t$MZ -6 $h1 -q -p 64 -b de:ad:be:ef:13:37 -t ip -c 1\n\tflooding_check_packets \"${packets[@]}\"\n\tlog_test \"flood after 5 packets\"\n\n\tRET=0\n\n\tpackets=(2 2 2 2 4 5 6 6 1 1 1 1 3 3 3 3)\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::7\n\n\t$MZ -6 $h1 -q -p 64 -b de:ad:be:ef:13:37 -t ip -c 1\n\tflooding_check_packets \"${packets[@]}\"\n\tlog_test \"flood after 6 packets\"\n\n\tRET=0\n\n\tpackets=(2 2 2 2 4 5 6 7 1 1 1 1 3 3 3 3)\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::8\n\n\t$MZ -6 $h1 -q -p 64 -b de:ad:be:ef:13:37 -t ip -c 1\n\tflooding_check_packets \"${packets[@]}\"\n\tlog_test \"flood after 7 packets\"\n\n\tRET=0\n\n\tpackets=(2 2 2 2 4 5 6 7 1 1 1 1 3 3 3 3)\n\tbridge fdb del 00:00:00:00:00:00 dev vxlan0 self dst 2001:db8:2::9\n\n\t$MZ -6 $h1 -q -p 64 -b de:ad:be:ef:13:37 -t ip -c 1\n\tflooding_check_packets \"${packets[@]}\"\n\tlog_test \"flood after 8 packets\"\n\n\tflooding_filters_del $num_remotes\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}