{
  "module_name": "tc_flower_scale.sh",
  "hash_id": "a5d6bba01ff5cee2241bdab4629e912321328d85648952872186db9b9da50a44",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/tc_flower_scale.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# Test for resource limit of offloaded flower rules. The test adds a given\n# number of flower matches for different IPv6 addresses, then check the offload\n# indication for all of the tc flower rules. This file contains functions to set\n# up a testing topology and run the test, and is meant to be sourced from a test\n# script that calls the testing routine with a given number of rules.\n\nTC_FLOWER_NUM_NETIFS=2\n\ntc_flower_h1_create()\n{\n\tsimple_if_init $h1\n\ttc qdisc add dev $h1 clsact\n}\n\ntc_flower_h1_destroy()\n{\n\ttc qdisc del dev $h1 clsact\n\tsimple_if_fini $h1\n}\n\ntc_flower_h2_create()\n{\n\tsimple_if_init $h2\n\ttc qdisc add dev $h2 clsact\n}\n\ntc_flower_h2_destroy()\n{\n\ttc qdisc del dev $h2 clsact\n\tsimple_if_fini $h2\n}\n\ntc_flower_setup_prepare()\n{\n\th1=${NETIFS[p1]}\n\th2=${NETIFS[p2]}\n\n\tvrf_prepare\n\n\ttc_flower_h1_create\n\ttc_flower_h2_create\n}\n\ntc_flower_cleanup()\n{\n\tpre_cleanup\n\n\ttc_flower_h2_destroy\n\ttc_flower_h1_destroy\n\n\tvrf_cleanup\n\n\tif [[ -v TC_FLOWER_BATCH_FILE ]]; then\n\t\trm -f $TC_FLOWER_BATCH_FILE\n\tfi\n}\n\ntc_flower_addr()\n{\n\tlocal num=$1; shift\n\n\tprintf \"2001:db8:1::%x\" $num\n}\n\ntc_flower_rules_create()\n{\n\tlocal count=$1; shift\n\tlocal should_fail=$1; shift\n\n\tTC_FLOWER_BATCH_FILE=\"$(mktemp)\"\n\n\tfor ((i = 0; i < count; ++i)); do\n\t\tcat >> $TC_FLOWER_BATCH_FILE <<-EOF\n\t\t\tfilter add dev $h2 ingress \\\n\t\t\t\tprot ipv6 \\\n\t\t\t\tpref 1000 \\\n\t\t\t\thandle 42$i \\\n\t\t\t\tflower $tcflags dst_ip $(tc_flower_addr $i) \\\n\t\t\t\taction drop\n\t\tEOF\n\tdone\n\n\ttc -b $TC_FLOWER_BATCH_FILE\n\tcheck_err_fail $should_fail $? \"Rule insertion\"\n}\n\n__tc_flower_test()\n{\n\tlocal count=$1; shift\n\tlocal should_fail=$1; shift\n\tlocal last=$((count - 1))\n\n\ttc_flower_rules_create $count $should_fail\n\n\toffload_count=$(tc -j -s filter show dev $h2 ingress    |\n\t\t\tjq -r '[ .[] | select(.kind == \"flower\") |\n\t\t\t.options | .in_hw ]' | jq .[] | wc -l)\n\t[[ $((offload_count - 1)) -eq $count ]]\n\tcheck_err_fail $should_fail $? \"Attempt to offload $count rules (actual result $((offload_count - 1)))\"\n}\n\ntc_flower_test()\n{\n\tlocal count=$1; shift\n\tlocal should_fail=$1; shift\n\n\t# We use lower 16 bits of IPv6 address for match. Also there are only 16\n\t# bits of rule priority space.\n\tif ((count > 65536)); then\n\t\tcheck_err 1 \"Invalid count of $count. At most 65536 rules supported\"\n\t\treturn\n\tfi\n\n\tif ! tc_offload_check $TC_FLOWER_NUM_NETIFS; then\n\t\tcheck_err 1 \"Could not test offloaded functionality\"\n\t\treturn\n\tfi\n\n\ttcflags=\"skip_sw\"\n\t__tc_flower_test $count $should_fail\n}\n\ntc_flower_traffic_test()\n{\n\tlocal count=$1; shift\n\tlocal i;\n\n\tfor ((i = count - 1; i > 0; i /= 2)); do\n\t\t$MZ -6 $h1 -c 1 -d 20msec -p 100 -a own -b $(mac_get $h2) \\\n\t\t    -A $(tc_flower_addr 0) -B $(tc_flower_addr $i) \\\n\t\t    -q -t udp sp=54321,dp=12345\n\tdone\n\tfor ((i = count - 1; i > 0; i /= 2)); do\n\t\ttc_check_packets \"dev $h2 ingress\" 42$i 1\n\t\tcheck_err $? \"Traffic not seen at rule #$i\"\n\tdone\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}