{
  "module_name": "sch_red_core.sh",
  "hash_id": "0115b9c8a3ae9a4815e4b273b92185f2650c0c5c9cc5e7d10358d1e621009a95",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/sch_red_core.sh",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n\n# This test sends a >1Gbps stream of traffic from H1, to the switch, which\n# forwards it to a 1Gbps port. This 1Gbps stream is then looped back to the\n# switch and forwarded to the port under test $swp3, which is also 1Gbps.\n#\n# This way, $swp3 should be 100% filled with traffic without any of it spilling\n# to the backlog. Any extra packets sent should almost 1:1 go to backlog. That\n# is what H2 is used for--it sends the extra traffic to create backlog.\n#\n# A RED Qdisc is installed on $swp3. The configuration is such that the minimum\n# and maximum size are 1 byte apart, so there is a very clear border under which\n# no marking or dropping takes place, and above which everything is marked or\n# dropped.\n#\n# The test uses the buffer build-up behavior to test the installed RED.\n#\n# In order to test WRED, $swp3 actually contains RED under PRIO, with two\n# different configurations. Traffic is prioritized using 802.1p and relies on\n# the implicit mlxsw configuration, where packet priority is taken 1:1 from the\n# 802.1p marking.\n#\n# +--------------------------+                     +--------------------------+\n# | H1                       |                     | H2                       |\n# |     + $h1.10             |                     |     + $h2.10             |\n# |     | 192.0.2.1/28       |                     |     | 192.0.2.2/28       |\n# |     |                    |                     |     |                    |\n# |     |         $h1.11 +   |                     |     |         $h2.11 +   |\n# |     |  192.0.2.17/28 |   |                     |     |  192.0.2.18/28 |   |\n# |     |                |   |                     |     |                |   |\n# |     \\______    ______/   |                     |     \\______    ______/   |\n# |            \\ /           |                     |            \\ /           |\n# |             + $h1        |                     |             + $h2        |\n# +-------------|------------+                     +-------------|------------+\n#               | >1Gbps                                         |\n# +-------------|------------------------------------------------|------------+\n# | SW          + $swp1                                          + $swp2      |\n# |     _______/ \\___________                        ___________/ \\_______    |\n# |    /                     \\                      /                     \\   |\n# |  +-|-----------------+   |                    +-|-----------------+   |   |\n# |  | + $swp1.10        |   |                    | + $swp2.10        |   |   |\n# |  |                   |   |        .-------------+ $swp5.10        |   |   |\n# |  |     BR1_10        |   |        |           |                   |   |   |\n# |  |                   |   |        |           |     BR2_10        |   |   |\n# |  | + $swp2.10        |   |        |           |                   |   |   |\n# |  +-|-----------------+   |        |           | + $swp3.10        |   |   |\n# |    |                     |        |           +-|-----------------+   |   |\n# |    |   +-----------------|-+      |             |   +-----------------|-+ |\n# |    |   |        $swp1.11 + |      |             |   |        $swp2.11 + | |\n# |    |   |                   |      | .-----------------+ $swp5.11        | |\n# |    |   |      BR1_11       |      | |           |   |                   | |\n# |    |   |                   |      | |           |   |      BR2_11       | |\n# |    |   |        $swp2.11 + |      | |           |   |                   | |\n# |    |   +-----------------|-+      | |           |   |        $swp3.11 + | |\n# |    |                     |        | |           |   +-----------------|-+ |\n# |    \\_______   ___________/        | |           \\___________   _______/   |\n# |            \\ /                    \\ /                       \\ /           |\n# |             + $swp4                + $swp5                   + $swp3      |\n# +-------------|----------------------|-------------------------|------------+\n#               |                      |                         | 1Gbps\n#               \\________1Gbps_________/                         |\n#                                   +----------------------------|------------+\n#                                   | H3                         + $h3        |\n#                                   |      _____________________/ \\_______    |\n#                                   |     /                               \\   |\n#                                   |     |                               |   |\n#                                   |     + $h3.10                 $h3.11 +   |\n#                                   |       192.0.2.3/28    192.0.2.19/28     |\n#                                   +-----------------------------------------+\n\nNUM_NETIFS=8\nCHECK_TC=\"yes\"\nlib_dir=$(dirname $0)/../../../net/forwarding\nsource $lib_dir/lib.sh\nsource $lib_dir/devlink_lib.sh\nsource mlxsw_lib.sh\n\nipaddr()\n{\n\tlocal host=$1; shift\n\tlocal vlan=$1; shift\n\n\techo 192.0.2.$((16 * (vlan - 10) + host))\n}\n\nhost_create()\n{\n\tlocal dev=$1; shift\n\tlocal host=$1; shift\n\n\tsimple_if_init $dev\n\tmtu_set $dev 10000\n\n\tvlan_create $dev 10 v$dev $(ipaddr $host 10)/28\n\tip link set dev $dev.10 type vlan egress 0:0\n\n\tvlan_create $dev 11 v$dev $(ipaddr $host 11)/28\n\tip link set dev $dev.11 type vlan egress 0:1\n}\n\nhost_destroy()\n{\n\tlocal dev=$1; shift\n\n\tvlan_destroy $dev 11\n\tvlan_destroy $dev 10\n\tmtu_restore $dev\n\tsimple_if_fini $dev\n}\n\nh1_create()\n{\n\thost_create $h1 1\n}\n\nh1_destroy()\n{\n\thost_destroy $h1\n}\n\nh2_create()\n{\n\thost_create $h2 2\n\ttc qdisc add dev $h2 clsact\n\n\t# Some of the tests in this suite use multicast traffic. As this traffic\n\t# enters BR2_10 resp. BR2_11, it is flooded to all other ports. Thus\n\t# e.g. traffic ingressing through $swp2 is flooded to $swp3 (the\n\t# intended destination) and $swp5 (which is intended as ingress for\n\t# another stream of traffic).\n\t#\n\t# This is generally not a problem, but if the $swp5 throughput is lower\n\t# than $swp2 throughput, there will be a build-up at $swp5. That may\n\t# cause packets to fail to queue up at $swp3 due to shared buffer\n\t# quotas, and the test to spuriously fail.\n\t#\n\t# Prevent this by adding a shaper which limits the traffic in $h2 to\n\t# 1Gbps.\n\n\ttc qdisc replace dev $h2 root handle 10: tbf rate 1gbit \\\n\t\tburst 128K limit 1G\n}\n\nh2_destroy()\n{\n\ttc qdisc del dev $h2 root handle 10:\n\ttc qdisc del dev $h2 clsact\n\thost_destroy $h2\n}\n\nh3_create()\n{\n\thost_create $h3 3\n}\n\nh3_destroy()\n{\n\thost_destroy $h3\n}\n\nswitch_create()\n{\n\tlocal intf\n\tlocal vlan\n\n\tip link add dev br1_10 type bridge\n\tip link add dev br1_11 type bridge\n\n\tip link add dev br2_10 type bridge\n\tip link add dev br2_11 type bridge\n\n\tfor intf in $swp1 $swp2 $swp3 $swp4 $swp5; do\n\t\tip link set dev $intf up\n\t\tmtu_set $intf 10000\n\tdone\n\n\tfor intf in $swp1 $swp4; do\n\t\tfor vlan in 10 11; do\n\t\t\tvlan_create $intf $vlan\n\t\t\tip link set dev $intf.$vlan master br1_$vlan\n\t\t\tip link set dev $intf.$vlan up\n\t\tdone\n\tdone\n\n\tfor intf in $swp2 $swp3 $swp5; do\n\t\tfor vlan in 10 11; do\n\t\t\tvlan_create $intf $vlan\n\t\t\tip link set dev $intf.$vlan master br2_$vlan\n\t\t\tip link set dev $intf.$vlan up\n\t\tdone\n\tdone\n\n\tip link set dev $swp4.10 type vlan egress 0:0\n\tip link set dev $swp4.11 type vlan egress 0:1\n\tfor intf in $swp1 $swp2 $swp5; do\n\t\tfor vlan in 10 11; do\n\t\t\tip link set dev $intf.$vlan type vlan ingress 0:0 1:1\n\t\tdone\n\tdone\n\n\tfor intf in $swp3 $swp4; do\n\t\ttc qdisc replace dev $intf root handle 1: tbf rate 1gbit \\\n\t\t\tburst 128K limit 1G\n\tdone\n\n\tip link set dev br1_10 up\n\tip link set dev br1_11 up\n\tip link set dev br2_10 up\n\tip link set dev br2_11 up\n\n\tlocal size=$(devlink_pool_size_thtype 0 | cut -d' ' -f 1)\n\tdevlink_port_pool_th_save $swp3 8\n\tdevlink_port_pool_th_set $swp3 8 $size\n}\n\nswitch_destroy()\n{\n\tlocal intf\n\tlocal vlan\n\n\tdevlink_port_pool_th_restore $swp3 8\n\n\tip link set dev br2_11 down\n\tip link set dev br2_10 down\n\tip link set dev br1_11 down\n\tip link set dev br1_10 down\n\n\tfor intf in $swp4 $swp3; do\n\t\ttc qdisc del dev $intf root handle 1:\n\tdone\n\n\tfor intf in $swp5 $swp3 $swp2 $swp4 $swp1; do\n\t\tfor vlan in 11 10; do\n\t\t\tip link set dev $intf.$vlan down\n\t\t\tip link set dev $intf.$vlan nomaster\n\t\t\tvlan_destroy $intf $vlan\n\t\tdone\n\n\t\tmtu_restore $intf\n\t\tip link set dev $intf down\n\tdone\n\n\tip link del dev br2_11\n\tip link del dev br2_10\n\tip link del dev br1_11\n\tip link del dev br1_10\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\tswp3=${NETIFS[p5]}\n\th3=${NETIFS[p6]}\n\n\tswp4=${NETIFS[p7]}\n\tswp5=${NETIFS[p8]}\n\n\th3_mac=$(mac_get $h3)\n\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\th3_create\n\tswitch_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tswitch_destroy\n\th3_destroy\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n}\n\nping_ipv4()\n{\n\tping_test $h1.10 $(ipaddr 3 10) \" from host 1, vlan 10\"\n\tping_test $h1.11 $(ipaddr 3 11) \" from host 1, vlan 11\"\n\tping_test $h2.10 $(ipaddr 3 10) \" from host 2, vlan 10\"\n\tping_test $h2.11 $(ipaddr 3 11) \" from host 2, vlan 11\"\n}\n\nget_tc()\n{\n\tlocal vlan=$1; shift\n\n\techo $((vlan - 10))\n}\n\nget_qdisc_handle()\n{\n\tlocal vlan=$1; shift\n\n\tlocal tc=$(get_tc $vlan)\n\tlocal band=$((8 - tc))\n\n\t# Handle is 107: for TC1, 108: for TC0.\n\techo \"10$band:\"\n}\n\nget_qdisc_backlog()\n{\n\tlocal vlan=$1; shift\n\n\tqdisc_stats_get $swp3 $(get_qdisc_handle $vlan) .backlog\n}\n\nget_mc_transmit_queue()\n{\n\tlocal vlan=$1; shift\n\n\tlocal tc=$(($(get_tc $vlan) + 8))\n\tethtool_stats_get $swp3 tc_transmit_queue_tc_$tc\n}\n\nget_nmarked()\n{\n\tlocal vlan=$1; shift\n\n\tethtool_stats_get $swp3 ecn_marked\n}\n\nget_qdisc_nmarked()\n{\n\tlocal vlan=$1; shift\n\n\tbusywait_for_counter 1100 +1 \\\n\t\tqdisc_stats_get $swp3 $(get_qdisc_handle $vlan) .marked\n}\n\nget_qdisc_npackets()\n{\n\tlocal vlan=$1; shift\n\n\tbusywait_for_counter 1100 +1 \\\n\t\tqdisc_stats_get $swp3 $(get_qdisc_handle $vlan) .packets\n}\n\nsend_packets()\n{\n\tlocal vlan=$1; shift\n\tlocal proto=$1; shift\n\tlocal pkts=$1; shift\n\n\t$MZ $h2.$vlan -p 8000 -a own -b $h3_mac \\\n\t    -A $(ipaddr 2 $vlan) -B $(ipaddr 3 $vlan) \\\n\t    -t $proto -q -c $pkts \"$@\"\n}\n\n# This sends traffic in an attempt to build a backlog of $size. Returns 0 on\n# success. After 10 failed attempts it bails out and returns 1. It dumps the\n# backlog size to stdout.\nbuild_backlog()\n{\n\tlocal vlan=$1; shift\n\tlocal size=$1; shift\n\tlocal proto=$1; shift\n\n\tlocal tc=$((vlan - 10))\n\tlocal band=$((8 - tc))\n\tlocal cur=-1\n\tlocal i=0\n\n\twhile :; do\n\t\tlocal cur=$(busywait 1100 until_counter_is \"> $cur\" \\\n\t\t\t\t\t    get_qdisc_backlog $vlan)\n\t\tlocal diff=$((size - cur))\n\t\tlocal pkts=$(((diff + 7999) / 8000))\n\n\t\tif ((cur >= size)); then\n\t\t\techo $cur\n\t\t\treturn 0\n\t\telif ((i++ > 10)); then\n\t\t\techo $cur\n\t\t\treturn 1\n\t\tfi\n\n\t\tsend_packets $vlan $proto $pkts \"$@\"\n\tdone\n}\n\ncheck_marking()\n{\n\tlocal get_nmarked=$1; shift\n\tlocal vlan=$1; shift\n\tlocal cond=$1; shift\n\n\tlocal npackets_0=$(get_qdisc_npackets $vlan)\n\tlocal nmarked_0=$($get_nmarked $vlan)\n\tsleep 5\n\tlocal npackets_1=$(get_qdisc_npackets $vlan)\n\tlocal nmarked_1=$($get_nmarked $vlan)\n\n\tlocal nmarked_d=$((nmarked_1 - nmarked_0))\n\tlocal npackets_d=$((npackets_1 - npackets_0))\n\tlocal pct=$((100 * nmarked_d / npackets_d))\n\n\techo $pct\n\t((pct $cond))\n}\n\necn_test_common()\n{\n\tlocal name=$1; shift\n\tlocal get_nmarked=$1; shift\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\tlocal backlog\n\tlocal pct\n\n\t# Build the below-the-limit backlog using UDP. We could use TCP just\n\t# fine, but this way we get a proof that UDP is accepted when queue\n\t# length is below the limit. The main stream is using TCP, and if the\n\t# limit is misconfigured, we would see this traffic being ECN marked.\n\tRET=0\n\tbacklog=$(build_backlog $vlan $((2 * limit / 3)) udp)\n\tcheck_err $? \"Could not build the requested backlog\"\n\tpct=$(check_marking \"$get_nmarked\" $vlan \"== 0\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% marked packets, expected == 0.\"\n\tlog_test \"TC $((vlan - 10)): $name backlog < limit\"\n\n\t# Now push TCP, because non-TCP traffic would be early-dropped after the\n\t# backlog crosses the limit, and we want to make sure that the backlog\n\t# is above the limit.\n\tRET=0\n\tbacklog=$(build_backlog $vlan $((3 * limit / 2)) tcp tos=0x01)\n\tcheck_err $? \"Could not build the requested backlog\"\n\tpct=$(check_marking \"$get_nmarked\" $vlan \">= 95\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% marked packets, expected >= 95.\"\n\tlog_test \"TC $((vlan - 10)): $name backlog > limit\"\n}\n\n__do_ecn_test()\n{\n\tlocal get_nmarked=$1; shift\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\tlocal name=${1-ECN}; shift\n\n\tstart_tcp_traffic $h1.$vlan $(ipaddr 1 $vlan) $(ipaddr 3 $vlan) \\\n\t\t\t  $h3_mac tos=0x01\n\tsleep 1\n\n\tecn_test_common \"$name\" \"$get_nmarked\" $vlan $limit\n\n\t# Up there we saw that UDP gets accepted when backlog is below the\n\t# limit. Now that it is above, it should all get dropped, and backlog\n\t# building should fail.\n\tRET=0\n\tbuild_backlog $vlan $((2 * limit)) udp >/dev/null\n\tcheck_fail $? \"UDP traffic went into backlog instead of being early-dropped\"\n\tlog_test \"TC $((vlan - 10)): $name backlog > limit: UDP early-dropped\"\n\n\tstop_traffic\n\tsleep 1\n}\n\ndo_ecn_test()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\n\t__do_ecn_test get_nmarked \"$vlan\" \"$limit\"\n}\n\ndo_ecn_test_perband()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\n\tmlxsw_only_on_spectrum 3+ || return\n\t__do_ecn_test get_qdisc_nmarked \"$vlan\" \"$limit\" \"per-band ECN\"\n}\n\ndo_ecn_nodrop_test()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\tlocal name=\"ECN nodrop\"\n\n\tstart_tcp_traffic $h1.$vlan $(ipaddr 1 $vlan) $(ipaddr 3 $vlan) \\\n\t\t\t  $h3_mac tos=0x01\n\tsleep 1\n\n\tecn_test_common \"$name\" get_nmarked $vlan $limit\n\n\t# Up there we saw that UDP gets accepted when backlog is below the\n\t# limit. Now that it is above, in nodrop mode, make sure it goes to\n\t# backlog as well.\n\tRET=0\n\tbuild_backlog $vlan $((2 * limit)) udp >/dev/null\n\tcheck_err $? \"UDP traffic was early-dropped instead of getting into backlog\"\n\tlog_test \"TC $((vlan - 10)): $name backlog > limit: UDP not dropped\"\n\n\tstop_traffic\n\tsleep 1\n}\n\ndo_red_test()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\tlocal backlog\n\tlocal pct\n\n\t# Use ECN-capable TCP to verify there's no marking even though the queue\n\t# is above limit.\n\tstart_tcp_traffic $h1.$vlan $(ipaddr 1 $vlan) $(ipaddr 3 $vlan) \\\n\t\t\t  $h3_mac tos=0x01\n\n\t# Pushing below the queue limit should work.\n\tRET=0\n\tbacklog=$(build_backlog $vlan $((2 * limit / 3)) tcp tos=0x01)\n\tcheck_err $? \"Could not build the requested backlog\"\n\tpct=$(check_marking get_nmarked $vlan \"== 0\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% marked packets, expected == 0.\"\n\tlog_test \"TC $((vlan - 10)): RED backlog < limit\"\n\n\t# Pushing above should not.\n\tRET=0\n\tbacklog=$(build_backlog $vlan $((3 * limit / 2)) tcp tos=0x01)\n\tcheck_fail $? \"Traffic went into backlog instead of being early-dropped\"\n\tpct=$(check_marking get_nmarked $vlan \"== 0\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% marked packets, expected == 0.\"\n\tlocal diff=$((limit - backlog))\n\tpct=$((100 * diff / limit))\n\t((-10 <= pct && pct <= 10))\n\tcheck_err $? \"backlog $backlog / $limit expected <= 10% distance\"\n\tlog_test \"TC $((vlan - 10)): RED backlog > limit\"\n\n\tstop_traffic\n\tsleep 1\n}\n\ndo_mc_backlog_test()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\tlocal backlog\n\tlocal pct\n\n\tRET=0\n\n\tstart_tcp_traffic $h1.$vlan $(ipaddr 1 $vlan) $(ipaddr 3 $vlan) bc\n\tstart_tcp_traffic $h2.$vlan $(ipaddr 2 $vlan) $(ipaddr 3 $vlan) bc\n\n\tqbl=$(busywait 5000 until_counter_is \">= 500000\" \\\n\t\t       get_qdisc_backlog $vlan)\n\tcheck_err $? \"Could not build MC backlog\"\n\n\t# Verify that we actually see the backlog on BUM TC. Do a busywait as\n\t# well, performance blips might cause false fail.\n\tlocal ebl\n\tebl=$(busywait 5000 until_counter_is \">= 500000\" \\\n\t\t       get_mc_transmit_queue $vlan)\n\tcheck_err $? \"MC backlog reported by qdisc not visible in ethtool\"\n\n\tstop_traffic\n\tstop_traffic\n\n\tlog_test \"TC $((vlan - 10)): Qdisc reports MC backlog\"\n}\n\ndo_mark_test()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\tlocal subtest=$1; shift\n\tlocal fetch_counter=$1; shift\n\tlocal should_fail=$1; shift\n\tlocal base\n\n\tmlxsw_only_on_spectrum 2+ || return\n\n\tRET=0\n\n\tstart_tcp_traffic $h1.$vlan $(ipaddr 1 $vlan) $(ipaddr 3 $vlan) \\\n\t\t\t  $h3_mac tos=0x01\n\n\t# Create a bit of a backlog and observe no mirroring due to marks.\n\tqevent_rule_install_$subtest\n\n\tbuild_backlog $vlan $((2 * limit / 3)) tcp tos=0x01 >/dev/null\n\n\tbase=$($fetch_counter)\n\tcount=$(busywait 1100 until_counter_is \">= $((base + 1))\" \\\n\t\t$fetch_counter)\n\tcheck_fail $? \"Spurious packets ($base -> $count) observed without buffer pressure\"\n\n\t# Above limit, everything should be mirrored, we should see lots of\n\t# packets.\n\tbuild_backlog $vlan $((3 * limit / 2)) tcp tos=0x01 >/dev/null\n\tbusywait_for_counter 1100 +10000 \\\n\t\t $fetch_counter > /dev/null\n\tcheck_err_fail \"$should_fail\" $? \"ECN-marked packets $subtest'd\"\n\n\t# When the rule is uninstalled, there should be no mirroring.\n\tqevent_rule_uninstall_$subtest\n\tbusywait_for_counter 1100 +10 \\\n\t\t $fetch_counter > /dev/null\n\tcheck_fail $? \"Spurious packets observed after uninstall\"\n\n\tif ((should_fail)); then\n\t\tlog_test \"TC $((vlan - 10)): marked packets not $subtest'd\"\n\telse\n\t\tlog_test \"TC $((vlan - 10)): marked packets $subtest'd\"\n\tfi\n\n\tstop_traffic\n\tsleep 1\n}\n\ndo_drop_test()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\tlocal trigger=$1; shift\n\tlocal subtest=$1; shift\n\tlocal fetch_counter=$1; shift\n\tlocal base\n\tlocal now\n\n\tmlxsw_only_on_spectrum 2+ || return\n\n\tRET=0\n\n\tstart_traffic $h1.$vlan $(ipaddr 1 $vlan) $(ipaddr 3 $vlan) $h3_mac\n\n\t# Create a bit of a backlog and observe no mirroring due to drops.\n\tqevent_rule_install_$subtest\n\tbase=$($fetch_counter)\n\n\tbuild_backlog $vlan $((2 * limit / 3)) udp >/dev/null\n\n\tbusywait 1100 until_counter_is \">= $((base + 1))\" $fetch_counter >/dev/null\n\tcheck_fail $? \"Spurious packets observed without buffer pressure\"\n\n\t# Push to the queue until it's at the limit. The configured limit is\n\t# rounded by the qdisc and then by the driver, so this is the best we\n\t# can do to get to the real limit of the system.\n\tbuild_backlog $vlan $((3 * limit / 2)) udp >/dev/null\n\n\tbase=$($fetch_counter)\n\tsend_packets $vlan udp 11\n\n\tnow=$(busywait 1100 until_counter_is \">= $((base + 10))\" $fetch_counter)\n\tcheck_err $? \"Dropped packets not observed: 11 expected, $((now - base)) seen\"\n\n\t# When no extra traffic is injected, there should be no mirroring.\n\tbusywait 1100 until_counter_is \">= $((base + 20))\" $fetch_counter >/dev/null\n\tcheck_fail $? \"Spurious packets observed\"\n\n\t# When the rule is uninstalled, there should be no mirroring.\n\tqevent_rule_uninstall_$subtest\n\tsend_packets $vlan udp 11\n\tbusywait 1100 until_counter_is \">= $((base + 20))\" $fetch_counter >/dev/null\n\tcheck_fail $? \"Spurious packets observed after uninstall\"\n\n\tlog_test \"TC $((vlan - 10)): ${trigger}ped packets $subtest'd\"\n\n\tstop_traffic\n\tsleep 1\n}\n\nqevent_rule_install_mirror()\n{\n\ttc filter add block 10 pref 1234 handle 102 matchall skip_sw \\\n\t   action mirred egress mirror dev $swp2 hw_stats disabled\n}\n\nqevent_rule_uninstall_mirror()\n{\n\ttc filter del block 10 pref 1234 handle 102 matchall\n}\n\nqevent_counter_fetch_mirror()\n{\n\ttc_rule_handle_stats_get \"dev $h2 ingress\" 101\n}\n\ndo_drop_mirror_test()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\tlocal qevent_name=$1; shift\n\n\ttc filter add dev $h2 ingress pref 1 handle 101 prot ip \\\n\t   flower skip_sw ip_proto udp \\\n\t   action drop\n\n\tdo_drop_test \"$vlan\" \"$limit\" \"$qevent_name\" mirror \\\n\t\t     qevent_counter_fetch_mirror\n\n\ttc filter del dev $h2 ingress pref 1 handle 101 flower\n}\n\ndo_mark_mirror_test()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\n\ttc filter add dev $h2 ingress pref 1 handle 101 prot ip \\\n\t   flower skip_sw ip_proto tcp \\\n\t   action drop\n\n\tdo_mark_test \"$vlan\" \"$limit\" mirror \\\n\t\t     qevent_counter_fetch_mirror \\\n\t\t     $(: should_fail=)0\n\n\ttc filter del dev $h2 ingress pref 1 handle 101 flower\n}\n\nqevent_rule_install_trap()\n{\n\ttc filter add block 10 pref 1234 handle 102 matchall skip_sw \\\n\t   action trap hw_stats disabled\n}\n\nqevent_rule_uninstall_trap()\n{\n\ttc filter del block 10 pref 1234 handle 102 matchall\n}\n\nqevent_counter_fetch_trap()\n{\n\tlocal trap_name=$1; shift\n\n\tdevlink_trap_rx_packets_get \"$trap_name\"\n}\n\ndo_drop_trap_test()\n{\n\tlocal vlan=$1; shift\n\tlocal limit=$1; shift\n\tlocal trap_name=$1; shift\n\n\tdo_drop_test \"$vlan\" \"$limit\" \"$trap_name\" trap \\\n\t\t     \"qevent_counter_fetch_trap $trap_name\"\n}\n\nqevent_rule_install_trap_fwd()\n{\n\ttc filter add block 10 pref 1234 handle 102 matchall skip_sw \\\n\t   action trap_fwd hw_stats disabled\n}\n\nqevent_rule_uninstall_trap_fwd()\n{\n\ttc filter del block 10 pref 1234 handle 102 matchall\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}