{
  "module_name": "sch_ets.sh",
  "hash_id": "8e46baebd3553bfd21a1148a370e5b09da8916a6ce233332afd22120ca6b1e7c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/sch_ets.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# A driver for the ETS selftest that implements testing in offloaded datapath.\nlib_dir=$(dirname $0)/../../../net/forwarding\nsource $lib_dir/sch_ets_core.sh\nsource $lib_dir/devlink_lib.sh\n\nALL_TESTS=\"\n\tping_ipv4\n\tpriomap_mode\n\tets_test_strict\n\tets_test_mixed\n\tets_test_dwrr\n\"\n\nPARENT=\"parent 3:3\"\n\nswitch_create()\n{\n\t# Create a bottleneck so that the DWRR process can kick in.\n\ttc qdisc replace dev $swp2 root handle 3: tbf rate 1gbit \\\n\t\tburst 128K limit 1G\n\n\tets_switch_create\n\n\t# Set the ingress quota high and use the three egress TCs to limit the\n\t# amount of traffic that is admitted to the shared buffers. This makes\n\t# sure that there is always enough traffic of all types to select from\n\t# for the DWRR process.\n\tdevlink_port_pool_th_save $swp1 0\n\tdevlink_port_pool_th_set $swp1 0 12\n\tdevlink_tc_bind_pool_th_save $swp1 0 ingress\n\tdevlink_tc_bind_pool_th_set $swp1 0 ingress 0 12\n\tdevlink_port_pool_th_save $swp2 4\n\tdevlink_port_pool_th_set $swp2 4 12\n\tdevlink_tc_bind_pool_th_save $swp2 7 egress\n\tdevlink_tc_bind_pool_th_set $swp2 7 egress 4 5\n\tdevlink_tc_bind_pool_th_save $swp2 6 egress\n\tdevlink_tc_bind_pool_th_set $swp2 6 egress 4 5\n\tdevlink_tc_bind_pool_th_save $swp2 5 egress\n\tdevlink_tc_bind_pool_th_set $swp2 5 egress 4 5\n\n\t# Note: sch_ets_core.sh uses VLAN ingress-qos-map to assign packet\n\t# priorities at $swp1 based on their 802.1p headers. ingress-qos-map is\n\t# not offloaded by mlxsw as of this writing, but the mapping used is\n\t# 1:1, which is the mapping currently hard-coded by the driver.\n}\n\nswitch_destroy()\n{\n\tdevlink_tc_bind_pool_th_restore $swp2 5 egress\n\tdevlink_tc_bind_pool_th_restore $swp2 6 egress\n\tdevlink_tc_bind_pool_th_restore $swp2 7 egress\n\tdevlink_port_pool_th_restore $swp2 4\n\tdevlink_tc_bind_pool_th_restore $swp1 0 ingress\n\tdevlink_port_pool_th_restore $swp1 0\n\n\tets_switch_destroy\n\n\ttc qdisc del dev $swp2 root handle 3:\n}\n\n# Callback from sch_ets_tests.sh\ncollect_stats()\n{\n\tlocal -a streams=(\"$@\")\n\tlocal stream\n\n\t# Wait for qdisc counter update so that we don't get it mid-way through.\n\tbusywait_for_counter 1000 +1 \\\n\t\tqdisc_parent_stats_get $swp2 10:$((${streams[0]} + 1)) .bytes \\\n\t\t> /dev/null\n\n\tfor stream in ${streams[@]}; do\n\t\tqdisc_parent_stats_get $swp2 10:$((stream + 1)) .bytes\n\tdone\n}\n\nbail_on_lldpad \"configure DCB\" \"configure Qdiscs\"\nets_run\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}