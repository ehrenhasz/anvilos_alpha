{
  "module_name": "qos_dscp_router.sh",
  "hash_id": "20a42c83287cf21526e7a0f8440d8d3f2ea75f60dcffa9c6c973adce7f7ea8ea",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/qos_dscp_router.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# Test for DSCP prioritization in the router.\n#\n# With ip_forward_update_priority disabled, the packets are expected to keep\n# their DSCP (which in this test uses only values 0..7) intact as they are\n# forwarded by the switch. That is verified at $h2. ICMP responses are formed\n# with the same DSCP as the requests, and likewise pass through the switch\n# intact, which is verified at $h1.\n#\n# With ip_forward_update_priority enabled, router reprioritizes the packets\n# according to the table in reprioritize(). Thus, say, DSCP 7 maps to priority\n# 4, which on egress maps back to DSCP 4. The response packet then gets\n# reprioritized to 6, getting DSCP 6 on egress.\n#\n# +----------------------+                             +----------------------+\n# | H1                   |                             |                   H2 |\n# |    + $h1             |                             |            $h2 +     |\n# |    | 192.0.2.1/28    |                             |  192.0.2.18/28 |     |\n# +----|-----------------+                             +----------------|-----+\n#      |                                                                |\n# +----|----------------------------------------------------------------|-----+\n# | SW |                                                                |     |\n# |    + $swp1                                                    $swp2 +     |\n# |      192.0.2.2/28                                     192.0.2.17/28       |\n# |      APP=0,5,0 .. 7,5,7                          APP=0,5,0 .. 7,5,7       |\n# +---------------------------------------------------------------------------+\n\nALL_TESTS=\"\n\tping_ipv4\n\ttest_update\n\ttest_no_update\n\ttest_pedit_norewrite\n\ttest_dscp_leftover\n\"\n\nlib_dir=$(dirname $0)/../../../net/forwarding\n\nNUM_NETIFS=4\nsource $lib_dir/lib.sh\n\nreprioritize()\n{\n\tlocal in=$1; shift\n\n\t# This is based on rt_tos2priority in include/net/route.h. Assuming 1:1\n\t# mapping between priorities and TOS, it yields a new priority for a\n\t# packet with ingress priority of $in.\n\tlocal -a reprio=(0 0 2 2 6 6 4 4)\n\n\techo ${reprio[$in]}\n}\n\nzero()\n{\n    echo 0\n}\n\nthree()\n{\n    echo 3\n}\n\nh1_create()\n{\n\tsimple_if_init $h1 192.0.2.1/28\n\ttc qdisc add dev $h1 clsact\n\tdscp_capture_install $h1 0\n\tip route add vrf v$h1 192.0.2.16/28 via 192.0.2.2\n}\n\nh1_destroy()\n{\n\tip route del vrf v$h1 192.0.2.16/28 via 192.0.2.2\n\tdscp_capture_uninstall $h1 0\n\ttc qdisc del dev $h1 clsact\n\tsimple_if_fini $h1 192.0.2.1/28\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 192.0.2.18/28\n\ttc qdisc add dev $h2 clsact\n\tdscp_capture_install $h2 0\n\tip route add vrf v$h2 192.0.2.0/28 via 192.0.2.17\n}\n\nh2_destroy()\n{\n\tip route del vrf v$h2 192.0.2.0/28 via 192.0.2.17\n\tdscp_capture_uninstall $h2 0\n\ttc qdisc del dev $h2 clsact\n\tsimple_if_fini $h2 192.0.2.18/28\n}\n\nswitch_create()\n{\n\tsimple_if_init $swp1 192.0.2.2/28\n\t__simple_if_init $swp2 v$swp1 192.0.2.17/28\n\n\ttc qdisc add dev $swp1 clsact\n\ttc qdisc add dev $swp2 clsact\n\n\tdcb app add dev $swp1 dscp-prio 0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7\n\tdcb app add dev $swp2 dscp-prio 0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7\n}\n\nswitch_destroy()\n{\n\tdcb app del dev $swp2 dscp-prio 0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7\n\tdcb app del dev $swp1 dscp-prio 0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7\n\n\ttc qdisc del dev $swp2 clsact\n\ttc qdisc del dev $swp1 clsact\n\n\t__simple_if_fini $swp2 192.0.2.17/28\n\tsimple_if_fini $swp1 192.0.2.2/28\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\tvrf_prepare\n\n\tsysctl_set net.ipv4.ip_forward_update_priority 1\n\th1_create\n\th2_create\n\tswitch_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tswitch_destroy\n\th2_destroy\n\th1_destroy\n\tsysctl_restore net.ipv4.ip_forward_update_priority\n\n\tvrf_cleanup\n}\n\nping_ipv4()\n{\n\tping_test $h1 192.0.2.18\n}\n\ndscp_ping_test()\n{\n\tlocal vrf_name=$1; shift\n\tlocal sip=$1; shift\n\tlocal dip=$1; shift\n\tlocal prio=$1; shift\n\tlocal reprio=$1; shift\n\tlocal dev1=$1; shift\n\tlocal dev2=$1; shift\n\tlocal i\n\n\tlocal prio2=$($reprio $prio)   # ICMP Request egress prio\n\tlocal prio3=$($reprio $prio2)  # ICMP Response egress prio\n\n\tlocal dscp=$((prio << 2))     # ICMP Request ingress DSCP\n\tlocal dscp2=$((prio2 << 2))   # ICMP Request egress DSCP\n\tlocal dscp3=$((prio3 << 2))   # ICMP Response egress DSCP\n\n\tRET=0\n\n\teval \"local -A dev1_t0s=($(dscp_fetch_stats $dev1 0))\"\n\teval \"local -A dev2_t0s=($(dscp_fetch_stats $dev2 0))\"\n\n\tlocal ping_timeout=$((PING_TIMEOUT * 5))\n\tip vrf exec $vrf_name \\\n\t   ${PING} -Q $dscp ${sip:+-I $sip} $dip \\\n\t\t   -c 10 -i 0.5 -w $ping_timeout &> /dev/null\n\n\teval \"local -A dev1_t1s=($(dscp_fetch_stats $dev1 0))\"\n\teval \"local -A dev2_t1s=($(dscp_fetch_stats $dev2 0))\"\n\n\tfor i in {0..7}; do\n\t\tlocal dscpi=$((i << 2))\n\t\tlocal expect2=0\n\t\tlocal expect3=0\n\n\t\tif ((i == prio2)); then\n\t\t\texpect2=10\n\t\tfi\n\t\tif ((i == prio3)); then\n\t\t\texpect3=10\n\t\tfi\n\n\t\tlocal delta=$((dev2_t1s[$i] - dev2_t0s[$i]))\n\t\t((expect2 == delta))\n\t\tcheck_err $? \"DSCP $dscpi@$dev2: Expected to capture $expect2 packets, got $delta.\"\n\n\t\tdelta=$((dev1_t1s[$i] - dev1_t0s[$i]))\n\t\t((expect3 == delta))\n\t\tcheck_err $? \"DSCP $dscpi@$dev1: Expected to capture $expect3 packets, got $delta.\"\n\tdone\n\n\tlog_test \"DSCP rewrite: $dscp-(prio $prio2)-$dscp2-(prio $prio3)-$dscp3\"\n}\n\n__test_update()\n{\n\tlocal update=$1; shift\n\tlocal reprio=$1; shift\n\tlocal prio\n\n\tsysctl_restore net.ipv4.ip_forward_update_priority\n\tsysctl_set net.ipv4.ip_forward_update_priority $update\n\n\tfor prio in {0..7}; do\n\t\tdscp_ping_test v$h1 192.0.2.1 192.0.2.18 $prio $reprio $h1 $h2\n\tdone\n}\n\ntest_update()\n{\n\techo \"Test net.ipv4.ip_forward_update_priority=1\"\n\t__test_update 1 reprioritize\n}\n\ntest_no_update()\n{\n\techo \"Test net.ipv4.ip_forward_update_priority=0\"\n\t__test_update 0 echo\n}\n\n# Test that when DSCP is updated in pedit, the DSCP rewrite is turned off.\ntest_pedit_norewrite()\n{\n\techo \"Test no DSCP rewrite after DSCP is updated by pedit\"\n\n\ttc filter add dev $swp1 ingress handle 101 pref 1 prot ip flower \\\n\t    action pedit ex munge ip dsfield set $((3 << 2)) retain 0xfc \\\n\t    action skbedit priority 3\n\n\t__test_update 0 three\n\n\ttc filter del dev $swp1 ingress pref 1\n}\n\n# Test that when the last APP rule is removed, the prio->DSCP map is properly\n# set to zeroes, and that the last APP rule does not stay active in the ASIC.\ntest_dscp_leftover()\n{\n\techo \"Test that last removed DSCP rule is deconfigured correctly\"\n\n\tdcb app del dev $swp2 dscp-prio 0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7\n\n\t__test_update 0 zero\n\n\tdcb app add dev $swp2 dscp-prio 0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}