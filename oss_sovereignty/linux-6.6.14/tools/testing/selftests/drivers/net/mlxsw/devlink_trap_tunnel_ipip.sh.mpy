{
  "module_name": "devlink_trap_tunnel_ipip.sh",
  "hash_id": "b7422d421c7e4c44b3b32ee8720ffa289d77bcabf541c2204b530df7c0e09467",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/devlink_trap_tunnel_ipip.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test devlink-trap tunnel exceptions functionality over mlxsw.\n# Check all exception traps to make sure they are triggered under the right\n# conditions.\n\n# +-------------------------+\n# | H1                      |\n# |               $h1 +     |\n# |      192.0.2.1/28 |     |\n# +-------------------|-----+\n#                     |\n# +-------------------|-----+\n# | SW1               |     |\n# |             $swp1 +     |\n# |      192.0.2.2/28       |\n# |                         |\n# |  + g1a (gre)            |\n# |    loc=192.0.2.65       |\n# |    rem=192.0.2.66       |\n# |    tos=inherit          |\n# |                         |\n# |  + $rp1                 |\n# |  |  198.51.100.1/28     |\n# +--|----------------------+\n#    |\n# +--|----------------------+\n# |  |                 VRF2 |\n# |  + $rp2                 |\n# |    198.51.100.2/28      |\n# +-------------------------+\n\nlib_dir=$(dirname $0)/../../../net/forwarding\n\nALL_TESTS=\"\n\tdecap_error_test\n\"\n\nNUM_NETIFS=4\nsource $lib_dir/lib.sh\nsource $lib_dir/tc_common.sh\nsource $lib_dir/devlink_lib.sh\n\nh1_create()\n{\n\tsimple_if_init $h1 192.0.2.1/28\n}\n\nh1_destroy()\n{\n\tsimple_if_fini $h1 192.0.2.1/28\n}\n\nvrf2_create()\n{\n\tsimple_if_init $rp2 198.51.100.2/28\n}\n\nvrf2_destroy()\n{\n\tsimple_if_fini $rp2 198.51.100.2/28\n}\n\nswitch_create()\n{\n\t__addr_add_del $swp1 add 192.0.2.2/28\n\ttc qdisc add dev $swp1 clsact\n\tip link set dev $swp1 up\n\n\ttunnel_create g1 gre 192.0.2.65 192.0.2.66 tos inherit\n\t__addr_add_del g1 add 192.0.2.65/32\n\tip link set dev g1 up\n\n\t__addr_add_del $rp1 add 198.51.100.1/28\n\tip link set dev $rp1 up\n}\n\nswitch_destroy()\n{\n\tip link set dev $rp1 down\n\t__addr_add_del $rp1 del 198.51.100.1/28\n\n\tip link set dev g1 down\n\t__addr_add_del g1 del 192.0.2.65/32\n\ttunnel_destroy g1\n\n\tip link set dev $swp1 down\n\ttc qdisc del dev $swp1 clsact\n\t__addr_add_del $swp1 del 192.0.2.2/28\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\trp1=${NETIFS[p3]}\n\trp2=${NETIFS[p4]}\n\n\tforwarding_enable\n\tvrf_prepare\n\th1_create\n\tswitch_create\n\tvrf2_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tvrf2_destroy\n\tswitch_destroy\n\th1_destroy\n\tvrf_cleanup\n\tforwarding_restore\n}\n\nipip_payload_get()\n{\n\tlocal flags=$1; shift\n\tlocal key=$1; shift\n\n\tp=$(:\n\t\t)\"$flags\"$(\t\t      : GRE flags\n\t        )\"0:00:\"$(                    : Reserved + version\n\t\t)\"08:00:\"$(\t\t      : ETH protocol type\n\t\t)\"$key\"$( \t\t      : Key\n\t\t)\"4\"$(\t                      : IP version\n\t\t)\"5:\"$(                       : IHL\n\t\t)\"00:\"$(                      : IP TOS\n\t\t)\"00:14:\"$(                   : IP total length\n\t\t)\"00:00:\"$(                   : IP identification\n\t\t)\"20:00:\"$(                   : IP flags + frag off\n\t\t)\"30:\"$(                      : IP TTL\n\t\t)\"01:\"$(                      : IP proto\n\t\t)\"E7:E6:\"$(    \t              : IP header csum\n\t\t)\"C0:00:01:01:\"$(             : IP saddr : 192.0.1.1\n\t\t)\"C0:00:02:01:\"$(             : IP daddr : 192.0.2.1\n\t\t)\n\techo $p\n}\n\necn_payload_get()\n{\n\techo $(ipip_payload_get \"0\")\n}\n\necn_decap_test()\n{\n\tlocal trap_name=\"decap_error\"\n\tlocal desc=$1; shift\n\tlocal ecn_desc=$1; shift\n\tlocal outer_tos=$1; shift\n\tlocal mz_pid\n\n\tRET=0\n\n\ttc filter add dev $swp1 egress protocol ip pref 1 handle 101 \\\n\t\tflower src_ip 192.0.1.1 dst_ip 192.0.2.1 action pass\n\n\trp1_mac=$(mac_get $rp1)\n\trp2_mac=$(mac_get $rp2)\n\tpayload=$(ecn_payload_get)\n\n\tip vrf exec v$rp2 $MZ $rp2 -c 0 -d 1msec -a $rp2_mac -b $rp1_mac \\\n\t\t-A 192.0.2.66 -B 192.0.2.65 -t ip \\\n\t\t\tlen=48,tos=$outer_tos,proto=47,p=$payload -q &\n\n\tmz_pid=$!\n\n\tdevlink_trap_exception_test $trap_name\n\n\ttc_check_packets \"dev $swp1 egress\" 101 0\n\tcheck_err $? \"Packets were not dropped\"\n\n\tlog_test \"$desc: Inner ECN is not ECT and outer is $ecn_desc\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\ttc filter del dev $swp1 egress protocol ip pref 1 handle 101 flower\n}\n\nno_matching_tunnel_test()\n{\n\tlocal trap_name=\"decap_error\"\n\tlocal desc=$1; shift\n\tlocal sip=$1; shift\n\tlocal mz_pid\n\n\tRET=0\n\n\ttc filter add dev $swp1 egress protocol ip pref 1 handle 101 \\\n\t\tflower src_ip 192.0.1.1 dst_ip 192.0.2.1 action pass\n\n\trp1_mac=$(mac_get $rp1)\n\trp2_mac=$(mac_get $rp2)\n\tpayload=$(ipip_payload_get \"$@\")\n\n\tip vrf exec v$rp2 $MZ $rp2 -c 0 -d 1msec -a $rp2_mac -b $rp1_mac \\\n\t\t-A $sip -B 192.0.2.65 -t ip len=48,proto=47,p=$payload -q &\n\tmz_pid=$!\n\n\tdevlink_trap_exception_test $trap_name\n\n\ttc_check_packets \"dev $swp1 egress\" 101 0\n\tcheck_err $? \"Packets were not dropped\"\n\n\tlog_test \"$desc\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\ttc filter del dev $swp1 egress protocol ip pref 1 handle 101 flower\n}\n\ndecap_error_test()\n{\n\t# Correct source IP - the remote address\n\tlocal sip=192.0.2.66\n\n\tecn_decap_test \"Decap error\" \"ECT(1)\" 01\n\tecn_decap_test \"Decap error\" \"ECT(0)\" 02\n\tecn_decap_test \"Decap error\" \"CE\" 03\n\n\tno_matching_tunnel_test \"Decap error: Source IP check failed\" \\\n\t\t192.0.2.68 \"0\"\n\tno_matching_tunnel_test \\\n\t\t\"Decap error: Key exists but was not expected\" $sip \"2\" \\\n\t\t\"00:00:00:E9:\"\n\n\t# Destroy the tunnel and create new one with key\n\t__addr_add_del g1 del 192.0.2.65/32\n\ttunnel_destroy g1\n\n\ttunnel_create g1 gre 192.0.2.65 192.0.2.66 tos inherit key 233\n\t__addr_add_del g1 add 192.0.2.65/32\n\n\tno_matching_tunnel_test \\\n\t\t\"Decap error: Key does not exist but was expected\" $sip \"0\"\n\tno_matching_tunnel_test \\\n\t\t\"Decap error: Packet has a wrong key field\" $sip \"2\" \\\n\t\t\"00:00:00:E8:\"\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}