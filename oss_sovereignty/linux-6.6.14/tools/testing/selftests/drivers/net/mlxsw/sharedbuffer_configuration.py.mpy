{
  "module_name": "sharedbuffer_configuration.py",
  "hash_id": "c300f33cc81946b61fb991e3182dd17d41d2cbe280bad07964d62f87ed7e3072",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/sharedbuffer_configuration.py",
  "human_readable_source": "#!/usr/bin/env python\n# SPDX-License-Identifier: GPL-2.0\n\nimport subprocess\nimport json as j\nimport random\n\n\nclass SkipTest(Exception):\n    pass\n\n\nclass RandomValuePicker:\n    \"\"\"\n    Class for storing shared buffer configuration. Can handle 3 different\n    objects, pool, tcbind and portpool. Provide an interface to get random\n    values for a specific object type as the follow:\n      1. Pool:\n         - random size\n\n      2. TcBind:\n         - random pool number\n         - random threshold\n\n      3. PortPool:\n         - random threshold\n    \"\"\"\n    def __init__(self, pools):\n        self._pools = []\n        for pool in pools:\n            self._pools.append(pool)\n\n    def _cell_size(self):\n        return self._pools[0][\"cell_size\"]\n\n    def _get_static_size(self, th):\n        # For threshold of 16, this works out to be about 12MB on Spectrum-1,\n        # and about 17MB on Spectrum-2.\n        return th * 8000 * self._cell_size()\n\n    def _get_size(self):\n        return self._get_static_size(16)\n\n    def _get_thtype(self):\n        return \"static\"\n\n    def _get_th(self, pool):\n        # Threshold value could be any integer between 3 to 16\n        th = random.randint(3, 16)\n        if pool[\"thtype\"] == \"dynamic\":\n            return th\n        else:\n            return self._get_static_size(th)\n\n    def _get_pool(self, direction):\n        ing_pools = []\n        egr_pools = []\n        for pool in self._pools:\n            if pool[\"type\"] == \"ingress\":\n                ing_pools.append(pool)\n            else:\n                egr_pools.append(pool)\n        if direction == \"ingress\":\n            arr = ing_pools\n        else:\n            arr = egr_pools\n        return arr[random.randint(0, len(arr) - 1)]\n\n    def get_value(self, objid):\n        if isinstance(objid, Pool):\n            if objid[\"pool\"] in [4, 8, 9, 10]:\n                # The threshold type of pools 4, 8, 9 and 10 cannot be changed\n                raise SkipTest()\n            else:\n                return (self._get_size(), self._get_thtype())\n        if isinstance(objid, TcBind):\n            if objid[\"tc\"] >= 8:\n                # Multicast TCs cannot be changed\n                raise SkipTest()\n            else:\n                pool = self._get_pool(objid[\"type\"])\n                th = self._get_th(pool)\n                pool_n = pool[\"pool\"]\n                return (pool_n, th)\n        if isinstance(objid, PortPool):\n            pool_n = objid[\"pool\"]\n            pool = self._pools[pool_n]\n            assert pool[\"pool\"] == pool_n\n            th = self._get_th(pool)\n            return (th,)\n\n\nclass RecordValuePickerException(Exception):\n    pass\n\n\nclass RecordValuePicker:\n    \"\"\"\n    Class for storing shared buffer configuration. Can handle 2 different\n    objects, pool and tcbind. Provide an interface to get the stored values per\n    object type.\n    \"\"\"\n    def __init__(self, objlist):\n        self._recs = []\n        for item in objlist:\n            self._recs.append({\"objid\": item, \"value\": item.var_tuple()})\n\n    def get_value(self, objid):\n        if isinstance(objid, Pool) and objid[\"pool\"] in [4, 8, 9, 10]:\n            # The threshold type of pools 4, 8, 9 and 10 cannot be changed\n            raise SkipTest()\n        if isinstance(objid, TcBind) and objid[\"tc\"] >= 8:\n            # Multicast TCs cannot be changed\n            raise SkipTest()\n        for rec in self._recs:\n            if rec[\"objid\"].weak_eq(objid):\n                return rec[\"value\"]\n        raise RecordValuePickerException()\n\n\ndef run_cmd(cmd, json=False):\n    out = subprocess.check_output(cmd, shell=True)\n    if json:\n        return j.loads(out)\n    return out\n\n\ndef run_json_cmd(cmd):\n    return run_cmd(cmd, json=True)\n\n\ndef log_test(test_name, err_msg=None):\n    if err_msg:\n        print(\"\\t%s\" % err_msg)\n        print(\"TEST: %-80s  [FAIL]\" % test_name)\n    else:\n        print(\"TEST: %-80s  [ OK ]\" % test_name)\n\n\nclass CommonItem(dict):\n    varitems = []\n\n    def var_tuple(self):\n        ret = []\n        self.varitems.sort()\n        for key in self.varitems:\n            ret.append(self[key])\n        return tuple(ret)\n\n    def weak_eq(self, other):\n        for key in self:\n            if key in self.varitems:\n                continue\n            if self[key] != other[key]:\n                return False\n        return True\n\n\nclass CommonList(list):\n    def get_by(self, by_obj):\n        for item in self:\n            if item.weak_eq(by_obj):\n                return item\n        return None\n\n    def del_by(self, by_obj):\n        for item in self:\n            if item.weak_eq(by_obj):\n                self.remove(item)\n\n\nclass Pool(CommonItem):\n    varitems = [\"size\", \"thtype\"]\n\n    def dl_set(self, dlname, size, thtype):\n        run_cmd(\"devlink sb pool set {} sb {} pool {} size {} thtype {}\".format(dlname, self[\"sb\"],\n                                                                                self[\"pool\"],\n                                                                                size, thtype))\n\n\nclass PoolList(CommonList):\n    pass\n\n\ndef get_pools(dlname, direction=None):\n    d = run_json_cmd(\"devlink sb pool show -j\")\n    pools = PoolList()\n    for pooldict in d[\"pool\"][dlname]:\n        if not direction or direction == pooldict[\"type\"]:\n            pools.append(Pool(pooldict))\n    return pools\n\n\ndef do_check_pools(dlname, pools, vp):\n    for pool in pools:\n        pre_pools = get_pools(dlname)\n        try:\n            (size, thtype) = vp.get_value(pool)\n        except SkipTest:\n            continue\n        pool.dl_set(dlname, size, thtype)\n        post_pools = get_pools(dlname)\n        pool = post_pools.get_by(pool)\n\n        err_msg = None\n        if pool[\"size\"] != size:\n            err_msg = \"Incorrect pool size (got {}, expected {})\".format(pool[\"size\"], size)\n        if pool[\"thtype\"] != thtype:\n            err_msg = \"Incorrect pool threshold type (got {}, expected {})\".format(pool[\"thtype\"], thtype)\n\n        pre_pools.del_by(pool)\n        post_pools.del_by(pool)\n        if pre_pools != post_pools:\n            err_msg = \"Other pool setup changed as well\"\n        log_test(\"pool {} of sb {} set verification\".format(pool[\"pool\"],\n                                                            pool[\"sb\"]), err_msg)\n\n\ndef check_pools(dlname, pools):\n    # Save defaults\n    record_vp = RecordValuePicker(pools)\n\n    # For each pool, set random size and static threshold type\n    do_check_pools(dlname, pools, RandomValuePicker(pools))\n\n    # Restore defaults\n    do_check_pools(dlname, pools, record_vp)\n\n\nclass TcBind(CommonItem):\n    varitems = [\"pool\", \"threshold\"]\n\n    def __init__(self, port, d):\n        super(TcBind, self).__init__(d)\n        self[\"dlportname\"] = port.name\n\n    def dl_set(self, pool, th):\n        run_cmd(\"devlink sb tc bind set {} sb {} tc {} type {} pool {} th {}\".format(self[\"dlportname\"],\n                                                                                     self[\"sb\"],\n                                                                                     self[\"tc\"],\n                                                                                     self[\"type\"],\n                                                                                     pool, th))\n\n\nclass TcBindList(CommonList):\n    pass\n\n\ndef get_tcbinds(ports, verify_existence=False):\n    d = run_json_cmd(\"devlink sb tc bind show -j -n\")\n    tcbinds = TcBindList()\n    for port in ports:\n        err_msg = None\n        if port.name not in d[\"tc_bind\"] or len(d[\"tc_bind\"][port.name]) == 0:\n            err_msg = \"No tc bind for port\"\n        else:\n            for tcbinddict in d[\"tc_bind\"][port.name]:\n                tcbinds.append(TcBind(port, tcbinddict))\n        if verify_existence:\n            log_test(\"tc bind existence for port {} verification\".format(port.name), err_msg)\n    return tcbinds\n\n\ndef do_check_tcbind(ports, tcbinds, vp):\n    for tcbind in tcbinds:\n        pre_tcbinds = get_tcbinds(ports)\n        try:\n            (pool, th) = vp.get_value(tcbind)\n        except SkipTest:\n            continue\n        tcbind.dl_set(pool, th)\n        post_tcbinds = get_tcbinds(ports)\n        tcbind = post_tcbinds.get_by(tcbind)\n\n        err_msg = None\n        if tcbind[\"pool\"] != pool:\n            err_msg = \"Incorrect pool (got {}, expected {})\".format(tcbind[\"pool\"], pool)\n        if tcbind[\"threshold\"] != th:\n            err_msg = \"Incorrect threshold (got {}, expected {})\".format(tcbind[\"threshold\"], th)\n\n        pre_tcbinds.del_by(tcbind)\n        post_tcbinds.del_by(tcbind)\n        if pre_tcbinds != post_tcbinds:\n            err_msg = \"Other tc bind setup changed as well\"\n        log_test(\"tc bind {}-{} of sb {} set verification\".format(tcbind[\"dlportname\"],\n                                                                  tcbind[\"tc\"],\n                                                                  tcbind[\"sb\"]), err_msg)\n\n\ndef check_tcbind(dlname, ports, pools):\n    tcbinds = get_tcbinds(ports, verify_existence=True)\n\n    # Save defaults\n    record_vp = RecordValuePicker(tcbinds)\n\n    # Bind each port and unicast TC (TCs < 8) to a random pool and a random\n    # threshold\n    do_check_tcbind(ports, tcbinds, RandomValuePicker(pools))\n\n    # Restore defaults\n    do_check_tcbind(ports, tcbinds, record_vp)\n\n\nclass PortPool(CommonItem):\n    varitems = [\"threshold\"]\n\n    def __init__(self, port, d):\n        super(PortPool, self).__init__(d)\n        self[\"dlportname\"] = port.name\n\n    def dl_set(self, th):\n        run_cmd(\"devlink sb port pool set {} sb {} pool {} th {}\".format(self[\"dlportname\"],\n                                                                         self[\"sb\"],\n                                                                         self[\"pool\"], th))\n\n\nclass PortPoolList(CommonList):\n    pass\n\n\ndef get_portpools(ports, verify_existence=False):\n    d = run_json_cmd(\"devlink sb port pool -j -n\")\n    portpools = PortPoolList()\n    for port in ports:\n        err_msg = None\n        if port.name not in d[\"port_pool\"] or len(d[\"port_pool\"][port.name]) == 0:\n            err_msg = \"No port pool for port\"\n        else:\n            for portpooldict in d[\"port_pool\"][port.name]:\n                portpools.append(PortPool(port, portpooldict))\n        if verify_existence:\n            log_test(\"port pool existence for port {} verification\".format(port.name), err_msg)\n    return portpools\n\n\ndef do_check_portpool(ports, portpools, vp):\n    for portpool in portpools:\n        pre_portpools = get_portpools(ports)\n        (th,) = vp.get_value(portpool)\n        portpool.dl_set(th)\n        post_portpools = get_portpools(ports)\n        portpool = post_portpools.get_by(portpool)\n\n        err_msg = None\n        if portpool[\"threshold\"] != th:\n            err_msg = \"Incorrect threshold (got {}, expected {})\".format(portpool[\"threshold\"], th)\n\n        pre_portpools.del_by(portpool)\n        post_portpools.del_by(portpool)\n        if pre_portpools != post_portpools:\n            err_msg = \"Other port pool setup changed as well\"\n        log_test(\"port pool {}-{} of sb {} set verification\".format(portpool[\"dlportname\"],\n                                                                    portpool[\"pool\"],\n                                                                    portpool[\"sb\"]), err_msg)\n\n\ndef check_portpool(dlname, ports, pools):\n    portpools = get_portpools(ports, verify_existence=True)\n\n    # Save defaults\n    record_vp = RecordValuePicker(portpools)\n\n    # For each port pool, set a random threshold\n    do_check_portpool(ports, portpools, RandomValuePicker(pools))\n\n    # Restore defaults\n    do_check_portpool(ports, portpools, record_vp)\n\n\nclass Port:\n    def __init__(self, name):\n        self.name = name\n\n\nclass PortList(list):\n    pass\n\n\ndef get_ports(dlname):\n    d = run_json_cmd(\"devlink port show -j\")\n    ports = PortList()\n    for name in d[\"port\"]:\n        if name.find(dlname) == 0 and d[\"port\"][name][\"flavour\"] == \"physical\":\n            ports.append(Port(name))\n    return ports\n\n\ndef get_device():\n    devices_info = run_json_cmd(\"devlink -j dev info\")[\"info\"]\n    for d in devices_info:\n        if \"mlxsw_spectrum\" in devices_info[d][\"driver\"]:\n            return d\n    return None\n\n\nclass UnavailableDevlinkNameException(Exception):\n    pass\n\n\ndef test_sb_configuration():\n    # Use static seed\n    random.seed(0)\n\n    dlname = get_device()\n    if not dlname:\n        raise UnavailableDevlinkNameException()\n\n    ports = get_ports(dlname)\n    pools = get_pools(dlname)\n\n    check_pools(dlname, pools)\n    check_tcbind(dlname, ports, pools)\n    check_portpool(dlname, ports, pools)\n\n\ntest_sb_configuration()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}