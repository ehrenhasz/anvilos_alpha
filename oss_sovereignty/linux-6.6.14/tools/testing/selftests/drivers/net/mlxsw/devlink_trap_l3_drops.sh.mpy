{
  "module_name": "devlink_trap_l3_drops.sh",
  "hash_id": "3b07b39d40c637b61791b19c35f5248db91a59cbbe5caa7ab8e160de1baa71ea",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/devlink_trap_l3_drops.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test devlink-trap L3 drops functionality over mlxsw. Each registered L3 drop\n# packet trap is tested to make sure it is triggered under the right\n# conditions.\n\n# +---------------------------------+\n# | H1 (vrf)                        |\n# |    + $h1                        |\n# |    | 192.0.2.1/24               |\n# |    | 2001:db8:1::1/64           |\n# |    |                            |\n# |    |  default via 192.0.2.2     |\n# |    |  default via 2001:db8:1::2 |\n# +----|----------------------------+\n#      |\n# +----|----------------------------------------------------------------------+\n# | SW |                                                                      |\n# |    + $rp1                                                                 |\n# |        192.0.2.2/24                                                       |\n# |        2001:db8:1::2/64                                                   |\n# |                                                                           |\n# |        2001:db8:2::2/64                                                   |\n# |        198.51.100.2/24                                                    |\n# |    + $rp2                                                                 |\n# |    |                                                                      |\n# +----|----------------------------------------------------------------------+\n#      |\n# +----|----------------------------+\n# |    |  default via 198.51.100.2  |\n# |    |  default via 2001:db8:2::2 |\n# |    |                            |\n# |    | 2001:db8:2::1/64           |\n# |    | 198.51.100.1/24            |\n# |    + $h2                        |\n# | H2 (vrf)                        |\n# +---------------------------------+\n\nlib_dir=$(dirname $0)/../../../net/forwarding\n\nALL_TESTS=\"\n\tnon_ip_test\n\tuc_dip_over_mc_dmac_test\n\tdip_is_loopback_test\n\tsip_is_mc_test\n\tsip_is_loopback_test\n\tip_header_corrupted_test\n\tipv4_sip_is_limited_bc_test\n\tipv6_mc_dip_reserved_scope_test\n\tipv6_mc_dip_interface_local_scope_test\n\tblackhole_route_test\n\tirif_disabled_test\n\terif_disabled_test\n\tblackhole_nexthop_test\n\"\n\nNUM_NETIFS=4\nsource $lib_dir/lib.sh\nsource $lib_dir/tc_common.sh\nsource $lib_dir/devlink_lib.sh\n\nh1_create()\n{\n\tsimple_if_init $h1 192.0.2.1/24 2001:db8:1::1/64\n\n\tip -4 route add default vrf v$h1 nexthop via 192.0.2.2\n\tip -6 route add default vrf v$h1 nexthop via 2001:db8:1::2\n}\n\nh1_destroy()\n{\n\tip -6 route del default vrf v$h1 nexthop via 2001:db8:1::2\n\tip -4 route del default vrf v$h1 nexthop via 192.0.2.2\n\n\tsimple_if_fini $h1 192.0.2.1/24 2001:db8:1::1/64\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 $h2_ipv4/24 $h2_ipv6/64\n\n\tip -4 route add default vrf v$h2 nexthop via 198.51.100.2\n\tip -6 route add default vrf v$h2 nexthop via 2001:db8:2::2\n}\n\nh2_destroy()\n{\n\tip -6 route del default vrf v$h2 nexthop via 2001:db8:2::2\n\tip -4 route del default vrf v$h2 nexthop via 198.51.100.2\n\n\tsimple_if_fini $h2 $h2_ipv4/24 $h2_ipv6/64\n}\n\nrouter_create()\n{\n\tip link set dev $rp1 up\n\tip link set dev $rp2 up\n\n\ttc qdisc add dev $rp2 clsact\n\n\t__addr_add_del $rp1 add 192.0.2.2/24 2001:db8:1::2/64\n\t__addr_add_del $rp2 add 198.51.100.2/24 2001:db8:2::2/64\n}\n\nrouter_destroy()\n{\n\t__addr_add_del $rp2 del 198.51.100.2/24 2001:db8:2::2/64\n\t__addr_add_del $rp1 del 192.0.2.2/24 2001:db8:1::2/64\n\n\ttc qdisc del dev $rp2 clsact\n\n\tip link set dev $rp2 down\n\tip link set dev $rp1 down\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\trp1=${NETIFS[p2]}\n\n\trp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\th1mac=$(mac_get $h1)\n\trp1mac=$(mac_get $rp1)\n\n\th1_ipv4=192.0.2.1\n\th2_ipv4=198.51.100.1\n\th1_ipv6=2001:db8:1::1\n\th2_ipv6=2001:db8:2::1\n\n\tvrf_prepare\n\tforwarding_enable\n\n\th1_create\n\th2_create\n\n\trouter_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\trouter_destroy\n\n\th2_destroy\n\th1_destroy\n\n\tforwarding_restore\n\tvrf_cleanup\n}\n\nping_check()\n{\n\ttrap_name=$1; shift\n\n\tdevlink_trap_action_set $trap_name \"trap\"\n\tping_do $h1 $h2_ipv4\n\tcheck_err $? \"Packets that should not be trapped were trapped\"\n\tdevlink_trap_action_set $trap_name \"drop\"\n}\n\nnon_ip_test()\n{\n\tlocal trap_name=\"non_ip\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol ip pref 1 handle 101 \\\n\t\tflower dst_ip $h2_ipv4 action drop\n\n\t# Generate non-IP packets to the router\n\t$MZ $h1 -c 0 -p 100 -d 1msec -B $h2_ipv4 -q \"$rp1mac $h1mac \\\n\t\t00:00 de:ad:be:ef\" &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"Non IP\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 \"ip\" 1 101\n}\n\n__uc_dip_over_mc_dmac_test()\n{\n\tlocal desc=$1; shift\n\tlocal proto=$1; shift\n\tlocal dip=$1; shift\n\tlocal flags=${1:-\"\"}; shift\n\tlocal trap_name=\"uc_dip_over_mc_dmac\"\n\tlocal dmac=01:02:03:04:05:06\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol $proto pref 1 handle 101 \\\n\t\tflower ip_proto udp src_port 54321 dst_port 12345 action drop\n\n\t# Generate IP packets with a unicast IP and a multicast destination MAC\n\t$MZ $h1 $flags -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -b $dmac \\\n\t\t-B $dip -d 1msec -q &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"Unicast destination IP over multicast destination MAC: $desc\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 $proto 1 101\n}\n\nuc_dip_over_mc_dmac_test()\n{\n\t__uc_dip_over_mc_dmac_test \"IPv4\" \"ip\" $h2_ipv4\n\t__uc_dip_over_mc_dmac_test \"IPv6\" \"ipv6\" $h2_ipv6 \"-6\"\n}\n\n__sip_is_loopback_test()\n{\n\tlocal desc=$1; shift\n\tlocal proto=$1; shift\n\tlocal sip=$1; shift\n\tlocal dip=$1; shift\n\tlocal flags=${1:-\"\"}; shift\n\tlocal trap_name=\"sip_is_loopback_address\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol $proto pref 1 handle 101 \\\n\t\tflower src_ip $sip action drop\n\n\t# Generate packets with loopback source IP\n\t$MZ $h1 $flags -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -A $sip \\\n\t\t-b $rp1mac -B $dip -d 1msec -q &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"Source IP is loopback address: $desc\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 $proto 1 101\n}\n\nsip_is_loopback_test()\n{\n\t__sip_is_loopback_test \"IPv4\" \"ip\" \"127.0.0.0/8\" $h2_ipv4\n\t__sip_is_loopback_test \"IPv6\" \"ipv6\" \"::1\" $h2_ipv6 \"-6\"\n}\n\n__dip_is_loopback_test()\n{\n\tlocal desc=$1; shift\n\tlocal proto=$1; shift\n\tlocal dip=$1; shift\n\tlocal flags=${1:-\"\"}; shift\n\tlocal trap_name=\"dip_is_loopback_address\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol $proto pref 1 handle 101 \\\n\t\tflower dst_ip $dip action drop\n\n\t# Generate packets with loopback destination IP\n\t$MZ $h1 $flags -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -b $rp1mac \\\n\t\t-B $dip -d 1msec -q &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"Destination IP is loopback address: $desc\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 $proto 1 101\n}\n\ndip_is_loopback_test()\n{\n\t__dip_is_loopback_test \"IPv4\" \"ip\" \"127.0.0.0/8\"\n\t__dip_is_loopback_test \"IPv6\" \"ipv6\" \"::1\" \"-6\"\n}\n\n__sip_is_mc_test()\n{\n\tlocal desc=$1; shift\n\tlocal proto=$1; shift\n\tlocal sip=$1; shift\n\tlocal dip=$1; shift\n\tlocal flags=${1:-\"\"}; shift\n\tlocal trap_name=\"sip_is_mc\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol $proto pref 1 handle 101 \\\n\t\tflower src_ip $sip action drop\n\n\t# Generate packets with multicast source IP\n\t$MZ $h1 $flags -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -A $sip \\\n\t\t-b $rp1mac -B $dip -d 1msec -q &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"Source IP is multicast: $desc\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 $proto 1 101\n}\n\nsip_is_mc_test()\n{\n\t__sip_is_mc_test \"IPv4\" \"ip\" \"239.1.1.1\" $h2_ipv4\n\t__sip_is_mc_test \"IPv6\" \"ipv6\" \"FF02::2\" $h2_ipv6 \"-6\"\n}\n\nipv4_sip_is_limited_bc_test()\n{\n\tlocal trap_name=\"ipv4_sip_is_limited_bc\"\n\tlocal sip=255.255.255.255\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol ip pref 1 handle 101 \\\n\t\tflower src_ip $sip action drop\n\n\t# Generate packets with limited broadcast source IP\n\t$MZ $h1 -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -A $sip -b $rp1mac \\\n\t\t-B $h2_ipv4 -d 1msec -q &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"IPv4 source IP is limited broadcast\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 \"ip\" 1 101\n}\n\nipv4_payload_get()\n{\n\tlocal ipver=$1; shift\n\tlocal ihl=$1; shift\n\tlocal checksum=$1; shift\n\n\tp=$(:\n\t\t)\"08:00:\"$(                   : ETH type\n\t\t)\"$ipver\"$(                   : IP version\n\t\t)\"$ihl:\"$(                    : IHL\n\t\t)\"00:\"$(\t\t      : IP TOS\n\t\t)\"00:F4:\"$(                   : IP total length\n\t\t)\"00:00:\"$(                   : IP identification\n\t\t)\"20:00:\"$(                   : IP flags + frag off\n\t\t)\"30:\"$(                      : IP TTL\n\t\t)\"01:\"$(                      : IP proto\n\t\t)\"$checksum:\"$(               : IP header csum\n\t\t)\"$h1_ipv4:\"$(                : IP saddr\n\t        )\"$h2_ipv4:\"$(                : IP daddr\n\t\t)\n\techo $p\n}\n\n__ipv4_header_corrupted_test()\n{\n\tlocal desc=$1; shift\n\tlocal ipver=$1; shift\n\tlocal ihl=$1; shift\n\tlocal checksum=$1; shift\n\tlocal trap_name=\"ip_header_corrupted\"\n\tlocal payload\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol ip pref 1 handle 101 \\\n\t\tflower dst_ip $h2_ipv4 action drop\n\n\tpayload=$(ipv4_payload_get $ipver $ihl $checksum)\n\n\t# Generate packets with corrupted IP header\n\t$MZ $h1 -c 0 -d 1msec -a $h1mac -b $rp1mac -q p=$payload &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"IP header corrupted: $desc: IPv4\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 \"ip\" 1 101\n}\n\nipv6_payload_get()\n{\n\tlocal ipver=$1; shift\n\n\tp=$(:\n\t\t)\"86:DD:\"$(                  : ETH type\n\t\t)\"$ipver\"$(                  : IP version\n\t\t)\"0:0:\"$(                    : Traffic class\n\t\t)\"0:00:00:\"$(\t\t     : Flow label\n\t\t)\"00:00:\"$(                  : Payload length\n\t\t)\"01:\"$(                     : Next header\n\t\t)\"04:\"$(                     : Hop limit\n\t\t)\"$h1_ipv6:\"$(      \t     : IP saddr\n\t\t)\"$h2_ipv6:\"$(               : IP daddr\n\t\t)\n\techo $p\n}\n\n__ipv6_header_corrupted_test()\n{\n\tlocal desc=$1; shift\n\tlocal ipver=$1; shift\n\tlocal trap_name=\"ip_header_corrupted\"\n\tlocal payload\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol ip pref 1 handle 101 \\\n\t\tflower dst_ip $h2_ipv4 action drop\n\n\tpayload=$(ipv6_payload_get $ipver)\n\n\t# Generate packets with corrupted IP header\n\t$MZ $h1 -c 0 -d 1msec -a $h1mac -b $rp1mac -q p=$payload &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"IP header corrupted: $desc: IPv6\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 \"ip\" 1 101\n}\n\nip_header_corrupted_test()\n{\n\t# Each test uses one wrong value. The three values below are correct.\n\tlocal ipv=\"4\"\n\tlocal ihl=\"5\"\n\tlocal checksum=\"00:F4\"\n\n\t__ipv4_header_corrupted_test \"wrong IP version\" 5 $ihl $checksum\n\t__ipv4_header_corrupted_test \"wrong IHL\" $ipv 4 $checksum\n\t__ipv4_header_corrupted_test \"wrong checksum\" $ipv $ihl \"00:00\"\n\t__ipv6_header_corrupted_test \"wrong IP version\" 5\n}\n\nipv6_mc_dip_reserved_scope_test()\n{\n\tlocal trap_name=\"ipv6_mc_dip_reserved_scope\"\n\tlocal dip=FF00::\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol ipv6 pref 1 handle 101 \\\n\t\tflower dst_ip $dip action drop\n\n\t# Generate packets with reserved scope destination IP\n\t$MZ $h1 -6 -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -b \\\n\t\t\"33:33:00:00:00:00\" -B $dip -d 1msec -q &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"IPv6 multicast destination IP reserved scope\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 \"ipv6\" 1 101\n}\n\nipv6_mc_dip_interface_local_scope_test()\n{\n\tlocal trap_name=\"ipv6_mc_dip_interface_local_scope\"\n\tlocal dip=FF01::\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\ttc filter add dev $rp2 egress protocol ipv6 pref 1 handle 101 \\\n\t\tflower dst_ip $dip action drop\n\n\t# Generate packets with interface local scope destination IP\n\t$MZ $h1 -6 -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -b \\\n\t\t\"33:33:00:00:00:00\" -B $dip -d 1msec -q &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\n\tlog_test \"IPv6 multicast destination IP interface-local scope\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 \"ipv6\" 1 101\n}\n\n__blackhole_route_test()\n{\n\tlocal flags=$1; shift\n\tlocal subnet=$1; shift\n\tlocal proto=$1; shift\n\tlocal dip=$1; shift\n\tlocal ip_proto=${1:-\"icmp\"}; shift\n\tlocal trap_name=\"blackhole_route\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\tip -$flags route add blackhole $subnet\n\ttc filter add dev $rp2 egress protocol $proto pref 1 handle 101 \\\n\t\tflower skip_hw dst_ip $dip ip_proto $ip_proto action drop\n\n\t# Generate packets to the blackhole route\n\t$MZ $h1 -$flags -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -b $rp1mac \\\n\t\t-B $dip -d 1msec -q &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\tlog_test \"Blackhole route: IPv$flags\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 $proto 1 101\n\tip -$flags route del blackhole $subnet\n}\n\nblackhole_route_test()\n{\n\t__blackhole_route_test \"4\" \"198.51.100.0/30\" \"ip\" $h2_ipv4\n\t__blackhole_route_test \"6\" \"2001:db8:2::/120\" \"ipv6\" $h2_ipv6 \"icmpv6\"\n}\n\nirif_disabled_test()\n{\n\tlocal trap_name=\"irif_disabled\"\n\tlocal t0_packets t0_bytes\n\tlocal t1_packets t1_bytes\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\tdevlink_trap_action_set $trap_name \"trap\"\n\n\t# When RIF of a physical port (\"Sub-port RIF\") is destroyed, we first\n\t# block the STP of the {Port, VLAN} so packets cannot get into the RIF.\n\t# Using bridge enables us to see this trap because when bridge is\n\t# destroyed, there is a small time window that packets can go into the\n\t# RIF, while it is disabled.\n\tip link add dev br0 type bridge\n\tip link set dev $rp1 master br0\n\tip address flush dev $rp1\n\t__addr_add_del br0 add 192.0.2.2/24\n\tip li set dev br0 up\n\n\tt0_packets=$(devlink_trap_rx_packets_get $trap_name)\n\tt0_bytes=$(devlink_trap_rx_bytes_get $trap_name)\n\n\t# Generate packets to h2 through br0 RIF that will be removed later\n\t$MZ $h1 -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -a own -b $rp1mac \\\n\t\t-B $h2_ipv4 -q &\n\tmz_pid=$!\n\n\t# Wait before removing br0 RIF to allow packets to go into the bridge.\n\tsleep 1\n\n\t# Flushing address will dismantle the RIF\n\tip address flush dev br0\n\n\tt1_packets=$(devlink_trap_rx_packets_get $trap_name)\n\tt1_bytes=$(devlink_trap_rx_bytes_get $trap_name)\n\n\tif [[ $t0_packets -eq $t1_packets && $t0_bytes -eq $t1_bytes ]]; then\n\t\tcheck_err 1 \"Trap stats idle when packets should be trapped\"\n\tfi\n\n\tlog_test \"Ingress RIF disabled\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\tip link set dev $rp1 nomaster\n\t__addr_add_del $rp1 add 192.0.2.2/24 2001:db8:1::2/64\n\tip link del dev br0 type bridge\n\tdevlink_trap_action_set $trap_name \"drop\"\n}\n\nerif_disabled_test()\n{\n\tlocal trap_name=\"erif_disabled\"\n\tlocal t0_packets t0_bytes\n\tlocal t1_packets t1_bytes\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\n\tdevlink_trap_action_set $trap_name \"trap\"\n\tip link add dev br0 type bridge\n\tip add flush dev $rp1\n\tip link set dev $rp1 master br0\n\t__addr_add_del br0 add 192.0.2.2/24\n\tip link set dev br0 up\n\n\tt0_packets=$(devlink_trap_rx_packets_get $trap_name)\n\tt0_bytes=$(devlink_trap_rx_bytes_get $trap_name)\n\n\trp2mac=$(mac_get $rp2)\n\n\t# Generate packets that should go out through br0 RIF that will be\n\t# removed later\n\t$MZ $h2 -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -a own -b $rp2mac \\\n\t\t-B 192.0.2.1 -q &\n\tmz_pid=$!\n\n\tsleep 5\n\t# Unlinking the port from the bridge will disable the RIF associated\n\t# with br0 as it is no longer an upper of any mlxsw port.\n\tip link set dev $rp1 nomaster\n\n\tt1_packets=$(devlink_trap_rx_packets_get $trap_name)\n\tt1_bytes=$(devlink_trap_rx_bytes_get $trap_name)\n\n\tif [[ $t0_packets -eq $t1_packets && $t0_bytes -eq $t1_bytes ]]; then\n\t\tcheck_err 1 \"Trap stats idle when packets should be trapped\"\n\tfi\n\n\tlog_test \"Egress RIF disabled\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\t__addr_add_del $rp1 add 192.0.2.2/24 2001:db8:1::2/64\n\tip link del dev br0 type bridge\n\tdevlink_trap_action_set $trap_name \"drop\"\n}\n\n__blackhole_nexthop_test()\n{\n\tlocal flags=$1; shift\n\tlocal subnet=$1; shift\n\tlocal proto=$1; shift\n\tlocal dip=$1; shift\n\tlocal trap_name=\"blackhole_nexthop\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tip -$flags nexthop add id 1 blackhole\n\tip -$flags route add $subnet nhid 1\n\ttc filter add dev $rp2 egress protocol $proto pref 1 handle 101 \\\n\t\tflower skip_hw dst_ip $dip ip_proto udp action drop\n\n\t# Generate packets to the blackhole nexthop\n\t$MZ $h1 -$flags -t udp \"sp=54321,dp=12345\" -c 0 -p 100 -b $rp1mac \\\n\t\t-B $dip -d 1msec -q &\n\tmz_pid=$!\n\n\tdevlink_trap_drop_test $trap_name $rp2 101\n\tlog_test \"Blackhole nexthop: IPv$flags\"\n\n\tdevlink_trap_drop_cleanup $mz_pid $rp2 $proto 1 101\n\tip -$flags route del $subnet\n\tip -$flags nexthop del id 1\n}\n\nblackhole_nexthop_test()\n{\n\t__blackhole_nexthop_test \"4\" \"198.51.100.0/30\" \"ip\" $h2_ipv4\n\t__blackhole_nexthop_test \"6\" \"2001:db8:2::/120\" \"ipv6\" $h2_ipv6\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}