{
  "module_name": "tc_flower.sh",
  "hash_id": "2f6bcfd1b64349464f730199f5421918497e59a29c99bbd57a71772476618b02",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/tc_flower.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# This test is for checking the A-TCAM and C-TCAM operation in Spectrum-2.\n# It tries to exercise as many code paths in the eRP state machine as\n# possible.\n\nlib_dir=$(dirname $0)/../../../../net/forwarding\n\nALL_TESTS=\"single_mask_test identical_filters_test two_masks_test \\\n\tmultiple_masks_test ctcam_edge_cases_test delta_simple_test \\\n\tdelta_two_masks_one_key_test delta_simple_rehash_test \\\n\tbloom_simple_test bloom_complex_test bloom_delta_test \\\n\tmax_erp_entries_test max_group_size_test\"\nNUM_NETIFS=2\nsource $lib_dir/lib.sh\nsource $lib_dir/tc_common.sh\nsource $lib_dir/devlink_lib.sh\n\ntcflags=\"skip_hw\"\n\nh1_create()\n{\n\tsimple_if_init $h1 192.0.2.1/24 198.51.100.1/24\n}\n\nh1_destroy()\n{\n\tsimple_if_fini $h1 192.0.2.1/24 198.51.100.1/24\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 192.0.2.2/24 198.51.100.2/24\n\ttc qdisc add dev $h2 clsact\n}\n\nh2_destroy()\n{\n\ttc qdisc del dev $h2 clsact\n\tsimple_if_fini $h2 192.0.2.2/24 198.51.100.2/24\n}\n\ntp_record()\n{\n\tlocal tracepoint=$1\n\tlocal cmd=$2\n\n\tperf record -q -e $tracepoint $cmd\n\treturn $?\n}\n\ntp_record_all()\n{\n\tlocal tracepoint=$1\n\tlocal seconds=$2\n\n\tperf record -a -q -e $tracepoint sleep $seconds\n\treturn $?\n}\n\n__tp_hit_count()\n{\n\tlocal tracepoint=$1\n\n\tlocal perf_output=`perf script -F trace:event,trace`\n\treturn `echo $perf_output | grep \"$tracepoint:\" | wc -l`\n}\n\ntp_check_hits()\n{\n\tlocal tracepoint=$1\n\tlocal count=$2\n\n\t__tp_hit_count $tracepoint\n\tif [[ \"$?\" -ne \"$count\" ]]; then\n\t\treturn 1\n\tfi\n\treturn 0\n}\n\ntp_check_hits_any()\n{\n\tlocal tracepoint=$1\n\n\t__tp_hit_count $tracepoint\n\tif [[ \"$?\" -eq \"0\" ]]; then\n\t\treturn 1\n\tfi\n\treturn 0\n}\n\nsingle_mask_test()\n{\n\t# When only a single mask is required, the device uses the master\n\t# mask and not the eRP table. Verify that under this mode the right\n\t# filter is matched\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_err $? \"Single filter - did not match\"\n\n\ttc filter add dev $h2 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 198.51.100.2 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 2\n\tcheck_err $? \"Two filters - did not match highest priority\"\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 198.51.100.1 -B 198.51.100.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Two filters - did not match lowest priority\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 198.51.100.1 -B 198.51.100.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 2\n\tcheck_err $? \"Single filter - did not match after delete\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\n\tlog_test \"single mask test ($tcflags)\"\n}\n\nidentical_filters_test()\n{\n\t# When two filters that only differ in their priority are used,\n\t# one needs to be inserted into the C-TCAM. This test verifies\n\t# that filters are correctly spilled to C-TCAM and that the right\n\t# filter is matched\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\ttc filter add dev $h2 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_err $? \"Did not match A-TCAM filter\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Did not match C-TCAM filter after A-TCAM delete\"\n\n\ttc filter add dev $h2 ingress protocol ip pref 3 handle 103 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 2\n\tcheck_err $? \"Did not match C-TCAM filter after A-TCAM add\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_err $? \"Did not match A-TCAM filter after C-TCAM delete\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 3 handle 103 flower\n\n\tlog_test \"identical filters test ($tcflags)\"\n}\n\ntwo_masks_test()\n{\n\t# When more than one mask is required, the eRP table is used. This\n\t# test verifies that the eRP table is correctly allocated and used\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\ttc filter add dev $h2 ingress protocol ip pref 3 handle 103 flower \\\n\t\t$tcflags dst_ip 192.0.0.0/8 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_err $? \"Two filters - did not match highest priority\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_err $? \"Single filter - did not match\"\n\n\ttc filter add dev $h2 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 192.0.2.0/24 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Two filters - did not match highest priority after add\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 3 handle 103 flower\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\n\tlog_test \"two masks test ($tcflags)\"\n}\n\nmultiple_masks_test()\n{\n\t# The number of masks in a region is limited. Once the maximum\n\t# number of masks has been reached filters that require new\n\t# masks are spilled to the C-TCAM. This test verifies that\n\t# spillage is performed correctly and that the right filter is\n\t# matched\n\n\tif [[ \"$tcflags\" != \"skip_sw\" ]]; then\n\t\treturn 0;\n\tfi\n\n\tlocal index\n\n\tRET=0\n\n\tNUM_MASKS=32\n\tNUM_ERPS=16\n\tBASE_INDEX=100\n\n\tfor i in $(eval echo {1..$NUM_MASKS}); do\n\t\tindex=$((BASE_INDEX - i))\n\n\t\tif ((i > NUM_ERPS)); then\n\t\t\texp_hits=1\n\t\t\terr_msg=\"$i filters - C-TCAM spill did not happen when it was expected\"\n\t\telse\n\t\t\texp_hits=0\n\t\t\terr_msg=\"$i filters - C-TCAM spill happened when it should not\"\n\t\tfi\n\n\t\ttp_record \"mlxsw:mlxsw_sp_acl_atcam_entry_add_ctcam_spill\" \\\n\t\t\t\"tc filter add dev $h2 ingress protocol ip pref $index \\\n\t\t\t\thandle $index \\\n\t\t\t\tflower $tcflags \\\n\t\t\t\tdst_ip 192.0.2.2/${i} src_ip 192.0.2.1/${i} \\\n\t\t\t\taction drop\"\n\t\ttp_check_hits \"mlxsw:mlxsw_sp_acl_atcam_entry_add_ctcam_spill\" \\\n\t\t\t\t$exp_hits\n\t\tcheck_err $? \"$err_msg\"\n\n\t\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 \\\n\t\t\t-B 192.0.2.2 -t ip -q\n\n\t\ttc_check_packets \"dev $h2 ingress\" $index 1\n\t\tcheck_err $? \"$i filters - did not match highest priority (add)\"\n\tdone\n\n\tfor i in $(eval echo {$NUM_MASKS..1}); do\n\t\tindex=$((BASE_INDEX - i))\n\n\t\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 \\\n\t\t\t-B 192.0.2.2 -t ip -q\n\n\t\ttc_check_packets \"dev $h2 ingress\" $index 2\n\t\tcheck_err $? \"$i filters - did not match highest priority (del)\"\n\n\t\ttc filter del dev $h2 ingress protocol ip pref $index \\\n\t\t\thandle $index flower\n\tdone\n\n\tlog_test \"multiple masks test ($tcflags)\"\n}\n\nctcam_two_atcam_masks_test()\n{\n\tRET=0\n\n\t# First case: C-TCAM is disabled when there are two A-TCAM masks.\n\t# We push a filter into the C-TCAM by using two identical filters\n\t# as in identical_filters_test()\n\n\t# Filter goes into A-TCAM\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\t# Filter goes into C-TCAM\n\ttc filter add dev $h2 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\t# Filter goes into A-TCAM\n\ttc filter add dev $h2 ingress protocol ip pref 3 handle 103 flower \\\n\t\t$tcflags dst_ip 192.0.0.0/16 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_err $? \"Did not match A-TCAM filter\"\n\n\t# Delete both A-TCAM and C-TCAM filters and make sure the remaining\n\t# A-TCAM filter still works\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_err $? \"Did not match A-TCAM filter\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 3 handle 103 flower\n\n\tlog_test \"ctcam with two atcam masks test ($tcflags)\"\n}\n\nctcam_one_atcam_mask_test()\n{\n\tRET=0\n\n\t# Second case: C-TCAM is disabled when there is one A-TCAM mask.\n\t# The test is similar to identical_filters_test()\n\n\t# Filter goes into A-TCAM\n\ttc filter add dev $h2 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\t# Filter goes into C-TCAM\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_err $? \"Did not match C-TCAM filter\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Did not match A-TCAM filter\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\n\tlog_test \"ctcam with one atcam mask test ($tcflags)\"\n}\n\nctcam_no_atcam_masks_test()\n{\n\tRET=0\n\n\t# Third case: C-TCAM is disabled when there are no A-TCAM masks\n\t# This test exercises the code path that transitions the eRP table\n\t# to its initial state after deleting the last C-TCAM mask\n\n\t# Filter goes into A-TCAM\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\t# Filter goes into C-TCAM\n\ttc filter add dev $h2 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\n\tlog_test \"ctcam with no atcam masks test ($tcflags)\"\n}\n\nctcam_edge_cases_test()\n{\n\t# When the C-TCAM is disabled after deleting the last C-TCAM\n\t# mask, we want to make sure the eRP state machine is put in\n\t# the correct state\n\n\tctcam_two_atcam_masks_test\n\tctcam_one_atcam_mask_test\n\tctcam_no_atcam_masks_test\n}\n\ndelta_simple_test()\n{\n\t# The first filter will create eRP, the second filter will fit into\n\t# the first eRP with delta. Remove the first rule then and check that\n        # the eRP stays (referenced by the second filter).\n\n\tRET=0\n\n\tif [[ \"$tcflags\" != \"skip_sw\" ]]; then\n\t\treturn 0;\n\tfi\n\n\ttp_record \"objagg:*\" \"tc filter add dev $h2 ingress protocol ip \\\n\t\t   pref 1 handle 101 flower $tcflags dst_ip 192.0.0.0/24 \\\n\t\t   action drop\"\n\ttp_check_hits \"objagg:objagg_obj_root_create\" 1\n\tcheck_err $? \"eRP was not created\"\n\n\ttp_record \"objagg:*\" \"tc filter add dev $h2 ingress protocol ip \\\n\t\t   pref 2 handle 102 flower $tcflags dst_ip 192.0.2.2 \\\n\t\t   action drop\"\n\ttp_check_hits \"objagg:objagg_obj_root_create\" 0\n\tcheck_err $? \"eRP was incorrectly created\"\n\ttp_check_hits \"objagg:objagg_obj_parent_assign\" 1\n\tcheck_err $? \"delta was not created\"\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_fail $? \"Matched a wrong filter\"\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Did not match on correct filter\"\n\n\ttp_record \"objagg:*\" \"tc filter del dev $h2 ingress protocol ip \\\n\t\t   pref 1 handle 101 flower\"\n\ttp_check_hits \"objagg:objagg_obj_root_destroy\" 0\n\tcheck_err $? \"eRP was incorrectly destroyed\"\n\ttp_check_hits \"objagg:objagg_obj_parent_unassign\" 0\n\tcheck_err $? \"delta was incorrectly destroyed\"\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 2\n\tcheck_err $? \"Did not match on correct filter after the first was removed\"\n\n\ttp_record \"objagg:*\" \"tc filter del dev $h2 ingress protocol ip \\\n\t\t   pref 2 handle 102 flower\"\n\ttp_check_hits \"objagg:objagg_obj_parent_unassign\" 1\n\tcheck_err $? \"delta was not destroyed\"\n\ttp_check_hits \"objagg:objagg_obj_root_destroy\" 1\n\tcheck_err $? \"eRP was not destroyed\"\n\n\tlog_test \"delta simple test ($tcflags)\"\n}\n\ndelta_two_masks_one_key_test()\n{\n\t# If 2 keys are the same and only differ in mask in a way that\n\t# they belong under the same ERP (second is delta of the first),\n\t# there should be no C-TCAM spill.\n\n\tRET=0\n\n\tif [[ \"$tcflags\" != \"skip_sw\" ]]; then\n\t\treturn 0;\n\tfi\n\n\ttp_record \"mlxsw:*\" \"tc filter add dev $h2 ingress protocol ip \\\n\t\t   pref 1 handle 101 flower $tcflags dst_ip 192.0.2.0/24 \\\n\t\t   action drop\"\n\ttp_check_hits \"mlxsw:mlxsw_sp_acl_atcam_entry_add_ctcam_spill\" 0\n\tcheck_err $? \"incorrect C-TCAM spill while inserting the first rule\"\n\n\ttp_record \"mlxsw:*\" \"tc filter add dev $h2 ingress protocol ip \\\n\t\t   pref 2 handle 102 flower $tcflags dst_ip 192.0.2.2 \\\n\t\t   action drop\"\n\ttp_check_hits \"mlxsw:mlxsw_sp_acl_atcam_entry_add_ctcam_spill\" 0\n\tcheck_err $? \"incorrect C-TCAM spill while inserting the second rule\"\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_err $? \"Did not match on correct filter\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Did not match on correct filter\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\n\tlog_test \"delta two masks one key test ($tcflags)\"\n}\n\ndelta_simple_rehash_test()\n{\n\tRET=0\n\n\tif [[ \"$tcflags\" != \"skip_sw\" ]]; then\n\t\treturn 0;\n\tfi\n\n\tdevlink dev param set $DEVLINK_DEV \\\n\t\tname acl_region_rehash_interval cmode runtime value 0\n\tcheck_err $? \"Failed to set ACL region rehash interval\"\n\n\ttp_record_all mlxsw:mlxsw_sp_acl_tcam_vregion_rehash 7\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_rehash\n\tcheck_fail $? \"Rehash trace was hit even when rehash should be disabled\"\n\n\tdevlink dev param set $DEVLINK_DEV \\\n\t\tname acl_region_rehash_interval cmode runtime value 3000\n\tcheck_err $? \"Failed to set ACL region rehash interval\"\n\n\tsleep 1\n\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 192.0.1.0/25 action drop\n\ttc filter add dev $h2 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\ttc filter add dev $h2 ingress protocol ip pref 3 handle 103 flower \\\n\t\t$tcflags dst_ip 192.0.3.0/24 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_fail $? \"Matched a wrong filter\"\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_fail $? \"Matched a wrong filter\"\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Did not match on correct filter\"\n\n\ttp_record_all mlxsw:* 3\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_rehash\n\tcheck_err $? \"Rehash trace was not hit\"\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_migrate\n\tcheck_err $? \"Migrate trace was not hit\"\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_migrate_end\n\tcheck_err $? \"Migrate end trace was not hit\"\n\ttp_record_all mlxsw:* 3\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_rehash\n\tcheck_err $? \"Rehash trace was not hit\"\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_migrate\n\tcheck_fail $? \"Migrate trace was hit when no migration should happen\"\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_migrate_end\n\tcheck_fail $? \"Migrate end trace was hit when no migration should happen\"\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_fail $? \"Matched a wrong filter after rehash\"\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_fail $? \"Matched a wrong filter after rehash\"\n\n\ttc_check_packets \"dev $h2 ingress\" 102 2\n\tcheck_err $? \"Did not match on correct filter after rehash\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 3 handle 103 flower\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\n\tlog_test \"delta simple rehash test ($tcflags)\"\n}\n\ndelta_simple_ipv6_rehash_test()\n{\n\tRET=0\n\n\tif [[ \"$tcflags\" != \"skip_sw\" ]]; then\n\t\treturn 0;\n\tfi\n\n\tdevlink dev param set $DEVLINK_DEV \\\n\t\tname acl_region_rehash_interval cmode runtime value 0\n\tcheck_err $? \"Failed to set ACL region rehash interval\"\n\n\ttp_record_all mlxsw:mlxsw_sp_acl_tcam_vregion_rehash 7\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_rehash\n\tcheck_fail $? \"Rehash trace was hit even when rehash should be disabled\"\n\n\tdevlink dev param set $DEVLINK_DEV \\\n\t\tname acl_region_rehash_interval cmode runtime value 3000\n\tcheck_err $? \"Failed to set ACL region rehash interval\"\n\n\tsleep 1\n\n\ttc filter add dev $h2 ingress protocol ipv6 pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 2001:db8:1::0/121 action drop\n\ttc filter add dev $h2 ingress protocol ipv6 pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 2001:db8:2::2 action drop\n\ttc filter add dev $h2 ingress protocol ipv6 pref 3 handle 103 flower \\\n\t\t$tcflags dst_ip 2001:db8:3::0/120 action drop\n\n\t$MZ $h1 -6 -c 1 -p 64 -a $h1mac -b $h2mac \\\n\t\t-A 2001:db8:2::1 -B 2001:db8:2::2 -t udp -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_fail $? \"Matched a wrong filter\"\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_fail $? \"Matched a wrong filter\"\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Did not match on correct filter\"\n\n\ttp_record_all mlxsw:* 3\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_rehash\n\tcheck_err $? \"Rehash trace was not hit\"\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_migrate\n\tcheck_err $? \"Migrate trace was not hit\"\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_migrate_end\n\tcheck_err $? \"Migrate end trace was not hit\"\n\ttp_record_all mlxsw:* 3\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_rehash\n\tcheck_err $? \"Rehash trace was not hit\"\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_migrate\n\tcheck_fail $? \"Migrate trace was hit when no migration should happen\"\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_migrate_end\n\tcheck_fail $? \"Migrate end trace was hit when no migration should happen\"\n\n\t$MZ $h1 -6 -c 1 -p 64 -a $h1mac -b $h2mac \\\n\t\t-A 2001:db8:2::1 -B 2001:db8:2::2 -t udp -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_fail $? \"Matched a wrong filter after rehash\"\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_fail $? \"Matched a wrong filter after rehash\"\n\n\ttc_check_packets \"dev $h2 ingress\" 102 2\n\tcheck_err $? \"Did not match on correct filter after rehash\"\n\n\ttc filter del dev $h2 ingress protocol ipv6 pref 3 handle 103 flower\n\ttc filter del dev $h2 ingress protocol ipv6 pref 2 handle 102 flower\n\ttc filter del dev $h2 ingress protocol ipv6 pref 1 handle 101 flower\n\n\tlog_test \"delta simple IPv6 rehash test ($tcflags)\"\n}\n\nTEST_RULE_BASE=256\ndeclare -a test_rules_inserted\n\ntest_rule_add()\n{\n\tlocal iface=$1\n\tlocal tcflags=$2\n\tlocal index=$3\n\n\tif ! [ ${test_rules_inserted[$index]} ] ; then\n\t\ttest_rules_inserted[$index]=false\n\tfi\n\tif ${test_rules_inserted[$index]} ; then\n\t\treturn\n\tfi\n\n\tlocal number=$(( $index + $TEST_RULE_BASE ))\n\tprintf -v hexnumber '%x' $number\n\n\tbatch=\"${batch}filter add dev $iface ingress protocol ipv6 pref 1 \\\n\t\thandle $number flower $tcflags \\\n\t\tsrc_ip 2001:db8:1::$hexnumber action drop\\n\"\n\ttest_rules_inserted[$index]=true\n}\n\ntest_rule_del()\n{\n\tlocal iface=$1\n\tlocal index=$2\n\n\tif ! [ ${test_rules_inserted[$index]} ] ; then\n\t\ttest_rules_inserted[$index]=false\n\tfi\n\tif ! ${test_rules_inserted[$index]} ; then\n\t\treturn\n\tfi\n\n\tlocal number=$(( $index + $TEST_RULE_BASE ))\n\tprintf -v hexnumber '%x' $number\n\n\tbatch=\"${batch}filter del dev $iface ingress protocol ipv6 pref 1 \\\n\t\thandle $number flower\\n\"\n\ttest_rules_inserted[$index]=false\n}\n\ntest_rule_add_or_remove()\n{\n\tlocal iface=$1\n\tlocal tcflags=$2\n\tlocal index=$3\n\n\tif ! [ ${test_rules_inserted[$index]} ] ; then\n\t\ttest_rules_inserted[$index]=false\n\tfi\n\tif ${test_rules_inserted[$index]} ; then\n\t\ttest_rule_del $iface $index\n\telse\n\t\ttest_rule_add $iface $tcflags $index\n\tfi\n}\n\ntest_rule_add_or_remove_random_batch()\n{\n\tlocal iface=$1\n\tlocal tcflags=$2\n\tlocal total_count=$3\n\tlocal skip=0\n\tlocal count=0\n\tlocal MAXSKIP=20\n\tlocal MAXCOUNT=20\n\n\tfor ((i=1;i<=total_count;i++)); do\n\t\tif (( $skip == 0 )) && (($count == 0)); then\n\t\t\t((skip=$RANDOM % $MAXSKIP + 1))\n\t\t\t((count=$RANDOM % $MAXCOUNT + 1))\n\t\tfi\n\t\tif (( $skip != 0 )); then\n\t\t\t((skip-=1))\n\t\telse\n\t\t\t((count-=1))\n\t\t\ttest_rule_add_or_remove $iface $tcflags $i\n\t\tfi\n\tdone\n}\n\ndelta_massive_ipv6_rehash_test()\n{\n\tRET=0\n\n\tif [[ \"$tcflags\" != \"skip_sw\" ]]; then\n\t\treturn 0;\n\tfi\n\n\tdevlink dev param set $DEVLINK_DEV \\\n\t\tname acl_region_rehash_interval cmode runtime value 0\n\tcheck_err $? \"Failed to set ACL region rehash interval\"\n\n\ttp_record_all mlxsw:mlxsw_sp_acl_tcam_vregion_rehash 7\n\ttp_check_hits_any mlxsw:mlxsw_sp_acl_tcam_vregion_rehash\n\tcheck_fail $? \"Rehash trace was hit even when rehash should be disabled\"\n\n\tRANDOM=4432897\n\tdeclare batch=\"\"\n\ttest_rule_add_or_remove_random_batch $h2 $tcflags 5000\n\n\techo -n -e $batch | tc -b -\n\n\tdeclare batch=\"\"\n\ttest_rule_add_or_remove_random_batch $h2 $tcflags 5000\n\n\tdevlink dev param set $DEVLINK_DEV \\\n\t\tname acl_region_rehash_interval cmode runtime value 3000\n\tcheck_err $? \"Failed to set ACL region rehash interval\"\n\n\tsleep 1\n\n\ttc filter add dev $h2 ingress protocol ipv6 pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 2001:db8:1::0/121 action drop\n\ttc filter add dev $h2 ingress protocol ipv6 pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 2001:db8:2::2 action drop\n\ttc filter add dev $h2 ingress protocol ipv6 pref 3 handle 103 flower \\\n\t\t$tcflags dst_ip 2001:db8:3::0/120 action drop\n\n\t$MZ $h1 -6 -c 1 -p 64 -a $h1mac -b $h2mac \\\n\t\t-A 2001:db8:2::1 -B 2001:db8:2::2 -t udp -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_fail $? \"Matched a wrong filter\"\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_fail $? \"Matched a wrong filter\"\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Did not match on correct filter\"\n\n\techo -n -e $batch | tc -b -\n\n\tdevlink dev param set $DEVLINK_DEV \\\n\t\tname acl_region_rehash_interval cmode runtime value 0\n\tcheck_err $? \"Failed to set ACL region rehash interval\"\n\n\t$MZ $h1 -6 -c 1 -p 64 -a $h1mac -b $h2mac \\\n\t\t-A 2001:db8:2::1 -B 2001:db8:2::2 -t udp -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_fail $? \"Matched a wrong filter after rehash\"\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_fail $? \"Matched a wrong filter after rehash\"\n\n\ttc_check_packets \"dev $h2 ingress\" 102 2\n\tcheck_err $? \"Did not match on correct filter after rehash\"\n\n\ttc filter del dev $h2 ingress protocol ipv6 pref 3 handle 103 flower\n\ttc filter del dev $h2 ingress protocol ipv6 pref 2 handle 102 flower\n\ttc filter del dev $h2 ingress protocol ipv6 pref 1 handle 101 flower\n\n\tdeclare batch=\"\"\n\tfor i in {1..5000}; do\n\t\ttest_rule_del $h2 $tcflags $i\n\tdone\n\techo -e $batch | tc -b -\n\n\tlog_test \"delta massive IPv6 rehash test ($tcflags)\"\n}\n\nbloom_simple_test()\n{\n\t# Bloom filter requires that the eRP table is used. This test\n\t# verifies that Bloom filter is not harming correctness of ACLs.\n\t# First, make sure that eRP table is used and then set rule patterns\n\t# which are distant enough and will result skipping a lookup after\n\t# consulting the Bloom filter. Although some eRP lookups are skipped,\n\t# the correct filter should be hit.\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\ttc filter add dev $h2 ingress protocol ip pref 5 handle 104 flower \\\n\t\t$tcflags dst_ip 198.51.100.2 action drop\n\ttc filter add dev $h2 ingress protocol ip pref 3 handle 103 flower \\\n\t\t$tcflags dst_ip 192.0.0.0/8 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_err $? \"Two filters - did not match highest priority\"\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 198.51.100.1 -B 198.51.100.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 104 1\n\tcheck_err $? \"Single filter - did not match\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_err $? \"Low prio filter - did not match\"\n\n\ttc filter add dev $h2 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 198.0.0.0/8 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 198.51.100.1 -B 198.51.100.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Two filters - did not match highest priority after add\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 3 handle 103 flower\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\ttc filter del dev $h2 ingress protocol ip pref 5 handle 104 flower\n\n\tlog_test \"bloom simple test ($tcflags)\"\n}\n\nbloom_complex_test()\n{\n\t# Bloom filter index computation is affected from region ID, eRP\n\t# ID and from the region key size. In order to excercise those parts\n\t# of the Bloom filter code, use a series of regions, each with a\n\t# different key size and send packet that should hit all of them.\n\tlocal index\n\n\tRET=0\n\tNUM_CHAINS=4\n\tBASE_INDEX=100\n\n\t# Create chain with up to 2 key blocks (ip_proto only)\n\ttc chain add dev $h2 ingress chain 1 protocol ip flower \\\n\t\tip_proto tcp &> /dev/null\n\t# Create chain with 2-4 key blocks (ip_proto, src MAC)\n\ttc chain add dev $h2 ingress chain 2 protocol ip flower \\\n\t\tip_proto tcp \\\n\t\tsrc_mac 00:00:00:00:00:00/FF:FF:FF:FF:FF:FF &> /dev/null\n\t# Create chain with 4-8 key blocks (ip_proto, src & dst MAC, IPv4 dest)\n\ttc chain add dev $h2 ingress chain 3 protocol ip flower \\\n\t\tip_proto tcp \\\n\t\tdst_mac 00:00:00:00:00:00/FF:FF:FF:FF:FF:FF \\\n\t\tsrc_mac 00:00:00:00:00:00/FF:FF:FF:FF:FF:FF \\\n\t\tdst_ip 0.0.0.0/32 &> /dev/null\n\t# Default chain contains all fields and therefore is 8-12 key blocks\n\ttc chain add dev $h2 ingress chain 4\n\n\t# We need at least 2 rules in every region to have eRP table active\n\t# so create a dummy rule per chain using a different pattern\n\tfor i in $(eval echo {0..$NUM_CHAINS}); do\n\t\tindex=$((BASE_INDEX - 1 - i))\n\t\ttc filter add dev $h2 ingress chain $i protocol ip \\\n\t\t\tpref 2 handle $index flower \\\n\t\t\t$tcflags ip_proto tcp action drop\n\tdone\n\n\t# Add rules to test Bloom filter, each in a different chain\n\tindex=$BASE_INDEX\n\ttc filter add dev $h2 ingress protocol ip \\\n\t\tpref 1 handle $((++index)) flower \\\n\t\t$tcflags dst_ip 192.0.0.0/16 action goto chain 1\n\ttc filter add dev $h2 ingress chain 1 protocol ip \\\n\t\tpref 1 handle $((++index)) flower \\\n\t\t$tcflags action goto chain 2\n\ttc filter add dev $h2 ingress chain 2 protocol ip \\\n\t\tpref 1 handle $((++index)) flower \\\n\t\t$tcflags src_mac $h1mac action goto chain 3\n\ttc filter add dev $h2 ingress chain 3 protocol ip \\\n\t\tpref 1 handle $((++index)) flower \\\n\t\t$tcflags dst_ip 192.0.0.0/8 action goto chain 4\n\ttc filter add dev $h2 ingress chain 4 protocol ip \\\n\t\tpref 1 handle $((++index)) flower \\\n\t\t$tcflags src_ip 192.0.2.0/24 action drop\n\n\t# Send a packet that is supposed to hit all chains\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\tfor i in $(eval echo {0..$NUM_CHAINS}); do\n\t\tindex=$((BASE_INDEX + i + 1))\n\t\ttc_check_packets \"dev $h2 ingress\" $index 1\n\t\tcheck_err $? \"Did not match chain $i\"\n\tdone\n\n\t# Rules cleanup\n\tfor i in $(eval echo {$NUM_CHAINS..0}); do\n\t\tindex=$((BASE_INDEX - i - 1))\n\t\ttc filter del dev $h2 ingress chain $i \\\n\t\t\tpref 2 handle $index flower\n\t\tindex=$((BASE_INDEX + i + 1))\n\t\ttc filter del dev $h2 ingress chain $i \\\n\t\t\tpref 1 handle $index flower\n\tdone\n\n\t# Chains cleanup\n\tfor i in $(eval echo {$NUM_CHAINS..1}); do\n\t\ttc chain del dev $h2 ingress chain $i\n\tdone\n\n\tlog_test \"bloom complex test ($tcflags)\"\n}\n\n\nbloom_delta_test()\n{\n\t# When multiple masks are used, the eRP table is activated. When\n\t# masks are close enough (delta) the masks reside on the same\n\t# eRP table. This test verifies that the eRP table is correctly\n\t# allocated and used in delta condition and that Bloom filter is\n\t# still functional with delta.\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ip pref 3 handle 103 flower \\\n\t\t$tcflags dst_ip 192.1.0.0/16 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.1.2.1 -B 192.1.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 103 1\n\tcheck_err $? \"Single filter - did not match\"\n\n\ttc filter add dev $h2 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 192.2.1.0/24 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.2.1.1 -B 192.2.1.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 102 1\n\tcheck_err $? \"Delta filters - did not match second filter\"\n\n\ttc filter del dev $h2 ingress protocol ip pref 3 handle 103 flower\n\ttc filter del dev $h2 ingress protocol ip pref 2 handle 102 flower\n\n\tlog_test \"bloom delta test ($tcflags)\"\n}\n\nmax_erp_entries_test()\n{\n\t# The number of eRP entries is limited. Once the maximum number of eRPs\n\t# has been reached, filters cannot be added. This test verifies that\n\t# when this limit is reached, inserstion fails without crashing.\n\n\tRET=0\n\n\tlocal num_masks=32\n\tlocal num_regions=15\n\tlocal chain_failed\n\tlocal mask_failed\n\tlocal ret\n\n\tif [[ \"$tcflags\" != \"skip_sw\" ]]; then\n\t\treturn 0;\n\tfi\n\n\tfor ((i=1; i < $num_regions; i++)); do\n\t\tfor ((j=$num_masks; j >= 0; j--)); do\n\t\t\ttc filter add dev $h2 ingress chain $i protocol ip \\\n\t\t\t\tpref $i\thandle $j flower $tcflags \\\n\t\t\t\tdst_ip 192.1.0.0/$j &> /dev/null\n\t\t\tret=$?\n\n\t\t\tif [ $ret -ne 0 ]; then\n\t\t\t\tchain_failed=$i\n\t\t\t\tmask_failed=$j\n\t\t\t\tbreak 2\n\t\t\tfi\n\t\tdone\n\tdone\n\n\t# We expect to exceed the maximum number of eRP entries, so that\n\t# insertion eventually fails. Otherwise, the test should be adjusted to\n\t# add more filters.\n\tcheck_fail $ret \"expected to exceed number of eRP entries\"\n\n\tfor ((; i >= 1; i--)); do\n\t\tfor ((j=0; j <= $num_masks; j++)); do\n\t\t\ttc filter del dev $h2 ingress chain $i protocol ip \\\n\t\t\t\tpref $i handle $j flower &> /dev/null\n\t\tdone\n\tdone\n\n\tlog_test \"max eRP entries test ($tcflags). \" \\\n\t\t\"max chain $chain_failed, mask $mask_failed\"\n}\n\nmax_group_size_test()\n{\n\t# The number of ACLs in an ACL group is limited. Once the maximum\n\t# number of ACLs has been reached, filters cannot be added. This test\n\t# verifies that when this limit is reached, insertion fails without\n\t# crashing.\n\n\tRET=0\n\n\tlocal num_acls=32\n\tlocal max_size\n\tlocal ret\n\n\tif [[ \"$tcflags\" != \"skip_sw\" ]]; then\n\t\treturn 0;\n\tfi\n\n\tfor ((i=1; i < $num_acls; i++)); do\n\t\tif [[ $(( i % 2 )) == 1 ]]; then\n\t\t\ttc filter add dev $h2 ingress pref $i proto ipv4 \\\n\t\t\t\tflower $tcflags dst_ip 198.51.100.1/32 \\\n\t\t\t\tip_proto tcp tcp_flags 0x01/0x01 \\\n\t\t\t\taction drop &> /dev/null\n\t\telse\n\t\t\ttc filter add dev $h2 ingress pref $i proto ipv6 \\\n\t\t\t\tflower $tcflags dst_ip 2001:db8:1::1/128 \\\n\t\t\t\taction drop &> /dev/null\n\t\tfi\n\n\t\tret=$?\n\t\t[[ $ret -ne 0 ]] && max_size=$((i - 1)) && break\n\tdone\n\n\t# We expect to exceed the maximum number of ACLs in a group, so that\n\t# insertion eventually fails. Otherwise, the test should be adjusted to\n\t# add more filters.\n\tcheck_fail $ret \"expected to exceed number of ACLs in a group\"\n\n\tfor ((; i >= 1; i--)); do\n\t\tif [[ $(( i % 2 )) == 1 ]]; then\n\t\t\ttc filter del dev $h2 ingress pref $i proto ipv4 \\\n\t\t\t\tflower $tcflags dst_ip 198.51.100.1/32 \\\n\t\t\t\tip_proto tcp tcp_flags 0x01/0x01 \\\n\t\t\t\taction drop &> /dev/null\n\t\telse\n\t\t\ttc filter del dev $h2 ingress pref $i proto ipv6 \\\n\t\t\t\tflower $tcflags dst_ip 2001:db8:1::1/128 \\\n\t\t\t\taction drop &> /dev/null\n\t\tfi\n\tdone\n\n\tlog_test \"max ACL group size test ($tcflags). max size $max_size\"\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\th2=${NETIFS[p2]}\n\th1mac=$(mac_get $h1)\n\th2mac=$(mac_get $h2)\n\n\tvrf_prepare\n\n\th1_create\n\th2_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nif ! tc_offload_check; then\n\tcheck_err 1 \"Could not test offloaded functionality\"\n\tlog_test \"mlxsw-specific tests for tc flower\"\n\texit\nelse\n\ttcflags=\"skip_sw\"\n\ttests_run\nfi\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}