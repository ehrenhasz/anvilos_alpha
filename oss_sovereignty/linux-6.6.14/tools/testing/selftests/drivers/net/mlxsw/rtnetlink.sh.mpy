{
  "module_name": "rtnetlink.sh",
  "hash_id": "e7484a9dc5e94419b8812d11e65e5c870587cfb2ca4fe72d1360e1a74f02103a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/rtnetlink.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test various interface configuration scenarios. Observe that configurations\n# deemed valid by mlxsw succeed, invalid configurations fail and that no traces\n# are produced. To prevent the test from passing in case traces are produced,\n# the user can set the 'kernel.panic_on_warn' and 'kernel.panic_on_oops'\n# sysctls in its environment.\n\nlib_dir=$(dirname $0)/../../../net/forwarding\n\nALL_TESTS=\"\n\trif_vrf_set_addr_test\n\trif_non_inherit_bridge_addr_test\n\tvlan_interface_deletion_test\n\tbridge_deletion_test\n\tbridge_vlan_flags_test\n\tvlan_1_test\n\tduplicate_vlans_test\n\tvlan_rif_refcount_test\n\tsubport_rif_refcount_test\n\tsubport_rif_lag_join_test\n\tvlan_dev_deletion_test\n\tlag_unlink_slaves_test\n\tlag_dev_deletion_test\n\tvlan_interface_uppers_test\n\tbridge_extern_learn_test\n\tneigh_offload_test\n\tnexthop_offload_test\n\tnexthop_obj_invalid_test\n\tnexthop_obj_offload_test\n\tnexthop_obj_group_offload_test\n\tnexthop_obj_bucket_offload_test\n\tnexthop_obj_blackhole_offload_test\n\tnexthop_obj_route_offload_test\n\tbridge_locked_port_test\n\tdevlink_reload_test\n\"\nNUM_NETIFS=2\n: ${TIMEOUT:=20000} # ms\nsource $lib_dir/lib.sh\nsource $lib_dir/devlink_lib.sh\n\nsetup_prepare()\n{\n\tswp1=${NETIFS[p1]}\n\tswp2=${NETIFS[p2]}\n\n\tip link set dev $swp1 up\n\tip link set dev $swp2 up\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tip link set dev $swp2 down\n\tip link set dev $swp1 down\n}\n\nrif_vrf_set_addr_test()\n{\n\t# Test that it is possible to set an IP address on a VRF upper despite\n\t# its random MAC address.\n\tRET=0\n\n\tip link add name vrf-test type vrf table 10\n\tip link set dev $swp1 master vrf-test\n\n\tip -4 address add 192.0.2.1/24 dev vrf-test\n\tcheck_err $? \"failed to set IPv4 address on VRF\"\n\tip -6 address add 2001:db8:1::1/64 dev vrf-test\n\tcheck_err $? \"failed to set IPv6 address on VRF\"\n\n\tlog_test \"RIF - setting IP address on VRF\"\n\n\tip link del dev vrf-test\n}\n\nrif_non_inherit_bridge_addr_test()\n{\n\tlocal swp2_mac=$(mac_get $swp2)\n\n\tRET=0\n\n\t# Create first RIF\n\tip addr add dev $swp1 192.0.2.1/28\n\tcheck_err $?\n\n\t# Create a FID RIF\n\tip link add name br1 up type bridge vlan_filtering 0\n\tip link set dev br1 addr $swp2_mac\n\tip link set dev $swp2 master br1\n\tip addr add dev br1 192.0.2.17/28\n\tcheck_err $?\n\n\t# Prepare a device with a low MAC address\n\tip link add name d up type dummy\n\tip link set dev d addr 00:11:22:33:44:55\n\n\t# Attach the device to br1. Since the bridge address was set, it should\n\t# work.\n\tip link set dev d master br1 &>/dev/null\n\tcheck_err $? \"Could not attach a device with low MAC to a bridge with RIF\"\n\n\t# Port MAC address change should be allowed for a bridge with set MAC.\n\tip link set dev $swp2 addr 00:11:22:33:44:55\n\tcheck_err $? \"Changing swp2's MAC address not permitted\"\n\n\tlog_test \"RIF - attach port with bad MAC to bridge with set MAC\"\n\n\tip link set dev $swp2 addr $swp2_mac\n\tip link del dev d\n\tip link del dev br1\n\tip addr del dev $swp1 192.0.2.1/28\n}\n\nvlan_interface_deletion_test()\n{\n\t# Test that when a VLAN interface is deleted, its associated router\n\t# interface (RIF) is correctly deleted and not leaked. See commit\n\t# c360867ec46a (\"mlxsw: spectrum: Delete RIF when VLAN device is\n\t# removed\") for more details\n\tRET=0\n\n\tip link add name br0 type bridge vlan_filtering 1\n\tip link set dev $swp1 master br0\n\n\tip link add link br0 name br0.10 type vlan id 10\n\tip -6 address add 2001:db8:1::1/64 dev br0.10\n\tip link del dev br0.10\n\n\t# If we leaked the previous RIF, then this should produce a trace\n\tip link add link br0 name br0.20 type vlan id 20\n\tip -6 address add 2001:db8:1::1/64 dev br0.20\n\tip link del dev br0.20\n\n\tlog_test \"vlan interface deletion\"\n\n\tip link del dev br0\n}\n\nbridge_deletion_test()\n{\n\t# Test that when a bridge with VLAN interfaces is deleted, we correctly\n\t# delete the associated RIFs. See commit 602b74eda813 (\"mlxsw:\n\t# spectrum_switchdev: Do not leak RIFs when removing bridge\") for more\n\t# details\n\tRET=0\n\n\tip link add name br0 type bridge vlan_filtering 1\n\tip link set dev $swp1 master br0\n\tip -6 address add 2001:db8::1/64 dev br0\n\n\tip link add link br0 name br0.10 type vlan id 10\n\tip -6 address add 2001:db8:1::1/64 dev br0.10\n\n\tip link add link br0 name br0.20 type vlan id 20\n\tip -6 address add 2001:db8:2::1/64 dev br0.20\n\n\tip link del dev br0\n\n\t# If we leaked previous RIFs, then this should produce a trace\n\tip -6 address add 2001:db8:1::1/64 dev $swp1\n\tip -6 address del 2001:db8:1::1/64 dev $swp1\n\n\tlog_test \"bridge deletion\"\n}\n\nbridge_vlan_flags_test()\n{\n\t# Test that when bridge VLAN flags are toggled, we do not take\n\t# unnecessary references on related structs. See commit 9e25826ffc94\n\t# (\"mlxsw: spectrum_switchdev: Fix port_vlan refcounting\") for more\n\t# details\n\tRET=0\n\n\tip link add name br0 type bridge vlan_filtering 1\n\tip link set dev $swp1 master br0\n\n\tbridge vlan add vid 10 dev $swp1 pvid untagged\n\tbridge vlan add vid 10 dev $swp1 untagged\n\tbridge vlan add vid 10 dev $swp1 pvid\n\tbridge vlan add vid 10 dev $swp1\n\tip link del dev br0\n\n\t# If we did not handle references correctly, then this should produce a\n\t# trace\n\tdevlink dev reload \"$DEVLINK_DEV\"\n\n\t# Allow netdevices to be re-created following the reload\n\tsleep 20\n\n\tlog_test \"bridge vlan flags\"\n}\n\nvlan_1_test()\n{\n\t# Test that VLAN 1 can be configured over mlxsw ports. In the past it\n\t# was used internally for untagged traffic. See commit 47bf9df2e820\n\t# (\"mlxsw: spectrum: Forbid creation of VLAN 1 over port/LAG\") for more\n\t# details\n\tRET=0\n\n\tip link add link $swp1 name $swp1.1 type vlan id 1\n\tcheck_err $? \"did not manage to create vlan 1 when should\"\n\n\tlog_test \"vlan 1\"\n\n\tip link del dev $swp1.1\n}\n\nduplicate_vlans_test()\n{\n\t# Test that on a given port a VLAN is only used once. Either as VLAN\n\t# in a VLAN-aware bridge or as a VLAN device\n\tRET=0\n\n\tip link add name br0 type bridge vlan_filtering 1\n\tip link set dev $swp1 master br0\n\tbridge vlan add vid 10 dev $swp1\n\n\tip link add link $swp1 name $swp1.10 type vlan id 10 &> /dev/null\n\tcheck_fail $? \"managed to create vlan device when should not\"\n\n\tbridge vlan del vid 10 dev $swp1\n\tip link add link $swp1 name $swp1.10 type vlan id 10\n\tcheck_err $? \"did not manage to create vlan device when should\"\n\tbridge vlan add vid 10 dev $swp1 &> /dev/null\n\tcheck_fail $? \"managed to add bridge vlan when should not\"\n\n\tlog_test \"duplicate vlans\"\n\n\tip link del dev $swp1.10\n\tip link del dev br0\n}\n\nvlan_rif_refcount_test()\n{\n\t# Test that RIFs representing VLAN interfaces are not affected from\n\t# ports member in the VLAN. We use the offload indication on routes\n\t# configured on the RIF to understand if it was created / destroyed\n\tRET=0\n\n\tip link add name br0 type bridge vlan_filtering 1\n\tip link set dev $swp1 master br0\n\n\tip link set dev $swp1 up\n\tip link set dev br0 up\n\n\tip link add link br0 name br0.10 up type vlan id 10\n\tip -6 address add 2001:db8:1::1/64 dev br0.10\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev br0.10\n\tcheck_err $? \"vlan rif was not created before adding port to vlan\"\n\n\tbridge vlan add vid 10 dev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev br0.10\n\tcheck_err $? \"vlan rif was destroyed after adding port to vlan\"\n\n\tbridge vlan del vid 10 dev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev br0.10\n\tcheck_err $? \"vlan rif was destroyed after removing port from vlan\"\n\n\tip link set dev $swp1 nomaster\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev br0.10\n\tcheck_err $? \"vlan rif was not destroyed after unlinking port from bridge\"\n\n\tlog_test \"vlan rif refcount\"\n\n\tip link del dev br0.10\n\tip link set dev $swp1 down\n\tip link del dev br0\n}\n\nsubport_rif_refcount_test()\n{\n\t# Test that RIFs representing upper devices of physical ports are\n\t# reference counted correctly and destroyed when should. We use the\n\t# offload indication on routes configured on the RIF to understand if\n\t# it was created / destroyed\n\tRET=0\n\n\tip link add name bond1 type bond mode 802.3ad\n\tip link set dev $swp1 down\n\tip link set dev $swp2 down\n\tip link set dev $swp1 master bond1\n\tip link set dev $swp2 master bond1\n\n\tip link set dev bond1 up\n\tip link add link bond1 name bond1.10 up type vlan id 10\n\tip -6 address add 2001:db8:1::1/64 dev bond1\n\tip -6 address add 2001:db8:2::1/64 dev bond1.10\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev bond1\n\tcheck_err $? \"subport rif was not created on lag device\"\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:2::2 dev bond1.10\n\tcheck_err $? \"subport rif was not created on vlan device\"\n\n\tip link set dev $swp1 nomaster\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev bond1\n\tcheck_err $? \"subport rif of lag device was destroyed when should not\"\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:2::2 dev bond1.10\n\tcheck_err $? \"subport rif of vlan device was destroyed when should not\"\n\n\tip link set dev $swp2 nomaster\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev bond1\n\tcheck_err $? \"subport rif of lag device was not destroyed when should\"\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:2::2 dev bond1.10\n\tcheck_err $? \"subport rif of vlan device was not destroyed when should\"\n\n\tlog_test \"subport rif refcount\"\n\n\tip link del dev bond1.10\n\tip link del dev bond1\n}\n\nsubport_rif_lag_join_test()\n{\n\t# Test that the reference count of a RIF configured for a LAG is\n\t# incremented / decremented when ports join / leave the LAG. We use the\n\t# offload indication on routes configured on the RIF to understand if\n\t# it was created / destroyed\n\tRET=0\n\n\tip link add name bond1 type bond mode 802.3ad\n\tip link set dev $swp1 down\n\tip link set dev $swp2 down\n\tip link set dev $swp1 master bond1\n\tip link set dev $swp2 master bond1\n\n\tip link set dev bond1 up\n\tip -6 address add 2001:db8:1::1/64 dev bond1\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev bond1\n\tcheck_err $? \"subport rif was not created on lag device\"\n\n\tip link set dev $swp1 nomaster\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev bond1\n\tcheck_err $? \"subport rif of lag device was destroyed after removing one port\"\n\n\tip link set dev $swp1 master bond1\n\tip link set dev $swp2 nomaster\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev bond1\n\tcheck_err $? \"subport rif of lag device was destroyed after re-adding a port and removing another\"\n\n\tip link set dev $swp1 nomaster\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip -6 route get fibmatch 2001:db8:1::2 dev bond1\n\tcheck_err $? \"subport rif of lag device was not destroyed when should\"\n\n\tlog_test \"subport rif lag join\"\n\n\tip link del dev bond1\n}\n\nvlan_dev_deletion_test()\n{\n\t# Test that VLAN devices are correctly deleted / unlinked when enslaved\n\t# to bridge\n\tRET=0\n\n\tip link add name br10 type bridge\n\tip link add name br20 type bridge\n\tip link add name br30 type bridge\n\tip link add link $swp1 name $swp1.10 type vlan id 10\n\tip link add link $swp1 name $swp1.20 type vlan id 20\n\tip link add link $swp1 name $swp1.30 type vlan id 30\n\tip link set dev $swp1.10 master br10\n\tip link set dev $swp1.20 master br20\n\tip link set dev $swp1.30 master br30\n\n\t# If we did not handle the situation correctly, then these operations\n\t# might produce a trace\n\tip link set dev $swp1.30 nomaster\n\tip link del dev $swp1.20\n\t# Deletion via ioctl uses different code paths from netlink\n\tvconfig rem $swp1.10 &> /dev/null\n\n\tlog_test \"vlan device deletion\"\n\n\tip link del dev $swp1.30\n\tip link del dev br30\n\tip link del dev br20\n\tip link del dev br10\n}\n\nlag_create()\n{\n\tip link add name bond1 type bond mode 802.3ad\n\tip link set dev $swp1 down\n\tip link set dev $swp2 down\n\tip link set dev $swp1 master bond1\n\tip link set dev $swp2 master bond1\n\n\tip link add link bond1 name bond1.10 type vlan id 10\n\tip link add link bond1 name bond1.20 type vlan id 20\n\n\tip link add name br0 type bridge vlan_filtering 1\n\tip link set dev bond1 master br0\n\n\tip link add name br10 type bridge\n\tip link set dev bond1.10 master br10\n\n\tip link add name br20 type bridge\n\tip link set dev bond1.20 master br20\n}\n\nlag_unlink_slaves_test()\n{\n\t# Test that ports are correctly unlinked from their LAG master, when\n\t# the LAG and its VLAN uppers are enslaved to bridges\n\tRET=0\n\n\tlag_create\n\n\tip link set dev $swp1 nomaster\n\tcheck_err $? \"lag slave $swp1 was not unlinked from master\"\n\tip link set dev $swp2 nomaster\n\tcheck_err $? \"lag slave $swp2 was not unlinked from master\"\n\n\t# Try to configure corresponding VLANs as router interfaces\n\tip -6 address add 2001:db8:1::1/64 dev $swp1\n\tcheck_err $? \"failed to configure ip address on $swp1\"\n\n\tip link add link $swp1 name $swp1.10 type vlan id 10\n\tip -6 address add 2001:db8:10::1/64 dev $swp1.10\n\tcheck_err $? \"failed to configure ip address on $swp1.10\"\n\n\tip link add link $swp1 name $swp1.20 type vlan id 20\n\tip -6 address add 2001:db8:20::1/64 dev $swp1.20\n\tcheck_err $? \"failed to configure ip address on $swp1.20\"\n\n\tlog_test \"lag slaves unlinking\"\n\n\tip link del dev $swp1.20\n\tip link del dev $swp1.10\n\tip address flush dev $swp1\n\n\tip link del dev br20\n\tip link del dev br10\n\tip link del dev br0\n\tip link del dev bond1\n}\n\nlag_dev_deletion_test()\n{\n\t# Test that LAG device is correctly deleted, when the LAG and its VLAN\n\t# uppers are enslaved to bridges\n\tRET=0\n\n\tlag_create\n\n\tip link del dev bond1\n\n\tlog_test \"lag device deletion\"\n\n\tip link del dev br20\n\tip link del dev br10\n\tip link del dev br0\n}\n\nvlan_interface_uppers_test()\n{\n\t# Test that uppers of a VLAN interface are correctly sanitized\n\tRET=0\n\n\tip link add name br0 type bridge vlan_filtering 1\n\tip link set dev $swp1 master br0\n\n\tip link add link br0 name br0.10 type vlan id 10\n\n\tip -6 address add 2001:db8:1::1/64 dev br0.10\n\tip link add link br0.10 name macvlan0 type macvlan mode private\n\tcheck_err $? \"did not manage to create a macvlan when should\"\n\n\tip link del dev macvlan0\n\n\tip link add name vrf-test type vrf table 10\n\tip link set dev br0.10 master vrf-test\n\tcheck_err $? \"did not manage to enslave vlan interface to vrf\"\n\tip link del dev vrf-test\n\n\tip link add name br-test type bridge\n\tip link set dev br0.10 master br-test &> /dev/null\n\tcheck_fail $? \"managed to enslave vlan interface to bridge when should not\"\n\tip link del dev br-test\n\n\tlog_test \"vlan interface uppers\"\n\n\tip link del dev br0\n}\n\nbridge_extern_learn_test()\n{\n\t# Test that externally learned entries added from user space are\n\t# marked as offloaded\n\tRET=0\n\n\tip link add name br0 type bridge\n\tip link set dev $swp1 master br0\n\n\tbridge fdb add de:ad:be:ef:13:37 dev $swp1 master extern_learn\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tbridge fdb show brport $swp1 de:ad:be:ef:13:37\n\tcheck_err $? \"fdb entry not marked as offloaded when should\"\n\n\tlog_test \"externally learned fdb entry\"\n\n\tip link del dev br0\n}\n\nneigh_offload_test()\n{\n\t# Test that IPv4 and IPv6 neighbour entries are marked as offloaded\n\tRET=0\n\n\tip -4 address add 192.0.2.1/24 dev $swp1\n\tip -6 address add 2001:db8:1::1/64 dev $swp1\n\n\tip -4 neigh add 192.0.2.2 lladdr de:ad:be:ef:13:37 nud perm dev $swp1\n\tip -6 neigh add 2001:db8:1::2 lladdr de:ad:be:ef:13:37 nud perm \\\n\t\tdev $swp1\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -4 neigh show dev $swp1 192.0.2.2\n\tcheck_err $? \"ipv4 neigh entry not marked as offloaded when should\"\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 neigh show dev $swp1 2001:db8:1::2\n\tcheck_err $? \"ipv6 neigh entry not marked as offloaded when should\"\n\n\tlog_test \"neighbour offload indication\"\n\n\tip -6 neigh del 2001:db8:1::2 dev $swp1\n\tip -4 neigh del 192.0.2.2 dev $swp1\n\tip -6 address del 2001:db8:1::1/64 dev $swp1\n\tip -4 address del 192.0.2.1/24 dev $swp1\n}\n\nnexthop_offload_test()\n{\n\t# Test that IPv4 and IPv6 nexthops are marked as offloaded\n\tRET=0\n\n\tsysctl_set net.ipv6.conf.$swp2.keep_addr_on_down 1\n\tsimple_if_init $swp1 192.0.2.1/24 2001:db8:1::1/64\n\tsimple_if_init $swp2 192.0.2.2/24 2001:db8:1::2/64\n\tsetup_wait\n\n\tip -4 route add 198.51.100.0/24 vrf v$swp1 \\\n\t\tnexthop via 192.0.2.2 dev $swp1\n\tip -6 route add 2001:db8:2::/64 vrf v$swp1 \\\n\t\tnexthop via 2001:db8:1::2 dev $swp1\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -4 route show 198.51.100.0/24 vrf v$swp1\n\tcheck_err $? \"ipv4 nexthop not marked as offloaded when should\"\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route show 2001:db8:2::/64 vrf v$swp1\n\tcheck_err $? \"ipv6 nexthop not marked as offloaded when should\"\n\n\tip link set dev $swp2 down\n\tsleep 1\n\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip -4 route show 198.51.100.0/24 vrf v$swp1\n\tcheck_err $? \"ipv4 nexthop marked as offloaded when should not\"\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip -6 route show 2001:db8:2::/64 vrf v$swp1\n\tcheck_err $? \"ipv6 nexthop marked as offloaded when should not\"\n\n\tip link set dev $swp2 up\n\tsetup_wait\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -4 route show 198.51.100.0/24 vrf v$swp1\n\tcheck_err $? \"ipv4 nexthop not marked as offloaded after neigh add\"\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip -6 route show 2001:db8:2::/64 vrf v$swp1\n\tcheck_err $? \"ipv6 nexthop not marked as offloaded after neigh add\"\n\n\tlog_test \"nexthop offload indication\"\n\n\tip -6 route del 2001:db8:2::/64 vrf v$swp1\n\tip -4 route del 198.51.100.0/24 vrf v$swp1\n\n\tsimple_if_fini $swp2 192.0.2.2/24 2001:db8:1::2/64\n\tsimple_if_fini $swp1 192.0.2.1/24 2001:db8:1::1/64\n\tsysctl_restore net.ipv6.conf.$swp2.keep_addr_on_down\n}\n\nnexthop_obj_invalid_test()\n{\n\t# Test that invalid nexthop object configurations are rejected\n\tRET=0\n\n\tsimple_if_init $swp1 192.0.2.1/24 2001:db8:1::1/64\n\tsimple_if_init $swp2 192.0.2.2/24 2001:db8:1::2/64\n\tsetup_wait\n\n\tip nexthop add id 1 via 192.0.2.3 fdb\n\tcheck_fail $? \"managed to configure an FDB nexthop when should not\"\n\n\tip nexthop add id 1 encap mpls 200/300 via 192.0.2.3 dev $swp1\n\tcheck_fail $? \"managed to configure a nexthop with MPLS encap when should not\"\n\n\tip nexthop add id 1 dev $swp1\n\tip nexthop add id 2 dev $swp1\n\tip nexthop add id 3 via 192.0.2.3 dev $swp1\n\tip nexthop add id 10 group 1/2\n\tcheck_fail $? \"managed to configure a nexthop group with device-only nexthops when should not\"\n\n\tip nexthop add id 10 group 3 type resilient buckets 7\n\tcheck_fail $? \"managed to configure a too small resilient nexthop group when should not\"\n\n\tip nexthop add id 10 group 3 type resilient buckets 129\n\tcheck_fail $? \"managed to configure a resilient nexthop group with invalid number of buckets when should not\"\n\n\tip nexthop add id 10 group 1/2 type resilient buckets 32\n\tcheck_fail $? \"managed to configure a resilient nexthop group with device-only nexthops when should not\"\n\n\tip nexthop add id 10 group 3 type resilient buckets 32\n\tcheck_err $? \"failed to configure a valid resilient nexthop group\"\n\tip nexthop replace id 3 dev $swp1\n\tcheck_fail $? \"managed to populate a nexthop bucket with a device-only nexthop when should not\"\n\n\tlog_test \"nexthop objects - invalid configurations\"\n\n\tip nexthop del id 10\n\tip nexthop del id 3\n\tip nexthop del id 2\n\tip nexthop del id 1\n\n\tsimple_if_fini $swp2 192.0.2.2/24 2001:db8:1::2/64\n\tsimple_if_fini $swp1 192.0.2.1/24 2001:db8:1::1/64\n}\n\nnexthop_obj_offload_test()\n{\n\t# Test offload indication of nexthop objects\n\tRET=0\n\n\tsimple_if_init $swp1 192.0.2.1/24 2001:db8:1::1/64\n\tsimple_if_init $swp2\n\tsetup_wait\n\n\tip nexthop add id 1 via 192.0.2.2 dev $swp1\n\tip neigh replace 192.0.2.2 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop show id 1\n\tcheck_err $? \"nexthop not marked as offloaded when should\"\n\n\tip neigh replace 192.0.2.2 nud failed dev $swp1\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip nexthop show id 1\n\tcheck_err $? \"nexthop marked as offloaded after setting neigh to failed state\"\n\n\tip neigh replace 192.0.2.2 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop show id 1\n\tcheck_err $? \"nexthop not marked as offloaded after neigh replace\"\n\n\tip nexthop replace id 1 via 192.0.2.3 dev $swp1\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip nexthop show id 1\n\tcheck_err $? \"nexthop marked as offloaded after replacing to use an invalid address\"\n\n\tip nexthop replace id 1 via 192.0.2.2 dev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop show id 1\n\tcheck_err $? \"nexthop not marked as offloaded after replacing to use a valid address\"\n\n\tlog_test \"nexthop objects offload indication\"\n\n\tip neigh del 192.0.2.2 dev $swp1\n\tip nexthop del id 1\n\n\tsimple_if_fini $swp2\n\tsimple_if_fini $swp1 192.0.2.1/24 2001:db8:1::1/64\n}\n\nnexthop_obj_group_offload_test()\n{\n\t# Test offload indication of nexthop group objects\n\tRET=0\n\n\tsimple_if_init $swp1 192.0.2.1/24 2001:db8:1::1/64\n\tsimple_if_init $swp2\n\tsetup_wait\n\n\tip nexthop add id 1 via 192.0.2.2 dev $swp1\n\tip nexthop add id 2 via 2001:db8:1::2 dev $swp1\n\tip nexthop add id 10 group 1/2\n\tip neigh replace 192.0.2.2 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\tip neigh replace 192.0.2.3 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\tip neigh replace 2001:db8:1::2 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop show id 1\n\tcheck_err $? \"IPv4 nexthop not marked as offloaded when should\"\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop show id 2\n\tcheck_err $? \"IPv6 nexthop not marked as offloaded when should\"\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop show id 10\n\tcheck_err $? \"nexthop group not marked as offloaded when should\"\n\n\t# Invalidate nexthop id 1\n\tip neigh replace 192.0.2.2 nud failed dev $swp1\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip nexthop show id 10\n\tcheck_fail $? \"nexthop group not marked as offloaded with one valid nexthop\"\n\n\t# Invalidate nexthop id 2\n\tip neigh replace 2001:db8:1::2 nud failed dev $swp1\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip nexthop show id 10\n\tcheck_err $? \"nexthop group marked as offloaded when should not\"\n\n\t# Revalidate nexthop id 1\n\tip nexthop replace id 1 via 192.0.2.3 dev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop show id 10\n\tcheck_err $? \"nexthop group not marked as offloaded after revalidating nexthop\"\n\n\tlog_test \"nexthop group objects offload indication\"\n\n\tip neigh del 2001:db8:1::2 dev $swp1\n\tip neigh del 192.0.2.3 dev $swp1\n\tip neigh del 192.0.2.2 dev $swp1\n\tip nexthop del id 10\n\tip nexthop del id 2\n\tip nexthop del id 1\n\n\tsimple_if_fini $swp2\n\tsimple_if_fini $swp1 192.0.2.1/24 2001:db8:1::1/64\n}\n\nnexthop_obj_bucket_offload_test()\n{\n\t# Test offload indication of nexthop buckets\n\tRET=0\n\n\tsimple_if_init $swp1 192.0.2.1/24 2001:db8:1::1/64\n\tsimple_if_init $swp2\n\tsetup_wait\n\n\tip nexthop add id 1 via 192.0.2.2 dev $swp1\n\tip nexthop add id 2 via 2001:db8:1::2 dev $swp1\n\tip nexthop add id 10 group 1/2 type resilient buckets 32 idle_timer 0\n\tip neigh replace 192.0.2.2 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\tip neigh replace 192.0.2.3 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\tip neigh replace 2001:db8:1::2 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop bucket show nhid 1\n\tcheck_err $? \"IPv4 nexthop buckets not marked as offloaded when should\"\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop bucket show nhid 2\n\tcheck_err $? \"IPv6 nexthop buckets not marked as offloaded when should\"\n\n\t# Invalidate nexthop id 1\n\tip neigh replace 192.0.2.2 nud failed dev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_trap \\\n\t\tip nexthop bucket show nhid 1\n\tcheck_err $? \"IPv4 nexthop buckets not marked with trap when should\"\n\n\t# Invalidate nexthop id 2\n\tip neigh replace 2001:db8:1::2 nud failed dev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_trap \\\n\t\tip nexthop bucket show nhid 2\n\tcheck_err $? \"IPv6 nexthop buckets not marked with trap when should\"\n\n\t# Revalidate nexthop id 1 by changing its configuration\n\tip nexthop replace id 1 via 192.0.2.3 dev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop bucket show nhid 1\n\tcheck_err $? \"nexthop bucket not marked as offloaded after revalidating nexthop\"\n\n\t# Revalidate nexthop id 2 by changing its neighbour\n\tip neigh replace 2001:db8:1::2 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop bucket show nhid 2\n\tcheck_err $? \"nexthop bucket not marked as offloaded after revalidating neighbour\"\n\n\tlog_test \"nexthop bucket offload indication\"\n\n\tip neigh del 2001:db8:1::2 dev $swp1\n\tip neigh del 192.0.2.3 dev $swp1\n\tip neigh del 192.0.2.2 dev $swp1\n\tip nexthop del id 10\n\tip nexthop del id 2\n\tip nexthop del id 1\n\n\tsimple_if_fini $swp2\n\tsimple_if_fini $swp1 192.0.2.1/24 2001:db8:1::1/64\n}\n\nnexthop_obj_blackhole_offload_test()\n{\n\t# Test offload indication of blackhole nexthop objects\n\tRET=0\n\n\tip nexthop add id 1 blackhole\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop show id 1\n\tcheck_err $? \"Blackhole nexthop not marked as offloaded when should\"\n\n\tip nexthop add id 10 group 1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip nexthop show id 10\n\tcheck_err $? \"Nexthop group not marked as offloaded when should\"\n\n\tlog_test \"blackhole nexthop objects offload indication\"\n\n\tip nexthop del id 10\n\tip nexthop del id 1\n}\n\nnexthop_obj_route_offload_test()\n{\n\t# Test offload indication of routes using nexthop objects\n\tRET=0\n\n\tsimple_if_init $swp1 192.0.2.1/24 2001:db8:1::1/64\n\tsimple_if_init $swp2\n\tsetup_wait\n\n\tip nexthop add id 1 via 192.0.2.2 dev $swp1\n\tip neigh replace 192.0.2.2 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\tip neigh replace 192.0.2.3 lladdr 00:11:22:33:44:55 nud perm \\\n\t\tdev $swp1\n\n\tip route replace 198.51.100.0/24 nhid 1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip route show 198.51.100.0/24\n\tcheck_err $? \"route not marked as offloaded when using valid nexthop\"\n\n\tip nexthop replace id 1 via 192.0.2.3 dev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip route show 198.51.100.0/24\n\tcheck_err $? \"route not marked as offloaded after replacing valid nexthop with a valid one\"\n\n\tip nexthop replace id 1 via 192.0.2.4 dev $swp1\n\tbusywait \"$TIMEOUT\" not wait_for_offload \\\n\t\tip route show 198.51.100.0/24\n\tcheck_err $? \"route marked as offloaded after replacing valid nexthop with an invalid one\"\n\n\tip nexthop replace id 1 via 192.0.2.2 dev $swp1\n\tbusywait \"$TIMEOUT\" wait_for_offload \\\n\t\tip route show 198.51.100.0/24\n\tcheck_err $? \"route not marked as offloaded after replacing invalid nexthop with a valid one\"\n\n\tlog_test \"routes using nexthop objects offload indication\"\n\n\tip route del 198.51.100.0/24\n\tip neigh del 192.0.2.3 dev $swp1\n\tip neigh del 192.0.2.2 dev $swp1\n\tip nexthop del id 1\n\n\tsimple_if_fini $swp2\n\tsimple_if_fini $swp1 192.0.2.1/24 2001:db8:1::1/64\n}\n\nbridge_locked_port_test()\n{\n\tRET=0\n\n\tip link add name br1 up type bridge vlan_filtering 0\n\n\tip link add link $swp1 name $swp1.10 type vlan id 10\n\tip link set dev $swp1.10 master br1\n\n\tbridge link set dev $swp1.10 locked on\n\tcheck_fail $? \"managed to set locked flag on a VLAN upper\"\n\n\tip link set dev $swp1.10 nomaster\n\tip link set dev $swp1 master br1\n\n\tbridge link set dev $swp1 locked on\n\tcheck_fail $? \"managed to set locked flag on a bridge port that has a VLAN upper\"\n\n\tip link del dev $swp1.10\n\tbridge link set dev $swp1 locked on\n\n\tip link add link $swp1 name $swp1.10 type vlan id 10\n\tcheck_fail $? \"managed to configure a VLAN upper on a locked port\"\n\n\tlog_test \"bridge locked port\"\n\n\tip link del dev $swp1.10 &> /dev/null\n\tip link del dev br1\n}\n\ndevlink_reload_test()\n{\n\t# Test that after executing all the above configuration tests, a\n\t# devlink reload can be performed without errors\n\tRET=0\n\n\tdevlink dev reload \"$DEVLINK_DEV\"\n\tcheck_err $? \"devlink reload failed\"\n\n\tlog_test \"devlink reload - last test\"\n\n\tsleep 20\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}