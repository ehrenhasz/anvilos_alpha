{
  "module_name": "qos_pfc.sh",
  "hash_id": "ca7de1122ce3b36c35940d6ac76bd5f5b56f3d02f455eff2e657d5b6f6338ed8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/qos_pfc.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# This test injects a 10-MB burst of traffic with VLAN tag and 802.1p priority\n# of 1. This stream is consistently prioritized as priority 1, is put to PG\n# buffer 1, and scheduled at TC 1.\n#\n# - the stream first ingresses through $swp1, where it is forwarded to $swp3\n#\n# - then it ingresses through $swp4. Here it is put to a lossless buffer and put\n#   to a small pool (\"PFC pool\"). The traffic is forwarded to $swp2, which is\n#   shaped, and thus the PFC pool eventually fills, therefore the headroom\n#   fills, and $swp3 is paused.\n#\n# - since $swp3 now can't send traffic, the traffic ingressing $swp1 is kept at\n#   a pool (\"overflow pool\"). The overflow pool needs to be large enough to\n#   contain the whole burst.\n#\n# - eventually the PFC pool gets some traffic out, headroom therefore gets some\n#   traffic to the pool, and $swp3 is unpaused again. This way the traffic is\n#   gradually forwarded from the overflow pool, through the PFC pool, out of\n#   $swp2, and eventually to $h2.\n#\n# - if PFC works, all lossless flow packets that ingress through $swp1 should\n#   also be seen ingressing $h2. If it doesn't, there will be drops due to\n#   discrepancy between the speeds of $swp1 and $h2.\n#\n# - it should all play out relatively quickly, so that SLL and HLL will not\n#   cause drops.\n#\n# +-----------------------+\n# | H1                    |\n# |   + $h1.111           |\n# |   | 192.0.2.33/28     |\n# |   |                   |\n# |   + $h1               |\n# +---|-------------------+  +--------------------+\n#     |                      |                    |\n# +---|----------------------|--------------------|---------------------------+\n# |   + $swp1          $swp3 +                    + $swp4                     |\n# |   | iPOOL1        iPOOL0 |                    | iPOOL2                    |\n# |   | ePOOL4        ePOOL5 |                    | ePOOL4                    |\n# |   |                1Gbps |                    | 1Gbps                     |\n# |   |        PFC:enabled=1 |                    | PFC:enabled=1             |\n# | +-|----------------------|-+                +-|------------------------+  |\n# | | + $swp1.111  $swp3.111 + |                | + $swp4.111              |  |\n# | |                          |                |                          |  |\n# | | BR1                      |                | BR2                      |  |\n# | |                          |                |                          |  |\n# | |                          |                |         + $swp2.111      |  |\n# | +--------------------------+                +---------|----------------+  |\n# |                                                       |                   |\n# | iPOOL0: 500KB dynamic                                 |                   |\n# | iPOOL1: 10MB static                                   |                   |\n# | iPOOL2: 1MB static                                    + $swp2             |\n# | ePOOL4: 500KB dynamic                                 | iPOOL0            |\n# | ePOOL5: 10MB static                                   | ePOOL6            |\n# | ePOOL6: \"infinite\" static                             | 200Mbps shaper    |\n# +-------------------------------------------------------|-------------------+\n#                                                         |\n#                                                     +---|-------------------+\n#                                                     |   + $h2            H2 |\n#                                                     |   |                   |\n#                                                     |   + $h2.111           |\n#                                                     |     192.0.2.34/28     |\n#                                                     +-----------------------+\n#\n# iPOOL0+ePOOL4 is a helper pool for control traffic etc.\n# iPOOL1+ePOOL5 are overflow pools.\n# iPOOL2+ePOOL6 are PFC pools.\n\nALL_TESTS=\"\n\tping_ipv4\n\ttest_qos_pfc\n\"\n\nlib_dir=$(dirname $0)/../../../net/forwarding\n\nNUM_NETIFS=6\nsource $lib_dir/lib.sh\nsource $lib_dir/devlink_lib.sh\n\n_1KB=1000\n_100KB=$((100 * _1KB))\n_500KB=$((500 * _1KB))\n_1MB=$((1000 * _1KB))\n_10MB=$((10 * _1MB))\n\nh1_create()\n{\n\tsimple_if_init $h1\n\tmtu_set $h1 10000\n\n\tvlan_create $h1 111 v$h1 192.0.2.33/28\n}\n\nh1_destroy()\n{\n\tvlan_destroy $h1 111\n\n\tmtu_restore $h1\n\tsimple_if_fini $h1\n}\n\nh2_create()\n{\n\tsimple_if_init $h2\n\tmtu_set $h2 10000\n\n\tvlan_create $h2 111 v$h2 192.0.2.34/28\n}\n\nh2_destroy()\n{\n\tvlan_destroy $h2 111\n\n\tmtu_restore $h2\n\tsimple_if_fini $h2\n}\n\nswitch_create()\n{\n\tlocal lanes_swp4\n\tlocal pg1_size\n\n\t# pools\n\t# -----\n\n\tdevlink_pool_size_thtype_save 0\n\tdevlink_pool_size_thtype_save 4\n\tdevlink_pool_size_thtype_save 1\n\tdevlink_pool_size_thtype_save 5\n\tdevlink_pool_size_thtype_save 2\n\tdevlink_pool_size_thtype_save 6\n\n\tdevlink_port_pool_th_save $swp1 1\n\tdevlink_port_pool_th_save $swp2 6\n\tdevlink_port_pool_th_save $swp3 5\n\tdevlink_port_pool_th_save $swp4 2\n\n\tdevlink_tc_bind_pool_th_save $swp1 1 ingress\n\tdevlink_tc_bind_pool_th_save $swp2 1 egress\n\tdevlink_tc_bind_pool_th_save $swp3 1 egress\n\tdevlink_tc_bind_pool_th_save $swp4 1 ingress\n\n\t# Control traffic pools. Just reduce the size. Keep them dynamic so that\n\t# we don't need to change all the uninteresting quotas.\n\tdevlink_pool_size_thtype_set 0 dynamic $_500KB\n\tdevlink_pool_size_thtype_set 4 dynamic $_500KB\n\n\t# Overflow pools.\n\tdevlink_pool_size_thtype_set 1 static $_10MB\n\tdevlink_pool_size_thtype_set 5 static $_10MB\n\n\t# PFC pools. As per the writ, the size of egress PFC pool should be\n\t# infinice, but actually it just needs to be large enough to not matter\n\t# in practice, so reuse the 10MB limit.\n\tdevlink_pool_size_thtype_set 2 static $_1MB\n\tdevlink_pool_size_thtype_set 6 static $_10MB\n\n\t# $swp1\n\t# -----\n\n\tip link set dev $swp1 up\n\tmtu_set $swp1 10000\n\tvlan_create $swp1 111\n\tip link set dev $swp1.111 type vlan ingress-qos-map 0:0 1:1\n\n\tdevlink_port_pool_th_set $swp1 1 $_10MB\n\tdevlink_tc_bind_pool_th_set $swp1 1 ingress 1 $_10MB\n\n\t# Configure qdisc so that we can configure PG and therefore pool\n\t# assignment.\n\ttc qdisc replace dev $swp1 root handle 1: \\\n\t   ets bands 8 strict 8 priomap 7 6\n\tdcb buffer set dev $swp1 prio-buffer all:0 1:1\n\n\t# $swp2\n\t# -----\n\n\tip link set dev $swp2 up\n\tmtu_set $swp2 10000\n\tvlan_create $swp2 111\n\tip link set dev $swp2.111 type vlan egress-qos-map 0:0 1:1\n\n\tdevlink_port_pool_th_set $swp2 6 $_10MB\n\tdevlink_tc_bind_pool_th_set $swp2 1 egress 6 $_10MB\n\n\t# prio 0->TC0 (band 7), 1->TC1 (band 6). TC1 is shaped.\n\ttc qdisc replace dev $swp2 root handle 1: \\\n\t   ets bands 8 strict 8 priomap 7 6\n\ttc qdisc replace dev $swp2 parent 1:7 handle 17: \\\n\t   tbf rate 200Mbit burst 131072 limit 1M\n\n\t# $swp3\n\t# -----\n\n\tip link set dev $swp3 up\n\tmtu_set $swp3 10000\n\tvlan_create $swp3 111\n\tip link set dev $swp3.111 type vlan egress-qos-map 0:0 1:1\n\n\tdevlink_port_pool_th_set $swp3 5 $_10MB\n\tdevlink_tc_bind_pool_th_set $swp3 1 egress 5 $_10MB\n\n\t# prio 0->TC0 (band 7), 1->TC1 (band 6)\n\ttc qdisc replace dev $swp3 root handle 1: \\\n\t   ets bands 8 strict 8 priomap 7 6\n\n\t# Need to enable PFC so that PAUSE takes effect. Therefore need to put\n\t# the lossless prio into a buffer of its own. Don't bother with buffer\n\t# sizes though, there is not going to be any pressure in the \"backward\"\n\t# direction.\n\tdcb buffer set dev $swp3 prio-buffer all:0 1:1\n\tdcb pfc set dev $swp3 prio-pfc all:off 1:on\n\n\t# $swp4\n\t# -----\n\n\tip link set dev $swp4 up\n\tmtu_set $swp4 10000\n\tvlan_create $swp4 111\n\tip link set dev $swp4.111 type vlan ingress-qos-map 0:0 1:1\n\n\tdevlink_port_pool_th_set $swp4 2 $_1MB\n\tdevlink_tc_bind_pool_th_set $swp4 1 ingress 2 $_1MB\n\n\t# Configure qdisc so that we can hand-tune headroom.\n\ttc qdisc replace dev $swp4 root handle 1: \\\n\t   ets bands 8 strict 8 priomap 7 6\n\tdcb buffer set dev $swp4 prio-buffer all:0 1:1\n\tdcb pfc set dev $swp4 prio-pfc all:off 1:on\n\t# PG0 will get autoconfigured to Xoff, give PG1 arbitrarily 100K, which\n\t# is (-2*MTU) about 80K of delay provision.\n\tpg1_size=$_100KB\n\n\tsetup_wait_dev_with_timeout $swp4\n\n\tlanes_swp4=$(ethtool $swp4 | grep 'Lanes:')\n\tlanes_swp4=${lanes_swp4#*\"Lanes: \"}\n\n\t# 8-lane ports use two buffers among which the configured buffer\n\t# is split, so double the size to get twice (20K + 80K).\n\tif [[ $lanes_swp4 -eq 8 ]]; then\n\t\tpg1_size=$((pg1_size * 2))\n\tfi\n\n\tdcb buffer set dev $swp4 buffer-size all:0 1:$pg1_size\n\n\t# bridges\n\t# -------\n\n\tip link add name br1 type bridge vlan_filtering 0\n\tip link set dev $swp1.111 master br1\n\tip link set dev $swp3.111 master br1\n\tip link set dev br1 up\n\n\tip link add name br2 type bridge vlan_filtering 0\n\tip link set dev $swp2.111 master br2\n\tip link set dev $swp4.111 master br2\n\tip link set dev br2 up\n}\n\nswitch_destroy()\n{\n\t# Do this first so that we can reset the limits to values that are only\n\t# valid for the original static / dynamic setting.\n\tdevlink_pool_size_thtype_restore 6\n\tdevlink_pool_size_thtype_restore 5\n\tdevlink_pool_size_thtype_restore 4\n\tdevlink_pool_size_thtype_restore 2\n\tdevlink_pool_size_thtype_restore 1\n\tdevlink_pool_size_thtype_restore 0\n\n\t# bridges\n\t# -------\n\n\tip link set dev br2 down\n\tip link set dev $swp4.111 nomaster\n\tip link set dev $swp2.111 nomaster\n\tip link del dev br2\n\n\tip link set dev br1 down\n\tip link set dev $swp3.111 nomaster\n\tip link set dev $swp1.111 nomaster\n\tip link del dev br1\n\n\t# $swp4\n\t# -----\n\n\tdcb buffer set dev $swp4 buffer-size all:0\n\tdcb pfc set dev $swp4 prio-pfc all:off\n\tdcb buffer set dev $swp4 prio-buffer all:0\n\ttc qdisc del dev $swp4 root\n\n\tdevlink_tc_bind_pool_th_restore $swp4 1 ingress\n\tdevlink_port_pool_th_restore $swp4 2\n\n\tvlan_destroy $swp4 111\n\tmtu_restore $swp4\n\tip link set dev $swp4 down\n\n\t# $swp3\n\t# -----\n\n\tdcb pfc set dev $swp3 prio-pfc all:off\n\tdcb buffer set dev $swp3 prio-buffer all:0\n\ttc qdisc del dev $swp3 root\n\n\tdevlink_tc_bind_pool_th_restore $swp3 1 egress\n\tdevlink_port_pool_th_restore $swp3 5\n\n\tvlan_destroy $swp3 111\n\tmtu_restore $swp3\n\tip link set dev $swp3 down\n\n\t# $swp2\n\t# -----\n\n\ttc qdisc del dev $swp2 parent 1:7\n\ttc qdisc del dev $swp2 root\n\n\tdevlink_tc_bind_pool_th_restore $swp2 1 egress\n\tdevlink_port_pool_th_restore $swp2 6\n\n\tvlan_destroy $swp2 111\n\tmtu_restore $swp2\n\tip link set dev $swp2 down\n\n\t# $swp1\n\t# -----\n\n\tdcb buffer set dev $swp1 prio-buffer all:0\n\ttc qdisc del dev $swp1 root\n\n\tdevlink_tc_bind_pool_th_restore $swp1 1 ingress\n\tdevlink_port_pool_th_restore $swp1 1\n\n\tvlan_destroy $swp1 111\n\tmtu_restore $swp1\n\tip link set dev $swp1 down\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\tswp3=${NETIFS[p5]}\n\tswp4=${NETIFS[p6]}\n\n\th2mac=$(mac_get $h2)\n\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\tswitch_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tswitch_destroy\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n}\n\nping_ipv4()\n{\n\tping_test $h1 192.0.2.34\n}\n\ntest_qos_pfc()\n{\n\tRET=0\n\n\t# 10M pool, each packet is 8K of payload + headers\n\tlocal pkts=$((_10MB / 8050))\n\tlocal size=$((pkts * 8050))\n\tlocal in0=$(ethtool_stats_get $swp1 rx_octets_prio_1)\n\tlocal out0=$(ethtool_stats_get $swp2 tx_octets_prio_1)\n\n\t$MZ $h1 -p 8000 -Q 1:111 -A 192.0.2.33 -B 192.0.2.34 \\\n\t\t-a own -b $h2mac -c $pkts -t udp -q\n\tsleep 2\n\n\tlocal in1=$(ethtool_stats_get $swp1 rx_octets_prio_1)\n\tlocal out1=$(ethtool_stats_get $swp2 tx_octets_prio_1)\n\n\tlocal din=$((in1 - in0))\n\tlocal dout=$((out1 - out0))\n\n\tlocal pct_in=$((din * 100 / size))\n\n\t((pct_in > 95 && pct_in < 105))\n\tcheck_err $? \"Relative ingress out of expected bounds, $pct_in% should be 100%\"\n\n\t((dout == din))\n\tcheck_err $? \"$((din - dout)) bytes out of $din ingressed got lost\"\n\n\tlog_test \"PFC\"\n}\n\nbail_on_lldpad \"configure DCB\" \"configure Qdiscs\"\n\ntrap cleanup EXIT\nsetup_prepare\nsetup_wait\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}