{
  "module_name": "devlink_trap_l3_exceptions.sh",
  "hash_id": "6e225b1e947e5675b7ec5853504d7b5cabe35b9449ca2bee80e6fa66ffc5dfb5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/devlink_trap_l3_exceptions.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test devlink-trap L3 exceptions functionality over mlxsw.\n# Check all exception traps to make sure they are triggered under the right\n# conditions.\n\n# +---------------------------------+\n# | H1 (vrf)                        |\n# |    + $h1                        |\n# |    | 192.0.2.1/24               |\n# |    | 2001:db8:1::1/64           |\n# |    |                            |\n# |    |  default via 192.0.2.2     |\n# |    |  default via 2001:db8:1::2 |\n# +----|----------------------------+\n#      |\n# +----|----------------------------------------------------------------------+\n# | SW |                                                                      |\n# |    + $rp1                                                                 |\n# |        192.0.2.2/24                                                       |\n# |        2001:db8:1::2/64                                                   |\n# |                                                                           |\n# |        2001:db8:2::2/64                                                   |\n# |        198.51.100.2/24                                                    |\n# |    + $rp2                                                                 |\n# |    |                                                                      |\n# +----|----------------------------------------------------------------------+\n#      |\n# +----|----------------------------+\n# |    |  default via 198.51.100.2  |\n# |    |  default via 2001:db8:2::2 |\n# |    |                            |\n# |    | 2001:db8:2::1/64           |\n# |    | 198.51.100.1/24            |\n# |    + $h2                        |\n# | H2 (vrf)                        |\n# +---------------------------------+\n\nlib_dir=$(dirname $0)/../../../net/forwarding\n\nALL_TESTS=\"\n\tmtu_value_is_too_small_test\n\tttl_value_is_too_small_test\n\tmc_reverse_path_forwarding_test\n\treject_route_test\n\tunresolved_neigh_test\n\tipv4_lpm_miss_test\n\tipv6_lpm_miss_test\n\"\n\nNUM_NETIFS=4\nsource $lib_dir/lib.sh\nsource $lib_dir/tc_common.sh\nsource $lib_dir/devlink_lib.sh\n\nrequire_command $MCD\nrequire_command $MC_CLI\ntable_name=selftests\n\nh1_create()\n{\n\tsimple_if_init $h1 192.0.2.1/24 2001:db8:1::1/64\n\n\tip -4 route add default vrf v$h1 nexthop via 192.0.2.2\n\tip -6 route add default vrf v$h1 nexthop via 2001:db8:1::2\n\n\ttc qdisc add dev $h1 clsact\n}\n\nh1_destroy()\n{\n\ttc qdisc del dev $h1 clsact\n\n\tip -6 route del default vrf v$h1 nexthop via 2001:db8:1::2\n\tip -4 route del default vrf v$h1 nexthop via 192.0.2.2\n\n\tsimple_if_fini $h1 192.0.2.1/24 2001:db8:1::1/64\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 198.51.100.1/24 2001:db8:2::1/64\n\n\tip -4 route add default vrf v$h2 nexthop via 198.51.100.2\n\tip -6 route add default vrf v$h2 nexthop via 2001:db8:2::2\n}\n\nh2_destroy()\n{\n\tip -6 route del default vrf v$h2 nexthop via 2001:db8:2::2\n\tip -4 route del default vrf v$h2 nexthop via 198.51.100.2\n\n\tsimple_if_fini $h2 198.51.100.1/24 2001:db8:2::1/64\n}\n\nrouter_create()\n{\n\tip link set dev $rp1 up\n\tip link set dev $rp2 up\n\n\ttc qdisc add dev $rp2 clsact\n\n\t__addr_add_del $rp1 add 192.0.2.2/24 2001:db8:1::2/64\n\t__addr_add_del $rp2 add 198.51.100.2/24 2001:db8:2::2/64\n}\n\nrouter_destroy()\n{\n\t__addr_add_del $rp2 del 198.51.100.2/24 2001:db8:2::2/64\n\t__addr_add_del $rp1 del 192.0.2.2/24 2001:db8:1::2/64\n\n\ttc qdisc del dev $rp2 clsact\n\n\tip link set dev $rp2 down\n\tip link set dev $rp1 down\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\trp1=${NETIFS[p2]}\n\n\trp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\trp1mac=$(mac_get $rp1)\n\n\tstart_mcd\n\n\tvrf_prepare\n\tforwarding_enable\n\n\th1_create\n\th2_create\n\n\trouter_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\trouter_destroy\n\n\th2_destroy\n\th1_destroy\n\n\tforwarding_restore\n\tvrf_cleanup\n\n\tkill_mcd\n}\n\nping_check()\n{\n\tping_do $h1 198.51.100.1\n\tcheck_err $? \"Packets that should not be trapped were trapped\"\n}\n\ntrap_action_check()\n{\n\tlocal trap_name=$1; shift\n\tlocal expected_action=$1; shift\n\n\taction=$(devlink_trap_action_get $trap_name)\n\tif [ \"$action\" != $expected_action ]; then\n\t\tcheck_err 1 \"Trap $trap_name has wrong action: $action\"\n\tfi\n}\n\nmtu_value_is_too_small_test()\n{\n\tlocal trap_name=\"mtu_value_is_too_small\"\n\tlocal expected_action=\"trap\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\ttrap_action_check $trap_name $expected_action\n\n\t# type - Destination Unreachable\n\t# code - Fragmentation Needed and Don't Fragment was Set\n\ttc filter add dev $h1 ingress protocol ip pref 1 handle 101 \\\n\t\tflower skip_hw ip_proto icmp type 3 code 4 action pass\n\n\tmtu_set $rp2 1300\n\n\t# Generate IP packets bigger than router's MTU with don't fragment\n\t# flag on.\n\t$MZ $h1 -t udp \"sp=54321,dp=12345,df\" -p 1400 -c 0 -d 1msec -b $rp1mac \\\n\t\t-B 198.51.100.1 -q &\n\tmz_pid=$!\n\n\tdevlink_trap_exception_test $trap_name\n\n\ttc_check_packets_hitting \"dev $h1 ingress\" 101\n\tcheck_err $? \"Packets were not received to h1\"\n\n\tlog_test \"MTU value is too small\"\n\n\tmtu_restore $rp2\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\ttc filter del dev $h1 ingress protocol ip pref 1 handle 101 flower\n}\n\n__ttl_value_is_too_small_test()\n{\n\tlocal ttl_val=$1; shift\n\tlocal trap_name=\"ttl_value_is_too_small\"\n\tlocal expected_action=\"trap\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\ttrap_action_check $trap_name $expected_action\n\n\t# type - Time Exceeded\n\t# code - Time to Live exceeded in Transit\n\ttc filter add dev $h1 ingress protocol ip pref 1 handle 101 \\\n\t\t flower skip_hw ip_proto icmp type 11 code 0 action pass\n\n\t# Generate IP packets with small TTL\n\t$MZ $h1 -t udp \"ttl=$ttl_val,sp=54321,dp=12345\" -c 0 -d 1msec \\\n\t\t-b $rp1mac -B 198.51.100.1 -q &\n\tmz_pid=$!\n\n\tdevlink_trap_exception_test $trap_name\n\n\ttc_check_packets_hitting \"dev $h1 ingress\" 101\n\tcheck_err $? \"Packets were not received to h1\"\n\n\tlog_test \"TTL value is too small: TTL=$ttl_val\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\ttc filter del dev $h1 ingress protocol ip pref 1 handle 101 flower\n}\n\nttl_value_is_too_small_test()\n{\n\t__ttl_value_is_too_small_test 0\n\t__ttl_value_is_too_small_test 1\n}\n\nstart_mcd()\n{\n\tSMCROUTEDIR=\"$(mktemp -d)\"\n\tfor ((i = 1; i <= $NUM_NETIFS; ++i)); do\n\t\t echo \"phyint ${NETIFS[p$i]} enable\" >> \\\n\t\t\t $SMCROUTEDIR/$table_name.conf\n\tdone\n\n\t$MCD -N -I $table_name -f $SMCROUTEDIR/$table_name.conf \\\n\t\t-P $SMCROUTEDIR/$table_name.pid\n}\n\nkill_mcd()\n{\n\tpkill $MCD\n\trm -rf $SMCROUTEDIR\n}\n\n__mc_reverse_path_forwarding_test()\n{\n\tlocal desc=$1; shift\n\tlocal src_ip=$1; shift\n\tlocal dst_ip=$1; shift\n\tlocal dst_mac=$1; shift\n\tlocal proto=$1; shift\n\tlocal flags=${1:-\"\"}; shift\n\tlocal trap_name=\"mc_reverse_path_forwarding\"\n\tlocal expected_action=\"trap\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\ttrap_action_check $trap_name $expected_action\n\n\ttc filter add dev $rp2 egress protocol $proto pref 1 handle 101 \\\n\t\tflower dst_ip $dst_ip ip_proto udp action drop\n\n\t$MC_CLI -I $table_name add $rp1 $src_ip $dst_ip $rp2\n\n\t# Generate packets to multicast address.\n\t$MZ $h2 $flags -t udp \"sp=54321,dp=12345\" -c 0 -p 128 \\\n\t\t-a 00:11:22:33:44:55 -b $dst_mac \\\n\t\t-A $src_ip -B $dst_ip -q &\n\n\tmz_pid=$!\n\n\tdevlink_trap_exception_test $trap_name\n\n\ttc_check_packets \"dev $rp2 egress\" 101 0\n\tcheck_err $? \"Packets were not dropped\"\n\n\tlog_test \"Multicast reverse path forwarding: $desc\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\ttc filter del dev $rp2 egress protocol $proto pref 1 handle 101 flower\n}\n\nmc_reverse_path_forwarding_test()\n{\n\t__mc_reverse_path_forwarding_test \"IPv4\" \"192.0.2.1\" \"225.1.2.3\" \\\n\t\t\"01:00:5e:01:02:03\" \"ip\"\n\t__mc_reverse_path_forwarding_test \"IPv6\" \"2001:db8:1::1\" \"ff0e::3\" \\\n\t\t\"33:33:00:00:00:03\" \"ipv6\" \"-6\"\n}\n\n__reject_route_test()\n{\n\tlocal desc=$1; shift\n\tlocal dst_ip=$1; shift\n\tlocal proto=$1; shift\n\tlocal ip_proto=$1; shift\n\tlocal type=$1; shift\n\tlocal code=$1; shift\n\tlocal unreachable=$1; shift\n\tlocal flags=${1:-\"\"}; shift\n\tlocal trap_name=\"reject_route\"\n\tlocal expected_action=\"trap\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\ttrap_action_check $trap_name $expected_action\n\n\ttc filter add dev $h1 ingress protocol $proto pref 1 handle 101 flower \\\n\t\tskip_hw ip_proto $ip_proto type $type code $code action pass\n\n\tip route add unreachable $unreachable\n\n\t# Generate pacekts to h2. The destination IP is unreachable.\n\t$MZ $flags $h1 -t udp \"sp=54321,dp=12345\" -c 0 -d 1msec -b $rp1mac \\\n\t\t-B $dst_ip -q &\n\tmz_pid=$!\n\n\tdevlink_trap_exception_test $trap_name\n\n\ttc_check_packets_hitting \"dev $h1 ingress\" 101\n\tcheck_err $? \"ICMP packet was not received to h1\"\n\n\tlog_test \"Reject route: $desc\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\tip route del unreachable $unreachable\n\ttc filter del dev $h1 ingress protocol $proto pref 1 handle 101 flower\n}\n\nreject_route_test()\n{\n\t# type - Destination Unreachable\n\t# code - Host Unreachable\n\t__reject_route_test \"IPv4\" 198.51.100.1 \"ip\" \"icmp\" 3 1 \\\n\t\t\"198.51.100.0/26\"\n\t# type - Destination Unreachable\n\t# code - No Route\n\t__reject_route_test \"IPv6\" 2001:db8:2::1 \"ipv6\" \"icmpv6\" 1 0 \\\n\t\t\"2001:db8:2::0/66\" \"-6\"\n}\n\n__host_miss_test()\n{\n\tlocal desc=$1; shift\n\tlocal dip=$1; shift\n\tlocal trap_name=\"unresolved_neigh\"\n\tlocal expected_action=\"trap\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\ttrap_action_check $trap_name $expected_action\n\n\tip neigh flush dev $rp2\n\n\tt0_packets=$(devlink_trap_rx_packets_get $trap_name)\n\n\t# Generate packets to h2 (will incur a unresolved neighbor).\n\t# The ping should pass and devlink counters should be increased.\n\tping_do $h1 $dip\n\tcheck_err $? \"ping failed: $desc\"\n\n\tt1_packets=$(devlink_trap_rx_packets_get $trap_name)\n\n\tif [[ $t0_packets -eq $t1_packets ]]; then\n\t\tcheck_err 1 \"Trap counter did not increase\"\n\tfi\n\n\tlog_test \"Unresolved neigh: host miss: $desc\"\n}\n\n__invalid_nexthop_test()\n{\n\tlocal desc=$1; shift\n\tlocal dip=$1; shift\n\tlocal extra_add=$1; shift\n\tlocal subnet=$1; shift\n\tlocal via_add=$1; shift\n\tlocal trap_name=\"unresolved_neigh\"\n\tlocal expected_action=\"trap\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\ttrap_action_check $trap_name $expected_action\n\n\tip address add $extra_add/$subnet dev $h2\n\n\t# Check that correct route does not trigger unresolved_neigh\n\tip $flags route add $dip via $extra_add dev $rp2\n\n\t# Generate packets in order to discover all neighbours.\n\t# Without it, counters of unresolved_neigh will be increased\n\t# during neighbours discovery and the check below will fail\n\t# for a wrong reason\n\tping_do $h1 $dip\n\n\tt0_packets=$(devlink_trap_rx_packets_get $trap_name)\n\tping_do $h1 $dip\n\tt1_packets=$(devlink_trap_rx_packets_get $trap_name)\n\n\tif [[ $t0_packets -ne $t1_packets ]]; then\n\t\tcheck_err 1 \"Trap counter increased when it should not\"\n\tfi\n\n\tip $flags route del $dip via $extra_add dev $rp2\n\n\t# Check that route to nexthop that does not exist trigger\n\t# unresolved_neigh\n\tip $flags route add $dip via $via_add dev $h2\n\n\tt0_packets=$(devlink_trap_rx_packets_get $trap_name)\n\tping_do $h1 $dip\n\tt1_packets=$(devlink_trap_rx_packets_get $trap_name)\n\n\tif [[ $t0_packets -eq $t1_packets ]]; then\n\t\tcheck_err 1 \"Trap counter did not increase\"\n\tfi\n\n\tip $flags route del $dip via $via_add dev $h2\n\tip address del $extra_add/$subnet dev $h2\n\tlog_test \"Unresolved neigh: nexthop does not exist: $desc\"\n}\n\n__invalid_nexthop_bucket_test()\n{\n\tlocal desc=$1; shift\n\tlocal dip=$1; shift\n\tlocal via_add=$1; shift\n\tlocal trap_name=\"unresolved_neigh\"\n\n\tRET=0\n\n\t# Check that route to nexthop that does not exist triggers\n\t# unresolved_neigh\n\tip nexthop add id 1 via $via_add dev $rp2\n\tip nexthop add id 10 group 1 type resilient buckets 32\n\tip route add $dip nhid 10\n\n\tt0_packets=$(devlink_trap_rx_packets_get $trap_name)\n\tping_do $h1 $dip\n\tt1_packets=$(devlink_trap_rx_packets_get $trap_name)\n\n\tif [[ $t0_packets -eq $t1_packets ]]; then\n\t\tcheck_err 1 \"Trap counter did not increase\"\n\tfi\n\n\tip route del $dip nhid 10\n\tip nexthop del id 10\n\tip nexthop del id 1\n\tlog_test \"Unresolved neigh: nexthop bucket does not exist: $desc\"\n}\n\nunresolved_neigh_test()\n{\n\t__host_miss_test \"IPv4\" 198.51.100.1\n\t__host_miss_test \"IPv6\" 2001:db8:2::1\n\t__invalid_nexthop_test \"IPv4\" 198.51.100.1 198.51.100.3 24 198.51.100.4\n\t__invalid_nexthop_test \"IPv6\" 2001:db8:2::1 2001:db8:2::3 64 \\\n\t\t2001:db8:2::4\n\t__invalid_nexthop_bucket_test \"IPv4\" 198.51.100.1 198.51.100.4\n\t__invalid_nexthop_bucket_test \"IPv6\" 2001:db8:2::1 2001:db8:2::4\n}\n\nvrf_without_routes_create()\n{\n\t# VRF creating makes the links to be down and then up again.\n\t# By default, IPv6 address is not saved after link becomes down.\n\t# Save IPv6 address using sysctl configuration.\n\tsysctl_set net.ipv6.conf.$rp1.keep_addr_on_down 1\n\tsysctl_set net.ipv6.conf.$rp2.keep_addr_on_down 1\n\n\tip link add dev vrf1 type vrf table 101\n\tip link set dev $rp1 master vrf1\n\tip link set dev $rp2 master vrf1\n\tip link set dev vrf1 up\n\n\t# Wait for rp1 and rp2 to be up\n\tsetup_wait\n}\n\nvrf_without_routes_destroy()\n{\n\tip link set dev $rp1 nomaster\n\tip link set dev $rp2 nomaster\n\tip link del dev vrf1\n\n\tsysctl_restore net.ipv6.conf.$rp2.keep_addr_on_down\n\tsysctl_restore net.ipv6.conf.$rp1.keep_addr_on_down\n\n\t# Wait for interfaces to be up\n\tsetup_wait\n}\n\nipv4_lpm_miss_test()\n{\n\tlocal trap_name=\"ipv4_lpm_miss\"\n\tlocal expected_action=\"trap\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\ttrap_action_check $trap_name $expected_action\n\n\t# Create a VRF without a default route\n\tvrf_without_routes_create\n\n\t# Generate packets through a VRF without a matching route.\n\t$MZ $h1 -t udp \"sp=54321,dp=12345\" -c 0 -d 1msec -b $rp1mac \\\n\t\t-B 203.0.113.1 -q &\n\tmz_pid=$!\n\n\tdevlink_trap_exception_test $trap_name\n\n\tlog_test \"LPM miss: IPv4\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\tvrf_without_routes_destroy\n}\n\nipv6_lpm_miss_test()\n{\n\tlocal trap_name=\"ipv6_lpm_miss\"\n\tlocal expected_action=\"trap\"\n\tlocal mz_pid\n\n\tRET=0\n\n\tping_check $trap_name\n\ttrap_action_check $trap_name $expected_action\n\n\t# Create a VRF without a default route\n\tvrf_without_routes_create\n\n\t# Generate packets through a VRF without a matching route.\n\t$MZ -6 $h1 -t udp \"sp=54321,dp=12345\" -c 0 -d 1msec -b $rp1mac \\\n\t\t-B 2001:db8::1 -q &\n\tmz_pid=$!\n\n\tdevlink_trap_exception_test $trap_name\n\n\tlog_test \"LPM miss: IPv6\"\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\tvrf_without_routes_destroy\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}