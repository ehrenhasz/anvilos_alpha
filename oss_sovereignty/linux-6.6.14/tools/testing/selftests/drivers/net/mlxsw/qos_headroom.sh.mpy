{
  "module_name": "qos_headroom.sh",
  "hash_id": "e1c5f89af214102105a186dc933bbddbd2e3b815ea766f5911def66e8aa5700a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/mlxsw/qos_headroom.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\nALL_TESTS=\"\n\ttest_defaults\n\ttest_dcb_ets\n\ttest_mtu\n\ttest_pfc\n\ttest_int_buf\n\ttest_tc_priomap\n\ttest_tc_mtu\n\ttest_tc_sizes\n\ttest_tc_int_buf\n\"\n\nlib_dir=$(dirname $0)/../../../net/forwarding\n\nNUM_NETIFS=0\nsource $lib_dir/lib.sh\nsource $lib_dir/devlink_lib.sh\n\nswp=$NETIF_NO_CABLE\n\ncleanup()\n{\n\tpre_cleanup\n}\n\nget_prio_pg()\n{\n\t# Produces a string of numbers \"<B0> <B1> ... <B7> \", where BX is number\n\t# of buffer that priority X is mapped to.\n\tdcb -j buffer show dev $swp |\n\t\tjq -r '[.prio_buffer | .[] | tostring + \" \"] | add'\n}\n\nget_prio_pfc()\n{\n\t# Produces a string of numbers \"<P0> <P1> ... <P7> \", where PX denotes\n\t# whether priority X has PFC enabled (the value is 1) or disabled (0).\n\tdcb -j pfc show dev $swp |\n\t\tjq -r '[.prio_pfc | .[] | if . then \"1 \" else \"0 \" end] | add'\n}\n\nget_prio_tc()\n{\n\t# Produces a string of numbers \"<T0> <T1> ... <T7> \", where TC is number\n\t# of TC that priority X is mapped to.\n\tdcb -j ets show dev $swp |\n\t\tjq -r '[.prio_tc | .[] | tostring + \" \"] | add'\n}\n\nget_buf_size()\n{\n\tlocal idx=$1; shift\n\n\tdcb -j buffer show dev $swp | jq \".buffer_size[$idx]\"\n}\n\nget_tot_size()\n{\n\tdcb -j buffer show dev $swp | jq '.total_size'\n}\n\ncheck_prio_pg()\n{\n\tlocal expect=$1; shift\n\n\tlocal current=$(get_prio_pg)\n\ttest \"$current\" = \"$expect\"\n\tcheck_err $? \"prio2buffer is '$current', expected '$expect'\"\n}\n\ncheck_prio_pfc()\n{\n\tlocal expect=$1; shift\n\n\tlocal current=$(get_prio_pfc)\n\ttest \"$current\" = \"$expect\"\n\tcheck_err $? \"prio PFC is '$current', expected '$expect'\"\n}\n\ncheck_prio_tc()\n{\n\tlocal expect=$1; shift\n\n\tlocal current=$(get_prio_tc)\n\ttest \"$current\" = \"$expect\"\n\tcheck_err $? \"prio_tc is '$current', expected '$expect'\"\n}\n\n__check_buf_size()\n{\n\tlocal idx=$1; shift\n\tlocal expr=$1; shift\n\tlocal what=$1; shift\n\n\tlocal current=$(get_buf_size $idx)\n\t((current $expr))\n\tcheck_err $? \"${what}buffer $idx size is '$current', expected '$expr'\"\n\techo $current\n}\n\ncheck_buf_size()\n{\n\t__check_buf_size \"$@\" > /dev/null\n}\n\ntest_defaults()\n{\n\tRET=0\n\n\tcheck_prio_pg \"0 0 0 0 0 0 0 0 \"\n\tcheck_prio_tc \"0 0 0 0 0 0 0 0 \"\n\tcheck_prio_pfc \"0 0 0 0 0 0 0 0 \"\n\n\tlog_test \"Default headroom configuration\"\n}\n\ntest_dcb_ets()\n{\n\tRET=0\n\n\tdcb ets set dev $swp prio-tc 0:0 1:2 2:4 3:6 4:1 5:3 6:5 7:7\n\n\tcheck_prio_pg \"0 2 4 6 1 3 5 7 \"\n\tcheck_prio_tc \"0 2 4 6 1 3 5 7 \"\n\tcheck_prio_pfc \"0 0 0 0 0 0 0 0 \"\n\n\tdcb ets set dev $swp prio-tc all:0\n\n\tcheck_prio_pg \"0 0 0 0 0 0 0 0 \"\n\tcheck_prio_tc \"0 0 0 0 0 0 0 0 \"\n\n\tdcb buffer set dev $swp prio-buffer 0:1 1:3 2:5 3:7 4:0 5:2 6:4 7:6 2>/dev/null\n\tcheck_fail $? \"prio2buffer accepted in DCB mode\"\n\n\tlog_test \"Configuring headroom through ETS\"\n}\n\ntest_mtu()\n{\n\tlocal what=$1; shift\n\tlocal buf0size_2\n\tlocal buf0size\n\n\tRET=0\n\tbuf0size=$(__check_buf_size 0 \"> 0\")\n\n\tmtu_set $swp 3000\n\tbuf0size_2=$(__check_buf_size 0 \"> $buf0size\" \"MTU 3000: \")\n\tmtu_restore $swp\n\n\tmtu_set $swp 6000\n\tcheck_buf_size 0 \"> $buf0size_2\" \"MTU 6000: \"\n\tmtu_restore $swp\n\n\tcheck_buf_size 0 \"== $buf0size\"\n\n\tlog_test \"${what}MTU impacts buffer size\"\n}\n\ntest_tc_mtu()\n{\n\t# In TC mode, MTU still impacts the threshold below which a buffer is\n\t# not permitted to go.\n\n\ttc qdisc replace dev $swp root handle 1: bfifo limit 1.5M\n\ttest_mtu \"TC: \"\n\ttc qdisc delete dev $swp root\n}\n\ntest_pfc()\n{\n\tRET=0\n\n\tdcb ets set dev $swp prio-tc all:0 5:1 6:2 7:3\n\n\tlocal buf0size=$(get_buf_size 0)\n\tlocal buf1size=$(get_buf_size 1)\n\tlocal buf2size=$(get_buf_size 2)\n\tlocal buf3size=$(get_buf_size 3)\n\tcheck_buf_size 0 \"> 0\"\n\tcheck_buf_size 1 \"> 0\"\n\tcheck_buf_size 2 \"> 0\"\n\tcheck_buf_size 3 \"> 0\"\n\tcheck_buf_size 4 \"== 0\"\n\tcheck_buf_size 5 \"== 0\"\n\tcheck_buf_size 6 \"== 0\"\n\tcheck_buf_size 7 \"== 0\"\n\n\tlog_test \"Buffer size sans PFC\"\n\n\tRET=0\n\n\tdcb pfc set dev $swp prio-pfc all:off 5:on 6:on 7:on delay 0\n\n\tcheck_prio_pg \"0 0 0 0 0 1 2 3 \"\n\tcheck_prio_pfc \"0 0 0 0 0 1 1 1 \"\n\tcheck_buf_size 0 \"== $buf0size\"\n\tcheck_buf_size 1 \"> $buf1size\"\n\tcheck_buf_size 2 \"> $buf2size\"\n\tcheck_buf_size 3 \"> $buf3size\"\n\n\tlocal buf1size=$(get_buf_size 1)\n\tcheck_buf_size 2 \"== $buf1size\"\n\tcheck_buf_size 3 \"== $buf1size\"\n\n\tlog_test \"PFC: Cable length 0\"\n\n\tRET=0\n\n\tdcb pfc set dev $swp delay 1000\n\n\tcheck_buf_size 0 \"== $buf0size\"\n\tcheck_buf_size 1 \"> $buf1size\"\n\tcheck_buf_size 2 \"> $buf1size\"\n\tcheck_buf_size 3 \"> $buf1size\"\n\n\tlog_test \"PFC: Cable length 1000\"\n\n\tRET=0\n\n\tdcb pfc set dev $swp prio-pfc all:off delay 0\n\tdcb ets set dev $swp prio-tc all:0\n\n\tcheck_prio_pg \"0 0 0 0 0 0 0 0 \"\n\tcheck_prio_tc \"0 0 0 0 0 0 0 0 \"\n\tcheck_buf_size 0 \"> 0\"\n\tcheck_buf_size 1 \"== 0\"\n\tcheck_buf_size 2 \"== 0\"\n\tcheck_buf_size 3 \"== 0\"\n\tcheck_buf_size 4 \"== 0\"\n\tcheck_buf_size 5 \"== 0\"\n\tcheck_buf_size 6 \"== 0\"\n\tcheck_buf_size 7 \"== 0\"\n\n\tlog_test \"PFC: Restore defaults\"\n}\n\ntest_tc_priomap()\n{\n\tRET=0\n\n\tdcb ets set dev $swp prio-tc 0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7\n\tcheck_prio_pg \"0 1 2 3 4 5 6 7 \"\n\n\ttc qdisc replace dev $swp root handle 1: bfifo limit 1.5M\n\tcheck_prio_pg \"0 0 0 0 0 0 0 0 \"\n\n\tdcb buffer set dev $swp prio-buffer 0:1 1:3 2:5 3:7 4:0 5:2 6:4 7:6\n\tcheck_prio_pg \"1 3 5 7 0 2 4 6 \"\n\n\ttc qdisc delete dev $swp root\n\tcheck_prio_pg \"0 1 2 3 4 5 6 7 \"\n\n\t# Clean up.\n\ttc qdisc replace dev $swp root handle 1: bfifo limit 1.5M\n\tdcb buffer set dev $swp prio-buffer all:0\n\ttc qdisc delete dev $swp root\n\tdcb ets set dev $swp prio-tc all:0\n\n\tlog_test \"TC: priomap\"\n}\n\ntest_tc_sizes()\n{\n\tlocal cell_size=$(devlink_cell_size_get)\n\tlocal size=$((cell_size * 1000))\n\n\tRET=0\n\n\tdcb buffer set dev $swp buffer-size all:0 0:$size 2>/dev/null\n\tcheck_fail $? \"buffer_size should fail before qdisc is added\"\n\n\ttc qdisc replace dev $swp root handle 1: bfifo limit 1.5M\n\n\tdcb buffer set dev $swp buffer-size all:0 0:$size\n\tcheck_err $? \"buffer_size should pass after qdisc is added\"\n\tcheck_buf_size 0 \"== $size\" \"set size: \"\n\n\tmtu_set $swp 6000\n\tcheck_buf_size 0 \"== $size\" \"set MTU: \"\n\tmtu_restore $swp\n\n\tdcb buffer set dev $swp buffer-size all:0\n\n\t# After replacing the qdisc for the same kind, buffer_size still has to\n\t# work.\n\ttc qdisc replace dev $swp root handle 1: bfifo limit 1M\n\n\tdcb buffer set dev $swp buffer-size all:0 0:$size\n\tcheck_buf_size 0 \"== $size\" \"post replace, set size: \"\n\n\tdcb buffer set dev $swp buffer-size all:0\n\n\t# Likewise after replacing for a different kind.\n\ttc qdisc replace dev $swp root handle 2: prio bands 8\n\n\tdcb buffer set dev $swp buffer-size all:0 0:$size\n\tcheck_buf_size 0 \"== $size\" \"post replace different kind, set size: \"\n\n\ttc qdisc delete dev $swp root\n\n\tdcb buffer set dev $swp buffer-size all:0 0:$size 2>/dev/null\n\tcheck_fail $? \"buffer_size should fail after qdisc is deleted\"\n\n\tlog_test \"TC: buffer size\"\n}\n\ntest_int_buf()\n{\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tlocal buf0size=$(get_buf_size 0)\n\tlocal tot_size=$(get_tot_size)\n\n\t# Size of internal buffer and buffer 9.\n\tlocal dsize=$((tot_size - buf0size))\n\n\ttc qdisc add dev $swp clsact\n\ttc filter add dev $swp egress matchall skip_sw action mirred egress mirror dev $swp\n\n\tlocal buf0size_2=$(get_buf_size 0)\n\tlocal tot_size_2=$(get_tot_size)\n\tlocal dsize_2=$((tot_size_2 - buf0size_2))\n\n\t# Egress SPAN should have added to the \"invisible\" buffer configuration.\n\t((dsize_2 > dsize))\n\tcheck_err $? \"Invisible buffers account for '$dsize_2', expected '> $dsize'\"\n\n\tmtu_set $swp 3000\n\n\tlocal buf0size_3=$(get_buf_size 0)\n\tlocal tot_size_3=$(get_tot_size)\n\tlocal dsize_3=$((tot_size_3 - buf0size_3))\n\n\t# MTU change might change buffer 0, which will show at total, but the\n\t# hidden buffers should stay the same size.\n\t((dsize_3 == dsize_2))\n\tcheck_err $? \"MTU change: Invisible buffers account for '$dsize_3', expected '== $dsize_2'\"\n\n\tmtu_restore $swp\n\ttc qdisc del dev $swp clsact\n\n\t# After SPAN removal, hidden buffers should be back to the original sizes.\n\tlocal buf0size_4=$(get_buf_size 0)\n\tlocal tot_size_4=$(get_tot_size)\n\tlocal dsize_4=$((tot_size_4 - buf0size_4))\n\t((dsize_4 == dsize))\n\tcheck_err $? \"SPAN removed: Invisible buffers account for '$dsize_4', expected '== $dsize'\"\n\n\tlog_test \"${what}internal buffer size\"\n}\n\ntest_tc_int_buf()\n{\n\tlocal cell_size=$(devlink_cell_size_get)\n\tlocal size=$((cell_size * 1000))\n\n\ttc qdisc replace dev $swp root handle 1: bfifo limit 1.5M\n\ttest_int_buf \"TC: \"\n\n\tdcb buffer set dev $swp buffer-size all:0 0:$size\n\ttest_int_buf \"TC+buffsize: \"\n\n\tdcb buffer set dev $swp buffer-size all:0\n\ttc qdisc delete dev $swp root\n}\n\nbail_on_lldpad \"configure DCB\" \"configure Qdiscs\"\n\ntrap cleanup EXIT\nsetup_wait\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}