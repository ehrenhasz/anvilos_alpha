{
  "module_name": "psfp.sh",
  "hash_id": "cfca0260a9dab618342b788e953ac18fd2082e37134e865e35b5e7626ecc650d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/ocelot/psfp.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# Copyright 2021-2022 NXP\n\n# Note: On LS1028A, in lack of enough user ports, this setup requires patching\n# the device tree to use the second CPU port as a user port\n\nWAIT_TIME=1\nNUM_NETIFS=4\nSTABLE_MAC_ADDRS=yes\nNETIF_CREATE=no\nlib_dir=$(dirname $0)/../../../net/forwarding\nsource $lib_dir/tc_common.sh\nsource $lib_dir/lib.sh\nsource $lib_dir/tsn_lib.sh\n\nUDS_ADDRESS_H1=\"/var/run/ptp4l_h1\"\nUDS_ADDRESS_SWP1=\"/var/run/ptp4l_swp1\"\n\n# Tunables\nNUM_PKTS=1000\nSTREAM_VID=100\nSTREAM_PRIO=6\n# Use a conservative cycle of 10 ms to allow the test to still pass when the\n# kernel has some extra overhead like lockdep etc\nCYCLE_TIME_NS=10000000\n# Create two Gate Control List entries, one OPEN and one CLOSE, of equal\n# durations\nGATE_DURATION_NS=$((${CYCLE_TIME_NS} / 2))\n# Give 2/3 of the cycle time to user space and 1/3 to the kernel\nFUDGE_FACTOR=$((${CYCLE_TIME_NS} / 3))\n# Shift the isochron base time by half the gate time, so that packets are\n# always received by swp1 close to the middle of the time slot, to minimize\n# inaccuracies due to network sync\nSHIFT_TIME_NS=$((${GATE_DURATION_NS} / 2))\n\nh1=${NETIFS[p1]}\nswp1=${NETIFS[p2]}\nswp2=${NETIFS[p3]}\nh2=${NETIFS[p4]}\n\nH1_IPV4=\"192.0.2.1\"\nH2_IPV4=\"192.0.2.2\"\nH1_IPV6=\"2001:db8:1::1\"\nH2_IPV6=\"2001:db8:1::2\"\n\n# Chain number exported by the ocelot driver for\n# Per-Stream Filtering and Policing filters\nPSFP()\n{\n\techo 30000\n}\n\npsfp_chain_create()\n{\n\tlocal if_name=$1\n\n\ttc qdisc add dev $if_name clsact\n\n\ttc filter add dev $if_name ingress chain 0 pref 49152 flower \\\n\t\tskip_sw action goto chain $(PSFP)\n}\n\npsfp_chain_destroy()\n{\n\tlocal if_name=$1\n\n\ttc qdisc del dev $if_name clsact\n}\n\npsfp_filter_check()\n{\n\tlocal expected=$1\n\tlocal packets=\"\"\n\tlocal drops=\"\"\n\tlocal stats=\"\"\n\n\tstats=$(tc -j -s filter show dev ${swp1} ingress chain $(PSFP) pref 1)\n\tpackets=$(echo ${stats} | jq \".[1].options.actions[].stats.packets\")\n\tdrops=$(echo ${stats} | jq \".[1].options.actions[].stats.drops\")\n\n\tif ! [ \"${packets}\" = \"${expected}\" ]; then\n\t\tprintf \"Expected filter to match on %d packets but matched on %d instead\\n\" \\\n\t\t\t\"${expected}\" \"${packets}\"\n\tfi\n\n\techo \"Hardware filter reports ${drops} drops\"\n}\n\nh1_create()\n{\n\tsimple_if_init $h1 $H1_IPV4/24 $H1_IPV6/64\n}\n\nh1_destroy()\n{\n\tsimple_if_fini $h1 $H1_IPV4/24 $H1_IPV6/64\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 $H2_IPV4/24 $H2_IPV6/64\n}\n\nh2_destroy()\n{\n\tsimple_if_fini $h2 $H2_IPV4/24 $H2_IPV6/64\n}\n\nswitch_create()\n{\n\tlocal h2_mac_addr=$(mac_get $h2)\n\n\tip link set ${swp1} up\n\tip link set ${swp2} up\n\n\tip link add br0 type bridge vlan_filtering 1\n\tip link set ${swp1} master br0\n\tip link set ${swp2} master br0\n\tip link set br0 up\n\n\tbridge vlan add dev ${swp2} vid ${STREAM_VID}\n\tbridge vlan add dev ${swp1} vid ${STREAM_VID}\n\t# PSFP on Ocelot requires the filter to also be added to the bridge\n\t# FDB, and not be removed\n\tbridge fdb add dev ${swp2} \\\n\t\t${h2_mac_addr} vlan ${STREAM_VID} static master\n\n\tpsfp_chain_create ${swp1}\n\n\ttc filter add dev ${swp1} ingress chain $(PSFP) pref 1 \\\n\t\tprotocol 802.1Q flower skip_sw \\\n\t\tdst_mac ${h2_mac_addr} vlan_id ${STREAM_VID} \\\n\t\taction gate base-time 0.000000000 \\\n\t\tsched-entry OPEN  ${GATE_DURATION_NS} -1 -1 \\\n\t\tsched-entry CLOSE ${GATE_DURATION_NS} -1 -1\n}\n\nswitch_destroy()\n{\n\tpsfp_chain_destroy ${swp1}\n\tip link del br0\n}\n\ntxtime_setup()\n{\n\tlocal if_name=$1\n\n\ttc qdisc add dev ${if_name} clsact\n\t# Classify PTP on TC 7 and isochron on TC 6\n\ttc filter add dev ${if_name} egress protocol 0x88f7 \\\n\t\tflower action skbedit priority 7\n\ttc filter add dev ${if_name} egress protocol 802.1Q \\\n\t\tflower vlan_ethtype 0xdead action skbedit priority 6\n\ttc qdisc add dev ${if_name} handle 100: parent root mqprio num_tc 8 \\\n\t\tqueues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 \\\n\t\tmap 0 1 2 3 4 5 6 7 \\\n\t\thw 1\n\t# Set up TC 6 for SO_TXTIME. tc-mqprio queues count from 1.\n\ttc qdisc replace dev ${if_name} parent 100:$((${STREAM_PRIO} + 1)) etf \\\n\t\tclockid CLOCK_TAI offload delta ${FUDGE_FACTOR}\n}\n\ntxtime_cleanup()\n{\n\tlocal if_name=$1\n\n\ttc qdisc del dev ${if_name} root\n\ttc qdisc del dev ${if_name} clsact\n}\n\nsetup_prepare()\n{\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\tswitch_create\n\n\ttxtime_setup ${h1}\n\n\t# Set up swp1 as a master PHC for h1, synchronized to the local\n\t# CLOCK_REALTIME.\n\tphc2sys_start ${UDS_ADDRESS_SWP1}\n\n\t# Assumption true for LS1028A: h1 and h2 use the same PHC. So by\n\t# synchronizing h1 to swp1 via PTP, h2 is also implicitly synchronized\n\t# to swp1 (and both to CLOCK_REALTIME).\n\tptp4l_start ${h1} true ${UDS_ADDRESS_H1}\n\tptp4l_start ${swp1} false ${UDS_ADDRESS_SWP1}\n\n\t# Make sure there are no filter matches at the beginning of the test\n\tpsfp_filter_check 0\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tptp4l_stop ${swp1}\n\tptp4l_stop ${h1}\n\tphc2sys_stop\n\tisochron_recv_stop\n\n\ttxtime_cleanup ${h1}\n\n\th2_destroy\n\th1_destroy\n\tswitch_destroy\n\n\tvrf_cleanup\n}\n\ndebug_incorrectly_dropped_packets()\n{\n\tlocal isochron_dat=$1\n\tlocal dropped_seqids\n\tlocal seqid\n\n\techo \"Packets incorrectly dropped:\"\n\n\tdropped_seqids=$(isochron report \\\n\t\t--input-file \"${isochron_dat}\" \\\n\t\t--printf-format \"%u RX hw %T\\n\" \\\n\t\t--printf-args \"qR\" | \\\n\t\tgrep 'RX hw 0.000000000' | \\\n\t\tawk '{print $1}')\n\n\tfor seqid in ${dropped_seqids}; do\n\t\tisochron report \\\n\t\t\t--input-file \"${isochron_dat}\" \\\n\t\t\t--start ${seqid} --stop ${seqid} \\\n\t\t\t--printf-format \"seqid %u scheduled for %T, HW TX timestamp %T\\n\" \\\n\t\t\t--printf-args \"qST\"\n\tdone\n}\n\ndebug_incorrectly_received_packets()\n{\n\tlocal isochron_dat=$1\n\n\techo \"Packets incorrectly received:\"\n\n\tisochron report \\\n\t\t--input-file \"${isochron_dat}\" \\\n\t\t--printf-format \"seqid %u scheduled for %T, HW TX timestamp %T, HW RX timestamp %T\\n\" \\\n\t\t--printf-args \"qSTR\" |\n\t\tgrep -v 'HW RX timestamp 0.000000000'\n}\n\nrun_test()\n{\n\tlocal base_time=$1\n\tlocal expected=$2\n\tlocal test_name=$3\n\tlocal debug=$4\n\tlocal isochron_dat=\"$(mktemp)\"\n\tlocal extra_args=\"\"\n\tlocal received\n\n\tisochron_do \\\n\t\t\"${h1}\" \\\n\t\t\"${h2}\" \\\n\t\t\"${UDS_ADDRESS_H1}\" \\\n\t\t\"\" \\\n\t\t\"${base_time}\" \\\n\t\t\"${CYCLE_TIME_NS}\" \\\n\t\t\"${SHIFT_TIME_NS}\" \\\n\t\t\"${NUM_PKTS}\" \\\n\t\t\"${STREAM_VID}\" \\\n\t\t\"${STREAM_PRIO}\" \\\n\t\t\"\" \\\n\t\t\"${isochron_dat}\"\n\n\t# Count all received packets by looking at the non-zero RX timestamps\n\treceived=$(isochron report \\\n\t\t--input-file \"${isochron_dat}\" \\\n\t\t--printf-format \"%u\\n\" --printf-args \"R\" | \\\n\t\tgrep -w -v '0' | wc -l)\n\n\tif [ \"${received}\" = \"${expected}\" ]; then\n\t\tRET=0\n\telse\n\t\tRET=1\n\t\techo \"Expected isochron to receive ${expected} packets but received ${received}\"\n\tfi\n\n\tlog_test \"${test_name}\"\n\n\tif [ \"$RET\" = \"1\" ]; then\n\t\t${debug} \"${isochron_dat}\"\n\tfi\n\n\trm ${isochron_dat} 2> /dev/null\n}\n\ntest_gate_in_band()\n{\n\t# Send packets in-band with the OPEN gate entry\n\trun_test 0.000000000 ${NUM_PKTS} \"In band\" \\\n\t\tdebug_incorrectly_dropped_packets\n\n\tpsfp_filter_check ${NUM_PKTS}\n}\n\ntest_gate_out_of_band()\n{\n\t# Send packets in-band with the CLOSE gate entry\n\trun_test 0.005000000 0 \"Out of band\" \\\n\t\tdebug_incorrectly_received_packets\n\n\tpsfp_filter_check $((2 * ${NUM_PKTS}))\n}\n\ntrap cleanup EXIT\n\nALL_TESTS=\"\n\ttest_gate_in_band\n\ttest_gate_out_of_band\n\"\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}