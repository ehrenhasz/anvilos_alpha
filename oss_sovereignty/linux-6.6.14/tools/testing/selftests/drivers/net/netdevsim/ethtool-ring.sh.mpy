{
  "module_name": "ethtool-ring.sh",
  "hash_id": "3c95d3cbac25b39c23b8c3eba2ffd8b99c501574b72617b2c2c1dc148ee94152",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/net/netdevsim/ethtool-ring.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0-only\n\nsource ethtool-common.sh\n\nfunction get_value {\n    local query=\"${SETTINGS_MAP[$1]}\"\n\n    echo $(ethtool -g $NSIM_NETDEV | \\\n        tail -n +$CURR_SETT_LINE | \\\n        awk -F':' -v pattern=\"$query:\" '$0 ~ pattern {gsub(/[\\t ]/, \"\", $2); print $2}')\n}\n\nfunction update_current_settings {\n    for key in ${!SETTINGS_MAP[@]}; do\n        CURRENT_SETTINGS[$key]=$(get_value $key)\n    done\n    echo ${CURRENT_SETTINGS[@]}\n}\n\nif ! ethtool -h | grep -q set-ring >/dev/null; then\n    echo \"SKIP: No --set-ring support in ethtool\"\n    exit 4\nfi\n\nNSIM_NETDEV=$(make_netdev)\n\nset -o pipefail\n\ndeclare -A SETTINGS_MAP=(\n    [\"rx\"]=\"RX\"\n    [\"rx-mini\"]=\"RX Mini\"\n    [\"rx-jumbo\"]=\"RX Jumbo\"\n    [\"tx\"]=\"TX\"\n)\n\ndeclare -A EXPECTED_SETTINGS=(\n    [\"rx\"]=\"\"\n    [\"rx-mini\"]=\"\"\n    [\"rx-jumbo\"]=\"\"\n    [\"tx\"]=\"\"\n)\n\ndeclare -A CURRENT_SETTINGS=(\n    [\"rx\"]=\"\"\n    [\"rx-mini\"]=\"\"\n    [\"rx-jumbo\"]=\"\"\n    [\"tx\"]=\"\"\n)\n\nMAX_VALUE=$((RANDOM % $((2**32-1))))\nRING_MAX_LIST=$(ls $NSIM_DEV_DFS/ethtool/ring/)\n\nfor ring_max_entry in $RING_MAX_LIST; do\n    echo $MAX_VALUE > $NSIM_DEV_DFS/ethtool/ring/$ring_max_entry\ndone\n\nCURR_SETT_LINE=$(ethtool -g $NSIM_NETDEV | grep -i -m1 -n 'Current hardware settings' | cut -f1 -d:)\n\n# populate the expected settings map\nfor key in ${!SETTINGS_MAP[@]}; do\n    EXPECTED_SETTINGS[$key]=$(get_value $key)\ndone\n\n# test\nfor key in ${!SETTINGS_MAP[@]}; do\n    value=$((RANDOM % $MAX_VALUE))\n\n    ethtool -G $NSIM_NETDEV \"$key\" \"$value\"\n\n    EXPECTED_SETTINGS[$key]=\"$value\"\n    expected=${EXPECTED_SETTINGS[@]}\n    current=$(update_current_settings)\n\n    check $? \"$current\" \"$expected\"\n    set +x\ndone\n\nif [ $num_errors -eq 0 ]; then\n    echo \"PASSED all $((num_passes)) checks\"\n    exit 0\nelse\n    echo \"FAILED $num_errors/$((num_errors+num_passes)) checks\"\n    exit 1\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}