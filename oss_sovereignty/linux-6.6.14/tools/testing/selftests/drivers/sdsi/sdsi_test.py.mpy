{
  "module_name": "sdsi_test.py",
  "hash_id": "f5a80c347a2d4070c7f943975c100d5b7f69370fd6337b3e512494be175a6bee",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/drivers/sdsi/sdsi_test.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n\nfrom struct import pack\nfrom time import sleep\n\nimport errno\nimport glob\nimport os\nimport subprocess\n\ntry:\n    import pytest\nexcept ImportError:\n    print(\"Unable to import pytest python module.\")\n    print(\"\\nIf not already installed, you may do so with:\")\n    print(\"\\t\\tpip3 install pytest\")\n    exit(1)\n\nSOCKETS = glob.glob('/sys/bus/auxiliary/devices/intel_vsec.sdsi.*')\nNUM_SOCKETS = len(SOCKETS)\n\nMODULE_NAME = 'intel_sdsi'\nDEV_PREFIX = 'intel_vsec.sdsi'\nCLASS_DIR = '/sys/bus/auxiliary/devices'\nGUID = \"0x6dd191\"\n\ndef read_bin_file(file):\n    with open(file, mode='rb') as f:\n        content = f.read()\n    return content\n\ndef get_dev_file_path(socket, file):\n    return CLASS_DIR + '/' + DEV_PREFIX + '.' + str(socket) + '/' + file\n\ndef kmemleak_enabled():\n    kmemleak = \"/sys/kernel/debug/kmemleak\"\n    return os.path.isfile(kmemleak)\n\nclass TestSDSiDriver:\n    def test_driver_loaded(self):\n        lsmod_p = subprocess.Popen(('lsmod'), stdout=subprocess.PIPE)\n        result = subprocess.check_output(('grep', '-q', MODULE_NAME), stdin=lsmod_p.stdout)\n\n@pytest.mark.parametrize('socket', range(0, NUM_SOCKETS))\nclass TestSDSiFilesClass:\n\n    def read_value(self, file):\n        f = open(file, \"r\")\n        value = f.read().strip(\"\\n\")\n        return value\n\n    def get_dev_folder(self, socket):\n        return CLASS_DIR + '/' + DEV_PREFIX + '.' + str(socket) + '/'\n\n    def test_sysfs_files_exist(self, socket):\n        folder = self.get_dev_folder(socket)\n        print (folder)\n        assert os.path.isfile(folder + \"guid\") == True\n        assert os.path.isfile(folder + \"provision_akc\") == True\n        assert os.path.isfile(folder + \"provision_cap\") == True\n        assert os.path.isfile(folder + \"state_certificate\") == True\n        assert os.path.isfile(folder + \"registers\") == True\n\n    def test_sysfs_file_permissions(self, socket):\n        folder = self.get_dev_folder(socket)\n        mode = os.stat(folder + \"guid\").st_mode & 0o777\n        assert mode == 0o444    # Read all\n        mode = os.stat(folder + \"registers\").st_mode & 0o777\n        assert mode == 0o400    # Read owner\n        mode = os.stat(folder + \"provision_akc\").st_mode & 0o777\n        assert mode == 0o200    # Read owner\n        mode = os.stat(folder + \"provision_cap\").st_mode & 0o777\n        assert mode == 0o200    # Read owner\n        mode = os.stat(folder + \"state_certificate\").st_mode & 0o777\n        assert mode == 0o400    # Read owner\n\n    def test_sysfs_file_ownership(self, socket):\n        folder = self.get_dev_folder(socket)\n\n        st = os.stat(folder + \"guid\")\n        assert st.st_uid == 0\n        assert st.st_gid == 0\n\n        st = os.stat(folder + \"registers\")\n        assert st.st_uid == 0\n        assert st.st_gid == 0\n\n        st = os.stat(folder + \"provision_akc\")\n        assert st.st_uid == 0\n        assert st.st_gid == 0\n\n        st = os.stat(folder + \"provision_cap\")\n        assert st.st_uid == 0\n        assert st.st_gid == 0\n\n        st = os.stat(folder + \"state_certificate\")\n        assert st.st_uid == 0\n        assert st.st_gid == 0\n\n    def test_sysfs_file_sizes(self, socket):\n        folder = self.get_dev_folder(socket)\n\n        if self.read_value(folder + \"guid\") == GUID:\n            st = os.stat(folder + \"registers\")\n            assert st.st_size == 72\n\n        st = os.stat(folder + \"provision_akc\")\n        assert st.st_size == 1024\n\n        st = os.stat(folder + \"provision_cap\")\n        assert st.st_size == 1024\n\n        st = os.stat(folder + \"state_certificate\")\n        assert st.st_size == 4096\n\n    def test_no_seek_allowed(self, socket):\n        folder = self.get_dev_folder(socket)\n        rand_file = bytes(os.urandom(8))\n\n        f = open(folder + \"provision_cap\", \"wb\", 0)\n        f.seek(1)\n        with pytest.raises(OSError) as error:\n            f.write(rand_file)\n        assert error.value.errno == errno.ESPIPE\n        f.close()\n\n        f = open(folder + \"provision_akc\", \"wb\", 0)\n        f.seek(1)\n        with pytest.raises(OSError) as error:\n            f.write(rand_file)\n        assert error.value.errno == errno.ESPIPE\n        f.close()\n\n    def test_registers_seek(self, socket):\n        folder = self.get_dev_folder(socket)\n\n        # Check that the value read from an offset of the entire\n        # file is none-zero and the same as the value read\n        # from seeking to the same location\n        f = open(folder + \"registers\", \"rb\")\n        data = f.read()\n        f.seek(64)\n        id = f.read()\n        assert id != bytes(0)\n        assert data[64:] == id\n        f.close()\n\n@pytest.mark.parametrize('socket', range(0, NUM_SOCKETS))\nclass TestSDSiMailboxCmdsClass:\n    def test_provision_akc_eoverflow_1017_bytes(self, socket):\n\n        # The buffer for writes is 1k, of with 8 bytes must be\n        # reserved for the command, leaving 1016 bytes max.\n        # Check that we get an overflow error for 1017 bytes.\n        node = get_dev_file_path(socket, \"provision_akc\")\n        rand_file = bytes(os.urandom(1017))\n\n        f = open(node, 'wb', 0)\n        with pytest.raises(OSError) as error:\n            f.write(rand_file)\n        assert error.value.errno == errno.EOVERFLOW\n        f.close()\n\n@pytest.mark.parametrize('socket', range(0, NUM_SOCKETS))\nclass TestSdsiDriverLocksClass:\n    def test_enodev_when_pci_device_removed(self, socket):\n        node = get_dev_file_path(socket, \"provision_akc\")\n        dev_name = DEV_PREFIX + '.' + str(socket)\n        driver_dir = CLASS_DIR + '/' + dev_name + \"/driver/\"\n        rand_file = bytes(os.urandom(8))\n\n        f = open(node, 'wb', 0)\n        g = open(node, 'wb', 0)\n\n        with open(driver_dir + 'unbind', 'w') as k:\n            print(dev_name, file = k)\n\n        with pytest.raises(OSError) as error:\n            f.write(rand_file)\n        assert error.value.errno == errno.ENODEV\n\n        with pytest.raises(OSError) as error:\n            g.write(rand_file)\n        assert error.value.errno == errno.ENODEV\n\n        f.close()\n        g.close()\n\n        # Short wait needed to allow file to close before pulling driver\n        sleep(1)\n\n        p = subprocess.Popen(('modprobe', '-r', 'intel_sdsi'))\n        p.wait()\n        p = subprocess.Popen(('modprobe', '-r', 'intel_vsec'))\n        p.wait()\n        p = subprocess.Popen(('modprobe', 'intel_vsec'))\n        p.wait()\n\n        # Short wait needed to allow driver time to get inserted\n        # before continuing tests\n        sleep(1)\n\n    def test_memory_leak(self, socket):\n        if not kmemleak_enabled():\n            pytest.skip(\"kmemleak not enabled in kernel\")\n\n        dev_name = DEV_PREFIX + '.' + str(socket)\n        driver_dir = CLASS_DIR + '/' + dev_name + \"/driver/\"\n\n        with open(driver_dir + 'unbind', 'w') as k:\n            print(dev_name, file = k)\n\n        sleep(1)\n\n        subprocess.check_output(('modprobe', '-r', 'intel_sdsi'))\n        subprocess.check_output(('modprobe', '-r', 'intel_vsec'))\n\n        with open('/sys/kernel/debug/kmemleak', 'w') as f:\n            print('scan', file = f)\n        sleep(5)\n\n        assert os.stat('/sys/kernel/debug/kmemleak').st_size == 0\n\n        subprocess.check_output(('modprobe', 'intel_vsec'))\n        sleep(1)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}