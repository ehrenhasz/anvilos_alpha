{
  "module_name": "unprivileged-remount-test.c",
  "hash_id": "9917627bfdb6615cb497255ae8a48074d982f45007de681bbcc4279e9099a46a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mount/unprivileged-remount-test.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/statvfs.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <stdbool.h>\n#include <stdarg.h>\n\n#ifndef CLONE_NEWNS\n# define CLONE_NEWNS 0x00020000\n#endif\n#ifndef CLONE_NEWUTS\n# define CLONE_NEWUTS 0x04000000\n#endif\n#ifndef CLONE_NEWIPC\n# define CLONE_NEWIPC 0x08000000\n#endif\n#ifndef CLONE_NEWNET\n# define CLONE_NEWNET 0x40000000\n#endif\n#ifndef CLONE_NEWUSER\n# define CLONE_NEWUSER 0x10000000\n#endif\n#ifndef CLONE_NEWPID\n# define CLONE_NEWPID 0x20000000\n#endif\n\n#ifndef MS_REC\n# define MS_REC 16384\n#endif\n#ifndef MS_RELATIME\n# define MS_RELATIME (1 << 21)\n#endif\n#ifndef MS_STRICTATIME\n# define MS_STRICTATIME (1 << 24)\n#endif\n\nstatic void die(char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\texit(EXIT_FAILURE);\n}\n\nstatic void vmaybe_write_file(bool enoent_ok, char *filename, char *fmt, va_list ap)\n{\n\tchar buf[4096];\n\tint fd;\n\tssize_t written;\n\tint buf_len;\n\n\tbuf_len = vsnprintf(buf, sizeof(buf), fmt, ap);\n\tif (buf_len < 0) {\n\t\tdie(\"vsnprintf failed: %s\\n\",\n\t\t    strerror(errno));\n\t}\n\tif (buf_len >= sizeof(buf)) {\n\t\tdie(\"vsnprintf output truncated\\n\");\n\t}\n\n\tfd = open(filename, O_WRONLY);\n\tif (fd < 0) {\n\t\tif ((errno == ENOENT) && enoent_ok)\n\t\t\treturn;\n\t\tdie(\"open of %s failed: %s\\n\",\n\t\t    filename, strerror(errno));\n\t}\n\twritten = write(fd, buf, buf_len);\n\tif (written != buf_len) {\n\t\tif (written >= 0) {\n\t\t\tdie(\"short write to %s\\n\", filename);\n\t\t} else {\n\t\t\tdie(\"write to %s failed: %s\\n\",\n\t\t\t\tfilename, strerror(errno));\n\t\t}\n\t}\n\tif (close(fd) != 0) {\n\t\tdie(\"close of %s failed: %s\\n\",\n\t\t\tfilename, strerror(errno));\n\t}\n}\n\nstatic void maybe_write_file(char *filename, char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvmaybe_write_file(true, filename, fmt, ap);\n\tva_end(ap);\n\n}\n\nstatic void write_file(char *filename, char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvmaybe_write_file(false, filename, fmt, ap);\n\tva_end(ap);\n\n}\n\nstatic int read_mnt_flags(const char *path)\n{\n\tint ret;\n\tstruct statvfs stat;\n\tint mnt_flags;\n\n\tret = statvfs(path, &stat);\n\tif (ret != 0) {\n\t\tdie(\"statvfs of %s failed: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t}\n\tif (stat.f_flag & ~(ST_RDONLY | ST_NOSUID | ST_NODEV | \\\n\t\t\tST_NOEXEC | ST_NOATIME | ST_NODIRATIME | ST_RELATIME | \\\n\t\t\tST_SYNCHRONOUS | ST_MANDLOCK)) {\n\t\tdie(\"Unrecognized mount flags\\n\");\n\t}\n\tmnt_flags = 0;\n\tif (stat.f_flag & ST_RDONLY)\n\t\tmnt_flags |= MS_RDONLY;\n\tif (stat.f_flag & ST_NOSUID)\n\t\tmnt_flags |= MS_NOSUID;\n\tif (stat.f_flag & ST_NODEV)\n\t\tmnt_flags |= MS_NODEV;\n\tif (stat.f_flag & ST_NOEXEC)\n\t\tmnt_flags |= MS_NOEXEC;\n\tif (stat.f_flag & ST_NOATIME)\n\t\tmnt_flags |= MS_NOATIME;\n\tif (stat.f_flag & ST_NODIRATIME)\n\t\tmnt_flags |= MS_NODIRATIME;\n\tif (stat.f_flag & ST_RELATIME)\n\t\tmnt_flags |= MS_RELATIME;\n\tif (stat.f_flag & ST_SYNCHRONOUS)\n\t\tmnt_flags |= MS_SYNCHRONOUS;\n\tif (stat.f_flag & ST_MANDLOCK)\n\t\tmnt_flags |= ST_MANDLOCK;\n\n\treturn mnt_flags;\n}\n\nstatic void create_and_enter_userns(void)\n{\n\tuid_t uid;\n\tgid_t gid;\n\n\tuid = getuid();\n\tgid = getgid();\n\n\tif (unshare(CLONE_NEWUSER) !=0) {\n\t\tdie(\"unshare(CLONE_NEWUSER) failed: %s\\n\",\n\t\t\tstrerror(errno));\n\t}\n\n\tmaybe_write_file(\"/proc/self/setgroups\", \"deny\");\n\twrite_file(\"/proc/self/uid_map\", \"0 %d 1\", uid);\n\twrite_file(\"/proc/self/gid_map\", \"0 %d 1\", gid);\n\n\tif (setgid(0) != 0) {\n\t\tdie (\"setgid(0) failed %s\\n\",\n\t\t\tstrerror(errno));\n\t}\n\tif (setuid(0) != 0) {\n\t\tdie(\"setuid(0) failed %s\\n\",\n\t\t\tstrerror(errno));\n\t}\n}\n\nstatic\nbool test_unpriv_remount(const char *fstype, const char *mount_options,\n\t\t\t int mount_flags, int remount_flags, int invalid_flags)\n{\n\tpid_t child;\n\n\tchild = fork();\n\tif (child == -1) {\n\t\tdie(\"fork failed: %s\\n\",\n\t\t\tstrerror(errno));\n\t}\n\tif (child != 0) {  \n\t\tpid_t pid;\n\t\tint status;\n\t\tpid = waitpid(child, &status, 0);\n\t\tif (pid == -1) {\n\t\t\tdie(\"waitpid failed: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\t}\n\t\tif (pid != child) {\n\t\t\tdie(\"waited for %d got %d\\n\",\n\t\t\t\tchild, pid);\n\t\t}\n\t\tif (!WIFEXITED(status)) {\n\t\t\tdie(\"child did not terminate cleanly\\n\");\n\t\t}\n\t\treturn WEXITSTATUS(status) == EXIT_SUCCESS;\n\t}\n\n\tcreate_and_enter_userns();\n\tif (unshare(CLONE_NEWNS) != 0) {\n\t\tdie(\"unshare(CLONE_NEWNS) failed: %s\\n\",\n\t\t\tstrerror(errno));\n\t}\n\n\tif (mount(\"testing\", \"/tmp\", fstype, mount_flags, mount_options) != 0) {\n\t\tdie(\"mount of %s with options '%s' on /tmp failed: %s\\n\",\n\t\t    fstype,\n\t\t    mount_options? mount_options : \"\",\n\t\t    strerror(errno));\n\t}\n\n\tcreate_and_enter_userns();\n\n\tif (unshare(CLONE_NEWNS) != 0) {\n\t\tdie(\"unshare(CLONE_NEWNS) failed: %s\\n\",\n\t\t\tstrerror(errno));\n\t}\n\n\tif (mount(\"/tmp\", \"/tmp\", \"none\",\n\t\t  MS_REMOUNT | MS_BIND | remount_flags, NULL) != 0) {\n\t\t \n\t\tdie(\"remount of /tmp failed: %s\\n\",\n\t\t    strerror(errno));\n\t}\n\n\tif (mount(\"/tmp\", \"/tmp\", \"none\",\n\t\t  MS_REMOUNT | MS_BIND | invalid_flags, NULL) == 0) {\n\t\t \n\t\tdie(\"remount of /tmp with invalid flags \"\n\t\t    \"succeeded unexpectedly\\n\");\n\t}\n\texit(EXIT_SUCCESS);\n}\n\nstatic bool test_unpriv_remount_simple(int mount_flags)\n{\n\treturn test_unpriv_remount(\"ramfs\", NULL, mount_flags, mount_flags, 0);\n}\n\nstatic bool test_unpriv_remount_atime(int mount_flags, int invalid_flags)\n{\n\treturn test_unpriv_remount(\"ramfs\", NULL, mount_flags, mount_flags,\n\t\t\t\t   invalid_flags);\n}\n\nstatic bool test_priv_mount_unpriv_remount(void)\n{\n\tpid_t child;\n\tint ret;\n\tconst char *orig_path = \"/dev\";\n\tconst char *dest_path = \"/tmp\";\n\tint orig_mnt_flags, remount_mnt_flags;\n\n\tchild = fork();\n\tif (child == -1) {\n\t\tdie(\"fork failed: %s\\n\",\n\t\t\tstrerror(errno));\n\t}\n\tif (child != 0) {  \n\t\tpid_t pid;\n\t\tint status;\n\t\tpid = waitpid(child, &status, 0);\n\t\tif (pid == -1) {\n\t\t\tdie(\"waitpid failed: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\t}\n\t\tif (pid != child) {\n\t\t\tdie(\"waited for %d got %d\\n\",\n\t\t\t\tchild, pid);\n\t\t}\n\t\tif (!WIFEXITED(status)) {\n\t\t\tdie(\"child did not terminate cleanly\\n\");\n\t\t}\n\t\treturn WEXITSTATUS(status) == EXIT_SUCCESS;\n\t}\n\n\torig_mnt_flags = read_mnt_flags(orig_path);\n\n\tcreate_and_enter_userns();\n\tret = unshare(CLONE_NEWNS);\n\tif (ret != 0) {\n\t\tdie(\"unshare(CLONE_NEWNS) failed: %s\\n\",\n\t\t\tstrerror(errno));\n\t}\n\n\tret = mount(orig_path, dest_path, \"bind\", MS_BIND | MS_REC, NULL);\n\tif (ret != 0) {\n\t\tdie(\"recursive bind mount of %s onto %s failed: %s\\n\",\n\t\t\torig_path, dest_path, strerror(errno));\n\t}\n\n\tret = mount(dest_path, dest_path, \"none\",\n\t\t    MS_REMOUNT | MS_BIND | orig_mnt_flags , NULL);\n\tif (ret != 0) {\n\t\t \n\t\tdie(\"remount of /tmp failed: %s\\n\",\n\t\t    strerror(errno));\n\t}\n\n\tremount_mnt_flags = read_mnt_flags(dest_path);\n\tif (orig_mnt_flags != remount_mnt_flags) {\n\t\tdie(\"Mount flags unexpectedly changed during remount of %s originally mounted on %s\\n\",\n\t\t\tdest_path, orig_path);\n\t}\n\texit(EXIT_SUCCESS);\n}\n\nint main(int argc, char **argv)\n{\n\tif (!test_unpriv_remount_simple(MS_RDONLY)) {\n\t\tdie(\"MS_RDONLY malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount(\"devpts\", \"newinstance\", MS_NODEV, MS_NODEV, 0)) {\n\t\tdie(\"MS_NODEV malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount_simple(MS_NOSUID)) {\n\t\tdie(\"MS_NOSUID malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount_simple(MS_NOEXEC)) {\n\t\tdie(\"MS_NOEXEC malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount_atime(MS_RELATIME,\n\t\t\t\t       MS_NOATIME))\n\t{\n\t\tdie(\"MS_RELATIME malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount_atime(MS_STRICTATIME,\n\t\t\t\t       MS_NOATIME))\n\t{\n\t\tdie(\"MS_STRICTATIME malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount_atime(MS_NOATIME,\n\t\t\t\t       MS_STRICTATIME))\n\t{\n\t\tdie(\"MS_NOATIME malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount_atime(MS_RELATIME|MS_NODIRATIME,\n\t\t\t\t       MS_NOATIME))\n\t{\n\t\tdie(\"MS_RELATIME|MS_NODIRATIME malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount_atime(MS_STRICTATIME|MS_NODIRATIME,\n\t\t\t\t       MS_NOATIME))\n\t{\n\t\tdie(\"MS_STRICTATIME|MS_NODIRATIME malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount_atime(MS_NOATIME|MS_NODIRATIME,\n\t\t\t\t       MS_STRICTATIME))\n\t{\n\t\tdie(\"MS_NOATIME|MS_DIRATIME malfunctions\\n\");\n\t}\n\tif (!test_unpriv_remount(\"ramfs\", NULL, MS_STRICTATIME, 0, MS_NOATIME))\n\t{\n\t\tdie(\"Default atime malfunctions\\n\");\n\t}\n\tif (!test_priv_mount_unpriv_remount()) {\n\t\tdie(\"Mount flags unexpectedly changed after remount\\n\");\n\t}\n\treturn EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}