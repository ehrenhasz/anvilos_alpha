{
  "module_name": "safesetid-test.c",
  "hash_id": "4a4ae3ee703e97a991a67bd6ae9ef3f5bcbe10e2db88aa93d9c1e1b2032d3048",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/safesetid/safesetid-test.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <errno.h>\n#include <pwd.h>\n#include <grp.h>\n#include <string.h>\n#include <syscall.h>\n#include <sys/capability.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stdarg.h>\n\n \n\n#ifndef CLONE_NEWUSER\n# define CLONE_NEWUSER 0x10000000\n#endif\n\n#define ROOT_UGID 0\n#define RESTRICTED_PARENT_UGID 1\n#define ALLOWED_CHILD1_UGID 2\n#define ALLOWED_CHILD2_UGID 3\n#define NO_POLICY_UGID 4\n\n#define UGID_POLICY_STRING \"1:2\\n1:3\\n2:2\\n3:3\\n\"\n\nchar* add_uid_whitelist_policy_file = \"/sys/kernel/security/safesetid/uid_allowlist_policy\";\nchar* add_gid_whitelist_policy_file = \"/sys/kernel/security/safesetid/gid_allowlist_policy\";\n\nstatic void die(char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\texit(EXIT_FAILURE);\n}\n\nstatic bool vmaybe_write_file(bool enoent_ok, char *filename, char *fmt, va_list ap)\n{\n\tchar buf[4096];\n\tint fd;\n\tssize_t written;\n\tint buf_len;\n\n\tbuf_len = vsnprintf(buf, sizeof(buf), fmt, ap);\n\tif (buf_len < 0) {\n\t\tprintf(\"vsnprintf failed: %s\\n\",\n\t\t    strerror(errno));\n\t\treturn false;\n\t}\n\tif (buf_len >= sizeof(buf)) {\n\t\tprintf(\"vsnprintf output truncated\\n\");\n\t\treturn false;\n\t}\n\n\tfd = open(filename, O_WRONLY);\n\tif (fd < 0) {\n\t\tif ((errno == ENOENT) && enoent_ok)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\twritten = write(fd, buf, buf_len);\n\tif (written != buf_len) {\n\t\tif (written >= 0) {\n\t\t\tprintf(\"short write to %s\\n\", filename);\n\t\t\treturn false;\n\t\t} else {\n\t\t\tprintf(\"write to %s failed: %s\\n\",\n\t\t\t\tfilename, strerror(errno));\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (close(fd) != 0) {\n\t\tprintf(\"close of %s failed: %s\\n\",\n\t\t\tfilename, strerror(errno));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool write_file(char *filename, char *fmt, ...)\n{\n\tva_list ap;\n\tbool ret;\n\n\tva_start(ap, fmt);\n\tret = vmaybe_write_file(false, filename, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\nstatic void ensure_user_exists(uid_t uid)\n{\n\tstruct passwd p;\n\n\tFILE *fd;\n\tchar name_str[10];\n\n\tif (getpwuid(uid) == NULL) {\n\t\tmemset(&p,0x00,sizeof(p));\n\t\tfd=fopen(\"/etc/passwd\",\"a\");\n\t\tif (fd == NULL)\n\t\t\tdie(\"couldn't open file\\n\");\n\t\tif (fseek(fd, 0, SEEK_END))\n\t\t\tdie(\"couldn't fseek\\n\");\n\t\tsnprintf(name_str, 10, \"user %d\", uid);\n\t\tp.pw_name=name_str;\n\t\tp.pw_uid=uid;\n\t\tp.pw_gid=uid;\n\t\tp.pw_gecos=\"Test account\";\n\t\tp.pw_dir=\"/dev/null\";\n\t\tp.pw_shell=\"/bin/false\";\n\t\tint value = putpwent(&p,fd);\n\t\tif (value != 0)\n\t\t\tdie(\"putpwent failed\\n\");\n\t\tif (fclose(fd))\n\t\t\tdie(\"fclose failed\\n\");\n\t}\n}\n\nstatic void ensure_group_exists(gid_t gid)\n{\n\tstruct group g;\n\n\tFILE *fd;\n\tchar name_str[10];\n\n\tif (getgrgid(gid) == NULL) {\n\t\tmemset(&g,0x00,sizeof(g));\n\t\tfd=fopen(\"/etc/group\",\"a\");\n\t\tif (fd == NULL)\n\t\t\tdie(\"couldn't open group file\\n\");\n\t\tif (fseek(fd, 0, SEEK_END))\n\t\t\tdie(\"couldn't fseek group file\\n\");\n\t\tsnprintf(name_str, 10, \"group %d\", gid);\n\t\tg.gr_name=name_str;\n\t\tg.gr_gid=gid;\n\t\tg.gr_passwd=NULL;\n\t\tg.gr_mem=NULL;\n\t\tint value = putgrent(&g,fd);\n\t\tif (value != 0)\n\t\t\tdie(\"putgrent failed\\n\");\n\t\tif (fclose(fd))\n\t\t\tdie(\"fclose failed\\n\");\n\t}\n}\n\nstatic void ensure_securityfs_mounted(void)\n{\n\tint fd = open(add_uid_whitelist_policy_file, O_WRONLY);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\t\n\t\t\tif (mount(\"securityfs\", \"/sys/kernel/security\",\n\t\t\t\t\t\t\"securityfs\", 0, NULL) < 0)\n\t\t\t\tdie(\"mounting securityfs failed\\n\");\n\t\t} else {\n\t\t\tdie(\"couldn't find securityfs for unknown reason\\n\");\n\t\t}\n\t} else {\n\t\tif (close(fd) != 0) {\n\t\t\tdie(\"close of %s failed: %s\\n\",\n\t\t\t\tadd_uid_whitelist_policy_file, strerror(errno));\n\t\t}\n\t}\n}\n\nstatic void write_uid_policies()\n{\n\tstatic char *policy_str = UGID_POLICY_STRING;\n\tssize_t written;\n\tint fd;\n\n\tfd = open(add_uid_whitelist_policy_file, O_WRONLY);\n\tif (fd < 0)\n\t\tdie(\"can't open add_uid_whitelist_policy file\\n\");\n\twritten = write(fd, policy_str, strlen(policy_str));\n\tif (written != strlen(policy_str)) {\n\t\tif (written >= 0) {\n\t\t\tdie(\"short write to %s\\n\", add_uid_whitelist_policy_file);\n\t\t} else {\n\t\t\tdie(\"write to %s failed: %s\\n\",\n\t\t\t\tadd_uid_whitelist_policy_file, strerror(errno));\n\t\t}\n\t}\n\tif (close(fd) != 0) {\n\t\tdie(\"close of %s failed: %s\\n\",\n\t\t\tadd_uid_whitelist_policy_file, strerror(errno));\n\t}\n}\n\nstatic void write_gid_policies()\n{\n\tstatic char *policy_str = UGID_POLICY_STRING;\n\tssize_t written;\n\tint fd;\n\n\tfd = open(add_gid_whitelist_policy_file, O_WRONLY);\n\tif (fd < 0)\n\t\tdie(\"can't open add_gid_whitelist_policy file\\n\");\n\twritten = write(fd, policy_str, strlen(policy_str));\n\tif (written != strlen(policy_str)) {\n\t\tif (written >= 0) {\n\t\t\tdie(\"short write to %s\\n\", add_gid_whitelist_policy_file);\n\t\t} else {\n\t\t\tdie(\"write to %s failed: %s\\n\",\n\t\t\t\tadd_gid_whitelist_policy_file, strerror(errno));\n\t\t}\n\t}\n\tif (close(fd) != 0) {\n\t\tdie(\"close of %s failed: %s\\n\",\n\t\t\tadd_gid_whitelist_policy_file, strerror(errno));\n\t}\n}\n\n\nstatic bool test_userns(bool expect_success)\n{\n\tuid_t uid;\n\tchar map_file_name[32];\n\tsize_t sz = sizeof(map_file_name);\n\tpid_t cpid;\n\tbool success;\n\n\tuid = getuid();\n\n\tint clone_flags = CLONE_NEWUSER;\n\tcpid = syscall(SYS_clone, clone_flags, NULL);\n\tif (cpid == -1) {\n\t    printf(\"clone failed\");\n\t    return false;\n\t}\n\n\tif (cpid == 0) {\t \n\t\t\n\t\tsleep(1);\n\t\texit(EXIT_SUCCESS);\n\t} else {\t\t \n\t\tif(snprintf(map_file_name, sz, \"/proc/%d/uid_map\", cpid) < 0) {\n\t\t\tprintf(\"preparing file name string failed\");\n\t\t\treturn false;\n\t\t}\n\t\tsuccess = write_file(map_file_name, \"0 %d 1\", uid);\n\t\treturn success == expect_success;\n\t}\n\n\tprintf(\"should not reach here\");\n\treturn false;\n}\n\nstatic void test_setuid(uid_t child_uid, bool expect_success)\n{\n\tpid_t cpid, w;\n\tint wstatus;\n\n\tcpid = fork();\n\tif (cpid == -1) {\n\t\tdie(\"fork\\n\");\n\t}\n\n\tif (cpid == 0) {\t     \n\t\tif (setuid(child_uid) < 0)\n\t\t\texit(EXIT_FAILURE);\n\t\tif (getuid() == child_uid)\n\t\t\texit(EXIT_SUCCESS);\n\t\telse\n\t\t\texit(EXIT_FAILURE);\n\t} else {\t\t  \n\t\tdo {\n\t\t\tw = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);\n\t\t\tif (w == -1) {\n\t\t\t\tdie(\"waitpid\\n\");\n\t\t\t}\n\n\t\t\tif (WIFEXITED(wstatus)) {\n\t\t\t\tif (WEXITSTATUS(wstatus) == EXIT_SUCCESS) {\n\t\t\t\t\tif (expect_success) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdie(\"unexpected success\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (expect_success) {\n\t\t\t\t\t\tdie(\"unexpected failure\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (WIFSIGNALED(wstatus)) {\n\t\t\t\tif (WTERMSIG(wstatus) == 9) {\n\t\t\t\t\tif (expect_success)\n\t\t\t\t\t\tdie(\"killed unexpectedly\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdie(\"unexpected signal: %d\\n\", wstatus);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdie(\"unexpected status: %d\\n\", wstatus);\n\t\t\t}\n\t\t} while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));\n\t}\n\n\tdie(\"should not reach here\\n\");\n}\n\nstatic void test_setgid(gid_t child_gid, bool expect_success)\n{\n\tpid_t cpid, w;\n\tint wstatus;\n\n\tcpid = fork();\n\tif (cpid == -1) {\n\t\tdie(\"fork\\n\");\n\t}\n\n\tif (cpid == 0) {\t     \n\t\tif (setgid(child_gid) < 0)\n\t\t\texit(EXIT_FAILURE);\n\t\tif (getgid() == child_gid)\n\t\t\texit(EXIT_SUCCESS);\n\t\telse\n\t\t\texit(EXIT_FAILURE);\n\t} else {\t\t  \n\t\tdo {\n\t\t\tw = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);\n\t\t\tif (w == -1) {\n\t\t\t\tdie(\"waitpid\\n\");\n\t\t\t}\n\n\t\t\tif (WIFEXITED(wstatus)) {\n\t\t\t\tif (WEXITSTATUS(wstatus) == EXIT_SUCCESS) {\n\t\t\t\t\tif (expect_success) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdie(\"unexpected success\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (expect_success) {\n\t\t\t\t\t\tdie(\"unexpected failure\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (WIFSIGNALED(wstatus)) {\n\t\t\t\tif (WTERMSIG(wstatus) == 9) {\n\t\t\t\t\tif (expect_success)\n\t\t\t\t\t\tdie(\"killed unexpectedly\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdie(\"unexpected signal: %d\\n\", wstatus);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdie(\"unexpected status: %d\\n\", wstatus);\n\t\t\t}\n\t\t} while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));\n\t}\n\n\tdie(\"should not reach here\\n\");\n}\n\nstatic void test_setgroups(gid_t* child_groups, size_t len, bool expect_success)\n{\n\tpid_t cpid, w;\n\tint wstatus;\n\tgid_t groupset[len];\n\tint i, j;\n\n\tcpid = fork();\n\tif (cpid == -1) {\n\t\tdie(\"fork\\n\");\n\t}\n\n\tif (cpid == 0) {\t     \n\t\tif (setgroups(len, child_groups) != 0)\n\t\t\texit(EXIT_FAILURE);\n\t\tif (getgroups(len, groupset) != len)\n\t\t\texit(EXIT_FAILURE);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tfor (j = 0; j < len; j++) {\n\t\t\t\tif (child_groups[i] == groupset[j])\n\t\t\t\t\tbreak;\n\t\t\t\tif (j == len - 1)\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t\texit(EXIT_SUCCESS);\n\t} else {\t\t  \n\t\tdo {\n\t\t\tw = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);\n\t\t\tif (w == -1) {\n\t\t\t\tdie(\"waitpid\\n\");\n\t\t\t}\n\n\t\t\tif (WIFEXITED(wstatus)) {\n\t\t\t\tif (WEXITSTATUS(wstatus) == EXIT_SUCCESS) {\n\t\t\t\t\tif (expect_success) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdie(\"unexpected success\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (expect_success) {\n\t\t\t\t\t\tdie(\"unexpected failure\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (WIFSIGNALED(wstatus)) {\n\t\t\t\tif (WTERMSIG(wstatus) == 9) {\n\t\t\t\t\tif (expect_success)\n\t\t\t\t\t\tdie(\"killed unexpectedly\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdie(\"unexpected signal: %d\\n\", wstatus);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdie(\"unexpected status: %d\\n\", wstatus);\n\t\t\t}\n\t\t} while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));\n\t}\n\n\tdie(\"should not reach here\\n\");\n}\n\n\nstatic void ensure_users_exist(void)\n{\n\tensure_user_exists(ROOT_UGID);\n\tensure_user_exists(RESTRICTED_PARENT_UGID);\n\tensure_user_exists(ALLOWED_CHILD1_UGID);\n\tensure_user_exists(ALLOWED_CHILD2_UGID);\n\tensure_user_exists(NO_POLICY_UGID);\n}\n\nstatic void ensure_groups_exist(void)\n{\n\tensure_group_exists(ROOT_UGID);\n\tensure_group_exists(RESTRICTED_PARENT_UGID);\n\tensure_group_exists(ALLOWED_CHILD1_UGID);\n\tensure_group_exists(ALLOWED_CHILD2_UGID);\n\tensure_group_exists(NO_POLICY_UGID);\n}\n\nstatic void drop_caps(bool setid_retained)\n{\n\tcap_value_t cap_values[] = {CAP_SETUID, CAP_SETGID};\n\tcap_t caps;\n\n\tcaps = cap_get_proc();\n\tif (setid_retained)\n\t\tcap_set_flag(caps, CAP_EFFECTIVE, 2, cap_values, CAP_SET);\n\telse\n\t\tcap_clear(caps);\n\tcap_set_proc(caps);\n\tcap_free(caps);\n}\n\nint main(int argc, char **argv)\n{\n\tensure_groups_exist();\n\tensure_users_exist();\n\tensure_securityfs_mounted();\n\twrite_uid_policies();\n\twrite_gid_policies();\n\n\tif (prctl(PR_SET_KEEPCAPS, 1L))\n\t\tdie(\"Error with set keepcaps\\n\");\n\n\t\n\t\n\t\n\tif (setgid(NO_POLICY_UGID) < 0)\n\t\tdie(\"Error with set gid(%d)\\n\", NO_POLICY_UGID);\n\tif (setuid(NO_POLICY_UGID) < 0)\n\t\tdie(\"Error with set uid(%d)\\n\", NO_POLICY_UGID);\n\t\n\tdrop_caps(true);\n\t\n\t\n\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0))\n\t\tdie(\"Error with set dumpable\\n\");\n\tif (!test_userns(true)) {\n\t\tdie(\"test_userns failed when it should work\\n\");\n\t}\n\n\t\n\tif (setgid(RESTRICTED_PARENT_UGID) < 0)\n\t\tdie(\"Error with set gid(%d)\\n\", RESTRICTED_PARENT_UGID);\n\tif (setuid(RESTRICTED_PARENT_UGID) < 0)\n\t\tdie(\"Error with set uid(%d)\\n\", RESTRICTED_PARENT_UGID);\n\n\ttest_setuid(ROOT_UGID, false);\n\ttest_setuid(ALLOWED_CHILD1_UGID, true);\n\ttest_setuid(ALLOWED_CHILD2_UGID, true);\n\ttest_setuid(NO_POLICY_UGID, false);\n\n\ttest_setgid(ROOT_UGID, false);\n\ttest_setgid(ALLOWED_CHILD1_UGID, true);\n\ttest_setgid(ALLOWED_CHILD2_UGID, true);\n\ttest_setgid(NO_POLICY_UGID, false);\n\n\tgid_t allowed_supp_groups[2] = {ALLOWED_CHILD1_UGID, ALLOWED_CHILD2_UGID};\n\tgid_t disallowed_supp_groups[2] = {ROOT_UGID, NO_POLICY_UGID};\n\ttest_setgroups(allowed_supp_groups, 2, true);\n\ttest_setgroups(disallowed_supp_groups, 2, false);\n\n\tif (!test_userns(false)) {\n\t\tdie(\"test_userns worked when it should fail\\n\");\n\t}\n\n\t\n\tdrop_caps(false);\n\ttest_setuid(2, false);\n\ttest_setuid(3, false);\n\ttest_setuid(4, false);\n\ttest_setgid(2, false);\n\ttest_setgid(3, false);\n\ttest_setgid(4, false);\n\n\t\n\t\n\tprintf(\"test successful!\\n\");\n\treturn EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}