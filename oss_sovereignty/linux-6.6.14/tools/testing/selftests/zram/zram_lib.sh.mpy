{
  "module_name": "zram_lib.sh",
  "hash_id": "f4b9991fe0085824b770199e5f5cc7aa8f1a228342cbbfac8a32ebc65d29c11c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/zram/zram_lib.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0-or-later\n# Copyright (c) 2015 Oracle and/or its affiliates. All Rights Reserved.\n#\n# Author: Alexey Kodanev <alexey.kodanev@oracle.com>\n# Modified: Naresh Kamboju <naresh.kamboju@linaro.org>\n\ndev_makeswap=-1\ndev_mounted=-1\ndev_start=0\ndev_end=-1\nmodule_load=-1\nsys_control=-1\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nkernel_version=`uname -r | cut -d'.' -f1,2`\nkernel_major=${kernel_version%.*}\nkernel_minor=${kernel_version#*.}\n\ntrap INT\n\ncheck_prereqs()\n{\n\tlocal msg=\"skip all tests:\"\n\tlocal uid=$(id -u)\n\n\tif [ $uid -ne 0 ]; then\n\t\techo $msg must be run as root >&2\n\t\texit $ksft_skip\n\tfi\n}\n\nkernel_gte()\n{\n\tmajor=${1%.*}\n\tminor=${1#*.}\n\n\tif [ $kernel_major -gt $major ]; then\n\t\treturn 0\n\telif [[ $kernel_major -eq $major && $kernel_minor -ge $minor ]]; then\n\t\treturn 0\n\tfi\n\n\treturn 1\n}\n\nzram_cleanup()\n{\n\techo \"zram cleanup\"\n\tlocal i=\n\tfor i in $(seq $dev_start $dev_makeswap); do\n\t\tswapoff /dev/zram$i\n\tdone\n\n\tfor i in $(seq $dev_start $dev_mounted); do\n\t\tumount /dev/zram$i\n\tdone\n\n\tfor i in $(seq $dev_start $dev_end); do\n\t\techo 1 > /sys/block/zram${i}/reset\n\t\trm -rf zram$i\n\tdone\n\n\tif [ $sys_control -eq 1 ]; then\n\t\tfor i in $(seq $dev_start $dev_end); do\n\t\t\techo $i > /sys/class/zram-control/hot_remove\n\t\tdone\n\tfi\n\n\tif [ $module_load -eq 1 ]; then\n\t\trmmod zram > /dev/null 2>&1\n\tfi\n}\n\nzram_load()\n{\n\techo \"create '$dev_num' zram device(s)\"\n\n\t# zram module loaded, new kernel\n\tif [ -d \"/sys/class/zram-control\" ]; then\n\t\techo \"zram modules already loaded, kernel supports\" \\\n\t\t\t\"zram-control interface\"\n\t\tdev_start=$(ls /dev/zram* | wc -w)\n\t\tdev_end=$(($dev_start + $dev_num - 1))\n\t\tsys_control=1\n\n\t\tfor i in $(seq $dev_start $dev_end); do\n\t\t\tcat /sys/class/zram-control/hot_add > /dev/null\n\t\tdone\n\n\t\techo \"all zram devices (/dev/zram$dev_start~$dev_end\" \\\n\t\t\t\"successfully created\"\n\t\treturn 0\n\tfi\n\n\t# detect old kernel or built-in\n\tmodprobe zram num_devices=$dev_num\n\tif [ ! -d \"/sys/class/zram-control\" ]; then\n\t\tif grep -q '^zram' /proc/modules; then\n\t\t\trmmod zram > /dev/null 2>&1\n\t\t\tif [ $? -ne 0 ]; then\n\t\t\t\techo \"zram module is being used on old kernel\" \\\n\t\t\t\t\t\"without zram-control interface\"\n\t\t\t\texit $ksft_skip\n\t\t\tfi\n\t\telse\n\t\t\techo \"test needs CONFIG_ZRAM=m on old kernel without\" \\\n\t\t\t\t\"zram-control interface\"\n\t\t\texit $ksft_skip\n\t\tfi\n\t\tmodprobe zram num_devices=$dev_num\n\tfi\n\n\tmodule_load=1\n\tdev_end=$(($dev_num - 1))\n\techo \"all zram devices (/dev/zram0~$dev_end) successfully created\"\n}\n\nzram_max_streams()\n{\n\techo \"set max_comp_streams to zram device(s)\"\n\n\tkernel_gte 4.7\n\tif [ $? -eq 0 ]; then\n\t\techo \"The device attribute max_comp_streams was\"\\\n\t\t               \"deprecated in 4.7\"\n\t\treturn 0\n\tfi\n\n\tlocal i=$dev_start\n\tfor max_s in $zram_max_streams; do\n\t\tlocal sys_path=\"/sys/block/zram${i}/max_comp_streams\"\n\t\techo $max_s > $sys_path || \\\n\t\t\techo \"FAIL failed to set '$max_s' to $sys_path\"\n\t\tsleep 1\n\t\tlocal max_streams=$(cat $sys_path)\n\n\t\t[ \"$max_s\" -ne \"$max_streams\" ] && \\\n\t\t\techo \"FAIL can't set max_streams '$max_s', get $max_stream\"\n\n\t\ti=$(($i + 1))\n\t\techo \"$sys_path = '$max_streams'\"\n\tdone\n\n\techo \"zram max streams: OK\"\n}\n\nzram_compress_alg()\n{\n\techo \"test that we can set compression algorithm\"\n\n\tlocal i=$dev_start\n\tlocal algs=$(cat /sys/block/zram${i}/comp_algorithm)\n\techo \"supported algs: $algs\"\n\n\tfor alg in $zram_algs; do\n\t\tlocal sys_path=\"/sys/block/zram${i}/comp_algorithm\"\n\t\techo \"$alg\" >\t$sys_path || \\\n\t\t\techo \"FAIL can't set '$alg' to $sys_path\"\n\t\ti=$(($i + 1))\n\t\techo \"$sys_path = '$alg'\"\n\tdone\n\n\techo \"zram set compression algorithm: OK\"\n}\n\nzram_set_disksizes()\n{\n\techo \"set disk size to zram device(s)\"\n\tlocal i=$dev_start\n\tfor ds in $zram_sizes; do\n\t\tlocal sys_path=\"/sys/block/zram${i}/disksize\"\n\t\techo \"$ds\" >\t$sys_path || \\\n\t\t\techo \"FAIL can't set '$ds' to $sys_path\"\n\n\t\ti=$(($i + 1))\n\t\techo \"$sys_path = '$ds'\"\n\tdone\n\n\techo \"zram set disksizes: OK\"\n}\n\nzram_set_memlimit()\n{\n\techo \"set memory limit to zram device(s)\"\n\n\tlocal i=$dev_start\n\tfor ds in $zram_mem_limits; do\n\t\tlocal sys_path=\"/sys/block/zram${i}/mem_limit\"\n\t\techo \"$ds\" >\t$sys_path || \\\n\t\t\techo \"FAIL can't set '$ds' to $sys_path\"\n\n\t\ti=$(($i + 1))\n\t\techo \"$sys_path = '$ds'\"\n\tdone\n\n\techo \"zram set memory limit: OK\"\n}\n\nzram_makeswap()\n{\n\techo \"make swap with zram device(s)\"\n\tlocal i=$dev_start\n\tfor i in $(seq $dev_start $dev_end); do\n\t\tmkswap /dev/zram$i > err.log 2>&1\n\t\tif [ $? -ne 0 ]; then\n\t\t\tcat err.log\n\t\t\techo \"FAIL mkswap /dev/zram$1 failed\"\n\t\tfi\n\n\t\tswapon /dev/zram$i > err.log 2>&1\n\t\tif [ $? -ne 0 ]; then\n\t\t\tcat err.log\n\t\t\techo \"FAIL swapon /dev/zram$1 failed\"\n\t\tfi\n\n\t\techo \"done with /dev/zram$i\"\n\t\tdev_makeswap=$i\n\tdone\n\n\techo \"zram making zram mkswap and swapon: OK\"\n}\n\nzram_swapoff()\n{\n\tlocal i=\n\tfor i in $(seq $dev_start $dev_end); do\n\t\tswapoff /dev/zram$i > err.log 2>&1\n\t\tif [ $? -ne 0 ]; then\n\t\t\tcat err.log\n\t\t\techo \"FAIL swapoff /dev/zram$i failed\"\n\t\tfi\n\tdone\n\tdev_makeswap=-1\n\n\techo \"zram swapoff: OK\"\n}\n\nzram_makefs()\n{\n\tlocal i=$dev_start\n\tfor fs in $zram_filesystems; do\n\t\t# if requested fs not supported default it to ext2\n\t\twhich mkfs.$fs > /dev/null 2>&1 || fs=ext2\n\n\t\techo \"make $fs filesystem on /dev/zram$i\"\n\t\tmkfs.$fs /dev/zram$i > err.log 2>&1\n\t\tif [ $? -ne 0 ]; then\n\t\t\tcat err.log\n\t\t\techo \"FAIL failed to make $fs on /dev/zram$i\"\n\t\tfi\n\t\ti=$(($i + 1))\n\t\techo \"zram mkfs.$fs: OK\"\n\tdone\n}\n\nzram_mount()\n{\n\tlocal i=0\n\tfor i in $(seq $dev_start $dev_end); do\n\t\techo \"mount /dev/zram$i\"\n\t\tmkdir zram$i\n\t\tmount /dev/zram$i zram$i > /dev/null || \\\n\t\t\techo \"FAIL mount /dev/zram$i failed\"\n\t\tdev_mounted=$i\n\tdone\n\n\techo \"zram mount of zram device(s): OK\"\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}