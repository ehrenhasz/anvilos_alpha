{
  "module_name": "aliasing-test.c",
  "hash_id": "9bed825123ff394c665f3916ec3a1b54b8828d224b4cefb35a7c40ea217bc012",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ia64/aliasing-test.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <fnmatch.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <linux/pci.h>\n\nint sum;\n\nstatic int map_mem(char *path, off_t offset, size_t length, int touch)\n{\n\tint fd, rc;\n\tvoid *addr;\n\tint *c;\n\n\tfd = open(path, O_RDWR);\n\tif (fd == -1) {\n\t\tperror(path);\n\t\treturn -1;\n\t}\n\n\tif (fnmatch(\"/proc/bus/pci/*\", path, 0) == 0) {\n\t\trc = ioctl(fd, PCIIOC_MMAP_IS_MEM);\n\t\tif (rc == -1)\n\t\t\tperror(\"PCIIOC_MMAP_IS_MEM ioctl\");\n\t}\n\n\taddr = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset);\n\tif (addr == MAP_FAILED)\n\t\treturn 1;\n\n\tif (touch) {\n\t\tc = (int *) addr;\n\t\twhile (c < (int *) (addr + length))\n\t\t\tsum += *c++;\n\t}\n\n\trc = munmap(addr, length);\n\tif (rc == -1) {\n\t\tperror(\"munmap\");\n\t\treturn -1;\n\t}\n\n\tclose(fd);\n\treturn 0;\n}\n\nstatic int scan_tree(char *path, char *file, off_t offset, size_t length, int touch)\n{\n\tstruct dirent **namelist;\n\tchar *name, *path2;\n\tint i, n, r, rc = 0, result = 0;\n\tstruct stat buf;\n\n\tn = scandir(path, &namelist, 0, alphasort);\n\tif (n < 0) {\n\t\tperror(\"scandir\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tname = namelist[i]->d_name;\n\n\t\tif (fnmatch(\".\", name, 0) == 0)\n\t\t\tgoto skip;\n\t\tif (fnmatch(\"..\", name, 0) == 0)\n\t\t\tgoto skip;\n\n\t\tpath2 = malloc(strlen(path) + strlen(name) + 3);\n\t\tstrcpy(path2, path);\n\t\tstrcat(path2, \"/\");\n\t\tstrcat(path2, name);\n\n\t\tif (fnmatch(file, name, 0) == 0) {\n\t\t\trc = map_mem(path2, offset, length, touch);\n\t\t\tif (rc == 0)\n\t\t\t\tfprintf(stderr, \"PASS: %s 0x%lx-0x%lx is %s\\n\", path2, offset, offset + length, touch ? \"readable\" : \"mappable\");\n\t\t\telse if (rc > 0)\n\t\t\t\tfprintf(stderr, \"PASS: %s 0x%lx-0x%lx not mappable\\n\", path2, offset, offset + length);\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"FAIL: %s 0x%lx-0x%lx not accessible\\n\", path2, offset, offset + length);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tr = lstat(path2, &buf);\n\t\t\tif (r == 0 && S_ISDIR(buf.st_mode)) {\n\t\t\t\trc = scan_tree(path2, file, offset, length, touch);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tresult |= rc;\n\t\tfree(path2);\n\nskip:\n\t\tfree(namelist[i]);\n\t}\n\tfree(namelist);\n\treturn result;\n}\n\nchar buf[1024];\n\nstatic int read_rom(char *path)\n{\n\tint fd, rc;\n\tsize_t size = 0;\n\n\tfd = open(path, O_RDWR);\n\tif (fd == -1) {\n\t\tperror(path);\n\t\treturn -1;\n\t}\n\n\trc = write(fd, \"1\", 2);\n\tif (rc <= 0) {\n\t\tclose(fd);\n\t\tperror(\"write\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\trc = read(fd, buf, sizeof(buf));\n\t\tif (rc > 0)\n\t\t\tsize += rc;\n\t} while (rc > 0);\n\n\tclose(fd);\n\treturn size;\n}\n\nstatic int scan_rom(char *path, char *file)\n{\n\tstruct dirent **namelist;\n\tchar *name, *path2;\n\tint i, n, r, rc = 0, result = 0;\n\tstruct stat buf;\n\n\tn = scandir(path, &namelist, 0, alphasort);\n\tif (n < 0) {\n\t\tperror(\"scandir\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tname = namelist[i]->d_name;\n\n\t\tif (fnmatch(\".\", name, 0) == 0)\n\t\t\tgoto skip;\n\t\tif (fnmatch(\"..\", name, 0) == 0)\n\t\t\tgoto skip;\n\n\t\tpath2 = malloc(strlen(path) + strlen(name) + 3);\n\t\tstrcpy(path2, path);\n\t\tstrcat(path2, \"/\");\n\t\tstrcat(path2, name);\n\n\t\tif (fnmatch(file, name, 0) == 0) {\n\t\t\trc = read_rom(path2);\n\n\t\t\t \n\t\t\tif (rc > 0)\n\t\t\t\tfprintf(stderr, \"PASS: %s read %d bytes\\n\", path2, rc);\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"PASS: %s not readable\\n\", path2);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tr = lstat(path2, &buf);\n\t\t\tif (r == 0 && S_ISDIR(buf.st_mode)) {\n\t\t\t\trc = scan_rom(path2, file);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tresult |= rc;\n\t\tfree(path2);\n\nskip:\n\t\tfree(namelist[i]);\n\t}\n\tfree(namelist);\n\treturn result;\n}\n\nint main(void)\n{\n\tint rc;\n\n\tif (map_mem(\"/dev/mem\", 0, 0xA0000, 1) == 0)\n\t\tfprintf(stderr, \"PASS: /dev/mem 0x0-0xa0000 is readable\\n\");\n\telse\n\t\tfprintf(stderr, \"FAIL: /dev/mem 0x0-0xa0000 not accessible\\n\");\n\n\t \n\tif (map_mem(\"/dev/mem\", 0xA0000, 0x20000, 0) == 0)\n\t\tfprintf(stderr, \"PASS: /dev/mem 0xa0000-0xc0000 is mappable\\n\");\n\telse\n\t\tfprintf(stderr, \"FAIL: /dev/mem 0xa0000-0xc0000 not accessible\\n\");\n\n\tif (map_mem(\"/dev/mem\", 0xC0000, 0x40000, 1) == 0)\n\t\tfprintf(stderr, \"PASS: /dev/mem 0xc0000-0x100000 is readable\\n\");\n\telse\n\t\tfprintf(stderr, \"FAIL: /dev/mem 0xc0000-0x100000 not accessible\\n\");\n\n\t \n\trc = map_mem(\"/dev/mem\", 0, 1024*1024, 0);\n\tif (rc == 0)\n\t\tfprintf(stderr, \"PASS: /dev/mem 0x0-0x100000 is mappable\\n\");\n\telse if (rc > 0)\n\t\tfprintf(stderr, \"PASS: /dev/mem 0x0-0x100000 not mappable\\n\");\n\telse\n\t\tfprintf(stderr, \"FAIL: /dev/mem 0x0-0x100000 not accessible\\n\");\n\n\tscan_tree(\"/sys/class/pci_bus\", \"legacy_mem\", 0, 0xA0000, 1);\n\tscan_tree(\"/sys/class/pci_bus\", \"legacy_mem\", 0xA0000, 0x20000, 0);\n\tscan_tree(\"/sys/class/pci_bus\", \"legacy_mem\", 0xC0000, 0x40000, 1);\n\tscan_tree(\"/sys/class/pci_bus\", \"legacy_mem\", 0, 1024*1024, 0);\n\n\tscan_rom(\"/sys/devices\", \"rom\");\n\n\tscan_tree(\"/proc/bus/pci\", \"??.?\", 0, 0xA0000, 1);\n\tscan_tree(\"/proc/bus/pci\", \"??.?\", 0xA0000, 0x20000, 0);\n\tscan_tree(\"/proc/bus/pci\", \"??.?\", 0xC0000, 0x40000, 1);\n\tscan_tree(\"/proc/bus/pci\", \"??.?\", 0, 1024*1024, 0);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}