{
  "module_name": "close_range_test.c",
  "hash_id": "56f1333ed63dd360c70059969745abe190b4c883ffad5d109ea06decd4e38421",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/core/close_range_test.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/kernel.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syscall.h>\n#include <unistd.h>\n#include <sys/resource.h>\n\n#include \"../kselftest_harness.h\"\n#include \"../clone3/clone3_selftests.h\"\n\n#ifndef __NR_close_range\n\t#if defined __alpha__\n\t\t#define __NR_close_range 546\n\t#elif defined _MIPS_SIM\n\t\t#if _MIPS_SIM == _MIPS_SIM_ABI32\t \n\t\t\t#define __NR_close_range (436 + 4000)\n\t\t#endif\n\t\t#if _MIPS_SIM == _MIPS_SIM_NABI32\t \n\t\t\t#define __NR_close_range (436 + 6000)\n\t\t#endif\n\t\t#if _MIPS_SIM == _MIPS_SIM_ABI64\t \n\t\t\t#define __NR_close_range (436 + 5000)\n\t\t#endif\n\t#elif defined __ia64__\n\t\t#define __NR_close_range (436 + 1024)\n\t#else\n\t\t#define __NR_close_range 436\n\t#endif\n#endif\n\n#ifndef CLOSE_RANGE_UNSHARE\n#define CLOSE_RANGE_UNSHARE\t(1U << 1)\n#endif\n\n#ifndef CLOSE_RANGE_CLOEXEC\n#define CLOSE_RANGE_CLOEXEC\t(1U << 2)\n#endif\n\nstatic inline int sys_close_range(unsigned int fd, unsigned int max_fd,\n\t\t\t\t  unsigned int flags)\n{\n\treturn syscall(__NR_close_range, fd, max_fd, flags);\n}\n\nTEST(core_close_range)\n{\n\tint i, ret;\n\tint open_fds[101];\n\n\tfor (i = 0; i < ARRAY_SIZE(open_fds); i++) {\n\t\tint fd;\n\n\t\tfd = open(\"/dev/null\", O_RDONLY | O_CLOEXEC);\n\t\tASSERT_GE(fd, 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tSKIP(return, \"Skipping test since /dev/null does not exist\");\n\t\t}\n\n\t\topen_fds[i] = fd;\n\t}\n\n\tEXPECT_EQ(-1, sys_close_range(open_fds[0], open_fds[100], -1)) {\n\t\tif (errno == ENOSYS)\n\t\t\tSKIP(return, \"close_range() syscall not supported\");\n\t}\n\n\tEXPECT_EQ(0, sys_close_range(open_fds[0], open_fds[50], 0));\n\n\tfor (i = 0; i <= 50; i++)\n\t\tEXPECT_EQ(-1, fcntl(open_fds[i], F_GETFL));\n\n\tfor (i = 51; i <= 100; i++)\n\t\tEXPECT_GT(fcntl(open_fds[i], F_GETFL), -1);\n\n\t \n\tclose(57);\n\tclose(78);\n\tclose(81);\n\tclose(82);\n\tclose(84);\n\tclose(90);\n\n\tEXPECT_EQ(0, sys_close_range(open_fds[51], open_fds[92], 0));\n\n\tfor (i = 51; i <= 92; i++)\n\t\tEXPECT_EQ(-1, fcntl(open_fds[i], F_GETFL));\n\n\tfor (i = 93; i <= 100; i++)\n\t\tEXPECT_GT(fcntl(open_fds[i], F_GETFL), -1);\n\n\t \n\tEXPECT_EQ(0, sys_close_range(open_fds[93], open_fds[99], 0));\n\n\tfor (i = 93; i <= 99; i++)\n\t\tEXPECT_EQ(-1, fcntl(open_fds[i], F_GETFL));\n\n\tEXPECT_GT(fcntl(open_fds[i], F_GETFL), -1);\n\n\tEXPECT_EQ(0, sys_close_range(open_fds[100], open_fds[100], 0));\n\n\tEXPECT_EQ(-1, fcntl(open_fds[100], F_GETFL));\n}\n\nTEST(close_range_unshare)\n{\n\tint i, ret, status;\n\tpid_t pid;\n\tint open_fds[101];\n\tstruct __clone_args args = {\n\t\t.flags = CLONE_FILES,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(open_fds); i++) {\n\t\tint fd;\n\n\t\tfd = open(\"/dev/null\", O_RDONLY | O_CLOEXEC);\n\t\tASSERT_GE(fd, 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tSKIP(return, \"Skipping test since /dev/null does not exist\");\n\t\t}\n\n\t\topen_fds[i] = fd;\n\t}\n\n\tpid = sys_clone3(&args, sizeof(args));\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tret = sys_close_range(open_fds[0], open_fds[50],\n\t\t\t\t      CLOSE_RANGE_UNSHARE);\n\t\tif (ret)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tfor (i = 0; i <= 50; i++)\n\t\t\tif (fcntl(open_fds[i], F_GETFL) != -1)\n\t\t\t\texit(EXIT_FAILURE);\n\n\t\tfor (i = 51; i <= 100; i++)\n\t\t\tif (fcntl(open_fds[i], F_GETFL) == -1)\n\t\t\t\texit(EXIT_FAILURE);\n\n\t\t \n\t\tclose(57);\n\t\tclose(78);\n\t\tclose(81);\n\t\tclose(82);\n\t\tclose(84);\n\t\tclose(90);\n\n\t\tret = sys_close_range(open_fds[51], open_fds[92],\n\t\t\t\t      CLOSE_RANGE_UNSHARE);\n\t\tif (ret)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tfor (i = 51; i <= 92; i++)\n\t\t\tif (fcntl(open_fds[i], F_GETFL) != -1)\n\t\t\t\texit(EXIT_FAILURE);\n\n\t\tfor (i = 93; i <= 100; i++)\n\t\t\tif (fcntl(open_fds[i], F_GETFL) == -1)\n\t\t\t\texit(EXIT_FAILURE);\n\n\t\t \n\t\tret = sys_close_range(open_fds[93], open_fds[99],\n\t\t\t\t      CLOSE_RANGE_UNSHARE);\n\t\tif (ret)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tfor (i = 93; i <= 99; i++)\n\t\t\tif (fcntl(open_fds[i], F_GETFL) != -1)\n\t\t\t\texit(EXIT_FAILURE);\n\n\t\tif (fcntl(open_fds[100], F_GETFL) == -1)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tret = sys_close_range(open_fds[100], open_fds[100],\n\t\t\t\t      CLOSE_RANGE_UNSHARE);\n\t\tif (ret)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tif (fcntl(open_fds[100], F_GETFL) != -1)\n\t\t\texit(EXIT_FAILURE);\n\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n}\n\nTEST(close_range_unshare_capped)\n{\n\tint i, ret, status;\n\tpid_t pid;\n\tint open_fds[101];\n\tstruct __clone_args args = {\n\t\t.flags = CLONE_FILES,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(open_fds); i++) {\n\t\tint fd;\n\n\t\tfd = open(\"/dev/null\", O_RDONLY | O_CLOEXEC);\n\t\tASSERT_GE(fd, 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tSKIP(return, \"Skipping test since /dev/null does not exist\");\n\t\t}\n\n\t\topen_fds[i] = fd;\n\t}\n\n\tpid = sys_clone3(&args, sizeof(args));\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tret = sys_close_range(open_fds[0], UINT_MAX,\n\t\t\t\t      CLOSE_RANGE_UNSHARE);\n\t\tif (ret)\n\t\t\texit(EXIT_FAILURE);\n\n\t\tfor (i = 0; i <= 100; i++)\n\t\t\tif (fcntl(open_fds[i], F_GETFL) != -1)\n\t\t\t\texit(EXIT_FAILURE);\n\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n}\n\nTEST(close_range_cloexec)\n{\n\tint i, ret;\n\tint open_fds[101];\n\tstruct rlimit rlimit;\n\n\tfor (i = 0; i < ARRAY_SIZE(open_fds); i++) {\n\t\tint fd;\n\n\t\tfd = open(\"/dev/null\", O_RDONLY);\n\t\tASSERT_GE(fd, 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tSKIP(return, \"Skipping test since /dev/null does not exist\");\n\t\t}\n\n\t\topen_fds[i] = fd;\n\t}\n\n\tret = sys_close_range(1000, 1000, CLOSE_RANGE_CLOEXEC);\n\tif (ret < 0) {\n\t\tif (errno == ENOSYS)\n\t\t\tSKIP(return, \"close_range() syscall not supported\");\n\t\tif (errno == EINVAL)\n\t\t\tSKIP(return, \"close_range() doesn't support CLOSE_RANGE_CLOEXEC\");\n\t}\n\n\t \n\tASSERT_EQ(0, getrlimit(RLIMIT_NOFILE, &rlimit));\n\trlimit.rlim_cur = 25;\n\tASSERT_EQ(0, setrlimit(RLIMIT_NOFILE, &rlimit));\n\n\t \n\tret = sys_close_range(open_fds[0], open_fds[50], CLOSE_RANGE_CLOEXEC);\n\tASSERT_EQ(0, ret);\n\tret = sys_close_range(open_fds[75], open_fds[100], CLOSE_RANGE_CLOEXEC);\n\tASSERT_EQ(0, ret);\n\n\tfor (i = 0; i <= 50; i++) {\n\t\tint flags = fcntl(open_fds[i], F_GETFD);\n\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\t}\n\n\tfor (i = 51; i <= 74; i++) {\n\t\tint flags = fcntl(open_fds[i], F_GETFD);\n\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, 0);\n\t}\n\n\tfor (i = 75; i <= 100; i++) {\n\t\tint flags = fcntl(open_fds[i], F_GETFD);\n\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\t}\n\n\t \n\tret = sys_close_range(3, UINT_MAX, CLOSE_RANGE_CLOEXEC);\n\tfor (i = 0; i <= 100; i++) {\n\t\tint flags = fcntl(open_fds[i], F_GETFD);\n\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\t}\n}\n\nTEST(close_range_cloexec_unshare)\n{\n\tint i, ret;\n\tint open_fds[101];\n\tstruct rlimit rlimit;\n\n\tfor (i = 0; i < ARRAY_SIZE(open_fds); i++) {\n\t\tint fd;\n\n\t\tfd = open(\"/dev/null\", O_RDONLY);\n\t\tASSERT_GE(fd, 0) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tSKIP(return, \"Skipping test since /dev/null does not exist\");\n\t\t}\n\n\t\topen_fds[i] = fd;\n\t}\n\n\tret = sys_close_range(1000, 1000, CLOSE_RANGE_CLOEXEC);\n\tif (ret < 0) {\n\t\tif (errno == ENOSYS)\n\t\t\tSKIP(return, \"close_range() syscall not supported\");\n\t\tif (errno == EINVAL)\n\t\t\tSKIP(return, \"close_range() doesn't support CLOSE_RANGE_CLOEXEC\");\n\t}\n\n\t \n\tASSERT_EQ(0, getrlimit(RLIMIT_NOFILE, &rlimit));\n\trlimit.rlim_cur = 25;\n\tASSERT_EQ(0, setrlimit(RLIMIT_NOFILE, &rlimit));\n\n\t \n\tret = sys_close_range(open_fds[0], open_fds[50],\n\t\t\t      CLOSE_RANGE_CLOEXEC | CLOSE_RANGE_UNSHARE);\n\tASSERT_EQ(0, ret);\n\tret = sys_close_range(open_fds[75], open_fds[100],\n\t\t\t      CLOSE_RANGE_CLOEXEC | CLOSE_RANGE_UNSHARE);\n\tASSERT_EQ(0, ret);\n\n\tfor (i = 0; i <= 50; i++) {\n\t\tint flags = fcntl(open_fds[i], F_GETFD);\n\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\t}\n\n\tfor (i = 51; i <= 74; i++) {\n\t\tint flags = fcntl(open_fds[i], F_GETFD);\n\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, 0);\n\t}\n\n\tfor (i = 75; i <= 100; i++) {\n\t\tint flags = fcntl(open_fds[i], F_GETFD);\n\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\t}\n\n\t \n\tret = sys_close_range(3, UINT_MAX,\n\t\t\t      CLOSE_RANGE_CLOEXEC | CLOSE_RANGE_UNSHARE);\n\tfor (i = 0; i <= 100; i++) {\n\t\tint flags = fcntl(open_fds[i], F_GETFD);\n\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\t}\n}\n\n \nTEST(close_range_cloexec_syzbot)\n{\n\tint fd1, fd2, fd3, flags, ret, status;\n\tpid_t pid;\n\tstruct __clone_args args = {\n\t\t.flags = CLONE_FILES,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\t \n\tfd1 = open(\"/dev/null\", O_RDWR);\n\tEXPECT_GT(fd1, 0);\n\n\tfd2 = dup2(fd1, 1000);\n\tEXPECT_GT(fd2, 0);\n\n\tpid = sys_clone3(&args, sizeof(args));\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\tret = sys_close_range(3, ~0U, CLOSE_RANGE_CLOEXEC);\n\t\tif (ret)\n\t\t\texit(EXIT_FAILURE);\n\n\t\t \n\t\tflags = fcntl(fd1, F_GETFD);\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\n\t\tflags = fcntl(fd2, F_GETFD);\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\n\t\tfd3 = dup2(fd1, 42);\n\t\tEXPECT_GT(fd3, 0);\n\n\t\t \n\t\tflags = fcntl(fd3, F_GETFD);\n\t\tEXPECT_GT(flags, -1);\n\t\tEXPECT_EQ(flags & FD_CLOEXEC, 0);\n\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n\n\t \n\tflags = fcntl(fd1, F_GETFD);\n\tEXPECT_GT(flags, -1);\n\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\n\tflags = fcntl(fd2, F_GETFD);\n\tEXPECT_GT(flags, -1);\n\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\n\tfd3 = dup2(fd1, 42);\n\tEXPECT_GT(fd3, 0);\n\n\tflags = fcntl(fd3, F_GETFD);\n\tEXPECT_GT(flags, -1);\n\tEXPECT_EQ(flags & FD_CLOEXEC, 0);\n\n\tEXPECT_EQ(close(fd1), 0);\n\tEXPECT_EQ(close(fd2), 0);\n\tEXPECT_EQ(close(fd3), 0);\n}\n\n \nTEST(close_range_cloexec_unshare_syzbot)\n{\n\tint i, fd1, fd2, fd3, flags, ret, status;\n\tpid_t pid;\n\tstruct __clone_args args = {\n\t\t.flags = CLONE_FILES,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\t \n\tfd1 = open(\"/dev/null\", O_RDWR);\n\tEXPECT_GT(fd1, 0);\n\n\tfd2 = dup2(fd1, 1000);\n\tEXPECT_GT(fd2, 0);\n\n\tfor (i = 0; i < 100; i++) {\n\n\t\tpid = sys_clone3(&args, sizeof(args));\n\t\tASSERT_GE(pid, 0);\n\n\t\tif (pid == 0) {\n\t\t\tret = sys_close_range(3, ~0U, CLOSE_RANGE_UNSHARE |\n\t\t\t\t\t\t      CLOSE_RANGE_CLOEXEC);\n\t\t\tif (ret)\n\t\t\t\texit(EXIT_FAILURE);\n\n\t\t\t \n\t\t\tflags = fcntl(fd1, F_GETFD);\n\t\t\tEXPECT_GT(flags, -1);\n\t\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\n\t\t\tflags = fcntl(fd2, F_GETFD);\n\t\t\tEXPECT_GT(flags, -1);\n\t\t\tEXPECT_EQ(flags & FD_CLOEXEC, FD_CLOEXEC);\n\n\t\t\tfd3 = dup2(fd1, 42);\n\t\t\tEXPECT_GT(fd3, 0);\n\n\t\t\t \n\t\t\tflags = fcntl(fd3, F_GETFD);\n\t\t\tEXPECT_GT(flags, -1);\n\t\t\tEXPECT_EQ(flags & FD_CLOEXEC, 0);\n\n\t\t\tEXPECT_EQ(close(fd1), 0);\n\t\t\tEXPECT_EQ(close(fd2), 0);\n\t\t\tEXPECT_EQ(close(fd3), 0);\n\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\n\t\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\t\tEXPECT_EQ(true, WIFEXITED(status));\n\t\tEXPECT_EQ(0, WEXITSTATUS(status));\n\t}\n\n\t \n\tflags = fcntl(fd1, F_GETFD);\n\tEXPECT_GT(flags, -1);\n\tEXPECT_EQ(flags & FD_CLOEXEC, 0);\n\n\tflags = fcntl(fd2, F_GETFD);\n\tEXPECT_GT(flags, -1);\n\tEXPECT_EQ(flags & FD_CLOEXEC, 0);\n\n\tfd3 = dup2(fd1, 42);\n\tEXPECT_GT(fd3, 0);\n\n\tflags = fcntl(fd3, F_GETFD);\n\tEXPECT_GT(flags, -1);\n\tEXPECT_EQ(flags & FD_CLOEXEC, 0);\n\n\tEXPECT_EQ(close(fd1), 0);\n\tEXPECT_EQ(close(fd2), 0);\n\tEXPECT_EQ(close(fd3), 0);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}