{
  "module_name": "dmabuf-heap.c",
  "hash_id": "11d4464c109e3c23f3bd32dd1cac2a67986ed992fe6920f60456693565a6fa06",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/dmabuf-heaps/dmabuf-heap.c",
  "human_readable_source": "\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\n#include <linux/dma-buf.h>\n#include <linux/dma-heap.h>\n#include <drm/drm.h>\n\n#define DEVPATH \"/dev/dma_heap\"\n\nstatic int check_vgem(int fd)\n{\n\tdrm_version_t version = { 0 };\n\tchar name[5];\n\tint ret;\n\n\tversion.name_len = 4;\n\tversion.name = name;\n\n\tret = ioctl(fd, DRM_IOCTL_VERSION, &version);\n\tif (ret)\n\t\treturn 0;\n\n\treturn !strcmp(name, \"vgem\");\n}\n\nstatic int open_vgem(void)\n{\n\tint i, fd;\n\tconst char *drmstr = \"/dev/dri/card\";\n\n\tfd = -1;\n\tfor (i = 0; i < 16; i++) {\n\t\tchar name[80];\n\n\t\tsnprintf(name, 80, \"%s%u\", drmstr, i);\n\n\t\tfd = open(name, O_RDWR);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\n\t\tif (!check_vgem(fd)) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fd;\n}\n\nstatic int import_vgem_fd(int vgem_fd, int dma_buf_fd, uint32_t *handle)\n{\n\tstruct drm_prime_handle import_handle = {\n\t\t.fd = dma_buf_fd,\n\t\t.flags = 0,\n\t\t.handle = 0,\n\t };\n\tint ret;\n\n\tret = ioctl(vgem_fd, DRM_IOCTL_PRIME_FD_TO_HANDLE, &import_handle);\n\tif (ret == 0)\n\t\t*handle = import_handle.handle;\n\treturn ret;\n}\n\nstatic void close_handle(int vgem_fd, uint32_t handle)\n{\n\tstruct drm_gem_close close = {\n\t\t.handle = handle,\n\t};\n\n\tioctl(vgem_fd, DRM_IOCTL_GEM_CLOSE, &close);\n}\n\nstatic int dmabuf_heap_open(char *name)\n{\n\tint ret, fd;\n\tchar buf[256];\n\n\tret = snprintf(buf, 256, \"%s/%s\", DEVPATH, name);\n\tif (ret < 0) {\n\t\tprintf(\"snprintf failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tfd = open(buf, O_RDWR);\n\tif (fd < 0)\n\t\tprintf(\"open %s failed!\\n\", buf);\n\treturn fd;\n}\n\nstatic int dmabuf_heap_alloc_fdflags(int fd, size_t len, unsigned int fd_flags,\n\t\t\t\t     unsigned int heap_flags, int *dmabuf_fd)\n{\n\tstruct dma_heap_allocation_data data = {\n\t\t.len = len,\n\t\t.fd = 0,\n\t\t.fd_flags = fd_flags,\n\t\t.heap_flags = heap_flags,\n\t};\n\tint ret;\n\n\tif (!dmabuf_fd)\n\t\treturn -EINVAL;\n\n\tret = ioctl(fd, DMA_HEAP_IOCTL_ALLOC, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\t*dmabuf_fd = (int)data.fd;\n\treturn ret;\n}\n\nstatic int dmabuf_heap_alloc(int fd, size_t len, unsigned int flags,\n\t\t\t     int *dmabuf_fd)\n{\n\treturn dmabuf_heap_alloc_fdflags(fd, len, O_RDWR | O_CLOEXEC, flags,\n\t\t\t\t\t dmabuf_fd);\n}\n\nstatic int dmabuf_sync(int fd, int start_stop)\n{\n\tstruct dma_buf_sync sync = {\n\t\t.flags = start_stop | DMA_BUF_SYNC_RW,\n\t};\n\n\treturn ioctl(fd, DMA_BUF_IOCTL_SYNC, &sync);\n}\n\n#define ONE_MEG (1024 * 1024)\n\nstatic int test_alloc_and_import(char *heap_name)\n{\n\tint heap_fd = -1, dmabuf_fd = -1, importer_fd = -1;\n\tuint32_t handle = 0;\n\tvoid *p = NULL;\n\tint ret;\n\n\theap_fd = dmabuf_heap_open(heap_name);\n\tif (heap_fd < 0)\n\t\treturn -1;\n\n\tprintf(\"  Testing allocation and importing:  \");\n\tret = dmabuf_heap_alloc(heap_fd, ONE_MEG, 0, &dmabuf_fd);\n\tif (ret) {\n\t\tprintf(\"FAIL (Allocation Failed!)\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\t \n\tp = mmap(NULL,\n\t\t ONE_MEG,\n\t\t PROT_READ | PROT_WRITE,\n\t\t MAP_SHARED,\n\t\t dmabuf_fd,\n\t\t 0);\n\tif (p == MAP_FAILED) {\n\t\tprintf(\"FAIL (mmap() failed)\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tdmabuf_sync(dmabuf_fd, DMA_BUF_SYNC_START);\n\tmemset(p, 1, ONE_MEG / 2);\n\tmemset((char *)p + ONE_MEG / 2, 0, ONE_MEG / 2);\n\tdmabuf_sync(dmabuf_fd, DMA_BUF_SYNC_END);\n\n\timporter_fd = open_vgem();\n\tif (importer_fd < 0) {\n\t\tret = importer_fd;\n\t\tprintf(\"(Could not open vgem - skipping):  \");\n\t} else {\n\t\tret = import_vgem_fd(importer_fd, dmabuf_fd, &handle);\n\t\tif (ret < 0) {\n\t\t\tprintf(\"FAIL (Failed to import buffer)\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = dmabuf_sync(dmabuf_fd, DMA_BUF_SYNC_START);\n\tif (ret < 0) {\n\t\tprintf(\"FAIL (DMA_BUF_SYNC_START failed!)\\n\");\n\t\tgoto out;\n\t}\n\n\tmemset(p, 0xff, ONE_MEG);\n\tret = dmabuf_sync(dmabuf_fd, DMA_BUF_SYNC_END);\n\tif (ret < 0) {\n\t\tprintf(\"FAIL (DMA_BUF_SYNC_END failed!)\\n\");\n\t\tgoto out;\n\t}\n\n\tclose_handle(importer_fd, handle);\n\tret = 0;\n\tprintf(\" OK\\n\");\nout:\n\tif (p)\n\t\tmunmap(p, ONE_MEG);\n\tif (importer_fd >= 0)\n\t\tclose(importer_fd);\n\tif (dmabuf_fd >= 0)\n\t\tclose(dmabuf_fd);\n\tif (heap_fd >= 0)\n\t\tclose(heap_fd);\n\n\treturn ret;\n}\n\nstatic int test_alloc_zeroed(char *heap_name, size_t size)\n{\n\tint heap_fd = -1, dmabuf_fd[32];\n\tint i, j, ret;\n\tvoid *p = NULL;\n\tchar *c;\n\n\tprintf(\"  Testing alloced %ldk buffers are zeroed:  \", size / 1024);\n\theap_fd = dmabuf_heap_open(heap_name);\n\tif (heap_fd < 0)\n\t\treturn -1;\n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\tret = dmabuf_heap_alloc(heap_fd, size, 0, &dmabuf_fd[i]);\n\t\tif (ret < 0) {\n\t\t\tprintf(\"FAIL (Allocation (%i) failed)\\n\", i);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tp = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, dmabuf_fd[i], 0);\n\t\tif (p == MAP_FAILED) {\n\t\t\tprintf(\"FAIL (mmap() failed!)\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tdmabuf_sync(dmabuf_fd[i], DMA_BUF_SYNC_START);\n\t\tmemset(p, 0xff, size);\n\t\tdmabuf_sync(dmabuf_fd[i], DMA_BUF_SYNC_END);\n\t\tmunmap(p, size);\n\t}\n\t \n\tfor (i = 0; i < 32; i++)\n\t\tclose(dmabuf_fd[i]);\n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\tret = dmabuf_heap_alloc(heap_fd, size, 0, &dmabuf_fd[i]);\n\t\tif (ret < 0) {\n\t\t\tprintf(\"FAIL (Allocation (%i) failed)\\n\", i);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tp = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, dmabuf_fd[i], 0);\n\t\tif (p == MAP_FAILED) {\n\t\t\tprintf(\"FAIL (mmap() failed!)\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tdmabuf_sync(dmabuf_fd[i], DMA_BUF_SYNC_START);\n\t\tc = (char *)p;\n\t\tfor (j = 0; j < size; j++) {\n\t\t\tif (c[j] != 0) {\n\t\t\t\tprintf(\"FAIL (Allocated buffer not zeroed @ %i)\\n\", j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdmabuf_sync(dmabuf_fd[i], DMA_BUF_SYNC_END);\n\t\tmunmap(p, size);\n\t}\n\t \n\tfor (i = 0; i < 32; i++)\n\t\tclose(dmabuf_fd[i]);\n\n\tclose(heap_fd);\n\tprintf(\"OK\\n\");\n\treturn 0;\n\nout:\n\twhile (i > 0) {\n\t\tclose(dmabuf_fd[i]);\n\t\ti--;\n\t}\n\tclose(heap_fd);\n\treturn ret;\n}\n\n \nstatic int dmabuf_heap_alloc_older(int fd, size_t len, unsigned int flags,\n\t\t\t\t   int *dmabuf_fd)\n{\n\tint ret;\n\tunsigned int older_alloc_ioctl;\n\tstruct dma_heap_allocation_data_smaller {\n\t\t__u64 len;\n\t\t__u32 fd;\n\t\t__u32 fd_flags;\n\t} data = {\n\t\t.len = len,\n\t\t.fd = 0,\n\t\t.fd_flags = O_RDWR | O_CLOEXEC,\n\t};\n\n\tolder_alloc_ioctl = _IOWR(DMA_HEAP_IOC_MAGIC, 0x0,\n\t\t\t\t  struct dma_heap_allocation_data_smaller);\n\tif (!dmabuf_fd)\n\t\treturn -EINVAL;\n\n\tret = ioctl(fd, older_alloc_ioctl, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\t*dmabuf_fd = (int)data.fd;\n\treturn ret;\n}\n\n \nstatic int dmabuf_heap_alloc_newer(int fd, size_t len, unsigned int flags,\n\t\t\t\t   int *dmabuf_fd)\n{\n\tint ret;\n\tunsigned int newer_alloc_ioctl;\n\tstruct dma_heap_allocation_data_bigger {\n\t\t__u64 len;\n\t\t__u32 fd;\n\t\t__u32 fd_flags;\n\t\t__u64 heap_flags;\n\t\t__u64 garbage1;\n\t\t__u64 garbage2;\n\t\t__u64 garbage3;\n\t} data = {\n\t\t.len = len,\n\t\t.fd = 0,\n\t\t.fd_flags = O_RDWR | O_CLOEXEC,\n\t\t.heap_flags = flags,\n\t\t.garbage1 = 0xffffffff,\n\t\t.garbage2 = 0x88888888,\n\t\t.garbage3 = 0x11111111,\n\t};\n\n\tnewer_alloc_ioctl = _IOWR(DMA_HEAP_IOC_MAGIC, 0x0,\n\t\t\t\t  struct dma_heap_allocation_data_bigger);\n\tif (!dmabuf_fd)\n\t\treturn -EINVAL;\n\n\tret = ioctl(fd, newer_alloc_ioctl, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*dmabuf_fd = (int)data.fd;\n\treturn ret;\n}\n\nstatic int test_alloc_compat(char *heap_name)\n{\n\tint heap_fd = -1, dmabuf_fd = -1;\n\tint ret;\n\n\theap_fd = dmabuf_heap_open(heap_name);\n\tif (heap_fd < 0)\n\t\treturn -1;\n\n\tprintf(\"  Testing (theoretical)older alloc compat:  \");\n\tret = dmabuf_heap_alloc_older(heap_fd, ONE_MEG, 0, &dmabuf_fd);\n\tif (ret) {\n\t\tprintf(\"FAIL (Older compat allocation failed!)\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tclose(dmabuf_fd);\n\tprintf(\"OK\\n\");\n\n\tprintf(\"  Testing (theoretical)newer alloc compat:  \");\n\tret = dmabuf_heap_alloc_newer(heap_fd, ONE_MEG, 0, &dmabuf_fd);\n\tif (ret) {\n\t\tprintf(\"FAIL (Newer compat allocation failed!)\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tprintf(\"OK\\n\");\nout:\n\tif (dmabuf_fd >= 0)\n\t\tclose(dmabuf_fd);\n\tif (heap_fd >= 0)\n\t\tclose(heap_fd);\n\n\treturn ret;\n}\n\nstatic int test_alloc_errors(char *heap_name)\n{\n\tint heap_fd = -1, dmabuf_fd = -1;\n\tint ret;\n\n\theap_fd = dmabuf_heap_open(heap_name);\n\tif (heap_fd < 0)\n\t\treturn -1;\n\n\tprintf(\"  Testing expected error cases:  \");\n\tret = dmabuf_heap_alloc(0, ONE_MEG, 0x111111, &dmabuf_fd);\n\tif (!ret) {\n\t\tprintf(\"FAIL (Did not see expected error (invalid fd)!)\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tret = dmabuf_heap_alloc(heap_fd, ONE_MEG, 0x111111, &dmabuf_fd);\n\tif (!ret) {\n\t\tprintf(\"FAIL (Did not see expected error (invalid heap flags)!)\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tret = dmabuf_heap_alloc_fdflags(heap_fd, ONE_MEG,\n\t\t\t\t\t~(O_RDWR | O_CLOEXEC), 0, &dmabuf_fd);\n\tif (!ret) {\n\t\tprintf(\"FAIL (Did not see expected error (invalid fd flags)!)\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tprintf(\"OK\\n\");\n\tret = 0;\nout:\n\tif (dmabuf_fd >= 0)\n\t\tclose(dmabuf_fd);\n\tif (heap_fd >= 0)\n\t\tclose(heap_fd);\n\n\treturn ret;\n}\n\nint main(void)\n{\n\tDIR *d;\n\tstruct dirent *dir;\n\tint ret = -1;\n\n\td = opendir(DEVPATH);\n\tif (!d) {\n\t\tprintf(\"No %s directory?\\n\", DEVPATH);\n\t\treturn -1;\n\t}\n\n\twhile ((dir = readdir(d)) != NULL) {\n\t\tif (!strncmp(dir->d_name, \".\", 2))\n\t\t\tcontinue;\n\t\tif (!strncmp(dir->d_name, \"..\", 3))\n\t\t\tcontinue;\n\n\t\tprintf(\"Testing heap: %s\\n\", dir->d_name);\n\t\tprintf(\"=======================================\\n\");\n\t\tret = test_alloc_and_import(dir->d_name);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = test_alloc_zeroed(dir->d_name, 4 * 1024);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = test_alloc_zeroed(dir->d_name, ONE_MEG);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = test_alloc_compat(dir->d_name);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = test_alloc_errors(dir->d_name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tclosedir(d);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}