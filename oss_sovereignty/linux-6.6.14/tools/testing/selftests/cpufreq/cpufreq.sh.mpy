{
  "module_name": "cpufreq.sh",
  "hash_id": "7b4b742bb4258cc16040d4984da4444ce6f2c3b00bc2c8a19f2d8dea0052d5e0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cpufreq/cpufreq.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# protect against multiple inclusion\nif [ $FILE_CPUFREQ ]; then\n\treturn 0\nelse\n\tFILE_CPUFREQ=DONE\nfi\n\nsource cpu.sh\n\n\n# $1: cpu\ncpu_should_have_cpufreq_directory()\n{\n\tif [ ! -d $CPUROOT/$1/cpufreq ]; then\n\t\tprintf \"Warning: No cpufreq directory present for $1\\n\"\n\tfi\n}\n\ncpu_should_not_have_cpufreq_directory()\n{\n\tif [ -d $CPUROOT/$1/cpufreq ]; then\n\t\tprintf \"Warning: cpufreq directory present for $1\\n\"\n\tfi\n}\n\nfor_each_policy()\n{\n\tpolicies=$(ls $CPUFREQROOT| grep \"policy[0-9].*\")\n\tfor policy in $policies; do\n\t\t$@ $policy\n\tdone\n}\n\nfor_each_policy_concurrent()\n{\n\tpolicies=$(ls $CPUFREQROOT| grep \"policy[0-9].*\")\n\tfor policy in $policies; do\n\t\t$@ $policy &\n\tdone\n}\n\n# $1: Path\nread_cpufreq_files_in_dir()\n{\n\tlocal files=`ls $1`\n\n\tprintf \"Printing directory: $1\\n\\n\"\n\n\tfor file in $files; do\n\t\tif [ -f $1/$file ]; then\n\t\t\tprintf \"$file:\"\n\t\t\tcat $1/$file\n\t\telse\n\t\t\tprintf \"\\n\"\n\t\t\tread_cpufreq_files_in_dir \"$1/$file\"\n\t\tfi\n\tdone\n\tprintf \"\\n\"\n}\n\n\nread_all_cpufreq_files()\n{\n\tprintf \"** Test: Running ${FUNCNAME[0]} **\\n\\n\"\n\n\tread_cpufreq_files_in_dir $CPUFREQROOT\n\n\tprintf \"%s\\n\\n\" \"------------------------------------------------\"\n}\n\n\n# UPDATE CPUFREQ FILES\n\n# $1: directory path\nupdate_cpufreq_files_in_dir()\n{\n\tlocal files=`ls $1`\n\n\tprintf \"Updating directory: $1\\n\\n\"\n\n\tfor file in $files; do\n\t\tif [ -f $1/$file ]; then\n\t\t\t# file is writable ?\n\t\t\tlocal wfile=$(ls -l $1/$file | awk '$1 ~ /^.*w.*/ { print $NF; }')\n\n\t\t\tif [ ! -z $wfile ]; then\n\t\t\t\t# scaling_setspeed is a special file and we\n\t\t\t\t# should skip updating it\n\t\t\t\tif [ $file != \"scaling_setspeed\" ]; then\n\t\t\t\t\tlocal val=$(cat $1/$file)\n\t\t\t\t\tprintf \"Writing $val to: $file\\n\"\n\t\t\t\t\techo $val > $1/$file\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\tprintf \"\\n\"\n\t\t\tupdate_cpufreq_files_in_dir \"$1/$file\"\n\t\tfi\n\tdone\n\n\tprintf \"\\n\"\n}\n\n# Update all writable files with their existing values\nupdate_all_cpufreq_files()\n{\n\tprintf \"** Test: Running ${FUNCNAME[0]} **\\n\\n\"\n\n\tupdate_cpufreq_files_in_dir $CPUFREQROOT\n\n\tprintf \"%s\\n\\n\" \"------------------------------------------------\"\n}\n\n\n# CHANGE CPU FREQUENCIES\n\n# $1: policy\nfind_current_freq()\n{\n\tcat $CPUFREQROOT/$1/scaling_cur_freq\n}\n\n# $1: policy\n# $2: frequency\nset_cpu_frequency()\n{\n\tprintf \"Change frequency for $1 to $2\\n\"\n\techo $2 > $CPUFREQROOT/$1/scaling_setspeed\n}\n\n# $1: policy\ntest_all_frequencies()\n{\n\tlocal filepath=\"$CPUFREQROOT/$1\"\n\n\tbackup_governor $1\n\n\tlocal found=$(switch_governor $1 \"userspace\")\n\tif [ $found = 1 ]; then\n\t\tprintf \"${FUNCNAME[0]}: userspace governor not available for: $1\\n\"\n\t\treturn;\n\tfi\n\n\tprintf \"Switched governor for $1 to userspace\\n\\n\"\n\n\tlocal freqs=$(cat $filepath/scaling_available_frequencies)\n\tprintf \"Available frequencies for $1: $freqs\\n\\n\"\n\n\t# Set all frequencies one-by-one\n\tfor freq in $freqs; do\n\t\tset_cpu_frequency $1 $freq\n\tdone\n\n\tprintf \"\\n\"\n\n\trestore_governor $1\n}\n\n# $1: loop count\nshuffle_frequency_for_all_cpus()\n{\n\tprintf \"** Test: Running ${FUNCNAME[0]} for $1 loops **\\n\\n\"\n\n\tfor i in `seq 1 $1`; do\n\t\tfor_each_policy test_all_frequencies\n\tdone\n\tprintf \"\\n%s\\n\\n\" \"------------------------------------------------\"\n}\n\n# Basic cpufreq tests\ncpufreq_basic_tests()\n{\n\tprintf \"*** RUNNING CPUFREQ SANITY TESTS ***\\n\"\n\tprintf \"====================================\\n\\n\"\n\n\tcount=$(count_cpufreq_managed_cpus)\n\tif [ $count = 0 ]; then\n\t\tprintf \"No cpu is managed by cpufreq core, exiting\\n\"\n\t\texit;\n\telse\n\t\tprintf \"CPUFreq manages: $count CPUs\\n\\n\"\n\tfi\n\n\t# Detect & print which CPUs are not managed by cpufreq\n\tprint_unmanaged_cpus\n\n\t# read/update all cpufreq files\n\tread_all_cpufreq_files\n\tupdate_all_cpufreq_files\n\n\t# hotplug cpus\n\treboot_cpus 5\n\n\t# Test all frequencies\n\tshuffle_frequency_for_all_cpus 2\n\n\t# Test all governors\n\tshuffle_governors_for_all_cpus 1\n}\n\n# Suspend/resume\n# $1: \"suspend\" or \"hibernate\", $2: loop count\ndo_suspend()\n{\n\tprintf \"** Test: Running ${FUNCNAME[0]}: Trying $1 for $2 loops **\\n\\n\"\n\n\t# Is the directory available\n\tif [ ! -d $SYSFS/power/ -o ! -f $SYSFS/power/state ]; then\n\t\tprintf \"$SYSFS/power/state not available\\n\"\n\t\treturn 1\n\tfi\n\n\tif [ $1 = \"suspend\" ]; then\n\t\tfilename=\"mem\"\n\telif [ $1 = \"hibernate\" ]; then\n\t\tfilename=\"disk\"\n\telse\n\t\tprintf \"$1 is not a valid option\\n\"\n\t\treturn 1\n\tfi\n\n\tif [ -n $filename ]; then\n\t\tpresent=$(cat $SYSFS/power/state | grep $filename)\n\n\t\tif [ -z \"$present\" ]; then\n\t\t\tprintf \"Tried to $1 but $filename isn't present in $SYSFS/power/state\\n\"\n\t\t\treturn 1;\n\t\tfi\n\n\t\tfor i in `seq 1 $2`; do\n\t\t\tprintf \"Starting $1\\n\"\n\t\t\techo $filename > $SYSFS/power/state\n\t\t\tprintf \"Came out of $1\\n\"\n\n\t\t\tprintf \"Do basic tests after finishing $1 to verify cpufreq state\\n\\n\"\n\t\t\tcpufreq_basic_tests\n\t\tdone\n\tfi\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}