{
  "module_name": "governor.sh",
  "hash_id": "a0024cabaa3cddf69b87827cbc5c67a13717f1f2dc0478e342ee32203c865d74",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/cpufreq/governor.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test governors\n\n# protect against multiple inclusion\nif [ $FILE_GOVERNOR ]; then\n\treturn 0\nelse\n\tFILE_GOVERNOR=DONE\nfi\n\nsource cpu.sh\nsource cpufreq.sh\n\nCUR_GOV=\nCUR_FREQ=\n\n# Find governor's directory path\n# $1: policy, $2: governor\nfind_gov_directory()\n{\n\tif [ -d $CPUFREQROOT/$2 ]; then\n\t\tprintf \"$CPUFREQROOT/$2\\n\"\n\telif [ -d $CPUFREQROOT/$1/$2 ]; then\n\t\tprintf \"$CPUFREQROOT/$1/$2\\n\"\n\telse\n\t\tprintf \"INVALID\\n\"\n\tfi\n}\n\n# $1: policy\nfind_current_governor()\n{\n\tcat $CPUFREQROOT/$1/scaling_governor\n}\n\n# $1: policy\nbackup_governor()\n{\n\tCUR_GOV=$(find_current_governor $1)\n\n\tprintf \"Governor backup done for $1: $CUR_GOV\\n\"\n\n\tif [ $CUR_GOV == \"userspace\" ]; then\n\t\tCUR_FREQ=$(find_current_freq $1)\n\t\tprintf \"Governor frequency backup done for $1: $CUR_FREQ\\n\"\n\tfi\n\n\tprintf \"\\n\"\n}\n\n# $1: policy\nrestore_governor()\n{\n\t__switch_governor $1 $CUR_GOV\n\n\tprintf \"Governor restored for $1 to $CUR_GOV\\n\"\n\n\tif [ $CUR_GOV == \"userspace\" ]; then\n\t\tset_cpu_frequency $1 $CUR_FREQ\n\t\tprintf \"Governor frequency restored for $1: $CUR_FREQ\\n\"\n\tfi\n\n\tprintf \"\\n\"\n}\n\n# param:\n# $1: policy, $2: governor\n__switch_governor()\n{\n\techo $2 > $CPUFREQROOT/$1/scaling_governor\n}\n\n# param:\n# $1: cpu, $2: governor\n__switch_governor_for_cpu()\n{\n\techo $2 > $CPUROOT/$1/cpufreq/scaling_governor\n}\n\n# SWITCH GOVERNORS\n\n# $1: cpu, $2: governor\nswitch_governor()\n{\n\tlocal filepath=$CPUFREQROOT/$1/scaling_available_governors\n\n\t# check if governor is available\n\tlocal found=$(cat $filepath | grep $2 | wc -l)\n\tif [ $found = 0 ]; then\n\t\techo 1;\n\t\treturn\n\tfi\n\n\t__switch_governor $1 $2\n\techo 0;\n}\n\n# $1: policy, $2: governor\nswitch_show_governor()\n{\n\tcur_gov=find_current_governor\n\tif [ $cur_gov == \"userspace\" ]; then\n\t\tcur_freq=find_current_freq\n\tfi\n\n\t# switch governor\n\t__switch_governor $1 $2\n\n\tprintf \"\\nSwitched governor for $1 to $2\\n\\n\"\n\n\tif [ $2 == \"userspace\" -o $2 == \"powersave\" -o $2 == \"performance\" ]; then\n\t\tprintf \"No files to read for $2 governor\\n\\n\"\n\t\treturn\n\tfi\n\n\t# show governor files\n\tlocal govpath=$(find_gov_directory $1 $2)\n\tread_cpufreq_files_in_dir $govpath\n}\n\n# $1: function to be called, $2: policy\ncall_for_each_governor()\n{\n\tlocal filepath=$CPUFREQROOT/$2/scaling_available_governors\n\n\t# Exit if cpu isn't managed by cpufreq core\n\tif [ ! -f $filepath ]; then\n\t\treturn;\n\tfi\n\n\tbackup_governor $2\n\n\tlocal governors=$(cat $filepath)\n\tprintf \"Available governors for $2: $governors\\n\"\n\n\tfor governor in $governors; do\n\t\t$1 $2 $governor\n\tdone\n\n\trestore_governor $2\n}\n\n# $1: loop count\nshuffle_governors_for_all_cpus()\n{\n\tprintf \"** Test: Running ${FUNCNAME[0]} for $1 loops **\\n\\n\"\n\n\tfor i in `seq 1 $1`; do\n\t\tfor_each_policy call_for_each_governor switch_show_governor\n\tdone\n\tprintf \"%s\\n\\n\" \"------------------------------------------------\"\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}