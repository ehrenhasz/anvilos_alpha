{
  "module_name": "guest_print_test.c",
  "hash_id": "211bd3b74bdfd1cd4b9ea9ed1cc330f89d81a151e2778aadb1c7a177bca4a37d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/guest_print_test.c",
  "human_readable_source": "\n \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\nstruct guest_vals {\n\tuint64_t a;\n\tuint64_t b;\n\tuint64_t type;\n};\n\nstatic struct guest_vals vals;\n\n \n#define TYPE_LIST\t\t\t\t\t\\\nTYPE(test_type_i64,  I64,  \"%ld\",   int64_t)\t\t\\\nTYPE(test_type_u64,  U64u, \"%lu\",   uint64_t)\t\t\\\nTYPE(test_type_x64,  U64x, \"0x%lx\", uint64_t)\t\t\\\nTYPE(test_type_X64,  U64X, \"0x%lX\", uint64_t)\t\t\\\nTYPE(test_type_u32,  U32u, \"%u\",    uint32_t)\t\t\\\nTYPE(test_type_x32,  U32x, \"0x%x\",  uint32_t)\t\t\\\nTYPE(test_type_X32,  U32X, \"0x%X\",  uint32_t)\t\t\\\nTYPE(test_type_int,  INT,  \"%d\",    int)\t\t\\\nTYPE(test_type_char, CHAR, \"%c\",    char)\t\t\\\nTYPE(test_type_str,  STR,  \"'%s'\",  const char *)\t\\\nTYPE(test_type_ptr,  PTR,  \"%p\",    uintptr_t)\n\nenum args_type {\n#define TYPE(fn, ext, fmt_t, T) TYPE_##ext,\n\tTYPE_LIST\n#undef TYPE\n};\n\nstatic void run_test(struct kvm_vcpu *vcpu, const char *expected_printf,\n\t\t     const char *expected_assert);\n\n#define BUILD_TYPE_STRINGS_AND_HELPER(fn, ext, fmt_t, T)\t\t     \\\nconst char *PRINTF_FMT_##ext = \"Got params a = \" fmt_t \" and b = \" fmt_t;    \\\nconst char *ASSERT_FMT_##ext = \"Expected \" fmt_t \", got \" fmt_t \" instead\";  \\\nstatic void fn(struct kvm_vcpu *vcpu, T a, T b)\t\t\t\t     \\\n{\t\t\t\t\t\t\t\t\t     \\\n\tchar expected_printf[UCALL_BUFFER_LEN];\t\t\t\t     \\\n\tchar expected_assert[UCALL_BUFFER_LEN];\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tsnprintf(expected_printf, UCALL_BUFFER_LEN, PRINTF_FMT_##ext, a, b); \\\n\tsnprintf(expected_assert, UCALL_BUFFER_LEN, ASSERT_FMT_##ext, a, b); \\\n\tvals = (struct guest_vals){ (uint64_t)a, (uint64_t)b, TYPE_##ext };  \\\n\tsync_global_to_guest(vcpu->vm, vals);\t\t\t\t     \\\n\trun_test(vcpu, expected_printf, expected_assert);\t\t     \\\n}\n\n#define TYPE(fn, ext, fmt_t, T) \\\n\t\tBUILD_TYPE_STRINGS_AND_HELPER(fn, ext, fmt_t, T)\n\tTYPE_LIST\n#undef TYPE\n\nstatic void guest_code(void)\n{\n\twhile (1) {\n\t\tswitch (vals.type) {\n#define TYPE(fn, ext, fmt_t, T)\t\t\t\t\t\t\t\\\n\t\tcase TYPE_##ext:\t\t\t\t\t\t\\\n\t\t\tGUEST_PRINTF(PRINTF_FMT_##ext, vals.a, vals.b);\t\t\\\n\t\t\t__GUEST_ASSERT(vals.a == vals.b,\t\t\t\\\n\t\t\t\t       ASSERT_FMT_##ext, vals.a, vals.b);\t\\\n\t\t\tbreak;\n\t\tTYPE_LIST\n#undef TYPE\n\t\tdefault:\n\t\t\tGUEST_SYNC(vals.type);\n\t\t}\n\n\t\tGUEST_DONE();\n\t}\n}\n\n \nstatic void ucall_abort(const char *assert_msg, const char *expected_assert_msg)\n{\n\tint len_str = strlen(assert_msg);\n\tint len_substr = strlen(expected_assert_msg);\n\tint offset = len_str - len_substr;\n\n\tTEST_ASSERT(len_substr <= len_str,\n\t\t    \"Expected '%s' to be a substring of '%s'\\n\",\n\t\t    assert_msg, expected_assert_msg);\n\n\tTEST_ASSERT(strcmp(&assert_msg[offset], expected_assert_msg) == 0,\n\t\t    \"Unexpected mismatch. Expected: '%s', got: '%s'\",\n\t\t    expected_assert_msg, &assert_msg[offset]);\n}\n\nstatic void run_test(struct kvm_vcpu *vcpu, const char *expected_printf,\n\t\t     const char *expected_assert)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct ucall uc;\n\n\twhile (1) {\n\t\tvcpu_run(vcpu);\n\n\t\tTEST_ASSERT(run->exit_reason == UCALL_EXIT_REASON,\n\t\t\t    \"Unexpected exit reason: %u (%s),\\n\",\n\t\t\t    run->exit_reason, exit_reason_str(run->exit_reason));\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_SYNC:\n\t\t\tTEST_FAIL(\"Unknown 'args_type' = %lu\", uc.args[1]);\n\t\t\tbreak;\n\t\tcase UCALL_PRINTF:\n\t\t\tTEST_ASSERT(strcmp(uc.buffer, expected_printf) == 0,\n\t\t\t\t    \"Unexpected mismatch. Expected: '%s', got: '%s'\",\n\t\t\t\t    expected_printf, uc.buffer);\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\tucall_abort(uc.buffer, expected_assert);\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\t}\n}\n\nstatic void guest_code_limits(void)\n{\n\tchar test_str[UCALL_BUFFER_LEN + 10];\n\n\tmemset(test_str, 'a', sizeof(test_str));\n\ttest_str[sizeof(test_str) - 1] = 0;\n\n\tGUEST_PRINTF(\"%s\", test_str);\n}\n\nstatic void test_limits(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_run *run;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code_limits);\n\trun = vcpu->run;\n\tvcpu_run(vcpu);\n\n\tTEST_ASSERT(run->exit_reason == UCALL_EXIT_REASON,\n\t\t    \"Unexpected exit reason: %u (%s),\\n\",\n\t\t    run->exit_reason, exit_reason_str(run->exit_reason));\n\n\tTEST_ASSERT(get_ucall(vcpu, &uc) == UCALL_ABORT,\n\t\t    \"Unexpected ucall command: %lu,  Expected: %u (UCALL_ABORT)\\n\",\n\t\t    uc.cmd, UCALL_ABORT);\n\n\tkvm_vm_free(vm);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\ttest_type_i64(vcpu, -1, -1);\n\ttest_type_i64(vcpu, -1,  1);\n\ttest_type_i64(vcpu, 0x1234567890abcdef, 0x1234567890abcdef);\n\ttest_type_i64(vcpu, 0x1234567890abcdef, 0x1234567890abcdee);\n\n\ttest_type_u64(vcpu, 0x1234567890abcdef, 0x1234567890abcdef);\n\ttest_type_u64(vcpu, 0x1234567890abcdef, 0x1234567890abcdee);\n\ttest_type_x64(vcpu, 0x1234567890abcdef, 0x1234567890abcdef);\n\ttest_type_x64(vcpu, 0x1234567890abcdef, 0x1234567890abcdee);\n\ttest_type_X64(vcpu, 0x1234567890abcdef, 0x1234567890abcdef);\n\ttest_type_X64(vcpu, 0x1234567890abcdef, 0x1234567890abcdee);\n\n\ttest_type_u32(vcpu, 0x90abcdef, 0x90abcdef);\n\ttest_type_u32(vcpu, 0x90abcdef, 0x90abcdee);\n\ttest_type_x32(vcpu, 0x90abcdef, 0x90abcdef);\n\ttest_type_x32(vcpu, 0x90abcdef, 0x90abcdee);\n\ttest_type_X32(vcpu, 0x90abcdef, 0x90abcdef);\n\ttest_type_X32(vcpu, 0x90abcdef, 0x90abcdee);\n\n\ttest_type_int(vcpu, -1, -1);\n\ttest_type_int(vcpu, -1,  1);\n\ttest_type_int(vcpu,  1,  1);\n\n\ttest_type_char(vcpu, 'a', 'a');\n\ttest_type_char(vcpu, 'a', 'A');\n\ttest_type_char(vcpu, 'a', 'b');\n\n\ttest_type_str(vcpu, \"foo\", \"foo\");\n\ttest_type_str(vcpu, \"foo\", \"bar\");\n\n\ttest_type_ptr(vcpu, 0x1234567890abcdef, 0x1234567890abcdef);\n\ttest_type_ptr(vcpu, 0x1234567890abcdef, 0x1234567890abcdee);\n\n\tkvm_vm_free(vm);\n\n\ttest_limits();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}