{
  "module_name": "dirty_log_test.c",
  "hash_id": "77f5a4b0632349616acac6ee4c2efe9896369c509e6bc0deeed315109d7f696c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/dirty_log_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <sys/types.h>\n#include <signal.h>\n#include <errno.h>\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <asm/barrier.h>\n\n#include \"kvm_util.h\"\n#include \"test_util.h\"\n#include \"guest_modes.h\"\n#include \"processor.h\"\n\n#define DIRTY_MEM_BITS 30  \n#define PAGE_SHIFT_4K  12\n\n \n#define TEST_MEM_SLOT_INDEX\t\t1\n\n \n#define DEFAULT_GUEST_TEST_MEM\t\t0xc0000000\n\n \n#define TEST_PAGES_PER_LOOP\t\t1024\n\n \n#define TEST_HOST_LOOP_N\t\t32UL\n\n \n#define TEST_HOST_LOOP_INTERVAL\t\t10UL\n\n \n#if defined(__s390x__)\n# define BITOP_LE_SWIZZLE\t((BITS_PER_LONG-1) & ~0x7)\n# define test_bit_le(nr, addr) \\\n\ttest_bit((nr) ^ BITOP_LE_SWIZZLE, addr)\n# define __set_bit_le(nr, addr) \\\n\t__set_bit((nr) ^ BITOP_LE_SWIZZLE, addr)\n# define __clear_bit_le(nr, addr) \\\n\t__clear_bit((nr) ^ BITOP_LE_SWIZZLE, addr)\n# define __test_and_set_bit_le(nr, addr) \\\n\t__test_and_set_bit((nr) ^ BITOP_LE_SWIZZLE, addr)\n# define __test_and_clear_bit_le(nr, addr) \\\n\t__test_and_clear_bit((nr) ^ BITOP_LE_SWIZZLE, addr)\n#else\n# define test_bit_le\t\t\ttest_bit\n# define __set_bit_le\t\t\t__set_bit\n# define __clear_bit_le\t\t\t__clear_bit\n# define __test_and_set_bit_le\t\t__test_and_set_bit\n# define __test_and_clear_bit_le\t__test_and_clear_bit\n#endif\n\n#define TEST_DIRTY_RING_COUNT\t\t65536\n\n#define SIG_IPI SIGUSR1\n\n \nstatic uint64_t host_page_size;\nstatic uint64_t guest_page_size;\nstatic uint64_t guest_num_pages;\nstatic uint64_t random_array[TEST_PAGES_PER_LOOP];\nstatic uint64_t iteration;\n\n \nstatic uint64_t guest_test_phys_mem;\n\n \nstatic uint64_t guest_test_virt_mem = DEFAULT_GUEST_TEST_MEM;\n\n \nstatic void guest_code(void)\n{\n\tuint64_t addr;\n\tint i;\n\n\t \n\tfor (i = 0; i < guest_num_pages; i++) {\n\t\taddr = guest_test_virt_mem + i * guest_page_size;\n\t\t*(uint64_t *)addr = READ_ONCE(iteration);\n\t}\n\n\twhile (true) {\n\t\tfor (i = 0; i < TEST_PAGES_PER_LOOP; i++) {\n\t\t\taddr = guest_test_virt_mem;\n\t\t\taddr += (READ_ONCE(random_array[i]) % guest_num_pages)\n\t\t\t\t* guest_page_size;\n\t\t\taddr = align_down(addr, host_page_size);\n\t\t\t*(uint64_t *)addr = READ_ONCE(iteration);\n\t\t}\n\n\t\t \n\t\tGUEST_SYNC(1);\n\t}\n}\n\n \nstatic bool host_quit;\n\n \nstatic void *host_test_mem;\nstatic uint64_t host_num_pages;\n\n \nstatic uint64_t host_dirty_count;\nstatic uint64_t host_clear_count;\nstatic uint64_t host_track_next_count;\n\n \nstatic sem_t sem_vcpu_stop;\nstatic sem_t sem_vcpu_cont;\n \nstatic atomic_t vcpu_sync_stop_requested;\n \nstatic bool dirty_ring_vcpu_ring_full;\n \nstatic uint64_t dirty_ring_last_page;\n\nenum log_mode_t {\n\t \n\tLOG_MODE_DIRTY_LOG = 0,\n\n\t \n\tLOG_MODE_CLEAR_LOG = 1,\n\n\t \n\tLOG_MODE_DIRTY_RING = 2,\n\n\tLOG_MODE_NUM,\n\n\t \n\tLOG_MODE_ALL = LOG_MODE_NUM,\n};\n\n \nstatic enum log_mode_t host_log_mode_option = LOG_MODE_ALL;\n \nstatic enum log_mode_t host_log_mode;\nstatic pthread_t vcpu_thread;\nstatic uint32_t test_dirty_ring_count = TEST_DIRTY_RING_COUNT;\n\nstatic void vcpu_kick(void)\n{\n\tpthread_kill(vcpu_thread, SIG_IPI);\n}\n\n \nstatic void sem_wait_until(sem_t *sem)\n{\n\tint ret;\n\n\tdo\n\t\tret = sem_wait(sem);\n\twhile (ret == -1 && errno == EINTR);\n}\n\nstatic bool clear_log_supported(void)\n{\n\treturn kvm_has_cap(KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2);\n}\n\nstatic void clear_log_create_vm_done(struct kvm_vm *vm)\n{\n\tu64 manual_caps;\n\n\tmanual_caps = kvm_check_cap(KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2);\n\tTEST_ASSERT(manual_caps, \"MANUAL_CAPS is zero!\");\n\tmanual_caps &= (KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE |\n\t\t\tKVM_DIRTY_LOG_INITIALLY_SET);\n\tvm_enable_cap(vm, KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2, manual_caps);\n}\n\nstatic void dirty_log_collect_dirty_pages(struct kvm_vcpu *vcpu, int slot,\n\t\t\t\t\t  void *bitmap, uint32_t num_pages,\n\t\t\t\t\t  uint32_t *unused)\n{\n\tkvm_vm_get_dirty_log(vcpu->vm, slot, bitmap);\n}\n\nstatic void clear_log_collect_dirty_pages(struct kvm_vcpu *vcpu, int slot,\n\t\t\t\t\t  void *bitmap, uint32_t num_pages,\n\t\t\t\t\t  uint32_t *unused)\n{\n\tkvm_vm_get_dirty_log(vcpu->vm, slot, bitmap);\n\tkvm_vm_clear_dirty_log(vcpu->vm, slot, bitmap, 0, num_pages);\n}\n\n \nstatic void vcpu_handle_sync_stop(void)\n{\n\tif (atomic_read(&vcpu_sync_stop_requested)) {\n\t\t \n\t\tatomic_set(&vcpu_sync_stop_requested, false);\n\t\tsem_post(&sem_vcpu_stop);\n\t\tsem_wait_until(&sem_vcpu_cont);\n\t}\n}\n\nstatic void default_after_vcpu_run(struct kvm_vcpu *vcpu, int ret, int err)\n{\n\tstruct kvm_run *run = vcpu->run;\n\n\tTEST_ASSERT(ret == 0 || (ret == -1 && err == EINTR),\n\t\t    \"vcpu run failed: errno=%d\", err);\n\n\tTEST_ASSERT(get_ucall(vcpu, NULL) == UCALL_SYNC,\n\t\t    \"Invalid guest sync status: exit_reason=%s\\n\",\n\t\t    exit_reason_str(run->exit_reason));\n\n\tvcpu_handle_sync_stop();\n}\n\nstatic bool dirty_ring_supported(void)\n{\n\treturn (kvm_has_cap(KVM_CAP_DIRTY_LOG_RING) ||\n\t\tkvm_has_cap(KVM_CAP_DIRTY_LOG_RING_ACQ_REL));\n}\n\nstatic void dirty_ring_create_vm_done(struct kvm_vm *vm)\n{\n\tuint64_t pages;\n\tuint32_t limit;\n\n\t \n\tpages = (1ul << (DIRTY_MEM_BITS - vm->page_shift)) + 3;\n\tpages = vm_adjust_num_guest_pages(vm->mode, pages);\n\tif (vm->page_size < getpagesize())\n\t\tpages = vm_num_host_pages(vm->mode, pages);\n\n\tlimit = 1 << (31 - __builtin_clz(pages));\n\ttest_dirty_ring_count = 1 << (31 - __builtin_clz(test_dirty_ring_count));\n\ttest_dirty_ring_count = min(limit, test_dirty_ring_count);\n\tpr_info(\"dirty ring count: 0x%x\\n\", test_dirty_ring_count);\n\n\t \n\tvm_enable_dirty_ring(vm, test_dirty_ring_count *\n\t\t\t     sizeof(struct kvm_dirty_gfn));\n}\n\nstatic inline bool dirty_gfn_is_dirtied(struct kvm_dirty_gfn *gfn)\n{\n\treturn smp_load_acquire(&gfn->flags) == KVM_DIRTY_GFN_F_DIRTY;\n}\n\nstatic inline void dirty_gfn_set_collected(struct kvm_dirty_gfn *gfn)\n{\n\tsmp_store_release(&gfn->flags, KVM_DIRTY_GFN_F_RESET);\n}\n\nstatic uint32_t dirty_ring_collect_one(struct kvm_dirty_gfn *dirty_gfns,\n\t\t\t\t       int slot, void *bitmap,\n\t\t\t\t       uint32_t num_pages, uint32_t *fetch_index)\n{\n\tstruct kvm_dirty_gfn *cur;\n\tuint32_t count = 0;\n\n\twhile (true) {\n\t\tcur = &dirty_gfns[*fetch_index % test_dirty_ring_count];\n\t\tif (!dirty_gfn_is_dirtied(cur))\n\t\t\tbreak;\n\t\tTEST_ASSERT(cur->slot == slot, \"Slot number didn't match: \"\n\t\t\t    \"%u != %u\", cur->slot, slot);\n\t\tTEST_ASSERT(cur->offset < num_pages, \"Offset overflow: \"\n\t\t\t    \"0x%llx >= 0x%x\", cur->offset, num_pages);\n\t\t\n\t\t__set_bit_le(cur->offset, bitmap);\n\t\tdirty_ring_last_page = cur->offset;\n\t\tdirty_gfn_set_collected(cur);\n\t\t(*fetch_index)++;\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic void dirty_ring_wait_vcpu(void)\n{\n\t \n\tvcpu_kick();\n\tsem_wait_until(&sem_vcpu_stop);\n}\n\nstatic void dirty_ring_continue_vcpu(void)\n{\n\tpr_info(\"Notifying vcpu to continue\\n\");\n\tsem_post(&sem_vcpu_cont);\n}\n\nstatic void dirty_ring_collect_dirty_pages(struct kvm_vcpu *vcpu, int slot,\n\t\t\t\t\t   void *bitmap, uint32_t num_pages,\n\t\t\t\t\t   uint32_t *ring_buf_idx)\n{\n\tuint32_t count = 0, cleared;\n\tbool continued_vcpu = false;\n\n\tdirty_ring_wait_vcpu();\n\n\tif (!dirty_ring_vcpu_ring_full) {\n\t\t \n\t\tdirty_ring_continue_vcpu();\n\t\tcontinued_vcpu = true;\n\t}\n\n\t \n\tcount = dirty_ring_collect_one(vcpu_map_dirty_ring(vcpu),\n\t\t\t\t       slot, bitmap, num_pages,\n\t\t\t\t       ring_buf_idx);\n\n\tcleared = kvm_vm_reset_dirty_ring(vcpu->vm);\n\n\t \n\tTEST_ASSERT(cleared == count, \"Reset dirty pages (%u) mismatch \"\n\t\t    \"with collected (%u)\", cleared, count);\n\n\tif (!continued_vcpu) {\n\t\tTEST_ASSERT(dirty_ring_vcpu_ring_full,\n\t\t\t    \"Didn't continue vcpu even without ring full\");\n\t\tdirty_ring_continue_vcpu();\n\t}\n\n\tpr_info(\"Iteration %ld collected %u pages\\n\", iteration, count);\n}\n\nstatic void dirty_ring_after_vcpu_run(struct kvm_vcpu *vcpu, int ret, int err)\n{\n\tstruct kvm_run *run = vcpu->run;\n\n\t \n\tif (get_ucall(vcpu, NULL) == UCALL_SYNC) {\n\t\t \n\t\t;\n\t} else if (run->exit_reason == KVM_EXIT_DIRTY_RING_FULL ||\n\t\t   (ret == -1 && err == EINTR)) {\n\t\t \n\t\tWRITE_ONCE(dirty_ring_vcpu_ring_full,\n\t\t\t   run->exit_reason == KVM_EXIT_DIRTY_RING_FULL);\n\t\tsem_post(&sem_vcpu_stop);\n\t\tpr_info(\"vcpu stops because %s...\\n\",\n\t\t\tdirty_ring_vcpu_ring_full ?\n\t\t\t\"dirty ring is full\" : \"vcpu is kicked out\");\n\t\tsem_wait_until(&sem_vcpu_cont);\n\t\tpr_info(\"vcpu continues now.\\n\");\n\t} else {\n\t\tTEST_ASSERT(false, \"Invalid guest sync status: \"\n\t\t\t    \"exit_reason=%s\\n\",\n\t\t\t    exit_reason_str(run->exit_reason));\n\t}\n}\n\nstatic void dirty_ring_before_vcpu_join(void)\n{\n\t \n\tsem_post(&sem_vcpu_cont);\n}\n\nstruct log_mode {\n\tconst char *name;\n\t \n\tbool (*supported)(void);\n\t \n\tvoid (*create_vm_done)(struct kvm_vm *vm);\n\t \n\tvoid (*collect_dirty_pages) (struct kvm_vcpu *vcpu, int slot,\n\t\t\t\t     void *bitmap, uint32_t num_pages,\n\t\t\t\t     uint32_t *ring_buf_idx);\n\t \n\tvoid (*after_vcpu_run)(struct kvm_vcpu *vcpu, int ret, int err);\n\tvoid (*before_vcpu_join) (void);\n} log_modes[LOG_MODE_NUM] = {\n\t{\n\t\t.name = \"dirty-log\",\n\t\t.collect_dirty_pages = dirty_log_collect_dirty_pages,\n\t\t.after_vcpu_run = default_after_vcpu_run,\n\t},\n\t{\n\t\t.name = \"clear-log\",\n\t\t.supported = clear_log_supported,\n\t\t.create_vm_done = clear_log_create_vm_done,\n\t\t.collect_dirty_pages = clear_log_collect_dirty_pages,\n\t\t.after_vcpu_run = default_after_vcpu_run,\n\t},\n\t{\n\t\t.name = \"dirty-ring\",\n\t\t.supported = dirty_ring_supported,\n\t\t.create_vm_done = dirty_ring_create_vm_done,\n\t\t.collect_dirty_pages = dirty_ring_collect_dirty_pages,\n\t\t.before_vcpu_join = dirty_ring_before_vcpu_join,\n\t\t.after_vcpu_run = dirty_ring_after_vcpu_run,\n\t},\n};\n\n \nstatic unsigned long *host_bmap_track;\n\nstatic void log_modes_dump(void)\n{\n\tint i;\n\n\tprintf(\"all\");\n\tfor (i = 0; i < LOG_MODE_NUM; i++)\n\t\tprintf(\", %s\", log_modes[i].name);\n\tprintf(\"\\n\");\n}\n\nstatic bool log_mode_supported(void)\n{\n\tstruct log_mode *mode = &log_modes[host_log_mode];\n\n\tif (mode->supported)\n\t\treturn mode->supported();\n\n\treturn true;\n}\n\nstatic void log_mode_create_vm_done(struct kvm_vm *vm)\n{\n\tstruct log_mode *mode = &log_modes[host_log_mode];\n\n\tif (mode->create_vm_done)\n\t\tmode->create_vm_done(vm);\n}\n\nstatic void log_mode_collect_dirty_pages(struct kvm_vcpu *vcpu, int slot,\n\t\t\t\t\t void *bitmap, uint32_t num_pages,\n\t\t\t\t\t uint32_t *ring_buf_idx)\n{\n\tstruct log_mode *mode = &log_modes[host_log_mode];\n\n\tTEST_ASSERT(mode->collect_dirty_pages != NULL,\n\t\t    \"collect_dirty_pages() is required for any log mode!\");\n\tmode->collect_dirty_pages(vcpu, slot, bitmap, num_pages, ring_buf_idx);\n}\n\nstatic void log_mode_after_vcpu_run(struct kvm_vcpu *vcpu, int ret, int err)\n{\n\tstruct log_mode *mode = &log_modes[host_log_mode];\n\n\tif (mode->after_vcpu_run)\n\t\tmode->after_vcpu_run(vcpu, ret, err);\n}\n\nstatic void log_mode_before_vcpu_join(void)\n{\n\tstruct log_mode *mode = &log_modes[host_log_mode];\n\n\tif (mode->before_vcpu_join)\n\t\tmode->before_vcpu_join();\n}\n\nstatic void generate_random_array(uint64_t *guest_array, uint64_t size)\n{\n\tuint64_t i;\n\n\tfor (i = 0; i < size; i++)\n\t\tguest_array[i] = random();\n}\n\nstatic void *vcpu_worker(void *data)\n{\n\tint ret;\n\tstruct kvm_vcpu *vcpu = data;\n\tstruct kvm_vm *vm = vcpu->vm;\n\tuint64_t *guest_array;\n\tuint64_t pages_count = 0;\n\tstruct kvm_signal_mask *sigmask = alloca(offsetof(struct kvm_signal_mask, sigset)\n\t\t\t\t\t\t + sizeof(sigset_t));\n\tsigset_t *sigset = (sigset_t *) &sigmask->sigset;\n\n\t \n\tsigmask->len = 8;\n\tpthread_sigmask(0, NULL, sigset);\n\tsigdelset(sigset, SIG_IPI);\n\tvcpu_ioctl(vcpu, KVM_SET_SIGNAL_MASK, sigmask);\n\n\tsigemptyset(sigset);\n\tsigaddset(sigset, SIG_IPI);\n\n\tguest_array = addr_gva2hva(vm, (vm_vaddr_t)random_array);\n\n\twhile (!READ_ONCE(host_quit)) {\n\t\t \n\t\tgenerate_random_array(guest_array, TEST_PAGES_PER_LOOP);\n\t\tpages_count += TEST_PAGES_PER_LOOP;\n\t\t \n\t\tret = __vcpu_run(vcpu);\n\t\tif (ret == -1 && errno == EINTR) {\n\t\t\tint sig = -1;\n\t\t\tsigwait(sigset, &sig);\n\t\t\tassert(sig == SIG_IPI);\n\t\t}\n\t\tlog_mode_after_vcpu_run(vcpu, ret, errno);\n\t}\n\n\tpr_info(\"Dirtied %\"PRIu64\" pages\\n\", pages_count);\n\n\treturn NULL;\n}\n\nstatic void vm_dirty_log_verify(enum vm_guest_mode mode, unsigned long *bmap)\n{\n\tuint64_t step = vm_num_host_pages(mode, 1);\n\tuint64_t page;\n\tuint64_t *value_ptr;\n\tuint64_t min_iter = 0;\n\n\tfor (page = 0; page < host_num_pages; page += step) {\n\t\tvalue_ptr = host_test_mem + page * host_page_size;\n\n\t\t \n\t\tif (__test_and_clear_bit_le(page, host_bmap_track)) {\n\t\t\thost_track_next_count++;\n\t\t\tTEST_ASSERT(test_bit_le(page, bmap),\n\t\t\t\t    \"Page %\"PRIu64\" should have its dirty bit \"\n\t\t\t\t    \"set in this iteration but it is missing\",\n\t\t\t\t    page);\n\t\t}\n\n\t\tif (__test_and_clear_bit_le(page, bmap)) {\n\t\t\tbool matched;\n\n\t\t\thost_dirty_count++;\n\n\t\t\t \n\t\t\tmatched = (*value_ptr == iteration ||\n\t\t\t\t   *value_ptr == iteration - 1);\n\n\t\t\tif (host_log_mode == LOG_MODE_DIRTY_RING && !matched) {\n\t\t\t\tif (*value_ptr == iteration - 2 && min_iter <= iteration - 2) {\n\t\t\t\t\t \n\t\t\t\t\tmin_iter = iteration - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (page == dirty_ring_last_page) {\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTEST_ASSERT(matched,\n\t\t\t\t    \"Set page %\"PRIu64\" value %\"PRIu64\n\t\t\t\t    \" incorrect (iteration=%\"PRIu64\")\",\n\t\t\t\t    page, *value_ptr, iteration);\n\t\t} else {\n\t\t\thost_clear_count++;\n\t\t\t \n\t\t\tTEST_ASSERT(*value_ptr <= iteration,\n\t\t\t\t    \"Clear page %\"PRIu64\" value %\"PRIu64\n\t\t\t\t    \" incorrect (iteration=%\"PRIu64\")\",\n\t\t\t\t    page, *value_ptr, iteration);\n\t\t\tif (*value_ptr == iteration) {\n\t\t\t\t \n\t\t\t\t__set_bit_le(page, host_bmap_track);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic struct kvm_vm *create_vm(enum vm_guest_mode mode, struct kvm_vcpu **vcpu,\n\t\t\t\tuint64_t extra_mem_pages, void *guest_code)\n{\n\tstruct kvm_vm *vm;\n\n\tpr_info(\"Testing guest mode: %s\\n\", vm_guest_mode_string(mode));\n\n\tvm = __vm_create(mode, 1, extra_mem_pages);\n\n\tlog_mode_create_vm_done(vm);\n\t*vcpu = vm_vcpu_add(vm, 0, guest_code);\n\treturn vm;\n}\n\nstruct test_params {\n\tunsigned long iterations;\n\tunsigned long interval;\n\tuint64_t phys_offset;\n};\n\nstatic void run_test(enum vm_guest_mode mode, void *arg)\n{\n\tstruct test_params *p = arg;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tunsigned long *bmap;\n\tuint32_t ring_buf_idx = 0;\n\n\tif (!log_mode_supported()) {\n\t\tprint_skip(\"Log mode '%s' not supported\",\n\t\t\t   log_modes[host_log_mode].name);\n\t\treturn;\n\t}\n\n\t \n\tvm = create_vm(mode, &vcpu,\n\t\t       2ul << (DIRTY_MEM_BITS - PAGE_SHIFT_4K), guest_code);\n\n\tguest_page_size = vm->page_size;\n\t \n\tguest_num_pages = (1ul << (DIRTY_MEM_BITS - vm->page_shift)) + 3;\n\tguest_num_pages = vm_adjust_num_guest_pages(mode, guest_num_pages);\n\n\thost_page_size = getpagesize();\n\thost_num_pages = vm_num_host_pages(mode, guest_num_pages);\n\n\tif (!p->phys_offset) {\n\t\tguest_test_phys_mem = (vm->max_gfn - guest_num_pages) *\n\t\t\t\t      guest_page_size;\n\t\tguest_test_phys_mem = align_down(guest_test_phys_mem, host_page_size);\n\t} else {\n\t\tguest_test_phys_mem = p->phys_offset;\n\t}\n\n#ifdef __s390x__\n\t \n\tguest_test_phys_mem = align_down(guest_test_phys_mem, 1 << 20);\n#endif\n\n\tpr_info(\"guest physical test memory offset: 0x%lx\\n\", guest_test_phys_mem);\n\n\tbmap = bitmap_zalloc(host_num_pages);\n\thost_bmap_track = bitmap_zalloc(host_num_pages);\n\n\t \n\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS,\n\t\t\t\t    guest_test_phys_mem,\n\t\t\t\t    TEST_MEM_SLOT_INDEX,\n\t\t\t\t    guest_num_pages,\n\t\t\t\t    KVM_MEM_LOG_DIRTY_PAGES);\n\n\t \n\tvirt_map(vm, guest_test_virt_mem, guest_test_phys_mem, guest_num_pages);\n\n\t \n\thost_test_mem = addr_gpa2hva(vm, (vm_paddr_t)guest_test_phys_mem);\n\n\t \n\tsync_global_to_guest(vm, host_page_size);\n\tsync_global_to_guest(vm, guest_page_size);\n\tsync_global_to_guest(vm, guest_test_virt_mem);\n\tsync_global_to_guest(vm, guest_num_pages);\n\n\t \n\titeration = 1;\n\tsync_global_to_guest(vm, iteration);\n\thost_quit = false;\n\thost_dirty_count = 0;\n\thost_clear_count = 0;\n\thost_track_next_count = 0;\n\tWRITE_ONCE(dirty_ring_vcpu_ring_full, false);\n\n\tpthread_create(&vcpu_thread, NULL, vcpu_worker, vcpu);\n\n\twhile (iteration < p->iterations) {\n\t\t \n\t\tusleep(p->interval * 1000);\n\t\tlog_mode_collect_dirty_pages(vcpu, TEST_MEM_SLOT_INDEX,\n\t\t\t\t\t     bmap, host_num_pages,\n\t\t\t\t\t     &ring_buf_idx);\n\n\t\t \n\t\tatomic_set(&vcpu_sync_stop_requested, true);\n\t\tsem_wait_until(&sem_vcpu_stop);\n\t\t \n\t\tassert(host_log_mode == LOG_MODE_DIRTY_RING ||\n\t\t       atomic_read(&vcpu_sync_stop_requested) == false);\n\t\tvm_dirty_log_verify(mode, bmap);\n\t\tsem_post(&sem_vcpu_cont);\n\n\t\titeration++;\n\t\tsync_global_to_guest(vm, iteration);\n\t}\n\n\t \n\thost_quit = true;\n\tlog_mode_before_vcpu_join();\n\tpthread_join(vcpu_thread, NULL);\n\n\tpr_info(\"Total bits checked: dirty (%\"PRIu64\"), clear (%\"PRIu64\"), \"\n\t\t\"track_next (%\"PRIu64\")\\n\", host_dirty_count, host_clear_count,\n\t\thost_track_next_count);\n\n\tfree(bmap);\n\tfree(host_bmap_track);\n\tkvm_vm_free(vm);\n}\n\nstatic void help(char *name)\n{\n\tputs(\"\");\n\tprintf(\"usage: %s [-h] [-i iterations] [-I interval] \"\n\t       \"[-p offset] [-m mode]\\n\", name);\n\tputs(\"\");\n\tprintf(\" -c: hint to dirty ring size, in number of entries\\n\");\n\tprintf(\"     (only useful for dirty-ring test; default: %\"PRIu32\")\\n\",\n\t       TEST_DIRTY_RING_COUNT);\n\tprintf(\" -i: specify iteration counts (default: %\"PRIu64\")\\n\",\n\t       TEST_HOST_LOOP_N);\n\tprintf(\" -I: specify interval in ms (default: %\"PRIu64\" ms)\\n\",\n\t       TEST_HOST_LOOP_INTERVAL);\n\tprintf(\" -p: specify guest physical test memory offset\\n\"\n\t       \"     Warning: a low offset can conflict with the loaded test code.\\n\");\n\tprintf(\" -M: specify the host logging mode \"\n\t       \"(default: run all log modes).  Supported modes: \\n\\t\");\n\tlog_modes_dump();\n\tguest_modes_help();\n\tputs(\"\");\n\texit(0);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct test_params p = {\n\t\t.iterations = TEST_HOST_LOOP_N,\n\t\t.interval = TEST_HOST_LOOP_INTERVAL,\n\t};\n\tint opt, i;\n\tsigset_t sigset;\n\n\tsem_init(&sem_vcpu_stop, 0, 0);\n\tsem_init(&sem_vcpu_cont, 0, 0);\n\n\tguest_modes_append_default();\n\n\twhile ((opt = getopt(argc, argv, \"c:hi:I:p:m:M:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'c':\n\t\t\ttest_dirty_ring_count = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tp.iterations = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tp.interval = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tp.phys_offset = strtoull(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tguest_modes_cmdline(optarg);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tif (!strcmp(optarg, \"all\")) {\n\t\t\t\thost_log_mode_option = LOG_MODE_ALL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = 0; i < LOG_MODE_NUM; i++) {\n\t\t\t\tif (!strcmp(optarg, log_modes[i].name)) {\n\t\t\t\t\tpr_info(\"Setting log mode to: '%s'\\n\",\n\t\t\t\t\t\toptarg);\n\t\t\t\t\thost_log_mode_option = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == LOG_MODE_NUM) {\n\t\t\t\tprintf(\"Log mode '%s' invalid. Please choose \"\n\t\t\t\t       \"from: \", optarg);\n\t\t\t\tlog_modes_dump();\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tTEST_ASSERT(p.iterations > 2, \"Iterations must be greater than two\");\n\tTEST_ASSERT(p.interval > 0, \"Interval must be greater than zero\");\n\n\tpr_info(\"Test iterations: %\"PRIu64\", interval: %\"PRIu64\" (ms)\\n\",\n\t\tp.iterations, p.interval);\n\n\tsrandom(time(0));\n\n\t \n\tsigemptyset(&sigset);\n\tsigaddset(&sigset, SIG_IPI);\n\tpthread_sigmask(SIG_BLOCK, &sigset, NULL);\n\n\tif (host_log_mode_option == LOG_MODE_ALL) {\n\t\t \n\t\tfor (i = 0; i < LOG_MODE_NUM; i++) {\n\t\t\tpr_info(\"Testing Log Mode '%s'\\n\", log_modes[i].name);\n\t\t\thost_log_mode = i;\n\t\t\tfor_each_guest_mode(run_test, &p);\n\t\t}\n\t} else {\n\t\thost_log_mode = host_log_mode_option;\n\t\tfor_each_guest_mode(run_test, &p);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}