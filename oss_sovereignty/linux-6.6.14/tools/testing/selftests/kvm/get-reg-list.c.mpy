{
  "module_name": "get-reg-list.c",
  "hash_id": "6e009c295eb92b06d6d8967c9e8367aaf23b2290c05b993da0bca92e85fe5daa",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/get-reg-list.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include \"kvm_util.h\"\n#include \"test_util.h\"\n#include \"processor.h\"\n\nstatic struct kvm_reg_list *reg_list;\nstatic __u64 *blessed_reg, blessed_n;\n\nextern struct vcpu_reg_list *vcpu_configs[];\nextern int vcpu_configs_n;\n\n#define for_each_reg(i)\t\t\t\t\t\t\t\t\\\n\tfor ((i) = 0; (i) < reg_list->n; ++(i))\n\n#define for_each_reg_filtered(i)\t\t\t\t\t\t\\\n\tfor_each_reg(i)\t\t\t\t\t\t\t\t\\\n\t\tif (!filter_reg(reg_list->reg[i]))\n\n#define for_each_missing_reg(i)\t\t\t\t\t\t\t\\\n\tfor ((i) = 0; (i) < blessed_n; ++(i))\t\t\t\t\t\\\n\t\tif (!find_reg(reg_list->reg, reg_list->n, blessed_reg[i]))\t\\\n\t\t\tif (check_supported_reg(vcpu, blessed_reg[i]))\n\n#define for_each_new_reg(i)\t\t\t\t\t\t\t\\\n\tfor_each_reg_filtered(i)\t\t\t\t\t\t\\\n\t\tif (!find_reg(blessed_reg, blessed_n, reg_list->reg[i]))\n\n#define for_each_present_blessed_reg(i)\t\t\t\t\t\t\\\n\tfor_each_reg(i)\t\t\t\t\t\t\t\t\\\n\t\tif (find_reg(blessed_reg, blessed_n, reg_list->reg[i]))\n\nstatic const char *config_name(struct vcpu_reg_list *c)\n{\n\tstruct vcpu_reg_sublist *s;\n\tint len = 0;\n\n\tif (c->name)\n\t\treturn c->name;\n\n\tfor_each_sublist(c, s)\n\t\tlen += strlen(s->name) + 1;\n\n\tc->name = malloc(len);\n\n\tlen = 0;\n\tfor_each_sublist(c, s) {\n\t\tif (!strcmp(s->name, \"base\"))\n\t\t\tcontinue;\n\t\tstrcat(c->name + len, s->name);\n\t\tlen += strlen(s->name) + 1;\n\t\tc->name[len - 1] = '+';\n\t}\n\tc->name[len - 1] = '\\0';\n\n\treturn c->name;\n}\n\nbool __weak check_supported_reg(struct kvm_vcpu *vcpu, __u64 reg)\n{\n\treturn true;\n}\n\nbool __weak filter_reg(__u64 reg)\n{\n\treturn false;\n}\n\nstatic bool find_reg(__u64 regs[], __u64 nr_regs, __u64 reg)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_regs; ++i)\n\t\tif (reg == regs[i])\n\t\t\treturn true;\n\treturn false;\n}\n\nvoid __weak print_reg(const char *prefix, __u64 id)\n{\n\tprintf(\"\\t0x%llx,\\n\", id);\n}\n\nbool __weak check_reject_set(int err)\n{\n\treturn true;\n}\n\nvoid __weak finalize_vcpu(struct kvm_vcpu *vcpu, struct vcpu_reg_list *c)\n{\n}\n\n#ifdef __aarch64__\nstatic void prepare_vcpu_init(struct vcpu_reg_list *c, struct kvm_vcpu_init *init)\n{\n\tstruct vcpu_reg_sublist *s;\n\n\tfor_each_sublist(c, s)\n\t\tif (s->capability)\n\t\t\tinit->features[s->feature / 32] |= 1 << (s->feature % 32);\n}\n\nstatic struct kvm_vcpu *vcpu_config_get_vcpu(struct vcpu_reg_list *c, struct kvm_vm *vm)\n{\n\tstruct kvm_vcpu_init init = { .target = -1, };\n\tstruct kvm_vcpu *vcpu;\n\n\tprepare_vcpu_init(c, &init);\n\tvcpu = __vm_vcpu_add(vm, 0);\n\taarch64_vcpu_setup(vcpu, &init);\n\n\treturn vcpu;\n}\n#else\nstatic struct kvm_vcpu *vcpu_config_get_vcpu(struct vcpu_reg_list *c, struct kvm_vm *vm)\n{\n\treturn __vm_vcpu_add(vm, 0);\n}\n#endif\n\nstatic void check_supported(struct vcpu_reg_list *c)\n{\n\tstruct vcpu_reg_sublist *s;\n\n\tfor_each_sublist(c, s) {\n\t\tif (!s->capability)\n\t\t\tcontinue;\n\n\t\t__TEST_REQUIRE(kvm_has_cap(s->capability),\n\t\t\t       \"%s: %s not available, skipping tests\\n\",\n\t\t\t       config_name(c), s->name);\n\t}\n}\n\nstatic bool print_list;\nstatic bool print_filtered;\n\nstatic void run_test(struct vcpu_reg_list *c)\n{\n\tint new_regs = 0, missing_regs = 0, i, n;\n\tint failed_get = 0, failed_set = 0, failed_reject = 0;\n\tint skipped_set = 0;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct vcpu_reg_sublist *s;\n\n\tcheck_supported(c);\n\n\tvm = vm_create_barebones();\n\tvcpu = vcpu_config_get_vcpu(c, vm);\n\tfinalize_vcpu(vcpu, c);\n\n\treg_list = vcpu_get_reg_list(vcpu);\n\n\tif (print_list || print_filtered) {\n\t\tputchar('\\n');\n\t\tfor_each_reg(i) {\n\t\t\t__u64 id = reg_list->reg[i];\n\t\t\tif ((print_list && !filter_reg(id)) ||\n\t\t\t    (print_filtered && filter_reg(id)))\n\t\t\t\tprint_reg(config_name(c), id);\n\t\t}\n\t\tputchar('\\n');\n\t\treturn;\n\t}\n\n\tfor_each_sublist(c, s)\n\t\tblessed_n += s->regs_n;\n\tblessed_reg = calloc(blessed_n, sizeof(__u64));\n\n\tn = 0;\n\tfor_each_sublist(c, s) {\n\t\tfor (i = 0; i < s->regs_n; ++i)\n\t\t\tblessed_reg[n++] = s->regs[i];\n\t}\n\n\t \n\tfor_each_present_blessed_reg(i) {\n\t\tuint8_t addr[2048 / 8];\n\t\tstruct kvm_one_reg reg = {\n\t\t\t.id = reg_list->reg[i],\n\t\t\t.addr = (__u64)&addr,\n\t\t};\n\t\tbool reject_reg = false, skip_reg = false;\n\t\tint ret;\n\n\t\tret = __vcpu_get_reg(vcpu, reg_list->reg[i], &addr);\n\t\tif (ret) {\n\t\t\tprintf(\"%s: Failed to get \", config_name(c));\n\t\t\tprint_reg(config_name(c), reg.id);\n\t\t\tputchar('\\n');\n\t\t\t++failed_get;\n\t\t}\n\n\t\tfor_each_sublist(c, s) {\n\t\t\t \n\t\t\tif (s->rejects_set && find_reg(s->rejects_set, s->rejects_set_n, reg.id)) {\n\t\t\t\treject_reg = true;\n\t\t\t\tret = __vcpu_ioctl(vcpu, KVM_SET_ONE_REG, &reg);\n\t\t\t\tif (ret != -1 || !check_reject_set(errno)) {\n\t\t\t\t\tprintf(\"%s: Failed to reject (ret=%d, errno=%d) \", config_name(c), ret, errno);\n\t\t\t\t\tprint_reg(config_name(c), reg.id);\n\t\t\t\t\tputchar('\\n');\n\t\t\t\t\t++failed_reject;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (s->skips_set && find_reg(s->skips_set, s->skips_set_n, reg.id)) {\n\t\t\t\tskip_reg = true;\n\t\t\t\t++skipped_set;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!reject_reg && !skip_reg) {\n\t\t\tret = __vcpu_ioctl(vcpu, KVM_SET_ONE_REG, &reg);\n\t\t\tif (ret) {\n\t\t\t\tprintf(\"%s: Failed to set \", config_name(c));\n\t\t\t\tprint_reg(config_name(c), reg.id);\n\t\t\t\tputchar('\\n');\n\t\t\t\t++failed_set;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_each_new_reg(i)\n\t\t++new_regs;\n\n\tfor_each_missing_reg(i)\n\t\t++missing_regs;\n\n\tif (new_regs || missing_regs) {\n\t\tn = 0;\n\t\tfor_each_reg_filtered(i)\n\t\t\t++n;\n\n\t\tprintf(\"%s: Number blessed registers: %5lld\\n\", config_name(c), blessed_n);\n\t\tprintf(\"%s: Number registers:         %5lld (includes %lld filtered registers)\\n\",\n\t\t       config_name(c), reg_list->n, reg_list->n - n);\n\t}\n\n\tif (new_regs) {\n\t\tprintf(\"\\n%s: There are %d new registers.\\n\"\n\t\t       \"Consider adding them to the blessed reg \"\n\t\t       \"list with the following lines:\\n\\n\", config_name(c), new_regs);\n\t\tfor_each_new_reg(i)\n\t\t\tprint_reg(config_name(c), reg_list->reg[i]);\n\t\tputchar('\\n');\n\t}\n\n\tif (missing_regs) {\n\t\tprintf(\"\\n%s: There are %d missing registers.\\n\"\n\t\t       \"The following lines are missing registers:\\n\\n\", config_name(c), missing_regs);\n\t\tfor_each_missing_reg(i)\n\t\t\tprint_reg(config_name(c), blessed_reg[i]);\n\t\tputchar('\\n');\n\t}\n\n\tTEST_ASSERT(!missing_regs && !failed_get && !failed_set && !failed_reject,\n\t\t    \"%s: There are %d missing registers; %d registers failed get; \"\n\t\t    \"%d registers failed set; %d registers failed reject; %d registers skipped set\",\n\t\t    config_name(c), missing_regs, failed_get, failed_set, failed_reject, skipped_set);\n\n\tpr_info(\"%s: PASS\\n\", config_name(c));\n\tblessed_n = 0;\n\tfree(blessed_reg);\n\tfree(reg_list);\n\tkvm_vm_free(vm);\n}\n\nstatic void help(void)\n{\n\tstruct vcpu_reg_list *c;\n\tint i;\n\n\tprintf(\n\t\"\\n\"\n\t\"usage: get-reg-list [--config=<selection>] [--list] [--list-filtered]\\n\\n\"\n\t\" --config=<selection>        Used to select a specific vcpu configuration for the test/listing\\n\"\n\t\"                             '<selection>' may be\\n\");\n\n\tfor (i = 0; i < vcpu_configs_n; ++i) {\n\t\tc = vcpu_configs[i];\n\t\tprintf(\n\t\"                               '%s'\\n\", config_name(c));\n\t}\n\n\tprintf(\n\t\"\\n\"\n\t\" --list                      Print the register list rather than test it (requires --config)\\n\"\n\t\" --list-filtered             Print registers that would normally be filtered out (requires --config)\\n\"\n\t\"\\n\"\n\t);\n}\n\nstatic struct vcpu_reg_list *parse_config(const char *config)\n{\n\tstruct vcpu_reg_list *c = NULL;\n\tint i;\n\n\tif (config[8] != '=')\n\t\thelp(), exit(1);\n\n\tfor (i = 0; i < vcpu_configs_n; ++i) {\n\t\tc = vcpu_configs[i];\n\t\tif (strcmp(config_name(c), &config[9]) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == vcpu_configs_n)\n\t\thelp(), exit(1);\n\n\treturn c;\n}\n\nint main(int ac, char **av)\n{\n\tstruct vcpu_reg_list *c, *sel = NULL;\n\tint i, ret = 0;\n\tpid_t pid;\n\n\tfor (i = 1; i < ac; ++i) {\n\t\tif (strncmp(av[i], \"--config\", 8) == 0)\n\t\t\tsel = parse_config(av[i]);\n\t\telse if (strcmp(av[i], \"--list\") == 0)\n\t\t\tprint_list = true;\n\t\telse if (strcmp(av[i], \"--list-filtered\") == 0)\n\t\t\tprint_filtered = true;\n\t\telse if (strcmp(av[i], \"--help\") == 0 || strcmp(av[1], \"-h\") == 0)\n\t\t\thelp(), exit(0);\n\t\telse\n\t\t\thelp(), exit(1);\n\t}\n\n\tif (print_list || print_filtered) {\n\t\t \n\t\tif (!sel)\n\t\t\thelp(), exit(1);\n\t}\n\n\tfor (i = 0; i < vcpu_configs_n; ++i) {\n\t\tc = vcpu_configs[i];\n\t\tif (sel && c != sel)\n\t\t\tcontinue;\n\n\t\tpid = fork();\n\n\t\tif (!pid) {\n\t\t\trun_test(c);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tint wstatus;\n\t\t\tpid_t wpid = wait(&wstatus);\n\t\t\tTEST_ASSERT(wpid == pid && WIFEXITED(wstatus), \"wait: Unexpected return\");\n\t\t\tif (WEXITSTATUS(wstatus) && WEXITSTATUS(wstatus) != KSFT_SKIP)\n\t\t\t\tret = KSFT_FAIL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}