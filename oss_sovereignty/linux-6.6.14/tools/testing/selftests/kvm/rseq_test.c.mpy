{
  "module_name": "rseq_test.c",
  "hash_id": "c4f70830f88ca0802aa63be775ae8309412992d1d5731d0924ba8705d83dadc6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/rseq_test.c",
  "human_readable_source": "\n#define _GNU_SOURCE  \n#include <errno.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <syscall.h>\n#include <sys/ioctl.h>\n#include <sys/sysinfo.h>\n#include <asm/barrier.h>\n#include <linux/atomic.h>\n#include <linux/rseq.h>\n#include <linux/unistd.h>\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"test_util.h\"\n\n#include \"../rseq/rseq.c\"\n\n \n#define NR_TASK_MIGRATIONS 100000\n\nstatic pthread_t migration_thread;\nstatic cpu_set_t possible_mask;\nstatic int min_cpu, max_cpu;\nstatic bool done;\n\nstatic atomic_t seq_cnt;\n\nstatic void guest_code(void)\n{\n\tfor (;;)\n\t\tGUEST_SYNC(0);\n}\n\nstatic int next_cpu(int cpu)\n{\n\t \n\tdo {\n\t\tcpu++;\n\t\tif (cpu > max_cpu) {\n\t\t\tcpu = min_cpu;\n\t\t\tTEST_ASSERT(CPU_ISSET(cpu, &possible_mask),\n\t\t\t\t    \"Min CPU = %d must always be usable\", cpu);\n\t\t\tbreak;\n\t\t}\n\t} while (!CPU_ISSET(cpu, &possible_mask));\n\n\treturn cpu;\n}\n\nstatic void *migration_worker(void *__rseq_tid)\n{\n\tpid_t rseq_tid = (pid_t)(unsigned long)__rseq_tid;\n\tcpu_set_t allowed_mask;\n\tint r, i, cpu;\n\n\tCPU_ZERO(&allowed_mask);\n\n\tfor (i = 0, cpu = min_cpu; i < NR_TASK_MIGRATIONS; i++, cpu = next_cpu(cpu)) {\n\t\tCPU_SET(cpu, &allowed_mask);\n\n\t\t \n\t\tatomic_inc(&seq_cnt);\n\n\t\t \n\t\tsmp_wmb();\n\t\tr = sched_setaffinity(rseq_tid, sizeof(allowed_mask), &allowed_mask);\n\t\tTEST_ASSERT(!r, \"sched_setaffinity failed, errno = %d (%s)\",\n\t\t\t    errno, strerror(errno));\n\t\tsmp_wmb();\n\t\tatomic_inc(&seq_cnt);\n\n\t\tCPU_CLR(cpu, &allowed_mask);\n\n\t\t \n\t\tusleep((i % 10) + 1);\n\t}\n\tdone = true;\n\treturn NULL;\n}\n\nstatic void calc_min_max_cpu(void)\n{\n\tint i, cnt, nproc;\n\n\tTEST_REQUIRE(CPU_COUNT(&possible_mask) >= 2);\n\n\t \n\tnproc = get_nprocs_conf();\n\tmin_cpu = -1;\n\tmax_cpu = -1;\n\tcnt = 0;\n\n\tfor (i = 0; i < nproc; i++) {\n\t\tif (!CPU_ISSET(i, &possible_mask))\n\t\t\tcontinue;\n\t\tif (min_cpu == -1)\n\t\t\tmin_cpu = i;\n\t\tmax_cpu = i;\n\t\tcnt++;\n\t}\n\n\t__TEST_REQUIRE(cnt >= 2,\n\t\t       \"Only one usable CPU, task migration not possible\");\n}\n\nint main(int argc, char *argv[])\n{\n\tint r, i, snapshot;\n\tstruct kvm_vm *vm;\n\tstruct kvm_vcpu *vcpu;\n\tu32 cpu, rseq_cpu;\n\n\tr = sched_getaffinity(0, sizeof(possible_mask), &possible_mask);\n\tTEST_ASSERT(!r, \"sched_getaffinity failed, errno = %d (%s)\", errno,\n\t\t    strerror(errno));\n\n\tcalc_min_max_cpu();\n\n\tr = rseq_register_current_thread();\n\tTEST_ASSERT(!r, \"rseq_register_current_thread failed, errno = %d (%s)\",\n\t\t    errno, strerror(errno));\n\n\t \n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\tpthread_create(&migration_thread, NULL, migration_worker,\n\t\t       (void *)(unsigned long)syscall(SYS_gettid));\n\n\tfor (i = 0; !done; i++) {\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT(get_ucall(vcpu, NULL) == UCALL_SYNC,\n\t\t\t    \"Guest failed?\");\n\n\t\t \n\t\tdo {\n\t\t\t \n\t\t\tsnapshot = atomic_read(&seq_cnt) & ~1;\n\n\t\t\t \n\t\t\tsmp_rmb();\n\t\t\tr = sys_getcpu(&cpu, NULL);\n\t\t\tTEST_ASSERT(!r, \"getcpu failed, errno = %d (%s)\",\n\t\t\t\t    errno, strerror(errno));\n\t\t\trseq_cpu = rseq_current_cpu_raw();\n\t\t\tsmp_rmb();\n\t\t} while (snapshot != atomic_read(&seq_cnt));\n\n\t\tTEST_ASSERT(rseq_cpu == cpu,\n\t\t\t    \"rseq CPU = %d, sched CPU = %d\\n\", rseq_cpu, cpu);\n\t}\n\n\t \n\tTEST_ASSERT(i > (NR_TASK_MIGRATIONS / 2),\n\t\t    \"Only performed %d KVM_RUNs, task stalled too much?\\n\", i);\n\n\tpthread_join(migration_thread, NULL);\n\n\tkvm_vm_free(vm);\n\n\trseq_unregister_current_thread();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}