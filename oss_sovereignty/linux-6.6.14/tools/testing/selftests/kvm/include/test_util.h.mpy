{
  "module_name": "test_util.h",
  "hash_id": "d79b4716048bffc8de60189d12f0c3272cd363120e8860d4a8f71d8b6cb41fd2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/include/test_util.h",
  "human_readable_source": " \n \n\n#ifndef SELFTEST_KVM_TEST_UTIL_H\n#define SELFTEST_KVM_TEST_UTIL_H\n\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include \"kselftest.h\"\n\nstatic inline int _no_printf(const char *format, ...) { return 0; }\n\n#ifdef DEBUG\n#define pr_debug(...) printf(__VA_ARGS__)\n#else\n#define pr_debug(...) _no_printf(__VA_ARGS__)\n#endif\n#ifndef QUIET\n#define pr_info(...) printf(__VA_ARGS__)\n#else\n#define pr_info(...) _no_printf(__VA_ARGS__)\n#endif\n\nvoid print_skip(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n#define __TEST_REQUIRE(f, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (!(f))\t\t\t\t\t\t\\\n\t\tksft_exit_skip(\"- \" fmt \"\\n\", ##__VA_ARGS__);\t\\\n} while (0)\n\n#define TEST_REQUIRE(f) __TEST_REQUIRE(f, \"Requirement not met: %s\", #f)\n\nssize_t test_write(int fd, const void *buf, size_t count);\nssize_t test_read(int fd, void *buf, size_t count);\nint test_seq_read(const char *path, char **bufp, size_t *sizep);\n\nvoid test_assert(bool exp, const char *exp_str,\n\t\t const char *file, unsigned int line, const char *fmt, ...)\n\t\t__attribute__((format(printf, 5, 6)));\n\n#define TEST_ASSERT(e, fmt, ...) \\\n\ttest_assert((e), #e, __FILE__, __LINE__, fmt, ##__VA_ARGS__)\n\n#define TEST_ASSERT_EQ(a, b)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof(a) __a = (a);\t\t\t\t\t\t\\\n\ttypeof(b) __b = (b);\t\t\t\t\t\t\\\n\ttest_assert(__a == __b, #a \" == \" #b, __FILE__, __LINE__,\t\\\n\t\t    \"%#lx != %#lx (%s != %s)\",\t\t\t\t\\\n\t\t    (unsigned long)(__a), (unsigned long)(__b), #a, #b);\\\n} while (0)\n\n#define TEST_ASSERT_KVM_EXIT_REASON(vcpu, expected) do {\t\t\\\n\t__u32 exit_reason = (vcpu)->run->exit_reason;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tTEST_ASSERT(exit_reason == (expected),\t\t\t\t\\\n\t\t    \"Wanted KVM exit reason: %u (%s), got: %u (%s)\",    \\\n\t\t    (expected), exit_reason_str((expected)),\t\t\\\n\t\t    exit_reason, exit_reason_str(exit_reason));\t\t\\\n} while (0)\n\n#define TEST_FAIL(fmt, ...) do { \\\n\tTEST_ASSERT(false, fmt, ##__VA_ARGS__); \\\n\t__builtin_unreachable(); \\\n} while (0)\n\nsize_t parse_size(const char *size);\n\nint64_t timespec_to_ns(struct timespec ts);\nstruct timespec timespec_add_ns(struct timespec ts, int64_t ns);\nstruct timespec timespec_add(struct timespec ts1, struct timespec ts2);\nstruct timespec timespec_sub(struct timespec ts1, struct timespec ts2);\nstruct timespec timespec_elapsed(struct timespec start);\nstruct timespec timespec_div(struct timespec ts, int divisor);\n\nstruct guest_random_state {\n\tuint32_t seed;\n};\n\nstruct guest_random_state new_guest_random_state(uint32_t seed);\nuint32_t guest_random_u32(struct guest_random_state *state);\n\nenum vm_mem_backing_src_type {\n\tVM_MEM_SRC_ANONYMOUS,\n\tVM_MEM_SRC_ANONYMOUS_THP,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_16KB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_64KB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_512KB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_1MB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_2MB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_8MB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_16MB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_32MB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_256MB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_512MB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_1GB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_2GB,\n\tVM_MEM_SRC_ANONYMOUS_HUGETLB_16GB,\n\tVM_MEM_SRC_SHMEM,\n\tVM_MEM_SRC_SHARED_HUGETLB,\n\tNUM_SRC_TYPES,\n};\n\n#define DEFAULT_VM_MEM_SRC VM_MEM_SRC_ANONYMOUS\n\nstruct vm_mem_backing_src_alias {\n\tconst char *name;\n\tuint32_t flag;\n};\n\n#define MIN_RUN_DELAY_NS\t200000UL\n\nbool thp_configured(void);\nsize_t get_trans_hugepagesz(void);\nsize_t get_def_hugetlb_pagesz(void);\nconst struct vm_mem_backing_src_alias *vm_mem_backing_src_alias(uint32_t i);\nsize_t get_backing_src_pagesz(uint32_t i);\nbool is_backing_src_hugetlb(uint32_t i);\nvoid backing_src_help(const char *flag);\nenum vm_mem_backing_src_type parse_backing_src_type(const char *type_name);\nlong get_run_delay(void);\n\n \nstatic inline bool backing_src_is_shared(enum vm_mem_backing_src_type t)\n{\n\treturn vm_mem_backing_src_alias(t)->flag & MAP_SHARED;\n}\n\n \nstatic inline uint64_t align_up(uint64_t x, uint64_t size)\n{\n\tuint64_t mask = size - 1;\n\n\tTEST_ASSERT(size != 0 && !(size & (size - 1)),\n\t\t    \"size not a power of 2: %lu\", size);\n\treturn ((x + mask) & ~mask);\n}\n\nstatic inline uint64_t align_down(uint64_t x, uint64_t size)\n{\n\tuint64_t x_aligned_up = align_up(x, size);\n\n\tif (x == x_aligned_up)\n\t\treturn x;\n\telse\n\t\treturn x_aligned_up - size;\n}\n\nstatic inline void *align_ptr_up(void *x, size_t size)\n{\n\treturn (void *)align_up((unsigned long)x, size);\n}\n\nint atoi_paranoid(const char *num_str);\n\nstatic inline uint32_t atoi_positive(const char *name, const char *num_str)\n{\n\tint num = atoi_paranoid(num_str);\n\n\tTEST_ASSERT(num > 0, \"%s must be greater than 0, got '%s'\", name, num_str);\n\treturn num;\n}\n\nstatic inline uint32_t atoi_non_negative(const char *name, const char *num_str)\n{\n\tint num = atoi_paranoid(num_str);\n\n\tTEST_ASSERT(num >= 0, \"%s must be non-negative, got '%s'\", name, num_str);\n\treturn num;\n}\n\nint guest_vsnprintf(char *buf, int n, const char *fmt, va_list args);\nint guest_snprintf(char *buf, int n, const char *fmt, ...);\n\nchar *strdup_printf(const char *fmt, ...) __attribute__((format(printf, 1, 2), nonnull(1)));\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}