{
  "module_name": "kvm_util_base.h",
  "hash_id": "df6ec639fa9f78f85994e25f540b524ebc2e9673d3a3dd6948ae2641ae5ea861",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/include/kvm_util_base.h",
  "human_readable_source": " \n \n#ifndef SELFTEST_KVM_UTIL_BASE_H\n#define SELFTEST_KVM_UTIL_BASE_H\n\n#include \"test_util.h\"\n\n#include <linux/compiler.h>\n#include \"linux/hashtable.h\"\n#include \"linux/list.h\"\n#include <linux/kernel.h>\n#include <linux/kvm.h>\n#include \"linux/rbtree.h\"\n#include <linux/types.h>\n\n#include <asm/atomic.h>\n\n#include <sys/ioctl.h>\n\n#include \"sparsebit.h\"\n\n \n#define __kvm_static_assert(expr, msg, ...) _Static_assert(expr, msg)\n#define kvm_static_assert(expr, ...) __kvm_static_assert(expr, ##__VA_ARGS__, #expr)\n\n#define KVM_DEV_PATH \"/dev/kvm\"\n#define KVM_MAX_VCPUS 512\n\n#define NSEC_PER_SEC 1000000000L\n\ntypedef uint64_t vm_paddr_t;  \ntypedef uint64_t vm_vaddr_t;  \n\nstruct userspace_mem_region {\n\tstruct kvm_userspace_memory_region region;\n\tstruct sparsebit *unused_phy_pages;\n\tint fd;\n\toff_t offset;\n\tenum vm_mem_backing_src_type backing_src_type;\n\tvoid *host_mem;\n\tvoid *host_alias;\n\tvoid *mmap_start;\n\tvoid *mmap_alias;\n\tsize_t mmap_size;\n\tstruct rb_node gpa_node;\n\tstruct rb_node hva_node;\n\tstruct hlist_node slot_node;\n};\n\nstruct kvm_vcpu {\n\tstruct list_head list;\n\tuint32_t id;\n\tint fd;\n\tstruct kvm_vm *vm;\n\tstruct kvm_run *run;\n#ifdef __x86_64__\n\tstruct kvm_cpuid2 *cpuid;\n#endif\n\tstruct kvm_dirty_gfn *dirty_gfns;\n\tuint32_t fetch_index;\n\tuint32_t dirty_gfns_count;\n};\n\nstruct userspace_mem_regions {\n\tstruct rb_root gpa_tree;\n\tstruct rb_root hva_tree;\n\tDECLARE_HASHTABLE(slot_hash, 9);\n};\n\nenum kvm_mem_region_type {\n\tMEM_REGION_CODE,\n\tMEM_REGION_DATA,\n\tMEM_REGION_PT,\n\tMEM_REGION_TEST_DATA,\n\tNR_MEM_REGIONS,\n};\n\nstruct kvm_vm {\n\tint mode;\n\tunsigned long type;\n\tint kvm_fd;\n\tint fd;\n\tunsigned int pgtable_levels;\n\tunsigned int page_size;\n\tunsigned int page_shift;\n\tunsigned int pa_bits;\n\tunsigned int va_bits;\n\tuint64_t max_gfn;\n\tstruct list_head vcpus;\n\tstruct userspace_mem_regions regions;\n\tstruct sparsebit *vpages_valid;\n\tstruct sparsebit *vpages_mapped;\n\tbool has_irqchip;\n\tbool pgd_created;\n\tvm_paddr_t ucall_mmio_addr;\n\tvm_paddr_t pgd;\n\tvm_vaddr_t gdt;\n\tvm_vaddr_t tss;\n\tvm_vaddr_t idt;\n\tvm_vaddr_t handlers;\n\tuint32_t dirty_ring_size;\n\n\t \n\tint stats_fd;\n\tstruct kvm_stats_header stats_header;\n\tstruct kvm_stats_desc *stats_desc;\n\n\t \n\tuint32_t memslots[NR_MEM_REGIONS];\n};\n\nstruct vcpu_reg_sublist {\n\tconst char *name;\n\tlong capability;\n\tint feature;\n\tbool finalize;\n\t__u64 *regs;\n\t__u64 regs_n;\n\t__u64 *rejects_set;\n\t__u64 rejects_set_n;\n\t__u64 *skips_set;\n\t__u64 skips_set_n;\n};\n\nstruct vcpu_reg_list {\n\tchar *name;\n\tstruct vcpu_reg_sublist sublists[];\n};\n\n#define for_each_sublist(c, s)\t\t\\\n\tfor ((s) = &(c)->sublists[0]; (s)->regs; ++(s))\n\n#define kvm_for_each_vcpu(vm, i, vcpu)\t\t\t\\\n\tfor ((i) = 0; (i) <= (vm)->last_vcpu_id; (i)++)\t\\\n\t\tif (!((vcpu) = vm->vcpus[i]))\t\t\\\n\t\t\tcontinue;\t\t\t\\\n\t\telse\n\nstruct userspace_mem_region *\nmemslot2region(struct kvm_vm *vm, uint32_t memslot);\n\nstatic inline struct userspace_mem_region *vm_get_mem_region(struct kvm_vm *vm,\n\t\t\t\t\t\t\t     enum kvm_mem_region_type type)\n{\n\tassert(type < NR_MEM_REGIONS);\n\treturn memslot2region(vm, vm->memslots[type]);\n}\n\n \n#define KVM_UTIL_MIN_VADDR\t\t0x2000\n#define KVM_GUEST_PAGE_TABLE_MIN_PADDR\t0x180000\n\n#define DEFAULT_GUEST_STACK_VADDR_MIN\t0xab6000\n#define DEFAULT_STACK_PGS\t\t5\n\nenum vm_guest_mode {\n\tVM_MODE_P52V48_4K,\n\tVM_MODE_P52V48_64K,\n\tVM_MODE_P48V48_4K,\n\tVM_MODE_P48V48_16K,\n\tVM_MODE_P48V48_64K,\n\tVM_MODE_P40V48_4K,\n\tVM_MODE_P40V48_16K,\n\tVM_MODE_P40V48_64K,\n\tVM_MODE_PXXV48_4K,\t \n\tVM_MODE_P47V64_4K,\n\tVM_MODE_P44V64_4K,\n\tVM_MODE_P36V48_4K,\n\tVM_MODE_P36V48_16K,\n\tVM_MODE_P36V48_64K,\n\tVM_MODE_P36V47_16K,\n\tNUM_VM_MODES,\n};\n\n#if defined(__aarch64__)\n\nextern enum vm_guest_mode vm_mode_default;\n\n#define VM_MODE_DEFAULT\t\t\tvm_mode_default\n#define MIN_PAGE_SHIFT\t\t\t12U\n#define ptes_per_page(page_size)\t((page_size) / 8)\n\n#elif defined(__x86_64__)\n\n#define VM_MODE_DEFAULT\t\t\tVM_MODE_PXXV48_4K\n#define MIN_PAGE_SHIFT\t\t\t12U\n#define ptes_per_page(page_size)\t((page_size) / 8)\n\n#elif defined(__s390x__)\n\n#define VM_MODE_DEFAULT\t\t\tVM_MODE_P44V64_4K\n#define MIN_PAGE_SHIFT\t\t\t12U\n#define ptes_per_page(page_size)\t((page_size) / 16)\n\n#elif defined(__riscv)\n\n#if __riscv_xlen == 32\n#error \"RISC-V 32-bit kvm selftests not supported\"\n#endif\n\n#define VM_MODE_DEFAULT\t\t\tVM_MODE_P40V48_4K\n#define MIN_PAGE_SHIFT\t\t\t12U\n#define ptes_per_page(page_size)\t((page_size) / 8)\n\n#endif\n\n#define MIN_PAGE_SIZE\t\t(1U << MIN_PAGE_SHIFT)\n#define PTES_PER_MIN_PAGE\tptes_per_page(MIN_PAGE_SIZE)\n\nstruct vm_guest_mode_params {\n\tunsigned int pa_bits;\n\tunsigned int va_bits;\n\tunsigned int page_size;\n\tunsigned int page_shift;\n};\nextern const struct vm_guest_mode_params vm_guest_mode_params[];\n\nint open_path_or_exit(const char *path, int flags);\nint open_kvm_dev_path_or_exit(void);\n\nbool get_kvm_param_bool(const char *param);\nbool get_kvm_intel_param_bool(const char *param);\nbool get_kvm_amd_param_bool(const char *param);\n\nunsigned int kvm_check_cap(long cap);\n\nstatic inline bool kvm_has_cap(long cap)\n{\n\treturn kvm_check_cap(cap);\n}\n\n#define __KVM_SYSCALL_ERROR(_name, _ret) \\\n\t\"%s failed, rc: %i errno: %i (%s)\", (_name), (_ret), errno, strerror(errno)\n\n#define __KVM_IOCTL_ERROR(_name, _ret)\t__KVM_SYSCALL_ERROR(_name, _ret)\n#define KVM_IOCTL_ERROR(_ioctl, _ret) __KVM_IOCTL_ERROR(#_ioctl, _ret)\n\n#define kvm_do_ioctl(fd, cmd, arg)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tkvm_static_assert(!_IOC_SIZE(cmd) || sizeof(*arg) == _IOC_SIZE(cmd));\t\\\n\tioctl(fd, cmd, arg);\t\t\t\t\t\t\t\\\n})\n\n#define __kvm_ioctl(kvm_fd, cmd, arg)\t\t\t\t\\\n\tkvm_do_ioctl(kvm_fd, cmd, arg)\n\n\n#define _kvm_ioctl(kvm_fd, cmd, name, arg)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tint ret = __kvm_ioctl(kvm_fd, cmd, arg);\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tTEST_ASSERT(!ret, __KVM_IOCTL_ERROR(name, ret));\t\\\n})\n\n#define kvm_ioctl(kvm_fd, cmd, arg) \\\n\t_kvm_ioctl(kvm_fd, cmd, #cmd, arg)\n\nstatic __always_inline void static_assert_is_vm(struct kvm_vm *vm) { }\n\n#define __vm_ioctl(vm, cmd, arg)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic_assert_is_vm(vm);\t\t\t\t\\\n\tkvm_do_ioctl((vm)->fd, cmd, arg);\t\t\t\\\n})\n\n#define _vm_ioctl(vm, cmd, name, arg)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tint ret = __vm_ioctl(vm, cmd, arg);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tTEST_ASSERT(!ret, __KVM_IOCTL_ERROR(name, ret));\t\\\n})\n\n#define vm_ioctl(vm, cmd, arg)\t\t\t\t\t\\\n\t_vm_ioctl(vm, cmd, #cmd, arg)\n\n\nstatic __always_inline void static_assert_is_vcpu(struct kvm_vcpu *vcpu) { }\n\n#define __vcpu_ioctl(vcpu, cmd, arg)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic_assert_is_vcpu(vcpu);\t\t\t\t\\\n\tkvm_do_ioctl((vcpu)->fd, cmd, arg);\t\t\t\\\n})\n\n#define _vcpu_ioctl(vcpu, cmd, name, arg)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tint ret = __vcpu_ioctl(vcpu, cmd, arg);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tTEST_ASSERT(!ret, __KVM_IOCTL_ERROR(name, ret));\t\\\n})\n\n#define vcpu_ioctl(vcpu, cmd, arg)\t\t\t\t\\\n\t_vcpu_ioctl(vcpu, cmd, #cmd, arg)\n\n \nstatic inline int vm_check_cap(struct kvm_vm *vm, long cap)\n{\n\tint ret =  __vm_ioctl(vm, KVM_CHECK_EXTENSION, (void *)cap);\n\n\tTEST_ASSERT(ret >= 0, KVM_IOCTL_ERROR(KVM_CHECK_EXTENSION, ret));\n\treturn ret;\n}\n\nstatic inline int __vm_enable_cap(struct kvm_vm *vm, uint32_t cap, uint64_t arg0)\n{\n\tstruct kvm_enable_cap enable_cap = { .cap = cap, .args = { arg0 } };\n\n\treturn __vm_ioctl(vm, KVM_ENABLE_CAP, &enable_cap);\n}\nstatic inline void vm_enable_cap(struct kvm_vm *vm, uint32_t cap, uint64_t arg0)\n{\n\tstruct kvm_enable_cap enable_cap = { .cap = cap, .args = { arg0 } };\n\n\tvm_ioctl(vm, KVM_ENABLE_CAP, &enable_cap);\n}\n\nvoid vm_enable_dirty_ring(struct kvm_vm *vm, uint32_t ring_size);\nconst char *vm_guest_mode_string(uint32_t i);\n\nvoid kvm_vm_free(struct kvm_vm *vmp);\nvoid kvm_vm_restart(struct kvm_vm *vmp);\nvoid kvm_vm_release(struct kvm_vm *vmp);\nint kvm_memcmp_hva_gva(void *hva, struct kvm_vm *vm, const vm_vaddr_t gva,\n\t\t       size_t len);\nvoid kvm_vm_elf_load(struct kvm_vm *vm, const char *filename);\nint kvm_memfd_alloc(size_t size, bool hugepages);\n\nvoid vm_dump(FILE *stream, struct kvm_vm *vm, uint8_t indent);\n\nstatic inline void kvm_vm_get_dirty_log(struct kvm_vm *vm, int slot, void *log)\n{\n\tstruct kvm_dirty_log args = { .dirty_bitmap = log, .slot = slot };\n\n\tvm_ioctl(vm, KVM_GET_DIRTY_LOG, &args);\n}\n\nstatic inline void kvm_vm_clear_dirty_log(struct kvm_vm *vm, int slot, void *log,\n\t\t\t\t\t  uint64_t first_page, uint32_t num_pages)\n{\n\tstruct kvm_clear_dirty_log args = {\n\t\t.dirty_bitmap = log,\n\t\t.slot = slot,\n\t\t.first_page = first_page,\n\t\t.num_pages = num_pages\n\t};\n\n\tvm_ioctl(vm, KVM_CLEAR_DIRTY_LOG, &args);\n}\n\nstatic inline uint32_t kvm_vm_reset_dirty_ring(struct kvm_vm *vm)\n{\n\treturn __vm_ioctl(vm, KVM_RESET_DIRTY_RINGS, NULL);\n}\n\nstatic inline int vm_get_stats_fd(struct kvm_vm *vm)\n{\n\tint fd = __vm_ioctl(vm, KVM_GET_STATS_FD, NULL);\n\n\tTEST_ASSERT(fd >= 0, KVM_IOCTL_ERROR(KVM_GET_STATS_FD, fd));\n\treturn fd;\n}\n\nstatic inline void read_stats_header(int stats_fd, struct kvm_stats_header *header)\n{\n\tssize_t ret;\n\n\tret = pread(stats_fd, header, sizeof(*header), 0);\n\tTEST_ASSERT(ret == sizeof(*header),\n\t\t    \"Failed to read '%lu' header bytes, ret = '%ld'\",\n\t\t    sizeof(*header), ret);\n}\n\nstruct kvm_stats_desc *read_stats_descriptors(int stats_fd,\n\t\t\t\t\t      struct kvm_stats_header *header);\n\nstatic inline ssize_t get_stats_descriptor_size(struct kvm_stats_header *header)\n{\n\t  \n\treturn sizeof(struct kvm_stats_desc) + header->name_size;\n}\n\nstatic inline struct kvm_stats_desc *get_stats_descriptor(struct kvm_stats_desc *stats,\n\t\t\t\t\t\t\t  int index,\n\t\t\t\t\t\t\t  struct kvm_stats_header *header)\n{\n\t \n\treturn (void *)stats + index * get_stats_descriptor_size(header);\n}\n\nvoid read_stat_data(int stats_fd, struct kvm_stats_header *header,\n\t\t    struct kvm_stats_desc *desc, uint64_t *data,\n\t\t    size_t max_elements);\n\nvoid __vm_get_stat(struct kvm_vm *vm, const char *stat_name, uint64_t *data,\n\t\t   size_t max_elements);\n\nstatic inline uint64_t vm_get_stat(struct kvm_vm *vm, const char *stat_name)\n{\n\tuint64_t data;\n\n\t__vm_get_stat(vm, stat_name, &data, 1);\n\treturn data;\n}\n\nvoid vm_create_irqchip(struct kvm_vm *vm);\n\nvoid vm_set_user_memory_region(struct kvm_vm *vm, uint32_t slot, uint32_t flags,\n\t\t\t       uint64_t gpa, uint64_t size, void *hva);\nint __vm_set_user_memory_region(struct kvm_vm *vm, uint32_t slot, uint32_t flags,\n\t\t\t\tuint64_t gpa, uint64_t size, void *hva);\nvoid vm_userspace_mem_region_add(struct kvm_vm *vm,\n\tenum vm_mem_backing_src_type src_type,\n\tuint64_t guest_paddr, uint32_t slot, uint64_t npages,\n\tuint32_t flags);\n\nvoid vm_mem_region_set_flags(struct kvm_vm *vm, uint32_t slot, uint32_t flags);\nvoid vm_mem_region_move(struct kvm_vm *vm, uint32_t slot, uint64_t new_gpa);\nvoid vm_mem_region_delete(struct kvm_vm *vm, uint32_t slot);\nstruct kvm_vcpu *__vm_vcpu_add(struct kvm_vm *vm, uint32_t vcpu_id);\nvoid vm_populate_vaddr_bitmap(struct kvm_vm *vm);\nvm_vaddr_t vm_vaddr_unused_gap(struct kvm_vm *vm, size_t sz, vm_vaddr_t vaddr_min);\nvm_vaddr_t vm_vaddr_alloc(struct kvm_vm *vm, size_t sz, vm_vaddr_t vaddr_min);\nvm_vaddr_t __vm_vaddr_alloc(struct kvm_vm *vm, size_t sz, vm_vaddr_t vaddr_min,\n\t\t\t    enum kvm_mem_region_type type);\nvm_vaddr_t vm_vaddr_alloc_pages(struct kvm_vm *vm, int nr_pages);\nvm_vaddr_t __vm_vaddr_alloc_page(struct kvm_vm *vm,\n\t\t\t\t enum kvm_mem_region_type type);\nvm_vaddr_t vm_vaddr_alloc_page(struct kvm_vm *vm);\n\nvoid virt_map(struct kvm_vm *vm, uint64_t vaddr, uint64_t paddr,\n\t      unsigned int npages);\nvoid *addr_gpa2hva(struct kvm_vm *vm, vm_paddr_t gpa);\nvoid *addr_gva2hva(struct kvm_vm *vm, vm_vaddr_t gva);\nvm_paddr_t addr_hva2gpa(struct kvm_vm *vm, void *hva);\nvoid *addr_gpa2alias(struct kvm_vm *vm, vm_paddr_t gpa);\n\nvoid vcpu_run(struct kvm_vcpu *vcpu);\nint _vcpu_run(struct kvm_vcpu *vcpu);\n\nstatic inline int __vcpu_run(struct kvm_vcpu *vcpu)\n{\n\treturn __vcpu_ioctl(vcpu, KVM_RUN, NULL);\n}\n\nvoid vcpu_run_complete_io(struct kvm_vcpu *vcpu);\nstruct kvm_reg_list *vcpu_get_reg_list(struct kvm_vcpu *vcpu);\n\nstatic inline void vcpu_enable_cap(struct kvm_vcpu *vcpu, uint32_t cap,\n\t\t\t\t   uint64_t arg0)\n{\n\tstruct kvm_enable_cap enable_cap = { .cap = cap, .args = { arg0 } };\n\n\tvcpu_ioctl(vcpu, KVM_ENABLE_CAP, &enable_cap);\n}\n\nstatic inline void vcpu_guest_debug_set(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *debug)\n{\n\tvcpu_ioctl(vcpu, KVM_SET_GUEST_DEBUG, debug);\n}\n\nstatic inline void vcpu_mp_state_get(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_mp_state *mp_state)\n{\n\tvcpu_ioctl(vcpu, KVM_GET_MP_STATE, mp_state);\n}\nstatic inline void vcpu_mp_state_set(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_mp_state *mp_state)\n{\n\tvcpu_ioctl(vcpu, KVM_SET_MP_STATE, mp_state);\n}\n\nstatic inline void vcpu_regs_get(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu_ioctl(vcpu, KVM_GET_REGS, regs);\n}\n\nstatic inline void vcpu_regs_set(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu_ioctl(vcpu, KVM_SET_REGS, regs);\n}\nstatic inline void vcpu_sregs_get(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\tvcpu_ioctl(vcpu, KVM_GET_SREGS, sregs);\n\n}\nstatic inline void vcpu_sregs_set(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\tvcpu_ioctl(vcpu, KVM_SET_SREGS, sregs);\n}\nstatic inline int _vcpu_sregs_set(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\treturn __vcpu_ioctl(vcpu, KVM_SET_SREGS, sregs);\n}\nstatic inline void vcpu_fpu_get(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tvcpu_ioctl(vcpu, KVM_GET_FPU, fpu);\n}\nstatic inline void vcpu_fpu_set(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tvcpu_ioctl(vcpu, KVM_SET_FPU, fpu);\n}\n\nstatic inline int __vcpu_get_reg(struct kvm_vcpu *vcpu, uint64_t id, void *addr)\n{\n\tstruct kvm_one_reg reg = { .id = id, .addr = (uint64_t)addr };\n\n\treturn __vcpu_ioctl(vcpu, KVM_GET_ONE_REG, &reg);\n}\nstatic inline int __vcpu_set_reg(struct kvm_vcpu *vcpu, uint64_t id, uint64_t val)\n{\n\tstruct kvm_one_reg reg = { .id = id, .addr = (uint64_t)&val };\n\n\treturn __vcpu_ioctl(vcpu, KVM_SET_ONE_REG, &reg);\n}\nstatic inline void vcpu_get_reg(struct kvm_vcpu *vcpu, uint64_t id, void *addr)\n{\n\tstruct kvm_one_reg reg = { .id = id, .addr = (uint64_t)addr };\n\n\tvcpu_ioctl(vcpu, KVM_GET_ONE_REG, &reg);\n}\nstatic inline void vcpu_set_reg(struct kvm_vcpu *vcpu, uint64_t id, uint64_t val)\n{\n\tstruct kvm_one_reg reg = { .id = id, .addr = (uint64_t)&val };\n\n\tvcpu_ioctl(vcpu, KVM_SET_ONE_REG, &reg);\n}\n\n#ifdef __KVM_HAVE_VCPU_EVENTS\nstatic inline void vcpu_events_get(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_vcpu_events *events)\n{\n\tvcpu_ioctl(vcpu, KVM_GET_VCPU_EVENTS, events);\n}\nstatic inline void vcpu_events_set(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_vcpu_events *events)\n{\n\tvcpu_ioctl(vcpu, KVM_SET_VCPU_EVENTS, events);\n}\n#endif\n#ifdef __x86_64__\nstatic inline void vcpu_nested_state_get(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_nested_state *state)\n{\n\tvcpu_ioctl(vcpu, KVM_GET_NESTED_STATE, state);\n}\nstatic inline int __vcpu_nested_state_set(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  struct kvm_nested_state *state)\n{\n\treturn __vcpu_ioctl(vcpu, KVM_SET_NESTED_STATE, state);\n}\n\nstatic inline void vcpu_nested_state_set(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_nested_state *state)\n{\n\tvcpu_ioctl(vcpu, KVM_SET_NESTED_STATE, state);\n}\n#endif\nstatic inline int vcpu_get_stats_fd(struct kvm_vcpu *vcpu)\n{\n\tint fd = __vcpu_ioctl(vcpu, KVM_GET_STATS_FD, NULL);\n\n\tTEST_ASSERT(fd >= 0, KVM_IOCTL_ERROR(KVM_GET_STATS_FD, fd));\n\treturn fd;\n}\n\nint __kvm_has_device_attr(int dev_fd, uint32_t group, uint64_t attr);\n\nstatic inline void kvm_has_device_attr(int dev_fd, uint32_t group, uint64_t attr)\n{\n\tint ret = __kvm_has_device_attr(dev_fd, group, attr);\n\n\tTEST_ASSERT(!ret, \"KVM_HAS_DEVICE_ATTR failed, rc: %i errno: %i\", ret, errno);\n}\n\nint __kvm_device_attr_get(int dev_fd, uint32_t group, uint64_t attr, void *val);\n\nstatic inline void kvm_device_attr_get(int dev_fd, uint32_t group,\n\t\t\t\t       uint64_t attr, void *val)\n{\n\tint ret = __kvm_device_attr_get(dev_fd, group, attr, val);\n\n\tTEST_ASSERT(!ret, KVM_IOCTL_ERROR(KVM_GET_DEVICE_ATTR, ret));\n}\n\nint __kvm_device_attr_set(int dev_fd, uint32_t group, uint64_t attr, void *val);\n\nstatic inline void kvm_device_attr_set(int dev_fd, uint32_t group,\n\t\t\t\t       uint64_t attr, void *val)\n{\n\tint ret = __kvm_device_attr_set(dev_fd, group, attr, val);\n\n\tTEST_ASSERT(!ret, KVM_IOCTL_ERROR(KVM_SET_DEVICE_ATTR, ret));\n}\n\nstatic inline int __vcpu_has_device_attr(struct kvm_vcpu *vcpu, uint32_t group,\n\t\t\t\t\t uint64_t attr)\n{\n\treturn __kvm_has_device_attr(vcpu->fd, group, attr);\n}\n\nstatic inline void vcpu_has_device_attr(struct kvm_vcpu *vcpu, uint32_t group,\n\t\t\t\t\tuint64_t attr)\n{\n\tkvm_has_device_attr(vcpu->fd, group, attr);\n}\n\nstatic inline int __vcpu_device_attr_get(struct kvm_vcpu *vcpu, uint32_t group,\n\t\t\t\t\t uint64_t attr, void *val)\n{\n\treturn __kvm_device_attr_get(vcpu->fd, group, attr, val);\n}\n\nstatic inline void vcpu_device_attr_get(struct kvm_vcpu *vcpu, uint32_t group,\n\t\t\t\t\tuint64_t attr, void *val)\n{\n\tkvm_device_attr_get(vcpu->fd, group, attr, val);\n}\n\nstatic inline int __vcpu_device_attr_set(struct kvm_vcpu *vcpu, uint32_t group,\n\t\t\t\t\t uint64_t attr, void *val)\n{\n\treturn __kvm_device_attr_set(vcpu->fd, group, attr, val);\n}\n\nstatic inline void vcpu_device_attr_set(struct kvm_vcpu *vcpu, uint32_t group,\n\t\t\t\t\tuint64_t attr, void *val)\n{\n\tkvm_device_attr_set(vcpu->fd, group, attr, val);\n}\n\nint __kvm_test_create_device(struct kvm_vm *vm, uint64_t type);\nint __kvm_create_device(struct kvm_vm *vm, uint64_t type);\n\nstatic inline int kvm_create_device(struct kvm_vm *vm, uint64_t type)\n{\n\tint fd = __kvm_create_device(vm, type);\n\n\tTEST_ASSERT(fd >= 0, KVM_IOCTL_ERROR(KVM_CREATE_DEVICE, fd));\n\treturn fd;\n}\n\nvoid *vcpu_map_dirty_ring(struct kvm_vcpu *vcpu);\n\n \nvoid vcpu_args_set(struct kvm_vcpu *vcpu, unsigned int num, ...);\n\nvoid kvm_irq_line(struct kvm_vm *vm, uint32_t irq, int level);\nint _kvm_irq_line(struct kvm_vm *vm, uint32_t irq, int level);\n\n#define KVM_MAX_IRQ_ROUTES\t\t4096\n\nstruct kvm_irq_routing *kvm_gsi_routing_create(void);\nvoid kvm_gsi_routing_irqchip_add(struct kvm_irq_routing *routing,\n\t\tuint32_t gsi, uint32_t pin);\nint _kvm_gsi_routing_write(struct kvm_vm *vm, struct kvm_irq_routing *routing);\nvoid kvm_gsi_routing_write(struct kvm_vm *vm, struct kvm_irq_routing *routing);\n\nconst char *exit_reason_str(unsigned int exit_reason);\n\nvm_paddr_t vm_phy_page_alloc(struct kvm_vm *vm, vm_paddr_t paddr_min,\n\t\t\t     uint32_t memslot);\nvm_paddr_t vm_phy_pages_alloc(struct kvm_vm *vm, size_t num,\n\t\t\t      vm_paddr_t paddr_min, uint32_t memslot);\nvm_paddr_t vm_alloc_page_table(struct kvm_vm *vm);\n\n \nstruct kvm_vm *____vm_create(enum vm_guest_mode mode);\nstruct kvm_vm *__vm_create(enum vm_guest_mode mode, uint32_t nr_runnable_vcpus,\n\t\t\t   uint64_t nr_extra_pages);\n\nstatic inline struct kvm_vm *vm_create_barebones(void)\n{\n\treturn ____vm_create(VM_MODE_DEFAULT);\n}\n\nstatic inline struct kvm_vm *vm_create(uint32_t nr_runnable_vcpus)\n{\n\treturn __vm_create(VM_MODE_DEFAULT, nr_runnable_vcpus, 0);\n}\n\nstruct kvm_vm *__vm_create_with_vcpus(enum vm_guest_mode mode, uint32_t nr_vcpus,\n\t\t\t\t      uint64_t extra_mem_pages,\n\t\t\t\t      void *guest_code, struct kvm_vcpu *vcpus[]);\n\nstatic inline struct kvm_vm *vm_create_with_vcpus(uint32_t nr_vcpus,\n\t\t\t\t\t\t  void *guest_code,\n\t\t\t\t\t\t  struct kvm_vcpu *vcpus[])\n{\n\treturn __vm_create_with_vcpus(VM_MODE_DEFAULT, nr_vcpus, 0,\n\t\t\t\t      guest_code, vcpus);\n}\n\n \nstruct kvm_vm *__vm_create_with_one_vcpu(struct kvm_vcpu **vcpu,\n\t\t\t\t\t uint64_t extra_mem_pages,\n\t\t\t\t\t void *guest_code);\n\nstatic inline struct kvm_vm *vm_create_with_one_vcpu(struct kvm_vcpu **vcpu,\n\t\t\t\t\t\t     void *guest_code)\n{\n\treturn __vm_create_with_one_vcpu(vcpu, 0, guest_code);\n}\n\nstruct kvm_vcpu *vm_recreate_with_one_vcpu(struct kvm_vm *vm);\n\nvoid kvm_pin_this_task_to_pcpu(uint32_t pcpu);\nvoid kvm_print_vcpu_pinning_help(void);\nvoid kvm_parse_vcpu_pinning(const char *pcpus_string, uint32_t vcpu_to_pcpu[],\n\t\t\t    int nr_vcpus);\n\nunsigned long vm_compute_max_gfn(struct kvm_vm *vm);\nunsigned int vm_calc_num_guest_pages(enum vm_guest_mode mode, size_t size);\nunsigned int vm_num_host_pages(enum vm_guest_mode mode, unsigned int num_guest_pages);\nunsigned int vm_num_guest_pages(enum vm_guest_mode mode, unsigned int num_host_pages);\nstatic inline unsigned int\nvm_adjust_num_guest_pages(enum vm_guest_mode mode, unsigned int num_guest_pages)\n{\n\tunsigned int n;\n\tn = vm_num_guest_pages(mode, vm_num_host_pages(mode, num_guest_pages));\n#ifdef __s390x__\n\t \n\tn = (n + 255) & ~255;\n#endif\n\treturn n;\n}\n\nstruct kvm_userspace_memory_region *\nkvm_userspace_memory_region_find(struct kvm_vm *vm, uint64_t start,\n\t\t\t\t uint64_t end);\n\n#define sync_global_to_guest(vm, g) ({\t\t\t\t\\\n\ttypeof(g) *_p = addr_gva2hva(vm, (vm_vaddr_t)&(g));\t\\\n\tmemcpy(_p, &(g), sizeof(g));\t\t\t\t\\\n})\n\n#define sync_global_from_guest(vm, g) ({\t\t\t\\\n\ttypeof(g) *_p = addr_gva2hva(vm, (vm_vaddr_t)&(g));\t\\\n\tmemcpy(&(g), _p, sizeof(g));\t\t\t\t\\\n})\n\n \n#define write_guest_global(vm, g, val) ({\t\t\t\\\n\ttypeof(g) *_p = addr_gva2hva(vm, (vm_vaddr_t)&(g));\t\\\n\ttypeof(g) _val = val;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tmemcpy(_p, &(_val), sizeof(g));\t\t\t\t\\\n})\n\nvoid assert_on_unhandled_exception(struct kvm_vcpu *vcpu);\n\nvoid vcpu_arch_dump(FILE *stream, struct kvm_vcpu *vcpu,\n\t\t    uint8_t indent);\n\nstatic inline void vcpu_dump(FILE *stream, struct kvm_vcpu *vcpu,\n\t\t\t     uint8_t indent)\n{\n\tvcpu_arch_dump(stream, vcpu, indent);\n}\n\n \nstruct kvm_vcpu *vm_arch_vcpu_add(struct kvm_vm *vm, uint32_t vcpu_id,\n\t\t\t\t  void *guest_code);\n\nstatic inline struct kvm_vcpu *vm_vcpu_add(struct kvm_vm *vm, uint32_t vcpu_id,\n\t\t\t\t\t   void *guest_code)\n{\n\treturn vm_arch_vcpu_add(vm, vcpu_id, guest_code);\n}\n\n \nstruct kvm_vcpu *vm_arch_vcpu_recreate(struct kvm_vm *vm, uint32_t vcpu_id);\n\nstatic inline struct kvm_vcpu *vm_vcpu_recreate(struct kvm_vm *vm,\n\t\t\t\t\t\tuint32_t vcpu_id)\n{\n\treturn vm_arch_vcpu_recreate(vm, vcpu_id);\n}\n\nvoid vcpu_arch_free(struct kvm_vcpu *vcpu);\n\nvoid virt_arch_pgd_alloc(struct kvm_vm *vm);\n\nstatic inline void virt_pgd_alloc(struct kvm_vm *vm)\n{\n\tvirt_arch_pgd_alloc(vm);\n}\n\n \nvoid virt_arch_pg_map(struct kvm_vm *vm, uint64_t vaddr, uint64_t paddr);\n\nstatic inline void virt_pg_map(struct kvm_vm *vm, uint64_t vaddr, uint64_t paddr)\n{\n\tvirt_arch_pg_map(vm, vaddr, paddr);\n}\n\n\n \nvm_paddr_t addr_arch_gva2gpa(struct kvm_vm *vm, vm_vaddr_t gva);\n\nstatic inline vm_paddr_t addr_gva2gpa(struct kvm_vm *vm, vm_vaddr_t gva)\n{\n\treturn addr_arch_gva2gpa(vm, gva);\n}\n\n \nvoid virt_arch_dump(FILE *stream, struct kvm_vm *vm, uint8_t indent);\n\nstatic inline void virt_dump(FILE *stream, struct kvm_vm *vm, uint8_t indent)\n{\n\tvirt_arch_dump(stream, vm, indent);\n}\n\n\nstatic inline int __vm_disable_nx_huge_pages(struct kvm_vm *vm)\n{\n\treturn __vm_enable_cap(vm, KVM_CAP_VM_DISABLE_NX_HUGE_PAGES, 0);\n}\n\n \nvoid kvm_selftest_arch_init(void);\n\nvoid kvm_arch_vm_post_create(struct kvm_vm *vm);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}