{
  "module_name": "steal_time.c",
  "hash_id": "383f3658abbfa3719be37422f18c7fddcce33e1338182f1650919885423e6fec",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/steal_time.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <stdio.h>\n#include <time.h>\n#include <sched.h>\n#include <pthread.h>\n#include <linux/kernel.h>\n#include <asm/kvm.h>\n#include <asm/kvm_para.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n#define NR_VCPUS\t\t4\n#define ST_GPA_BASE\t\t(1 << 30)\n\nstatic void *st_gva[NR_VCPUS];\nstatic uint64_t guest_stolen_time[NR_VCPUS];\n\n#if defined(__x86_64__)\n\n \n#define STEAL_TIME_SIZE\t\t((sizeof(struct kvm_steal_time) + 63) & ~63)\n\nstatic void check_status(struct kvm_steal_time *st)\n{\n\tGUEST_ASSERT(!(READ_ONCE(st->version) & 1));\n\tGUEST_ASSERT_EQ(READ_ONCE(st->flags), 0);\n\tGUEST_ASSERT_EQ(READ_ONCE(st->preempted), 0);\n}\n\nstatic void guest_code(int cpu)\n{\n\tstruct kvm_steal_time *st = st_gva[cpu];\n\tuint32_t version;\n\n\tGUEST_ASSERT_EQ(rdmsr(MSR_KVM_STEAL_TIME), ((uint64_t)st_gva[cpu] | KVM_MSR_ENABLED));\n\n\tmemset(st, 0, sizeof(*st));\n\tGUEST_SYNC(0);\n\n\tcheck_status(st);\n\tWRITE_ONCE(guest_stolen_time[cpu], st->steal);\n\tversion = READ_ONCE(st->version);\n\tcheck_status(st);\n\tGUEST_SYNC(1);\n\n\tcheck_status(st);\n\tGUEST_ASSERT(version < READ_ONCE(st->version));\n\tWRITE_ONCE(guest_stolen_time[cpu], st->steal);\n\tcheck_status(st);\n\tGUEST_DONE();\n}\n\nstatic bool is_steal_time_supported(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_cpu_has(X86_FEATURE_KVM_STEAL_TIME);\n}\n\nstatic void steal_time_init(struct kvm_vcpu *vcpu, uint32_t i)\n{\n\tint ret;\n\n\t \n\tst_gva[i] = (void *)(ST_GPA_BASE + i * STEAL_TIME_SIZE);\n\tsync_global_to_guest(vcpu->vm, st_gva[i]);\n\n\tret = _vcpu_set_msr(vcpu, MSR_KVM_STEAL_TIME,\n\t\t\t    (ulong)st_gva[i] | KVM_STEAL_RESERVED_MASK);\n\tTEST_ASSERT(ret == 0, \"Bad GPA didn't fail\");\n\n\tvcpu_set_msr(vcpu, MSR_KVM_STEAL_TIME, (ulong)st_gva[i] | KVM_MSR_ENABLED);\n}\n\nstatic void steal_time_dump(struct kvm_vm *vm, uint32_t vcpu_idx)\n{\n\tstruct kvm_steal_time *st = addr_gva2hva(vm, (ulong)st_gva[vcpu_idx]);\n\tint i;\n\n\tpr_info(\"VCPU%d:\\n\", vcpu_idx);\n\tpr_info(\"    steal:     %lld\\n\", st->steal);\n\tpr_info(\"    version:   %d\\n\", st->version);\n\tpr_info(\"    flags:     %d\\n\", st->flags);\n\tpr_info(\"    preempted: %d\\n\", st->preempted);\n\tpr_info(\"    u8_pad:    \");\n\tfor (i = 0; i < 3; ++i)\n\t\tpr_info(\"%d\", st->u8_pad[i]);\n\tpr_info(\"\\n    pad:       \");\n\tfor (i = 0; i < 11; ++i)\n\t\tpr_info(\"%d\", st->pad[i]);\n\tpr_info(\"\\n\");\n}\n\n#elif defined(__aarch64__)\n\n \n#define STEAL_TIME_SIZE\t\t((sizeof(struct st_time) + 63) & ~63)\n\n#define SMCCC_ARCH_FEATURES\t0x80000001\n#define PV_TIME_FEATURES\t0xc5000020\n#define PV_TIME_ST\t\t0xc5000021\n\nstruct st_time {\n\tuint32_t rev;\n\tuint32_t attr;\n\tuint64_t st_time;\n};\n\nstatic int64_t smccc(uint32_t func, uint64_t arg)\n{\n\tstruct arm_smccc_res res;\n\n\tsmccc_hvc(func, arg, 0, 0, 0, 0, 0, 0, &res);\n\treturn res.a0;\n}\n\nstatic void check_status(struct st_time *st)\n{\n\tGUEST_ASSERT_EQ(READ_ONCE(st->rev), 0);\n\tGUEST_ASSERT_EQ(READ_ONCE(st->attr), 0);\n}\n\nstatic void guest_code(int cpu)\n{\n\tstruct st_time *st;\n\tint64_t status;\n\n\tstatus = smccc(SMCCC_ARCH_FEATURES, PV_TIME_FEATURES);\n\tGUEST_ASSERT_EQ(status, 0);\n\tstatus = smccc(PV_TIME_FEATURES, PV_TIME_FEATURES);\n\tGUEST_ASSERT_EQ(status, 0);\n\tstatus = smccc(PV_TIME_FEATURES, PV_TIME_ST);\n\tGUEST_ASSERT_EQ(status, 0);\n\n\tstatus = smccc(PV_TIME_ST, 0);\n\tGUEST_ASSERT_NE(status, -1);\n\tGUEST_ASSERT_EQ(status, (ulong)st_gva[cpu]);\n\n\tst = (struct st_time *)status;\n\tGUEST_SYNC(0);\n\n\tcheck_status(st);\n\tWRITE_ONCE(guest_stolen_time[cpu], st->st_time);\n\tGUEST_SYNC(1);\n\n\tcheck_status(st);\n\tWRITE_ONCE(guest_stolen_time[cpu], st->st_time);\n\tGUEST_DONE();\n}\n\nstatic bool is_steal_time_supported(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_device_attr dev = {\n\t\t.group = KVM_ARM_VCPU_PVTIME_CTRL,\n\t\t.attr = KVM_ARM_VCPU_PVTIME_IPA,\n\t};\n\n\treturn !__vcpu_ioctl(vcpu, KVM_HAS_DEVICE_ATTR, &dev);\n}\n\nstatic void steal_time_init(struct kvm_vcpu *vcpu, uint32_t i)\n{\n\tstruct kvm_vm *vm = vcpu->vm;\n\tuint64_t st_ipa;\n\tint ret;\n\n\tstruct kvm_device_attr dev = {\n\t\t.group = KVM_ARM_VCPU_PVTIME_CTRL,\n\t\t.attr = KVM_ARM_VCPU_PVTIME_IPA,\n\t\t.addr = (uint64_t)&st_ipa,\n\t};\n\n\tvcpu_ioctl(vcpu, KVM_HAS_DEVICE_ATTR, &dev);\n\n\t \n\tst_gva[i] = (void *)(ST_GPA_BASE + i * STEAL_TIME_SIZE);\n\tsync_global_to_guest(vm, st_gva[i]);\n\n\tst_ipa = (ulong)st_gva[i] | 1;\n\tret = __vcpu_ioctl(vcpu, KVM_SET_DEVICE_ATTR, &dev);\n\tTEST_ASSERT(ret == -1 && errno == EINVAL, \"Bad IPA didn't report EINVAL\");\n\n\tst_ipa = (ulong)st_gva[i];\n\tvcpu_ioctl(vcpu, KVM_SET_DEVICE_ATTR, &dev);\n\n\tret = __vcpu_ioctl(vcpu, KVM_SET_DEVICE_ATTR, &dev);\n\tTEST_ASSERT(ret == -1 && errno == EEXIST, \"Set IPA twice without EEXIST\");\n}\n\nstatic void steal_time_dump(struct kvm_vm *vm, uint32_t vcpu_idx)\n{\n\tstruct st_time *st = addr_gva2hva(vm, (ulong)st_gva[vcpu_idx]);\n\n\tpr_info(\"VCPU%d:\\n\", vcpu_idx);\n\tpr_info(\"    rev:     %d\\n\", st->rev);\n\tpr_info(\"    attr:    %d\\n\", st->attr);\n\tpr_info(\"    st_time: %ld\\n\", st->st_time);\n}\n\n#endif\n\nstatic void *do_steal_time(void *arg)\n{\n\tstruct timespec ts, stop;\n\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\tstop = timespec_add_ns(ts, MIN_RUN_DELAY_NS);\n\n\twhile (1) {\n\t\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\t\tif (timespec_to_ns(timespec_sub(ts, stop)) >= 0)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic void run_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct ucall uc;\n\n\tvcpu_run(vcpu);\n\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_SYNC:\n\tcase UCALL_DONE:\n\t\tbreak;\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\tdefault:\n\t\tTEST_ASSERT(false, \"Unexpected exit: %s\",\n\t\t\t    exit_reason_str(vcpu->run->exit_reason));\n\t}\n}\n\nint main(int ac, char **av)\n{\n\tstruct kvm_vcpu *vcpus[NR_VCPUS];\n\tstruct kvm_vm *vm;\n\tpthread_attr_t attr;\n\tpthread_t thread;\n\tcpu_set_t cpuset;\n\tunsigned int gpages;\n\tlong stolen_time;\n\tlong run_delay;\n\tbool verbose;\n\tint i;\n\n\tverbose = ac > 1 && (!strncmp(av[1], \"-v\", 3) || !strncmp(av[1], \"--verbose\", 10));\n\n\t \n\tCPU_ZERO(&cpuset);\n\tCPU_SET(0, &cpuset);\n\tpthread_attr_init(&attr);\n\tpthread_attr_setaffinity_np(&attr, sizeof(cpu_set_t), &cpuset);\n\tpthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset);\n\n\t \n\tvm = vm_create_with_vcpus(NR_VCPUS, guest_code, vcpus);\n\tgpages = vm_calc_num_guest_pages(VM_MODE_DEFAULT, STEAL_TIME_SIZE * NR_VCPUS);\n\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS, ST_GPA_BASE, 1, gpages, 0);\n\tvirt_map(vm, ST_GPA_BASE, ST_GPA_BASE, gpages);\n\n\tTEST_REQUIRE(is_steal_time_supported(vcpus[0]));\n\n\t \n\tfor (i = 0; i < NR_VCPUS; ++i) {\n\t\tsteal_time_init(vcpus[i], i);\n\n\t\tvcpu_args_set(vcpus[i], 1, i);\n\n\t\t \n\t\trun_vcpu(vcpus[i]);\n\n\t\t \n\t\trun_vcpu(vcpus[i]);\n\t\tsync_global_from_guest(vm, guest_stolen_time[i]);\n\t\tstolen_time = guest_stolen_time[i];\n\t\trun_delay = get_run_delay();\n\t\tTEST_ASSERT(stolen_time <= run_delay,\n\t\t\t    \"Expected stolen time <= %ld, got %ld\",\n\t\t\t    run_delay, stolen_time);\n\n\t\t \n\t\trun_delay = get_run_delay();\n\t\tpthread_create(&thread, &attr, do_steal_time, NULL);\n\t\tdo\n\t\t\tsched_yield();\n\t\twhile (get_run_delay() - run_delay < MIN_RUN_DELAY_NS);\n\t\tpthread_join(thread, NULL);\n\t\trun_delay = get_run_delay() - run_delay;\n\t\tTEST_ASSERT(run_delay >= MIN_RUN_DELAY_NS,\n\t\t\t    \"Expected run_delay >= %ld, got %ld\",\n\t\t\t    MIN_RUN_DELAY_NS, run_delay);\n\n\t\t \n\t\trun_vcpu(vcpus[i]);\n\t\tsync_global_from_guest(vm, guest_stolen_time[i]);\n\t\tstolen_time = guest_stolen_time[i] - stolen_time;\n\t\tTEST_ASSERT(stolen_time >= run_delay,\n\t\t\t    \"Expected stolen time >= %ld, got %ld\",\n\t\t\t    run_delay, stolen_time);\n\n\t\tif (verbose) {\n\t\t\tpr_info(\"VCPU%d: total-stolen-time=%ld test-stolen-time=%ld\", i,\n\t\t\t\tguest_stolen_time[i], stolen_time);\n\t\t\tif (stolen_time == run_delay)\n\t\t\t\tpr_info(\" (BONUS: guest test-stolen-time even exactly matches test-run_delay)\");\n\t\t\tpr_info(\"\\n\");\n\t\t\tsteal_time_dump(vm, i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}