{
  "module_name": "memslot_modification_stress_test.c",
  "hash_id": "250b86f4028e21d746fdc10c8191e9216fa084f9107ea31babcbe183741ffa3e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/memslot_modification_stress_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <asm/unistd.h>\n#include <time.h>\n#include <poll.h>\n#include <pthread.h>\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/userfaultfd.h>\n\n#include \"memstress.h\"\n#include \"processor.h\"\n#include \"test_util.h\"\n#include \"guest_modes.h\"\n\n#define DUMMY_MEMSLOT_INDEX 7\n\n#define DEFAULT_MEMSLOT_MODIFICATION_ITERATIONS 10\n\n\nstatic int nr_vcpus = 1;\nstatic uint64_t guest_percpu_mem_size = DEFAULT_PER_VCPU_MEM_SIZE;\n\nstatic void vcpu_worker(struct memstress_vcpu_args *vcpu_args)\n{\n\tstruct kvm_vcpu *vcpu = vcpu_args->vcpu;\n\tstruct kvm_run *run;\n\tint ret;\n\n\trun = vcpu->run;\n\n\t \n\twhile (!READ_ONCE(memstress_args.stop_vcpus)) {\n\t\tret = _vcpu_run(vcpu);\n\t\tTEST_ASSERT(ret == 0, \"vcpu_run failed: %d\\n\", ret);\n\n\t\tif (get_ucall(vcpu, NULL) == UCALL_SYNC)\n\t\t\tcontinue;\n\n\t\tTEST_ASSERT(false,\n\t\t\t    \"Invalid guest sync status: exit_reason=%s\\n\",\n\t\t\t    exit_reason_str(run->exit_reason));\n\t}\n}\n\nstruct memslot_antagonist_args {\n\tstruct kvm_vm *vm;\n\tuseconds_t delay;\n\tuint64_t nr_modifications;\n};\n\nstatic void add_remove_memslot(struct kvm_vm *vm, useconds_t delay,\n\t\t\t       uint64_t nr_modifications)\n{\n\tuint64_t pages = max_t(int, vm->page_size, getpagesize()) / vm->page_size;\n\tuint64_t gpa;\n\tint i;\n\n\t \n\tgpa = memstress_args.gpa - pages * vm->page_size;\n\n\tfor (i = 0; i < nr_modifications; i++) {\n\t\tusleep(delay);\n\t\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS, gpa,\n\t\t\t\t\t    DUMMY_MEMSLOT_INDEX, pages, 0);\n\n\t\tvm_mem_region_delete(vm, DUMMY_MEMSLOT_INDEX);\n\t}\n}\n\nstruct test_params {\n\tuseconds_t delay;\n\tuint64_t nr_iterations;\n\tbool partition_vcpu_memory_access;\n};\n\nstatic void run_test(enum vm_guest_mode mode, void *arg)\n{\n\tstruct test_params *p = arg;\n\tstruct kvm_vm *vm;\n\n\tvm = memstress_create_vm(mode, nr_vcpus, guest_percpu_mem_size, 1,\n\t\t\t\t VM_MEM_SRC_ANONYMOUS,\n\t\t\t\t p->partition_vcpu_memory_access);\n\n\tpr_info(\"Finished creating vCPUs\\n\");\n\n\tmemstress_start_vcpu_threads(nr_vcpus, vcpu_worker);\n\n\tpr_info(\"Started all vCPUs\\n\");\n\n\tadd_remove_memslot(vm, p->delay, p->nr_iterations);\n\n\tmemstress_join_vcpu_threads(nr_vcpus);\n\tpr_info(\"All vCPU threads joined\\n\");\n\n\tmemstress_destroy_vm(vm);\n}\n\nstatic void help(char *name)\n{\n\tputs(\"\");\n\tprintf(\"usage: %s [-h] [-m mode] [-d delay_usec]\\n\"\n\t       \"          [-b memory] [-v vcpus] [-o] [-i iterations]\\n\", name);\n\tguest_modes_help();\n\tprintf(\" -d: add a delay between each iteration of adding and\\n\"\n\t       \"     deleting a memslot in usec.\\n\");\n\tprintf(\" -b: specify the size of the memory region which should be\\n\"\n\t       \"     accessed by each vCPU. e.g. 10M or 3G.\\n\"\n\t       \"     Default: 1G\\n\");\n\tprintf(\" -v: specify the number of vCPUs to run.\\n\");\n\tprintf(\" -o: Overlap guest memory accesses instead of partitioning\\n\"\n\t       \"     them into a separate region of memory for each vCPU.\\n\");\n\tprintf(\" -i: specify the number of iterations of adding and removing\\n\"\n\t       \"     a memslot.\\n\"\n\t       \"     Default: %d\\n\", DEFAULT_MEMSLOT_MODIFICATION_ITERATIONS);\n\tputs(\"\");\n\texit(0);\n}\n\nint main(int argc, char *argv[])\n{\n\tint max_vcpus = kvm_check_cap(KVM_CAP_MAX_VCPUS);\n\tint opt;\n\tstruct test_params p = {\n\t\t.delay = 0,\n\t\t.nr_iterations = DEFAULT_MEMSLOT_MODIFICATION_ITERATIONS,\n\t\t.partition_vcpu_memory_access = true\n\t};\n\n\tguest_modes_append_default();\n\n\twhile ((opt = getopt(argc, argv, \"hm:d:b:v:oi:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'm':\n\t\t\tguest_modes_cmdline(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tp.delay = atoi_non_negative(\"Delay\", optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tguest_percpu_mem_size = parse_size(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tnr_vcpus = atoi_positive(\"Number of vCPUs\", optarg);\n\t\t\tTEST_ASSERT(nr_vcpus <= max_vcpus,\n\t\t\t\t    \"Invalid number of vcpus, must be between 1 and %d\",\n\t\t\t\t    max_vcpus);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tp.partition_vcpu_memory_access = false;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tp.nr_iterations = atoi_positive(\"Number of iterations\", optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor_each_guest_mode(run_test, &p);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}