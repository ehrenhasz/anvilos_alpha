{
  "module_name": "kvm_binary_stats_test.c",
  "hash_id": "be3e30ae95d3c26f59b597a90425a17969fe7755fce41d90117c3c4d0d9ed442",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/kvm_binary_stats_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"test_util.h\"\n\n#include \"kvm_util.h\"\n#include \"asm/kvm.h\"\n#include \"linux/kvm.h\"\n#include \"kselftest.h\"\n\nstatic void stats_test(int stats_fd)\n{\n\tssize_t ret;\n\tint i;\n\tsize_t size_desc;\n\tsize_t size_data = 0;\n\tstruct kvm_stats_header header;\n\tchar *id;\n\tstruct kvm_stats_desc *stats_desc;\n\tu64 *stats_data;\n\tstruct kvm_stats_desc *pdesc;\n\tu32 type, unit, base;\n\n\t \n\tread_stats_header(stats_fd, &header);\n\n\tsize_desc = get_stats_descriptor_size(&header);\n\n\t \n\tid = malloc(header.name_size);\n\tTEST_ASSERT(id, \"Allocate memory for id string\");\n\n\tret = pread(stats_fd, id, header.name_size, sizeof(header));\n\tTEST_ASSERT(ret == header.name_size,\n\t\t    \"Expected header size '%u', read '%lu' bytes\",\n\t\t    header.name_size, ret);\n\n\t \n\tTEST_ASSERT(!strncmp(id, \"kvm\", 3) && strlen(id) < header.name_size,\n\t\t    \"Invalid KVM stats type, id: %s\", id);\n\n\t \n\tif (header.num_desc == 0) {\n\t\tksft_print_msg(\"No KVM stats defined!\\n\");\n\t\treturn;\n\t}\n\t \n\tTEST_ASSERT(header.desc_offset && header.desc_offset >= sizeof(header) &&\n\t\t    header.data_offset && header.data_offset >= sizeof(header),\n\t\t    \"Invalid offset fields in header\");\n\n\tTEST_ASSERT(header.desc_offset > header.data_offset ||\n\t\t    (header.desc_offset + size_desc * header.num_desc <= header.data_offset),\n\t\t    \"Descriptor block is overlapped with data block\");\n\n\t \n\tstats_desc = read_stats_descriptors(stats_fd, &header);\n\n\t \n\tfor (i = 0; i < header.num_desc; ++i) {\n\t\tpdesc = get_stats_descriptor(stats_desc, i, &header);\n\t\ttype = pdesc->flags & KVM_STATS_TYPE_MASK;\n\t\tunit = pdesc->flags & KVM_STATS_UNIT_MASK;\n\t\tbase = pdesc->flags & KVM_STATS_BASE_MASK;\n\n\t\t \n\t\tTEST_ASSERT(strlen(pdesc->name) < header.name_size,\n\t\t\t    \"KVM stats name (index: %d) too long\", i);\n\n\t\t \n\t\tTEST_ASSERT(type <= KVM_STATS_TYPE_MAX,\n\t\t\t    \"Unknown KVM stats (%s) type: %u\", pdesc->name, type);\n\t\tTEST_ASSERT(unit <= KVM_STATS_UNIT_MAX,\n\t\t\t    \"Unknown KVM stats (%s) unit: %u\", pdesc->name, unit);\n\t\tTEST_ASSERT(base <= KVM_STATS_BASE_MAX,\n\t\t\t    \"Unknown KVM stats (%s) base: %u\", pdesc->name, base);\n\n\t\t \n\t\tswitch (pdesc->flags & KVM_STATS_UNIT_MASK) {\n\t\tcase KVM_STATS_UNIT_NONE:\n\t\tcase KVM_STATS_UNIT_BYTES:\n\t\tcase KVM_STATS_UNIT_CYCLES:\n\t\t\tTEST_ASSERT(pdesc->exponent >= 0,\n\t\t\t\t    \"Unsupported KVM stats (%s) exponent: %i\",\n\t\t\t\t    pdesc->name, pdesc->exponent);\n\t\t\tbreak;\n\t\tcase KVM_STATS_UNIT_SECONDS:\n\t\t\tTEST_ASSERT(pdesc->exponent <= 0,\n\t\t\t\t    \"Unsupported KVM stats (%s) exponent: %i\",\n\t\t\t\t    pdesc->name, pdesc->exponent);\n\t\t\tbreak;\n\t\tcase KVM_STATS_UNIT_BOOLEAN:\n\t\t\tTEST_ASSERT(pdesc->exponent == 0,\n\t\t\t\t    \"Unsupported KVM stats (%s) exponent: %d\",\n\t\t\t\t    pdesc->name, pdesc->exponent);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tTEST_ASSERT(pdesc->size,\n\t\t\t    \"KVM descriptor(%s) with size of 0\", pdesc->name);\n\t\t \n\t\tswitch (pdesc->flags & KVM_STATS_TYPE_MASK) {\n\t\tcase KVM_STATS_TYPE_LINEAR_HIST:\n\t\t\tTEST_ASSERT(pdesc->bucket_size,\n\t\t\t\t    \"Bucket size of Linear Histogram stats (%s) is zero\",\n\t\t\t\t    pdesc->name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTEST_ASSERT(!pdesc->bucket_size,\n\t\t\t\t    \"Bucket size of stats (%s) is not zero\",\n\t\t\t\t    pdesc->name);\n\t\t}\n\t\tsize_data = max(size_data, pdesc->offset + pdesc->size * sizeof(*stats_data));\n\t}\n\n\t \n\tTEST_ASSERT(header.data_offset >= header.desc_offset ||\n\t\t    header.data_offset + size_data <= header.desc_offset,\n\t\t    \"Data block is overlapped with Descriptor block\");\n\n\t \n\tTEST_ASSERT(size_data >= header.num_desc * sizeof(*stats_data),\n\t\t    \"Data size is not correct\");\n\n\t \n\tstats_data = malloc(size_data);\n\tTEST_ASSERT(stats_data, \"Allocate memory for stats data\");\n\t \n\tret = pread(stats_fd, stats_data, size_data, header.data_offset);\n\tTEST_ASSERT(ret == size_data, \"Read KVM stats data\");\n\t \n\tfor (i = 0; i < header.num_desc; ++i) {\n\t\tpdesc = get_stats_descriptor(stats_desc, i, &header);\n\t\tread_stat_data(stats_fd, &header, pdesc, stats_data,\n\t\t\t       pdesc->size);\n\t}\n\n\tfree(stats_data);\n\tfree(stats_desc);\n\tfree(id);\n\n\tclose(stats_fd);\n\tTEST_ASSERT(fcntl(stats_fd, F_GETFD) == -1, \"Stats fd not freed\");\n}\n\n#define DEFAULT_NUM_VM\t\t4\n#define DEFAULT_NUM_VCPU\t4\n\n \n\nint main(int argc, char *argv[])\n{\n\tint vm_stats_fds, *vcpu_stats_fds;\n\tint i, j;\n\tstruct kvm_vcpu **vcpus;\n\tstruct kvm_vm **vms;\n\tint max_vm = DEFAULT_NUM_VM;\n\tint max_vcpu = DEFAULT_NUM_VCPU;\n\n\t \n\tif (argc > 1) {\n\t\tmax_vm = strtol(argv[1], NULL, 0);\n\t\tif (max_vm <= 0)\n\t\t\tmax_vm = DEFAULT_NUM_VM;\n\t}\n\tif (argc > 2) {\n\t\tmax_vcpu = strtol(argv[2], NULL, 0);\n\t\tif (max_vcpu <= 0)\n\t\t\tmax_vcpu = DEFAULT_NUM_VCPU;\n\t}\n\n\tksft_print_header();\n\n\t \n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_BINARY_STATS_FD));\n\n\tksft_set_plan(max_vm);\n\n\t \n\tvms = malloc(sizeof(vms[0]) * max_vm);\n\tTEST_ASSERT(vms, \"Allocate memory for storing VM pointers\");\n\n\tvcpus = malloc(sizeof(struct kvm_vcpu *) * max_vm * max_vcpu);\n\tTEST_ASSERT(vcpus, \"Allocate memory for storing vCPU pointers\");\n\n\t \n\tvcpu_stats_fds = calloc(max_vm, sizeof(*vcpu_stats_fds));\n\tTEST_ASSERT(vcpu_stats_fds, \"Allocate memory for VM stats fds\");\n\n\tfor (i = 0; i < max_vm; ++i) {\n\t\tvms[i] = vm_create_barebones();\n\t\tfor (j = 0; j < max_vcpu; ++j)\n\t\t\tvcpus[i * max_vcpu + j] = __vm_vcpu_add(vms[i], j);\n\t}\n\n\t \n\tfor (i = 0; i < max_vm; ++i) {\n\t\t \n\t\tvm_stats_fds = vm_get_stats_fd(vms[i]);\n\t\tstats_test(dup(vm_stats_fds));\n\n\t\t \n\t\tstats_test(vm_get_stats_fd(vms[i]));\n\n\t\tfor (j = 0; j < max_vcpu; ++j) {\n\t\t\tvcpu_stats_fds[j] = vcpu_get_stats_fd(vcpus[i * max_vcpu + j]);\n\t\t\tstats_test(dup(vcpu_stats_fds[j]));\n\t\t\tstats_test(vcpu_get_stats_fd(vcpus[i * max_vcpu + j]));\n\t\t}\n\n\t\t \n\t\tkvm_vm_free(vms[i]);\n\n\t\tstats_test(vm_stats_fds);\n\t\tfor (j = 0; j < max_vcpu; ++j)\n\t\t\tstats_test(vcpu_stats_fds[j]);\n\n\t\tksft_test_result_pass(\"vm%i\\n\", i);\n\t}\n\n\tfree(vms);\n\tfree(vcpus);\n\tfree(vcpu_stats_fds);\n\n\tksft_finished();\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}