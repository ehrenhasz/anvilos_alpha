{
  "module_name": "hardware_disable_test.c",
  "hash_id": "561263aea24742389d1b20e2d4dfedc85dc3c6498348652efd32a1f800129e6b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/hardware_disable_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <fcntl.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#include <test_util.h>\n\n#include \"kvm_util.h\"\n\n#define VCPU_NUM 4\n#define SLEEPING_THREAD_NUM (1 << 4)\n#define FORK_NUM (1ULL << 9)\n#define DELAY_US_MAX 2000\n#define GUEST_CODE_PIO_PORT 4\n\nsem_t *sem;\n\nstatic void guest_code(void)\n{\n\tfor (;;)\n\t\t;   \n\tprintf(\"Should not be reached.\\n\");\n}\n\nstatic void *run_vcpu(void *arg)\n{\n\tstruct kvm_vcpu *vcpu = arg;\n\tstruct kvm_run *run = vcpu->run;\n\n\tvcpu_run(vcpu);\n\n\tTEST_ASSERT(false, \"%s: exited with reason %d: %s\\n\",\n\t\t    __func__, run->exit_reason,\n\t\t    exit_reason_str(run->exit_reason));\n\tpthread_exit(NULL);\n}\n\nstatic void *sleeping_thread(void *arg)\n{\n\tint fd;\n\n\twhile (true) {\n\t\tfd = open(\"/dev/null\", O_RDWR);\n\t\tclose(fd);\n\t}\n\tTEST_ASSERT(false, \"%s: exited\\n\", __func__);\n\tpthread_exit(NULL);\n}\n\nstatic inline void check_create_thread(pthread_t *thread, pthread_attr_t *attr,\n\t\t\t\t       void *(*f)(void *), void *arg)\n{\n\tint r;\n\n\tr = pthread_create(thread, attr, f, arg);\n\tTEST_ASSERT(r == 0, \"%s: failed to create thread\", __func__);\n}\n\nstatic inline void check_set_affinity(pthread_t thread, cpu_set_t *cpu_set)\n{\n\tint r;\n\n\tr = pthread_setaffinity_np(thread, sizeof(cpu_set_t), cpu_set);\n\tTEST_ASSERT(r == 0, \"%s: failed set affinity\", __func__);\n}\n\nstatic inline void check_join(pthread_t thread, void **retval)\n{\n\tint r;\n\n\tr = pthread_join(thread, retval);\n\tTEST_ASSERT(r == 0, \"%s: failed to join thread\", __func__);\n}\n\nstatic void run_test(uint32_t run)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tcpu_set_t cpu_set;\n\tpthread_t threads[VCPU_NUM];\n\tpthread_t throw_away;\n\tvoid *b;\n\tuint32_t i, j;\n\n\tCPU_ZERO(&cpu_set);\n\tfor (i = 0; i < VCPU_NUM; i++)\n\t\tCPU_SET(i, &cpu_set);\n\n\tvm = vm_create(VCPU_NUM);\n\n\tpr_debug(\"%s: [%d] start vcpus\\n\", __func__, run);\n\tfor (i = 0; i < VCPU_NUM; ++i) {\n\t\tvcpu = vm_vcpu_add(vm, i, guest_code);\n\n\t\tcheck_create_thread(&threads[i], NULL, run_vcpu, vcpu);\n\t\tcheck_set_affinity(threads[i], &cpu_set);\n\n\t\tfor (j = 0; j < SLEEPING_THREAD_NUM; ++j) {\n\t\t\tcheck_create_thread(&throw_away, NULL, sleeping_thread,\n\t\t\t\t\t    (void *)NULL);\n\t\t\tcheck_set_affinity(throw_away, &cpu_set);\n\t\t}\n\t}\n\tpr_debug(\"%s: [%d] all threads launched\\n\", __func__, run);\n\tsem_post(sem);\n\tfor (i = 0; i < VCPU_NUM; ++i)\n\t\tcheck_join(threads[i], &b);\n\t \n\tTEST_ASSERT(false, \"%s: [%d] child escaped the ninja\\n\", __func__, run);\n}\n\nvoid wait_for_child_setup(pid_t pid)\n{\n\t \n\tfor (;;) {\n\t\tconst struct timespec wait_period = { .tv_sec = 1 };\n\t\tint status;\n\n\t\tif (!sem_timedwait(sem, &wait_period))\n\t\t\treturn;\n\n\t\t \n\t\tif (pid != waitpid(pid, &status, WNOHANG))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (WIFEXITED(status))\n\t\t\texit(WEXITSTATUS(status));\n\t\telse\n\t\t\tTEST_ASSERT(false, \"Child exited unexpectedly\");\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tuint32_t i;\n\tint s, r;\n\tpid_t pid;\n\n\tsem = sem_open(\"vm_sem\", O_CREAT | O_EXCL, 0644, 0);\n\tsem_unlink(\"vm_sem\");\n\n\tfor (i = 0; i < FORK_NUM; ++i) {\n\t\tpid = fork();\n\t\tTEST_ASSERT(pid >= 0, \"%s: unable to fork\", __func__);\n\t\tif (pid == 0)\n\t\t\trun_test(i);  \n\n\t\tpr_debug(\"%s: [%d] waiting semaphore\\n\", __func__, i);\n\t\twait_for_child_setup(pid);\n\t\tr = (rand() % DELAY_US_MAX) + 1;\n\t\tpr_debug(\"%s: [%d] waiting %dus\\n\", __func__, i, r);\n\t\tusleep(r);\n\t\tr = waitpid(pid, &s, WNOHANG);\n\t\tTEST_ASSERT(r != pid,\n\t\t\t    \"%s: [%d] child exited unexpectedly status: [%d]\",\n\t\t\t    __func__, i, s);\n\t\tpr_debug(\"%s: [%d] killing child\\n\", __func__, i);\n\t\tkill(pid, SIGKILL);\n\t}\n\n\tsem_destroy(sem);\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}