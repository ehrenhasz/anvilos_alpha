{
  "module_name": "access_tracking_perf_test.c",
  "hash_id": "ad4c75af8221bc6075fa1943b5329b58ec5ee5f71afbdadfd9a1975cf5a71df7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/access_tracking_perf_test.c",
  "human_readable_source": "\n \n#include <inttypes.h>\n#include <limits.h>\n#include <pthread.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include \"kvm_util.h\"\n#include \"test_util.h\"\n#include \"memstress.h\"\n#include \"guest_modes.h\"\n#include \"processor.h\"\n\n \nstatic int iteration;\n\n \nstatic enum {\n\t \n\tITERATION_ACCESS_MEMORY,\n\t \n\tITERATION_MARK_IDLE,\n} iteration_work;\n\n \nstatic int vcpu_last_completed_iteration[KVM_MAX_VCPUS];\n\n \nstatic bool overlap_memory_access;\n\nstruct test_params {\n\t \n\tenum vm_mem_backing_src_type backing_src;\n\n\t \n\tuint64_t vcpu_memory_bytes;\n\n\t \n\tint nr_vcpus;\n};\n\nstatic uint64_t pread_uint64(int fd, const char *filename, uint64_t index)\n{\n\tuint64_t value;\n\toff_t offset = index * sizeof(value);\n\n\tTEST_ASSERT(pread(fd, &value, sizeof(value), offset) == sizeof(value),\n\t\t    \"pread from %s offset 0x%\" PRIx64 \" failed!\",\n\t\t    filename, offset);\n\n\treturn value;\n\n}\n\n#define PAGEMAP_PRESENT (1ULL << 63)\n#define PAGEMAP_PFN_MASK ((1ULL << 55) - 1)\n\nstatic uint64_t lookup_pfn(int pagemap_fd, struct kvm_vm *vm, uint64_t gva)\n{\n\tuint64_t hva = (uint64_t) addr_gva2hva(vm, gva);\n\tuint64_t entry;\n\tuint64_t pfn;\n\n\tentry = pread_uint64(pagemap_fd, \"pagemap\", hva / getpagesize());\n\tif (!(entry & PAGEMAP_PRESENT))\n\t\treturn 0;\n\n\tpfn = entry & PAGEMAP_PFN_MASK;\n\t__TEST_REQUIRE(pfn, \"Looking up PFNs requires CAP_SYS_ADMIN\");\n\n\treturn pfn;\n}\n\nstatic bool is_page_idle(int page_idle_fd, uint64_t pfn)\n{\n\tuint64_t bits = pread_uint64(page_idle_fd, \"page_idle\", pfn / 64);\n\n\treturn !!((bits >> (pfn % 64)) & 1);\n}\n\nstatic void mark_page_idle(int page_idle_fd, uint64_t pfn)\n{\n\tuint64_t bits = 1ULL << (pfn % 64);\n\n\tTEST_ASSERT(pwrite(page_idle_fd, &bits, 8, 8 * (pfn / 64)) == 8,\n\t\t    \"Set page_idle bits for PFN 0x%\" PRIx64, pfn);\n}\n\nstatic void mark_vcpu_memory_idle(struct kvm_vm *vm,\n\t\t\t\t  struct memstress_vcpu_args *vcpu_args)\n{\n\tint vcpu_idx = vcpu_args->vcpu_idx;\n\tuint64_t base_gva = vcpu_args->gva;\n\tuint64_t pages = vcpu_args->pages;\n\tuint64_t page;\n\tuint64_t still_idle = 0;\n\tuint64_t no_pfn = 0;\n\tint page_idle_fd;\n\tint pagemap_fd;\n\n\t \n\tif (overlap_memory_access && vcpu_idx)\n\t\treturn;\n\n\tpage_idle_fd = open(\"/sys/kernel/mm/page_idle/bitmap\", O_RDWR);\n\tTEST_ASSERT(page_idle_fd > 0, \"Failed to open page_idle.\");\n\n\tpagemap_fd = open(\"/proc/self/pagemap\", O_RDONLY);\n\tTEST_ASSERT(pagemap_fd > 0, \"Failed to open pagemap.\");\n\n\tfor (page = 0; page < pages; page++) {\n\t\tuint64_t gva = base_gva + page * memstress_args.guest_page_size;\n\t\tuint64_t pfn = lookup_pfn(pagemap_fd, vm, gva);\n\n\t\tif (!pfn) {\n\t\t\tno_pfn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_page_idle(page_idle_fd, pfn)) {\n\t\t\tstill_idle++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmark_page_idle(page_idle_fd, pfn);\n\t}\n\n\t \n\tTEST_ASSERT(no_pfn < pages / 100,\n\t\t    \"vCPU %d: No PFN for %\" PRIu64 \" out of %\" PRIu64 \" pages.\",\n\t\t    vcpu_idx, no_pfn, pages);\n\n\t \n\tif (still_idle >= pages / 10) {\n#ifdef __x86_64__\n\t\tTEST_ASSERT(this_cpu_has(X86_FEATURE_HYPERVISOR),\n\t\t\t    \"vCPU%d: Too many pages still idle (%lu out of %lu)\",\n\t\t\t    vcpu_idx, still_idle, pages);\n#endif\n\t\tprintf(\"WARNING: vCPU%d: Too many pages still idle (%lu out of %lu), \"\n\t\t       \"this will affect performance results.\\n\",\n\t\t       vcpu_idx, still_idle, pages);\n\t}\n\n\tclose(page_idle_fd);\n\tclose(pagemap_fd);\n}\n\nstatic void assert_ucall(struct kvm_vcpu *vcpu, uint64_t expected_ucall)\n{\n\tstruct ucall uc;\n\tuint64_t actual_ucall = get_ucall(vcpu, &uc);\n\n\tTEST_ASSERT(expected_ucall == actual_ucall,\n\t\t    \"Guest exited unexpectedly (expected ucall %\" PRIu64\n\t\t    \", got %\" PRIu64 \")\",\n\t\t    expected_ucall, actual_ucall);\n}\n\nstatic bool spin_wait_for_next_iteration(int *current_iteration)\n{\n\tint last_iteration = *current_iteration;\n\n\tdo {\n\t\tif (READ_ONCE(memstress_args.stop_vcpus))\n\t\t\treturn false;\n\n\t\t*current_iteration = READ_ONCE(iteration);\n\t} while (last_iteration == *current_iteration);\n\n\treturn true;\n}\n\nstatic void vcpu_thread_main(struct memstress_vcpu_args *vcpu_args)\n{\n\tstruct kvm_vcpu *vcpu = vcpu_args->vcpu;\n\tstruct kvm_vm *vm = memstress_args.vm;\n\tint vcpu_idx = vcpu_args->vcpu_idx;\n\tint current_iteration = 0;\n\n\twhile (spin_wait_for_next_iteration(&current_iteration)) {\n\t\tswitch (READ_ONCE(iteration_work)) {\n\t\tcase ITERATION_ACCESS_MEMORY:\n\t\t\tvcpu_run(vcpu);\n\t\t\tassert_ucall(vcpu, UCALL_SYNC);\n\t\t\tbreak;\n\t\tcase ITERATION_MARK_IDLE:\n\t\t\tmark_vcpu_memory_idle(vm, vcpu_args);\n\t\t\tbreak;\n\t\t};\n\n\t\tvcpu_last_completed_iteration[vcpu_idx] = current_iteration;\n\t}\n}\n\nstatic void spin_wait_for_vcpu(int vcpu_idx, int target_iteration)\n{\n\twhile (READ_ONCE(vcpu_last_completed_iteration[vcpu_idx]) !=\n\t       target_iteration) {\n\t\tcontinue;\n\t}\n}\n\n \nenum access_type {\n\tACCESS_READ,\n\tACCESS_WRITE,\n};\n\nstatic void run_iteration(struct kvm_vm *vm, int nr_vcpus, const char *description)\n{\n\tstruct timespec ts_start;\n\tstruct timespec ts_elapsed;\n\tint next_iteration, i;\n\n\t \n\tnext_iteration = ++iteration;\n\n\tclock_gettime(CLOCK_MONOTONIC, &ts_start);\n\n\t \n\tfor (i = 0; i < nr_vcpus; i++)\n\t\tspin_wait_for_vcpu(i, next_iteration);\n\n\tts_elapsed = timespec_elapsed(ts_start);\n\tpr_info(\"%-30s: %ld.%09lds\\n\",\n\t\tdescription, ts_elapsed.tv_sec, ts_elapsed.tv_nsec);\n}\n\nstatic void access_memory(struct kvm_vm *vm, int nr_vcpus,\n\t\t\t  enum access_type access, const char *description)\n{\n\tmemstress_set_write_percent(vm, (access == ACCESS_READ) ? 0 : 100);\n\titeration_work = ITERATION_ACCESS_MEMORY;\n\trun_iteration(vm, nr_vcpus, description);\n}\n\nstatic void mark_memory_idle(struct kvm_vm *vm, int nr_vcpus)\n{\n\t \n\tpr_debug(\"Marking VM memory idle (slow)...\\n\");\n\titeration_work = ITERATION_MARK_IDLE;\n\trun_iteration(vm, nr_vcpus, \"Mark memory idle\");\n}\n\nstatic void run_test(enum vm_guest_mode mode, void *arg)\n{\n\tstruct test_params *params = arg;\n\tstruct kvm_vm *vm;\n\tint nr_vcpus = params->nr_vcpus;\n\n\tvm = memstress_create_vm(mode, nr_vcpus, params->vcpu_memory_bytes, 1,\n\t\t\t\t params->backing_src, !overlap_memory_access);\n\n\tmemstress_start_vcpu_threads(nr_vcpus, vcpu_thread_main);\n\n\tpr_info(\"\\n\");\n\taccess_memory(vm, nr_vcpus, ACCESS_WRITE, \"Populating memory\");\n\n\t \n\taccess_memory(vm, nr_vcpus, ACCESS_WRITE, \"Writing to populated memory\");\n\taccess_memory(vm, nr_vcpus, ACCESS_READ, \"Reading from populated memory\");\n\n\t \n\tmark_memory_idle(vm, nr_vcpus);\n\taccess_memory(vm, nr_vcpus, ACCESS_WRITE, \"Writing to idle memory\");\n\tmark_memory_idle(vm, nr_vcpus);\n\taccess_memory(vm, nr_vcpus, ACCESS_READ, \"Reading from idle memory\");\n\n\tmemstress_join_vcpu_threads(nr_vcpus);\n\tmemstress_destroy_vm(vm);\n}\n\nstatic void help(char *name)\n{\n\tputs(\"\");\n\tprintf(\"usage: %s [-h] [-m mode] [-b vcpu_bytes] [-v vcpus] [-o]  [-s mem_type]\\n\",\n\t       name);\n\tputs(\"\");\n\tprintf(\" -h: Display this help message.\");\n\tguest_modes_help();\n\tprintf(\" -b: specify the size of the memory region which should be\\n\"\n\t       \"     dirtied by each vCPU. e.g. 10M or 3G.\\n\"\n\t       \"     (default: 1G)\\n\");\n\tprintf(\" -v: specify the number of vCPUs to run.\\n\");\n\tprintf(\" -o: Overlap guest memory accesses instead of partitioning\\n\"\n\t       \"     them into a separate region of memory for each vCPU.\\n\");\n\tbacking_src_help(\"-s\");\n\tputs(\"\");\n\texit(0);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct test_params params = {\n\t\t.backing_src = DEFAULT_VM_MEM_SRC,\n\t\t.vcpu_memory_bytes = DEFAULT_PER_VCPU_MEM_SIZE,\n\t\t.nr_vcpus = 1,\n\t};\n\tint page_idle_fd;\n\tint opt;\n\n\tguest_modes_append_default();\n\n\twhile ((opt = getopt(argc, argv, \"hm:b:v:os:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'm':\n\t\t\tguest_modes_cmdline(optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tparams.vcpu_memory_bytes = parse_size(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tparams.nr_vcpus = atoi_positive(\"Number of vCPUs\", optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toverlap_memory_access = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tparams.backing_src = parse_backing_src_type(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpage_idle_fd = open(\"/sys/kernel/mm/page_idle/bitmap\", O_RDWR);\n\t__TEST_REQUIRE(page_idle_fd >= 0,\n\t\t       \"CONFIG_IDLE_PAGE_TRACKING is not enabled\");\n\tclose(page_idle_fd);\n\n\tfor_each_guest_mode(run_test, &params);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}