{
  "module_name": "resets.c",
  "hash_id": "228d1056e59b3486ff253d5d066b7cdd8bc7c94f55ca56a98c29cbe1370be1db",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/s390x/resets.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"kselftest.h\"\n\n#define LOCAL_IRQS 32\n\n#define ARBITRARY_NON_ZERO_VCPU_ID 3\n\nstruct kvm_s390_irq buf[ARBITRARY_NON_ZERO_VCPU_ID + LOCAL_IRQS];\n\nstatic uint8_t regs_null[512];\n\nstatic void guest_code_initial(void)\n{\n\t \n\tunsigned long cr2_59 = 0x10;\t \n\tunsigned long cr8_63 = 0x1;\t \n\tunsigned long cr10 = 1;\t\t \n\tunsigned long cr11 = -1;\t \n\n\n\t \n\tasm volatile (\n\t\t\"\tlghi\t2,0x11\\n\"\t \n\t\t\"\tsfpc\t2\\n\"\t\t \n\t\t\"\tlctlg\t2,2,%0\\n\"\n\t\t\"\tlctlg\t8,8,%1\\n\"\n\t\t\"\tlctlg\t10,10,%2\\n\"\n\t\t\"\tlctlg\t11,11,%3\\n\"\n\t\t \n\t\t\"\tllihh\t0,0xffff\\n\"\n\t\t\"\tllihl\t1,0x5555\\n\"\n\t\t\"\tllilh\t2,0xaaaa\\n\"\n\t\t\"\tllill\t3,0x0000\\n\"\n\t\t \n\t\t\"\tlghi\t4,0x1\\n\"\n\t\t\"\tcdgbr\t0,4\\n\"\n\t\t \n\t\t\"\tsar\t9,4\\n\"\n\t\t \n\t\t\"\tdiag 0,0,0x501\\n\"\n\t\t:\n\t\t: \"m\" (cr2_59), \"m\" (cr8_63), \"m\" (cr10), \"m\" (cr11)\n\t\t \n\t\t);\n}\n\nstatic void test_one_reg(struct kvm_vcpu *vcpu, uint64_t id, uint64_t value)\n{\n\tuint64_t eval_reg;\n\n\tvcpu_get_reg(vcpu, id, &eval_reg);\n\tTEST_ASSERT(eval_reg == value, \"value == 0x%lx\", value);\n}\n\nstatic void assert_noirq(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_s390_irq_state irq_state;\n\tint irqs;\n\n\tirq_state.len = sizeof(buf);\n\tirq_state.buf = (unsigned long)buf;\n\tirqs = __vcpu_ioctl(vcpu, KVM_S390_GET_IRQ_STATE, &irq_state);\n\t \n\tTEST_ASSERT(irqs >= 0, \"Could not fetch IRQs: errno %d\\n\", errno);\n\tTEST_ASSERT(!irqs, \"IRQ pending\");\n}\n\nstatic void assert_clear(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_sync_regs *sync_regs = &vcpu->run->s.regs;\n\tstruct kvm_sregs sregs;\n\tstruct kvm_regs regs;\n\tstruct kvm_fpu fpu;\n\n\tvcpu_regs_get(vcpu, &regs);\n\tTEST_ASSERT(!memcmp(&regs.gprs, regs_null, sizeof(regs.gprs)), \"grs == 0\");\n\n\tvcpu_sregs_get(vcpu, &sregs);\n\tTEST_ASSERT(!memcmp(&sregs.acrs, regs_null, sizeof(sregs.acrs)), \"acrs == 0\");\n\n\tvcpu_fpu_get(vcpu, &fpu);\n\tTEST_ASSERT(!memcmp(&fpu.fprs, regs_null, sizeof(fpu.fprs)), \"fprs == 0\");\n\n\t \n\tTEST_ASSERT(!memcmp(sync_regs->gprs, regs_null, sizeof(sync_regs->gprs)),\n\t\t    \"gprs0-15 == 0 (sync_regs)\");\n\n\tTEST_ASSERT(!memcmp(sync_regs->acrs, regs_null, sizeof(sync_regs->acrs)),\n\t\t    \"acrs0-15 == 0 (sync_regs)\");\n\n\tTEST_ASSERT(!memcmp(sync_regs->vrs, regs_null, sizeof(sync_regs->vrs)),\n\t\t    \"vrs0-15 == 0 (sync_regs)\");\n}\n\nstatic void assert_initial_noclear(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_sync_regs *sync_regs = &vcpu->run->s.regs;\n\n\tTEST_ASSERT(sync_regs->gprs[0] == 0xffff000000000000UL,\n\t\t    \"gpr0 == 0xffff000000000000 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->gprs[1] == 0x0000555500000000UL,\n\t\t    \"gpr1 == 0x0000555500000000 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->gprs[2] == 0x00000000aaaa0000UL,\n\t\t    \"gpr2 == 0x00000000aaaa0000 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->gprs[3] == 0x0000000000000000UL,\n\t\t    \"gpr3 == 0x0000000000000000 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->fprs[0] == 0x3ff0000000000000UL,\n\t\t    \"fpr0 == 0f1 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->acrs[9] == 1, \"ar9 == 1 (sync_regs)\");\n}\n\nstatic void assert_initial(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_sync_regs *sync_regs = &vcpu->run->s.regs;\n\tstruct kvm_sregs sregs;\n\tstruct kvm_fpu fpu;\n\n\t \n\tvcpu_sregs_get(vcpu, &sregs);\n\tTEST_ASSERT(sregs.crs[0] == 0xE0UL, \"cr0 == 0xE0 (KVM_GET_SREGS)\");\n\tTEST_ASSERT(sregs.crs[14] == 0xC2000000UL,\n\t\t    \"cr14 == 0xC2000000 (KVM_GET_SREGS)\");\n\tTEST_ASSERT(!memcmp(&sregs.crs[1], regs_null, sizeof(sregs.crs[1]) * 12),\n\t\t    \"cr1-13 == 0 (KVM_GET_SREGS)\");\n\tTEST_ASSERT(sregs.crs[15] == 0, \"cr15 == 0 (KVM_GET_SREGS)\");\n\n\t \n\tTEST_ASSERT(sync_regs->crs[0] == 0xE0UL, \"cr0 == 0xE0 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->crs[14] == 0xC2000000UL,\n\t\t    \"cr14 == 0xC2000000 (sync_regs)\");\n\tTEST_ASSERT(!memcmp(&sync_regs->crs[1], regs_null, 8 * 12),\n\t\t    \"cr1-13 == 0 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->crs[15] == 0, \"cr15 == 0 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->fpc == 0, \"fpc == 0 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->todpr == 0, \"todpr == 0 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->cputm == 0, \"cputm == 0 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->ckc == 0, \"ckc == 0 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->pp == 0, \"pp == 0 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->gbea == 1, \"gbea == 1 (sync_regs)\");\n\n\t \n\tTEST_ASSERT(vcpu->run->psw_addr == 0, \"psw_addr == 0 (kvm_run)\");\n\tTEST_ASSERT(vcpu->run->psw_mask == 0, \"psw_mask == 0 (kvm_run)\");\n\n\tvcpu_fpu_get(vcpu, &fpu);\n\tTEST_ASSERT(!fpu.fpc, \"fpc == 0\");\n\n\ttest_one_reg(vcpu, KVM_REG_S390_GBEA, 1);\n\ttest_one_reg(vcpu, KVM_REG_S390_PP, 0);\n\ttest_one_reg(vcpu, KVM_REG_S390_TODPR, 0);\n\ttest_one_reg(vcpu, KVM_REG_S390_CPU_TIMER, 0);\n\ttest_one_reg(vcpu, KVM_REG_S390_CLOCK_COMP, 0);\n}\n\nstatic void assert_normal_noclear(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_sync_regs *sync_regs = &vcpu->run->s.regs;\n\n\tTEST_ASSERT(sync_regs->crs[2] == 0x10, \"cr2 == 10 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->crs[8] == 1, \"cr10 == 1 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->crs[10] == 1, \"cr10 == 1 (sync_regs)\");\n\tTEST_ASSERT(sync_regs->crs[11] == -1, \"cr11 == -1 (sync_regs)\");\n}\n\nstatic void assert_normal(struct kvm_vcpu *vcpu)\n{\n\ttest_one_reg(vcpu, KVM_REG_S390_PFTOKEN, KVM_S390_PFAULT_TOKEN_INVALID);\n\tTEST_ASSERT(vcpu->run->s.regs.pft == KVM_S390_PFAULT_TOKEN_INVALID,\n\t\t\t\"pft == 0xff.....  (sync_regs)\");\n\tassert_noirq(vcpu);\n}\n\nstatic void inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_s390_irq_state irq_state;\n\tstruct kvm_s390_irq *irq = &buf[0];\n\tint irqs;\n\n\t \n\tirq_state.len = sizeof(struct kvm_s390_irq);\n\tirq_state.buf = (unsigned long)buf;\n\tirq->type = KVM_S390_INT_EMERGENCY;\n\tirq->u.emerg.code = vcpu->id;\n\tirqs = __vcpu_ioctl(vcpu, KVM_S390_SET_IRQ_STATE, &irq_state);\n\tTEST_ASSERT(irqs >= 0, \"Error injecting EMERGENCY IRQ errno %d\\n\", errno);\n}\n\nstatic struct kvm_vm *create_vm(struct kvm_vcpu **vcpu)\n{\n\tstruct kvm_vm *vm;\n\n\tvm = vm_create(1);\n\n\t*vcpu = vm_vcpu_add(vm, ARBITRARY_NON_ZERO_VCPU_ID, guest_code_initial);\n\n\treturn vm;\n}\n\nstatic void test_normal(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tksft_print_msg(\"Testing normal reset\\n\");\n\tvm = create_vm(&vcpu);\n\n\tvcpu_run(vcpu);\n\n\tinject_irq(vcpu);\n\n\tvcpu_ioctl(vcpu, KVM_S390_NORMAL_RESET, NULL);\n\n\t \n\tassert_normal(vcpu);\n\t \n\tassert_normal_noclear(vcpu);\n\tassert_initial_noclear(vcpu);\n\n\tkvm_vm_free(vm);\n}\n\nstatic void test_initial(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tksft_print_msg(\"Testing initial reset\\n\");\n\tvm = create_vm(&vcpu);\n\n\tvcpu_run(vcpu);\n\n\tinject_irq(vcpu);\n\n\tvcpu_ioctl(vcpu, KVM_S390_INITIAL_RESET, NULL);\n\n\t \n\tassert_normal(vcpu);\n\tassert_initial(vcpu);\n\t \n\tassert_initial_noclear(vcpu);\n\n\tkvm_vm_free(vm);\n}\n\nstatic void test_clear(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tksft_print_msg(\"Testing clear reset\\n\");\n\tvm = create_vm(&vcpu);\n\n\tvcpu_run(vcpu);\n\n\tinject_irq(vcpu);\n\n\tvcpu_ioctl(vcpu, KVM_S390_CLEAR_RESET, NULL);\n\n\t \n\tassert_normal(vcpu);\n\tassert_initial(vcpu);\n\tassert_clear(vcpu);\n\n\tkvm_vm_free(vm);\n}\n\nstruct testdef {\n\tconst char *name;\n\tvoid (*test)(void);\n\tbool needs_cap;\n} testlist[] = {\n\t{ \"initial\", test_initial, false },\n\t{ \"normal\", test_normal, true },\n\t{ \"clear\", test_clear, true },\n};\n\nint main(int argc, char *argv[])\n{\n\tbool has_s390_vcpu_resets = kvm_check_cap(KVM_CAP_S390_VCPU_RESETS);\n\tint idx;\n\n\tksft_print_header();\n\tksft_set_plan(ARRAY_SIZE(testlist));\n\n\tfor (idx = 0; idx < ARRAY_SIZE(testlist); idx++) {\n\t\tif (!testlist[idx].needs_cap || has_s390_vcpu_resets) {\n\t\t\ttestlist[idx].test();\n\t\t\tksft_test_result_pass(\"%s\\n\", testlist[idx].name);\n\t\t} else {\n\t\t\tksft_test_result_skip(\"%s - no VCPU_RESETS capability\\n\",\n\t\t\t\t\t      testlist[idx].name);\n\t\t}\n\t}\n\n\tksft_finished();\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}