{
  "module_name": "debug_test.c",
  "hash_id": "d866aaa8031c6a9fd3c10bacd8181fa045092e888ec9432af4cf1020f7b9ddd9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/s390x/debug_test.c",
  "human_readable_source": "\n \n#include \"kvm_util.h\"\n#include \"test_util.h\"\n\n#include <linux/kvm.h>\n\n#define __LC_SVC_NEW_PSW 0x1c0\n#define __LC_PGM_NEW_PSW 0x1d0\n#define ICPT_INSTRUCTION 0x04\n#define IPA0_DIAG 0x8300\n#define PGM_SPECIFICATION 0x06\n\n \nextern char int_handler[];\nasm(\"int_handler:\\n\"\n    \"j .\\n\");\n\nstatic struct kvm_vm *test_step_int_1(struct kvm_vcpu **vcpu, void *guest_code,\n\t\t\t\t      size_t new_psw_off, uint64_t *new_psw)\n{\n\tstruct kvm_guest_debug debug = {};\n\tstruct kvm_regs regs;\n\tstruct kvm_vm *vm;\n\tchar *lowcore;\n\n\tvm = vm_create_with_one_vcpu(vcpu, guest_code);\n\tlowcore = addr_gpa2hva(vm, 0);\n\tnew_psw[0] = (*vcpu)->run->psw_mask;\n\tnew_psw[1] = (uint64_t)int_handler;\n\tmemcpy(lowcore + new_psw_off, new_psw, 16);\n\tvcpu_regs_get(*vcpu, &regs);\n\tregs.gprs[2] = -1;\n\tvcpu_regs_set(*vcpu, &regs);\n\tdebug.control = KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_SINGLESTEP;\n\tvcpu_guest_debug_set(*vcpu, &debug);\n\tvcpu_run(*vcpu);\n\n\treturn vm;\n}\n\nstatic void test_step_int(void *guest_code, size_t new_psw_off)\n{\n\tstruct kvm_vcpu *vcpu;\n\tuint64_t new_psw[2];\n\tstruct kvm_vm *vm;\n\n\tvm = test_step_int_1(&vcpu, guest_code, new_psw_off, new_psw);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_DEBUG);\n\tTEST_ASSERT_EQ(vcpu->run->psw_mask, new_psw[0]);\n\tTEST_ASSERT_EQ(vcpu->run->psw_addr, new_psw[1]);\n\tkvm_vm_free(vm);\n}\n\n \nextern char test_step_pgm_guest_code[];\nasm(\"test_step_pgm_guest_code:\\n\"\n    \".insn rr,0x1d00,%r1,%r0 /* dr %r1,%r0 */\\n\"\n    \"j .\\n\");\n\nstatic void test_step_pgm(void)\n{\n\ttest_step_int(test_step_pgm_guest_code, __LC_PGM_NEW_PSW);\n}\n\n \nextern char test_step_pgm_diag_guest_code[];\nasm(\"test_step_pgm_diag_guest_code:\\n\"\n    \"diag %r0,%r0,0\\n\"\n    \"j .\\n\");\n\nstatic void test_step_pgm_diag(void)\n{\n\tstruct kvm_s390_irq irq = {\n\t\t.type = KVM_S390_PROGRAM_INT,\n\t\t.u.pgm.code = PGM_SPECIFICATION,\n\t};\n\tstruct kvm_vcpu *vcpu;\n\tuint64_t new_psw[2];\n\tstruct kvm_vm *vm;\n\n\tvm = test_step_int_1(&vcpu, test_step_pgm_diag_guest_code,\n\t\t\t     __LC_PGM_NEW_PSW, new_psw);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_S390_SIEIC);\n\tTEST_ASSERT_EQ(vcpu->run->s390_sieic.icptcode, ICPT_INSTRUCTION);\n\tTEST_ASSERT_EQ(vcpu->run->s390_sieic.ipa & 0xff00, IPA0_DIAG);\n\tvcpu_ioctl(vcpu, KVM_S390_IRQ, &irq);\n\tvcpu_run(vcpu);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_DEBUG);\n\tTEST_ASSERT_EQ(vcpu->run->psw_mask, new_psw[0]);\n\tTEST_ASSERT_EQ(vcpu->run->psw_addr, new_psw[1]);\n\tkvm_vm_free(vm);\n}\n\n \nextern char test_step_pgm_iske_guest_code[];\nasm(\"test_step_pgm_iske_guest_code:\\n\"\n    \"iske %r2,%r2\\n\"\n    \"j .\\n\");\n\nstatic void test_step_pgm_iske(void)\n{\n\ttest_step_int(test_step_pgm_iske_guest_code, __LC_PGM_NEW_PSW);\n}\n\n \nextern char test_step_pgm_lctl_guest_code[];\nasm(\"test_step_pgm_lctl_guest_code:\\n\"\n    \"lctl %c0,%c0,1\\n\"\n    \"j .\\n\");\n\nstatic void test_step_pgm_lctl(void)\n{\n\ttest_step_int(test_step_pgm_lctl_guest_code, __LC_PGM_NEW_PSW);\n}\n\n \nextern char test_step_svc_guest_code[];\nasm(\"test_step_svc_guest_code:\\n\"\n    \"svc 0\\n\"\n    \"j .\\n\");\n\nstatic void test_step_svc(void)\n{\n\ttest_step_int(test_step_svc_guest_code, __LC_SVC_NEW_PSW);\n}\n\n \nstatic struct testdef {\n\tconst char *name;\n\tvoid (*test)(void);\n} testlist[] = {\n\t{ \"single-step pgm\", test_step_pgm },\n\t{ \"single-step pgm caused by diag\", test_step_pgm_diag },\n\t{ \"single-step pgm caused by iske\", test_step_pgm_iske },\n\t{ \"single-step pgm caused by lctl\", test_step_pgm_lctl },\n\t{ \"single-step svc\", test_step_svc },\n};\n\nint main(int argc, char *argv[])\n{\n\tint idx;\n\n\tksft_print_header();\n\tksft_set_plan(ARRAY_SIZE(testlist));\n\tfor (idx = 0; idx < ARRAY_SIZE(testlist); idx++) {\n\t\ttestlist[idx].test();\n\t\tksft_test_result_pass(\"%s\\n\", testlist[idx].name);\n\t}\n\tksft_finished();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}