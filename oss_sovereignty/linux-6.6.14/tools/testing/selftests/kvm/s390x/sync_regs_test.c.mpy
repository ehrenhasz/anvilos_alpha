{
  "module_name": "sync_regs_test.c",
  "hash_id": "d687a434fd60550ac17103b0d17729f9939b2b368dc02674e5476047c504bd4f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/s390x/sync_regs_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"diag318_test_handler.h\"\n#include \"kselftest.h\"\n\nstatic void guest_code(void)\n{\n\t \n\tasm volatile (\n\t\t\"0:\tdiag 0,0,0x501\\n\"\n\t\t\"\tahi 11,1\\n\"\n\t\t\"\tj 0b\\n\"\n\t);\n}\n\n#define REG_COMPARE(reg) \\\n\tTEST_ASSERT(left->reg == right->reg, \\\n\t\t    \"Register \" #reg \\\n\t\t    \" values did not match: 0x%llx, 0x%llx\\n\", \\\n\t\t    left->reg, right->reg)\n\n#define REG_COMPARE32(reg) \\\n\tTEST_ASSERT(left->reg == right->reg, \\\n\t\t    \"Register \" #reg \\\n\t\t    \" values did not match: 0x%x, 0x%x\\n\", \\\n\t\t    left->reg, right->reg)\n\n\nstatic void compare_regs(struct kvm_regs *left, struct kvm_sync_regs *right)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tREG_COMPARE(gprs[i]);\n}\n\nstatic void compare_sregs(struct kvm_sregs *left, struct kvm_sync_regs *right)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tREG_COMPARE32(acrs[i]);\n\n\tfor (i = 0; i < 16; i++)\n\t\tREG_COMPARE(crs[i]);\n}\n\n#undef REG_COMPARE\n\n#define TEST_SYNC_FIELDS   (KVM_SYNC_GPRS|KVM_SYNC_ACRS|KVM_SYNC_CRS|KVM_SYNC_DIAG318)\n#define INVALID_SYNC_FIELD 0x80000000\n\nvoid test_read_invalid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tint rv;\n\n\t \n\trun->kvm_valid_regs = INVALID_SYNC_FIELD;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv < 0 && errno == EINVAL,\n\t\t    \"Invalid kvm_valid_regs did not cause expected KVM_RUN error: %d\\n\",\n\t\t    rv);\n\trun->kvm_valid_regs = 0;\n\n\trun->kvm_valid_regs = INVALID_SYNC_FIELD | TEST_SYNC_FIELDS;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv < 0 && errno == EINVAL,\n\t\t    \"Invalid kvm_valid_regs did not cause expected KVM_RUN error: %d\\n\",\n\t\t    rv);\n\trun->kvm_valid_regs = 0;\n}\n\nvoid test_set_invalid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tint rv;\n\n\t \n\trun->kvm_dirty_regs = INVALID_SYNC_FIELD;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv < 0 && errno == EINVAL,\n\t\t    \"Invalid kvm_dirty_regs did not cause expected KVM_RUN error: %d\\n\",\n\t\t    rv);\n\trun->kvm_dirty_regs = 0;\n\n\trun->kvm_dirty_regs = INVALID_SYNC_FIELD | TEST_SYNC_FIELDS;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv < 0 && errno == EINVAL,\n\t\t    \"Invalid kvm_dirty_regs did not cause expected KVM_RUN error: %d\\n\",\n\t\t    rv);\n\trun->kvm_dirty_regs = 0;\n}\n\nvoid test_req_and_verify_all_valid_regs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_sregs sregs;\n\tstruct kvm_regs regs;\n\tint rv;\n\n\t \n\trun->kvm_valid_regs = TEST_SYNC_FIELDS;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv == 0, \"vcpu_run failed: %d\\n\", rv);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_S390_SIEIC);\n\tTEST_ASSERT(run->s390_sieic.icptcode == 4 &&\n\t\t    (run->s390_sieic.ipa >> 8) == 0x83 &&\n\t\t    (run->s390_sieic.ipb >> 16) == 0x501,\n\t\t    \"Unexpected interception code: ic=%u, ipa=0x%x, ipb=0x%x\\n\",\n\t\t    run->s390_sieic.icptcode, run->s390_sieic.ipa,\n\t\t    run->s390_sieic.ipb);\n\n\tvcpu_regs_get(vcpu, &regs);\n\tcompare_regs(&regs, &run->s.regs);\n\n\tvcpu_sregs_get(vcpu, &sregs);\n\tcompare_sregs(&sregs, &run->s.regs);\n}\n\nvoid test_set_and_verify_various_reg_values(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_sregs sregs;\n\tstruct kvm_regs regs;\n\tint rv;\n\n\t \n\trun->s.regs.gprs[11] = 0xBAD1DEA;\n\trun->s.regs.acrs[0] = 1 << 11;\n\n\trun->kvm_valid_regs = TEST_SYNC_FIELDS;\n\trun->kvm_dirty_regs = KVM_SYNC_GPRS | KVM_SYNC_ACRS;\n\n\tif (get_diag318_info() > 0) {\n\t\trun->s.regs.diag318 = get_diag318_info();\n\t\trun->kvm_dirty_regs |= KVM_SYNC_DIAG318;\n\t}\n\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv == 0, \"vcpu_run failed: %d\\n\", rv);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_S390_SIEIC);\n\tTEST_ASSERT(run->s.regs.gprs[11] == 0xBAD1DEA + 1,\n\t\t    \"r11 sync regs value incorrect 0x%llx.\",\n\t\t    run->s.regs.gprs[11]);\n\tTEST_ASSERT(run->s.regs.acrs[0]  == 1 << 11,\n\t\t    \"acr0 sync regs value incorrect 0x%x.\",\n\t\t    run->s.regs.acrs[0]);\n\tTEST_ASSERT(run->s.regs.diag318 == get_diag318_info(),\n\t\t    \"diag318 sync regs value incorrect 0x%llx.\",\n\t\t    run->s.regs.diag318);\n\n\tvcpu_regs_get(vcpu, &regs);\n\tcompare_regs(&regs, &run->s.regs);\n\n\tvcpu_sregs_get(vcpu, &sregs);\n\tcompare_sregs(&sregs, &run->s.regs);\n}\n\nvoid test_clear_kvm_dirty_regs_bits(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tint rv;\n\n\t \n\trun->kvm_valid_regs = TEST_SYNC_FIELDS;\n\trun->kvm_dirty_regs = 0;\n\trun->s.regs.gprs[11] = 0xDEADBEEF;\n\trun->s.regs.diag318 = 0x4B1D;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv == 0, \"vcpu_run failed: %d\\n\", rv);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_S390_SIEIC);\n\tTEST_ASSERT(run->s.regs.gprs[11] != 0xDEADBEEF,\n\t\t    \"r11 sync regs value incorrect 0x%llx.\",\n\t\t    run->s.regs.gprs[11]);\n\tTEST_ASSERT(run->s.regs.diag318 != 0x4B1D,\n\t\t    \"diag318 sync regs value incorrect 0x%llx.\",\n\t\t    run->s.regs.diag318);\n}\n\nstruct testdef {\n\tconst char *name;\n\tvoid (*test)(struct kvm_vcpu *vcpu);\n} testlist[] = {\n\t{ \"read invalid\", test_read_invalid },\n\t{ \"set invalid\", test_set_invalid },\n\t{ \"request+verify all valid regs\", test_req_and_verify_all_valid_regs },\n\t{ \"set+verify various regs\", test_set_and_verify_various_reg_values },\n\t{ \"clear kvm_dirty_regs bits\", test_clear_kvm_dirty_regs_bits },\n};\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tint idx;\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_SYNC_REGS));\n\n\tksft_print_header();\n\n\tksft_set_plan(ARRAY_SIZE(testlist));\n\n\t \n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(testlist); idx++) {\n\t\ttestlist[idx].test(vcpu);\n\t\tksft_test_result_pass(\"%s\\n\", testlist[idx].name);\n\t}\n\n\tkvm_vm_free(vm);\n\n\tksft_finished();\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}