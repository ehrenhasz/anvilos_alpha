{
  "module_name": "tprot.c",
  "hash_id": "a03d5172139368b32c4b0bd2e1c4c62a4c0bbe484d7931825e4d9657e246a05e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/s390x/tprot.c",
  "human_readable_source": "\n \n#include <sys/mman.h>\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"kselftest.h\"\n\n#define PAGE_SHIFT 12\n#define PAGE_SIZE (1 << PAGE_SHIFT)\n#define CR0_FETCH_PROTECTION_OVERRIDE\t(1UL << (63 - 38))\n#define CR0_STORAGE_PROTECTION_OVERRIDE\t(1UL << (63 - 39))\n\nstatic __aligned(PAGE_SIZE) uint8_t pages[2][PAGE_SIZE];\nstatic uint8_t *const page_store_prot = pages[0];\nstatic uint8_t *const page_fetch_prot = pages[1];\n\n \nstatic int set_storage_key(void *addr, uint8_t key)\n{\n\tint not_mapped = 0;\n\n\tasm volatile (\n\t\t       \"lra\t%[addr], 0(0,%[addr])\\n\"\n\t\t\"\tjz\t0f\\n\"\n\t\t\"\tllill\t%[not_mapped],1\\n\"\n\t\t\"\tj\t1f\\n\"\n\t\t\"0:\tsske\t%[key], %[addr]\\n\"\n\t\t\"1:\"\n\t\t: [addr] \"+&a\" (addr), [not_mapped] \"+r\" (not_mapped)\n\t\t: [key] \"r\" (key)\n\t\t: \"cc\"\n\t);\n\treturn -not_mapped;\n}\n\nenum permission {\n\tREAD_WRITE = 0,\n\tREAD = 1,\n\tRW_PROTECTED = 2,\n\tTRANSL_UNAVAIL = 3,\n};\n\nstatic enum permission test_protection(void *addr, uint8_t key)\n{\n\tuint64_t mask;\n\n\tasm volatile (\n\t\t       \"tprot\t%[addr], 0(%[key])\\n\"\n\t\t\"\tipm\t%[mask]\\n\"\n\t\t: [mask] \"=r\" (mask)\n\t\t: [addr] \"Q\" (*(char *)addr),\n\t\t  [key] \"a\" (key)\n\t\t: \"cc\"\n\t);\n\n\treturn (enum permission)(mask >> 28);\n}\n\nenum stage {\n\tSTAGE_INIT_SIMPLE,\n\tTEST_SIMPLE,\n\tSTAGE_INIT_FETCH_PROT_OVERRIDE,\n\tTEST_FETCH_PROT_OVERRIDE,\n\tTEST_STORAGE_PROT_OVERRIDE,\n\tSTAGE_END\t \n};\n\nstruct test {\n\tenum stage stage;\n\tvoid *addr;\n\tuint8_t key;\n\tenum permission expected;\n} tests[] = {\n\t \n\t \n\t \n\t{ TEST_SIMPLE, page_store_prot, 0x00, READ_WRITE },\n\t \n\t{ TEST_SIMPLE, page_store_prot, 0x10, READ_WRITE },\n\t \n\t{ TEST_SIMPLE, page_store_prot, 0x20, READ },\n\t \n\t{ TEST_SIMPLE, page_fetch_prot, 0x00, READ_WRITE },\n\t \n\t{ TEST_SIMPLE, page_fetch_prot, 0x90, READ_WRITE },\n\t \n\t{ TEST_SIMPLE, page_fetch_prot, 0x10, RW_PROTECTED },\n\t \n\t{ TEST_SIMPLE, (void *)0x00, 0x10, TRANSL_UNAVAIL },\n\t \n\t \n\t{ TEST_FETCH_PROT_OVERRIDE, (void *)0x00, 0x10, READ },\n\t \n\t{ TEST_FETCH_PROT_OVERRIDE, (void *)2049, 0x10, RW_PROTECTED },\n\t \n\t \n\t{ TEST_STORAGE_PROT_OVERRIDE, page_fetch_prot, 0x10, READ_WRITE },\n\t \n\t{ TEST_STORAGE_PROT_OVERRIDE, page_store_prot, 0x20, READ },\n\t \n\t{ TEST_STORAGE_PROT_OVERRIDE, (void *)2049, 0x10, READ_WRITE },\n\t \n\t{ STAGE_END, 0, 0, 0 },\n};\n\nstatic enum stage perform_next_stage(int *i, bool mapped_0)\n{\n\tenum stage stage = tests[*i].stage;\n\tenum permission result;\n\tbool skip;\n\n\tfor (; tests[*i].stage == stage; (*i)++) {\n\t\t \n\t\tskip = tests[*i].addr < (void *)4096 &&\n\t\t       tests[*i].expected != TRANSL_UNAVAIL &&\n\t\t       !mapped_0;\n\t\tif (!skip) {\n\t\t\tresult = test_protection(tests[*i].addr, tests[*i].key);\n\t\t\t__GUEST_ASSERT(result == tests[*i].expected,\n\t\t\t\t       \"Wanted %u, got %u, for i = %u\",\n\t\t\t\t       tests[*i].expected, result, *i);\n\t\t}\n\t}\n\treturn stage;\n}\n\nstatic void guest_code(void)\n{\n\tbool mapped_0;\n\tint i = 0;\n\n\tGUEST_ASSERT_EQ(set_storage_key(page_store_prot, 0x10), 0);\n\tGUEST_ASSERT_EQ(set_storage_key(page_fetch_prot, 0x98), 0);\n\tGUEST_SYNC(STAGE_INIT_SIMPLE);\n\tGUEST_SYNC(perform_next_stage(&i, false));\n\n\t \n\tmapped_0 = !set_storage_key((void *)0, 0x98);\n\tGUEST_SYNC(STAGE_INIT_FETCH_PROT_OVERRIDE);\n\tGUEST_SYNC(perform_next_stage(&i, mapped_0));\n\n\t \n\tGUEST_SYNC(perform_next_stage(&i, mapped_0));\n}\n\n#define HOST_SYNC_NO_TAP(vcpup, stage)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstruct kvm_vcpu *__vcpu = (vcpup);\t\t\t\\\n\tstruct ucall uc;\t\t\t\t\t\\\n\tint __stage = (stage);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tvcpu_run(__vcpu);\t\t\t\t\t\\\n\tget_ucall(__vcpu, &uc);\t\t\t\t\t\\\n\tif (uc.cmd == UCALL_ABORT)\t\t\t\t\\\n\t\tREPORT_GUEST_ASSERT(uc);\t\t\t\\\n\tTEST_ASSERT_EQ(uc.cmd, UCALL_SYNC);\t\t\t\\\n\tTEST_ASSERT_EQ(uc.args[1], __stage);\t\t\t\\\n})\n\n#define HOST_SYNC(vcpu, stage)\t\t\t\\\n({\t\t\t\t\t\t\\\n\tHOST_SYNC_NO_TAP(vcpu, stage);\t\t\\\n\tksft_test_result_pass(\"\" #stage \"\\n\");\t\\\n})\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct kvm_run *run;\n\tvm_vaddr_t guest_0_page;\n\n\tksft_print_header();\n\tksft_set_plan(STAGE_END);\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\trun = vcpu->run;\n\n\tHOST_SYNC(vcpu, STAGE_INIT_SIMPLE);\n\tmprotect(addr_gva2hva(vm, (vm_vaddr_t)pages), PAGE_SIZE * 2, PROT_READ);\n\tHOST_SYNC(vcpu, TEST_SIMPLE);\n\n\tguest_0_page = vm_vaddr_alloc(vm, PAGE_SIZE, 0);\n\tif (guest_0_page != 0) {\n\t\t \n\t\tHOST_SYNC_NO_TAP(vcpu, STAGE_INIT_FETCH_PROT_OVERRIDE);\n\t\tksft_test_result_skip(\"STAGE_INIT_FETCH_PROT_OVERRIDE - \"\n\t\t\t\t      \"Did not allocate page at 0\\n\");\n\t} else {\n\t\tHOST_SYNC(vcpu, STAGE_INIT_FETCH_PROT_OVERRIDE);\n\t}\n\tif (guest_0_page == 0)\n\t\tmprotect(addr_gva2hva(vm, (vm_vaddr_t)0), PAGE_SIZE, PROT_READ);\n\trun->s.regs.crs[0] |= CR0_FETCH_PROTECTION_OVERRIDE;\n\trun->kvm_dirty_regs = KVM_SYNC_CRS;\n\tHOST_SYNC(vcpu, TEST_FETCH_PROT_OVERRIDE);\n\n\trun->s.regs.crs[0] |= CR0_STORAGE_PROTECTION_OVERRIDE;\n\trun->kvm_dirty_regs = KVM_SYNC_CRS;\n\tHOST_SYNC(vcpu, TEST_STORAGE_PROT_OVERRIDE);\n\n\tkvm_vm_free(vm);\n\n\tksft_finished();\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}