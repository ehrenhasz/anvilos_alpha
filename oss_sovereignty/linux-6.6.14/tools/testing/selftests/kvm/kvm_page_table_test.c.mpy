{
  "module_name": "kvm_page_table_test.c",
  "hash_id": "f070d49470c0369d40f209d8c5b91b50d8022ed2fb02d7a6b735d7077a3ae496",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/kvm_page_table_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"guest_modes.h\"\n\n#define TEST_MEM_SLOT_INDEX             1\n\n \n#define DEFAULT_TEST_MEM_SIZE\t\t(1 << 30)\n\n \n#define DEFAULT_GUEST_TEST_MEM\t\t0xc0000000\n\n \nenum test_stage {\n\tKVM_BEFORE_MAPPINGS,\n\tKVM_CREATE_MAPPINGS,\n\tKVM_UPDATE_MAPPINGS,\n\tKVM_ADJUST_MAPPINGS,\n\tNUM_TEST_STAGES,\n};\n\nstatic const char * const test_stage_string[] = {\n\t\"KVM_BEFORE_MAPPINGS\",\n\t\"KVM_CREATE_MAPPINGS\",\n\t\"KVM_UPDATE_MAPPINGS\",\n\t\"KVM_ADJUST_MAPPINGS\",\n};\n\nstruct test_args {\n\tstruct kvm_vm *vm;\n\tuint64_t guest_test_virt_mem;\n\tuint64_t host_page_size;\n\tuint64_t host_num_pages;\n\tuint64_t large_page_size;\n\tuint64_t large_num_pages;\n\tuint64_t host_pages_per_lpage;\n\tenum vm_mem_backing_src_type src_type;\n\tstruct kvm_vcpu *vcpus[KVM_MAX_VCPUS];\n};\n\n \nstatic enum test_stage guest_test_stage;\n\n \nstatic uint32_t nr_vcpus = 1;\nstatic struct test_args test_args;\nstatic enum test_stage *current_stage;\nstatic bool host_quit;\n\n \nstatic sem_t test_stage_updated;\nstatic sem_t test_stage_completed;\n\n \nstatic uint64_t guest_test_phys_mem;\n\n \nstatic uint64_t guest_test_virt_mem = DEFAULT_GUEST_TEST_MEM;\n\nstatic void guest_code(bool do_write)\n{\n\tstruct test_args *p = &test_args;\n\tenum test_stage *current_stage = &guest_test_stage;\n\tuint64_t addr;\n\tint i, j;\n\n\twhile (true) {\n\t\taddr = p->guest_test_virt_mem;\n\n\t\tswitch (READ_ONCE(*current_stage)) {\n\t\t \n\t\tcase KVM_BEFORE_MAPPINGS:\n\t\t\tbreak;\n\n\t\t \n\t\tcase KVM_CREATE_MAPPINGS:\n\t\t\tfor (i = 0; i < p->large_num_pages; i++) {\n\t\t\t\tif (do_write)\n\t\t\t\t\t*(uint64_t *)addr = 0x0123456789ABCDEF;\n\t\t\t\telse\n\t\t\t\t\tREAD_ONCE(*(uint64_t *)addr);\n\n\t\t\t\taddr += p->large_page_size;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase KVM_UPDATE_MAPPINGS:\n\t\t\tif (p->src_type == VM_MEM_SRC_ANONYMOUS) {\n\t\t\t\tfor (i = 0; i < p->host_num_pages; i++) {\n\t\t\t\t\t*(uint64_t *)addr = 0x0123456789ABCDEF;\n\t\t\t\t\taddr += p->host_page_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < p->large_num_pages; i++) {\n\t\t\t\t \n\t\t\t\t*(uint64_t *)addr = 0x0123456789ABCDEF;\n\n\t\t\t\t \n\t\t\t\taddr += p->large_page_size / 2;\n\t\t\t\tfor (j = 0; j < p->host_pages_per_lpage / 2; j++) {\n\t\t\t\t\tREAD_ONCE(*(uint64_t *)addr);\n\t\t\t\t\taddr += p->host_page_size;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase KVM_ADJUST_MAPPINGS:\n\t\t\tfor (i = 0; i < p->host_num_pages; i++) {\n\t\t\t\tREAD_ONCE(*(uint64_t *)addr);\n\t\t\t\taddr += p->host_page_size;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGUEST_ASSERT(0);\n\t\t}\n\n\t\tGUEST_SYNC(1);\n\t}\n}\n\nstatic void *vcpu_worker(void *data)\n{\n\tstruct kvm_vcpu *vcpu = data;\n\tbool do_write = !(vcpu->id % 2);\n\tstruct timespec start;\n\tstruct timespec ts_diff;\n\tenum test_stage stage;\n\tint ret;\n\n\tvcpu_args_set(vcpu, 1, do_write);\n\n\twhile (!READ_ONCE(host_quit)) {\n\t\tret = sem_wait(&test_stage_updated);\n\t\tTEST_ASSERT(ret == 0, \"Error in sem_wait\");\n\n\t\tif (READ_ONCE(host_quit))\n\t\t\treturn NULL;\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &start);\n\t\tret = _vcpu_run(vcpu);\n\t\tts_diff = timespec_elapsed(start);\n\n\t\tTEST_ASSERT(ret == 0, \"vcpu_run failed: %d\\n\", ret);\n\t\tTEST_ASSERT(get_ucall(vcpu, NULL) == UCALL_SYNC,\n\t\t\t    \"Invalid guest sync status: exit_reason=%s\\n\",\n\t\t\t    exit_reason_str(vcpu->run->exit_reason));\n\n\t\tpr_debug(\"Got sync event from vCPU %d\\n\", vcpu->id);\n\t\tstage = READ_ONCE(*current_stage);\n\n\t\t \n\t\tpr_debug(\"vCPU %d has completed stage %s\\n\"\n\t\t\t \"execution time is: %ld.%.9lds\\n\\n\",\n\t\t\t vcpu->id, test_stage_string[stage],\n\t\t\t ts_diff.tv_sec, ts_diff.tv_nsec);\n\n\t\tret = sem_post(&test_stage_completed);\n\t\tTEST_ASSERT(ret == 0, \"Error in sem_post\");\n\t}\n\n\treturn NULL;\n}\n\nstruct test_params {\n\tuint64_t phys_offset;\n\tuint64_t test_mem_size;\n\tenum vm_mem_backing_src_type src_type;\n};\n\nstatic struct kvm_vm *pre_init_before_test(enum vm_guest_mode mode, void *arg)\n{\n\tint ret;\n\tstruct test_params *p = arg;\n\tenum vm_mem_backing_src_type src_type = p->src_type;\n\tuint64_t large_page_size = get_backing_src_pagesz(src_type);\n\tuint64_t guest_page_size = vm_guest_mode_params[mode].page_size;\n\tuint64_t host_page_size = getpagesize();\n\tuint64_t test_mem_size = p->test_mem_size;\n\tuint64_t guest_num_pages;\n\tuint64_t alignment;\n\tvoid *host_test_mem;\n\tstruct kvm_vm *vm;\n\n\t \n\talignment = max(large_page_size, guest_page_size);\n\ttest_mem_size = (test_mem_size + alignment - 1) & ~(alignment - 1);\n\n\t \n\tguest_num_pages = test_mem_size / guest_page_size;\n\tvm = __vm_create_with_vcpus(mode, nr_vcpus, guest_num_pages,\n\t\t\t\t    guest_code, test_args.vcpus);\n\n\t \n\tif (!p->phys_offset)\n\t\tguest_test_phys_mem = (vm->max_gfn - guest_num_pages) *\n\t\t\t\t       guest_page_size;\n\telse\n\t\tguest_test_phys_mem = p->phys_offset;\n#ifdef __s390x__\n\talignment = max(0x100000UL, alignment);\n#endif\n\tguest_test_phys_mem = align_down(guest_test_phys_mem, alignment);\n\n\t \n\ttest_args.vm = vm;\n\ttest_args.guest_test_virt_mem = guest_test_virt_mem;\n\ttest_args.host_page_size = host_page_size;\n\ttest_args.host_num_pages = test_mem_size / host_page_size;\n\ttest_args.large_page_size = large_page_size;\n\ttest_args.large_num_pages = test_mem_size / large_page_size;\n\ttest_args.host_pages_per_lpage = large_page_size / host_page_size;\n\ttest_args.src_type = src_type;\n\n\t \n\tvm_userspace_mem_region_add(vm, src_type, guest_test_phys_mem,\n\t\t\t\t    TEST_MEM_SLOT_INDEX, guest_num_pages, 0);\n\n\t \n\tvirt_map(vm, guest_test_virt_mem, guest_test_phys_mem, guest_num_pages);\n\n\t \n\thost_test_mem = addr_gpa2hva(vm, (vm_paddr_t)guest_test_phys_mem);\n\n\t \n\tsync_global_to_guest(vm, test_args);\n\n\tret = sem_init(&test_stage_updated, 0, 0);\n\tTEST_ASSERT(ret == 0, \"Error in sem_init\");\n\n\tret = sem_init(&test_stage_completed, 0, 0);\n\tTEST_ASSERT(ret == 0, \"Error in sem_init\");\n\n\tcurrent_stage = addr_gva2hva(vm, (vm_vaddr_t)(&guest_test_stage));\n\t*current_stage = NUM_TEST_STAGES;\n\n\tpr_info(\"Testing guest mode: %s\\n\", vm_guest_mode_string(mode));\n\tpr_info(\"Testing memory backing src type: %s\\n\",\n\t\tvm_mem_backing_src_alias(src_type)->name);\n\tpr_info(\"Testing memory backing src granularity: 0x%lx\\n\",\n\t\tlarge_page_size);\n\tpr_info(\"Testing memory size(aligned): 0x%lx\\n\", test_mem_size);\n\tpr_info(\"Guest physical test memory offset: 0x%lx\\n\",\n\t\tguest_test_phys_mem);\n\tpr_info(\"Host  virtual  test memory offset: 0x%lx\\n\",\n\t\t(uint64_t)host_test_mem);\n\tpr_info(\"Number of testing vCPUs: %d\\n\", nr_vcpus);\n\n\treturn vm;\n}\n\nstatic void vcpus_complete_new_stage(enum test_stage stage)\n{\n\tint ret;\n\tint vcpus;\n\n\t \n\tfor (vcpus = 0; vcpus < nr_vcpus; vcpus++) {\n\t\tret = sem_post(&test_stage_updated);\n\t\tTEST_ASSERT(ret == 0, \"Error in sem_post\");\n\t}\n\tpr_debug(\"All vcpus have been notified to continue\\n\");\n\n\t \n\tfor (vcpus = 0; vcpus < nr_vcpus; vcpus++) {\n\t\tret = sem_wait(&test_stage_completed);\n\t\tTEST_ASSERT(ret == 0, \"Error in sem_wait\");\n\n\t\tpr_debug(\"%d vcpus have completed stage %s\\n\",\n\t\t\t vcpus + 1, test_stage_string[stage]);\n\t}\n\n\tpr_debug(\"All vcpus have completed stage %s\\n\",\n\t\t test_stage_string[stage]);\n}\n\nstatic void run_test(enum vm_guest_mode mode, void *arg)\n{\n\tpthread_t *vcpu_threads;\n\tstruct kvm_vm *vm;\n\tstruct timespec start;\n\tstruct timespec ts_diff;\n\tint ret, i;\n\n\t \n\tvm = pre_init_before_test(mode, arg);\n\n\tvcpu_threads = malloc(nr_vcpus * sizeof(*vcpu_threads));\n\tTEST_ASSERT(vcpu_threads, \"Memory allocation failed\");\n\n\thost_quit = false;\n\t*current_stage = KVM_BEFORE_MAPPINGS;\n\n\tfor (i = 0; i < nr_vcpus; i++)\n\t\tpthread_create(&vcpu_threads[i], NULL, vcpu_worker,\n\t\t\t       test_args.vcpus[i]);\n\n\tvcpus_complete_new_stage(*current_stage);\n\tpr_info(\"Started all vCPUs successfully\\n\");\n\n\t \n\t*current_stage = KVM_CREATE_MAPPINGS;\n\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\tvcpus_complete_new_stage(*current_stage);\n\tts_diff = timespec_elapsed(start);\n\n\tpr_info(\"KVM_CREATE_MAPPINGS: total execution time: %ld.%.9lds\\n\\n\",\n\t\tts_diff.tv_sec, ts_diff.tv_nsec);\n\n\t \n\tvm_mem_region_set_flags(vm, TEST_MEM_SLOT_INDEX,\n\t\t\t\tKVM_MEM_LOG_DIRTY_PAGES);\n\n\t*current_stage = KVM_UPDATE_MAPPINGS;\n\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\tvcpus_complete_new_stage(*current_stage);\n\tts_diff = timespec_elapsed(start);\n\n\tpr_info(\"KVM_UPDATE_MAPPINGS: total execution time: %ld.%.9lds\\n\\n\",\n\t\tts_diff.tv_sec, ts_diff.tv_nsec);\n\n\t \n\tvm_mem_region_set_flags(vm, TEST_MEM_SLOT_INDEX, 0);\n\n\t*current_stage = KVM_ADJUST_MAPPINGS;\n\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\tvcpus_complete_new_stage(*current_stage);\n\tts_diff = timespec_elapsed(start);\n\n\tpr_info(\"KVM_ADJUST_MAPPINGS: total execution time: %ld.%.9lds\\n\\n\",\n\t\tts_diff.tv_sec, ts_diff.tv_nsec);\n\n\t \n\thost_quit = true;\n\tfor (i = 0; i < nr_vcpus; i++) {\n\t\tret = sem_post(&test_stage_updated);\n\t\tTEST_ASSERT(ret == 0, \"Error in sem_post\");\n\t}\n\n\tfor (i = 0; i < nr_vcpus; i++)\n\t\tpthread_join(vcpu_threads[i], NULL);\n\n\tret = sem_destroy(&test_stage_updated);\n\tTEST_ASSERT(ret == 0, \"Error in sem_destroy\");\n\n\tret = sem_destroy(&test_stage_completed);\n\tTEST_ASSERT(ret == 0, \"Error in sem_destroy\");\n\n\tfree(vcpu_threads);\n\tkvm_vm_free(vm);\n}\n\nstatic void help(char *name)\n{\n\tputs(\"\");\n\tprintf(\"usage: %s [-h] [-p offset] [-m mode] \"\n\t       \"[-b mem-size] [-v vcpus] [-s mem-type]\\n\", name);\n\tputs(\"\");\n\tprintf(\" -p: specify guest physical test memory offset\\n\"\n\t       \"     Warning: a low offset can conflict with the loaded test code.\\n\");\n\tguest_modes_help();\n\tprintf(\" -b: specify size of the memory region for testing. e.g. 10M or 3G.\\n\"\n\t       \"     (default: 1G)\\n\");\n\tprintf(\" -v: specify the number of vCPUs to run\\n\"\n\t       \"     (default: 1)\\n\");\n\tbacking_src_help(\"-s\");\n\tputs(\"\");\n}\n\nint main(int argc, char *argv[])\n{\n\tint max_vcpus = kvm_check_cap(KVM_CAP_MAX_VCPUS);\n\tstruct test_params p = {\n\t\t.test_mem_size = DEFAULT_TEST_MEM_SIZE,\n\t\t.src_type = DEFAULT_VM_MEM_SRC,\n\t};\n\tint opt;\n\n\tguest_modes_append_default();\n\n\twhile ((opt = getopt(argc, argv, \"hp:m:b:v:s:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'p':\n\t\t\tp.phys_offset = strtoull(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tguest_modes_cmdline(optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tp.test_mem_size = parse_size(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tnr_vcpus = atoi_positive(\"Number of vCPUs\", optarg);\n\t\t\tTEST_ASSERT(nr_vcpus <= max_vcpus,\n\t\t\t\t    \"Invalid number of vcpus, must be between 1 and %d\", max_vcpus);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tp.src_type = parse_backing_src_type(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tfor_each_guest_mode(run_test, &p);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}