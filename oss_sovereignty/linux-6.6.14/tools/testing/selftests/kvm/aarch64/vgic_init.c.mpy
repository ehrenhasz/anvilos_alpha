{
  "module_name": "vgic_init.c",
  "hash_id": "23219d3915cbdd9ead0fe30848078a02f91ccc01dca07361d99c5e06a5b2e60a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/aarch64/vgic_init.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <linux/kernel.h>\n#include <sys/syscall.h>\n#include <asm/kvm.h>\n#include <asm/kvm_para.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vgic.h\"\n\n#define NR_VCPUS\t\t4\n\n#define REG_OFFSET(vcpu, offset) (((uint64_t)vcpu << 32) | offset)\n\n#define GICR_TYPER 0x8\n\n#define VGIC_DEV_IS_V2(_d) ((_d) == KVM_DEV_TYPE_ARM_VGIC_V2)\n#define VGIC_DEV_IS_V3(_d) ((_d) == KVM_DEV_TYPE_ARM_VGIC_V3)\n\nstruct vm_gic {\n\tstruct kvm_vm *vm;\n\tint gic_fd;\n\tuint32_t gic_dev_type;\n};\n\nstatic uint64_t max_phys_size;\n\n \nstatic void v3_redist_reg_get_errno(int gicv3_fd, int vcpu, int offset,\n\t\t\t\t    int want, const char *msg)\n{\n\tuint32_t ignored_val;\n\tint ret = __kvm_device_attr_get(gicv3_fd, KVM_DEV_ARM_VGIC_GRP_REDIST_REGS,\n\t\t\t\t\tREG_OFFSET(vcpu, offset), &ignored_val);\n\n\tTEST_ASSERT(ret && errno == want, \"%s; want errno = %d\", msg, want);\n}\n\nstatic void v3_redist_reg_get(int gicv3_fd, int vcpu, int offset, uint32_t want,\n\t\t\t      const char *msg)\n{\n\tuint32_t val;\n\n\tkvm_device_attr_get(gicv3_fd, KVM_DEV_ARM_VGIC_GRP_REDIST_REGS,\n\t\t\t    REG_OFFSET(vcpu, offset), &val);\n\tTEST_ASSERT(val == want, \"%s; want '0x%x', got '0x%x'\", msg, want, val);\n}\n\n \nstatic void guest_code(void)\n{\n\tGUEST_SYNC(0);\n\tGUEST_SYNC(1);\n\tGUEST_SYNC(2);\n\tGUEST_DONE();\n}\n\n \nstatic int run_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn __vcpu_run(vcpu) ? -errno : 0;\n}\n\nstatic struct vm_gic vm_gic_create_with_vcpus(uint32_t gic_dev_type,\n\t\t\t\t\t      uint32_t nr_vcpus,\n\t\t\t\t\t      struct kvm_vcpu *vcpus[])\n{\n\tstruct vm_gic v;\n\n\tv.gic_dev_type = gic_dev_type;\n\tv.vm = vm_create_with_vcpus(nr_vcpus, guest_code, vcpus);\n\tv.gic_fd = kvm_create_device(v.vm, gic_dev_type);\n\n\treturn v;\n}\n\nstatic void vm_gic_destroy(struct vm_gic *v)\n{\n\tclose(v->gic_fd);\n\tkvm_vm_free(v->vm);\n}\n\nstruct vgic_region_attr {\n\tuint64_t attr;\n\tuint64_t size;\n\tuint64_t alignment;\n};\n\nstruct vgic_region_attr gic_v3_dist_region = {\n\t.attr = KVM_VGIC_V3_ADDR_TYPE_DIST,\n\t.size = 0x10000,\n\t.alignment = 0x10000,\n};\n\nstruct vgic_region_attr gic_v3_redist_region = {\n\t.attr = KVM_VGIC_V3_ADDR_TYPE_REDIST,\n\t.size = NR_VCPUS * 0x20000,\n\t.alignment = 0x10000,\n};\n\nstruct vgic_region_attr gic_v2_dist_region = {\n\t.attr = KVM_VGIC_V2_ADDR_TYPE_DIST,\n\t.size = 0x1000,\n\t.alignment = 0x1000,\n};\n\nstruct vgic_region_attr gic_v2_cpu_region = {\n\t.attr = KVM_VGIC_V2_ADDR_TYPE_CPU,\n\t.size = 0x2000,\n\t.alignment = 0x1000,\n};\n\n \nstatic void subtest_dist_rdist(struct vm_gic *v)\n{\n\tint ret;\n\tuint64_t addr;\n\tstruct vgic_region_attr rdist;  \n\tstruct vgic_region_attr dist;\n\n\trdist = VGIC_DEV_IS_V3(v->gic_dev_type) ? gic_v3_redist_region\n\t\t\t\t\t\t: gic_v2_cpu_region;\n\tdist = VGIC_DEV_IS_V3(v->gic_dev_type) ? gic_v3_dist_region\n\t\t\t\t\t\t: gic_v2_dist_region;\n\n\t \n\tkvm_has_device_attr(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR, dist.attr);\n\n\tkvm_has_device_attr(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR, rdist.attr);\n\n\t \n\tret = __kvm_has_device_attr(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR, -1);\n\tTEST_ASSERT(ret && errno == ENXIO, \"attribute not supported\");\n\n\t \n\taddr = dist.alignment / 0x10;\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    dist.attr, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL, \"GIC dist base not aligned\");\n\n\taddr = rdist.alignment / 0x10;\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    rdist.attr, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL, \"GIC redist/cpu base not aligned\");\n\n\t \n\taddr = max_phys_size;\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    dist.attr, &addr);\n\tTEST_ASSERT(ret && errno == E2BIG, \"dist address beyond IPA limit\");\n\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    rdist.attr, &addr);\n\tTEST_ASSERT(ret && errno == E2BIG, \"redist address beyond IPA limit\");\n\n\t \n\taddr = max_phys_size - dist.alignment;\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    rdist.attr, &addr);\n\tTEST_ASSERT(ret && errno == E2BIG,\n\t\t\t\"half of the redist is beyond IPA limit\");\n\n\t \n\taddr = 0x00000;\n\tkvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    rdist.attr, &addr);\n\n\t \n\taddr = 0xE0000;\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    rdist.attr, &addr);\n\tTEST_ASSERT(ret && errno == EEXIST, \"GIC redist base set again\");\n\n\tret = __kvm_has_device_attr(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t     KVM_VGIC_V3_ADDR_TYPE_REDIST);\n\tif (!ret) {\n\t\t \n\t\taddr = REDIST_REGION_ATTR_ADDR(NR_VCPUS, 0x100000, 0, 0);\n\t\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\t\tTEST_ASSERT(ret && errno == EINVAL,\n\t\t\t    \"attempt to mix GICv3 REDIST and REDIST_REGION\");\n\t}\n\n\t \n\taddr = rdist.size - rdist.alignment;\n\tkvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    dist.attr, &addr);\n}\n\n \nstatic void subtest_v3_redist_regions(struct vm_gic *v)\n{\n\tuint64_t addr, expected_addr;\n\tint ret;\n\n\tret = __kvm_has_device_attr(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST);\n\tTEST_ASSERT(!ret, \"Multiple redist regions advertised\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(NR_VCPUS, 0x100000, 2, 0);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL, \"redist region attr value with flags != 0\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(0, 0x100000, 0, 0);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL, \"redist region attr value with count== 0\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(2, 0x200000, 0, 1);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL,\n\t\t    \"attempt to register the first rdist region with index != 0\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(2, 0x201000, 0, 1);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL, \"rdist region with misaligned address\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(2, 0x200000, 0, 0);\n\tkvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\n\taddr = REDIST_REGION_ATTR_ADDR(2, 0x200000, 0, 1);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL, \"register an rdist region with already used index\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(1, 0x210000, 0, 2);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL,\n\t\t    \"register an rdist region overlapping with another one\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(1, 0x240000, 0, 2);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL, \"register redist region with index not +1\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(1, 0x240000, 0, 1);\n\tkvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\n\taddr = REDIST_REGION_ATTR_ADDR(1, max_phys_size, 0, 2);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == E2BIG,\n\t\t    \"register redist region with base address beyond IPA range\");\n\n\t \n\taddr = REDIST_REGION_ATTR_ADDR(2, max_phys_size - 0x30000, 0, 2);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == E2BIG,\n\t\t    \"register redist region with top address beyond IPA range\");\n\n\taddr = 0x260000;\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL,\n\t\t    \"Mix KVM_VGIC_V3_ADDR_TYPE_REDIST and REDIST_REGION\");\n\n\t \n\n\taddr = REDIST_REGION_ATTR_ADDR(0, 0, 0, 0);\n\texpected_addr = REDIST_REGION_ATTR_ADDR(2, 0x200000, 0, 0);\n\tret = __kvm_device_attr_get(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(!ret && addr == expected_addr, \"read characteristics of region #0\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(0, 0, 0, 1);\n\texpected_addr = REDIST_REGION_ATTR_ADDR(1, 0x240000, 0, 1);\n\tret = __kvm_device_attr_get(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(!ret && addr == expected_addr, \"read characteristics of region #1\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(0, 0, 0, 2);\n\tret = __kvm_device_attr_get(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == ENOENT, \"read characteristics of non existing region\");\n\n\taddr = 0x260000;\n\tkvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_DIST, &addr);\n\n\taddr = REDIST_REGION_ATTR_ADDR(1, 0x260000, 0, 2);\n\tret = __kvm_device_attr_set(v->gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL, \"register redist region colliding with dist\");\n}\n\n \nstatic void test_vgic_then_vcpus(uint32_t gic_dev_type)\n{\n\tstruct kvm_vcpu *vcpus[NR_VCPUS];\n\tstruct vm_gic v;\n\tint ret, i;\n\n\tv = vm_gic_create_with_vcpus(gic_dev_type, 1, vcpus);\n\n\tsubtest_dist_rdist(&v);\n\n\t \n\tfor (i = 1; i < NR_VCPUS; ++i)\n\t\tvcpus[i] = vm_vcpu_add(v.vm, i, guest_code);\n\n\tret = run_vcpu(vcpus[3]);\n\tTEST_ASSERT(ret == -EINVAL, \"dist/rdist overlap detected on 1st vcpu run\");\n\n\tvm_gic_destroy(&v);\n}\n\n \nstatic void test_vcpus_then_vgic(uint32_t gic_dev_type)\n{\n\tstruct kvm_vcpu *vcpus[NR_VCPUS];\n\tstruct vm_gic v;\n\tint ret;\n\n\tv = vm_gic_create_with_vcpus(gic_dev_type, NR_VCPUS, vcpus);\n\n\tsubtest_dist_rdist(&v);\n\n\tret = run_vcpu(vcpus[3]);\n\tTEST_ASSERT(ret == -EINVAL, \"dist/rdist overlap detected on 1st vcpu run\");\n\n\tvm_gic_destroy(&v);\n}\n\nstatic void test_v3_new_redist_regions(void)\n{\n\tstruct kvm_vcpu *vcpus[NR_VCPUS];\n\tvoid *dummy = NULL;\n\tstruct vm_gic v;\n\tuint64_t addr;\n\tint ret;\n\n\tv = vm_gic_create_with_vcpus(KVM_DEV_TYPE_ARM_VGIC_V3, NR_VCPUS, vcpus);\n\tsubtest_v3_redist_regions(&v);\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\t\t\t    KVM_DEV_ARM_VGIC_CTRL_INIT, NULL);\n\n\tret = run_vcpu(vcpus[3]);\n\tTEST_ASSERT(ret == -ENXIO, \"running without sufficient number of rdists\");\n\tvm_gic_destroy(&v);\n\n\t \n\n\tv = vm_gic_create_with_vcpus(KVM_DEV_TYPE_ARM_VGIC_V3, NR_VCPUS, vcpus);\n\tsubtest_v3_redist_regions(&v);\n\n\taddr = REDIST_REGION_ATTR_ADDR(1, 0x280000, 0, 2);\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\n\tret = run_vcpu(vcpus[3]);\n\tTEST_ASSERT(ret == -EBUSY, \"running without vgic explicit init\");\n\n\tvm_gic_destroy(&v);\n\n\t \n\n\tv = vm_gic_create_with_vcpus(KVM_DEV_TYPE_ARM_VGIC_V3, NR_VCPUS, vcpus);\n\tsubtest_v3_redist_regions(&v);\n\n\tret = __kvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, dummy);\n\tTEST_ASSERT(ret && errno == EFAULT,\n\t\t    \"register a third region allowing to cover the 4 vcpus\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(1, 0x280000, 0, 2);\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\t\t\t    KVM_DEV_ARM_VGIC_CTRL_INIT, NULL);\n\n\tret = run_vcpu(vcpus[3]);\n\tTEST_ASSERT(!ret, \"vcpu run\");\n\n\tvm_gic_destroy(&v);\n}\n\nstatic void test_v3_typer_accesses(void)\n{\n\tstruct vm_gic v;\n\tuint64_t addr;\n\tint ret, i;\n\n\tv.vm = vm_create(NR_VCPUS);\n\t(void)vm_vcpu_add(v.vm, 0, guest_code);\n\n\tv.gic_fd = kvm_create_device(v.vm, KVM_DEV_TYPE_ARM_VGIC_V3);\n\n\t(void)vm_vcpu_add(v.vm, 3, guest_code);\n\n\tv3_redist_reg_get_errno(v.gic_fd, 1, GICR_TYPER, EINVAL,\n\t\t\t\t\"attempting to read GICR_TYPER of non created vcpu\");\n\n\t(void)vm_vcpu_add(v.vm, 1, guest_code);\n\n\tv3_redist_reg_get_errno(v.gic_fd, 1, GICR_TYPER, EBUSY,\n\t\t\t\t\"read GICR_TYPER before GIC initialized\");\n\n\t(void)vm_vcpu_add(v.vm, 2, guest_code);\n\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\t\t\t    KVM_DEV_ARM_VGIC_CTRL_INIT, NULL);\n\n\tfor (i = 0; i < NR_VCPUS ; i++) {\n\t\tv3_redist_reg_get(v.gic_fd, i, GICR_TYPER, i * 0x100,\n\t\t\t\t  \"read GICR_TYPER before rdist region setting\");\n\t}\n\n\taddr = REDIST_REGION_ATTR_ADDR(2, 0x200000, 0, 0);\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\n\t \n\tv3_redist_reg_get(v.gic_fd, 0, GICR_TYPER, 0x0, \"read typer of rdist #0\");\n\tv3_redist_reg_get(v.gic_fd, 3, GICR_TYPER, 0x310, \"read typer of rdist #1\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(10, 0x100000, 0, 1);\n\tret = __kvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL, \"collision with previous rdist region\");\n\n\tv3_redist_reg_get(v.gic_fd, 1, GICR_TYPER, 0x100,\n\t\t\t  \"no redist region attached to vcpu #1 yet, last cannot be returned\");\n\tv3_redist_reg_get(v.gic_fd, 2, GICR_TYPER, 0x200,\n\t\t\t  \"no redist region attached to vcpu #2, last cannot be returned\");\n\n\taddr = REDIST_REGION_ATTR_ADDR(10, 0x20000, 0, 1);\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\n\tv3_redist_reg_get(v.gic_fd, 1, GICR_TYPER, 0x100, \"read typer of rdist #1\");\n\tv3_redist_reg_get(v.gic_fd, 2, GICR_TYPER, 0x210,\n\t\t\t  \"read typer of rdist #1, last properly returned\");\n\n\tvm_gic_destroy(&v);\n}\n\nstatic struct vm_gic vm_gic_v3_create_with_vcpuids(int nr_vcpus,\n\t\t\t\t\t\t   uint32_t vcpuids[])\n{\n\tstruct vm_gic v;\n\tint i;\n\n\tv.vm = vm_create(nr_vcpus);\n\tfor (i = 0; i < nr_vcpus; i++)\n\t\tvm_vcpu_add(v.vm, vcpuids[i], guest_code);\n\n\tv.gic_fd = kvm_create_device(v.vm, KVM_DEV_TYPE_ARM_VGIC_V3);\n\n\treturn v;\n}\n\n \nstatic void test_v3_last_bit_redist_regions(void)\n{\n\tuint32_t vcpuids[] = { 0, 3, 5, 4, 1, 2 };\n\tstruct vm_gic v;\n\tuint64_t addr;\n\n\tv = vm_gic_v3_create_with_vcpuids(ARRAY_SIZE(vcpuids), vcpuids);\n\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\t\t\t    KVM_DEV_ARM_VGIC_CTRL_INIT, NULL);\n\n\taddr = REDIST_REGION_ATTR_ADDR(2, 0x100000, 0, 0);\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\n\taddr = REDIST_REGION_ATTR_ADDR(2, 0x240000, 0, 1);\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\n\taddr = REDIST_REGION_ATTR_ADDR(2, 0x200000, 0, 2);\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &addr);\n\n\tv3_redist_reg_get(v.gic_fd, 0, GICR_TYPER, 0x000, \"read typer of rdist #0\");\n\tv3_redist_reg_get(v.gic_fd, 1, GICR_TYPER, 0x100, \"read typer of rdist #1\");\n\tv3_redist_reg_get(v.gic_fd, 2, GICR_TYPER, 0x200, \"read typer of rdist #2\");\n\tv3_redist_reg_get(v.gic_fd, 3, GICR_TYPER, 0x310, \"read typer of rdist #3\");\n\tv3_redist_reg_get(v.gic_fd, 5, GICR_TYPER, 0x500, \"read typer of rdist #5\");\n\tv3_redist_reg_get(v.gic_fd, 4, GICR_TYPER, 0x410, \"read typer of rdist #4\");\n\n\tvm_gic_destroy(&v);\n}\n\n \nstatic void test_v3_last_bit_single_rdist(void)\n{\n\tuint32_t vcpuids[] = { 0, 3, 5, 4, 1, 2 };\n\tstruct vm_gic v;\n\tuint64_t addr;\n\n\tv = vm_gic_v3_create_with_vcpuids(ARRAY_SIZE(vcpuids), vcpuids);\n\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\t\t\t    KVM_DEV_ARM_VGIC_CTRL_INIT, NULL);\n\n\taddr = 0x10000;\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST, &addr);\n\n\tv3_redist_reg_get(v.gic_fd, 0, GICR_TYPER, 0x000, \"read typer of rdist #0\");\n\tv3_redist_reg_get(v.gic_fd, 3, GICR_TYPER, 0x300, \"read typer of rdist #1\");\n\tv3_redist_reg_get(v.gic_fd, 5, GICR_TYPER, 0x500, \"read typer of rdist #2\");\n\tv3_redist_reg_get(v.gic_fd, 1, GICR_TYPER, 0x100, \"read typer of rdist #3\");\n\tv3_redist_reg_get(v.gic_fd, 2, GICR_TYPER, 0x210, \"read typer of rdist #3\");\n\n\tvm_gic_destroy(&v);\n}\n\n \nstatic void test_v3_redist_ipa_range_check_at_vcpu_run(void)\n{\n\tstruct kvm_vcpu *vcpus[NR_VCPUS];\n\tstruct vm_gic v;\n\tint ret, i;\n\tuint64_t addr;\n\n\tv = vm_gic_create_with_vcpus(KVM_DEV_TYPE_ARM_VGIC_V3, 1, vcpus);\n\n\t \n\taddr = max_phys_size - (3 * 2 * 0x10000);\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST, &addr);\n\n\taddr = 0x00000;\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_DIST, &addr);\n\n\t \n\tfor (i = 1; i < NR_VCPUS; ++i)\n\t\tvcpus[i] = vm_vcpu_add(v.vm, i, guest_code);\n\n\tkvm_device_attr_set(v.gic_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\t\t\t    KVM_DEV_ARM_VGIC_CTRL_INIT, NULL);\n\n\t \n\tret = run_vcpu(vcpus[2]);\n\tTEST_ASSERT(ret && errno == EINVAL,\n\t\t\"redist base+size above PA range detected on 1st vcpu run\");\n\n\tvm_gic_destroy(&v);\n}\n\nstatic void test_v3_its_region(void)\n{\n\tstruct kvm_vcpu *vcpus[NR_VCPUS];\n\tstruct vm_gic v;\n\tuint64_t addr;\n\tint its_fd, ret;\n\n\tv = vm_gic_create_with_vcpus(KVM_DEV_TYPE_ARM_VGIC_V3, NR_VCPUS, vcpus);\n\tits_fd = kvm_create_device(v.vm, KVM_DEV_TYPE_ARM_VGIC_ITS);\n\n\taddr = 0x401000;\n\tret = __kvm_device_attr_set(its_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_ITS_ADDR_TYPE, &addr);\n\tTEST_ASSERT(ret && errno == EINVAL,\n\t\t\"ITS region with misaligned address\");\n\n\taddr = max_phys_size;\n\tret = __kvm_device_attr_set(its_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_ITS_ADDR_TYPE, &addr);\n\tTEST_ASSERT(ret && errno == E2BIG,\n\t\t\"register ITS region with base address beyond IPA range\");\n\n\taddr = max_phys_size - 0x10000;\n\tret = __kvm_device_attr_set(its_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_ITS_ADDR_TYPE, &addr);\n\tTEST_ASSERT(ret && errno == E2BIG,\n\t\t\"Half of ITS region is beyond IPA range\");\n\n\t \n\taddr = 0x400000;\n\tkvm_device_attr_set(its_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_ITS_ADDR_TYPE, &addr);\n\n\taddr = 0x300000;\n\tret = __kvm_device_attr_set(its_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t\t    KVM_VGIC_ITS_ADDR_TYPE, &addr);\n\tTEST_ASSERT(ret && errno == EEXIST, \"ITS base set again\");\n\n\tclose(its_fd);\n\tvm_gic_destroy(&v);\n}\n\n \nint test_kvm_device(uint32_t gic_dev_type)\n{\n\tstruct kvm_vcpu *vcpus[NR_VCPUS];\n\tstruct vm_gic v;\n\tuint32_t other;\n\tint ret;\n\n\tv.vm = vm_create_with_vcpus(NR_VCPUS, guest_code, vcpus);\n\n\t \n\tret = __kvm_test_create_device(v.vm, 0);\n\tTEST_ASSERT(ret && errno == ENODEV, \"unsupported device\");\n\n\t \n\tret = __kvm_test_create_device(v.vm, gic_dev_type);\n\tif (ret)\n\t\treturn ret;\n\tv.gic_fd = kvm_create_device(v.vm, gic_dev_type);\n\n\tret = __kvm_create_device(v.vm, gic_dev_type);\n\tTEST_ASSERT(ret < 0 && errno == EEXIST, \"create GIC device twice\");\n\n\t \n\tother = VGIC_DEV_IS_V2(gic_dev_type) ? KVM_DEV_TYPE_ARM_VGIC_V3\n\t\t\t\t\t     : KVM_DEV_TYPE_ARM_VGIC_V2;\n\n\tif (!__kvm_test_create_device(v.vm, other)) {\n\t\tret = __kvm_create_device(v.vm, other);\n\t\tTEST_ASSERT(ret < 0 && (errno == EINVAL || errno == EEXIST),\n\t\t\t\t\"create GIC device while other version exists\");\n\t}\n\n\tvm_gic_destroy(&v);\n\n\treturn 0;\n}\n\nvoid run_tests(uint32_t gic_dev_type)\n{\n\ttest_vcpus_then_vgic(gic_dev_type);\n\ttest_vgic_then_vcpus(gic_dev_type);\n\n\tif (VGIC_DEV_IS_V3(gic_dev_type)) {\n\t\ttest_v3_new_redist_regions();\n\t\ttest_v3_typer_accesses();\n\t\ttest_v3_last_bit_redist_regions();\n\t\ttest_v3_last_bit_single_rdist();\n\t\ttest_v3_redist_ipa_range_check_at_vcpu_run();\n\t\ttest_v3_its_region();\n\t}\n}\n\nint main(int ac, char **av)\n{\n\tint ret;\n\tint pa_bits;\n\tint cnt_impl = 0;\n\n\tpa_bits = vm_guest_mode_params[VM_MODE_DEFAULT].pa_bits;\n\tmax_phys_size = 1ULL << pa_bits;\n\n\tret = test_kvm_device(KVM_DEV_TYPE_ARM_VGIC_V3);\n\tif (!ret) {\n\t\tpr_info(\"Running GIC_v3 tests.\\n\");\n\t\trun_tests(KVM_DEV_TYPE_ARM_VGIC_V3);\n\t\tcnt_impl++;\n\t}\n\n\tret = test_kvm_device(KVM_DEV_TYPE_ARM_VGIC_V2);\n\tif (!ret) {\n\t\tpr_info(\"Running GIC_v2 tests.\\n\");\n\t\trun_tests(KVM_DEV_TYPE_ARM_VGIC_V2);\n\t\tcnt_impl++;\n\t}\n\n\tif (!cnt_impl) {\n\t\tprint_skip(\"No GICv2 nor GICv3 support\");\n\t\texit(KSFT_SKIP);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}