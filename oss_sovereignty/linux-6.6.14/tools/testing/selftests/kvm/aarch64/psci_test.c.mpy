{
  "module_name": "psci_test.c",
  "hash_id": "997df8f495576b8e5f17e8f0f4a1b8fe19ecf07b32aae2e56ce1cebeeb4c51b3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/aarch64/psci_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <linux/psci.h>\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"test_util.h\"\n\n#define CPU_ON_ENTRY_ADDR 0xfeedf00dul\n#define CPU_ON_CONTEXT_ID 0xdeadc0deul\n\nstatic uint64_t psci_cpu_on(uint64_t target_cpu, uint64_t entry_addr,\n\t\t\t    uint64_t context_id)\n{\n\tstruct arm_smccc_res res;\n\n\tsmccc_hvc(PSCI_0_2_FN64_CPU_ON, target_cpu, entry_addr, context_id,\n\t\t  0, 0, 0, 0, &res);\n\n\treturn res.a0;\n}\n\nstatic uint64_t psci_affinity_info(uint64_t target_affinity,\n\t\t\t\t   uint64_t lowest_affinity_level)\n{\n\tstruct arm_smccc_res res;\n\n\tsmccc_hvc(PSCI_0_2_FN64_AFFINITY_INFO, target_affinity, lowest_affinity_level,\n\t\t  0, 0, 0, 0, 0, &res);\n\n\treturn res.a0;\n}\n\nstatic uint64_t psci_system_suspend(uint64_t entry_addr, uint64_t context_id)\n{\n\tstruct arm_smccc_res res;\n\n\tsmccc_hvc(PSCI_1_0_FN64_SYSTEM_SUSPEND, entry_addr, context_id,\n\t\t  0, 0, 0, 0, 0, &res);\n\n\treturn res.a0;\n}\n\nstatic uint64_t psci_features(uint32_t func_id)\n{\n\tstruct arm_smccc_res res;\n\n\tsmccc_hvc(PSCI_1_0_FN_PSCI_FEATURES, func_id, 0, 0, 0, 0, 0, 0, &res);\n\n\treturn res.a0;\n}\n\nstatic void vcpu_power_off(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mp_state mp_state = {\n\t\t.mp_state = KVM_MP_STATE_STOPPED,\n\t};\n\n\tvcpu_mp_state_set(vcpu, &mp_state);\n}\n\nstatic struct kvm_vm *setup_vm(void *guest_code, struct kvm_vcpu **source,\n\t\t\t       struct kvm_vcpu **target)\n{\n\tstruct kvm_vcpu_init init;\n\tstruct kvm_vm *vm;\n\n\tvm = vm_create(2);\n\n\tvm_ioctl(vm, KVM_ARM_PREFERRED_TARGET, &init);\n\tinit.features[0] |= (1 << KVM_ARM_VCPU_PSCI_0_2);\n\n\t*source = aarch64_vcpu_add(vm, 0, &init, guest_code);\n\t*target = aarch64_vcpu_add(vm, 1, &init, guest_code);\n\n\treturn vm;\n}\n\nstatic void enter_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct ucall uc;\n\n\tvcpu_run(vcpu);\n\tif (get_ucall(vcpu, &uc) == UCALL_ABORT)\n\t\tREPORT_GUEST_ASSERT(uc);\n}\n\nstatic void assert_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tuint64_t obs_pc, obs_x0;\n\n\tvcpu_get_reg(vcpu, ARM64_CORE_REG(regs.pc), &obs_pc);\n\tvcpu_get_reg(vcpu, ARM64_CORE_REG(regs.regs[0]), &obs_x0);\n\n\tTEST_ASSERT(obs_pc == CPU_ON_ENTRY_ADDR,\n\t\t    \"unexpected target cpu pc: %lx (expected: %lx)\",\n\t\t    obs_pc, CPU_ON_ENTRY_ADDR);\n\tTEST_ASSERT(obs_x0 == CPU_ON_CONTEXT_ID,\n\t\t    \"unexpected target context id: %lx (expected: %lx)\",\n\t\t    obs_x0, CPU_ON_CONTEXT_ID);\n}\n\nstatic void guest_test_cpu_on(uint64_t target_cpu)\n{\n\tuint64_t target_state;\n\n\tGUEST_ASSERT(!psci_cpu_on(target_cpu, CPU_ON_ENTRY_ADDR, CPU_ON_CONTEXT_ID));\n\n\tdo {\n\t\ttarget_state = psci_affinity_info(target_cpu, 0);\n\n\t\tGUEST_ASSERT((target_state == PSCI_0_2_AFFINITY_LEVEL_ON) ||\n\t\t\t     (target_state == PSCI_0_2_AFFINITY_LEVEL_OFF));\n\t} while (target_state != PSCI_0_2_AFFINITY_LEVEL_ON);\n\n\tGUEST_DONE();\n}\n\nstatic void host_test_cpu_on(void)\n{\n\tstruct kvm_vcpu *source, *target;\n\tuint64_t target_mpidr;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\n\tvm = setup_vm(guest_test_cpu_on, &source, &target);\n\n\t \n\tvcpu_power_off(target);\n\n\tvcpu_get_reg(target, KVM_ARM64_SYS_REG(SYS_MPIDR_EL1), &target_mpidr);\n\tvcpu_args_set(source, 1, target_mpidr & MPIDR_HWID_BITMASK);\n\tenter_guest(source);\n\n\tif (get_ucall(source, &uc) != UCALL_DONE)\n\t\tTEST_FAIL(\"Unhandled ucall: %lu\", uc.cmd);\n\n\tassert_vcpu_reset(target);\n\tkvm_vm_free(vm);\n}\n\nstatic void guest_test_system_suspend(void)\n{\n\tuint64_t ret;\n\n\t \n\tGUEST_ASSERT(!psci_features(PSCI_1_0_FN_SYSTEM_SUSPEND));\n\tGUEST_ASSERT(!psci_features(PSCI_1_0_FN64_SYSTEM_SUSPEND));\n\n\tret = psci_system_suspend(CPU_ON_ENTRY_ADDR, CPU_ON_CONTEXT_ID);\n\tGUEST_SYNC(ret);\n}\n\nstatic void host_test_system_suspend(void)\n{\n\tstruct kvm_vcpu *source, *target;\n\tstruct kvm_run *run;\n\tstruct kvm_vm *vm;\n\n\tvm = setup_vm(guest_test_system_suspend, &source, &target);\n\tvm_enable_cap(vm, KVM_CAP_ARM_SYSTEM_SUSPEND, 0);\n\n\tvcpu_power_off(target);\n\trun = source->run;\n\n\tenter_guest(source);\n\n\tTEST_ASSERT_KVM_EXIT_REASON(source, KVM_EXIT_SYSTEM_EVENT);\n\tTEST_ASSERT(run->system_event.type == KVM_SYSTEM_EVENT_SUSPEND,\n\t\t    \"Unhandled system event: %u (expected: %u)\",\n\t\t    run->system_event.type, KVM_SYSTEM_EVENT_SUSPEND);\n\n\tkvm_vm_free(vm);\n}\n\nint main(void)\n{\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_ARM_SYSTEM_SUSPEND));\n\n\thost_test_cpu_on();\n\thost_test_system_suspend();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}