{
  "module_name": "page_fault_test.c",
  "hash_id": "198ed06fd9d649121687998d1ede63bf5e6111164576f828dc625aef7d90314c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/aarch64/page_fault_test.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <linux/bitmap.h>\n#include <fcntl.h>\n#include <test_util.h>\n#include <kvm_util.h>\n#include <processor.h>\n#include <asm/sysreg.h>\n#include <linux/bitfield.h>\n#include \"guest_modes.h\"\n#include \"userfaultfd_util.h\"\n\n \n#define TEST_GVA\t\t\t\t0xc0000000\n#define TEST_EXEC_GVA\t\t\t\t(TEST_GVA + 0x8)\n#define TEST_PTE_GVA\t\t\t\t0xb0000000\n#define TEST_DATA\t\t\t\t0x0123456789ABCDEF\n\nstatic uint64_t *guest_test_memory = (uint64_t *)TEST_GVA;\n\n#define CMD_NONE\t\t\t\t(0)\n#define CMD_SKIP_TEST\t\t\t\t(1ULL << 1)\n#define CMD_HOLE_PT\t\t\t\t(1ULL << 2)\n#define CMD_HOLE_DATA\t\t\t\t(1ULL << 3)\n#define CMD_CHECK_WRITE_IN_DIRTY_LOG\t\t(1ULL << 4)\n#define CMD_CHECK_S1PTW_WR_IN_DIRTY_LOG\t\t(1ULL << 5)\n#define CMD_CHECK_NO_WRITE_IN_DIRTY_LOG\t\t(1ULL << 6)\n#define CMD_CHECK_NO_S1PTW_WR_IN_DIRTY_LOG\t(1ULL << 7)\n#define CMD_SET_PTE_AF\t\t\t\t(1ULL << 8)\n\n#define PREPARE_FN_NR\t\t\t\t10\n#define CHECK_FN_NR\t\t\t\t10\n\nstatic struct event_cnt {\n\tint mmio_exits;\n\tint fail_vcpu_runs;\n\tint uffd_faults;\n\t \n\tpthread_mutex_t uffd_faults_mutex;\n} events;\n\nstruct test_desc {\n\tconst char *name;\n\tuint64_t mem_mark_cmd;\n\t \n\tbool (*guest_prepare[PREPARE_FN_NR])(void);\n\tvoid (*guest_test)(void);\n\tvoid (*guest_test_check[CHECK_FN_NR])(void);\n\tuffd_handler_t uffd_pt_handler;\n\tuffd_handler_t uffd_data_handler;\n\tvoid (*dabt_handler)(struct ex_regs *regs);\n\tvoid (*iabt_handler)(struct ex_regs *regs);\n\tvoid (*mmio_handler)(struct kvm_vm *vm, struct kvm_run *run);\n\tvoid (*fail_vcpu_run_handler)(int ret);\n\tuint32_t pt_memslot_flags;\n\tuint32_t data_memslot_flags;\n\tbool skip;\n\tstruct event_cnt expected_events;\n};\n\nstruct test_params {\n\tenum vm_mem_backing_src_type src_type;\n\tstruct test_desc *test_desc;\n};\n\nstatic inline void flush_tlb_page(uint64_t vaddr)\n{\n\tuint64_t page = vaddr >> 12;\n\n\tdsb(ishst);\n\tasm volatile(\"tlbi vaae1is, %0\" :: \"r\" (page));\n\tdsb(ish);\n\tisb();\n}\n\nstatic void guest_write64(void)\n{\n\tuint64_t val;\n\n\tWRITE_ONCE(*guest_test_memory, TEST_DATA);\n\tval = READ_ONCE(*guest_test_memory);\n\tGUEST_ASSERT_EQ(val, TEST_DATA);\n}\n\n \nstatic bool guest_check_lse(void)\n{\n\tuint64_t isar0 = read_sysreg(id_aa64isar0_el1);\n\tuint64_t atomic;\n\n\tatomic = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64ISAR0_ATOMICS), isar0);\n\treturn atomic >= 2;\n}\n\nstatic bool guest_check_dc_zva(void)\n{\n\tuint64_t dczid = read_sysreg(dczid_el0);\n\tuint64_t dzp = FIELD_GET(ARM64_FEATURE_MASK(DCZID_DZP), dczid);\n\n\treturn dzp == 0;\n}\n\n \nstatic void guest_cas(void)\n{\n\tuint64_t val;\n\n\tGUEST_ASSERT(guest_check_lse());\n\tasm volatile(\".arch_extension lse\\n\"\n\t\t     \"casal %0, %1, [%2]\\n\"\n\t\t     :: \"r\" (0ul), \"r\" (TEST_DATA), \"r\" (guest_test_memory));\n\tval = READ_ONCE(*guest_test_memory);\n\tGUEST_ASSERT_EQ(val, TEST_DATA);\n}\n\nstatic void guest_read64(void)\n{\n\tuint64_t val;\n\n\tval = READ_ONCE(*guest_test_memory);\n\tGUEST_ASSERT_EQ(val, 0);\n}\n\n \nstatic void guest_at(void)\n{\n\tuint64_t par;\n\n\tasm volatile(\"at s1e1r, %0\" :: \"r\" (guest_test_memory));\n\tpar = read_sysreg(par_el1);\n\tisb();\n\n\t \n\tGUEST_ASSERT_EQ(par & 1, 0);\n}\n\n \nstatic void guest_dc_zva(void)\n{\n\tuint16_t val;\n\n\tasm volatile(\"dc zva, %0\" :: \"r\" (guest_test_memory));\n\tdsb(ish);\n\tval = READ_ONCE(*guest_test_memory);\n\tGUEST_ASSERT_EQ(val, 0);\n}\n\n \nstatic void guest_ld_preidx(void)\n{\n\tuint64_t val;\n\tuint64_t addr = TEST_GVA - 8;\n\n\t \n\tasm volatile(\"ldr %0, [%1, #8]!\"\n\t\t     : \"=r\" (val), \"+r\" (addr));\n\tGUEST_ASSERT_EQ(val, 0);\n\tGUEST_ASSERT_EQ(addr, TEST_GVA);\n}\n\nstatic void guest_st_preidx(void)\n{\n\tuint64_t val = TEST_DATA;\n\tuint64_t addr = TEST_GVA - 8;\n\n\tasm volatile(\"str %0, [%1, #8]!\"\n\t\t     : \"+r\" (val), \"+r\" (addr));\n\n\tGUEST_ASSERT_EQ(addr, TEST_GVA);\n\tval = READ_ONCE(*guest_test_memory);\n}\n\nstatic bool guest_set_ha(void)\n{\n\tuint64_t mmfr1 = read_sysreg(id_aa64mmfr1_el1);\n\tuint64_t hadbs, tcr;\n\n\t \n\thadbs = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64MMFR1_HADBS), mmfr1);\n\tif (hadbs == 0)\n\t\treturn false;\n\n\ttcr = read_sysreg(tcr_el1) | TCR_EL1_HA;\n\twrite_sysreg(tcr, tcr_el1);\n\tisb();\n\n\treturn true;\n}\n\nstatic bool guest_clear_pte_af(void)\n{\n\t*((uint64_t *)TEST_PTE_GVA) &= ~PTE_AF;\n\tflush_tlb_page(TEST_GVA);\n\n\treturn true;\n}\n\nstatic void guest_check_pte_af(void)\n{\n\tdsb(ish);\n\tGUEST_ASSERT_EQ(*((uint64_t *)TEST_PTE_GVA) & PTE_AF, PTE_AF);\n}\n\nstatic void guest_check_write_in_dirty_log(void)\n{\n\tGUEST_SYNC(CMD_CHECK_WRITE_IN_DIRTY_LOG);\n}\n\nstatic void guest_check_no_write_in_dirty_log(void)\n{\n\tGUEST_SYNC(CMD_CHECK_NO_WRITE_IN_DIRTY_LOG);\n}\n\nstatic void guest_check_s1ptw_wr_in_dirty_log(void)\n{\n\tGUEST_SYNC(CMD_CHECK_S1PTW_WR_IN_DIRTY_LOG);\n}\n\nstatic void guest_check_no_s1ptw_wr_in_dirty_log(void)\n{\n\tGUEST_SYNC(CMD_CHECK_NO_S1PTW_WR_IN_DIRTY_LOG);\n}\n\nstatic void guest_exec(void)\n{\n\tint (*code)(void) = (int (*)(void))TEST_EXEC_GVA;\n\tint ret;\n\n\tret = code();\n\tGUEST_ASSERT_EQ(ret, 0x77);\n}\n\nstatic bool guest_prepare(struct test_desc *test)\n{\n\tbool (*prepare_fn)(void);\n\tint i;\n\n\tfor (i = 0; i < PREPARE_FN_NR; i++) {\n\t\tprepare_fn = test->guest_prepare[i];\n\t\tif (prepare_fn && !prepare_fn())\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void guest_test_check(struct test_desc *test)\n{\n\tvoid (*check_fn)(void);\n\tint i;\n\n\tfor (i = 0; i < CHECK_FN_NR; i++) {\n\t\tcheck_fn = test->guest_test_check[i];\n\t\tif (check_fn)\n\t\t\tcheck_fn();\n\t}\n}\n\nstatic void guest_code(struct test_desc *test)\n{\n\tif (!guest_prepare(test))\n\t\tGUEST_SYNC(CMD_SKIP_TEST);\n\n\tGUEST_SYNC(test->mem_mark_cmd);\n\n\tif (test->guest_test)\n\t\ttest->guest_test();\n\n\tguest_test_check(test);\n\tGUEST_DONE();\n}\n\nstatic void no_dabt_handler(struct ex_regs *regs)\n{\n\tGUEST_FAIL(\"Unexpected dabt, far_el1 = 0x%llx\", read_sysreg(far_el1));\n}\n\nstatic void no_iabt_handler(struct ex_regs *regs)\n{\n\tGUEST_FAIL(\"Unexpected iabt, pc = 0x%lx\", regs->pc);\n}\n\nstatic struct uffd_args {\n\tchar *copy;\n\tvoid *hva;\n\tuint64_t paging_size;\n} pt_args, data_args;\n\n \nstatic int uffd_generic_handler(int uffd_mode, int uffd, struct uffd_msg *msg,\n\t\t\t\tstruct uffd_args *args)\n{\n\tuint64_t addr = msg->arg.pagefault.address;\n\tuint64_t flags = msg->arg.pagefault.flags;\n\tstruct uffdio_copy copy;\n\tint ret;\n\n\tTEST_ASSERT(uffd_mode == UFFDIO_REGISTER_MODE_MISSING,\n\t\t    \"The only expected UFFD mode is MISSING\");\n\tTEST_ASSERT_EQ(addr, (uint64_t)args->hva);\n\n\tpr_debug(\"uffd fault: addr=%p write=%d\\n\",\n\t\t (void *)addr, !!(flags & UFFD_PAGEFAULT_FLAG_WRITE));\n\n\tcopy.src = (uint64_t)args->copy;\n\tcopy.dst = addr;\n\tcopy.len = args->paging_size;\n\tcopy.mode = 0;\n\n\tret = ioctl(uffd, UFFDIO_COPY, &copy);\n\tif (ret == -1) {\n\t\tpr_info(\"Failed UFFDIO_COPY in 0x%lx with errno: %d\\n\",\n\t\t\taddr, errno);\n\t\treturn ret;\n\t}\n\n\tpthread_mutex_lock(&events.uffd_faults_mutex);\n\tevents.uffd_faults += 1;\n\tpthread_mutex_unlock(&events.uffd_faults_mutex);\n\treturn 0;\n}\n\nstatic int uffd_pt_handler(int mode, int uffd, struct uffd_msg *msg)\n{\n\treturn uffd_generic_handler(mode, uffd, msg, &pt_args);\n}\n\nstatic int uffd_data_handler(int mode, int uffd, struct uffd_msg *msg)\n{\n\treturn uffd_generic_handler(mode, uffd, msg, &data_args);\n}\n\nstatic void setup_uffd_args(struct userspace_mem_region *region,\n\t\t\t    struct uffd_args *args)\n{\n\targs->hva = (void *)region->region.userspace_addr;\n\targs->paging_size = region->region.memory_size;\n\n\targs->copy = malloc(args->paging_size);\n\tTEST_ASSERT(args->copy, \"Failed to allocate data copy.\");\n\tmemcpy(args->copy, args->hva, args->paging_size);\n}\n\nstatic void setup_uffd(struct kvm_vm *vm, struct test_params *p,\n\t\t       struct uffd_desc **pt_uffd, struct uffd_desc **data_uffd)\n{\n\tstruct test_desc *test = p->test_desc;\n\tint uffd_mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\tsetup_uffd_args(vm_get_mem_region(vm, MEM_REGION_PT), &pt_args);\n\tsetup_uffd_args(vm_get_mem_region(vm, MEM_REGION_TEST_DATA), &data_args);\n\n\t*pt_uffd = NULL;\n\tif (test->uffd_pt_handler)\n\t\t*pt_uffd = uffd_setup_demand_paging(uffd_mode, 0,\n\t\t\t\t\t\t    pt_args.hva,\n\t\t\t\t\t\t    pt_args.paging_size,\n\t\t\t\t\t\t    test->uffd_pt_handler);\n\n\t*data_uffd = NULL;\n\tif (test->uffd_data_handler)\n\t\t*data_uffd = uffd_setup_demand_paging(uffd_mode, 0,\n\t\t\t\t\t\t      data_args.hva,\n\t\t\t\t\t\t      data_args.paging_size,\n\t\t\t\t\t\t      test->uffd_data_handler);\n}\n\nstatic void free_uffd(struct test_desc *test, struct uffd_desc *pt_uffd,\n\t\t      struct uffd_desc *data_uffd)\n{\n\tif (test->uffd_pt_handler)\n\t\tuffd_stop_demand_paging(pt_uffd);\n\tif (test->uffd_data_handler)\n\t\tuffd_stop_demand_paging(data_uffd);\n\n\tfree(pt_args.copy);\n\tfree(data_args.copy);\n}\n\nstatic int uffd_no_handler(int mode, int uffd, struct uffd_msg *msg)\n{\n\tTEST_FAIL(\"There was no UFFD fault expected.\");\n\treturn -1;\n}\n\n \nstatic bool punch_hole_in_backing_store(struct kvm_vm *vm,\n\t\t\t\t\tstruct userspace_mem_region *region)\n{\n\tvoid *hva = (void *)region->region.userspace_addr;\n\tuint64_t paging_size = region->region.memory_size;\n\tint ret, fd = region->fd;\n\n\tif (fd != -1) {\n\t\tret = fallocate(fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\t0, paging_size);\n\t\tTEST_ASSERT(ret == 0, \"fallocate failed\\n\");\n\t} else {\n\t\tret = madvise(hva, paging_size, MADV_DONTNEED);\n\t\tTEST_ASSERT(ret == 0, \"madvise failed\\n\");\n\t}\n\n\treturn true;\n}\n\nstatic void mmio_on_test_gpa_handler(struct kvm_vm *vm, struct kvm_run *run)\n{\n\tstruct userspace_mem_region *region;\n\tvoid *hva;\n\n\tregion = vm_get_mem_region(vm, MEM_REGION_TEST_DATA);\n\thva = (void *)region->region.userspace_addr;\n\n\tTEST_ASSERT_EQ(run->mmio.phys_addr, region->region.guest_phys_addr);\n\n\tmemcpy(hva, run->mmio.data, run->mmio.len);\n\tevents.mmio_exits += 1;\n}\n\nstatic void mmio_no_handler(struct kvm_vm *vm, struct kvm_run *run)\n{\n\tuint64_t data;\n\n\tmemcpy(&data, run->mmio.data, sizeof(data));\n\tpr_debug(\"addr=%lld len=%d w=%d data=%lx\\n\",\n\t\t run->mmio.phys_addr, run->mmio.len,\n\t\t run->mmio.is_write, data);\n\tTEST_FAIL(\"There was no MMIO exit expected.\");\n}\n\nstatic bool check_write_in_dirty_log(struct kvm_vm *vm,\n\t\t\t\t     struct userspace_mem_region *region,\n\t\t\t\t     uint64_t host_pg_nr)\n{\n\tunsigned long *bmap;\n\tbool first_page_dirty;\n\tuint64_t size = region->region.memory_size;\n\n\t \n\tbmap = bitmap_zalloc(size / getpagesize());\n\tkvm_vm_get_dirty_log(vm, region->region.slot, bmap);\n\tfirst_page_dirty = test_bit(host_pg_nr, bmap);\n\tfree(bmap);\n\treturn first_page_dirty;\n}\n\n \nstatic bool handle_cmd(struct kvm_vm *vm, int cmd)\n{\n\tstruct userspace_mem_region *data_region, *pt_region;\n\tbool continue_test = true;\n\tuint64_t pte_gpa, pte_pg;\n\n\tdata_region = vm_get_mem_region(vm, MEM_REGION_TEST_DATA);\n\tpt_region = vm_get_mem_region(vm, MEM_REGION_PT);\n\tpte_gpa = addr_hva2gpa(vm, virt_get_pte_hva(vm, TEST_GVA));\n\tpte_pg = (pte_gpa - pt_region->region.guest_phys_addr) / getpagesize();\n\n\tif (cmd == CMD_SKIP_TEST)\n\t\tcontinue_test = false;\n\n\tif (cmd & CMD_HOLE_PT)\n\t\tcontinue_test = punch_hole_in_backing_store(vm, pt_region);\n\tif (cmd & CMD_HOLE_DATA)\n\t\tcontinue_test = punch_hole_in_backing_store(vm, data_region);\n\tif (cmd & CMD_CHECK_WRITE_IN_DIRTY_LOG)\n\t\tTEST_ASSERT(check_write_in_dirty_log(vm, data_region, 0),\n\t\t\t    \"Missing write in dirty log\");\n\tif (cmd & CMD_CHECK_S1PTW_WR_IN_DIRTY_LOG)\n\t\tTEST_ASSERT(check_write_in_dirty_log(vm, pt_region, pte_pg),\n\t\t\t    \"Missing s1ptw write in dirty log\");\n\tif (cmd & CMD_CHECK_NO_WRITE_IN_DIRTY_LOG)\n\t\tTEST_ASSERT(!check_write_in_dirty_log(vm, data_region, 0),\n\t\t\t    \"Unexpected write in dirty log\");\n\tif (cmd & CMD_CHECK_NO_S1PTW_WR_IN_DIRTY_LOG)\n\t\tTEST_ASSERT(!check_write_in_dirty_log(vm, pt_region, pte_pg),\n\t\t\t    \"Unexpected s1ptw write in dirty log\");\n\n\treturn continue_test;\n}\n\nvoid fail_vcpu_run_no_handler(int ret)\n{\n\tTEST_FAIL(\"Unexpected vcpu run failure\\n\");\n}\n\nvoid fail_vcpu_run_mmio_no_syndrome_handler(int ret)\n{\n\tTEST_ASSERT(errno == ENOSYS,\n\t\t    \"The mmio handler should have returned not implemented.\");\n\tevents.fail_vcpu_runs += 1;\n}\n\ntypedef uint32_t aarch64_insn_t;\nextern aarch64_insn_t __exec_test[2];\n\nnoinline void __return_0x77(void)\n{\n\tasm volatile(\"__exec_test: mov x0, #0x77\\n\"\n\t\t     \"ret\\n\");\n}\n\n \nstatic void load_exec_code_for_test(struct kvm_vm *vm)\n{\n\tuint64_t *code;\n\tstruct userspace_mem_region *region;\n\tvoid *hva;\n\n\tregion = vm_get_mem_region(vm, MEM_REGION_TEST_DATA);\n\thva = (void *)region->region.userspace_addr;\n\n\tassert(TEST_EXEC_GVA > TEST_GVA);\n\tcode = hva + TEST_EXEC_GVA - TEST_GVA;\n\tmemcpy(code, __exec_test, sizeof(__exec_test));\n}\n\nstatic void setup_abort_handlers(struct kvm_vm *vm, struct kvm_vcpu *vcpu,\n\t\t\t\t struct test_desc *test)\n{\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\tvm_install_sync_handler(vm, VECTOR_SYNC_CURRENT,\n\t\t\t\tESR_EC_DABT, no_dabt_handler);\n\tvm_install_sync_handler(vm, VECTOR_SYNC_CURRENT,\n\t\t\t\tESR_EC_IABT, no_iabt_handler);\n}\n\nstatic void setup_gva_maps(struct kvm_vm *vm)\n{\n\tstruct userspace_mem_region *region;\n\tuint64_t pte_gpa;\n\n\tregion = vm_get_mem_region(vm, MEM_REGION_TEST_DATA);\n\t \n\tvirt_pg_map(vm, TEST_GVA, region->region.guest_phys_addr);\n\t \n\tpte_gpa = addr_hva2gpa(vm, virt_get_pte_hva(vm, TEST_GVA));\n\tvirt_pg_map(vm, TEST_PTE_GVA, pte_gpa);\n}\n\nenum pf_test_memslots {\n\tCODE_AND_DATA_MEMSLOT,\n\tPAGE_TABLE_MEMSLOT,\n\tTEST_DATA_MEMSLOT,\n};\n\n \nstatic void setup_memslots(struct kvm_vm *vm, struct test_params *p)\n{\n\tuint64_t backing_src_pagesz = get_backing_src_pagesz(p->src_type);\n\tuint64_t guest_page_size = vm->page_size;\n\tuint64_t max_gfn = vm_compute_max_gfn(vm);\n\t \n\tuint64_t code_npages = 512;\n\tuint64_t pt_size, data_size, data_gpa;\n\n\t \n\tpt_size = 26 * guest_page_size;\n\n\t \n\tpt_size = align_up(pt_size, backing_src_pagesz);\n\tdata_size = align_up(guest_page_size, backing_src_pagesz);\n\tdata_gpa = (max_gfn * guest_page_size) - data_size;\n\tdata_gpa = align_down(data_gpa, backing_src_pagesz);\n\n\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS, 0,\n\t\t\t\t    CODE_AND_DATA_MEMSLOT, code_npages, 0);\n\tvm->memslots[MEM_REGION_CODE] = CODE_AND_DATA_MEMSLOT;\n\tvm->memslots[MEM_REGION_DATA] = CODE_AND_DATA_MEMSLOT;\n\n\tvm_userspace_mem_region_add(vm, p->src_type, data_gpa - pt_size,\n\t\t\t\t    PAGE_TABLE_MEMSLOT, pt_size / guest_page_size,\n\t\t\t\t    p->test_desc->pt_memslot_flags);\n\tvm->memslots[MEM_REGION_PT] = PAGE_TABLE_MEMSLOT;\n\n\tvm_userspace_mem_region_add(vm, p->src_type, data_gpa, TEST_DATA_MEMSLOT,\n\t\t\t\t    data_size / guest_page_size,\n\t\t\t\t    p->test_desc->data_memslot_flags);\n\tvm->memslots[MEM_REGION_TEST_DATA] = TEST_DATA_MEMSLOT;\n}\n\nstatic void setup_ucall(struct kvm_vm *vm)\n{\n\tstruct userspace_mem_region *region = vm_get_mem_region(vm, MEM_REGION_TEST_DATA);\n\n\tucall_init(vm, region->region.guest_phys_addr + region->region.memory_size);\n}\n\nstatic void setup_default_handlers(struct test_desc *test)\n{\n\tif (!test->mmio_handler)\n\t\ttest->mmio_handler = mmio_no_handler;\n\n\tif (!test->fail_vcpu_run_handler)\n\t\ttest->fail_vcpu_run_handler = fail_vcpu_run_no_handler;\n}\n\nstatic void check_event_counts(struct test_desc *test)\n{\n\tTEST_ASSERT_EQ(test->expected_events.uffd_faults, events.uffd_faults);\n\tTEST_ASSERT_EQ(test->expected_events.mmio_exits, events.mmio_exits);\n\tTEST_ASSERT_EQ(test->expected_events.fail_vcpu_runs, events.fail_vcpu_runs);\n}\n\nstatic void print_test_banner(enum vm_guest_mode mode, struct test_params *p)\n{\n\tstruct test_desc *test = p->test_desc;\n\n\tpr_debug(\"Test: %s\\n\", test->name);\n\tpr_debug(\"Testing guest mode: %s\\n\", vm_guest_mode_string(mode));\n\tpr_debug(\"Testing memory backing src type: %s\\n\",\n\t\t vm_mem_backing_src_alias(p->src_type)->name);\n}\n\nstatic void reset_event_counts(void)\n{\n\tmemset(&events, 0, sizeof(events));\n}\n\n \nstatic void vcpu_run_loop(struct kvm_vm *vm, struct kvm_vcpu *vcpu,\n\t\t\t  struct test_desc *test)\n{\n\tstruct kvm_run *run;\n\tstruct ucall uc;\n\tint ret;\n\n\trun = vcpu->run;\n\n\tfor (;;) {\n\t\tret = _vcpu_run(vcpu);\n\t\tif (ret) {\n\t\t\ttest->fail_vcpu_run_handler(ret);\n\t\t\tgoto done;\n\t\t}\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_SYNC:\n\t\t\tif (!handle_cmd(vm, uc.args[1])) {\n\t\t\t\ttest->skip = true;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tcase UCALL_NONE:\n\t\t\tif (run->exit_reason == KVM_EXIT_MMIO)\n\t\t\t\ttest->mmio_handler(vm, run);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\t}\n\ndone:\n\tpr_debug(test->skip ? \"Skipped.\\n\" : \"Done.\\n\");\n}\n\nstatic void run_test(enum vm_guest_mode mode, void *arg)\n{\n\tstruct test_params *p = (struct test_params *)arg;\n\tstruct test_desc *test = p->test_desc;\n\tstruct kvm_vm *vm;\n\tstruct kvm_vcpu *vcpu;\n\tstruct uffd_desc *pt_uffd, *data_uffd;\n\n\tprint_test_banner(mode, p);\n\n\tvm = ____vm_create(mode);\n\tsetup_memslots(vm, p);\n\tkvm_vm_elf_load(vm, program_invocation_name);\n\tsetup_ucall(vm);\n\tvcpu = vm_vcpu_add(vm, 0, guest_code);\n\n\tsetup_gva_maps(vm);\n\n\treset_event_counts();\n\n\t \n\tload_exec_code_for_test(vm);\n\tsetup_uffd(vm, p, &pt_uffd, &data_uffd);\n\tsetup_abort_handlers(vm, vcpu, test);\n\tsetup_default_handlers(test);\n\tvcpu_args_set(vcpu, 1, test);\n\n\tvcpu_run_loop(vm, vcpu, test);\n\n\tkvm_vm_free(vm);\n\tfree_uffd(test, pt_uffd, data_uffd);\n\n\t \n\tif (!test->skip)\n\t\tcheck_event_counts(test);\n}\n\nstatic void help(char *name)\n{\n\tputs(\"\");\n\tprintf(\"usage: %s [-h] [-s mem-type]\\n\", name);\n\tputs(\"\");\n\tguest_modes_help();\n\tbacking_src_help(\"-s\");\n\tputs(\"\");\n}\n\n#define SNAME(s)\t\t\t#s\n#define SCAT2(a, b)\t\t\tSNAME(a ## _ ## b)\n#define SCAT3(a, b, c)\t\t\tSCAT2(a, SCAT2(b, c))\n#define SCAT4(a, b, c, d)\t\tSCAT2(a, SCAT3(b, c, d))\n\n#define _CHECK(_test)\t\t\t_CHECK_##_test\n#define _PREPARE(_test)\t\t\t_PREPARE_##_test\n#define _PREPARE_guest_read64\t\tNULL\n#define _PREPARE_guest_ld_preidx\tNULL\n#define _PREPARE_guest_write64\t\tNULL\n#define _PREPARE_guest_st_preidx\tNULL\n#define _PREPARE_guest_exec\t\tNULL\n#define _PREPARE_guest_at\t\tNULL\n#define _PREPARE_guest_dc_zva\t\tguest_check_dc_zva\n#define _PREPARE_guest_cas\t\tguest_check_lse\n\n \n#define _PREPARE_with_af\t\tguest_set_ha, guest_clear_pte_af\n#define _PREPARE_no_af\t\t\tNULL\n#define _CHECK_with_af\t\t\tguest_check_pte_af\n#define _CHECK_no_af\t\t\tNULL\n\n \n#define TEST_ACCESS(_access, _with_af, _mark_cmd)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT3(_access, _with_af, #_mark_cmd),\t\t\\\n\t.guest_prepare\t\t= { _PREPARE(_with_af),\t\t\t\t\\\n\t\t\t\t    _PREPARE(_access) },\t\t\t\\\n\t.mem_mark_cmd\t\t= _mark_cmd,\t\t\t\t\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.guest_test_check\t= { _CHECK(_with_af) },\t\t\t\t\\\n\t.expected_events\t= { 0 },\t\t\t\t\t\\\n}\n\n#define TEST_UFFD(_access, _with_af, _mark_cmd,\t\t\t\t\t\\\n\t\t  _uffd_data_handler, _uffd_pt_handler, _uffd_faults)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT4(uffd, _access, _with_af, #_mark_cmd),\t\\\n\t.guest_prepare\t\t= { _PREPARE(_with_af),\t\t\t\t\\\n\t\t\t\t    _PREPARE(_access) },\t\t\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.mem_mark_cmd\t\t= _mark_cmd,\t\t\t\t\t\\\n\t.guest_test_check\t= { _CHECK(_with_af) },\t\t\t\t\\\n\t.uffd_data_handler\t= _uffd_data_handler,\t\t\t\t\\\n\t.uffd_pt_handler\t= _uffd_pt_handler,\t\t\t\t\\\n\t.expected_events\t= { .uffd_faults = _uffd_faults, },\t\t\\\n}\n\n#define TEST_DIRTY_LOG(_access, _with_af, _test_check, _pt_check)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT3(dirty_log, _access, _with_af),\t\t\\\n\t.data_memslot_flags\t= KVM_MEM_LOG_DIRTY_PAGES,\t\t\t\\\n\t.pt_memslot_flags\t= KVM_MEM_LOG_DIRTY_PAGES,\t\t\t\\\n\t.guest_prepare\t\t= { _PREPARE(_with_af),\t\t\t\t\\\n\t\t\t\t    _PREPARE(_access) },\t\t\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.guest_test_check\t= { _CHECK(_with_af), _test_check, _pt_check },\t\\\n\t.expected_events\t= { 0 },\t\t\t\t\t\\\n}\n\n#define TEST_UFFD_AND_DIRTY_LOG(_access, _with_af, _uffd_data_handler,\t\t\\\n\t\t\t\t_uffd_faults, _test_check, _pt_check)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT3(uffd_and_dirty_log, _access, _with_af),\t\\\n\t.data_memslot_flags\t= KVM_MEM_LOG_DIRTY_PAGES,\t\t\t\\\n\t.pt_memslot_flags\t= KVM_MEM_LOG_DIRTY_PAGES,\t\t\t\\\n\t.guest_prepare\t\t= { _PREPARE(_with_af),\t\t\t\t\\\n\t\t\t\t    _PREPARE(_access) },\t\t\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.mem_mark_cmd\t\t= CMD_HOLE_DATA | CMD_HOLE_PT,\t\t\t\\\n\t.guest_test_check\t= { _CHECK(_with_af), _test_check, _pt_check },\t\\\n\t.uffd_data_handler\t= _uffd_data_handler,\t\t\t\t\\\n\t.uffd_pt_handler\t= uffd_pt_handler,\t\t\t\t\\\n\t.expected_events\t= { .uffd_faults = _uffd_faults, },\t\t\\\n}\n\n#define TEST_RO_MEMSLOT(_access, _mmio_handler, _mmio_exits)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT2(ro_memslot, _access),\t\t\t\\\n\t.data_memslot_flags\t= KVM_MEM_READONLY,\t\t\t\t\\\n\t.pt_memslot_flags\t= KVM_MEM_READONLY,\t\t\t\t\\\n\t.guest_prepare\t\t= { _PREPARE(_access) },\t\t\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.mmio_handler\t\t= _mmio_handler,\t\t\t\t\\\n\t.expected_events\t= { .mmio_exits = _mmio_exits },\t\t\\\n}\n\n#define TEST_RO_MEMSLOT_NO_SYNDROME(_access)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT2(ro_memslot_no_syndrome, _access),\t\\\n\t.data_memslot_flags\t= KVM_MEM_READONLY,\t\t\t\t\\\n\t.pt_memslot_flags\t= KVM_MEM_READONLY,\t\t\t\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.fail_vcpu_run_handler\t= fail_vcpu_run_mmio_no_syndrome_handler,\t\\\n\t.expected_events\t= { .fail_vcpu_runs = 1 },\t\t\t\\\n}\n\n#define TEST_RO_MEMSLOT_AND_DIRTY_LOG(_access, _mmio_handler, _mmio_exits,\t\\\n\t\t\t\t      _test_check)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT2(ro_memslot, _access),\t\t\t\\\n\t.data_memslot_flags\t= KVM_MEM_READONLY | KVM_MEM_LOG_DIRTY_PAGES,\t\\\n\t.pt_memslot_flags\t= KVM_MEM_READONLY | KVM_MEM_LOG_DIRTY_PAGES,\t\\\n\t.guest_prepare\t\t= { _PREPARE(_access) },\t\t\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.guest_test_check\t= { _test_check },\t\t\t\t\\\n\t.mmio_handler\t\t= _mmio_handler,\t\t\t\t\\\n\t.expected_events\t= { .mmio_exits = _mmio_exits},\t\t\t\\\n}\n\n#define TEST_RO_MEMSLOT_NO_SYNDROME_AND_DIRTY_LOG(_access, _test_check)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT2(ro_memslot_no_syn_and_dlog, _access),\t\\\n\t.data_memslot_flags\t= KVM_MEM_READONLY | KVM_MEM_LOG_DIRTY_PAGES,\t\\\n\t.pt_memslot_flags\t= KVM_MEM_READONLY | KVM_MEM_LOG_DIRTY_PAGES,\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.guest_test_check\t= { _test_check },\t\t\t\t\\\n\t.fail_vcpu_run_handler\t= fail_vcpu_run_mmio_no_syndrome_handler,\t\\\n\t.expected_events\t= { .fail_vcpu_runs = 1 },\t\t\t\\\n}\n\n#define TEST_RO_MEMSLOT_AND_UFFD(_access, _mmio_handler, _mmio_exits,\t\t\\\n\t\t\t\t _uffd_data_handler, _uffd_faults)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT2(ro_memslot_uffd, _access),\t\t\\\n\t.data_memslot_flags\t= KVM_MEM_READONLY,\t\t\t\t\\\n\t.pt_memslot_flags\t= KVM_MEM_READONLY,\t\t\t\t\\\n\t.mem_mark_cmd\t\t= CMD_HOLE_DATA | CMD_HOLE_PT,\t\t\t\\\n\t.guest_prepare\t\t= { _PREPARE(_access) },\t\t\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.uffd_data_handler\t= _uffd_data_handler,\t\t\t\t\\\n\t.uffd_pt_handler\t= uffd_pt_handler,\t\t\t\t\\\n\t.mmio_handler\t\t= _mmio_handler,\t\t\t\t\\\n\t.expected_events\t= { .mmio_exits = _mmio_exits,\t\t\t\\\n\t\t\t\t    .uffd_faults = _uffd_faults },\t\t\\\n}\n\n#define TEST_RO_MEMSLOT_NO_SYNDROME_AND_UFFD(_access, _uffd_data_handler,\t\\\n\t\t\t\t\t     _uffd_faults)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.name\t\t\t= SCAT2(ro_memslot_no_syndrome, _access),\t\\\n\t.data_memslot_flags\t= KVM_MEM_READONLY,\t\t\t\t\\\n\t.pt_memslot_flags\t= KVM_MEM_READONLY,\t\t\t\t\\\n\t.mem_mark_cmd\t\t= CMD_HOLE_DATA | CMD_HOLE_PT,\t\t\t\\\n\t.guest_test\t\t= _access,\t\t\t\t\t\\\n\t.uffd_data_handler\t= _uffd_data_handler,\t\t\t\t\\\n\t.uffd_pt_handler\t= uffd_pt_handler,\t\t\t\\\n\t.fail_vcpu_run_handler\t= fail_vcpu_run_mmio_no_syndrome_handler,\t\\\n\t.expected_events\t= { .fail_vcpu_runs = 1,\t\t\t\\\n\t\t\t\t    .uffd_faults = _uffd_faults },\t\t\\\n}\n\nstatic struct test_desc tests[] = {\n\n\t \n\tTEST_ACCESS(guest_read64, with_af, CMD_NONE),\n\tTEST_ACCESS(guest_ld_preidx, with_af, CMD_NONE),\n\tTEST_ACCESS(guest_cas, with_af, CMD_NONE),\n\tTEST_ACCESS(guest_write64, with_af, CMD_NONE),\n\tTEST_ACCESS(guest_st_preidx, with_af, CMD_NONE),\n\tTEST_ACCESS(guest_dc_zva, with_af, CMD_NONE),\n\tTEST_ACCESS(guest_exec, with_af, CMD_NONE),\n\n\t \n\tTEST_ACCESS(guest_read64, no_af, CMD_HOLE_DATA),\n\tTEST_ACCESS(guest_cas, no_af, CMD_HOLE_DATA),\n\tTEST_ACCESS(guest_ld_preidx, no_af, CMD_HOLE_DATA),\n\tTEST_ACCESS(guest_write64, no_af, CMD_HOLE_DATA),\n\tTEST_ACCESS(guest_st_preidx, no_af, CMD_HOLE_DATA),\n\tTEST_ACCESS(guest_at, no_af, CMD_HOLE_DATA),\n\tTEST_ACCESS(guest_dc_zva, no_af, CMD_HOLE_DATA),\n\n\t \n\tTEST_UFFD(guest_read64, with_af, CMD_HOLE_DATA | CMD_HOLE_PT,\n\t\t  uffd_data_handler, uffd_pt_handler, 2),\n\tTEST_UFFD(guest_read64, no_af, CMD_HOLE_DATA | CMD_HOLE_PT,\n\t\t  uffd_data_handler, uffd_pt_handler, 2),\n\tTEST_UFFD(guest_cas, with_af, CMD_HOLE_DATA | CMD_HOLE_PT,\n\t\t  uffd_data_handler, uffd_pt_handler, 2),\n\t \n\tTEST_UFFD(guest_at, no_af, CMD_HOLE_DATA | CMD_HOLE_PT,\n\t\t  uffd_no_handler, uffd_pt_handler, 1),\n\tTEST_UFFD(guest_ld_preidx, with_af, CMD_HOLE_DATA | CMD_HOLE_PT,\n\t\t  uffd_data_handler, uffd_pt_handler, 2),\n\tTEST_UFFD(guest_write64, with_af, CMD_HOLE_DATA | CMD_HOLE_PT,\n\t\t  uffd_data_handler, uffd_pt_handler, 2),\n\tTEST_UFFD(guest_dc_zva, with_af, CMD_HOLE_DATA | CMD_HOLE_PT,\n\t\t  uffd_data_handler, uffd_pt_handler, 2),\n\tTEST_UFFD(guest_st_preidx, with_af, CMD_HOLE_DATA | CMD_HOLE_PT,\n\t\t  uffd_data_handler, uffd_pt_handler, 2),\n\tTEST_UFFD(guest_exec, with_af, CMD_HOLE_DATA | CMD_HOLE_PT,\n\t\t  uffd_data_handler, uffd_pt_handler, 2),\n\n\t \n\tTEST_DIRTY_LOG(guest_read64, with_af, guest_check_no_write_in_dirty_log,\n\t\t       guest_check_s1ptw_wr_in_dirty_log),\n\tTEST_DIRTY_LOG(guest_read64, no_af, guest_check_no_write_in_dirty_log,\n\t\t       guest_check_no_s1ptw_wr_in_dirty_log),\n\tTEST_DIRTY_LOG(guest_ld_preidx, with_af,\n\t\t       guest_check_no_write_in_dirty_log,\n\t\t       guest_check_s1ptw_wr_in_dirty_log),\n\tTEST_DIRTY_LOG(guest_at, no_af, guest_check_no_write_in_dirty_log,\n\t\t       guest_check_no_s1ptw_wr_in_dirty_log),\n\tTEST_DIRTY_LOG(guest_exec, with_af, guest_check_no_write_in_dirty_log,\n\t\t       guest_check_s1ptw_wr_in_dirty_log),\n\tTEST_DIRTY_LOG(guest_write64, with_af, guest_check_write_in_dirty_log,\n\t\t       guest_check_s1ptw_wr_in_dirty_log),\n\tTEST_DIRTY_LOG(guest_cas, with_af, guest_check_write_in_dirty_log,\n\t\t       guest_check_s1ptw_wr_in_dirty_log),\n\tTEST_DIRTY_LOG(guest_dc_zva, with_af, guest_check_write_in_dirty_log,\n\t\t       guest_check_s1ptw_wr_in_dirty_log),\n\tTEST_DIRTY_LOG(guest_st_preidx, with_af, guest_check_write_in_dirty_log,\n\t\t       guest_check_s1ptw_wr_in_dirty_log),\n\n\t \n\tTEST_UFFD_AND_DIRTY_LOG(guest_read64, with_af,\n\t\t\t\tuffd_data_handler, 2,\n\t\t\t\tguest_check_no_write_in_dirty_log,\n\t\t\t\tguest_check_s1ptw_wr_in_dirty_log),\n\tTEST_UFFD_AND_DIRTY_LOG(guest_read64, no_af,\n\t\t\t\tuffd_data_handler, 2,\n\t\t\t\tguest_check_no_write_in_dirty_log,\n\t\t\t\tguest_check_no_s1ptw_wr_in_dirty_log),\n\tTEST_UFFD_AND_DIRTY_LOG(guest_ld_preidx, with_af,\n\t\t\t\tuffd_data_handler,\n\t\t\t\t2, guest_check_no_write_in_dirty_log,\n\t\t\t\tguest_check_s1ptw_wr_in_dirty_log),\n\tTEST_UFFD_AND_DIRTY_LOG(guest_at, with_af, uffd_no_handler, 1,\n\t\t\t\tguest_check_no_write_in_dirty_log,\n\t\t\t\tguest_check_s1ptw_wr_in_dirty_log),\n\tTEST_UFFD_AND_DIRTY_LOG(guest_exec, with_af,\n\t\t\t\tuffd_data_handler, 2,\n\t\t\t\tguest_check_no_write_in_dirty_log,\n\t\t\t\tguest_check_s1ptw_wr_in_dirty_log),\n\tTEST_UFFD_AND_DIRTY_LOG(guest_write64, with_af,\n\t\t\t\tuffd_data_handler,\n\t\t\t\t2, guest_check_write_in_dirty_log,\n\t\t\t\tguest_check_s1ptw_wr_in_dirty_log),\n\tTEST_UFFD_AND_DIRTY_LOG(guest_cas, with_af,\n\t\t\t\tuffd_data_handler, 2,\n\t\t\t\tguest_check_write_in_dirty_log,\n\t\t\t\tguest_check_s1ptw_wr_in_dirty_log),\n\tTEST_UFFD_AND_DIRTY_LOG(guest_dc_zva, with_af,\n\t\t\t\tuffd_data_handler,\n\t\t\t\t2, guest_check_write_in_dirty_log,\n\t\t\t\tguest_check_s1ptw_wr_in_dirty_log),\n\tTEST_UFFD_AND_DIRTY_LOG(guest_st_preidx, with_af,\n\t\t\t\tuffd_data_handler, 2,\n\t\t\t\tguest_check_write_in_dirty_log,\n\t\t\t\tguest_check_s1ptw_wr_in_dirty_log),\n\t \n\tTEST_RO_MEMSLOT(guest_read64, 0, 0),\n\tTEST_RO_MEMSLOT(guest_ld_preidx, 0, 0),\n\tTEST_RO_MEMSLOT(guest_at, 0, 0),\n\tTEST_RO_MEMSLOT(guest_exec, 0, 0),\n\tTEST_RO_MEMSLOT(guest_write64, mmio_on_test_gpa_handler, 1),\n\tTEST_RO_MEMSLOT_NO_SYNDROME(guest_dc_zva),\n\tTEST_RO_MEMSLOT_NO_SYNDROME(guest_cas),\n\tTEST_RO_MEMSLOT_NO_SYNDROME(guest_st_preidx),\n\n\t \n\tTEST_RO_MEMSLOT_AND_DIRTY_LOG(guest_read64, 0, 0,\n\t\t\t\t      guest_check_no_write_in_dirty_log),\n\tTEST_RO_MEMSLOT_AND_DIRTY_LOG(guest_ld_preidx, 0, 0,\n\t\t\t\t      guest_check_no_write_in_dirty_log),\n\tTEST_RO_MEMSLOT_AND_DIRTY_LOG(guest_at, 0, 0,\n\t\t\t\t      guest_check_no_write_in_dirty_log),\n\tTEST_RO_MEMSLOT_AND_DIRTY_LOG(guest_exec, 0, 0,\n\t\t\t\t      guest_check_no_write_in_dirty_log),\n\tTEST_RO_MEMSLOT_AND_DIRTY_LOG(guest_write64, mmio_on_test_gpa_handler,\n\t\t\t\t      1, guest_check_no_write_in_dirty_log),\n\tTEST_RO_MEMSLOT_NO_SYNDROME_AND_DIRTY_LOG(guest_dc_zva,\n\t\t\t\t\t\t  guest_check_no_write_in_dirty_log),\n\tTEST_RO_MEMSLOT_NO_SYNDROME_AND_DIRTY_LOG(guest_cas,\n\t\t\t\t\t\t  guest_check_no_write_in_dirty_log),\n\tTEST_RO_MEMSLOT_NO_SYNDROME_AND_DIRTY_LOG(guest_st_preidx,\n\t\t\t\t\t\t  guest_check_no_write_in_dirty_log),\n\n\t \n\tTEST_RO_MEMSLOT_AND_UFFD(guest_read64, 0, 0, uffd_data_handler, 2),\n\tTEST_RO_MEMSLOT_AND_UFFD(guest_ld_preidx, 0, 0, uffd_data_handler, 2),\n\tTEST_RO_MEMSLOT_AND_UFFD(guest_at, 0, 0, uffd_no_handler, 1),\n\tTEST_RO_MEMSLOT_AND_UFFD(guest_exec, 0, 0, uffd_data_handler, 2),\n\tTEST_RO_MEMSLOT_AND_UFFD(guest_write64, mmio_on_test_gpa_handler, 1,\n\t\t\t\t uffd_data_handler, 2),\n\tTEST_RO_MEMSLOT_NO_SYNDROME_AND_UFFD(guest_cas, uffd_data_handler, 2),\n\tTEST_RO_MEMSLOT_NO_SYNDROME_AND_UFFD(guest_dc_zva, uffd_no_handler, 1),\n\tTEST_RO_MEMSLOT_NO_SYNDROME_AND_UFFD(guest_st_preidx, uffd_no_handler, 1),\n\n\t{ 0 }\n};\n\nstatic void for_each_test_and_guest_mode(enum vm_mem_backing_src_type src_type)\n{\n\tstruct test_desc *t;\n\n\tfor (t = &tests[0]; t->name; t++) {\n\t\tif (t->skip)\n\t\t\tcontinue;\n\n\t\tstruct test_params p = {\n\t\t\t.src_type = src_type,\n\t\t\t.test_desc = t,\n\t\t};\n\n\t\tfor_each_guest_mode(run_test, &p);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tenum vm_mem_backing_src_type src_type;\n\tint opt;\n\n\tsrc_type = DEFAULT_VM_MEM_SRC;\n\n\twhile ((opt = getopt(argc, argv, \"hm:s:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'm':\n\t\t\tguest_modes_cmdline(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsrc_type = parse_backing_src_type(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tfor_each_test_and_guest_mode(src_type);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}