{
  "module_name": "arch_timer.c",
  "hash_id": "053578d36ad1a8e86aba352c015cf0f6e35935644c87781e459a9cfd35be3c62",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/aarch64/arch_timer.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <pthread.h>\n#include <linux/kvm.h>\n#include <linux/sizes.h>\n#include <linux/bitmap.h>\n#include <sys/sysinfo.h>\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"delay.h\"\n#include \"arch_timer.h\"\n#include \"gic.h\"\n#include \"vgic.h\"\n\n#define NR_VCPUS_DEF\t\t\t4\n#define NR_TEST_ITERS_DEF\t\t5\n#define TIMER_TEST_PERIOD_MS_DEF\t10\n#define TIMER_TEST_ERR_MARGIN_US\t100\n#define TIMER_TEST_MIGRATION_FREQ_MS\t2\n\nstruct test_args {\n\tint nr_vcpus;\n\tint nr_iter;\n\tint timer_period_ms;\n\tint migration_freq_ms;\n\tstruct kvm_arm_counter_offset offset;\n};\n\nstatic struct test_args test_args = {\n\t.nr_vcpus = NR_VCPUS_DEF,\n\t.nr_iter = NR_TEST_ITERS_DEF,\n\t.timer_period_ms = TIMER_TEST_PERIOD_MS_DEF,\n\t.migration_freq_ms = TIMER_TEST_MIGRATION_FREQ_MS,\n\t.offset = { .reserved = 1 },\n};\n\n#define msecs_to_usecs(msec)\t\t((msec) * 1000LL)\n\n#define GICD_BASE_GPA\t\t\t0x8000000ULL\n#define GICR_BASE_GPA\t\t\t0x80A0000ULL\n\nenum guest_stage {\n\tGUEST_STAGE_VTIMER_CVAL = 1,\n\tGUEST_STAGE_VTIMER_TVAL,\n\tGUEST_STAGE_PTIMER_CVAL,\n\tGUEST_STAGE_PTIMER_TVAL,\n\tGUEST_STAGE_MAX,\n};\n\n \nstruct test_vcpu_shared_data {\n\tint nr_iter;\n\tenum guest_stage guest_stage;\n\tuint64_t xcnt;\n};\n\nstatic struct kvm_vcpu *vcpus[KVM_MAX_VCPUS];\nstatic pthread_t pt_vcpu_run[KVM_MAX_VCPUS];\nstatic struct test_vcpu_shared_data vcpu_shared_data[KVM_MAX_VCPUS];\n\nstatic int vtimer_irq, ptimer_irq;\n\nstatic unsigned long *vcpu_done_map;\nstatic pthread_mutex_t vcpu_done_map_lock;\n\nstatic void\nguest_configure_timer_action(struct test_vcpu_shared_data *shared_data)\n{\n\tswitch (shared_data->guest_stage) {\n\tcase GUEST_STAGE_VTIMER_CVAL:\n\t\ttimer_set_next_cval_ms(VIRTUAL, test_args.timer_period_ms);\n\t\tshared_data->xcnt = timer_get_cntct(VIRTUAL);\n\t\ttimer_set_ctl(VIRTUAL, CTL_ENABLE);\n\t\tbreak;\n\tcase GUEST_STAGE_VTIMER_TVAL:\n\t\ttimer_set_next_tval_ms(VIRTUAL, test_args.timer_period_ms);\n\t\tshared_data->xcnt = timer_get_cntct(VIRTUAL);\n\t\ttimer_set_ctl(VIRTUAL, CTL_ENABLE);\n\t\tbreak;\n\tcase GUEST_STAGE_PTIMER_CVAL:\n\t\ttimer_set_next_cval_ms(PHYSICAL, test_args.timer_period_ms);\n\t\tshared_data->xcnt = timer_get_cntct(PHYSICAL);\n\t\ttimer_set_ctl(PHYSICAL, CTL_ENABLE);\n\t\tbreak;\n\tcase GUEST_STAGE_PTIMER_TVAL:\n\t\ttimer_set_next_tval_ms(PHYSICAL, test_args.timer_period_ms);\n\t\tshared_data->xcnt = timer_get_cntct(PHYSICAL);\n\t\ttimer_set_ctl(PHYSICAL, CTL_ENABLE);\n\t\tbreak;\n\tdefault:\n\t\tGUEST_ASSERT(0);\n\t}\n}\n\nstatic void guest_validate_irq(unsigned int intid,\n\t\t\t\tstruct test_vcpu_shared_data *shared_data)\n{\n\tenum guest_stage stage = shared_data->guest_stage;\n\tuint64_t xcnt = 0, xcnt_diff_us, cval = 0;\n\tunsigned long xctl = 0;\n\tunsigned int timer_irq = 0;\n\tunsigned int accessor;\n\n\tif (intid == IAR_SPURIOUS)\n\t\treturn;\n\n\tswitch (stage) {\n\tcase GUEST_STAGE_VTIMER_CVAL:\n\tcase GUEST_STAGE_VTIMER_TVAL:\n\t\taccessor = VIRTUAL;\n\t\ttimer_irq = vtimer_irq;\n\t\tbreak;\n\tcase GUEST_STAGE_PTIMER_CVAL:\n\tcase GUEST_STAGE_PTIMER_TVAL:\n\t\taccessor = PHYSICAL;\n\t\ttimer_irq = ptimer_irq;\n\t\tbreak;\n\tdefault:\n\t\tGUEST_ASSERT(0);\n\t\treturn;\n\t}\n\n\txctl = timer_get_ctl(accessor);\n\tif ((xctl & CTL_IMASK) || !(xctl & CTL_ENABLE))\n\t\treturn;\n\n\ttimer_set_ctl(accessor, CTL_IMASK);\n\txcnt = timer_get_cntct(accessor);\n\tcval = timer_get_cval(accessor);\n\n\txcnt_diff_us = cycles_to_usec(xcnt - shared_data->xcnt);\n\n\t \n\tGUEST_ASSERT_EQ(intid, timer_irq);\n\n\t \n\t__GUEST_ASSERT(xcnt >= cval,\n\t\t       \"xcnt = 0x%llx, cval = 0x%llx, xcnt_diff_us = 0x%llx\",\n\t\t       xcnt, cval, xcnt_diff_us);\n\t__GUEST_ASSERT(xctl & CTL_ISTATUS, \"xcnt = 0x%llx\", xcnt);\n\n\tWRITE_ONCE(shared_data->nr_iter, shared_data->nr_iter + 1);\n}\n\nstatic void guest_irq_handler(struct ex_regs *regs)\n{\n\tunsigned int intid = gic_get_and_ack_irq();\n\tuint32_t cpu = guest_get_vcpuid();\n\tstruct test_vcpu_shared_data *shared_data = &vcpu_shared_data[cpu];\n\n\tguest_validate_irq(intid, shared_data);\n\n\tgic_set_eoi(intid);\n}\n\nstatic void guest_run_stage(struct test_vcpu_shared_data *shared_data,\n\t\t\t\tenum guest_stage stage)\n{\n\tuint32_t irq_iter, config_iter;\n\n\tshared_data->guest_stage = stage;\n\tshared_data->nr_iter = 0;\n\n\tfor (config_iter = 0; config_iter < test_args.nr_iter; config_iter++) {\n\t\t \n\t\tguest_configure_timer_action(shared_data);\n\n\t\t \n\t\tudelay(msecs_to_usecs(test_args.timer_period_ms) +\n\t\t\tTIMER_TEST_ERR_MARGIN_US);\n\n\t\tirq_iter = READ_ONCE(shared_data->nr_iter);\n\t\tGUEST_ASSERT_EQ(config_iter + 1, irq_iter);\n\t}\n}\n\nstatic void guest_code(void)\n{\n\tuint32_t cpu = guest_get_vcpuid();\n\tstruct test_vcpu_shared_data *shared_data = &vcpu_shared_data[cpu];\n\n\tlocal_irq_disable();\n\n\tgic_init(GIC_V3, test_args.nr_vcpus,\n\t\t(void *)GICD_BASE_GPA, (void *)GICR_BASE_GPA);\n\n\ttimer_set_ctl(VIRTUAL, CTL_IMASK);\n\ttimer_set_ctl(PHYSICAL, CTL_IMASK);\n\n\tgic_irq_enable(vtimer_irq);\n\tgic_irq_enable(ptimer_irq);\n\tlocal_irq_enable();\n\n\tguest_run_stage(shared_data, GUEST_STAGE_VTIMER_CVAL);\n\tguest_run_stage(shared_data, GUEST_STAGE_VTIMER_TVAL);\n\tguest_run_stage(shared_data, GUEST_STAGE_PTIMER_CVAL);\n\tguest_run_stage(shared_data, GUEST_STAGE_PTIMER_TVAL);\n\n\tGUEST_DONE();\n}\n\nstatic void *test_vcpu_run(void *arg)\n{\n\tunsigned int vcpu_idx = (unsigned long)arg;\n\tstruct ucall uc;\n\tstruct kvm_vcpu *vcpu = vcpus[vcpu_idx];\n\tstruct kvm_vm *vm = vcpu->vm;\n\tstruct test_vcpu_shared_data *shared_data = &vcpu_shared_data[vcpu_idx];\n\n\tvcpu_run(vcpu);\n\n\t \n\tpthread_mutex_lock(&vcpu_done_map_lock);\n\t__set_bit(vcpu_idx, vcpu_done_map);\n\tpthread_mutex_unlock(&vcpu_done_map_lock);\n\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_SYNC:\n\tcase UCALL_DONE:\n\t\tbreak;\n\tcase UCALL_ABORT:\n\t\tsync_global_from_guest(vm, *shared_data);\n\t\tfprintf(stderr, \"Guest assert failed,  vcpu %u; stage; %u; iter: %u\\n\",\n\t\t\tvcpu_idx, shared_data->guest_stage, shared_data->nr_iter);\n\t\tREPORT_GUEST_ASSERT(uc);\n\t\tbreak;\n\tdefault:\n\t\tTEST_FAIL(\"Unexpected guest exit\\n\");\n\t}\n\n\treturn NULL;\n}\n\nstatic uint32_t test_get_pcpu(void)\n{\n\tuint32_t pcpu;\n\tunsigned int nproc_conf;\n\tcpu_set_t online_cpuset;\n\n\tnproc_conf = get_nprocs_conf();\n\tsched_getaffinity(0, sizeof(cpu_set_t), &online_cpuset);\n\n\t \n\tdo {\n\t\tpcpu = rand() % nproc_conf;\n\t} while (!CPU_ISSET(pcpu, &online_cpuset));\n\n\treturn pcpu;\n}\n\nstatic int test_migrate_vcpu(unsigned int vcpu_idx)\n{\n\tint ret;\n\tcpu_set_t cpuset;\n\tuint32_t new_pcpu = test_get_pcpu();\n\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(new_pcpu, &cpuset);\n\n\tpr_debug(\"Migrating vCPU: %u to pCPU: %u\\n\", vcpu_idx, new_pcpu);\n\n\tret = pthread_setaffinity_np(pt_vcpu_run[vcpu_idx],\n\t\t\t\t     sizeof(cpuset), &cpuset);\n\n\t \n\tTEST_ASSERT(ret == 0 || ret == ESRCH,\n\t\t    \"Failed to migrate the vCPU:%u to pCPU: %u; ret: %d\\n\",\n\t\t    vcpu_idx, new_pcpu, ret);\n\n\treturn ret;\n}\n\nstatic void *test_vcpu_migration(void *arg)\n{\n\tunsigned int i, n_done;\n\tbool vcpu_done;\n\n\tdo {\n\t\tusleep(msecs_to_usecs(test_args.migration_freq_ms));\n\n\t\tfor (n_done = 0, i = 0; i < test_args.nr_vcpus; i++) {\n\t\t\tpthread_mutex_lock(&vcpu_done_map_lock);\n\t\t\tvcpu_done = test_bit(i, vcpu_done_map);\n\t\t\tpthread_mutex_unlock(&vcpu_done_map_lock);\n\n\t\t\tif (vcpu_done) {\n\t\t\t\tn_done++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttest_migrate_vcpu(i);\n\t\t}\n\t} while (test_args.nr_vcpus != n_done);\n\n\treturn NULL;\n}\n\nstatic void test_run(struct kvm_vm *vm)\n{\n\tpthread_t pt_vcpu_migration;\n\tunsigned int i;\n\tint ret;\n\n\tpthread_mutex_init(&vcpu_done_map_lock, NULL);\n\tvcpu_done_map = bitmap_zalloc(test_args.nr_vcpus);\n\tTEST_ASSERT(vcpu_done_map, \"Failed to allocate vcpu done bitmap\\n\");\n\n\tfor (i = 0; i < (unsigned long)test_args.nr_vcpus; i++) {\n\t\tret = pthread_create(&pt_vcpu_run[i], NULL, test_vcpu_run,\n\t\t\t\t     (void *)(unsigned long)i);\n\t\tTEST_ASSERT(!ret, \"Failed to create vCPU-%d pthread\\n\", i);\n\t}\n\n\t \n\tif (test_args.migration_freq_ms) {\n\t\tsrand(time(NULL));\n\n\t\tret = pthread_create(&pt_vcpu_migration, NULL,\n\t\t\t\t\ttest_vcpu_migration, NULL);\n\t\tTEST_ASSERT(!ret, \"Failed to create the migration pthread\\n\");\n\t}\n\n\n\tfor (i = 0; i < test_args.nr_vcpus; i++)\n\t\tpthread_join(pt_vcpu_run[i], NULL);\n\n\tif (test_args.migration_freq_ms)\n\t\tpthread_join(pt_vcpu_migration, NULL);\n\n\tbitmap_free(vcpu_done_map);\n}\n\nstatic void test_init_timer_irq(struct kvm_vm *vm)\n{\n\t \n\tvcpu_device_attr_get(vcpus[0], KVM_ARM_VCPU_TIMER_CTRL,\n\t\t\t     KVM_ARM_VCPU_TIMER_IRQ_PTIMER, &ptimer_irq);\n\tvcpu_device_attr_get(vcpus[0], KVM_ARM_VCPU_TIMER_CTRL,\n\t\t\t     KVM_ARM_VCPU_TIMER_IRQ_VTIMER, &vtimer_irq);\n\n\tsync_global_to_guest(vm, ptimer_irq);\n\tsync_global_to_guest(vm, vtimer_irq);\n\n\tpr_debug(\"ptimer_irq: %d; vtimer_irq: %d\\n\", ptimer_irq, vtimer_irq);\n}\n\nstatic int gic_fd;\n\nstatic struct kvm_vm *test_vm_create(void)\n{\n\tstruct kvm_vm *vm;\n\tunsigned int i;\n\tint nr_vcpus = test_args.nr_vcpus;\n\n\tvm = vm_create_with_vcpus(nr_vcpus, guest_code, vcpus);\n\n\tvm_init_descriptor_tables(vm);\n\tvm_install_exception_handler(vm, VECTOR_IRQ_CURRENT, guest_irq_handler);\n\n\tif (!test_args.offset.reserved) {\n\t\tif (kvm_has_cap(KVM_CAP_COUNTER_OFFSET))\n\t\t\tvm_ioctl(vm, KVM_ARM_SET_COUNTER_OFFSET, &test_args.offset);\n\t\telse\n\t\t\tTEST_FAIL(\"no support for global offset\\n\");\n\t}\n\n\tfor (i = 0; i < nr_vcpus; i++)\n\t\tvcpu_init_descriptor_tables(vcpus[i]);\n\n\ttest_init_timer_irq(vm);\n\tgic_fd = vgic_v3_setup(vm, nr_vcpus, 64, GICD_BASE_GPA, GICR_BASE_GPA);\n\t__TEST_REQUIRE(gic_fd >= 0, \"Failed to create vgic-v3\");\n\n\t \n\tsync_global_to_guest(vm, test_args);\n\n\treturn vm;\n}\n\nstatic void test_vm_cleanup(struct kvm_vm *vm)\n{\n\tclose(gic_fd);\n\tkvm_vm_free(vm);\n}\n\nstatic void test_print_help(char *name)\n{\n\tpr_info(\"Usage: %s [-h] [-n nr_vcpus] [-i iterations] [-p timer_period_ms]\\n\",\n\t\tname);\n\tpr_info(\"\\t-n: Number of vCPUs to configure (default: %u; max: %u)\\n\",\n\t\tNR_VCPUS_DEF, KVM_MAX_VCPUS);\n\tpr_info(\"\\t-i: Number of iterations per stage (default: %u)\\n\",\n\t\tNR_TEST_ITERS_DEF);\n\tpr_info(\"\\t-p: Periodicity (in ms) of the guest timer (default: %u)\\n\",\n\t\tTIMER_TEST_PERIOD_MS_DEF);\n\tpr_info(\"\\t-m: Frequency (in ms) of vCPUs to migrate to different pCPU. 0 to turn off (default: %u)\\n\",\n\t\tTIMER_TEST_MIGRATION_FREQ_MS);\n\tpr_info(\"\\t-o: Counter offset (in counter cycles, default: 0)\\n\");\n\tpr_info(\"\\t-h: print this help screen\\n\");\n}\n\nstatic bool parse_args(int argc, char *argv[])\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"hn:i:p:m:o:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'n':\n\t\t\ttest_args.nr_vcpus = atoi_positive(\"Number of vCPUs\", optarg);\n\t\t\tif (test_args.nr_vcpus > KVM_MAX_VCPUS) {\n\t\t\t\tpr_info(\"Max allowed vCPUs: %u\\n\",\n\t\t\t\t\tKVM_MAX_VCPUS);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\ttest_args.nr_iter = atoi_positive(\"Number of iterations\", optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttest_args.timer_period_ms = atoi_positive(\"Periodicity\", optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\ttest_args.migration_freq_ms = atoi_non_negative(\"Frequency\", optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\ttest_args.offset.counter_offset = strtol(optarg, NULL, 0);\n\t\t\ttest_args.offset.reserved = 0;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn true;\n\nerr:\n\ttest_print_help(argv[0]);\n\treturn false;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vm *vm;\n\n\tif (!parse_args(argc, argv))\n\t\texit(KSFT_SKIP);\n\n\t__TEST_REQUIRE(!test_args.migration_freq_ms || get_nprocs() >= 2,\n\t\t       \"At least two physical CPUs needed for vCPU migration\");\n\n\tvm = test_vm_create();\n\ttest_run(vm);\n\ttest_vm_cleanup(vm);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}