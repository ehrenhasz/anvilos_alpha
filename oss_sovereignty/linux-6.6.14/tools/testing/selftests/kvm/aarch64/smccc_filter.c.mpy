{
  "module_name": "smccc_filter.c",
  "hash_id": "5d830ea5b167ea69310bd864ec2b1510c92558ca98fe8872337c5c3f628c7854",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/aarch64/smccc_filter.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/psci.h>\n#include <stdint.h>\n\n#include \"processor.h\"\n#include \"test_util.h\"\n\nenum smccc_conduit {\n\tHVC_INSN,\n\tSMC_INSN,\n};\n\n#define for_each_conduit(conduit)\t\t\t\t\t\\\n\tfor (conduit = HVC_INSN; conduit <= SMC_INSN; conduit++)\n\nstatic void guest_main(uint32_t func_id, enum smccc_conduit conduit)\n{\n\tstruct arm_smccc_res res;\n\n\tif (conduit == SMC_INSN)\n\t\tsmccc_smc(func_id, 0, 0, 0, 0, 0, 0, 0, &res);\n\telse\n\t\tsmccc_hvc(func_id, 0, 0, 0, 0, 0, 0, 0, &res);\n\n\tGUEST_SYNC(res.a0);\n}\n\nstatic int __set_smccc_filter(struct kvm_vm *vm, uint32_t start, uint32_t nr_functions,\n\t\t\t      enum kvm_smccc_filter_action action)\n{\n\tstruct kvm_smccc_filter filter = {\n\t\t.base\t\t= start,\n\t\t.nr_functions\t= nr_functions,\n\t\t.action\t\t= action,\n\t};\n\n\treturn __kvm_device_attr_set(vm->fd, KVM_ARM_VM_SMCCC_CTRL,\n\t\t\t\t     KVM_ARM_VM_SMCCC_FILTER, &filter);\n}\n\nstatic void set_smccc_filter(struct kvm_vm *vm, uint32_t start, uint32_t nr_functions,\n\t\t\t     enum kvm_smccc_filter_action action)\n{\n\tint ret = __set_smccc_filter(vm, start, nr_functions, action);\n\n\tTEST_ASSERT(!ret, \"failed to configure SMCCC filter: %d\", ret);\n}\n\nstatic struct kvm_vm *setup_vm(struct kvm_vcpu **vcpu)\n{\n\tstruct kvm_vcpu_init init;\n\tstruct kvm_vm *vm;\n\n\tvm = vm_create(1);\n\tvm_ioctl(vm, KVM_ARM_PREFERRED_TARGET, &init);\n\n\t \n\tinit.features[0] |= (1 << KVM_ARM_VCPU_PSCI_0_2);\n\n\t*vcpu = aarch64_vcpu_add(vm, 0, &init, guest_main);\n\treturn vm;\n}\n\nstatic void test_pad_must_be_zero(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = setup_vm(&vcpu);\n\tstruct kvm_smccc_filter filter = {\n\t\t.base\t\t= PSCI_0_2_FN_PSCI_VERSION,\n\t\t.nr_functions\t= 1,\n\t\t.action\t\t= KVM_SMCCC_FILTER_DENY,\n\t\t.pad\t\t= { -1 },\n\t};\n\tint r;\n\n\tr = __kvm_device_attr_set(vm->fd, KVM_ARM_VM_SMCCC_CTRL,\n\t\t\t\t  KVM_ARM_VM_SMCCC_FILTER, &filter);\n\tTEST_ASSERT(r < 0 && errno == EINVAL,\n\t\t    \"Setting filter with nonzero padding should return EINVAL\");\n}\n\n \nstatic void test_filter_reserved_range(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = setup_vm(&vcpu);\n\tuint32_t smc64_fn;\n\tint r;\n\n\tr = __set_smccc_filter(vm, ARM_SMCCC_ARCH_WORKAROUND_1,\n\t\t\t       1, KVM_SMCCC_FILTER_DENY);\n\tTEST_ASSERT(r < 0 && errno == EEXIST,\n\t\t    \"Attempt to filter reserved range should return EEXIST\");\n\n\tsmc64_fn = ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, ARM_SMCCC_SMC_64,\n\t\t\t\t      0, 0);\n\n\tr = __set_smccc_filter(vm, smc64_fn, 1, KVM_SMCCC_FILTER_DENY);\n\tTEST_ASSERT(r < 0 && errno == EEXIST,\n\t\t    \"Attempt to filter reserved range should return EEXIST\");\n\n\tkvm_vm_free(vm);\n}\n\nstatic void test_invalid_nr_functions(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = setup_vm(&vcpu);\n\tint r;\n\n\tr = __set_smccc_filter(vm, PSCI_0_2_FN64_CPU_ON, 0, KVM_SMCCC_FILTER_DENY);\n\tTEST_ASSERT(r < 0 && errno == EINVAL,\n\t\t    \"Attempt to filter 0 functions should return EINVAL\");\n\n\tkvm_vm_free(vm);\n}\n\nstatic void test_overflow_nr_functions(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = setup_vm(&vcpu);\n\tint r;\n\n\tr = __set_smccc_filter(vm, ~0, ~0, KVM_SMCCC_FILTER_DENY);\n\tTEST_ASSERT(r < 0 && errno == EINVAL,\n\t\t    \"Attempt to overflow filter range should return EINVAL\");\n\n\tkvm_vm_free(vm);\n}\n\nstatic void test_reserved_action(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = setup_vm(&vcpu);\n\tint r;\n\n\tr = __set_smccc_filter(vm, PSCI_0_2_FN64_CPU_ON, 1, -1);\n\tTEST_ASSERT(r < 0 && errno == EINVAL,\n\t\t    \"Attempt to use reserved filter action should return EINVAL\");\n\n\tkvm_vm_free(vm);\n}\n\n\n \nstatic void test_filter_overlap(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = setup_vm(&vcpu);\n\tint r;\n\n\tset_smccc_filter(vm, PSCI_0_2_FN64_CPU_ON, 1, KVM_SMCCC_FILTER_DENY);\n\n\tr = __set_smccc_filter(vm, PSCI_0_2_FN64_CPU_ON, 1, KVM_SMCCC_FILTER_DENY);\n\tTEST_ASSERT(r < 0 && errno == EEXIST,\n\t\t    \"Attempt to filter already configured range should return EEXIST\");\n\n\tkvm_vm_free(vm);\n}\n\nstatic void expect_call_denied(struct kvm_vcpu *vcpu)\n{\n\tstruct ucall uc;\n\n\tif (get_ucall(vcpu, &uc) != UCALL_SYNC)\n\t\tTEST_FAIL(\"Unexpected ucall: %lu\\n\", uc.cmd);\n\n\tTEST_ASSERT(uc.args[1] == SMCCC_RET_NOT_SUPPORTED,\n\t\t    \"Unexpected SMCCC return code: %lu\", uc.args[1]);\n}\n\n \nstatic void test_filter_denied(void)\n{\n\tenum smccc_conduit conduit;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tfor_each_conduit(conduit) {\n\t\tvm = setup_vm(&vcpu);\n\n\t\tset_smccc_filter(vm, PSCI_0_2_FN_PSCI_VERSION, 1, KVM_SMCCC_FILTER_DENY);\n\t\tvcpu_args_set(vcpu, 2, PSCI_0_2_FN_PSCI_VERSION, conduit);\n\n\t\tvcpu_run(vcpu);\n\t\texpect_call_denied(vcpu);\n\n\t\tkvm_vm_free(vm);\n\t}\n}\n\nstatic void expect_call_fwd_to_user(struct kvm_vcpu *vcpu, uint32_t func_id,\n\t\t\t\t    enum smccc_conduit conduit)\n{\n\tstruct kvm_run *run = vcpu->run;\n\n\tTEST_ASSERT(run->exit_reason == KVM_EXIT_HYPERCALL,\n\t\t    \"Unexpected exit reason: %u\", run->exit_reason);\n\tTEST_ASSERT(run->hypercall.nr == func_id,\n\t\t    \"Unexpected SMCCC function: %llu\", run->hypercall.nr);\n\n\tif (conduit == SMC_INSN)\n\t\tTEST_ASSERT(run->hypercall.flags & KVM_HYPERCALL_EXIT_SMC,\n\t\t\t    \"KVM_HYPERCALL_EXIT_SMC is not set\");\n\telse\n\t\tTEST_ASSERT(!(run->hypercall.flags & KVM_HYPERCALL_EXIT_SMC),\n\t\t\t    \"KVM_HYPERCALL_EXIT_SMC is set\");\n}\n\n \nstatic void test_filter_fwd_to_user(void)\n{\n\tenum smccc_conduit conduit;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tfor_each_conduit(conduit) {\n\t\tvm = setup_vm(&vcpu);\n\n\t\tset_smccc_filter(vm, PSCI_0_2_FN_PSCI_VERSION, 1, KVM_SMCCC_FILTER_FWD_TO_USER);\n\t\tvcpu_args_set(vcpu, 2, PSCI_0_2_FN_PSCI_VERSION, conduit);\n\n\t\tvcpu_run(vcpu);\n\t\texpect_call_fwd_to_user(vcpu, PSCI_0_2_FN_PSCI_VERSION, conduit);\n\n\t\tkvm_vm_free(vm);\n\t}\n}\n\nstatic bool kvm_supports_smccc_filter(void)\n{\n\tstruct kvm_vm *vm = vm_create_barebones();\n\tint r;\n\n\tr = __kvm_has_device_attr(vm->fd, KVM_ARM_VM_SMCCC_CTRL, KVM_ARM_VM_SMCCC_FILTER);\n\n\tkvm_vm_free(vm);\n\treturn !r;\n}\n\nint main(void)\n{\n\tTEST_REQUIRE(kvm_supports_smccc_filter());\n\n\ttest_pad_must_be_zero();\n\ttest_invalid_nr_functions();\n\ttest_overflow_nr_functions();\n\ttest_reserved_action();\n\ttest_filter_reserved_range();\n\ttest_filter_overlap();\n\ttest_filter_denied();\n\ttest_filter_fwd_to_user();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}