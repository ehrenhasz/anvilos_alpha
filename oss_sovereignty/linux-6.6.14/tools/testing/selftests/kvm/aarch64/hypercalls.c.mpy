{
  "module_name": "hypercalls.c",
  "hash_id": "7af83d0883dc29e0d293f613decefa87b0f18dff17f6667b3711fc6b3b44b9cd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/aarch64/hypercalls.c",
  "human_readable_source": "\n\n \n#include <errno.h>\n#include <linux/arm-smccc.h>\n#include <asm/kvm.h>\n#include <kvm_util.h>\n\n#include \"processor.h\"\n\n#define FW_REG_ULIMIT_VAL(max_feat_bit) (GENMASK(max_feat_bit, 0))\n\n \n#define KVM_REG_ARM_STD_BMAP_BIT_MAX\t\t0\n#define KVM_REG_ARM_STD_HYP_BMAP_BIT_MAX\t0\n#define KVM_REG_ARM_VENDOR_HYP_BMAP_BIT_MAX\t1\n\nstruct kvm_fw_reg_info {\n\tuint64_t reg;\t\t \n\tuint64_t max_feat_bit;\t \n};\n\n#define FW_REG_INFO(r)\t\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.reg = r,\t\t\t\\\n\t\t.max_feat_bit = r##_BIT_MAX,\t\\\n\t}\n\nstatic const struct kvm_fw_reg_info fw_reg_info[] = {\n\tFW_REG_INFO(KVM_REG_ARM_STD_BMAP),\n\tFW_REG_INFO(KVM_REG_ARM_STD_HYP_BMAP),\n\tFW_REG_INFO(KVM_REG_ARM_VENDOR_HYP_BMAP),\n};\n\nenum test_stage {\n\tTEST_STAGE_REG_IFACE,\n\tTEST_STAGE_HVC_IFACE_FEAT_DISABLED,\n\tTEST_STAGE_HVC_IFACE_FEAT_ENABLED,\n\tTEST_STAGE_HVC_IFACE_FALSE_INFO,\n\tTEST_STAGE_END,\n};\n\nstatic int stage = TEST_STAGE_REG_IFACE;\n\nstruct test_hvc_info {\n\tuint32_t func_id;\n\tuint64_t arg1;\n};\n\n#define TEST_HVC_INFO(f, a1)\t\\\n\t{\t\t\t\\\n\t\t.func_id = f,\t\\\n\t\t.arg1 = a1,\t\\\n\t}\n\nstatic const struct test_hvc_info hvc_info[] = {\n\t \n\tTEST_HVC_INFO(ARM_SMCCC_TRNG_VERSION, 0),\n\tTEST_HVC_INFO(ARM_SMCCC_TRNG_FEATURES, ARM_SMCCC_TRNG_RND64),\n\tTEST_HVC_INFO(ARM_SMCCC_TRNG_GET_UUID, 0),\n\tTEST_HVC_INFO(ARM_SMCCC_TRNG_RND32, 0),\n\tTEST_HVC_INFO(ARM_SMCCC_TRNG_RND64, 0),\n\n\t \n\tTEST_HVC_INFO(ARM_SMCCC_ARCH_FEATURES_FUNC_ID, ARM_SMCCC_HV_PV_TIME_FEATURES),\n\tTEST_HVC_INFO(ARM_SMCCC_HV_PV_TIME_FEATURES, ARM_SMCCC_HV_PV_TIME_ST),\n\tTEST_HVC_INFO(ARM_SMCCC_HV_PV_TIME_ST, 0),\n\n\t \n\tTEST_HVC_INFO(ARM_SMCCC_VENDOR_HYP_KVM_FEATURES_FUNC_ID,\n\t\t\tARM_SMCCC_VENDOR_HYP_KVM_PTP_FUNC_ID),\n\tTEST_HVC_INFO(ARM_SMCCC_VENDOR_HYP_CALL_UID_FUNC_ID, 0),\n\tTEST_HVC_INFO(ARM_SMCCC_VENDOR_HYP_KVM_PTP_FUNC_ID, KVM_PTP_VIRT_COUNTER),\n};\n\n \nstatic const struct test_hvc_info false_hvc_info[] = {\n\t \n\tTEST_HVC_INFO(ARM_SMCCC_TRNG_FEATURES, ARM_SMCCC_VENDOR_HYP_KVM_PTP_FUNC_ID),\n\tTEST_HVC_INFO(ARM_SMCCC_ARCH_FEATURES_FUNC_ID, ARM_SMCCC_TRNG_RND64),\n\tTEST_HVC_INFO(ARM_SMCCC_HV_PV_TIME_FEATURES, ARM_SMCCC_TRNG_RND64),\n};\n\nstatic void guest_test_hvc(const struct test_hvc_info *hc_info)\n{\n\tunsigned int i;\n\tstruct arm_smccc_res res;\n\tunsigned int hvc_info_arr_sz;\n\n\thvc_info_arr_sz =\n\thc_info == hvc_info ? ARRAY_SIZE(hvc_info) : ARRAY_SIZE(false_hvc_info);\n\n\tfor (i = 0; i < hvc_info_arr_sz; i++, hc_info++) {\n\t\tmemset(&res, 0, sizeof(res));\n\t\tsmccc_hvc(hc_info->func_id, hc_info->arg1, 0, 0, 0, 0, 0, 0, &res);\n\n\t\tswitch (stage) {\n\t\tcase TEST_STAGE_HVC_IFACE_FEAT_DISABLED:\n\t\tcase TEST_STAGE_HVC_IFACE_FALSE_INFO:\n\t\t\t__GUEST_ASSERT(res.a0 == SMCCC_RET_NOT_SUPPORTED,\n\t\t\t\t       \"a0 = 0x%lx, func_id = 0x%x, arg1 = 0x%llx, stage = %u\",\n\t\t\t\t\tres.a0, hc_info->func_id, hc_info->arg1, stage);\n\t\t\tbreak;\n\t\tcase TEST_STAGE_HVC_IFACE_FEAT_ENABLED:\n\t\t\t__GUEST_ASSERT(res.a0 != SMCCC_RET_NOT_SUPPORTED,\n\t\t\t\t       \"a0 = 0x%lx, func_id = 0x%x, arg1 = 0x%llx, stage = %u\",\n\t\t\t\t\tres.a0, hc_info->func_id, hc_info->arg1, stage);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGUEST_FAIL(\"Unexpected stage = %u\", stage);\n\t\t}\n\t}\n}\n\nstatic void guest_code(void)\n{\n\twhile (stage != TEST_STAGE_END) {\n\t\tswitch (stage) {\n\t\tcase TEST_STAGE_REG_IFACE:\n\t\t\tbreak;\n\t\tcase TEST_STAGE_HVC_IFACE_FEAT_DISABLED:\n\t\tcase TEST_STAGE_HVC_IFACE_FEAT_ENABLED:\n\t\t\tguest_test_hvc(hvc_info);\n\t\t\tbreak;\n\t\tcase TEST_STAGE_HVC_IFACE_FALSE_INFO:\n\t\t\tguest_test_hvc(false_hvc_info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGUEST_FAIL(\"Unexpected stage = %u\", stage);\n\t\t}\n\n\t\tGUEST_SYNC(stage);\n\t}\n\n\tGUEST_DONE();\n}\n\nstruct st_time {\n\tuint32_t rev;\n\tuint32_t attr;\n\tuint64_t st_time;\n};\n\n#define STEAL_TIME_SIZE\t\t((sizeof(struct st_time) + 63) & ~63)\n#define ST_GPA_BASE\t\t(1 << 30)\n\nstatic void steal_time_init(struct kvm_vcpu *vcpu)\n{\n\tuint64_t st_ipa = (ulong)ST_GPA_BASE;\n\tunsigned int gpages;\n\n\tgpages = vm_calc_num_guest_pages(VM_MODE_DEFAULT, STEAL_TIME_SIZE);\n\tvm_userspace_mem_region_add(vcpu->vm, VM_MEM_SRC_ANONYMOUS, ST_GPA_BASE, 1, gpages, 0);\n\n\tvcpu_device_attr_set(vcpu, KVM_ARM_VCPU_PVTIME_CTRL,\n\t\t\t     KVM_ARM_VCPU_PVTIME_IPA, &st_ipa);\n}\n\nstatic void test_fw_regs_before_vm_start(struct kvm_vcpu *vcpu)\n{\n\tuint64_t val;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_reg_info); i++) {\n\t\tconst struct kvm_fw_reg_info *reg_info = &fw_reg_info[i];\n\n\t\t \n\t\tvcpu_get_reg(vcpu, reg_info->reg, &val);\n\t\tTEST_ASSERT(val == FW_REG_ULIMIT_VAL(reg_info->max_feat_bit),\n\t\t\t\"Expected all the features to be set for reg: 0x%lx; expected: 0x%lx; read: 0x%lx\\n\",\n\t\t\treg_info->reg, FW_REG_ULIMIT_VAL(reg_info->max_feat_bit), val);\n\n\t\t \n\t\tret = __vcpu_set_reg(vcpu, reg_info->reg, 0);\n\t\tTEST_ASSERT(ret == 0,\n\t\t\t\"Failed to clear all the features of reg: 0x%lx; ret: %d\\n\",\n\t\t\treg_info->reg, errno);\n\n\t\tvcpu_get_reg(vcpu, reg_info->reg, &val);\n\t\tTEST_ASSERT(val == 0,\n\t\t\t\"Expected all the features to be cleared for reg: 0x%lx\\n\", reg_info->reg);\n\n\t\t \n\t\tif (reg_info->max_feat_bit < 63) {\n\t\t\tret = __vcpu_set_reg(vcpu, reg_info->reg, BIT(reg_info->max_feat_bit + 1));\n\t\t\tTEST_ASSERT(ret != 0 && errno == EINVAL,\n\t\t\t\"Unexpected behavior or return value (%d) while setting an unsupported feature for reg: 0x%lx\\n\",\n\t\t\terrno, reg_info->reg);\n\t\t}\n\t}\n}\n\nstatic void test_fw_regs_after_vm_start(struct kvm_vcpu *vcpu)\n{\n\tuint64_t val;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_reg_info); i++) {\n\t\tconst struct kvm_fw_reg_info *reg_info = &fw_reg_info[i];\n\n\t\t \n\t\tvcpu_get_reg(vcpu, reg_info->reg, &val);\n\t\tTEST_ASSERT(val == 0,\n\t\t\t\"Expected all the features to be cleared for reg: 0x%lx\\n\",\n\t\t\treg_info->reg);\n\n\t\t \n\t\tret = __vcpu_set_reg(vcpu, reg_info->reg, FW_REG_ULIMIT_VAL(reg_info->max_feat_bit));\n\t\tTEST_ASSERT(ret != 0 && errno == EBUSY,\n\t\t\"Unexpected behavior or return value (%d) while setting a feature while VM is running for reg: 0x%lx\\n\",\n\t\terrno, reg_info->reg);\n\t}\n}\n\nstatic struct kvm_vm *test_vm_create(struct kvm_vcpu **vcpu)\n{\n\tstruct kvm_vm *vm;\n\n\tvm = vm_create_with_one_vcpu(vcpu, guest_code);\n\n\tsteal_time_init(*vcpu);\n\n\treturn vm;\n}\n\nstatic void test_guest_stage(struct kvm_vm **vm, struct kvm_vcpu **vcpu)\n{\n\tint prev_stage = stage;\n\n\tpr_debug(\"Stage: %d\\n\", prev_stage);\n\n\t \n\tstage++;\n\tsync_global_to_guest(*vm, stage);\n\n\tswitch (prev_stage) {\n\tcase TEST_STAGE_REG_IFACE:\n\t\ttest_fw_regs_after_vm_start(*vcpu);\n\t\tbreak;\n\tcase TEST_STAGE_HVC_IFACE_FEAT_DISABLED:\n\t\t \n\t\tkvm_vm_free(*vm);\n\t\t*vm = test_vm_create(vcpu);\n\t\tbreak;\n\tcase TEST_STAGE_HVC_IFACE_FEAT_ENABLED:\n\tcase TEST_STAGE_HVC_IFACE_FALSE_INFO:\n\t\tbreak;\n\tdefault:\n\t\tTEST_FAIL(\"Unknown test stage: %d\\n\", prev_stage);\n\t}\n}\n\nstatic void test_run(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\tbool guest_done = false;\n\n\tvm = test_vm_create(&vcpu);\n\n\ttest_fw_regs_before_vm_start(vcpu);\n\n\twhile (!guest_done) {\n\t\tvcpu_run(vcpu);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_SYNC:\n\t\t\ttest_guest_stage(&vm, &vcpu);\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tguest_done = true;\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unexpected guest exit\\n\");\n\t\t}\n\t}\n\n\tkvm_vm_free(vm);\n}\n\nint main(void)\n{\n\ttest_run();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}