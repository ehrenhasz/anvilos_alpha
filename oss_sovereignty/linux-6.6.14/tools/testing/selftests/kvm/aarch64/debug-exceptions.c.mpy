{
  "module_name": "debug-exceptions.c",
  "hash_id": "50cb8a39f5f91c6b5b38ef4fdf6e44a7e588d2cba16c6e95d6e08b8ea9693cec",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/aarch64/debug-exceptions.c",
  "human_readable_source": "\n#include <test_util.h>\n#include <kvm_util.h>\n#include <processor.h>\n#include <linux/bitfield.h>\n\n#define MDSCR_KDE\t(1 << 13)\n#define MDSCR_MDE\t(1 << 15)\n#define MDSCR_SS\t(1 << 0)\n\n#define DBGBCR_LEN8\t(0xff << 5)\n#define DBGBCR_EXEC\t(0x0 << 3)\n#define DBGBCR_EL1\t(0x1 << 1)\n#define DBGBCR_E\t(0x1 << 0)\n#define DBGBCR_LBN_SHIFT\t16\n#define DBGBCR_BT_SHIFT\t\t20\n#define DBGBCR_BT_ADDR_LINK_CTX\t(0x1 << DBGBCR_BT_SHIFT)\n#define DBGBCR_BT_CTX_LINK\t(0x3 << DBGBCR_BT_SHIFT)\n\n#define DBGWCR_LEN8\t(0xff << 5)\n#define DBGWCR_RD\t(0x1 << 3)\n#define DBGWCR_WR\t(0x2 << 3)\n#define DBGWCR_EL1\t(0x1 << 1)\n#define DBGWCR_E\t(0x1 << 0)\n#define DBGWCR_LBN_SHIFT\t16\n#define DBGWCR_WT_SHIFT\t\t20\n#define DBGWCR_WT_LINK\t\t(0x1 << DBGWCR_WT_SHIFT)\n\n#define SPSR_D\t\t(1 << 9)\n#define SPSR_SS\t\t(1 << 21)\n\nextern unsigned char sw_bp, sw_bp2, hw_bp, hw_bp2, bp_svc, bp_brk, hw_wp, ss_start, hw_bp_ctx;\nextern unsigned char iter_ss_begin, iter_ss_end;\nstatic volatile uint64_t sw_bp_addr, hw_bp_addr;\nstatic volatile uint64_t wp_addr, wp_data_addr;\nstatic volatile uint64_t svc_addr;\nstatic volatile uint64_t ss_addr[4], ss_idx;\n#define  PC(v)  ((uint64_t)&(v))\n\n#define GEN_DEBUG_WRITE_REG(reg_name)\t\t\t\\\nstatic void write_##reg_name(int num, uint64_t val)\t\\\n{\t\t\t\t\t\t\t\\\n\tswitch (num) {\t\t\t\t\t\\\n\tcase 0:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##0_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 1:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##1_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 2:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##2_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 3:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##3_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 4:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##4_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 5:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##5_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 6:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##6_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 7:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##7_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 8:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##8_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 9:\t\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##9_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 10:\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##10_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 11:\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##11_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 12:\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##12_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 13:\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##13_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 14:\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##14_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tcase 15:\t\t\t\t\t\\\n\t\twrite_sysreg(val, reg_name##15_el1);\t\\\n\t\tbreak;\t\t\t\t\t\\\n\tdefault:\t\t\t\t\t\\\n\t\tGUEST_ASSERT(0);\t\t\t\\\n\t}\t\t\t\t\t\t\\\n}\n\n \nGEN_DEBUG_WRITE_REG(dbgbcr)\nGEN_DEBUG_WRITE_REG(dbgbvr)\nGEN_DEBUG_WRITE_REG(dbgwcr)\nGEN_DEBUG_WRITE_REG(dbgwvr)\n\nstatic void reset_debug_state(void)\n{\n\tuint8_t brps, wrps, i;\n\tuint64_t dfr0;\n\n\tasm volatile(\"msr daifset, #8\");\n\n\twrite_sysreg(0, osdlr_el1);\n\twrite_sysreg(0, oslar_el1);\n\tisb();\n\n\twrite_sysreg(0, mdscr_el1);\n\twrite_sysreg(0, contextidr_el1);\n\n\t \n\tdfr0 = read_sysreg(id_aa64dfr0_el1);\n\tbrps = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_BRPS), dfr0);\n\tfor (i = 0; i <= brps; i++) {\n\t\twrite_dbgbcr(i, 0);\n\t\twrite_dbgbvr(i, 0);\n\t}\n\twrps = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_WRPS), dfr0);\n\tfor (i = 0; i <= wrps; i++) {\n\t\twrite_dbgwcr(i, 0);\n\t\twrite_dbgwvr(i, 0);\n\t}\n\n\tisb();\n}\n\nstatic void enable_os_lock(void)\n{\n\twrite_sysreg(1, oslar_el1);\n\tisb();\n\n\tGUEST_ASSERT(read_sysreg(oslsr_el1) & 2);\n}\n\nstatic void enable_monitor_debug_exceptions(void)\n{\n\tuint32_t mdscr;\n\n\tasm volatile(\"msr daifclr, #8\");\n\n\tmdscr = read_sysreg(mdscr_el1) | MDSCR_KDE | MDSCR_MDE;\n\twrite_sysreg(mdscr, mdscr_el1);\n\tisb();\n}\n\nstatic void install_wp(uint8_t wpn, uint64_t addr)\n{\n\tuint32_t wcr;\n\n\twcr = DBGWCR_LEN8 | DBGWCR_RD | DBGWCR_WR | DBGWCR_EL1 | DBGWCR_E;\n\twrite_dbgwcr(wpn, wcr);\n\twrite_dbgwvr(wpn, addr);\n\n\tisb();\n\n\tenable_monitor_debug_exceptions();\n}\n\nstatic void install_hw_bp(uint8_t bpn, uint64_t addr)\n{\n\tuint32_t bcr;\n\n\tbcr = DBGBCR_LEN8 | DBGBCR_EXEC | DBGBCR_EL1 | DBGBCR_E;\n\twrite_dbgbcr(bpn, bcr);\n\twrite_dbgbvr(bpn, addr);\n\tisb();\n\n\tenable_monitor_debug_exceptions();\n}\n\nstatic void install_wp_ctx(uint8_t addr_wp, uint8_t ctx_bp, uint64_t addr,\n\t\t\t   uint64_t ctx)\n{\n\tuint32_t wcr;\n\tuint64_t ctx_bcr;\n\n\t \n\tctx_bcr = DBGBCR_LEN8 | DBGBCR_EXEC | DBGBCR_EL1 | DBGBCR_E |\n\t\t  DBGBCR_BT_CTX_LINK;\n\twrite_dbgbcr(ctx_bp, ctx_bcr);\n\twrite_dbgbvr(ctx_bp, ctx);\n\n\t \n\twcr = DBGWCR_LEN8 | DBGWCR_RD | DBGWCR_WR | DBGWCR_EL1 | DBGWCR_E |\n\t      DBGWCR_WT_LINK | ((uint32_t)ctx_bp << DBGWCR_LBN_SHIFT);\n\twrite_dbgwcr(addr_wp, wcr);\n\twrite_dbgwvr(addr_wp, addr);\n\tisb();\n\n\tenable_monitor_debug_exceptions();\n}\n\nvoid install_hw_bp_ctx(uint8_t addr_bp, uint8_t ctx_bp, uint64_t addr,\n\t\t       uint64_t ctx)\n{\n\tuint32_t addr_bcr, ctx_bcr;\n\n\t \n\tctx_bcr = DBGBCR_LEN8 | DBGBCR_EXEC | DBGBCR_EL1 | DBGBCR_E |\n\t\t  DBGBCR_BT_CTX_LINK;\n\twrite_dbgbcr(ctx_bp, ctx_bcr);\n\twrite_dbgbvr(ctx_bp, ctx);\n\n\t \n\taddr_bcr = DBGBCR_LEN8 | DBGBCR_EXEC | DBGBCR_EL1 | DBGBCR_E |\n\t\t   DBGBCR_BT_ADDR_LINK_CTX |\n\t\t   ((uint32_t)ctx_bp << DBGBCR_LBN_SHIFT);\n\twrite_dbgbcr(addr_bp, addr_bcr);\n\twrite_dbgbvr(addr_bp, addr);\n\tisb();\n\n\tenable_monitor_debug_exceptions();\n}\n\nstatic void install_ss(void)\n{\n\tuint32_t mdscr;\n\n\tasm volatile(\"msr daifclr, #8\");\n\n\tmdscr = read_sysreg(mdscr_el1) | MDSCR_KDE | MDSCR_SS;\n\twrite_sysreg(mdscr, mdscr_el1);\n\tisb();\n}\n\nstatic volatile char write_data;\n\nstatic void guest_code(uint8_t bpn, uint8_t wpn, uint8_t ctx_bpn)\n{\n\tuint64_t ctx = 0xabcdef;\t \n\n\t \n\treset_debug_state();\n\tasm volatile(\"sw_bp: brk #0\");\n\tGUEST_ASSERT_EQ(sw_bp_addr, PC(sw_bp));\n\n\t \n\treset_debug_state();\n\tinstall_hw_bp(bpn, PC(hw_bp));\n\tasm volatile(\"hw_bp: nop\");\n\tGUEST_ASSERT_EQ(hw_bp_addr, PC(hw_bp));\n\n\t \n\treset_debug_state();\n\tinstall_hw_bp(bpn, PC(bp_svc));\n\tasm volatile(\"bp_svc: svc #0\");\n\tGUEST_ASSERT_EQ(hw_bp_addr, PC(bp_svc));\n\tGUEST_ASSERT_EQ(svc_addr, PC(bp_svc) + 4);\n\n\t \n\treset_debug_state();\n\tinstall_hw_bp(bpn, PC(bp_brk));\n\tasm volatile(\"bp_brk: brk #0\");\n\tGUEST_ASSERT_EQ(sw_bp_addr, PC(bp_brk));\n\tGUEST_ASSERT_EQ(hw_bp_addr, PC(bp_brk));\n\n\t \n\treset_debug_state();\n\tinstall_wp(wpn, PC(write_data));\n\twrite_data = 'x';\n\tGUEST_ASSERT_EQ(write_data, 'x');\n\tGUEST_ASSERT_EQ(wp_data_addr, PC(write_data));\n\n\t \n\treset_debug_state();\n\tinstall_ss();\n\tss_idx = 0;\n\tasm volatile(\"ss_start:\\n\"\n\t\t     \"mrs x0, esr_el1\\n\"\n\t\t     \"add x0, x0, #1\\n\"\n\t\t     \"msr daifset, #8\\n\"\n\t\t     : : : \"x0\");\n\tGUEST_ASSERT_EQ(ss_addr[0], PC(ss_start));\n\tGUEST_ASSERT_EQ(ss_addr[1], PC(ss_start) + 4);\n\tGUEST_ASSERT_EQ(ss_addr[2], PC(ss_start) + 8);\n\n\t \n\treset_debug_state();\n\tenable_os_lock();\n\tsw_bp_addr = 0;\n\tasm volatile(\"sw_bp2: brk #0\");\n\tGUEST_ASSERT_EQ(sw_bp_addr, PC(sw_bp2));\n\n\t \n\treset_debug_state();\n\tenable_os_lock();\n\tinstall_hw_bp(bpn, PC(hw_bp2));\n\thw_bp_addr = 0;\n\tasm volatile(\"hw_bp2: nop\");\n\tGUEST_ASSERT_EQ(hw_bp_addr, 0);\n\n\t \n\treset_debug_state();\n\tenable_os_lock();\n\twrite_data = '\\0';\n\twp_data_addr = 0;\n\tinstall_wp(wpn, PC(write_data));\n\twrite_data = 'x';\n\tGUEST_ASSERT_EQ(write_data, 'x');\n\tGUEST_ASSERT_EQ(wp_data_addr, 0);\n\n\t \n\treset_debug_state();\n\tenable_os_lock();\n\tss_addr[0] = 0;\n\tinstall_ss();\n\tss_idx = 0;\n\tasm volatile(\"mrs x0, esr_el1\\n\\t\"\n\t\t     \"add x0, x0, #1\\n\\t\"\n\t\t     \"msr daifset, #8\\n\\t\"\n\t\t     : : : \"x0\");\n\tGUEST_ASSERT_EQ(ss_addr[0], 0);\n\n\t \n\thw_bp_addr = 0;\n\treset_debug_state();\n\tinstall_hw_bp_ctx(bpn, ctx_bpn, PC(hw_bp_ctx), ctx);\n\t \n\twrite_sysreg(ctx, contextidr_el1);\n\tisb();\n\tasm volatile(\"hw_bp_ctx: nop\");\n\twrite_sysreg(0, contextidr_el1);\n\tGUEST_ASSERT_EQ(hw_bp_addr, PC(hw_bp_ctx));\n\n\t \n\treset_debug_state();\n\tinstall_wp_ctx(wpn, ctx_bpn, PC(write_data), ctx);\n\t \n\twrite_sysreg(ctx, contextidr_el1);\n\tisb();\n\twrite_data = 'x';\n\tGUEST_ASSERT_EQ(write_data, 'x');\n\tGUEST_ASSERT_EQ(wp_data_addr, PC(write_data));\n\n\tGUEST_DONE();\n}\n\nstatic void guest_sw_bp_handler(struct ex_regs *regs)\n{\n\tsw_bp_addr = regs->pc;\n\tregs->pc += 4;\n}\n\nstatic void guest_hw_bp_handler(struct ex_regs *regs)\n{\n\thw_bp_addr = regs->pc;\n\tregs->pstate |= SPSR_D;\n}\n\nstatic void guest_wp_handler(struct ex_regs *regs)\n{\n\twp_data_addr = read_sysreg(far_el1);\n\twp_addr = regs->pc;\n\tregs->pstate |= SPSR_D;\n}\n\nstatic void guest_ss_handler(struct ex_regs *regs)\n{\n\t__GUEST_ASSERT(ss_idx < 4, \"Expected index < 4, got '%u'\", ss_idx);\n\tss_addr[ss_idx++] = regs->pc;\n\tregs->pstate |= SPSR_SS;\n}\n\nstatic void guest_svc_handler(struct ex_regs *regs)\n{\n\tsvc_addr = regs->pc;\n}\n\nstatic void guest_code_ss(int test_cnt)\n{\n\tuint64_t i;\n\tuint64_t bvr, wvr, w_bvr, w_wvr;\n\n\tfor (i = 0; i < test_cnt; i++) {\n\t\t \n\t\tw_bvr = i << 2;\n\t\tw_wvr = i << 2;\n\n\t\t \n\t\tGUEST_UCALL_NONE();\n\n\t\t \n\t\tasm volatile(\"iter_ss_begin:nop\\n\");\n\n\t\twrite_sysreg(w_bvr, dbgbvr0_el1);\n\t\twrite_sysreg(w_wvr, dbgwvr0_el1);\n\t\tbvr = read_sysreg(dbgbvr0_el1);\n\t\twvr = read_sysreg(dbgwvr0_el1);\n\n\t\t \n\t\tasm volatile(\"iter_ss_end:\\n\");\n\n\t\tGUEST_ASSERT_EQ(bvr, w_bvr);\n\t\tGUEST_ASSERT_EQ(wvr, w_wvr);\n\t}\n\tGUEST_DONE();\n}\n\nstatic int debug_version(uint64_t id_aa64dfr0)\n{\n\treturn FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_DEBUGVER), id_aa64dfr0);\n}\n\nstatic void test_guest_debug_exceptions(uint8_t bpn, uint8_t wpn, uint8_t ctx_bpn)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\tvm_install_sync_handler(vm, VECTOR_SYNC_CURRENT,\n\t\t\t\tESR_EC_BRK_INS, guest_sw_bp_handler);\n\tvm_install_sync_handler(vm, VECTOR_SYNC_CURRENT,\n\t\t\t\tESR_EC_HW_BP_CURRENT, guest_hw_bp_handler);\n\tvm_install_sync_handler(vm, VECTOR_SYNC_CURRENT,\n\t\t\t\tESR_EC_WP_CURRENT, guest_wp_handler);\n\tvm_install_sync_handler(vm, VECTOR_SYNC_CURRENT,\n\t\t\t\tESR_EC_SSTEP_CURRENT, guest_ss_handler);\n\tvm_install_sync_handler(vm, VECTOR_SYNC_CURRENT,\n\t\t\t\tESR_EC_SVC64, guest_svc_handler);\n\n\t \n\tvcpu_args_set(vcpu, 3, bpn, wpn, ctx_bpn);\n\tpr_debug(\"Use bpn#%d, wpn#%d and ctx_bpn#%d\\n\", bpn, wpn, ctx_bpn);\n\n\tvcpu_run(vcpu);\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\t\tbreak;\n\tcase UCALL_DONE:\n\t\tgoto done;\n\tdefault:\n\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t}\n\ndone:\n\tkvm_vm_free(vm);\n}\n\nvoid test_single_step_from_userspace(int test_cnt)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\tstruct kvm_run *run;\n\tuint64_t pc, cmd;\n\tuint64_t test_pc = 0;\n\tbool ss_enable = false;\n\tstruct kvm_guest_debug debug = {};\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code_ss);\n\trun = vcpu->run;\n\tvcpu_args_set(vcpu, 1, test_cnt);\n\n\twhile (1) {\n\t\tvcpu_run(vcpu);\n\t\tif (run->exit_reason != KVM_EXIT_DEBUG) {\n\t\t\tcmd = get_ucall(vcpu, &uc);\n\t\t\tif (cmd == UCALL_ABORT) {\n\t\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t\t \n\t\t\t} else if (cmd == UCALL_DONE) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tTEST_ASSERT(cmd == UCALL_NONE,\n\t\t\t\t    \"Unexpected ucall cmd 0x%lx\", cmd);\n\n\t\t\tdebug.control = KVM_GUESTDBG_ENABLE |\n\t\t\t\t\tKVM_GUESTDBG_SINGLESTEP;\n\t\t\tss_enable = true;\n\t\t\tvcpu_guest_debug_set(vcpu, &debug);\n\t\t\tcontinue;\n\t\t}\n\n\t\tTEST_ASSERT(ss_enable, \"Unexpected KVM_EXIT_DEBUG\");\n\n\t\t \n\t\tvcpu_get_reg(vcpu, ARM64_CORE_REG(regs.pc), &pc);\n\t\tTEST_ASSERT(!test_pc || pc == test_pc,\n\t\t\t    \"Unexpected pc 0x%lx (expected 0x%lx)\",\n\t\t\t    pc, test_pc);\n\n\t\tif ((pc + 4) == (uint64_t)&iter_ss_end) {\n\t\t\ttest_pc = 0;\n\t\t\tdebug.control = KVM_GUESTDBG_ENABLE;\n\t\t\tss_enable = false;\n\t\t\tvcpu_guest_debug_set(vcpu, &debug);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((pc >= (uint64_t)&iter_ss_begin) &&\n\t\t    (pc < (uint64_t)&iter_ss_end))\n\t\t\ttest_pc = pc + 4;\n\t\telse\n\t\t\ttest_pc = 0;\n\t}\n\n\tkvm_vm_free(vm);\n}\n\n \nvoid test_guest_debug_exceptions_all(uint64_t aa64dfr0)\n{\n\tuint8_t brp_num, wrp_num, ctx_brp_num, normal_brp_num, ctx_brp_base;\n\tint b, w, c;\n\n\t \n\tbrp_num = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_BRPS), aa64dfr0) + 1;\n\t__TEST_REQUIRE(brp_num >= 2, \"At least two breakpoints are required\");\n\n\t \n\twrp_num = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_WRPS), aa64dfr0) + 1;\n\n\t \n\tctx_brp_num = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64DFR0_CTX_CMPS), aa64dfr0) + 1;\n\n\tpr_debug(\"%s brp_num:%d, wrp_num:%d, ctx_brp_num:%d\\n\", __func__,\n\t\t brp_num, wrp_num, ctx_brp_num);\n\n\t \n\tnormal_brp_num = brp_num - ctx_brp_num;\n\n\t \n\tctx_brp_base = normal_brp_num;\n\n\t \n\tfor (c = ctx_brp_base; c < ctx_brp_base + ctx_brp_num; c++) {\n\t\tfor (b = 0; b < normal_brp_num; b++) {\n\t\t\tfor (w = 0; w < wrp_num; w++)\n\t\t\t\ttest_guest_debug_exceptions(b, w, c);\n\t\t}\n\t}\n}\n\nstatic void help(char *name)\n{\n\tputs(\"\");\n\tprintf(\"Usage: %s [-h] [-i iterations of the single step test]\\n\", name);\n\tputs(\"\");\n\texit(0);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tint opt;\n\tint ss_iteration = 10000;\n\tuint64_t aa64dfr0;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\tvcpu_get_reg(vcpu, KVM_ARM64_SYS_REG(SYS_ID_AA64DFR0_EL1), &aa64dfr0);\n\t__TEST_REQUIRE(debug_version(aa64dfr0) >= 6,\n\t\t       \"Armv8 debug architecture not supported.\");\n\tkvm_vm_free(vm);\n\n\twhile ((opt = getopt(argc, argv, \"i:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'i':\n\t\t\tss_iteration = atoi_positive(\"Number of iterations\", optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttest_guest_debug_exceptions_all(aa64dfr0);\n\ttest_single_step_from_userspace(ss_iteration);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}