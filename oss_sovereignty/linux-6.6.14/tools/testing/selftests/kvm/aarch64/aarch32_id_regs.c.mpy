{
  "module_name": "aarch32_id_regs.c",
  "hash_id": "24260cf7af7d22a289278c6649c5ef01b4dafea3201040ac22328c6887b33916",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/aarch64/aarch32_id_regs.c",
  "human_readable_source": "\n \n\n#include <stdint.h>\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"test_util.h\"\n#include <linux/bitfield.h>\n\n#define BAD_ID_REG_VAL\t0x1badc0deul\n\n#define GUEST_ASSERT_REG_RAZ(reg)\tGUEST_ASSERT_EQ(read_sysreg_s(reg), 0)\n\nstatic void guest_main(void)\n{\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_PFR0_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_PFR1_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_DFR0_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_AFR0_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_MMFR0_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_MMFR1_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_MMFR2_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_MMFR3_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_ISAR0_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_ISAR1_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_ISAR2_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_ISAR3_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_ISAR4_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_ISAR5_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_MMFR4_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_ISAR6_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_MVFR0_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_MVFR1_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_MVFR2_EL1);\n\tGUEST_ASSERT_REG_RAZ(sys_reg(3, 0, 0, 3, 3));\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_PFR2_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_DFR1_EL1);\n\tGUEST_ASSERT_REG_RAZ(SYS_ID_MMFR5_EL1);\n\tGUEST_ASSERT_REG_RAZ(sys_reg(3, 0, 0, 3, 7));\n\n\tGUEST_DONE();\n}\n\nstatic void test_guest_raz(struct kvm_vcpu *vcpu)\n{\n\tstruct ucall uc;\n\n\tvcpu_run(vcpu);\n\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\t\tbreak;\n\tcase UCALL_DONE:\n\t\tbreak;\n\tdefault:\n\t\tTEST_FAIL(\"Unexpected ucall: %lu\", uc.cmd);\n\t}\n}\n\nstatic uint64_t raz_wi_reg_ids[] = {\n\tKVM_ARM64_SYS_REG(SYS_ID_PFR0_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_PFR1_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_DFR0_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_MMFR0_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_MMFR1_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_MMFR2_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_MMFR3_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_ISAR0_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_ISAR1_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_ISAR2_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_ISAR3_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_ISAR4_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_ISAR5_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_MMFR4_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_ISAR6_EL1),\n\tKVM_ARM64_SYS_REG(SYS_MVFR0_EL1),\n\tKVM_ARM64_SYS_REG(SYS_MVFR1_EL1),\n\tKVM_ARM64_SYS_REG(SYS_MVFR2_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_PFR2_EL1),\n\tKVM_ARM64_SYS_REG(SYS_ID_MMFR5_EL1),\n};\n\nstatic void test_user_raz_wi(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(raz_wi_reg_ids); i++) {\n\t\tuint64_t reg_id = raz_wi_reg_ids[i];\n\t\tuint64_t val;\n\n\t\tvcpu_get_reg(vcpu, reg_id, &val);\n\t\tTEST_ASSERT_EQ(val, 0);\n\n\t\t \n\t\tvcpu_set_reg(vcpu, reg_id, BAD_ID_REG_VAL);\n\n\t\tvcpu_get_reg(vcpu, reg_id, &val);\n\t\tTEST_ASSERT_EQ(val, 0);\n\t}\n}\n\nstatic uint64_t raz_invariant_reg_ids[] = {\n\tKVM_ARM64_SYS_REG(SYS_ID_AFR0_EL1),\n\tKVM_ARM64_SYS_REG(sys_reg(3, 0, 0, 3, 3)),\n\tKVM_ARM64_SYS_REG(SYS_ID_DFR1_EL1),\n\tKVM_ARM64_SYS_REG(sys_reg(3, 0, 0, 3, 7)),\n};\n\nstatic void test_user_raz_invariant(struct kvm_vcpu *vcpu)\n{\n\tint i, r;\n\n\tfor (i = 0; i < ARRAY_SIZE(raz_invariant_reg_ids); i++) {\n\t\tuint64_t reg_id = raz_invariant_reg_ids[i];\n\t\tuint64_t val;\n\n\t\tvcpu_get_reg(vcpu, reg_id, &val);\n\t\tTEST_ASSERT_EQ(val, 0);\n\n\t\tr = __vcpu_set_reg(vcpu, reg_id, BAD_ID_REG_VAL);\n\t\tTEST_ASSERT(r < 0 && errno == EINVAL,\n\t\t\t    \"unexpected KVM_SET_ONE_REG error: r=%d, errno=%d\", r, errno);\n\n\t\tvcpu_get_reg(vcpu, reg_id, &val);\n\t\tTEST_ASSERT_EQ(val, 0);\n\t}\n}\n\n\n\nstatic bool vcpu_aarch64_only(struct kvm_vcpu *vcpu)\n{\n\tuint64_t val, el0;\n\n\tvcpu_get_reg(vcpu, KVM_ARM64_SYS_REG(SYS_ID_AA64PFR0_EL1), &val);\n\n\tel0 = FIELD_GET(ARM64_FEATURE_MASK(ID_AA64PFR0_EL0), val);\n\treturn el0 == ID_AA64PFR0_ELx_64BIT_ONLY;\n}\n\nint main(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_main);\n\n\tTEST_REQUIRE(vcpu_aarch64_only(vcpu));\n\n\ttest_user_raz_wi(vcpu);\n\ttest_user_raz_invariant(vcpu);\n\ttest_guest_raz(vcpu);\n\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}