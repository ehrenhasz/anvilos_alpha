{
  "module_name": "vgic_irq.c",
  "hash_id": "703ca2881d99a0586c3747bb730589267044f655364a9873f48c7bef4805cea8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/aarch64/vgic_irq.c",
  "human_readable_source": "\n \n#include <asm/kvm.h>\n#include <asm/kvm_para.h>\n#include <sys/eventfd.h>\n#include <linux/sizes.h>\n\n#include \"processor.h\"\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"gic.h\"\n#include \"gic_v3.h\"\n#include \"vgic.h\"\n\n#define GICD_BASE_GPA\t\t0x08000000ULL\n#define GICR_BASE_GPA\t\t0x080A0000ULL\n\n \nstruct test_args {\n\tuint32_t nr_irqs;  \n\tbool eoi_split;  \n\tbool level_sensitive;  \n\tint kvm_max_routes;  \n\tbool kvm_supports_irqfd;  \n};\n\n \n#define KVM_NUM_PRIOS\t\t32\n#define KVM_PRIO_SHIFT\t\t3  \n#define KVM_PRIO_STEPS\t\t(1 << KVM_PRIO_SHIFT)  \n#define LOWEST_PRIO\t\t(KVM_NUM_PRIOS - 1)\n#define CPU_PRIO_MASK\t\t(LOWEST_PRIO << KVM_PRIO_SHIFT)\t \n#define IRQ_DEFAULT_PRIO\t(LOWEST_PRIO - 1)\n#define IRQ_DEFAULT_PRIO_REG\t(IRQ_DEFAULT_PRIO << KVM_PRIO_SHIFT)  \n\nstatic void *dist = (void *)GICD_BASE_GPA;\nstatic void *redist = (void *)GICR_BASE_GPA;\n\n \n\ntypedef enum {\n\tKVM_INJECT_EDGE_IRQ_LINE = 1,\n\tKVM_SET_IRQ_LINE,\n\tKVM_SET_IRQ_LINE_HIGH,\n\tKVM_SET_LEVEL_INFO_HIGH,\n\tKVM_INJECT_IRQFD,\n\tKVM_WRITE_ISPENDR,\n\tKVM_WRITE_ISACTIVER,\n} kvm_inject_cmd;\n\nstruct kvm_inject_args {\n\tkvm_inject_cmd cmd;\n\tuint32_t first_intid;\n\tuint32_t num;\n\tint level;\n\tbool expect_failure;\n};\n\n \nstatic void kvm_inject_call(kvm_inject_cmd cmd, uint32_t first_intid,\n\t\tuint32_t num, int level, bool expect_failure);\n\n \nstatic void kvm_inject_get_call(struct kvm_vm *vm, struct ucall *uc,\n\t\tstruct kvm_inject_args *args);\n\n#define _KVM_INJECT_MULTI(cmd, intid, num, expect_failure)\t\t\t\\\n\tkvm_inject_call(cmd, intid, num, -1  , expect_failure)\n\n#define KVM_INJECT_MULTI(cmd, intid, num)\t\t\t\t\t\\\n\t_KVM_INJECT_MULTI(cmd, intid, num, false)\n\n#define _KVM_INJECT(cmd, intid, expect_failure)\t\t\t\t\t\\\n\t_KVM_INJECT_MULTI(cmd, intid, 1, expect_failure)\n\n#define KVM_INJECT(cmd, intid)\t\t\t\t\t\t\t\\\n\t_KVM_INJECT_MULTI(cmd, intid, 1, false)\n\n#define KVM_ACTIVATE(cmd, intid)\t\t\t\t\t\t\\\n\tkvm_inject_call(cmd, intid, 1, 1, false);\n\nstruct kvm_inject_desc {\n\tkvm_inject_cmd cmd;\n\t \n\tbool sgi, ppi, spi;\n};\n\nstatic struct kvm_inject_desc inject_edge_fns[] = {\n\t \n\t{ KVM_INJECT_EDGE_IRQ_LINE,\t\tfalse, false, true },\n\t{ KVM_INJECT_IRQFD,\t\t\tfalse, false, true },\n\t{ KVM_WRITE_ISPENDR,\t\t\ttrue,  false, true },\n\t{ 0, },\n};\n\nstatic struct kvm_inject_desc inject_level_fns[] = {\n\t \n\t{ KVM_SET_IRQ_LINE_HIGH,\t\tfalse, true,  true },\n\t{ KVM_SET_LEVEL_INFO_HIGH,\t\tfalse, true,  true },\n\t{ KVM_INJECT_IRQFD,\t\t\tfalse, false, true },\n\t{ KVM_WRITE_ISPENDR,\t\t\tfalse, true,  true },\n\t{ 0, },\n};\n\nstatic struct kvm_inject_desc set_active_fns[] = {\n\t \n\t{ KVM_WRITE_ISACTIVER,\t\t\ttrue,  true,  true },\n\t{ 0, },\n};\n\n#define for_each_inject_fn(t, f)\t\t\t\t\t\t\\\n\tfor ((f) = (t); (f)->cmd; (f)++)\n\n#define for_each_supported_inject_fn(args, t, f)\t\t\t\t\\\n\tfor_each_inject_fn(t, f)\t\t\t\t\t\t\\\n\t\tif ((args)->kvm_supports_irqfd || (f)->cmd != KVM_INJECT_IRQFD)\n\n#define for_each_supported_activate_fn(args, t, f)\t\t\t\t\\\n\tfor_each_supported_inject_fn((args), (t), (f))\n\n \nvolatile uint64_t irq_handled;\nvolatile uint32_t irqnr_received[MAX_SPI + 1];\n\nstatic void reset_stats(void)\n{\n\tint i;\n\n\tirq_handled = 0;\n\tfor (i = 0; i <= MAX_SPI; i++)\n\t\tirqnr_received[i] = 0;\n}\n\nstatic uint64_t gic_read_ap1r0(void)\n{\n\tuint64_t reg = read_sysreg_s(SYS_ICV_AP1R0_EL1);\n\n\tdsb(sy);\n\treturn reg;\n}\n\nstatic void gic_write_ap1r0(uint64_t val)\n{\n\twrite_sysreg_s(val, SYS_ICV_AP1R0_EL1);\n\tisb();\n}\n\nstatic void guest_set_irq_line(uint32_t intid, uint32_t level);\n\nstatic void guest_irq_generic_handler(bool eoi_split, bool level_sensitive)\n{\n\tuint32_t intid = gic_get_and_ack_irq();\n\n\tif (intid == IAR_SPURIOUS)\n\t\treturn;\n\n\tGUEST_ASSERT(gic_irq_get_active(intid));\n\n\tif (!level_sensitive)\n\t\tGUEST_ASSERT(!gic_irq_get_pending(intid));\n\n\tif (level_sensitive)\n\t\tguest_set_irq_line(intid, 0);\n\n\tGUEST_ASSERT(intid < MAX_SPI);\n\tirqnr_received[intid] += 1;\n\tirq_handled += 1;\n\n\tgic_set_eoi(intid);\n\tGUEST_ASSERT_EQ(gic_read_ap1r0(), 0);\n\tif (eoi_split)\n\t\tgic_set_dir(intid);\n\n\tGUEST_ASSERT(!gic_irq_get_active(intid));\n\tGUEST_ASSERT(!gic_irq_get_pending(intid));\n}\n\nstatic void kvm_inject_call(kvm_inject_cmd cmd, uint32_t first_intid,\n\t\tuint32_t num, int level, bool expect_failure)\n{\n\tstruct kvm_inject_args args = {\n\t\t.cmd = cmd,\n\t\t.first_intid = first_intid,\n\t\t.num = num,\n\t\t.level = level,\n\t\t.expect_failure = expect_failure,\n\t};\n\tGUEST_SYNC(&args);\n}\n\n#define GUEST_ASSERT_IAR_EMPTY()\t\t\t\t\t\t\\\ndo { \t\t\t\t\t\t\t\t\t\t\\\n\tuint32_t _intid;\t\t\t\t\t\t\t\\\n\t_intid = gic_get_and_ack_irq();\t\t\t\t\t\t\\\n\tGUEST_ASSERT(_intid == 0 || _intid == IAR_SPURIOUS);\t\t\t\\\n} while (0)\n\n#define CAT_HELPER(a, b) a ## b\n#define CAT(a, b) CAT_HELPER(a, b)\n#define PREFIX guest_irq_handler_\n#define GUEST_IRQ_HANDLER_NAME(split, lev) CAT(PREFIX, CAT(split, lev))\n#define GENERATE_GUEST_IRQ_HANDLER(split, lev)\t\t\t\t\t\\\nstatic void CAT(PREFIX, CAT(split, lev))(struct ex_regs *regs)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tguest_irq_generic_handler(split, lev);\t\t\t\t\t\\\n}\n\nGENERATE_GUEST_IRQ_HANDLER(0, 0);\nGENERATE_GUEST_IRQ_HANDLER(0, 1);\nGENERATE_GUEST_IRQ_HANDLER(1, 0);\nGENERATE_GUEST_IRQ_HANDLER(1, 1);\n\nstatic void (*guest_irq_handlers[2][2])(struct ex_regs *) = {\n\t{GUEST_IRQ_HANDLER_NAME(0, 0), GUEST_IRQ_HANDLER_NAME(0, 1),},\n\t{GUEST_IRQ_HANDLER_NAME(1, 0), GUEST_IRQ_HANDLER_NAME(1, 1),},\n};\n\nstatic void reset_priorities(struct test_args *args)\n{\n\tint i;\n\n\tfor (i = 0; i < args->nr_irqs; i++)\n\t\tgic_set_priority(i, IRQ_DEFAULT_PRIO_REG);\n}\n\nstatic void guest_set_irq_line(uint32_t intid, uint32_t level)\n{\n\tkvm_inject_call(KVM_SET_IRQ_LINE, intid, 1, level, false);\n}\n\nstatic void test_inject_fail(struct test_args *args,\n\t\tuint32_t intid, kvm_inject_cmd cmd)\n{\n\treset_stats();\n\n\t_KVM_INJECT(cmd, intid, true);\n\t \n\n\tGUEST_ASSERT_EQ(irq_handled, 0);\n\tGUEST_ASSERT_IAR_EMPTY();\n}\n\nstatic void guest_inject(struct test_args *args,\n\t\tuint32_t first_intid, uint32_t num,\n\t\tkvm_inject_cmd cmd)\n{\n\tuint32_t i;\n\n\treset_stats();\n\n\t \n\tfor (i = first_intid; i < num + first_intid; i++)\n\t\tgic_set_priority(i, (i % (KVM_NUM_PRIOS - 1)) << 3);\n\n\tasm volatile(\"msr daifset, #2\" : : : \"memory\");\n\tKVM_INJECT_MULTI(cmd, first_intid, num);\n\n\twhile (irq_handled < num) {\n\t\tasm volatile(\"wfi\\n\"\n\t\t\t     \"msr daifclr, #2\\n\"\n\t\t\t      \n\t\t\t     \"msr daifset, #2\\n\"\n\t\t\t     : : : \"memory\");\n\t}\n\tasm volatile(\"msr daifclr, #2\" : : : \"memory\");\n\n\tGUEST_ASSERT_EQ(irq_handled, num);\n\tfor (i = first_intid; i < num + first_intid; i++)\n\t\tGUEST_ASSERT_EQ(irqnr_received[i], 1);\n\tGUEST_ASSERT_IAR_EMPTY();\n\n\treset_priorities(args);\n}\n\n \nstatic void guest_restore_active(struct test_args *args,\n\t\tuint32_t first_intid, uint32_t num,\n\t\tkvm_inject_cmd cmd)\n{\n\tuint32_t prio, intid, ap1r;\n\tint i;\n\n\t \n\tfor (i = 0, prio = (num - 1) * 8; i < num; i++, prio -= 8) {\n\t\tGUEST_ASSERT(prio >= 0);\n\t\tintid = i + first_intid;\n\t\tgic_set_priority(intid, prio);\n\t}\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tintid = i + first_intid;\n\t\tKVM_ACTIVATE(cmd, intid);\n\t\tap1r = gic_read_ap1r0();\n\t\tap1r |= 1U << i;\n\t\tgic_write_ap1r0(ap1r);\n\t}\n\n\t \n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tintid = num - i - 1 + first_intid;\n\t\tgic_set_eoi(intid);\n\t\tif (args->eoi_split)\n\t\t\tgic_set_dir(intid);\n\t}\n\n\tfor (i = 0; i < num; i++)\n\t\tGUEST_ASSERT(!gic_irq_get_active(i + first_intid));\n\tGUEST_ASSERT_EQ(gic_read_ap1r0(), 0);\n\tGUEST_ASSERT_IAR_EMPTY();\n}\n\n \nstatic uint32_t wait_for_and_activate_irq(void)\n{\n\tuint32_t intid;\n\n\tdo {\n\t\tasm volatile(\"wfi\" : : : \"memory\");\n\t\tintid = gic_get_and_ack_irq();\n\t} while (intid == IAR_SPURIOUS);\n\n\treturn intid;\n}\n\n \nstatic void test_inject_preemption(struct test_args *args,\n\t\tuint32_t first_intid, int num,\n\t\tkvm_inject_cmd cmd)\n{\n\tuint32_t intid, prio, step = KVM_PRIO_STEPS;\n\tint i;\n\n\t \n\tfor (i = 0, prio = (num - 1) * step; i < num; i++, prio -= step) {\n\t\tGUEST_ASSERT(prio >= 0);\n\t\tintid = i + first_intid;\n\t\tgic_set_priority(intid, prio);\n\t}\n\n\tlocal_irq_disable();\n\n\tfor (i = 0; i < num; i++) {\n\t\tuint32_t tmp;\n\t\tintid = i + first_intid;\n\t\tKVM_INJECT(cmd, intid);\n\t\t \n\t\ttmp = wait_for_and_activate_irq();\n\t\tGUEST_ASSERT_EQ(tmp, intid);\n\t\tif (args->level_sensitive)\n\t\t\tguest_set_irq_line(intid, 0);\n\t}\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tintid = num - i - 1 + first_intid;\n\t\tgic_set_eoi(intid);\n\t\tif (args->eoi_split)\n\t\t\tgic_set_dir(intid);\n\t}\n\n\tlocal_irq_enable();\n\n\tfor (i = 0; i < num; i++)\n\t\tGUEST_ASSERT(!gic_irq_get_active(i + first_intid));\n\tGUEST_ASSERT_EQ(gic_read_ap1r0(), 0);\n\tGUEST_ASSERT_IAR_EMPTY();\n\n\treset_priorities(args);\n}\n\nstatic void test_injection(struct test_args *args, struct kvm_inject_desc *f)\n{\n\tuint32_t nr_irqs = args->nr_irqs;\n\n\tif (f->sgi) {\n\t\tguest_inject(args, MIN_SGI, 1, f->cmd);\n\t\tguest_inject(args, 0, 16, f->cmd);\n\t}\n\n\tif (f->ppi)\n\t\tguest_inject(args, MIN_PPI, 1, f->cmd);\n\n\tif (f->spi) {\n\t\tguest_inject(args, MIN_SPI, 1, f->cmd);\n\t\tguest_inject(args, nr_irqs - 1, 1, f->cmd);\n\t\tguest_inject(args, MIN_SPI, nr_irqs - MIN_SPI, f->cmd);\n\t}\n}\n\nstatic void test_injection_failure(struct test_args *args,\n\t\tstruct kvm_inject_desc *f)\n{\n\tuint32_t bad_intid[] = { args->nr_irqs, 1020, 1024, 1120, 5120, ~0U, };\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bad_intid); i++)\n\t\ttest_inject_fail(args, bad_intid[i], f->cmd);\n}\n\nstatic void test_preemption(struct test_args *args, struct kvm_inject_desc *f)\n{\n\t \n\tif (f->sgi)\n\t\ttest_inject_preemption(args, MIN_SGI, 4, f->cmd);\n\n\tif (f->ppi)\n\t\ttest_inject_preemption(args, MIN_PPI, 4, f->cmd);\n\n\tif (f->spi)\n\t\ttest_inject_preemption(args, MIN_SPI, 4, f->cmd);\n}\n\nstatic void test_restore_active(struct test_args *args, struct kvm_inject_desc *f)\n{\n\t \n\tif (f->sgi)\n\t\tguest_restore_active(args, MIN_SGI, 4, f->cmd);\n\n\tif (f->ppi)\n\t\tguest_restore_active(args, MIN_PPI, 4, f->cmd);\n\n\tif (f->spi)\n\t\tguest_restore_active(args, MIN_SPI, 4, f->cmd);\n}\n\nstatic void guest_code(struct test_args *args)\n{\n\tuint32_t i, nr_irqs = args->nr_irqs;\n\tbool level_sensitive = args->level_sensitive;\n\tstruct kvm_inject_desc *f, *inject_fns;\n\n\tgic_init(GIC_V3, 1, dist, redist);\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tgic_irq_enable(i);\n\n\tfor (i = MIN_SPI; i < nr_irqs; i++)\n\t\tgic_irq_set_config(i, !level_sensitive);\n\n\tgic_set_eoi_split(args->eoi_split);\n\n\treset_priorities(args);\n\tgic_set_priority_mask(CPU_PRIO_MASK);\n\n\tinject_fns  = level_sensitive ? inject_level_fns\n\t\t\t\t      : inject_edge_fns;\n\n\tlocal_irq_enable();\n\n\t \n\tfor_each_supported_inject_fn(args, inject_fns, f) {\n\t\ttest_injection(args, f);\n\t\ttest_preemption(args, f);\n\t\ttest_injection_failure(args, f);\n\t}\n\n\t \n\tfor_each_supported_activate_fn(args, set_active_fns, f)\n\t\ttest_restore_active(args, f);\n\n\tGUEST_DONE();\n}\n\nstatic void kvm_irq_line_check(struct kvm_vm *vm, uint32_t intid, int level,\n\t\t\tstruct test_args *test_args, bool expect_failure)\n{\n\tint ret;\n\n\tif (!expect_failure) {\n\t\tkvm_arm_irq_line(vm, intid, level);\n\t} else {\n\t\t \n\t\tif (intid > KVM_ARM_IRQ_NUM_MASK)\n\t\t\treturn;\n\n\t\tret = _kvm_arm_irq_line(vm, intid, level);\n\t\tTEST_ASSERT(ret != 0 && errno == EINVAL,\n\t\t\t\t\"Bad intid %i did not cause KVM_IRQ_LINE \"\n\t\t\t\t\"error: rc: %i errno: %i\", intid, ret, errno);\n\t}\n}\n\nvoid kvm_irq_set_level_info_check(int gic_fd, uint32_t intid, int level,\n\t\t\tbool expect_failure)\n{\n\tif (!expect_failure) {\n\t\tkvm_irq_set_level_info(gic_fd, intid, level);\n\t} else {\n\t\tint ret = _kvm_irq_set_level_info(gic_fd, intid, level);\n\t\t \n\t\tif (intid > VGIC_MAX_RESERVED)\n\t\t\tTEST_ASSERT(ret != 0 && errno == EINVAL,\n\t\t\t\t\"Bad intid %i did not cause VGIC_GRP_LEVEL_INFO \"\n\t\t\t\t\"error: rc: %i errno: %i\", intid, ret, errno);\n\t\telse\n\t\t\tTEST_ASSERT(!ret, \"KVM_DEV_ARM_VGIC_GRP_LEVEL_INFO \"\n\t\t\t\t\"for intid %i failed, rc: %i errno: %i\",\n\t\t\t\tintid, ret, errno);\n\t}\n}\n\nstatic void kvm_set_gsi_routing_irqchip_check(struct kvm_vm *vm,\n\t\tuint32_t intid, uint32_t num, uint32_t kvm_max_routes,\n\t\tbool expect_failure)\n{\n\tstruct kvm_irq_routing *routing;\n\tint ret;\n\tuint64_t i;\n\n\tassert(num <= kvm_max_routes && kvm_max_routes <= KVM_MAX_IRQ_ROUTES);\n\n\trouting = kvm_gsi_routing_create();\n\tfor (i = intid; i < (uint64_t)intid + num; i++)\n\t\tkvm_gsi_routing_irqchip_add(routing, i - MIN_SPI, i - MIN_SPI);\n\n\tif (!expect_failure) {\n\t\tkvm_gsi_routing_write(vm, routing);\n\t} else {\n\t\tret = _kvm_gsi_routing_write(vm, routing);\n\t\t \n\t\tif (((uint64_t)intid + num - 1 - MIN_SPI) >= KVM_IRQCHIP_NUM_PINS)\n\t\t\tTEST_ASSERT(ret != 0 && errno == EINVAL,\n\t\t\t\t\"Bad intid %u did not cause KVM_SET_GSI_ROUTING \"\n\t\t\t\t\"error: rc: %i errno: %i\", intid, ret, errno);\n\t\telse\n\t\t\tTEST_ASSERT(ret == 0, \"KVM_SET_GSI_ROUTING \"\n\t\t\t\t\"for intid %i failed, rc: %i errno: %i\",\n\t\t\t\tintid, ret, errno);\n\t}\n}\n\nstatic void kvm_irq_write_ispendr_check(int gic_fd, uint32_t intid,\n\t\t\t\t\tstruct kvm_vcpu *vcpu,\n\t\t\t\t\tbool expect_failure)\n{\n\t \n\tif (!expect_failure)\n\t\tkvm_irq_write_ispendr(gic_fd, intid, vcpu);\n}\n\nstatic void kvm_routing_and_irqfd_check(struct kvm_vm *vm,\n\t\tuint32_t intid, uint32_t num, uint32_t kvm_max_routes,\n\t\tbool expect_failure)\n{\n\tint fd[MAX_SPI];\n\tuint64_t val;\n\tint ret, f;\n\tuint64_t i;\n\n\t \n\tif (INTID_IS_SGI(intid) || INTID_IS_PPI(intid))\n\t\treturn;\n\n\tkvm_set_gsi_routing_irqchip_check(vm, intid, num,\n\t\t\tkvm_max_routes, expect_failure);\n\n\t \n\n\tfor (f = 0, i = intid; i < (uint64_t)intid + num; i++, f++) {\n\t\tfd[f] = eventfd(0, 0);\n\t\tTEST_ASSERT(fd[f] != -1, __KVM_SYSCALL_ERROR(\"eventfd()\", fd[f]));\n\t}\n\n\tfor (f = 0, i = intid; i < (uint64_t)intid + num; i++, f++) {\n\t\tstruct kvm_irqfd irqfd = {\n\t\t\t.fd  = fd[f],\n\t\t\t.gsi = i - MIN_SPI,\n\t\t};\n\t\tassert(i <= (uint64_t)UINT_MAX);\n\t\tvm_ioctl(vm, KVM_IRQFD, &irqfd);\n\t}\n\n\tfor (f = 0, i = intid; i < (uint64_t)intid + num; i++, f++) {\n\t\tval = 1;\n\t\tret = write(fd[f], &val, sizeof(uint64_t));\n\t\tTEST_ASSERT(ret == sizeof(uint64_t),\n\t\t\t    __KVM_SYSCALL_ERROR(\"write()\", ret));\n\t}\n\n\tfor (f = 0, i = intid; i < (uint64_t)intid + num; i++, f++)\n\t\tclose(fd[f]);\n}\n\n \n#define for_each_intid(first, num, tmp, i)\t\t\t\t\t\\\n\tfor ((tmp) = (i) = (first);\t\t\t\t\t\t\\\n\t\t(tmp) < (uint64_t)(first) + (uint64_t)(num);\t\t\t\\\n\t\t(tmp)++, (i)++)\n\nstatic void run_guest_cmd(struct kvm_vcpu *vcpu, int gic_fd,\n\t\t\t  struct kvm_inject_args *inject_args,\n\t\t\t  struct test_args *test_args)\n{\n\tkvm_inject_cmd cmd = inject_args->cmd;\n\tuint32_t intid = inject_args->first_intid;\n\tuint32_t num = inject_args->num;\n\tint level = inject_args->level;\n\tbool expect_failure = inject_args->expect_failure;\n\tstruct kvm_vm *vm = vcpu->vm;\n\tuint64_t tmp;\n\tuint32_t i;\n\n\t \n\tassert(intid < UINT_MAX - num || num == 1);\n\n\tswitch (cmd) {\n\tcase KVM_INJECT_EDGE_IRQ_LINE:\n\t\tfor_each_intid(intid, num, tmp, i)\n\t\t\tkvm_irq_line_check(vm, i, 1, test_args,\n\t\t\t\t\texpect_failure);\n\t\tfor_each_intid(intid, num, tmp, i)\n\t\t\tkvm_irq_line_check(vm, i, 0, test_args,\n\t\t\t\t\texpect_failure);\n\t\tbreak;\n\tcase KVM_SET_IRQ_LINE:\n\t\tfor_each_intid(intid, num, tmp, i)\n\t\t\tkvm_irq_line_check(vm, i, level, test_args,\n\t\t\t\t\texpect_failure);\n\t\tbreak;\n\tcase KVM_SET_IRQ_LINE_HIGH:\n\t\tfor_each_intid(intid, num, tmp, i)\n\t\t\tkvm_irq_line_check(vm, i, 1, test_args,\n\t\t\t\t\texpect_failure);\n\t\tbreak;\n\tcase KVM_SET_LEVEL_INFO_HIGH:\n\t\tfor_each_intid(intid, num, tmp, i)\n\t\t\tkvm_irq_set_level_info_check(gic_fd, i, 1,\n\t\t\t\t\texpect_failure);\n\t\tbreak;\n\tcase KVM_INJECT_IRQFD:\n\t\tkvm_routing_and_irqfd_check(vm, intid, num,\n\t\t\t\t\ttest_args->kvm_max_routes,\n\t\t\t\t\texpect_failure);\n\t\tbreak;\n\tcase KVM_WRITE_ISPENDR:\n\t\tfor (i = intid; i < intid + num; i++)\n\t\t\tkvm_irq_write_ispendr_check(gic_fd, i, vcpu,\n\t\t\t\t\t\t    expect_failure);\n\t\tbreak;\n\tcase KVM_WRITE_ISACTIVER:\n\t\tfor (i = intid; i < intid + num; i++)\n\t\t\tkvm_irq_write_isactiver(gic_fd, i, vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void kvm_inject_get_call(struct kvm_vm *vm, struct ucall *uc,\n\t\tstruct kvm_inject_args *args)\n{\n\tstruct kvm_inject_args *kvm_args_hva;\n\tvm_vaddr_t kvm_args_gva;\n\n\tkvm_args_gva = uc->args[1];\n\tkvm_args_hva = (struct kvm_inject_args *)addr_gva2hva(vm, kvm_args_gva);\n\tmemcpy(args, kvm_args_hva, sizeof(struct kvm_inject_args));\n}\n\nstatic void print_args(struct test_args *args)\n{\n\tprintf(\"nr-irqs=%d level-sensitive=%d eoi-split=%d\\n\",\n\t\t\targs->nr_irqs, args->level_sensitive,\n\t\t\targs->eoi_split);\n}\n\nstatic void test_vgic(uint32_t nr_irqs, bool level_sensitive, bool eoi_split)\n{\n\tstruct ucall uc;\n\tint gic_fd;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct kvm_inject_args inject_args;\n\tvm_vaddr_t args_gva;\n\n\tstruct test_args args = {\n\t\t.nr_irqs = nr_irqs,\n\t\t.level_sensitive = level_sensitive,\n\t\t.eoi_split = eoi_split,\n\t\t.kvm_max_routes = kvm_check_cap(KVM_CAP_IRQ_ROUTING),\n\t\t.kvm_supports_irqfd = kvm_check_cap(KVM_CAP_IRQFD),\n\t};\n\n\tprint_args(&args);\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\t \n\targs_gva = vm_vaddr_alloc_page(vm);\n\tmemcpy(addr_gva2hva(vm, args_gva), &args, sizeof(args));\n\tvcpu_args_set(vcpu, 1, args_gva);\n\n\tgic_fd = vgic_v3_setup(vm, 1, nr_irqs,\n\t\t\tGICD_BASE_GPA, GICR_BASE_GPA);\n\t__TEST_REQUIRE(gic_fd >= 0, \"Failed to create vgic-v3, skipping\");\n\n\tvm_install_exception_handler(vm, VECTOR_IRQ_CURRENT,\n\t\tguest_irq_handlers[args.eoi_split][args.level_sensitive]);\n\n\twhile (1) {\n\t\tvcpu_run(vcpu);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_SYNC:\n\t\t\tkvm_inject_get_call(vm, &uc, &inject_args);\n\t\t\trun_guest_cmd(vcpu, gic_fd, &inject_args, &args);\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\t}\n\ndone:\n\tclose(gic_fd);\n\tkvm_vm_free(vm);\n}\n\nstatic void help(const char *name)\n{\n\tprintf(\n\t\"\\n\"\n\t\"usage: %s [-n num_irqs] [-e eoi_split] [-l level_sensitive]\\n\", name);\n\tprintf(\" -n: specify number of IRQs to setup the vgic with. \"\n\t\t\"It has to be a multiple of 32 and between 64 and 1024.\\n\");\n\tprintf(\" -e: if 1 then EOI is split into a write to DIR on top \"\n\t\t\"of writing EOI.\\n\");\n\tprintf(\" -l: specify whether the IRQs are level-sensitive (1) or not (0).\");\n\tputs(\"\");\n\texit(1);\n}\n\nint main(int argc, char **argv)\n{\n\tuint32_t nr_irqs = 64;\n\tbool default_args = true;\n\tbool level_sensitive = false;\n\tint opt;\n\tbool eoi_split = false;\n\n\twhile ((opt = getopt(argc, argv, \"hn:e:l:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'n':\n\t\t\tnr_irqs = atoi_non_negative(\"Number of IRQs\", optarg);\n\t\t\tif (nr_irqs > 1024 || nr_irqs % 32)\n\t\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\teoi_split = (bool)atoi_paranoid(optarg);\n\t\t\tdefault_args = false;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlevel_sensitive = (bool)atoi_paranoid(optarg);\n\t\t\tdefault_args = false;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (default_args) {\n\t\ttest_vgic(nr_irqs, false  , false  );\n\t\ttest_vgic(nr_irqs, false  , true  );\n\t\ttest_vgic(nr_irqs, true  , false  );\n\t\ttest_vgic(nr_irqs, true  , true  );\n\t} else {\n\t\ttest_vgic(nr_irqs, level_sensitive, eoi_split);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}