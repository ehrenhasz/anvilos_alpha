{
  "module_name": "test_util.c",
  "hash_id": "47620624415fcad79e98b541dbd065069a1e92208d8f17f5ab1c3fb5e07a0f95",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/test_util.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <linux/mman.h>\n#include \"linux/kernel.h\"\n\n#include \"test_util.h\"\n\n \n\nstruct guest_random_state new_guest_random_state(uint32_t seed)\n{\n\tstruct guest_random_state s = {.seed = seed};\n\treturn s;\n}\n\nuint32_t guest_random_u32(struct guest_random_state *state)\n{\n\tstate->seed = (uint64_t)state->seed * 48271 % ((uint32_t)(1 << 31) - 1);\n\treturn state->seed;\n}\n\n \nsize_t parse_size(const char *size)\n{\n\tsize_t base;\n\tchar *scale;\n\tint shift = 0;\n\n\tTEST_ASSERT(size && isdigit(size[0]), \"Need at least one digit in '%s'\", size);\n\n\tbase = strtoull(size, &scale, 0);\n\n\tTEST_ASSERT(base != ULLONG_MAX, \"Overflow parsing size!\");\n\n\tswitch (tolower(*scale)) {\n\tcase 't':\n\t\tshift = 40;\n\t\tbreak;\n\tcase 'g':\n\t\tshift = 30;\n\t\tbreak;\n\tcase 'm':\n\t\tshift = 20;\n\t\tbreak;\n\tcase 'k':\n\t\tshift = 10;\n\t\tbreak;\n\tcase 'b':\n\tcase '\\0':\n\t\tshift = 0;\n\t\tbreak;\n\tdefault:\n\t\tTEST_ASSERT(false, \"Unknown size letter %c\", *scale);\n\t}\n\n\tTEST_ASSERT((base << shift) >> shift == base, \"Overflow scaling size!\");\n\n\treturn base << shift;\n}\n\nint64_t timespec_to_ns(struct timespec ts)\n{\n\treturn (int64_t)ts.tv_nsec + 1000000000LL * (int64_t)ts.tv_sec;\n}\n\nstruct timespec timespec_add_ns(struct timespec ts, int64_t ns)\n{\n\tstruct timespec res;\n\n\tres.tv_nsec = ts.tv_nsec + ns;\n\tres.tv_sec = ts.tv_sec + res.tv_nsec / 1000000000LL;\n\tres.tv_nsec %= 1000000000LL;\n\n\treturn res;\n}\n\nstruct timespec timespec_add(struct timespec ts1, struct timespec ts2)\n{\n\tint64_t ns1 = timespec_to_ns(ts1);\n\tint64_t ns2 = timespec_to_ns(ts2);\n\treturn timespec_add_ns((struct timespec){0}, ns1 + ns2);\n}\n\nstruct timespec timespec_sub(struct timespec ts1, struct timespec ts2)\n{\n\tint64_t ns1 = timespec_to_ns(ts1);\n\tint64_t ns2 = timespec_to_ns(ts2);\n\treturn timespec_add_ns((struct timespec){0}, ns1 - ns2);\n}\n\nstruct timespec timespec_elapsed(struct timespec start)\n{\n\tstruct timespec end;\n\n\tclock_gettime(CLOCK_MONOTONIC, &end);\n\treturn timespec_sub(end, start);\n}\n\nstruct timespec timespec_div(struct timespec ts, int divisor)\n{\n\tint64_t ns = timespec_to_ns(ts) / divisor;\n\n\treturn timespec_add_ns((struct timespec){0}, ns);\n}\n\nvoid print_skip(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tassert(fmt);\n\tva_start(ap, fmt);\n\tvprintf(fmt, ap);\n\tva_end(ap);\n\tputs(\", skipping test\");\n}\n\nbool thp_configured(void)\n{\n\tint ret;\n\tstruct stat statbuf;\n\n\tret = stat(\"/sys/kernel/mm/transparent_hugepage\", &statbuf);\n\tTEST_ASSERT(ret == 0 || (ret == -1 && errno == ENOENT),\n\t\t    \"Error in stating /sys/kernel/mm/transparent_hugepage\");\n\n\treturn ret == 0;\n}\n\nsize_t get_trans_hugepagesz(void)\n{\n\tsize_t size;\n\tFILE *f;\n\tint ret;\n\n\tTEST_ASSERT(thp_configured(), \"THP is not configured in host kernel\");\n\n\tf = fopen(\"/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\", \"r\");\n\tTEST_ASSERT(f != NULL, \"Error in opening transparent_hugepage/hpage_pmd_size\");\n\n\tret = fscanf(f, \"%ld\", &size);\n\tret = fscanf(f, \"%ld\", &size);\n\tTEST_ASSERT(ret < 1, \"Error reading transparent_hugepage/hpage_pmd_size\");\n\tfclose(f);\n\n\treturn size;\n}\n\nsize_t get_def_hugetlb_pagesz(void)\n{\n\tchar buf[64];\n\tconst char *hugepagesize = \"Hugepagesize:\";\n\tconst char *hugepages_total = \"HugePages_Total:\";\n\tFILE *f;\n\n\tf = fopen(\"/proc/meminfo\", \"r\");\n\tTEST_ASSERT(f != NULL, \"Error in opening /proc/meminfo\");\n\n\twhile (fgets(buf, sizeof(buf), f) != NULL) {\n\t\tif (strstr(buf, hugepages_total) == buf) {\n\t\t\tunsigned long long total = strtoull(buf + strlen(hugepages_total), NULL, 10);\n\t\t\tif (!total) {\n\t\t\t\tfprintf(stderr, \"HUGETLB is not enabled in /proc/sys/vm/nr_hugepages\\n\");\n\t\t\t\texit(KSFT_SKIP);\n\t\t\t}\n\t\t}\n\t\tif (strstr(buf, hugepagesize) == buf) {\n\t\t\tfclose(f);\n\t\t\treturn strtoull(buf + strlen(hugepagesize), NULL, 10) << 10;\n\t\t}\n\t}\n\n\tif (feof(f)) {\n\t\tfprintf(stderr, \"HUGETLB is not configured in host kernel\");\n\t\texit(KSFT_SKIP);\n\t}\n\n\tTEST_FAIL(\"Error in reading /proc/meminfo\");\n}\n\n#define ANON_FLAGS\t(MAP_PRIVATE | MAP_ANONYMOUS)\n#define ANON_HUGE_FLAGS\t(ANON_FLAGS | MAP_HUGETLB)\n\nconst struct vm_mem_backing_src_alias *vm_mem_backing_src_alias(uint32_t i)\n{\n\tstatic const struct vm_mem_backing_src_alias aliases[] = {\n\t\t[VM_MEM_SRC_ANONYMOUS] = {\n\t\t\t.name = \"anonymous\",\n\t\t\t.flag = ANON_FLAGS,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_THP] = {\n\t\t\t.name = \"anonymous_thp\",\n\t\t\t.flag = ANON_FLAGS,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB] = {\n\t\t\t.name = \"anonymous_hugetlb\",\n\t\t\t.flag = ANON_HUGE_FLAGS,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_16KB] = {\n\t\t\t.name = \"anonymous_hugetlb_16kb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_16KB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_64KB] = {\n\t\t\t.name = \"anonymous_hugetlb_64kb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_64KB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_512KB] = {\n\t\t\t.name = \"anonymous_hugetlb_512kb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_512KB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_1MB] = {\n\t\t\t.name = \"anonymous_hugetlb_1mb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_1MB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_2MB] = {\n\t\t\t.name = \"anonymous_hugetlb_2mb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_2MB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_8MB] = {\n\t\t\t.name = \"anonymous_hugetlb_8mb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_8MB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_16MB] = {\n\t\t\t.name = \"anonymous_hugetlb_16mb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_16MB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_32MB] = {\n\t\t\t.name = \"anonymous_hugetlb_32mb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_32MB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_256MB] = {\n\t\t\t.name = \"anonymous_hugetlb_256mb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_256MB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_512MB] = {\n\t\t\t.name = \"anonymous_hugetlb_512mb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_512MB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_1GB] = {\n\t\t\t.name = \"anonymous_hugetlb_1gb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_1GB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_2GB] = {\n\t\t\t.name = \"anonymous_hugetlb_2gb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_2GB,\n\t\t},\n\t\t[VM_MEM_SRC_ANONYMOUS_HUGETLB_16GB] = {\n\t\t\t.name = \"anonymous_hugetlb_16gb\",\n\t\t\t.flag = ANON_HUGE_FLAGS | MAP_HUGE_16GB,\n\t\t},\n\t\t[VM_MEM_SRC_SHMEM] = {\n\t\t\t.name = \"shmem\",\n\t\t\t.flag = MAP_SHARED,\n\t\t},\n\t\t[VM_MEM_SRC_SHARED_HUGETLB] = {\n\t\t\t.name = \"shared_hugetlb\",\n\t\t\t \n\t\t\t.flag = MAP_SHARED,\n\t\t},\n\t};\n\t_Static_assert(ARRAY_SIZE(aliases) == NUM_SRC_TYPES,\n\t\t       \"Missing new backing src types?\");\n\n\tTEST_ASSERT(i < NUM_SRC_TYPES, \"Backing src type ID %d too big\", i);\n\n\treturn &aliases[i];\n}\n\n#define MAP_HUGE_PAGE_SIZE(x) (1ULL << ((x >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK))\n\nsize_t get_backing_src_pagesz(uint32_t i)\n{\n\tuint32_t flag = vm_mem_backing_src_alias(i)->flag;\n\n\tswitch (i) {\n\tcase VM_MEM_SRC_ANONYMOUS:\n\tcase VM_MEM_SRC_SHMEM:\n\t\treturn getpagesize();\n\tcase VM_MEM_SRC_ANONYMOUS_THP:\n\t\treturn get_trans_hugepagesz();\n\tcase VM_MEM_SRC_ANONYMOUS_HUGETLB:\n\tcase VM_MEM_SRC_SHARED_HUGETLB:\n\t\treturn get_def_hugetlb_pagesz();\n\tdefault:\n\t\treturn MAP_HUGE_PAGE_SIZE(flag);\n\t}\n}\n\nbool is_backing_src_hugetlb(uint32_t i)\n{\n\treturn !!(vm_mem_backing_src_alias(i)->flag & MAP_HUGETLB);\n}\n\nstatic void print_available_backing_src_types(const char *prefix)\n{\n\tint i;\n\n\tprintf(\"%sAvailable backing src types:\\n\", prefix);\n\n\tfor (i = 0; i < NUM_SRC_TYPES; i++)\n\t\tprintf(\"%s    %s\\n\", prefix, vm_mem_backing_src_alias(i)->name);\n}\n\nvoid backing_src_help(const char *flag)\n{\n\tprintf(\" %s: specify the type of memory that should be used to\\n\"\n\t       \"     back the guest data region. (default: %s)\\n\",\n\t       flag, vm_mem_backing_src_alias(DEFAULT_VM_MEM_SRC)->name);\n\tprint_available_backing_src_types(\"     \");\n}\n\nenum vm_mem_backing_src_type parse_backing_src_type(const char *type_name)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_SRC_TYPES; i++)\n\t\tif (!strcmp(type_name, vm_mem_backing_src_alias(i)->name))\n\t\t\treturn i;\n\n\tprint_available_backing_src_types(\"\");\n\tTEST_FAIL(\"Unknown backing src type: %s\", type_name);\n\treturn -1;\n}\n\nlong get_run_delay(void)\n{\n\tchar path[64];\n\tlong val[2];\n\tFILE *fp;\n\n\tsprintf(path, \"/proc/%ld/schedstat\", syscall(SYS_gettid));\n\tfp = fopen(path, \"r\");\n\t \n\tif (fscanf(fp, \"%ld %ld \", &val[0], &val[1]) < 2)\n\t\tval[1] = MIN_RUN_DELAY_NS;\n\tfclose(fp);\n\n\treturn val[1];\n}\n\nint atoi_paranoid(const char *num_str)\n{\n\tchar *end_ptr;\n\tlong num;\n\n\terrno = 0;\n\tnum = strtol(num_str, &end_ptr, 0);\n\tTEST_ASSERT(!errno, \"strtol(\\\"%s\\\") failed\", num_str);\n\tTEST_ASSERT(num_str != end_ptr,\n\t\t    \"strtol(\\\"%s\\\") didn't find a valid integer.\", num_str);\n\tTEST_ASSERT(*end_ptr == '\\0',\n\t\t    \"strtol(\\\"%s\\\") failed to parse trailing characters \\\"%s\\\".\",\n\t\t    num_str, end_ptr);\n\tTEST_ASSERT(num >= INT_MIN && num <= INT_MAX,\n\t\t    \"%ld not in range of [%d, %d]\", num, INT_MIN, INT_MAX);\n\n\treturn num;\n}\n\nchar *strdup_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *str;\n\n\tva_start(ap, fmt);\n\tTEST_ASSERT(vasprintf(&str, fmt, ap) >= 0, \"vasprintf() failed\");\n\tva_end(ap);\n\n\treturn str;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}