{
  "module_name": "sparsebit.c",
  "hash_id": "d66eb8c52362e4efef50d4aca75f8c69e7f1f529df1c10f02e94c6447ccb9edc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/sparsebit.c",
  "human_readable_source": "\n \n\n#include \"test_util.h\"\n#include \"sparsebit.h\"\n#include <limits.h>\n#include <assert.h>\n\n#define DUMP_LINE_MAX 100  \n\ntypedef uint32_t mask_t;\n#define MASK_BITS (sizeof(mask_t) * CHAR_BIT)\n\nstruct node {\n\tstruct node *parent;\n\tstruct node *left;\n\tstruct node *right;\n\tsparsebit_idx_t idx;  \n\tsparsebit_num_t num_after;  \n\tmask_t mask;\n};\n\nstruct sparsebit {\n\t \n\tstruct node *root;\n\n\t \n\tsparsebit_num_t num_set;\n};\n\n \nstatic sparsebit_num_t node_num_set(struct node *nodep)\n{\n\treturn nodep->num_after + __builtin_popcount(nodep->mask);\n}\n\n \nstatic struct node *node_first(struct sparsebit *s)\n{\n\tstruct node *nodep;\n\n\tfor (nodep = s->root; nodep && nodep->left; nodep = nodep->left)\n\t\t;\n\n\treturn nodep;\n}\n\n \nstatic struct node *node_next(struct sparsebit *s, struct node *np)\n{\n\tstruct node *nodep = np;\n\n\t \n\tif (nodep->right) {\n\t\tfor (nodep = nodep->right; nodep->left; nodep = nodep->left)\n\t\t\t;\n\t\treturn nodep;\n\t}\n\n\t \n\twhile (nodep->parent && nodep == nodep->parent->right)\n\t\tnodep = nodep->parent;\n\n\treturn nodep->parent;\n}\n\n \nstatic struct node *node_prev(struct sparsebit *s, struct node *np)\n{\n\tstruct node *nodep = np;\n\n\t \n\tif (nodep->left) {\n\t\tfor (nodep = nodep->left; nodep->right; nodep = nodep->right)\n\t\t\t;\n\t\treturn (struct node *) nodep;\n\t}\n\n\t \n\twhile (nodep->parent && nodep == nodep->parent->left)\n\t\tnodep = nodep->parent;\n\n\treturn (struct node *) nodep->parent;\n}\n\n\n \nstatic struct node *node_copy_subtree(struct node *subtree)\n{\n\tstruct node *root;\n\n\t \n\troot = calloc(1, sizeof(*root));\n\tif (!root) {\n\t\tperror(\"calloc\");\n\t\tabort();\n\t}\n\n\troot->idx = subtree->idx;\n\troot->mask = subtree->mask;\n\troot->num_after = subtree->num_after;\n\n\t \n\tif (subtree->left) {\n\t\troot->left = node_copy_subtree(subtree->left);\n\t\troot->left->parent = root;\n\t}\n\n\tif (subtree->right) {\n\t\troot->right = node_copy_subtree(subtree->right);\n\t\troot->right->parent = root;\n\t}\n\n\treturn root;\n}\n\n \nstatic struct node *node_find(struct sparsebit *s, sparsebit_idx_t idx)\n{\n\tstruct node *nodep;\n\n\t \n\tfor (nodep = s->root; nodep;\n\t     nodep = nodep->idx > idx ? nodep->left : nodep->right) {\n\t\tif (idx >= nodep->idx &&\n\t\t    idx <= nodep->idx + MASK_BITS + nodep->num_after - 1)\n\t\t\tbreak;\n\t}\n\n\treturn nodep;\n}\n\n \nstatic struct node *node_add(struct sparsebit *s, sparsebit_idx_t idx)\n{\n\tstruct node *nodep, *parentp, *prev;\n\n\t \n\tnodep = calloc(1, sizeof(*nodep));\n\tif (!nodep) {\n\t\tperror(\"calloc\");\n\t\tabort();\n\t}\n\n\tnodep->idx = idx & -MASK_BITS;\n\n\t \n\tif (!s->root) {\n\t\ts->root = nodep;\n\t\treturn nodep;\n\t}\n\n\t \n\tparentp = s->root;\n\twhile (true) {\n\t\tif (idx < parentp->idx) {\n\t\t\tif (!parentp->left) {\n\t\t\t\tparentp->left = nodep;\n\t\t\t\tnodep->parent = parentp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparentp = parentp->left;\n\t\t} else {\n\t\t\tassert(idx > parentp->idx + MASK_BITS + parentp->num_after - 1);\n\t\t\tif (!parentp->right) {\n\t\t\t\tparentp->right = nodep;\n\t\t\t\tnodep->parent = parentp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparentp = parentp->right;\n\t\t}\n\t}\n\n\t \n\tprev = node_prev(s, nodep);\n\twhile (prev && prev->idx + MASK_BITS + prev->num_after - 1 >= nodep->idx) {\n\t\tunsigned int n1 = (prev->idx + MASK_BITS + prev->num_after - 1)\n\t\t\t- nodep->idx;\n\t\tassert(prev->num_after > 0);\n\t\tassert(n1 < MASK_BITS);\n\t\tassert(!(nodep->mask & (1 << n1)));\n\t\tnodep->mask |= (1 << n1);\n\t\tprev->num_after--;\n\t}\n\n\treturn nodep;\n}\n\n \nbool sparsebit_all_set(struct sparsebit *s)\n{\n\t \n\treturn s->root && s->num_set == 0;\n}\n\n \nstatic void node_rm(struct sparsebit *s, struct node *nodep)\n{\n\tstruct node *tmp;\n\tsparsebit_num_t num_set;\n\n\tnum_set = node_num_set(nodep);\n\tassert(s->num_set >= num_set || sparsebit_all_set(s));\n\ts->num_set -= node_num_set(nodep);\n\n\t \n\tif (nodep->left && nodep->right) {\n\t\t \n\t\tfor (tmp = nodep->right; tmp->left; tmp = tmp->left)\n\t\t\t;\n\t\ttmp->left = nodep->left;\n\t\tnodep->left = NULL;\n\t\ttmp->left->parent = tmp;\n\t}\n\n\t \n\tif (nodep->left) {\n\t\tif (!nodep->parent) {\n\t\t\ts->root = nodep->left;\n\t\t\tnodep->left->parent = NULL;\n\t\t} else {\n\t\t\tnodep->left->parent = nodep->parent;\n\t\t\tif (nodep == nodep->parent->left)\n\t\t\t\tnodep->parent->left = nodep->left;\n\t\t\telse {\n\t\t\t\tassert(nodep == nodep->parent->right);\n\t\t\t\tnodep->parent->right = nodep->left;\n\t\t\t}\n\t\t}\n\n\t\tnodep->parent = nodep->left = nodep->right = NULL;\n\t\tfree(nodep);\n\n\t\treturn;\n\t}\n\n\n\t \n\tif (nodep->right) {\n\t\tif (!nodep->parent) {\n\t\t\ts->root = nodep->right;\n\t\t\tnodep->right->parent = NULL;\n\t\t} else {\n\t\t\tnodep->right->parent = nodep->parent;\n\t\t\tif (nodep == nodep->parent->left)\n\t\t\t\tnodep->parent->left = nodep->right;\n\t\t\telse {\n\t\t\t\tassert(nodep == nodep->parent->right);\n\t\t\t\tnodep->parent->right = nodep->right;\n\t\t\t}\n\t\t}\n\n\t\tnodep->parent = nodep->left = nodep->right = NULL;\n\t\tfree(nodep);\n\n\t\treturn;\n\t}\n\n\t \n\tif (!nodep->parent) {\n\t\ts->root = NULL;\n\t} else {\n\t\tif (nodep->parent->left == nodep)\n\t\t\tnodep->parent->left = NULL;\n\t\telse {\n\t\t\tassert(nodep == nodep->parent->right);\n\t\t\tnodep->parent->right = NULL;\n\t\t}\n\t}\n\n\tnodep->parent = nodep->left = nodep->right = NULL;\n\tfree(nodep);\n\n\treturn;\n}\n\n \nstatic struct node *node_split(struct sparsebit *s, sparsebit_idx_t idx)\n{\n\tstruct node *nodep1, *nodep2;\n\tsparsebit_idx_t offset;\n\tsparsebit_num_t orig_num_after;\n\n\tassert(!(idx % MASK_BITS));\n\n\t \n\tnodep1 = node_find(s, idx);\n\tif (!nodep1)\n\t\treturn node_add(s, idx);\n\n\t \n\tif (nodep1->idx == idx)\n\t\treturn nodep1;\n\n\t \n\n\t \n\toffset = idx - (nodep1->idx + MASK_BITS);\n\torig_num_after = nodep1->num_after;\n\n\t \n\tnodep1->num_after = offset;\n\tnodep2 = node_add(s, idx);\n\n\t \n\tnodep2->num_after = orig_num_after - offset;\n\tif (nodep2->num_after >= MASK_BITS) {\n\t\tnodep2->mask = ~(mask_t) 0;\n\t\tnodep2->num_after -= MASK_BITS;\n\t} else {\n\t\tnodep2->mask = (1 << nodep2->num_after) - 1;\n\t\tnodep2->num_after = 0;\n\t}\n\n\treturn nodep2;\n}\n\n \nstatic void node_reduce(struct sparsebit *s, struct node *nodep)\n{\n\tbool reduction_performed;\n\n\tdo {\n\t\treduction_performed = false;\n\t\tstruct node *prev, *next, *tmp;\n\n\t\t \n\n\t\t \n\t\tif (nodep->mask == 0 && nodep->num_after == 0) {\n\t\t\t \n\t\t\ttmp = node_next(s, nodep);\n\t\t\tif (!tmp)\n\t\t\t\ttmp = node_prev(s, nodep);\n\n\t\t\tnode_rm(s, nodep);\n\n\t\t\tnodep = tmp;\n\t\t\treduction_performed = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (nodep->mask == 0) {\n\t\t\tassert(nodep->num_after != 0);\n\t\t\tassert(nodep->idx + MASK_BITS > nodep->idx);\n\n\t\t\tnodep->idx += MASK_BITS;\n\n\t\t\tif (nodep->num_after >= MASK_BITS) {\n\t\t\t\tnodep->mask = ~0;\n\t\t\t\tnodep->num_after -= MASK_BITS;\n\t\t\t} else {\n\t\t\t\tnodep->mask = (1u << nodep->num_after) - 1;\n\t\t\t\tnodep->num_after = 0;\n\t\t\t}\n\n\t\t\treduction_performed = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tprev = node_prev(s, nodep);\n\t\tif (prev) {\n\t\t\tsparsebit_idx_t prev_highest_bit;\n\n\t\t\t \n\t\t\tif (prev->mask == 0 && prev->num_after == 0) {\n\t\t\t\tnode_rm(s, prev);\n\n\t\t\t\treduction_performed = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (nodep->mask + 1 == 0 &&\n\t\t\t    prev->idx + MASK_BITS == nodep->idx) {\n\t\t\t\tprev->num_after += MASK_BITS + nodep->num_after;\n\t\t\t\tnodep->mask = 0;\n\t\t\t\tnodep->num_after = 0;\n\n\t\t\t\treduction_performed = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tprev_highest_bit = prev->idx + MASK_BITS - 1 + prev->num_after;\n\t\t\tif (prev_highest_bit + 1 == nodep->idx &&\n\t\t\t    (nodep->mask | (nodep->mask >> 1)) == nodep->mask) {\n\t\t\t\t \n\t\t\t\tunsigned int num_contiguous\n\t\t\t\t\t= __builtin_popcount(nodep->mask);\n\t\t\t\tassert((num_contiguous > 0) &&\n\t\t\t\t       ((1ULL << num_contiguous) - 1) == nodep->mask);\n\n\t\t\t\tprev->num_after += num_contiguous;\n\t\t\t\tnodep->mask = 0;\n\n\t\t\t\t \n\t\t\t\tif (num_contiguous == MASK_BITS) {\n\t\t\t\t\tprev->num_after += nodep->num_after;\n\t\t\t\t\tnodep->num_after = 0;\n\t\t\t\t}\n\n\t\t\t\treduction_performed = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tnext = node_next(s, nodep);\n\t\tif (next) {\n\t\t\t \n\t\t\tif (next->mask == 0 && next->num_after == 0) {\n\t\t\t\tnode_rm(s, next);\n\t\t\t\treduction_performed = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (next->idx == nodep->idx + MASK_BITS + nodep->num_after &&\n\t\t\t    next->mask == ~(mask_t) 0) {\n\t\t\t\tnodep->num_after += MASK_BITS;\n\t\t\t\tnext->mask = 0;\n\t\t\t\tnodep->num_after += next->num_after;\n\t\t\t\tnext->num_after = 0;\n\n\t\t\t\tnode_rm(s, next);\n\t\t\t\tnext = NULL;\n\n\t\t\t\treduction_performed = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t} while (nodep && reduction_performed);\n}\n\n \nbool sparsebit_is_set(struct sparsebit *s, sparsebit_idx_t idx)\n{\n\tstruct node *nodep;\n\n\t \n\tfor (nodep = s->root; nodep;\n\t     nodep = nodep->idx > idx ? nodep->left : nodep->right)\n\t\tif (idx >= nodep->idx &&\n\t\t    idx <= nodep->idx + MASK_BITS + nodep->num_after - 1)\n\t\t\tgoto have_node;\n\n\treturn false;\n\nhave_node:\n\t \n\tif (nodep->num_after && idx >= nodep->idx + MASK_BITS)\n\t\treturn true;\n\n\t \n\tassert(idx >= nodep->idx && idx - nodep->idx < MASK_BITS);\n\treturn !!(nodep->mask & (1 << (idx - nodep->idx)));\n}\n\n \nstatic void bit_set(struct sparsebit *s, sparsebit_idx_t idx)\n{\n\tstruct node *nodep;\n\n\t \n\tif (sparsebit_is_set(s, idx))\n\t\treturn;\n\n\t \n\tnodep = node_split(s, idx & -MASK_BITS);\n\n\t \n\tassert(idx >= nodep->idx && idx <= nodep->idx + MASK_BITS - 1);\n\tassert(!(nodep->mask & (1 << (idx - nodep->idx))));\n\tnodep->mask |= 1 << (idx - nodep->idx);\n\ts->num_set++;\n\n\tnode_reduce(s, nodep);\n}\n\n \nstatic void bit_clear(struct sparsebit *s, sparsebit_idx_t idx)\n{\n\tstruct node *nodep;\n\n\t \n\tif (!sparsebit_is_set(s, idx))\n\t\treturn;\n\n\t \n\tnodep = node_find(s, idx);\n\tif (!nodep)\n\t\treturn;\n\n\t \n\tif (idx >= nodep->idx + MASK_BITS)\n\t\tnodep = node_split(s, idx & -MASK_BITS);\n\n\t \n\tassert(idx >= nodep->idx && idx <= nodep->idx + MASK_BITS - 1);\n\tassert(nodep->mask & (1 << (idx - nodep->idx)));\n\tnodep->mask &= ~(1 << (idx - nodep->idx));\n\tassert(s->num_set > 0 || sparsebit_all_set(s));\n\ts->num_set--;\n\n\tnode_reduce(s, nodep);\n}\n\n \nstatic void dump_nodes(FILE *stream, struct node *nodep,\n\tunsigned int indent)\n{\n\tchar *node_type;\n\n\t \n\tif (!nodep->parent)\n\t\tnode_type = \"root\";\n\telse if (nodep == nodep->parent->left)\n\t\tnode_type = \"left\";\n\telse {\n\t\tassert(nodep == nodep->parent->right);\n\t\tnode_type = \"right\";\n\t}\n\tfprintf(stream, \"%*s---- %s nodep: %p\\n\", indent, \"\", node_type, nodep);\n\tfprintf(stream, \"%*s  parent: %p left: %p right: %p\\n\", indent, \"\",\n\t\tnodep->parent, nodep->left, nodep->right);\n\tfprintf(stream, \"%*s  idx: 0x%lx mask: 0x%x num_after: 0x%lx\\n\",\n\t\tindent, \"\", nodep->idx, nodep->mask, nodep->num_after);\n\n\t \n\tif (nodep->left)\n\t\tdump_nodes(stream, nodep->left, indent + 2);\n\n\t \n\tif (nodep->right)\n\t\tdump_nodes(stream, nodep->right, indent + 2);\n}\n\nstatic inline sparsebit_idx_t node_first_set(struct node *nodep, int start)\n{\n\tmask_t leading = (mask_t)1 << start;\n\tint n1 = __builtin_ctz(nodep->mask & -leading);\n\n\treturn nodep->idx + n1;\n}\n\nstatic inline sparsebit_idx_t node_first_clear(struct node *nodep, int start)\n{\n\tmask_t leading = (mask_t)1 << start;\n\tint n1 = __builtin_ctz(~nodep->mask & -leading);\n\n\treturn nodep->idx + n1;\n}\n\n \nstatic void sparsebit_dump_internal(FILE *stream, struct sparsebit *s,\n\tunsigned int indent)\n{\n\t \n\tfprintf(stream, \"%*sroot: %p\\n\", indent, \"\", s->root);\n\tfprintf(stream, \"%*snum_set: 0x%lx\\n\", indent, \"\", s->num_set);\n\n\tif (s->root)\n\t\tdump_nodes(stream, s->root, indent);\n}\n\n \nstruct sparsebit *sparsebit_alloc(void)\n{\n\tstruct sparsebit *s;\n\n\t \n\ts = calloc(1, sizeof(*s));\n\tif (!s) {\n\t\tperror(\"calloc\");\n\t\tabort();\n\t}\n\n\treturn s;\n}\n\n \nvoid sparsebit_free(struct sparsebit **sbitp)\n{\n\tstruct sparsebit *s = *sbitp;\n\n\tif (!s)\n\t\treturn;\n\n\tsparsebit_clear_all(s);\n\tfree(s);\n\t*sbitp = NULL;\n}\n\n \nvoid sparsebit_copy(struct sparsebit *d, struct sparsebit *s)\n{\n\t \n\tsparsebit_clear_all(d);\n\n\tif (s->root) {\n\t\td->root = node_copy_subtree(s->root);\n\t\td->num_set = s->num_set;\n\t}\n}\n\n \nbool sparsebit_is_set_num(struct sparsebit *s,\n\tsparsebit_idx_t idx, sparsebit_num_t num)\n{\n\tsparsebit_idx_t next_cleared;\n\n\tassert(num > 0);\n\tassert(idx + num - 1 >= idx);\n\n\t \n\tif (!sparsebit_is_set(s, idx))\n\t\treturn false;\n\n\t \n\tnext_cleared = sparsebit_next_clear(s, idx);\n\n\t \n\treturn next_cleared == 0 || next_cleared - idx >= num;\n}\n\n \nbool sparsebit_is_clear(struct sparsebit *s,\n\tsparsebit_idx_t idx)\n{\n\treturn !sparsebit_is_set(s, idx);\n}\n\n \nbool sparsebit_is_clear_num(struct sparsebit *s,\n\tsparsebit_idx_t idx, sparsebit_num_t num)\n{\n\tsparsebit_idx_t next_set;\n\n\tassert(num > 0);\n\tassert(idx + num - 1 >= idx);\n\n\t \n\tif (!sparsebit_is_clear(s, idx))\n\t\treturn false;\n\n\t \n\tnext_set = sparsebit_next_set(s, idx);\n\n\t \n\treturn next_set == 0 || next_set - idx >= num;\n}\n\n \nsparsebit_num_t sparsebit_num_set(struct sparsebit *s)\n{\n\treturn s->num_set;\n}\n\n \nbool sparsebit_any_set(struct sparsebit *s)\n{\n\t \n\tif (!s->root)\n\t\treturn false;\n\n\t \n\tassert(s->root->mask != 0);\n\tassert(s->num_set > 0 ||\n\t       (s->root->num_after == ((sparsebit_num_t) 0) - MASK_BITS &&\n\t\ts->root->mask == ~(mask_t) 0));\n\n\treturn true;\n}\n\n \nbool sparsebit_all_clear(struct sparsebit *s)\n{\n\treturn !sparsebit_any_set(s);\n}\n\n \nbool sparsebit_any_clear(struct sparsebit *s)\n{\n\treturn !sparsebit_all_set(s);\n}\n\n \nsparsebit_idx_t sparsebit_first_set(struct sparsebit *s)\n{\n\tstruct node *nodep;\n\n\t \n\tassert(sparsebit_any_set(s));\n\n\tnodep = node_first(s);\n\treturn node_first_set(nodep, 0);\n}\n\n \nsparsebit_idx_t sparsebit_first_clear(struct sparsebit *s)\n{\n\tstruct node *nodep1, *nodep2;\n\n\t \n\tassert(sparsebit_any_clear(s));\n\n\t \n\tnodep1 = node_first(s);\n\tif (!nodep1 || nodep1->idx > 0)\n\t\treturn 0;\n\n\t \n\tif (nodep1->mask != ~(mask_t) 0)\n\t\treturn node_first_clear(nodep1, 0);\n\n\t \n\tnodep2 = node_next(s, nodep1);\n\tif (!nodep2) {\n\t\t \n\t\tassert(nodep1->mask == ~(mask_t) 0);\n\t\tassert(nodep1->idx + MASK_BITS + nodep1->num_after != (sparsebit_idx_t) 0);\n\t\treturn nodep1->idx + MASK_BITS + nodep1->num_after;\n\t}\n\n\t \n\tif (nodep1->idx + MASK_BITS + nodep1->num_after != nodep2->idx)\n\t\treturn nodep1->idx + MASK_BITS + nodep1->num_after;\n\n\t \n\treturn node_first_clear(nodep2, 0);\n}\n\n \nsparsebit_idx_t sparsebit_next_set(struct sparsebit *s,\n\tsparsebit_idx_t prev)\n{\n\tsparsebit_idx_t lowest_possible = prev + 1;\n\tsparsebit_idx_t start;\n\tstruct node *nodep;\n\n\t \n\tif (lowest_possible == 0)\n\t\treturn 0;\n\n\t \n\tstruct node *candidate = NULL;\n\n\t \n\tbool contains = false;\n\n\t \n\tfor (nodep = s->root; nodep;) {\n\t\tif ((nodep->idx + MASK_BITS + nodep->num_after - 1)\n\t\t\t>= lowest_possible) {\n\t\t\tcandidate = nodep;\n\t\t\tif (candidate->idx <= lowest_possible) {\n\t\t\t\tcontains = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnodep = nodep->left;\n\t\t} else {\n\t\t\tnodep = nodep->right;\n\t\t}\n\t}\n\tif (!candidate)\n\t\treturn 0;\n\n\tassert(candidate->mask != 0);\n\n\t \n\tif (!contains) {\n\t\t \n\t\tassert(candidate->idx > lowest_possible);\n\n\t\treturn node_first_set(candidate, 0);\n\t}\n\n\t \n\tstart = lowest_possible - candidate->idx;\n\n\tif (start < MASK_BITS && candidate->mask >= (1 << start))\n\t\treturn node_first_set(candidate, start);\n\n\tif (candidate->num_after) {\n\t\tsparsebit_idx_t first_num_after_idx = candidate->idx + MASK_BITS;\n\n\t\treturn lowest_possible < first_num_after_idx\n\t\t\t? first_num_after_idx : lowest_possible;\n\t}\n\n\t \n\tcandidate = node_next(s, candidate);\n\tif (!candidate)\n\t\treturn 0;\n\n\treturn node_first_set(candidate, 0);\n}\n\n \nsparsebit_idx_t sparsebit_next_clear(struct sparsebit *s,\n\tsparsebit_idx_t prev)\n{\n\tsparsebit_idx_t lowest_possible = prev + 1;\n\tsparsebit_idx_t idx;\n\tstruct node *nodep1, *nodep2;\n\n\t \n\tif (lowest_possible == 0)\n\t\treturn 0;\n\n\t \n\tnodep1 = node_find(s, lowest_possible);\n\tif (!nodep1)\n\t\treturn lowest_possible;\n\n\t \n\tfor (idx = lowest_possible - nodep1->idx; idx < MASK_BITS; idx++)\n\t\tif (!(nodep1->mask & (1 << idx)))\n\t\t\treturn nodep1->idx + idx;\n\n\t \n\tnodep2 = node_next(s, nodep1);\n\tif (!nodep2)\n\t\treturn nodep1->idx + MASK_BITS + nodep1->num_after;\n\n\t \n\tif (nodep1->idx + MASK_BITS + nodep1->num_after != nodep2->idx)\n\t\treturn nodep1->idx + MASK_BITS + nodep1->num_after;\n\n\t \n\treturn node_first_clear(nodep2, 0);\n}\n\n \nsparsebit_idx_t sparsebit_next_set_num(struct sparsebit *s,\n\tsparsebit_idx_t start, sparsebit_num_t num)\n{\n\tsparsebit_idx_t idx;\n\n\tassert(num >= 1);\n\n\tfor (idx = sparsebit_next_set(s, start);\n\t\tidx != 0 && idx + num - 1 >= idx;\n\t\tidx = sparsebit_next_set(s, idx)) {\n\t\tassert(sparsebit_is_set(s, idx));\n\n\t\t \n\t\tif (sparsebit_is_set_num(s, idx, num))\n\t\t\treturn idx;\n\n\t\t \n\t\tidx = sparsebit_next_clear(s, idx);\n\t\tif (idx == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nsparsebit_idx_t sparsebit_next_clear_num(struct sparsebit *s,\n\tsparsebit_idx_t start, sparsebit_num_t num)\n{\n\tsparsebit_idx_t idx;\n\n\tassert(num >= 1);\n\n\tfor (idx = sparsebit_next_clear(s, start);\n\t\tidx != 0 && idx + num - 1 >= idx;\n\t\tidx = sparsebit_next_clear(s, idx)) {\n\t\tassert(sparsebit_is_clear(s, idx));\n\n\t\t \n\t\tif (sparsebit_is_clear_num(s, idx, num))\n\t\t\treturn idx;\n\n\t\t \n\t\tidx = sparsebit_next_set(s, idx);\n\t\tif (idx == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nvoid sparsebit_set_num(struct sparsebit *s,\n\tsparsebit_idx_t start, sparsebit_num_t num)\n{\n\tstruct node *nodep, *next;\n\tunsigned int n1;\n\tsparsebit_idx_t idx;\n\tsparsebit_num_t n;\n\tsparsebit_idx_t middle_start, middle_end;\n\n\tassert(num > 0);\n\tassert(start + num - 1 >= start);\n\n\t \n\tfor (idx = start, n = num; n > 0 && idx % MASK_BITS != 0; idx++, n--)\n\t\tbit_set(s, idx);\n\n\t \n\tmiddle_start = idx;\n\tmiddle_end = middle_start + (n & -MASK_BITS) - 1;\n\tif (n >= MASK_BITS) {\n\t\tnodep = node_split(s, middle_start);\n\n\t\t \n\t\tif (middle_end + 1 > middle_end)\n\t\t\t(void) node_split(s, middle_end + 1);\n\n\t\t \n\t\tfor (next = node_next(s, nodep);\n\t\t\tnext && (next->idx < middle_end);\n\t\t\tnext = node_next(s, nodep)) {\n\t\t\tassert(next->idx + MASK_BITS + next->num_after - 1 <= middle_end);\n\t\t\tnode_rm(s, next);\n\t\t\tnext = NULL;\n\t\t}\n\n\t\t \n\t\tfor (n1 = 0; n1 < MASK_BITS; n1++) {\n\t\t\tif (!(nodep->mask & (1 << n1))) {\n\t\t\t\tnodep->mask |= 1 << n1;\n\t\t\t\ts->num_set++;\n\t\t\t}\n\t\t}\n\n\t\ts->num_set -= nodep->num_after;\n\t\tnodep->num_after = middle_end - middle_start + 1 - MASK_BITS;\n\t\ts->num_set += nodep->num_after;\n\n\t\tnode_reduce(s, nodep);\n\t}\n\tidx = middle_end + 1;\n\tn -= middle_end - middle_start + 1;\n\n\t \n\tassert(n < MASK_BITS);\n\tfor (; n > 0; idx++, n--)\n\t\tbit_set(s, idx);\n}\n\n \nvoid sparsebit_clear_num(struct sparsebit *s,\n\tsparsebit_idx_t start, sparsebit_num_t num)\n{\n\tstruct node *nodep, *next;\n\tunsigned int n1;\n\tsparsebit_idx_t idx;\n\tsparsebit_num_t n;\n\tsparsebit_idx_t middle_start, middle_end;\n\n\tassert(num > 0);\n\tassert(start + num - 1 >= start);\n\n\t \n\tfor (idx = start, n = num; n > 0 && idx % MASK_BITS != 0; idx++, n--)\n\t\tbit_clear(s, idx);\n\n\t \n\tmiddle_start = idx;\n\tmiddle_end = middle_start + (n & -MASK_BITS) - 1;\n\tif (n >= MASK_BITS) {\n\t\tnodep = node_split(s, middle_start);\n\n\t\t \n\t\tif (middle_end + 1 > middle_end)\n\t\t\t(void) node_split(s, middle_end + 1);\n\n\t\t \n\t\tfor (next = node_next(s, nodep);\n\t\t\tnext && (next->idx < middle_end);\n\t\t\tnext = node_next(s, nodep)) {\n\t\t\tassert(next->idx + MASK_BITS + next->num_after - 1 <= middle_end);\n\t\t\tnode_rm(s, next);\n\t\t\tnext = NULL;\n\t\t}\n\n\t\t \n\t\tfor (n1 = 0; n1 < MASK_BITS; n1++) {\n\t\t\tif (nodep->mask & (1 << n1)) {\n\t\t\t\tnodep->mask &= ~(1 << n1);\n\t\t\t\ts->num_set--;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ts->num_set -= nodep->num_after;\n\t\tnodep->num_after = 0;\n\n\t\t \n\t\tnode_reduce(s, nodep);\n\t\tnodep = NULL;\n\t}\n\tidx = middle_end + 1;\n\tn -= middle_end - middle_start + 1;\n\n\t \n\tassert(n < MASK_BITS);\n\tfor (; n > 0; idx++, n--)\n\t\tbit_clear(s, idx);\n}\n\n \nvoid sparsebit_set(struct sparsebit *s, sparsebit_idx_t idx)\n{\n\tsparsebit_set_num(s, idx, 1);\n}\n\n \nvoid sparsebit_clear(struct sparsebit *s, sparsebit_idx_t idx)\n{\n\tsparsebit_clear_num(s, idx, 1);\n}\n\n \nvoid sparsebit_set_all(struct sparsebit *s)\n{\n\tsparsebit_set(s, 0);\n\tsparsebit_set_num(s, 1, ~(sparsebit_idx_t) 0);\n\tassert(sparsebit_all_set(s));\n}\n\n \nvoid sparsebit_clear_all(struct sparsebit *s)\n{\n\tsparsebit_clear(s, 0);\n\tsparsebit_clear_num(s, 1, ~(sparsebit_idx_t) 0);\n\tassert(!sparsebit_any_set(s));\n}\n\nstatic size_t display_range(FILE *stream, sparsebit_idx_t low,\n\tsparsebit_idx_t high, bool prepend_comma_space)\n{\n\tchar *fmt_str;\n\tsize_t sz;\n\n\t \n\tif (low == high)\n\t\tfmt_str = prepend_comma_space ? \", 0x%lx\" : \"0x%lx\";\n\telse\n\t\tfmt_str = prepend_comma_space ? \", 0x%lx:0x%lx\" : \"0x%lx:0x%lx\";\n\n\t \n\tif (!stream)\n\t\tsz = snprintf(NULL, 0, fmt_str, low, high);\n\telse\n\t\tsz = fprintf(stream, fmt_str, low, high);\n\n\treturn sz;\n}\n\n\n \nvoid sparsebit_dump(FILE *stream, struct sparsebit *s,\n\tunsigned int indent)\n{\n\tsize_t current_line_len = 0;\n\tsize_t sz;\n\tstruct node *nodep;\n\n\tif (!sparsebit_any_set(s))\n\t\treturn;\n\n\t \n\tfprintf(stream, \"%*s\", indent, \"\");\n\n\t \n\tfor (nodep = node_first(s); nodep; nodep = node_next(s, nodep)) {\n\t\tunsigned int n1;\n\t\tsparsebit_idx_t low, high;\n\n\t\t \n\t\tfor (n1 = 0; n1 < MASK_BITS; n1++) {\n\t\t\tif (nodep->mask & (1 << n1)) {\n\t\t\t\tlow = high = nodep->idx + n1;\n\n\t\t\t\tfor (; n1 < MASK_BITS; n1++) {\n\t\t\t\t\tif (nodep->mask & (1 << n1))\n\t\t\t\t\t\thigh = nodep->idx + n1;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ((n1 == MASK_BITS) && nodep->num_after)\n\t\t\t\t\thigh += nodep->num_after;\n\n\t\t\t\t \n\t\t\t\tsz = display_range(NULL, low, high,\n\t\t\t\t\tcurrent_line_len != 0);\n\n\t\t\t\t \n\t\t\t\tif (current_line_len + sz > DUMP_LINE_MAX) {\n\t\t\t\t\tfputs(\"\\n\", stream);\n\t\t\t\t\tfprintf(stream, \"%*s\", indent, \"\");\n\t\t\t\t\tcurrent_line_len = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tsz = display_range(stream, low, high,\n\t\t\t\t\tcurrent_line_len != 0);\n\t\t\t\tcurrent_line_len += sz;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!(nodep->mask & (1 << (MASK_BITS - 1))) && nodep->num_after) {\n\t\t\tlow = nodep->idx + MASK_BITS;\n\t\t\thigh = nodep->idx + MASK_BITS + nodep->num_after - 1;\n\n\t\t\t \n\t\t\tsz = display_range(NULL, low, high,\n\t\t\t\tcurrent_line_len != 0);\n\n\t\t\t \n\t\t\tif (current_line_len + sz > DUMP_LINE_MAX) {\n\t\t\t\tfputs(\"\\n\", stream);\n\t\t\t\tfprintf(stream, \"%*s\", indent, \"\");\n\t\t\t\tcurrent_line_len = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tsz = display_range(stream, low, high,\n\t\t\t\tcurrent_line_len != 0);\n\t\t\tcurrent_line_len += sz;\n\t\t}\n\t}\n\tfputs(\"\\n\", stream);\n}\n\n \nvoid sparsebit_validate_internal(struct sparsebit *s)\n{\n\tbool error_detected = false;\n\tstruct node *nodep, *prev = NULL;\n\tsparsebit_num_t total_bits_set = 0;\n\tunsigned int n1;\n\n\t \n\tfor (nodep = node_first(s); nodep;\n\t\tprev = nodep, nodep = node_next(s, nodep)) {\n\n\t\t \n\t\tfor (n1 = 0; n1 < MASK_BITS; n1++)\n\t\t\tif (nodep->mask & (1 << n1))\n\t\t\t\ttotal_bits_set++;\n\n\t\ttotal_bits_set += nodep->num_after;\n\n\t\t \n\t\tif (nodep->mask == 0) {\n\t\t\tfprintf(stderr, \"Node mask of zero, \"\n\t\t\t\t\"nodep: %p nodep->mask: 0x%x\",\n\t\t\t\tnodep, nodep->mask);\n\t\t\terror_detected = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (nodep->num_after\n\t\t\t> (~(sparsebit_num_t) 0) - MASK_BITS + 1) {\n\t\t\tfprintf(stderr, \"num_after too large, \"\n\t\t\t\t\"nodep: %p nodep->num_after: 0x%lx\",\n\t\t\t\tnodep, nodep->num_after);\n\t\t\terror_detected = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (nodep->idx % MASK_BITS) {\n\t\t\tfprintf(stderr, \"Node index not divisible by \"\n\t\t\t\t\"mask size,\\n\"\n\t\t\t\t\"  nodep: %p nodep->idx: 0x%lx \"\n\t\t\t\t\"MASK_BITS: %lu\\n\",\n\t\t\t\tnodep, nodep->idx, MASK_BITS);\n\t\t\terror_detected = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((nodep->idx + MASK_BITS + nodep->num_after - 1) < nodep->idx) {\n\t\t\tfprintf(stderr, \"Bits described by node wrap \"\n\t\t\t\t\"beyond highest supported index,\\n\"\n\t\t\t\t\"  nodep: %p nodep->idx: 0x%lx\\n\"\n\t\t\t\t\"  MASK_BITS: %lu nodep->num_after: 0x%lx\",\n\t\t\t\tnodep, nodep->idx, MASK_BITS, nodep->num_after);\n\t\t\terror_detected = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (nodep->left) {\n\t\t\tif (nodep->left->parent != nodep) {\n\t\t\t\tfprintf(stderr, \"Left child parent pointer \"\n\t\t\t\t\t\"doesn't point to this node,\\n\"\n\t\t\t\t\t\"  nodep: %p nodep->left: %p \"\n\t\t\t\t\t\"nodep->left->parent: %p\",\n\t\t\t\t\tnodep, nodep->left,\n\t\t\t\t\tnodep->left->parent);\n\t\t\t\terror_detected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (nodep->right) {\n\t\t\tif (nodep->right->parent != nodep) {\n\t\t\t\tfprintf(stderr, \"Right child parent pointer \"\n\t\t\t\t\t\"doesn't point to this node,\\n\"\n\t\t\t\t\t\"  nodep: %p nodep->right: %p \"\n\t\t\t\t\t\"nodep->right->parent: %p\",\n\t\t\t\t\tnodep, nodep->right,\n\t\t\t\t\tnodep->right->parent);\n\t\t\t\terror_detected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!nodep->parent) {\n\t\t\tif (s->root != nodep) {\n\t\t\t\tfprintf(stderr, \"Unexpected root node, \"\n\t\t\t\t\t\"s->root: %p nodep: %p\",\n\t\t\t\t\ts->root, nodep);\n\t\t\t\terror_detected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (prev) {\n\t\t\t \n\t\t\tif (prev->idx >= nodep->idx) {\n\t\t\t\tfprintf(stderr, \"Previous node index \"\n\t\t\t\t\t\">= current node index,\\n\"\n\t\t\t\t\t\"  prev: %p prev->idx: 0x%lx\\n\"\n\t\t\t\t\t\"  nodep: %p nodep->idx: 0x%lx\",\n\t\t\t\t\tprev, prev->idx, nodep, nodep->idx);\n\t\t\t\terror_detected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((prev->idx + MASK_BITS + prev->num_after - 1)\n\t\t\t\t>= nodep->idx) {\n\t\t\t\tfprintf(stderr, \"Previous node bit range \"\n\t\t\t\t\t\"overlap with current node bit range,\\n\"\n\t\t\t\t\t\"  prev: %p prev->idx: 0x%lx \"\n\t\t\t\t\t\"prev->num_after: 0x%lx\\n\"\n\t\t\t\t\t\"  nodep: %p nodep->idx: 0x%lx \"\n\t\t\t\t\t\"nodep->num_after: 0x%lx\\n\"\n\t\t\t\t\t\"  MASK_BITS: %lu\",\n\t\t\t\t\tprev, prev->idx, prev->num_after,\n\t\t\t\t\tnodep, nodep->idx, nodep->num_after,\n\t\t\t\t\tMASK_BITS);\n\t\t\t\terror_detected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (nodep->mask == ~(mask_t) 0 &&\n\t\t\t    prev->idx + MASK_BITS + prev->num_after == nodep->idx) {\n\t\t\t\tfprintf(stderr, \"Current node has mask with \"\n\t\t\t\t\t\"all bits set and is adjacent to the \"\n\t\t\t\t\t\"previous node,\\n\"\n\t\t\t\t\t\"  prev: %p prev->idx: 0x%lx \"\n\t\t\t\t\t\"prev->num_after: 0x%lx\\n\"\n\t\t\t\t\t\"  nodep: %p nodep->idx: 0x%lx \"\n\t\t\t\t\t\"nodep->num_after: 0x%lx\\n\"\n\t\t\t\t\t\"  MASK_BITS: %lu\",\n\t\t\t\t\tprev, prev->idx, prev->num_after,\n\t\t\t\t\tnodep, nodep->idx, nodep->num_after,\n\t\t\t\t\tMASK_BITS);\n\n\t\t\t\terror_detected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!error_detected) {\n\t\t \n\t\tif (s->num_set != total_bits_set) {\n\t\t\tfprintf(stderr, \"Number of bits set mismatch,\\n\"\n\t\t\t\t\"  s->num_set: 0x%lx total_bits_set: 0x%lx\",\n\t\t\t\ts->num_set, total_bits_set);\n\n\t\t\terror_detected = true;\n\t\t}\n\t}\n\n\tif (error_detected) {\n\t\tfputs(\"  dump_internal:\\n\", stderr);\n\t\tsparsebit_dump_internal(stderr, s, 4);\n\t\tabort();\n\t}\n}\n\n\n#ifdef FUZZ\n \n\n#include <stdlib.h>\n\nstruct range {\n\tsparsebit_idx_t first, last;\n\tbool set;\n};\n\nstruct sparsebit *s;\nstruct range ranges[1000];\nint num_ranges;\n\nstatic bool get_value(sparsebit_idx_t idx)\n{\n\tint i;\n\n\tfor (i = num_ranges; --i >= 0; )\n\t\tif (ranges[i].first <= idx && idx <= ranges[i].last)\n\t\t\treturn ranges[i].set;\n\n\treturn false;\n}\n\nstatic void operate(int code, sparsebit_idx_t first, sparsebit_idx_t last)\n{\n\tsparsebit_num_t num;\n\tsparsebit_idx_t next;\n\n\tif (first < last) {\n\t\tnum = last - first + 1;\n\t} else {\n\t\tnum = first - last + 1;\n\t\tfirst = last;\n\t\tlast = first + num - 1;\n\t}\n\n\tswitch (code) {\n\tcase 0:\n\t\tsparsebit_set(s, first);\n\t\tassert(sparsebit_is_set(s, first));\n\t\tassert(!sparsebit_is_clear(s, first));\n\t\tassert(sparsebit_any_set(s));\n\t\tassert(!sparsebit_all_clear(s));\n\t\tif (get_value(first))\n\t\t\treturn;\n\t\tif (num_ranges == 1000)\n\t\t\texit(0);\n\t\tranges[num_ranges++] = (struct range)\n\t\t\t{ .first = first, .last = first, .set = true };\n\t\tbreak;\n\tcase 1:\n\t\tsparsebit_clear(s, first);\n\t\tassert(!sparsebit_is_set(s, first));\n\t\tassert(sparsebit_is_clear(s, first));\n\t\tassert(sparsebit_any_clear(s));\n\t\tassert(!sparsebit_all_set(s));\n\t\tif (!get_value(first))\n\t\t\treturn;\n\t\tif (num_ranges == 1000)\n\t\t\texit(0);\n\t\tranges[num_ranges++] = (struct range)\n\t\t\t{ .first = first, .last = first, .set = false };\n\t\tbreak;\n\tcase 2:\n\t\tassert(sparsebit_is_set(s, first) == get_value(first));\n\t\tassert(sparsebit_is_clear(s, first) == !get_value(first));\n\t\tbreak;\n\tcase 3:\n\t\tif (sparsebit_any_set(s))\n\t\t\tassert(get_value(sparsebit_first_set(s)));\n\t\tif (sparsebit_any_clear(s))\n\t\t\tassert(!get_value(sparsebit_first_clear(s)));\n\t\tsparsebit_set_all(s);\n\t\tassert(!sparsebit_any_clear(s));\n\t\tassert(sparsebit_all_set(s));\n\t\tnum_ranges = 0;\n\t\tranges[num_ranges++] = (struct range)\n\t\t\t{ .first = 0, .last = ~(sparsebit_idx_t)0, .set = true };\n\t\tbreak;\n\tcase 4:\n\t\tif (sparsebit_any_set(s))\n\t\t\tassert(get_value(sparsebit_first_set(s)));\n\t\tif (sparsebit_any_clear(s))\n\t\t\tassert(!get_value(sparsebit_first_clear(s)));\n\t\tsparsebit_clear_all(s);\n\t\tassert(!sparsebit_any_set(s));\n\t\tassert(sparsebit_all_clear(s));\n\t\tnum_ranges = 0;\n\t\tbreak;\n\tcase 5:\n\t\tnext = sparsebit_next_set(s, first);\n\t\tassert(next == 0 || next > first);\n\t\tassert(next == 0 || get_value(next));\n\t\tbreak;\n\tcase 6:\n\t\tnext = sparsebit_next_clear(s, first);\n\t\tassert(next == 0 || next > first);\n\t\tassert(next == 0 || !get_value(next));\n\t\tbreak;\n\tcase 7:\n\t\tnext = sparsebit_next_clear(s, first);\n\t\tif (sparsebit_is_set_num(s, first, num)) {\n\t\t\tassert(next == 0 || next > last);\n\t\t\tif (first)\n\t\t\t\tnext = sparsebit_next_set(s, first - 1);\n\t\t\telse if (sparsebit_any_set(s))\n\t\t\t\tnext = sparsebit_first_set(s);\n\t\t\telse\n\t\t\t\treturn;\n\t\t\tassert(next == first);\n\t\t} else {\n\t\t\tassert(sparsebit_is_clear(s, first) || next <= last);\n\t\t}\n\t\tbreak;\n\tcase 8:\n\t\tnext = sparsebit_next_set(s, first);\n\t\tif (sparsebit_is_clear_num(s, first, num)) {\n\t\t\tassert(next == 0 || next > last);\n\t\t\tif (first)\n\t\t\t\tnext = sparsebit_next_clear(s, first - 1);\n\t\t\telse if (sparsebit_any_clear(s))\n\t\t\t\tnext = sparsebit_first_clear(s);\n\t\t\telse\n\t\t\t\treturn;\n\t\t\tassert(next == first);\n\t\t} else {\n\t\t\tassert(sparsebit_is_set(s, first) || next <= last);\n\t\t}\n\t\tbreak;\n\tcase 9:\n\t\tsparsebit_set_num(s, first, num);\n\t\tassert(sparsebit_is_set_num(s, first, num));\n\t\tassert(!sparsebit_is_clear_num(s, first, num));\n\t\tassert(sparsebit_any_set(s));\n\t\tassert(!sparsebit_all_clear(s));\n\t\tif (num_ranges == 1000)\n\t\t\texit(0);\n\t\tranges[num_ranges++] = (struct range)\n\t\t\t{ .first = first, .last = last, .set = true };\n\t\tbreak;\n\tcase 10:\n\t\tsparsebit_clear_num(s, first, num);\n\t\tassert(!sparsebit_is_set_num(s, first, num));\n\t\tassert(sparsebit_is_clear_num(s, first, num));\n\t\tassert(sparsebit_any_clear(s));\n\t\tassert(!sparsebit_all_set(s));\n\t\tif (num_ranges == 1000)\n\t\t\texit(0);\n\t\tranges[num_ranges++] = (struct range)\n\t\t\t{ .first = first, .last = last, .set = false };\n\t\tbreak;\n\tcase 11:\n\t\tsparsebit_validate_internal(s);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nunsigned char get8(void)\n{\n\tint ch;\n\n\tch = getchar();\n\tif (ch == EOF)\n\t\texit(0);\n\treturn ch;\n}\n\nuint64_t get64(void)\n{\n\tuint64_t x;\n\n\tx = get8();\n\tx = (x << 8) | get8();\n\tx = (x << 8) | get8();\n\tx = (x << 8) | get8();\n\tx = (x << 8) | get8();\n\tx = (x << 8) | get8();\n\tx = (x << 8) | get8();\n\treturn (x << 8) | get8();\n}\n\nint main(void)\n{\n\ts = sparsebit_alloc();\n\tfor (;;) {\n\t\tuint8_t op = get8() & 0xf;\n\t\tuint64_t first = get64();\n\t\tuint64_t last = get64();\n\n\t\toperate(op, first, last);\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}