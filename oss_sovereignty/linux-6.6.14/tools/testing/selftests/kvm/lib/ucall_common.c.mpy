{
  "module_name": "ucall_common.c",
  "hash_id": "a62f27a0a1a6ee0194a9114aef282182c252bf9a066b95c940cc46c005f3ea6b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/ucall_common.c",
  "human_readable_source": "\n#include \"kvm_util.h\"\n#include \"linux/types.h\"\n#include \"linux/bitmap.h\"\n#include \"linux/atomic.h\"\n\n#define GUEST_UCALL_FAILED -1\n\nstruct ucall_header {\n\tDECLARE_BITMAP(in_use, KVM_MAX_VCPUS);\n\tstruct ucall ucalls[KVM_MAX_VCPUS];\n};\n\nint ucall_nr_pages_required(uint64_t page_size)\n{\n\treturn align_up(sizeof(struct ucall_header), page_size) / page_size;\n}\n\n \nstatic struct ucall_header *ucall_pool;\n\nvoid ucall_init(struct kvm_vm *vm, vm_paddr_t mmio_gpa)\n{\n\tstruct ucall_header *hdr;\n\tstruct ucall *uc;\n\tvm_vaddr_t vaddr;\n\tint i;\n\n\tvaddr = __vm_vaddr_alloc(vm, sizeof(*hdr), KVM_UTIL_MIN_VADDR, MEM_REGION_DATA);\n\thdr = (struct ucall_header *)addr_gva2hva(vm, vaddr);\n\tmemset(hdr, 0, sizeof(*hdr));\n\n\tfor (i = 0; i < KVM_MAX_VCPUS; ++i) {\n\t\tuc = &hdr->ucalls[i];\n\t\tuc->hva = uc;\n\t}\n\n\twrite_guest_global(vm, ucall_pool, (struct ucall_header *)vaddr);\n\n\tucall_arch_init(vm, mmio_gpa);\n}\n\nstatic struct ucall *ucall_alloc(void)\n{\n\tstruct ucall *uc;\n\tint i;\n\n\tif (!ucall_pool)\n\t\tgoto ucall_failed;\n\n\tfor (i = 0; i < KVM_MAX_VCPUS; ++i) {\n\t\tif (!test_and_set_bit(i, ucall_pool->in_use)) {\n\t\t\tuc = &ucall_pool->ucalls[i];\n\t\t\tmemset(uc->args, 0, sizeof(uc->args));\n\t\t\treturn uc;\n\t\t}\n\t}\n\nucall_failed:\n\t \n\tucall_arch_do_ucall(GUEST_UCALL_FAILED);\n\treturn NULL;\n}\n\nstatic void ucall_free(struct ucall *uc)\n{\n\t \n\tclear_bit(uc - ucall_pool->ucalls, ucall_pool->in_use);\n}\n\nvoid ucall_assert(uint64_t cmd, const char *exp, const char *file,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct ucall *uc;\n\tva_list va;\n\n\tuc = ucall_alloc();\n\tuc->cmd = cmd;\n\n\tWRITE_ONCE(uc->args[GUEST_ERROR_STRING], (uint64_t)(exp));\n\tWRITE_ONCE(uc->args[GUEST_FILE], (uint64_t)(file));\n\tWRITE_ONCE(uc->args[GUEST_LINE], line);\n\n\tva_start(va, fmt);\n\tguest_vsnprintf(uc->buffer, UCALL_BUFFER_LEN, fmt, va);\n\tva_end(va);\n\n\tucall_arch_do_ucall((vm_vaddr_t)uc->hva);\n\n\tucall_free(uc);\n}\n\nvoid ucall_fmt(uint64_t cmd, const char *fmt, ...)\n{\n\tstruct ucall *uc;\n\tva_list va;\n\n\tuc = ucall_alloc();\n\tuc->cmd = cmd;\n\n\tva_start(va, fmt);\n\tguest_vsnprintf(uc->buffer, UCALL_BUFFER_LEN, fmt, va);\n\tva_end(va);\n\n\tucall_arch_do_ucall((vm_vaddr_t)uc->hva);\n\n\tucall_free(uc);\n}\n\nvoid ucall(uint64_t cmd, int nargs, ...)\n{\n\tstruct ucall *uc;\n\tva_list va;\n\tint i;\n\n\tuc = ucall_alloc();\n\n\tWRITE_ONCE(uc->cmd, cmd);\n\n\tnargs = min(nargs, UCALL_MAX_ARGS);\n\n\tva_start(va, nargs);\n\tfor (i = 0; i < nargs; ++i)\n\t\tWRITE_ONCE(uc->args[i], va_arg(va, uint64_t));\n\tva_end(va);\n\n\tucall_arch_do_ucall((vm_vaddr_t)uc->hva);\n\n\tucall_free(uc);\n}\n\nuint64_t get_ucall(struct kvm_vcpu *vcpu, struct ucall *uc)\n{\n\tstruct ucall ucall;\n\tvoid *addr;\n\n\tif (!uc)\n\t\tuc = &ucall;\n\n\taddr = ucall_arch_get_ucall(vcpu);\n\tif (addr) {\n\t\tTEST_ASSERT(addr != (void *)GUEST_UCALL_FAILED,\n\t\t\t    \"Guest failed to allocate ucall struct\");\n\n\t\tmemcpy(uc, addr, sizeof(*uc));\n\t\tvcpu_run_complete_io(vcpu);\n\t} else {\n\t\tmemset(uc, 0, sizeof(*uc));\n\t}\n\n\treturn uc->cmd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}