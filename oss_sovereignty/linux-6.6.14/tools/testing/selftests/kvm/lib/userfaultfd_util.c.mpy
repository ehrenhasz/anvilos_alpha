{
  "module_name": "userfaultfd_util.c",
  "hash_id": "5ee83c1c9e0645c7905fc5635ccd3f88ce3fb6417a2ee74e58e7e2082970df37",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/userfaultfd_util.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <poll.h>\n#include <pthread.h>\n#include <linux/userfaultfd.h>\n#include <sys/syscall.h>\n\n#include \"kvm_util.h\"\n#include \"test_util.h\"\n#include \"memstress.h\"\n#include \"userfaultfd_util.h\"\n\n#ifdef __NR_userfaultfd\n\nstatic void *uffd_handler_thread_fn(void *arg)\n{\n\tstruct uffd_desc *uffd_desc = (struct uffd_desc *)arg;\n\tint uffd = uffd_desc->uffd;\n\tint pipefd = uffd_desc->pipefds[0];\n\tuseconds_t delay = uffd_desc->delay;\n\tint64_t pages = 0;\n\tstruct timespec start;\n\tstruct timespec ts_diff;\n\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\twhile (1) {\n\t\tstruct uffd_msg msg;\n\t\tstruct pollfd pollfd[2];\n\t\tchar tmp_chr;\n\t\tint r;\n\n\t\tpollfd[0].fd = uffd;\n\t\tpollfd[0].events = POLLIN;\n\t\tpollfd[1].fd = pipefd;\n\t\tpollfd[1].events = POLLIN;\n\n\t\tr = poll(pollfd, 2, -1);\n\t\tswitch (r) {\n\t\tcase -1:\n\t\t\tpr_info(\"poll err\");\n\t\t\tcontinue;\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"Polling uffd returned %d\", r);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (pollfd[0].revents & POLLERR) {\n\t\t\tpr_info(\"uffd revents has POLLERR\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (pollfd[1].revents & POLLIN) {\n\t\t\tr = read(pollfd[1].fd, &tmp_chr, 1);\n\t\t\tTEST_ASSERT(r == 1,\n\t\t\t\t    \"Error reading pipefd in UFFD thread\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(pollfd[0].revents & POLLIN))\n\t\t\tcontinue;\n\n\t\tr = read(uffd, &msg, sizeof(msg));\n\t\tif (r == -1) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"Read of uffd got errno %d\\n\", errno);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (r != sizeof(msg)) {\n\t\t\tpr_info(\"Read on uffd returned unexpected size: %d bytes\", r);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!(msg.event & UFFD_EVENT_PAGEFAULT))\n\t\t\tcontinue;\n\n\t\tif (delay)\n\t\t\tusleep(delay);\n\t\tr = uffd_desc->handler(uffd_desc->uffd_mode, uffd, &msg);\n\t\tif (r < 0)\n\t\t\treturn NULL;\n\t\tpages++;\n\t}\n\n\tts_diff = timespec_elapsed(start);\n\tPER_VCPU_DEBUG(\"userfaulted %ld pages over %ld.%.9lds. (%f/sec)\\n\",\n\t\t       pages, ts_diff.tv_sec, ts_diff.tv_nsec,\n\t\t       pages / ((double)ts_diff.tv_sec + (double)ts_diff.tv_nsec / NSEC_PER_SEC));\n\n\treturn NULL;\n}\n\nstruct uffd_desc *uffd_setup_demand_paging(int uffd_mode, useconds_t delay,\n\t\t\t\t\t   void *hva, uint64_t len,\n\t\t\t\t\t   uffd_handler_t handler)\n{\n\tstruct uffd_desc *uffd_desc;\n\tbool is_minor = (uffd_mode == UFFDIO_REGISTER_MODE_MINOR);\n\tint uffd;\n\tstruct uffdio_api uffdio_api;\n\tstruct uffdio_register uffdio_register;\n\tuint64_t expected_ioctls = ((uint64_t) 1) << _UFFDIO_COPY;\n\tint ret;\n\n\tPER_PAGE_DEBUG(\"Userfaultfd %s mode, faults resolved with %s\\n\",\n\t\t       is_minor ? \"MINOR\" : \"MISSING\",\n\t\t       is_minor ? \"UFFDIO_CONINUE\" : \"UFFDIO_COPY\");\n\n\tuffd_desc = malloc(sizeof(struct uffd_desc));\n\tTEST_ASSERT(uffd_desc, \"malloc failed\");\n\n\t \n\tif (is_minor)\n\t\texpected_ioctls = ((uint64_t) 1) << _UFFDIO_CONTINUE;\n\n\tuffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\tTEST_ASSERT(uffd >= 0, \"uffd creation failed, errno: %d\", errno);\n\n\tuffdio_api.api = UFFD_API;\n\tuffdio_api.features = 0;\n\tTEST_ASSERT(ioctl(uffd, UFFDIO_API, &uffdio_api) != -1,\n\t\t    \"ioctl UFFDIO_API failed: %\" PRIu64,\n\t\t    (uint64_t)uffdio_api.api);\n\n\tuffdio_register.range.start = (uint64_t)hva;\n\tuffdio_register.range.len = len;\n\tuffdio_register.mode = uffd_mode;\n\tTEST_ASSERT(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) != -1,\n\t\t    \"ioctl UFFDIO_REGISTER failed\");\n\tTEST_ASSERT((uffdio_register.ioctls & expected_ioctls) ==\n\t\t    expected_ioctls, \"missing userfaultfd ioctls\");\n\n\tret = pipe2(uffd_desc->pipefds, O_CLOEXEC | O_NONBLOCK);\n\tTEST_ASSERT(!ret, \"Failed to set up pipefd\");\n\n\tuffd_desc->uffd_mode = uffd_mode;\n\tuffd_desc->uffd = uffd;\n\tuffd_desc->delay = delay;\n\tuffd_desc->handler = handler;\n\tpthread_create(&uffd_desc->thread, NULL, uffd_handler_thread_fn,\n\t\t       uffd_desc);\n\n\tPER_VCPU_DEBUG(\"Created uffd thread for HVA range [%p, %p)\\n\",\n\t\t       hva, hva + len);\n\n\treturn uffd_desc;\n}\n\nvoid uffd_stop_demand_paging(struct uffd_desc *uffd)\n{\n\tchar c = 0;\n\tint ret;\n\n\tret = write(uffd->pipefds[1], &c, 1);\n\tTEST_ASSERT(ret == 1, \"Unable to write to pipefd\");\n\n\tret = pthread_join(uffd->thread, NULL);\n\tTEST_ASSERT(ret == 0, \"Pthread_join failed.\");\n\n\tclose(uffd->uffd);\n\n\tclose(uffd->pipefds[1]);\n\tclose(uffd->pipefds[0]);\n\n\tfree(uffd);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}