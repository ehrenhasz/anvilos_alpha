{
  "module_name": "gic_v3.c",
  "hash_id": "066eeb8d0ae0e02b0401a3d7af3dcdbfb219e0040a8691a6ad81f2c773db8daa",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/aarch64/gic_v3.c",
  "human_readable_source": "\n \n\n#include <linux/sizes.h>\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"delay.h\"\n\n#include \"gic_v3.h\"\n#include \"gic_private.h\"\n\nstruct gicv3_data {\n\tvoid *dist_base;\n\tvoid *redist_base[GICV3_MAX_CPUS];\n\tunsigned int nr_cpus;\n\tunsigned int nr_spis;\n};\n\n#define sgi_base_from_redist(redist_base)\t(redist_base + SZ_64K)\n#define DIST_BIT\t\t\t\t(1U << 31)\n\nenum gicv3_intid_range {\n\tSGI_RANGE,\n\tPPI_RANGE,\n\tSPI_RANGE,\n\tINVALID_RANGE,\n};\n\nstatic struct gicv3_data gicv3_data;\n\nstatic void gicv3_gicd_wait_for_rwp(void)\n{\n\tunsigned int count = 100000;  \n\n\twhile (readl(gicv3_data.dist_base + GICD_CTLR) & GICD_CTLR_RWP) {\n\t\tGUEST_ASSERT(count--);\n\t\tudelay(10);\n\t}\n}\n\nstatic void gicv3_gicr_wait_for_rwp(void *redist_base)\n{\n\tunsigned int count = 100000;  \n\n\twhile (readl(redist_base + GICR_CTLR) & GICR_CTLR_RWP) {\n\t\tGUEST_ASSERT(count--);\n\t\tudelay(10);\n\t}\n}\n\nstatic void gicv3_wait_for_rwp(uint32_t cpu_or_dist)\n{\n\tif (cpu_or_dist & DIST_BIT)\n\t\tgicv3_gicd_wait_for_rwp();\n\telse\n\t\tgicv3_gicr_wait_for_rwp(gicv3_data.redist_base[cpu_or_dist]);\n}\n\nstatic enum gicv3_intid_range get_intid_range(unsigned int intid)\n{\n\tswitch (intid) {\n\tcase 0 ... 15:\n\t\treturn SGI_RANGE;\n\tcase 16 ... 31:\n\t\treturn PPI_RANGE;\n\tcase 32 ... 1019:\n\t\treturn SPI_RANGE;\n\t}\n\n\t \n\tGUEST_ASSERT(0);\n\n\treturn INVALID_RANGE;\n}\n\nstatic uint64_t gicv3_read_iar(void)\n{\n\tuint64_t irqstat = read_sysreg_s(SYS_ICC_IAR1_EL1);\n\n\tdsb(sy);\n\treturn irqstat;\n}\n\nstatic void gicv3_write_eoir(uint32_t irq)\n{\n\twrite_sysreg_s(irq, SYS_ICC_EOIR1_EL1);\n\tisb();\n}\n\nstatic void gicv3_write_dir(uint32_t irq)\n{\n\twrite_sysreg_s(irq, SYS_ICC_DIR_EL1);\n\tisb();\n}\n\nstatic void gicv3_set_priority_mask(uint64_t mask)\n{\n\twrite_sysreg_s(mask, SYS_ICC_PMR_EL1);\n}\n\nstatic void gicv3_set_eoi_split(bool split)\n{\n\tuint32_t val;\n\n\t \n\tval = split ? (1U << 1) : 0;\n\twrite_sysreg_s(val, SYS_ICC_CTLR_EL1);\n\tisb();\n}\n\nuint32_t gicv3_reg_readl(uint32_t cpu_or_dist, uint64_t offset)\n{\n\tvoid *base = cpu_or_dist & DIST_BIT ? gicv3_data.dist_base\n\t\t: sgi_base_from_redist(gicv3_data.redist_base[cpu_or_dist]);\n\treturn readl(base + offset);\n}\n\nvoid gicv3_reg_writel(uint32_t cpu_or_dist, uint64_t offset, uint32_t reg_val)\n{\n\tvoid *base = cpu_or_dist & DIST_BIT ? gicv3_data.dist_base\n\t\t: sgi_base_from_redist(gicv3_data.redist_base[cpu_or_dist]);\n\twritel(reg_val, base + offset);\n}\n\nuint32_t gicv3_getl_fields(uint32_t cpu_or_dist, uint64_t offset, uint32_t mask)\n{\n\treturn gicv3_reg_readl(cpu_or_dist, offset) & mask;\n}\n\nvoid gicv3_setl_fields(uint32_t cpu_or_dist, uint64_t offset,\n\t\tuint32_t mask, uint32_t reg_val)\n{\n\tuint32_t tmp = gicv3_reg_readl(cpu_or_dist, offset) & ~mask;\n\n\ttmp |= (reg_val & mask);\n\tgicv3_reg_writel(cpu_or_dist, offset, tmp);\n}\n\n \nstatic void gicv3_access_reg(uint32_t intid, uint64_t offset,\n\t\tuint32_t reg_bits, uint32_t bits_per_field,\n\t\tbool write, uint32_t *val)\n{\n\tuint32_t cpu = guest_get_vcpuid();\n\tenum gicv3_intid_range intid_range = get_intid_range(intid);\n\tuint32_t fields_per_reg, index, mask, shift;\n\tuint32_t cpu_or_dist;\n\n\tGUEST_ASSERT(bits_per_field <= reg_bits);\n\tGUEST_ASSERT(!write || *val < (1U << bits_per_field));\n\t \n\tGUEST_ASSERT(reg_bits == 32);\n\n\tfields_per_reg = reg_bits / bits_per_field;\n\tindex = intid % fields_per_reg;\n\tshift = index * bits_per_field;\n\tmask = ((1U << bits_per_field) - 1) << shift;\n\n\t \n\toffset += (intid / fields_per_reg) * (reg_bits / 8);\n\n\tcpu_or_dist = (intid_range == SPI_RANGE) ? DIST_BIT : cpu;\n\n\tif (write)\n\t\tgicv3_setl_fields(cpu_or_dist, offset, mask, *val << shift);\n\t*val = gicv3_getl_fields(cpu_or_dist, offset, mask) >> shift;\n}\n\nstatic void gicv3_write_reg(uint32_t intid, uint64_t offset,\n\t\tuint32_t reg_bits, uint32_t bits_per_field, uint32_t val)\n{\n\tgicv3_access_reg(intid, offset, reg_bits,\n\t\t\tbits_per_field, true, &val);\n}\n\nstatic uint32_t gicv3_read_reg(uint32_t intid, uint64_t offset,\n\t\tuint32_t reg_bits, uint32_t bits_per_field)\n{\n\tuint32_t val;\n\n\tgicv3_access_reg(intid, offset, reg_bits,\n\t\t\tbits_per_field, false, &val);\n\treturn val;\n}\n\nstatic void gicv3_set_priority(uint32_t intid, uint32_t prio)\n{\n\tgicv3_write_reg(intid, GICD_IPRIORITYR, 32, 8, prio);\n}\n\n \nstatic void gicv3_irq_set_config(uint32_t intid, bool is_edge)\n{\n\tuint32_t val;\n\n\t \n\tGUEST_ASSERT(get_intid_range(intid) == SPI_RANGE);\n\tval = is_edge ? 2 : 0;\n\tgicv3_write_reg(intid, GICD_ICFGR, 32, 2, val);\n}\n\nstatic void gicv3_irq_enable(uint32_t intid)\n{\n\tbool is_spi = get_intid_range(intid) == SPI_RANGE;\n\tuint32_t cpu = guest_get_vcpuid();\n\n\tgicv3_write_reg(intid, GICD_ISENABLER, 32, 1, 1);\n\tgicv3_wait_for_rwp(is_spi ? DIST_BIT : cpu);\n}\n\nstatic void gicv3_irq_disable(uint32_t intid)\n{\n\tbool is_spi = get_intid_range(intid) == SPI_RANGE;\n\tuint32_t cpu = guest_get_vcpuid();\n\n\tgicv3_write_reg(intid, GICD_ICENABLER, 32, 1, 1);\n\tgicv3_wait_for_rwp(is_spi ? DIST_BIT : cpu);\n}\n\nstatic void gicv3_irq_set_active(uint32_t intid)\n{\n\tgicv3_write_reg(intid, GICD_ISACTIVER, 32, 1, 1);\n}\n\nstatic void gicv3_irq_clear_active(uint32_t intid)\n{\n\tgicv3_write_reg(intid, GICD_ICACTIVER, 32, 1, 1);\n}\n\nstatic bool gicv3_irq_get_active(uint32_t intid)\n{\n\treturn gicv3_read_reg(intid, GICD_ISACTIVER, 32, 1);\n}\n\nstatic void gicv3_irq_set_pending(uint32_t intid)\n{\n\tgicv3_write_reg(intid, GICD_ISPENDR, 32, 1, 1);\n}\n\nstatic void gicv3_irq_clear_pending(uint32_t intid)\n{\n\tgicv3_write_reg(intid, GICD_ICPENDR, 32, 1, 1);\n}\n\nstatic bool gicv3_irq_get_pending(uint32_t intid)\n{\n\treturn gicv3_read_reg(intid, GICD_ISPENDR, 32, 1);\n}\n\nstatic void gicv3_enable_redist(void *redist_base)\n{\n\tuint32_t val = readl(redist_base + GICR_WAKER);\n\tunsigned int count = 100000;  \n\n\tval &= ~GICR_WAKER_ProcessorSleep;\n\twritel(val, redist_base + GICR_WAKER);\n\n\t \n\twhile (readl(redist_base + GICR_WAKER) & GICR_WAKER_ChildrenAsleep) {\n\t\tGUEST_ASSERT(count--);\n\t\tudelay(10);\n\t}\n}\n\nstatic inline void *gicr_base_cpu(void *redist_base, uint32_t cpu)\n{\n\t \n\treturn redist_base + cpu * SZ_64K * 2;\n}\n\nstatic void gicv3_cpu_init(unsigned int cpu, void *redist_base)\n{\n\tvoid *sgi_base;\n\tunsigned int i;\n\tvoid *redist_base_cpu;\n\n\tGUEST_ASSERT(cpu < gicv3_data.nr_cpus);\n\n\tredist_base_cpu = gicr_base_cpu(redist_base, cpu);\n\tsgi_base = sgi_base_from_redist(redist_base_cpu);\n\n\tgicv3_enable_redist(redist_base_cpu);\n\n\t \n\twritel(~0, sgi_base + GICR_IGROUPR0);\n\twritel(~0, sgi_base + GICR_ICACTIVER0);\n\twritel(~0, sgi_base + GICR_ICENABLER0);\n\n\t \n\tfor (i = 0; i < 32; i += 4)\n\t\twritel(GICD_INT_DEF_PRI_X4,\n\t\t\t\tsgi_base + GICR_IPRIORITYR0 + i);\n\n\tgicv3_gicr_wait_for_rwp(redist_base_cpu);\n\n\t \n\twrite_sysreg_s(read_sysreg_s(SYS_ICC_SRE_EL1) | ICC_SRE_EL1_SRE,\n\t\t\tSYS_ICC_SRE_EL1);\n\n\t \n\twrite_sysreg_s(ICC_PMR_DEF_PRIO, SYS_ICC_PMR_EL1);\n\n\t \n\twrite_sysreg_s(ICC_IGRPEN1_EL1_ENABLE, SYS_ICC_GRPEN1_EL1);\n\n\tgicv3_data.redist_base[cpu] = redist_base_cpu;\n}\n\nstatic void gicv3_dist_init(void)\n{\n\tvoid *dist_base = gicv3_data.dist_base;\n\tunsigned int i;\n\n\t \n\twritel(0, dist_base + GICD_CTLR);\n\tgicv3_gicd_wait_for_rwp();\n\n\t \n\tfor (i = 32; i < gicv3_data.nr_spis; i += 32) {\n\t\twritel(~0, dist_base + GICD_IGROUPR + i / 8);\n\t\twritel(~0, dist_base + GICD_ICACTIVER + i / 8);\n\t\twritel(~0, dist_base + GICD_ICENABLER + i / 8);\n\t}\n\n\t \n\tfor (i = 32; i < gicv3_data.nr_spis; i += 4)\n\t\twritel(GICD_INT_DEF_PRI_X4,\n\t\t\t\tdist_base + GICD_IPRIORITYR + i);\n\n\t \n\tgicv3_gicd_wait_for_rwp();\n\n\t \n\twritel(GICD_CTLR_ARE_NS | GICD_CTLR_ENABLE_G1A |\n\t\t\tGICD_CTLR_ENABLE_G1, dist_base + GICD_CTLR);\n\tgicv3_gicd_wait_for_rwp();\n}\n\nstatic void gicv3_init(unsigned int nr_cpus, void *dist_base)\n{\n\tGUEST_ASSERT(nr_cpus <= GICV3_MAX_CPUS);\n\n\tgicv3_data.nr_cpus = nr_cpus;\n\tgicv3_data.dist_base = dist_base;\n\tgicv3_data.nr_spis = GICD_TYPER_SPIS(\n\t\t\t\treadl(gicv3_data.dist_base + GICD_TYPER));\n\tif (gicv3_data.nr_spis > 1020)\n\t\tgicv3_data.nr_spis = 1020;\n\n\t \n\tgicv3_dist_init();\n}\n\nconst struct gic_common_ops gicv3_ops = {\n\t.gic_init = gicv3_init,\n\t.gic_cpu_init = gicv3_cpu_init,\n\t.gic_irq_enable = gicv3_irq_enable,\n\t.gic_irq_disable = gicv3_irq_disable,\n\t.gic_read_iar = gicv3_read_iar,\n\t.gic_write_eoir = gicv3_write_eoir,\n\t.gic_write_dir = gicv3_write_dir,\n\t.gic_set_priority_mask = gicv3_set_priority_mask,\n\t.gic_set_eoi_split = gicv3_set_eoi_split,\n\t.gic_set_priority = gicv3_set_priority,\n\t.gic_irq_set_active = gicv3_irq_set_active,\n\t.gic_irq_clear_active = gicv3_irq_clear_active,\n\t.gic_irq_get_active = gicv3_irq_get_active,\n\t.gic_irq_set_pending = gicv3_irq_set_pending,\n\t.gic_irq_clear_pending = gicv3_irq_clear_pending,\n\t.gic_irq_get_pending = gicv3_irq_get_pending,\n\t.gic_irq_set_config = gicv3_irq_set_config,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}