{
  "module_name": "vgic.c",
  "hash_id": "f5c57daa2dd31818539eaece8ca47be267935786bb2514fc5a03cb3c621afe8d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/aarch64/vgic.c",
  "human_readable_source": "\n \n\n#include <linux/kvm.h>\n#include <linux/sizes.h>\n#include <asm/kvm_para.h>\n#include <asm/kvm.h>\n\n#include \"kvm_util.h\"\n#include \"vgic.h\"\n#include \"gic.h\"\n#include \"gic_v3.h\"\n\n \nint vgic_v3_setup(struct kvm_vm *vm, unsigned int nr_vcpus, uint32_t nr_irqs,\n\t\tuint64_t gicd_base_gpa, uint64_t gicr_base_gpa)\n{\n\tint gic_fd;\n\tuint64_t redist_attr;\n\tstruct list_head *iter;\n\tunsigned int nr_gic_pages, nr_vcpus_created = 0;\n\n\tTEST_ASSERT(nr_vcpus, \"Number of vCPUs cannot be empty\\n\");\n\n\t \n\tlist_for_each(iter, &vm->vcpus)\n\t\tnr_vcpus_created++;\n\tTEST_ASSERT(nr_vcpus == nr_vcpus_created,\n\t\t\t\"Number of vCPUs requested (%u) doesn't match with the ones created for the VM (%u)\\n\",\n\t\t\tnr_vcpus, nr_vcpus_created);\n\n\t \n\tgic_fd = __kvm_create_device(vm, KVM_DEV_TYPE_ARM_VGIC_V3);\n\tif (gic_fd < 0)\n\t\treturn gic_fd;\n\n\tkvm_device_attr_set(gic_fd, KVM_DEV_ARM_VGIC_GRP_NR_IRQS, 0, &nr_irqs);\n\n\tkvm_device_attr_set(gic_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\t\t\t    KVM_DEV_ARM_VGIC_CTRL_INIT, NULL);\n\n\tkvm_device_attr_set(gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_DIST, &gicd_base_gpa);\n\tnr_gic_pages = vm_calc_num_guest_pages(vm->mode, KVM_VGIC_V3_DIST_SIZE);\n\tvirt_map(vm, gicd_base_gpa, gicd_base_gpa,  nr_gic_pages);\n\n\t \n\tredist_attr = REDIST_REGION_ATTR_ADDR(nr_vcpus, gicr_base_gpa, 0, 0);\n\tkvm_device_attr_set(gic_fd, KVM_DEV_ARM_VGIC_GRP_ADDR,\n\t\t\t    KVM_VGIC_V3_ADDR_TYPE_REDIST_REGION, &redist_attr);\n\tnr_gic_pages = vm_calc_num_guest_pages(vm->mode,\n\t\t\t\t\t\tKVM_VGIC_V3_REDIST_SIZE * nr_vcpus);\n\tvirt_map(vm, gicr_base_gpa, gicr_base_gpa,  nr_gic_pages);\n\n\tkvm_device_attr_set(gic_fd, KVM_DEV_ARM_VGIC_GRP_CTRL,\n\t\t\t    KVM_DEV_ARM_VGIC_CTRL_INIT, NULL);\n\n\treturn gic_fd;\n}\n\n \nint _kvm_irq_set_level_info(int gic_fd, uint32_t intid, int level)\n{\n\tuint64_t attr = 32 * (intid / 32);\n\tuint64_t index = intid % 32;\n\tuint64_t val;\n\tint ret;\n\n\tret = __kvm_device_attr_get(gic_fd, KVM_DEV_ARM_VGIC_GRP_LEVEL_INFO,\n\t\t\t\t    attr, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tval |= 1U << index;\n\tret = __kvm_device_attr_set(gic_fd, KVM_DEV_ARM_VGIC_GRP_LEVEL_INFO,\n\t\t\t\t    attr, &val);\n\treturn ret;\n}\n\nvoid kvm_irq_set_level_info(int gic_fd, uint32_t intid, int level)\n{\n\tint ret = _kvm_irq_set_level_info(gic_fd, intid, level);\n\n\tTEST_ASSERT(!ret, KVM_IOCTL_ERROR(KVM_DEV_ARM_VGIC_GRP_LEVEL_INFO, ret));\n}\n\nint _kvm_arm_irq_line(struct kvm_vm *vm, uint32_t intid, int level)\n{\n\tuint32_t irq = intid & KVM_ARM_IRQ_NUM_MASK;\n\n\tTEST_ASSERT(!INTID_IS_SGI(intid), \"KVM_IRQ_LINE's interface itself \"\n\t\t\"doesn't allow injecting SGIs. There's no mask for it.\");\n\n\tif (INTID_IS_PPI(intid))\n\t\tirq |= KVM_ARM_IRQ_TYPE_PPI << KVM_ARM_IRQ_TYPE_SHIFT;\n\telse\n\t\tirq |= KVM_ARM_IRQ_TYPE_SPI << KVM_ARM_IRQ_TYPE_SHIFT;\n\n\treturn _kvm_irq_line(vm, irq, level);\n}\n\nvoid kvm_arm_irq_line(struct kvm_vm *vm, uint32_t intid, int level)\n{\n\tint ret = _kvm_arm_irq_line(vm, intid, level);\n\n\tTEST_ASSERT(!ret, KVM_IOCTL_ERROR(KVM_IRQ_LINE, ret));\n}\n\nstatic void vgic_poke_irq(int gic_fd, uint32_t intid, struct kvm_vcpu *vcpu,\n\t\t\t  uint64_t reg_off)\n{\n\tuint64_t reg = intid / 32;\n\tuint64_t index = intid % 32;\n\tuint64_t attr = reg_off + reg * 4;\n\tuint64_t val;\n\tbool intid_is_private = INTID_IS_SGI(intid) || INTID_IS_PPI(intid);\n\n\tuint32_t group = intid_is_private ? KVM_DEV_ARM_VGIC_GRP_REDIST_REGS\n\t\t\t\t\t  : KVM_DEV_ARM_VGIC_GRP_DIST_REGS;\n\n\tif (intid_is_private) {\n\t\t \n\t\tassert(vcpu->id == 0);\n\t\tattr += SZ_64K;\n\t}\n\n\t \n\tassert((attr & ~KVM_DEV_ARM_VGIC_OFFSET_MASK) == 0);\n\n\t \n\tkvm_device_attr_get(gic_fd, group, attr, &val);\n\tval |= 1ULL << index;\n\tkvm_device_attr_set(gic_fd, group, attr, &val);\n}\n\nvoid kvm_irq_write_ispendr(int gic_fd, uint32_t intid, struct kvm_vcpu *vcpu)\n{\n\tvgic_poke_irq(gic_fd, intid, vcpu, GICD_ISPENDR);\n}\n\nvoid kvm_irq_write_isactiver(int gic_fd, uint32_t intid, struct kvm_vcpu *vcpu)\n{\n\tvgic_poke_irq(gic_fd, intid, vcpu, GICD_ISACTIVER);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}