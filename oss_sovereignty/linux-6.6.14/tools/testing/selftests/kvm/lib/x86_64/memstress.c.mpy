{
  "module_name": "memstress.c",
  "hash_id": "d7b2dc261f11bf4ba3c8272704132924835656bcd7e721834b3a72ee5666e8b7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/x86_64/memstress.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"memstress.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n\nvoid memstress_l2_guest_code(uint64_t vcpu_id)\n{\n\tmemstress_guest_code(vcpu_id);\n\tvmcall();\n}\n\nextern char memstress_l2_guest_entry[];\n__asm__(\n\"memstress_l2_guest_entry:\"\n\"\tmov (%rsp), %rdi;\"\n\"\tcall memstress_l2_guest_code;\"\n\"\tud2;\"\n);\n\nstatic void memstress_l1_guest_code(struct vmx_pages *vmx, uint64_t vcpu_id)\n{\n#define L2_GUEST_STACK_SIZE 64\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\tunsigned long *rsp;\n\n\tGUEST_ASSERT(vmx->vmcs_gpa);\n\tGUEST_ASSERT(prepare_for_vmx_operation(vmx));\n\tGUEST_ASSERT(load_vmcs(vmx));\n\tGUEST_ASSERT(ept_1g_pages_supported());\n\n\trsp = &l2_guest_stack[L2_GUEST_STACK_SIZE - 1];\n\t*rsp = vcpu_id;\n\tprepare_vmcs(vmx, memstress_l2_guest_entry, rsp);\n\n\tGUEST_ASSERT(!vmlaunch());\n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_VMCALL);\n\tGUEST_DONE();\n}\n\nuint64_t memstress_nested_pages(int nr_vcpus)\n{\n\t \n\treturn 513 + 10 * nr_vcpus;\n}\n\nvoid memstress_setup_ept(struct vmx_pages *vmx, struct kvm_vm *vm)\n{\n\tuint64_t start, end;\n\n\tprepare_eptp(vmx, vm, 0);\n\n\t \n\tnested_identity_map_1g(vmx, vm, 0, 0x100000000ULL);\n\n\tstart = align_down(memstress_args.gpa, PG_SIZE_1G);\n\tend = align_up(memstress_args.gpa + memstress_args.size, PG_SIZE_1G);\n\tnested_identity_map_1g(vmx, vm, start, end - start);\n}\n\nvoid memstress_setup_nested(struct kvm_vm *vm, int nr_vcpus, struct kvm_vcpu *vcpus[])\n{\n\tstruct vmx_pages *vmx, *vmx0 = NULL;\n\tstruct kvm_regs regs;\n\tvm_vaddr_t vmx_gva;\n\tint vcpu_id;\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));\n\tTEST_REQUIRE(kvm_cpu_has_ept());\n\n\tfor (vcpu_id = 0; vcpu_id < nr_vcpus; vcpu_id++) {\n\t\tvmx = vcpu_alloc_vmx(vm, &vmx_gva);\n\n\t\tif (vcpu_id == 0) {\n\t\t\tmemstress_setup_ept(vmx, vm);\n\t\t\tvmx0 = vmx;\n\t\t} else {\n\t\t\t \n\t\t\tvmx->eptp = vmx0->eptp;\n\t\t\tvmx->eptp_hva = vmx0->eptp_hva;\n\t\t\tvmx->eptp_gpa = vmx0->eptp_gpa;\n\t\t}\n\n\t\t \n\t\tvcpu_regs_get(vcpus[vcpu_id], &regs);\n\t\tregs.rip = (unsigned long) memstress_l1_guest_code;\n\t\tvcpu_regs_set(vcpus[vcpu_id], &regs);\n\t\tvcpu_args_set(vcpus[vcpu_id], 2, vmx_gva, vcpu_id);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}