{
  "module_name": "svm.c",
  "hash_id": "504172ef6a695faccab9855ac768135cecfb0d35bcf2f7349e906440689eea54",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/x86_64/svm.c",
  "human_readable_source": "\n \n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"svm_util.h\"\n\n#define SEV_DEV_PATH \"/dev/sev\"\n\nstruct gpr64_regs guest_regs;\nu64 rflags;\n\n \nstruct svm_test_data *\nvcpu_alloc_svm(struct kvm_vm *vm, vm_vaddr_t *p_svm_gva)\n{\n\tvm_vaddr_t svm_gva = vm_vaddr_alloc_page(vm);\n\tstruct svm_test_data *svm = addr_gva2hva(vm, svm_gva);\n\n\tsvm->vmcb = (void *)vm_vaddr_alloc_page(vm);\n\tsvm->vmcb_hva = addr_gva2hva(vm, (uintptr_t)svm->vmcb);\n\tsvm->vmcb_gpa = addr_gva2gpa(vm, (uintptr_t)svm->vmcb);\n\n\tsvm->save_area = (void *)vm_vaddr_alloc_page(vm);\n\tsvm->save_area_hva = addr_gva2hva(vm, (uintptr_t)svm->save_area);\n\tsvm->save_area_gpa = addr_gva2gpa(vm, (uintptr_t)svm->save_area);\n\n\tsvm->msr = (void *)vm_vaddr_alloc_page(vm);\n\tsvm->msr_hva = addr_gva2hva(vm, (uintptr_t)svm->msr);\n\tsvm->msr_gpa = addr_gva2gpa(vm, (uintptr_t)svm->msr);\n\tmemset(svm->msr_hva, 0, getpagesize());\n\n\t*p_svm_gva = svm_gva;\n\treturn svm;\n}\n\nstatic void vmcb_set_seg(struct vmcb_seg *seg, u16 selector,\n\t\t\t u64 base, u32 limit, u32 attr)\n{\n\tseg->selector = selector;\n\tseg->attrib = attr;\n\tseg->limit = limit;\n\tseg->base = base;\n}\n\nvoid generic_svm_setup(struct svm_test_data *svm, void *guest_rip, void *guest_rsp)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\tuint64_t vmcb_gpa = svm->vmcb_gpa;\n\tstruct vmcb_save_area *save = &vmcb->save;\n\tstruct vmcb_control_area *ctrl = &vmcb->control;\n\tu32 data_seg_attr = 3 | SVM_SELECTOR_S_MASK | SVM_SELECTOR_P_MASK\n\t      | SVM_SELECTOR_DB_MASK | SVM_SELECTOR_G_MASK;\n\tu32 code_seg_attr = 9 | SVM_SELECTOR_S_MASK | SVM_SELECTOR_P_MASK\n\t\t| SVM_SELECTOR_L_MASK | SVM_SELECTOR_G_MASK;\n\tuint64_t efer;\n\n\tefer = rdmsr(MSR_EFER);\n\twrmsr(MSR_EFER, efer | EFER_SVME);\n\twrmsr(MSR_VM_HSAVE_PA, svm->save_area_gpa);\n\n\tmemset(vmcb, 0, sizeof(*vmcb));\n\tasm volatile (\"vmsave %0\\n\\t\" : : \"a\" (vmcb_gpa) : \"memory\");\n\tvmcb_set_seg(&save->es, get_es(), 0, -1U, data_seg_attr);\n\tvmcb_set_seg(&save->cs, get_cs(), 0, -1U, code_seg_attr);\n\tvmcb_set_seg(&save->ss, get_ss(), 0, -1U, data_seg_attr);\n\tvmcb_set_seg(&save->ds, get_ds(), 0, -1U, data_seg_attr);\n\tvmcb_set_seg(&save->gdtr, 0, get_gdt().address, get_gdt().size, 0);\n\tvmcb_set_seg(&save->idtr, 0, get_idt().address, get_idt().size, 0);\n\n\tctrl->asid = 1;\n\tsave->cpl = 0;\n\tsave->efer = rdmsr(MSR_EFER);\n\tasm volatile (\"mov %%cr4, %0\" : \"=r\"(save->cr4) : : \"memory\");\n\tasm volatile (\"mov %%cr3, %0\" : \"=r\"(save->cr3) : : \"memory\");\n\tasm volatile (\"mov %%cr0, %0\" : \"=r\"(save->cr0) : : \"memory\");\n\tasm volatile (\"mov %%dr7, %0\" : \"=r\"(save->dr7) : : \"memory\");\n\tasm volatile (\"mov %%dr6, %0\" : \"=r\"(save->dr6) : : \"memory\");\n\tasm volatile (\"mov %%cr2, %0\" : \"=r\"(save->cr2) : : \"memory\");\n\tsave->g_pat = rdmsr(MSR_IA32_CR_PAT);\n\tsave->dbgctl = rdmsr(MSR_IA32_DEBUGCTLMSR);\n\tctrl->intercept = (1ULL << INTERCEPT_VMRUN) |\n\t\t\t\t(1ULL << INTERCEPT_VMMCALL);\n\tctrl->msrpm_base_pa = svm->msr_gpa;\n\n\tvmcb->save.rip = (u64)guest_rip;\n\tvmcb->save.rsp = (u64)guest_rsp;\n\tguest_regs.rdi = (u64)svm;\n}\n\n \n#define SAVE_GPR_C\t\t\t\t\\\n\t\"xchg %%rbx, guest_regs+0x20\\n\\t\"\t\\\n\t\"xchg %%rcx, guest_regs+0x10\\n\\t\"\t\\\n\t\"xchg %%rdx, guest_regs+0x18\\n\\t\"\t\\\n\t\"xchg %%rbp, guest_regs+0x30\\n\\t\"\t\\\n\t\"xchg %%rsi, guest_regs+0x38\\n\\t\"\t\\\n\t\"xchg %%rdi, guest_regs+0x40\\n\\t\"\t\\\n\t\"xchg %%r8,  guest_regs+0x48\\n\\t\"\t\\\n\t\"xchg %%r9,  guest_regs+0x50\\n\\t\"\t\\\n\t\"xchg %%r10, guest_regs+0x58\\n\\t\"\t\\\n\t\"xchg %%r11, guest_regs+0x60\\n\\t\"\t\\\n\t\"xchg %%r12, guest_regs+0x68\\n\\t\"\t\\\n\t\"xchg %%r13, guest_regs+0x70\\n\\t\"\t\\\n\t\"xchg %%r14, guest_regs+0x78\\n\\t\"\t\\\n\t\"xchg %%r15, guest_regs+0x80\\n\\t\"\n\n#define LOAD_GPR_C      SAVE_GPR_C\n\n \nvoid run_guest(struct vmcb *vmcb, uint64_t vmcb_gpa)\n{\n\tasm volatile (\n\t\t\"vmload %[vmcb_gpa]\\n\\t\"\n\t\t\"mov rflags, %%r15\\n\\t\"\t\n\t\t\"mov %%r15, 0x170(%[vmcb])\\n\\t\"\n\t\t\"mov guest_regs, %%r15\\n\\t\"\t\n\t\t\"mov %%r15, 0x1f8(%[vmcb])\\n\\t\"\n\t\tLOAD_GPR_C\n\t\t\"vmrun %[vmcb_gpa]\\n\\t\"\n\t\tSAVE_GPR_C\n\t\t\"mov 0x170(%[vmcb]), %%r15\\n\\t\"\t\n\t\t\"mov %%r15, rflags\\n\\t\"\n\t\t\"mov 0x1f8(%[vmcb]), %%r15\\n\\t\"\t\n\t\t\"mov %%r15, guest_regs\\n\\t\"\n\t\t\"vmsave %[vmcb_gpa]\\n\\t\"\n\t\t: : [vmcb] \"r\" (vmcb), [vmcb_gpa] \"a\" (vmcb_gpa)\n\t\t: \"r15\", \"memory\");\n}\n\n \nint open_sev_dev_path_or_exit(void)\n{\n\treturn open_path_or_exit(SEV_DEV_PATH, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}