{
  "module_name": "guest_sprintf.c",
  "hash_id": "cf283ebba8c010ee9d432a211a5378e823a32477869bf21d27d1abdfd6efc4f4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/guest_sprintf.c",
  "human_readable_source": "\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"ucall_common.h\"\n\n#define APPEND_BUFFER_SAFE(str, end, v) \\\ndo {\t\t\t\t\t\\\n\tGUEST_ASSERT(str < end);\t\\\n\t*str++ = (v);\t\t\t\\\n} while (0)\n\nstatic int isdigit(int ch)\n{\n\treturn (ch >= '0') && (ch <= '9');\n}\n\nstatic int skip_atoi(const char **s)\n{\n\tint i = 0;\n\n\twhile (isdigit(**s))\n\t\ti = i * 10 + *((*s)++) - '0';\n\treturn i;\n}\n\n#define ZEROPAD\t1\t\t \n#define SIGN\t2\t\t \n#define PLUS\t4\t\t \n#define SPACE\t8\t\t \n#define LEFT\t16\t\t \n#define SMALL\t32\t\t \n#define SPECIAL\t64\t\t \n\n#define __do_div(n, base)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tint __res;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n\t__res = ((uint64_t) n) % (uint32_t) base;\t\\\n\tn = ((uint64_t) n) / (uint32_t) base;\t\t\\\n\t__res;\t\t\t\t\t\t\\\n})\n\nstatic char *number(char *str, const char *end, long num, int base, int size,\n\t\t    int precision, int type)\n{\n\t \n\tstatic const char digits[16] = \"0123456789ABCDEF\";  \n\n\tchar tmp[66];\n\tchar c, sign, locase;\n\tint i;\n\n\t \n\tlocase = (type & SMALL);\n\tif (type & LEFT)\n\t\ttype &= ~ZEROPAD;\n\tif (base < 2 || base > 16)\n\t\treturn NULL;\n\tc = (type & ZEROPAD) ? '0' : ' ';\n\tsign = 0;\n\tif (type & SIGN) {\n\t\tif (num < 0) {\n\t\t\tsign = '-';\n\t\t\tnum = -num;\n\t\t\tsize--;\n\t\t} else if (type & PLUS) {\n\t\t\tsign = '+';\n\t\t\tsize--;\n\t\t} else if (type & SPACE) {\n\t\t\tsign = ' ';\n\t\t\tsize--;\n\t\t}\n\t}\n\tif (type & SPECIAL) {\n\t\tif (base == 16)\n\t\t\tsize -= 2;\n\t\telse if (base == 8)\n\t\t\tsize--;\n\t}\n\ti = 0;\n\tif (num == 0)\n\t\ttmp[i++] = '0';\n\telse\n\t\twhile (num != 0)\n\t\t\ttmp[i++] = (digits[__do_div(num, base)] | locase);\n\tif (i > precision)\n\t\tprecision = i;\n\tsize -= precision;\n\tif (!(type & (ZEROPAD + LEFT)))\n\t\twhile (size-- > 0)\n\t\t\tAPPEND_BUFFER_SAFE(str, end, ' ');\n\tif (sign)\n\t\tAPPEND_BUFFER_SAFE(str, end, sign);\n\tif (type & SPECIAL) {\n\t\tif (base == 8)\n\t\t\tAPPEND_BUFFER_SAFE(str, end, '0');\n\t\telse if (base == 16) {\n\t\t\tAPPEND_BUFFER_SAFE(str, end, '0');\n\t\t\tAPPEND_BUFFER_SAFE(str, end, 'x');\n\t\t}\n\t}\n\tif (!(type & LEFT))\n\t\twhile (size-- > 0)\n\t\t\tAPPEND_BUFFER_SAFE(str, end, c);\n\twhile (i < precision--)\n\t\tAPPEND_BUFFER_SAFE(str, end, '0');\n\twhile (i-- > 0)\n\t\tAPPEND_BUFFER_SAFE(str, end, tmp[i]);\n\twhile (size-- > 0)\n\t\tAPPEND_BUFFER_SAFE(str, end, ' ');\n\n\treturn str;\n}\n\nint guest_vsnprintf(char *buf, int n, const char *fmt, va_list args)\n{\n\tchar *str, *end;\n\tconst char *s;\n\tuint64_t num;\n\tint i, base;\n\tint len;\n\n\tint flags;\t\t \n\n\tint field_width;\t \n\tint precision;\t\t \n\tint qualifier;\t\t \n\n\tend = buf + n;\n\tGUEST_ASSERT(buf < end);\n\tGUEST_ASSERT(n > 0);\n\n\tfor (str = buf; *fmt; ++fmt) {\n\t\tif (*fmt != '%') {\n\t\t\tAPPEND_BUFFER_SAFE(str, end, *fmt);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tflags = 0;\nrepeat:\n\t\t++fmt;\t\t \n\t\tswitch (*fmt) {\n\t\tcase '-':\n\t\t\tflags |= LEFT;\n\t\t\tgoto repeat;\n\t\tcase '+':\n\t\t\tflags |= PLUS;\n\t\t\tgoto repeat;\n\t\tcase ' ':\n\t\t\tflags |= SPACE;\n\t\t\tgoto repeat;\n\t\tcase '#':\n\t\t\tflags |= SPECIAL;\n\t\t\tgoto repeat;\n\t\tcase '0':\n\t\t\tflags |= ZEROPAD;\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t \n\t\tfield_width = -1;\n\t\tif (isdigit(*fmt))\n\t\t\tfield_width = skip_atoi(&fmt);\n\t\telse if (*fmt == '*') {\n\t\t\t++fmt;\n\t\t\t \n\t\t\tfield_width = va_arg(args, int);\n\t\t\tif (field_width < 0) {\n\t\t\t\tfield_width = -field_width;\n\t\t\t\tflags |= LEFT;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tprecision = -1;\n\t\tif (*fmt == '.') {\n\t\t\t++fmt;\n\t\t\tif (isdigit(*fmt))\n\t\t\t\tprecision = skip_atoi(&fmt);\n\t\t\telse if (*fmt == '*') {\n\t\t\t\t++fmt;\n\t\t\t\t \n\t\t\t\tprecision = va_arg(args, int);\n\t\t\t}\n\t\t\tif (precision < 0)\n\t\t\t\tprecision = 0;\n\t\t}\n\n\t\t \n\t\tqualifier = -1;\n\t\tif (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {\n\t\t\tqualifier = *fmt;\n\t\t\t++fmt;\n\t\t}\n\n\t\t \n\t\tif (qualifier == 'l' && *fmt == 'l')\n\t\t\t++fmt;\n\n\t\t \n\t\tbase = 10;\n\n\t\tswitch (*fmt) {\n\t\tcase 'c':\n\t\t\tif (!(flags & LEFT))\n\t\t\t\twhile (--field_width > 0)\n\t\t\t\t\tAPPEND_BUFFER_SAFE(str, end, ' ');\n\t\t\tAPPEND_BUFFER_SAFE(str, end,\n\t\t\t\t\t    (uint8_t)va_arg(args, int));\n\t\t\twhile (--field_width > 0)\n\t\t\t\tAPPEND_BUFFER_SAFE(str, end, ' ');\n\t\t\tcontinue;\n\n\t\tcase 's':\n\t\t\ts = va_arg(args, char *);\n\t\t\tlen = strnlen(s, precision);\n\n\t\t\tif (!(flags & LEFT))\n\t\t\t\twhile (len < field_width--)\n\t\t\t\t\tAPPEND_BUFFER_SAFE(str, end, ' ');\n\t\t\tfor (i = 0; i < len; ++i)\n\t\t\t\tAPPEND_BUFFER_SAFE(str, end, *s++);\n\t\t\twhile (len < field_width--)\n\t\t\t\tAPPEND_BUFFER_SAFE(str, end, ' ');\n\t\t\tcontinue;\n\n\t\tcase 'p':\n\t\t\tif (field_width == -1) {\n\t\t\t\tfield_width = 2 * sizeof(void *);\n\t\t\t\tflags |= SPECIAL | SMALL | ZEROPAD;\n\t\t\t}\n\t\t\tstr = number(str, end,\n\t\t\t\t     (uint64_t)va_arg(args, void *), 16,\n\t\t\t\t     field_width, precision, flags);\n\t\t\tcontinue;\n\n\t\tcase 'n':\n\t\t\tif (qualifier == 'l') {\n\t\t\t\tlong *ip = va_arg(args, long *);\n\t\t\t\t*ip = (str - buf);\n\t\t\t} else {\n\t\t\t\tint *ip = va_arg(args, int *);\n\t\t\t\t*ip = (str - buf);\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase '%':\n\t\t\tAPPEND_BUFFER_SAFE(str, end, '%');\n\t\t\tcontinue;\n\n\t\t \n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tflags |= SMALL;\n\t\tcase 'X':\n\t\t\tbase = 16;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tflags |= SIGN;\n\t\tcase 'u':\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tAPPEND_BUFFER_SAFE(str, end, '%');\n\t\t\tif (*fmt)\n\t\t\t\tAPPEND_BUFFER_SAFE(str, end, *fmt);\n\t\t\telse\n\t\t\t\t--fmt;\n\t\t\tcontinue;\n\t\t}\n\t\tif (qualifier == 'l')\n\t\t\tnum = va_arg(args, uint64_t);\n\t\telse if (qualifier == 'h') {\n\t\t\tnum = (uint16_t)va_arg(args, int);\n\t\t\tif (flags & SIGN)\n\t\t\t\tnum = (int16_t)num;\n\t\t} else if (flags & SIGN)\n\t\t\tnum = va_arg(args, int);\n\t\telse\n\t\t\tnum = va_arg(args, uint32_t);\n\t\tstr = number(str, end, num, base, field_width, precision, flags);\n\t}\n\n\tGUEST_ASSERT(str < end);\n\t*str = '\\0';\n\treturn str - buf;\n}\n\nint guest_snprintf(char *buf, int n, const char *fmt, ...)\n{\n\tva_list va;\n\tint len;\n\n\tva_start(va, fmt);\n\tlen = guest_vsnprintf(buf, n, fmt, va);\n\tva_end(va);\n\n\treturn len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}