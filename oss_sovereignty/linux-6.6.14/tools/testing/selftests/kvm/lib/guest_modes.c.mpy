{
  "module_name": "guest_modes.c",
  "hash_id": "4e45fa84791750d7732e739e113fa9b82a5c0b1e6361eaf79895d5f28188c582",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/guest_modes.c",
  "human_readable_source": "\n \n#include \"guest_modes.h\"\n\n#ifdef __aarch64__\n#include \"processor.h\"\nenum vm_guest_mode vm_mode_default;\n#endif\n\nstruct guest_mode guest_modes[NUM_VM_MODES];\n\nvoid guest_modes_append_default(void)\n{\n#ifndef __aarch64__\n\tguest_mode_append(VM_MODE_DEFAULT, true, true);\n#else\n\t{\n\t\tunsigned int limit = kvm_check_cap(KVM_CAP_ARM_VM_IPA_SIZE);\n\t\tbool ps4k, ps16k, ps64k;\n\t\tint i;\n\n\t\taarch64_get_supported_page_sizes(limit, &ps4k, &ps16k, &ps64k);\n\n\t\tvm_mode_default = NUM_VM_MODES;\n\n\t\tif (limit >= 52)\n\t\t\tguest_mode_append(VM_MODE_P52V48_64K, ps64k, ps64k);\n\t\tif (limit >= 48) {\n\t\t\tguest_mode_append(VM_MODE_P48V48_4K, ps4k, ps4k);\n\t\t\tguest_mode_append(VM_MODE_P48V48_16K, ps16k, ps16k);\n\t\t\tguest_mode_append(VM_MODE_P48V48_64K, ps64k, ps64k);\n\t\t}\n\t\tif (limit >= 40) {\n\t\t\tguest_mode_append(VM_MODE_P40V48_4K, ps4k, ps4k);\n\t\t\tguest_mode_append(VM_MODE_P40V48_16K, ps16k, ps16k);\n\t\t\tguest_mode_append(VM_MODE_P40V48_64K, ps64k, ps64k);\n\t\t\tif (ps4k)\n\t\t\t\tvm_mode_default = VM_MODE_P40V48_4K;\n\t\t}\n\t\tif (limit >= 36) {\n\t\t\tguest_mode_append(VM_MODE_P36V48_4K, ps4k, ps4k);\n\t\t\tguest_mode_append(VM_MODE_P36V48_16K, ps16k, ps16k);\n\t\t\tguest_mode_append(VM_MODE_P36V48_64K, ps64k, ps64k);\n\t\t\tguest_mode_append(VM_MODE_P36V47_16K, ps16k, ps16k);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; vm_mode_default == NUM_VM_MODES && i < NUM_VM_MODES; i++) {\n\t\t\tif (guest_modes[i].supported && guest_modes[i].enabled)\n\t\t\t\tvm_mode_default = i;\n\t\t}\n\n\t\tTEST_ASSERT(vm_mode_default != NUM_VM_MODES,\n\t\t\t    \"No supported mode!\");\n\t}\n#endif\n#ifdef __s390x__\n\t{\n\t\tint kvm_fd, vm_fd;\n\t\tstruct kvm_s390_vm_cpu_processor info;\n\n\t\tkvm_fd = open_kvm_dev_path_or_exit();\n\t\tvm_fd = __kvm_ioctl(kvm_fd, KVM_CREATE_VM, NULL);\n\t\tkvm_device_attr_get(vm_fd, KVM_S390_VM_CPU_MODEL,\n\t\t\t\t    KVM_S390_VM_CPU_PROCESSOR, &info);\n\t\tclose(vm_fd);\n\t\tclose(kvm_fd);\n\t\t \n\t\tif (info.ibc >= 0x30)\n\t\t\tguest_mode_append(VM_MODE_P47V64_4K, true, true);\n\t}\n#endif\n#ifdef __riscv\n\t{\n\t\tunsigned int sz = kvm_check_cap(KVM_CAP_VM_GPA_BITS);\n\n\t\tif (sz >= 52)\n\t\t\tguest_mode_append(VM_MODE_P52V48_4K, true, true);\n\t\tif (sz >= 48)\n\t\t\tguest_mode_append(VM_MODE_P48V48_4K, true, true);\n\t}\n#endif\n}\n\nvoid for_each_guest_mode(void (*func)(enum vm_guest_mode, void *), void *arg)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_VM_MODES; ++i) {\n\t\tif (!guest_modes[i].enabled)\n\t\t\tcontinue;\n\t\tTEST_ASSERT(guest_modes[i].supported,\n\t\t\t    \"Guest mode ID %d (%s) not supported.\",\n\t\t\t    i, vm_guest_mode_string(i));\n\t\tfunc(i, arg);\n\t}\n}\n\nvoid guest_modes_help(void)\n{\n\tint i;\n\n\tprintf(\" -m: specify the guest mode ID to test\\n\"\n\t       \"     (default: test all supported modes)\\n\"\n\t       \"     This option may be used multiple times.\\n\"\n\t       \"     Guest mode IDs:\\n\");\n\tfor (i = 0; i < NUM_VM_MODES; ++i) {\n\t\tprintf(\"         %d:    %s%s\\n\", i, vm_guest_mode_string(i),\n\t\t       guest_modes[i].supported ? \" (supported)\" : \"\");\n\t}\n}\n\nvoid guest_modes_cmdline(const char *arg)\n{\n\tstatic bool mode_selected;\n\tunsigned int mode;\n\tint i;\n\n\tif (!mode_selected) {\n\t\tfor (i = 0; i < NUM_VM_MODES; ++i)\n\t\t\tguest_modes[i].enabled = false;\n\t\tmode_selected = true;\n\t}\n\n\tmode = atoi_non_negative(\"Guest mode ID\", arg);\n\tTEST_ASSERT(mode < NUM_VM_MODES, \"Guest mode ID %d too big\", mode);\n\tguest_modes[mode].enabled = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}