{
  "module_name": "elf.c",
  "hash_id": "56d15f15e9794ba87a36380cfc602f6fb6f097db4603f093f5552039e84a5d58",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/lib/elf.c",
  "human_readable_source": "\n \n\n#include \"test_util.h\"\n\n#include <bits/endian.h>\n#include <linux/elf.h>\n\n#include \"kvm_util.h\"\n\nstatic void elfhdr_get(const char *filename, Elf64_Ehdr *hdrp)\n{\n\toff_t offset_rv;\n\n\t \n\tint fd;\n\tfd = open(filename, O_RDONLY);\n\tTEST_ASSERT(fd >= 0, \"Failed to open ELF file,\\n\"\n\t\t\"  filename: %s\\n\"\n\t\t\"  rv: %i errno: %i\", filename, fd, errno);\n\n\t \n\tunsigned char ident[EI_NIDENT];\n\ttest_read(fd, ident, sizeof(ident));\n\tTEST_ASSERT((ident[EI_MAG0] == ELFMAG0) && (ident[EI_MAG1] == ELFMAG1)\n\t\t&& (ident[EI_MAG2] == ELFMAG2) && (ident[EI_MAG3] == ELFMAG3),\n\t\t\"ELF MAGIC Mismatch,\\n\"\n\t\t\"  filename: %s\\n\"\n\t\t\"  ident[EI_MAG0 - EI_MAG3]: %02x %02x %02x %02x\\n\"\n\t\t\"  Expected: %02x %02x %02x %02x\",\n\t\tfilename,\n\t\tident[EI_MAG0], ident[EI_MAG1], ident[EI_MAG2], ident[EI_MAG3],\n\t\tELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3);\n\tTEST_ASSERT(ident[EI_CLASS] == ELFCLASS64,\n\t\t\"Current implementation only able to handle ELFCLASS64,\\n\"\n\t\t\"  filename: %s\\n\"\n\t\t\"  ident[EI_CLASS]: %02x\\n\"\n\t\t\"  expected: %02x\",\n\t\tfilename,\n\t\tident[EI_CLASS], ELFCLASS64);\n\tTEST_ASSERT(((BYTE_ORDER == LITTLE_ENDIAN)\n\t\t\t&& (ident[EI_DATA] == ELFDATA2LSB))\n\t\t|| ((BYTE_ORDER == BIG_ENDIAN)\n\t\t\t&& (ident[EI_DATA] == ELFDATA2MSB)), \"Current \"\n\t\t\"implementation only able to handle\\n\"\n\t\t\"cases where the host and ELF file endianness\\n\"\n\t\t\"is the same:\\n\"\n\t\t\"  host BYTE_ORDER: %u\\n\"\n\t\t\"  host LITTLE_ENDIAN: %u\\n\"\n\t\t\"  host BIG_ENDIAN: %u\\n\"\n\t\t\"  ident[EI_DATA]: %u\\n\"\n\t\t\"  ELFDATA2LSB: %u\\n\"\n\t\t\"  ELFDATA2MSB: %u\",\n\t\tBYTE_ORDER, LITTLE_ENDIAN, BIG_ENDIAN,\n\t\tident[EI_DATA], ELFDATA2LSB, ELFDATA2MSB);\n\tTEST_ASSERT(ident[EI_VERSION] == EV_CURRENT,\n\t\t\"Current implementation only able to handle current \"\n\t\t\"ELF version,\\n\"\n\t\t\"  filename: %s\\n\"\n\t\t\"  ident[EI_VERSION]: %02x\\n\"\n\t\t\"  expected: %02x\",\n\t\tfilename, ident[EI_VERSION], EV_CURRENT);\n\n\t \n\toffset_rv = lseek(fd, 0, SEEK_SET);\n\tTEST_ASSERT(offset_rv == 0, \"Seek to ELF header failed,\\n\"\n\t\t\"  rv: %zi expected: %i\", offset_rv, 0);\n\ttest_read(fd, hdrp, sizeof(*hdrp));\n\tTEST_ASSERT(hdrp->e_phentsize == sizeof(Elf64_Phdr),\n\t\t\"Unexpected physical header size,\\n\"\n\t\t\"  hdrp->e_phentsize: %x\\n\"\n\t\t\"  expected: %zx\",\n\t\thdrp->e_phentsize, sizeof(Elf64_Phdr));\n\tTEST_ASSERT(hdrp->e_shentsize == sizeof(Elf64_Shdr),\n\t\t\"Unexpected section header size,\\n\"\n\t\t\"  hdrp->e_shentsize: %x\\n\"\n\t\t\"  expected: %zx\",\n\t\thdrp->e_shentsize, sizeof(Elf64_Shdr));\n\tclose(fd);\n}\n\n \nvoid kvm_vm_elf_load(struct kvm_vm *vm, const char *filename)\n{\n\toff_t offset, offset_rv;\n\tElf64_Ehdr hdr;\n\n\t \n\tint fd;\n\tfd = open(filename, O_RDONLY);\n\tTEST_ASSERT(fd >= 0, \"Failed to open ELF file,\\n\"\n\t\t\"  filename: %s\\n\"\n\t\t\"  rv: %i errno: %i\", filename, fd, errno);\n\n\t \n\telfhdr_get(filename, &hdr);\n\n\t \n\tfor (unsigned int n1 = 0; n1 < hdr.e_phnum; n1++) {\n\t\t \n\t\toffset = hdr.e_phoff + (n1 * hdr.e_phentsize);\n\t\toffset_rv = lseek(fd, offset, SEEK_SET);\n\t\tTEST_ASSERT(offset_rv == offset,\n\t\t\t\"Failed to seek to beginning of program header %u,\\n\"\n\t\t\t\"  filename: %s\\n\"\n\t\t\t\"  rv: %jd errno: %i\",\n\t\t\tn1, filename, (intmax_t) offset_rv, errno);\n\n\t\t \n\t\tElf64_Phdr phdr;\n\t\ttest_read(fd, &phdr, sizeof(phdr));\n\n\t\t \n\t\tif (phdr.p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\t \n\t\tTEST_ASSERT(phdr.p_memsz > 0, \"Unexpected loadable segment \"\n\t\t\t\"memsize of 0,\\n\"\n\t\t\t\"  phdr index: %u p_memsz: 0x%\" PRIx64,\n\t\t\tn1, (uint64_t) phdr.p_memsz);\n\t\tvm_vaddr_t seg_vstart = align_down(phdr.p_vaddr, vm->page_size);\n\t\tvm_vaddr_t seg_vend = phdr.p_vaddr + phdr.p_memsz - 1;\n\t\tseg_vend |= vm->page_size - 1;\n\t\tsize_t seg_size = seg_vend - seg_vstart + 1;\n\n\t\tvm_vaddr_t vaddr = __vm_vaddr_alloc(vm, seg_size, seg_vstart,\n\t\t\t\t\t\t    MEM_REGION_CODE);\n\t\tTEST_ASSERT(vaddr == seg_vstart, \"Unable to allocate \"\n\t\t\t\"virtual memory for segment at requested min addr,\\n\"\n\t\t\t\"  segment idx: %u\\n\"\n\t\t\t\"  seg_vstart: 0x%lx\\n\"\n\t\t\t\"  vaddr: 0x%lx\",\n\t\t\tn1, seg_vstart, vaddr);\n\t\tmemset(addr_gva2hva(vm, vaddr), 0, seg_size);\n\t\t \n\n\t\t \n\t\tif (phdr.p_filesz) {\n\t\t\toffset_rv = lseek(fd, phdr.p_offset, SEEK_SET);\n\t\t\tTEST_ASSERT(offset_rv == phdr.p_offset,\n\t\t\t\t\"Seek to program segment offset failed,\\n\"\n\t\t\t\t\"  program header idx: %u errno: %i\\n\"\n\t\t\t\t\"  offset_rv: 0x%jx\\n\"\n\t\t\t\t\"  expected: 0x%jx\\n\",\n\t\t\t\tn1, errno, (intmax_t) offset_rv,\n\t\t\t\t(intmax_t) phdr.p_offset);\n\t\t\ttest_read(fd, addr_gva2hva(vm, phdr.p_vaddr),\n\t\t\t\tphdr.p_filesz);\n\t\t}\n\t}\n\tclose(fd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}