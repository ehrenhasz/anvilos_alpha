{
  "module_name": "system_counter_offset_test.c",
  "hash_id": "f547dd0c0b6b845c34f41d02fd46d591d21aee893d1727ab62d1167f210f6713",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/system_counter_offset_test.c",
  "human_readable_source": "\n \n#include <asm/kvm_para.h>\n#include <stdint.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n#ifdef __x86_64__\n\nstruct test_case {\n\tuint64_t tsc_offset;\n};\n\nstatic struct test_case test_cases[] = {\n\t{ 0 },\n\t{ 180 * NSEC_PER_SEC },\n\t{ -180 * NSEC_PER_SEC },\n};\n\nstatic void check_preconditions(struct kvm_vcpu *vcpu)\n{\n\t__TEST_REQUIRE(!__vcpu_has_device_attr(vcpu, KVM_VCPU_TSC_CTRL,\n\t\t\t\t\t       KVM_VCPU_TSC_OFFSET),\n\t\t       \"KVM_VCPU_TSC_OFFSET not supported; skipping test\");\n}\n\nstatic void setup_system_counter(struct kvm_vcpu *vcpu, struct test_case *test)\n{\n\tvcpu_device_attr_set(vcpu, KVM_VCPU_TSC_CTRL, KVM_VCPU_TSC_OFFSET,\n\t\t\t     &test->tsc_offset);\n}\n\nstatic uint64_t guest_read_system_counter(struct test_case *test)\n{\n\treturn rdtsc();\n}\n\nstatic uint64_t host_read_guest_system_counter(struct test_case *test)\n{\n\treturn rdtsc() + test->tsc_offset;\n}\n\n#else  \n\n#error test not implemented for this architecture!\n\n#endif\n\n#define GUEST_SYNC_CLOCK(__stage, __val)\t\t\t\\\n\t\tGUEST_SYNC_ARGS(__stage, __val, 0, 0, 0)\n\nstatic void guest_main(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_cases); i++) {\n\t\tstruct test_case *test = &test_cases[i];\n\n\t\tGUEST_SYNC_CLOCK(i, guest_read_system_counter(test));\n\t}\n}\n\nstatic void handle_sync(struct ucall *uc, uint64_t start, uint64_t end)\n{\n\tuint64_t obs = uc->args[2];\n\n\tTEST_ASSERT(start <= obs && obs <= end,\n\t\t    \"unexpected system counter value: %\"PRIu64\" expected range: [%\"PRIu64\", %\"PRIu64\"]\",\n\t\t    obs, start, end);\n\n\tpr_info(\"system counter value: %\"PRIu64\" expected range [%\"PRIu64\", %\"PRIu64\"]\\n\",\n\t\tobs, start, end);\n}\n\nstatic void handle_abort(struct ucall *uc)\n{\n\tREPORT_GUEST_ASSERT(*uc);\n}\n\nstatic void enter_guest(struct kvm_vcpu *vcpu)\n{\n\tuint64_t start, end;\n\tstruct ucall uc;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_cases); i++) {\n\t\tstruct test_case *test = &test_cases[i];\n\n\t\tsetup_system_counter(vcpu, test);\n\t\tstart = host_read_guest_system_counter(test);\n\t\tvcpu_run(vcpu);\n\t\tend = host_read_guest_system_counter(test);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_SYNC:\n\t\t\thandle_sync(&uc, start, end);\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\thandle_abort(&uc);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tTEST_ASSERT(0, \"unhandled ucall %ld\\n\",\n\t\t\t\t    get_ucall(vcpu, &uc));\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_main);\n\tcheck_preconditions(vcpu);\n\n\tenter_guest(vcpu);\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}