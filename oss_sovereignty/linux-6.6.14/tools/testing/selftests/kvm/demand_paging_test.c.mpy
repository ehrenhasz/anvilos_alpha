{
  "module_name": "demand_paging_test.c",
  "hash_id": "e6446ee747825afb21647bb15973b876e2a9a2adea072dd812f4bbc4ca71bfef",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/demand_paging_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <poll.h>\n#include <pthread.h>\n#include <linux/userfaultfd.h>\n#include <sys/syscall.h>\n\n#include \"kvm_util.h\"\n#include \"test_util.h\"\n#include \"memstress.h\"\n#include \"guest_modes.h\"\n#include \"userfaultfd_util.h\"\n\n#ifdef __NR_userfaultfd\n\nstatic int nr_vcpus = 1;\nstatic uint64_t guest_percpu_mem_size = DEFAULT_PER_VCPU_MEM_SIZE;\n\nstatic size_t demand_paging_size;\nstatic char *guest_data_prototype;\n\nstatic void vcpu_worker(struct memstress_vcpu_args *vcpu_args)\n{\n\tstruct kvm_vcpu *vcpu = vcpu_args->vcpu;\n\tint vcpu_idx = vcpu_args->vcpu_idx;\n\tstruct kvm_run *run = vcpu->run;\n\tstruct timespec start;\n\tstruct timespec ts_diff;\n\tint ret;\n\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\n\t \n\tret = _vcpu_run(vcpu);\n\tTEST_ASSERT(ret == 0, \"vcpu_run failed: %d\\n\", ret);\n\tif (get_ucall(vcpu, NULL) != UCALL_SYNC) {\n\t\tTEST_ASSERT(false,\n\t\t\t    \"Invalid guest sync status: exit_reason=%s\\n\",\n\t\t\t    exit_reason_str(run->exit_reason));\n\t}\n\n\tts_diff = timespec_elapsed(start);\n\tPER_VCPU_DEBUG(\"vCPU %d execution time: %ld.%.9lds\\n\", vcpu_idx,\n\t\t       ts_diff.tv_sec, ts_diff.tv_nsec);\n}\n\nstatic int handle_uffd_page_request(int uffd_mode, int uffd,\n\t\tstruct uffd_msg *msg)\n{\n\tpid_t tid = syscall(__NR_gettid);\n\tuint64_t addr = msg->arg.pagefault.address;\n\tstruct timespec start;\n\tstruct timespec ts_diff;\n\tint r;\n\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\n\tif (uffd_mode == UFFDIO_REGISTER_MODE_MISSING) {\n\t\tstruct uffdio_copy copy;\n\n\t\tcopy.src = (uint64_t)guest_data_prototype;\n\t\tcopy.dst = addr;\n\t\tcopy.len = demand_paging_size;\n\t\tcopy.mode = 0;\n\n\t\tr = ioctl(uffd, UFFDIO_COPY, &copy);\n\t\tif (r == -1) {\n\t\t\tpr_info(\"Failed UFFDIO_COPY in 0x%lx from thread %d with errno: %d\\n\",\n\t\t\t\taddr, tid, errno);\n\t\t\treturn r;\n\t\t}\n\t} else if (uffd_mode == UFFDIO_REGISTER_MODE_MINOR) {\n\t\tstruct uffdio_continue cont = {0};\n\n\t\tcont.range.start = addr;\n\t\tcont.range.len = demand_paging_size;\n\n\t\tr = ioctl(uffd, UFFDIO_CONTINUE, &cont);\n\t\tif (r == -1) {\n\t\t\tpr_info(\"Failed UFFDIO_CONTINUE in 0x%lx from thread %d with errno: %d\\n\",\n\t\t\t\taddr, tid, errno);\n\t\t\treturn r;\n\t\t}\n\t} else {\n\t\tTEST_FAIL(\"Invalid uffd mode %d\", uffd_mode);\n\t}\n\n\tts_diff = timespec_elapsed(start);\n\n\tPER_PAGE_DEBUG(\"UFFD page-in %d \\t%ld ns\\n\", tid,\n\t\t       timespec_to_ns(ts_diff));\n\tPER_PAGE_DEBUG(\"Paged in %ld bytes at 0x%lx from thread %d\\n\",\n\t\t       demand_paging_size, addr, tid);\n\n\treturn 0;\n}\n\nstruct test_params {\n\tint uffd_mode;\n\tuseconds_t uffd_delay;\n\tenum vm_mem_backing_src_type src_type;\n\tbool partition_vcpu_memory_access;\n};\n\nstatic void prefault_mem(void *alias, uint64_t len)\n{\n\tsize_t p;\n\n\tTEST_ASSERT(alias != NULL, \"Alias required for minor faults\");\n\tfor (p = 0; p < (len / demand_paging_size); ++p) {\n\t\tmemcpy(alias + (p * demand_paging_size),\n\t\t       guest_data_prototype, demand_paging_size);\n\t}\n}\n\nstatic void run_test(enum vm_guest_mode mode, void *arg)\n{\n\tstruct memstress_vcpu_args *vcpu_args;\n\tstruct test_params *p = arg;\n\tstruct uffd_desc **uffd_descs = NULL;\n\tstruct timespec start;\n\tstruct timespec ts_diff;\n\tstruct kvm_vm *vm;\n\tint i;\n\n\tvm = memstress_create_vm(mode, nr_vcpus, guest_percpu_mem_size, 1,\n\t\t\t\t p->src_type, p->partition_vcpu_memory_access);\n\n\tdemand_paging_size = get_backing_src_pagesz(p->src_type);\n\n\tguest_data_prototype = malloc(demand_paging_size);\n\tTEST_ASSERT(guest_data_prototype,\n\t\t    \"Failed to allocate buffer for guest data pattern\");\n\tmemset(guest_data_prototype, 0xAB, demand_paging_size);\n\n\tif (p->uffd_mode == UFFDIO_REGISTER_MODE_MINOR) {\n\t\tfor (i = 0; i < nr_vcpus; i++) {\n\t\t\tvcpu_args = &memstress_args.vcpu_args[i];\n\t\t\tprefault_mem(addr_gpa2alias(vm, vcpu_args->gpa),\n\t\t\t\t     vcpu_args->pages * memstress_args.guest_page_size);\n\t\t}\n\t}\n\n\tif (p->uffd_mode) {\n\t\tuffd_descs = malloc(nr_vcpus * sizeof(struct uffd_desc *));\n\t\tTEST_ASSERT(uffd_descs, \"Memory allocation failed\");\n\t\tfor (i = 0; i < nr_vcpus; i++) {\n\t\t\tvoid *vcpu_hva;\n\n\t\t\tvcpu_args = &memstress_args.vcpu_args[i];\n\n\t\t\t \n\t\t\tvcpu_hva = addr_gpa2hva(vm, vcpu_args->gpa);\n\t\t\t \n\t\t\tuffd_descs[i] = uffd_setup_demand_paging(\n\t\t\t\tp->uffd_mode, p->uffd_delay, vcpu_hva,\n\t\t\t\tvcpu_args->pages * memstress_args.guest_page_size,\n\t\t\t\t&handle_uffd_page_request);\n\t\t}\n\t}\n\n\tpr_info(\"Finished creating vCPUs and starting uffd threads\\n\");\n\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\tmemstress_start_vcpu_threads(nr_vcpus, vcpu_worker);\n\tpr_info(\"Started all vCPUs\\n\");\n\n\tmemstress_join_vcpu_threads(nr_vcpus);\n\tts_diff = timespec_elapsed(start);\n\tpr_info(\"All vCPU threads joined\\n\");\n\n\tif (p->uffd_mode) {\n\t\t \n\t\tfor (i = 0; i < nr_vcpus; i++)\n\t\t\tuffd_stop_demand_paging(uffd_descs[i]);\n\t}\n\n\tpr_info(\"Total guest execution time: %ld.%.9lds\\n\",\n\t\tts_diff.tv_sec, ts_diff.tv_nsec);\n\tpr_info(\"Overall demand paging rate: %f pgs/sec\\n\",\n\t\tmemstress_args.vcpu_args[0].pages * nr_vcpus /\n\t\t((double)ts_diff.tv_sec + (double)ts_diff.tv_nsec / NSEC_PER_SEC));\n\n\tmemstress_destroy_vm(vm);\n\n\tfree(guest_data_prototype);\n\tif (p->uffd_mode)\n\t\tfree(uffd_descs);\n}\n\nstatic void help(char *name)\n{\n\tputs(\"\");\n\tprintf(\"usage: %s [-h] [-m vm_mode] [-u uffd_mode] [-d uffd_delay_usec]\\n\"\n\t       \"          [-b memory] [-s type] [-v vcpus] [-c cpu_list] [-o]\\n\", name);\n\tguest_modes_help();\n\tprintf(\" -u: use userfaultfd to handle vCPU page faults. Mode is a\\n\"\n\t       \"     UFFD registration mode: 'MISSING' or 'MINOR'.\\n\");\n\tkvm_print_vcpu_pinning_help();\n\tprintf(\" -d: add a delay in usec to the User Fault\\n\"\n\t       \"     FD handler to simulate demand paging\\n\"\n\t       \"     overheads. Ignored without -u.\\n\");\n\tprintf(\" -b: specify the size of the memory region which should be\\n\"\n\t       \"     demand paged by each vCPU. e.g. 10M or 3G.\\n\"\n\t       \"     Default: 1G\\n\");\n\tbacking_src_help(\"-s\");\n\tprintf(\" -v: specify the number of vCPUs to run.\\n\");\n\tprintf(\" -o: Overlap guest memory accesses instead of partitioning\\n\"\n\t       \"     them into a separate region of memory for each vCPU.\\n\");\n\tputs(\"\");\n\texit(0);\n}\n\nint main(int argc, char *argv[])\n{\n\tint max_vcpus = kvm_check_cap(KVM_CAP_MAX_VCPUS);\n\tconst char *cpulist = NULL;\n\tstruct test_params p = {\n\t\t.src_type = DEFAULT_VM_MEM_SRC,\n\t\t.partition_vcpu_memory_access = true,\n\t};\n\tint opt;\n\n\tguest_modes_append_default();\n\n\twhile ((opt = getopt(argc, argv, \"hm:u:d:b:s:v:c:o\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'm':\n\t\t\tguest_modes_cmdline(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (!strcmp(\"MISSING\", optarg))\n\t\t\t\tp.uffd_mode = UFFDIO_REGISTER_MODE_MISSING;\n\t\t\telse if (!strcmp(\"MINOR\", optarg))\n\t\t\t\tp.uffd_mode = UFFDIO_REGISTER_MODE_MINOR;\n\t\t\tTEST_ASSERT(p.uffd_mode, \"UFFD mode must be 'MISSING' or 'MINOR'.\");\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tp.uffd_delay = strtoul(optarg, NULL, 0);\n\t\t\tTEST_ASSERT(p.uffd_delay >= 0, \"A negative UFFD delay is not supported.\");\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tguest_percpu_mem_size = parse_size(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tp.src_type = parse_backing_src_type(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tnr_vcpus = atoi_positive(\"Number of vCPUs\", optarg);\n\t\t\tTEST_ASSERT(nr_vcpus <= max_vcpus,\n\t\t\t\t    \"Invalid number of vcpus, must be between 1 and %d\", max_vcpus);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcpulist = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tp.partition_vcpu_memory_access = false;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p.uffd_mode == UFFDIO_REGISTER_MODE_MINOR &&\n\t    !backing_src_is_shared(p.src_type)) {\n\t\tTEST_FAIL(\"userfaultfd MINOR mode requires shared memory; pick a different -s\");\n\t}\n\n\tif (cpulist) {\n\t\tkvm_parse_vcpu_pinning(cpulist, memstress_args.vcpu_to_pcpu,\n\t\t\t\t       nr_vcpus);\n\t\tmemstress_args.pin_vcpus = true;\n\t}\n\n\tfor_each_guest_mode(run_test, &p);\n\n\treturn 0;\n}\n\n#else  \n\n#warning \"missing __NR_userfaultfd definition\"\n\nint main(void)\n{\n\tprint_skip(\"__NR_userfaultfd must be present for userfaultfd test\");\n\treturn KSFT_SKIP;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}