{
  "module_name": "dirty_log_perf_test.c",
  "hash_id": "952f05a3776cdfb5749bbf184cdb9b22b02cf1702d9bfebaa35cd6cec5ed63da",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/dirty_log_perf_test.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <pthread.h>\n#include <linux/bitmap.h>\n\n#include \"kvm_util.h\"\n#include \"test_util.h\"\n#include \"memstress.h\"\n#include \"guest_modes.h\"\n\n#ifdef __aarch64__\n#include \"aarch64/vgic.h\"\n\n#define GICD_BASE_GPA\t\t\t0x8000000ULL\n#define GICR_BASE_GPA\t\t\t0x80A0000ULL\n\nstatic int gic_fd;\n\nstatic void arch_setup_vm(struct kvm_vm *vm, unsigned int nr_vcpus)\n{\n\t \n\tgic_fd = vgic_v3_setup(vm, nr_vcpus, 64, GICD_BASE_GPA, GICR_BASE_GPA);\n}\n\nstatic void arch_cleanup_vm(struct kvm_vm *vm)\n{\n\tif (gic_fd > 0)\n\t\tclose(gic_fd);\n}\n\n#else  \n\nstatic void arch_setup_vm(struct kvm_vm *vm, unsigned int nr_vcpus)\n{\n}\n\nstatic void arch_cleanup_vm(struct kvm_vm *vm)\n{\n}\n\n#endif\n\n \n#define TEST_HOST_LOOP_N\t\t2UL\n\nstatic int nr_vcpus = 1;\nstatic uint64_t guest_percpu_mem_size = DEFAULT_PER_VCPU_MEM_SIZE;\nstatic bool run_vcpus_while_disabling_dirty_logging;\n\n \nstatic u64 dirty_log_manual_caps;\nstatic bool host_quit;\nstatic int iteration;\nstatic int vcpu_last_completed_iteration[KVM_MAX_VCPUS];\n\nstatic void vcpu_worker(struct memstress_vcpu_args *vcpu_args)\n{\n\tstruct kvm_vcpu *vcpu = vcpu_args->vcpu;\n\tint vcpu_idx = vcpu_args->vcpu_idx;\n\tuint64_t pages_count = 0;\n\tstruct kvm_run *run;\n\tstruct timespec start;\n\tstruct timespec ts_diff;\n\tstruct timespec total = (struct timespec){0};\n\tstruct timespec avg;\n\tint ret;\n\n\trun = vcpu->run;\n\n\twhile (!READ_ONCE(host_quit)) {\n\t\tint current_iteration = READ_ONCE(iteration);\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &start);\n\t\tret = _vcpu_run(vcpu);\n\t\tts_diff = timespec_elapsed(start);\n\n\t\tTEST_ASSERT(ret == 0, \"vcpu_run failed: %d\\n\", ret);\n\t\tTEST_ASSERT(get_ucall(vcpu, NULL) == UCALL_SYNC,\n\t\t\t    \"Invalid guest sync status: exit_reason=%s\\n\",\n\t\t\t    exit_reason_str(run->exit_reason));\n\n\t\tpr_debug(\"Got sync event from vCPU %d\\n\", vcpu_idx);\n\t\tvcpu_last_completed_iteration[vcpu_idx] = current_iteration;\n\t\tpr_debug(\"vCPU %d updated last completed iteration to %d\\n\",\n\t\t\t vcpu_idx, vcpu_last_completed_iteration[vcpu_idx]);\n\n\t\tif (current_iteration) {\n\t\t\tpages_count += vcpu_args->pages;\n\t\t\ttotal = timespec_add(total, ts_diff);\n\t\t\tpr_debug(\"vCPU %d iteration %d dirty memory time: %ld.%.9lds\\n\",\n\t\t\t\tvcpu_idx, current_iteration, ts_diff.tv_sec,\n\t\t\t\tts_diff.tv_nsec);\n\t\t} else {\n\t\t\tpr_debug(\"vCPU %d iteration %d populate memory time: %ld.%.9lds\\n\",\n\t\t\t\tvcpu_idx, current_iteration, ts_diff.tv_sec,\n\t\t\t\tts_diff.tv_nsec);\n\t\t}\n\n\t\t \n\t\twhile (current_iteration == READ_ONCE(iteration) &&\n\t\t       READ_ONCE(iteration) >= 0 && !READ_ONCE(host_quit)) {}\n\t}\n\n\tavg = timespec_div(total, vcpu_last_completed_iteration[vcpu_idx]);\n\tpr_debug(\"\\nvCPU %d dirtied 0x%lx pages over %d iterations in %ld.%.9lds. (Avg %ld.%.9lds/iteration)\\n\",\n\t\tvcpu_idx, pages_count, vcpu_last_completed_iteration[vcpu_idx],\n\t\ttotal.tv_sec, total.tv_nsec, avg.tv_sec, avg.tv_nsec);\n}\n\nstruct test_params {\n\tunsigned long iterations;\n\tuint64_t phys_offset;\n\tbool partition_vcpu_memory_access;\n\tenum vm_mem_backing_src_type backing_src;\n\tint slots;\n\tuint32_t write_percent;\n\tuint32_t random_seed;\n\tbool random_access;\n};\n\nstatic void run_test(enum vm_guest_mode mode, void *arg)\n{\n\tstruct test_params *p = arg;\n\tstruct kvm_vm *vm;\n\tunsigned long **bitmaps;\n\tuint64_t guest_num_pages;\n\tuint64_t host_num_pages;\n\tuint64_t pages_per_slot;\n\tstruct timespec start;\n\tstruct timespec ts_diff;\n\tstruct timespec get_dirty_log_total = (struct timespec){0};\n\tstruct timespec vcpu_dirty_total = (struct timespec){0};\n\tstruct timespec avg;\n\tstruct timespec clear_dirty_log_total = (struct timespec){0};\n\tint i;\n\n\tvm = memstress_create_vm(mode, nr_vcpus, guest_percpu_mem_size,\n\t\t\t\t p->slots, p->backing_src,\n\t\t\t\t p->partition_vcpu_memory_access);\n\n\tpr_info(\"Random seed: %u\\n\", p->random_seed);\n\tmemstress_set_random_seed(vm, p->random_seed);\n\tmemstress_set_write_percent(vm, p->write_percent);\n\n\tguest_num_pages = (nr_vcpus * guest_percpu_mem_size) >> vm->page_shift;\n\tguest_num_pages = vm_adjust_num_guest_pages(mode, guest_num_pages);\n\thost_num_pages = vm_num_host_pages(mode, guest_num_pages);\n\tpages_per_slot = host_num_pages / p->slots;\n\n\tbitmaps = memstress_alloc_bitmaps(p->slots, pages_per_slot);\n\n\tif (dirty_log_manual_caps)\n\t\tvm_enable_cap(vm, KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2,\n\t\t\t      dirty_log_manual_caps);\n\n\tarch_setup_vm(vm, nr_vcpus);\n\n\t \n\titeration = 0;\n\thost_quit = false;\n\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\tfor (i = 0; i < nr_vcpus; i++)\n\t\tvcpu_last_completed_iteration[i] = -1;\n\n\t \n\tmemstress_set_write_percent(vm, 100);\n\tmemstress_set_random_access(vm, false);\n\tmemstress_start_vcpu_threads(nr_vcpus, vcpu_worker);\n\n\t \n\tpr_debug(\"Starting iteration %d - Populating\\n\", iteration);\n\tfor (i = 0; i < nr_vcpus; i++) {\n\t\twhile (READ_ONCE(vcpu_last_completed_iteration[i]) !=\n\t\t       iteration)\n\t\t\t;\n\t}\n\n\tts_diff = timespec_elapsed(start);\n\tpr_info(\"Populate memory time: %ld.%.9lds\\n\",\n\t\tts_diff.tv_sec, ts_diff.tv_nsec);\n\n\t \n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\tmemstress_enable_dirty_logging(vm, p->slots);\n\tts_diff = timespec_elapsed(start);\n\tpr_info(\"Enabling dirty logging time: %ld.%.9lds\\n\\n\",\n\t\tts_diff.tv_sec, ts_diff.tv_nsec);\n\n\tmemstress_set_write_percent(vm, p->write_percent);\n\tmemstress_set_random_access(vm, p->random_access);\n\n\twhile (iteration < p->iterations) {\n\t\t \n\t\tclock_gettime(CLOCK_MONOTONIC, &start);\n\t\titeration++;\n\n\t\tpr_debug(\"Starting iteration %d\\n\", iteration);\n\t\tfor (i = 0; i < nr_vcpus; i++) {\n\t\t\twhile (READ_ONCE(vcpu_last_completed_iteration[i])\n\t\t\t       != iteration)\n\t\t\t\t;\n\t\t}\n\n\t\tts_diff = timespec_elapsed(start);\n\t\tvcpu_dirty_total = timespec_add(vcpu_dirty_total, ts_diff);\n\t\tpr_info(\"Iteration %d dirty memory time: %ld.%.9lds\\n\",\n\t\t\titeration, ts_diff.tv_sec, ts_diff.tv_nsec);\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &start);\n\t\tmemstress_get_dirty_log(vm, bitmaps, p->slots);\n\t\tts_diff = timespec_elapsed(start);\n\t\tget_dirty_log_total = timespec_add(get_dirty_log_total,\n\t\t\t\t\t\t   ts_diff);\n\t\tpr_info(\"Iteration %d get dirty log time: %ld.%.9lds\\n\",\n\t\t\titeration, ts_diff.tv_sec, ts_diff.tv_nsec);\n\n\t\tif (dirty_log_manual_caps) {\n\t\t\tclock_gettime(CLOCK_MONOTONIC, &start);\n\t\t\tmemstress_clear_dirty_log(vm, bitmaps, p->slots,\n\t\t\t\t\t\t  pages_per_slot);\n\t\t\tts_diff = timespec_elapsed(start);\n\t\t\tclear_dirty_log_total = timespec_add(clear_dirty_log_total,\n\t\t\t\t\t\t\t     ts_diff);\n\t\t\tpr_info(\"Iteration %d clear dirty log time: %ld.%.9lds\\n\",\n\t\t\t\titeration, ts_diff.tv_sec, ts_diff.tv_nsec);\n\t\t}\n\t}\n\n\t \n\tif (run_vcpus_while_disabling_dirty_logging)\n\t\tWRITE_ONCE(iteration, -1);\n\n\t \n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\tmemstress_disable_dirty_logging(vm, p->slots);\n\tts_diff = timespec_elapsed(start);\n\tpr_info(\"Disabling dirty logging time: %ld.%.9lds\\n\",\n\t\tts_diff.tv_sec, ts_diff.tv_nsec);\n\n\t \n\thost_quit = true;\n\tmemstress_join_vcpu_threads(nr_vcpus);\n\n\tavg = timespec_div(get_dirty_log_total, p->iterations);\n\tpr_info(\"Get dirty log over %lu iterations took %ld.%.9lds. (Avg %ld.%.9lds/iteration)\\n\",\n\t\tp->iterations, get_dirty_log_total.tv_sec,\n\t\tget_dirty_log_total.tv_nsec, avg.tv_sec, avg.tv_nsec);\n\n\tif (dirty_log_manual_caps) {\n\t\tavg = timespec_div(clear_dirty_log_total, p->iterations);\n\t\tpr_info(\"Clear dirty log over %lu iterations took %ld.%.9lds. (Avg %ld.%.9lds/iteration)\\n\",\n\t\t\tp->iterations, clear_dirty_log_total.tv_sec,\n\t\t\tclear_dirty_log_total.tv_nsec, avg.tv_sec, avg.tv_nsec);\n\t}\n\n\tmemstress_free_bitmaps(bitmaps, p->slots);\n\tarch_cleanup_vm(vm);\n\tmemstress_destroy_vm(vm);\n}\n\nstatic void help(char *name)\n{\n\tputs(\"\");\n\tprintf(\"usage: %s [-h] [-a] [-i iterations] [-p offset] [-g] \"\n\t       \"[-m mode] [-n] [-b vcpu bytes] [-v vcpus] [-o] [-r random seed ] [-s mem type]\"\n\t       \"[-x memslots] [-w percentage] [-c physical cpus to run test on]\\n\", name);\n\tputs(\"\");\n\tprintf(\" -a: access memory randomly rather than in order.\\n\");\n\tprintf(\" -i: specify iteration counts (default: %\"PRIu64\")\\n\",\n\t       TEST_HOST_LOOP_N);\n\tprintf(\" -g: Do not enable KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2. This\\n\"\n\t       \"     makes KVM_GET_DIRTY_LOG clear the dirty log (i.e.\\n\"\n\t       \"     KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE is not enabled)\\n\"\n\t       \"     and writes will be tracked as soon as dirty logging is\\n\"\n\t       \"     enabled on the memslot (i.e. KVM_DIRTY_LOG_INITIALLY_SET\\n\"\n\t       \"     is not enabled).\\n\");\n\tprintf(\" -p: specify guest physical test memory offset\\n\"\n\t       \"     Warning: a low offset can conflict with the loaded test code.\\n\");\n\tguest_modes_help();\n\tprintf(\" -n: Run the vCPUs in nested mode (L2)\\n\");\n\tprintf(\" -e: Run vCPUs while dirty logging is being disabled.  This\\n\"\n\t       \"     can significantly increase runtime, especially if there\\n\"\n\t       \"     isn't a dedicated pCPU for the main thread.\\n\");\n\tprintf(\" -b: specify the size of the memory region which should be\\n\"\n\t       \"     dirtied by each vCPU. e.g. 10M or 3G.\\n\"\n\t       \"     (default: 1G)\\n\");\n\tprintf(\" -v: specify the number of vCPUs to run.\\n\");\n\tprintf(\" -o: Overlap guest memory accesses instead of partitioning\\n\"\n\t       \"     them into a separate region of memory for each vCPU.\\n\");\n\tprintf(\" -r: specify the starting random seed.\\n\");\n\tbacking_src_help(\"-s\");\n\tprintf(\" -x: Split the memory region into this number of memslots.\\n\"\n\t       \"     (default: 1)\\n\");\n\tprintf(\" -w: specify the percentage of pages which should be written to\\n\"\n\t       \"     as an integer from 0-100 inclusive. This is probabilistic,\\n\"\n\t       \"     so -w X means each page has an X%% chance of writing\\n\"\n\t       \"     and a (100-X)%% chance of reading.\\n\"\n\t       \"     (default: 100 i.e. all pages are written to.)\\n\");\n\tkvm_print_vcpu_pinning_help();\n\tputs(\"\");\n\texit(0);\n}\n\nint main(int argc, char *argv[])\n{\n\tint max_vcpus = kvm_check_cap(KVM_CAP_MAX_VCPUS);\n\tconst char *pcpu_list = NULL;\n\tstruct test_params p = {\n\t\t.iterations = TEST_HOST_LOOP_N,\n\t\t.partition_vcpu_memory_access = true,\n\t\t.backing_src = DEFAULT_VM_MEM_SRC,\n\t\t.slots = 1,\n\t\t.random_seed = 1,\n\t\t.write_percent = 100,\n\t};\n\tint opt;\n\n\tdirty_log_manual_caps =\n\t\tkvm_check_cap(KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2);\n\tdirty_log_manual_caps &= (KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE |\n\t\t\t\t  KVM_DIRTY_LOG_INITIALLY_SET);\n\n\tguest_modes_append_default();\n\n\twhile ((opt = getopt(argc, argv, \"ab:c:eghi:m:nop:r:s:v:x:w:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\tp.random_access = true;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tguest_percpu_mem_size = parse_size(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tpcpu_list = optarg;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\t \n\t\t\trun_vcpus_while_disabling_dirty_logging = true;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tdirty_log_manual_caps = 0;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tp.iterations = atoi_positive(\"Number of iterations\", optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tguest_modes_cmdline(optarg);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmemstress_args.nested = true;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tp.partition_vcpu_memory_access = false;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tp.phys_offset = strtoull(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tp.random_seed = atoi_positive(\"Random seed\", optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tp.backing_src = parse_backing_src_type(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tnr_vcpus = atoi_positive(\"Number of vCPUs\", optarg);\n\t\t\tTEST_ASSERT(nr_vcpus <= max_vcpus,\n\t\t\t\t    \"Invalid number of vcpus, must be between 1 and %d\", max_vcpus);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tp.write_percent = atoi_non_negative(\"Write percentage\", optarg);\n\t\t\tTEST_ASSERT(p.write_percent <= 100,\n\t\t\t\t    \"Write percentage must be between 0 and 100\");\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tp.slots = atoi_positive(\"Number of slots\", optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pcpu_list) {\n\t\tkvm_parse_vcpu_pinning(pcpu_list, memstress_args.vcpu_to_pcpu,\n\t\t\t\t       nr_vcpus);\n\t\tmemstress_args.pin_vcpus = true;\n\t}\n\n\tTEST_ASSERT(p.iterations >= 2, \"The test should have at least two iterations\");\n\n\tpr_info(\"Test iterations: %\"PRIu64\"\\n\",\tp.iterations);\n\n\tfor_each_guest_mode(run_test, &p);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}