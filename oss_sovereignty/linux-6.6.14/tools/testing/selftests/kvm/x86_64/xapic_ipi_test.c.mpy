{
  "module_name": "xapic_ipi_test.c",
  "hash_id": "e49a1dc50ac876ff2b75cf1269b5524b3dfcddf454fc1fd8beda7bb12c18ebd4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/xapic_ipi_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n#include <getopt.h>\n#include <pthread.h>\n#include <inttypes.h>\n#include <string.h>\n#include <time.h>\n\n#include \"kvm_util.h\"\n#include \"numaif.h\"\n#include \"processor.h\"\n#include \"test_util.h\"\n#include \"vmx.h\"\n\n \n#define DEFAULT_RUN_SECS 3\n\n \n#define DEFAULT_DELAY_USECS 500000\n\n \n#define IPI_VECTOR\t 0xa5\n\n \nstatic volatile uint64_t ipis_rcvd;\n\n \nstruct test_data_page {\n\tuint32_t halter_apic_id;\n\tvolatile uint64_t hlt_count;\n\tvolatile uint64_t wake_count;\n\tuint64_t ipis_sent;\n\tuint64_t migrations_attempted;\n\tuint64_t migrations_completed;\n\tuint32_t icr;\n\tuint32_t icr2;\n\tuint32_t halter_tpr;\n\tuint32_t halter_ppr;\n\n\t \n\tuint32_t halter_lvr;\n};\n\nstruct thread_params {\n\tstruct test_data_page *data;\n\tstruct kvm_vcpu *vcpu;\n\tuint64_t *pipis_rcvd;  \n};\n\nvoid verify_apic_base_addr(void)\n{\n\tuint64_t msr = rdmsr(MSR_IA32_APICBASE);\n\tuint64_t base = GET_APIC_BASE(msr);\n\n\tGUEST_ASSERT(base == APIC_DEFAULT_GPA);\n}\n\nstatic void halter_guest_code(struct test_data_page *data)\n{\n\tverify_apic_base_addr();\n\txapic_enable();\n\n\tdata->halter_apic_id = GET_APIC_ID_FIELD(xapic_read_reg(APIC_ID));\n\tdata->halter_lvr = xapic_read_reg(APIC_LVR);\n\n\t \n\tfor (;;) {\n\t\tdata->halter_tpr = xapic_read_reg(APIC_TASKPRI);\n\t\tdata->halter_ppr = xapic_read_reg(APIC_PROCPRI);\n\t\tdata->hlt_count++;\n\t\tasm volatile(\"sti; hlt; cli\");\n\t\tdata->wake_count++;\n\t}\n}\n\n \nstatic void guest_ipi_handler(struct ex_regs *regs)\n{\n\tipis_rcvd++;\n\txapic_write_reg(APIC_EOI, 77);\n}\n\nstatic void sender_guest_code(struct test_data_page *data)\n{\n\tuint64_t last_wake_count;\n\tuint64_t last_hlt_count;\n\tuint64_t last_ipis_rcvd_count;\n\tuint32_t icr_val;\n\tuint32_t icr2_val;\n\tuint64_t tsc_start;\n\n\tverify_apic_base_addr();\n\txapic_enable();\n\n\t \n\ticr_val = (APIC_DEST_PHYSICAL | APIC_DM_FIXED | IPI_VECTOR);\n\ticr2_val = SET_APIC_DEST_FIELD(data->halter_apic_id);\n\tdata->icr = icr_val;\n\tdata->icr2 = icr2_val;\n\n\tlast_wake_count = data->wake_count;\n\tlast_hlt_count = data->hlt_count;\n\tlast_ipis_rcvd_count = ipis_rcvd;\n\tfor (;;) {\n\t\t \n\t\txapic_write_reg(APIC_ICR2, icr2_val);\n\t\txapic_write_reg(APIC_ICR, icr_val);\n\t\tdata->ipis_sent++;\n\n\t\t \n\t\ttsc_start = rdtsc();\n\t\twhile (rdtsc() - tsc_start < 2000000000) {\n\t\t\tif ((ipis_rcvd != last_ipis_rcvd_count) &&\n\t\t\t    (data->wake_count != last_wake_count) &&\n\t\t\t    (data->hlt_count != last_hlt_count))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tGUEST_ASSERT((ipis_rcvd != last_ipis_rcvd_count) &&\n\t\t\t     (data->wake_count != last_wake_count) &&\n\t\t\t     (data->hlt_count != last_hlt_count));\n\n\t\tlast_wake_count = data->wake_count;\n\t\tlast_hlt_count = data->hlt_count;\n\t\tlast_ipis_rcvd_count = ipis_rcvd;\n\t}\n}\n\nstatic void *vcpu_thread(void *arg)\n{\n\tstruct thread_params *params = (struct thread_params *)arg;\n\tstruct kvm_vcpu *vcpu = params->vcpu;\n\tstruct ucall uc;\n\tint old;\n\tint r;\n\n\tr = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &old);\n\tTEST_ASSERT(r == 0,\n\t\t    \"pthread_setcanceltype failed on vcpu_id=%u with errno=%d\",\n\t\t    vcpu->id, r);\n\n\tfprintf(stderr, \"vCPU thread running vCPU %u\\n\", vcpu->id);\n\tvcpu_run(vcpu);\n\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\tif (get_ucall(vcpu, &uc) == UCALL_ABORT) {\n\t\tTEST_ASSERT(false,\n\t\t\t    \"vCPU %u exited with error: %s.\\n\"\n\t\t\t    \"Sending vCPU sent %lu IPIs to halting vCPU\\n\"\n\t\t\t    \"Halting vCPU halted %lu times, woke %lu times, received %lu IPIs.\\n\"\n\t\t\t    \"Halter TPR=%#x PPR=%#x LVR=%#x\\n\"\n\t\t\t    \"Migrations attempted: %lu\\n\"\n\t\t\t    \"Migrations completed: %lu\\n\",\n\t\t\t    vcpu->id, (const char *)uc.args[0],\n\t\t\t    params->data->ipis_sent, params->data->hlt_count,\n\t\t\t    params->data->wake_count,\n\t\t\t    *params->pipis_rcvd, params->data->halter_tpr,\n\t\t\t    params->data->halter_ppr, params->data->halter_lvr,\n\t\t\t    params->data->migrations_attempted,\n\t\t\t    params->data->migrations_completed);\n\t}\n\n\treturn NULL;\n}\n\nstatic void cancel_join_vcpu_thread(pthread_t thread, struct kvm_vcpu *vcpu)\n{\n\tvoid *retval;\n\tint r;\n\n\tr = pthread_cancel(thread);\n\tTEST_ASSERT(r == 0,\n\t\t    \"pthread_cancel on vcpu_id=%d failed with errno=%d\",\n\t\t    vcpu->id, r);\n\n\tr = pthread_join(thread, &retval);\n\tTEST_ASSERT(r == 0,\n\t\t    \"pthread_join on vcpu_id=%d failed with errno=%d\",\n\t\t    vcpu->id, r);\n\tTEST_ASSERT(retval == PTHREAD_CANCELED,\n\t\t    \"expected retval=%p, got %p\", PTHREAD_CANCELED,\n\t\t    retval);\n}\n\nvoid do_migrations(struct test_data_page *data, int run_secs, int delay_usecs,\n\t\t   uint64_t *pipis_rcvd)\n{\n\tlong pages_not_moved;\n\tunsigned long nodemask = 0;\n\tunsigned long nodemasks[sizeof(nodemask) * 8];\n\tint nodes = 0;\n\ttime_t start_time, last_update, now;\n\ttime_t interval_secs = 1;\n\tint i, r;\n\tint from, to;\n\tunsigned long bit;\n\tuint64_t hlt_count;\n\tuint64_t wake_count;\n\tuint64_t ipis_sent;\n\n\tfprintf(stderr, \"Calling migrate_pages every %d microseconds\\n\",\n\t\tdelay_usecs);\n\n\t \n\tr = get_mempolicy(NULL, &nodemask, sizeof(nodemask) * 8,\n\t\t\t  0, MPOL_F_MEMS_ALLOWED);\n\tTEST_ASSERT(r == 0, \"get_mempolicy failed errno=%d\", errno);\n\n\tfprintf(stderr, \"Numa nodes found amongst first %lu possible nodes \"\n\t\t\"(each 1-bit indicates node is present): %#lx\\n\",\n\t\tsizeof(nodemask) * 8, nodemask);\n\n\t \n\tfor (i = 0, bit = 1; i < sizeof(nodemask) * 8; i++, bit <<= 1) {\n\t\tif (nodemask & bit) {\n\t\t\tnodemasks[nodes] = nodemask & bit;\n\t\t\tnodes++;\n\t\t}\n\t}\n\n\tTEST_ASSERT(nodes > 1,\n\t\t    \"Did not find at least 2 numa nodes. Can't do migration\\n\");\n\n\tfprintf(stderr, \"Migrating amongst %d nodes found\\n\", nodes);\n\n\tfrom = 0;\n\tto = 1;\n\tstart_time = time(NULL);\n\tlast_update = start_time;\n\n\tipis_sent = data->ipis_sent;\n\thlt_count = data->hlt_count;\n\twake_count = data->wake_count;\n\n\twhile ((int)(time(NULL) - start_time) < run_secs) {\n\t\tdata->migrations_attempted++;\n\n\t\t \n\t\tpages_not_moved = migrate_pages(0, sizeof(nodemasks[from]),\n\t\t\t\t\t\t&nodemasks[from],\n\t\t\t\t\t\t&nodemasks[to]);\n\t\tif (pages_not_moved < 0)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"migrate_pages failed, errno=%d\\n\", errno);\n\t\telse if (pages_not_moved > 0)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"migrate_pages could not move %ld pages\\n\",\n\t\t\t\tpages_not_moved);\n\t\telse\n\t\t\tdata->migrations_completed++;\n\n\t\tfrom = to;\n\t\tto++;\n\t\tif (to == nodes)\n\t\t\tto = 0;\n\n\t\tnow = time(NULL);\n\t\tif (((now - start_time) % interval_secs == 0) &&\n\t\t    (now != last_update)) {\n\t\t\tlast_update = now;\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%lu seconds: Migrations attempted=%lu completed=%lu, \"\n\t\t\t\t\"IPIs sent=%lu received=%lu, HLTs=%lu wakes=%lu\\n\",\n\t\t\t\tnow - start_time, data->migrations_attempted,\n\t\t\t\tdata->migrations_completed,\n\t\t\t\tdata->ipis_sent, *pipis_rcvd,\n\t\t\t\tdata->hlt_count, data->wake_count);\n\n\t\t\tTEST_ASSERT(ipis_sent != data->ipis_sent &&\n\t\t\t\t    hlt_count != data->hlt_count &&\n\t\t\t\t    wake_count != data->wake_count,\n\t\t\t\t    \"IPI, HLT and wake count have not increased \"\n\t\t\t\t    \"in the last %lu seconds. \"\n\t\t\t\t    \"HLTer is likely hung.\\n\", interval_secs);\n\n\t\t\tipis_sent = data->ipis_sent;\n\t\t\thlt_count = data->hlt_count;\n\t\t\twake_count = data->wake_count;\n\t\t}\n\t\tusleep(delay_usecs);\n\t}\n}\n\nvoid get_cmdline_args(int argc, char *argv[], int *run_secs,\n\t\t      bool *migrate, int *delay_usecs)\n{\n\tfor (;;) {\n\t\tint opt = getopt(argc, argv, \"s:d:m\");\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\t*run_secs = parse_size(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\t*migrate = true;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t*delay_usecs = parse_size(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTEST_ASSERT(false,\n\t\t\t\t    \"Usage: -s <runtime seconds>. Default is %d seconds.\\n\"\n\t\t\t\t    \"-m adds calls to migrate_pages while vCPUs are running.\"\n\t\t\t\t    \" Default is no migrations.\\n\"\n\t\t\t\t    \"-d <delay microseconds> - delay between migrate_pages() calls.\"\n\t\t\t\t    \" Default is %d microseconds.\\n\",\n\t\t\t\t    DEFAULT_RUN_SECS, DEFAULT_DELAY_USECS);\n\t\t}\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint r;\n\tint wait_secs;\n\tconst int max_halter_wait = 10;\n\tint run_secs = 0;\n\tint delay_usecs = 0;\n\tstruct test_data_page *data;\n\tvm_vaddr_t test_data_page_vaddr;\n\tbool migrate = false;\n\tpthread_t threads[2];\n\tstruct thread_params params[2];\n\tstruct kvm_vm *vm;\n\tuint64_t *pipis_rcvd;\n\n\tget_cmdline_args(argc, argv, &run_secs, &migrate, &delay_usecs);\n\tif (run_secs <= 0)\n\t\trun_secs = DEFAULT_RUN_SECS;\n\tif (delay_usecs <= 0)\n\t\tdelay_usecs = DEFAULT_DELAY_USECS;\n\n\tvm = vm_create_with_one_vcpu(&params[0].vcpu, halter_guest_code);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(params[0].vcpu);\n\tvm_install_exception_handler(vm, IPI_VECTOR, guest_ipi_handler);\n\n\tvirt_pg_map(vm, APIC_DEFAULT_GPA, APIC_DEFAULT_GPA);\n\n\tparams[1].vcpu = vm_vcpu_add(vm, 1, sender_guest_code);\n\n\ttest_data_page_vaddr = vm_vaddr_alloc_page(vm);\n\tdata = addr_gva2hva(vm, test_data_page_vaddr);\n\tmemset(data, 0, sizeof(*data));\n\tparams[0].data = data;\n\tparams[1].data = data;\n\n\tvcpu_args_set(params[0].vcpu, 1, test_data_page_vaddr);\n\tvcpu_args_set(params[1].vcpu, 1, test_data_page_vaddr);\n\n\tpipis_rcvd = (uint64_t *)addr_gva2hva(vm, (uint64_t)&ipis_rcvd);\n\tparams[0].pipis_rcvd = pipis_rcvd;\n\tparams[1].pipis_rcvd = pipis_rcvd;\n\n\t \n\tr = pthread_create(&threads[0], NULL, vcpu_thread, &params[0]);\n\tTEST_ASSERT(r == 0,\n\t\t    \"pthread_create halter failed errno=%d\", errno);\n\tfprintf(stderr, \"Halter vCPU thread started\\n\");\n\n\twait_secs = 0;\n\twhile ((wait_secs < max_halter_wait) && !data->hlt_count) {\n\t\tsleep(1);\n\t\twait_secs++;\n\t}\n\n\tTEST_ASSERT(data->hlt_count,\n\t\t    \"Halter vCPU did not execute first HLT within %d seconds\",\n\t\t    max_halter_wait);\n\n\tfprintf(stderr,\n\t\t\"Halter vCPU thread reported its APIC ID: %u after %d seconds.\\n\",\n\t\tdata->halter_apic_id, wait_secs);\n\n\tr = pthread_create(&threads[1], NULL, vcpu_thread, &params[1]);\n\tTEST_ASSERT(r == 0, \"pthread_create sender failed errno=%d\", errno);\n\n\tfprintf(stderr,\n\t\t\"IPI sender vCPU thread started. Letting vCPUs run for %d seconds.\\n\",\n\t\trun_secs);\n\n\tif (!migrate)\n\t\tsleep(run_secs);\n\telse\n\t\tdo_migrations(data, run_secs, delay_usecs, pipis_rcvd);\n\n\t \n\tcancel_join_vcpu_thread(threads[0], params[0].vcpu);\n\tcancel_join_vcpu_thread(threads[1], params[1].vcpu);\n\n\tfprintf(stderr,\n\t\t\"Test successful after running for %d seconds.\\n\"\n\t\t\"Sending vCPU sent %lu IPIs to halting vCPU\\n\"\n\t\t\"Halting vCPU halted %lu times, woke %lu times, received %lu IPIs.\\n\"\n\t\t\"Halter APIC ID=%#x\\n\"\n\t\t\"Sender ICR value=%#x ICR2 value=%#x\\n\"\n\t\t\"Halter TPR=%#x PPR=%#x LVR=%#x\\n\"\n\t\t\"Migrations attempted: %lu\\n\"\n\t\t\"Migrations completed: %lu\\n\",\n\t\trun_secs, data->ipis_sent,\n\t\tdata->hlt_count, data->wake_count, *pipis_rcvd,\n\t\tdata->halter_apic_id,\n\t\tdata->icr, data->icr2,\n\t\tdata->halter_tpr, data->halter_ppr, data->halter_lvr,\n\t\tdata->migrations_attempted, data->migrations_completed);\n\n\tkvm_vm_free(vm);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}