{
  "module_name": "userspace_io_test.c",
  "hash_id": "c1f40aaea7f30c31ac51a573981859d6ad4ecec9af348c5f32654ae2a5a0f966",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/userspace_io_test.c",
  "human_readable_source": "\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\nstatic void guest_ins_port80(uint8_t *buffer, unsigned int count)\n{\n\tunsigned long end;\n\n\tif (count == 2)\n\t\tend = (unsigned long)buffer + 1;\n\telse\n\t\tend = (unsigned long)buffer + 8192;\n\n\tasm volatile(\"cld; rep; insb\" : \"+D\"(buffer), \"+c\"(count) : \"d\"(0x80) : \"memory\");\n\tGUEST_ASSERT_EQ(count, 0);\n\tGUEST_ASSERT_EQ((unsigned long)buffer, end);\n}\n\nstatic void guest_code(void)\n{\n\tuint8_t buffer[8192];\n\tint i;\n\n\t \n\tguest_ins_port80(buffer, 2);\n\tguest_ins_port80(buffer, 3);\n\n\t \n\tmemset(buffer, 0, sizeof(buffer));\n\tguest_ins_port80(buffer, 8192);\n\tfor (i = 0; i < 8192; i++)\n\t\t__GUEST_ASSERT(buffer[i] == 0xaa,\n\t\t\t       \"Expected '0xaa', got '0x%x' at buffer[%u]\",\n\t\t\t       buffer[i], i);\n\n\tGUEST_DONE();\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_regs regs;\n\tstruct kvm_run *run;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\trun = vcpu->run;\n\n\tmemset(&regs, 0, sizeof(regs));\n\n\twhile (1) {\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tif (get_ucall(vcpu, &uc))\n\t\t\tbreak;\n\n\t\tTEST_ASSERT(run->io.port == 0x80,\n\t\t\t    \"Expected I/O at port 0x80, got port 0x%x\\n\", run->io.port);\n\n\t\t \n\t\tvcpu_regs_get(vcpu, &regs);\n\t\tif (regs.rcx == 2)\n\t\t\tregs.rcx = 1;\n\t\tif (regs.rcx == 3)\n\t\t\tregs.rcx = 8192;\n\t\tmemset((void *)run + run->io.data_offset, 0xaa, 4096);\n\t\tvcpu_regs_set(vcpu, &regs);\n\t}\n\n\tswitch (uc.cmd) {\n\tcase UCALL_DONE:\n\t\tbreak;\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\tdefault:\n\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t}\n\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}