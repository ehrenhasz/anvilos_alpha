{
  "module_name": "xcr0_cpuid_test.c",
  "hash_id": "2151b276024c4cd7f8c3c4d9bb6ab4904bbc3a513c0d459cc7bbddcc83a85ecc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/xcr0_cpuid_test.c",
  "human_readable_source": "\n \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n \n#define ASSERT_XFEATURE_DEPENDENCIES(supported_xcr0, xfeatures, dependencies)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\t\\\n\tuint64_t __supported = (supported_xcr0) & ((xfeatures) | (dependencies));\t\\\n\t\t\t\t\t\t\t\t\t\t\t\\\n\t__GUEST_ASSERT((__supported & (xfeatures)) != (xfeatures) ||\t\t\t\\\n\t\t       __supported == ((xfeatures) | (dependencies)),\t\t\t\\\n\t\t       \"supported = 0x%llx, xfeatures = 0x%llx, dependencies = 0x%llx\",\t\\\n\t\t       __supported, (xfeatures), (dependencies));\t\t\t\\\n} while (0)\n\n \n#define ASSERT_ALL_OR_NONE_XFEATURE(supported_xcr0, xfeatures)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tuint64_t __supported = (supported_xcr0) & (xfeatures);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__GUEST_ASSERT(!__supported || __supported == (xfeatures),\t\\\n\t\t       \"supported = 0x%llx, xfeatures = 0x%llx\",\t\\\n\t\t       __supported, (xfeatures));\t\t\t\\\n} while (0)\n\nstatic void guest_code(void)\n{\n\tuint64_t xcr0_reset;\n\tuint64_t supported_xcr0;\n\tint i, vector;\n\n\tset_cr4(get_cr4() | X86_CR4_OSXSAVE);\n\n\txcr0_reset = xgetbv(0);\n\tsupported_xcr0 = this_cpu_supported_xcr0();\n\n\tGUEST_ASSERT(xcr0_reset == XFEATURE_MASK_FP);\n\n\t \n\tASSERT_XFEATURE_DEPENDENCIES(supported_xcr0,\n\t\t\t\t     XFEATURE_MASK_YMM,\n\t\t\t\t     XFEATURE_MASK_SSE);\n\n\t \n\tASSERT_ALL_OR_NONE_XFEATURE(supported_xcr0,\n\t\t\t\t    XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\t \n\tASSERT_XFEATURE_DEPENDENCIES(supported_xcr0,\n\t\t\t\t     XFEATURE_MASK_AVX512,\n\t\t\t\t     XFEATURE_MASK_SSE | XFEATURE_MASK_YMM);\n\tASSERT_ALL_OR_NONE_XFEATURE(supported_xcr0,\n\t\t\t\t    XFEATURE_MASK_AVX512);\n\n\t \n\tASSERT_ALL_OR_NONE_XFEATURE(supported_xcr0,\n\t\t\t\t    XFEATURE_MASK_XTILE);\n\n\tvector = xsetbv_safe(0, supported_xcr0);\n\t__GUEST_ASSERT(!vector,\n\t\t       \"Expected success on XSETBV(0x%llx), got vector '0x%x'\",\n\t\t       supported_xcr0, vector);\n\n\tfor (i = 0; i < 64; i++) {\n\t\tif (supported_xcr0 & BIT_ULL(i))\n\t\t\tcontinue;\n\n\t\tvector = xsetbv_safe(0, supported_xcr0 | BIT_ULL(i));\n\t\t__GUEST_ASSERT(vector == GP_VECTOR,\n\t\t\t       \"Expected #GP on XSETBV(0x%llx), supported XCR0 = %llx, got vector '0x%x'\",\n\t\t\t       BIT_ULL(i), supported_xcr0, vector);\n\t}\n\n\tGUEST_DONE();\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_run *run;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_XSAVE));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\trun = vcpu->run;\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\twhile (1) {\n\t\tvcpu_run(vcpu);\n\n\t\tTEST_ASSERT(run->exit_reason == KVM_EXIT_IO,\n\t\t\t    \"Unexpected exit reason: %u (%s),\\n\",\n\t\t\t    run->exit_reason,\n\t\t\t    exit_reason_str(run->exit_reason));\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\t}\n\ndone:\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}