{
  "module_name": "nx_huge_pages_test.c",
  "hash_id": "2c2f24f78789835fee4d3732f81132b5561979792bf03004e006f494526a0278",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/nx_huge_pages_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <fcntl.h>\n#include <stdint.h>\n#include <time.h>\n\n#include <test_util.h>\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n#define HPAGE_SLOT\t\t10\n#define HPAGE_GPA\t\t(4UL << 30)  \n#define HPAGE_GVA\t\tHPAGE_GPA  \n#define PAGES_PER_2MB_HUGE_PAGE 512\n#define HPAGE_SLOT_NPAGES\t(3 * PAGES_PER_2MB_HUGE_PAGE)\n\n \n#define MAGIC_TOKEN 887563923\n\n \n#define RETURN_OPCODE 0xC3\n\n \nstatic void guest_do_CALL(uint64_t target)\n{\n\t((void (*)(void)) target)();\n}\n\n \nvoid guest_code(void)\n{\n\tuint64_t hpage_1 = HPAGE_GVA;\n\tuint64_t hpage_2 = hpage_1 + (PAGE_SIZE * 512);\n\tuint64_t hpage_3 = hpage_2 + (PAGE_SIZE * 512);\n\n\tREAD_ONCE(*(uint64_t *)hpage_1);\n\tGUEST_SYNC(1);\n\n\tREAD_ONCE(*(uint64_t *)hpage_2);\n\tGUEST_SYNC(2);\n\n\tguest_do_CALL(hpage_1);\n\tGUEST_SYNC(3);\n\n\tguest_do_CALL(hpage_3);\n\tGUEST_SYNC(4);\n\n\tREAD_ONCE(*(uint64_t *)hpage_1);\n\tGUEST_SYNC(5);\n\n\tREAD_ONCE(*(uint64_t *)hpage_3);\n\tGUEST_SYNC(6);\n}\n\nstatic void check_2m_page_count(struct kvm_vm *vm, int expected_pages_2m)\n{\n\tint actual_pages_2m;\n\n\tactual_pages_2m = vm_get_stat(vm, \"pages_2m\");\n\n\tTEST_ASSERT(actual_pages_2m == expected_pages_2m,\n\t\t    \"Unexpected 2m page count. Expected %d, got %d\",\n\t\t    expected_pages_2m, actual_pages_2m);\n}\n\nstatic void check_split_count(struct kvm_vm *vm, int expected_splits)\n{\n\tint actual_splits;\n\n\tactual_splits = vm_get_stat(vm, \"nx_lpage_splits\");\n\n\tTEST_ASSERT(actual_splits == expected_splits,\n\t\t    \"Unexpected NX huge page split count. Expected %d, got %d\",\n\t\t    expected_splits, actual_splits);\n}\n\nstatic void wait_for_reclaim(int reclaim_period_ms)\n{\n\tlong reclaim_wait_ms;\n\tstruct timespec ts;\n\n\treclaim_wait_ms = reclaim_period_ms * 5;\n\tts.tv_sec = reclaim_wait_ms / 1000;\n\tts.tv_nsec = (reclaim_wait_ms - (ts.tv_sec * 1000)) * 1000000;\n\tnanosleep(&ts, NULL);\n}\n\nvoid run_test(int reclaim_period_ms, bool disable_nx_huge_pages,\n\t      bool reboot_permissions)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tuint64_t nr_bytes;\n\tvoid *hva;\n\tint r;\n\n\tvm = vm_create(1);\n\n\tif (disable_nx_huge_pages) {\n\t\tr = __vm_disable_nx_huge_pages(vm);\n\t\tif (reboot_permissions) {\n\t\t\tTEST_ASSERT(!r, \"Disabling NX huge pages should succeed if process has reboot permissions\");\n\t\t} else {\n\t\t\tTEST_ASSERT(r == -1 && errno == EPERM,\n\t\t\t\t    \"This process should not have permission to disable NX huge pages\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvcpu = vm_vcpu_add(vm, 0, guest_code);\n\n\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS_HUGETLB,\n\t\t\t\t    HPAGE_GPA, HPAGE_SLOT,\n\t\t\t\t    HPAGE_SLOT_NPAGES, 0);\n\n\tnr_bytes = HPAGE_SLOT_NPAGES * vm->page_size;\n\n\t \n\tif (kvm_is_tdp_enabled())\n\t\tvirt_map_level(vm, HPAGE_GVA, HPAGE_GPA, nr_bytes, PG_LEVEL_4K);\n\telse\n\t\tvirt_map_level(vm, HPAGE_GVA, HPAGE_GPA, nr_bytes, PG_LEVEL_2M);\n\n\thva = addr_gpa2hva(vm, HPAGE_GPA);\n\tmemset(hva, RETURN_OPCODE, nr_bytes);\n\n\tcheck_2m_page_count(vm, 0);\n\tcheck_split_count(vm, 0);\n\n\t \n\tvcpu_run(vcpu);\n\tcheck_2m_page_count(vm, 1);\n\tcheck_split_count(vm, 0);\n\n\t \n\tvcpu_run(vcpu);\n\tcheck_2m_page_count(vm, 2);\n\tcheck_split_count(vm, 0);\n\n\t \n\tvcpu_run(vcpu);\n\tcheck_2m_page_count(vm, disable_nx_huge_pages ? 2 : 1);\n\tcheck_split_count(vm, disable_nx_huge_pages ? 0 : 1);\n\n\t \n\tvcpu_run(vcpu);\n\tcheck_2m_page_count(vm, disable_nx_huge_pages ? 3 : 1);\n\tcheck_split_count(vm, disable_nx_huge_pages ? 0 : 2);\n\n\t \n\tvcpu_run(vcpu);\n\tcheck_2m_page_count(vm, disable_nx_huge_pages ? 3 : 1);\n\tcheck_split_count(vm, disable_nx_huge_pages ? 0 : 2);\n\n\t \n\twait_for_reclaim(reclaim_period_ms);\n\n\t \n\tcheck_2m_page_count(vm, disable_nx_huge_pages ? 3 : 1);\n\tcheck_split_count(vm, 0);\n\n\t \n\tvcpu_run(vcpu);\n\tcheck_2m_page_count(vm, disable_nx_huge_pages ? 3 : 2);\n\tcheck_split_count(vm, 0);\n\n\tkvm_vm_free(vm);\n}\n\nstatic void help(char *name)\n{\n\tputs(\"\");\n\tprintf(\"usage: %s [-h] [-p period_ms] [-t token]\\n\", name);\n\tputs(\"\");\n\tprintf(\" -p: The NX reclaim period in milliseconds.\\n\");\n\tprintf(\" -t: The magic token to indicate environment setup is done.\\n\");\n\tprintf(\" -r: The test has reboot permissions and can disable NX huge pages.\\n\");\n\tputs(\"\");\n\texit(0);\n}\n\nint main(int argc, char **argv)\n{\n\tint reclaim_period_ms = 0, token = 0, opt;\n\tbool reboot_permissions = false;\n\n\twhile ((opt = getopt(argc, argv, \"hp:t:r\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'p':\n\t\t\treclaim_period_ms = atoi_positive(\"Reclaim period\", optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttoken = atoi_paranoid(optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\treboot_permissions = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_VM_DISABLE_NX_HUGE_PAGES));\n\n\t__TEST_REQUIRE(token == MAGIC_TOKEN,\n\t\t       \"This test must be run with the magic token %d.\\n\"\n\t\t       \"This is done by nx_huge_pages_test.sh, which\\n\"\n\t\t       \"also handles environment setup for the test.\");\n\n\trun_test(reclaim_period_ms, false, reboot_permissions);\n\trun_test(reclaim_period_ms, true, reboot_permissions);\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}