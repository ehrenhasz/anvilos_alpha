{
  "module_name": "amx_test.c",
  "hash_id": "fddfb5f46fb47f9844fa2bba549b667460fd085fef258f5c7182c25b8bcfd72a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/amx_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n\n#include \"test_util.h\"\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n\n#ifndef __x86_64__\n# error This test is 64-bit only\n#endif\n\n#define NUM_TILES\t\t\t8\n#define TILE_SIZE\t\t\t1024\n#define XSAVE_SIZE\t\t\t((NUM_TILES * TILE_SIZE) + PAGE_SIZE)\n\n \n#define PALETTE_TABLE_INDEX\t\t1\n#define MAX_TILES\t\t\t16\n#define RESERVED_BYTES\t\t\t14\n\n#define XSAVE_HDR_OFFSET\t\t512\n\nstruct tile_config {\n\tu8  palette_id;\n\tu8  start_row;\n\tu8  reserved[RESERVED_BYTES];\n\tu16 colsb[MAX_TILES];\n\tu8  rows[MAX_TILES];\n};\n\nstruct tile_data {\n\tu8 data[NUM_TILES * TILE_SIZE];\n};\n\nstruct xtile_info {\n\tu16 bytes_per_tile;\n\tu16 bytes_per_row;\n\tu16 max_names;\n\tu16 max_rows;\n\tu32 xsave_offset;\n\tu32 xsave_size;\n};\n\nstatic struct xtile_info xtile;\n\nstatic inline void __ldtilecfg(void *cfg)\n{\n\tasm volatile(\".byte 0xc4,0xe2,0x78,0x49,0x00\"\n\t\t     : : \"a\"(cfg));\n}\n\nstatic inline void __tileloadd(void *tile)\n{\n\tasm volatile(\".byte 0xc4,0xe2,0x7b,0x4b,0x04,0x10\"\n\t\t     : : \"a\"(tile), \"d\"(0));\n}\n\nstatic inline void __tilerelease(void)\n{\n\tasm volatile(\".byte 0xc4, 0xe2, 0x78, 0x49, 0xc0\" ::);\n}\n\nstatic inline void __xsavec(struct xstate *xstate, uint64_t rfbm)\n{\n\tuint32_t rfbm_lo = rfbm;\n\tuint32_t rfbm_hi = rfbm >> 32;\n\n\tasm volatile(\"xsavec (%%rdi)\"\n\t\t     : : \"D\" (xstate), \"a\" (rfbm_lo), \"d\" (rfbm_hi)\n\t\t     : \"memory\");\n}\n\nstatic void check_xtile_info(void)\n{\n\tGUEST_ASSERT(this_cpu_has_p(X86_PROPERTY_XSTATE_MAX_SIZE_XCR0));\n\tGUEST_ASSERT(this_cpu_property(X86_PROPERTY_XSTATE_MAX_SIZE_XCR0) <= XSAVE_SIZE);\n\n\txtile.xsave_offset = this_cpu_property(X86_PROPERTY_XSTATE_TILE_OFFSET);\n\tGUEST_ASSERT(xtile.xsave_offset == 2816);\n\txtile.xsave_size = this_cpu_property(X86_PROPERTY_XSTATE_TILE_SIZE);\n\tGUEST_ASSERT(xtile.xsave_size == 8192);\n\tGUEST_ASSERT(sizeof(struct tile_data) >= xtile.xsave_size);\n\n\tGUEST_ASSERT(this_cpu_has_p(X86_PROPERTY_AMX_MAX_PALETTE_TABLES));\n\tGUEST_ASSERT(this_cpu_property(X86_PROPERTY_AMX_MAX_PALETTE_TABLES) >=\n\t\t     PALETTE_TABLE_INDEX);\n\n\tGUEST_ASSERT(this_cpu_has_p(X86_PROPERTY_AMX_NR_TILE_REGS));\n\txtile.max_names = this_cpu_property(X86_PROPERTY_AMX_NR_TILE_REGS);\n\tGUEST_ASSERT(xtile.max_names == 8);\n\txtile.bytes_per_tile = this_cpu_property(X86_PROPERTY_AMX_BYTES_PER_TILE);\n\tGUEST_ASSERT(xtile.bytes_per_tile == 1024);\n\txtile.bytes_per_row = this_cpu_property(X86_PROPERTY_AMX_BYTES_PER_ROW);\n\tGUEST_ASSERT(xtile.bytes_per_row == 64);\n\txtile.max_rows = this_cpu_property(X86_PROPERTY_AMX_MAX_ROWS);\n\tGUEST_ASSERT(xtile.max_rows == 16);\n}\n\nstatic void set_tilecfg(struct tile_config *cfg)\n{\n\tint i;\n\n\t \n\tcfg->palette_id = 1;\n\tfor (i = 0; i < xtile.max_names; i++) {\n\t\tcfg->colsb[i] = xtile.bytes_per_row;\n\t\tcfg->rows[i] = xtile.max_rows;\n\t}\n}\n\nstatic void init_regs(void)\n{\n\tuint64_t cr4, xcr0;\n\n\tGUEST_ASSERT(this_cpu_has(X86_FEATURE_XSAVE));\n\n\t \n\tcr4 = get_cr4();\n\tcr4 |= X86_CR4_OSXSAVE;\n\tset_cr4(cr4);\n\tGUEST_ASSERT(this_cpu_has(X86_FEATURE_OSXSAVE));\n\n\txcr0 = xgetbv(0);\n\txcr0 |= XFEATURE_MASK_XTILE;\n\txsetbv(0x0, xcr0);\n\tGUEST_ASSERT((xgetbv(0) & XFEATURE_MASK_XTILE) == XFEATURE_MASK_XTILE);\n}\n\nstatic void __attribute__((__flatten__)) guest_code(struct tile_config *amx_cfg,\n\t\t\t\t\t\t    struct tile_data *tiledata,\n\t\t\t\t\t\t    struct xstate *xstate)\n{\n\tinit_regs();\n\tcheck_xtile_info();\n\tGUEST_SYNC(1);\n\n\t \n\twrmsr(MSR_IA32_XFD, 0);\n\tGUEST_SYNC(2);\n\tGUEST_ASSERT(rdmsr(MSR_IA32_XFD) == 0);\n\tset_tilecfg(amx_cfg);\n\t__ldtilecfg(amx_cfg);\n\tGUEST_SYNC(3);\n\t \n\t__tileloadd(tiledata);\n\tGUEST_SYNC(4);\n\t__tilerelease();\n\tGUEST_SYNC(5);\n\t \n\txstate->header.xstate_bv = XFEATURE_MASK_XTILE_DATA;\n\t__xsavec(xstate, XFEATURE_MASK_XTILE_DATA);\n\tGUEST_ASSERT(!(xstate->header.xstate_bv & XFEATURE_MASK_XTILE_DATA));\n\tGUEST_ASSERT(xstate->header.xcomp_bv & XFEATURE_MASK_XTILE_DATA);\n\n\t \n\twrmsr(MSR_IA32_XFD, XFEATURE_MASK_XTILE_DATA);\n\n\t \n\txstate->header.xstate_bv = XFEATURE_MASK_XTILE_DATA;\n\t__xsavec(xstate, XFEATURE_MASK_XTILE_DATA);\n\tGUEST_ASSERT(!(xstate->header.xstate_bv & XFEATURE_MASK_XTILE_DATA));\n\tGUEST_ASSERT((xstate->header.xcomp_bv & XFEATURE_MASK_XTILE_DATA));\n\n\tGUEST_SYNC(6);\n\tGUEST_ASSERT(rdmsr(MSR_IA32_XFD) == XFEATURE_MASK_XTILE_DATA);\n\tset_tilecfg(amx_cfg);\n\t__ldtilecfg(amx_cfg);\n\t \n\t__tileloadd(tiledata);\n\tGUEST_SYNC(10);\n\n\tGUEST_DONE();\n}\n\nvoid guest_nm_handler(struct ex_regs *regs)\n{\n\t \n\tGUEST_SYNC(7);\n\tGUEST_ASSERT(!(get_cr0() & X86_CR0_TS));\n\tGUEST_ASSERT(rdmsr(MSR_IA32_XFD_ERR) == XFEATURE_MASK_XTILE_DATA);\n\tGUEST_ASSERT(rdmsr(MSR_IA32_XFD) == XFEATURE_MASK_XTILE_DATA);\n\tGUEST_SYNC(8);\n\tGUEST_ASSERT(rdmsr(MSR_IA32_XFD_ERR) == XFEATURE_MASK_XTILE_DATA);\n\tGUEST_ASSERT(rdmsr(MSR_IA32_XFD) == XFEATURE_MASK_XTILE_DATA);\n\t \n\twrmsr(MSR_IA32_XFD_ERR, 0);\n\t \n\twrmsr(MSR_IA32_XFD, 0);\n\tGUEST_SYNC(9);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_regs regs1, regs2;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct kvm_x86_state *state;\n\tint xsave_restore_size;\n\tvm_vaddr_t amx_cfg, tiledata, xstate;\n\tstruct ucall uc;\n\tu32 amx_offset;\n\tint stage, ret;\n\n\t \n\tvm_xsave_require_permission(XFEATURE_MASK_XTILE_DATA);\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_XFD));\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_XSAVE));\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_AMX_TILE));\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_XTILECFG));\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_XTILEDATA));\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_XTILEDATA_XFD));\n\n\t \n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\tTEST_ASSERT(kvm_cpu_has_p(X86_PROPERTY_XSTATE_MAX_SIZE),\n\t\t    \"KVM should enumerate max XSAVE size when XSAVE is supported\");\n\txsave_restore_size = kvm_cpu_property(X86_PROPERTY_XSTATE_MAX_SIZE);\n\n\tvcpu_regs_get(vcpu, &regs1);\n\n\t \n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\tvm_install_exception_handler(vm, NM_VECTOR, guest_nm_handler);\n\n\t \n\tamx_cfg = vm_vaddr_alloc_page(vm);\n\tmemset(addr_gva2hva(vm, amx_cfg), 0x0, getpagesize());\n\n\t \n\ttiledata = vm_vaddr_alloc_pages(vm, 2);\n\tmemset(addr_gva2hva(vm, tiledata), rand() | 1, 2 * getpagesize());\n\n\t \n\txstate = vm_vaddr_alloc_pages(vm, DIV_ROUND_UP(XSAVE_SIZE, PAGE_SIZE));\n\tmemset(addr_gva2hva(vm, xstate), 0, PAGE_SIZE * DIV_ROUND_UP(XSAVE_SIZE, PAGE_SIZE));\n\tvcpu_args_set(vcpu, 3, amx_cfg, tiledata, xstate);\n\n\tfor (stage = 1; ; stage++) {\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t \n\t\tcase UCALL_SYNC:\n\t\t\tswitch (uc.args[1]) {\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\t\tfprintf(stderr, \"GUEST_SYNC(%ld)\\n\", uc.args[1]);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 10:\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\"GUEST_SYNC(%ld), check save/restore status\\n\", uc.args[1]);\n\n\t\t\t\t \n\t\t\t\tamx_offset = xsave_restore_size - NUM_TILES*TILE_SIZE;\n\t\t\t\tstate = vcpu_save_state(vcpu);\n\t\t\t\tvoid *amx_start = (void *)state->xsave + amx_offset;\n\t\t\t\tvoid *tiles_data = (void *)addr_gva2hva(vm, tiledata);\n\t\t\t\t \n\t\t\t\tret = memcmp(amx_start, tiles_data, TILE_SIZE);\n\t\t\t\tTEST_ASSERT(ret == 0, \"memcmp failed, ret=%d\\n\", ret);\n\t\t\t\tkvm_x86_state_cleanup(state);\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\"GUEST_SYNC(%ld), #NM exception and enable amx\\n\", uc.args[1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tfprintf(stderr, \"UCALL_DONE\\n\");\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\n\t\tstate = vcpu_save_state(vcpu);\n\t\tmemset(&regs1, 0, sizeof(regs1));\n\t\tvcpu_regs_get(vcpu, &regs1);\n\n\t\tkvm_vm_release(vm);\n\n\t\t \n\t\tvcpu = vm_recreate_with_one_vcpu(vm);\n\t\tvcpu_load_state(vcpu, state);\n\t\tkvm_x86_state_cleanup(state);\n\n\t\tmemset(&regs2, 0, sizeof(regs2));\n\t\tvcpu_regs_get(vcpu, &regs2);\n\t\tTEST_ASSERT(!memcmp(&regs1, &regs2, sizeof(regs2)),\n\t\t\t    \"Unexpected register values after vcpu_load_state; rdi: %lx rsi: %lx\",\n\t\t\t    (ulong) regs2.rdi, (ulong) regs2.rsi);\n\t}\ndone:\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}