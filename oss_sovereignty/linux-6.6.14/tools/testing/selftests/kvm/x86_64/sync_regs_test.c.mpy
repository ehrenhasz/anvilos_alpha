{
  "module_name": "sync_regs_test.c",
  "hash_id": "1ffaf75c6d8f43a97ccdc4ce3804695bcec87e939bfb78803439742edb3f0f29",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/sync_regs_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <pthread.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n#define UCALL_PIO_PORT ((uint16_t)0x1000)\n\nstruct ucall uc_none = {\n\t.cmd = UCALL_NONE,\n};\n\n \nvoid guest_code(void)\n{\n\tasm volatile(\"1: in %[port], %%al\\n\"\n\t\t     \"add $0x1, %%rbx\\n\"\n\t\t     \"jmp 1b\"\n\t\t     : : [port] \"d\" (UCALL_PIO_PORT), \"D\" (&uc_none)\n\t\t     : \"rax\", \"rbx\");\n}\n\nstatic void compare_regs(struct kvm_regs *left, struct kvm_regs *right)\n{\n#define REG_COMPARE(reg) \\\n\tTEST_ASSERT(left->reg == right->reg, \\\n\t\t    \"Register \" #reg \\\n\t\t    \" values did not match: 0x%llx, 0x%llx\\n\", \\\n\t\t    left->reg, right->reg)\n\tREG_COMPARE(rax);\n\tREG_COMPARE(rbx);\n\tREG_COMPARE(rcx);\n\tREG_COMPARE(rdx);\n\tREG_COMPARE(rsi);\n\tREG_COMPARE(rdi);\n\tREG_COMPARE(rsp);\n\tREG_COMPARE(rbp);\n\tREG_COMPARE(r8);\n\tREG_COMPARE(r9);\n\tREG_COMPARE(r10);\n\tREG_COMPARE(r11);\n\tREG_COMPARE(r12);\n\tREG_COMPARE(r13);\n\tREG_COMPARE(r14);\n\tREG_COMPARE(r15);\n\tREG_COMPARE(rip);\n\tREG_COMPARE(rflags);\n#undef REG_COMPARE\n}\n\nstatic void compare_sregs(struct kvm_sregs *left, struct kvm_sregs *right)\n{\n}\n\nstatic void compare_vcpu_events(struct kvm_vcpu_events *left,\n\t\t\t\tstruct kvm_vcpu_events *right)\n{\n}\n\n#define TEST_SYNC_FIELDS   (KVM_SYNC_X86_REGS|KVM_SYNC_X86_SREGS|KVM_SYNC_X86_EVENTS)\n#define INVALID_SYNC_FIELD 0x80000000\n\n \nstatic void *race_events_inj_pen(void *arg)\n{\n\tstruct kvm_run *run = (struct kvm_run *)arg;\n\tstruct kvm_vcpu_events *events = &run->s.regs.events;\n\n\tWRITE_ONCE(events->exception.nr, UD_VECTOR);\n\n\tfor (;;) {\n\t\tWRITE_ONCE(run->kvm_dirty_regs, KVM_SYNC_X86_EVENTS);\n\t\tWRITE_ONCE(events->flags, 0);\n\t\tWRITE_ONCE(events->exception.injected, 1);\n\t\tWRITE_ONCE(events->exception.pending, 1);\n\n\t\tpthread_testcancel();\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void *race_events_exc(void *arg)\n{\n\tstruct kvm_run *run = (struct kvm_run *)arg;\n\tstruct kvm_vcpu_events *events = &run->s.regs.events;\n\n\tfor (;;) {\n\t\tWRITE_ONCE(run->kvm_dirty_regs, KVM_SYNC_X86_EVENTS);\n\t\tWRITE_ONCE(events->flags, 0);\n\t\tWRITE_ONCE(events->exception.nr, UD_VECTOR);\n\t\tWRITE_ONCE(events->exception.pending, 1);\n\t\tWRITE_ONCE(events->exception.nr, 255);\n\n\t\tpthread_testcancel();\n\t}\n\n\treturn NULL;\n}\n\n \nstatic noinline void *race_sregs_cr4(void *arg)\n{\n\tstruct kvm_run *run = (struct kvm_run *)arg;\n\t__u64 *cr4 = &run->s.regs.sregs.cr4;\n\t__u64 pae_enabled = *cr4;\n\t__u64 pae_disabled = *cr4 & ~X86_CR4_PAE;\n\n\tfor (;;) {\n\t\tWRITE_ONCE(run->kvm_dirty_regs, KVM_SYNC_X86_SREGS);\n\t\tWRITE_ONCE(*cr4, pae_enabled);\n\t\tasm volatile(\".rept 512\\n\\t\"\n\t\t\t     \"nop\\n\\t\"\n\t\t\t     \".endr\");\n\t\tWRITE_ONCE(*cr4, pae_disabled);\n\n\t\tpthread_testcancel();\n\t}\n\n\treturn NULL;\n}\n\nstatic void race_sync_regs(void *racer)\n{\n\tconst time_t TIMEOUT = 2;  \n\tstruct kvm_x86_state *state;\n\tstruct kvm_translation tr;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_run *run;\n\tstruct kvm_vm *vm;\n\tpthread_t thread;\n\ttime_t t;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\trun = vcpu->run;\n\n\trun->kvm_valid_regs = KVM_SYNC_X86_SREGS;\n\tvcpu_run(vcpu);\n\trun->kvm_valid_regs = 0;\n\n\t \n\tstate = vcpu_save_state(vcpu);\n\n\t \n\tTEST_ASSERT((run->s.regs.sregs.cr4 & X86_CR4_PAE) &&\n\t\t    (run->s.regs.sregs.efer & EFER_LME),\n\t\t    \"vCPU should be in long mode, CR4.PAE=%d, EFER.LME=%d\",\n\t\t    !!(run->s.regs.sregs.cr4 & X86_CR4_PAE),\n\t\t    !!(run->s.regs.sregs.efer & EFER_LME));\n\n\tTEST_ASSERT_EQ(pthread_create(&thread, NULL, racer, (void *)run), 0);\n\n\tfor (t = time(NULL) + TIMEOUT; time(NULL) < t;) {\n\t\t \n\t\tif (!__vcpu_run(vcpu) && run->exit_reason == KVM_EXIT_SHUTDOWN)\n\t\t\tvcpu_load_state(vcpu, state);\n\n\t\tif (racer == race_sregs_cr4) {\n\t\t\ttr = (struct kvm_translation) { .linear_address = 0 };\n\t\t\t__vcpu_ioctl(vcpu, KVM_TRANSLATE, &tr);\n\t\t}\n\t}\n\n\tTEST_ASSERT_EQ(pthread_cancel(thread), 0);\n\tTEST_ASSERT_EQ(pthread_join(thread, NULL), 0);\n\n\tkvm_x86_state_cleanup(state);\n\tkvm_vm_free(vm);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct kvm_run *run;\n\tstruct kvm_regs regs;\n\tstruct kvm_sregs sregs;\n\tstruct kvm_vcpu_events events;\n\tint rv, cap;\n\n\tcap = kvm_check_cap(KVM_CAP_SYNC_REGS);\n\tTEST_REQUIRE((cap & TEST_SYNC_FIELDS) == TEST_SYNC_FIELDS);\n\tTEST_REQUIRE(!(cap & INVALID_SYNC_FIELD));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\trun = vcpu->run;\n\n\t \n\trun->kvm_valid_regs = INVALID_SYNC_FIELD;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv < 0 && errno == EINVAL,\n\t\t    \"Invalid kvm_valid_regs did not cause expected KVM_RUN error: %d\\n\",\n\t\t    rv);\n\trun->kvm_valid_regs = 0;\n\n\trun->kvm_valid_regs = INVALID_SYNC_FIELD | TEST_SYNC_FIELDS;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv < 0 && errno == EINVAL,\n\t\t    \"Invalid kvm_valid_regs did not cause expected KVM_RUN error: %d\\n\",\n\t\t    rv);\n\trun->kvm_valid_regs = 0;\n\n\t \n\trun->kvm_dirty_regs = INVALID_SYNC_FIELD;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv < 0 && errno == EINVAL,\n\t\t    \"Invalid kvm_dirty_regs did not cause expected KVM_RUN error: %d\\n\",\n\t\t    rv);\n\trun->kvm_dirty_regs = 0;\n\n\trun->kvm_dirty_regs = INVALID_SYNC_FIELD | TEST_SYNC_FIELDS;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT(rv < 0 && errno == EINVAL,\n\t\t    \"Invalid kvm_dirty_regs did not cause expected KVM_RUN error: %d\\n\",\n\t\t    rv);\n\trun->kvm_dirty_regs = 0;\n\n\t \n\t \n\trun->kvm_valid_regs = TEST_SYNC_FIELDS;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\tvcpu_regs_get(vcpu, &regs);\n\tcompare_regs(&regs, &run->s.regs.regs);\n\n\tvcpu_sregs_get(vcpu, &sregs);\n\tcompare_sregs(&sregs, &run->s.regs.sregs);\n\n\tvcpu_events_get(vcpu, &events);\n\tcompare_vcpu_events(&events, &run->s.regs.events);\n\n\t \n\trun->s.regs.regs.rbx = 0xBAD1DEA;\n\trun->s.regs.sregs.apic_base = 1 << 11;\n\t \n\n\trun->kvm_valid_regs = TEST_SYNC_FIELDS;\n\trun->kvm_dirty_regs = KVM_SYNC_X86_REGS | KVM_SYNC_X86_SREGS;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\tTEST_ASSERT(run->s.regs.regs.rbx == 0xBAD1DEA + 1,\n\t\t    \"rbx sync regs value incorrect 0x%llx.\",\n\t\t    run->s.regs.regs.rbx);\n\tTEST_ASSERT(run->s.regs.sregs.apic_base == 1 << 11,\n\t\t    \"apic_base sync regs value incorrect 0x%llx.\",\n\t\t    run->s.regs.sregs.apic_base);\n\n\tvcpu_regs_get(vcpu, &regs);\n\tcompare_regs(&regs, &run->s.regs.regs);\n\n\tvcpu_sregs_get(vcpu, &sregs);\n\tcompare_sregs(&sregs, &run->s.regs.sregs);\n\n\tvcpu_events_get(vcpu, &events);\n\tcompare_vcpu_events(&events, &run->s.regs.events);\n\n\t \n\trun->kvm_valid_regs = TEST_SYNC_FIELDS;\n\trun->kvm_dirty_regs = 0;\n\trun->s.regs.regs.rbx = 0xDEADBEEF;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\tTEST_ASSERT(run->s.regs.regs.rbx != 0xDEADBEEF,\n\t\t    \"rbx sync regs value incorrect 0x%llx.\",\n\t\t    run->s.regs.regs.rbx);\n\n\t \n\trun->kvm_valid_regs = 0;\n\trun->kvm_dirty_regs = 0;\n\trun->s.regs.regs.rbx = 0xAAAA;\n\tregs.rbx = 0xBAC0;\n\tvcpu_regs_set(vcpu, &regs);\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\tTEST_ASSERT(run->s.regs.regs.rbx == 0xAAAA,\n\t\t    \"rbx sync regs value incorrect 0x%llx.\",\n\t\t    run->s.regs.regs.rbx);\n\tvcpu_regs_get(vcpu, &regs);\n\tTEST_ASSERT(regs.rbx == 0xBAC0 + 1,\n\t\t    \"rbx guest value incorrect 0x%llx.\",\n\t\t    regs.rbx);\n\n\t \n\trun->kvm_valid_regs = 0;\n\trun->kvm_dirty_regs = TEST_SYNC_FIELDS;\n\trun->s.regs.regs.rbx = 0xBBBB;\n\trv = _vcpu_run(vcpu);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\tTEST_ASSERT(run->s.regs.regs.rbx == 0xBBBB,\n\t\t    \"rbx sync regs value incorrect 0x%llx.\",\n\t\t    run->s.regs.regs.rbx);\n\tvcpu_regs_get(vcpu, &regs);\n\tTEST_ASSERT(regs.rbx == 0xBBBB + 1,\n\t\t    \"rbx guest value incorrect 0x%llx.\",\n\t\t    regs.rbx);\n\n\tkvm_vm_free(vm);\n\n\trace_sync_regs(race_sregs_cr4);\n\trace_sync_regs(race_events_exc);\n\trace_sync_regs(race_events_inj_pen);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}