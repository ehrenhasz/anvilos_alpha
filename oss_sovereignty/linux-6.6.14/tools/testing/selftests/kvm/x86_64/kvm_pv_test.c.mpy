{
  "module_name": "kvm_pv_test.c",
  "hash_id": "81c80bf0a62c50cee6f47750d4b2d5512acecb8aa59d12c8d91ff15e5dcd3e15",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/kvm_pv_test.c",
  "human_readable_source": "\n \n#include <asm/kvm_para.h>\n#include <linux/kvm_para.h>\n#include <stdint.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\nstruct msr_data {\n\tuint32_t idx;\n\tconst char *name;\n};\n\n#define TEST_MSR(msr) { .idx = msr, .name = #msr }\n#define UCALL_PR_MSR 0xdeadbeef\n#define PR_MSR(msr) ucall(UCALL_PR_MSR, 1, msr)\n\n \nstatic struct msr_data msrs_to_test[] = {\n\tTEST_MSR(MSR_KVM_SYSTEM_TIME),\n\tTEST_MSR(MSR_KVM_SYSTEM_TIME_NEW),\n\tTEST_MSR(MSR_KVM_WALL_CLOCK),\n\tTEST_MSR(MSR_KVM_WALL_CLOCK_NEW),\n\tTEST_MSR(MSR_KVM_ASYNC_PF_EN),\n\tTEST_MSR(MSR_KVM_STEAL_TIME),\n\tTEST_MSR(MSR_KVM_PV_EOI_EN),\n\tTEST_MSR(MSR_KVM_POLL_CONTROL),\n\tTEST_MSR(MSR_KVM_ASYNC_PF_INT),\n\tTEST_MSR(MSR_KVM_ASYNC_PF_ACK),\n};\n\nstatic void test_msr(struct msr_data *msr)\n{\n\tuint64_t ignored;\n\tuint8_t vector;\n\n\tPR_MSR(msr);\n\n\tvector = rdmsr_safe(msr->idx, &ignored);\n\tGUEST_ASSERT_EQ(vector, GP_VECTOR);\n\n\tvector = wrmsr_safe(msr->idx, 0);\n\tGUEST_ASSERT_EQ(vector, GP_VECTOR);\n}\n\nstruct hcall_data {\n\tuint64_t nr;\n\tconst char *name;\n};\n\n#define TEST_HCALL(hc) { .nr = hc, .name = #hc }\n#define UCALL_PR_HCALL 0xdeadc0de\n#define PR_HCALL(hc) ucall(UCALL_PR_HCALL, 1, hc)\n\n \nstatic struct hcall_data hcalls_to_test[] = {\n\tTEST_HCALL(KVM_HC_KICK_CPU),\n\tTEST_HCALL(KVM_HC_SEND_IPI),\n\tTEST_HCALL(KVM_HC_SCHED_YIELD),\n};\n\nstatic void test_hcall(struct hcall_data *hc)\n{\n\tuint64_t r;\n\n\tPR_HCALL(hc);\n\tr = kvm_hypercall(hc->nr, 0, 0, 0, 0);\n\tGUEST_ASSERT_EQ(r, -KVM_ENOSYS);\n}\n\nstatic void guest_main(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(msrs_to_test); i++) {\n\t\ttest_msr(&msrs_to_test[i]);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(hcalls_to_test); i++) {\n\t\ttest_hcall(&hcalls_to_test[i]);\n\t}\n\n\tGUEST_DONE();\n}\n\nstatic void pr_msr(struct ucall *uc)\n{\n\tstruct msr_data *msr = (struct msr_data *)uc->args[0];\n\n\tpr_info(\"testing msr: %s (%#x)\\n\", msr->name, msr->idx);\n}\n\nstatic void pr_hcall(struct ucall *uc)\n{\n\tstruct hcall_data *hc = (struct hcall_data *)uc->args[0];\n\n\tpr_info(\"testing hcall: %s (%lu)\\n\", hc->name, hc->nr);\n}\n\nstatic void enter_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct ucall uc;\n\n\twhile (true) {\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_PR_MSR:\n\t\t\tpr_msr(&uc);\n\t\t\tbreak;\n\t\tcase UCALL_PR_HCALL:\n\t\t\tpr_hcall(&uc);\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\treturn;\n\t\tcase UCALL_DONE:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_ENFORCE_PV_FEATURE_CPUID));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_main);\n\n\tvcpu_enable_cap(vcpu, KVM_CAP_ENFORCE_PV_FEATURE_CPUID, 1);\n\n\tvcpu_clear_cpuid_entry(vcpu, KVM_CPUID_FEATURES);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\tenter_guest(vcpu);\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}