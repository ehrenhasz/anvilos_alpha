{
  "module_name": "hyperv_features.c",
  "hash_id": "c23f804902330a6a402014d2f723db218b18a94bde6ff5b14da5a69546537217",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/hyperv_features.c",
  "human_readable_source": "\n \n#include <asm/kvm_para.h>\n#include <linux/kvm_para.h>\n#include <stdint.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"hyperv.h\"\n\n \n#define HV_PV_SPINLOCKS_TEST            \\\n\tKVM_X86_CPU_FEATURE(HYPERV_CPUID_ENLIGHTMENT_INFO, 0, EBX, 0)\n\nstruct msr_data {\n\tuint32_t idx;\n\tbool fault_expected;\n\tbool write;\n\tu64 write_val;\n};\n\nstruct hcall_data {\n\tuint64_t control;\n\tuint64_t expect;\n\tbool ud_expected;\n};\n\nstatic bool is_write_only_msr(uint32_t msr)\n{\n\treturn msr == HV_X64_MSR_EOI;\n}\n\nstatic void guest_msr(struct msr_data *msr)\n{\n\tuint8_t vector = 0;\n\tuint64_t msr_val = 0;\n\n\tGUEST_ASSERT(msr->idx);\n\n\tif (msr->write)\n\t\tvector = wrmsr_safe(msr->idx, msr->write_val);\n\n\tif (!vector && (!msr->write || !is_write_only_msr(msr->idx)))\n\t\tvector = rdmsr_safe(msr->idx, &msr_val);\n\n\tif (msr->fault_expected)\n\t\t__GUEST_ASSERT(vector == GP_VECTOR,\n\t\t\t       \"Expected #GP on %sMSR(0x%x), got vector '0x%x'\",\n\t\t\t       msr->idx, msr->write ? \"WR\" : \"RD\", vector);\n\telse\n\t\t__GUEST_ASSERT(!vector,\n\t\t\t       \"Expected success on %sMSR(0x%x), got vector '0x%x'\",\n\t\t\t       msr->idx, msr->write ? \"WR\" : \"RD\", vector);\n\n\tif (vector || is_write_only_msr(msr->idx))\n\t\tgoto done;\n\n\tif (msr->write)\n\t\t__GUEST_ASSERT(!vector,\n\t\t\t       \"WRMSR(0x%x) to '0x%llx', RDMSR read '0x%llx'\",\n\t\t\t       msr->idx, msr->write_val, msr_val);\n\n\t \n\tif (msr->idx == HV_X64_MSR_TSC_INVARIANT_CONTROL) {\n\t\tif (!this_cpu_has(HV_ACCESS_TSC_INVARIANT))\n\t\t\tGUEST_ASSERT(this_cpu_has(X86_FEATURE_INVTSC));\n\t\telse\n\t\t\tGUEST_ASSERT(this_cpu_has(X86_FEATURE_INVTSC) ==\n\t\t\t\t     !!(msr_val & HV_INVARIANT_TSC_EXPOSED));\n\t}\n\ndone:\n\tGUEST_DONE();\n}\n\nstatic void guest_hcall(vm_vaddr_t pgs_gpa, struct hcall_data *hcall)\n{\n\tu64 res, input, output;\n\tuint8_t vector;\n\n\tGUEST_ASSERT_NE(hcall->control, 0);\n\n\twrmsr(HV_X64_MSR_GUEST_OS_ID, HYPERV_LINUX_OS_ID);\n\twrmsr(HV_X64_MSR_HYPERCALL, pgs_gpa);\n\n\tif (!(hcall->control & HV_HYPERCALL_FAST_BIT)) {\n\t\tinput = pgs_gpa;\n\t\toutput = pgs_gpa + 4096;\n\t} else {\n\t\tinput = output = 0;\n\t}\n\n\tvector = __hyperv_hypercall(hcall->control, input, output, &res);\n\tif (hcall->ud_expected) {\n\t\t__GUEST_ASSERT(vector == UD_VECTOR,\n\t\t\t       \"Expected #UD for control '%u', got vector '0x%x'\",\n\t\t\t       hcall->control, vector);\n\t} else {\n\t\t__GUEST_ASSERT(!vector,\n\t\t\t       \"Expected no exception for control '%u', got vector '0x%x'\",\n\t\t\t       hcall->control, vector);\n\t\tGUEST_ASSERT_EQ(res, hcall->expect);\n\t}\n\n\tGUEST_DONE();\n}\n\nstatic void vcpu_reset_hv_cpuid(struct kvm_vcpu *vcpu)\n{\n\t \n\tvcpu_set_hv_cpuid(vcpu);\n\n\tvcpu_clear_cpuid_entry(vcpu, HYPERV_CPUID_FEATURES);\n\tvcpu_clear_cpuid_entry(vcpu, HYPERV_CPUID_ENLIGHTMENT_INFO);\n\tvcpu_clear_cpuid_entry(vcpu, HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES);\n}\n\nstatic void guest_test_msrs_access(void)\n{\n\tstruct kvm_cpuid2 *prev_cpuid = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\tint stage = 0;\n\tvm_vaddr_t msr_gva;\n\tstruct msr_data *msr;\n\tbool has_invtsc = kvm_cpu_has(X86_FEATURE_INVTSC);\n\n\twhile (true) {\n\t\tvm = vm_create_with_one_vcpu(&vcpu, guest_msr);\n\n\t\tmsr_gva = vm_vaddr_alloc_page(vm);\n\t\tmemset(addr_gva2hva(vm, msr_gva), 0x0, getpagesize());\n\t\tmsr = addr_gva2hva(vm, msr_gva);\n\n\t\tvcpu_args_set(vcpu, 1, msr_gva);\n\t\tvcpu_enable_cap(vcpu, KVM_CAP_HYPERV_ENFORCE_CPUID, 1);\n\n\t\tif (!prev_cpuid) {\n\t\t\tvcpu_reset_hv_cpuid(vcpu);\n\n\t\t\tprev_cpuid = allocate_kvm_cpuid2(vcpu->cpuid->nent);\n\t\t} else {\n\t\t\tvcpu_init_cpuid(vcpu, prev_cpuid);\n\t\t}\n\n\t\tvm_init_descriptor_tables(vm);\n\t\tvcpu_init_descriptor_tables(vcpu);\n\n\t\t \n\t\tif (stage >= 21)\n\t\t\tvcpu_enable_cap(vcpu, KVM_CAP_HYPERV_SYNIC2, 0);\n\n\t\tswitch (stage) {\n\t\tcase 0:\n\t\t\t \n\t\t\tmsr->idx = HV_X64_MSR_GUEST_OS_ID;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmsr->idx = HV_X64_MSR_HYPERCALL;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_HYPERCALL_AVAILABLE);\n\t\t\t \n\t\t\tmsr->idx = HV_X64_MSR_GUEST_OS_ID;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = HYPERV_LINUX_OS_ID;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmsr->idx = HV_X64_MSR_GUEST_OS_ID;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmsr->idx = HV_X64_MSR_HYPERCALL;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tmsr->idx = HV_X64_MSR_VP_RUNTIME;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_VP_RUNTIME_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_VP_RUNTIME;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t \n\t\t\tmsr->idx = HV_X64_MSR_VP_RUNTIME;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tmsr->idx = HV_X64_MSR_TIME_REF_COUNT;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_TIME_REF_COUNT_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_TIME_REF_COUNT;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\t \n\t\t\tmsr->idx = HV_X64_MSR_TIME_REF_COUNT;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\n\t\tcase 11:\n\t\t\tmsr->idx = HV_X64_MSR_VP_INDEX;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_VP_INDEX_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_VP_INDEX;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\t \n\t\t\tmsr->idx = HV_X64_MSR_VP_INDEX;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\n\t\tcase 14:\n\t\t\tmsr->idx = HV_X64_MSR_RESET;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_RESET_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_RESET;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tmsr->idx = HV_X64_MSR_RESET;\n\t\t\tmsr->write = true;\n\t\t\t \n\t\t\tmsr->write_val = 0;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\n\t\tcase 17:\n\t\t\tmsr->idx = HV_X64_MSR_REFERENCE_TSC;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_REFERENCE_TSC_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_REFERENCE_TSC;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\tmsr->idx = HV_X64_MSR_REFERENCE_TSC;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 0;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\n\t\tcase 20:\n\t\t\tmsr->idx = HV_X64_MSR_EOM;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\t \n\t\t\tmsr->idx = HV_X64_MSR_EOM;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_SYNIC_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_EOM;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tmsr->idx = HV_X64_MSR_EOM;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 0;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\t\tmsr->idx = HV_X64_MSR_STIMER0_CONFIG;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_SYNTIMER_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_STIMER0_CONFIG;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 26:\n\t\t\tmsr->idx = HV_X64_MSR_STIMER0_CONFIG;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 0;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 27:\n\t\t\t \n\t\t\tmsr->idx = HV_X64_MSR_STIMER0_CONFIG;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1 << 12;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 28:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_STIMER_DIRECT_MODE_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_STIMER0_CONFIG;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1 << 12;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\n\t\tcase 29:\n\t\t\tmsr->idx = HV_X64_MSR_EOI;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 30:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_APIC_ACCESS_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_EOI;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\n\t\tcase 31:\n\t\t\tmsr->idx = HV_X64_MSR_TSC_FREQUENCY;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_ACCESS_FREQUENCY_MSRS);\n\t\t\tmsr->idx = HV_X64_MSR_TSC_FREQUENCY;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 33:\n\t\t\t \n\t\t\tmsr->idx = HV_X64_MSR_TSC_FREQUENCY;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\n\t\tcase 34:\n\t\t\tmsr->idx = HV_X64_MSR_REENLIGHTENMENT_CONTROL;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 35:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_ACCESS_REENLIGHTENMENT);\n\t\t\tmsr->idx = HV_X64_MSR_REENLIGHTENMENT_CONTROL;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 36:\n\t\t\tmsr->idx = HV_X64_MSR_REENLIGHTENMENT_CONTROL;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 37:\n\t\t\t \n\t\t\tmsr->idx = HV_X64_MSR_TSC_EMULATION_STATUS;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\n\t\tcase 38:\n\t\t\tmsr->idx = HV_X64_MSR_CRASH_P0;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE);\n\t\t\tmsr->idx = HV_X64_MSR_CRASH_P0;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\tmsr->idx = HV_X64_MSR_CRASH_P0;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\n\t\tcase 41:\n\t\t\tmsr->idx = HV_X64_MSR_SYNDBG_STATUS;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 42:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_FEATURE_DEBUG_MSRS_AVAILABLE);\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_X64_SYNDBG_CAP_ALLOW_KERNEL_DEBUGGING);\n\t\t\tmsr->idx = HV_X64_MSR_SYNDBG_STATUS;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 43:\n\t\t\tmsr->idx = HV_X64_MSR_SYNDBG_STATUS;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 0;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\n\t\tcase 44:\n\t\t\t \n\t\t\tif (!has_invtsc)\n\t\t\t\tcontinue;\n\t\t\tmsr->idx = HV_X64_MSR_TSC_INVARIANT_CONTROL;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 45:\n\t\t\t \n\t\t\tif (!has_invtsc)\n\t\t\t\tcontinue;\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_ACCESS_TSC_INVARIANT);\n\t\t\tmsr->idx = HV_X64_MSR_TSC_INVARIANT_CONTROL;\n\t\t\tmsr->write = false;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\t\tcase 46:\n\t\t\t \n\t\t\tif (!has_invtsc)\n\t\t\t\tcontinue;\n\t\t\tmsr->idx = HV_X64_MSR_TSC_INVARIANT_CONTROL;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 0xdeadbeef;\n\t\t\tmsr->fault_expected = true;\n\t\t\tbreak;\n\t\tcase 47:\n\t\t\t \n\t\t\tif (!has_invtsc)\n\t\t\t\tcontinue;\n\t\t\tmsr->idx = HV_X64_MSR_TSC_INVARIANT_CONTROL;\n\t\t\tmsr->write = true;\n\t\t\tmsr->write_val = 1;\n\t\t\tmsr->fault_expected = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tkvm_vm_free(vm);\n\t\t\treturn;\n\t\t}\n\n\t\tvcpu_set_cpuid(vcpu);\n\n\t\tmemcpy(prev_cpuid, vcpu->cpuid, kvm_cpuid2_size(vcpu->cpuid->nent));\n\n\t\tpr_debug(\"Stage %d: testing msr: 0x%x for %s\\n\", stage,\n\t\t\t msr->idx, msr->write ? \"write\" : \"read\");\n\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\treturn;\n\t\tcase UCALL_DONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unhandled ucall: %ld\", uc.cmd);\n\t\t\treturn;\n\t\t}\n\n\t\tstage++;\n\t\tkvm_vm_free(vm);\n\t}\n}\n\nstatic void guest_test_hcalls_access(void)\n{\n\tstruct kvm_cpuid2 *prev_cpuid = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\tint stage = 0;\n\tvm_vaddr_t hcall_page, hcall_params;\n\tstruct hcall_data *hcall;\n\n\twhile (true) {\n\t\tvm = vm_create_with_one_vcpu(&vcpu, guest_hcall);\n\n\t\tvm_init_descriptor_tables(vm);\n\t\tvcpu_init_descriptor_tables(vcpu);\n\n\t\t \n\t\thcall_page = vm_vaddr_alloc_pages(vm, 2);\n\t\tmemset(addr_gva2hva(vm, hcall_page), 0x0, 2 * getpagesize());\n\n\t\thcall_params = vm_vaddr_alloc_page(vm);\n\t\tmemset(addr_gva2hva(vm, hcall_params), 0x0, getpagesize());\n\t\thcall = addr_gva2hva(vm, hcall_params);\n\n\t\tvcpu_args_set(vcpu, 2, addr_gva2gpa(vm, hcall_page), hcall_params);\n\t\tvcpu_enable_cap(vcpu, KVM_CAP_HYPERV_ENFORCE_CPUID, 1);\n\n\t\tif (!prev_cpuid) {\n\t\t\tvcpu_reset_hv_cpuid(vcpu);\n\n\t\t\tprev_cpuid = allocate_kvm_cpuid2(vcpu->cpuid->nent);\n\t\t} else {\n\t\t\tvcpu_init_cpuid(vcpu, prev_cpuid);\n\t\t}\n\n\t\tswitch (stage) {\n\t\tcase 0:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_MSR_HYPERCALL_AVAILABLE);\n\t\t\thcall->control = 0xbeef;\n\t\t\thcall->expect = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\thcall->control = HVCALL_POST_MESSAGE;\n\t\t\thcall->expect = HV_STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_POST_MESSAGES);\n\t\t\thcall->control = HVCALL_POST_MESSAGE;\n\t\t\thcall->expect = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\thcall->control = HVCALL_SIGNAL_EVENT;\n\t\t\thcall->expect = HV_STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_SIGNAL_EVENTS);\n\t\t\thcall->control = HVCALL_SIGNAL_EVENT;\n\t\t\thcall->expect = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\thcall->control = HVCALL_RESET_DEBUG_SESSION;\n\t\t\thcall->expect = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_X64_SYNDBG_CAP_ALLOW_KERNEL_DEBUGGING);\n\t\t\thcall->control = HVCALL_RESET_DEBUG_SESSION;\n\t\t\thcall->expect = HV_STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_DEBUGGING);\n\t\t\thcall->control = HVCALL_RESET_DEBUG_SESSION;\n\t\t\thcall->expect = HV_STATUS_OPERATION_DENIED;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\thcall->control = HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE;\n\t\t\thcall->expect = HV_STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED);\n\t\t\thcall->control = HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE;\n\t\t\thcall->expect = HV_STATUS_SUCCESS;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\thcall->control = HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX;\n\t\t\thcall->expect = HV_STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED);\n\t\t\thcall->control = HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX;\n\t\t\thcall->expect = HV_STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase 12:\n\t\t\thcall->control = HVCALL_SEND_IPI;\n\t\t\thcall->expect = HV_STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_X64_CLUSTER_IPI_RECOMMENDED);\n\t\t\thcall->control = HVCALL_SEND_IPI;\n\t\t\thcall->expect = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\t \n\t\t\thcall->control = HVCALL_SEND_IPI_EX;\n\t\t\thcall->expect = HV_STATUS_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase 15:\n\t\t\thcall->control = HVCALL_NOTIFY_LONG_SPIN_WAIT;\n\t\t\thcall->expect = HV_STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_PV_SPINLOCKS_TEST);\n\t\t\thcall->control = HVCALL_NOTIFY_LONG_SPIN_WAIT;\n\t\t\thcall->expect = HV_STATUS_SUCCESS;\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\t \n\t\t\thcall->control = HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE | HV_HYPERCALL_FAST_BIT;\n\t\t\thcall->ud_expected = true;\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_X64_HYPERCALL_XMM_INPUT_AVAILABLE);\n\t\t\thcall->control = HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE | HV_HYPERCALL_FAST_BIT;\n\t\t\thcall->ud_expected = false;\n\t\t\thcall->expect = HV_STATUS_SUCCESS;\n\t\t\tbreak;\n\t\tcase 19:\n\t\t\thcall->control = HV_EXT_CALL_QUERY_CAPABILITIES;\n\t\t\thcall->expect = HV_STATUS_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tvcpu_set_cpuid_feature(vcpu, HV_ENABLE_EXTENDED_HYPERCALLS);\n\t\t\thcall->control = HV_EXT_CALL_QUERY_CAPABILITIES | HV_HYPERCALL_FAST_BIT;\n\t\t\thcall->expect = HV_STATUS_INVALID_PARAMETER;\n\t\t\tbreak;\n\t\tcase 21:\n\t\t\tkvm_vm_free(vm);\n\t\t\treturn;\n\t\t}\n\n\t\tvcpu_set_cpuid(vcpu);\n\n\t\tmemcpy(prev_cpuid, vcpu->cpuid, kvm_cpuid2_size(vcpu->cpuid->nent));\n\n\t\tpr_debug(\"Stage %d: testing hcall: 0x%lx\\n\", stage, hcall->control);\n\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\treturn;\n\t\tcase UCALL_DONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unhandled ucall: %ld\", uc.cmd);\n\t\t\treturn;\n\t\t}\n\n\t\tstage++;\n\t\tkvm_vm_free(vm);\n\t}\n}\n\nint main(void)\n{\n\tpr_info(\"Testing access to Hyper-V specific MSRs\\n\");\n\tguest_test_msrs_access();\n\n\tpr_info(\"Testing access to Hyper-V hypercalls\\n\");\n\tguest_test_hcalls_access();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}