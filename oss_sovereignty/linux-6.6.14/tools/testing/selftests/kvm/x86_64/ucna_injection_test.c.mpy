{
  "module_name": "ucna_injection_test.c",
  "hash_id": "d56c49ea207a42bea577df2f8b167ab31a169f9f466e8282b37ea99c0beee7d6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/ucna_injection_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n#include <pthread.h>\n#include <inttypes.h>\n#include <string.h>\n#include <time.h>\n\n#include \"kvm_util_base.h\"\n#include \"kvm_util.h\"\n#include \"mce.h\"\n#include \"processor.h\"\n#include \"test_util.h\"\n#include \"apic.h\"\n\n#define SYNC_FIRST_UCNA 9\n#define SYNC_SECOND_UCNA 10\n#define SYNC_GP 11\n#define FIRST_UCNA_ADDR 0xdeadbeef\n#define SECOND_UCNA_ADDR 0xcafeb0ba\n\n \n#define CMCI_VECTOR  0xa9\n\n#define UCNA_BANK  0x7\t\n\n#define MCI_CTL2_RESERVED_BIT BIT_ULL(29)\n\nstatic uint64_t supported_mcg_caps;\n\n \nstatic volatile uint64_t i_ucna_rcvd;\nstatic volatile uint64_t i_ucna_addr;\nstatic volatile uint64_t ucna_addr;\nstatic volatile uint64_t ucna_addr2;\n\nstruct thread_params {\n\tstruct kvm_vcpu *vcpu;\n\tuint64_t *p_i_ucna_rcvd;\n\tuint64_t *p_i_ucna_addr;\n\tuint64_t *p_ucna_addr;\n\tuint64_t *p_ucna_addr2;\n};\n\nstatic void verify_apic_base_addr(void)\n{\n\tuint64_t msr = rdmsr(MSR_IA32_APICBASE);\n\tuint64_t base = GET_APIC_BASE(msr);\n\n\tGUEST_ASSERT(base == APIC_DEFAULT_GPA);\n}\n\nstatic void ucna_injection_guest_code(void)\n{\n\tuint64_t ctl2;\n\tverify_apic_base_addr();\n\txapic_enable();\n\n\t \n\txapic_write_reg(APIC_LVTCMCI, CMCI_VECTOR | APIC_DM_FIXED);\n\tctl2 = rdmsr(MSR_IA32_MCx_CTL2(UCNA_BANK));\n\twrmsr(MSR_IA32_MCx_CTL2(UCNA_BANK), ctl2 | MCI_CTL2_CMCI_EN);\n\n\t \n\tasm volatile(\"sti\");\n\n\t \n\tGUEST_SYNC(SYNC_FIRST_UCNA);\n\n\tucna_addr = rdmsr(MSR_IA32_MCx_ADDR(UCNA_BANK));\n\n\t \n\tctl2 = rdmsr(MSR_IA32_MCx_CTL2(UCNA_BANK));\n\twrmsr(MSR_IA32_MCx_CTL2(UCNA_BANK), ctl2 & ~MCI_CTL2_CMCI_EN);\n\n\t \n\tGUEST_SYNC(SYNC_SECOND_UCNA);\n\n\tucna_addr2 = rdmsr(MSR_IA32_MCx_ADDR(UCNA_BANK));\n\tGUEST_DONE();\n}\n\nstatic void cmci_disabled_guest_code(void)\n{\n\tuint64_t ctl2 = rdmsr(MSR_IA32_MCx_CTL2(UCNA_BANK));\n\twrmsr(MSR_IA32_MCx_CTL2(UCNA_BANK), ctl2 | MCI_CTL2_CMCI_EN);\n\n\tGUEST_DONE();\n}\n\nstatic void cmci_enabled_guest_code(void)\n{\n\tuint64_t ctl2 = rdmsr(MSR_IA32_MCx_CTL2(UCNA_BANK));\n\twrmsr(MSR_IA32_MCx_CTL2(UCNA_BANK), ctl2 | MCI_CTL2_RESERVED_BIT);\n\n\tGUEST_DONE();\n}\n\nstatic void guest_cmci_handler(struct ex_regs *regs)\n{\n\ti_ucna_rcvd++;\n\ti_ucna_addr = rdmsr(MSR_IA32_MCx_ADDR(UCNA_BANK));\n\txapic_write_reg(APIC_EOI, 0);\n}\n\nstatic void guest_gp_handler(struct ex_regs *regs)\n{\n\tGUEST_SYNC(SYNC_GP);\n}\n\nstatic void run_vcpu_expect_gp(struct kvm_vcpu *vcpu)\n{\n\tstruct ucall uc;\n\n\tvcpu_run(vcpu);\n\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\tTEST_ASSERT(get_ucall(vcpu, &uc) == UCALL_SYNC,\n\t\t    \"Expect UCALL_SYNC\\n\");\n\tTEST_ASSERT(uc.args[1] == SYNC_GP, \"#GP is expected.\");\n\tprintf(\"vCPU received GP in guest.\\n\");\n}\n\nstatic void inject_ucna(struct kvm_vcpu *vcpu, uint64_t addr) {\n\t \n\tuint64_t status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN |\n\t\t\t  MCI_STATUS_MISCV | MCI_STATUS_ADDRV | 0x10090;\n\tstruct kvm_x86_mce mce = {};\n\tmce.status = status;\n\tmce.mcg_status = 0;\n\t \n\tmce.misc = (MCM_ADDR_PHYS << 6) | 0xc;\n\tmce.addr = addr;\n\tmce.bank = UCNA_BANK;\n\n\tvcpu_ioctl(vcpu, KVM_X86_SET_MCE, &mce);\n}\n\nstatic void *run_ucna_injection(void *arg)\n{\n\tstruct thread_params *params = (struct thread_params *)arg;\n\tstruct ucall uc;\n\tint old;\n\tint r;\n\n\tr = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &old);\n\tTEST_ASSERT(r == 0,\n\t\t    \"pthread_setcanceltype failed with errno=%d\",\n\t\t    r);\n\n\tvcpu_run(params->vcpu);\n\n\tTEST_ASSERT_KVM_EXIT_REASON(params->vcpu, KVM_EXIT_IO);\n\tTEST_ASSERT(get_ucall(params->vcpu, &uc) == UCALL_SYNC,\n\t\t    \"Expect UCALL_SYNC\\n\");\n\tTEST_ASSERT(uc.args[1] == SYNC_FIRST_UCNA, \"Injecting first UCNA.\");\n\n\tprintf(\"Injecting first UCNA at %#x.\\n\", FIRST_UCNA_ADDR);\n\n\tinject_ucna(params->vcpu, FIRST_UCNA_ADDR);\n\tvcpu_run(params->vcpu);\n\n\tTEST_ASSERT_KVM_EXIT_REASON(params->vcpu, KVM_EXIT_IO);\n\tTEST_ASSERT(get_ucall(params->vcpu, &uc) == UCALL_SYNC,\n\t\t    \"Expect UCALL_SYNC\\n\");\n\tTEST_ASSERT(uc.args[1] == SYNC_SECOND_UCNA, \"Injecting second UCNA.\");\n\n\tprintf(\"Injecting second UCNA at %#x.\\n\", SECOND_UCNA_ADDR);\n\n\tinject_ucna(params->vcpu, SECOND_UCNA_ADDR);\n\tvcpu_run(params->vcpu);\n\n\tTEST_ASSERT_KVM_EXIT_REASON(params->vcpu, KVM_EXIT_IO);\n\tif (get_ucall(params->vcpu, &uc) == UCALL_ABORT) {\n\t\tTEST_ASSERT(false, \"vCPU assertion failure: %s.\\n\",\n\t\t\t    (const char *)uc.args[0]);\n\t}\n\n\treturn NULL;\n}\n\nstatic void test_ucna_injection(struct kvm_vcpu *vcpu, struct thread_params *params)\n{\n\tstruct kvm_vm *vm = vcpu->vm;\n\tparams->vcpu = vcpu;\n\tparams->p_i_ucna_rcvd = (uint64_t *)addr_gva2hva(vm, (uint64_t)&i_ucna_rcvd);\n\tparams->p_i_ucna_addr = (uint64_t *)addr_gva2hva(vm, (uint64_t)&i_ucna_addr);\n\tparams->p_ucna_addr = (uint64_t *)addr_gva2hva(vm, (uint64_t)&ucna_addr);\n\tparams->p_ucna_addr2 = (uint64_t *)addr_gva2hva(vm, (uint64_t)&ucna_addr2);\n\n\trun_ucna_injection(params);\n\n\tTEST_ASSERT(*params->p_i_ucna_rcvd == 1, \"Only first UCNA get signaled.\");\n\tTEST_ASSERT(*params->p_i_ucna_addr == FIRST_UCNA_ADDR,\n\t\t    \"Only first UCNA reported addr get recorded via interrupt.\");\n\tTEST_ASSERT(*params->p_ucna_addr == FIRST_UCNA_ADDR,\n\t\t    \"First injected UCNAs should get exposed via registers.\");\n\tTEST_ASSERT(*params->p_ucna_addr2 == SECOND_UCNA_ADDR,\n\t\t    \"Second injected UCNAs should get exposed via registers.\");\n\n\tprintf(\"Test successful.\\n\"\n\t       \"UCNA CMCI interrupts received: %ld\\n\"\n\t       \"Last UCNA address received via CMCI: %lx\\n\"\n\t       \"First UCNA address in vCPU thread: %lx\\n\"\n\t       \"Second UCNA address in vCPU thread: %lx\\n\",\n\t       *params->p_i_ucna_rcvd, *params->p_i_ucna_addr,\n\t       *params->p_ucna_addr, *params->p_ucna_addr2);\n}\n\nstatic void setup_mce_cap(struct kvm_vcpu *vcpu, bool enable_cmci_p)\n{\n\tuint64_t mcg_caps = MCG_CTL_P | MCG_SER_P | MCG_LMCE_P | KVM_MAX_MCE_BANKS;\n\tif (enable_cmci_p)\n\t\tmcg_caps |= MCG_CMCI_P;\n\n\tmcg_caps &= supported_mcg_caps | MCG_CAP_BANKS_MASK;\n\tvcpu_ioctl(vcpu, KVM_X86_SETUP_MCE, &mcg_caps);\n}\n\nstatic struct kvm_vcpu *create_vcpu_with_mce_cap(struct kvm_vm *vm, uint32_t vcpuid,\n\t\t\t\t\t\t bool enable_cmci_p, void *guest_code)\n{\n\tstruct kvm_vcpu *vcpu = vm_vcpu_add(vm, vcpuid, guest_code);\n\tsetup_mce_cap(vcpu, enable_cmci_p);\n\treturn vcpu;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct thread_params params;\n\tstruct kvm_vm *vm;\n\tstruct kvm_vcpu *ucna_vcpu;\n\tstruct kvm_vcpu *cmcidis_vcpu;\n\tstruct kvm_vcpu *cmci_vcpu;\n\n\tkvm_check_cap(KVM_CAP_MCE);\n\n\tvm = __vm_create(VM_MODE_DEFAULT, 3, 0);\n\n\tkvm_ioctl(vm->kvm_fd, KVM_X86_GET_MCE_CAP_SUPPORTED,\n\t\t  &supported_mcg_caps);\n\n\tif (!(supported_mcg_caps & MCG_CMCI_P)) {\n\t\tprint_skip(\"MCG_CMCI_P is not supported\");\n\t\texit(KSFT_SKIP);\n\t}\n\n\tucna_vcpu = create_vcpu_with_mce_cap(vm, 0, true, ucna_injection_guest_code);\n\tcmcidis_vcpu = create_vcpu_with_mce_cap(vm, 1, false, cmci_disabled_guest_code);\n\tcmci_vcpu = create_vcpu_with_mce_cap(vm, 2, true, cmci_enabled_guest_code);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(ucna_vcpu);\n\tvcpu_init_descriptor_tables(cmcidis_vcpu);\n\tvcpu_init_descriptor_tables(cmci_vcpu);\n\tvm_install_exception_handler(vm, CMCI_VECTOR, guest_cmci_handler);\n\tvm_install_exception_handler(vm, GP_VECTOR, guest_gp_handler);\n\n\tvirt_pg_map(vm, APIC_DEFAULT_GPA, APIC_DEFAULT_GPA);\n\n\ttest_ucna_injection(ucna_vcpu, &params);\n\trun_vcpu_expect_gp(cmcidis_vcpu);\n\trun_vcpu_expect_gp(cmci_vcpu);\n\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}