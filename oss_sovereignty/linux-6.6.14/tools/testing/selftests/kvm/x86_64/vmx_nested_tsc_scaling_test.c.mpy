{
  "module_name": "vmx_nested_tsc_scaling_test.c",
  "hash_id": "ed0f8b6d71aaf1df7507b339800b96e24025e3b6cc81298a6db29f891b8783e5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_nested_tsc_scaling_test.c",
  "human_readable_source": "\n \n\n#include <time.h>\n\n#include \"kvm_util.h\"\n#include \"vmx.h\"\n#include \"kselftest.h\"\n\n \n#define L2_SCALE_FACTOR 4ULL\n\n#define TSC_OFFSET_L2 ((uint64_t) -33125236320908)\n#define TSC_MULTIPLIER_L2 (L2_SCALE_FACTOR << 48)\n\n#define L2_GUEST_STACK_SIZE 64\n\nenum { USLEEP, UCHECK_L1, UCHECK_L2 };\n#define GUEST_SLEEP(sec)         ucall(UCALL_SYNC, 2, USLEEP, sec)\n#define GUEST_CHECK(level, freq) ucall(UCALL_SYNC, 2, level, freq)\n\n\n \nstatic void compare_tsc_freq(uint64_t actual, uint64_t expected)\n{\n\tuint64_t tolerance, thresh_low, thresh_high;\n\n\ttolerance = expected / 100;\n\tthresh_low = expected - tolerance;\n\tthresh_high = expected + tolerance;\n\n\tTEST_ASSERT(thresh_low < actual,\n\t\t\"TSC freq is expected to be between %\"PRIu64\" and %\"PRIu64\n\t\t\" but it actually is %\"PRIu64,\n\t\tthresh_low, thresh_high, actual);\n\tTEST_ASSERT(thresh_high > actual,\n\t\t\"TSC freq is expected to be between %\"PRIu64\" and %\"PRIu64\n\t\t\" but it actually is %\"PRIu64,\n\t\tthresh_low, thresh_high, actual);\n}\n\nstatic void check_tsc_freq(int level)\n{\n\tuint64_t tsc_start, tsc_end, tsc_freq;\n\n\t \n\ttsc_start = rdmsr(MSR_IA32_TSC);\n\tGUEST_SLEEP(1);\n\ttsc_end = rdmsr(MSR_IA32_TSC);\n\n\ttsc_freq = tsc_end - tsc_start;\n\n\tGUEST_CHECK(level, tsc_freq);\n}\n\nstatic void l2_guest_code(void)\n{\n\tcheck_tsc_freq(UCHECK_L2);\n\n\t \n\t__asm__ __volatile__(\"vmcall\");\n}\n\nstatic void l1_guest_code(struct vmx_pages *vmx_pages)\n{\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\tuint32_t control;\n\n\t \n\tcheck_tsc_freq(UCHECK_L1);\n\n\tGUEST_ASSERT(prepare_for_vmx_operation(vmx_pages));\n\tGUEST_ASSERT(load_vmcs(vmx_pages));\n\n\t \n\tprepare_vmcs(vmx_pages, l2_guest_code, &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\n\t \n\tcontrol = vmreadz(CPU_BASED_VM_EXEC_CONTROL);\n\tcontrol |= CPU_BASED_USE_MSR_BITMAPS | CPU_BASED_USE_TSC_OFFSETTING;\n\tvmwrite(CPU_BASED_VM_EXEC_CONTROL, control);\n\n\tcontrol = vmreadz(SECONDARY_VM_EXEC_CONTROL);\n\tcontrol |= SECONDARY_EXEC_TSC_SCALING;\n\tvmwrite(SECONDARY_VM_EXEC_CONTROL, control);\n\n\tvmwrite(TSC_OFFSET, TSC_OFFSET_L2);\n\tvmwrite(TSC_MULTIPLIER, TSC_MULTIPLIER_L2);\n\tvmwrite(TSC_MULTIPLIER_HIGH, TSC_MULTIPLIER_L2 >> 32);\n\n\t \n\tGUEST_ASSERT(!vmlaunch());\n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_VMCALL);\n\n\t \n\tcheck_tsc_freq(UCHECK_L1);\n\n\tGUEST_DONE();\n}\n\nstatic bool system_has_stable_tsc(void)\n{\n\tbool tsc_is_stable;\n\tFILE *fp;\n\tchar buf[4];\n\n\tfp = fopen(\"/sys/devices/system/clocksource/clocksource0/current_clocksource\", \"r\");\n\tif (fp == NULL)\n\t\treturn false;\n\n\ttsc_is_stable = fgets(buf, sizeof(buf), fp) &&\n\t\t\t!strncmp(buf, \"tsc\", sizeof(buf));\n\n\tfclose(fp);\n\treturn tsc_is_stable;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tvm_vaddr_t vmx_pages_gva;\n\n\tuint64_t tsc_start, tsc_end;\n\tuint64_t tsc_khz;\n\tuint64_t l1_scale_factor;\n\tuint64_t l0_tsc_freq = 0;\n\tuint64_t l1_tsc_freq = 0;\n\tuint64_t l2_tsc_freq = 0;\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_TSC_CONTROL));\n\tTEST_REQUIRE(system_has_stable_tsc());\n\n\t \n\tsrand(time(NULL));\n\tl1_scale_factor = (rand() % 9) + 2;\n\tprintf(\"L1's scale down factor is: %\"PRIu64\"\\n\", l1_scale_factor);\n\tprintf(\"L2's scale up factor is: %llu\\n\", L2_SCALE_FACTOR);\n\n\ttsc_start = rdtsc();\n\tsleep(1);\n\ttsc_end = rdtsc();\n\n\tl0_tsc_freq = tsc_end - tsc_start;\n\tprintf(\"real TSC frequency is around: %\"PRIu64\"\\n\", l0_tsc_freq);\n\n\tvm = vm_create_with_one_vcpu(&vcpu, l1_guest_code);\n\tvcpu_alloc_vmx(vm, &vmx_pages_gva);\n\tvcpu_args_set(vcpu, 1, vmx_pages_gva);\n\n\ttsc_khz = __vcpu_ioctl(vcpu, KVM_GET_TSC_KHZ, NULL);\n\tTEST_ASSERT(tsc_khz != -1, \"vcpu ioctl KVM_GET_TSC_KHZ failed\");\n\n\t \n\tvcpu_ioctl(vcpu, KVM_SET_TSC_KHZ, (void *) (tsc_khz / l1_scale_factor));\n\n\tfor (;;) {\n\t\tstruct ucall uc;\n\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\tcase UCALL_SYNC:\n\t\t\tswitch (uc.args[0]) {\n\t\t\tcase USLEEP:\n\t\t\t\tsleep(uc.args[1]);\n\t\t\t\tbreak;\n\t\t\tcase UCHECK_L1:\n\t\t\t\tl1_tsc_freq = uc.args[1];\n\t\t\t\tprintf(\"L1's TSC frequency is around: %\"PRIu64\n\t\t\t\t       \"\\n\", l1_tsc_freq);\n\n\t\t\t\tcompare_tsc_freq(l1_tsc_freq,\n\t\t\t\t\t\t l0_tsc_freq / l1_scale_factor);\n\t\t\t\tbreak;\n\t\t\tcase UCHECK_L2:\n\t\t\t\tl2_tsc_freq = uc.args[1];\n\t\t\t\tprintf(\"L2's TSC frequency is around: %\"PRIu64\n\t\t\t\t       \"\\n\", l2_tsc_freq);\n\n\t\t\t\tcompare_tsc_freq(l2_tsc_freq,\n\t\t\t\t\t\t l1_tsc_freq * L2_SCALE_FACTOR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\t}\n\ndone:\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}