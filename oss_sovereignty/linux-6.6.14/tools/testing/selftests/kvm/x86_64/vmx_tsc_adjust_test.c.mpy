{
  "module_name": "vmx_tsc_adjust_test.c",
  "hash_id": "ca24e210da1fbd45dbcc8f91ebe346a6b2819deaf2f19374a5e2d2755edecde3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c",
  "human_readable_source": "\n \n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"kselftest.h\"\n\n#ifndef MSR_IA32_TSC_ADJUST\n#define MSR_IA32_TSC_ADJUST 0x3b\n#endif\n\n#define TSC_ADJUST_VALUE (1ll << 32)\n#define TSC_OFFSET_VALUE -(1ll << 48)\n\nenum {\n\tPORT_ABORT = 0x1000,\n\tPORT_REPORT,\n\tPORT_DONE,\n};\n\nenum {\n\tVMXON_PAGE = 0,\n\tVMCS_PAGE,\n\tMSR_BITMAP_PAGE,\n\n\tNUM_VMX_PAGES,\n};\n\n \nstatic struct kvm_vm *vm;\n\nstatic void check_ia32_tsc_adjust(int64_t max)\n{\n\tint64_t adjust;\n\n\tadjust = rdmsr(MSR_IA32_TSC_ADJUST);\n\tGUEST_SYNC(adjust);\n\tGUEST_ASSERT(adjust <= max);\n}\n\nstatic void l2_guest_code(void)\n{\n\tuint64_t l1_tsc = rdtsc() - TSC_OFFSET_VALUE;\n\n\twrmsr(MSR_IA32_TSC, l1_tsc - TSC_ADJUST_VALUE);\n\tcheck_ia32_tsc_adjust(-2 * TSC_ADJUST_VALUE);\n\n\t \n\t__asm__ __volatile__(\"vmcall\");\n}\n\nstatic void l1_guest_code(struct vmx_pages *vmx_pages)\n{\n#define L2_GUEST_STACK_SIZE 64\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\tuint32_t control;\n\tuintptr_t save_cr3;\n\n\tGUEST_ASSERT(rdtsc() < TSC_ADJUST_VALUE);\n\twrmsr(MSR_IA32_TSC, rdtsc() - TSC_ADJUST_VALUE);\n\tcheck_ia32_tsc_adjust(-1 * TSC_ADJUST_VALUE);\n\n\tGUEST_ASSERT(prepare_for_vmx_operation(vmx_pages));\n\tGUEST_ASSERT(load_vmcs(vmx_pages));\n\n\t \n\tprepare_vmcs(vmx_pages, l2_guest_code,\n\t\t     &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\tcontrol = vmreadz(CPU_BASED_VM_EXEC_CONTROL);\n\tcontrol |= CPU_BASED_USE_MSR_BITMAPS | CPU_BASED_USE_TSC_OFFSETTING;\n\tvmwrite(CPU_BASED_VM_EXEC_CONTROL, control);\n\tvmwrite(TSC_OFFSET, TSC_OFFSET_VALUE);\n\n\t \n\tsave_cr3 = vmreadz(GUEST_CR3);\n\tvmwrite(GUEST_CR3, -1ull);\n\tGUEST_ASSERT(!vmlaunch());\n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) ==\n\t\t     (EXIT_REASON_FAILED_VMENTRY | EXIT_REASON_INVALID_STATE));\n\tcheck_ia32_tsc_adjust(-1 * TSC_ADJUST_VALUE);\n\tvmwrite(GUEST_CR3, save_cr3);\n\n\tGUEST_ASSERT(!vmlaunch());\n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_VMCALL);\n\n\tcheck_ia32_tsc_adjust(-2 * TSC_ADJUST_VALUE);\n\n\tGUEST_DONE();\n}\n\nstatic void report(int64_t val)\n{\n\tpr_info(\"IA32_TSC_ADJUST is %ld (%lld * TSC_ADJUST_VALUE + %lld).\\n\",\n\t\tval, val / TSC_ADJUST_VALUE, val % TSC_ADJUST_VALUE);\n}\n\nint main(int argc, char *argv[])\n{\n\tvm_vaddr_t vmx_pages_gva;\n\tstruct kvm_vcpu *vcpu;\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, (void *) l1_guest_code);\n\n\t \n\tvcpu_alloc_vmx(vm, &vmx_pages_gva);\n\tvcpu_args_set(vcpu, 1, vmx_pages_gva);\n\n\tfor (;;) {\n\t\tstruct ucall uc;\n\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t \n\t\tcase UCALL_SYNC:\n\t\t\treport(uc.args[1]);\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\t}\n\ndone:\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}