{
  "module_name": "triple_fault_event_test.c",
  "hash_id": "41f3da56c91d0a468407ce71cd3303a97c429bb23bac59bf9c3613392b4cb233",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/triple_fault_event_test.c",
  "human_readable_source": "\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n#include \"svm_util.h\"\n\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"kselftest.h\"\n\n#define ARBITRARY_IO_PORT\t0x2000\n\n \nstatic struct kvm_vm *vm;\n\nstatic void l2_guest_code(void)\n{\n\tasm volatile(\"inb %%dx, %%al\"\n\t\t     : : [port] \"d\" (ARBITRARY_IO_PORT) : \"rax\");\n}\n\n#define L2_GUEST_STACK_SIZE 64\nunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\nvoid l1_guest_code_vmx(struct vmx_pages *vmx)\n{\n\n\tGUEST_ASSERT(vmx->vmcs_gpa);\n\tGUEST_ASSERT(prepare_for_vmx_operation(vmx));\n\tGUEST_ASSERT(load_vmcs(vmx));\n\n\tprepare_vmcs(vmx, l2_guest_code,\n\t\t     &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\n\tGUEST_ASSERT(!vmlaunch());\n\t \n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_TRIPLE_FAULT);\n\tGUEST_DONE();\n}\n\nvoid l1_guest_code_svm(struct svm_test_data *svm)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tgeneric_svm_setup(svm, l2_guest_code,\n\t\t\t&l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\n\t \n\tvmcb->control.intercept &= ~(BIT(INTERCEPT_SHUTDOWN));\n\n\trun_guest(vmcb, svm->vmcb_gpa);\n\n\t \n\tGUEST_ASSERT(0);\n}\n\nint main(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_run *run;\n\tstruct kvm_vcpu_events events;\n\tstruct ucall uc;\n\n\tbool has_vmx = kvm_cpu_has(X86_FEATURE_VMX);\n\tbool has_svm = kvm_cpu_has(X86_FEATURE_SVM);\n\n\tTEST_REQUIRE(has_vmx || has_svm);\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_X86_TRIPLE_FAULT_EVENT));\n\n\n\tif (has_vmx) {\n\t\tvm_vaddr_t vmx_pages_gva;\n\n\t\tvm = vm_create_with_one_vcpu(&vcpu, l1_guest_code_vmx);\n\t\tvcpu_alloc_vmx(vm, &vmx_pages_gva);\n\t\tvcpu_args_set(vcpu, 1, vmx_pages_gva);\n\t} else {\n\t\tvm_vaddr_t svm_gva;\n\n\t\tvm = vm_create_with_one_vcpu(&vcpu, l1_guest_code_svm);\n\t\tvcpu_alloc_svm(vm, &svm_gva);\n\t\tvcpu_args_set(vcpu, 1, svm_gva);\n\t}\n\n\tvm_enable_cap(vm, KVM_CAP_X86_TRIPLE_FAULT_EVENT, 1);\n\trun = vcpu->run;\n\tvcpu_run(vcpu);\n\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\tTEST_ASSERT(run->io.port == ARBITRARY_IO_PORT,\n\t\t    \"Expected IN from port %d from L2, got port %d\",\n\t\t    ARBITRARY_IO_PORT, run->io.port);\n\tvcpu_events_get(vcpu, &events);\n\tevents.flags |= KVM_VCPUEVENT_VALID_TRIPLE_FAULT;\n\tevents.triple_fault.pending = true;\n\tvcpu_events_set(vcpu, &events);\n\trun->immediate_exit = true;\n\tvcpu_run_complete_io(vcpu);\n\n\tvcpu_events_get(vcpu, &events);\n\tTEST_ASSERT(events.flags & KVM_VCPUEVENT_VALID_TRIPLE_FAULT,\n\t\t    \"Triple fault event invalid\");\n\tTEST_ASSERT(events.triple_fault.pending,\n\t\t    \"No triple fault pending\");\n\tvcpu_run(vcpu);\n\n\n\tif (has_svm) {\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_SHUTDOWN);\n\t} else {\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_DONE:\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unexpected ucall: %lu\", uc.cmd);\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}