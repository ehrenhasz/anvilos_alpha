{
  "module_name": "debug_regs.c",
  "hash_id": "d5f8c0ee92da2507d9f3c4e8b040a35096f5bacd9fb8265f8aec621ab9d68b1a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/debug_regs.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <string.h>\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"apic.h\"\n\n#define DR6_BD\t\t(1 << 13)\n#define DR7_GD\t\t(1 << 13)\n\n#define IRQ_VECTOR 0xAA\n\n \nuint32_t guest_value;\n\nextern unsigned char sw_bp, hw_bp, write_data, ss_start, bd_start;\n\nstatic void guest_code(void)\n{\n\t \n\tx2apic_enable();\n\tx2apic_write_reg(APIC_ICR, APIC_DEST_SELF | APIC_INT_ASSERT |\n\t\t\t APIC_DM_FIXED | IRQ_VECTOR);\n\n\t \n\tasm volatile(\"sw_bp: int3\");\n\n\t \n\tasm volatile(\"hw_bp: nop\");\n\n\t \n\tasm volatile(\"mov $1234,%%rax;\\n\\t\"\n\t\t     \"mov %%rax,%0;\\n\\t write_data:\"\n\t\t     : \"=m\" (guest_value) : : \"rax\");\n\n\t \n\tasm volatile(\"ss_start: \"\n\t\t     \"sti\\n\\t\"\n\t\t     \"xor %%eax,%%eax\\n\\t\"\n\t\t     \"cpuid\\n\\t\"\n\t\t     \"movl $0x1a0,%%ecx\\n\\t\"\n\t\t     \"rdmsr\\n\\t\"\n\t\t     \"cli\\n\\t\"\n\t\t     : : : \"eax\", \"ebx\", \"ecx\", \"edx\");\n\n\t \n\tasm volatile(\"bd_start: mov %%dr0, %%rax\" : : : \"rax\");\n\tGUEST_DONE();\n}\n\n#define  CAST_TO_RIP(v)  ((unsigned long long)&(v))\n\nstatic void vcpu_skip_insn(struct kvm_vcpu *vcpu, int insn_len)\n{\n\tstruct kvm_regs regs;\n\n\tvcpu_regs_get(vcpu, &regs);\n\tregs.rip += insn_len;\n\tvcpu_regs_set(vcpu, &regs);\n}\n\nint main(void)\n{\n\tstruct kvm_guest_debug debug;\n\tunsigned long long target_dr6, target_rip;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_run *run;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\tuint64_t cmd;\n\tint i;\n\t \n\tint ss_size[6] = {\n\t\t1,\t\t \n\t\t2,\t\t \n\t\t2,\t\t \n\t\t5,\t\t \n\t\t2,\t\t \n\t\t1,\t\t \n\t};\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_SET_GUEST_DEBUG));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\trun = vcpu->run;\n\n\t \n\tmemset(&debug, 0, sizeof(debug));\n\tdebug.control = KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP;\n\tvcpu_guest_debug_set(vcpu, &debug);\n\tvcpu_run(vcpu);\n\tTEST_ASSERT(run->exit_reason == KVM_EXIT_DEBUG &&\n\t\t    run->debug.arch.exception == BP_VECTOR &&\n\t\t    run->debug.arch.pc == CAST_TO_RIP(sw_bp),\n\t\t    \"INT3: exit %d exception %d rip 0x%llx (should be 0x%llx)\",\n\t\t    run->exit_reason, run->debug.arch.exception,\n\t\t    run->debug.arch.pc, CAST_TO_RIP(sw_bp));\n\tvcpu_skip_insn(vcpu, 1);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tmemset(&debug, 0, sizeof(debug));\n\t\tdebug.control = KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_HW_BP;\n\t\tdebug.arch.debugreg[i] = CAST_TO_RIP(hw_bp);\n\t\tdebug.arch.debugreg[7] = 0x400 | (1UL << (2*i+1));\n\t\tvcpu_guest_debug_set(vcpu, &debug);\n\t\tvcpu_run(vcpu);\n\t\ttarget_dr6 = 0xffff0ff0 | (1UL << i);\n\t\tTEST_ASSERT(run->exit_reason == KVM_EXIT_DEBUG &&\n\t\t\t    run->debug.arch.exception == DB_VECTOR &&\n\t\t\t    run->debug.arch.pc == CAST_TO_RIP(hw_bp) &&\n\t\t\t    run->debug.arch.dr6 == target_dr6,\n\t\t\t    \"INS_HW_BP (DR%d): exit %d exception %d rip 0x%llx \"\n\t\t\t    \"(should be 0x%llx) dr6 0x%llx (should be 0x%llx)\",\n\t\t\t    i, run->exit_reason, run->debug.arch.exception,\n\t\t\t    run->debug.arch.pc, CAST_TO_RIP(hw_bp),\n\t\t\t    run->debug.arch.dr6, target_dr6);\n\t}\n\t \n\tvcpu_skip_insn(vcpu, 1);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tmemset(&debug, 0, sizeof(debug));\n\t\tdebug.control = KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_HW_BP;\n\t\tdebug.arch.debugreg[i] = CAST_TO_RIP(guest_value);\n\t\tdebug.arch.debugreg[7] = 0x00000400 | (1UL << (2*i+1)) |\n\t\t    (0x000d0000UL << (4*i));\n\t\tvcpu_guest_debug_set(vcpu, &debug);\n\t\tvcpu_run(vcpu);\n\t\ttarget_dr6 = 0xffff0ff0 | (1UL << i);\n\t\tTEST_ASSERT(run->exit_reason == KVM_EXIT_DEBUG &&\n\t\t\t    run->debug.arch.exception == DB_VECTOR &&\n\t\t\t    run->debug.arch.pc == CAST_TO_RIP(write_data) &&\n\t\t\t    run->debug.arch.dr6 == target_dr6,\n\t\t\t    \"DATA_HW_BP (DR%d): exit %d exception %d rip 0x%llx \"\n\t\t\t    \"(should be 0x%llx) dr6 0x%llx (should be 0x%llx)\",\n\t\t\t    i, run->exit_reason, run->debug.arch.exception,\n\t\t\t    run->debug.arch.pc, CAST_TO_RIP(write_data),\n\t\t\t    run->debug.arch.dr6, target_dr6);\n\t\t \n\t\tvcpu_skip_insn(vcpu, -7);\n\t}\n\t \n\tvcpu_skip_insn(vcpu, 7);\n\n\t \n\ttarget_rip = CAST_TO_RIP(ss_start);\n\ttarget_dr6 = 0xffff4ff0ULL;\n\tfor (i = 0; i < (sizeof(ss_size) / sizeof(ss_size[0])); i++) {\n\t\ttarget_rip += ss_size[i];\n\t\tmemset(&debug, 0, sizeof(debug));\n\t\tdebug.control = KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_SINGLESTEP |\n\t\t\t\tKVM_GUESTDBG_BLOCKIRQ;\n\t\tdebug.arch.debugreg[7] = 0x00000400;\n\t\tvcpu_guest_debug_set(vcpu, &debug);\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT(run->exit_reason == KVM_EXIT_DEBUG &&\n\t\t\t    run->debug.arch.exception == DB_VECTOR &&\n\t\t\t    run->debug.arch.pc == target_rip &&\n\t\t\t    run->debug.arch.dr6 == target_dr6,\n\t\t\t    \"SINGLE_STEP[%d]: exit %d exception %d rip 0x%llx \"\n\t\t\t    \"(should be 0x%llx) dr6 0x%llx (should be 0x%llx)\",\n\t\t\t    i, run->exit_reason, run->debug.arch.exception,\n\t\t\t    run->debug.arch.pc, target_rip, run->debug.arch.dr6,\n\t\t\t    target_dr6);\n\t}\n\n\t \n\tmemset(&debug, 0, sizeof(debug));\n\tdebug.control = KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_HW_BP;\n\tdebug.arch.debugreg[7] = 0x400 | DR7_GD;\n\tvcpu_guest_debug_set(vcpu, &debug);\n\tvcpu_run(vcpu);\n\ttarget_dr6 = 0xffff0ff0 | DR6_BD;\n\tTEST_ASSERT(run->exit_reason == KVM_EXIT_DEBUG &&\n\t\t    run->debug.arch.exception == DB_VECTOR &&\n\t\t    run->debug.arch.pc == CAST_TO_RIP(bd_start) &&\n\t\t    run->debug.arch.dr6 == target_dr6,\n\t\t\t    \"DR7.GD: exit %d exception %d rip 0x%llx \"\n\t\t\t    \"(should be 0x%llx) dr6 0x%llx (should be 0x%llx)\",\n\t\t\t    run->exit_reason, run->debug.arch.exception,\n\t\t\t    run->debug.arch.pc, target_rip, run->debug.arch.dr6,\n\t\t\t    target_dr6);\n\n\t \n\tmemset(&debug, 0, sizeof(debug));\n\tvcpu_guest_debug_set(vcpu, &debug);\n\n\tvcpu_run(vcpu);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\tcmd = get_ucall(vcpu, &uc);\n\tTEST_ASSERT(cmd == UCALL_DONE, \"UCALL_DONE\");\n\n\tkvm_vm_free(vm);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}