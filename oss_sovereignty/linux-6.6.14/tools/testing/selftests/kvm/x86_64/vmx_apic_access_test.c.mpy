{
  "module_name": "vmx_apic_access_test.c",
  "hash_id": "ebb724b37fac2e603905140627048bfcf51a12d6f131765a07a324f5d5cdbb8e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_apic_access_test.c",
  "human_readable_source": "\n \n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"kselftest.h\"\n\nstatic void l2_guest_code(void)\n{\n\t \n\t__asm__ __volatile__(\"vmcall\");\n}\n\nstatic void l1_guest_code(struct vmx_pages *vmx_pages, unsigned long high_gpa)\n{\n#define L2_GUEST_STACK_SIZE 64\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\tuint32_t control;\n\n\tGUEST_ASSERT(prepare_for_vmx_operation(vmx_pages));\n\tGUEST_ASSERT(load_vmcs(vmx_pages));\n\n\t \n\tprepare_vmcs(vmx_pages, l2_guest_code,\n\t\t     &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\tcontrol = vmreadz(CPU_BASED_VM_EXEC_CONTROL);\n\tcontrol |= CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\tvmwrite(CPU_BASED_VM_EXEC_CONTROL, control);\n\tcontrol = vmreadz(SECONDARY_VM_EXEC_CONTROL);\n\tcontrol |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tvmwrite(SECONDARY_VM_EXEC_CONTROL, control);\n\tvmwrite(APIC_ACCESS_ADDR, vmx_pages->apic_access_gpa);\n\n\t \n\tGUEST_SYNC(vmreadz(APIC_ACCESS_ADDR));\n\tGUEST_ASSERT(!vmlaunch());\n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_VMCALL);\n\n\tvmwrite(APIC_ACCESS_ADDR, high_gpa);\n\n\t \n\tGUEST_SYNC(vmreadz(APIC_ACCESS_ADDR));\n\tGUEST_ASSERT(!vmresume());\n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_VMCALL);\n\n\tGUEST_DONE();\n}\n\nint main(int argc, char *argv[])\n{\n\tunsigned long apic_access_addr = ~0ul;\n\tvm_vaddr_t vmx_pages_gva;\n\tunsigned long high_gpa;\n\tstruct vmx_pages *vmx;\n\tbool done = false;\n\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, l1_guest_code);\n\n\thigh_gpa = (vm->max_gfn - 1) << vm->page_shift;\n\n\tvmx = vcpu_alloc_vmx(vm, &vmx_pages_gva);\n\tprepare_virtualize_apic_accesses(vmx, vm);\n\tvcpu_args_set(vcpu, 2, vmx_pages_gva, high_gpa);\n\n\twhile (!done) {\n\t\tvolatile struct kvm_run *run = vcpu->run;\n\t\tstruct ucall uc;\n\n\t\tvcpu_run(vcpu);\n\t\tif (apic_access_addr == high_gpa) {\n\t\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_INTERNAL_ERROR);\n\t\t\tTEST_ASSERT(run->internal.suberror ==\n\t\t\t\t    KVM_INTERNAL_ERROR_EMULATION,\n\t\t\t\t    \"Got internal suberror other than KVM_INTERNAL_ERROR_EMULATION: %u\\n\",\n\t\t\t\t    run->internal.suberror);\n\t\t\tbreak;\n\t\t}\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t \n\t\tcase UCALL_SYNC:\n\t\t\tapic_access_addr = uc.args[1];\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTEST_ASSERT(false, \"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\t}\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}