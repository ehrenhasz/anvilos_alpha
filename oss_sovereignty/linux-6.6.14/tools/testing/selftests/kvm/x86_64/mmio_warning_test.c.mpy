{
  "module_name": "mmio_warning_test.c",
  "hash_id": "1b4faaad6e236c12bbf5a4f2cdf39c1386e51a93d596f06d27eec3a6e924df29",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/mmio_warning_test.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n#include <fcntl.h>\n#include <kvm_util.h>\n#include <linux/kvm.h>\n#include <processor.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <test_util.h>\n#include <unistd.h>\n\n#define NTHREAD 4\n#define NPROCESS 5\n\nstruct thread_context {\n\tint kvmcpu;\n\tstruct kvm_run *run;\n};\n\nvoid *thr(void *arg)\n{\n\tstruct thread_context *tc = (struct thread_context *)arg;\n\tint res;\n\tint kvmcpu = tc->kvmcpu;\n\tstruct kvm_run *run = tc->run;\n\n\tres = ioctl(kvmcpu, KVM_RUN, 0);\n\tpr_info(\"ret1=%d exit_reason=%d suberror=%d\\n\",\n\t\tres, run->exit_reason, run->internal.suberror);\n\n\treturn 0;\n}\n\nvoid test(void)\n{\n\tint i, kvm, kvmvm, kvmcpu;\n\tpthread_t th[NTHREAD];\n\tstruct kvm_run *run;\n\tstruct thread_context tc;\n\n\tkvm = open(\"/dev/kvm\", O_RDWR);\n\tTEST_ASSERT(kvm != -1, \"failed to open /dev/kvm\");\n\tkvmvm = __kvm_ioctl(kvm, KVM_CREATE_VM, NULL);\n\tTEST_ASSERT(kvmvm > 0, KVM_IOCTL_ERROR(KVM_CREATE_VM, kvmvm));\n\tkvmcpu = ioctl(kvmvm, KVM_CREATE_VCPU, 0);\n\tTEST_ASSERT(kvmcpu != -1, KVM_IOCTL_ERROR(KVM_CREATE_VCPU, kvmcpu));\n\trun = (struct kvm_run *)mmap(0, 4096, PROT_READ|PROT_WRITE, MAP_SHARED,\n\t\t\t\t    kvmcpu, 0);\n\ttc.kvmcpu = kvmcpu;\n\ttc.run = run;\n\tsrand(getpid());\n\tfor (i = 0; i < NTHREAD; i++) {\n\t\tpthread_create(&th[i], NULL, thr, (void *)(uintptr_t)&tc);\n\t\tusleep(rand() % 10000);\n\t}\n\tfor (i = 0; i < NTHREAD; i++)\n\t\tpthread_join(th[i], NULL);\n}\n\nint get_warnings_count(void)\n{\n\tint warnings;\n\tFILE *f;\n\n\tf = popen(\"dmesg | grep \\\"WARNING:\\\" | wc -l\", \"r\");\n\tif (fscanf(f, \"%d\", &warnings) < 1)\n\t\twarnings = 0;\n\tpclose(f);\n\n\treturn warnings;\n}\n\nint main(void)\n{\n\tint warnings_before, warnings_after;\n\n\tTEST_REQUIRE(host_cpu_is_intel);\n\n\tTEST_REQUIRE(!vm_is_unrestricted_guest(NULL));\n\n\twarnings_before = get_warnings_count();\n\n\tfor (int i = 0; i < NPROCESS; ++i) {\n\t\tint status;\n\t\tint pid = fork();\n\n\t\tif (pid < 0)\n\t\t\texit(1);\n\t\tif (pid == 0) {\n\t\t\ttest();\n\t\t\texit(0);\n\t\t}\n\t\twhile (waitpid(pid, &status, __WALL) != pid)\n\t\t\t;\n\t}\n\n\twarnings_after = get_warnings_count();\n\tTEST_ASSERT(warnings_before == warnings_after,\n\t\t   \"Warnings found in kernel.  Run 'dmesg' to inspect them.\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}