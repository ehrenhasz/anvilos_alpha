{
  "module_name": "vmx_dirty_log_test.c",
  "hash_id": "f16090b691e20953ed396b36d064cd8ff497510037dc0a32dc9b8d6b443c53c2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_dirty_log_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n\n \n#define TEST_MEM_SLOT_INDEX\t\t1\n#define TEST_MEM_PAGES\t\t\t3\n\n \n#define GUEST_TEST_MEM\t\t\t0xc0000000\n\n \n#define NESTED_TEST_MEM1\t\t0xc0001000\n#define NESTED_TEST_MEM2\t\t0xc0002000\n\nstatic void l2_guest_code(void)\n{\n\t*(volatile uint64_t *)NESTED_TEST_MEM1;\n\t*(volatile uint64_t *)NESTED_TEST_MEM1 = 1;\n\tGUEST_SYNC(true);\n\tGUEST_SYNC(false);\n\n\t*(volatile uint64_t *)NESTED_TEST_MEM2 = 1;\n\tGUEST_SYNC(true);\n\t*(volatile uint64_t *)NESTED_TEST_MEM2 = 1;\n\tGUEST_SYNC(true);\n\tGUEST_SYNC(false);\n\n\t \n\tvmcall();\n}\n\nvoid l1_guest_code(struct vmx_pages *vmx)\n{\n#define L2_GUEST_STACK_SIZE 64\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\n\tGUEST_ASSERT(vmx->vmcs_gpa);\n\tGUEST_ASSERT(prepare_for_vmx_operation(vmx));\n\tGUEST_ASSERT(load_vmcs(vmx));\n\n\tprepare_vmcs(vmx, l2_guest_code,\n\t\t     &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\n\tGUEST_SYNC(false);\n\tGUEST_ASSERT(!vmlaunch());\n\tGUEST_SYNC(false);\n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_VMCALL);\n\tGUEST_DONE();\n}\n\nint main(int argc, char *argv[])\n{\n\tvm_vaddr_t vmx_pages_gva = 0;\n\tstruct vmx_pages *vmx;\n\tunsigned long *bmap;\n\tuint64_t *host_test_mem;\n\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\tbool done = false;\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));\n\tTEST_REQUIRE(kvm_cpu_has_ept());\n\n\t \n\tvm = vm_create_with_one_vcpu(&vcpu, l1_guest_code);\n\tvmx = vcpu_alloc_vmx(vm, &vmx_pages_gva);\n\tvcpu_args_set(vcpu, 1, vmx_pages_gva);\n\n\t \n\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS,\n\t\t\t\t    GUEST_TEST_MEM,\n\t\t\t\t    TEST_MEM_SLOT_INDEX,\n\t\t\t\t    TEST_MEM_PAGES,\n\t\t\t\t    KVM_MEM_LOG_DIRTY_PAGES);\n\n\t \n\tvirt_map(vm, GUEST_TEST_MEM, GUEST_TEST_MEM, TEST_MEM_PAGES);\n\n\t \n\tprepare_eptp(vmx, vm, 0);\n\tnested_map_memslot(vmx, vm, 0);\n\tnested_map(vmx, vm, NESTED_TEST_MEM1, GUEST_TEST_MEM, 4096);\n\tnested_map(vmx, vm, NESTED_TEST_MEM2, GUEST_TEST_MEM, 4096);\n\n\tbmap = bitmap_zalloc(TEST_MEM_PAGES);\n\thost_test_mem = addr_gpa2hva(vm, GUEST_TEST_MEM);\n\n\twhile (!done) {\n\t\tmemset(host_test_mem, 0xaa, TEST_MEM_PAGES * 4096);\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t \n\t\tcase UCALL_SYNC:\n\t\t\t \n\t\t\tkvm_vm_get_dirty_log(vm, TEST_MEM_SLOT_INDEX, bmap);\n\t\t\tif (uc.args[1]) {\n\t\t\t\tTEST_ASSERT(test_bit(0, bmap), \"Page 0 incorrectly reported clean\\n\");\n\t\t\t\tTEST_ASSERT(host_test_mem[0] == 1, \"Page 0 not written by guest\\n\");\n\t\t\t} else {\n\t\t\t\tTEST_ASSERT(!test_bit(0, bmap), \"Page 0 incorrectly reported dirty\\n\");\n\t\t\t\tTEST_ASSERT(host_test_mem[0] == 0xaaaaaaaaaaaaaaaaULL, \"Page 0 written by guest\\n\");\n\t\t\t}\n\n\t\t\tTEST_ASSERT(!test_bit(1, bmap), \"Page 1 incorrectly reported dirty\\n\");\n\t\t\tTEST_ASSERT(host_test_mem[4096 / 8] == 0xaaaaaaaaaaaaaaaaULL, \"Page 1 written by guest\\n\");\n\t\t\tTEST_ASSERT(!test_bit(2, bmap), \"Page 2 incorrectly reported dirty\\n\");\n\t\t\tTEST_ASSERT(host_test_mem[8192 / 8] == 0xaaaaaaaaaaaaaaaaULL, \"Page 2 written by guest\\n\");\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}