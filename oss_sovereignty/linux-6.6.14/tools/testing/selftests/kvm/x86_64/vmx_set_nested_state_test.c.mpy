{
  "module_name": "vmx_set_nested_state_test.c",
  "hash_id": "7cea1f571d7d604579fe5bd1decb1d992678a25d13ee72205293c97af6813c75",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_set_nested_state_test.c",
  "human_readable_source": "\n \n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n\n#include <errno.h>\n#include <linux/kvm.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n\n \n#define VMCS12_REVISION 0x11e57ed0\n\nbool have_evmcs;\n\nvoid test_nested_state(struct kvm_vcpu *vcpu, struct kvm_nested_state *state)\n{\n\tvcpu_nested_state_set(vcpu, state);\n}\n\nvoid test_nested_state_expect_errno(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_nested_state *state,\n\t\t\t\t    int expected_errno)\n{\n\tint rv;\n\n\trv = __vcpu_nested_state_set(vcpu, state);\n\tTEST_ASSERT(rv == -1 && errno == expected_errno,\n\t\t\"Expected %s (%d) from vcpu_nested_state_set but got rv: %i errno: %s (%d)\",\n\t\tstrerror(expected_errno), expected_errno, rv, strerror(errno),\n\t\terrno);\n}\n\nvoid test_nested_state_expect_einval(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_nested_state *state)\n{\n\ttest_nested_state_expect_errno(vcpu, state, EINVAL);\n}\n\nvoid test_nested_state_expect_efault(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_nested_state *state)\n{\n\ttest_nested_state_expect_errno(vcpu, state, EFAULT);\n}\n\nvoid set_revision_id_for_vmcs12(struct kvm_nested_state *state,\n\t\t\t\tu32 vmcs12_revision)\n{\n\t \n\tmemcpy(&state->data, &vmcs12_revision, sizeof(u32));\n}\n\nvoid set_default_state(struct kvm_nested_state *state)\n{\n\tmemset(state, 0, sizeof(*state));\n\tstate->flags = KVM_STATE_NESTED_RUN_PENDING |\n\t\t       KVM_STATE_NESTED_GUEST_MODE;\n\tstate->format = 0;\n\tstate->size = sizeof(*state);\n}\n\nvoid set_default_vmx_state(struct kvm_nested_state *state, int size)\n{\n\tmemset(state, 0, size);\n\tif (have_evmcs)\n\t\tstate->flags = KVM_STATE_NESTED_EVMCS;\n\tstate->format = 0;\n\tstate->size = size;\n\tstate->hdr.vmx.vmxon_pa = 0x1000;\n\tstate->hdr.vmx.vmcs12_pa = 0x2000;\n\tstate->hdr.vmx.smm.flags = 0;\n\tset_revision_id_for_vmcs12(state, VMCS12_REVISION);\n}\n\nvoid test_vmx_nested_state(struct kvm_vcpu *vcpu)\n{\n\t \n\tconst int state_sz = sizeof(struct kvm_nested_state) + getpagesize();\n\tstruct kvm_nested_state *state =\n\t\t(struct kvm_nested_state *)malloc(state_sz);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->format = 1;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->hdr.vmx.vmxon_pa = -1ull;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\tstate->hdr.vmx.vmcs12_pa = -1ull;\n\tstate->flags = KVM_STATE_NESTED_EVMCS;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\tstate->flags = 0;\n\ttest_nested_state(vcpu, state);\n\n\t \n\tvcpu_set_cpuid_feature(vcpu, X86_FEATURE_VMX);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->hdr.vmx.vmxon_pa = -1ull;\n\tstate->hdr.vmx.vmcs12_pa = -1ull;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\tstate->flags &= KVM_STATE_NESTED_EVMCS;\n\tif (have_evmcs) {\n\t\ttest_nested_state_expect_einval(vcpu, state);\n\t\tvcpu_enable_evmcs(vcpu);\n\t}\n\ttest_nested_state(vcpu, state);\n\n\t \n\tstate->hdr.vmx.smm.flags = 1;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->hdr.vmx.flags = ~0;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->hdr.vmx.vmxon_pa = -1ull;\n\tstate->flags = 0;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->hdr.vmx.vmxon_pa = 1;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->flags = KVM_STATE_NESTED_GUEST_MODE  |\n\t\t      KVM_STATE_NESTED_RUN_PENDING;\n\tstate->hdr.vmx.smm.flags = KVM_STATE_NESTED_SMM_GUEST_MODE;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->hdr.vmx.smm.flags = ~(KVM_STATE_NESTED_SMM_GUEST_MODE |\n\t\t\t\tKVM_STATE_NESTED_SMM_VMXON);\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->flags = 0;\n\tstate->hdr.vmx.smm.flags = KVM_STATE_NESTED_SMM_GUEST_MODE;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->size = sizeof(*state);\n\tstate->flags = 0;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\tset_default_vmx_state(state, state_sz);\n\tstate->size = sizeof(*state);\n\tstate->flags = 0;\n\tstate->hdr.vmx.vmcs12_pa = -1;\n\ttest_nested_state(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->flags = 0;\n\ttest_nested_state(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->size = sizeof(*state);\n\tstate->flags = 0;\n\tstate->hdr.vmx.vmcs12_pa = -1;\n\tstate->hdr.vmx.flags = ~0;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->hdr.vmx.vmxon_pa = 0;\n\tstate->hdr.vmx.vmcs12_pa = 0;\n\ttest_nested_state_expect_einval(vcpu, state);\n\n\t \n\tset_default_vmx_state(state, state_sz);\n\tstate->hdr.vmx.vmxon_pa = -1ull;\n\tstate->hdr.vmx.vmcs12_pa = -1ull;\n\tstate->flags = 0;\n\ttest_nested_state(vcpu, state);\n\tvcpu_nested_state_get(vcpu, state);\n\tTEST_ASSERT(state->size >= sizeof(*state) && state->size <= state_sz,\n\t\t    \"Size must be between %ld and %d.  The size returned was %d.\",\n\t\t    sizeof(*state), state_sz, state->size);\n\tTEST_ASSERT(state->hdr.vmx.vmxon_pa == -1ull, \"vmxon_pa must be -1ull.\");\n\tTEST_ASSERT(state->hdr.vmx.vmcs12_pa == -1ull, \"vmcs_pa must be -1ull.\");\n\n\tfree(state);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vm *vm;\n\tstruct kvm_nested_state state;\n\tstruct kvm_vcpu *vcpu;\n\n\thave_evmcs = kvm_check_cap(KVM_CAP_HYPERV_ENLIGHTENED_VMCS);\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_NESTED_STATE));\n\n\t \n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, NULL);\n\n\t \n\tvcpu_clear_cpuid_feature(vcpu, X86_FEATURE_VMX);\n\n\t \n\ttest_nested_state_expect_efault(vcpu, NULL);\n\n\t \n\tset_default_state(&state);\n\tstate.size = 0;\n\ttest_nested_state_expect_einval(vcpu, &state);\n\n\t \n\tset_default_state(&state);\n\tstate.flags = 0xf;\n\ttest_nested_state_expect_einval(vcpu, &state);\n\n\t \n\tset_default_state(&state);\n\tstate.flags = KVM_STATE_NESTED_RUN_PENDING;\n\ttest_nested_state_expect_einval(vcpu, &state);\n\n\ttest_vmx_nested_state(vcpu);\n\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}