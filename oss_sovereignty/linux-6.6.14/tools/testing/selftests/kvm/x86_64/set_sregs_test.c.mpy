{
  "module_name": "set_sregs_test.c",
  "hash_id": "e7b7ce635045effd815037f8a757cb3f84cf6a51ea3c82b0f1fbca4947b8ef3d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/set_sregs_test.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n#define TEST_INVALID_CR_BIT(vcpu, cr, orig, bit)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tstruct kvm_sregs new;\t\t\t\t\t\t\t\\\n\tint rc;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\\\n\tif (orig.cr & bit)\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tmemcpy(&new, &orig, sizeof(sregs));\t\t\t\t\t\\\n\tnew.cr |= bit;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\trc = _vcpu_sregs_set(vcpu, &new);\t\t\t\t\t\\\n\tTEST_ASSERT(rc, \"KVM allowed invalid \" #cr \" bit (0x%lx)\", bit);\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\\\n\tvcpu_sregs_get(vcpu, &new);\t\t\t\t\t\t\\\n\tTEST_ASSERT(!memcmp(&new, &orig, sizeof(new)), \"KVM modified sregs\");\t\\\n} while (0)\n\nstatic uint64_t calc_supported_cr4_feature_bits(void)\n{\n\tuint64_t cr4;\n\n\tcr4 = X86_CR4_VME | X86_CR4_PVI | X86_CR4_TSD | X86_CR4_DE |\n\t      X86_CR4_PSE | X86_CR4_PAE | X86_CR4_MCE | X86_CR4_PGE |\n\t      X86_CR4_PCE | X86_CR4_OSFXSR | X86_CR4_OSXMMEXCPT;\n\tif (kvm_cpu_has(X86_FEATURE_UMIP))\n\t\tcr4 |= X86_CR4_UMIP;\n\tif (kvm_cpu_has(X86_FEATURE_LA57))\n\t\tcr4 |= X86_CR4_LA57;\n\tif (kvm_cpu_has(X86_FEATURE_VMX))\n\t\tcr4 |= X86_CR4_VMXE;\n\tif (kvm_cpu_has(X86_FEATURE_SMX))\n\t\tcr4 |= X86_CR4_SMXE;\n\tif (kvm_cpu_has(X86_FEATURE_FSGSBASE))\n\t\tcr4 |= X86_CR4_FSGSBASE;\n\tif (kvm_cpu_has(X86_FEATURE_PCID))\n\t\tcr4 |= X86_CR4_PCIDE;\n\tif (kvm_cpu_has(X86_FEATURE_XSAVE))\n\t\tcr4 |= X86_CR4_OSXSAVE;\n\tif (kvm_cpu_has(X86_FEATURE_SMEP))\n\t\tcr4 |= X86_CR4_SMEP;\n\tif (kvm_cpu_has(X86_FEATURE_SMAP))\n\t\tcr4 |= X86_CR4_SMAP;\n\tif (kvm_cpu_has(X86_FEATURE_PKU))\n\t\tcr4 |= X86_CR4_PKE;\n\n\treturn cr4;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_sregs sregs;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tuint64_t cr4;\n\tint rc, i;\n\n\t \n\tvm = vm_create_barebones();\n\tvcpu = __vm_vcpu_add(vm, 0);\n\n\tvcpu_sregs_get(vcpu, &sregs);\n\n\tsregs.cr0 = 0;\n\tsregs.cr4 |= calc_supported_cr4_feature_bits();\n\tcr4 = sregs.cr4;\n\n\trc = _vcpu_sregs_set(vcpu, &sregs);\n\tTEST_ASSERT(!rc, \"Failed to set supported CR4 bits (0x%lx)\", cr4);\n\n\tvcpu_sregs_get(vcpu, &sregs);\n\tTEST_ASSERT(sregs.cr4 == cr4, \"sregs.CR4 (0x%llx) != CR4 (0x%lx)\",\n\t\t    sregs.cr4, cr4);\n\n\t \n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_UMIP);\n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_LA57);\n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_VMXE);\n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_SMXE);\n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_FSGSBASE);\n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_PCIDE);\n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_OSXSAVE);\n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_SMEP);\n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_SMAP);\n\tTEST_INVALID_CR_BIT(vcpu, cr4, sregs, X86_CR4_PKE);\n\n\tfor (i = 32; i < 64; i++)\n\t\tTEST_INVALID_CR_BIT(vcpu, cr0, sregs, BIT(i));\n\n\t \n\tTEST_INVALID_CR_BIT(vcpu, cr0, sregs, X86_CR0_NW);\n\tTEST_INVALID_CR_BIT(vcpu, cr0, sregs, X86_CR0_PG);\n\n\tkvm_vm_free(vm);\n\n\t \n\tvm = vm_create_with_one_vcpu(&vcpu, NULL);\n\n\tvcpu_sregs_get(vcpu, &sregs);\n\tsregs.apic_base = 1 << 10;\n\trc = _vcpu_sregs_set(vcpu, &sregs);\n\tTEST_ASSERT(rc, \"Set IA32_APIC_BASE to %llx (invalid)\",\n\t\t    sregs.apic_base);\n\tsregs.apic_base = 1 << 11;\n\trc = _vcpu_sregs_set(vcpu, &sregs);\n\tTEST_ASSERT(!rc, \"Couldn't set IA32_APIC_BASE to %llx (valid)\",\n\t\t    sregs.apic_base);\n\n\tkvm_vm_free(vm);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}