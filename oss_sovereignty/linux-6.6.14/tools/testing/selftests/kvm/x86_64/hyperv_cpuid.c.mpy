{
  "module_name": "hyperv_cpuid.c",
  "hash_id": "38f2290087c79e858c7b7376b42a582212a5a7c1391731933dd645736ec7baf4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n\nstatic void guest_code(void)\n{\n}\n\nstatic bool smt_possible(void)\n{\n\tchar buf[16];\n\tFILE *f;\n\tbool res = true;\n\n\tf = fopen(\"/sys/devices/system/cpu/smt/control\", \"r\");\n\tif (f) {\n\t\tif (fread(buf, sizeof(*buf), sizeof(buf), f) > 0) {\n\t\t\tif (!strncmp(buf, \"forceoff\", 8) ||\n\t\t\t    !strncmp(buf, \"notsupported\", 12))\n\t\t\t\tres = false;\n\t\t}\n\t\tfclose(f);\n\t}\n\n\treturn res;\n}\n\nstatic void test_hv_cpuid(const struct kvm_cpuid2 *hv_cpuid_entries,\n\t\t\t  bool evmcs_expected)\n{\n\tint i;\n\tint nent_expected = 10;\n\tu32 test_val;\n\n\tTEST_ASSERT(hv_cpuid_entries->nent == nent_expected,\n\t\t    \"KVM_GET_SUPPORTED_HV_CPUID should return %d entries\"\n\t\t    \" (returned %d)\",\n\t\t    nent_expected, hv_cpuid_entries->nent);\n\n\tfor (i = 0; i < hv_cpuid_entries->nent; i++) {\n\t\tconst struct kvm_cpuid_entry2 *entry = &hv_cpuid_entries->entries[i];\n\n\t\tTEST_ASSERT((entry->function >= 0x40000000) &&\n\t\t\t    (entry->function <= 0x40000082),\n\t\t\t    \"function %x is our of supported range\",\n\t\t\t    entry->function);\n\n\t\tTEST_ASSERT(entry->index == 0,\n\t\t\t    \".index field should be zero\");\n\n\t\tTEST_ASSERT(entry->flags == 0,\n\t\t\t    \".flags field should be zero\");\n\n\t\tTEST_ASSERT(!entry->padding[0] && !entry->padding[1] &&\n\t\t\t    !entry->padding[2], \"padding should be zero\");\n\n\t\tswitch (entry->function) {\n\t\tcase 0x40000000:\n\t\t\ttest_val = 0x40000082;\n\n\t\t\tTEST_ASSERT(entry->eax == test_val,\n\t\t\t\t    \"Wrong max leaf report in 0x40000000.EAX: %x\"\n\t\t\t\t    \" (evmcs=%d)\",\n\t\t\t\t    entry->eax, evmcs_expected\n\t\t\t\t);\n\t\t\tbreak;\n\t\tcase 0x40000004:\n\t\t\ttest_val = entry->eax & (1UL << 18);\n\n\t\t\tTEST_ASSERT(!!test_val == !smt_possible(),\n\t\t\t\t    \"NoNonArchitecturalCoreSharing bit\"\n\t\t\t\t    \" doesn't reflect SMT setting\");\n\t\t\tbreak;\n\t\tcase 0x4000000A:\n\t\t\tTEST_ASSERT(entry->eax & (1UL << 19),\n\t\t\t\t    \"Enlightened MSR-Bitmap should always be supported\"\n\t\t\t\t    \" 0x40000000.EAX: %x\", entry->eax);\n\t\t\tif (evmcs_expected)\n\t\t\t\tTEST_ASSERT((entry->eax & 0xffff) == 0x101,\n\t\t\t\t    \"Supported Enlightened VMCS version range is supposed to be 1:1\"\n\t\t\t\t    \" 0x40000000.EAX: %x\", entry->eax);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\t\t \n\t}\n}\n\nvoid test_hv_cpuid_e2big(struct kvm_vm *vm, struct kvm_vcpu *vcpu)\n{\n\tstatic struct kvm_cpuid2 cpuid = {.nent = 0};\n\tint ret;\n\n\tif (vcpu)\n\t\tret = __vcpu_ioctl(vcpu, KVM_GET_SUPPORTED_HV_CPUID, &cpuid);\n\telse\n\t\tret = __kvm_ioctl(vm->kvm_fd, KVM_GET_SUPPORTED_HV_CPUID, &cpuid);\n\n\tTEST_ASSERT(ret == -1 && errno == E2BIG,\n\t\t    \"%s KVM_GET_SUPPORTED_HV_CPUID didn't fail with -E2BIG when\"\n\t\t    \" it should have: %d %d\", !vcpu ? \"KVM\" : \"vCPU\", ret, errno);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vm *vm;\n\tconst struct kvm_cpuid2 *hv_cpuid_entries;\n\tstruct kvm_vcpu *vcpu;\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_HYPERV_CPUID));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\t \n\ttest_hv_cpuid_e2big(vm, vcpu);\n\n\thv_cpuid_entries = vcpu_get_supported_hv_cpuid(vcpu);\n\ttest_hv_cpuid(hv_cpuid_entries, false);\n\tfree((void *)hv_cpuid_entries);\n\n\tif (!kvm_cpu_has(X86_FEATURE_VMX) ||\n\t    !kvm_has_cap(KVM_CAP_HYPERV_ENLIGHTENED_VMCS)) {\n\t\tprint_skip(\"Enlightened VMCS is unsupported\");\n\t\tgoto do_sys;\n\t}\n\tvcpu_enable_evmcs(vcpu);\n\thv_cpuid_entries = vcpu_get_supported_hv_cpuid(vcpu);\n\ttest_hv_cpuid(hv_cpuid_entries, true);\n\tfree((void *)hv_cpuid_entries);\n\ndo_sys:\n\t \n\tif (!kvm_has_cap(KVM_CAP_SYS_HYPERV_CPUID)) {\n\t\tprint_skip(\"KVM_CAP_SYS_HYPERV_CPUID not supported\");\n\t\tgoto out;\n\t}\n\n\ttest_hv_cpuid_e2big(vm, NULL);\n\n\thv_cpuid_entries = kvm_get_supported_hv_cpuid();\n\ttest_hv_cpuid(hv_cpuid_entries, kvm_cpu_has(X86_FEATURE_VMX));\n\nout:\n\tkvm_vm_free(vm);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}