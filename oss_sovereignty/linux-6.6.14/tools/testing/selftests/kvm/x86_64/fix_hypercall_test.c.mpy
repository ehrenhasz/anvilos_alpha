{
  "module_name": "fix_hypercall_test.c",
  "hash_id": "bec3715886c21a4542ea0c1ef1bbec9e2a2e7964ea01072bb13b4a67dcb39a82",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/fix_hypercall_test.c",
  "human_readable_source": "\n \n#include <asm/kvm_para.h>\n#include <linux/kvm_para.h>\n#include <linux/stringify.h>\n#include <stdint.h>\n\n#include \"apic.h\"\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n \n#define HYPERCALL_INSN_SIZE\t3\n\nstatic bool quirk_disabled;\n\nstatic void guest_ud_handler(struct ex_regs *regs)\n{\n\tregs->rax = -EFAULT;\n\tregs->rip += HYPERCALL_INSN_SIZE;\n}\n\nstatic const uint8_t vmx_vmcall[HYPERCALL_INSN_SIZE]  = { 0x0f, 0x01, 0xc1 };\nstatic const uint8_t svm_vmmcall[HYPERCALL_INSN_SIZE] = { 0x0f, 0x01, 0xd9 };\n\nextern uint8_t hypercall_insn[HYPERCALL_INSN_SIZE];\nstatic uint64_t do_sched_yield(uint8_t apic_id)\n{\n\tuint64_t ret;\n\n\tasm volatile(\"hypercall_insn:\\n\\t\"\n\t\t     \".byte 0xcc,0xcc,0xcc\\n\\t\"\n\t\t     : \"=a\"(ret)\n\t\t     : \"a\"((uint64_t)KVM_HC_SCHED_YIELD), \"b\"((uint64_t)apic_id)\n\t\t     : \"memory\");\n\n\treturn ret;\n}\n\nstatic void guest_main(void)\n{\n\tconst uint8_t *native_hypercall_insn;\n\tconst uint8_t *other_hypercall_insn;\n\tuint64_t ret;\n\n\tif (host_cpu_is_intel) {\n\t\tnative_hypercall_insn = vmx_vmcall;\n\t\tother_hypercall_insn  = svm_vmmcall;\n\t} else if (host_cpu_is_amd) {\n\t\tnative_hypercall_insn = svm_vmmcall;\n\t\tother_hypercall_insn  = vmx_vmcall;\n\t} else {\n\t\tGUEST_ASSERT(0);\n\t\t \n\t\treturn;\n\t}\n\n\tmemcpy(hypercall_insn, other_hypercall_insn, HYPERCALL_INSN_SIZE);\n\n\tret = do_sched_yield(GET_APIC_ID_FIELD(xapic_read_reg(APIC_ID)));\n\n\t \n\tif (quirk_disabled) {\n\t\tGUEST_ASSERT(ret == (uint64_t)-EFAULT);\n\t\tGUEST_ASSERT(!memcmp(other_hypercall_insn, hypercall_insn,\n\t\t\t     HYPERCALL_INSN_SIZE));\n\t} else {\n\t\tGUEST_ASSERT(!ret);\n\t\tGUEST_ASSERT(!memcmp(native_hypercall_insn, hypercall_insn,\n\t\t\t     HYPERCALL_INSN_SIZE));\n\t}\n\n\tGUEST_DONE();\n}\n\nstatic void enter_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct ucall uc;\n\n\tvcpu_run(vcpu);\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_SYNC:\n\t\tpr_info(\"%s: %016lx\\n\", (const char *)uc.args[2], uc.args[3]);\n\t\tbreak;\n\tcase UCALL_DONE:\n\t\treturn;\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\tdefault:\n\t\tTEST_FAIL(\"Unhandled ucall: %ld\\nexit_reason: %u (%s)\",\n\t\t\t  uc.cmd, run->exit_reason, exit_reason_str(run->exit_reason));\n\t}\n}\n\nstatic void test_fix_hypercall(bool disable_quirk)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_main);\n\n\tvm_init_descriptor_tables(vcpu->vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\tvm_install_exception_handler(vcpu->vm, UD_VECTOR, guest_ud_handler);\n\n\tif (disable_quirk)\n\t\tvm_enable_cap(vm, KVM_CAP_DISABLE_QUIRKS2,\n\t\t\t      KVM_X86_QUIRK_FIX_HYPERCALL_INSN);\n\n\tquirk_disabled = disable_quirk;\n\tsync_global_to_guest(vm, quirk_disabled);\n\n\tvirt_pg_map(vm, APIC_DEFAULT_GPA, APIC_DEFAULT_GPA);\n\n\tenter_guest(vcpu);\n}\n\nint main(void)\n{\n\tTEST_REQUIRE(kvm_check_cap(KVM_CAP_DISABLE_QUIRKS2) & KVM_X86_QUIRK_FIX_HYPERCALL_INSN);\n\n\ttest_fix_hypercall(false);\n\ttest_fix_hypercall(true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}