{
  "module_name": "sev_migrate_tests.c",
  "hash_id": "8923366de306dded9cb851275cef34162fe51960c81dfc68baf4119354533b84",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/sev_migrate_tests.c",
  "human_readable_source": "\n#include <linux/kvm.h>\n#include <linux/psp-sev.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pthread.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"svm_util.h\"\n#include \"kselftest.h\"\n\n#define SEV_POLICY_ES 0b100\n\n#define NR_MIGRATE_TEST_VCPUS 4\n#define NR_MIGRATE_TEST_VMS 3\n#define NR_LOCK_TESTING_THREADS 3\n#define NR_LOCK_TESTING_ITERATIONS 10000\n\nbool have_sev_es;\n\nstatic int __sev_ioctl(int vm_fd, int cmd_id, void *data, __u32 *fw_error)\n{\n\tstruct kvm_sev_cmd cmd = {\n\t\t.id = cmd_id,\n\t\t.data = (uint64_t)data,\n\t\t.sev_fd = open_sev_dev_path_or_exit(),\n\t};\n\tint ret;\n\n\tret = ioctl(vm_fd, KVM_MEMORY_ENCRYPT_OP, &cmd);\n\t*fw_error = cmd.error;\n\treturn ret;\n}\n\nstatic void sev_ioctl(int vm_fd, int cmd_id, void *data)\n{\n\tint ret;\n\t__u32 fw_error;\n\n\tret = __sev_ioctl(vm_fd, cmd_id, data, &fw_error);\n\tTEST_ASSERT(ret == 0 && fw_error == SEV_RET_SUCCESS,\n\t\t    \"%d failed: return code: %d, errno: %d, fw error: %d\",\n\t\t    cmd_id, ret, errno, fw_error);\n}\n\nstatic struct kvm_vm *sev_vm_create(bool es)\n{\n\tstruct kvm_vm *vm;\n\tstruct kvm_sev_launch_start start = { 0 };\n\tint i;\n\n\tvm = vm_create_barebones();\n\tsev_ioctl(vm->fd, es ? KVM_SEV_ES_INIT : KVM_SEV_INIT, NULL);\n\tfor (i = 0; i < NR_MIGRATE_TEST_VCPUS; ++i)\n\t\t__vm_vcpu_add(vm, i);\n\tif (es)\n\t\tstart.policy |= SEV_POLICY_ES;\n\tsev_ioctl(vm->fd, KVM_SEV_LAUNCH_START, &start);\n\tif (es)\n\t\tsev_ioctl(vm->fd, KVM_SEV_LAUNCH_UPDATE_VMSA, NULL);\n\treturn vm;\n}\n\nstatic struct kvm_vm *aux_vm_create(bool with_vcpus)\n{\n\tstruct kvm_vm *vm;\n\tint i;\n\n\tvm = vm_create_barebones();\n\tif (!with_vcpus)\n\t\treturn vm;\n\n\tfor (i = 0; i < NR_MIGRATE_TEST_VCPUS; ++i)\n\t\t__vm_vcpu_add(vm, i);\n\n\treturn vm;\n}\n\nstatic int __sev_migrate_from(struct kvm_vm *dst, struct kvm_vm *src)\n{\n\treturn __vm_enable_cap(dst, KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM, src->fd);\n}\n\n\nstatic void sev_migrate_from(struct kvm_vm *dst, struct kvm_vm *src)\n{\n\tint ret;\n\n\tret = __sev_migrate_from(dst, src);\n\tTEST_ASSERT(!ret, \"Migration failed, ret: %d, errno: %d\\n\", ret, errno);\n}\n\nstatic void test_sev_migrate_from(bool es)\n{\n\tstruct kvm_vm *src_vm;\n\tstruct kvm_vm *dst_vms[NR_MIGRATE_TEST_VMS];\n\tint i, ret;\n\n\tsrc_vm = sev_vm_create(es);\n\tfor (i = 0; i < NR_MIGRATE_TEST_VMS; ++i)\n\t\tdst_vms[i] = aux_vm_create(true);\n\n\t \n\tsev_migrate_from(dst_vms[0], src_vm);\n\n\tfor (i = 1; i < NR_MIGRATE_TEST_VMS; i++)\n\t\tsev_migrate_from(dst_vms[i], dst_vms[i - 1]);\n\n\t \n\tret = __sev_migrate_from(src_vm, dst_vms[NR_MIGRATE_TEST_VMS - 1]);\n\tTEST_ASSERT(ret == -1 && errno == EIO,\n\t\t    \"VM that was migrated from should be dead. ret %d, errno: %d\\n\", ret,\n\t\t    errno);\n\n\tkvm_vm_free(src_vm);\n\tfor (i = 0; i < NR_MIGRATE_TEST_VMS; ++i)\n\t\tkvm_vm_free(dst_vms[i]);\n}\n\nstruct locking_thread_input {\n\tstruct kvm_vm *vm;\n\tstruct kvm_vm *source_vms[NR_LOCK_TESTING_THREADS];\n};\n\nstatic void *locking_test_thread(void *arg)\n{\n\tint i, j;\n\tstruct locking_thread_input *input = (struct locking_thread_input *)arg;\n\n\tfor (i = 0; i < NR_LOCK_TESTING_ITERATIONS; ++i) {\n\t\tj = i % NR_LOCK_TESTING_THREADS;\n\t\t__sev_migrate_from(input->vm, input->source_vms[j]);\n\t}\n\n\treturn NULL;\n}\n\nstatic void test_sev_migrate_locking(void)\n{\n\tstruct locking_thread_input input[NR_LOCK_TESTING_THREADS];\n\tpthread_t pt[NR_LOCK_TESTING_THREADS];\n\tint i;\n\n\tfor (i = 0; i < NR_LOCK_TESTING_THREADS; ++i) {\n\t\tinput[i].vm = sev_vm_create(  false);\n\t\tinput[0].source_vms[i] = input[i].vm;\n\t}\n\tfor (i = 1; i < NR_LOCK_TESTING_THREADS; ++i)\n\t\tmemcpy(input[i].source_vms, input[0].source_vms,\n\t\t       sizeof(input[i].source_vms));\n\n\tfor (i = 0; i < NR_LOCK_TESTING_THREADS; ++i)\n\t\tpthread_create(&pt[i], NULL, locking_test_thread, &input[i]);\n\n\tfor (i = 0; i < NR_LOCK_TESTING_THREADS; ++i)\n\t\tpthread_join(pt[i], NULL);\n\tfor (i = 0; i < NR_LOCK_TESTING_THREADS; ++i)\n\t\tkvm_vm_free(input[i].vm);\n}\n\nstatic void test_sev_migrate_parameters(void)\n{\n\tstruct kvm_vm *sev_vm, *sev_es_vm, *vm_no_vcpu, *vm_no_sev,\n\t\t*sev_es_vm_no_vmsa;\n\tint ret;\n\n\tvm_no_vcpu = vm_create_barebones();\n\tvm_no_sev = aux_vm_create(true);\n\tret = __sev_migrate_from(vm_no_vcpu, vm_no_sev);\n\tTEST_ASSERT(ret == -1 && errno == EINVAL,\n\t\t    \"Migrations require SEV enabled. ret %d, errno: %d\\n\", ret,\n\t\t    errno);\n\n\tif (!have_sev_es)\n\t\tgoto out;\n\n\tsev_vm = sev_vm_create(  false);\n\tsev_es_vm = sev_vm_create(  true);\n\tsev_es_vm_no_vmsa = vm_create_barebones();\n\tsev_ioctl(sev_es_vm_no_vmsa->fd, KVM_SEV_ES_INIT, NULL);\n\t__vm_vcpu_add(sev_es_vm_no_vmsa, 1);\n\n\tret = __sev_migrate_from(sev_vm, sev_es_vm);\n\tTEST_ASSERT(\n\t\tret == -1 && errno == EINVAL,\n\t\t\"Should not be able migrate to SEV enabled VM. ret: %d, errno: %d\\n\",\n\t\tret, errno);\n\n\tret = __sev_migrate_from(sev_es_vm, sev_vm);\n\tTEST_ASSERT(\n\t\tret == -1 && errno == EINVAL,\n\t\t\"Should not be able migrate to SEV-ES enabled VM. ret: %d, errno: %d\\n\",\n\t\tret, errno);\n\n\tret = __sev_migrate_from(vm_no_vcpu, sev_es_vm);\n\tTEST_ASSERT(\n\t\tret == -1 && errno == EINVAL,\n\t\t\"SEV-ES migrations require same number of vCPUS. ret: %d, errno: %d\\n\",\n\t\tret, errno);\n\n\tret = __sev_migrate_from(vm_no_vcpu, sev_es_vm_no_vmsa);\n\tTEST_ASSERT(\n\t\tret == -1 && errno == EINVAL,\n\t\t\"SEV-ES migrations require UPDATE_VMSA. ret %d, errno: %d\\n\",\n\t\tret, errno);\n\n\tkvm_vm_free(sev_vm);\n\tkvm_vm_free(sev_es_vm);\n\tkvm_vm_free(sev_es_vm_no_vmsa);\nout:\n\tkvm_vm_free(vm_no_vcpu);\n\tkvm_vm_free(vm_no_sev);\n}\n\nstatic int __sev_mirror_create(struct kvm_vm *dst, struct kvm_vm *src)\n{\n\treturn __vm_enable_cap(dst, KVM_CAP_VM_COPY_ENC_CONTEXT_FROM, src->fd);\n}\n\n\nstatic void sev_mirror_create(struct kvm_vm *dst, struct kvm_vm *src)\n{\n\tint ret;\n\n\tret = __sev_mirror_create(dst, src);\n\tTEST_ASSERT(!ret, \"Copying context failed, ret: %d, errno: %d\\n\", ret, errno);\n}\n\nstatic void verify_mirror_allowed_cmds(int vm_fd)\n{\n\tstruct kvm_sev_guest_status status;\n\n\tfor (int cmd_id = KVM_SEV_INIT; cmd_id < KVM_SEV_NR_MAX; ++cmd_id) {\n\t\tint ret;\n\t\t__u32 fw_error;\n\n\t\t \n\t\tswitch (cmd_id) {\n\t\tcase KVM_SEV_LAUNCH_UPDATE_VMSA:\n\t\tcase KVM_SEV_GUEST_STATUS:\n\t\tcase KVM_SEV_DBG_DECRYPT:\n\t\tcase KVM_SEV_DBG_ENCRYPT:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = __sev_ioctl(vm_fd, cmd_id, NULL, &fw_error);\n\t\tTEST_ASSERT(\n\t\t\tret == -1 && errno == EINVAL,\n\t\t\t\"Should not be able call command: %d. ret: %d, errno: %d\\n\",\n\t\t\tcmd_id, ret, errno);\n\t}\n\n\tsev_ioctl(vm_fd, KVM_SEV_GUEST_STATUS, &status);\n}\n\nstatic void test_sev_mirror(bool es)\n{\n\tstruct kvm_vm *src_vm, *dst_vm;\n\tint i;\n\n\tsrc_vm = sev_vm_create(es);\n\tdst_vm = aux_vm_create(false);\n\n\tsev_mirror_create(dst_vm, src_vm);\n\n\t \n\tfor (i = 0; i < NR_MIGRATE_TEST_VCPUS; ++i)\n\t\t__vm_vcpu_add(dst_vm, i);\n\n\tif (es)\n\t\tsev_ioctl(dst_vm->fd, KVM_SEV_LAUNCH_UPDATE_VMSA, NULL);\n\n\tverify_mirror_allowed_cmds(dst_vm->fd);\n\n\tkvm_vm_free(src_vm);\n\tkvm_vm_free(dst_vm);\n}\n\nstatic void test_sev_mirror_parameters(void)\n{\n\tstruct kvm_vm *sev_vm, *sev_es_vm, *vm_no_vcpu, *vm_with_vcpu;\n\tint ret;\n\n\tsev_vm = sev_vm_create(  false);\n\tvm_with_vcpu = aux_vm_create(true);\n\tvm_no_vcpu = aux_vm_create(false);\n\n\tret = __sev_mirror_create(sev_vm, sev_vm);\n\tTEST_ASSERT(\n\t\tret == -1 && errno == EINVAL,\n\t\t\"Should not be able copy context to self. ret: %d, errno: %d\\n\",\n\t\tret, errno);\n\n\tret = __sev_mirror_create(vm_no_vcpu, vm_with_vcpu);\n\tTEST_ASSERT(ret == -1 && errno == EINVAL,\n\t\t    \"Copy context requires SEV enabled. ret %d, errno: %d\\n\", ret,\n\t\t    errno);\n\n\tret = __sev_mirror_create(vm_with_vcpu, sev_vm);\n\tTEST_ASSERT(\n\t\tret == -1 && errno == EINVAL,\n\t\t\"SEV copy context requires no vCPUS on the destination. ret: %d, errno: %d\\n\",\n\t\tret, errno);\n\n\tif (!have_sev_es)\n\t\tgoto out;\n\n\tsev_es_vm = sev_vm_create(  true);\n\tret = __sev_mirror_create(sev_vm, sev_es_vm);\n\tTEST_ASSERT(\n\t\tret == -1 && errno == EINVAL,\n\t\t\"Should not be able copy context to SEV enabled VM. ret: %d, errno: %d\\n\",\n\t\tret, errno);\n\n\tret = __sev_mirror_create(sev_es_vm, sev_vm);\n\tTEST_ASSERT(\n\t\tret == -1 && errno == EINVAL,\n\t\t\"Should not be able copy context to SEV-ES enabled VM. ret: %d, errno: %d\\n\",\n\t\tret, errno);\n\n\tkvm_vm_free(sev_es_vm);\n\nout:\n\tkvm_vm_free(sev_vm);\n\tkvm_vm_free(vm_with_vcpu);\n\tkvm_vm_free(vm_no_vcpu);\n}\n\nstatic void test_sev_move_copy(void)\n{\n\tstruct kvm_vm *dst_vm, *dst2_vm, *dst3_vm, *sev_vm, *mirror_vm,\n\t\t      *dst_mirror_vm, *dst2_mirror_vm, *dst3_mirror_vm;\n\n\tsev_vm = sev_vm_create(  false);\n\tdst_vm = aux_vm_create(true);\n\tdst2_vm = aux_vm_create(true);\n\tdst3_vm = aux_vm_create(true);\n\tmirror_vm = aux_vm_create(false);\n\tdst_mirror_vm = aux_vm_create(false);\n\tdst2_mirror_vm = aux_vm_create(false);\n\tdst3_mirror_vm = aux_vm_create(false);\n\n\tsev_mirror_create(mirror_vm, sev_vm);\n\n\tsev_migrate_from(dst_mirror_vm, mirror_vm);\n\tsev_migrate_from(dst_vm, sev_vm);\n\n\tsev_migrate_from(dst2_vm, dst_vm);\n\tsev_migrate_from(dst2_mirror_vm, dst_mirror_vm);\n\n\tsev_migrate_from(dst3_mirror_vm, dst2_mirror_vm);\n\tsev_migrate_from(dst3_vm, dst2_vm);\n\n\tkvm_vm_free(dst_vm);\n\tkvm_vm_free(sev_vm);\n\tkvm_vm_free(dst2_vm);\n\tkvm_vm_free(dst3_vm);\n\tkvm_vm_free(mirror_vm);\n\tkvm_vm_free(dst_mirror_vm);\n\tkvm_vm_free(dst2_mirror_vm);\n\tkvm_vm_free(dst3_mirror_vm);\n\n\t \n\tsev_vm = sev_vm_create(  false);\n\tdst_vm = aux_vm_create(true);\n\tmirror_vm = aux_vm_create(false);\n\tdst_mirror_vm = aux_vm_create(false);\n\n\tsev_mirror_create(mirror_vm, sev_vm);\n\n\tsev_migrate_from(dst_mirror_vm, mirror_vm);\n\tsev_migrate_from(dst_vm, sev_vm);\n\n\tkvm_vm_free(mirror_vm);\n\tkvm_vm_free(dst_mirror_vm);\n\tkvm_vm_free(dst_vm);\n\tkvm_vm_free(sev_vm);\n}\n\nint main(int argc, char *argv[])\n{\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM));\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_VM_COPY_ENC_CONTEXT_FROM));\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_SEV));\n\n\thave_sev_es = kvm_cpu_has(X86_FEATURE_SEV_ES);\n\n\tif (kvm_has_cap(KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM)) {\n\t\ttest_sev_migrate_from(  false);\n\t\tif (have_sev_es)\n\t\t\ttest_sev_migrate_from(  true);\n\t\ttest_sev_migrate_locking();\n\t\ttest_sev_migrate_parameters();\n\t\tif (kvm_has_cap(KVM_CAP_VM_COPY_ENC_CONTEXT_FROM))\n\t\t\ttest_sev_move_copy();\n\t}\n\tif (kvm_has_cap(KVM_CAP_VM_COPY_ENC_CONTEXT_FROM)) {\n\t\ttest_sev_mirror(  false);\n\t\tif (have_sev_es)\n\t\t\ttest_sev_mirror(  true);\n\t\ttest_sev_mirror_parameters();\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}