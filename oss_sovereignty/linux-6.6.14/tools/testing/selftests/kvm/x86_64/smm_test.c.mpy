{
  "module_name": "smm_test.c",
  "hash_id": "2b92e78b667dde3278140c7bbd871ef795dcf652dd54c10116a46f54d712052e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/smm_test.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n\n#include \"kvm_util.h\"\n\n#include \"vmx.h\"\n#include \"svm_util.h\"\n\n#define SMRAM_SIZE 65536\n#define SMRAM_MEMSLOT ((1 << 16) | 1)\n#define SMRAM_PAGES (SMRAM_SIZE / PAGE_SIZE)\n#define SMRAM_GPA 0x1000000\n#define SMRAM_STAGE 0xfe\n\n#define STR(x) #x\n#define XSTR(s) STR(s)\n\n#define SYNC_PORT 0xe\n#define DONE 0xff\n\n \nuint8_t smi_handler[] = {\n\t0xb0, SMRAM_STAGE,     \n\t0xe4, SYNC_PORT,       \n\t0x0f, 0xaa,            \n};\n\nstatic inline void sync_with_host(uint64_t phase)\n{\n\tasm volatile(\"in $\" XSTR(SYNC_PORT)\", %%al \\n\"\n\t\t     : \"+a\" (phase));\n}\n\nstatic void self_smi(void)\n{\n\tx2apic_write_reg(APIC_ICR,\n\t\t\t APIC_DEST_SELF | APIC_INT_ASSERT | APIC_DM_SMI);\n}\n\nstatic void l2_guest_code(void)\n{\n\tsync_with_host(8);\n\n\tsync_with_host(10);\n\n\tvmcall();\n}\n\nstatic void guest_code(void *arg)\n{\n\t#define L2_GUEST_STACK_SIZE 64\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\tuint64_t apicbase = rdmsr(MSR_IA32_APICBASE);\n\tstruct svm_test_data *svm = arg;\n\tstruct vmx_pages *vmx_pages = arg;\n\n\tsync_with_host(1);\n\n\twrmsr(MSR_IA32_APICBASE, apicbase | X2APIC_ENABLE);\n\n\tsync_with_host(2);\n\n\tself_smi();\n\n\tsync_with_host(4);\n\n\tif (arg) {\n\t\tif (this_cpu_has(X86_FEATURE_SVM)) {\n\t\t\tgeneric_svm_setup(svm, l2_guest_code,\n\t\t\t\t\t  &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\t\t} else {\n\t\t\tGUEST_ASSERT(prepare_for_vmx_operation(vmx_pages));\n\t\t\tGUEST_ASSERT(load_vmcs(vmx_pages));\n\t\t\tprepare_vmcs(vmx_pages, l2_guest_code,\n\t\t\t\t     &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\t\t}\n\n\t\tsync_with_host(5);\n\n\t\tself_smi();\n\n\t\tsync_with_host(7);\n\n\t\tif (this_cpu_has(X86_FEATURE_SVM)) {\n\t\t\trun_guest(svm->vmcb, svm->vmcb_gpa);\n\t\t\trun_guest(svm->vmcb, svm->vmcb_gpa);\n\t\t} else {\n\t\t\tvmlaunch();\n\t\t\tvmresume();\n\t\t}\n\n\t\t \n\t\tsync_with_host(12);\n\t}\n\n\tsync_with_host(DONE);\n}\n\nvoid inject_smi(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_events events;\n\n\tvcpu_events_get(vcpu, &events);\n\n\tevents.smi.pending = 1;\n\tevents.flags |= KVM_VCPUEVENT_VALID_SMM;\n\n\tvcpu_events_set(vcpu, &events);\n}\n\nint main(int argc, char *argv[])\n{\n\tvm_vaddr_t nested_gva = 0;\n\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_regs regs;\n\tstruct kvm_vm *vm;\n\tstruct kvm_x86_state *state;\n\tint stage, stage_reported;\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_X86_SMM));\n\n\t \n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS, SMRAM_GPA,\n\t\t\t\t    SMRAM_MEMSLOT, SMRAM_PAGES, 0);\n\tTEST_ASSERT(vm_phy_pages_alloc(vm, SMRAM_PAGES, SMRAM_GPA, SMRAM_MEMSLOT)\n\t\t    == SMRAM_GPA, \"could not allocate guest physical addresses?\");\n\n\tmemset(addr_gpa2hva(vm, SMRAM_GPA), 0x0, SMRAM_SIZE);\n\tmemcpy(addr_gpa2hva(vm, SMRAM_GPA) + 0x8000, smi_handler,\n\t       sizeof(smi_handler));\n\n\tvcpu_set_msr(vcpu, MSR_IA32_SMBASE, SMRAM_GPA);\n\n\tif (kvm_has_cap(KVM_CAP_NESTED_STATE)) {\n\t\tif (kvm_cpu_has(X86_FEATURE_SVM))\n\t\t\tvcpu_alloc_svm(vm, &nested_gva);\n\t\telse if (kvm_cpu_has(X86_FEATURE_VMX))\n\t\t\tvcpu_alloc_vmx(vm, &nested_gva);\n\t}\n\n\tif (!nested_gva)\n\t\tpr_info(\"will skip SMM test with VMX enabled\\n\");\n\n\tvcpu_args_set(vcpu, 1, nested_gva);\n\n\tfor (stage = 1;; stage++) {\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tmemset(&regs, 0, sizeof(regs));\n\t\tvcpu_regs_get(vcpu, &regs);\n\n\t\tstage_reported = regs.rax & 0xff;\n\n\t\tif (stage_reported == DONE)\n\t\t\tgoto done;\n\n\t\tTEST_ASSERT(stage_reported == stage ||\n\t\t\t    stage_reported == SMRAM_STAGE,\n\t\t\t    \"Unexpected stage: #%x, got %x\",\n\t\t\t    stage, stage_reported);\n\n\t\t \n\t\tif (stage == 8) {\n\t\t\tinject_smi(vcpu);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (stage == 10)\n\t\t\tinject_smi(vcpu);\n\n\t\tstate = vcpu_save_state(vcpu);\n\t\tkvm_vm_release(vm);\n\n\t\tvcpu = vm_recreate_with_one_vcpu(vm);\n\t\tvcpu_load_state(vcpu, state);\n\t\tkvm_x86_state_cleanup(state);\n\t}\n\ndone:\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}