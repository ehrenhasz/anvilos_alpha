{
  "module_name": "vmx_exception_with_invalid_guest_state.c",
  "hash_id": "2cdc45758e9295f8a23ee64c377fe6e8fe8ba9cf5c1bee7a9f698b69fb389050",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_exception_with_invalid_guest_state.c",
  "human_readable_source": "\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n#include <signal.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n\n#include \"kselftest.h\"\n\nstatic void guest_ud_handler(struct ex_regs *regs)\n{\n\t \n}\n\nstatic void guest_code(void)\n{\n\tasm volatile(\"ud2\");\n}\n\nstatic void __run_vcpu_with_invalid_state(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\n\tvcpu_run(vcpu);\n\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_INTERNAL_ERROR);\n\tTEST_ASSERT(run->emulation_failure.suberror == KVM_INTERNAL_ERROR_EMULATION,\n\t\t    \"Expected emulation failure, got %d\\n\",\n\t\t    run->emulation_failure.suberror);\n}\n\nstatic void run_vcpu_with_invalid_state(struct kvm_vcpu *vcpu)\n{\n\t \n\t__run_vcpu_with_invalid_state(vcpu);\n\t__run_vcpu_with_invalid_state(vcpu);\n}\n\nstatic void set_timer(void)\n{\n\tstruct itimerval timer;\n\n\ttimer.it_value.tv_sec  = 0;\n\ttimer.it_value.tv_usec = 200;\n\ttimer.it_interval = timer.it_value;\n\tTEST_ASSERT_EQ(setitimer(ITIMER_REAL, &timer, NULL), 0);\n}\n\nstatic void set_or_clear_invalid_guest_state(struct kvm_vcpu *vcpu, bool set)\n{\n\tstatic struct kvm_sregs sregs;\n\n\tif (!sregs.cr0)\n\t\tvcpu_sregs_get(vcpu, &sregs);\n\tsregs.tr.unusable = !!set;\n\tvcpu_sregs_set(vcpu, &sregs);\n}\n\nstatic void set_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tset_or_clear_invalid_guest_state(vcpu, true);\n}\n\nstatic void clear_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tset_or_clear_invalid_guest_state(vcpu, false);\n}\n\nstatic struct kvm_vcpu *get_set_sigalrm_vcpu(struct kvm_vcpu *__vcpu)\n{\n\tstatic struct kvm_vcpu *vcpu = NULL;\n\n\tif (__vcpu)\n\t\tvcpu = __vcpu;\n\treturn vcpu;\n}\n\nstatic void sigalrm_handler(int sig)\n{\n\tstruct kvm_vcpu *vcpu = get_set_sigalrm_vcpu(NULL);\n\tstruct kvm_vcpu_events events;\n\n\tTEST_ASSERT(sig == SIGALRM, \"Unexpected signal = %d\", sig);\n\n\tvcpu_events_get(vcpu, &events);\n\n\t \n\tif (events.exception.pending) {\n\t\tset_invalid_guest_state(vcpu);\n\t\trun_vcpu_with_invalid_state(vcpu);\n\t} else {\n\t\tset_timer();\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tTEST_REQUIRE(host_cpu_is_intel);\n\tTEST_REQUIRE(!vm_is_unrestricted_guest(NULL));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\tget_set_sigalrm_vcpu(vcpu);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\tvm_install_exception_handler(vm, UD_VECTOR, guest_ud_handler);\n\n\t \n\tset_invalid_guest_state(vcpu);\n\trun_vcpu_with_invalid_state(vcpu);\n\n\t \n\tclear_invalid_guest_state(vcpu);\n\tTEST_ASSERT(signal(SIGALRM, sigalrm_handler) != SIG_ERR,\n\t\t    \"Failed to register SIGALRM handler, errno = %d (%s)\",\n\t\t    errno, strerror(errno));\n\n\tset_timer();\n\trun_vcpu_with_invalid_state(vcpu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}