{
  "module_name": "hyperv_svm_test.c",
  "hash_id": "109c6ee5a620cdc4fb8c3afb7bd0c6269814dc448299f057c4dfc6b858d726ea",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/hyperv_svm_test.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <linux/bitmap.h>\n\n#include \"test_util.h\"\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"svm_util.h\"\n#include \"hyperv.h\"\n\n#define L2_GUEST_STACK_SIZE 256\n\n \nstatic inline void rdmsr_from_l2(uint32_t msr)\n{\n\t \n\t__asm__ __volatile__ (\"rdmsr\" : : \"c\"(msr) :\n\t\t\t      \"rax\", \"rbx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \"r9\",\n\t\t\t      \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\");\n}\n\nvoid l2_guest_code(void)\n{\n\tu64 unused;\n\n\tGUEST_SYNC(3);\n\t \n\tvmmcall();\n\n\t \n\trdmsr_from_l2(MSR_FS_BASE);  \n\trdmsr_from_l2(MSR_FS_BASE);  \n\trdmsr_from_l2(MSR_GS_BASE);  \n\tvmmcall();\n\trdmsr_from_l2(MSR_GS_BASE);  \n\n\tGUEST_SYNC(5);\n\n\t \n\thyperv_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE |\n\t\t\t HV_HYPERCALL_FAST_BIT, 0x0,\n\t\t\t HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES |\n\t\t\t HV_FLUSH_ALL_PROCESSORS);\n\trdmsr_from_l2(MSR_FS_BASE);\n\t \n\t__hyperv_hypercall(HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE |\n\t\t\t   HV_HYPERCALL_FAST_BIT, 0x0,\n\t\t\t   HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES |\n\t\t\t   HV_FLUSH_ALL_PROCESSORS, &unused);\n\n\t \n\tvmmcall();\n}\n\nstatic void __attribute__((__flatten__)) guest_code(struct svm_test_data *svm,\n\t\t\t\t\t\t    struct hyperv_test_pages *hv_pages,\n\t\t\t\t\t\t    vm_vaddr_t pgs_gpa)\n{\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct hv_vmcb_enlightenments *hve = &vmcb->control.hv_enlightenments;\n\n\tGUEST_SYNC(1);\n\n\twrmsr(HV_X64_MSR_GUEST_OS_ID, HYPERV_LINUX_OS_ID);\n\twrmsr(HV_X64_MSR_HYPERCALL, pgs_gpa);\n\tenable_vp_assist(hv_pages->vp_assist_gpa, hv_pages->vp_assist);\n\n\tGUEST_ASSERT(svm->vmcb_gpa);\n\t \n\tgeneric_svm_setup(svm, l2_guest_code,\n\t\t\t  &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\n\t \n\thve->partition_assist_page = hv_pages->partition_assist_gpa;\n\thve->hv_enlightenments_control.nested_flush_hypercall = 1;\n\thve->hv_vm_id = 1;\n\thve->hv_vp_id = 1;\n\tcurrent_vp_assist->nested_control.features.directhypercall = 1;\n\t*(u32 *)(hv_pages->partition_assist) = 0;\n\n\tGUEST_SYNC(2);\n\trun_guest(vmcb, svm->vmcb_gpa);\n\tGUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_VMMCALL);\n\tGUEST_SYNC(4);\n\tvmcb->save.rip += 3;\n\n\t \n\tvmcb->control.intercept |= 1ULL << INTERCEPT_MSR_PROT;\n\t__set_bit(2 * (MSR_FS_BASE & 0x1fff), svm->msr + 0x800);\n\trun_guest(vmcb, svm->vmcb_gpa);\n\tGUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_MSR);\n\tvmcb->save.rip += 2;  \n\n\t \n\thve->hv_enlightenments_control.msr_bitmap = 1;\n\trun_guest(vmcb, svm->vmcb_gpa);\n\tGUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_MSR);\n\tvmcb->save.rip += 2;  \n\n\t \n\t__set_bit(2 * (MSR_GS_BASE & 0x1fff), svm->msr + 0x800);\n\t \n\tvmcb->control.clean |= HV_VMCB_NESTED_ENLIGHTENMENTS;\n\trun_guest(vmcb, svm->vmcb_gpa);\n\t \n\tGUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_VMMCALL);\n\tvmcb->save.rip += 3;  \n\n\t \n\tvmcb->control.clean &= ~HV_VMCB_NESTED_ENLIGHTENMENTS;\n\trun_guest(vmcb, svm->vmcb_gpa);\n\tGUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_MSR);\n\tvmcb->save.rip += 2;  \n\n\n\t \n\trun_guest(vmcb, svm->vmcb_gpa);\n\tGUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_MSR);\n\tvmcb->save.rip += 2;  \n\t \n\t*(u32 *)(hv_pages->partition_assist) = 1;\n\trun_guest(vmcb, svm->vmcb_gpa);\n\tGUEST_ASSERT(vmcb->control.exit_code == HV_SVM_EXITCODE_ENL);\n\tGUEST_ASSERT(vmcb->control.exit_info_1 == HV_SVM_ENL_EXITCODE_TRAP_AFTER_FLUSH);\n\n\trun_guest(vmcb, svm->vmcb_gpa);\n\tGUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_VMMCALL);\n\tGUEST_SYNC(6);\n\n\tGUEST_DONE();\n}\n\nint main(int argc, char *argv[])\n{\n\tvm_vaddr_t nested_gva = 0, hv_pages_gva = 0;\n\tvm_vaddr_t hcall_page;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\tint stage;\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_SVM));\n\n\t \n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\tvcpu_set_hv_cpuid(vcpu);\n\tvcpu_alloc_svm(vm, &nested_gva);\n\tvcpu_alloc_hyperv_test_pages(vm, &hv_pages_gva);\n\n\thcall_page = vm_vaddr_alloc_pages(vm, 1);\n\tmemset(addr_gva2hva(vm, hcall_page), 0x0,  getpagesize());\n\n\tvcpu_args_set(vcpu, 3, nested_gva, hv_pages_gva, addr_gva2gpa(vm, hcall_page));\n\tvcpu_set_msr(vcpu, HV_X64_MSR_VP_INDEX, vcpu->id);\n\n\tfor (stage = 1;; stage++) {\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t \n\t\tcase UCALL_SYNC:\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\n\t\t \n\t\tTEST_ASSERT(!strcmp((const char *)uc.args[0], \"hello\") &&\n\t\t\t    uc.args[1] == stage, \"Stage %d: Unexpected register values vmexit, got %lx\",\n\t\t\t    stage, (ulong)uc.args[1]);\n\n\t}\n\ndone:\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}