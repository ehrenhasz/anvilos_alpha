{
  "module_name": "xen_shinfo_test.c",
  "hash_id": "59da2145f444463e5169905e78cc3a3553b738646c905eb3b9a472f3a311d2d4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/xen_shinfo_test.c",
  "human_readable_source": "\n \n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n#include <stdint.h>\n#include <time.h>\n#include <sched.h>\n#include <signal.h>\n#include <pthread.h>\n\n#include <sys/eventfd.h>\n\n#define SHINFO_REGION_GVA\t0xc0000000ULL\n#define SHINFO_REGION_GPA\t0xc0000000ULL\n#define SHINFO_REGION_SLOT\t10\n\n#define DUMMY_REGION_GPA\t(SHINFO_REGION_GPA + (3 * PAGE_SIZE))\n#define DUMMY_REGION_SLOT\t11\n\n#define DUMMY_REGION_GPA_2\t(SHINFO_REGION_GPA + (4 * PAGE_SIZE))\n#define DUMMY_REGION_SLOT_2\t12\n\n#define SHINFO_ADDR\t(SHINFO_REGION_GPA)\n#define VCPU_INFO_ADDR\t(SHINFO_REGION_GPA + 0x40)\n#define PVTIME_ADDR\t(SHINFO_REGION_GPA + PAGE_SIZE)\n#define RUNSTATE_ADDR\t(SHINFO_REGION_GPA + PAGE_SIZE + PAGE_SIZE - 15)\n\n#define SHINFO_VADDR\t(SHINFO_REGION_GVA)\n#define VCPU_INFO_VADDR\t(SHINFO_REGION_GVA + 0x40)\n#define RUNSTATE_VADDR\t(SHINFO_REGION_GVA + PAGE_SIZE + PAGE_SIZE - 15)\n\n#define EVTCHN_VECTOR\t0x10\n\n#define EVTCHN_TEST1 15\n#define EVTCHN_TEST2 66\n#define EVTCHN_TIMER 13\n\nenum {\n\tTEST_INJECT_VECTOR = 0,\n\tTEST_RUNSTATE_runnable,\n\tTEST_RUNSTATE_blocked,\n\tTEST_RUNSTATE_offline,\n\tTEST_RUNSTATE_ADJUST,\n\tTEST_RUNSTATE_DATA,\n\tTEST_STEAL_TIME,\n\tTEST_EVTCHN_MASKED,\n\tTEST_EVTCHN_UNMASKED,\n\tTEST_EVTCHN_SLOWPATH,\n\tTEST_EVTCHN_SEND_IOCTL,\n\tTEST_EVTCHN_HCALL,\n\tTEST_EVTCHN_HCALL_SLOWPATH,\n\tTEST_EVTCHN_HCALL_EVENTFD,\n\tTEST_TIMER_SETUP,\n\tTEST_TIMER_WAIT,\n\tTEST_TIMER_RESTORE,\n\tTEST_POLL_READY,\n\tTEST_POLL_TIMEOUT,\n\tTEST_POLL_MASKED,\n\tTEST_POLL_WAKE,\n\tTEST_TIMER_PAST,\n\tTEST_LOCKING_SEND_RACE,\n\tTEST_LOCKING_POLL_RACE,\n\tTEST_LOCKING_POLL_TIMEOUT,\n\tTEST_DONE,\n\n\tTEST_GUEST_SAW_IRQ,\n};\n\n#define XEN_HYPERCALL_MSR\t0x40000000\n\n#define MIN_STEAL_TIME\t\t50000\n\n#define SHINFO_RACE_TIMEOUT\t2\t \n\n#define __HYPERVISOR_set_timer_op\t15\n#define __HYPERVISOR_sched_op\t\t29\n#define __HYPERVISOR_event_channel_op\t32\n\n#define SCHEDOP_poll\t\t\t3\n\n#define EVTCHNOP_send\t\t\t4\n\n#define EVTCHNSTAT_interdomain\t\t2\n\nstruct evtchn_send {\n\tu32 port;\n};\n\nstruct sched_poll {\n\tu32 *ports;\n\tunsigned int nr_ports;\n\tu64 timeout;\n};\n\nstruct pvclock_vcpu_time_info {\n\tu32   version;\n\tu32   pad0;\n\tu64   tsc_timestamp;\n\tu64   system_time;\n\tu32   tsc_to_system_mul;\n\ts8    tsc_shift;\n\tu8    flags;\n\tu8    pad[2];\n} __attribute__((__packed__));  \n\nstruct pvclock_wall_clock {\n\tu32   version;\n\tu32   sec;\n\tu32   nsec;\n} __attribute__((__packed__));\n\nstruct vcpu_runstate_info {\n\tuint32_t state;\n\tuint64_t state_entry_time;\n\tuint64_t time[5];  \n};\n\nstruct compat_vcpu_runstate_info {\n\tuint32_t state;\n\tuint64_t state_entry_time;\n\tuint64_t time[5];\n} __attribute__((__packed__));;\n\nstruct arch_vcpu_info {\n\tunsigned long cr2;\n\tunsigned long pad;  \n};\n\nstruct vcpu_info {\n\tuint8_t evtchn_upcall_pending;\n\tuint8_t evtchn_upcall_mask;\n\tunsigned long evtchn_pending_sel;\n\tstruct arch_vcpu_info arch;\n\tstruct pvclock_vcpu_time_info time;\n};  \n\nstruct shared_info {\n\tstruct vcpu_info vcpu_info[32];\n\tunsigned long evtchn_pending[64];\n\tunsigned long evtchn_mask[64];\n\tstruct pvclock_wall_clock wc;\n\tuint32_t wc_sec_hi;\n\t \n};\n\n#define RUNSTATE_running  0\n#define RUNSTATE_runnable 1\n#define RUNSTATE_blocked  2\n#define RUNSTATE_offline  3\n\nstatic const char *runstate_names[] = {\n\t\"running\",\n\t\"runnable\",\n\t\"blocked\",\n\t\"offline\"\n};\n\nstruct {\n\tstruct kvm_irq_routing info;\n\tstruct kvm_irq_routing_entry entries[2];\n} irq_routes;\n\nstatic volatile bool guest_saw_irq;\n\nstatic void evtchn_handler(struct ex_regs *regs)\n{\n\tstruct vcpu_info *vi = (void *)VCPU_INFO_VADDR;\n\tvi->evtchn_upcall_pending = 0;\n\tvi->evtchn_pending_sel = 0;\n\tguest_saw_irq = true;\n\n\tGUEST_SYNC(TEST_GUEST_SAW_IRQ);\n}\n\nstatic void guest_wait_for_irq(void)\n{\n\twhile (!guest_saw_irq)\n\t\t__asm__ __volatile__ (\"rep nop\" : : : \"memory\");\n\tguest_saw_irq = false;\n}\n\nstatic void guest_code(void)\n{\n\tstruct vcpu_runstate_info *rs = (void *)RUNSTATE_VADDR;\n\tint i;\n\n\t__asm__ __volatile__(\n\t\t\"sti\\n\"\n\t\t\"nop\\n\"\n\t);\n\n\t \n\tGUEST_SYNC(TEST_INJECT_VECTOR);\n\n\tguest_wait_for_irq();\n\n\t \n\tGUEST_SYNC(TEST_RUNSTATE_runnable);\n\tGUEST_ASSERT(rs->time[RUNSTATE_runnable] != 0);\n\tGUEST_ASSERT(rs->state == 0);\n\n\tGUEST_SYNC(TEST_RUNSTATE_blocked);\n\tGUEST_ASSERT(rs->time[RUNSTATE_blocked] != 0);\n\tGUEST_ASSERT(rs->state == 0);\n\n\tGUEST_SYNC(TEST_RUNSTATE_offline);\n\tGUEST_ASSERT(rs->time[RUNSTATE_offline] != 0);\n\tGUEST_ASSERT(rs->state == 0);\n\n\t \n\tGUEST_SYNC(TEST_RUNSTATE_ADJUST);\n\tGUEST_ASSERT(rs->time[RUNSTATE_blocked] == 0x5a);\n\tGUEST_ASSERT(rs->time[RUNSTATE_offline] == 0x6b6b);\n\n\t \n\tGUEST_SYNC(TEST_RUNSTATE_DATA);\n\tGUEST_ASSERT(rs->state_entry_time >= 0x8000);\n\tGUEST_ASSERT(rs->time[RUNSTATE_runnable] == 0);\n\tGUEST_ASSERT(rs->time[RUNSTATE_blocked] == 0x6b6b);\n\tGUEST_ASSERT(rs->time[RUNSTATE_offline] == 0x5a);\n\n\t \n\tGUEST_SYNC(TEST_STEAL_TIME);\n\tGUEST_ASSERT(rs->time[RUNSTATE_runnable] >= MIN_STEAL_TIME);\n\n\t \n\tGUEST_SYNC(TEST_EVTCHN_MASKED);\n\n\t \n\tstruct shared_info *si = (void *)SHINFO_VADDR;\n\twhile (!si->evtchn_pending[0])\n\t\t__asm__ __volatile__ (\"rep nop\" : : : \"memory\");\n\n\t \n\tGUEST_SYNC(TEST_EVTCHN_UNMASKED);\n\n\tguest_wait_for_irq();\n\n\t \n\tGUEST_SYNC(TEST_EVTCHN_SLOWPATH);\n\n\tguest_wait_for_irq();\n\n\t \n\tGUEST_SYNC(TEST_EVTCHN_SEND_IOCTL);\n\n\tguest_wait_for_irq();\n\n\tGUEST_SYNC(TEST_EVTCHN_HCALL);\n\n\t \n\tstruct evtchn_send s = { .port = 127 };\n\txen_hypercall(__HYPERVISOR_event_channel_op, EVTCHNOP_send, &s);\n\n\tguest_wait_for_irq();\n\n\tGUEST_SYNC(TEST_EVTCHN_HCALL_SLOWPATH);\n\n\t \n\txen_hypercall(__HYPERVISOR_event_channel_op, EVTCHNOP_send, &s);\n\n\tguest_wait_for_irq();\n\n\tGUEST_SYNC(TEST_EVTCHN_HCALL_EVENTFD);\n\n\t \n\ts.port = 197;\n\txen_hypercall(__HYPERVISOR_event_channel_op, EVTCHNOP_send, &s);\n\n\tguest_wait_for_irq();\n\n\tGUEST_SYNC(TEST_TIMER_SETUP);\n\n\t \n\txen_hypercall(__HYPERVISOR_set_timer_op,\n\t\t      rs->state_entry_time + 100000000, NULL);\n\n\tGUEST_SYNC(TEST_TIMER_WAIT);\n\n\t \n\tguest_wait_for_irq();\n\n\tGUEST_SYNC(TEST_TIMER_RESTORE);\n\n\t \n\tguest_wait_for_irq();\n\n\tGUEST_SYNC(TEST_POLL_READY);\n\n\t \n\tu32 ports[1] = { EVTCHN_TIMER };\n\tstruct sched_poll p = {\n\t\t.ports = ports,\n\t\t.nr_ports = 1,\n\t\t.timeout = 0,\n\t};\n\n\txen_hypercall(__HYPERVISOR_sched_op, SCHEDOP_poll, &p);\n\n\tGUEST_SYNC(TEST_POLL_TIMEOUT);\n\n\t \n\tp.timeout = 100000000;\n\txen_hypercall(__HYPERVISOR_sched_op, SCHEDOP_poll, &p);\n\n\tGUEST_SYNC(TEST_POLL_MASKED);\n\n\t \n\tp.timeout = 0;\n\txen_hypercall(__HYPERVISOR_sched_op, SCHEDOP_poll, &p);\n\n\tGUEST_SYNC(TEST_POLL_WAKE);\n\n\t \n\tports[0]++;\n\tp.timeout = 0;\n\txen_hypercall(__HYPERVISOR_sched_op, SCHEDOP_poll, &p);\n\n\tguest_wait_for_irq();\n\n\tGUEST_SYNC(TEST_TIMER_PAST);\n\n\t \n\tguest_wait_for_irq();\n\n\tGUEST_SYNC(TEST_LOCKING_SEND_RACE);\n\t \n\n\tguest_wait_for_irq();\n\n\tGUEST_SYNC(TEST_LOCKING_POLL_RACE);\n\t \n\n\tports[0] = 0;\n\n\tp = (struct sched_poll) {\n\t\t.ports = ports,\n\t\t.nr_ports = 1,\n\t\t.timeout = 0\n\t};\n\nwait_for_timer:\n\t \n\tfor (i = 0; i < 100 && !guest_saw_irq; i++)\n\t\t__xen_hypercall(__HYPERVISOR_sched_op, SCHEDOP_poll, &p);\n\n\t \n\tif (!guest_saw_irq) {\n\t\tGUEST_SYNC(TEST_LOCKING_POLL_TIMEOUT);\n\t\tgoto wait_for_timer;\n\t}\n\tguest_saw_irq = false;\n\n\tGUEST_SYNC(TEST_DONE);\n}\n\nstatic int cmp_timespec(struct timespec *a, struct timespec *b)\n{\n\tif (a->tv_sec > b->tv_sec)\n\t\treturn 1;\n\telse if (a->tv_sec < b->tv_sec)\n\t\treturn -1;\n\telse if (a->tv_nsec > b->tv_nsec)\n\t\treturn 1;\n\telse if (a->tv_nsec < b->tv_nsec)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\nstatic struct vcpu_info *vinfo;\nstatic struct kvm_vcpu *vcpu;\n\nstatic void handle_alrm(int sig)\n{\n\tif (vinfo)\n\t\tprintf(\"evtchn_upcall_pending 0x%x\\n\", vinfo->evtchn_upcall_pending);\n\tvcpu_dump(stdout, vcpu, 0);\n\tTEST_FAIL(\"IRQ delivery timed out\");\n}\n\nstatic void *juggle_shinfo_state(void *arg)\n{\n\tstruct kvm_vm *vm = (struct kvm_vm *)arg;\n\n\tstruct kvm_xen_hvm_attr cache_activate = {\n\t\t.type = KVM_XEN_ATTR_TYPE_SHARED_INFO,\n\t\t.u.shared_info.gfn = SHINFO_REGION_GPA / PAGE_SIZE\n\t};\n\n\tstruct kvm_xen_hvm_attr cache_deactivate = {\n\t\t.type = KVM_XEN_ATTR_TYPE_SHARED_INFO,\n\t\t.u.shared_info.gfn = KVM_XEN_INVALID_GFN\n\t};\n\n\tfor (;;) {\n\t\t__vm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &cache_activate);\n\t\t__vm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &cache_deactivate);\n\t\tpthread_testcancel();\n\t}\n\n\treturn NULL;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct timespec min_ts, max_ts, vm_ts;\n\tstruct kvm_xen_hvm_attr evt_reset;\n\tstruct kvm_vm *vm;\n\tpthread_t thread;\n\tbool verbose;\n\tint ret;\n\n\tverbose = argc > 1 && (!strncmp(argv[1], \"-v\", 3) ||\n\t\t\t       !strncmp(argv[1], \"--verbose\", 10));\n\n\tint xen_caps = kvm_check_cap(KVM_CAP_XEN_HVM);\n\tTEST_REQUIRE(xen_caps & KVM_XEN_HVM_CONFIG_SHARED_INFO);\n\n\tbool do_runstate_tests = !!(xen_caps & KVM_XEN_HVM_CONFIG_RUNSTATE);\n\tbool do_runstate_flag = !!(xen_caps & KVM_XEN_HVM_CONFIG_RUNSTATE_UPDATE_FLAG);\n\tbool do_eventfd_tests = !!(xen_caps & KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL);\n\tbool do_evtchn_tests = do_eventfd_tests && !!(xen_caps & KVM_XEN_HVM_CONFIG_EVTCHN_SEND);\n\n\tclock_gettime(CLOCK_REALTIME, &min_ts);\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\t \n\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS,\n\t\t\t\t    SHINFO_REGION_GPA, SHINFO_REGION_SLOT, 3, 0);\n\tvirt_map(vm, SHINFO_REGION_GVA, SHINFO_REGION_GPA, 3);\n\n\tstruct shared_info *shinfo = addr_gpa2hva(vm, SHINFO_VADDR);\n\n\tint zero_fd = open(\"/dev/zero\", O_RDONLY);\n\tTEST_ASSERT(zero_fd != -1, \"Failed to open /dev/zero\");\n\n\tstruct kvm_xen_hvm_config hvmc = {\n\t\t.flags = KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL,\n\t\t.msr = XEN_HYPERCALL_MSR,\n\t};\n\n\t \n\tif (do_evtchn_tests)\n\t\thvmc.flags |= KVM_XEN_HVM_CONFIG_EVTCHN_SEND;\n\n\tvm_ioctl(vm, KVM_XEN_HVM_CONFIG, &hvmc);\n\n\tstruct kvm_xen_hvm_attr lm = {\n\t\t.type = KVM_XEN_ATTR_TYPE_LONG_MODE,\n\t\t.u.long_mode = 1,\n\t};\n\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &lm);\n\n\tif (do_runstate_flag) {\n\t\tstruct kvm_xen_hvm_attr ruf = {\n\t\t\t.type = KVM_XEN_ATTR_TYPE_RUNSTATE_UPDATE_FLAG,\n\t\t\t.u.runstate_update_flag = 1,\n\t\t};\n\t\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &ruf);\n\n\t\truf.u.runstate_update_flag = 0;\n\t\tvm_ioctl(vm, KVM_XEN_HVM_GET_ATTR, &ruf);\n\t\tTEST_ASSERT(ruf.u.runstate_update_flag == 1,\n\t\t\t    \"Failed to read back RUNSTATE_UPDATE_FLAG attr\");\n\t}\n\n\tstruct kvm_xen_hvm_attr ha = {\n\t\t.type = KVM_XEN_ATTR_TYPE_SHARED_INFO,\n\t\t.u.shared_info.gfn = SHINFO_REGION_GPA / PAGE_SIZE,\n\t};\n\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &ha);\n\n\t \n\tstruct pvclock_wall_clock wc_copy = shinfo->wc;\n\tvoid *m = mmap(shinfo, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, zero_fd, 0);\n\tTEST_ASSERT(m == shinfo, \"Failed to map /dev/zero over shared info\");\n\tshinfo->wc = wc_copy;\n\n\tstruct kvm_xen_vcpu_attr vi = {\n\t\t.type = KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO,\n\t\t.u.gpa = VCPU_INFO_ADDR,\n\t};\n\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &vi);\n\n\tstruct kvm_xen_vcpu_attr pvclock = {\n\t\t.type = KVM_XEN_VCPU_ATTR_TYPE_VCPU_TIME_INFO,\n\t\t.u.gpa = PVTIME_ADDR,\n\t};\n\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &pvclock);\n\n\tstruct kvm_xen_hvm_attr vec = {\n\t\t.type = KVM_XEN_ATTR_TYPE_UPCALL_VECTOR,\n\t\t.u.vector = EVTCHN_VECTOR,\n\t};\n\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &vec);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\tvm_install_exception_handler(vm, EVTCHN_VECTOR, evtchn_handler);\n\n\tif (do_runstate_tests) {\n\t\tstruct kvm_xen_vcpu_attr st = {\n\t\t\t.type = KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR,\n\t\t\t.u.gpa = RUNSTATE_ADDR,\n\t\t};\n\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &st);\n\t}\n\n\tint irq_fd[2] = { -1, -1 };\n\n\tif (do_eventfd_tests) {\n\t\tirq_fd[0] = eventfd(0, 0);\n\t\tirq_fd[1] = eventfd(0, 0);\n\n\t\t \n\t\tif (irq_fd[0] == -1 || irq_fd[1] == -1)\n\t\t\tdo_evtchn_tests = do_eventfd_tests = false;\n\t}\n\n\tif (do_eventfd_tests) {\n\t\tirq_routes.info.nr = 2;\n\n\t\tirq_routes.entries[0].gsi = 32;\n\t\tirq_routes.entries[0].type = KVM_IRQ_ROUTING_XEN_EVTCHN;\n\t\tirq_routes.entries[0].u.xen_evtchn.port = EVTCHN_TEST1;\n\t\tirq_routes.entries[0].u.xen_evtchn.vcpu = vcpu->id;\n\t\tirq_routes.entries[0].u.xen_evtchn.priority = KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL;\n\n\t\tirq_routes.entries[1].gsi = 33;\n\t\tirq_routes.entries[1].type = KVM_IRQ_ROUTING_XEN_EVTCHN;\n\t\tirq_routes.entries[1].u.xen_evtchn.port = EVTCHN_TEST2;\n\t\tirq_routes.entries[1].u.xen_evtchn.vcpu = vcpu->id;\n\t\tirq_routes.entries[1].u.xen_evtchn.priority = KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL;\n\n\t\tvm_ioctl(vm, KVM_SET_GSI_ROUTING, &irq_routes.info);\n\n\t\tstruct kvm_irqfd ifd = { };\n\n\t\tifd.fd = irq_fd[0];\n\t\tifd.gsi = 32;\n\t\tvm_ioctl(vm, KVM_IRQFD, &ifd);\n\n\t\tifd.fd = irq_fd[1];\n\t\tifd.gsi = 33;\n\t\tvm_ioctl(vm, KVM_IRQFD, &ifd);\n\n\t\tstruct sigaction sa = { };\n\t\tsa.sa_handler = handle_alrm;\n\t\tsigaction(SIGALRM, &sa, NULL);\n\t}\n\n\tstruct kvm_xen_vcpu_attr tmr = {\n\t\t.type = KVM_XEN_VCPU_ATTR_TYPE_TIMER,\n\t\t.u.timer.port = EVTCHN_TIMER,\n\t\t.u.timer.priority = KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL,\n\t\t.u.timer.expires_ns = 0\n\t};\n\n\tif (do_evtchn_tests) {\n\t\tstruct kvm_xen_hvm_attr inj = {\n\t\t\t.type = KVM_XEN_ATTR_TYPE_EVTCHN,\n\t\t\t.u.evtchn.send_port = 127,\n\t\t\t.u.evtchn.type = EVTCHNSTAT_interdomain,\n\t\t\t.u.evtchn.flags = 0,\n\t\t\t.u.evtchn.deliver.port.port = EVTCHN_TEST1,\n\t\t\t.u.evtchn.deliver.port.vcpu = vcpu->id + 1,\n\t\t\t.u.evtchn.deliver.port.priority = KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL,\n\t\t};\n\t\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &inj);\n\n\t\t \n\t\tinj.u.evtchn.flags = KVM_XEN_EVTCHN_UPDATE;\n\t\tinj.u.evtchn.deliver.port.vcpu = vcpu->id;\n\t\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &inj);\n\n\t\tinj.u.evtchn.send_port = 197;\n\t\tinj.u.evtchn.deliver.eventfd.port = 0;\n\t\tinj.u.evtchn.deliver.eventfd.fd = irq_fd[1];\n\t\tinj.u.evtchn.flags = 0;\n\t\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &inj);\n\n\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &tmr);\n\t}\n\tvinfo = addr_gpa2hva(vm, VCPU_INFO_VADDR);\n\tvinfo->evtchn_upcall_pending = 0;\n\n\tstruct vcpu_runstate_info *rs = addr_gpa2hva(vm, RUNSTATE_ADDR);\n\trs->state = 0x5a;\n\n\tbool evtchn_irq_expected = false;\n\n\tfor (;;) {\n\t\tstruct ucall uc;\n\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t \n\t\tcase UCALL_SYNC: {\n\t\t\tstruct kvm_xen_vcpu_attr rst;\n\t\t\tlong rundelay;\n\n\t\t\tif (do_runstate_tests)\n\t\t\t\tTEST_ASSERT(rs->state_entry_time == rs->time[0] +\n\t\t\t\t\t    rs->time[1] + rs->time[2] + rs->time[3],\n\t\t\t\t\t    \"runstate times don't add up\");\n\n\t\t\tswitch (uc.args[1]) {\n\t\t\tcase TEST_INJECT_VECTOR:\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Delivering evtchn upcall\\n\");\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\tvinfo->evtchn_upcall_pending = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_RUNSTATE_runnable...TEST_RUNSTATE_offline:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected, \"Event channel IRQ not seen\");\n\t\t\t\tif (!do_runstate_tests)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing runstate %s\\n\", runstate_names[uc.args[1]]);\n\t\t\t\trst.type = KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_CURRENT;\n\t\t\t\trst.u.runstate.state = uc.args[1] + RUNSTATE_runnable -\n\t\t\t\t\tTEST_RUNSTATE_runnable;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &rst);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_RUNSTATE_ADJUST:\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing RUNSTATE_ADJUST\\n\");\n\t\t\t\trst.type = KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST;\n\t\t\t\tmemset(&rst.u, 0, sizeof(rst.u));\n\t\t\t\trst.u.runstate.state = (uint64_t)-1;\n\t\t\t\trst.u.runstate.time_blocked =\n\t\t\t\t\t0x5a - rs->time[RUNSTATE_blocked];\n\t\t\t\trst.u.runstate.time_offline =\n\t\t\t\t\t0x6b6b - rs->time[RUNSTATE_offline];\n\t\t\t\trst.u.runstate.time_runnable = -rst.u.runstate.time_blocked -\n\t\t\t\t\trst.u.runstate.time_offline;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &rst);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_RUNSTATE_DATA:\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing RUNSTATE_DATA\\n\");\n\t\t\t\trst.type = KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_DATA;\n\t\t\t\tmemset(&rst.u, 0, sizeof(rst.u));\n\t\t\t\trst.u.runstate.state = RUNSTATE_running;\n\t\t\t\trst.u.runstate.state_entry_time = 0x6b6b + 0x5a;\n\t\t\t\trst.u.runstate.time_blocked = 0x6b6b;\n\t\t\t\trst.u.runstate.time_offline = 0x5a;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &rst);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_STEAL_TIME:\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing steal time\\n\");\n\t\t\t\t \n\t\t\t\trundelay = get_run_delay() + MIN_STEAL_TIME;\n\t\t\t\tdo {\n\t\t\t\t\tsched_yield();\n\t\t\t\t} while (get_run_delay() < rundelay);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_EVTCHN_MASKED:\n\t\t\t\tif (!do_eventfd_tests)\n\t\t\t\t\tgoto done;\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing masked event channel\\n\");\n\t\t\t\tshinfo->evtchn_mask[0] = 1UL << EVTCHN_TEST1;\n\t\t\t\teventfd_write(irq_fd[0], 1UL);\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_EVTCHN_UNMASKED:\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing unmasked event channel\\n\");\n\t\t\t\t \n\t\t\t\tshinfo->evtchn_pending[0] = 0;\n\t\t\t\tshinfo->evtchn_mask[0] = 0;\n\t\t\t\teventfd_write(irq_fd[1], 1UL);\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_EVTCHN_SLOWPATH:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\t\t\t\tshinfo->evtchn_pending[1] = 0;\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing event channel after memslot change\\n\");\n\t\t\t\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS,\n\t\t\t\t\t\t\t    DUMMY_REGION_GPA, DUMMY_REGION_SLOT, 1, 0);\n\t\t\t\teventfd_write(irq_fd[0], 1UL);\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_EVTCHN_SEND_IOCTL:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\t\t\t\tif (!do_evtchn_tests)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tshinfo->evtchn_pending[0] = 0;\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing injection with KVM_XEN_HVM_EVTCHN_SEND\\n\");\n\n\t\t\t\tstruct kvm_irq_routing_xen_evtchn e;\n\t\t\t\te.port = EVTCHN_TEST2;\n\t\t\t\te.vcpu = vcpu->id;\n\t\t\t\te.priority = KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL;\n\n\t\t\t\tvm_ioctl(vm, KVM_XEN_HVM_EVTCHN_SEND, &e);\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_EVTCHN_HCALL:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\t\t\t\tshinfo->evtchn_pending[1] = 0;\n\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing guest EVTCHNOP_send direct to evtchn\\n\");\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_EVTCHN_HCALL_SLOWPATH:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\t\t\t\tshinfo->evtchn_pending[0] = 0;\n\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing guest EVTCHNOP_send direct to evtchn after memslot change\\n\");\n\t\t\t\tvm_userspace_mem_region_add(vm, VM_MEM_SRC_ANONYMOUS,\n\t\t\t\t\t\t\t    DUMMY_REGION_GPA_2, DUMMY_REGION_SLOT_2, 1, 0);\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_EVTCHN_HCALL_EVENTFD:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\t\t\t\tshinfo->evtchn_pending[0] = 0;\n\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing guest EVTCHNOP_send to eventfd\\n\");\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_TIMER_SETUP:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\t\t\t\tshinfo->evtchn_pending[1] = 0;\n\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing guest oneshot timer\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_TIMER_WAIT:\n\t\t\t\tmemset(&tmr, 0, sizeof(tmr));\n\t\t\t\ttmr.type = KVM_XEN_VCPU_ATTR_TYPE_TIMER;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_GET_ATTR, &tmr);\n\t\t\t\tTEST_ASSERT(tmr.u.timer.port == EVTCHN_TIMER,\n\t\t\t\t\t    \"Timer port not returned\");\n\t\t\t\tTEST_ASSERT(tmr.u.timer.priority == KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL,\n\t\t\t\t\t    \"Timer priority not returned\");\n\t\t\t\tTEST_ASSERT(tmr.u.timer.expires_ns > rs->state_entry_time,\n\t\t\t\t\t    \"Timer expiry not returned\");\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_TIMER_RESTORE:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\t\t\t\tshinfo->evtchn_pending[0] = 0;\n\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing restored oneshot timer\\n\");\n\n\t\t\t\ttmr.u.timer.expires_ns = rs->state_entry_time + 100000000;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &tmr);\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_POLL_READY:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing SCHEDOP_poll with already pending event\\n\");\n\t\t\t\tshinfo->evtchn_pending[0] = shinfo->evtchn_mask[0] = 1UL << EVTCHN_TIMER;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_POLL_TIMEOUT:\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing SCHEDOP_poll timeout\\n\");\n\t\t\t\tshinfo->evtchn_pending[0] = 0;\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_POLL_MASKED:\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing SCHEDOP_poll wake on masked event\\n\");\n\n\t\t\t\ttmr.u.timer.expires_ns = rs->state_entry_time + 100000000;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &tmr);\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_POLL_WAKE:\n\t\t\t\tshinfo->evtchn_pending[0] = shinfo->evtchn_mask[0] = 0;\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing SCHEDOP_poll wake on unmasked event\\n\");\n\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\ttmr.u.timer.expires_ns = rs->state_entry_time + 100000000;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &tmr);\n\n\t\t\t\t \n\t\t\t\ttmr.u.timer.expires_ns = 0;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_GET_ATTR, &tmr);\n\t\t\t\tTEST_ASSERT(tmr.u.timer.expires_ns == rs->state_entry_time + 100000000,\n\t\t\t\t\t    \"Timer not reported pending\");\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_TIMER_PAST:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\t\t\t\t \n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_GET_ATTR, &tmr);\n\t\t\t\tTEST_ASSERT(!tmr.u.timer.expires_ns, \"Timer still reported pending\");\n\n\t\t\t\tshinfo->evtchn_pending[0] = 0;\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing timer in the past\\n\");\n\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\ttmr.u.timer.expires_ns = rs->state_entry_time - 100000000ULL;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &tmr);\n\t\t\t\talarm(1);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_LOCKING_SEND_RACE:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\t\t\t\talarm(0);\n\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing shinfo lock corruption (KVM_XEN_HVM_EVTCHN_SEND)\\n\");\n\n\t\t\t\tret = pthread_create(&thread, NULL, &juggle_shinfo_state, (void *)vm);\n\t\t\t\tTEST_ASSERT(ret == 0, \"pthread_create() failed: %s\", strerror(ret));\n\n\t\t\t\tstruct kvm_irq_routing_xen_evtchn uxe = {\n\t\t\t\t\t.port = 1,\n\t\t\t\t\t.vcpu = vcpu->id,\n\t\t\t\t\t.priority = KVM_IRQ_ROUTING_XEN_EVTCHN_PRIO_2LEVEL\n\t\t\t\t};\n\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\tfor (time_t t = time(NULL) + SHINFO_RACE_TIMEOUT; time(NULL) < t;)\n\t\t\t\t\t__vm_ioctl(vm, KVM_XEN_HVM_EVTCHN_SEND, &uxe);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_LOCKING_POLL_RACE:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"Testing shinfo lock corruption (SCHEDOP_poll)\\n\");\n\n\t\t\t\tshinfo->evtchn_pending[0] = 1;\n\n\t\t\t\tevtchn_irq_expected = true;\n\t\t\t\ttmr.u.timer.expires_ns = rs->state_entry_time +\n\t\t\t\t\t\t\t SHINFO_RACE_TIMEOUT * 1000000000ULL;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &tmr);\n\t\t\t\tbreak;\n\n\t\t\tcase TEST_LOCKING_POLL_TIMEOUT:\n\t\t\t\t \n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_GET_ATTR, &tmr);\n\n\t\t\t\t \n\t\t\t\tif (tmr.u.timer.expires_ns)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (!evtchn_irq_expected)\n\t\t\t\t\tbreak;\n\n\t\t\t\ttmr.u.timer.expires_ns = rs->state_entry_time +\n\t\t\t\t\t\t\t SHINFO_RACE_TIMEOUT * 1000000000ULL;\n\t\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &tmr);\n\t\t\t\tbreak;\n\t\t\tcase TEST_DONE:\n\t\t\t\tTEST_ASSERT(!evtchn_irq_expected,\n\t\t\t\t\t    \"Expected event channel IRQ but it didn't happen\");\n\n\t\t\t\tret = pthread_cancel(thread);\n\t\t\t\tTEST_ASSERT(ret == 0, \"pthread_cancel() failed: %s\", strerror(ret));\n\n\t\t\t\tret = pthread_join(thread, 0);\n\t\t\t\tTEST_ASSERT(ret == 0, \"pthread_join() failed: %s\", strerror(ret));\n\t\t\t\tgoto done;\n\n\t\t\tcase TEST_GUEST_SAW_IRQ:\n\t\t\t\tTEST_ASSERT(evtchn_irq_expected, \"Unexpected event channel IRQ\");\n\t\t\t\tevtchn_irq_expected = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall 0x%lx.\", uc.cmd);\n\t\t}\n\t}\n\n done:\n\tevt_reset.type = KVM_XEN_ATTR_TYPE_EVTCHN;\n\tevt_reset.u.evtchn.flags = KVM_XEN_EVTCHN_RESET;\n\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &evt_reset);\n\n\talarm(0);\n\tclock_gettime(CLOCK_REALTIME, &max_ts);\n\n\t \n\tstruct pvclock_wall_clock *wc;\n\tstruct pvclock_vcpu_time_info *ti, *ti2;\n\n\twc = addr_gpa2hva(vm, SHINFO_REGION_GPA + 0xc00);\n\tti = addr_gpa2hva(vm, SHINFO_REGION_GPA + 0x40 + 0x20);\n\tti2 = addr_gpa2hva(vm, PVTIME_ADDR);\n\n\tif (verbose) {\n\t\tprintf(\"Wall clock (v %d) %d.%09d\\n\", wc->version, wc->sec, wc->nsec);\n\t\tprintf(\"Time info 1: v %u tsc %\" PRIu64 \" time %\" PRIu64 \" mul %u shift %u flags %x\\n\",\n\t\t       ti->version, ti->tsc_timestamp, ti->system_time, ti->tsc_to_system_mul,\n\t\t       ti->tsc_shift, ti->flags);\n\t\tprintf(\"Time info 2: v %u tsc %\" PRIu64 \" time %\" PRIu64 \" mul %u shift %u flags %x\\n\",\n\t\t       ti2->version, ti2->tsc_timestamp, ti2->system_time, ti2->tsc_to_system_mul,\n\t\t       ti2->tsc_shift, ti2->flags);\n\t}\n\n\tvm_ts.tv_sec = wc->sec;\n\tvm_ts.tv_nsec = wc->nsec;\n\tTEST_ASSERT(wc->version && !(wc->version & 1),\n\t\t    \"Bad wallclock version %x\", wc->version);\n\tTEST_ASSERT(cmp_timespec(&min_ts, &vm_ts) <= 0, \"VM time too old\");\n\tTEST_ASSERT(cmp_timespec(&max_ts, &vm_ts) >= 0, \"VM time too new\");\n\n\tTEST_ASSERT(ti->version && !(ti->version & 1),\n\t\t    \"Bad time_info version %x\", ti->version);\n\tTEST_ASSERT(ti2->version && !(ti2->version & 1),\n\t\t    \"Bad time_info version %x\", ti->version);\n\n\tif (do_runstate_tests) {\n\t\t \n\t\tstruct kvm_xen_vcpu_attr rst = {\n\t\t\t.type = KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_DATA,\n\t\t};\n\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_GET_ATTR, &rst);\n\n\t\tif (verbose) {\n\t\t\tprintf(\"Runstate: %s(%d), entry %\" PRIu64 \" ns\\n\",\n\t\t\t       rs->state <= RUNSTATE_offline ? runstate_names[rs->state] : \"unknown\",\n\t\t\t       rs->state, rs->state_entry_time);\n\t\t\tfor (int i = RUNSTATE_running; i <= RUNSTATE_offline; i++) {\n\t\t\t\tprintf(\"State %s: %\" PRIu64 \" ns\\n\",\n\t\t\t\t       runstate_names[i], rs->time[i]);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tunsigned long runstate_addr;\n\t\tstruct compat_vcpu_runstate_info *crs;\n\t\tfor (runstate_addr = SHINFO_REGION_GPA + PAGE_SIZE + PAGE_SIZE - sizeof(*rs) - 4;\n\t\t     runstate_addr < SHINFO_REGION_GPA + PAGE_SIZE + PAGE_SIZE + 4; runstate_addr++) {\n\n\t\t\trs = addr_gpa2hva(vm, runstate_addr);\n\t\t\tcrs = (void *)rs;\n\n\t\t\tmemset(rs, 0xa5, sizeof(*rs));\n\n\t\t\t \n\t\t\tlm.u.long_mode = 0;\n\t\t\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &lm);\n\n\t\t\t \n\t\t\tstruct kvm_xen_vcpu_attr st = {\n\t\t\t\t.type = KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR,\n\t\t\t\t.u.gpa = runstate_addr,\n\t\t\t};\n\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &st);\n\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"Compatibility runstate at %08lx\\n\", runstate_addr);\n\n\t\t\tTEST_ASSERT(crs->state == rst.u.runstate.state, \"Runstate mismatch\");\n\t\t\tTEST_ASSERT(crs->state_entry_time == rst.u.runstate.state_entry_time,\n\t\t\t\t    \"State entry time mismatch\");\n\t\t\tTEST_ASSERT(crs->time[RUNSTATE_running] == rst.u.runstate.time_running,\n\t\t\t\t    \"Running time mismatch\");\n\t\t\tTEST_ASSERT(crs->time[RUNSTATE_runnable] == rst.u.runstate.time_runnable,\n\t\t\t\t    \"Runnable time mismatch\");\n\t\t\tTEST_ASSERT(crs->time[RUNSTATE_blocked] == rst.u.runstate.time_blocked,\n\t\t\t\t    \"Blocked time mismatch\");\n\t\t\tTEST_ASSERT(crs->time[RUNSTATE_offline] == rst.u.runstate.time_offline,\n\t\t\t\t    \"Offline time mismatch\");\n\t\t\tTEST_ASSERT(crs->time[RUNSTATE_offline + 1] == 0xa5a5a5a5a5a5a5a5ULL,\n\t\t\t\t    \"Structure overrun\");\n\t\t\tTEST_ASSERT(crs->state_entry_time == crs->time[0] +\n\t\t\t\t    crs->time[1] + crs->time[2] + crs->time[3],\n\t\t\t\t    \"runstate times don't add up\");\n\n\n\t\t\t \n\t\t\tlm.u.long_mode = 1;\n\t\t\tvm_ioctl(vm, KVM_XEN_HVM_SET_ATTR, &lm);\n\n\t\t\tmemset(rs, 0xa5, sizeof(*rs));\n\n\t\t\t \n\t\t\tstruct kvm_xen_vcpu_attr adj = {\n\t\t\t\t.type = KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST,\n\t\t\t\t.u.runstate.state = (uint64_t)-1\n\t\t\t};\n\t\t\tvcpu_ioctl(vcpu, KVM_XEN_VCPU_SET_ATTR, &adj);\n\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"64-bit runstate at %08lx\\n\", runstate_addr);\n\n\t\t\tTEST_ASSERT(rs->state == rst.u.runstate.state, \"Runstate mismatch\");\n\t\t\tTEST_ASSERT(rs->state_entry_time == rst.u.runstate.state_entry_time,\n\t\t\t\t    \"State entry time mismatch\");\n\t\t\tTEST_ASSERT(rs->time[RUNSTATE_running] == rst.u.runstate.time_running,\n\t\t\t\t    \"Running time mismatch\");\n\t\t\tTEST_ASSERT(rs->time[RUNSTATE_runnable] == rst.u.runstate.time_runnable,\n\t\t\t\t    \"Runnable time mismatch\");\n\t\t\tTEST_ASSERT(rs->time[RUNSTATE_blocked] == rst.u.runstate.time_blocked,\n\t\t\t\t    \"Blocked time mismatch\");\n\t\t\tTEST_ASSERT(rs->time[RUNSTATE_offline] == rst.u.runstate.time_offline,\n\t\t\t\t    \"Offline time mismatch\");\n\t\t\tTEST_ASSERT(rs->time[RUNSTATE_offline + 1] == 0xa5a5a5a5a5a5a5a5ULL,\n\t\t\t\t    \"Structure overrun\");\n\n\t\t\tTEST_ASSERT(rs->state_entry_time == rs->time[0] +\n\t\t\t\t    rs->time[1] + rs->time[2] + rs->time[3],\n\t\t\t\t    \"runstate times don't add up\");\n\t\t}\n\t}\n\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}