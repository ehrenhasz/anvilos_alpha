{
  "module_name": "vmx_msrs_test.c",
  "hash_id": "c7b1a7b977de50333428059f291129c0ed444e2232085bd70431563416f62b2a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_msrs_test.c",
  "human_readable_source": "\n \n#include <linux/bitmap.h>\n#include \"kvm_util.h\"\n#include \"vmx.h\"\n\nstatic void vmx_fixed1_msr_test(struct kvm_vcpu *vcpu, uint32_t msr_index,\n\t\t\t\t  uint64_t mask)\n{\n\tuint64_t val = vcpu_get_msr(vcpu, msr_index);\n\tuint64_t bit;\n\n\tmask &= val;\n\n\tfor_each_set_bit(bit, &mask, 64) {\n\t\tvcpu_set_msr(vcpu, msr_index, val & ~BIT_ULL(bit));\n\t\tvcpu_set_msr(vcpu, msr_index, val);\n\t}\n}\n\nstatic void vmx_fixed0_msr_test(struct kvm_vcpu *vcpu, uint32_t msr_index,\n\t\t\t\tuint64_t mask)\n{\n\tuint64_t val = vcpu_get_msr(vcpu, msr_index);\n\tuint64_t bit;\n\n\tmask = ~mask | val;\n\n\tfor_each_clear_bit(bit, &mask, 64) {\n\t\tvcpu_set_msr(vcpu, msr_index, val | BIT_ULL(bit));\n\t\tvcpu_set_msr(vcpu, msr_index, val);\n\t}\n}\n\nstatic void vmx_fixed0and1_msr_test(struct kvm_vcpu *vcpu, uint32_t msr_index)\n{\n\tvmx_fixed0_msr_test(vcpu, msr_index, GENMASK_ULL(31, 0));\n\tvmx_fixed1_msr_test(vcpu, msr_index, GENMASK_ULL(63, 32));\n}\n\nstatic void vmx_save_restore_msrs_test(struct kvm_vcpu *vcpu)\n{\n\tvcpu_set_msr(vcpu, MSR_IA32_VMX_VMCS_ENUM, 0);\n\tvcpu_set_msr(vcpu, MSR_IA32_VMX_VMCS_ENUM, -1ull);\n\n\tvmx_fixed1_msr_test(vcpu, MSR_IA32_VMX_BASIC,\n\t\t\t    BIT_ULL(49) | BIT_ULL(54) | BIT_ULL(55));\n\n\tvmx_fixed1_msr_test(vcpu, MSR_IA32_VMX_MISC,\n\t\t\t    BIT_ULL(5) | GENMASK_ULL(8, 6) | BIT_ULL(14) |\n\t\t\t    BIT_ULL(15) | BIT_ULL(28) | BIT_ULL(29) | BIT_ULL(30));\n\n\tvmx_fixed0and1_msr_test(vcpu, MSR_IA32_VMX_PROCBASED_CTLS2);\n\tvmx_fixed1_msr_test(vcpu, MSR_IA32_VMX_EPT_VPID_CAP, -1ull);\n\tvmx_fixed0and1_msr_test(vcpu, MSR_IA32_VMX_TRUE_PINBASED_CTLS);\n\tvmx_fixed0and1_msr_test(vcpu, MSR_IA32_VMX_TRUE_PROCBASED_CTLS);\n\tvmx_fixed0and1_msr_test(vcpu, MSR_IA32_VMX_TRUE_EXIT_CTLS);\n\tvmx_fixed0and1_msr_test(vcpu, MSR_IA32_VMX_TRUE_ENTRY_CTLS);\n\tvmx_fixed1_msr_test(vcpu, MSR_IA32_VMX_VMFUNC, -1ull);\n}\n\nstatic void __ia32_feature_control_msr_test(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    uint64_t msr_bit,\n\t\t\t\t\t    struct kvm_x86_cpu_feature feature)\n{\n\tuint64_t val;\n\n\tvcpu_clear_cpuid_feature(vcpu, feature);\n\n\tval = vcpu_get_msr(vcpu, MSR_IA32_FEAT_CTL);\n\tvcpu_set_msr(vcpu, MSR_IA32_FEAT_CTL, val | msr_bit | FEAT_CTL_LOCKED);\n\tvcpu_set_msr(vcpu, MSR_IA32_FEAT_CTL, (val & ~msr_bit) | FEAT_CTL_LOCKED);\n\tvcpu_set_msr(vcpu, MSR_IA32_FEAT_CTL, val | msr_bit | FEAT_CTL_LOCKED);\n\tvcpu_set_msr(vcpu, MSR_IA32_FEAT_CTL, (val & ~msr_bit) | FEAT_CTL_LOCKED);\n\tvcpu_set_msr(vcpu, MSR_IA32_FEAT_CTL, val);\n\n\tif (!kvm_cpu_has(feature))\n\t\treturn;\n\n\tvcpu_set_cpuid_feature(vcpu, feature);\n}\n\nstatic void ia32_feature_control_msr_test(struct kvm_vcpu *vcpu)\n{\n\tuint64_t supported_bits = FEAT_CTL_LOCKED |\n\t\t\t\t  FEAT_CTL_VMX_ENABLED_INSIDE_SMX |\n\t\t\t\t  FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX |\n\t\t\t\t  FEAT_CTL_SGX_LC_ENABLED |\n\t\t\t\t  FEAT_CTL_SGX_ENABLED |\n\t\t\t\t  FEAT_CTL_LMCE_ENABLED;\n\tint bit, r;\n\n\t__ia32_feature_control_msr_test(vcpu, FEAT_CTL_VMX_ENABLED_INSIDE_SMX, X86_FEATURE_SMX);\n\t__ia32_feature_control_msr_test(vcpu, FEAT_CTL_VMX_ENABLED_INSIDE_SMX, X86_FEATURE_VMX);\n\t__ia32_feature_control_msr_test(vcpu, FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX, X86_FEATURE_VMX);\n\t__ia32_feature_control_msr_test(vcpu, FEAT_CTL_SGX_LC_ENABLED, X86_FEATURE_SGX_LC);\n\t__ia32_feature_control_msr_test(vcpu, FEAT_CTL_SGX_LC_ENABLED, X86_FEATURE_SGX);\n\t__ia32_feature_control_msr_test(vcpu, FEAT_CTL_SGX_ENABLED, X86_FEATURE_SGX);\n\t__ia32_feature_control_msr_test(vcpu, FEAT_CTL_LMCE_ENABLED, X86_FEATURE_MCE);\n\n\tfor_each_clear_bit(bit, &supported_bits, 64) {\n\t\tr = _vcpu_set_msr(vcpu, MSR_IA32_FEAT_CTL, BIT(bit));\n\t\tTEST_ASSERT(r == 0,\n\t\t\t    \"Setting reserved bit %d in IA32_FEATURE_CONTROL should fail\", bit);\n\t}\n}\n\nint main(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_DISABLE_QUIRKS2));\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));\n\n\t \n\tvm = vm_create_with_one_vcpu(&vcpu, NULL);\n\n\tvmx_save_restore_msrs_test(vcpu);\n\tia32_feature_control_msr_test(vcpu);\n\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}