{
  "module_name": "svm_nested_soft_inject_test.c",
  "hash_id": "d263212e0ca2683888ea699cdbf42b9f7d26c0180950b4bf5ae659b517f50803",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/svm_nested_soft_inject_test.c",
  "human_readable_source": "\n \n#include <stdatomic.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"apic.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"svm_util.h\"\n#include \"test_util.h\"\n\n#define INT_NR\t\t\t0x20\n\nstatic_assert(ATOMIC_INT_LOCK_FREE == 2, \"atomic int is not lockless\");\n\nstatic unsigned int bp_fired;\nstatic void guest_bp_handler(struct ex_regs *regs)\n{\n\tbp_fired++;\n}\n\nstatic unsigned int int_fired;\nstatic void l2_guest_code_int(void);\n\nstatic void guest_int_handler(struct ex_regs *regs)\n{\n\tint_fired++;\n\tGUEST_ASSERT_EQ(regs->rip, (unsigned long)l2_guest_code_int);\n}\n\nstatic void l2_guest_code_int(void)\n{\n\tGUEST_ASSERT_EQ(int_fired, 1);\n\n\t \n\t__asm__ __volatile__(\"push %%rbp; vmmcall; ud2; pop %%rbp\"\n                             : : \"a\"(0xdeadbeef), \"c\"(0xbeefdead)\n                             : \"rbx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \"r9\",\n                               \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\");\n\n\tGUEST_ASSERT_EQ(bp_fired, 1);\n\thlt();\n}\n\nstatic atomic_int nmi_stage;\n#define nmi_stage_get() atomic_load_explicit(&nmi_stage, memory_order_acquire)\n#define nmi_stage_inc() atomic_fetch_add_explicit(&nmi_stage, 1, memory_order_acq_rel)\nstatic void guest_nmi_handler(struct ex_regs *regs)\n{\n\tnmi_stage_inc();\n\n\tif (nmi_stage_get() == 1) {\n\t\tvmmcall();\n\t\tGUEST_FAIL(\"Unexpected resume after VMMCALL\");\n\t} else {\n\t\tGUEST_ASSERT_EQ(nmi_stage_get(), 3);\n\t\tGUEST_DONE();\n\t}\n}\n\nstatic void l2_guest_code_nmi(void)\n{\n\tud2();\n}\n\nstatic void l1_guest_code(struct svm_test_data *svm, uint64_t is_nmi, uint64_t idt_alt)\n{\n\t#define L2_GUEST_STACK_SIZE 64\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (is_nmi)\n\t\tx2apic_enable();\n\n\t \n\tgeneric_svm_setup(svm,\n\t\t\t  is_nmi ? l2_guest_code_nmi : l2_guest_code_int,\n\t\t\t  &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\n\tvmcb->control.intercept_exceptions |= BIT(PF_VECTOR) | BIT(UD_VECTOR);\n\tvmcb->control.intercept |= BIT(INTERCEPT_NMI) | BIT(INTERCEPT_HLT);\n\n\tif (is_nmi) {\n\t\tvmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\t} else {\n\t\tvmcb->control.event_inj = INT_NR | SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_SOFT;\n\t\t \n\t\tvmcb->control.next_rip = vmcb->save.rip;\n\t}\n\n\trun_guest(vmcb, svm->vmcb_gpa);\n\t__GUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_VMMCALL,\n\t\t       \"Expected VMMCAL #VMEXIT, got '0x%x', info1 = '0x%llx, info2 = '0x%llx'\",\n\t\t       vmcb->control.exit_code,\n\t\t       vmcb->control.exit_info_1, vmcb->control.exit_info_2);\n\n\tif (is_nmi) {\n\t\tclgi();\n\t\tx2apic_write_reg(APIC_ICR, APIC_DEST_SELF | APIC_INT_ASSERT | APIC_DM_NMI);\n\n\t\tGUEST_ASSERT_EQ(nmi_stage_get(), 1);\n\t\tnmi_stage_inc();\n\n\t\tstgi();\n\t\t \n\t\twhile (true)\n\t\t\tcpu_relax();\n\t}\n\n\t \n\tvmcb->save.rip += 3;\n\n\t \n\tvmcb->save.idtr.base = idt_alt;\n\tvmcb->control.clean = 0;  \n\n\tvmcb->control.event_inj = BP_VECTOR | SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_EXEPT;\n\t \n\tvmcb->control.next_rip = vmcb->save.rip + 2;\n\n\trun_guest(vmcb, svm->vmcb_gpa);\n\t__GUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_HLT,\n\t\t       \"Expected HLT #VMEXIT, got '0x%x', info1 = '0x%llx, info2 = '0x%llx'\",\n\t\t       vmcb->control.exit_code,\n\t\t       vmcb->control.exit_info_1, vmcb->control.exit_info_2);\n\n\tGUEST_DONE();\n}\n\nstatic void run_test(bool is_nmi)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tvm_vaddr_t svm_gva;\n\tvm_vaddr_t idt_alt_vm;\n\tstruct kvm_guest_debug debug;\n\n\tpr_info(\"Running %s test\\n\", is_nmi ? \"NMI\" : \"soft int\");\n\n\tvm = vm_create_with_one_vcpu(&vcpu, l1_guest_code);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\tvm_install_exception_handler(vm, NMI_VECTOR, guest_nmi_handler);\n\tvm_install_exception_handler(vm, BP_VECTOR, guest_bp_handler);\n\tvm_install_exception_handler(vm, INT_NR, guest_int_handler);\n\n\tvcpu_alloc_svm(vm, &svm_gva);\n\n\tif (!is_nmi) {\n\t\tvoid *idt, *idt_alt;\n\n\t\tidt_alt_vm = vm_vaddr_alloc_page(vm);\n\t\tidt_alt = addr_gva2hva(vm, idt_alt_vm);\n\t\tidt = addr_gva2hva(vm, vm->idt);\n\t\tmemcpy(idt_alt, idt, getpagesize());\n\t} else {\n\t\tidt_alt_vm = 0;\n\t}\n\tvcpu_args_set(vcpu, 3, svm_gva, (uint64_t)is_nmi, (uint64_t)idt_alt_vm);\n\n\tmemset(&debug, 0, sizeof(debug));\n\tvcpu_guest_debug_set(vcpu, &debug);\n\n\tstruct ucall uc;\n\n\talarm(2);\n\tvcpu_run(vcpu);\n\talarm(0);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\t\tbreak;\n\t\t \n\tcase UCALL_DONE:\n\t\tgoto done;\n\tdefault:\n\t\tTEST_FAIL(\"Unknown ucall 0x%lx.\", uc.cmd);\n\t}\ndone:\n\tkvm_vm_free(vm);\n}\n\nint main(int argc, char *argv[])\n{\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_SVM));\n\n\tTEST_ASSERT(kvm_cpu_has(X86_FEATURE_NRIPS),\n\t\t    \"KVM with nSVM is supposed to unconditionally advertise nRIP Save\");\n\n\tatomic_init(&nmi_stage, 0);\n\n\trun_test(false);\n\trun_test(true);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}