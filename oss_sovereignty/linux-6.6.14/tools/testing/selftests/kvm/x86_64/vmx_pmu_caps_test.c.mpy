{
  "module_name": "vmx_pmu_caps_test.c",
  "hash_id": "562b56a433daeacde64ae45a165e6cd54e1b5d4d27cf6248545fb213604f8dc2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_pmu_caps_test.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE  \n#include <sys/ioctl.h>\n\n#include <linux/bitmap.h>\n\n#include \"kvm_util.h\"\n#include \"vmx.h\"\n\nunion perf_capabilities {\n\tstruct {\n\t\tu64\tlbr_format:6;\n\t\tu64\tpebs_trap:1;\n\t\tu64\tpebs_arch_reg:1;\n\t\tu64\tpebs_format:4;\n\t\tu64\tsmm_freeze:1;\n\t\tu64\tfull_width_write:1;\n\t\tu64 pebs_baseline:1;\n\t\tu64\tperf_metrics:1;\n\t\tu64\tpebs_output_pt_available:1;\n\t\tu64\tanythread_deprecated:1;\n\t};\n\tu64\tcapabilities;\n};\n\n \nstatic const union perf_capabilities immutable_caps = {\n\t.lbr_format = -1,\n\t.pebs_trap  = 1,\n\t.pebs_arch_reg = 1,\n\t.pebs_format = -1,\n\t.pebs_baseline = 1,\n};\n\nstatic const union perf_capabilities format_caps = {\n\t.lbr_format = -1,\n\t.pebs_format = -1,\n};\n\nstatic void guest_test_perf_capabilities_gp(uint64_t val)\n{\n\tuint8_t vector = wrmsr_safe(MSR_IA32_PERF_CAPABILITIES, val);\n\n\t__GUEST_ASSERT(vector == GP_VECTOR,\n\t\t       \"Expected #GP for value '0x%llx', got vector '0x%x'\",\n\t\t       val, vector);\n}\n\nstatic void guest_code(uint64_t current_val)\n{\n\tint i;\n\n\tguest_test_perf_capabilities_gp(current_val);\n\tguest_test_perf_capabilities_gp(0);\n\n\tfor (i = 0; i < 64; i++)\n\t\tguest_test_perf_capabilities_gp(current_val ^ BIT_ULL(i));\n\n\tGUEST_DONE();\n}\n\n \nstatic void test_guest_wrmsr_perf_capabilities(union perf_capabilities host_cap)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\tstruct ucall uc;\n\tint r, i;\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\tvcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, host_cap.capabilities);\n\n\tvcpu_args_set(vcpu, 1, host_cap.capabilities);\n\tvcpu_run(vcpu);\n\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\t\tbreak;\n\tcase UCALL_DONE:\n\t\tbreak;\n\tdefault:\n\t\tTEST_FAIL(\"Unexpected ucall: %lu\", uc.cmd);\n\t}\n\n\tTEST_ASSERT_EQ(vcpu_get_msr(vcpu, MSR_IA32_PERF_CAPABILITIES),\n\t\t\thost_cap.capabilities);\n\n\tvcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, host_cap.capabilities);\n\n\tr = _vcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, 0);\n\tTEST_ASSERT(!r, \"Post-KVM_RUN write '0' didn't fail\");\n\n\tfor (i = 0; i < 64; i++) {\n\t\tr = _vcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES,\n\t\t\t\t  host_cap.capabilities ^ BIT_ULL(i));\n\t\tTEST_ASSERT(!r, \"Post-KVM_RUN write '0x%llx'didn't fail\",\n\t\t\t    host_cap.capabilities ^ BIT_ULL(i));\n\t}\n\n\tkvm_vm_free(vm);\n}\n\n \nstatic void test_basic_perf_capabilities(union perf_capabilities host_cap)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = vm_create_with_one_vcpu(&vcpu, NULL);\n\n\tvcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, 0);\n\tvcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, host_cap.capabilities);\n\n\tkvm_vm_free(vm);\n}\n\nstatic void test_fungible_perf_capabilities(union perf_capabilities host_cap)\n{\n\tconst uint64_t fungible_caps = host_cap.capabilities & ~immutable_caps.capabilities;\n\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = vm_create_with_one_vcpu(&vcpu, NULL);\n\tint bit;\n\n\tfor_each_set_bit(bit, &fungible_caps, 64) {\n\t\tvcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, BIT_ULL(bit));\n\t\tvcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES,\n\t\t\t     host_cap.capabilities & ~BIT_ULL(bit));\n\t}\n\tvcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, host_cap.capabilities);\n\n\tkvm_vm_free(vm);\n}\n\n \nstatic void test_immutable_perf_capabilities(union perf_capabilities host_cap)\n{\n\tconst uint64_t reserved_caps = (~host_cap.capabilities |\n\t\t\t\t\timmutable_caps.capabilities) &\n\t\t\t\t       ~format_caps.capabilities;\n\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm = vm_create_with_one_vcpu(&vcpu, NULL);\n\tunion perf_capabilities val = host_cap;\n\tint r, bit;\n\n\tfor_each_set_bit(bit, &reserved_caps, 64) {\n\t\tr = _vcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES,\n\t\t\t\t  host_cap.capabilities ^ BIT_ULL(bit));\n\t\tTEST_ASSERT(!r, \"%s immutable feature 0x%llx (bit %d) didn't fail\",\n\t\t\t    host_cap.capabilities & BIT_ULL(bit) ? \"Setting\" : \"Clearing\",\n\t\t\t    BIT_ULL(bit), bit);\n\t}\n\n\t \n\tfor (val.lbr_format = 1; val.lbr_format; val.lbr_format++) {\n\t\tif (val.lbr_format == host_cap.lbr_format)\n\t\t\tcontinue;\n\n\t\tr = _vcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, val.capabilities);\n\t\tTEST_ASSERT(!r, \"Bad LBR FMT = 0x%x didn't fail, host = 0x%x\",\n\t\t\t    val.lbr_format, host_cap.lbr_format);\n\t}\n\n\t \n\tfor (val.pebs_format = 1; val.pebs_format; val.pebs_format++) {\n\t\tif (val.pebs_format == host_cap.pebs_format)\n\t\t\tcontinue;\n\n\t\tr = _vcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, val.capabilities);\n\t\tTEST_ASSERT(!r, \"Bad PEBS FMT = 0x%x didn't fail, host = 0x%x\",\n\t\t\t    val.pebs_format, host_cap.pebs_format);\n\t}\n\n\tkvm_vm_free(vm);\n}\n\n \nstatic void test_lbr_perf_capabilities(union perf_capabilities host_cap)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tint r;\n\n\tif (!host_cap.lbr_format)\n\t\treturn;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, NULL);\n\n\tvcpu_set_msr(vcpu, MSR_IA32_PERF_CAPABILITIES, host_cap.capabilities);\n\tvcpu_set_msr(vcpu, MSR_LBR_TOS, 7);\n\n\tvcpu_clear_cpuid_entry(vcpu, X86_PROPERTY_PMU_VERSION.function);\n\n\tr = _vcpu_set_msr(vcpu, MSR_LBR_TOS, 7);\n\tTEST_ASSERT(!r, \"Writing LBR_TOS should fail after disabling vPMU\");\n\n\tkvm_vm_free(vm);\n}\n\nint main(int argc, char *argv[])\n{\n\tunion perf_capabilities host_cap;\n\n\tTEST_REQUIRE(get_kvm_param_bool(\"enable_pmu\"));\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_PDCM));\n\n\tTEST_REQUIRE(kvm_cpu_has_p(X86_PROPERTY_PMU_VERSION));\n\tTEST_REQUIRE(kvm_cpu_property(X86_PROPERTY_PMU_VERSION) > 0);\n\n\thost_cap.capabilities = kvm_get_feature_msr(MSR_IA32_PERF_CAPABILITIES);\n\n\tTEST_ASSERT(host_cap.full_width_write,\n\t\t    \"Full-width writes should always be supported\");\n\n\ttest_basic_perf_capabilities(host_cap);\n\ttest_fungible_perf_capabilities(host_cap);\n\ttest_immutable_perf_capabilities(host_cap);\n\ttest_guest_wrmsr_perf_capabilities(host_cap);\n\ttest_lbr_perf_capabilities(host_cap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}