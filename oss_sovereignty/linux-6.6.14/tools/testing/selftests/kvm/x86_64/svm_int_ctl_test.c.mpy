{
  "module_name": "svm_int_ctl_test.c",
  "hash_id": "7d4b1e2eb72345e47d27a5e7a139167a708a760dddd942b15d2587afb83901c6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/svm_int_ctl_test.c",
  "human_readable_source": "\n \n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"svm_util.h\"\n#include \"apic.h\"\n\nbool vintr_irq_called;\nbool intr_irq_called;\n\n#define VINTR_IRQ_NUMBER 0x20\n#define INTR_IRQ_NUMBER 0x30\n\nstatic void vintr_irq_handler(struct ex_regs *regs)\n{\n\tvintr_irq_called = true;\n}\n\nstatic void intr_irq_handler(struct ex_regs *regs)\n{\n\tx2apic_write_reg(APIC_EOI, 0x00);\n\tintr_irq_called = true;\n}\n\nstatic void l2_guest_code(struct svm_test_data *svm)\n{\n\t \n\tx2apic_write_reg(APIC_ICR,\n\t\tAPIC_DEST_SELF | APIC_INT_ASSERT | INTR_IRQ_NUMBER);\n\n\t__asm__ __volatile__(\n\t\t\"sti\\n\"\n\t\t\"nop\\n\"\n\t);\n\n\tGUEST_ASSERT(vintr_irq_called);\n\tGUEST_ASSERT(intr_irq_called);\n\n\t__asm__ __volatile__(\n\t\t\"vmcall\\n\"\n\t);\n}\n\nstatic void l1_guest_code(struct svm_test_data *svm)\n{\n\t#define L2_GUEST_STACK_SIZE 64\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tx2apic_enable();\n\n\t \n\tgeneric_svm_setup(svm, l2_guest_code,\n\t\t\t  &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\n\t \n\tvmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t \n\tvmcb->control.intercept &= ~(BIT(INTERCEPT_INTR) | BIT(INTERCEPT_VINTR));\n\n\t \n\tvmcb->control.int_ctl |= V_IRQ_MASK | (0x1 << V_INTR_PRIO_SHIFT);\n\tvmcb->control.int_vector = VINTR_IRQ_NUMBER;\n\n\trun_guest(vmcb, svm->vmcb_gpa);\n\tGUEST_ASSERT(vmcb->control.exit_code == SVM_EXIT_VMMCALL);\n\tGUEST_DONE();\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vcpu *vcpu;\n\tvm_vaddr_t svm_gva;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_SVM));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, l1_guest_code);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\tvm_install_exception_handler(vm, VINTR_IRQ_NUMBER, vintr_irq_handler);\n\tvm_install_exception_handler(vm, INTR_IRQ_NUMBER, intr_irq_handler);\n\n\tvcpu_alloc_svm(vm, &svm_gva);\n\tvcpu_args_set(vcpu, 1, svm_gva);\n\n\tvcpu_run(vcpu);\n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\t\tbreak;\n\t\t \n\tcase UCALL_DONE:\n\t\tgoto done;\n\tdefault:\n\t\tTEST_FAIL(\"Unknown ucall 0x%lx.\", uc.cmd);\n\t}\ndone:\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}