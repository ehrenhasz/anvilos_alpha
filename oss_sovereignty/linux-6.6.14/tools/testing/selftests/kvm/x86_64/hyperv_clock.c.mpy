{
  "module_name": "hyperv_clock.c",
  "hash_id": "f1073837d93c19da4dc4b010fb0f145d02130f5b5e2aab0ffa14992589cbb15d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/hyperv_clock.c",
  "human_readable_source": "\n \n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"hyperv.h\"\n\nstruct ms_hyperv_tsc_page {\n\tvolatile u32 tsc_sequence;\n\tu32 reserved1;\n\tvolatile u64 tsc_scale;\n\tvolatile s64 tsc_offset;\n} __packed;\n\n \nstatic inline u64 mul_u64_u64_shr64(u64 a, u64 b)\n{\n\tunion {\n\t\tu64 ll;\n\t\tstruct {\n\t\t\tu32 low, high;\n\t\t} l;\n\t} rm, rn, rh, a0, b0;\n\tu64 c;\n\n\ta0.ll = a;\n\tb0.ll = b;\n\n\trm.ll = (u64)a0.l.low * b0.l.high;\n\trn.ll = (u64)a0.l.high * b0.l.low;\n\trh.ll = (u64)a0.l.high * b0.l.high;\n\n\trh.l.low = c = rm.l.high + rn.l.high + rh.l.low;\n\trh.l.high = (c >> 32) + rh.l.high;\n\n\treturn rh.ll;\n}\n\nstatic inline void nop_loop(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 100000000; i++)\n\t\tasm volatile(\"nop\");\n}\n\nstatic inline void check_tsc_msr_rdtsc(void)\n{\n\tu64 tsc_freq, r1, r2, t1, t2;\n\ts64 delta_ns;\n\n\ttsc_freq = rdmsr(HV_X64_MSR_TSC_FREQUENCY);\n\tGUEST_ASSERT(tsc_freq > 0);\n\n\t \n\tr1 = rdtsc();\n\tt1 = rdmsr(HV_X64_MSR_TIME_REF_COUNT);\n\tr1 = (r1 + rdtsc()) / 2;\n\tnop_loop();\n\tr2 = rdtsc();\n\tt2 = rdmsr(HV_X64_MSR_TIME_REF_COUNT);\n\tr2 = (r2 + rdtsc()) / 2;\n\n\tGUEST_ASSERT(r2 > r1 && t2 > t1);\n\n\t \n\tdelta_ns = ((t2 - t1) * 100) - ((r2 - r1) * 1000000000 / tsc_freq);\n\tif (delta_ns < 0)\n\t\tdelta_ns = -delta_ns;\n\n\t \n\tGUEST_ASSERT(delta_ns * 100 < (t2 - t1) * 100);\n}\n\nstatic inline u64 get_tscpage_ts(struct ms_hyperv_tsc_page *tsc_page)\n{\n\treturn mul_u64_u64_shr64(rdtsc(), tsc_page->tsc_scale) + tsc_page->tsc_offset;\n}\n\nstatic inline void check_tsc_msr_tsc_page(struct ms_hyperv_tsc_page *tsc_page)\n{\n\tu64 r1, r2, t1, t2;\n\n\t \n\tt1 = get_tscpage_ts(tsc_page);\n\tr1 = rdmsr(HV_X64_MSR_TIME_REF_COUNT);\n\n\t \n\tGUEST_ASSERT(r1 >= t1 && r1 - t1 < 100000);\n\tnop_loop();\n\n\tt2 = get_tscpage_ts(tsc_page);\n\tr2 = rdmsr(HV_X64_MSR_TIME_REF_COUNT);\n\tGUEST_ASSERT(r2 >= t1 && r2 - t2 < 100000);\n}\n\nstatic void guest_main(struct ms_hyperv_tsc_page *tsc_page, vm_paddr_t tsc_page_gpa)\n{\n\tu64 tsc_scale, tsc_offset;\n\n\t \n\tGUEST_SYNC(1);\n\twrmsr(HV_X64_MSR_GUEST_OS_ID, HYPERV_LINUX_OS_ID);\n\tGUEST_SYNC(2);\n\n\tcheck_tsc_msr_rdtsc();\n\n\tGUEST_SYNC(3);\n\n\t \n\twrmsr(HV_X64_MSR_REFERENCE_TSC, tsc_page_gpa);\n\tGUEST_ASSERT(tsc_page->tsc_sequence == 0);\n\tGUEST_ASSERT(tsc_page->tsc_scale == 0);\n\tGUEST_ASSERT(tsc_page->tsc_offset == 0);\n\n\tGUEST_SYNC(4);\n\n\t \n\twrmsr(HV_X64_MSR_REFERENCE_TSC, tsc_page_gpa | 0x1);\n\tGUEST_ASSERT(tsc_page->tsc_sequence != 0);\n\n\tGUEST_SYNC(5);\n\n\tcheck_tsc_msr_tsc_page(tsc_page);\n\n\tGUEST_SYNC(6);\n\n\ttsc_offset = tsc_page->tsc_offset;\n\t \n\n\tGUEST_SYNC(7);\n\t \n\tGUEST_ASSERT(get_tscpage_ts(tsc_page) < 100000);\n\n\tGUEST_ASSERT(tsc_page->tsc_offset != tsc_offset);\n\n\tnop_loop();\n\n\t \n\twrmsr(HV_X64_MSR_REENLIGHTENMENT_CONTROL, 0x1 << 16 | 0xff);\n\twrmsr(HV_X64_MSR_TSC_EMULATION_CONTROL, 0x1);\n\ttsc_offset = tsc_page->tsc_offset;\n\ttsc_scale = tsc_page->tsc_scale;\n\tGUEST_SYNC(8);\n\tGUEST_ASSERT(tsc_page->tsc_offset == tsc_offset);\n\tGUEST_ASSERT(tsc_page->tsc_scale == tsc_scale);\n\n\tGUEST_SYNC(9);\n\n\tcheck_tsc_msr_tsc_page(tsc_page);\n\n\t \n\twrmsr(HV_X64_MSR_REENLIGHTENMENT_CONTROL, 0);\n\twrmsr(HV_X64_MSR_TSC_EMULATION_CONTROL, 0);\n\twrmsr(HV_X64_MSR_REFERENCE_TSC, 0);\n\tmemset(tsc_page, 0, sizeof(*tsc_page));\n\n\tGUEST_SYNC(10);\n\tGUEST_ASSERT(tsc_page->tsc_sequence == 0);\n\tGUEST_ASSERT(tsc_page->tsc_offset == 0);\n\tGUEST_ASSERT(tsc_page->tsc_scale == 0);\n\n\tGUEST_DONE();\n}\n\nstatic void host_check_tsc_msr_rdtsc(struct kvm_vcpu *vcpu)\n{\n\tu64 tsc_freq, r1, r2, t1, t2;\n\ts64 delta_ns;\n\n\ttsc_freq = vcpu_get_msr(vcpu, HV_X64_MSR_TSC_FREQUENCY);\n\tTEST_ASSERT(tsc_freq > 0, \"TSC frequency must be nonzero\");\n\n\t \n\tr1 = rdtsc();\n\tt1 = vcpu_get_msr(vcpu, HV_X64_MSR_TIME_REF_COUNT);\n\tr1 = (r1 + rdtsc()) / 2;\n\tnop_loop();\n\tr2 = rdtsc();\n\tt2 = vcpu_get_msr(vcpu, HV_X64_MSR_TIME_REF_COUNT);\n\tr2 = (r2 + rdtsc()) / 2;\n\n\tTEST_ASSERT(t2 > t1, \"Time reference MSR is not monotonic (%ld <= %ld)\", t1, t2);\n\n\t \n\tdelta_ns = ((t2 - t1) * 100) - ((r2 - r1) * 1000000000 / tsc_freq);\n\tif (delta_ns < 0)\n\t\tdelta_ns = -delta_ns;\n\n\t \n\tTEST_ASSERT(delta_ns * 100 < (t2 - t1) * 100,\n\t\t    \"Elapsed time does not match (MSR=%ld, TSC=%ld)\",\n\t\t    (t2 - t1) * 100, (r2 - r1) * 1000000000 / tsc_freq);\n}\n\nint main(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\tvm_vaddr_t tsc_page_gva;\n\tint stage;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_main);\n\n\tvcpu_set_hv_cpuid(vcpu);\n\n\ttsc_page_gva = vm_vaddr_alloc_page(vm);\n\tmemset(addr_gva2hva(vm, tsc_page_gva), 0x0, getpagesize());\n\tTEST_ASSERT((addr_gva2gpa(vm, tsc_page_gva) & (getpagesize() - 1)) == 0,\n\t\t\"TSC page has to be page aligned\\n\");\n\tvcpu_args_set(vcpu, 2, tsc_page_gva, addr_gva2gpa(vm, tsc_page_gva));\n\n\thost_check_tsc_msr_rdtsc(vcpu);\n\n\tfor (stage = 1;; stage++) {\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t \n\t\tcase UCALL_SYNC:\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\t \n\t\t\tTEST_ASSERT(stage == 11, \"Testing ended prematurely, stage %d\\n\",\n\t\t\t\t    stage);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\n\t\tTEST_ASSERT(!strcmp((const char *)uc.args[0], \"hello\") &&\n\t\t\t    uc.args[1] == stage,\n\t\t\t    \"Stage %d: Unexpected register values vmexit, got %lx\",\n\t\t\t    stage, (ulong)uc.args[1]);\n\n\t\t \n\t\tif (stage == 7 || stage == 8 || stage == 10) {\n\t\t\tstruct kvm_clock_data clock = {0};\n\n\t\t\tvm_ioctl(vm, KVM_SET_CLOCK, &clock);\n\t\t}\n\t}\n\nout:\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}