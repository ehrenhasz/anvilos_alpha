{
  "module_name": "hyperv_ipi.c",
  "hash_id": "7096e33731d64fd444975cb2739952e2f85f785e069c6a5801004984fed42afb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/hyperv_ipi.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE  \n#include <pthread.h>\n#include <inttypes.h>\n\n#include \"kvm_util.h\"\n#include \"hyperv.h\"\n#include \"test_util.h\"\n#include \"vmx.h\"\n\n#define RECEIVER_VCPU_ID_1 2\n#define RECEIVER_VCPU_ID_2 65\n\n#define IPI_VECTOR\t 0xfe\n\nstatic volatile uint64_t ipis_rcvd[RECEIVER_VCPU_ID_2 + 1];\n\nstruct hv_vpset {\n\tu64 format;\n\tu64 valid_bank_mask;\n\tu64 bank_contents[2];\n};\n\nenum HV_GENERIC_SET_FORMAT {\n\tHV_GENERIC_SET_SPARSE_4K,\n\tHV_GENERIC_SET_ALL,\n};\n\n \nstruct hv_send_ipi {\n\tu32 vector;\n\tu32 reserved;\n\tu64 cpu_mask;\n};\n\n \nstruct hv_send_ipi_ex {\n\tu32 vector;\n\tu32 reserved;\n\tstruct hv_vpset vp_set;\n};\n\nstatic inline void hv_init(vm_vaddr_t pgs_gpa)\n{\n\twrmsr(HV_X64_MSR_GUEST_OS_ID, HYPERV_LINUX_OS_ID);\n\twrmsr(HV_X64_MSR_HYPERCALL, pgs_gpa);\n}\n\nstatic void receiver_code(void *hcall_page, vm_vaddr_t pgs_gpa)\n{\n\tu32 vcpu_id;\n\n\tx2apic_enable();\n\thv_init(pgs_gpa);\n\n\tvcpu_id = rdmsr(HV_X64_MSR_VP_INDEX);\n\n\t \n\tipis_rcvd[vcpu_id] = (u64)-1;\n\n\tfor (;;)\n\t\tasm volatile(\"sti; hlt; cli\");\n}\n\nstatic void guest_ipi_handler(struct ex_regs *regs)\n{\n\tu32 vcpu_id = rdmsr(HV_X64_MSR_VP_INDEX);\n\n\tipis_rcvd[vcpu_id]++;\n\twrmsr(HV_X64_MSR_EOI, 1);\n}\n\nstatic inline void nop_loop(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 100000000; i++)\n\t\tasm volatile(\"nop\");\n}\n\nstatic void sender_guest_code(void *hcall_page, vm_vaddr_t pgs_gpa)\n{\n\tstruct hv_send_ipi *ipi = (struct hv_send_ipi *)hcall_page;\n\tstruct hv_send_ipi_ex *ipi_ex = (struct hv_send_ipi_ex *)hcall_page;\n\tint stage = 1, ipis_expected[2] = {0};\n\n\thv_init(pgs_gpa);\n\tGUEST_SYNC(stage++);\n\n\t \n\twhile (!ipis_rcvd[RECEIVER_VCPU_ID_1] || !ipis_rcvd[RECEIVER_VCPU_ID_2])\n\t\tnop_loop();\n\tipis_rcvd[RECEIVER_VCPU_ID_1] = ipis_rcvd[RECEIVER_VCPU_ID_2] = 0;\n\n\t \n\tipi->vector = IPI_VECTOR;\n\tipi->cpu_mask = 1 << RECEIVER_VCPU_ID_1;\n\thyperv_hypercall(HVCALL_SEND_IPI, pgs_gpa, pgs_gpa + 4096);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ++ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\t \n\thyperv_hypercall(HVCALL_SEND_IPI | HV_HYPERCALL_FAST_BIT,\n\t\t\t IPI_VECTOR, 1 << RECEIVER_VCPU_ID_1);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ++ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\n\t \n\tmemset(hcall_page, 0, 4096);\n\tipi_ex->vector = IPI_VECTOR;\n\tipi_ex->vp_set.format = HV_GENERIC_SET_SPARSE_4K;\n\tipi_ex->vp_set.valid_bank_mask = 1 << 0;\n\tipi_ex->vp_set.bank_contents[0] = BIT(RECEIVER_VCPU_ID_1);\n\thyperv_hypercall(HVCALL_SEND_IPI_EX | (1 << HV_HYPERCALL_VARHEAD_OFFSET),\n\t\t\t pgs_gpa, pgs_gpa + 4096);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ++ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\t \n\thyperv_write_xmm_input(&ipi_ex->vp_set.valid_bank_mask, 1);\n\thyperv_hypercall(HVCALL_SEND_IPI_EX | HV_HYPERCALL_FAST_BIT |\n\t\t\t (1 << HV_HYPERCALL_VARHEAD_OFFSET),\n\t\t\t IPI_VECTOR, HV_GENERIC_SET_SPARSE_4K);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ++ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\n\t \n\tmemset(hcall_page, 0, 4096);\n\tipi_ex->vector = IPI_VECTOR;\n\tipi_ex->vp_set.format = HV_GENERIC_SET_SPARSE_4K;\n\tipi_ex->vp_set.valid_bank_mask = 1 << 1;\n\tipi_ex->vp_set.bank_contents[0] = BIT(RECEIVER_VCPU_ID_2 - 64);\n\thyperv_hypercall(HVCALL_SEND_IPI_EX | (1 << HV_HYPERCALL_VARHEAD_OFFSET),\n\t\t\t pgs_gpa, pgs_gpa + 4096);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ++ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\t \n\thyperv_write_xmm_input(&ipi_ex->vp_set.valid_bank_mask, 1);\n\thyperv_hypercall(HVCALL_SEND_IPI_EX | HV_HYPERCALL_FAST_BIT |\n\t\t\t (1 << HV_HYPERCALL_VARHEAD_OFFSET),\n\t\t\t IPI_VECTOR, HV_GENERIC_SET_SPARSE_4K);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ++ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\n\t \n\tmemset(hcall_page, 0, 4096);\n\tipi_ex->vector = IPI_VECTOR;\n\tipi_ex->vp_set.format = HV_GENERIC_SET_SPARSE_4K;\n\tipi_ex->vp_set.valid_bank_mask = 1 << 1 | 1;\n\tipi_ex->vp_set.bank_contents[0] = BIT(RECEIVER_VCPU_ID_1);\n\tipi_ex->vp_set.bank_contents[1] = BIT(RECEIVER_VCPU_ID_2 - 64);\n\thyperv_hypercall(HVCALL_SEND_IPI_EX | (2 << HV_HYPERCALL_VARHEAD_OFFSET),\n\t\t\t pgs_gpa, pgs_gpa + 4096);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ++ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ++ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\t \n\thyperv_write_xmm_input(&ipi_ex->vp_set.valid_bank_mask, 2);\n\thyperv_hypercall(HVCALL_SEND_IPI_EX | HV_HYPERCALL_FAST_BIT |\n\t\t\t (2 << HV_HYPERCALL_VARHEAD_OFFSET),\n\t\t\t IPI_VECTOR, HV_GENERIC_SET_SPARSE_4K);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ++ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ++ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\n\t \n\tmemset(hcall_page, 0, 4096);\n\tipi_ex->vector = IPI_VECTOR;\n\tipi_ex->vp_set.format = HV_GENERIC_SET_ALL;\n\thyperv_hypercall(HVCALL_SEND_IPI_EX, pgs_gpa, pgs_gpa + 4096);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ++ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ++ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\t \n\tipi_ex->vp_set.valid_bank_mask = 0;\n\thyperv_write_xmm_input(&ipi_ex->vp_set.valid_bank_mask, 2);\n\thyperv_hypercall(HVCALL_SEND_IPI_EX | HV_HYPERCALL_FAST_BIT,\n\t\t\t IPI_VECTOR, HV_GENERIC_SET_ALL);\n\tnop_loop();\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_1] == ++ipis_expected[0]);\n\tGUEST_ASSERT(ipis_rcvd[RECEIVER_VCPU_ID_2] == ++ipis_expected[1]);\n\tGUEST_SYNC(stage++);\n\n\tGUEST_DONE();\n}\n\nstatic void *vcpu_thread(void *arg)\n{\n\tstruct kvm_vcpu *vcpu = (struct kvm_vcpu *)arg;\n\tint old, r;\n\n\tr = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &old);\n\tTEST_ASSERT(!r, \"pthread_setcanceltype failed on vcpu_id=%u with errno=%d\",\n\t\t    vcpu->id, r);\n\n\tvcpu_run(vcpu);\n\n\tTEST_FAIL(\"vCPU %u exited unexpectedly\", vcpu->id);\n\n\treturn NULL;\n}\n\nstatic void cancel_join_vcpu_thread(pthread_t thread, struct kvm_vcpu *vcpu)\n{\n\tvoid *retval;\n\tint r;\n\n\tr = pthread_cancel(thread);\n\tTEST_ASSERT(!r, \"pthread_cancel on vcpu_id=%d failed with errno=%d\",\n\t\t    vcpu->id, r);\n\n\tr = pthread_join(thread, &retval);\n\tTEST_ASSERT(!r, \"pthread_join on vcpu_id=%d failed with errno=%d\",\n\t\t    vcpu->id, r);\n\tTEST_ASSERT(retval == PTHREAD_CANCELED,\n\t\t    \"expected retval=%p, got %p\", PTHREAD_CANCELED,\n\t\t    retval);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct kvm_vm *vm;\n\tstruct kvm_vcpu *vcpu[3];\n\tvm_vaddr_t hcall_page;\n\tpthread_t threads[2];\n\tint stage = 1, r;\n\tstruct ucall uc;\n\n\tvm = vm_create_with_one_vcpu(&vcpu[0], sender_guest_code);\n\n\t \n\thcall_page = vm_vaddr_alloc_pages(vm, 2);\n\tmemset(addr_gva2hva(vm, hcall_page), 0x0, 2 * getpagesize());\n\n\tvm_init_descriptor_tables(vm);\n\n\tvcpu[1] = vm_vcpu_add(vm, RECEIVER_VCPU_ID_1, receiver_code);\n\tvcpu_init_descriptor_tables(vcpu[1]);\n\tvcpu_args_set(vcpu[1], 2, hcall_page, addr_gva2gpa(vm, hcall_page));\n\tvcpu_set_msr(vcpu[1], HV_X64_MSR_VP_INDEX, RECEIVER_VCPU_ID_1);\n\tvcpu_set_hv_cpuid(vcpu[1]);\n\n\tvcpu[2] = vm_vcpu_add(vm, RECEIVER_VCPU_ID_2, receiver_code);\n\tvcpu_init_descriptor_tables(vcpu[2]);\n\tvcpu_args_set(vcpu[2], 2, hcall_page, addr_gva2gpa(vm, hcall_page));\n\tvcpu_set_msr(vcpu[2], HV_X64_MSR_VP_INDEX, RECEIVER_VCPU_ID_2);\n\tvcpu_set_hv_cpuid(vcpu[2]);\n\n\tvm_install_exception_handler(vm, IPI_VECTOR, guest_ipi_handler);\n\n\tvcpu_args_set(vcpu[0], 2, hcall_page, addr_gva2gpa(vm, hcall_page));\n\tvcpu_set_hv_cpuid(vcpu[0]);\n\n\tr = pthread_create(&threads[0], NULL, vcpu_thread, vcpu[1]);\n\tTEST_ASSERT(!r, \"pthread_create failed errno=%d\", r);\n\n\tr = pthread_create(&threads[1], NULL, vcpu_thread, vcpu[2]);\n\tTEST_ASSERT(!r, \"pthread_create failed errno=%d\", errno);\n\n\twhile (true) {\n\t\tvcpu_run(vcpu[0]);\n\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu[0], KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu[0], &uc)) {\n\t\tcase UCALL_SYNC:\n\t\t\tTEST_ASSERT(uc.args[1] == stage,\n\t\t\t\t    \"Unexpected stage: %ld (%d expected)\\n\",\n\t\t\t\t    uc.args[1], stage);\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t \n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\n\t\tstage++;\n\t}\n\ndone:\n\tcancel_join_vcpu_thread(threads[0], vcpu[1]);\n\tcancel_join_vcpu_thread(threads[1], vcpu[2]);\n\tkvm_vm_free(vm);\n\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}