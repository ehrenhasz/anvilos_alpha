{
  "module_name": "vmx_invalid_nested_guest_state.c",
  "hash_id": "5381e2839a2eb3fd62a5ddb64eaacfeb69d17dd52a13d57f5c8c40c67d20bd5a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_invalid_nested_guest_state.c",
  "human_readable_source": "\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"kselftest.h\"\n\n#define ARBITRARY_IO_PORT 0x2000\n\nstatic struct kvm_vm *vm;\n\nstatic void l2_guest_code(void)\n{\n\t \n\tasm volatile(\"inb %%dx, %%al\"\n\t\t     : : [port] \"d\" (ARBITRARY_IO_PORT) : \"rax\");\n}\n\nstatic void l1_guest_code(struct vmx_pages *vmx_pages)\n{\n#define L2_GUEST_STACK_SIZE 64\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\n\tGUEST_ASSERT(prepare_for_vmx_operation(vmx_pages));\n\tGUEST_ASSERT(load_vmcs(vmx_pages));\n\n\t \n\tprepare_vmcs(vmx_pages, l2_guest_code,\n\t\t     &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\n\t \n\tGUEST_ASSERT(!(vmreadz(CPU_BASED_VM_EXEC_CONTROL) & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) ||\n\t\t     !(vmreadz(SECONDARY_VM_EXEC_CONTROL) & SECONDARY_EXEC_UNRESTRICTED_GUEST));\n\n\tGUEST_ASSERT(!vmlaunch());\n\n\t \n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_TRIPLE_FAULT);\n\tGUEST_DONE();\n}\n\nint main(int argc, char *argv[])\n{\n\tvm_vaddr_t vmx_pages_gva;\n\tstruct kvm_sregs sregs;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_run *run;\n\tstruct ucall uc;\n\n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, l1_guest_code);\n\n\t \n\tvcpu_alloc_vmx(vm, &vmx_pages_gva);\n\tvcpu_args_set(vcpu, 1, vmx_pages_gva);\n\n\tvcpu_run(vcpu);\n\n\trun = vcpu->run;\n\n\t \n\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\tTEST_ASSERT(run->io.port == ARBITRARY_IO_PORT,\n\t\t    \"Expected IN from port %d from L2, got port %d\",\n\t\t    ARBITRARY_IO_PORT, run->io.port);\n\n\t \n\tmemset(&sregs, 0, sizeof(sregs));\n\tvcpu_sregs_get(vcpu, &sregs);\n\tsregs.tr.unusable = 1;\n\tvcpu_sregs_set(vcpu, &sregs);\n\n\tvcpu_run(vcpu);\n\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_DONE:\n\t\tbreak;\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\tdefault:\n\t\tTEST_FAIL(\"Unexpected ucall: %lu\", uc.cmd);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}