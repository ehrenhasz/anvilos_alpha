{
  "module_name": "monitor_mwait_test.c",
  "hash_id": "a137c0ab6309389ddcdf02e512483390f10b85ac576d6937c2f511494fc1c0a9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/monitor_mwait_test.c",
  "human_readable_source": "\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n#define CPUID_MWAIT (1u << 3)\n\nenum monitor_mwait_testcases {\n\tMWAIT_QUIRK_DISABLED = BIT(0),\n\tMISC_ENABLES_QUIRK_DISABLED = BIT(1),\n\tMWAIT_DISABLED = BIT(2),\n};\n\n \n#define GUEST_ASSERT_MONITOR_MWAIT(insn, testcase, vector)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tbool fault_wanted = ((testcase) & MWAIT_QUIRK_DISABLED) &&\t\\\n\t\t\t    ((testcase) & MWAIT_DISABLED);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (fault_wanted)\t\t\t\t\t\t\\\n\t\t__GUEST_ASSERT((vector) == UD_VECTOR,\t\t\t\\\n\t\t\t       \"Expected #UD on \" insn \" for testcase '0x%x', got '0x%x'\", vector); \\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__GUEST_ASSERT(!(vector),\t\t\t\t\\\n\t\t\t       \"Expected success on \" insn \" for testcase '0x%x', got '0x%x'\", vector); \\\n} while (0)\n\nstatic void guest_monitor_wait(int testcase)\n{\n\tu8 vector;\n\n\tGUEST_SYNC(testcase);\n\n\t \n\tvector = kvm_asm_safe(\"monitor\", \"a\"(guest_monitor_wait), \"c\"(0), \"d\"(0));\n\tGUEST_ASSERT_MONITOR_MWAIT(\"MONITOR\", testcase, vector);\n\n\tvector = kvm_asm_safe(\"mwait\", \"a\"(guest_monitor_wait), \"c\"(0), \"d\"(0));\n\tGUEST_ASSERT_MONITOR_MWAIT(\"MWAIT\", testcase, vector);\n}\n\nstatic void guest_code(void)\n{\n\tguest_monitor_wait(MWAIT_DISABLED);\n\n\tguest_monitor_wait(MWAIT_QUIRK_DISABLED | MWAIT_DISABLED);\n\n\tguest_monitor_wait(MISC_ENABLES_QUIRK_DISABLED | MWAIT_DISABLED);\n\tguest_monitor_wait(MISC_ENABLES_QUIRK_DISABLED);\n\n\tguest_monitor_wait(MISC_ENABLES_QUIRK_DISABLED | MWAIT_QUIRK_DISABLED | MWAIT_DISABLED);\n\tguest_monitor_wait(MISC_ENABLES_QUIRK_DISABLED | MWAIT_QUIRK_DISABLED);\n\n\tGUEST_DONE();\n}\n\nint main(int argc, char *argv[])\n{\n\tuint64_t disabled_quirks;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vm *vm;\n\tstruct ucall uc;\n\tint testcase;\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_DISABLE_QUIRKS2));\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\tvcpu_clear_cpuid_feature(vcpu, X86_FEATURE_MWAIT);\n\n\tvm_init_descriptor_tables(vm);\n\tvcpu_init_descriptor_tables(vcpu);\n\n\twhile (1) {\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_SYNC:\n\t\t\ttestcase = uc.args[1];\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\tgoto done;\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdisabled_quirks = 0;\n\t\tif (testcase & MWAIT_QUIRK_DISABLED)\n\t\t\tdisabled_quirks |= KVM_X86_QUIRK_MWAIT_NEVER_UD_FAULTS;\n\t\tif (testcase & MISC_ENABLES_QUIRK_DISABLED)\n\t\t\tdisabled_quirks |= KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT;\n\t\tvm_enable_cap(vm, KVM_CAP_DISABLE_QUIRKS2, disabled_quirks);\n\n\t\t \n\t\tif (!(testcase & MISC_ENABLES_QUIRK_DISABLED)) {\n\t\t\tTEST_ASSERT(testcase & MWAIT_DISABLED,\n\t\t\t\t    \"Can't toggle CPUID features after running vCPU\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcpu_set_msr(vcpu, MSR_IA32_MISC_ENABLE,\n\t\t\t     (testcase & MWAIT_DISABLED) ? 0 : MSR_IA32_MISC_ENABLE_MWAIT);\n\t}\n\ndone:\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}