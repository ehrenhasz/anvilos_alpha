{
  "module_name": "xapic_state_test.c",
  "hash_id": "35390941e28918aa394f896c0dc7fb6c207e2dac71a1f9e75f13c5cbcaf24fe5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/xapic_state_test.c",
  "human_readable_source": "\n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"apic.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"test_util.h\"\n\nstruct xapic_vcpu {\n\tstruct kvm_vcpu *vcpu;\n\tbool is_x2apic;\n};\n\nstatic void xapic_guest_code(void)\n{\n\tasm volatile(\"cli\");\n\n\txapic_enable();\n\n\twhile (1) {\n\t\tuint64_t val = (u64)xapic_read_reg(APIC_IRR) |\n\t\t\t       (u64)xapic_read_reg(APIC_IRR + 0x10) << 32;\n\n\t\txapic_write_reg(APIC_ICR2, val >> 32);\n\t\txapic_write_reg(APIC_ICR, val);\n\t\tGUEST_SYNC(val);\n\t}\n}\n\nstatic void x2apic_guest_code(void)\n{\n\tasm volatile(\"cli\");\n\n\tx2apic_enable();\n\n\tdo {\n\t\tuint64_t val = x2apic_read_reg(APIC_IRR) |\n\t\t\t       x2apic_read_reg(APIC_IRR + 0x10) << 32;\n\n\t\tx2apic_write_reg(APIC_ICR, val);\n\t\tGUEST_SYNC(val);\n\t} while (1);\n}\n\nstatic void ____test_icr(struct xapic_vcpu *x, uint64_t val)\n{\n\tstruct kvm_vcpu *vcpu = x->vcpu;\n\tstruct kvm_lapic_state xapic;\n\tstruct ucall uc;\n\tuint64_t icr;\n\n\t \n\tvcpu_ioctl(vcpu, KVM_GET_LAPIC, &xapic);\n\t*((u32 *)&xapic.regs[APIC_IRR]) = val;\n\t*((u32 *)&xapic.regs[APIC_IRR + 0x10]) = val >> 32;\n\tvcpu_ioctl(vcpu, KVM_SET_LAPIC, &xapic);\n\n\tvcpu_run(vcpu);\n\tTEST_ASSERT_EQ(get_ucall(vcpu, &uc), UCALL_SYNC);\n\tTEST_ASSERT_EQ(uc.args[1], val);\n\n\tvcpu_ioctl(vcpu, KVM_GET_LAPIC, &xapic);\n\ticr = (u64)(*((u32 *)&xapic.regs[APIC_ICR])) |\n\t      (u64)(*((u32 *)&xapic.regs[APIC_ICR2])) << 32;\n\tif (!x->is_x2apic) {\n\t\tval &= (-1u | (0xffull << (32 + 24)));\n\t\tTEST_ASSERT_EQ(icr, val & ~APIC_ICR_BUSY);\n\t} else {\n\t\tTEST_ASSERT_EQ(icr & ~APIC_ICR_BUSY, val & ~APIC_ICR_BUSY);\n\t}\n}\n\n#define X2APIC_RSVED_BITS_MASK  (GENMASK_ULL(31,20) | \\\n\t\t\t\t GENMASK_ULL(17,16) | \\\n\t\t\t\t GENMASK_ULL(13,13))\n\nstatic void __test_icr(struct xapic_vcpu *x, uint64_t val)\n{\n\tif (x->is_x2apic) {\n\t\t \n\t\tval &= ~X2APIC_RSVED_BITS_MASK;\n\t}\n\t____test_icr(x, val | APIC_ICR_BUSY);\n\t____test_icr(x, val & ~(u64)APIC_ICR_BUSY);\n}\n\nstatic void test_icr(struct xapic_vcpu *x)\n{\n\tstruct kvm_vcpu *vcpu = x->vcpu;\n\tuint64_t icr, i, j;\n\n\ticr = APIC_DEST_SELF | APIC_INT_ASSERT | APIC_DM_FIXED;\n\tfor (i = 0; i <= 0xff; i++)\n\t\t__test_icr(x, icr | i);\n\n\ticr = APIC_INT_ASSERT | APIC_DM_FIXED;\n\tfor (i = 0; i <= 0xff; i++)\n\t\t__test_icr(x, icr | i);\n\n\t \n\ticr = APIC_INT_ASSERT | 0xff;\n\tfor (i = 0; i < 0xff; i++) {\n\t\tif (i == vcpu->id)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < 8; j++)\n\t\t\t__test_icr(x, i << (32 + 24) | icr | (j << 8));\n\t}\n\n\t \n\ticr = APIC_DEST_ALLBUT | APIC_INT_ASSERT;\n\tfor (i = 0; i < 8; i++)\n\t\t__test_icr(x, icr | (i << 8));\n\n\t \n\t__test_icr(x, 0xa5a5a5a5a5a5a5a5 & ~APIC_DM_FIXED_MASK);\n\t__test_icr(x, 0x5a5a5a5a5a5a5a5a & ~APIC_DM_FIXED_MASK);\n\t__test_icr(x, -1ull & ~APIC_DM_FIXED_MASK);\n}\n\nstatic void __test_apic_id(struct kvm_vcpu *vcpu, uint64_t apic_base)\n{\n\tuint32_t apic_id, expected;\n\tstruct kvm_lapic_state xapic;\n\n\tvcpu_set_msr(vcpu, MSR_IA32_APICBASE, apic_base);\n\n\tvcpu_ioctl(vcpu, KVM_GET_LAPIC, &xapic);\n\n\texpected = apic_base & X2APIC_ENABLE ? vcpu->id : vcpu->id << 24;\n\tapic_id = *((u32 *)&xapic.regs[APIC_ID]);\n\n\tTEST_ASSERT(apic_id == expected,\n\t\t    \"APIC_ID not set back to %s format; wanted = %x, got = %x\",\n\t\t    (apic_base & X2APIC_ENABLE) ? \"x2APIC\" : \"xAPIC\",\n\t\t    expected, apic_id);\n}\n\n \nstatic void test_apic_id(void)\n{\n\tconst uint32_t NR_VCPUS = 3;\n\tstruct kvm_vcpu *vcpus[NR_VCPUS];\n\tuint64_t apic_base;\n\tstruct kvm_vm *vm;\n\tint i;\n\n\tvm = vm_create_with_vcpus(NR_VCPUS, NULL, vcpus);\n\tvm_enable_cap(vm, KVM_CAP_X2APIC_API, KVM_X2APIC_API_USE_32BIT_IDS);\n\n\tfor (i = 0; i < NR_VCPUS; i++) {\n\t\tapic_base = vcpu_get_msr(vcpus[i], MSR_IA32_APICBASE);\n\n\t\tTEST_ASSERT(apic_base & MSR_IA32_APICBASE_ENABLE,\n\t\t\t    \"APIC not in ENABLED state at vCPU RESET\");\n\t\tTEST_ASSERT(!(apic_base & X2APIC_ENABLE),\n\t\t\t    \"APIC not in xAPIC mode at vCPU RESET\");\n\n\t\t__test_apic_id(vcpus[i], apic_base);\n\t\t__test_apic_id(vcpus[i], apic_base | X2APIC_ENABLE);\n\t\t__test_apic_id(vcpus[i], apic_base);\n\t}\n\n\tkvm_vm_free(vm);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct xapic_vcpu x = {\n\t\t.vcpu = NULL,\n\t\t.is_x2apic = true,\n\t};\n\tstruct kvm_vm *vm;\n\n\tvm = vm_create_with_one_vcpu(&x.vcpu, x2apic_guest_code);\n\ttest_icr(&x);\n\tkvm_vm_free(vm);\n\n\t \n\tvm = vm_create_with_one_vcpu(&x.vcpu, xapic_guest_code);\n\tx.is_x2apic = false;\n\n\tvcpu_clear_cpuid_feature(x.vcpu, X86_FEATURE_X2APIC);\n\n\tvirt_pg_map(vm, APIC_DEFAULT_GPA, APIC_DEFAULT_GPA);\n\ttest_icr(&x);\n\tkvm_vm_free(vm);\n\n\ttest_apic_id();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}