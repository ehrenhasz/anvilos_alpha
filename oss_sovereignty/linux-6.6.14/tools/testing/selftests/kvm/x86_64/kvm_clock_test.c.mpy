{
  "module_name": "kvm_clock_test.c",
  "hash_id": "1ec61849b9098a9930a6377a5d34aad75f3d2b8c049dcc4aabe2fb842603e361",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/kvm_clock_test.c",
  "human_readable_source": "\n \n#include <asm/kvm_para.h>\n#include <asm/pvclock.h>\n#include <asm/pvclock-abi.h>\n#include <stdint.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\nstruct test_case {\n\tuint64_t kvmclock_base;\n\tint64_t realtime_offset;\n};\n\nstatic struct test_case test_cases[] = {\n\t{ .kvmclock_base = 0 },\n\t{ .kvmclock_base = 180 * NSEC_PER_SEC },\n\t{ .kvmclock_base = 0, .realtime_offset = -180 * NSEC_PER_SEC },\n\t{ .kvmclock_base = 0, .realtime_offset = 180 * NSEC_PER_SEC },\n};\n\n#define GUEST_SYNC_CLOCK(__stage, __val)\t\t\t\\\n\t\tGUEST_SYNC_ARGS(__stage, __val, 0, 0, 0)\n\nstatic void guest_main(vm_paddr_t pvti_pa, struct pvclock_vcpu_time_info *pvti)\n{\n\tint i;\n\n\twrmsr(MSR_KVM_SYSTEM_TIME_NEW, pvti_pa | KVM_MSR_ENABLED);\n\tfor (i = 0; i < ARRAY_SIZE(test_cases); i++)\n\t\tGUEST_SYNC_CLOCK(i, __pvclock_read_cycles(pvti, rdtsc()));\n}\n\n#define EXPECTED_FLAGS (KVM_CLOCK_REALTIME | KVM_CLOCK_HOST_TSC)\n\nstatic inline void assert_flags(struct kvm_clock_data *data)\n{\n\tTEST_ASSERT((data->flags & EXPECTED_FLAGS) == EXPECTED_FLAGS,\n\t\t    \"unexpected clock data flags: %x (want set: %x)\",\n\t\t    data->flags, EXPECTED_FLAGS);\n}\n\nstatic void handle_sync(struct ucall *uc, struct kvm_clock_data *start,\n\t\t\tstruct kvm_clock_data *end)\n{\n\tuint64_t obs, exp_lo, exp_hi;\n\n\tobs = uc->args[2];\n\texp_lo = start->clock;\n\texp_hi = end->clock;\n\n\tassert_flags(start);\n\tassert_flags(end);\n\n\tTEST_ASSERT(exp_lo <= obs && obs <= exp_hi,\n\t\t    \"unexpected kvm-clock value: %\"PRIu64\" expected range: [%\"PRIu64\", %\"PRIu64\"]\",\n\t\t    obs, exp_lo, exp_hi);\n\n\tpr_info(\"kvm-clock value: %\"PRIu64\" expected range [%\"PRIu64\", %\"PRIu64\"]\\n\",\n\t\tobs, exp_lo, exp_hi);\n}\n\nstatic void handle_abort(struct ucall *uc)\n{\n\tREPORT_GUEST_ASSERT(*uc);\n}\n\nstatic void setup_clock(struct kvm_vm *vm, struct test_case *test_case)\n{\n\tstruct kvm_clock_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tdata.clock = test_case->kvmclock_base;\n\tif (test_case->realtime_offset) {\n\t\tstruct timespec ts;\n\t\tint r;\n\n\t\tdata.flags |= KVM_CLOCK_REALTIME;\n\t\tdo {\n\t\t\tr = clock_gettime(CLOCK_REALTIME, &ts);\n\t\t\tif (!r)\n\t\t\t\tbreak;\n\t\t} while (errno == EINTR);\n\n\t\tTEST_ASSERT(!r, \"clock_gettime() failed: %d\\n\", r);\n\n\t\tdata.realtime = ts.tv_sec * NSEC_PER_SEC;\n\t\tdata.realtime += ts.tv_nsec;\n\t\tdata.realtime += test_case->realtime_offset;\n\t}\n\n\tvm_ioctl(vm, KVM_SET_CLOCK, &data);\n}\n\nstatic void enter_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_clock_data start, end;\n\tstruct kvm_vm *vm = vcpu->vm;\n\tstruct ucall uc;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_cases); i++) {\n\t\tsetup_clock(vm, &test_cases[i]);\n\n\t\tvm_ioctl(vm, KVM_GET_CLOCK, &start);\n\n\t\tvcpu_run(vcpu);\n\t\tvm_ioctl(vm, KVM_GET_CLOCK, &end);\n\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_SYNC:\n\t\t\thandle_sync(&uc, &start, &end);\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\thandle_abort(&uc);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tTEST_ASSERT(0, \"unhandled ucall: %ld\\n\", uc.cmd);\n\t\t}\n\t}\n}\n\n#define CLOCKSOURCE_PATH \"/sys/devices/system/clocksource/clocksource0/current_clocksource\"\n\nstatic void check_clocksource(void)\n{\n\tchar *clk_name;\n\tstruct stat st;\n\tFILE *fp;\n\n\tfp = fopen(CLOCKSOURCE_PATH, \"r\");\n\tif (!fp) {\n\t\tpr_info(\"failed to open clocksource file: %d; assuming TSC.\\n\",\n\t\t\terrno);\n\t\treturn;\n\t}\n\n\tif (fstat(fileno(fp), &st)) {\n\t\tpr_info(\"failed to stat clocksource file: %d; assuming TSC.\\n\",\n\t\t\terrno);\n\t\tgoto out;\n\t}\n\n\tclk_name = malloc(st.st_size);\n\tTEST_ASSERT(clk_name, \"failed to allocate buffer to read file\\n\");\n\n\tif (!fgets(clk_name, st.st_size, fp)) {\n\t\tpr_info(\"failed to read clocksource file: %d; assuming TSC.\\n\",\n\t\t\tferror(fp));\n\t\tgoto out;\n\t}\n\n\tTEST_ASSERT(!strncmp(clk_name, \"tsc\\n\", st.st_size),\n\t\t    \"clocksource not supported: %s\", clk_name);\nout:\n\tfclose(fp);\n}\n\nint main(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tvm_vaddr_t pvti_gva;\n\tvm_paddr_t pvti_gpa;\n\tstruct kvm_vm *vm;\n\tint flags;\n\n\tflags = kvm_check_cap(KVM_CAP_ADJUST_CLOCK);\n\tTEST_REQUIRE(flags & KVM_CLOCK_REALTIME);\n\n\tcheck_clocksource();\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_main);\n\n\tpvti_gva = vm_vaddr_alloc(vm, getpagesize(), 0x10000);\n\tpvti_gpa = addr_gva2gpa(vm, pvti_gva);\n\tvcpu_args_set(vcpu, 2, pvti_gpa, pvti_gva);\n\n\tenter_guest(vcpu);\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}