{
  "module_name": "tsc_scaling_sync.c",
  "hash_id": "fb4d3746e8f58eccc4e66debf6ac5c77c6187614bd56057353565a1f31e93051",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/tsc_scaling_sync.c",
  "human_readable_source": "\n \n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n#include <stdint.h>\n#include <time.h>\n#include <sched.h>\n#include <signal.h>\n#include <pthread.h>\n\n#define NR_TEST_VCPUS 20\n\nstatic struct kvm_vm *vm;\npthread_spinlock_t create_lock;\n\n#define TEST_TSC_KHZ    2345678UL\n#define TEST_TSC_OFFSET 200000000\n\nuint64_t tsc_sync;\nstatic void guest_code(void)\n{\n\tuint64_t start_tsc, local_tsc, tmp;\n\n\tstart_tsc = rdtsc();\n\tdo {\n\t\ttmp = READ_ONCE(tsc_sync);\n\t\tlocal_tsc = rdtsc();\n\t\tWRITE_ONCE(tsc_sync, local_tsc);\n\t\tif (unlikely(local_tsc < tmp))\n\t\t\tGUEST_SYNC_ARGS(0, local_tsc, tmp, 0, 0);\n\n\t} while (local_tsc - start_tsc < 5000 * TEST_TSC_KHZ);\n\n\tGUEST_DONE();\n}\n\n\nstatic void *run_vcpu(void *_cpu_nr)\n{\n\tunsigned long vcpu_id = (unsigned long)_cpu_nr;\n\tunsigned long failures = 0;\n\tstatic bool first_cpu_done;\n\tstruct kvm_vcpu *vcpu;\n\n\t \n\tpthread_spin_lock(&create_lock);\n\n\tvcpu = vm_vcpu_add(vm, vcpu_id, guest_code);\n\n\tif (!first_cpu_done) {\n\t\tfirst_cpu_done = true;\n\t\tvcpu_set_msr(vcpu, MSR_IA32_TSC, TEST_TSC_OFFSET);\n\t}\n\n\tpthread_spin_unlock(&create_lock);\n\n\tfor (;;) {\n                struct ucall uc;\n\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n                case UCALL_DONE:\n\t\t\tgoto out;\n\n                case UCALL_SYNC:\n\t\t\tprintf(\"Guest %d sync %lx %lx %ld\\n\", vcpu->id,\n\t\t\t       uc.args[2], uc.args[3], uc.args[2] - uc.args[3]);\n\t\t\tfailures++;\n\t\t\tbreak;\n\n                default:\n                        TEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\t}\n out:\n\treturn (void *)failures;\n}\n\nint main(int argc, char *argv[])\n{\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_VM_TSC_CONTROL));\n\n\tvm = vm_create(NR_TEST_VCPUS);\n\tvm_ioctl(vm, KVM_SET_TSC_KHZ, (void *) TEST_TSC_KHZ);\n\n\tpthread_spin_init(&create_lock, PTHREAD_PROCESS_PRIVATE);\n\tpthread_t cpu_threads[NR_TEST_VCPUS];\n\tunsigned long cpu;\n\tfor (cpu = 0; cpu < NR_TEST_VCPUS; cpu++)\n\t\tpthread_create(&cpu_threads[cpu], NULL, run_vcpu, (void *)cpu);\n\n\tunsigned long failures = 0;\n\tfor (cpu = 0; cpu < NR_TEST_VCPUS; cpu++) {\n\t\tvoid *this_cpu_failures;\n\t\tpthread_join(cpu_threads[cpu], &this_cpu_failures);\n\t\tfailures += (unsigned long)this_cpu_failures;\n\t}\n\n\tTEST_ASSERT(!failures, \"TSC sync failed\");\n\tpthread_spin_destroy(&create_lock);\n\tkvm_vm_free(vm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}