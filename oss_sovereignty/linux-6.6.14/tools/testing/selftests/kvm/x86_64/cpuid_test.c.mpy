{
  "module_name": "cpuid_test.c",
  "hash_id": "757096c46af1975b103d9e8fcd0cd3e3b0869239680b83155613323611492ac1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/cpuid_test.c",
  "human_readable_source": "\n \n#include <asm/kvm_para.h>\n#include <linux/kvm_para.h>\n#include <stdint.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n\n \nstruct {\n\tu32 function;\n\tu32 index;\n} mangled_cpuids[] = {\n\t \n\t{.function = 0xd, .index = 0},\n\t{.function = 0xd, .index = 1},\n};\n\nstatic void test_guest_cpuids(struct kvm_cpuid2 *guest_cpuid)\n{\n\tint i;\n\tu32 eax, ebx, ecx, edx;\n\n\tfor (i = 0; i < guest_cpuid->nent; i++) {\n\t\t__cpuid(guest_cpuid->entries[i].function,\n\t\t\tguest_cpuid->entries[i].index,\n\t\t\t&eax, &ebx, &ecx, &edx);\n\n\t\tGUEST_ASSERT_EQ(eax, guest_cpuid->entries[i].eax);\n\t\tGUEST_ASSERT_EQ(ebx, guest_cpuid->entries[i].ebx);\n\t\tGUEST_ASSERT_EQ(ecx, guest_cpuid->entries[i].ecx);\n\t\tGUEST_ASSERT_EQ(edx, guest_cpuid->entries[i].edx);\n\t}\n\n}\n\nstatic void guest_main(struct kvm_cpuid2 *guest_cpuid)\n{\n\tGUEST_SYNC(1);\n\n\ttest_guest_cpuids(guest_cpuid);\n\n\tGUEST_SYNC(2);\n\n\tGUEST_ASSERT_EQ(this_cpu_property(X86_PROPERTY_MAX_KVM_LEAF), 0x40000001);\n\n\tGUEST_DONE();\n}\n\nstatic bool is_cpuid_mangled(const struct kvm_cpuid_entry2 *entrie)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(mangled_cpuids); i++) {\n\t\tif (mangled_cpuids[i].function == entrie->function &&\n\t\t    mangled_cpuids[i].index == entrie->index)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void compare_cpuids(const struct kvm_cpuid2 *cpuid1,\n\t\t\t   const struct kvm_cpuid2 *cpuid2)\n{\n\tconst struct kvm_cpuid_entry2 *e1, *e2;\n\tint i;\n\n\tTEST_ASSERT(cpuid1->nent == cpuid2->nent,\n\t\t    \"CPUID nent mismatch: %d vs. %d\", cpuid1->nent, cpuid2->nent);\n\n\tfor (i = 0; i < cpuid1->nent; i++) {\n\t\te1 = &cpuid1->entries[i];\n\t\te2 = &cpuid2->entries[i];\n\n\t\tTEST_ASSERT(e1->function == e2->function &&\n\t\t\t    e1->index == e2->index && e1->flags == e2->flags,\n\t\t\t    \"CPUID entries[%d] mismtach: 0x%x.%d.%x vs. 0x%x.%d.%x\\n\",\n\t\t\t    i, e1->function, e1->index, e1->flags,\n\t\t\t    e2->function, e2->index, e2->flags);\n\n\t\tif (is_cpuid_mangled(e1))\n\t\t\tcontinue;\n\n\t\tTEST_ASSERT(e1->eax == e2->eax && e1->ebx == e2->ebx &&\n\t\t\t    e1->ecx == e2->ecx && e1->edx == e2->edx,\n\t\t\t    \"CPUID 0x%x.%x differ: 0x%x:0x%x:0x%x:0x%x vs 0x%x:0x%x:0x%x:0x%x\",\n\t\t\t    e1->function, e1->index,\n\t\t\t    e1->eax, e1->ebx, e1->ecx, e1->edx,\n\t\t\t    e2->eax, e2->ebx, e2->ecx, e2->edx);\n\t}\n}\n\nstatic void run_vcpu(struct kvm_vcpu *vcpu, int stage)\n{\n\tstruct ucall uc;\n\n\tvcpu_run(vcpu);\n\n\tswitch (get_ucall(vcpu, &uc)) {\n\tcase UCALL_SYNC:\n\t\tTEST_ASSERT(!strcmp((const char *)uc.args[0], \"hello\") &&\n\t\t\t    uc.args[1] == stage + 1,\n\t\t\t    \"Stage %d: Unexpected register values vmexit, got %lx\",\n\t\t\t    stage + 1, (ulong)uc.args[1]);\n\t\treturn;\n\tcase UCALL_DONE:\n\t\treturn;\n\tcase UCALL_ABORT:\n\t\tREPORT_GUEST_ASSERT(uc);\n\tdefault:\n\t\tTEST_ASSERT(false, \"Unexpected exit: %s\",\n\t\t\t    exit_reason_str(vcpu->run->exit_reason));\n\t}\n}\n\nstruct kvm_cpuid2 *vcpu_alloc_cpuid(struct kvm_vm *vm, vm_vaddr_t *p_gva, struct kvm_cpuid2 *cpuid)\n{\n\tint size = sizeof(*cpuid) + cpuid->nent * sizeof(cpuid->entries[0]);\n\tvm_vaddr_t gva = vm_vaddr_alloc(vm, size, KVM_UTIL_MIN_VADDR);\n\tstruct kvm_cpuid2 *guest_cpuids = addr_gva2hva(vm, gva);\n\n\tmemcpy(guest_cpuids, cpuid, size);\n\n\t*p_gva = gva;\n\treturn guest_cpuids;\n}\n\nstatic void set_cpuid_after_run(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *ent;\n\tint rc;\n\tu32 eax, ebx, x;\n\n\t \n\trc = __vcpu_set_cpuid(vcpu);\n\tTEST_ASSERT(!rc, \"Setting unmodified CPUID after KVM_RUN failed: %d\", rc);\n\n\t \n\tent = vcpu_get_cpuid_entry(vcpu, 0x7);\n\tebx = ent->ebx;\n\tent->ebx--;\n\trc = __vcpu_set_cpuid(vcpu);\n\tTEST_ASSERT(rc, \"Changing CPU features should fail\");\n\tent->ebx = ebx;\n\n\t \n\tent = vcpu_get_cpuid_entry(vcpu, 0x80000008);\n\teax = ent->eax;\n\tx = eax & 0xff;\n\tent->eax = (eax & ~0xffu) | (x - 1);\n\trc = __vcpu_set_cpuid(vcpu);\n\tTEST_ASSERT(rc, \"Changing MAXPHYADDR should fail\");\n\tent->eax = eax;\n}\n\nstatic void test_get_cpuid2(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid2 *cpuid = allocate_kvm_cpuid2(vcpu->cpuid->nent + 1);\n\tint i, r;\n\n\tvcpu_ioctl(vcpu, KVM_GET_CPUID2, cpuid);\n\tTEST_ASSERT(cpuid->nent == vcpu->cpuid->nent,\n\t\t    \"KVM didn't update nent on success, wanted %u, got %u\\n\",\n\t\t    vcpu->cpuid->nent, cpuid->nent);\n\n\tfor (i = 0; i < vcpu->cpuid->nent; i++) {\n\t\tcpuid->nent = i;\n\t\tr = __vcpu_ioctl(vcpu, KVM_GET_CPUID2, cpuid);\n\t\tTEST_ASSERT(r && errno == E2BIG, KVM_IOCTL_ERROR(KVM_GET_CPUID2, r));\n\t\tTEST_ASSERT(cpuid->nent == i, \"KVM modified nent on failure\");\n\t}\n\tfree(cpuid);\n}\n\nint main(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tvm_vaddr_t cpuid_gva;\n\tstruct kvm_vm *vm;\n\tint stage;\n\n\tvm = vm_create_with_one_vcpu(&vcpu, guest_main);\n\n\tcompare_cpuids(kvm_get_supported_cpuid(), vcpu->cpuid);\n\n\tvcpu_alloc_cpuid(vm, &cpuid_gva, vcpu->cpuid);\n\n\tvcpu_args_set(vcpu, 1, cpuid_gva);\n\n\tfor (stage = 0; stage < 3; stage++)\n\t\trun_vcpu(vcpu, stage);\n\n\tset_cpuid_after_run(vcpu);\n\n\ttest_get_cpuid2(vcpu);\n\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}