{
  "module_name": "vmx_preemption_timer_test.c",
  "hash_id": "90198db27608490412b680a59dd604e3713dd9f1920aa4d0ee696714ef6b9bf4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/vmx_preemption_timer_test.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"vmx.h\"\n\n#define PREEMPTION_TIMER_VALUE\t\t\t100000000ull\n#define PREEMPTION_TIMER_VALUE_THRESHOLD1\t 80000000ull\n\nu32 vmx_pt_rate;\nbool l2_save_restore_done;\nstatic u64 l2_vmx_pt_start;\nvolatile u64 l2_vmx_pt_finish;\n\nunion vmx_basic basic;\nunion vmx_ctrl_msr ctrl_pin_rev;\nunion vmx_ctrl_msr ctrl_exit_rev;\n\nvoid l2_guest_code(void)\n{\n\tu64 vmx_pt_delta;\n\n\tvmcall();\n\tl2_vmx_pt_start = (rdtsc() >> vmx_pt_rate) << vmx_pt_rate;\n\n\t \n\tdo {\n\t\tl2_vmx_pt_finish = rdtsc();\n\t\tvmx_pt_delta = (l2_vmx_pt_finish - l2_vmx_pt_start) >>\n\t\t\t\tvmx_pt_rate;\n\t} while (vmx_pt_delta < PREEMPTION_TIMER_VALUE_THRESHOLD1);\n\n\t \n\tGUEST_SYNC(1);\n\n\tl2_save_restore_done = 1;\n\n\t \n\twhile ((l2_vmx_pt_finish = rdtsc()))\n\t\t;\n}\n\nvoid l1_guest_code(struct vmx_pages *vmx_pages)\n{\n#define L2_GUEST_STACK_SIZE 64\n\tunsigned long l2_guest_stack[L2_GUEST_STACK_SIZE];\n\tu64 l1_vmx_pt_start;\n\tu64 l1_vmx_pt_finish;\n\tu64 l1_tsc_deadline, l2_tsc_deadline;\n\n\tGUEST_ASSERT(vmx_pages->vmcs_gpa);\n\tGUEST_ASSERT(prepare_for_vmx_operation(vmx_pages));\n\tGUEST_ASSERT(load_vmcs(vmx_pages));\n\tGUEST_ASSERT(vmptrstz() == vmx_pages->vmcs_gpa);\n\n\tprepare_vmcs(vmx_pages, l2_guest_code,\n\t\t     &l2_guest_stack[L2_GUEST_STACK_SIZE]);\n\n\t \n\tbasic.val = rdmsr(MSR_IA32_VMX_BASIC);\n\tctrl_pin_rev.val = rdmsr(basic.ctrl ? MSR_IA32_VMX_TRUE_PINBASED_CTLS\n\t\t\t: MSR_IA32_VMX_PINBASED_CTLS);\n\tctrl_exit_rev.val = rdmsr(basic.ctrl ? MSR_IA32_VMX_TRUE_EXIT_CTLS\n\t\t\t: MSR_IA32_VMX_EXIT_CTLS);\n\n\tif (!(ctrl_pin_rev.clr & PIN_BASED_VMX_PREEMPTION_TIMER) ||\n\t    !(ctrl_exit_rev.clr & VM_EXIT_SAVE_VMX_PREEMPTION_TIMER))\n\t\treturn;\n\n\tGUEST_ASSERT(!vmlaunch());\n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_VMCALL);\n\tvmwrite(GUEST_RIP, vmreadz(GUEST_RIP) + vmreadz(VM_EXIT_INSTRUCTION_LEN));\n\n\t \n\tGUEST_ASSERT(!vmwrite(PIN_BASED_VM_EXEC_CONTROL,\n\t\t\t      vmreadz(PIN_BASED_VM_EXEC_CONTROL) |\n\t\t\t      PIN_BASED_VMX_PREEMPTION_TIMER));\n\n\tGUEST_ASSERT(!vmwrite(VMX_PREEMPTION_TIMER_VALUE,\n\t\t\t      PREEMPTION_TIMER_VALUE));\n\n\tvmx_pt_rate = rdmsr(MSR_IA32_VMX_MISC) & 0x1F;\n\n\tl2_save_restore_done = 0;\n\n\tl1_vmx_pt_start = (rdtsc() >> vmx_pt_rate) << vmx_pt_rate;\n\n\tGUEST_ASSERT(!vmresume());\n\n\tl1_vmx_pt_finish = rdtsc();\n\n\t \n\tGUEST_ASSERT(l2_save_restore_done);\n\n\t \n\tGUEST_ASSERT(vmreadz(VM_EXIT_REASON) == EXIT_REASON_PREEMPTION_TIMER);\n\n\tl1_tsc_deadline = l1_vmx_pt_start +\n\t\t(PREEMPTION_TIMER_VALUE << vmx_pt_rate);\n\n\tl2_tsc_deadline = l2_vmx_pt_start +\n\t\t(PREEMPTION_TIMER_VALUE << vmx_pt_rate);\n\n\t \n\tGUEST_SYNC_ARGS(2, l1_vmx_pt_finish, l1_tsc_deadline,\n\t\tl2_vmx_pt_finish, l2_tsc_deadline);\n}\n\nvoid guest_code(struct vmx_pages *vmx_pages)\n{\n\tif (vmx_pages)\n\t\tl1_guest_code(vmx_pages);\n\n\tGUEST_DONE();\n}\n\nint main(int argc, char *argv[])\n{\n\tvm_vaddr_t vmx_pages_gva = 0;\n\n\tstruct kvm_regs regs1, regs2;\n\tstruct kvm_vm *vm;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_x86_state *state;\n\tstruct ucall uc;\n\tint stage;\n\n\t \n\tTEST_REQUIRE(kvm_cpu_has(X86_FEATURE_VMX));\n\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_NESTED_STATE));\n\n\t \n\tvm = vm_create_with_one_vcpu(&vcpu, guest_code);\n\n\tvcpu_regs_get(vcpu, &regs1);\n\n\tvcpu_alloc_vmx(vm, &vmx_pages_gva);\n\tvcpu_args_set(vcpu, 1, vmx_pages_gva);\n\n\tfor (stage = 1;; stage++) {\n\t\tvcpu_run(vcpu);\n\t\tTEST_ASSERT_KVM_EXIT_REASON(vcpu, KVM_EXIT_IO);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\t\t \n\t\tcase UCALL_SYNC:\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tTEST_FAIL(\"Unknown ucall %lu\", uc.cmd);\n\t\t}\n\n\t\t \n\t\tTEST_ASSERT(!strcmp((const char *)uc.args[0], \"hello\") &&\n\t\t\t    uc.args[1] == stage, \"Stage %d: Unexpected register values vmexit, got %lx\",\n\t\t\t    stage, (ulong)uc.args[1]);\n\t\t \n\t\tif (stage == 2) {\n\n\t\t\tpr_info(\"Stage %d: L1 PT expiry TSC (%lu) , L1 TSC deadline (%lu)\\n\",\n\t\t\t\tstage, uc.args[2], uc.args[3]);\n\n\t\t\tpr_info(\"Stage %d: L2 PT expiry TSC (%lu) , L2 TSC deadline (%lu)\\n\",\n\t\t\t\tstage, uc.args[4], uc.args[5]);\n\n\t\t\tTEST_ASSERT(uc.args[2] >= uc.args[3],\n\t\t\t\t\"Stage %d: L1 PT expiry TSC (%lu) < L1 TSC deadline (%lu)\",\n\t\t\t\tstage, uc.args[2], uc.args[3]);\n\n\t\t\tTEST_ASSERT(uc.args[4] < uc.args[5],\n\t\t\t\t\"Stage %d: L2 PT expiry TSC (%lu) > L2 TSC deadline (%lu)\",\n\t\t\t\tstage, uc.args[4], uc.args[5]);\n\t\t}\n\n\t\tstate = vcpu_save_state(vcpu);\n\t\tmemset(&regs1, 0, sizeof(regs1));\n\t\tvcpu_regs_get(vcpu, &regs1);\n\n\t\tkvm_vm_release(vm);\n\n\t\t \n\t\tvcpu = vm_recreate_with_one_vcpu(vm);\n\t\tvcpu_load_state(vcpu, state);\n\t\tkvm_x86_state_cleanup(state);\n\n\t\tmemset(&regs2, 0, sizeof(regs2));\n\t\tvcpu_regs_get(vcpu, &regs2);\n\t\tTEST_ASSERT(!memcmp(&regs1, &regs2, sizeof(regs2)),\n\t\t\t    \"Unexpected register values after vcpu_load_state; rdi: %lx rsi: %lx\",\n\t\t\t    (ulong) regs2.rdi, (ulong) regs2.rsi);\n\t}\n\ndone:\n\tkvm_vm_free(vm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}