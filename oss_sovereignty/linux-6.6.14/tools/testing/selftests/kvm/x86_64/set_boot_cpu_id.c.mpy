{
  "module_name": "set_boot_cpu_id.c",
  "hash_id": "a386b2e04bcbf47508fd6414c0beb728abae07780386cc842abd31eb2b42459c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kvm/x86_64/set_boot_cpu_id.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE  \n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n\n#include \"test_util.h\"\n#include \"kvm_util.h\"\n#include \"processor.h\"\n#include \"apic.h\"\n\nstatic void guest_bsp_vcpu(void *arg)\n{\n\tGUEST_SYNC(1);\n\n\tGUEST_ASSERT_NE(get_bsp_flag(), 0);\n\n\tGUEST_DONE();\n}\n\nstatic void guest_not_bsp_vcpu(void *arg)\n{\n\tGUEST_SYNC(1);\n\n\tGUEST_ASSERT_EQ(get_bsp_flag(), 0);\n\n\tGUEST_DONE();\n}\n\nstatic void test_set_bsp_busy(struct kvm_vcpu *vcpu, const char *msg)\n{\n\tint r = __vm_ioctl(vcpu->vm, KVM_SET_BOOT_CPU_ID,\n\t\t\t   (void *)(unsigned long)vcpu->id);\n\n\tTEST_ASSERT(r == -1 && errno == EBUSY, \"KVM_SET_BOOT_CPU_ID set %s\", msg);\n}\n\nstatic void run_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct ucall uc;\n\tint stage;\n\n\tfor (stage = 0; stage < 2; stage++) {\n\n\t\tvcpu_run(vcpu);\n\n\t\tswitch (get_ucall(vcpu, &uc)) {\n\t\tcase UCALL_SYNC:\n\t\t\tTEST_ASSERT(!strcmp((const char *)uc.args[0], \"hello\") &&\n\t\t\t\t\tuc.args[1] == stage + 1,\n\t\t\t\t\t\"Stage %d: Unexpected register values vmexit, got %lx\",\n\t\t\t\t\tstage + 1, (ulong)uc.args[1]);\n\t\t\ttest_set_bsp_busy(vcpu, \"while running vm\");\n\t\t\tbreak;\n\t\tcase UCALL_DONE:\n\t\t\tTEST_ASSERT(stage == 1,\n\t\t\t\t\t\"Expected GUEST_DONE in stage 2, got stage %d\",\n\t\t\t\t\tstage);\n\t\t\tbreak;\n\t\tcase UCALL_ABORT:\n\t\t\tREPORT_GUEST_ASSERT(uc);\n\t\tdefault:\n\t\t\tTEST_ASSERT(false, \"Unexpected exit: %s\",\n\t\t\t\t    exit_reason_str(vcpu->run->exit_reason));\n\t\t}\n\t}\n}\n\nstatic struct kvm_vm *create_vm(uint32_t nr_vcpus, uint32_t bsp_vcpu_id,\n\t\t\t\tstruct kvm_vcpu *vcpus[])\n{\n\tstruct kvm_vm *vm;\n\tuint32_t i;\n\n\tvm = vm_create(nr_vcpus);\n\n\tvm_ioctl(vm, KVM_SET_BOOT_CPU_ID, (void *)(unsigned long)bsp_vcpu_id);\n\n\tfor (i = 0; i < nr_vcpus; i++)\n\t\tvcpus[i] = vm_vcpu_add(vm, i, i == bsp_vcpu_id ? guest_bsp_vcpu :\n\t\t\t\t\t\t\t\t guest_not_bsp_vcpu);\n\treturn vm;\n}\n\nstatic void run_vm_bsp(uint32_t bsp_vcpu_id)\n{\n\tstruct kvm_vcpu *vcpus[2];\n\tstruct kvm_vm *vm;\n\n\tvm = create_vm(ARRAY_SIZE(vcpus), bsp_vcpu_id, vcpus);\n\n\trun_vcpu(vcpus[0]);\n\trun_vcpu(vcpus[1]);\n\n\tkvm_vm_free(vm);\n}\n\nstatic void check_set_bsp_busy(void)\n{\n\tstruct kvm_vcpu *vcpus[2];\n\tstruct kvm_vm *vm;\n\n\tvm = create_vm(ARRAY_SIZE(vcpus), 0, vcpus);\n\n\ttest_set_bsp_busy(vcpus[1], \"after adding vcpu\");\n\n\trun_vcpu(vcpus[0]);\n\trun_vcpu(vcpus[1]);\n\n\ttest_set_bsp_busy(vcpus[1], \"to a terminated vcpu\");\n\n\tkvm_vm_free(vm);\n}\n\nint main(int argc, char *argv[])\n{\n\tTEST_REQUIRE(kvm_has_cap(KVM_CAP_SET_BOOT_CPU_ID));\n\n\trun_vm_bsp(0);\n\trun_vm_bsp(1);\n\trun_vm_bsp(0);\n\n\tcheck_set_bsp_busy();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}