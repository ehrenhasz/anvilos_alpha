{
  "module_name": "ir_loopback.c",
  "hash_id": "08f85c1dacbc3c073db033471df3211753d77b3def2ae03811ca0a164b2108f0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ir/ir_loopback.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n#include <linux/lirc.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <poll.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"../kselftest.h\"\n\n#define TEST_SCANCODES\t10\n#define SYSFS_PATH_MAX 256\n#define DNAME_PATH_MAX 256\n\n \n#if RC_PROTO_MAX < 26\n#define RC_PROTO_RCMM12 24\n#define RC_PROTO_RCMM24 25\n#define RC_PROTO_RCMM32 26\n#endif\n\nstatic const struct {\n\tenum rc_proto proto;\n\tconst char *name;\n\tunsigned int mask;\n\tconst char *decoder;\n} protocols[] = {\n\t{ RC_PROTO_RC5, \"rc-5\", 0x1f7f, \"rc-5\" },\n\t{ RC_PROTO_RC5X_20, \"rc-5x-20\", 0x1f7f3f, \"rc-5\" },\n\t{ RC_PROTO_RC5_SZ, \"rc-5-sz\", 0x2fff, \"rc-5-sz\" },\n\t{ RC_PROTO_JVC, \"jvc\", 0xffff, \"jvc\" },\n\t{ RC_PROTO_SONY12, \"sony-12\", 0x1f007f, \"sony\" },\n\t{ RC_PROTO_SONY15, \"sony-15\", 0xff007f, \"sony\" },\n\t{ RC_PROTO_SONY20, \"sony-20\", 0x1fff7f, \"sony\" },\n\t{ RC_PROTO_NEC, \"nec\", 0xffff, \"nec\" },\n\t{ RC_PROTO_NECX, \"nec-x\", 0xffffff, \"nec\" },\n\t{ RC_PROTO_NEC32, \"nec-32\", 0xffffffff, \"nec\" },\n\t{ RC_PROTO_SANYO, \"sanyo\", 0x1fffff, \"sanyo\" },\n\t{ RC_PROTO_RC6_0, \"rc-6-0\", 0xffff, \"rc-6\" },\n\t{ RC_PROTO_RC6_6A_20, \"rc-6-6a-20\", 0xfffff, \"rc-6\" },\n\t{ RC_PROTO_RC6_6A_24, \"rc-6-6a-24\", 0xffffff, \"rc-6\" },\n\t{ RC_PROTO_RC6_6A_32, \"rc-6-6a-32\", 0xffffffff, \"rc-6\" },\n\t{ RC_PROTO_RC6_MCE, \"rc-6-mce\", 0x00007fff, \"rc-6\" },\n\t{ RC_PROTO_SHARP, \"sharp\", 0x1fff, \"sharp\" },\n\t{ RC_PROTO_IMON, \"imon\", 0x7fffffff, \"imon\" },\n\t{ RC_PROTO_RCMM12, \"rcmm-12\", 0x00000fff, \"rc-mm\" },\n\t{ RC_PROTO_RCMM24, \"rcmm-24\", 0x00ffffff, \"rc-mm\" },\n\t{ RC_PROTO_RCMM32, \"rcmm-32\", 0xffffffff, \"rc-mm\" },\n};\n\nint lirc_open(const char *rc)\n{\n\tstruct dirent *dent;\n\tchar buf[SYSFS_PATH_MAX + DNAME_PATH_MAX];\n\tDIR *d;\n\tint fd;\n\n\tsnprintf(buf, sizeof(buf), \"/sys/class/rc/%s\", rc);\n\n\td = opendir(buf);\n\tif (!d)\n\t\tksft_exit_fail_msg(\"cannot open %s: %m\\n\", buf);\n\n\twhile ((dent = readdir(d)) != NULL) {\n\t\tif (!strncmp(dent->d_name, \"lirc\", 4)) {\n\t\t\tsnprintf(buf, sizeof(buf), \"/dev/%s\", dent->d_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!dent)\n\t\tksft_exit_skip(\"cannot find lirc device for %s\\n\", rc);\n\n\tclosedir(d);\n\n\tfd = open(buf, O_RDWR | O_NONBLOCK);\n\tif (fd == -1)\n\t\tksft_exit_fail_msg(\"cannot open: %s: %m\\n\", buf);\n\n\treturn fd;\n}\n\nint main(int argc, char **argv)\n{\n\tunsigned int mode;\n\tchar buf[100];\n\tint rlircfd, wlircfd, protocolfd, i, n;\n\n\tsrand(time(NULL));\n\n\tif (argc != 3)\n\t\tksft_exit_fail_msg(\"Usage: %s <write rcN> <read rcN>\\n\",\n\t\t\t\t   argv[0]);\n\n\trlircfd = lirc_open(argv[2]);\n\tmode = LIRC_MODE_SCANCODE;\n\tif (ioctl(rlircfd, LIRC_SET_REC_MODE, &mode))\n\t\tksft_exit_fail_msg(\"failed to set scancode rec mode %s: %m\\n\",\n\t\t\t\t   argv[2]);\n\n\twlircfd = lirc_open(argv[1]);\n\tif (ioctl(wlircfd, LIRC_SET_SEND_MODE, &mode))\n\t\tksft_exit_fail_msg(\"failed to set scancode send mode %s: %m\\n\",\n\t\t\t\t   argv[1]);\n\n\tsnprintf(buf, sizeof(buf), \"/sys/class/rc/%s/protocols\", argv[2]);\n\tprotocolfd = open(buf, O_WRONLY);\n\tif (protocolfd == -1)\n\t\tksft_exit_fail_msg(\"failed to open %s: %m\\n\", buf);\n\n\tprintf(\"Sending IR on %s and receiving IR on %s.\\n\", argv[1], argv[2]);\n\n\tfor (i = 0; i < ARRAY_SIZE(protocols); i++) {\n\t\tif (write(protocolfd, protocols[i].decoder,\n\t\t\t  strlen(protocols[i].decoder)) == -1)\n\t\t\tksft_exit_fail_msg(\"failed to set write decoder\\n\");\n\n\t\tprintf(\"Testing protocol %s for decoder %s (%d/%d)...\\n\",\n\t\t       protocols[i].name, protocols[i].decoder,\n\t\t       i + 1, (int)ARRAY_SIZE(protocols));\n\n\t\tfor (n = 0; n < TEST_SCANCODES; n++) {\n\t\t\tunsigned int scancode = rand() & protocols[i].mask;\n\t\t\tunsigned int rc_proto = protocols[i].proto;\n\n\t\t\tif (rc_proto == RC_PROTO_RC6_MCE)\n\t\t\t\tscancode |= 0x800f0000;\n\n\t\t\tif (rc_proto == RC_PROTO_NECX &&\n\t\t\t    (((scancode >> 16) ^ ~(scancode >> 8)) & 0xff) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (rc_proto == RC_PROTO_NEC32 &&\n\t\t\t    (((scancode >> 8) ^ ~scancode) & 0xff) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (rc_proto == RC_PROTO_RCMM32 &&\n\t\t\t    (scancode & 0x000c0000) != 0x000c0000 &&\n\t\t\t    scancode & 0x00008000)\n\t\t\t\tcontinue;\n\n\t\t\tstruct lirc_scancode lsc = {\n\t\t\t\t.rc_proto = rc_proto,\n\t\t\t\t.scancode = scancode\n\t\t\t};\n\n\t\t\tprintf(\"Testing scancode:%x\\n\", scancode);\n\n\t\t\twhile (write(wlircfd, &lsc, sizeof(lsc)) < 0) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tksft_exit_fail_msg(\"failed to send ir: %m\\n\");\n\t\t\t}\n\n\t\t\tstruct pollfd pfd = { .fd = rlircfd, .events = POLLIN };\n\t\t\tstruct lirc_scancode lsc2;\n\n\t\t\tpoll(&pfd, 1, 1000);\n\n\t\t\tbool decoded = true;\n\n\t\t\twhile (read(rlircfd, &lsc2, sizeof(lsc2)) < 0) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tksft_test_result_error(\"no scancode decoded: %m\\n\");\n\t\t\t\tdecoded = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!decoded)\n\t\t\t\tcontinue;\n\n\t\t\tif (lsc.rc_proto != lsc2.rc_proto)\n\t\t\t\tksft_test_result_error(\"decoded protocol is different: %d\\n\",\n\t\t\t\t\t\t       lsc2.rc_proto);\n\n\t\t\telse if (lsc.scancode != lsc2.scancode)\n\t\t\t\tksft_test_result_error(\"decoded scancode is different: %llx\\n\",\n\t\t\t\t\t\t       lsc2.scancode);\n\t\t\telse\n\t\t\t\tksft_inc_pass_cnt();\n\t\t}\n\n\t\tprintf(\"OK\\n\");\n\t}\n\n\tclose(rlircfd);\n\tclose(wlircfd);\n\tclose(protocolfd);\n\n\tif (ksft_get_fail_cnt() > 0)\n\t\tksft_exit_fail();\n\telse\n\t\tksft_exit_pass();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}