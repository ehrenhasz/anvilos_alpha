{
  "module_name": "test_encl.c",
  "hash_id": "9b348af13e9eec48a905c36e1fb141c0ebf0bb4f8f22929f2fe2605a0e3b531c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sgx/test_encl.c",
  "human_readable_source": "\n \n\n#include <stddef.h>\n#include \"defines.h\"\n\n \nstatic uint8_t encl_buffer[8192] = { 1 };\n\nenum sgx_enclu_function {\n\tEACCEPT = 0x5,\n\tEMODPE = 0x6,\n};\n\nstatic void do_encl_emodpe(void *_op)\n{\n\tstruct sgx_secinfo secinfo __aligned(sizeof(struct sgx_secinfo)) = {0};\n\tstruct encl_op_emodpe *op = _op;\n\n\tsecinfo.flags = op->flags;\n\n\tasm volatile(\".byte 0x0f, 0x01, 0xd7\"\n\t\t\t\t:  \n\t\t\t\t: \"a\" (EMODPE),\n\t\t\t\t  \"b\" (&secinfo),\n\t\t\t\t  \"c\" (op->epc_addr)\n\t\t\t\t: \"memory\"  );\n}\n\nstatic void do_encl_eaccept(void *_op)\n{\n\tstruct sgx_secinfo secinfo __aligned(sizeof(struct sgx_secinfo)) = {0};\n\tstruct encl_op_eaccept *op = _op;\n\tint rax;\n\n\tsecinfo.flags = op->flags;\n\n\tasm volatile(\".byte 0x0f, 0x01, 0xd7\"\n\t\t\t\t: \"=a\" (rax)\n\t\t\t\t: \"a\" (EACCEPT),\n\t\t\t\t  \"b\" (&secinfo),\n\t\t\t\t  \"c\" (op->epc_addr)\n\t\t\t\t: \"memory\"  );\n\n\top->ret = rax;\n}\n\nstatic void *memcpy(void *dest, const void *src, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++)\n\t\t((char *)dest)[i] = ((char *)src)[i];\n\n\treturn dest;\n}\n\nstatic void *memset(void *dest, int c, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++)\n\t\t((char *)dest)[i] = c;\n\n\treturn dest;\n}\n\nstatic void do_encl_init_tcs_page(void *_op)\n{\n\tstruct encl_op_init_tcs_page *op = _op;\n\tvoid *tcs = (void *)op->tcs_page;\n\tuint32_t val_32;\n\n\tmemset(tcs, 0, 16);\t\t\t \n\tmemcpy(tcs + 16, &op->ssa, 8);\t\t \n\tmemset(tcs + 24, 0, 4);\t\t\t \n\tval_32 = 1;\n\tmemcpy(tcs + 28, &val_32, 4);\t\t \n\tmemcpy(tcs + 32, &op->entry, 8);\t \n\tmemset(tcs + 40, 0, 24);\t\t \n\tval_32 = 0xFFFFFFFF;\n\tmemcpy(tcs + 64, &val_32, 4);\t\t \n\tmemcpy(tcs + 68, &val_32, 4);\t\t \n\tmemset(tcs + 72, 0, 4024);\t\t \n}\n\nstatic void do_encl_op_put_to_buf(void *op)\n{\n\tstruct encl_op_put_to_buf *op2 = op;\n\n\tmemcpy(&encl_buffer[0], &op2->value, 8);\n}\n\nstatic void do_encl_op_get_from_buf(void *op)\n{\n\tstruct encl_op_get_from_buf *op2 = op;\n\n\tmemcpy(&op2->value, &encl_buffer[0], 8);\n}\n\nstatic void do_encl_op_put_to_addr(void *_op)\n{\n\tstruct encl_op_put_to_addr *op = _op;\n\n\tmemcpy((void *)op->addr, &op->value, 8);\n}\n\nstatic void do_encl_op_get_from_addr(void *_op)\n{\n\tstruct encl_op_get_from_addr *op = _op;\n\n\tmemcpy(&op->value, (void *)op->addr, 8);\n}\n\nstatic void do_encl_op_nop(void *_op)\n{\n\n}\n\nvoid encl_body(void *rdi,  void *rsi)\n{\n\tconst void (*encl_op_array[ENCL_OP_MAX])(void *) = {\n\t\tdo_encl_op_put_to_buf,\n\t\tdo_encl_op_get_from_buf,\n\t\tdo_encl_op_put_to_addr,\n\t\tdo_encl_op_get_from_addr,\n\t\tdo_encl_op_nop,\n\t\tdo_encl_eaccept,\n\t\tdo_encl_emodpe,\n\t\tdo_encl_init_tcs_page,\n\t};\n\n\tstruct encl_op_header *op = (struct encl_op_header *)rdi;\n\n\tif (op->type < ENCL_OP_MAX)\n\t\t(*encl_op_array[op->type])(op);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}