{
  "module_name": "test_encl_bootstrap.S",
  "hash_id": "580de8308a725c40ddb90437f319ab4c4d6bfa444edd0e7615bf2192be4c86b0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sgx/test_encl_bootstrap.S",
  "human_readable_source": " \n \n\n\t.macro ENCLU\n\t.byte 0x0f, 0x01, 0xd7\n\t.endm\n\n\t.section \".tcs\", \"aw\"\n\t.balign\t4096\n\n\t.fill\t1, 8, 0\t\t\t# STATE (set by CPU)\n\t.fill\t1, 8, 0\t\t\t# FLAGS\n\t.quad\tencl_ssa_tcs1\t\t# OSSA\n\t.fill\t1, 4, 0\t\t\t# CSSA (set by CPU)\n\t.fill\t1, 4, 1\t\t\t# NSSA\n\t.quad\tencl_entry\t\t# OENTRY\n\t.fill\t1, 8, 0\t\t\t# AEP (set by EENTER and ERESUME)\n\t.fill\t1, 8, 0\t\t\t# OFSBASE\n\t.fill\t1, 8, 0\t\t\t# OGSBASE\n\t.fill\t1, 4, 0xFFFFFFFF \t# FSLIMIT\n\t.fill\t1, 4, 0xFFFFFFFF\t# GSLIMIT\n\t.fill\t4024, 1, 0\t\t# Reserved\n\n\t# TCS2\n\t.fill\t1, 8, 0\t\t\t# STATE (set by CPU)\n\t.fill\t1, 8, 0\t\t\t# FLAGS\n\t.quad\tencl_ssa_tcs2\t\t# OSSA\n\t.fill\t1, 4, 0\t\t\t# CSSA (set by CPU)\n\t.fill\t1, 4, 1\t\t\t# NSSA\n\t.quad\tencl_entry\t\t# OENTRY\n\t.fill\t1, 8, 0\t\t\t# AEP (set by EENTER and ERESUME)\n\t.fill\t1, 8, 0\t\t\t# OFSBASE\n\t.fill\t1, 8, 0\t\t\t# OGSBASE\n\t.fill\t1, 4, 0xFFFFFFFF \t# FSLIMIT\n\t.fill\t1, 4, 0xFFFFFFFF\t# GSLIMIT\n\t.fill\t4024, 1, 0\t\t# Reserved\n\n\t.text\n\nencl_entry:\n\t# RBX contains the base address for TCS, which is the first address\n\t# inside the enclave for TCS #1 and one page into the enclave for\n\t# TCS #2. By adding the value of encl_stack to it, we get\n\t# the absolute address for the stack.\n\tlea\t(encl_stack)(%rbx), %rax\n\tjmp encl_entry_core\nencl_dyn_entry:\n\t# Entry point for dynamically created TCS page expected to follow\n\t# its stack directly.\n\tlea -1(%rbx), %rax\nencl_entry_core:\n\txchg\t%rsp, %rax\n\tpush\t%rax\n\n\tpush\t%rcx # push the address after EENTER\n\tpush\t%rbx # push the enclave base address\n\n\tcall\tencl_body\n\n\tpop\t%rbx # pop the enclave base address\n\n\t \n\txor     %rcx, %rcx\n\txor     %rdx, %rdx\n\txor     %rdi, %rdi\n\txor     %rsi, %rsi\n\txor     %r8, %r8\n\txor     %r9, %r9\n\txor     %r10, %r10\n\txor     %r11, %r11\n\n\t# Reset status flags.\n\tadd     %rdx, %rdx # OF = SF = AF = CF = 0; ZF = PF = 1\n\n\t# Prepare EEXIT target by popping the address of the instruction after\n\t# EENTER to RBX.\n\tpop\t%rbx\n\n\t# Restore the caller stack.\n\tpop\t%rax\n\tmov\t%rax, %rsp\n\n\t# EEXIT\n\tmov\t$4, %rax\n\tenclu\n\n\t.section \".data\", \"aw\"\n\nencl_ssa_tcs1:\n\t.space 4096\nencl_ssa_tcs2:\n\t.space 4096\n\n\t.balign 4096\n\t# Stack of TCS #1\n\t.space 4096\nencl_stack:\n\t.balign 4096\n\t# Stack of TCS #2\n\t.space 4096\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}