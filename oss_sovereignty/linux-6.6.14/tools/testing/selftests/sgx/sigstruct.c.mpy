{
  "module_name": "sigstruct.c",
  "hash_id": "74371d3cf3afdb4a6cabd48f41c59940d1dd2196379afbba409b129b3649885b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sgx/sigstruct.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <assert.h>\n#include <getopt.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <openssl/err.h>\n#include <openssl/pem.h>\n#include \"defines.h\"\n#include \"main.h\"\n\n \n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n\nstruct q1q2_ctx {\n\tBN_CTX *bn_ctx;\n\tBIGNUM *m;\n\tBIGNUM *s;\n\tBIGNUM *q1;\n\tBIGNUM *qr;\n\tBIGNUM *q2;\n};\n\nstatic void free_q1q2_ctx(struct q1q2_ctx *ctx)\n{\n\tBN_CTX_free(ctx->bn_ctx);\n\tBN_free(ctx->m);\n\tBN_free(ctx->s);\n\tBN_free(ctx->q1);\n\tBN_free(ctx->qr);\n\tBN_free(ctx->q2);\n}\n\nstatic bool alloc_q1q2_ctx(const uint8_t *s, const uint8_t *m,\n\t\t\t   struct q1q2_ctx *ctx)\n{\n\tctx->bn_ctx = BN_CTX_new();\n\tctx->s = BN_bin2bn(s, SGX_MODULUS_SIZE, NULL);\n\tctx->m = BN_bin2bn(m, SGX_MODULUS_SIZE, NULL);\n\tctx->q1 = BN_new();\n\tctx->qr = BN_new();\n\tctx->q2 = BN_new();\n\n\tif (!ctx->bn_ctx || !ctx->s || !ctx->m || !ctx->q1 || !ctx->qr ||\n\t    !ctx->q2) {\n\t\tfree_q1q2_ctx(ctx);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void reverse_bytes(void *data, int length)\n{\n\tint i = 0;\n\tint j = length - 1;\n\tuint8_t temp;\n\tuint8_t *ptr = data;\n\n\twhile (i < j) {\n\t\ttemp = ptr[i];\n\t\tptr[i] = ptr[j];\n\t\tptr[j] = temp;\n\t\ti++;\n\t\tj--;\n\t}\n}\n\nstatic bool calc_q1q2(const uint8_t *s, const uint8_t *m, uint8_t *q1,\n\t\t      uint8_t *q2)\n{\n\tstruct q1q2_ctx ctx;\n\tint len;\n\n\tif (!alloc_q1q2_ctx(s, m, &ctx)) {\n\t\tfprintf(stderr, \"Not enough memory for Q1Q2 calculation\\n\");\n\t\treturn false;\n\t}\n\n\tif (!BN_mul(ctx.q1, ctx.s, ctx.s, ctx.bn_ctx))\n\t\tgoto out;\n\n\tif (!BN_div(ctx.q1, ctx.qr, ctx.q1, ctx.m, ctx.bn_ctx))\n\t\tgoto out;\n\n\tif (BN_num_bytes(ctx.q1) > SGX_MODULUS_SIZE) {\n\t\tfprintf(stderr, \"Too large Q1 %d bytes\\n\",\n\t\t\tBN_num_bytes(ctx.q1));\n\t\tgoto out;\n\t}\n\n\tif (!BN_mul(ctx.q2, ctx.s, ctx.qr, ctx.bn_ctx))\n\t\tgoto out;\n\n\tif (!BN_div(ctx.q2, NULL, ctx.q2, ctx.m, ctx.bn_ctx))\n\t\tgoto out;\n\n\tif (BN_num_bytes(ctx.q2) > SGX_MODULUS_SIZE) {\n\t\tfprintf(stderr, \"Too large Q2 %d bytes\\n\",\n\t\t\tBN_num_bytes(ctx.q2));\n\t\tgoto out;\n\t}\n\n\tlen = BN_bn2bin(ctx.q1, q1);\n\treverse_bytes(q1, len);\n\tlen = BN_bn2bin(ctx.q2, q2);\n\treverse_bytes(q2, len);\n\n\tfree_q1q2_ctx(&ctx);\n\treturn true;\nout:\n\tfree_q1q2_ctx(&ctx);\n\treturn false;\n}\n\nstruct sgx_sigstruct_payload {\n\tstruct sgx_sigstruct_header header;\n\tstruct sgx_sigstruct_body body;\n};\n\nstatic bool check_crypto_errors(void)\n{\n\tint err;\n\tbool had_errors = false;\n\tconst char *filename;\n\tint line;\n\tchar str[256];\n\n\tfor ( ; ; ) {\n\t\tif (ERR_peek_error() == 0)\n\t\t\tbreak;\n\n\t\thad_errors = true;\n\t\terr = ERR_get_error_line(&filename, &line);\n\t\tERR_error_string_n(err, str, sizeof(str));\n\t\tfprintf(stderr, \"crypto: %s: %s:%d\\n\", str, filename, line);\n\t}\n\n\treturn had_errors;\n}\n\nstatic inline const BIGNUM *get_modulus(RSA *key)\n{\n\tconst BIGNUM *n;\n\n\tRSA_get0_key(key, &n, NULL, NULL);\n\treturn n;\n}\n\nstatic RSA *gen_sign_key(void)\n{\n\tunsigned long sign_key_length;\n\tBIO *bio;\n\tRSA *key;\n\n\tsign_key_length = (unsigned long)&sign_key_end -\n\t\t\t  (unsigned long)&sign_key;\n\n\tbio = BIO_new_mem_buf(&sign_key, sign_key_length);\n\tif (!bio)\n\t\treturn NULL;\n\n\tkey = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);\n\tBIO_free(bio);\n\n\treturn key;\n}\n\nenum mrtags {\n\tMRECREATE = 0x0045544145524345,\n\tMREADD = 0x0000000044444145,\n\tMREEXTEND = 0x00444E4554584545,\n};\n\nstatic bool mrenclave_update(EVP_MD_CTX *ctx, const void *data)\n{\n\tif (!EVP_DigestUpdate(ctx, data, 64)) {\n\t\tfprintf(stderr, \"digest update failed\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool mrenclave_commit(EVP_MD_CTX *ctx, uint8_t *mrenclave)\n{\n\tunsigned int size;\n\n\tif (!EVP_DigestFinal_ex(ctx, (unsigned char *)mrenclave, &size)) {\n\t\tfprintf(stderr, \"digest commit failed\\n\");\n\t\treturn false;\n\t}\n\n\tif (size != 32) {\n\t\tfprintf(stderr, \"invalid digest size = %u\\n\", size);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstruct mrecreate {\n\tuint64_t tag;\n\tuint32_t ssaframesize;\n\tuint64_t size;\n\tuint8_t reserved[44];\n} __attribute__((__packed__));\n\n\nstatic bool mrenclave_ecreate(EVP_MD_CTX *ctx, uint64_t blob_size)\n{\n\tstruct mrecreate mrecreate;\n\tuint64_t encl_size;\n\n\tfor (encl_size = 0x1000; encl_size < blob_size; )\n\t\tencl_size <<= 1;\n\n\tmemset(&mrecreate, 0, sizeof(mrecreate));\n\tmrecreate.tag = MRECREATE;\n\tmrecreate.ssaframesize = 1;\n\tmrecreate.size = encl_size;\n\n\tif (!EVP_DigestInit_ex(ctx, EVP_sha256(), NULL))\n\t\treturn false;\n\n\treturn mrenclave_update(ctx, &mrecreate);\n}\n\nstruct mreadd {\n\tuint64_t tag;\n\tuint64_t offset;\n\tuint64_t flags;  \n\tuint8_t reserved[40];\n} __attribute__((__packed__));\n\nstatic bool mrenclave_eadd(EVP_MD_CTX *ctx, uint64_t offset, uint64_t flags)\n{\n\tstruct mreadd mreadd;\n\n\tmemset(&mreadd, 0, sizeof(mreadd));\n\tmreadd.tag = MREADD;\n\tmreadd.offset = offset;\n\tmreadd.flags = flags;\n\n\treturn mrenclave_update(ctx, &mreadd);\n}\n\nstruct mreextend {\n\tuint64_t tag;\n\tuint64_t offset;\n\tuint8_t reserved[48];\n} __attribute__((__packed__));\n\nstatic bool mrenclave_eextend(EVP_MD_CTX *ctx, uint64_t offset,\n\t\t\t      const uint8_t *data)\n{\n\tstruct mreextend mreextend;\n\tint i;\n\n\tfor (i = 0; i < 0x1000; i += 0x100) {\n\t\tmemset(&mreextend, 0, sizeof(mreextend));\n\t\tmreextend.tag = MREEXTEND;\n\t\tmreextend.offset = offset + i;\n\n\t\tif (!mrenclave_update(ctx, &mreextend))\n\t\t\treturn false;\n\n\t\tif (!mrenclave_update(ctx, &data[i + 0x00]))\n\t\t\treturn false;\n\n\t\tif (!mrenclave_update(ctx, &data[i + 0x40]))\n\t\t\treturn false;\n\n\t\tif (!mrenclave_update(ctx, &data[i + 0x80]))\n\t\t\treturn false;\n\n\t\tif (!mrenclave_update(ctx, &data[i + 0xC0]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool mrenclave_segment(EVP_MD_CTX *ctx, struct encl *encl,\n\t\t\t      struct encl_segment *seg)\n{\n\tuint64_t end = seg->size;\n\tuint64_t offset;\n\n\tfor (offset = 0; offset < end; offset += PAGE_SIZE) {\n\t\tif (!mrenclave_eadd(ctx, seg->offset + offset, seg->flags))\n\t\t\treturn false;\n\n\t\tif (seg->measure) {\n\t\t\tif (!mrenclave_eextend(ctx, seg->offset + offset, seg->src + offset))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool encl_measure(struct encl *encl)\n{\n\tuint64_t header1[2] = {0x000000E100000006, 0x0000000000010000};\n\tuint64_t header2[2] = {0x0000006000000101, 0x0000000100000060};\n\tstruct sgx_sigstruct *sigstruct = &encl->sigstruct;\n\tstruct sgx_sigstruct_payload payload;\n\tuint8_t digest[SHA256_DIGEST_LENGTH];\n\tEVP_MD_CTX *ctx = NULL;\n\tunsigned int siglen;\n\tRSA *key = NULL;\n\tint i;\n\n\tmemset(sigstruct, 0, sizeof(*sigstruct));\n\n\tsigstruct->header.header1[0] = header1[0];\n\tsigstruct->header.header1[1] = header1[1];\n\tsigstruct->header.header2[0] = header2[0];\n\tsigstruct->header.header2[1] = header2[1];\n\tsigstruct->exponent = 3;\n\tsigstruct->body.attributes = SGX_ATTR_MODE64BIT;\n\tsigstruct->body.xfrm = 3;\n\n\t \n\tif (check_crypto_errors())\n\t\tgoto err;\n\n\tkey = gen_sign_key();\n\tif (!key) {\n\t\tERR_print_errors_fp(stdout);\n\t\tgoto err;\n\t}\n\n\tBN_bn2bin(get_modulus(key), sigstruct->modulus);\n\n\tctx = EVP_MD_CTX_create();\n\tif (!ctx)\n\t\tgoto err;\n\n\tif (!mrenclave_ecreate(ctx, encl->src_size))\n\t\tgoto err;\n\n\tfor (i = 0; i < encl->nr_segments; i++) {\n\t\tstruct encl_segment *seg = &encl->segment_tbl[i];\n\n\t\tif (!mrenclave_segment(ctx, encl, seg))\n\t\t\tgoto err;\n\t}\n\n\tif (!mrenclave_commit(ctx, sigstruct->body.mrenclave))\n\t\tgoto err;\n\n\tmemcpy(&payload.header, &sigstruct->header, sizeof(sigstruct->header));\n\tmemcpy(&payload.body, &sigstruct->body, sizeof(sigstruct->body));\n\n\tSHA256((unsigned char *)&payload, sizeof(payload), digest);\n\n\tif (!RSA_sign(NID_sha256, digest, SHA256_DIGEST_LENGTH,\n\t\t      sigstruct->signature, &siglen, key))\n\t\tgoto err;\n\n\tif (!calc_q1q2(sigstruct->signature, sigstruct->modulus, sigstruct->q1,\n\t\t       sigstruct->q2))\n\t\tgoto err;\n\n\t \n\treverse_bytes(sigstruct->signature, SGX_MODULUS_SIZE);\n\treverse_bytes(sigstruct->modulus, SGX_MODULUS_SIZE);\n\n\tEVP_MD_CTX_destroy(ctx);\n\tRSA_free(key);\n\treturn true;\n\nerr:\n\tif (ctx)\n\t\tEVP_MD_CTX_destroy(ctx);\n\tRSA_free(key);\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}