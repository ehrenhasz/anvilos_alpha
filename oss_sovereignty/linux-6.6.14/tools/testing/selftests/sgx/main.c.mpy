{
  "module_name": "main.c",
  "hash_id": "b87748fd2a40513818e46e23483e3cd36ac446066a2449492708b1fdec3c4f7e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sgx/main.c",
  "human_readable_source": "\n \n\n#include <cpuid.h>\n#include <elf.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/auxv.h>\n#include \"defines.h\"\n#include \"../kselftest_harness.h\"\n#include \"main.h\"\n\nstatic const uint64_t MAGIC = 0x1122334455667788ULL;\nstatic const uint64_t MAGIC2 = 0x8877665544332211ULL;\nvdso_sgx_enter_enclave_t vdso_sgx_enter_enclave;\n\n \nenum sgx_secinfo_page_state {\n\tSGX_SECINFO_PENDING = (1 << 3),\n\tSGX_SECINFO_MODIFIED = (1 << 4),\n\tSGX_SECINFO_PR = (1 << 5),\n};\n\nstruct vdso_symtab {\n\tElf64_Sym *elf_symtab;\n\tconst char *elf_symstrtab;\n\tElf64_Word *elf_hashtab;\n};\n\nstatic Elf64_Dyn *vdso_get_dyntab(void *addr)\n{\n\tElf64_Ehdr *ehdr = addr;\n\tElf64_Phdr *phdrtab = addr + ehdr->e_phoff;\n\tint i;\n\n\tfor (i = 0; i < ehdr->e_phnum; i++)\n\t\tif (phdrtab[i].p_type == PT_DYNAMIC)\n\t\t\treturn addr + phdrtab[i].p_offset;\n\n\treturn NULL;\n}\n\nstatic void *vdso_get_dyn(void *addr, Elf64_Dyn *dyntab, Elf64_Sxword tag)\n{\n\tint i;\n\n\tfor (i = 0; dyntab[i].d_tag != DT_NULL; i++)\n\t\tif (dyntab[i].d_tag == tag)\n\t\t\treturn addr + dyntab[i].d_un.d_ptr;\n\n\treturn NULL;\n}\n\nstatic bool vdso_get_symtab(void *addr, struct vdso_symtab *symtab)\n{\n\tElf64_Dyn *dyntab = vdso_get_dyntab(addr);\n\n\tsymtab->elf_symtab = vdso_get_dyn(addr, dyntab, DT_SYMTAB);\n\tif (!symtab->elf_symtab)\n\t\treturn false;\n\n\tsymtab->elf_symstrtab = vdso_get_dyn(addr, dyntab, DT_STRTAB);\n\tif (!symtab->elf_symstrtab)\n\t\treturn false;\n\n\tsymtab->elf_hashtab = vdso_get_dyn(addr, dyntab, DT_HASH);\n\tif (!symtab->elf_hashtab)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline int sgx2_supported(void)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\t__cpuid_count(SGX_CPUID, 0x0, eax, ebx, ecx, edx);\n\n\treturn eax & 0x2;\n}\n\nstatic unsigned long elf_sym_hash(const char *name)\n{\n\tunsigned long h = 0, high;\n\n\twhile (*name) {\n\t\th = (h << 4) + *name++;\n\t\thigh = h & 0xf0000000;\n\n\t\tif (high)\n\t\t\th ^= high >> 24;\n\n\t\th &= ~high;\n\t}\n\n\treturn h;\n}\n\nstatic Elf64_Sym *vdso_symtab_get(struct vdso_symtab *symtab, const char *name)\n{\n\tElf64_Word bucketnum = symtab->elf_hashtab[0];\n\tElf64_Word *buckettab = &symtab->elf_hashtab[2];\n\tElf64_Word *chaintab = &symtab->elf_hashtab[2 + bucketnum];\n\tElf64_Sym *sym;\n\tElf64_Word i;\n\n\tfor (i = buckettab[elf_sym_hash(name) % bucketnum]; i != STN_UNDEF;\n\t     i = chaintab[i]) {\n\t\tsym = &symtab->elf_symtab[i];\n\t\tif (!strcmp(name, &symtab->elf_symstrtab[sym->st_name]))\n\t\t\treturn sym;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic off_t encl_get_tcs_offset(struct encl *encl)\n{\n\tint i;\n\n\tfor (i = 0; i < encl->nr_segments; i++) {\n\t\tstruct encl_segment *seg = &encl->segment_tbl[i];\n\n\t\tif (i == 0 && seg->prot == (PROT_READ | PROT_WRITE))\n\t\t\treturn seg->offset;\n\t}\n\n\treturn -1;\n}\n\n \nstatic off_t encl_get_data_offset(struct encl *encl)\n{\n\tint i;\n\n\tfor (i = 1; i < encl->nr_segments; i++) {\n\t\tstruct encl_segment *seg = &encl->segment_tbl[i];\n\n\t\tif (seg->prot == (PROT_READ | PROT_WRITE))\n\t\t\treturn seg->offset;\n\t}\n\n\treturn -1;\n}\n\nFIXTURE(enclave) {\n\tstruct encl encl;\n\tstruct sgx_enclave_run run;\n};\n\nstatic bool setup_test_encl(unsigned long heap_size, struct encl *encl,\n\t\t\t    struct __test_metadata *_metadata)\n{\n\tElf64_Sym *sgx_enter_enclave_sym = NULL;\n\tstruct vdso_symtab symtab;\n\tstruct encl_segment *seg;\n\tchar maps_line[256];\n\tFILE *maps_file;\n\tunsigned int i;\n\tvoid *addr;\n\n\tif (!encl_load(\"test_encl.elf\", encl, heap_size)) {\n\t\tencl_delete(encl);\n\t\tTH_LOG(\"Failed to load the test enclave.\");\n\t\treturn false;\n\t}\n\n\tif (!encl_measure(encl))\n\t\tgoto err;\n\n\tif (!encl_build(encl))\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < encl->nr_segments; i++) {\n\t\tstruct encl_segment *seg = &encl->segment_tbl[i];\n\n\t\taddr = mmap((void *)encl->encl_base + seg->offset, seg->size,\n\t\t\t    seg->prot, MAP_SHARED | MAP_FIXED, encl->fd, 0);\n\t\tEXPECT_NE(addr, MAP_FAILED);\n\t\tif (addr == MAP_FAILED)\n\t\t\tgoto err;\n\t}\n\n\t \n\taddr = (void *)getauxval(AT_SYSINFO_EHDR);\n\tif (!addr)\n\t\tgoto err;\n\n\tif (!vdso_get_symtab(addr, &symtab))\n\t\tgoto err;\n\n\tsgx_enter_enclave_sym = vdso_symtab_get(&symtab, \"__vdso_sgx_enter_enclave\");\n\tif (!sgx_enter_enclave_sym)\n\t\tgoto err;\n\n\tvdso_sgx_enter_enclave = addr + sgx_enter_enclave_sym->st_value;\n\n\treturn true;\n\nerr:\n\tfor (i = 0; i < encl->nr_segments; i++) {\n\t\tseg = &encl->segment_tbl[i];\n\n\t\tTH_LOG(\"0x%016lx 0x%016lx 0x%02x\", seg->offset, seg->size, seg->prot);\n\t}\n\n\tmaps_file = fopen(\"/proc/self/maps\", \"r\");\n\tif (maps_file != NULL)  {\n\t\twhile (fgets(maps_line, sizeof(maps_line), maps_file) != NULL) {\n\t\t\tmaps_line[strlen(maps_line) - 1] = '\\0';\n\n\t\t\tif (strstr(maps_line, \"/dev/sgx_enclave\"))\n\t\t\t\tTH_LOG(\"%s\", maps_line);\n\t\t}\n\n\t\tfclose(maps_file);\n\t}\n\n\tTH_LOG(\"Failed to initialize the test enclave.\");\n\n\tencl_delete(encl);\n\n\treturn false;\n}\n\nFIXTURE_SETUP(enclave)\n{\n}\n\nFIXTURE_TEARDOWN(enclave)\n{\n\tencl_delete(&self->encl);\n}\n\n#define ENCL_CALL(op, run, clobbered) \\\n\t({ \\\n\t\tint ret; \\\n\t\tif ((clobbered)) \\\n\t\t\tret = vdso_sgx_enter_enclave((unsigned long)(op), 0, 0, \\\n\t\t\t\t\t\t     EENTER, 0, 0, (run)); \\\n\t\telse \\\n\t\t\tret = sgx_enter_enclave((void *)(op), NULL, 0, EENTER, NULL, NULL, \\\n\t\t\t\t\t\t(run)); \\\n\t\tret; \\\n\t})\n\n#define EXPECT_EEXIT(run) \\\n\tdo { \\\n\t\tEXPECT_EQ((run)->function, EEXIT); \\\n\t\tif ((run)->function != EEXIT) \\\n\t\t\tTH_LOG(\"0x%02x 0x%02x 0x%016llx\", (run)->exception_vector, \\\n\t\t\t       (run)->exception_error_code, (run)->exception_addr); \\\n\t} while (0)\n\nTEST_F(enclave, unclobbered_vdso)\n{\n\tstruct encl_op_get_from_buf get_op;\n\tstruct encl_op_put_to_buf put_op;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\tput_op.header.type = ENCL_OP_PUT_TO_BUFFER;\n\tput_op.value = MAGIC;\n\n\tEXPECT_EQ(ENCL_CALL(&put_op, &self->run, false), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n\n\tget_op.header.type = ENCL_OP_GET_FROM_BUFFER;\n\tget_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_op, &self->run, false), 0);\n\n\tEXPECT_EQ(get_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n}\n\n \nstatic unsigned long sgx_calc_section_metric(unsigned int low,\n\t\t\t\t\t     unsigned int high)\n{\n\treturn (low & GENMASK_ULL(31, 12)) +\n\t       ((high & GENMASK_ULL(19, 0)) << 32);\n}\n\n \nstatic unsigned long get_total_epc_mem(void)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\tunsigned long total_size = 0;\n\tunsigned int type;\n\tint section = 0;\n\n\twhile (true) {\n\t\t__cpuid_count(SGX_CPUID, section + SGX_CPUID_EPC, eax, ebx, ecx, edx);\n\n\t\ttype = eax & SGX_CPUID_EPC_MASK;\n\t\tif (type == SGX_CPUID_EPC_INVALID)\n\t\t\tbreak;\n\n\t\tif (type != SGX_CPUID_EPC_SECTION)\n\t\t\tbreak;\n\n\t\ttotal_size += sgx_calc_section_metric(ecx, edx);\n\n\t\tsection++;\n\t}\n\n\treturn total_size;\n}\n\nTEST_F(enclave, unclobbered_vdso_oversubscribed)\n{\n\tstruct encl_op_get_from_buf get_op;\n\tstruct encl_op_put_to_buf put_op;\n\tunsigned long total_mem;\n\n\ttotal_mem = get_total_epc_mem();\n\tASSERT_NE(total_mem, 0);\n\tASSERT_TRUE(setup_test_encl(total_mem, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\tput_op.header.type = ENCL_OP_PUT_TO_BUFFER;\n\tput_op.value = MAGIC;\n\n\tEXPECT_EQ(ENCL_CALL(&put_op, &self->run, false), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n\n\tget_op.header.type = ENCL_OP_GET_FROM_BUFFER;\n\tget_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_op, &self->run, false), 0);\n\n\tEXPECT_EQ(get_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n}\n\nTEST_F_TIMEOUT(enclave, unclobbered_vdso_oversubscribed_remove, 900)\n{\n\tstruct sgx_enclave_remove_pages remove_ioc;\n\tstruct sgx_enclave_modify_types modt_ioc;\n\tstruct encl_op_get_from_buf get_op;\n\tstruct encl_op_eaccept eaccept_op;\n\tstruct encl_op_put_to_buf put_op;\n\tstruct encl_segment *heap;\n\tunsigned long total_mem;\n\tint ret, errno_save;\n\tunsigned long addr;\n\tunsigned long i;\n\n\t \n\ttotal_mem = get_total_epc_mem();\n\tASSERT_NE(total_mem, 0);\n\tTH_LOG(\"Creating an enclave with %lu bytes heap may take a while ...\",\n\t       total_mem);\n\tASSERT_TRUE(setup_test_encl(total_mem, &self->encl, _metadata));\n\n\t \n\tmemset(&modt_ioc, 0, sizeof(modt_ioc));\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &modt_ioc);\n\n\tif (ret == -1) {\n\t\tif (errno == ENOTTY)\n\t\t\tSKIP(return,\n\t\t\t     \"Kernel does not support SGX_IOC_ENCLAVE_MODIFY_TYPES ioctl()\");\n\t\telse if (errno == ENODEV)\n\t\t\tSKIP(return, \"System does not support SGX2\");\n\t}\n\n\t \n\tEXPECT_EQ(ret, -1);\n\n\t \n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\theap = &self->encl.segment_tbl[self->encl.nr_segments - 1];\n\n\tput_op.header.type = ENCL_OP_PUT_TO_BUFFER;\n\tput_op.value = MAGIC;\n\n\tEXPECT_EQ(ENCL_CALL(&put_op, &self->run, false), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n\n\tget_op.header.type = ENCL_OP_GET_FROM_BUFFER;\n\tget_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_op, &self->run, false), 0);\n\n\tEXPECT_EQ(get_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n\n\t \n\tmemset(&modt_ioc, 0, sizeof(modt_ioc));\n\n\tmodt_ioc.offset = heap->offset;\n\tmodt_ioc.length = heap->size;\n\tmodt_ioc.page_type = SGX_PAGE_TYPE_TRIM;\n\n\tTH_LOG(\"Changing type of %zd bytes to trimmed may take a while ...\",\n\t       heap->size);\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &modt_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(modt_ioc.result, 0);\n\tEXPECT_EQ(modt_ioc.count, heap->size);\n\n\t \n\taddr = self->encl.encl_base + heap->offset;\n\n\teaccept_op.flags = SGX_SECINFO_TRIM | SGX_SECINFO_MODIFIED;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tTH_LOG(\"Entering enclave to run EACCEPT for each page of %zd bytes may take a while ...\",\n\t       heap->size);\n\tfor (i = 0; i < heap->size; i += 4096) {\n\t\teaccept_op.epc_addr = addr + i;\n\t\teaccept_op.ret = 0;\n\n\t\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\t\tEXPECT_EQ(self->run.exception_vector, 0);\n\t\tEXPECT_EQ(self->run.exception_error_code, 0);\n\t\tEXPECT_EQ(self->run.exception_addr, 0);\n\t\tASSERT_EQ(eaccept_op.ret, 0);\n\t\tASSERT_EQ(self->run.function, EEXIT);\n\t}\n\n\t \n\tmemset(&remove_ioc, 0, sizeof(remove_ioc));\n\n\tremove_ioc.offset = heap->offset;\n\tremove_ioc.length = heap->size;\n\n\tTH_LOG(\"Removing %zd bytes from enclave may take a while ...\",\n\t       heap->size);\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_REMOVE_PAGES, &remove_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(remove_ioc.count, heap->size);\n}\n\nTEST_F(enclave, clobbered_vdso)\n{\n\tstruct encl_op_get_from_buf get_op;\n\tstruct encl_op_put_to_buf put_op;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\tput_op.header.type = ENCL_OP_PUT_TO_BUFFER;\n\tput_op.value = MAGIC;\n\n\tEXPECT_EQ(ENCL_CALL(&put_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n\n\tget_op.header.type = ENCL_OP_GET_FROM_BUFFER;\n\tget_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n}\n\nstatic int test_handler(long rdi, long rsi, long rdx, long ursp, long r8, long r9,\n\t\t\tstruct sgx_enclave_run *run)\n{\n\trun->user_data = 0;\n\n\treturn 0;\n}\n\nTEST_F(enclave, clobbered_vdso_and_user_function)\n{\n\tstruct encl_op_get_from_buf get_op;\n\tstruct encl_op_put_to_buf put_op;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\tself->run.user_handler = (__u64)test_handler;\n\tself->run.user_data = 0xdeadbeef;\n\n\tput_op.header.type = ENCL_OP_PUT_TO_BUFFER;\n\tput_op.value = MAGIC;\n\n\tEXPECT_EQ(ENCL_CALL(&put_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n\n\tget_op.header.type = ENCL_OP_GET_FROM_BUFFER;\n\tget_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n}\n\n \nTEST_F(enclave, tcs_entry)\n{\n\tstruct encl_op_header op;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\top.type = ENCL_OP_NOP;\n\n\tEXPECT_EQ(ENCL_CALL(&op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tself->run.tcs = self->encl.encl_base + PAGE_SIZE;\n\n\tEXPECT_EQ(ENCL_CALL(&op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n}\n\n \nTEST_F(enclave, pte_permissions)\n{\n\tstruct encl_op_get_from_addr get_addr_op;\n\tstruct encl_op_put_to_addr put_addr_op;\n\tunsigned long data_start;\n\tint ret;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\tdata_start = self->encl.encl_base +\n\t\t     encl_get_data_offset(&self->encl) +\n\t\t     PAGE_SIZE;\n\n\t \n\n\t \n\tput_addr_op.value = MAGIC;\n\tput_addr_op.addr = data_start;\n\tput_addr_op.header.type = ENCL_OP_PUT_TO_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tget_addr_op.value = 0;\n\tget_addr_op.addr = data_start;\n\tget_addr_op.header.type = ENCL_OP_GET_FROM_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tret = mprotect((void *)data_start, PAGE_SIZE, PROT_READ);\n\tif (ret)\n\t\tperror(\"mprotect\");\n\n\t \n\n\tput_addr_op.value = MAGIC2;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(self->run.exception_vector, 14);\n\tEXPECT_EQ(self->run.exception_error_code, 0x7);\n\tEXPECT_EQ(self->run.exception_addr, data_start);\n\n\tself->run.exception_vector = 0;\n\tself->run.exception_error_code = 0;\n\tself->run.exception_addr = 0;\n\n\t \n\tret = mprotect((void *)data_start, PAGE_SIZE, PROT_READ | PROT_WRITE);\n\tif (ret)\n\t\tperror(\"mprotect\");\n\n\tEXPECT_EQ(vdso_sgx_enter_enclave((unsigned long)&put_addr_op, 0,\n\t\t\t\t\t 0, ERESUME, 0, 0, &self->run),\n\t\t 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\tget_addr_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC2);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n}\n\n \nTEST_F(enclave, tcs_permissions)\n{\n\tstruct sgx_enclave_restrict_permissions ioc;\n\tint ret, errno_save;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\tmemset(&ioc, 0, sizeof(ioc));\n\n\t \n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_RESTRICT_PERMISSIONS, &ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\t \n\tASSERT_EQ(ret, -1);\n\n\t \n\tif (errno_save == ENOTTY)\n\t\tSKIP(return,\n\t\t     \"Kernel does not support SGX_IOC_ENCLAVE_RESTRICT_PERMISSIONS ioctl()\");\n\telse if (errno_save == ENODEV)\n\t\tSKIP(return, \"System does not support SGX2\");\n\n\t \n\tioc.offset = encl_get_tcs_offset(&self->encl);\n\tioc.length = PAGE_SIZE;\n\tioc.permissions = SGX_SECINFO_R;\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_RESTRICT_PERMISSIONS, &ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, -1);\n\tEXPECT_EQ(errno_save, EINVAL);\n\tEXPECT_EQ(ioc.result, 0);\n\tEXPECT_EQ(ioc.count, 0);\n}\n\n \nTEST_F(enclave, epcm_permissions)\n{\n\tstruct sgx_enclave_restrict_permissions restrict_ioc;\n\tstruct encl_op_get_from_addr get_addr_op;\n\tstruct encl_op_put_to_addr put_addr_op;\n\tstruct encl_op_eaccept eaccept_op;\n\tstruct encl_op_emodpe emodpe_op;\n\tunsigned long data_start;\n\tint ret, errno_save;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\t \n\tmemset(&restrict_ioc, 0, sizeof(restrict_ioc));\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_RESTRICT_PERMISSIONS,\n\t\t    &restrict_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\t \n\tASSERT_EQ(ret, -1);\n\n\t \n\tif (errno_save == ENOTTY)\n\t\tSKIP(return,\n\t\t     \"Kernel does not support SGX_IOC_ENCLAVE_RESTRICT_PERMISSIONS ioctl()\");\n\telse if (errno_save == ENODEV)\n\t\tSKIP(return, \"System does not support SGX2\");\n\n\t \n\n\tdata_start = self->encl.encl_base +\n\t\t     encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\n\t \n\tput_addr_op.value = MAGIC;\n\tput_addr_op.addr = data_start;\n\tput_addr_op.header.type = ENCL_OP_PUT_TO_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tget_addr_op.value = 0;\n\tget_addr_op.addr = data_start;\n\tget_addr_op.header.type = ENCL_OP_GET_FROM_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tmemset(&restrict_ioc, 0, sizeof(restrict_ioc));\n\n\trestrict_ioc.offset = encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\trestrict_ioc.length = PAGE_SIZE;\n\trestrict_ioc.permissions = SGX_SECINFO_R;\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_RESTRICT_PERMISSIONS,\n\t\t    &restrict_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(restrict_ioc.result, 0);\n\tEXPECT_EQ(restrict_ioc.count, 4096);\n\n\t \n\teaccept_op.epc_addr = data_start;\n\teaccept_op.flags = SGX_SECINFO_R | SGX_SECINFO_REG | SGX_SECINFO_PR;\n\teaccept_op.ret = 0;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\t \n\tput_addr_op.value = MAGIC2;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(self->run.function, ERESUME);\n\tEXPECT_EQ(self->run.exception_vector, 14);\n\tEXPECT_EQ(self->run.exception_error_code, 0x8007);\n\tEXPECT_EQ(self->run.exception_addr, data_start);\n\n\tself->run.exception_vector = 0;\n\tself->run.exception_error_code = 0;\n\tself->run.exception_addr = 0;\n\n\t \n\tself->run.tcs = self->encl.encl_base + PAGE_SIZE;\n\n\t \n\n\temodpe_op.epc_addr = data_start;\n\temodpe_op.flags = SGX_SECINFO_R | SGX_SECINFO_W;\n\temodpe_op.header.type = ENCL_OP_EMODPE;\n\n\tEXPECT_EQ(ENCL_CALL(&emodpe_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tself->run.tcs = self->encl.encl_base;\n\n\t \n\tself->run.tcs = self->encl.encl_base;\n\n\tEXPECT_EQ(vdso_sgx_enter_enclave((unsigned long)&put_addr_op, 0, 0,\n\t\t\t\t\t ERESUME, 0, 0,\n\t\t\t\t\t &self->run),\n\t\t  0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\tget_addr_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC2);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.user_data, 0);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n}\n\n \nTEST_F(enclave, augment)\n{\n\tstruct encl_op_get_from_addr get_addr_op;\n\tstruct encl_op_put_to_addr put_addr_op;\n\tstruct encl_op_eaccept eaccept_op;\n\tsize_t total_size = 0;\n\tvoid *addr;\n\tint i;\n\n\tif (!sgx2_supported())\n\t\tSKIP(return, \"SGX2 not supported\");\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\tfor (i = 0; i < self->encl.nr_segments; i++) {\n\t\tstruct encl_segment *seg = &self->encl.segment_tbl[i];\n\n\t\ttotal_size += seg->size;\n\t}\n\n\t \n\tEXPECT_LT(total_size + PAGE_SIZE, self->encl.encl_size);\n\n\t \n\taddr = mmap((void *)self->encl.encl_base + total_size, PAGE_SIZE,\n\t\t    PROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t    MAP_SHARED | MAP_FIXED, self->encl.fd, 0);\n\tEXPECT_NE(addr, MAP_FAILED);\n\n\tself->run.exception_vector = 0;\n\tself->run.exception_error_code = 0;\n\tself->run.exception_addr = 0;\n\n\t \n\tput_addr_op.value = MAGIC;\n\tput_addr_op.addr = (unsigned long)addr;\n\tput_addr_op.header.type = ENCL_OP_PUT_TO_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(self->run.function, ERESUME);\n\tEXPECT_EQ(self->run.exception_vector, 14);\n\tEXPECT_EQ(self->run.exception_addr, (unsigned long)addr);\n\n\tif (self->run.exception_error_code == 0x6) {\n\t\tmunmap(addr, PAGE_SIZE);\n\t\tSKIP(return, \"Kernel does not support adding pages to initialized enclave\");\n\t}\n\n\tEXPECT_EQ(self->run.exception_error_code, 0x8007);\n\n\tself->run.exception_vector = 0;\n\tself->run.exception_error_code = 0;\n\tself->run.exception_addr = 0;\n\n\t \n\tself->run.tcs = self->encl.encl_base + PAGE_SIZE;\n\n\teaccept_op.epc_addr = self->encl.encl_base + total_size;\n\teaccept_op.flags = SGX_SECINFO_R | SGX_SECINFO_W | SGX_SECINFO_REG | SGX_SECINFO_PENDING;\n\teaccept_op.ret = 0;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\t \n\tself->run.tcs = self->encl.encl_base;\n\n\tEXPECT_EQ(vdso_sgx_enter_enclave((unsigned long)&put_addr_op, 0, 0,\n\t\t\t\t\t ERESUME, 0, 0,\n\t\t\t\t\t &self->run),\n\t\t  0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tget_addr_op.value = 0;\n\tget_addr_op.addr = (unsigned long)addr;\n\tget_addr_op.header.type = ENCL_OP_GET_FROM_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\tmunmap(addr, PAGE_SIZE);\n}\n\n \nTEST_F(enclave, augment_via_eaccept)\n{\n\tstruct encl_op_get_from_addr get_addr_op;\n\tstruct encl_op_put_to_addr put_addr_op;\n\tstruct encl_op_eaccept eaccept_op;\n\tsize_t total_size = 0;\n\tvoid *addr;\n\tint i;\n\n\tif (!sgx2_supported())\n\t\tSKIP(return, \"SGX2 not supported\");\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\tfor (i = 0; i < self->encl.nr_segments; i++) {\n\t\tstruct encl_segment *seg = &self->encl.segment_tbl[i];\n\n\t\ttotal_size += seg->size;\n\t}\n\n\t \n\tEXPECT_LT(total_size + PAGE_SIZE, self->encl.encl_size);\n\n\t \n\n\taddr = mmap((void *)self->encl.encl_base + total_size, PAGE_SIZE,\n\t\t    PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_FIXED,\n\t\t    self->encl.fd, 0);\n\tEXPECT_NE(addr, MAP_FAILED);\n\n\tself->run.exception_vector = 0;\n\tself->run.exception_error_code = 0;\n\tself->run.exception_addr = 0;\n\n\t \n\teaccept_op.epc_addr = self->encl.encl_base + total_size;\n\teaccept_op.flags = SGX_SECINFO_R | SGX_SECINFO_W | SGX_SECINFO_REG | SGX_SECINFO_PENDING;\n\teaccept_op.ret = 0;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tif (self->run.exception_vector == 14 &&\n\t    self->run.exception_error_code == 4 &&\n\t    self->run.exception_addr == self->encl.encl_base + total_size) {\n\t\tmunmap(addr, PAGE_SIZE);\n\t\tSKIP(return, \"Kernel does not support adding pages to initialized enclave\");\n\t}\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\t \n\tput_addr_op.value = MAGIC;\n\tput_addr_op.addr = (unsigned long)addr;\n\tput_addr_op.header.type = ENCL_OP_PUT_TO_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tget_addr_op.value = 0;\n\tget_addr_op.addr = (unsigned long)addr;\n\tget_addr_op.header.type = ENCL_OP_GET_FROM_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\tmunmap(addr, PAGE_SIZE);\n}\n\n \nTEST_F(enclave, tcs_create)\n{\n\tstruct encl_op_init_tcs_page init_tcs_page_op;\n\tstruct sgx_enclave_remove_pages remove_ioc;\n\tstruct encl_op_get_from_addr get_addr_op;\n\tstruct sgx_enclave_modify_types modt_ioc;\n\tstruct encl_op_put_to_addr put_addr_op;\n\tstruct encl_op_get_from_buf get_buf_op;\n\tstruct encl_op_put_to_buf put_buf_op;\n\tvoid *addr, *tcs, *stack_end, *ssa;\n\tstruct encl_op_eaccept eaccept_op;\n\tsize_t total_size = 0;\n\tuint64_t val_64;\n\tint errno_save;\n\tint ret, i;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl,\n\t\t\t\t    _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\t \n\tmemset(&modt_ioc, 0, sizeof(modt_ioc));\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &modt_ioc);\n\n\tif (ret == -1) {\n\t\tif (errno == ENOTTY)\n\t\t\tSKIP(return,\n\t\t\t     \"Kernel does not support SGX_IOC_ENCLAVE_MODIFY_TYPES ioctl()\");\n\t\telse if (errno == ENODEV)\n\t\t\tSKIP(return, \"System does not support SGX2\");\n\t}\n\n\t \n\tEXPECT_EQ(ret, -1);\n\n\t \n\tfor (i = 0; i < self->encl.nr_segments; i++) {\n\t\tstruct encl_segment *seg = &self->encl.segment_tbl[i];\n\n\t\ttotal_size += seg->size;\n\t}\n\n\t \n\tEXPECT_LT(total_size + 3 * PAGE_SIZE, self->encl.encl_size);\n\n\t \n\taddr = mmap((void *)self->encl.encl_base + total_size, 3 * PAGE_SIZE,\n\t\t    PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED,\n\t\t    self->encl.fd, 0);\n\tEXPECT_NE(addr, MAP_FAILED);\n\n\tself->run.exception_vector = 0;\n\tself->run.exception_error_code = 0;\n\tself->run.exception_addr = 0;\n\n\tstack_end = (void *)self->encl.encl_base + total_size;\n\ttcs = (void *)self->encl.encl_base + total_size + PAGE_SIZE;\n\tssa = (void *)self->encl.encl_base + total_size + 2 * PAGE_SIZE;\n\n\t \n\n\teaccept_op.epc_addr = (unsigned long)stack_end;\n\teaccept_op.flags = SGX_SECINFO_R | SGX_SECINFO_W | SGX_SECINFO_REG | SGX_SECINFO_PENDING;\n\teaccept_op.ret = 0;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tif (self->run.exception_vector == 14 &&\n\t    self->run.exception_error_code == 4 &&\n\t    self->run.exception_addr == (unsigned long)stack_end) {\n\t\tmunmap(addr, 3 * PAGE_SIZE);\n\t\tSKIP(return, \"Kernel does not support adding pages to initialized enclave\");\n\t}\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\teaccept_op.epc_addr = (unsigned long)ssa;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\teaccept_op.epc_addr = (unsigned long)tcs;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\t \n\n\t \n\tval_64 = encl_get_entry(&self->encl, \"encl_dyn_entry\");\n\tEXPECT_NE(val_64, 0);\n\n\tinit_tcs_page_op.tcs_page = (unsigned long)tcs;\n\tinit_tcs_page_op.ssa = (unsigned long)total_size + 2 * PAGE_SIZE;\n\tinit_tcs_page_op.entry = val_64;\n\tinit_tcs_page_op.header.type = ENCL_OP_INIT_TCS_PAGE;\n\n\tEXPECT_EQ(ENCL_CALL(&init_tcs_page_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tmemset(&modt_ioc, 0, sizeof(modt_ioc));\n\n\tmodt_ioc.offset = total_size + PAGE_SIZE;\n\tmodt_ioc.length = PAGE_SIZE;\n\tmodt_ioc.page_type = SGX_PAGE_TYPE_TCS;\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &modt_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(modt_ioc.result, 0);\n\tEXPECT_EQ(modt_ioc.count, 4096);\n\n\t \n\teaccept_op.epc_addr = (unsigned long)tcs;\n\teaccept_op.flags = SGX_SECINFO_TCS | SGX_SECINFO_MODIFIED;\n\teaccept_op.ret = 0;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\t \n\tself->run.tcs = (unsigned long)tcs;\n\n\t \n\tput_buf_op.header.type = ENCL_OP_PUT_TO_BUFFER;\n\tput_buf_op.value = MAGIC;\n\n\tEXPECT_EQ(ENCL_CALL(&put_buf_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\tget_buf_op.header.type = ENCL_OP_GET_FROM_BUFFER;\n\tget_buf_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_buf_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_buf_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\n\t \n\tmemset(&modt_ioc, 0, sizeof(modt_ioc));\n\n\tmodt_ioc.offset = total_size;\n\tmodt_ioc.length = 3 * PAGE_SIZE;\n\tmodt_ioc.page_type = SGX_PAGE_TYPE_TRIM;\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &modt_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(modt_ioc.result, 0);\n\tEXPECT_EQ(modt_ioc.count, 3 * PAGE_SIZE);\n\n\t \n\tself->run.tcs = self->encl.encl_base;\n\n\teaccept_op.epc_addr = (unsigned long)stack_end;\n\teaccept_op.flags = SGX_SECINFO_TRIM | SGX_SECINFO_MODIFIED;\n\teaccept_op.ret = 0;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\teaccept_op.epc_addr = (unsigned long)tcs;\n\teaccept_op.ret = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\teaccept_op.epc_addr = (unsigned long)ssa;\n\teaccept_op.ret = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\t \n\tmemset(&remove_ioc, 0, sizeof(remove_ioc));\n\n\tremove_ioc.offset = total_size;\n\tremove_ioc.length = 3 * PAGE_SIZE;\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_REMOVE_PAGES, &remove_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(remove_ioc.count, 3 * PAGE_SIZE);\n\n\t \n\teaccept_op.epc_addr = (unsigned long)tcs;\n\teaccept_op.flags = SGX_SECINFO_R | SGX_SECINFO_W | SGX_SECINFO_REG | SGX_SECINFO_PENDING;\n\teaccept_op.ret = 0;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\t \n\tput_addr_op.value = MAGIC;\n\tput_addr_op.addr = (unsigned long)tcs;\n\tput_addr_op.header.type = ENCL_OP_PUT_TO_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tget_addr_op.value = 0;\n\tget_addr_op.addr = (unsigned long)tcs;\n\tget_addr_op.header.type = ENCL_OP_GET_FROM_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\tmunmap(addr, 3 * PAGE_SIZE);\n}\n\n \nTEST_F(enclave, remove_added_page_no_eaccept)\n{\n\tstruct sgx_enclave_remove_pages remove_ioc;\n\tstruct encl_op_get_from_addr get_addr_op;\n\tstruct sgx_enclave_modify_types modt_ioc;\n\tstruct encl_op_put_to_addr put_addr_op;\n\tunsigned long data_start;\n\tint ret, errno_save;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\t \n\tmemset(&modt_ioc, 0, sizeof(modt_ioc));\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &modt_ioc);\n\n\tif (ret == -1) {\n\t\tif (errno == ENOTTY)\n\t\t\tSKIP(return,\n\t\t\t     \"Kernel does not support SGX_IOC_ENCLAVE_MODIFY_TYPES ioctl()\");\n\t\telse if (errno == ENODEV)\n\t\t\tSKIP(return, \"System does not support SGX2\");\n\t}\n\n\t \n\tEXPECT_EQ(ret, -1);\n\n\t \n\tdata_start = self->encl.encl_base +\n\t\t     encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\n\t \n\tput_addr_op.value = MAGIC;\n\tput_addr_op.addr = data_start;\n\tput_addr_op.header.type = ENCL_OP_PUT_TO_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tget_addr_op.value = 0;\n\tget_addr_op.addr = data_start;\n\tget_addr_op.header.type = ENCL_OP_GET_FROM_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tmemset(&modt_ioc, 0, sizeof(modt_ioc));\n\n\tmodt_ioc.offset = encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\tmodt_ioc.length = PAGE_SIZE;\n\tmodt_ioc.page_type = SGX_PAGE_TYPE_TRIM;\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &modt_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(modt_ioc.result, 0);\n\tEXPECT_EQ(modt_ioc.count, 4096);\n\n\t \n\n\t \n\tmemset(&remove_ioc, 0, sizeof(remove_ioc));\n\n\tremove_ioc.offset = encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\tremove_ioc.length = PAGE_SIZE;\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_REMOVE_PAGES, &remove_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\t \n\tEXPECT_EQ(ret, -1);\n\tEXPECT_EQ(errno_save, EPERM);\n\tEXPECT_EQ(remove_ioc.count, 0);\n}\n\n \nTEST_F(enclave, remove_added_page_invalid_access)\n{\n\tstruct encl_op_get_from_addr get_addr_op;\n\tstruct encl_op_put_to_addr put_addr_op;\n\tstruct sgx_enclave_modify_types ioc;\n\tunsigned long data_start;\n\tint ret, errno_save;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\t \n\tmemset(&ioc, 0, sizeof(ioc));\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &ioc);\n\n\tif (ret == -1) {\n\t\tif (errno == ENOTTY)\n\t\t\tSKIP(return,\n\t\t\t     \"Kernel does not support SGX_IOC_ENCLAVE_MODIFY_TYPES ioctl()\");\n\t\telse if (errno == ENODEV)\n\t\t\tSKIP(return, \"System does not support SGX2\");\n\t}\n\n\t \n\tEXPECT_EQ(ret, -1);\n\n\t \n\tdata_start = self->encl.encl_base +\n\t\t     encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\n\t \n\tput_addr_op.value = MAGIC;\n\tput_addr_op.addr = data_start;\n\tput_addr_op.header.type = ENCL_OP_PUT_TO_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tget_addr_op.value = 0;\n\tget_addr_op.addr = data_start;\n\tget_addr_op.header.type = ENCL_OP_GET_FROM_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tmemset(&ioc, 0, sizeof(ioc));\n\n\tioc.offset = encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\tioc.length = PAGE_SIZE;\n\tioc.page_type = SGX_PAGE_TYPE_TRIM;\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(ioc.result, 0);\n\tEXPECT_EQ(ioc.count, 4096);\n\n\t \n\tget_addr_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\t \n\n\tEXPECT_EQ(self->run.function, ERESUME);\n\tEXPECT_EQ(self->run.exception_vector, 14);\n\tEXPECT_EQ(self->run.exception_error_code, 0x8005);\n\tEXPECT_EQ(self->run.exception_addr, data_start);\n}\n\n \nTEST_F(enclave, remove_added_page_invalid_access_after_eaccept)\n{\n\tstruct encl_op_get_from_addr get_addr_op;\n\tstruct encl_op_put_to_addr put_addr_op;\n\tstruct sgx_enclave_modify_types ioc;\n\tstruct encl_op_eaccept eaccept_op;\n\tunsigned long data_start;\n\tint ret, errno_save;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\t \n\tmemset(&ioc, 0, sizeof(ioc));\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &ioc);\n\n\tif (ret == -1) {\n\t\tif (errno == ENOTTY)\n\t\t\tSKIP(return,\n\t\t\t     \"Kernel does not support SGX_IOC_ENCLAVE_MODIFY_TYPES ioctl()\");\n\t\telse if (errno == ENODEV)\n\t\t\tSKIP(return, \"System does not support SGX2\");\n\t}\n\n\t \n\tEXPECT_EQ(ret, -1);\n\n\t \n\tdata_start = self->encl.encl_base +\n\t\t     encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\n\t \n\tput_addr_op.value = MAGIC;\n\tput_addr_op.addr = data_start;\n\tput_addr_op.header.type = ENCL_OP_PUT_TO_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&put_addr_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tget_addr_op.value = 0;\n\tget_addr_op.addr = data_start;\n\tget_addr_op.header.type = ENCL_OP_GET_FROM_ADDRESS;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\tEXPECT_EQ(get_addr_op.value, MAGIC);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\n\t \n\tmemset(&ioc, 0, sizeof(ioc));\n\n\tioc.offset = encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\tioc.length = PAGE_SIZE;\n\tioc.page_type = SGX_PAGE_TYPE_TRIM;\n\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(ioc.result, 0);\n\tEXPECT_EQ(ioc.count, 4096);\n\n\teaccept_op.epc_addr = (unsigned long)data_start;\n\teaccept_op.ret = 0;\n\teaccept_op.flags = SGX_SECINFO_TRIM | SGX_SECINFO_MODIFIED;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\t \n\n\t \n\tget_addr_op.value = 0;\n\n\tEXPECT_EQ(ENCL_CALL(&get_addr_op, &self->run, true), 0);\n\n\t \n\n\tEXPECT_EQ(self->run.function, ERESUME);\n\tEXPECT_EQ(self->run.exception_vector, 14);\n\tEXPECT_EQ(self->run.exception_error_code, 0x8005);\n\tEXPECT_EQ(self->run.exception_addr, data_start);\n}\n\nTEST_F(enclave, remove_untouched_page)\n{\n\tstruct sgx_enclave_remove_pages remove_ioc;\n\tstruct sgx_enclave_modify_types modt_ioc;\n\tstruct encl_op_eaccept eaccept_op;\n\tunsigned long data_start;\n\tint ret, errno_save;\n\n\tASSERT_TRUE(setup_test_encl(ENCL_HEAP_SIZE_DEFAULT, &self->encl, _metadata));\n\n\t \n\tmemset(&modt_ioc, 0, sizeof(modt_ioc));\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &modt_ioc);\n\n\tif (ret == -1) {\n\t\tif (errno == ENOTTY)\n\t\t\tSKIP(return,\n\t\t\t     \"Kernel does not support SGX_IOC_ENCLAVE_MODIFY_TYPES ioctl()\");\n\t\telse if (errno == ENODEV)\n\t\t\tSKIP(return, \"System does not support SGX2\");\n\t}\n\n\t \n\tEXPECT_EQ(ret, -1);\n\n\t \n\tmemset(&self->run, 0, sizeof(self->run));\n\tself->run.tcs = self->encl.encl_base;\n\n\tdata_start = self->encl.encl_base +\n\t\t\t encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\n\tmemset(&modt_ioc, 0, sizeof(modt_ioc));\n\n\tmodt_ioc.offset = encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\tmodt_ioc.length = PAGE_SIZE;\n\tmodt_ioc.page_type = SGX_PAGE_TYPE_TRIM;\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_MODIFY_TYPES, &modt_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(modt_ioc.result, 0);\n\tEXPECT_EQ(modt_ioc.count, 4096);\n\n\t \n\n\teaccept_op.epc_addr = data_start;\n\teaccept_op.flags = SGX_SECINFO_TRIM | SGX_SECINFO_MODIFIED;\n\teaccept_op.ret = 0;\n\teaccept_op.header.type = ENCL_OP_EACCEPT;\n\n\tEXPECT_EQ(ENCL_CALL(&eaccept_op, &self->run, true), 0);\n\tEXPECT_EEXIT(&self->run);\n\tEXPECT_EQ(self->run.exception_vector, 0);\n\tEXPECT_EQ(self->run.exception_error_code, 0);\n\tEXPECT_EQ(self->run.exception_addr, 0);\n\tEXPECT_EQ(eaccept_op.ret, 0);\n\n\tmemset(&remove_ioc, 0, sizeof(remove_ioc));\n\n\tremove_ioc.offset = encl_get_data_offset(&self->encl) + PAGE_SIZE;\n\tremove_ioc.length = PAGE_SIZE;\n\tret = ioctl(self->encl.fd, SGX_IOC_ENCLAVE_REMOVE_PAGES, &remove_ioc);\n\terrno_save = ret == -1 ? errno : 0;\n\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(errno_save, 0);\n\tEXPECT_EQ(remove_ioc.count, 4096);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}