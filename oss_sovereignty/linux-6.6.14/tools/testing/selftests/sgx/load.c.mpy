{
  "module_name": "load.c",
  "hash_id": "f4f43718a7c5f35a49c5f625d97bfd86d33c4ee9bb429885741cc0a2d87a073e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sgx/load.c",
  "human_readable_source": "\n \n\n#include <assert.h>\n#include <elf.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"defines.h\"\n#include \"main.h\"\n\nvoid encl_delete(struct encl *encl)\n{\n\tstruct encl_segment *heap_seg;\n\n\tif (encl->encl_base)\n\t\tmunmap((void *)encl->encl_base, encl->encl_size);\n\n\tif (encl->bin)\n\t\tmunmap(encl->bin, encl->bin_size);\n\n\tif (encl->fd)\n\t\tclose(encl->fd);\n\n\tif (encl->segment_tbl) {\n\t\theap_seg = &encl->segment_tbl[encl->nr_segments - 1];\n\t\tmunmap(heap_seg->src, heap_seg->size);\n\t\tfree(encl->segment_tbl);\n\t}\n\n\tmemset(encl, 0, sizeof(*encl));\n}\n\nstatic bool encl_map_bin(const char *path, struct encl *encl)\n{\n\tstruct stat sb;\n\tvoid *bin;\n\tint ret;\n\tint fd;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)  {\n\t\tperror(\"enclave executable open()\");\n\t\treturn false;\n\t}\n\n\tret = stat(path, &sb);\n\tif (ret) {\n\t\tperror(\"enclave executable stat()\");\n\t\tgoto err;\n\t}\n\n\tbin = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (bin == MAP_FAILED) {\n\t\tperror(\"enclave executable mmap()\");\n\t\tgoto err;\n\t}\n\n\tencl->bin = bin;\n\tencl->bin_size = sb.st_size;\n\n\tclose(fd);\n\treturn true;\n\nerr:\n\tclose(fd);\n\treturn false;\n}\n\nstatic bool encl_ioc_create(struct encl *encl)\n{\n\tstruct sgx_secs *secs = &encl->secs;\n\tstruct sgx_enclave_create ioc;\n\tint rc;\n\n\tassert(encl->encl_base != 0);\n\n\tmemset(secs, 0, sizeof(*secs));\n\tsecs->ssa_frame_size = 1;\n\tsecs->attributes = SGX_ATTR_MODE64BIT;\n\tsecs->xfrm = 3;\n\tsecs->base = encl->encl_base;\n\tsecs->size = encl->encl_size;\n\n\tioc.src = (unsigned long)secs;\n\trc = ioctl(encl->fd, SGX_IOC_ENCLAVE_CREATE, &ioc);\n\tif (rc) {\n\t\tperror(\"SGX_IOC_ENCLAVE_CREATE failed\");\n\t\tmunmap((void *)secs->base, encl->encl_size);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool encl_ioc_add_pages(struct encl *encl, struct encl_segment *seg)\n{\n\tstruct sgx_enclave_add_pages ioc;\n\tstruct sgx_secinfo secinfo;\n\tint rc;\n\n\tmemset(&secinfo, 0, sizeof(secinfo));\n\tsecinfo.flags = seg->flags;\n\n\tioc.src = (uint64_t)seg->src;\n\tioc.offset = seg->offset;\n\tioc.length = seg->size;\n\tioc.secinfo = (unsigned long)&secinfo;\n\tif (seg->measure)\n\t\tioc.flags = SGX_PAGE_MEASURE;\n\telse\n\t\tioc.flags = 0;\n\n\trc = ioctl(encl->fd, SGX_IOC_ENCLAVE_ADD_PAGES, &ioc);\n\tif (rc < 0) {\n\t\tperror(\"SGX_IOC_ENCLAVE_ADD_PAGES failed\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nuint64_t encl_get_entry(struct encl *encl, const char *symbol)\n{\n\tElf64_Sym *symtab = NULL;\n\tchar *sym_names = NULL;\n\tElf64_Shdr *sections;\n\tElf64_Ehdr *ehdr;\n\tint num_sym = 0;\n\tint i;\n\n\tehdr = encl->bin;\n\tsections = encl->bin + ehdr->e_shoff;\n\n\tfor (i = 0; i < ehdr->e_shnum; i++) {\n\t\tif (sections[i].sh_type == SHT_SYMTAB) {\n\t\t\tsymtab = (Elf64_Sym *)((char *)encl->bin + sections[i].sh_offset);\n\t\t\tnum_sym = sections[i].sh_size / sections[i].sh_entsize;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ehdr->e_shnum; i++) {\n\t\tif (sections[i].sh_type == SHT_STRTAB) {\n\t\t\tsym_names = (char *)encl->bin + sections[i].sh_offset;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!symtab || !sym_names)\n\t\treturn 0;\n\n\tfor (i = 0; i < num_sym; i++) {\n\t\tElf64_Sym *sym = &symtab[i];\n\n\t\tif (!strcmp(symbol, sym_names + sym->st_name))\n\t\t\treturn (uint64_t)sym->st_value;\n\t}\n\n\treturn 0;\n}\n\nbool encl_load(const char *path, struct encl *encl, unsigned long heap_size)\n{\n\tconst char device_path[] = \"/dev/sgx_enclave\";\n\tstruct encl_segment *seg;\n\tElf64_Phdr *phdr_tbl;\n\toff_t src_offset;\n\tElf64_Ehdr *ehdr;\n\tstruct stat sb;\n\tvoid *ptr;\n\tint i, j;\n\tint ret;\n\tint fd = -1;\n\n\tmemset(encl, 0, sizeof(*encl));\n\n\tfd = open(device_path, O_RDWR);\n\tif (fd < 0) {\n\t\tperror(\"Unable to open /dev/sgx_enclave\");\n\t\tgoto err;\n\t}\n\n\tret = stat(device_path, &sb);\n\tif (ret) {\n\t\tperror(\"device file stat()\");\n\t\tgoto err;\n\t}\n\n\tptr = mmap(NULL, PAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);\n\tif (ptr == (void *)-1) {\n\t\tperror(\"mmap for read\");\n\t\tgoto err;\n\t}\n\tmunmap(ptr, PAGE_SIZE);\n\n#define ERR_MSG \\\n\"mmap() succeeded for PROT_READ, but failed for PROT_EXEC.\\n\" \\\n\" Check that /dev does not have noexec set:\\n\" \\\n\" \\tmount | grep \\\"/dev .*noexec\\\"\\n\" \\\n\" If so, remount it executable: mount -o remount,exec /dev\\n\\n\"\n\n\tptr = mmap(NULL, PAGE_SIZE, PROT_EXEC, MAP_SHARED, fd, 0);\n\tif (ptr == (void *)-1) {\n\t\tfprintf(stderr, ERR_MSG);\n\t\tgoto err;\n\t}\n\tmunmap(ptr, PAGE_SIZE);\n\n\tencl->fd = fd;\n\n\tif (!encl_map_bin(path, encl))\n\t\tgoto err;\n\n\tehdr = encl->bin;\n\tphdr_tbl = encl->bin + ehdr->e_phoff;\n\n\tencl->nr_segments = 1;  \n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tElf64_Phdr *phdr = &phdr_tbl[i];\n\n\t\tif (phdr->p_type == PT_LOAD)\n\t\t\tencl->nr_segments++;\n\t}\n\n\tencl->segment_tbl = calloc(encl->nr_segments,\n\t\t\t\t   sizeof(struct encl_segment));\n\tif (!encl->segment_tbl)\n\t\tgoto err;\n\n\tfor (i = 0, j = 0; i < ehdr->e_phnum; i++) {\n\t\tElf64_Phdr *phdr = &phdr_tbl[i];\n\t\tunsigned int flags = phdr->p_flags;\n\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tseg = &encl->segment_tbl[j];\n\n\t\tif (!!(flags & ~(PF_R | PF_W | PF_X))) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%d has invalid segment flags 0x%02x.\\n\", i,\n\t\t\t\tphdr->p_flags);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (j == 0 && flags != (PF_R | PF_W)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"TCS has invalid segment flags 0x%02x.\\n\",\n\t\t\t\tphdr->p_flags);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (j == 0) {\n\t\t\tsrc_offset = phdr->p_offset & PAGE_MASK;\n\t\t\tencl->src = encl->bin + src_offset;\n\n\t\t\tseg->prot = PROT_READ | PROT_WRITE;\n\t\t\tseg->flags = SGX_PAGE_TYPE_TCS << 8;\n\t\t} else  {\n\t\t\tseg->prot = (phdr->p_flags & PF_R) ? PROT_READ : 0;\n\t\t\tseg->prot |= (phdr->p_flags & PF_W) ? PROT_WRITE : 0;\n\t\t\tseg->prot |= (phdr->p_flags & PF_X) ? PROT_EXEC : 0;\n\t\t\tseg->flags = (SGX_PAGE_TYPE_REG << 8) | seg->prot;\n\t\t}\n\n\t\tseg->offset = (phdr->p_offset & PAGE_MASK) - src_offset;\n\t\tseg->size = (phdr->p_filesz + PAGE_SIZE - 1) & PAGE_MASK;\n\t\tseg->src = encl->src + seg->offset;\n\t\tseg->measure = true;\n\n\t\tj++;\n\t}\n\n\tassert(j == encl->nr_segments - 1);\n\n\tseg = &encl->segment_tbl[j];\n\tseg->offset =  encl->segment_tbl[j - 1].offset + encl->segment_tbl[j - 1].size;\n\tseg->size = heap_size;\n\tseg->src = mmap(NULL, heap_size, PROT_READ | PROT_WRITE,\n\t\t\tMAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n\tseg->prot = PROT_READ | PROT_WRITE;\n\tseg->flags = (SGX_PAGE_TYPE_REG << 8) | seg->prot;\n\tseg->measure = false;\n\n\tif (seg->src == MAP_FAILED)\n\t\tgoto err;\n\n\tencl->src_size = encl->segment_tbl[j].offset + encl->segment_tbl[j].size;\n\n\tfor (encl->encl_size = 4096; encl->encl_size < encl->src_size; )\n\t\tencl->encl_size <<= 1;\n\n\treturn true;\n\nerr:\n\tif (fd != -1)\n\t\tclose(fd);\n\tencl_delete(encl);\n\treturn false;\n}\n\nstatic bool encl_map_area(struct encl *encl)\n{\n\tsize_t encl_size = encl->encl_size;\n\tvoid *area;\n\n\tarea = mmap(NULL, encl_size * 2, PROT_NONE,\n\t\t    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (area == MAP_FAILED) {\n\t\tperror(\"reservation mmap()\");\n\t\treturn false;\n\t}\n\n\tencl->encl_base = ((uint64_t)area + encl_size - 1) & ~(encl_size - 1);\n\n\tmunmap(area, encl->encl_base - (uint64_t)area);\n\tmunmap((void *)(encl->encl_base + encl_size),\n\t       (uint64_t)area + encl_size - encl->encl_base);\n\n\treturn true;\n}\n\nbool encl_build(struct encl *encl)\n{\n\tstruct sgx_enclave_init ioc;\n\tint ret;\n\tint i;\n\n\tif (!encl_map_area(encl))\n\t\treturn false;\n\n\tif (!encl_ioc_create(encl))\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < encl->nr_segments; i++) {\n\t\tstruct encl_segment *seg = &encl->segment_tbl[i];\n\n\t\tif (!encl_ioc_add_pages(encl, seg))\n\t\t\treturn false;\n\t}\n\n\tioc.sigstruct = (uint64_t)&encl->sigstruct;\n\tret = ioctl(encl->fd, SGX_IOC_ENCLAVE_INIT, &ioc);\n\tif (ret) {\n\t\tperror(\"SGX_IOC_ENCLAVE_INIT failed\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}