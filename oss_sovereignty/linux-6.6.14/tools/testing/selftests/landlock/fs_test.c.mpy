{
  "module_name": "fs_test.c",
  "hash_id": "267a8431c05ebb9461f6801e2a61cf8e133dad4eb8687c8416db7ce954071575",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/landlock/fs_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <fcntl.h>\n#include <linux/landlock.h>\n#include <linux/magic.h>\n#include <sched.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/capability.h>\n#include <sys/mount.h>\n#include <sys/prctl.h>\n#include <sys/sendfile.h>\n#include <sys/stat.h>\n#include <sys/sysmacros.h>\n#include <sys/vfs.h>\n#include <unistd.h>\n\n#include \"common.h\"\n\n#ifndef renameat2\nint renameat2(int olddirfd, const char *oldpath, int newdirfd,\n\t      const char *newpath, unsigned int flags)\n{\n\treturn syscall(__NR_renameat2, olddirfd, oldpath, newdirfd, newpath,\n\t\t       flags);\n}\n#endif\n\n#ifndef RENAME_EXCHANGE\n#define RENAME_EXCHANGE (1 << 1)\n#endif\n\n#define TMP_DIR \"tmp\"\n#define BINARY_PATH \"./true\"\n\n \nstatic const char dir_s1d1[] = TMP_DIR \"/s1d1\";\nstatic const char file1_s1d1[] = TMP_DIR \"/s1d1/f1\";\nstatic const char file2_s1d1[] = TMP_DIR \"/s1d1/f2\";\nstatic const char dir_s1d2[] = TMP_DIR \"/s1d1/s1d2\";\nstatic const char file1_s1d2[] = TMP_DIR \"/s1d1/s1d2/f1\";\nstatic const char file2_s1d2[] = TMP_DIR \"/s1d1/s1d2/f2\";\nstatic const char dir_s1d3[] = TMP_DIR \"/s1d1/s1d2/s1d3\";\nstatic const char file1_s1d3[] = TMP_DIR \"/s1d1/s1d2/s1d3/f1\";\nstatic const char file2_s1d3[] = TMP_DIR \"/s1d1/s1d2/s1d3/f2\";\n\nstatic const char dir_s2d1[] = TMP_DIR \"/s2d1\";\nstatic const char file1_s2d1[] = TMP_DIR \"/s2d1/f1\";\nstatic const char dir_s2d2[] = TMP_DIR \"/s2d1/s2d2\";\nstatic const char file1_s2d2[] = TMP_DIR \"/s2d1/s2d2/f1\";\nstatic const char dir_s2d3[] = TMP_DIR \"/s2d1/s2d2/s2d3\";\nstatic const char file1_s2d3[] = TMP_DIR \"/s2d1/s2d2/s2d3/f1\";\nstatic const char file2_s2d3[] = TMP_DIR \"/s2d1/s2d2/s2d3/f2\";\n\nstatic const char dir_s3d1[] = TMP_DIR \"/s3d1\";\nstatic const char file1_s3d1[] = TMP_DIR \"/s3d1/f1\";\n \nstatic const char dir_s3d2[] = TMP_DIR \"/s3d1/s3d2\";\nstatic const char dir_s3d3[] = TMP_DIR \"/s3d1/s3d2/s3d3\";\n\n \n\nstatic bool fgrep(FILE *const inf, const char *const str)\n{\n\tchar line[32];\n\tconst int slen = strlen(str);\n\n\twhile (!feof(inf)) {\n\t\tif (!fgets(line, sizeof(line), inf))\n\t\t\tbreak;\n\t\tif (strncmp(line, str, slen))\n\t\t\tcontinue;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool supports_filesystem(const char *const filesystem)\n{\n\tchar str[32];\n\tint len;\n\tbool res = true;\n\tFILE *const inf = fopen(\"/proc/filesystems\", \"r\");\n\n\t \n\tif (!inf)\n\t\treturn true;\n\n\t \n\tif (!filesystem)\n\t\tgoto out;\n\n\tlen = snprintf(str, sizeof(str), \"nodev\\t%s\\n\", filesystem);\n\tif (len >= sizeof(str))\n\t\t \n\t\tgoto out;\n\n\tres = fgrep(inf, str);\n\nout:\n\tfclose(inf);\n\treturn res;\n}\n\nstatic bool cwd_matches_fs(unsigned int fs_magic)\n{\n\tstruct statfs statfs_buf;\n\n\tif (!fs_magic)\n\t\treturn true;\n\n\tif (statfs(\".\", &statfs_buf))\n\t\treturn true;\n\n\treturn statfs_buf.f_type == fs_magic;\n}\n\nstatic void mkdir_parents(struct __test_metadata *const _metadata,\n\t\t\t  const char *const path)\n{\n\tchar *walker;\n\tconst char *parent;\n\tint i, err;\n\n\tASSERT_NE(path[0], '\\0');\n\twalker = strdup(path);\n\tASSERT_NE(NULL, walker);\n\tparent = walker;\n\tfor (i = 1; walker[i]; i++) {\n\t\tif (walker[i] != '/')\n\t\t\tcontinue;\n\t\twalker[i] = '\\0';\n\t\terr = mkdir(parent, 0700);\n\t\tASSERT_FALSE(err && errno != EEXIST)\n\t\t{\n\t\t\tTH_LOG(\"Failed to create directory \\\"%s\\\": %s\", parent,\n\t\t\t       strerror(errno));\n\t\t}\n\t\twalker[i] = '/';\n\t}\n\tfree(walker);\n}\n\nstatic void create_directory(struct __test_metadata *const _metadata,\n\t\t\t     const char *const path)\n{\n\tmkdir_parents(_metadata, path);\n\tASSERT_EQ(0, mkdir(path, 0700))\n\t{\n\t\tTH_LOG(\"Failed to create directory \\\"%s\\\": %s\", path,\n\t\t       strerror(errno));\n\t}\n}\n\nstatic void create_file(struct __test_metadata *const _metadata,\n\t\t\tconst char *const path)\n{\n\tmkdir_parents(_metadata, path);\n\tASSERT_EQ(0, mknod(path, S_IFREG | 0700, 0))\n\t{\n\t\tTH_LOG(\"Failed to create file \\\"%s\\\": %s\", path,\n\t\t       strerror(errno));\n\t}\n}\n\nstatic int remove_path(const char *const path)\n{\n\tchar *walker;\n\tint i, ret, err = 0;\n\n\twalker = strdup(path);\n\tif (!walker) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\tif (unlink(path) && rmdir(path)) {\n\t\tif (errno != ENOENT && errno != ENOTDIR)\n\t\t\terr = errno;\n\t\tgoto out;\n\t}\n\tfor (i = strlen(walker); i > 0; i--) {\n\t\tif (walker[i] != '/')\n\t\t\tcontinue;\n\t\twalker[i] = '\\0';\n\t\tret = rmdir(walker);\n\t\tif (ret) {\n\t\t\tif (errno != ENOTEMPTY && errno != EBUSY)\n\t\t\t\terr = errno;\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcmp(walker, TMP_DIR) == 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfree(walker);\n\treturn err;\n}\n\nstruct mnt_opt {\n\tconst char *const source;\n\tconst char *const type;\n\tconst unsigned long flags;\n\tconst char *const data;\n};\n\nconst struct mnt_opt mnt_tmp = {\n\t.type = \"tmpfs\",\n\t.data = \"size=4m,mode=700\",\n};\n\nstatic int mount_opt(const struct mnt_opt *const mnt, const char *const target)\n{\n\treturn mount(mnt->source ?: mnt->type, target, mnt->type, mnt->flags,\n\t\t     mnt->data);\n}\n\nstatic void prepare_layout_opt(struct __test_metadata *const _metadata,\n\t\t\t       const struct mnt_opt *const mnt)\n{\n\tdisable_caps(_metadata);\n\tumask(0077);\n\tcreate_directory(_metadata, TMP_DIR);\n\n\t \n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(0, unshare(CLONE_NEWNS | CLONE_NEWCGROUP));\n\tASSERT_EQ(0, mount_opt(mnt, TMP_DIR))\n\t{\n\t\tTH_LOG(\"Failed to mount the %s filesystem: %s\", mnt->type,\n\t\t       strerror(errno));\n\t\t \n\t\tremove_path(TMP_DIR);\n\t}\n\tASSERT_EQ(0, mount(NULL, TMP_DIR, NULL, MS_PRIVATE | MS_REC, NULL));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n}\n\nstatic void prepare_layout(struct __test_metadata *const _metadata)\n{\n\tprepare_layout_opt(_metadata, &mnt_tmp);\n}\n\nstatic void cleanup_layout(struct __test_metadata *const _metadata)\n{\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, umount(TMP_DIR));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, remove_path(TMP_DIR));\n}\n\n \nFIXTURE(layout0) {};\n \n\nFIXTURE_SETUP(layout0)\n{\n\tprepare_layout(_metadata);\n}\n\nFIXTURE_TEARDOWN(layout0)\n{\n\tcleanup_layout(_metadata);\n}\n\nstatic void create_layout1(struct __test_metadata *const _metadata)\n{\n\tcreate_file(_metadata, file1_s1d1);\n\tcreate_file(_metadata, file1_s1d2);\n\tcreate_file(_metadata, file1_s1d3);\n\tcreate_file(_metadata, file2_s1d1);\n\tcreate_file(_metadata, file2_s1d2);\n\tcreate_file(_metadata, file2_s1d3);\n\n\tcreate_file(_metadata, file1_s2d1);\n\tcreate_file(_metadata, file1_s2d2);\n\tcreate_file(_metadata, file1_s2d3);\n\tcreate_file(_metadata, file2_s2d3);\n\n\tcreate_file(_metadata, file1_s3d1);\n\tcreate_directory(_metadata, dir_s3d2);\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(0, mount_opt(&mnt_tmp, dir_s3d2));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\n\tASSERT_EQ(0, mkdir(dir_s3d3, 0700));\n}\n\nstatic void remove_layout1(struct __test_metadata *const _metadata)\n{\n\tEXPECT_EQ(0, remove_path(file2_s1d3));\n\tEXPECT_EQ(0, remove_path(file2_s1d2));\n\tEXPECT_EQ(0, remove_path(file2_s1d1));\n\tEXPECT_EQ(0, remove_path(file1_s1d3));\n\tEXPECT_EQ(0, remove_path(file1_s1d2));\n\tEXPECT_EQ(0, remove_path(file1_s1d1));\n\tEXPECT_EQ(0, remove_path(dir_s1d3));\n\n\tEXPECT_EQ(0, remove_path(file2_s2d3));\n\tEXPECT_EQ(0, remove_path(file1_s2d3));\n\tEXPECT_EQ(0, remove_path(file1_s2d2));\n\tEXPECT_EQ(0, remove_path(file1_s2d1));\n\tEXPECT_EQ(0, remove_path(dir_s2d2));\n\n\tEXPECT_EQ(0, remove_path(file1_s3d1));\n\tEXPECT_EQ(0, remove_path(dir_s3d3));\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tumount(dir_s3d2);\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, remove_path(dir_s3d2));\n}\n\n \nFIXTURE(layout1) {};\n \n\nFIXTURE_SETUP(layout1)\n{\n\tprepare_layout(_metadata);\n\n\tcreate_layout1(_metadata);\n}\n\nFIXTURE_TEARDOWN(layout1)\n{\n\tremove_layout1(_metadata);\n\n\tcleanup_layout(_metadata);\n}\n\n \nstatic int test_open_rel(const int dirfd, const char *const path,\n\t\t\t const int flags)\n{\n\tint fd;\n\n\t \n\tfd = openat(dirfd, path, flags | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn errno;\n\t \n\tif (close(fd) != 0)\n\t\treturn errno;\n\treturn 0;\n}\n\nstatic int test_open(const char *const path, const int flags)\n{\n\treturn test_open_rel(AT_FDCWD, path, flags);\n}\n\nTEST_F_FORK(layout1, no_restriction)\n{\n\tASSERT_EQ(0, test_open(dir_s1d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(file2_s1d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(file2_s1d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\n\tASSERT_EQ(0, test_open(dir_s2d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s2d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s2d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s2d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s2d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s2d3, O_RDONLY));\n\n\tASSERT_EQ(0, test_open(dir_s3d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s3d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s3d3, O_RDONLY));\n}\n\nTEST_F_FORK(layout1, inval)\n{\n\tstruct landlock_path_beneath_attr path_beneath = {\n\t\t.allowed_access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t.parent_fd = -1,\n\t};\n\tstruct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t     LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t};\n\tint ruleset_fd;\n\n\tpath_beneath.parent_fd =\n\t\topen(dir_s1d2, O_PATH | O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath.parent_fd);\n\n\truleset_fd = open(dir_s1d1, O_PATH | O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, ruleset_fd);\n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath, 0));\n\t \n\tASSERT_EQ(EBADF, errno);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\truleset_fd = open(dir_s1d1, O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, ruleset_fd);\n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath, 0));\n\t \n\tASSERT_EQ(EBADFD, errno);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\truleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tASSERT_LE(0, ruleset_fd);\n\tASSERT_EQ(0, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t       &path_beneath, 0));\n\tASSERT_EQ(0, close(path_beneath.parent_fd));\n\n\t \n\tpath_beneath.parent_fd = open(dir_s1d2, O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath.parent_fd);\n\tASSERT_EQ(0, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t       &path_beneath, 0));\n\tASSERT_EQ(0, close(path_beneath.parent_fd));\n\n\t \n\tpath_beneath.parent_fd = ruleset_fd;\n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath, 0));\n\tASSERT_EQ(EBADFD, errno);\n\n\t \n\tpath_beneath.parent_fd =\n\t\topen(dir_s1d2, O_PATH | O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath.parent_fd);\n\n\t \n\tpath_beneath.allowed_access |= LANDLOCK_ACCESS_FS_EXECUTE;\n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath, 0));\n\tASSERT_EQ(EINVAL, errno);\n\tpath_beneath.allowed_access &= ~LANDLOCK_ACCESS_FS_EXECUTE;\n\n\t \n\tpath_beneath.allowed_access |= LANDLOCK_ACCESS_FS_REFER;\n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath, 0));\n\tASSERT_EQ(EINVAL, errno);\n\tpath_beneath.allowed_access &= ~LANDLOCK_ACCESS_FS_REFER;\n\n\t \n\tpath_beneath.allowed_access |= (1ULL << 60);\n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath, 0));\n\tASSERT_EQ(EINVAL, errno);\n\tpath_beneath.allowed_access &= ~(1ULL << 60);\n\n\t \n\tpath_beneath.allowed_access = 0;\n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath, 0));\n\tASSERT_EQ(ENOMSG, errno);\n\tpath_beneath.allowed_access &= ~(1ULL << 60);\n\n\tASSERT_EQ(0, close(path_beneath.parent_fd));\n\n\t \n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\tASSERT_EQ(0, landlock_restrict_self(ruleset_fd, 0));\n\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\n \n\n#define ACCESS_FILE ( \\\n\tLANDLOCK_ACCESS_FS_EXECUTE | \\\n\tLANDLOCK_ACCESS_FS_WRITE_FILE | \\\n\tLANDLOCK_ACCESS_FS_READ_FILE | \\\n\tLANDLOCK_ACCESS_FS_TRUNCATE)\n\n#define ACCESS_LAST LANDLOCK_ACCESS_FS_TRUNCATE\n\n#define ACCESS_ALL ( \\\n\tACCESS_FILE | \\\n\tLANDLOCK_ACCESS_FS_READ_DIR | \\\n\tLANDLOCK_ACCESS_FS_REMOVE_DIR | \\\n\tLANDLOCK_ACCESS_FS_REMOVE_FILE | \\\n\tLANDLOCK_ACCESS_FS_MAKE_CHAR | \\\n\tLANDLOCK_ACCESS_FS_MAKE_DIR | \\\n\tLANDLOCK_ACCESS_FS_MAKE_REG | \\\n\tLANDLOCK_ACCESS_FS_MAKE_SOCK | \\\n\tLANDLOCK_ACCESS_FS_MAKE_FIFO | \\\n\tLANDLOCK_ACCESS_FS_MAKE_BLOCK | \\\n\tLANDLOCK_ACCESS_FS_MAKE_SYM | \\\n\tLANDLOCK_ACCESS_FS_REFER)\n\n \n\nTEST_F_FORK(layout1, file_and_dir_access_rights)\n{\n\t__u64 access;\n\tint err;\n\tstruct landlock_path_beneath_attr path_beneath_file = {},\n\t\t\t\t\t  path_beneath_dir = {};\n\tstruct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = ACCESS_ALL,\n\t};\n\tconst int ruleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\t \n\tpath_beneath_file.parent_fd = open(file1_s1d2, O_PATH | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath_file.parent_fd);\n\n\t \n\tpath_beneath_dir.parent_fd =\n\t\topen(dir_s1d2, O_PATH | O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath_dir.parent_fd);\n\n\tfor (access = 1; access <= ACCESS_LAST; access <<= 1) {\n\t\tpath_beneath_dir.allowed_access = access;\n\t\tASSERT_EQ(0, landlock_add_rule(ruleset_fd,\n\t\t\t\t\t       LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t       &path_beneath_dir, 0));\n\n\t\tpath_beneath_file.allowed_access = access;\n\t\terr = landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath_file, 0);\n\t\tif (access & ACCESS_FILE) {\n\t\t\tASSERT_EQ(0, err);\n\t\t} else {\n\t\t\tASSERT_EQ(-1, err);\n\t\t\tASSERT_EQ(EINVAL, errno);\n\t\t}\n\t}\n\tASSERT_EQ(0, close(path_beneath_file.parent_fd));\n\tASSERT_EQ(0, close(path_beneath_dir.parent_fd));\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\nTEST_F_FORK(layout0, unknown_access_rights)\n{\n\t__u64 access_mask;\n\n\tfor (access_mask = 1ULL << 63; access_mask != ACCESS_LAST;\n\t     access_mask >>= 1) {\n\t\tstruct landlock_ruleset_attr ruleset_attr = {\n\t\t\t.handled_access_fs = access_mask,\n\t\t};\n\n\t\tASSERT_EQ(-1, landlock_create_ruleset(&ruleset_attr,\n\t\t\t\t\t\t      sizeof(ruleset_attr), 0));\n\t\tASSERT_EQ(EINVAL, errno);\n\t}\n}\n\nstatic void add_path_beneath(struct __test_metadata *const _metadata,\n\t\t\t     const int ruleset_fd, const __u64 allowed_access,\n\t\t\t     const char *const path)\n{\n\tstruct landlock_path_beneath_attr path_beneath = {\n\t\t.allowed_access = allowed_access,\n\t};\n\n\tpath_beneath.parent_fd = open(path, O_PATH | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath.parent_fd)\n\t{\n\t\tTH_LOG(\"Failed to open directory \\\"%s\\\": %s\", path,\n\t\t       strerror(errno));\n\t}\n\tASSERT_EQ(0, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t       &path_beneath, 0))\n\t{\n\t\tTH_LOG(\"Failed to update the ruleset with \\\"%s\\\": %s\", path,\n\t\t       strerror(errno));\n\t}\n\tASSERT_EQ(0, close(path_beneath.parent_fd));\n}\n\nstruct rule {\n\tconst char *path;\n\t__u64 access;\n};\n\n \n\n#define ACCESS_RO ( \\\n\tLANDLOCK_ACCESS_FS_READ_FILE | \\\n\tLANDLOCK_ACCESS_FS_READ_DIR)\n\n#define ACCESS_RW ( \\\n\tACCESS_RO | \\\n\tLANDLOCK_ACCESS_FS_WRITE_FILE)\n\n \n\nstatic int create_ruleset(struct __test_metadata *const _metadata,\n\t\t\t  const __u64 handled_access_fs,\n\t\t\t  const struct rule rules[])\n{\n\tint ruleset_fd, i;\n\tstruct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = handled_access_fs,\n\t};\n\n\tASSERT_NE(NULL, rules)\n\t{\n\t\tTH_LOG(\"No rule list\");\n\t}\n\tASSERT_NE(NULL, rules[0].path)\n\t{\n\t\tTH_LOG(\"Empty rule list\");\n\t}\n\n\truleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tASSERT_LE(0, ruleset_fd)\n\t{\n\t\tTH_LOG(\"Failed to create a ruleset: %s\", strerror(errno));\n\t}\n\n\tfor (i = 0; rules[i].path; i++) {\n\t\tadd_path_beneath(_metadata, ruleset_fd, rules[i].access,\n\t\t\t\t rules[i].path);\n\t}\n\treturn ruleset_fd;\n}\n\nstatic void enforce_ruleset(struct __test_metadata *const _metadata,\n\t\t\t    const int ruleset_fd)\n{\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\tASSERT_EQ(0, landlock_restrict_self(ruleset_fd, 0))\n\t{\n\t\tTH_LOG(\"Failed to enforce ruleset: %s\", strerror(errno));\n\t}\n}\n\nTEST_F_FORK(layout0, proc_nsfs)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = \"/dev/null\",\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tstruct landlock_path_beneath_attr path_beneath;\n\tconst int ruleset_fd = create_ruleset(\n\t\t_metadata, rules[0].access | LANDLOCK_ACCESS_FS_READ_DIR,\n\t\trules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tASSERT_EQ(0, test_open(\"/proc/self/ns/mnt\", O_RDONLY));\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\n\tASSERT_EQ(EACCES, test_open(\"/\", O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(\"/dev\", O_RDONLY));\n\tASSERT_EQ(0, test_open(\"/dev/null\", O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(\"/dev/full\", O_RDONLY));\n\n\tASSERT_EQ(EACCES, test_open(\"/proc\", O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(\"/proc/self\", O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(\"/proc/self/ns\", O_RDONLY));\n\t \n\tASSERT_EQ(0, test_open(\"/proc/self/ns/mnt\", O_RDONLY));\n\n\t \n\tpath_beneath.allowed_access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t      LANDLOCK_ACCESS_FS_WRITE_FILE,\n\tpath_beneath.parent_fd = open(\"/proc/self/ns/mnt\", O_PATH | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath.parent_fd);\n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath, 0));\n\tASSERT_EQ(EBADFD, errno);\n\tASSERT_EQ(0, close(path_beneath.parent_fd));\n}\n\nTEST_F_FORK(layout0, unpriv)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = TMP_DIR,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd;\n\n\tdrop_caps(_metadata);\n\n\truleset_fd = create_ruleset(_metadata, ACCESS_RO, rules);\n\tASSERT_LE(0, ruleset_fd);\n\tASSERT_EQ(-1, landlock_restrict_self(ruleset_fd, 0));\n\tASSERT_EQ(EPERM, errno);\n\n\t \n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\nTEST_F_FORK(layout1, effective_access)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{\n\t\t\t.path = file1_s2d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\tchar buf;\n\tint reg_fd;\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(\"/\", O_RDONLY));\n\tASSERT_EQ(0, test_open(\"/\", O_RDONLY | O_PATH));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s1d1, O_RDONLY | O_PATH));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d1, O_RDONLY | O_PATH));\n\n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(dir_s2d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s2d2, O_RDONLY | O_PATH));\n\n\tASSERT_EQ(0, test_open(file1_s2d2, O_RDONLY));\n\n\t \n\treg_fd = open(file1_s2d2, O_RDWR | O_CLOEXEC);\n\tASSERT_LE(0, reg_fd);\n\tASSERT_EQ(1, write(reg_fd, \".\", 1));\n\tASSERT_LE(0, lseek(reg_fd, 0, SEEK_SET));\n\tASSERT_EQ(1, read(reg_fd, &buf, 1));\n\tASSERT_EQ('.', buf);\n\tASSERT_EQ(0, close(reg_fd));\n\n\t \n\treg_fd = open(file1_s2d2, O_RDONLY | O_CLOEXEC);\n\tASSERT_LE(0, reg_fd);\n\tASSERT_EQ(-1, write(reg_fd, &buf, 1));\n\tASSERT_EQ(EBADF, errno);\n\tASSERT_EQ(0, close(reg_fd));\n}\n\nTEST_F_FORK(layout1, unhandled_access)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\t \n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RO, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDWR));\n\n\tASSERT_EQ(0, test_open(file1_s1d2, O_WRONLY));\n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDWR));\n}\n\nTEST_F_FORK(layout1, ruleset_overlap)\n{\n\tconst struct rule rules[] = {\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_READ_DIR,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d2, O_WRONLY));\n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDWR));\n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d3, O_WRONLY));\n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDWR));\n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY | O_DIRECTORY));\n}\n\nTEST_F_FORK(layout1, layer_rule_unions)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer2[] = {\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer3[] = {\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd = create_ruleset(_metadata, ACCESS_RW, layer1);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d3, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer2);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d3, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer3);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d3, O_WRONLY));\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n}\n\nTEST_F_FORK(layout1, non_overlapping_accesses)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_REG,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer2[] = {\n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REMOVE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd;\n\n\tASSERT_EQ(0, unlink(file1_s1d1));\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\n\truleset_fd =\n\t\tcreate_ruleset(_metadata, LANDLOCK_ACCESS_FS_MAKE_REG, layer1);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(-1, mknod(file1_s1d1, S_IFREG | 0700, 0));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(0, mknod(file1_s1d2, S_IFREG | 0700, 0));\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\n\truleset_fd = create_ruleset(_metadata, LANDLOCK_ACCESS_FS_REMOVE_FILE,\n\t\t\t\t    layer2);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(-1, mknod(file1_s1d1, S_IFREG | 0700, 0));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(0, mknod(file1_s1d2, S_IFREG | 0700, 0));\n\n\t \n\tASSERT_EQ(-1, unlink(file1_s1d2));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(0, unlink(file1_s1d3));\n}\n\nTEST_F_FORK(layout1, interleaved_masked_accesses)\n{\n\t \n\tconst struct rule layer1_read[] = {\n\t\t \n\t\t{\n\t\t\t.path = file1_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{},\n\t};\n\t \n\tconst struct rule layer2_read_write[] = {\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer3_read[] = {\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer4_read_write[] = {\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer5_read[] = {\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer6_execute[] = {\n\t\t \n\t\t{\n\t\t\t.path = dir_s2d1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_EXECUTE,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer7_read_write[] = {\n\t\t \n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd;\n\n\truleset_fd = create_ruleset(_metadata, LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t\t\t    layer1_read);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file2_s1d3, O_WRONLY));\n\n\truleset_fd = create_ruleset(_metadata,\n\t\t\t\t    LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t\t    LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t\t\t    layer2_read_write);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file2_s1d3, O_WRONLY));\n\n\truleset_fd = create_ruleset(_metadata, LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t\t\t    layer3_read);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file2_s1d3, O_WRONLY));\n\n\t \n\truleset_fd = create_ruleset(_metadata,\n\t\t\t\t    LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t\t    LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t\t\t    layer4_read_write);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_WRONLY));\n\n\truleset_fd = create_ruleset(_metadata, LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t\t\t    layer5_read);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_RDONLY));\n\n\truleset_fd = create_ruleset(_metadata, LANDLOCK_ACCESS_FS_EXECUTE,\n\t\t\t\t    layer6_execute);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_RDONLY));\n\n\truleset_fd = create_ruleset(_metadata,\n\t\t\t\t    LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t\t    LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t\t\t    layer7_read_write);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(file2_s1d3, O_RDONLY));\n}\n\nTEST_F_FORK(layout1, inherit_subset)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_READ_DIR,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY | O_DIRECTORY));\n\n\t \n\tadd_path_beneath(_metadata, ruleset_fd, LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t\t dir_s1d2);\n\t \n\tenforce_ruleset(_metadata, ruleset_fd);\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY | O_DIRECTORY));\n\n\t \n\tadd_path_beneath(_metadata, ruleset_fd, ACCESS_RW, dir_s1d1);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY | O_DIRECTORY));\n\n\t \n\tadd_path_beneath(_metadata, ruleset_fd, LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t\t dir_s1d3);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY | O_DIRECTORY));\n}\n\nTEST_F_FORK(layout1, inherit_superset)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\n\t \n\tASSERT_EQ(EACCES, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY | O_DIRECTORY));\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\n\t \n\tadd_path_beneath(_metadata, ruleset_fd,\n\t\t\t LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t LANDLOCK_ACCESS_FS_READ_DIR,\n\t\t\t dir_s1d2);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\t \n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY | O_DIRECTORY));\n\t \n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n}\n\nTEST_F_FORK(layout0, max_layers)\n{\n\tint i, err;\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = TMP_DIR,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tfor (i = 0; i < 16; i++)\n\t\tenforce_ruleset(_metadata, ruleset_fd);\n\n\tfor (i = 0; i < 2; i++) {\n\t\terr = landlock_restrict_self(ruleset_fd, 0);\n\t\tASSERT_EQ(-1, err);\n\t\tASSERT_EQ(E2BIG, errno);\n\t}\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\nTEST_F_FORK(layout1, empty_or_same_ruleset)\n{\n\tstruct landlock_ruleset_attr ruleset_attr = {};\n\tint ruleset_fd;\n\n\t \n\truleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tASSERT_LE(-1, ruleset_fd);\n\tASSERT_EQ(ENOMSG, errno);\n\n\t \n\truleset_attr.handled_access_fs = LANDLOCK_ACCESS_FS_READ_FILE;\n\truleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s1d1, O_RDONLY));\n\n\t \n\truleset_attr.handled_access_fs = LANDLOCK_ACCESS_FS_READ_DIR;\n\truleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY));\n\n\t \n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\nTEST_F_FORK(layout1, rule_on_mountpoint)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d1,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{\n\t\t\t \n\t\t\t.path = dir_s3d2,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(0, test_open(dir_s1d1, O_RDONLY));\n\n\tASSERT_EQ(EACCES, test_open(dir_s2d1, O_RDONLY));\n\n\tASSERT_EQ(EACCES, test_open(dir_s3d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s3d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s3d3, O_RDONLY));\n}\n\nTEST_F_FORK(layout1, rule_over_mountpoint)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d1,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{\n\t\t\t \n\t\t\t.path = dir_s3d1,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(0, test_open(dir_s1d1, O_RDONLY));\n\n\tASSERT_EQ(EACCES, test_open(dir_s2d1, O_RDONLY));\n\n\tASSERT_EQ(0, test_open(dir_s3d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s3d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s3d3, O_RDONLY));\n}\n\n \nTEST_F_FORK(layout1, rule_over_root_allow_then_deny)\n{\n\tstruct rule rules[] = {\n\t\t{\n\t\t\t.path = \"/\",\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(\"/\", O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s1d1, O_RDONLY));\n\n\trules[0].access = LANDLOCK_ACCESS_FS_READ_FILE;\n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(\"/\", O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY));\n}\n\nTEST_F_FORK(layout1, rule_over_root_deny)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = \"/\",\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(\"/\", O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY));\n}\n\nTEST_F_FORK(layout1, rule_inside_mount_ns)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = \"s3d3\",\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd;\n\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(0, syscall(__NR_pivot_root, dir_s3d2, dir_s3d3))\n\t{\n\t\tTH_LOG(\"Failed to pivot root: %s\", strerror(errno));\n\t};\n\tASSERT_EQ(0, chdir(\"/\"));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(0, test_open(\"s3d3\", O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(\"/\", O_RDONLY));\n}\n\nTEST_F_FORK(layout1, mount_and_pivot)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s3d2,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(-1, mount(NULL, dir_s3d2, NULL, MS_RDONLY, NULL));\n\tASSERT_EQ(EPERM, errno);\n\tASSERT_EQ(-1, syscall(__NR_pivot_root, dir_s3d2, dir_s3d3));\n\tASSERT_EQ(EPERM, errno);\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n}\n\nTEST_F_FORK(layout1, move_mount)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s3d2,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(0, syscall(__NR_move_mount, AT_FDCWD, dir_s3d2, AT_FDCWD,\n\t\t\t     dir_s1d2, 0))\n\t{\n\t\tTH_LOG(\"Failed to move mount: %s\", strerror(errno));\n\t}\n\n\tASSERT_EQ(0, syscall(__NR_move_mount, AT_FDCWD, dir_s1d2, AT_FDCWD,\n\t\t\t     dir_s3d2, 0));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(-1, syscall(__NR_move_mount, AT_FDCWD, dir_s3d2, AT_FDCWD,\n\t\t\t      dir_s1d2, 0));\n\tASSERT_EQ(EPERM, errno);\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n}\n\nTEST_F_FORK(layout1, release_inodes)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d1,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s3d2,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s3d3,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, ACCESS_RW, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\t \n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(0, umount(dir_s3d2));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(0, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s3d2, O_RDONLY));\n\t \n\tASSERT_EQ(ENOENT, test_open(dir_s3d3, O_RDONLY));\n}\n\nenum relative_access {\n\tREL_OPEN,\n\tREL_CHDIR,\n\tREL_CHROOT_ONLY,\n\tREL_CHROOT_CHDIR,\n};\n\nstatic void test_relative_path(struct __test_metadata *const _metadata,\n\t\t\t       const enum relative_access rel)\n{\n\t \n\tconst struct rule layer1_base[] = {\n\t\t{\n\t\t\t.path = TMP_DIR,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer2_subs[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d2,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{},\n\t};\n\tint dirfd, ruleset_fd;\n\n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer1_base);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer2_subs);\n\n\tASSERT_LE(0, ruleset_fd);\n\tswitch (rel) {\n\tcase REL_OPEN:\n\tcase REL_CHDIR:\n\t\tbreak;\n\tcase REL_CHROOT_ONLY:\n\t\tASSERT_EQ(0, chdir(dir_s2d2));\n\t\tbreak;\n\tcase REL_CHROOT_CHDIR:\n\t\tASSERT_EQ(0, chdir(dir_s1d2));\n\t\tbreak;\n\tdefault:\n\t\tASSERT_TRUE(false);\n\t\treturn;\n\t}\n\n\tset_cap(_metadata, CAP_SYS_CHROOT);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\n\tswitch (rel) {\n\tcase REL_OPEN:\n\t\tdirfd = open(dir_s1d2, O_DIRECTORY);\n\t\tASSERT_LE(0, dirfd);\n\t\tbreak;\n\tcase REL_CHDIR:\n\t\tASSERT_EQ(0, chdir(dir_s1d2));\n\t\tdirfd = AT_FDCWD;\n\t\tbreak;\n\tcase REL_CHROOT_ONLY:\n\t\t \n\t\tASSERT_EQ(0, chroot(\"../../s1d1/s1d2\"))\n\t\t{\n\t\t\tTH_LOG(\"Failed to chroot: %s\", strerror(errno));\n\t\t}\n\t\tdirfd = AT_FDCWD;\n\t\tbreak;\n\tcase REL_CHROOT_CHDIR:\n\t\t \n\t\tASSERT_EQ(0, chroot(\".\"))\n\t\t{\n\t\t\tTH_LOG(\"Failed to chroot: %s\", strerror(errno));\n\t\t}\n\t\tdirfd = AT_FDCWD;\n\t\tbreak;\n\t}\n\n\tASSERT_EQ((rel == REL_CHROOT_CHDIR) ? 0 : EACCES,\n\t\t  test_open_rel(dirfd, \"..\", O_RDONLY));\n\tASSERT_EQ(0, test_open_rel(dirfd, \".\", O_RDONLY));\n\n\tif (rel == REL_CHROOT_ONLY) {\n\t\t \n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"./s2d3\", O_RDONLY));\n\t} else {\n\t\t \n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"./s1d3\", O_RDONLY));\n\t}\n\n\tif (rel == REL_CHROOT_ONLY || rel == REL_CHROOT_CHDIR) {\n\t\t \n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"/..\", O_RDONLY));\n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"/\", O_RDONLY));\n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"/f1\", O_RDONLY));\n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"/s1d3\", O_RDONLY));\n\t}\n\n\tif (rel != REL_CHROOT_CHDIR) {\n\t\tASSERT_EQ(EACCES, test_open_rel(dirfd, \"../../s1d1\", O_RDONLY));\n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"../../s1d1/s1d2\", O_RDONLY));\n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"../../s1d1/s1d2/s1d3\",\n\t\t\t\t\t   O_RDONLY));\n\n\t\tASSERT_EQ(EACCES, test_open_rel(dirfd, \"../../s2d1\", O_RDONLY));\n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"../../s2d1/s2d2\", O_RDONLY));\n\t\tASSERT_EQ(0, test_open_rel(dirfd, \"../../s2d1/s2d2/s2d3\",\n\t\t\t\t\t   O_RDONLY));\n\t}\n\n\tif (rel == REL_OPEN)\n\t\tASSERT_EQ(0, close(dirfd));\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\nTEST_F_FORK(layout1, relative_open)\n{\n\ttest_relative_path(_metadata, REL_OPEN);\n}\n\nTEST_F_FORK(layout1, relative_chdir)\n{\n\ttest_relative_path(_metadata, REL_CHDIR);\n}\n\nTEST_F_FORK(layout1, relative_chroot_only)\n{\n\ttest_relative_path(_metadata, REL_CHROOT_ONLY);\n}\n\nTEST_F_FORK(layout1, relative_chroot_chdir)\n{\n\ttest_relative_path(_metadata, REL_CHROOT_CHDIR);\n}\n\nstatic void copy_binary(struct __test_metadata *const _metadata,\n\t\t\tconst char *const dst_path)\n{\n\tint dst_fd, src_fd;\n\tstruct stat statbuf;\n\n\tdst_fd = open(dst_path, O_WRONLY | O_TRUNC | O_CLOEXEC);\n\tASSERT_LE(0, dst_fd)\n\t{\n\t\tTH_LOG(\"Failed to open \\\"%s\\\": %s\", dst_path, strerror(errno));\n\t}\n\tsrc_fd = open(BINARY_PATH, O_RDONLY | O_CLOEXEC);\n\tASSERT_LE(0, src_fd)\n\t{\n\t\tTH_LOG(\"Failed to open \\\"\" BINARY_PATH \"\\\": %s\",\n\t\t       strerror(errno));\n\t}\n\tASSERT_EQ(0, fstat(src_fd, &statbuf));\n\tASSERT_EQ(statbuf.st_size,\n\t\t  sendfile(dst_fd, src_fd, 0, statbuf.st_size));\n\tASSERT_EQ(0, close(src_fd));\n\tASSERT_EQ(0, close(dst_fd));\n}\n\nstatic void test_execute(struct __test_metadata *const _metadata, const int err,\n\t\t\t const char *const path)\n{\n\tint status;\n\tchar *const argv[] = { (char *)path, NULL };\n\tconst pid_t child = fork();\n\n\tASSERT_LE(0, child);\n\tif (child == 0) {\n\t\tASSERT_EQ(err ? -1 : 0, execve(path, argv, NULL))\n\t\t{\n\t\t\tTH_LOG(\"Failed to execute \\\"%s\\\": %s\", path,\n\t\t\t       strerror(errno));\n\t\t};\n\t\tASSERT_EQ(err, errno);\n\t\t_exit(_metadata->passed ? 2 : 1);\n\t\treturn;\n\t}\n\tASSERT_EQ(child, waitpid(child, &status, 0));\n\tASSERT_EQ(1, WIFEXITED(status));\n\tASSERT_EQ(err ? 2 : 0, WEXITSTATUS(status))\n\t{\n\t\tTH_LOG(\"Unexpected return code for \\\"%s\\\": %s\", path,\n\t\t       strerror(errno));\n\t};\n}\n\nTEST_F_FORK(layout1, execute)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_EXECUTE,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd =\n\t\tcreate_ruleset(_metadata, rules[0].access, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tcopy_binary(_metadata, file1_s1d1);\n\tcopy_binary(_metadata, file1_s1d2);\n\tcopy_binary(_metadata, file1_s1d3);\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(0, test_open(dir_s1d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d1, O_RDONLY));\n\ttest_execute(_metadata, EACCES, file1_s1d1);\n\n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\ttest_execute(_metadata, 0, file1_s1d2);\n\n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\ttest_execute(_metadata, 0, file1_s1d3);\n}\n\nTEST_F_FORK(layout1, link)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_REG,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer2[] = {\n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REMOVE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd = create_ruleset(_metadata, layer1[0].access, layer1);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\tASSERT_EQ(0, unlink(file1_s1d1));\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(-1, link(file2_s1d1, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, link(file1_s2d1, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, link(file2_s1d2, file1_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, link(file2_s1d3, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\n\tASSERT_EQ(0, link(file2_s1d2, file1_s1d2));\n\tASSERT_EQ(0, link(file2_s1d3, file1_s1d3));\n\n\t \n\tASSERT_EQ(0, unlink(file2_s1d2));\n\tASSERT_EQ(0, unlink(file2_s1d3));\n\n\truleset_fd = create_ruleset(_metadata, layer2[0].access, layer2);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, link(file1_s1d2, file2_s1d2));\n\tASSERT_EQ(0, link(file1_s1d3, file2_s1d3));\n}\n\nstatic int test_rename(const char *const oldpath, const char *const newpath)\n{\n\tif (rename(oldpath, newpath))\n\t\treturn errno;\n\treturn 0;\n}\n\nstatic int test_exchange(const char *const oldpath, const char *const newpath)\n{\n\tif (renameat2(AT_FDCWD, oldpath, AT_FDCWD, newpath, RENAME_EXCHANGE))\n\t\treturn errno;\n\treturn 0;\n}\n\nTEST_F_FORK(layout1, rename_file)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REMOVE_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REMOVE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd =\n\t\tcreate_ruleset(_metadata, rules[0].access, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(-1, rename(file1_s2d3, file1_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d3, AT_FDCWD, file1_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d3, AT_FDCWD, dir_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s2d1, file1_s1d3));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d1, AT_FDCWD, file1_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_s2d2, AT_FDCWD, file1_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_s2d2, AT_FDCWD, file1_s2d1,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(-1, rename(dir_s2d2, file1_s2d1));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d1, AT_FDCWD, dir_s2d2,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(-1, rename(file1_s1d1, dir_s1d2));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s2d2, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\tASSERT_EQ(-1, rename(file1_s2d1, file1_s1d3));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(0, renameat2(AT_FDCWD, file2_s2d3, AT_FDCWD, file1_s2d3,\n\t\t\t       RENAME_EXCHANGE));\n\tASSERT_EQ(0, rename(file2_s2d3, file1_s2d3));\n\n\t \n\tASSERT_EQ(0, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, dir_s2d3,\n\t\t\t       RENAME_EXCHANGE));\n\tASSERT_EQ(0, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, dir_s2d3,\n\t\t\t       RENAME_EXCHANGE));\n}\n\nTEST_F_FORK(layout1, rename_dir)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REMOVE_DIR,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REMOVE_DIR,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd =\n\t\tcreate_ruleset(_metadata, rules[0].access, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\t \n\tASSERT_EQ(0, unlink(file1_s1d3));\n\tASSERT_EQ(0, unlink(file2_s1d3));\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_s2d3, AT_FDCWD, dir_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, rename(dir_s2d3, dir_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, dir_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_s1d1, AT_FDCWD, dir_s2d1,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(-1, rename(dir_s1d2, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s1d1, AT_FDCWD, dir_s1d2,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(-1, rename(file1_s1d1, dir_s1d2));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(0, renameat2(AT_FDCWD, dir_s1d3, AT_FDCWD, file1_s1d2,\n\t\t\t       RENAME_EXCHANGE));\n\tASSERT_EQ(0, unlink(dir_s1d3));\n\tASSERT_EQ(0, mkdir(dir_s1d3, 0700));\n\tASSERT_EQ(0, rename(file1_s1d2, dir_s1d3));\n\tASSERT_EQ(0, rmdir(dir_s1d3));\n}\n\nTEST_F_FORK(layout1, reparent_refer)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd =\n\t\tcreate_ruleset(_metadata, LANDLOCK_ACCESS_FS_REFER, layer1);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(-1, rename(dir_s1d2, dir_s2d1));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, rename(dir_s1d2, dir_s2d2));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, rename(dir_s1d2, dir_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n\n\tASSERT_EQ(-1, rename(dir_s1d3, dir_s2d1));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, rename(dir_s1d3, dir_s2d2));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(-1, rename(dir_s1d3, dir_s2d3));\n\tASSERT_EQ(ENOTEMPTY, errno);\n\tASSERT_EQ(0, unlink(file1_s2d3));\n\tASSERT_EQ(0, unlink(file2_s2d3));\n\tASSERT_EQ(0, rename(dir_s1d3, dir_s2d3));\n}\n\n \nstatic void refer_denied_by_default(struct __test_metadata *const _metadata,\n\t\t\t\t    const struct rule layer1[],\n\t\t\t\t    const int layer1_err,\n\t\t\t\t    const struct rule layer2[])\n{\n\tint ruleset_fd;\n\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\n\truleset_fd = create_ruleset(_metadata, layer1[0].access, layer1);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(layer1_err, test_rename(file1_s1d1, file1_s1d2));\n\tif (layer1_err == 0)\n\t\tASSERT_EQ(layer1_err, test_rename(file1_s1d2, file1_s1d1));\n\tASSERT_EQ(layer1_err, test_exchange(file2_s1d1, file2_s1d2));\n\tASSERT_EQ(layer1_err, test_exchange(file2_s1d2, file2_s1d1));\n\n\truleset_fd = create_ruleset(_metadata, layer2[0].access, layer2);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EXDEV, test_rename(file1_s1d1, file1_s1d2));\n\tASSERT_EQ(EXDEV, test_exchange(file2_s1d1, file2_s1d2));\n\tASSERT_EQ(EXDEV, test_exchange(file2_s1d2, file2_s1d1));\n}\n\nconst struct rule layer_dir_s1d1_refer[] = {\n\t{\n\t\t.path = dir_s1d1,\n\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t},\n\t{},\n};\n\nconst struct rule layer_dir_s1d1_execute[] = {\n\t{\n\t\t \n\t\t.path = dir_s1d1,\n\t\t.access = LANDLOCK_ACCESS_FS_EXECUTE,\n\t},\n\t{},\n};\n\nconst struct rule layer_dir_s2d1_execute[] = {\n\t{\n\t\t \n\t\t.path = dir_s2d1,\n\t\t.access = LANDLOCK_ACCESS_FS_EXECUTE,\n\t},\n\t{},\n};\n\n \nTEST_F_FORK(layout1, refer_denied_by_default1)\n{\n\trefer_denied_by_default(_metadata, layer_dir_s1d1_refer, 0,\n\t\t\t\tlayer_dir_s1d1_execute);\n}\n\n \nTEST_F_FORK(layout1, refer_denied_by_default2)\n{\n\trefer_denied_by_default(_metadata, layer_dir_s1d1_execute, EXDEV,\n\t\t\t\tlayer_dir_s1d1_refer);\n}\n\n \nTEST_F_FORK(layout1, refer_denied_by_default3)\n{\n\trefer_denied_by_default(_metadata, layer_dir_s1d1_refer, 0,\n\t\t\t\tlayer_dir_s2d1_execute);\n}\n\n \nTEST_F_FORK(layout1, refer_denied_by_default4)\n{\n\trefer_denied_by_default(_metadata, layer_dir_s2d1_execute, EXDEV,\n\t\t\t\tlayer_dir_s1d1_refer);\n}\n\nTEST_F_FORK(layout1, reparent_link)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_REG,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_REG,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(\n\t\t_metadata,\n\t\tLANDLOCK_ACCESS_FS_MAKE_REG | LANDLOCK_ACCESS_FS_REFER, layer1);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(0, unlink(file1_s1d1));\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\n\t \n\tASSERT_EQ(-1, link(file2_s1d1, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(-1, link(file1_s2d1, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(-1, link(file1_s2d1, file1_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(-1, link(file1_s2d2, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(-1, link(file1_s2d2, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(0, link(file1_s2d2, file1_s1d3));\n\tASSERT_EQ(0, unlink(file1_s2d2));\n\t \n\tASSERT_EQ(-1, link(file1_s1d3, file1_s2d2));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(0, unlink(file1_s2d3));\n\t \n\tASSERT_EQ(0, link(file1_s1d3, file1_s2d3));\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\n\t \n\tASSERT_EQ(0, link(file1_s2d3, file1_s1d3));\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\n\tASSERT_EQ(-1, link(file2_s1d2, file1_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, link(file2_s1d3, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\n\tASSERT_EQ(0, link(file2_s1d2, file1_s1d2));\n\tASSERT_EQ(0, link(file2_s1d3, file1_s1d3));\n}\n\nTEST_F_FORK(layout1, reparent_rename)\n{\n\t \n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_REG,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_REG,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(\n\t\t_metadata,\n\t\tLANDLOCK_ACCESS_FS_MAKE_REG | LANDLOCK_ACCESS_FS_REFER, layer1);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file2_s1d1, AT_FDCWD, file1_s1d1,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s1d1, AT_FDCWD, file2_s1d1,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(0, unlink(file1_s1d1));\n\tASSERT_EQ(-1, rename(file2_s1d1, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file2_s1d1, AT_FDCWD, file2_s1d1,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s2d1, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d1, AT_FDCWD, file2_s1d1,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file2_s1d1, AT_FDCWD, file1_s2d1,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s2d1, file1_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d1, AT_FDCWD, file2_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s2d2, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(-1, rename(file1_s2d2, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, file2_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(0, rename(file1_s2d2, file1_s1d3));\n\n\t \n\tASSERT_EQ(-1, rename(file1_s1d3, file1_s2d2));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(0, unlink(file1_s2d3));\n\tASSERT_EQ(0, rename(file1_s1d3, file1_s2d3));\n\n\t \n\tASSERT_EQ(0, rename(file1_s2d3, file1_s1d3));\n\tASSERT_EQ(0, renameat2(AT_FDCWD, file2_s2d3, AT_FDCWD, file1_s1d3,\n\t\t\t       RENAME_EXCHANGE));\n\tASSERT_EQ(0, rename(file1_s1d3, file1_s2d3));\n\n\t \n\tASSERT_EQ(0, rename(file1_s2d3, file1_s1d3));\n\tASSERT_EQ(0, rename(file1_s1d3, file1_s2d3));\n\n\t \n\tASSERT_EQ(0, rename(dir_s2d3, file1_s1d3));\n\tASSERT_EQ(0, rename(file1_s1d3, dir_s2d3));\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d3, AT_FDCWD, dir_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_s1d3, AT_FDCWD, file1_s2d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, rename(file1_s2d3, dir_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n\n\tASSERT_EQ(-1, rename(file2_s1d2, file1_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, rename(file2_s1d3, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(0, rename(file2_s1d2, file1_s1d2));\n\tASSERT_EQ(0, rename(file2_s1d3, file1_s1d3));\n\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\t \n\tASSERT_EQ(-1, rename(dir_s2d3, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\t \n\tASSERT_EQ(-1, rename(dir_s2d2, file1_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n}\n\nstatic void\nreparent_exdev_layers_enforce1(struct __test_metadata *const _metadata)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{\n\t\t\t \n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_REG,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_REG,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(\n\t\t_metadata,\n\t\tLANDLOCK_ACCESS_FS_MAKE_REG | LANDLOCK_ACCESS_FS_REFER, layer1);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\nstatic void\nreparent_exdev_layers_enforce2(struct __test_metadata *const _metadata)\n{\n\tconst struct rule layer2[] = {\n\t\t{\n\t\t\t.path = dir_s2d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_DIR,\n\t\t},\n\t\t{},\n\t};\n\t \n\tconst int ruleset_fd =\n\t\tcreate_ruleset(_metadata, LANDLOCK_ACCESS_FS_MAKE_DIR, layer2);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\nTEST_F_FORK(layout1, reparent_exdev_layers_rename1)\n{\n\tASSERT_EQ(0, unlink(file1_s2d2));\n\tASSERT_EQ(0, unlink(file1_s2d3));\n\n\treparent_exdev_layers_enforce1(_metadata);\n\n\t \n\tASSERT_EQ(0, rename(dir_s1d3, file1_s2d2));\n\tASSERT_EQ(0, rename(file1_s2d2, dir_s1d3));\n\n\t \n\tASSERT_EQ(0, rename(dir_s1d3, file1_s2d3));\n\tASSERT_EQ(0, rename(file1_s2d3, dir_s1d3));\n\n\t \n\tASSERT_EQ(0, rename(file1_s1d3, file1_s2d3));\n\n\treparent_exdev_layers_enforce2(_metadata);\n\n\t \n\tASSERT_EQ(-1, rename(dir_s1d3, file1_s2d2));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, rename(dir_s1d3, file1_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(-1, rename(file2_s1d3, file1_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n}\n\nTEST_F_FORK(layout1, reparent_exdev_layers_rename2)\n{\n\treparent_exdev_layers_enforce1(_metadata);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s1d1, file1_s2d2));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, rename(file1_s1d2, file1_s2d2));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, rename(file1_s1d1, file1_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(0, rename(file1_s1d2, file1_s2d3));\n\n\t \n\tASSERT_EQ(-1, rename(dir_s1d1, file1_s2d2));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, rename(dir_s1d2, file1_s2d2));\n\tASSERT_EQ(EXDEV, errno);\n\n\treparent_exdev_layers_enforce2(_metadata);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s1d1, file1_s2d2));\n\tASSERT_EQ(EACCES, errno);\n\t \n\tASSERT_EQ(-1, rename(file2_s1d2, file1_s2d2));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, rename(file1_s1d1, file1_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(-1, rename(file2_s1d2, file1_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(-1, rename(dir_s1d1, file1_s2d2));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, rename(dir_s1d2, file1_s2d2));\n\tASSERT_EQ(EACCES, errno);\n}\n\nTEST_F_FORK(layout1, reparent_exdev_layers_exchange1)\n{\n\tconst char *const dir_file1_s1d2 = file1_s1d2, *const dir_file2_s2d3 =\n\t\t\t\t\t\t\t       file2_s2d3;\n\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\tASSERT_EQ(0, mkdir(file1_s1d2, 0700));\n\tASSERT_EQ(0, unlink(file2_s2d3));\n\tASSERT_EQ(0, mkdir(file2_s2d3, 0700));\n\n\treparent_exdev_layers_enforce1(_metadata);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s1d1, AT_FDCWD, file1_s2d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d3, AT_FDCWD, file1_s1d1,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_file1_s1d2, AT_FDCWD,\n\t\t\t\tdir_file2_s2d3, RENAME_EXCHANGE));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_file2_s2d3, AT_FDCWD,\n\t\t\t\tdir_file1_s1d2, RENAME_EXCHANGE));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(0, renameat2(AT_FDCWD, dir_s1d3, AT_FDCWD, dir_s2d3,\n\t\t\t       RENAME_EXCHANGE));\n\tASSERT_EQ(0, renameat2(AT_FDCWD, dir_s2d3, AT_FDCWD, dir_s1d3,\n\t\t\t       RENAME_EXCHANGE));\n\n\t \n\tASSERT_EQ(0, renameat2(AT_FDCWD, dir_s2d3, AT_FDCWD, dir_file1_s1d2,\n\t\t\t       RENAME_EXCHANGE));\n\tASSERT_EQ(0, renameat2(AT_FDCWD, dir_file1_s1d2, AT_FDCWD, dir_s2d3,\n\t\t\t       RENAME_EXCHANGE));\n\n\t \n\tASSERT_EQ(0, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, dir_file2_s2d3,\n\t\t\t       RENAME_EXCHANGE));\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_file2_s2d3, AT_FDCWD, file1_s2d2,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, dir_file2_s2d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\treparent_exdev_layers_enforce2(_metadata);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s1d1, AT_FDCWD, file1_s2d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d3, AT_FDCWD, file1_s1d1,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_file1_s1d2, AT_FDCWD,\n\t\t\t\tdir_file2_s2d3, RENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_file2_s2d3, AT_FDCWD,\n\t\t\t\tdir_file1_s1d2, RENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_s1d3, AT_FDCWD, dir_s2d3,\n\t\t\t\tRENAME_EXCHANGE));\n\t \n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_s2d3, AT_FDCWD, dir_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_s2d3, AT_FDCWD, dir_file1_s1d2,\n\t\t\t\tRENAME_EXCHANGE));\n\t \n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_file1_s1d2, AT_FDCWD, dir_s2d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n}\n\nTEST_F_FORK(layout1, reparent_exdev_layers_exchange2)\n{\n\tconst char *const dir_file2_s2d3 = file2_s2d3;\n\n\tASSERT_EQ(0, unlink(file2_s2d3));\n\tASSERT_EQ(0, mkdir(file2_s2d3, 0700));\n\n\treparent_exdev_layers_enforce1(_metadata);\n\treparent_exdev_layers_enforce2(_metadata);\n\n\t \n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, dir_file2_s2d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_file2_s2d3, AT_FDCWD, file1_s2d2,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n}\n\nTEST_F_FORK(layout1, reparent_exdev_layers_exchange3)\n{\n\tconst char *const dir_file2_s2d3 = file2_s2d3;\n\n\tASSERT_EQ(0, unlink(file2_s2d3));\n\tASSERT_EQ(0, mkdir(file2_s2d3, 0700));\n\n\treparent_exdev_layers_enforce1(_metadata);\n\n\t \n\tASSERT_EQ(0, renameat2(AT_FDCWD, dir_file2_s2d3, AT_FDCWD, file1_s2d2,\n\t\t\t       RENAME_EXCHANGE));\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, dir_file2_s2d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, dir_file2_s2d3, AT_FDCWD, file1_s2d2,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n}\n\nTEST_F_FORK(layout1, reparent_remove)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = dir_s1d1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER |\n\t\t\t\t  LANDLOCK_ACCESS_FS_REMOVE_DIR,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REMOVE_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER |\n\t\t\t\t  LANDLOCK_ACCESS_FS_REMOVE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(\n\t\t_metadata,\n\t\tLANDLOCK_ACCESS_FS_REFER | LANDLOCK_ACCESS_FS_REMOVE_DIR |\n\t\t\tLANDLOCK_ACCESS_FS_REMOVE_FILE,\n\t\tlayer1);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(-1, rename(file1_s1d1, dir_s2d2));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, rename(dir_s2d2, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s1d1, AT_FDCWD, dir_s2d2,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s1d1, AT_FDCWD, dir_s2d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s2d1, dir_s1d2));\n\tASSERT_EQ(EISDIR, errno);\n\tASSERT_EQ(-1, rename(dir_s1d2, file1_s2d1));\n\tASSERT_EQ(ENOTDIR, errno);\n\tASSERT_EQ(-1, rename(dir_s1d3, file1_s2d1));\n\tASSERT_EQ(ENOTDIR, errno);\n\tASSERT_EQ(0, unlink(file1_s2d1));\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\tASSERT_EQ(0, unlink(file2_s1d3));\n\tASSERT_EQ(0, rename(dir_s1d3, file1_s2d1));\n\n\t \n\tASSERT_EQ(0, mkdir(dir_s1d3, 0700));\n\tASSERT_EQ(0, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, dir_s1d3,\n\t\t\t       RENAME_EXCHANGE));\n\tASSERT_EQ(-1, renameat2(AT_FDCWD, file1_s2d2, AT_FDCWD, dir_s1d3,\n\t\t\t\tRENAME_EXCHANGE));\n\tASSERT_EQ(EACCES, errno);\n}\n\nTEST_F_FORK(layout1, reparent_dom_superset)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{\n\t\t\t.path = file1_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_EXECUTE,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_SOCK |\n\t\t\t\t  LANDLOCK_ACCESS_FS_EXECUTE,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER |\n\t\t\t\t  LANDLOCK_ACCESS_FS_EXECUTE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_MAKE_SOCK,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_MAKE_FIFO,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd = create_ruleset(_metadata,\n\t\t\t\t\tLANDLOCK_ACCESS_FS_REFER |\n\t\t\t\t\t\tLANDLOCK_ACCESS_FS_EXECUTE |\n\t\t\t\t\t\tLANDLOCK_ACCESS_FS_MAKE_SOCK |\n\t\t\t\t\t\tLANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t\t\tLANDLOCK_ACCESS_FS_MAKE_FIFO,\n\t\t\t\t\tlayer1);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(-1, rename(file1_s1d2, file1_s2d1));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(-1, rename(file1_s1d2, file1_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(0, rename(file1_s1d2, file1_s2d2));\n\tASSERT_EQ(0, rename(file1_s2d2, file1_s1d2));\n\n\tASSERT_EQ(-1, rename(dir_s1d3, file1_s2d1));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(-1, rename(dir_s1d3, file1_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n\t \n\tASSERT_EQ(0, rename(dir_s1d3, file1_s2d2));\n\tASSERT_EQ(0, rename(file1_s2d2, dir_s1d3));\n\n\t \n\tASSERT_EQ(0, rename(file1_s2d3, file2_s1d2));\n\tASSERT_EQ(-1, rename(file2_s1d2, file1_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n\tASSERT_EQ(0, unlink(file2_s1d2));\n\tASSERT_EQ(0, unlink(file2_s2d3));\n\t \n\tASSERT_EQ(0, rename(dir_s2d3, file2_s1d2));\n\tASSERT_EQ(-1, rename(file2_s1d2, dir_s2d3));\n\tASSERT_EQ(EXDEV, errno);\n}\n\nTEST_F_FORK(layout1, remove_dir)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REMOVE_DIR,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd =\n\t\tcreate_ruleset(_metadata, rules[0].access, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\tASSERT_EQ(0, unlink(file1_s1d1));\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\tASSERT_EQ(0, unlink(file2_s1d3));\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(0, rmdir(dir_s1d3));\n\tASSERT_EQ(0, mkdir(dir_s1d3, 0700));\n\tASSERT_EQ(0, unlinkat(AT_FDCWD, dir_s1d3, AT_REMOVEDIR));\n\n\t \n\tASSERT_EQ(-1, rmdir(dir_s1d2));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, unlinkat(AT_FDCWD, dir_s1d2, AT_REMOVEDIR));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, rmdir(dir_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, unlinkat(AT_FDCWD, dir_s1d1, AT_REMOVEDIR));\n\tASSERT_EQ(EACCES, errno);\n}\n\nTEST_F_FORK(layout1, remove_file)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REMOVE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd =\n\t\tcreate_ruleset(_metadata, rules[0].access, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(-1, unlink(file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, unlinkat(AT_FDCWD, file1_s1d1, 0));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\tASSERT_EQ(0, unlinkat(AT_FDCWD, file1_s1d3, 0));\n}\n\nstatic void test_make_file(struct __test_metadata *const _metadata,\n\t\t\t   const __u64 access, const mode_t mode,\n\t\t\t   const dev_t dev)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = access,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd = create_ruleset(_metadata, access, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\tASSERT_EQ(0, unlink(file1_s1d1));\n\tASSERT_EQ(0, unlink(file2_s1d1));\n\tASSERT_EQ(0, mknod(file2_s1d1, mode | 0400, dev))\n\t{\n\t\tTH_LOG(\"Failed to make file \\\"%s\\\": %s\", file2_s1d1,\n\t\t       strerror(errno));\n\t};\n\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\tASSERT_EQ(0, unlink(file2_s1d2));\n\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\tASSERT_EQ(0, unlink(file2_s1d3));\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(-1, mknod(file1_s1d1, mode | 0400, dev));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, link(file2_s1d1, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, rename(file2_s1d1, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\n\tASSERT_EQ(0, mknod(file1_s1d2, mode | 0400, dev))\n\t{\n\t\tTH_LOG(\"Failed to make file \\\"%s\\\": %s\", file1_s1d2,\n\t\t       strerror(errno));\n\t};\n\tASSERT_EQ(0, link(file1_s1d2, file2_s1d2));\n\tASSERT_EQ(0, unlink(file2_s1d2));\n\tASSERT_EQ(0, rename(file1_s1d2, file2_s1d2));\n\n\tASSERT_EQ(0, mknod(file1_s1d3, mode | 0400, dev));\n\tASSERT_EQ(0, link(file1_s1d3, file2_s1d3));\n\tASSERT_EQ(0, unlink(file2_s1d3));\n\tASSERT_EQ(0, rename(file1_s1d3, file2_s1d3));\n}\n\nTEST_F_FORK(layout1, make_char)\n{\n\t \n\tset_cap(_metadata, CAP_MKNOD);\n\ttest_make_file(_metadata, LANDLOCK_ACCESS_FS_MAKE_CHAR, S_IFCHR,\n\t\t       makedev(1, 3));\n}\n\nTEST_F_FORK(layout1, make_block)\n{\n\t \n\tset_cap(_metadata, CAP_MKNOD);\n\ttest_make_file(_metadata, LANDLOCK_ACCESS_FS_MAKE_BLOCK, S_IFBLK,\n\t\t       makedev(7, 0));\n}\n\nTEST_F_FORK(layout1, make_reg_1)\n{\n\ttest_make_file(_metadata, LANDLOCK_ACCESS_FS_MAKE_REG, S_IFREG, 0);\n}\n\nTEST_F_FORK(layout1, make_reg_2)\n{\n\ttest_make_file(_metadata, LANDLOCK_ACCESS_FS_MAKE_REG, 0, 0);\n}\n\nTEST_F_FORK(layout1, make_sock)\n{\n\ttest_make_file(_metadata, LANDLOCK_ACCESS_FS_MAKE_SOCK, S_IFSOCK, 0);\n}\n\nTEST_F_FORK(layout1, make_fifo)\n{\n\ttest_make_file(_metadata, LANDLOCK_ACCESS_FS_MAKE_FIFO, S_IFIFO, 0);\n}\n\nTEST_F_FORK(layout1, make_sym)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_SYM,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd =\n\t\tcreate_ruleset(_metadata, rules[0].access, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\tASSERT_EQ(0, unlink(file1_s1d1));\n\tASSERT_EQ(0, unlink(file2_s1d1));\n\tASSERT_EQ(0, symlink(\"none\", file2_s1d1));\n\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\tASSERT_EQ(0, unlink(file2_s1d2));\n\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\tASSERT_EQ(0, unlink(file2_s1d3));\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(-1, symlink(\"none\", file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, link(file2_s1d1, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(-1, rename(file2_s1d1, file1_s1d1));\n\tASSERT_EQ(EACCES, errno);\n\n\tASSERT_EQ(0, symlink(\"none\", file1_s1d2));\n\tASSERT_EQ(0, link(file1_s1d2, file2_s1d2));\n\tASSERT_EQ(0, unlink(file2_s1d2));\n\tASSERT_EQ(0, rename(file1_s1d2, file2_s1d2));\n\n\tASSERT_EQ(0, symlink(\"none\", file1_s1d3));\n\tASSERT_EQ(0, link(file1_s1d3, file2_s1d3));\n\tASSERT_EQ(0, unlink(file2_s1d3));\n\tASSERT_EQ(0, rename(file1_s1d3, file2_s1d3));\n}\n\nTEST_F_FORK(layout1, make_dir)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_MAKE_DIR,\n\t\t},\n\t\t{},\n\t};\n\tconst int ruleset_fd =\n\t\tcreate_ruleset(_metadata, rules[0].access, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\tASSERT_EQ(0, unlink(file1_s1d1));\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\tASSERT_EQ(0, unlink(file1_s1d3));\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(-1, mkdir(file1_s1d1, 0700));\n\tASSERT_EQ(EACCES, errno);\n\tASSERT_EQ(0, mkdir(file1_s1d2, 0700));\n\tASSERT_EQ(0, mkdir(file1_s1d3, 0700));\n}\n\nstatic int open_proc_fd(struct __test_metadata *const _metadata, const int fd,\n\t\t\tconst int open_flags)\n{\n\tstatic const char path_template[] = \"/proc/self/fd/%d\";\n\tchar procfd_path[sizeof(path_template) + 10];\n\tconst int procfd_path_size =\n\t\tsnprintf(procfd_path, sizeof(procfd_path), path_template, fd);\n\n\tASSERT_LT(procfd_path_size, sizeof(procfd_path));\n\treturn open(procfd_path, open_flags);\n}\n\nTEST_F_FORK(layout1, proc_unlinked_file)\n{\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = file1_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{},\n\t};\n\tint reg_fd, proc_fd;\n\tconst int ruleset_fd = create_ruleset(\n\t\t_metadata,\n\t\tLANDLOCK_ACCESS_FS_READ_FILE | LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\trules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_RDWR));\n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\treg_fd = open(file1_s1d2, O_RDONLY | O_CLOEXEC);\n\tASSERT_LE(0, reg_fd);\n\tASSERT_EQ(0, unlink(file1_s1d2));\n\n\tproc_fd = open_proc_fd(_metadata, reg_fd, O_RDONLY | O_CLOEXEC);\n\tASSERT_LE(0, proc_fd);\n\tASSERT_EQ(0, close(proc_fd));\n\n\tproc_fd = open_proc_fd(_metadata, reg_fd, O_RDWR | O_CLOEXEC);\n\tASSERT_EQ(-1, proc_fd)\n\t{\n\t\tTH_LOG(\"Successfully opened /proc/self/fd/%d: %s\", reg_fd,\n\t\t       strerror(errno));\n\t}\n\tASSERT_EQ(EACCES, errno);\n\n\tASSERT_EQ(0, close(reg_fd));\n}\n\nTEST_F_FORK(layout1, proc_pipe)\n{\n\tint proc_fd;\n\tint pipe_fds[2];\n\tchar buf = '\\0';\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\t \n\tconst int ruleset_fd =\n\t\tcreate_ruleset(_metadata, rules[0].access, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDWR));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDWR));\n\n\t \n\tASSERT_EQ(0, pipe2(pipe_fds, O_CLOEXEC));\n\tASSERT_EQ(1, write(pipe_fds[1], \".\", 1))\n\t{\n\t\tTH_LOG(\"Failed to write in pipe: %s\", strerror(errno));\n\t}\n\tASSERT_EQ(1, read(pipe_fds[0], &buf, 1));\n\tASSERT_EQ('.', buf);\n\n\t \n\tproc_fd = open_proc_fd(_metadata, pipe_fds[1], O_WRONLY | O_CLOEXEC);\n\tASSERT_LE(0, proc_fd);\n\tASSERT_EQ(1, write(proc_fd, \".\", 1))\n\t{\n\t\tTH_LOG(\"Failed to write through /proc/self/fd/%d: %s\",\n\t\t       pipe_fds[1], strerror(errno));\n\t}\n\tASSERT_EQ(0, close(proc_fd));\n\n\t \n\tproc_fd = open_proc_fd(_metadata, pipe_fds[0], O_RDONLY | O_CLOEXEC);\n\tASSERT_LE(0, proc_fd);\n\tbuf = '\\0';\n\tASSERT_EQ(1, read(proc_fd, &buf, 1))\n\t{\n\t\tTH_LOG(\"Failed to read through /proc/self/fd/%d: %s\",\n\t\t       pipe_fds[1], strerror(errno));\n\t}\n\tASSERT_EQ(0, close(proc_fd));\n\n\tASSERT_EQ(0, close(pipe_fds[0]));\n\tASSERT_EQ(0, close(pipe_fds[1]));\n}\n\n \nstatic int test_truncate(const char *const path)\n{\n\tif (truncate(path, 10) < 0)\n\t\treturn errno;\n\treturn 0;\n}\n\n \nstatic int test_creat(const char *const path)\n{\n\tint fd = creat(path, 0600);\n\n\tif (fd < 0)\n\t\treturn errno;\n\n\t \n\tif (close(fd) < 0)\n\t\treturn errno;\n\treturn 0;\n}\n\n \nTEST_F_FORK(layout1, truncate_unhandled)\n{\n\tconst char *const file_r = file1_s1d1;\n\tconst char *const file_w = file2_s1d1;\n\tconst char *const file_none = file1_s1d2;\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = file_r,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = file_w,\n\t\t\t.access = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t \n\t\t{},\n\t};\n\n\tconst __u64 handled = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t      LANDLOCK_ACCESS_FS_WRITE_FILE;\n\tint ruleset_fd;\n\n\t \n\truleset_fd = create_ruleset(_metadata, handled, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tEXPECT_EQ(0, test_truncate(file_r));\n\tEXPECT_EQ(0, test_open(file_r, O_RDONLY | O_TRUNC));\n\tEXPECT_EQ(EACCES, test_open(file_r, O_WRONLY | O_TRUNC));\n\tEXPECT_EQ(EACCES, test_creat(file_r));\n\n\t \n\tEXPECT_EQ(0, test_truncate(file_w));\n\tEXPECT_EQ(EACCES, test_open(file_w, O_RDONLY | O_TRUNC));\n\tEXPECT_EQ(0, test_open(file_w, O_WRONLY | O_TRUNC));\n\tEXPECT_EQ(0, test_creat(file_w));\n\n\t \n\tEXPECT_EQ(0, test_truncate(file_none));\n\tEXPECT_EQ(EACCES, test_open(file_none, O_RDONLY | O_TRUNC));\n\tEXPECT_EQ(EACCES, test_open(file_none, O_WRONLY | O_TRUNC));\n\tEXPECT_EQ(EACCES, test_creat(file_none));\n}\n\nTEST_F_FORK(layout1, truncate)\n{\n\tconst char *const file_rwt = file1_s1d1;\n\tconst char *const file_rw = file2_s1d1;\n\tconst char *const file_rt = file1_s1d2;\n\tconst char *const file_t = file2_s1d2;\n\tconst char *const file_none = file1_s1d3;\n\tconst char *const dir_t = dir_s2d1;\n\tconst char *const file_in_dir_t = file1_s2d1;\n\tconst char *const dir_w = dir_s3d1;\n\tconst char *const file_in_dir_w = file1_s3d1;\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = file_rwt,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_TRUNCATE,\n\t\t},\n\t\t{\n\t\t\t.path = file_rw,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = file_rt,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_TRUNCATE,\n\t\t},\n\t\t{\n\t\t\t.path = file_t,\n\t\t\t.access = LANDLOCK_ACCESS_FS_TRUNCATE,\n\t\t},\n\t\t \n\t\t{\n\t\t\t.path = dir_t,\n\t\t\t.access = LANDLOCK_ACCESS_FS_TRUNCATE,\n\t\t},\n\t\t{\n\t\t\t.path = dir_w,\n\t\t\t.access = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst __u64 handled = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t      LANDLOCK_ACCESS_FS_WRITE_FILE |\n\t\t\t      LANDLOCK_ACCESS_FS_TRUNCATE;\n\tint ruleset_fd;\n\n\t \n\truleset_fd = create_ruleset(_metadata, handled, rules);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tEXPECT_EQ(0, test_truncate(file_rwt));\n\tEXPECT_EQ(0, test_open(file_rwt, O_RDONLY | O_TRUNC));\n\tEXPECT_EQ(0, test_open(file_rwt, O_WRONLY | O_TRUNC));\n\n\t \n\tEXPECT_EQ(EACCES, test_truncate(file_rw));\n\tEXPECT_EQ(EACCES, test_open(file_rw, O_RDONLY | O_TRUNC));\n\tEXPECT_EQ(EACCES, test_open(file_rw, O_WRONLY | O_TRUNC));\n\n\t \n\tEXPECT_EQ(0, test_truncate(file_rt));\n\tEXPECT_EQ(0, test_open(file_rt, O_RDONLY | O_TRUNC));\n\tEXPECT_EQ(EACCES, test_open(file_rt, O_WRONLY | O_TRUNC));\n\n\t \n\tEXPECT_EQ(0, test_truncate(file_t));\n\tEXPECT_EQ(EACCES, test_open(file_t, O_RDONLY | O_TRUNC));\n\tEXPECT_EQ(EACCES, test_open(file_t, O_WRONLY | O_TRUNC));\n\n\t \n\tEXPECT_EQ(EACCES, test_truncate(file_none));\n\tEXPECT_EQ(EACCES, test_open(file_none, O_RDONLY | O_TRUNC));\n\tEXPECT_EQ(EACCES, test_open(file_none, O_WRONLY | O_TRUNC));\n\n\t \n\tEXPECT_EQ(0, test_truncate(file_in_dir_t));\n\tEXPECT_EQ(EACCES, test_open(file_in_dir_t, O_RDONLY | O_TRUNC));\n\tEXPECT_EQ(EACCES, test_open(file_in_dir_t, O_WRONLY | O_TRUNC));\n\n\t \n\tEXPECT_EQ(EACCES, test_creat(file_in_dir_w));\n\n\tASSERT_EQ(0, unlink(file_in_dir_w));\n\tEXPECT_EQ(0, test_creat(file_in_dir_w));\n}\n\n \nstatic int test_ftruncate(int fd)\n{\n\tif (ftruncate(fd, 10) < 0)\n\t\treturn errno;\n\treturn 0;\n}\n\nTEST_F_FORK(layout1, ftruncate)\n{\n\t \n\tconst char *const path = file1_s1d1;\n\tconst __u64 handled1 = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t       LANDLOCK_ACCESS_FS_WRITE_FILE;\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = path,\n\t\t\t.access = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst __u64 handled2 = LANDLOCK_ACCESS_FS_TRUNCATE;\n\tconst struct rule layer2[] = {\n\t\t{\n\t\t\t.path = path,\n\t\t\t.access = LANDLOCK_ACCESS_FS_TRUNCATE,\n\t\t},\n\t\t{},\n\t};\n\tconst __u64 handled3 = LANDLOCK_ACCESS_FS_TRUNCATE |\n\t\t\t       LANDLOCK_ACCESS_FS_WRITE_FILE;\n\tconst struct rule layer3[] = {\n\t\t{\n\t\t\t.path = path,\n\t\t\t.access = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tint fd_layer0, fd_layer1, fd_layer2, fd_layer3, ruleset_fd;\n\n\tfd_layer0 = open(path, O_WRONLY);\n\tEXPECT_EQ(0, test_ftruncate(fd_layer0));\n\n\truleset_fd = create_ruleset(_metadata, handled1, layer1);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tfd_layer1 = open(path, O_WRONLY);\n\tEXPECT_EQ(0, test_ftruncate(fd_layer0));\n\tEXPECT_EQ(0, test_ftruncate(fd_layer1));\n\n\truleset_fd = create_ruleset(_metadata, handled2, layer2);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tfd_layer2 = open(path, O_WRONLY);\n\tEXPECT_EQ(0, test_ftruncate(fd_layer0));\n\tEXPECT_EQ(0, test_ftruncate(fd_layer1));\n\tEXPECT_EQ(0, test_ftruncate(fd_layer2));\n\n\truleset_fd = create_ruleset(_metadata, handled3, layer3);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tfd_layer3 = open(path, O_WRONLY);\n\tEXPECT_EQ(0, test_ftruncate(fd_layer0));\n\tEXPECT_EQ(0, test_ftruncate(fd_layer1));\n\tEXPECT_EQ(0, test_ftruncate(fd_layer2));\n\tEXPECT_EQ(EACCES, test_ftruncate(fd_layer3));\n\n\tASSERT_EQ(0, close(fd_layer0));\n\tASSERT_EQ(0, close(fd_layer1));\n\tASSERT_EQ(0, close(fd_layer2));\n\tASSERT_EQ(0, close(fd_layer3));\n}\n\n \nFIXTURE(ftruncate) {};\n \n\nFIXTURE_SETUP(ftruncate)\n{\n\tprepare_layout(_metadata);\n\tcreate_file(_metadata, file1_s1d1);\n}\n\nFIXTURE_TEARDOWN(ftruncate)\n{\n\tEXPECT_EQ(0, remove_path(file1_s1d1));\n\tcleanup_layout(_metadata);\n}\n\nFIXTURE_VARIANT(ftruncate)\n{\n\tconst __u64 handled;\n\tconst __u64 permitted;\n\tconst int expected_open_result;\n\tconst int expected_ftruncate_result;\n};\n\n \nFIXTURE_VARIANT_ADD(ftruncate, w_w) {\n\t \n\t.handled = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t.permitted = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t.expected_open_result = 0,\n\t.expected_ftruncate_result = 0,\n};\n\n \nFIXTURE_VARIANT_ADD(ftruncate, t_t) {\n\t \n\t.handled = LANDLOCK_ACCESS_FS_TRUNCATE,\n\t.permitted = LANDLOCK_ACCESS_FS_TRUNCATE,\n\t.expected_open_result = 0,\n\t.expected_ftruncate_result = 0,\n};\n\n \nFIXTURE_VARIANT_ADD(ftruncate, wt_w) {\n\t \n\t.handled = LANDLOCK_ACCESS_FS_WRITE_FILE | LANDLOCK_ACCESS_FS_TRUNCATE,\n\t.permitted = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t.expected_open_result = 0,\n\t.expected_ftruncate_result = EACCES,\n};\n\n \nFIXTURE_VARIANT_ADD(ftruncate, wt_wt) {\n\t \n\t.handled = LANDLOCK_ACCESS_FS_WRITE_FILE | LANDLOCK_ACCESS_FS_TRUNCATE,\n\t.permitted = LANDLOCK_ACCESS_FS_WRITE_FILE |\n\t\t     LANDLOCK_ACCESS_FS_TRUNCATE,\n\t.expected_open_result = 0,\n\t.expected_ftruncate_result = 0,\n};\n\n \nFIXTURE_VARIANT_ADD(ftruncate, wt_t) {\n\t \n\t.handled = LANDLOCK_ACCESS_FS_WRITE_FILE | LANDLOCK_ACCESS_FS_TRUNCATE,\n\t.permitted = LANDLOCK_ACCESS_FS_TRUNCATE,\n\t.expected_open_result = EACCES,\n};\n\nTEST_F_FORK(ftruncate, open_and_ftruncate)\n{\n\tconst char *const path = file1_s1d1;\n\tconst struct rule rules[] = {\n\t\t{\n\t\t\t.path = path,\n\t\t\t.access = variant->permitted,\n\t\t},\n\t\t{},\n\t};\n\tint fd, ruleset_fd;\n\n\t \n\truleset_fd = create_ruleset(_metadata, variant->handled, rules);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\tfd = open(path, O_WRONLY);\n\tEXPECT_EQ(variant->expected_open_result, (fd < 0 ? errno : 0));\n\tif (fd >= 0) {\n\t\tEXPECT_EQ(variant->expected_ftruncate_result,\n\t\t\t  test_ftruncate(fd));\n\t\tASSERT_EQ(0, close(fd));\n\t}\n}\n\nTEST_F_FORK(ftruncate, open_and_ftruncate_in_different_processes)\n{\n\tint child, fd, status;\n\tint socket_fds[2];\n\n\tASSERT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0,\n\t\t\t\tsocket_fds));\n\n\tchild = fork();\n\tASSERT_LE(0, child);\n\tif (child == 0) {\n\t\t \n\t\tconst char *const path = file1_s1d1;\n\t\tconst struct rule rules[] = {\n\t\t\t{\n\t\t\t\t.path = path,\n\t\t\t\t.access = variant->permitted,\n\t\t\t},\n\t\t\t{},\n\t\t};\n\t\tint fd, ruleset_fd;\n\n\t\truleset_fd = create_ruleset(_metadata, variant->handled, rules);\n\t\tASSERT_LE(0, ruleset_fd);\n\t\tenforce_ruleset(_metadata, ruleset_fd);\n\t\tASSERT_EQ(0, close(ruleset_fd));\n\n\t\tfd = open(path, O_WRONLY);\n\t\tASSERT_EQ(variant->expected_open_result, (fd < 0 ? errno : 0));\n\n\t\tif (fd >= 0) {\n\t\t\tASSERT_EQ(0, send_fd(socket_fds[0], fd));\n\t\t\tASSERT_EQ(0, close(fd));\n\t\t}\n\n\t\tASSERT_EQ(0, close(socket_fds[0]));\n\n\t\t_exit(_metadata->passed ? EXIT_SUCCESS : EXIT_FAILURE);\n\t\treturn;\n\t}\n\n\tif (variant->expected_open_result == 0) {\n\t\tfd = recv_fd(socket_fds[1]);\n\t\tASSERT_LE(0, fd);\n\n\t\tEXPECT_EQ(variant->expected_ftruncate_result,\n\t\t\t  test_ftruncate(fd));\n\t\tASSERT_EQ(0, close(fd));\n\t}\n\n\tASSERT_EQ(child, waitpid(child, &status, 0));\n\tASSERT_EQ(1, WIFEXITED(status));\n\tASSERT_EQ(EXIT_SUCCESS, WEXITSTATUS(status));\n\n\tASSERT_EQ(0, close(socket_fds[0]));\n\tASSERT_EQ(0, close(socket_fds[1]));\n}\n\nTEST(memfd_ftruncate)\n{\n\tint fd;\n\n\tfd = memfd_create(\"name\", MFD_CLOEXEC);\n\tASSERT_LE(0, fd);\n\n\t \n\tEXPECT_EQ(0, test_ftruncate(fd));\n\n\tASSERT_EQ(0, close(fd));\n}\n\n \nFIXTURE(layout1_bind) {};\n \n\nFIXTURE_SETUP(layout1_bind)\n{\n\tprepare_layout(_metadata);\n\n\tcreate_layout1(_metadata);\n\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(0, mount(dir_s1d2, dir_s2d2, NULL, MS_BIND, NULL));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n}\n\nFIXTURE_TEARDOWN(layout1_bind)\n{\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, umount(dir_s2d2));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\n\tremove_layout1(_metadata);\n\n\tcleanup_layout(_metadata);\n}\n\nstatic const char bind_dir_s1d3[] = TMP_DIR \"/s2d1/s2d2/s1d3\";\nstatic const char bind_file1_s1d3[] = TMP_DIR \"/s2d1/s2d2/s1d3/f1\";\n\n \n\nTEST_F_FORK(layout1_bind, no_restriction)\n{\n\tASSERT_EQ(0, test_open(dir_s1d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\n\tASSERT_EQ(0, test_open(dir_s2d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s2d1, O_RDONLY));\n\tASSERT_EQ(0, test_open(dir_s2d2, O_RDONLY));\n\tASSERT_EQ(0, test_open(file1_s2d2, O_RDONLY));\n\tASSERT_EQ(ENOENT, test_open(dir_s2d3, O_RDONLY));\n\tASSERT_EQ(ENOENT, test_open(file1_s2d3, O_RDONLY));\n\n\tASSERT_EQ(0, test_open(bind_dir_s1d3, O_RDONLY));\n\tASSERT_EQ(0, test_open(bind_file1_s1d3, O_RDONLY));\n\n\tASSERT_EQ(0, test_open(dir_s3d1, O_RDONLY));\n}\n\nTEST_F_FORK(layout1_bind, same_content_same_file)\n{\n\t \n\tconst struct rule layer1_parent[] = {\n\t\t{\n\t\t\t.path = dir_s1d1,\n\t\t\t.access = ACCESS_RO,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d1,\n\t\t\t.access = ACCESS_RW,\n\t\t},\n\t\t{},\n\t};\n\t \n\tconst struct rule layer2_mount_point[] = {\n\t\t{\n\t\t\t.path = dir_s1d2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = dir_s2d2,\n\t\t\t.access = ACCESS_RW,\n\t\t},\n\t\t{},\n\t};\n\t \n\tconst struct rule layer3_source[] = {\n\t\t{\n\t\t\t.path = dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{},\n\t};\n\t \n\tconst struct rule layer4_destination[] = {\n\t\t{\n\t\t\t.path = bind_file1_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd;\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer1_parent);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(0, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(0, test_open(file1_s2d1, O_RDWR));\n\tASSERT_EQ(0, test_open(dir_s2d1, O_RDONLY | O_DIRECTORY));\n\n\tASSERT_EQ(0, test_open(file1_s2d2, O_RDWR));\n\tASSERT_EQ(0, test_open(dir_s2d2, O_RDONLY | O_DIRECTORY));\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer2_mount_point);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d1, O_RDONLY | O_DIRECTORY));\n\n\tASSERT_EQ(0, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\tASSERT_EQ(0, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s2d1, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s2d1, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s2d1, O_RDONLY | O_DIRECTORY));\n\n\tASSERT_EQ(0, test_open(file1_s2d2, O_RDWR));\n\tASSERT_EQ(0, test_open(dir_s2d2, O_RDONLY | O_DIRECTORY));\n\tASSERT_EQ(0, test_open(bind_dir_s1d3, O_RDONLY | O_DIRECTORY));\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer3_source);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d2, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d2, O_RDONLY | O_DIRECTORY));\n\n\tASSERT_EQ(0, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s1d3, O_RDONLY | O_DIRECTORY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s2d2, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s2d2, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(dir_s2d2, O_RDONLY | O_DIRECTORY));\n\n\tASSERT_EQ(0, test_open(bind_file1_s1d3, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(bind_file1_s1d3, O_WRONLY));\n\tASSERT_EQ(EACCES, test_open(bind_dir_s1d3, O_RDONLY | O_DIRECTORY));\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer4_destination);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(file1_s1d3, O_WRONLY));\n\n\t \n\tASSERT_EQ(EACCES, test_open(bind_file1_s1d3, O_RDONLY));\n\tASSERT_EQ(EACCES, test_open(bind_file1_s1d3, O_WRONLY));\n}\n\nTEST_F_FORK(layout1_bind, reparent_cross_mount)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t \n\t\t\t.path = dir_s2d1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_REFER,\n\t\t},\n\t\t{\n\t\t\t.path = bind_dir_s1d3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_EXECUTE,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd = create_ruleset(\n\t\t_metadata,\n\t\tLANDLOCK_ACCESS_FS_REFER | LANDLOCK_ACCESS_FS_EXECUTE, layer1);\n\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(-1, rename(file1_s1d1, file1_s1d2));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s2d1, file1_s2d2));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(-1, rename(file1_s2d2, bind_file1_s1d3));\n\tASSERT_EQ(EXDEV, errno);\n\n\t \n\tASSERT_EQ(0, rename(bind_file1_s1d3, file1_s2d2));\n}\n\n#define LOWER_BASE TMP_DIR \"/lower\"\n#define LOWER_DATA LOWER_BASE \"/data\"\nstatic const char lower_fl1[] = LOWER_DATA \"/fl1\";\nstatic const char lower_dl1[] = LOWER_DATA \"/dl1\";\nstatic const char lower_dl1_fl2[] = LOWER_DATA \"/dl1/fl2\";\nstatic const char lower_fo1[] = LOWER_DATA \"/fo1\";\nstatic const char lower_do1[] = LOWER_DATA \"/do1\";\nstatic const char lower_do1_fo2[] = LOWER_DATA \"/do1/fo2\";\nstatic const char lower_do1_fl3[] = LOWER_DATA \"/do1/fl3\";\n\nstatic const char (*lower_base_files[])[] = {\n\t&lower_fl1,\n\t&lower_fo1,\n\tNULL,\n};\nstatic const char (*lower_base_directories[])[] = {\n\t&lower_dl1,\n\t&lower_do1,\n\tNULL,\n};\nstatic const char (*lower_sub_files[])[] = {\n\t&lower_dl1_fl2,\n\t&lower_do1_fo2,\n\t&lower_do1_fl3,\n\tNULL,\n};\n\n#define UPPER_BASE TMP_DIR \"/upper\"\n#define UPPER_DATA UPPER_BASE \"/data\"\n#define UPPER_WORK UPPER_BASE \"/work\"\nstatic const char upper_fu1[] = UPPER_DATA \"/fu1\";\nstatic const char upper_du1[] = UPPER_DATA \"/du1\";\nstatic const char upper_du1_fu2[] = UPPER_DATA \"/du1/fu2\";\nstatic const char upper_fo1[] = UPPER_DATA \"/fo1\";\nstatic const char upper_do1[] = UPPER_DATA \"/do1\";\nstatic const char upper_do1_fo2[] = UPPER_DATA \"/do1/fo2\";\nstatic const char upper_do1_fu3[] = UPPER_DATA \"/do1/fu3\";\n\nstatic const char (*upper_base_files[])[] = {\n\t&upper_fu1,\n\t&upper_fo1,\n\tNULL,\n};\nstatic const char (*upper_base_directories[])[] = {\n\t&upper_du1,\n\t&upper_do1,\n\tNULL,\n};\nstatic const char (*upper_sub_files[])[] = {\n\t&upper_du1_fu2,\n\t&upper_do1_fo2,\n\t&upper_do1_fu3,\n\tNULL,\n};\n\n#define MERGE_BASE TMP_DIR \"/merge\"\n#define MERGE_DATA MERGE_BASE \"/data\"\nstatic const char merge_fl1[] = MERGE_DATA \"/fl1\";\nstatic const char merge_dl1[] = MERGE_DATA \"/dl1\";\nstatic const char merge_dl1_fl2[] = MERGE_DATA \"/dl1/fl2\";\nstatic const char merge_fu1[] = MERGE_DATA \"/fu1\";\nstatic const char merge_du1[] = MERGE_DATA \"/du1\";\nstatic const char merge_du1_fu2[] = MERGE_DATA \"/du1/fu2\";\nstatic const char merge_fo1[] = MERGE_DATA \"/fo1\";\nstatic const char merge_do1[] = MERGE_DATA \"/do1\";\nstatic const char merge_do1_fo2[] = MERGE_DATA \"/do1/fo2\";\nstatic const char merge_do1_fl3[] = MERGE_DATA \"/do1/fl3\";\nstatic const char merge_do1_fu3[] = MERGE_DATA \"/do1/fu3\";\n\nstatic const char (*merge_base_files[])[] = {\n\t&merge_fl1,\n\t&merge_fu1,\n\t&merge_fo1,\n\tNULL,\n};\nstatic const char (*merge_base_directories[])[] = {\n\t&merge_dl1,\n\t&merge_du1,\n\t&merge_do1,\n\tNULL,\n};\nstatic const char (*merge_sub_files[])[] = {\n\t&merge_dl1_fl2, &merge_du1_fu2, &merge_do1_fo2,\n\t&merge_do1_fl3, &merge_do1_fu3, NULL,\n};\n\n \n\nFIXTURE(layout2_overlay)\n{\n\tbool skip_test;\n};\n\nFIXTURE_SETUP(layout2_overlay)\n{\n\tif (!supports_filesystem(\"overlay\")) {\n\t\tself->skip_test = true;\n\t\tSKIP(return, \"overlayfs is not supported (setup)\");\n\t}\n\n\tprepare_layout(_metadata);\n\n\tcreate_directory(_metadata, LOWER_BASE);\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\t \n\tASSERT_EQ(0, mount_opt(&mnt_tmp, LOWER_BASE));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\tcreate_file(_metadata, lower_fl1);\n\tcreate_file(_metadata, lower_dl1_fl2);\n\tcreate_file(_metadata, lower_fo1);\n\tcreate_file(_metadata, lower_do1_fo2);\n\tcreate_file(_metadata, lower_do1_fl3);\n\n\tcreate_directory(_metadata, UPPER_BASE);\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(0, mount_opt(&mnt_tmp, UPPER_BASE));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\tcreate_file(_metadata, upper_fu1);\n\tcreate_file(_metadata, upper_du1_fu2);\n\tcreate_file(_metadata, upper_fo1);\n\tcreate_file(_metadata, upper_do1_fo2);\n\tcreate_file(_metadata, upper_do1_fu3);\n\tASSERT_EQ(0, mkdir(UPPER_WORK, 0700));\n\n\tcreate_directory(_metadata, MERGE_DATA);\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tset_cap(_metadata, CAP_DAC_OVERRIDE);\n\tASSERT_EQ(0, mount(\"overlay\", MERGE_DATA, \"overlay\", 0,\n\t\t\t   \"lowerdir=\" LOWER_DATA \",upperdir=\" UPPER_DATA\n\t\t\t   \",workdir=\" UPPER_WORK));\n\tclear_cap(_metadata, CAP_DAC_OVERRIDE);\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n}\n\nFIXTURE_TEARDOWN(layout2_overlay)\n{\n\tif (self->skip_test)\n\t\tSKIP(return, \"overlayfs is not supported (teardown)\");\n\n\tEXPECT_EQ(0, remove_path(lower_do1_fl3));\n\tEXPECT_EQ(0, remove_path(lower_dl1_fl2));\n\tEXPECT_EQ(0, remove_path(lower_fl1));\n\tEXPECT_EQ(0, remove_path(lower_do1_fo2));\n\tEXPECT_EQ(0, remove_path(lower_fo1));\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, umount(LOWER_BASE));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, remove_path(LOWER_BASE));\n\n\tEXPECT_EQ(0, remove_path(upper_do1_fu3));\n\tEXPECT_EQ(0, remove_path(upper_du1_fu2));\n\tEXPECT_EQ(0, remove_path(upper_fu1));\n\tEXPECT_EQ(0, remove_path(upper_do1_fo2));\n\tEXPECT_EQ(0, remove_path(upper_fo1));\n\tEXPECT_EQ(0, remove_path(UPPER_WORK \"/work\"));\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, umount(UPPER_BASE));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, remove_path(UPPER_BASE));\n\n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, umount(MERGE_DATA));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\tEXPECT_EQ(0, remove_path(MERGE_DATA));\n\n\tcleanup_layout(_metadata);\n}\n\nTEST_F_FORK(layout2_overlay, no_restriction)\n{\n\tif (self->skip_test)\n\t\tSKIP(return, \"overlayfs is not supported (test)\");\n\n\tASSERT_EQ(0, test_open(lower_fl1, O_RDONLY));\n\tASSERT_EQ(0, test_open(lower_dl1, O_RDONLY));\n\tASSERT_EQ(0, test_open(lower_dl1_fl2, O_RDONLY));\n\tASSERT_EQ(0, test_open(lower_fo1, O_RDONLY));\n\tASSERT_EQ(0, test_open(lower_do1, O_RDONLY));\n\tASSERT_EQ(0, test_open(lower_do1_fo2, O_RDONLY));\n\tASSERT_EQ(0, test_open(lower_do1_fl3, O_RDONLY));\n\n\tASSERT_EQ(0, test_open(upper_fu1, O_RDONLY));\n\tASSERT_EQ(0, test_open(upper_du1, O_RDONLY));\n\tASSERT_EQ(0, test_open(upper_du1_fu2, O_RDONLY));\n\tASSERT_EQ(0, test_open(upper_fo1, O_RDONLY));\n\tASSERT_EQ(0, test_open(upper_do1, O_RDONLY));\n\tASSERT_EQ(0, test_open(upper_do1_fo2, O_RDONLY));\n\tASSERT_EQ(0, test_open(upper_do1_fu3, O_RDONLY));\n\n\tASSERT_EQ(0, test_open(merge_fl1, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_dl1, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_dl1_fl2, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_fu1, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_du1, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_du1_fu2, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_fo1, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_do1, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_do1_fo2, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_do1_fl3, O_RDONLY));\n\tASSERT_EQ(0, test_open(merge_do1_fu3, O_RDONLY));\n}\n\n#define for_each_path(path_list, path_entry, i)               \\\n\tfor (i = 0, path_entry = *path_list[i]; path_list[i]; \\\n\t     path_entry = *path_list[++i])\n\nTEST_F_FORK(layout2_overlay, same_content_different_file)\n{\n\t \n\tconst struct rule layer1_base[] = {\n\t\t{\n\t\t\t.path = LOWER_BASE,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = UPPER_BASE,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = MERGE_BASE,\n\t\t\t.access = ACCESS_RW,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer2_data[] = {\n\t\t{\n\t\t\t.path = LOWER_DATA,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = UPPER_DATA,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = MERGE_DATA,\n\t\t\t.access = ACCESS_RW,\n\t\t},\n\t\t{},\n\t};\n\t \n\tconst struct rule layer3_subdirs[] = {\n\t\t{\n\t\t\t.path = lower_dl1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = lower_do1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = upper_du1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = upper_do1,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = merge_dl1,\n\t\t\t.access = ACCESS_RW,\n\t\t},\n\t\t{\n\t\t\t.path = merge_du1,\n\t\t\t.access = ACCESS_RW,\n\t\t},\n\t\t{\n\t\t\t.path = merge_do1,\n\t\t\t.access = ACCESS_RW,\n\t\t},\n\t\t{},\n\t};\n\t \n\tconst struct rule layer4_files[] = {\n\t\t{\n\t\t\t.path = lower_dl1_fl2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = lower_do1_fo2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = lower_do1_fl3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = upper_du1_fu2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = upper_do1_fo2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = upper_do1_fu3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = merge_dl1_fl2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = merge_du1_fu2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = merge_do1_fo2,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = merge_do1_fl3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{\n\t\t\t.path = merge_do1_fu3,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst struct rule layer5_merge_only[] = {\n\t\t{\n\t\t\t.path = MERGE_DATA,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE |\n\t\t\t\t  LANDLOCK_ACCESS_FS_WRITE_FILE,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd;\n\tsize_t i;\n\tconst char *path_entry;\n\n\tif (self->skip_test)\n\t\tSKIP(return, \"overlayfs is not supported (test)\");\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer1_base);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tfor_each_path(lower_base_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDONLY));\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_WRONLY));\n\t}\n\tfor_each_path(lower_base_directories, path_entry, i) {\n\t\tASSERT_EQ(EACCES,\n\t\t\t  test_open(path_entry, O_RDONLY | O_DIRECTORY));\n\t}\n\tfor_each_path(lower_sub_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDONLY));\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_WRONLY));\n\t}\n\t \n\tfor_each_path(upper_base_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDONLY));\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_WRONLY));\n\t}\n\tfor_each_path(upper_base_directories, path_entry, i) {\n\t\tASSERT_EQ(EACCES,\n\t\t\t  test_open(path_entry, O_RDONLY | O_DIRECTORY));\n\t}\n\tfor_each_path(upper_sub_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDONLY));\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_WRONLY));\n\t}\n\t \n\tfor_each_path(merge_base_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDWR));\n\t}\n\tfor_each_path(merge_base_directories, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDONLY | O_DIRECTORY));\n\t}\n\tfor_each_path(merge_sub_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDWR));\n\t}\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer2_data);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tfor_each_path(merge_base_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDWR));\n\t}\n\tfor_each_path(merge_base_directories, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDONLY | O_DIRECTORY));\n\t}\n\tfor_each_path(merge_sub_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDWR));\n\t}\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer3_subdirs);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tfor_each_path(lower_base_files, path_entry, i) {\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_RDONLY));\n\t}\n\t \n\tfor_each_path(upper_base_files, path_entry, i) {\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_RDONLY));\n\t}\n\t \n\tfor_each_path(merge_base_files, path_entry, i) {\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_RDWR));\n\t}\n\tfor_each_path(merge_base_directories, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDONLY | O_DIRECTORY));\n\t}\n\tfor_each_path(merge_sub_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDWR));\n\t}\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer4_files);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tfor_each_path(lower_sub_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDONLY));\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_WRONLY));\n\t}\n\t \n\tfor_each_path(upper_sub_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDONLY));\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_WRONLY));\n\t}\n\t \n\tfor_each_path(merge_base_files, path_entry, i) {\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_RDWR));\n\t}\n\tfor_each_path(merge_base_directories, path_entry, i) {\n\t\tASSERT_EQ(EACCES,\n\t\t\t  test_open(path_entry, O_RDONLY | O_DIRECTORY));\n\t}\n\tfor_each_path(merge_sub_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDWR));\n\t}\n\n\t \n\truleset_fd = create_ruleset(_metadata, ACCESS_RW, layer5_merge_only);\n\tASSERT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tfor_each_path(lower_sub_files, path_entry, i) {\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_RDONLY));\n\t}\n\t \n\tfor_each_path(upper_sub_files, path_entry, i) {\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_RDONLY));\n\t}\n\t \n\tfor_each_path(merge_base_files, path_entry, i) {\n\t\tASSERT_EQ(EACCES, test_open(path_entry, O_RDWR));\n\t}\n\tfor_each_path(merge_base_directories, path_entry, i) {\n\t\tASSERT_EQ(EACCES,\n\t\t\t  test_open(path_entry, O_RDONLY | O_DIRECTORY));\n\t}\n\tfor_each_path(merge_sub_files, path_entry, i) {\n\t\tASSERT_EQ(0, test_open(path_entry, O_RDWR));\n\t}\n}\n\nFIXTURE(layout3_fs)\n{\n\tbool has_created_dir;\n\tbool has_created_file;\n\tchar *dir_path;\n\tbool skip_test;\n};\n\nFIXTURE_VARIANT(layout3_fs)\n{\n\tconst struct mnt_opt mnt;\n\tconst char *const file_path;\n\tunsigned int cwd_fs_magic;\n};\n\n \nFIXTURE_VARIANT_ADD(layout3_fs, tmpfs) {\n\t \n\t.mnt = mnt_tmp,\n\t.file_path = file1_s1d1,\n};\n\nFIXTURE_VARIANT_ADD(layout3_fs, ramfs) {\n\t.mnt = {\n\t\t.type = \"ramfs\",\n\t\t.data = \"mode=700\",\n\t},\n\t.file_path = TMP_DIR \"/dir/file\",\n};\n\nFIXTURE_VARIANT_ADD(layout3_fs, cgroup2) {\n\t.mnt = {\n\t\t.type = \"cgroup2\",\n\t},\n\t.file_path = TMP_DIR \"/test/cgroup.procs\",\n};\n\nFIXTURE_VARIANT_ADD(layout3_fs, proc) {\n\t.mnt = {\n\t\t.type = \"proc\",\n\t},\n\t.file_path = TMP_DIR \"/self/status\",\n};\n\nFIXTURE_VARIANT_ADD(layout3_fs, sysfs) {\n\t.mnt = {\n\t\t.type = \"sysfs\",\n\t},\n\t.file_path = TMP_DIR \"/kernel/notes\",\n};\n\nFIXTURE_VARIANT_ADD(layout3_fs, hostfs) {\n\t.mnt = {\n\t\t.source = TMP_DIR,\n\t\t.flags = MS_BIND,\n\t},\n\t.file_path = TMP_DIR \"/dir/file\",\n\t.cwd_fs_magic = HOSTFS_SUPER_MAGIC,\n};\n\nFIXTURE_SETUP(layout3_fs)\n{\n\tstruct stat statbuf;\n\tconst char *slash;\n\tsize_t dir_len;\n\n\tif (!supports_filesystem(variant->mnt.type) ||\n\t    !cwd_matches_fs(variant->cwd_fs_magic)) {\n\t\tself->skip_test = true;\n\t\tSKIP(return, \"this filesystem is not supported (setup)\");\n\t}\n\n\tslash = strrchr(variant->file_path, '/');\n\tASSERT_NE(slash, NULL);\n\tdir_len = (size_t)slash - (size_t)variant->file_path;\n\tASSERT_LT(0, dir_len);\n\tself->dir_path = malloc(dir_len + 1);\n\tself->dir_path[dir_len] = '\\0';\n\tstrncpy(self->dir_path, variant->file_path, dir_len);\n\n\tprepare_layout_opt(_metadata, &variant->mnt);\n\n\t \n\tif (stat(self->dir_path, &statbuf)) {\n\t\tset_cap(_metadata, CAP_DAC_OVERRIDE);\n\t\tEXPECT_EQ(0, mkdir(self->dir_path, 0700))\n\t\t{\n\t\t\tTH_LOG(\"Failed to create directory \\\"%s\\\": %s\",\n\t\t\t       self->dir_path, strerror(errno));\n\t\t\tfree(self->dir_path);\n\t\t\tself->dir_path = NULL;\n\t\t}\n\t\tself->has_created_dir = true;\n\t\tclear_cap(_metadata, CAP_DAC_OVERRIDE);\n\t}\n\n\t \n\tif (stat(variant->file_path, &statbuf)) {\n\t\tint fd;\n\n\t\tset_cap(_metadata, CAP_DAC_OVERRIDE);\n\t\tfd = creat(variant->file_path, 0600);\n\t\tEXPECT_LE(0, fd)\n\t\t{\n\t\t\tTH_LOG(\"Failed to create file \\\"%s\\\": %s\",\n\t\t\t       variant->file_path, strerror(errno));\n\t\t}\n\t\tEXPECT_EQ(0, close(fd));\n\t\tself->has_created_file = true;\n\t\tclear_cap(_metadata, CAP_DAC_OVERRIDE);\n\t}\n}\n\nFIXTURE_TEARDOWN(layout3_fs)\n{\n\tif (self->skip_test)\n\t\tSKIP(return, \"this filesystem is not supported (teardown)\");\n\n\tif (self->has_created_file) {\n\t\tset_cap(_metadata, CAP_DAC_OVERRIDE);\n\t\t \n\t\tunlink(variant->file_path);\n\t\tclear_cap(_metadata, CAP_DAC_OVERRIDE);\n\t}\n\n\tif (self->has_created_dir) {\n\t\tset_cap(_metadata, CAP_DAC_OVERRIDE);\n\t\t \n\t\trmdir(self->dir_path);\n\t\tclear_cap(_metadata, CAP_DAC_OVERRIDE);\n\t}\n\tfree(self->dir_path);\n\tself->dir_path = NULL;\n\n\tcleanup_layout(_metadata);\n}\n\nstatic void layer3_fs_tag_inode(struct __test_metadata *const _metadata,\n\t\t\t\tFIXTURE_DATA(layout3_fs) * self,\n\t\t\t\tconst FIXTURE_VARIANT(layout3_fs) * variant,\n\t\t\t\tconst char *const rule_path)\n{\n\tconst struct rule layer1_allow_read_file[] = {\n\t\t{\n\t\t\t.path = rule_path,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t},\n\t\t{},\n\t};\n\tconst struct landlock_ruleset_attr layer2_deny_everything_attr = {\n\t\t.handled_access_fs = LANDLOCK_ACCESS_FS_READ_FILE,\n\t};\n\tconst char *const dev_null_path = \"/dev/null\";\n\tint ruleset_fd;\n\n\tif (self->skip_test)\n\t\tSKIP(return, \"this filesystem is not supported (test)\");\n\n\t \n\tEXPECT_EQ(0, test_open(dev_null_path, O_RDONLY | O_CLOEXEC));\n\tEXPECT_EQ(0, test_open(variant->file_path, O_RDONLY | O_CLOEXEC));\n\n\truleset_fd = create_ruleset(_metadata, LANDLOCK_ACCESS_FS_READ_FILE,\n\t\t\t\t    layer1_allow_read_file);\n\tEXPECT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tEXPECT_EQ(0, close(ruleset_fd));\n\n\tEXPECT_EQ(EACCES, test_open(dev_null_path, O_RDONLY | O_CLOEXEC));\n\tEXPECT_EQ(0, test_open(variant->file_path, O_RDONLY | O_CLOEXEC));\n\n\t \n\truleset_fd =\n\t\tlandlock_create_ruleset(&layer2_deny_everything_attr,\n\t\t\t\t\tsizeof(layer2_deny_everything_attr), 0);\n\tEXPECT_LE(0, ruleset_fd);\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tEXPECT_EQ(0, close(ruleset_fd));\n\n\t \n\tEXPECT_EQ(EACCES, test_open(dev_null_path, O_RDONLY | O_CLOEXEC));\n\tEXPECT_EQ(EACCES, test_open(variant->file_path, O_RDONLY | O_CLOEXEC));\n}\n\n \n\nTEST_F_FORK(layout3_fs, tag_inode_dir_parent)\n{\n\t \n\tlayer3_fs_tag_inode(_metadata, self, variant, \".\");\n}\n\nTEST_F_FORK(layout3_fs, tag_inode_dir_mnt)\n{\n\tlayer3_fs_tag_inode(_metadata, self, variant, TMP_DIR);\n}\n\nTEST_F_FORK(layout3_fs, tag_inode_dir_child)\n{\n\tlayer3_fs_tag_inode(_metadata, self, variant, self->dir_path);\n}\n\nTEST_F_FORK(layout3_fs, tag_inode_file)\n{\n\tlayer3_fs_tag_inode(_metadata, self, variant, variant->file_path);\n}\n\n \nTEST_F_FORK(layout3_fs, release_inodes)\n{\n\tconst struct rule layer1[] = {\n\t\t{\n\t\t\t.path = TMP_DIR,\n\t\t\t.access = LANDLOCK_ACCESS_FS_READ_DIR,\n\t\t},\n\t\t{},\n\t};\n\tint ruleset_fd;\n\n\tif (self->skip_test)\n\t\tSKIP(return, \"this filesystem is not supported (test)\");\n\n\t \n\tif (self->has_created_file)\n\t\tEXPECT_EQ(0, remove_path(variant->file_path));\n\n\tif (self->has_created_dir)\n\t\t \n\t\tremove_path(self->dir_path);\n\n\truleset_fd =\n\t\tcreate_ruleset(_metadata, LANDLOCK_ACCESS_FS_READ_DIR, layer1);\n\tASSERT_LE(0, ruleset_fd);\n\n\t \n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(0, umount(TMP_DIR));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\n\t \n\tset_cap(_metadata, CAP_SYS_ADMIN);\n\tASSERT_EQ(0, mount_opt(&mnt_tmp, TMP_DIR));\n\tclear_cap(_metadata, CAP_SYS_ADMIN);\n\n\tenforce_ruleset(_metadata, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n\n\t \n\tASSERT_EQ(EACCES, test_open(TMP_DIR, O_RDONLY));\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}