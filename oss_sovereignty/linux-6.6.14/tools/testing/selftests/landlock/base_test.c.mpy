{
  "module_name": "base_test.c",
  "hash_id": "eb3945a6145678e04292e1aec34d0e096bd85a849edd7544c24010c7d48c0d22",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/landlock/base_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/landlock.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include \"common.h\"\n\n#ifndef O_PATH\n#define O_PATH 010000000\n#endif\n\nTEST(inconsistent_attr)\n{\n\tconst long page_size = sysconf(_SC_PAGESIZE);\n\tchar *const buf = malloc(page_size + 1);\n\tstruct landlock_ruleset_attr *const ruleset_attr = (void *)buf;\n\n\tASSERT_NE(NULL, buf);\n\n\t \n\tASSERT_EQ(-1, landlock_create_ruleset(ruleset_attr, 0, 0));\n\t \n\tASSERT_EQ(EINVAL, errno);\n\tASSERT_EQ(-1, landlock_create_ruleset(ruleset_attr, 1, 0));\n\tASSERT_EQ(EINVAL, errno);\n\tASSERT_EQ(-1, landlock_create_ruleset(ruleset_attr, 7, 0));\n\tASSERT_EQ(EINVAL, errno);\n\n\tASSERT_EQ(-1, landlock_create_ruleset(NULL, 1, 0));\n\t \n\tASSERT_EQ(EFAULT, errno);\n\n\tASSERT_EQ(-1, landlock_create_ruleset(\n\t\t\t      NULL, sizeof(struct landlock_ruleset_attr), 0));\n\tASSERT_EQ(EFAULT, errno);\n\n\tASSERT_EQ(-1, landlock_create_ruleset(ruleset_attr, page_size + 1, 0));\n\tASSERT_EQ(E2BIG, errno);\n\n\t \n\tASSERT_EQ(-1, landlock_create_ruleset(ruleset_attr, 8, 0));\n\tASSERT_EQ(ENOMSG, errno);\n\tASSERT_EQ(-1, landlock_create_ruleset(\n\t\t\t      ruleset_attr,\n\t\t\t      sizeof(struct landlock_ruleset_attr), 0));\n\tASSERT_EQ(ENOMSG, errno);\n\tASSERT_EQ(-1, landlock_create_ruleset(ruleset_attr, page_size, 0));\n\tASSERT_EQ(ENOMSG, errno);\n\n\t \n\tbuf[page_size - 2] = '.';\n\tASSERT_EQ(-1, landlock_create_ruleset(ruleset_attr, page_size, 0));\n\tASSERT_EQ(E2BIG, errno);\n\n\tASSERT_EQ(-1, landlock_create_ruleset(ruleset_attr, page_size + 1, 0));\n\tASSERT_EQ(E2BIG, errno);\n\n\tfree(buf);\n}\n\nTEST(abi_version)\n{\n\tconst struct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = LANDLOCK_ACCESS_FS_READ_FILE,\n\t};\n\tASSERT_EQ(3, landlock_create_ruleset(NULL, 0,\n\t\t\t\t\t     LANDLOCK_CREATE_RULESET_VERSION));\n\n\tASSERT_EQ(-1, landlock_create_ruleset(&ruleset_attr, 0,\n\t\t\t\t\t      LANDLOCK_CREATE_RULESET_VERSION));\n\tASSERT_EQ(EINVAL, errno);\n\n\tASSERT_EQ(-1, landlock_create_ruleset(NULL, sizeof(ruleset_attr),\n\t\t\t\t\t      LANDLOCK_CREATE_RULESET_VERSION));\n\tASSERT_EQ(EINVAL, errno);\n\n\tASSERT_EQ(-1,\n\t\t  landlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr),\n\t\t\t\t\t  LANDLOCK_CREATE_RULESET_VERSION));\n\tASSERT_EQ(EINVAL, errno);\n\n\tASSERT_EQ(-1, landlock_create_ruleset(NULL, 0,\n\t\t\t\t\t      LANDLOCK_CREATE_RULESET_VERSION |\n\t\t\t\t\t\t      1 << 31));\n\tASSERT_EQ(EINVAL, errno);\n}\n\n \nTEST(create_ruleset_checks_ordering)\n{\n\tconst int last_flag = LANDLOCK_CREATE_RULESET_VERSION;\n\tconst int invalid_flag = last_flag << 1;\n\tint ruleset_fd;\n\tconst struct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = LANDLOCK_ACCESS_FS_READ_FILE,\n\t};\n\n\t \n\tASSERT_EQ(-1, landlock_create_ruleset(NULL, 0, invalid_flag));\n\tASSERT_EQ(EINVAL, errno);\n\n\tASSERT_EQ(-1, landlock_create_ruleset(&ruleset_attr, 0, invalid_flag));\n\tASSERT_EQ(EINVAL, errno);\n\n\tASSERT_EQ(-1, landlock_create_ruleset(NULL, sizeof(ruleset_attr),\n\t\t\t\t\t      invalid_flag));\n\tASSERT_EQ(EINVAL, errno);\n\n\tASSERT_EQ(-1,\n\t\t  landlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr),\n\t\t\t\t\t  invalid_flag));\n\tASSERT_EQ(EINVAL, errno);\n\n\t \n\tASSERT_EQ(-1, landlock_create_ruleset(&ruleset_attr, -1, 0));\n\tASSERT_EQ(E2BIG, errno);\n\n\t \n\tASSERT_EQ(-1, landlock_create_ruleset(&ruleset_attr, 0, 0));\n\tASSERT_EQ(EINVAL, errno);\n\tASSERT_EQ(-1, landlock_create_ruleset(&ruleset_attr, 1, 0));\n\tASSERT_EQ(EINVAL, errno);\n\n\t \n\truleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tASSERT_LE(0, ruleset_fd);\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\n \nTEST(add_rule_checks_ordering)\n{\n\tconst struct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = LANDLOCK_ACCESS_FS_EXECUTE,\n\t};\n\tstruct landlock_path_beneath_attr path_beneath_attr = {\n\t\t.allowed_access = LANDLOCK_ACCESS_FS_EXECUTE,\n\t\t.parent_fd = -1,\n\t};\n\tconst int ruleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\n\tASSERT_LE(0, ruleset_fd);\n\n\t \n\tASSERT_EQ(-1, landlock_add_rule(-1, 0, NULL, 1));\n\tASSERT_EQ(EINVAL, errno);\n\n\t \n\tASSERT_EQ(-1, landlock_add_rule(-1, 0, NULL, 0));\n\tASSERT_EQ(EBADF, errno);\n\n\t \n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, 0, NULL, 0));\n\tASSERT_EQ(EINVAL, errno);\n\n\t \n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\tNULL, 0));\n\tASSERT_EQ(EFAULT, errno);\n\n\t \n\tASSERT_EQ(-1, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t\t&path_beneath_attr, 0));\n\tASSERT_EQ(EBADF, errno);\n\n\t \n\tpath_beneath_attr.parent_fd =\n\t\topen(\"/tmp\", O_PATH | O_NOFOLLOW | O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath_attr.parent_fd);\n\tASSERT_EQ(0, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t       &path_beneath_attr, 0));\n\tASSERT_EQ(0, close(path_beneath_attr.parent_fd));\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\n \nTEST(restrict_self_checks_ordering)\n{\n\tconst struct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = LANDLOCK_ACCESS_FS_EXECUTE,\n\t};\n\tstruct landlock_path_beneath_attr path_beneath_attr = {\n\t\t.allowed_access = LANDLOCK_ACCESS_FS_EXECUTE,\n\t\t.parent_fd = -1,\n\t};\n\tconst int ruleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\n\tASSERT_LE(0, ruleset_fd);\n\tpath_beneath_attr.parent_fd =\n\t\topen(\"/tmp\", O_PATH | O_NOFOLLOW | O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath_attr.parent_fd);\n\tASSERT_EQ(0, landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t       &path_beneath_attr, 0));\n\tASSERT_EQ(0, close(path_beneath_attr.parent_fd));\n\n\t \n\tdrop_caps(_metadata);\n\tASSERT_EQ(-1, landlock_restrict_self(-1, -1));\n\tASSERT_EQ(EPERM, errno);\n\tASSERT_EQ(-1, landlock_restrict_self(-1, 0));\n\tASSERT_EQ(EPERM, errno);\n\tASSERT_EQ(-1, landlock_restrict_self(ruleset_fd, 0));\n\tASSERT_EQ(EPERM, errno);\n\n\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\n\t \n\tASSERT_EQ(-1, landlock_restrict_self(-1, -1));\n\tASSERT_EQ(EINVAL, errno);\n\n\t \n\tASSERT_EQ(-1, landlock_restrict_self(-1, 0));\n\tASSERT_EQ(EBADF, errno);\n\n\t \n\tASSERT_EQ(0, landlock_restrict_self(ruleset_fd, 0));\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\nTEST(ruleset_fd_io)\n{\n\tstruct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = LANDLOCK_ACCESS_FS_READ_FILE,\n\t};\n\tint ruleset_fd;\n\tchar buf;\n\n\tdrop_caps(_metadata);\n\truleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tASSERT_LE(0, ruleset_fd);\n\n\tASSERT_EQ(-1, write(ruleset_fd, \".\", 1));\n\tASSERT_EQ(EINVAL, errno);\n\tASSERT_EQ(-1, read(ruleset_fd, &buf, 1));\n\tASSERT_EQ(EINVAL, errno);\n\n\tASSERT_EQ(0, close(ruleset_fd));\n}\n\n \nTEST(ruleset_fd_transfer)\n{\n\tstruct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = LANDLOCK_ACCESS_FS_READ_DIR,\n\t};\n\tstruct landlock_path_beneath_attr path_beneath_attr = {\n\t\t.allowed_access = LANDLOCK_ACCESS_FS_READ_DIR,\n\t};\n\tint ruleset_fd_tx, dir_fd;\n\tint socket_fds[2];\n\tpid_t child;\n\tint status;\n\n\tdrop_caps(_metadata);\n\n\t \n\truleset_fd_tx =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tASSERT_LE(0, ruleset_fd_tx);\n\tpath_beneath_attr.parent_fd =\n\t\topen(\"/tmp\", O_PATH | O_NOFOLLOW | O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, path_beneath_attr.parent_fd);\n\tASSERT_EQ(0,\n\t\t  landlock_add_rule(ruleset_fd_tx, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t    &path_beneath_attr, 0));\n\tASSERT_EQ(0, close(path_beneath_attr.parent_fd));\n\n\t \n\tASSERT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0,\n\t\t\t\tsocket_fds));\n\tASSERT_EQ(0, send_fd(socket_fds[0], ruleset_fd_tx));\n\tASSERT_EQ(0, close(socket_fds[0]));\n\tASSERT_EQ(0, close(ruleset_fd_tx));\n\n\tchild = fork();\n\tASSERT_LE(0, child);\n\tif (child == 0) {\n\t\tconst int ruleset_fd_rx = recv_fd(socket_fds[1]);\n\n\t\tASSERT_LE(0, ruleset_fd_rx);\n\t\tASSERT_EQ(0, close(socket_fds[1]));\n\n\t\t \n\t\tASSERT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\t\tASSERT_EQ(0, landlock_restrict_self(ruleset_fd_rx, 0));\n\t\tASSERT_EQ(0, close(ruleset_fd_rx));\n\n\t\t \n\t\tASSERT_EQ(-1, open(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC));\n\t\tASSERT_EQ(EACCES, errno);\n\t\tdir_fd = open(\"/tmp\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n\t\tASSERT_LE(0, dir_fd);\n\t\tASSERT_EQ(0, close(dir_fd));\n\t\t_exit(_metadata->passed ? EXIT_SUCCESS : EXIT_FAILURE);\n\t\treturn;\n\t}\n\n\tASSERT_EQ(0, close(socket_fds[1]));\n\n\t \n\tdir_fd = open(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, dir_fd);\n\tASSERT_EQ(0, close(dir_fd));\n\tdir_fd = open(\"/tmp\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n\tASSERT_LE(0, dir_fd);\n\tASSERT_EQ(0, close(dir_fd));\n\n\tASSERT_EQ(child, waitpid(child, &status, 0));\n\tASSERT_EQ(1, WIFEXITED(status));\n\tASSERT_EQ(EXIT_SUCCESS, WEXITSTATUS(status));\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}