{
  "module_name": "common.h",
  "hash_id": "6df39754c49660635cb58596f100297b7749827adb0f8295eef3f12b53e6f36c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/landlock/common.h",
  "human_readable_source": " \n \n\n#include <errno.h>\n#include <linux/landlock.h>\n#include <sys/capability.h>\n#include <sys/socket.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"../kselftest_harness.h\"\n\n#ifndef __maybe_unused\n#define __maybe_unused __attribute__((__unused__))\n#endif\n\n \n \n#define TEST_F_FORK(fixture_name, test_name) \\\n\tstatic void fixture_name##_##test_name##_child( \\\n\t\tstruct __test_metadata *_metadata, \\\n\t\tFIXTURE_DATA(fixture_name) *self, \\\n\t\tconst FIXTURE_VARIANT(fixture_name) *variant); \\\n\tTEST_F(fixture_name, test_name) \\\n\t{ \\\n\t\tint status; \\\n\t\tconst pid_t child = fork(); \\\n\t\tif (child < 0) \\\n\t\t\tabort(); \\\n\t\tif (child == 0) { \\\n\t\t\t_metadata->no_print = 1; \\\n\t\t\tfixture_name##_##test_name##_child(_metadata, self, variant); \\\n\t\t\tif (_metadata->skip) \\\n\t\t\t\t_exit(255); \\\n\t\t\tif (_metadata->passed) \\\n\t\t\t\t_exit(0); \\\n\t\t\t_exit(_metadata->step); \\\n\t\t} \\\n\t\tif (child != waitpid(child, &status, 0)) \\\n\t\t\tabort(); \\\n\t\tif (WIFSIGNALED(status) || !WIFEXITED(status)) { \\\n\t\t\t_metadata->passed = 0; \\\n\t\t\t_metadata->step = 1; \\\n\t\t\treturn; \\\n\t\t} \\\n\t\tswitch (WEXITSTATUS(status)) { \\\n\t\tcase 0: \\\n\t\t\t_metadata->passed = 1; \\\n\t\t\tbreak; \\\n\t\tcase 255: \\\n\t\t\t_metadata->passed = 1; \\\n\t\t\t_metadata->skip = 1; \\\n\t\t\tbreak; \\\n\t\tdefault: \\\n\t\t\t_metadata->passed = 0; \\\n\t\t\t_metadata->step = WEXITSTATUS(status); \\\n\t\t\tbreak; \\\n\t\t} \\\n\t} \\\n\tstatic void fixture_name##_##test_name##_child( \\\n\t\tstruct __test_metadata __attribute__((unused)) *_metadata, \\\n\t\tFIXTURE_DATA(fixture_name) __attribute__((unused)) *self, \\\n\t\tconst FIXTURE_VARIANT(fixture_name) \\\n\t\t\t__attribute__((unused)) *variant)\n \n\n#ifndef landlock_create_ruleset\nstatic inline int\nlandlock_create_ruleset(const struct landlock_ruleset_attr *const attr,\n\t\t\tconst size_t size, const __u32 flags)\n{\n\treturn syscall(__NR_landlock_create_ruleset, attr, size, flags);\n}\n#endif\n\n#ifndef landlock_add_rule\nstatic inline int landlock_add_rule(const int ruleset_fd,\n\t\t\t\t    const enum landlock_rule_type rule_type,\n\t\t\t\t    const void *const rule_attr,\n\t\t\t\t    const __u32 flags)\n{\n\treturn syscall(__NR_landlock_add_rule, ruleset_fd, rule_type, rule_attr,\n\t\t       flags);\n}\n#endif\n\n#ifndef landlock_restrict_self\nstatic inline int landlock_restrict_self(const int ruleset_fd,\n\t\t\t\t\t const __u32 flags)\n{\n\treturn syscall(__NR_landlock_restrict_self, ruleset_fd, flags);\n}\n#endif\n\nstatic void _init_caps(struct __test_metadata *const _metadata, bool drop_all)\n{\n\tcap_t cap_p;\n\t \n\tconst cap_value_t caps[] = {\n\t\tCAP_DAC_OVERRIDE,\n\t\tCAP_MKNOD,\n\t\tCAP_SYS_ADMIN,\n\t\tCAP_SYS_CHROOT,\n\t};\n\n\tcap_p = cap_get_proc();\n\tEXPECT_NE(NULL, cap_p)\n\t{\n\t\tTH_LOG(\"Failed to cap_get_proc: %s\", strerror(errno));\n\t}\n\tEXPECT_NE(-1, cap_clear(cap_p))\n\t{\n\t\tTH_LOG(\"Failed to cap_clear: %s\", strerror(errno));\n\t}\n\tif (!drop_all) {\n\t\tEXPECT_NE(-1, cap_set_flag(cap_p, CAP_PERMITTED,\n\t\t\t\t\t   ARRAY_SIZE(caps), caps, CAP_SET))\n\t\t{\n\t\t\tTH_LOG(\"Failed to cap_set_flag: %s\", strerror(errno));\n\t\t}\n\t}\n\tEXPECT_NE(-1, cap_set_proc(cap_p))\n\t{\n\t\tTH_LOG(\"Failed to cap_set_proc: %s\", strerror(errno));\n\t}\n\tEXPECT_NE(-1, cap_free(cap_p))\n\t{\n\t\tTH_LOG(\"Failed to cap_free: %s\", strerror(errno));\n\t}\n}\n\n \nstatic void __maybe_unused disable_caps(struct __test_metadata *const _metadata)\n{\n\t_init_caps(_metadata, false);\n}\n\nstatic void __maybe_unused drop_caps(struct __test_metadata *const _metadata)\n{\n\t_init_caps(_metadata, true);\n}\n\nstatic void _effective_cap(struct __test_metadata *const _metadata,\n\t\t\t   const cap_value_t caps, const cap_flag_value_t value)\n{\n\tcap_t cap_p;\n\n\tcap_p = cap_get_proc();\n\tEXPECT_NE(NULL, cap_p)\n\t{\n\t\tTH_LOG(\"Failed to cap_get_proc: %s\", strerror(errno));\n\t}\n\tEXPECT_NE(-1, cap_set_flag(cap_p, CAP_EFFECTIVE, 1, &caps, value))\n\t{\n\t\tTH_LOG(\"Failed to cap_set_flag: %s\", strerror(errno));\n\t}\n\tEXPECT_NE(-1, cap_set_proc(cap_p))\n\t{\n\t\tTH_LOG(\"Failed to cap_set_proc: %s\", strerror(errno));\n\t}\n\tEXPECT_NE(-1, cap_free(cap_p))\n\t{\n\t\tTH_LOG(\"Failed to cap_free: %s\", strerror(errno));\n\t}\n}\n\nstatic void __maybe_unused set_cap(struct __test_metadata *const _metadata,\n\t\t\t\t   const cap_value_t caps)\n{\n\t_effective_cap(_metadata, caps, CAP_SET);\n}\n\nstatic void __maybe_unused clear_cap(struct __test_metadata *const _metadata,\n\t\t\t\t     const cap_value_t caps)\n{\n\t_effective_cap(_metadata, caps, CAP_CLEAR);\n}\n\n \nstatic int __maybe_unused recv_fd(int usock)\n{\n\tint fd_rx;\n\tunion {\n\t\t \n\t\tchar buf[CMSG_SPACE(sizeof(fd_rx))];\n\t\tstruct cmsghdr _align;\n\t} cmsg_rx = {};\n\tchar data = '\\0';\n\tstruct iovec io = {\n\t\t.iov_base = &data,\n\t\t.iov_len = sizeof(data),\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_iov = &io,\n\t\t.msg_iovlen = 1,\n\t\t.msg_control = &cmsg_rx.buf,\n\t\t.msg_controllen = sizeof(cmsg_rx.buf),\n\t};\n\tstruct cmsghdr *cmsg;\n\tint res;\n\n\tres = recvmsg(usock, &msg, MSG_CMSG_CLOEXEC);\n\tif (res < 0)\n\t\treturn -errno;\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(fd_rx)))\n\t\treturn -EIO;\n\n\tmemcpy(&fd_rx, CMSG_DATA(cmsg), sizeof(fd_rx));\n\treturn fd_rx;\n}\n\n \nstatic int __maybe_unused send_fd(int usock, int fd_tx)\n{\n\tunion {\n\t\t \n\t\tchar buf[CMSG_SPACE(sizeof(fd_tx))];\n\t\tstruct cmsghdr _align;\n\t} cmsg_tx = {};\n\tchar data_tx = '.';\n\tstruct iovec io = {\n\t\t.iov_base = &data_tx,\n\t\t.iov_len = sizeof(data_tx),\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_iov = &io,\n\t\t.msg_iovlen = 1,\n\t\t.msg_control = &cmsg_tx.buf,\n\t\t.msg_controllen = sizeof(cmsg_tx.buf),\n\t};\n\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);\n\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(fd_tx));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tmemcpy(CMSG_DATA(cmsg), &fd_tx, sizeof(fd_tx));\n\n\tif (sendmsg(usock, &msg, 0) < 0)\n\t\treturn -errno;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}