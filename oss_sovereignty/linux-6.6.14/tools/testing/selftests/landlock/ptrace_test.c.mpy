{
  "module_name": "ptrace_test.c",
  "hash_id": "38e2a07c930f8c7690a4c231b2261e8e9b3325e870e96261453e1335cf552b5f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/landlock/ptrace_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/landlock.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"common.h\"\n\n \n#define YAMA_SCOPE_DISABLED 0\n#define YAMA_SCOPE_RELATIONAL 1\n#define YAMA_SCOPE_CAPABILITY 2\n#define YAMA_SCOPE_NO_ATTACH 3\n\nstatic void create_domain(struct __test_metadata *const _metadata)\n{\n\tint ruleset_fd;\n\tstruct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = LANDLOCK_ACCESS_FS_MAKE_BLOCK,\n\t};\n\n\truleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tEXPECT_LE(0, ruleset_fd)\n\t{\n\t\tTH_LOG(\"Failed to create a ruleset: %s\", strerror(errno));\n\t}\n\tEXPECT_EQ(0, prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n\tEXPECT_EQ(0, landlock_restrict_self(ruleset_fd, 0));\n\tEXPECT_EQ(0, close(ruleset_fd));\n}\n\nstatic int test_ptrace_read(const pid_t pid)\n{\n\tstatic const char path_template[] = \"/proc/%d/environ\";\n\tchar procenv_path[sizeof(path_template) + 10];\n\tint procenv_path_size, fd;\n\n\tprocenv_path_size = snprintf(procenv_path, sizeof(procenv_path),\n\t\t\t\t     path_template, pid);\n\tif (procenv_path_size >= sizeof(procenv_path))\n\t\treturn E2BIG;\n\n\tfd = open(procenv_path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn errno;\n\t \n\tif (close(fd) != 0)\n\t\treturn errno;\n\treturn 0;\n}\n\nstatic int get_yama_ptrace_scope(void)\n{\n\tint ret;\n\tchar buf[2] = {};\n\tconst int fd = open(\"/proc/sys/kernel/yama/ptrace_scope\", O_RDONLY);\n\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (read(fd, buf, 1) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tret = atoi(buf);\n\tclose(fd);\n\treturn ret;\n}\n\n \nFIXTURE(hierarchy) {};\n \n\nFIXTURE_VARIANT(hierarchy)\n{\n\tconst bool domain_both;\n\tconst bool domain_parent;\n\tconst bool domain_child;\n};\n\n \n\n \n \nFIXTURE_VARIANT_ADD(hierarchy, allow_without_domain) {\n\t \n\t.domain_both = false,\n\t.domain_parent = false,\n\t.domain_child = false,\n};\n\n \n \nFIXTURE_VARIANT_ADD(hierarchy, allow_with_one_domain) {\n\t \n\t.domain_both = false,\n\t.domain_parent = false,\n\t.domain_child = true,\n};\n\n \n \nFIXTURE_VARIANT_ADD(hierarchy, deny_with_parent_domain) {\n\t \n\t.domain_both = false,\n\t.domain_parent = true,\n\t.domain_child = false,\n};\n\n \n \nFIXTURE_VARIANT_ADD(hierarchy, deny_with_sibling_domain) {\n\t \n\t.domain_both = false,\n\t.domain_parent = true,\n\t.domain_child = true,\n};\n\n \n \nFIXTURE_VARIANT_ADD(hierarchy, allow_sibling_domain) {\n\t \n\t.domain_both = true,\n\t.domain_parent = false,\n\t.domain_child = false,\n};\n\n \n \nFIXTURE_VARIANT_ADD(hierarchy, allow_with_nested_domain) {\n\t \n\t.domain_both = true,\n\t.domain_parent = false,\n\t.domain_child = true,\n};\n\n \n \nFIXTURE_VARIANT_ADD(hierarchy, deny_with_nested_and_parent_domain) {\n\t \n\t.domain_both = true,\n\t.domain_parent = true,\n\t.domain_child = false,\n};\n\n \n \nFIXTURE_VARIANT_ADD(hierarchy, deny_with_forked_domain) {\n\t \n\t.domain_both = true,\n\t.domain_parent = true,\n\t.domain_child = true,\n};\n\nFIXTURE_SETUP(hierarchy)\n{\n}\n\nFIXTURE_TEARDOWN(hierarchy)\n{\n}\n\n \nTEST_F(hierarchy, trace)\n{\n\tpid_t child, parent;\n\tint status, err_proc_read;\n\tint pipe_child[2], pipe_parent[2];\n\tint yama_ptrace_scope;\n\tchar buf_parent;\n\tlong ret;\n\tbool can_read_child, can_trace_child, can_read_parent, can_trace_parent;\n\n\tyama_ptrace_scope = get_yama_ptrace_scope();\n\tASSERT_LE(0, yama_ptrace_scope);\n\n\tif (yama_ptrace_scope > YAMA_SCOPE_DISABLED)\n\t\tTH_LOG(\"Incomplete tests due to Yama restrictions (scope %d)\",\n\t\t       yama_ptrace_scope);\n\n\t \n\tcan_read_child = !variant->domain_parent;\n\n\t \n\tcan_trace_child = can_read_child &&\n\t\t\t  yama_ptrace_scope <= YAMA_SCOPE_RELATIONAL;\n\n\t \n\tcan_read_parent = !variant->domain_child;\n\n\t \n\tcan_trace_parent = can_read_parent &&\n\t\t\t   yama_ptrace_scope <= YAMA_SCOPE_DISABLED;\n\n\t \n\tdrop_caps(_metadata);\n\n\tparent = getpid();\n\tASSERT_EQ(0, pipe2(pipe_child, O_CLOEXEC));\n\tASSERT_EQ(0, pipe2(pipe_parent, O_CLOEXEC));\n\tif (variant->domain_both) {\n\t\tcreate_domain(_metadata);\n\t\tif (!_metadata->passed)\n\t\t\t \n\t\t\treturn;\n\t}\n\n\tchild = fork();\n\tASSERT_LE(0, child);\n\tif (child == 0) {\n\t\tchar buf_child;\n\n\t\tASSERT_EQ(0, close(pipe_parent[1]));\n\t\tASSERT_EQ(0, close(pipe_child[0]));\n\t\tif (variant->domain_child)\n\t\t\tcreate_domain(_metadata);\n\n\t\t \n\t\tASSERT_EQ(1, read(pipe_parent[0], &buf_child, 1));\n\n\t\t \n\t\terr_proc_read = test_ptrace_read(parent);\n\t\tif (can_read_parent) {\n\t\t\tEXPECT_EQ(0, err_proc_read);\n\t\t} else {\n\t\t\tEXPECT_EQ(EACCES, err_proc_read);\n\t\t}\n\n\t\t \n\t\tret = ptrace(PTRACE_ATTACH, parent, NULL, 0);\n\t\tif (can_trace_parent) {\n\t\t\tEXPECT_EQ(0, ret);\n\t\t} else {\n\t\t\tEXPECT_EQ(-1, ret);\n\t\t\tEXPECT_EQ(EPERM, errno);\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tASSERT_EQ(parent, waitpid(parent, &status, 0));\n\t\t\tASSERT_EQ(1, WIFSTOPPED(status));\n\t\t\tASSERT_EQ(0, ptrace(PTRACE_DETACH, parent, NULL, 0));\n\t\t}\n\n\t\t \n\t\tret = ptrace(PTRACE_TRACEME);\n\t\tif (can_trace_child) {\n\t\t\tEXPECT_EQ(0, ret);\n\t\t} else {\n\t\t\tEXPECT_EQ(-1, ret);\n\t\t\tEXPECT_EQ(EPERM, errno);\n\t\t}\n\n\t\t \n\t\tASSERT_EQ(1, write(pipe_child[1], \".\", 1));\n\n\t\tif (can_trace_child) {\n\t\t\tASSERT_EQ(0, raise(SIGSTOP));\n\t\t}\n\n\t\t \n\t\tASSERT_EQ(1, read(pipe_parent[0], &buf_child, 1));\n\t\t_exit(_metadata->passed ? EXIT_SUCCESS : EXIT_FAILURE);\n\t\treturn;\n\t}\n\n\tASSERT_EQ(0, close(pipe_child[1]));\n\tASSERT_EQ(0, close(pipe_parent[0]));\n\tif (variant->domain_parent)\n\t\tcreate_domain(_metadata);\n\n\t \n\tASSERT_EQ(1, write(pipe_parent[1], \".\", 1));\n\n\t \n\tASSERT_EQ(1, read(pipe_child[0], &buf_parent, 1));\n\n\t \n\tif (can_trace_child) {\n\t\tASSERT_EQ(child, waitpid(child, &status, 0));\n\t\tASSERT_EQ(1, WIFSTOPPED(status));\n\t\tASSERT_EQ(0, ptrace(PTRACE_DETACH, child, NULL, 0));\n\t} else {\n\t\t \n\t\tEXPECT_EQ(-1, ptrace(PTRACE_DETACH, child, NULL, 0));\n\t\tEXPECT_EQ(ESRCH, errno);\n\t}\n\n\t \n\terr_proc_read = test_ptrace_read(child);\n\tif (can_read_child) {\n\t\tEXPECT_EQ(0, err_proc_read);\n\t} else {\n\t\tEXPECT_EQ(EACCES, err_proc_read);\n\t}\n\n\t \n\tret = ptrace(PTRACE_ATTACH, child, NULL, 0);\n\tif (can_trace_child) {\n\t\tEXPECT_EQ(0, ret);\n\t} else {\n\t\tEXPECT_EQ(-1, ret);\n\t\tEXPECT_EQ(EPERM, errno);\n\t}\n\n\tif (ret == 0) {\n\t\tASSERT_EQ(child, waitpid(child, &status, 0));\n\t\tASSERT_EQ(1, WIFSTOPPED(status));\n\t\tASSERT_EQ(0, ptrace(PTRACE_DETACH, child, NULL, 0));\n\t}\n\n\t \n\tASSERT_EQ(1, write(pipe_parent[1], \".\", 1));\n\tASSERT_EQ(child, waitpid(child, &status, 0));\n\tif (WIFSIGNALED(status) || !WIFEXITED(status) ||\n\t    WEXITSTATUS(status) != EXIT_SUCCESS)\n\t\t_metadata->passed = 0;\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}