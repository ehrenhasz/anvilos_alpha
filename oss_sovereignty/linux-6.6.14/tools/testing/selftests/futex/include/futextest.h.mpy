{
  "module_name": "futextest.h",
  "hash_id": "600e6f14b64807a943b8afc9eafc180d4d1bb55701099fe636356fe7451cbbbd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/futex/include/futextest.h",
  "human_readable_source": " \n \n\n#ifndef _FUTEXTEST_H\n#define _FUTEXTEST_H\n\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <linux/futex.h>\n\ntypedef volatile u_int32_t futex_t;\n#define FUTEX_INITIALIZER 0\n\n \n#ifndef FUTEX_WAIT_BITSET\n#define FUTEX_WAIT_BITSET\t\t9\n#endif\n#ifndef FUTEX_WAKE_BITSET\n#define FUTEX_WAKE_BITSET\t\t10\n#endif\n#ifndef FUTEX_WAIT_REQUEUE_PI\n#define FUTEX_WAIT_REQUEUE_PI\t\t11\n#endif\n#ifndef FUTEX_CMP_REQUEUE_PI\n#define FUTEX_CMP_REQUEUE_PI\t\t12\n#endif\n#ifndef FUTEX_WAIT_REQUEUE_PI_PRIVATE\n#define FUTEX_WAIT_REQUEUE_PI_PRIVATE\t(FUTEX_WAIT_REQUEUE_PI | \\\n\t\t\t\t\t FUTEX_PRIVATE_FLAG)\n#endif\n#ifndef FUTEX_REQUEUE_PI_PRIVATE\n#define FUTEX_CMP_REQUEUE_PI_PRIVATE\t(FUTEX_CMP_REQUEUE_PI | \\\n\t\t\t\t\t FUTEX_PRIVATE_FLAG)\n#endif\n\n \n#define futex(uaddr, op, val, timeout, uaddr2, val3, opflags) \\\n\tsyscall(SYS_futex, uaddr, op | opflags, val, timeout, uaddr2, val3)\n\n \nstatic inline int\nfutex_wait(futex_t *uaddr, futex_t val, struct timespec *timeout, int opflags)\n{\n\treturn futex(uaddr, FUTEX_WAIT, val, timeout, NULL, 0, opflags);\n}\n\n \nstatic inline int\nfutex_wake(futex_t *uaddr, int nr_wake, int opflags)\n{\n\treturn futex(uaddr, FUTEX_WAKE, nr_wake, NULL, NULL, 0, opflags);\n}\n\n \nstatic inline int\nfutex_wait_bitset(futex_t *uaddr, futex_t val, struct timespec *timeout,\n\t\t  u_int32_t bitset, int opflags)\n{\n\treturn futex(uaddr, FUTEX_WAIT_BITSET, val, timeout, NULL, bitset,\n\t\t     opflags);\n}\n\n \nstatic inline int\nfutex_wake_bitset(futex_t *uaddr, int nr_wake, u_int32_t bitset, int opflags)\n{\n\treturn futex(uaddr, FUTEX_WAKE_BITSET, nr_wake, NULL, NULL, bitset,\n\t\t     opflags);\n}\n\n \nstatic inline int\nfutex_lock_pi(futex_t *uaddr, struct timespec *timeout, int detect,\n\t      int opflags)\n{\n\treturn futex(uaddr, FUTEX_LOCK_PI, detect, timeout, NULL, 0, opflags);\n}\n\n \nstatic inline int\nfutex_unlock_pi(futex_t *uaddr, int opflags)\n{\n\treturn futex(uaddr, FUTEX_UNLOCK_PI, 0, NULL, NULL, 0, opflags);\n}\n\n \nstatic inline int\nfutex_wake_op(futex_t *uaddr, futex_t *uaddr2, int nr_wake, int nr_wake2,\n\t      int wake_op, int opflags)\n{\n\treturn futex(uaddr, FUTEX_WAKE_OP, nr_wake, nr_wake2, uaddr2, wake_op,\n\t\t     opflags);\n}\n\n \nstatic inline int\nfutex_requeue(futex_t *uaddr, futex_t *uaddr2, int nr_wake, int nr_requeue,\n\t      int opflags)\n{\n\treturn futex(uaddr, FUTEX_REQUEUE, nr_wake, nr_requeue, uaddr2, 0,\n\t\t     opflags);\n}\n\n \nstatic inline int\nfutex_cmp_requeue(futex_t *uaddr, futex_t val, futex_t *uaddr2, int nr_wake,\n\t\t  int nr_requeue, int opflags)\n{\n\treturn futex(uaddr, FUTEX_CMP_REQUEUE, nr_wake, nr_requeue, uaddr2,\n\t\t     val, opflags);\n}\n\n \nstatic inline int\nfutex_wait_requeue_pi(futex_t *uaddr, futex_t val, futex_t *uaddr2,\n\t\t      struct timespec *timeout, int opflags)\n{\n\treturn futex(uaddr, FUTEX_WAIT_REQUEUE_PI, val, timeout, uaddr2, 0,\n\t\t     opflags);\n}\n\n \nstatic inline int\nfutex_cmp_requeue_pi(futex_t *uaddr, futex_t val, futex_t *uaddr2, int nr_wake,\n\t\t     int nr_requeue, int opflags)\n{\n\treturn futex(uaddr, FUTEX_CMP_REQUEUE_PI, nr_wake, nr_requeue, uaddr2,\n\t\t     val, opflags);\n}\n\n \nstatic inline u_int32_t\nfutex_cmpxchg(futex_t *uaddr, u_int32_t oldval, u_int32_t newval)\n{\n\treturn __sync_val_compare_and_swap(uaddr, oldval, newval);\n}\n\n \nstatic inline u_int32_t\nfutex_dec(futex_t *uaddr)\n{\n\treturn __sync_sub_and_fetch(uaddr, 1);\n}\n\n \nstatic inline u_int32_t\nfutex_inc(futex_t *uaddr)\n{\n\treturn __sync_add_and_fetch(uaddr, 1);\n}\n\n \nstatic inline u_int32_t\nfutex_set(futex_t *uaddr, u_int32_t newval)\n{\n\t*uaddr = newval;\n\treturn newval;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}