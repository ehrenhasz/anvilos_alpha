{
  "module_name": "futex_requeue_pi_signal_restart.c",
  "hash_id": "79e97dc857ff63565e2224d4e3d47c40bcb414c2d0dd53381b9fd9b43ad0789d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/futex/functional/futex_requeue_pi_signal_restart.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <getopt.h>\n#include <limits.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"atomic.h\"\n#include \"futextest.h\"\n#include \"logging.h\"\n\n#define TEST_NAME \"futex-requeue-pi-signal-restart\"\n#define DELAY_US 100\n\nfutex_t f1 = FUTEX_INITIALIZER;\nfutex_t f2 = FUTEX_INITIALIZER;\natomic_t requeued = ATOMIC_INITIALIZER;\n\nint waiter_ret = 0;\n\nvoid usage(char *prog)\n{\n\tprintf(\"Usage: %s\\n\", prog);\n\tprintf(\"  -c\tUse color\\n\");\n\tprintf(\"  -h\tDisplay this help message\\n\");\n\tprintf(\"  -v L\tVerbosity level: %d=QUIET %d=CRITICAL %d=INFO\\n\",\n\t       VQUIET, VCRITICAL, VINFO);\n}\n\nint create_rt_thread(pthread_t *pth, void*(*func)(void *), void *arg,\n\t\t     int policy, int prio)\n{\n\tstruct sched_param schedp;\n\tpthread_attr_t attr;\n\tint ret;\n\n\tpthread_attr_init(&attr);\n\tmemset(&schedp, 0, sizeof(schedp));\n\n\tret = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n\tif (ret) {\n\t\terror(\"pthread_attr_setinheritsched\\n\", ret);\n\t\treturn -1;\n\t}\n\n\tret = pthread_attr_setschedpolicy(&attr, policy);\n\tif (ret) {\n\t\terror(\"pthread_attr_setschedpolicy\\n\", ret);\n\t\treturn -1;\n\t}\n\n\tschedp.sched_priority = prio;\n\tret = pthread_attr_setschedparam(&attr, &schedp);\n\tif (ret) {\n\t\terror(\"pthread_attr_setschedparam\\n\", ret);\n\t\treturn -1;\n\t}\n\n\tret = pthread_create(pth, &attr, func, arg);\n\tif (ret) {\n\t\terror(\"pthread_create\\n\", ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvoid handle_signal(int signo)\n{\n\tinfo(\"signal received %s requeue\\n\",\n\t     requeued.val ? \"after\" : \"prior to\");\n}\n\nvoid *waiterfn(void *arg)\n{\n\tunsigned int old_val;\n\tint res;\n\n\twaiter_ret = RET_PASS;\n\n\tinfo(\"Waiter running\\n\");\n\tinfo(\"Calling FUTEX_LOCK_PI on f2=%x @ %p\\n\", f2, &f2);\n\told_val = f1;\n\tres = futex_wait_requeue_pi(&f1, old_val, &(f2), NULL,\n\t\t\t\t    FUTEX_PRIVATE_FLAG);\n\tif (!requeued.val || errno != EWOULDBLOCK) {\n\t\tfail(\"unexpected return from futex_wait_requeue_pi: %d (%s)\\n\",\n\t\t     res, strerror(errno));\n\t\tinfo(\"w2:futex: %x\\n\", f2);\n\t\tif (!res)\n\t\t\tfutex_unlock_pi(&f2, FUTEX_PRIVATE_FLAG);\n\t\twaiter_ret = RET_FAIL;\n\t}\n\n\tinfo(\"Waiter exiting with %d\\n\", waiter_ret);\n\tpthread_exit(NULL);\n}\n\n\nint main(int argc, char *argv[])\n{\n\tunsigned int old_val;\n\tstruct sigaction sa;\n\tpthread_t waiter;\n\tint c, res, ret = RET_PASS;\n\n\twhile ((c = getopt(argc, argv, \"chv:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tlog_color(1);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(basename(argv[0]));\n\t\t\texit(0);\n\t\tcase 'v':\n\t\t\tlog_verbosity(atoi(optarg));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(basename(argv[0]));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tksft_print_header();\n\tksft_set_plan(1);\n\tksft_print_msg(\"%s: Test signal handling during requeue_pi\\n\",\n\t       basename(argv[0]));\n\tksft_print_msg(\"\\tArguments: <none>\\n\");\n\n\tsa.sa_handler = handle_signal;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\n\tif (sigaction(SIGUSR1, &sa, NULL)) {\n\t\terror(\"sigaction\\n\", errno);\n\t\texit(1);\n\t}\n\n\tinfo(\"m1:f2: %x\\n\", f2);\n\tinfo(\"Creating waiter\\n\");\n\tres = create_rt_thread(&waiter, waiterfn, NULL, SCHED_FIFO, 1);\n\tif (res) {\n\t\terror(\"Creating waiting thread failed\", res);\n\t\tret = RET_ERROR;\n\t\tgoto out;\n\t}\n\n\tinfo(\"Calling FUTEX_LOCK_PI on f2=%x @ %p\\n\", f2, &f2);\n\tinfo(\"m2:f2: %x\\n\", f2);\n\tfutex_lock_pi(&f2, 0, 0, FUTEX_PRIVATE_FLAG);\n\tinfo(\"m3:f2: %x\\n\", f2);\n\n\twhile (1) {\n\t\t \n\t\tinfo(\"Issuing SIGUSR1 to waiter\\n\");\n\t\tpthread_kill(waiter, SIGUSR1);\n\t\tusleep(DELAY_US);\n\n\t\tinfo(\"Requeueing waiter via FUTEX_CMP_REQUEUE_PI\\n\");\n\t\told_val = f1;\n\t\tres = futex_cmp_requeue_pi(&f1, old_val, &(f2), 1, 0,\n\t\t\t\t\t   FUTEX_PRIVATE_FLAG);\n\t\t \n\t\tif (res > 0) {\n\t\t\tatomic_set(&requeued, 1);\n\t\t\tbreak;\n\t\t} else if (res < 0) {\n\t\t\terror(\"FUTEX_CMP_REQUEUE_PI failed\\n\", errno);\n\t\t\tret = RET_ERROR;\n\t\t\tbreak;\n\t\t}\n\t}\n\tinfo(\"m4:f2: %x\\n\", f2);\n\n\t \n\tinfo(\"Issuing SIGUSR1 to waiter\\n\");\n\tpthread_kill(waiter, SIGUSR1);\n\tinfo(\"Waiting for waiter to return\\n\");\n\tpthread_join(waiter, NULL);\n\n\tinfo(\"Calling FUTEX_UNLOCK_PI on mutex=%x @ %p\\n\", f2, &f2);\n\tfutex_unlock_pi(&f2, FUTEX_PRIVATE_FLAG);\n\tinfo(\"m5:f2: %x\\n\", f2);\n\n out:\n\tif (ret == RET_PASS && waiter_ret)\n\t\tret = waiter_ret;\n\n\tprint_result(TEST_NAME, ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}