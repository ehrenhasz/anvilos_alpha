{
  "module_name": "futex_wait_timeout.c",
  "hash_id": "64eaeb8de664be7fa291b7667a2784487e3eecf68b3c17b78ff6a0864d963e53",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/futex/functional/futex_wait_timeout.c",
  "human_readable_source": "\n \n\n#include <pthread.h>\n#include \"futextest.h\"\n#include \"futex2test.h\"\n#include \"logging.h\"\n\n#define TEST_NAME \"futex-wait-timeout\"\n\nstatic long timeout_ns = 100000;\t \nstatic futex_t futex_pi;\nstatic pthread_barrier_t barrier;\n\nvoid usage(char *prog)\n{\n\tprintf(\"Usage: %s\\n\", prog);\n\tprintf(\"  -c\tUse color\\n\");\n\tprintf(\"  -h\tDisplay this help message\\n\");\n\tprintf(\"  -t N\tTimeout in nanoseconds (default: 100,000)\\n\");\n\tprintf(\"  -v L\tVerbosity level: %d=QUIET %d=CRITICAL %d=INFO\\n\",\n\t       VQUIET, VCRITICAL, VINFO);\n}\n\n \nvoid *get_pi_lock(void *arg)\n{\n\tint ret;\n\tvolatile futex_t lock = 0;\n\n\tret = futex_lock_pi(&futex_pi, NULL, 0, 0);\n\tif (ret != 0)\n\t\terror(\"futex_lock_pi failed\\n\", ret);\n\n\tpthread_barrier_wait(&barrier);\n\n\t \n\tret = futex_wait(&lock, 0, NULL, 0);\n\terror(\"futex_wait failed\\n\", ret);\n\n\treturn NULL;\n}\n\n \nstatic void test_timeout(int res, int *ret, char *test_name, int err)\n{\n\tif (!res || errno != err) {\n\t\tksft_test_result_fail(\"%s returned %d\\n\", test_name,\n\t\t\t\t      res < 0 ? errno : res);\n\t\t*ret = RET_FAIL;\n\t} else {\n\t\tksft_test_result_pass(\"%s succeeds\\n\", test_name);\n\t}\n}\n\n \nstatic int futex_get_abs_timeout(clockid_t clockid, struct timespec *to,\n\t\t\t\t long timeout_ns)\n{\n\tif (clock_gettime(clockid, to)) {\n\t\terror(\"clock_gettime failed\\n\", errno);\n\t\treturn errno;\n\t}\n\n\tto->tv_nsec += timeout_ns;\n\n\tif (to->tv_nsec >= 1000000000) {\n\t\tto->tv_sec++;\n\t\tto->tv_nsec -= 1000000000;\n\t}\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tfutex_t f1 = FUTEX_INITIALIZER;\n\tint res, ret = RET_PASS;\n\tstruct timespec to;\n\tpthread_t thread;\n\tint c;\n\tstruct futex_waitv waitv = {\n\t\t\t.uaddr = (uintptr_t)&f1,\n\t\t\t.val = f1,\n\t\t\t.flags = FUTEX_32,\n\t\t\t.__reserved = 0\n\t\t};\n\n\twhile ((c = getopt(argc, argv, \"cht:v:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tlog_color(1);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(basename(argv[0]));\n\t\t\texit(0);\n\t\tcase 't':\n\t\t\ttimeout_ns = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tlog_verbosity(atoi(optarg));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(basename(argv[0]));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tksft_print_header();\n\tksft_set_plan(9);\n\tksft_print_msg(\"%s: Block on a futex and wait for timeout\\n\",\n\t       basename(argv[0]));\n\tksft_print_msg(\"\\tArguments: timeout=%ldns\\n\", timeout_ns);\n\n\tpthread_barrier_init(&barrier, NULL, 2);\n\tpthread_create(&thread, NULL, get_pi_lock, NULL);\n\n\t \n\tto.tv_sec = 0;\n\tto.tv_nsec = timeout_ns;\n\n\tres = futex_wait(&f1, f1, &to, 0);\n\ttest_timeout(res, &ret, \"futex_wait relative\", ETIMEDOUT);\n\n\t \n\tif (futex_get_abs_timeout(CLOCK_REALTIME, &to, timeout_ns))\n\t\treturn RET_FAIL;\n\tres = futex_wait_bitset(&f1, f1, &to, 1, FUTEX_CLOCK_REALTIME);\n\ttest_timeout(res, &ret, \"futex_wait_bitset realtime\", ETIMEDOUT);\n\n\t \n\tif (futex_get_abs_timeout(CLOCK_MONOTONIC, &to, timeout_ns))\n\t\treturn RET_FAIL;\n\tres = futex_wait_bitset(&f1, f1, &to, 1, 0);\n\ttest_timeout(res, &ret, \"futex_wait_bitset monotonic\", ETIMEDOUT);\n\n\t \n\tif (futex_get_abs_timeout(CLOCK_REALTIME, &to, timeout_ns))\n\t\treturn RET_FAIL;\n\tres = futex_wait_requeue_pi(&f1, f1, &futex_pi, &to, FUTEX_CLOCK_REALTIME);\n\ttest_timeout(res, &ret, \"futex_wait_requeue_pi realtime\", ETIMEDOUT);\n\n\t \n\tif (futex_get_abs_timeout(CLOCK_MONOTONIC, &to, timeout_ns))\n\t\treturn RET_FAIL;\n\tres = futex_wait_requeue_pi(&f1, f1, &futex_pi, &to, 0);\n\ttest_timeout(res, &ret, \"futex_wait_requeue_pi monotonic\", ETIMEDOUT);\n\n\t \n\tpthread_barrier_wait(&barrier);\n\tpthread_barrier_destroy(&barrier);\n\t \n\tif (futex_get_abs_timeout(CLOCK_REALTIME, &to, timeout_ns))\n\t\treturn RET_FAIL;\n\tres = futex_lock_pi(&futex_pi, &to, 0, 0);\n\ttest_timeout(res, &ret, \"futex_lock_pi realtime\", ETIMEDOUT);\n\n\t \n\tres = futex_lock_pi(&futex_pi, NULL, 0, FUTEX_CLOCK_REALTIME);\n\ttest_timeout(res, &ret, \"futex_lock_pi invalid timeout flag\", ENOSYS);\n\n\t \n\tif (futex_get_abs_timeout(CLOCK_MONOTONIC, &to, timeout_ns))\n\t\treturn RET_FAIL;\n\tres = futex_waitv(&waitv, 1, 0, &to, CLOCK_MONOTONIC);\n\ttest_timeout(res, &ret, \"futex_waitv monotonic\", ETIMEDOUT);\n\n\t \n\tif (futex_get_abs_timeout(CLOCK_REALTIME, &to, timeout_ns))\n\t\treturn RET_FAIL;\n\tres = futex_waitv(&waitv, 1, 0, &to, CLOCK_REALTIME);\n\ttest_timeout(res, &ret, \"futex_waitv realtime\", ETIMEDOUT);\n\n\tksft_print_cnts();\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}