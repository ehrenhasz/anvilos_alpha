{
  "module_name": "futex_wait_uninitialized_heap.c",
  "hash_id": "d0afb161be27f3b9313851d710897b9f3055503e206868c31ebf343526b05814",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/futex/functional/futex_wait_uninitialized_heap.c",
  "human_readable_source": "\n \n\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <syscall.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <errno.h>\n#include <linux/futex.h>\n#include <libgen.h>\n\n#include \"logging.h\"\n#include \"futextest.h\"\n\n#define TEST_NAME \"futex-wait-uninitialized-heap\"\n#define WAIT_US 5000000\n\nstatic int child_blocked = 1;\nstatic int child_ret;\nvoid *buf;\n\nvoid usage(char *prog)\n{\n\tprintf(\"Usage: %s\\n\", prog);\n\tprintf(\"  -c\tUse color\\n\");\n\tprintf(\"  -h\tDisplay this help message\\n\");\n\tprintf(\"  -v L\tVerbosity level: %d=QUIET %d=CRITICAL %d=INFO\\n\",\n\t       VQUIET, VCRITICAL, VINFO);\n}\n\nvoid *wait_thread(void *arg)\n{\n\tint res;\n\n\tchild_ret = RET_PASS;\n\tres = futex_wait(buf, 1, NULL, 0);\n\tchild_blocked = 0;\n\n\tif (res != 0 && errno != EWOULDBLOCK) {\n\t\terror(\"futex failure\\n\", errno);\n\t\tchild_ret = RET_ERROR;\n\t}\n\tpthread_exit(NULL);\n}\n\nint main(int argc, char **argv)\n{\n\tint c, ret = RET_PASS;\n\tlong page_size;\n\tpthread_t thr;\n\n\twhile ((c = getopt(argc, argv, \"chv:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tlog_color(1);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(basename(argv[0]));\n\t\t\texit(0);\n\t\tcase 'v':\n\t\t\tlog_verbosity(atoi(optarg));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(basename(argv[0]));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpage_size = sysconf(_SC_PAGESIZE);\n\n\tbuf = mmap(NULL, page_size, PROT_READ|PROT_WRITE,\n\t\t   MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);\n\tif (buf == (void *)-1) {\n\t\terror(\"mmap\\n\", errno);\n\t\texit(1);\n\t}\n\n\tksft_print_header();\n\tksft_set_plan(1);\n\tksft_print_msg(\"%s: Test the uninitialized futex value in FUTEX_WAIT\\n\",\n\t       basename(argv[0]));\n\n\n\tret = pthread_create(&thr, NULL, wait_thread, NULL);\n\tif (ret) {\n\t\terror(\"pthread_create\\n\", errno);\n\t\tret = RET_ERROR;\n\t\tgoto out;\n\t}\n\n\tinfo(\"waiting %dus for child to return\\n\", WAIT_US);\n\tusleep(WAIT_US);\n\n\tret = child_ret;\n\tif (child_blocked) {\n\t\tfail(\"child blocked in kernel\\n\");\n\t\tret = RET_FAIL;\n\t}\n\n out:\n\tprint_result(TEST_NAME, ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}