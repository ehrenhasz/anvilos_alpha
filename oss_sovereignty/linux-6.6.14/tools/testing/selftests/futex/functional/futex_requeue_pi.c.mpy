{
  "module_name": "futex_requeue_pi.c",
  "hash_id": "6f9c9349ef77bf4b73c77d46ab0fd82eb15b14670093bc8e3d35a6f481e1f0a8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/futex/functional/futex_requeue_pi.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <limits.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include \"atomic.h\"\n#include \"futextest.h\"\n#include \"logging.h\"\n\n#define TEST_NAME \"futex-requeue-pi\"\n#define MAX_WAKE_ITERS 1000\n#define THREAD_MAX 10\n#define SIGNAL_PERIOD_US 100\n\natomic_t waiters_blocked = ATOMIC_INITIALIZER;\natomic_t waiters_woken = ATOMIC_INITIALIZER;\n\nfutex_t f1 = FUTEX_INITIALIZER;\nfutex_t f2 = FUTEX_INITIALIZER;\nfutex_t wake_complete = FUTEX_INITIALIZER;\n\n \nstatic long timeout_ns;\nstatic int broadcast;\nstatic int owner;\nstatic int locked;\n\nstruct thread_arg {\n\tlong id;\n\tstruct timespec *timeout;\n\tint lock;\n\tint ret;\n};\n#define THREAD_ARG_INITIALIZER { 0, NULL, 0, 0 }\n\nvoid usage(char *prog)\n{\n\tprintf(\"Usage: %s\\n\", prog);\n\tprintf(\"  -b\tBroadcast wakeup (all waiters)\\n\");\n\tprintf(\"  -c\tUse color\\n\");\n\tprintf(\"  -h\tDisplay this help message\\n\");\n\tprintf(\"  -l\tLock the pi futex across requeue\\n\");\n\tprintf(\"  -o\tUse a third party pi futex owner during requeue (cancels -l)\\n\");\n\tprintf(\"  -t N\tTimeout in nanoseconds (default: 0)\\n\");\n\tprintf(\"  -v L\tVerbosity level: %d=QUIET %d=CRITICAL %d=INFO\\n\",\n\t       VQUIET, VCRITICAL, VINFO);\n}\n\nint create_rt_thread(pthread_t *pth, void*(*func)(void *), void *arg,\n\t\t     int policy, int prio)\n{\n\tint ret;\n\tstruct sched_param schedp;\n\tpthread_attr_t attr;\n\n\tpthread_attr_init(&attr);\n\tmemset(&schedp, 0, sizeof(schedp));\n\n\tret = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n\tif (ret) {\n\t\terror(\"pthread_attr_setinheritsched\\n\", ret);\n\t\treturn -1;\n\t}\n\n\tret = pthread_attr_setschedpolicy(&attr, policy);\n\tif (ret) {\n\t\terror(\"pthread_attr_setschedpolicy\\n\", ret);\n\t\treturn -1;\n\t}\n\n\tschedp.sched_priority = prio;\n\tret = pthread_attr_setschedparam(&attr, &schedp);\n\tif (ret) {\n\t\terror(\"pthread_attr_setschedparam\\n\", ret);\n\t\treturn -1;\n\t}\n\n\tret = pthread_create(pth, &attr, func, arg);\n\tif (ret) {\n\t\terror(\"pthread_create\\n\", ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n\nvoid *waiterfn(void *arg)\n{\n\tstruct thread_arg *args = (struct thread_arg *)arg;\n\tfutex_t old_val;\n\n\tinfo(\"Waiter %ld: running\\n\", args->id);\n\t \n\tusleep(1000 * (long)args->id);\n\n\told_val = f1;\n\tatomic_inc(&waiters_blocked);\n\tinfo(\"Calling futex_wait_requeue_pi: %p (%u) -> %p\\n\",\n\t     &f1, f1, &f2);\n\targs->ret = futex_wait_requeue_pi(&f1, old_val, &f2, args->timeout,\n\t\t\t\t\t  FUTEX_PRIVATE_FLAG);\n\n\tinfo(\"waiter %ld woke with %d %s\\n\", args->id, args->ret,\n\t     args->ret < 0 ? strerror(errno) : \"\");\n\tatomic_inc(&waiters_woken);\n\tif (args->ret < 0) {\n\t\tif (args->timeout && errno == ETIMEDOUT)\n\t\t\targs->ret = 0;\n\t\telse {\n\t\t\targs->ret = RET_ERROR;\n\t\t\terror(\"futex_wait_requeue_pi\\n\", errno);\n\t\t}\n\t\tfutex_lock_pi(&f2, NULL, 0, FUTEX_PRIVATE_FLAG);\n\t}\n\tfutex_unlock_pi(&f2, FUTEX_PRIVATE_FLAG);\n\n\tinfo(\"Waiter %ld: exiting with %d\\n\", args->id, args->ret);\n\tpthread_exit((void *)&args->ret);\n}\n\nvoid *broadcast_wakerfn(void *arg)\n{\n\tstruct thread_arg *args = (struct thread_arg *)arg;\n\tint nr_requeue = INT_MAX;\n\tint task_count = 0;\n\tfutex_t old_val;\n\tint nr_wake = 1;\n\tint i = 0;\n\n\tinfo(\"Waker: waiting for waiters to block\\n\");\n\twhile (waiters_blocked.val < THREAD_MAX)\n\t\tusleep(1000);\n\tusleep(1000);\n\n\tinfo(\"Waker: Calling broadcast\\n\");\n\tif (args->lock) {\n\t\tinfo(\"Calling FUTEX_LOCK_PI on mutex=%x @ %p\\n\", f2, &f2);\n\t\tfutex_lock_pi(&f2, NULL, 0, FUTEX_PRIVATE_FLAG);\n\t}\n continue_requeue:\n\told_val = f1;\n\targs->ret = futex_cmp_requeue_pi(&f1, old_val, &f2, nr_wake, nr_requeue,\n\t\t\t\t   FUTEX_PRIVATE_FLAG);\n\tif (args->ret < 0) {\n\t\targs->ret = RET_ERROR;\n\t\terror(\"FUTEX_CMP_REQUEUE_PI failed\\n\", errno);\n\t} else if (++i < MAX_WAKE_ITERS) {\n\t\ttask_count += args->ret;\n\t\tif (task_count < THREAD_MAX - waiters_woken.val)\n\t\t\tgoto continue_requeue;\n\t} else {\n\t\terror(\"max broadcast iterations (%d) reached with %d/%d tasks woken or requeued\\n\",\n\t\t       0, MAX_WAKE_ITERS, task_count, THREAD_MAX);\n\t\targs->ret = RET_ERROR;\n\t}\n\n\tfutex_wake(&wake_complete, 1, FUTEX_PRIVATE_FLAG);\n\n\tif (args->lock)\n\t\tfutex_unlock_pi(&f2, FUTEX_PRIVATE_FLAG);\n\n\tif (args->ret > 0)\n\t\targs->ret = task_count;\n\n\tinfo(\"Waker: exiting with %d\\n\", args->ret);\n\tpthread_exit((void *)&args->ret);\n}\n\nvoid *signal_wakerfn(void *arg)\n{\n\tstruct thread_arg *args = (struct thread_arg *)arg;\n\tunsigned int old_val;\n\tint nr_requeue = 0;\n\tint task_count = 0;\n\tint nr_wake = 1;\n\tint i = 0;\n\n\tinfo(\"Waker: waiting for waiters to block\\n\");\n\twhile (waiters_blocked.val < THREAD_MAX)\n\t\tusleep(1000);\n\tusleep(1000);\n\n\twhile (task_count < THREAD_MAX && waiters_woken.val < THREAD_MAX) {\n\t\tinfo(\"task_count: %d, waiters_woken: %d\\n\",\n\t\t     task_count, waiters_woken.val);\n\t\tif (args->lock) {\n\t\t\tinfo(\"Calling FUTEX_LOCK_PI on mutex=%x @ %p\\n\",\n\t\t\t     f2, &f2);\n\t\t\tfutex_lock_pi(&f2, NULL, 0, FUTEX_PRIVATE_FLAG);\n\t\t}\n\t\tinfo(\"Waker: Calling signal\\n\");\n\t\t \n\t\told_val = f1;\n\t\targs->ret = futex_cmp_requeue_pi(&f1, old_val, &f2,\n\t\t\t\t\t\t nr_wake, nr_requeue,\n\t\t\t\t\t\t FUTEX_PRIVATE_FLAG);\n\t\tif (args->ret < 0)\n\t\t\targs->ret = -errno;\n\t\tinfo(\"futex: %x\\n\", f2);\n\t\tif (args->lock) {\n\t\t\tinfo(\"Calling FUTEX_UNLOCK_PI on mutex=%x @ %p\\n\",\n\t\t\t     f2, &f2);\n\t\t\tfutex_unlock_pi(&f2, FUTEX_PRIVATE_FLAG);\n\t\t}\n\t\tinfo(\"futex: %x\\n\", f2);\n\t\tif (args->ret < 0) {\n\t\t\terror(\"FUTEX_CMP_REQUEUE_PI failed\\n\", errno);\n\t\t\targs->ret = RET_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\ttask_count += args->ret;\n\t\tusleep(SIGNAL_PERIOD_US);\n\t\ti++;\n\t\t \n\t\tif (i > MAX_WAKE_ITERS + THREAD_MAX) {\n\t\t\terror(\"max signaling iterations (%d) reached, giving up on pending waiters.\\n\",\n\t\t\t      0, MAX_WAKE_ITERS + THREAD_MAX);\n\t\t\targs->ret = RET_ERROR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfutex_wake(&wake_complete, 1, FUTEX_PRIVATE_FLAG);\n\n\tif (args->ret >= 0)\n\t\targs->ret = task_count;\n\n\tinfo(\"Waker: exiting with %d\\n\", args->ret);\n\tinfo(\"Waker: waiters_woken: %d\\n\", waiters_woken.val);\n\tpthread_exit((void *)&args->ret);\n}\n\nvoid *third_party_blocker(void *arg)\n{\n\tstruct thread_arg *args = (struct thread_arg *)arg;\n\tint ret2 = 0;\n\n\targs->ret = futex_lock_pi(&f2, NULL, 0, FUTEX_PRIVATE_FLAG);\n\tif (args->ret)\n\t\tgoto out;\n\targs->ret = futex_wait(&wake_complete, wake_complete, NULL,\n\t\t\t       FUTEX_PRIVATE_FLAG);\n\tret2 = futex_unlock_pi(&f2, FUTEX_PRIVATE_FLAG);\n\n out:\n\tif (args->ret || ret2) {\n\t\terror(\"third_party_blocker() futex error\", 0);\n\t\targs->ret = RET_ERROR;\n\t}\n\n\tpthread_exit((void *)&args->ret);\n}\n\nint unit_test(int broadcast, long lock, int third_party_owner, long timeout_ns)\n{\n\tvoid *(*wakerfn)(void *) = signal_wakerfn;\n\tstruct thread_arg blocker_arg = THREAD_ARG_INITIALIZER;\n\tstruct thread_arg waker_arg = THREAD_ARG_INITIALIZER;\n\tpthread_t waiter[THREAD_MAX], waker, blocker;\n\tstruct timespec ts, *tsp = NULL;\n\tstruct thread_arg args[THREAD_MAX];\n\tint *waiter_ret;\n\tint i, ret = RET_PASS;\n\n\tif (timeout_ns) {\n\t\ttime_t secs;\n\n\t\tinfo(\"timeout_ns = %ld\\n\", timeout_ns);\n\t\tret = clock_gettime(CLOCK_MONOTONIC, &ts);\n\t\tsecs = (ts.tv_nsec + timeout_ns) / 1000000000;\n\t\tts.tv_nsec = ((int64_t)ts.tv_nsec + timeout_ns) % 1000000000;\n\t\tts.tv_sec += secs;\n\t\tinfo(\"ts.tv_sec  = %ld\\n\", ts.tv_sec);\n\t\tinfo(\"ts.tv_nsec = %ld\\n\", ts.tv_nsec);\n\t\ttsp = &ts;\n\t}\n\n\tif (broadcast)\n\t\twakerfn = broadcast_wakerfn;\n\n\tif (third_party_owner) {\n\t\tif (create_rt_thread(&blocker, third_party_blocker,\n\t\t\t\t     (void *)&blocker_arg, SCHED_FIFO, 1)) {\n\t\t\terror(\"Creating third party blocker thread failed\\n\",\n\t\t\t      errno);\n\t\t\tret = RET_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tatomic_set(&waiters_woken, 0);\n\tfor (i = 0; i < THREAD_MAX; i++) {\n\t\targs[i].id = i;\n\t\targs[i].timeout = tsp;\n\t\tinfo(\"Starting thread %d\\n\", i);\n\t\tif (create_rt_thread(&waiter[i], waiterfn, (void *)&args[i],\n\t\t\t\t     SCHED_FIFO, 1)) {\n\t\t\terror(\"Creating waiting thread failed\\n\", errno);\n\t\t\tret = RET_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\twaker_arg.lock = lock;\n\tif (create_rt_thread(&waker, wakerfn, (void *)&waker_arg,\n\t\t\t     SCHED_FIFO, 1)) {\n\t\terror(\"Creating waker thread failed\\n\", errno);\n\t\tret = RET_ERROR;\n\t\tgoto out;\n\t}\n\n\t \n\t \n\twaiter_ret = &args[0].ret;\n\tfor (i = 0; i < THREAD_MAX; i++)\n\t\tpthread_join(waiter[i],\n\t\t\t     *waiter_ret ? NULL : (void **)&waiter_ret);\n\n\tif (third_party_owner)\n\t\tpthread_join(blocker, NULL);\n\tpthread_join(waker, NULL);\n\nout:\n\tif (!ret) {\n\t\tif (*waiter_ret)\n\t\t\tret = *waiter_ret;\n\t\telse if (waker_arg.ret < 0)\n\t\t\tret = waker_arg.ret;\n\t\telse if (blocker_arg.ret)\n\t\t\tret = blocker_arg.ret;\n\t}\n\n\treturn ret;\n}\n\nint main(int argc, char *argv[])\n{\n\tint c, ret;\n\n\twhile ((c = getopt(argc, argv, \"bchlot:v:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'b':\n\t\t\tbroadcast = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tlog_color(1);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(basename(argv[0]));\n\t\t\texit(0);\n\t\tcase 'l':\n\t\t\tlocked = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\towner = 1;\n\t\t\tlocked = 0;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttimeout_ns = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tlog_verbosity(atoi(optarg));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(basename(argv[0]));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tksft_print_header();\n\tksft_set_plan(1);\n\tksft_print_msg(\"%s: Test requeue functionality\\n\", basename(argv[0]));\n\tksft_print_msg(\n\t\t\"\\tArguments: broadcast=%d locked=%d owner=%d timeout=%ldns\\n\",\n\t\tbroadcast, locked, owner, timeout_ns);\n\n\t \n\tret = unit_test(broadcast, locked, owner, timeout_ns);\n\n\tprint_result(TEST_NAME, ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}