{
  "module_name": "devpts_pts.c",
  "hash_id": "ee614d458268782f2e52e0face80e0d17045228c194e40307a96d6c50ae1afcc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/filesystems/devpts_pts.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <asm/ioctls.h>\n#include <sys/mount.h>\n#include <sys/wait.h>\n#include \"../kselftest.h\"\n\nstatic bool terminal_dup2(int duplicate, int original)\n{\n\tint ret;\n\n\tret = dup2(duplicate, original);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int terminal_set_stdfds(int fd)\n{\n\tint i;\n\n\tif (fd < 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (!terminal_dup2(fd, (int[]){STDIN_FILENO, STDOUT_FILENO,\n\t\t\t\t\t       STDERR_FILENO}[i]))\n\t\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int login_pty(int fd)\n{\n\tint ret;\n\n\tsetsid();\n\n\tret = ioctl(fd, TIOCSCTTY, NULL);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tret = terminal_set_stdfds(fd);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tif (fd > STDERR_FILENO)\n\t\tclose(fd);\n\n\treturn 0;\n}\n\nstatic int wait_for_pid(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\treturn -1;\n\t}\n\tif (ret != pid)\n\t\tgoto again;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int resolve_procfd_symlink(int fd, char *buf, size_t buflen)\n{\n\tint ret;\n\tchar procfd[4096];\n\n\tret = snprintf(procfd, 4096, \"/proc/self/fd/%d\", fd);\n\tif (ret < 0 || ret >= 4096)\n\t\treturn -1;\n\n\tret = readlink(procfd, buf, buflen);\n\tif (ret < 0 || (size_t)ret >= buflen)\n\t\treturn -1;\n\n\tbuf[ret] = '\\0';\n\n\treturn 0;\n}\n\nstatic int do_tiocgptpeer(char *ptmx, char *expected_procfd_contents)\n{\n\tint ret;\n\tint master = -1, slave = -1, fret = -1;\n\n\tmaster = open(ptmx, O_RDWR | O_NOCTTY | O_CLOEXEC);\n\tif (master < 0) {\n\t\tfprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\", ptmx,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\t \n\tret = unlockpt(master);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to unlock terminal\\n\");\n\t\tgoto do_cleanup;\n\t}\n\n#ifdef TIOCGPTPEER\n\tslave = ioctl(master, TIOCGPTPEER, O_RDWR | O_NOCTTY | O_CLOEXEC);\n#endif\n\tif (slave < 0) {\n\t\tif (errno == EINVAL) {\n\t\t\tfprintf(stderr, \"TIOCGPTPEER is not supported. \"\n\t\t\t\t\t\"Skipping test.\\n\");\n\t\t\tfret = KSFT_SKIP;\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Failed to perform TIOCGPTPEER ioctl\\n\");\n\t\t\tfret = EXIT_FAILURE;\n\t\t}\n\t\tgoto do_cleanup;\n\t}\n\n\tpid_t pid = fork();\n\tif (pid < 0)\n\t\tgoto do_cleanup;\n\n\tif (pid == 0) {\n\t\tchar buf[4096];\n\n\t\tret = login_pty(slave);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Failed to setup terminal\\n\");\n\t\t\t_exit(EXIT_FAILURE);\n\t\t}\n\n\t\tret = resolve_procfd_symlink(STDIN_FILENO, buf, sizeof(buf));\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Failed to retrieve pathname of pts \"\n\t\t\t\t\t\"slave file descriptor\\n\");\n\t\t\t_exit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (strncmp(expected_procfd_contents, buf,\n\t\t\t    strlen(expected_procfd_contents)) != 0) {\n\t\t\tfprintf(stderr, \"Received invalid contents for \"\n\t\t\t\t\t\"\\\"/proc/<pid>/fd/%d\\\" symlink: %s\\n\",\n\t\t\t\t\tSTDIN_FILENO, buf);\n\t\t\t_exit(-1);\n\t\t}\n\n\t\tfprintf(stderr, \"Contents of \\\"/proc/<pid>/fd/%d\\\" \"\n\t\t\t\t\"symlink are valid: %s\\n\", STDIN_FILENO, buf);\n\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\n\tret = wait_for_pid(pid);\n\tif (ret < 0)\n\t\tgoto do_cleanup;\n\n\tfret = EXIT_SUCCESS;\n\ndo_cleanup:\n\tif (master >= 0)\n\t\tclose(master);\n\tif (slave >= 0)\n\t\tclose(slave);\n\n\treturn fret;\n}\n\nstatic int verify_non_standard_devpts_mount(void)\n{\n\tchar *mntpoint;\n\tint ret = -1;\n\tchar devpts[] = P_tmpdir \"/devpts_fs_XXXXXX\";\n\tchar ptmx[] = P_tmpdir \"/devpts_fs_XXXXXX/ptmx\";\n\n\tret = umount(\"/dev/pts\");\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to unmount \\\"/dev/pts\\\": %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\t(void)umount(\"/dev/ptmx\");\n\n\tmntpoint = mkdtemp(devpts);\n\tif (!mntpoint) {\n\t\tfprintf(stderr, \"Failed to create temporary mountpoint: %s\\n\",\n\t\t\t\t strerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = mount(\"devpts\", mntpoint, \"devpts\", MS_NOSUID | MS_NOEXEC,\n\t\t    \"newinstance,ptmxmode=0666,mode=0620,gid=5\");\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to mount devpts fs to \\\"%s\\\" in new \"\n\t\t\t\t\"mount namespace: %s\\n\", mntpoint,\n\t\t\t\tstrerror(errno));\n\t\tunlink(mntpoint);\n\t\treturn -1;\n\t}\n\n\tret = snprintf(ptmx, sizeof(ptmx), \"%s/ptmx\", devpts);\n\tif (ret < 0 || (size_t)ret >= sizeof(ptmx)) {\n\t\tunlink(mntpoint);\n\t\treturn -1;\n\t}\n\n\tret = do_tiocgptpeer(ptmx, mntpoint);\n\tunlink(mntpoint);\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int verify_ptmx_bind_mount(void)\n{\n\tint ret;\n\n\tret = mount(\"/dev/pts/ptmx\", \"/dev/ptmx\", NULL, MS_BIND, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to bind mount \\\"/dev/pts/ptmx\\\" to \"\n\t\t\t\t\"\\\"/dev/ptmx\\\" mount namespace\\n\");\n\t\treturn -1;\n\t}\n\n\tret = do_tiocgptpeer(\"/dev/ptmx\", \"/dev/pts/\");\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int verify_invalid_ptmx_bind_mount(void)\n{\n\tint ret;\n\tchar mntpoint_fd;\n\tchar ptmx[] = P_tmpdir \"/devpts_ptmx_XXXXXX\";\n\n\tmntpoint_fd = mkstemp(ptmx);\n\tif (mntpoint_fd < 0) {\n\t\tfprintf(stderr, \"Failed to create temporary directory: %s\\n\",\n\t\t\t\t strerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = mount(\"/dev/pts/ptmx\", ptmx, NULL, MS_BIND, NULL);\n\tclose(mntpoint_fd);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to bind mount \\\"/dev/pts/ptmx\\\" to \"\n\t\t\t\t\"\\\"%s\\\" mount namespace\\n\", ptmx);\n\t\treturn -1;\n\t}\n\n\tret = do_tiocgptpeer(ptmx, \"/dev/pts/\");\n\tif (ret == 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret;\n\n\tif (!isatty(STDIN_FILENO)) {\n\t\tfprintf(stderr, \"Standard input file descriptor is not attached \"\n\t\t\t\t\"to a terminal. Skipping test\\n\");\n\t\texit(KSFT_SKIP);\n\t}\n\n\tret = unshare(CLONE_NEWNS);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to unshare mount namespace\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tret = mount(\"\", \"/\", NULL, MS_PRIVATE | MS_REC, 0);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to make \\\"/\\\" MS_PRIVATE in new mount \"\n\t\t\t\t\"namespace\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tret = verify_ptmx_bind_mount();\n\tif (ret < 0)\n\t\texit(EXIT_FAILURE);\n\n\tret = verify_invalid_ptmx_bind_mount();\n\tif (ret < 0)\n\t\texit(EXIT_FAILURE);\n\n\tret = verify_non_standard_devpts_mount();\n\tif (ret < 0)\n\t\texit(EXIT_FAILURE);\n\n\texit(EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}