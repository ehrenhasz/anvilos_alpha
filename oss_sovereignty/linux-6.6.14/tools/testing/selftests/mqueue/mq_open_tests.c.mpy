{
  "module_name": "mq_open_tests.c",
  "hash_id": "d715a9bc28ad362e7cf08d5557005ad746a04d13f3b9dd108d86cf8464241869",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mqueue/mq_open_tests.c",
  "human_readable_source": " \n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <mqueue.h>\n#include <error.h>\n\n#include \"../kselftest.h\"\n\nstatic char *usage =\n\"Usage:\\n\"\n\"  %s path\\n\"\n\"\\n\"\n\"\tpath\tPath name of the message queue to create\\n\"\n\"\\n\"\n\"\tNote: this program must be run as root in order to enable all tests\\n\"\n\"\\n\";\n\nchar *DEF_MSGS = \"/proc/sys/fs/mqueue/msg_default\";\nchar *DEF_MSGSIZE = \"/proc/sys/fs/mqueue/msgsize_default\";\nchar *MAX_MSGS = \"/proc/sys/fs/mqueue/msg_max\";\nchar *MAX_MSGSIZE = \"/proc/sys/fs/mqueue/msgsize_max\";\n\nint default_settings;\nstruct rlimit saved_limits, cur_limits;\nint saved_def_msgs, saved_def_msgsize, saved_max_msgs, saved_max_msgsize;\nint cur_def_msgs, cur_def_msgsize, cur_max_msgs, cur_max_msgsize;\nFILE *def_msgs, *def_msgsize, *max_msgs, *max_msgsize;\nchar *queue_path;\nchar *default_queue_path = \"/test1\";\nmqd_t queue = -1;\n\nstatic inline void __set(FILE *stream, int value, char *err_msg);\nvoid shutdown(int exit_val, char *err_cause, int line_no);\nstatic inline int get(FILE *stream);\nstatic inline void set(FILE *stream, int value);\nstatic inline void getr(int type, struct rlimit *rlim);\nstatic inline void setr(int type, struct rlimit *rlim);\nvoid validate_current_settings();\nstatic inline void test_queue(struct mq_attr *attr, struct mq_attr *result);\nstatic inline int test_queue_fail(struct mq_attr *attr, struct mq_attr *result);\n\nstatic inline void __set(FILE *stream, int value, char *err_msg)\n{\n\trewind(stream);\n\tif (fprintf(stream, \"%d\", value) < 0)\n\t\tperror(err_msg);\n}\n\n\nvoid shutdown(int exit_val, char *err_cause, int line_no)\n{\n\tstatic int in_shutdown = 0;\n\n\t \n\tif (in_shutdown++)\n\t\treturn;\n\n\tif (seteuid(0) == -1)\n\t\tperror(\"seteuid() failed\");\n\n\tif (queue != -1)\n\t\tif (mq_close(queue))\n\t\t\tperror(\"mq_close() during shutdown\");\n\tif (queue_path)\n\t\t \n\t\tmq_unlink(queue_path);\n\tif (default_settings) {\n\t\tif (saved_def_msgs)\n\t\t\t__set(def_msgs, saved_def_msgs,\n\t\t\t      \"failed to restore saved_def_msgs\");\n\t\tif (saved_def_msgsize)\n\t\t\t__set(def_msgsize, saved_def_msgsize,\n\t\t\t      \"failed to restore saved_def_msgsize\");\n\t}\n\tif (saved_max_msgs)\n\t\t__set(max_msgs, saved_max_msgs,\n\t\t      \"failed to restore saved_max_msgs\");\n\tif (saved_max_msgsize)\n\t\t__set(max_msgsize, saved_max_msgsize,\n\t\t      \"failed to restore saved_max_msgsize\");\n\tif (exit_val)\n\t\terror(exit_val, errno, \"%s at %d\", err_cause, line_no);\n\texit(0);\n}\n\nstatic inline int get(FILE *stream)\n{\n\tint value;\n\trewind(stream);\n\tif (fscanf(stream, \"%d\", &value) != 1)\n\t\tshutdown(4, \"Error reading /proc entry\", __LINE__ - 1);\n\treturn value;\n}\n\nstatic inline void set(FILE *stream, int value)\n{\n\tint new_value;\n\n\trewind(stream);\n\tif (fprintf(stream, \"%d\", value) < 0)\n\t\treturn shutdown(5, \"Failed writing to /proc file\",\n\t\t\t\t__LINE__ - 1);\n\tnew_value = get(stream);\n\tif (new_value != value)\n\t\treturn shutdown(5, \"We didn't get what we wrote to /proc back\",\n\t\t\t\t__LINE__ - 1);\n}\n\nstatic inline void getr(int type, struct rlimit *rlim)\n{\n\tif (getrlimit(type, rlim))\n\t\tshutdown(6, \"getrlimit()\", __LINE__ - 1);\n}\n\nstatic inline void setr(int type, struct rlimit *rlim)\n{\n\tif (setrlimit(type, rlim))\n\t\tshutdown(7, \"setrlimit()\", __LINE__ - 1);\n}\n\nvoid validate_current_settings()\n{\n\tint rlim_needed;\n\n\tif (cur_limits.rlim_cur < 4096) {\n\t\tprintf(\"Current rlimit value for POSIX message queue bytes is \"\n\t\t       \"unreasonably low,\\nincreasing.\\n\\n\");\n\t\tcur_limits.rlim_cur = 8192;\n\t\tcur_limits.rlim_max = 16384;\n\t\tsetr(RLIMIT_MSGQUEUE, &cur_limits);\n\t}\n\n\tif (default_settings) {\n\t\trlim_needed = (cur_def_msgs + 1) * (cur_def_msgsize + 1 +\n\t\t\t\t\t\t    2 * sizeof(void *));\n\t\tif (rlim_needed > cur_limits.rlim_cur) {\n\t\t\tprintf(\"Temporarily lowering default queue parameters \"\n\t\t\t       \"to something that will work\\n\"\n\t\t\t       \"with the current rlimit values.\\n\\n\");\n\t\t\tset(def_msgs, 10);\n\t\t\tcur_def_msgs = 10;\n\t\t\tset(def_msgsize, 128);\n\t\t\tcur_def_msgsize = 128;\n\t\t}\n\t} else {\n\t\trlim_needed = (cur_max_msgs + 1) * (cur_max_msgsize + 1 +\n\t\t\t\t\t\t    2 * sizeof(void *));\n\t\tif (rlim_needed > cur_limits.rlim_cur) {\n\t\t\tprintf(\"Temporarily lowering maximum queue parameters \"\n\t\t\t       \"to something that will work\\n\"\n\t\t\t       \"with the current rlimit values in case this is \"\n\t\t\t       \"a kernel that ties the default\\n\"\n\t\t\t       \"queue parameters to the maximum queue \"\n\t\t\t       \"parameters.\\n\\n\");\n\t\t\tset(max_msgs, 10);\n\t\t\tcur_max_msgs = 10;\n\t\t\tset(max_msgsize, 128);\n\t\t\tcur_max_msgsize = 128;\n\t\t}\n\t}\n}\n\n \nstatic inline void test_queue(struct mq_attr *attr, struct mq_attr *result)\n{\n\tint flags = O_RDWR | O_EXCL | O_CREAT;\n\tint perms = DEFFILEMODE;\n\n\tif ((queue = mq_open(queue_path, flags, perms, attr)) == -1)\n\t\tshutdown(1, \"mq_open()\", __LINE__);\n\tif (mq_getattr(queue, result))\n\t\tshutdown(1, \"mq_getattr()\", __LINE__);\n\tif (mq_close(queue))\n\t\tshutdown(1, \"mq_close()\", __LINE__);\n\tqueue = -1;\n\tif (mq_unlink(queue_path))\n\t\tshutdown(1, \"mq_unlink()\", __LINE__);\n}\n\n \nstatic inline int test_queue_fail(struct mq_attr *attr, struct mq_attr *result)\n{\n\tint flags = O_RDWR | O_EXCL | O_CREAT;\n\tint perms = DEFFILEMODE;\n\n\tif ((queue = mq_open(queue_path, flags, perms, attr)) == -1)\n\t\treturn 0;\n\tif (mq_getattr(queue, result))\n\t\tshutdown(1, \"mq_getattr()\", __LINE__);\n\tif (mq_close(queue))\n\t\tshutdown(1, \"mq_close()\", __LINE__);\n\tqueue = -1;\n\tif (mq_unlink(queue_path))\n\t\tshutdown(1, \"mq_unlink()\", __LINE__);\n\treturn 1;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct mq_attr attr, result;\n\n\tif (argc != 2) {\n\t\tprintf(\"Using Default queue path - %s\\n\", default_queue_path);\n\t\tqueue_path = default_queue_path;\n\t} else {\n\n\t \n\t\tif (*argv[1] == '/')\n\t\t\tqueue_path = strdup(argv[1]);\n\t\telse {\n\t\t\tqueue_path = malloc(strlen(argv[1]) + 2);\n\t\t\tif (!queue_path) {\n\t\t\t\tperror(\"malloc()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tqueue_path[0] = '/';\n\t\t\tqueue_path[1] = 0;\n\t\t\tstrcat(queue_path, argv[1]);\n\t\t}\n\t}\n\n\tif (getuid() != 0)\n\t\tksft_exit_skip(\"Not running as root, but almost all tests \"\n\t\t\t\"require root in order to modify\\nsystem settings.  \"\n\t\t\t\"Exiting.\\n\");\n\n\t \n\tdef_msgs = fopen(DEF_MSGS, \"r+\");\n\tdef_msgsize = fopen(DEF_MSGSIZE, \"r+\");\n\tmax_msgs = fopen(MAX_MSGS, \"r+\");\n\tmax_msgsize = fopen(MAX_MSGSIZE, \"r+\");\n\n\tif (!max_msgs)\n\t\tshutdown(2, \"Failed to open msg_max\", __LINE__);\n\tif (!max_msgsize)\n\t\tshutdown(2, \"Failed to open msgsize_max\", __LINE__);\n\tif (def_msgs || def_msgsize)\n\t\tdefault_settings = 1;\n\n\t \n\tgetr(RLIMIT_MSGQUEUE, &saved_limits);\n\tcur_limits = saved_limits;\n\tif (default_settings) {\n\t\tsaved_def_msgs = cur_def_msgs = get(def_msgs);\n\t\tsaved_def_msgsize = cur_def_msgsize = get(def_msgsize);\n\t}\n\tsaved_max_msgs = cur_max_msgs = get(max_msgs);\n\tsaved_max_msgsize = cur_max_msgsize = get(max_msgsize);\n\n\t \n\tprintf(\"\\nInitial system state:\\n\");\n\tprintf(\"\\tUsing queue path:\\t\\t%s\\n\", queue_path);\n\tprintf(\"\\tRLIMIT_MSGQUEUE(soft):\\t\\t%ld\\n\",\n\t\t(long) saved_limits.rlim_cur);\n\tprintf(\"\\tRLIMIT_MSGQUEUE(hard):\\t\\t%ld\\n\",\n\t\t(long) saved_limits.rlim_max);\n\tprintf(\"\\tMaximum Message Size:\\t\\t%d\\n\", saved_max_msgsize);\n\tprintf(\"\\tMaximum Queue Size:\\t\\t%d\\n\", saved_max_msgs);\n\tif (default_settings) {\n\t\tprintf(\"\\tDefault Message Size:\\t\\t%d\\n\", saved_def_msgsize);\n\t\tprintf(\"\\tDefault Queue Size:\\t\\t%d\\n\", saved_def_msgs);\n\t} else {\n\t\tprintf(\"\\tDefault Message Size:\\t\\tNot Supported\\n\");\n\t\tprintf(\"\\tDefault Queue Size:\\t\\tNot Supported\\n\");\n\t}\n\tprintf(\"\\n\");\n\n\tvalidate_current_settings();\n\n\tprintf(\"Adjusted system state for testing:\\n\");\n\tprintf(\"\\tRLIMIT_MSGQUEUE(soft):\\t\\t%ld\\n\", (long) cur_limits.rlim_cur);\n\tprintf(\"\\tRLIMIT_MSGQUEUE(hard):\\t\\t%ld\\n\", (long) cur_limits.rlim_max);\n\tprintf(\"\\tMaximum Message Size:\\t\\t%d\\n\", cur_max_msgsize);\n\tprintf(\"\\tMaximum Queue Size:\\t\\t%d\\n\", cur_max_msgs);\n\tif (default_settings) {\n\t\tprintf(\"\\tDefault Message Size:\\t\\t%d\\n\", cur_def_msgsize);\n\t\tprintf(\"\\tDefault Queue Size:\\t\\t%d\\n\", cur_def_msgs);\n\t}\n\n\tprintf(\"\\n\\nTest series 1, behavior when no attr struct \"\n\t       \"passed to mq_open:\\n\");\n\tif (!default_settings) {\n\t\ttest_queue(NULL, &result);\n\t\tprintf(\"Given sane system settings, mq_open without an attr \"\n\t\t       \"struct succeeds:\\tPASS\\n\");\n\t\tif (result.mq_maxmsg != cur_max_msgs ||\n\t\t    result.mq_msgsize != cur_max_msgsize) {\n\t\t\tprintf(\"Kernel does not support setting the default \"\n\t\t\t       \"mq attributes,\\nbut also doesn't tie the \"\n\t\t\t       \"defaults to the maximums:\\t\\t\\tPASS\\n\");\n\t\t} else {\n\t\t\tset(max_msgs, ++cur_max_msgs);\n\t\t\tset(max_msgsize, ++cur_max_msgsize);\n\t\t\ttest_queue(NULL, &result);\n\t\t\tif (result.mq_maxmsg == cur_max_msgs &&\n\t\t\t    result.mq_msgsize == cur_max_msgsize)\n\t\t\t\tprintf(\"Kernel does not support setting the \"\n\t\t\t\t       \"default mq attributes and\\n\"\n\t\t\t\t       \"also ties system wide defaults to \"\n\t\t\t\t       \"the system wide maximums:\\t\\t\"\n\t\t\t\t       \"FAIL\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"Kernel does not support setting the \"\n\t\t\t\t       \"default mq attributes,\\n\"\n\t\t\t\t       \"but also doesn't tie the defaults to \"\n\t\t\t\t       \"the maximums:\\t\\t\\tPASS\\n\");\n\t\t}\n\t} else {\n\t\tprintf(\"Kernel supports setting defaults separately from \"\n\t\t       \"maximums:\\t\\tPASS\\n\");\n\t\t \n\t\ttest_queue(NULL, &result);\n\t\tprintf(\"Given sane values, mq_open without an attr struct \"\n\t\t       \"succeeds:\\t\\tPASS\\n\");\n\t\tif (result.mq_maxmsg != cur_def_msgs ||\n\t\t    result.mq_msgsize != cur_def_msgsize)\n\t\t\tprintf(\"Kernel supports setting defaults, but does \"\n\t\t\t       \"not actually honor them:\\tFAIL\\n\\n\");\n\t\telse {\n\t\t\tset(def_msgs, ++cur_def_msgs);\n\t\t\tset(def_msgsize, ++cur_def_msgsize);\n\t\t\t \n\t\t\tset(max_msgs, ++cur_max_msgs);\n\t\t\tset(max_msgsize, ++cur_max_msgsize);\n\t\t\ttest_queue(NULL, &result);\n\t\t\tif (result.mq_maxmsg != cur_def_msgs ||\n\t\t\t    result.mq_msgsize != cur_def_msgsize)\n\t\t\t\tprintf(\"Kernel supports setting defaults, but \"\n\t\t\t\t       \"does not actually honor them:\\t\"\n\t\t\t\t       \"FAIL\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"Kernel properly honors default setting \"\n\t\t\t\t       \"knobs:\\t\\t\\t\\tPASS\\n\");\n\t\t}\n\t\tset(def_msgs, cur_max_msgs + 1);\n\t\tcur_def_msgs = cur_max_msgs + 1;\n\t\tset(def_msgsize, cur_max_msgsize + 1);\n\t\tcur_def_msgsize = cur_max_msgsize + 1;\n\t\tif (cur_def_msgs * (cur_def_msgsize + 2 * sizeof(void *)) >=\n\t\t    cur_limits.rlim_cur) {\n\t\t\tcur_limits.rlim_cur = (cur_def_msgs + 2) *\n\t\t\t\t(cur_def_msgsize + 2 * sizeof(void *));\n\t\t\tcur_limits.rlim_max = 2 * cur_limits.rlim_cur;\n\t\t\tsetr(RLIMIT_MSGQUEUE, &cur_limits);\n\t\t}\n\t\tif (test_queue_fail(NULL, &result)) {\n\t\t\tif (result.mq_maxmsg == cur_max_msgs &&\n\t\t\t    result.mq_msgsize == cur_max_msgsize)\n\t\t\t\tprintf(\"Kernel properly limits default values \"\n\t\t\t\t       \"to lesser of default/max:\\t\\tPASS\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"Kernel does not properly set default \"\n\t\t\t\t       \"queue parameters when\\ndefaults > \"\n\t\t\t\t       \"max:\\t\\t\\t\\t\\t\\t\\t\\tFAIL\\n\");\n\t\t} else\n\t\t\tprintf(\"Kernel fails to open mq because defaults are \"\n\t\t\t       \"greater than maximums:\\tFAIL\\n\");\n\t\tset(def_msgs, --cur_def_msgs);\n\t\tset(def_msgsize, --cur_def_msgsize);\n\t\tcur_limits.rlim_cur = cur_limits.rlim_max = cur_def_msgs *\n\t\t\tcur_def_msgsize;\n\t\tsetr(RLIMIT_MSGQUEUE, &cur_limits);\n\t\tif (test_queue_fail(NULL, &result))\n\t\t\tprintf(\"Kernel creates queue even though defaults \"\n\t\t\t       \"would exceed\\nrlimit setting:\"\n\t\t\t       \"\\t\\t\\t\\t\\t\\t\\t\\tFAIL\\n\");\n\t\telse\n\t\t\tprintf(\"Kernel properly fails to create queue when \"\n\t\t\t       \"defaults would\\nexceed rlimit:\"\n\t\t\t       \"\\t\\t\\t\\t\\t\\t\\t\\tPASS\\n\");\n\t}\n\n\t \n\tprintf(\"\\n\\nTest series 2, behavior when attr struct is \"\n\t       \"passed to mq_open:\\n\");\n\tcur_max_msgs = 32;\n\tcur_max_msgsize = cur_limits.rlim_max >> 4;\n\tset(max_msgs, cur_max_msgs);\n\tset(max_msgsize, cur_max_msgsize);\n\tattr.mq_maxmsg = cur_max_msgs;\n\tattr.mq_msgsize = cur_max_msgsize;\n\tif (test_queue_fail(&attr, &result))\n\t\tprintf(\"Queue open in excess of rlimit max when euid = 0 \"\n\t\t       \"succeeded:\\t\\tFAIL\\n\");\n\telse\n\t\tprintf(\"Queue open in excess of rlimit max when euid = 0 \"\n\t\t       \"failed:\\t\\tPASS\\n\");\n\tattr.mq_maxmsg = cur_max_msgs + 1;\n\tattr.mq_msgsize = 10;\n\tif (test_queue_fail(&attr, &result))\n\t\tprintf(\"Queue open with mq_maxmsg > limit when euid = 0 \"\n\t\t       \"succeeded:\\t\\tPASS\\n\");\n\telse\n\t\tprintf(\"Queue open with mq_maxmsg > limit when euid = 0 \"\n\t\t       \"failed:\\t\\tFAIL\\n\");\n\tattr.mq_maxmsg = 1;\n\tattr.mq_msgsize = cur_max_msgsize + 1;\n\tif (test_queue_fail(&attr, &result))\n\t\tprintf(\"Queue open with mq_msgsize > limit when euid = 0 \"\n\t\t       \"succeeded:\\t\\tPASS\\n\");\n\telse\n\t\tprintf(\"Queue open with mq_msgsize > limit when euid = 0 \"\n\t\t       \"failed:\\t\\tFAIL\\n\");\n\tattr.mq_maxmsg = 65536;\n\tattr.mq_msgsize = 65536;\n\tif (test_queue_fail(&attr, &result))\n\t\tprintf(\"Queue open with total size > 2GB when euid = 0 \"\n\t\t       \"succeeded:\\t\\tFAIL\\n\");\n\telse\n\t\tprintf(\"Queue open with total size > 2GB when euid = 0 \"\n\t\t       \"failed:\\t\\t\\tPASS\\n\");\n\n\tif (seteuid(99) == -1) {\n\t\tperror(\"seteuid() failed\");\n\t\texit(1);\n\t}\n\n\tattr.mq_maxmsg = cur_max_msgs;\n\tattr.mq_msgsize = cur_max_msgsize;\n\tif (test_queue_fail(&attr, &result))\n\t\tprintf(\"Queue open in excess of rlimit max when euid = 99 \"\n\t\t       \"succeeded:\\t\\tFAIL\\n\");\n\telse\n\t\tprintf(\"Queue open in excess of rlimit max when euid = 99 \"\n\t\t       \"failed:\\t\\tPASS\\n\");\n\tattr.mq_maxmsg = cur_max_msgs + 1;\n\tattr.mq_msgsize = 10;\n\tif (test_queue_fail(&attr, &result))\n\t\tprintf(\"Queue open with mq_maxmsg > limit when euid = 99 \"\n\t\t       \"succeeded:\\t\\tFAIL\\n\");\n\telse\n\t\tprintf(\"Queue open with mq_maxmsg > limit when euid = 99 \"\n\t\t       \"failed:\\t\\tPASS\\n\");\n\tattr.mq_maxmsg = 1;\n\tattr.mq_msgsize = cur_max_msgsize + 1;\n\tif (test_queue_fail(&attr, &result))\n\t\tprintf(\"Queue open with mq_msgsize > limit when euid = 99 \"\n\t\t       \"succeeded:\\t\\tFAIL\\n\");\n\telse\n\t\tprintf(\"Queue open with mq_msgsize > limit when euid = 99 \"\n\t\t       \"failed:\\t\\tPASS\\n\");\n\tattr.mq_maxmsg = 65536;\n\tattr.mq_msgsize = 65536;\n\tif (test_queue_fail(&attr, &result))\n\t\tprintf(\"Queue open with total size > 2GB when euid = 99 \"\n\t\t       \"succeeded:\\t\\tFAIL\\n\");\n\telse\n\t\tprintf(\"Queue open with total size > 2GB when euid = 99 \"\n\t\t       \"failed:\\t\\t\\tPASS\\n\");\n\n\tshutdown(0,\"\",0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}