{
  "module_name": "mq_perf_tests.c",
  "hash_id": "47c447b1b9ab66534409c422cf225ae320f3d1a82d4c4836ed0d49d7703dcd31",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mqueue/mq_perf_tests.c",
  "human_readable_source": " \n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include <signal.h>\n#include <pthread.h>\n#include <sched.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <mqueue.h>\n#include <popt.h>\n#include <error.h>\n\n#include \"../kselftest.h\"\n\nstatic char *usage =\n\"Usage:\\n\"\n\"  %s [-c #[,#..] -f] path\\n\"\n\"\\n\"\n\"\t-c #\tSkip most tests and go straight to a high queue depth test\\n\"\n\"\t\tand then run that test continuously (useful for running at\\n\"\n\"\t\tthe same time as some other workload to see how much the\\n\"\n\"\t\tcache thrashing caused by adding messages to a very deep\\n\"\n\"\t\tqueue impacts the performance of other programs).  The number\\n\"\n\"\t\tindicates which CPU core we should bind the process to during\\n\"\n\"\t\tthe run.  If you have more than one physical CPU, then you\\n\"\n\"\t\twill need one copy per physical CPU package, and you should\\n\"\n\"\t\tspecify the CPU cores to pin ourself to via a comma separated\\n\"\n\"\t\tlist of CPU values.\\n\"\n\"\t-f\tOnly usable with continuous mode.  Pin ourself to the CPUs\\n\"\n\"\t\tas requested, then instead of looping doing a high mq\\n\"\n\"\t\tworkload, just busy loop.  This will allow us to lock up a\\n\"\n\"\t\tsingle CPU just like we normally would, but without actually\\n\"\n\"\t\tthrashing the CPU cache.  This is to make it easier to get\\n\"\n\"\t\tcomparable numbers from some other workload running on the\\n\"\n\"\t\tother CPUs.  One set of numbers with # CPUs locked up running\\n\"\n\"\t\tan mq workload, and another set of numbers with those same\\n\"\n\"\t\tCPUs locked away from the test workload, but not doing\\n\"\n\"\t\tanything to trash the cache like the mq workload might.\\n\"\n\"\tpath\tPath name of the message queue to create\\n\"\n\"\\n\"\n\"\tNote: this program must be run as root in order to enable all tests\\n\"\n\"\\n\";\n\nchar *MAX_MSGS = \"/proc/sys/fs/mqueue/msg_max\";\nchar *MAX_MSGSIZE = \"/proc/sys/fs/mqueue/msgsize_max\";\n\n#define MAX_CPUS 64\nchar *cpu_option_string;\nint cpus_to_pin[MAX_CPUS];\nint num_cpus_to_pin;\npthread_t cpu_threads[MAX_CPUS];\npthread_t main_thread;\ncpu_set_t *cpu_set;\nint cpu_set_size;\nint cpus_online;\n\n#define MSG_SIZE 16\n#define TEST1_LOOPS 10000000\n#define TEST2_LOOPS 100000\nint continuous_mode;\nint continuous_mode_fake;\n\nstruct rlimit saved_limits, cur_limits;\nint saved_max_msgs, saved_max_msgsize;\nint cur_max_msgs, cur_max_msgsize;\nFILE *max_msgs, *max_msgsize;\nint cur_nice;\nchar *queue_path = \"/mq_perf_tests\";\nmqd_t queue = -1;\nstruct mq_attr result;\nint mq_prio_max;\n\nconst struct poptOption options[] = {\n\t{\n\t\t.longName = \"continuous\",\n\t\t.shortName = 'c',\n\t\t.argInfo = POPT_ARG_STRING,\n\t\t.arg = &cpu_option_string,\n\t\t.val = 'c',\n\t\t.descrip = \"Run continuous tests at a high queue depth in \"\n\t\t\t\"order to test the effects of cache thrashing on \"\n\t\t\t\"other tasks on the system.  This test is intended \"\n\t\t\t\"to be run on one core of each physical CPU while \"\n\t\t\t\"some other CPU intensive task is run on all the other \"\n\t\t\t\"cores of that same physical CPU and the other task \"\n\t\t\t\"is timed.  It is assumed that the process of adding \"\n\t\t\t\"messages to the message queue in a tight loop will \"\n\t\t\t\"impact that other task to some degree.  Once the \"\n\t\t\t\"tests are performed in this way, you should then \"\n\t\t\t\"re-run the tests using fake mode in order to check \"\n\t\t\t\"the difference in time required to perform the CPU \"\n\t\t\t\"intensive task\",\n\t\t.argDescrip = \"cpu[,cpu]\",\n\t},\n\t{\n\t\t.longName = \"fake\",\n\t\t.shortName = 'f',\n\t\t.argInfo = POPT_ARG_NONE,\n\t\t.arg = &continuous_mode_fake,\n\t\t.val = 0,\n\t\t.descrip = \"Tie up the CPUs that we would normally tie up in\"\n\t\t\t\"continuous mode, but don't actually do any mq stuff, \"\n\t\t\t\"just keep the CPU busy so it can't be used to process \"\n\t\t\t\"system level tasks as this would free up resources on \"\n\t\t\t\"the other CPU cores and skew the comparison between \"\n\t\t\t\"the no-mqueue work and mqueue work tests\",\n\t\t.argDescrip = NULL,\n\t},\n\t{\n\t\t.longName = \"path\",\n\t\t.shortName = 'p',\n\t\t.argInfo = POPT_ARG_STRING | POPT_ARGFLAG_SHOW_DEFAULT,\n\t\t.arg = &queue_path,\n\t\t.val = 'p',\n\t\t.descrip = \"The name of the path to use in the mqueue \"\n\t\t\t\"filesystem for our tests\",\n\t\t.argDescrip = \"pathname\",\n\t},\n\tPOPT_AUTOHELP\n\tPOPT_TABLEEND\n};\n\nstatic inline void __set(FILE *stream, int value, char *err_msg);\nvoid shutdown(int exit_val, char *err_cause, int line_no);\nvoid sig_action_SIGUSR1(int signum, siginfo_t *info, void *context);\nvoid sig_action(int signum, siginfo_t *info, void *context);\nstatic inline int get(FILE *stream);\nstatic inline void set(FILE *stream, int value);\nstatic inline int try_set(FILE *stream, int value);\nstatic inline void getr(int type, struct rlimit *rlim);\nstatic inline void setr(int type, struct rlimit *rlim);\nstatic inline void open_queue(struct mq_attr *attr);\nvoid increase_limits(void);\n\nstatic inline void __set(FILE *stream, int value, char *err_msg)\n{\n\trewind(stream);\n\tif (fprintf(stream, \"%d\", value) < 0)\n\t\tperror(err_msg);\n}\n\n\nvoid shutdown(int exit_val, char *err_cause, int line_no)\n{\n\tstatic int in_shutdown = 0;\n\tint errno_at_shutdown = errno;\n\tint i;\n\n\t \n\tif (in_shutdown++)\n\t\treturn;\n\n\t \n\tCPU_FREE(cpu_set);\n\n\tfor (i = 0; i < num_cpus_to_pin; i++)\n\t\tif (cpu_threads[i]) {\n\t\t\tpthread_kill(cpu_threads[i], SIGUSR1);\n\t\t\tpthread_join(cpu_threads[i], NULL);\n\t\t}\n\n\tif (queue != -1)\n\t\tif (mq_close(queue))\n\t\t\tperror(\"mq_close() during shutdown\");\n\tif (queue_path)\n\t\t \n\t\tmq_unlink(queue_path);\n\tif (saved_max_msgs)\n\t\t__set(max_msgs, saved_max_msgs,\n\t\t      \"failed to restore saved_max_msgs\");\n\tif (saved_max_msgsize)\n\t\t__set(max_msgsize, saved_max_msgsize,\n\t\t      \"failed to restore saved_max_msgsize\");\n\tif (exit_val)\n\t\terror(exit_val, errno_at_shutdown, \"%s at %d\",\n\t\t      err_cause, line_no);\n\texit(0);\n}\n\nvoid sig_action_SIGUSR1(int signum, siginfo_t *info, void *context)\n{\n\tif (pthread_self() != main_thread)\n\t\tpthread_exit(0);\n\telse {\n\t\tfprintf(stderr, \"Caught signal %d in SIGUSR1 handler, \"\n\t\t\t\t\"exiting\\n\", signum);\n\t\tshutdown(0, \"\", 0);\n\t\tfprintf(stderr, \"\\n\\nReturned from shutdown?!?!\\n\\n\");\n\t\texit(0);\n\t}\n}\n\nvoid sig_action(int signum, siginfo_t *info, void *context)\n{\n\tif (pthread_self() != main_thread)\n\t\tpthread_kill(main_thread, signum);\n\telse {\n\t\tfprintf(stderr, \"Caught signal %d, exiting\\n\", signum);\n\t\tshutdown(0, \"\", 0);\n\t\tfprintf(stderr, \"\\n\\nReturned from shutdown?!?!\\n\\n\");\n\t\texit(0);\n\t}\n}\n\nstatic inline int get(FILE *stream)\n{\n\tint value;\n\trewind(stream);\n\tif (fscanf(stream, \"%d\", &value) != 1)\n\t\tshutdown(4, \"Error reading /proc entry\", __LINE__);\n\treturn value;\n}\n\nstatic inline void set(FILE *stream, int value)\n{\n\tint new_value;\n\n\trewind(stream);\n\tif (fprintf(stream, \"%d\", value) < 0)\n\t\treturn shutdown(5, \"Failed writing to /proc file\", __LINE__);\n\tnew_value = get(stream);\n\tif (new_value != value)\n\t\treturn shutdown(5, \"We didn't get what we wrote to /proc back\",\n\t\t\t\t__LINE__);\n}\n\nstatic inline int try_set(FILE *stream, int value)\n{\n\tint new_value;\n\n\trewind(stream);\n\tfprintf(stream, \"%d\", value);\n\tnew_value = get(stream);\n\treturn new_value == value;\n}\n\nstatic inline void getr(int type, struct rlimit *rlim)\n{\n\tif (getrlimit(type, rlim))\n\t\tshutdown(6, \"getrlimit()\", __LINE__);\n}\n\nstatic inline void setr(int type, struct rlimit *rlim)\n{\n\tif (setrlimit(type, rlim))\n\t\tshutdown(7, \"setrlimit()\", __LINE__);\n}\n\n \nstatic inline void open_queue(struct mq_attr *attr)\n{\n\tint flags = O_RDWR | O_EXCL | O_CREAT | O_NONBLOCK;\n\tint perms = DEFFILEMODE;\n\n\tqueue = mq_open(queue_path, flags, perms, attr);\n\tif (queue == -1)\n\t\tshutdown(1, \"mq_open()\", __LINE__);\n\tif (mq_getattr(queue, &result))\n\t\tshutdown(1, \"mq_getattr()\", __LINE__);\n\tprintf(\"\\n\\tQueue %s created:\\n\", queue_path);\n\tprintf(\"\\t\\tmq_flags:\\t\\t\\t%s\\n\", result.mq_flags & O_NONBLOCK ?\n\t       \"O_NONBLOCK\" : \"(null)\");\n\tprintf(\"\\t\\tmq_maxmsg:\\t\\t\\t%lu\\n\", result.mq_maxmsg);\n\tprintf(\"\\t\\tmq_msgsize:\\t\\t\\t%lu\\n\", result.mq_msgsize);\n\tprintf(\"\\t\\tmq_curmsgs:\\t\\t\\t%lu\\n\", result.mq_curmsgs);\n}\n\nvoid *fake_cont_thread(void *arg)\n{\n\tint i;\n\n\tfor (i = 0; i < num_cpus_to_pin; i++)\n\t\tif (cpu_threads[i] == pthread_self())\n\t\t\tbreak;\n\tprintf(\"\\tStarted fake continuous mode thread %d on CPU %d\\n\", i,\n\t       cpus_to_pin[i]);\n\twhile (1)\n\t\t;\n}\n\nvoid *cont_thread(void *arg)\n{\n\tchar buff[MSG_SIZE];\n\tint i, priority;\n\n\tfor (i = 0; i < num_cpus_to_pin; i++)\n\t\tif (cpu_threads[i] == pthread_self())\n\t\t\tbreak;\n\tprintf(\"\\tStarted continuous mode thread %d on CPU %d\\n\", i,\n\t       cpus_to_pin[i]);\n\twhile (1) {\n\t\twhile (mq_send(queue, buff, sizeof(buff), 0) == 0)\n\t\t\t;\n\t\tmq_receive(queue, buff, sizeof(buff), &priority);\n\t}\n}\n\n#define drain_queue() \\\n\twhile (mq_receive(queue, buff, MSG_SIZE, &prio_in) == MSG_SIZE)\n\n#define do_untimed_send() \\\n\tdo { \\\n\t\tif (mq_send(queue, buff, MSG_SIZE, prio_out)) \\\n\t\t\tshutdown(3, \"Test send failure\", __LINE__); \\\n\t} while (0)\n\n#define do_send_recv() \\\n\tdo { \\\n\t\tclock_gettime(clock, &start); \\\n\t\tif (mq_send(queue, buff, MSG_SIZE, prio_out)) \\\n\t\t\tshutdown(3, \"Test send failure\", __LINE__); \\\n\t\tclock_gettime(clock, &middle); \\\n\t\tif (mq_receive(queue, buff, MSG_SIZE, &prio_in) != MSG_SIZE) \\\n\t\t\tshutdown(3, \"Test receive failure\", __LINE__); \\\n\t\tclock_gettime(clock, &end); \\\n\t\tnsec = ((middle.tv_sec - start.tv_sec) * 1000000000) + \\\n\t\t\t(middle.tv_nsec - start.tv_nsec); \\\n\t\tsend_total.tv_nsec += nsec; \\\n\t\tif (send_total.tv_nsec >= 1000000000) { \\\n\t\t\tsend_total.tv_sec++; \\\n\t\t\tsend_total.tv_nsec -= 1000000000; \\\n\t\t} \\\n\t\tnsec = ((end.tv_sec - middle.tv_sec) * 1000000000) + \\\n\t\t\t(end.tv_nsec - middle.tv_nsec); \\\n\t\trecv_total.tv_nsec += nsec; \\\n\t\tif (recv_total.tv_nsec >= 1000000000) { \\\n\t\t\trecv_total.tv_sec++; \\\n\t\t\trecv_total.tv_nsec -= 1000000000; \\\n\t\t} \\\n\t} while (0)\n\nstruct test {\n\tchar *desc;\n\tvoid (*func)(int *);\n};\n\nvoid const_prio(int *prio)\n{\n\treturn;\n}\n\nvoid inc_prio(int *prio)\n{\n\tif (++*prio == mq_prio_max)\n\t\t*prio = 0;\n}\n\nvoid dec_prio(int *prio)\n{\n\tif (--*prio < 0)\n\t\t*prio = mq_prio_max - 1;\n}\n\nvoid random_prio(int *prio)\n{\n\t*prio = random() % mq_prio_max;\n}\n\nstruct test test2[] = {\n\t{\"\\n\\tTest #2a: Time send/recv message, queue full, constant prio\\n\",\n\t\tconst_prio},\n\t{\"\\n\\tTest #2b: Time send/recv message, queue full, increasing prio\\n\",\n\t\tinc_prio},\n\t{\"\\n\\tTest #2c: Time send/recv message, queue full, decreasing prio\\n\",\n\t\tdec_prio},\n\t{\"\\n\\tTest #2d: Time send/recv message, queue full, random prio\\n\",\n\t\trandom_prio},\n\t{NULL, NULL}\n};\n\n \nvoid *perf_test_thread(void *arg)\n{\n\tchar buff[MSG_SIZE];\n\tint prio_out, prio_in;\n\tint i;\n\tclockid_t clock;\n\tpthread_t *t;\n\tstruct timespec res, start, middle, end, send_total, recv_total;\n\tunsigned long long nsec;\n\tstruct test *cur_test;\n\n\tt = &cpu_threads[0];\n\tprintf(\"\\n\\tStarted mqueue performance test thread on CPU %d\\n\",\n\t       cpus_to_pin[0]);\n\tmq_prio_max = sysconf(_SC_MQ_PRIO_MAX);\n\tif (mq_prio_max == -1)\n\t\tshutdown(2, \"sysconf(_SC_MQ_PRIO_MAX)\", __LINE__);\n\tif (pthread_getcpuclockid(cpu_threads[0], &clock) != 0)\n\t\tshutdown(2, \"pthread_getcpuclockid\", __LINE__);\n\n\tif (clock_getres(clock, &res))\n\t\tshutdown(2, \"clock_getres()\", __LINE__);\n\n\tprintf(\"\\t\\tMax priorities:\\t\\t\\t%d\\n\", mq_prio_max);\n\tprintf(\"\\t\\tClock resolution:\\t\\t%lu nsec%s\\n\", res.tv_nsec,\n\t       res.tv_nsec > 1 ? \"s\" : \"\");\n\n\n\n\tprintf(\"\\n\\tTest #1: Time send/recv message, queue empty\\n\");\n\tprintf(\"\\t\\t(%d iterations)\\n\", TEST1_LOOPS);\n\tprio_out = 0;\n\tsend_total.tv_sec = 0;\n\tsend_total.tv_nsec = 0;\n\trecv_total.tv_sec = 0;\n\trecv_total.tv_nsec = 0;\n\tfor (i = 0; i < TEST1_LOOPS; i++)\n\t\tdo_send_recv();\n\tprintf(\"\\t\\tSend msg:\\t\\t\\t%ld.%lus total time\\n\",\n\t       send_total.tv_sec, send_total.tv_nsec);\n\tnsec = ((unsigned long long)send_total.tv_sec * 1000000000 +\n\t\t send_total.tv_nsec) / TEST1_LOOPS;\n\tprintf(\"\\t\\t\\t\\t\\t\\t%lld nsec/msg\\n\", nsec);\n\tprintf(\"\\t\\tRecv msg:\\t\\t\\t%ld.%lus total time\\n\",\n\t       recv_total.tv_sec, recv_total.tv_nsec);\n\tnsec = ((unsigned long long)recv_total.tv_sec * 1000000000 +\n\t\trecv_total.tv_nsec) / TEST1_LOOPS;\n\tprintf(\"\\t\\t\\t\\t\\t\\t%lld nsec/msg\\n\", nsec);\n\n\n\tfor (cur_test = test2; cur_test->desc != NULL; cur_test++) {\n\t\tprintf(\"%s:\\n\", cur_test->desc);\n\t\tprintf(\"\\t\\t(%d iterations)\\n\", TEST2_LOOPS);\n\t\tprio_out = 0;\n\t\tsend_total.tv_sec = 0;\n\t\tsend_total.tv_nsec = 0;\n\t\trecv_total.tv_sec = 0;\n\t\trecv_total.tv_nsec = 0;\n\t\tprintf(\"\\t\\tFilling queue...\");\n\t\tfflush(stdout);\n\t\tclock_gettime(clock, &start);\n\t\tfor (i = 0; i < result.mq_maxmsg - 1; i++) {\n\t\t\tdo_untimed_send();\n\t\t\tcur_test->func(&prio_out);\n\t\t}\n\t\tclock_gettime(clock, &end);\n\t\tnsec = ((unsigned long long)(end.tv_sec - start.tv_sec) *\n\t\t\t1000000000) + (end.tv_nsec - start.tv_nsec);\n\t\tprintf(\"done.\\t\\t%lld.%llds\\n\", nsec / 1000000000,\n\t\t       nsec % 1000000000);\n\t\tprintf(\"\\t\\tTesting...\");\n\t\tfflush(stdout);\n\t\tfor (i = 0; i < TEST2_LOOPS; i++) {\n\t\t\tdo_send_recv();\n\t\t\tcur_test->func(&prio_out);\n\t\t}\n\t\tprintf(\"done.\\n\");\n\t\tprintf(\"\\t\\tSend msg:\\t\\t\\t%ld.%lus total time\\n\",\n\t\t       send_total.tv_sec, send_total.tv_nsec);\n\t\tnsec = ((unsigned long long)send_total.tv_sec * 1000000000 +\n\t\t\t send_total.tv_nsec) / TEST2_LOOPS;\n\t\tprintf(\"\\t\\t\\t\\t\\t\\t%lld nsec/msg\\n\", nsec);\n\t\tprintf(\"\\t\\tRecv msg:\\t\\t\\t%ld.%lus total time\\n\",\n\t\t       recv_total.tv_sec, recv_total.tv_nsec);\n\t\tnsec = ((unsigned long long)recv_total.tv_sec * 1000000000 +\n\t\t\trecv_total.tv_nsec) / TEST2_LOOPS;\n\t\tprintf(\"\\t\\t\\t\\t\\t\\t%lld nsec/msg\\n\", nsec);\n\t\tprintf(\"\\t\\tDraining queue...\");\n\t\tfflush(stdout);\n\t\tclock_gettime(clock, &start);\n\t\tdrain_queue();\n\t\tclock_gettime(clock, &end);\n\t\tnsec = ((unsigned long long)(end.tv_sec - start.tv_sec) *\n\t\t\t1000000000) + (end.tv_nsec - start.tv_nsec);\n\t\tprintf(\"done.\\t\\t%lld.%llds\\n\", nsec / 1000000000,\n\t\t       nsec % 1000000000);\n\t}\n\treturn 0;\n}\n\nvoid increase_limits(void)\n{\n\tcur_limits.rlim_cur = RLIM_INFINITY;\n\tcur_limits.rlim_max = RLIM_INFINITY;\n\tsetr(RLIMIT_MSGQUEUE, &cur_limits);\n\twhile (try_set(max_msgs, cur_max_msgs += 10))\n\t\t;\n\tcur_max_msgs = get(max_msgs);\n\twhile (try_set(max_msgsize, cur_max_msgsize += 1024))\n\t\t;\n\tcur_max_msgsize = get(max_msgsize);\n\tif (setpriority(PRIO_PROCESS, 0, -20) != 0)\n\t\tshutdown(2, \"setpriority()\", __LINE__);\n\tcur_nice = -20;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct mq_attr attr;\n\tchar *option, *next_option;\n\tint i, cpu, rc;\n\tstruct sigaction sa;\n\tpoptContext popt_context;\n\tvoid *retval;\n\n\tmain_thread = pthread_self();\n\tnum_cpus_to_pin = 0;\n\n\tif (sysconf(_SC_NPROCESSORS_ONLN) == -1) {\n\t\tperror(\"sysconf(_SC_NPROCESSORS_ONLN)\");\n\t\texit(1);\n\t}\n\n\tif (getuid() != 0)\n\t\tksft_exit_skip(\"Not running as root, but almost all tests \"\n\t\t\t\"require root in order to modify\\nsystem settings.  \"\n\t\t\t\"Exiting.\\n\");\n\n\tcpus_online = MIN(MAX_CPUS, sysconf(_SC_NPROCESSORS_ONLN));\n\tcpu_set = CPU_ALLOC(cpus_online);\n\tif (cpu_set == NULL) {\n\t\tperror(\"CPU_ALLOC()\");\n\t\texit(1);\n\t}\n\tcpu_set_size = CPU_ALLOC_SIZE(cpus_online);\n\tCPU_ZERO_S(cpu_set_size, cpu_set);\n\n\tpopt_context = poptGetContext(NULL, argc, (const char **)argv,\n\t\t\t\t      options, 0);\n\n\twhile ((rc = poptGetNextOpt(popt_context)) > 0) {\n\t\tswitch (rc) {\n\t\tcase 'c':\n\t\t\tcontinuous_mode = 1;\n\t\t\toption = cpu_option_string;\n\t\t\tdo {\n\t\t\t\tnext_option = strchr(option, ',');\n\t\t\t\tif (next_option)\n\t\t\t\t\t*next_option = '\\0';\n\t\t\t\tcpu = atoi(option);\n\t\t\t\tif (cpu >= cpus_online)\n\t\t\t\t\tfprintf(stderr, \"CPU %d exceeds \"\n\t\t\t\t\t\t\"cpus online, ignoring.\\n\",\n\t\t\t\t\t\tcpu);\n\t\t\t\telse\n\t\t\t\t\tcpus_to_pin[num_cpus_to_pin++] = cpu;\n\t\t\t\tif (next_option)\n\t\t\t\t\toption = ++next_option;\n\t\t\t} while (next_option && num_cpus_to_pin < MAX_CPUS);\n\t\t\t \n\t\t\tfor (cpu = 0; cpu < num_cpus_to_pin; cpu++) {\n\t\t\t\tif (CPU_ISSET_S(cpus_to_pin[cpu], cpu_set_size,\n\t\t\t\t\t\tcpu_set)) {\n\t\t\t\t\tfprintf(stderr, \"Any given CPU may \"\n\t\t\t\t\t\t\"only be given once.\\n\");\n\t\t\t\t\tgoto err_code;\n\t\t\t\t} else\n\t\t\t\t\tCPU_SET_S(cpus_to_pin[cpu],\n\t\t\t\t\t\t  cpu_set_size, cpu_set);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\t \n\t\t\toption = queue_path;\n\t\t\tif (*option != '/') {\n\t\t\t\tqueue_path = malloc(strlen(option) + 2);\n\t\t\t\tif (!queue_path) {\n\t\t\t\t\tperror(\"malloc()\");\n\t\t\t\t\tgoto err_code;\n\t\t\t\t}\n\t\t\t\tqueue_path[0] = '/';\n\t\t\t\tqueue_path[1] = 0;\n\t\t\t\tstrcat(queue_path, option);\n\t\t\t\tfree(option);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (continuous_mode && num_cpus_to_pin == 0) {\n\t\tfprintf(stderr, \"Must pass at least one CPU to continuous \"\n\t\t\t\"mode.\\n\");\n\t\tpoptPrintUsage(popt_context, stderr, 0);\n\t\tgoto err_code;\n\t} else if (!continuous_mode) {\n\t\tnum_cpus_to_pin = 1;\n\t\tcpus_to_pin[0] = cpus_online - 1;\n\t}\n\n\tmax_msgs = fopen(MAX_MSGS, \"r+\");\n\tmax_msgsize = fopen(MAX_MSGSIZE, \"r+\");\n\tif (!max_msgs)\n\t\tshutdown(2, \"Failed to open msg_max\", __LINE__);\n\tif (!max_msgsize)\n\t\tshutdown(2, \"Failed to open msgsize_max\", __LINE__);\n\n\t \n\tgetr(RLIMIT_MSGQUEUE, &saved_limits);\n\tcur_limits = saved_limits;\n\tsaved_max_msgs = cur_max_msgs = get(max_msgs);\n\tsaved_max_msgsize = cur_max_msgsize = get(max_msgsize);\n\terrno = 0;\n\tcur_nice = getpriority(PRIO_PROCESS, 0);\n\tif (errno)\n\t\tshutdown(2, \"getpriority()\", __LINE__);\n\n\t \n\tprintf(\"\\nInitial system state:\\n\");\n\tprintf(\"\\tUsing queue path:\\t\\t\\t%s\\n\", queue_path);\n\tprintf(\"\\tRLIMIT_MSGQUEUE(soft):\\t\\t\\t%ld\\n\",\n\t\t(long) saved_limits.rlim_cur);\n\tprintf(\"\\tRLIMIT_MSGQUEUE(hard):\\t\\t\\t%ld\\n\",\n\t\t(long) saved_limits.rlim_max);\n\tprintf(\"\\tMaximum Message Size:\\t\\t\\t%d\\n\", saved_max_msgsize);\n\tprintf(\"\\tMaximum Queue Size:\\t\\t\\t%d\\n\", saved_max_msgs);\n\tprintf(\"\\tNice value:\\t\\t\\t\\t%d\\n\", cur_nice);\n\tprintf(\"\\n\");\n\n\tincrease_limits();\n\n\tprintf(\"Adjusted system state for testing:\\n\");\n\tif (cur_limits.rlim_cur == RLIM_INFINITY) {\n\t\tprintf(\"\\tRLIMIT_MSGQUEUE(soft):\\t\\t\\t(unlimited)\\n\");\n\t\tprintf(\"\\tRLIMIT_MSGQUEUE(hard):\\t\\t\\t(unlimited)\\n\");\n\t} else {\n\t\tprintf(\"\\tRLIMIT_MSGQUEUE(soft):\\t\\t\\t%ld\\n\",\n\t\t       (long) cur_limits.rlim_cur);\n\t\tprintf(\"\\tRLIMIT_MSGQUEUE(hard):\\t\\t\\t%ld\\n\",\n\t\t       (long) cur_limits.rlim_max);\n\t}\n\tprintf(\"\\tMaximum Message Size:\\t\\t\\t%d\\n\", cur_max_msgsize);\n\tprintf(\"\\tMaximum Queue Size:\\t\\t\\t%d\\n\", cur_max_msgs);\n\tprintf(\"\\tNice value:\\t\\t\\t\\t%d\\n\", cur_nice);\n\tprintf(\"\\tContinuous mode:\\t\\t\\t(%s)\\n\", continuous_mode ?\n\t       (continuous_mode_fake ? \"fake mode\" : \"enabled\") :\n\t       \"disabled\");\n\tprintf(\"\\tCPUs to pin:\\t\\t\\t\\t%d\", cpus_to_pin[0]);\n\tfor (cpu = 1; cpu < num_cpus_to_pin; cpu++)\n\t\t\tprintf(\",%d\", cpus_to_pin[cpu]);\n\tprintf(\"\\n\");\n\n\tsa.sa_sigaction = sig_action_SIGUSR1;\n\tsigemptyset(&sa.sa_mask);\n\tsigaddset(&sa.sa_mask, SIGHUP);\n\tsigaddset(&sa.sa_mask, SIGINT);\n\tsigaddset(&sa.sa_mask, SIGQUIT);\n\tsigaddset(&sa.sa_mask, SIGTERM);\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGUSR1, &sa, NULL) == -1)\n\t\tshutdown(1, \"sigaction(SIGUSR1)\", __LINE__);\n\tsa.sa_sigaction = sig_action;\n\tif (sigaction(SIGHUP, &sa, NULL) == -1)\n\t\tshutdown(1, \"sigaction(SIGHUP)\", __LINE__);\n\tif (sigaction(SIGINT, &sa, NULL) == -1)\n\t\tshutdown(1, \"sigaction(SIGINT)\", __LINE__);\n\tif (sigaction(SIGQUIT, &sa, NULL) == -1)\n\t\tshutdown(1, \"sigaction(SIGQUIT)\", __LINE__);\n\tif (sigaction(SIGTERM, &sa, NULL) == -1)\n\t\tshutdown(1, \"sigaction(SIGTERM)\", __LINE__);\n\n\tif (!continuous_mode_fake) {\n\t\tattr.mq_flags = O_NONBLOCK;\n\t\tattr.mq_maxmsg = cur_max_msgs;\n\t\tattr.mq_msgsize = MSG_SIZE;\n\t\topen_queue(&attr);\n\t}\n\tfor (i = 0; i < num_cpus_to_pin; i++) {\n\t\tpthread_attr_t thread_attr;\n\t\tvoid *thread_func;\n\n\t\tif (continuous_mode_fake)\n\t\t\tthread_func = &fake_cont_thread;\n\t\telse if (continuous_mode)\n\t\t\tthread_func = &cont_thread;\n\t\telse\n\t\t\tthread_func = &perf_test_thread;\n\n\t\tCPU_ZERO_S(cpu_set_size, cpu_set);\n\t\tCPU_SET_S(cpus_to_pin[i], cpu_set_size, cpu_set);\n\t\tpthread_attr_init(&thread_attr);\n\t\tpthread_attr_setaffinity_np(&thread_attr, cpu_set_size,\n\t\t\t\t\t    cpu_set);\n\t\tif (pthread_create(&cpu_threads[i], &thread_attr, thread_func,\n\t\t\t\t   NULL))\n\t\t\tshutdown(1, \"pthread_create()\", __LINE__);\n\t\tpthread_attr_destroy(&thread_attr);\n\t}\n\n\tif (!continuous_mode) {\n\t\tpthread_join(cpu_threads[0], &retval);\n\t\tshutdown((long)retval, \"perf_test_thread()\", __LINE__);\n\t} else {\n\t\twhile (1)\n\t\t\tsleep(1);\n\t}\n\tshutdown(0, \"\", 0);\n\nerr_code:\n\tCPU_FREE(cpu_set);\n\texit(1);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}