{
  "module_name": "fd-001-lookup.c",
  "hash_id": "2f4205c34bf06b1493767aa8cd38a6c86aafa43d690ad86dbe791bfd8042fbc0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/proc/fd-001-lookup.c",
  "human_readable_source": " \n\n\n#undef NDEBUG\n#include <assert.h>\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <sched.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include \"proc.h\"\n\n \nstatic void test_lookup_pass(const char *pathname)\n{\n\tstruct stat st;\n\tssize_t rv;\n\n\tmemset(&st, 0, sizeof(struct stat));\n\trv = lstat(pathname, &st);\n\tassert(rv == 0);\n\tassert(S_ISLNK(st.st_mode));\n}\n\nstatic void test_lookup_fail(const char *pathname)\n{\n\tstruct stat st;\n\tssize_t rv;\n\n\trv = lstat(pathname, &st);\n\tassert(rv == -1 && errno == ENOENT);\n}\n\nstatic void test_lookup(unsigned int fd)\n{\n\tchar buf[64];\n\tunsigned int c;\n\tunsigned int u;\n\tint i;\n\n\tsnprintf(buf, sizeof(buf), \"/proc/self/fd/%u\", fd);\n\ttest_lookup_pass(buf);\n\n\t \n\tfor (c = 1; c <= 255; c++) {\n\t\tif (c == '/')\n\t\t\tcontinue;\n\t\tsnprintf(buf, sizeof(buf), \"/proc/self/fd/%c%u\", c, fd);\n\t\ttest_lookup_fail(buf);\n\t}\n\n\t \n\tfor (c = 1; c <= 255; c++) {\n\t\tif (c == '/')\n\t\t\tcontinue;\n\t\tsnprintf(buf, sizeof(buf), \"/proc/self/fd/%u%c\", fd, c);\n\t\ttest_lookup_fail(buf);\n\t}\n\n\tfor (i = INT_MIN; i < INT_MIN + 1024; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"/proc/self/fd/%d\", i);\n\t\ttest_lookup_fail(buf);\n\t}\n\tfor (i = -1024; i < 0; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"/proc/self/fd/%d\", i);\n\t\ttest_lookup_fail(buf);\n\t}\n\tfor (u = INT_MAX - 1024; u <= (unsigned int)INT_MAX + 1024; u++) {\n\t\tsnprintf(buf, sizeof(buf), \"/proc/self/fd/%u\", u);\n\t\ttest_lookup_fail(buf);\n\t}\n\tfor (u = UINT_MAX - 1024; u != 0; u++) {\n\t\tsnprintf(buf, sizeof(buf), \"/proc/self/fd/%u\", u);\n\t\ttest_lookup_fail(buf);\n\t}\n\n\n}\n\nint main(void)\n{\n\tstruct dirent *de;\n\tunsigned int fd, target_fd;\n\n\tif (unshare(CLONE_FILES) == -1)\n\t\treturn 1;\n\n\t \n\tdo {\n\t\tDIR *d;\n\n\t\td = opendir(\"/proc/self/fd\");\n\t\tif (!d)\n\t\t\treturn 1;\n\n\t\tde = xreaddir(d);\n\t\tassert(de->d_type == DT_DIR);\n\t\tassert(streq(de->d_name, \".\"));\n\n\t\tde = xreaddir(d);\n\t\tassert(de->d_type == DT_DIR);\n\t\tassert(streq(de->d_name, \"..\"));\nnext:\n\t\tde = xreaddir(d);\n\t\tif (de) {\n\t\t\tunsigned long long fd_ull;\n\t\t\tunsigned int fd;\n\t\t\tchar *end;\n\n\t\t\tassert(de->d_type == DT_LNK);\n\n\t\t\tfd_ull = xstrtoull(de->d_name, &end);\n\t\t\tassert(*end == '\\0');\n\t\t\tassert(fd_ull == (unsigned int)fd_ull);\n\n\t\t\tfd = fd_ull;\n\t\t\tif (fd == dirfd(d))\n\t\t\t\tgoto next;\n\t\t\tclose(fd);\n\t\t}\n\n\t\tclosedir(d);\n\t} while (de);\n\n\t \n\n\tfd = open(\"/\", O_PATH|O_DIRECTORY);\n\tassert(fd == 0);\n\ttest_lookup(fd);\n\tclose(fd);\n\n\t \n\n\tfd = open(\"/\", O_PATH|O_DIRECTORY);\n\tassert(fd == 0);\n\t \n\ttarget_fd = 1023;\n\twhile (target_fd > 0) {\n\t\tif (dup2(fd, target_fd) == target_fd)\n\t\t\tbreak;\n\t\ttarget_fd /= 2;\n\t}\n\tassert(target_fd > 0);\n\tclose(fd);\n\ttest_lookup(target_fd);\n\tclose(target_fd);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}