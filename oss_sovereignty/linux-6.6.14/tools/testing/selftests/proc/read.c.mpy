{
  "module_name": "read.c",
  "hash_id": "39e0171ae483fa2097efb879be7401b41931ce2b98d18fb260ebaec1d285ab05",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/proc/read.c",
  "human_readable_source": " \n\n\n\n\n\n\n#undef NDEBUG\n#include <assert.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"proc.h\"\n\nstatic void f_reg(DIR *d, const char *filename)\n{\n\tchar buf[4096];\n\tint fd;\n\tssize_t rv;\n\n\t \n\tfd = openat(dirfd(d), filename, O_RDONLY|O_NONBLOCK);\n\tif (fd == -1)\n\t\treturn;\n\t \n\t(void)lseek(fd, 0, SEEK_SET);\n\trv = read(fd, buf, sizeof(buf));\n\tassert((0 <= rv && rv <= sizeof(buf)) || rv == -1);\n\tclose(fd);\n}\n\nstatic void f_reg_write(DIR *d, const char *filename, const char *buf, size_t len)\n{\n\tint fd;\n\tssize_t rv;\n\n\tfd = openat(dirfd(d), filename, O_WRONLY);\n\tif (fd == -1)\n\t\treturn;\n\trv = write(fd, buf, len);\n\tassert((0 <= rv && rv <= len) || rv == -1);\n\tclose(fd);\n}\n\nstatic void f_lnk(DIR *d, const char *filename)\n{\n\tchar buf[4096];\n\tssize_t rv;\n\n\trv = readlinkat(dirfd(d), filename, buf, sizeof(buf));\n\tassert((0 <= rv && rv <= sizeof(buf)) || rv == -1);\n}\n\nstatic void f(DIR *d, unsigned int level)\n{\n\tstruct dirent *de;\n\n\tde = xreaddir(d);\n\tassert(de->d_type == DT_DIR);\n\tassert(streq(de->d_name, \".\"));\n\n\tde = xreaddir(d);\n\tassert(de->d_type == DT_DIR);\n\tassert(streq(de->d_name, \"..\"));\n\n\twhile ((de = xreaddir(d))) {\n\t\tassert(!streq(de->d_name, \".\"));\n\t\tassert(!streq(de->d_name, \"..\"));\n\n\t\tswitch (de->d_type) {\n\t\t\tDIR *dd;\n\t\t\tint fd;\n\n\t\tcase DT_REG:\n\t\t\tif (level == 0 && streq(de->d_name, \"sysrq-trigger\")) {\n\t\t\t\tf_reg_write(d, de->d_name, \"h\", 1);\n\t\t\t} else if (level == 1 && streq(de->d_name, \"clear_refs\")) {\n\t\t\t\tf_reg_write(d, de->d_name, \"1\", 1);\n\t\t\t} else if (level == 3 && streq(de->d_name, \"clear_refs\")) {\n\t\t\t\tf_reg_write(d, de->d_name, \"1\", 1);\n\t\t\t} else {\n\t\t\t\tf_reg(d, de->d_name);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DT_DIR:\n\t\t\tfd = openat(dirfd(d), de->d_name, O_DIRECTORY|O_RDONLY);\n\t\t\tif (fd == -1)\n\t\t\t\tcontinue;\n\t\t\tdd = fdopendir(fd);\n\t\t\tif (!dd)\n\t\t\t\tcontinue;\n\t\t\tf(dd, level + 1);\n\t\t\tclosedir(dd);\n\t\t\tbreak;\n\t\tcase DT_LNK:\n\t\t\tf_lnk(d, de->d_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tDIR *d;\n\tstruct statfs sfs;\n\n\td = opendir(\"/proc\");\n\tif (!d)\n\t\treturn 4;\n\n\t \n\tif (fstatfs(dirfd(d), &sfs) == -1) {\n\t\treturn 1;\n\t}\n\tif (sfs.f_type != 0x9fa0) {\n\t\tfprintf(stderr, \"error: unexpected f_type %lx\\n\", (long)sfs.f_type);\n\t\treturn 2;\n\t}\n\n\tf(d, 0);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}