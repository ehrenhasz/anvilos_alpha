{
  "module_name": "proc-empty-vm.c",
  "hash_id": "184e92df393ced55d3e8e3133670801cf3c38edebc5de202fc64c9b609f3ce40",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/proc/proc-empty-vm.c",
  "human_readable_source": "#if defined __amd64__ || defined __i386__\n \n \n#undef NDEBUG\n#include <assert.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <sys/ptrace.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#ifdef __amd64__\n#define TEST_VSYSCALL\n#endif\n\n \nstatic volatile int g_vsyscall;\nstatic const char *g_proc_pid_maps_vsyscall;\nstatic const char *g_proc_pid_smaps_vsyscall;\n\nstatic const char proc_pid_maps_vsyscall_0[] = \"\";\nstatic const char proc_pid_maps_vsyscall_1[] =\n\"ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]\\n\";\nstatic const char proc_pid_maps_vsyscall_2[] =\n\"ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\\n\";\n\nstatic const char proc_pid_smaps_vsyscall_0[] = \"\";\n\nstatic const char proc_pid_smaps_vsyscall_1[] =\n\"ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\\n\"\n\"Size:                  4 kB\\n\"\n\"KernelPageSize:        4 kB\\n\"\n\"MMUPageSize:           4 kB\\n\"\n\"Rss:                   0 kB\\n\"\n\"Pss:                   0 kB\\n\"\n\"Pss_Dirty:             0 kB\\n\"\n\"Shared_Clean:          0 kB\\n\"\n\"Shared_Dirty:          0 kB\\n\"\n\"Private_Clean:         0 kB\\n\"\n\"Private_Dirty:         0 kB\\n\"\n\"Referenced:            0 kB\\n\"\n\"Anonymous:             0 kB\\n\"\n\"LazyFree:              0 kB\\n\"\n\"AnonHugePages:         0 kB\\n\"\n\"ShmemPmdMapped:        0 kB\\n\"\n\"FilePmdMapped:         0 kB\\n\"\n\"Shared_Hugetlb:        0 kB\\n\"\n\"Private_Hugetlb:       0 kB\\n\"\n\"Swap:                  0 kB\\n\"\n\"SwapPss:               0 kB\\n\"\n\"Locked:                0 kB\\n\"\n\"THPeligible:           0\\n\"\n \n;\n\nstatic const char proc_pid_smaps_vsyscall_2[] =\n\"ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]\\n\"\n\"Size:                  4 kB\\n\"\n\"KernelPageSize:        4 kB\\n\"\n\"MMUPageSize:           4 kB\\n\"\n\"Rss:                   0 kB\\n\"\n\"Pss:                   0 kB\\n\"\n\"Pss_Dirty:             0 kB\\n\"\n\"Shared_Clean:          0 kB\\n\"\n\"Shared_Dirty:          0 kB\\n\"\n\"Private_Clean:         0 kB\\n\"\n\"Private_Dirty:         0 kB\\n\"\n\"Referenced:            0 kB\\n\"\n\"Anonymous:             0 kB\\n\"\n\"LazyFree:              0 kB\\n\"\n\"AnonHugePages:         0 kB\\n\"\n\"ShmemPmdMapped:        0 kB\\n\"\n\"FilePmdMapped:         0 kB\\n\"\n\"Shared_Hugetlb:        0 kB\\n\"\n\"Private_Hugetlb:       0 kB\\n\"\n\"Swap:                  0 kB\\n\"\n\"SwapPss:               0 kB\\n\"\n\"Locked:                0 kB\\n\"\n\"THPeligible:           0\\n\"\n \n;\n\nstatic void sigaction_SIGSEGV(int _, siginfo_t *__, void *___)\n{\n\t_exit(EXIT_FAILURE);\n}\n\n#ifdef TEST_VSYSCALL\nstatic void sigaction_SIGSEGV_vsyscall(int _, siginfo_t *__, void *___)\n{\n\t_exit(g_vsyscall);\n}\n\n \nstatic void vsyscall(void)\n{\n\tpid_t pid;\n\tint wstatus;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tfprintf(stderr, \"fork, errno %d\\n\", errno);\n\t\texit(1);\n\t}\n\tif (pid == 0) {\n\t\tsetrlimit(RLIMIT_CORE, &(struct rlimit){});\n\n\t\t \n\t\tstruct sigaction act = {};\n\t\tact.sa_flags = SA_SIGINFO;\n\t\tact.sa_sigaction = sigaction_SIGSEGV_vsyscall;\n\t\tsigaction(SIGSEGV, &act, NULL);\n\n\t\tg_vsyscall = 0;\n\t\t \n\t\tuint64_t rax = 0xffffffffff600000;\n\t\tasm volatile (\n\t\t\t\"call *%[rax]\"\n\t\t\t: [rax] \"+a\" (rax)\n\t\t\t: \"D\" (NULL), \"S\" (NULL)\n\t\t\t: \"rcx\", \"r11\"\n\t\t);\n\n\t\tg_vsyscall = 1;\n\t\t*(volatile int *)0xffffffffff600000UL;\n\n\t\tg_vsyscall = 2;\n\t\texit(g_vsyscall);\n\t}\n\twaitpid(pid, &wstatus, 0);\n\tif (WIFEXITED(wstatus)) {\n\t\tg_vsyscall = WEXITSTATUS(wstatus);\n\t} else {\n\t\tfprintf(stderr, \"error: vsyscall wstatus %08x\\n\", wstatus);\n\t\texit(1);\n\t}\n}\n#endif\n\nstatic int test_proc_pid_maps(pid_t pid)\n{\n\tchar buf[4096];\n\tsnprintf(buf, sizeof(buf), \"/proc/%u/maps\", pid);\n\tint fd = open(buf, O_RDONLY);\n\tif (fd == -1) {\n\t\tperror(\"open /proc/${pid}/maps\");\n\t\treturn EXIT_FAILURE;\n\t} else {\n\t\tssize_t rv = read(fd, buf, sizeof(buf));\n\t\tclose(fd);\n\t\tif (g_vsyscall == 0) {\n\t\t\tassert(rv == 0);\n\t\t} else {\n\t\t\tsize_t len = strlen(g_proc_pid_maps_vsyscall);\n\t\t\tassert(rv == len);\n\t\t\tassert(memcmp(buf, g_proc_pid_maps_vsyscall, len) == 0);\n\t\t}\n\t\treturn EXIT_SUCCESS;\n\t}\n}\n\nstatic int test_proc_pid_numa_maps(pid_t pid)\n{\n\tchar buf[4096];\n\tsnprintf(buf, sizeof(buf), \"/proc/%u/numa_maps\", pid);\n\tint fd = open(buf, O_RDONLY);\n\tif (fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\t \n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\tperror(\"open /proc/${pid}/numa_maps\");\n\t\treturn EXIT_FAILURE;\n\t} else {\n\t\tssize_t rv = read(fd, buf, sizeof(buf));\n\t\tclose(fd);\n\t\tassert(rv == 0);\n\t\treturn EXIT_SUCCESS;\n\t}\n}\n\nstatic int test_proc_pid_smaps(pid_t pid)\n{\n\tchar buf[4096];\n\tsnprintf(buf, sizeof(buf), \"/proc/%u/smaps\", pid);\n\tint fd = open(buf, O_RDONLY);\n\tif (fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\t \n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\tperror(\"open /proc/${pid}/smaps\");\n\t\treturn EXIT_FAILURE;\n\t} else {\n\t\tssize_t rv = read(fd, buf, sizeof(buf));\n\t\tclose(fd);\n\t\tif (g_vsyscall == 0) {\n\t\t\tassert(rv == 0);\n\t\t} else {\n\t\t\tsize_t len = strlen(g_proc_pid_maps_vsyscall);\n\t\t\t \n\t\t\tassert(rv > len);\n\t\t\tassert(memcmp(buf, g_proc_pid_maps_vsyscall, len) == 0);\n\t\t}\n\t\treturn EXIT_SUCCESS;\n\t}\n}\n\nstatic const char g_smaps_rollup[] =\n\"00000000-00000000 ---p 00000000 00:00 0                                  [rollup]\\n\"\n\"Rss:                   0 kB\\n\"\n\"Pss:                   0 kB\\n\"\n\"Pss_Dirty:             0 kB\\n\"\n\"Pss_Anon:              0 kB\\n\"\n\"Pss_File:              0 kB\\n\"\n\"Pss_Shmem:             0 kB\\n\"\n\"Shared_Clean:          0 kB\\n\"\n\"Shared_Dirty:          0 kB\\n\"\n\"Private_Clean:         0 kB\\n\"\n\"Private_Dirty:         0 kB\\n\"\n\"Referenced:            0 kB\\n\"\n\"Anonymous:             0 kB\\n\"\n\"KSM:                   0 kB\\n\"\n\"LazyFree:              0 kB\\n\"\n\"AnonHugePages:         0 kB\\n\"\n\"ShmemPmdMapped:        0 kB\\n\"\n\"FilePmdMapped:         0 kB\\n\"\n\"Shared_Hugetlb:        0 kB\\n\"\n\"Private_Hugetlb:       0 kB\\n\"\n\"Swap:                  0 kB\\n\"\n\"SwapPss:               0 kB\\n\"\n\"Locked:                0 kB\\n\"\n;\n\nstatic int test_proc_pid_smaps_rollup(pid_t pid)\n{\n\tchar buf[4096];\n\tsnprintf(buf, sizeof(buf), \"/proc/%u/smaps_rollup\", pid);\n\tint fd = open(buf, O_RDONLY);\n\tif (fd == -1) {\n\t\tif (errno == ENOENT) {\n\t\t\t \n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\tperror(\"open /proc/${pid}/smaps_rollup\");\n\t\treturn EXIT_FAILURE;\n\t} else {\n\t\tssize_t rv = read(fd, buf, sizeof(buf));\n\t\tclose(fd);\n\t\tassert(rv == sizeof(g_smaps_rollup) - 1);\n\t\tassert(memcmp(buf, g_smaps_rollup, sizeof(g_smaps_rollup) - 1) == 0);\n\t\treturn EXIT_SUCCESS;\n\t}\n}\n\nint main(void)\n{\n\tint rv = EXIT_SUCCESS;\n\n#ifdef TEST_VSYSCALL\n\tvsyscall();\n#endif\n\n\tswitch (g_vsyscall) {\n\tcase 0:\n\t\tg_proc_pid_maps_vsyscall  = proc_pid_maps_vsyscall_0;\n\t\tg_proc_pid_smaps_vsyscall = proc_pid_smaps_vsyscall_0;\n\t\tbreak;\n\tcase 1:\n\t\tg_proc_pid_maps_vsyscall  = proc_pid_maps_vsyscall_1;\n\t\tg_proc_pid_smaps_vsyscall = proc_pid_smaps_vsyscall_1;\n\t\tbreak;\n\tcase 2:\n\t\tg_proc_pid_maps_vsyscall  = proc_pid_maps_vsyscall_2;\n\t\tg_proc_pid_smaps_vsyscall = proc_pid_smaps_vsyscall_2;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tpid_t pid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\treturn EXIT_FAILURE;\n\t} else if (pid == 0) {\n\t\trv = ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n\t\tif (rv != 0) {\n\t\t\tif (errno == EPERM) {\n\t\t\t\tfprintf(stderr,\n\"Did you know? ptrace(PTRACE_TRACEME) doesn't work under strace.\\n\"\n\t\t\t\t);\n\t\t\t\tkill(getppid(), SIGTERM);\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\tperror(\"ptrace PTRACE_TRACEME\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\t \n\t\tstruct sigaction act = {};\n\t\tact.sa_flags = SA_SIGINFO;\n\t\tact.sa_sigaction = sigaction_SIGSEGV;\n\t\tsigaction(SIGSEGV, &act, NULL);\n\n#ifdef __amd64__\n\t\tmunmap(NULL, ((size_t)1 << 47) - 4096);\n#elif defined __i386__\n\t\t{\n\t\t\tsize_t len;\n\n\t\t\tfor (len = -4096;; len -= 4096) {\n\t\t\t\tmunmap(NULL, len);\n\t\t\t}\n\t\t}\n#else\n#error \"implement 'unmap everything'\"\n#endif\n\t\treturn EXIT_FAILURE;\n\t} else {\n\t\t \n\t\tsleep(1);\n\n\t\tif (rv == EXIT_SUCCESS) {\n\t\t\trv = test_proc_pid_maps(pid);\n\t\t}\n\t\tif (rv == EXIT_SUCCESS) {\n\t\t\trv = test_proc_pid_numa_maps(pid);\n\t\t}\n\t\tif (rv == EXIT_SUCCESS) {\n\t\t\trv = test_proc_pid_smaps(pid);\n\t\t}\n\t\tif (rv == EXIT_SUCCESS) {\n\t\t\trv = test_proc_pid_smaps_rollup(pid);\n\t\t}\n\t\t \n\n\t\t \n\t\tint wstatus;\n\t\twaitpid(pid, &wstatus, 0);\n\t\tassert(WIFSTOPPED(wstatus));\n\t\tassert(WSTOPSIG(wstatus) == SIGSEGV);\n\t}\n\n\treturn rv;\n}\n#else\nint main(void)\n{\n\treturn 4;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}