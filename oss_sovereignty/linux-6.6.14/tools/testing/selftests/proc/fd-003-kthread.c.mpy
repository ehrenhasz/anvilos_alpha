{
  "module_name": "fd-003-kthread.c",
  "hash_id": "89183de4d8e18b3acd16e655ec8c45cf111d4be7dac37d7d660a95791a029056",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/proc/fd-003-kthread.c",
  "human_readable_source": " \n\n\n#undef NDEBUG\n#include <sys/syscall.h>\n#include <assert.h>\n#include <dirent.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"proc.h\"\n\n#define PF_KHTREAD 0x00200000\n\n \nstatic int kernel_thread_fd(unsigned int pid)\n{\n\tunsigned int flags = 0;\n\tchar buf[4096];\n\tint dir_fd, fd;\n\tssize_t rv;\n\n\tsnprintf(buf, sizeof(buf), \"/proc/%u\", pid);\n\tdir_fd = open(buf, O_RDONLY|O_DIRECTORY);\n\tif (dir_fd == -1)\n\t\treturn -1;\n\n\t \n\tfd = openat(dir_fd, \"stat\", O_RDONLY);\n\tif (fd == -1) {\n\t\tclose(dir_fd);\n\t\treturn -1;\n\t}\n\trv = read(fd, buf, sizeof(buf));\n\tclose(fd);\n\tif (0 < rv && rv <= sizeof(buf)) {\n\t\tunsigned long long flags_ull;\n\t\tchar *p, *end;\n\t\tint i;\n\n\t\tassert(buf[rv - 1] == '\\n');\n\t\tbuf[rv - 1] = '\\0';\n\n\t\t \n\t\tfor (i = 0; i < 43; i++) {\n\t\t\tp = strrchr(buf, ' ');\n\t\t\tassert(p);\n\t\t\t*p = '\\0';\n\t\t}\n\n\t\tp = strrchr(buf, ' ');\n\t\tassert(p);\n\n\t\tflags_ull = xstrtoull(p + 1, &end);\n\t\tassert(*end == '\\0');\n\t\tassert(flags_ull == (unsigned int)flags_ull);\n\n\t\tflags = flags_ull;\n\t}\n\n\tfd = -1;\n\tif (flags & PF_KHTREAD) {\n\t\tfd = openat(dir_fd, \"fd\", O_RDONLY|O_DIRECTORY);\n\t}\n\tclose(dir_fd);\n\treturn fd;\n}\n\nstatic void test_readdir(int fd)\n{\n\tDIR *d;\n\tstruct dirent *de;\n\n\td = fdopendir(fd);\n\tassert(d);\n\n\tde = xreaddir(d);\n\tassert(streq(de->d_name, \".\"));\n\tassert(de->d_type == DT_DIR);\n\n\tde = xreaddir(d);\n\tassert(streq(de->d_name, \"..\"));\n\tassert(de->d_type == DT_DIR);\n\n\tde = xreaddir(d);\n\tassert(!de);\n}\n\nstatic inline int sys_statx(int dirfd, const char *pathname, int flags,\n\t\t\t    unsigned int mask, void *stx)\n{\n\treturn syscall(SYS_statx, dirfd, pathname, flags, mask, stx);\n}\n\nstatic void test_lookup_fail(int fd, const char *pathname)\n{\n\tchar stx[256] __attribute__((aligned(8)));\n\tint rv;\n\n\trv = sys_statx(fd, pathname, AT_SYMLINK_NOFOLLOW, 0, (void *)stx);\n\tassert(rv == -1 && errno == ENOENT);\n}\n\nstatic void test_lookup(int fd)\n{\n\tchar buf[64];\n\tunsigned int u;\n\tint i;\n\n\tfor (i = INT_MIN; i < INT_MIN + 1024; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%d\", i);\n\t\ttest_lookup_fail(fd, buf);\n\t}\n\tfor (i = -1024; i < 1024; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%d\", i);\n\t\ttest_lookup_fail(fd, buf);\n\t}\n\tfor (u = INT_MAX - 1024; u < (unsigned int)INT_MAX + 1024; u++) {\n\t\tsnprintf(buf, sizeof(buf), \"%u\", u);\n\t\ttest_lookup_fail(fd, buf);\n\t}\n\tfor (u = UINT_MAX - 1024; u != 0; u++) {\n\t\tsnprintf(buf, sizeof(buf), \"%u\", u);\n\t\ttest_lookup_fail(fd, buf);\n\t}\n}\n\nint main(void)\n{\n\tunsigned int pid;\n\tint fd;\n\n\t \n\tpid = 2;\n\twhile ((fd = kernel_thread_fd(pid)) == -1 && pid < 1024) {\n\t\tpid++;\n\t}\n\t \n\tif (pid >= 1024)\n\t\treturn 1;\n\n\ttest_readdir(fd);\n\ttest_lookup(fd);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}