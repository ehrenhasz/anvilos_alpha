{
  "module_name": "proc-pid-vm.c",
  "hash_id": "d71d900a480382300fcbbf52b92ca5f153220c516fe35b5ed17b8b97584c4bea",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/proc/proc-pid-vm.c",
  "human_readable_source": " \n \n#undef NDEBUG\n#include <assert.h>\n#include <errno.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/mount.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/uio.h>\n#include <linux/kdev_t.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n\n#include \"../kselftest.h\"\n\nstatic inline long sys_execveat(int dirfd, const char *pathname, char **argv, char **envp, int flags)\n{\n\treturn syscall(SYS_execveat, dirfd, pathname, argv, envp, flags);\n}\n\nstatic void make_private_tmp(void)\n{\n\tif (unshare(CLONE_NEWNS) == -1) {\n\t\tif (errno == ENOSYS || errno == EPERM) {\n\t\t\texit(4);\n\t\t}\n\t\texit(1);\n\t}\n\tif (mount(NULL, \"/\", NULL, MS_PRIVATE|MS_REC, NULL) == -1) {\n\t\texit(1);\n\t}\n\tif (mount(NULL, \"/tmp\", \"tmpfs\", 0, NULL) == -1) {\n\t\texit(1);\n\t}\n}\n\nstatic pid_t pid = -1;\nstatic void ate(void)\n{\n\tif (pid > 0) {\n\t\tkill(pid, SIGTERM);\n\t}\n}\n\nstruct elf64_hdr {\n\tuint8_t e_ident[16];\n\tuint16_t e_type;\n\tuint16_t e_machine;\n\tuint32_t e_version;\n\tuint64_t e_entry;\n\tuint64_t e_phoff;\n\tuint64_t e_shoff;\n\tuint32_t e_flags;\n\tuint16_t e_ehsize;\n\tuint16_t e_phentsize;\n\tuint16_t e_phnum;\n\tuint16_t e_shentsize;\n\tuint16_t e_shnum;\n\tuint16_t e_shstrndx;\n};\n\nstruct elf64_phdr {\n\tuint32_t p_type;\n\tuint32_t p_flags;\n\tuint64_t p_offset;\n\tuint64_t p_vaddr;\n\tuint64_t p_paddr;\n\tuint64_t p_filesz;\n\tuint64_t p_memsz;\n\tuint64_t p_align;\n};\n\n#ifdef __x86_64__\n#define PAGE_SIZE 4096\n#define VADDR (1UL << 32)\n#define MAPS_OFFSET 73\n\n#define syscall\t0x0f, 0x05\n#define mov_rdi(x)\t\\\n\t0x48, 0xbf,\t\\\n\t(x)&0xff, ((x)>>8)&0xff, ((x)>>16)&0xff, ((x)>>24)&0xff,\t\\\n\t((x)>>32)&0xff, ((x)>>40)&0xff, ((x)>>48)&0xff, ((x)>>56)&0xff\n\n#define mov_rsi(x)\t\\\n\t0x48, 0xbe,\t\\\n\t(x)&0xff, ((x)>>8)&0xff, ((x)>>16)&0xff, ((x)>>24)&0xff,\t\\\n\t((x)>>32)&0xff, ((x)>>40)&0xff, ((x)>>48)&0xff, ((x)>>56)&0xff\n\n#define mov_eax(x)\t\\\n\t0xb8, (x)&0xff, ((x)>>8)&0xff, ((x)>>16)&0xff, ((x)>>24)&0xff\n\nstatic const uint8_t payload[] = {\n\t \n\t \n\tmov_rdi(VADDR + 4096),\n\tmov_rsi((1ULL << 47) - 4096 - VADDR - 4096),\n\tmov_eax(11),\n\tsyscall,\n\n\t \n\t \n\t0x31, 0xff,\t\t\t\t\t \n\t0x48, 0x8d, 0x35, 0x00, 0x00, 0x00, 0x00,\t \n\t0xba, 0x01, 0x00, 0x00, 0x00,\t\t\t \n\tmov_eax(1),\n\tsyscall,\n\n\t \n\tmov_eax(34),\n\tsyscall,\n\n\t0xeb, 0xf7,\t \n};\n\nstatic int make_exe(const uint8_t *payload, size_t len)\n{\n\tstruct elf64_hdr h;\n\tstruct elf64_phdr ph;\n\n\tstruct iovec iov[3] = {\n\t\t{&h, sizeof(struct elf64_hdr)},\n\t\t{&ph, sizeof(struct elf64_phdr)},\n\t\t{(void *)payload, len},\n\t};\n\tint fd, fd1;\n\tchar buf[64];\n\n\tmemset(&h, 0, sizeof(h));\n\th.e_ident[0] = 0x7f;\n\th.e_ident[1] = 'E';\n\th.e_ident[2] = 'L';\n\th.e_ident[3] = 'F';\n\th.e_ident[4] = 2;\n\th.e_ident[5] = 1;\n\th.e_ident[6] = 1;\n\th.e_ident[7] = 0;\n\th.e_type = 2;\n\th.e_machine = 0x3e;\n\th.e_version = 1;\n\th.e_entry = VADDR + sizeof(struct elf64_hdr) + sizeof(struct elf64_phdr);\n\th.e_phoff = sizeof(struct elf64_hdr);\n\th.e_shoff = 0;\n\th.e_flags = 0;\n\th.e_ehsize = sizeof(struct elf64_hdr);\n\th.e_phentsize = sizeof(struct elf64_phdr);\n\th.e_phnum = 1;\n\th.e_shentsize = 0;\n\th.e_shnum = 0;\n\th.e_shstrndx = 0;\n\n\tmemset(&ph, 0, sizeof(ph));\n\tph.p_type = 1;\n\tph.p_flags = (1<<2)|1;\n\tph.p_offset = 0;\n\tph.p_vaddr = VADDR;\n\tph.p_paddr = 0;\n\tph.p_filesz = sizeof(struct elf64_hdr) + sizeof(struct elf64_phdr) + len;\n\tph.p_memsz = sizeof(struct elf64_hdr) + sizeof(struct elf64_phdr) + len;\n\tph.p_align = 4096;\n\n\tfd = openat(AT_FDCWD, \"/tmp\", O_WRONLY|O_EXCL|O_TMPFILE, 0700);\n\tif (fd == -1) {\n\t\texit(1);\n\t}\n\n\tif (writev(fd, iov, 3) != sizeof(struct elf64_hdr) + sizeof(struct elf64_phdr) + len) {\n\t\texit(1);\n\t}\n\n\t \n\tsnprintf(buf, sizeof(buf), \"/proc/self/fd/%u\", fd);\n\tfd1 = open(buf, O_RDONLY|O_CLOEXEC);\n\tclose(fd);\n\n\treturn fd1;\n}\n#endif\n\n \nstatic volatile int g_vsyscall;\nstatic const char *str_vsyscall;\n\nstatic const char str_vsyscall_0[] = \"\";\nstatic const char str_vsyscall_1[] =\n\"ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]\\n\";\nstatic const char str_vsyscall_2[] =\n\"ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\\n\";\n\n#ifdef __x86_64__\nstatic void sigaction_SIGSEGV(int _, siginfo_t *__, void *___)\n{\n\t_exit(g_vsyscall);\n}\n\n \nstatic void vsyscall(void)\n{\n\tpid_t pid;\n\tint wstatus;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tfprintf(stderr, \"fork, errno %d\\n\", errno);\n\t\texit(1);\n\t}\n\tif (pid == 0) {\n\t\tstruct rlimit rlim = {0, 0};\n\t\t(void)setrlimit(RLIMIT_CORE, &rlim);\n\n\t\t \n\t\tstruct sigaction act;\n\t\tmemset(&act, 0, sizeof(struct sigaction));\n\t\tact.sa_flags = SA_SIGINFO;\n\t\tact.sa_sigaction = sigaction_SIGSEGV;\n\t\t(void)sigaction(SIGSEGV, &act, NULL);\n\n\t\tg_vsyscall = 0;\n\t\t \n\t\tuint64_t rax = 0xffffffffff600000;\n\t\tasm volatile (\n\t\t\t\"call *%[rax]\"\n\t\t\t: [rax] \"+a\" (rax)\n\t\t\t: \"D\" (NULL), \"S\" (NULL)\n\t\t\t: \"rcx\", \"r11\"\n\t\t);\n\n\t\tg_vsyscall = 1;\n\t\t*(volatile int *)0xffffffffff600000UL;\n\n\t\tg_vsyscall = 2;\n\t\texit(g_vsyscall);\n\t}\n\twaitpid(pid, &wstatus, 0);\n\tif (WIFEXITED(wstatus)) {\n\t\tg_vsyscall = WEXITSTATUS(wstatus);\n\t} else {\n\t\tfprintf(stderr, \"error: wstatus %08x\\n\", wstatus);\n\t\texit(1);\n\t}\n}\n\nint main(void)\n{\n\tint pipefd[2];\n\tint exec_fd;\n\n\tvsyscall();\n\tswitch (g_vsyscall) {\n\tcase 0:\n\t\tstr_vsyscall = str_vsyscall_0;\n\t\tbreak;\n\tcase 1:\n\t\tstr_vsyscall = str_vsyscall_1;\n\t\tbreak;\n\tcase 2:\n\t\tstr_vsyscall = str_vsyscall_2;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tatexit(ate);\n\n\tmake_private_tmp();\n\n\t \n\tclose(0);\n\tif (open(\"/\", O_RDONLY|O_DIRECTORY|O_PATH) != 0) {\n\t\treturn 1;\n\t}\n\n\texec_fd = make_exe(payload, sizeof(payload));\n\n\tif (pipe(pipefd) == -1) {\n\t\treturn 1;\n\t}\n\tif (dup2(pipefd[1], 0) != 0) {\n\t\treturn 1;\n\t}\n\n\tpid = fork();\n\tif (pid == -1) {\n\t\treturn 1;\n\t}\n\tif (pid == 0) {\n\t\tsys_execveat(exec_fd, \"\", NULL, NULL, AT_EMPTY_PATH);\n\t\treturn 1;\n\t}\n\n\tchar _;\n\tif (read(pipefd[0], &_, 1) != 1) {\n\t\treturn 1;\n\t}\n\n\tstruct stat st;\n\tif (fstat(exec_fd, &st) == -1) {\n\t\treturn 1;\n\t}\n\n\t \n\tchar buf0[256];\n\tmemset(buf0, ' ', sizeof(buf0));\n\tint len = snprintf(buf0, sizeof(buf0),\n\t\t\t\"%08lx-%08lx r-xp 00000000 %02lx:%02lx %llu\",\n\t\t\tVADDR, VADDR + PAGE_SIZE,\n\t\t\tMAJOR(st.st_dev), MINOR(st.st_dev),\n\t\t\t(unsigned long long)st.st_ino);\n\tbuf0[len] = ' ';\n\tsnprintf(buf0 + MAPS_OFFSET, sizeof(buf0) - MAPS_OFFSET,\n\t\t \"/tmp/#%llu (deleted)\\n\", (unsigned long long)st.st_ino);\n\n\t \n\t{\n\t\tconst size_t len = strlen(buf0) + strlen(str_vsyscall);\n\t\tchar buf[256];\n\t\tssize_t rv;\n\t\tint fd;\n\n\t\tsnprintf(buf, sizeof(buf), \"/proc/%u/maps\", pid);\n\t\tfd = open(buf, O_RDONLY);\n\t\tif (fd == -1) {\n\t\t\treturn 1;\n\t\t}\n\t\trv = read(fd, buf, sizeof(buf));\n\t\tassert(rv == len);\n\t\tassert(memcmp(buf, buf0, strlen(buf0)) == 0);\n\t\tif (g_vsyscall > 0) {\n\t\t\tassert(memcmp(buf + strlen(buf0), str_vsyscall, strlen(str_vsyscall)) == 0);\n\t\t}\n\t}\n\n\t \n\t{\n\t\tchar buf[4096];\n\t\tssize_t rv;\n\t\tint fd;\n\n\t\tsnprintf(buf, sizeof(buf), \"/proc/%u/smaps\", pid);\n\t\tfd = open(buf, O_RDONLY);\n\t\tif (fd == -1) {\n\t\t\treturn 1;\n\t\t}\n\t\trv = read(fd, buf, sizeof(buf));\n\t\tassert(0 <= rv && rv <= sizeof(buf));\n\n\t\tassert(rv >= strlen(buf0));\n\t\tassert(memcmp(buf, buf0, strlen(buf0)) == 0);\n\n#define RSS1 \"Rss:                   4 kB\\n\"\n#define RSS2 \"Rss:                   0 kB\\n\"\n#define PSS1 \"Pss:                   4 kB\\n\"\n#define PSS2 \"Pss:                   0 kB\\n\"\n\t\tassert(memmem(buf, rv, RSS1, strlen(RSS1)) ||\n\t\t       memmem(buf, rv, RSS2, strlen(RSS2)));\n\t\tassert(memmem(buf, rv, PSS1, strlen(PSS1)) ||\n\t\t       memmem(buf, rv, PSS2, strlen(PSS2)));\n\n\t\tstatic const char *S[] = {\n\t\t\t\"Size:                  4 kB\\n\",\n\t\t\t\"KernelPageSize:        4 kB\\n\",\n\t\t\t\"MMUPageSize:           4 kB\\n\",\n\t\t\t\"Anonymous:             0 kB\\n\",\n\t\t\t\"AnonHugePages:         0 kB\\n\",\n\t\t\t\"Shared_Hugetlb:        0 kB\\n\",\n\t\t\t\"Private_Hugetlb:       0 kB\\n\",\n\t\t\t\"Locked:                0 kB\\n\",\n\t\t};\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(S); i++) {\n\t\t\tassert(memmem(buf, rv, S[i], strlen(S[i])));\n\t\t}\n\n\t\tif (g_vsyscall > 0) {\n\t\t\tassert(memmem(buf, rv, str_vsyscall, strlen(str_vsyscall)));\n\t\t}\n\t}\n\n\t \n\t{\n\t\tchar bufr[256];\n\t\tmemset(bufr, ' ', sizeof(bufr));\n\t\tlen = snprintf(bufr, sizeof(bufr),\n\t\t\t\t\"%08lx-%08lx ---p 00000000 00:00 0\",\n\t\t\t\tVADDR, VADDR + PAGE_SIZE);\n\t\tbufr[len] = ' ';\n\t\tsnprintf(bufr + MAPS_OFFSET, sizeof(bufr) - MAPS_OFFSET,\n\t\t\t \"[rollup]\\n\");\n\n\t\tchar buf[1024];\n\t\tssize_t rv;\n\t\tint fd;\n\n\t\tsnprintf(buf, sizeof(buf), \"/proc/%u/smaps_rollup\", pid);\n\t\tfd = open(buf, O_RDONLY);\n\t\tif (fd == -1) {\n\t\t\treturn 1;\n\t\t}\n\t\trv = read(fd, buf, sizeof(buf));\n\t\tassert(0 <= rv && rv <= sizeof(buf));\n\n\t\tassert(rv >= strlen(bufr));\n\t\tassert(memcmp(buf, bufr, strlen(bufr)) == 0);\n\n\t\tassert(memmem(buf, rv, RSS1, strlen(RSS1)) ||\n\t\t       memmem(buf, rv, RSS2, strlen(RSS2)));\n\t\tassert(memmem(buf, rv, PSS1, strlen(PSS1)) ||\n\t\t       memmem(buf, rv, PSS2, strlen(PSS2)));\n\n\t\tstatic const char *S[] = {\n\t\t\t\"Anonymous:             0 kB\\n\",\n\t\t\t\"AnonHugePages:         0 kB\\n\",\n\t\t\t\"Shared_Hugetlb:        0 kB\\n\",\n\t\t\t\"Private_Hugetlb:       0 kB\\n\",\n\t\t\t\"Locked:                0 kB\\n\",\n\t\t};\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(S); i++) {\n\t\t\tassert(memmem(buf, rv, S[i], strlen(S[i])));\n\t\t}\n\t}\n\n\t \n\t{\n\t\tchar buf[64];\n\t\tssize_t rv;\n\t\tint fd;\n\n\t\tsnprintf(buf, sizeof(buf), \"/proc/%u/statm\", pid);\n\t\tfd = open(buf, O_RDONLY);\n\t\tif (fd == -1) {\n\t\t\treturn 1;\n\t\t}\n\t\trv = read(fd, buf, sizeof(buf));\n\t\tassert(rv == 7 * 2);\n\n\t\tassert(buf[0] == '1');\t \n\t\tassert(buf[1] == ' ');\n\t\tassert(buf[2] == '0' || buf[2] == '1');\t \n\t\tassert(buf[3] == ' ');\n\t\tassert(buf[4] == '0' || buf[2] == '1');\t \n\t\tassert(buf[5] == ' ');\n\t\tassert(buf[6] == '1');\t \n\t\tassert(buf[7] == ' ');\n\t\tassert(buf[8] == '0');\n\t\tassert(buf[9] == ' ');\n\t\tassert(buf[10] == '0');\t \n\t\tassert(buf[11] == ' ');\n\t\tassert(buf[12] == '0');\n\t\tassert(buf[13] == '\\n');\n\t}\n\n\treturn 0;\n}\n#else\nint main(void)\n{\n\treturn 4;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}