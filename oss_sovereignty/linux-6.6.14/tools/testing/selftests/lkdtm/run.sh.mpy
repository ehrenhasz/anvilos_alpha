{
  "module_name": "run.sh",
  "hash_id": "15eb892a9f8f77f10aa98d756624a9b78b260b0f8c2d9bbcebe67254b9bd5cc7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/lkdtm/run.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# This reads tests.txt for the list of LKDTM tests to invoke. Any marked\n# with a leading \"#\" are skipped. The rest of the line after the\n# test name is either the text to look for in dmesg for a \"success\",\n# or the rationale for why a test is marked to be skipped.\n#\nset -e\nTRIGGER=/sys/kernel/debug/provoke-crash/DIRECT\nCLEAR_ONCE=/sys/kernel/debug/clear_warn_once\nKSELFTEST_SKIP_TEST=4\n\n# Verify we have LKDTM available in the kernel.\nif [ ! -r $TRIGGER ] ; then\n\t/sbin/modprobe -q lkdtm || true\n\tif [ ! -r $TRIGGER ] ; then\n\t\techo \"Cannot find $TRIGGER (missing CONFIG_LKDTM?)\"\n\telse\n\t\techo \"Cannot write $TRIGGER (need to run as root?)\"\n\tfi\n\t# Skip this test\n\texit $KSELFTEST_SKIP_TEST\nfi\n\n# Figure out which test to run from our script name.\ntest=$(basename $0 .sh)\n# Look up details about the test from master list of LKDTM tests.\nline=$(grep -E '^#?'\"$test\"'\\b' tests.txt)\nif [ -z \"$line\" ]; then\n\techo \"Skipped: missing test '$test' in tests.txt\"\n\texit $KSELFTEST_SKIP_TEST\nfi\n# Check that the test is known to LKDTM.\nif ! grep -E -q '^'\"$test\"'$' \"$TRIGGER\" ; then\n\techo \"Skipped: test '$test' missing in $TRIGGER!\"\n\texit $KSELFTEST_SKIP_TEST\nfi\n\n# Extract notes/expected output from test list.\ntest=$(echo \"$line\" | cut -d\" \" -f1)\nif echo \"$line\" | grep -q ' ' ; then\n\texpect=$(echo \"$line\" | cut -d\" \" -f2-)\nelse\n\texpect=\"\"\nfi\n\n# If the test is commented out, report a skip\nif echo \"$test\" | grep -q '^#' ; then\n\ttest=$(echo \"$test\" | cut -c2-)\n\tif [ -z \"$expect\" ]; then\n\t\texpect=\"crashes entire system\"\n\tfi\n\techo \"Skipping $test: $expect\"\n\texit $KSELFTEST_SKIP_TEST\nfi\n\n# If no expected output given, assume an Oops with back trace is success.\nrepeat=1\nif [ -z \"$expect\" ]; then\n\texpect=\"call trace:\"\nelse\n\tif echo \"$expect\" | grep -q '^repeat:' ; then\n\t\trepeat=$(echo \"$expect\" | cut -d' ' -f1 | cut -d: -f2)\n\t\texpect=$(echo \"$expect\" | cut -d' ' -f2-)\n\tfi\nfi\n\n# Prepare log for report checking\nLOG=$(mktemp --tmpdir -t lkdtm-log-XXXXXX)\nDMESG=$(mktemp --tmpdir -t lkdtm-dmesg-XXXXXX)\ncleanup() {\n\trm -f \"$LOG\" \"$DMESG\"\n}\ntrap cleanup EXIT\n\n# Reset WARN_ONCE counters so we trip it each time this runs.\nif [ -w $CLEAR_ONCE ] ; then\n\techo 1 > $CLEAR_ONCE\nfi\n\n# Save existing dmesg so we can detect new content below\ndmesg > \"$DMESG\"\n\n# Since the kernel is likely killing the process writing to the trigger\n# file, it must not be the script's shell itself. i.e. we cannot do:\n#     echo \"$test\" >\"$TRIGGER\"\n# Instead, use \"cat\" to take the signal. Since the shell will yell about\n# the signal that killed the subprocess, we must ignore the failure and\n# continue. However we don't silence stderr since there might be other\n# useful details reported there in the case of other unexpected conditions.\nfor i in $(seq 1 $repeat); do\n\techo \"$test\" | cat >\"$TRIGGER\" || true\ndone\n\n# Record and dump the results\ndmesg | comm --nocheck-order -13 \"$DMESG\" - > \"$LOG\" || true\n\ncat \"$LOG\"\n# Check for expected output\nif grep -E -qi \"$expect\" \"$LOG\" ; then\n\techo \"$test: saw '$expect': ok\"\n\texit 0\nelse\n\tif grep -E -qi XFAIL: \"$LOG\" ; then\n\t\techo \"$test: saw 'XFAIL': [SKIP]\"\n\t\texit $KSELFTEST_SKIP_TEST\n\telse\n\t\techo \"$test: missing '$expect': [FAIL]\"\n\t\texit 1\n\tfi\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}