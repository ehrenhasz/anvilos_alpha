{
  "module_name": "fw_fallback.sh",
  "hash_id": "1ff3a4c75e3f53f98b34a19c822f1a0f95529c215388cfeb9ab8db4f8e1b526e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/firmware/fw_fallback.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# This validates that the kernel will fall back to using the fallback mechanism\n# to load firmware it can't find on disk itself. We must request a firmware\n# that the kernel won't find, and any installed helper (e.g. udev) also\n# won't find so that we can do the load ourself manually.\nset -e\n\nTEST_REQS_FW_SYSFS_FALLBACK=\"yes\"\nTEST_REQS_FW_SET_CUSTOM_PATH=\"no\"\nTEST_DIR=$(dirname $0)\nsource $TEST_DIR/fw_lib.sh\n\ncheck_mods\ncheck_setup\nverify_reqs\nsetup_tmp_file\n\ntrap \"test_finish\" EXIT\n\nload_fw()\n{\n\tlocal name=\"$1\"\n\tlocal file=\"$2\"\n\n\t# This will block until our load (below) has finished.\n\techo -n \"$name\" >\"$DIR\"/trigger_request &\n\n\t# Give kernel a chance to react.\n\tlocal timeout=10\n\twhile [ ! -e \"$DIR\"/\"$name\"/loading ]; do\n\t\tsleep 0.1\n\t\ttimeout=$(( $timeout - 1 ))\n\t\tif [ \"$timeout\" -eq 0 ]; then\n\t\t\techo \"$0: firmware interface never appeared\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n\n\techo 1 >\"$DIR\"/\"$name\"/loading\n\tcat \"$file\" >\"$DIR\"/\"$name\"/data\n\techo 0 >\"$DIR\"/\"$name\"/loading\n\n\t# Wait for request to finish.\n\twait\n}\n\nload_fw_cancel()\n{\n\tlocal name=\"$1\"\n\tlocal file=\"$2\"\n\n\t# This will block until our load (below) has finished.\n\techo -n \"$name\" >\"$DIR\"/trigger_request 2>/dev/null &\n\n\t# Give kernel a chance to react.\n\tlocal timeout=10\n\twhile [ ! -e \"$DIR\"/\"$name\"/loading ]; do\n\t\tsleep 0.1\n\t\ttimeout=$(( $timeout - 1 ))\n\t\tif [ \"$timeout\" -eq 0 ]; then\n\t\t\techo \"$0: firmware interface never appeared\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n\n\techo -1 >\"$DIR\"/\"$name\"/loading\n\n\t# Wait for request to finish.\n\twait\n}\n\nload_fw_custom()\n{\n\tif [ ! -e \"$DIR\"/trigger_custom_fallback ]; then\n\t\techo \"$0: custom fallback trigger not present, ignoring test\" >&2\n\t\texit $ksft_skip\n\tfi\n\n\tlocal name=\"$1\"\n\tlocal file=\"$2\"\n\n\techo -n \"$name\" >\"$DIR\"/trigger_custom_fallback 2>/dev/null &\n\n\t# Give kernel a chance to react.\n\tlocal timeout=10\n\twhile [ ! -e \"$DIR\"/\"$name\"/loading ]; do\n\t\tsleep 0.1\n\t\ttimeout=$(( $timeout - 1 ))\n\t\tif [ \"$timeout\" -eq 0 ]; then\n\t\t\techo \"$0: firmware interface never appeared\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n\n\techo 1 >\"$DIR\"/\"$name\"/loading\n\tcat \"$file\" >\"$DIR\"/\"$name\"/data\n\techo 0 >\"$DIR\"/\"$name\"/loading\n\n\t# Wait for request to finish.\n\twait\n\treturn 0\n}\n\n\nload_fw_custom_cancel()\n{\n\tif [ ! -e \"$DIR\"/trigger_custom_fallback ]; then\n\t\techo \"$0: canceling custom fallback trigger not present, ignoring test\" >&2\n\t\texit $ksft_skip\n\tfi\n\n\tlocal name=\"$1\"\n\tlocal file=\"$2\"\n\n\techo -n \"$name\" >\"$DIR\"/trigger_custom_fallback 2>/dev/null &\n\n\t# Give kernel a chance to react.\n\tlocal timeout=10\n\twhile [ ! -e \"$DIR\"/\"$name\"/loading ]; do\n\t\tsleep 0.1\n\t\ttimeout=$(( $timeout - 1 ))\n\t\tif [ \"$timeout\" -eq 0 ]; then\n\t\t\techo \"$0: firmware interface never appeared\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n\n\techo -1 >\"$DIR\"/\"$name\"/loading\n\n\t# Wait for request to finish.\n\twait\n\treturn 0\n}\n\nload_fw_fallback_with_child()\n{\n\tlocal name=\"$1\"\n\tlocal file=\"$2\"\n\n\t# This is the value already set but we want to be explicit\n\techo 4 >/sys/class/firmware/timeout\n\n\tsleep 1 &\n\tSECONDS_BEFORE=$(date +%s)\n\techo -n \"$name\" >\"$DIR\"/trigger_request 2>/dev/null\n\tSECONDS_AFTER=$(date +%s)\n\tSECONDS_DELTA=$(($SECONDS_AFTER - $SECONDS_BEFORE))\n\tif [ \"$SECONDS_DELTA\" -lt 4 ]; then\n\t\tRET=1\n\telse\n\t\tRET=0\n\tfi\n\twait\n\treturn $RET\n}\n\ntest_syfs_timeout()\n{\n\tDEVPATH=\"$DIR\"/\"nope-$NAME\"/loading\n\n\t# Test failure when doing nothing (timeout works).\n\techo -n 2 >/sys/class/firmware/timeout\n\techo -n \"nope-$NAME\" >\"$DIR\"/trigger_request 2>/dev/null &\n\n\t# Give the kernel some time to load the loading file, must be less\n\t# than the timeout above.\n\tsleep 1\n\tif [ ! -f $DEVPATH ]; then\n\t\techo \"$0: fallback mechanism immediately cancelled\"\n\t\techo \"\"\n\t\techo \"The file never appeared: $DEVPATH\"\n\t\techo \"\"\n\t\techo \"This might be a distribution udev rule setup by your distribution\"\n\t\techo \"to immediately cancel all fallback requests, this must be\"\n\t\techo \"removed before running these tests. To confirm look for\"\n\t\techo \"a firmware rule like /lib/udev/rules.d/50-firmware.rules\"\n\t\techo \"and see if you have something like this:\"\n\t\techo \"\"\n\t\techo \"SUBSYSTEM==\\\"firmware\\\", ACTION==\\\"add\\\", ATTR{loading}=\\\"-1\\\"\"\n\t\techo \"\"\n\t\techo \"If you do remove this file or comment out this line before\"\n\t\techo \"proceeding with these tests.\"\n\t\texit 1\n\tfi\n\n\tif diff -q \"$FW\" /dev/test_firmware >/dev/null ; then\n\t\techo \"$0: firmware was not expected to match\" >&2\n\t\texit 1\n\telse\n\t\techo \"$0: timeout works\"\n\tfi\n}\n\nrun_sysfs_main_tests()\n{\n\ttest_syfs_timeout\n\t# Put timeout high enough for us to do work but not so long that failures\n\t# slow down this test too much.\n\techo 4 >/sys/class/firmware/timeout\n\n\t# Load this script instead of the desired firmware.\n\tload_fw \"$NAME\" \"$0\"\n\tif diff -q \"$FW\" /dev/test_firmware >/dev/null ; then\n\t\techo \"$0: firmware was not expected to match\" >&2\n\t\texit 1\n\telse\n\t\techo \"$0: firmware comparison works\"\n\tfi\n\n\t# Do a proper load, which should work correctly.\n\tload_fw \"$NAME\" \"$FW\"\n\tif ! diff -q \"$FW\" /dev/test_firmware >/dev/null ; then\n\t\techo \"$0: firmware was not loaded\" >&2\n\t\texit 1\n\telse\n\t\techo \"$0: fallback mechanism works\"\n\tfi\n\n\tload_fw_cancel \"nope-$NAME\" \"$FW\"\n\tif diff -q \"$FW\" /dev/test_firmware >/dev/null ; then\n\t\techo \"$0: firmware was expected to be cancelled\" >&2\n\t\texit 1\n\telse\n\t\techo \"$0: cancelling fallback mechanism works\"\n\tfi\n\n\tset +e\n\tload_fw_fallback_with_child \"nope-signal-$NAME\" \"$FW\"\n\tif [ \"$?\" -eq 0 ]; then\n\t\techo \"$0: SIGCHLD on sync ignored as expected\" >&2\n\telse\n\t\techo \"$0: error - sync firmware request cancelled due to SIGCHLD\" >&2\n\t\texit 1\n\tfi\n\tset -e\n}\n\nrun_sysfs_custom_load_tests()\n{\n\tRANDOM_FILE_PATH=$(setup_random_file)\n\tRANDOM_FILE=\"$(basename $RANDOM_FILE_PATH)\"\n\tif load_fw_custom \"$RANDOM_FILE\" \"$RANDOM_FILE_PATH\" ; then\n\t\tif ! diff -q \"$RANDOM_FILE_PATH\" /dev/test_firmware >/dev/null ; then\n\t\t\techo \"$0: firmware was not loaded\" >&2\n\t\t\texit 1\n\t\telse\n\t\t\techo \"$0: custom fallback loading mechanism works\"\n\t\tfi\n\tfi\n\n\tRANDOM_FILE_PATH=$(setup_random_file)\n\tRANDOM_FILE=\"$(basename $RANDOM_FILE_PATH)\"\n\tif load_fw_custom \"$RANDOM_FILE\" \"$RANDOM_FILE_PATH\" ; then\n\t\tif ! diff -q \"$RANDOM_FILE_PATH\" /dev/test_firmware >/dev/null ; then\n\t\t\techo \"$0: firmware was not loaded\" >&2\n\t\t\texit 1\n\t\telse\n\t\t\techo \"$0: custom fallback loading mechanism works\"\n\t\tfi\n\tfi\n\n\tRANDOM_FILE_REAL=\"$RANDOM_FILE_PATH\"\n\tFAKE_RANDOM_FILE_PATH=$(setup_random_file_fake)\n\tFAKE_RANDOM_FILE=\"$(basename $FAKE_RANDOM_FILE_PATH)\"\n\n\tif load_fw_custom_cancel \"$FAKE_RANDOM_FILE\" \"$RANDOM_FILE_REAL\" ; then\n\t\tif diff -q \"$RANDOM_FILE_PATH\" /dev/test_firmware >/dev/null ; then\n\t\t\techo \"$0: firmware was expected to be cancelled\" >&2\n\t\t\texit 1\n\t\telse\n\t\t\techo \"$0: cancelling custom fallback mechanism works\"\n\t\tfi\n\tfi\n}\n\nif [ \"$HAS_FW_LOADER_USER_HELPER_FALLBACK\" = \"yes\" ]; then\n\trun_sysfs_main_tests\nfi\n\nrun_sysfs_custom_load_tests\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}