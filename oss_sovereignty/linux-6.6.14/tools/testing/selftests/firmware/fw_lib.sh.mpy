{
  "module_name": "fw_lib.sh",
  "hash_id": "2a645444522cb20454c4c4a5d9a0c58417ccd91cffb6da67af201686efbaf3e8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/firmware/fw_lib.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# Library of helpers for test scripts.\nset -e\n\nDIR=/sys/devices/virtual/misc/test_firmware\n\nPROC_CONFIG=\"/proc/config.gz\"\nTEST_DIR=$(dirname $0)\n\n# We need to load a different file to test request_firmware_into_buf\n# I believe the issue is firmware loaded cached vs. non-cached\n# with same filename is bungled.\n# To reproduce rename this to test-firmware.bin\nTEST_FIRMWARE_INTO_BUF_FILENAME=test-firmware-into-buf.bin\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\nprint_reqs_exit()\n{\n\techo \"You must have the following enabled in your kernel:\" >&2\n\tcat $TEST_DIR/config >&2\n\texit $ksft_skip\n}\n\ntest_modprobe()\n{\n\tif [ ! -d $DIR ]; then\n\t\tprint_reqs_exit\n\tfi\n}\n\ncheck_mods()\n{\n\tlocal uid=$(id -u)\n\tif [ $uid -ne 0 ]; then\n\t\techo \"skip all tests: must be run as root\" >&2\n\t\texit $ksft_skip\n\tfi\n\n\ttrap \"test_modprobe\" EXIT\n\tif [ ! -d $DIR ]; then\n\t\tmodprobe test_firmware\n\tfi\n\tif [ ! -f $PROC_CONFIG ]; then\n\t\tif modprobe configs 2>/dev/null; then\n\t\t\techo \"Loaded configs module\"\n\t\t\tif [ ! -f $PROC_CONFIG ]; then\n\t\t\t\techo \"You must have the following enabled in your kernel:\" >&2\n\t\t\t\tcat $TEST_DIR/config >&2\n\t\t\t\techo \"Resorting to old heuristics\" >&2\n\t\t\tfi\n\t\telse\n\t\t\techo \"Failed to load configs module, using old heuristics\" >&2\n\t\tfi\n\tfi\n}\n\ncheck_setup()\n{\n\tHAS_FW_LOADER_USER_HELPER=\"$(kconfig_has CONFIG_FW_LOADER_USER_HELPER=y)\"\n\tHAS_FW_LOADER_USER_HELPER_FALLBACK=\"$(kconfig_has CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y)\"\n\tHAS_FW_LOADER_COMPRESS_XZ=\"$(kconfig_has CONFIG_FW_LOADER_COMPRESS_XZ=y)\"\n\tHAS_FW_LOADER_COMPRESS_ZSTD=\"$(kconfig_has CONFIG_FW_LOADER_COMPRESS_ZSTD=y)\"\n\tHAS_FW_UPLOAD=\"$(kconfig_has CONFIG_FW_UPLOAD=y)\"\n\tPROC_FW_IGNORE_SYSFS_FALLBACK=\"0\"\n\tPROC_FW_FORCE_SYSFS_FALLBACK=\"0\"\n\n\tif [ -z $PROC_SYS_DIR ]; then\n\t\tPROC_SYS_DIR=\"/proc/sys/kernel\"\n\tfi\n\n\tFW_PROC=\"${PROC_SYS_DIR}/firmware_config\"\n\tFW_FORCE_SYSFS_FALLBACK=\"$FW_PROC/force_sysfs_fallback\"\n\tFW_IGNORE_SYSFS_FALLBACK=\"$FW_PROC/ignore_sysfs_fallback\"\n\n\tif [ -f $FW_FORCE_SYSFS_FALLBACK ]; then\n\t\tPROC_FW_FORCE_SYSFS_FALLBACK=\"$(cat $FW_FORCE_SYSFS_FALLBACK)\"\n\tfi\n\n\tif [ -f $FW_IGNORE_SYSFS_FALLBACK ]; then\n\t\tPROC_FW_IGNORE_SYSFS_FALLBACK=\"$(cat $FW_IGNORE_SYSFS_FALLBACK)\"\n\tfi\n\n\tif [ \"$PROC_FW_FORCE_SYSFS_FALLBACK\" = \"1\" ]; then\n\t\tHAS_FW_LOADER_USER_HELPER=\"yes\"\n\t\tHAS_FW_LOADER_USER_HELPER_FALLBACK=\"yes\"\n\tfi\n\n\tif [ \"$PROC_FW_IGNORE_SYSFS_FALLBACK\" = \"1\" ]; then\n\t\tHAS_FW_LOADER_USER_HELPER_FALLBACK=\"no\"\n\t\tHAS_FW_LOADER_USER_HELPER=\"no\"\n\tfi\n\n\tif [ \"$HAS_FW_LOADER_USER_HELPER\" = \"yes\" ]; then\n\t       OLD_TIMEOUT=\"$(cat /sys/class/firmware/timeout)\"\n\tfi\n\n\tOLD_FWPATH=\"$(cat /sys/module/firmware_class/parameters/path)\"\n\n\tif [ \"$HAS_FW_LOADER_COMPRESS_XZ\" = \"yes\" ]; then\n\t\tif ! which xz 2> /dev/null > /dev/null; then\n\t\t\tHAS_FW_LOADER_COMPRESS_XZ=\"\"\n\t\tfi\n\tfi\n\tif [ \"$HAS_FW_LOADER_COMPRESS_ZSTD\" = \"yes\" ]; then\n\t\tif ! which zstd 2> /dev/null > /dev/null; then\n\t\t\tHAS_FW_LOADER_COMPRESS_ZSTD=\"\"\n\t\tfi\n\tfi\n}\n\nverify_reqs()\n{\n\tif [ \"$TEST_REQS_FW_SYSFS_FALLBACK\" = \"yes\" ]; then\n\t\tif [ ! \"$HAS_FW_LOADER_USER_HELPER\" = \"yes\" ]; then\n\t\t\techo \"usermode helper disabled so ignoring test\"\n\t\t\texit 0\n\t\tfi\n\tfi\n\tif [ \"$TEST_REQS_FW_UPLOAD\" = \"yes\" ]; then\n\t\tif [ ! \"$HAS_FW_UPLOAD\" = \"yes\" ]; then\n\t\t\techo \"firmware upload disabled so ignoring test\"\n\t\t\texit 0\n\t\tfi\n\tfi\n}\n\nsetup_tmp_file()\n{\n\tFWPATH=$(mktemp -d)\n\tFW=\"$FWPATH/test-firmware.bin\"\n\techo \"ABCD0123\" >\"$FW\"\n\tFW_INTO_BUF=\"$FWPATH/$TEST_FIRMWARE_INTO_BUF_FILENAME\"\n\techo \"EFGH4567\" >\"$FW_INTO_BUF\"\n\tNAME=$(basename \"$FW\")\n\tif [ \"$TEST_REQS_FW_SET_CUSTOM_PATH\" = \"yes\" ]; then\n\t\techo -n \"$FWPATH\" >/sys/module/firmware_class/parameters/path\n\tfi\n}\n\n__setup_random_file()\n{\n\tRANDOM_FILE_PATH=\"$(mktemp -p $FWPATH)\"\n\t# mktemp says dry-run -n is unsafe, so...\n\tif [[ \"$1\" = \"fake\" ]]; then\n\t\trm -rf $RANDOM_FILE_PATH\n\t\tsync\n\telse\n\t\techo \"ABCD0123\" >\"$RANDOM_FILE_PATH\"\n\tfi\n\techo $RANDOM_FILE_PATH\n}\n\nsetup_random_file()\n{\n\techo $(__setup_random_file)\n}\n\nsetup_random_file_fake()\n{\n\techo $(__setup_random_file fake)\n}\n\nproc_set_force_sysfs_fallback()\n{\n\tif [ -f $FW_FORCE_SYSFS_FALLBACK ]; then\n\t\techo -n $1 > $FW_FORCE_SYSFS_FALLBACK\n\t\tcheck_setup\n\tfi\n}\n\nproc_set_ignore_sysfs_fallback()\n{\n\tif [ -f $FW_IGNORE_SYSFS_FALLBACK ]; then\n\t\techo -n $1 > $FW_IGNORE_SYSFS_FALLBACK\n\t\tcheck_setup\n\tfi\n}\n\nproc_restore_defaults()\n{\n\tproc_set_force_sysfs_fallback 0\n\tproc_set_ignore_sysfs_fallback 0\n}\n\ntest_finish()\n{\n\tif [ \"$HAS_FW_LOADER_USER_HELPER\" = \"yes\" ]; then\n\t\techo \"$OLD_TIMEOUT\" >/sys/class/firmware/timeout\n\tfi\n\tif [ \"$TEST_REQS_FW_SET_CUSTOM_PATH\" = \"yes\" ]; then\n\t\tif [ \"$OLD_FWPATH\" = \"\" ]; then\n\t\t\t# A zero-length write won't work; write a null byte\n\t\t\tprintf '\\000' >/sys/module/firmware_class/parameters/path\n\t\telse\n\t\t\techo -n \"$OLD_FWPATH\" >/sys/module/firmware_class/parameters/path\n\t\tfi\n\tfi\n\tif [ -f $FW ]; then\n\t\trm -f \"$FW\"\n\tfi\n\tif [ -f $FW_INTO_BUF ]; then\n\t\trm -f \"$FW_INTO_BUF\"\n\tfi\n\tif [ -d $FWPATH ]; then\n\t\trm -rf \"$FWPATH\"\n\tfi\n\tproc_restore_defaults\n}\n\nkconfig_has()\n{\n\tif [ -f $PROC_CONFIG ]; then\n\t\tif zgrep -q $1 $PROC_CONFIG 2>/dev/null; then\n\t\t\techo \"yes\"\n\t\telse\n\t\t\techo \"no\"\n\t\tfi\n\telse\n\t\t# We currently don't have easy heuristics to infer this\n\t\t# so best we can do is just try to use the kernel assuming\n\t\t# you had enabled it. This matches the old behaviour.\n\t\tif [ \"$1\" = \"CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y\" ]; then\n\t\t\techo \"yes\"\n\t\telif [ \"$1\" = \"CONFIG_FW_LOADER_USER_HELPER=y\" ]; then\n\t\t\tif [ -d /sys/class/firmware/ ]; then\n\t\t\t\techo yes\n\t\t\telse\n\t\t\t\techo no\n\t\t\tfi\n\t\tfi\n\tfi\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}