{
  "module_name": "fw_filesystem.sh",
  "hash_id": "f95d354bbec747e93a473cc655f00824be49f0fa4ccaa154ab36b6a3fe3447de",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/firmware/fw_filesystem.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# This validates that the kernel will load firmware out of its list of\n# firmware locations on disk. Since the user helper does similar work,\n# we reset the custom load directory to a location the user helper doesn't\n# know so we can be sure we're not accidentally testing the user helper.\nset -e\n\nTEST_REQS_FW_SYSFS_FALLBACK=\"no\"\nTEST_REQS_FW_SET_CUSTOM_PATH=\"yes\"\nTEST_DIR=$(dirname $0)\nsource $TEST_DIR/fw_lib.sh\n\nRUN_XZ=\"xz -C crc32 --lzma2=dict=2MiB\"\nRUN_ZSTD=\"zstd -q\"\n\ncheck_mods\ncheck_setup\nverify_reqs\nsetup_tmp_file\n\ntrap \"test_finish\" EXIT\n\nif [ \"$HAS_FW_LOADER_USER_HELPER\" = \"yes\" ]; then\n\t# Turn down the timeout so failures don't take so long.\n\techo 1 >/sys/class/firmware/timeout\nfi\n\nif printf '\\000' >\"$DIR\"/trigger_request 2> /dev/null; then\n\techo \"$0: empty filename should not succeed\" >&2\n\texit 1\nfi\n\nif [ ! -e \"$DIR\"/trigger_async_request ]; then\n\techo \"$0: empty filename: async trigger not present, ignoring test\" >&2\n\texit $ksft_skip\nelse\n\tif printf '\\000' >\"$DIR\"/trigger_async_request 2> /dev/null; then\n\t\techo \"$0: empty filename should not succeed (async)\" >&2\n\t\texit 1\n\tfi\nfi\n\n# Request a firmware that doesn't exist, it should fail.\nif echo -n \"nope-$NAME\" >\"$DIR\"/trigger_request 2> /dev/null; then\n\techo \"$0: firmware shouldn't have loaded\" >&2\n\texit 1\nfi\nif diff -q \"$FW\" /dev/test_firmware >/dev/null ; then\n\techo \"$0: firmware was not expected to match\" >&2\n\texit 1\nelse\n\tif [ \"$HAS_FW_LOADER_USER_HELPER\" = \"yes\" ]; then\n\t\techo \"$0: timeout works\"\n\tfi\nfi\n\n# This should succeed via kernel load or will fail after 1 second after\n# being handed over to the user helper, which won't find the fw either.\nif ! echo -n \"$NAME\" >\"$DIR\"/trigger_request ; then\n\techo \"$0: could not trigger request\" >&2\n\texit 1\nfi\n\n# Verify the contents are what we expect.\nif ! diff -q \"$FW\" /dev/test_firmware >/dev/null ; then\n\techo \"$0: firmware was not loaded\" >&2\n\texit 1\nelse\n\techo \"$0: filesystem loading works\"\nfi\n\n# Try the asynchronous version too\nif [ ! -e \"$DIR\"/trigger_async_request ]; then\n\techo \"$0: firmware loading: async trigger not present, ignoring test\" >&2\n\texit $ksft_skip\nelse\n\tif ! echo -n \"$NAME\" >\"$DIR\"/trigger_async_request ; then\n\t\techo \"$0: could not trigger async request\" >&2\n\t\texit 1\n\tfi\n\n\t# Verify the contents are what we expect.\n\tif ! diff -q \"$FW\" /dev/test_firmware >/dev/null ; then\n\t\techo \"$0: firmware was not loaded (async)\" >&2\n\t\texit 1\n\telse\n\t\techo \"$0: async filesystem loading works\"\n\tfi\nfi\n\n# Try platform (EFI embedded fw) loading too\nif [ ! -e \"$DIR\"/trigger_request_platform ]; then\n\techo \"$0: firmware loading: platform trigger not present, ignoring test\" >&2\nelse\n\tif printf '\\000' >\"$DIR\"/trigger_request_platform 2> /dev/null; then\n\t\techo \"$0: empty filename should not succeed (platform)\" >&2\n\t\texit 1\n\tfi\n\n\t# Note we echo a non-existing name, since files on the file-system\n\t# are preferred over firmware embedded inside the platform's firmware\n\t# The test adds a fake entry with the requested name to the platform's\n\t# fw list, so the name does not matter as long as it does not exist\n\tif ! echo -n \"nope-$NAME\" >\"$DIR\"/trigger_request_platform ; then\n\t\techo \"$0: could not trigger request platform\" >&2\n\t\texit 1\n\tfi\n\n\t# The test verifies itself that the loaded firmware contents matches\n\t# the contents for the fake platform fw entry it added.\n\techo \"$0: platform loading works\"\nfi\n\n### Batched requests tests\ntest_config_present()\n{\n\tif [ ! -f $DIR/reset ]; then\n\t\techo \"Configuration triggers not present, ignoring test\"\n\t\texit $ksft_skip\n\tfi\n}\n\n# Defaults :\n#\n# send_uevent: 1\n# sync_direct: 0\n# name: test-firmware.bin\n# num_requests: 4\nconfig_reset()\n{\n\techo 1 >  $DIR/reset\n}\n\nrelease_all_firmware()\n{\n\techo 1 >  $DIR/release_all_firmware\n}\n\nconfig_set_name()\n{\n\techo -n $1 >  $DIR/config_name\n}\n\nconfig_set_into_buf()\n{\n\techo 1 >  $DIR/config_into_buf\n}\n\nconfig_unset_into_buf()\n{\n\techo 0 >  $DIR/config_into_buf\n}\n\nconfig_set_buf_size()\n{\n\techo $1 >  $DIR/config_buf_size\n}\n\nconfig_set_file_offset()\n{\n\techo $1 >  $DIR/config_file_offset\n}\n\nconfig_set_partial()\n{\n\techo 1 >  $DIR/config_partial\n}\n\nconfig_unset_partial()\n{\n\techo 0 >  $DIR/config_partial\n}\n\nconfig_set_sync_direct()\n{\n\techo 1 >  $DIR/config_sync_direct\n}\n\nconfig_unset_sync_direct()\n{\n\techo 0 >  $DIR/config_sync_direct\n}\n\nconfig_set_uevent()\n{\n\techo 1 >  $DIR/config_send_uevent\n}\n\nconfig_unset_uevent()\n{\n\techo 0 >  $DIR/config_send_uevent\n}\n\nconfig_trigger_sync()\n{\n\techo -n 1 > $DIR/trigger_batched_requests 2>/dev/null\n}\n\nconfig_trigger_async()\n{\n\techo -n 1 > $DIR/trigger_batched_requests_async 2> /dev/null\n}\n\nconfig_set_read_fw_idx()\n{\n\techo -n $1 > $DIR/config_read_fw_idx 2> /dev/null\n}\n\nread_firmwares()\n{\n\tif [ \"$(cat $DIR/config_into_buf)\" == \"1\" ]; then\n\t\tfwfile=\"$FW_INTO_BUF\"\n\telse\n\t\tfwfile=\"$FW\"\n\tfi\n\tif [ \"$1\" = \"componly\" ]; then\n\t\tfwfile=\"${fwfile}-orig\"\n\tfi\n\tfor i in $(seq 0 3); do\n\t\tconfig_set_read_fw_idx $i\n\t\t# Verify the contents are what we expect.\n\t\t# -Z required for now -- check for yourself, md5sum\n\t\t# on $FW and DIR/read_firmware will yield the same. Even\n\t\t# cmp agrees, so something is off.\n\t\tif ! diff -q -Z \"$fwfile\" $DIR/read_firmware 2>/dev/null ; then\n\t\t\techo \"request #$i: firmware was not loaded\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n}\n\nread_partial_firmwares()\n{\n\tif [ \"$(cat $DIR/config_into_buf)\" == \"1\" ]; then\n\t\tfwfile=\"${FW_INTO_BUF}\"\n\telse\n\t\tfwfile=\"${FW}\"\n\tfi\n\n\tif [ \"$1\" = \"componly\" ]; then\n\t\tfwfile=\"${fwfile}-orig\"\n\tfi\n\n\t# Strip fwfile down to match partial offset and length\n\tpartial_data=\"$(cat $fwfile)\"\n\tpartial_data=\"${partial_data:$2:$3}\"\n\n\tfor i in $(seq 0 3); do\n\t\tconfig_set_read_fw_idx $i\n\n\t\tread_firmware=\"$(cat $DIR/read_firmware)\"\n\n\t\t# Verify the contents are what we expect.\n\t\tif [ $read_firmware != $partial_data ]; then\n\t\t\techo \"request #$i: partial firmware was not loaded\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n}\n\nread_firmwares_expect_nofile()\n{\n\tfor i in $(seq 0 3); do\n\t\tconfig_set_read_fw_idx $i\n\t\t# Ensures contents differ\n\t\tif diff -q -Z \"$FW\" $DIR/read_firmware 2>/dev/null ; then\n\t\t\techo \"request $i: file was not expected to match\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n}\n\ntest_batched_request_firmware_nofile()\n{\n\techo -n \"Batched request_firmware() nofile try #$1: \"\n\tconfig_reset\n\tconfig_set_name nope-test-firmware.bin\n\tconfig_trigger_sync\n\tread_firmwares_expect_nofile\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_batched_request_firmware_into_buf_nofile()\n{\n\techo -n \"Batched request_firmware_into_buf() nofile try #$1: \"\n\tconfig_reset\n\tconfig_set_name nope-test-firmware.bin\n\tconfig_set_into_buf\n\tconfig_trigger_sync\n\tread_firmwares_expect_nofile\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_request_partial_firmware_into_buf_nofile()\n{\n\techo -n \"Test request_partial_firmware_into_buf() off=$1 size=$2 nofile: \"\n\tconfig_reset\n\tconfig_set_name nope-test-firmware.bin\n\tconfig_set_into_buf\n\tconfig_set_partial\n\tconfig_set_buf_size $2\n\tconfig_set_file_offset $1\n\tconfig_trigger_sync\n\tread_firmwares_expect_nofile\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_batched_request_firmware_direct_nofile()\n{\n\techo -n \"Batched request_firmware_direct() nofile try #$1: \"\n\tconfig_reset\n\tconfig_set_name nope-test-firmware.bin\n\tconfig_set_sync_direct\n\tconfig_trigger_sync\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_request_firmware_nowait_uevent_nofile()\n{\n\techo -n \"Batched request_firmware_nowait(uevent=true) nofile try #$1: \"\n\tconfig_reset\n\tconfig_set_name nope-test-firmware.bin\n\tconfig_trigger_async\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_wait_and_cancel_custom_load()\n{\n\tif [ \"$HAS_FW_LOADER_USER_HELPER\" != \"yes\" ]; then\n\t\treturn\n\tfi\n\tlocal timeout=10\n\tname=$1\n\twhile [ ! -e \"$DIR\"/\"$name\"/loading ]; do\n\t\tsleep 0.1\n\t\ttimeout=$(( $timeout - 1 ))\n\t\tif [ \"$timeout\" -eq 0 ]; then\n\t\t\techo \"firmware interface never appeared:\" >&2\n\t\t\techo \"$DIR/$name/loading\" >&2\n\t\t\texit 1\n\t\tfi\n\tdone\n\techo -1 >\"$DIR\"/\"$name\"/loading\n}\n\ntest_request_firmware_nowait_custom_nofile()\n{\n\techo -n \"Batched request_firmware_nowait(uevent=false) nofile try #$1: \"\n\tconfig_reset\n\tconfig_unset_uevent\n\tRANDOM_FILE_PATH=$(setup_random_file_fake)\n\tRANDOM_FILE=\"$(basename $RANDOM_FILE_PATH)\"\n\tconfig_set_name $RANDOM_FILE\n\tconfig_trigger_async &\n\ttest_wait_and_cancel_custom_load $RANDOM_FILE\n\twait\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_batched_request_firmware()\n{\n\techo -n \"Batched request_firmware() $2 try #$1: \"\n\tconfig_reset\n\tconfig_trigger_sync\n\tread_firmwares $2\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_batched_request_firmware_into_buf()\n{\n\techo -n \"Batched request_firmware_into_buf() $2 try #$1: \"\n\tconfig_reset\n\tconfig_set_name $TEST_FIRMWARE_INTO_BUF_FILENAME\n\tconfig_set_into_buf\n\tconfig_trigger_sync\n\tread_firmwares $2\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_batched_request_firmware_direct()\n{\n\techo -n \"Batched request_firmware_direct() $2 try #$1: \"\n\tconfig_reset\n\tconfig_set_sync_direct\n\tconfig_trigger_sync\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_request_firmware_nowait_uevent()\n{\n\techo -n \"Batched request_firmware_nowait(uevent=true) $2 try #$1: \"\n\tconfig_reset\n\tconfig_trigger_async\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_request_firmware_nowait_custom()\n{\n\techo -n \"Batched request_firmware_nowait(uevent=false) $2 try #$1: \"\n\tconfig_reset\n\tconfig_unset_uevent\n\tRANDOM_FILE_PATH=$(setup_random_file)\n\tRANDOM_FILE=\"$(basename $RANDOM_FILE_PATH)\"\n\tif [ -n \"$2\" -a \"$2\" != \"normal\" ]; then\n\t\tcompress_\"$2\"_\"$COMPRESS_FORMAT\" $RANDOM_FILE_PATH\n\tfi\n\tconfig_set_name $RANDOM_FILE\n\tconfig_trigger_async\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ntest_request_partial_firmware_into_buf()\n{\n\techo -n \"Test request_partial_firmware_into_buf() off=$1 size=$2: \"\n\tconfig_reset\n\tconfig_set_name $TEST_FIRMWARE_INTO_BUF_FILENAME\n\tconfig_set_into_buf\n\tconfig_set_partial\n\tconfig_set_buf_size $2\n\tconfig_set_file_offset $1\n\tconfig_trigger_sync\n\tread_partial_firmwares normal $1 $2\n\trelease_all_firmware\n\techo \"OK\"\n}\n\ndo_tests ()\n{\n\tmode=\"$1\"\n\tsuffix=\"$2\"\n\n\tfor i in $(seq 1 5); do\n\t\ttest_batched_request_firmware$suffix $i $mode\n\tdone\n\n\tfor i in $(seq 1 5); do\n\t\ttest_batched_request_firmware_into_buf$suffix $i $mode\n\tdone\n\n\tfor i in $(seq 1 5); do\n\t\ttest_batched_request_firmware_direct$suffix $i $mode\n\tdone\n\n\tfor i in $(seq 1 5); do\n\t\ttest_request_firmware_nowait_uevent$suffix $i $mode\n\tdone\n\n\tfor i in $(seq 1 5); do\n\t\ttest_request_firmware_nowait_custom$suffix $i $mode\n\tdone\n}\n\n# Only continue if batched request triggers are present on the\n# test-firmware driver\ntest_config_present\n\n# test with the file present\necho\necho \"Testing with the file present...\"\ndo_tests normal\n\n# Partial loads cannot use fallback, so do not repeat tests.\ntest_request_partial_firmware_into_buf 0 10\ntest_request_partial_firmware_into_buf 0 5\ntest_request_partial_firmware_into_buf 1 6\ntest_request_partial_firmware_into_buf 2 10\n\n# Test for file not found, errors are expected, the failure would be\n# a hung task, which would require a hard reset.\necho\necho \"Testing with the file missing...\"\ndo_tests nofile _nofile\n\n# Partial loads cannot use fallback, so do not repeat tests.\ntest_request_partial_firmware_into_buf_nofile 0 10\ntest_request_partial_firmware_into_buf_nofile 0 5\ntest_request_partial_firmware_into_buf_nofile 1 6\ntest_request_partial_firmware_into_buf_nofile 2 10\n\ntest_request_firmware_compressed ()\n{\n\texport COMPRESS_FORMAT=\"$1\"\n\n\t# test with both files present\n\tcompress_both_\"$COMPRESS_FORMAT\" $FW\n\tcompress_both_\"$COMPRESS_FORMAT\" $FW_INTO_BUF\n\n\tconfig_set_name $NAME\n\techo\n\techo \"Testing with both plain and $COMPRESS_FORMAT files present...\"\n\tdo_tests both\n\n\t# test with only compressed file present\n\tmv \"$FW\" \"${FW}-orig\"\n\tmv \"$FW_INTO_BUF\" \"${FW_INTO_BUF}-orig\"\n\n\tconfig_set_name $NAME\n\techo\n\techo \"Testing with only $COMPRESS_FORMAT file present...\"\n\tdo_tests componly\n\n\tmv \"${FW}-orig\" \"$FW\"\n\tmv \"${FW_INTO_BUF}-orig\" \"$FW_INTO_BUF\"\n}\n\ncompress_both_XZ ()\n{\n\t$RUN_XZ -k \"$@\"\n}\n\ncompress_componly_XZ ()\n{\n\t$RUN_XZ \"$@\"\n}\n\ncompress_both_ZSTD ()\n{\n\t$RUN_ZSTD -k \"$@\"\n}\n\ncompress_componly_ZSTD ()\n{\n\t$RUN_ZSTD --rm \"$@\"\n}\n\nif test \"$HAS_FW_LOADER_COMPRESS_XZ\" = \"yes\"; then\n\ttest_request_firmware_compressed XZ\nfi\n\nif test \"$HAS_FW_LOADER_COMPRESS_ZSTD\" = \"yes\"; then\n\ttest_request_firmware_compressed ZSTD\nfi\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}