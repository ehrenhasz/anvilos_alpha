{
  "module_name": "tpm2.py",
  "hash_id": "8571a6f6441a73e939a08b37db9df05f28c8f05e7fdb0cfd3ea8dda04fbf5242",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/tpm2/tpm2.py",
  "human_readable_source": "# SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)\n\nimport hashlib\nimport os\nimport socket\nimport struct\nimport sys\nimport unittest\nimport fcntl\nimport select\n\nTPM2_ST_NO_SESSIONS = 0x8001\nTPM2_ST_SESSIONS = 0x8002\n\nTPM2_CC_FIRST = 0x01FF\n\nTPM2_CC_CREATE_PRIMARY = 0x0131\nTPM2_CC_DICTIONARY_ATTACK_LOCK_RESET = 0x0139\nTPM2_CC_CREATE = 0x0153\nTPM2_CC_LOAD = 0x0157\nTPM2_CC_UNSEAL = 0x015E\nTPM2_CC_FLUSH_CONTEXT = 0x0165\nTPM2_CC_START_AUTH_SESSION = 0x0176\nTPM2_CC_GET_CAPABILITY\t= 0x017A\nTPM2_CC_GET_RANDOM = 0x017B\nTPM2_CC_PCR_READ = 0x017E\nTPM2_CC_POLICY_PCR = 0x017F\nTPM2_CC_PCR_EXTEND = 0x0182\nTPM2_CC_POLICY_PASSWORD = 0x018C\nTPM2_CC_POLICY_GET_DIGEST = 0x0189\n\nTPM2_SE_POLICY = 0x01\nTPM2_SE_TRIAL = 0x03\n\nTPM2_ALG_RSA = 0x0001\nTPM2_ALG_SHA1 = 0x0004\nTPM2_ALG_AES = 0x0006\nTPM2_ALG_KEYEDHASH = 0x0008\nTPM2_ALG_SHA256 = 0x000B\nTPM2_ALG_NULL = 0x0010\nTPM2_ALG_CBC = 0x0042\nTPM2_ALG_CFB = 0x0043\n\nTPM2_RH_OWNER = 0x40000001\nTPM2_RH_NULL = 0x40000007\nTPM2_RH_LOCKOUT = 0x4000000A\nTPM2_RS_PW = 0x40000009\n\nTPM2_RC_SIZE            = 0x01D5\nTPM2_RC_AUTH_FAIL       = 0x098E\nTPM2_RC_POLICY_FAIL     = 0x099D\nTPM2_RC_COMMAND_CODE    = 0x0143\n\nTSS2_RC_LAYER_SHIFT = 16\nTSS2_RESMGR_TPM_RC_LAYER = (11 << TSS2_RC_LAYER_SHIFT)\n\nTPM2_CAP_HANDLES = 0x00000001\nTPM2_CAP_COMMANDS = 0x00000002\nTPM2_CAP_PCRS = 0x00000005\nTPM2_CAP_TPM_PROPERTIES = 0x00000006\n\nTPM2_PT_FIXED = 0x100\nTPM2_PT_TOTAL_COMMANDS = TPM2_PT_FIXED + 41\n\nHR_SHIFT = 24\nHR_LOADED_SESSION = 0x02000000\nHR_TRANSIENT = 0x80000000\n\nSHA1_DIGEST_SIZE = 20\nSHA256_DIGEST_SIZE = 32\n\nTPM2_VER0_ERRORS = {\n    0x000: \"TPM_RC_SUCCESS\",\n    0x030: \"TPM_RC_BAD_TAG\",\n}\n\nTPM2_VER1_ERRORS = {\n    0x000: \"TPM_RC_FAILURE\",\n    0x001: \"TPM_RC_FAILURE\",\n    0x003: \"TPM_RC_SEQUENCE\",\n    0x00B: \"TPM_RC_PRIVATE\",\n    0x019: \"TPM_RC_HMAC\",\n    0x020: \"TPM_RC_DISABLED\",\n    0x021: \"TPM_RC_EXCLUSIVE\",\n    0x024: \"TPM_RC_AUTH_TYPE\",\n    0x025: \"TPM_RC_AUTH_MISSING\",\n    0x026: \"TPM_RC_POLICY\",\n    0x027: \"TPM_RC_PCR\",\n    0x028: \"TPM_RC_PCR_CHANGED\",\n    0x02D: \"TPM_RC_UPGRADE\",\n    0x02E: \"TPM_RC_TOO_MANY_CONTEXTS\",\n    0x02F: \"TPM_RC_AUTH_UNAVAILABLE\",\n    0x030: \"TPM_RC_REBOOT\",\n    0x031: \"TPM_RC_UNBALANCED\",\n    0x042: \"TPM_RC_COMMAND_SIZE\",\n    0x043: \"TPM_RC_COMMAND_CODE\",\n    0x044: \"TPM_RC_AUTHSIZE\",\n    0x045: \"TPM_RC_AUTH_CONTEXT\",\n    0x046: \"TPM_RC_NV_RANGE\",\n    0x047: \"TPM_RC_NV_SIZE\",\n    0x048: \"TPM_RC_NV_LOCKED\",\n    0x049: \"TPM_RC_NV_AUTHORIZATION\",\n    0x04A: \"TPM_RC_NV_UNINITIALIZED\",\n    0x04B: \"TPM_RC_NV_SPACE\",\n    0x04C: \"TPM_RC_NV_DEFINED\",\n    0x050: \"TPM_RC_BAD_CONTEXT\",\n    0x051: \"TPM_RC_CPHASH\",\n    0x052: \"TPM_RC_PARENT\",\n    0x053: \"TPM_RC_NEEDS_TEST\",\n    0x054: \"TPM_RC_NO_RESULT\",\n    0x055: \"TPM_RC_SENSITIVE\",\n    0x07F: \"RC_MAX_FM0\",\n}\n\nTPM2_FMT1_ERRORS = {\n    0x001: \"TPM_RC_ASYMMETRIC\",\n    0x002: \"TPM_RC_ATTRIBUTES\",\n    0x003: \"TPM_RC_HASH\",\n    0x004: \"TPM_RC_VALUE\",\n    0x005: \"TPM_RC_HIERARCHY\",\n    0x007: \"TPM_RC_KEY_SIZE\",\n    0x008: \"TPM_RC_MGF\",\n    0x009: \"TPM_RC_MODE\",\n    0x00A: \"TPM_RC_TYPE\",\n    0x00B: \"TPM_RC_HANDLE\",\n    0x00C: \"TPM_RC_KDF\",\n    0x00D: \"TPM_RC_RANGE\",\n    0x00E: \"TPM_RC_AUTH_FAIL\",\n    0x00F: \"TPM_RC_NONCE\",\n    0x010: \"TPM_RC_PP\",\n    0x012: \"TPM_RC_SCHEME\",\n    0x015: \"TPM_RC_SIZE\",\n    0x016: \"TPM_RC_SYMMETRIC\",\n    0x017: \"TPM_RC_TAG\",\n    0x018: \"TPM_RC_SELECTOR\",\n    0x01A: \"TPM_RC_INSUFFICIENT\",\n    0x01B: \"TPM_RC_SIGNATURE\",\n    0x01C: \"TPM_RC_KEY\",\n    0x01D: \"TPM_RC_POLICY_FAIL\",\n    0x01F: \"TPM_RC_INTEGRITY\",\n    0x020: \"TPM_RC_TICKET\",\n    0x021: \"TPM_RC_RESERVED_BITS\",\n    0x022: \"TPM_RC_BAD_AUTH\",\n    0x023: \"TPM_RC_EXPIRED\",\n    0x024: \"TPM_RC_POLICY_CC\",\n    0x025: \"TPM_RC_BINDING\",\n    0x026: \"TPM_RC_CURVE\",\n    0x027: \"TPM_RC_ECC_POINT\",\n}\n\nTPM2_WARN_ERRORS = {\n    0x001: \"TPM_RC_CONTEXT_GAP\",\n    0x002: \"TPM_RC_OBJECT_MEMORY\",\n    0x003: \"TPM_RC_SESSION_MEMORY\",\n    0x004: \"TPM_RC_MEMORY\",\n    0x005: \"TPM_RC_SESSION_HANDLES\",\n    0x006: \"TPM_RC_OBJECT_HANDLES\",\n    0x007: \"TPM_RC_LOCALITY\",\n    0x008: \"TPM_RC_YIELDED\",\n    0x009: \"TPM_RC_CANCELED\",\n    0x00A: \"TPM_RC_TESTING\",\n    0x010: \"TPM_RC_REFERENCE_H0\",\n    0x011: \"TPM_RC_REFERENCE_H1\",\n    0x012: \"TPM_RC_REFERENCE_H2\",\n    0x013: \"TPM_RC_REFERENCE_H3\",\n    0x014: \"TPM_RC_REFERENCE_H4\",\n    0x015: \"TPM_RC_REFERENCE_H5\",\n    0x016: \"TPM_RC_REFERENCE_H6\",\n    0x018: \"TPM_RC_REFERENCE_S0\",\n    0x019: \"TPM_RC_REFERENCE_S1\",\n    0x01A: \"TPM_RC_REFERENCE_S2\",\n    0x01B: \"TPM_RC_REFERENCE_S3\",\n    0x01C: \"TPM_RC_REFERENCE_S4\",\n    0x01D: \"TPM_RC_REFERENCE_S5\",\n    0x01E: \"TPM_RC_REFERENCE_S6\",\n    0x020: \"TPM_RC_NV_RATE\",\n    0x021: \"TPM_RC_LOCKOUT\",\n    0x022: \"TPM_RC_RETRY\",\n    0x023: \"TPM_RC_NV_UNAVAILABLE\",\n    0x7F: \"TPM_RC_NOT_USED\",\n}\n\nRC_VER1 = 0x100\nRC_FMT1 = 0x080\nRC_WARN = 0x900\n\nALG_DIGEST_SIZE_MAP = {\n    TPM2_ALG_SHA1: SHA1_DIGEST_SIZE,\n    TPM2_ALG_SHA256: SHA256_DIGEST_SIZE,\n}\n\nALG_HASH_FUNCTION_MAP = {\n    TPM2_ALG_SHA1: hashlib.sha1,\n    TPM2_ALG_SHA256: hashlib.sha256\n}\n\nNAME_ALG_MAP = {\n    \"sha1\": TPM2_ALG_SHA1,\n    \"sha256\": TPM2_ALG_SHA256,\n}\n\n\nclass UnknownAlgorithmIdError(Exception):\n    def __init__(self, alg):\n        self.alg = alg\n\n    def __str__(self):\n        return '0x%0x' % (alg)\n\n\nclass UnknownAlgorithmNameError(Exception):\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return name\n\n\nclass UnknownPCRBankError(Exception):\n    def __init__(self, alg):\n        self.alg = alg\n\n    def __str__(self):\n        return '0x%0x' % (alg)\n\n\nclass ProtocolError(Exception):\n    def __init__(self, cc, rc):\n        self.cc = cc\n        self.rc = rc\n\n        if (rc & RC_FMT1) == RC_FMT1:\n            self.name = TPM2_FMT1_ERRORS.get(rc & 0x3f, \"TPM_RC_UNKNOWN\")\n        elif (rc & RC_WARN) == RC_WARN:\n            self.name = TPM2_WARN_ERRORS.get(rc & 0x7f, \"TPM_RC_UNKNOWN\")\n        elif (rc & RC_VER1) == RC_VER1:\n            self.name = TPM2_VER1_ERRORS.get(rc & 0x7f, \"TPM_RC_UNKNOWN\")\n        else:\n            self.name = TPM2_VER0_ERRORS.get(rc & 0x7f, \"TPM_RC_UNKNOWN\")\n\n    def __str__(self):\n        if self.cc:\n            return '%s: cc=0x%08x, rc=0x%08x' % (self.name, self.cc, self.rc)\n        else:\n            return '%s: rc=0x%08x' % (self.name, self.rc)\n\n\nclass AuthCommand(object):\n    \"\"\"TPMS_AUTH_COMMAND\"\"\"\n\n    def __init__(self, session_handle=TPM2_RS_PW, nonce=bytes(),\n                 session_attributes=0, hmac=bytes()):\n        self.session_handle = session_handle\n        self.nonce = nonce\n        self.session_attributes = session_attributes\n        self.hmac = hmac\n\n    def __bytes__(self):\n        fmt = '>I H%us B H%us' % (len(self.nonce), len(self.hmac))\n        return struct.pack(fmt, self.session_handle, len(self.nonce),\n                           self.nonce, self.session_attributes, len(self.hmac),\n                           self.hmac)\n\n    def __len__(self):\n        fmt = '>I H%us B H%us' % (len(self.nonce), len(self.hmac))\n        return struct.calcsize(fmt)\n\n\nclass SensitiveCreate(object):\n    \"\"\"TPMS_SENSITIVE_CREATE\"\"\"\n\n    def __init__(self, user_auth=bytes(), data=bytes()):\n        self.user_auth = user_auth\n        self.data = data\n\n    def __bytes__(self):\n        fmt = '>H%us H%us' % (len(self.user_auth), len(self.data))\n        return struct.pack(fmt, len(self.user_auth), self.user_auth,\n                           len(self.data), self.data)\n\n    def __len__(self):\n        fmt = '>H%us H%us' % (len(self.user_auth), len(self.data))\n        return struct.calcsize(fmt)\n\n\nclass Public(object):\n    \"\"\"TPMT_PUBLIC\"\"\"\n\n    FIXED_TPM = (1 << 1)\n    FIXED_PARENT = (1 << 4)\n    SENSITIVE_DATA_ORIGIN = (1 << 5)\n    USER_WITH_AUTH = (1 << 6)\n    RESTRICTED = (1 << 16)\n    DECRYPT = (1 << 17)\n\n    def __fmt(self):\n        return '>HHIH%us%usH%us' % \\\n            (len(self.auth_policy), len(self.parameters), len(self.unique))\n\n    def __init__(self, object_type, name_alg, object_attributes,\n                 auth_policy=bytes(), parameters=bytes(),\n                 unique=bytes()):\n        self.object_type = object_type\n        self.name_alg = name_alg\n        self.object_attributes = object_attributes\n        self.auth_policy = auth_policy\n        self.parameters = parameters\n        self.unique = unique\n\n    def __bytes__(self):\n        return struct.pack(self.__fmt(),\n                           self.object_type,\n                           self.name_alg,\n                           self.object_attributes,\n                           len(self.auth_policy),\n                           self.auth_policy,\n                           self.parameters,\n                           len(self.unique),\n                           self.unique)\n\n    def __len__(self):\n        return struct.calcsize(self.__fmt())\n\n\ndef get_digest_size(alg):\n    ds = ALG_DIGEST_SIZE_MAP.get(alg)\n    if not ds:\n        raise UnknownAlgorithmIdError(alg)\n    return ds\n\n\ndef get_hash_function(alg):\n    f = ALG_HASH_FUNCTION_MAP.get(alg)\n    if not f:\n        raise UnknownAlgorithmIdError(alg)\n    return f\n\n\ndef get_algorithm(name):\n    alg = NAME_ALG_MAP.get(name)\n    if not alg:\n        raise UnknownAlgorithmNameError(name)\n    return alg\n\n\ndef hex_dump(d):\n    d = [format(x, '02x') for x in d]\n    d = [d[i: i + 16] for i in range(0, len(d), 16)]\n    d = [' '.join(x) for x in d]\n    d = os.linesep.join(d)\n\n    return d\n\nclass Client:\n    FLAG_DEBUG = 0x01\n    FLAG_SPACE = 0x02\n    FLAG_NONBLOCK = 0x04\n    TPM_IOC_NEW_SPACE = 0xa200\n\n    def __init__(self, flags = 0):\n        self.flags = flags\n\n        if (self.flags & Client.FLAG_SPACE) == 0:\n            self.tpm = open('/dev/tpm0', 'r+b', buffering=0)\n        else:\n            self.tpm = open('/dev/tpmrm0', 'r+b', buffering=0)\n\n        if (self.flags & Client.FLAG_NONBLOCK):\n            flags = fcntl.fcntl(self.tpm, fcntl.F_GETFL)\n            flags |= os.O_NONBLOCK\n            fcntl.fcntl(self.tpm, fcntl.F_SETFL, flags)\n            self.tpm_poll = select.poll()\n\n    def __del__(self):\n        if self.tpm:\n            self.tpm.close()\n\n    def close(self):\n        self.tpm.close()\n\n    def send_cmd(self, cmd):\n        self.tpm.write(cmd)\n\n        if (self.flags & Client.FLAG_NONBLOCK):\n            self.tpm_poll.register(self.tpm, select.POLLIN)\n            self.tpm_poll.poll(10000)\n\n        rsp = self.tpm.read()\n\n        if (self.flags & Client.FLAG_NONBLOCK):\n            self.tpm_poll.unregister(self.tpm)\n\n        if (self.flags & Client.FLAG_DEBUG) != 0:\n            sys.stderr.write('cmd' + os.linesep)\n            sys.stderr.write(hex_dump(cmd) + os.linesep)\n            sys.stderr.write('rsp' + os.linesep)\n            sys.stderr.write(hex_dump(rsp) + os.linesep)\n\n        rc = struct.unpack('>I', rsp[6:10])[0]\n        if rc != 0:\n            cc = struct.unpack('>I', cmd[6:10])[0]\n            raise ProtocolError(cc, rc)\n\n        return rsp\n\n    def read_pcr(self, i, bank_alg = TPM2_ALG_SHA1):\n        pcrsel_len = max((i >> 3) + 1, 3)\n        pcrsel = [0] * pcrsel_len\n        pcrsel[i >> 3] = 1 << (i & 7)\n        pcrsel = ''.join(map(chr, pcrsel)).encode()\n\n        fmt = '>HII IHB%us' % (pcrsel_len)\n        cmd = struct.pack(fmt,\n                          TPM2_ST_NO_SESSIONS,\n                          struct.calcsize(fmt),\n                          TPM2_CC_PCR_READ,\n                          1,\n                          bank_alg,\n                          pcrsel_len, pcrsel)\n\n        rsp = self.send_cmd(cmd)\n\n        pcr_update_cnt, pcr_select_cnt = struct.unpack('>II', rsp[10:18])\n        assert pcr_select_cnt == 1\n        rsp = rsp[18:]\n\n        alg2, pcrsel_len2 = struct.unpack('>HB', rsp[:3])\n        assert bank_alg == alg2 and pcrsel_len == pcrsel_len2\n        rsp = rsp[3 + pcrsel_len:]\n\n        digest_cnt = struct.unpack('>I', rsp[:4])[0]\n        if digest_cnt == 0:\n            return None\n        rsp = rsp[6:]\n\n        return rsp\n\n    def extend_pcr(self, i, dig, bank_alg = TPM2_ALG_SHA1):\n        ds = get_digest_size(bank_alg)\n        assert(ds == len(dig))\n\n        auth_cmd = AuthCommand()\n\n        fmt = '>HII I I%us IH%us' % (len(auth_cmd), ds)\n        cmd = struct.pack(\n            fmt,\n            TPM2_ST_SESSIONS,\n            struct.calcsize(fmt),\n            TPM2_CC_PCR_EXTEND,\n            i,\n            len(auth_cmd),\n            bytes(auth_cmd),\n            1, bank_alg, dig)\n\n        self.send_cmd(cmd)\n\n    def start_auth_session(self, session_type, name_alg = TPM2_ALG_SHA1):\n        fmt = '>HII IIH16sHBHH'\n        cmd = struct.pack(fmt,\n                          TPM2_ST_NO_SESSIONS,\n                          struct.calcsize(fmt),\n                          TPM2_CC_START_AUTH_SESSION,\n                          TPM2_RH_NULL,\n                          TPM2_RH_NULL,\n                          16,\n                          ('\\0' * 16).encode(),\n                          0,\n                          session_type,\n                          TPM2_ALG_NULL,\n                          name_alg)\n\n        return struct.unpack('>I', self.send_cmd(cmd)[10:14])[0]\n\n    def __calc_pcr_digest(self, pcrs, bank_alg = TPM2_ALG_SHA1,\n                          digest_alg = TPM2_ALG_SHA1):\n        x = []\n        f = get_hash_function(digest_alg)\n\n        for i in pcrs:\n            pcr = self.read_pcr(i, bank_alg)\n            if pcr is None:\n                return None\n            x += pcr\n\n        return f(bytearray(x)).digest()\n\n    def policy_pcr(self, handle, pcrs, bank_alg = TPM2_ALG_SHA1,\n                   name_alg = TPM2_ALG_SHA1):\n        ds = get_digest_size(name_alg)\n        dig = self.__calc_pcr_digest(pcrs, bank_alg, name_alg)\n        if not dig:\n            raise UnknownPCRBankError(bank_alg)\n\n        pcrsel_len = max((max(pcrs) >> 3) + 1, 3)\n        pcrsel = [0] * pcrsel_len\n        for i in pcrs:\n            pcrsel[i >> 3] |= 1 << (i & 7)\n        pcrsel = ''.join(map(chr, pcrsel)).encode()\n\n        fmt = '>HII IH%usIHB3s' % ds\n        cmd = struct.pack(fmt,\n                          TPM2_ST_NO_SESSIONS,\n                          struct.calcsize(fmt),\n                          TPM2_CC_POLICY_PCR,\n                          handle,\n                          len(dig),\n                          bytes(dig),\n                          1,\n                          bank_alg,\n                          pcrsel_len, pcrsel)\n\n        self.send_cmd(cmd)\n\n    def policy_password(self, handle):\n        fmt = '>HII I'\n        cmd = struct.pack(fmt,\n                          TPM2_ST_NO_SESSIONS,\n                          struct.calcsize(fmt),\n                          TPM2_CC_POLICY_PASSWORD,\n                          handle)\n\n        self.send_cmd(cmd)\n\n    def get_policy_digest(self, handle):\n        fmt = '>HII I'\n        cmd = struct.pack(fmt,\n                          TPM2_ST_NO_SESSIONS,\n                          struct.calcsize(fmt),\n                          TPM2_CC_POLICY_GET_DIGEST,\n                          handle)\n\n        return self.send_cmd(cmd)[12:]\n\n    def flush_context(self, handle):\n        fmt = '>HIII'\n        cmd = struct.pack(fmt,\n                          TPM2_ST_NO_SESSIONS,\n                          struct.calcsize(fmt),\n                          TPM2_CC_FLUSH_CONTEXT,\n                          handle)\n\n        self.send_cmd(cmd)\n\n    def create_root_key(self, auth_value = bytes()):\n        attributes = \\\n            Public.FIXED_TPM | \\\n            Public.FIXED_PARENT | \\\n            Public.SENSITIVE_DATA_ORIGIN | \\\n            Public.USER_WITH_AUTH | \\\n            Public.RESTRICTED | \\\n            Public.DECRYPT\n\n        auth_cmd = AuthCommand()\n        sensitive = SensitiveCreate(user_auth=auth_value)\n\n        public_parms = struct.pack(\n            '>HHHHHI',\n            TPM2_ALG_AES,\n            128,\n            TPM2_ALG_CFB,\n            TPM2_ALG_NULL,\n            2048,\n            0)\n\n        public = Public(\n            object_type=TPM2_ALG_RSA,\n            name_alg=TPM2_ALG_SHA1,\n            object_attributes=attributes,\n            parameters=public_parms)\n\n        fmt = '>HIII I%us H%us H%us HI' % \\\n            (len(auth_cmd), len(sensitive), len(public))\n        cmd = struct.pack(\n            fmt,\n            TPM2_ST_SESSIONS,\n            struct.calcsize(fmt),\n            TPM2_CC_CREATE_PRIMARY,\n            TPM2_RH_OWNER,\n            len(auth_cmd),\n            bytes(auth_cmd),\n            len(sensitive),\n            bytes(sensitive),\n            len(public),\n            bytes(public),\n            0, 0)\n\n        return struct.unpack('>I', self.send_cmd(cmd)[10:14])[0]\n\n    def seal(self, parent_key, data, auth_value, policy_dig,\n             name_alg = TPM2_ALG_SHA1):\n        ds = get_digest_size(name_alg)\n        assert(not policy_dig or ds == len(policy_dig))\n\n        attributes = 0\n        if not policy_dig:\n            attributes |= Public.USER_WITH_AUTH\n            policy_dig = bytes()\n\n        auth_cmd =  AuthCommand()\n        sensitive = SensitiveCreate(user_auth=auth_value, data=data)\n\n        public = Public(\n            object_type=TPM2_ALG_KEYEDHASH,\n            name_alg=name_alg,\n            object_attributes=attributes,\n            auth_policy=policy_dig,\n            parameters=struct.pack('>H', TPM2_ALG_NULL))\n\n        fmt = '>HIII I%us H%us H%us HI' % \\\n            (len(auth_cmd), len(sensitive), len(public))\n        cmd = struct.pack(\n            fmt,\n            TPM2_ST_SESSIONS,\n            struct.calcsize(fmt),\n            TPM2_CC_CREATE,\n            parent_key,\n            len(auth_cmd),\n            bytes(auth_cmd),\n            len(sensitive),\n            bytes(sensitive),\n            len(public),\n            bytes(public),\n            0, 0)\n\n        rsp = self.send_cmd(cmd)\n\n        return rsp[14:]\n\n    def unseal(self, parent_key, blob, auth_value, policy_handle):\n        private_len = struct.unpack('>H', blob[0:2])[0]\n        public_start = private_len + 2\n        public_len = struct.unpack('>H', blob[public_start:public_start + 2])[0]\n        blob = blob[:private_len + public_len + 4]\n\n        auth_cmd = AuthCommand()\n\n        fmt = '>HII I I%us %us' % (len(auth_cmd), len(blob))\n        cmd = struct.pack(\n            fmt,\n            TPM2_ST_SESSIONS,\n            struct.calcsize(fmt),\n            TPM2_CC_LOAD,\n            parent_key,\n            len(auth_cmd),\n            bytes(auth_cmd),\n            blob)\n\n        data_handle = struct.unpack('>I', self.send_cmd(cmd)[10:14])[0]\n\n        if policy_handle:\n            auth_cmd = AuthCommand(session_handle=policy_handle, hmac=auth_value)\n        else:\n            auth_cmd = AuthCommand(hmac=auth_value)\n\n        fmt = '>HII I I%us' % (len(auth_cmd))\n        cmd = struct.pack(\n            fmt,\n            TPM2_ST_SESSIONS,\n            struct.calcsize(fmt),\n            TPM2_CC_UNSEAL,\n            data_handle,\n            len(auth_cmd),\n            bytes(auth_cmd))\n\n        try:\n            rsp = self.send_cmd(cmd)\n        finally:\n            self.flush_context(data_handle)\n\n        data_len = struct.unpack('>I', rsp[10:14])[0] - 2\n\n        return rsp[16:16 + data_len]\n\n    def reset_da_lock(self):\n        auth_cmd = AuthCommand()\n\n        fmt = '>HII I I%us' % (len(auth_cmd))\n        cmd = struct.pack(\n            fmt,\n            TPM2_ST_SESSIONS,\n            struct.calcsize(fmt),\n            TPM2_CC_DICTIONARY_ATTACK_LOCK_RESET,\n            TPM2_RH_LOCKOUT,\n            len(auth_cmd),\n            bytes(auth_cmd))\n\n        self.send_cmd(cmd)\n\n    def __get_cap_cnt(self, cap, pt, cnt):\n        handles = []\n        fmt = '>HII III'\n\n        cmd = struct.pack(fmt,\n                          TPM2_ST_NO_SESSIONS,\n                          struct.calcsize(fmt),\n                          TPM2_CC_GET_CAPABILITY,\n                          cap, pt, cnt)\n\n        rsp = self.send_cmd(cmd)[10:]\n        more_data, cap, cnt = struct.unpack('>BII', rsp[:9])\n        rsp = rsp[9:]\n\n        for i in range(0, cnt):\n            handle = struct.unpack('>I', rsp[:4])[0]\n            handles.append(handle)\n            rsp = rsp[4:]\n\n        return handles, more_data\n\n    def get_cap(self, cap, pt):\n        handles = []\n\n        more_data = True\n        while more_data:\n            next_handles, more_data = self.__get_cap_cnt(cap, pt, 1)\n            handles += next_handles\n            pt += 1\n\n        return handles\n\n    def get_cap_pcrs(self):\n        pcr_banks = {}\n\n        fmt = '>HII III'\n\n        cmd = struct.pack(fmt,\n                          TPM2_ST_NO_SESSIONS,\n                          struct.calcsize(fmt),\n                          TPM2_CC_GET_CAPABILITY,\n                          TPM2_CAP_PCRS, 0, 1)\n        rsp = self.send_cmd(cmd)[10:]\n        _, _, cnt = struct.unpack('>BII', rsp[:9])\n        rsp = rsp[9:]\n\n        # items are TPMS_PCR_SELECTION's\n        for i in range(0, cnt):\n              hash, sizeOfSelect = struct.unpack('>HB', rsp[:3])\n              rsp = rsp[3:]\n\n              pcrSelect = 0\n              if sizeOfSelect > 0:\n                  pcrSelect, = struct.unpack('%ds' % sizeOfSelect,\n                                             rsp[:sizeOfSelect])\n                  rsp = rsp[sizeOfSelect:]\n                  pcrSelect = int.from_bytes(pcrSelect, byteorder='big')\n\n              pcr_banks[hash] = pcrSelect\n\n        return pcr_banks\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}