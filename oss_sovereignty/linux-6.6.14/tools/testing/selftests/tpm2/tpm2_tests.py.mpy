{
  "module_name": "tpm2_tests.py",
  "hash_id": "469d5d63e1845353641392709af0c26d8e0bf3334765f1c2333f1f453c8b7455",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/tpm2/tpm2_tests.py",
  "human_readable_source": "# SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)\n\nfrom argparse import ArgumentParser\nfrom argparse import FileType\nimport os\nimport sys\nimport tpm2\nfrom tpm2 import ProtocolError\nimport unittest\nimport logging\nimport struct\n\nclass SmokeTest(unittest.TestCase):\n    def setUp(self):\n        self.client = tpm2.Client()\n        self.root_key = self.client.create_root_key()\n\n    def tearDown(self):\n        self.client.flush_context(self.root_key)\n        self.client.close()\n\n    def test_seal_with_auth(self):\n        data = ('X' * 64).encode()\n        auth = ('A' * 15).encode()\n\n        blob = self.client.seal(self.root_key, data, auth, None)\n        result = self.client.unseal(self.root_key, blob, auth, None)\n        self.assertEqual(data, result)\n\n    def determine_bank_alg(self, mask):\n        pcr_banks = self.client.get_cap_pcrs()\n        for bank_alg, pcrSelection in pcr_banks.items():\n            if pcrSelection & mask == mask:\n                return bank_alg\n        return None\n\n    def test_seal_with_policy(self):\n        bank_alg = self.determine_bank_alg(1 << 16)\n        self.assertIsNotNone(bank_alg)\n\n        handle = self.client.start_auth_session(tpm2.TPM2_SE_TRIAL)\n\n        data = ('X' * 64).encode()\n        auth = ('A' * 15).encode()\n        pcrs = [16]\n\n        try:\n            self.client.policy_pcr(handle, pcrs, bank_alg=bank_alg)\n            self.client.policy_password(handle)\n\n            policy_dig = self.client.get_policy_digest(handle)\n        finally:\n            self.client.flush_context(handle)\n\n        blob = self.client.seal(self.root_key, data, auth, policy_dig)\n\n        handle = self.client.start_auth_session(tpm2.TPM2_SE_POLICY)\n\n        try:\n            self.client.policy_pcr(handle, pcrs, bank_alg=bank_alg)\n            self.client.policy_password(handle)\n\n            result = self.client.unseal(self.root_key, blob, auth, handle)\n        except:\n            self.client.flush_context(handle)\n            raise\n\n        self.assertEqual(data, result)\n\n    def test_unseal_with_wrong_auth(self):\n        data = ('X' * 64).encode()\n        auth = ('A' * 20).encode()\n        rc = 0\n\n        blob = self.client.seal(self.root_key, data, auth, None)\n        try:\n            result = self.client.unseal(self.root_key, blob,\n                        auth[:-1] + 'B'.encode(), None)\n        except ProtocolError as e:\n            rc = e.rc\n\n        self.assertEqual(rc, tpm2.TPM2_RC_AUTH_FAIL)\n\n    def test_unseal_with_wrong_policy(self):\n        bank_alg = self.determine_bank_alg(1 << 16 | 1 << 1)\n        self.assertIsNotNone(bank_alg)\n\n        handle = self.client.start_auth_session(tpm2.TPM2_SE_TRIAL)\n\n        data = ('X' * 64).encode()\n        auth = ('A' * 17).encode()\n        pcrs = [16]\n\n        try:\n            self.client.policy_pcr(handle, pcrs, bank_alg=bank_alg)\n            self.client.policy_password(handle)\n\n            policy_dig = self.client.get_policy_digest(handle)\n        finally:\n            self.client.flush_context(handle)\n\n        blob = self.client.seal(self.root_key, data, auth, policy_dig)\n\n        # Extend first a PCR that is not part of the policy and try to unseal.\n        # This should succeed.\n\n        ds = tpm2.get_digest_size(bank_alg)\n        self.client.extend_pcr(1, ('X' * ds).encode(), bank_alg=bank_alg)\n\n        handle = self.client.start_auth_session(tpm2.TPM2_SE_POLICY)\n\n        try:\n            self.client.policy_pcr(handle, pcrs, bank_alg=bank_alg)\n            self.client.policy_password(handle)\n\n            result = self.client.unseal(self.root_key, blob, auth, handle)\n        except:\n            self.client.flush_context(handle)\n            raise\n\n        self.assertEqual(data, result)\n\n        # Then, extend a PCR that is part of the policy and try to unseal.\n        # This should fail.\n        self.client.extend_pcr(16, ('X' * ds).encode(), bank_alg=bank_alg)\n\n        handle = self.client.start_auth_session(tpm2.TPM2_SE_POLICY)\n\n        rc = 0\n\n        try:\n            self.client.policy_pcr(handle, pcrs, bank_alg=bank_alg)\n            self.client.policy_password(handle)\n\n            result = self.client.unseal(self.root_key, blob, auth, handle)\n        except ProtocolError as e:\n            rc = e.rc\n            self.client.flush_context(handle)\n        except:\n            self.client.flush_context(handle)\n            raise\n\n        self.assertEqual(rc, tpm2.TPM2_RC_POLICY_FAIL)\n\n    def test_seal_with_too_long_auth(self):\n        ds = tpm2.get_digest_size(tpm2.TPM2_ALG_SHA1)\n        data = ('X' * 64).encode()\n        auth = ('A' * (ds + 1)).encode()\n\n        rc = 0\n        try:\n            blob = self.client.seal(self.root_key, data, auth, None)\n        except ProtocolError as e:\n            rc = e.rc\n\n        self.assertEqual(rc, tpm2.TPM2_RC_SIZE)\n\n    def test_too_short_cmd(self):\n        rejected = False\n        try:\n            fmt = '>HIII'\n            cmd = struct.pack(fmt,\n                              tpm2.TPM2_ST_NO_SESSIONS,\n                              struct.calcsize(fmt) + 1,\n                              tpm2.TPM2_CC_FLUSH_CONTEXT,\n                              0xDEADBEEF)\n\n            self.client.send_cmd(cmd)\n        except IOError as e:\n            rejected = True\n        except:\n            pass\n        self.assertEqual(rejected, True)\n\n    def test_read_partial_resp(self):\n        try:\n            fmt = '>HIIH'\n            cmd = struct.pack(fmt,\n                              tpm2.TPM2_ST_NO_SESSIONS,\n                              struct.calcsize(fmt),\n                              tpm2.TPM2_CC_GET_RANDOM,\n                              0x20)\n            self.client.tpm.write(cmd)\n            hdr = self.client.tpm.read(10)\n            sz = struct.unpack('>I', hdr[2:6])[0]\n            rsp = self.client.tpm.read()\n        except:\n            pass\n        self.assertEqual(sz, 10 + 2 + 32)\n        self.assertEqual(len(rsp), 2 + 32)\n\n    def test_read_partial_overwrite(self):\n        try:\n            fmt = '>HIIH'\n            cmd = struct.pack(fmt,\n                              tpm2.TPM2_ST_NO_SESSIONS,\n                              struct.calcsize(fmt),\n                              tpm2.TPM2_CC_GET_RANDOM,\n                              0x20)\n            self.client.tpm.write(cmd)\n            # Read part of the respone\n            rsp1 = self.client.tpm.read(15)\n\n            # Send a new cmd\n            self.client.tpm.write(cmd)\n\n            # Read the whole respone\n            rsp2 = self.client.tpm.read()\n        except:\n            pass\n        self.assertEqual(len(rsp1), 15)\n        self.assertEqual(len(rsp2), 10 + 2 + 32)\n\n    def test_send_two_cmds(self):\n        rejected = False\n        try:\n            fmt = '>HIIH'\n            cmd = struct.pack(fmt,\n                              tpm2.TPM2_ST_NO_SESSIONS,\n                              struct.calcsize(fmt),\n                              tpm2.TPM2_CC_GET_RANDOM,\n                              0x20)\n            self.client.tpm.write(cmd)\n\n            # expect the second one to raise -EBUSY error\n            self.client.tpm.write(cmd)\n            rsp = self.client.tpm.read()\n\n        except IOError as e:\n            # read the response\n            rsp = self.client.tpm.read()\n            rejected = True\n            pass\n        except:\n            pass\n        self.assertEqual(rejected, True)\n\nclass SpaceTest(unittest.TestCase):\n    def setUp(self):\n        logging.basicConfig(filename='SpaceTest.log', level=logging.DEBUG)\n\n    def test_make_two_spaces(self):\n        log = logging.getLogger(__name__)\n        log.debug(\"test_make_two_spaces\")\n\n        space1 = tpm2.Client(tpm2.Client.FLAG_SPACE)\n        root1 = space1.create_root_key()\n        space2 = tpm2.Client(tpm2.Client.FLAG_SPACE)\n        root2 = space2.create_root_key()\n        root3 = space2.create_root_key()\n\n        log.debug(\"%08x\" % (root1))\n        log.debug(\"%08x\" % (root2))\n        log.debug(\"%08x\" % (root3))\n\n    def test_flush_context(self):\n        log = logging.getLogger(__name__)\n        log.debug(\"test_flush_context\")\n\n        space1 = tpm2.Client(tpm2.Client.FLAG_SPACE)\n        root1 = space1.create_root_key()\n        log.debug(\"%08x\" % (root1))\n\n        space1.flush_context(root1)\n\n    def test_get_handles(self):\n        log = logging.getLogger(__name__)\n        log.debug(\"test_get_handles\")\n\n        space1 = tpm2.Client(tpm2.Client.FLAG_SPACE)\n        space1.create_root_key()\n        space2 = tpm2.Client(tpm2.Client.FLAG_SPACE)\n        space2.create_root_key()\n        space2.create_root_key()\n\n        handles = space2.get_cap(tpm2.TPM2_CAP_HANDLES, tpm2.HR_TRANSIENT)\n\n        self.assertEqual(len(handles), 2)\n\n        log.debug(\"%08x\" % (handles[0]))\n        log.debug(\"%08x\" % (handles[1]))\n\n    def test_invalid_cc(self):\n        log = logging.getLogger(__name__)\n        log.debug(sys._getframe().f_code.co_name)\n\n        TPM2_CC_INVALID = tpm2.TPM2_CC_FIRST - 1\n\n        space1 = tpm2.Client(tpm2.Client.FLAG_SPACE)\n        root1 = space1.create_root_key()\n        log.debug(\"%08x\" % (root1))\n\n        fmt = '>HII'\n        cmd = struct.pack(fmt, tpm2.TPM2_ST_NO_SESSIONS, struct.calcsize(fmt),\n                          TPM2_CC_INVALID)\n\n        rc = 0\n        try:\n            space1.send_cmd(cmd)\n        except ProtocolError as e:\n            rc = e.rc\n\n        self.assertEqual(rc, tpm2.TPM2_RC_COMMAND_CODE |\n                         tpm2.TSS2_RESMGR_TPM_RC_LAYER)\n\nclass AsyncTest(unittest.TestCase):\n    def setUp(self):\n        logging.basicConfig(filename='AsyncTest.log', level=logging.DEBUG)\n\n    def test_async(self):\n        log = logging.getLogger(__name__)\n        log.debug(sys._getframe().f_code.co_name)\n\n        async_client = tpm2.Client(tpm2.Client.FLAG_NONBLOCK)\n        log.debug(\"Calling get_cap in a NON_BLOCKING mode\")\n        async_client.get_cap(tpm2.TPM2_CAP_HANDLES, tpm2.HR_LOADED_SESSION)\n        async_client.close()\n\n    def test_flush_invalid_context(self):\n        log = logging.getLogger(__name__)\n        log.debug(sys._getframe().f_code.co_name)\n\n        async_client = tpm2.Client(tpm2.Client.FLAG_SPACE | tpm2.Client.FLAG_NONBLOCK)\n        log.debug(\"Calling flush_context passing in an invalid handle \")\n        handle = 0x80123456\n        rc = 0\n        try:\n            async_client.flush_context(handle)\n        except OSError as e:\n            rc = e.errno\n\n        self.assertEqual(rc, 22)\n        async_client.close()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}