{
  "module_name": "txtimestamp.c",
  "hash_id": "549e45dfc49cd33fc960a13d3737a53d3bc3abce00d83b0e3d2c46d2922e632f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/txtimestamp.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <asm/types.h>\n#include <error.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <linux/errqueue.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/ipv6.h>\n#include <linux/net_tstamp.h>\n#include <netdb.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <netinet/tcp.h>\n#include <poll.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <sys/ioctl.h>\n#include <sys/select.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#define NSEC_PER_USEC\t1000L\n#define USEC_PER_SEC\t1000000L\n#define NSEC_PER_SEC\t1000000000LL\n\n \nstatic int cfg_proto = SOCK_STREAM;\nstatic int cfg_ipproto = IPPROTO_TCP;\nstatic int cfg_num_pkts = 4;\nstatic int do_ipv4 = 1;\nstatic int do_ipv6 = 1;\nstatic int cfg_payload_len = 10;\nstatic int cfg_poll_timeout = 100;\nstatic int cfg_delay_snd;\nstatic int cfg_delay_ack;\nstatic int cfg_delay_tolerance_usec = 500;\nstatic bool cfg_show_payload;\nstatic bool cfg_do_pktinfo;\nstatic bool cfg_busy_poll;\nstatic int cfg_sleep_usec = 50 * 1000;\nstatic bool cfg_loop_nodata;\nstatic bool cfg_use_cmsg;\nstatic bool cfg_use_pf_packet;\nstatic bool cfg_use_epoll;\nstatic bool cfg_epollet;\nstatic bool cfg_do_listen;\nstatic uint16_t dest_port = 9000;\nstatic bool cfg_print_nsec;\n\nstatic struct sockaddr_in daddr;\nstatic struct sockaddr_in6 daddr6;\nstatic struct timespec ts_usr;\n\nstatic int saved_tskey = -1;\nstatic int saved_tskey_type = -1;\n\nstruct timing_event {\n\tint64_t min;\n\tint64_t max;\n\tint64_t total;\n\tint count;\n};\n\nstatic struct timing_event usr_enq;\nstatic struct timing_event usr_snd;\nstatic struct timing_event usr_ack;\n\nstatic bool test_failed;\n\nstatic int64_t timespec_to_ns64(struct timespec *ts)\n{\n\treturn ts->tv_sec * NSEC_PER_SEC + ts->tv_nsec;\n}\n\nstatic int64_t timespec_to_us64(struct timespec *ts)\n{\n\treturn ts->tv_sec * USEC_PER_SEC + ts->tv_nsec / NSEC_PER_USEC;\n}\n\nstatic void init_timing_event(struct timing_event *te)\n{\n\tte->min = INT64_MAX;\n\tte->max = 0;\n\tte->total = 0;\n\tte->count = 0;\n}\n\nstatic void add_timing_event(struct timing_event *te,\n\t\tstruct timespec *t_start, struct timespec *t_end)\n{\n\tint64_t ts_delta = timespec_to_ns64(t_end) - timespec_to_ns64(t_start);\n\n\tte->count++;\n\tif (ts_delta < te->min)\n\t\tte->min = ts_delta;\n\tif (ts_delta > te->max)\n\t\tte->max = ts_delta;\n\tte->total += ts_delta;\n}\n\nstatic void validate_key(int tskey, int tstype)\n{\n\tint stepsize;\n\n\t \n\tif (saved_tskey == -1)\n\t\tsaved_tskey_type = tstype;\n\telse if (saved_tskey_type != tstype)\n\t\treturn;\n\n\tstepsize = cfg_proto == SOCK_STREAM ? cfg_payload_len : 1;\n\tif (tskey != saved_tskey + stepsize) {\n\t\tfprintf(stderr, \"ERROR: key %d, expected %d\\n\",\n\t\t\t\ttskey, saved_tskey + stepsize);\n\t\ttest_failed = true;\n\t}\n\n\tsaved_tskey = tskey;\n}\n\nstatic void validate_timestamp(struct timespec *cur, int min_delay)\n{\n\tint64_t cur64, start64;\n\tint max_delay;\n\n\tcur64 = timespec_to_us64(cur);\n\tstart64 = timespec_to_us64(&ts_usr);\n\tmax_delay = min_delay + cfg_delay_tolerance_usec;\n\n\tif (cur64 < start64 + min_delay || cur64 > start64 + max_delay) {\n\t\tfprintf(stderr, \"ERROR: %\" PRId64 \" us expected between %d and %d\\n\",\n\t\t\t\tcur64 - start64, min_delay, max_delay);\n\t\ttest_failed = true;\n\t}\n}\n\nstatic void __print_ts_delta_formatted(int64_t ts_delta)\n{\n\tif (cfg_print_nsec)\n\t\tfprintf(stderr, \"%\" PRId64 \" ns\", ts_delta);\n\telse\n\t\tfprintf(stderr, \"%\" PRId64 \" us\", ts_delta / NSEC_PER_USEC);\n}\n\nstatic void __print_timestamp(const char *name, struct timespec *cur,\n\t\t\t      uint32_t key, int payload_len)\n{\n\tint64_t ts_delta;\n\n\tif (!(cur->tv_sec | cur->tv_nsec))\n\t\treturn;\n\n\tif (cfg_print_nsec)\n\t\tfprintf(stderr, \"  %s: %lu s %lu ns (seq=%u, len=%u)\",\n\t\t\t\tname, cur->tv_sec, cur->tv_nsec,\n\t\t\t\tkey, payload_len);\n\telse\n\t\tfprintf(stderr, \"  %s: %lu s %lu us (seq=%u, len=%u)\",\n\t\t\t\tname, cur->tv_sec, cur->tv_nsec / NSEC_PER_USEC,\n\t\t\t\tkey, payload_len);\n\n\tif (cur != &ts_usr) {\n\t\tts_delta = timespec_to_ns64(cur) - timespec_to_ns64(&ts_usr);\n\t\tfprintf(stderr, \"  (USR +\");\n\t\t__print_ts_delta_formatted(ts_delta);\n\t\tfprintf(stderr, \")\");\n\t}\n\n\tfprintf(stderr, \"\\n\");\n}\n\nstatic void print_timestamp_usr(void)\n{\n\tif (clock_gettime(CLOCK_REALTIME, &ts_usr))\n\t\terror(1, errno, \"clock_gettime\");\n\n\t__print_timestamp(\"  USR\", &ts_usr, 0, 0);\n}\n\nstatic void print_timestamp(struct scm_timestamping *tss, int tstype,\n\t\t\t    int tskey, int payload_len)\n{\n\tconst char *tsname;\n\n\tvalidate_key(tskey, tstype);\n\n\tswitch (tstype) {\n\tcase SCM_TSTAMP_SCHED:\n\t\ttsname = \"  ENQ\";\n\t\tvalidate_timestamp(&tss->ts[0], 0);\n\t\tadd_timing_event(&usr_enq, &ts_usr, &tss->ts[0]);\n\t\tbreak;\n\tcase SCM_TSTAMP_SND:\n\t\ttsname = \"  SND\";\n\t\tvalidate_timestamp(&tss->ts[0], cfg_delay_snd);\n\t\tadd_timing_event(&usr_snd, &ts_usr, &tss->ts[0]);\n\t\tbreak;\n\tcase SCM_TSTAMP_ACK:\n\t\ttsname = \"  ACK\";\n\t\tvalidate_timestamp(&tss->ts[0], cfg_delay_ack);\n\t\tadd_timing_event(&usr_ack, &ts_usr, &tss->ts[0]);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"unknown timestamp type: %u\",\n\t\ttstype);\n\t}\n\t__print_timestamp(tsname, &tss->ts[0], tskey, payload_len);\n}\n\nstatic void print_timing_event(char *name, struct timing_event *te)\n{\n\tif (!te->count)\n\t\treturn;\n\n\tfprintf(stderr, \"    %s: count=%d\", name, te->count);\n\tfprintf(stderr, \", avg=\");\n\t__print_ts_delta_formatted((int64_t)(te->total / te->count));\n\tfprintf(stderr, \", min=\");\n\t__print_ts_delta_formatted(te->min);\n\tfprintf(stderr, \", max=\");\n\t__print_ts_delta_formatted(te->max);\n\tfprintf(stderr, \"\\n\");\n}\n\n \nstatic void print_payload(char *data, int len)\n{\n\tint i;\n\n\tif (!len)\n\t\treturn;\n\n\tif (len > 70)\n\t\tlen = 70;\n\n\tfprintf(stderr, \"payload: \");\n\tfor (i = 0; i < len; i++)\n\t\tfprintf(stderr, \"%02hhx \", data[i]);\n\tfprintf(stderr, \"\\n\");\n}\n\nstatic void print_pktinfo(int family, int ifindex, void *saddr, void *daddr)\n{\n\tchar sa[INET6_ADDRSTRLEN], da[INET6_ADDRSTRLEN];\n\n\tfprintf(stderr, \"         pktinfo: ifindex=%u src=%s dst=%s\\n\",\n\t\tifindex,\n\t\tsaddr ? inet_ntop(family, saddr, sa, sizeof(sa)) : \"unknown\",\n\t\tdaddr ? inet_ntop(family, daddr, da, sizeof(da)) : \"unknown\");\n}\n\nstatic void __epoll(int epfd)\n{\n\tstruct epoll_event events;\n\tint ret;\n\n\tmemset(&events, 0, sizeof(events));\n\tret = epoll_wait(epfd, &events, 1, cfg_poll_timeout);\n\tif (ret != 1)\n\t\terror(1, errno, \"epoll_wait\");\n}\n\nstatic void __poll(int fd)\n{\n\tstruct pollfd pollfd;\n\tint ret;\n\n\tmemset(&pollfd, 0, sizeof(pollfd));\n\tpollfd.fd = fd;\n\tret = poll(&pollfd, 1, cfg_poll_timeout);\n\tif (ret != 1)\n\t\terror(1, errno, \"poll\");\n}\n\nstatic void __recv_errmsg_cmsg(struct msghdr *msg, int payload_len)\n{\n\tstruct sock_extended_err *serr = NULL;\n\tstruct scm_timestamping *tss = NULL;\n\tstruct cmsghdr *cm;\n\tint batch = 0;\n\n\tfor (cm = CMSG_FIRSTHDR(msg);\n\t     cm && cm->cmsg_len;\n\t     cm = CMSG_NXTHDR(msg, cm)) {\n\t\tif (cm->cmsg_level == SOL_SOCKET &&\n\t\t    cm->cmsg_type == SCM_TIMESTAMPING) {\n\t\t\ttss = (void *) CMSG_DATA(cm);\n\t\t} else if ((cm->cmsg_level == SOL_IP &&\n\t\t\t    cm->cmsg_type == IP_RECVERR) ||\n\t\t\t   (cm->cmsg_level == SOL_IPV6 &&\n\t\t\t    cm->cmsg_type == IPV6_RECVERR) ||\n\t\t\t   (cm->cmsg_level == SOL_PACKET &&\n\t\t\t    cm->cmsg_type == PACKET_TX_TIMESTAMP)) {\n\t\t\tserr = (void *) CMSG_DATA(cm);\n\t\t\tif (serr->ee_errno != ENOMSG ||\n\t\t\t    serr->ee_origin != SO_EE_ORIGIN_TIMESTAMPING) {\n\t\t\t\tfprintf(stderr, \"unknown ip error %d %d\\n\",\n\t\t\t\t\t\tserr->ee_errno,\n\t\t\t\t\t\tserr->ee_origin);\n\t\t\t\tserr = NULL;\n\t\t\t}\n\t\t} else if (cm->cmsg_level == SOL_IP &&\n\t\t\t   cm->cmsg_type == IP_PKTINFO) {\n\t\t\tstruct in_pktinfo *info = (void *) CMSG_DATA(cm);\n\t\t\tprint_pktinfo(AF_INET, info->ipi_ifindex,\n\t\t\t\t      &info->ipi_spec_dst, &info->ipi_addr);\n\t\t} else if (cm->cmsg_level == SOL_IPV6 &&\n\t\t\t   cm->cmsg_type == IPV6_PKTINFO) {\n\t\t\tstruct in6_pktinfo *info6 = (void *) CMSG_DATA(cm);\n\t\t\tprint_pktinfo(AF_INET6, info6->ipi6_ifindex,\n\t\t\t\t      NULL, &info6->ipi6_addr);\n\t\t} else\n\t\t\tfprintf(stderr, \"unknown cmsg %d,%d\\n\",\n\t\t\t\t\tcm->cmsg_level, cm->cmsg_type);\n\n\t\tif (serr && tss) {\n\t\t\tprint_timestamp(tss, serr->ee_info, serr->ee_data,\n\t\t\t\t\tpayload_len);\n\t\t\tserr = NULL;\n\t\t\ttss = NULL;\n\t\t\tbatch++;\n\t\t}\n\t}\n\n\tif (batch > 1)\n\t\tfprintf(stderr, \"batched %d timestamps\\n\", batch);\n}\n\nstatic int recv_errmsg(int fd)\n{\n\tstatic char ctrl[1024  ];\n\tstatic struct msghdr msg;\n\tstruct iovec entry;\n\tstatic char *data;\n\tint ret = 0;\n\n\tdata = malloc(cfg_payload_len);\n\tif (!data)\n\t\terror(1, 0, \"malloc\");\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmemset(&entry, 0, sizeof(entry));\n\tmemset(ctrl, 0, sizeof(ctrl));\n\n\tentry.iov_base = data;\n\tentry.iov_len = cfg_payload_len;\n\tmsg.msg_iov = &entry;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_control = ctrl;\n\tmsg.msg_controllen = sizeof(ctrl);\n\n\tret = recvmsg(fd, &msg, MSG_ERRQUEUE);\n\tif (ret == -1 && errno != EAGAIN)\n\t\terror(1, errno, \"recvmsg\");\n\n\tif (ret >= 0) {\n\t\t__recv_errmsg_cmsg(&msg, ret);\n\t\tif (cfg_show_payload)\n\t\t\tprint_payload(data, cfg_payload_len);\n\t}\n\n\tfree(data);\n\treturn ret == -1;\n}\n\nstatic uint16_t get_ip_csum(const uint16_t *start, int num_words,\n\t\t\t    unsigned long sum)\n{\n\tint i;\n\n\tfor (i = 0; i < num_words; i++)\n\t\tsum += start[i];\n\n\twhile (sum >> 16)\n\t\tsum = (sum & 0xFFFF) + (sum >> 16);\n\n\treturn ~sum;\n}\n\nstatic uint16_t get_udp_csum(const struct udphdr *udph, int alen)\n{\n\tunsigned long pseudo_sum, csum_len;\n\tconst void *csum_start = udph;\n\n\tpseudo_sum = htons(IPPROTO_UDP);\n\tpseudo_sum += udph->len;\n\n\t \n\tcsum_start -= alen * 2;\n\tcsum_len = ntohs(udph->len) + alen * 2;\n\n\treturn get_ip_csum(csum_start, csum_len >> 1, pseudo_sum);\n}\n\nstatic int fill_header_ipv4(void *p)\n{\n\tstruct iphdr *iph = p;\n\n\tmemset(iph, 0, sizeof(*iph));\n\n\tiph->ihl\t= 5;\n\tiph->version\t= 4;\n\tiph->ttl\t= 2;\n\tiph->saddr\t= daddr.sin_addr.s_addr;\t \n\tiph->daddr\t= daddr.sin_addr.s_addr;\n\tiph->protocol\t= IPPROTO_UDP;\n\n\t \n\n\treturn sizeof(*iph);\n}\n\nstatic int fill_header_ipv6(void *p)\n{\n\tstruct ipv6hdr *ip6h = p;\n\n\tmemset(ip6h, 0, sizeof(*ip6h));\n\n\tip6h->version\t\t= 6;\n\tip6h->payload_len\t= htons(sizeof(struct udphdr) + cfg_payload_len);\n\tip6h->nexthdr\t\t= IPPROTO_UDP;\n\tip6h->hop_limit\t\t= 64;\n\n\tip6h->saddr             = daddr6.sin6_addr;\n\tip6h->daddr\t\t= daddr6.sin6_addr;\n\n\t \n\n\treturn sizeof(*ip6h);\n}\n\nstatic void fill_header_udp(void *p, bool is_ipv4)\n{\n\tstruct udphdr *udph = p;\n\n\tudph->source = ntohs(dest_port + 1);\t \n\tudph->dest   = ntohs(dest_port);\n\tudph->len    = ntohs(sizeof(*udph) + cfg_payload_len);\n\tudph->check  = 0;\n\n\tudph->check  = get_udp_csum(udph, is_ipv4 ? sizeof(struct in_addr) :\n\t\t\t\t\t\t    sizeof(struct in6_addr));\n}\n\nstatic void do_test(int family, unsigned int report_opt)\n{\n\tchar control[CMSG_SPACE(sizeof(uint32_t))];\n\tstruct sockaddr_ll laddr;\n\tunsigned int sock_opt;\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tchar *buf;\n\tint fd, i, val = 1, total_len, epfd = 0;\n\n\tinit_timing_event(&usr_enq);\n\tinit_timing_event(&usr_snd);\n\tinit_timing_event(&usr_ack);\n\n\ttotal_len = cfg_payload_len;\n\tif (cfg_use_pf_packet || cfg_proto == SOCK_RAW) {\n\t\ttotal_len += sizeof(struct udphdr);\n\t\tif (cfg_use_pf_packet || cfg_ipproto == IPPROTO_RAW) {\n\t\t\tif (family == PF_INET)\n\t\t\t\ttotal_len += sizeof(struct iphdr);\n\t\t\telse\n\t\t\t\ttotal_len += sizeof(struct ipv6hdr);\n\t\t}\n\t\t \n\t\tdaddr6.sin6_port = htons(cfg_ipproto);\n\t}\n\n\tbuf = malloc(total_len);\n\tif (!buf)\n\t\terror(1, 0, \"malloc\");\n\n\tfd = socket(cfg_use_pf_packet ? PF_PACKET : family,\n\t\t    cfg_proto, cfg_ipproto);\n\tif (fd < 0)\n\t\terror(1, errno, \"socket\");\n\n\tif (cfg_use_epoll) {\n\t\tstruct epoll_event ev;\n\n\t\tmemset(&ev, 0, sizeof(ev));\n\t\tev.data.fd = fd;\n\t\tif (cfg_epollet)\n\t\t\tev.events |= EPOLLET;\n\t\tepfd = epoll_create(1);\n\t\tif (epfd <= 0)\n\t\t\terror(1, errno, \"epoll_create\");\n\t\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev))\n\t\t\terror(1, errno, \"epoll_ctl\");\n\t}\n\n\t \n\tsaved_tskey = -1;\n\n\tif (cfg_proto == SOCK_STREAM) {\n\t\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n\t\t\t       (char*) &val, sizeof(val)))\n\t\t\terror(1, 0, \"setsockopt no nagle\");\n\n\t\tif (family == PF_INET) {\n\t\t\tif (connect(fd, (void *) &daddr, sizeof(daddr)))\n\t\t\t\terror(1, errno, \"connect ipv4\");\n\t\t} else {\n\t\t\tif (connect(fd, (void *) &daddr6, sizeof(daddr6)))\n\t\t\t\terror(1, errno, \"connect ipv6\");\n\t\t}\n\t}\n\n\tif (cfg_do_pktinfo) {\n\t\tif (family == AF_INET6) {\n\t\t\tif (setsockopt(fd, SOL_IPV6, IPV6_RECVPKTINFO,\n\t\t\t\t       &val, sizeof(val)))\n\t\t\t\terror(1, errno, \"setsockopt pktinfo ipv6\");\n\t\t} else {\n\t\t\tif (setsockopt(fd, SOL_IP, IP_PKTINFO,\n\t\t\t\t       &val, sizeof(val)))\n\t\t\t\terror(1, errno, \"setsockopt pktinfo ipv4\");\n\t\t}\n\t}\n\n\tsock_opt = SOF_TIMESTAMPING_SOFTWARE |\n\t\t   SOF_TIMESTAMPING_OPT_CMSG |\n\t\t   SOF_TIMESTAMPING_OPT_ID;\n\n\tif (!cfg_use_cmsg)\n\t\tsock_opt |= report_opt;\n\n\tif (cfg_loop_nodata)\n\t\tsock_opt |= SOF_TIMESTAMPING_OPT_TSONLY;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_TIMESTAMPING,\n\t\t       (char *) &sock_opt, sizeof(sock_opt)))\n\t\terror(1, 0, \"setsockopt timestamping\");\n\n\tfor (i = 0; i < cfg_num_pkts; i++) {\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmemset(buf, 'a' + i, total_len);\n\n\t\tif (cfg_use_pf_packet || cfg_proto == SOCK_RAW) {\n\t\t\tint off = 0;\n\n\t\t\tif (cfg_use_pf_packet || cfg_ipproto == IPPROTO_RAW) {\n\t\t\t\tif (family == PF_INET)\n\t\t\t\t\toff = fill_header_ipv4(buf);\n\t\t\t\telse\n\t\t\t\t\toff = fill_header_ipv6(buf);\n\t\t\t}\n\n\t\t\tfill_header_udp(buf + off, family == PF_INET);\n\t\t}\n\n\t\tprint_timestamp_usr();\n\n\t\tiov.iov_base = buf;\n\t\tiov.iov_len = total_len;\n\n\t\tif (cfg_proto != SOCK_STREAM) {\n\t\t\tif (cfg_use_pf_packet) {\n\t\t\t\tmemset(&laddr, 0, sizeof(laddr));\n\n\t\t\t\tladdr.sll_family\t= AF_PACKET;\n\t\t\t\tladdr.sll_ifindex\t= 1;\n\t\t\t\tladdr.sll_protocol\t= htons(family == AF_INET ? ETH_P_IP : ETH_P_IPV6);\n\t\t\t\tladdr.sll_halen\t\t= ETH_ALEN;\n\n\t\t\t\tmsg.msg_name = (void *)&laddr;\n\t\t\t\tmsg.msg_namelen = sizeof(laddr);\n\t\t\t} else if (family == PF_INET) {\n\t\t\t\tmsg.msg_name = (void *)&daddr;\n\t\t\t\tmsg.msg_namelen = sizeof(daddr);\n\t\t\t} else {\n\t\t\t\tmsg.msg_name = (void *)&daddr6;\n\t\t\t\tmsg.msg_namelen = sizeof(daddr6);\n\t\t\t}\n\t\t}\n\n\t\tmsg.msg_iov = &iov;\n\t\tmsg.msg_iovlen = 1;\n\n\t\tif (cfg_use_cmsg) {\n\t\t\tmemset(control, 0, sizeof(control));\n\n\t\t\tmsg.msg_control = control;\n\t\t\tmsg.msg_controllen = sizeof(control);\n\n\t\t\tcmsg = CMSG_FIRSTHDR(&msg);\n\t\t\tcmsg->cmsg_level = SOL_SOCKET;\n\t\t\tcmsg->cmsg_type = SO_TIMESTAMPING;\n\t\t\tcmsg->cmsg_len = CMSG_LEN(sizeof(uint32_t));\n\n\t\t\t*((uint32_t *) CMSG_DATA(cmsg)) = report_opt;\n\t\t}\n\n\t\tval = sendmsg(fd, &msg, 0);\n\t\tif (val != total_len)\n\t\t\terror(1, errno, \"send\");\n\n\t\t \n\t\tif (cfg_sleep_usec)\n\t\t\tusleep(cfg_sleep_usec);\n\n\t\tif (!cfg_busy_poll) {\n\t\t\tif (cfg_use_epoll)\n\t\t\t\t__epoll(epfd);\n\t\t\telse\n\t\t\t\t__poll(fd);\n\t\t}\n\n\t\twhile (!recv_errmsg(fd)) {}\n\t}\n\n\tprint_timing_event(\"USR-ENQ\", &usr_enq);\n\tprint_timing_event(\"USR-SND\", &usr_snd);\n\tprint_timing_event(\"USR-ACK\", &usr_ack);\n\n\tif (close(fd))\n\t\terror(1, errno, \"close\");\n\n\tfree(buf);\n\tusleep(100 * NSEC_PER_USEC);\n}\n\nstatic void __attribute__((noreturn)) usage(const char *filepath)\n{\n\tfprintf(stderr, \"\\nUsage: %s [options] hostname\\n\"\n\t\t\t\"\\nwhere options are:\\n\"\n\t\t\t\"  -4:   only IPv4\\n\"\n\t\t\t\"  -6:   only IPv6\\n\"\n\t\t\t\"  -h:   show this message\\n\"\n\t\t\t\"  -b:   busy poll to read from error queue\\n\"\n\t\t\t\"  -c N: number of packets for each test\\n\"\n\t\t\t\"  -C:   use cmsg to set tstamp recording options\\n\"\n\t\t\t\"  -e:   use level-triggered epoll() instead of poll()\\n\"\n\t\t\t\"  -E:   use event-triggered epoll() instead of poll()\\n\"\n\t\t\t\"  -F:   poll()/epoll() waits forever for an event\\n\"\n\t\t\t\"  -I:   request PKTINFO\\n\"\n\t\t\t\"  -l N: send N bytes at a time\\n\"\n\t\t\t\"  -L    listen on hostname and port\\n\"\n\t\t\t\"  -n:   set no-payload option\\n\"\n\t\t\t\"  -N:   print timestamps and durations in nsec (instead of usec)\\n\"\n\t\t\t\"  -p N: connect to port N\\n\"\n\t\t\t\"  -P:   use PF_PACKET\\n\"\n\t\t\t\"  -r:   use raw\\n\"\n\t\t\t\"  -R:   use raw (IP_HDRINCL)\\n\"\n\t\t\t\"  -S N: usec to sleep before reading error queue\\n\"\n\t\t\t\"  -t N: tolerance (usec) for timestamp validation\\n\"\n\t\t\t\"  -u:   use udp\\n\"\n\t\t\t\"  -v:   validate SND delay (usec)\\n\"\n\t\t\t\"  -V:   validate ACK delay (usec)\\n\"\n\t\t\t\"  -x:   show payload (up to 70 bytes)\\n\",\n\t\t\tfilepath);\n\texit(1);\n}\n\nstatic void parse_opt(int argc, char **argv)\n{\n\tint proto_count = 0;\n\tint c;\n\n\twhile ((c = getopt(argc, argv,\n\t\t\t\t\"46bc:CeEFhIl:LnNp:PrRS:t:uv:V:x\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tdo_ipv6 = 0;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tdo_ipv4 = 0;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tcfg_busy_poll = true;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcfg_num_pkts = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcfg_use_cmsg = true;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcfg_use_epoll = true;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tcfg_use_epoll = true;\n\t\t\tcfg_epollet = true;\n\t\tcase 'F':\n\t\t\tcfg_poll_timeout = -1;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tcfg_do_pktinfo = true;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tcfg_payload_len = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tcfg_do_listen = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcfg_loop_nodata = true;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tcfg_print_nsec = true;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdest_port = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tproto_count++;\n\t\t\tcfg_use_pf_packet = true;\n\t\t\tcfg_proto = SOCK_DGRAM;\n\t\t\tcfg_ipproto = 0;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tproto_count++;\n\t\t\tcfg_proto = SOCK_RAW;\n\t\t\tcfg_ipproto = IPPROTO_UDP;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tproto_count++;\n\t\t\tcfg_proto = SOCK_RAW;\n\t\t\tcfg_ipproto = IPPROTO_RAW;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tcfg_sleep_usec = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_delay_tolerance_usec = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tproto_count++;\n\t\t\tcfg_proto = SOCK_DGRAM;\n\t\t\tcfg_ipproto = IPPROTO_UDP;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcfg_delay_snd = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tcfg_delay_ack = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tcfg_show_payload = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (!cfg_payload_len)\n\t\terror(1, 0, \"payload may not be nonzero\");\n\tif (cfg_proto != SOCK_STREAM && cfg_payload_len > 1472)\n\t\terror(1, 0, \"udp packet might exceed expected MTU\");\n\tif (!do_ipv4 && !do_ipv6)\n\t\terror(1, 0, \"pass -4 or -6, not both\");\n\tif (proto_count > 1)\n\t\terror(1, 0, \"pass -P, -r, -R or -u, not multiple\");\n\tif (cfg_do_pktinfo && cfg_use_pf_packet)\n\t\terror(1, 0, \"cannot ask for pktinfo over pf_packet\");\n\tif (cfg_busy_poll && cfg_use_epoll)\n\t\terror(1, 0, \"pass epoll or busy_poll, not both\");\n\n\tif (optind != argc - 1)\n\t\terror(1, 0, \"missing required hostname argument\");\n}\n\nstatic void resolve_hostname(const char *hostname)\n{\n\tstruct addrinfo hints = { .ai_family = do_ipv4 ? AF_INET : AF_INET6 };\n\tstruct addrinfo *addrs, *cur;\n\tint have_ipv4 = 0, have_ipv6 = 0;\n\nretry:\n\tif (getaddrinfo(hostname, NULL, &hints, &addrs))\n\t\terror(1, errno, \"getaddrinfo\");\n\n\tcur = addrs;\n\twhile (cur && !have_ipv4 && !have_ipv6) {\n\t\tif (!have_ipv4 && cur->ai_family == AF_INET) {\n\t\t\tmemcpy(&daddr, cur->ai_addr, sizeof(daddr));\n\t\t\tdaddr.sin_port = htons(dest_port);\n\t\t\thave_ipv4 = 1;\n\t\t}\n\t\telse if (!have_ipv6 && cur->ai_family == AF_INET6) {\n\t\t\tmemcpy(&daddr6, cur->ai_addr, sizeof(daddr6));\n\t\t\tdaddr6.sin6_port = htons(dest_port);\n\t\t\thave_ipv6 = 1;\n\t\t}\n\t\tcur = cur->ai_next;\n\t}\n\tif (addrs)\n\t\tfreeaddrinfo(addrs);\n\n\tif (do_ipv6 && hints.ai_family != AF_INET6) {\n\t\thints.ai_family = AF_INET6;\n\t\tgoto retry;\n\t}\n\n\tdo_ipv4 &= have_ipv4;\n\tdo_ipv6 &= have_ipv6;\n}\n\nstatic void do_listen(int family, void *addr, int alen)\n{\n\tint fd, type;\n\n\ttype = cfg_proto == SOCK_RAW ? SOCK_DGRAM : cfg_proto;\n\n\tfd = socket(family, type, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket rx\");\n\n\tif (bind(fd, addr, alen))\n\t\terror(1, errno, \"bind rx\");\n\n\tif (type == SOCK_STREAM && listen(fd, 10))\n\t\terror(1, errno, \"listen rx\");\n\n\t \n}\n\nstatic void do_main(int family)\n{\n\tfprintf(stderr, \"family:       %s %s\\n\",\n\t\t\tfamily == PF_INET ? \"INET\" : \"INET6\",\n\t\t\tcfg_use_pf_packet ? \"(PF_PACKET)\" : \"\");\n\n\tfprintf(stderr, \"test SND\\n\");\n\tdo_test(family, SOF_TIMESTAMPING_TX_SOFTWARE);\n\n\tfprintf(stderr, \"test ENQ\\n\");\n\tdo_test(family, SOF_TIMESTAMPING_TX_SCHED);\n\n\tfprintf(stderr, \"test ENQ + SND\\n\");\n\tdo_test(family, SOF_TIMESTAMPING_TX_SCHED |\n\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE);\n\n\tif (cfg_proto == SOCK_STREAM) {\n\t\tfprintf(stderr, \"\\ntest ACK\\n\");\n\t\tdo_test(family, SOF_TIMESTAMPING_TX_ACK);\n\n\t\tfprintf(stderr, \"\\ntest SND + ACK\\n\");\n\t\tdo_test(family, SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_ACK);\n\n\t\tfprintf(stderr, \"\\ntest ENQ + SND + ACK\\n\");\n\t\tdo_test(family, SOF_TIMESTAMPING_TX_SCHED |\n\t\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_ACK);\n\t}\n}\n\nconst char *sock_names[] = { NULL, \"TCP\", \"UDP\", \"RAW\" };\n\nint main(int argc, char **argv)\n{\n\tif (argc == 1)\n\t\tusage(argv[0]);\n\n\tparse_opt(argc, argv);\n\tresolve_hostname(argv[argc - 1]);\n\n\tfprintf(stderr, \"protocol:     %s\\n\", sock_names[cfg_proto]);\n\tfprintf(stderr, \"payload:      %u\\n\", cfg_payload_len);\n\tfprintf(stderr, \"server port:  %u\\n\", dest_port);\n\tfprintf(stderr, \"\\n\");\n\n\tif (do_ipv4) {\n\t\tif (cfg_do_listen)\n\t\t\tdo_listen(PF_INET, &daddr, sizeof(daddr));\n\t\tdo_main(PF_INET);\n\t}\n\n\tif (do_ipv6) {\n\t\tif (cfg_do_listen)\n\t\t\tdo_listen(PF_INET6, &daddr6, sizeof(daddr6));\n\t\tdo_main(PF_INET6);\n\t}\n\n\treturn test_failed;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}