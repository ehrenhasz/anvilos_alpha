{
  "module_name": "srv6_end_flavors_test.sh",
  "hash_id": "3289b639fa61c906b7e6ec05e8a4a5e04ce120f11c0b6d9cec0356c3ddc54e09",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/srv6_end_flavors_test.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# author: Andrea Mayer <andrea.mayer@uniroma2.it>\n# author: Paolo Lungaroni <paolo.lungaroni@uniroma2.it>\n#\n# This script is designed to test the support for \"flavors\" in the SRv6 End\n# behavior.\n#\n# Flavors defined in RFC8986 [1] represent additional operations that can modify\n# or extend the existing SRv6 End, End.X and End.T behaviors. For the sake of\n# convenience, we report the list of flavors described in [1] hereafter:\n#   - Penultimate Segment Pop (PSP);\n#   - Ultimate Segment Pop (USP);\n#   - Ultimate Segment Decapsulation (USD).\n#\n# The End, End.X, and End.T behaviors can support these flavors either\n# individually or in combinations.\n# Currently in this selftest we consider only the PSP flavor for the SRv6 End\n# behavior. However, it is possible to extend the script as soon as other\n# flavors will be supported in the kernel.\n#\n# The purpose of the PSP flavor consists in instructing the penultimate node\n# listed in the SRv6 policy to remove (i.e. pop) the outermost SRH from the IPv6\n# header.\n# A PSP enabled SRv6 End behavior instance processes the SRH by:\n#  - decrementing the Segment Left (SL) value from 1 to 0;\n#  - copying the last SID from the SID List into the IPv6 Destination Address\n#    (DA);\n#  - removing the SRH from the extension headers following the IPv6 header.\n#\n# Once the SRH is removed, the IPv6 packet is forwarded to the destination using\n# the IPv6 DA updated during the PSP operation (i.e. the IPv6 DA corresponding\n# to the last SID carried by the removed SRH).\n#\n# Although the PSP flavor can be set for any SRv6 End behavior instance on any\n# SR node, it will be active only on such behaviors bound to a penultimate SID\n# for a given SRv6 policy.\n#                                                SL=2 SL=1 SL=0\n#                                                  |    |    |\n# For example, given the SRv6 policy (SID List := <X,   Y,   Z>):\n#  - a PSP enabled SRv6 End behavior bound to SID Y will apply the PSP operation\n#    as Segment Left (SL) is 1, corresponding to the Penultimate Segment of the\n#    SID List;\n#  - a PSP enabled SRv6 End behavior bound to SID X will *NOT* apply the PSP\n#    operation as the Segment Left is 2. This behavior instance will apply the\n#    \"standard\" End packet processing, ignoring the configured PSP flavor at\n#    all.\n#\n# [1] RFC8986: https://datatracker.ietf.org/doc/html/rfc8986\n#\n# Network topology\n# ================\n#\n# The network topology used in this selftest is depicted hereafter, composed by\n# two hosts (hs-1, hs-2) and four routers (rt-1, rt-2, rt-3, rt-4).\n# Hosts hs-1 and hs-2 are connected to routers rt-1 and rt-2, respectively,\n# allowing them to communicate with each other.\n# Traffic exchanged between hs-1 and hs-2 can follow different network paths.\n# The network operator, through specific SRv6 Policies can steer traffic to one\n# path rather than another. In this selftest this is implemented as follows:\n#\n#   i) The SRv6 H.Insert behavior applies SRv6 Policies on traffic received by\n#      connected hosts. It pushes the Segment Routing Header (SRH) after the\n#      IPv6 header. The SRH contains the SID List (i.e. SRv6 Policy) needed for\n#      steering traffic across the segments/waypoints specified in that list;\n#\n#  ii) The SRv6 End behavior advances the active SID in the SID List carried by\n#      the SRH;\n#\n# iii) The PSP enabled SRv6 End behavior is used to remove the SRH when such\n#      behavior is configured on a node bound to the Penultimate Segment carried\n#      by the SID List.\n#\n#                cafe::1                      cafe::2\n#              +--------+                   +--------+\n#              |        |                   |        |\n#              |  hs-1  |                   |  hs-2  |\n#              |        |                   |        |\n#              +---+----+                   +--- +---+\n#     cafe::/64    |                             |      cafe::/64\n#                  |                             |\n#              +---+----+                   +----+---+\n#              |        |  fcf0:0:1:2::/64  |        |\n#              |  rt-1  +-------------------+  rt-2  |\n#              |        |                   |        |\n#              +---+----+                   +----+---+\n#                  |      .               .      |\n#                  |  fcf0:0:1:3::/64   .        |\n#                  |          .       .          |\n#                  |            .   .            |\n#  fcf0:0:1:4::/64 |              .              | fcf0:0:2:3::/64\n#                  |            .   .            |\n#                  |          .       .          |\n#                  |  fcf0:0:2:4::/64   .        |\n#                  |      .               .      |\n#              +---+----+                   +----+---+\n#              |        |                   |        |\n#              |  rt-4  +-------------------+  rt-3  |\n#              |        |  fcf0:0:3:4::/64  |        |\n#              +---+----+                   +----+---+\n#\n# Every fcf0:0:x:y::/64 network interconnects the SRv6 routers rt-x with rt-y in\n# the IPv6 operator network.\n#\n#\n# Local SID table\n# ===============\n#\n# Each SRv6 router is configured with a Local SID table in which SIDs are\n# stored. Considering the given SRv6 router rt-x, at least two SIDs are\n# configured in the Local SID table:\n#\n#   Local SID table for SRv6 router rt-x\n#   +---------------------------------------------------------------------+\n#   |fcff:x::e is associated with the SRv6 End behavior                   |\n#   |fcff:x::ef1 is associated with the SRv6 End behavior with PSP flavor |\n#   +---------------------------------------------------------------------+\n#\n# The fcff::/16 prefix is reserved by the operator for the SIDs. Reachability of\n# SIDs is ensured by proper configuration of the IPv6 operator's network and\n# SRv6 routers.\n#\n#\n# SRv6 Policies\n# =============\n#\n# An SRv6 ingress router applies different SRv6 Policies to the traffic received\n# from connected hosts on the basis of the destination addresses.\n# In case of SRv6 H.Insert behavior, the SRv6 Policy enforcement consists of\n# pushing the SRH (carrying a given SID List) after the existing IPv6 header.\n# Note that in the inserting mode, there is no encapsulation at all.\n#\n#   Before applying an SRv6 Policy using the SRv6 H.Insert behavior\n#   +------+---------+\n#   | IPv6 | Payload |\n#   +------+---------+\n#\n#   After applying an SRv6 Policy using the SRv6 H.Insert behavior\n#   +------+-----+---------+\n#   | IPv6 | SRH | Payload |\n#   +------+-----+---------+\n#\n# Traffic from hs-1 to hs-2\n# -------------------------\n#\n# Packets generated from hs-1 and directed towards hs-2 are\n# handled by rt-1 which applies the following SRv6 Policy:\n#\n#   i.a) IPv6 traffic, SID List=fcff:3::e,fcff:4::ef1,fcff:2::ef1,cafe::2\n#\n# Router rt-1 is configured to enforce the Policy (i.a) through the SRv6\n# H.Insert behavior which pushes the SRH after the existing IPv6 header. This\n# Policy steers the traffic from hs-1 across rt-3, rt-4, rt-2 and finally to the\n# destination hs-2.\n#\n# As the packet reaches the router rt-3, the SRv6 End behavior bound to SID\n# fcff:3::e is triggered. The behavior updates the Segment Left (from SL=3 to\n# SL=2) in the SRH, the IPv6 DA with fcff:4::ef1 and forwards the packet to the\n# next router on the path, i.e. rt-4.\n#\n# When router rt-4 receives the packet, the PSP enabled SRv6 End behavior bound\n# to SID fcff:4::ef1 is executed. Since the SL=2, the PSP operation is *NOT*\n# kicked in and the behavior applies the default End processing: the Segment\n# Left is decreased (from SL=2 to SL=1), the IPv6 DA is updated with the SID\n# fcff:2::ef1 and the packet is forwarded to router rt-2.\n#\n# The PSP enabled SRv6 End behavior on rt-2 is associated with SID fcff:2::ef1\n# and is executed as the packet is received. Because SL=1, the behavior applies\n# the PSP processing on the packet as follows: i) SL is decreased, i.e. from\n# SL=1 to SL=0; ii) last SID (cafe::2) is copied into the IPv6 DA; iii) the\n# outermost SRH is removed from the extension headers following the IPv6 header.\n# Once the PSP processing is completed, the packet is forwarded to the host hs-2\n# (destination).\n#\n# Traffic from hs-2 to hs-1\n# -------------------------\n#\n# Packets generated from hs-2 and directed to hs-1 are handled by rt-2 which\n# applies the following SRv6 Policy:\n#\n#   i.b) IPv6 traffic, SID List=fcff:1::ef1,cafe::1\n#\n# Router rt-2 is configured to enforce the Policy (i.b) through the SRv6\n# H.Insert behavior which pushes the SRH after the existing IPv6 header. This\n# Policy steers the traffic from hs-2 across rt-1 and finally to the\n# destination hs-1\n#\n#\n# When the router rt-1 receives the packet, the PSP enabled SRv6 End behavior\n# associated with the SID fcff:1::ef1 is triggered. Since the SL=1,\n# the PSP operation takes place: i) the SL is decremented; ii) the IPv6 DA is\n# set with the last SID; iii) the SRH is removed from the extension headers\n# after the IPv6 header. At this point, the packet with IPv6 DA=cafe::1 is sent\n# to the destination, i.e. hs-1.\n\n# Kselftest framework requirement - SKIP code is 4.\nreadonly ksft_skip=4\n\nreadonly RDMSUFF=\"$(mktemp -u XXXXXXXX)\"\nreadonly DUMMY_DEVNAME=\"dum0\"\nreadonly RT2HS_DEVNAME=\"veth1\"\nreadonly LOCALSID_TABLE_ID=90\nreadonly IPv6_RT_NETWORK=fcf0:0\nreadonly IPv6_HS_NETWORK=cafe\nreadonly IPv6_TESTS_ADDR=2001:db8::1\nreadonly LOCATOR_SERVICE=fcff\nreadonly END_FUNC=000e\nreadonly END_PSP_FUNC=0ef1\n\nPING_TIMEOUT_SEC=4\nPAUSE_ON_FAIL=${PAUSE_ON_FAIL:=no}\n\n# IDs of routers and hosts are initialized during the setup of the testing\n# network\nROUTERS=''\nHOSTS=''\n\nSETUP_ERR=1\n\nret=${ksft_skip}\nnsuccess=0\nnfail=0\n\nlog_test()\n{\n\tlocal rc=\"$1\"\n\tlocal expected=\"$2\"\n\tlocal msg=\"$3\"\n\n\tif [ \"${rc}\" -eq \"${expected}\" ]; then\n\t\tnsuccess=$((nsuccess+1))\n\t\tprintf \"\\n    TEST: %-60s  [ OK ]\\n\" \"${msg}\"\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"\\n    TEST: %-60s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n}\n\nprint_log_test_results()\n{\n\tprintf \"\\nTests passed: %3d\\n\" \"${nsuccess}\"\n\tprintf \"Tests failed: %3d\\n\"   \"${nfail}\"\n\n\t# when a test fails, the value of 'ret' is set to 1 (error code).\n\t# Conversely, when all tests are passed successfully, the 'ret' value\n\t# is set to 0 (success code).\n\tif [ \"${ret}\" -ne 1 ]; then\n\t\tret=0\n\tfi\n}\n\nlog_section()\n{\n\techo\n\techo \"################################################################################\"\n\techo \"TEST SECTION: $*\"\n\techo \"################################################################################\"\n}\n\ntest_command_or_ksft_skip()\n{\n\tlocal cmd=\"$1\"\n\n\tif [ ! -x \"$(command -v \"${cmd}\")\" ]; then\n\t\techo \"SKIP: Could not run test without \\\"${cmd}\\\" tool\";\n\t\texit \"${ksft_skip}\"\n\tfi\n}\n\nget_nodename()\n{\n\tlocal name=\"$1\"\n\n\techo \"${name}-${RDMSUFF}\"\n}\n\nget_rtname()\n{\n\tlocal rtid=\"$1\"\n\n\tget_nodename \"rt-${rtid}\"\n}\n\nget_hsname()\n{\n\tlocal hsid=\"$1\"\n\n\tget_nodename \"hs-${hsid}\"\n}\n\n__create_namespace()\n{\n\tlocal name=\"$1\"\n\n\tip netns add \"${name}\"\n}\n\ncreate_router()\n{\n\tlocal rtid=\"$1\"\n\tlocal nsname\n\n\tnsname=\"$(get_rtname \"${rtid}\")\"\n\n\t__create_namespace \"${nsname}\"\n}\n\ncreate_host()\n{\n\tlocal hsid=\"$1\"\n\tlocal nsname\n\n\tnsname=\"$(get_hsname \"${hsid}\")\"\n\n\t__create_namespace \"${nsname}\"\n}\n\ncleanup()\n{\n\tlocal nsname\n\tlocal i\n\n\t# destroy routers\n\tfor i in ${ROUTERS}; do\n\t\tnsname=\"$(get_rtname \"${i}\")\"\n\n\t\tip netns del \"${nsname}\" &>/dev/null || true\n\tdone\n\n\t# destroy hosts\n\tfor i in ${HOSTS}; do\n\t\tnsname=\"$(get_hsname \"${i}\")\"\n\n\t\tip netns del \"${nsname}\" &>/dev/null || true\n\tdone\n\n\t# check whether the setup phase was completed successfully or not. In\n\t# case of an error during the setup phase of the testing environment,\n\t# the selftest is considered as \"skipped\".\n\tif [ \"${SETUP_ERR}\" -ne 0 ]; then\n\t\techo \"SKIP: Setting up the testing environment failed\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\texit \"${ret}\"\n}\n\nadd_link_rt_pairs()\n{\n\tlocal rt=\"$1\"\n\tlocal rt_neighs=\"$2\"\n\tlocal neigh\n\tlocal nsname\n\tlocal neigh_nsname\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\tfor neigh in ${rt_neighs}; do\n\t\tneigh_nsname=\"$(get_rtname \"${neigh}\")\"\n\n\t\tip link add \"veth-rt-${rt}-${neigh}\" netns \"${nsname}\" \\\n\t\t\ttype veth peer name \"veth-rt-${neigh}-${rt}\" \\\n\t\t\tnetns \"${neigh_nsname}\"\n\tdone\n}\n\nget_network_prefix()\n{\n\tlocal rt=\"$1\"\n\tlocal neigh=\"$2\"\n\tlocal p=\"${rt}\"\n\tlocal q=\"${neigh}\"\n\n\tif [ \"${p}\" -gt \"${q}\" ]; then\n\t\tp=\"${q}\"; q=\"${rt}\"\n\tfi\n\n\techo \"${IPv6_RT_NETWORK}:${p}:${q}\"\n}\n\n# Given the description of a router <id:op> as an input, the function returns\n# the <id> token which represents the ID of the router.\n# i.e. input: \"12:psp\"\n#      output: \"12\"\n__get_srv6_rtcfg_id()\n{\n\tlocal element=\"$1\"\n\n\techo \"${element}\" | cut -d':' -f1\n}\n\n# Given the description of a router <id:op> as an input, the function returns\n# the <op> token which represents the operation (e.g. End behavior with or\n# withouth flavors) configured for the node.\n\n# Note that when the operation represents an End behavior with a list of\n# flavors, the output is the ordered version of that list.\n# i.e. input: \"5:usp,psp,usd\"\n#      output: \"psp,usd,usp\"\n__get_srv6_rtcfg_op()\n{\n\tlocal element=\"$1\"\n\n\t# return the lexicographically ordered flavors\n\techo \"${element}\" | cut -d':' -f2 | sed 's/,/\\n/g' | sort | \\\n\t\txargs | sed 's/ /,/g'\n}\n\n# Setup the basic networking for the routers\nsetup_rt_networking()\n{\n\tlocal rt=\"$1\"\n\tlocal rt_neighs=\"$2\"\n\tlocal nsname\n\tlocal net_prefix\n\tlocal devname\n\tlocal neigh\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\tfor neigh in ${rt_neighs}; do\n\t\tdevname=\"veth-rt-${rt}-${neigh}\"\n\n\t\tnet_prefix=\"$(get_network_prefix \"${rt}\" \"${neigh}\")\"\n\n\t\tip -netns \"${nsname}\" addr \\\n\t\t\tadd \"${net_prefix}::${rt}/64\" dev \"${devname}\" nodad\n\n\t\tip -netns \"${nsname}\" link set \"${devname}\" up\n\tdone\n\n\tip -netns \"${nsname}\" link set lo up\n\n\tip -netns \"${nsname}\" link add ${DUMMY_DEVNAME} type dummy\n\tip -netns \"${nsname}\" link set ${DUMMY_DEVNAME} up\n\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv6.conf.all.accept_dad=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv6.conf.default.accept_dad=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv6.conf.all.forwarding=1\n}\n\n# Setup local SIDs for an SRv6 router\nsetup_rt_local_sids()\n{\n\tlocal rt=\"$1\"\n\tlocal rt_neighs=\"$2\"\n\tlocal net_prefix\n\tlocal devname\n\tlocal nsname\n\tlocal neigh\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\tfor neigh in ${rt_neighs}; do\n\t\tdevname=\"veth-rt-${rt}-${neigh}\"\n\n\t\tnet_prefix=\"$(get_network_prefix \"${rt}\" \"${neigh}\")\"\n\n\t\t# set underlay network routes for SIDs reachability\n\t\tip -netns \"${nsname}\" -6 route \\\n\t\t\tadd \"${LOCATOR_SERVICE}:${neigh}::/32\" \\\n\t\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\t\tvia \"${net_prefix}::${neigh}\" dev \"${devname}\"\n\tdone\n\n\t# Local End behavior (note that \"dev\" is a dummy interface chosen for\n\t# the sake of simplicity).\n\tip -netns \"${nsname}\" -6 route \\\n\t\tadd \"${LOCATOR_SERVICE}:${rt}::${END_FUNC}\" \\\n\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\tencap seg6local action End dev \"${DUMMY_DEVNAME}\"\n\n\n\t# all SIDs start with a common locator. Routes and SRv6 Endpoint\n\t# behavior instaces are grouped together in the 'localsid' table.\n\tip -netns \"${nsname}\" -6 rule \\\n\t\tadd to \"${LOCATOR_SERVICE}::/16\" \\\n\t\tlookup \"${LOCALSID_TABLE_ID}\" prio 999\n\n\t# set default routes to unreachable\n\tip -netns \"${nsname}\" -6 route \\\n\t\tadd unreachable default metric 4278198272 \\\n\t\tdev \"${DUMMY_DEVNAME}\"\n}\n\n# This helper function builds and installs the SID List (i.e. SRv6 Policy)\n# to be applied on incoming packets at the ingress node. Moreover, it\n# configures the SRv6 nodes specified in the SID List to process the traffic\n# according to the operations required by the Policy itself.\n# args:\n#  $1 - destination host (i.e. cafe::x host)\n#  $2 - SRv6 router configured for enforcing the SRv6 Policy\n#  $3 - compact way to represent a list of SRv6 routers with their operations\n#       (i.e. behaviors) that each of them needs to perform. Every <nodeid:op>\n#       element constructs a SID that is associated with the behavior <op> on\n#       the <nodeid> node. The list of such elements forms an SRv6 Policy.\n__setup_rt_policy()\n{\n\tlocal dst=\"$1\"\n\tlocal encap_rt=\"$2\"\n\tlocal policy_rts=\"$3\"\n\tlocal behavior_cfg\n\tlocal in_nsname\n\tlocal rt_nsname\n\tlocal policy=''\n\tlocal function\n\tlocal fullsid\n\tlocal op_type\n\tlocal node\n\tlocal n\n\n\tin_nsname=\"$(get_rtname \"${encap_rt}\")\"\n\n\tfor n in ${policy_rts}; do\n\t\tnode=\"$(__get_srv6_rtcfg_id \"${n}\")\"\n\t\top_type=\"$(__get_srv6_rtcfg_op \"${n}\")\"\n\t\trt_nsname=\"$(get_rtname \"${node}\")\"\n\n\t\tcase \"${op_type}\" in\n\t\t\"noflv\")\n\t\t\tpolicy=\"${policy}${LOCATOR_SERVICE}:${node}::${END_FUNC},\"\n\t\t\tfunction=\"${END_FUNC}\"\n\t\t\tbehavior_cfg=\"End\"\n\t\t\t;;\n\n\t\t\"psp\")\n\t\t\tpolicy=\"${policy}${LOCATOR_SERVICE}:${node}::${END_PSP_FUNC},\"\n\t\t\tfunction=\"${END_PSP_FUNC}\"\n\t\t\tbehavior_cfg=\"End flavors psp\"\n\t\t\t;;\n\n\t\t*)\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\n\t\tfullsid=\"${LOCATOR_SERVICE}:${node}::${function}\"\n\n\t\t# add SRv6 Endpoint behavior to the selected router\n\t\tif ! ip -netns \"${rt_nsname}\" -6 route get \"${fullsid}\" \\\n\t\t\t&>/dev/null; then\n\t\t\tip -netns \"${rt_nsname}\" -6 route \\\n\t\t\t\tadd \"${fullsid}\" \\\n\t\t\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\t\t\tencap seg6local action ${behavior_cfg} \\\n\t\t\t\tdev \"${DUMMY_DEVNAME}\"\n\t\tfi\n\tdone\n\n\t# we need to remove the trailing comma to avoid inserting an empty\n\t# address (::0) in the SID List.\n\tpolicy=\"${policy%,}\"\n\n\t# add SRv6 policy to incoming traffic sent by connected hosts\n\tip -netns \"${in_nsname}\" -6 route \\\n\t\tadd \"${IPv6_HS_NETWORK}::${dst}\" \\\n\t\tencap seg6 mode inline segs \"${policy}\" \\\n\t\tdev \"${DUMMY_DEVNAME}\"\n\n\tip -netns \"${in_nsname}\" -6 neigh \\\n\t\tadd proxy \"${IPv6_HS_NETWORK}::${dst}\" \\\n\t\tdev \"${RT2HS_DEVNAME}\"\n}\n\n# see __setup_rt_policy\nsetup_rt_policy_ipv6()\n{\n\t__setup_rt_policy \"$1\" \"$2\" \"$3\"\n}\n\nsetup_hs()\n{\n\tlocal hs=\"$1\"\n\tlocal rt=\"$2\"\n\tlocal hsname\n\tlocal rtname\n\n\thsname=\"$(get_hsname \"${hs}\")\"\n\trtname=\"$(get_rtname \"${rt}\")\"\n\n\tip netns exec \"${hsname}\" sysctl -wq net.ipv6.conf.all.accept_dad=0\n\tip netns exec \"${hsname}\" sysctl -wq net.ipv6.conf.default.accept_dad=0\n\n\tip -netns \"${hsname}\" link add veth0 type veth \\\n\t\tpeer name \"${RT2HS_DEVNAME}\" netns \"${rtname}\"\n\n\tip -netns \"${hsname}\" addr \\\n\t\tadd \"${IPv6_HS_NETWORK}::${hs}/64\" dev veth0 nodad\n\n\tip -netns \"${hsname}\" link set veth0 up\n\tip -netns \"${hsname}\" link set lo up\n\n\tip -netns \"${rtname}\" addr \\\n\t\tadd \"${IPv6_HS_NETWORK}::254/64\" dev \"${RT2HS_DEVNAME}\" nodad\n\n\tip -netns \"${rtname}\" link set \"${RT2HS_DEVNAME}\" up\n\n\tip netns exec \"${rtname}\" \\\n\t\tsysctl -wq net.ipv6.conf.\"${RT2HS_DEVNAME}\".proxy_ndp=1\n}\n\nsetup()\n{\n\tlocal i\n\n\t# create routers\n\tROUTERS=\"1 2 3 4\"; readonly ROUTERS\n\tfor i in ${ROUTERS}; do\n\t\tcreate_router \"${i}\"\n\tdone\n\n\t# create hosts\n\tHOSTS=\"1 2\"; readonly HOSTS\n\tfor i in ${HOSTS}; do\n\t\tcreate_host \"${i}\"\n\tdone\n\n\t# set up the links for connecting routers\n\tadd_link_rt_pairs 1 \"2 3 4\"\n\tadd_link_rt_pairs 2 \"3 4\"\n\tadd_link_rt_pairs 3 \"4\"\n\n\t# set up the basic connectivity of routers and routes required for\n\t# reachability of SIDs.\n\tsetup_rt_networking 1 \"2 3 4\"\n\tsetup_rt_networking 2 \"1 3 4\"\n\tsetup_rt_networking 3 \"1 2 4\"\n\tsetup_rt_networking 4 \"1 2 3\"\n\n\t# set up the hosts connected to routers\n\tsetup_hs 1 1\n\tsetup_hs 2 2\n\n\t# set up default SRv6 Endpoints (i.e. SRv6 End behavior)\n\tsetup_rt_local_sids 1 \"2 3 4\"\n\tsetup_rt_local_sids 2 \"1 3 4\"\n\tsetup_rt_local_sids 3 \"1 2 4\"\n\tsetup_rt_local_sids 4 \"1 2 3\"\n\n\t# set up SRv6 policies\n\t# create a connection between hosts hs-1 and hs-2.\n\t# The path between hs-1 and hs-2 traverses SRv6 aware routers.\n\t# For each direction two path are chosen:\n\t#\n\t# Direction hs-1 -> hs-2 (PSP flavor)\n\t#  - rt-1 (SRv6 H.Insert policy)\n\t#  - rt-3 (SRv6 End behavior)\n\t#  - rt-4 (SRv6 End flavor PSP with SL>1, acting as End behavior)\n\t#  - rt-2 (SRv6 End flavor PSP with SL=1)\n\t#\n\t# Direction hs-2 -> hs-1 (PSP flavor)\n\t#  - rt-2 (SRv6 H.Insert policy)\n\t#  - rt-1 (SRv6 End flavor PSP with SL=1)\n\tsetup_rt_policy_ipv6 2 1 \"3:noflv 4:psp 2:psp\"\n\tsetup_rt_policy_ipv6 1 2 \"1:psp\"\n\n\t# testing environment was set up successfully\n\tSETUP_ERR=0\n}\n\ncheck_rt_connectivity()\n{\n\tlocal rtsrc=\"$1\"\n\tlocal rtdst=\"$2\"\n\tlocal prefix\n\tlocal rtsrc_nsname\n\n\trtsrc_nsname=\"$(get_rtname \"${rtsrc}\")\"\n\n\tprefix=\"$(get_network_prefix \"${rtsrc}\" \"${rtdst}\")\"\n\n\tip netns exec \"${rtsrc_nsname}\" ping -c 1 -W \"${PING_TIMEOUT_SEC}\" \\\n\t\t\"${prefix}::${rtdst}\" >/dev/null 2>&1\n}\n\ncheck_and_log_rt_connectivity()\n{\n\tlocal rtsrc=\"$1\"\n\tlocal rtdst=\"$2\"\n\n\tcheck_rt_connectivity \"${rtsrc}\" \"${rtdst}\"\n\tlog_test $? 0 \"Routers connectivity: rt-${rtsrc} -> rt-${rtdst}\"\n}\n\ncheck_hs_ipv6_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\tlocal hssrc_nsname\n\n\thssrc_nsname=\"$(get_hsname \"${hssrc}\")\"\n\n\tip netns exec \"${hssrc_nsname}\" ping -c 1 -W \"${PING_TIMEOUT_SEC}\" \\\n\t\t\"${IPv6_HS_NETWORK}::${hsdst}\" >/dev/null 2>&1\n}\n\ncheck_and_log_hs2gw_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\n\tcheck_hs_ipv6_connectivity \"${hssrc}\" 254\n\tlog_test $? 0 \"IPv6 Hosts connectivity: hs-${hssrc} -> gw\"\n}\n\ncheck_and_log_hs_ipv6_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\n\tcheck_hs_ipv6_connectivity \"${hssrc}\" \"${hsdst}\"\n\tlog_test $? 0 \"IPv6 Hosts connectivity: hs-${hssrc} -> hs-${hsdst}\"\n}\n\ncheck_and_log_hs_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\n\tcheck_and_log_hs_ipv6_connectivity \"${hssrc}\" \"${hsdst}\"\n}\n\nrouter_tests()\n{\n\tlocal i\n\tlocal j\n\n\tlog_section \"IPv6 routers connectivity test\"\n\n\tfor i in ${ROUTERS}; do\n\t\tfor j in ${ROUTERS}; do\n\t\t\tif [ \"${i}\" -eq \"${j}\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\tcheck_and_log_rt_connectivity \"${i}\" \"${j}\"\n\t\tdone\n\tdone\n}\n\nhost2gateway_tests()\n{\n\tlocal hs\n\n\tlog_section \"IPv6 connectivity test among hosts and gateways\"\n\n\tfor hs in ${HOSTS}; do\n\t\tcheck_and_log_hs2gw_connectivity \"${hs}\"\n\tdone\n}\n\nhost_srv6_end_flv_psp_tests()\n{\n\tlog_section \"SRv6 connectivity test hosts (h1 <-> h2, PSP flavor)\"\n\n\tcheck_and_log_hs_connectivity 1 2\n\tcheck_and_log_hs_connectivity 2 1\n}\n\ntest_iproute2_supp_or_ksft_skip()\n{\n\tlocal flavor=\"$1\"\n\n\tif ! ip route help 2>&1 | grep -qo \"${flavor}\"; then\n\t\techo \"SKIP: Missing SRv6 ${flavor} flavor support in iproute2\"\n\t\texit \"${ksft_skip}\"\n\tfi\n}\n\ntest_kernel_supp_or_ksft_skip()\n{\n\tlocal flavor=\"$1\"\n\tlocal test_netns\n\n\ttest_netns=\"kflv-$(mktemp -u XXXXXXXX)\"\n\n\tif ! ip netns add \"${test_netns}\"; then\n\t\techo \"SKIP: Cannot set up netns to test kernel support for flavors\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\tif ! ip -netns \"${test_netns}\" link \\\n\t\tadd \"${DUMMY_DEVNAME}\" type dummy; then\n\t\techo \"SKIP: Cannot set up dummy dev to test kernel support for flavors\"\n\n\t\tip netns del \"${test_netns}\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\tif ! ip -netns \"${test_netns}\" link \\\n\t\tset \"${DUMMY_DEVNAME}\" up; then\n\t\techo \"SKIP: Cannot activate dummy dev to test kernel support for flavors\"\n\n\t\tip netns del \"${test_netns}\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\tif ! ip -netns \"${test_netns}\" -6 route \\\n\t\tadd \"${IPv6_TESTS_ADDR}\" encap seg6local \\\n\t\taction End flavors \"${flavor}\" dev \"${DUMMY_DEVNAME}\"; then\n\t\techo \"SKIP: ${flavor} flavor not supported in kernel\"\n\n\t\tip netns del \"${test_netns}\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\tip netns del \"${test_netns}\"\n}\n\ntest_dummy_dev_or_ksft_skip()\n{\n\tlocal test_netns\n\n\ttest_netns=\"dummy-$(mktemp -u XXXXXXXX)\"\n\n\tif ! ip netns add \"${test_netns}\"; then\n\t\techo \"SKIP: Cannot set up netns for testing dummy dev support\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\tmodprobe dummy &>/dev/null || true\n\tif ! ip -netns \"${test_netns}\" link \\\n\t\tadd \"${DUMMY_DEVNAME}\" type dummy; then\n\t\techo \"SKIP: dummy dev not supported\"\n\n\t\tip netns del \"${test_netns}\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\tip netns del \"${test_netns}\"\n}\n\nif [ \"$(id -u)\" -ne 0 ]; then\n\techo \"SKIP: Need root privileges\"\n\texit \"${ksft_skip}\"\nfi\n\n# required programs to carry out this selftest\ntest_command_or_ksft_skip ip\ntest_command_or_ksft_skip ping\ntest_command_or_ksft_skip sysctl\ntest_command_or_ksft_skip grep\ntest_command_or_ksft_skip cut\ntest_command_or_ksft_skip sed\ntest_command_or_ksft_skip sort\ntest_command_or_ksft_skip xargs\n\ntest_dummy_dev_or_ksft_skip\ntest_iproute2_supp_or_ksft_skip psp\ntest_kernel_supp_or_ksft_skip psp\n\nset -e\ntrap cleanup EXIT\n\nsetup\nset +e\n\nrouter_tests\nhost2gateway_tests\nhost_srv6_end_flv_psp_tests\n\nprint_log_test_results\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}