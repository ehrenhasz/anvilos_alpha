{
  "module_name": "bind_bhash.c",
  "hash_id": "c53d74dc6c7f4bc73993dc2fef185d98945efdc8b0f12d02f0709d87b0e9d8c9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/bind_bhash.c",
  "human_readable_source": "\n \n\n#include <unistd.h>\n#include <stdio.h>\n#include <netdb.h>\n#include <pthread.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_THREADS 600\n#define MAX_CONNECTIONS 40\n\nstatic const char *setup_addr_v6 = \"::1\";\nstatic const char *setup_addr_v4 = \"127.0.0.1\";\nstatic const char *setup_addr;\nstatic const char *bind_addr;\nstatic const char *port;\nbool use_v6;\nint ret;\n\nstatic int fd_array[MAX_THREADS][MAX_CONNECTIONS];\n\nstatic int bind_socket(int opt, const char *addr)\n{\n\tstruct addrinfo *res, hint = {};\n\tint sock_fd, reuse = 1, err;\n\tint domain = use_v6 ? AF_INET6 : AF_INET;\n\n\tsock_fd = socket(domain, SOCK_STREAM, 0);\n\tif (sock_fd < 0) {\n\t\tperror(\"socket fd err\");\n\t\treturn sock_fd;\n\t}\n\n\thint.ai_family = domain;\n\thint.ai_socktype = SOCK_STREAM;\n\n\terr = getaddrinfo(addr, port, &hint, &res);\n\tif (err) {\n\t\tperror(\"getaddrinfo failed\");\n\t\tgoto cleanup;\n\t}\n\n\tif (opt) {\n\t\terr = setsockopt(sock_fd, SOL_SOCKET, opt, &reuse, sizeof(reuse));\n\t\tif (err) {\n\t\t\tperror(\"setsockopt failed\");\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\terr = bind(sock_fd, res->ai_addr, res->ai_addrlen);\n\tif (err) {\n\t\tperror(\"failed to bind to port\");\n\t\tgoto cleanup;\n\t}\n\n\treturn sock_fd;\n\ncleanup:\n\tclose(sock_fd);\n\treturn err;\n}\n\nstatic void *setup(void *arg)\n{\n\tint sock_fd, i;\n\tint *array = (int *)arg;\n\n\tfor (i = 0; i < MAX_CONNECTIONS; i++) {\n\t\tsock_fd = bind_socket(SO_REUSEADDR | SO_REUSEPORT, setup_addr);\n\t\tif (sock_fd < 0) {\n\t\t\tret = sock_fd;\n\t\t\tpthread_exit(&ret);\n\t\t}\n\t\tarray[i] = sock_fd;\n\t}\n\n\treturn NULL;\n}\n\nint main(int argc, const char *argv[])\n{\n\tint listener_fd, sock_fd, i, j;\n\tpthread_t tid[MAX_THREADS];\n\tclock_t begin, end;\n\n\tif (argc != 4) {\n\t\tprintf(\"Usage: listener <port> <ipv6 | ipv4> <bind-addr>\\n\");\n\t\treturn -1;\n\t}\n\n\tport = argv[1];\n\tuse_v6 = strcmp(argv[2], \"ipv6\") == 0;\n\tbind_addr = argv[3];\n\n\tsetup_addr = use_v6 ? setup_addr_v6 : setup_addr_v4;\n\n\tlistener_fd = bind_socket(SO_REUSEADDR | SO_REUSEPORT, setup_addr);\n\tif (listen(listener_fd, 100) < 0) {\n\t\tperror(\"listen failed\");\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_THREADS; i++)\n\t\tpthread_create(&tid[i], NULL, setup, fd_array[i]);\n\n\tfor (i = 0; i < MAX_THREADS; i++)\n\t\tpthread_join(tid[i], NULL);\n\n\tif (ret)\n\t\tgoto done;\n\n\tbegin = clock();\n\n\t \n\tsock_fd  = bind_socket(0, bind_addr);\n\tif (sock_fd < 0)\n\t\tgoto done;\n\n\tend = clock();\n\n\tprintf(\"time spent = %f\\n\", (double)(end - begin) / CLOCKS_PER_SEC);\n\n\t \n\tclose(sock_fd);\n\ndone:\n\tclose(listener_fd);\n\tfor (i = 0; i < MAX_THREADS; i++) {\n\t\tfor (j = 0; i < MAX_THREADS; i++)\n\t\t\tclose(fd_array[i][j]);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}