{
  "module_name": "ipv6_flowlabel.c",
  "hash_id": "f763e1a7501aceccc8f4378f1259f2f9884220491248032044cad4e6bc8e67bc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/ipv6_flowlabel.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <asm/byteorder.h>\n#include <error.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/icmpv6.h>\n#include <linux/in6.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n \n#ifndef IPV6_FLOWINFO\n#define IPV6_FLOWINFO 11\n#endif\n\n#ifndef IPV6_FLOWLABEL_MGR\n#define IPV6_FLOWLABEL_MGR 32\n#endif\n#ifndef IPV6_FLOWINFO_SEND\n#define IPV6_FLOWINFO_SEND 33\n#endif\n\n#define FLOWLABEL_WILDCARD\t((uint32_t) -1)\n\nstatic const char cfg_data[]\t= \"a\";\nstatic uint32_t cfg_label\t= 1;\nstatic bool use_ping;\nstatic bool use_flowinfo_send;\n\nstatic struct icmp6hdr icmp6 = {\n\t.icmp6_type = ICMPV6_ECHO_REQUEST\n};\n\nstatic struct sockaddr_in6 addr = {\n\t.sin6_family = AF_INET6,\n\t.sin6_addr = IN6ADDR_LOOPBACK_INIT,\n};\n\nstatic void do_send(int fd, bool with_flowlabel, uint32_t flowlabel)\n{\n\tchar control[CMSG_SPACE(sizeof(flowlabel))] = {0};\n\tstruct msghdr msg = {0};\n\tstruct iovec iov = {\n\t\t.iov_base = (char *)cfg_data,\n\t\t.iov_len = sizeof(cfg_data)\n\t};\n\tint ret;\n\n\tif (use_ping) {\n\t\tiov.iov_base = &icmp6;\n\t\tiov.iov_len = sizeof(icmp6);\n\t}\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tif (use_flowinfo_send) {\n\t\tmsg.msg_name = &addr;\n\t\tmsg.msg_namelen = sizeof(addr);\n\t} else if (with_flowlabel) {\n\t\tstruct cmsghdr *cm;\n\n\t\tcm = (void *)control;\n\t\tcm->cmsg_len = CMSG_LEN(sizeof(flowlabel));\n\t\tcm->cmsg_level = SOL_IPV6;\n\t\tcm->cmsg_type = IPV6_FLOWINFO;\n\t\t*(uint32_t *)CMSG_DATA(cm) = htonl(flowlabel);\n\n\t\tmsg.msg_control = control;\n\t\tmsg.msg_controllen = sizeof(control);\n\t}\n\n\tret = sendmsg(fd, &msg, 0);\n\tif (ret == -1)\n\t\terror(1, errno, \"send\");\n\n\tif (with_flowlabel)\n\t\tfprintf(stderr, \"sent with label %u\\n\", flowlabel);\n\telse\n\t\tfprintf(stderr, \"sent without label\\n\");\n}\n\nstatic void do_recv(int fd, bool with_flowlabel, uint32_t expect)\n{\n\tchar control[CMSG_SPACE(sizeof(expect))];\n\tchar data[sizeof(cfg_data)];\n\tstruct msghdr msg = {0};\n\tstruct iovec iov = {0};\n\tstruct cmsghdr *cm;\n\tuint32_t flowlabel;\n\tint ret;\n\n\tiov.iov_base = data;\n\tiov.iov_len = sizeof(data);\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tmemset(control, 0, sizeof(control));\n\tmsg.msg_control = control;\n\tmsg.msg_controllen = sizeof(control);\n\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret == -1)\n\t\terror(1, errno, \"recv\");\n\tif (use_ping)\n\t\tgoto parse_cmsg;\n\tif (msg.msg_flags & (MSG_TRUNC | MSG_CTRUNC))\n\t\terror(1, 0, \"recv: truncated\");\n\tif (ret != sizeof(cfg_data))\n\t\terror(1, 0, \"recv: length mismatch\");\n\tif (memcmp(data, cfg_data, sizeof(data)))\n\t\terror(1, 0, \"recv: data mismatch\");\n\nparse_cmsg:\n\tcm = CMSG_FIRSTHDR(&msg);\n\tif (with_flowlabel) {\n\t\tif (!cm)\n\t\t\terror(1, 0, \"recv: missing cmsg\");\n\t\tif (CMSG_NXTHDR(&msg, cm))\n\t\t\terror(1, 0, \"recv: too many cmsg\");\n\t\tif (cm->cmsg_level != SOL_IPV6 ||\n\t\t    cm->cmsg_type != IPV6_FLOWINFO)\n\t\t\terror(1, 0, \"recv: unexpected cmsg level or type\");\n\n\t\tflowlabel = ntohl(*(uint32_t *)CMSG_DATA(cm));\n\t\tfprintf(stderr, \"recv with label %u\\n\", flowlabel);\n\n\t\tif (expect != FLOWLABEL_WILDCARD && expect != flowlabel) {\n\t\t\tfprintf(stderr, \"recv: incorrect flowlabel %u != %u\\n\",\n\t\t\t\t\tflowlabel, expect);\n\t\t\terror(1, 0, \"recv: flowlabel is wrong\");\n\t\t}\n\n\t} else {\n\t\tfprintf(stderr, \"recv without label\\n\");\n\t}\n}\n\nstatic bool get_autoflowlabel_enabled(void)\n{\n\tint fd, ret;\n\tchar val;\n\n\tfd = open(\"/proc/sys/net/ipv6/auto_flowlabels\", O_RDONLY);\n\tif (fd == -1)\n\t\terror(1, errno, \"open sysctl\");\n\n\tret = read(fd, &val, 1);\n\tif (ret == -1)\n\t\terror(1, errno, \"read sysctl\");\n\tif (ret == 0)\n\t\terror(1, 0, \"read sysctl: 0\");\n\n\tif (close(fd))\n\t\terror(1, errno, \"close sysctl\");\n\n\treturn val == '1';\n}\n\nstatic void flowlabel_get(int fd, uint32_t label, uint8_t share, uint16_t flags)\n{\n\tstruct in6_flowlabel_req req = {\n\t\t.flr_action = IPV6_FL_A_GET,\n\t\t.flr_label = htonl(label),\n\t\t.flr_flags = flags,\n\t\t.flr_share = share,\n\t};\n\n\t \n\treq.flr_dst.s6_addr[0] = 0xfd;\n\treq.flr_dst.s6_addr[15] = 0x1;\n\n\tif (setsockopt(fd, SOL_IPV6, IPV6_FLOWLABEL_MGR, &req, sizeof(req)))\n\t\terror(1, errno, \"setsockopt flowlabel get\");\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"l:ps\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'l':\n\t\t\tcfg_label = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tuse_ping = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tuse_flowinfo_send = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"%s: parse error\", argv[0]);\n\t\t}\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tconst int one = 1;\n\tint fdt, fdr;\n\tint prot = 0;\n\n\taddr.sin6_port = htons(8000);\n\n\tparse_opts(argc, argv);\n\n\tif (use_ping) {\n\t\tfprintf(stderr, \"attempting to use ping sockets\\n\");\n\t\tprot = IPPROTO_ICMPV6;\n\t}\n\n\tfdt = socket(PF_INET6, SOCK_DGRAM, prot);\n\tif (fdt == -1)\n\t\terror(1, errno, \"socket t\");\n\n\tfdr = use_ping ? fdt : socket(PF_INET6, SOCK_DGRAM, 0);\n\tif (fdr == -1)\n\t\terror(1, errno, \"socket r\");\n\n\tif (connect(fdt, (void *)&addr, sizeof(addr)))\n\t\terror(1, errno, \"connect\");\n\tif (!use_ping && bind(fdr, (void *)&addr, sizeof(addr)))\n\t\terror(1, errno, \"bind\");\n\n\tflowlabel_get(fdt, cfg_label, IPV6_FL_S_EXCL, IPV6_FL_F_CREATE);\n\n\tif (setsockopt(fdr, SOL_IPV6, IPV6_FLOWINFO, &one, sizeof(one)))\n\t\terror(1, errno, \"setsockopt flowinfo\");\n\n\tif (get_autoflowlabel_enabled()) {\n\t\tfprintf(stderr, \"send no label: recv auto flowlabel\\n\");\n\t\tdo_send(fdt, false, 0);\n\t\tdo_recv(fdr, true, FLOWLABEL_WILDCARD);\n\t} else {\n\t\tfprintf(stderr, \"send no label: recv no label (auto off)\\n\");\n\t\tdo_send(fdt, false, 0);\n\t\tdo_recv(fdr, false, 0);\n\t}\n\n\tif (use_flowinfo_send) {\n\t\tfprintf(stderr, \"using IPV6_FLOWINFO_SEND to send label\\n\");\n\t\taddr.sin6_flowinfo = htonl(cfg_label);\n\t\tif (setsockopt(fdt, SOL_IPV6, IPV6_FLOWINFO_SEND, &one,\n\t\t\t       sizeof(one)) == -1)\n\t\t\terror(1, errno, \"setsockopt flowinfo_send\");\n\t}\n\n\tfprintf(stderr, \"send label\\n\");\n\tdo_send(fdt, true, cfg_label);\n\tdo_recv(fdr, true, cfg_label);\n\n\tif (close(fdr))\n\t\terror(1, errno, \"close r\");\n\tif (!use_ping && close(fdt))\n\t\terror(1, errno, \"close t\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}