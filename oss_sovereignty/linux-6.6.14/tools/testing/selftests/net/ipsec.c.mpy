{
  "module_name": "ipsec.c",
  "hash_id": "7a5d7c61e440164b3988bebde8b19560fd068f74ebf3caa5499c22f00762123b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/ipsec.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <asm/types.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/limits.h>\n#include <linux/netlink.h>\n#include <linux/random.h>\n#include <linux/rtnetlink.h>\n#include <linux/veth.h>\n#include <linux/xfrm.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sched.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"../kselftest.h\"\n\n#define printk(fmt, ...)\t\t\t\t\t\t\\\n\tksft_print_msg(\"%d[%u] \" fmt \"\\n\", getpid(), __LINE__, ##__VA_ARGS__)\n\n#define pr_err(fmt, ...)\tprintk(fmt \": %m\", ##__VA_ARGS__)\n\n#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))\n\n#define IPV4_STR_SZ\t16\t \n#define MAX_PAYLOAD\t2048\n#define XFRM_ALGO_KEY_BUF_SIZE\t512\n#define MAX_PROCESSES\t(1 << 14)  \n#define INADDR_A\t((in_addr_t) 0x0a000000)  \n#define INADDR_B\t((in_addr_t) 0xc0a80000)  \n\n \n#define PREFIX_LEN\t30\n#define child_ip(nr)\t(4*nr + 1)\n#define grchild_ip(nr)\t(4*nr + 2)\n\n#define VETH_FMT\t\"ktst-%d\"\n#define VETH_LEN\t12\n\n#define XFRM_ALGO_NR_KEYS 29\n\nstatic int nsfd_parent\t= -1;\nstatic int nsfd_childa\t= -1;\nstatic int nsfd_childb\t= -1;\nstatic long page_size;\n\n \nstatic int results_fd[2];\n\nconst unsigned int ping_delay_nsec\t= 50 * 1000 * 1000;\nconst unsigned int ping_timeout\t\t= 300;\nconst unsigned int ping_count\t\t= 100;\nconst unsigned int ping_success\t\t= 80;\n\nstruct xfrm_key_entry {\n\tchar algo_name[35];\n\tint key_len;\n};\n\nstruct xfrm_key_entry xfrm_key_entries[] = {\n\t{\"digest_null\", 0},\n\t{\"ecb(cipher_null)\", 0},\n\t{\"cbc(des)\", 64},\n\t{\"hmac(md5)\", 128},\n\t{\"cmac(aes)\", 128},\n\t{\"xcbc(aes)\", 128},\n\t{\"cbc(cast5)\", 128},\n\t{\"cbc(serpent)\", 128},\n\t{\"hmac(sha1)\", 160},\n\t{\"hmac(rmd160)\", 160},\n\t{\"cbc(des3_ede)\", 192},\n\t{\"hmac(sha256)\", 256},\n\t{\"cbc(aes)\", 256},\n\t{\"cbc(camellia)\", 256},\n\t{\"cbc(twofish)\", 256},\n\t{\"rfc3686(ctr(aes))\", 288},\n\t{\"hmac(sha384)\", 384},\n\t{\"cbc(blowfish)\", 448},\n\t{\"hmac(sha512)\", 512},\n\t{\"rfc4106(gcm(aes))-128\", 160},\n\t{\"rfc4543(gcm(aes))-128\", 160},\n\t{\"rfc4309(ccm(aes))-128\", 152},\n\t{\"rfc4106(gcm(aes))-192\", 224},\n\t{\"rfc4543(gcm(aes))-192\", 224},\n\t{\"rfc4309(ccm(aes))-192\", 216},\n\t{\"rfc4106(gcm(aes))-256\", 288},\n\t{\"rfc4543(gcm(aes))-256\", 288},\n\t{\"rfc4309(ccm(aes))-256\", 280},\n\t{\"rfc7539(chacha20,poly1305)-128\", 0}\n};\n\nstatic void randomize_buffer(void *buf, size_t buflen)\n{\n\tint *p = (int *)buf;\n\tsize_t words = buflen / sizeof(int);\n\tsize_t leftover = buflen % sizeof(int);\n\n\tif (!buflen)\n\t\treturn;\n\n\twhile (words--)\n\t\t*p++ = rand();\n\n\tif (leftover) {\n\t\tint tmp = rand();\n\n\t\tmemcpy(buf + buflen - leftover, &tmp, leftover);\n\t}\n\n\treturn;\n}\n\nstatic int unshare_open(void)\n{\n\tconst char *netns_path = \"/proc/self/ns/net\";\n\tint fd;\n\n\tif (unshare(CLONE_NEWNET) != 0) {\n\t\tpr_err(\"unshare()\");\n\t\treturn -1;\n\t}\n\n\tfd = open(netns_path, O_RDONLY);\n\tif (fd <= 0) {\n\t\tpr_err(\"open(%s)\", netns_path);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic int switch_ns(int fd)\n{\n\tif (setns(fd, CLONE_NEWNET)) {\n\t\tpr_err(\"setns()\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int init_namespaces(void)\n{\n\tnsfd_parent = unshare_open();\n\tif (nsfd_parent <= 0)\n\t\treturn -1;\n\n\tnsfd_childa = unshare_open();\n\tif (nsfd_childa <= 0)\n\t\treturn -1;\n\n\tif (switch_ns(nsfd_parent))\n\t\treturn -1;\n\n\tnsfd_childb = unshare_open();\n\tif (nsfd_childb <= 0)\n\t\treturn -1;\n\n\tif (switch_ns(nsfd_parent))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int netlink_sock(int *sock, uint32_t *seq_nr, int proto)\n{\n\tif (*sock > 0) {\n\t\tseq_nr++;\n\t\treturn 0;\n\t}\n\n\t*sock = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, proto);\n\tif (*sock <= 0) {\n\t\tpr_err(\"socket(AF_NETLINK)\");\n\t\treturn -1;\n\t}\n\n\trandomize_buffer(seq_nr, sizeof(*seq_nr));\n\n\treturn 0;\n}\n\nstatic inline struct rtattr *rtattr_hdr(struct nlmsghdr *nh)\n{\n\treturn (struct rtattr *)((char *)(nh) + RTA_ALIGN((nh)->nlmsg_len));\n}\n\nstatic int rtattr_pack(struct nlmsghdr *nh, size_t req_sz,\n\t\tunsigned short rta_type, const void *payload, size_t size)\n{\n\t \n\tstruct rtattr *attr = rtattr_hdr(nh);\n\tsize_t nl_size = RTA_ALIGN(nh->nlmsg_len) + RTA_LENGTH(size);\n\n\tif (req_sz < nl_size) {\n\t\tprintk(\"req buf is too small: %zu < %zu\", req_sz, nl_size);\n\t\treturn -1;\n\t}\n\tnh->nlmsg_len = nl_size;\n\n\tattr->rta_len = RTA_LENGTH(size);\n\tattr->rta_type = rta_type;\n\tmemcpy(RTA_DATA(attr), payload, size);\n\n\treturn 0;\n}\n\nstatic struct rtattr *_rtattr_begin(struct nlmsghdr *nh, size_t req_sz,\n\t\tunsigned short rta_type, const void *payload, size_t size)\n{\n\tstruct rtattr *ret = rtattr_hdr(nh);\n\n\tif (rtattr_pack(nh, req_sz, rta_type, payload, size))\n\t\treturn 0;\n\n\treturn ret;\n}\n\nstatic inline struct rtattr *rtattr_begin(struct nlmsghdr *nh, size_t req_sz,\n\t\tunsigned short rta_type)\n{\n\treturn _rtattr_begin(nh, req_sz, rta_type, 0, 0);\n}\n\nstatic inline void rtattr_end(struct nlmsghdr *nh, struct rtattr *attr)\n{\n\tchar *nlmsg_end = (char *)nh + nh->nlmsg_len;\n\n\tattr->rta_len = nlmsg_end - (char *)attr;\n}\n\nstatic int veth_pack_peerb(struct nlmsghdr *nh, size_t req_sz,\n\t\tconst char *peer, int ns)\n{\n\tstruct ifinfomsg pi;\n\tstruct rtattr *peer_attr;\n\n\tmemset(&pi, 0, sizeof(pi));\n\tpi.ifi_family\t= AF_UNSPEC;\n\tpi.ifi_change\t= 0xFFFFFFFF;\n\n\tpeer_attr = _rtattr_begin(nh, req_sz, VETH_INFO_PEER, &pi, sizeof(pi));\n\tif (!peer_attr)\n\t\treturn -1;\n\n\tif (rtattr_pack(nh, req_sz, IFLA_IFNAME, peer, strlen(peer)))\n\t\treturn -1;\n\n\tif (rtattr_pack(nh, req_sz, IFLA_NET_NS_FD, &ns, sizeof(ns)))\n\t\treturn -1;\n\n\trtattr_end(nh, peer_attr);\n\n\treturn 0;\n}\n\nstatic int netlink_check_answer(int sock)\n{\n\tstruct nlmsgerror {\n\t\tstruct nlmsghdr hdr;\n\t\tint error;\n\t\tstruct nlmsghdr orig_msg;\n\t} answer;\n\n\tif (recv(sock, &answer, sizeof(answer), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\treturn -1;\n\t} else if (answer.hdr.nlmsg_type != NLMSG_ERROR) {\n\t\tprintk(\"expected NLMSG_ERROR, got %d\", (int)answer.hdr.nlmsg_type);\n\t\treturn -1;\n\t} else if (answer.error) {\n\t\tprintk(\"NLMSG_ERROR: %d: %s\",\n\t\t\tanswer.error, strerror(-answer.error));\n\t\treturn answer.error;\n\t}\n\n\treturn 0;\n}\n\nstatic int veth_add(int sock, uint32_t seq, const char *peera, int ns_a,\n\t\tconst char *peerb, int ns_b)\n{\n\tuint16_t flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_EXCL | NLM_F_CREATE;\n\tstruct {\n\t\tstruct nlmsghdr\t\tnh;\n\t\tstruct ifinfomsg\tinfo;\n\t\tchar\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\tconst char veth_type[] = \"veth\";\n\tstruct rtattr *link_info, *info_data;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.info));\n\treq.nh.nlmsg_type\t= RTM_NEWLINK;\n\treq.nh.nlmsg_flags\t= flags;\n\treq.nh.nlmsg_seq\t= seq;\n\treq.info.ifi_family\t= AF_UNSPEC;\n\treq.info.ifi_change\t= 0xFFFFFFFF;\n\n\tif (rtattr_pack(&req.nh, sizeof(req), IFLA_IFNAME, peera, strlen(peera)))\n\t\treturn -1;\n\n\tif (rtattr_pack(&req.nh, sizeof(req), IFLA_NET_NS_FD, &ns_a, sizeof(ns_a)))\n\t\treturn -1;\n\n\tlink_info = rtattr_begin(&req.nh, sizeof(req), IFLA_LINKINFO);\n\tif (!link_info)\n\t\treturn -1;\n\n\tif (rtattr_pack(&req.nh, sizeof(req), IFLA_INFO_KIND, veth_type, sizeof(veth_type)))\n\t\treturn -1;\n\n\tinfo_data = rtattr_begin(&req.nh, sizeof(req), IFLA_INFO_DATA);\n\tif (!info_data)\n\t\treturn -1;\n\n\tif (veth_pack_peerb(&req.nh, sizeof(req), peerb, ns_b))\n\t\treturn -1;\n\n\trtattr_end(&req.nh, info_data);\n\trtattr_end(&req.nh, link_info);\n\n\tif (send(sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\treturn netlink_check_answer(sock);\n}\n\nstatic int ip4_addr_set(int sock, uint32_t seq, const char *intf,\n\t\tstruct in_addr addr, uint8_t prefix)\n{\n\tuint16_t flags = NLM_F_REQUEST | NLM_F_ACK | NLM_F_EXCL | NLM_F_CREATE;\n\tstruct {\n\t\tstruct nlmsghdr\t\tnh;\n\t\tstruct ifaddrmsg\tinfo;\n\t\tchar\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.info));\n\treq.nh.nlmsg_type\t= RTM_NEWADDR;\n\treq.nh.nlmsg_flags\t= flags;\n\treq.nh.nlmsg_seq\t= seq;\n\treq.info.ifa_family\t= AF_INET;\n\treq.info.ifa_prefixlen\t= prefix;\n\treq.info.ifa_index\t= if_nametoindex(intf);\n\n#ifdef DEBUG\n\t{\n\t\tchar addr_str[IPV4_STR_SZ] = {};\n\n\t\tstrncpy(addr_str, inet_ntoa(addr), IPV4_STR_SZ - 1);\n\n\t\tprintk(\"ip addr set %s\", addr_str);\n\t}\n#endif\n\n\tif (rtattr_pack(&req.nh, sizeof(req), IFA_LOCAL, &addr, sizeof(addr)))\n\t\treturn -1;\n\n\tif (rtattr_pack(&req.nh, sizeof(req), IFA_ADDRESS, &addr, sizeof(addr)))\n\t\treturn -1;\n\n\tif (send(sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\treturn netlink_check_answer(sock);\n}\n\nstatic int link_set_up(int sock, uint32_t seq, const char *intf)\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\tnh;\n\t\tstruct ifinfomsg\tinfo;\n\t\tchar\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.info));\n\treq.nh.nlmsg_type\t= RTM_NEWLINK;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_seq\t= seq;\n\treq.info.ifi_family\t= AF_UNSPEC;\n\treq.info.ifi_change\t= 0xFFFFFFFF;\n\treq.info.ifi_index\t= if_nametoindex(intf);\n\treq.info.ifi_flags\t= IFF_UP;\n\treq.info.ifi_change\t= IFF_UP;\n\n\tif (send(sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\treturn netlink_check_answer(sock);\n}\n\nstatic int ip4_route_set(int sock, uint32_t seq, const char *intf,\n\t\tstruct in_addr src, struct in_addr dst)\n{\n\tstruct {\n\t\tstruct nlmsghdr\tnh;\n\t\tstruct rtmsg\trt;\n\t\tchar\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\tunsigned int index = if_nametoindex(intf);\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.rt));\n\treq.nh.nlmsg_type\t= RTM_NEWROUTE;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK | NLM_F_CREATE;\n\treq.nh.nlmsg_seq\t= seq;\n\treq.rt.rtm_family\t= AF_INET;\n\treq.rt.rtm_dst_len\t= 32;\n\treq.rt.rtm_table\t= RT_TABLE_MAIN;\n\treq.rt.rtm_protocol\t= RTPROT_BOOT;\n\treq.rt.rtm_scope\t= RT_SCOPE_LINK;\n\treq.rt.rtm_type\t\t= RTN_UNICAST;\n\n\tif (rtattr_pack(&req.nh, sizeof(req), RTA_DST, &dst, sizeof(dst)))\n\t\treturn -1;\n\n\tif (rtattr_pack(&req.nh, sizeof(req), RTA_PREFSRC, &src, sizeof(src)))\n\t\treturn -1;\n\n\tif (rtattr_pack(&req.nh, sizeof(req), RTA_OIF, &index, sizeof(index)))\n\t\treturn -1;\n\n\tif (send(sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\n\treturn netlink_check_answer(sock);\n}\n\nstatic int tunnel_set_route(int route_sock, uint32_t *route_seq, char *veth,\n\t\tstruct in_addr tunsrc, struct in_addr tundst)\n{\n\tif (ip4_addr_set(route_sock, (*route_seq)++, \"lo\",\n\t\t\ttunsrc, PREFIX_LEN)) {\n\t\tprintk(\"Failed to set ipv4 addr\");\n\t\treturn -1;\n\t}\n\n\tif (ip4_route_set(route_sock, (*route_seq)++, veth, tunsrc, tundst)) {\n\t\tprintk(\"Failed to set ipv4 route\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_child(int nsfd, char *veth, unsigned int src, unsigned int dst)\n{\n\tstruct in_addr intsrc = inet_makeaddr(INADDR_B, src);\n\tstruct in_addr tunsrc = inet_makeaddr(INADDR_A, src);\n\tstruct in_addr tundst = inet_makeaddr(INADDR_A, dst);\n\tint route_sock = -1, ret = -1;\n\tuint32_t route_seq;\n\n\tif (switch_ns(nsfd))\n\t\treturn -1;\n\n\tif (netlink_sock(&route_sock, &route_seq, NETLINK_ROUTE)) {\n\t\tprintk(\"Failed to open netlink route socket in child\");\n\t\treturn -1;\n\t}\n\n\tif (ip4_addr_set(route_sock, route_seq++, veth, intsrc, PREFIX_LEN)) {\n\t\tprintk(\"Failed to set ipv4 addr\");\n\t\tgoto err;\n\t}\n\n\tif (link_set_up(route_sock, route_seq++, veth)) {\n\t\tprintk(\"Failed to bring up %s\", veth);\n\t\tgoto err;\n\t}\n\n\tif (tunnel_set_route(route_sock, &route_seq, veth, tunsrc, tundst)) {\n\t\tprintk(\"Failed to add tunnel route on %s\", veth);\n\t\tgoto err;\n\t}\n\tret = 0;\n\nerr:\n\tclose(route_sock);\n\treturn ret;\n}\n\n#define ALGO_LEN\t64\nenum desc_type {\n\tCREATE_TUNNEL\t= 0,\n\tALLOCATE_SPI,\n\tMONITOR_ACQUIRE,\n\tEXPIRE_STATE,\n\tEXPIRE_POLICY,\n\tSPDINFO_ATTRS,\n};\nconst char *desc_name[] = {\n\t\"create tunnel\",\n\t\"alloc spi\",\n\t\"monitor acquire\",\n\t\"expire state\",\n\t\"expire policy\",\n\t\"spdinfo attributes\",\n\t\"\"\n};\nstruct xfrm_desc {\n\tenum desc_type\ttype;\n\tuint8_t\t\tproto;\n\tchar\t\ta_algo[ALGO_LEN];\n\tchar\t\te_algo[ALGO_LEN];\n\tchar\t\tc_algo[ALGO_LEN];\n\tchar\t\tae_algo[ALGO_LEN];\n\tunsigned int\ticv_len;\n\t \n};\n\nenum msg_type {\n\tMSG_ACK\t\t= 0,\n\tMSG_EXIT,\n\tMSG_PING,\n\tMSG_XFRM_PREPARE,\n\tMSG_XFRM_ADD,\n\tMSG_XFRM_DEL,\n\tMSG_XFRM_CLEANUP,\n};\n\nstruct test_desc {\n\tenum msg_type type;\n\tunion {\n\t\tstruct {\n\t\t\tin_addr_t reply_ip;\n\t\t\tunsigned int port;\n\t\t} ping;\n\t\tstruct xfrm_desc xfrm_desc;\n\t} body;\n};\n\nstruct test_result {\n\tstruct xfrm_desc desc;\n\tunsigned int res;\n};\n\nstatic void write_test_result(unsigned int res, struct xfrm_desc *d)\n{\n\tstruct test_result tr = {};\n\tssize_t ret;\n\n\ttr.desc = *d;\n\ttr.res = res;\n\n\tret = write(results_fd[1], &tr, sizeof(tr));\n\tif (ret != sizeof(tr))\n\t\tpr_err(\"Failed to write the result in pipe %zd\", ret);\n}\n\nstatic void write_msg(int fd, struct test_desc *msg, bool exit_of_fail)\n{\n\tssize_t bytes = write(fd, msg, sizeof(*msg));\n\n\t \n\tBUILD_BUG_ON(sizeof(struct test_desc) > PIPE_BUF);\n\n\tif (bytes < 0) {\n\t\tpr_err(\"write()\");\n\t\tif (exit_of_fail)\n\t\t\texit(KSFT_FAIL);\n\t}\n\tif (bytes != sizeof(*msg)) {\n\t\tpr_err(\"sent part of the message %zd/%zu\", bytes, sizeof(*msg));\n\t\tif (exit_of_fail)\n\t\t\texit(KSFT_FAIL);\n\t}\n}\n\nstatic void read_msg(int fd, struct test_desc *msg, bool exit_of_fail)\n{\n\tssize_t bytes = read(fd, msg, sizeof(*msg));\n\n\tif (bytes < 0) {\n\t\tpr_err(\"read()\");\n\t\tif (exit_of_fail)\n\t\t\texit(KSFT_FAIL);\n\t}\n\tif (bytes != sizeof(*msg)) {\n\t\tpr_err(\"got incomplete message %zd/%zu\", bytes, sizeof(*msg));\n\t\tif (exit_of_fail)\n\t\t\texit(KSFT_FAIL);\n\t}\n}\n\nstatic int udp_ping_init(struct in_addr listen_ip, unsigned int u_timeout,\n\t\tunsigned int *server_port, int sock[2])\n{\n\tstruct sockaddr_in server;\n\tstruct timeval t = { .tv_sec = 0, .tv_usec = u_timeout };\n\tsocklen_t s_len = sizeof(server);\n\n\tsock[0] = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock[0] < 0) {\n\t\tpr_err(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tserver.sin_family\t= AF_INET;\n\tserver.sin_port\t\t= 0;\n\tmemcpy(&server.sin_addr.s_addr, &listen_ip, sizeof(struct in_addr));\n\n\tif (bind(sock[0], (struct sockaddr *)&server, s_len)) {\n\t\tpr_err(\"bind()\");\n\t\tgoto err_close_server;\n\t}\n\n\tif (getsockname(sock[0], (struct sockaddr *)&server, &s_len)) {\n\t\tpr_err(\"getsockname()\");\n\t\tgoto err_close_server;\n\t}\n\n\t*server_port = ntohs(server.sin_port);\n\n\tif (setsockopt(sock[0], SOL_SOCKET, SO_RCVTIMEO, (const char *)&t, sizeof t)) {\n\t\tpr_err(\"setsockopt()\");\n\t\tgoto err_close_server;\n\t}\n\n\tsock[1] = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock[1] < 0) {\n\t\tpr_err(\"socket()\");\n\t\tgoto err_close_server;\n\t}\n\n\treturn 0;\n\nerr_close_server:\n\tclose(sock[0]);\n\treturn -1;\n}\n\nstatic int udp_ping_send(int sock[2], in_addr_t dest_ip, unsigned int port,\n\t\tchar *buf, size_t buf_len)\n{\n\tstruct sockaddr_in server;\n\tconst struct sockaddr *dest_addr = (struct sockaddr *)&server;\n\tchar *sock_buf[buf_len];\n\tssize_t r_bytes, s_bytes;\n\n\tserver.sin_family\t= AF_INET;\n\tserver.sin_port\t\t= htons(port);\n\tserver.sin_addr.s_addr\t= dest_ip;\n\n\ts_bytes = sendto(sock[1], buf, buf_len, 0, dest_addr, sizeof(server));\n\tif (s_bytes < 0) {\n\t\tpr_err(\"sendto()\");\n\t\treturn -1;\n\t} else if (s_bytes != buf_len) {\n\t\tprintk(\"send part of the message: %zd/%zu\", s_bytes, sizeof(server));\n\t\treturn -1;\n\t}\n\n\tr_bytes = recv(sock[0], sock_buf, buf_len, 0);\n\tif (r_bytes < 0) {\n\t\tif (errno != EAGAIN)\n\t\t\tpr_err(\"recv()\");\n\t\treturn -1;\n\t} else if (r_bytes == 0) {  \n\t\tprintk(\"EOF on reply to ping\");\n\t\treturn -1;\n\t} else if (r_bytes != buf_len || memcmp(buf, sock_buf, buf_len)) {\n\t\tprintk(\"ping reply packet is corrupted %zd/%zu\", r_bytes, buf_len);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int udp_ping_reply(int sock[2], in_addr_t dest_ip, unsigned int port,\n\t\tchar *buf, size_t buf_len)\n{\n\tstruct sockaddr_in server;\n\tconst struct sockaddr *dest_addr = (struct sockaddr *)&server;\n\tchar *sock_buf[buf_len];\n\tssize_t r_bytes, s_bytes;\n\n\tserver.sin_family\t= AF_INET;\n\tserver.sin_port\t\t= htons(port);\n\tserver.sin_addr.s_addr\t= dest_ip;\n\n\tr_bytes = recv(sock[0], sock_buf, buf_len, 0);\n\tif (r_bytes < 0) {\n\t\tif (errno != EAGAIN)\n\t\t\tpr_err(\"recv()\");\n\t\treturn -1;\n\t}\n\tif (r_bytes == 0) {  \n\t\tprintk(\"EOF on reply to ping\");\n\t\treturn -1;\n\t}\n\tif (r_bytes != buf_len || memcmp(buf, sock_buf, buf_len)) {\n\t\tprintk(\"ping reply packet is corrupted %zd/%zu\", r_bytes, buf_len);\n\t\treturn -1;\n\t}\n\n\ts_bytes = sendto(sock[1], buf, buf_len, 0, dest_addr, sizeof(server));\n\tif (s_bytes < 0) {\n\t\tpr_err(\"sendto()\");\n\t\treturn -1;\n\t} else if (s_bytes != buf_len) {\n\t\tprintk(\"send part of the message: %zd/%zu\", s_bytes, sizeof(server));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\ntypedef int (*ping_f)(int sock[2], in_addr_t dest_ip, unsigned int port,\n\t\tchar *buf, size_t buf_len);\nstatic int do_ping(int cmd_fd, char *buf, size_t buf_len, struct in_addr from,\n\t\tbool init_side, int d_port, in_addr_t to, ping_f func)\n{\n\tstruct test_desc msg;\n\tunsigned int s_port, i, ping_succeeded = 0;\n\tint ping_sock[2];\n\tchar to_str[IPV4_STR_SZ] = {}, from_str[IPV4_STR_SZ] = {};\n\n\tif (udp_ping_init(from, ping_timeout, &s_port, ping_sock)) {\n\t\tprintk(\"Failed to init ping\");\n\t\treturn -1;\n\t}\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type\t\t= MSG_PING;\n\tmsg.body.ping.port\t= s_port;\n\tmemcpy(&msg.body.ping.reply_ip, &from, sizeof(from));\n\n\twrite_msg(cmd_fd, &msg, 0);\n\tif (init_side) {\n\t\t \n\t\tread_msg(cmd_fd, &msg, 0);\n\t\tif (msg.type != MSG_PING)\n\t\t\treturn -1;\n\t\tto = msg.body.ping.reply_ip;\n\t\td_port = msg.body.ping.port;\n\t}\n\n\tfor (i = 0; i < ping_count ; i++) {\n\t\tstruct timespec sleep_time = {\n\t\t\t.tv_sec = 0,\n\t\t\t.tv_nsec = ping_delay_nsec,\n\t\t};\n\n\t\tping_succeeded += !func(ping_sock, to, d_port, buf, page_size);\n\t\tnanosleep(&sleep_time, 0);\n\t}\n\n\tclose(ping_sock[0]);\n\tclose(ping_sock[1]);\n\n\tstrncpy(to_str, inet_ntoa(*(struct in_addr *)&to), IPV4_STR_SZ - 1);\n\tstrncpy(from_str, inet_ntoa(from), IPV4_STR_SZ - 1);\n\n\tif (ping_succeeded < ping_success) {\n\t\tprintk(\"ping (%s) %s->%s failed %u/%u times\",\n\t\t\tinit_side ? \"send\" : \"reply\", from_str, to_str,\n\t\t\tping_count - ping_succeeded, ping_count);\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG\n\tprintk(\"ping (%s) %s->%s succeeded %u/%u times\",\n\t\tinit_side ? \"send\" : \"reply\", from_str, to_str,\n\t\tping_succeeded, ping_count);\n#endif\n\n\treturn 0;\n}\n\nstatic int xfrm_fill_key(char *name, char *buf,\n\t\tsize_t buf_len, unsigned int *key_len)\n{\n\tint i;\n\n\tfor (i = 0; i < XFRM_ALGO_NR_KEYS; i++) {\n\t\tif (strncmp(name, xfrm_key_entries[i].algo_name, ALGO_LEN) == 0)\n\t\t\t*key_len = xfrm_key_entries[i].key_len;\n\t}\n\n\tif (*key_len > buf_len) {\n\t\tprintk(\"Can't pack a key - too big for buffer\");\n\t\treturn -1;\n\t}\n\n\trandomize_buffer(buf, *key_len);\n\n\treturn 0;\n}\n\nstatic int xfrm_state_pack_algo(struct nlmsghdr *nh, size_t req_sz,\n\t\tstruct xfrm_desc *desc)\n{\n\tstruct {\n\t\tunion {\n\t\t\tstruct xfrm_algo\talg;\n\t\t\tstruct xfrm_algo_aead\taead;\n\t\t\tstruct xfrm_algo_auth\tauth;\n\t\t} u;\n\t\tchar buf[XFRM_ALGO_KEY_BUF_SIZE];\n\t} alg = {};\n\tsize_t alen, elen, clen, aelen;\n\tunsigned short type;\n\n\talen = strlen(desc->a_algo);\n\telen = strlen(desc->e_algo);\n\tclen = strlen(desc->c_algo);\n\taelen = strlen(desc->ae_algo);\n\n\t \n\tswitch (desc->proto) {\n\tcase IPPROTO_AH:\n\t\tif (!alen || elen || clen || aelen) {\n\t\t\tprintk(\"BUG: buggy ah desc\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrncpy(alg.u.alg.alg_name, desc->a_algo, ALGO_LEN - 1);\n\t\tif (xfrm_fill_key(desc->a_algo, alg.u.alg.alg_key,\n\t\t\t\tsizeof(alg.buf), &alg.u.alg.alg_key_len))\n\t\t\treturn -1;\n\t\ttype = XFRMA_ALG_AUTH;\n\t\tbreak;\n\tcase IPPROTO_COMP:\n\t\tif (!clen || elen || alen || aelen) {\n\t\t\tprintk(\"BUG: buggy comp desc\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrncpy(alg.u.alg.alg_name, desc->c_algo, ALGO_LEN - 1);\n\t\tif (xfrm_fill_key(desc->c_algo, alg.u.alg.alg_key,\n\t\t\t\tsizeof(alg.buf), &alg.u.alg.alg_key_len))\n\t\t\treturn -1;\n\t\ttype = XFRMA_ALG_COMP;\n\t\tbreak;\n\tcase IPPROTO_ESP:\n\t\tif (!((alen && elen) ^ aelen) || clen) {\n\t\t\tprintk(\"BUG: buggy esp desc\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (aelen) {\n\t\t\talg.u.aead.alg_icv_len = desc->icv_len;\n\t\t\tstrncpy(alg.u.aead.alg_name, desc->ae_algo, ALGO_LEN - 1);\n\t\t\tif (xfrm_fill_key(desc->ae_algo, alg.u.aead.alg_key,\n\t\t\t\t\t\tsizeof(alg.buf), &alg.u.aead.alg_key_len))\n\t\t\t\treturn -1;\n\t\t\ttype = XFRMA_ALG_AEAD;\n\t\t} else {\n\n\t\t\tstrncpy(alg.u.alg.alg_name, desc->e_algo, ALGO_LEN - 1);\n\t\t\ttype = XFRMA_ALG_CRYPT;\n\t\t\tif (xfrm_fill_key(desc->e_algo, alg.u.alg.alg_key,\n\t\t\t\t\t\tsizeof(alg.buf), &alg.u.alg.alg_key_len))\n\t\t\t\treturn -1;\n\t\t\tif (rtattr_pack(nh, req_sz, type, &alg, sizeof(alg)))\n\t\t\t\treturn -1;\n\n\t\t\tstrncpy(alg.u.alg.alg_name, desc->a_algo, ALGO_LEN);\n\t\t\ttype = XFRMA_ALG_AUTH;\n\t\t\tif (xfrm_fill_key(desc->a_algo, alg.u.alg.alg_key,\n\t\t\t\t\t\tsizeof(alg.buf), &alg.u.alg.alg_key_len))\n\t\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"BUG: unknown proto in desc\");\n\t\treturn -1;\n\t}\n\n\tif (rtattr_pack(nh, req_sz, type, &alg, sizeof(alg)))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic inline uint32_t gen_spi(struct in_addr src)\n{\n\treturn htonl(inet_lnaof(src));\n}\n\nstatic int xfrm_state_add(int xfrm_sock, uint32_t seq, uint32_t spi,\n\t\tstruct in_addr src, struct in_addr dst,\n\t\tstruct xfrm_desc *desc)\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\tnh;\n\t\tstruct xfrm_usersa_info\tinfo;\n\t\tchar\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.info));\n\treq.nh.nlmsg_type\t= XFRM_MSG_NEWSA;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_seq\t= seq;\n\n\t \n\tmemcpy(&req.info.sel.daddr, &dst, sizeof(dst));\n\tmemcpy(&req.info.sel.saddr, &src, sizeof(src));\n\treq.info.sel.family\t\t= AF_INET;\n\treq.info.sel.prefixlen_d\t= PREFIX_LEN;\n\treq.info.sel.prefixlen_s\t= PREFIX_LEN;\n\n\t \n\tmemcpy(&req.info.id.daddr, &dst, sizeof(dst));\n\t \n\treq.info.id.spi = spi;\n\treq.info.id.proto\t= desc->proto;\n\n\tmemcpy(&req.info.saddr, &src, sizeof(src));\n\n\t \n\treq.info.lft.soft_byte_limit\t= XFRM_INF;\n\treq.info.lft.hard_byte_limit\t= XFRM_INF;\n\treq.info.lft.soft_packet_limit\t= XFRM_INF;\n\treq.info.lft.hard_packet_limit\t= XFRM_INF;\n\n\treq.info.family\t\t= AF_INET;\n\treq.info.mode\t\t= XFRM_MODE_TUNNEL;\n\n\tif (xfrm_state_pack_algo(&req.nh, sizeof(req), desc))\n\t\treturn -1;\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\n\treturn netlink_check_answer(xfrm_sock);\n}\n\nstatic bool xfrm_usersa_found(struct xfrm_usersa_info *info, uint32_t spi,\n\t\tstruct in_addr src, struct in_addr dst,\n\t\tstruct xfrm_desc *desc)\n{\n\tif (memcmp(&info->sel.daddr, &dst, sizeof(dst)))\n\t\treturn false;\n\n\tif (memcmp(&info->sel.saddr, &src, sizeof(src)))\n\t\treturn false;\n\n\tif (info->sel.family != AF_INET\t\t\t\t\t||\n\t\t\tinfo->sel.prefixlen_d != PREFIX_LEN\t\t||\n\t\t\tinfo->sel.prefixlen_s != PREFIX_LEN)\n\t\treturn false;\n\n\tif (info->id.spi != spi || info->id.proto != desc->proto)\n\t\treturn false;\n\n\tif (memcmp(&info->id.daddr, &dst, sizeof(dst)))\n\t\treturn false;\n\n\tif (memcmp(&info->saddr, &src, sizeof(src)))\n\t\treturn false;\n\n\tif (info->lft.soft_byte_limit != XFRM_INF\t\t\t||\n\t\t\tinfo->lft.hard_byte_limit != XFRM_INF\t\t||\n\t\t\tinfo->lft.soft_packet_limit != XFRM_INF\t\t||\n\t\t\tinfo->lft.hard_packet_limit != XFRM_INF)\n\t\treturn false;\n\n\tif (info->family != AF_INET || info->mode != XFRM_MODE_TUNNEL)\n\t\treturn false;\n\n\t \n\n\treturn true;\n}\n\nstatic int xfrm_state_check(int xfrm_sock, uint32_t seq, uint32_t spi,\n\t\tstruct in_addr src, struct in_addr dst,\n\t\tstruct xfrm_desc *desc)\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\tnh;\n\t\tchar\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\tstruct {\n\t\tstruct nlmsghdr\t\tnh;\n\t\tunion {\n\t\t\tstruct xfrm_usersa_info\tinfo;\n\t\t\tint error;\n\t\t};\n\t\tchar\t\t\tattrbuf[MAX_PAYLOAD];\n\t} answer;\n\tstruct xfrm_address_filter filter = {};\n\tbool found = false;\n\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(0);\n\treq.nh.nlmsg_type\t= XFRM_MSG_GETSA;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_DUMP;\n\treq.nh.nlmsg_seq\t= seq;\n\n\t \n\tfilter.family = AF_INET;\n\tfilter.splen = 0x1f;\t \n\tmemcpy(&filter.saddr, &src, sizeof(src));\n\tif (rtattr_pack(&req.nh, sizeof(req), XFRMA_ADDRESS_FILTER,\n\t\t\t\t&filter, sizeof(filter)))\n\t\treturn -1;\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tif (recv(xfrm_sock, &answer, sizeof(answer), 0) < 0) {\n\t\t\tpr_err(\"recv()\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (answer.nh.nlmsg_type == NLMSG_ERROR) {\n\t\t\tprintk(\"NLMSG_ERROR: %d: %s\",\n\t\t\t\tanswer.error, strerror(-answer.error));\n\t\t\treturn -1;\n\t\t} else if (answer.nh.nlmsg_type == NLMSG_DONE) {\n\t\t\tif (found)\n\t\t\t\treturn 0;\n\t\t\tprintk(\"didn't find allocated xfrm state in dump\");\n\t\t\treturn -1;\n\t\t} else if (answer.nh.nlmsg_type == XFRM_MSG_NEWSA) {\n\t\t\tif (xfrm_usersa_found(&answer.info, spi, src, dst, desc))\n\t\t\t\tfound = true;\n\t\t}\n\t}\n}\n\nstatic int xfrm_set(int xfrm_sock, uint32_t *seq,\n\t\tstruct in_addr src, struct in_addr dst,\n\t\tstruct in_addr tunsrc, struct in_addr tundst,\n\t\tstruct xfrm_desc *desc)\n{\n\tint err;\n\n\terr = xfrm_state_add(xfrm_sock, (*seq)++, gen_spi(src), src, dst, desc);\n\tif (err) {\n\t\tprintk(\"Failed to add xfrm state\");\n\t\treturn -1;\n\t}\n\n\terr = xfrm_state_add(xfrm_sock, (*seq)++, gen_spi(src), dst, src, desc);\n\tif (err) {\n\t\tprintk(\"Failed to add xfrm state\");\n\t\treturn -1;\n\t}\n\n\t \n\terr = xfrm_state_check(xfrm_sock, (*seq)++, gen_spi(src), src, dst, desc);\n\terr |= xfrm_state_check(xfrm_sock, (*seq)++, gen_spi(src), dst, src, desc);\n\tif (err) {\n\t\tprintk(\"Failed to check xfrm state\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm_policy_add(int xfrm_sock, uint32_t seq, uint32_t spi,\n\t\tstruct in_addr src, struct in_addr dst, uint8_t dir,\n\t\tstruct in_addr tunsrc, struct in_addr tundst, uint8_t proto)\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\t\tnh;\n\t\tstruct xfrm_userpolicy_info\tinfo;\n\t\tchar\t\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\tstruct xfrm_user_tmpl tmpl;\n\n\tmemset(&req, 0, sizeof(req));\n\tmemset(&tmpl, 0, sizeof(tmpl));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.info));\n\treq.nh.nlmsg_type\t= XFRM_MSG_NEWPOLICY;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_seq\t= seq;\n\n\t \n\tmemcpy(&req.info.sel.daddr, &dst, sizeof(tundst));\n\tmemcpy(&req.info.sel.saddr, &src, sizeof(tunsrc));\n\treq.info.sel.family\t\t= AF_INET;\n\treq.info.sel.prefixlen_d\t= PREFIX_LEN;\n\treq.info.sel.prefixlen_s\t= PREFIX_LEN;\n\n\t \n\treq.info.lft.soft_byte_limit\t= XFRM_INF;\n\treq.info.lft.hard_byte_limit\t= XFRM_INF;\n\treq.info.lft.soft_packet_limit\t= XFRM_INF;\n\treq.info.lft.hard_packet_limit\t= XFRM_INF;\n\n\treq.info.dir = dir;\n\n\t \n\tmemcpy(&tmpl.id.daddr, &dst, sizeof(dst));\n\t \n\ttmpl.id.spi = spi;\n\ttmpl.id.proto\t= proto;\n\ttmpl.family\t= AF_INET;\n\tmemcpy(&tmpl.saddr, &src, sizeof(src));\n\ttmpl.mode\t= XFRM_MODE_TUNNEL;\n\ttmpl.aalgos = (~(uint32_t)0);\n\ttmpl.ealgos = (~(uint32_t)0);\n\ttmpl.calgos = (~(uint32_t)0);\n\n\tif (rtattr_pack(&req.nh, sizeof(req), XFRMA_TMPL, &tmpl, sizeof(tmpl)))\n\t\treturn -1;\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\n\treturn netlink_check_answer(xfrm_sock);\n}\n\nstatic int xfrm_prepare(int xfrm_sock, uint32_t *seq,\n\t\tstruct in_addr src, struct in_addr dst,\n\t\tstruct in_addr tunsrc, struct in_addr tundst, uint8_t proto)\n{\n\tif (xfrm_policy_add(xfrm_sock, (*seq)++, gen_spi(src), src, dst,\n\t\t\t\tXFRM_POLICY_OUT, tunsrc, tundst, proto)) {\n\t\tprintk(\"Failed to add xfrm policy\");\n\t\treturn -1;\n\t}\n\n\tif (xfrm_policy_add(xfrm_sock, (*seq)++, gen_spi(src), dst, src,\n\t\t\t\tXFRM_POLICY_IN, tunsrc, tundst, proto)) {\n\t\tprintk(\"Failed to add xfrm policy\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm_policy_del(int xfrm_sock, uint32_t seq,\n\t\tstruct in_addr src, struct in_addr dst, uint8_t dir,\n\t\tstruct in_addr tunsrc, struct in_addr tundst)\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\t\tnh;\n\t\tstruct xfrm_userpolicy_id\tid;\n\t\tchar\t\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.id));\n\treq.nh.nlmsg_type\t= XFRM_MSG_DELPOLICY;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_seq\t= seq;\n\n\t \n\tmemcpy(&req.id.sel.daddr, &dst, sizeof(tundst));\n\tmemcpy(&req.id.sel.saddr, &src, sizeof(tunsrc));\n\treq.id.sel.family\t\t= AF_INET;\n\treq.id.sel.prefixlen_d\t\t= PREFIX_LEN;\n\treq.id.sel.prefixlen_s\t\t= PREFIX_LEN;\n\treq.id.dir = dir;\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\n\treturn netlink_check_answer(xfrm_sock);\n}\n\nstatic int xfrm_cleanup(int xfrm_sock, uint32_t *seq,\n\t\tstruct in_addr src, struct in_addr dst,\n\t\tstruct in_addr tunsrc, struct in_addr tundst)\n{\n\tif (xfrm_policy_del(xfrm_sock, (*seq)++, src, dst,\n\t\t\t\tXFRM_POLICY_OUT, tunsrc, tundst)) {\n\t\tprintk(\"Failed to add xfrm policy\");\n\t\treturn -1;\n\t}\n\n\tif (xfrm_policy_del(xfrm_sock, (*seq)++, dst, src,\n\t\t\t\tXFRM_POLICY_IN, tunsrc, tundst)) {\n\t\tprintk(\"Failed to add xfrm policy\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm_state_del(int xfrm_sock, uint32_t seq, uint32_t spi,\n\t\tstruct in_addr src, struct in_addr dst, uint8_t proto)\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\tnh;\n\t\tstruct xfrm_usersa_id\tid;\n\t\tchar\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\txfrm_address_t saddr = {};\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.id));\n\treq.nh.nlmsg_type\t= XFRM_MSG_DELSA;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_seq\t= seq;\n\n\tmemcpy(&req.id.daddr, &dst, sizeof(dst));\n\treq.id.family\t\t= AF_INET;\n\treq.id.proto\t\t= proto;\n\t \n\treq.id.spi = spi;\n\n\tmemcpy(&saddr, &src, sizeof(src));\n\tif (rtattr_pack(&req.nh, sizeof(req), XFRMA_SRCADDR, &saddr, sizeof(saddr)))\n\t\treturn -1;\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\n\treturn netlink_check_answer(xfrm_sock);\n}\n\nstatic int xfrm_delete(int xfrm_sock, uint32_t *seq,\n\t\tstruct in_addr src, struct in_addr dst,\n\t\tstruct in_addr tunsrc, struct in_addr tundst, uint8_t proto)\n{\n\tif (xfrm_state_del(xfrm_sock, (*seq)++, gen_spi(src), src, dst, proto)) {\n\t\tprintk(\"Failed to remove xfrm state\");\n\t\treturn -1;\n\t}\n\n\tif (xfrm_state_del(xfrm_sock, (*seq)++, gen_spi(src), dst, src, proto)) {\n\t\tprintk(\"Failed to remove xfrm state\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm_state_allocspi(int xfrm_sock, uint32_t *seq,\n\t\tuint32_t spi, uint8_t proto)\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\t\tnh;\n\t\tstruct xfrm_userspi_info\tspi;\n\t} req;\n\tstruct {\n\t\tstruct nlmsghdr\t\t\tnh;\n\t\tunion {\n\t\t\tstruct xfrm_usersa_info\tinfo;\n\t\t\tint error;\n\t\t};\n\t} answer;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.spi));\n\treq.nh.nlmsg_type\t= XFRM_MSG_ALLOCSPI;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST;\n\treq.nh.nlmsg_seq\t= (*seq)++;\n\n\treq.spi.info.family\t= AF_INET;\n\treq.spi.min\t\t= spi;\n\treq.spi.max\t\t= spi;\n\treq.spi.info.id.proto\t= proto;\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tif (recv(xfrm_sock, &answer, sizeof(answer), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\treturn KSFT_FAIL;\n\t} else if (answer.nh.nlmsg_type == XFRM_MSG_NEWSA) {\n\t\tuint32_t new_spi = htonl(answer.info.id.spi);\n\n\t\tif (new_spi != spi) {\n\t\t\tprintk(\"allocated spi is different from requested: %#x != %#x\",\n\t\t\t\t\tnew_spi, spi);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\treturn KSFT_PASS;\n\t} else if (answer.nh.nlmsg_type != NLMSG_ERROR) {\n\t\tprintk(\"expected NLMSG_ERROR, got %d\", (int)answer.nh.nlmsg_type);\n\t\treturn KSFT_FAIL;\n\t}\n\n\tprintk(\"NLMSG_ERROR: %d: %s\", answer.error, strerror(-answer.error));\n\treturn (answer.error) ? KSFT_FAIL : KSFT_PASS;\n}\n\nstatic int netlink_sock_bind(int *sock, uint32_t *seq, int proto, uint32_t groups)\n{\n\tstruct sockaddr_nl snl = {};\n\tsocklen_t addr_len;\n\tint ret = -1;\n\n\tsnl.nl_family = AF_NETLINK;\n\tsnl.nl_groups = groups;\n\n\tif (netlink_sock(sock, seq, proto)) {\n\t\tprintk(\"Failed to open xfrm netlink socket\");\n\t\treturn -1;\n\t}\n\n\tif (bind(*sock, (struct sockaddr *)&snl, sizeof(snl)) < 0) {\n\t\tpr_err(\"bind()\");\n\t\tgoto out_close;\n\t}\n\n\taddr_len = sizeof(snl);\n\tif (getsockname(*sock, (struct sockaddr *)&snl, &addr_len) < 0) {\n\t\tpr_err(\"getsockname()\");\n\t\tgoto out_close;\n\t}\n\tif (addr_len != sizeof(snl)) {\n\t\tprintk(\"Wrong address length %d\", addr_len);\n\t\tgoto out_close;\n\t}\n\tif (snl.nl_family != AF_NETLINK) {\n\t\tprintk(\"Wrong address family %d\", snl.nl_family);\n\t\tgoto out_close;\n\t}\n\treturn 0;\n\nout_close:\n\tclose(*sock);\n\treturn ret;\n}\n\nstatic int xfrm_monitor_acquire(int xfrm_sock, uint32_t *seq, unsigned int nr)\n{\n\tstruct {\n\t\tstruct nlmsghdr nh;\n\t\tunion {\n\t\t\tstruct xfrm_user_acquire acq;\n\t\t\tint error;\n\t\t};\n\t\tchar attrbuf[MAX_PAYLOAD];\n\t} req;\n\tstruct xfrm_user_tmpl xfrm_tmpl = {};\n\tint xfrm_listen = -1, ret = KSFT_FAIL;\n\tuint32_t seq_listen;\n\n\tif (netlink_sock_bind(&xfrm_listen, &seq_listen, NETLINK_XFRM, XFRMNLGRP_ACQUIRE))\n\t\treturn KSFT_FAIL;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.acq));\n\treq.nh.nlmsg_type\t= XFRM_MSG_ACQUIRE;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_seq\t= (*seq)++;\n\n\treq.acq.policy.sel.family\t= AF_INET;\n\treq.acq.aalgos\t= 0xfeed;\n\treq.acq.ealgos\t= 0xbaad;\n\treq.acq.calgos\t= 0xbabe;\n\n\txfrm_tmpl.family = AF_INET;\n\txfrm_tmpl.id.proto = IPPROTO_ESP;\n\tif (rtattr_pack(&req.nh, sizeof(req), XFRMA_TMPL, &xfrm_tmpl, sizeof(xfrm_tmpl)))\n\t\tgoto out_close;\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\tgoto out_close;\n\t}\n\n\tif (recv(xfrm_sock, &req, sizeof(req), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\tgoto out_close;\n\t} else if (req.nh.nlmsg_type != NLMSG_ERROR) {\n\t\tprintk(\"expected NLMSG_ERROR, got %d\", (int)req.nh.nlmsg_type);\n\t\tgoto out_close;\n\t}\n\n\tif (req.error) {\n\t\tprintk(\"NLMSG_ERROR: %d: %s\", req.error, strerror(-req.error));\n\t\tret = req.error;\n\t\tgoto out_close;\n\t}\n\n\tif (recv(xfrm_listen, &req, sizeof(req), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\tgoto out_close;\n\t}\n\n\tif (req.acq.aalgos != 0xfeed || req.acq.ealgos != 0xbaad\n\t\t\t|| req.acq.calgos != 0xbabe) {\n\t\tprintk(\"xfrm_user_acquire has changed  %x %x %x\",\n\t\t\t\treq.acq.aalgos, req.acq.ealgos, req.acq.calgos);\n\t\tgoto out_close;\n\t}\n\n\tret = KSFT_PASS;\nout_close:\n\tclose(xfrm_listen);\n\treturn ret;\n}\n\nstatic int xfrm_expire_state(int xfrm_sock, uint32_t *seq,\n\t\tunsigned int nr, struct xfrm_desc *desc)\n{\n\tstruct {\n\t\tstruct nlmsghdr nh;\n\t\tunion {\n\t\t\tstruct xfrm_user_expire expire;\n\t\t\tint error;\n\t\t};\n\t} req;\n\tstruct in_addr src, dst;\n\tint xfrm_listen = -1, ret = KSFT_FAIL;\n\tuint32_t seq_listen;\n\n\tsrc = inet_makeaddr(INADDR_B, child_ip(nr));\n\tdst = inet_makeaddr(INADDR_B, grchild_ip(nr));\n\n\tif (xfrm_state_add(xfrm_sock, (*seq)++, gen_spi(src), src, dst, desc)) {\n\t\tprintk(\"Failed to add xfrm state\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tif (netlink_sock_bind(&xfrm_listen, &seq_listen, NETLINK_XFRM, XFRMNLGRP_EXPIRE))\n\t\treturn KSFT_FAIL;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.expire));\n\treq.nh.nlmsg_type\t= XFRM_MSG_EXPIRE;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_seq\t= (*seq)++;\n\n\tmemcpy(&req.expire.state.id.daddr, &dst, sizeof(dst));\n\treq.expire.state.id.spi\t\t= gen_spi(src);\n\treq.expire.state.id.proto\t= desc->proto;\n\treq.expire.state.family\t\t= AF_INET;\n\treq.expire.hard\t\t\t= 0xff;\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\tgoto out_close;\n\t}\n\n\tif (recv(xfrm_sock, &req, sizeof(req), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\tgoto out_close;\n\t} else if (req.nh.nlmsg_type != NLMSG_ERROR) {\n\t\tprintk(\"expected NLMSG_ERROR, got %d\", (int)req.nh.nlmsg_type);\n\t\tgoto out_close;\n\t}\n\n\tif (req.error) {\n\t\tprintk(\"NLMSG_ERROR: %d: %s\", req.error, strerror(-req.error));\n\t\tret = req.error;\n\t\tgoto out_close;\n\t}\n\n\tif (recv(xfrm_listen, &req, sizeof(req), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\tgoto out_close;\n\t}\n\n\tif (req.expire.hard != 0x1) {\n\t\tprintk(\"expire.hard is not set: %x\", req.expire.hard);\n\t\tgoto out_close;\n\t}\n\n\tret = KSFT_PASS;\nout_close:\n\tclose(xfrm_listen);\n\treturn ret;\n}\n\nstatic int xfrm_expire_policy(int xfrm_sock, uint32_t *seq,\n\t\tunsigned int nr, struct xfrm_desc *desc)\n{\n\tstruct {\n\t\tstruct nlmsghdr nh;\n\t\tunion {\n\t\t\tstruct xfrm_user_polexpire expire;\n\t\t\tint error;\n\t\t};\n\t} req;\n\tstruct in_addr src, dst, tunsrc, tundst;\n\tint xfrm_listen = -1, ret = KSFT_FAIL;\n\tuint32_t seq_listen;\n\n\tsrc = inet_makeaddr(INADDR_B, child_ip(nr));\n\tdst = inet_makeaddr(INADDR_B, grchild_ip(nr));\n\ttunsrc = inet_makeaddr(INADDR_A, child_ip(nr));\n\ttundst = inet_makeaddr(INADDR_A, grchild_ip(nr));\n\n\tif (xfrm_policy_add(xfrm_sock, (*seq)++, gen_spi(src), src, dst,\n\t\t\t\tXFRM_POLICY_OUT, tunsrc, tundst, desc->proto)) {\n\t\tprintk(\"Failed to add xfrm policy\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tif (netlink_sock_bind(&xfrm_listen, &seq_listen, NETLINK_XFRM, XFRMNLGRP_EXPIRE))\n\t\treturn KSFT_FAIL;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.expire));\n\treq.nh.nlmsg_type\t= XFRM_MSG_POLEXPIRE;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_seq\t= (*seq)++;\n\n\t \n\tmemcpy(&req.expire.pol.sel.daddr, &dst, sizeof(tundst));\n\tmemcpy(&req.expire.pol.sel.saddr, &src, sizeof(tunsrc));\n\treq.expire.pol.sel.family\t= AF_INET;\n\treq.expire.pol.sel.prefixlen_d\t= PREFIX_LEN;\n\treq.expire.pol.sel.prefixlen_s\t= PREFIX_LEN;\n\treq.expire.pol.dir\t\t= XFRM_POLICY_OUT;\n\treq.expire.hard\t\t\t= 0xff;\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\tgoto out_close;\n\t}\n\n\tif (recv(xfrm_sock, &req, sizeof(req), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\tgoto out_close;\n\t} else if (req.nh.nlmsg_type != NLMSG_ERROR) {\n\t\tprintk(\"expected NLMSG_ERROR, got %d\", (int)req.nh.nlmsg_type);\n\t\tgoto out_close;\n\t}\n\n\tif (req.error) {\n\t\tprintk(\"NLMSG_ERROR: %d: %s\", req.error, strerror(-req.error));\n\t\tret = req.error;\n\t\tgoto out_close;\n\t}\n\n\tif (recv(xfrm_listen, &req, sizeof(req), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\tgoto out_close;\n\t}\n\n\tif (req.expire.hard != 0x1) {\n\t\tprintk(\"expire.hard is not set: %x\", req.expire.hard);\n\t\tgoto out_close;\n\t}\n\n\tret = KSFT_PASS;\nout_close:\n\tclose(xfrm_listen);\n\treturn ret;\n}\n\nstatic int xfrm_spdinfo_set_thresh(int xfrm_sock, uint32_t *seq,\n\t\tunsigned thresh4_l, unsigned thresh4_r,\n\t\tunsigned thresh6_l, unsigned thresh6_r,\n\t\tbool add_bad_attr)\n\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\tnh;\n\t\tunion {\n\t\t\tuint32_t\tunused;\n\t\t\tint\t\terror;\n\t\t};\n\t\tchar\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\tstruct xfrmu_spdhthresh thresh;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.unused));\n\treq.nh.nlmsg_type\t= XFRM_MSG_NEWSPDINFO;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST | NLM_F_ACK;\n\treq.nh.nlmsg_seq\t= (*seq)++;\n\n\tthresh.lbits = thresh4_l;\n\tthresh.rbits = thresh4_r;\n\tif (rtattr_pack(&req.nh, sizeof(req), XFRMA_SPD_IPV4_HTHRESH, &thresh, sizeof(thresh)))\n\t\treturn -1;\n\n\tthresh.lbits = thresh6_l;\n\tthresh.rbits = thresh6_r;\n\tif (rtattr_pack(&req.nh, sizeof(req), XFRMA_SPD_IPV6_HTHRESH, &thresh, sizeof(thresh)))\n\t\treturn -1;\n\n\tif (add_bad_attr) {\n\t\tBUILD_BUG_ON(XFRMA_IF_ID <= XFRMA_SPD_MAX + 1);\n\t\tif (rtattr_pack(&req.nh, sizeof(req), XFRMA_IF_ID, NULL, 0)) {\n\t\t\tpr_err(\"adding attribute failed: no space\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn -1;\n\t}\n\n\tif (recv(xfrm_sock, &req, sizeof(req), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\treturn -1;\n\t} else if (req.nh.nlmsg_type != NLMSG_ERROR) {\n\t\tprintk(\"expected NLMSG_ERROR, got %d\", (int)req.nh.nlmsg_type);\n\t\treturn -1;\n\t}\n\n\tif (req.error) {\n\t\tprintk(\"NLMSG_ERROR: %d: %s\", req.error, strerror(-req.error));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm_spdinfo_attrs(int xfrm_sock, uint32_t *seq)\n{\n\tstruct {\n\t\tstruct nlmsghdr\t\t\tnh;\n\t\tunion {\n\t\t\tuint32_t\tunused;\n\t\t\tint\t\terror;\n\t\t};\n\t\tchar\t\t\tattrbuf[MAX_PAYLOAD];\n\t} req;\n\n\tif (xfrm_spdinfo_set_thresh(xfrm_sock, seq, 32, 31, 120, 16, false)) {\n\t\tpr_err(\"Can't set SPD HTHRESH\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.nh.nlmsg_len\t= NLMSG_LENGTH(sizeof(req.unused));\n\treq.nh.nlmsg_type\t= XFRM_MSG_GETSPDINFO;\n\treq.nh.nlmsg_flags\t= NLM_F_REQUEST;\n\treq.nh.nlmsg_seq\t= (*seq)++;\n\tif (send(xfrm_sock, &req, req.nh.nlmsg_len, 0) < 0) {\n\t\tpr_err(\"send()\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tif (recv(xfrm_sock, &req, sizeof(req), 0) < 0) {\n\t\tpr_err(\"recv()\");\n\t\treturn KSFT_FAIL;\n\t} else if (req.nh.nlmsg_type == XFRM_MSG_NEWSPDINFO) {\n\t\tsize_t len = NLMSG_PAYLOAD(&req.nh, sizeof(req.unused));\n\t\tstruct rtattr *attr = (void *)req.attrbuf;\n\t\tint got_thresh = 0;\n\n\t\tfor (; RTA_OK(attr, len); attr = RTA_NEXT(attr, len)) {\n\t\t\tif (attr->rta_type == XFRMA_SPD_IPV4_HTHRESH) {\n\t\t\t\tstruct xfrmu_spdhthresh *t = RTA_DATA(attr);\n\n\t\t\t\tgot_thresh++;\n\t\t\t\tif (t->lbits != 32 || t->rbits != 31) {\n\t\t\t\t\tpr_err(\"thresh differ: %u, %u\",\n\t\t\t\t\t\t\tt->lbits, t->rbits);\n\t\t\t\t\treturn KSFT_FAIL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (attr->rta_type == XFRMA_SPD_IPV6_HTHRESH) {\n\t\t\t\tstruct xfrmu_spdhthresh *t = RTA_DATA(attr);\n\n\t\t\t\tgot_thresh++;\n\t\t\t\tif (t->lbits != 120 || t->rbits != 16) {\n\t\t\t\t\tpr_err(\"thresh differ: %u, %u\",\n\t\t\t\t\t\t\tt->lbits, t->rbits);\n\t\t\t\t\treturn KSFT_FAIL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (got_thresh != 2) {\n\t\t\tpr_err(\"only %d thresh returned by XFRM_MSG_GETSPDINFO\", got_thresh);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t} else if (req.nh.nlmsg_type != NLMSG_ERROR) {\n\t\tprintk(\"expected NLMSG_ERROR, got %d\", (int)req.nh.nlmsg_type);\n\t\treturn KSFT_FAIL;\n\t} else {\n\t\tprintk(\"NLMSG_ERROR: %d: %s\", req.error, strerror(-req.error));\n\t\treturn -1;\n\t}\n\n\t \n\tif (xfrm_spdinfo_set_thresh(xfrm_sock, seq, 32, 32, 128, 128, false)) {\n\t\tpr_err(\"Can't restore SPD HTHRESH\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\t \n\tif (xfrm_spdinfo_set_thresh(xfrm_sock, seq, 32, 32, 128, 128, true))\n\t\treturn KSFT_PASS;\n\n\treturn KSFT_PASS;\n}\n\nstatic int child_serv(int xfrm_sock, uint32_t *seq,\n\t\tunsigned int nr, int cmd_fd, void *buf, struct xfrm_desc *desc)\n{\n\tstruct in_addr src, dst, tunsrc, tundst;\n\tstruct test_desc msg;\n\tint ret = KSFT_FAIL;\n\n\tsrc = inet_makeaddr(INADDR_B, child_ip(nr));\n\tdst = inet_makeaddr(INADDR_B, grchild_ip(nr));\n\ttunsrc = inet_makeaddr(INADDR_A, child_ip(nr));\n\ttundst = inet_makeaddr(INADDR_A, grchild_ip(nr));\n\n\t \n\tif (do_ping(cmd_fd, buf, page_size, src, true, 0, 0, udp_ping_send)) {\n\t\tprintk(\"ping failed before setting xfrm\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type = MSG_XFRM_PREPARE;\n\tmemcpy(&msg.body.xfrm_desc, desc, sizeof(*desc));\n\twrite_msg(cmd_fd, &msg, 1);\n\n\tif (xfrm_prepare(xfrm_sock, seq, src, dst, tunsrc, tundst, desc->proto)) {\n\t\tprintk(\"failed to prepare xfrm\");\n\t\tgoto cleanup;\n\t}\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type = MSG_XFRM_ADD;\n\tmemcpy(&msg.body.xfrm_desc, desc, sizeof(*desc));\n\twrite_msg(cmd_fd, &msg, 1);\n\tif (xfrm_set(xfrm_sock, seq, src, dst, tunsrc, tundst, desc)) {\n\t\tprintk(\"failed to set xfrm\");\n\t\tgoto delete;\n\t}\n\n\t \n\tif (do_ping(cmd_fd, buf, page_size, tunsrc,\n\t\t\t\ttrue, 0, 0, udp_ping_send)) {\n\t\tprintk(\"ping failed for xfrm\");\n\t\tgoto delete;\n\t}\n\n\tret = KSFT_PASS;\ndelete:\n\t \n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type = MSG_XFRM_DEL;\n\tmemcpy(&msg.body.xfrm_desc, desc, sizeof(*desc));\n\twrite_msg(cmd_fd, &msg, 1);\n\n\tif (xfrm_delete(xfrm_sock, seq, src, dst, tunsrc, tundst, desc->proto)) {\n\t\tprintk(\"failed ping to remove xfrm\");\n\t\tret = KSFT_FAIL;\n\t}\n\ncleanup:\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type = MSG_XFRM_CLEANUP;\n\tmemcpy(&msg.body.xfrm_desc, desc, sizeof(*desc));\n\twrite_msg(cmd_fd, &msg, 1);\n\tif (xfrm_cleanup(xfrm_sock, seq, src, dst, tunsrc, tundst)) {\n\t\tprintk(\"failed ping to cleanup xfrm\");\n\t\tret = KSFT_FAIL;\n\t}\n\treturn ret;\n}\n\nstatic int child_f(unsigned int nr, int test_desc_fd, int cmd_fd, void *buf)\n{\n\tstruct xfrm_desc desc;\n\tstruct test_desc msg;\n\tint xfrm_sock = -1;\n\tuint32_t seq;\n\n\tif (switch_ns(nsfd_childa))\n\t\texit(KSFT_FAIL);\n\n\tif (netlink_sock(&xfrm_sock, &seq, NETLINK_XFRM)) {\n\t\tprintk(\"Failed to open xfrm netlink socket\");\n\t\texit(KSFT_FAIL);\n\t}\n\n\t \n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type = MSG_ACK;\n\twrite_msg(cmd_fd, &msg, 1);\n\tread_msg(cmd_fd, &msg, 1);\n\tif (msg.type != MSG_ACK) {\n\t\tprintk(\"Ack failed\");\n\t\texit(KSFT_FAIL);\n\t}\n\n\tfor (;;) {\n\t\tssize_t received = read(test_desc_fd, &desc, sizeof(desc));\n\t\tint ret;\n\n\t\tif (received == 0)  \n\t\t\tbreak;\n\n\t\tif (received != sizeof(desc)) {\n\t\t\tpr_err(\"read() returned %zd\", received);\n\t\t\texit(KSFT_FAIL);\n\t\t}\n\n\t\tswitch (desc.type) {\n\t\tcase CREATE_TUNNEL:\n\t\t\tret = child_serv(xfrm_sock, &seq, nr,\n\t\t\t\t\t cmd_fd, buf, &desc);\n\t\t\tbreak;\n\t\tcase ALLOCATE_SPI:\n\t\t\tret = xfrm_state_allocspi(xfrm_sock, &seq,\n\t\t\t\t\t\t  -1, desc.proto);\n\t\t\tbreak;\n\t\tcase MONITOR_ACQUIRE:\n\t\t\tret = xfrm_monitor_acquire(xfrm_sock, &seq, nr);\n\t\t\tbreak;\n\t\tcase EXPIRE_STATE:\n\t\t\tret = xfrm_expire_state(xfrm_sock, &seq, nr, &desc);\n\t\t\tbreak;\n\t\tcase EXPIRE_POLICY:\n\t\t\tret = xfrm_expire_policy(xfrm_sock, &seq, nr, &desc);\n\t\t\tbreak;\n\t\tcase SPDINFO_ATTRS:\n\t\t\tret = xfrm_spdinfo_attrs(xfrm_sock, &seq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Unknown desc type %d\", desc.type);\n\t\t\texit(KSFT_FAIL);\n\t\t}\n\t\twrite_test_result(ret, &desc);\n\t}\n\n\tclose(xfrm_sock);\n\n\tmsg.type = MSG_EXIT;\n\twrite_msg(cmd_fd, &msg, 1);\n\texit(KSFT_PASS);\n}\n\nstatic void grand_child_serv(unsigned int nr, int cmd_fd, void *buf,\n\t\tstruct test_desc *msg, int xfrm_sock, uint32_t *seq)\n{\n\tstruct in_addr src, dst, tunsrc, tundst;\n\tbool tun_reply;\n\tstruct xfrm_desc *desc = &msg->body.xfrm_desc;\n\n\tsrc = inet_makeaddr(INADDR_B, grchild_ip(nr));\n\tdst = inet_makeaddr(INADDR_B, child_ip(nr));\n\ttunsrc = inet_makeaddr(INADDR_A, grchild_ip(nr));\n\ttundst = inet_makeaddr(INADDR_A, child_ip(nr));\n\n\tswitch (msg->type) {\n\tcase MSG_EXIT:\n\t\texit(KSFT_PASS);\n\tcase MSG_ACK:\n\t\twrite_msg(cmd_fd, msg, 1);\n\t\tbreak;\n\tcase MSG_PING:\n\t\ttun_reply = memcmp(&dst, &msg->body.ping.reply_ip, sizeof(in_addr_t));\n\t\t \n\t\tif (do_ping(cmd_fd, buf, page_size, tun_reply ? tunsrc : src,\n\t\t\t\tfalse, msg->body.ping.port,\n\t\t\t\tmsg->body.ping.reply_ip, udp_ping_reply)) {\n\t\t\tprintk(\"ping failed before setting xfrm\");\n\t\t}\n\t\tbreak;\n\tcase MSG_XFRM_PREPARE:\n\t\tif (xfrm_prepare(xfrm_sock, seq, src, dst, tunsrc, tundst,\n\t\t\t\t\tdesc->proto)) {\n\t\t\txfrm_cleanup(xfrm_sock, seq, src, dst, tunsrc, tundst);\n\t\t\tprintk(\"failed to prepare xfrm\");\n\t\t}\n\t\tbreak;\n\tcase MSG_XFRM_ADD:\n\t\tif (xfrm_set(xfrm_sock, seq, src, dst, tunsrc, tundst, desc)) {\n\t\t\txfrm_cleanup(xfrm_sock, seq, src, dst, tunsrc, tundst);\n\t\t\tprintk(\"failed to set xfrm\");\n\t\t}\n\t\tbreak;\n\tcase MSG_XFRM_DEL:\n\t\tif (xfrm_delete(xfrm_sock, seq, src, dst, tunsrc, tundst,\n\t\t\t\t\tdesc->proto)) {\n\t\t\txfrm_cleanup(xfrm_sock, seq, src, dst, tunsrc, tundst);\n\t\t\tprintk(\"failed to remove xfrm\");\n\t\t}\n\t\tbreak;\n\tcase MSG_XFRM_CLEANUP:\n\t\tif (xfrm_cleanup(xfrm_sock, seq, src, dst, tunsrc, tundst)) {\n\t\t\tprintk(\"failed to cleanup xfrm\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"got unknown msg type %d\", msg->type);\n\t}\n}\n\nstatic int grand_child_f(unsigned int nr, int cmd_fd, void *buf)\n{\n\tstruct test_desc msg;\n\tint xfrm_sock = -1;\n\tuint32_t seq;\n\n\tif (switch_ns(nsfd_childb))\n\t\texit(KSFT_FAIL);\n\n\tif (netlink_sock(&xfrm_sock, &seq, NETLINK_XFRM)) {\n\t\tprintk(\"Failed to open xfrm netlink socket\");\n\t\texit(KSFT_FAIL);\n\t}\n\n\tdo {\n\t\tread_msg(cmd_fd, &msg, 1);\n\t\tgrand_child_serv(nr, cmd_fd, buf, &msg, xfrm_sock, &seq);\n\t} while (1);\n\n\tclose(xfrm_sock);\n\texit(KSFT_FAIL);\n}\n\nstatic int start_child(unsigned int nr, char *veth, int test_desc_fd[2])\n{\n\tint cmd_sock[2];\n\tvoid *data_map;\n\tpid_t child;\n\n\tif (init_child(nsfd_childa, veth, child_ip(nr), grchild_ip(nr)))\n\t\treturn -1;\n\n\tif (init_child(nsfd_childb, veth, grchild_ip(nr), child_ip(nr)))\n\t\treturn -1;\n\n\tchild = fork();\n\tif (child < 0) {\n\t\tpr_err(\"fork()\");\n\t\treturn -1;\n\t} else if (child) {\n\t\t \n\t\treturn switch_ns(nsfd_parent);\n\t}\n\n\tif (close(test_desc_fd[1])) {\n\t\tpr_err(\"close()\");\n\t\treturn -1;\n\t}\n\n\t \n\tdata_map = mmap(0, page_size, PROT_READ | PROT_WRITE,\n\t\t\tMAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\tif (data_map == MAP_FAILED) {\n\t\tpr_err(\"mmap()\");\n\t\treturn -1;\n\t}\n\n\trandomize_buffer(data_map, page_size);\n\n\tif (socketpair(PF_LOCAL, SOCK_SEQPACKET, 0, cmd_sock)) {\n\t\tpr_err(\"socketpair()\");\n\t\treturn -1;\n\t}\n\n\tchild = fork();\n\tif (child < 0) {\n\t\tpr_err(\"fork()\");\n\t\treturn -1;\n\t} else if (child) {\n\t\tif (close(cmd_sock[0])) {\n\t\t\tpr_err(\"close()\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn child_f(nr, test_desc_fd[0], cmd_sock[1], data_map);\n\t}\n\tif (close(cmd_sock[1])) {\n\t\tpr_err(\"close()\");\n\t\treturn -1;\n\t}\n\treturn grand_child_f(nr, cmd_sock[0], data_map);\n}\n\nstatic void exit_usage(char **argv)\n{\n\tprintk(\"Usage: %s [nr_process]\", argv[0]);\n\texit(KSFT_FAIL);\n}\n\nstatic int __write_desc(int test_desc_fd, struct xfrm_desc *desc)\n{\n\tssize_t ret;\n\n\tret = write(test_desc_fd, desc, sizeof(*desc));\n\n\tif (ret == sizeof(*desc))\n\t\treturn 0;\n\n\tpr_err(\"Writing test's desc failed %ld\", ret);\n\n\treturn -1;\n}\n\nstatic int write_desc(int proto, int test_desc_fd,\n\t\tchar *a, char *e, char *c, char *ae)\n{\n\tstruct xfrm_desc desc = {};\n\n\tdesc.type = CREATE_TUNNEL;\n\tdesc.proto = proto;\n\n\tif (a)\n\t\tstrncpy(desc.a_algo, a, ALGO_LEN - 1);\n\tif (e)\n\t\tstrncpy(desc.e_algo, e, ALGO_LEN - 1);\n\tif (c)\n\t\tstrncpy(desc.c_algo, c, ALGO_LEN - 1);\n\tif (ae)\n\t\tstrncpy(desc.ae_algo, ae, ALGO_LEN - 1);\n\n\treturn __write_desc(test_desc_fd, &desc);\n}\n\nint proto_list[] = { IPPROTO_AH, IPPROTO_COMP, IPPROTO_ESP };\nchar *ah_list[] = {\n\t\"digest_null\", \"hmac(md5)\", \"hmac(sha1)\", \"hmac(sha256)\",\n\t\"hmac(sha384)\", \"hmac(sha512)\", \"hmac(rmd160)\",\n\t\"xcbc(aes)\", \"cmac(aes)\"\n};\nchar *comp_list[] = {\n\t\"deflate\",\n#if 0\n\t \n\t\"lzs\", \"lzjh\"\n#endif\n};\nchar *e_list[] = {\n\t\"ecb(cipher_null)\", \"cbc(des)\", \"cbc(des3_ede)\", \"cbc(cast5)\",\n\t\"cbc(blowfish)\", \"cbc(aes)\", \"cbc(serpent)\", \"cbc(camellia)\",\n\t\"cbc(twofish)\", \"rfc3686(ctr(aes))\"\n};\nchar *ae_list[] = {\n#if 0\n\t \n\t\"rfc4106(gcm(aes))\", \"rfc4309(ccm(aes))\", \"rfc4543(gcm(aes))\",\n\t\"rfc7539esp(chacha20,poly1305)\"\n#endif\n};\n\nconst unsigned int proto_plan = ARRAY_SIZE(ah_list) + ARRAY_SIZE(comp_list) \\\n\t\t\t\t+ (ARRAY_SIZE(ah_list) * ARRAY_SIZE(e_list)) \\\n\t\t\t\t+ ARRAY_SIZE(ae_list);\n\nstatic int write_proto_plan(int fd, int proto)\n{\n\tunsigned int i;\n\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\t\tfor (i = 0; i < ARRAY_SIZE(ah_list); i++) {\n\t\t\tif (write_desc(proto, fd, ah_list[i], 0, 0, 0))\n\t\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase IPPROTO_COMP:\n\t\tfor (i = 0; i < ARRAY_SIZE(comp_list); i++) {\n\t\t\tif (write_desc(proto, fd, 0, 0, comp_list[i], 0))\n\t\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase IPPROTO_ESP:\n\t\tfor (i = 0; i < ARRAY_SIZE(ah_list); i++) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < ARRAY_SIZE(e_list); j++) {\n\t\t\t\tif (write_desc(proto, fd, ah_list[i],\n\t\t\t\t\t\t\te_list[j], 0, 0))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(ae_list); i++) {\n\t\t\tif (write_desc(proto, fd, 0, 0, 0, ae_list[i]))\n\t\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"BUG: Specified unknown proto %d\", proto);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nconst unsigned int compat_plan = 5;\nstatic int write_compat_struct_tests(int test_desc_fd)\n{\n\tstruct xfrm_desc desc = {};\n\n\tdesc.type = ALLOCATE_SPI;\n\tdesc.proto = IPPROTO_AH;\n\tstrncpy(desc.a_algo, ah_list[0], ALGO_LEN - 1);\n\n\tif (__write_desc(test_desc_fd, &desc))\n\t\treturn -1;\n\n\tdesc.type = MONITOR_ACQUIRE;\n\tif (__write_desc(test_desc_fd, &desc))\n\t\treturn -1;\n\n\tdesc.type = EXPIRE_STATE;\n\tif (__write_desc(test_desc_fd, &desc))\n\t\treturn -1;\n\n\tdesc.type = EXPIRE_POLICY;\n\tif (__write_desc(test_desc_fd, &desc))\n\t\treturn -1;\n\n\tdesc.type = SPDINFO_ATTRS;\n\tif (__write_desc(test_desc_fd, &desc))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int write_test_plan(int test_desc_fd)\n{\n\tunsigned int i;\n\tpid_t child;\n\n\tchild = fork();\n\tif (child < 0) {\n\t\tpr_err(\"fork()\");\n\t\treturn -1;\n\t}\n\tif (child) {\n\t\tif (close(test_desc_fd))\n\t\t\tprintk(\"close(): %m\");\n\t\treturn 0;\n\t}\n\n\tif (write_compat_struct_tests(test_desc_fd))\n\t\texit(KSFT_FAIL);\n\n\tfor (i = 0; i < ARRAY_SIZE(proto_list); i++) {\n\t\tif (write_proto_plan(test_desc_fd, proto_list[i]))\n\t\t\texit(KSFT_FAIL);\n\t}\n\n\texit(KSFT_PASS);\n}\n\nstatic int children_cleanup(void)\n{\n\tunsigned ret = KSFT_PASS;\n\n\twhile (1) {\n\t\tint status;\n\t\tpid_t p = wait(&status);\n\n\t\tif ((p < 0) && errno == ECHILD)\n\t\t\tbreak;\n\n\t\tif (p < 0) {\n\t\t\tpr_err(\"wait()\");\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\n\t\tif (!WIFEXITED(status)) {\n\t\t\tret = KSFT_FAIL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (WEXITSTATUS(status) == KSFT_FAIL)\n\t\t\tret = KSFT_FAIL;\n\t}\n\n\treturn ret;\n}\n\ntypedef void (*print_res)(const char *, ...);\n\nstatic int check_results(void)\n{\n\tstruct test_result tr = {};\n\tstruct xfrm_desc *d = &tr.desc;\n\tint ret = KSFT_PASS;\n\n\twhile (1) {\n\t\tssize_t received = read(results_fd[0], &tr, sizeof(tr));\n\t\tprint_res result;\n\n\t\tif (received == 0)  \n\t\t\tbreak;\n\n\t\tif (received != sizeof(tr)) {\n\t\t\tpr_err(\"read() returned %zd\", received);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\n\t\tswitch (tr.res) {\n\t\tcase KSFT_PASS:\n\t\t\tresult = ksft_test_result_pass;\n\t\t\tbreak;\n\t\tcase KSFT_FAIL:\n\t\tdefault:\n\t\t\tresult = ksft_test_result_fail;\n\t\t\tret = KSFT_FAIL;\n\t\t}\n\n\t\tresult(\" %s: [%u, '%s', '%s', '%s', '%s', %u]\\n\",\n\t\t       desc_name[d->type], (unsigned int)d->proto, d->a_algo,\n\t\t       d->e_algo, d->c_algo, d->ae_algo, d->icv_len);\n\t}\n\n\treturn ret;\n}\n\nint main(int argc, char **argv)\n{\n\tlong nr_process = 1;\n\tint route_sock = -1, ret = KSFT_SKIP;\n\tint test_desc_fd[2];\n\tuint32_t route_seq;\n\tunsigned int i;\n\n\tif (argc > 2)\n\t\texit_usage(argv);\n\n\tif (argc > 1) {\n\t\tchar *endptr;\n\n\t\terrno = 0;\n\t\tnr_process = strtol(argv[1], &endptr, 10);\n\t\tif ((errno == ERANGE && (nr_process == LONG_MAX || nr_process == LONG_MIN))\n\t\t\t\t|| (errno != 0 && nr_process == 0)\n\t\t\t\t|| (endptr == argv[1]) || (*endptr != '\\0')) {\n\t\t\tprintk(\"Failed to parse [nr_process]\");\n\t\t\texit_usage(argv);\n\t\t}\n\n\t\tif (nr_process > MAX_PROCESSES || nr_process < 1) {\n\t\t\tprintk(\"nr_process should be between [1; %u]\",\n\t\t\t\t\tMAX_PROCESSES);\n\t\t\texit_usage(argv);\n\t\t}\n\t}\n\n\tsrand(time(NULL));\n\tpage_size = sysconf(_SC_PAGESIZE);\n\tif (page_size < 1)\n\t\tksft_exit_skip(\"sysconf(): %m\\n\");\n\n\tif (pipe2(test_desc_fd, O_DIRECT) < 0)\n\t\tksft_exit_skip(\"pipe(): %m\\n\");\n\n\tif (pipe2(results_fd, O_DIRECT) < 0)\n\t\tksft_exit_skip(\"pipe(): %m\\n\");\n\n\tif (init_namespaces())\n\t\tksft_exit_skip(\"Failed to create namespaces\\n\");\n\n\tif (netlink_sock(&route_sock, &route_seq, NETLINK_ROUTE))\n\t\tksft_exit_skip(\"Failed to open netlink route socket\\n\");\n\n\tfor (i = 0; i < nr_process; i++) {\n\t\tchar veth[VETH_LEN];\n\n\t\tsnprintf(veth, VETH_LEN, VETH_FMT, i);\n\n\t\tif (veth_add(route_sock, route_seq++, veth, nsfd_childa, veth, nsfd_childb)) {\n\t\t\tclose(route_sock);\n\t\t\tksft_exit_fail_msg(\"Failed to create veth device\");\n\t\t}\n\n\t\tif (start_child(i, veth, test_desc_fd)) {\n\t\t\tclose(route_sock);\n\t\t\tksft_exit_fail_msg(\"Child %u failed to start\", i);\n\t\t}\n\t}\n\n\tif (close(route_sock) || close(test_desc_fd[0]) || close(results_fd[1]))\n\t\tksft_exit_fail_msg(\"close(): %m\");\n\n\tksft_set_plan(proto_plan + compat_plan);\n\n\tif (write_test_plan(test_desc_fd[1]))\n\t\tksft_exit_fail_msg(\"Failed to write test plan to pipe\");\n\n\tret = check_results();\n\n\tif (children_cleanup() == KSFT_FAIL)\n\t\texit(KSFT_FAIL);\n\n\texit(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}