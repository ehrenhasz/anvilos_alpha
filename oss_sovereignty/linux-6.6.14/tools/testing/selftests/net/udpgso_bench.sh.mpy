{
  "module_name": "udpgso_bench.sh",
  "hash_id": "8d42c3a1687440c610c72edba42176dd95a64c9d9f4a02afd7a84bf97625bb18",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/udpgso_bench.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Run a series of udpgso benchmarks\n\nreadonly GREEN='\\033[0;92m'\nreadonly YELLOW='\\033[0;33m'\nreadonly RED='\\033[0;31m'\nreadonly NC='\\033[0m' # No Color\nreadonly TESTPORT=8000\n\nreadonly KSFT_PASS=0\nreadonly KSFT_FAIL=1\nreadonly KSFT_SKIP=4\n\nnum_pass=0\nnum_err=0\nnum_skip=0\n\nkselftest_test_exitcode() {\n\tlocal -r exitcode=$1\n\n\tif [[ ${exitcode} -eq ${KSFT_PASS} ]]; then\n\t\tnum_pass=$(( $num_pass + 1 ))\n\telif [[ ${exitcode} -eq ${KSFT_SKIP} ]]; then\n\t\tnum_skip=$(( $num_skip + 1 ))\n\telse\n\t\tnum_err=$(( $num_err + 1 ))\n\tfi\n}\n\nkselftest_exit() {\n\techo -e \"$(basename $0): PASS=${num_pass} SKIP=${num_skip} FAIL=${num_err}\"\n\n\tif [[ $num_err -ne 0 ]]; then\n\t\techo -e \"$(basename $0): ${RED}FAIL${NC}\"\n\t\texit ${KSFT_FAIL}\n\tfi\n\n\tif [[ $num_skip -ne 0 ]]; then\n\t\techo -e \"$(basename $0): ${YELLOW}SKIP${NC}\"\n\t\texit ${KSFT_SKIP}\n\tfi\n\n\techo -e \"$(basename $0): ${GREEN}PASS${NC}\"\n\texit ${KSFT_PASS}\n}\n\nwake_children() {\n\tlocal -r jobs=\"$(jobs -p)\"\n\n\tif [[ \"${jobs}\" != \"\" ]]; then\n\t\tkill -1 ${jobs} 2>/dev/null\n\tfi\n}\ntrap wake_children EXIT\n\nrun_one() {\n\tlocal -r args=$@\n\tlocal nr_socks=0\n\tlocal i=0\n\tlocal -r timeout=10\n\n\t./udpgso_bench_rx -p \"$TESTPORT\" &\n\t./udpgso_bench_rx -p \"$TESTPORT\" -t &\n\n\t# Wait for the above test program to get ready to receive connections.\n\twhile [ \"$i\" -lt \"$timeout\" ]; do\n\t\tnr_socks=\"$(ss -lnHi | grep -c \"\\*:${TESTPORT}\")\"\n\t\t[ \"$nr_socks\" -eq 2 ] && break\n\t\ti=$((i + 1))\n\t\tsleep 1\n\tdone\n\tif [ \"$nr_socks\" -ne 2 ]; then\n\t\techo \"timed out while waiting for udpgso_bench_rx\"\n\t\texit 1\n\tfi\n\n\t./udpgso_bench_tx -p \"$TESTPORT\" ${args}\n}\n\nrun_in_netns() {\n\tlocal -r args=$@\n\n\t./in_netns.sh $0 __subprocess ${args}\n\tkselftest_test_exitcode $?\n}\n\nrun_udp() {\n\tlocal -r args=$@\n\n\techo \"udp\"\n\trun_in_netns ${args}\n\n\techo \"udp gso\"\n\trun_in_netns ${args} -S 0\n\n\techo \"udp gso zerocopy\"\n\trun_in_netns ${args} -S 0 -z\n\n\techo \"udp gso timestamp\"\n\trun_in_netns ${args} -S 0 -T\n\n\techo \"udp gso zerocopy audit\"\n\trun_in_netns ${args} -S 0 -z -a\n\n\techo \"udp gso timestamp audit\"\n\trun_in_netns ${args} -S 0 -T -a\n\n\techo \"udp gso zerocopy timestamp audit\"\n\trun_in_netns ${args} -S 0 -T -z -a\n}\n\nrun_tcp() {\n\tlocal -r args=$@\n\n\techo \"tcp\"\n\trun_in_netns ${args} -t\n\n\techo \"tcp zerocopy\"\n\trun_in_netns ${args} -t -z\n\n\t# excluding for now because test fails intermittently\n\t# add -P option to include poll() to reduce possibility of lost messages\n\t#echo \"tcp zerocopy audit\"\n\t#run_in_netns ${args} -t -z -P -a\n}\n\nrun_all() {\n\tlocal -r core_args=\"-l 3\"\n\tlocal -r ipv4_args=\"${core_args} -4 -D 127.0.0.1\"\n\tlocal -r ipv6_args=\"${core_args} -6 -D ::1\"\n\n\techo \"ipv4\"\n\trun_tcp \"${ipv4_args}\"\n\trun_udp \"${ipv4_args}\"\n\n\techo \"ipv6\"\n\trun_tcp \"${ipv6_args}\"\n\trun_udp \"${ipv6_args}\"\n}\n\nif [[ $# -eq 0 ]]; then\n\trun_all\n\tkselftest_exit\nelif [[ $1 == \"__subprocess\" ]]; then\n\tshift\n\trun_one $@\nelse\n\trun_in_netns $@\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}