{
  "module_name": "tcp_fastopen_backup_key.c",
  "hash_id": "83cb3fdff5f0956a01634db870f24383ea8d74c9718647608348a9162ba31ffc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/tcp_fastopen_backup_key.c",
  "human_readable_source": "\n\n \n#define _GNU_SOURCE\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <netinet/tcp.h>\n#include <fcntl.h>\n#include <time.h>\n\n#include \"../kselftest.h\"\n\n#ifndef TCP_FASTOPEN_KEY\n#define TCP_FASTOPEN_KEY 33\n#endif\n\n#define N_LISTEN 10\n#define PROC_FASTOPEN_KEY \"/proc/sys/net/ipv4/tcp_fastopen_key\"\n#define KEY_LENGTH 16\n\nstatic bool do_ipv6;\nstatic bool do_sockopt;\nstatic bool do_rotate;\nstatic int key_len = KEY_LENGTH;\nstatic int rcv_fds[N_LISTEN];\nstatic int proc_fd;\nstatic const char *IP4_ADDR = \"127.0.0.1\";\nstatic const char *IP6_ADDR = \"::1\";\nstatic const int PORT = 8891;\n\nstatic void get_keys(int fd, uint32_t *keys)\n{\n\tchar buf[128];\n\tsocklen_t len = KEY_LENGTH * 2;\n\n\tif (do_sockopt) {\n\t\tif (getsockopt(fd, SOL_TCP, TCP_FASTOPEN_KEY, keys, &len))\n\t\t\terror(1, errno, \"Unable to get key\");\n\t\treturn;\n\t}\n\tlseek(proc_fd, 0, SEEK_SET);\n\tif (read(proc_fd, buf, sizeof(buf)) <= 0)\n\t\terror(1, errno, \"Unable to read %s\", PROC_FASTOPEN_KEY);\n\tif (sscanf(buf, \"%x-%x-%x-%x,%x-%x-%x-%x\", keys, keys + 1, keys + 2,\n\t    keys + 3, keys + 4, keys + 5, keys + 6, keys + 7) != 8)\n\t\terror(1, 0, \"Unable to parse %s\", PROC_FASTOPEN_KEY);\n}\n\nstatic void set_keys(int fd, uint32_t *keys)\n{\n\tchar buf[128];\n\n\tif (do_sockopt) {\n\t\tif (setsockopt(fd, SOL_TCP, TCP_FASTOPEN_KEY, keys,\n\t\t    key_len))\n\t\t\terror(1, errno, \"Unable to set key\");\n\t\treturn;\n\t}\n\tif (do_rotate)\n\t\tsnprintf(buf, 128, \"%08x-%08x-%08x-%08x,%08x-%08x-%08x-%08x\",\n\t\t\t keys[0], keys[1], keys[2], keys[3], keys[4], keys[5],\n\t\t\t keys[6], keys[7]);\n\telse\n\t\tsnprintf(buf, 128, \"%08x-%08x-%08x-%08x\",\n\t\t\t keys[0], keys[1], keys[2], keys[3]);\n\tlseek(proc_fd, 0, SEEK_SET);\n\tif (write(proc_fd, buf, sizeof(buf)) <= 0)\n\t\terror(1, errno, \"Unable to write %s\", PROC_FASTOPEN_KEY);\n}\n\nstatic void build_rcv_fd(int family, int proto, int *rcv_fds)\n{\n\tstruct sockaddr_in  addr4 = {0};\n\tstruct sockaddr_in6 addr6 = {0};\n\tstruct sockaddr *addr;\n\tint opt = 1, i, sz;\n\tint qlen = 100;\n\tuint32_t keys[8];\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr4.sin_family = family;\n\t\taddr4.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\taddr4.sin_port = htons(PORT);\n\t\tsz = sizeof(addr4);\n\t\taddr = (struct sockaddr *)&addr4;\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddr6.sin6_family = AF_INET6;\n\t\taddr6.sin6_addr = in6addr_any;\n\t\taddr6.sin6_port = htons(PORT);\n\t\tsz = sizeof(addr6);\n\t\taddr = (struct sockaddr *)&addr6;\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t\t \n\t\treturn;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(keys); i++)\n\t\tkeys[i] = rand();\n\tfor (i = 0; i < N_LISTEN; i++) {\n\t\trcv_fds[i] = socket(family, proto, 0);\n\t\tif (rcv_fds[i] < 0)\n\t\t\terror(1, errno, \"failed to create receive socket\");\n\t\tif (setsockopt(rcv_fds[i], SOL_SOCKET, SO_REUSEPORT, &opt,\n\t\t\t       sizeof(opt)))\n\t\t\terror(1, errno, \"failed to set SO_REUSEPORT\");\n\t\tif (bind(rcv_fds[i], addr, sz))\n\t\t\terror(1, errno, \"failed to bind receive socket\");\n\t\tif (setsockopt(rcv_fds[i], SOL_TCP, TCP_FASTOPEN, &qlen,\n\t\t\t       sizeof(qlen)))\n\t\t\terror(1, errno, \"failed to set TCP_FASTOPEN\");\n\t\tset_keys(rcv_fds[i], keys);\n\t\tif (proto == SOCK_STREAM && listen(rcv_fds[i], 10))\n\t\t\terror(1, errno, \"failed to listen on receive port\");\n\t}\n}\n\nstatic int connect_and_send(int family, int proto)\n{\n\tstruct sockaddr_in  saddr4 = {0};\n\tstruct sockaddr_in  daddr4 = {0};\n\tstruct sockaddr_in6 saddr6 = {0};\n\tstruct sockaddr_in6 daddr6 = {0};\n\tstruct sockaddr *saddr, *daddr;\n\tint fd, sz, ret;\n\tchar data[1];\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tsaddr4.sin_family = AF_INET;\n\t\tsaddr4.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tsaddr4.sin_port = 0;\n\n\t\tdaddr4.sin_family = AF_INET;\n\t\tif (!inet_pton(family, IP4_ADDR, &daddr4.sin_addr.s_addr))\n\t\t\terror(1, errno, \"inet_pton failed: %s\", IP4_ADDR);\n\t\tdaddr4.sin_port = htons(PORT);\n\n\t\tsz = sizeof(saddr4);\n\t\tsaddr = (struct sockaddr *)&saddr4;\n\t\tdaddr = (struct sockaddr *)&daddr4;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsaddr6.sin6_family = AF_INET6;\n\t\tsaddr6.sin6_addr = in6addr_any;\n\n\t\tdaddr6.sin6_family = AF_INET6;\n\t\tif (!inet_pton(family, IP6_ADDR, &daddr6.sin6_addr))\n\t\t\terror(1, errno, \"inet_pton failed: %s\", IP6_ADDR);\n\t\tdaddr6.sin6_port = htons(PORT);\n\n\t\tsz = sizeof(saddr6);\n\t\tsaddr = (struct sockaddr *)&saddr6;\n\t\tdaddr = (struct sockaddr *)&daddr6;\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t\t \n\t\treturn -1;\n\t}\n\tfd = socket(family, proto, 0);\n\tif (fd < 0)\n\t\terror(1, errno, \"failed to create send socket\");\n\tif (bind(fd, saddr, sz))\n\t\terror(1, errno, \"failed to bind send socket\");\n\tdata[0] = 'a';\n\tret = sendto(fd, data, 1, MSG_FASTOPEN, daddr, sz);\n\tif (ret != 1)\n\t\terror(1, errno, \"failed to sendto\");\n\n\treturn fd;\n}\n\nstatic bool is_listen_fd(int fd)\n{\n\tint i;\n\n\tfor (i = 0; i < N_LISTEN; i++) {\n\t\tif (rcv_fds[i] == fd)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void rotate_key(int fd)\n{\n\tstatic int iter;\n\tstatic uint32_t new_key[4];\n\tuint32_t keys[8];\n\tuint32_t tmp_key[4];\n\tint i;\n\n\tif (iter < N_LISTEN) {\n\t\t \n\t\tif (iter == 0) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(new_key); i++)\n\t\t\t\tnew_key[i] = rand();\n\t\t}\n\t\tget_keys(fd, keys);\n\t\tmemcpy(keys + 4, new_key, KEY_LENGTH);\n\t\tset_keys(fd, keys);\n\t} else {\n\t\t \n\t\tget_keys(fd, keys);\n\t\tmemcpy(tmp_key, keys + 4, KEY_LENGTH);\n\t\tmemcpy(keys + 4, keys, KEY_LENGTH);\n\t\tmemcpy(keys, tmp_key, KEY_LENGTH);\n\t\tset_keys(fd, keys);\n\t}\n\tif (++iter >= (N_LISTEN * 2))\n\t\titer = 0;\n}\n\nstatic void run_one_test(int family)\n{\n\tstruct epoll_event ev;\n\tint i, send_fd;\n\tint n_loops = 10000;\n\tint rotate_key_fd = 0;\n\tint key_rotate_interval = 50;\n\tint fd, epfd;\n\tchar buf[1];\n\n\tbuild_rcv_fd(family, SOCK_STREAM, rcv_fds);\n\tepfd = epoll_create(1);\n\tif (epfd < 0)\n\t\terror(1, errno, \"failed to create epoll\");\n\tev.events = EPOLLIN;\n\tfor (i = 0; i < N_LISTEN; i++) {\n\t\tev.data.fd = rcv_fds[i];\n\t\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, rcv_fds[i], &ev))\n\t\t\terror(1, errno, \"failed to register sock epoll\");\n\t}\n\twhile (n_loops--) {\n\t\tsend_fd = connect_and_send(family, SOCK_STREAM);\n\t\tif (do_rotate && ((n_loops % key_rotate_interval) == 0)) {\n\t\t\trotate_key(rcv_fds[rotate_key_fd]);\n\t\t\tif (++rotate_key_fd >= N_LISTEN)\n\t\t\t\trotate_key_fd = 0;\n\t\t}\n\t\twhile (1) {\n\t\t\ti = epoll_wait(epfd, &ev, 1, -1);\n\t\t\tif (i < 0)\n\t\t\t\terror(1, errno, \"epoll_wait failed\");\n\t\t\tif (is_listen_fd(ev.data.fd)) {\n\t\t\t\tfd = accept(ev.data.fd, NULL, NULL);\n\t\t\t\tif (fd < 0)\n\t\t\t\t\terror(1, errno, \"failed to accept\");\n\t\t\t\tev.data.fd = fd;\n\t\t\t\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev))\n\t\t\t\t\terror(1, errno, \"failed epoll add\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = recv(ev.data.fd, buf, sizeof(buf), 0);\n\t\t\tif (i != 1)\n\t\t\t\terror(1, errno, \"failed recv data\");\n\t\t\tif (epoll_ctl(epfd, EPOLL_CTL_DEL, ev.data.fd, NULL))\n\t\t\t\terror(1, errno, \"failed epoll del\");\n\t\t\tclose(ev.data.fd);\n\t\t\tbreak;\n\t\t}\n\t\tclose(send_fd);\n\t}\n\tfor (i = 0; i < N_LISTEN; i++)\n\t\tclose(rcv_fds[i]);\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"46sr\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tdo_ipv6 = false;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tdo_ipv6 = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tdo_sockopt = true;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tdo_rotate = true;\n\t\t\tkey_len = KEY_LENGTH * 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"%s: parse error\", argv[0]);\n\t\t}\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tparse_opts(argc, argv);\n\tproc_fd = open(PROC_FASTOPEN_KEY, O_RDWR);\n\tif (proc_fd < 0)\n\t\terror(1, errno, \"Unable to open %s\", PROC_FASTOPEN_KEY);\n\tsrand(time(NULL));\n\tif (do_ipv6)\n\t\trun_one_test(AF_INET6);\n\telse\n\t\trun_one_test(AF_INET);\n\tclose(proc_fd);\n\tfprintf(stderr, \"PASS\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}