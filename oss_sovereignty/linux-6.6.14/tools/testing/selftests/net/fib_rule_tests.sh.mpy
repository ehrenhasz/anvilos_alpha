{
  "module_name": "fib_rule_tests.sh",
  "hash_id": "1602bbd2abd9922377da2390b488db442e3fd70af97b689abfd7a55e3aaa36b1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/fib_rule_tests.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# This test is for checking IPv4 and IPv6 FIB rules API\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\nret=0\n\nPAUSE_ON_FAIL=${PAUSE_ON_FAIL:=no}\nIP=\"ip -netns testns\"\nIP_PEER=\"ip -netns peerns\"\n\nRTABLE=100\nRTABLE_PEER=101\nGW_IP4=192.51.100.2\nSRC_IP=192.51.100.3\nGW_IP6=2001:db8:1::2\nSRC_IP6=2001:db8:1::3\n\nDEV_ADDR=192.51.100.1\nDEV_ADDR6=2001:db8:1::1\nDEV=dummy0\nTESTS=\"fib_rule6 fib_rule4 fib_rule6_connect fib_rule4_connect\"\n\nSELFTEST_PATH=\"\"\n\nlog_test()\n{\n\tlocal rc=$1\n\tlocal expected=$2\n\tlocal msg=\"$3\"\n\n\tif [ ${rc} -eq ${expected} ]; then\n\t\tnsuccess=$((nsuccess+1))\n\t\tprintf \"\\n    TEST: %-50s  [ OK ]\\n\" \"${msg}\"\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"\\n    TEST: %-50s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n}\n\nlog_section()\n{\n\techo\n\techo \"######################################################################\"\n\techo \"TEST SECTION: $*\"\n\techo \"######################################################################\"\n}\n\ncheck_nettest()\n{\n\tif which nettest > /dev/null 2>&1; then\n\t\treturn 0\n\tfi\n\n\t# Add the selftest directory to PATH if not already done\n\tif [ \"${SELFTEST_PATH}\" = \"\" ]; then\n\t\tSELFTEST_PATH=\"$(dirname $0)\"\n\t\tPATH=\"${PATH}:${SELFTEST_PATH}\"\n\n\t\t# Now retry with the new path\n\t\tif which nettest > /dev/null 2>&1; then\n\t\t\treturn 0\n\t\tfi\n\n\t\tif [ \"${ret}\" -eq 0 ]; then\n\t\t\tret=\"${ksft_skip}\"\n\t\tfi\n\t\techo \"nettest not found (try 'make -C ${SELFTEST_PATH} nettest')\"\n\tfi\n\n\treturn 1\n}\n\nsetup()\n{\n\tset -e\n\tip netns add testns\n\t$IP link set dev lo up\n\n\t$IP link add dummy0 type dummy\n\t$IP link set dev dummy0 up\n\t$IP address add $DEV_ADDR/24 dev dummy0\n\t$IP -6 address add $DEV_ADDR6/64 dev dummy0\n\n\tset +e\n}\n\ncleanup()\n{\n\t$IP link del dev dummy0 &> /dev/null\n\tip netns del testns\n}\n\nsetup_peer()\n{\n\tset -e\n\n\tip netns add peerns\n\t$IP_PEER link set dev lo up\n\n\tip link add name veth0 netns testns type veth \\\n\t\tpeer name veth1 netns peerns\n\t$IP link set dev veth0 up\n\t$IP_PEER link set dev veth1 up\n\n\t$IP address add 192.0.2.10 peer 192.0.2.11/32 dev veth0\n\t$IP_PEER address add 192.0.2.11 peer 192.0.2.10/32 dev veth1\n\n\t$IP address add 2001:db8::10 peer 2001:db8::11/128 dev veth0 nodad\n\t$IP_PEER address add 2001:db8::11 peer 2001:db8::10/128 dev veth1 nodad\n\n\t$IP_PEER address add 198.51.100.11/32 dev lo\n\t$IP route add table $RTABLE_PEER 198.51.100.11/32 via 192.0.2.11\n\n\t$IP_PEER address add 2001:db8::1:11/128 dev lo\n\t$IP route add table $RTABLE_PEER 2001:db8::1:11/128 via 2001:db8::11\n\n\tset +e\n}\n\ncleanup_peer()\n{\n\t$IP link del dev veth0\n\tip netns del peerns\n}\n\nfib_check_iproute_support()\n{\n\tip rule help 2>&1 | grep -q $1\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: iproute2 iprule too old, missing $1 match\"\n\t\treturn 1\n\tfi\n\n\tip route get help 2>&1 | grep -q $2\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: iproute2 get route too old, missing $2 match\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\nfib_rule6_del()\n{\n\t$IP -6 rule del $1\n\tlog_test $? 0 \"rule6 del $1\"\n}\n\nfib_rule6_del_by_pref()\n{\n\tpref=$($IP -6 rule show $1 table $RTABLE | cut -d \":\" -f 1)\n\t$IP -6 rule del pref $pref\n}\n\nfib_rule6_test_match_n_redirect()\n{\n\tlocal match=\"$1\"\n\tlocal getmatch=\"$2\"\n\tlocal description=\"$3\"\n\n\t$IP -6 rule add $match table $RTABLE\n\t$IP -6 route get $GW_IP6 $getmatch | grep -q \"table $RTABLE\"\n\tlog_test $? 0 \"rule6 check: $description\"\n\n\tfib_rule6_del_by_pref \"$match\"\n\tlog_test $? 0 \"rule6 del by pref: $description\"\n}\n\nfib_rule6_test_reject()\n{\n\tlocal match=\"$1\"\n\tlocal rc\n\n\t$IP -6 rule add $match table $RTABLE 2>/dev/null\n\trc=$?\n\tlog_test $rc 2 \"rule6 check: $match\"\n\n\tif [ $rc -eq 0 ]; then\n\t\t$IP -6 rule del $match table $RTABLE\n\tfi\n}\n\nfib_rule6_test()\n{\n\tlocal getmatch\n\tlocal match\n\tlocal cnt\n\n\t# setup the fib rule redirect route\n\t$IP -6 route add table $RTABLE default via $GW_IP6 dev $DEV onlink\n\n\tmatch=\"oif $DEV\"\n\tfib_rule6_test_match_n_redirect \"$match\" \"$match\" \"oif redirect to table\"\n\n\tmatch=\"from $SRC_IP6 iif $DEV\"\n\tfib_rule6_test_match_n_redirect \"$match\" \"$match\" \"iif redirect to table\"\n\n\t# Reject dsfield (tos) options which have ECN bits set\n\tfor cnt in $(seq 1 3); do\n\t\tmatch=\"dsfield $cnt\"\n\t\tfib_rule6_test_reject \"$match\"\n\tdone\n\n\t# Don't take ECN bits into account when matching on dsfield\n\tmatch=\"tos 0x10\"\n\tfor cnt in \"0x10\" \"0x11\" \"0x12\" \"0x13\"; do\n\t\t# Using option 'tos' instead of 'dsfield' as old iproute2\n\t\t# versions don't support 'dsfield' in ip rule show.\n\t\tgetmatch=\"tos $cnt\"\n\t\tfib_rule6_test_match_n_redirect \"$match\" \"$getmatch\" \\\n\t\t\t\t\t\t\"$getmatch redirect to table\"\n\tdone\n\n\tmatch=\"fwmark 0x64\"\n\tgetmatch=\"mark 0x64\"\n\tfib_rule6_test_match_n_redirect \"$match\" \"$getmatch\" \"fwmark redirect to table\"\n\n\tfib_check_iproute_support \"uidrange\" \"uid\"\n\tif [ $? -eq 0 ]; then\n\t\tmatch=\"uidrange 100-100\"\n\t\tgetmatch=\"uid 100\"\n\t\tfib_rule6_test_match_n_redirect \"$match\" \"$getmatch\" \"uid redirect to table\"\n\tfi\n\n\tfib_check_iproute_support \"sport\" \"sport\"\n\tif [ $? -eq 0 ]; then\n\t\tmatch=\"sport 666 dport 777\"\n\t\tfib_rule6_test_match_n_redirect \"$match\" \"$match\" \"sport and dport redirect to table\"\n\tfi\n\n\tfib_check_iproute_support \"ipproto\" \"ipproto\"\n\tif [ $? -eq 0 ]; then\n\t\tmatch=\"ipproto tcp\"\n\t\tfib_rule6_test_match_n_redirect \"$match\" \"$match\" \"ipproto match\"\n\tfi\n\n\tfib_check_iproute_support \"ipproto\" \"ipproto\"\n\tif [ $? -eq 0 ]; then\n\t\tmatch=\"ipproto ipv6-icmp\"\n\t\tfib_rule6_test_match_n_redirect \"$match\" \"$match\" \"ipproto ipv6-icmp match\"\n\tfi\n}\n\n# Verify that the IPV6_TCLASS option of UDPv6 and TCPv6 sockets is properly\n# taken into account when connecting the socket and when sending packets.\nfib_rule6_connect_test()\n{\n\tlocal dsfield\n\n\tif ! check_nettest; then\n\t\techo \"SKIP: Could not run test without nettest tool\"\n\t\treturn\n\tfi\n\n\tsetup_peer\n\t$IP -6 rule add dsfield 0x04 table $RTABLE_PEER\n\n\t# Combine the base DS Field value (0x04) with all possible ECN values\n\t# (Not-ECT: 0, ECT(1): 1, ECT(0): 2, CE: 3).\n\t# The ECN bits shouldn't influence the result of the test.\n\tfor dsfield in 0x04 0x05 0x06 0x07; do\n\t\tnettest -q -6 -B -t 5 -N testns -O peerns -U -D \\\n\t\t\t-Q \"${dsfield}\" -l 2001:db8::1:11 -r 2001:db8::1:11\n\t\tlog_test $? 0 \"rule6 dsfield udp connect (dsfield ${dsfield})\"\n\n\t\tnettest -q -6 -B -t 5 -N testns -O peerns -Q \"${dsfield}\" \\\n\t\t\t-l 2001:db8::1:11 -r 2001:db8::1:11\n\t\tlog_test $? 0 \"rule6 dsfield tcp connect (dsfield ${dsfield})\"\n\tdone\n\n\t$IP -6 rule del dsfield 0x04 table $RTABLE_PEER\n\tcleanup_peer\n}\n\nfib_rule4_del()\n{\n\t$IP rule del $1\n\tlog_test $? 0 \"del $1\"\n}\n\nfib_rule4_del_by_pref()\n{\n\tpref=$($IP rule show $1 table $RTABLE | cut -d \":\" -f 1)\n\t$IP rule del pref $pref\n}\n\nfib_rule4_test_match_n_redirect()\n{\n\tlocal match=\"$1\"\n\tlocal getmatch=\"$2\"\n\tlocal description=\"$3\"\n\n\t$IP rule add $match table $RTABLE\n\t$IP route get $GW_IP4 $getmatch | grep -q \"table $RTABLE\"\n\tlog_test $? 0 \"rule4 check: $description\"\n\n\tfib_rule4_del_by_pref \"$match\"\n\tlog_test $? 0 \"rule4 del by pref: $description\"\n}\n\nfib_rule4_test_reject()\n{\n\tlocal match=\"$1\"\n\tlocal rc\n\n\t$IP rule add $match table $RTABLE 2>/dev/null\n\trc=$?\n\tlog_test $rc 2 \"rule4 check: $match\"\n\n\tif [ $rc -eq 0 ]; then\n\t\t$IP rule del $match table $RTABLE\n\tfi\n}\n\nfib_rule4_test()\n{\n\tlocal getmatch\n\tlocal match\n\tlocal cnt\n\n\t# setup the fib rule redirect route\n\t$IP route add table $RTABLE default via $GW_IP4 dev $DEV onlink\n\n\tmatch=\"oif $DEV\"\n\tfib_rule4_test_match_n_redirect \"$match\" \"$match\" \"oif redirect to table\"\n\n\t# need enable forwarding and disable rp_filter temporarily as all the\n\t# addresses are in the same subnet and egress device == ingress device.\n\tip netns exec testns sysctl -qw net.ipv4.ip_forward=1\n\tip netns exec testns sysctl -qw net.ipv4.conf.$DEV.rp_filter=0\n\tmatch=\"from $SRC_IP iif $DEV\"\n\tfib_rule4_test_match_n_redirect \"$match\" \"$match\" \"iif redirect to table\"\n\tip netns exec testns sysctl -qw net.ipv4.ip_forward=0\n\n\t# Reject dsfield (tos) options which have ECN bits set\n\tfor cnt in $(seq 1 3); do\n\t\tmatch=\"dsfield $cnt\"\n\t\tfib_rule4_test_reject \"$match\"\n\tdone\n\n\t# Don't take ECN bits into account when matching on dsfield\n\tmatch=\"tos 0x10\"\n\tfor cnt in \"0x10\" \"0x11\" \"0x12\" \"0x13\"; do\n\t\t# Using option 'tos' instead of 'dsfield' as old iproute2\n\t\t# versions don't support 'dsfield' in ip rule show.\n\t\tgetmatch=\"tos $cnt\"\n\t\tfib_rule4_test_match_n_redirect \"$match\" \"$getmatch\" \\\n\t\t\t\t\t\t\"$getmatch redirect to table\"\n\tdone\n\n\tmatch=\"fwmark 0x64\"\n\tgetmatch=\"mark 0x64\"\n\tfib_rule4_test_match_n_redirect \"$match\" \"$getmatch\" \"fwmark redirect to table\"\n\n\tfib_check_iproute_support \"uidrange\" \"uid\"\n\tif [ $? -eq 0 ]; then\n\t\tmatch=\"uidrange 100-100\"\n\t\tgetmatch=\"uid 100\"\n\t\tfib_rule4_test_match_n_redirect \"$match\" \"$getmatch\" \"uid redirect to table\"\n\tfi\n\n\tfib_check_iproute_support \"sport\" \"sport\"\n\tif [ $? -eq 0 ]; then\n\t\tmatch=\"sport 666 dport 777\"\n\t\tfib_rule4_test_match_n_redirect \"$match\" \"$match\" \"sport and dport redirect to table\"\n\tfi\n\n\tfib_check_iproute_support \"ipproto\" \"ipproto\"\n\tif [ $? -eq 0 ]; then\n\t\tmatch=\"ipproto tcp\"\n\t\tfib_rule4_test_match_n_redirect \"$match\" \"$match\" \"ipproto tcp match\"\n\tfi\n\n\tfib_check_iproute_support \"ipproto\" \"ipproto\"\n\tif [ $? -eq 0 ]; then\n\t\tmatch=\"ipproto icmp\"\n\t\tfib_rule4_test_match_n_redirect \"$match\" \"$match\" \"ipproto icmp match\"\n\tfi\n}\n\n# Verify that the IP_TOS option of UDPv4 and TCPv4 sockets is properly taken\n# into account when connecting the socket and when sending packets.\nfib_rule4_connect_test()\n{\n\tlocal dsfield\n\n\tif ! check_nettest; then\n\t\techo \"SKIP: Could not run test without nettest tool\"\n\t\treturn\n\tfi\n\n\tsetup_peer\n\t$IP -4 rule add dsfield 0x04 table $RTABLE_PEER\n\n\t# Combine the base DS Field value (0x04) with all possible ECN values\n\t# (Not-ECT: 0, ECT(1): 1, ECT(0): 2, CE: 3).\n\t# The ECN bits shouldn't influence the result of the test.\n\tfor dsfield in 0x04 0x05 0x06 0x07; do\n\t\tnettest -q -B -t 5 -N testns -O peerns -D -U -Q \"${dsfield}\" \\\n\t\t\t-l 198.51.100.11 -r 198.51.100.11\n\t\tlog_test $? 0 \"rule4 dsfield udp connect (dsfield ${dsfield})\"\n\n\t\tnettest -q -B -t 5 -N testns -O peerns -Q \"${dsfield}\" \\\n\t\t\t-l 198.51.100.11 -r 198.51.100.11\n\t\tlog_test $? 0 \"rule4 dsfield tcp connect (dsfield ${dsfield})\"\n\tdone\n\n\t$IP -4 rule del dsfield 0x04 table $RTABLE_PEER\n\tcleanup_peer\n}\n\nrun_fibrule_tests()\n{\n\tlog_section \"IPv4 fib rule\"\n\tfib_rule4_test\n\tlog_section \"IPv6 fib rule\"\n\tfib_rule6_test\n}\n################################################################################\n# usage\n\nusage()\n{\n\tcat <<EOF\nusage: ${0##*/} OPTS\n\n        -t <test>   Test(s) to run (default: all)\n                    (options: $TESTS)\nEOF\n}\n\n################################################################################\n# main\n\nwhile getopts \":t:h\" opt; do\n\tcase $opt in\n\t\tt) TESTS=$OPTARG;;\n\t\th) usage; exit 0;;\n\t\t*) usage; exit 1;;\n\tesac\ndone\n\nif [ \"$(id -u)\" -ne 0 ];then\n\techo \"SKIP: Need root privileges\"\n\texit $ksft_skip\nfi\n\nif [ ! -x \"$(command -v ip)\" ]; then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\n# start clean\ncleanup &> /dev/null\nsetup\nfor t in $TESTS\ndo\n\tcase $t in\n\tfib_rule6_test|fib_rule6)\t\tfib_rule6_test;;\n\tfib_rule4_test|fib_rule4)\t\tfib_rule4_test;;\n\tfib_rule6_connect_test|fib_rule6_connect)\tfib_rule6_connect_test;;\n\tfib_rule4_connect_test|fib_rule4_connect)\tfib_rule4_connect_test;;\n\n\thelp) echo \"Test names: $TESTS\"; exit 0;;\n\n\tesac\ndone\ncleanup\n\nif [ \"$TESTS\" != \"none\" ]; then\n\tprintf \"\\nTests passed: %3d\\n\" ${nsuccess}\n\tprintf \"Tests failed: %3d\\n\"   ${nfail}\nfi\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}