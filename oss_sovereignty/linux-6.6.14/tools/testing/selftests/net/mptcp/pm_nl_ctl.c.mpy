{
  "module_name": "pm_nl_ctl.c",
  "hash_id": "373e9f0beed660d7864d63ac1e384c54356974e62a6c7836b1260ac5a6ae776a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/mptcp/pm_nl_ctl.c",
  "human_readable_source": "\n\n#include <errno.h>\n#include <error.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include <arpa/inet.h>\n#include <net/if.h>\n\n#include <linux/rtnetlink.h>\n#include <linux/genetlink.h>\n\n#include \"linux/mptcp.h\"\n\n#ifndef MPTCP_PM_NAME\n#define MPTCP_PM_NAME\t\t\"mptcp_pm\"\n#endif\n#ifndef MPTCP_PM_EVENTS\n#define MPTCP_PM_EVENTS\t\t\"mptcp_pm_events\"\n#endif\n#ifndef IPPROTO_MPTCP\n#define IPPROTO_MPTCP 262\n#endif\n\nstatic void syntax(char *argv[])\n{\n\tfprintf(stderr, \"%s add|ann|rem|csf|dsf|get|set|del|flush|dump|events|listen|accept [<args>]\\n\", argv[0]);\n\tfprintf(stderr, \"\\tadd [flags signal|subflow|backup|fullmesh] [id <nr>] [dev <name>] <ip>\\n\");\n\tfprintf(stderr, \"\\tann <local-ip> id <local-id> token <token> [port <local-port>] [dev <name>]\\n\");\n\tfprintf(stderr, \"\\trem id <local-id> token <token>\\n\");\n\tfprintf(stderr, \"\\tcsf lip <local-ip> lid <local-id> rip <remote-ip> rport <remote-port> token <token>\\n\");\n\tfprintf(stderr, \"\\tdsf lip <local-ip> lport <local-port> rip <remote-ip> rport <remote-port> token <token>\\n\");\n\tfprintf(stderr, \"\\tdel <id> [<ip>]\\n\");\n\tfprintf(stderr, \"\\tget <id>\\n\");\n\tfprintf(stderr, \"\\tset [<ip>] [id <nr>] flags [no]backup|[no]fullmesh [port <nr>] [token <token>] [rip <ip>] [rport <port>]\\n\");\n\tfprintf(stderr, \"\\tflush\\n\");\n\tfprintf(stderr, \"\\tdump\\n\");\n\tfprintf(stderr, \"\\tlimits [<rcv addr max> <subflow max>]\\n\");\n\tfprintf(stderr, \"\\tevents\\n\");\n\tfprintf(stderr, \"\\tlisten <local-ip> <local-port>\\n\");\n\texit(0);\n}\n\nstatic int init_genl_req(char *data, int family, int cmd, int version)\n{\n\tstruct nlmsghdr *nh = (void *)data;\n\tstruct genlmsghdr *gh;\n\tint off = 0;\n\n\tnh->nlmsg_type = family;\n\tnh->nlmsg_flags = NLM_F_REQUEST;\n\tnh->nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);\n\toff += NLMSG_ALIGN(sizeof(*nh));\n\n\tgh = (void *)(data + off);\n\tgh->cmd = cmd;\n\tgh->version = version;\n\toff += NLMSG_ALIGN(sizeof(*gh));\n\treturn off;\n}\n\nstatic int nl_error(struct nlmsghdr *nh)\n{\n\tstruct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(nh);\n\tint len = nh->nlmsg_len - sizeof(*nh);\n\tuint32_t off;\n\n\tif (len < sizeof(struct nlmsgerr)) {\n\t\terror(1, 0, \"netlink error message truncated %d min %ld\", len,\n\t\t      sizeof(struct nlmsgerr));\n\t\treturn -1;\n\t}\n\n\tif (err->error) {\n\t\t \n\t\tstruct rtattr *attrs = (struct rtattr *)NLMSG_DATA(nh);\n\n\t\tfprintf(stderr, \"netlink error %d (%s)\\n\",\n\t\t\terr->error, strerror(-err->error));\n\n\t\twhile (RTA_OK(attrs, len)) {\n\t\t\tif (attrs->rta_type == NLMSGERR_ATTR_MSG)\n\t\t\t\tfprintf(stderr, \"netlink ext ack msg: %s\\n\",\n\t\t\t\t\t(char *)RTA_DATA(attrs));\n\t\t\tif (attrs->rta_type == NLMSGERR_ATTR_OFFS) {\n\t\t\t\tmemcpy(&off, RTA_DATA(attrs), 4);\n\t\t\t\tfprintf(stderr, \"netlink err off %d\\n\",\n\t\t\t\t\t(int)off);\n\t\t\t}\n\t\t\tattrs = RTA_NEXT(attrs, len);\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int capture_events(int fd, int event_group)\n{\n\tu_int8_t buffer[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t\tNLMSG_ALIGN(sizeof(struct genlmsghdr)) + 1024];\n\tstruct genlmsghdr *ghdr;\n\tstruct rtattr *attrs;\n\tstruct nlmsghdr *nh;\n\tint ret = 0;\n\tint res_len;\n\tint msg_len;\n\tfd_set rfds;\n\n\tif (setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP,\n\t\t       &event_group, sizeof(event_group)) < 0)\n\t\terror(1, errno, \"could not join the \" MPTCP_PM_EVENTS \" mcast group\");\n\n\tdo {\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(fd, &rfds);\n\t\tres_len = NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) + 1024;\n\n\t\tret = select(FD_SETSIZE, &rfds, NULL, NULL, NULL);\n\n\t\tif (ret < 0)\n\t\t\terror(1, ret, \"error in select() on NL socket\");\n\n\t\tres_len = recv(fd, buffer, res_len, 0);\n\t\tif (res_len < 0)\n\t\t\terror(1, res_len, \"error on recv() from NL socket\");\n\n\t\tnh = (struct nlmsghdr *)buffer;\n\n\t\tfor (; NLMSG_OK(nh, res_len); nh = NLMSG_NEXT(nh, res_len)) {\n\t\t\tif (nh->nlmsg_type == NLMSG_ERROR)\n\t\t\t\terror(1, NLMSG_ERROR, \"received invalid NL message\");\n\n\t\t\tghdr = (struct genlmsghdr *)NLMSG_DATA(nh);\n\n\t\t\tif (ghdr->cmd == 0)\n\t\t\t\tcontinue;\n\n\t\t\tfprintf(stderr, \"type:%d\", ghdr->cmd);\n\n\t\t\tmsg_len = nh->nlmsg_len - NLMSG_LENGTH(GENL_HDRLEN);\n\n\t\t\tattrs = (struct rtattr *) ((char *) ghdr + GENL_HDRLEN);\n\t\t\twhile (RTA_OK(attrs, msg_len)) {\n\t\t\t\tif (attrs->rta_type == MPTCP_ATTR_TOKEN)\n\t\t\t\t\tfprintf(stderr, \",token:%u\", *(__u32 *)RTA_DATA(attrs));\n\t\t\t\telse if (attrs->rta_type == MPTCP_ATTR_FAMILY)\n\t\t\t\t\tfprintf(stderr, \",family:%u\", *(__u16 *)RTA_DATA(attrs));\n\t\t\t\telse if (attrs->rta_type == MPTCP_ATTR_LOC_ID)\n\t\t\t\t\tfprintf(stderr, \",loc_id:%u\", *(__u8 *)RTA_DATA(attrs));\n\t\t\t\telse if (attrs->rta_type == MPTCP_ATTR_REM_ID)\n\t\t\t\t\tfprintf(stderr, \",rem_id:%u\", *(__u8 *)RTA_DATA(attrs));\n\t\t\t\telse if (attrs->rta_type == MPTCP_ATTR_SADDR4) {\n\t\t\t\t\tu_int32_t saddr4 = ntohl(*(__u32 *)RTA_DATA(attrs));\n\n\t\t\t\t\tfprintf(stderr, \",saddr4:%u.%u.%u.%u\", saddr4 >> 24,\n\t\t\t\t\t       (saddr4 >> 16) & 0xFF, (saddr4 >> 8) & 0xFF,\n\t\t\t\t\t       (saddr4 & 0xFF));\n\t\t\t\t} else if (attrs->rta_type == MPTCP_ATTR_SADDR6) {\n\t\t\t\t\tchar buf[INET6_ADDRSTRLEN];\n\n\t\t\t\t\tif (inet_ntop(AF_INET6, RTA_DATA(attrs), buf,\n\t\t\t\t\t\t      sizeof(buf)) != NULL)\n\t\t\t\t\t\tfprintf(stderr, \",saddr6:%s\", buf);\n\t\t\t\t} else if (attrs->rta_type == MPTCP_ATTR_DADDR4) {\n\t\t\t\t\tu_int32_t daddr4 = ntohl(*(__u32 *)RTA_DATA(attrs));\n\n\t\t\t\t\tfprintf(stderr, \",daddr4:%u.%u.%u.%u\", daddr4 >> 24,\n\t\t\t\t\t       (daddr4 >> 16) & 0xFF, (daddr4 >> 8) & 0xFF,\n\t\t\t\t\t       (daddr4 & 0xFF));\n\t\t\t\t} else if (attrs->rta_type == MPTCP_ATTR_DADDR6) {\n\t\t\t\t\tchar buf[INET6_ADDRSTRLEN];\n\n\t\t\t\t\tif (inet_ntop(AF_INET6, RTA_DATA(attrs), buf,\n\t\t\t\t\t\t      sizeof(buf)) != NULL)\n\t\t\t\t\t\tfprintf(stderr, \",daddr6:%s\", buf);\n\t\t\t\t} else if (attrs->rta_type == MPTCP_ATTR_SPORT)\n\t\t\t\t\tfprintf(stderr, \",sport:%u\",\n\t\t\t\t\t\tntohs(*(__u16 *)RTA_DATA(attrs)));\n\t\t\t\telse if (attrs->rta_type == MPTCP_ATTR_DPORT)\n\t\t\t\t\tfprintf(stderr, \",dport:%u\",\n\t\t\t\t\t\tntohs(*(__u16 *)RTA_DATA(attrs)));\n\t\t\t\telse if (attrs->rta_type == MPTCP_ATTR_BACKUP)\n\t\t\t\t\tfprintf(stderr, \",backup:%u\", *(__u8 *)RTA_DATA(attrs));\n\t\t\t\telse if (attrs->rta_type == MPTCP_ATTR_ERROR)\n\t\t\t\t\tfprintf(stderr, \",error:%u\", *(__u8 *)RTA_DATA(attrs));\n\t\t\t\telse if (attrs->rta_type == MPTCP_ATTR_SERVER_SIDE)\n\t\t\t\t\tfprintf(stderr, \",server_side:%u\", *(__u8 *)RTA_DATA(attrs));\n\n\t\t\t\tattrs = RTA_NEXT(attrs, msg_len);\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t} while (1);\n\n\treturn 0;\n}\n\n \nstatic int do_nl_req(int fd, struct nlmsghdr *nh, int len, int max)\n{\n\tstruct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };\n\tsocklen_t addr_len;\n\tvoid *data = nh;\n\tint rem, ret;\n\tint err = 0;\n\n\t \n\tif (max == 0) {\n\t\tnh->nlmsg_flags |= NLM_F_ACK;\n\t\tmax = 1024;\n\t}\n\n\tnh->nlmsg_len = len;\n\tret = sendto(fd, data, len, 0, (void *)&nladdr, sizeof(nladdr));\n\tif (ret != len)\n\t\terror(1, errno, \"send netlink: %uB != %uB\\n\", ret, len);\n\n\taddr_len = sizeof(nladdr);\n\trem = ret = recvfrom(fd, data, max, 0, (void *)&nladdr, &addr_len);\n\tif (ret < 0)\n\t\terror(1, errno, \"recv netlink: %uB\\n\", ret);\n\n\t \n\tfor (; NLMSG_OK(nh, rem); nh = NLMSG_NEXT(nh, rem)) {\n\t\tif (nh->nlmsg_type == NLMSG_DONE)\n\t\t\tbreak;\n\n\t\tif (nh->nlmsg_type == NLMSG_ERROR && nl_error(nh))\n\t\t\terr = 1;\n\t}\n\tif (err)\n\t\terror(1, 0, \"bailing out due to netlink error[s]\");\n\treturn ret;\n}\n\nstatic int genl_parse_getfamily(struct nlmsghdr *nlh, int *pm_family,\n\t\t\t\tint *events_mcast_grp)\n{\n\tstruct genlmsghdr *ghdr = NLMSG_DATA(nlh);\n\tint len = nlh->nlmsg_len;\n\tstruct rtattr *attrs;\n\tstruct rtattr *grps;\n\tstruct rtattr *grp;\n\tint got_events_grp;\n\tint got_family;\n\tint grps_len;\n\tint grp_len;\n\n\tif (nlh->nlmsg_type != GENL_ID_CTRL)\n\t\terror(1, errno, \"Not a controller message, len=%d type=0x%x\\n\",\n\t\t      nlh->nlmsg_len, nlh->nlmsg_type);\n\n\tlen -= NLMSG_LENGTH(GENL_HDRLEN);\n\n\tif (len < 0)\n\t\terror(1, errno, \"wrong controller message len %d\\n\", len);\n\n\tif (ghdr->cmd != CTRL_CMD_NEWFAMILY)\n\t\terror(1, errno, \"Unknown controller command %d\\n\", ghdr->cmd);\n\n\tattrs = (struct rtattr *) ((char *) ghdr + GENL_HDRLEN);\n\tgot_family = 0;\n\tgot_events_grp = 0;\n\n\twhile (RTA_OK(attrs, len)) {\n\t\tif (attrs->rta_type == CTRL_ATTR_FAMILY_ID) {\n\t\t\t*pm_family = *(__u16 *)RTA_DATA(attrs);\n\t\t\tgot_family = 1;\n\t\t} else if (attrs->rta_type == CTRL_ATTR_MCAST_GROUPS) {\n\t\t\tgrps = RTA_DATA(attrs);\n\t\t\tgrps_len = RTA_PAYLOAD(attrs);\n\n\t\t\twhile (RTA_OK(grps, grps_len)) {\n\t\t\t\tgrp = RTA_DATA(grps);\n\t\t\t\tgrp_len = RTA_PAYLOAD(grps);\n\t\t\t\tgot_events_grp = 0;\n\n\t\t\t\twhile (RTA_OK(grp, grp_len)) {\n\t\t\t\t\tif (grp->rta_type == CTRL_ATTR_MCAST_GRP_ID)\n\t\t\t\t\t\t*events_mcast_grp = *(__u32 *)RTA_DATA(grp);\n\t\t\t\t\telse if (grp->rta_type == CTRL_ATTR_MCAST_GRP_NAME &&\n\t\t\t\t\t\t !strcmp(RTA_DATA(grp), MPTCP_PM_EVENTS))\n\t\t\t\t\t\tgot_events_grp = 1;\n\n\t\t\t\t\tgrp = RTA_NEXT(grp, grp_len);\n\t\t\t\t}\n\n\t\t\t\tif (got_events_grp)\n\t\t\t\t\tbreak;\n\n\t\t\t\tgrps = RTA_NEXT(grps, grps_len);\n\t\t\t}\n\t\t}\n\n\t\tif (got_family && got_events_grp)\n\t\t\treturn 0;\n\n\t\tattrs = RTA_NEXT(attrs, len);\n\t}\n\n\terror(1, errno, \"can't find CTRL_ATTR_FAMILY_ID attr\");\n\treturn -1;\n}\n\nstatic int resolve_mptcp_pm_netlink(int fd, int *pm_family, int *events_mcast_grp)\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tstruct nlmsghdr *nh;\n\tstruct rtattr *rta;\n\tint namelen;\n\tint off = 0;\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, GENL_ID_CTRL, CTRL_CMD_GETFAMILY, 0);\n\n\trta = (void *)(data + off);\n\tnamelen = strlen(MPTCP_PM_NAME) + 1;\n\trta->rta_type = CTRL_ATTR_FAMILY_NAME;\n\trta->rta_len = RTA_LENGTH(namelen);\n\tmemcpy(RTA_DATA(rta), MPTCP_PM_NAME, namelen);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\tdo_nl_req(fd, nh, off, sizeof(data));\n\treturn genl_parse_getfamily((void *)data, pm_family, events_mcast_grp);\n}\n\nint dsf(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tstruct rtattr *rta, *addr;\n\tu_int16_t family, port;\n\tstruct nlmsghdr *nh;\n\tu_int32_t token;\n\tint addr_start;\n\tint off = 0;\n\tint arg;\n\n\tconst char *params[5];\n\n\tmemset(params, 0, 5 * sizeof(const char *));\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_SUBFLOW_DESTROY,\n\t\t\t    MPTCP_PM_VER);\n\n\tif (argc < 12)\n\t\tsyntax(argv);\n\n\t \n\tfor (arg = 2; arg < argc; arg++) {\n\t\tif (!strcmp(argv[arg], \"lip\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing local IP\");\n\n\t\t\tparams[0] = argv[arg];\n\t\t} else if (!strcmp(argv[arg], \"lport\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing local port\");\n\n\t\t\tparams[1] = argv[arg];\n\t\t} else if (!strcmp(argv[arg], \"rip\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing remote IP\");\n\n\t\t\tparams[2] = argv[arg];\n\t\t} else if (!strcmp(argv[arg], \"rport\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing remote port\");\n\n\t\t\tparams[3] = argv[arg];\n\t\t} else if (!strcmp(argv[arg], \"token\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing token\");\n\n\t\t\tparams[4] = argv[arg];\n\t\t} else\n\t\t\terror(1, 0, \"unknown keyword %s\", argv[arg]);\n\t}\n\n\tfor (arg = 0; arg < 4; arg = arg + 2) {\n\t\t \n\t\taddr_start = off;\n\t\taddr = (void *)(data + off);\n\t\taddr->rta_type = NLA_F_NESTED |\n\t\t\t((arg == 0) ? MPTCP_PM_ATTR_ADDR : MPTCP_PM_ATTR_ADDR_REMOTE);\n\t\taddr->rta_len = RTA_LENGTH(0);\n\t\toff += NLMSG_ALIGN(addr->rta_len);\n\n\t\t \n\t\trta = (void *)(data + off);\n\t\tif (inet_pton(AF_INET, params[arg], RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR4;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t} else if (inet_pton(AF_INET6, params[arg], RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET6;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR6;\n\t\t\trta->rta_len = RTA_LENGTH(16);\n\t\t} else\n\t\t\terror(1, errno, \"can't parse ip %s\", params[arg]);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\t \n\t\trta = (void *)(data + off);\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_FAMILY;\n\t\trta->rta_len = RTA_LENGTH(2);\n\t\tmemcpy(RTA_DATA(rta), &family, 2);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\t \n\t\tport = atoi(params[arg + 1]);\n\t\trta = (void *)(data + off);\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_PORT;\n\t\trta->rta_len = RTA_LENGTH(2);\n\t\tmemcpy(RTA_DATA(rta), &port, 2);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\taddr->rta_len = off - addr_start;\n\t}\n\n\t \n\ttoken = strtoul(params[4], NULL, 10);\n\trta = (void *)(data + off);\n\trta->rta_type = MPTCP_PM_ATTR_TOKEN;\n\trta->rta_len = RTA_LENGTH(4);\n\tmemcpy(RTA_DATA(rta), &token, 4);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\tdo_nl_req(fd, nh, off, 0);\n\n\treturn 0;\n}\n\nint csf(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tconst char *params[5];\n\tstruct nlmsghdr *nh;\n\tstruct rtattr *addr;\n\tstruct rtattr *rta;\n\tu_int16_t family;\n\tu_int32_t token;\n\tu_int16_t port;\n\tint addr_start;\n\tu_int8_t id;\n\tint off = 0;\n\tint arg;\n\n\tmemset(params, 0, 5 * sizeof(const char *));\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_SUBFLOW_CREATE,\n\t\t\t    MPTCP_PM_VER);\n\n\tif (argc < 12)\n\t\tsyntax(argv);\n\n\t \n\tfor (arg = 2; arg < argc; arg++) {\n\t\tif (!strcmp(argv[arg], \"lip\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing local IP\");\n\n\t\t\tparams[0] = argv[arg];\n\t\t} else if (!strcmp(argv[arg], \"lid\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing local id\");\n\n\t\t\tparams[1] = argv[arg];\n\t\t} else if (!strcmp(argv[arg], \"rip\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing remote ip\");\n\n\t\t\tparams[2] = argv[arg];\n\t\t} else if (!strcmp(argv[arg], \"rport\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing remote port\");\n\n\t\t\tparams[3] = argv[arg];\n\t\t} else if (!strcmp(argv[arg], \"token\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing token\");\n\n\t\t\tparams[4] = argv[arg];\n\t\t} else\n\t\t\terror(1, 0, \"unknown param %s\", argv[arg]);\n\t}\n\n\tfor (arg = 0; arg < 4; arg = arg + 2) {\n\t\t \n\t\taddr_start = off;\n\t\taddr = (void *)(data + off);\n\t\taddr->rta_type = NLA_F_NESTED |\n\t\t\t((arg == 0) ? MPTCP_PM_ATTR_ADDR : MPTCP_PM_ATTR_ADDR_REMOTE);\n\t\taddr->rta_len = RTA_LENGTH(0);\n\t\toff += NLMSG_ALIGN(addr->rta_len);\n\n\t\t \n\t\trta = (void *)(data + off);\n\t\tif (inet_pton(AF_INET, params[arg], RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR4;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t} else if (inet_pton(AF_INET6, params[arg], RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET6;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR6;\n\t\t\trta->rta_len = RTA_LENGTH(16);\n\t\t} else\n\t\t\terror(1, errno, \"can't parse ip %s\", params[arg]);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\t \n\t\trta = (void *)(data + off);\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_FAMILY;\n\t\trta->rta_len = RTA_LENGTH(2);\n\t\tmemcpy(RTA_DATA(rta), &family, 2);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\tif (arg == 2) {\n\t\t\t \n\t\t\tport = atoi(params[arg + 1]);\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_PORT;\n\t\t\trta->rta_len = RTA_LENGTH(2);\n\t\t\tmemcpy(RTA_DATA(rta), &port, 2);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t}\n\n\t\tif (arg == 0) {\n\t\t\t \n\t\t\tid = atoi(params[arg + 1]);\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ID;\n\t\t\trta->rta_len = RTA_LENGTH(1);\n\t\t\tmemcpy(RTA_DATA(rta), &id, 1);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t}\n\n\t\taddr->rta_len = off - addr_start;\n\t}\n\n\t \n\ttoken = strtoul(params[4], NULL, 10);\n\trta = (void *)(data + off);\n\trta->rta_type = MPTCP_PM_ATTR_TOKEN;\n\trta->rta_len = RTA_LENGTH(4);\n\tmemcpy(RTA_DATA(rta), &token, 4);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\tdo_nl_req(fd, nh, off, 0);\n\n\treturn 0;\n}\n\nint remove_addr(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tstruct nlmsghdr *nh;\n\tstruct rtattr *rta;\n\tu_int32_t token;\n\tu_int8_t id;\n\tint off = 0;\n\tint arg;\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_REMOVE,\n\t\t\t    MPTCP_PM_VER);\n\n\tif (argc < 6)\n\t\tsyntax(argv);\n\n\tfor (arg = 2; arg < argc; arg++) {\n\t\tif (!strcmp(argv[arg], \"id\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing id value\");\n\n\t\t\tid = atoi(argv[arg]);\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ATTR_LOC_ID;\n\t\t\trta->rta_len = RTA_LENGTH(1);\n\t\t\tmemcpy(RTA_DATA(rta), &id, 1);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else if (!strcmp(argv[arg], \"token\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing token value\");\n\n\t\t\ttoken = strtoul(argv[arg], NULL, 10);\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ATTR_TOKEN;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t\tmemcpy(RTA_DATA(rta), &token, 4);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else\n\t\t\terror(1, 0, \"unknown keyword %s\", argv[arg]);\n\t}\n\n\tdo_nl_req(fd, nh, off, 0);\n\treturn 0;\n}\n\nint announce_addr(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tu_int32_t flags = MPTCP_PM_ADDR_FLAG_SIGNAL;\n\tu_int32_t token = UINT_MAX;\n\tstruct rtattr *rta, *addr;\n\tu_int32_t id = UINT_MAX;\n\tstruct nlmsghdr *nh;\n\tu_int16_t family;\n\tint addr_start;\n\tint off = 0;\n\tint arg;\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_ANNOUNCE,\n\t\t\t    MPTCP_PM_VER);\n\n\tif (argc < 7)\n\t\tsyntax(argv);\n\n\t \n\taddr_start = off;\n\taddr = (void *)(data + off);\n\taddr->rta_type = NLA_F_NESTED | MPTCP_PM_ATTR_ADDR;\n\taddr->rta_len = RTA_LENGTH(0);\n\toff += NLMSG_ALIGN(addr->rta_len);\n\n\t \n\t \n\trta = (void *)(data + off);\n\tif (inet_pton(AF_INET, argv[2], RTA_DATA(rta))) {\n\t\tfamily = AF_INET;\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR4;\n\t\trta->rta_len = RTA_LENGTH(4);\n\t} else if (inet_pton(AF_INET6, argv[2], RTA_DATA(rta))) {\n\t\tfamily = AF_INET6;\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR6;\n\t\trta->rta_len = RTA_LENGTH(16);\n\t} else\n\t\terror(1, errno, \"can't parse ip %s\", argv[2]);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t \n\trta = (void *)(data + off);\n\trta->rta_type = MPTCP_PM_ADDR_ATTR_FAMILY;\n\trta->rta_len = RTA_LENGTH(2);\n\tmemcpy(RTA_DATA(rta), &family, 2);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\tfor (arg = 3; arg < argc; arg++) {\n\t\tif (!strcmp(argv[arg], \"id\")) {\n\t\t\t \n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing id value\");\n\n\t\t\tid = atoi(argv[arg]);\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ID;\n\t\t\trta->rta_len = RTA_LENGTH(1);\n\t\t\tmemcpy(RTA_DATA(rta), &id, 1);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else if (!strcmp(argv[arg], \"dev\")) {\n\t\t\t \n\t\t\tint32_t ifindex;\n\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing dev name\");\n\n\t\t\tifindex = if_nametoindex(argv[arg]);\n\t\t\tif (!ifindex)\n\t\t\t\terror(1, errno, \"unknown device %s\", argv[arg]);\n\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_IF_IDX;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t\tmemcpy(RTA_DATA(rta), &ifindex, 4);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else if (!strcmp(argv[arg], \"port\")) {\n\t\t\t \n\t\t\tu_int16_t port;\n\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing port value\");\n\n\t\t\tport = atoi(argv[arg]);\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_PORT;\n\t\t\trta->rta_len = RTA_LENGTH(2);\n\t\t\tmemcpy(RTA_DATA(rta), &port, 2);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else if (!strcmp(argv[arg], \"token\")) {\n\t\t\t \n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing token value\");\n\n\t\t\ttoken = strtoul(argv[arg], NULL, 10);\n\t\t} else\n\t\t\terror(1, 0, \"unknown keyword %s\", argv[arg]);\n\t}\n\n\t \n\trta = (void *)(data + off);\n\trta->rta_type = MPTCP_PM_ADDR_ATTR_FLAGS;\n\trta->rta_len = RTA_LENGTH(4);\n\tmemcpy(RTA_DATA(rta), &flags, 4);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\taddr->rta_len = off - addr_start;\n\n\tif (id == UINT_MAX || token == UINT_MAX)\n\t\terror(1, 0, \" missing mandatory inputs\");\n\n\t \n\trta = (void *)(data + off);\n\trta->rta_type = MPTCP_PM_ATTR_TOKEN;\n\trta->rta_len = RTA_LENGTH(4);\n\tmemcpy(RTA_DATA(rta), &token, 4);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\tdo_nl_req(fd, nh, off, 0);\n\n\treturn 0;\n}\n\nint add_addr(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tstruct rtattr *rta, *nest;\n\tstruct nlmsghdr *nh;\n\tu_int32_t flags = 0;\n\tu_int16_t family;\n\tint nest_start;\n\tu_int8_t id;\n\tint off = 0;\n\tint arg;\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_ADD_ADDR,\n\t\t\t    MPTCP_PM_VER);\n\n\tif (argc < 3)\n\t\tsyntax(argv);\n\n\tnest_start = off;\n\tnest = (void *)(data + off);\n\tnest->rta_type = NLA_F_NESTED | MPTCP_PM_ATTR_ADDR;\n\tnest->rta_len = RTA_LENGTH(0);\n\toff += NLMSG_ALIGN(nest->rta_len);\n\n\t \n\trta = (void *)(data + off);\n\tif (inet_pton(AF_INET, argv[2], RTA_DATA(rta))) {\n\t\tfamily = AF_INET;\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR4;\n\t\trta->rta_len = RTA_LENGTH(4);\n\t} else if (inet_pton(AF_INET6, argv[2], RTA_DATA(rta))) {\n\t\tfamily = AF_INET6;\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR6;\n\t\trta->rta_len = RTA_LENGTH(16);\n\t} else\n\t\terror(1, errno, \"can't parse ip %s\", argv[2]);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t \n\trta = (void *)(data + off);\n\trta->rta_type = MPTCP_PM_ADDR_ATTR_FAMILY;\n\trta->rta_len = RTA_LENGTH(2);\n\tmemcpy(RTA_DATA(rta), &family, 2);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\tfor (arg = 3; arg < argc; arg++) {\n\t\tif (!strcmp(argv[arg], \"flags\")) {\n\t\t\tchar *tok, *str;\n\n\t\t\t \n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing flags value\");\n\n\t\t\t \n\t\t\tfor (str = argv[arg]; (tok = strtok(str, \",\"));\n\t\t\t     str = NULL) {\n\t\t\t\tif (!strcmp(tok, \"subflow\"))\n\t\t\t\t\tflags |= MPTCP_PM_ADDR_FLAG_SUBFLOW;\n\t\t\t\telse if (!strcmp(tok, \"signal\"))\n\t\t\t\t\tflags |= MPTCP_PM_ADDR_FLAG_SIGNAL;\n\t\t\t\telse if (!strcmp(tok, \"backup\"))\n\t\t\t\t\tflags |= MPTCP_PM_ADDR_FLAG_BACKUP;\n\t\t\t\telse if (!strcmp(tok, \"fullmesh\"))\n\t\t\t\t\tflags |= MPTCP_PM_ADDR_FLAG_FULLMESH;\n\t\t\t\telse\n\t\t\t\t\terror(1, errno,\n\t\t\t\t\t      \"unknown flag %s\", argv[arg]);\n\t\t\t}\n\n\t\t\tif (flags & MPTCP_PM_ADDR_FLAG_SIGNAL &&\n\t\t\t    flags & MPTCP_PM_ADDR_FLAG_FULLMESH) {\n\t\t\t\terror(1, errno, \"error flag fullmesh\");\n\t\t\t}\n\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_FLAGS;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t\tmemcpy(RTA_DATA(rta), &flags, 4);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else if (!strcmp(argv[arg], \"id\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing id value\");\n\n\t\t\tid = atoi(argv[arg]);\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ID;\n\t\t\trta->rta_len = RTA_LENGTH(1);\n\t\t\tmemcpy(RTA_DATA(rta), &id, 1);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else if (!strcmp(argv[arg], \"dev\")) {\n\t\t\tint32_t ifindex;\n\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing dev name\");\n\n\t\t\tifindex = if_nametoindex(argv[arg]);\n\t\t\tif (!ifindex)\n\t\t\t\terror(1, errno, \"unknown device %s\", argv[arg]);\n\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_IF_IDX;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t\tmemcpy(RTA_DATA(rta), &ifindex, 4);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else if (!strcmp(argv[arg], \"port\")) {\n\t\t\tu_int16_t port;\n\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing port value\");\n\t\t\tif (!(flags & MPTCP_PM_ADDR_FLAG_SIGNAL))\n\t\t\t\terror(1, 0, \" flags must be signal when using port\");\n\n\t\t\tport = atoi(argv[arg]);\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_PORT;\n\t\t\trta->rta_len = RTA_LENGTH(2);\n\t\t\tmemcpy(RTA_DATA(rta), &port, 2);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else\n\t\t\terror(1, 0, \"unknown keyword %s\", argv[arg]);\n\t}\n\tnest->rta_len = off - nest_start;\n\n\tdo_nl_req(fd, nh, off, 0);\n\treturn 0;\n}\n\nint del_addr(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tstruct rtattr *rta, *nest;\n\tstruct nlmsghdr *nh;\n\tu_int16_t family;\n\tint nest_start;\n\tu_int8_t id;\n\tint off = 0;\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_DEL_ADDR,\n\t\t\t    MPTCP_PM_VER);\n\n\t \n\tif (argc != 3 && argc != 4)\n\t\tsyntax(argv);\n\n\tid = atoi(argv[2]);\n\t \n\tif (!id && argc != 4)\n\t\tsyntax(argv);\n\n\tnest_start = off;\n\tnest = (void *)(data + off);\n\tnest->rta_type = NLA_F_NESTED | MPTCP_PM_ATTR_ADDR;\n\tnest->rta_len =  RTA_LENGTH(0);\n\toff += NLMSG_ALIGN(nest->rta_len);\n\n\t \n\trta = (void *)(data + off);\n\trta->rta_type = MPTCP_PM_ADDR_ATTR_ID;\n\trta->rta_len = RTA_LENGTH(1);\n\tmemcpy(RTA_DATA(rta), &id, 1);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\tif (!id) {\n\t\t \n\t\trta = (void *)(data + off);\n\t\tif (inet_pton(AF_INET, argv[3], RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR4;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t} else if (inet_pton(AF_INET6, argv[3], RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET6;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR6;\n\t\t\trta->rta_len = RTA_LENGTH(16);\n\t\t} else {\n\t\t\terror(1, errno, \"can't parse ip %s\", argv[3]);\n\t\t}\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\t \n\t\trta = (void *)(data + off);\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_FAMILY;\n\t\trta->rta_len = RTA_LENGTH(2);\n\t\tmemcpy(RTA_DATA(rta), &family, 2);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t}\n\tnest->rta_len = off - nest_start;\n\n\tdo_nl_req(fd, nh, off, 0);\n\treturn 0;\n}\n\nstatic void print_addr(struct rtattr *attrs, int len)\n{\n\tuint16_t family = 0;\n\tuint16_t port = 0;\n\tchar str[1024];\n\tuint32_t flags;\n\tuint8_t id;\n\n\twhile (RTA_OK(attrs, len)) {\n\t\tif (attrs->rta_type == MPTCP_PM_ADDR_ATTR_FAMILY)\n\t\t\tmemcpy(&family, RTA_DATA(attrs), 2);\n\t\tif (attrs->rta_type == MPTCP_PM_ADDR_ATTR_PORT)\n\t\t\tmemcpy(&port, RTA_DATA(attrs), 2);\n\t\tif (attrs->rta_type == MPTCP_PM_ADDR_ATTR_ADDR4) {\n\t\t\tif (family != AF_INET)\n\t\t\t\terror(1, errno, \"wrong IP (v4) for family %d\",\n\t\t\t\t      family);\n\t\t\tinet_ntop(AF_INET, RTA_DATA(attrs), str, sizeof(str));\n\t\t\tprintf(\"%s\", str);\n\t\t\tif (port)\n\t\t\t\tprintf(\" %d\", port);\n\t\t}\n\t\tif (attrs->rta_type == MPTCP_PM_ADDR_ATTR_ADDR6) {\n\t\t\tif (family != AF_INET6)\n\t\t\t\terror(1, errno, \"wrong IP (v6) for family %d\",\n\t\t\t\t      family);\n\t\t\tinet_ntop(AF_INET6, RTA_DATA(attrs), str, sizeof(str));\n\t\t\tprintf(\"%s\", str);\n\t\t\tif (port)\n\t\t\t\tprintf(\" %d\", port);\n\t\t}\n\t\tif (attrs->rta_type == MPTCP_PM_ADDR_ATTR_ID) {\n\t\t\tmemcpy(&id, RTA_DATA(attrs), 1);\n\t\t\tprintf(\"id %d \", id);\n\t\t}\n\t\tif (attrs->rta_type == MPTCP_PM_ADDR_ATTR_FLAGS) {\n\t\t\tmemcpy(&flags, RTA_DATA(attrs), 4);\n\n\t\t\tprintf(\"flags \");\n\t\t\tif (flags & MPTCP_PM_ADDR_FLAG_SIGNAL) {\n\t\t\t\tprintf(\"signal\");\n\t\t\t\tflags &= ~MPTCP_PM_ADDR_FLAG_SIGNAL;\n\t\t\t\tif (flags)\n\t\t\t\t\tprintf(\",\");\n\t\t\t}\n\n\t\t\tif (flags & MPTCP_PM_ADDR_FLAG_SUBFLOW) {\n\t\t\t\tprintf(\"subflow\");\n\t\t\t\tflags &= ~MPTCP_PM_ADDR_FLAG_SUBFLOW;\n\t\t\t\tif (flags)\n\t\t\t\t\tprintf(\",\");\n\t\t\t}\n\n\t\t\tif (flags & MPTCP_PM_ADDR_FLAG_BACKUP) {\n\t\t\t\tprintf(\"backup\");\n\t\t\t\tflags &= ~MPTCP_PM_ADDR_FLAG_BACKUP;\n\t\t\t\tif (flags)\n\t\t\t\t\tprintf(\",\");\n\t\t\t}\n\n\t\t\tif (flags & MPTCP_PM_ADDR_FLAG_FULLMESH) {\n\t\t\t\tprintf(\"fullmesh\");\n\t\t\t\tflags &= ~MPTCP_PM_ADDR_FLAG_FULLMESH;\n\t\t\t\tif (flags)\n\t\t\t\t\tprintf(\",\");\n\t\t\t}\n\n\t\t\tif (flags & MPTCP_PM_ADDR_FLAG_IMPLICIT) {\n\t\t\t\tprintf(\"implicit\");\n\t\t\t\tflags &= ~MPTCP_PM_ADDR_FLAG_IMPLICIT;\n\t\t\t\tif (flags)\n\t\t\t\t\tprintf(\",\");\n\t\t\t}\n\n\t\t\t \n\t\t\tif (flags)\n\t\t\t\tprintf(\"0x%x\", flags);\n\t\t\tprintf(\" \");\n\t\t}\n\t\tif (attrs->rta_type == MPTCP_PM_ADDR_ATTR_IF_IDX) {\n\t\t\tchar name[IF_NAMESIZE], *ret;\n\t\t\tint32_t ifindex;\n\n\t\t\tmemcpy(&ifindex, RTA_DATA(attrs), 4);\n\t\t\tret = if_indextoname(ifindex, name);\n\t\t\tif (ret)\n\t\t\t\tprintf(\"dev %s \", ret);\n\t\t\telse\n\t\t\t\tprintf(\"dev unknown/%d\", ifindex);\n\t\t}\n\n\t\tattrs = RTA_NEXT(attrs, len);\n\t}\n\tprintf(\"\\n\");\n}\n\nstatic void print_addrs(struct nlmsghdr *nh, int pm_family, int total_len)\n{\n\tstruct rtattr *attrs;\n\n\tfor (; NLMSG_OK(nh, total_len); nh = NLMSG_NEXT(nh, total_len)) {\n\t\tint len = nh->nlmsg_len;\n\n\t\tif (nh->nlmsg_type == NLMSG_DONE)\n\t\t\tbreak;\n\t\tif (nh->nlmsg_type == NLMSG_ERROR)\n\t\t\tnl_error(nh);\n\t\tif (nh->nlmsg_type != pm_family)\n\t\t\tcontinue;\n\n\t\tlen -= NLMSG_LENGTH(GENL_HDRLEN);\n\t\tattrs = (struct rtattr *) ((char *) NLMSG_DATA(nh) +\n\t\t\t\t\t   GENL_HDRLEN);\n\t\twhile (RTA_OK(attrs, len)) {\n\t\t\tif (attrs->rta_type ==\n\t\t\t    (MPTCP_PM_ATTR_ADDR | NLA_F_NESTED))\n\t\t\t\tprint_addr((void *)RTA_DATA(attrs),\n\t\t\t\t\t   attrs->rta_len);\n\t\t\tattrs = RTA_NEXT(attrs, len);\n\t\t}\n\t}\n}\n\nint get_addr(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tstruct rtattr *rta, *nest;\n\tstruct nlmsghdr *nh;\n\tint nest_start;\n\tu_int8_t id;\n\tint off = 0;\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_GET_ADDR,\n\t\t\t    MPTCP_PM_VER);\n\n\t \n\tif (argc != 3)\n\t\tsyntax(argv);\n\n\tid = atoi(argv[2]);\n\n\tnest_start = off;\n\tnest = (void *)(data + off);\n\tnest->rta_type = NLA_F_NESTED | MPTCP_PM_ATTR_ADDR;\n\tnest->rta_len =  RTA_LENGTH(0);\n\toff += NLMSG_ALIGN(nest->rta_len);\n\n\t \n\trta = (void *)(data + off);\n\trta->rta_type = MPTCP_PM_ADDR_ATTR_ID;\n\trta->rta_len = RTA_LENGTH(1);\n\tmemcpy(RTA_DATA(rta), &id, 1);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\tnest->rta_len = off - nest_start;\n\n\tprint_addrs(nh, pm_family, do_nl_req(fd, nh, off, sizeof(data)));\n\treturn 0;\n}\n\nint dump_addrs(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tpid_t pid = getpid();\n\tstruct nlmsghdr *nh;\n\tint off = 0;\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_GET_ADDR,\n\t\t\t    MPTCP_PM_VER);\n\tnh->nlmsg_flags |= NLM_F_DUMP;\n\tnh->nlmsg_seq = 1;\n\tnh->nlmsg_pid = pid;\n\tnh->nlmsg_len = off;\n\n\tprint_addrs(nh, pm_family, do_nl_req(fd, nh, off, sizeof(data)));\n\treturn 0;\n}\n\nint flush_addrs(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tstruct nlmsghdr *nh;\n\tint off = 0;\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_FLUSH_ADDRS,\n\t\t\t    MPTCP_PM_VER);\n\n\tdo_nl_req(fd, nh, off, 0);\n\treturn 0;\n}\n\nstatic void print_limits(struct nlmsghdr *nh, int pm_family, int total_len)\n{\n\tstruct rtattr *attrs;\n\tuint32_t max;\n\n\tfor (; NLMSG_OK(nh, total_len); nh = NLMSG_NEXT(nh, total_len)) {\n\t\tint len = nh->nlmsg_len;\n\n\t\tif (nh->nlmsg_type == NLMSG_DONE)\n\t\t\tbreak;\n\t\tif (nh->nlmsg_type == NLMSG_ERROR)\n\t\t\tnl_error(nh);\n\t\tif (nh->nlmsg_type != pm_family)\n\t\t\tcontinue;\n\n\t\tlen -= NLMSG_LENGTH(GENL_HDRLEN);\n\t\tattrs = (struct rtattr *) ((char *) NLMSG_DATA(nh) +\n\t\t\t\t\t   GENL_HDRLEN);\n\t\twhile (RTA_OK(attrs, len)) {\n\t\t\tint type = attrs->rta_type;\n\n\t\t\tif (type != MPTCP_PM_ATTR_RCV_ADD_ADDRS &&\n\t\t\t    type != MPTCP_PM_ATTR_SUBFLOWS)\n\t\t\t\tgoto next;\n\n\t\t\tmemcpy(&max, RTA_DATA(attrs), 4);\n\t\t\tprintf(\"%s %u\\n\", type == MPTCP_PM_ATTR_SUBFLOWS ?\n\t\t\t\t\t  \"subflows\" : \"accept\", max);\n\nnext:\n\t\t\tattrs = RTA_NEXT(attrs, len);\n\t\t}\n\t}\n}\n\nint get_set_limits(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tuint32_t rcv_addr = 0, subflows = 0;\n\tint cmd, len = sizeof(data);\n\tstruct nlmsghdr *nh;\n\tint off = 0;\n\n\t \n\tif (argc == 4) {\n\t\trcv_addr = atoi(argv[2]);\n\t\tsubflows = atoi(argv[3]);\n\t\tcmd = MPTCP_PM_CMD_SET_LIMITS;\n\t} else {\n\t\tcmd = MPTCP_PM_CMD_GET_LIMITS;\n\t}\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, cmd, MPTCP_PM_VER);\n\n\t \n\tif (cmd == MPTCP_PM_CMD_SET_LIMITS) {\n\t\tstruct rtattr *rta = (void *)(data + off);\n\n\t\trta->rta_type = MPTCP_PM_ATTR_RCV_ADD_ADDRS;\n\t\trta->rta_len = RTA_LENGTH(4);\n\t\tmemcpy(RTA_DATA(rta), &rcv_addr, 4);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\trta = (void *)(data + off);\n\t\trta->rta_type = MPTCP_PM_ATTR_SUBFLOWS;\n\t\trta->rta_len = RTA_LENGTH(4);\n\t\tmemcpy(RTA_DATA(rta), &subflows, 4);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\t \n\t\tlen = 0;\n\t}\n\n\tlen = do_nl_req(fd, nh, off, len);\n\tif (cmd == MPTCP_PM_CMD_GET_LIMITS)\n\t\tprint_limits(nh, pm_family, len);\n\treturn 0;\n}\n\nint add_listener(int argc, char *argv[])\n{\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in6 *a6;\n\tstruct sockaddr_in *a4;\n\tu_int16_t family;\n\tint enable = 1;\n\tint sock;\n\tint err;\n\n\tif (argc < 4)\n\t\tsyntax(argv);\n\n\tmemset(&addr, 0, sizeof(struct sockaddr_storage));\n\ta4 = (struct sockaddr_in *)&addr;\n\ta6 = (struct sockaddr_in6 *)&addr;\n\n\tif (inet_pton(AF_INET, argv[2], &a4->sin_addr)) {\n\t\tfamily = AF_INET;\n\t\ta4->sin_family = family;\n\t\ta4->sin_port = htons(atoi(argv[3]));\n\t} else if (inet_pton(AF_INET6, argv[2], &a6->sin6_addr)) {\n\t\tfamily = AF_INET6;\n\t\ta6->sin6_family = family;\n\t\ta6->sin6_port = htons(atoi(argv[3]));\n\t} else\n\t\terror(1, errno, \"can't parse ip %s\", argv[2]);\n\n\tsock = socket(family, SOCK_STREAM, IPPROTO_MPTCP);\n\tif (sock < 0)\n\t\terror(1, errno, \"can't create listener sock\\n\");\n\n\tif (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable))) {\n\t\tclose(sock);\n\t\terror(1, errno, \"can't set SO_REUSEADDR on listener sock\\n\");\n\t}\n\n\terr = bind(sock, (struct sockaddr *)&addr,\n\t\t   ((family == AF_INET) ? sizeof(struct sockaddr_in) :\n\t\t    sizeof(struct sockaddr_in6)));\n\n\tif (err == 0 && listen(sock, 30) == 0)\n\t\tpause();\n\n\tclose(sock);\n\treturn 0;\n}\n\nint set_flags(int fd, int pm_family, int argc, char *argv[])\n{\n\tchar data[NLMSG_ALIGN(sizeof(struct nlmsghdr)) +\n\t\t  NLMSG_ALIGN(sizeof(struct genlmsghdr)) +\n\t\t  1024];\n\tstruct rtattr *rta, *nest;\n\tstruct nlmsghdr *nh;\n\tu_int32_t flags = 0;\n\tu_int32_t token = 0;\n\tu_int16_t rport = 0;\n\tu_int16_t family;\n\tvoid *rip = NULL;\n\tint nest_start;\n\tint use_id = 0;\n\tu_int8_t id;\n\tint off = 0;\n\tint arg = 2;\n\n\tmemset(data, 0, sizeof(data));\n\tnh = (void *)data;\n\toff = init_genl_req(data, pm_family, MPTCP_PM_CMD_SET_FLAGS,\n\t\t\t    MPTCP_PM_VER);\n\n\tif (argc < 3)\n\t\tsyntax(argv);\n\n\tnest_start = off;\n\tnest = (void *)(data + off);\n\tnest->rta_type = NLA_F_NESTED | MPTCP_PM_ATTR_ADDR;\n\tnest->rta_len = RTA_LENGTH(0);\n\toff += NLMSG_ALIGN(nest->rta_len);\n\n\tif (!strcmp(argv[arg], \"id\")) {\n\t\tif (++arg >= argc)\n\t\t\terror(1, 0, \" missing id value\");\n\n\t\tuse_id = 1;\n\t\tid = atoi(argv[arg]);\n\t\trta = (void *)(data + off);\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ID;\n\t\trta->rta_len = RTA_LENGTH(1);\n\t\tmemcpy(RTA_DATA(rta), &id, 1);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t} else {\n\t\t \n\t\trta = (void *)(data + off);\n\t\tif (inet_pton(AF_INET, argv[arg], RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR4;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t} else if (inet_pton(AF_INET6, argv[arg], RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET6;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR6;\n\t\t\trta->rta_len = RTA_LENGTH(16);\n\t\t} else {\n\t\t\terror(1, errno, \"can't parse ip %s\", argv[arg]);\n\t\t}\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\t \n\t\trta = (void *)(data + off);\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_FAMILY;\n\t\trta->rta_len = RTA_LENGTH(2);\n\t\tmemcpy(RTA_DATA(rta), &family, 2);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t}\n\n\tif (++arg >= argc)\n\t\terror(1, 0, \" missing flags keyword\");\n\n\tfor (; arg < argc; arg++) {\n\t\tif (!strcmp(argv[arg], \"token\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing token value\");\n\n\t\t\t \n\t\t\ttoken = strtoul(argv[arg], NULL, 10);\n\t\t} else if (!strcmp(argv[arg], \"flags\")) {\n\t\t\tchar *tok, *str;\n\n\t\t\t \n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing flags value\");\n\n\t\t\tfor (str = argv[arg]; (tok = strtok(str, \",\"));\n\t\t\t     str = NULL) {\n\t\t\t\tif (!strcmp(tok, \"backup\"))\n\t\t\t\t\tflags |= MPTCP_PM_ADDR_FLAG_BACKUP;\n\t\t\t\telse if (!strcmp(tok, \"fullmesh\"))\n\t\t\t\t\tflags |= MPTCP_PM_ADDR_FLAG_FULLMESH;\n\t\t\t\telse if (strcmp(tok, \"nobackup\") &&\n\t\t\t\t\t strcmp(tok, \"nofullmesh\"))\n\t\t\t\t\terror(1, errno,\n\t\t\t\t\t      \"unknown flag %s\", argv[arg]);\n\t\t\t}\n\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_FLAGS;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t\tmemcpy(RTA_DATA(rta), &flags, 4);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else if (!strcmp(argv[arg], \"port\")) {\n\t\t\tu_int16_t port;\n\n\t\t\tif (use_id)\n\t\t\t\terror(1, 0, \" port can't be used with id\");\n\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing port value\");\n\n\t\t\tport = atoi(argv[arg]);\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_PORT;\n\t\t\trta->rta_len = RTA_LENGTH(2);\n\t\t\tmemcpy(RTA_DATA(rta), &port, 2);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t} else if (!strcmp(argv[arg], \"rport\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing remote port\");\n\n\t\t\trport = atoi(argv[arg]);\n\t\t} else if (!strcmp(argv[arg], \"rip\")) {\n\t\t\tif (++arg >= argc)\n\t\t\t\terror(1, 0, \" missing remote ip\");\n\n\t\t\trip = argv[arg];\n\t\t} else {\n\t\t\terror(1, 0, \"unknown keyword %s\", argv[arg]);\n\t\t}\n\t}\n\tnest->rta_len = off - nest_start;\n\n\t \n\tif (token) {\n\t\trta = (void *)(data + off);\n\t\trta->rta_type = MPTCP_PM_ATTR_TOKEN;\n\t\trta->rta_len = RTA_LENGTH(4);\n\t\tmemcpy(RTA_DATA(rta), &token, 4);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t}\n\n\t \n\tif (rip) {\n\t\tnest_start = off;\n\t\tnest = (void *)(data + off);\n\t\tnest->rta_type = NLA_F_NESTED | MPTCP_PM_ATTR_ADDR_REMOTE;\n\t\tnest->rta_len = RTA_LENGTH(0);\n\t\toff += NLMSG_ALIGN(nest->rta_len);\n\n\t\t \n\t\trta = (void *)(data + off);\n\t\tif (inet_pton(AF_INET, rip, RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR4;\n\t\t\trta->rta_len = RTA_LENGTH(4);\n\t\t} else if (inet_pton(AF_INET6, rip, RTA_DATA(rta))) {\n\t\t\tfamily = AF_INET6;\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_ADDR6;\n\t\t\trta->rta_len = RTA_LENGTH(16);\n\t\t} else {\n\t\t\terror(1, errno, \"can't parse ip %s\", (char *)rip);\n\t\t}\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\t \n\t\trta = (void *)(data + off);\n\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_FAMILY;\n\t\trta->rta_len = RTA_LENGTH(2);\n\t\tmemcpy(RTA_DATA(rta), &family, 2);\n\t\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t\tif (rport) {\n\t\t\trta = (void *)(data + off);\n\t\t\trta->rta_type = MPTCP_PM_ADDR_ATTR_PORT;\n\t\t\trta->rta_len = RTA_LENGTH(2);\n\t\t\tmemcpy(RTA_DATA(rta), &rport, 2);\n\t\t\toff += NLMSG_ALIGN(rta->rta_len);\n\t\t}\n\n\t\tnest->rta_len = off - nest_start;\n\t}\n\n\tdo_nl_req(fd, nh, off, 0);\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tint events_mcast_grp;\n\tint pm_family;\n\tint fd;\n\n\tif (argc < 2)\n\t\tsyntax(argv);\n\n\tfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket netlink\");\n\n\tresolve_mptcp_pm_netlink(fd, &pm_family, &events_mcast_grp);\n\n\tif (!strcmp(argv[1], \"add\"))\n\t\treturn add_addr(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"ann\"))\n\t\treturn announce_addr(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"rem\"))\n\t\treturn remove_addr(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"csf\"))\n\t\treturn csf(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"dsf\"))\n\t\treturn dsf(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"del\"))\n\t\treturn del_addr(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"flush\"))\n\t\treturn flush_addrs(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"get\"))\n\t\treturn get_addr(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"dump\"))\n\t\treturn dump_addrs(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"limits\"))\n\t\treturn get_set_limits(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"set\"))\n\t\treturn set_flags(fd, pm_family, argc, argv);\n\telse if (!strcmp(argv[1], \"events\"))\n\t\treturn capture_events(fd, events_mcast_grp);\n\telse if (!strcmp(argv[1], \"listen\"))\n\t\treturn add_listener(argc, argv);\n\n\tfprintf(stderr, \"unknown sub-command: %s\", argv[1]);\n\tsyntax(argv);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}