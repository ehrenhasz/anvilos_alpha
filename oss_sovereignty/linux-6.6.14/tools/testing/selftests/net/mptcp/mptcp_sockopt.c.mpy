{
  "module_name": "mptcp_sockopt.c",
  "hash_id": "0480a8147c33b5dd87262f870475aa61201dc6558b3485c3847907e21ff5ddd6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/mptcp/mptcp_sockopt.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <netdb.h>\n#include <netinet/in.h>\n\n#include <linux/tcp.h>\n\nstatic int pf = AF_INET;\n\n#ifndef IPPROTO_MPTCP\n#define IPPROTO_MPTCP 262\n#endif\n#ifndef SOL_MPTCP\n#define SOL_MPTCP 284\n#endif\n\n#ifndef MPTCP_INFO\nstruct mptcp_info {\n\t__u8\tmptcpi_subflows;\n\t__u8\tmptcpi_add_addr_signal;\n\t__u8\tmptcpi_add_addr_accepted;\n\t__u8\tmptcpi_subflows_max;\n\t__u8\tmptcpi_add_addr_signal_max;\n\t__u8\tmptcpi_add_addr_accepted_max;\n\t__u32\tmptcpi_flags;\n\t__u32\tmptcpi_token;\n\t__u64\tmptcpi_write_seq;\n\t__u64\tmptcpi_snd_una;\n\t__u64\tmptcpi_rcv_nxt;\n\t__u8\tmptcpi_local_addr_used;\n\t__u8\tmptcpi_local_addr_max;\n\t__u8\tmptcpi_csum_enabled;\n\t__u32\tmptcpi_retransmits;\n\t__u64\tmptcpi_bytes_retrans;\n\t__u64\tmptcpi_bytes_sent;\n\t__u64\tmptcpi_bytes_received;\n\t__u64\tmptcpi_bytes_acked;\n};\n\nstruct mptcp_subflow_data {\n\t__u32\t\tsize_subflow_data;\t\t \n\t__u32\t\tnum_subflows;\t\t\t \n\t__u32\t\tsize_kernel;\t\t\t \n\t__u32\t\tsize_user;\t\t\t \n} __attribute__((aligned(8)));\n\nstruct mptcp_subflow_addrs {\n\tunion {\n\t\t__kernel_sa_family_t sa_family;\n\t\tstruct sockaddr sa_local;\n\t\tstruct sockaddr_in sin_local;\n\t\tstruct sockaddr_in6 sin6_local;\n\t\tstruct __kernel_sockaddr_storage ss_local;\n\t};\n\tunion {\n\t\tstruct sockaddr sa_remote;\n\t\tstruct sockaddr_in sin_remote;\n\t\tstruct sockaddr_in6 sin6_remote;\n\t\tstruct __kernel_sockaddr_storage ss_remote;\n\t};\n};\n\n#define MPTCP_INFO\t\t1\n#define MPTCP_TCPINFO\t\t2\n#define MPTCP_SUBFLOW_ADDRS\t3\n#endif\n\n#ifndef MPTCP_FULL_INFO\nstruct mptcp_subflow_info {\n\t__u32\t\t\t\tid;\n\tstruct mptcp_subflow_addrs\taddrs;\n};\n\nstruct mptcp_full_info {\n\t__u32\t\tsize_tcpinfo_kernel;\t \n\t__u32\t\tsize_tcpinfo_user;\n\t__u32\t\tsize_sfinfo_kernel;\t \n\t__u32\t\tsize_sfinfo_user;\n\t__u32\t\tnum_subflows;\t\t \n\t__u32\t\tsize_arrays_user;\t \n\t__aligned_u64\t\tsubflow_info;\n\t__aligned_u64\t\ttcp_info;\n\tstruct mptcp_info\tmptcp_info;\n};\n\n#define MPTCP_FULL_INFO\t\t4\n#endif\n\nstruct so_state {\n\tstruct mptcp_info mi;\n\tstruct mptcp_info last_sample;\n\tstruct tcp_info tcp_info;\n\tstruct mptcp_subflow_addrs addrs;\n\tuint64_t mptcpi_rcv_delta;\n\tuint64_t tcpi_rcv_delta;\n\tbool pkt_stats_avail;\n};\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\nstatic void die_perror(const char *msg)\n{\n\tperror(msg);\n\texit(1);\n}\n\nstatic void die_usage(int r)\n{\n\tfprintf(stderr, \"Usage: mptcp_sockopt [-6]\\n\");\n\texit(r);\n}\n\nstatic void xerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tfputc('\\n', stderr);\n\texit(1);\n}\n\nstatic const char *getxinfo_strerr(int err)\n{\n\tif (err == EAI_SYSTEM)\n\t\treturn strerror(errno);\n\n\treturn gai_strerror(err);\n}\n\nstatic void xgetaddrinfo(const char *node, const char *service,\n\t\t\t const struct addrinfo *hints,\n\t\t\t struct addrinfo **res)\n{\n\tint err = getaddrinfo(node, service, hints, res);\n\n\tif (err) {\n\t\tconst char *errstr = getxinfo_strerr(err);\n\n\t\tfprintf(stderr, \"Fatal: getaddrinfo(%s:%s): %s\\n\",\n\t\t\tnode ? node : \"\", service ? service : \"\", errstr);\n\t\texit(1);\n\t}\n}\n\nstatic int sock_listen_mptcp(const char * const listenaddr,\n\t\t\t     const char * const port)\n{\n\tint sock = -1;\n\tstruct addrinfo hints = {\n\t\t.ai_protocol = IPPROTO_TCP,\n\t\t.ai_socktype = SOCK_STREAM,\n\t\t.ai_flags = AI_PASSIVE | AI_NUMERICHOST\n\t};\n\n\thints.ai_family = pf;\n\n\tstruct addrinfo *a, *addr;\n\tint one = 1;\n\n\txgetaddrinfo(listenaddr, port, &hints, &addr);\n\thints.ai_family = pf;\n\n\tfor (a = addr; a; a = a->ai_next) {\n\t\tsock = socket(a->ai_family, a->ai_socktype, IPPROTO_MPTCP);\n\t\tif (sock < 0)\n\t\t\tcontinue;\n\n\t\tif (-1 == setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one,\n\t\t\t\t     sizeof(one)))\n\t\t\tperror(\"setsockopt\");\n\n\t\tif (bind(sock, a->ai_addr, a->ai_addrlen) == 0)\n\t\t\tbreak;  \n\n\t\tperror(\"bind\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t}\n\n\tfreeaddrinfo(addr);\n\n\tif (sock < 0)\n\t\txerror(\"could not create listen socket\");\n\n\tif (listen(sock, 20))\n\t\tdie_perror(\"listen\");\n\n\treturn sock;\n}\n\nstatic int sock_connect_mptcp(const char * const remoteaddr,\n\t\t\t      const char * const port, int proto)\n{\n\tstruct addrinfo hints = {\n\t\t.ai_protocol = IPPROTO_TCP,\n\t\t.ai_socktype = SOCK_STREAM,\n\t};\n\tstruct addrinfo *a, *addr;\n\tint sock = -1;\n\n\thints.ai_family = pf;\n\n\txgetaddrinfo(remoteaddr, port, &hints, &addr);\n\tfor (a = addr; a; a = a->ai_next) {\n\t\tsock = socket(a->ai_family, a->ai_socktype, proto);\n\t\tif (sock < 0)\n\t\t\tcontinue;\n\n\t\tif (connect(sock, a->ai_addr, a->ai_addrlen) == 0)\n\t\t\tbreak;  \n\n\t\tdie_perror(\"connect\");\n\t}\n\n\tif (sock < 0)\n\t\txerror(\"could not create connect socket\");\n\n\tfreeaddrinfo(addr);\n\treturn sock;\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"h6\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\t\tdie_usage(0);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tpf = AF_INET6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdie_usage(1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void do_getsockopt_bogus_sf_data(int fd, int optname)\n{\n\tstruct mptcp_subflow_data good_data;\n\tstruct bogus_data {\n\t\tstruct mptcp_subflow_data d;\n\t\tchar buf[2];\n\t} bd;\n\tsocklen_t olen, _olen;\n\tint ret;\n\n\tmemset(&bd, 0, sizeof(bd));\n\tmemset(&good_data, 0, sizeof(good_data));\n\n\tolen = sizeof(good_data);\n\tgood_data.size_subflow_data = olen;\n\n\tret = getsockopt(fd, SOL_MPTCP, optname, &bd, &olen);\n\tassert(ret < 0);  \n\tassert(olen == sizeof(good_data));\n\n\tbd.d = good_data;\n\n\tret = getsockopt(fd, SOL_MPTCP, optname, &bd, &olen);\n\tassert(ret == 0);\n\tassert(olen == sizeof(good_data));\n\tassert(bd.d.num_subflows == 1);\n\tassert(bd.d.size_kernel > 0);\n\tassert(bd.d.size_user == 0);\n\n\tbd.d = good_data;\n\t_olen = rand() % olen;\n\tolen = _olen;\n\tret = getsockopt(fd, SOL_MPTCP, optname, &bd, &olen);\n\tassert(ret < 0);\t \n\tassert(olen == _olen);\t \n\n\tbd.d = good_data;\n\tolen = sizeof(good_data);\n\tbd.d.size_kernel = 1;\n\tret = getsockopt(fd, SOL_MPTCP, optname, &bd, &olen);\n\tassert(ret < 0);  \n\n\tbd.d = good_data;\n\tolen = sizeof(good_data);\n\tbd.d.num_subflows = 1;\n\tret = getsockopt(fd, SOL_MPTCP, optname, &bd, &olen);\n\tassert(ret < 0);  \n\n\t \n\tbd.d = good_data;\n\tolen = sizeof(bd);\n\tbd.d.size_subflow_data = sizeof(bd);\n\n\tret = getsockopt(fd, SOL_MPTCP, optname, &bd, &olen);\n\tassert(ret == 0);\n\n\t \n\tassert(olen == sizeof(good_data));\n\n\tassert(bd.d.size_subflow_data == sizeof(bd));\n\n\tbd.d = good_data;\n\tbd.d.size_subflow_data += 1;\n\tbd.d.size_user = 1;\n\tolen = bd.d.size_subflow_data + 1;\n\t_olen = olen;\n\n\tret = getsockopt(fd, SOL_MPTCP, optname, &bd, &_olen);\n\tassert(ret == 0);\n\n\t \n\tassert(olen == _olen);\n\n\tassert(bd.d.size_subflow_data == sizeof(good_data) + 1);\n\tassert(bd.buf[0] == 0);\n}\n\nstatic void do_getsockopt_mptcp_info(struct so_state *s, int fd, size_t w)\n{\n\tstruct mptcp_info i;\n\tsocklen_t olen;\n\tint ret;\n\n\tolen = sizeof(i);\n\tret = getsockopt(fd, SOL_MPTCP, MPTCP_INFO, &i, &olen);\n\n\tif (ret < 0)\n\t\tdie_perror(\"getsockopt MPTCP_INFO\");\n\n\ts->pkt_stats_avail = olen >= sizeof(i);\n\n\ts->last_sample = i;\n\tif (s->mi.mptcpi_write_seq == 0)\n\t\ts->mi = i;\n\n\tassert(s->mi.mptcpi_write_seq + w == i.mptcpi_write_seq);\n\n\ts->mptcpi_rcv_delta = i.mptcpi_rcv_nxt - s->mi.mptcpi_rcv_nxt;\n}\n\nstatic void do_getsockopt_tcp_info(struct so_state *s, int fd, size_t r, size_t w)\n{\n\tstruct my_tcp_info {\n\t\tstruct mptcp_subflow_data d;\n\t\tstruct tcp_info ti[2];\n\t} ti;\n\tint ret, tries = 5;\n\tsocklen_t olen;\n\n\tdo {\n\t\tmemset(&ti, 0, sizeof(ti));\n\n\t\tti.d.size_subflow_data = sizeof(struct mptcp_subflow_data);\n\t\tti.d.size_user = sizeof(struct tcp_info);\n\t\tolen = sizeof(ti);\n\n\t\tret = getsockopt(fd, SOL_MPTCP, MPTCP_TCPINFO, &ti, &olen);\n\t\tif (ret < 0)\n\t\t\txerror(\"getsockopt MPTCP_TCPINFO (tries %d, %m)\");\n\n\t\tassert(olen <= sizeof(ti));\n\t\tassert(ti.d.size_kernel > 0);\n\t\tassert(ti.d.size_user ==\n\t\t       MIN(ti.d.size_kernel, sizeof(struct tcp_info)));\n\t\tassert(ti.d.num_subflows == 1);\n\n\t\tassert(olen > (socklen_t)sizeof(struct mptcp_subflow_data));\n\t\tolen -= sizeof(struct mptcp_subflow_data);\n\t\tassert(olen == ti.d.size_user);\n\n\t\ts->tcp_info = ti.ti[0];\n\n\t\tif (ti.ti[0].tcpi_bytes_sent == w &&\n\t\t    ti.ti[0].tcpi_bytes_received == r)\n\t\t\tgoto done;\n\n\t\tif (r == 0 && ti.ti[0].tcpi_bytes_sent == w &&\n\t\t    ti.ti[0].tcpi_bytes_received) {\n\t\t\ts->tcpi_rcv_delta = ti.ti[0].tcpi_bytes_received;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tsleep(1);\n\t} while (tries-- > 0);\n\n\txerror(\"tcpi_bytes_sent %\" PRIu64 \", want %zu. tcpi_bytes_received %\" PRIu64 \", want %zu\",\n\t\tti.ti[0].tcpi_bytes_sent, w, ti.ti[0].tcpi_bytes_received, r);\n\ndone:\n\tdo_getsockopt_bogus_sf_data(fd, MPTCP_TCPINFO);\n}\n\nstatic void do_getsockopt_subflow_addrs(struct so_state *s, int fd)\n{\n\tstruct sockaddr_storage remote, local;\n\tsocklen_t olen, rlen, llen;\n\tint ret;\n\tstruct my_addrs {\n\t\tstruct mptcp_subflow_data d;\n\t\tstruct mptcp_subflow_addrs addr[2];\n\t} addrs;\n\n\tmemset(&addrs, 0, sizeof(addrs));\n\tmemset(&local, 0, sizeof(local));\n\tmemset(&remote, 0, sizeof(remote));\n\n\taddrs.d.size_subflow_data = sizeof(struct mptcp_subflow_data);\n\taddrs.d.size_user = sizeof(struct mptcp_subflow_addrs);\n\tolen = sizeof(addrs);\n\n\tret = getsockopt(fd, SOL_MPTCP, MPTCP_SUBFLOW_ADDRS, &addrs, &olen);\n\tif (ret < 0)\n\t\tdie_perror(\"getsockopt MPTCP_SUBFLOW_ADDRS\");\n\n\tassert(olen <= sizeof(addrs));\n\tassert(addrs.d.size_kernel > 0);\n\tassert(addrs.d.size_user ==\n\t       MIN(addrs.d.size_kernel, sizeof(struct mptcp_subflow_addrs)));\n\tassert(addrs.d.num_subflows == 1);\n\n\tassert(olen > (socklen_t)sizeof(struct mptcp_subflow_data));\n\tolen -= sizeof(struct mptcp_subflow_data);\n\tassert(olen == addrs.d.size_user);\n\n\tllen = sizeof(local);\n\tret = getsockname(fd, (struct sockaddr *)&local, &llen);\n\tif (ret < 0)\n\t\tdie_perror(\"getsockname\");\n\trlen = sizeof(remote);\n\tret = getpeername(fd, (struct sockaddr *)&remote, &rlen);\n\tif (ret < 0)\n\t\tdie_perror(\"getpeername\");\n\n\tassert(rlen > 0);\n\tassert(rlen == llen);\n\n\tassert(remote.ss_family == local.ss_family);\n\n\tassert(memcmp(&local, &addrs.addr[0].ss_local, sizeof(local)) == 0);\n\tassert(memcmp(&remote, &addrs.addr[0].ss_remote, sizeof(remote)) == 0);\n\ts->addrs = addrs.addr[0];\n\n\tmemset(&addrs, 0, sizeof(addrs));\n\n\taddrs.d.size_subflow_data = sizeof(struct mptcp_subflow_data);\n\taddrs.d.size_user = sizeof(sa_family_t);\n\tolen = sizeof(addrs.d) + sizeof(sa_family_t);\n\n\tret = getsockopt(fd, SOL_MPTCP, MPTCP_SUBFLOW_ADDRS, &addrs, &olen);\n\tassert(ret == 0);\n\tassert(olen == sizeof(addrs.d) + sizeof(sa_family_t));\n\n\tassert(addrs.addr[0].sa_family == pf);\n\tassert(addrs.addr[0].sa_family == local.ss_family);\n\n\tassert(memcmp(&local, &addrs.addr[0].ss_local, sizeof(local)) != 0);\n\tassert(memcmp(&remote, &addrs.addr[0].ss_remote, sizeof(remote)) != 0);\n\n\tdo_getsockopt_bogus_sf_data(fd, MPTCP_SUBFLOW_ADDRS);\n}\n\nstatic void do_getsockopt_mptcp_full_info(struct so_state *s, int fd)\n{\n\tsize_t data_size = sizeof(struct mptcp_full_info);\n\tstruct mptcp_subflow_info sfinfo[2];\n\tstruct tcp_info tcp_info[2];\n\tstruct mptcp_full_info mfi;\n\tsocklen_t olen;\n\tint ret;\n\n\tmemset(&mfi, 0, data_size);\n\tmemset(tcp_info, 0, sizeof(tcp_info));\n\tmemset(sfinfo, 0, sizeof(sfinfo));\n\n\tmfi.size_tcpinfo_user = sizeof(struct tcp_info);\n\tmfi.size_sfinfo_user = sizeof(struct mptcp_subflow_info);\n\tmfi.size_arrays_user = 2;\n\tmfi.subflow_info = (unsigned long)&sfinfo[0];\n\tmfi.tcp_info = (unsigned long)&tcp_info[0];\n\tolen = data_size;\n\n\tret = getsockopt(fd, SOL_MPTCP, MPTCP_FULL_INFO, &mfi, &olen);\n\tif (ret < 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\tperror(\"MPTCP_FULL_INFO test skipped\");\n\t\t\treturn;\n\t\t}\n\t\txerror(\"getsockopt MPTCP_FULL_INFO\");\n\t}\n\n\tassert(olen <= data_size);\n\tassert(mfi.size_tcpinfo_kernel > 0);\n\tassert(mfi.size_tcpinfo_user ==\n\t       MIN(mfi.size_tcpinfo_kernel, sizeof(struct tcp_info)));\n\tassert(mfi.size_sfinfo_kernel > 0);\n\tassert(mfi.size_sfinfo_user ==\n\t       MIN(mfi.size_sfinfo_kernel, sizeof(struct mptcp_subflow_info)));\n\tassert(mfi.num_subflows == 1);\n\n\t \n\tassert(olen > (socklen_t)__builtin_offsetof(struct mptcp_full_info, tcp_info));\n\tassert(mfi.mptcp_info.mptcpi_subflows == 0);\n\tassert(mfi.mptcp_info.mptcpi_bytes_sent == s->last_sample.mptcpi_bytes_sent);\n\tassert(mfi.mptcp_info.mptcpi_bytes_received == s->last_sample.mptcpi_bytes_received);\n\n\tassert(sfinfo[0].id == 1);\n\tassert(tcp_info[0].tcpi_bytes_sent == s->tcp_info.tcpi_bytes_sent);\n\tassert(tcp_info[0].tcpi_bytes_received == s->tcp_info.tcpi_bytes_received);\n\tassert(!memcmp(&sfinfo->addrs, &s->addrs, sizeof(struct mptcp_subflow_addrs)));\n}\n\nstatic void do_getsockopts(struct so_state *s, int fd, size_t r, size_t w)\n{\n\tdo_getsockopt_mptcp_info(s, fd, w);\n\n\tdo_getsockopt_tcp_info(s, fd, r, w);\n\n\tdo_getsockopt_subflow_addrs(s, fd);\n\n\tif (r)\n\t\tdo_getsockopt_mptcp_full_info(s, fd);\n}\n\nstatic void connect_one_server(int fd, int pipefd)\n{\n\tchar buf[4096], buf2[4096];\n\tsize_t len, i, total;\n\tstruct so_state s;\n\tbool eof = false;\n\tssize_t ret;\n\n\tmemset(&s, 0, sizeof(s));\n\n\tlen = rand() % (sizeof(buf) - 1);\n\n\tif (len < 128)\n\t\tlen = 128;\n\n\tfor (i = 0; i < len ; i++) {\n\t\tbuf[i] = rand() % 26;\n\t\tbuf[i] += 'A';\n\t}\n\n\tbuf[i] = '\\n';\n\n\tdo_getsockopts(&s, fd, 0, 0);\n\n\t \n\tret = read(pipefd, buf2, 4);\n\tassert(ret == 4);\n\tclose(pipefd);\n\n\tassert(strncmp(buf2, \"xmit\", 4) == 0);\n\n\tret = write(fd, buf, len);\n\tif (ret < 0)\n\t\tdie_perror(\"write\");\n\n\tif (ret != (ssize_t)len)\n\t\txerror(\"short write\");\n\n\ttotal = 0;\n\tdo {\n\t\tret = read(fd, buf2 + total, sizeof(buf2) - total);\n\t\tif (ret < 0)\n\t\t\tdie_perror(\"read\");\n\t\tif (ret == 0) {\n\t\t\teof = true;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotal += ret;\n\t} while (total < len);\n\n\tif (total != len)\n\t\txerror(\"total %lu, len %lu eof %d\\n\", total, len, eof);\n\n\tif (memcmp(buf, buf2, len))\n\t\txerror(\"data corruption\");\n\n\tif (s.tcpi_rcv_delta)\n\t\tassert(s.tcpi_rcv_delta <= total);\n\n\tdo_getsockopts(&s, fd, ret, ret);\n\n\tif (eof)\n\t\ttotal += 1;  \n\n\tassert(s.mptcpi_rcv_delta == (uint64_t)total);\n\tclose(fd);\n}\n\nstatic void process_one_client(int fd, int pipefd)\n{\n\tssize_t ret, ret2, ret3;\n\tstruct so_state s;\n\tchar buf[4096];\n\n\tmemset(&s, 0, sizeof(s));\n\tdo_getsockopts(&s, fd, 0, 0);\n\n\tret = write(pipefd, \"xmit\", 4);\n\tassert(ret == 4);\n\n\tret = read(fd, buf, sizeof(buf));\n\tif (ret < 0)\n\t\tdie_perror(\"read\");\n\n\tassert(s.mptcpi_rcv_delta <= (uint64_t)ret);\n\n\tif (s.tcpi_rcv_delta)\n\t\tassert(s.tcpi_rcv_delta == (uint64_t)ret);\n\n\tret2 = write(fd, buf, ret);\n\tif (ret2 < 0)\n\t\tdie_perror(\"write\");\n\n\t \n\tret3 = read(fd, buf, 1);\n\tif (ret3 != 0)\n\t\txerror(\"expected EOF, got %lu\", ret3);\n\n\tdo_getsockopts(&s, fd, ret, ret2);\n\tif (s.mptcpi_rcv_delta != (uint64_t)ret + 1)\n\t\txerror(\"mptcpi_rcv_delta %\" PRIu64 \", expect %\" PRIu64, s.mptcpi_rcv_delta, ret + 1, s.mptcpi_rcv_delta - ret);\n\n\t \n\tif (s.pkt_stats_avail) {\n\t\tif (s.last_sample.mptcpi_bytes_sent != ret2)\n\t\t\txerror(\"mptcpi_bytes_sent %\" PRIu64 \", expect %\" PRIu64,\n\t\t\t       s.last_sample.mptcpi_bytes_sent, ret2,\n\t\t\t       s.last_sample.mptcpi_bytes_sent - ret2);\n\t\tif (s.last_sample.mptcpi_bytes_received != ret)\n\t\t\txerror(\"mptcpi_bytes_received %\" PRIu64 \", expect %\" PRIu64,\n\t\t\t       s.last_sample.mptcpi_bytes_received, ret,\n\t\t\t       s.last_sample.mptcpi_bytes_received - ret);\n\t\tif (s.last_sample.mptcpi_bytes_acked != ret)\n\t\t\txerror(\"mptcpi_bytes_acked %\" PRIu64 \", expect %\" PRIu64,\n\t\t\t       s.last_sample.mptcpi_bytes_acked, ret2,\n\t\t\t       s.last_sample.mptcpi_bytes_acked - ret2);\n\t}\n\n\tclose(fd);\n}\n\nstatic int xaccept(int s)\n{\n\tint fd = accept(s, NULL, 0);\n\n\tif (fd < 0)\n\t\tdie_perror(\"accept\");\n\n\treturn fd;\n}\n\nstatic int server(int pipefd)\n{\n\tint fd = -1, r;\n\n\tswitch (pf) {\n\tcase AF_INET:\n\t\tfd = sock_listen_mptcp(\"127.0.0.1\", \"15432\");\n\t\tbreak;\n\tcase AF_INET6:\n\t\tfd = sock_listen_mptcp(\"::1\", \"15432\");\n\t\tbreak;\n\tdefault:\n\t\txerror(\"Unknown pf %d\\n\", pf);\n\t\tbreak;\n\t}\n\n\tr = write(pipefd, \"conn\", 4);\n\tassert(r == 4);\n\n\talarm(15);\n\tr = xaccept(fd);\n\n\tprocess_one_client(r, pipefd);\n\n\treturn 0;\n}\n\nstatic void test_ip_tos_sockopt(int fd)\n{\n\tuint8_t tos_in, tos_out;\n\tsocklen_t s;\n\tint r;\n\n\ttos_in = rand() & 0xfc;\n\tr = setsockopt(fd, SOL_IP, IP_TOS, &tos_in, sizeof(tos_out));\n\tif (r != 0)\n\t\tdie_perror(\"setsockopt IP_TOS\");\n\n\ttos_out = 0;\n\ts = sizeof(tos_out);\n\tr = getsockopt(fd, SOL_IP, IP_TOS, &tos_out, &s);\n\tif (r != 0)\n\t\tdie_perror(\"getsockopt IP_TOS\");\n\n\tif (tos_in != tos_out)\n\t\txerror(\"tos %x != %x socklen_t %d\\n\", tos_in, tos_out, s);\n\n\tif (s != 1)\n\t\txerror(\"tos should be 1 byte\");\n\n\ts = 0;\n\tr = getsockopt(fd, SOL_IP, IP_TOS, &tos_out, &s);\n\tif (r != 0)\n\t\tdie_perror(\"getsockopt IP_TOS 0\");\n\tif (s != 0)\n\t\txerror(\"expect socklen_t == 0\");\n\n\ts = -1;\n\tr = getsockopt(fd, SOL_IP, IP_TOS, &tos_out, &s);\n\tif (r != -1 && errno != EINVAL)\n\t\tdie_perror(\"getsockopt IP_TOS did not indicate -EINVAL\");\n\tif (s != -1)\n\t\txerror(\"expect socklen_t == -1\");\n}\n\nstatic int client(int pipefd)\n{\n\tint fd = -1;\n\n\talarm(15);\n\n\tswitch (pf) {\n\tcase AF_INET:\n\t\tfd = sock_connect_mptcp(\"127.0.0.1\", \"15432\", IPPROTO_MPTCP);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tfd = sock_connect_mptcp(\"::1\", \"15432\", IPPROTO_MPTCP);\n\t\tbreak;\n\tdefault:\n\t\txerror(\"Unknown pf %d\\n\", pf);\n\t}\n\n\ttest_ip_tos_sockopt(fd);\n\n\tconnect_one_server(fd, pipefd);\n\n\treturn 0;\n}\n\nstatic pid_t xfork(void)\n{\n\tpid_t p = fork();\n\n\tif (p < 0)\n\t\tdie_perror(\"fork\");\n\n\treturn p;\n}\n\nstatic int rcheck(int wstatus, const char *what)\n{\n\tif (WIFEXITED(wstatus)) {\n\t\tif (WEXITSTATUS(wstatus) == 0)\n\t\t\treturn 0;\n\t\tfprintf(stderr, \"%s exited, status=%d\\n\", what, WEXITSTATUS(wstatus));\n\t\treturn WEXITSTATUS(wstatus);\n\t} else if (WIFSIGNALED(wstatus)) {\n\t\txerror(\"%s killed by signal %d\\n\", what, WTERMSIG(wstatus));\n\t} else if (WIFSTOPPED(wstatus)) {\n\t\txerror(\"%s stopped by signal %d\\n\", what, WSTOPSIG(wstatus));\n\t}\n\n\treturn 111;\n}\n\nstatic void init_rng(void)\n{\n\tint fd = open(\"/dev/urandom\", O_RDONLY);\n\n\tif (fd >= 0) {\n\t\tunsigned int foo;\n\t\tssize_t ret;\n\n\t\t \n\t\tret = read(fd, &foo, sizeof(foo));\n\t\tassert(ret == sizeof(foo));\n\n\t\tclose(fd);\n\t\tsrand(foo);\n\t} else {\n\t\tsrand(time(NULL));\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint e1, e2, wstatus;\n\tpid_t s, c, ret;\n\tint pipefds[2];\n\n\tparse_opts(argc, argv);\n\n\tinit_rng();\n\n\te1 = pipe(pipefds);\n\tif (e1 < 0)\n\t\tdie_perror(\"pipe\");\n\n\ts = xfork();\n\tif (s == 0)\n\t\treturn server(pipefds[1]);\n\n\tclose(pipefds[1]);\n\n\t \n\te1 = read(pipefds[0], &e1, 4);\n\tassert(e1 == 4);\n\n\tc = xfork();\n\tif (c == 0)\n\t\treturn client(pipefds[0]);\n\n\tclose(pipefds[0]);\n\n\tret = waitpid(s, &wstatus, 0);\n\tif (ret == -1)\n\t\tdie_perror(\"waitpid\");\n\te1 = rcheck(wstatus, \"server\");\n\tret = waitpid(c, &wstatus, 0);\n\tif (ret == -1)\n\t\tdie_perror(\"waitpid\");\n\te2 = rcheck(wstatus, \"client\");\n\n\treturn e1 ? e1 : e2;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}