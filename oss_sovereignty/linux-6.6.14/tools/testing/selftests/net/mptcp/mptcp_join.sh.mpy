{
  "module_name": "mptcp_join.sh",
  "hash_id": "fc4fac08ad15efa497fd70f108999b3a74b0bc1316327469de05e881ab10e18c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/mptcp/mptcp_join.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# Double quotes to prevent globbing and word splitting is recommended in new\n# code but we accept it, especially because there were too many before having\n# address all other issues detected by shellcheck.\n#shellcheck disable=SC2086\n\n# ShellCheck incorrectly believes that most of the code here is unreachable\n# because it's invoked by variable name, see how the \"tests\" array is used\n#shellcheck disable=SC2317\n\n. \"$(dirname \"${0}\")/mptcp_lib.sh\"\n\nret=0\nsin=\"\"\nsinfail=\"\"\nsout=\"\"\ncin=\"\"\ncinfail=\"\"\ncinsent=\"\"\ntmpfile=\"\"\ncout=\"\"\ncapout=\"\"\nns1=\"\"\nns2=\"\"\nksft_skip=4\niptables=\"iptables\"\nip6tables=\"ip6tables\"\ntimeout_poll=30\ntimeout_test=$((timeout_poll * 2 + 1))\ncapture=0\nchecksum=0\nip_mptcp=0\ncheck_invert=0\nvalidate_checksum=0\ninit=0\nevts_ns1=\"\"\nevts_ns2=\"\"\nevts_ns1_pid=0\nevts_ns2_pid=0\nlast_test_failed=0\nlast_test_skipped=0\nlast_test_ignored=1\n\ndeclare -A all_tests\ndeclare -a only_tests_ids\ndeclare -a only_tests_names\ndeclare -A failed_tests\nTEST_COUNT=0\nTEST_NAME=\"\"\nnr_blank=6\n\n# These var are used only in some tests, make sure they are not already set\nunset FAILING_LINKS\nunset test_linkfail\nunset addr_nr_ns1\nunset addr_nr_ns2\nunset sflags\nunset fastclose\nunset fullmesh\nunset speed\n\n# generated using \"nfbpf_compile '(ip && (ip[54] & 0xf0) == 0x30) ||\n#\t\t\t\t  (ip6 && (ip6[74] & 0xf0) == 0x30)'\"\nCBPF_MPTCP_SUBOPTION_ADD_ADDR=\"14,\n\t\t\t       48 0 0 0,\n\t\t\t       84 0 0 240,\n\t\t\t       21 0 3 64,\n\t\t\t       48 0 0 54,\n\t\t\t       84 0 0 240,\n\t\t\t       21 6 7 48,\n\t\t\t       48 0 0 0,\n\t\t\t       84 0 0 240,\n\t\t\t       21 0 4 96,\n\t\t\t       48 0 0 74,\n\t\t\t       84 0 0 240,\n\t\t\t       21 0 1 48,\n\t\t\t       6 0 0 65535,\n\t\t\t       6 0 0 0\"\n\ninit_partial()\n{\n\tcapout=$(mktemp)\n\n\tlocal sec rndh\n\tsec=$(date +%s)\n\trndh=$(printf %x $sec)-$(mktemp -u XXXXXX)\n\n\tns1=\"ns1-$rndh\"\n\tns2=\"ns2-$rndh\"\n\n\tlocal netns\n\tfor netns in \"$ns1\" \"$ns2\"; do\n\t\tip netns add $netns || exit $ksft_skip\n\t\tip -net $netns link set lo up\n\t\tip netns exec $netns sysctl -q net.mptcp.enabled=1\n\t\tip netns exec $netns sysctl -q net.mptcp.pm_type=0 2>/dev/null || true\n\t\tip netns exec $netns sysctl -q net.ipv4.conf.all.rp_filter=0\n\t\tip netns exec $netns sysctl -q net.ipv4.conf.default.rp_filter=0\n\t\tif [ $checksum -eq 1 ]; then\n\t\t\tip netns exec $netns sysctl -q net.mptcp.checksum_enabled=1\n\t\tfi\n\tdone\n\n\tcheck_invert=0\n\tvalidate_checksum=$checksum\n\n\t#  ns1         ns2\n\t# ns1eth1    ns2eth1\n\t# ns1eth2    ns2eth2\n\t# ns1eth3    ns2eth3\n\t# ns1eth4    ns2eth4\n\n\tlocal i\n\tfor i in $(seq 1 4); do\n\t\tip link add ns1eth$i netns \"$ns1\" type veth peer name ns2eth$i netns \"$ns2\"\n\t\tip -net \"$ns1\" addr add 10.0.$i.1/24 dev ns1eth$i\n\t\tip -net \"$ns1\" addr add dead:beef:$i::1/64 dev ns1eth$i nodad\n\t\tip -net \"$ns1\" link set ns1eth$i up\n\n\t\tip -net \"$ns2\" addr add 10.0.$i.2/24 dev ns2eth$i\n\t\tip -net \"$ns2\" addr add dead:beef:$i::2/64 dev ns2eth$i nodad\n\t\tip -net \"$ns2\" link set ns2eth$i up\n\n\t\t# let $ns2 reach any $ns1 address from any interface\n\t\tip -net \"$ns2\" route add default via 10.0.$i.1 dev ns2eth$i metric 10$i\n\t\tip -net \"$ns2\" route add default via dead:beef:$i::1 dev ns2eth$i metric 10$i\n\tdone\n}\n\ninit_shapers()\n{\n\tlocal i\n\tfor i in $(seq 1 4); do\n\t\ttc -n $ns1 qdisc add dev ns1eth$i root netem rate 20mbit delay 1\n\t\ttc -n $ns2 qdisc add dev ns2eth$i root netem rate 20mbit delay 1\n\tdone\n}\n\ncleanup_partial()\n{\n\trm -f \"$capout\"\n\n\tlocal netns\n\tfor netns in \"$ns1\" \"$ns2\"; do\n\t\tip netns del $netns\n\t\trm -f /tmp/$netns.{nstat,out}\n\tdone\n}\n\ncheck_tools()\n{\n\tmptcp_lib_check_mptcp\n\tmptcp_lib_check_kallsyms\n\n\tif ! ip -Version &> /dev/null; then\n\t\techo \"SKIP: Could not run test without ip tool\"\n\t\texit $ksft_skip\n\tfi\n\n\t# Use the legacy version if available to support old kernel versions\n\tif iptables-legacy -V &> /dev/null; then\n\t\tiptables=\"iptables-legacy\"\n\t\tip6tables=\"ip6tables-legacy\"\n\telif ! iptables -V &> /dev/null; then\n\t\techo \"SKIP: Could not run all tests without iptables tool\"\n\t\texit $ksft_skip\n\telif ! ip6tables -V &> /dev/null; then\n\t\techo \"SKIP: Could not run all tests without ip6tables tool\"\n\t\texit $ksft_skip\n\tfi\n}\n\ninit() {\n\tinit=1\n\n\tcheck_tools\n\n\tsin=$(mktemp)\n\tsout=$(mktemp)\n\tcin=$(mktemp)\n\tcinsent=$(mktemp)\n\tcout=$(mktemp)\n\tevts_ns1=$(mktemp)\n\tevts_ns2=$(mktemp)\n\n\ttrap cleanup EXIT\n\n\tmake_file \"$cin\" \"client\" 1 >/dev/null\n\tmake_file \"$sin\" \"server\" 1 >/dev/null\n}\n\ncleanup()\n{\n\trm -f \"$cin\" \"$cout\" \"$sinfail\"\n\trm -f \"$sin\" \"$sout\" \"$cinsent\" \"$cinfail\"\n\trm -f \"$tmpfile\"\n\trm -rf $evts_ns1 $evts_ns2\n\tcleanup_partial\n}\n\nprint_title()\n{\n\tprintf \"%03u %s\\n\" \"${TEST_COUNT}\" \"${TEST_NAME}\"\n}\n\nprint_check()\n{\n\tprintf \"%-${nr_blank}s%-36s\" \" \" \"${*}\"\n}\n\nprint_info()\n{\n\t# It can be empty, no need to print anything then\n\t[ -z \"${1}\" ] && return\n\n\tmptcp_lib_print_info \"      Info: ${*}\"\n}\n\nprint_ok()\n{\n\tmptcp_lib_print_ok \"[ ok ]${1:+ ${*}}\"\n}\n\nprint_fail()\n{\n\tmptcp_lib_print_err \"[fail]${1:+ ${*}}\"\n}\n\nprint_skip()\n{\n\tmptcp_lib_print_warn \"[skip]${1:+ ${*}}\"\n}\n\n# [ $1: fail msg ]\nmark_as_skipped()\n{\n\tlocal msg=\"${1:-\"Feature not supported\"}\"\n\n\tmptcp_lib_fail_if_expected_feature \"${msg}\"\n\n\tprint_check \"${msg}\"\n\tprint_skip\n\n\tlast_test_skipped=1\n}\n\n# $@: condition\ncontinue_if()\n{\n\tif ! \"${@}\"; then\n\t\tmark_as_skipped\n\t\treturn 1\n\tfi\n}\n\nskip_test()\n{\n\tif [ \"${#only_tests_ids[@]}\" -eq 0 ] && [ \"${#only_tests_names[@]}\" -eq 0 ]; then\n\t\treturn 1\n\tfi\n\n\tlocal i\n\tfor i in \"${only_tests_ids[@]}\"; do\n\t\tif [ \"${TEST_COUNT}\" -eq \"${i}\" ]; then\n\t\t\treturn 1\n\t\tfi\n\tdone\n\tfor i in \"${only_tests_names[@]}\"; do\n\t\tif [ \"${TEST_NAME}\" = \"${i}\" ]; then\n\t\t\treturn 1\n\t\tfi\n\tdone\n\n\treturn 0\n}\n\nappend_prev_results()\n{\n\tif [ ${last_test_failed} -eq 1 ]; then\n\t\tmptcp_lib_result_fail \"${TEST_NAME}\"\n\telif [ ${last_test_skipped} -eq 1 ]; then\n\t\tmptcp_lib_result_skip \"${TEST_NAME}\"\n\telif [ ${last_test_ignored} -ne 1 ]; then\n\t\tmptcp_lib_result_pass \"${TEST_NAME}\"\n\tfi\n\n\tlast_test_failed=0\n\tlast_test_skipped=0\n\tlast_test_ignored=0\n}\n\n# $1: test name\nreset()\n{\n\tappend_prev_results\n\n\tTEST_NAME=\"${1}\"\n\n\tTEST_COUNT=$((TEST_COUNT+1))\n\n\tif skip_test; then\n\t\tlast_test_ignored=1\n\t\treturn 1\n\tfi\n\n\tprint_title\n\n\tif [ \"${init}\" != \"1\" ]; then\n\t\tinit\n\telse\n\t\tcleanup_partial\n\tfi\n\n\tinit_partial\n\n\treturn 0\n}\n\n# $1: test name ; $2: counter to check\nreset_check_counter()\n{\n\treset \"${1}\" || return 1\n\n\tlocal counter=\"${2}\"\n\n\tif ! nstat -asz \"${counter}\" | grep -wq \"${counter}\"; then\n\t\tmark_as_skipped \"counter '${counter}' is not available\"\n\t\treturn 1\n\tfi\n}\n\n# $1: test name\nreset_with_cookies()\n{\n\treset \"${1}\" || return 1\n\n\tlocal netns\n\tfor netns in \"$ns1\" \"$ns2\"; do\n\t\tip netns exec $netns sysctl -q net.ipv4.tcp_syncookies=2\n\tdone\n}\n\n# $1: test name\nreset_with_add_addr_timeout()\n{\n\tlocal ip=\"${2:-4}\"\n\tlocal tables\n\n\treset \"${1}\" || return 1\n\n\ttables=\"${iptables}\"\n\tif [ $ip -eq 6 ]; then\n\t\ttables=\"${ip6tables}\"\n\tfi\n\n\tip netns exec $ns1 sysctl -q net.mptcp.add_addr_timeout=1\n\n\tif ! ip netns exec $ns2 $tables -A OUTPUT -p tcp \\\n\t\t\t-m tcp --tcp-option 30 \\\n\t\t\t-m bpf --bytecode \\\n\t\t\t\"$CBPF_MPTCP_SUBOPTION_ADD_ADDR\" \\\n\t\t\t-j DROP; then\n\t\tmark_as_skipped \"unable to set the 'add addr' rule\"\n\t\treturn 1\n\tfi\n}\n\n# $1: test name\nreset_with_checksum()\n{\n\tlocal ns1_enable=$1\n\tlocal ns2_enable=$2\n\n\treset \"checksum test ${1} ${2}\" || return 1\n\n\tip netns exec $ns1 sysctl -q net.mptcp.checksum_enabled=$ns1_enable\n\tip netns exec $ns2 sysctl -q net.mptcp.checksum_enabled=$ns2_enable\n\n\tvalidate_checksum=1\n}\n\nreset_with_allow_join_id0()\n{\n\tlocal ns1_enable=$2\n\tlocal ns2_enable=$3\n\n\treset \"${1}\" || return 1\n\n\tip netns exec $ns1 sysctl -q net.mptcp.allow_join_initial_addr_port=$ns1_enable\n\tip netns exec $ns2 sysctl -q net.mptcp.allow_join_initial_addr_port=$ns2_enable\n}\n\n# Modify TCP payload without corrupting the TCP packet\n#\n# This rule inverts a 8-bit word at byte offset 148 for the 2nd TCP ACK packets\n# carrying enough data.\n# Once it is done, the TCP Checksum field is updated so the packet is still\n# considered as valid at the TCP level.\n# Because the MPTCP checksum, covering the TCP options and data, has not been\n# updated, the modification will be detected and an MP_FAIL will be emitted:\n# what we want to validate here without corrupting \"random\" MPTCP options.\n#\n# To avoid having tc producing this pr_info() message for each TCP ACK packets\n# not carrying enough data:\n#\n#     tc action pedit offset 162 out of bounds\n#\n# Netfilter is used to mark packets with enough data.\nsetup_fail_rules()\n{\n\tcheck_invert=1\n\tvalidate_checksum=1\n\tlocal i=\"$1\"\n\tlocal ip=\"${2:-4}\"\n\tlocal tables\n\n\ttables=\"${iptables}\"\n\tif [ $ip -eq 6 ]; then\n\t\ttables=\"${ip6tables}\"\n\tfi\n\n\tip netns exec $ns2 $tables \\\n\t\t-t mangle \\\n\t\t-A OUTPUT \\\n\t\t-o ns2eth$i \\\n\t\t-p tcp \\\n\t\t-m length --length 150:9999 \\\n\t\t-m statistic --mode nth --packet 1 --every 99999 \\\n\t\t-j MARK --set-mark 42 || return ${ksft_skip}\n\n\ttc -n $ns2 qdisc add dev ns2eth$i clsact || return ${ksft_skip}\n\ttc -n $ns2 filter add dev ns2eth$i egress \\\n\t\tprotocol ip prio 1000 \\\n\t\thandle 42 fw \\\n\t\taction pedit munge offset 148 u8 invert \\\n\t\tpipe csum tcp \\\n\t\tindex 100 || return ${ksft_skip}\n}\n\nreset_with_fail()\n{\n\treset_check_counter \"${1}\" \"MPTcpExtInfiniteMapTx\" || return 1\n\tshift\n\n\tip netns exec $ns1 sysctl -q net.mptcp.checksum_enabled=1\n\tip netns exec $ns2 sysctl -q net.mptcp.checksum_enabled=1\n\n\tlocal rc=0\n\tsetup_fail_rules \"${@}\" || rc=$?\n\n\tif [ ${rc} -eq ${ksft_skip} ]; then\n\t\tmark_as_skipped \"unable to set the 'fail' rules\"\n\t\treturn 1\n\tfi\n}\n\nreset_with_events()\n{\n\treset \"${1}\" || return 1\n\n\t:> \"$evts_ns1\"\n\t:> \"$evts_ns2\"\n\tip netns exec $ns1 ./pm_nl_ctl events >> \"$evts_ns1\" 2>&1 &\n\tevts_ns1_pid=$!\n\tip netns exec $ns2 ./pm_nl_ctl events >> \"$evts_ns2\" 2>&1 &\n\tevts_ns2_pid=$!\n}\n\nreset_with_tcp_filter()\n{\n\treset \"${1}\" || return 1\n\tshift\n\n\tlocal ns=\"${!1}\"\n\tlocal src=\"${2}\"\n\tlocal target=\"${3}\"\n\n\tif ! ip netns exec \"${ns}\" ${iptables} \\\n\t\t\t-A INPUT \\\n\t\t\t-s \"${src}\" \\\n\t\t\t-p tcp \\\n\t\t\t-j \"${target}\"; then\n\t\tmark_as_skipped \"unable to set the filter rules\"\n\t\treturn 1\n\tfi\n}\n\n# $1: err msg\nfail_test()\n{\n\tret=1\n\n\tprint_fail \"${@}\"\n\n\t# just in case a test is marked twice as failed\n\tif [ ${last_test_failed} -eq 0 ]; then\n\t\tfailed_tests[${TEST_COUNT}]=\"${TEST_NAME}\"\n\t\tdump_stats\n\t\tlast_test_failed=1\n\tfi\n}\n\nget_failed_tests_ids()\n{\n\t# sorted\n\tlocal i\n\tfor i in \"${!failed_tests[@]}\"; do\n\t\techo \"${i}\"\n\tdone | sort -n\n}\n\nprint_file_err()\n{\n\tls -l \"$1\" 1>&2\n\techo -n \"Trailing bytes are: \"\n\ttail -c 27 \"$1\"\n}\n\ncheck_transfer()\n{\n\tlocal in=$1\n\tlocal out=$2\n\tlocal what=$3\n\tlocal bytes=$4\n\tlocal i a b\n\n\tlocal line\n\tif [ -n \"$bytes\" ]; then\n\t\tlocal out_size\n\t\t# when truncating we must check the size explicitly\n\t\tout_size=$(wc -c $out | awk '{print $1}')\n\t\tif [ $out_size -ne $bytes ]; then\n\t\t\tfail_test \"$what output file has wrong size ($out_size, $bytes)\"\n\t\t\treturn 1\n\t\tfi\n\n\t\t# note: BusyBox's \"cmp\" command doesn't support --bytes\n\t\ttmpfile=$(mktemp)\n\t\thead --bytes=\"$bytes\" \"$in\" > \"$tmpfile\"\n\t\tmv \"$tmpfile\" \"$in\"\n\t\thead --bytes=\"$bytes\" \"$out\" > \"$tmpfile\"\n\t\tmv \"$tmpfile\" \"$out\"\n\t\ttmpfile=\"\"\n\tfi\n\tcmp -l \"$in\" \"$out\" | while read -r i a b; do\n\t\tlocal sum=$((0${a} + 0${b}))\n\t\tif [ $check_invert -eq 0 ] || [ $sum -ne $((0xff)) ]; then\n\t\t\tfail_test \"$what does not match (in, out):\"\n\t\t\tprint_file_err \"$in\"\n\t\t\tprint_file_err \"$out\"\n\n\t\t\treturn 1\n\t\telse\n\t\t\tprint_info \"$what has inverted byte at ${i}\"\n\t\tfi\n\tdone\n\n\treturn 0\n}\n\ndo_ping()\n{\n\tlocal listener_ns=\"$1\"\n\tlocal connector_ns=\"$2\"\n\tlocal connect_addr=\"$3\"\n\n\tif ! ip netns exec ${connector_ns} ping -q -c 1 $connect_addr >/dev/null; then\n\t\tfail_test \"$listener_ns -> $connect_addr connectivity\"\n\tfi\n}\n\nlink_failure()\n{\n\tlocal ns=\"$1\"\n\n\tif [ -z \"$FAILING_LINKS\" ]; then\n\t\tl=$((RANDOM%4))\n\t\tFAILING_LINKS=$((l+1))\n\tfi\n\n\tlocal l\n\tfor l in $FAILING_LINKS; do\n\t\tlocal veth=\"ns1eth$l\"\n\t\tip -net \"$ns\" link set \"$veth\" down\n\tdone\n}\n\n# $1: IP address\nis_v6()\n{\n\t[ -z \"${1##*:*}\" ]\n}\n\n# $1: ns, $2: port\nwait_local_port_listen()\n{\n\tlocal listener_ns=\"${1}\"\n\tlocal port=\"${2}\"\n\n\tlocal port_hex\n\tport_hex=\"$(printf \"%04X\" \"${port}\")\"\n\n\tlocal i\n\tfor i in $(seq 10); do\n\t\tip netns exec \"${listener_ns}\" cat /proc/net/tcp* | \\\n\t\t\tawk \"BEGIN {rc=1} {if (\\$2 ~ /:${port_hex}\\$/ && \\$4 ~ /0A/) {rc=0; exit}} END {exit rc}\" &&\n\t\t\tbreak\n\t\tsleep 0.1\n\tdone\n}\n\n# $1: ns ; $2: counter\nget_counter()\n{\n\tlocal ns=\"${1}\"\n\tlocal counter=\"${2}\"\n\tlocal count\n\n\tcount=$(ip netns exec ${ns} nstat -asz \"${counter}\" | awk 'NR==1 {next} {print $2}')\n\tif [ -z \"${count}\" ]; then\n\t\tmptcp_lib_fail_if_expected_feature \"${counter} counter\"\n\t\treturn 1\n\tfi\n\n\techo \"${count}\"\n}\n\nrm_addr_count()\n{\n\tget_counter \"${1}\" \"MPTcpExtRmAddr\"\n}\n\n# $1: ns, $2: old rm_addr counter in $ns\nwait_rm_addr()\n{\n\tlocal ns=\"${1}\"\n\tlocal old_cnt=\"${2}\"\n\tlocal cnt\n\n\tlocal i\n\tfor i in $(seq 10); do\n\t\tcnt=$(rm_addr_count ${ns})\n\t\t[ \"$cnt\" = \"${old_cnt}\" ] || break\n\t\tsleep 0.1\n\tdone\n}\n\nrm_sf_count()\n{\n\tget_counter \"${1}\" \"MPTcpExtRmSubflow\"\n}\n\n# $1: ns, $2: old rm_sf counter in $ns\nwait_rm_sf()\n{\n\tlocal ns=\"${1}\"\n\tlocal old_cnt=\"${2}\"\n\tlocal cnt\n\n\tlocal i\n\tfor i in $(seq 10); do\n\t\tcnt=$(rm_sf_count ${ns})\n\t\t[ \"$cnt\" = \"${old_cnt}\" ] || break\n\t\tsleep 0.1\n\tdone\n}\n\nwait_mpj()\n{\n\tlocal ns=\"${1}\"\n\tlocal cnt old_cnt\n\n\told_cnt=$(get_counter ${ns} \"MPTcpExtMPJoinAckRx\")\n\n\tlocal i\n\tfor i in $(seq 10); do\n\t\tcnt=$(get_counter ${ns} \"MPTcpExtMPJoinAckRx\")\n\t\t[ \"$cnt\" = \"${old_cnt}\" ] || break\n\t\tsleep 0.1\n\tdone\n}\n\nkill_wait()\n{\n\tkill $1 > /dev/null 2>&1\n\twait $1 2>/dev/null\n}\n\nkill_events_pids()\n{\n\tkill_wait $evts_ns1_pid\n\tkill_wait $evts_ns2_pid\n}\n\nkill_tests_wait()\n{\n\t#shellcheck disable=SC2046\n\tkill -SIGUSR1 $(ip netns pids $ns2) $(ip netns pids $ns1)\n\twait\n}\n\npm_nl_set_limits()\n{\n\tlocal ns=$1\n\tlocal addrs=$2\n\tlocal subflows=$3\n\n\tif [ $ip_mptcp -eq 1 ]; then\n\t\tip -n $ns mptcp limits set add_addr_accepted $addrs subflows $subflows\n\telse\n\t\tip netns exec $ns ./pm_nl_ctl limits $addrs $subflows\n\tfi\n}\n\npm_nl_add_endpoint()\n{\n\tlocal ns=$1\n\tlocal addr=$2\n\tlocal flags _flags\n\tlocal port _port\n\tlocal dev _dev\n\tlocal id _id\n\tlocal nr=2\n\n\tlocal p\n\tfor p in \"${@}\"\n\tdo\n\t\tif [ $p = \"flags\" ]; then\n\t\t\teval _flags=\\$\"$nr\"\n\t\t\t[ -n \"$_flags\" ]; flags=\"flags $_flags\"\n\t\tfi\n\t\tif [ $p = \"dev\" ]; then\n\t\t\teval _dev=\\$\"$nr\"\n\t\t\t[ -n \"$_dev\" ]; dev=\"dev $_dev\"\n\t\tfi\n\t\tif [ $p = \"id\" ]; then\n\t\t\teval _id=\\$\"$nr\"\n\t\t\t[ -n \"$_id\" ]; id=\"id $_id\"\n\t\tfi\n\t\tif [ $p = \"port\" ]; then\n\t\t\teval _port=\\$\"$nr\"\n\t\t\t[ -n \"$_port\" ]; port=\"port $_port\"\n\t\tfi\n\n\t\tnr=$((nr + 1))\n\tdone\n\n\tif [ $ip_mptcp -eq 1 ]; then\n\t\tip -n $ns mptcp endpoint add $addr ${_flags//\",\"/\" \"} $dev $id $port\n\telse\n\t\tip netns exec $ns ./pm_nl_ctl add $addr $flags $dev $id $port\n\tfi\n}\n\npm_nl_del_endpoint()\n{\n\tlocal ns=$1\n\tlocal id=$2\n\tlocal addr=$3\n\n\tif [ $ip_mptcp -eq 1 ]; then\n\t\t[ $id -ne 0 ] && addr=''\n\t\tip -n $ns mptcp endpoint delete id $id $addr\n\telse\n\t\tip netns exec $ns ./pm_nl_ctl del $id $addr\n\tfi\n}\n\npm_nl_flush_endpoint()\n{\n\tlocal ns=$1\n\n\tif [ $ip_mptcp -eq 1 ]; then\n\t\tip -n $ns mptcp endpoint flush\n\telse\n\t\tip netns exec $ns ./pm_nl_ctl flush\n\tfi\n}\n\npm_nl_show_endpoints()\n{\n\tlocal ns=$1\n\n\tif [ $ip_mptcp -eq 1 ]; then\n\t\tip -n $ns mptcp endpoint show\n\telse\n\t\tip netns exec $ns ./pm_nl_ctl dump\n\tfi\n}\n\npm_nl_change_endpoint()\n{\n\tlocal ns=$1\n\tlocal id=$2\n\tlocal flags=$3\n\n\tif [ $ip_mptcp -eq 1 ]; then\n\t\tip -n $ns mptcp endpoint change id $id ${flags//\",\"/\" \"}\n\telse\n\t\tip netns exec $ns ./pm_nl_ctl set id $id flags $flags\n\tfi\n}\n\npm_nl_check_endpoint()\n{\n\tlocal line expected_line\n\tlocal msg=\"$1\"\n\tlocal ns=$2\n\tlocal addr=$3\n\tlocal _flags=\"\"\n\tlocal flags\n\tlocal _port\n\tlocal port\n\tlocal dev\n\tlocal _id\n\tlocal id\n\n\tprint_check \"${msg}\"\n\n\tshift 3\n\twhile [ -n \"$1\" ]; do\n\t\tif [ $1 = \"flags\" ]; then\n\t\t\t_flags=$2\n\t\t\t[ -n \"$_flags\" ]; flags=\"flags $_flags\"\n\t\t\tshift\n\t\telif [ $1 = \"dev\" ]; then\n\t\t\t[ -n \"$2\" ]; dev=\"dev $1\"\n\t\t\tshift\n\t\telif [ $1 = \"id\" ]; then\n\t\t\t_id=$2\n\t\t\t[ -n \"$_id\" ]; id=\"id $_id\"\n\t\t\tshift\n\t\telif [ $1 = \"port\" ]; then\n\t\t\t_port=$2\n\t\t\t[ -n \"$_port\" ]; port=\" port $_port\"\n\t\t\tshift\n\t\tfi\n\n\t\tshift\n\tdone\n\n\tif [ -z \"$id\" ]; then\n\t\ttest_fail \"bad test - missing endpoint id\"\n\t\treturn\n\tfi\n\n\tif [ $ip_mptcp -eq 1 ]; then\n\t\t# get line and trim trailing whitespace\n\t\tline=$(ip -n $ns mptcp endpoint show $id)\n\t\tline=\"${line% }\"\n\t\t# the dump order is: address id flags port dev\n\t\t[ -n \"$addr\" ] && expected_line=\"$addr\"\n\t\texpected_line=\"$expected_line $id\"\n\t\t[ -n \"$_flags\" ] && expected_line=\"$expected_line ${_flags//\",\"/\" \"}\"\n\t\t[ -n \"$dev\" ] && expected_line=\"$expected_line $dev\"\n\t\t[ -n \"$port\" ] && expected_line=\"$expected_line $port\"\n\telse\n\t\tline=$(ip netns exec $ns ./pm_nl_ctl get $_id)\n\t\t# the dump order is: id flags dev address port\n\t\texpected_line=\"$id\"\n\t\t[ -n \"$flags\" ] && expected_line=\"$expected_line $flags\"\n\t\t[ -n \"$dev\" ] && expected_line=\"$expected_line $dev\"\n\t\t[ -n \"$addr\" ] && expected_line=\"$expected_line $addr\"\n\t\t[ -n \"$_port\" ] && expected_line=\"$expected_line $_port\"\n\tfi\n\tif [ \"$line\" = \"$expected_line\" ]; then\n\t\tprint_ok\n\telse\n\t\tfail_test \"expected '$expected_line' found '$line'\"\n\tfi\n}\n\npm_nl_set_endpoint()\n{\n\tlocal listener_ns=\"$1\"\n\tlocal connector_ns=\"$2\"\n\tlocal connect_addr=\"$3\"\n\n\tlocal addr_nr_ns1=${addr_nr_ns1:-0}\n\tlocal addr_nr_ns2=${addr_nr_ns2:-0}\n\tlocal sflags=${sflags:-\"\"}\n\tlocal fullmesh=${fullmesh:-\"\"}\n\n\tlocal flags=\"subflow\"\n\tif [ -n \"${fullmesh}\" ]; then\n\t\tflags=\"${flags},fullmesh\"\n\t\taddr_nr_ns2=${fullmesh}\n\tfi\n\n\t# let the mptcp subflow be established in background before\n\t# do endpoint manipulation\n\tif [ $addr_nr_ns1 != \"0\" ] || [ $addr_nr_ns2 != \"0\" ]; then\n\t\tsleep 1\n\tfi\n\n\tif [ $addr_nr_ns1 -gt 0 ]; then\n\t\tlocal counter=2\n\t\tlocal add_nr_ns1=${addr_nr_ns1}\n\t\tlocal id=10\n\t\twhile [ $add_nr_ns1 -gt 0 ]; do\n\t\t\tlocal addr\n\t\t\tif is_v6 \"${connect_addr}\"; then\n\t\t\t\taddr=\"dead:beef:$counter::1\"\n\t\t\telse\n\t\t\t\taddr=\"10.0.$counter.1\"\n\t\t\tfi\n\t\t\tpm_nl_add_endpoint $ns1 $addr flags signal\n\t\t\tcounter=$((counter + 1))\n\t\t\tadd_nr_ns1=$((add_nr_ns1 - 1))\n\t\t\tid=$((id + 1))\n\t\tdone\n\telif [ $addr_nr_ns1 -lt 0 ]; then\n\t\tlocal rm_nr_ns1=$((-addr_nr_ns1))\n\t\tif [ $rm_nr_ns1 -lt 8 ]; then\n\t\t\tlocal counter=0\n\t\t\tlocal line\n\t\t\tpm_nl_show_endpoints ${listener_ns} | while read -r line; do\n\t\t\t\t# shellcheck disable=SC2206 # we do want to split per word\n\t\t\t\tlocal arr=($line)\n\t\t\t\tlocal nr=0\n\n\t\t\t\tlocal i\n\t\t\t\tfor i in \"${arr[@]}\"; do\n\t\t\t\t\tif [ $i = \"id\" ]; then\n\t\t\t\t\t\tif [ $counter -eq $rm_nr_ns1 ]; then\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tfi\n\t\t\t\t\t\tid=${arr[$nr+1]}\n\t\t\t\t\t\trm_addr=$(rm_addr_count ${connector_ns})\n\t\t\t\t\t\tpm_nl_del_endpoint ${listener_ns} $id\n\t\t\t\t\t\twait_rm_addr ${connector_ns} ${rm_addr}\n\t\t\t\t\t\tcounter=$((counter + 1))\n\t\t\t\t\tfi\n\t\t\t\t\tnr=$((nr + 1))\n\t\t\t\tdone\n\t\t\tdone\n\t\telif [ $rm_nr_ns1 -eq 8 ]; then\n\t\t\tpm_nl_flush_endpoint ${listener_ns}\n\t\telif [ $rm_nr_ns1 -eq 9 ]; then\n\t\t\tpm_nl_del_endpoint ${listener_ns} 0 ${connect_addr}\n\t\tfi\n\tfi\n\n\t# if newly added endpoints must be deleted, give the background msk\n\t# some time to created them\n\t[ $addr_nr_ns1 -gt 0 ] && [ $addr_nr_ns2 -lt 0 ] && sleep 1\n\n\tif [ $addr_nr_ns2 -gt 0 ]; then\n\t\tlocal add_nr_ns2=${addr_nr_ns2}\n\t\tlocal counter=3\n\t\tlocal id=20\n\t\twhile [ $add_nr_ns2 -gt 0 ]; do\n\t\t\tlocal addr\n\t\t\tif is_v6 \"${connect_addr}\"; then\n\t\t\t\taddr=\"dead:beef:$counter::2\"\n\t\t\telse\n\t\t\t\taddr=\"10.0.$counter.2\"\n\t\t\tfi\n\t\t\tpm_nl_add_endpoint $ns2 $addr flags $flags\n\t\t\tcounter=$((counter + 1))\n\t\t\tadd_nr_ns2=$((add_nr_ns2 - 1))\n\t\t\tid=$((id + 1))\n\t\tdone\n\telif [ $addr_nr_ns2 -lt 0 ]; then\n\t\tlocal rm_nr_ns2=$((-addr_nr_ns2))\n\t\tif [ $rm_nr_ns2 -lt 8 ]; then\n\t\t\tlocal counter=0\n\t\t\tlocal line\n\t\t\tpm_nl_show_endpoints ${connector_ns} | while read -r line; do\n\t\t\t\t# shellcheck disable=SC2206 # we do want to split per word\n\t\t\t\tlocal arr=($line)\n\t\t\t\tlocal nr=0\n\n\t\t\t\tlocal i\n\t\t\t\tfor i in \"${arr[@]}\"; do\n\t\t\t\t\tif [ $i = \"id\" ]; then\n\t\t\t\t\t\tif [ $counter -eq $rm_nr_ns2 ]; then\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tfi\n\t\t\t\t\t\tlocal id rm_addr\n\t\t\t\t\t\t# rm_addr are serialized, allow the previous one to\n\t\t\t\t\t\t# complete\n\t\t\t\t\t\tid=${arr[$nr+1]}\n\t\t\t\t\t\trm_addr=$(rm_addr_count ${listener_ns})\n\t\t\t\t\t\tpm_nl_del_endpoint ${connector_ns} $id\n\t\t\t\t\t\twait_rm_addr ${listener_ns} ${rm_addr}\n\t\t\t\t\t\tcounter=$((counter + 1))\n\t\t\t\t\tfi\n\t\t\t\t\tnr=$((nr + 1))\n\t\t\t\tdone\n\t\t\tdone\n\t\telif [ $rm_nr_ns2 -eq 8 ]; then\n\t\t\tpm_nl_flush_endpoint ${connector_ns}\n\t\telif [ $rm_nr_ns2 -eq 9 ]; then\n\t\t\tlocal addr\n\t\t\tif is_v6 \"${connect_addr}\"; then\n\t\t\t\taddr=\"dead:beef:1::2\"\n\t\t\telse\n\t\t\t\taddr=\"10.0.1.2\"\n\t\t\tfi\n\t\t\tpm_nl_del_endpoint ${connector_ns} 0 $addr\n\t\tfi\n\tfi\n\n\tif [ -n \"${sflags}\" ]; then\n\t\tsleep 1\n\n\t\tlocal netns\n\t\tfor netns in \"$ns1\" \"$ns2\"; do\n\t\t\tlocal line\n\t\t\tpm_nl_show_endpoints $netns | while read -r line; do\n\t\t\t\t# shellcheck disable=SC2206 # we do want to split per word\n\t\t\t\tlocal arr=($line)\n\t\t\t\tlocal nr=0\n\t\t\t\tlocal id\n\n\t\t\t\tlocal i\n\t\t\t\tfor i in \"${arr[@]}\"; do\n\t\t\t\t\tif [ $i = \"id\" ]; then\n\t\t\t\t\t\tid=${arr[$nr+1]}\n\t\t\t\t\tfi\n\t\t\t\t\tnr=$((nr + 1))\n\t\t\t\tdone\n\t\t\t\tpm_nl_change_endpoint $netns $id $sflags\n\t\t\tdone\n\t\tdone\n\tfi\n}\n\ndo_transfer()\n{\n\tlocal listener_ns=\"$1\"\n\tlocal connector_ns=\"$2\"\n\tlocal cl_proto=\"$3\"\n\tlocal srv_proto=\"$4\"\n\tlocal connect_addr=\"$5\"\n\n\tlocal port=$((10000 + TEST_COUNT - 1))\n\tlocal cappid\n\tlocal FAILING_LINKS=${FAILING_LINKS:-\"\"}\n\tlocal fastclose=${fastclose:-\"\"}\n\tlocal speed=${speed:-\"fast\"}\n\n\t:> \"$cout\"\n\t:> \"$sout\"\n\t:> \"$capout\"\n\n\tif [ $capture -eq 1 ]; then\n\t\tlocal capuser\n\t\tif [ -z $SUDO_USER ] ; then\n\t\t\tcapuser=\"\"\n\t\telse\n\t\t\tcapuser=\"-Z $SUDO_USER\"\n\t\tfi\n\n\t\tcapfile=$(printf \"mp_join-%02u-%s.pcap\" \"$TEST_COUNT\" \"${listener_ns}\")\n\n\t\techo \"Capturing traffic for test $TEST_COUNT into $capfile\"\n\t\tip netns exec ${listener_ns} tcpdump -i any -s 65535 -B 32768 $capuser -w $capfile > \"$capout\" 2>&1 &\n\t\tcappid=$!\n\n\t\tsleep 1\n\tfi\n\n\tNSTAT_HISTORY=/tmp/${listener_ns}.nstat ip netns exec ${listener_ns} \\\n\t\tnstat -n\n\tNSTAT_HISTORY=/tmp/${connector_ns}.nstat ip netns exec ${connector_ns} \\\n\t\tnstat -n\n\n\tlocal extra_args\n\tif [ $speed = \"fast\" ]; then\n\t\textra_args=\"-j\"\n\telif [ $speed = \"slow\" ]; then\n\t\textra_args=\"-r 50\"\n\telif [ $speed -gt 0 ]; then\n\t\textra_args=\"-r ${speed}\"\n\tfi\n\n\tlocal extra_cl_args=\"\"\n\tlocal extra_srv_args=\"\"\n\tlocal trunc_size=\"\"\n\tif [ -n \"${fastclose}\" ]; then\n\t\tif [ ${test_linkfail} -le 1 ]; then\n\t\t\tfail_test \"fastclose tests need test_linkfail argument\"\n\t\t\treturn 1\n\t\tfi\n\n\t\t# disconnect\n\t\ttrunc_size=${test_linkfail}\n\t\tlocal side=${fastclose}\n\n\t\tif [ ${side} = \"client\" ]; then\n\t\t\textra_cl_args=\"-f ${test_linkfail}\"\n\t\t\textra_srv_args=\"-f -1\"\n\t\telif [ ${side} = \"server\" ]; then\n\t\t\textra_srv_args=\"-f ${test_linkfail}\"\n\t\t\textra_cl_args=\"-f -1\"\n\t\telse\n\t\t\tfail_test \"wrong/unknown fastclose spec ${side}\"\n\t\t\treturn 1\n\t\tfi\n\tfi\n\n\textra_srv_args=\"$extra_args $extra_srv_args\"\n\tif [ \"$test_linkfail\" -gt 1 ];then\n\t\ttimeout ${timeout_test} \\\n\t\t\tip netns exec ${listener_ns} \\\n\t\t\t\t./mptcp_connect -t ${timeout_poll} -l -p $port -s ${srv_proto} \\\n\t\t\t\t\t$extra_srv_args \"::\" < \"$sinfail\" > \"$sout\" &\n\telse\n\t\ttimeout ${timeout_test} \\\n\t\t\tip netns exec ${listener_ns} \\\n\t\t\t\t./mptcp_connect -t ${timeout_poll} -l -p $port -s ${srv_proto} \\\n\t\t\t\t\t$extra_srv_args \"::\" < \"$sin\" > \"$sout\" &\n\tfi\n\tlocal spid=$!\n\n\twait_local_port_listen \"${listener_ns}\" \"${port}\"\n\n\textra_cl_args=\"$extra_args $extra_cl_args\"\n\tif [ \"$test_linkfail\" -eq 0 ];then\n\t\ttimeout ${timeout_test} \\\n\t\t\tip netns exec ${connector_ns} \\\n\t\t\t\t./mptcp_connect -t ${timeout_poll} -p $port -s ${cl_proto} \\\n\t\t\t\t\t$extra_cl_args $connect_addr < \"$cin\" > \"$cout\" &\n\telif [ \"$test_linkfail\" -eq 1 ] || [ \"$test_linkfail\" -eq 2 ];then\n\t\t( cat \"$cinfail\" ; sleep 2; link_failure $listener_ns ; cat \"$cinfail\" ) | \\\n\t\t\ttee \"$cinsent\" | \\\n\t\t\ttimeout ${timeout_test} \\\n\t\t\t\tip netns exec ${connector_ns} \\\n\t\t\t\t\t./mptcp_connect -t ${timeout_poll} -p $port -s ${cl_proto} \\\n\t\t\t\t\t\t$extra_cl_args $connect_addr > \"$cout\" &\n\telse\n\t\ttee \"$cinsent\" < \"$cinfail\" | \\\n\t\t\ttimeout ${timeout_test} \\\n\t\t\t\tip netns exec ${connector_ns} \\\n\t\t\t\t\t./mptcp_connect -t ${timeout_poll} -p $port -s ${cl_proto} \\\n\t\t\t\t\t\t$extra_cl_args $connect_addr > \"$cout\" &\n\tfi\n\tlocal cpid=$!\n\n\tpm_nl_set_endpoint $listener_ns $connector_ns $connect_addr\n\n\twait $cpid\n\tlocal retc=$?\n\twait $spid\n\tlocal rets=$?\n\n\tif [ $capture -eq 1 ]; then\n\t    sleep 1\n\t    kill $cappid\n\tfi\n\n\tNSTAT_HISTORY=/tmp/${listener_ns}.nstat ip netns exec ${listener_ns} \\\n\t\tnstat | grep Tcp > /tmp/${listener_ns}.out\n\tNSTAT_HISTORY=/tmp/${connector_ns}.nstat ip netns exec ${connector_ns} \\\n\t\tnstat | grep Tcp > /tmp/${connector_ns}.out\n\n\tif [ ${rets} -ne 0 ] || [ ${retc} -ne 0 ]; then\n\t\tfail_test \"client exit code $retc, server $rets\"\n\t\techo -e \"\\nnetns ${listener_ns} socket stat for ${port}:\" 1>&2\n\t\tip netns exec ${listener_ns} ss -Menita 1>&2 -o \"sport = :$port\"\n\t\tcat /tmp/${listener_ns}.out\n\t\techo -e \"\\nnetns ${connector_ns} socket stat for ${port}:\" 1>&2\n\t\tip netns exec ${connector_ns} ss -Menita 1>&2 -o \"dport = :$port\"\n\t\tcat /tmp/${connector_ns}.out\n\n\t\tcat \"$capout\"\n\t\treturn 1\n\tfi\n\n\tif [ \"$test_linkfail\" -gt 1 ];then\n\t\tcheck_transfer $sinfail $cout \"file received by client\" $trunc_size\n\telse\n\t\tcheck_transfer $sin $cout \"file received by client\" $trunc_size\n\tfi\n\tretc=$?\n\tif [ \"$test_linkfail\" -eq 0 ];then\n\t\tcheck_transfer $cin $sout \"file received by server\" $trunc_size\n\telse\n\t\tcheck_transfer $cinsent $sout \"file received by server\" $trunc_size\n\tfi\n\trets=$?\n\n\tif [ $retc -eq 0 ] && [ $rets -eq 0 ];then\n\t\tcat \"$capout\"\n\t\treturn 0\n\tfi\n\n\tcat \"$capout\"\n\treturn 1\n}\n\nmake_file()\n{\n\tlocal name=$1\n\tlocal who=$2\n\tlocal size=$3\n\n\tdd if=/dev/urandom of=\"$name\" bs=1024 count=$size 2> /dev/null\n\techo -e \"\\nMPTCP_TEST_FILE_END_MARKER\" >> \"$name\"\n\n\tprint_info \"Test file (size $size KB) for $who\"\n}\n\nrun_tests()\n{\n\tlocal listener_ns=\"$1\"\n\tlocal connector_ns=\"$2\"\n\tlocal connect_addr=\"$3\"\n\n\tlocal size\n\tlocal test_linkfail=${test_linkfail:-0}\n\n\t# The values above 2 are reused to make test files\n\t# with the given sizes (KB)\n\tif [ \"$test_linkfail\" -gt 2 ]; then\n\t\tsize=$test_linkfail\n\n\t\tif [ -z \"$cinfail\" ]; then\n\t\t\tcinfail=$(mktemp)\n\t\tfi\n\t\tmake_file \"$cinfail\" \"client\" $size\n\t# create the input file for the failure test when\n\t# the first failure test run\n\telif [ \"$test_linkfail\" -ne 0 ] && [ -z \"$cinfail\" ]; then\n\t\t# the client file must be considerably larger\n\t\t# of the maximum expected cwin value, or the\n\t\t# link utilization will be not predicable\n\t\tsize=$((RANDOM%2))\n\t\tsize=$((size+1))\n\t\tsize=$((size*8192))\n\t\tsize=$((size + ( RANDOM % 8192) ))\n\n\t\tcinfail=$(mktemp)\n\t\tmake_file \"$cinfail\" \"client\" $size\n\tfi\n\n\tif [ \"$test_linkfail\" -gt 2 ]; then\n\t\tsize=$test_linkfail\n\n\t\tif [ -z \"$sinfail\" ]; then\n\t\t\tsinfail=$(mktemp)\n\t\tfi\n\t\tmake_file \"$sinfail\" \"server\" $size\n\telif [ \"$test_linkfail\" -eq 2 ] && [ -z \"$sinfail\" ]; then\n\t\tsize=$((RANDOM%16))\n\t\tsize=$((size+1))\n\t\tsize=$((size*2048))\n\n\t\tsinfail=$(mktemp)\n\t\tmake_file \"$sinfail\" \"server\" $size\n\tfi\n\n\tdo_transfer ${listener_ns} ${connector_ns} MPTCP MPTCP ${connect_addr}\n}\n\ndump_stats()\n{\n\techo Server ns stats\n\tip netns exec $ns1 nstat -as | grep Tcp\n\techo Client ns stats\n\tip netns exec $ns2 nstat -as | grep Tcp\n}\n\nchk_csum_nr()\n{\n\tlocal csum_ns1=${1:-0}\n\tlocal csum_ns2=${2:-0}\n\tlocal count\n\tlocal extra_msg=\"\"\n\tlocal allow_multi_errors_ns1=0\n\tlocal allow_multi_errors_ns2=0\n\n\tif [[ \"${csum_ns1}\" = \"+\"* ]]; then\n\t\tallow_multi_errors_ns1=1\n\t\tcsum_ns1=${csum_ns1:1}\n\tfi\n\tif [[ \"${csum_ns2}\" = \"+\"* ]]; then\n\t\tallow_multi_errors_ns2=1\n\t\tcsum_ns2=${csum_ns2:1}\n\tfi\n\n\tprint_check \"sum\"\n\tcount=$(get_counter ${ns1} \"MPTcpExtDataCsumErr\")\n\tif [ \"$count\" != \"$csum_ns1\" ]; then\n\t\textra_msg=\"$extra_msg ns1=$count\"\n\tfi\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif { [ \"$count\" != $csum_ns1 ] && [ $allow_multi_errors_ns1 -eq 0 ]; } ||\n\t   { [ \"$count\" -lt $csum_ns1 ] && [ $allow_multi_errors_ns1 -eq 1 ]; }; then\n\t\tfail_test \"got $count data checksum error[s] expected $csum_ns1\"\n\telse\n\t\tprint_ok\n\tfi\n\tprint_check \"csum\"\n\tcount=$(get_counter ${ns2} \"MPTcpExtDataCsumErr\")\n\tif [ \"$count\" != \"$csum_ns2\" ]; then\n\t\textra_msg=\"$extra_msg ns2=$count\"\n\tfi\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif { [ \"$count\" != $csum_ns2 ] && [ $allow_multi_errors_ns2 -eq 0 ]; } ||\n\t   { [ \"$count\" -lt $csum_ns2 ] && [ $allow_multi_errors_ns2 -eq 1 ]; }; then\n\t\tfail_test \"got $count data checksum error[s] expected $csum_ns2\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_info \"$extra_msg\"\n}\n\nchk_fail_nr()\n{\n\tlocal fail_tx=$1\n\tlocal fail_rx=$2\n\tlocal ns_invert=${3:-\"\"}\n\tlocal count\n\tlocal ns_tx=$ns1\n\tlocal ns_rx=$ns2\n\tlocal extra_msg=\"\"\n\tlocal allow_tx_lost=0\n\tlocal allow_rx_lost=0\n\n\tif [[ $ns_invert = \"invert\" ]]; then\n\t\tns_tx=$ns2\n\t\tns_rx=$ns1\n\t\textra_msg=\"invert\"\n\tfi\n\n\tif [[ \"${fail_tx}\" = \"-\"* ]]; then\n\t\tallow_tx_lost=1\n\t\tfail_tx=${fail_tx:1}\n\tfi\n\tif [[ \"${fail_rx}\" = \"-\"* ]]; then\n\t\tallow_rx_lost=1\n\t\tfail_rx=${fail_rx:1}\n\tfi\n\n\tprint_check \"ftx\"\n\tcount=$(get_counter ${ns_tx} \"MPTcpExtMPFailTx\")\n\tif [ \"$count\" != \"$fail_tx\" ]; then\n\t\textra_msg=\"$extra_msg,tx=$count\"\n\tfi\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif { [ \"$count\" != \"$fail_tx\" ] && [ $allow_tx_lost -eq 0 ]; } ||\n\t   { [ \"$count\" -gt \"$fail_tx\" ] && [ $allow_tx_lost -eq 1 ]; }; then\n\t\tfail_test \"got $count MP_FAIL[s] TX expected $fail_tx\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"failrx\"\n\tcount=$(get_counter ${ns_rx} \"MPTcpExtMPFailRx\")\n\tif [ \"$count\" != \"$fail_rx\" ]; then\n\t\textra_msg=\"$extra_msg,rx=$count\"\n\tfi\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif { [ \"$count\" != \"$fail_rx\" ] && [ $allow_rx_lost -eq 0 ]; } ||\n\t   { [ \"$count\" -gt \"$fail_rx\" ] && [ $allow_rx_lost -eq 1 ]; }; then\n\t\tfail_test \"got $count MP_FAIL[s] RX expected $fail_rx\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_info \"$extra_msg\"\n}\n\nchk_fclose_nr()\n{\n\tlocal fclose_tx=$1\n\tlocal fclose_rx=$2\n\tlocal ns_invert=$3\n\tlocal count\n\tlocal ns_tx=$ns2\n\tlocal ns_rx=$ns1\n\tlocal extra_msg=\"\"\n\n\tif [[ $ns_invert = \"invert\" ]]; then\n\t\tns_tx=$ns1\n\t\tns_rx=$ns2\n\t\textra_msg=\"invert\"\n\tfi\n\n\tprint_check \"ctx\"\n\tcount=$(get_counter ${ns_tx} \"MPTcpExtMPFastcloseTx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$fclose_tx\" ]; then\n\t\textra_msg=\"$extra_msg,tx=$count\"\n\t\tfail_test \"got $count MP_FASTCLOSE[s] TX expected $fclose_tx\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"fclzrx\"\n\tcount=$(get_counter ${ns_rx} \"MPTcpExtMPFastcloseRx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$fclose_rx\" ]; then\n\t\textra_msg=\"$extra_msg,rx=$count\"\n\t\tfail_test \"got $count MP_FASTCLOSE[s] RX expected $fclose_rx\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_info \"$extra_msg\"\n}\n\nchk_rst_nr()\n{\n\tlocal rst_tx=$1\n\tlocal rst_rx=$2\n\tlocal ns_invert=${3:-\"\"}\n\tlocal count\n\tlocal ns_tx=$ns1\n\tlocal ns_rx=$ns2\n\tlocal extra_msg=\"\"\n\n\tif [[ $ns_invert = \"invert\" ]]; then\n\t\tns_tx=$ns2\n\t\tns_rx=$ns1\n\t\textra_msg=\"invert\"\n\tfi\n\n\tprint_check \"rtx\"\n\tcount=$(get_counter ${ns_tx} \"MPTcpExtMPRstTx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\t# accept more rst than expected except if we don't expect any\n\telif { [ $rst_tx -ne 0 ] && [ $count -lt $rst_tx ]; } ||\n\t     { [ $rst_tx -eq 0 ] && [ $count -ne 0 ]; }; then\n\t\tfail_test \"got $count MP_RST[s] TX expected $rst_tx\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"rstrx\"\n\tcount=$(get_counter ${ns_rx} \"MPTcpExtMPRstRx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\t# accept more rst than expected except if we don't expect any\n\telif { [ $rst_rx -ne 0 ] && [ $count -lt $rst_rx ]; } ||\n\t     { [ $rst_rx -eq 0 ] && [ $count -ne 0 ]; }; then\n\t\tfail_test \"got $count MP_RST[s] RX expected $rst_rx\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_info \"$extra_msg\"\n}\n\nchk_infi_nr()\n{\n\tlocal infi_tx=$1\n\tlocal infi_rx=$2\n\tlocal count\n\n\tprint_check \"itx\"\n\tcount=$(get_counter ${ns2} \"MPTcpExtInfiniteMapTx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$infi_tx\" ]; then\n\t\tfail_test \"got $count infinite map[s] TX expected $infi_tx\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"infirx\"\n\tcount=$(get_counter ${ns1} \"MPTcpExtInfiniteMapRx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$infi_rx\" ]; then\n\t\tfail_test \"got $count infinite map[s] RX expected $infi_rx\"\n\telse\n\t\tprint_ok\n\tfi\n}\n\nchk_join_nr()\n{\n\tlocal syn_nr=$1\n\tlocal syn_ack_nr=$2\n\tlocal ack_nr=$3\n\tlocal csum_ns1=${4:-0}\n\tlocal csum_ns2=${5:-0}\n\tlocal fail_nr=${6:-0}\n\tlocal rst_nr=${7:-0}\n\tlocal infi_nr=${8:-0}\n\tlocal corrupted_pkts=${9:-0}\n\tlocal count\n\tlocal with_cookie\n\n\tif [ \"${corrupted_pkts}\" -gt 0 ]; then\n\t\tprint_info \"${corrupted_pkts} corrupted pkts\"\n\tfi\n\n\tprint_check \"syn\"\n\tcount=$(get_counter ${ns1} \"MPTcpExtMPJoinSynRx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$syn_nr\" ]; then\n\t\tfail_test \"got $count JOIN[s] syn expected $syn_nr\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"synack\"\n\twith_cookie=$(ip netns exec $ns2 sysctl -n net.ipv4.tcp_syncookies)\n\tcount=$(get_counter ${ns2} \"MPTcpExtMPJoinSynAckRx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$syn_ack_nr\" ]; then\n\t\t# simult connections exceeding the limit with cookie enabled could go up to\n\t\t# synack validation as the conn limit can be enforced reliably only after\n\t\t# the subflow creation\n\t\tif [ \"$with_cookie\" = 2 ] && [ \"$count\" -gt \"$syn_ack_nr\" ] && [ \"$count\" -le \"$syn_nr\" ]; then\n\t\t\tprint_ok\n\t\telse\n\t\t\tfail_test \"got $count JOIN[s] synack expected $syn_ack_nr\"\n\t\tfi\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"ack\"\n\tcount=$(get_counter ${ns1} \"MPTcpExtMPJoinAckRx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$ack_nr\" ]; then\n\t\tfail_test \"got $count JOIN[s] ack expected $ack_nr\"\n\telse\n\t\tprint_ok\n\tfi\n\tif [ $validate_checksum -eq 1 ]; then\n\t\tchk_csum_nr $csum_ns1 $csum_ns2\n\t\tchk_fail_nr $fail_nr $fail_nr\n\t\tchk_rst_nr $rst_nr $rst_nr\n\t\tchk_infi_nr $infi_nr $infi_nr\n\tfi\n}\n\n# a negative value for 'stale_max' means no upper bound:\n# for bidirectional transfer, if one peer sleep for a while\n# - as these tests do - we can have a quite high number of\n# stale/recover conversions, proportional to\n# sleep duration/ MPTCP-level RTX interval.\nchk_stale_nr()\n{\n\tlocal ns=$1\n\tlocal stale_min=$2\n\tlocal stale_max=$3\n\tlocal stale_delta=$4\n\tlocal dump_stats\n\tlocal stale_nr\n\tlocal recover_nr\n\n\tprint_check \"stale\"\n\n\tstale_nr=$(get_counter ${ns} \"MPTcpExtSubflowStale\")\n\trecover_nr=$(get_counter ${ns} \"MPTcpExtSubflowRecover\")\n\tif [ -z \"$stale_nr\" ] || [ -z \"$recover_nr\" ]; then\n\t\tprint_skip\n\telif [ $stale_nr -lt $stale_min ] ||\n\t   { [ $stale_max -gt 0 ] && [ $stale_nr -gt $stale_max ]; } ||\n\t   [ $((stale_nr - recover_nr)) -ne $stale_delta ]; then\n\t\tfail_test \"got $stale_nr stale[s] $recover_nr recover[s], \" \\\n\t\t     \" expected stale in range [$stale_min..$stale_max],\" \\\n\t\t     \" stale-recover delta $stale_delta\"\n\t\tdump_stats=1\n\telse\n\t\tprint_ok\n\tfi\n\n\tif [ \"${dump_stats}\" = 1 ]; then\n\t\techo $ns stats\n\t\tip netns exec $ns ip -s link show\n\t\tip netns exec $ns nstat -as | grep MPTcp\n\tfi\n}\n\nchk_add_nr()\n{\n\tlocal add_nr=$1\n\tlocal echo_nr=$2\n\tlocal port_nr=${3:-0}\n\tlocal syn_nr=${4:-$port_nr}\n\tlocal syn_ack_nr=${5:-$port_nr}\n\tlocal ack_nr=${6:-$port_nr}\n\tlocal mis_syn_nr=${7:-0}\n\tlocal mis_ack_nr=${8:-0}\n\tlocal count\n\tlocal timeout\n\n\ttimeout=$(ip netns exec $ns1 sysctl -n net.mptcp.add_addr_timeout)\n\n\tprint_check \"add\"\n\tcount=$(get_counter ${ns2} \"MPTcpExtAddAddr\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\t# if the test configured a short timeout tolerate greater then expected\n\t# add addrs options, due to retransmissions\n\telif [ \"$count\" != \"$add_nr\" ] && { [ \"$timeout\" -gt 1 ] || [ \"$count\" -lt \"$add_nr\" ]; }; then\n\t\tfail_test \"got $count ADD_ADDR[s] expected $add_nr\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"echo\"\n\tcount=$(get_counter ${ns1} \"MPTcpExtEchoAdd\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$echo_nr\" ]; then\n\t\tfail_test \"got $count ADD_ADDR echo[s] expected $echo_nr\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tif [ $port_nr -gt 0 ]; then\n\t\tprint_check \"pt\"\n\t\tcount=$(get_counter ${ns2} \"MPTcpExtPortAdd\")\n\t\tif [ -z \"$count\" ]; then\n\t\t\tprint_skip\n\t\telif [ \"$count\" != \"$port_nr\" ]; then\n\t\t\tfail_test \"got $count ADD_ADDR[s] with a port-number expected $port_nr\"\n\t\telse\n\t\t\tprint_ok\n\t\tfi\n\n\t\tprint_check \"syn\"\n\t\tcount=$(get_counter ${ns1} \"MPTcpExtMPJoinPortSynRx\")\n\t\tif [ -z \"$count\" ]; then\n\t\t\tprint_skip\n\t\telif [ \"$count\" != \"$syn_nr\" ]; then\n\t\t\tfail_test \"got $count JOIN[s] syn with a different \\\n\t\t\t\t   port-number expected $syn_nr\"\n\t\telse\n\t\t\tprint_ok\n\t\tfi\n\n\t\tprint_check \"synack\"\n\t\tcount=$(get_counter ${ns2} \"MPTcpExtMPJoinPortSynAckRx\")\n\t\tif [ -z \"$count\" ]; then\n\t\t\tprint_skip\n\t\telif [ \"$count\" != \"$syn_ack_nr\" ]; then\n\t\t\tfail_test \"got $count JOIN[s] synack with a different \\\n\t\t\t\t   port-number expected $syn_ack_nr\"\n\t\telse\n\t\t\tprint_ok\n\t\tfi\n\n\t\tprint_check \"ack\"\n\t\tcount=$(get_counter ${ns1} \"MPTcpExtMPJoinPortAckRx\")\n\t\tif [ -z \"$count\" ]; then\n\t\t\tprint_skip\n\t\telif [ \"$count\" != \"$ack_nr\" ]; then\n\t\t\tfail_test \"got $count JOIN[s] ack with a different \\\n\t\t\t\t   port-number expected $ack_nr\"\n\t\telse\n\t\t\tprint_ok\n\t\tfi\n\n\t\tprint_check \"syn\"\n\t\tcount=$(get_counter ${ns1} \"MPTcpExtMismatchPortSynRx\")\n\t\tif [ -z \"$count\" ]; then\n\t\t\tprint_skip\n\t\telif [ \"$count\" != \"$mis_syn_nr\" ]; then\n\t\t\tfail_test \"got $count JOIN[s] syn with a mismatched \\\n\t\t\t\t   port-number expected $mis_syn_nr\"\n\t\telse\n\t\t\tprint_ok\n\t\tfi\n\n\t\tprint_check \"ack\"\n\t\tcount=$(get_counter ${ns1} \"MPTcpExtMismatchPortAckRx\")\n\t\tif [ -z \"$count\" ]; then\n\t\t\tprint_skip\n\t\telif [ \"$count\" != \"$mis_ack_nr\" ]; then\n\t\t\tfail_test \"got $count JOIN[s] ack with a mismatched \\\n\t\t\t\t   port-number expected $mis_ack_nr\"\n\t\telse\n\t\t\tprint_ok\n\t\tfi\n\tfi\n}\n\nchk_add_tx_nr()\n{\n\tlocal add_tx_nr=$1\n\tlocal echo_tx_nr=$2\n\tlocal timeout\n\tlocal count\n\n\ttimeout=$(ip netns exec $ns1 sysctl -n net.mptcp.add_addr_timeout)\n\n\tprint_check \"add TX\"\n\tcount=$(get_counter ${ns1} \"MPTcpExtAddAddrTx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\t# if the test configured a short timeout tolerate greater then expected\n\t# add addrs options, due to retransmissions\n\telif [ \"$count\" != \"$add_tx_nr\" ] && { [ \"$timeout\" -gt 1 ] || [ \"$count\" -lt \"$add_tx_nr\" ]; }; then\n\t\tfail_test \"got $count ADD_ADDR[s] TX, expected $add_tx_nr\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"echo TX\"\n\tcount=$(get_counter ${ns2} \"MPTcpExtEchoAddTx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$echo_tx_nr\" ]; then\n\t\tfail_test \"got $count ADD_ADDR echo[s] TX, expected $echo_tx_nr\"\n\telse\n\t\tprint_ok\n\tfi\n}\n\nchk_rm_nr()\n{\n\tlocal rm_addr_nr=$1\n\tlocal rm_subflow_nr=$2\n\tlocal invert\n\tlocal simult\n\tlocal count\n\tlocal addr_ns=$ns1\n\tlocal subflow_ns=$ns2\n\tlocal extra_msg=\"\"\n\n\tshift 2\n\twhile [ -n \"$1\" ]; do\n\t\t[ \"$1\" = \"invert\" ] && invert=true\n\t\t[ \"$1\" = \"simult\" ] && simult=true\n\t\tshift\n\tdone\n\n\tif [ -z $invert ]; then\n\t\taddr_ns=$ns1\n\t\tsubflow_ns=$ns2\n\telif [ $invert = \"true\" ]; then\n\t\taddr_ns=$ns2\n\t\tsubflow_ns=$ns1\n\t\textra_msg=\"invert\"\n\tfi\n\n\tprint_check \"rm\"\n\tcount=$(get_counter ${addr_ns} \"MPTcpExtRmAddr\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$rm_addr_nr\" ]; then\n\t\tfail_test \"got $count RM_ADDR[s] expected $rm_addr_nr\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"rmsf\"\n\tcount=$(get_counter ${subflow_ns} \"MPTcpExtRmSubflow\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ -n \"$simult\" ]; then\n\t\tlocal cnt suffix\n\n\t\tcnt=$(get_counter ${addr_ns} \"MPTcpExtRmSubflow\")\n\n\t\t# in case of simult flush, the subflow removal count on each side is\n\t\t# unreliable\n\t\tcount=$((count + cnt))\n\t\t[ \"$count\" != \"$rm_subflow_nr\" ] && suffix=\"$count in [$rm_subflow_nr:$((rm_subflow_nr*2))]\"\n\t\tif [ $count -ge \"$rm_subflow_nr\" ] && \\\n\t\t   [ \"$count\" -le \"$((rm_subflow_nr *2 ))\" ]; then\n\t\t\tprint_ok \"$suffix\"\n\t\telse\n\t\t\tfail_test \"got $count RM_SUBFLOW[s] expected in range [$rm_subflow_nr:$((rm_subflow_nr*2))]\"\n\t\tfi\n\telif [ \"$count\" != \"$rm_subflow_nr\" ]; then\n\t\tfail_test \"got $count RM_SUBFLOW[s] expected $rm_subflow_nr\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_info \"$extra_msg\"\n}\n\nchk_rm_tx_nr()\n{\n\tlocal rm_addr_tx_nr=$1\n\n\tprint_check \"rm TX\"\n\tcount=$(get_counter ${ns2} \"MPTcpExtRmAddrTx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$rm_addr_tx_nr\" ]; then\n\t\tfail_test \"got $count RM_ADDR[s] expected $rm_addr_tx_nr\"\n\telse\n\t\tprint_ok\n\tfi\n}\n\nchk_prio_nr()\n{\n\tlocal mp_prio_nr_tx=$1\n\tlocal mp_prio_nr_rx=$2\n\tlocal count\n\n\tprint_check \"ptx\"\n\tcount=$(get_counter ${ns1} \"MPTcpExtMPPrioTx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$mp_prio_nr_tx\" ]; then\n\t\tfail_test \"got $count MP_PRIO[s] TX expected $mp_prio_nr_tx\"\n\telse\n\t\tprint_ok\n\tfi\n\n\tprint_check \"prx\"\n\tcount=$(get_counter ${ns1} \"MPTcpExtMPPrioRx\")\n\tif [ -z \"$count\" ]; then\n\t\tprint_skip\n\telif [ \"$count\" != \"$mp_prio_nr_rx\" ]; then\n\t\tfail_test \"got $count MP_PRIO[s] RX expected $mp_prio_nr_rx\"\n\telse\n\t\tprint_ok\n\tfi\n}\n\nchk_subflow_nr()\n{\n\tlocal msg=\"$1\"\n\tlocal subflow_nr=$2\n\tlocal cnt1\n\tlocal cnt2\n\tlocal dump_stats\n\n\tprint_check \"${msg}\"\n\n\tcnt1=$(ss -N $ns1 -tOni | grep -c token)\n\tcnt2=$(ss -N $ns2 -tOni | grep -c token)\n\tif [ \"$cnt1\" != \"$subflow_nr\" ] || [ \"$cnt2\" != \"$subflow_nr\" ]; then\n\t\tfail_test \"got $cnt1:$cnt2 subflows expected $subflow_nr\"\n\t\tdump_stats=1\n\telse\n\t\tprint_ok\n\tfi\n\n\tif [ \"${dump_stats}\" = 1 ]; then\n\t\tss -N $ns1 -tOni\n\t\tss -N $ns1 -tOni | grep token\n\t\tip -n $ns1 mptcp endpoint\n\tfi\n}\n\nchk_mptcp_info()\n{\n\tlocal info1=$1\n\tlocal exp1=$2\n\tlocal info2=$3\n\tlocal exp2=$4\n\tlocal cnt1\n\tlocal cnt2\n\tlocal dump_stats\n\n\tprint_check \"mptcp_info ${info1:0:8}=$exp1:$exp2\"\n\n\tcnt1=$(ss -N $ns1 -inmHM | grep \"$info1:\" |\n\t       sed -n 's/.*\\('\"$info1\"':\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\tcnt2=$(ss -N $ns2 -inmHM | grep \"$info2:\" |\n\t       sed -n 's/.*\\('\"$info2\"':\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\t# 'ss' only display active connections and counters that are not 0.\n\t[ -z \"$cnt1\" ] && cnt1=0\n\t[ -z \"$cnt2\" ] && cnt2=0\n\n\tif [ \"$cnt1\" != \"$exp1\" ] || [ \"$cnt2\" != \"$exp2\" ]; then\n\t\tfail_test \"got $cnt1:$cnt2 $info1:$info2 expected $exp1:$exp2\"\n\t\tdump_stats=1\n\telse\n\t\tprint_ok\n\tfi\n\n\tif [ \"$dump_stats\" = 1 ]; then\n\t\tss -N $ns1 -inmHM\n\t\tss -N $ns2 -inmHM\n\tfi\n}\n\nchk_link_usage()\n{\n\tlocal ns=$1\n\tlocal link=$2\n\tlocal out=$3\n\tlocal expected_rate=$4\n\n\tlocal tx_link tx_total\n\ttx_link=$(ip netns exec $ns cat /sys/class/net/$link/statistics/tx_bytes)\n\ttx_total=$(stat --format=%s $out)\n\tlocal tx_rate=$((tx_link * 100 / tx_total))\n\tlocal tolerance=5\n\n\tprint_check \"link usage\"\n\tif [ $tx_rate -lt $((expected_rate - tolerance)) ] || \\\n\t   [ $tx_rate -gt $((expected_rate + tolerance)) ]; then\n\t\tfail_test \"got $tx_rate% usage, expected $expected_rate%\"\n\telse\n\t\tprint_ok\n\tfi\n}\n\nwait_attempt_fail()\n{\n\tlocal timeout_ms=$((timeout_poll * 1000))\n\tlocal time=0\n\tlocal ns=$1\n\n\twhile [ $time -lt $timeout_ms ]; do\n\t\tlocal cnt\n\n\t\tcnt=$(get_counter ${ns} \"TcpAttemptFails\")\n\n\t\t[ \"$cnt\" = 1 ] && return 1\n\t\ttime=$((time + 100))\n\t\tsleep 0.1\n\tdone\n\treturn 1\n}\n\nset_userspace_pm()\n{\n\tlocal ns=$1\n\n\tip netns exec $ns sysctl -q net.mptcp.pm_type=1\n}\n\nsubflows_tests()\n{\n\tif reset \"no JOIN\"; then\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# subflow limited by client\n\tif reset \"single subflow, limited by client\"; then\n\t\tpm_nl_set_limits $ns1 0 0\n\t\tpm_nl_set_limits $ns2 0 0\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# subflow limited by server\n\tif reset \"single subflow, limited by server\"; then\n\t\tpm_nl_set_limits $ns1 0 0\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 0\n\tfi\n\n\t# subflow\n\tif reset \"single subflow\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# multiple subflows\n\tif reset \"multiple subflows\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 0 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\tfi\n\n\t# multiple subflows limited by server\n\tif reset \"multiple subflows, limited by server\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 1\n\tfi\n\n\t# single subflow, dev\n\tif reset \"single subflow, dev\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow dev ns2eth3\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\tfi\n}\n\nsubflows_error_tests()\n{\n\t# If a single subflow is configured, and matches the MPC src\n\t# address, no additional subflow should be created\n\tif reset \"no MPC reuse with single endpoint\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.1.2 flags subflow\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# multiple subflows, with subflow creation error\n\tif reset_with_tcp_filter \"multi subflows, with failing subflow\" ns1 10.0.3.2 REJECT &&\n\t   continue_if mptcp_lib_kallsyms_has \"mptcp_pm_subflow_check_next$\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 0 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# multiple subflows, with subflow timeout on MPJ\n\tif reset_with_tcp_filter \"multi subflows, with subflow timeout\" ns1 10.0.3.2 DROP &&\n\t   continue_if mptcp_lib_kallsyms_has \"mptcp_pm_subflow_check_next$\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 0 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# multiple subflows, check that the endpoint corresponding to\n\t# closed subflow (due to reset) is not reused if additional\n\t# subflows are added later\n\tif reset_with_tcp_filter \"multi subflows, fair usage on close\" ns1 10.0.3.2 REJECT &&\n\t   continue_if mptcp_lib_kallsyms_has \"mptcp_pm_subflow_check_next$\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1 &\n\n\t\t# mpj subflow will be in TW after the reset\n\t\twait_attempt_fail $ns2\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow\n\t\twait\n\n\t\t# additional subflow could be created only if the PM select\n\t\t# the later endpoint, skipping the already used one\n\t\tchk_join_nr 1 1 1\n\tfi\n}\n\nsignal_address_tests()\n{\n\t# add_address, unused\n\tif reset \"unused signal address\"; then\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\t\tchk_add_tx_nr 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# accept and use add_addr\n\tif reset \"signal address\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# accept and use add_addr with an additional subflow\n\t# note: signal address in server ns and local addresses in client ns must\n\t# belong to different subnets or one of the listed local address could be\n\t# used for 'add_addr' subflow\n\tif reset \"subflow and signal\"; then\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 1 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# accept and use add_addr with additional subflows\n\tif reset \"multiple subflows and signal\"; then\n\t\tpm_nl_set_limits $ns1 0 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns2 1 3\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.4.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# signal addresses\n\tif reset \"signal addresses\"; then\n\t\tpm_nl_set_limits $ns1 3 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.4.1 flags signal\n\t\tpm_nl_set_limits $ns2 3 3\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 3 3\n\tfi\n\n\t# signal invalid addresses\n\tif reset \"signal invalid addresses\"; then\n\t\tpm_nl_set_limits $ns1 3 3\n\t\tpm_nl_add_endpoint $ns1 10.0.12.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.14.1 flags signal\n\t\tpm_nl_set_limits $ns2 3 3\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 3 3\n\tfi\n\n\t# signal addresses race test\n\tif reset \"signal addresses race test\"; then\n\t\tpm_nl_set_limits $ns1 4 4\n\t\tpm_nl_set_limits $ns2 4 4\n\t\tpm_nl_add_endpoint $ns1 10.0.1.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.4.1 flags signal\n\t\tpm_nl_add_endpoint $ns2 10.0.1.2 flags signal\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags signal\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags signal\n\t\tpm_nl_add_endpoint $ns2 10.0.4.2 flags signal\n\n\t\t# the peer could possibly miss some addr notification, allow retransmission\n\t\tip netns exec $ns1 sysctl -q net.mptcp.add_addr_timeout=1\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\n\t\t# It is not directly linked to the commit introducing this\n\t\t# symbol but for the parent one which is linked anyway.\n\t\tif ! mptcp_lib_kallsyms_has \"mptcp_pm_subflow_check_next$\"; then\n\t\t\tchk_join_nr 3 3 2\n\t\t\tchk_add_nr 4 4\n\t\telse\n\t\t\tchk_join_nr 3 3 3\n\t\t\t# the server will not signal the address terminating\n\t\t\t# the MPC subflow\n\t\t\tchk_add_nr 3 3\n\t\tfi\n\tfi\n}\n\nlink_failure_tests()\n{\n\t# accept and use add_addr with additional subflows and link loss\n\tif reset \"multiple flows, signal, link failure\"; then\n\t\t# without any b/w limit each veth could spool the packets and get\n\t\t# them acked at xmit time, so that the corresponding subflow will\n\t\t# have almost always no outstanding pkts, the scheduler will pick\n\t\t# always the first subflow and we will have hard time testing\n\t\t# active backup and link switch-over.\n\t\t# Let's set some arbitrary (low) virtual link limits.\n\t\tinit_shapers\n\t\tpm_nl_set_limits $ns1 0 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 dev ns1eth2 flags signal\n\t\tpm_nl_set_limits $ns2 1 3\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 dev ns2eth3 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.4.2 dev ns2eth4 flags subflow\n\t\ttest_linkfail=1 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 1 1\n\t\tchk_stale_nr $ns2 1 5 1\n\tfi\n\n\t# accept and use add_addr with additional subflows and link loss\n\t# for bidirectional transfer\n\tif reset \"multi flows, signal, bidi, link fail\"; then\n\t\tinit_shapers\n\t\tpm_nl_set_limits $ns1 0 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 dev ns1eth2 flags signal\n\t\tpm_nl_set_limits $ns2 1 3\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 dev ns2eth3 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.4.2 dev ns2eth4 flags subflow\n\t\ttest_linkfail=2 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 1 1\n\t\tchk_stale_nr $ns2 1 -1 1\n\tfi\n\n\t# 2 subflows plus 1 backup subflow with a lossy link, backup\n\t# will never be used\n\tif reset \"backup subflow unused, link failure\"; then\n\t\tinit_shapers\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 dev ns1eth2 flags signal\n\t\tpm_nl_set_limits $ns2 1 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 dev ns2eth3 flags subflow,backup\n\t\tFAILING_LINKS=\"1\" test_linkfail=1 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 1 1\n\t\tchk_link_usage $ns2 ns2eth3 $cinsent 0\n\tfi\n\n\t# 2 lossy links after half transfer, backup will get half of\n\t# the traffic\n\tif reset \"backup flow used, multi links fail\"; then\n\t\tinit_shapers\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 dev ns1eth2 flags signal\n\t\tpm_nl_set_limits $ns2 1 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 dev ns2eth3 flags subflow,backup\n\t\tFAILING_LINKS=\"1 2\" test_linkfail=1 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 1 1\n\t\tchk_stale_nr $ns2 2 4 2\n\t\tchk_link_usage $ns2 ns2eth3 $cinsent 50\n\tfi\n\n\t# use a backup subflow with the first subflow on a lossy link\n\t# for bidirectional transfer\n\tif reset \"backup flow used, bidi, link failure\"; then\n\t\tinit_shapers\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 dev ns1eth2 flags signal\n\t\tpm_nl_set_limits $ns2 1 3\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 dev ns2eth3 flags subflow,backup\n\t\tFAILING_LINKS=\"1 2\" test_linkfail=2 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 1 1\n\t\tchk_stale_nr $ns2 1 -1 2\n\t\tchk_link_usage $ns2 ns2eth3 $cinsent 50\n\tfi\n}\n\nadd_addr_timeout_tests()\n{\n\t# add_addr timeout\n\tif reset_with_add_addr_timeout \"signal address, ADD_ADDR timeout\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_tx_nr 4 4\n\t\tchk_add_nr 4 0\n\tfi\n\n\t# add_addr timeout IPv6\n\tif reset_with_add_addr_timeout \"signal address, ADD_ADDR6 timeout\" 6; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 dead:beef:2::1 flags signal\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 4 0\n\tfi\n\n\t# signal addresses timeout\n\tif reset_with_add_addr_timeout \"signal addresses, ADD_ADDR timeout\"; then\n\t\tpm_nl_set_limits $ns1 2 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal\n\t\tpm_nl_set_limits $ns2 2 2\n\t\tspeed=10 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 8 0\n\tfi\n\n\t# signal invalid addresses timeout\n\tif reset_with_add_addr_timeout \"invalid address, ADD_ADDR timeout\"; then\n\t\tpm_nl_set_limits $ns1 2 2\n\t\tpm_nl_add_endpoint $ns1 10.0.12.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal\n\t\tpm_nl_set_limits $ns2 2 2\n\t\tspeed=10 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 8 0\n\tfi\n}\n\nremove_tests()\n{\n\t# single subflow, remove\n\tif reset \"remove single subflow\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\taddr_nr_ns2=-1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_rm_tx_nr 1\n\t\tchk_rm_nr 1 1\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# multiple subflows, remove\n\tif reset \"remove multiple subflows\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 0 2\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\taddr_nr_ns2=-2 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_rm_nr 2 2\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# single address, remove\n\tif reset \"remove single address\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns2 1 1\n\t\taddr_nr_ns1=-1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\t\tchk_rm_nr 1 1 invert\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# subflow and signal, remove\n\tif reset \"remove subflow and signal\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns2 1 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\taddr_nr_ns1=-1 addr_nr_ns2=-1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 1 1\n\t\tchk_rm_nr 1 1\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# subflows and signal, remove\n\tif reset \"remove subflows and signal\"; then\n\t\tpm_nl_set_limits $ns1 0 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns2 1 3\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.4.2 flags subflow\n\t\taddr_nr_ns1=-1 addr_nr_ns2=-2 speed=10 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 1 1\n\t\tchk_rm_nr 2 2\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# addresses remove\n\tif reset \"remove addresses\"; then\n\t\tpm_nl_set_limits $ns1 3 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal id 250\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.4.1 flags signal\n\t\tpm_nl_set_limits $ns2 3 3\n\t\taddr_nr_ns1=-3 speed=10 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 3 3\n\t\tchk_rm_nr 3 3 invert\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# invalid addresses remove\n\tif reset \"remove invalid addresses\"; then\n\t\tpm_nl_set_limits $ns1 3 3\n\t\tpm_nl_add_endpoint $ns1 10.0.12.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.14.1 flags signal\n\t\tpm_nl_set_limits $ns2 3 3\n\t\taddr_nr_ns1=-3 speed=10 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 3 3\n\t\tchk_rm_nr 3 1 invert\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# subflows and signal, flush\n\tif reset \"flush subflows and signal\"; then\n\t\tpm_nl_set_limits $ns1 0 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns2 1 3\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.4.2 flags subflow\n\t\taddr_nr_ns1=-8 addr_nr_ns2=-8 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 1 1\n\t\tchk_rm_nr 1 3 invert simult\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# subflows flush\n\tif reset \"flush subflows\"; then\n\t\tpm_nl_set_limits $ns1 3 3\n\t\tpm_nl_set_limits $ns2 3 3\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow id 150\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.4.2 flags subflow\n\t\taddr_nr_ns1=-8 addr_nr_ns2=-8 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\n\t\tif mptcp_lib_kversion_ge 5.18; then\n\t\t\tchk_rm_tx_nr 0\n\t\t\tchk_rm_nr 0 3 simult\n\t\telse\n\t\t\tchk_rm_nr 3 3\n\t\tfi\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# addresses flush\n\tif reset \"flush addresses\"; then\n\t\tpm_nl_set_limits $ns1 3 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal id 250\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.4.1 flags signal\n\t\tpm_nl_set_limits $ns2 3 3\n\t\taddr_nr_ns1=-8 addr_nr_ns2=-8 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 3 3\n\t\tchk_rm_nr 3 3 invert simult\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# invalid addresses flush\n\tif reset \"flush invalid addresses\"; then\n\t\tpm_nl_set_limits $ns1 3 3\n\t\tpm_nl_add_endpoint $ns1 10.0.12.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 10.0.14.1 flags signal\n\t\tpm_nl_set_limits $ns2 3 3\n\t\taddr_nr_ns1=-8 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 3 3\n\t\tchk_rm_nr 3 1 invert\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# remove id 0 subflow\n\tif reset \"remove id 0 subflow\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\taddr_nr_ns2=-9 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_rm_nr 1 1\n\t\tchk_rst_nr 0 0\n\tfi\n\n\t# remove id 0 address\n\tif reset \"remove id 0 address\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns2 1 1\n\t\taddr_nr_ns1=-9 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\t\tchk_rm_nr 1 1 invert\n\t\tchk_rst_nr 0 0 invert\n\tfi\n}\n\nadd_tests()\n{\n\t# add single subflow\n\tif reset \"add single subflow\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\taddr_nr_ns2=1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# add signal address\n\tif reset \"add signal address\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\taddr_nr_ns1=1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# add multiple subflows\n\tif reset \"add multiple subflows\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 0 2\n\t\taddr_nr_ns2=2 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\tfi\n\n\t# add multiple subflows IPv6\n\tif reset \"add multiple subflows IPv6\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 0 2\n\t\taddr_nr_ns2=2 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 2 2 2\n\tfi\n\n\t# add multiple addresses IPv6\n\tif reset \"add multiple addresses IPv6\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 2 2\n\t\taddr_nr_ns1=2 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 2 2\n\tfi\n}\n\nipv6_tests()\n{\n\t# subflow IPv6\n\tif reset \"single subflow IPv6\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 dead:beef:3::2 dev ns2eth3 flags subflow\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# add_address, unused IPv6\n\tif reset \"unused signal address IPv6\"; then\n\t\tpm_nl_add_endpoint $ns1 dead:beef:2::1 flags signal\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 0 0 0\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# signal address IPv6\n\tif reset \"single address IPv6\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_add_endpoint $ns1 dead:beef:2::1 flags signal\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# single address IPv6, remove\n\tif reset \"remove single address IPv6\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_add_endpoint $ns1 dead:beef:2::1 flags signal\n\t\tpm_nl_set_limits $ns2 1 1\n\t\taddr_nr_ns1=-1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\t\tchk_rm_nr 1 1 invert\n\tfi\n\n\t# subflow and signal IPv6, remove\n\tif reset \"remove subflow and signal IPv6\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_add_endpoint $ns1 dead:beef:2::1 flags signal\n\t\tpm_nl_set_limits $ns2 1 2\n\t\tpm_nl_add_endpoint $ns2 dead:beef:3::2 dev ns2eth3 flags subflow\n\t\taddr_nr_ns1=-1 addr_nr_ns2=-1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 1 1\n\t\tchk_rm_nr 1 1\n\tfi\n}\n\nv4mapped_tests()\n{\n\t# subflow IPv4-mapped to IPv4-mapped\n\tif reset \"single subflow IPv4-mapped\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 \"::ffff:10.0.3.2\" flags subflow\n\t\trun_tests $ns1 $ns2 \"::ffff:10.0.1.1\"\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# signal address IPv4-mapped with IPv4-mapped sk\n\tif reset \"signal address IPv4-mapped\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 \"::ffff:10.0.2.1\" flags signal\n\t\trun_tests $ns1 $ns2 \"::ffff:10.0.1.1\"\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# subflow v4-map-v6\n\tif reset \"single subflow v4-map-v6\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 \"::ffff:10.0.1.1\"\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# signal address v4-map-v6\n\tif reset \"signal address v4-map-v6\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\trun_tests $ns1 $ns2 \"::ffff:10.0.1.1\"\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# subflow v6-map-v4\n\tif reset \"single subflow v6-map-v4\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 \"::ffff:10.0.3.2\" flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# signal address v6-map-v4\n\tif reset \"signal address v6-map-v4\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 \"::ffff:10.0.2.1\" flags signal\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# no subflow IPv6 to v4 address\n\tif reset \"no JOIN with diff families v4-v6\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 dead:beef:2::2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# no subflow IPv6 to v4 address even if v6 has a valid v4 at the end\n\tif reset \"no JOIN with diff families v4-v6-2\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 dead:beef:2::10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# no subflow IPv4 to v6 address, no need to slow down too then\n\tif reset \"no JOIN with diff families v6-v4\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 0 0 0\n\tfi\n}\n\nmixed_tests()\n{\n\tif reset \"IPv4 sockets do not use IPv6 addresses\" &&\n\t   continue_if mptcp_lib_kversion_ge 6.3; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 dead:beef:2::1 flags signal\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# Need an IPv6 mptcp socket to allow subflows of both families\n\tif reset \"simult IPv4 and IPv6 subflows\" &&\n\t   continue_if mptcp_lib_kversion_ge 6.3; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 10.0.1.1 flags signal\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:2::1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# cross families subflows will not be created even in fullmesh mode\n\tif reset \"simult IPv4 and IPv6 subflows, fullmesh 1x1\" &&\n\t   continue_if mptcp_lib_kversion_ge 6.3; then\n\t\tpm_nl_set_limits $ns1 0 4\n\t\tpm_nl_set_limits $ns2 1 4\n\t\tpm_nl_add_endpoint $ns2 dead:beef:2::2 flags subflow,fullmesh\n\t\tpm_nl_add_endpoint $ns1 10.0.1.1 flags signal\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:2::1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# fullmesh still tries to create all the possibly subflows with\n\t# matching family\n\tif reset \"simult IPv4 and IPv6 subflows, fullmesh 2x2\" &&\n\t   continue_if mptcp_lib_kversion_ge 6.3; then\n\t\tpm_nl_set_limits $ns1 0 4\n\t\tpm_nl_set_limits $ns2 2 4\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_add_endpoint $ns1 dead:beef:2::1 flags signal\n\t\tfullmesh=1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 dead:beef:1::1\n\t\tchk_join_nr 4 4 4\n\tfi\n}\n\nbackup_tests()\n{\n\t# single subflow, backup\n\tif reset \"single subflow, backup\" &&\n\t   continue_if mptcp_lib_kallsyms_has \"subflow_rebuild_header$\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow,backup\n\t\tsflags=nobackup speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_prio_nr 0 1\n\tfi\n\n\t# single address, backup\n\tif reset \"single address, backup\" &&\n\t   continue_if mptcp_lib_kallsyms_has \"subflow_rebuild_header$\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tsflags=backup speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\t\tchk_prio_nr 1 1\n\tfi\n\n\t# single address with port, backup\n\tif reset \"single address with port, backup\" &&\n\t   continue_if mptcp_lib_kallsyms_has \"subflow_rebuild_header$\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal port 10100\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tsflags=backup speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\t\tchk_prio_nr 1 1\n\tfi\n\n\tif reset \"mpc backup\" &&\n\t   continue_if mptcp_lib_kallsyms_doesnt_have \"T mptcp_subflow_send_ack$\"; then\n\t\tpm_nl_add_endpoint $ns2 10.0.1.2 flags subflow,backup\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\t\tchk_prio_nr 0 1\n\tfi\n\n\tif reset \"mpc backup both sides\" &&\n\t   continue_if mptcp_lib_kallsyms_doesnt_have \"T mptcp_subflow_send_ack$\"; then\n\t\tpm_nl_add_endpoint $ns1 10.0.1.1 flags subflow,backup\n\t\tpm_nl_add_endpoint $ns2 10.0.1.2 flags subflow,backup\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\t\tchk_prio_nr 1 1\n\tfi\n\n\tif reset \"mpc switch to backup\" &&\n\t   continue_if mptcp_lib_kallsyms_doesnt_have \"T mptcp_subflow_send_ack$\"; then\n\t\tpm_nl_add_endpoint $ns2 10.0.1.2 flags subflow\n\t\tsflags=backup speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\t\tchk_prio_nr 0 1\n\tfi\n\n\tif reset \"mpc switch to backup both sides\" &&\n\t   continue_if mptcp_lib_kallsyms_doesnt_have \"T mptcp_subflow_send_ack$\"; then\n\t\tpm_nl_add_endpoint $ns1 10.0.1.1 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.1.2 flags subflow\n\t\tsflags=backup speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\t\tchk_prio_nr 1 1\n\tfi\n}\n\nLISTENER_CREATED=15 #MPTCP_EVENT_LISTENER_CREATED\nLISTENER_CLOSED=16  #MPTCP_EVENT_LISTENER_CLOSED\n\nAF_INET=2\nAF_INET6=10\n\nverify_listener_events()\n{\n\tlocal evt=$1\n\tlocal e_type=$2\n\tlocal e_family=$3\n\tlocal e_saddr=$4\n\tlocal e_sport=$5\n\tlocal type\n\tlocal family\n\tlocal saddr\n\tlocal sport\n\tlocal name\n\n\tif [ $e_type = $LISTENER_CREATED ]; then\n\t\tname=\"LISTENER_CREATED\"\n\telif [ $e_type = $LISTENER_CLOSED ]; then\n\t\tname=\"LISTENER_CLOSED \"\n\telse\n\t\tname=\"$e_type\"\n\tfi\n\n\tprint_check \"$name $e_saddr:$e_sport\"\n\n\tif ! mptcp_lib_kallsyms_has \"mptcp_event_pm_listener$\"; then\n\t\tprint_skip \"event not supported\"\n\t\treturn\n\tfi\n\n\ttype=$(grep \"type:$e_type,\" $evt | sed -n 's/.*\\(type:\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\tfamily=$(grep \"type:$e_type,\" $evt | sed -n 's/.*\\(family:\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\tsport=$(grep \"type:$e_type,\" $evt | sed -n 's/.*\\(sport:\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\tif [ $family ] && [ $family = $AF_INET6 ]; then\n\t\tsaddr=$(grep \"type:$e_type,\" $evt | sed -n 's/.*\\(saddr6:\\)\\([0-9a-f:.]*\\).*$/\\2/p;q')\n\telse\n\t\tsaddr=$(grep \"type:$e_type,\" $evt | sed -n 's/.*\\(saddr4:\\)\\([0-9.]*\\).*$/\\2/p;q')\n\tfi\n\n\tif [ $type ] && [ $type = $e_type ] &&\n\t   [ $family ] && [ $family = $e_family ] &&\n\t   [ $saddr ] && [ $saddr = $e_saddr ] &&\n\t   [ $sport ] && [ $sport = $e_sport ]; then\n\t\tprint_ok\n\t\treturn 0\n\tfi\n\tfail_test \"$e_type:$type $e_family:$family $e_saddr:$saddr $e_sport:$sport\"\n}\n\nadd_addr_ports_tests()\n{\n\t# signal address with port\n\tif reset \"signal address with port\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal port 10100\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1 1\n\tfi\n\n\t# subflow and signal with port\n\tif reset \"subflow and signal with port\"; then\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal port 10100\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 1 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 1 1 1\n\tfi\n\n\t# single address with port, remove\n\t# pm listener events\n\tif reset_with_events \"remove single address with port\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal port 10100\n\t\tpm_nl_set_limits $ns2 1 1\n\t\taddr_nr_ns1=-1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1 1\n\t\tchk_rm_nr 1 1 invert\n\n\t\tverify_listener_events $evts_ns1 $LISTENER_CREATED $AF_INET 10.0.2.1 10100\n\t\tverify_listener_events $evts_ns1 $LISTENER_CLOSED $AF_INET 10.0.2.1 10100\n\t\tkill_events_pids\n\tfi\n\n\t# subflow and signal with port, remove\n\tif reset \"remove subflow and signal with port\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal port 10100\n\t\tpm_nl_set_limits $ns2 1 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\taddr_nr_ns1=-1 addr_nr_ns2=-1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 1 1 1\n\t\tchk_rm_nr 1 1\n\tfi\n\n\t# subflows and signal with port, flush\n\tif reset \"flush subflows and signal with port\"; then\n\t\tpm_nl_set_limits $ns1 0 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal port 10100\n\t\tpm_nl_set_limits $ns2 1 3\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.4.2 flags subflow\n\t\taddr_nr_ns1=-8 addr_nr_ns2=-2 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 1 1\n\t\tchk_rm_nr 1 3 invert simult\n\tfi\n\n\t# multiple addresses with port\n\tif reset \"multiple addresses with port\"; then\n\t\tpm_nl_set_limits $ns1 2 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal port 10100\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal port 10100\n\t\tpm_nl_set_limits $ns2 2 2\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 2 2 2\n\tfi\n\n\t# multiple addresses with ports\n\tif reset \"multiple addresses with ports\"; then\n\t\tpm_nl_set_limits $ns1 2 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal port 10100\n\t\tpm_nl_add_endpoint $ns1 10.0.3.1 flags signal port 10101\n\t\tpm_nl_set_limits $ns2 2 2\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 2 2 2\n\tfi\n}\n\nsyncookies_tests()\n{\n\t# single subflow, syncookies\n\tif reset_with_cookies \"single subflow with syn cookies\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# multiple subflows with syn cookies\n\tif reset_with_cookies \"multiple subflows with syn cookies\"; then\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 0 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\tfi\n\n\t# multiple subflows limited by server\n\tif reset_with_cookies \"subflows limited by server w cookies\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 1 1\n\tfi\n\n\t# test signal address with cookies\n\tif reset_with_cookies \"signal address with syn cookies\"; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# test cookie with subflow and signal\n\tif reset_with_cookies \"subflow and signal w cookies\"; then\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 1 2\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# accept and use add_addr with additional subflows\n\tif reset_with_cookies \"subflows and signal w. cookies\"; then\n\t\tpm_nl_set_limits $ns1 0 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_set_limits $ns2 1 3\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tpm_nl_add_endpoint $ns2 10.0.4.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 1 1\n\tfi\n}\n\nchecksum_tests()\n{\n\t# checksum test 0 0\n\tif reset_with_checksum 0 0; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# checksum test 1 1\n\tif reset_with_checksum 1 1; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# checksum test 0 1\n\tif reset_with_checksum 0 1; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# checksum test 1 0\n\tif reset_with_checksum 1 0; then\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n}\n\ndeny_join_id0_tests()\n{\n\t# subflow allow join id0 ns1\n\tif reset_with_allow_join_id0 \"single subflow allow join id0 ns1\" 1 0; then\n\t\tpm_nl_set_limits $ns1 1 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\tfi\n\n\t# subflow allow join id0 ns2\n\tif reset_with_allow_join_id0 \"single subflow allow join id0 ns2\" 0 1; then\n\t\tpm_nl_set_limits $ns1 1 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# signal address allow join id0 ns1\n\t# ADD_ADDRs are not affected by allow_join_id0 value.\n\tif reset_with_allow_join_id0 \"signal address allow join id0 ns1\" 1 0; then\n\t\tpm_nl_set_limits $ns1 1 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# signal address allow join id0 ns2\n\t# ADD_ADDRs are not affected by allow_join_id0 value.\n\tif reset_with_allow_join_id0 \"signal address allow join id0 ns2\" 0 1; then\n\t\tpm_nl_set_limits $ns1 1 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# subflow and address allow join id0 ns1\n\tif reset_with_allow_join_id0 \"subflow and address allow join id0 1\" 1 0; then\n\t\tpm_nl_set_limits $ns1 2 2\n\t\tpm_nl_set_limits $ns2 2 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\tfi\n\n\t# subflow and address allow join id0 ns2\n\tif reset_with_allow_join_id0 \"subflow and address allow join id0 2\" 0 1; then\n\t\tpm_nl_set_limits $ns1 2 2\n\t\tpm_nl_set_limits $ns2 2 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1\n\tfi\n}\n\nfullmesh_tests()\n{\n\t# fullmesh 1\n\t# 2 fullmesh addrs in ns2, added before the connection,\n\t# 1 non-fullmesh addr in ns1, added during the connection.\n\tif reset \"fullmesh test 2x1\"; then\n\t\tpm_nl_set_limits $ns1 0 4\n\t\tpm_nl_set_limits $ns2 1 4\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow,fullmesh\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow,fullmesh\n\t\taddr_nr_ns1=1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 4 4 4\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# fullmesh 2\n\t# 1 non-fullmesh addr in ns1, added before the connection,\n\t# 1 fullmesh addr in ns2, added during the connection.\n\tif reset \"fullmesh test 1x1\"; then\n\t\tpm_nl_set_limits $ns1 1 3\n\t\tpm_nl_set_limits $ns2 1 3\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tfullmesh=1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 3 3 3\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# fullmesh 3\n\t# 1 non-fullmesh addr in ns1, added before the connection,\n\t# 2 fullmesh addrs in ns2, added during the connection.\n\tif reset \"fullmesh test 1x2\"; then\n\t\tpm_nl_set_limits $ns1 2 5\n\t\tpm_nl_set_limits $ns2 1 5\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tfullmesh=2 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 5 5 5\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# fullmesh 4\n\t# 1 non-fullmesh addr in ns1, added before the connection,\n\t# 2 fullmesh addrs in ns2, added during the connection,\n\t# limit max_subflows to 4.\n\tif reset \"fullmesh test 1x2, limited\"; then\n\t\tpm_nl_set_limits $ns1 2 4\n\t\tpm_nl_set_limits $ns2 1 4\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tfullmesh=2 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 4 4 4\n\t\tchk_add_nr 1 1\n\tfi\n\n\t# set fullmesh flag\n\tif reset \"set fullmesh flag test\" &&\n\t   continue_if mptcp_lib_kversion_ge 5.18; then\n\t\tpm_nl_set_limits $ns1 4 4\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags subflow\n\t\tpm_nl_set_limits $ns2 4 4\n\t\taddr_nr_ns2=1 sflags=fullmesh speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_rm_nr 0 1\n\tfi\n\n\t# set nofullmesh flag\n\tif reset \"set nofullmesh flag test\" &&\n\t   continue_if mptcp_lib_kversion_ge 5.18; then\n\t\tpm_nl_set_limits $ns1 4 4\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags subflow,fullmesh\n\t\tpm_nl_set_limits $ns2 4 4\n\t\tfullmesh=1 sflags=nofullmesh speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_rm_nr 0 1\n\tfi\n\n\t# set backup,fullmesh flags\n\tif reset \"set backup,fullmesh flags test\" &&\n\t   continue_if mptcp_lib_kversion_ge 5.18; then\n\t\tpm_nl_set_limits $ns1 4 4\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags subflow\n\t\tpm_nl_set_limits $ns2 4 4\n\t\taddr_nr_ns2=1 sflags=backup,fullmesh speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_prio_nr 0 1\n\t\tchk_rm_nr 0 1\n\tfi\n\n\t# set nobackup,nofullmesh flags\n\tif reset \"set nobackup,nofullmesh flags test\" &&\n\t   continue_if mptcp_lib_kversion_ge 5.18; then\n\t\tpm_nl_set_limits $ns1 4 4\n\t\tpm_nl_set_limits $ns2 4 4\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags subflow,backup,fullmesh\n\t\tsflags=nobackup,nofullmesh speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 2 2 2\n\t\tchk_prio_nr 0 1\n\t\tchk_rm_nr 0 1\n\tfi\n}\n\nfastclose_tests()\n{\n\tif reset_check_counter \"fastclose test\" \"MPTcpExtMPFastcloseTx\"; then\n\t\ttest_linkfail=1024 fastclose=client \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\t\tchk_fclose_nr 1 1\n\t\tchk_rst_nr 1 1 invert\n\tfi\n\n\tif reset_check_counter \"fastclose server test\" \"MPTcpExtMPFastcloseRx\"; then\n\t\ttest_linkfail=1024 fastclose=server \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0 0 0 0 1\n\t\tchk_fclose_nr 1 1 invert\n\t\tchk_rst_nr 1 1\n\tfi\n}\n\npedit_action_pkts()\n{\n\ttc -n $ns2 -j -s action show action pedit index 100 | \\\n\t\tgrep \"packets\" | \\\n\t\tsed 's/.*\"packets\":\\([0-9]\\+\\),.*/\\1/'\n}\n\nfail_tests()\n{\n\t# single subflow\n\tif reset_with_fail \"Infinite map\" 1; then\n\t\ttest_linkfail=128 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0 +1 +0 1 0 1 \"$(pedit_action_pkts)\"\n\t\tchk_fail_nr 1 -1 invert\n\tfi\n\n\t# multiple subflows\n\tif reset_with_fail \"MP_FAIL MP_RST\" 2; then\n\t\ttc -n $ns2 qdisc add dev ns2eth1 root netem rate 1mbit delay 5\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 dev ns2eth2 flags subflow\n\t\ttest_linkfail=1024 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 1 1 0 1 1 0 \"$(pedit_action_pkts)\"\n\tfi\n}\n\nuserspace_pm_add_addr()\n{\n\tlocal addr=$1\n\tlocal id=$2\n\tlocal tk\n\n\ttk=$(grep \"type:1,\" \"$evts_ns1\" |\n\t     sed -n 's/.*\\(token:\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\tip netns exec $ns1 ./pm_nl_ctl ann $addr token $tk id $id\n\tsleep 1\n}\n\nuserspace_pm_rm_sf_addr_ns1()\n{\n\tlocal addr=$1\n\tlocal id=$2\n\tlocal tk sp da dp\n\tlocal cnt_addr cnt_sf\n\n\ttk=$(grep \"type:1,\" \"$evts_ns1\" |\n\t     sed -n 's/.*\\(token:\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\tsp=$(grep \"type:10\" \"$evts_ns1\" |\n\t     sed -n 's/.*\\(sport:\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\tda=$(grep \"type:10\" \"$evts_ns1\" |\n\t     sed -n 's/.*\\(daddr6:\\)\\([0-9a-f:.]*\\).*$/\\2/p;q')\n\tdp=$(grep \"type:10\" \"$evts_ns1\" |\n\t     sed -n 's/.*\\(dport:\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\tcnt_addr=$(rm_addr_count ${ns1})\n\tcnt_sf=$(rm_sf_count ${ns1})\n\tip netns exec $ns1 ./pm_nl_ctl rem token $tk id $id\n\tip netns exec $ns1 ./pm_nl_ctl dsf lip \"::ffff:$addr\" \\\n\t\t\t\tlport $sp rip $da rport $dp token $tk\n\twait_rm_addr $ns1 \"${cnt_addr}\"\n\twait_rm_sf $ns1 \"${cnt_sf}\"\n}\n\nuserspace_pm_add_sf()\n{\n\tlocal addr=$1\n\tlocal id=$2\n\tlocal tk da dp\n\n\ttk=$(sed -n 's/.*\\(token:\\)\\([[:digit:]]*\\).*$/\\2/p;q' \"$evts_ns2\")\n\tda=$(sed -n 's/.*\\(daddr4:\\)\\([0-9.]*\\).*$/\\2/p;q' \"$evts_ns2\")\n\tdp=$(sed -n 's/.*\\(dport:\\)\\([[:digit:]]*\\).*$/\\2/p;q' \"$evts_ns2\")\n\tip netns exec $ns2 ./pm_nl_ctl csf lip $addr lid $id \\\n\t\t\t\trip $da rport $dp token $tk\n\tsleep 1\n}\n\nuserspace_pm_rm_sf_addr_ns2()\n{\n\tlocal addr=$1\n\tlocal id=$2\n\tlocal tk da dp sp\n\tlocal cnt_addr cnt_sf\n\n\ttk=$(sed -n 's/.*\\(token:\\)\\([[:digit:]]*\\).*$/\\2/p;q' \"$evts_ns2\")\n\tda=$(sed -n 's/.*\\(daddr4:\\)\\([0-9.]*\\).*$/\\2/p;q' \"$evts_ns2\")\n\tdp=$(sed -n 's/.*\\(dport:\\)\\([[:digit:]]*\\).*$/\\2/p;q' \"$evts_ns2\")\n\tsp=$(grep \"type:10\" \"$evts_ns2\" |\n\t     sed -n 's/.*\\(sport:\\)\\([[:digit:]]*\\).*$/\\2/p;q')\n\tcnt_addr=$(rm_addr_count ${ns2})\n\tcnt_sf=$(rm_sf_count ${ns2})\n\tip netns exec $ns2 ./pm_nl_ctl rem token $tk id $id\n\tip netns exec $ns2 ./pm_nl_ctl dsf lip $addr lport $sp \\\n\t\t\t\trip $da rport $dp token $tk\n\twait_rm_addr $ns2 \"${cnt_addr}\"\n\twait_rm_sf $ns2 \"${cnt_sf}\"\n}\n\nuserspace_tests()\n{\n\t# userspace pm type prevents add_addr\n\tif reset \"userspace pm type prevents add_addr\" &&\n\t   continue_if mptcp_lib_has_file '/proc/sys/net/mptcp/pm_type'; then\n\t\tset_userspace_pm $ns1\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 0 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\t\tchk_add_nr 0 0\n\tfi\n\n\t# userspace pm type does not echo add_addr without daemon\n\tif reset \"userspace pm no echo w/o daemon\" &&\n\t   continue_if mptcp_lib_has_file '/proc/sys/net/mptcp/pm_type'; then\n\t\tset_userspace_pm $ns2\n\t\tpm_nl_set_limits $ns1 0 2\n\t\tpm_nl_set_limits $ns2 0 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\t\tchk_add_nr 1 0\n\tfi\n\n\t# userspace pm type rejects join\n\tif reset \"userspace pm type rejects join\" &&\n\t   continue_if mptcp_lib_has_file '/proc/sys/net/mptcp/pm_type'; then\n\t\tset_userspace_pm $ns1\n\t\tpm_nl_set_limits $ns1 1 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 0\n\tfi\n\n\t# userspace pm type does not send join\n\tif reset \"userspace pm type does not send join\" &&\n\t   continue_if mptcp_lib_has_file '/proc/sys/net/mptcp/pm_type'; then\n\t\tset_userspace_pm $ns2\n\t\tpm_nl_set_limits $ns1 1 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\tfi\n\n\t# userspace pm type prevents mp_prio\n\tif reset \"userspace pm type prevents mp_prio\" &&\n\t   continue_if mptcp_lib_has_file '/proc/sys/net/mptcp/pm_type'; then\n\t\tset_userspace_pm $ns1\n\t\tpm_nl_set_limits $ns1 1 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\tsflags=backup speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 1 1 0\n\t\tchk_prio_nr 0 0\n\tfi\n\n\t# userspace pm type prevents rm_addr\n\tif reset \"userspace pm type prevents rm_addr\" &&\n\t   continue_if mptcp_lib_has_file '/proc/sys/net/mptcp/pm_type'; then\n\t\tset_userspace_pm $ns1\n\t\tset_userspace_pm $ns2\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tpm_nl_set_limits $ns2 0 1\n\t\tpm_nl_add_endpoint $ns2 10.0.3.2 flags subflow\n\t\taddr_nr_ns2=-1 speed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1\n\t\tchk_join_nr 0 0 0\n\t\tchk_rm_nr 0 0\n\tfi\n\n\t# userspace pm add & remove address\n\tif reset_with_events \"userspace pm add & remove address\" &&\n\t   continue_if mptcp_lib_has_file '/proc/sys/net/mptcp/pm_type'; then\n\t\tset_userspace_pm $ns1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tspeed=5 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1 &\n\t\tlocal tests_pid=$!\n\t\twait_mpj $ns1\n\t\tuserspace_pm_add_addr 10.0.2.1 10\n\t\tchk_join_nr 1 1 1\n\t\tchk_add_nr 1 1\n\t\tchk_mptcp_info subflows 1 subflows 1\n\t\tchk_mptcp_info add_addr_signal 1 add_addr_accepted 1\n\t\tuserspace_pm_rm_sf_addr_ns1 10.0.2.1 10\n\t\tchk_rm_nr 1 1 invert\n\t\tchk_mptcp_info subflows 0 subflows 0\n\t\tkill_events_pids\n\t\twait $tests_pid\n\tfi\n\n\t# userspace pm create destroy subflow\n\tif reset_with_events \"userspace pm create destroy subflow\" &&\n\t   continue_if mptcp_lib_has_file '/proc/sys/net/mptcp/pm_type'; then\n\t\tset_userspace_pm $ns2\n\t\tpm_nl_set_limits $ns1 0 1\n\t\tspeed=5 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1 &\n\t\tlocal tests_pid=$!\n\t\twait_mpj $ns2\n\t\tuserspace_pm_add_sf 10.0.3.2 20\n\t\tchk_join_nr 1 1 1\n\t\tchk_mptcp_info subflows 1 subflows 1\n\t\tuserspace_pm_rm_sf_addr_ns2 10.0.3.2 20\n\t\tchk_rm_nr 1 1\n\t\tchk_mptcp_info subflows 0 subflows 0\n\t\tkill_events_pids\n\t\twait $tests_pid\n\tfi\n}\n\nendpoint_tests()\n{\n\t# subflow_rebuild_header is needed to support the implicit flag\n\t# userspace pm type prevents add_addr\n\tif reset \"implicit EP\" &&\n\t   mptcp_lib_kallsyms_has \"subflow_rebuild_header$\"; then\n\t\tpm_nl_set_limits $ns1 2 2\n\t\tpm_nl_set_limits $ns2 2 2\n\t\tpm_nl_add_endpoint $ns1 10.0.2.1 flags signal\n\t\tspeed=slow \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1 2>/dev/null &\n\n\t\twait_mpj $ns1\n\t\tpm_nl_check_endpoint \"creation\" \\\n\t\t\t$ns2 10.0.2.2 id 1 flags implicit\n\t\tchk_mptcp_info subflows 1 subflows 1\n\t\tchk_mptcp_info add_addr_signal 1 add_addr_accepted 1\n\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 id 33 2>/dev/null\n\t\tpm_nl_check_endpoint \"ID change is prevented\" \\\n\t\t\t$ns2 10.0.2.2 id 1 flags implicit\n\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 flags signal\n\t\tpm_nl_check_endpoint \"modif is allowed\" \\\n\t\t\t$ns2 10.0.2.2 id 1 flags signal\n\t\tkill_tests_wait\n\tfi\n\n\tif reset \"delete and re-add\" &&\n\t   mptcp_lib_kallsyms_has \"subflow_rebuild_header$\"; then\n\t\tpm_nl_set_limits $ns1 1 1\n\t\tpm_nl_set_limits $ns2 1 1\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 id 2 dev ns2eth2 flags subflow\n\t\ttest_linkfail=4 speed=20 \\\n\t\t\trun_tests $ns1 $ns2 10.0.1.1 2>/dev/null &\n\n\t\twait_mpj $ns2\n\t\tchk_subflow_nr \"before delete\" 2\n\t\tchk_mptcp_info subflows 1 subflows 1\n\n\t\tpm_nl_del_endpoint $ns2 2 10.0.2.2\n\t\tsleep 0.5\n\t\tchk_subflow_nr \"after delete\" 1\n\t\tchk_mptcp_info subflows 0 subflows 0\n\n\t\tpm_nl_add_endpoint $ns2 10.0.2.2 dev ns2eth2 flags subflow\n\t\twait_mpj $ns2\n\t\tchk_subflow_nr \"after re-add\" 2\n\t\tchk_mptcp_info subflows 1 subflows 1\n\t\tkill_tests_wait\n\tfi\n}\n\n# [$1: error message]\nusage()\n{\n\tif [ -n \"${1}\" ]; then\n\t\techo \"${1}\"\n\t\tret=1\n\tfi\n\n\techo \"mptcp_join usage:\"\n\n\tlocal key\n\tfor key in \"${!all_tests[@]}\"; do\n\t\techo \"  -${key} ${all_tests[${key}]}\"\n\tdone\n\n\techo \"  -c capture pcap files\"\n\techo \"  -C enable data checksum\"\n\techo \"  -i use ip mptcp\"\n\techo \"  -h help\"\n\n\techo \"[test ids|names]\"\n\n\texit ${ret}\n}\n\n\n# Use a \"simple\" array to force an specific order we cannot have with an associative one\nall_tests_sorted=(\n\tf@subflows_tests\n\te@subflows_error_tests\n\ts@signal_address_tests\n\tl@link_failure_tests\n\tt@add_addr_timeout_tests\n\tr@remove_tests\n\ta@add_tests\n\t6@ipv6_tests\n\t4@v4mapped_tests\n\tM@mixed_tests\n\tb@backup_tests\n\tp@add_addr_ports_tests\n\tk@syncookies_tests\n\tS@checksum_tests\n\td@deny_join_id0_tests\n\tm@fullmesh_tests\n\tz@fastclose_tests\n\tF@fail_tests\n\tu@userspace_tests\n\tI@endpoint_tests\n)\n\nall_tests_args=\"\"\nall_tests_names=()\nfor subtests in \"${all_tests_sorted[@]}\"; do\n\tkey=\"${subtests%@*}\"\n\tvalue=\"${subtests#*@}\"\n\n\tall_tests_args+=\"${key}\"\n\tall_tests_names+=(\"${value}\")\n\tall_tests[${key}]=\"${value}\"\ndone\n\ntests=()\nwhile getopts \"${all_tests_args}cCih\" opt; do\n\tcase $opt in\n\t\t[\"${all_tests_args}\"])\n\t\t\ttests+=(\"${all_tests[${opt}]}\")\n\t\t\t;;\n\t\tc)\n\t\t\tcapture=1\n\t\t\t;;\n\t\tC)\n\t\t\tchecksum=1\n\t\t\t;;\n\t\ti)\n\t\t\tip_mptcp=1\n\t\t\t;;\n\t\th)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tusage \"Unknown option: -${opt}\"\n\t\t\t;;\n\tesac\ndone\n\nshift $((OPTIND - 1))\n\nfor arg in \"${@}\"; do\n\tif [[ \"${arg}\" =~ ^[0-9]+$ ]]; then\n\t\tonly_tests_ids+=(\"${arg}\")\n\telse\n\t\tonly_tests_names+=(\"${arg}\")\n\tfi\ndone\n\nif [ ${#tests[@]} -eq 0 ]; then\n\ttests=(\"${all_tests_names[@]}\")\nfi\n\nfor subtests in \"${tests[@]}\"; do\n\t\"${subtests}\"\ndone\n\nif [ ${ret} -ne 0 ]; then\n\techo\n\techo \"${#failed_tests[@]} failure(s) has(ve) been detected:\"\n\tfor i in $(get_failed_tests_ids); do\n\t\techo -e \"\\t- ${i}: ${failed_tests[${i}]}\"\n\tdone\n\techo\nfi\n\nappend_prev_results\nmptcp_lib_result_print_all_tap\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}