{
  "module_name": "mptcp_sockopt.sh",
  "hash_id": "4cb2fe4130d311803930717e550064d2d23e90821302fb674ea792d5e6c587fa",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/mptcp/mptcp_sockopt.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n. \"$(dirname \"${0}\")/mptcp_lib.sh\"\n\nret=0\nsin=\"\"\nsout=\"\"\ncin=\"\"\ncout=\"\"\nksft_skip=4\ntimeout_poll=30\ntimeout_test=$((timeout_poll * 2 + 1))\nmptcp_connect=\"\"\niptables=\"iptables\"\nip6tables=\"ip6tables\"\n\nsec=$(date +%s)\nrndh=$(printf %x $sec)-$(mktemp -u XXXXXX)\nns1=\"ns1-$rndh\"\nns2=\"ns2-$rndh\"\nns_sbox=\"ns_sbox-$rndh\"\n\nadd_mark_rules()\n{\n\tlocal ns=$1\n\tlocal m=$2\n\n\tlocal t\n\tfor t in ${iptables} ${ip6tables}; do\n\t\t# just to debug: check we have multiple subflows connection requests\n\t\tip netns exec $ns $t -A OUTPUT -p tcp --syn -m mark --mark $m -j ACCEPT\n\n\t\t# RST packets might be handled by a internal dummy socket\n\t\tip netns exec $ns $t -A OUTPUT -p tcp --tcp-flags RST RST -m mark --mark 0 -j ACCEPT\n\n\t\tip netns exec $ns $t -A OUTPUT -p tcp -m mark --mark $m -j ACCEPT\n\t\tip netns exec $ns $t -A OUTPUT -p tcp -m mark --mark 0 -j DROP\n\tdone\n}\n\ninit()\n{\n\tlocal netns\n\tfor netns in \"$ns1\" \"$ns2\" \"$ns_sbox\";do\n\t\tip netns add $netns || exit $ksft_skip\n\t\tip -net $netns link set lo up\n\t\tip netns exec $netns sysctl -q net.mptcp.enabled=1\n\t\tip netns exec $netns sysctl -q net.ipv4.conf.all.rp_filter=0\n\t\tip netns exec $netns sysctl -q net.ipv4.conf.default.rp_filter=0\n\tdone\n\n\tlocal i\n\tfor i in `seq 1 4`; do\n\t\tip link add ns1eth$i netns \"$ns1\" type veth peer name ns2eth$i netns \"$ns2\"\n\t\tip -net \"$ns1\" addr add 10.0.$i.1/24 dev ns1eth$i\n\t\tip -net \"$ns1\" addr add dead:beef:$i::1/64 dev ns1eth$i nodad\n\t\tip -net \"$ns1\" link set ns1eth$i up\n\n\t\tip -net \"$ns2\" addr add 10.0.$i.2/24 dev ns2eth$i\n\t\tip -net \"$ns2\" addr add dead:beef:$i::2/64 dev ns2eth$i nodad\n\t\tip -net \"$ns2\" link set ns2eth$i up\n\n\t\t# let $ns2 reach any $ns1 address from any interface\n\t\tip -net \"$ns2\" route add default via 10.0.$i.1 dev ns2eth$i metric 10$i\n\n\t\tip netns exec $ns1 ./pm_nl_ctl add 10.0.$i.1 flags signal\n\t\tip netns exec $ns1 ./pm_nl_ctl add dead:beef:$i::1 flags signal\n\n\t\tip netns exec $ns2 ./pm_nl_ctl add 10.0.$i.2 flags signal\n\t\tip netns exec $ns2 ./pm_nl_ctl add dead:beef:$i::2 flags signal\n\tdone\n\n\tip netns exec $ns1 ./pm_nl_ctl limits 8 8\n\tip netns exec $ns2 ./pm_nl_ctl limits 8 8\n\n\tadd_mark_rules $ns1 1\n\tadd_mark_rules $ns2 2\n}\n\ncleanup()\n{\n\tlocal netns\n\tfor netns in \"$ns1\" \"$ns2\" \"$ns_sbox\"; do\n\t\tip netns del $netns\n\tdone\n\trm -f \"$cin\" \"$cout\"\n\trm -f \"$sin\" \"$sout\"\n}\n\nmptcp_lib_check_mptcp\nmptcp_lib_check_kallsyms\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\n# Use the legacy version if available to support old kernel versions\nif iptables-legacy -V &> /dev/null; then\n\tiptables=\"iptables-legacy\"\n\tip6tables=\"ip6tables-legacy\"\nelif ! iptables -V &> /dev/null; then\n\techo \"SKIP: Could not run all tests without iptables tool\"\n\texit $ksft_skip\nelif ! ip6tables -V &> /dev/null; then\n\techo \"SKIP: Could not run all tests without ip6tables tool\"\n\texit $ksft_skip\nfi\n\ncheck_mark()\n{\n\tlocal ns=$1\n\tlocal af=$2\n\n\tlocal tables=${iptables}\n\n\tif [ $af -eq 6 ];then\n\t\ttables=${ip6tables}\n\tfi\n\n\tlocal counters values\n\tcounters=$(ip netns exec $ns $tables -v -L OUTPUT | grep DROP)\n\tvalues=${counters%DROP*}\n\n\tlocal v\n\tfor v in $values; do\n\t\tif [ $v -ne 0 ]; then\n\t\t\techo \"FAIL: got $tables $values in ns $ns , not 0 - not all expected packets marked\" 1>&2\n\t\t\tret=1\n\t\t\treturn 1\n\t\tfi\n\tdone\n\n\treturn 0\n}\n\nprint_file_err()\n{\n\tls -l \"$1\" 1>&2\n\techo \"Trailing bytes are: \"\n\ttail -c 27 \"$1\"\n}\n\ncheck_transfer()\n{\n\tlocal in=$1\n\tlocal out=$2\n\tlocal what=$3\n\n\tcmp \"$in\" \"$out\" > /dev/null 2>&1\n\tif [ $? -ne 0 ] ;then\n\t\techo \"[ FAIL ] $what does not match (in, out):\"\n\t\tprint_file_err \"$in\"\n\t\tprint_file_err \"$out\"\n\t\tret=1\n\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\n# $1: IP address\nis_v6()\n{\n\t[ -z \"${1##*:*}\" ]\n}\n\ndo_transfer()\n{\n\tlocal listener_ns=\"$1\"\n\tlocal connector_ns=\"$2\"\n\tlocal cl_proto=\"$3\"\n\tlocal srv_proto=\"$4\"\n\tlocal connect_addr=\"$5\"\n\n\tlocal port=12001\n\n\t:> \"$cout\"\n\t:> \"$sout\"\n\n\tlocal mptcp_connect=\"./mptcp_connect -r 20\"\n\n\tlocal local_addr ip\n\tif is_v6 \"${connect_addr}\"; then\n\t\tlocal_addr=\"::\"\n\t\tip=ipv6\n\telse\n\t\tlocal_addr=\"0.0.0.0\"\n\t\tip=ipv4\n\tfi\n\n\tcmsg=\"TIMESTAMPNS\"\n\tif mptcp_lib_kallsyms_has \"mptcp_ioctl$\"; then\n\t\tcmsg+=\",TCPINQ\"\n\tfi\n\n\ttimeout ${timeout_test} \\\n\t\tip netns exec ${listener_ns} \\\n\t\t\t$mptcp_connect -t ${timeout_poll} -l -M 1 -p $port -s ${srv_proto} -c \"${cmsg}\" \\\n\t\t\t\t${local_addr} < \"$sin\" > \"$sout\" &\n\tlocal spid=$!\n\n\tsleep 1\n\n\ttimeout ${timeout_test} \\\n\t\tip netns exec ${connector_ns} \\\n\t\t\t$mptcp_connect -t ${timeout_poll} -M 2 -p $port -s ${cl_proto} -c \"${cmsg}\" \\\n\t\t\t\t$connect_addr < \"$cin\" > \"$cout\" &\n\n\tlocal cpid=$!\n\n\twait $cpid\n\tlocal retc=$?\n\twait $spid\n\tlocal rets=$?\n\n\tif [ ${rets} -ne 0 ] || [ ${retc} -ne 0 ]; then\n\t\techo \" client exit code $retc, server $rets\" 1>&2\n\t\techo -e \"\\nnetns ${listener_ns} socket stat for ${port}:\" 1>&2\n\t\tip netns exec ${listener_ns} ss -Menita 1>&2 -o \"sport = :$port\"\n\n\t\techo -e \"\\nnetns ${connector_ns} socket stat for ${port}:\" 1>&2\n\t\tip netns exec ${connector_ns} ss -Menita 1>&2 -o \"dport = :$port\"\n\n\t\tmptcp_lib_result_fail \"transfer ${ip}\"\n\n\t\tret=1\n\t\treturn 1\n\tfi\n\n\tif [ $local_addr = \"::\" ];then\n\t\tcheck_mark $listener_ns 6 || retc=1\n\t\tcheck_mark $connector_ns 6 || retc=1\n\telse\n\t\tcheck_mark $listener_ns 4 || retc=1\n\t\tcheck_mark $connector_ns 4 || retc=1\n\tfi\n\n\tcheck_transfer $cin $sout \"file received by server\"\n\trets=$?\n\n\tmptcp_lib_result_code \"${retc}\" \"mark ${ip}\"\n\tmptcp_lib_result_code \"${rets}\" \"transfer ${ip}\"\n\n\tif [ $retc -eq 0 ] && [ $rets -eq 0 ];then\n\t\treturn 0\n\tfi\n\n\treturn 1\n}\n\nmake_file()\n{\n\tlocal name=$1\n\tlocal who=$2\n\tlocal size=$3\n\n\tdd if=/dev/urandom of=\"$name\" bs=1024 count=$size 2> /dev/null\n\techo -e \"\\nMPTCP_TEST_FILE_END_MARKER\" >> \"$name\"\n\n\techo \"Created $name (size $size KB) containing data sent by $who\"\n}\n\ndo_mptcp_sockopt_tests()\n{\n\tlocal lret=0\n\n\tif ! mptcp_lib_kallsyms_has \"mptcp_diag_fill_info$\"; then\n\t\techo \"INFO: MPTCP sockopt not supported: SKIP\"\n\t\tmptcp_lib_result_skip \"sockopt\"\n\t\treturn\n\tfi\n\n\tip netns exec \"$ns_sbox\" ./mptcp_sockopt\n\tlret=$?\n\n\tif [ $lret -ne 0 ]; then\n\t\techo \"FAIL: SOL_MPTCP getsockopt\" 1>&2\n\t\tmptcp_lib_result_fail \"sockopt v4\"\n\t\tret=$lret\n\t\treturn\n\tfi\n\tmptcp_lib_result_pass \"sockopt v4\"\n\n\tip netns exec \"$ns_sbox\" ./mptcp_sockopt -6\n\tlret=$?\n\n\tif [ $lret -ne 0 ]; then\n\t\techo \"FAIL: SOL_MPTCP getsockopt (ipv6)\" 1>&2\n\t\tmptcp_lib_result_fail \"sockopt v6\"\n\t\tret=$lret\n\t\treturn\n\tfi\n\tmptcp_lib_result_pass \"sockopt v6\"\n}\n\nrun_tests()\n{\n\tlocal listener_ns=\"$1\"\n\tlocal connector_ns=\"$2\"\n\tlocal connect_addr=\"$3\"\n\tlocal lret=0\n\n\tdo_transfer ${listener_ns} ${connector_ns} MPTCP MPTCP ${connect_addr}\n\n\tlret=$?\n\n\tif [ $lret -ne 0 ]; then\n\t\tret=$lret\n\t\treturn\n\tfi\n}\n\ndo_tcpinq_test()\n{\n\tip netns exec \"$ns_sbox\" ./mptcp_inq \"$@\"\n\tlocal lret=$?\n\tif [ $lret -ne 0 ];then\n\t\tret=$lret\n\t\techo \"FAIL: mptcp_inq $@\" 1>&2\n\t\tmptcp_lib_result_fail \"TCP_INQ: $*\"\n\t\treturn $lret\n\tfi\n\n\techo \"PASS: TCP_INQ cmsg/ioctl $@\"\n\tmptcp_lib_result_pass \"TCP_INQ: $*\"\n\treturn $lret\n}\n\ndo_tcpinq_tests()\n{\n\tlocal lret=0\n\n\tif ! mptcp_lib_kallsyms_has \"mptcp_ioctl$\"; then\n\t\techo \"INFO: TCP_INQ not supported: SKIP\"\n\t\tmptcp_lib_result_skip \"TCP_INQ\"\n\t\treturn\n\tfi\n\n\tlocal args\n\tfor args in \"-t tcp\" \"-r tcp\"; do\n\t\tdo_tcpinq_test $args\n\t\tlret=$?\n\t\tif [ $lret -ne 0 ] ; then\n\t\t\treturn $lret\n\t\tfi\n\t\tdo_tcpinq_test -6 $args\n\t\tlret=$?\n\t\tif [ $lret -ne 0 ] ; then\n\t\t\treturn $lret\n\t\tfi\n\tdone\n\n\tdo_tcpinq_test -r tcp -t tcp\n\n\treturn $?\n}\n\nsin=$(mktemp)\nsout=$(mktemp)\ncin=$(mktemp)\ncout=$(mktemp)\ninit\nmake_file \"$cin\" \"client\" 1\nmake_file \"$sin\" \"server\" 1\ntrap cleanup EXIT\n\nrun_tests $ns1 $ns2 10.0.1.1\nrun_tests $ns1 $ns2 dead:beef:1::1\n\nif [ $ret -eq 0 ];then\n\techo \"PASS: all packets had packet mark set\"\nfi\n\ndo_mptcp_sockopt_tests\nif [ $ret -eq 0 ];then\n\techo \"PASS: SOL_MPTCP getsockopt has expected information\"\nfi\n\ndo_tcpinq_tests\n\nmptcp_lib_result_print_all_tap\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}