{
  "module_name": "simult_flows.sh",
  "hash_id": "264dfd73610a85fd929cad811690c051f18c4506127ac13d57f693840312fc96",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/mptcp/simult_flows.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n. \"$(dirname \"${0}\")/mptcp_lib.sh\"\n\nsec=$(date +%s)\nrndh=$(printf %x $sec)-$(mktemp -u XXXXXX)\nns1=\"ns1-$rndh\"\nns2=\"ns2-$rndh\"\nns3=\"ns3-$rndh\"\ncapture=false\nksft_skip=4\ntimeout_poll=30\ntimeout_test=$((timeout_poll * 2 + 1))\ntest_cnt=1\nret=0\nbail=0\nslack=50\n\nusage() {\n\techo \"Usage: $0 [ -b ] [ -c ] [ -d ]\"\n\techo -e \"\\t-b: bail out after first error, otherwise runs al testcases\"\n\techo -e \"\\t-c: capture packets for each test using tcpdump (default: no capture)\"\n\techo -e \"\\t-d: debug this script\"\n}\n\ncleanup()\n{\n\trm -f \"$cout\" \"$sout\"\n\trm -f \"$large\" \"$small\"\n\trm -f \"$capout\"\n\n\tlocal netns\n\tfor netns in \"$ns1\" \"$ns2\" \"$ns3\";do\n\t\tip netns del $netns\n\tdone\n}\n\nmptcp_lib_check_mptcp\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\n#  \"$ns1\"              ns2                    ns3\n#     ns1eth1    ns2eth1   ns2eth3      ns3eth1\n#            netem\n#     ns1eth2    ns2eth2\n#            netem\n\nsetup()\n{\n\tlarge=$(mktemp)\n\tsmall=$(mktemp)\n\tsout=$(mktemp)\n\tcout=$(mktemp)\n\tcapout=$(mktemp)\n\tsize=$((2 * 2048 * 4096))\n\n\tdd if=/dev/zero of=$small bs=4096 count=20 >/dev/null 2>&1\n\tdd if=/dev/zero of=$large bs=4096 count=$((size / 4096)) >/dev/null 2>&1\n\n\ttrap cleanup EXIT\n\n\tfor i in \"$ns1\" \"$ns2\" \"$ns3\";do\n\t\tip netns add $i || exit $ksft_skip\n\t\tip -net $i link set lo up\n\t\tip netns exec $i sysctl -q net.ipv4.conf.all.rp_filter=0\n\t\tip netns exec $i sysctl -q net.ipv4.conf.default.rp_filter=0\n\tdone\n\n\tip link add ns1eth1 netns \"$ns1\" type veth peer name ns2eth1 netns \"$ns2\"\n\tip link add ns1eth2 netns \"$ns1\" type veth peer name ns2eth2 netns \"$ns2\"\n\tip link add ns2eth3 netns \"$ns2\" type veth peer name ns3eth1 netns \"$ns3\"\n\n\tip -net \"$ns1\" addr add 10.0.1.1/24 dev ns1eth1\n\tip -net \"$ns1\" addr add dead:beef:1::1/64 dev ns1eth1 nodad\n\tip -net \"$ns1\" link set ns1eth1 up mtu 1500\n\tip -net \"$ns1\" route add default via 10.0.1.2\n\tip -net \"$ns1\" route add default via dead:beef:1::2\n\n\tip -net \"$ns1\" addr add 10.0.2.1/24 dev ns1eth2\n\tip -net \"$ns1\" addr add dead:beef:2::1/64 dev ns1eth2 nodad\n\tip -net \"$ns1\" link set ns1eth2 up mtu 1500\n\tip -net \"$ns1\" route add default via 10.0.2.2 metric 101\n\tip -net \"$ns1\" route add default via dead:beef:2::2 metric 101\n\n\tip netns exec \"$ns1\" ./pm_nl_ctl limits 1 1\n\tip netns exec \"$ns1\" ./pm_nl_ctl add 10.0.2.1 dev ns1eth2 flags subflow\n\n\tip -net \"$ns2\" addr add 10.0.1.2/24 dev ns2eth1\n\tip -net \"$ns2\" addr add dead:beef:1::2/64 dev ns2eth1 nodad\n\tip -net \"$ns2\" link set ns2eth1 up mtu 1500\n\n\tip -net \"$ns2\" addr add 10.0.2.2/24 dev ns2eth2\n\tip -net \"$ns2\" addr add dead:beef:2::2/64 dev ns2eth2 nodad\n\tip -net \"$ns2\" link set ns2eth2 up mtu 1500\n\n\tip -net \"$ns2\" addr add 10.0.3.2/24 dev ns2eth3\n\tip -net \"$ns2\" addr add dead:beef:3::2/64 dev ns2eth3 nodad\n\tip -net \"$ns2\" link set ns2eth3 up mtu 1500\n\tip netns exec \"$ns2\" sysctl -q net.ipv4.ip_forward=1\n\tip netns exec \"$ns2\" sysctl -q net.ipv6.conf.all.forwarding=1\n\n\tip -net \"$ns3\" addr add 10.0.3.3/24 dev ns3eth1\n\tip -net \"$ns3\" addr add dead:beef:3::3/64 dev ns3eth1 nodad\n\tip -net \"$ns3\" link set ns3eth1 up mtu 1500\n\tip -net \"$ns3\" route add default via 10.0.3.2\n\tip -net \"$ns3\" route add default via dead:beef:3::2\n\n\tip netns exec \"$ns3\" ./pm_nl_ctl limits 1 1\n\n\t# debug build can slow down measurably the test program\n\t# we use quite tight time limit on the run-time, to ensure\n\t# maximum B/W usage.\n\t# Use kmemleak/lockdep/kasan/prove_locking presence as a rough\n\t# estimate for this being a debug kernel and increase the\n\t# maximum run-time accordingly. Observed run times for CI builds\n\t# running selftests, including kbuild, were used to determine the\n\t# amount of time to add.\n\tgrep -q ' kmemleak_init$\\| lockdep_init$\\| kasan_init$\\| prove_locking$' /proc/kallsyms && slack=$((slack+550))\n}\n\n# $1: ns, $2: port\nwait_local_port_listen()\n{\n\tlocal listener_ns=\"${1}\"\n\tlocal port=\"${2}\"\n\n\tlocal port_hex i\n\n\tport_hex=\"$(printf \"%04X\" \"${port}\")\"\n\tfor i in $(seq 10); do\n\t\tip netns exec \"${listener_ns}\" cat /proc/net/tcp* | \\\n\t\t\tawk \"BEGIN {rc=1} {if (\\$2 ~ /:${port_hex}\\$/ && \\$4 ~ /0A/) {rc=0; exit}} END {exit rc}\" &&\n\t\t\tbreak\n\t\tsleep 0.1\n\tdone\n}\n\ndo_transfer()\n{\n\tlocal cin=$1\n\tlocal sin=$2\n\tlocal max_time=$3\n\tlocal port\n\tport=$((10000+$test_cnt))\n\ttest_cnt=$((test_cnt+1))\n\n\t:> \"$cout\"\n\t:> \"$sout\"\n\t:> \"$capout\"\n\n\tif $capture; then\n\t\tlocal capuser\n\t\tif [ -z $SUDO_USER ] ; then\n\t\t\tcapuser=\"\"\n\t\telse\n\t\t\tcapuser=\"-Z $SUDO_USER\"\n\t\tfi\n\n\t\tlocal capfile=\"${rndh}-${port}\"\n\t\tlocal capopt=\"-i any -s 65535 -B 32768 ${capuser}\"\n\n\t\tip netns exec ${ns3}  tcpdump ${capopt} -w \"${capfile}-listener.pcap\"  >> \"${capout}\" 2>&1 &\n\t\tlocal cappid_listener=$!\n\n\t\tip netns exec ${ns1} tcpdump ${capopt} -w \"${capfile}-connector.pcap\" >> \"${capout}\" 2>&1 &\n\t\tlocal cappid_connector=$!\n\n\t\tsleep 1\n\tfi\n\n\ttimeout ${timeout_test} \\\n\t\tip netns exec ${ns3} \\\n\t\t\t./mptcp_connect -jt ${timeout_poll} -l -p $port -T $max_time \\\n\t\t\t\t0.0.0.0 < \"$sin\" > \"$sout\" &\n\tlocal spid=$!\n\n\twait_local_port_listen \"${ns3}\" \"${port}\"\n\n\ttimeout ${timeout_test} \\\n\t\tip netns exec ${ns1} \\\n\t\t\t./mptcp_connect -jt ${timeout_poll} -p $port -T $max_time \\\n\t\t\t\t10.0.3.3 < \"$cin\" > \"$cout\" &\n\tlocal cpid=$!\n\n\twait $cpid\n\tlocal retc=$?\n\twait $spid\n\tlocal rets=$?\n\n\tif $capture; then\n\t\tsleep 1\n\t\tkill ${cappid_listener}\n\t\tkill ${cappid_connector}\n\tfi\n\n\tcmp $sin $cout > /dev/null 2>&1\n\tlocal cmps=$?\n\tcmp $cin $sout > /dev/null 2>&1\n\tlocal cmpc=$?\n\n\tprintf \"%-16s\" \" max $max_time \"\n\tif [ $retc -eq 0 ] && [ $rets -eq 0 ] && \\\n\t   [ $cmpc -eq 0 ] && [ $cmps -eq 0 ]; then\n\t\techo \"[ OK ]\"\n\t\tcat \"$capout\"\n\t\treturn 0\n\tfi\n\n\techo \" [ fail ]\"\n\techo \"client exit code $retc, server $rets\" 1>&2\n\techo -e \"\\nnetns ${ns3} socket stat for $port:\" 1>&2\n\tip netns exec ${ns3} ss -nita 1>&2 -o \"sport = :$port\"\n\techo -e \"\\nnetns ${ns1} socket stat for $port:\" 1>&2\n\tip netns exec ${ns1} ss -nita 1>&2 -o \"dport = :$port\"\n\tls -l $sin $cout\n\tls -l $cin $sout\n\n\tcat \"$capout\"\n\treturn 1\n}\n\nrun_test()\n{\n\tlocal rate1=$1\n\tlocal rate2=$2\n\tlocal delay1=$3\n\tlocal delay2=$4\n\tlocal lret\n\tlocal dev\n\tshift 4\n\tlocal msg=$*\n\n\t[ $delay1 -gt 0 ] && delay1=\"delay $delay1\" || delay1=\"\"\n\t[ $delay2 -gt 0 ] && delay2=\"delay $delay2\" || delay2=\"\"\n\n\tfor dev in ns1eth1 ns1eth2; do\n\t\ttc -n $ns1 qdisc del dev $dev root >/dev/null 2>&1\n\tdone\n\tfor dev in ns2eth1 ns2eth2; do\n\t\ttc -n $ns2 qdisc del dev $dev root >/dev/null 2>&1\n\tdone\n\ttc -n $ns1 qdisc add dev ns1eth1 root netem rate ${rate1}mbit $delay1\n\ttc -n $ns1 qdisc add dev ns1eth2 root netem rate ${rate2}mbit $delay2\n\ttc -n $ns2 qdisc add dev ns2eth1 root netem rate ${rate1}mbit $delay1\n\ttc -n $ns2 qdisc add dev ns2eth2 root netem rate ${rate2}mbit $delay2\n\n\t# time is measured in ms, account for transfer size, aggregated link speed\n\t# and header overhead (10%)\n\t#              ms    byte -> bit   10%        mbit      -> kbit -> bit  10%\n\tlocal time=$((1000 * size  *  8  * 10 / ((rate1 + rate2) * 1000 * 1000 * 9) ))\n\n\t# mptcp_connect will do some sleeps to allow the mp_join handshake\n\t# completion (see mptcp_connect): 200ms on each side, add some slack\n\ttime=$((time + 400 + slack))\n\n\tprintf \"%-60s\" \"$msg\"\n\tdo_transfer $small $large $time\n\tlret=$?\n\tmptcp_lib_result_code \"${lret}\" \"${msg}\"\n\tif [ $lret -ne 0 ]; then\n\t\tret=$lret\n\t\t[ $bail -eq 0 ] || exit $ret\n\tfi\n\n\tprintf \"%-60s\" \"$msg - reverse direction\"\n\tdo_transfer $large $small $time\n\tlret=$?\n\tmptcp_lib_result_code \"${lret}\" \"${msg}\"\n\tif [ $lret -ne 0 ]; then\n\t\tret=$lret\n\t\t[ $bail -eq 0 ] || exit $ret\n\tfi\n}\n\nwhile getopts \"bcdh\" option;do\n\tcase \"$option\" in\n\t\"h\")\n\t\tusage $0\n\t\texit 0\n\t\t;;\n\t\"b\")\n\t\tbail=1\n\t\t;;\n\t\"c\")\n\t\tcapture=true\n\t\t;;\n\t\"d\")\n\t\tset -x\n\t\t;;\n\t\"?\")\n\t\tusage $0\n\t\texit 1\n\t\t;;\n\tesac\ndone\n\nsetup\nrun_test 10 10 0 0 \"balanced bwidth\"\nrun_test 10 10 1 50 \"balanced bwidth with unbalanced delay\"\n\n# we still need some additional infrastructure to pass the following test-cases\nrun_test 30 10 0 0 \"unbalanced bwidth\"\nrun_test 30 10 1 50 \"unbalanced bwidth with unbalanced delay\"\nrun_test 30 10 50 1 \"unbalanced bwidth with opposed, unbalanced delay\"\n\nmptcp_lib_result_print_all_tap\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}