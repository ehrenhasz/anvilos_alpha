{
  "module_name": "mptcp_connect.c",
  "hash_id": "b64d7a5a13fdf7885d71cfce488e20c4c3efc73543e86b87f1623e1c8cd24b2e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/mptcp/mptcp_connect.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n\n#include <sys/ioctl.h>\n#include <sys/poll.h>\n#include <sys/random.h>\n#include <sys/sendfile.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n\n#include <netdb.h>\n#include <netinet/in.h>\n\n#include <linux/tcp.h>\n#include <linux/time_types.h>\n#include <linux/sockios.h>\n\nextern int optind;\n\n#ifndef IPPROTO_MPTCP\n#define IPPROTO_MPTCP 262\n#endif\n#ifndef TCP_ULP\n#define TCP_ULP 31\n#endif\n\nstatic int  poll_timeout = 10 * 1000;\nstatic bool listen_mode;\nstatic bool quit;\n\nenum cfg_mode {\n\tCFG_MODE_POLL,\n\tCFG_MODE_MMAP,\n\tCFG_MODE_SENDFILE,\n};\n\nenum cfg_peek {\n\tCFG_NONE_PEEK,\n\tCFG_WITH_PEEK,\n\tCFG_AFTER_PEEK,\n};\n\nstatic enum cfg_mode cfg_mode = CFG_MODE_POLL;\nstatic enum cfg_peek cfg_peek = CFG_NONE_PEEK;\nstatic const char *cfg_host;\nstatic const char *cfg_port\t= \"12000\";\nstatic int cfg_sock_proto\t= IPPROTO_MPTCP;\nstatic int pf = AF_INET;\nstatic int cfg_sndbuf;\nstatic int cfg_rcvbuf;\nstatic bool cfg_join;\nstatic bool cfg_remove;\nstatic unsigned int cfg_time;\nstatic unsigned int cfg_do_w;\nstatic int cfg_wait;\nstatic uint32_t cfg_mark;\nstatic char *cfg_input;\nstatic int cfg_repeat = 1;\nstatic int cfg_truncate;\nstatic int cfg_rcv_trunc;\n\nstruct cfg_cmsg_types {\n\tunsigned int cmsg_enabled:1;\n\tunsigned int timestampns:1;\n\tunsigned int tcp_inq:1;\n};\n\nstruct cfg_sockopt_types {\n\tunsigned int transparent:1;\n\tunsigned int mptfo:1;\n};\n\nstruct tcp_inq_state {\n\tunsigned int last;\n\tbool expect_eof;\n};\n\nstruct wstate {\n\tchar buf[8192];\n\tunsigned int len;\n\tunsigned int off;\n\tunsigned int total_len;\n};\n\nstatic struct tcp_inq_state tcp_inq;\n\nstatic struct cfg_cmsg_types cfg_cmsg_types;\nstatic struct cfg_sockopt_types cfg_sockopt_types;\n\nstatic void die_usage(void)\n{\n\tfprintf(stderr, \"Usage: mptcp_connect [-6] [-c cmsg] [-f offset] [-i file] [-I num] [-j] [-l] \"\n\t\t\"[-m mode] [-M mark] [-o option] [-p port] [-P mode] [-r num] [-R num] \"\n\t\t\"[-s MPTCP|TCP] [-S num] [-t num] [-T num] [-w sec] connect_address\\n\");\n\tfprintf(stderr, \"\\t-6 use ipv6\\n\");\n\tfprintf(stderr, \"\\t-c cmsg -- test cmsg type <cmsg>\\n\");\n\tfprintf(stderr, \"\\t-f offset -- stop the I/O after receiving and sending the specified amount \"\n\t\t\"of bytes. If there are unread bytes in the receive queue, that will cause a MPTCP \"\n\t\t\"fastclose at close/shutdown. If offset is negative, expect the peer to close before \"\n\t\t\"all the local data as been sent, thus toleration errors on write and EPIPE signals\\n\");\n\tfprintf(stderr, \"\\t-i file -- read the data to send from the given file instead of stdin\");\n\tfprintf(stderr, \"\\t-I num -- repeat the transfer 'num' times. In listen mode accepts num \"\n\t\t\"incoming connections, in client mode, disconnect and reconnect to the server\\n\");\n\tfprintf(stderr, \"\\t-j     -- add additional sleep at connection start and tear down \"\n\t\t\"-- for MPJ tests\\n\");\n\tfprintf(stderr, \"\\t-l     -- listens mode, accepts incoming connection\\n\");\n\tfprintf(stderr, \"\\t-m [poll|mmap|sendfile] -- use poll(default)/mmap+write/sendfile\\n\");\n\tfprintf(stderr, \"\\t-M mark -- set socket packet mark\\n\");\n\tfprintf(stderr, \"\\t-o option -- test sockopt <option>\\n\");\n\tfprintf(stderr, \"\\t-p num -- use port num\\n\");\n\tfprintf(stderr,\n\t\t\"\\t-P [saveWithPeek|saveAfterPeek] -- save data with/after MSG_PEEK form tcp socket\\n\");\n\tfprintf(stderr, \"\\t-r num -- enable slow mode, limiting each write to num bytes \"\n\t\t\"-- for remove addr tests\\n\");\n\tfprintf(stderr, \"\\t-R num -- set SO_RCVBUF to num\\n\");\n\tfprintf(stderr, \"\\t-s [MPTCP|TCP] -- use mptcp(default) or tcp sockets\\n\");\n\tfprintf(stderr, \"\\t-S num -- set SO_SNDBUF to num\\n\");\n\tfprintf(stderr, \"\\t-t num -- set poll timeout to num\\n\");\n\tfprintf(stderr, \"\\t-T num -- set expected runtime to num ms\\n\");\n\tfprintf(stderr, \"\\t-w num -- wait num sec before closing the socket\\n\");\n\texit(1);\n}\n\nstatic void xerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\texit(1);\n}\n\nstatic void handle_signal(int nr)\n{\n\tquit = true;\n}\n\nstatic const char *getxinfo_strerr(int err)\n{\n\tif (err == EAI_SYSTEM)\n\t\treturn strerror(errno);\n\n\treturn gai_strerror(err);\n}\n\nstatic void xgetnameinfo(const struct sockaddr *addr, socklen_t addrlen,\n\t\t\t char *host, socklen_t hostlen,\n\t\t\t char *serv, socklen_t servlen)\n{\n\tint flags = NI_NUMERICHOST | NI_NUMERICSERV;\n\tint err = getnameinfo(addr, addrlen, host, hostlen, serv, servlen,\n\t\t\t      flags);\n\n\tif (err) {\n\t\tconst char *errstr = getxinfo_strerr(err);\n\n\t\tfprintf(stderr, \"Fatal: getnameinfo: %s\\n\", errstr);\n\t\texit(1);\n\t}\n}\n\nstatic void xgetaddrinfo(const char *node, const char *service,\n\t\t\t const struct addrinfo *hints,\n\t\t\t struct addrinfo **res)\n{\n\tint err = getaddrinfo(node, service, hints, res);\n\n\tif (err) {\n\t\tconst char *errstr = getxinfo_strerr(err);\n\n\t\tfprintf(stderr, \"Fatal: getaddrinfo(%s:%s): %s\\n\",\n\t\t\tnode ? node : \"\", service ? service : \"\", errstr);\n\t\texit(1);\n\t}\n}\n\nstatic void set_rcvbuf(int fd, unsigned int size)\n{\n\tint err;\n\n\terr = setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &size, sizeof(size));\n\tif (err) {\n\t\tperror(\"set SO_RCVBUF\");\n\t\texit(1);\n\t}\n}\n\nstatic void set_sndbuf(int fd, unsigned int size)\n{\n\tint err;\n\n\terr = setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size));\n\tif (err) {\n\t\tperror(\"set SO_SNDBUF\");\n\t\texit(1);\n\t}\n}\n\nstatic void set_mark(int fd, uint32_t mark)\n{\n\tint err;\n\n\terr = setsockopt(fd, SOL_SOCKET, SO_MARK, &mark, sizeof(mark));\n\tif (err) {\n\t\tperror(\"set SO_MARK\");\n\t\texit(1);\n\t}\n}\n\nstatic void set_transparent(int fd, int pf)\n{\n\tint one = 1;\n\n\tswitch (pf) {\n\tcase AF_INET:\n\t\tif (-1 == setsockopt(fd, SOL_IP, IP_TRANSPARENT, &one, sizeof(one)))\n\t\t\tperror(\"IP_TRANSPARENT\");\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (-1 == setsockopt(fd, IPPROTO_IPV6, IPV6_TRANSPARENT, &one, sizeof(one)))\n\t\t\tperror(\"IPV6_TRANSPARENT\");\n\t\tbreak;\n\t}\n}\n\nstatic void set_mptfo(int fd, int pf)\n{\n\tint qlen = 25;\n\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN, &qlen, sizeof(qlen)) == -1)\n\t\tperror(\"TCP_FASTOPEN\");\n}\n\nstatic int do_ulp_so(int sock, const char *name)\n{\n\treturn setsockopt(sock, IPPROTO_TCP, TCP_ULP, name, strlen(name));\n}\n\n#define X(m)\txerror(\"%s:%u: %s: failed for proto %d at line %u\", __FILE__, __LINE__, (m), proto, line)\nstatic void sock_test_tcpulp(int sock, int proto, unsigned int line)\n{\n\tsocklen_t buflen = 8;\n\tchar buf[8] = \"\";\n\tint ret = getsockopt(sock, IPPROTO_TCP, TCP_ULP, buf, &buflen);\n\n\tif (ret != 0)\n\t\tX(\"getsockopt\");\n\n\tif (buflen > 0) {\n\t\tif (strcmp(buf, \"mptcp\") != 0)\n\t\t\txerror(\"unexpected ULP '%s' for proto %d at line %u\", buf, proto, line);\n\t\tret = do_ulp_so(sock, \"tls\");\n\t\tif (ret == 0)\n\t\t\tX(\"setsockopt\");\n\t} else if (proto == IPPROTO_MPTCP) {\n\t\tret = do_ulp_so(sock, \"tls\");\n\t\tif (ret != -1)\n\t\t\tX(\"setsockopt\");\n\t}\n\n\tret = do_ulp_so(sock, \"mptcp\");\n\tif (ret != -1)\n\t\tX(\"setsockopt\");\n\n#undef X\n}\n\n#define SOCK_TEST_TCPULP(s, p) sock_test_tcpulp((s), (p), __LINE__)\n\nstatic int sock_listen_mptcp(const char * const listenaddr,\n\t\t\t     const char * const port)\n{\n\tint sock = -1;\n\tstruct addrinfo hints = {\n\t\t.ai_protocol = IPPROTO_TCP,\n\t\t.ai_socktype = SOCK_STREAM,\n\t\t.ai_flags = AI_PASSIVE | AI_NUMERICHOST\n\t};\n\n\thints.ai_family = pf;\n\n\tstruct addrinfo *a, *addr;\n\tint one = 1;\n\n\txgetaddrinfo(listenaddr, port, &hints, &addr);\n\thints.ai_family = pf;\n\n\tfor (a = addr; a; a = a->ai_next) {\n\t\tsock = socket(a->ai_family, a->ai_socktype, cfg_sock_proto);\n\t\tif (sock < 0)\n\t\t\tcontinue;\n\n\t\tSOCK_TEST_TCPULP(sock, cfg_sock_proto);\n\n\t\tif (-1 == setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one,\n\t\t\t\t     sizeof(one)))\n\t\t\tperror(\"setsockopt\");\n\n\t\tif (cfg_sockopt_types.transparent)\n\t\t\tset_transparent(sock, pf);\n\n\t\tif (cfg_sockopt_types.mptfo)\n\t\t\tset_mptfo(sock, pf);\n\n\t\tif (bind(sock, a->ai_addr, a->ai_addrlen) == 0)\n\t\t\tbreak;  \n\n\t\tperror(\"bind\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t}\n\n\tfreeaddrinfo(addr);\n\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Could not create listen socket\\n\");\n\t\treturn sock;\n\t}\n\n\tSOCK_TEST_TCPULP(sock, cfg_sock_proto);\n\n\tif (listen(sock, 20)) {\n\t\tperror(\"listen\");\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tSOCK_TEST_TCPULP(sock, cfg_sock_proto);\n\n\treturn sock;\n}\n\nstatic int sock_connect_mptcp(const char * const remoteaddr,\n\t\t\t      const char * const port, int proto,\n\t\t\t      struct addrinfo **peer,\n\t\t\t      int infd, struct wstate *winfo)\n{\n\tstruct addrinfo hints = {\n\t\t.ai_protocol = IPPROTO_TCP,\n\t\t.ai_socktype = SOCK_STREAM,\n\t};\n\tstruct addrinfo *a, *addr;\n\tint syn_copied = 0;\n\tint sock = -1;\n\n\thints.ai_family = pf;\n\n\txgetaddrinfo(remoteaddr, port, &hints, &addr);\n\tfor (a = addr; a; a = a->ai_next) {\n\t\tsock = socket(a->ai_family, a->ai_socktype, proto);\n\t\tif (sock < 0) {\n\t\t\tperror(\"socket\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tSOCK_TEST_TCPULP(sock, proto);\n\n\t\tif (cfg_mark)\n\t\t\tset_mark(sock, cfg_mark);\n\n\t\tif (cfg_sockopt_types.mptfo) {\n\t\t\tif (!winfo->total_len)\n\t\t\t\twinfo->total_len = winfo->len = read(infd, winfo->buf,\n\t\t\t\t\t\t\t\t     sizeof(winfo->buf));\n\n\t\t\tsyn_copied = sendto(sock, winfo->buf, winfo->len, MSG_FASTOPEN,\n\t\t\t\t\t    a->ai_addr, a->ai_addrlen);\n\t\t\tif (syn_copied >= 0) {\n\t\t\t\twinfo->off = syn_copied;\n\t\t\t\twinfo->len -= syn_copied;\n\t\t\t\t*peer = a;\n\t\t\t\tbreak;  \n\t\t\t}\n\t\t} else {\n\t\t\tif (connect(sock, a->ai_addr, a->ai_addrlen) == 0) {\n\t\t\t\t*peer = a;\n\t\t\t\tbreak;  \n\t\t\t}\n\t\t}\n\t\tif (cfg_sockopt_types.mptfo) {\n\t\t\tperror(\"sendto()\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t} else {\n\t\t\tperror(\"connect()\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t}\n\t}\n\n\tfreeaddrinfo(addr);\n\tif (sock != -1)\n\t\tSOCK_TEST_TCPULP(sock, proto);\n\treturn sock;\n}\n\nstatic size_t do_rnd_write(const int fd, char *buf, const size_t len)\n{\n\tstatic bool first = true;\n\tunsigned int do_w;\n\tssize_t bw;\n\n\tdo_w = rand() & 0xffff;\n\tif (do_w == 0 || do_w > len)\n\t\tdo_w = len;\n\n\tif (cfg_join && first && do_w > 100)\n\t\tdo_w = 100;\n\n\tif (cfg_remove && do_w > cfg_do_w)\n\t\tdo_w = cfg_do_w;\n\n\tbw = write(fd, buf, do_w);\n\tif (bw < 0)\n\t\treturn bw;\n\n\t \n\tif (cfg_join && first) {\n\t\tusleep(200000);\n\t\tfirst = false;\n\t}\n\n\tif (cfg_remove)\n\t\tusleep(200000);\n\n\treturn bw;\n}\n\nstatic size_t do_write(const int fd, char *buf, const size_t len)\n{\n\tsize_t offset = 0;\n\n\twhile (offset < len) {\n\t\tsize_t written;\n\t\tssize_t bw;\n\n\t\tbw = write(fd, buf + offset, len - offset);\n\t\tif (bw < 0) {\n\t\t\tperror(\"write\");\n\t\t\treturn 0;\n\t\t}\n\n\t\twritten = (size_t)bw;\n\t\toffset += written;\n\t}\n\n\treturn offset;\n}\n\nstatic void process_cmsg(struct msghdr *msgh)\n{\n\tstruct __kernel_timespec ts;\n\tbool inq_found = false;\n\tbool ts_found = false;\n\tunsigned int inq = 0;\n\tstruct cmsghdr *cmsg;\n\n\tfor (cmsg = CMSG_FIRSTHDR(msgh); cmsg ; cmsg = CMSG_NXTHDR(msgh, cmsg)) {\n\t\tif (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SO_TIMESTAMPNS_NEW) {\n\t\t\tmemcpy(&ts, CMSG_DATA(cmsg), sizeof(ts));\n\t\t\tts_found = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (cmsg->cmsg_level == IPPROTO_TCP && cmsg->cmsg_type == TCP_CM_INQ) {\n\t\t\tmemcpy(&inq, CMSG_DATA(cmsg), sizeof(inq));\n\t\t\tinq_found = true;\n\t\t\tcontinue;\n\t\t}\n\n\t}\n\n\tif (cfg_cmsg_types.timestampns) {\n\t\tif (!ts_found)\n\t\t\txerror(\"TIMESTAMPNS not present\\n\");\n\t}\n\n\tif (cfg_cmsg_types.tcp_inq) {\n\t\tif (!inq_found)\n\t\t\txerror(\"TCP_INQ not present\\n\");\n\n\t\tif (inq > 1024)\n\t\t\txerror(\"tcp_inq %u is larger than one kbyte\\n\", inq);\n\t\ttcp_inq.last = inq;\n\t}\n}\n\nstatic ssize_t do_recvmsg_cmsg(const int fd, char *buf, const size_t len)\n{\n\tchar msg_buf[8192];\n\tstruct iovec iov = {\n\t\t.iov_base = buf,\n\t\t.iov_len = len,\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t\t.msg_control = msg_buf,\n\t\t.msg_controllen = sizeof(msg_buf),\n\t};\n\tint flags = 0;\n\tunsigned int last_hint = tcp_inq.last;\n\tint ret = recvmsg(fd, &msg, flags);\n\n\tif (ret <= 0) {\n\t\tif (ret == 0 && tcp_inq.expect_eof)\n\t\t\treturn ret;\n\n\t\tif (ret == 0 && cfg_cmsg_types.tcp_inq)\n\t\t\tif (last_hint != 1 && last_hint != 0)\n\t\t\t\txerror(\"EOF but last tcp_inq hint was %u\\n\", last_hint);\n\n\t\treturn ret;\n\t}\n\n\tif (tcp_inq.expect_eof)\n\t\txerror(\"expected EOF, last_hint %u, now %u\\n\",\n\t\t       last_hint, tcp_inq.last);\n\n\tif (msg.msg_controllen && !cfg_cmsg_types.cmsg_enabled)\n\t\txerror(\"got %lu bytes of cmsg data, expected 0\\n\",\n\t\t       (unsigned long)msg.msg_controllen);\n\n\tif (msg.msg_controllen == 0 && cfg_cmsg_types.cmsg_enabled)\n\t\txerror(\"%s\\n\", \"got no cmsg data\");\n\n\tif (msg.msg_controllen)\n\t\tprocess_cmsg(&msg);\n\n\tif (cfg_cmsg_types.tcp_inq) {\n\t\tif ((size_t)ret < len && last_hint > (unsigned int)ret) {\n\t\t\tif (ret + 1 != (int)last_hint) {\n\t\t\t\tint next = read(fd, msg_buf, sizeof(msg_buf));\n\n\t\t\t\txerror(\"read %u of %u, last_hint was %u tcp_inq hint now %u next_read returned %d/%m\\n\",\n\t\t\t\t       ret, (unsigned int)len, last_hint, tcp_inq.last, next);\n\t\t\t} else {\n\t\t\t\ttcp_inq.expect_eof = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t do_rnd_read(const int fd, char *buf, const size_t len)\n{\n\tint ret = 0;\n\tchar tmp[16384];\n\tsize_t cap = rand();\n\n\tcap &= 0xffff;\n\n\tif (cap == 0)\n\t\tcap = 1;\n\telse if (cap > len)\n\t\tcap = len;\n\n\tif (cfg_peek == CFG_WITH_PEEK) {\n\t\tret = recv(fd, buf, cap, MSG_PEEK);\n\t\tret = (ret < 0) ? ret : read(fd, tmp, ret);\n\t} else if (cfg_peek == CFG_AFTER_PEEK) {\n\t\tret = recv(fd, buf, cap, MSG_PEEK);\n\t\tret = (ret < 0) ? ret : read(fd, buf, cap);\n\t} else if (cfg_cmsg_types.cmsg_enabled) {\n\t\tret = do_recvmsg_cmsg(fd, buf, cap);\n\t} else {\n\t\tret = read(fd, buf, cap);\n\t}\n\n\treturn ret;\n}\n\nstatic void set_nonblock(int fd, bool nonblock)\n{\n\tint flags = fcntl(fd, F_GETFL);\n\n\tif (flags == -1)\n\t\treturn;\n\n\tif (nonblock)\n\t\tfcntl(fd, F_SETFL, flags | O_NONBLOCK);\n\telse\n\t\tfcntl(fd, F_SETFL, flags & ~O_NONBLOCK);\n}\n\nstatic void shut_wr(int fd)\n{\n\t \n\tif (cfg_wait)\n\t\tusleep(cfg_wait);\n\n\tshutdown(fd, SHUT_WR);\n}\n\nstatic int copyfd_io_poll(int infd, int peerfd, int outfd,\n\t\t\t  bool *in_closed_after_out, struct wstate *winfo)\n{\n\tstruct pollfd fds = {\n\t\t.fd = peerfd,\n\t\t.events = POLLIN | POLLOUT,\n\t};\n\tunsigned int total_wlen = 0, total_rlen = 0;\n\n\tset_nonblock(peerfd, true);\n\n\tfor (;;) {\n\t\tchar rbuf[8192];\n\t\tssize_t len;\n\n\t\tif (fds.events == 0 || quit)\n\t\t\tbreak;\n\n\t\tswitch (poll(&fds, 1, poll_timeout)) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tperror(\"poll\");\n\t\t\treturn 1;\n\t\tcase 0:\n\t\t\tfprintf(stderr, \"%s: poll timed out (events: \"\n\t\t\t\t\"POLLIN %u, POLLOUT %u)\\n\", __func__,\n\t\t\t\tfds.events & POLLIN, fds.events & POLLOUT);\n\t\t\treturn 2;\n\t\t}\n\n\t\tif (fds.revents & POLLIN) {\n\t\t\tssize_t rb = sizeof(rbuf);\n\n\t\t\t \n\t\t\tif (cfg_truncate > 0) {\n\t\t\t\tif (rb + total_rlen > cfg_truncate)\n\t\t\t\t\trb = cfg_truncate - total_rlen;\n\t\t\t\tlen = read(peerfd, rbuf, rb);\n\t\t\t} else {\n\t\t\t\tlen = do_rnd_read(peerfd, rbuf, sizeof(rbuf));\n\t\t\t}\n\t\t\tif (len == 0) {\n\t\t\t\t \n\t\t\t\tfds.events &= ~POLLIN;\n\n\t\t\t\tif ((fds.events & POLLOUT) == 0) {\n\t\t\t\t\t*in_closed_after_out = true;\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t \n\t\t\t} else if (len < 0) {\n\t\t\t\tif (cfg_rcv_trunc)\n\t\t\t\t\treturn 0;\n\t\t\t\tperror(\"read\");\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\ttotal_rlen += len;\n\t\t\tdo_write(outfd, rbuf, len);\n\t\t}\n\n\t\tif (fds.revents & POLLOUT) {\n\t\t\tif (winfo->len == 0) {\n\t\t\t\twinfo->off = 0;\n\t\t\t\twinfo->len = read(infd, winfo->buf, sizeof(winfo->buf));\n\t\t\t}\n\n\t\t\tif (winfo->len > 0) {\n\t\t\t\tssize_t bw;\n\n\t\t\t\t \n\t\t\t\tif (cfg_truncate > 0 && winfo->len + total_wlen > cfg_truncate)\n\t\t\t\t\twinfo->len = cfg_truncate - total_wlen;\n\n\t\t\t\tbw = do_rnd_write(peerfd, winfo->buf + winfo->off, winfo->len);\n\t\t\t\tif (bw < 0) {\n\t\t\t\t\tif (cfg_rcv_trunc)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tperror(\"write\");\n\t\t\t\t\treturn 111;\n\t\t\t\t}\n\n\t\t\t\twinfo->off += bw;\n\t\t\t\twinfo->len -= bw;\n\t\t\t\ttotal_wlen += bw;\n\t\t\t} else if (winfo->len == 0) {\n\t\t\t\t \n\t\t\t\tfds.events &= ~POLLOUT;\n\n\t\t\t\tif ((fds.events & POLLIN) == 0)\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\n\t\t\t\tshut_wr(peerfd);\n\t\t\t} else {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tperror(\"read\");\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t}\n\n\t\tif (fds.revents & (POLLERR | POLLNVAL)) {\n\t\t\tif (cfg_rcv_trunc)\n\t\t\t\treturn 0;\n\t\t\tfprintf(stderr, \"Unexpected revents: \"\n\t\t\t\t\"POLLERR/POLLNVAL(%x)\\n\", fds.revents);\n\t\t\treturn 5;\n\t\t}\n\n\t\tif (cfg_truncate > 0 && total_wlen >= cfg_truncate &&\n\t\t    total_rlen >= cfg_truncate)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (cfg_remove && !quit)\n\t\tusleep(cfg_wait);\n\n\treturn 0;\n}\n\nstatic int do_recvfile(int infd, int outfd)\n{\n\tssize_t r;\n\n\tdo {\n\t\tchar buf[16384];\n\n\t\tr = do_rnd_read(infd, buf, sizeof(buf));\n\t\tif (r > 0) {\n\t\t\tif (write(outfd, buf, r) != r)\n\t\t\t\tbreak;\n\t\t} else if (r < 0) {\n\t\t\tperror(\"read\");\n\t\t}\n\t} while (r > 0);\n\n\treturn (int)r;\n}\n\nstatic int spool_buf(int fd, struct wstate *winfo)\n{\n\twhile (winfo->len) {\n\t\tint ret = write(fd, winfo->buf + winfo->off, winfo->len);\n\n\t\tif (ret < 0) {\n\t\t\tperror(\"write\");\n\t\t\treturn 4;\n\t\t}\n\t\twinfo->off += ret;\n\t\twinfo->len -= ret;\n\t}\n\treturn 0;\n}\n\nstatic int do_mmap(int infd, int outfd, unsigned int size,\n\t\t   struct wstate *winfo)\n{\n\tchar *inbuf = mmap(NULL, size, PROT_READ, MAP_SHARED, infd, 0);\n\tssize_t ret = 0, off = winfo->total_len;\n\tsize_t rem;\n\n\tif (inbuf == MAP_FAILED) {\n\t\tperror(\"mmap\");\n\t\treturn 1;\n\t}\n\n\tret = spool_buf(outfd, winfo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trem = size - winfo->total_len;\n\n\twhile (rem > 0) {\n\t\tret = write(outfd, inbuf + off, rem);\n\n\t\tif (ret < 0) {\n\t\t\tperror(\"write\");\n\t\t\tbreak;\n\t\t}\n\n\t\toff += ret;\n\t\trem -= ret;\n\t}\n\n\tmunmap(inbuf, size);\n\treturn rem;\n}\n\nstatic int get_infd_size(int fd)\n{\n\tstruct stat sb;\n\tssize_t count;\n\tint err;\n\n\terr = fstat(fd, &sb);\n\tif (err < 0) {\n\t\tperror(\"fstat\");\n\t\treturn -1;\n\t}\n\n\tif ((sb.st_mode & S_IFMT) != S_IFREG) {\n\t\tfprintf(stderr, \"%s: stdin is not a regular file\\n\", __func__);\n\t\treturn -2;\n\t}\n\n\tcount = sb.st_size;\n\tif (count > INT_MAX) {\n\t\tfprintf(stderr, \"File too large: %zu\\n\", count);\n\t\treturn -3;\n\t}\n\n\treturn (int)count;\n}\n\nstatic int do_sendfile(int infd, int outfd, unsigned int count,\n\t\t       struct wstate *winfo)\n{\n\tint ret = spool_buf(outfd, winfo);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcount -= winfo->total_len;\n\n\twhile (count > 0) {\n\t\tssize_t r;\n\n\t\tr = sendfile(outfd, infd, NULL, count);\n\t\tif (r < 0) {\n\t\t\tperror(\"sendfile\");\n\t\t\treturn 3;\n\t\t}\n\n\t\tcount -= r;\n\t}\n\n\treturn 0;\n}\n\nstatic int copyfd_io_mmap(int infd, int peerfd, int outfd,\n\t\t\t  unsigned int size, bool *in_closed_after_out,\n\t\t\t  struct wstate *winfo)\n{\n\tint err;\n\n\tif (listen_mode) {\n\t\terr = do_recvfile(peerfd, outfd);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = do_mmap(infd, peerfd, size, winfo);\n\t} else {\n\t\terr = do_mmap(infd, peerfd, size, winfo);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tshut_wr(peerfd);\n\n\t\terr = do_recvfile(peerfd, outfd);\n\t\t*in_closed_after_out = true;\n\t}\n\n\treturn err;\n}\n\nstatic int copyfd_io_sendfile(int infd, int peerfd, int outfd,\n\t\t\t      unsigned int size, bool *in_closed_after_out, struct wstate *winfo)\n{\n\tint err;\n\n\tif (listen_mode) {\n\t\terr = do_recvfile(peerfd, outfd);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = do_sendfile(infd, peerfd, size, winfo);\n\t} else {\n\t\terr = do_sendfile(infd, peerfd, size, winfo);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tshut_wr(peerfd);\n\n\t\terr = do_recvfile(peerfd, outfd);\n\t\t*in_closed_after_out = true;\n\t}\n\n\treturn err;\n}\n\nstatic int copyfd_io(int infd, int peerfd, int outfd, bool close_peerfd, struct wstate *winfo)\n{\n\tbool in_closed_after_out = false;\n\tstruct timespec start, end;\n\tint file_size;\n\tint ret;\n\n\tif (cfg_time && (clock_gettime(CLOCK_MONOTONIC, &start) < 0))\n\t\txerror(\"can not fetch start time %d\", errno);\n\n\tswitch (cfg_mode) {\n\tcase CFG_MODE_POLL:\n\t\tret = copyfd_io_poll(infd, peerfd, outfd, &in_closed_after_out,\n\t\t\t\t     winfo);\n\t\tbreak;\n\n\tcase CFG_MODE_MMAP:\n\t\tfile_size = get_infd_size(infd);\n\t\tif (file_size < 0)\n\t\t\treturn file_size;\n\t\tret = copyfd_io_mmap(infd, peerfd, outfd, file_size,\n\t\t\t\t     &in_closed_after_out, winfo);\n\t\tbreak;\n\n\tcase CFG_MODE_SENDFILE:\n\t\tfile_size = get_infd_size(infd);\n\t\tif (file_size < 0)\n\t\t\treturn file_size;\n\t\tret = copyfd_io_sendfile(infd, peerfd, outfd, file_size,\n\t\t\t\t\t &in_closed_after_out, winfo);\n\t\tbreak;\n\n\tdefault:\n\t\tfprintf(stderr, \"Invalid mode %d\\n\", cfg_mode);\n\n\t\tdie_usage();\n\t\treturn 1;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (close_peerfd)\n\t\tclose(peerfd);\n\n\tif (cfg_time) {\n\t\tunsigned int delta_ms;\n\n\t\tif (clock_gettime(CLOCK_MONOTONIC, &end) < 0)\n\t\t\txerror(\"can not fetch end time %d\", errno);\n\t\tdelta_ms = (end.tv_sec - start.tv_sec) * 1000 + (end.tv_nsec - start.tv_nsec) / 1000000;\n\t\tif (delta_ms > cfg_time) {\n\t\t\txerror(\"transfer slower than expected! runtime %d ms, expected %d ms\",\n\t\t\t       delta_ms, cfg_time);\n\t\t}\n\n\t\t \n\t\tif (in_closed_after_out)\n\t\t\tfprintf(stderr, \"%d\", delta_ms);\n\t}\n\n\treturn 0;\n}\n\nstatic void check_sockaddr(int pf, struct sockaddr_storage *ss,\n\t\t\t   socklen_t salen)\n{\n\tstruct sockaddr_in6 *sin6;\n\tstruct sockaddr_in *sin;\n\tsocklen_t wanted_size = 0;\n\n\tswitch (pf) {\n\tcase AF_INET:\n\t\twanted_size = sizeof(*sin);\n\t\tsin = (void *)ss;\n\t\tif (!sin->sin_port)\n\t\t\tfprintf(stderr, \"accept: something wrong: ip connection from port 0\");\n\t\tbreak;\n\tcase AF_INET6:\n\t\twanted_size = sizeof(*sin6);\n\t\tsin6 = (void *)ss;\n\t\tif (!sin6->sin6_port)\n\t\t\tfprintf(stderr, \"accept: something wrong: ipv6 connection from port 0\");\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"accept: Unknown pf %d, salen %u\\n\", pf, salen);\n\t\treturn;\n\t}\n\n\tif (salen != wanted_size)\n\t\tfprintf(stderr, \"accept: size mismatch, got %d expected %d\\n\",\n\t\t\t(int)salen, wanted_size);\n\n\tif (ss->ss_family != pf)\n\t\tfprintf(stderr, \"accept: pf mismatch, expect %d, ss_family is %d\\n\",\n\t\t\t(int)ss->ss_family, pf);\n}\n\nstatic void check_getpeername(int fd, struct sockaddr_storage *ss, socklen_t salen)\n{\n\tstruct sockaddr_storage peerss;\n\tsocklen_t peersalen = sizeof(peerss);\n\n\tif (getpeername(fd, (struct sockaddr *)&peerss, &peersalen) < 0) {\n\t\tperror(\"getpeername\");\n\t\treturn;\n\t}\n\n\tif (peersalen != salen) {\n\t\tfprintf(stderr, \"%s: %d vs %d\\n\", __func__, peersalen, salen);\n\t\treturn;\n\t}\n\n\tif (memcmp(ss, &peerss, peersalen)) {\n\t\tchar a[INET6_ADDRSTRLEN];\n\t\tchar b[INET6_ADDRSTRLEN];\n\t\tchar c[INET6_ADDRSTRLEN];\n\t\tchar d[INET6_ADDRSTRLEN];\n\n\t\txgetnameinfo((struct sockaddr *)ss, salen,\n\t\t\t     a, sizeof(a), b, sizeof(b));\n\n\t\txgetnameinfo((struct sockaddr *)&peerss, peersalen,\n\t\t\t     c, sizeof(c), d, sizeof(d));\n\n\t\tfprintf(stderr, \"%s: memcmp failure: accept %s vs peername %s, %s vs %s salen %d vs %d\\n\",\n\t\t\t__func__, a, c, b, d, peersalen, salen);\n\t}\n}\n\nstatic void check_getpeername_connect(int fd)\n{\n\tstruct sockaddr_storage ss;\n\tsocklen_t salen = sizeof(ss);\n\tchar a[INET6_ADDRSTRLEN];\n\tchar b[INET6_ADDRSTRLEN];\n\n\tif (getpeername(fd, (struct sockaddr *)&ss, &salen) < 0) {\n\t\tperror(\"getpeername\");\n\t\treturn;\n\t}\n\n\txgetnameinfo((struct sockaddr *)&ss, salen,\n\t\t     a, sizeof(a), b, sizeof(b));\n\n\tif (strcmp(cfg_host, a) || strcmp(cfg_port, b))\n\t\tfprintf(stderr, \"%s: %s vs %s, %s vs %s\\n\", __func__,\n\t\t\tcfg_host, a, cfg_port, b);\n}\n\nstatic void maybe_close(int fd)\n{\n\tunsigned int r = rand();\n\n\tif (!(cfg_join || cfg_remove || cfg_repeat > 1) && (r & 1))\n\t\tclose(fd);\n}\n\nint main_loop_s(int listensock)\n{\n\tstruct sockaddr_storage ss;\n\tstruct wstate winfo;\n\tstruct pollfd polls;\n\tsocklen_t salen;\n\tint remotesock;\n\tint fd = 0;\n\nagain:\n\tpolls.fd = listensock;\n\tpolls.events = POLLIN;\n\n\tswitch (poll(&polls, 1, poll_timeout)) {\n\tcase -1:\n\t\tperror(\"poll\");\n\t\treturn 1;\n\tcase 0:\n\t\tfprintf(stderr, \"%s: timed out\\n\", __func__);\n\t\tclose(listensock);\n\t\treturn 2;\n\t}\n\n\tsalen = sizeof(ss);\n\tremotesock = accept(listensock, (struct sockaddr *)&ss, &salen);\n\tif (remotesock >= 0) {\n\t\tmaybe_close(listensock);\n\t\tcheck_sockaddr(pf, &ss, salen);\n\t\tcheck_getpeername(remotesock, &ss, salen);\n\n\t\tif (cfg_input) {\n\t\t\tfd = open(cfg_input, O_RDONLY);\n\t\t\tif (fd < 0)\n\t\t\t\txerror(\"can't open %s: %d\", cfg_input, errno);\n\t\t}\n\n\t\tSOCK_TEST_TCPULP(remotesock, 0);\n\n\t\tmemset(&winfo, 0, sizeof(winfo));\n\t\tcopyfd_io(fd, remotesock, 1, true, &winfo);\n\t} else {\n\t\tperror(\"accept\");\n\t\treturn 1;\n\t}\n\n\tif (--cfg_repeat > 0) {\n\t\tif (cfg_input)\n\t\t\tclose(fd);\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}\n\nstatic void init_rng(void)\n{\n\tunsigned int foo;\n\n\tif (getrandom(&foo, sizeof(foo), 0) == -1) {\n\t\tperror(\"getrandom\");\n\t\texit(1);\n\t}\n\n\tsrand(foo);\n}\n\nstatic void xsetsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen)\n{\n\tint err;\n\n\terr = setsockopt(fd, level, optname, optval, optlen);\n\tif (err) {\n\t\tperror(\"setsockopt\");\n\t\texit(1);\n\t}\n}\n\nstatic void apply_cmsg_types(int fd, const struct cfg_cmsg_types *cmsg)\n{\n\tstatic const unsigned int on = 1;\n\n\tif (cmsg->timestampns)\n\t\txsetsockopt(fd, SOL_SOCKET, SO_TIMESTAMPNS_NEW, &on, sizeof(on));\n\tif (cmsg->tcp_inq)\n\t\txsetsockopt(fd, IPPROTO_TCP, TCP_INQ, &on, sizeof(on));\n}\n\nstatic void parse_cmsg_types(const char *type)\n{\n\tchar *next = strchr(type, ',');\n\tunsigned int len = 0;\n\n\tcfg_cmsg_types.cmsg_enabled = 1;\n\n\tif (next) {\n\t\tparse_cmsg_types(next + 1);\n\t\tlen = next - type;\n\t} else {\n\t\tlen = strlen(type);\n\t}\n\n\tif (strncmp(type, \"TIMESTAMPNS\", len) == 0) {\n\t\tcfg_cmsg_types.timestampns = 1;\n\t\treturn;\n\t}\n\n\tif (strncmp(type, \"TCPINQ\", len) == 0) {\n\t\tcfg_cmsg_types.tcp_inq = 1;\n\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Unrecognized cmsg option %s\\n\", type);\n\texit(1);\n}\n\nstatic void parse_setsock_options(const char *name)\n{\n\tchar *next = strchr(name, ',');\n\tunsigned int len = 0;\n\n\tif (next) {\n\t\tparse_setsock_options(next + 1);\n\t\tlen = next - name;\n\t} else {\n\t\tlen = strlen(name);\n\t}\n\n\tif (strncmp(name, \"TRANSPARENT\", len) == 0) {\n\t\tcfg_sockopt_types.transparent = 1;\n\t\treturn;\n\t}\n\n\tif (strncmp(name, \"MPTFO\", len) == 0) {\n\t\tcfg_sockopt_types.mptfo = 1;\n\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Unrecognized setsockopt option %s\\n\", name);\n\texit(1);\n}\n\nvoid xdisconnect(int fd, int addrlen)\n{\n\tstruct sockaddr_storage empty;\n\tint msec_sleep = 10;\n\tint queued = 1;\n\tint i;\n\n\tshutdown(fd, SHUT_WR);\n\n\t \n\tfor (i = 0; ; i += msec_sleep) {\n\t\tif (ioctl(fd, SIOCOUTQ, &queued) < 0)\n\t\t\txerror(\"can't query out socket queue: %d\", errno);\n\n\t\tif (!queued)\n\t\t\tbreak;\n\n\t\tif (i > poll_timeout)\n\t\t\txerror(\"timeout while waiting for spool to complete\");\n\t\tusleep(msec_sleep * 1000);\n\t}\n\n\tmemset(&empty, 0, sizeof(empty));\n\tempty.ss_family = AF_UNSPEC;\n\tif (connect(fd, (struct sockaddr *)&empty, addrlen) < 0)\n\t\txerror(\"can't disconnect: %d\", errno);\n}\n\nint main_loop(void)\n{\n\tint fd = 0, ret, fd_in = 0;\n\tstruct addrinfo *peer;\n\tstruct wstate winfo;\n\n\tif (cfg_input && cfg_sockopt_types.mptfo) {\n\t\tfd_in = open(cfg_input, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\txerror(\"can't open %s:%d\", cfg_input, errno);\n\t}\n\n\tmemset(&winfo, 0, sizeof(winfo));\n\tfd = sock_connect_mptcp(cfg_host, cfg_port, cfg_sock_proto, &peer, fd_in, &winfo);\n\tif (fd < 0)\n\t\treturn 2;\n\nagain:\n\tcheck_getpeername_connect(fd);\n\n\tSOCK_TEST_TCPULP(fd, cfg_sock_proto);\n\n\tif (cfg_rcvbuf)\n\t\tset_rcvbuf(fd, cfg_rcvbuf);\n\tif (cfg_sndbuf)\n\t\tset_sndbuf(fd, cfg_sndbuf);\n\tif (cfg_cmsg_types.cmsg_enabled)\n\t\tapply_cmsg_types(fd, &cfg_cmsg_types);\n\n\tif (cfg_input && !cfg_sockopt_types.mptfo) {\n\t\tfd_in = open(cfg_input, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\txerror(\"can't open %s:%d\", cfg_input, errno);\n\t}\n\n\tret = copyfd_io(fd_in, fd, 1, 0, &winfo);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cfg_truncate > 0) {\n\t\txdisconnect(fd, peer->ai_addrlen);\n\t} else if (--cfg_repeat > 0) {\n\t\txdisconnect(fd, peer->ai_addrlen);\n\n\t\t \n\t\tset_nonblock(fd, false);\n\t\tif (connect(fd, peer->ai_addr, peer->ai_addrlen))\n\t\t\txerror(\"can't reconnect: %d\", errno);\n\t\tif (cfg_input)\n\t\t\tclose(fd_in);\n\t\tmemset(&winfo, 0, sizeof(winfo));\n\t\tgoto again;\n\t} else {\n\t\tclose(fd);\n\t}\n\n\treturn 0;\n}\n\nint parse_proto(const char *proto)\n{\n\tif (!strcasecmp(proto, \"MPTCP\"))\n\t\treturn IPPROTO_MPTCP;\n\tif (!strcasecmp(proto, \"TCP\"))\n\t\treturn IPPROTO_TCP;\n\n\tfprintf(stderr, \"Unknown protocol: %s\\n.\", proto);\n\tdie_usage();\n\n\t \n\treturn 0;\n}\n\nint parse_mode(const char *mode)\n{\n\tif (!strcasecmp(mode, \"poll\"))\n\t\treturn CFG_MODE_POLL;\n\tif (!strcasecmp(mode, \"mmap\"))\n\t\treturn CFG_MODE_MMAP;\n\tif (!strcasecmp(mode, \"sendfile\"))\n\t\treturn CFG_MODE_SENDFILE;\n\n\tfprintf(stderr, \"Unknown test mode: %s\\n\", mode);\n\tfprintf(stderr, \"Supported modes are:\\n\");\n\tfprintf(stderr, \"\\t\\t\\\"poll\\\" - interleaved read/write using poll()\\n\");\n\tfprintf(stderr, \"\\t\\t\\\"mmap\\\" - send entire input file (mmap+write), then read response (-l will read input first)\\n\");\n\tfprintf(stderr, \"\\t\\t\\\"sendfile\\\" - send entire input file (sendfile), then read response (-l will read input first)\\n\");\n\n\tdie_usage();\n\n\t \n\treturn 0;\n}\n\nint parse_peek(const char *mode)\n{\n\tif (!strcasecmp(mode, \"saveWithPeek\"))\n\t\treturn CFG_WITH_PEEK;\n\tif (!strcasecmp(mode, \"saveAfterPeek\"))\n\t\treturn CFG_AFTER_PEEK;\n\n\tfprintf(stderr, \"Unknown: %s\\n\", mode);\n\tfprintf(stderr, \"Supported MSG_PEEK mode are:\\n\");\n\tfprintf(stderr,\n\t\t\"\\t\\t\\\"saveWithPeek\\\" - recv data with flags 'MSG_PEEK' and save the peek data into file\\n\");\n\tfprintf(stderr,\n\t\t\"\\t\\t\\\"saveAfterPeek\\\" - read and save data into file after recv with flags 'MSG_PEEK'\\n\");\n\n\tdie_usage();\n\n\t \n\treturn 0;\n}\n\nstatic int parse_int(const char *size)\n{\n\tunsigned long s;\n\n\terrno = 0;\n\n\ts = strtoul(size, NULL, 0);\n\n\tif (errno) {\n\t\tfprintf(stderr, \"Invalid sndbuf size %s (%s)\\n\",\n\t\t\tsize, strerror(errno));\n\t\tdie_usage();\n\t}\n\n\tif (s > INT_MAX) {\n\t\tfprintf(stderr, \"Invalid sndbuf size %s (%s)\\n\",\n\t\t\tsize, strerror(ERANGE));\n\t\tdie_usage();\n\t}\n\n\treturn (int)s;\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"6c:f:hi:I:jlm:M:o:p:P:r:R:s:S:t:T:w:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'f':\n\t\t\tcfg_truncate = atoi(optarg);\n\n\t\t\t \n\t\t\tif (cfg_truncate < 0) {\n\t\t\t\tcfg_rcv_trunc = true;\n\t\t\t\tsignal(SIGPIPE, handle_signal);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tcfg_join = true;\n\t\t\tcfg_mode = CFG_MODE_POLL;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcfg_remove = true;\n\t\t\tcfg_mode = CFG_MODE_POLL;\n\t\t\tcfg_wait = 400000;\n\t\t\tcfg_do_w = atoi(optarg);\n\t\t\tif (cfg_do_w <= 0)\n\t\t\t\tcfg_do_w = 50;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcfg_input = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tcfg_repeat = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlisten_mode = true;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcfg_port = optarg;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcfg_sock_proto = parse_proto(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tdie_usage();\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tpf = AF_INET6;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tpoll_timeout = atoi(optarg) * 1000;\n\t\t\tif (poll_timeout <= 0)\n\t\t\t\tpoll_timeout = -1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tcfg_time = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcfg_mode = parse_mode(optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tcfg_sndbuf = parse_int(optarg);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tcfg_rcvbuf = parse_int(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tcfg_wait = atoi(optarg)*1000000;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tcfg_mark = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcfg_peek = parse_peek(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tparse_cmsg_types(optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tparse_setsock_options(optarg);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind + 1 != argc)\n\t\tdie_usage();\n\tcfg_host = argv[optind];\n\n\tif (strchr(cfg_host, ':'))\n\t\tpf = AF_INET6;\n}\n\nint main(int argc, char *argv[])\n{\n\tinit_rng();\n\n\tsignal(SIGUSR1, handle_signal);\n\tparse_opts(argc, argv);\n\n\tif (listen_mode) {\n\t\tint fd = sock_listen_mptcp(cfg_host, cfg_port);\n\n\t\tif (fd < 0)\n\t\t\treturn 1;\n\n\t\tif (cfg_rcvbuf)\n\t\t\tset_rcvbuf(fd, cfg_rcvbuf);\n\t\tif (cfg_sndbuf)\n\t\t\tset_sndbuf(fd, cfg_sndbuf);\n\t\tif (cfg_mark)\n\t\t\tset_mark(fd, cfg_mark);\n\t\tif (cfg_cmsg_types.cmsg_enabled)\n\t\t\tapply_cmsg_types(fd, &cfg_cmsg_types);\n\n\t\treturn main_loop_s(fd);\n\t}\n\n\treturn main_loop();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}