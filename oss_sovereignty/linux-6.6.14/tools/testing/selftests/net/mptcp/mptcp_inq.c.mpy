{
  "module_name": "mptcp_inq.c",
  "hash_id": "8c02f9c436db7602e0b73ec89883f763dcd71fa0e098ef219734f40629e6aa1c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/mptcp/mptcp_inq.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <unistd.h>\n#include <time.h>\n\n#include <sys/ioctl.h>\n#include <sys/random.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <netdb.h>\n#include <netinet/in.h>\n\n#include <linux/tcp.h>\n#include <linux/sockios.h>\n\n#ifndef IPPROTO_MPTCP\n#define IPPROTO_MPTCP 262\n#endif\n#ifndef SOL_MPTCP\n#define SOL_MPTCP 284\n#endif\n\nstatic int pf = AF_INET;\nstatic int proto_tx = IPPROTO_MPTCP;\nstatic int proto_rx = IPPROTO_MPTCP;\n\nstatic void die_perror(const char *msg)\n{\n\tperror(msg);\n\texit(1);\n}\n\nstatic void die_usage(int r)\n{\n\tfprintf(stderr, \"Usage: mptcp_inq [-6] [ -t tcp|mptcp ] [ -r tcp|mptcp]\\n\");\n\texit(r);\n}\n\nstatic void xerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tfputc('\\n', stderr);\n\texit(1);\n}\n\nstatic const char *getxinfo_strerr(int err)\n{\n\tif (err == EAI_SYSTEM)\n\t\treturn strerror(errno);\n\n\treturn gai_strerror(err);\n}\n\nstatic void xgetaddrinfo(const char *node, const char *service,\n\t\t\t const struct addrinfo *hints,\n\t\t\t struct addrinfo **res)\n{\n\tint err = getaddrinfo(node, service, hints, res);\n\n\tif (err) {\n\t\tconst char *errstr = getxinfo_strerr(err);\n\n\t\tfprintf(stderr, \"Fatal: getaddrinfo(%s:%s): %s\\n\",\n\t\t\tnode ? node : \"\", service ? service : \"\", errstr);\n\t\texit(1);\n\t}\n}\n\nstatic int sock_listen_mptcp(const char * const listenaddr,\n\t\t\t     const char * const port)\n{\n\tint sock = -1;\n\tstruct addrinfo hints = {\n\t\t.ai_protocol = IPPROTO_TCP,\n\t\t.ai_socktype = SOCK_STREAM,\n\t\t.ai_flags = AI_PASSIVE | AI_NUMERICHOST\n\t};\n\n\thints.ai_family = pf;\n\n\tstruct addrinfo *a, *addr;\n\tint one = 1;\n\n\txgetaddrinfo(listenaddr, port, &hints, &addr);\n\thints.ai_family = pf;\n\n\tfor (a = addr; a; a = a->ai_next) {\n\t\tsock = socket(a->ai_family, a->ai_socktype, proto_rx);\n\t\tif (sock < 0)\n\t\t\tcontinue;\n\n\t\tif (-1 == setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one,\n\t\t\t\t     sizeof(one)))\n\t\t\tperror(\"setsockopt\");\n\n\t\tif (bind(sock, a->ai_addr, a->ai_addrlen) == 0)\n\t\t\tbreak;  \n\n\t\tperror(\"bind\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t}\n\n\tfreeaddrinfo(addr);\n\n\tif (sock < 0)\n\t\txerror(\"could not create listen socket\");\n\n\tif (listen(sock, 20))\n\t\tdie_perror(\"listen\");\n\n\treturn sock;\n}\n\nstatic int sock_connect_mptcp(const char * const remoteaddr,\n\t\t\t      const char * const port, int proto)\n{\n\tstruct addrinfo hints = {\n\t\t.ai_protocol = IPPROTO_TCP,\n\t\t.ai_socktype = SOCK_STREAM,\n\t};\n\tstruct addrinfo *a, *addr;\n\tint sock = -1;\n\n\thints.ai_family = pf;\n\n\txgetaddrinfo(remoteaddr, port, &hints, &addr);\n\tfor (a = addr; a; a = a->ai_next) {\n\t\tsock = socket(a->ai_family, a->ai_socktype, proto);\n\t\tif (sock < 0)\n\t\t\tcontinue;\n\n\t\tif (connect(sock, a->ai_addr, a->ai_addrlen) == 0)\n\t\t\tbreak;  \n\n\t\tdie_perror(\"connect\");\n\t}\n\n\tif (sock < 0)\n\t\txerror(\"could not create connect socket\");\n\n\tfreeaddrinfo(addr);\n\treturn sock;\n}\n\nstatic int protostr_to_num(const char *s)\n{\n\tif (strcasecmp(s, \"tcp\") == 0)\n\t\treturn IPPROTO_TCP;\n\tif (strcasecmp(s, \"mptcp\") == 0)\n\t\treturn IPPROTO_MPTCP;\n\n\tdie_usage(1);\n\treturn 0;\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"h6t:r:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\t\tdie_usage(0);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tpf = AF_INET6;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tproto_tx = protostr_to_num(optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tproto_rx = protostr_to_num(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdie_usage(1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void wait_for_ack(int fd, int timeout, size_t total)\n{\n\tint i;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tint nsd, ret, queued = -1;\n\t\tstruct timespec req;\n\n\t\tret = ioctl(fd, TIOCOUTQ, &queued);\n\t\tif (ret < 0)\n\t\t\tdie_perror(\"TIOCOUTQ\");\n\n\t\tret = ioctl(fd, SIOCOUTQNSD, &nsd);\n\t\tif (ret < 0)\n\t\t\tdie_perror(\"SIOCOUTQNSD\");\n\n\t\tif ((size_t)queued > total)\n\t\t\txerror(\"TIOCOUTQ %u, but only %zu expected\\n\", queued, total);\n\t\tassert(nsd <= queued);\n\n\t\tif (queued == 0)\n\t\t\treturn;\n\n\t\t \n\t\treq.tv_sec = 0;\n\t\treq.tv_nsec = 1 * 1000 * 1000ul;  \n\t\tnanosleep(&req, NULL);\n\t}\n\n\txerror(\"still tx data queued after %u ms\\n\", timeout);\n}\n\nstatic void connect_one_server(int fd, int unixfd)\n{\n\tsize_t len, i, total, sent;\n\tchar buf[4096], buf2[4096];\n\tssize_t ret;\n\n\tlen = rand() % (sizeof(buf) - 1);\n\n\tif (len < 128)\n\t\tlen = 128;\n\n\tfor (i = 0; i < len ; i++) {\n\t\tbuf[i] = rand() % 26;\n\t\tbuf[i] += 'A';\n\t}\n\n\tbuf[i] = '\\n';\n\n\t \n\tret = read(unixfd, buf2, 4);\n\tassert(ret == 4);\n\n\tassert(strncmp(buf2, \"xmit\", 4) == 0);\n\n\tret = write(unixfd, &len, sizeof(len));\n\tassert(ret == (ssize_t)sizeof(len));\n\n\tret = write(fd, buf, len);\n\tif (ret < 0)\n\t\tdie_perror(\"write\");\n\n\tif (ret != (ssize_t)len)\n\t\txerror(\"short write\");\n\n\tret = read(unixfd, buf2, 4);\n\tassert(strncmp(buf2, \"huge\", 4) == 0);\n\n\ttotal = rand() % (16 * 1024 * 1024);\n\ttotal += (1 * 1024 * 1024);\n\tsent = total;\n\n\tret = write(unixfd, &total, sizeof(total));\n\tassert(ret == (ssize_t)sizeof(total));\n\n\twait_for_ack(fd, 5000, len);\n\n\twhile (total > 0) {\n\t\tif (total > sizeof(buf))\n\t\t\tlen = sizeof(buf);\n\t\telse\n\t\t\tlen = total;\n\n\t\tret = write(fd, buf, len);\n\t\tif (ret < 0)\n\t\t\tdie_perror(\"write\");\n\t\ttotal -= ret;\n\n\t\t \n\t}\n\n\tret = read(unixfd, buf2, 4);\n\tassert(ret == 4);\n\tassert(strncmp(buf2, \"shut\", 4) == 0);\n\n\twait_for_ack(fd, 5000, sent);\n\n\tret = write(fd, buf, 1);\n\tassert(ret == 1);\n\tclose(fd);\n\tret = write(unixfd, \"closed\", 6);\n\tassert(ret == 6);\n\n\tclose(unixfd);\n}\n\nstatic void get_tcp_inq(struct msghdr *msgh, unsigned int *inqv)\n{\n\tstruct cmsghdr *cmsg;\n\n\tfor (cmsg = CMSG_FIRSTHDR(msgh); cmsg ; cmsg = CMSG_NXTHDR(msgh, cmsg)) {\n\t\tif (cmsg->cmsg_level == IPPROTO_TCP && cmsg->cmsg_type == TCP_CM_INQ) {\n\t\t\tmemcpy(inqv, CMSG_DATA(cmsg), sizeof(*inqv));\n\t\t\treturn;\n\t\t}\n\t}\n\n\txerror(\"could not find TCP_CM_INQ cmsg type\");\n}\n\nstatic void process_one_client(int fd, int unixfd)\n{\n\tunsigned int tcp_inq;\n\tsize_t expect_len;\n\tchar msg_buf[4096];\n\tchar buf[4096];\n\tchar tmp[16];\n\tstruct iovec iov = {\n\t\t.iov_base = buf,\n\t\t.iov_len = 1,\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t\t.msg_control = msg_buf,\n\t\t.msg_controllen = sizeof(msg_buf),\n\t};\n\tssize_t ret, tot;\n\n\tret = write(unixfd, \"xmit\", 4);\n\tassert(ret == 4);\n\n\tret = read(unixfd, &expect_len, sizeof(expect_len));\n\tassert(ret == (ssize_t)sizeof(expect_len));\n\n\tif (expect_len > sizeof(buf))\n\t\txerror(\"expect len %zu exceeds buffer size\", expect_len);\n\n\tfor (;;) {\n\t\tstruct timespec req;\n\t\tunsigned int queued;\n\n\t\tret = ioctl(fd, FIONREAD, &queued);\n\t\tif (ret < 0)\n\t\t\tdie_perror(\"FIONREAD\");\n\t\tif (queued > expect_len)\n\t\t\txerror(\"FIONREAD returned %u, but only %zu expected\\n\",\n\t\t\t       queued, expect_len);\n\t\tif (queued == expect_len)\n\t\t\tbreak;\n\n\t\treq.tv_sec = 0;\n\t\treq.tv_nsec = 1000 * 1000ul;\n\t\tnanosleep(&req, NULL);\n\t}\n\n\t \n\tret = recvmsg(fd, &msg, 0);\n\tif (ret < 0)\n\t\tdie_perror(\"recvmsg\");\n\n\tif (msg.msg_controllen == 0)\n\t\txerror(\"msg_controllen is 0\");\n\n\tget_tcp_inq(&msg, &tcp_inq);\n\n\tassert((size_t)tcp_inq == (expect_len - 1));\n\n\tiov.iov_len = sizeof(buf);\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret < 0)\n\t\tdie_perror(\"recvmsg\");\n\n\t \n\tassert(ret == (ssize_t)tcp_inq);\n\n\t \n\tget_tcp_inq(&msg, &tcp_inq);\n\tassert(tcp_inq == 0);\n\n\t \n\tret = write(unixfd, \"huge\", 4);\n\tassert(ret == 4);\n\n\tret = read(unixfd, &expect_len, sizeof(expect_len));\n\tassert(ret == (ssize_t)sizeof(expect_len));\n\n\t \n\tif (expect_len <= sizeof(buf))\n\t\txerror(\"expect len %zu too small\\n\", expect_len);\n\n\ttot = 0;\n\tdo {\n\t\tiov.iov_len = sizeof(buf);\n\t\tret = recvmsg(fd, &msg, 0);\n\t\tif (ret < 0)\n\t\t\tdie_perror(\"recvmsg\");\n\n\t\ttot += ret;\n\n\t\tget_tcp_inq(&msg, &tcp_inq);\n\n\t\tif (tcp_inq > expect_len - tot)\n\t\t\txerror(\"inq %d, remaining %d total_len %d\\n\",\n\t\t\t       tcp_inq, expect_len - tot, (int)expect_len);\n\n\t\tassert(tcp_inq <= expect_len - tot);\n\t} while ((size_t)tot < expect_len);\n\n\tret = write(unixfd, \"shut\", 4);\n\tassert(ret == 4);\n\n\t \n\tret = read(unixfd, tmp, sizeof(tmp));\n\tassert(ret == 6);\n\tassert(strncmp(tmp, \"closed\", 6) == 0);\n\n\tsleep(1);\n\n\tiov.iov_len = 1;\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret < 0)\n\t\tdie_perror(\"recvmsg\");\n\tassert(ret == 1);\n\n\tget_tcp_inq(&msg, &tcp_inq);\n\n\t \n\tassert(tcp_inq == 1);\n\n\tiov.iov_len = 1;\n\tret = recvmsg(fd, &msg, 0);\n\tif (ret < 0)\n\t\tdie_perror(\"recvmsg\");\n\n\t \n\tassert(ret == 0);\n\tget_tcp_inq(&msg, &tcp_inq);\n\tassert(tcp_inq == 1);\n\n\tclose(fd);\n}\n\nstatic int xaccept(int s)\n{\n\tint fd = accept(s, NULL, 0);\n\n\tif (fd < 0)\n\t\tdie_perror(\"accept\");\n\n\treturn fd;\n}\n\nstatic int server(int unixfd)\n{\n\tint fd = -1, r, on = 1;\n\n\tswitch (pf) {\n\tcase AF_INET:\n\t\tfd = sock_listen_mptcp(\"127.0.0.1\", \"15432\");\n\t\tbreak;\n\tcase AF_INET6:\n\t\tfd = sock_listen_mptcp(\"::1\", \"15432\");\n\t\tbreak;\n\tdefault:\n\t\txerror(\"Unknown pf %d\\n\", pf);\n\t\tbreak;\n\t}\n\n\tr = write(unixfd, \"conn\", 4);\n\tassert(r == 4);\n\n\talarm(15);\n\tr = xaccept(fd);\n\n\tif (-1 == setsockopt(r, IPPROTO_TCP, TCP_INQ, &on, sizeof(on)))\n\t\tdie_perror(\"setsockopt\");\n\n\tprocess_one_client(r, unixfd);\n\n\treturn 0;\n}\n\nstatic int client(int unixfd)\n{\n\tint fd = -1;\n\n\talarm(15);\n\n\tswitch (pf) {\n\tcase AF_INET:\n\t\tfd = sock_connect_mptcp(\"127.0.0.1\", \"15432\", proto_tx);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tfd = sock_connect_mptcp(\"::1\", \"15432\", proto_tx);\n\t\tbreak;\n\tdefault:\n\t\txerror(\"Unknown pf %d\\n\", pf);\n\t}\n\n\tconnect_one_server(fd, unixfd);\n\n\treturn 0;\n}\n\nstatic void init_rng(void)\n{\n\tunsigned int foo;\n\n\tif (getrandom(&foo, sizeof(foo), 0) == -1) {\n\t\tperror(\"getrandom\");\n\t\texit(1);\n\t}\n\n\tsrand(foo);\n}\n\nstatic pid_t xfork(void)\n{\n\tpid_t p = fork();\n\n\tif (p < 0)\n\t\tdie_perror(\"fork\");\n\telse if (p == 0)\n\t\tinit_rng();\n\n\treturn p;\n}\n\nstatic int rcheck(int wstatus, const char *what)\n{\n\tif (WIFEXITED(wstatus)) {\n\t\tif (WEXITSTATUS(wstatus) == 0)\n\t\t\treturn 0;\n\t\tfprintf(stderr, \"%s exited, status=%d\\n\", what, WEXITSTATUS(wstatus));\n\t\treturn WEXITSTATUS(wstatus);\n\t} else if (WIFSIGNALED(wstatus)) {\n\t\txerror(\"%s killed by signal %d\\n\", what, WTERMSIG(wstatus));\n\t} else if (WIFSTOPPED(wstatus)) {\n\t\txerror(\"%s stopped by signal %d\\n\", what, WSTOPSIG(wstatus));\n\t}\n\n\treturn 111;\n}\n\nint main(int argc, char *argv[])\n{\n\tint e1, e2, wstatus;\n\tpid_t s, c, ret;\n\tint unixfds[2];\n\n\tparse_opts(argc, argv);\n\n\te1 = socketpair(AF_UNIX, SOCK_DGRAM, 0, unixfds);\n\tif (e1 < 0)\n\t\tdie_perror(\"pipe\");\n\n\ts = xfork();\n\tif (s == 0)\n\t\treturn server(unixfds[1]);\n\n\tclose(unixfds[1]);\n\n\t \n\te1 = read(unixfds[0], &e1, 4);\n\tassert(e1 == 4);\n\n\tc = xfork();\n\tif (c == 0)\n\t\treturn client(unixfds[0]);\n\n\tclose(unixfds[0]);\n\n\tret = waitpid(s, &wstatus, 0);\n\tif (ret == -1)\n\t\tdie_perror(\"waitpid\");\n\te1 = rcheck(wstatus, \"server\");\n\tret = waitpid(c, &wstatus, 0);\n\tif (ret == -1)\n\t\tdie_perror(\"waitpid\");\n\te2 = rcheck(wstatus, \"client\");\n\n\treturn e1 ? e1 : e2;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}