{
  "module_name": "diag.sh",
  "hash_id": "3cad80f49ef2de25ec79f835c8973619980f6abb912f97d8a6fe31d112791828",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/mptcp/diag.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n. \"$(dirname \"${0}\")/mptcp_lib.sh\"\n\nsec=$(date +%s)\nrndh=$(printf %x $sec)-$(mktemp -u XXXXXX)\nns=\"ns1-$rndh\"\nksft_skip=4\ntest_cnt=1\ntimeout_poll=100\ntimeout_test=$((timeout_poll * 2 + 1))\nret=0\n\nflush_pids()\n{\n\t# mptcp_connect in join mode will sleep a bit before completing,\n\t# give it some time\n\tsleep 1.1\n\n\tip netns pids \"${ns}\" | xargs --no-run-if-empty kill -SIGUSR1 &>/dev/null\n\n\tfor _ in $(seq 10); do\n\t\t[ -z \"$(ip netns pids \"${ns}\")\" ] && break\n\t\tsleep 0.1\n\tdone\n}\n\ncleanup()\n{\n\tip netns pids \"${ns}\" | xargs --no-run-if-empty kill -SIGKILL &>/dev/null\n\n\tip netns del $ns\n}\n\nmptcp_lib_check_mptcp\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\nss -h | grep -q MPTCP\nif [ $? -ne 0 ];then\n\techo \"SKIP: ss tool does not support MPTCP\"\n\texit $ksft_skip\nfi\n\nget_msk_inuse()\n{\n\tip netns exec $ns cat /proc/net/protocols | awk '$1~/^MPTCP$/{print $3}'\n}\n\n__chk_nr()\n{\n\tlocal command=\"$1\"\n\tlocal expected=$2\n\tlocal msg=\"$3\"\n\tlocal skip=\"${4:-SKIP}\"\n\tlocal nr\n\n\tnr=$(eval $command)\n\n\tprintf \"%-50s\" \"$msg\"\n\tif [ $nr != $expected ]; then\n\t\tif [ $nr = \"$skip\" ] && ! mptcp_lib_expect_all_features; then\n\t\t\techo \"[ skip ] Feature probably not supported\"\n\t\t\tmptcp_lib_result_skip \"${msg}\"\n\t\telse\n\t\t\techo \"[ fail ] expected $expected found $nr\"\n\t\t\tmptcp_lib_result_fail \"${msg}\"\n\t\t\tret=$test_cnt\n\t\tfi\n\telse\n\t\techo \"[  ok  ]\"\n\t\tmptcp_lib_result_pass \"${msg}\"\n\tfi\n\ttest_cnt=$((test_cnt+1))\n}\n\n__chk_msk_nr()\n{\n\tlocal condition=$1\n\tshift 1\n\n\t__chk_nr \"ss -inmHMN $ns | $condition\" \"$@\"\n}\n\nchk_msk_nr()\n{\n\t__chk_msk_nr \"grep -c token:\" \"$@\"\n}\n\nwait_msk_nr()\n{\n\tlocal condition=\"grep -c token:\"\n\tlocal expected=$1\n\tlocal timeout=20\n\tlocal msg nr\n\tlocal max=0\n\tlocal i=0\n\n\tshift 1\n\tmsg=$*\n\n\twhile [ $i -lt $timeout ]; do\n\t\tnr=$(ss -inmHMN $ns | $condition)\n\t\t[ $nr == $expected ] && break;\n\t\t[ $nr -gt $max ] && max=$nr\n\t\ti=$((i + 1))\n\t\tsleep 1\n\tdone\n\n\tprintf \"%-50s\" \"$msg\"\n\tif [ $i -ge $timeout ]; then\n\t\techo \"[ fail ] timeout while expecting $expected max $max last $nr\"\n\t\tmptcp_lib_result_fail \"${msg} # timeout\"\n\t\tret=$test_cnt\n\telif [ $nr != $expected ]; then\n\t\techo \"[ fail ] expected $expected found $nr\"\n\t\tmptcp_lib_result_fail \"${msg} # unexpected result\"\n\t\tret=$test_cnt\n\telse\n\t\techo \"[  ok  ]\"\n\t\tmptcp_lib_result_pass \"${msg}\"\n\tfi\n\ttest_cnt=$((test_cnt+1))\n}\n\nchk_msk_fallback_nr()\n{\n\t__chk_msk_nr \"grep -c fallback\" \"$@\"\n}\n\nchk_msk_remote_key_nr()\n{\n\t__chk_msk_nr \"grep -c remote_key\" \"$@\"\n}\n\n__chk_listen()\n{\n\tlocal filter=\"$1\"\n\tlocal expected=$2\n\tlocal msg=\"$3\"\n\n\t__chk_nr \"ss -N $ns -Ml '$filter' | grep -c LISTEN\" \"$expected\" \"$msg\" 0\n}\n\nchk_msk_listen()\n{\n\tlport=$1\n\n\t# destination port search should always return empty list\n\t__chk_listen \"dport $lport\" 0 \"listen match for dport $lport\"\n\n\t# should return 'our' mptcp listen socket\n\t__chk_listen \"sport $lport\" 1 \"listen match for sport $lport\"\n\n\t__chk_listen \"src inet:0.0.0.0:$lport\" 1 \"listen match for saddr and sport\"\n\n\t__chk_listen \"\" 1 \"all listen sockets\"\n\n\tnr=$(ss -Ml $filter | wc -l)\n}\n\nchk_msk_inuse()\n{\n\tlocal expected=$1\n\tlocal msg=\"$2\"\n\tlocal listen_nr\n\n\tlisten_nr=$(ss -N \"${ns}\" -Ml | grep -c LISTEN)\n\texpected=$((expected + listen_nr))\n\n\tfor _ in $(seq 10); do\n\t\tif [ $(get_msk_inuse) -eq $expected ];then\n\t\t\tbreak\n\t\tfi\n\t\tsleep 0.1\n\tdone\n\n\t__chk_nr get_msk_inuse $expected \"$msg\" 0\n}\n\n# $1: ns, $2: port\nwait_local_port_listen()\n{\n\tlocal listener_ns=\"${1}\"\n\tlocal port=\"${2}\"\n\n\tlocal port_hex i\n\n\tport_hex=\"$(printf \"%04X\" \"${port}\")\"\n\tfor i in $(seq 10); do\n\t\tip netns exec \"${listener_ns}\" cat /proc/net/tcp | \\\n\t\t\tawk \"BEGIN {rc=1} {if (\\$2 ~ /:${port_hex}\\$/ && \\$4 ~ /0A/) {rc=0; exit}} END {exit rc}\" &&\n\t\t\tbreak\n\t\tsleep 0.1\n\tdone\n}\n\nwait_connected()\n{\n\tlocal listener_ns=\"${1}\"\n\tlocal port=\"${2}\"\n\n\tlocal port_hex i\n\n\tport_hex=\"$(printf \"%04X\" \"${port}\")\"\n\tfor i in $(seq 10); do\n\t\tip netns exec ${listener_ns} grep -q \" 0100007F:${port_hex} \" /proc/net/tcp && break\n\t\tsleep 0.1\n\tdone\n}\n\ntrap cleanup EXIT\nip netns add $ns\nip -n $ns link set dev lo up\n\necho \"a\" | \\\n\ttimeout ${timeout_test} \\\n\t\tip netns exec $ns \\\n\t\t\t./mptcp_connect -p 10000 -l -t ${timeout_poll} -w 20 \\\n\t\t\t\t0.0.0.0 >/dev/null &\nwait_local_port_listen $ns 10000\nchk_msk_nr 0 \"no msk on netns creation\"\nchk_msk_listen 10000\n\necho \"b\" | \\\n\ttimeout ${timeout_test} \\\n\t\tip netns exec $ns \\\n\t\t\t./mptcp_connect -p 10000 -r 0 -t ${timeout_poll} -w 20 \\\n\t\t\t\t127.0.0.1 >/dev/null &\nwait_connected $ns 10000\nchk_msk_nr 2 \"after MPC handshake \"\nchk_msk_remote_key_nr 2 \"....chk remote_key\"\nchk_msk_fallback_nr 0 \"....chk no fallback\"\nchk_msk_inuse 2 \"....chk 2 msk in use\"\nflush_pids\n\nchk_msk_inuse 0 \"....chk 0 msk in use after flush\"\n\necho \"a\" | \\\n\ttimeout ${timeout_test} \\\n\t\tip netns exec $ns \\\n\t\t\t./mptcp_connect -p 10001 -l -s TCP -t ${timeout_poll} -w 20 \\\n\t\t\t\t0.0.0.0 >/dev/null &\nwait_local_port_listen $ns 10001\necho \"b\" | \\\n\ttimeout ${timeout_test} \\\n\t\tip netns exec $ns \\\n\t\t\t./mptcp_connect -p 10001 -r 0 -t ${timeout_poll} -w 20 \\\n\t\t\t\t127.0.0.1 >/dev/null &\nwait_connected $ns 10001\nchk_msk_fallback_nr 1 \"check fallback\"\nchk_msk_inuse 1 \"....chk 1 msk in use\"\nflush_pids\n\nchk_msk_inuse 0 \"....chk 0 msk in use after flush\"\n\nNR_CLIENTS=100\nfor I in `seq 1 $NR_CLIENTS`; do\n\techo \"a\" | \\\n\t\ttimeout ${timeout_test} \\\n\t\t\tip netns exec $ns \\\n\t\t\t\t./mptcp_connect -p $((I+10001)) -l -w 20 \\\n\t\t\t\t\t-t ${timeout_poll} 0.0.0.0 >/dev/null &\ndone\nwait_local_port_listen $ns $((NR_CLIENTS + 10001))\n\nfor I in `seq 1 $NR_CLIENTS`; do\n\techo \"b\" | \\\n\t\ttimeout ${timeout_test} \\\n\t\t\tip netns exec $ns \\\n\t\t\t\t./mptcp_connect -p $((I+10001)) -w 20 \\\n\t\t\t\t\t-t ${timeout_poll} 127.0.0.1 >/dev/null &\ndone\n\nwait_msk_nr $((NR_CLIENTS*2)) \"many msk socket present\"\nchk_msk_inuse $((NR_CLIENTS*2)) \"....chk many msk in use\"\nflush_pids\n\nchk_msk_inuse 0 \"....chk 0 msk in use after flush\"\n\nmptcp_lib_result_print_all_tap\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}