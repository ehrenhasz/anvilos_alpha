{
  "module_name": "mptcp_connect.sh",
  "hash_id": "294a07874a38bba0b0ebeb3f793021869aa48f9d06ed6e1e093562206f453b46",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/mptcp/mptcp_connect.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n. \"$(dirname \"${0}\")/mptcp_lib.sh\"\n\ntime_start=$(date +%s)\n\noptstring=\"S:R:d:e:l:r:h4cm:f:tC\"\nret=0\nfinal_ret=0\nsin=\"\"\nsout=\"\"\ncin_disconnect=\"\"\ncin=\"\"\ncout=\"\"\nksft_skip=4\ncapture=false\ntimeout_poll=30\ntimeout_test=$((timeout_poll * 2 + 1))\nipv6=true\nethtool_random_on=true\ntc_delay=\"$((RANDOM%50))\"\ntc_loss=$((RANDOM%101))\ntestmode=\"\"\nsndbuf=0\nrcvbuf=0\noptions_log=true\ndo_tcp=0\nchecksum=false\nfilesize=0\nconnect_per_transfer=1\n\nif [ $tc_loss -eq 100 ];then\n\ttc_loss=1%\nelif [ $tc_loss -ge 10 ]; then\n\ttc_loss=0.$tc_loss%\nelif [ $tc_loss -ge 1 ]; then\n\ttc_loss=0.0$tc_loss%\nelse\n\ttc_loss=\"\"\nfi\n\nusage() {\n\techo \"Usage: $0 [ -a ]\"\n\techo -e \"\\t-d: tc/netem delay in milliseconds, e.g. \\\"-d 10\\\" (default random)\"\n\techo -e \"\\t-l: tc/netem loss percentage, e.g. \\\"-l 0.02\\\" (default random)\"\n\techo -e \"\\t-r: tc/netem reorder mode, e.g. \\\"-r 25% 50% gap 5\\\", use \"-r 0\" to disable reordering (default random)\"\n\techo -e \"\\t-e: ethtool features to disable, e.g.: \\\"-e tso -e gso\\\" (default: randomly disable any of tso/gso/gro)\"\n\techo -e \"\\t-4: IPv4 only: disable IPv6 tests (default: test both IPv4 and IPv6)\"\n\techo -e \"\\t-c: capture packets for each test using tcpdump (default: no capture)\"\n\techo -e \"\\t-f: size of file to transfer in bytes (default random)\"\n\techo -e \"\\t-S: set sndbuf value (default: use kernel default)\"\n\techo -e \"\\t-R: set rcvbuf value (default: use kernel default)\"\n\techo -e \"\\t-m: test mode (poll, sendfile; default: poll)\"\n\techo -e \"\\t-t: also run tests with TCP (use twice to non-fallback tcp)\"\n\techo -e \"\\t-C: enable the MPTCP data checksum\"\n}\n\nwhile getopts \"$optstring\" option;do\n\tcase \"$option\" in\n\t\"h\")\n\t\tusage $0\n\t\texit 0\n\t\t;;\n\t\"d\")\n\t\tif [ $OPTARG -ge 0 ];then\n\t\t\ttc_delay=\"$OPTARG\"\n\t\telse\n\t\t\techo \"-d requires numeric argument, got \\\"$OPTARG\\\"\" 1>&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\t\"e\")\n\t\tethtool_args=\"$ethtool_args $OPTARG off\"\n\t\tethtool_random_on=false\n\t\t;;\n\t\"l\")\n\t\ttc_loss=\"$OPTARG\"\n\t\t;;\n\t\"r\")\n\t\ttc_reorder=\"$OPTARG\"\n\t\t;;\n\t\"4\")\n\t\tipv6=false\n\t\t;;\n\t\"c\")\n\t\tcapture=true\n\t\t;;\n\t\"S\")\n\t\tif [ $OPTARG -ge 0 ];then\n\t\t\tsndbuf=\"$OPTARG\"\n\t\telse\n\t\t\techo \"-S requires numeric argument, got \\\"$OPTARG\\\"\" 1>&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\t\"R\")\n\t\tif [ $OPTARG -ge 0 ];then\n\t\t\trcvbuf=\"$OPTARG\"\n\t\telse\n\t\t\techo \"-R requires numeric argument, got \\\"$OPTARG\\\"\" 1>&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\t\"m\")\n\t\ttestmode=\"$OPTARG\"\n\t\t;;\n\t\"f\")\n\t\tfilesize=\"$OPTARG\"\n\t\t;;\n\t\"t\")\n\t\tdo_tcp=$((do_tcp+1))\n\t\t;;\n\t\"C\")\n\t\tchecksum=true\n\t\t;;\n\t\"?\")\n\t\tusage $0\n\t\texit 1\n\t\t;;\n\tesac\ndone\n\nsec=$(date +%s)\nrndh=$(printf %x $sec)-$(mktemp -u XXXXXX)\nns1=\"ns1-$rndh\"\nns2=\"ns2-$rndh\"\nns3=\"ns3-$rndh\"\nns4=\"ns4-$rndh\"\n\nTEST_COUNT=0\nTEST_GROUP=\"\"\n\ncleanup()\n{\n\trm -f \"$cin_disconnect\" \"$cout_disconnect\"\n\trm -f \"$cin\" \"$cout\"\n\trm -f \"$sin\" \"$sout\"\n\trm -f \"$capout\"\n\n\tlocal netns\n\tfor netns in \"$ns1\" \"$ns2\" \"$ns3\" \"$ns4\";do\n\t\tip netns del $netns\n\t\trm -f /tmp/$netns.{nstat,out}\n\tdone\n}\n\nmptcp_lib_check_mptcp\nmptcp_lib_check_kallsyms\n\nip -Version > /dev/null 2>&1\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nsin=$(mktemp)\nsout=$(mktemp)\ncin=$(mktemp)\ncout=$(mktemp)\ncapout=$(mktemp)\ncin_disconnect=\"$cin\".disconnect\ncout_disconnect=\"$cout\".disconnect\ntrap cleanup EXIT\n\nfor i in \"$ns1\" \"$ns2\" \"$ns3\" \"$ns4\";do\n\tip netns add $i || exit $ksft_skip\n\tip -net $i link set lo up\ndone\n\n#  \"$ns1\"              ns2                    ns3                     ns4\n# ns1eth2    ns2eth1   ns2eth3      ns3eth2   ns3eth4       ns4eth3\n#                           - drop 1% ->            reorder 25%\n#                           <- TSO off -\n\nip link add ns1eth2 netns \"$ns1\" type veth peer name ns2eth1 netns \"$ns2\"\nip link add ns2eth3 netns \"$ns2\" type veth peer name ns3eth2 netns \"$ns3\"\nip link add ns3eth4 netns \"$ns3\" type veth peer name ns4eth3 netns \"$ns4\"\n\nip -net \"$ns1\" addr add 10.0.1.1/24 dev ns1eth2\nip -net \"$ns1\" addr add dead:beef:1::1/64 dev ns1eth2 nodad\n\nip -net \"$ns1\" link set ns1eth2 up\nip -net \"$ns1\" route add default via 10.0.1.2\nip -net \"$ns1\" route add default via dead:beef:1::2\n\nip -net \"$ns2\" addr add 10.0.1.2/24 dev ns2eth1\nip -net \"$ns2\" addr add dead:beef:1::2/64 dev ns2eth1 nodad\nip -net \"$ns2\" link set ns2eth1 up\n\nip -net \"$ns2\" addr add 10.0.2.1/24 dev ns2eth3\nip -net \"$ns2\" addr add dead:beef:2::1/64 dev ns2eth3 nodad\nip -net \"$ns2\" link set ns2eth3 up\nip -net \"$ns2\" route add default via 10.0.2.2\nip -net \"$ns2\" route add default via dead:beef:2::2\nip netns exec \"$ns2\" sysctl -q net.ipv4.ip_forward=1\nip netns exec \"$ns2\" sysctl -q net.ipv6.conf.all.forwarding=1\n\nip -net \"$ns3\" addr add 10.0.2.2/24 dev ns3eth2\nip -net \"$ns3\" addr add dead:beef:2::2/64 dev ns3eth2 nodad\nip -net \"$ns3\" link set ns3eth2 up\n\nip -net \"$ns3\" addr add 10.0.3.2/24 dev ns3eth4\nip -net \"$ns3\" addr add dead:beef:3::2/64 dev ns3eth4 nodad\nip -net \"$ns3\" link set ns3eth4 up\nip -net \"$ns3\" route add default via 10.0.2.1\nip -net \"$ns3\" route add default via dead:beef:2::1\nip netns exec \"$ns3\" sysctl -q net.ipv4.ip_forward=1\nip netns exec \"$ns3\" sysctl -q net.ipv6.conf.all.forwarding=1\n\nip -net \"$ns4\" addr add 10.0.3.1/24 dev ns4eth3\nip -net \"$ns4\" addr add dead:beef:3::1/64 dev ns4eth3 nodad\nip -net \"$ns4\" link set ns4eth3 up\nip -net \"$ns4\" route add default via 10.0.3.2\nip -net \"$ns4\" route add default via dead:beef:3::2\n\nif $checksum; then\n\tfor i in \"$ns1\" \"$ns2\" \"$ns3\" \"$ns4\";do\n\t\tip netns exec $i sysctl -q net.mptcp.checksum_enabled=1\n\tdone\nfi\n\nset_ethtool_flags() {\n\tlocal ns=\"$1\"\n\tlocal dev=\"$2\"\n\tlocal flags=\"$3\"\n\n\tip netns exec $ns ethtool -K $dev $flags 2>/dev/null\n\t[ $? -eq 0 ] && echo \"INFO: set $ns dev $dev: ethtool -K $flags\"\n}\n\nset_random_ethtool_flags() {\n\tlocal flags=\"\"\n\tlocal r=$RANDOM\n\n\tlocal pick1=$((r & 1))\n\tlocal pick2=$((r & 2))\n\tlocal pick3=$((r & 4))\n\n\t[ $pick1 -ne 0 ] && flags=\"tso off\"\n\t[ $pick2 -ne 0 ] && flags=\"$flags gso off\"\n\t[ $pick3 -ne 0 ] && flags=\"$flags gro off\"\n\n\t[ -z \"$flags\" ] && return\n\n\tset_ethtool_flags \"$1\" \"$2\" \"$flags\"\n}\n\nif $ethtool_random_on;then\n\tset_random_ethtool_flags \"$ns3\" ns3eth2\n\tset_random_ethtool_flags \"$ns4\" ns4eth3\nelse\n\tset_ethtool_flags \"$ns3\" ns3eth2 \"$ethtool_args\"\n\tset_ethtool_flags \"$ns4\" ns4eth3 \"$ethtool_args\"\nfi\n\nprint_file_err()\n{\n\tls -l \"$1\" 1>&2\n\techo \"Trailing bytes are: \"\n\ttail -c 27 \"$1\"\n}\n\ncheck_transfer()\n{\n\tlocal in=$1\n\tlocal out=$2\n\tlocal what=$3\n\n\tcmp \"$in\" \"$out\" > /dev/null 2>&1\n\tif [ $? -ne 0 ] ;then\n\t\techo \"[ FAIL ] $what does not match (in, out):\"\n\t\tprint_file_err \"$in\"\n\t\tprint_file_err \"$out\"\n\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\ncheck_mptcp_disabled()\n{\n\tlocal disabled_ns=\"ns_disabled-$rndh\"\n\tip netns add ${disabled_ns} || exit $ksft_skip\n\n\t# net.mptcp.enabled should be enabled by default\n\tif [ \"$(ip netns exec ${disabled_ns} sysctl net.mptcp.enabled | awk '{ print $3 }')\" -ne 1 ]; then\n\t\techo -e \"net.mptcp.enabled sysctl is not 1 by default\\t\\t[ FAIL ]\"\n\t\tmptcp_lib_result_fail \"net.mptcp.enabled sysctl is not 1 by default\"\n\t\tret=1\n\t\treturn 1\n\tfi\n\tip netns exec ${disabled_ns} sysctl -q net.mptcp.enabled=0\n\n\tlocal err=0\n\tLC_ALL=C ip netns exec ${disabled_ns} ./mptcp_connect -p 10000 -s MPTCP 127.0.0.1 < \"$cin\" 2>&1 | \\\n\t\tgrep -q \"^socket: Protocol not available$\" && err=1\n\tip netns delete ${disabled_ns}\n\n\tif [ ${err} -eq 0 ]; then\n\t\techo -e \"New MPTCP socket cannot be blocked via sysctl\\t\\t[ FAIL ]\"\n\t\tmptcp_lib_result_fail \"New MPTCP socket cannot be blocked via sysctl\"\n\t\tret=1\n\t\treturn 1\n\tfi\n\n\techo -e \"New MPTCP socket can be blocked via sysctl\\t\\t[ OK ]\"\n\tmptcp_lib_result_pass \"New MPTCP socket can be blocked via sysctl\"\n\treturn 0\n}\n\n# $1: IP address\nis_v6()\n{\n\t[ -z \"${1##*:*}\" ]\n}\n\ndo_ping()\n{\n\tlocal listener_ns=\"$1\"\n\tlocal connector_ns=\"$2\"\n\tlocal connect_addr=\"$3\"\n\tlocal ping_args=\"-q -c 1\"\n\tlocal rc=0\n\n\tif is_v6 \"${connect_addr}\"; then\n\t\t$ipv6 || return 0\n\t\tping_args=\"${ping_args} -6\"\n\tfi\n\n\tip netns exec ${connector_ns} ping ${ping_args} $connect_addr >/dev/null || rc=1\n\n\tif [ $rc -ne 0 ] ; then\n\t\techo \"$listener_ns -> $connect_addr connectivity [ FAIL ]\" 1>&2\n\t\tret=1\n\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\n# $1: ns, $2: MIB counter\nget_mib_counter()\n{\n\tlocal listener_ns=\"${1}\"\n\tlocal mib=\"${2}\"\n\n\t# strip the header\n\tip netns exec \"${listener_ns}\" \\\n\t\tnstat -z -a \"${mib}\" | \\\n\t\t\ttail -n+2 | \\\n\t\t\twhile read a count c rest; do\n\t\t\t\techo $count\n\t\t\tdone\n}\n\n# $1: ns, $2: port\nwait_local_port_listen()\n{\n\tlocal listener_ns=\"${1}\"\n\tlocal port=\"${2}\"\n\n\tlocal port_hex i\n\n\tport_hex=\"$(printf \"%04X\" \"${port}\")\"\n\tfor i in $(seq 10); do\n\t\tip netns exec \"${listener_ns}\" cat /proc/net/tcp* | \\\n\t\t\tawk \"BEGIN {rc=1} {if (\\$2 ~ /:${port_hex}\\$/ && \\$4 ~ /0A/) {rc=0; exit}} END {exit rc}\" &&\n\t\t\tbreak\n\t\tsleep 0.1\n\tdone\n}\n\ndo_transfer()\n{\n\tlocal listener_ns=\"$1\"\n\tlocal connector_ns=\"$2\"\n\tlocal cl_proto=\"$3\"\n\tlocal srv_proto=\"$4\"\n\tlocal connect_addr=\"$5\"\n\tlocal local_addr=\"$6\"\n\tlocal extra_args=\"$7\"\n\n\tlocal port\n\tport=$((10000+$TEST_COUNT))\n\tTEST_COUNT=$((TEST_COUNT+1))\n\n\tif [ \"$rcvbuf\" -gt 0 ]; then\n\t\textra_args=\"$extra_args -R $rcvbuf\"\n\tfi\n\n\tif [ \"$sndbuf\" -gt 0 ]; then\n\t\textra_args=\"$extra_args -S $sndbuf\"\n\tfi\n\n\tif [ -n \"$testmode\" ]; then\n\t\textra_args=\"$extra_args -m $testmode\"\n\tfi\n\n\tif [ -n \"$extra_args\" ] && $options_log; then\n\t\techo \"INFO: extra options: $extra_args\"\n\tfi\n\toptions_log=false\n\n\t:> \"$cout\"\n\t:> \"$sout\"\n\t:> \"$capout\"\n\n\tlocal addr_port\n\taddr_port=$(printf \"%s:%d\" ${connect_addr} ${port})\n\tlocal result_msg\n\tresult_msg=\"$(printf \"%.3s %-5s -> %.3s (%-20s) %-5s\" ${connector_ns} ${cl_proto} ${listener_ns} ${addr_port} ${srv_proto})\"\n\tprintf \"%s\\t\" \"${result_msg}\"\n\n\tif $capture; then\n\t\tlocal capuser\n\t\tif [ -z $SUDO_USER ] ; then\n\t\t\tcapuser=\"\"\n\t\telse\n\t\t\tcapuser=\"-Z $SUDO_USER\"\n\t\tfi\n\n\t\tlocal capfile=\"${rndh}-${connector_ns:0:3}-${listener_ns:0:3}-${cl_proto}-${srv_proto}-${connect_addr}-${port}\"\n\t\tlocal capopt=\"-i any -s 65535 -B 32768 ${capuser}\"\n\n\t\tip netns exec ${listener_ns}  tcpdump ${capopt} -w \"${capfile}-listener.pcap\"  >> \"${capout}\" 2>&1 &\n\t\tlocal cappid_listener=$!\n\n\t\tip netns exec ${connector_ns} tcpdump ${capopt} -w \"${capfile}-connector.pcap\" >> \"${capout}\" 2>&1 &\n\t\tlocal cappid_connector=$!\n\n\t\tsleep 1\n\tfi\n\n\tNSTAT_HISTORY=/tmp/${listener_ns}.nstat ip netns exec ${listener_ns} \\\n\t\tnstat -n\n\tif [ ${listener_ns} != ${connector_ns} ]; then\n\t\tNSTAT_HISTORY=/tmp/${connector_ns}.nstat ip netns exec ${connector_ns} \\\n\t\t\tnstat -n\n\tfi\n\n\tlocal stat_synrx_last_l=$(get_mib_counter \"${listener_ns}\" \"MPTcpExtMPCapableSYNRX\")\n\tlocal stat_ackrx_last_l=$(get_mib_counter \"${listener_ns}\" \"MPTcpExtMPCapableACKRX\")\n\tlocal stat_cookietx_last=$(get_mib_counter \"${listener_ns}\" \"TcpExtSyncookiesSent\")\n\tlocal stat_cookierx_last=$(get_mib_counter \"${listener_ns}\" \"TcpExtSyncookiesRecv\")\n\tlocal stat_csum_err_s=$(get_mib_counter \"${listener_ns}\" \"MPTcpExtDataCsumErr\")\n\tlocal stat_csum_err_c=$(get_mib_counter \"${connector_ns}\" \"MPTcpExtDataCsumErr\")\n\n\ttimeout ${timeout_test} \\\n\t\tip netns exec ${listener_ns} \\\n\t\t\t./mptcp_connect -t ${timeout_poll} -l -p $port -s ${srv_proto} \\\n\t\t\t\t$extra_args $local_addr < \"$sin\" > \"$sout\" &\n\tlocal spid=$!\n\n\twait_local_port_listen \"${listener_ns}\" \"${port}\"\n\n\tlocal start\n\tstart=$(date +%s%3N)\n\ttimeout ${timeout_test} \\\n\t\tip netns exec ${connector_ns} \\\n\t\t\t./mptcp_connect -t ${timeout_poll} -p $port -s ${cl_proto} \\\n\t\t\t\t$extra_args $connect_addr < \"$cin\" > \"$cout\" &\n\tlocal cpid=$!\n\n\twait $cpid\n\tlocal retc=$?\n\twait $spid\n\tlocal rets=$?\n\n\tlocal stop\n\tstop=$(date +%s%3N)\n\n\tif $capture; then\n\t\tsleep 1\n\t\tkill ${cappid_listener}\n\t\tkill ${cappid_connector}\n\tfi\n\n\tNSTAT_HISTORY=/tmp/${listener_ns}.nstat ip netns exec ${listener_ns} \\\n\t\tnstat | grep Tcp > /tmp/${listener_ns}.out\n\tif [ ${listener_ns} != ${connector_ns} ]; then\n\t\tNSTAT_HISTORY=/tmp/${connector_ns}.nstat ip netns exec ${connector_ns} \\\n\t\t\tnstat | grep Tcp > /tmp/${connector_ns}.out\n\tfi\n\n\tlocal duration\n\tduration=$((stop-start))\n\tresult_msg+=\" # time=${duration}ms\"\n\tprintf \"(duration %05sms) \" \"${duration}\"\n\tif [ ${rets} -ne 0 ] || [ ${retc} -ne 0 ]; then\n\t\techo \"[ FAIL ] client exit code $retc, server $rets\" 1>&2\n\t\techo -e \"\\nnetns ${listener_ns} socket stat for ${port}:\" 1>&2\n\t\tip netns exec ${listener_ns} ss -Menita 1>&2 -o \"sport = :$port\"\n\t\tcat /tmp/${listener_ns}.out\n\t\techo -e \"\\nnetns ${connector_ns} socket stat for ${port}:\" 1>&2\n\t\tip netns exec ${connector_ns} ss -Menita 1>&2 -o \"dport = :$port\"\n\t\t[ ${listener_ns} != ${connector_ns} ] && cat /tmp/${connector_ns}.out\n\n\t\techo\n\t\tcat \"$capout\"\n\t\tmptcp_lib_result_fail \"${TEST_GROUP}: ${result_msg}\"\n\t\treturn 1\n\tfi\n\n\tcheck_transfer $sin $cout \"file received by client\"\n\tretc=$?\n\tcheck_transfer $cin $sout \"file received by server\"\n\trets=$?\n\n\tlocal stat_synrx_now_l=$(get_mib_counter \"${listener_ns}\" \"MPTcpExtMPCapableSYNRX\")\n\tlocal stat_ackrx_now_l=$(get_mib_counter \"${listener_ns}\" \"MPTcpExtMPCapableACKRX\")\n\tlocal stat_cookietx_now=$(get_mib_counter \"${listener_ns}\" \"TcpExtSyncookiesSent\")\n\tlocal stat_cookierx_now=$(get_mib_counter \"${listener_ns}\" \"TcpExtSyncookiesRecv\")\n\tlocal stat_ooo_now=$(get_mib_counter \"${listener_ns}\" \"TcpExtTCPOFOQueue\")\n\n\texpect_synrx=$((stat_synrx_last_l))\n\texpect_ackrx=$((stat_ackrx_last_l))\n\n\tcookies=$(ip netns exec ${listener_ns} sysctl net.ipv4.tcp_syncookies)\n\tcookies=${cookies##*=}\n\n\tif [ ${cl_proto} = \"MPTCP\" ] && [ ${srv_proto} = \"MPTCP\" ]; then\n\t\texpect_synrx=$((stat_synrx_last_l+$connect_per_transfer))\n\t\texpect_ackrx=$((stat_ackrx_last_l+$connect_per_transfer))\n\tfi\n\n\tif [ ${stat_synrx_now_l} -lt ${expect_synrx} ]; then\n\t\tprintf \"[ FAIL ] lower MPC SYN rx (%d) than expected (%d)\\n\" \\\n\t\t\t\"${stat_synrx_now_l}\" \"${expect_synrx}\" 1>&2\n\t\tretc=1\n\tfi\n\tif [ ${stat_ackrx_now_l} -lt ${expect_ackrx} -a ${stat_ooo_now} -eq 0 ]; then\n\t\tif [ ${stat_ooo_now} -eq 0 ]; then\n\t\t\tprintf \"[ FAIL ] lower MPC ACK rx (%d) than expected (%d)\\n\" \\\n\t\t\t\t\"${stat_ackrx_now_l}\" \"${expect_ackrx}\" 1>&2\n\t\t\trets=1\n\t\telse\n\t\t\tprintf \"[ Note ] fallback due to TCP OoO\"\n\t\tfi\n\tfi\n\n\tif $checksum; then\n\t\tlocal csum_err_s=$(get_mib_counter \"${listener_ns}\" \"MPTcpExtDataCsumErr\")\n\t\tlocal csum_err_c=$(get_mib_counter \"${connector_ns}\" \"MPTcpExtDataCsumErr\")\n\n\t\tlocal csum_err_s_nr=$((csum_err_s - stat_csum_err_s))\n\t\tif [ $csum_err_s_nr -gt 0 ]; then\n\t\t\tprintf \"[ FAIL ]\\nserver got $csum_err_s_nr data checksum error[s]\"\n\t\t\trets=1\n\t\tfi\n\n\t\tlocal csum_err_c_nr=$((csum_err_c - stat_csum_err_c))\n\t\tif [ $csum_err_c_nr -gt 0 ]; then\n\t\t\tprintf \"[ FAIL ]\\nclient got $csum_err_c_nr data checksum error[s]\"\n\t\t\tretc=1\n\t\tfi\n\tfi\n\n\tif [ $retc -eq 0 ] && [ $rets -eq 0 ]; then\n\t\tprintf \"[ OK ]\"\n\t\tmptcp_lib_result_pass \"${TEST_GROUP}: ${result_msg}\"\n\telse\n\t\tmptcp_lib_result_fail \"${TEST_GROUP}: ${result_msg}\"\n\tfi\n\n\tif [ $cookies -eq 2 ];then\n\t\tif [ $stat_cookietx_last -ge $stat_cookietx_now ] ;then\n\t\t\tprintf \" WARN: CookieSent: did not advance\"\n\t\tfi\n\t\tif [ $stat_cookierx_last -ge $stat_cookierx_now ] ;then\n\t\t\tprintf \" WARN: CookieRecv: did not advance\"\n\t\tfi\n\telse\n\t\tif [ $stat_cookietx_last -ne $stat_cookietx_now ] ;then\n\t\t\tprintf \" WARN: CookieSent: changed\"\n\t\tfi\n\t\tif [ $stat_cookierx_last -ne $stat_cookierx_now ] ;then\n\t\t\tprintf \" WARN: CookieRecv: changed\"\n\t\tfi\n\tfi\n\n\tif [ ${stat_synrx_now_l} -gt ${expect_synrx} ]; then\n\t\tprintf \" WARN: SYNRX: expect %d, got %d (probably retransmissions)\" \\\n\t\t\t\"${expect_synrx}\" \"${stat_synrx_now_l}\"\n\tfi\n\tif [ ${stat_ackrx_now_l} -gt ${expect_ackrx} ]; then\n\t\tprintf \" WARN: ACKRX: expect %d, got %d (probably retransmissions)\" \\\n\t\t\t\"${expect_ackrx}\" \"${stat_ackrx_now_l}\"\n\tfi\n\n\techo\n\tcat \"$capout\"\n\t[ $retc -eq 0 ] && [ $rets -eq 0 ]\n}\n\nmake_file()\n{\n\tlocal name=$1\n\tlocal who=$2\n\tlocal SIZE=$filesize\n\tlocal ksize\n\tlocal rem\n\n\tif [ $SIZE -eq 0 ]; then\n\t\tlocal MAXSIZE=$((1024 * 1024 * 8))\n\t\tlocal MINSIZE=$((1024 * 256))\n\n\t\tSIZE=$(((RANDOM * RANDOM + MINSIZE) % MAXSIZE))\n\tfi\n\n\tksize=$((SIZE / 1024))\n\trem=$((SIZE - (ksize * 1024)))\n\n\tdd if=/dev/urandom of=\"$name\" bs=1024 count=$ksize 2> /dev/null\n\tdd if=/dev/urandom conv=notrunc of=\"$name\" bs=1 count=$rem 2> /dev/null\n\techo -e \"\\nMPTCP_TEST_FILE_END_MARKER\" >> \"$name\"\n\n\techo \"Created $name (size $(du -b \"$name\")) containing data sent by $who\"\n}\n\nrun_tests_lo()\n{\n\tlocal listener_ns=\"$1\"\n\tlocal connector_ns=\"$2\"\n\tlocal connect_addr=\"$3\"\n\tlocal loopback=\"$4\"\n\tlocal extra_args=\"$5\"\n\tlocal lret=0\n\n\t# skip if test programs are running inside same netns for subsequent runs.\n\tif [ $loopback -eq 0 ] && [ ${listener_ns} = ${connector_ns} ]; then\n\t\treturn 0\n\tfi\n\n\t# skip if we don't want v6\n\tif ! $ipv6 && is_v6 \"${connect_addr}\"; then\n\t\treturn 0\n\tfi\n\n\tlocal local_addr\n\tif is_v6 \"${connect_addr}\"; then\n\t\tlocal_addr=\"::\"\n\telse\n\t\tlocal_addr=\"0.0.0.0\"\n\tfi\n\n\tdo_transfer ${listener_ns} ${connector_ns} MPTCP MPTCP \\\n\t\t    ${connect_addr} ${local_addr} \"${extra_args}\"\n\tlret=$?\n\tif [ $lret -ne 0 ]; then\n\t\tret=$lret\n\t\treturn 1\n\tfi\n\n\tif [ $do_tcp -eq 0 ]; then\n\t\t# don't bother testing fallback tcp except for loopback case.\n\t\tif [ ${listener_ns} != ${connector_ns} ]; then\n\t\t\treturn 0\n\t\tfi\n\tfi\n\n\tdo_transfer ${listener_ns} ${connector_ns} MPTCP TCP \\\n\t\t    ${connect_addr} ${local_addr} \"${extra_args}\"\n\tlret=$?\n\tif [ $lret -ne 0 ]; then\n\t\tret=$lret\n\t\treturn 1\n\tfi\n\n\tdo_transfer ${listener_ns} ${connector_ns} TCP MPTCP \\\n\t\t    ${connect_addr} ${local_addr} \"${extra_args}\"\n\tlret=$?\n\tif [ $lret -ne 0 ]; then\n\t\tret=$lret\n\t\treturn 1\n\tfi\n\n\tif [ $do_tcp -gt 1 ] ;then\n\t\tdo_transfer ${listener_ns} ${connector_ns} TCP TCP \\\n\t\t\t    ${connect_addr} ${local_addr} \"${extra_args}\"\n\t\tlret=$?\n\t\tif [ $lret -ne 0 ]; then\n\t\t\tret=$lret\n\t\t\treturn 1\n\t\tfi\n\tfi\n\n\treturn 0\n}\n\nrun_tests()\n{\n\trun_tests_lo $1 $2 $3 0\n}\n\nrun_test_transparent()\n{\n\tlocal connect_addr=\"$1\"\n\tlocal msg=\"$2\"\n\n\tlocal connector_ns=\"$ns1\"\n\tlocal listener_ns=\"$ns2\"\n\tlocal lret=0\n\tlocal r6flag=\"\"\n\n\tTEST_GROUP=\"${msg}\"\n\n\t# skip if we don't want v6\n\tif ! $ipv6 && is_v6 \"${connect_addr}\"; then\n\t\treturn 0\n\tfi\n\n\t# IP(V6)_TRANSPARENT has been added after TOS support which came with\n\t# the required infrastructure in MPTCP sockopt code. To support TOS, the\n\t# following function has been exported (T). Not great but better than\n\t# checking for a specific kernel version.\n\tif ! mptcp_lib_kallsyms_has \"T __ip_sock_set_tos$\"; then\n\t\techo \"INFO: ${msg} not supported by the kernel: SKIP\"\n\t\tmptcp_lib_result_skip \"${TEST_GROUP}\"\n\t\treturn\n\tfi\n\nip netns exec \"$listener_ns\" nft -f /dev/stdin <<\"EOF\"\nflush ruleset\ntable inet mangle {\n\tchain divert {\n\t\ttype filter hook prerouting priority -150;\n\n\t\tmeta l4proto tcp socket transparent 1 meta mark set 1 accept\n\t\ttcp dport 20000 tproxy to :20000 meta mark set 1 accept\n\t}\n}\nEOF\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: $msg, could not load nft ruleset\"\n\t\tmptcp_lib_fail_if_expected_feature \"nft rules\"\n\t\tmptcp_lib_result_skip \"${TEST_GROUP}\"\n\t\treturn\n\tfi\n\n\tlocal local_addr\n\tif is_v6 \"${connect_addr}\"; then\n\t\tlocal_addr=\"::\"\n\t\tr6flag=\"-6\"\n\telse\n\t\tlocal_addr=\"0.0.0.0\"\n\tfi\n\n\tip -net \"$listener_ns\" $r6flag rule add fwmark 1 lookup 100\n\tif [ $? -ne 0 ]; then\n\t\tip netns exec \"$listener_ns\" nft flush ruleset\n\t\techo \"SKIP: $msg, ip $r6flag rule failed\"\n\t\tmptcp_lib_fail_if_expected_feature \"ip rule\"\n\t\tmptcp_lib_result_skip \"${TEST_GROUP}\"\n\t\treturn\n\tfi\n\n\tip -net \"$listener_ns\" route add local $local_addr/0 dev lo table 100\n\tif [ $? -ne 0 ]; then\n\t\tip netns exec \"$listener_ns\" nft flush ruleset\n\t\tip -net \"$listener_ns\" $r6flag rule del fwmark 1 lookup 100\n\t\techo \"SKIP: $msg, ip route add local $local_addr failed\"\n\t\tmptcp_lib_fail_if_expected_feature \"ip route\"\n\t\tmptcp_lib_result_skip \"${TEST_GROUP}\"\n\t\treturn\n\tfi\n\n\techo \"INFO: test $msg\"\n\n\tTEST_COUNT=10000\n\tlocal extra_args=\"-o TRANSPARENT\"\n\tdo_transfer ${listener_ns} ${connector_ns} MPTCP MPTCP \\\n\t\t    ${connect_addr} ${local_addr} \"${extra_args}\"\n\tlret=$?\n\n\tip netns exec \"$listener_ns\" nft flush ruleset\n\tip -net \"$listener_ns\" $r6flag rule del fwmark 1 lookup 100\n\tip -net \"$listener_ns\" route del local $local_addr/0 dev lo table 100\n\n\tif [ $lret -ne 0 ]; then\n\t\techo \"FAIL: $msg, mptcp connection error\" 1>&2\n\t\tret=$lret\n\t\treturn 1\n\tfi\n\n\techo \"PASS: $msg\"\n\treturn 0\n}\n\nrun_tests_peekmode()\n{\n\tlocal peekmode=\"$1\"\n\n\tTEST_GROUP=\"peek mode: ${peekmode}\"\n\techo \"INFO: with peek mode: ${peekmode}\"\n\trun_tests_lo \"$ns1\" \"$ns1\" 10.0.1.1 1 \"-P ${peekmode}\"\n\trun_tests_lo \"$ns1\" \"$ns1\" dead:beef:1::1 1 \"-P ${peekmode}\"\n}\n\nrun_tests_mptfo()\n{\n\tTEST_GROUP=\"MPTFO\"\n\n\tif ! mptcp_lib_kallsyms_has \"mptcp_fastopen_\"; then\n\t\techo \"INFO: TFO not supported by the kernel: SKIP\"\n\t\tmptcp_lib_result_skip \"${TEST_GROUP}\"\n\t\treturn\n\tfi\n\n\techo \"INFO: with MPTFO start\"\n\tip netns exec \"$ns1\" sysctl -q net.ipv4.tcp_fastopen=2\n\tip netns exec \"$ns2\" sysctl -q net.ipv4.tcp_fastopen=1\n\n\trun_tests_lo \"$ns1\" \"$ns2\" 10.0.1.1 0 \"-o MPTFO\"\n\trun_tests_lo \"$ns1\" \"$ns2\" 10.0.1.1 0 \"-o MPTFO\"\n\n\trun_tests_lo \"$ns1\" \"$ns2\" dead:beef:1::1 0 \"-o MPTFO\"\n\trun_tests_lo \"$ns1\" \"$ns2\" dead:beef:1::1 0 \"-o MPTFO\"\n\n\tip netns exec \"$ns1\" sysctl -q net.ipv4.tcp_fastopen=0\n\tip netns exec \"$ns2\" sysctl -q net.ipv4.tcp_fastopen=0\n\techo \"INFO: with MPTFO end\"\n}\n\nrun_tests_disconnect()\n{\n\tlocal old_cin=$cin\n\tlocal old_sin=$sin\n\n\tTEST_GROUP=\"full disconnect\"\n\n\tif ! mptcp_lib_kallsyms_has \"mptcp_pm_data_reset$\"; then\n\t\techo \"INFO: Full disconnect not supported: SKIP\"\n\t\tmptcp_lib_result_skip \"${TEST_GROUP}\"\n\t\treturn\n\tfi\n\n\tcat $cin $cin $cin > \"$cin\".disconnect\n\n\t# force do_transfer to cope with the multiple transmissions\n\tsin=\"$cin.disconnect\"\n\tcin=\"$cin.disconnect\"\n\tcin_disconnect=\"$old_cin\"\n\tconnect_per_transfer=3\n\n\techo \"INFO: disconnect\"\n\trun_tests_lo \"$ns1\" \"$ns1\" 10.0.1.1 1 \"-I 3 -i $old_cin\"\n\trun_tests_lo \"$ns1\" \"$ns1\" dead:beef:1::1 1 \"-I 3 -i $old_cin\"\n\n\t# restore previous status\n\tsin=$old_sin\n\tcin=$old_cin\n\tcin_disconnect=\"$cin\".disconnect\n\tconnect_per_transfer=1\n}\n\ndisplay_time()\n{\n\ttime_end=$(date +%s)\n\ttime_run=$((time_end-time_start))\n\n\techo \"Time: ${time_run} seconds\"\n}\n\nlog_if_error()\n{\n\tlocal msg=\"$1\"\n\n\tif [ ${ret} -ne 0 ]; then\n\t\techo \"FAIL: ${msg}\" 1>&2\n\n\t\tfinal_ret=${ret}\n\t\tret=0\n\n\t\treturn ${final_ret}\n\tfi\n}\n\nstop_if_error()\n{\n\tif ! log_if_error \"${@}\"; then\n\t\tdisplay_time\n\t\tmptcp_lib_result_print_all_tap\n\t\texit ${final_ret}\n\tfi\n}\n\nmake_file \"$cin\" \"client\"\nmake_file \"$sin\" \"server\"\n\ncheck_mptcp_disabled\n\nstop_if_error \"The kernel configuration is not valid for MPTCP\"\n\necho \"INFO: validating network environment with pings\"\nfor sender in \"$ns1\" \"$ns2\" \"$ns3\" \"$ns4\";do\n\tdo_ping \"$ns1\" $sender 10.0.1.1\n\tdo_ping \"$ns1\" $sender dead:beef:1::1\n\n\tdo_ping \"$ns2\" $sender 10.0.1.2\n\tdo_ping \"$ns2\" $sender dead:beef:1::2\n\tdo_ping \"$ns2\" $sender 10.0.2.1\n\tdo_ping \"$ns2\" $sender dead:beef:2::1\n\n\tdo_ping \"$ns3\" $sender 10.0.2.2\n\tdo_ping \"$ns3\" $sender dead:beef:2::2\n\tdo_ping \"$ns3\" $sender 10.0.3.2\n\tdo_ping \"$ns3\" $sender dead:beef:3::2\n\n\tdo_ping \"$ns4\" $sender 10.0.3.1\n\tdo_ping \"$ns4\" $sender dead:beef:3::1\ndone\n\nmptcp_lib_result_code \"${ret}\" \"ping tests\"\n\nstop_if_error \"Could not even run ping tests\"\n\n[ -n \"$tc_loss\" ] && tc -net \"$ns2\" qdisc add dev ns2eth3 root netem loss random $tc_loss delay ${tc_delay}ms\necho -n \"INFO: Using loss of $tc_loss \"\ntest \"$tc_delay\" -gt 0 && echo -n \"delay $tc_delay ms \"\n\nreorder_delay=$(($tc_delay / 4))\n\nif [ -z \"${tc_reorder}\" ]; then\n\treorder1=$((RANDOM%10))\n\treorder1=$((100 - reorder1))\n\treorder2=$((RANDOM%100))\n\n\tif [ $reorder_delay -gt 0 ] && [ $reorder1 -lt 100 ] && [ $reorder2 -gt 0 ]; then\n\t\ttc_reorder=\"reorder ${reorder1}% ${reorder2}%\"\n\t\techo -n \"$tc_reorder with delay ${reorder_delay}ms \"\n\tfi\nelif [ \"$tc_reorder\" = \"0\" ];then\n\ttc_reorder=\"\"\nelif [ \"$reorder_delay\" -gt 0 ];then\n\t# reordering requires some delay\n\ttc_reorder=\"reorder $tc_reorder\"\n\techo -n \"$tc_reorder with delay ${reorder_delay}ms \"\nfi\n\necho \"on ns3eth4\"\n\ntc -net \"$ns3\" qdisc add dev ns3eth4 root netem delay ${reorder_delay}ms $tc_reorder\n\nTEST_GROUP=\"loopback v4\"\nrun_tests_lo \"$ns1\" \"$ns1\" 10.0.1.1 1\nstop_if_error \"Could not even run loopback test\"\n\nTEST_GROUP=\"loopback v6\"\nrun_tests_lo \"$ns1\" \"$ns1\" dead:beef:1::1 1\nstop_if_error \"Could not even run loopback v6 test\"\n\nTEST_GROUP=\"multihosts\"\nfor sender in $ns1 $ns2 $ns3 $ns4;do\n\t# ns1<->ns2 is not subject to reordering/tc delays. Use it to test\n\t# mptcp syncookie support.\n\tif [ $sender = $ns1 ]; then\n\t\tip netns exec \"$ns2\" sysctl -q net.ipv4.tcp_syncookies=2\n\telse\n\t\tip netns exec \"$ns2\" sysctl -q net.ipv4.tcp_syncookies=1\n\tfi\n\n\trun_tests \"$ns1\" $sender 10.0.1.1\n\trun_tests \"$ns1\" $sender dead:beef:1::1\n\n\trun_tests \"$ns2\" $sender 10.0.1.2\n\trun_tests \"$ns2\" $sender dead:beef:1::2\n\trun_tests \"$ns2\" $sender 10.0.2.1\n\trun_tests \"$ns2\" $sender dead:beef:2::1\n\n\trun_tests \"$ns3\" $sender 10.0.2.2\n\trun_tests \"$ns3\" $sender dead:beef:2::2\n\trun_tests \"$ns3\" $sender 10.0.3.2\n\trun_tests \"$ns3\" $sender dead:beef:3::2\n\n\trun_tests \"$ns4\" $sender 10.0.3.1\n\trun_tests \"$ns4\" $sender dead:beef:3::1\n\n\tlog_if_error \"Tests with $sender as a sender have failed\"\ndone\n\nrun_tests_peekmode \"saveWithPeek\"\nrun_tests_peekmode \"saveAfterPeek\"\nlog_if_error \"Tests with peek mode have failed\"\n\n# MPTFO (MultiPath TCP Fatopen tests)\nrun_tests_mptfo\nlog_if_error \"Tests with MPTFO have failed\"\n\n# connect to ns4 ip address, ns2 should intercept/proxy\nrun_test_transparent 10.0.3.1 \"tproxy ipv4\"\nrun_test_transparent dead:beef:3::1 \"tproxy ipv6\"\nlog_if_error \"Tests with tproxy have failed\"\n\nrun_tests_disconnect\nlog_if_error \"Tests of the full disconnection have failed\"\n\ndisplay_time\nmptcp_lib_result_print_all_tap\nexit ${final_ret}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}