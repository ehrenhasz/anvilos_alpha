{
  "module_name": "gro.c",
  "hash_id": "f933992f1ac32a3c009690955a2b06c57c9b855488b5af49e284acefdc13382d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/gro.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <getopt.h>\n#include <linux/filter.h>\n#include <linux/if_packet.h>\n#include <linux/ipv6.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netinet/ip6.h>\n#include <netinet/tcp.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"../kselftest.h\"\n\n#define DPORT 8000\n#define SPORT 1500\n#define PAYLOAD_LEN 100\n#define NUM_PACKETS 4\n#define START_SEQ 100\n#define START_ACK 100\n#define ETH_P_NONE 0\n#define TOTAL_HDR_LEN (ETH_HLEN + sizeof(struct ipv6hdr) + sizeof(struct tcphdr))\n#define MSS (4096 - sizeof(struct tcphdr) - sizeof(struct ipv6hdr))\n#define MAX_PAYLOAD (IP_MAXPACKET - sizeof(struct tcphdr) - sizeof(struct ipv6hdr))\n#define NUM_LARGE_PKT (MAX_PAYLOAD / MSS)\n#define MAX_HDR_LEN (ETH_HLEN + sizeof(struct ipv6hdr) + sizeof(struct tcphdr))\n\nstatic const char *addr6_src = \"fdaa::2\";\nstatic const char *addr6_dst = \"fdaa::1\";\nstatic const char *addr4_src = \"192.168.1.200\";\nstatic const char *addr4_dst = \"192.168.1.100\";\nstatic int proto = -1;\nstatic uint8_t src_mac[ETH_ALEN], dst_mac[ETH_ALEN];\nstatic char *testname = \"data\";\nstatic char *ifname = \"eth0\";\nstatic char *smac = \"aa:00:00:00:00:02\";\nstatic char *dmac = \"aa:00:00:00:00:01\";\nstatic bool verbose;\nstatic bool tx_socket = true;\nstatic int tcp_offset = -1;\nstatic int total_hdr_len = -1;\nstatic int ethhdr_proto = -1;\n\nstatic void vlog(const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (verbose) {\n\t\tva_start(args, fmt);\n\t\tvfprintf(stderr, fmt, args);\n\t\tva_end(args);\n\t}\n}\n\nstatic void setup_sock_filter(int fd)\n{\n\tconst int dport_off = tcp_offset + offsetof(struct tcphdr, dest);\n\tconst int ethproto_off = offsetof(struct ethhdr, h_proto);\n\tint optlen = 0;\n\tint ipproto_off;\n\tint next_off;\n\n\tif (proto == PF_INET)\n\t\tnext_off = offsetof(struct iphdr, protocol);\n\telse\n\t\tnext_off = offsetof(struct ipv6hdr, nexthdr);\n\tipproto_off = ETH_HLEN + next_off;\n\n\tif (strcmp(testname, \"ip\") == 0) {\n\t\tif (proto == PF_INET)\n\t\t\toptlen = sizeof(struct ip_timestamp);\n\t\telse\n\t\t\toptlen = sizeof(struct ip6_frag);\n\t}\n\n\tstruct sock_filter filter[] = {\n\t\t\tBPF_STMT(BPF_LD  + BPF_H   + BPF_ABS, ethproto_off),\n\t\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ntohs(ethhdr_proto), 0, 7),\n\t\t\tBPF_STMT(BPF_LD  + BPF_B   + BPF_ABS, ipproto_off),\n\t\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_TCP, 0, 5),\n\t\t\tBPF_STMT(BPF_LD  + BPF_H   + BPF_ABS, dport_off),\n\t\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, DPORT, 2, 0),\n\t\t\tBPF_STMT(BPF_LD  + BPF_H   + BPF_ABS, dport_off + optlen),\n\t\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, DPORT, 0, 1),\n\t\t\tBPF_STMT(BPF_RET + BPF_K, 0xFFFFFFFF),\n\t\t\tBPF_STMT(BPF_RET + BPF_K, 0),\n\t};\n\n\tstruct sock_fprog bpf = {\n\t\t.len = ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, &bpf, sizeof(bpf)) < 0)\n\t\terror(1, errno, \"error setting filter\");\n}\n\nstatic uint32_t checksum_nofold(void *data, size_t len, uint32_t sum)\n{\n\tuint16_t *words = data;\n\tint i;\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tsum += words[i];\n\tif (len & 1)\n\t\tsum += ((char *)data)[len - 1];\n\treturn sum;\n}\n\nstatic uint16_t checksum_fold(void *data, size_t len, uint32_t sum)\n{\n\tsum = checksum_nofold(data, len, sum);\n\twhile (sum > 0xFFFF)\n\t\tsum = (sum & 0xFFFF) + (sum >> 16);\n\treturn ~sum;\n}\n\nstatic uint16_t tcp_checksum(void *buf, int payload_len)\n{\n\tstruct pseudo_header6 {\n\t\tstruct in6_addr saddr;\n\t\tstruct in6_addr daddr;\n\t\tuint16_t protocol;\n\t\tuint16_t payload_len;\n\t} ph6;\n\tstruct pseudo_header4 {\n\t\tstruct in_addr saddr;\n\t\tstruct in_addr daddr;\n\t\tuint16_t protocol;\n\t\tuint16_t payload_len;\n\t} ph4;\n\tuint32_t sum = 0;\n\n\tif (proto == PF_INET6) {\n\t\tif (inet_pton(AF_INET6, addr6_src, &ph6.saddr) != 1)\n\t\t\terror(1, errno, \"inet_pton6 source ip pseudo\");\n\t\tif (inet_pton(AF_INET6, addr6_dst, &ph6.daddr) != 1)\n\t\t\terror(1, errno, \"inet_pton6 dest ip pseudo\");\n\t\tph6.protocol = htons(IPPROTO_TCP);\n\t\tph6.payload_len = htons(sizeof(struct tcphdr) + payload_len);\n\n\t\tsum = checksum_nofold(&ph6, sizeof(ph6), 0);\n\t} else if (proto == PF_INET) {\n\t\tif (inet_pton(AF_INET, addr4_src, &ph4.saddr) != 1)\n\t\t\terror(1, errno, \"inet_pton source ip pseudo\");\n\t\tif (inet_pton(AF_INET, addr4_dst, &ph4.daddr) != 1)\n\t\t\terror(1, errno, \"inet_pton dest ip pseudo\");\n\t\tph4.protocol = htons(IPPROTO_TCP);\n\t\tph4.payload_len = htons(sizeof(struct tcphdr) + payload_len);\n\n\t\tsum = checksum_nofold(&ph4, sizeof(ph4), 0);\n\t}\n\n\treturn checksum_fold(buf, sizeof(struct tcphdr) + payload_len, sum);\n}\n\nstatic void read_MAC(uint8_t *mac_addr, char *mac)\n{\n\tif (sscanf(mac, \"%hhx:%hhx:%hhx:%hhx:%hhx:%hhx\",\n\t\t   &mac_addr[0], &mac_addr[1], &mac_addr[2],\n\t\t   &mac_addr[3], &mac_addr[4], &mac_addr[5]) != 6)\n\t\terror(1, 0, \"sscanf\");\n}\n\nstatic void fill_datalinklayer(void *buf)\n{\n\tstruct ethhdr *eth = buf;\n\n\tmemcpy(eth->h_dest, dst_mac, ETH_ALEN);\n\tmemcpy(eth->h_source, src_mac, ETH_ALEN);\n\teth->h_proto = ethhdr_proto;\n}\n\nstatic void fill_networklayer(void *buf, int payload_len)\n{\n\tstruct ipv6hdr *ip6h = buf;\n\tstruct iphdr *iph = buf;\n\n\tif (proto == PF_INET6) {\n\t\tmemset(ip6h, 0, sizeof(*ip6h));\n\n\t\tip6h->version = 6;\n\t\tip6h->payload_len = htons(sizeof(struct tcphdr) + payload_len);\n\t\tip6h->nexthdr = IPPROTO_TCP;\n\t\tip6h->hop_limit = 8;\n\t\tif (inet_pton(AF_INET6, addr6_src, &ip6h->saddr) != 1)\n\t\t\terror(1, errno, \"inet_pton source ip6\");\n\t\tif (inet_pton(AF_INET6, addr6_dst, &ip6h->daddr) != 1)\n\t\t\terror(1, errno, \"inet_pton dest ip6\");\n\t} else if (proto == PF_INET) {\n\t\tmemset(iph, 0, sizeof(*iph));\n\n\t\tiph->version = 4;\n\t\tiph->ihl = 5;\n\t\tiph->ttl = 8;\n\t\tiph->protocol\t= IPPROTO_TCP;\n\t\tiph->tot_len = htons(sizeof(struct tcphdr) +\n\t\t\t\tpayload_len + sizeof(struct iphdr));\n\t\tiph->frag_off = htons(0x4000);  \n\t\tif (inet_pton(AF_INET, addr4_src, &iph->saddr) != 1)\n\t\t\terror(1, errno, \"inet_pton source ip\");\n\t\tif (inet_pton(AF_INET, addr4_dst, &iph->daddr) != 1)\n\t\t\terror(1, errno, \"inet_pton dest ip\");\n\t\tiph->check = checksum_fold(buf, sizeof(struct iphdr), 0);\n\t}\n}\n\nstatic void fill_transportlayer(void *buf, int seq_offset, int ack_offset,\n\t\t\t\tint payload_len, int fin)\n{\n\tstruct tcphdr *tcph = buf;\n\n\tmemset(tcph, 0, sizeof(*tcph));\n\n\ttcph->source = htons(SPORT);\n\ttcph->dest = htons(DPORT);\n\ttcph->seq = ntohl(START_SEQ + seq_offset);\n\ttcph->ack_seq = ntohl(START_ACK + ack_offset);\n\ttcph->ack = 1;\n\ttcph->fin = fin;\n\ttcph->doff = 5;\n\ttcph->window = htons(TCP_MAXWIN);\n\ttcph->urg_ptr = 0;\n\ttcph->check = tcp_checksum(tcph, payload_len);\n}\n\nstatic void write_packet(int fd, char *buf, int len, struct sockaddr_ll *daddr)\n{\n\tint ret = -1;\n\n\tret = sendto(fd, buf, len, 0, (struct sockaddr *)daddr, sizeof(*daddr));\n\tif (ret == -1)\n\t\terror(1, errno, \"sendto failure\");\n\tif (ret != len)\n\t\terror(1, errno, \"sendto wrong length\");\n}\n\nstatic void create_packet(void *buf, int seq_offset, int ack_offset,\n\t\t\t  int payload_len, int fin)\n{\n\tmemset(buf, 0, total_hdr_len);\n\tmemset(buf + total_hdr_len, 'a', payload_len);\n\tfill_transportlayer(buf + tcp_offset, seq_offset, ack_offset,\n\t\t\t    payload_len, fin);\n\tfill_networklayer(buf + ETH_HLEN, payload_len);\n\tfill_datalinklayer(buf);\n}\n\n \nstatic void send_flags(int fd, struct sockaddr_ll *daddr, int psh, int syn,\n\t\t       int rst, int urg)\n{\n\tstatic char flag_buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tint payload_len, pkt_size, flag, i;\n\tstruct tcphdr *tcph;\n\n\tpayload_len = PAYLOAD_LEN * psh;\n\tpkt_size = total_hdr_len + payload_len;\n\tflag = NUM_PACKETS / 2;\n\n\tcreate_packet(flag_buf, flag * payload_len, 0, payload_len, 0);\n\n\ttcph = (struct tcphdr *)(flag_buf + tcp_offset);\n\ttcph->psh = psh;\n\ttcph->syn = syn;\n\ttcph->rst = rst;\n\ttcph->urg = urg;\n\ttcph->check = 0;\n\ttcph->check = tcp_checksum(tcph, payload_len);\n\n\tfor (i = 0; i < NUM_PACKETS + 1; i++) {\n\t\tif (i == flag) {\n\t\t\twrite_packet(fd, flag_buf, pkt_size, daddr);\n\t\t\tcontinue;\n\t\t}\n\t\tcreate_packet(buf, i * PAYLOAD_LEN, 0, PAYLOAD_LEN, 0);\n\t\twrite_packet(fd, buf, total_hdr_len + PAYLOAD_LEN, daddr);\n\t}\n}\n\n \nstatic void send_data_pkts(int fd, struct sockaddr_ll *daddr,\n\t\t\t   int payload_len1, int payload_len2)\n{\n\tstatic char buf[ETH_HLEN + IP_MAXPACKET];\n\n\tcreate_packet(buf, 0, 0, payload_len1, 0);\n\twrite_packet(fd, buf, total_hdr_len + payload_len1, daddr);\n\tcreate_packet(buf, payload_len1, 0, payload_len2, 0);\n\twrite_packet(fd, buf, total_hdr_len + payload_len2, daddr);\n}\n\n \nstatic void send_large(int fd, struct sockaddr_ll *daddr, int remainder)\n{\n\tstatic char pkts[NUM_LARGE_PKT][TOTAL_HDR_LEN + MSS];\n\tstatic char last[TOTAL_HDR_LEN + MSS];\n\tstatic char new_seg[TOTAL_HDR_LEN + MSS];\n\tint i;\n\n\tfor (i = 0; i < NUM_LARGE_PKT; i++)\n\t\tcreate_packet(pkts[i], i * MSS, 0, MSS, 0);\n\tcreate_packet(last, NUM_LARGE_PKT * MSS, 0, remainder, 0);\n\tcreate_packet(new_seg, (NUM_LARGE_PKT + 1) * MSS, 0, remainder, 0);\n\n\tfor (i = 0; i < NUM_LARGE_PKT; i++)\n\t\twrite_packet(fd, pkts[i], total_hdr_len + MSS, daddr);\n\twrite_packet(fd, last, total_hdr_len + remainder, daddr);\n\twrite_packet(fd, new_seg, total_hdr_len + remainder, daddr);\n}\n\n \nstatic void send_ack(int fd, struct sockaddr_ll *daddr)\n{\n\tstatic char buf[MAX_HDR_LEN];\n\n\tcreate_packet(buf, 0, 0, 0, 0);\n\twrite_packet(fd, buf, total_hdr_len, daddr);\n\twrite_packet(fd, buf, total_hdr_len, daddr);\n\tcreate_packet(buf, 0, 1, 0, 0);\n\twrite_packet(fd, buf, total_hdr_len, daddr);\n}\n\nstatic void recompute_packet(char *buf, char *no_ext, int extlen)\n{\n\tstruct tcphdr *tcphdr = (struct tcphdr *)(buf + tcp_offset);\n\tstruct ipv6hdr *ip6h = (struct ipv6hdr *)(buf + ETH_HLEN);\n\tstruct iphdr *iph = (struct iphdr *)(buf + ETH_HLEN);\n\n\tmemmove(buf, no_ext, total_hdr_len);\n\tmemmove(buf + total_hdr_len + extlen,\n\t\tno_ext + total_hdr_len, PAYLOAD_LEN);\n\n\ttcphdr->doff = tcphdr->doff + (extlen / 4);\n\ttcphdr->check = 0;\n\ttcphdr->check = tcp_checksum(tcphdr, PAYLOAD_LEN + extlen);\n\tif (proto == PF_INET) {\n\t\tiph->tot_len = htons(ntohs(iph->tot_len) + extlen);\n\t\tiph->check = 0;\n\t\tiph->check = checksum_fold(iph, sizeof(struct iphdr), 0);\n\t} else {\n\t\tip6h->payload_len = htons(ntohs(ip6h->payload_len) + extlen);\n\t}\n}\n\nstatic void tcp_write_options(char *buf, int kind, int ts)\n{\n\tstruct tcp_option_ts {\n\t\tuint8_t kind;\n\t\tuint8_t len;\n\t\tuint32_t tsval;\n\t\tuint32_t tsecr;\n\t} *opt_ts = (void *)buf;\n\tstruct tcp_option_window {\n\t\tuint8_t kind;\n\t\tuint8_t len;\n\t\tuint8_t shift;\n\t} *opt_window = (void *)buf;\n\n\tswitch (kind) {\n\tcase TCPOPT_NOP:\n\t\tbuf[0] = TCPOPT_NOP;\n\t\tbreak;\n\tcase TCPOPT_WINDOW:\n\t\tmemset(opt_window, 0, sizeof(struct tcp_option_window));\n\t\topt_window->kind = TCPOPT_WINDOW;\n\t\topt_window->len = TCPOLEN_WINDOW;\n\t\topt_window->shift = 0;\n\t\tbreak;\n\tcase TCPOPT_TIMESTAMP:\n\t\tmemset(opt_ts, 0, sizeof(struct tcp_option_ts));\n\t\topt_ts->kind = TCPOPT_TIMESTAMP;\n\t\topt_ts->len = TCPOLEN_TIMESTAMP;\n\t\topt_ts->tsval = ts;\n\t\topt_ts->tsecr = 0;\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"unimplemented TCP option\");\n\t\tbreak;\n\t}\n}\n\n \nstatic void add_standard_tcp_options(char *buf, char *no_ext, int ts, int order)\n{\n\tswitch (order) {\n\tcase 0:\n\t\ttcp_write_options(buf + total_hdr_len, TCPOPT_NOP, 0);\n\t\ttcp_write_options(buf + total_hdr_len + 1, TCPOPT_NOP, 0);\n\t\ttcp_write_options(buf + total_hdr_len + 2  ,\n\t\t\t\t  TCPOPT_TIMESTAMP, ts);\n\t\tbreak;\n\tcase 1:\n\t\ttcp_write_options(buf + total_hdr_len, TCPOPT_NOP, 0);\n\t\ttcp_write_options(buf + total_hdr_len + 1,\n\t\t\t\t  TCPOPT_TIMESTAMP, ts);\n\t\ttcp_write_options(buf + total_hdr_len + 1 + TCPOLEN_TIMESTAMP,\n\t\t\t\t  TCPOPT_NOP, 0);\n\t\tbreak;\n\tcase 2:\n\t\ttcp_write_options(buf + total_hdr_len, TCPOPT_TIMESTAMP, ts);\n\t\ttcp_write_options(buf + total_hdr_len + TCPOLEN_TIMESTAMP + 1,\n\t\t\t\t  TCPOPT_NOP, 0);\n\t\ttcp_write_options(buf + total_hdr_len + TCPOLEN_TIMESTAMP + 2,\n\t\t\t\t  TCPOPT_NOP, 0);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"unknown order\");\n\t\tbreak;\n\t}\n\trecompute_packet(buf, no_ext, TCPOLEN_TSTAMP_APPA);\n}\n\n \nstatic void send_changed_checksum(int fd, struct sockaddr_ll *daddr)\n{\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstruct tcphdr *tcph = (struct tcphdr *)(buf + tcp_offset);\n\tint pkt_size = total_hdr_len + PAYLOAD_LEN;\n\n\tcreate_packet(buf, 0, 0, PAYLOAD_LEN, 0);\n\twrite_packet(fd, buf, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN, 0, PAYLOAD_LEN, 0);\n\ttcph->check = tcph->check - 1;\n\twrite_packet(fd, buf, pkt_size, daddr);\n}\n\n  \nstatic void send_changed_seq(int fd, struct sockaddr_ll *daddr)\n{\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstruct tcphdr *tcph = (struct tcphdr *)(buf + tcp_offset);\n\tint pkt_size = total_hdr_len + PAYLOAD_LEN;\n\n\tcreate_packet(buf, 0, 0, PAYLOAD_LEN, 0);\n\twrite_packet(fd, buf, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN, 0, PAYLOAD_LEN, 0);\n\ttcph->seq = ntohl(htonl(tcph->seq) + 1);\n\ttcph->check = 0;\n\ttcph->check = tcp_checksum(tcph, PAYLOAD_LEN);\n\twrite_packet(fd, buf, pkt_size, daddr);\n}\n\n  \nstatic void send_changed_ts(int fd, struct sockaddr_ll *daddr)\n{\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstatic char extpkt[sizeof(buf) + TCPOLEN_TSTAMP_APPA];\n\tint pkt_size = total_hdr_len + PAYLOAD_LEN + TCPOLEN_TSTAMP_APPA;\n\n\tcreate_packet(buf, 0, 0, PAYLOAD_LEN, 0);\n\tadd_standard_tcp_options(extpkt, buf, 0, 0);\n\twrite_packet(fd, extpkt, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN, 0, PAYLOAD_LEN, 0);\n\tadd_standard_tcp_options(extpkt, buf, 0, 0);\n\twrite_packet(fd, extpkt, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN * 2, 0, PAYLOAD_LEN, 0);\n\tadd_standard_tcp_options(extpkt, buf, 100, 0);\n\twrite_packet(fd, extpkt, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN * 3, 0, PAYLOAD_LEN, 0);\n\tadd_standard_tcp_options(extpkt, buf, 100, 1);\n\twrite_packet(fd, extpkt, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN * 4, 0, PAYLOAD_LEN, 0);\n\tadd_standard_tcp_options(extpkt, buf, 100, 2);\n\twrite_packet(fd, extpkt, pkt_size, daddr);\n}\n\n \nstatic void send_diff_opt(int fd, struct sockaddr_ll *daddr)\n{\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstatic char extpkt1[sizeof(buf) + TCPOLEN_TSTAMP_APPA];\n\tstatic char extpkt2[sizeof(buf) + TCPOLEN_MAXSEG];\n\tint extpkt1_size = total_hdr_len + PAYLOAD_LEN + TCPOLEN_TSTAMP_APPA;\n\tint extpkt2_size = total_hdr_len + PAYLOAD_LEN + TCPOLEN_MAXSEG;\n\n\tcreate_packet(buf, 0, 0, PAYLOAD_LEN, 0);\n\tadd_standard_tcp_options(extpkt1, buf, 0, 0);\n\twrite_packet(fd, extpkt1, extpkt1_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN, 0, PAYLOAD_LEN, 0);\n\tadd_standard_tcp_options(extpkt1, buf, 0, 0);\n\twrite_packet(fd, extpkt1, extpkt1_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN * 2, 0, PAYLOAD_LEN, 0);\n\ttcp_write_options(extpkt2 + MAX_HDR_LEN, TCPOPT_NOP, 0);\n\ttcp_write_options(extpkt2 + MAX_HDR_LEN + 1, TCPOPT_WINDOW, 0);\n\trecompute_packet(extpkt2, buf, TCPOLEN_WINDOW + 1);\n\twrite_packet(fd, extpkt2, extpkt2_size, daddr);\n}\n\nstatic void add_ipv4_ts_option(void *buf, void *optpkt)\n{\n\tstruct ip_timestamp *ts = (struct ip_timestamp *)(optpkt + tcp_offset);\n\tint optlen = sizeof(struct ip_timestamp);\n\tstruct iphdr *iph;\n\n\tif (optlen % 4)\n\t\terror(1, 0, \"ipv4 timestamp length is not a multiple of 4B\");\n\n\tts->ipt_code = IPOPT_TS;\n\tts->ipt_len = optlen;\n\tts->ipt_ptr = 5;\n\tts->ipt_flg = IPOPT_TS_TSONLY;\n\n\tmemcpy(optpkt, buf, tcp_offset);\n\tmemcpy(optpkt + tcp_offset + optlen, buf + tcp_offset,\n\t       sizeof(struct tcphdr) + PAYLOAD_LEN);\n\n\tiph = (struct iphdr *)(optpkt + ETH_HLEN);\n\tiph->ihl = 5 + (optlen / 4);\n\tiph->tot_len = htons(ntohs(iph->tot_len) + optlen);\n\tiph->check = 0;\n\tiph->check = checksum_fold(iph, sizeof(struct iphdr) + optlen, 0);\n}\n\n \nstatic void send_ip_options(int fd, struct sockaddr_ll *daddr)\n{\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstatic char optpkt[sizeof(buf) + sizeof(struct ip_timestamp)];\n\tint optlen = sizeof(struct ip_timestamp);\n\tint pkt_size = total_hdr_len + PAYLOAD_LEN + optlen;\n\n\tcreate_packet(buf, 0, 0, PAYLOAD_LEN, 0);\n\twrite_packet(fd, buf, total_hdr_len + PAYLOAD_LEN, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN * 1, 0, PAYLOAD_LEN, 0);\n\tadd_ipv4_ts_option(buf, optpkt);\n\twrite_packet(fd, optpkt, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN * 2, 0, PAYLOAD_LEN, 0);\n\twrite_packet(fd, buf, total_hdr_len + PAYLOAD_LEN, daddr);\n}\n\n \nstatic void send_fragment4(int fd, struct sockaddr_ll *daddr)\n{\n\tstatic char buf[IP_MAXPACKET];\n\tstruct iphdr *iph = (struct iphdr *)(buf + ETH_HLEN);\n\tint pkt_size = total_hdr_len + PAYLOAD_LEN;\n\n\tcreate_packet(buf, 0, 0, PAYLOAD_LEN, 0);\n\twrite_packet(fd, buf, pkt_size, daddr);\n\n\t \n\tmemset(buf + total_hdr_len, 'a', PAYLOAD_LEN * 2);\n\tfill_transportlayer(buf + tcp_offset, PAYLOAD_LEN, 0, PAYLOAD_LEN * 2, 0);\n\tfill_networklayer(buf + ETH_HLEN, PAYLOAD_LEN);\n\tfill_datalinklayer(buf);\n\n\tiph->frag_off = htons(0x6000); \n\tiph->check = 0;\n\tiph->check = checksum_fold(iph, sizeof(struct iphdr), 0);\n\twrite_packet(fd, buf, pkt_size, daddr);\n}\n\n \nstatic void send_changed_ttl(int fd, struct sockaddr_ll *daddr)\n{\n\tint pkt_size = total_hdr_len + PAYLOAD_LEN;\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstruct iphdr *iph = (struct iphdr *)(buf + ETH_HLEN);\n\n\tcreate_packet(buf, 0, 0, PAYLOAD_LEN, 0);\n\twrite_packet(fd, buf, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN, 0, PAYLOAD_LEN, 0);\n\tiph->ttl = 7;\n\tiph->check = 0;\n\tiph->check = checksum_fold(iph, sizeof(struct iphdr), 0);\n\twrite_packet(fd, buf, pkt_size, daddr);\n}\n\n \nstatic void send_changed_tos(int fd, struct sockaddr_ll *daddr)\n{\n\tint pkt_size = total_hdr_len + PAYLOAD_LEN;\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstruct iphdr *iph = (struct iphdr *)(buf + ETH_HLEN);\n\tstruct ipv6hdr *ip6h = (struct ipv6hdr *)(buf + ETH_HLEN);\n\n\tcreate_packet(buf, 0, 0, PAYLOAD_LEN, 0);\n\twrite_packet(fd, buf, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN, 0, PAYLOAD_LEN, 0);\n\tif (proto == PF_INET) {\n\t\tiph->tos = 1;\n\t\tiph->check = 0;\n\t\tiph->check = checksum_fold(iph, sizeof(struct iphdr), 0);\n\t} else if (proto == PF_INET6) {\n\t\tip6h->priority = 0xf;\n\t}\n\twrite_packet(fd, buf, pkt_size, daddr);\n}\n\n \nstatic void send_changed_ECN(int fd, struct sockaddr_ll *daddr)\n{\n\tint pkt_size = total_hdr_len + PAYLOAD_LEN;\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstruct iphdr *iph = (struct iphdr *)(buf + ETH_HLEN);\n\n\tcreate_packet(buf, 0, 0, PAYLOAD_LEN, 0);\n\twrite_packet(fd, buf, pkt_size, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN, 0, PAYLOAD_LEN, 0);\n\tif (proto == PF_INET) {\n\t\tbuf[ETH_HLEN + 1] ^= 0x2;  \n\t\tiph->check = 0;\n\t\tiph->check = checksum_fold(iph, sizeof(struct iphdr), 0);\n\t} else {\n\t\tbuf[ETH_HLEN + 1] ^= 0x20;  \n\t}\n\twrite_packet(fd, buf, pkt_size, daddr);\n}\n\n \nstatic void send_fragment6(int fd, struct sockaddr_ll *daddr)\n{\n\tstatic char buf[MAX_HDR_LEN + PAYLOAD_LEN];\n\tstatic char extpkt[MAX_HDR_LEN + PAYLOAD_LEN +\n\t\t\t   sizeof(struct ip6_frag)];\n\tstruct ipv6hdr *ip6h = (struct ipv6hdr *)(buf + ETH_HLEN);\n\tstruct ip6_frag *frag = (void *)(extpkt + tcp_offset);\n\tint extlen = sizeof(struct ip6_frag);\n\tint bufpkt_len = total_hdr_len + PAYLOAD_LEN;\n\tint extpkt_len = bufpkt_len + extlen;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tcreate_packet(buf, PAYLOAD_LEN * i, 0, PAYLOAD_LEN, 0);\n\t\twrite_packet(fd, buf, bufpkt_len, daddr);\n\t}\n\n\tcreate_packet(buf, PAYLOAD_LEN * 2, 0, PAYLOAD_LEN, 0);\n\tmemset(extpkt, 0, extpkt_len);\n\n\tip6h->nexthdr = IPPROTO_FRAGMENT;\n\tip6h->payload_len = htons(ntohs(ip6h->payload_len) + extlen);\n\tfrag->ip6f_nxt = IPPROTO_TCP;\n\n\tmemcpy(extpkt, buf, tcp_offset);\n\tmemcpy(extpkt + tcp_offset + extlen, buf + tcp_offset,\n\t       sizeof(struct tcphdr) + PAYLOAD_LEN);\n\twrite_packet(fd, extpkt, extpkt_len, daddr);\n\n\tcreate_packet(buf, PAYLOAD_LEN * 3, 0, PAYLOAD_LEN, 0);\n\twrite_packet(fd, buf, bufpkt_len, daddr);\n}\n\nstatic void bind_packetsocket(int fd)\n{\n\tstruct sockaddr_ll daddr = {};\n\n\tdaddr.sll_family = AF_PACKET;\n\tdaddr.sll_protocol = ethhdr_proto;\n\tdaddr.sll_ifindex = if_nametoindex(ifname);\n\tif (daddr.sll_ifindex == 0)\n\t\terror(1, errno, \"if_nametoindex\");\n\n\tif (bind(fd, (void *)&daddr, sizeof(daddr)) < 0)\n\t\terror(1, errno, \"could not bind socket\");\n}\n\nstatic void set_timeout(int fd)\n{\n\tstruct timeval timeout;\n\n\ttimeout.tv_sec = 3;\n\ttimeout.tv_usec = 0;\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout,\n\t\t       sizeof(timeout)) < 0)\n\t\terror(1, errno, \"cannot set timeout, setsockopt failed\");\n}\n\nstatic void check_recv_pkts(int fd, int *correct_payload,\n\t\t\t    int correct_num_pkts)\n{\n\tstatic char buffer[IP_MAXPACKET + ETH_HLEN + 1];\n\tstruct iphdr *iph = (struct iphdr *)(buffer + ETH_HLEN);\n\tstruct ipv6hdr *ip6h = (struct ipv6hdr *)(buffer + ETH_HLEN);\n\tstruct tcphdr *tcph;\n\tbool bad_packet = false;\n\tint tcp_ext_len = 0;\n\tint ip_ext_len = 0;\n\tint pkt_size = -1;\n\tint data_len = 0;\n\tint num_pkt = 0;\n\tint i;\n\n\tvlog(\"Expected {\");\n\tfor (i = 0; i < correct_num_pkts; i++)\n\t\tvlog(\"%d \", correct_payload[i]);\n\tvlog(\"}, Total %d packets\\nReceived {\", correct_num_pkts);\n\n\twhile (1) {\n\t\tpkt_size = recv(fd, buffer, IP_MAXPACKET + ETH_HLEN + 1, 0);\n\t\tif (pkt_size < 0)\n\t\t\terror(1, errno, \"could not receive\");\n\n\t\tif (iph->version == 4)\n\t\t\tip_ext_len = (iph->ihl - 5) * 4;\n\t\telse if (ip6h->version == 6 && ip6h->nexthdr != IPPROTO_TCP)\n\t\t\tip_ext_len = sizeof(struct ip6_frag);\n\n\t\ttcph = (struct tcphdr *)(buffer + tcp_offset + ip_ext_len);\n\n\t\tif (tcph->fin)\n\t\t\tbreak;\n\n\t\ttcp_ext_len = (tcph->doff - 5) * 4;\n\t\tdata_len = pkt_size - total_hdr_len - tcp_ext_len - ip_ext_len;\n\t\t \n\t\tif (pkt_size == ETH_ZLEN && iph->version == 4) {\n\t\t\tdata_len = ntohs(iph->tot_len)\n\t\t\t\t- sizeof(struct tcphdr) - sizeof(struct iphdr);\n\t\t}\n\t\tvlog(\"%d \", data_len);\n\t\tif (data_len != correct_payload[num_pkt]) {\n\t\t\tvlog(\"[!=%d]\", correct_payload[num_pkt]);\n\t\t\tbad_packet = true;\n\t\t}\n\t\tnum_pkt++;\n\t}\n\tvlog(\"}, Total %d packets.\\n\", num_pkt);\n\tif (num_pkt != correct_num_pkts)\n\t\terror(1, 0, \"incorrect number of packets\");\n\tif (bad_packet)\n\t\terror(1, 0, \"incorrect packet geometry\");\n\n\tprintf(\"Test succeeded\\n\\n\");\n}\n\nstatic void gro_sender(void)\n{\n\tstatic char fin_pkt[MAX_HDR_LEN];\n\tstruct sockaddr_ll daddr = {};\n\tint txfd = -1;\n\n\ttxfd = socket(PF_PACKET, SOCK_RAW, IPPROTO_RAW);\n\tif (txfd < 0)\n\t\terror(1, errno, \"socket creation\");\n\n\tmemset(&daddr, 0, sizeof(daddr));\n\tdaddr.sll_ifindex = if_nametoindex(ifname);\n\tif (daddr.sll_ifindex == 0)\n\t\terror(1, errno, \"if_nametoindex\");\n\tdaddr.sll_family = AF_PACKET;\n\tmemcpy(daddr.sll_addr, dst_mac, ETH_ALEN);\n\tdaddr.sll_halen = ETH_ALEN;\n\tcreate_packet(fin_pkt, PAYLOAD_LEN * 2, 0, 0, 1);\n\n\tif (strcmp(testname, \"data\") == 0) {\n\t\tsend_data_pkts(txfd, &daddr, PAYLOAD_LEN, PAYLOAD_LEN);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_data_pkts(txfd, &daddr, PAYLOAD_LEN, PAYLOAD_LEN / 2);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_data_pkts(txfd, &daddr, PAYLOAD_LEN / 2, PAYLOAD_LEN);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\t} else if (strcmp(testname, \"ack\") == 0) {\n\t\tsend_ack(txfd, &daddr);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\t} else if (strcmp(testname, \"flags\") == 0) {\n\t\tsend_flags(txfd, &daddr, 1, 0, 0, 0);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_flags(txfd, &daddr, 0, 1, 0, 0);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_flags(txfd, &daddr, 0, 0, 1, 0);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_flags(txfd, &daddr, 0, 0, 0, 1);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\t} else if (strcmp(testname, \"tcp\") == 0) {\n\t\tsend_changed_checksum(txfd, &daddr);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_changed_seq(txfd, &daddr);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_changed_ts(txfd, &daddr);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_diff_opt(txfd, &daddr);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\t} else if (strcmp(testname, \"ip\") == 0) {\n\t\tsend_changed_ECN(txfd, &daddr);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_changed_tos(txfd, &daddr);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\t\tif (proto == PF_INET) {\n\t\t\t \n\t\t\tsleep(1);\n\t\t\tsend_changed_ttl(txfd, &daddr);\n\t\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\t\tsleep(1);\n\t\t\tsend_ip_options(txfd, &daddr);\n\t\t\tsleep(1);\n\t\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\t\tsleep(1);\n\t\t\tsend_fragment4(txfd, &daddr);\n\t\t\tsleep(1);\n\t\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\t\t} else if (proto == PF_INET6) {\n\t\t\tsend_fragment6(txfd, &daddr);\n\t\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\t\t}\n\t} else if (strcmp(testname, \"large\") == 0) {\n\t\t \n\t\tint offset = proto == PF_INET ? 20 : 0;\n\t\tint remainder = (MAX_PAYLOAD + offset) % MSS;\n\n\t\tsend_large(txfd, &daddr, remainder);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\n\t\tsend_large(txfd, &daddr, remainder + 1);\n\t\twrite_packet(txfd, fin_pkt, total_hdr_len, &daddr);\n\t} else {\n\t\terror(1, 0, \"Unknown testcase\");\n\t}\n\n\tif (close(txfd))\n\t\terror(1, errno, \"socket close\");\n}\n\nstatic void gro_receiver(void)\n{\n\tstatic int correct_payload[NUM_PACKETS];\n\tint rxfd = -1;\n\n\trxfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_NONE));\n\tif (rxfd < 0)\n\t\terror(1, 0, \"socket creation\");\n\tsetup_sock_filter(rxfd);\n\tset_timeout(rxfd);\n\tbind_packetsocket(rxfd);\n\n\tmemset(correct_payload, 0, sizeof(correct_payload));\n\n\tif (strcmp(testname, \"data\") == 0) {\n\t\tprintf(\"pure data packet of same size: \");\n\t\tcorrect_payload[0] = PAYLOAD_LEN * 2;\n\t\tcheck_recv_pkts(rxfd, correct_payload, 1);\n\n\t\tprintf(\"large data packets followed by a smaller one: \");\n\t\tcorrect_payload[0] = PAYLOAD_LEN * 1.5;\n\t\tcheck_recv_pkts(rxfd, correct_payload, 1);\n\n\t\tprintf(\"small data packets followed by a larger one: \");\n\t\tcorrect_payload[0] = PAYLOAD_LEN / 2;\n\t\tcorrect_payload[1] = PAYLOAD_LEN;\n\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\t} else if (strcmp(testname, \"ack\") == 0) {\n\t\tprintf(\"duplicate ack and pure ack: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 3);\n\t} else if (strcmp(testname, \"flags\") == 0) {\n\t\tcorrect_payload[0] = PAYLOAD_LEN * 3;\n\t\tcorrect_payload[1] = PAYLOAD_LEN * 2;\n\n\t\tprintf(\"psh flag ends coalescing: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\n\t\tcorrect_payload[0] = PAYLOAD_LEN * 2;\n\t\tcorrect_payload[1] = 0;\n\t\tcorrect_payload[2] = PAYLOAD_LEN * 2;\n\t\tprintf(\"syn flag ends coalescing: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 3);\n\n\t\tprintf(\"rst flag ends coalescing: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 3);\n\n\t\tprintf(\"urg flag ends coalescing: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 3);\n\t} else if (strcmp(testname, \"tcp\") == 0) {\n\t\tcorrect_payload[0] = PAYLOAD_LEN;\n\t\tcorrect_payload[1] = PAYLOAD_LEN;\n\t\tcorrect_payload[2] = PAYLOAD_LEN;\n\t\tcorrect_payload[3] = PAYLOAD_LEN;\n\n\t\tprintf(\"changed checksum does not coalesce: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\n\t\tprintf(\"Wrong Seq number doesn't coalesce: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\n\t\tprintf(\"Different timestamp doesn't coalesce: \");\n\t\tcorrect_payload[0] = PAYLOAD_LEN * 2;\n\t\tcheck_recv_pkts(rxfd, correct_payload, 4);\n\n\t\tprintf(\"Different options doesn't coalesce: \");\n\t\tcorrect_payload[0] = PAYLOAD_LEN * 2;\n\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\t} else if (strcmp(testname, \"ip\") == 0) {\n\t\tcorrect_payload[0] = PAYLOAD_LEN;\n\t\tcorrect_payload[1] = PAYLOAD_LEN;\n\n\t\tprintf(\"different ECN doesn't coalesce: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\n\t\tprintf(\"different tos doesn't coalesce: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\n\t\tif (proto == PF_INET) {\n\t\t\tprintf(\"different ttl doesn't coalesce: \");\n\t\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\n\t\t\tprintf(\"ip options doesn't coalesce: \");\n\t\t\tcorrect_payload[2] = PAYLOAD_LEN;\n\t\t\tcheck_recv_pkts(rxfd, correct_payload, 3);\n\n\t\t\tprintf(\"fragmented ip4 doesn't coalesce: \");\n\t\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\t\t} else if (proto == PF_INET6) {\n\t\t\t \n\t\t\tprintf(\"fragmented ip6 doesn't coalesce: \");\n\t\t\tcorrect_payload[0] = PAYLOAD_LEN * 2;\n\t\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\t\t}\n\t} else if (strcmp(testname, \"large\") == 0) {\n\t\tint offset = proto == PF_INET ? 20 : 0;\n\t\tint remainder = (MAX_PAYLOAD + offset) % MSS;\n\n\t\tcorrect_payload[0] = (MAX_PAYLOAD + offset);\n\t\tcorrect_payload[1] = remainder;\n\t\tprintf(\"Shouldn't coalesce if exceed IP max pkt size: \");\n\t\tcheck_recv_pkts(rxfd, correct_payload, 2);\n\n\t\t \n\t\tcorrect_payload[0] = correct_payload[0] - remainder;\n\t\tcorrect_payload[1] = remainder + 1;\n\t\tcorrect_payload[2] = remainder + 1;\n\t\tcheck_recv_pkts(rxfd, correct_payload, 3);\n\t} else {\n\t\terror(1, 0, \"Test case error, should never trigger\");\n\t}\n\n\tif (close(rxfd))\n\t\terror(1, 0, \"socket close\");\n}\n\nstatic void parse_args(int argc, char **argv)\n{\n\tstatic const struct option opts[] = {\n\t\t{ \"daddr\", required_argument, NULL, 'd' },\n\t\t{ \"dmac\", required_argument, NULL, 'D' },\n\t\t{ \"iface\", required_argument, NULL, 'i' },\n\t\t{ \"ipv4\", no_argument, NULL, '4' },\n\t\t{ \"ipv6\", no_argument, NULL, '6' },\n\t\t{ \"rx\", no_argument, NULL, 'r' },\n\t\t{ \"saddr\", required_argument, NULL, 's' },\n\t\t{ \"smac\", required_argument, NULL, 'S' },\n\t\t{ \"test\", required_argument, NULL, 't' },\n\t\t{ \"verbose\", no_argument, NULL, 'v' },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\tint c;\n\n\twhile ((c = getopt_long(argc, argv, \"46d:D:i:rs:S:t:v\", opts, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tproto = PF_INET;\n\t\t\tethhdr_proto = htons(ETH_P_IP);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tproto = PF_INET6;\n\t\t\tethhdr_proto = htons(ETH_P_IPV6);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\taddr4_dst = addr6_dst = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdmac = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tifname = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\ttx_socket = false;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\taddr4_src = addr6_src = optarg;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsmac = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttestname = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"%s invalid option %c\\n\", __func__, c);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tparse_args(argc, argv);\n\n\tif (proto == PF_INET) {\n\t\ttcp_offset = ETH_HLEN + sizeof(struct iphdr);\n\t\ttotal_hdr_len = tcp_offset + sizeof(struct tcphdr);\n\t} else if (proto == PF_INET6) {\n\t\ttcp_offset = ETH_HLEN + sizeof(struct ipv6hdr);\n\t\ttotal_hdr_len = MAX_HDR_LEN;\n\t} else {\n\t\terror(1, 0, \"Protocol family is not ipv4 or ipv6\");\n\t}\n\n\tread_MAC(src_mac, smac);\n\tread_MAC(dst_mac, dmac);\n\n\tif (tx_socket)\n\t\tgro_sender();\n\telse\n\t\tgro_receiver();\n\n\tfprintf(stderr, \"Gro::%s test passed.\\n\", testname);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}