{
  "module_name": "srv6_end_next_csid_l3vpn_test.sh",
  "hash_id": "ddf266f5aef08de1f327d407da83ff290b179d73c2c6e313657418e70e9a7dcf",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/srv6_end_next_csid_l3vpn_test.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# author: Andrea Mayer <andrea.mayer@uniroma2.it>\n#\n# This script is designed for testing the support of NEXT-C-SID flavor for SRv6\n# End behavior.\n# A basic knowledge of SRv6 architecture [1] and of the compressed SID approach\n# [2] is assumed for the reader.\n#\n# The network topology used in the selftest is depicted hereafter, composed by\n# two hosts and four routers. Hosts hs-1 and hs-2 are connected through an\n# IPv4/IPv6 L3 VPN service, offered by routers rt-1, rt-2, rt-3 and rt-4 using\n# the NEXT-C-SID flavor. The key components for such VPNs are:\n#\n#    i) The SRv6 H.Encaps/H.Encaps.Red behaviors [1] apply SRv6 Policies on\n#       traffic received by connected hosts, initiating the VPN tunnel;\n#\n#   ii) The SRv6 End behavior [1] advances the active SID in the SID List\n#       carried by the SRH;\n#\n#  iii) The NEXT-C-SID mechanism [2] offers the possibility of encoding several\n#       SRv6 segments within a single 128-bit SID address, referred to as a\n#       Compressed SID (C-SID) container. In this way, the length of the SID\n#       List can be drastically reduced.\n#       The NEXT-C-SID is provided as a \"flavor\" of the SRv6 End behavior\n#       which advances the current C-SID (i.e. the Locator-Node Function defined\n#       in [2]) with the next one carried in the Argument, if available.\n#       When no more C-SIDs are available in the Argument, the SRv6 End behavior\n#       will apply the End function selecting the next SID in the SID List.\n#\n#   iv) The SRv6 End.DT46 behavior [1] is used for removing the SRv6 Policy and,\n#       thus, it terminates the VPN tunnel. Such a behavior is capable of\n#       handling, at the same time, both tunneled IPv4 and IPv6 traffic.\n#\n# [1] https://datatracker.ietf.org/doc/html/rfc8986\n# [2] https://datatracker.ietf.org/doc/html/draft-ietf-spring-srv6-srh-compression\n#\n#\n#               cafe::1                      cafe::2\n#              10.0.0.1                     10.0.0.2\n#             +--------+                   +--------+\n#             |        |                   |        |\n#             |  hs-1  |                   |  hs-2  |\n#             |        |                   |        |\n#             +---+----+                   +----+---+\n#    cafe::/64    |                             |      cafe::/64\n#  10.0.0.0/24    |                             |    10.0.0.0/24\n#             +---+----+                   +----+---+\n#             |        |  fcf0:0:1:2::/64  |        |\n#             |  rt-1  +-------------------+  rt-2  |\n#             |        |                   |        |\n#             +---+----+                   +----+---+\n#                 |      .               .      |\n#                 |  fcf0:0:1:3::/64   .        |\n#                 |          .       .          |\n#                 |            .   .            |\n# fcf0:0:1:4::/64 |              .              | fcf0:0:2:3::/64\n#                 |            .   .            |\n#                 |          .       .          |\n#                 |  fcf0:0:2:4::/64   .        |\n#                 |      .               .      |\n#             +---+----+                   +----+---+\n#             |        |                   |        |\n#             |  rt-4  +-------------------+  rt-3  |\n#             |        |  fcf0:0:3:4::/64  |        |\n#             +---+----+                   +----+---+\n#\n# Every fcf0:0:x:y::/64 network interconnects the SRv6 routers rt-x with rt-y in\n# the selftest network.\n#\n# Local SID/C-SID table\n# =====================\n#\n# Each SRv6 router is configured with a Local SID/C-SID table in which\n# SIDs/C-SIDs are stored. Considering an SRv6 router rt-x, SIDs/C-SIDs are\n# configured in the Local SID/C-SIDs table as follows:\n#\n#   Local SID/C-SID table for SRv6 router rt-x\n#   +-----------------------------------------------------------+\n#   |fcff:x::d46 is associated with the non-compressed SRv6     |\n#   |   End.DT46 behavior                                       |\n#   +-----------------------------------------------------------+\n#   |fcbb:0:0x00::/48 is associated with the NEXT-C-SID flavor  |\n#   |   of SRv6 End behavior                                    |\n#   +-----------------------------------------------------------+\n#   |fcbb:0:0x00:d46::/64 is associated with the SRv6 End.DT46  |\n#   |   behavior when NEXT-C-SID compression is turned on       |\n#   +-----------------------------------------------------------+\n#\n# The fcff::/16 prefix is reserved for implementing SRv6 services with regular\n# (non compressed) SIDs. Reachability of SIDs is ensured by proper configuration\n# of the IPv6 routing tables in the routers.\n# Similarly, the fcbb:0::/32 prefix is reserved for implementing SRv6 VPN\n# services leveraging the NEXT-C-SID compression mechanism. Indeed, the\n# fcbb:0::/32 is used for encoding the Locator-Block while the Locator-Node\n# Function is encoded with 16 bits.\n#\n# Incoming traffic classification and application of SRv6 Policies\n# ================================================================\n#\n# An SRv6 ingress router applies different SRv6 Policies to the traffic received\n# from a connected host, considering the IPv4 or IPv6 destination address.\n# SRv6 policy enforcement consists of encapsulating the received traffic into a\n# new IPv6 packet with a given SID List contained in the SRH.\n# When the SID List contains only one SID, the SRH could be omitted completely\n# and that SID is stored directly in the IPv6 Destination Address (DA) (this is\n# called \"reduced\" encapsulation).\n#\n# Test cases for NEXT-C-SID\n# =========================\n#\n# We consider two test cases for NEXT-C-SID: i) single SID and ii) double SID.\n#\n# In the single SID test case we have a number of segments that are all\n# contained in a single Compressed SID (C-SID) container. Therefore the\n# resulting SID List has only one SID. Using the reduced encapsulation format\n# this will result in a packet with no SRH.\n#\n# In the double SID test case we have one segment carried in a Compressed SID\n# (C-SID) container, followed by a regular (non compressed) SID. The resulting\n# SID List has two segments and it is possible to test the advance to the next\n# SID when all the C-SIDs in a C-SID container have been processed. Using the\n# reduced encapsulation format this will result in a packet with an SRH\n# containing 1 segment.\n#\n# For the single SID test case, we use the IPv4 addresses of hs-1 and hs-2, for\n# the double SID test case, we use their IPv6 addresses. This is only done to\n# simplify the test setup and avoid adding other hosts or multiple addresses on\n# the same interface of a host.\n#\n# Traffic from hs-1 to hs-2\n# -------------------------\n#\n# Packets generated from hs-1 and directed towards hs-2 are handled by rt-1\n# which applies the SRv6 Policies as follows:\n#\n#   i) IPv6 DA=cafe::2, H.Encaps.Red with SID List=fcbb:0:0400:0300:0200:d46::\n#  ii) IPv4 DA=10.0.0.2, H.Encaps.Red with SID List=fcbb:0:0300::,fcff:2::d46\n#\n# ### i) single SID\n#\n# The router rt-1 is configured to enforce the given Policy through the SRv6\n# H.Encaps.Red behavior which avoids the presence of the SRH at all, since it\n# pushes the single SID directly in the IPv6 DA. Such a SID encodes a whole\n# C-SID container carrying several C-SIDs (e.g. 0400, 0300, etc).\n#\n# As the packet reaches the router rt-4, the enabled NEXT-C-SID SRv6 End\n# behavior (associated with fcbb:0:0400::/48) is triggered. This behavior\n# analyzes the IPv6 DA and checks whether the Argument of the C-SID container\n# is zero or not. In this case, the Argument is *NOT* zero and the IPv6 DA is\n# updated as follows:\n#\n# +---------------------------------------------------------------+\n# | Before applying the rt-4 enabled NEXT-C-SID SRv6 End behavior |\n# +---------------------------------------------------------------+\n# |                            +---------- Argument               |\n# |                     vvvvvvvvvvvvvvvv                          |\n# | IPv6 DA fcbb:0:0400:0300:0200:d46::                           |\n# |                ^^^^    <-- shifting                           |\n# |                  |                                            |\n# |          Locator-Node Function                                |\n# +---------------------------------------------------------------+\n# | After applying the rt-4 enabled NEXT-C-SID SRv6 End behavior  |\n# +---------------------------------------------------------------+\n# |                          +---------- Argument                 |\n# |                    vvvvvvvvvvvv                               |\n# | IPv6 DA fcbb:0:0300:0200:d46::                                |\n# |                ^^^^                                           |\n# |                  |                                            |\n# |          Locator-Node Function                                |\n# +---------------------------------------------------------------+\n#\n# After having applied the enabled NEXT-C-SID SRv6 End behavior, the packet is\n# sent to the next node, i.e. rt-3.\n#\n# The enabled NEXT-C-SID SRv6 End behavior on rt-3 is executed as the packet is\n# received. This behavior processes the packet and updates the IPv6 DA with\n# fcbb:0:0200:d46::, since the Argument is *NOT* zero. Then, the packet is sent\n# to the router rt-2.\n#\n# The router rt-2 is configured for decapsulating the inner IPv6 packet and,\n# for this reason, it applies the SRv6 End.DT46 behavior on the received\n# packet. It is worth noting that the SRv6 End.DT46 behavior does not require\n# the presence of the SRH: it is fully capable to operate properly on\n# IPv4/IPv6-in-IPv6 encapsulations.\n# At the end of the decap operation, the packet is sent to the\n# host hs-2.\n#\n# ### ii) double SID\n#\n# The router rt-1 is configured to enforce the given Policy through the SRv6\n# H.Encaps.Red. As a result, the first SID fcbb:0:0300:: is stored into the\n# IPv6 DA, while the SRH pushed into the packet is made of only one SID, i.e.\n# fcff:2::d46. Hence, the packet sent by hs-1 to hs-2 is encapsulated in an\n# outer IPv6 header plus the SRH.\n#\n# As the packet reaches the node rt-3, the router applies the enabled NEXT-C-SID\n# SRv6 End behavior.\n#\n# +---------------------------------------------------------------+\n# | Before applying the rt-3 enabled NEXT-C-SID SRv6 End behavior |\n# +---------------------------------------------------------------+\n# |                            +---------- Argument               |\n# |                      vvvv (Argument is all filled with zeros) |\n# | IPv6 DA fcbb:0:0300::                                         |\n# |                ^^^^                                           |\n# |                  |                                            |\n# |          Locator-Node Function                                |\n# +---------------------------------------------------------------+\n# | After applying the rt-3 enabled NEXT-C-SID SRv6 End behavior  |\n# +---------------------------------------------------------------+\n# |                                                               |\n# | IPv6 DA fcff:2::d46                                           |\n# |         ^^^^^^^^^^^                                           |\n# |              |                                                |\n# |        SID copied from the SID List contained in the SRH      |\n# +---------------------------------------------------------------+\n#\n# Since the Argument of the C-SID container is zero, the behavior can not\n# update the Locator-Node function with the next C-SID carried in the Argument\n# itself. Thus, the enabled NEXT-C-SID SRv6 End behavior operates as the\n# traditional End behavior: it updates the IPv6 DA by copying the next\n# available SID in the SID List carried by the SRH. After that, the packet is\n# sent to the node rt-2.\n#\n# Once the packet is received by rt-2, the router decapsulates the inner IPv6\n# packet using the SRv6 End.DT46 behavior (associated with the SID fcff:2::d46)\n# and sends it to the host hs-2.\n#\n# Traffic from hs-2 to hs-1\n# -------------------------\n#\n# Packets generated from hs-2 and directed towards hs-1 are handled by rt-2\n# which applies the SRv6 Policies as follows:\n#\n#   i) IPv6 DA=cafe::1, SID List=fcbb:0:0300:0400:0100:d46::\n#  ii) IPv4 DA=10.0.0.1, SID List=fcbb:0:0300::,fcff:1::d46\n#\n# For simplicity, such SRv6 Policies were chosen so that, in both use cases (i)\n# and (ii), the network paths crossed by traffic from hs-2 to hs-1 are the same\n# as those taken by traffic from hs-1 to hs-2.\n# In this way, traffic from hs-2 to hs-1 is processed similarly to traffic from\n# hs-1 to hs-2. So, the traffic processing scheme turns out to be the same as\n# that adopted in the use cases already examined (of course, it is necessary to\n# consider the different SIDs/C-SIDs).\n\n# Kselftest framework requirement - SKIP code is 4.\nreadonly ksft_skip=4\n\nreadonly RDMSUFF=\"$(mktemp -u XXXXXXXX)\"\nreadonly DUMMY_DEVNAME=\"dum0\"\nreadonly VRF_TID=100\nreadonly VRF_DEVNAME=\"vrf-${VRF_TID}\"\nreadonly RT2HS_DEVNAME=\"veth-t${VRF_TID}\"\nreadonly LOCALSID_TABLE_ID=90\nreadonly IPv6_RT_NETWORK=fcf0:0\nreadonly IPv6_HS_NETWORK=cafe\nreadonly IPv4_HS_NETWORK=10.0.0\nreadonly VPN_LOCATOR_SERVICE=fcff\nreadonly DT46_FUNC=0d46\nreadonly HEADEND_ENCAP=\"encap.red\"\n\n# do not add ':' as separator\nreadonly LCBLOCK_ADDR=fcbb0000\nreadonly LCBLOCK_BLEN=32\n# do not add ':' as separator\nreadonly LCNODEFUNC_FMT=\"0%d00\"\nreadonly LCNODEFUNC_BLEN=16\n\nreadonly LCBLOCK_NODEFUNC_BLEN=$((LCBLOCK_BLEN + LCNODEFUNC_BLEN))\n\nreadonly CSID_CNTR_PREFIX=\"dead:beaf::/32\"\n# ID of the router used for testing the C-SID container cfgs\nreadonly CSID_CNTR_RT_ID_TEST=1\n# Routing table used for testing the C-SID container cfgs\nreadonly CSID_CNTR_RT_TABLE=91\n\n# C-SID container configurations to be tested\n#\n# An entry of the array is defined as \"a,b,c\" where:\n# - 'a' and 'b' elements represent respectively the Locator-Block length\n#   (lblen) in bits and the Locator-Node Function length (nflen) in bits.\n#   'a' and 'b' can be set to default values using the placeholder \"d\" which\n#   indicates the default kernel values (32 for lblen and 16 for nflen);\n#   otherwise, any numeric value is accepted;\n# - 'c' indicates whether the C-SID configuration provided by the values 'a'\n#   and 'b' should be considered valid (\"y\") or invalid (\"n\").\ndeclare -ra CSID_CONTAINER_CFGS=(\n\t\"d,d,y\"\n\t\"d,16,y\"\n\t\"16,d,y\"\n\t\"16,32,y\"\n\t\"32,16,y\"\n\t\"48,8,y\"\n\t\"8,48,y\"\n\t\"d,0,n\"\n\t\"0,d,n\"\n\t\"32,0,n\"\n\t\"0,32,n\"\n\t\"17,d,n\"\n\t\"d,17,n\"\n\t\"120,16,n\"\n\t\"16,120,n\"\n\t\"0,128,n\"\n\t\"128,0,n\"\n\t\"130,0,n\"\n\t\"0,130,n\"\n\t\"0,0,n\"\n)\n\nPING_TIMEOUT_SEC=4\nPAUSE_ON_FAIL=${PAUSE_ON_FAIL:=no}\n\n# IDs of routers and hosts are initialized during the setup of the testing\n# network\nROUTERS=''\nHOSTS=''\n\nSETUP_ERR=1\n\nret=${ksft_skip}\nnsuccess=0\nnfail=0\n\nlog_test()\n{\n\tlocal rc=\"$1\"\n\tlocal expected=\"$2\"\n\tlocal msg=\"$3\"\n\n\tif [ \"${rc}\" -eq \"${expected}\" ]; then\n\t\tnsuccess=$((nsuccess+1))\n\t\tprintf \"\\n    TEST: %-60s  [ OK ]\\n\" \"${msg}\"\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"\\n    TEST: %-60s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n}\n\nprint_log_test_results()\n{\n\tprintf \"\\nTests passed: %3d\\n\" \"${nsuccess}\"\n\tprintf \"Tests failed: %3d\\n\"   \"${nfail}\"\n\n\t# when a test fails, the value of 'ret' is set to 1 (error code).\n\t# Conversely, when all tests are passed successfully, the 'ret' value\n\t# is set to 0 (success code).\n\tif [ \"${ret}\" -ne 1 ]; then\n\t\tret=0\n\tfi\n}\n\nlog_section()\n{\n\techo\n\techo \"################################################################################\"\n\techo \"TEST SECTION: $*\"\n\techo \"################################################################################\"\n}\n\ntest_command_or_ksft_skip()\n{\n\tlocal cmd=\"$1\"\n\n\tif [ ! -x \"$(command -v \"${cmd}\")\" ]; then\n\t\techo \"SKIP: Could not run test without \\\"${cmd}\\\" tool\";\n\t\texit \"${ksft_skip}\"\n\tfi\n}\n\nget_nodename()\n{\n\tlocal name=\"$1\"\n\n\techo \"${name}-${RDMSUFF}\"\n}\n\nget_rtname()\n{\n\tlocal rtid=\"$1\"\n\n\tget_nodename \"rt-${rtid}\"\n}\n\nget_hsname()\n{\n\tlocal hsid=\"$1\"\n\n\tget_nodename \"hs-${hsid}\"\n}\n\n__create_namespace()\n{\n\tlocal name=\"$1\"\n\n\tip netns add \"${name}\"\n}\n\ncreate_router()\n{\n\tlocal rtid=\"$1\"\n\tlocal nsname\n\n\tnsname=\"$(get_rtname \"${rtid}\")\"\n\n\t__create_namespace \"${nsname}\"\n}\n\ncreate_host()\n{\n\tlocal hsid=\"$1\"\n\tlocal nsname\n\n\tnsname=\"$(get_hsname \"${hsid}\")\"\n\n\t__create_namespace \"${nsname}\"\n}\n\ncleanup()\n{\n\tlocal nsname\n\tlocal i\n\n\t# destroy routers\n\tfor i in ${ROUTERS}; do\n\t\tnsname=\"$(get_rtname \"${i}\")\"\n\n\t\tip netns del \"${nsname}\" &>/dev/null || true\n\tdone\n\n\t# destroy hosts\n\tfor i in ${HOSTS}; do\n\t\tnsname=\"$(get_hsname \"${i}\")\"\n\n\t\tip netns del \"${nsname}\" &>/dev/null || true\n\tdone\n\n\t# check whether the setup phase was completed successfully or not. In\n\t# case of an error during the setup phase of the testing environment,\n\t# the selftest is considered as \"skipped\".\n\tif [ \"${SETUP_ERR}\" -ne 0 ]; then\n\t\techo \"SKIP: Setting up the testing environment failed\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\texit \"${ret}\"\n}\n\nadd_link_rt_pairs()\n{\n\tlocal rt=\"$1\"\n\tlocal rt_neighs=\"$2\"\n\tlocal neigh\n\tlocal nsname\n\tlocal neigh_nsname\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\tfor neigh in ${rt_neighs}; do\n\t\tneigh_nsname=\"$(get_rtname \"${neigh}\")\"\n\n\t\tip link add \"veth-rt-${rt}-${neigh}\" netns \"${nsname}\" \\\n\t\t\ttype veth peer name \"veth-rt-${neigh}-${rt}\" \\\n\t\t\tnetns \"${neigh_nsname}\"\n\tdone\n}\n\nget_network_prefix()\n{\n\tlocal rt=\"$1\"\n\tlocal neigh=\"$2\"\n\tlocal p=\"${rt}\"\n\tlocal q=\"${neigh}\"\n\n\tif [ \"${p}\" -gt \"${q}\" ]; then\n\t\tp=\"${q}\"; q=\"${rt}\"\n\tfi\n\n\techo \"${IPv6_RT_NETWORK}:${p}:${q}\"\n}\n\n# Setup the basic networking for the routers\nsetup_rt_networking()\n{\n\tlocal rt=\"$1\"\n\tlocal rt_neighs=\"$2\"\n\tlocal nsname\n\tlocal net_prefix\n\tlocal devname\n\tlocal neigh\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\tfor neigh in ${rt_neighs}; do\n\t\tdevname=\"veth-rt-${rt}-${neigh}\"\n\n\t\tnet_prefix=\"$(get_network_prefix \"${rt}\" \"${neigh}\")\"\n\n\t\tip -netns \"${nsname}\" addr \\\n\t\t\tadd \"${net_prefix}::${rt}/64\" dev \"${devname}\" nodad\n\n\t\tip -netns \"${nsname}\" link set \"${devname}\" up\n\tdone\n\n        ip -netns \"${nsname}\" link add \"${DUMMY_DEVNAME}\" type dummy\n\n        ip -netns \"${nsname}\" link set \"${DUMMY_DEVNAME}\" up\n\tip -netns \"${nsname}\" link set lo up\n\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv6.conf.all.accept_dad=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv6.conf.default.accept_dad=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv6.conf.all.forwarding=1\n\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv4.conf.all.rp_filter=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv4.conf.default.rp_filter=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv4.ip_forward=1\n}\n\n# build an ipv6 prefix/address based on the input string\n# Note that the input string does not contain ':' and '::' which are considered\n# to be implicit.\n# e.g.:\n#  - input:  fbcc00000400300\n#  - output: fbcc:0000:0400:0300:0000:0000:0000:0000\n#                                ^^^^^^^^^^^^^^^^^^^\n#                              fill the address with 0s\nbuild_ipv6_addr()\n{\n\tlocal addr=\"$1\"\n\tlocal out=\"\"\n\tlocal strlen=\"${#addr}\"\n\tlocal padn\n\tlocal i\n\n\t# add \":\" every 4 digits (16 bits)\n\tfor (( i = 0; i < strlen; i++ )); do\n\t\tif (( i > 0 && i < 32 && (i % 4) == 0 )); then\n\t\t\tout=\"${out}:\"\n\t\tfi\n\n\t\tout=\"${out}${addr:$i:1}\"\n\tdone\n\n\t# fill the remaining bits of the address with 0s\n\tpadn=$((32 - strlen))\n\tfor (( i = padn; i > 0; i-- )); do\n\t\tif (( i > 0 && i < 32 && (i % 4) == 0 )); then\n\t\t\tout=\"${out}:\"\n\t\tfi\n\n\t\tout=\"${out}0\"\n\tdone\n\n\tprintf \"${out}\"\n}\n\nbuild_csid()\n{\n\tlocal nodeid=\"$1\"\n\n\tprintf \"${LCNODEFUNC_FMT}\" \"${nodeid}\"\n}\n\nbuild_lcnode_func_prefix()\n{\n\tlocal nodeid=\"$1\"\n\tlocal lcnodefunc\n\tlocal prefix\n\tlocal out\n\n\tlcnodefunc=\"$(build_csid \"${nodeid}\")\"\n\tprefix=\"$(build_ipv6_addr \"${LCBLOCK_ADDR}${lcnodefunc}\")\"\n\n\tout=\"${prefix}/${LCBLOCK_NODEFUNC_BLEN}\"\n\n\techo \"${out}\"\n}\n\n# Setup local SIDs for an SRv6 router\nsetup_rt_local_sids()\n{\n\tlocal rt=\"$1\"\n\tlocal rt_neighs=\"$2\"\n\tlocal net_prefix\n\tlocal devname\n\tlocal nsname\n\tlocal neigh\n\tlocal lcnode_func_prefix\n\tlocal lcblock_prefix\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\tfor neigh in ${rt_neighs}; do\n\t\tdevname=\"veth-rt-${rt}-${neigh}\"\n\n\t\tnet_prefix=\"$(get_network_prefix \"${rt}\" \"${neigh}\")\"\n\n\t\t# set underlay network routes for SIDs reachability\n\t\tip -netns \"${nsname}\" -6 route \\\n\t\t\tadd \"${VPN_LOCATOR_SERVICE}:${neigh}::/32\" \\\n\t\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\t\tvia \"${net_prefix}::${neigh}\" dev \"${devname}\"\n\n\t\t# set the underlay network for C-SIDs reachability\n\t\tlcnode_func_prefix=\"$(build_lcnode_func_prefix \"${neigh}\")\"\n\n\t\tip -netns \"${nsname}\" -6 route \\\n\t\t\tadd \"${lcnode_func_prefix}\" \\\n\t\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\t\tvia \"${net_prefix}::${neigh}\" dev \"${devname}\"\n\tdone\n\n\tlcnode_func_prefix=\"$(build_lcnode_func_prefix \"${rt}\")\"\n\n\t# enabled NEXT-C-SID SRv6 End behavior (note that \"dev\" is the dummy\n\t# dum0 device chosen for the sake of simplicity).\n\tip -netns \"${nsname}\" -6 route \\\n\t\tadd \"${lcnode_func_prefix}\" \\\n\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\tencap seg6local action End flavors next-csid \\\n\t\tlblen \"${LCBLOCK_BLEN}\" nflen \"${LCNODEFUNC_BLEN}\" \\\n\t\tdev \"${DUMMY_DEVNAME}\"\n\n\t# all SIDs for VPNs start with a common locator. Routes and SRv6\n\t# Endpoint behavior instaces are grouped together in the 'localsid'\n\t# table.\n\tip -netns \"${nsname}\" -6 rule \\\n\t\tadd to \"${VPN_LOCATOR_SERVICE}::/16\" \\\n\t\tlookup \"${LOCALSID_TABLE_ID}\" prio 999\n\n\t# common locator block for NEXT-C-SIDS compression mechanism.\n\tlcblock_prefix=\"$(build_ipv6_addr \"${LCBLOCK_ADDR}\")\"\n\tip -netns \"${nsname}\" -6 rule \\\n\t\tadd to \"${lcblock_prefix}/${LCBLOCK_BLEN}\" \\\n\t\tlookup \"${LOCALSID_TABLE_ID}\" prio 999\n}\n\n# build and install the SRv6 policy into the ingress SRv6 router as well as the\n# decap SID in the egress one.\n# args:\n#  $1 - src host (evaluate automatically the ingress router)\n#  $2 - dst host (evaluate automatically the egress router)\n#  $3 - SRv6 routers configured for steering traffic (End behaviors)\n#  $4 - single SID or double SID\n#  $5 - traffic type (IPv6 or IPv4)\n__setup_l3vpn()\n{\n\tlocal src=\"$1\"\n\tlocal dst=\"$2\"\n\tlocal end_rts=\"$3\"\n\tlocal mode=\"$4\"\n\tlocal traffic=\"$5\"\n\tlocal nsname\n\tlocal policy\n\tlocal container\n\tlocal decapsid\n\tlocal lcnfunc\n\tlocal dt\n\tlocal n\n\tlocal rtsrc_nsname\n\tlocal rtdst_nsname\n\n\trtsrc_nsname=\"$(get_rtname \"${src}\")\"\n\trtdst_nsname=\"$(get_rtname \"${dst}\")\"\n\n\tcontainer=\"${LCBLOCK_ADDR}\"\n\n\t# build first SID (C-SID container)\n\tfor n in ${end_rts}; do\n\t\tlcnfunc=\"$(build_csid \"${n}\")\"\n\n\t\tcontainer=\"${container}${lcnfunc}\"\n\tdone\n\n\tif [ \"${mode}\" -eq 1 ]; then\n\t\t# single SID policy\n\t\tdt=\"$(build_csid \"${dst}\")${DT46_FUNC}\"\n\t\tcontainer=\"${container}${dt}\"\n\t\t# build the full ipv6 address for the container\n\t\tpolicy=\"$(build_ipv6_addr \"${container}\")\"\n\n\t\t# build the decap SID used in the decap node\n\t\tcontainer=\"${LCBLOCK_ADDR}${dt}\"\n\t\tdecapsid=\"$(build_ipv6_addr \"${container}\")\"\n\telse\n\t\t# double SID policy\n\t\tdecapsid=\"${VPN_LOCATOR_SERVICE}:${dst}::${DT46_FUNC}\"\n\n\t\tpolicy=\"$(build_ipv6_addr \"${container}\"),${decapsid}\"\n\tfi\n\n\t# apply encap policy\n\tif [ \"${traffic}\" -eq 6 ]; then\n\t\tip -netns \"${rtsrc_nsname}\" -6 route \\\n\t\t\tadd \"${IPv6_HS_NETWORK}::${dst}\" vrf \"${VRF_DEVNAME}\" \\\n\t\t\tencap seg6 mode \"${HEADEND_ENCAP}\" segs \"${policy}\" \\\n\t\t\tdev \"${VRF_DEVNAME}\"\n\n\t\tip -netns \"${rtsrc_nsname}\" -6 neigh \\\n\t\t\tadd proxy \"${IPv6_HS_NETWORK}::${dst}\" \\\n\t\t\tdev \"${RT2HS_DEVNAME}\"\n\telse\n\t\t# \"dev\" must be different from the one where the packet is\n\t\t# received, otherwise the proxy arp does not work.\n\t\tip -netns \"${rtsrc_nsname}\" -4 route \\\n\t\t\tadd \"${IPv4_HS_NETWORK}.${dst}\" vrf \"${VRF_DEVNAME}\" \\\n\t\t\tencap seg6 mode \"${HEADEND_ENCAP}\" segs \"${policy}\" \\\n\t\t\tdev \"${VRF_DEVNAME}\"\n\tfi\n\n\t# apply decap\n\t# Local End.DT46 behavior (decap)\n\tip -netns \"${rtdst_nsname}\" -6 route \\\n\t\tadd \"${decapsid}\" \\\n\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\tencap seg6local action End.DT46 vrftable \"${VRF_TID}\" \\\n\t\tdev \"${VRF_DEVNAME}\"\n}\n\n# see __setup_l3vpn()\nsetup_ipv4_vpn_2sids()\n{\n\t__setup_l3vpn \"$1\" \"$2\" \"$3\" 2 4\n}\n\n# see __setup_l3vpn()\nsetup_ipv6_vpn_1sid()\n{\n\t__setup_l3vpn \"$1\" \"$2\" \"$3\" 1 6\n}\n\nsetup_hs()\n{\n\tlocal hs=\"$1\"\n\tlocal rt=\"$2\"\n\tlocal hsname\n\tlocal rtname\n\n\thsname=\"$(get_hsname \"${hs}\")\"\n\trtname=\"$(get_rtname \"${rt}\")\"\n\n\tip netns exec \"${hsname}\" sysctl -wq net.ipv6.conf.all.accept_dad=0\n\tip netns exec \"${hsname}\" sysctl -wq net.ipv6.conf.default.accept_dad=0\n\n\tip -netns \"${hsname}\" link add veth0 type veth \\\n\t\tpeer name \"${RT2HS_DEVNAME}\" netns \"${rtname}\"\n\n\tip -netns \"${hsname}\" addr \\\n\t\tadd \"${IPv6_HS_NETWORK}::${hs}/64\" dev veth0 nodad\n\tip -netns \"${hsname}\" addr add \"${IPv4_HS_NETWORK}.${hs}/24\" dev veth0\n\n\tip -netns \"${hsname}\" link set veth0 up\n\tip -netns \"${hsname}\" link set lo up\n\n\t# configure the VRF on the router which is directly connected to the\n\t# source host.\n\tip -netns \"${rtname}\" link \\\n\t\tadd \"${VRF_DEVNAME}\" type vrf table \"${VRF_TID}\"\n\tip -netns \"${rtname}\" link set \"${VRF_DEVNAME}\" up\n\n\t# enslave the veth interface connecting the router with the host to the\n\t# VRF in the access router\n\tip -netns \"${rtname}\" link \\\n\t\tset \"${RT2HS_DEVNAME}\" master \"${VRF_DEVNAME}\"\n\n\t# set default routes to unreachable for both ipv6 and ipv4\n\tip -netns \"${rtname}\" -6 route \\\n\t\tadd unreachable default metric 4278198272 \\\n\t\tvrf \"${VRF_DEVNAME}\"\n\tip -netns \"${rtname}\" -4 route \\\n\t\tadd unreachable default metric 4278198272 \\\n\t\tvrf \"${VRF_DEVNAME}\"\n\n\tip -netns \"${rtname}\" addr \\\n\t\tadd \"${IPv6_HS_NETWORK}::254/64\" dev \"${RT2HS_DEVNAME}\" nodad\n\tip -netns \"${rtname}\" addr \\\n\t\tadd \"${IPv4_HS_NETWORK}.254/24\" dev \"${RT2HS_DEVNAME}\"\n\n\tip -netns \"${rtname}\" link set \"${RT2HS_DEVNAME}\" up\n\n\tip netns exec \"${rtname}\" \\\n\t\tsysctl -wq net.ipv6.conf.\"${RT2HS_DEVNAME}\".proxy_ndp=1\n\tip netns exec \"${rtname}\" \\\n\t\tsysctl -wq net.ipv4.conf.\"${RT2HS_DEVNAME}\".proxy_arp=1\n\n\t# disable the rp_filter otherwise the kernel gets confused about how\n\t# to route decap ipv4 packets.\n\tip netns exec \"${rtname}\" \\\n\t\tsysctl -wq net.ipv4.conf.\"${RT2HS_DEVNAME}\".rp_filter=0\n\n\tip netns exec \"${rtname}\" sh -c \"echo 1 > /proc/sys/net/vrf/strict_mode\"\n}\n\nsetup()\n{\n\tlocal i\n\n\t# create routers\n\tROUTERS=\"1 2 3 4\"; readonly ROUTERS\n\tfor i in ${ROUTERS}; do\n\t\tcreate_router \"${i}\"\n\tdone\n\n\t# create hosts\n\tHOSTS=\"1 2\"; readonly HOSTS\n\tfor i in ${HOSTS}; do\n\t\tcreate_host \"${i}\"\n\tdone\n\n\t# set up the links for connecting routers\n\tadd_link_rt_pairs 1 \"2 3 4\"\n\tadd_link_rt_pairs 2 \"3 4\"\n\tadd_link_rt_pairs 3 \"4\"\n\n\t# set up the basic connectivity of routers and routes required for\n\t# reachability of SIDs.\n\tsetup_rt_networking 1 \"2 3 4\"\n\tsetup_rt_networking 2 \"1 3 4\"\n\tsetup_rt_networking 3 \"1 2 4\"\n\tsetup_rt_networking 4 \"1 2 3\"\n\n\t# set up the hosts connected to routers\n\tsetup_hs 1 1\n\tsetup_hs 2 2\n\n\t# set up default SRv6 Endpoints (i.e. SRv6 End and SRv6 End.DT46)\n\tsetup_rt_local_sids 1 \"2 3 4\"\n\tsetup_rt_local_sids 2 \"1 3 4\"\n\tsetup_rt_local_sids 3 \"1 2 4\"\n\tsetup_rt_local_sids 4 \"1 2 3\"\n\n\t# set up SRv6 Policies\n\n\t# create an IPv6 VPN between hosts hs-1 and hs-2.\n\t#\n\t# Direction hs-1 -> hs-2\n\t# - rt-1 encap (H.Encaps.Red)\n\t# - rt-4 SRv6 End behavior (NEXT-C-SID flavor)\n\t# - rt-3 SRv6 End behavior (NEXT-C-SID flavor)\n\t# - rt-2 SRv6 End.DT46 behavior\n\tsetup_ipv6_vpn_1sid 1 2 \"4 3\"\n\n\t# Direction hs2 -> hs-1\n\t# - rt-2 encap (H.Encaps.Red)\n\t# - rt-3 SRv6 End behavior (NEXT-C-SID flavor)\n\t# - rt-4 SRv6 End behavior (NEXT-C-SID flavor)\n\t# - rt-1 SRv6 End.DT46 behavior\n\tsetup_ipv6_vpn_1sid 2 1 \"3 4\"\n\n\t# create an IPv4 VPN between hosts hs-1 and hs-2\n\t#\n\t# Direction hs-1 -> hs-2\n\t# - rt-1 encap (H.Encaps.Red)\n\t# - rt-3 SRv6 End behavior (NEXT-C-SID flavor)\n\t# - rt-2 SRv6 End.DT46 behavior\n\tsetup_ipv4_vpn_2sids 1 2 \"3\"\n\n\t# Direction hs-2 -> hs-1\n\t# - rt-2 encap (H.Encaps.Red)\n\t# - rt-3 SRv6 End behavior (NEXT-C-SID flavor)\n\t# - rt-1 SRv6 End.DT46 behavior\n\tsetup_ipv4_vpn_2sids 2 1 \"3\"\n\n\t# testing environment was set up successfully\n\tSETUP_ERR=0\n}\n\ncheck_rt_connectivity()\n{\n\tlocal rtsrc=\"$1\"\n\tlocal rtdst=\"$2\"\n\tlocal prefix\n\tlocal rtsrc_nsname\n\n\trtsrc_nsname=\"$(get_rtname \"${rtsrc}\")\"\n\n\tprefix=\"$(get_network_prefix \"${rtsrc}\" \"${rtdst}\")\"\n\n\tip netns exec \"${rtsrc_nsname}\" ping -c 1 -W \"${PING_TIMEOUT_SEC}\" \\\n\t\t\"${prefix}::${rtdst}\" >/dev/null 2>&1\n}\n\ncheck_and_log_rt_connectivity()\n{\n\tlocal rtsrc=\"$1\"\n\tlocal rtdst=\"$2\"\n\n\tcheck_rt_connectivity \"${rtsrc}\" \"${rtdst}\"\n\tlog_test $? 0 \"Routers connectivity: rt-${rtsrc} -> rt-${rtdst}\"\n}\n\ncheck_hs_ipv6_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\tlocal hssrc_nsname\n\n\thssrc_nsname=\"$(get_hsname \"${hssrc}\")\"\n\n\tip netns exec \"${hssrc_nsname}\" ping -c 1 -W \"${PING_TIMEOUT_SEC}\" \\\n\t\t\"${IPv6_HS_NETWORK}::${hsdst}\" >/dev/null 2>&1\n}\n\ncheck_hs_ipv4_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\tlocal hssrc_nsname\n\n\thssrc_nsname=\"$(get_hsname \"${hssrc}\")\"\n\n\tip netns exec \"${hssrc_nsname}\" ping -c 1 -W \"${PING_TIMEOUT_SEC}\" \\\n\t\t\"${IPv4_HS_NETWORK}.${hsdst}\" >/dev/null 2>&1\n}\n\ncheck_and_log_hs2gw_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\n\tcheck_hs_ipv6_connectivity \"${hssrc}\" 254\n\tlog_test $? 0 \"IPv6 Hosts connectivity: hs-${hssrc} -> gw\"\n\n\tcheck_hs_ipv4_connectivity \"${hssrc}\" 254\n\tlog_test $? 0 \"IPv4 Hosts connectivity: hs-${hssrc} -> gw\"\n}\n\ncheck_and_log_hs_ipv6_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\n\tcheck_hs_ipv6_connectivity \"${hssrc}\" \"${hsdst}\"\n\tlog_test $? 0 \"IPv6 Hosts connectivity: hs-${hssrc} -> hs-${hsdst}\"\n}\n\ncheck_and_log_hs_ipv4_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\n\tcheck_hs_ipv4_connectivity \"${hssrc}\" \"${hsdst}\"\n\tlog_test $? 0 \"IPv4 Hosts connectivity: hs-${hssrc} -> hs-${hsdst}\"\n}\n\nrouter_tests()\n{\n\tlocal i\n\tlocal j\n\n\tlog_section \"IPv6 routers connectivity test\"\n\n\tfor i in ${ROUTERS}; do\n\t\tfor j in ${ROUTERS}; do\n\t\t\tif [ \"${i}\" -eq \"${j}\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\tcheck_and_log_rt_connectivity \"${i}\" \"${j}\"\n\t\tdone\n\tdone\n}\n\nhost2gateway_tests()\n{\n\tlocal hs\n\n\tlog_section \"IPv4/IPv6 connectivity test among hosts and gateways\"\n\n\tfor hs in ${HOSTS}; do\n\t\tcheck_and_log_hs2gw_connectivity \"${hs}\"\n\tdone\n}\n\nhost_vpn_tests()\n{\n\tlog_section \"SRv6 VPN connectivity test hosts (h1 <-> h2, IPv6)\"\n\n\tcheck_and_log_hs_ipv6_connectivity 1 2\n\tcheck_and_log_hs_ipv6_connectivity 2 1\n\n\tlog_section \"SRv6 VPN connectivity test hosts (h1 <-> h2, IPv4)\"\n\n\tcheck_and_log_hs_ipv4_connectivity 1 2\n\tcheck_and_log_hs_ipv4_connectivity 2 1\n}\n\n__nextcsid_end_behavior_test()\n{\n\tlocal nsname=\"$1\"\n\tlocal cmd=\"$2\"\n\tlocal blen=\"$3\"\n\tlocal flen=\"$4\"\n\tlocal layout=\"\"\n\n\tif [ \"${blen}\" != \"d\" ]; then\n\t\tlayout=\"${layout} lblen ${blen}\"\n\tfi\n\n\tif [ \"${flen}\" != \"d\" ]; then\n\t\tlayout=\"${layout} nflen ${flen}\"\n\tfi\n\n\tip -netns \"${nsname}\" -6 route \\\n\t\t\"${cmd}\" \"${CSID_CNTR_PREFIX}\" \\\n\t\ttable \"${CSID_CNTR_RT_TABLE}\" \\\n\t\tencap seg6local action End flavors next-csid ${layout} \\\n\t\tdev \"${DUMMY_DEVNAME}\" &>/dev/null\n\n\treturn \"$?\"\n}\n\nrt_x_nextcsid_end_behavior_test()\n{\n\tlocal rt=\"$1\"\n\tlocal blen=\"$2\"\n\tlocal flen=\"$3\"\n\tlocal nsname\n\tlocal ret\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\t__nextcsid_end_behavior_test \"${nsname}\" \"add\" \"${blen}\" \"${flen}\"\n\tret=\"$?\"\n\t__nextcsid_end_behavior_test \"${nsname}\" \"del\" \"${blen}\" \"${flen}\"\n\n\treturn \"${ret}\"\n}\n\n__parse_csid_container_cfg()\n{\n\tlocal cfg=\"$1\"\n\tlocal index=\"$2\"\n\tlocal out\n\n\techo \"${cfg}\" | cut -d',' -f\"${index}\"\n}\n\ncsid_container_cfg_tests()\n{\n\tlocal valid\n\tlocal blen\n\tlocal flen\n\tlocal cfg\n\tlocal ret\n\n\tlog_section \"C-SID Container config tests (legend: d='kernel default')\"\n\n\tfor cfg in \"${CSID_CONTAINER_CFGS[@]}\"; do\n\t\tblen=\"$(__parse_csid_container_cfg \"${cfg}\" 1)\"\n\t\tflen=\"$(__parse_csid_container_cfg \"${cfg}\" 2)\"\n\t\tvalid=\"$(__parse_csid_container_cfg \"${cfg}\" 3)\"\n\n\t\trt_x_nextcsid_end_behavior_test \\\n\t\t\t\"${CSID_CNTR_RT_ID_TEST}\" \\\n\t\t\t\"${blen}\" \\\n\t\t\t\"${flen}\"\n\t\tret=\"$?\"\n\n\t\tif [ \"${valid}\" == \"y\" ]; then\n\t\t\tlog_test \"${ret}\" 0 \\\n\t\t\t\t\"Accept valid C-SID container cfg (lblen=${blen}, nflen=${flen})\"\n\t\telse\n\t\t\tlog_test \"${ret}\" 2 \\\n\t\t\t\t\"Reject invalid C-SID container cfg (lblen=${blen}, nflen=${flen})\"\n\t\tfi\n\tdone\n}\n\ntest_iproute2_supp_or_ksft_skip()\n{\n\tif ! ip route help 2>&1 | grep -qo \"next-csid\"; then\n\t\techo \"SKIP: Missing SRv6 NEXT-C-SID flavor support in iproute2\"\n\t\texit \"${ksft_skip}\"\n\tfi\n}\n\ntest_dummy_dev_or_ksft_skip()\n{\n        local test_netns\n\n        test_netns=\"dummy-$(mktemp -u XXXXXXXX)\"\n\n        if ! ip netns add \"${test_netns}\"; then\n                echo \"SKIP: Cannot set up netns for testing dummy dev support\"\n                exit \"${ksft_skip}\"\n        fi\n\n        modprobe dummy &>/dev/null || true\n        if ! ip -netns \"${test_netns}\" link \\\n                add \"${DUMMY_DEVNAME}\" type dummy; then\n                echo \"SKIP: dummy dev not supported\"\n\n                ip netns del \"${test_netns}\"\n                exit \"${ksft_skip}\"\n        fi\n\n        ip netns del \"${test_netns}\"\n}\n\ntest_vrf_or_ksft_skip()\n{\n\tmodprobe vrf &>/dev/null || true\n\tif [ ! -e /proc/sys/net/vrf/strict_mode ]; then\n\t\techo \"SKIP: vrf sysctl does not exist\"\n\t\texit \"${ksft_skip}\"\n\tfi\n}\n\nif [ \"$(id -u)\" -ne 0 ]; then\n\techo \"SKIP: Need root privileges\"\n\texit \"${ksft_skip}\"\nfi\n\n# required programs to carry out this selftest\ntest_command_or_ksft_skip ip\ntest_command_or_ksft_skip ping\ntest_command_or_ksft_skip sysctl\ntest_command_or_ksft_skip grep\ntest_command_or_ksft_skip cut\n\ntest_iproute2_supp_or_ksft_skip\ntest_dummy_dev_or_ksft_skip\ntest_vrf_or_ksft_skip\n\nset -e\ntrap cleanup EXIT\n\nsetup\nset +e\n\ncsid_container_cfg_tests\n\nrouter_tests\nhost2gateway_tests\nhost_vpn_tests\n\nprint_log_test_results\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}