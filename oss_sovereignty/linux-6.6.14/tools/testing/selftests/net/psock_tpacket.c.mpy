{
  "module_name": "psock_tpacket.c",
  "hash_id": "6a245b0bd459d34ff538c74440f3e66e226849721ee229055ac336f531ebe8a1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/psock_tpacket.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <linux/if_packet.h>\n#include <linux/filter.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <bits/wordsize.h>\n#include <net/ethernet.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n#include <stdint.h>\n#include <string.h>\n#include <assert.h>\n#include <net/if.h>\n#include <inttypes.h>\n#include <poll.h>\n\n#include \"psock_lib.h\"\n\n#include \"../kselftest.h\"\n\n#ifndef bug_on\n# define bug_on(cond)\t\tassert(!(cond))\n#endif\n\n#ifndef __aligned_tpacket\n# define __aligned_tpacket\t__attribute__((aligned(TPACKET_ALIGNMENT)))\n#endif\n\n#ifndef __align_tpacket\n# define __align_tpacket(x)\t__attribute__((aligned(TPACKET_ALIGN(x))))\n#endif\n\n#define NUM_PACKETS\t\t100\n#define ALIGN_8(x)\t\t(((x) + 8 - 1) & ~(8 - 1))\n\nstruct ring {\n\tstruct iovec *rd;\n\tuint8_t *mm_space;\n\tsize_t mm_len, rd_len;\n\tstruct sockaddr_ll ll;\n\tvoid (*walk)(int sock, struct ring *ring);\n\tint type, rd_num, flen, version;\n\tunion {\n\t\tstruct tpacket_req  req;\n\t\tstruct tpacket_req3 req3;\n\t};\n};\n\nstruct block_desc {\n\tuint32_t version;\n\tuint32_t offset_to_priv;\n\tstruct tpacket_hdr_v1 h1;\n};\n\nunion frame_map {\n\tstruct {\n\t\tstruct tpacket_hdr tp_h __aligned_tpacket;\n\t\tstruct sockaddr_ll s_ll __align_tpacket(sizeof(struct tpacket_hdr));\n\t} *v1;\n\tstruct {\n\t\tstruct tpacket2_hdr tp_h __aligned_tpacket;\n\t\tstruct sockaddr_ll s_ll __align_tpacket(sizeof(struct tpacket2_hdr));\n\t} *v2;\n\tvoid *raw;\n};\n\nstatic unsigned int total_packets, total_bytes;\n\nstatic int pfsocket(int ver)\n{\n\tint ret, sock = socket(PF_PACKET, SOCK_RAW, 0);\n\tif (sock == -1) {\n\t\tperror(\"socket\");\n\t\texit(1);\n\t}\n\n\tret = setsockopt(sock, SOL_PACKET, PACKET_VERSION, &ver, sizeof(ver));\n\tif (ret == -1) {\n\t\tperror(\"setsockopt\");\n\t\texit(1);\n\t}\n\n\treturn sock;\n}\n\nstatic void status_bar_update(void)\n{\n\tif (total_packets % 10 == 0) {\n\t\tfprintf(stderr, \".\");\n\t\tfflush(stderr);\n\t}\n}\n\nstatic void test_payload(void *pay, size_t len)\n{\n\tstruct ethhdr *eth = pay;\n\n\tif (len < sizeof(struct ethhdr)) {\n\t\tfprintf(stderr, \"test_payload: packet too \"\n\t\t\t\"small: %zu bytes!\\n\", len);\n\t\texit(1);\n\t}\n\n\tif (eth->h_proto != htons(ETH_P_IP)) {\n\t\tfprintf(stderr, \"test_payload: wrong ethernet \"\n\t\t\t\"type: 0x%x!\\n\", ntohs(eth->h_proto));\n\t\texit(1);\n\t}\n}\n\nstatic void create_payload(void *pay, size_t *len)\n{\n\tint i;\n\tstruct ethhdr *eth = pay;\n\tstruct iphdr *ip = pay + sizeof(*eth);\n\n\t \n\n\t*len = DATA_LEN + 42;\n\n\tmemset(pay, 0xff, ETH_ALEN * 2);\n\teth->h_proto = htons(ETH_P_IP);\n\n\tfor (i = 0; i < sizeof(*ip); ++i)\n\t\t((uint8_t *) pay)[i + sizeof(*eth)] = (uint8_t) rand();\n\n\tip->ihl = 5;\n\tip->version = 4;\n\tip->protocol = 0x11;\n\tip->frag_off = 0;\n\tip->ttl = 64;\n\tip->tot_len = htons((uint16_t) *len - sizeof(*eth));\n\n\tip->saddr = htonl(INADDR_LOOPBACK);\n\tip->daddr = htonl(INADDR_LOOPBACK);\n\n\tmemset(pay + sizeof(*eth) + sizeof(*ip),\n\t       DATA_CHAR, DATA_LEN);\n}\n\nstatic inline int __v1_rx_kernel_ready(struct tpacket_hdr *hdr)\n{\n\treturn ((hdr->tp_status & TP_STATUS_USER) == TP_STATUS_USER);\n}\n\nstatic inline void __v1_rx_user_ready(struct tpacket_hdr *hdr)\n{\n\thdr->tp_status = TP_STATUS_KERNEL;\n\t__sync_synchronize();\n}\n\nstatic inline int __v2_rx_kernel_ready(struct tpacket2_hdr *hdr)\n{\n\treturn ((hdr->tp_status & TP_STATUS_USER) == TP_STATUS_USER);\n}\n\nstatic inline void __v2_rx_user_ready(struct tpacket2_hdr *hdr)\n{\n\thdr->tp_status = TP_STATUS_KERNEL;\n\t__sync_synchronize();\n}\n\nstatic inline int __v1_v2_rx_kernel_ready(void *base, int version)\n{\n\tswitch (version) {\n\tcase TPACKET_V1:\n\t\treturn __v1_rx_kernel_ready(base);\n\tcase TPACKET_V2:\n\t\treturn __v2_rx_kernel_ready(base);\n\tdefault:\n\t\tbug_on(1);\n\t\treturn 0;\n\t}\n}\n\nstatic inline void __v1_v2_rx_user_ready(void *base, int version)\n{\n\tswitch (version) {\n\tcase TPACKET_V1:\n\t\t__v1_rx_user_ready(base);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\t__v2_rx_user_ready(base);\n\t\tbreak;\n\t}\n}\n\nstatic void walk_v1_v2_rx(int sock, struct ring *ring)\n{\n\tstruct pollfd pfd;\n\tint udp_sock[2];\n\tunion frame_map ppd;\n\tunsigned int frame_num = 0;\n\n\tbug_on(ring->type != PACKET_RX_RING);\n\n\tpair_udp_open(udp_sock, PORT_BASE);\n\n\tmemset(&pfd, 0, sizeof(pfd));\n\tpfd.fd = sock;\n\tpfd.events = POLLIN | POLLERR;\n\tpfd.revents = 0;\n\n\tpair_udp_send(udp_sock, NUM_PACKETS);\n\n\twhile (total_packets < NUM_PACKETS * 2) {\n\t\twhile (__v1_v2_rx_kernel_ready(ring->rd[frame_num].iov_base,\n\t\t\t\t\t       ring->version)) {\n\t\t\tppd.raw = ring->rd[frame_num].iov_base;\n\n\t\t\tswitch (ring->version) {\n\t\t\tcase TPACKET_V1:\n\t\t\t\ttest_payload((uint8_t *) ppd.raw + ppd.v1->tp_h.tp_mac,\n\t\t\t\t\t     ppd.v1->tp_h.tp_snaplen);\n\t\t\t\ttotal_bytes += ppd.v1->tp_h.tp_snaplen;\n\t\t\t\tbreak;\n\n\t\t\tcase TPACKET_V2:\n\t\t\t\ttest_payload((uint8_t *) ppd.raw + ppd.v2->tp_h.tp_mac,\n\t\t\t\t\t     ppd.v2->tp_h.tp_snaplen);\n\t\t\t\ttotal_bytes += ppd.v2->tp_h.tp_snaplen;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus_bar_update();\n\t\t\ttotal_packets++;\n\n\t\t\t__v1_v2_rx_user_ready(ppd.raw, ring->version);\n\n\t\t\tframe_num = (frame_num + 1) % ring->rd_num;\n\t\t}\n\n\t\tpoll(&pfd, 1, 1);\n\t}\n\n\tpair_udp_close(udp_sock);\n\n\tif (total_packets != 2 * NUM_PACKETS) {\n\t\tfprintf(stderr, \"walk_v%d_rx: received %u out of %u pkts\\n\",\n\t\t\tring->version, total_packets, NUM_PACKETS);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \" %u pkts (%u bytes)\", NUM_PACKETS, total_bytes >> 1);\n}\n\nstatic inline int __v1_tx_kernel_ready(struct tpacket_hdr *hdr)\n{\n\treturn !(hdr->tp_status & (TP_STATUS_SEND_REQUEST | TP_STATUS_SENDING));\n}\n\nstatic inline void __v1_tx_user_ready(struct tpacket_hdr *hdr)\n{\n\thdr->tp_status = TP_STATUS_SEND_REQUEST;\n\t__sync_synchronize();\n}\n\nstatic inline int __v2_tx_kernel_ready(struct tpacket2_hdr *hdr)\n{\n\treturn !(hdr->tp_status & (TP_STATUS_SEND_REQUEST | TP_STATUS_SENDING));\n}\n\nstatic inline void __v2_tx_user_ready(struct tpacket2_hdr *hdr)\n{\n\thdr->tp_status = TP_STATUS_SEND_REQUEST;\n\t__sync_synchronize();\n}\n\nstatic inline int __v3_tx_kernel_ready(struct tpacket3_hdr *hdr)\n{\n\treturn !(hdr->tp_status & (TP_STATUS_SEND_REQUEST | TP_STATUS_SENDING));\n}\n\nstatic inline void __v3_tx_user_ready(struct tpacket3_hdr *hdr)\n{\n\thdr->tp_status = TP_STATUS_SEND_REQUEST;\n\t__sync_synchronize();\n}\n\nstatic inline int __tx_kernel_ready(void *base, int version)\n{\n\tswitch (version) {\n\tcase TPACKET_V1:\n\t\treturn __v1_tx_kernel_ready(base);\n\tcase TPACKET_V2:\n\t\treturn __v2_tx_kernel_ready(base);\n\tcase TPACKET_V3:\n\t\treturn __v3_tx_kernel_ready(base);\n\tdefault:\n\t\tbug_on(1);\n\t\treturn 0;\n\t}\n}\n\nstatic inline void __tx_user_ready(void *base, int version)\n{\n\tswitch (version) {\n\tcase TPACKET_V1:\n\t\t__v1_tx_user_ready(base);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\t__v2_tx_user_ready(base);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t__v3_tx_user_ready(base);\n\t\tbreak;\n\t}\n}\n\nstatic void __v1_v2_set_packet_loss_discard(int sock)\n{\n\tint ret, discard = 1;\n\n\tret = setsockopt(sock, SOL_PACKET, PACKET_LOSS, (void *) &discard,\n\t\t\t sizeof(discard));\n\tif (ret == -1) {\n\t\tperror(\"setsockopt\");\n\t\texit(1);\n\t}\n}\n\nstatic inline void *get_next_frame(struct ring *ring, int n)\n{\n\tuint8_t *f0 = ring->rd[0].iov_base;\n\n\tswitch (ring->version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\treturn ring->rd[n].iov_base;\n\tcase TPACKET_V3:\n\t\treturn f0 + (n * ring->req3.tp_frame_size);\n\tdefault:\n\t\tbug_on(1);\n\t}\n}\n\nstatic void walk_tx(int sock, struct ring *ring)\n{\n\tstruct pollfd pfd;\n\tint rcv_sock, ret;\n\tsize_t packet_len;\n\tunion frame_map ppd;\n\tchar packet[1024];\n\tunsigned int frame_num = 0, got = 0;\n\tstruct sockaddr_ll ll = {\n\t\t.sll_family = PF_PACKET,\n\t\t.sll_halen = ETH_ALEN,\n\t};\n\tint nframes;\n\n\t \n\tif (ring->version <= TPACKET_V2)\n\t\tnframes = ring->rd_num;\n\telse\n\t\tnframes = ring->req3.tp_frame_nr;\n\n\tbug_on(ring->type != PACKET_TX_RING);\n\tbug_on(nframes < NUM_PACKETS);\n\n\trcv_sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));\n\tif (rcv_sock == -1) {\n\t\tperror(\"socket\");\n\t\texit(1);\n\t}\n\n\tpair_udp_setfilter(rcv_sock);\n\n\tll.sll_ifindex = if_nametoindex(\"lo\");\n\tret = bind(rcv_sock, (struct sockaddr *) &ll, sizeof(ll));\n\tif (ret == -1) {\n\t\tperror(\"bind\");\n\t\texit(1);\n\t}\n\n\tmemset(&pfd, 0, sizeof(pfd));\n\tpfd.fd = sock;\n\tpfd.events = POLLOUT | POLLERR;\n\tpfd.revents = 0;\n\n\ttotal_packets = NUM_PACKETS;\n\tcreate_payload(packet, &packet_len);\n\n\twhile (total_packets > 0) {\n\t\tvoid *next = get_next_frame(ring, frame_num);\n\n\t\twhile (__tx_kernel_ready(next, ring->version) &&\n\t\t       total_packets > 0) {\n\t\t\tppd.raw = next;\n\n\t\t\tswitch (ring->version) {\n\t\t\tcase TPACKET_V1:\n\t\t\t\tppd.v1->tp_h.tp_snaplen = packet_len;\n\t\t\t\tppd.v1->tp_h.tp_len = packet_len;\n\n\t\t\t\tmemcpy((uint8_t *) ppd.raw + TPACKET_HDRLEN -\n\t\t\t\t       sizeof(struct sockaddr_ll), packet,\n\t\t\t\t       packet_len);\n\t\t\t\ttotal_bytes += ppd.v1->tp_h.tp_snaplen;\n\t\t\t\tbreak;\n\n\t\t\tcase TPACKET_V2:\n\t\t\t\tppd.v2->tp_h.tp_snaplen = packet_len;\n\t\t\t\tppd.v2->tp_h.tp_len = packet_len;\n\n\t\t\t\tmemcpy((uint8_t *) ppd.raw + TPACKET2_HDRLEN -\n\t\t\t\t       sizeof(struct sockaddr_ll), packet,\n\t\t\t\t       packet_len);\n\t\t\t\ttotal_bytes += ppd.v2->tp_h.tp_snaplen;\n\t\t\t\tbreak;\n\t\t\tcase TPACKET_V3: {\n\t\t\t\tstruct tpacket3_hdr *tx = next;\n\n\t\t\t\ttx->tp_snaplen = packet_len;\n\t\t\t\ttx->tp_len = packet_len;\n\t\t\t\ttx->tp_next_offset = 0;\n\n\t\t\t\tmemcpy((uint8_t *)tx + TPACKET3_HDRLEN -\n\t\t\t\t       sizeof(struct sockaddr_ll), packet,\n\t\t\t\t       packet_len);\n\t\t\t\ttotal_bytes += tx->tp_snaplen;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\n\t\t\tstatus_bar_update();\n\t\t\ttotal_packets--;\n\n\t\t\t__tx_user_ready(next, ring->version);\n\n\t\t\tframe_num = (frame_num + 1) % nframes;\n\t\t}\n\n\t\tpoll(&pfd, 1, 1);\n\t}\n\n\tbug_on(total_packets != 0);\n\n\tret = sendto(sock, NULL, 0, 0, NULL, 0);\n\tif (ret == -1) {\n\t\tperror(\"sendto\");\n\t\texit(1);\n\t}\n\n\twhile ((ret = recvfrom(rcv_sock, packet, sizeof(packet),\n\t\t\t       0, NULL, NULL)) > 0 &&\n\t       total_packets < NUM_PACKETS) {\n\t\tgot += ret;\n\t\ttest_payload(packet, ret);\n\n\t\tstatus_bar_update();\n\t\ttotal_packets++;\n\t}\n\n\tclose(rcv_sock);\n\n\tif (total_packets != NUM_PACKETS) {\n\t\tfprintf(stderr, \"walk_v%d_rx: received %u out of %u pkts\\n\",\n\t\t\tring->version, total_packets, NUM_PACKETS);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \" %u pkts (%u bytes)\", NUM_PACKETS, got);\n}\n\nstatic void walk_v1_v2(int sock, struct ring *ring)\n{\n\tif (ring->type == PACKET_RX_RING)\n\t\twalk_v1_v2_rx(sock, ring);\n\telse\n\t\twalk_tx(sock, ring);\n}\n\nstatic uint64_t __v3_prev_block_seq_num = 0;\n\nvoid __v3_test_block_seq_num(struct block_desc *pbd)\n{\n\tif (__v3_prev_block_seq_num + 1 != pbd->h1.seq_num) {\n\t\tfprintf(stderr, \"\\nprev_block_seq_num:%\"PRIu64\", expected \"\n\t\t\t\"seq:%\"PRIu64\" != actual seq:%\"PRIu64\"\\n\",\n\t\t\t__v3_prev_block_seq_num, __v3_prev_block_seq_num + 1,\n\t\t\t(uint64_t) pbd->h1.seq_num);\n\t\texit(1);\n\t}\n\n\t__v3_prev_block_seq_num = pbd->h1.seq_num;\n}\n\nstatic void __v3_test_block_len(struct block_desc *pbd, uint32_t bytes, int block_num)\n{\n\tif (pbd->h1.num_pkts && bytes != pbd->h1.blk_len) {\n\t\tfprintf(stderr, \"\\nblock:%u with %upackets, expected \"\n\t\t\t\"len:%u != actual len:%u\\n\", block_num,\n\t\t\tpbd->h1.num_pkts, bytes, pbd->h1.blk_len);\n\t\texit(1);\n\t}\n}\n\nstatic void __v3_test_block_header(struct block_desc *pbd, const int block_num)\n{\n\tif ((pbd->h1.block_status & TP_STATUS_USER) == 0) {\n\t\tfprintf(stderr, \"\\nblock %u: not in TP_STATUS_USER\\n\", block_num);\n\t\texit(1);\n\t}\n\n\t__v3_test_block_seq_num(pbd);\n}\n\nstatic void __v3_walk_block(struct block_desc *pbd, const int block_num)\n{\n\tint num_pkts = pbd->h1.num_pkts, i;\n\tunsigned long bytes = 0, bytes_with_padding = ALIGN_8(sizeof(*pbd));\n\tstruct tpacket3_hdr *ppd;\n\n\t__v3_test_block_header(pbd, block_num);\n\n\tppd = (struct tpacket3_hdr *) ((uint8_t *) pbd +\n\t\t\t\t       pbd->h1.offset_to_first_pkt);\n\n\tfor (i = 0; i < num_pkts; ++i) {\n\t\tbytes += ppd->tp_snaplen;\n\n\t\tif (ppd->tp_next_offset)\n\t\t\tbytes_with_padding += ppd->tp_next_offset;\n\t\telse\n\t\t\tbytes_with_padding += ALIGN_8(ppd->tp_snaplen + ppd->tp_mac);\n\n\t\ttest_payload((uint8_t *) ppd + ppd->tp_mac, ppd->tp_snaplen);\n\n\t\tstatus_bar_update();\n\t\ttotal_packets++;\n\n\t\tppd = (struct tpacket3_hdr *) ((uint8_t *) ppd + ppd->tp_next_offset);\n\t\t__sync_synchronize();\n\t}\n\n\t__v3_test_block_len(pbd, bytes_with_padding, block_num);\n\ttotal_bytes += bytes;\n}\n\nvoid __v3_flush_block(struct block_desc *pbd)\n{\n\tpbd->h1.block_status = TP_STATUS_KERNEL;\n\t__sync_synchronize();\n}\n\nstatic void walk_v3_rx(int sock, struct ring *ring)\n{\n\tunsigned int block_num = 0;\n\tstruct pollfd pfd;\n\tstruct block_desc *pbd;\n\tint udp_sock[2];\n\n\tbug_on(ring->type != PACKET_RX_RING);\n\n\tpair_udp_open(udp_sock, PORT_BASE);\n\n\tmemset(&pfd, 0, sizeof(pfd));\n\tpfd.fd = sock;\n\tpfd.events = POLLIN | POLLERR;\n\tpfd.revents = 0;\n\n\tpair_udp_send(udp_sock, NUM_PACKETS);\n\n\twhile (total_packets < NUM_PACKETS * 2) {\n\t\tpbd = (struct block_desc *) ring->rd[block_num].iov_base;\n\n\t\twhile ((pbd->h1.block_status & TP_STATUS_USER) == 0)\n\t\t\tpoll(&pfd, 1, 1);\n\n\t\t__v3_walk_block(pbd, block_num);\n\t\t__v3_flush_block(pbd);\n\n\t\tblock_num = (block_num + 1) % ring->rd_num;\n\t}\n\n\tpair_udp_close(udp_sock);\n\n\tif (total_packets != 2 * NUM_PACKETS) {\n\t\tfprintf(stderr, \"walk_v3_rx: received %u out of %u pkts\\n\",\n\t\t\ttotal_packets, NUM_PACKETS);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \" %u pkts (%u bytes)\", NUM_PACKETS, total_bytes >> 1);\n}\n\nstatic void walk_v3(int sock, struct ring *ring)\n{\n\tif (ring->type == PACKET_RX_RING)\n\t\twalk_v3_rx(sock, ring);\n\telse\n\t\twalk_tx(sock, ring);\n}\n\nstatic void __v1_v2_fill(struct ring *ring, unsigned int blocks)\n{\n\tring->req.tp_block_size = getpagesize() << 2;\n\tring->req.tp_frame_size = TPACKET_ALIGNMENT << 7;\n\tring->req.tp_block_nr = blocks;\n\n\tring->req.tp_frame_nr = ring->req.tp_block_size /\n\t\t\t\tring->req.tp_frame_size *\n\t\t\t\tring->req.tp_block_nr;\n\n\tring->mm_len = ring->req.tp_block_size * ring->req.tp_block_nr;\n\tring->walk = walk_v1_v2;\n\tring->rd_num = ring->req.tp_frame_nr;\n\tring->flen = ring->req.tp_frame_size;\n}\n\nstatic void __v3_fill(struct ring *ring, unsigned int blocks, int type)\n{\n\tif (type == PACKET_RX_RING) {\n\t\tring->req3.tp_retire_blk_tov = 64;\n\t\tring->req3.tp_sizeof_priv = 0;\n\t\tring->req3.tp_feature_req_word = TP_FT_REQ_FILL_RXHASH;\n\t}\n\tring->req3.tp_block_size = getpagesize() << 2;\n\tring->req3.tp_frame_size = TPACKET_ALIGNMENT << 7;\n\tring->req3.tp_block_nr = blocks;\n\n\tring->req3.tp_frame_nr = ring->req3.tp_block_size /\n\t\t\t\t ring->req3.tp_frame_size *\n\t\t\t\t ring->req3.tp_block_nr;\n\n\tring->mm_len = ring->req3.tp_block_size * ring->req3.tp_block_nr;\n\tring->walk = walk_v3;\n\tring->rd_num = ring->req3.tp_block_nr;\n\tring->flen = ring->req3.tp_block_size;\n}\n\nstatic void setup_ring(int sock, struct ring *ring, int version, int type)\n{\n\tint ret = 0;\n\tunsigned int blocks = 256;\n\n\tring->type = type;\n\tring->version = version;\n\n\tswitch (version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\tif (type == PACKET_TX_RING)\n\t\t\t__v1_v2_set_packet_loss_discard(sock);\n\t\t__v1_v2_fill(ring, blocks);\n\t\tret = setsockopt(sock, SOL_PACKET, type, &ring->req,\n\t\t\t\t sizeof(ring->req));\n\t\tbreak;\n\n\tcase TPACKET_V3:\n\t\t__v3_fill(ring, blocks, type);\n\t\tret = setsockopt(sock, SOL_PACKET, type, &ring->req3,\n\t\t\t\t sizeof(ring->req3));\n\t\tbreak;\n\t}\n\n\tif (ret == -1) {\n\t\tperror(\"setsockopt\");\n\t\texit(1);\n\t}\n\n\tring->rd_len = ring->rd_num * sizeof(*ring->rd);\n\tring->rd = malloc(ring->rd_len);\n\tif (ring->rd == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(1);\n\t}\n\n\ttotal_packets = 0;\n\ttotal_bytes = 0;\n}\n\nstatic void mmap_ring(int sock, struct ring *ring)\n{\n\tint i;\n\n\tring->mm_space = mmap(0, ring->mm_len, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_LOCKED | MAP_POPULATE, sock, 0);\n\tif (ring->mm_space == MAP_FAILED) {\n\t\tperror(\"mmap\");\n\t\texit(1);\n\t}\n\n\tmemset(ring->rd, 0, ring->rd_len);\n\tfor (i = 0; i < ring->rd_num; ++i) {\n\t\tring->rd[i].iov_base = ring->mm_space + (i * ring->flen);\n\t\tring->rd[i].iov_len = ring->flen;\n\t}\n}\n\nstatic void bind_ring(int sock, struct ring *ring)\n{\n\tint ret;\n\n\tpair_udp_setfilter(sock);\n\n\tring->ll.sll_family = PF_PACKET;\n\tring->ll.sll_protocol = htons(ETH_P_ALL);\n\tring->ll.sll_ifindex = if_nametoindex(\"lo\");\n\tring->ll.sll_hatype = 0;\n\tring->ll.sll_pkttype = 0;\n\tring->ll.sll_halen = 0;\n\n\tret = bind(sock, (struct sockaddr *) &ring->ll, sizeof(ring->ll));\n\tif (ret == -1) {\n\t\tperror(\"bind\");\n\t\texit(1);\n\t}\n}\n\nstatic void walk_ring(int sock, struct ring *ring)\n{\n\tring->walk(sock, ring);\n}\n\nstatic void unmap_ring(int sock, struct ring *ring)\n{\n\tmunmap(ring->mm_space, ring->mm_len);\n\tfree(ring->rd);\n}\n\nstatic int test_kernel_bit_width(void)\n{\n\tchar in[512], *ptr;\n\tint num = 0, fd;\n\tssize_t ret;\n\n\tfd = open(\"/proc/kallsyms\", O_RDONLY);\n\tif (fd == -1) {\n\t\tperror(\"open\");\n\t\texit(1);\n\t}\n\n\tret = read(fd, in, sizeof(in));\n\tif (ret <= 0) {\n\t\tperror(\"read\");\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tptr = in;\n\twhile(!isspace(*ptr)) {\n\t\tnum++;\n\t\tptr++;\n\t}\n\n\treturn num * 4;\n}\n\nstatic int test_user_bit_width(void)\n{\n\treturn __WORDSIZE;\n}\n\nstatic const char *tpacket_str[] = {\n\t[TPACKET_V1] = \"TPACKET_V1\",\n\t[TPACKET_V2] = \"TPACKET_V2\",\n\t[TPACKET_V3] = \"TPACKET_V3\",\n};\n\nstatic const char *type_str[] = {\n\t[PACKET_RX_RING] = \"PACKET_RX_RING\",\n\t[PACKET_TX_RING] = \"PACKET_TX_RING\",\n};\n\nstatic int test_tpacket(int version, int type)\n{\n\tint sock;\n\tstruct ring ring;\n\n\tfprintf(stderr, \"test: %s with %s \", tpacket_str[version],\n\t\ttype_str[type]);\n\tfflush(stderr);\n\n\tif (version == TPACKET_V1 &&\n\t    test_kernel_bit_width() != test_user_bit_width()) {\n\t\tfprintf(stderr, \"test: skip %s %s since user and kernel \"\n\t\t\t\"space have different bit width\\n\",\n\t\t\ttpacket_str[version], type_str[type]);\n\t\treturn KSFT_SKIP;\n\t}\n\n\tsock = pfsocket(version);\n\tmemset(&ring, 0, sizeof(ring));\n\tsetup_ring(sock, &ring, version, type);\n\tmmap_ring(sock, &ring);\n\tbind_ring(sock, &ring);\n\twalk_ring(sock, &ring);\n\tunmap_ring(sock, &ring);\n\tclose(sock);\n\n\tfprintf(stderr, \"\\n\");\n\treturn 0;\n}\n\nint main(void)\n{\n\tint ret = 0;\n\n\tret |= test_tpacket(TPACKET_V1, PACKET_RX_RING);\n\tret |= test_tpacket(TPACKET_V1, PACKET_TX_RING);\n\n\tret |= test_tpacket(TPACKET_V2, PACKET_RX_RING);\n\tret |= test_tpacket(TPACKET_V2, PACKET_TX_RING);\n\n\tret |= test_tpacket(TPACKET_V3, PACKET_RX_RING);\n\tret |= test_tpacket(TPACKET_V3, PACKET_TX_RING);\n\n\tif (ret)\n\t\treturn 1;\n\n\tprintf(\"OK. All tests passed\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}