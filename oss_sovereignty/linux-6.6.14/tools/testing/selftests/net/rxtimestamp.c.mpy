{
  "module_name": "rxtimestamp.c",
  "hash_id": "c8eabe3ccfdf0ade43ee9df455770b8852e92d9931e63757d9fb6bb48a024a99",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/rxtimestamp.c",
  "human_readable_source": "#include <errno.h>\n#include <error.h>\n#include <getopt.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n\n#include <asm/types.h>\n#include <linux/net_tstamp.h>\n#include <linux/errqueue.h>\n\n#include \"../kselftest.h\"\n\nstruct options {\n\tint so_timestamp;\n\tint so_timestampns;\n\tint so_timestamping;\n};\n\nstruct tstamps {\n\tbool tstamp;\n\tbool tstampns;\n\tbool swtstamp;\n\tbool hwtstamp;\n};\n\nstruct socket_type {\n\tchar *friendly_name;\n\tint type;\n\tint protocol;\n\tbool enabled;\n};\n\nstruct test_case {\n\tstruct options sockopt;\n\tstruct tstamps expected;\n\tbool enabled;\n\tbool warn_on_fail;\n};\n\nstruct sof_flag {\n\tint mask;\n\tchar *name;\n};\n\nstatic struct sof_flag sof_flags[] = {\n#define SOF_FLAG(f) { f, #f }\n\tSOF_FLAG(SOF_TIMESTAMPING_SOFTWARE),\n\tSOF_FLAG(SOF_TIMESTAMPING_RX_SOFTWARE),\n\tSOF_FLAG(SOF_TIMESTAMPING_RX_HARDWARE),\n};\n\nstatic struct socket_type socket_types[] = {\n\t{ \"ip\",\t\tSOCK_RAW,\tIPPROTO_EGP },\n\t{ \"udp\",\tSOCK_DGRAM,\tIPPROTO_UDP },\n\t{ \"tcp\",\tSOCK_STREAM,\tIPPROTO_TCP },\n};\n\nstatic struct test_case test_cases[] = {\n\t{ {}, {} },\n\t{\n\t\t{ .so_timestamp = 1 },\n\t\t{ .tstamp = true }\n\t},\n\t{\n\t\t{ .so_timestampns = 1 },\n\t\t{ .tstampns = true }\n\t},\n\t{\n\t\t{ .so_timestamp = 1, .so_timestampns = 1 },\n\t\t{ .tstampns = true }\n\t},\n\t{\n\t\t{ .so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE },\n\t\t{}\n\t},\n\t{\n\t\t \n\t\t{ .so_timestamping = SOF_TIMESTAMPING_RX_HARDWARE },\n\t\t{}\n\t},\n\t{\n\t\t{ .so_timestamping = SOF_TIMESTAMPING_SOFTWARE },\n\t\t.warn_on_fail = true\n\t},\n\t{\n\t\t{ .so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE\n\t\t\t| SOF_TIMESTAMPING_RX_HARDWARE },\n\t\t{}\n\t},\n\t{\n\t\t{ .so_timestamping = SOF_TIMESTAMPING_SOFTWARE\n\t\t\t| SOF_TIMESTAMPING_RX_SOFTWARE },\n\t\t{ .swtstamp = true }\n\t},\n\t{\n\t\t{ .so_timestamp = 1, .so_timestamping = SOF_TIMESTAMPING_SOFTWARE\n\t\t\t| SOF_TIMESTAMPING_RX_SOFTWARE },\n\t\t{ .tstamp = true, .swtstamp = true }\n\t},\n};\n\nstatic struct option long_options[] = {\n\t{ \"list_tests\", no_argument, 0, 'l' },\n\t{ \"test_num\", required_argument, 0, 'n' },\n\t{ \"op_size\", required_argument, 0, 's' },\n\t{ \"tcp\", no_argument, 0, 't' },\n\t{ \"udp\", no_argument, 0, 'u' },\n\t{ \"ip\", no_argument, 0, 'i' },\n\t{ \"strict\", no_argument, 0, 'S' },\n\t{ \"ipv4\", no_argument, 0, '4' },\n\t{ \"ipv6\", no_argument, 0, '6' },\n\t{ NULL, 0, NULL, 0 },\n};\n\nstatic int next_port = 19999;\nstatic int op_size = 10 * 1024;\n\nvoid print_test_case(struct test_case *t)\n{\n\tint f = 0;\n\n\tprintf(\"sockopts {\");\n\tif (t->sockopt.so_timestamp)\n\t\tprintf(\" SO_TIMESTAMP \");\n\tif (t->sockopt.so_timestampns)\n\t\tprintf(\" SO_TIMESTAMPNS \");\n\tif (t->sockopt.so_timestamping) {\n\t\tprintf(\" SO_TIMESTAMPING: {\");\n\t\tfor (f = 0; f < ARRAY_SIZE(sof_flags); f++)\n\t\t\tif (t->sockopt.so_timestamping & sof_flags[f].mask)\n\t\t\t\tprintf(\" %s |\", sof_flags[f].name);\n\t\tprintf(\"}\");\n\t}\n\tprintf(\"} expected cmsgs: {\");\n\tif (t->expected.tstamp)\n\t\tprintf(\" SCM_TIMESTAMP \");\n\tif (t->expected.tstampns)\n\t\tprintf(\" SCM_TIMESTAMPNS \");\n\tif (t->expected.swtstamp || t->expected.hwtstamp) {\n\t\tprintf(\" SCM_TIMESTAMPING {\");\n\t\tif (t->expected.swtstamp)\n\t\t\tprintf(\"0\");\n\t\tif (t->expected.swtstamp && t->expected.hwtstamp)\n\t\t\tprintf(\",\");\n\t\tif (t->expected.hwtstamp)\n\t\t\tprintf(\"2\");\n\t\tprintf(\"}\");\n\t}\n\tprintf(\"}\\n\");\n}\n\nvoid do_send(int src)\n{\n\tint r;\n\tchar *buf = malloc(op_size);\n\n\tmemset(buf, 'z', op_size);\n\tr = write(src, buf, op_size);\n\tif (r < 0)\n\t\terror(1, errno, \"Failed to sendmsg\");\n\n\tfree(buf);\n}\n\nbool do_recv(int rcv, int read_size, struct tstamps expected)\n{\n\tconst int CMSG_SIZE = 1024;\n\n\tstruct scm_timestamping *ts;\n\tstruct tstamps actual = {};\n\tchar cmsg_buf[CMSG_SIZE];\n\tstruct iovec recv_iov;\n\tstruct cmsghdr *cmsg;\n\tbool failed = false;\n\tstruct msghdr hdr;\n\tint flags = 0;\n\tint r;\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.msg_iov = &recv_iov;\n\thdr.msg_iovlen = 1;\n\trecv_iov.iov_base = malloc(read_size);\n\trecv_iov.iov_len = read_size;\n\n\thdr.msg_control = cmsg_buf;\n\thdr.msg_controllen = sizeof(cmsg_buf);\n\n\tr = recvmsg(rcv, &hdr, flags);\n\tif (r < 0)\n\t\terror(1, errno, \"Failed to recvmsg\");\n\tif (r != read_size)\n\t\terror(1, 0, \"Only received %d bytes of payload.\", r);\n\n\tif (hdr.msg_flags & (MSG_TRUNC | MSG_CTRUNC))\n\t\terror(1, 0, \"Message was truncated.\");\n\n\tfor (cmsg = CMSG_FIRSTHDR(&hdr); cmsg != NULL;\n\t     cmsg = CMSG_NXTHDR(&hdr, cmsg)) {\n\t\tif (cmsg->cmsg_level != SOL_SOCKET)\n\t\t\terror(1, 0, \"Unexpected cmsg_level %d\",\n\t\t\t      cmsg->cmsg_level);\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase SCM_TIMESTAMP:\n\t\t\tactual.tstamp = true;\n\t\t\tbreak;\n\t\tcase SCM_TIMESTAMPNS:\n\t\t\tactual.tstampns = true;\n\t\t\tbreak;\n\t\tcase SCM_TIMESTAMPING:\n\t\t\tts = (struct scm_timestamping *)CMSG_DATA(cmsg);\n\t\t\tactual.swtstamp = !!ts->ts[0].tv_sec;\n\t\t\tif (ts->ts[1].tv_sec != 0)\n\t\t\t\terror(0, 0, \"ts[1] should not be set.\");\n\t\t\tactual.hwtstamp = !!ts->ts[2].tv_sec;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"Unexpected cmsg_type %d\", cmsg->cmsg_type);\n\t\t}\n\t}\n\n#define VALIDATE(field) \\\n\tdo { \\\n\t\tif (expected.field != actual.field) { \\\n\t\t\tif (expected.field) \\\n\t\t\t\terror(0, 0, \"Expected \" #field \" to be set.\"); \\\n\t\t\telse \\\n\t\t\t\terror(0, 0, \\\n\t\t\t\t      \"Expected \" #field \" to not be set.\"); \\\n\t\t\tfailed = true; \\\n\t\t} \\\n\t} while (0)\n\n\tVALIDATE(tstamp);\n\tVALIDATE(tstampns);\n\tVALIDATE(swtstamp);\n\tVALIDATE(hwtstamp);\n#undef VALIDATE\n\n\tfree(recv_iov.iov_base);\n\n\treturn failed;\n}\n\nvoid config_so_flags(int rcv, struct options o)\n{\n\tint on = 1;\n\n\tif (setsockopt(rcv, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)\n\t\terror(1, errno, \"Failed to enable SO_REUSEADDR\");\n\n\tif (o.so_timestamp &&\n\t    setsockopt(rcv, SOL_SOCKET, SO_TIMESTAMP,\n\t\t       &o.so_timestamp, sizeof(o.so_timestamp)) < 0)\n\t\terror(1, errno, \"Failed to enable SO_TIMESTAMP\");\n\n\tif (o.so_timestampns &&\n\t    setsockopt(rcv, SOL_SOCKET, SO_TIMESTAMPNS,\n\t\t       &o.so_timestampns, sizeof(o.so_timestampns)) < 0)\n\t\terror(1, errno, \"Failed to enable SO_TIMESTAMPNS\");\n\n\tif (o.so_timestamping &&\n\t    setsockopt(rcv, SOL_SOCKET, SO_TIMESTAMPING,\n\t\t       &o.so_timestamping, sizeof(o.so_timestamping)) < 0)\n\t\terror(1, errno, \"Failed to set SO_TIMESTAMPING\");\n}\n\nbool run_test_case(struct socket_type *s, int test_num, char ip_version,\n\t\t   bool strict)\n{\n\tunion {\n\t\tstruct sockaddr_in6 addr6;\n\t\tstruct sockaddr_in addr4;\n\t\tstruct sockaddr addr_un;\n\t} addr;\n\tint read_size = op_size;\n\tint src, dst, rcv, port;\n\tsocklen_t addr_size;\n\tbool failed = false;\n\n\tport = (s->type == SOCK_RAW) ? 0 : next_port++;\n\tmemset(&addr, 0, sizeof(addr));\n\tif (ip_version == '4') {\n\t\taddr.addr4.sin_family = AF_INET;\n\t\taddr.addr4.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\taddr.addr4.sin_port = htons(port);\n\t\taddr_size = sizeof(addr.addr4);\n\t\tif (s->type == SOCK_RAW)\n\t\t\tread_size += 20;   \n\t} else {\n\t\taddr.addr6.sin6_family = AF_INET6;\n\t\taddr.addr6.sin6_addr = in6addr_loopback;\n\t\taddr.addr6.sin6_port = htons(port);\n\t\taddr_size = sizeof(addr.addr6);\n\t}\n\tprintf(\"Starting testcase %d over ipv%c...\\n\", test_num, ip_version);\n\tsrc = socket(addr.addr_un.sa_family, s->type,\n\t\t     s->protocol);\n\tif (src < 0)\n\t\terror(1, errno, \"Failed to open src socket\");\n\n\tdst = socket(addr.addr_un.sa_family, s->type,\n\t\t     s->protocol);\n\tif (dst < 0)\n\t\terror(1, errno, \"Failed to open dst socket\");\n\n\tif (bind(dst, &addr.addr_un, addr_size) < 0)\n\t\terror(1, errno, \"Failed to bind to port %d\", port);\n\n\tif (s->type == SOCK_STREAM && (listen(dst, 1) < 0))\n\t\terror(1, errno, \"Failed to listen\");\n\n\tif (connect(src, &addr.addr_un, addr_size) < 0)\n\t\terror(1, errno, \"Failed to connect\");\n\n\tif (s->type == SOCK_STREAM) {\n\t\trcv = accept(dst, NULL, NULL);\n\t\tif (rcv < 0)\n\t\t\terror(1, errno, \"Failed to accept\");\n\t\tclose(dst);\n\t} else {\n\t\trcv = dst;\n\t}\n\n\tconfig_so_flags(rcv, test_cases[test_num].sockopt);\n\tusleep(20000);  \n\tdo_send(src);\n\n\tfailed = do_recv(rcv, read_size, test_cases[test_num].expected);\n\n\tclose(rcv);\n\tclose(src);\n\n\tif (failed) {\n\t\tprintf(\"FAILURE in testcase %d over ipv%c \", test_num,\n\t\t       ip_version);\n\t\tprint_test_case(&test_cases[test_num]);\n\t\tif (!strict && test_cases[test_num].warn_on_fail)\n\t\t\tfailed = false;\n\t}\n\treturn failed;\n}\n\nint main(int argc, char **argv)\n{\n\tbool all_protocols = true;\n\tbool all_tests = true;\n\tbool cfg_ipv4 = false;\n\tbool cfg_ipv6 = false;\n\tbool strict = false;\n\tint arg_index = 0;\n\tint failures = 0;\n\tint s, t, opt;\n\n\twhile ((opt = getopt_long(argc, argv, \"\", long_options,\n\t\t\t\t  &arg_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'l':\n\t\t\tfor (t = 0; t < ARRAY_SIZE(test_cases); t++) {\n\t\t\t\tprintf(\"%d\\t\", t);\n\t\t\t\tprint_test_case(&test_cases[t]);\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 'n':\n\t\t\tt = atoi(optarg);\n\t\t\tif (t >= ARRAY_SIZE(test_cases))\n\t\t\t\terror(1, 0, \"Invalid test case: %d\", t);\n\t\t\tall_tests = false;\n\t\t\ttest_cases[t].enabled = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\top_size = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tall_protocols = false;\n\t\t\tsocket_types[2].enabled = true;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tall_protocols = false;\n\t\t\tsocket_types[1].enabled = true;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tall_protocols = false;\n\t\t\tsocket_types[0].enabled = true;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tstrict = true;\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\tcfg_ipv4 = true;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tcfg_ipv6 = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"Failed to parse parameters.\");\n\t\t}\n\t}\n\n\tfor (s = 0; s < ARRAY_SIZE(socket_types); s++) {\n\t\tif (!all_protocols && !socket_types[s].enabled)\n\t\t\tcontinue;\n\n\t\tprintf(\"Testing %s...\\n\", socket_types[s].friendly_name);\n\t\tfor (t = 0; t < ARRAY_SIZE(test_cases); t++) {\n\t\t\tif (!all_tests && !test_cases[t].enabled)\n\t\t\t\tcontinue;\n\t\t\tif (cfg_ipv4 || !cfg_ipv6)\n\t\t\t\tif (run_test_case(&socket_types[s], t, '4',\n\t\t\t\t\t\t  strict))\n\t\t\t\t\tfailures++;\n\t\t\tif (cfg_ipv6 || !cfg_ipv4)\n\t\t\t\tif (run_test_case(&socket_types[s], t, '6',\n\t\t\t\t\t\t  strict))\n\t\t\t\t\tfailures++;\n\t\t}\n\t}\n\tif (!failures)\n\t\tprintf(\"PASSED.\\n\");\n\treturn failures;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}