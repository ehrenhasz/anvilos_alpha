{
  "module_name": "devlink_port_split.py",
  "hash_id": "1156de7fdf317cc73fe0608662d3e92e121ea4eb2b0fb1ebc614ee104252b715",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/devlink_port_split.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n\nfrom subprocess import PIPE, Popen\nimport json\nimport time\nimport argparse\nimport collections\nimport sys\n\n#\n# Test port split configuration using devlink-port lanes attribute.\n# The test is skipped in case the attribute is not available.\n#\n# First, check that all the ports with 1 lane fail to split.\n# Second, check that all the ports with more than 1 lane can be split\n# to all valid configurations (e.g., split to 2, split to 4 etc.)\n#\n\n\n# Kselftest framework requirement - SKIP code is 4\nKSFT_SKIP=4\nPort = collections.namedtuple('Port', 'bus_info name')\n\n\ndef run_command(cmd, should_fail=False):\n    \"\"\"\n    Run a command in subprocess.\n    Return: Tuple of (stdout, stderr).\n    \"\"\"\n\n    p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n    stdout, stderr = p.communicate()\n    stdout, stderr = stdout.decode(), stderr.decode()\n\n    if stderr != \"\" and not should_fail:\n        print(\"Error sending command: %s\" % cmd)\n        print(stdout)\n        print(stderr)\n    return stdout, stderr\n\n\nclass devlink_ports(object):\n    \"\"\"\n    Class that holds information on the devlink ports, required to the tests;\n    if_names: A list of interfaces in the devlink ports.\n    \"\"\"\n\n    def get_if_names(dev):\n        \"\"\"\n        Get a list of physical devlink ports.\n        Return: Array of tuples (bus_info/port, if_name).\n        \"\"\"\n\n        arr = []\n\n        cmd = \"devlink -j port show\"\n        stdout, stderr = run_command(cmd)\n        assert stderr == \"\"\n        ports = json.loads(stdout)['port']\n\n        validate_devlink_output(ports, 'flavour')\n\n        for port in ports:\n            if dev in port:\n                if ports[port]['flavour'] == 'physical':\n                    arr.append(Port(bus_info=port, name=ports[port]['netdev']))\n\n        return arr\n\n    def __init__(self, dev):\n        self.if_names = devlink_ports.get_if_names(dev)\n\n\ndef get_max_lanes(port):\n    \"\"\"\n    Get the $port's maximum number of lanes.\n    Return: number of lanes, e.g. 1, 2, 4 and 8.\n    \"\"\"\n\n    cmd = \"devlink -j port show %s\" % port\n    stdout, stderr = run_command(cmd)\n    assert stderr == \"\"\n    values = list(json.loads(stdout)['port'].values())[0]\n\n    if 'lanes' in values:\n        lanes = values['lanes']\n    else:\n        lanes = 0\n    return lanes\n\n\ndef get_split_ability(port):\n    \"\"\"\n    Get the $port split ability.\n    Return: split ability, true or false.\n    \"\"\"\n\n    cmd = \"devlink -j port show %s\" % port.name\n    stdout, stderr = run_command(cmd)\n    assert stderr == \"\"\n    values = list(json.loads(stdout)['port'].values())[0]\n\n    return values['splittable']\n\n\ndef split(k, port, should_fail=False):\n    \"\"\"\n    Split $port into $k ports.\n    If should_fail == True, the split should fail. Otherwise, should pass.\n    Return: Array of sub ports after splitting.\n            If the $port wasn't split, the array will be empty.\n    \"\"\"\n\n    cmd = \"devlink port split %s count %s\" % (port.bus_info, k)\n    stdout, stderr = run_command(cmd, should_fail=should_fail)\n\n    if should_fail:\n        if not test(stderr != \"\", \"%s is unsplittable\" % port.name):\n            print(\"split an unsplittable port %s\" % port.name)\n            return create_split_group(port, k)\n    else:\n        if stderr == \"\":\n            return create_split_group(port, k)\n        print(\"didn't split a splittable port %s\" % port.name)\n\n    return []\n\n\ndef unsplit(port):\n    \"\"\"\n    Unsplit $port.\n    \"\"\"\n\n    cmd = \"devlink port unsplit %s\" % port\n    stdout, stderr = run_command(cmd)\n    test(stderr == \"\", \"Unsplit port %s\" % port)\n\n\ndef exists(port, dev):\n    \"\"\"\n    Check if $port exists in the devlink ports.\n    Return: True is so, False otherwise.\n    \"\"\"\n\n    return any(dev_port.name == port\n               for dev_port in devlink_ports.get_if_names(dev))\n\n\ndef exists_and_lanes(ports, lanes, dev):\n    \"\"\"\n    Check if every port in the list $ports exists in the devlink ports and has\n    $lanes number of lanes after splitting.\n    Return: True if both are True, False otherwise.\n    \"\"\"\n\n    for port in ports:\n        max_lanes = get_max_lanes(port)\n        if not exists(port, dev):\n            print(\"port %s doesn't exist in devlink ports\" % port)\n            return False\n        if max_lanes != lanes:\n            print(\"port %s has %d lanes, but %s were expected\"\n                  % (port, lanes, max_lanes))\n            return False\n    return True\n\n\ndef test(cond, msg):\n    \"\"\"\n    Check $cond and print a message accordingly.\n    Return: True is pass, False otherwise.\n    \"\"\"\n\n    if cond:\n        print(\"TEST: %-60s [ OK ]\" % msg)\n    else:\n        print(\"TEST: %-60s [FAIL]\" % msg)\n\n    return cond\n\n\ndef create_split_group(port, k):\n    \"\"\"\n    Create the split group for $port.\n    Return: Array with $k elements, which are the split port group.\n    \"\"\"\n\n    return list(port.name + \"s\" + str(i) for i in range(k))\n\n\ndef split_unsplittable_port(port, k):\n    \"\"\"\n    Test that splitting of unsplittable port fails.\n    \"\"\"\n\n    # split to max\n    new_split_group = split(k, port, should_fail=True)\n\n    if new_split_group != []:\n        unsplit(port.bus_info)\n\n\ndef split_splittable_port(port, k, lanes, dev):\n    \"\"\"\n    Test that splitting of splittable port passes correctly.\n    \"\"\"\n\n    new_split_group = split(k, port)\n\n    # Once the split command ends, it takes some time to the sub ifaces'\n    # to get their names. Use udevadm to continue only when all current udev\n    # events are handled.\n    cmd = \"udevadm settle\"\n    stdout, stderr = run_command(cmd)\n    assert stderr == \"\"\n\n    if new_split_group != []:\n        test(exists_and_lanes(new_split_group, lanes/k, dev),\n             \"split port %s into %s\" % (port.name, k))\n\n    unsplit(port.bus_info)\n\n\ndef validate_devlink_output(devlink_data, target_property=None):\n    \"\"\"\n    Determine if test should be skipped by checking:\n      1. devlink_data contains values\n      2. The target_property exist in devlink_data\n    \"\"\"\n    skip_reason = None\n    if any(devlink_data.values()):\n        if target_property:\n            skip_reason = \"{} not found in devlink output, test skipped\".format(target_property)\n            for key in devlink_data:\n                if target_property in devlink_data[key]:\n                    skip_reason = None\n    else:\n        skip_reason = 'devlink output is empty, test skipped'\n\n    if skip_reason:\n        print(skip_reason)\n        sys.exit(KSFT_SKIP)\n\n\ndef make_parser():\n    parser = argparse.ArgumentParser(description='A test for port splitting.')\n    parser.add_argument('--dev',\n                        help='The devlink handle of the device under test. ' +\n                             'The default is the first registered devlink ' +\n                             'handle.')\n\n    return parser\n\n\ndef main(cmdline=None):\n    parser = make_parser()\n    args = parser.parse_args(cmdline)\n\n    dev = args.dev\n    if not dev:\n        cmd = \"devlink -j dev show\"\n        stdout, stderr = run_command(cmd)\n        assert stderr == \"\"\n\n        validate_devlink_output(json.loads(stdout))\n        devs = json.loads(stdout)['dev']\n        dev = list(devs.keys())[0]\n\n    cmd = \"devlink dev show %s\" % dev\n    stdout, stderr = run_command(cmd)\n    if stderr != \"\":\n        print(\"devlink device %s can not be found\" % dev)\n        sys.exit(1)\n\n    ports = devlink_ports(dev)\n\n    found_max_lanes = False\n    for port in ports.if_names:\n        max_lanes = get_max_lanes(port.name)\n\n        # If max lanes is 0, do not test port splitting at all\n        if max_lanes == 0:\n            continue\n\n        # If 1 lane, shouldn't be able to split\n        elif max_lanes == 1:\n            test(not get_split_ability(port),\n                 \"%s should not be able to split\" % port.name)\n            split_unsplittable_port(port, max_lanes)\n\n        # Else, splitting should pass and all the split ports should exist.\n        else:\n            lane = max_lanes\n            test(get_split_ability(port),\n                 \"%s should be able to split\" % port.name)\n            while lane > 1:\n                split_splittable_port(port, lane, max_lanes, dev)\n\n                lane //= 2\n        found_max_lanes = True\n\n    if not found_max_lanes:\n        print(f\"Test not started, no port of device {dev} reports max_lanes\")\n        sys.exit(KSFT_SKIP)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}