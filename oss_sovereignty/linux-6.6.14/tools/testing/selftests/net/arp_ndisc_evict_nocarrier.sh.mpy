{
  "module_name": "arp_ndisc_evict_nocarrier.sh",
  "hash_id": "099ac430ca483a74f83c169b901eade207513d253461a274dee6332d6eca6426",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/arp_ndisc_evict_nocarrier.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Tests sysctl options {arp,ndisc}_evict_nocarrier={0,1}\n#\n# Create a veth pair and set IPs/routes on both. Then ping to establish\n# an entry in the ARP/ND table. Depending on the test set sysctl option to\n# 1 or 0. Set remote veth down which will cause local veth to go into a no\n# carrier state. Depending on the test check the ARP/ND table:\n#\n# {arp,ndisc}_evict_nocarrier=1 should contain no ARP/ND after no carrier\n# {arp,ndisc}_evict_nocarrer=0 should still contain the single ARP/ND entry\n#\n\nreadonly PEER_NS=\"ns-peer-$(mktemp -u XXXXXX)\"\nreadonly V4_ADDR0=10.0.10.1\nreadonly V4_ADDR1=10.0.10.2\nreadonly V6_ADDR0=2001:db8:91::1\nreadonly V6_ADDR1=2001:db8:91::2\nnsid=100\nret=0\n\ncleanup_v6()\n{\n    ip netns del me\n    ip netns del peer\n\n    sysctl -w net.ipv6.conf.veth1.ndisc_evict_nocarrier=1 >/dev/null 2>&1\n    sysctl -w net.ipv6.conf.all.ndisc_evict_nocarrier=1 >/dev/null 2>&1\n}\n\ncreate_ns()\n{\n    local n=${1}\n\n    ip netns del ${n} 2>/dev/null\n\n    ip netns add ${n}\n    ip netns set ${n} $((nsid++))\n    ip -netns ${n} link set lo up\n}\n\n\nsetup_v6() {\n    create_ns me\n    create_ns peer\n\n    IP=\"ip -netns me\"\n\n    $IP li add veth1 type veth peer name veth2\n    $IP li set veth1 up\n    $IP -6 addr add $V6_ADDR0/64 dev veth1 nodad\n    $IP li set veth2 netns peer up\n    ip -netns peer -6 addr add $V6_ADDR1/64 dev veth2 nodad\n\n    ip netns exec me sysctl -w $1 >/dev/null 2>&1\n\n    # Establish an ND cache entry\n    ip netns exec me ping -6 -c1 -Iveth1 $V6_ADDR1 >/dev/null 2>&1\n    # Should have the veth1 entry in ND table\n    ip netns exec me ip -6 neigh get $V6_ADDR1 dev veth1 >/dev/null 2>&1\n    if [ $? -ne 0 ]; then\n        cleanup_v6\n        echo \"failed\"\n        exit 1\n    fi\n\n    # Set veth2 down, which will put veth1 in NOCARRIER state\n    ip netns exec peer ip link set veth2 down\n}\n\nsetup_v4() {\n    ip netns add \"${PEER_NS}\"\n    ip link add name veth0 type veth peer name veth1\n    ip link set dev veth0 up\n    ip link set dev veth1 netns \"${PEER_NS}\"\n    ip netns exec \"${PEER_NS}\" ip link set dev veth1 up\n    ip addr add $V4_ADDR0/24 dev veth0\n    ip netns exec \"${PEER_NS}\" ip addr add $V4_ADDR1/24 dev veth1\n    ip netns exec ${PEER_NS} ip route add default via $V4_ADDR1 dev veth1\n    ip route add default via $V4_ADDR0 dev veth0\n\n    sysctl -w \"$1\" >/dev/null 2>&1\n\n    # Establish an ARP cache entry\n    ping -c1 -I veth0 $V4_ADDR1 -q >/dev/null 2>&1\n    # Should have the veth1 entry in ARP table\n    ip neigh get $V4_ADDR1 dev veth0 >/dev/null 2>&1\n    if [ $? -ne 0 ]; then\n        cleanup_v4\n        echo \"failed\"\n        exit 1\n    fi\n\n    # Set veth1 down, which will put veth0 in NOCARRIER state\n    ip netns exec \"${PEER_NS}\" ip link set veth1 down\n}\n\ncleanup_v4() {\n    ip neigh flush dev veth0\n    ip link del veth0\n    local -r ns=\"$(ip netns list|grep $PEER_NS)\"\n    [ -n \"$ns\" ] && ip netns del $ns 2>/dev/null\n\n    sysctl -w net.ipv4.conf.veth0.arp_evict_nocarrier=1 >/dev/null 2>&1\n    sysctl -w net.ipv4.conf.all.arp_evict_nocarrier=1 >/dev/null 2>&1\n}\n\n# Run test when arp_evict_nocarrier = 1 (default).\nrun_arp_evict_nocarrier_enabled() {\n    echo \"run arp_evict_nocarrier=1 test\"\n    setup_v4 \"net.ipv4.conf.veth0.arp_evict_nocarrier=1\"\n\n    # ARP table should be empty\n    ip neigh get $V4_ADDR1 dev veth0 >/dev/null 2>&1\n\n    if [ $? -eq 0 ];then\n        echo \"failed\"\n        ret=1\n    else\n        echo \"ok\"\n    fi\n\n    cleanup_v4\n}\n\n# Run test when arp_evict_nocarrier = 0\nrun_arp_evict_nocarrier_disabled() {\n    echo \"run arp_evict_nocarrier=0 test\"\n    setup_v4 \"net.ipv4.conf.veth0.arp_evict_nocarrier=0\"\n\n    # ARP table should still contain the entry\n    ip neigh get $V4_ADDR1 dev veth0 >/dev/null 2>&1\n\n    if [ $? -eq 0 ];then\n        echo \"ok\"\n    else\n        echo \"failed\"\n        ret=1\n    fi\n\n    cleanup_v4\n}\n\nrun_arp_evict_nocarrier_disabled_all() {\n    echo \"run all.arp_evict_nocarrier=0 test\"\n    setup_v4 \"net.ipv4.conf.all.arp_evict_nocarrier=0\"\n\n    # ARP table should still contain the entry\n    ip neigh get $V4_ADDR1 dev veth0 >/dev/null 2>&1\n\n    if [ $? -eq 0 ];then\n        echo \"ok\"\n    else\n        echo \"failed\"\n    fi\n\n    cleanup_v4\n}\n\nrun_ndisc_evict_nocarrier_enabled() {\n    echo \"run ndisc_evict_nocarrier=1 test\"\n\n    setup_v6 \"net.ipv6.conf.veth1.ndisc_evict_nocarrier=1\"\n\n    ip netns exec me ip -6 neigh get $V6_ADDR1 dev veth1 >/dev/null 2>&1\n\n    if [ $? -eq 0 ];then\n        echo \"failed\"\n        ret=1\n    else\n        echo \"ok\"\n    fi\n\n    cleanup_v6\n}\n\nrun_ndisc_evict_nocarrier_disabled() {\n    echo \"run ndisc_evict_nocarrier=0 test\"\n\n    setup_v6 \"net.ipv6.conf.veth1.ndisc_evict_nocarrier=0\"\n\n    ip netns exec me ip -6 neigh get $V6_ADDR1 dev veth1 >/dev/null 2>&1\n\n    if [ $? -eq 0 ];then\n        echo \"ok\"\n    else\n        echo \"failed\"\n        ret=1\n    fi\n\n    cleanup_v6\n}\n\nrun_ndisc_evict_nocarrier_disabled_all() {\n    echo \"run all.ndisc_evict_nocarrier=0 test\"\n\n    setup_v6 \"net.ipv6.conf.all.ndisc_evict_nocarrier=0\"\n\n    ip netns exec me ip -6 neigh get $V6_ADDR1 dev veth1 >/dev/null 2>&1\n\n    if [ $? -eq 0 ];then\n        echo \"ok\"\n    else\n        echo \"failed\"\n        ret=1\n    fi\n\n    cleanup_v6\n}\n\nrun_all_tests() {\n    run_arp_evict_nocarrier_enabled\n    run_arp_evict_nocarrier_disabled\n    run_arp_evict_nocarrier_disabled_all\n    run_ndisc_evict_nocarrier_enabled\n    run_ndisc_evict_nocarrier_disabled\n    run_ndisc_evict_nocarrier_disabled_all\n}\n\nif [ \"$(id -u)\" -ne 0 ];then\n\techo \"SKIP: Need root privileges\"\n\texit $ksft_skip;\nfi\n\nrun_all_tests\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}