{
  "module_name": "setup_loopback.sh",
  "hash_id": "7a8e08207e734d9c9b49c5ebd106fb6e21eece911854bcf80f2c99d947d9613a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/setup_loopback.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\nreadonly FLUSH_PATH=\"/sys/class/net/${dev}/gro_flush_timeout\"\nreadonly IRQ_PATH=\"/sys/class/net/${dev}/napi_defer_hard_irqs\"\nreadonly FLUSH_TIMEOUT=\"$(< ${FLUSH_PATH})\"\nreadonly HARD_IRQS=\"$(< ${IRQ_PATH})\"\n\nnetdev_check_for_carrier() {\n\tlocal -r dev=\"$1\"\n\n\tfor i in {1..5}; do\n\t\tcarrier=\"$(cat /sys/class/net/${dev}/carrier)\"\n\t\tif [[ \"${carrier}\" -ne 1 ]] ; then\n\t\t\techo \"carrier not ready yet...\" >&2\n\t\t\tsleep 1\n\t\telse\n\t\t\techo \"carrier ready\" >&2\n\t\t\tbreak\n\t\tfi\n\tdone\n\techo \"${carrier}\"\n}\n\n# Assumes that there is no existing ipvlan device on the physical device\nsetup_loopback_environment() {\n\tlocal dev=\"$1\"\n\n\t# Fail hard if cannot turn on loopback mode for current NIC\n\tethtool -K \"${dev}\" loopback on || exit 1\n\tsleep 1\n\n\t# Check for the carrier\n\tcarrier=$(netdev_check_for_carrier ${dev})\n\tif [[ \"${carrier}\" -ne 1 ]] ; then\n\t\techo \"setup_loopback_environment failed\"\n\t\texit 1\n\tfi\n}\n\nsetup_macvlan_ns(){\n\tlocal -r link_dev=\"$1\"\n\tlocal -r ns_name=\"$2\"\n\tlocal -r ns_dev=\"$3\"\n\tlocal -r ns_mac=\"$4\"\n\tlocal -r addr=\"$5\"\n\n\tip link add link \"${link_dev}\" dev \"${ns_dev}\" \\\n\t\taddress \"${ns_mac}\" type macvlan\n\texit_code=$?\n\tif [[ \"${exit_code}\" -ne 0 ]]; then\n\t\techo \"setup_macvlan_ns failed\"\n\t\texit $exit_code\n\tfi\n\n\t[[ -e /var/run/netns/\"${ns_name}\" ]] || ip netns add \"${ns_name}\"\n\tip link set dev \"${ns_dev}\" netns \"${ns_name}\"\n\tip -netns \"${ns_name}\" link set dev \"${ns_dev}\" up\n\tif [[ -n \"${addr}\" ]]; then\n\t\tip -netns \"${ns_name}\" addr add dev \"${ns_dev}\" \"${addr}\"\n\tfi\n\n\tsleep 1\n}\n\ncleanup_macvlan_ns(){\n\twhile (( $# >= 2 )); do\n\t\tns_name=\"$1\"\n\t\tns_dev=\"$2\"\n\t\tip -netns \"${ns_name}\" link del dev \"${ns_dev}\"\n\t\tip netns del \"${ns_name}\"\n\t\tshift 2\n\tdone\n}\n\ncleanup_loopback(){\n\tlocal -r dev=\"$1\"\n\n\tethtool -K \"${dev}\" loopback off\n\tsleep 1\n\n\t# Check for the carrier\n\tcarrier=$(netdev_check_for_carrier ${dev})\n\tif [[ \"${carrier}\" -ne 1 ]] ; then\n\t\techo \"setup_loopback_environment failed\"\n\t\texit 1\n\tfi\n}\n\nsetup_interrupt() {\n\t# Use timer on  host to trigger the network stack\n\t# Also disable device interrupt to not depend on NIC interrupt\n\t# Reduce test flakiness caused by unexpected interrupts\n\techo 100000 >\"${FLUSH_PATH}\"\n\techo 50 >\"${IRQ_PATH}\"\n}\n\nsetup_ns() {\n\t# Set up server_ns namespace and client_ns namespace\n\tsetup_macvlan_ns \"${dev}\" server_ns server \"${SERVER_MAC}\"\n\tsetup_macvlan_ns \"${dev}\" client_ns client \"${CLIENT_MAC}\"\n}\n\ncleanup_ns() {\n\tcleanup_macvlan_ns server_ns server client_ns client\n}\n\nsetup() {\n\tsetup_loopback_environment \"${dev}\"\n\tsetup_interrupt\n}\n\ncleanup() {\n\tcleanup_loopback \"${dev}\"\n\n\techo \"${FLUSH_TIMEOUT}\" >\"${FLUSH_PATH}\"\n\techo \"${HARD_IRQS}\" >\"${IRQ_PATH}\"\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}