{
  "module_name": "psock_lib.h",
  "hash_id": "4d3e7d82f19938e1fde4aca2666b16c6c8802ede5254d3b07f852c3432945ea9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/psock_lib.h",
  "human_readable_source": " \n \n\n#ifndef PSOCK_LIB_H\n#define PSOCK_LIB_H\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#include \"kselftest.h\"\n\n#define DATA_LEN\t\t\t100\n#define DATA_CHAR\t\t\t'a'\n#define DATA_CHAR_1\t\t\t'b'\n\n#define PORT_BASE\t\t\t8000\n\n#ifndef __maybe_unused\n# define __maybe_unused\t\t__attribute__ ((__unused__))\n#endif\n\nstatic __maybe_unused void pair_udp_setfilter(int fd)\n{\n\t \n\tstruct sock_filter bpf_filter[] = {\n\t\t{ 0x28,  0,  0, 0x0000000c },\n\t\t{ 0x15,  0,  8, 0x00000800 },\n\t\t{ 0x30,  0,  0, 0x00000017 },\n\t\t{ 0x15,  0,  6, 0x00000011 },\n\t\t{ 0x80,  0,  0, 0000000000 },\n\t\t{ 0x35,  0,  4, 0x00000064 },\n\t\t{ 0x30,  0,  0, 0x00000050 },\n\t\t{ 0x15,  1,  0, 0x00000061 },\n\t\t{ 0x15,  0,  1, 0x00000062 },\n\t\t{ 0x06,  0,  0, 0xffffffff },\n\t\t{ 0x06,  0,  0, 0000000000 },\n\t};\n\tstruct sock_fprog bpf_prog;\n\n\tbpf_prog.filter = bpf_filter;\n\tbpf_prog.len = ARRAY_SIZE(bpf_filter);\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, &bpf_prog,\n\t\t       sizeof(bpf_prog))) {\n\t\tperror(\"setsockopt SO_ATTACH_FILTER\");\n\t\texit(1);\n\t}\n}\n\nstatic __maybe_unused void pair_udp_open(int fds[], uint16_t port)\n{\n\tstruct sockaddr_in saddr, daddr;\n\n\tfds[0] = socket(PF_INET, SOCK_DGRAM, 0);\n\tfds[1] = socket(PF_INET, SOCK_DGRAM, 0);\n\tif (fds[0] == -1 || fds[1] == -1) {\n\t\tfprintf(stderr, \"ERROR: socket dgram\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_port = htons(port);\n\tsaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n\tmemset(&daddr, 0, sizeof(daddr));\n\tdaddr.sin_family = AF_INET;\n\tdaddr.sin_port = htons(port + 1);\n\tdaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n\t \n\tif (bind(fds[1], (void *) &daddr, sizeof(daddr))) {\n\t\tperror(\"bind\");\n\t\texit(1);\n\t}\n\tif (bind(fds[0], (void *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind\");\n\t\texit(1);\n\t}\n\tif (connect(fds[0], (void *) &daddr, sizeof(daddr))) {\n\t\tperror(\"connect\");\n\t\texit(1);\n\t}\n}\n\nstatic __maybe_unused void pair_udp_send_char(int fds[], int num, char payload)\n{\n\tchar buf[DATA_LEN], rbuf[DATA_LEN];\n\n\tmemset(buf, payload, sizeof(buf));\n\twhile (num--) {\n\t\t \n\t\tif (write(fds[0], buf, sizeof(buf)) != sizeof(buf)) {\n\t\t\tfprintf(stderr, \"ERROR: send failed left=%d\\n\", num);\n\t\t\texit(1);\n\t\t}\n\t\tif (read(fds[1], rbuf, sizeof(rbuf)) != sizeof(rbuf)) {\n\t\t\tfprintf(stderr, \"ERROR: recv failed left=%d\\n\", num);\n\t\t\texit(1);\n\t\t}\n\t\tif (memcmp(buf, rbuf, sizeof(buf))) {\n\t\t\tfprintf(stderr, \"ERROR: data failed left=%d\\n\", num);\n\t\t\texit(1);\n\t\t}\n\t}\n}\n\nstatic __maybe_unused void pair_udp_send(int fds[], int num)\n{\n\treturn pair_udp_send_char(fds, num, DATA_CHAR);\n}\n\nstatic __maybe_unused void pair_udp_close(int fds[])\n{\n\tclose(fds[0]);\n\tclose(fds[1]);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}