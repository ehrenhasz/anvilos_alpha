{
  "module_name": "nettest.c",
  "hash_id": "99a1ef469e45b7cc5b5fcfd3635879fbd2893692378c6da3ddfc9cce56b2aee8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/nettest.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <features.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <limits.h>\n#include <sched.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <time.h>\n#include <errno.h>\n#include <getopt.h>\n\n#include <linux/xfrm.h>\n#include <linux/ipsec.h>\n#include <linux/pfkeyv2.h>\n\n#ifndef IPV6_UNICAST_IF\n#define IPV6_UNICAST_IF         76\n#endif\n#ifndef IPV6_MULTICAST_IF\n#define IPV6_MULTICAST_IF       17\n#endif\n\n#define DEFAULT_PORT 12345\n\n#define NS_PREFIX \"/run/netns/\"\n\n#ifndef MAX\n#define MAX(a, b)  ((a) > (b) ? (a) : (b))\n#endif\n#ifndef MIN\n#define MIN(a, b)  ((a) < (b) ? (a) : (b))\n#endif\n\nstruct sock_args {\n\t \n\tconst char *local_addr_str;\n\tconst char *client_local_addr_str;\n\tunion {\n\t\tstruct in_addr  in;\n\t\tstruct in6_addr in6;\n\t} local_addr;\n\n\t \n\tconst char *remote_addr_str;\n\tunion {\n\t\tstruct in_addr  in;\n\t\tstruct in6_addr in6;\n\t} remote_addr;\n\tint scope_id;   \n\n\tstruct in_addr grp;      \n\n\tunsigned int has_local_ip:1,\n\t\t     has_remote_ip:1,\n\t\t     has_grp:1,\n\t\t     has_expected_laddr:1,\n\t\t     has_expected_raddr:1,\n\t\t     bind_test_only:1,\n\t\t     client_dontroute:1,\n\t\t     server_dontroute:1;\n\n\tunsigned short port;\n\n\tint type;       \n\tint protocol;\n\tint version;    \n\n\tint use_setsockopt;\n\tint use_freebind;\n\tint use_cmsg;\n\tuint8_t dsfield;\n\tconst char *dev;\n\tconst char *server_dev;\n\tint ifindex;\n\n\tconst char *clientns;\n\tconst char *serverns;\n\n\tconst char *password;\n\tconst char *client_pw;\n\t \n\tconst char *md5_prefix_str;\n\tunion {\n\t\tstruct sockaddr_in v4;\n\t\tstruct sockaddr_in6 v6;\n\t} md5_prefix;\n\tunsigned int prefix_len;\n\t \n\tint bind_key_ifindex;\n\n\t \n\tconst char *expected_dev;\n\tconst char *expected_server_dev;\n\tint expected_ifindex;\n\n\t \n\tconst char *expected_laddr_str;\n\tunion {\n\t\tstruct in_addr  in;\n\t\tstruct in6_addr in6;\n\t} expected_laddr;\n\n\t \n\tconst char *expected_raddr_str;\n\tunion {\n\t\tstruct in_addr  in;\n\t\tstruct in6_addr in6;\n\t} expected_raddr;\n\n\t \n\tint use_xfrm;\n\n\t \n\tint datagram_connect;\n};\n\nstatic int server_mode;\nstatic unsigned int prog_timeout = 5;\nstatic unsigned int interactive;\nstatic int iter = 1;\nstatic char *msg = \"Hello world!\";\nstatic int msglen;\nstatic int quiet;\nstatic int try_broadcast = 1;\n\nstatic char *timestamp(char *timebuf, int buflen)\n{\n\ttime_t now;\n\n\tnow = time(NULL);\n\tif (strftime(timebuf, buflen, \"%T\", localtime(&now)) == 0) {\n\t\tmemset(timebuf, 0, buflen);\n\t\tstrncpy(timebuf, \"00:00:00\", buflen-1);\n\t}\n\n\treturn timebuf;\n}\n\nstatic void log_msg(const char *format, ...)\n{\n\tchar timebuf[64];\n\tva_list args;\n\n\tif (quiet)\n\t\treturn;\n\n\tfprintf(stdout, \"%s %s:\",\n\t\ttimestamp(timebuf, sizeof(timebuf)),\n\t\tserver_mode ? \"server\" : \"client\");\n\tva_start(args, format);\n\tvfprintf(stdout, format, args);\n\tva_end(args);\n\n\tfflush(stdout);\n}\n\nstatic void log_error(const char *format, ...)\n{\n\tchar timebuf[64];\n\tva_list args;\n\n\tif (quiet)\n\t\treturn;\n\n\tfprintf(stderr, \"%s %s:\",\n\t\ttimestamp(timebuf, sizeof(timebuf)),\n\t\tserver_mode ? \"server\" : \"client\");\n\tva_start(args, format);\n\tvfprintf(stderr, format, args);\n\tva_end(args);\n\n\tfflush(stderr);\n}\n\nstatic void log_err_errno(const char *fmt, ...)\n{\n\tchar timebuf[64];\n\tva_list args;\n\n\tif (quiet)\n\t\treturn;\n\n\tfprintf(stderr, \"%s %s: \",\n\t\ttimestamp(timebuf, sizeof(timebuf)),\n\t\tserver_mode ? \"server\" : \"client\");\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\n\tfprintf(stderr, \": %d: %s\\n\", errno, strerror(errno));\n\tfflush(stderr);\n}\n\nstatic void log_address(const char *desc, struct sockaddr *sa)\n{\n\tchar addrstr[64];\n\n\tif (quiet)\n\t\treturn;\n\n\tif (sa->sa_family == AF_INET) {\n\t\tstruct sockaddr_in *s = (struct sockaddr_in *) sa;\n\n\t\tlog_msg(\"%s %s:%d\\n\",\n\t\t\tdesc,\n\t\t\tinet_ntop(AF_INET, &s->sin_addr, addrstr,\n\t\t\t\t  sizeof(addrstr)),\n\t\t\tntohs(s->sin_port));\n\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *) sa;\n\n\t\tlog_msg(\"%s [%s]:%d\\n\",\n\t\t\tdesc,\n\t\t\tinet_ntop(AF_INET6, &s6->sin6_addr, addrstr,\n\t\t\t\t  sizeof(addrstr)),\n\t\t\tntohs(s6->sin6_port));\n\t}\n\n\tfflush(stdout);\n}\n\nstatic int switch_ns(const char *ns)\n{\n\tchar path[PATH_MAX];\n\tint fd, ret;\n\n\tif (geteuid())\n\t\tlog_error(\"warning: likely need root to set netns %s!\\n\", ns);\n\n\tsnprintf(path, sizeof(path), \"%s%s\", NS_PREFIX, ns);\n\tfd = open(path, 0);\n\tif (fd < 0) {\n\t\tlog_err_errno(\"Failed to open netns path; can not switch netns\");\n\t\treturn 1;\n\t}\n\n\tret = setns(fd, CLONE_NEWNET);\n\tclose(fd);\n\n\treturn ret;\n}\n\nstatic int tcp_md5sig(int sd, void *addr, socklen_t alen, struct sock_args *args)\n{\n\tint keylen = strlen(args->password);\n\tstruct tcp_md5sig md5sig = {};\n\tint opt = TCP_MD5SIG;\n\tint rc;\n\n\tmd5sig.tcpm_keylen = keylen;\n\tmemcpy(md5sig.tcpm_key, args->password, keylen);\n\n\tif (args->prefix_len) {\n\t\topt = TCP_MD5SIG_EXT;\n\t\tmd5sig.tcpm_flags |= TCP_MD5SIG_FLAG_PREFIX;\n\n\t\tmd5sig.tcpm_prefixlen = args->prefix_len;\n\t\taddr = &args->md5_prefix;\n\t}\n\tmemcpy(&md5sig.tcpm_addr, addr, alen);\n\n\tif ((args->ifindex && args->bind_key_ifindex >= 0) || args->bind_key_ifindex >= 1) {\n\t\topt = TCP_MD5SIG_EXT;\n\t\tmd5sig.tcpm_flags |= TCP_MD5SIG_FLAG_IFINDEX;\n\n\t\tmd5sig.tcpm_ifindex = args->ifindex;\n\t\tlog_msg(\"TCP_MD5SIG_FLAG_IFINDEX set tcpm_ifindex=%d\\n\", md5sig.tcpm_ifindex);\n\t} else {\n\t\tlog_msg(\"TCP_MD5SIG_FLAG_IFINDEX off\\n\", md5sig.tcpm_ifindex);\n\t}\n\n\trc = setsockopt(sd, IPPROTO_TCP, opt, &md5sig, sizeof(md5sig));\n\tif (rc < 0) {\n\t\t \n\t\tif (errno == ENOENT)\n\t\t\trc = 0;\n\t\telse\n\t\t\tlog_err_errno(\"setsockopt(TCP_MD5SIG)\");\n\t}\n\n\treturn rc;\n}\n\nstatic int tcp_md5_remote(int sd, struct sock_args *args)\n{\n\tstruct sockaddr_in sin = {\n\t\t.sin_family = AF_INET,\n\t};\n\tstruct sockaddr_in6 sin6 = {\n\t\t.sin6_family = AF_INET6,\n\t};\n\tvoid *addr;\n\tint alen;\n\n\tswitch (args->version) {\n\tcase AF_INET:\n\t\tsin.sin_port = htons(args->port);\n\t\tsin.sin_addr = args->md5_prefix.v4.sin_addr;\n\t\taddr = &sin;\n\t\talen = sizeof(sin);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsin6.sin6_port = htons(args->port);\n\t\tsin6.sin6_addr = args->md5_prefix.v6.sin6_addr;\n\t\taddr = &sin6;\n\t\talen = sizeof(sin6);\n\t\tbreak;\n\tdefault:\n\t\tlog_error(\"unknown address family\\n\");\n\t\texit(1);\n\t}\n\n\tif (tcp_md5sig(sd, addr, alen, args))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int get_ifidx(const char *ifname)\n{\n\tstruct ifreq ifdata;\n\tint sd, rc;\n\n\tif (!ifname || *ifname == '\\0')\n\t\treturn -1;\n\n\tmemset(&ifdata, 0, sizeof(ifdata));\n\n\tstrcpy(ifdata.ifr_name, ifname);\n\n\tsd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);\n\tif (sd < 0) {\n\t\tlog_err_errno(\"socket failed\");\n\t\treturn -1;\n\t}\n\n\trc = ioctl(sd, SIOCGIFINDEX, (char *)&ifdata);\n\tclose(sd);\n\tif (rc != 0) {\n\t\tlog_err_errno(\"ioctl(SIOCGIFINDEX) failed\");\n\t\treturn -1;\n\t}\n\n\treturn ifdata.ifr_ifindex;\n}\n\nstatic int bind_to_device(int sd, const char *name)\n{\n\tint rc;\n\n\trc = setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, name, strlen(name)+1);\n\tif (rc < 0)\n\t\tlog_err_errno(\"setsockopt(SO_BINDTODEVICE)\");\n\n\treturn rc;\n}\n\nstatic int get_bind_to_device(int sd, char *name, size_t len)\n{\n\tint rc;\n\tsocklen_t optlen = len;\n\n\tname[0] = '\\0';\n\trc = getsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, name, &optlen);\n\tif (rc < 0)\n\t\tlog_err_errno(\"setsockopt(SO_BINDTODEVICE)\");\n\n\treturn rc;\n}\n\nstatic int check_device(int sd, struct sock_args *args)\n{\n\tint ifindex = 0;\n\tchar name[32];\n\n\tif (get_bind_to_device(sd, name, sizeof(name)))\n\t\t*name = '\\0';\n\telse\n\t\tifindex = get_ifidx(name);\n\n\tlog_msg(\"    bound to device %s/%d\\n\",\n\t\t*name ? name : \"<none>\", ifindex);\n\n\tif (!args->expected_ifindex)\n\t\treturn 0;\n\n\tif (args->expected_ifindex != ifindex) {\n\t\tlog_error(\"Device index mismatch: expected %d have %d\\n\",\n\t\t\t  args->expected_ifindex, ifindex);\n\t\treturn 1;\n\t}\n\n\tlog_msg(\"Device index matches: expected %d have %d\\n\",\n\t\targs->expected_ifindex, ifindex);\n\n\treturn 0;\n}\n\nstatic int set_pktinfo_v4(int sd)\n{\n\tint one = 1;\n\tint rc;\n\n\trc = setsockopt(sd, SOL_IP, IP_PKTINFO, &one, sizeof(one));\n\tif (rc < 0 && rc != -ENOTSUP)\n\t\tlog_err_errno(\"setsockopt(IP_PKTINFO)\");\n\n\treturn rc;\n}\n\nstatic int set_recvpktinfo_v6(int sd)\n{\n\tint one = 1;\n\tint rc;\n\n\trc = setsockopt(sd, SOL_IPV6, IPV6_RECVPKTINFO, &one, sizeof(one));\n\tif (rc < 0 && rc != -ENOTSUP)\n\t\tlog_err_errno(\"setsockopt(IPV6_RECVPKTINFO)\");\n\n\treturn rc;\n}\n\nstatic int set_recverr_v4(int sd)\n{\n\tint one = 1;\n\tint rc;\n\n\trc = setsockopt(sd, SOL_IP, IP_RECVERR, &one, sizeof(one));\n\tif (rc < 0 && rc != -ENOTSUP)\n\t\tlog_err_errno(\"setsockopt(IP_RECVERR)\");\n\n\treturn rc;\n}\n\nstatic int set_recverr_v6(int sd)\n{\n\tint one = 1;\n\tint rc;\n\n\trc = setsockopt(sd, SOL_IPV6, IPV6_RECVERR, &one, sizeof(one));\n\tif (rc < 0 && rc != -ENOTSUP)\n\t\tlog_err_errno(\"setsockopt(IPV6_RECVERR)\");\n\n\treturn rc;\n}\n\nstatic int set_unicast_if(int sd, int ifindex, int version)\n{\n\tint opt = IP_UNICAST_IF;\n\tint level = SOL_IP;\n\tint rc;\n\n\tifindex = htonl(ifindex);\n\n\tif (version == AF_INET6) {\n\t\topt = IPV6_UNICAST_IF;\n\t\tlevel = SOL_IPV6;\n\t}\n\trc = setsockopt(sd, level, opt, &ifindex, sizeof(ifindex));\n\tif (rc < 0)\n\t\tlog_err_errno(\"setsockopt(IP_UNICAST_IF)\");\n\n\treturn rc;\n}\n\nstatic int set_multicast_if(int sd, int ifindex)\n{\n\tstruct ip_mreqn mreq = { .imr_ifindex = ifindex };\n\tint rc;\n\n\trc = setsockopt(sd, SOL_IP, IP_MULTICAST_IF, &mreq, sizeof(mreq));\n\tif (rc < 0)\n\t\tlog_err_errno(\"setsockopt(IP_MULTICAST_IF)\");\n\n\treturn rc;\n}\n\nstatic int set_membership(int sd, uint32_t grp, uint32_t addr, int ifindex)\n{\n\tuint32_t if_addr = addr;\n\tstruct ip_mreqn mreq;\n\tint rc;\n\n\tif (addr == htonl(INADDR_ANY) && !ifindex) {\n\t\tlog_error(\"Either local address or device needs to be given for multicast membership\\n\");\n\t\treturn -1;\n\t}\n\n\tmreq.imr_multiaddr.s_addr = grp;\n\tmreq.imr_address.s_addr = if_addr;\n\tmreq.imr_ifindex = ifindex;\n\n\trc = setsockopt(sd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));\n\tif (rc < 0) {\n\t\tlog_err_errno(\"setsockopt(IP_ADD_MEMBERSHIP)\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_freebind(int sd, int version)\n{\n\tunsigned int one = 1;\n\tint rc = 0;\n\n\tswitch (version) {\n\tcase AF_INET:\n\t\tif (setsockopt(sd, SOL_IP, IP_FREEBIND, &one, sizeof(one))) {\n\t\t\tlog_err_errno(\"setsockopt(IP_FREEBIND)\");\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (setsockopt(sd, SOL_IPV6, IPV6_FREEBIND, &one, sizeof(one))) {\n\t\t\tlog_err_errno(\"setsockopt(IPV6_FREEBIND\");\n\t\t\trc = -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int set_broadcast(int sd)\n{\n\tunsigned int one = 1;\n\tint rc = 0;\n\n\tif (setsockopt(sd, SOL_SOCKET, SO_BROADCAST, &one, sizeof(one)) != 0) {\n\t\tlog_err_errno(\"setsockopt(SO_BROADCAST)\");\n\t\trc = -1;\n\t}\n\n\treturn rc;\n}\n\nstatic int set_reuseport(int sd)\n{\n\tunsigned int one = 1;\n\tint rc = 0;\n\n\tif (setsockopt(sd, SOL_SOCKET, SO_REUSEPORT, &one, sizeof(one)) != 0) {\n\t\tlog_err_errno(\"setsockopt(SO_REUSEPORT)\");\n\t\trc = -1;\n\t}\n\n\treturn rc;\n}\n\nstatic int set_reuseaddr(int sd)\n{\n\tunsigned int one = 1;\n\tint rc = 0;\n\n\tif (setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) != 0) {\n\t\tlog_err_errno(\"setsockopt(SO_REUSEADDR)\");\n\t\trc = -1;\n\t}\n\n\treturn rc;\n}\n\nstatic int set_dsfield(int sd, int version, int dsfield)\n{\n\tif (!dsfield)\n\t\treturn 0;\n\n\tswitch (version) {\n\tcase AF_INET:\n\t\tif (setsockopt(sd, SOL_IP, IP_TOS, &dsfield,\n\t\t\t       sizeof(dsfield)) < 0) {\n\t\t\tlog_err_errno(\"setsockopt(IP_TOS)\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tif (setsockopt(sd, SOL_IPV6, IPV6_TCLASS, &dsfield,\n\t\t\t       sizeof(dsfield)) < 0) {\n\t\t\tlog_err_errno(\"setsockopt(IPV6_TCLASS)\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(\"Invalid address family\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_dontroute(int sd)\n{\n\tunsigned int one = 1;\n\n\tif (setsockopt(sd, SOL_SOCKET, SO_DONTROUTE, &one, sizeof(one)) < 0) {\n\t\tlog_err_errno(\"setsockopt(SO_DONTROUTE)\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int str_to_uint(const char *str, int min, int max, unsigned int *value)\n{\n\tint number;\n\tchar *end;\n\n\terrno = 0;\n\tnumber = (unsigned int) strtoul(str, &end, 0);\n\n\t \n\tif (((*end == '\\0') || (*end == '\\n')) && (end != str) &&\n\t    (errno != ERANGE) && (min <= number) && (number <= max)) {\n\t\t*value = number;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int resolve_devices(struct sock_args *args)\n{\n\tif (args->dev) {\n\t\targs->ifindex = get_ifidx(args->dev);\n\t\tif (args->ifindex < 0) {\n\t\t\tlog_error(\"Invalid device name\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (args->expected_dev) {\n\t\tunsigned int tmp;\n\n\t\tif (str_to_uint(args->expected_dev, 0, INT_MAX, &tmp) == 0) {\n\t\t\targs->expected_ifindex = (int)tmp;\n\t\t} else {\n\t\t\targs->expected_ifindex = get_ifidx(args->expected_dev);\n\t\t\tif (args->expected_ifindex < 0) {\n\t\t\t\tfprintf(stderr, \"Invalid expected device\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int expected_addr_match(struct sockaddr *sa, void *expected,\n\t\t\t       const char *desc)\n{\n\tchar addrstr[64];\n\tint rc = 0;\n\n\tif (sa->sa_family == AF_INET) {\n\t\tstruct sockaddr_in *s = (struct sockaddr_in *) sa;\n\t\tstruct in_addr *exp_in = (struct in_addr *) expected;\n\n\t\tif (s->sin_addr.s_addr != exp_in->s_addr) {\n\t\t\tlog_error(\"%s address does not match expected %s\\n\",\n\t\t\t\t  desc,\n\t\t\t\t  inet_ntop(AF_INET, exp_in,\n\t\t\t\t\t    addrstr, sizeof(addrstr)));\n\t\t\trc = 1;\n\t\t}\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *) sa;\n\t\tstruct in6_addr *exp_in = (struct in6_addr *) expected;\n\n\t\tif (memcmp(&s6->sin6_addr, exp_in, sizeof(*exp_in))) {\n\t\t\tlog_error(\"%s address does not match expected %s\\n\",\n\t\t\t\t  desc,\n\t\t\t\t  inet_ntop(AF_INET6, exp_in,\n\t\t\t\t\t    addrstr, sizeof(addrstr)));\n\t\t\trc = 1;\n\t\t}\n\t} else {\n\t\tlog_error(\"%s address does not match expected - unknown family\\n\",\n\t\t\t  desc);\n\t\trc = 1;\n\t}\n\n\tif (!rc)\n\t\tlog_msg(\"%s address matches expected\\n\", desc);\n\n\treturn rc;\n}\n\nstatic int show_sockstat(int sd, struct sock_args *args)\n{\n\tstruct sockaddr_in6 local_addr, remote_addr;\n\tsocklen_t alen = sizeof(local_addr);\n\tstruct sockaddr *sa;\n\tconst char *desc;\n\tint rc = 0;\n\n\tdesc = server_mode ? \"server local:\" : \"client local:\";\n\tsa = (struct sockaddr *) &local_addr;\n\tif (getsockname(sd, sa, &alen) == 0) {\n\t\tlog_address(desc, sa);\n\n\t\tif (args->has_expected_laddr) {\n\t\t\trc = expected_addr_match(sa, &args->expected_laddr,\n\t\t\t\t\t\t \"local\");\n\t\t}\n\t} else {\n\t\tlog_err_errno(\"getsockname failed\");\n\t}\n\n\tsa = (struct sockaddr *) &remote_addr;\n\tdesc = server_mode ? \"server peer:\" : \"client peer:\";\n\tif (getpeername(sd, sa, &alen) == 0) {\n\t\tlog_address(desc, sa);\n\n\t\tif (args->has_expected_raddr) {\n\t\t\trc |= expected_addr_match(sa, &args->expected_raddr,\n\t\t\t\t\t\t \"remote\");\n\t\t}\n\t} else {\n\t\tlog_err_errno(\"getpeername failed\");\n\t}\n\n\treturn rc;\n}\n\nenum addr_type {\n\tADDR_TYPE_LOCAL,\n\tADDR_TYPE_REMOTE,\n\tADDR_TYPE_MCAST,\n\tADDR_TYPE_EXPECTED_LOCAL,\n\tADDR_TYPE_EXPECTED_REMOTE,\n\tADDR_TYPE_MD5_PREFIX,\n};\n\nstatic int convert_addr(struct sock_args *args, const char *_str,\n\t\t\tenum addr_type atype)\n{\n\tint pfx_len_max = args->version == AF_INET6 ? 128 : 32;\n\tint family = args->version;\n\tchar *str, *dev, *sep;\n\tstruct in6_addr *in6;\n\tstruct in_addr  *in;\n\tconst char *desc;\n\tvoid *addr;\n\tint rc = 0;\n\n\tstr = strdup(_str);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\tswitch (atype) {\n\tcase ADDR_TYPE_LOCAL:\n\t\tdesc = \"local\";\n\t\taddr = &args->local_addr;\n\t\tbreak;\n\tcase ADDR_TYPE_REMOTE:\n\t\tdesc = \"remote\";\n\t\taddr = &args->remote_addr;\n\t\tbreak;\n\tcase ADDR_TYPE_MCAST:\n\t\tdesc = \"mcast grp\";\n\t\taddr = &args->grp;\n\t\tbreak;\n\tcase ADDR_TYPE_EXPECTED_LOCAL:\n\t\tdesc = \"expected local\";\n\t\taddr = &args->expected_laddr;\n\t\tbreak;\n\tcase ADDR_TYPE_EXPECTED_REMOTE:\n\t\tdesc = \"expected remote\";\n\t\taddr = &args->expected_raddr;\n\t\tbreak;\n\tcase ADDR_TYPE_MD5_PREFIX:\n\t\tdesc = \"md5 prefix\";\n\t\tif (family == AF_INET) {\n\t\t\targs->md5_prefix.v4.sin_family = AF_INET;\n\t\t\taddr = &args->md5_prefix.v4.sin_addr;\n\t\t} else if (family == AF_INET6) {\n\t\t\targs->md5_prefix.v6.sin6_family = AF_INET6;\n\t\t\taddr = &args->md5_prefix.v6.sin6_addr;\n\t\t} else\n\t\t\treturn 1;\n\n\t\tsep = strchr(str, '/');\n\t\tif (sep) {\n\t\t\t*sep = '\\0';\n\t\t\tsep++;\n\t\t\tif (str_to_uint(sep, 1, pfx_len_max,\n\t\t\t\t\t&args->prefix_len) != 0) {\n\t\t\t\tfprintf(stderr, \"Invalid port\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\targs->prefix_len = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tlog_error(\"unknown address type\\n\");\n\t\texit(1);\n\t}\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tin  = (struct in_addr *) addr;\n\t\tif (str) {\n\t\t\tif (inet_pton(AF_INET, str, in) == 0) {\n\t\t\t\tlog_error(\"Invalid %s IP address\\n\", desc);\n\t\t\t\trc = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tin->s_addr = htonl(INADDR_ANY);\n\t\t}\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tdev = strchr(str, '%');\n\t\tif (dev) {\n\t\t\t*dev = '\\0';\n\t\t\tdev++;\n\t\t}\n\n\t\tin6 = (struct in6_addr *) addr;\n\t\tif (str) {\n\t\t\tif (inet_pton(AF_INET6, str, in6) == 0) {\n\t\t\t\tlog_error(\"Invalid %s IPv6 address\\n\", desc);\n\t\t\t\trc = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t*in6 = in6addr_any;\n\t\t}\n\t\tif (dev) {\n\t\t\targs->scope_id = get_ifidx(dev);\n\t\t\tif (args->scope_id < 0) {\n\t\t\t\tlog_error(\"Invalid scope on %s IPv6 address\\n\",\n\t\t\t\t\t  desc);\n\t\t\t\trc = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(\"Invalid address family\\n\");\n\t}\n\nout:\n\tfree(str);\n\treturn rc;\n}\n\nstatic int validate_addresses(struct sock_args *args)\n{\n\tif (args->local_addr_str &&\n\t    convert_addr(args, args->local_addr_str, ADDR_TYPE_LOCAL) < 0)\n\t\treturn 1;\n\n\tif (args->remote_addr_str &&\n\t    convert_addr(args, args->remote_addr_str, ADDR_TYPE_REMOTE) < 0)\n\t\treturn 1;\n\n\tif (args->md5_prefix_str &&\n\t    convert_addr(args, args->md5_prefix_str,\n\t\t\t ADDR_TYPE_MD5_PREFIX) < 0)\n\t\treturn 1;\n\n\tif (args->expected_laddr_str &&\n\t    convert_addr(args, args->expected_laddr_str,\n\t\t\t ADDR_TYPE_EXPECTED_LOCAL))\n\t\treturn 1;\n\n\tif (args->expected_raddr_str &&\n\t    convert_addr(args, args->expected_raddr_str,\n\t\t\t ADDR_TYPE_EXPECTED_REMOTE))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int get_index_from_cmsg(struct msghdr *m)\n{\n\tstruct cmsghdr *cm;\n\tint ifindex = 0;\n\tchar buf[64];\n\n\tfor (cm = (struct cmsghdr *)CMSG_FIRSTHDR(m);\n\t     m->msg_controllen != 0 && cm;\n\t     cm = (struct cmsghdr *)CMSG_NXTHDR(m, cm)) {\n\n\t\tif (cm->cmsg_level == SOL_IP &&\n\t\t    cm->cmsg_type == IP_PKTINFO) {\n\t\t\tstruct in_pktinfo *pi;\n\n\t\t\tpi = (struct in_pktinfo *)(CMSG_DATA(cm));\n\t\t\tinet_ntop(AF_INET, &pi->ipi_addr, buf, sizeof(buf));\n\t\t\tifindex = pi->ipi_ifindex;\n\t\t} else if (cm->cmsg_level == SOL_IPV6 &&\n\t\t\t   cm->cmsg_type == IPV6_PKTINFO) {\n\t\t\tstruct in6_pktinfo *pi6;\n\n\t\t\tpi6 = (struct in6_pktinfo *)(CMSG_DATA(cm));\n\t\t\tinet_ntop(AF_INET6, &pi6->ipi6_addr, buf, sizeof(buf));\n\t\t\tifindex = pi6->ipi6_ifindex;\n\t\t}\n\t}\n\n\tif (ifindex) {\n\t\tlog_msg(\"    pktinfo: ifindex %d dest addr %s\\n\",\n\t\t\tifindex, buf);\n\t}\n\treturn ifindex;\n}\n\nstatic int send_msg_no_cmsg(int sd, void *addr, socklen_t alen)\n{\n\tint err;\n\nagain:\n\terr = sendto(sd, msg, msglen, 0, addr, alen);\n\tif (err < 0) {\n\t\tif (errno == EACCES && try_broadcast) {\n\t\t\ttry_broadcast = 0;\n\t\t\tif (!set_broadcast(sd))\n\t\t\t\tgoto again;\n\t\t\terrno = EACCES;\n\t\t}\n\n\t\tlog_err_errno(\"sendto failed\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int send_msg_cmsg(int sd, void *addr, socklen_t alen,\n\t\t\t int ifindex, int version)\n{\n\tunsigned char cmsgbuf[64];\n\tstruct iovec iov[2];\n\tstruct cmsghdr *cm;\n\tstruct msghdr m;\n\tint err;\n\n\tiov[0].iov_base = msg;\n\tiov[0].iov_len = msglen;\n\tm.msg_iov = iov;\n\tm.msg_iovlen = 1;\n\tm.msg_name = (caddr_t)addr;\n\tm.msg_namelen = alen;\n\n\tmemset(cmsgbuf, 0, sizeof(cmsgbuf));\n\tcm = (struct cmsghdr *)cmsgbuf;\n\tm.msg_control = (caddr_t)cm;\n\n\tif (version == AF_INET) {\n\t\tstruct in_pktinfo *pi;\n\n\t\tcm->cmsg_level = SOL_IP;\n\t\tcm->cmsg_type = IP_PKTINFO;\n\t\tcm->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));\n\t\tpi = (struct in_pktinfo *)(CMSG_DATA(cm));\n\t\tpi->ipi_ifindex = ifindex;\n\n\t\tm.msg_controllen = cm->cmsg_len;\n\n\t} else if (version == AF_INET6) {\n\t\tstruct in6_pktinfo *pi6;\n\n\t\tcm->cmsg_level = SOL_IPV6;\n\t\tcm->cmsg_type = IPV6_PKTINFO;\n\t\tcm->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));\n\n\t\tpi6 = (struct in6_pktinfo *)(CMSG_DATA(cm));\n\t\tpi6->ipi6_ifindex = ifindex;\n\n\t\tm.msg_controllen = cm->cmsg_len;\n\t}\n\nagain:\n\terr = sendmsg(sd, &m, 0);\n\tif (err < 0) {\n\t\tif (errno == EACCES && try_broadcast) {\n\t\t\ttry_broadcast = 0;\n\t\t\tif (!set_broadcast(sd))\n\t\t\t\tgoto again;\n\t\t\terrno = EACCES;\n\t\t}\n\n\t\tlog_err_errno(\"sendmsg failed\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int send_msg(int sd, void *addr, socklen_t alen, struct sock_args *args)\n{\n\tif (args->type == SOCK_STREAM) {\n\t\tif (write(sd, msg, msglen) < 0) {\n\t\t\tlog_err_errno(\"write failed sending msg to peer\");\n\t\t\treturn 1;\n\t\t}\n\t} else if (args->datagram_connect) {\n\t\tif (send(sd, msg, msglen, 0) < 0) {\n\t\t\tlog_err_errno(\"send failed sending msg to peer\");\n\t\t\treturn 1;\n\t\t}\n\t} else if (args->ifindex && args->use_cmsg) {\n\t\tif (send_msg_cmsg(sd, addr, alen, args->ifindex, args->version))\n\t\t\treturn 1;\n\t} else {\n\t\tif (send_msg_no_cmsg(sd, addr, alen))\n\t\t\treturn 1;\n\t}\n\n\tlog_msg(\"Sent message:\\n\");\n\tlog_msg(\"    %.24s%s\\n\", msg, msglen > 24 ? \" ...\" : \"\");\n\n\treturn 0;\n}\n\nstatic int socket_read_dgram(int sd, struct sock_args *args)\n{\n\tunsigned char addr[sizeof(struct sockaddr_in6)];\n\tstruct sockaddr *sa = (struct sockaddr *) addr;\n\tsocklen_t alen = sizeof(addr);\n\tstruct iovec iov[2];\n\tstruct msghdr m = {\n\t\t.msg_name = (caddr_t)addr,\n\t\t.msg_namelen = alen,\n\t\t.msg_iov = iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tunsigned char cmsgbuf[256];\n\tstruct cmsghdr *cm = (struct cmsghdr *)cmsgbuf;\n\tchar buf[16*1024];\n\tint ifindex;\n\tint len;\n\n\tiov[0].iov_base = (caddr_t)buf;\n\tiov[0].iov_len = sizeof(buf);\n\n\tmemset(cmsgbuf, 0, sizeof(cmsgbuf));\n\tm.msg_control = (caddr_t)cm;\n\tm.msg_controllen = sizeof(cmsgbuf);\n\n\tlen = recvmsg(sd, &m, 0);\n\tif (len == 0) {\n\t\tlog_msg(\"peer closed connection.\\n\");\n\t\treturn 0;\n\t} else if (len < 0) {\n\t\tlog_msg(\"failed to read message: %d: %s\\n\",\n\t\t\terrno, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tbuf[len] = '\\0';\n\n\tlog_address(\"Message from:\", sa);\n\tlog_msg(\"    %.24s%s\\n\", buf, len > 24 ? \" ...\" : \"\");\n\n\tifindex = get_index_from_cmsg(&m);\n\tif (args->expected_ifindex) {\n\t\tif (args->expected_ifindex != ifindex) {\n\t\t\tlog_error(\"Device index mismatch: expected %d have %d\\n\",\n\t\t\t\t  args->expected_ifindex, ifindex);\n\t\t\treturn -1;\n\t\t}\n\t\tlog_msg(\"Device index matches: expected %d have %d\\n\",\n\t\t\targs->expected_ifindex, ifindex);\n\t}\n\n\tif (!interactive && server_mode) {\n\t\tif (sa->sa_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *) sa;\n\t\t\tstruct in6_addr *in6 = &s6->sin6_addr;\n\n\t\t\tif (IN6_IS_ADDR_V4MAPPED(in6)) {\n\t\t\t\tconst uint32_t *pa = (uint32_t *) &in6->s6_addr;\n\t\t\t\tstruct in_addr in4;\n\t\t\t\tstruct sockaddr_in *sin;\n\n\t\t\t\tsin = (struct sockaddr_in *) addr;\n\t\t\t\tpa += 3;\n\t\t\t\tin4.s_addr = *pa;\n\t\t\t\tsin->sin_addr = in4;\n\t\t\t\tsin->sin_family = AF_INET;\n\t\t\t\tif (send_msg_cmsg(sd, addr, alen,\n\t\t\t\t\t\t  ifindex, AF_INET) < 0)\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\nagain:\n\t\tiov[0].iov_len = len;\n\n\t\tif (args->version == AF_INET6) {\n\t\t\tstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *) sa;\n\n\t\t\tif (args->dev) {\n\t\t\t\t \n\t\t\t\tif (sendto(sd, buf, len, 0,\n\t\t\t\t\t   (void *) addr, alen) < 0)\n\t\t\t\t\tgoto out_err;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ts6->sin6_scope_id = ifindex;\n\t\t\t\tif (sendmsg(sd, &m, 0) < 0)\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t} else {\n\t\t\tint err;\n\n\t\t\terr = sendmsg(sd, &m, 0);\n\t\t\tif (err < 0) {\n\t\t\t\tif (errno == EACCES && try_broadcast) {\n\t\t\t\t\ttry_broadcast = 0;\n\t\t\t\t\tif (!set_broadcast(sd))\n\t\t\t\t\t\tgoto again;\n\t\t\t\t\terrno = EACCES;\n\t\t\t\t}\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t\tlog_msg(\"Sent message:\\n\");\n\t\tlog_msg(\"    %.24s%s\\n\", buf, len > 24 ? \" ...\" : \"\");\n\t}\n\n\treturn 1;\nout_err:\n\tlog_err_errno(\"failed to send msg to peer\");\n\treturn -1;\n}\n\nstatic int socket_read_stream(int sd)\n{\n\tchar buf[1024];\n\tint len;\n\n\tlen = read(sd, buf, sizeof(buf)-1);\n\tif (len == 0) {\n\t\tlog_msg(\"client closed connection.\\n\");\n\t\treturn 0;\n\t} else if (len < 0) {\n\t\tlog_msg(\"failed to read message\\n\");\n\t\treturn -1;\n\t}\n\n\tbuf[len] = '\\0';\n\tlog_msg(\"Incoming message:\\n\");\n\tlog_msg(\"    %.24s%s\\n\", buf, len > 24 ? \" ...\" : \"\");\n\n\tif (!interactive && server_mode) {\n\t\tif (write(sd, buf, len) < 0) {\n\t\t\tlog_err_errno(\"failed to send buf\");\n\t\t\treturn -1;\n\t\t}\n\t\tlog_msg(\"Sent message:\\n\");\n\t\tlog_msg(\"     %.24s%s\\n\", buf, len > 24 ? \" ...\" : \"\");\n\t}\n\n\treturn 1;\n}\n\nstatic int socket_read(int sd, struct sock_args *args)\n{\n\tif (args->type == SOCK_STREAM)\n\t\treturn socket_read_stream(sd);\n\n\treturn socket_read_dgram(sd, args);\n}\n\nstatic int stdin_to_socket(int sd, int type, void *addr, socklen_t alen)\n{\n\tchar buf[1024];\n\tint len;\n\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\treturn 0;\n\n\tlen = strlen(buf);\n\tif (type == SOCK_STREAM) {\n\t\tif (write(sd, buf, len) < 0) {\n\t\t\tlog_err_errno(\"failed to send buf\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tint err;\n\nagain:\n\t\terr = sendto(sd, buf, len, 0, addr, alen);\n\t\tif (err < 0) {\n\t\t\tif (errno == EACCES && try_broadcast) {\n\t\t\t\ttry_broadcast = 0;\n\t\t\t\tif (!set_broadcast(sd))\n\t\t\t\t\tgoto again;\n\t\t\t\terrno = EACCES;\n\t\t\t}\n\t\t\tlog_err_errno(\"failed to send msg to peer\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlog_msg(\"Sent message:\\n\");\n\tlog_msg(\"    %.24s%s\\n\", buf, len > 24 ? \" ...\" : \"\");\n\n\treturn 1;\n}\n\nstatic void set_recv_attr(int sd, int version)\n{\n\tif (version == AF_INET6) {\n\t\tset_recvpktinfo_v6(sd);\n\t\tset_recverr_v6(sd);\n\t} else {\n\t\tset_pktinfo_v4(sd);\n\t\tset_recverr_v4(sd);\n\t}\n}\n\nstatic int msg_loop(int client, int sd, void *addr, socklen_t alen,\n\t\t    struct sock_args *args)\n{\n\tstruct timeval timeout = { .tv_sec = prog_timeout }, *ptval = NULL;\n\tfd_set rfds;\n\tint nfds;\n\tint rc;\n\n\tif (args->type != SOCK_STREAM)\n\t\tset_recv_attr(sd, args->version);\n\n\tif (msg) {\n\t\tmsglen = strlen(msg);\n\n\t\t \n\t\tif (client) {\n\t\t\tif (send_msg(sd, addr, alen, args))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (!interactive) {\n\t\t\tptval = &timeout;\n\t\t\tif (!prog_timeout)\n\t\t\t\ttimeout.tv_sec = 5;\n\t\t}\n\t}\n\n\tnfds = interactive ? MAX(fileno(stdin), sd)  + 1 : sd + 1;\n\twhile (1) {\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(sd, &rfds);\n\t\tif (interactive)\n\t\t\tFD_SET(fileno(stdin), &rfds);\n\n\t\trc = select(nfds, &rfds, NULL, NULL, ptval);\n\t\tif (rc < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\trc = 1;\n\t\t\tlog_err_errno(\"select failed\");\n\t\t\tbreak;\n\t\t} else if (rc == 0) {\n\t\t\tlog_error(\"Timed out waiting for response\\n\");\n\t\t\trc = 2;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FD_ISSET(sd, &rfds)) {\n\t\t\trc = socket_read(sd, args);\n\t\t\tif (rc < 0) {\n\t\t\t\trc = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\trc = 0;\n\n\t\tif (FD_ISSET(fileno(stdin), &rfds)) {\n\t\t\tif (stdin_to_socket(sd, args->type, addr, alen) <= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (interactive)\n\t\t\tcontinue;\n\n\t\tif (iter != -1) {\n\t\t\t--iter;\n\t\t\tif (iter == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlog_msg(\"Going into quiet mode\\n\");\n\t\tquiet = 1;\n\n\t\tif (client) {\n\t\t\tif (send_msg(sd, addr, alen, args)) {\n\t\t\t\trc = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int msock_init(struct sock_args *args, int server)\n{\n\tuint32_t if_addr = htonl(INADDR_ANY);\n\tstruct sockaddr_in laddr = {\n\t\t.sin_family = AF_INET,\n\t\t.sin_port = htons(args->port),\n\t};\n\tint one = 1;\n\tint sd;\n\n\tif (!server && args->has_local_ip)\n\t\tif_addr = args->local_addr.in.s_addr;\n\n\tsd = socket(PF_INET, SOCK_DGRAM, 0);\n\tif (sd < 0) {\n\t\tlog_err_errno(\"socket\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sd, SOL_SOCKET, SO_REUSEADDR,\n\t\t       (char *)&one, sizeof(one)) < 0) {\n\t\tlog_err_errno(\"Setting SO_REUSEADDR error\");\n\t\tgoto out_err;\n\t}\n\n\tif (setsockopt(sd, SOL_SOCKET, SO_BROADCAST,\n\t\t       (char *)&one, sizeof(one)) < 0)\n\t\tlog_err_errno(\"Setting SO_BROADCAST error\");\n\n\tif (set_dsfield(sd, AF_INET, args->dsfield) != 0)\n\t\tgoto out_err;\n\n\tif (server) {\n\t\tif (args->server_dontroute && set_dontroute(sd) != 0)\n\t\t\tgoto out_err;\n\t} else {\n\t\tif (args->client_dontroute && set_dontroute(sd) != 0)\n\t\t\tgoto out_err;\n\t}\n\n\tif (args->dev && bind_to_device(sd, args->dev) != 0)\n\t\tgoto out_err;\n\telse if (args->use_setsockopt &&\n\t\t set_multicast_if(sd, args->ifindex))\n\t\tgoto out_err;\n\n\tladdr.sin_addr.s_addr = if_addr;\n\n\tif (bind(sd, (struct sockaddr *) &laddr, sizeof(laddr)) < 0) {\n\t\tlog_err_errno(\"bind failed\");\n\t\tgoto out_err;\n\t}\n\n\tif (server &&\n\t    set_membership(sd, args->grp.s_addr,\n\t\t\t   args->local_addr.in.s_addr, args->ifindex))\n\t\tgoto out_err;\n\n\treturn sd;\nout_err:\n\tclose(sd);\n\treturn -1;\n}\n\nstatic int msock_server(struct sock_args *args)\n{\n\treturn msock_init(args, 1);\n}\n\nstatic int msock_client(struct sock_args *args)\n{\n\treturn msock_init(args, 0);\n}\n\nstatic int bind_socket(int sd, struct sock_args *args)\n{\n\tstruct sockaddr_in serv_addr = {\n\t\t.sin_family = AF_INET,\n\t};\n\tstruct sockaddr_in6 serv6_addr = {\n\t\t.sin6_family = AF_INET6,\n\t};\n\tvoid *addr;\n\tsocklen_t alen;\n\n\tif (!args->has_local_ip && args->type == SOCK_RAW)\n\t\treturn 0;\n\n\tswitch (args->version) {\n\tcase AF_INET:\n\t\tserv_addr.sin_port = htons(args->port);\n\t\tserv_addr.sin_addr = args->local_addr.in;\n\t\taddr = &serv_addr;\n\t\talen = sizeof(serv_addr);\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tserv6_addr.sin6_port = htons(args->port);\n\t\tserv6_addr.sin6_addr = args->local_addr.in6;\n\t\taddr = &serv6_addr;\n\t\talen = sizeof(serv6_addr);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(\"Invalid address family\\n\");\n\t\treturn -1;\n\t}\n\n\tif (bind(sd, addr, alen) < 0) {\n\t\tlog_err_errno(\"error binding socket\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int config_xfrm_policy(int sd, struct sock_args *args)\n{\n\tstruct xfrm_userpolicy_info policy = {};\n\tint type = UDP_ENCAP_ESPINUDP;\n\tint xfrm_af = IP_XFRM_POLICY;\n\tint level = SOL_IP;\n\n\tif (args->type != SOCK_DGRAM) {\n\t\tlog_error(\"Invalid socket type. Only DGRAM could be used for XFRM\\n\");\n\t\treturn 1;\n\t}\n\n\tpolicy.action = XFRM_POLICY_ALLOW;\n\tpolicy.sel.family = args->version;\n\tif (args->version == AF_INET6) {\n\t\txfrm_af = IPV6_XFRM_POLICY;\n\t\tlevel = SOL_IPV6;\n\t}\n\n\tpolicy.dir = XFRM_POLICY_OUT;\n\tif (setsockopt(sd, level, xfrm_af, &policy, sizeof(policy)) < 0)\n\t\treturn 1;\n\n\tpolicy.dir = XFRM_POLICY_IN;\n\tif (setsockopt(sd, level, xfrm_af, &policy, sizeof(policy)) < 0)\n\t\treturn 1;\n\n\tif (setsockopt(sd, IPPROTO_UDP, UDP_ENCAP, &type, sizeof(type)) < 0) {\n\t\tlog_err_errno(\"Failed to set xfrm encap\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int lsock_init(struct sock_args *args)\n{\n\tlong flags;\n\tint sd;\n\n\tsd = socket(args->version, args->type, args->protocol);\n\tif (sd < 0) {\n\t\tlog_err_errno(\"Error opening socket\");\n\t\treturn  -1;\n\t}\n\n\tif (set_reuseaddr(sd) != 0)\n\t\tgoto err;\n\n\tif (set_reuseport(sd) != 0)\n\t\tgoto err;\n\n\tif (set_dsfield(sd, args->version, args->dsfield) != 0)\n\t\tgoto err;\n\n\tif (args->server_dontroute && set_dontroute(sd) != 0)\n\t\tgoto err;\n\n\tif (args->dev && bind_to_device(sd, args->dev) != 0)\n\t\tgoto err;\n\telse if (args->use_setsockopt &&\n\t\t set_unicast_if(sd, args->ifindex, args->version))\n\t\tgoto err;\n\n\tif (args->use_freebind && set_freebind(sd, args->version))\n\t\tgoto err;\n\n\tif (bind_socket(sd, args))\n\t\tgoto err;\n\n\tif (args->bind_test_only)\n\t\tgoto out;\n\n\tif (args->type == SOCK_STREAM && listen(sd, 1) < 0) {\n\t\tlog_err_errno(\"listen failed\");\n\t\tgoto err;\n\t}\n\n\tflags = fcntl(sd, F_GETFL);\n\tif ((flags < 0) || (fcntl(sd, F_SETFL, flags|O_NONBLOCK) < 0)) {\n\t\tlog_err_errno(\"Failed to set non-blocking option\");\n\t\tgoto err;\n\t}\n\n\tif (fcntl(sd, F_SETFD, FD_CLOEXEC) < 0)\n\t\tlog_err_errno(\"Failed to set close-on-exec flag\");\n\n\tif (args->use_xfrm && config_xfrm_policy(sd, args)) {\n\t\tlog_err_errno(\"Failed to set xfrm policy\");\n\t\tgoto err;\n\t}\n\nout:\n\treturn sd;\n\nerr:\n\tclose(sd);\n\treturn -1;\n}\n\nstatic void ipc_write(int fd, int message)\n{\n\t \n\tif (fd < 0)\n\t\treturn;\n\n\tif (write(fd, &message, sizeof(message)) < 0)\n\t\tlog_err_errno(\"Failed to send client status\");\n}\n\nstatic int do_server(struct sock_args *args, int ipc_fd)\n{\n\t \n\tstruct timeval timeout = { .tv_sec = prog_timeout }, *ptval = NULL;\n\tunsigned char addr[sizeof(struct sockaddr_in6)] = {};\n\tsocklen_t alen = sizeof(addr);\n\tint lsd, csd = -1;\n\n\tfd_set rfds;\n\tint rc;\n\n\tif (args->serverns) {\n\t\tif (switch_ns(args->serverns)) {\n\t\t\tlog_error(\"Could not set server netns to %s\\n\",\n\t\t\t\t  args->serverns);\n\t\t\tgoto err_exit;\n\t\t}\n\t\tlog_msg(\"Switched server netns\\n\");\n\t}\n\n\targs->dev = args->server_dev;\n\targs->expected_dev = args->expected_server_dev;\n\tif (resolve_devices(args) || validate_addresses(args))\n\t\tgoto err_exit;\n\n\tif (prog_timeout)\n\t\tptval = &timeout;\n\n\tif (args->has_grp)\n\t\tlsd = msock_server(args);\n\telse\n\t\tlsd = lsock_init(args);\n\n\tif (lsd < 0)\n\t\tgoto err_exit;\n\n\tif (args->bind_test_only) {\n\t\tclose(lsd);\n\t\tipc_write(ipc_fd, 1);\n\t\treturn 0;\n\t}\n\n\tif (args->type != SOCK_STREAM) {\n\t\tipc_write(ipc_fd, 1);\n\t\trc = msg_loop(0, lsd, (void *) addr, alen, args);\n\t\tclose(lsd);\n\t\treturn rc;\n\t}\n\n\tif (args->password && tcp_md5_remote(lsd, args)) {\n\t\tclose(lsd);\n\t\tgoto err_exit;\n\t}\n\n\tipc_write(ipc_fd, 1);\n\twhile (1) {\n\t\tlog_msg(\"waiting for client connection.\\n\");\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(lsd, &rfds);\n\n\t\trc = select(lsd+1, &rfds, NULL, NULL, ptval);\n\t\tif (rc == 0) {\n\t\t\trc = 2;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tlog_err_errno(\"select failed\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FD_ISSET(lsd, &rfds)) {\n\n\t\t\tcsd = accept(lsd, (void *) addr, &alen);\n\t\t\tif (csd < 0) {\n\t\t\t\tlog_err_errno(\"accept failed\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trc = show_sockstat(csd, args);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\n\t\t\trc = check_device(csd, args);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\trc = msg_loop(0, csd, (void *) addr, alen, args);\n\t\tclose(csd);\n\n\t\tif (!interactive)\n\t\t\tbreak;\n\t}\n\n\tclose(lsd);\n\n\treturn rc;\nerr_exit:\n\tipc_write(ipc_fd, 0);\n\treturn 1;\n}\n\nstatic int wait_for_connect(int sd)\n{\n\tstruct timeval _tv = { .tv_sec = prog_timeout }, *tv = NULL;\n\tfd_set wfd;\n\tint val = 0, sz = sizeof(val);\n\tint rc;\n\n\tFD_ZERO(&wfd);\n\tFD_SET(sd, &wfd);\n\n\tif (prog_timeout)\n\t\ttv = &_tv;\n\n\trc = select(FD_SETSIZE, NULL, &wfd, NULL, tv);\n\tif (rc == 0) {\n\t\tlog_error(\"connect timed out\\n\");\n\t\treturn -2;\n\t} else if (rc < 0) {\n\t\tlog_err_errno(\"select failed\");\n\t\treturn -3;\n\t}\n\n\tif (getsockopt(sd, SOL_SOCKET, SO_ERROR, &val, (socklen_t *)&sz) < 0) {\n\t\tlog_err_errno(\"getsockopt(SO_ERROR) failed\");\n\t\treturn -4;\n\t}\n\n\tif (val != 0) {\n\t\tlog_error(\"connect failed: %d: %s\\n\", val, strerror(val));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int connectsock(void *addr, socklen_t alen, struct sock_args *args)\n{\n\tint sd, rc = -1;\n\tlong flags;\n\n\tsd = socket(args->version, args->type, args->protocol);\n\tif (sd < 0) {\n\t\tlog_err_errno(\"Failed to create socket\");\n\t\treturn -1;\n\t}\n\n\tflags = fcntl(sd, F_GETFL);\n\tif ((flags < 0) || (fcntl(sd, F_SETFL, flags|O_NONBLOCK) < 0)) {\n\t\tlog_err_errno(\"Failed to set non-blocking option\");\n\t\tgoto err;\n\t}\n\n\tif (set_reuseport(sd) != 0)\n\t\tgoto err;\n\n\tif (set_dsfield(sd, args->version, args->dsfield) != 0)\n\t\tgoto err;\n\n\tif (args->client_dontroute && set_dontroute(sd) != 0)\n\t\tgoto err;\n\n\tif (args->dev && bind_to_device(sd, args->dev) != 0)\n\t\tgoto err;\n\telse if (args->use_setsockopt &&\n\t\t set_unicast_if(sd, args->ifindex, args->version))\n\t\tgoto err;\n\n\tif (args->has_local_ip && bind_socket(sd, args))\n\t\tgoto err;\n\n\tif (args->type != SOCK_STREAM && !args->datagram_connect)\n\t\tgoto out;\n\n\tif (args->password && tcp_md5sig(sd, addr, alen, args))\n\t\tgoto err;\n\n\tif (args->bind_test_only)\n\t\tgoto out;\n\n\tif (connect(sd, addr, alen) < 0) {\n\t\tif (errno != EINPROGRESS) {\n\t\t\tlog_err_errno(\"Failed to connect to remote host\");\n\t\t\trc = -1;\n\t\t\tgoto err;\n\t\t}\n\t\trc = wait_for_connect(sd);\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\t}\nout:\n\treturn sd;\n\nerr:\n\tclose(sd);\n\treturn rc;\n}\n\nstatic int do_client(struct sock_args *args)\n{\n\tstruct sockaddr_in sin = {\n\t\t.sin_family = AF_INET,\n\t};\n\tstruct sockaddr_in6 sin6 = {\n\t\t.sin6_family = AF_INET6,\n\t};\n\tvoid *addr;\n\tint alen;\n\tint rc = 0;\n\tint sd;\n\n\tif (!args->has_remote_ip && !args->has_grp) {\n\t\tfprintf(stderr, \"remote IP or multicast group not given\\n\");\n\t\treturn 1;\n\t}\n\n\tif (args->clientns) {\n\t\tif (switch_ns(args->clientns)) {\n\t\t\tlog_error(\"Could not set client netns to %s\\n\",\n\t\t\t\t  args->clientns);\n\t\t\treturn 1;\n\t\t}\n\t\tlog_msg(\"Switched client netns\\n\");\n\t}\n\n\targs->local_addr_str = args->client_local_addr_str;\n\tif (resolve_devices(args) || validate_addresses(args))\n\t\treturn 1;\n\n\tif ((args->use_setsockopt || args->use_cmsg) && !args->ifindex) {\n\t\tfprintf(stderr, \"Device binding not specified\\n\");\n\t\treturn 1;\n\t}\n\tif (args->use_setsockopt || args->use_cmsg)\n\t\targs->dev = NULL;\n\n\tswitch (args->version) {\n\tcase AF_INET:\n\t\tsin.sin_port = htons(args->port);\n\t\tif (args->has_grp)\n\t\t\tsin.sin_addr = args->grp;\n\t\telse\n\t\t\tsin.sin_addr = args->remote_addr.in;\n\t\taddr = &sin;\n\t\talen = sizeof(sin);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsin6.sin6_port = htons(args->port);\n\t\tsin6.sin6_addr = args->remote_addr.in6;\n\t\tsin6.sin6_scope_id = args->scope_id;\n\t\taddr = &sin6;\n\t\talen = sizeof(sin6);\n\t\tbreak;\n\t}\n\n\targs->password = args->client_pw;\n\n\tif (args->has_grp)\n\t\tsd = msock_client(args);\n\telse\n\t\tsd = connectsock(addr, alen, args);\n\n\tif (sd < 0)\n\t\treturn -sd;\n\n\tif (args->bind_test_only)\n\t\tgoto out;\n\n\tif (args->type == SOCK_STREAM) {\n\t\trc = show_sockstat(sd, args);\n\t\tif (rc != 0)\n\t\t\tgoto out;\n\t}\n\n\trc = msg_loop(1, sd, addr, alen, args);\n\nout:\n\tclose(sd);\n\n\treturn rc;\n}\n\nstatic char *random_msg(int len)\n{\n\tint i, n = 0, olen = len + 1;\n\tchar *m;\n\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tm = malloc(olen);\n\tif (!m)\n\t\treturn NULL;\n\n\twhile (len > 26) {\n\t\ti = snprintf(m + n, olen - n, \"%.26s\",\n\t\t\t     \"abcdefghijklmnopqrstuvwxyz\");\n\t\tn += i;\n\t\tlen -= i;\n\t}\n\ti = snprintf(m + n, olen - n, \"%.*s\", len,\n\t\t     \"abcdefghijklmnopqrstuvwxyz\");\n\treturn m;\n}\n\nstatic int ipc_child(int fd, struct sock_args *args)\n{\n\tchar *outbuf, *errbuf;\n\tint rc = 1;\n\n\toutbuf = malloc(4096);\n\terrbuf = malloc(4096);\n\tif (!outbuf || !errbuf) {\n\t\tfprintf(stderr, \"server: Failed to allocate buffers for stdout and stderr\\n\");\n\t\tgoto out;\n\t}\n\n\tsetbuffer(stdout, outbuf, 4096);\n\tsetbuffer(stderr, errbuf, 4096);\n\n\tserver_mode = 1;  \n\n\t \n\targs->has_expected_laddr = 0;\n\targs->has_expected_raddr = 0;\n\n\trc = do_server(args, fd);\n\nout:\n\tfree(outbuf);\n\tfree(errbuf);\n\n\treturn rc;\n}\n\nstatic int ipc_parent(int cpid, int fd, struct sock_args *args)\n{\n\tint client_status;\n\tint status;\n\tint buf;\n\n\t \n\tif (read(fd, &buf, sizeof(buf)) <= 0) {\n\t\tlog_err_errno(\"Failed to read IPC status from status\");\n\t\treturn 1;\n\t}\n\tif (!buf) {\n\t\tlog_error(\"Server failed; can not continue\\n\");\n\t\treturn 1;\n\t}\n\tlog_msg(\"Server is ready\\n\");\n\n\tclient_status = do_client(args);\n\tlog_msg(\"parent is done!\\n\");\n\n\tif (kill(cpid, 0) == 0)\n\t\tkill(cpid, SIGKILL);\n\n\twait(&status);\n\treturn client_status;\n}\n\n#define GETOPT_STR  \"sr:l:c:Q:p:t:g:P:DRn:M:X:m:d:I:BN:O:SUCi6xL:0:1:2:3:Fbqf\"\n#define OPT_FORCE_BIND_KEY_IFINDEX 1001\n#define OPT_NO_BIND_KEY_IFINDEX 1002\n#define OPT_CLIENT_DONTROUTE 1003\n#define OPT_SERVER_DONTROUTE 1004\n\nstatic struct option long_opts[] = {\n\t{\"force-bind-key-ifindex\", 0, 0, OPT_FORCE_BIND_KEY_IFINDEX},\n\t{\"no-bind-key-ifindex\", 0, 0, OPT_NO_BIND_KEY_IFINDEX},\n\t{\"client-dontroute\", 0, 0, OPT_CLIENT_DONTROUTE},\n\t{\"server-dontroute\", 0, 0, OPT_SERVER_DONTROUTE},\n\t{0, 0, 0, 0}\n};\n\nstatic void print_usage(char *prog)\n{\n\tprintf(\n\t\"usage: %s OPTS\\n\"\n\t\"Required:\\n\"\n\t\"    -r addr       remote address to connect to (client mode only)\\n\"\n\t\"    -p port       port to connect to (client mode)/listen on (server mode)\\n\"\n\t\"                  (default: %d)\\n\"\n\t\"    -s            server mode (default: client mode)\\n\"\n\t\"    -t            timeout seconds (default: none)\\n\"\n\t\"\\n\"\n\t\"Optional:\\n\"\n\t\"    -B            do both client and server via fork and IPC\\n\"\n\t\"    -N ns         set client to network namespace ns (requires root)\\n\"\n\t\"    -O ns         set server to network namespace ns (requires root)\\n\"\n\t\"    -F            Restart server loop\\n\"\n\t\"    -6            IPv6 (default is IPv4)\\n\"\n\t\"    -P proto      protocol for socket: icmp, ospf (default: none)\\n\"\n\t\"    -D|R          datagram (D) / raw (R) socket (default stream)\\n\"\n\t\"    -l addr       local address to bind to in server mode\\n\"\n\t\"    -c addr       local address to bind to in client mode\\n\"\n\t\"    -Q dsfield    DS Field value of the socket (the IP_TOS or\\n\"\n\t\"                  IPV6_TCLASS socket option)\\n\"\n\t\"    -x            configure XFRM policy on socket\\n\"\n\t\"\\n\"\n\t\"    -d dev        bind socket to given device name\\n\"\n\t\"    -I dev        bind socket to given device name - server mode\\n\"\n\t\"    -S            use setsockopt (IP_UNICAST_IF or IP_MULTICAST_IF)\\n\"\n\t\"                  to set device binding\\n\"\n\t\"    -U            Use connect() and send() for datagram sockets\\n\"\n\t\"    -f            bind socket with the IP[V6]_FREEBIND option\\n\"\n\t\"    -C            use cmsg and IP_PKTINFO to specify device binding\\n\"\n\t\"\\n\"\n\t\"    -L len        send random message of given length\\n\"\n\t\"    -n num        number of times to send message\\n\"\n\t\"\\n\"\n\t\"    -M password   use MD5 sum protection\\n\"\n\t\"    -X password   MD5 password for client mode\\n\"\n\t\"    -m prefix/len prefix and length to use for MD5 key\\n\"\n\t\"    --no-bind-key-ifindex: Force TCP_MD5SIG_FLAG_IFINDEX off\\n\"\n\t\"    --force-bind-key-ifindex: Force TCP_MD5SIG_FLAG_IFINDEX on\\n\"\n\t\"        (default: only if -I is passed)\\n\"\n\t\"    --client-dontroute: don't use gateways for client socket: send\\n\"\n\t\"                        packets only if destination is on link (see\\n\"\n\t\"                        SO_DONTROUTE in socket(7))\\n\"\n\t\"    --server-dontroute: don't use gateways for server socket: send\\n\"\n\t\"                        packets only if destination is on link (see\\n\"\n\t\"                        SO_DONTROUTE in socket(7))\\n\"\n\t\"\\n\"\n\t\"    -g grp        multicast group (e.g., 239.1.1.1)\\n\"\n\t\"    -i            interactive mode (default is echo and terminate)\\n\"\n\t\"\\n\"\n\t\"    -0 addr       Expected local address\\n\"\n\t\"    -1 addr       Expected remote address\\n\"\n\t\"    -2 dev        Expected device name (or index) to receive packet\\n\"\n\t\"    -3 dev        Expected device name (or index) to receive packets - server mode\\n\"\n\t\"\\n\"\n\t\"    -b            Bind test only.\\n\"\n\t\"    -q            Be quiet. Run test without printing anything.\\n\"\n\t, prog, DEFAULT_PORT);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct sock_args args = {\n\t\t.version = AF_INET,\n\t\t.type    = SOCK_STREAM,\n\t\t.port    = DEFAULT_PORT,\n\t};\n\tstruct protoent *pe;\n\tint both_mode = 0;\n\tunsigned int tmp;\n\tint forever = 0;\n\tint fd[2];\n\tint cpid;\n\n\t \n\textern char *optarg;\n\tint rc = 0;\n\n\t \n\n\twhile ((rc = getopt_long(argc, argv, GETOPT_STR, long_opts, NULL)) != -1) {\n\t\tswitch (rc) {\n\t\tcase 'B':\n\t\t\tboth_mode = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tserver_mode = 1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tforever = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\targs.has_local_ip = 1;\n\t\t\targs.local_addr_str = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\targs.has_remote_ip = 1;\n\t\t\targs.remote_addr_str = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\targs.has_local_ip = 1;\n\t\t\targs.client_local_addr_str = optarg;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tif (str_to_uint(optarg, 0, 255, &tmp) != 0) {\n\t\t\t\tfprintf(stderr, \"Invalid DS Field\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\targs.dsfield = tmp;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (str_to_uint(optarg, 1, 65535, &tmp) != 0) {\n\t\t\t\tfprintf(stderr, \"Invalid port\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\targs.port = (unsigned short) tmp;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (str_to_uint(optarg, 0, INT_MAX,\n\t\t\t\t\t&prog_timeout) != 0) {\n\t\t\t\tfprintf(stderr, \"Invalid timeout\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\targs.type = SOCK_DGRAM;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\targs.type = SOCK_RAW;\n\t\t\targs.port = 0;\n\t\t\tif (!args.protocol)\n\t\t\t\targs.protocol = IPPROTO_RAW;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tpe = getprotobyname(optarg);\n\t\t\tif (pe) {\n\t\t\t\targs.protocol = pe->p_proto;\n\t\t\t} else {\n\t\t\t\tif (str_to_uint(optarg, 0, 0xffff, &tmp) != 0) {\n\t\t\t\t\tfprintf(stderr, \"Invalid protocol\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\targs.protocol = tmp;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\titer = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\targs.clientns = optarg;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\targs.serverns = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tmsg = random_msg(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\targs.password = optarg;\n\t\t\tbreak;\n\t\tcase OPT_FORCE_BIND_KEY_IFINDEX:\n\t\t\targs.bind_key_ifindex = 1;\n\t\t\tbreak;\n\t\tcase OPT_NO_BIND_KEY_IFINDEX:\n\t\t\targs.bind_key_ifindex = -1;\n\t\t\tbreak;\n\t\tcase OPT_CLIENT_DONTROUTE:\n\t\t\targs.client_dontroute = 1;\n\t\t\tbreak;\n\t\tcase OPT_SERVER_DONTROUTE:\n\t\t\targs.server_dontroute = 1;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\targs.client_pw = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\targs.md5_prefix_str = optarg;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\targs.use_setsockopt = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\targs.use_freebind = 1;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\targs.use_cmsg = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\targs.dev = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\targs.server_dev = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinteractive = 1;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\targs.has_grp = 1;\n\t\t\tif (convert_addr(&args, optarg, ADDR_TYPE_MCAST) < 0)\n\t\t\t\treturn 1;\n\t\t\targs.type = SOCK_DGRAM;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\targs.version = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\targs.bind_test_only = 1;\n\t\t\tbreak;\n\t\tcase '0':\n\t\t\targs.has_expected_laddr = 1;\n\t\t\targs.expected_laddr_str = optarg;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\targs.has_expected_raddr = 1;\n\t\t\targs.expected_raddr_str = optarg;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\targs.expected_dev = optarg;\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\targs.expected_server_dev = optarg;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tquiet = 1;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\targs.use_xfrm = 1;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\targs.datagram_connect = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage(argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (args.password &&\n\t    ((!args.has_remote_ip && !args.md5_prefix_str) ||\n\t      args.type != SOCK_STREAM)) {\n\t\tlog_error(\"MD5 passwords apply to TCP only and require a remote ip for the password\\n\");\n\t\treturn 1;\n\t}\n\n\tif (args.md5_prefix_str && !args.password) {\n\t\tlog_error(\"Prefix range for MD5 protection specified without a password\\n\");\n\t\treturn 1;\n\t}\n\n\tif (iter == 0) {\n\t\tfprintf(stderr, \"Invalid number of messages to send\\n\");\n\t\treturn 1;\n\t}\n\n\tif (args.type == SOCK_STREAM && !args.protocol)\n\t\targs.protocol = IPPROTO_TCP;\n\tif (args.type == SOCK_DGRAM && !args.protocol)\n\t\targs.protocol = IPPROTO_UDP;\n\n\tif ((args.type == SOCK_STREAM || args.type == SOCK_DGRAM) &&\n\t     args.port == 0) {\n\t\tfprintf(stderr, \"Invalid port number\\n\");\n\t\treturn 1;\n\t}\n\n\tif ((both_mode || !server_mode) && !args.has_grp &&\n\t    !args.has_remote_ip && !args.has_local_ip) {\n\t\tfprintf(stderr,\n\t\t\t\"Local (server mode) or remote IP (client IP) required\\n\");\n\t\treturn 1;\n\t}\n\n\tif (interactive) {\n\t\tprog_timeout = 0;\n\t\tmsg = NULL;\n\t}\n\n\tif (both_mode) {\n\t\tif (pipe(fd) < 0) {\n\t\t\tperror(\"pipe\");\n\t\t\texit(1);\n\t\t}\n\n\t\tcpid = fork();\n\t\tif (cpid < 0) {\n\t\t\tperror(\"fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (cpid)\n\t\t\treturn ipc_parent(cpid, fd[0], &args);\n\n\t\treturn ipc_child(fd[1], &args);\n\t}\n\n\tif (server_mode) {\n\t\tdo {\n\t\t\trc = do_server(&args, -1);\n\t\t} while (forever);\n\n\t\treturn rc;\n\t}\n\treturn do_client(&args);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}