{
  "module_name": "csum.c",
  "hash_id": "b1ef6d292895e30bd1b37b518416485045b064c2c7659e31f7d8063a06a55318",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/csum.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <asm/byteorder.h>\n#include <errno.h>\n#include <error.h>\n#include <linux/filter.h>\n#include <linux/if_packet.h>\n#include <linux/ipv6.h>\n#include <linux/virtio_net.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netinet/ip6.h>\n#include <netinet/tcp.h>\n#include <netinet/udp.h>\n#include <poll.h>\n#include <sched.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"kselftest.h\"\n\nstatic bool cfg_bad_csum;\nstatic int cfg_family = PF_INET6;\nstatic int cfg_num_pkt = 4;\nstatic bool cfg_do_rx = true;\nstatic bool cfg_do_tx = true;\nstatic bool cfg_encap;\nstatic char *cfg_ifname = \"eth0\";\nstatic char *cfg_mac_dst;\nstatic char *cfg_mac_src;\nstatic int cfg_proto = IPPROTO_UDP;\nstatic int cfg_payload_char = 'a';\nstatic int cfg_payload_len = 100;\nstatic uint16_t cfg_port_dst = 34000;\nstatic uint16_t cfg_port_src = 33000;\nstatic uint16_t cfg_port_src_encap = 33001;\nstatic unsigned int cfg_random_seed;\nstatic int cfg_rcvbuf = 1 << 22;\t \nstatic bool cfg_send_pfpacket;\nstatic bool cfg_send_udp;\nstatic int cfg_timeout_ms = 2000;\nstatic bool cfg_zero_disable;  \nstatic bool cfg_zero_sum;      \n\nstatic struct sockaddr_in cfg_daddr4 = {.sin_family = AF_INET};\nstatic struct sockaddr_in cfg_saddr4 = {.sin_family = AF_INET};\nstatic struct sockaddr_in6 cfg_daddr6 = {.sin6_family = AF_INET6};\nstatic struct sockaddr_in6 cfg_saddr6 = {.sin6_family = AF_INET6};\n\n#define ENC_HEADER_LEN\t(sizeof(struct udphdr) + sizeof(struct udp_encap_hdr))\n#define MAX_HEADER_LEN\t(sizeof(struct ipv6hdr) + ENC_HEADER_LEN + sizeof(struct tcphdr))\n#define MAX_PAYLOAD_LEN 1024\n\n \nstruct udp_encap_hdr {\n\tuint8_t nexthdr;\n\tuint8_t padding[3];\n};\n\n \nstatic void *iph_addr_p;\n\nstatic unsigned long gettimeofday_ms(void)\n{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\treturn (tv.tv_sec * 1000UL) + (tv.tv_usec / 1000UL);\n}\n\nstatic uint32_t checksum_nofold(char *data, size_t len, uint32_t sum)\n{\n\tuint16_t *words = (uint16_t *)data;\n\tint i;\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tsum += words[i];\n\n\tif (len & 1)\n\t\tsum += ((unsigned char *)data)[len - 1];\n\n\treturn sum;\n}\n\nstatic uint16_t checksum_fold(void *data, size_t len, uint32_t sum)\n{\n\tsum = checksum_nofold(data, len, sum);\n\n\twhile (sum > 0xFFFF)\n\t\tsum = (sum & 0xFFFF) + (sum >> 16);\n\n\treturn ~sum;\n}\n\nstatic uint16_t checksum(void *th, uint16_t proto, size_t len)\n{\n\tuint32_t sum;\n\tint alen;\n\n\talen = cfg_family == PF_INET6 ? 32 : 8;\n\n\tsum = checksum_nofold(iph_addr_p, alen, 0);\n\tsum += htons(proto);\n\tsum += htons(len);\n\n\t \n\tif (cfg_do_tx && cfg_send_pfpacket)\n\t\treturn ~checksum_fold(NULL, 0, sum);\n\telse\n\t\treturn checksum_fold(th, len, sum);\n}\n\nstatic void *build_packet_ipv4(void *_iph, uint8_t proto, unsigned int len)\n{\n\tstruct iphdr *iph = _iph;\n\n\tmemset(iph, 0, sizeof(*iph));\n\n\tiph->version = 4;\n\tiph->ihl = 5;\n\tiph->ttl = 8;\n\tiph->protocol = proto;\n\tiph->saddr = cfg_saddr4.sin_addr.s_addr;\n\tiph->daddr = cfg_daddr4.sin_addr.s_addr;\n\tiph->tot_len = htons(sizeof(*iph) + len);\n\tiph->check = checksum_fold(iph, sizeof(*iph), 0);\n\n\tiph_addr_p = &iph->saddr;\n\n\treturn iph + 1;\n}\n\nstatic void *build_packet_ipv6(void *_ip6h, uint8_t proto, unsigned int len)\n{\n\tstruct ipv6hdr *ip6h = _ip6h;\n\n\tmemset(ip6h, 0, sizeof(*ip6h));\n\n\tip6h->version = 6;\n\tip6h->payload_len = htons(len);\n\tip6h->nexthdr = proto;\n\tip6h->hop_limit = 64;\n\tip6h->saddr = cfg_saddr6.sin6_addr;\n\tip6h->daddr = cfg_daddr6.sin6_addr;\n\n\tiph_addr_p = &ip6h->saddr;\n\n\treturn ip6h + 1;\n}\n\nstatic void *build_packet_udp(void *_uh)\n{\n\tstruct udphdr *uh = _uh;\n\n\tuh->source = htons(cfg_port_src);\n\tuh->dest = htons(cfg_port_dst);\n\tuh->len = htons(sizeof(*uh) + cfg_payload_len);\n\tuh->check = 0;\n\n\t \n\tif (cfg_zero_sum) {\n\t\tuh->source = 0;\n\t\tuh->source = checksum(uh, IPPROTO_UDP, sizeof(*uh) + cfg_payload_len);\n\n\t\tfprintf(stderr, \"tx: changing sport: %hu -> %hu\\n\",\n\t\t\tcfg_port_src, ntohs(uh->source));\n\t\tcfg_port_src = ntohs(uh->source);\n\t}\n\n\tif (cfg_zero_disable)\n\t\tuh->check = 0;\n\telse\n\t\tuh->check = checksum(uh, IPPROTO_UDP, sizeof(*uh) + cfg_payload_len);\n\n\tif (cfg_bad_csum)\n\t\tuh->check = ~uh->check;\n\n\tfprintf(stderr, \"tx: sending checksum: 0x%x\\n\", uh->check);\n\treturn uh + 1;\n}\n\nstatic void *build_packet_tcp(void *_th)\n{\n\tstruct tcphdr *th = _th;\n\n\tth->source = htons(cfg_port_src);\n\tth->dest = htons(cfg_port_dst);\n\tth->doff = 5;\n\tth->check = 0;\n\n\tth->check = checksum(th, IPPROTO_TCP, sizeof(*th) + cfg_payload_len);\n\n\tif (cfg_bad_csum)\n\t\tth->check = ~th->check;\n\n\tfprintf(stderr, \"tx: sending checksum: 0x%x\\n\", th->check);\n\treturn th + 1;\n}\n\nstatic char *build_packet_udp_encap(void *_uh)\n{\n\tstruct udphdr *uh = _uh;\n\tstruct udp_encap_hdr *eh = _uh + sizeof(*uh);\n\n\t \n\tuh->dest = htons(cfg_port_dst);\n\tuh->source = htons(cfg_port_src_encap);\n\tuh->check = 0;\n\tuh->len = htons(sizeof(*uh) +\n\t\t\tsizeof(*eh) +\n\t\t\tsizeof(struct tcphdr) +\n\t\t\tcfg_payload_len);\n\n\teh->nexthdr = IPPROTO_TCP;\n\n\treturn build_packet_tcp(eh + 1);\n}\n\nstatic char *build_packet(char *buf, int max_len, int *len)\n{\n\tuint8_t proto;\n\tchar *off;\n\tint tlen;\n\n\tif (cfg_random_seed) {\n\t\tint *buf32 = (void *)buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < (max_len / sizeof(int)); i++)\n\t\t\tbuf32[i] = rand();\n\t} else {\n\t\tmemset(buf, cfg_payload_char, max_len);\n\t}\n\n\tif (cfg_proto == IPPROTO_UDP)\n\t\ttlen = sizeof(struct udphdr) + cfg_payload_len;\n\telse\n\t\ttlen = sizeof(struct tcphdr) + cfg_payload_len;\n\n\tif (cfg_encap) {\n\t\tproto = IPPROTO_UDP;\n\t\ttlen += ENC_HEADER_LEN;\n\t} else {\n\t\tproto = cfg_proto;\n\t}\n\n\tif (cfg_family == PF_INET)\n\t\toff = build_packet_ipv4(buf, proto, tlen);\n\telse\n\t\toff = build_packet_ipv6(buf, proto, tlen);\n\n\tif (cfg_encap)\n\t\toff = build_packet_udp_encap(off);\n\telse if (cfg_proto == IPPROTO_UDP)\n\t\toff = build_packet_udp(off);\n\telse\n\t\toff = build_packet_tcp(off);\n\n\t \n\tif (cfg_send_udp) {\n\t\t*len = cfg_payload_len;\n\t\treturn off;\n\t}\n\n\t*len = off - buf + cfg_payload_len;\n\treturn buf;\n}\n\nstatic int open_inet(int ipproto, int protocol)\n{\n\tint fd;\n\n\tfd = socket(cfg_family, ipproto, protocol);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket inet\");\n\n\tif (cfg_family == PF_INET6) {\n\t\t \n\t\tcfg_saddr6.sin6_port = htons(cfg_port_src);\n\n\t\tif (bind(fd, (void *)&cfg_saddr6, sizeof(cfg_saddr6)))\n\t\t\terror(1, errno, \"bind dgram 6\");\n\t\tif (connect(fd, (void *)&cfg_daddr6, sizeof(cfg_daddr6)))\n\t\t\terror(1, errno, \"connect dgram 6\");\n\t} else {\n\t\t \n\t\tcfg_saddr4.sin_port = htons(cfg_port_src);\n\n\t\tif (bind(fd, (void *)&cfg_saddr4, sizeof(cfg_saddr4)))\n\t\t\terror(1, errno, \"bind dgram 4\");\n\t\tif (connect(fd, (void *)&cfg_daddr4, sizeof(cfg_daddr4)))\n\t\t\terror(1, errno, \"connect dgram 4\");\n\t}\n\n\treturn fd;\n}\n\nstatic int open_packet(void)\n{\n\tint fd, one = 1;\n\n\tfd = socket(PF_PACKET, SOCK_RAW, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket packet\");\n\n\tif (setsockopt(fd, SOL_PACKET, PACKET_VNET_HDR, &one, sizeof(one)))\n\t\terror(1, errno, \"setsockopt packet_vnet_ndr\");\n\n\treturn fd;\n}\n\nstatic void send_inet(int fd, const char *buf, int len)\n{\n\tint ret;\n\n\tret = write(fd, buf, len);\n\tif (ret == -1)\n\t\terror(1, errno, \"write\");\n\tif (ret != len)\n\t\terror(1, 0, \"write: %d\", ret);\n}\n\nstatic void eth_str_to_addr(const char *str, unsigned char *eth)\n{\n\tif (sscanf(str, \"%hhx:%hhx:%hhx:%hhx:%hhx:%hhx\",\n\t\t   &eth[0], &eth[1], &eth[2], &eth[3], &eth[4], &eth[5]) != 6)\n\t\terror(1, 0, \"cannot parse mac addr %s\", str);\n}\n\nstatic void send_packet(int fd, const char *buf, int len)\n{\n\tstruct virtio_net_hdr vh = {0};\n\tstruct sockaddr_ll addr = {0};\n\tstruct msghdr msg = {0};\n\tstruct ethhdr eth;\n\tstruct iovec iov[3];\n\tint ret;\n\n\taddr.sll_family = AF_PACKET;\n\taddr.sll_halen = ETH_ALEN;\n\taddr.sll_ifindex = if_nametoindex(cfg_ifname);\n\tif (!addr.sll_ifindex)\n\t\terror(1, errno, \"if_nametoindex %s\", cfg_ifname);\n\n\tvh.flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\tif (cfg_family == PF_INET6) {\n\t\tvh.csum_start = sizeof(struct ethhdr) + sizeof(struct ipv6hdr);\n\t\taddr.sll_protocol = htons(ETH_P_IPV6);\n\t} else {\n\t\tvh.csum_start = sizeof(struct ethhdr) + sizeof(struct iphdr);\n\t\taddr.sll_protocol = htons(ETH_P_IP);\n\t}\n\n\tif (cfg_encap)\n\t\tvh.csum_start += ENC_HEADER_LEN;\n\n\tif (cfg_proto == IPPROTO_TCP) {\n\t\tvh.csum_offset = __builtin_offsetof(struct tcphdr, check);\n\t\tvh.hdr_len = vh.csum_start + sizeof(struct tcphdr);\n\t} else {\n\t\tvh.csum_offset = __builtin_offsetof(struct udphdr, check);\n\t\tvh.hdr_len = vh.csum_start + sizeof(struct udphdr);\n\t}\n\n\teth_str_to_addr(cfg_mac_src, eth.h_source);\n\teth_str_to_addr(cfg_mac_dst, eth.h_dest);\n\teth.h_proto = addr.sll_protocol;\n\n\tiov[0].iov_base = &vh;\n\tiov[0].iov_len = sizeof(vh);\n\n\tiov[1].iov_base = &eth;\n\tiov[1].iov_len = sizeof(eth);\n\n\tiov[2].iov_base = (void *)buf;\n\tiov[2].iov_len = len;\n\n\tmsg.msg_iov = iov;\n\tmsg.msg_iovlen = ARRAY_SIZE(iov);\n\n\tmsg.msg_name = &addr;\n\tmsg.msg_namelen = sizeof(addr);\n\n\tret = sendmsg(fd, &msg, 0);\n\tif (ret == -1)\n\t\terror(1, errno, \"sendmsg packet\");\n\tif (ret != sizeof(vh) + sizeof(eth) + len)\n\t\terror(1, errno, \"sendmsg packet: %u\", ret);\n}\n\nstatic int recv_prepare_udp(void)\n{\n\tint fd;\n\n\tfd = socket(cfg_family, SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket r\");\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVBUF,\n\t\t       &cfg_rcvbuf, sizeof(cfg_rcvbuf)))\n\t\terror(1, errno, \"setsockopt SO_RCVBUF r\");\n\n\tif (cfg_family == PF_INET6) {\n\t\tif (bind(fd, (void *)&cfg_daddr6, sizeof(cfg_daddr6)))\n\t\t\terror(1, errno, \"bind r\");\n\t} else {\n\t\tif (bind(fd, (void *)&cfg_daddr4, sizeof(cfg_daddr4)))\n\t\t\terror(1, errno, \"bind r\");\n\t}\n\n\treturn fd;\n}\n\n \nstatic void __recv_prepare_packet_filter(int fd, int off_nexthdr, int off_dport)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD + BPF_B + BPF_ABS, SKF_AD_OFF + SKF_AD_PKTTYPE),\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, PACKET_HOST, 0, 4),\n\t\tBPF_STMT(BPF_LD + BPF_B + BPF_ABS, off_nexthdr),\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, cfg_encap ? IPPROTO_UDP : cfg_proto, 0, 2),\n\t\tBPF_STMT(BPF_LD + BPF_H + BPF_ABS, off_dport),\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, cfg_port_dst, 1, 0),\n\t\tBPF_STMT(BPF_RET + BPF_K, 0),\n\t\tBPF_STMT(BPF_RET + BPF_K, 0xFFFF),\n\t};\n\tstruct sock_fprog prog = {};\n\n\tprog.filter = filter;\n\tprog.len = ARRAY_SIZE(filter);\n\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, &prog, sizeof(prog)))\n\t\terror(1, errno, \"setsockopt filter\");\n}\n\nstatic void recv_prepare_packet_filter(int fd)\n{\n\tconst int off_dport = offsetof(struct tcphdr, dest);  \n\n\tif (cfg_family == AF_INET)\n\t\t__recv_prepare_packet_filter(fd, offsetof(struct iphdr, protocol),\n\t\t\t\t\t     sizeof(struct iphdr) + off_dport);\n\telse\n\t\t__recv_prepare_packet_filter(fd, offsetof(struct ipv6hdr, nexthdr),\n\t\t\t\t\t     sizeof(struct ipv6hdr) + off_dport);\n}\n\nstatic void recv_prepare_packet_bind(int fd)\n{\n\tstruct sockaddr_ll laddr = {0};\n\n\tladdr.sll_family = AF_PACKET;\n\n\tif (cfg_family == PF_INET)\n\t\tladdr.sll_protocol = htons(ETH_P_IP);\n\telse\n\t\tladdr.sll_protocol = htons(ETH_P_IPV6);\n\n\tladdr.sll_ifindex = if_nametoindex(cfg_ifname);\n\tif (!laddr.sll_ifindex)\n\t\terror(1, 0, \"if_nametoindex %s\", cfg_ifname);\n\n\tif (bind(fd, (void *)&laddr, sizeof(laddr)))\n\t\terror(1, errno, \"bind pf_packet\");\n}\n\nstatic int recv_prepare_packet(void)\n{\n\tint fd, one = 1;\n\n\tfd = socket(PF_PACKET, SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket p\");\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVBUF,\n\t\t       &cfg_rcvbuf, sizeof(cfg_rcvbuf)))\n\t\terror(1, errno, \"setsockopt SO_RCVBUF p\");\n\n\t \n\tif (setsockopt(fd, SOL_PACKET, PACKET_AUXDATA, &one, sizeof(one)))\n\t\terror(1, errno, \"setsockopt auxdata\");\n\n\t \n\trecv_prepare_packet_filter(fd);\n\n\t \n\trecv_prepare_packet_bind(fd);\n\n\treturn fd;\n}\n\nstatic int recv_udp(int fd)\n{\n\tstatic char buf[MAX_PAYLOAD_LEN];\n\tint ret, count = 0;\n\n\twhile (1) {\n\t\tret = recv(fd, buf, sizeof(buf), MSG_DONTWAIT);\n\t\tif (ret == -1 && errno == EAGAIN)\n\t\t\tbreak;\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"recv r\");\n\n\t\tfprintf(stderr, \"rx: udp: len=%u\\n\", ret);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic int recv_verify_csum(void *th, int len, uint16_t sport, uint16_t csum_field)\n{\n\tuint16_t csum;\n\n\tcsum = checksum(th, cfg_proto, len);\n\n\tfprintf(stderr, \"rx: pkt: sport=%hu len=%u csum=0x%hx verify=0x%hx\\n\",\n\t\tsport, len, csum_field, csum);\n\n\t \n\tif (csum && !cfg_bad_csum) {\n\t\tfprintf(stderr, \"pkt: bad csum\\n\");\n\t\treturn 1;\n\t} else if (cfg_bad_csum && !csum) {\n\t\tfprintf(stderr, \"pkt: good csum, while bad expected\\n\");\n\t\treturn 1;\n\t}\n\n\tif (cfg_zero_sum && csum_field != 0xFFFF) {\n\t\tfprintf(stderr, \"pkt: zero csum: field should be 0xFFFF, is 0x%hx\\n\", csum_field);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int recv_verify_packet_tcp(void *th, int len)\n{\n\tstruct tcphdr *tcph = th;\n\n\tif (len < sizeof(*tcph) || tcph->dest != htons(cfg_port_dst))\n\t\treturn -1;\n\n\treturn recv_verify_csum(th, len, ntohs(tcph->source), tcph->check);\n}\n\nstatic int recv_verify_packet_udp_encap(void *th, int len)\n{\n\tstruct udp_encap_hdr *eh = th;\n\n\tif (len < sizeof(*eh) || eh->nexthdr != IPPROTO_TCP)\n\t\treturn -1;\n\n\treturn recv_verify_packet_tcp(eh + 1, len - sizeof(*eh));\n}\n\nstatic int recv_verify_packet_udp(void *th, int len)\n{\n\tstruct udphdr *udph = th;\n\n\tif (len < sizeof(*udph))\n\t\treturn -1;\n\n\tif (udph->dest != htons(cfg_port_dst))\n\t\treturn -1;\n\n\tif (udph->source == htons(cfg_port_src_encap))\n\t\treturn recv_verify_packet_udp_encap(udph + 1,\n\t\t\t\t\t\t    len - sizeof(*udph));\n\n\treturn recv_verify_csum(th, len, ntohs(udph->source), udph->check);\n}\n\nstatic int recv_verify_packet_ipv4(void *nh, int len)\n{\n\tstruct iphdr *iph = nh;\n\tuint16_t proto = cfg_encap ? IPPROTO_UDP : cfg_proto;\n\n\tif (len < sizeof(*iph) || iph->protocol != proto)\n\t\treturn -1;\n\n\tiph_addr_p = &iph->saddr;\n\tif (proto == IPPROTO_TCP)\n\t\treturn recv_verify_packet_tcp(iph + 1, len - sizeof(*iph));\n\telse\n\t\treturn recv_verify_packet_udp(iph + 1, len - sizeof(*iph));\n}\n\nstatic int recv_verify_packet_ipv6(void *nh, int len)\n{\n\tstruct ipv6hdr *ip6h = nh;\n\tuint16_t proto = cfg_encap ? IPPROTO_UDP : cfg_proto;\n\n\tif (len < sizeof(*ip6h) || ip6h->nexthdr != proto)\n\t\treturn -1;\n\n\tiph_addr_p = &ip6h->saddr;\n\n\tif (proto == IPPROTO_TCP)\n\t\treturn recv_verify_packet_tcp(ip6h + 1, len - sizeof(*ip6h));\n\telse\n\t\treturn recv_verify_packet_udp(ip6h + 1, len - sizeof(*ip6h));\n}\n\n \nstatic bool recv_verify_packet_csum(struct msghdr *msg)\n{\n\tstruct tpacket_auxdata *aux = NULL;\n\tstruct cmsghdr *cm;\n\n\tif (msg->msg_flags & MSG_CTRUNC)\n\t\terror(1, 0, \"cmsg: truncated\");\n\n\tfor (cm = CMSG_FIRSTHDR(msg); cm; cm = CMSG_NXTHDR(msg, cm)) {\n\t\tif (cm->cmsg_level != SOL_PACKET ||\n\t\t    cm->cmsg_type != PACKET_AUXDATA)\n\t\t\terror(1, 0, \"cmsg: level=%d type=%d\\n\",\n\t\t\t      cm->cmsg_level, cm->cmsg_type);\n\n\t\tif (cm->cmsg_len != CMSG_LEN(sizeof(struct tpacket_auxdata)))\n\t\t\terror(1, 0, \"cmsg: len=%lu expected=%lu\",\n\t\t\t      cm->cmsg_len, CMSG_LEN(sizeof(struct tpacket_auxdata)));\n\n\t\taux = (void *)CMSG_DATA(cm);\n\t}\n\n\tif (!aux)\n\t\terror(1, 0, \"cmsg: no auxdata\");\n\n\treturn aux->tp_status & TP_STATUS_CSUM_VALID;\n}\n\nstatic int recv_packet(int fd)\n{\n\tstatic char _buf[MAX_HEADER_LEN + MAX_PAYLOAD_LEN];\n\tunsigned long total = 0, bad_csums = 0, bad_validations = 0;\n\tchar ctrl[CMSG_SPACE(sizeof(struct tpacket_auxdata))];\n\tstruct pkt *buf = (void *)_buf;\n\tstruct msghdr msg = {0};\n\tstruct iovec iov;\n\tint len, ret;\n\n\tiov.iov_base = _buf;\n\tiov.iov_len = sizeof(_buf);\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tmsg.msg_control = ctrl;\n\tmsg.msg_controllen = sizeof(ctrl);\n\n\twhile (1) {\n\t\tmsg.msg_flags = 0;\n\n\t\tlen = recvmsg(fd, &msg, MSG_DONTWAIT);\n\t\tif (len == -1 && errno == EAGAIN)\n\t\t\tbreak;\n\t\tif (len == -1)\n\t\t\terror(1, errno, \"recv p\");\n\n\t\tif (cfg_family == PF_INET6)\n\t\t\tret = recv_verify_packet_ipv6(buf, len);\n\t\telse\n\t\t\tret = recv_verify_packet_ipv4(buf, len);\n\n\t\tif (ret == -1  )\n\t\t\tcontinue;\n\n\t\ttotal++;\n\t\tif (ret == 1)\n\t\t\tbad_csums++;\n\n\t\t \n\t\tif (recv_verify_packet_csum(&msg) && cfg_bad_csum) {\n\t\t\tfprintf(stderr, \"cmsg: expected bad csum, pf_packet returns valid\\n\");\n\t\t\tbad_validations++;\n\t\t}\n\t}\n\n\tif (bad_csums || bad_validations)\n\t\terror(1, 0, \"rx: errors at pf_packet: total=%lu bad_csums=%lu bad_valids=%lu\\n\",\n\t\t      total, bad_csums, bad_validations);\n\n\treturn total;\n}\n\nstatic void parse_args(int argc, char *const argv[])\n{\n\tconst char *daddr = NULL, *saddr = NULL;\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"46d:D:eEi:l:L:n:r:PRs:S:tTuUzZ\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tcfg_family = PF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tcfg_family = PF_INET6;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcfg_mac_dst = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdaddr = optarg;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcfg_encap = true;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tcfg_bad_csum = true;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcfg_ifname = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tcfg_payload_len = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tcfg_timeout_ms = strtol(optarg, NULL, 0) * 1000;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcfg_num_pkt = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcfg_random_seed = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcfg_send_pfpacket = true;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\t \n\t\t\tcfg_do_tx = false;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcfg_mac_src = optarg;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsaddr = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_proto = IPPROTO_TCP;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\t \n\t\t\tcfg_do_rx = false;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tcfg_proto = IPPROTO_UDP;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\t \n\t\t\tcfg_send_udp = true;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tcfg_zero_disable = true;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tcfg_zero_sum = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"unknown arg %c\", c);\n\t\t}\n\t}\n\n\tif (!daddr || !saddr)\n\t\terror(1, 0, \"Must pass -D <daddr> and -S <saddr>\");\n\n\tif (cfg_do_tx && cfg_send_pfpacket && (!cfg_mac_src || !cfg_mac_dst))\n\t\terror(1, 0, \"Transmit with pf_packet requires mac addresses\");\n\n\tif (cfg_payload_len > MAX_PAYLOAD_LEN)\n\t\terror(1, 0, \"Payload length exceeds max\");\n\n\tif (cfg_proto != IPPROTO_UDP && (cfg_zero_sum || cfg_zero_disable))\n\t\terror(1, 0, \"Only UDP supports zero csum\");\n\n\tif (cfg_zero_sum && !cfg_send_udp)\n\t\terror(1, 0, \"Zero checksum conversion requires -U for tx csum offload\");\n\tif (cfg_zero_sum && cfg_bad_csum)\n\t\terror(1, 0, \"Cannot combine zero checksum conversion and invalid checksum\");\n\tif (cfg_zero_sum && cfg_random_seed)\n\t\terror(1, 0, \"Cannot combine zero checksum conversion with randomization\");\n\n\tif (cfg_family == PF_INET6) {\n\t\tcfg_saddr6.sin6_port = htons(cfg_port_src);\n\t\tcfg_daddr6.sin6_port = htons(cfg_port_dst);\n\n\t\tif (inet_pton(cfg_family, daddr, &cfg_daddr6.sin6_addr) != 1)\n\t\t\terror(1, errno, \"Cannot parse ipv6 -D\");\n\t\tif (inet_pton(cfg_family, saddr, &cfg_saddr6.sin6_addr) != 1)\n\t\t\terror(1, errno, \"Cannot parse ipv6 -S\");\n\t} else {\n\t\tcfg_saddr4.sin_port = htons(cfg_port_src);\n\t\tcfg_daddr4.sin_port = htons(cfg_port_dst);\n\n\t\tif (inet_pton(cfg_family, daddr, &cfg_daddr4.sin_addr) != 1)\n\t\t\terror(1, errno, \"Cannot parse ipv4 -D\");\n\t\tif (inet_pton(cfg_family, saddr, &cfg_saddr4.sin_addr) != 1)\n\t\t\terror(1, errno, \"Cannot parse ipv4 -S\");\n\t}\n\n\tif (cfg_do_tx && cfg_random_seed) {\n\t\t \n\t\tif (cfg_random_seed == 1)\n\t\t\tcfg_random_seed = (unsigned int)gettimeofday_ms();\n\t\tsrand(cfg_random_seed);\n\t\tfprintf(stderr, \"randomization seed: %u\\n\", cfg_random_seed);\n\t}\n}\n\nstatic void do_tx(void)\n{\n\tstatic char _buf[MAX_HEADER_LEN + MAX_PAYLOAD_LEN];\n\tchar *buf;\n\tint fd, len, i;\n\n\tbuf = build_packet(_buf, sizeof(_buf), &len);\n\n\tif (cfg_send_pfpacket)\n\t\tfd = open_packet();\n\telse if (cfg_send_udp)\n\t\tfd = open_inet(SOCK_DGRAM, 0);\n\telse\n\t\tfd = open_inet(SOCK_RAW, IPPROTO_RAW);\n\n\tfor (i = 0; i < cfg_num_pkt; i++) {\n\t\tif (cfg_send_pfpacket)\n\t\t\tsend_packet(fd, buf, len);\n\t\telse\n\t\t\tsend_inet(fd, buf, len);\n\n\t\t \n\t\tif (cfg_random_seed) {\n\t\t\tcfg_payload_len = rand() % MAX_PAYLOAD_LEN;\n\t\t\tbuf = build_packet(_buf, sizeof(_buf), &len);\n\t\t}\n\t}\n\n\tif (close(fd))\n\t\terror(1, errno, \"close tx\");\n}\n\nstatic void do_rx(int fdp, int fdr)\n{\n\tunsigned long count_udp = 0, count_pkt = 0;\n\tlong tleft, tstop;\n\tstruct pollfd pfd;\n\n\ttstop = gettimeofday_ms() + cfg_timeout_ms;\n\ttleft = cfg_timeout_ms;\n\n\tdo {\n\t\tpfd.events = POLLIN;\n\t\tpfd.fd = fdp;\n\t\tif (poll(&pfd, 1, tleft) == -1)\n\t\t\terror(1, errno, \"poll\");\n\n\t\tif (pfd.revents & POLLIN)\n\t\t\tcount_pkt += recv_packet(fdp);\n\n\t\tif (cfg_proto == IPPROTO_UDP)\n\t\t\tcount_udp += recv_udp(fdr);\n\n\t\ttleft = tstop - gettimeofday_ms();\n\t} while (tleft > 0);\n\n\tif (close(fdr))\n\t\terror(1, errno, \"close r\");\n\tif (close(fdp))\n\t\terror(1, errno, \"close p\");\n\n\tif (count_pkt < cfg_num_pkt)\n\t\terror(1, 0, \"rx: missing packets at pf_packet: %lu < %u\",\n\t\t      count_pkt, cfg_num_pkt);\n\n\tif (cfg_proto == IPPROTO_UDP) {\n\t\tif (cfg_bad_csum && count_udp)\n\t\t\terror(1, 0, \"rx: unexpected packets at udp\");\n\t\tif (!cfg_bad_csum && !count_udp)\n\t\t\terror(1, 0, \"rx: missing packets at udp\");\n\t}\n}\n\nint main(int argc, char *const argv[])\n{\n\tint fdp = -1, fdr = -1;\t\t \n\n\tparse_args(argc, argv);\n\n\t \n\tif (cfg_do_rx) {\n\t\tfdp = recv_prepare_packet();\n\t\tfdr = recv_prepare_udp();\n\t}\n\n\tif (cfg_do_tx)\n\t\tdo_tx();\n\n\tif (cfg_do_rx)\n\t\tdo_rx(fdp, fdr);\n\n\tfprintf(stderr, \"OK\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}