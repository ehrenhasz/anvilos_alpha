{
  "module_name": "vrf_route_leaking.sh",
  "hash_id": "e800fa62937cba1f830b21a5309a44c9b3035773ea8c31572df91ca496761616",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/vrf_route_leaking.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright (c) 2019 David Ahern <dsahern@gmail.com>. All rights reserved.\n# Copyright (c) 2020 Michael Jeanson <mjeanson@efficios.com>. All rights reserved.\n#\n# Requires CONFIG_NET_VRF, CONFIG_VETH, CONFIG_BRIDGE and CONFIG_NET_NS.\n#\n#\n# Symmetric routing topology\n#\n#                     blue         red\n# +----+              .253 +----+ .253              +----+\n# | h1 |-------------------| r1 |-------------------| h2 |\n# +----+ .1                +----+                .2 +----+\n#         172.16.1/24                  172.16.2/24\n#    2001:db8:16:1/64                  2001:db8:16:2/64\n#\n#\n# Route from h1 to h2 and back goes through r1, incoming vrf blue has a route\n# to the outgoing vrf red for the n2 network and red has a route back to n1.\n# The red VRF interface has a MTU of 1400.\n#\n# The first test sends a ping with a ttl of 1 from h1 to h2 and parses the\n# output of the command to check that a ttl expired error is received.\n#\n# The second test runs traceroute from h1 to h2 and parses the output to check\n# for a hop on r1.\n#\n# The third test sends a ping with a packet size of 1450 from h1 to h2 and\n# parses the output of the command to check that a fragmentation error is\n# received.\n#\n#\n# Asymmetric routing topology\n#\n# This topology represents a customer setup where the issue with icmp errors\n# and VRF route leaking was initialy reported. The MTU test isn't done here\n# because of the lack of a return route in the red VRF.\n#\n#                     blue         red\n#                     .253 +----+ .253\n#                     +----| r1 |----+\n#                     |    +----+    |\n# +----+              |              |              +----+\n# | h1 |--------------+              +--------------| h2 |\n# +----+ .1           |              |           .2 +----+\n#         172.16.1/24 |    +----+    | 172.16.2/24\n#    2001:db8:16:1/64 +----| r2 |----+ 2001:db8:16:2/64\n#                     .254 +----+ .254\n#\n#\n# Route from h1 to h2 goes through r1, incoming vrf blue has a route to the\n# outgoing vrf red for the n2 network but red doesn't have a route back to n1.\n# Route from h2 to h1 goes through r2.\n#\n# The objective is to check that the incoming vrf routing table is selected\n# to send an ICMP error back to the source when the ttl of a packet reaches 1\n# while it is forwarded between different vrfs.\n\nVERBOSE=0\nPAUSE_ON_FAIL=no\nDEFAULT_TTYPE=sym\n\nH1_N1=172.16.1.0/24\nH1_N1_6=2001:db8:16:1::/64\n\nH1_N1_IP=172.16.1.1\nR1_N1_IP=172.16.1.253\nR2_N1_IP=172.16.1.254\n\nH1_N1_IP6=2001:db8:16:1::1\nR1_N1_IP6=2001:db8:16:1::253\nR2_N1_IP6=2001:db8:16:1::254\n\nH2_N2=172.16.2.0/24\nH2_N2_6=2001:db8:16:2::/64\n\nH2_N2_IP=172.16.2.2\nR1_N2_IP=172.16.2.253\nR2_N2_IP=172.16.2.254\n\nH2_N2_IP6=2001:db8:16:2::2\nR1_N2_IP6=2001:db8:16:2::253\nR2_N2_IP6=2001:db8:16:2::254\n\n################################################################################\n# helpers\n\nlog_section()\n{\n\techo\n\techo \"###########################################################################\"\n\techo \"$*\"\n\techo \"###########################################################################\"\n\techo\n}\n\nlog_test()\n{\n\tlocal rc=$1\n\tlocal expected=$2\n\tlocal msg=\"$3\"\n\n\tif [ \"${rc}\" -eq \"${expected}\" ]; then\n\t\tprintf \"TEST: %-60s  [ OK ]\\n\" \"${msg}\"\n\t\tnsuccess=$((nsuccess+1))\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"TEST: %-60s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread -r a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n}\n\nrun_cmd()\n{\n\tlocal cmd=\"$*\"\n\tlocal out\n\tlocal rc\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo \"COMMAND: $cmd\"\n\tfi\n\n\t# shellcheck disable=SC2086\n\tout=$(eval $cmd 2>&1)\n\trc=$?\n\tif [ \"$VERBOSE\" = \"1\" ] && [ -n \"$out\" ]; then\n\t\techo \"$out\"\n\tfi\n\n\t[ \"$VERBOSE\" = \"1\" ] && echo\n\n\treturn $rc\n}\n\nrun_cmd_grep()\n{\n\tlocal grep_pattern=\"$1\"\n\tshift\n\tlocal cmd=\"$*\"\n\tlocal out\n\tlocal rc\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo \"COMMAND: $cmd\"\n\tfi\n\n\t# shellcheck disable=SC2086\n\tout=$(eval $cmd 2>&1)\n\tif [ \"$VERBOSE\" = \"1\" ] && [ -n \"$out\" ]; then\n\t\techo \"$out\"\n\tfi\n\n\techo \"$out\" | grep -q \"$grep_pattern\"\n\trc=$?\n\n\t[ \"$VERBOSE\" = \"1\" ] && echo\n\n\treturn $rc\n}\n\n################################################################################\n# setup and teardown\n\ncleanup()\n{\n\tlocal ns\n\n\tfor ns in h1 h2 r1 r2; do\n\t\tip netns del $ns 2>/dev/null\n\tdone\n}\n\nsetup_vrf()\n{\n\tlocal ns=$1\n\n\tip -netns \"${ns}\" rule del pref 0\n\tip -netns \"${ns}\" rule add pref 32765 from all lookup local\n\tip -netns \"${ns}\" -6 rule del pref 0\n\tip -netns \"${ns}\" -6 rule add pref 32765 from all lookup local\n}\n\ncreate_vrf()\n{\n\tlocal ns=$1\n\tlocal vrf=$2\n\tlocal table=$3\n\n\tip -netns \"${ns}\" link add \"${vrf}\" type vrf table \"${table}\"\n\tip -netns \"${ns}\" link set \"${vrf}\" up\n\tip -netns \"${ns}\" route add vrf \"${vrf}\" unreachable default metric 8192\n\tip -netns \"${ns}\" -6 route add vrf \"${vrf}\" unreachable default metric 8192\n\n\tip -netns \"${ns}\" addr add 127.0.0.1/8 dev \"${vrf}\"\n\tip -netns \"${ns}\" -6 addr add ::1 dev \"${vrf}\" nodad\n}\n\nsetup_sym()\n{\n\tlocal ns\n\n\t# make sure we are starting with a clean slate\n\tcleanup\n\n\t#\n\t# create nodes as namespaces\n\t#\n\tfor ns in h1 h2 r1; do\n\t\tip netns add $ns\n\t\tip -netns $ns link set lo up\n\n\t\tcase \"${ns}\" in\n\t\th[12]) ip netns exec $ns sysctl -q -w net.ipv6.conf.all.forwarding=0\n\t\t       ip netns exec $ns sysctl -q -w net.ipv6.conf.all.keep_addr_on_down=1\n\t\t\t;;\n\t\tr1)    ip netns exec $ns sysctl -q -w net.ipv4.ip_forward=1\n\t\t       ip netns exec $ns sysctl -q -w net.ipv6.conf.all.forwarding=1\n\t\tesac\n\tdone\n\n\t#\n\t# create interconnects\n\t#\n\tip -netns h1 link add eth0 type veth peer name r1h1\n\tip -netns h1 link set r1h1 netns r1 name eth0 up\n\n\tip -netns h2 link add eth0 type veth peer name r1h2\n\tip -netns h2 link set r1h2 netns r1 name eth1 up\n\n\t#\n\t# h1\n\t#\n\tip -netns h1 addr add dev eth0 ${H1_N1_IP}/24\n\tip -netns h1 -6 addr add dev eth0 ${H1_N1_IP6}/64 nodad\n\tip -netns h1 link set eth0 up\n\n\t# h1 to h2 via r1\n\tip -netns h1    route add ${H2_N2} via ${R1_N1_IP} dev eth0\n\tip -netns h1 -6 route add ${H2_N2_6} via \"${R1_N1_IP6}\" dev eth0\n\n\t#\n\t# h2\n\t#\n\tip -netns h2 addr add dev eth0 ${H2_N2_IP}/24\n\tip -netns h2 -6 addr add dev eth0 ${H2_N2_IP6}/64 nodad\n\tip -netns h2 link set eth0 up\n\n\t# h2 to h1 via r1\n\tip -netns h2 route add default via ${R1_N2_IP} dev eth0\n\tip -netns h2 -6 route add default via ${R1_N2_IP6} dev eth0\n\n\t#\n\t# r1\n\t#\n\tsetup_vrf r1\n\tcreate_vrf r1 blue 1101\n\tcreate_vrf r1 red 1102\n\tip -netns r1 link set mtu 1400 dev eth1\n\tip -netns r1 link set eth0 vrf blue up\n\tip -netns r1 link set eth1 vrf red up\n\tip -netns r1 addr add dev eth0 ${R1_N1_IP}/24\n\tip -netns r1 -6 addr add dev eth0 ${R1_N1_IP6}/64 nodad\n\tip -netns r1 addr add dev eth1 ${R1_N2_IP}/24\n\tip -netns r1 -6 addr add dev eth1 ${R1_N2_IP6}/64 nodad\n\n\t# Route leak from blue to red\n\tip -netns r1 route add vrf blue ${H2_N2} dev red\n\tip -netns r1 -6 route add vrf blue ${H2_N2_6} dev red\n\n\t# Route leak from red to blue\n\tip -netns r1 route add vrf red ${H1_N1} dev blue\n\tip -netns r1 -6 route add vrf red ${H1_N1_6} dev blue\n\n\n\t# Wait for ip config to settle\n\tsleep 2\n}\n\nsetup_asym()\n{\n\tlocal ns\n\n\t# make sure we are starting with a clean slate\n\tcleanup\n\n\t#\n\t# create nodes as namespaces\n\t#\n\tfor ns in h1 h2 r1 r2; do\n\t\tip netns add $ns\n\t\tip -netns $ns link set lo up\n\n\t\tcase \"${ns}\" in\n\t\th[12]) ip netns exec $ns sysctl -q -w net.ipv6.conf.all.forwarding=0\n\t\t       ip netns exec $ns sysctl -q -w net.ipv6.conf.all.keep_addr_on_down=1\n\t\t\t;;\n\t\tr[12]) ip netns exec $ns sysctl -q -w net.ipv4.ip_forward=1\n\t\t       ip netns exec $ns sysctl -q -w net.ipv6.conf.all.forwarding=1\n\t\tesac\n\tdone\n\n\t#\n\t# create interconnects\n\t#\n\tip -netns h1 link add eth0 type veth peer name r1h1\n\tip -netns h1 link set r1h1 netns r1 name eth0 up\n\n\tip -netns h1 link add eth1 type veth peer name r2h1\n\tip -netns h1 link set r2h1 netns r2 name eth0 up\n\n\tip -netns h2 link add eth0 type veth peer name r1h2\n\tip -netns h2 link set r1h2 netns r1 name eth1 up\n\n\tip -netns h2 link add eth1 type veth peer name r2h2\n\tip -netns h2 link set r2h2 netns r2 name eth1 up\n\n\t#\n\t# h1\n\t#\n\tip -netns h1 link add br0 type bridge\n\tip -netns h1 link set br0 up\n\tip -netns h1 addr add dev br0 ${H1_N1_IP}/24\n\tip -netns h1 -6 addr add dev br0 ${H1_N1_IP6}/64 nodad\n\tip -netns h1 link set eth0 master br0 up\n\tip -netns h1 link set eth1 master br0 up\n\n\t# h1 to h2 via r1\n\tip -netns h1    route add ${H2_N2} via ${R1_N1_IP} dev br0\n\tip -netns h1 -6 route add ${H2_N2_6} via \"${R1_N1_IP6}\" dev br0\n\n\t#\n\t# h2\n\t#\n\tip -netns h2 link add br0 type bridge\n\tip -netns h2 link set br0 up\n\tip -netns h2 addr add dev br0 ${H2_N2_IP}/24\n\tip -netns h2 -6 addr add dev br0 ${H2_N2_IP6}/64 nodad\n\tip -netns h2 link set eth0 master br0 up\n\tip -netns h2 link set eth1 master br0 up\n\n\t# h2 to h1 via r2\n\tip -netns h2 route add default via ${R2_N2_IP} dev br0\n\tip -netns h2 -6 route add default via ${R2_N2_IP6} dev br0\n\n\t#\n\t# r1\n\t#\n\tsetup_vrf r1\n\tcreate_vrf r1 blue 1101\n\tcreate_vrf r1 red 1102\n\tip -netns r1 link set mtu 1400 dev eth1\n\tip -netns r1 link set eth0 vrf blue up\n\tip -netns r1 link set eth1 vrf red up\n\tip -netns r1 addr add dev eth0 ${R1_N1_IP}/24\n\tip -netns r1 -6 addr add dev eth0 ${R1_N1_IP6}/64 nodad\n\tip -netns r1 addr add dev eth1 ${R1_N2_IP}/24\n\tip -netns r1 -6 addr add dev eth1 ${R1_N2_IP6}/64 nodad\n\n\t# Route leak from blue to red\n\tip -netns r1 route add vrf blue ${H2_N2} dev red\n\tip -netns r1 -6 route add vrf blue ${H2_N2_6} dev red\n\n\t# No route leak from red to blue\n\n\t#\n\t# r2\n\t#\n\tip -netns r2 addr add dev eth0 ${R2_N1_IP}/24\n\tip -netns r2 -6 addr add dev eth0 ${R2_N1_IP6}/64 nodad\n\tip -netns r2 addr add dev eth1 ${R2_N2_IP}/24\n\tip -netns r2 -6 addr add dev eth1 ${R2_N2_IP6}/64 nodad\n\n\t# Wait for ip config to settle\n\tsleep 2\n}\n\ncheck_connectivity()\n{\n\tip netns exec h1 ping -c1 -w1 ${H2_N2_IP} >/dev/null 2>&1\n\tlog_test $? 0 \"Basic IPv4 connectivity\"\n\treturn $?\n}\n\ncheck_connectivity6()\n{\n\tip netns exec h1 \"${ping6}\" -c1 -w1 ${H2_N2_IP6} >/dev/null 2>&1\n\tlog_test $? 0 \"Basic IPv6 connectivity\"\n\treturn $?\n}\n\ncheck_traceroute()\n{\n\tif [ ! -x \"$(command -v traceroute)\" ]; then\n\t\techo \"SKIP: Could not run IPV4 test without traceroute\"\n\t\treturn 1\n\tfi\n}\n\ncheck_traceroute6()\n{\n\tif [ ! -x \"$(command -v traceroute6)\" ]; then\n\t\techo \"SKIP: Could not run IPV6 test without traceroute6\"\n\t\treturn 1\n\tfi\n}\n\nipv4_traceroute()\n{\n\tlocal ttype=\"$1\"\n\n\t[ \"x$ttype\" = \"x\" ] && ttype=\"$DEFAULT_TTYPE\"\n\n\tlog_section \"IPv4 ($ttype route): VRF ICMP error route lookup traceroute\"\n\n\tcheck_traceroute || return\n\n\tsetup_\"$ttype\"\n\n\tcheck_connectivity || return\n\n\trun_cmd_grep \"${R1_N1_IP}\" ip netns exec h1 traceroute ${H2_N2_IP}\n\tlog_test $? 0 \"Traceroute reports a hop on r1\"\n}\n\nipv4_traceroute_asym()\n{\n\tipv4_traceroute asym\n}\n\nipv6_traceroute()\n{\n\tlocal ttype=\"$1\"\n\n\t[ \"x$ttype\" = \"x\" ] && ttype=\"$DEFAULT_TTYPE\"\n\n\tlog_section \"IPv6 ($ttype route): VRF ICMP error route lookup traceroute\"\n\n\tcheck_traceroute6 || return\n\n\tsetup_\"$ttype\"\n\n\tcheck_connectivity6 || return\n\n\trun_cmd_grep \"${R1_N1_IP6}\" ip netns exec h1 traceroute6 ${H2_N2_IP6}\n\tlog_test $? 0 \"Traceroute6 reports a hop on r1\"\n}\n\nipv6_traceroute_asym()\n{\n\tipv6_traceroute asym\n}\n\nipv4_ping_ttl()\n{\n\tlocal ttype=\"$1\"\n\n\t[ \"x$ttype\" = \"x\" ] && ttype=\"$DEFAULT_TTYPE\"\n\n\tlog_section \"IPv4 ($ttype route): VRF ICMP ttl error route lookup ping\"\n\n\tsetup_\"$ttype\"\n\n\tcheck_connectivity || return\n\n\trun_cmd_grep \"Time to live exceeded\" ip netns exec h1 ping -t1 -c1 -W2 ${H2_N2_IP}\n\tlog_test $? 0 \"Ping received ICMP ttl exceeded\"\n}\n\nipv4_ping_ttl_asym()\n{\n\tipv4_ping_ttl asym\n}\n\nipv4_ping_frag()\n{\n\tlocal ttype=\"$1\"\n\n\t[ \"x$ttype\" = \"x\" ] && ttype=\"$DEFAULT_TTYPE\"\n\n\tlog_section \"IPv4 ($ttype route): VRF ICMP fragmentation error route lookup ping\"\n\n\tsetup_\"$ttype\"\n\n\tcheck_connectivity || return\n\n\trun_cmd_grep \"Frag needed\" ip netns exec h1 ping -s 1450 -Mdo -c1 -W2 ${H2_N2_IP}\n\tlog_test $? 0 \"Ping received ICMP Frag needed\"\n}\n\nipv4_ping_frag_asym()\n{\n\tipv4_ping_frag asym\n}\n\nipv6_ping_ttl()\n{\n\tlocal ttype=\"$1\"\n\n\t[ \"x$ttype\" = \"x\" ] && ttype=\"$DEFAULT_TTYPE\"\n\n\tlog_section \"IPv6 ($ttype route): VRF ICMP ttl error route lookup ping\"\n\n\tsetup_\"$ttype\"\n\n\tcheck_connectivity6 || return\n\n\trun_cmd_grep \"Time exceeded: Hop limit\" ip netns exec h1 \"${ping6}\" -t1 -c1 -W2 ${H2_N2_IP6}\n\tlog_test $? 0 \"Ping received ICMP Hop limit\"\n}\n\nipv6_ping_ttl_asym()\n{\n\tipv6_ping_ttl asym\n}\n\nipv6_ping_frag()\n{\n\tlocal ttype=\"$1\"\n\n\t[ \"x$ttype\" = \"x\" ] && ttype=\"$DEFAULT_TTYPE\"\n\n\tlog_section \"IPv6 ($ttype route): VRF ICMP fragmentation error route lookup ping\"\n\n\tsetup_\"$ttype\"\n\n\tcheck_connectivity6 || return\n\n\trun_cmd_grep \"Packet too big\" ip netns exec h1 \"${ping6}\" -s 1450 -Mdo -c1 -W2 ${H2_N2_IP6}\n\tlog_test $? 0 \"Ping received ICMP Packet too big\"\n}\n\nipv6_ping_frag_asym()\n{\n\tipv6_ping_frag asym\n}\n\n################################################################################\n# usage\n\nusage()\n{\n        cat <<EOF\nusage: ${0##*/} OPTS\n\n\t-4          Run IPv4 tests only\n\t-6          Run IPv6 tests only\n        -t TEST     Run only TEST\n\t-p          Pause on fail\n\t-v          verbose mode (show commands and output)\nEOF\n}\n\n################################################################################\n# main\n\n# Some systems don't have a ping6 binary anymore\ncommand -v ping6 > /dev/null 2>&1 && ping6=$(command -v ping6) || ping6=$(command -v ping)\n\nTESTS_IPV4=\"ipv4_ping_ttl ipv4_traceroute ipv4_ping_frag ipv4_ping_ttl_asym ipv4_traceroute_asym\"\nTESTS_IPV6=\"ipv6_ping_ttl ipv6_traceroute ipv6_ping_ttl_asym ipv6_traceroute_asym\"\n\nret=0\nnsuccess=0\nnfail=0\n\nwhile getopts :46t:pvh o\ndo\n\tcase $o in\n\t\t4) TESTS=ipv4;;\n\t\t6) TESTS=ipv6;;\n\t\tt) TESTS=$OPTARG;;\n\t\tp) PAUSE_ON_FAIL=yes;;\n\t\tv) VERBOSE=1;;\n\t\th) usage; exit 0;;\n\t\t*) usage; exit 1;;\n\tesac\ndone\n\n#\n# show user test config\n#\nif [ -z \"$TESTS\" ]; then\n        TESTS=\"$TESTS_IPV4 $TESTS_IPV6\"\nelif [ \"$TESTS\" = \"ipv4\" ]; then\n        TESTS=\"$TESTS_IPV4\"\nelif [ \"$TESTS\" = \"ipv6\" ]; then\n        TESTS=\"$TESTS_IPV6\"\nfi\n\nfor t in $TESTS\ndo\n\tcase $t in\n\tipv4_ping_ttl|ping)              ipv4_ping_ttl;;&\n\tipv4_ping_ttl_asym|ping)         ipv4_ping_ttl_asym;;&\n\tipv4_traceroute|traceroute)      ipv4_traceroute;;&\n\tipv4_traceroute_asym|traceroute) ipv4_traceroute_asym;;&\n\tipv4_ping_frag|ping)             ipv4_ping_frag;;&\n\n\tipv6_ping_ttl|ping)              ipv6_ping_ttl;;&\n\tipv6_ping_ttl_asym|ping)         ipv6_ping_ttl_asym;;&\n\tipv6_traceroute|traceroute)      ipv6_traceroute;;&\n\tipv6_traceroute_asym|traceroute) ipv6_traceroute_asym;;&\n\tipv6_ping_frag|ping)             ipv6_ping_frag;;&\n\n\t# setup namespaces and config, but do not run any tests\n\tsetup_sym|setup)                 setup_sym; exit 0;;\n\tsetup_asym)                      setup_asym; exit 0;;\n\n\thelp)                       echo \"Test names: $TESTS\"; exit 0;;\n\tesac\ndone\n\ncleanup\n\nprintf \"\\nTests passed: %3d\\n\" ${nsuccess}\nprintf \"Tests failed: %3d\\n\"   ${nfail}\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}