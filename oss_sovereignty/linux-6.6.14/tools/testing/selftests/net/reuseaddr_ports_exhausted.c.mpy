{
  "module_name": "reuseaddr_ports_exhausted.c",
  "hash_id": "a8848a9afe326f18647e07457356eab8e75b1bc426939ed0c1225b9024469758",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/reuseaddr_ports_exhausted.c",
  "human_readable_source": "\n \n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"../kselftest_harness.h\"\n\nstruct reuse_opts {\n\tint reuseaddr[2];\n\tint reuseport[2];\n};\n\nstruct reuse_opts unreusable_opts[12] = {\n\t{{0, 0}, {0, 0}},\n\t{{0, 0}, {0, 1}},\n\t{{0, 0}, {1, 0}},\n\t{{0, 0}, {1, 1}},\n\t{{0, 1}, {0, 0}},\n\t{{0, 1}, {0, 1}},\n\t{{0, 1}, {1, 0}},\n\t{{0, 1}, {1, 1}},\n\t{{1, 0}, {0, 0}},\n\t{{1, 0}, {0, 1}},\n\t{{1, 0}, {1, 0}},\n\t{{1, 0}, {1, 1}},\n};\n\nstruct reuse_opts reusable_opts[4] = {\n\t{{1, 1}, {0, 0}},\n\t{{1, 1}, {0, 1}},\n\t{{1, 1}, {1, 0}},\n\t{{1, 1}, {1, 1}},\n};\n\nint bind_port(struct __test_metadata *_metadata, int reuseaddr, int reuseport)\n{\n\tstruct sockaddr_in local_addr;\n\tint len = sizeof(local_addr);\n\tint fd, ret;\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tASSERT_NE(-1, fd) TH_LOG(\"failed to open socket.\");\n\n\tret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(int));\n\tASSERT_EQ(0, ret) TH_LOG(\"failed to setsockopt: SO_REUSEADDR.\");\n\n\tret = setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &reuseport, sizeof(int));\n\tASSERT_EQ(0, ret) TH_LOG(\"failed to setsockopt: SO_REUSEPORT.\");\n\n\tlocal_addr.sin_family = AF_INET;\n\tlocal_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tlocal_addr.sin_port = 0;\n\n\tif (bind(fd, (struct sockaddr *)&local_addr, len) == -1) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nTEST(reuseaddr_ports_exhausted_unreusable)\n{\n\tstruct reuse_opts *opts;\n\tint i, j, fd[2];\n\n\tfor (i = 0; i < 12; i++) {\n\t\topts = &unreusable_opts[i];\n\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tfd[j] = bind_port(_metadata, opts->reuseaddr[j], opts->reuseport[j]);\n\n\t\tASSERT_NE(-1, fd[0]) TH_LOG(\"failed to bind.\");\n\t\tEXPECT_EQ(-1, fd[1]) TH_LOG(\"should fail to bind.\");\n\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tif (fd[j] != -1)\n\t\t\t\tclose(fd[j]);\n\t}\n}\n\nTEST(reuseaddr_ports_exhausted_reusable_same_euid)\n{\n\tstruct reuse_opts *opts;\n\tint i, j, fd[2];\n\n\tfor (i = 0; i < 4; i++) {\n\t\topts = &reusable_opts[i];\n\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tfd[j] = bind_port(_metadata, opts->reuseaddr[j], opts->reuseport[j]);\n\n\t\tASSERT_NE(-1, fd[0]) TH_LOG(\"failed to bind.\");\n\n\t\tif (opts->reuseport[0] && opts->reuseport[1]) {\n\t\t\tEXPECT_EQ(-1, fd[1]) TH_LOG(\"should fail to bind because both sockets succeed to be listened.\");\n\t\t} else {\n\t\t\tEXPECT_NE(-1, fd[1]) TH_LOG(\"should succeed to bind to connect to different destinations.\");\n\t\t}\n\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tif (fd[j] != -1)\n\t\t\t\tclose(fd[j]);\n\t}\n}\n\nTEST(reuseaddr_ports_exhausted_reusable_different_euid)\n{\n\tstruct reuse_opts *opts;\n\tint i, j, ret, fd[2];\n\tuid_t euid[2] = {10, 20};\n\n\tfor (i = 0; i < 4; i++) {\n\t\topts = &reusable_opts[i];\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tret = seteuid(euid[j]);\n\t\t\tASSERT_EQ(0, ret) TH_LOG(\"failed to seteuid: %d.\", euid[j]);\n\n\t\t\tfd[j] = bind_port(_metadata, opts->reuseaddr[j], opts->reuseport[j]);\n\n\t\t\tret = seteuid(0);\n\t\t\tASSERT_EQ(0, ret) TH_LOG(\"failed to seteuid: 0.\");\n\t\t}\n\n\t\tASSERT_NE(-1, fd[0]) TH_LOG(\"failed to bind.\");\n\t\tEXPECT_NE(-1, fd[1]) TH_LOG(\"should succeed to bind because one socket can be bound in each euid.\");\n\n\t\tif (fd[1] != -1) {\n\t\t\tret = listen(fd[0], 5);\n\t\t\tASSERT_EQ(0, ret) TH_LOG(\"failed to listen.\");\n\n\t\t\tret = listen(fd[1], 5);\n\t\t\tEXPECT_EQ(-1, ret) TH_LOG(\"should fail to listen because only one uid reserves the port in TCP_LISTEN.\");\n\t\t}\n\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tif (fd[j] != -1)\n\t\t\t\tclose(fd[j]);\n\t}\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}