{
  "module_name": "udpgso.c",
  "hash_id": "eb0e23ece555f0509cb52bcba4a7c8d3e5cfa1c0ae209eb1f94c375cffd48ec4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/udpgso.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <stddef.h>\n#include <arpa/inet.h>\n#include <error.h>\n#include <errno.h>\n#include <net/if.h>\n#include <linux/in.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/ip6.h>\n#include <netinet/udp.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#ifndef ETH_MAX_MTU\n#define ETH_MAX_MTU\t0xFFFFU\n#endif\n\n#ifndef UDP_SEGMENT\n#define UDP_SEGMENT\t\t103\n#endif\n\n#ifndef UDP_MAX_SEGMENTS\n#define UDP_MAX_SEGMENTS\t(1 << 6UL)\n#endif\n\n#define CONST_MTU_TEST\t1500\n\n#define CONST_HDRLEN_V4\t\t(sizeof(struct iphdr) + sizeof(struct udphdr))\n#define CONST_HDRLEN_V6\t\t(sizeof(struct ip6_hdr) + sizeof(struct udphdr))\n\n#define CONST_MSS_V4\t\t(CONST_MTU_TEST - CONST_HDRLEN_V4)\n#define CONST_MSS_V6\t\t(CONST_MTU_TEST - CONST_HDRLEN_V6)\n\n#define CONST_MAX_SEGS_V4\t(ETH_MAX_MTU / CONST_MSS_V4)\n#define CONST_MAX_SEGS_V6\t(ETH_MAX_MTU / CONST_MSS_V6)\n\nstatic bool\t\tcfg_do_ipv4;\nstatic bool\t\tcfg_do_ipv6;\nstatic bool\t\tcfg_do_connected;\nstatic bool\t\tcfg_do_connectionless;\nstatic bool\t\tcfg_do_msgmore;\nstatic bool\t\tcfg_do_setsockopt;\nstatic int\t\tcfg_specific_test_id = -1;\n\nstatic const char\tcfg_ifname[] = \"lo\";\nstatic unsigned short\tcfg_port = 9000;\n\nstatic char buf[ETH_MAX_MTU];\n\nstruct testcase {\n\tint tlen;\t\t \n\tbool tfail;\t\t \n\tint gso_len;\t\t \n\tint r_num_mss;\t\t \n\tint r_len_last;\t\t \n};\n\nconst struct in6_addr addr6 = IN6ADDR_LOOPBACK_INIT;\nconst struct in_addr addr4 = { .s_addr = __constant_htonl(INADDR_LOOPBACK + 2) };\n\nstruct testcase testcases_v4[] = {\n\t{\n\t\t \n\t\t.tlen = 1,\n\t\t.r_len_last = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V4,\n\t\t.r_num_mss = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V4 + 1,\n\t\t.tfail = true,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V4,\n\t\t.gso_len = CONST_MSS_V4,\n\t\t.r_num_mss = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V4 + 1,\n\t\t.gso_len = CONST_MSS_V4,\n\t\t.r_num_mss = 1,\n\t\t.r_len_last = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V4 * 2,\n\t\t.gso_len = CONST_MSS_V4,\n\t\t.r_num_mss = 2,\n\t},\n\t{\n\t\t \n\t\t.tlen = (CONST_MSS_V4 * 2) + 1,\n\t\t.gso_len = CONST_MSS_V4,\n\t\t.r_num_mss = 2,\n\t\t.r_len_last = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = (ETH_MAX_MTU / CONST_MSS_V4) * CONST_MSS_V4,\n\t\t.gso_len = CONST_MSS_V4,\n\t\t.r_num_mss = (ETH_MAX_MTU / CONST_MSS_V4),\n\t},\n\n\t{\n\t\t \n\t\t.tlen = ETH_MAX_MTU - CONST_HDRLEN_V4,\n\t\t.gso_len = CONST_MSS_V4,\n\t\t.r_num_mss = CONST_MAX_SEGS_V4,\n\t\t.r_len_last = ETH_MAX_MTU - CONST_HDRLEN_V4 -\n\t\t\t      (CONST_MAX_SEGS_V4 * CONST_MSS_V4),\n\t},\n\t{\n\t\t \n\t\t.tlen = ETH_MAX_MTU - CONST_HDRLEN_V4 + 1,\n\t\t.gso_len = CONST_MSS_V4,\n\t\t.tfail = true,\n\t},\n\t{\n\t\t \n\t\t.tlen = 1,\n\t\t.gso_len = 1,\n\t\t.r_num_mss = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = 2,\n\t\t.gso_len = 1,\n\t\t.r_num_mss = 2,\n\t},\n\t{\n\t\t \n\t\t.tlen = 5,\n\t\t.gso_len = 2,\n\t\t.r_num_mss = 2,\n\t\t.r_len_last = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = UDP_MAX_SEGMENTS,\n\t\t.gso_len = 1,\n\t\t.r_num_mss = UDP_MAX_SEGMENTS,\n\t},\n\t{\n\t\t \n\t\t.tlen = UDP_MAX_SEGMENTS + 1,\n\t\t.gso_len = 1,\n\t\t.tfail = true,\n\t},\n\t{\n\t\t \n\t}\n};\n\n#ifndef IP6_MAX_MTU\n#define IP6_MAX_MTU\t(ETH_MAX_MTU + sizeof(struct ip6_hdr))\n#endif\n\nstruct testcase testcases_v6[] = {\n\t{\n\t\t \n\t\t.tlen = 1,\n\t\t.r_len_last = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V6,\n\t\t.r_num_mss = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V6 + 1,\n\t\t.tfail = true,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V6,\n\t\t.gso_len = CONST_MSS_V6,\n\t\t.r_num_mss = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V6 + 1,\n\t\t.gso_len = CONST_MSS_V6,\n\t\t.r_num_mss = 1,\n\t\t.r_len_last = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = CONST_MSS_V6 * 2,\n\t\t.gso_len = CONST_MSS_V6,\n\t\t.r_num_mss = 2,\n\t},\n\t{\n\t\t \n\t\t.tlen = (CONST_MSS_V6 * 2) + 1,\n\t\t.gso_len = CONST_MSS_V6,\n\t\t.r_num_mss = 2,\n\t\t.r_len_last = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = (IP6_MAX_MTU / CONST_MSS_V6) * CONST_MSS_V6,\n\t\t.gso_len = CONST_MSS_V6,\n\t\t.r_num_mss = (IP6_MAX_MTU / CONST_MSS_V6),\n\t},\n\n\t{\n\t\t \n\t\t.tlen = IP6_MAX_MTU - CONST_HDRLEN_V6,\n\t\t.gso_len = CONST_MSS_V6,\n\t\t.r_num_mss = CONST_MAX_SEGS_V6,\n\t\t.r_len_last = IP6_MAX_MTU - CONST_HDRLEN_V6 -\n\t\t\t      (CONST_MAX_SEGS_V6 * CONST_MSS_V6),\n\t},\n\t{\n\t\t \n\t\t.tlen = IP6_MAX_MTU - CONST_HDRLEN_V6 + 1,\n\t\t.gso_len = CONST_MSS_V6,\n\t\t.tfail = true,\n\t},\n\t{\n\t\t \n\t\t.tlen = 1,\n\t\t.gso_len = 1,\n\t\t.r_num_mss = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = 2,\n\t\t.gso_len = 1,\n\t\t.r_num_mss = 2,\n\t},\n\t{\n\t\t \n\t\t.tlen = 5,\n\t\t.gso_len = 2,\n\t\t.r_num_mss = 2,\n\t\t.r_len_last = 1,\n\t},\n\t{\n\t\t \n\t\t.tlen = UDP_MAX_SEGMENTS,\n\t\t.gso_len = 1,\n\t\t.r_num_mss = UDP_MAX_SEGMENTS,\n\t},\n\t{\n\t\t \n\t\t.tlen = UDP_MAX_SEGMENTS + 1,\n\t\t.gso_len = 1,\n\t\t.tfail = true,\n\t},\n\t{\n\t\t \n\t}\n};\n\nstatic unsigned int get_device_mtu(int fd, const char *ifname)\n{\n\tstruct ifreq ifr;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\n\tstrcpy(ifr.ifr_name, ifname);\n\n\tif (ioctl(fd, SIOCGIFMTU, &ifr))\n\t\terror(1, errno, \"ioctl get mtu\");\n\n\treturn ifr.ifr_mtu;\n}\n\nstatic void __set_device_mtu(int fd, const char *ifname, unsigned int mtu)\n{\n\tstruct ifreq ifr;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\n\tifr.ifr_mtu = mtu;\n\tstrcpy(ifr.ifr_name, ifname);\n\n\tif (ioctl(fd, SIOCSIFMTU, &ifr))\n\t\terror(1, errno, \"ioctl set mtu\");\n}\n\nstatic void set_device_mtu(int fd, int mtu)\n{\n\tint val;\n\n\tval = get_device_mtu(fd, cfg_ifname);\n\tfprintf(stderr, \"device mtu (orig): %u\\n\", val);\n\n\t__set_device_mtu(fd, cfg_ifname, mtu);\n\tval = get_device_mtu(fd, cfg_ifname);\n\tif (val != mtu)\n\t\terror(1, 0, \"unable to set device mtu to %u\\n\", val);\n\n\tfprintf(stderr, \"device mtu (test): %u\\n\", val);\n}\n\nstatic void set_pmtu_discover(int fd, bool is_ipv4)\n{\n\tint level, name, val;\n\n\tif (is_ipv4) {\n\t\tlevel\t= SOL_IP;\n\t\tname\t= IP_MTU_DISCOVER;\n\t\tval\t= IP_PMTUDISC_DO;\n\t} else {\n\t\tlevel\t= SOL_IPV6;\n\t\tname\t= IPV6_MTU_DISCOVER;\n\t\tval\t= IPV6_PMTUDISC_DO;\n\t}\n\n\tif (setsockopt(fd, level, name, &val, sizeof(val)))\n\t\terror(1, errno, \"setsockopt path mtu\");\n}\n\nstatic unsigned int get_path_mtu(int fd, bool is_ipv4)\n{\n\tsocklen_t vallen;\n\tunsigned int mtu;\n\tint ret;\n\n\tvallen = sizeof(mtu);\n\tif (is_ipv4)\n\t\tret = getsockopt(fd, SOL_IP, IP_MTU, &mtu, &vallen);\n\telse\n\t\tret = getsockopt(fd, SOL_IPV6, IPV6_MTU, &mtu, &vallen);\n\n\tif (ret)\n\t\terror(1, errno, \"getsockopt mtu\");\n\n\n\tfprintf(stderr, \"path mtu (read):  %u\\n\", mtu);\n\treturn mtu;\n}\n\n \nstatic void set_route_mtu(int mtu, bool is_ipv4)\n{\n\tstruct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };\n\tstruct nlmsghdr *nh;\n\tstruct rtattr *rta;\n\tstruct rtmsg *rt;\n\tchar data[NLMSG_ALIGN(sizeof(*nh)) +\n\t\t  NLMSG_ALIGN(sizeof(*rt)) +\n\t\t  NLMSG_ALIGN(RTA_LENGTH(sizeof(addr6))) +\n\t\t  NLMSG_ALIGN(RTA_LENGTH(sizeof(int))) +\n\t\t  NLMSG_ALIGN(RTA_LENGTH(0) + RTA_LENGTH(sizeof(int)))];\n\tint fd, ret, alen, off = 0;\n\n\talen = is_ipv4 ? sizeof(addr4) : sizeof(addr6);\n\n\tfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket netlink\");\n\n\tmemset(data, 0, sizeof(data));\n\n\tnh = (void *)data;\n\tnh->nlmsg_type = RTM_NEWROUTE;\n\tnh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;\n\toff += NLMSG_ALIGN(sizeof(*nh));\n\n\trt = (void *)(data + off);\n\trt->rtm_family = is_ipv4 ? AF_INET : AF_INET6;\n\trt->rtm_table = RT_TABLE_MAIN;\n\trt->rtm_dst_len = alen << 3;\n\trt->rtm_protocol = RTPROT_BOOT;\n\trt->rtm_scope = RT_SCOPE_UNIVERSE;\n\trt->rtm_type = RTN_UNICAST;\n\toff += NLMSG_ALIGN(sizeof(*rt));\n\n\trta = (void *)(data + off);\n\trta->rta_type = RTA_DST;\n\trta->rta_len = RTA_LENGTH(alen);\n\tif (is_ipv4)\n\t\tmemcpy(RTA_DATA(rta), &addr4, alen);\n\telse\n\t\tmemcpy(RTA_DATA(rta), &addr6, alen);\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\trta = (void *)(data + off);\n\trta->rta_type = RTA_OIF;\n\trta->rta_len = RTA_LENGTH(sizeof(int));\n\t*((int *)(RTA_DATA(rta))) = 1; \n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t \n\trta = (void *)(data + off);\n\trta->rta_type = RTA_METRICS;\n\trta->rta_len = RTA_LENGTH(0) + RTA_LENGTH(sizeof(int));\n\toff += NLMSG_ALIGN(rta->rta_len);\n\n\t \n\trta = (void *)(((char *) rta) + RTA_LENGTH(0));\n\trta->rta_type = RTAX_MTU;\n\trta->rta_len = RTA_LENGTH(sizeof(int));\n\t*((int *)(RTA_DATA(rta))) = mtu;\n\n\tnh->nlmsg_len = off;\n\n\tret = sendto(fd, data, off, 0, (void *)&nladdr, sizeof(nladdr));\n\tif (ret != off)\n\t\terror(1, errno, \"send netlink: %uB != %uB\\n\", ret, off);\n\n\tif (close(fd))\n\t\terror(1, errno, \"close netlink\");\n\n\tfprintf(stderr, \"route mtu (test): %u\\n\", mtu);\n}\n\nstatic bool __send_one(int fd, struct msghdr *msg, int flags)\n{\n\tint ret;\n\n\tret = sendmsg(fd, msg, flags);\n\tif (ret == -1 &&\n\t    (errno == EMSGSIZE || errno == ENOMEM || errno == EINVAL))\n\t\treturn false;\n\tif (ret == -1)\n\t\terror(1, errno, \"sendmsg\");\n\tif (ret != msg->msg_iov->iov_len)\n\t\terror(1, 0, \"sendto: %d != %llu\", ret,\n\t\t\t(unsigned long long)msg->msg_iov->iov_len);\n\tif (msg->msg_flags)\n\t\terror(1, 0, \"sendmsg: return flags 0x%x\\n\", msg->msg_flags);\n\n\treturn true;\n}\n\nstatic bool send_one(int fd, int len, int gso_len,\n\t\t     struct sockaddr *addr, socklen_t alen)\n{\n\tchar control[CMSG_SPACE(sizeof(uint16_t))] = {0};\n\tstruct msghdr msg = {0};\n\tstruct iovec iov = {0};\n\tstruct cmsghdr *cm;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = len;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tmsg.msg_name = addr;\n\tmsg.msg_namelen = alen;\n\n\tif (gso_len && !cfg_do_setsockopt) {\n\t\tmsg.msg_control = control;\n\t\tmsg.msg_controllen = sizeof(control);\n\n\t\tcm = CMSG_FIRSTHDR(&msg);\n\t\tcm->cmsg_level = SOL_UDP;\n\t\tcm->cmsg_type = UDP_SEGMENT;\n\t\tcm->cmsg_len = CMSG_LEN(sizeof(uint16_t));\n\t\t*((uint16_t *) CMSG_DATA(cm)) = gso_len;\n\t}\n\n\t \n\tif (cfg_do_msgmore && len > 1) {\n\t\tiov.iov_len = 1;\n\t\tif (!__send_one(fd, &msg, MSG_MORE))\n\t\t\terror(1, 0, \"send 1B failed\");\n\n\t\tiov.iov_base++;\n\t\tiov.iov_len = len - 1;\n\t}\n\n\treturn __send_one(fd, &msg, 0);\n}\n\nstatic int recv_one(int fd, int flags)\n{\n\tint ret;\n\n\tret = recv(fd, buf, sizeof(buf), flags);\n\tif (ret == -1 && errno == EAGAIN && (flags & MSG_DONTWAIT))\n\t\treturn 0;\n\tif (ret == -1)\n\t\terror(1, errno, \"recv\");\n\n\treturn ret;\n}\n\nstatic void run_one(struct testcase *test, int fdt, int fdr,\n\t\t    struct sockaddr *addr, socklen_t alen)\n{\n\tint i, ret, val, mss;\n\tbool sent;\n\n\tfprintf(stderr, \"ipv%d tx:%d gso:%d %s\\n\",\n\t\t\taddr->sa_family == AF_INET ? 4 : 6,\n\t\t\ttest->tlen, test->gso_len,\n\t\t\ttest->tfail ? \"(fail)\" : \"\");\n\n\tval = test->gso_len;\n\tif (cfg_do_setsockopt) {\n\t\tif (setsockopt(fdt, SOL_UDP, UDP_SEGMENT, &val, sizeof(val)))\n\t\t\terror(1, errno, \"setsockopt udp segment\");\n\t}\n\n\tsent = send_one(fdt, test->tlen, test->gso_len, addr, alen);\n\tif (sent && test->tfail)\n\t\terror(1, 0, \"send succeeded while expecting failure\");\n\tif (!sent && !test->tfail)\n\t\terror(1, 0, \"send failed while expecting success\");\n\tif (!sent)\n\t\treturn;\n\n\tif (test->gso_len)\n\t\tmss = test->gso_len;\n\telse\n\t\tmss = addr->sa_family == AF_INET ? CONST_MSS_V4 : CONST_MSS_V6;\n\n\n\t \n\tfor (i = 0; i < test->r_num_mss; i++) {\n\t\tret = recv_one(fdr, 0);\n\t\tif (ret != mss)\n\t\t\terror(1, 0, \"recv.%d: %d != %d\", i, ret, mss);\n\t}\n\n\t \n\tif (test->r_len_last) {\n\t\tret = recv_one(fdr, 0);\n\t\tif (ret != test->r_len_last)\n\t\t\terror(1, 0, \"recv.%d: %d != %d (last)\",\n\t\t\t      i, ret, test->r_len_last);\n\t}\n\n\t \n\tret = recv_one(fdr, MSG_DONTWAIT);\n\tif (ret)\n\t\terror(1, 0, \"recv: unexpected datagram\");\n}\n\nstatic void run_all(int fdt, int fdr, struct sockaddr *addr, socklen_t alen)\n{\n\tstruct testcase *tests, *test;\n\n\ttests = addr->sa_family == AF_INET ? testcases_v4 : testcases_v6;\n\n\tfor (test = tests; test->tlen; test++) {\n\t\t \n\t\tif (cfg_specific_test_id == -1 ||\n\t\t    cfg_specific_test_id == test - tests)\n\t\t\trun_one(test, fdt, fdr, addr, alen);\n\t}\n}\n\nstatic void run_test(struct sockaddr *addr, socklen_t alen)\n{\n\tstruct timeval tv = { .tv_usec = 100 * 1000 };\n\tint fdr, fdt, val;\n\n\tfdr = socket(addr->sa_family, SOCK_DGRAM, 0);\n\tif (fdr == -1)\n\t\terror(1, errno, \"socket r\");\n\n\tif (bind(fdr, addr, alen))\n\t\terror(1, errno, \"bind\");\n\n\t \n\tif (setsockopt(fdr, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)))\n\t\terror(1, errno, \"setsockopt rcv timeout\");\n\n\tfdt = socket(addr->sa_family, SOCK_DGRAM, 0);\n\tif (fdt == -1)\n\t\terror(1, errno, \"socket t\");\n\n\t \n\tset_pmtu_discover(fdt, addr->sa_family == AF_INET);\n\n\tif (cfg_do_connectionless) {\n\t\tset_device_mtu(fdt, CONST_MTU_TEST);\n\t\trun_all(fdt, fdr, addr, alen);\n\t}\n\n\tif (cfg_do_connected) {\n\t\tset_device_mtu(fdt, CONST_MTU_TEST + 100);\n\t\tset_route_mtu(CONST_MTU_TEST, addr->sa_family == AF_INET);\n\n\t\tif (connect(fdt, addr, alen))\n\t\t\terror(1, errno, \"connect\");\n\n\t\tval = get_path_mtu(fdt, addr->sa_family == AF_INET);\n\t\tif (val != CONST_MTU_TEST)\n\t\t\terror(1, 0, \"bad path mtu %u\\n\", val);\n\n\t\trun_all(fdt, fdr, addr, 0  );\n\t}\n\n\tif (close(fdt))\n\t\terror(1, errno, \"close t\");\n\tif (close(fdr))\n\t\terror(1, errno, \"close r\");\n}\n\nstatic void run_test_v4(void)\n{\n\tstruct sockaddr_in addr = {0};\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(cfg_port);\n\taddr.sin_addr = addr4;\n\n\trun_test((void *)&addr, sizeof(addr));\n}\n\nstatic void run_test_v6(void)\n{\n\tstruct sockaddr_in6 addr = {0};\n\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(cfg_port);\n\taddr.sin6_addr = addr6;\n\n\trun_test((void *)&addr, sizeof(addr));\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"46cCmst:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tcfg_do_ipv4 = true;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tcfg_do_ipv6 = true;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcfg_do_connected = true;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcfg_do_connectionless = true;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcfg_do_msgmore = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcfg_do_setsockopt = true;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_specific_test_id = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"%s: parse error\", argv[0]);\n\t\t}\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tparse_opts(argc, argv);\n\n\tif (cfg_do_ipv4)\n\t\trun_test_v4();\n\tif (cfg_do_ipv6)\n\t\trun_test_v6();\n\n\tfprintf(stderr, \"OK\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}