{
  "module_name": "srv6_hl2encap_red_l2vpn_test.sh",
  "hash_id": "320c94a0180271f61d43feb08cb0cfb4e62b0c4dd50c6418f87c42e21537b895",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/srv6_hl2encap_red_l2vpn_test.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# author: Andrea Mayer <andrea.mayer@uniroma2.it>\n#\n# This script is designed for testing the SRv6 H.L2Encaps.Red behavior.\n#\n# Below is depicted the IPv6 network of an operator which offers L2 VPN\n# services to hosts, enabling them to communicate with each other.\n# In this example, hosts hs-1 and hs-2 are connected through an L2 VPN service.\n# Currently, the SRv6 subsystem in Linux allows hosts hs-1 and hs-2 to exchange\n# full L2 frames as long as they carry IPv4/IPv6.\n#\n# Routers rt-1,rt-2,rt-3 and rt-4 implement L2 VPN services\n# leveraging the SRv6 architecture. The key components for such VPNs are:\n#\n#   i) The SRv6 H.L2Encaps.Red behavior applies SRv6 Policies on traffic\n#      received by connected hosts, initiating the VPN tunnel. Such a behavior\n#      is an optimization of the SRv6 H.L2Encap aiming to reduce the\n#      length of the SID List carried in the pushed SRH. Specifically, the\n#      H.L2Encaps.Red removes the first SID contained in the SID List (i.e. SRv6\n#      Policy) by storing it into the IPv6 Destination Address. When a SRv6\n#      Policy is made of only one SID, the SRv6 H.L2Encaps.Red behavior omits\n#      the SRH at all and pushes that SID directly into the IPv6 DA;\n#\n#  ii) The SRv6 End behavior advances the active SID in the SID List\n#      carried by the SRH;\n#\n# iii) The SRv6 End.DX2 behavior is used for removing the SRv6 Policy\n#      and, thus, it terminates the VPN tunnel. The decapsulated L2 frame is\n#      sent over the interface connected with the destination host.\n#\n#               cafe::1                      cafe::2\n#              10.0.0.1                     10.0.0.2\n#             +--------+                   +--------+\n#             |        |                   |        |\n#             |  hs-1  |                   |  hs-2  |\n#             |        |                   |        |\n#             +---+----+                   +--- +---+\n#    cafe::/64    |                             |      cafe::/64\n#  10.0.0.0/24    |                             |    10.0.0.0/24\n#             +---+----+                   +----+---+\n#             |        |  fcf0:0:1:2::/64  |        |\n#             |  rt-1  +-------------------+  rt-2  |\n#             |        |                   |        |\n#             +---+----+                   +----+---+\n#                 |      .               .      |\n#                 |  fcf0:0:1:3::/64   .        |\n#                 |          .       .          |\n#                 |            .   .            |\n# fcf0:0:1:4::/64 |              .              | fcf0:0:2:3::/64\n#                 |            .   .            |\n#                 |          .       .          |\n#                 |  fcf0:0:2:4::/64   .        |\n#                 |      .               .      |\n#             +---+----+                   +----+---+\n#             |        |                   |        |\n#             |  rt-4  +-------------------+  rt-3  |\n#             |        |  fcf0:0:3:4::/64  |        |\n#             +---+----+                   +----+---+\n#\n#\n# Every fcf0:0:x:y::/64 network interconnects the SRv6 routers rt-x with rt-y\n# in the IPv6 operator network.\n#\n# Local SID table\n# ===============\n#\n# Each SRv6 router is configured with a Local SID table in which SIDs are\n# stored. Considering the given SRv6 router rt-x, at least two SIDs are\n# configured in the Local SID table:\n#\n#   Local SID table for SRv6 router rt-x\n#   +----------------------------------------------------------+\n#   |fcff:x::e is associated with the SRv6 End behavior        |\n#   |fcff:x::d2 is associated with the SRv6 End.DX2 behavior   |\n#   +----------------------------------------------------------+\n#\n# The fcff::/16 prefix is reserved by the operator for implementing SRv6 VPN\n# services. Reachability of SIDs is ensured by proper configuration of the IPv6\n# operator's network and SRv6 routers.\n#\n# SRv6 Policies\n# =============\n#\n# An SRv6 ingress router applies SRv6 policies to the traffic received from a\n# connected host. SRv6 policy enforcement consists of encapsulating the\n# received traffic into a new IPv6 packet with a given SID List contained in\n# the SRH.\n#\n# L2 VPN between hs-1 and hs-2\n# ----------------------------\n#\n# Hosts hs-1 and hs-2 are connected using a dedicated L2 VPN.\n# Specifically, packets generated from hs-1 and directed towards hs-2 are\n# handled by rt-1 which applies the following SRv6 Policies:\n#\n#   i.a) L2 traffic, SID List=fcff:2::d2\n#\n# Policy (i.a) steers tunneled L2 traffic through SRv6 router rt-2.\n# The H.L2Encaps.Red omits the presence of SRH at all, since the SID List\n# consists of only one SID (fcff:2::d2) that can be stored directly in the IPv6\n# DA.\n#\n# On the reverse path (i.e. from hs-2 to hs-1), rt-2 applies the following\n# policies:\n#\n#   i.b) L2 traffic, SID List=fcff:4::e,fcff:3::e,fcff:1::d2\n#\n# Policy (i.b) steers tunneled L2 traffic through the SRv6 routers\n# rt-4,rt-3,rt2. The H.L2Encaps.Red reduces the SID List in the SRH by removing\n# the first SID (fcff:4::e) and pushing it into the IPv6 DA.\n#\n# In summary:\n#  hs-1->hs-2 |IPv6 DA=fcff:2::d2|eth|...|                              (i.a)\n#  hs-2->hs-1 |IPv6 DA=fcff:4::e|SRH SIDs=fcff:3::e,fcff:1::d2|eth|...| (i.b)\n#\n\n# Kselftest framework requirement - SKIP code is 4.\nreadonly ksft_skip=4\n\nreadonly RDMSUFF=\"$(mktemp -u XXXXXXXX)\"\nreadonly DUMMY_DEVNAME=\"dum0\"\nreadonly RT2HS_DEVNAME=\"veth-hs\"\nreadonly HS_VETH_NAME=\"veth0\"\nreadonly LOCALSID_TABLE_ID=90\nreadonly IPv6_RT_NETWORK=fcf0:0\nreadonly IPv6_HS_NETWORK=cafe\nreadonly IPv4_HS_NETWORK=10.0.0\nreadonly VPN_LOCATOR_SERVICE=fcff\nreadonly MAC_PREFIX=00:00:00:c0:01\nreadonly END_FUNC=000e\nreadonly DX2_FUNC=00d2\n\nPING_TIMEOUT_SEC=4\nPAUSE_ON_FAIL=${PAUSE_ON_FAIL:=no}\n\n# IDs of routers and hosts are initialized during the setup of the testing\n# network\nROUTERS=''\nHOSTS=''\n\nSETUP_ERR=1\n\nret=${ksft_skip}\nnsuccess=0\nnfail=0\n\nlog_test()\n{\n\tlocal rc=\"$1\"\n\tlocal expected=\"$2\"\n\tlocal msg=\"$3\"\n\n\tif [ \"${rc}\" -eq \"${expected}\" ]; then\n\t\tnsuccess=$((nsuccess+1))\n\t\tprintf \"\\n    TEST: %-60s  [ OK ]\\n\" \"${msg}\"\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"\\n    TEST: %-60s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n}\n\nprint_log_test_results()\n{\n\tprintf \"\\nTests passed: %3d\\n\" \"${nsuccess}\"\n\tprintf \"Tests failed: %3d\\n\"   \"${nfail}\"\n\n\t# when a test fails, the value of 'ret' is set to 1 (error code).\n\t# Conversely, when all tests are passed successfully, the 'ret' value\n\t# is set to 0 (success code).\n\tif [ \"${ret}\" -ne 1 ]; then\n\t\tret=0\n\tfi\n}\n\nlog_section()\n{\n\techo\n\techo \"################################################################################\"\n\techo \"TEST SECTION: $*\"\n\techo \"################################################################################\"\n}\n\ntest_command_or_ksft_skip()\n{\n\tlocal cmd=\"$1\"\n\n\tif [ ! -x \"$(command -v \"${cmd}\")\" ]; then\n\t\techo \"SKIP: Could not run test without \\\"${cmd}\\\" tool\";\n\t\texit \"${ksft_skip}\"\n\tfi\n}\n\nget_nodename()\n{\n\tlocal name=\"$1\"\n\n\techo \"${name}-${RDMSUFF}\"\n}\n\nget_rtname()\n{\n\tlocal rtid=\"$1\"\n\n\tget_nodename \"rt-${rtid}\"\n}\n\nget_hsname()\n{\n\tlocal hsid=\"$1\"\n\n\tget_nodename \"hs-${hsid}\"\n}\n\n__create_namespace()\n{\n\tlocal name=\"$1\"\n\n\tip netns add \"${name}\"\n}\n\ncreate_router()\n{\n\tlocal rtid=\"$1\"\n\tlocal nsname\n\n\tnsname=\"$(get_rtname \"${rtid}\")\"\n\n\t__create_namespace \"${nsname}\"\n}\n\ncreate_host()\n{\n\tlocal hsid=\"$1\"\n\tlocal nsname\n\n\tnsname=\"$(get_hsname \"${hsid}\")\"\n\n\t__create_namespace \"${nsname}\"\n}\n\ncleanup()\n{\n\tlocal nsname\n\tlocal i\n\n\t# destroy routers\n\tfor i in ${ROUTERS}; do\n\t\tnsname=\"$(get_rtname \"${i}\")\"\n\n\t\tip netns del \"${nsname}\" &>/dev/null || true\n\tdone\n\n\t# destroy hosts\n\tfor i in ${HOSTS}; do\n\t\tnsname=\"$(get_hsname \"${i}\")\"\n\n\t\tip netns del \"${nsname}\" &>/dev/null || true\n\tdone\n\n\t# check whether the setup phase was completed successfully or not. In\n\t# case of an error during the setup phase of the testing environment,\n\t# the selftest is considered as \"skipped\".\n\tif [ \"${SETUP_ERR}\" -ne 0 ]; then\n\t\techo \"SKIP: Setting up the testing environment failed\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\texit \"${ret}\"\n}\n\nadd_link_rt_pairs()\n{\n\tlocal rt=\"$1\"\n\tlocal rt_neighs=\"$2\"\n\tlocal neigh\n\tlocal nsname\n\tlocal neigh_nsname\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\tfor neigh in ${rt_neighs}; do\n\t\tneigh_nsname=\"$(get_rtname \"${neigh}\")\"\n\n\t\tip link add \"veth-rt-${rt}-${neigh}\" netns \"${nsname}\" \\\n\t\t\ttype veth peer name \"veth-rt-${neigh}-${rt}\" \\\n\t\t\tnetns \"${neigh_nsname}\"\n\tdone\n}\n\nget_network_prefix()\n{\n\tlocal rt=\"$1\"\n\tlocal neigh=\"$2\"\n\tlocal p=\"${rt}\"\n\tlocal q=\"${neigh}\"\n\n\tif [ \"${p}\" -gt \"${q}\" ]; then\n\t\tp=\"${q}\"; q=\"${rt}\"\n\tfi\n\n\techo \"${IPv6_RT_NETWORK}:${p}:${q}\"\n}\n\n# Setup the basic networking for the routers\nsetup_rt_networking()\n{\n\tlocal rt=\"$1\"\n\tlocal rt_neighs=\"$2\"\n\tlocal nsname\n\tlocal net_prefix\n\tlocal devname\n\tlocal neigh\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\tfor neigh in ${rt_neighs}; do\n\t\tdevname=\"veth-rt-${rt}-${neigh}\"\n\n\t\tnet_prefix=\"$(get_network_prefix \"${rt}\" \"${neigh}\")\"\n\n\t\tip -netns \"${nsname}\" addr \\\n\t\t\tadd \"${net_prefix}::${rt}/64\" dev \"${devname}\" nodad\n\n\t\tip -netns \"${nsname}\" link set \"${devname}\" up\n\tdone\n\n\tip -netns \"${nsname}\" link add \"${DUMMY_DEVNAME}\" type dummy\n\n\tip -netns \"${nsname}\" link set \"${DUMMY_DEVNAME}\" up\n\tip -netns \"${nsname}\" link set lo up\n\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv6.conf.all.accept_dad=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv6.conf.default.accept_dad=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv6.conf.all.forwarding=1\n\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv4.conf.all.rp_filter=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv4.conf.default.rp_filter=0\n\tip netns exec \"${nsname}\" sysctl -wq net.ipv4.ip_forward=1\n}\n\n# Setup local SIDs for an SRv6 router\nsetup_rt_local_sids()\n{\n\tlocal rt=\"$1\"\n\tlocal rt_neighs=\"$2\"\n\tlocal net_prefix\n\tlocal devname\n\tlocal nsname\n\tlocal neigh\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\tfor neigh in ${rt_neighs}; do\n\t\tdevname=\"veth-rt-${rt}-${neigh}\"\n\n\t\tnet_prefix=\"$(get_network_prefix \"${rt}\" \"${neigh}\")\"\n\n\t\t# set underlay network routes for SIDs reachability\n\t\tip -netns \"${nsname}\" -6 route \\\n\t\t\tadd \"${VPN_LOCATOR_SERVICE}:${neigh}::/32\" \\\n\t\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\t\tvia \"${net_prefix}::${neigh}\" dev \"${devname}\"\n\tdone\n\n\t# Local End behavior (note that dev \"${DUMMY_DEVNAME}\" is a dummy\n\t# interface)\n\tip -netns \"${nsname}\" -6 route \\\n\t\tadd \"${VPN_LOCATOR_SERVICE}:${rt}::${END_FUNC}\" \\\n\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\tencap seg6local action End dev \"${DUMMY_DEVNAME}\"\n\n\t# all SIDs for VPNs start with a common locator. Routes and SRv6\n\t# Endpoint behaviors instaces are grouped together in the 'localsid'\n\t# table.\n\tip -netns \"${nsname}\" -6 rule add \\\n\t\tto \"${VPN_LOCATOR_SERVICE}::/16\" \\\n\t\tlookup \"${LOCALSID_TABLE_ID}\" prio 999\n}\n\n# build and install the SRv6 policy into the ingress SRv6 router.\n# args:\n#  $1 - destination host (i.e. cafe::x host)\n#  $2 - SRv6 router configured for enforcing the SRv6 Policy\n#  $3 - SRv6 routers configured for steering traffic (End behaviors)\n#  $4 - SRv6 router configured for removing the SRv6 Policy (router connected\n#       to the destination host)\n#  $5 - encap mode (full or red)\n#  $6 - traffic type (IPv6 or IPv4)\n__setup_rt_policy()\n{\n\tlocal dst=\"$1\"\n\tlocal encap_rt=\"$2\"\n\tlocal end_rts=\"$3\"\n\tlocal dec_rt=\"$4\"\n\tlocal mode=\"$5\"\n\tlocal traffic=\"$6\"\n\tlocal nsname\n\tlocal policy=''\n\tlocal n\n\n\tnsname=\"$(get_rtname \"${encap_rt}\")\"\n\n\tfor n in ${end_rts}; do\n\t\tpolicy=\"${policy}${VPN_LOCATOR_SERVICE}:${n}::${END_FUNC},\"\n\tdone\n\n\tpolicy=\"${policy}${VPN_LOCATOR_SERVICE}:${dec_rt}::${DX2_FUNC}\"\n\n\t# add SRv6 policy to incoming traffic sent by connected hosts\n\tif [ \"${traffic}\" -eq 6 ]; then\n\t\tip -netns \"${nsname}\" -6 route \\\n\t\t\tadd \"${IPv6_HS_NETWORK}::${dst}\" \\\n\t\t\tencap seg6 mode \"${mode}\" segs \"${policy}\" \\\n\t\t\tdev dum0\n\telse\n\t\tip -netns \"${nsname}\" -4 route \\\n\t\t\tadd \"${IPv4_HS_NETWORK}.${dst}\" \\\n\t\t\tencap seg6 mode \"${mode}\" segs \"${policy}\" \\\n\t\t\tdev dum0\n\tfi\n}\n\n# see __setup_rt_policy\nsetup_rt_policy_ipv6()\n{\n\t__setup_rt_policy \"$1\" \"$2\" \"$3\" \"$4\" \"$5\" 6\n}\n\n#see __setup_rt_policy\nsetup_rt_policy_ipv4()\n{\n\t__setup_rt_policy \"$1\" \"$2\" \"$3\" \"$4\" \"$5\" 4\n}\n\nsetup_decap()\n{\n\tlocal rt=\"$1\"\n\tlocal nsname\n\n\tnsname=\"$(get_rtname \"${rt}\")\"\n\n\t# Local End.DX2 behavior\n\tip -netns \"${nsname}\" -6 route \\\n\t\tadd \"${VPN_LOCATOR_SERVICE}:${rt}::${DX2_FUNC}\" \\\n\t\ttable \"${LOCALSID_TABLE_ID}\" \\\n\t\tencap seg6local action End.DX2 oif \"${RT2HS_DEVNAME}\" \\\n\t\tdev \"${RT2HS_DEVNAME}\"\n}\n\nsetup_hs()\n{\n\tlocal hs=\"$1\"\n\tlocal rt=\"$2\"\n\tlocal hsname\n\tlocal rtname\n\n\thsname=\"$(get_hsname \"${hs}\")\"\n\trtname=\"$(get_rtname \"${rt}\")\"\n\n\tip netns exec \"${hsname}\" sysctl -wq net.ipv6.conf.all.accept_dad=0\n\tip netns exec \"${hsname}\" sysctl -wq net.ipv6.conf.default.accept_dad=0\n\n\tip -netns \"${hsname}\" link add \"${HS_VETH_NAME}\" type veth \\\n\t\tpeer name \"${RT2HS_DEVNAME}\" netns \"${rtname}\"\n\n\tip -netns \"${hsname}\" addr add \"${IPv6_HS_NETWORK}::${hs}/64\" \\\n\t\tdev \"${HS_VETH_NAME}\" nodad\n\tip -netns \"${hsname}\" addr add \"${IPv4_HS_NETWORK}.${hs}/24\" \\\n\t\tdev \"${HS_VETH_NAME}\"\n\n\tip -netns \"${hsname}\" link set \"${HS_VETH_NAME}\" up\n\tip -netns \"${hsname}\" link set lo up\n\n\tip -netns \"${rtname}\" addr add \"${IPv6_HS_NETWORK}::254/64\" \\\n\t\tdev \"${RT2HS_DEVNAME}\" nodad\n\tip -netns \"${rtname}\" addr \\\n\t\tadd \"${IPv4_HS_NETWORK}.254/24\" dev \"${RT2HS_DEVNAME}\"\n\n\tip -netns \"${rtname}\" link set \"${RT2HS_DEVNAME}\" up\n\n\t# disable the rp_filter otherwise the kernel gets confused about how\n\t# to route decap ipv4 packets.\n\tip netns exec \"${rtname}\" \\\n\t\tsysctl -wq net.ipv4.conf.\"${RT2HS_DEVNAME}\".rp_filter=0\n}\n\n# set an auto-generated mac address\n# args:\n#  $1 - name of the node (e.g.: hs-1, rt-3, etc)\n#  $2 - id of the node (e.g.: 1 for hs-1, 3 for rt-3, etc)\n#  $3 - host part of the IPv6 network address\n#  $4 - name of the network interface to which the generated mac address must\n#       be set.\nset_mac_address()\n{\n\tlocal nodename=\"$1\"\n\tlocal nodeid=\"$2\"\n\tlocal host=\"$3\"\n\tlocal ifname=\"$4\"\n\tlocal nsname\n\n\tnsname=$(get_nodename \"${nodename}\")\n\n\tip -netns \"${nsname}\" link set dev \"${ifname}\" down\n\n\tip -netns \"${nsname}\" link set address \"${MAC_PREFIX}:${nodeid}\" \\\n\t\tdev \"${ifname}\"\n\n\t# the IPv6 address must be set once again after the MAC address has\n\t# been changed.\n\tip -netns \"${nsname}\" addr add \"${IPv6_HS_NETWORK}::${host}/64\" \\\n\t\tdev \"${ifname}\" nodad\n\n\tip -netns \"${nsname}\" link set dev \"${ifname}\" up\n}\n\nset_host_l2peer()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\tlocal ipprefix=\"$3\"\n\tlocal proto=\"$4\"\n\tlocal hssrc_name\n\tlocal ipaddr\n\n\thssrc_name=\"$(get_hsname \"${hssrc}\")\"\n\n\tif [ \"${proto}\" -eq 6 ]; then\n\t\tipaddr=\"${ipprefix}::${hsdst}\"\n\telse\n\t\tipaddr=\"${ipprefix}.${hsdst}\"\n\tfi\n\n\tip -netns \"${hssrc_name}\" route add \"${ipaddr}\" dev \"${HS_VETH_NAME}\"\n\n\tip -netns \"${hssrc_name}\" neigh \\\n\t\tadd \"${ipaddr}\" lladdr \"${MAC_PREFIX}:${hsdst}\" \\\n\t\tdev \"${HS_VETH_NAME}\"\n}\n\n# setup an SRv6 L2 VPN between host hs-x and hs-y (currently, the SRv6\n# subsystem only supports L2 frames whose layer-3 is IPv4/IPv6).\n# args:\n#  $1 - source host\n#  $2 - SRv6 routers configured for steering tunneled traffic\n#  $3 - destination host\nsetup_l2vpn()\n{\n\tlocal hssrc=\"$1\"\n\tlocal end_rts=\"$2\"\n\tlocal hsdst=\"$3\"\n\tlocal rtsrc=\"${hssrc}\"\n\tlocal rtdst=\"${hsdst}\"\n\n\t# set fixed mac for source node and the neigh MAC address\n\tset_mac_address \"hs-${hssrc}\" \"${hssrc}\" \"${hssrc}\" \"${HS_VETH_NAME}\"\n\tset_host_l2peer \"${hssrc}\" \"${hsdst}\" \"${IPv6_HS_NETWORK}\" 6\n\tset_host_l2peer \"${hssrc}\" \"${hsdst}\" \"${IPv4_HS_NETWORK}\" 4\n\n\t# we have to set the mac address of the veth-host (on ingress router)\n\t# to the mac address of the remote peer (L2 VPN destination host).\n\t# Otherwise, traffic coming from the source host is dropped at the\n\t# ingress router.\n\tset_mac_address \"rt-${rtsrc}\" \"${hsdst}\" 254 \"${RT2HS_DEVNAME}\"\n\n\t# set the SRv6 Policies at the ingress router\n\tsetup_rt_policy_ipv6 \"${hsdst}\" \"${rtsrc}\" \"${end_rts}\" \"${rtdst}\" \\\n\t\tl2encap.red 6\n\tsetup_rt_policy_ipv4 \"${hsdst}\" \"${rtsrc}\" \"${end_rts}\" \"${rtdst}\" \\\n\t\tl2encap.red 4\n\n\t# set the decap behavior\n\tsetup_decap \"${rtsrc}\"\n}\n\nsetup()\n{\n\tlocal i\n\n\t# create routers\n\tROUTERS=\"1 2 3 4\"; readonly ROUTERS\n\tfor i in ${ROUTERS}; do\n\t\tcreate_router \"${i}\"\n\tdone\n\n\t# create hosts\n\tHOSTS=\"1 2\"; readonly HOSTS\n\tfor i in ${HOSTS}; do\n\t\tcreate_host \"${i}\"\n\tdone\n\n\t# set up the links for connecting routers\n\tadd_link_rt_pairs 1 \"2 3 4\"\n\tadd_link_rt_pairs 2 \"3 4\"\n\tadd_link_rt_pairs 3 \"4\"\n\n\t# set up the basic connectivity of routers and routes required for\n\t# reachability of SIDs.\n\tsetup_rt_networking 1 \"2 3 4\"\n\tsetup_rt_networking 2 \"1 3 4\"\n\tsetup_rt_networking 3 \"1 2 4\"\n\tsetup_rt_networking 4 \"1 2 3\"\n\n\t# set up the hosts connected to routers\n\tsetup_hs 1 1\n\tsetup_hs 2 2\n\n\t# set up default SRv6 Endpoints (i.e. SRv6 End and SRv6 End.DX2)\n\tsetup_rt_local_sids 1 \"2 3 4\"\n\tsetup_rt_local_sids 2 \"1 3 4\"\n\tsetup_rt_local_sids 3 \"1 2 4\"\n\tsetup_rt_local_sids 4 \"1 2 3\"\n\n\t# create a L2 VPN between hs-1 and hs-2.\n\t# NB: currently, H.L2Encap* enables tunneling of L2 frames whose\n\t# layer-3 is IPv4/IPv6.\n\t#\n\t# the network path between hs-1 and hs-2 traverses several routers\n\t# depending on the direction of traffic.\n\t#\n\t# Direction hs-1 -> hs-2 (H.L2Encaps.Red)\n\t# - rt-2 (SRv6 End.DX2 behavior)\n\t#\n\t# Direction hs-2 -> hs-1 (H.L2Encaps.Red)\n\t#  - rt-4,rt-3 (SRv6 End behaviors)\n\t#  - rt-1 (SRv6 End.DX2 behavior)\n\tsetup_l2vpn 1 \"\" 2\n\tsetup_l2vpn 2 \"4 3\" 1\n\n\t# testing environment was set up successfully\n\tSETUP_ERR=0\n}\n\ncheck_rt_connectivity()\n{\n\tlocal rtsrc=\"$1\"\n\tlocal rtdst=\"$2\"\n\tlocal prefix\n\tlocal rtsrc_nsname\n\n\trtsrc_nsname=\"$(get_rtname \"${rtsrc}\")\"\n\n\tprefix=\"$(get_network_prefix \"${rtsrc}\" \"${rtdst}\")\"\n\n\tip netns exec \"${rtsrc_nsname}\" ping -c 1 -W \"${PING_TIMEOUT_SEC}\" \\\n\t\t\"${prefix}::${rtdst}\" >/dev/null 2>&1\n}\n\ncheck_and_log_rt_connectivity()\n{\n\tlocal rtsrc=\"$1\"\n\tlocal rtdst=\"$2\"\n\n\tcheck_rt_connectivity \"${rtsrc}\" \"${rtdst}\"\n\tlog_test $? 0 \"Routers connectivity: rt-${rtsrc} -> rt-${rtdst}\"\n}\n\ncheck_hs_ipv6_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\tlocal hssrc_nsname\n\n\thssrc_nsname=\"$(get_hsname \"${hssrc}\")\"\n\n\tip netns exec \"${hssrc_nsname}\" ping -c 1 -W \"${PING_TIMEOUT_SEC}\" \\\n\t\t\"${IPv6_HS_NETWORK}::${hsdst}\" >/dev/null 2>&1\n}\n\ncheck_hs_ipv4_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\tlocal hssrc_nsname\n\n\thssrc_nsname=\"$(get_hsname \"${hssrc}\")\"\n\n\tip netns exec \"${hssrc_nsname}\" ping -c 1 -W \"${PING_TIMEOUT_SEC}\" \\\n\t\t\"${IPv4_HS_NETWORK}.${hsdst}\" >/dev/null 2>&1\n}\n\ncheck_and_log_hs2gw_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\n\tcheck_hs_ipv6_connectivity \"${hssrc}\" 254\n\tlog_test $? 0 \"IPv6 Hosts connectivity: hs-${hssrc} -> gw\"\n\n\tcheck_hs_ipv4_connectivity \"${hssrc}\" 254\n\tlog_test $? 0 \"IPv4 Hosts connectivity: hs-${hssrc} -> gw\"\n}\n\ncheck_and_log_hs_ipv6_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\n\tcheck_hs_ipv6_connectivity \"${hssrc}\" \"${hsdst}\"\n\tlog_test $? 0 \"IPv6 Hosts connectivity: hs-${hssrc} -> hs-${hsdst}\"\n}\n\ncheck_and_log_hs_ipv4_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\n\tcheck_hs_ipv4_connectivity \"${hssrc}\" \"${hsdst}\"\n\tlog_test $? 0 \"IPv4 Hosts connectivity: hs-${hssrc} -> hs-${hsdst}\"\n}\n\ncheck_and_log_hs_connectivity()\n{\n\tlocal hssrc=\"$1\"\n\tlocal hsdst=\"$2\"\n\n\tcheck_and_log_hs_ipv4_connectivity \"${hssrc}\" \"${hsdst}\"\n\tcheck_and_log_hs_ipv6_connectivity \"${hssrc}\" \"${hsdst}\"\n}\n\nrouter_tests()\n{\n\tlocal i\n\tlocal j\n\n\tlog_section \"IPv6 routers connectivity test\"\n\n\tfor i in ${ROUTERS}; do\n\t\tfor j in ${ROUTERS}; do\n\t\t\tif [ \"${i}\" -eq \"${j}\" ]; then\n\t\t\t\tcontinue\n\t\t\tfi\n\n\t\t\tcheck_and_log_rt_connectivity \"${i}\" \"${j}\"\n\t\tdone\n\tdone\n}\n\nhost2gateway_tests()\n{\n\tlocal hs\n\n\tlog_section \"IPv4/IPv6 connectivity test among hosts and gateways\"\n\n\tfor hs in ${HOSTS}; do\n\t\tcheck_and_log_hs2gw_connectivity \"${hs}\"\n\tdone\n}\n\nhost_vpn_tests()\n{\n\tlog_section \"SRv6 L2 VPN connectivity test hosts (h1 <-> h2)\"\n\n\tcheck_and_log_hs_connectivity 1 2\n\tcheck_and_log_hs_connectivity 2 1\n}\n\ntest_dummy_dev_or_ksft_skip()\n{\n\tlocal test_netns\n\n\ttest_netns=\"dummy-$(mktemp -u XXXXXXXX)\"\n\n\tif ! ip netns add \"${test_netns}\"; then\n\t\techo \"SKIP: Cannot set up netns for testing dummy dev support\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\tmodprobe dummy &>/dev/null || true\n\tif ! ip -netns \"${test_netns}\" link \\\n\t\tadd \"${DUMMY_DEVNAME}\" type dummy; then\n\t\techo \"SKIP: dummy dev not supported\"\n\n\t\tip netns del \"${test_netns}\"\n\t\texit \"${ksft_skip}\"\n\tfi\n\n\tip netns del \"${test_netns}\"\n}\n\ntest_iproute2_supp_or_ksft_skip()\n{\n\tif ! ip route help 2>&1 | grep -qo \"l2encap.red\"; then\n\t\techo \"SKIP: Missing SRv6 l2encap.red support in iproute2\"\n\t\texit \"${ksft_skip}\"\n\tfi\n}\n\nif [ \"$(id -u)\" -ne 0 ]; then\n\techo \"SKIP: Need root privileges\"\n\texit \"${ksft_skip}\"\nfi\n\n# required programs to carry out this selftest\ntest_command_or_ksft_skip ip\ntest_command_or_ksft_skip ping\ntest_command_or_ksft_skip sysctl\ntest_command_or_ksft_skip grep\n\ntest_iproute2_supp_or_ksft_skip\ntest_dummy_dev_or_ksft_skip\n\nset -e\ntrap cleanup EXIT\n\nsetup\nset +e\n\nrouter_tests\nhost2gateway_tests\nhost_vpn_tests\n\nprint_log_test_results\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}