{
  "module_name": "nat6to4.c",
  "hash_id": "6a46b9b81f0ba006dcd4cdedaecc9aabb2c2737ef827974455943005bbd43448",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/nat6to4.c",
  "human_readable_source": "\n \n#include <linux/bpf.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/pkt_cls.h>\n#include <linux/swab.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n\n#include <linux/udp.h>\n\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_endian.h>\n\n#define IP_DF 0x4000  \n\nSEC(\"schedcls/ingress6/nat_6\")\nint sched_cls_ingress6_nat_6_prog(struct __sk_buff *skb)\n{\n\tconst int l2_header_size =  sizeof(struct ethhdr);\n\tvoid *data = (void *)(long)skb->data;\n\tconst void *data_end = (void *)(long)skb->data_end;\n\tconst struct ethhdr * const eth = data;  \n\tconst struct ipv6hdr * const ip6 =  (void *)(eth + 1);\n\n\t\n\tif  (skb->pkt_type != PACKET_HOST)\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (skb->protocol != bpf_htons(ETH_P_IPV6))\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (data + l2_header_size + sizeof(*ip6) > data_end)\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (eth->h_proto != bpf_htons(ETH_P_IPV6))\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (ip6->version != 6)\n\t\treturn TC_ACT_OK;\n\t\n\tif (bpf_ntohs(ip6->payload_len) > 0xFFFF - sizeof(struct iphdr))\n\t\treturn TC_ACT_OK;\n\tswitch (ip6->nexthdr) {\n\tcase IPPROTO_TCP:  \n\tcase IPPROTO_UDP:  \n\tcase IPPROTO_GRE:  \n\tcase IPPROTO_ESP:  \n\t\tbreak;\n\tdefault:  \n\t\treturn TC_ACT_OK;\n\t}\n\n\tstruct ethhdr eth2;  \n\n\teth2 = *eth;                     \n\teth2.h_proto = bpf_htons(ETH_P_IP);  \n\n\tstruct iphdr ip = {\n\t\t.version = 4,                                                      \n\t\t.ihl = sizeof(struct iphdr) / sizeof(__u32),                       \n\t\t.tos = (ip6->priority << 4) + (ip6->flow_lbl[0] >> 4),             \n\t\t.tot_len = bpf_htons(bpf_ntohs(ip6->payload_len) + sizeof(struct iphdr)),  \n\t\t.id = 0,                                                           \n\t\t.frag_off = bpf_htons(IP_DF),                                          \n\t\t.ttl = ip6->hop_limit,                                             \n\t\t.protocol = ip6->nexthdr,                                          \n\t\t.check = 0,                                                        \n\t\t.saddr = 0x0201a8c0,                            \n\t\t.daddr = 0x0101a8c0,                                         \n\t};\n\n\t\n\t__wsum sum4 = 0;\n\n\tfor (int i = 0; i < sizeof(ip) / sizeof(__u16); ++i)\n\t\tsum4 += ((__u16 *)&ip)[i];\n\n\t\n\tsum4 = (sum4 & 0xFFFF) + (sum4 >> 16);  \n\tsum4 = (sum4 & 0xFFFF) + (sum4 >> 16);  \n\tip.check = (__u16)~sum4;                \n\n\t\n\t__wsum sum6 = 0;\n\t\n\tfor (int i = 0; i < sizeof(*ip6) / sizeof(__u16); ++i)\n\t\tsum6 += ~((__u16 *)ip6)[i];  \n\n\t\n\t\n\n\t\n\t\n\tif (bpf_skb_change_proto(skb, bpf_htons(ETH_P_IP), 0))\n\t\treturn TC_ACT_OK;\n\tbpf_csum_update(skb, sum6);\n\n\tdata = (void *)(long)skb->data;\n\tdata_end = (void *)(long)skb->data_end;\n\tif (data + l2_header_size + sizeof(struct iphdr) > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tstruct ethhdr *new_eth = data;\n\n\t\n\t*new_eth = eth2;\n\n\t\n\t*(struct iphdr *)(new_eth + 1) = ip;\n\treturn bpf_redirect(skb->ifindex, BPF_F_INGRESS);\n}\n\nSEC(\"schedcls/egress4/snat4\")\nint sched_cls_egress4_snat4_prog(struct __sk_buff *skb)\n{\n\tconst int l2_header_size =  sizeof(struct ethhdr);\n\tvoid *data = (void *)(long)skb->data;\n\tconst void *data_end = (void *)(long)skb->data_end;\n\tconst struct ethhdr *const eth = data;  \n\tconst struct iphdr *const ip4 = (void *)(eth + 1);\n\n\t\n\tif (skb->protocol != bpf_htons(ETH_P_IP))\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (data + l2_header_size + sizeof(struct ipv6hdr) > data_end)\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (eth->h_proto != bpf_htons(ETH_P_IP))\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (ip4->version != 4)\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (ip4->ihl != 5)\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (bpf_htons(ip4->tot_len) > 0xFFFF - sizeof(struct ipv6hdr))\n\t\treturn TC_ACT_OK;\n\n\t\n\t__wsum sum4 = 0;\n\n\tfor (int i = 0; i < sizeof(*ip4) / sizeof(__u16); ++i)\n\t\tsum4 += ((__u16 *)ip4)[i];\n\n\t\n\tsum4 = (sum4 & 0xFFFF) + (sum4 >> 16);  \n\tsum4 = (sum4 & 0xFFFF) + (sum4 >> 16);  \n\t\n\tif (sum4 != 0xFFFF)\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (bpf_ntohs(ip4->tot_len) < sizeof(*ip4))\n\t\treturn TC_ACT_OK;\n\n\t\n\tif (ip4->frag_off & ~bpf_htons(IP_DF))\n\t\treturn TC_ACT_OK;\n\n\tswitch (ip4->protocol) {\n\tcase IPPROTO_TCP:  \n\tcase IPPROTO_GRE:  \n\tcase IPPROTO_ESP:  \n\t\tbreak;         \n\n\tcase IPPROTO_UDP:  \n\t\tif (data + sizeof(*ip4) + sizeof(struct udphdr) > data_end)\n\t\t\treturn TC_ACT_OK;\n\t\tconst struct udphdr *uh = (const struct udphdr *)(ip4 + 1);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif (!uh->check)\n\t\t\treturn TC_ACT_OK;\n\t\tbreak;\n\n\tdefault:  \n\t\treturn TC_ACT_OK;\n\t}\n\tstruct ethhdr eth2;  \n\n\teth2 = *eth;                     \n\teth2.h_proto = bpf_htons(ETH_P_IPV6);  \n\n\tstruct ipv6hdr ip6 = {\n\t\t.version = 6,                                    \n\t\t.priority = ip4->tos >> 4,                       \n\t\t.flow_lbl = {(ip4->tos & 0xF) << 4, 0, 0},       \n\t\t.payload_len = bpf_htons(bpf_ntohs(ip4->tot_len) - 20),  \n\t\t.nexthdr = ip4->protocol,                        \n\t\t.hop_limit = ip4->ttl,                           \n\t};\n\tip6.saddr.in6_u.u6_addr32[0] = bpf_htonl(0x20010db8);\n\tip6.saddr.in6_u.u6_addr32[1] = 0;\n\tip6.saddr.in6_u.u6_addr32[2] = 0;\n\tip6.saddr.in6_u.u6_addr32[3] = bpf_htonl(1);\n\tip6.daddr.in6_u.u6_addr32[0] = bpf_htonl(0x20010db8);\n\tip6.daddr.in6_u.u6_addr32[1] = 0;\n\tip6.daddr.in6_u.u6_addr32[2] = 0;\n\tip6.daddr.in6_u.u6_addr32[3] = bpf_htonl(2);\n\n\t\n\t__wsum sum6 = 0;\n\t\n\tfor (int i = 0; i < sizeof(ip6) / sizeof(__u16); ++i)\n\t\tsum6 += ((__u16 *)&ip6)[i];\n\n\t\n\t\n\tif (bpf_skb_change_proto(skb, bpf_htons(ETH_P_IPV6), 0))\n\t\treturn TC_ACT_OK;\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tbpf_csum_update(skb, sum6);\n\n\t\n\tdata = (void *)(long)skb->data;\n\tdata_end = (void *)(long)skb->data_end;\n\n\t\n\t\n\tif (data + l2_header_size + sizeof(ip6) > data_end)\n\t\treturn TC_ACT_SHOT;\n\n\tstruct ethhdr *new_eth = data;\n\n\t\n\t*new_eth = eth2;\n\t\n\t*(struct ipv6hdr *)(new_eth + 1) = ip6;\n\treturn TC_ACT_OK;\n}\n\nchar _license[] SEC(\"license\") = (\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}