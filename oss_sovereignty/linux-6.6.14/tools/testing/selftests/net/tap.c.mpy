{
  "module_name": "tap.c",
  "hash_id": "8eb17c0da36ade458f2f4a3a7cc4c2b98de68c735ccc85bcfdf644b8dfaf0b38",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/tap.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <net/if.h>\n#include <linux/if_tun.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <linux/virtio_net.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include \"../kselftest_harness.h\"\n\nstatic const char param_dev_tap_name[] = \"xmacvtap0\";\nstatic const char param_dev_dummy_name[] = \"xdummy0\";\nstatic unsigned char param_hwaddr_src[] = { 0x00, 0xfe, 0x98, 0x14, 0x22, 0x42 };\nstatic unsigned char param_hwaddr_dest[] = {\n\t0x00, 0xfe, 0x98, 0x94, 0xd2, 0x43\n};\n\n#define MAX_RTNL_PAYLOAD (2048)\n#define PKT_DATA 0xCB\n#define TEST_PACKET_SZ (sizeof(struct virtio_net_hdr) + ETH_HLEN + ETH_MAX_MTU)\n\nstatic struct rtattr *rtattr_add(struct nlmsghdr *nh, unsigned short type,\n\t\t\t\t unsigned short len)\n{\n\tstruct rtattr *rta =\n\t\t(struct rtattr *)((uint8_t *)nh + RTA_ALIGN(nh->nlmsg_len));\n\trta->rta_type = type;\n\trta->rta_len = RTA_LENGTH(len);\n\tnh->nlmsg_len = RTA_ALIGN(nh->nlmsg_len) + RTA_ALIGN(rta->rta_len);\n\treturn rta;\n}\n\nstatic struct rtattr *rtattr_begin(struct nlmsghdr *nh, unsigned short type)\n{\n\treturn rtattr_add(nh, type, 0);\n}\n\nstatic void rtattr_end(struct nlmsghdr *nh, struct rtattr *attr)\n{\n\tuint8_t *end = (uint8_t *)nh + nh->nlmsg_len;\n\n\tattr->rta_len = end - (uint8_t *)attr;\n}\n\nstatic struct rtattr *rtattr_add_str(struct nlmsghdr *nh, unsigned short type,\n\t\t\t\t     const char *s)\n{\n\tstruct rtattr *rta = rtattr_add(nh, type, strlen(s));\n\n\tmemcpy(RTA_DATA(rta), s, strlen(s));\n\treturn rta;\n}\n\nstatic struct rtattr *rtattr_add_strsz(struct nlmsghdr *nh, unsigned short type,\n\t\t\t\t       const char *s)\n{\n\tstruct rtattr *rta = rtattr_add(nh, type, strlen(s) + 1);\n\n\tstrcpy(RTA_DATA(rta), s);\n\treturn rta;\n}\n\nstatic struct rtattr *rtattr_add_any(struct nlmsghdr *nh, unsigned short type,\n\t\t\t\t     const void *arr, size_t len)\n{\n\tstruct rtattr *rta = rtattr_add(nh, type, len);\n\n\tmemcpy(RTA_DATA(rta), arr, len);\n\treturn rta;\n}\n\nstatic int dev_create(const char *dev, const char *link_type,\n\t\t      int (*fill_rtattr)(struct nlmsghdr *nh),\n\t\t      int (*fill_info_data)(struct nlmsghdr *nh))\n{\n\tstruct {\n\t\tstruct nlmsghdr nh;\n\t\tstruct ifinfomsg info;\n\t\tunsigned char data[MAX_RTNL_PAYLOAD];\n\t} req;\n\tstruct rtattr *link_info, *info_data;\n\tint ret, rtnl;\n\n\trtnl = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\n\tif (rtnl < 0) {\n\t\tfprintf(stderr, \"%s: socket %s\\n\", __func__, strerror(errno));\n\t\treturn 1;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len = NLMSG_LENGTH(sizeof(req.info));\n\treq.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;\n\treq.nh.nlmsg_type = RTM_NEWLINK;\n\n\treq.info.ifi_family = AF_UNSPEC;\n\treq.info.ifi_type = 1;\n\treq.info.ifi_index = 0;\n\treq.info.ifi_flags = IFF_BROADCAST | IFF_UP;\n\treq.info.ifi_change = 0xffffffff;\n\n\trtattr_add_str(&req.nh, IFLA_IFNAME, dev);\n\n\tif (fill_rtattr) {\n\t\tret = fill_rtattr(&req.nh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tlink_info = rtattr_begin(&req.nh, IFLA_LINKINFO);\n\n\trtattr_add_strsz(&req.nh, IFLA_INFO_KIND, link_type);\n\n\tif (fill_info_data) {\n\t\tinfo_data = rtattr_begin(&req.nh, IFLA_INFO_DATA);\n\t\tret = fill_info_data(&req.nh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trtattr_end(&req.nh, info_data);\n\t}\n\n\trtattr_end(&req.nh, link_info);\n\n\tret = send(rtnl, &req, req.nh.nlmsg_len, 0);\n\tif (ret < 0)\n\t\tfprintf(stderr, \"%s: send %s\\n\", __func__, strerror(errno));\n\tret = (unsigned int)ret != req.nh.nlmsg_len;\n\n\tclose(rtnl);\n\treturn ret;\n}\n\nstatic int dev_delete(const char *dev)\n{\n\tstruct {\n\t\tstruct nlmsghdr nh;\n\t\tstruct ifinfomsg info;\n\t\tunsigned char data[MAX_RTNL_PAYLOAD];\n\t} req;\n\tint ret, rtnl;\n\n\trtnl = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\n\tif (rtnl < 0) {\n\t\tfprintf(stderr, \"%s: socket %s\\n\", __func__, strerror(errno));\n\t\treturn 1;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len = NLMSG_LENGTH(sizeof(req.info));\n\treq.nh.nlmsg_flags = NLM_F_REQUEST;\n\treq.nh.nlmsg_type = RTM_DELLINK;\n\n\treq.info.ifi_family = AF_UNSPEC;\n\n\trtattr_add_str(&req.nh, IFLA_IFNAME, dev);\n\n\tret = send(rtnl, &req, req.nh.nlmsg_len, 0);\n\tif (ret < 0)\n\t\tfprintf(stderr, \"%s: send %s\\n\", __func__, strerror(errno));\n\n\tret = (unsigned int)ret != req.nh.nlmsg_len;\n\n\tclose(rtnl);\n\treturn ret;\n}\n\nstatic int macvtap_fill_rtattr(struct nlmsghdr *nh)\n{\n\tint ifindex;\n\n\tifindex = if_nametoindex(param_dev_dummy_name);\n\tif (ifindex == 0) {\n\t\tfprintf(stderr, \"%s: ifindex  %s\\n\", __func__, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\trtattr_add_any(nh, IFLA_LINK, &ifindex, sizeof(ifindex));\n\trtattr_add_any(nh, IFLA_ADDRESS, param_hwaddr_src, ETH_ALEN);\n\n\treturn 0;\n}\n\nstatic int opentap(const char *devname)\n{\n\tint ifindex;\n\tchar buf[256];\n\tint fd;\n\tstruct ifreq ifr;\n\n\tifindex = if_nametoindex(devname);\n\tif (ifindex == 0) {\n\t\tfprintf(stderr, \"%s: ifindex %s\\n\", __func__, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\tsprintf(buf, \"/dev/tap%d\", ifindex);\n\tfd = open(buf, O_RDWR | O_NONBLOCK);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"%s: open %s\\n\", __func__, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrcpy(ifr.ifr_name, devname);\n\tifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_VNET_HDR | IFF_MULTI_QUEUE;\n\tif (ioctl(fd, TUNSETIFF, &ifr, sizeof(ifr)) < 0)\n\t\treturn -errno;\n\treturn fd;\n}\n\nsize_t build_eth(uint8_t *buf, uint16_t proto)\n{\n\tstruct ethhdr *eth = (struct ethhdr *)buf;\n\n\teth->h_proto = htons(proto);\n\tmemcpy(eth->h_source, param_hwaddr_src, ETH_ALEN);\n\tmemcpy(eth->h_dest, param_hwaddr_dest, ETH_ALEN);\n\n\treturn ETH_HLEN;\n}\n\nstatic uint32_t add_csum(const uint8_t *buf, int len)\n{\n\tuint32_t sum = 0;\n\tuint16_t *sbuf = (uint16_t *)buf;\n\n\twhile (len > 1) {\n\t\tsum += *sbuf++;\n\t\tlen -= 2;\n\t}\n\n\tif (len)\n\t\tsum += *(uint8_t *)sbuf;\n\n\treturn sum;\n}\n\nstatic uint16_t finish_ip_csum(uint32_t sum)\n{\n\tuint16_t lo = sum & 0xffff;\n\tuint16_t hi = sum >> 16;\n\n\treturn ~(lo + hi);\n\n}\n\nstatic uint16_t build_ip_csum(const uint8_t *buf, int len,\n\t\t\t      uint32_t sum)\n{\n\tsum += add_csum(buf, len);\n\treturn finish_ip_csum(sum);\n}\n\nstatic int build_ipv4_header(uint8_t *buf, int payload_len)\n{\n\tstruct iphdr *iph = (struct iphdr *)buf;\n\n\tiph->ihl = 5;\n\tiph->version = 4;\n\tiph->ttl = 8;\n\tiph->tot_len =\n\t\thtons(sizeof(*iph) + sizeof(struct udphdr) + payload_len);\n\tiph->id = htons(1337);\n\tiph->protocol = IPPROTO_UDP;\n\tiph->saddr = htonl((172 << 24) | (17 << 16) | 2);\n\tiph->daddr = htonl((172 << 24) | (17 << 16) | 1);\n\tiph->check = build_ip_csum(buf, iph->ihl << 2, 0);\n\n\treturn iph->ihl << 2;\n}\n\nstatic int build_udp_packet(uint8_t *buf, int payload_len, bool csum_off)\n{\n\tconst int ip4alen = sizeof(uint32_t);\n\tstruct udphdr *udph = (struct udphdr *)buf;\n\tint len = sizeof(*udph) + payload_len;\n\tuint32_t sum = 0;\n\n\tudph->source = htons(22);\n\tudph->dest = htons(58822);\n\tudph->len = htons(len);\n\n\tmemset(buf + sizeof(struct udphdr), PKT_DATA, payload_len);\n\n\tsum = add_csum(buf - 2 * ip4alen, 2 * ip4alen);\n\tsum += htons(IPPROTO_UDP) + udph->len;\n\n\tif (!csum_off)\n\t\tsum += add_csum(buf, len);\n\n\tudph->check = finish_ip_csum(sum);\n\n\treturn sizeof(*udph) + payload_len;\n}\n\nsize_t build_test_packet_valid_udp_gso(uint8_t *buf, size_t payload_len)\n{\n\tuint8_t *cur = buf;\n\tstruct virtio_net_hdr *vh = (struct virtio_net_hdr *)buf;\n\n\tvh->hdr_len = ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr);\n\tvh->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\tvh->csum_start = ETH_HLEN + sizeof(struct iphdr);\n\tvh->csum_offset = __builtin_offsetof(struct udphdr, check);\n\tvh->gso_type = VIRTIO_NET_HDR_GSO_UDP;\n\tvh->gso_size = ETH_DATA_LEN - sizeof(struct iphdr);\n\tcur += sizeof(*vh);\n\n\tcur += build_eth(cur, ETH_P_IP);\n\tcur += build_ipv4_header(cur, payload_len);\n\tcur += build_udp_packet(cur, payload_len, true);\n\n\treturn cur - buf;\n}\n\nsize_t build_test_packet_valid_udp_csum(uint8_t *buf, size_t payload_len)\n{\n\tuint8_t *cur = buf;\n\tstruct virtio_net_hdr *vh = (struct virtio_net_hdr *)buf;\n\n\tvh->flags = VIRTIO_NET_HDR_F_DATA_VALID;\n\tvh->gso_type = VIRTIO_NET_HDR_GSO_NONE;\n\tcur += sizeof(*vh);\n\n\tcur += build_eth(cur, ETH_P_IP);\n\tcur += build_ipv4_header(cur, payload_len);\n\tcur += build_udp_packet(cur, payload_len, false);\n\n\treturn cur - buf;\n}\n\nsize_t build_test_packet_crash_tap_invalid_eth_proto(uint8_t *buf,\n\t\t\t\t\t\t     size_t payload_len)\n{\n\tuint8_t *cur = buf;\n\tstruct virtio_net_hdr *vh = (struct virtio_net_hdr *)buf;\n\n\tvh->hdr_len = ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr);\n\tvh->flags = 0;\n\tvh->gso_type = VIRTIO_NET_HDR_GSO_UDP;\n\tvh->gso_size = ETH_DATA_LEN - sizeof(struct iphdr);\n\tcur += sizeof(*vh);\n\n\tcur += build_eth(cur, 0);\n\tcur += sizeof(struct iphdr) + sizeof(struct udphdr);\n\tcur += build_ipv4_header(cur, payload_len);\n\tcur += build_udp_packet(cur, payload_len, true);\n\tcur += payload_len;\n\n\treturn cur - buf;\n}\n\nFIXTURE(tap)\n{\n\tint fd;\n};\n\nFIXTURE_SETUP(tap)\n{\n\tint ret;\n\n\tret = dev_create(param_dev_dummy_name, \"dummy\", NULL, NULL);\n\tEXPECT_EQ(ret, 0);\n\n\tret = dev_create(param_dev_tap_name, \"macvtap\", macvtap_fill_rtattr,\n\t\t\t NULL);\n\tEXPECT_EQ(ret, 0);\n\n\tself->fd = opentap(param_dev_tap_name);\n\tASSERT_GE(self->fd, 0);\n}\n\nFIXTURE_TEARDOWN(tap)\n{\n\tint ret;\n\n\tif (self->fd != -1)\n\t\tclose(self->fd);\n\n\tret = dev_delete(param_dev_tap_name);\n\tEXPECT_EQ(ret, 0);\n\n\tret = dev_delete(param_dev_dummy_name);\n\tEXPECT_EQ(ret, 0);\n}\n\nTEST_F(tap, test_packet_valid_udp_gso)\n{\n\tuint8_t pkt[TEST_PACKET_SZ];\n\tsize_t off;\n\tint ret;\n\n\tmemset(pkt, 0, sizeof(pkt));\n\toff = build_test_packet_valid_udp_gso(pkt, 1021);\n\tret = write(self->fd, pkt, off);\n\tASSERT_EQ(ret, off);\n}\n\nTEST_F(tap, test_packet_valid_udp_csum)\n{\n\tuint8_t pkt[TEST_PACKET_SZ];\n\tsize_t off;\n\tint ret;\n\n\tmemset(pkt, 0, sizeof(pkt));\n\toff = build_test_packet_valid_udp_csum(pkt, 1024);\n\tret = write(self->fd, pkt, off);\n\tASSERT_EQ(ret, off);\n}\n\nTEST_F(tap, test_packet_crash_tap_invalid_eth_proto)\n{\n\tuint8_t pkt[TEST_PACKET_SZ];\n\tsize_t off;\n\tint ret;\n\n\tmemset(pkt, 0, sizeof(pkt));\n\toff = build_test_packet_crash_tap_invalid_eth_proto(pkt, 1024);\n\tret = write(self->fd, pkt, off);\n\tASSERT_EQ(ret, -1);\n\tASSERT_EQ(errno, EINVAL);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}