{
  "module_name": "reuseport_bpf_cpu.c",
  "hash_id": "1582dff91207f549e4e39e3a3724de4112117e63fa69b0154cadc17744c53b23",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/reuseport_bpf_cpu.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <linux/filter.h>\n#include <linux/in.h>\n#include <linux/unistd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nstatic const int PORT = 8888;\n\nstatic void build_rcv_group(int *rcv_fd, size_t len, int family, int proto)\n{\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in  *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tsize_t i;\n\tint opt;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr4 = (struct sockaddr_in *)&addr;\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\t\taddr4->sin_port = htons(PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddr6 = (struct sockaddr_in6 *)&addr;\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_addr = in6addr_any;\n\t\taddr6->sin6_port = htons(PORT);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t}\n\n\tfor (i = 0; i < len; ++i) {\n\t\trcv_fd[i] = socket(family, proto, 0);\n\t\tif (rcv_fd[i] < 0)\n\t\t\terror(1, errno, \"failed to create receive socket\");\n\n\t\topt = 1;\n\t\tif (setsockopt(rcv_fd[i], SOL_SOCKET, SO_REUSEPORT, &opt,\n\t\t\t       sizeof(opt)))\n\t\t\terror(1, errno, \"failed to set SO_REUSEPORT\");\n\n\t\tif (bind(rcv_fd[i], (struct sockaddr *)&addr, sizeof(addr)))\n\t\t\terror(1, errno, \"failed to bind receive socket\");\n\n\t\tif (proto == SOCK_STREAM && listen(rcv_fd[i], len * 10))\n\t\t\terror(1, errno, \"failed to listen on receive port\");\n\t}\n}\n\nstatic void attach_bpf(int fd)\n{\n\tstruct sock_filter code[] = {\n\t\t \n\t\t{ BPF_LD  | BPF_W | BPF_ABS, 0, 0, SKF_AD_OFF + SKF_AD_CPU },\n\t\t \n\t\t{ BPF_RET | BPF_A, 0, 0, 0 },\n\t};\n\tstruct sock_fprog p = {\n\t\t.len = 2,\n\t\t.filter = code,\n\t};\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_REUSEPORT_CBPF, &p, sizeof(p)))\n\t\terror(1, errno, \"failed to set SO_ATTACH_REUSEPORT_CBPF\");\n}\n\nstatic void send_from_cpu(int cpu_id, int family, int proto)\n{\n\tstruct sockaddr_storage saddr, daddr;\n\tstruct sockaddr_in  *saddr4, *daddr4;\n\tstruct sockaddr_in6 *saddr6, *daddr6;\n\tcpu_set_t cpu_set;\n\tint fd;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tsaddr4 = (struct sockaddr_in *)&saddr;\n\t\tsaddr4->sin_family = AF_INET;\n\t\tsaddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tsaddr4->sin_port = 0;\n\n\t\tdaddr4 = (struct sockaddr_in *)&daddr;\n\t\tdaddr4->sin_family = AF_INET;\n\t\tdaddr4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tdaddr4->sin_port = htons(PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsaddr6 = (struct sockaddr_in6 *)&saddr;\n\t\tsaddr6->sin6_family = AF_INET6;\n\t\tsaddr6->sin6_addr = in6addr_any;\n\t\tsaddr6->sin6_port = 0;\n\n\t\tdaddr6 = (struct sockaddr_in6 *)&daddr;\n\t\tdaddr6->sin6_family = AF_INET6;\n\t\tdaddr6->sin6_addr = in6addr_loopback;\n\t\tdaddr6->sin6_port = htons(PORT);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t}\n\n\tmemset(&cpu_set, 0, sizeof(cpu_set));\n\tCPU_SET(cpu_id, &cpu_set);\n\tif (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) < 0)\n\t\terror(1, errno, \"failed to pin to cpu\");\n\n\tfd = socket(family, proto, 0);\n\tif (fd < 0)\n\t\terror(1, errno, \"failed to create send socket\");\n\n\tif (bind(fd, (struct sockaddr *)&saddr, sizeof(saddr)))\n\t\terror(1, errno, \"failed to bind send socket\");\n\n\tif (connect(fd, (struct sockaddr *)&daddr, sizeof(daddr)))\n\t\terror(1, errno, \"failed to connect send socket\");\n\n\tif (send(fd, \"a\", 1, 0) < 0)\n\t\terror(1, errno, \"failed to send message\");\n\n\tclose(fd);\n}\n\nstatic\nvoid receive_on_cpu(int *rcv_fd, int len, int epfd, int cpu_id, int proto)\n{\n\tstruct epoll_event ev;\n\tint i, fd;\n\tchar buf[8];\n\n\ti = epoll_wait(epfd, &ev, 1, -1);\n\tif (i < 0)\n\t\terror(1, errno, \"epoll_wait failed\");\n\n\tif (proto == SOCK_STREAM) {\n\t\tfd = accept(ev.data.fd, NULL, NULL);\n\t\tif (fd < 0)\n\t\t\terror(1, errno, \"failed to accept\");\n\t\ti = recv(fd, buf, sizeof(buf), 0);\n\t\tclose(fd);\n\t} else {\n\t\ti = recv(ev.data.fd, buf, sizeof(buf), 0);\n\t}\n\n\tif (i < 0)\n\t\terror(1, errno, \"failed to recv\");\n\n\tfor (i = 0; i < len; ++i)\n\t\tif (ev.data.fd == rcv_fd[i])\n\t\t\tbreak;\n\tif (i == len)\n\t\terror(1, 0, \"failed to find socket\");\n\tfprintf(stderr, \"send cpu %d, receive socket %d\\n\", cpu_id, i);\n\tif (cpu_id != i)\n\t\terror(1, 0, \"cpu id/receive socket mismatch\");\n}\n\nstatic void test(int *rcv_fd, int len, int family, int proto)\n{\n\tstruct epoll_event ev;\n\tint epfd, cpu;\n\n\tbuild_rcv_group(rcv_fd, len, family, proto);\n\tattach_bpf(rcv_fd[0]);\n\n\tepfd = epoll_create(1);\n\tif (epfd < 0)\n\t\terror(1, errno, \"failed to create epoll\");\n\tfor (cpu = 0; cpu < len; ++cpu) {\n\t\tev.events = EPOLLIN;\n\t\tev.data.fd = rcv_fd[cpu];\n\t\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, rcv_fd[cpu], &ev))\n\t\t\terror(1, errno, \"failed to register sock epoll\");\n\t}\n\n\t \n\tfor (cpu = 0; cpu < len; ++cpu) {\n\t\tsend_from_cpu(cpu, family, proto);\n\t\treceive_on_cpu(rcv_fd, len, epfd, cpu, proto);\n\t}\n\n\t \n\tfor (cpu = len - 1; cpu >= 0; --cpu) {\n\t\tsend_from_cpu(cpu, family, proto);\n\t\treceive_on_cpu(rcv_fd, len, epfd, cpu, proto);\n\t}\n\n\t \n\tfor (cpu = 0; cpu < len; cpu += 2) {\n\t\tsend_from_cpu(cpu, family, proto);\n\t\treceive_on_cpu(rcv_fd, len, epfd, cpu, proto);\n\t}\n\n\t \n\tfor (cpu = 1; cpu < len; cpu += 2) {\n\t\tsend_from_cpu(cpu, family, proto);\n\t\treceive_on_cpu(rcv_fd, len, epfd, cpu, proto);\n\t}\n\n\tclose(epfd);\n\tfor (cpu = 0; cpu < len; ++cpu)\n\t\tclose(rcv_fd[cpu]);\n}\n\nint main(void)\n{\n\tint *rcv_fd, cpus;\n\n\tcpus = sysconf(_SC_NPROCESSORS_ONLN);\n\tif (cpus <= 0)\n\t\terror(1, errno, \"failed counting cpus\");\n\n\trcv_fd = calloc(cpus, sizeof(int));\n\tif (!rcv_fd)\n\t\terror(1, 0, \"failed to allocate array\");\n\n\tfprintf(stderr, \"---- IPv4 UDP ----\\n\");\n\ttest(rcv_fd, cpus, AF_INET, SOCK_DGRAM);\n\n\tfprintf(stderr, \"---- IPv6 UDP ----\\n\");\n\ttest(rcv_fd, cpus, AF_INET6, SOCK_DGRAM);\n\n\tfprintf(stderr, \"---- IPv4 TCP ----\\n\");\n\ttest(rcv_fd, cpus, AF_INET, SOCK_STREAM);\n\n\tfprintf(stderr, \"---- IPv6 TCP ----\\n\");\n\ttest(rcv_fd, cpus, AF_INET6, SOCK_STREAM);\n\n\tfree(rcv_fd);\n\n\tfprintf(stderr, \"SUCCESS\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}