{
  "module_name": "timestamping.c",
  "hash_id": "c4bd77cb60a651996afc56c6b0e0c96d2abbd14a975b4ce397728eb5b27f1be5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/timestamping.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n\n#include <asm/types.h>\n#include <linux/net_tstamp.h>\n#include <linux/errqueue.h>\n#include <linux/sockios.h>\n\n#ifndef SO_TIMESTAMPING\n# define SO_TIMESTAMPING         37\n# define SCM_TIMESTAMPING        SO_TIMESTAMPING\n#endif\n\n#ifndef SO_TIMESTAMPNS\n# define SO_TIMESTAMPNS 35\n#endif\n\nstatic void usage(const char *error)\n{\n\tif (error)\n\t\tprintf(\"invalid option: %s\\n\", error);\n\tprintf(\"timestamping <interface> [bind_phc_index] [option]*\\n\\n\"\n\t       \"Options:\\n\"\n\t       \"  IP_MULTICAST_LOOP - looping outgoing multicasts\\n\"\n\t       \"  SO_TIMESTAMP - normal software time stamping, ms resolution\\n\"\n\t       \"  SO_TIMESTAMPNS - more accurate software time stamping\\n\"\n\t       \"  SOF_TIMESTAMPING_TX_HARDWARE - hardware time stamping of outgoing packets\\n\"\n\t       \"  SOF_TIMESTAMPING_TX_SOFTWARE - software fallback for outgoing packets\\n\"\n\t       \"  SOF_TIMESTAMPING_RX_HARDWARE - hardware time stamping of incoming packets\\n\"\n\t       \"  SOF_TIMESTAMPING_RX_SOFTWARE - software fallback for incoming packets\\n\"\n\t       \"  SOF_TIMESTAMPING_SOFTWARE - request reporting of software time stamps\\n\"\n\t       \"  SOF_TIMESTAMPING_RAW_HARDWARE - request reporting of raw HW time stamps\\n\"\n\t       \"  SOF_TIMESTAMPING_BIND_PHC - request to bind a PHC of PTP vclock\\n\"\n\t       \"  SIOCGSTAMP - check last socket time stamp\\n\"\n\t       \"  SIOCGSTAMPNS - more accurate socket time stamp\\n\"\n\t       \"  PTPV2 - use PTPv2 messages\\n\");\n\texit(1);\n}\n\nstatic void bail(const char *error)\n{\n\tprintf(\"%s: %s\\n\", error, strerror(errno));\n\texit(1);\n}\n\nstatic const unsigned char sync[] = {\n\t0x00, 0x01, 0x00, 0x01,\n\t0x5f, 0x44, 0x46, 0x4c,\n\t0x54, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x01, 0x01,\n\n\t \n\t0x00, 0x01,\n\t0x02, 0x03, 0x04, 0x05,\n\n\t0x00, 0x01, 0x00, 0x37,\n\t0x00, 0x00, 0x00, 0x08,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x49, 0x05, 0xcd, 0x01,\n\t0x29, 0xb1, 0x8d, 0xb0,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x01,\n\n\t \n\t0x00, 0x01,\n\t0x02, 0x03, 0x04, 0x05,\n\n\t0x00, 0x00, 0x00, 0x37,\n\t0x00, 0x00, 0x00, 0x04,\n\t0x44, 0x46, 0x4c, 0x54,\n\t0x00, 0x00, 0xf0, 0x60,\n\t0x00, 0x01, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x01,\n\t0x00, 0x00, 0xf0, 0x60,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x04,\n\t0x44, 0x46, 0x4c, 0x54,\n\t0x00, 0x01,\n\n\t \n\t0x00, 0x01,\n\t0x02, 0x03, 0x04, 0x05,\n\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char sync_v2[] = {\n\t0x00, 0x02, 0x00, 0x2C,\n\t0x00, 0x00, 0x02, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0xFF,\n\t0xFE, 0x00, 0x00, 0x00,\n\t0x00, 0x01, 0x00, 0x01,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\n};\n\nstatic void sendpacket(int sock, struct sockaddr *addr, socklen_t addr_len, int ptpv2)\n{\n\tsize_t sync_len = ptpv2 ? sizeof(sync_v2) : sizeof(sync);\n\tconst void *sync_p = ptpv2 ? sync_v2 : sync;\n\tstruct timeval now;\n\tint res;\n\n\tres = sendto(sock, sync_p, sync_len, 0, addr, addr_len);\n\tgettimeofday(&now, 0);\n\tif (res < 0)\n\t\tprintf(\"%s: %s\\n\", \"send\", strerror(errno));\n\telse\n\t\tprintf(\"%ld.%06ld: sent %d bytes\\n\",\n\t\t       (long)now.tv_sec, (long)now.tv_usec,\n\t\t       res);\n}\n\nstatic void printpacket(struct msghdr *msg, int res,\n\t\t\tchar *data,\n\t\t\tint sock, int recvmsg_flags,\n\t\t\tint siocgstamp, int siocgstampns, int ptpv2)\n{\n\tstruct sockaddr_in *from_addr = (struct sockaddr_in *)msg->msg_name;\n\tsize_t sync_len = ptpv2 ? sizeof(sync_v2) : sizeof(sync);\n\tconst void *sync_p = ptpv2 ? sync_v2 : sync;\n\tstruct cmsghdr *cmsg;\n\tstruct timeval tv;\n\tstruct timespec ts;\n\tstruct timeval now;\n\n\tgettimeofday(&now, 0);\n\n\tprintf(\"%ld.%06ld: received %s data, %d bytes from %s, %zu bytes control messages\\n\",\n\t       (long)now.tv_sec, (long)now.tv_usec,\n\t       (recvmsg_flags & MSG_ERRQUEUE) ? \"error\" : \"regular\",\n\t       res,\n\t       inet_ntoa(from_addr->sin_addr),\n\t       msg->msg_controllen);\n\tfor (cmsg = CMSG_FIRSTHDR(msg);\n\t     cmsg;\n\t     cmsg = CMSG_NXTHDR(msg, cmsg)) {\n\t\tprintf(\"   cmsg len %zu: \", cmsg->cmsg_len);\n\t\tswitch (cmsg->cmsg_level) {\n\t\tcase SOL_SOCKET:\n\t\t\tprintf(\"SOL_SOCKET \");\n\t\t\tswitch (cmsg->cmsg_type) {\n\t\t\tcase SO_TIMESTAMP: {\n\t\t\t\tstruct timeval *stamp =\n\t\t\t\t\t(struct timeval *)CMSG_DATA(cmsg);\n\t\t\t\tprintf(\"SO_TIMESTAMP %ld.%06ld\",\n\t\t\t\t       (long)stamp->tv_sec,\n\t\t\t\t       (long)stamp->tv_usec);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SO_TIMESTAMPNS: {\n\t\t\t\tstruct timespec *stamp =\n\t\t\t\t\t(struct timespec *)CMSG_DATA(cmsg);\n\t\t\t\tprintf(\"SO_TIMESTAMPNS %ld.%09ld\",\n\t\t\t\t       (long)stamp->tv_sec,\n\t\t\t\t       (long)stamp->tv_nsec);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SO_TIMESTAMPING: {\n\t\t\t\tstruct timespec *stamp =\n\t\t\t\t\t(struct timespec *)CMSG_DATA(cmsg);\n\t\t\t\tprintf(\"SO_TIMESTAMPING \");\n\t\t\t\tprintf(\"SW %ld.%09ld \",\n\t\t\t\t       (long)stamp->tv_sec,\n\t\t\t\t       (long)stamp->tv_nsec);\n\t\t\t\tstamp++;\n\t\t\t\t \n\t\t\t\tstamp++;\n\t\t\t\tprintf(\"HW raw %ld.%09ld\",\n\t\t\t\t       (long)stamp->tv_sec,\n\t\t\t\t       (long)stamp->tv_nsec);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tprintf(\"type %d\", cmsg->cmsg_type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPPROTO_IP:\n\t\t\tprintf(\"IPPROTO_IP \");\n\t\t\tswitch (cmsg->cmsg_type) {\n\t\t\tcase IP_RECVERR: {\n\t\t\t\tstruct sock_extended_err *err =\n\t\t\t\t\t(struct sock_extended_err *)CMSG_DATA(cmsg);\n\t\t\t\tprintf(\"IP_RECVERR ee_errno '%s' ee_origin %d => %s\",\n\t\t\t\t\tstrerror(err->ee_errno),\n\t\t\t\t\terr->ee_origin,\n#ifdef SO_EE_ORIGIN_TIMESTAMPING\n\t\t\t\t\terr->ee_origin == SO_EE_ORIGIN_TIMESTAMPING ?\n\t\t\t\t\t\"bounced packet\" : \"unexpected origin\"\n#else\n\t\t\t\t\t\"probably SO_EE_ORIGIN_TIMESTAMPING\"\n#endif\n\t\t\t\t\t);\n\t\t\t\tif (res < sync_len)\n\t\t\t\t\tprintf(\" => truncated data?!\");\n\t\t\t\telse if (!memcmp(sync_p, data + res - sync_len, sync_len))\n\t\t\t\t\tprintf(\" => GOT OUR DATA BACK (HURRAY!)\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase IP_PKTINFO: {\n\t\t\t\tstruct in_pktinfo *pktinfo =\n\t\t\t\t\t(struct in_pktinfo *)CMSG_DATA(cmsg);\n\t\t\t\tprintf(\"IP_PKTINFO interface index %u\",\n\t\t\t\t\tpktinfo->ipi_ifindex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tprintf(\"type %d\", cmsg->cmsg_type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"level %d type %d\",\n\t\t\t\tcmsg->cmsg_level,\n\t\t\t\tcmsg->cmsg_type);\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (siocgstamp) {\n\t\tif (ioctl(sock, SIOCGSTAMP, &tv))\n\t\t\tprintf(\"   %s: %s\\n\", \"SIOCGSTAMP\", strerror(errno));\n\t\telse\n\t\t\tprintf(\"SIOCGSTAMP %ld.%06ld\\n\",\n\t\t\t       (long)tv.tv_sec,\n\t\t\t       (long)tv.tv_usec);\n\t}\n\tif (siocgstampns) {\n\t\tif (ioctl(sock, SIOCGSTAMPNS, &ts))\n\t\t\tprintf(\"   %s: %s\\n\", \"SIOCGSTAMPNS\", strerror(errno));\n\t\telse\n\t\t\tprintf(\"SIOCGSTAMPNS %ld.%09ld\\n\",\n\t\t\t       (long)ts.tv_sec,\n\t\t\t       (long)ts.tv_nsec);\n\t}\n}\n\nstatic void recvpacket(int sock, int recvmsg_flags,\n\t\t       int siocgstamp, int siocgstampns, int ptpv2)\n{\n\tchar data[256];\n\tstruct msghdr msg;\n\tstruct iovec entry;\n\tstruct sockaddr_in from_addr;\n\tstruct {\n\t\tstruct cmsghdr cm;\n\t\tchar control[512];\n\t} control;\n\tint res;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_iov = &entry;\n\tmsg.msg_iovlen = 1;\n\tentry.iov_base = data;\n\tentry.iov_len = sizeof(data);\n\tmsg.msg_name = (caddr_t)&from_addr;\n\tmsg.msg_namelen = sizeof(from_addr);\n\tmsg.msg_control = &control;\n\tmsg.msg_controllen = sizeof(control);\n\n\tres = recvmsg(sock, &msg, recvmsg_flags|MSG_DONTWAIT);\n\tif (res < 0) {\n\t\tprintf(\"%s %s: %s\\n\",\n\t\t       \"recvmsg\",\n\t\t       (recvmsg_flags & MSG_ERRQUEUE) ? \"error\" : \"regular\",\n\t\t       strerror(errno));\n\t} else {\n\t\tprintpacket(&msg, res, data,\n\t\t\t    sock, recvmsg_flags,\n\t\t\t    siocgstamp, siocgstampns, ptpv2);\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tint so_timestamp = 0;\n\tint so_timestampns = 0;\n\tint siocgstamp = 0;\n\tint siocgstampns = 0;\n\tint ip_multicast_loop = 0;\n\tint ptpv2 = 0;\n\tchar *interface;\n\tint i;\n\tint enabled = 1;\n\tint sock;\n\tstruct ifreq device;\n\tstruct ifreq hwtstamp;\n\tstruct hwtstamp_config hwconfig, hwconfig_requested;\n\tstruct so_timestamping so_timestamping_get = { 0, 0 };\n\tstruct so_timestamping so_timestamping = { 0, 0 };\n\tstruct sockaddr_in addr;\n\tstruct ip_mreq imr;\n\tstruct in_addr iaddr;\n\tint val;\n\tsocklen_t len;\n\tstruct timeval next;\n\tsize_t if_len;\n\n\tif (argc < 2)\n\t\tusage(0);\n\tinterface = argv[1];\n\tif_len = strlen(interface);\n\tif (if_len >= IFNAMSIZ) {\n\t\tprintf(\"interface name exceeds IFNAMSIZ\\n\");\n\t\texit(1);\n\t}\n\n\tif (argc >= 3 && sscanf(argv[2], \"%d\", &so_timestamping.bind_phc) == 1)\n\t\tval = 3;\n\telse\n\t\tval = 2;\n\n\tfor (i = val; i < argc; i++) {\n\t\tif (!strcasecmp(argv[i], \"SO_TIMESTAMP\"))\n\t\t\tso_timestamp = 1;\n\t\telse if (!strcasecmp(argv[i], \"SO_TIMESTAMPNS\"))\n\t\t\tso_timestampns = 1;\n\t\telse if (!strcasecmp(argv[i], \"SIOCGSTAMP\"))\n\t\t\tsiocgstamp = 1;\n\t\telse if (!strcasecmp(argv[i], \"SIOCGSTAMPNS\"))\n\t\t\tsiocgstampns = 1;\n\t\telse if (!strcasecmp(argv[i], \"IP_MULTICAST_LOOP\"))\n\t\t\tip_multicast_loop = 1;\n\t\telse if (!strcasecmp(argv[i], \"PTPV2\"))\n\t\t\tptpv2 = 1;\n\t\telse if (!strcasecmp(argv[i], \"SOF_TIMESTAMPING_TX_HARDWARE\"))\n\t\t\tso_timestamping.flags |= SOF_TIMESTAMPING_TX_HARDWARE;\n\t\telse if (!strcasecmp(argv[i], \"SOF_TIMESTAMPING_TX_SOFTWARE\"))\n\t\t\tso_timestamping.flags |= SOF_TIMESTAMPING_TX_SOFTWARE;\n\t\telse if (!strcasecmp(argv[i], \"SOF_TIMESTAMPING_RX_HARDWARE\"))\n\t\t\tso_timestamping.flags |= SOF_TIMESTAMPING_RX_HARDWARE;\n\t\telse if (!strcasecmp(argv[i], \"SOF_TIMESTAMPING_RX_SOFTWARE\"))\n\t\t\tso_timestamping.flags |= SOF_TIMESTAMPING_RX_SOFTWARE;\n\t\telse if (!strcasecmp(argv[i], \"SOF_TIMESTAMPING_SOFTWARE\"))\n\t\t\tso_timestamping.flags |= SOF_TIMESTAMPING_SOFTWARE;\n\t\telse if (!strcasecmp(argv[i], \"SOF_TIMESTAMPING_RAW_HARDWARE\"))\n\t\t\tso_timestamping.flags |= SOF_TIMESTAMPING_RAW_HARDWARE;\n\t\telse if (!strcasecmp(argv[i], \"SOF_TIMESTAMPING_BIND_PHC\"))\n\t\t\tso_timestamping.flags |= SOF_TIMESTAMPING_BIND_PHC;\n\t\telse\n\t\t\tusage(argv[i]);\n\t}\n\n\tsock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (sock < 0)\n\t\tbail(\"socket\");\n\n\tmemset(&device, 0, sizeof(device));\n\tmemcpy(device.ifr_name, interface, if_len + 1);\n\tif (ioctl(sock, SIOCGIFADDR, &device) < 0)\n\t\tbail(\"getting interface IP address\");\n\n\tmemset(&hwtstamp, 0, sizeof(hwtstamp));\n\tmemcpy(hwtstamp.ifr_name, interface, if_len + 1);\n\thwtstamp.ifr_data = (void *)&hwconfig;\n\tmemset(&hwconfig, 0, sizeof(hwconfig));\n\thwconfig.tx_type =\n\t\t(so_timestamping.flags & SOF_TIMESTAMPING_TX_HARDWARE) ?\n\t\tHWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;\n\thwconfig.rx_filter =\n\t\t(so_timestamping.flags & SOF_TIMESTAMPING_RX_HARDWARE) ?\n\t\tptpv2 ? HWTSTAMP_FILTER_PTP_V2_L4_SYNC :\n\t\tHWTSTAMP_FILTER_PTP_V1_L4_SYNC : HWTSTAMP_FILTER_NONE;\n\thwconfig_requested = hwconfig;\n\tif (ioctl(sock, SIOCSHWTSTAMP, &hwtstamp) < 0) {\n\t\tif ((errno == EINVAL || errno == ENOTSUP) &&\n\t\t    hwconfig_requested.tx_type == HWTSTAMP_TX_OFF &&\n\t\t    hwconfig_requested.rx_filter == HWTSTAMP_FILTER_NONE)\n\t\t\tprintf(\"SIOCSHWTSTAMP: disabling hardware time stamping not possible\\n\");\n\t\telse\n\t\t\tbail(\"SIOCSHWTSTAMP\");\n\t}\n\tprintf(\"SIOCSHWTSTAMP: tx_type %d requested, got %d; rx_filter %d requested, got %d\\n\",\n\t       hwconfig_requested.tx_type, hwconfig.tx_type,\n\t       hwconfig_requested.rx_filter, hwconfig.rx_filter);\n\n\t \n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(319  );\n\tif (bind(sock,\n\t\t (struct sockaddr *)&addr,\n\t\t sizeof(struct sockaddr_in)) < 0)\n\t\tbail(\"bind\");\n\n\tif (setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, interface, if_len))\n\t\tbail(\"bind device\");\n\n\t \n\tinet_aton(\"224.0.1.130\", &iaddr);  \n\taddr.sin_addr = iaddr;\n\timr.imr_multiaddr.s_addr = iaddr.s_addr;\n\timr.imr_interface.s_addr =\n\t\t((struct sockaddr_in *)&device.ifr_addr)->sin_addr.s_addr;\n\tif (setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t       &imr.imr_interface.s_addr, sizeof(struct in_addr)) < 0)\n\t\tbail(\"set multicast\");\n\n\t \n\tif (setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP,\n\t\t       &imr, sizeof(struct ip_mreq)) < 0)\n\t\tbail(\"join multicast group\");\n\n\tif (setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP,\n\t\t       &ip_multicast_loop, sizeof(enabled)) < 0) {\n\t\tbail(\"loop multicast\");\n\t}\n\n\t \n\tif (so_timestamp &&\n\t\tsetsockopt(sock, SOL_SOCKET, SO_TIMESTAMP,\n\t\t\t   &enabled, sizeof(enabled)) < 0)\n\t\tbail(\"setsockopt SO_TIMESTAMP\");\n\n\tif (so_timestampns &&\n\t\tsetsockopt(sock, SOL_SOCKET, SO_TIMESTAMPNS,\n\t\t\t   &enabled, sizeof(enabled)) < 0)\n\t\tbail(\"setsockopt SO_TIMESTAMPNS\");\n\n\tif (so_timestamping.flags &&\n\t    setsockopt(sock, SOL_SOCKET, SO_TIMESTAMPING, &so_timestamping,\n\t\t       sizeof(so_timestamping)) < 0)\n\t\tbail(\"setsockopt SO_TIMESTAMPING\");\n\n\t \n\tif (setsockopt(sock, SOL_IP, IP_PKTINFO,\n\t\t       &enabled, sizeof(enabled)) < 0)\n\t\tprintf(\"%s: %s\\n\", \"setsockopt IP_PKTINFO\", strerror(errno));\n\n\t \n\tlen = sizeof(val);\n\tif (getsockopt(sock, SOL_SOCKET, SO_TIMESTAMP, &val, &len) < 0)\n\t\tprintf(\"%s: %s\\n\", \"getsockopt SO_TIMESTAMP\", strerror(errno));\n\telse\n\t\tprintf(\"SO_TIMESTAMP %d\\n\", val);\n\n\tif (getsockopt(sock, SOL_SOCKET, SO_TIMESTAMPNS, &val, &len) < 0)\n\t\tprintf(\"%s: %s\\n\", \"getsockopt SO_TIMESTAMPNS\",\n\t\t       strerror(errno));\n\telse\n\t\tprintf(\"SO_TIMESTAMPNS %d\\n\", val);\n\n\tlen = sizeof(so_timestamping_get);\n\tif (getsockopt(sock, SOL_SOCKET, SO_TIMESTAMPING, &so_timestamping_get,\n\t\t       &len) < 0) {\n\t\tprintf(\"%s: %s\\n\", \"getsockopt SO_TIMESTAMPING\",\n\t\t       strerror(errno));\n\t} else {\n\t\tprintf(\"SO_TIMESTAMPING flags %d, bind phc %d\\n\",\n\t\t       so_timestamping_get.flags, so_timestamping_get.bind_phc);\n\t\tif (so_timestamping_get.flags != so_timestamping.flags ||\n\t\t    so_timestamping_get.bind_phc != so_timestamping.bind_phc)\n\t\t\tprintf(\"   not expected, flags %d, bind phc %d\\n\",\n\t\t\t       so_timestamping.flags, so_timestamping.bind_phc);\n\t}\n\n\t \n\tgettimeofday(&next, 0);\n\tnext.tv_sec = (next.tv_sec + 1) / 5 * 5;\n\tnext.tv_usec = 0;\n\twhile (1) {\n\t\tstruct timeval now;\n\t\tstruct timeval delta;\n\t\tlong delta_us;\n\t\tint res;\n\t\tfd_set readfs, errorfs;\n\n\t\tgettimeofday(&now, 0);\n\t\tdelta_us = (long)(next.tv_sec - now.tv_sec) * 1000000 +\n\t\t\t(long)(next.tv_usec - now.tv_usec);\n\t\tif (delta_us > 0) {\n\t\t\t \n\t\t\tdelta.tv_sec = delta_us / 1000000;\n\t\t\tdelta.tv_usec = delta_us % 1000000;\n\n\t\t\tFD_ZERO(&readfs);\n\t\t\tFD_ZERO(&errorfs);\n\t\t\tFD_SET(sock, &readfs);\n\t\t\tFD_SET(sock, &errorfs);\n\t\t\tprintf(\"%ld.%06ld: select %ldus\\n\",\n\t\t\t       (long)now.tv_sec, (long)now.tv_usec,\n\t\t\t       delta_us);\n\t\t\tres = select(sock + 1, &readfs, 0, &errorfs, &delta);\n\t\t\tgettimeofday(&now, 0);\n\t\t\tprintf(\"%ld.%06ld: select returned: %d, %s\\n\",\n\t\t\t       (long)now.tv_sec, (long)now.tv_usec,\n\t\t\t       res,\n\t\t\t       res < 0 ? strerror(errno) : \"success\");\n\t\t\tif (res > 0) {\n\t\t\t\tif (FD_ISSET(sock, &readfs))\n\t\t\t\t\tprintf(\"ready for reading\\n\");\n\t\t\t\tif (FD_ISSET(sock, &errorfs))\n\t\t\t\t\tprintf(\"has error\\n\");\n\t\t\t\trecvpacket(sock, 0,\n\t\t\t\t\t   siocgstamp,\n\t\t\t\t\t   siocgstampns, ptpv2);\n\t\t\t\trecvpacket(sock, MSG_ERRQUEUE,\n\t\t\t\t\t   siocgstamp,\n\t\t\t\t\t   siocgstampns, ptpv2);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tsendpacket(sock,\n\t\t\t\t   (struct sockaddr *)&addr,\n\t\t\t\t   sizeof(addr), ptpv2);\n\t\t\tnext.tv_sec += 5;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}