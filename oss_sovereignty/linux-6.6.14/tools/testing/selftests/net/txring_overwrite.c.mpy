{
  "module_name": "txring_overwrite.c",
  "hash_id": "90e988f82d27f7d5118ecfb75cbbf7769dad759021b874c2a1f96836263fc7fc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/txring_overwrite.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <assert.h>\n#include <error.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/filter.h>\n#include <linux/if_packet.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <poll.h>\n#include <pthread.h>\n#include <sched.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/utsname.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nconst int eth_off = TPACKET_HDRLEN - sizeof(struct sockaddr_ll);\nconst int cfg_frame_size = 1000;\n\nstatic void build_packet(void *buffer, size_t blen, char payload_char)\n{\n\tstruct udphdr *udph;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\tsize_t off = 0;\n\n\tmemset(buffer, 0, blen);\n\n\teth = buffer;\n\teth->h_proto = htons(ETH_P_IP);\n\n\toff += sizeof(*eth);\n\tiph = buffer + off;\n\tiph->ttl\t= 8;\n\tiph->ihl\t= 5;\n\tiph->version\t= 4;\n\tiph->saddr\t= htonl(INADDR_LOOPBACK);\n\tiph->daddr\t= htonl(INADDR_LOOPBACK + 1);\n\tiph->protocol\t= IPPROTO_UDP;\n\tiph->tot_len\t= htons(blen - off);\n\tiph->check\t= 0;\n\n\toff += sizeof(*iph);\n\tudph = buffer + off;\n\tudph->dest\t= htons(8000);\n\tudph->source\t= htons(8001);\n\tudph->len\t= htons(blen - off);\n\tudph->check\t= 0;\n\n\toff += sizeof(*udph);\n\tmemset(buffer + off, payload_char, blen - off);\n}\n\nstatic int setup_rx(void)\n{\n\tint fdr;\n\n\tfdr = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP));\n\tif (fdr == -1)\n\t\terror(1, errno, \"socket r\");\n\n\treturn fdr;\n}\n\nstatic int setup_tx(char **ring)\n{\n\tstruct sockaddr_ll laddr = {};\n\tstruct tpacket_req req = {};\n\tint fdt;\n\n\tfdt = socket(PF_PACKET, SOCK_RAW, 0);\n\tif (fdt == -1)\n\t\terror(1, errno, \"socket t\");\n\n\tladdr.sll_family = AF_PACKET;\n\tladdr.sll_protocol = htons(0);\n\tladdr.sll_ifindex = if_nametoindex(\"lo\");\n\tif (!laddr.sll_ifindex)\n\t\terror(1, errno, \"if_nametoindex\");\n\n\tif (bind(fdt, (void *)&laddr, sizeof(laddr)))\n\t\terror(1, errno, \"bind fdt\");\n\n\treq.tp_block_size = getpagesize();\n\treq.tp_block_nr   = 1;\n\treq.tp_frame_size = getpagesize();\n\treq.tp_frame_nr   = 1;\n\n\tif (setsockopt(fdt, SOL_PACKET, PACKET_TX_RING,\n\t\t       (void *)&req, sizeof(req)))\n\t\terror(1, errno, \"setsockopt ring\");\n\n\t*ring = mmap(0, req.tp_block_size * req.tp_block_nr,\n\t\t     PROT_READ | PROT_WRITE, MAP_SHARED, fdt, 0);\n\tif (*ring == MAP_FAILED)\n\t\terror(1, errno, \"mmap\");\n\n\treturn fdt;\n}\n\nstatic void send_pkt(int fdt, void *slot, char payload_char)\n{\n\tstruct tpacket_hdr *header = slot;\n\tint ret;\n\n\twhile (header->tp_status != TP_STATUS_AVAILABLE)\n\t\tusleep(1000);\n\n\tbuild_packet(slot + eth_off, cfg_frame_size, payload_char);\n\n\theader->tp_len = cfg_frame_size;\n\theader->tp_status = TP_STATUS_SEND_REQUEST;\n\n\tret = sendto(fdt, NULL, 0, 0, NULL, 0);\n\tif (ret == -1)\n\t\terror(1, errno, \"kick tx\");\n}\n\nstatic int read_verify_pkt(int fdr, char payload_char)\n{\n\tchar buf[100];\n\tint ret;\n\n\tret = read(fdr, buf, sizeof(buf));\n\tif (ret != sizeof(buf))\n\t\terror(1, errno, \"read\");\n\n\tif (buf[60] != payload_char) {\n\t\tprintf(\"wrong pattern: 0x%x != 0x%x\\n\", buf[60], payload_char);\n\t\treturn 1;\n\t}\n\n\tprintf(\"read: %c (0x%x)\\n\", buf[60], buf[60]);\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tconst char payload_patterns[] = \"ab\";\n\tchar *ring;\n\tint fdr, fdt, ret = 0;\n\n\tfdr = setup_rx();\n\tfdt = setup_tx(&ring);\n\n\tsend_pkt(fdt, ring, payload_patterns[0]);\n\tsend_pkt(fdt, ring, payload_patterns[1]);\n\n\tret |= read_verify_pkt(fdr, payload_patterns[0]);\n\tret |= read_verify_pkt(fdr, payload_patterns[1]);\n\n\tif (close(fdt))\n\t\terror(1, errno, \"close t\");\n\tif (close(fdr))\n\t\terror(1, errno, \"close r\");\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}