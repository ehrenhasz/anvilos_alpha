{
  "module_name": "cmsg_sender.c",
  "hash_id": "e1320e7b12ded34fccfd251e1f040b875f33de865e33abebacccb8b2f9df2cb8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/cmsg_sender.c",
  "human_readable_source": "\n#include <errno.h>\n#include <error.h>\n#include <netdb.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <linux/errqueue.h>\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/net_tstamp.h>\n#include <linux/types.h>\n#include <linux/udp.h>\n#include <sys/socket.h>\n\n#include \"../kselftest.h\"\n\nenum {\n\tERN_SUCCESS = 0,\n\t \n\tERN_SEND = 1,\n\t \n\tERN_HELP,\n\tERN_SEND_SHORT,\n\tERN_SOCK_CREATE,\n\tERN_RESOLVE,\n\tERN_CMSG_WR,\n\tERN_SOCKOPT,\n\tERN_GETTIME,\n\tERN_RECVERR,\n\tERN_CMSG_RD,\n\tERN_CMSG_RCV,\n};\n\nstruct option_cmsg_u32 {\n\tbool ena;\n\tunsigned int val;\n};\n\nstruct options {\n\tbool silent_send;\n\tconst char *host;\n\tconst char *service;\n\tunsigned int size;\n\tstruct {\n\t\tunsigned int mark;\n\t\tunsigned int dontfrag;\n\t\tunsigned int tclass;\n\t\tunsigned int hlimit;\n\t} sockopt;\n\tstruct {\n\t\tunsigned int family;\n\t\tunsigned int type;\n\t\tunsigned int proto;\n\t} sock;\n\tstruct option_cmsg_u32 mark;\n\tstruct {\n\t\tbool ena;\n\t\tunsigned int delay;\n\t} txtime;\n\tstruct {\n\t\tbool ena;\n\t} ts;\n\tstruct {\n\t\tstruct option_cmsg_u32 dontfrag;\n\t\tstruct option_cmsg_u32 tclass;\n\t\tstruct option_cmsg_u32 hlimit;\n\t\tstruct option_cmsg_u32 exthdr;\n\t} v6;\n} opt = {\n\t.size = 13,\n\t.sock = {\n\t\t.family\t= AF_UNSPEC,\n\t\t.type\t= SOCK_DGRAM,\n\t\t.proto\t= IPPROTO_UDP,\n\t},\n};\n\nstatic struct timespec time_start_real;\nstatic struct timespec time_start_mono;\n\nstatic void __attribute__((noreturn)) cs_usage(const char *bin)\n{\n\tprintf(\"Usage: %s [opts] <dst host> <dst port / service>\\n\", bin);\n\tprintf(\"Options:\\n\"\n\t       \"\\t\\t-s      Silent send() failures\\n\"\n\t       \"\\t\\t-S      send() size\\n\"\n\t       \"\\t\\t-4/-6   Force IPv4 / IPv6 only\\n\"\n\t       \"\\t\\t-p prot Socket protocol\\n\"\n\t       \"\\t\\t        (u = UDP (default); i = ICMP; r = RAW)\\n\"\n\t       \"\\n\"\n\t       \"\\t\\t-m val  Set SO_MARK with given value\\n\"\n\t       \"\\t\\t-M val  Set SO_MARK via setsockopt\\n\"\n\t       \"\\t\\t-d val  Set SO_TXTIME with given delay (usec)\\n\"\n\t       \"\\t\\t-t      Enable time stamp reporting\\n\"\n\t       \"\\t\\t-f val  Set don't fragment via cmsg\\n\"\n\t       \"\\t\\t-F val  Set don't fragment via setsockopt\\n\"\n\t       \"\\t\\t-c val  Set TCLASS via cmsg\\n\"\n\t       \"\\t\\t-C val  Set TCLASS via setsockopt\\n\"\n\t       \"\\t\\t-l val  Set HOPLIMIT via cmsg\\n\"\n\t       \"\\t\\t-L val  Set HOPLIMIT via setsockopt\\n\"\n\t       \"\\t\\t-H type Add an IPv6 header option\\n\"\n\t       \"\\t\\t        (h = HOP; d = DST; r = RTDST)\"\n\t       \"\");\n\texit(ERN_HELP);\n}\n\nstatic void cs_parse_args(int argc, char *argv[])\n{\n\tint o;\n\n\twhile ((o = getopt(argc, argv, \"46sS:p:m:M:d:tf:F:c:C:l:L:H:\")) != -1) {\n\t\tswitch (o) {\n\t\tcase 's':\n\t\t\topt.silent_send = true;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\topt.size = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\topt.sock.family = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\topt.sock.family = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (*optarg == 'u' || *optarg == 'U') {\n\t\t\t\topt.sock.proto = IPPROTO_UDP;\n\t\t\t} else if (*optarg == 'i' || *optarg == 'I') {\n\t\t\t\topt.sock.proto = IPPROTO_ICMP;\n\t\t\t} else if (*optarg == 'r') {\n\t\t\t\topt.sock.type = SOCK_RAW;\n\t\t\t} else {\n\t\t\t\tprintf(\"Error: unknown protocol: %s\\n\", optarg);\n\t\t\t\tcs_usage(argv[0]);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\topt.mark.ena = true;\n\t\t\topt.mark.val = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\topt.sockopt.mark = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\topt.txtime.ena = true;\n\t\t\topt.txtime.delay = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\topt.ts.ena = true;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\topt.v6.dontfrag.ena = true;\n\t\t\topt.v6.dontfrag.val = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\topt.sockopt.dontfrag = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\topt.v6.tclass.ena = true;\n\t\t\topt.v6.tclass.val = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\topt.sockopt.tclass = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\topt.v6.hlimit.ena = true;\n\t\t\topt.v6.hlimit.val = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\topt.sockopt.hlimit = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\topt.v6.exthdr.ena = true;\n\t\t\tswitch (optarg[0]) {\n\t\t\tcase 'h':\n\t\t\t\topt.v6.exthdr.val = IPV6_HOPOPTS;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\topt.v6.exthdr.val = IPV6_DSTOPTS;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\topt.v6.exthdr.val = IPV6_RTHDRDSTOPTS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Error: hdr type: %s\\n\", optarg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind != argc - 2)\n\t\tcs_usage(argv[0]);\n\n\topt.host = argv[optind];\n\topt.service = argv[optind + 1];\n}\n\nstatic void memrnd(void *s, size_t n)\n{\n\tint *dword = s;\n\tchar *byte;\n\n\tfor (; n >= 4; n -= 4)\n\t\t*dword++ = rand();\n\tbyte = (void *)dword;\n\twhile (n--)\n\t\t*byte++ = rand();\n}\n\nstatic void\nca_write_cmsg_u32(char *cbuf, size_t cbuf_sz, size_t *cmsg_len,\n\t\t  int level, int optname, struct option_cmsg_u32 *uopt)\n{\n\tstruct cmsghdr *cmsg;\n\n\tif (!uopt->ena)\n\t\treturn;\n\n\tcmsg = (struct cmsghdr *)(cbuf + *cmsg_len);\n\t*cmsg_len += CMSG_SPACE(sizeof(__u32));\n\tif (cbuf_sz < *cmsg_len)\n\t\terror(ERN_CMSG_WR, EFAULT, \"cmsg buffer too small\");\n\n\tcmsg->cmsg_level = level;\n\tcmsg->cmsg_type = optname;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(__u32));\n\t*(__u32 *)CMSG_DATA(cmsg) = uopt->val;\n}\n\nstatic void\ncs_write_cmsg(int fd, struct msghdr *msg, char *cbuf, size_t cbuf_sz)\n{\n\tstruct cmsghdr *cmsg;\n\tsize_t cmsg_len;\n\n\tmsg->msg_control = cbuf;\n\tcmsg_len = 0;\n\n\tca_write_cmsg_u32(cbuf, cbuf_sz, &cmsg_len,\n\t\t\t  SOL_SOCKET, SO_MARK, &opt.mark);\n\tca_write_cmsg_u32(cbuf, cbuf_sz, &cmsg_len,\n\t\t\t  SOL_IPV6, IPV6_DONTFRAG, &opt.v6.dontfrag);\n\tca_write_cmsg_u32(cbuf, cbuf_sz, &cmsg_len,\n\t\t\t  SOL_IPV6, IPV6_TCLASS, &opt.v6.tclass);\n\tca_write_cmsg_u32(cbuf, cbuf_sz, &cmsg_len,\n\t\t\t  SOL_IPV6, IPV6_HOPLIMIT, &opt.v6.hlimit);\n\n\tif (opt.txtime.ena) {\n\t\tstruct sock_txtime so_txtime = {\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t};\n\t\t__u64 txtime;\n\n\t\tif (setsockopt(fd, SOL_SOCKET, SO_TXTIME,\n\t\t\t       &so_txtime, sizeof(so_txtime)))\n\t\t\terror(ERN_SOCKOPT, errno, \"setsockopt TXTIME\");\n\n\t\ttxtime = time_start_mono.tv_sec * (1000ULL * 1000 * 1000) +\n\t\t\t time_start_mono.tv_nsec +\n\t\t\t opt.txtime.delay * 1000;\n\n\t\tcmsg = (struct cmsghdr *)(cbuf + cmsg_len);\n\t\tcmsg_len += CMSG_SPACE(sizeof(txtime));\n\t\tif (cbuf_sz < cmsg_len)\n\t\t\terror(ERN_CMSG_WR, EFAULT, \"cmsg buffer too small\");\n\n\t\tcmsg->cmsg_level = SOL_SOCKET;\n\t\tcmsg->cmsg_type = SCM_TXTIME;\n\t\tcmsg->cmsg_len = CMSG_LEN(sizeof(txtime));\n\t\tmemcpy(CMSG_DATA(cmsg), &txtime, sizeof(txtime));\n\t}\n\tif (opt.ts.ena) {\n\t\t__u32 val = SOF_TIMESTAMPING_SOFTWARE |\n\t\t\t    SOF_TIMESTAMPING_OPT_TSONLY;\n\n\t\tif (setsockopt(fd, SOL_SOCKET, SO_TIMESTAMPING,\n\t\t\t       &val, sizeof(val)))\n\t\t\terror(ERN_SOCKOPT, errno, \"setsockopt TIMESTAMPING\");\n\n\t\tcmsg = (struct cmsghdr *)(cbuf + cmsg_len);\n\t\tcmsg_len += CMSG_SPACE(sizeof(__u32));\n\t\tif (cbuf_sz < cmsg_len)\n\t\t\terror(ERN_CMSG_WR, EFAULT, \"cmsg buffer too small\");\n\n\t\tcmsg->cmsg_level = SOL_SOCKET;\n\t\tcmsg->cmsg_type = SO_TIMESTAMPING;\n\t\tcmsg->cmsg_len = CMSG_LEN(sizeof(__u32));\n\t\t*(__u32 *)CMSG_DATA(cmsg) = SOF_TIMESTAMPING_TX_SCHED |\n\t\t\t\t\t    SOF_TIMESTAMPING_TX_SOFTWARE;\n\t}\n\tif (opt.v6.exthdr.ena) {\n\t\tcmsg = (struct cmsghdr *)(cbuf + cmsg_len);\n\t\tcmsg_len += CMSG_SPACE(8);\n\t\tif (cbuf_sz < cmsg_len)\n\t\t\terror(ERN_CMSG_WR, EFAULT, \"cmsg buffer too small\");\n\n\t\tcmsg->cmsg_level = SOL_IPV6;\n\t\tcmsg->cmsg_type = opt.v6.exthdr.val;\n\t\tcmsg->cmsg_len = CMSG_LEN(8);\n\t\t*(__u64 *)CMSG_DATA(cmsg) = 0;\n\t}\n\n\tif (cmsg_len)\n\t\tmsg->msg_controllen = cmsg_len;\n\telse\n\t\tmsg->msg_control = NULL;\n}\n\nstatic const char *cs_ts_info2str(unsigned int info)\n{\n\tstatic const char *names[] = {\n\t\t[SCM_TSTAMP_SND]\t= \"SND\",\n\t\t[SCM_TSTAMP_SCHED]\t= \"SCHED\",\n\t\t[SCM_TSTAMP_ACK]\t= \"ACK\",\n\t};\n\n\tif (info < ARRAY_SIZE(names))\n\t\treturn names[info];\n\treturn \"unknown\";\n}\n\nstatic void\ncs_read_cmsg(int fd, struct msghdr *msg, char *cbuf, size_t cbuf_sz)\n{\n\tstruct sock_extended_err *see;\n\tstruct scm_timestamping *ts;\n\tstruct cmsghdr *cmsg;\n\tint i, err;\n\n\tif (!opt.ts.ena)\n\t\treturn;\n\tmsg->msg_control = cbuf;\n\tmsg->msg_controllen = cbuf_sz;\n\n\twhile (true) {\n\t\tts = NULL;\n\t\tsee = NULL;\n\t\tmemset(cbuf, 0, cbuf_sz);\n\n\t\terr = recvmsg(fd, msg, MSG_ERRQUEUE);\n\t\tif (err < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tbreak;\n\t\t\terror(ERN_RECVERR, errno, \"recvmsg ERRQ\");\n\t\t}\n\n\t\tfor (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL;\n\t\t     cmsg = CMSG_NXTHDR(msg, cmsg)) {\n\t\t\tif (cmsg->cmsg_level == SOL_SOCKET &&\n\t\t\t    cmsg->cmsg_type == SO_TIMESTAMPING_OLD) {\n\t\t\t\tif (cmsg->cmsg_len < sizeof(*ts))\n\t\t\t\t\terror(ERN_CMSG_RD, EINVAL, \"TS cmsg\");\n\n\t\t\t\tts = (void *)CMSG_DATA(cmsg);\n\t\t\t}\n\t\t\tif ((cmsg->cmsg_level == SOL_IP &&\n\t\t\t     cmsg->cmsg_type == IP_RECVERR) ||\n\t\t\t    (cmsg->cmsg_level == SOL_IPV6 &&\n\t\t\t     cmsg->cmsg_type == IPV6_RECVERR)) {\n\t\t\t\tif (cmsg->cmsg_len < sizeof(*see))\n\t\t\t\t\terror(ERN_CMSG_RD, EINVAL, \"sock_err cmsg\");\n\n\t\t\t\tsee = (void *)CMSG_DATA(cmsg);\n\t\t\t}\n\t\t}\n\n\t\tif (!ts)\n\t\t\terror(ERN_CMSG_RCV, ENOENT, \"TS cmsg not found\");\n\t\tif (!see)\n\t\t\terror(ERN_CMSG_RCV, ENOENT, \"sock_err cmsg not found\");\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tunsigned long long rel_time;\n\n\t\t\tif (!ts->ts[i].tv_sec && !ts->ts[i].tv_nsec)\n\t\t\t\tcontinue;\n\n\t\t\trel_time = (ts->ts[i].tv_sec - time_start_real.tv_sec) *\n\t\t\t\t(1000ULL * 1000) +\n\t\t\t\t(ts->ts[i].tv_nsec - time_start_real.tv_nsec) /\n\t\t\t\t1000;\n\t\t\tprintf(\" %5s ts%d %lluus\\n\",\n\t\t\t       cs_ts_info2str(see->ee_info),\n\t\t\t       i, rel_time);\n\t\t}\n\t}\n}\n\nstatic void ca_set_sockopts(int fd)\n{\n\tif (opt.sockopt.mark &&\n\t    setsockopt(fd, SOL_SOCKET, SO_MARK,\n\t\t       &opt.sockopt.mark, sizeof(opt.sockopt.mark)))\n\t\terror(ERN_SOCKOPT, errno, \"setsockopt SO_MARK\");\n\tif (opt.sockopt.dontfrag &&\n\t    setsockopt(fd, SOL_IPV6, IPV6_DONTFRAG,\n\t\t       &opt.sockopt.dontfrag, sizeof(opt.sockopt.dontfrag)))\n\t\terror(ERN_SOCKOPT, errno, \"setsockopt IPV6_DONTFRAG\");\n\tif (opt.sockopt.tclass &&\n\t    setsockopt(fd, SOL_IPV6, IPV6_TCLASS,\n\t\t       &opt.sockopt.tclass, sizeof(opt.sockopt.tclass)))\n\t\terror(ERN_SOCKOPT, errno, \"setsockopt IPV6_TCLASS\");\n\tif (opt.sockopt.hlimit &&\n\t    setsockopt(fd, SOL_IPV6, IPV6_UNICAST_HOPS,\n\t\t       &opt.sockopt.hlimit, sizeof(opt.sockopt.hlimit)))\n\t\terror(ERN_SOCKOPT, errno, \"setsockopt IPV6_HOPLIMIT\");\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct addrinfo hints, *ai;\n\tstruct iovec iov[1];\n\tunsigned char *buf;\n\tstruct msghdr msg;\n\tchar cbuf[1024];\n\tint err;\n\tint fd;\n\n\tcs_parse_args(argc, argv);\n\n\tbuf = malloc(opt.size);\n\tmemrnd(buf, opt.size);\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = opt.sock.family;\n\n\tai = NULL;\n\terr = getaddrinfo(opt.host, opt.service, &hints, &ai);\n\tif (err) {\n\t\tfprintf(stderr, \"Can't resolve address [%s]:%s\\n\",\n\t\t\topt.host, opt.service);\n\t\treturn ERN_SOCK_CREATE;\n\t}\n\n\tif (ai->ai_family == AF_INET6 && opt.sock.proto == IPPROTO_ICMP)\n\t\topt.sock.proto = IPPROTO_ICMPV6;\n\n\tfd = socket(ai->ai_family, opt.sock.type, opt.sock.proto);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Can't open socket: %s\\n\", strerror(errno));\n\t\tfreeaddrinfo(ai);\n\t\treturn ERN_RESOLVE;\n\t}\n\n\tif (opt.sock.proto == IPPROTO_ICMP) {\n\t\tbuf[0] = ICMP_ECHO;\n\t\tbuf[1] = 0;\n\t} else if (opt.sock.proto == IPPROTO_ICMPV6) {\n\t\tbuf[0] = ICMPV6_ECHO_REQUEST;\n\t\tbuf[1] = 0;\n\t} else if (opt.sock.type == SOCK_RAW) {\n\t\tstruct udphdr hdr = { 1, 2, htons(opt.size), 0 };\n\t\tstruct sockaddr_in6 *sin6 = (void *)ai->ai_addr;\n\n\t\tmemcpy(buf, &hdr, sizeof(hdr));\n\t\tsin6->sin6_port = htons(opt.sock.proto);\n\t}\n\n\tca_set_sockopts(fd);\n\n\tif (clock_gettime(CLOCK_REALTIME, &time_start_real))\n\t\terror(ERN_GETTIME, errno, \"gettime REALTIME\");\n\tif (clock_gettime(CLOCK_MONOTONIC, &time_start_mono))\n\t\terror(ERN_GETTIME, errno, \"gettime MONOTONIC\");\n\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = opt.size;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_name = ai->ai_addr;\n\tmsg.msg_namelen = ai->ai_addrlen;\n\tmsg.msg_iov = iov;\n\tmsg.msg_iovlen = 1;\n\n\tcs_write_cmsg(fd, &msg, cbuf, sizeof(cbuf));\n\n\terr = sendmsg(fd, &msg, 0);\n\tif (err < 0) {\n\t\tif (!opt.silent_send)\n\t\t\tfprintf(stderr, \"send failed: %s\\n\", strerror(errno));\n\t\terr = ERN_SEND;\n\t\tgoto err_out;\n\t} else if (err != (int)opt.size) {\n\t\tfprintf(stderr, \"short send\\n\");\n\t\terr = ERN_SEND_SHORT;\n\t\tgoto err_out;\n\t} else {\n\t\terr = ERN_SUCCESS;\n\t}\n\n\t \n\tusleep(opt.txtime.delay);\n\n\tcs_read_cmsg(fd, &msg, cbuf, sizeof(cbuf));\n\nerr_out:\n\tclose(fd);\n\tfreeaddrinfo(ai);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}