{
  "module_name": "tls.c",
  "hash_id": "f5d4cd073a74d36b47960c9080de161c3d89f6f78a6964e8738ffeb0e80d1b34",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/tls.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <fcntl.h>\n#include <poll.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <linux/tls.h>\n#include <linux/tcp.h>\n#include <linux/socket.h>\n\n#include <sys/epoll.h>\n#include <sys/types.h>\n#include <sys/sendfile.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n\n#include \"../kselftest_harness.h\"\n\n#define TLS_PAYLOAD_MAX_LEN 16384\n#define SOL_TLS 282\n\nstatic int fips_enabled;\n\nstruct tls_crypto_info_keys {\n\tunion {\n\t\tstruct tls_crypto_info crypto_info;\n\t\tstruct tls12_crypto_info_aes_gcm_128 aes128;\n\t\tstruct tls12_crypto_info_chacha20_poly1305 chacha20;\n\t\tstruct tls12_crypto_info_sm4_gcm sm4gcm;\n\t\tstruct tls12_crypto_info_sm4_ccm sm4ccm;\n\t\tstruct tls12_crypto_info_aes_ccm_128 aesccm128;\n\t\tstruct tls12_crypto_info_aes_gcm_256 aesgcm256;\n\t\tstruct tls12_crypto_info_aria_gcm_128 ariagcm128;\n\t\tstruct tls12_crypto_info_aria_gcm_256 ariagcm256;\n\t};\n\tsize_t len;\n};\n\nstatic void tls_crypto_info_init(uint16_t tls_version, uint16_t cipher_type,\n\t\t\t\t struct tls_crypto_info_keys *tls12)\n{\n\tmemset(tls12, 0, sizeof(*tls12));\n\n\tswitch (cipher_type) {\n\tcase TLS_CIPHER_CHACHA20_POLY1305:\n\t\ttls12->len = sizeof(struct tls12_crypto_info_chacha20_poly1305);\n\t\ttls12->chacha20.info.version = tls_version;\n\t\ttls12->chacha20.info.cipher_type = cipher_type;\n\t\tbreak;\n\tcase TLS_CIPHER_AES_GCM_128:\n\t\ttls12->len = sizeof(struct tls12_crypto_info_aes_gcm_128);\n\t\ttls12->aes128.info.version = tls_version;\n\t\ttls12->aes128.info.cipher_type = cipher_type;\n\t\tbreak;\n\tcase TLS_CIPHER_SM4_GCM:\n\t\ttls12->len = sizeof(struct tls12_crypto_info_sm4_gcm);\n\t\ttls12->sm4gcm.info.version = tls_version;\n\t\ttls12->sm4gcm.info.cipher_type = cipher_type;\n\t\tbreak;\n\tcase TLS_CIPHER_SM4_CCM:\n\t\ttls12->len = sizeof(struct tls12_crypto_info_sm4_ccm);\n\t\ttls12->sm4ccm.info.version = tls_version;\n\t\ttls12->sm4ccm.info.cipher_type = cipher_type;\n\t\tbreak;\n\tcase TLS_CIPHER_AES_CCM_128:\n\t\ttls12->len = sizeof(struct tls12_crypto_info_aes_ccm_128);\n\t\ttls12->aesccm128.info.version = tls_version;\n\t\ttls12->aesccm128.info.cipher_type = cipher_type;\n\t\tbreak;\n\tcase TLS_CIPHER_AES_GCM_256:\n\t\ttls12->len = sizeof(struct tls12_crypto_info_aes_gcm_256);\n\t\ttls12->aesgcm256.info.version = tls_version;\n\t\ttls12->aesgcm256.info.cipher_type = cipher_type;\n\t\tbreak;\n\tcase TLS_CIPHER_ARIA_GCM_128:\n\t\ttls12->len = sizeof(struct tls12_crypto_info_aria_gcm_128);\n\t\ttls12->ariagcm128.info.version = tls_version;\n\t\ttls12->ariagcm128.info.cipher_type = cipher_type;\n\t\tbreak;\n\tcase TLS_CIPHER_ARIA_GCM_256:\n\t\ttls12->len = sizeof(struct tls12_crypto_info_aria_gcm_256);\n\t\ttls12->ariagcm256.info.version = tls_version;\n\t\ttls12->ariagcm256.info.cipher_type = cipher_type;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void memrnd(void *s, size_t n)\n{\n\tint *dword = s;\n\tchar *byte;\n\n\tfor (; n >= 4; n -= 4)\n\t\t*dword++ = rand();\n\tbyte = (void *)dword;\n\twhile (n--)\n\t\t*byte++ = rand();\n}\n\nstatic void ulp_sock_pair(struct __test_metadata *_metadata,\n\t\t\t  int *fd, int *cfd, bool *notls)\n{\n\tstruct sockaddr_in addr;\n\tsocklen_t len;\n\tint sfd, ret;\n\n\t*notls = false;\n\tlen = sizeof(addr);\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = 0;\n\n\t*fd = socket(AF_INET, SOCK_STREAM, 0);\n\tsfd = socket(AF_INET, SOCK_STREAM, 0);\n\n\tret = bind(sfd, &addr, sizeof(addr));\n\tASSERT_EQ(ret, 0);\n\tret = listen(sfd, 10);\n\tASSERT_EQ(ret, 0);\n\n\tret = getsockname(sfd, &addr, &len);\n\tASSERT_EQ(ret, 0);\n\n\tret = connect(*fd, &addr, sizeof(addr));\n\tASSERT_EQ(ret, 0);\n\n\t*cfd = accept(sfd, &addr, &len);\n\tASSERT_GE(*cfd, 0);\n\n\tclose(sfd);\n\n\tret = setsockopt(*fd, IPPROTO_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"));\n\tif (ret != 0) {\n\t\tASSERT_EQ(errno, ENOENT);\n\t\t*notls = true;\n\t\tprintf(\"Failure setting TCP_ULP, testing without tls\\n\");\n\t\treturn;\n\t}\n\n\tret = setsockopt(*cfd, IPPROTO_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"));\n\tASSERT_EQ(ret, 0);\n}\n\n \nstatic int tls_send_cmsg(int fd, unsigned char record_type,\n\t\t\t void *data, size_t len, int flags)\n{\n\tchar cbuf[CMSG_SPACE(sizeof(char))];\n\tint cmsg_len = sizeof(char);\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr msg;\n\tstruct iovec vec;\n\n\tvec.iov_base = data;\n\tvec.iov_len = len;\n\tmemset(&msg, 0, sizeof(struct msghdr));\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = cbuf;\n\tmsg.msg_controllen = sizeof(cbuf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_TLS;\n\t \n\tcmsg->cmsg_type = TLS_SET_RECORD_TYPE;\n\tcmsg->cmsg_len = CMSG_LEN(cmsg_len);\n\t*CMSG_DATA(cmsg) = record_type;\n\tmsg.msg_controllen = cmsg->cmsg_len;\n\n\treturn sendmsg(fd, &msg, flags);\n}\n\nstatic int tls_recv_cmsg(struct __test_metadata *_metadata,\n\t\t\t int fd, unsigned char record_type,\n\t\t\t void *data, size_t len, int flags)\n{\n\tchar cbuf[CMSG_SPACE(sizeof(char))];\n\tstruct cmsghdr *cmsg;\n\tunsigned char ctype;\n\tstruct msghdr msg;\n\tstruct iovec vec;\n\tint n;\n\n\tvec.iov_base = data;\n\tvec.iov_len = len;\n\tmemset(&msg, 0, sizeof(struct msghdr));\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = cbuf;\n\tmsg.msg_controllen = sizeof(cbuf);\n\n\tn = recvmsg(fd, &msg, flags);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tEXPECT_NE(cmsg, NULL);\n\tEXPECT_EQ(cmsg->cmsg_level, SOL_TLS);\n\tEXPECT_EQ(cmsg->cmsg_type, TLS_GET_RECORD_TYPE);\n\tctype = *((unsigned char *)CMSG_DATA(cmsg));\n\tEXPECT_EQ(ctype, record_type);\n\n\treturn n;\n}\n\nFIXTURE(tls_basic)\n{\n\tint fd, cfd;\n\tbool notls;\n};\n\nFIXTURE_SETUP(tls_basic)\n{\n\tulp_sock_pair(_metadata, &self->fd, &self->cfd, &self->notls);\n}\n\nFIXTURE_TEARDOWN(tls_basic)\n{\n\tclose(self->fd);\n\tclose(self->cfd);\n}\n\n \nTEST_F(tls_basic, base_base)\n{\n\tchar const *test_str = \"test_read\";\n\tint send_len = 10;\n\tchar buf[10];\n\n\tASSERT_EQ(strlen(test_str) + 1, send_len);\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tEXPECT_NE(recv(self->cfd, buf, send_len, 0), -1);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n};\n\nTEST_F(tls_basic, bad_cipher)\n{\n\tstruct tls_crypto_info_keys tls12;\n\n\ttls12.crypto_info.version = 200;\n\ttls12.crypto_info.cipher_type = TLS_CIPHER_AES_GCM_128;\n\tEXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, sizeof(struct tls12_crypto_info_aes_gcm_128)), -1);\n\n\ttls12.crypto_info.version = TLS_1_2_VERSION;\n\ttls12.crypto_info.cipher_type = 50;\n\tEXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, sizeof(struct tls12_crypto_info_aes_gcm_128)), -1);\n\n\ttls12.crypto_info.version = TLS_1_2_VERSION;\n\ttls12.crypto_info.cipher_type = 59;\n\tEXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, sizeof(struct tls12_crypto_info_aes_gcm_128)), -1);\n\n\ttls12.crypto_info.version = TLS_1_2_VERSION;\n\ttls12.crypto_info.cipher_type = 10;\n\tEXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, sizeof(struct tls12_crypto_info_aes_gcm_128)), -1);\n\n\ttls12.crypto_info.version = TLS_1_2_VERSION;\n\ttls12.crypto_info.cipher_type = 70;\n\tEXPECT_EQ(setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, sizeof(struct tls12_crypto_info_aes_gcm_128)), -1);\n}\n\nFIXTURE(tls)\n{\n\tint fd, cfd;\n\tbool notls;\n};\n\nFIXTURE_VARIANT(tls)\n{\n\tuint16_t tls_version;\n\tuint16_t cipher_type;\n\tbool nopad, fips_non_compliant;\n};\n\nFIXTURE_VARIANT_ADD(tls, 12_aes_gcm)\n{\n\t.tls_version = TLS_1_2_VERSION,\n\t.cipher_type = TLS_CIPHER_AES_GCM_128,\n};\n\nFIXTURE_VARIANT_ADD(tls, 13_aes_gcm)\n{\n\t.tls_version = TLS_1_3_VERSION,\n\t.cipher_type = TLS_CIPHER_AES_GCM_128,\n};\n\nFIXTURE_VARIANT_ADD(tls, 12_chacha)\n{\n\t.tls_version = TLS_1_2_VERSION,\n\t.cipher_type = TLS_CIPHER_CHACHA20_POLY1305,\n\t.fips_non_compliant = true,\n};\n\nFIXTURE_VARIANT_ADD(tls, 13_chacha)\n{\n\t.tls_version = TLS_1_3_VERSION,\n\t.cipher_type = TLS_CIPHER_CHACHA20_POLY1305,\n\t.fips_non_compliant = true,\n};\n\nFIXTURE_VARIANT_ADD(tls, 13_sm4_gcm)\n{\n\t.tls_version = TLS_1_3_VERSION,\n\t.cipher_type = TLS_CIPHER_SM4_GCM,\n\t.fips_non_compliant = true,\n};\n\nFIXTURE_VARIANT_ADD(tls, 13_sm4_ccm)\n{\n\t.tls_version = TLS_1_3_VERSION,\n\t.cipher_type = TLS_CIPHER_SM4_CCM,\n\t.fips_non_compliant = true,\n};\n\nFIXTURE_VARIANT_ADD(tls, 12_aes_ccm)\n{\n\t.tls_version = TLS_1_2_VERSION,\n\t.cipher_type = TLS_CIPHER_AES_CCM_128,\n};\n\nFIXTURE_VARIANT_ADD(tls, 13_aes_ccm)\n{\n\t.tls_version = TLS_1_3_VERSION,\n\t.cipher_type = TLS_CIPHER_AES_CCM_128,\n};\n\nFIXTURE_VARIANT_ADD(tls, 12_aes_gcm_256)\n{\n\t.tls_version = TLS_1_2_VERSION,\n\t.cipher_type = TLS_CIPHER_AES_GCM_256,\n};\n\nFIXTURE_VARIANT_ADD(tls, 13_aes_gcm_256)\n{\n\t.tls_version = TLS_1_3_VERSION,\n\t.cipher_type = TLS_CIPHER_AES_GCM_256,\n};\n\nFIXTURE_VARIANT_ADD(tls, 13_nopad)\n{\n\t.tls_version = TLS_1_3_VERSION,\n\t.cipher_type = TLS_CIPHER_AES_GCM_128,\n\t.nopad = true,\n};\n\nFIXTURE_VARIANT_ADD(tls, 12_aria_gcm)\n{\n\t.tls_version = TLS_1_2_VERSION,\n\t.cipher_type = TLS_CIPHER_ARIA_GCM_128,\n};\n\nFIXTURE_VARIANT_ADD(tls, 12_aria_gcm_256)\n{\n\t.tls_version = TLS_1_2_VERSION,\n\t.cipher_type = TLS_CIPHER_ARIA_GCM_256,\n};\n\nFIXTURE_SETUP(tls)\n{\n\tstruct tls_crypto_info_keys tls12;\n\tint one = 1;\n\tint ret;\n\n\tif (fips_enabled && variant->fips_non_compliant)\n\t\tSKIP(return, \"Unsupported cipher in FIPS mode\");\n\n\ttls_crypto_info_init(variant->tls_version, variant->cipher_type,\n\t\t\t     &tls12);\n\n\tulp_sock_pair(_metadata, &self->fd, &self->cfd, &self->notls);\n\n\tif (self->notls)\n\t\treturn;\n\n\tret = setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len);\n\tASSERT_EQ(ret, 0);\n\n\tret = setsockopt(self->cfd, SOL_TLS, TLS_RX, &tls12, tls12.len);\n\tASSERT_EQ(ret, 0);\n\n\tif (variant->nopad) {\n\t\tret = setsockopt(self->cfd, SOL_TLS, TLS_RX_EXPECT_NO_PAD,\n\t\t\t\t (void *)&one, sizeof(one));\n\t\tASSERT_EQ(ret, 0);\n\t}\n}\n\nFIXTURE_TEARDOWN(tls)\n{\n\tclose(self->fd);\n\tclose(self->cfd);\n}\n\nTEST_F(tls, sendfile)\n{\n\tint filefd = open(\"/proc/self/exe\", O_RDONLY);\n\tstruct stat st;\n\n\tEXPECT_GE(filefd, 0);\n\tfstat(filefd, &st);\n\tEXPECT_GE(sendfile(self->fd, filefd, 0, st.st_size), 0);\n}\n\nTEST_F(tls, send_then_sendfile)\n{\n\tint filefd = open(\"/proc/self/exe\", O_RDONLY);\n\tchar const *test_str = \"test_send\";\n\tint to_send = strlen(test_str) + 1;\n\tchar recv_buf[10];\n\tstruct stat st;\n\tchar *buf;\n\n\tEXPECT_GE(filefd, 0);\n\tfstat(filefd, &st);\n\tbuf = (char *)malloc(st.st_size);\n\n\tEXPECT_EQ(send(self->fd, test_str, to_send, 0), to_send);\n\tEXPECT_EQ(recv(self->cfd, recv_buf, to_send, MSG_WAITALL), to_send);\n\tEXPECT_EQ(memcmp(test_str, recv_buf, to_send), 0);\n\n\tEXPECT_GE(sendfile(self->fd, filefd, 0, st.st_size), 0);\n\tEXPECT_EQ(recv(self->cfd, buf, st.st_size, MSG_WAITALL), st.st_size);\n}\n\nstatic void chunked_sendfile(struct __test_metadata *_metadata,\n\t\t\t     struct _test_data_tls *self,\n\t\t\t     uint16_t chunk_size,\n\t\t\t     uint16_t extra_payload_size)\n{\n\tchar buf[TLS_PAYLOAD_MAX_LEN];\n\tuint16_t test_payload_size;\n\tint size = 0;\n\tint ret;\n\tchar filename[] = \"/tmp/mytemp.XXXXXX\";\n\tint fd = mkstemp(filename);\n\toff_t offset = 0;\n\n\tunlink(filename);\n\tASSERT_GE(fd, 0);\n\tEXPECT_GE(chunk_size, 1);\n\ttest_payload_size = chunk_size + extra_payload_size;\n\tASSERT_GE(TLS_PAYLOAD_MAX_LEN, test_payload_size);\n\tmemset(buf, 1, test_payload_size);\n\tsize = write(fd, buf, test_payload_size);\n\tEXPECT_EQ(size, test_payload_size);\n\tfsync(fd);\n\n\twhile (size > 0) {\n\t\tret = sendfile(self->fd, fd, &offset, chunk_size);\n\t\tEXPECT_GE(ret, 0);\n\t\tsize -= ret;\n\t}\n\n\tEXPECT_EQ(recv(self->cfd, buf, test_payload_size, MSG_WAITALL),\n\t\t  test_payload_size);\n\n\tclose(fd);\n}\n\nTEST_F(tls, multi_chunk_sendfile)\n{\n\tchunked_sendfile(_metadata, self, 4096, 4096);\n\tchunked_sendfile(_metadata, self, 4096, 0);\n\tchunked_sendfile(_metadata, self, 4096, 1);\n\tchunked_sendfile(_metadata, self, 4096, 2048);\n\tchunked_sendfile(_metadata, self, 8192, 2048);\n\tchunked_sendfile(_metadata, self, 4096, 8192);\n\tchunked_sendfile(_metadata, self, 8192, 4096);\n\tchunked_sendfile(_metadata, self, 12288, 1024);\n\tchunked_sendfile(_metadata, self, 12288, 2000);\n\tchunked_sendfile(_metadata, self, 15360, 100);\n\tchunked_sendfile(_metadata, self, 15360, 300);\n\tchunked_sendfile(_metadata, self, 1, 4096);\n\tchunked_sendfile(_metadata, self, 2048, 4096);\n\tchunked_sendfile(_metadata, self, 2048, 8192);\n\tchunked_sendfile(_metadata, self, 4096, 8192);\n\tchunked_sendfile(_metadata, self, 1024, 12288);\n\tchunked_sendfile(_metadata, self, 2000, 12288);\n\tchunked_sendfile(_metadata, self, 100, 15360);\n\tchunked_sendfile(_metadata, self, 300, 15360);\n}\n\nTEST_F(tls, recv_max)\n{\n\tunsigned int send_len = TLS_PAYLOAD_MAX_LEN;\n\tchar recv_mem[TLS_PAYLOAD_MAX_LEN];\n\tchar buf[TLS_PAYLOAD_MAX_LEN];\n\n\tmemrnd(buf, sizeof(buf));\n\n\tEXPECT_GE(send(self->fd, buf, send_len, 0), 0);\n\tEXPECT_NE(recv(self->cfd, recv_mem, send_len, 0), -1);\n\tEXPECT_EQ(memcmp(buf, recv_mem, send_len), 0);\n}\n\nTEST_F(tls, recv_small)\n{\n\tchar const *test_str = \"test_read\";\n\tint send_len = 10;\n\tchar buf[10];\n\n\tsend_len = strlen(test_str) + 1;\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tEXPECT_NE(recv(self->cfd, buf, send_len, 0), -1);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n}\n\nTEST_F(tls, msg_more)\n{\n\tchar const *test_str = \"test_read\";\n\tint send_len = 10;\n\tchar buf[10 * 2];\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, MSG_MORE), send_len);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len, MSG_DONTWAIT), -1);\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len * 2, MSG_WAITALL),\n\t\t  send_len * 2);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n}\n\nTEST_F(tls, msg_more_unsent)\n{\n\tchar const *test_str = \"test_read\";\n\tint send_len = 10;\n\tchar buf[10];\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, MSG_MORE), send_len);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len, MSG_DONTWAIT), -1);\n}\n\nTEST_F(tls, msg_eor)\n{\n\tchar const *test_str = \"test_read\";\n\tint send_len = 10;\n\tchar buf[10];\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, MSG_EOR), send_len);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len, MSG_WAITALL), send_len);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n}\n\nTEST_F(tls, sendmsg_single)\n{\n\tstruct msghdr msg;\n\n\tchar const *test_str = \"test_sendmsg\";\n\tsize_t send_len = 13;\n\tstruct iovec vec;\n\tchar buf[13];\n\n\tvec.iov_base = (char *)test_str;\n\tvec.iov_len = send_len;\n\tmemset(&msg, 0, sizeof(struct msghdr));\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\tEXPECT_EQ(sendmsg(self->fd, &msg, 0), send_len);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len, MSG_WAITALL), send_len);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n}\n\n#define MAX_FRAGS\t64\n#define SEND_LEN\t13\nTEST_F(tls, sendmsg_fragmented)\n{\n\tchar const *test_str = \"test_sendmsg\";\n\tchar buf[SEND_LEN * MAX_FRAGS];\n\tstruct iovec vec[MAX_FRAGS];\n\tstruct msghdr msg;\n\tint i, frags;\n\n\tfor (frags = 1; frags <= MAX_FRAGS; frags++) {\n\t\tfor (i = 0; i < frags; i++) {\n\t\t\tvec[i].iov_base = (char *)test_str;\n\t\t\tvec[i].iov_len = SEND_LEN;\n\t\t}\n\n\t\tmemset(&msg, 0, sizeof(struct msghdr));\n\t\tmsg.msg_iov = vec;\n\t\tmsg.msg_iovlen = frags;\n\n\t\tEXPECT_EQ(sendmsg(self->fd, &msg, 0), SEND_LEN * frags);\n\t\tEXPECT_EQ(recv(self->cfd, buf, SEND_LEN * frags, MSG_WAITALL),\n\t\t\t  SEND_LEN * frags);\n\n\t\tfor (i = 0; i < frags; i++)\n\t\t\tEXPECT_EQ(memcmp(buf + SEND_LEN * i,\n\t\t\t\t\t test_str, SEND_LEN), 0);\n\t}\n}\n#undef MAX_FRAGS\n#undef SEND_LEN\n\nTEST_F(tls, sendmsg_large)\n{\n\tvoid *mem = malloc(16384);\n\tsize_t send_len = 16384;\n\tsize_t sends = 128;\n\tstruct msghdr msg;\n\tsize_t recvs = 0;\n\tsize_t sent = 0;\n\n\tmemset(&msg, 0, sizeof(struct msghdr));\n\twhile (sent++ < sends) {\n\t\tstruct iovec vec = { (void *)mem, send_len };\n\n\t\tmsg.msg_iov = &vec;\n\t\tmsg.msg_iovlen = 1;\n\t\tEXPECT_EQ(sendmsg(self->fd, &msg, 0), send_len);\n\t}\n\n\twhile (recvs++ < sends) {\n\t\tEXPECT_NE(recv(self->cfd, mem, send_len, 0), -1);\n\t}\n\n\tfree(mem);\n}\n\nTEST_F(tls, sendmsg_multiple)\n{\n\tchar const *test_str = \"test_sendmsg_multiple\";\n\tstruct iovec vec[5];\n\tchar *test_strs[5];\n\tstruct msghdr msg;\n\tint total_len = 0;\n\tint len_cmp = 0;\n\tint iov_len = 5;\n\tchar *buf;\n\tint i;\n\n\tmemset(&msg, 0, sizeof(struct msghdr));\n\tfor (i = 0; i < iov_len; i++) {\n\t\ttest_strs[i] = (char *)malloc(strlen(test_str) + 1);\n\t\tsnprintf(test_strs[i], strlen(test_str) + 1, \"%s\", test_str);\n\t\tvec[i].iov_base = (void *)test_strs[i];\n\t\tvec[i].iov_len = strlen(test_strs[i]) + 1;\n\t\ttotal_len += vec[i].iov_len;\n\t}\n\tmsg.msg_iov = vec;\n\tmsg.msg_iovlen = iov_len;\n\n\tEXPECT_EQ(sendmsg(self->fd, &msg, 0), total_len);\n\tbuf = malloc(total_len);\n\tEXPECT_NE(recv(self->cfd, buf, total_len, 0), -1);\n\tfor (i = 0; i < iov_len; i++) {\n\t\tEXPECT_EQ(memcmp(test_strs[i], buf + len_cmp,\n\t\t\t\t strlen(test_strs[i])),\n\t\t\t  0);\n\t\tlen_cmp += strlen(buf + len_cmp) + 1;\n\t}\n\tfor (i = 0; i < iov_len; i++)\n\t\tfree(test_strs[i]);\n\tfree(buf);\n}\n\nTEST_F(tls, sendmsg_multiple_stress)\n{\n\tchar const *test_str = \"abcdefghijklmno\";\n\tstruct iovec vec[1024];\n\tchar *test_strs[1024];\n\tint iov_len = 1024;\n\tint total_len = 0;\n\tchar buf[1 << 14];\n\tstruct msghdr msg;\n\tint len_cmp = 0;\n\tint i;\n\n\tmemset(&msg, 0, sizeof(struct msghdr));\n\tfor (i = 0; i < iov_len; i++) {\n\t\ttest_strs[i] = (char *)malloc(strlen(test_str) + 1);\n\t\tsnprintf(test_strs[i], strlen(test_str) + 1, \"%s\", test_str);\n\t\tvec[i].iov_base = (void *)test_strs[i];\n\t\tvec[i].iov_len = strlen(test_strs[i]) + 1;\n\t\ttotal_len += vec[i].iov_len;\n\t}\n\tmsg.msg_iov = vec;\n\tmsg.msg_iovlen = iov_len;\n\n\tEXPECT_EQ(sendmsg(self->fd, &msg, 0), total_len);\n\tEXPECT_NE(recv(self->cfd, buf, total_len, 0), -1);\n\n\tfor (i = 0; i < iov_len; i++)\n\t\tlen_cmp += strlen(buf + len_cmp) + 1;\n\n\tfor (i = 0; i < iov_len; i++)\n\t\tfree(test_strs[i]);\n}\n\nTEST_F(tls, splice_from_pipe)\n{\n\tint send_len = TLS_PAYLOAD_MAX_LEN;\n\tchar mem_send[TLS_PAYLOAD_MAX_LEN];\n\tchar mem_recv[TLS_PAYLOAD_MAX_LEN];\n\tint p[2];\n\n\tASSERT_GE(pipe(p), 0);\n\tEXPECT_GE(write(p[1], mem_send, send_len), 0);\n\tEXPECT_GE(splice(p[0], NULL, self->fd, NULL, send_len, 0), 0);\n\tEXPECT_EQ(recv(self->cfd, mem_recv, send_len, MSG_WAITALL), send_len);\n\tEXPECT_EQ(memcmp(mem_send, mem_recv, send_len), 0);\n}\n\nTEST_F(tls, splice_from_pipe2)\n{\n\tint send_len = 16000;\n\tchar mem_send[16000];\n\tchar mem_recv[16000];\n\tint p2[2];\n\tint p[2];\n\n\tmemrnd(mem_send, sizeof(mem_send));\n\n\tASSERT_GE(pipe(p), 0);\n\tASSERT_GE(pipe(p2), 0);\n\tEXPECT_EQ(write(p[1], mem_send, 8000), 8000);\n\tEXPECT_EQ(splice(p[0], NULL, self->fd, NULL, 8000, 0), 8000);\n\tEXPECT_EQ(write(p2[1], mem_send + 8000, 8000), 8000);\n\tEXPECT_EQ(splice(p2[0], NULL, self->fd, NULL, 8000, 0), 8000);\n\tEXPECT_EQ(recv(self->cfd, mem_recv, send_len, MSG_WAITALL), send_len);\n\tEXPECT_EQ(memcmp(mem_send, mem_recv, send_len), 0);\n}\n\nTEST_F(tls, send_and_splice)\n{\n\tint send_len = TLS_PAYLOAD_MAX_LEN;\n\tchar mem_send[TLS_PAYLOAD_MAX_LEN];\n\tchar mem_recv[TLS_PAYLOAD_MAX_LEN];\n\tchar const *test_str = \"test_read\";\n\tint send_len2 = 10;\n\tchar buf[10];\n\tint p[2];\n\n\tASSERT_GE(pipe(p), 0);\n\tEXPECT_EQ(send(self->fd, test_str, send_len2, 0), send_len2);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len2, MSG_WAITALL), send_len2);\n\tEXPECT_EQ(memcmp(test_str, buf, send_len2), 0);\n\n\tEXPECT_GE(write(p[1], mem_send, send_len), send_len);\n\tEXPECT_GE(splice(p[0], NULL, self->fd, NULL, send_len, 0), send_len);\n\n\tEXPECT_EQ(recv(self->cfd, mem_recv, send_len, MSG_WAITALL), send_len);\n\tEXPECT_EQ(memcmp(mem_send, mem_recv, send_len), 0);\n}\n\nTEST_F(tls, splice_to_pipe)\n{\n\tint send_len = TLS_PAYLOAD_MAX_LEN;\n\tchar mem_send[TLS_PAYLOAD_MAX_LEN];\n\tchar mem_recv[TLS_PAYLOAD_MAX_LEN];\n\tint p[2];\n\n\tmemrnd(mem_send, sizeof(mem_send));\n\n\tASSERT_GE(pipe(p), 0);\n\tEXPECT_EQ(send(self->fd, mem_send, send_len, 0), send_len);\n\tEXPECT_EQ(splice(self->cfd, NULL, p[1], NULL, send_len, 0), send_len);\n\tEXPECT_EQ(read(p[0], mem_recv, send_len), send_len);\n\tEXPECT_EQ(memcmp(mem_send, mem_recv, send_len), 0);\n}\n\nTEST_F(tls, splice_cmsg_to_pipe)\n{\n\tchar *test_str = \"test_read\";\n\tchar record_type = 100;\n\tint send_len = 10;\n\tchar buf[10];\n\tint p[2];\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\tASSERT_GE(pipe(p), 0);\n\tEXPECT_EQ(tls_send_cmsg(self->fd, 100, test_str, send_len, 0), 10);\n\tEXPECT_EQ(splice(self->cfd, NULL, p[1], NULL, send_len, 0), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len, 0), -1);\n\tEXPECT_EQ(errno, EIO);\n\tEXPECT_EQ(tls_recv_cmsg(_metadata, self->cfd, record_type,\n\t\t\t\tbuf, sizeof(buf), MSG_WAITALL),\n\t\t  send_len);\n\tEXPECT_EQ(memcmp(test_str, buf, send_len), 0);\n}\n\nTEST_F(tls, splice_dec_cmsg_to_pipe)\n{\n\tchar *test_str = \"test_read\";\n\tchar record_type = 100;\n\tint send_len = 10;\n\tchar buf[10];\n\tint p[2];\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\tASSERT_GE(pipe(p), 0);\n\tEXPECT_EQ(tls_send_cmsg(self->fd, 100, test_str, send_len, 0), 10);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len, 0), -1);\n\tEXPECT_EQ(errno, EIO);\n\tEXPECT_EQ(splice(self->cfd, NULL, p[1], NULL, send_len, 0), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\tEXPECT_EQ(tls_recv_cmsg(_metadata, self->cfd, record_type,\n\t\t\t\tbuf, sizeof(buf), MSG_WAITALL),\n\t\t  send_len);\n\tEXPECT_EQ(memcmp(test_str, buf, send_len), 0);\n}\n\nTEST_F(tls, recv_and_splice)\n{\n\tint send_len = TLS_PAYLOAD_MAX_LEN;\n\tchar mem_send[TLS_PAYLOAD_MAX_LEN];\n\tchar mem_recv[TLS_PAYLOAD_MAX_LEN];\n\tint half = send_len / 2;\n\tint p[2];\n\n\tASSERT_GE(pipe(p), 0);\n\tEXPECT_EQ(send(self->fd, mem_send, send_len, 0), send_len);\n\t \n\tEXPECT_EQ(recv(self->cfd, mem_recv, half, MSG_WAITALL), half);\n\tEXPECT_EQ(splice(self->cfd, NULL, p[1], NULL, half, SPLICE_F_NONBLOCK),\n\t\t  half);\n\tEXPECT_EQ(read(p[0], &mem_recv[half], half), half);\n\tEXPECT_EQ(memcmp(mem_send, mem_recv, send_len), 0);\n}\n\nTEST_F(tls, peek_and_splice)\n{\n\tint send_len = TLS_PAYLOAD_MAX_LEN;\n\tchar mem_send[TLS_PAYLOAD_MAX_LEN];\n\tchar mem_recv[TLS_PAYLOAD_MAX_LEN];\n\tint chunk = TLS_PAYLOAD_MAX_LEN / 4;\n\tint n, i, p[2];\n\n\tmemrnd(mem_send, sizeof(mem_send));\n\n\tASSERT_GE(pipe(p), 0);\n\tfor (i = 0; i < 4; i++)\n\t\tEXPECT_EQ(send(self->fd, &mem_send[chunk * i], chunk, 0),\n\t\t\t  chunk);\n\n\tEXPECT_EQ(recv(self->cfd, mem_recv, chunk * 5 / 2,\n\t\t       MSG_WAITALL | MSG_PEEK),\n\t\t  chunk * 5 / 2);\n\tEXPECT_EQ(memcmp(mem_send, mem_recv, chunk * 5 / 2), 0);\n\n\tn = 0;\n\twhile (n < send_len) {\n\t\ti = splice(self->cfd, NULL, p[1], NULL, send_len - n, 0);\n\t\tEXPECT_GT(i, 0);\n\t\tn += i;\n\t}\n\tEXPECT_EQ(n, send_len);\n\tEXPECT_EQ(read(p[0], mem_recv, send_len), send_len);\n\tEXPECT_EQ(memcmp(mem_send, mem_recv, send_len), 0);\n}\n\nTEST_F(tls, recvmsg_single)\n{\n\tchar const *test_str = \"test_recvmsg_single\";\n\tint send_len = strlen(test_str) + 1;\n\tchar buf[20];\n\tstruct msghdr hdr;\n\tstruct iovec vec;\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tvec.iov_base = (char *)buf;\n\tvec.iov_len = send_len;\n\thdr.msg_iovlen = 1;\n\thdr.msg_iov = &vec;\n\tEXPECT_NE(recvmsg(self->cfd, &hdr, 0), -1);\n\tEXPECT_EQ(memcmp(test_str, buf, send_len), 0);\n}\n\nTEST_F(tls, recvmsg_single_max)\n{\n\tint send_len = TLS_PAYLOAD_MAX_LEN;\n\tchar send_mem[TLS_PAYLOAD_MAX_LEN];\n\tchar recv_mem[TLS_PAYLOAD_MAX_LEN];\n\tstruct iovec vec;\n\tstruct msghdr hdr;\n\n\tmemrnd(send_mem, sizeof(send_mem));\n\n\tEXPECT_EQ(send(self->fd, send_mem, send_len, 0), send_len);\n\tvec.iov_base = (char *)recv_mem;\n\tvec.iov_len = TLS_PAYLOAD_MAX_LEN;\n\n\thdr.msg_iovlen = 1;\n\thdr.msg_iov = &vec;\n\tEXPECT_NE(recvmsg(self->cfd, &hdr, 0), -1);\n\tEXPECT_EQ(memcmp(send_mem, recv_mem, send_len), 0);\n}\n\nTEST_F(tls, recvmsg_multiple)\n{\n\tunsigned int msg_iovlen = 1024;\n\tstruct iovec vec[1024];\n\tchar *iov_base[1024];\n\tunsigned int iov_len = 16;\n\tint send_len = 1 << 14;\n\tchar buf[1 << 14];\n\tstruct msghdr hdr;\n\tint i;\n\n\tmemrnd(buf, sizeof(buf));\n\n\tEXPECT_EQ(send(self->fd, buf, send_len, 0), send_len);\n\tfor (i = 0; i < msg_iovlen; i++) {\n\t\tiov_base[i] = (char *)malloc(iov_len);\n\t\tvec[i].iov_base = iov_base[i];\n\t\tvec[i].iov_len = iov_len;\n\t}\n\n\thdr.msg_iovlen = msg_iovlen;\n\thdr.msg_iov = vec;\n\tEXPECT_NE(recvmsg(self->cfd, &hdr, 0), -1);\n\n\tfor (i = 0; i < msg_iovlen; i++)\n\t\tfree(iov_base[i]);\n}\n\nTEST_F(tls, single_send_multiple_recv)\n{\n\tunsigned int total_len = TLS_PAYLOAD_MAX_LEN * 2;\n\tunsigned int send_len = TLS_PAYLOAD_MAX_LEN;\n\tchar send_mem[TLS_PAYLOAD_MAX_LEN * 2];\n\tchar recv_mem[TLS_PAYLOAD_MAX_LEN * 2];\n\n\tmemrnd(send_mem, sizeof(send_mem));\n\n\tEXPECT_GE(send(self->fd, send_mem, total_len, 0), 0);\n\tmemset(recv_mem, 0, total_len);\n\n\tEXPECT_NE(recv(self->cfd, recv_mem, send_len, 0), -1);\n\tEXPECT_NE(recv(self->cfd, recv_mem + send_len, send_len, 0), -1);\n\tEXPECT_EQ(memcmp(send_mem, recv_mem, total_len), 0);\n}\n\nTEST_F(tls, multiple_send_single_recv)\n{\n\tunsigned int total_len = 2 * 10;\n\tunsigned int send_len = 10;\n\tchar recv_mem[2 * 10];\n\tchar send_mem[10];\n\n\tmemrnd(send_mem, sizeof(send_mem));\n\n\tEXPECT_GE(send(self->fd, send_mem, send_len, 0), 0);\n\tEXPECT_GE(send(self->fd, send_mem, send_len, 0), 0);\n\tmemset(recv_mem, 0, total_len);\n\tEXPECT_EQ(recv(self->cfd, recv_mem, total_len, MSG_WAITALL), total_len);\n\n\tEXPECT_EQ(memcmp(send_mem, recv_mem, send_len), 0);\n\tEXPECT_EQ(memcmp(send_mem, recv_mem + send_len, send_len), 0);\n}\n\nTEST_F(tls, single_send_multiple_recv_non_align)\n{\n\tconst unsigned int total_len = 15;\n\tconst unsigned int recv_len = 10;\n\tchar recv_mem[recv_len * 2];\n\tchar send_mem[total_len];\n\n\tmemrnd(send_mem, sizeof(send_mem));\n\n\tEXPECT_GE(send(self->fd, send_mem, total_len, 0), 0);\n\tmemset(recv_mem, 0, total_len);\n\n\tEXPECT_EQ(recv(self->cfd, recv_mem, recv_len, 0), recv_len);\n\tEXPECT_EQ(recv(self->cfd, recv_mem + recv_len, recv_len, 0), 5);\n\tEXPECT_EQ(memcmp(send_mem, recv_mem, total_len), 0);\n}\n\nTEST_F(tls, recv_partial)\n{\n\tchar const *test_str = \"test_read_partial\";\n\tchar const *test_str_first = \"test_read\";\n\tchar const *test_str_second = \"_partial\";\n\tint send_len = strlen(test_str) + 1;\n\tchar recv_mem[18];\n\n\tmemset(recv_mem, 0, sizeof(recv_mem));\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tEXPECT_NE(recv(self->cfd, recv_mem, strlen(test_str_first),\n\t\t       MSG_WAITALL), -1);\n\tEXPECT_EQ(memcmp(test_str_first, recv_mem, strlen(test_str_first)), 0);\n\tmemset(recv_mem, 0, sizeof(recv_mem));\n\tEXPECT_NE(recv(self->cfd, recv_mem, strlen(test_str_second),\n\t\t       MSG_WAITALL), -1);\n\tEXPECT_EQ(memcmp(test_str_second, recv_mem, strlen(test_str_second)),\n\t\t  0);\n}\n\nTEST_F(tls, recv_nonblock)\n{\n\tchar buf[4096];\n\tbool err;\n\n\tEXPECT_EQ(recv(self->cfd, buf, sizeof(buf), MSG_DONTWAIT), -1);\n\terr = (errno == EAGAIN || errno == EWOULDBLOCK);\n\tEXPECT_EQ(err, true);\n}\n\nTEST_F(tls, recv_peek)\n{\n\tchar const *test_str = \"test_read_peek\";\n\tint send_len = strlen(test_str) + 1;\n\tchar buf[15];\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len, MSG_PEEK), send_len);\n\tEXPECT_EQ(memcmp(test_str, buf, send_len), 0);\n\tmemset(buf, 0, sizeof(buf));\n\tEXPECT_EQ(recv(self->cfd, buf, send_len, 0), send_len);\n\tEXPECT_EQ(memcmp(test_str, buf, send_len), 0);\n}\n\nTEST_F(tls, recv_peek_multiple)\n{\n\tchar const *test_str = \"test_read_peek\";\n\tint send_len = strlen(test_str) + 1;\n\tunsigned int num_peeks = 100;\n\tchar buf[15];\n\tint i;\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tfor (i = 0; i < num_peeks; i++) {\n\t\tEXPECT_NE(recv(self->cfd, buf, send_len, MSG_PEEK), -1);\n\t\tEXPECT_EQ(memcmp(test_str, buf, send_len), 0);\n\t\tmemset(buf, 0, sizeof(buf));\n\t}\n\tEXPECT_NE(recv(self->cfd, buf, send_len, 0), -1);\n\tEXPECT_EQ(memcmp(test_str, buf, send_len), 0);\n}\n\nTEST_F(tls, recv_peek_multiple_records)\n{\n\tchar const *test_str = \"test_read_peek_mult_recs\";\n\tchar const *test_str_first = \"test_read_peek\";\n\tchar const *test_str_second = \"_mult_recs\";\n\tint len;\n\tchar buf[64];\n\n\tlen = strlen(test_str_first);\n\tEXPECT_EQ(send(self->fd, test_str_first, len, 0), len);\n\n\tlen = strlen(test_str_second) + 1;\n\tEXPECT_EQ(send(self->fd, test_str_second, len, 0), len);\n\n\tlen = strlen(test_str_first);\n\tmemset(buf, 0, len);\n\tEXPECT_EQ(recv(self->cfd, buf, len, MSG_PEEK | MSG_WAITALL), len);\n\n\t \n\tlen = strlen(test_str_first);\n\tEXPECT_EQ(memcmp(test_str_first, buf, len), 0);\n\n\tlen = strlen(test_str) + 1;\n\tmemset(buf, 0, len);\n\tEXPECT_EQ(recv(self->cfd, buf, len, MSG_WAITALL), len);\n\n\t \n\tlen = strlen(test_str) + 1;\n\tEXPECT_EQ(memcmp(test_str, buf, len), 0);\n\n\t \n\tlen = strlen(test_str_first);\n\tEXPECT_EQ(send(self->fd, test_str_first, len, MSG_MORE), len);\n\n\tlen = strlen(test_str_second) + 1;\n\tEXPECT_EQ(send(self->fd, test_str_second, len, 0), len);\n\n\tlen = strlen(test_str) + 1;\n\tmemset(buf, 0, len);\n\tEXPECT_EQ(recv(self->cfd, buf, len, MSG_PEEK | MSG_WAITALL), len);\n\n\tlen = strlen(test_str) + 1;\n\tEXPECT_EQ(memcmp(test_str, buf, len), 0);\n}\n\nTEST_F(tls, recv_peek_large_buf_mult_recs)\n{\n\tchar const *test_str = \"test_read_peek_mult_recs\";\n\tchar const *test_str_first = \"test_read_peek\";\n\tchar const *test_str_second = \"_mult_recs\";\n\tint len;\n\tchar buf[64];\n\n\tlen = strlen(test_str_first);\n\tEXPECT_EQ(send(self->fd, test_str_first, len, 0), len);\n\n\tlen = strlen(test_str_second) + 1;\n\tEXPECT_EQ(send(self->fd, test_str_second, len, 0), len);\n\n\tlen = strlen(test_str) + 1;\n\tmemset(buf, 0, len);\n\tEXPECT_NE((len = recv(self->cfd, buf, len,\n\t\t\t      MSG_PEEK | MSG_WAITALL)), -1);\n\tlen = strlen(test_str) + 1;\n\tEXPECT_EQ(memcmp(test_str, buf, len), 0);\n}\n\nTEST_F(tls, recv_lowat)\n{\n\tchar send_mem[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\tchar recv_mem[20];\n\tint lowat = 8;\n\n\tEXPECT_EQ(send(self->fd, send_mem, 10, 0), 10);\n\tEXPECT_EQ(send(self->fd, send_mem, 5, 0), 5);\n\n\tmemset(recv_mem, 0, 20);\n\tEXPECT_EQ(setsockopt(self->cfd, SOL_SOCKET, SO_RCVLOWAT,\n\t\t\t     &lowat, sizeof(lowat)), 0);\n\tEXPECT_EQ(recv(self->cfd, recv_mem, 1, MSG_WAITALL), 1);\n\tEXPECT_EQ(recv(self->cfd, recv_mem + 1, 6, MSG_WAITALL), 6);\n\tEXPECT_EQ(recv(self->cfd, recv_mem + 7, 10, 0), 8);\n\n\tEXPECT_EQ(memcmp(send_mem, recv_mem, 10), 0);\n\tEXPECT_EQ(memcmp(send_mem, recv_mem + 10, 5), 0);\n}\n\nTEST_F(tls, bidir)\n{\n\tchar const *test_str = \"test_read\";\n\tint send_len = 10;\n\tchar buf[10];\n\tint ret;\n\n\tif (!self->notls) {\n\t\tstruct tls_crypto_info_keys tls12;\n\n\t\ttls_crypto_info_init(variant->tls_version, variant->cipher_type,\n\t\t\t\t     &tls12);\n\n\t\tret = setsockopt(self->fd, SOL_TLS, TLS_RX, &tls12,\n\t\t\t\t tls12.len);\n\t\tASSERT_EQ(ret, 0);\n\n\t\tret = setsockopt(self->cfd, SOL_TLS, TLS_TX, &tls12,\n\t\t\t\t tls12.len);\n\t\tASSERT_EQ(ret, 0);\n\t}\n\n\tASSERT_EQ(strlen(test_str) + 1, send_len);\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tEXPECT_NE(recv(self->cfd, buf, send_len, 0), -1);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tEXPECT_EQ(send(self->cfd, test_str, send_len, 0), send_len);\n\tEXPECT_NE(recv(self->fd, buf, send_len, 0), -1);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n};\n\nTEST_F(tls, pollin)\n{\n\tchar const *test_str = \"test_poll\";\n\tstruct pollfd fd = { 0, 0, 0 };\n\tchar buf[10];\n\tint send_len = 10;\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tfd.fd = self->cfd;\n\tfd.events = POLLIN;\n\n\tEXPECT_EQ(poll(&fd, 1, 20), 1);\n\tEXPECT_EQ(fd.revents & POLLIN, 1);\n\tEXPECT_EQ(recv(self->cfd, buf, send_len, MSG_WAITALL), send_len);\n\t \n\tEXPECT_EQ(poll(&fd, 1, 20), 0);\n}\n\nTEST_F(tls, poll_wait)\n{\n\tchar const *test_str = \"test_poll_wait\";\n\tint send_len = strlen(test_str) + 1;\n\tstruct pollfd fd = { 0, 0, 0 };\n\tchar recv_mem[15];\n\n\tfd.fd = self->cfd;\n\tfd.events = POLLIN;\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\t \n\tEXPECT_EQ(poll(&fd, 1, -1), 1);\n\tEXPECT_EQ(fd.revents & POLLIN, 1);\n\tEXPECT_EQ(recv(self->cfd, recv_mem, send_len, MSG_WAITALL), send_len);\n}\n\nTEST_F(tls, poll_wait_split)\n{\n\tstruct pollfd fd = { 0, 0, 0 };\n\tchar send_mem[20] = {};\n\tchar recv_mem[15];\n\n\tfd.fd = self->cfd;\n\tfd.events = POLLIN;\n\t \n\tEXPECT_EQ(send(self->fd, send_mem, sizeof(send_mem), 0),\n\t\t  sizeof(send_mem));\n\t \n\tEXPECT_EQ(poll(&fd, 1, -1), 1);\n\tEXPECT_EQ(fd.revents & POLLIN, 1);\n\tEXPECT_EQ(recv(self->cfd, recv_mem, sizeof(recv_mem), MSG_WAITALL),\n\t\t  sizeof(recv_mem));\n\n\t \n\tfd.fd = self->cfd;\n\tfd.events = POLLIN;\n\tEXPECT_EQ(poll(&fd, 1, -1), 1);\n\tEXPECT_EQ(fd.revents & POLLIN, 1);\n\tEXPECT_EQ(recv(self->cfd, recv_mem, sizeof(recv_mem), 0),\n\t\t  sizeof(send_mem) - sizeof(recv_mem));\n}\n\nTEST_F(tls, blocking)\n{\n\tsize_t data = 100000;\n\tint res = fork();\n\n\tEXPECT_NE(res, -1);\n\n\tif (res) {\n\t\t \n\t\tsize_t left = data;\n\t\tchar buf[16384];\n\t\tint status;\n\t\tint pid2;\n\n\t\twhile (left) {\n\t\t\tint res = send(self->fd, buf,\n\t\t\t\t       left > 16384 ? 16384 : left, 0);\n\n\t\t\tEXPECT_GE(res, 0);\n\t\t\tleft -= res;\n\t\t}\n\n\t\tpid2 = wait(&status);\n\t\tEXPECT_EQ(status, 0);\n\t\tEXPECT_EQ(res, pid2);\n\t} else {\n\t\t \n\t\tsize_t left = data;\n\t\tchar buf[16384];\n\n\t\twhile (left) {\n\t\t\tint res = recv(self->cfd, buf,\n\t\t\t\t       left > 16384 ? 16384 : left, 0);\n\n\t\t\tEXPECT_GE(res, 0);\n\t\t\tleft -= res;\n\t\t}\n\t}\n}\n\nTEST_F(tls, nonblocking)\n{\n\tsize_t data = 100000;\n\tint sendbuf = 100;\n\tint flags;\n\tint res;\n\n\tflags = fcntl(self->fd, F_GETFL, 0);\n\tfcntl(self->fd, F_SETFL, flags | O_NONBLOCK);\n\tfcntl(self->cfd, F_SETFL, flags | O_NONBLOCK);\n\n\t \n\tEXPECT_EQ(setsockopt(self->fd, SOL_SOCKET, SO_SNDBUF,\n\t\t\t     &sendbuf, sizeof(sendbuf)), 0);\n\n\tres = fork();\n\tEXPECT_NE(res, -1);\n\n\tif (res) {\n\t\t \n\t\tbool eagain = false;\n\t\tsize_t left = data;\n\t\tchar buf[16384];\n\t\tint status;\n\t\tint pid2;\n\n\t\twhile (left) {\n\t\t\tint res = send(self->fd, buf,\n\t\t\t\t       left > 16384 ? 16384 : left, 0);\n\n\t\t\tif (res == -1 && errno == EAGAIN) {\n\t\t\t\teagain = true;\n\t\t\t\tusleep(10000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tEXPECT_GE(res, 0);\n\t\t\tleft -= res;\n\t\t}\n\n\t\tEXPECT_TRUE(eagain);\n\t\tpid2 = wait(&status);\n\n\t\tEXPECT_EQ(status, 0);\n\t\tEXPECT_EQ(res, pid2);\n\t} else {\n\t\t \n\t\tbool eagain = false;\n\t\tsize_t left = data;\n\t\tchar buf[16384];\n\n\t\twhile (left) {\n\t\t\tint res = recv(self->cfd, buf,\n\t\t\t\t       left > 16384 ? 16384 : left, 0);\n\n\t\t\tif (res == -1 && errno == EAGAIN) {\n\t\t\t\teagain = true;\n\t\t\t\tusleep(10000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tEXPECT_GE(res, 0);\n\t\t\tleft -= res;\n\t\t}\n\t\tEXPECT_TRUE(eagain);\n\t}\n}\n\nstatic void\ntest_mutliproc(struct __test_metadata *_metadata, struct _test_data_tls *self,\n\t       bool sendpg, unsigned int n_readers, unsigned int n_writers)\n{\n\tconst unsigned int n_children = n_readers + n_writers;\n\tconst size_t data = 6 * 1000 * 1000;\n\tconst size_t file_sz = data / 100;\n\tsize_t read_bias, write_bias;\n\tint i, fd, child_id;\n\tchar buf[file_sz];\n\tpid_t pid;\n\n\t \n\tASSERT_EQ(!(n_readers % n_writers) || !(n_writers % n_readers), true);\n\tread_bias = n_writers / n_readers ?: 1;\n\twrite_bias = n_readers / n_writers ?: 1;\n\n\t \n\tfd = open(\"/tmp/\", O_TMPFILE | O_RDWR, 0600);\n\tASSERT_GE(fd, 0);\n\n\tmemset(buf, 0xac, file_sz);\n\tASSERT_EQ(write(fd, buf, file_sz), file_sz);\n\n\t \n\tfor (child_id = 0; child_id < n_children; child_id++) {\n\t\tpid = fork();\n\t\tASSERT_NE(pid, -1);\n\t\tif (!pid)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (pid) {\n\t\tfor (i = 0; i < n_children; i++) {\n\t\t\tint status;\n\n\t\t\twait(&status);\n\t\t\tEXPECT_EQ(status, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\tif (child_id < n_readers) {\n\t\tsize_t left = data * read_bias;\n\t\tchar rb[8001];\n\n\t\twhile (left) {\n\t\t\tint res;\n\n\t\t\tres = recv(self->cfd, rb,\n\t\t\t\t   left > sizeof(rb) ? sizeof(rb) : left, 0);\n\n\t\t\tEXPECT_GE(res, 0);\n\t\t\tleft -= res;\n\t\t}\n\t} else {\n\t\tsize_t left = data * write_bias;\n\n\t\twhile (left) {\n\t\t\tint res;\n\n\t\t\tASSERT_EQ(lseek(fd, 0, SEEK_SET), 0);\n\t\t\tif (sendpg)\n\t\t\t\tres = sendfile(self->fd, fd, NULL,\n\t\t\t\t\t       left > file_sz ? file_sz : left);\n\t\t\telse\n\t\t\t\tres = send(self->fd, buf,\n\t\t\t\t\t   left > file_sz ? file_sz : left, 0);\n\n\t\t\tEXPECT_GE(res, 0);\n\t\t\tleft -= res;\n\t\t}\n\t}\n}\n\nTEST_F(tls, mutliproc_even)\n{\n\ttest_mutliproc(_metadata, self, false, 6, 6);\n}\n\nTEST_F(tls, mutliproc_readers)\n{\n\ttest_mutliproc(_metadata, self, false, 4, 12);\n}\n\nTEST_F(tls, mutliproc_writers)\n{\n\ttest_mutliproc(_metadata, self, false, 10, 2);\n}\n\nTEST_F(tls, mutliproc_sendpage_even)\n{\n\ttest_mutliproc(_metadata, self, true, 6, 6);\n}\n\nTEST_F(tls, mutliproc_sendpage_readers)\n{\n\ttest_mutliproc(_metadata, self, true, 4, 12);\n}\n\nTEST_F(tls, mutliproc_sendpage_writers)\n{\n\ttest_mutliproc(_metadata, self, true, 10, 2);\n}\n\nTEST_F(tls, control_msg)\n{\n\tchar *test_str = \"test_read\";\n\tchar record_type = 100;\n\tint send_len = 10;\n\tchar buf[10];\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\tEXPECT_EQ(tls_send_cmsg(self->fd, record_type, test_str, send_len, 0),\n\t\t  send_len);\n\t \n\tEXPECT_EQ(recv(self->cfd, buf, send_len, 0), -1);\n\n\tEXPECT_EQ(tls_recv_cmsg(_metadata, self->cfd, record_type,\n\t\t\t\tbuf, sizeof(buf), MSG_WAITALL | MSG_PEEK),\n\t\t  send_len);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\n\tEXPECT_EQ(tls_recv_cmsg(_metadata, self->cfd, record_type,\n\t\t\t\tbuf, sizeof(buf), MSG_WAITALL),\n\t\t  send_len);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n}\n\nTEST_F(tls, shutdown)\n{\n\tchar const *test_str = \"test_read\";\n\tint send_len = 10;\n\tchar buf[10];\n\n\tASSERT_EQ(strlen(test_str) + 1, send_len);\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, 0), send_len);\n\tEXPECT_NE(recv(self->cfd, buf, send_len, 0), -1);\n\tEXPECT_EQ(memcmp(buf, test_str, send_len), 0);\n\n\tshutdown(self->fd, SHUT_RDWR);\n\tshutdown(self->cfd, SHUT_RDWR);\n}\n\nTEST_F(tls, shutdown_unsent)\n{\n\tchar const *test_str = \"test_read\";\n\tint send_len = 10;\n\n\tEXPECT_EQ(send(self->fd, test_str, send_len, MSG_MORE), send_len);\n\n\tshutdown(self->fd, SHUT_RDWR);\n\tshutdown(self->cfd, SHUT_RDWR);\n}\n\nTEST_F(tls, shutdown_reuse)\n{\n\tstruct sockaddr_in addr;\n\tint ret;\n\n\tshutdown(self->fd, SHUT_RDWR);\n\tshutdown(self->cfd, SHUT_RDWR);\n\tclose(self->cfd);\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = 0;\n\n\tret = bind(self->fd, &addr, sizeof(addr));\n\tEXPECT_EQ(ret, 0);\n\tret = listen(self->fd, 10);\n\tEXPECT_EQ(ret, -1);\n\tEXPECT_EQ(errno, EINVAL);\n\n\tret = connect(self->fd, &addr, sizeof(addr));\n\tEXPECT_EQ(ret, -1);\n\tEXPECT_EQ(errno, EISCONN);\n}\n\nTEST_F(tls, getsockopt)\n{\n\tstruct tls_crypto_info_keys expect, get;\n\tsocklen_t len;\n\n\t \n\tlen = sizeof(struct tls_crypto_info);\n\tmemrnd(&get, sizeof(get));\n\tEXPECT_EQ(getsockopt(self->fd, SOL_TLS, TLS_TX, &get, &len), 0);\n\tEXPECT_EQ(len, sizeof(struct tls_crypto_info));\n\tEXPECT_EQ(get.crypto_info.version, variant->tls_version);\n\tEXPECT_EQ(get.crypto_info.cipher_type, variant->cipher_type);\n\n\t \n\ttls_crypto_info_init(variant->tls_version, variant->cipher_type, &expect);\n\tlen = expect.len;\n\tmemrnd(&get, sizeof(get));\n\tEXPECT_EQ(getsockopt(self->fd, SOL_TLS, TLS_TX, &get, &len), 0);\n\tEXPECT_EQ(len, expect.len);\n\tEXPECT_EQ(get.crypto_info.version, variant->tls_version);\n\tEXPECT_EQ(get.crypto_info.cipher_type, variant->cipher_type);\n\tEXPECT_EQ(memcmp(&get, &expect, expect.len), 0);\n\n\t \n\tlen = sizeof(struct tls_crypto_info) - 1;\n\tEXPECT_EQ(getsockopt(self->fd, SOL_TLS, TLS_TX, &get, &len), -1);\n\tEXPECT_EQ(errno, EINVAL);\n\n\t \n\tlen = expect.len - 1;\n\tEXPECT_EQ(getsockopt(self->fd, SOL_TLS, TLS_TX, &get, &len), -1);\n\tEXPECT_EQ(errno, EINVAL);\n}\n\nFIXTURE(tls_err)\n{\n\tint fd, cfd;\n\tint fd2, cfd2;\n\tbool notls;\n};\n\nFIXTURE_VARIANT(tls_err)\n{\n\tuint16_t tls_version;\n};\n\nFIXTURE_VARIANT_ADD(tls_err, 12_aes_gcm)\n{\n\t.tls_version = TLS_1_2_VERSION,\n};\n\nFIXTURE_VARIANT_ADD(tls_err, 13_aes_gcm)\n{\n\t.tls_version = TLS_1_3_VERSION,\n};\n\nFIXTURE_SETUP(tls_err)\n{\n\tstruct tls_crypto_info_keys tls12;\n\tint ret;\n\n\ttls_crypto_info_init(variant->tls_version, TLS_CIPHER_AES_GCM_128,\n\t\t\t     &tls12);\n\n\tulp_sock_pair(_metadata, &self->fd, &self->cfd, &self->notls);\n\tulp_sock_pair(_metadata, &self->fd2, &self->cfd2, &self->notls);\n\tif (self->notls)\n\t\treturn;\n\n\tret = setsockopt(self->fd, SOL_TLS, TLS_TX, &tls12, tls12.len);\n\tASSERT_EQ(ret, 0);\n\n\tret = setsockopt(self->cfd2, SOL_TLS, TLS_RX, &tls12, tls12.len);\n\tASSERT_EQ(ret, 0);\n}\n\nFIXTURE_TEARDOWN(tls_err)\n{\n\tclose(self->fd);\n\tclose(self->cfd);\n\tclose(self->fd2);\n\tclose(self->cfd2);\n}\n\nTEST_F(tls_err, bad_rec)\n{\n\tchar buf[64];\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\tmemset(buf, 0x55, sizeof(buf));\n\tEXPECT_EQ(send(self->fd2, buf, sizeof(buf), 0), sizeof(buf));\n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\tEXPECT_EQ(errno, EMSGSIZE);\n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), MSG_DONTWAIT), -1);\n\tEXPECT_EQ(errno, EAGAIN);\n}\n\nTEST_F(tls_err, bad_auth)\n{\n\tchar buf[128];\n\tint n;\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\tmemrnd(buf, sizeof(buf) / 2);\n\tEXPECT_EQ(send(self->fd, buf, sizeof(buf) / 2, 0), sizeof(buf) / 2);\n\tn = recv(self->cfd, buf, sizeof(buf), 0);\n\tEXPECT_GT(n, sizeof(buf) / 2);\n\n\tbuf[n - 1]++;\n\n\tEXPECT_EQ(send(self->fd2, buf, n, 0), n);\n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\tEXPECT_EQ(errno, EBADMSG);\n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\tEXPECT_EQ(errno, EBADMSG);\n}\n\nTEST_F(tls_err, bad_in_large_read)\n{\n\tchar txt[3][64];\n\tchar cip[3][128];\n\tchar buf[3 * 128];\n\tint i, n;\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tmemrnd(txt[i], sizeof(txt[i]));\n\t\tEXPECT_EQ(send(self->fd, txt[i], sizeof(txt[i]), 0),\n\t\t\t  sizeof(txt[i]));\n\t\tn = recv(self->cfd, cip[i], sizeof(cip[i]), 0);\n\t\tEXPECT_GT(n, sizeof(txt[i]));\n\t\t \n\t\tif (i == 2)\n\t\t\tcip[2][n - 1]++;\n\t\tEXPECT_EQ(send(self->fd2, cip[i], n, 0), n);\n\t}\n\n\t \n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), sizeof(txt[0]) * 2);\n\tEXPECT_EQ(memcmp(buf, txt[0], sizeof(txt[0])), 0);\n\tEXPECT_EQ(memcmp(buf + sizeof(txt[0]), txt[1], sizeof(txt[1])), 0);\n\t \n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\tEXPECT_EQ(errno, EBADMSG);\n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\tEXPECT_EQ(errno, EBADMSG);\n}\n\nTEST_F(tls_err, bad_cmsg)\n{\n\tchar *test_str = \"test_read\";\n\tint send_len = 10;\n\tchar cip[128];\n\tchar buf[128];\n\tchar txt[64];\n\tint n;\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\t \n\tmemrnd(txt, sizeof(txt));\n\tEXPECT_EQ(send(self->fd, txt, sizeof(txt), 0), sizeof(txt));\n\tn = recv(self->cfd, cip, sizeof(cip), 0);\n\tEXPECT_GT(n, sizeof(txt));\n\tEXPECT_EQ(send(self->fd2, cip, n, 0), n);\n\n\tEXPECT_EQ(tls_send_cmsg(self->fd, 100, test_str, send_len, 0), 10);\n\tn = recv(self->cfd, cip, sizeof(cip), 0);\n\tcip[n - 1]++;  \n\tEXPECT_GT(n, send_len);\n\tEXPECT_EQ(send(self->fd2, cip, n, 0), n);\n\n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), sizeof(txt));\n\tEXPECT_EQ(memcmp(buf, txt, sizeof(txt)), 0);\n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\tEXPECT_EQ(errno, EBADMSG);\n\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\tEXPECT_EQ(errno, EBADMSG);\n}\n\nTEST_F(tls_err, timeo)\n{\n\tstruct timeval tv = { .tv_usec = 10000, };\n\tchar buf[128];\n\tint ret;\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\tret = setsockopt(self->cfd2, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));\n\tASSERT_EQ(ret, 0);\n\n\tret = fork();\n\tASSERT_GE(ret, 0);\n\n\tif (ret) {\n\t\tusleep(1000);  \n\n\t\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\t\tEXPECT_EQ(errno, EAGAIN);\n\n\t\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\t\tEXPECT_EQ(errno, EAGAIN);\n\n\t\twait(&ret);\n\t} else {\n\t\tEXPECT_EQ(recv(self->cfd2, buf, sizeof(buf), 0), -1);\n\t\tEXPECT_EQ(errno, EAGAIN);\n\t\texit(0);\n\t}\n}\n\nTEST_F(tls_err, poll_partial_rec)\n{\n\tstruct pollfd pfd = { };\n\tssize_t rec_len;\n\tchar rec[256];\n\tchar buf[128];\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\tpfd.fd = self->cfd2;\n\tpfd.events = POLLIN;\n\tEXPECT_EQ(poll(&pfd, 1, 1), 0);\n\n\tmemrnd(buf, sizeof(buf));\n\tEXPECT_EQ(send(self->fd, buf, sizeof(buf), 0), sizeof(buf));\n\trec_len = recv(self->cfd, rec, sizeof(rec), 0);\n\tEXPECT_GT(rec_len, sizeof(buf));\n\n\t \n\tEXPECT_EQ(send(self->fd2, rec, 100, 0), 100);\n\t \n\tpfd.fd = self->cfd2;\n\tpfd.events = POLLIN;\n\tEXPECT_EQ(poll(&pfd, 1, 1), 0);\n\t \n\tEXPECT_EQ(send(self->fd2, rec + 100, rec_len - 100, 0), rec_len - 100);\n\tpfd.fd = self->cfd2;\n\tpfd.events = POLLIN;\n\tEXPECT_EQ(poll(&pfd, 1, 1), 1);\n\tEXPECT_EQ(recv(self->cfd2, rec, sizeof(rec), 0), sizeof(buf));\n\tEXPECT_EQ(memcmp(buf, rec, sizeof(buf)), 0);\n}\n\nTEST_F(tls_err, epoll_partial_rec)\n{\n\tstruct epoll_event ev, events[10];\n\tssize_t rec_len;\n\tchar rec[256];\n\tchar buf[128];\n\tint epollfd;\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\tepollfd = epoll_create1(0);\n\tASSERT_GE(epollfd, 0);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.events = EPOLLIN;\n\tev.data.fd = self->cfd2;\n\tASSERT_GE(epoll_ctl(epollfd, EPOLL_CTL_ADD, self->cfd2, &ev), 0);\n\n\tEXPECT_EQ(epoll_wait(epollfd, events, 10, 0), 0);\n\n\tmemrnd(buf, sizeof(buf));\n\tEXPECT_EQ(send(self->fd, buf, sizeof(buf), 0), sizeof(buf));\n\trec_len = recv(self->cfd, rec, sizeof(rec), 0);\n\tEXPECT_GT(rec_len, sizeof(buf));\n\n\t \n\tEXPECT_EQ(send(self->fd2, rec, 100, 0), 100);\n\t \n\tEXPECT_EQ(epoll_wait(epollfd, events, 10, 0), 0);\n\t \n\tEXPECT_EQ(send(self->fd2, rec + 100, rec_len - 100, 0), rec_len - 100);\n\tEXPECT_EQ(epoll_wait(epollfd, events, 10, 0), 1);\n\tEXPECT_EQ(recv(self->cfd2, rec, sizeof(rec), 0), sizeof(buf));\n\tEXPECT_EQ(memcmp(buf, rec, sizeof(buf)), 0);\n\n\tclose(epollfd);\n}\n\nTEST_F(tls_err, poll_partial_rec_async)\n{\n\tstruct pollfd pfd = { };\n\tssize_t rec_len;\n\tchar rec[256];\n\tchar buf[128];\n\tchar token;\n\tint p[2];\n\tint ret;\n\n\tif (self->notls)\n\t\tSKIP(return, \"no TLS support\");\n\n\tASSERT_GE(pipe(p), 0);\n\n\tmemrnd(buf, sizeof(buf));\n\tEXPECT_EQ(send(self->fd, buf, sizeof(buf), 0), sizeof(buf));\n\trec_len = recv(self->cfd, rec, sizeof(rec), 0);\n\tEXPECT_GT(rec_len, sizeof(buf));\n\n\tret = fork();\n\tASSERT_GE(ret, 0);\n\n\tif (ret) {\n\t\tint status, pid2;\n\n\t\tclose(p[1]);\n\t\tusleep(1000);  \n\n\t\tEXPECT_EQ(send(self->fd2, rec, 100, 0), 100);\n\n\t\tEXPECT_EQ(read(p[0], &token, 1), 1);  \n\n\t\tEXPECT_EQ(send(self->fd2, rec + 100, rec_len - 100, 0),\n\t\t\t  rec_len - 100);\n\n\t\tpid2 = wait(&status);\n\t\tEXPECT_EQ(pid2, ret);\n\t\tEXPECT_EQ(status, 0);\n\t} else {\n\t\tclose(p[0]);\n\n\t\t \n\t\tpfd.fd = self->cfd2;\n\t\tpfd.events = POLLIN;\n\t\tEXPECT_EQ(poll(&pfd, 1, 5), 0);\n\n\t\tEXPECT_EQ(write(p[1], &token, 1), 1);  \n\n\t\tpfd.fd = self->cfd2;\n\t\tpfd.events = POLLIN;\n\t\tEXPECT_EQ(poll(&pfd, 1, 5), 1);\n\n\t\texit(!_metadata->passed);\n\t}\n}\n\nTEST(non_established) {\n\tstruct tls12_crypto_info_aes_gcm_256 tls12;\n\tstruct sockaddr_in addr;\n\tint sfd, ret, fd;\n\tsocklen_t len;\n\n\tlen = sizeof(addr);\n\n\tmemset(&tls12, 0, sizeof(tls12));\n\ttls12.info.version = TLS_1_2_VERSION;\n\ttls12.info.cipher_type = TLS_CIPHER_AES_GCM_256;\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = 0;\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tsfd = socket(AF_INET, SOCK_STREAM, 0);\n\n\tret = bind(sfd, &addr, sizeof(addr));\n\tASSERT_EQ(ret, 0);\n\tret = listen(sfd, 10);\n\tASSERT_EQ(ret, 0);\n\n\tret = setsockopt(fd, IPPROTO_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"));\n\tEXPECT_EQ(ret, -1);\n\t \n\tif (errno == ENOENT)\n\t\treturn;\n\tEXPECT_EQ(errno, ENOTCONN);\n\n\tret = setsockopt(sfd, IPPROTO_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"));\n\tEXPECT_EQ(ret, -1);\n\tEXPECT_EQ(errno, ENOTCONN);\n\n\tret = getsockname(sfd, &addr, &len);\n\tASSERT_EQ(ret, 0);\n\n\tret = connect(fd, &addr, sizeof(addr));\n\tASSERT_EQ(ret, 0);\n\n\tret = setsockopt(fd, IPPROTO_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"));\n\tASSERT_EQ(ret, 0);\n\n\tret = setsockopt(fd, IPPROTO_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"));\n\tEXPECT_EQ(ret, -1);\n\tEXPECT_EQ(errno, EEXIST);\n\n\tclose(fd);\n\tclose(sfd);\n}\n\nTEST(keysizes) {\n\tstruct tls12_crypto_info_aes_gcm_256 tls12;\n\tint ret, fd, cfd;\n\tbool notls;\n\n\tmemset(&tls12, 0, sizeof(tls12));\n\ttls12.info.version = TLS_1_2_VERSION;\n\ttls12.info.cipher_type = TLS_CIPHER_AES_GCM_256;\n\n\tulp_sock_pair(_metadata, &fd, &cfd, &notls);\n\n\tif (!notls) {\n\t\tret = setsockopt(fd, SOL_TLS, TLS_TX, &tls12,\n\t\t\t\t sizeof(tls12));\n\t\tEXPECT_EQ(ret, 0);\n\n\t\tret = setsockopt(cfd, SOL_TLS, TLS_RX, &tls12,\n\t\t\t\t sizeof(tls12));\n\t\tEXPECT_EQ(ret, 0);\n\t}\n\n\tclose(fd);\n\tclose(cfd);\n}\n\nTEST(no_pad) {\n\tstruct tls12_crypto_info_aes_gcm_256 tls12;\n\tint ret, fd, cfd, val;\n\tsocklen_t len;\n\tbool notls;\n\n\tmemset(&tls12, 0, sizeof(tls12));\n\ttls12.info.version = TLS_1_3_VERSION;\n\ttls12.info.cipher_type = TLS_CIPHER_AES_GCM_256;\n\n\tulp_sock_pair(_metadata, &fd, &cfd, &notls);\n\n\tif (notls)\n\t\texit(KSFT_SKIP);\n\n\tret = setsockopt(fd, SOL_TLS, TLS_TX, &tls12, sizeof(tls12));\n\tEXPECT_EQ(ret, 0);\n\n\tret = setsockopt(cfd, SOL_TLS, TLS_RX, &tls12, sizeof(tls12));\n\tEXPECT_EQ(ret, 0);\n\n\tval = 1;\n\tret = setsockopt(cfd, SOL_TLS, TLS_RX_EXPECT_NO_PAD,\n\t\t\t (void *)&val, sizeof(val));\n\tEXPECT_EQ(ret, 0);\n\n\tlen = sizeof(val);\n\tval = 2;\n\tret = getsockopt(cfd, SOL_TLS, TLS_RX_EXPECT_NO_PAD,\n\t\t\t (void *)&val, &len);\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(val, 1);\n\tEXPECT_EQ(len, 4);\n\n\tval = 0;\n\tret = setsockopt(cfd, SOL_TLS, TLS_RX_EXPECT_NO_PAD,\n\t\t\t (void *)&val, sizeof(val));\n\tEXPECT_EQ(ret, 0);\n\n\tlen = sizeof(val);\n\tval = 2;\n\tret = getsockopt(cfd, SOL_TLS, TLS_RX_EXPECT_NO_PAD,\n\t\t\t (void *)&val, &len);\n\tEXPECT_EQ(ret, 0);\n\tEXPECT_EQ(val, 0);\n\tEXPECT_EQ(len, 4);\n\n\tclose(fd);\n\tclose(cfd);\n}\n\nTEST(tls_v6ops) {\n\tstruct tls_crypto_info_keys tls12;\n\tstruct sockaddr_in6 addr, addr2;\n\tint sfd, ret, fd;\n\tsocklen_t len, len2;\n\n\ttls_crypto_info_init(TLS_1_2_VERSION, TLS_CIPHER_AES_GCM_128, &tls12);\n\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_addr = in6addr_any;\n\taddr.sin6_port = 0;\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tsfd = socket(AF_INET6, SOCK_STREAM, 0);\n\n\tret = bind(sfd, &addr, sizeof(addr));\n\tASSERT_EQ(ret, 0);\n\tret = listen(sfd, 10);\n\tASSERT_EQ(ret, 0);\n\n\tlen = sizeof(addr);\n\tret = getsockname(sfd, &addr, &len);\n\tASSERT_EQ(ret, 0);\n\n\tret = connect(fd, &addr, sizeof(addr));\n\tASSERT_EQ(ret, 0);\n\n\tlen = sizeof(addr);\n\tret = getsockname(fd, &addr, &len);\n\tASSERT_EQ(ret, 0);\n\n\tret = setsockopt(fd, IPPROTO_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"));\n\tif (ret) {\n\t\tASSERT_EQ(errno, ENOENT);\n\t\tSKIP(return, \"no TLS support\");\n\t}\n\tASSERT_EQ(ret, 0);\n\n\tret = setsockopt(fd, SOL_TLS, TLS_TX, &tls12, tls12.len);\n\tASSERT_EQ(ret, 0);\n\n\tret = setsockopt(fd, SOL_TLS, TLS_RX, &tls12, tls12.len);\n\tASSERT_EQ(ret, 0);\n\n\tlen2 = sizeof(addr2);\n\tret = getsockname(fd, &addr2, &len2);\n\tASSERT_EQ(ret, 0);\n\n\tEXPECT_EQ(len2, len);\n\tEXPECT_EQ(memcmp(&addr, &addr2, len), 0);\n\n\tclose(fd);\n\tclose(sfd);\n}\n\nTEST(prequeue) {\n\tstruct tls_crypto_info_keys tls12;\n\tchar buf[20000], buf2[20000];\n\tstruct sockaddr_in addr;\n\tint sfd, cfd, ret, fd;\n\tsocklen_t len;\n\n\tlen = sizeof(addr);\n\tmemrnd(buf, sizeof(buf));\n\n\ttls_crypto_info_init(TLS_1_2_VERSION, TLS_CIPHER_AES_GCM_256, &tls12);\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = 0;\n\n\tfd = socket(AF_INET, SOCK_STREAM, 0);\n\tsfd = socket(AF_INET, SOCK_STREAM, 0);\n\n\tASSERT_EQ(bind(sfd, &addr, sizeof(addr)), 0);\n\tASSERT_EQ(listen(sfd, 10), 0);\n\tASSERT_EQ(getsockname(sfd, &addr, &len), 0);\n\tASSERT_EQ(connect(fd, &addr, sizeof(addr)), 0);\n\tASSERT_GE(cfd = accept(sfd, &addr, &len), 0);\n\tclose(sfd);\n\n\tret = setsockopt(fd, IPPROTO_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"));\n\tif (ret) {\n\t\tASSERT_EQ(errno, ENOENT);\n\t\tSKIP(return, \"no TLS support\");\n\t}\n\n\tASSERT_EQ(setsockopt(fd, SOL_TLS, TLS_TX, &tls12, tls12.len), 0);\n\tEXPECT_EQ(send(fd, buf, sizeof(buf), MSG_DONTWAIT), sizeof(buf));\n\n\tASSERT_EQ(setsockopt(cfd, IPPROTO_TCP, TCP_ULP, \"tls\", sizeof(\"tls\")), 0);\n\tASSERT_EQ(setsockopt(cfd, SOL_TLS, TLS_RX, &tls12, tls12.len), 0);\n\tEXPECT_EQ(recv(cfd, buf2, sizeof(buf2), MSG_WAITALL), sizeof(buf2));\n\n\tEXPECT_EQ(memcmp(buf, buf2, sizeof(buf)), 0);\n\n\tclose(fd);\n\tclose(cfd);\n}\n\nstatic void __attribute__((constructor)) fips_check(void) {\n\tint res;\n\tFILE *f;\n\n\tf = fopen(\"/proc/sys/crypto/fips_enabled\", \"r\");\n\tif (f) {\n\t\tres = fscanf(f, \"%d\", &fips_enabled);\n\t\tif (res != 1)\n\t\t\tksft_print_msg(\"ERROR: Couldn't read /proc/sys/crypto/fips_enabled\\n\");\n\t\tfclose(f);\n\t}\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}