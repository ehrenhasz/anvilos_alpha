{
  "module_name": "io_uring_zerocopy_tx.c",
  "hash_id": "3f1ab9997003294ba270a61c6804b9c037441d01529395d72d72f029b619eefe",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/io_uring_zerocopy_tx.c",
  "human_readable_source": " \n \n#include <assert.h>\n#include <errno.h>\n#include <error.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <arpa/inet.h>\n#include <linux/errqueue.h>\n#include <linux/if_packet.h>\n#include <linux/io_uring.h>\n#include <linux/ipv6.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netinet/ip6.h>\n#include <netinet/tcp.h>\n#include <netinet/udp.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n\n#define NOTIF_TAG 0xfffffffULL\n#define NONZC_TAG 0\n#define ZC_TAG 1\n\nenum {\n\tMODE_NONZC\t= 0,\n\tMODE_ZC\t\t= 1,\n\tMODE_ZC_FIXED\t= 2,\n\tMODE_MIXED\t= 3,\n};\n\nstatic bool cfg_cork\t\t= false;\nstatic int  cfg_mode\t\t= MODE_ZC_FIXED;\nstatic int  cfg_nr_reqs\t\t= 8;\nstatic int  cfg_family\t\t= PF_UNSPEC;\nstatic int  cfg_payload_len;\nstatic int  cfg_port\t\t= 8000;\nstatic int  cfg_runtime_ms\t= 4200;\n\nstatic socklen_t cfg_alen;\nstatic struct sockaddr_storage cfg_dst_addr;\n\nstatic char payload[IP_MAXPACKET] __attribute__((aligned(4096)));\n\nstruct io_sq_ring {\n\tunsigned *head;\n\tunsigned *tail;\n\tunsigned *ring_mask;\n\tunsigned *ring_entries;\n\tunsigned *flags;\n\tunsigned *array;\n};\n\nstruct io_cq_ring {\n\tunsigned *head;\n\tunsigned *tail;\n\tunsigned *ring_mask;\n\tunsigned *ring_entries;\n\tstruct io_uring_cqe *cqes;\n};\n\nstruct io_uring_sq {\n\tunsigned *khead;\n\tunsigned *ktail;\n\tunsigned *kring_mask;\n\tunsigned *kring_entries;\n\tunsigned *kflags;\n\tunsigned *kdropped;\n\tunsigned *array;\n\tstruct io_uring_sqe *sqes;\n\n\tunsigned sqe_head;\n\tunsigned sqe_tail;\n\n\tsize_t ring_sz;\n};\n\nstruct io_uring_cq {\n\tunsigned *khead;\n\tunsigned *ktail;\n\tunsigned *kring_mask;\n\tunsigned *kring_entries;\n\tunsigned *koverflow;\n\tstruct io_uring_cqe *cqes;\n\n\tsize_t ring_sz;\n};\n\nstruct io_uring {\n\tstruct io_uring_sq sq;\n\tstruct io_uring_cq cq;\n\tint ring_fd;\n};\n\n#ifdef __alpha__\n# ifndef __NR_io_uring_setup\n#  define __NR_io_uring_setup\t\t535\n# endif\n# ifndef __NR_io_uring_enter\n#  define __NR_io_uring_enter\t\t536\n# endif\n# ifndef __NR_io_uring_register\n#  define __NR_io_uring_register\t537\n# endif\n#else  \n# ifndef __NR_io_uring_setup\n#  define __NR_io_uring_setup\t\t425\n# endif\n# ifndef __NR_io_uring_enter\n#  define __NR_io_uring_enter\t\t426\n# endif\n# ifndef __NR_io_uring_register\n#  define __NR_io_uring_register\t427\n# endif\n#endif\n\n#if defined(__x86_64) || defined(__i386__)\n#define read_barrier()\t__asm__ __volatile__(\"\":::\"memory\")\n#define write_barrier()\t__asm__ __volatile__(\"\":::\"memory\")\n#else\n\n#define read_barrier()\t__sync_synchronize()\n#define write_barrier()\t__sync_synchronize()\n#endif\n\nstatic int io_uring_setup(unsigned int entries, struct io_uring_params *p)\n{\n\treturn syscall(__NR_io_uring_setup, entries, p);\n}\n\nstatic int io_uring_enter(int fd, unsigned int to_submit,\n\t\t\t  unsigned int min_complete,\n\t\t\t  unsigned int flags, sigset_t *sig)\n{\n\treturn syscall(__NR_io_uring_enter, fd, to_submit, min_complete,\n\t\t\tflags, sig, _NSIG / 8);\n}\n\nstatic int io_uring_register_buffers(struct io_uring *ring,\n\t\t\t\t     const struct iovec *iovecs,\n\t\t\t\t     unsigned nr_iovecs)\n{\n\tint ret;\n\n\tret = syscall(__NR_io_uring_register, ring->ring_fd,\n\t\t      IORING_REGISTER_BUFFERS, iovecs, nr_iovecs);\n\treturn (ret < 0) ? -errno : ret;\n}\n\nstatic int io_uring_mmap(int fd, struct io_uring_params *p,\n\t\t\t struct io_uring_sq *sq, struct io_uring_cq *cq)\n{\n\tsize_t size;\n\tvoid *ptr;\n\tint ret;\n\n\tsq->ring_sz = p->sq_off.array + p->sq_entries * sizeof(unsigned);\n\tptr = mmap(0, sq->ring_sz, PROT_READ | PROT_WRITE,\n\t\t   MAP_SHARED | MAP_POPULATE, fd, IORING_OFF_SQ_RING);\n\tif (ptr == MAP_FAILED)\n\t\treturn -errno;\n\tsq->khead = ptr + p->sq_off.head;\n\tsq->ktail = ptr + p->sq_off.tail;\n\tsq->kring_mask = ptr + p->sq_off.ring_mask;\n\tsq->kring_entries = ptr + p->sq_off.ring_entries;\n\tsq->kflags = ptr + p->sq_off.flags;\n\tsq->kdropped = ptr + p->sq_off.dropped;\n\tsq->array = ptr + p->sq_off.array;\n\n\tsize = p->sq_entries * sizeof(struct io_uring_sqe);\n\tsq->sqes = mmap(0, size, PROT_READ | PROT_WRITE,\n\t\t\tMAP_SHARED | MAP_POPULATE, fd, IORING_OFF_SQES);\n\tif (sq->sqes == MAP_FAILED) {\n\t\tret = -errno;\nerr:\n\t\tmunmap(sq->khead, sq->ring_sz);\n\t\treturn ret;\n\t}\n\n\tcq->ring_sz = p->cq_off.cqes + p->cq_entries * sizeof(struct io_uring_cqe);\n\tptr = mmap(0, cq->ring_sz, PROT_READ | PROT_WRITE,\n\t\t\tMAP_SHARED | MAP_POPULATE, fd, IORING_OFF_CQ_RING);\n\tif (ptr == MAP_FAILED) {\n\t\tret = -errno;\n\t\tmunmap(sq->sqes, p->sq_entries * sizeof(struct io_uring_sqe));\n\t\tgoto err;\n\t}\n\tcq->khead = ptr + p->cq_off.head;\n\tcq->ktail = ptr + p->cq_off.tail;\n\tcq->kring_mask = ptr + p->cq_off.ring_mask;\n\tcq->kring_entries = ptr + p->cq_off.ring_entries;\n\tcq->koverflow = ptr + p->cq_off.overflow;\n\tcq->cqes = ptr + p->cq_off.cqes;\n\treturn 0;\n}\n\nstatic int io_uring_queue_init(unsigned entries, struct io_uring *ring,\n\t\t\t       unsigned flags)\n{\n\tstruct io_uring_params p;\n\tint fd, ret;\n\n\tmemset(ring, 0, sizeof(*ring));\n\tmemset(&p, 0, sizeof(p));\n\tp.flags = flags;\n\n\tfd = io_uring_setup(entries, &p);\n\tif (fd < 0)\n\t\treturn fd;\n\tret = io_uring_mmap(fd, &p, &ring->sq, &ring->cq);\n\tif (!ret)\n\t\tring->ring_fd = fd;\n\telse\n\t\tclose(fd);\n\treturn ret;\n}\n\nstatic int io_uring_submit(struct io_uring *ring)\n{\n\tstruct io_uring_sq *sq = &ring->sq;\n\tconst unsigned mask = *sq->kring_mask;\n\tunsigned ktail, submitted, to_submit;\n\tint ret;\n\n\tread_barrier();\n\tif (*sq->khead != *sq->ktail) {\n\t\tsubmitted = *sq->kring_entries;\n\t\tgoto submit;\n\t}\n\tif (sq->sqe_head == sq->sqe_tail)\n\t\treturn 0;\n\n\tktail = *sq->ktail;\n\tto_submit = sq->sqe_tail - sq->sqe_head;\n\tfor (submitted = 0; submitted < to_submit; submitted++) {\n\t\tread_barrier();\n\t\tsq->array[ktail++ & mask] = sq->sqe_head++ & mask;\n\t}\n\tif (!submitted)\n\t\treturn 0;\n\n\tif (*sq->ktail != ktail) {\n\t\twrite_barrier();\n\t\t*sq->ktail = ktail;\n\t\twrite_barrier();\n\t}\nsubmit:\n\tret = io_uring_enter(ring->ring_fd, submitted, 0,\n\t\t\t\tIORING_ENTER_GETEVENTS, NULL);\n\treturn ret < 0 ? -errno : ret;\n}\n\nstatic inline void io_uring_prep_send(struct io_uring_sqe *sqe, int sockfd,\n\t\t\t\t      const void *buf, size_t len, int flags)\n{\n\tmemset(sqe, 0, sizeof(*sqe));\n\tsqe->opcode = (__u8) IORING_OP_SEND;\n\tsqe->fd = sockfd;\n\tsqe->addr = (unsigned long) buf;\n\tsqe->len = len;\n\tsqe->msg_flags = (__u32) flags;\n}\n\nstatic inline void io_uring_prep_sendzc(struct io_uring_sqe *sqe, int sockfd,\n\t\t\t\t        const void *buf, size_t len, int flags,\n\t\t\t\t        unsigned zc_flags)\n{\n\tio_uring_prep_send(sqe, sockfd, buf, len, flags);\n\tsqe->opcode = (__u8) IORING_OP_SEND_ZC;\n\tsqe->ioprio = zc_flags;\n}\n\nstatic struct io_uring_sqe *io_uring_get_sqe(struct io_uring *ring)\n{\n\tstruct io_uring_sq *sq = &ring->sq;\n\n\tif (sq->sqe_tail + 1 - sq->sqe_head > *sq->kring_entries)\n\t\treturn NULL;\n\treturn &sq->sqes[sq->sqe_tail++ & *sq->kring_mask];\n}\n\nstatic int io_uring_wait_cqe(struct io_uring *ring, struct io_uring_cqe **cqe_ptr)\n{\n\tstruct io_uring_cq *cq = &ring->cq;\n\tconst unsigned mask = *cq->kring_mask;\n\tunsigned head = *cq->khead;\n\tint ret;\n\n\t*cqe_ptr = NULL;\n\tdo {\n\t\tread_barrier();\n\t\tif (head != *cq->ktail) {\n\t\t\t*cqe_ptr = &cq->cqes[head & mask];\n\t\t\tbreak;\n\t\t}\n\t\tret = io_uring_enter(ring->ring_fd, 0, 1,\n\t\t\t\t\tIORING_ENTER_GETEVENTS, NULL);\n\t\tif (ret < 0)\n\t\t\treturn -errno;\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic inline void io_uring_cqe_seen(struct io_uring *ring)\n{\n\t*(&ring->cq)->khead += 1;\n\twrite_barrier();\n}\n\nstatic unsigned long gettimeofday_ms(void)\n{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\treturn (tv.tv_sec * 1000) + (tv.tv_usec / 1000);\n}\n\nstatic void do_setsockopt(int fd, int level, int optname, int val)\n{\n\tif (setsockopt(fd, level, optname, &val, sizeof(val)))\n\t\terror(1, errno, \"setsockopt %d.%d: %d\", level, optname, val);\n}\n\nstatic int do_setup_tx(int domain, int type, int protocol)\n{\n\tint fd;\n\n\tfd = socket(domain, type, protocol);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket t\");\n\n\tdo_setsockopt(fd, SOL_SOCKET, SO_SNDBUF, 1 << 21);\n\n\tif (connect(fd, (void *) &cfg_dst_addr, cfg_alen))\n\t\terror(1, errno, \"connect\");\n\treturn fd;\n}\n\nstatic void do_tx(int domain, int type, int protocol)\n{\n\tstruct io_uring_sqe *sqe;\n\tstruct io_uring_cqe *cqe;\n\tunsigned long packets = 0, bytes = 0;\n\tstruct io_uring ring;\n\tstruct iovec iov;\n\tuint64_t tstop;\n\tint i, fd, ret;\n\tint compl_cqes = 0;\n\n\tfd = do_setup_tx(domain, type, protocol);\n\n\tret = io_uring_queue_init(512, &ring, 0);\n\tif (ret)\n\t\terror(1, ret, \"io_uring: queue init\");\n\n\tiov.iov_base = payload;\n\tiov.iov_len = cfg_payload_len;\n\n\tret = io_uring_register_buffers(&ring, &iov, 1);\n\tif (ret)\n\t\terror(1, ret, \"io_uring: buffer registration\");\n\n\ttstop = gettimeofday_ms() + cfg_runtime_ms;\n\tdo {\n\t\tif (cfg_cork)\n\t\t\tdo_setsockopt(fd, IPPROTO_UDP, UDP_CORK, 1);\n\n\t\tfor (i = 0; i < cfg_nr_reqs; i++) {\n\t\t\tunsigned zc_flags = 0;\n\t\t\tunsigned buf_idx = 0;\n\t\t\tunsigned mode = cfg_mode;\n\t\t\tunsigned msg_flags = MSG_WAITALL;\n\n\t\t\tif (cfg_mode == MODE_MIXED)\n\t\t\t\tmode = rand() % 3;\n\n\t\t\tsqe = io_uring_get_sqe(&ring);\n\n\t\t\tif (mode == MODE_NONZC) {\n\t\t\t\tio_uring_prep_send(sqe, fd, payload,\n\t\t\t\t\t\t   cfg_payload_len, msg_flags);\n\t\t\t\tsqe->user_data = NONZC_TAG;\n\t\t\t} else {\n\t\t\t\tio_uring_prep_sendzc(sqe, fd, payload,\n\t\t\t\t\t\t     cfg_payload_len,\n\t\t\t\t\t\t     msg_flags, zc_flags);\n\t\t\t\tif (mode == MODE_ZC_FIXED) {\n\t\t\t\t\tsqe->ioprio |= IORING_RECVSEND_FIXED_BUF;\n\t\t\t\t\tsqe->buf_index = buf_idx;\n\t\t\t\t}\n\t\t\t\tsqe->user_data = ZC_TAG;\n\t\t\t}\n\t\t}\n\n\t\tret = io_uring_submit(&ring);\n\t\tif (ret != cfg_nr_reqs)\n\t\t\terror(1, ret, \"submit\");\n\n\t\tif (cfg_cork)\n\t\t\tdo_setsockopt(fd, IPPROTO_UDP, UDP_CORK, 0);\n\t\tfor (i = 0; i < cfg_nr_reqs; i++) {\n\t\t\tret = io_uring_wait_cqe(&ring, &cqe);\n\t\t\tif (ret)\n\t\t\t\terror(1, ret, \"wait cqe\");\n\n\t\t\tif (cqe->user_data != NONZC_TAG &&\n\t\t\t    cqe->user_data != ZC_TAG)\n\t\t\t\terror(1, -EINVAL, \"invalid cqe->user_data\");\n\n\t\t\tif (cqe->flags & IORING_CQE_F_NOTIF) {\n\t\t\t\tif (cqe->flags & IORING_CQE_F_MORE)\n\t\t\t\t\terror(1, -EINVAL, \"invalid notif flags\");\n\t\t\t\tif (compl_cqes <= 0)\n\t\t\t\t\terror(1, -EINVAL, \"notification mismatch\");\n\t\t\t\tcompl_cqes--;\n\t\t\t\ti--;\n\t\t\t\tio_uring_cqe_seen(&ring);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cqe->flags & IORING_CQE_F_MORE) {\n\t\t\t\tif (cqe->user_data != ZC_TAG)\n\t\t\t\t\terror(1, cqe->res, \"unexpected F_MORE\");\n\t\t\t\tcompl_cqes++;\n\t\t\t}\n\t\t\tif (cqe->res >= 0) {\n\t\t\t\tpackets++;\n\t\t\t\tbytes += cqe->res;\n\t\t\t} else if (cqe->res != -EAGAIN) {\n\t\t\t\terror(1, cqe->res, \"send failed\");\n\t\t\t}\n\t\t\tio_uring_cqe_seen(&ring);\n\t\t}\n\t} while (gettimeofday_ms() < tstop);\n\n\twhile (compl_cqes) {\n\t\tret = io_uring_wait_cqe(&ring, &cqe);\n\t\tif (ret)\n\t\t\terror(1, ret, \"wait cqe\");\n\t\tif (cqe->flags & IORING_CQE_F_MORE)\n\t\t\terror(1, -EINVAL, \"invalid notif flags\");\n\t\tif (!(cqe->flags & IORING_CQE_F_NOTIF))\n\t\t\terror(1, -EINVAL, \"missing notif flag\");\n\n\t\tio_uring_cqe_seen(&ring);\n\t\tcompl_cqes--;\n\t}\n\n\tfprintf(stderr, \"tx=%lu (MB=%lu), tx/s=%lu (MB/s=%lu)\\n\",\n\t\t\tpackets, bytes >> 20,\n\t\t\tpackets / (cfg_runtime_ms / 1000),\n\t\t\t(bytes >> 20) / (cfg_runtime_ms / 1000));\n\n\tif (close(fd))\n\t\terror(1, errno, \"close\");\n}\n\nstatic void do_test(int domain, int type, int protocol)\n{\n\tint i;\n\n\tfor (i = 0; i < IP_MAXPACKET; i++)\n\t\tpayload[i] = 'a' + (i % 26);\n\tdo_tx(domain, type, protocol);\n}\n\nstatic void usage(const char *filepath)\n{\n\terror(1, 0, \"Usage: %s (-4|-6) (udp|tcp) -D<dst_ip> [-s<payload size>] \"\n\t\t    \"[-t<time s>] [-n<batch>] [-p<port>] [-m<mode>]\", filepath);\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tconst int max_payload_len = sizeof(payload) -\n\t\t\t\t    sizeof(struct ipv6hdr) -\n\t\t\t\t    sizeof(struct tcphdr) -\n\t\t\t\t    40  ;\n\tstruct sockaddr_in6 *addr6 = (void *) &cfg_dst_addr;\n\tstruct sockaddr_in *addr4 = (void *) &cfg_dst_addr;\n\tchar *daddr = NULL;\n\tint c;\n\n\tif (argc <= 1)\n\t\tusage(argv[0]);\n\tcfg_payload_len = max_payload_len;\n\n\twhile ((c = getopt(argc, argv, \"46D:p:s:t:n:c:m:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tif (cfg_family != PF_UNSPEC)\n\t\t\t\terror(1, 0, \"Pass one of -4 or -6\");\n\t\t\tcfg_family = PF_INET;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tif (cfg_family != PF_UNSPEC)\n\t\t\t\terror(1, 0, \"Pass one of -4 or -6\");\n\t\t\tcfg_family = PF_INET6;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in6);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdaddr = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcfg_port = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcfg_payload_len = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_runtime_ms = 200 + strtoul(optarg, NULL, 10) * 1000;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcfg_nr_reqs = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcfg_cork = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcfg_mode = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (cfg_family) {\n\tcase PF_INET:\n\t\tmemset(addr4, 0, sizeof(*addr4));\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_port = htons(cfg_port);\n\t\tif (daddr &&\n\t\t    inet_pton(AF_INET, daddr, &(addr4->sin_addr)) != 1)\n\t\t\terror(1, 0, \"ipv4 parse error: %s\", daddr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tmemset(addr6, 0, sizeof(*addr6));\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_port = htons(cfg_port);\n\t\tif (daddr &&\n\t\t    inet_pton(AF_INET6, daddr, &(addr6->sin6_addr)) != 1)\n\t\t\terror(1, 0, \"ipv6 parse error: %s\", daddr);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"illegal domain\");\n\t}\n\n\tif (cfg_payload_len > max_payload_len)\n\t\terror(1, 0, \"-s: payload exceeds max (%d)\", max_payload_len);\n\tif (optind != argc - 1)\n\t\tusage(argv[0]);\n}\n\nint main(int argc, char **argv)\n{\n\tconst char *cfg_test = argv[argc - 1];\n\n\tparse_opts(argc, argv);\n\n\tif (!strcmp(cfg_test, \"tcp\"))\n\t\tdo_test(cfg_family, SOCK_STREAM, 0);\n\telse if (!strcmp(cfg_test, \"udp\"))\n\t\tdo_test(cfg_family, SOCK_DGRAM, 0);\n\telse\n\t\terror(1, 0, \"unknown cfg_test %s\", cfg_test);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}