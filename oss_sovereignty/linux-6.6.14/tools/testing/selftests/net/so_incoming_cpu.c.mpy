{
  "module_name": "so_incoming_cpu.c",
  "hash_id": "51a779d4a5063db576ce01c8f3c42c6f2c4ea6f2644552a56f5b33011b9c456d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/so_incoming_cpu.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <sched.h>\n\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/sysinfo.h>\n\n#include \"../kselftest_harness.h\"\n\n#define CLIENT_PER_SERVER\t32  \n#define NR_SERVER\t\tself->nproc\n#define NR_CLIENT\t\t(CLIENT_PER_SERVER * NR_SERVER)\n\nFIXTURE(so_incoming_cpu)\n{\n\tint nproc;\n\tint *servers;\n\tunion {\n\t\tstruct sockaddr addr;\n\t\tstruct sockaddr_in in_addr;\n\t};\n\tsocklen_t addrlen;\n};\n\nenum when_to_set {\n\tBEFORE_REUSEPORT,\n\tBEFORE_LISTEN,\n\tAFTER_LISTEN,\n\tAFTER_ALL_LISTEN,\n};\n\nFIXTURE_VARIANT(so_incoming_cpu)\n{\n\tint when_to_set;\n};\n\nFIXTURE_VARIANT_ADD(so_incoming_cpu, before_reuseport)\n{\n\t.when_to_set = BEFORE_REUSEPORT,\n};\n\nFIXTURE_VARIANT_ADD(so_incoming_cpu, before_listen)\n{\n\t.when_to_set = BEFORE_LISTEN,\n};\n\nFIXTURE_VARIANT_ADD(so_incoming_cpu, after_listen)\n{\n\t.when_to_set = AFTER_LISTEN,\n};\n\nFIXTURE_VARIANT_ADD(so_incoming_cpu, after_all_listen)\n{\n\t.when_to_set = AFTER_ALL_LISTEN,\n};\n\nFIXTURE_SETUP(so_incoming_cpu)\n{\n\tself->nproc = get_nprocs();\n\tASSERT_LE(2, self->nproc);\n\n\tself->servers = malloc(sizeof(int) * NR_SERVER);\n\tASSERT_NE(self->servers, NULL);\n\n\tself->in_addr.sin_family = AF_INET;\n\tself->in_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tself->in_addr.sin_port = htons(0);\n\tself->addrlen = sizeof(struct sockaddr_in);\n}\n\nFIXTURE_TEARDOWN(so_incoming_cpu)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_SERVER; i++)\n\t\tclose(self->servers[i]);\n\n\tfree(self->servers);\n}\n\nvoid set_so_incoming_cpu(struct __test_metadata *_metadata, int fd, int cpu)\n{\n\tint ret;\n\n\tret = setsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU, &cpu, sizeof(int));\n\tASSERT_EQ(ret, 0);\n}\n\nint create_server(struct __test_metadata *_metadata,\n\t\t  FIXTURE_DATA(so_incoming_cpu) *self,\n\t\t  const FIXTURE_VARIANT(so_incoming_cpu) *variant,\n\t\t  int cpu)\n{\n\tint fd, ret;\n\n\tfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n\tASSERT_NE(fd, -1);\n\n\tif (variant->when_to_set == BEFORE_REUSEPORT)\n\t\tset_so_incoming_cpu(_metadata, fd, cpu);\n\n\tret = setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &(int){1}, sizeof(int));\n\tASSERT_EQ(ret, 0);\n\n\tret = bind(fd, &self->addr, self->addrlen);\n\tASSERT_EQ(ret, 0);\n\n\tif (variant->when_to_set == BEFORE_LISTEN)\n\t\tset_so_incoming_cpu(_metadata, fd, cpu);\n\n\t \n\tret = listen(fd, NR_CLIENT);\n\tASSERT_EQ(ret, 0);\n\n\tif (variant->when_to_set == AFTER_LISTEN)\n\t\tset_so_incoming_cpu(_metadata, fd, cpu);\n\n\treturn fd;\n}\n\nvoid create_servers(struct __test_metadata *_metadata,\n\t\t    FIXTURE_DATA(so_incoming_cpu) *self,\n\t\t    const FIXTURE_VARIANT(so_incoming_cpu) *variant)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < NR_SERVER; i++) {\n\t\tself->servers[i] = create_server(_metadata, self, variant, i);\n\n\t\tif (i == 0) {\n\t\t\tret = getsockname(self->servers[i], &self->addr, &self->addrlen);\n\t\t\tASSERT_EQ(ret, 0);\n\t\t}\n\t}\n\n\tif (variant->when_to_set == AFTER_ALL_LISTEN) {\n\t\tfor (i = 0; i < NR_SERVER; i++)\n\t\t\tset_so_incoming_cpu(_metadata, self->servers[i], i);\n\t}\n}\n\nvoid create_clients(struct __test_metadata *_metadata,\n\t\t    FIXTURE_DATA(so_incoming_cpu) *self)\n{\n\tcpu_set_t cpu_set;\n\tint i, j, fd, ret;\n\n\tfor (i = 0; i < NR_SERVER; i++) {\n\t\tCPU_ZERO(&cpu_set);\n\n\t\tCPU_SET(i, &cpu_set);\n\t\tASSERT_EQ(CPU_COUNT(&cpu_set), 1);\n\t\tASSERT_NE(CPU_ISSET(i, &cpu_set), 0);\n\n\t\t \n\t\tret = sched_setaffinity(0, sizeof(cpu_set), &cpu_set);\n\t\tASSERT_EQ(ret, 0);\n\n\t\tfor (j = 0; j < CLIENT_PER_SERVER; j++) {\n\t\t\tfd  = socket(AF_INET, SOCK_STREAM, 0);\n\t\t\tASSERT_NE(fd, -1);\n\n\t\t\tret = connect(fd, &self->addr, self->addrlen);\n\t\t\tASSERT_EQ(ret, 0);\n\n\t\t\tclose(fd);\n\t\t}\n\t}\n}\n\nvoid verify_incoming_cpu(struct __test_metadata *_metadata,\n\t\t\t FIXTURE_DATA(so_incoming_cpu) *self)\n{\n\tint i, j, fd, cpu, ret, total = 0;\n\tsocklen_t len = sizeof(int);\n\n\tfor (i = 0; i < NR_SERVER; i++) {\n\t\tfor (j = 0; j < CLIENT_PER_SERVER; j++) {\n\t\t\t \n\t\t\tfd = accept(self->servers[i], &self->addr, &self->addrlen);\n\t\t\tASSERT_NE(fd, -1);\n\n\t\t\tret = getsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU, &cpu, &len);\n\t\t\tASSERT_EQ(ret, 0);\n\t\t\tASSERT_EQ(cpu, i);\n\n\t\t\tclose(fd);\n\t\t\ttotal++;\n\t\t}\n\t}\n\n\tASSERT_EQ(total, NR_CLIENT);\n\tTH_LOG(\"SO_INCOMING_CPU is very likely to be \"\n\t       \"working correctly with %d sockets.\", total);\n}\n\nTEST_F(so_incoming_cpu, test1)\n{\n\tcreate_servers(_metadata, self, variant);\n\tcreate_clients(_metadata, self);\n\tverify_incoming_cpu(_metadata, self);\n}\n\nTEST_F(so_incoming_cpu, test2)\n{\n\tint server;\n\n\tcreate_servers(_metadata, self, variant);\n\n\t \n\tserver = create_server(_metadata, self, variant, -1);\n\tclose(server);\n\n\tcreate_clients(_metadata, self);\n\tverify_incoming_cpu(_metadata, self);\n}\n\nTEST_F(so_incoming_cpu, test3)\n{\n\tint server, client;\n\n\tcreate_servers(_metadata, self, variant);\n\n\t \n\tserver = create_server(_metadata, self, variant, -1);\n\n\tcreate_clients(_metadata, self);\n\n\t \n\tclient = accept(server, &self->addr, &self->addrlen);\n\tASSERT_EQ(client, -1);\n\n\tverify_incoming_cpu(_metadata, self);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}