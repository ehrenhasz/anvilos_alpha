{
  "module_name": "so_txtime.c",
  "hash_id": "5534137a9a678c92d19482f972fff12d88cc4f4fd434bf4eb7bf96c45b453418",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/so_txtime.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <error.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <linux/net_tstamp.h>\n#include <linux/errqueue.h>\n#include <linux/if_ether.h>\n#include <linux/ipv6.h>\n#include <linux/udp.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n#include <poll.h>\n\nstatic int\tcfg_clockid\t= CLOCK_TAI;\nstatic uint16_t\tcfg_port\t= 8000;\nstatic int\tcfg_variance_us\t= 4000;\nstatic uint64_t\tcfg_start_time_ns;\nstatic int\tcfg_mark;\nstatic bool\tcfg_rx;\n\nstatic uint64_t glob_tstart;\nstatic uint64_t tdeliver_max;\n\n \nstruct timed_send {\n\tchar\tdata;\n\tint64_t\tdelay_us;\n};\n\n#define MAX_NUM_PKT\t8\nstatic struct timed_send cfg_buf[MAX_NUM_PKT];\nstatic int cfg_num_pkt;\n\nstatic int cfg_errq_level;\nstatic int cfg_errq_type;\n\nstatic struct sockaddr_storage cfg_dst_addr;\nstatic struct sockaddr_storage cfg_src_addr;\nstatic socklen_t cfg_alen;\n\nstatic uint64_t gettime_ns(clockid_t clock)\n{\n\tstruct timespec ts;\n\n\tif (clock_gettime(clock, &ts))\n\t\terror(1, errno, \"gettime\");\n\n\treturn ts.tv_sec * (1000ULL * 1000 * 1000) + ts.tv_nsec;\n}\n\nstatic void do_send_one(int fdt, struct timed_send *ts)\n{\n\tchar control[CMSG_SPACE(sizeof(uint64_t))];\n\tstruct msghdr msg = {0};\n\tstruct iovec iov = {0};\n\tstruct cmsghdr *cm;\n\tuint64_t tdeliver;\n\tint ret;\n\n\tiov.iov_base = &ts->data;\n\tiov.iov_len = 1;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_name = (struct sockaddr *)&cfg_dst_addr;\n\tmsg.msg_namelen = cfg_alen;\n\n\tif (ts->delay_us >= 0) {\n\t\tmemset(control, 0, sizeof(control));\n\t\tmsg.msg_control = &control;\n\t\tmsg.msg_controllen = sizeof(control);\n\n\t\ttdeliver = glob_tstart + ts->delay_us * 1000;\n\t\ttdeliver_max = tdeliver_max > tdeliver ?\n\t\t\t       tdeliver_max : tdeliver;\n\n\t\tcm = CMSG_FIRSTHDR(&msg);\n\t\tcm->cmsg_level = SOL_SOCKET;\n\t\tcm->cmsg_type = SCM_TXTIME;\n\t\tcm->cmsg_len = CMSG_LEN(sizeof(tdeliver));\n\t\tmemcpy(CMSG_DATA(cm), &tdeliver, sizeof(tdeliver));\n\t}\n\n\tret = sendmsg(fdt, &msg, 0);\n\tif (ret == -1)\n\t\terror(1, errno, \"write\");\n\tif (ret == 0)\n\t\terror(1, 0, \"write: 0B\");\n\n}\n\nstatic void do_recv_one(int fdr, struct timed_send *ts)\n{\n\tint64_t tstop, texpect;\n\tchar rbuf[2];\n\tint ret;\n\n\tret = recv(fdr, rbuf, sizeof(rbuf), 0);\n\tif (ret == -1 && errno == EAGAIN)\n\t\terror(1, EAGAIN, \"recv: timeout\");\n\tif (ret == -1)\n\t\terror(1, errno, \"read\");\n\tif (ret != 1)\n\t\terror(1, 0, \"read: %dB\", ret);\n\n\ttstop = (gettime_ns(cfg_clockid) - glob_tstart) / 1000;\n\ttexpect = ts->delay_us >= 0 ? ts->delay_us : 0;\n\n\tfprintf(stderr, \"payload:%c delay:%lld expected:%lld (us)\\n\",\n\t\t\trbuf[0], (long long)tstop, (long long)texpect);\n\n\tif (rbuf[0] != ts->data)\n\t\terror(1, 0, \"payload mismatch. expected %c\", ts->data);\n\n\tif (llabs(tstop - texpect) > cfg_variance_us)\n\t\terror(1, 0, \"exceeds variance (%d us)\", cfg_variance_us);\n}\n\nstatic void do_recv_verify_empty(int fdr)\n{\n\tchar rbuf[1];\n\tint ret;\n\n\tret = recv(fdr, rbuf, sizeof(rbuf), 0);\n\tif (ret != -1 || errno != EAGAIN)\n\t\terror(1, 0, \"recv: not empty as expected (%d, %d)\", ret, errno);\n}\n\nstatic int do_recv_errqueue_timeout(int fdt)\n{\n\tchar control[CMSG_SPACE(sizeof(struct sock_extended_err)) +\n\t\t     CMSG_SPACE(sizeof(struct sockaddr_in6))] = {0};\n\tchar data[sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +\n\t\t  sizeof(struct udphdr) + 1];\n\tstruct sock_extended_err *err;\n\tint ret, num_tstamp = 0;\n\tstruct msghdr msg = {0};\n\tstruct iovec iov = {0};\n\tstruct cmsghdr *cm;\n\tint64_t tstamp = 0;\n\n\tiov.iov_base = data;\n\tiov.iov_len = sizeof(data);\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tmsg.msg_control = control;\n\tmsg.msg_controllen = sizeof(control);\n\n\twhile (1) {\n\t\tconst char *reason;\n\n\t\tret = recvmsg(fdt, &msg, MSG_ERRQUEUE);\n\t\tif (ret == -1 && errno == EAGAIN)\n\t\t\tbreak;\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"errqueue\");\n\t\tif (msg.msg_flags != MSG_ERRQUEUE)\n\t\t\terror(1, 0, \"errqueue: flags 0x%x\\n\", msg.msg_flags);\n\n\t\tcm = CMSG_FIRSTHDR(&msg);\n\t\tif (cm->cmsg_level != cfg_errq_level ||\n\t\t    cm->cmsg_type != cfg_errq_type)\n\t\t\terror(1, 0, \"errqueue: type 0x%x.0x%x\\n\",\n\t\t\t\t    cm->cmsg_level, cm->cmsg_type);\n\n\t\terr = (struct sock_extended_err *)CMSG_DATA(cm);\n\t\tif (err->ee_origin != SO_EE_ORIGIN_TXTIME)\n\t\t\terror(1, 0, \"errqueue: origin 0x%x\\n\", err->ee_origin);\n\n\t\tswitch (err->ee_errno) {\n\t\tcase ECANCELED:\n\t\t\tif (err->ee_code != SO_EE_CODE_TXTIME_MISSED)\n\t\t\t\terror(1, 0, \"errqueue: unknown ECANCELED %u\\n\",\n\t\t\t\t      err->ee_code);\n\t\t\treason = \"missed txtime\";\n\t\tbreak;\n\t\tcase EINVAL:\n\t\t\tif (err->ee_code != SO_EE_CODE_TXTIME_INVALID_PARAM)\n\t\t\t\terror(1, 0, \"errqueue: unknown EINVAL %u\\n\",\n\t\t\t\t      err->ee_code);\n\t\t\treason = \"invalid txtime\";\n\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"errqueue: errno %u code %u\\n\",\n\t\t\t      err->ee_errno, err->ee_code);\n\t\t}\n\n\t\ttstamp = ((int64_t) err->ee_data) << 32 | err->ee_info;\n\t\ttstamp -= (int64_t) glob_tstart;\n\t\ttstamp /= 1000 * 1000;\n\t\tfprintf(stderr, \"send: pkt %c at %\" PRId64 \"ms dropped: %s\\n\",\n\t\t\tdata[ret - 1], tstamp, reason);\n\n\t\tmsg.msg_flags = 0;\n\t\tmsg.msg_controllen = sizeof(control);\n\t\tnum_tstamp++;\n\t}\n\n\treturn num_tstamp;\n}\n\nstatic void recv_errqueue_msgs(int fdt)\n{\n\tstruct pollfd pfd = { .fd = fdt, .events = POLLERR };\n\tconst int timeout_ms = 10;\n\tint ret, num_tstamp = 0;\n\n\tdo {\n\t\tret = poll(&pfd, 1, timeout_ms);\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"poll\");\n\n\t\tif (ret && (pfd.revents & POLLERR))\n\t\t\tnum_tstamp += do_recv_errqueue_timeout(fdt);\n\n\t\tif (num_tstamp == cfg_num_pkt)\n\t\t\tbreak;\n\n\t} while (gettime_ns(cfg_clockid) < tdeliver_max);\n}\n\nstatic void start_time_wait(void)\n{\n\tuint64_t now;\n\tint err;\n\n\tif (!cfg_start_time_ns)\n\t\treturn;\n\n\tnow = gettime_ns(CLOCK_REALTIME);\n\tif (cfg_start_time_ns < now)\n\t\treturn;\n\n\terr = usleep((cfg_start_time_ns - now) / 1000);\n\tif (err)\n\t\terror(1, errno, \"usleep\");\n}\n\nstatic void setsockopt_txtime(int fd)\n{\n\tstruct sock_txtime so_txtime_val = { .clockid = cfg_clockid };\n\tstruct sock_txtime so_txtime_val_read = { 0 };\n\tsocklen_t vallen = sizeof(so_txtime_val);\n\n\tso_txtime_val.flags = SOF_TXTIME_REPORT_ERRORS;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_TXTIME,\n\t\t       &so_txtime_val, sizeof(so_txtime_val)))\n\t\terror(1, errno, \"setsockopt txtime\");\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_TXTIME,\n\t\t       &so_txtime_val_read, &vallen))\n\t\terror(1, errno, \"getsockopt txtime\");\n\n\tif (vallen != sizeof(so_txtime_val) ||\n\t    memcmp(&so_txtime_val, &so_txtime_val_read, vallen))\n\t\terror(1, 0, \"getsockopt txtime: mismatch\");\n}\n\nstatic int setup_tx(struct sockaddr *addr, socklen_t alen)\n{\n\tint fd;\n\n\tfd = socket(addr->sa_family, SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket t\");\n\n\tif (connect(fd, addr, alen))\n\t\terror(1, errno, \"connect\");\n\n\tsetsockopt_txtime(fd);\n\n\tif (cfg_mark &&\n\t    setsockopt(fd, SOL_SOCKET, SO_MARK, &cfg_mark, sizeof(cfg_mark)))\n\t\terror(1, errno, \"setsockopt mark\");\n\n\treturn fd;\n}\n\nstatic int setup_rx(struct sockaddr *addr, socklen_t alen)\n{\n\tstruct timeval tv = { .tv_usec = 100 * 1000 };\n\tint fd;\n\n\tfd = socket(addr->sa_family, SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket r\");\n\n\tif (bind(fd, addr, alen))\n\t\terror(1, errno, \"bind\");\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)))\n\t\terror(1, errno, \"setsockopt rcv timeout\");\n\n\treturn fd;\n}\n\nstatic void do_test_tx(struct sockaddr *addr, socklen_t alen)\n{\n\tint fdt, i;\n\n\tfprintf(stderr, \"\\nSO_TXTIME ipv%c clock %s\\n\",\n\t\t\taddr->sa_family == PF_INET ? '4' : '6',\n\t\t\tcfg_clockid == CLOCK_TAI ? \"tai\" : \"monotonic\");\n\n\tfdt = setup_tx(addr, alen);\n\n\tstart_time_wait();\n\tglob_tstart = gettime_ns(cfg_clockid);\n\n\tfor (i = 0; i < cfg_num_pkt; i++)\n\t\tdo_send_one(fdt, &cfg_buf[i]);\n\n\trecv_errqueue_msgs(fdt);\n\n\tif (close(fdt))\n\t\terror(1, errno, \"close t\");\n}\n\nstatic void do_test_rx(struct sockaddr *addr, socklen_t alen)\n{\n\tint fdr, i;\n\n\tfdr = setup_rx(addr, alen);\n\n\tstart_time_wait();\n\tglob_tstart = gettime_ns(cfg_clockid);\n\n\tfor (i = 0; i < cfg_num_pkt; i++)\n\t\tdo_recv_one(fdr, &cfg_buf[i]);\n\n\tdo_recv_verify_empty(fdr);\n\n\tif (close(fdr))\n\t\terror(1, errno, \"close r\");\n}\n\nstatic void setup_sockaddr(int domain, const char *str_addr,\n\t\t\t   struct sockaddr_storage *sockaddr)\n{\n\tstruct sockaddr_in6 *addr6 = (void *) sockaddr;\n\tstruct sockaddr_in *addr4 = (void *) sockaddr;\n\n\tswitch (domain) {\n\tcase PF_INET:\n\t\tmemset(addr4, 0, sizeof(*addr4));\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_port = htons(cfg_port);\n\t\tif (str_addr &&\n\t\t    inet_pton(AF_INET, str_addr, &(addr4->sin_addr)) != 1)\n\t\t\terror(1, 0, \"ipv4 parse error: %s\", str_addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tmemset(addr6, 0, sizeof(*addr6));\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_port = htons(cfg_port);\n\t\tif (str_addr &&\n\t\t    inet_pton(AF_INET6, str_addr, &(addr6->sin6_addr)) != 1)\n\t\t\terror(1, 0, \"ipv6 parse error: %s\", str_addr);\n\t\tbreak;\n\t}\n}\n\nstatic int parse_io(const char *optarg, struct timed_send *array)\n{\n\tchar *arg, *tok;\n\tint aoff = 0;\n\n\targ = strdup(optarg);\n\tif (!arg)\n\t\terror(1, errno, \"strdup\");\n\n\twhile ((tok = strtok(arg, \",\"))) {\n\t\targ = NULL;\t \n\n\t\tif (aoff / 2 == MAX_NUM_PKT)\n\t\t\terror(1, 0, \"exceeds max pkt count (%d)\", MAX_NUM_PKT);\n\n\t\tif (aoff & 1) {\t \n\t\t\tarray->delay_us = strtol(tok, NULL, 0) * 1000;\n\t\t\tarray++;\n\t\t} else {\t \n\t\t\tarray->data = tok[0];\n\t\t}\n\n\t\taoff++;\n\t}\n\n\tfree(arg);\n\n\treturn aoff / 2;\n}\n\nstatic void usage(const char *progname)\n{\n\tfprintf(stderr, \"\\nUsage: %s [options] <payload>\\n\"\n\t\t\t\"Options:\\n\"\n\t\t\t\"  -4            only IPv4\\n\"\n\t\t\t\"  -6            only IPv6\\n\"\n\t\t\t\"  -c <clock>    monotonic or tai (default)\\n\"\n\t\t\t\"  -D <addr>     destination IP address (server)\\n\"\n\t\t\t\"  -S <addr>     source IP address (client)\\n\"\n\t\t\t\"  -r            run rx mode\\n\"\n\t\t\t\"  -t <nsec>     start time (UTC nanoseconds)\\n\"\n\t\t\t\"  -m <mark>     socket mark\\n\"\n\t\t\t\"\\n\",\n\t\t\tprogname);\n\texit(1);\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tchar *daddr = NULL, *saddr = NULL;\n\tint domain = PF_UNSPEC;\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"46c:S:D:rt:m:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tif (domain != PF_UNSPEC)\n\t\t\t\terror(1, 0, \"Pass one of -4 or -6\");\n\t\t\tdomain = PF_INET;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in);\n\t\t\tcfg_errq_level = SOL_IP;\n\t\t\tcfg_errq_type = IP_RECVERR;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tif (domain != PF_UNSPEC)\n\t\t\t\terror(1, 0, \"Pass one of -4 or -6\");\n\t\t\tdomain = PF_INET6;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in6);\n\t\t\tcfg_errq_level = SOL_IPV6;\n\t\t\tcfg_errq_type = IPV6_RECVERR;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (!strcmp(optarg, \"tai\"))\n\t\t\t\tcfg_clockid = CLOCK_TAI;\n\t\t\telse if (!strcmp(optarg, \"monotonic\") ||\n\t\t\t\t !strcmp(optarg, \"mono\"))\n\t\t\t\tcfg_clockid = CLOCK_MONOTONIC;\n\t\t\telse\n\t\t\t\terror(1, 0, \"unknown clock id %s\", optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsaddr = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdaddr = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcfg_rx = true;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_start_time_ns = strtoll(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcfg_mark = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (argc - optind != 1)\n\t\tusage(argv[0]);\n\n\tif (domain == PF_UNSPEC)\n\t\terror(1, 0, \"Pass one of -4 or -6\");\n\tif (!daddr)\n\t\terror(1, 0, \"-D <server addr> required\\n\");\n\tif (!cfg_rx && !saddr)\n\t\terror(1, 0, \"-S <client addr> required\\n\");\n\n\tsetup_sockaddr(domain, daddr, &cfg_dst_addr);\n\tsetup_sockaddr(domain, saddr, &cfg_src_addr);\n\n\tcfg_num_pkt = parse_io(argv[optind], cfg_buf);\n}\n\nint main(int argc, char **argv)\n{\n\tparse_opts(argc, argv);\n\n\tif (cfg_rx)\n\t\tdo_test_rx((void *)&cfg_dst_addr, cfg_alen);\n\telse\n\t\tdo_test_tx((void *)&cfg_src_addr, cfg_alen);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}