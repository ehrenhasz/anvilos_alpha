{
  "module_name": "vrf_strict_mode_test.sh",
  "hash_id": "5570e43384d04210596317c7fe56c8d2aac3fb20389a30fe84e8599874428fd1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/vrf_strict_mode_test.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# This test is designed for testing the new VRF strict_mode functionality.\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\nret=0\n\n# identifies the \"init\" network namespace which is often called root network\n# namespace.\nINIT_NETNS_NAME=\"init\"\n\nPAUSE_ON_FAIL=${PAUSE_ON_FAIL:=no}\n\nTESTS=\"init testns mix\"\n\nlog_test()\n{\n\tlocal rc=$1\n\tlocal expected=$2\n\tlocal msg=\"$3\"\n\n\tif [ ${rc} -eq ${expected} ]; then\n\t\tnsuccess=$((nsuccess+1))\n\t\tprintf \"\\n    TEST: %-60s  [ OK ]\\n\" \"${msg}\"\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"\\n    TEST: %-60s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n}\n\nprint_log_test_results()\n{\n\tif [ \"$TESTS\" != \"none\" ]; then\n\t\tprintf \"\\nTests passed: %3d\\n\" ${nsuccess}\n\t\tprintf \"Tests failed: %3d\\n\"   ${nfail}\n\tfi\n}\n\nlog_section()\n{\n\techo\n\techo \"################################################################################\"\n\techo \"TEST SECTION: $*\"\n\techo \"################################################################################\"\n}\n\nip_expand_args()\n{\n\tlocal nsname=$1\n\tlocal nsarg=\"\"\n\n\tif [ \"${nsname}\" != \"${INIT_NETNS_NAME}\" ]; then\n\t\tnsarg=\"-netns ${nsname}\"\n\tfi\n\n\techo \"${nsarg}\"\n}\n\nvrf_count()\n{\n\tlocal nsname=$1\n\tlocal nsarg=\"$(ip_expand_args ${nsname})\"\n\n\tip ${nsarg} -o link show type vrf | wc -l\n}\n\ncount_vrf_by_table_id()\n{\n\tlocal nsname=$1\n\tlocal tableid=$2\n\tlocal nsarg=\"$(ip_expand_args ${nsname})\"\n\n\tip ${nsarg} -d -o link show type vrf | grep \"table ${tableid}\" | wc -l\n}\n\nadd_vrf()\n{\n\tlocal nsname=$1\n\tlocal vrfname=$2\n\tlocal vrftable=$3\n\tlocal nsarg=\"$(ip_expand_args ${nsname})\"\n\n\tip ${nsarg} link add ${vrfname} type vrf table ${vrftable} &>/dev/null\n}\n\nadd_vrf_and_check()\n{\n\tlocal nsname=$1\n\tlocal vrfname=$2\n\tlocal vrftable=$3\n\tlocal cnt\n\tlocal rc\n\n\tadd_vrf ${nsname} ${vrfname} ${vrftable}; rc=$?\n\n\tcnt=$(count_vrf_by_table_id ${nsname} ${vrftable})\n\n\tlog_test ${rc} 0 \"${nsname}: add vrf ${vrfname}, ${cnt} vrfs for table ${vrftable}\"\n}\n\nadd_vrf_and_check_fail()\n{\n\tlocal nsname=$1\n\tlocal vrfname=$2\n\tlocal vrftable=$3\n\tlocal cnt\n\tlocal rc\n\n\tadd_vrf ${nsname} ${vrfname} ${vrftable}; rc=$?\n\n\tcnt=$(count_vrf_by_table_id ${nsname} ${vrftable})\n\n\tlog_test ${rc} 2 \"${nsname}: CANNOT add vrf ${vrfname}, ${cnt} vrfs for table ${vrftable}\"\n}\n\ndel_vrf_and_check()\n{\n\tlocal nsname=$1\n\tlocal vrfname=$2\n\tlocal nsarg=\"$(ip_expand_args ${nsname})\"\n\n\tip ${nsarg} link del ${vrfname}\n\tlog_test $? 0 \"${nsname}: remove vrf ${vrfname}\"\n}\n\nconfig_vrf_and_check()\n{\n\tlocal nsname=$1\n\tlocal addr=$2\n\tlocal vrfname=$3\n\tlocal nsarg=\"$(ip_expand_args ${nsname})\"\n\n\tip ${nsarg} link set dev ${vrfname} up && \\\n\t\tip ${nsarg} addr add ${addr} dev ${vrfname}\n\tlog_test $? 0 \"${nsname}: vrf ${vrfname} up, addr ${addr}\"\n}\n\nread_strict_mode()\n{\n\tlocal nsname=$1\n\tlocal rval\n\tlocal rc=0\n\tlocal nsexec=\"\"\n\n\tif [ \"${nsname}\" != \"${INIT_NETNS_NAME}\" ]; then\n\t\t# a custom network namespace is provided\n\t\tnsexec=\"ip netns exec ${nsname}\"\n\tfi\n\n\trval=\"$(${nsexec} bash -c \"cat /proc/sys/net/vrf/strict_mode\" | \\\n\t\tgrep -E \"^[0-1]$\")\" &> /dev/null\n\tif [ $? -ne 0 ]; then\n\t\t# set errors\n\t\trval=255\n\t\trc=1\n\tfi\n\n\t# on success, rval can be only 0 or 1; on error, rval is equal to 255\n\techo ${rval}\n\treturn ${rc}\n}\n\nread_strict_mode_compare_and_check()\n{\n\tlocal nsname=$1\n\tlocal expected=$2\n\tlocal res\n\n\tres=\"$(read_strict_mode ${nsname})\"\n\tlog_test ${res} ${expected} \"${nsname}: check strict_mode=${res}\"\n}\n\nset_strict_mode()\n{\n\tlocal nsname=$1\n\tlocal val=$2\n\tlocal nsexec=\"\"\n\n\tif [ \"${nsname}\" != \"${INIT_NETNS_NAME}\" ]; then\n\t\t# a custom network namespace is provided\n\t\tnsexec=\"ip netns exec ${nsname}\"\n\tfi\n\n\t${nsexec} bash -c \"echo ${val} >/proc/sys/net/vrf/strict_mode\" &>/dev/null\n}\n\nenable_strict_mode()\n{\n\tlocal nsname=$1\n\n\tset_strict_mode ${nsname} 1\n}\n\ndisable_strict_mode()\n{\n\tlocal nsname=$1\n\n\tset_strict_mode ${nsname} 0\n}\n\ndisable_strict_mode_and_check()\n{\n\tlocal nsname=$1\n\n\tdisable_strict_mode ${nsname}\n\tlog_test $? 0 \"${nsname}: disable strict_mode (=0)\"\n}\n\nenable_strict_mode_and_check()\n{\n\tlocal nsname=$1\n\n\tenable_strict_mode ${nsname}\n\tlog_test $? 0 \"${nsname}: enable strict_mode (=1)\"\n}\n\nenable_strict_mode_and_check_fail()\n{\n\tlocal nsname=$1\n\n\tenable_strict_mode ${nsname}\n\tlog_test $? 1 \"${nsname}: CANNOT enable strict_mode\"\n}\n\nstrict_mode_check_default()\n{\n\tlocal nsname=$1\n\tlocal strictmode\n\tlocal vrfcnt\n\n\tvrfcnt=$(vrf_count ${nsname})\n\tstrictmode=$(read_strict_mode ${nsname})\n\tlog_test ${strictmode} 0 \"${nsname}: strict_mode=0 by default, ${vrfcnt} vrfs\"\n}\n\nsetup()\n{\n\tmodprobe vrf\n\n\tip netns add testns\n\tip netns exec testns ip link set lo up\n}\n\ncleanup()\n{\n\tip netns del testns 2>/dev/null\n\n\tip link del vrf100 2>/dev/null\n\tip link del vrf101 2>/dev/null\n\tip link del vrf102 2>/dev/null\n\n\techo 0 >/proc/sys/net/vrf/strict_mode 2>/dev/null\n}\n\nvrf_strict_mode_tests_init()\n{\n\tlog_section \"VRF strict_mode test on init network namespace\"\n\n\tvrf_strict_mode_check_support init\n\n\tstrict_mode_check_default init\n\n\tadd_vrf_and_check init vrf100 100\n\tconfig_vrf_and_check init 172.16.100.1/24 vrf100\n\n\tenable_strict_mode_and_check init\n\n\tadd_vrf_and_check_fail init vrf101 100\n\n\tdisable_strict_mode_and_check init\n\n\tadd_vrf_and_check init vrf101 100\n\tconfig_vrf_and_check init 172.16.101.1/24 vrf101\n\n\tenable_strict_mode_and_check_fail init\n\n\tdel_vrf_and_check init vrf101\n\n\tenable_strict_mode_and_check init\n\n\tadd_vrf_and_check init vrf102 102\n\tconfig_vrf_and_check init 172.16.102.1/24 vrf102\n\n\t# the strict_modle is enabled in the init\n}\n\nvrf_strict_mode_tests_testns()\n{\n\tlog_section \"VRF strict_mode test on testns network namespace\"\n\n\tvrf_strict_mode_check_support testns\n\n\tstrict_mode_check_default testns\n\n\tenable_strict_mode_and_check testns\n\n\tadd_vrf_and_check testns vrf100 100\n\tconfig_vrf_and_check testns 10.0.100.1/24 vrf100\n\n\tadd_vrf_and_check_fail testns vrf101 100\n\n\tadd_vrf_and_check_fail testns vrf102 100\n\n\tadd_vrf_and_check testns vrf200 200\n\n\tdisable_strict_mode_and_check testns\n\n\tadd_vrf_and_check testns vrf101 100\n\n\tadd_vrf_and_check testns vrf102 100\n\n\t#the strict_mode is disabled in the testns\n}\n\nvrf_strict_mode_tests_mix()\n{\n\tlog_section \"VRF strict_mode test mixing init and testns network namespaces\"\n\n\tread_strict_mode_compare_and_check init 1\n\n\tread_strict_mode_compare_and_check testns 0\n\n\tdel_vrf_and_check testns vrf101\n\n\tdel_vrf_and_check testns vrf102\n\n\tdisable_strict_mode_and_check init\n\n\tenable_strict_mode_and_check testns\n\n\tenable_strict_mode_and_check init\n\tenable_strict_mode_and_check init\n\n\tdisable_strict_mode_and_check testns\n\tdisable_strict_mode_and_check testns\n\n\tread_strict_mode_compare_and_check init 1\n\n\tread_strict_mode_compare_and_check testns 0\n}\n\n################################################################################\n# usage\n\nusage()\n{\n\tcat <<EOF\nusage: ${0##*/} OPTS\n\n\t-t <test>\tTest(s) to run (default: all)\n\t\t\t(options: $TESTS)\nEOF\n}\n\n################################################################################\n# main\n\nwhile getopts \":t:h\" opt; do\n\tcase $opt in\n\t\tt) TESTS=$OPTARG;;\n\t\th) usage; exit 0;;\n\t\t*) usage; exit 1;;\n\tesac\ndone\n\nvrf_strict_mode_check_support()\n{\n\tlocal nsname=$1\n\tlocal output\n\tlocal rc\n\n\toutput=\"$(lsmod | grep '^vrf' | awk '{print $1}')\"\n\tif [ -z \"${output}\" ]; then\n\t\tmodinfo vrf || return $?\n\tfi\n\n\t# we do not care about the value of the strict_mode; we only check if\n\t# the strict_mode parameter is available or not.\n\tread_strict_mode ${nsname} &>/dev/null; rc=$?\n\tlog_test ${rc} 0 \"${nsname}: net.vrf.strict_mode is available\"\n\n\treturn ${rc}\n}\n\nif [ \"$(id -u)\" -ne 0 ];then\n\techo \"SKIP: Need root privileges\"\n\texit $ksft_skip\nfi\n\nif [ ! -x \"$(command -v ip)\" ]; then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nmodprobe vrf &>/dev/null\nif [ ! -e /proc/sys/net/vrf/strict_mode ]; then\n\techo \"SKIP: vrf sysctl does not exist\"\n\texit $ksft_skip\nfi\n\ncleanup &> /dev/null\n\nsetup\nfor t in $TESTS\ndo\n\tcase $t in\n\tvrf_strict_mode_tests_init|init) vrf_strict_mode_tests_init;;\n\tvrf_strict_mode_tests_testns|testns) vrf_strict_mode_tests_testns;;\n\tvrf_strict_mode_tests_mix|mix) vrf_strict_mode_tests_mix;;\n\n\thelp) echo \"Test names: $TESTS\"; exit 0;;\n\n\tesac\ndone\ncleanup\n\nprint_log_test_results\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}