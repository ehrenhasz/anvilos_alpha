{
  "module_name": "reuseport_addr_any.c",
  "hash_id": "5ab97a7dd5db6dba3b74a60e06155a4cecbc83664a5b3eb013b493430cf35e10",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/reuseport_addr_any.c",
  "human_readable_source": "\n\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <linux/dccp.h>\n#include <linux/in.h>\n#include <linux/unistd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#ifndef SOL_DCCP\n#define SOL_DCCP 269\n#endif\n\nstatic const char *IP4_ADDR = \"127.0.0.1\";\nstatic const char *IP6_ADDR = \"::1\";\nstatic const char *IP4_MAPPED6 = \"::ffff:127.0.0.1\";\n\nstatic const int PORT = 8888;\n\nstatic void build_rcv_fd(int family, int proto, int *rcv_fds, int count,\n\t\t\t const char *addr_str)\n{\n\tstruct sockaddr_in  addr4 = {0};\n\tstruct sockaddr_in6 addr6 = {0};\n\tstruct sockaddr *addr;\n\tint opt, i, sz;\n\n\tmemset(&addr, 0, sizeof(addr));\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr4.sin_family = family;\n\t\tif (!addr_str)\n\t\t\taddr4.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\telse if (!inet_pton(family, addr_str, &addr4.sin_addr.s_addr))\n\t\t\terror(1, errno, \"inet_pton failed: %s\", addr_str);\n\t\taddr4.sin_port = htons(PORT);\n\t\tsz = sizeof(addr4);\n\t\taddr = (struct sockaddr *)&addr4;\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddr6.sin6_family = AF_INET6;\n\t\tif (!addr_str)\n\t\t\taddr6.sin6_addr = in6addr_any;\n\t\telse if (!inet_pton(family, addr_str, &addr6.sin6_addr))\n\t\t\terror(1, errno, \"inet_pton failed: %s\", addr_str);\n\t\taddr6.sin6_port = htons(PORT);\n\t\tsz = sizeof(addr6);\n\t\taddr = (struct sockaddr *)&addr6;\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t\t \n\t\treturn;\n\t}\n\n\tfor (i = 0; i < count; ++i) {\n\t\trcv_fds[i] = socket(family, proto, 0);\n\t\tif (rcv_fds[i] < 0)\n\t\t\terror(1, errno, \"failed to create receive socket\");\n\n\t\topt = 1;\n\t\tif (setsockopt(rcv_fds[i], SOL_SOCKET, SO_REUSEPORT, &opt,\n\t\t\t       sizeof(opt)))\n\t\t\terror(1, errno, \"failed to set SO_REUSEPORT\");\n\n\t\tif (bind(rcv_fds[i], addr, sz))\n\t\t\terror(1, errno, \"failed to bind receive socket\");\n\n\t\tif (proto == SOCK_STREAM && listen(rcv_fds[i], 10))\n\t\t\terror(1, errno, \"tcp: failed to listen on receive port\");\n\t\telse if (proto == SOCK_DCCP) {\n\t\t\tif (setsockopt(rcv_fds[i], SOL_DCCP,\n\t\t\t\t\tDCCP_SOCKOPT_SERVICE,\n\t\t\t\t\t&(int) {htonl(42)}, sizeof(int)))\n\t\t\t\terror(1, errno, \"failed to setsockopt\");\n\n\t\t\tif (listen(rcv_fds[i], 10))\n\t\t\t\terror(1, errno, \"dccp: failed to listen on receive port\");\n\t\t}\n\t}\n}\n\nstatic int connect_and_send(int family, int proto)\n{\n\tstruct sockaddr_in  saddr4 = {0};\n\tstruct sockaddr_in  daddr4 = {0};\n\tstruct sockaddr_in6 saddr6 = {0};\n\tstruct sockaddr_in6 daddr6 = {0};\n\tstruct sockaddr *saddr, *daddr;\n\tint fd, sz;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tsaddr4.sin_family = AF_INET;\n\t\tsaddr4.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tsaddr4.sin_port = 0;\n\n\t\tdaddr4.sin_family = AF_INET;\n\t\tif (!inet_pton(family, IP4_ADDR, &daddr4.sin_addr.s_addr))\n\t\t\terror(1, errno, \"inet_pton failed: %s\", IP4_ADDR);\n\t\tdaddr4.sin_port = htons(PORT);\n\n\t\tsz = sizeof(saddr4);\n\t\tsaddr = (struct sockaddr *)&saddr4;\n\t\tdaddr = (struct sockaddr *)&daddr4;\n\tbreak;\n\tcase AF_INET6:\n\t\tsaddr6.sin6_family = AF_INET6;\n\t\tsaddr6.sin6_addr = in6addr_any;\n\n\t\tdaddr6.sin6_family = AF_INET6;\n\t\tif (!inet_pton(family, IP6_ADDR, &daddr6.sin6_addr))\n\t\t\terror(1, errno, \"inet_pton failed: %s\", IP6_ADDR);\n\t\tdaddr6.sin6_port = htons(PORT);\n\n\t\tsz = sizeof(saddr6);\n\t\tsaddr = (struct sockaddr *)&saddr6;\n\t\tdaddr = (struct sockaddr *)&daddr6;\n\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t\t \n\t\treturn -1;\n\t}\n\n\tfd = socket(family, proto, 0);\n\tif (fd < 0)\n\t\terror(1, errno, \"failed to create send socket\");\n\n\tif (proto == SOCK_DCCP &&\n\t\tsetsockopt(fd, SOL_DCCP, DCCP_SOCKOPT_SERVICE,\n\t\t\t\t&(int){htonl(42)}, sizeof(int)))\n\t\terror(1, errno, \"failed to setsockopt\");\n\n\tif (bind(fd, saddr, sz))\n\t\terror(1, errno, \"failed to bind send socket\");\n\n\tif (connect(fd, daddr, sz))\n\t\terror(1, errno, \"failed to connect send socket\");\n\n\tif (send(fd, \"a\", 1, 0) < 0)\n\t\terror(1, errno, \"failed to send message\");\n\n\treturn fd;\n}\n\nstatic int receive_once(int epfd, int proto)\n{\n\tstruct epoll_event ev;\n\tint i, fd;\n\tchar buf[8];\n\n\ti = epoll_wait(epfd, &ev, 1, 3);\n\tif (i < 0)\n\t\terror(1, errno, \"epoll_wait failed\");\n\n\tif (proto == SOCK_STREAM || proto == SOCK_DCCP) {\n\t\tfd = accept(ev.data.fd, NULL, NULL);\n\t\tif (fd < 0)\n\t\t\terror(1, errno, \"failed to accept\");\n\t\ti = recv(fd, buf, sizeof(buf), 0);\n\t\tclose(fd);\n\t} else {\n\t\ti = recv(ev.data.fd, buf, sizeof(buf), 0);\n\t}\n\n\tif (i < 0)\n\t\terror(1, errno, \"failed to recv\");\n\n\treturn ev.data.fd;\n}\n\nstatic void test(int *rcv_fds, int count, int family, int proto, int fd)\n{\n\tstruct epoll_event ev;\n\tint epfd, i, send_fd, recv_fd;\n\n\tepfd = epoll_create(1);\n\tif (epfd < 0)\n\t\terror(1, errno, \"failed to create epoll\");\n\n\tev.events = EPOLLIN;\n\tfor (i = 0; i < count; ++i) {\n\t\tev.data.fd = rcv_fds[i];\n\t\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, rcv_fds[i], &ev))\n\t\t\terror(1, errno, \"failed to register sock epoll\");\n\t}\n\n\tsend_fd = connect_and_send(family, proto);\n\n\trecv_fd = receive_once(epfd, proto);\n\tif (recv_fd != fd)\n\t\terror(1, 0, \"received on an unexpected socket\");\n\n\tclose(send_fd);\n\tclose(epfd);\n}\n\n\nstatic void run_one_test(int fam_send, int fam_rcv, int proto,\n\t\t\t const char *addr_str)\n{\n\t \n\tint rcv_fds[10], i;\n\n\tbuild_rcv_fd(AF_INET, proto, rcv_fds, 2, NULL);\n\tbuild_rcv_fd(AF_INET6, proto, rcv_fds + 2, 2, NULL);\n\tbuild_rcv_fd(fam_rcv, proto, rcv_fds + 4, 1, addr_str);\n\tbuild_rcv_fd(AF_INET, proto, rcv_fds + 5, 2, NULL);\n\tbuild_rcv_fd(AF_INET6, proto, rcv_fds + 7, 2, NULL);\n\ttest(rcv_fds, 9, fam_send, proto, rcv_fds[4]);\n\tfor (i = 0; i < 9; ++i)\n\t\tclose(rcv_fds[i]);\n\tfprintf(stderr, \"pass\\n\");\n}\n\nstatic void test_proto(int proto, const char *proto_str)\n{\n\tif (proto == SOCK_DCCP) {\n\t\tint test_fd;\n\n\t\ttest_fd = socket(AF_INET, proto, 0);\n\t\tif (test_fd < 0) {\n\t\t\tif (errno == ESOCKTNOSUPPORT) {\n\t\t\t\tfprintf(stderr, \"DCCP not supported: skipping DCCP tests\\n\");\n\t\t\t\treturn;\n\t\t\t} else\n\t\t\t\terror(1, errno, \"failed to create a DCCP socket\");\n\t\t}\n\t\tclose(test_fd);\n\t}\n\n\tfprintf(stderr, \"%s IPv4 ... \", proto_str);\n\trun_one_test(AF_INET, AF_INET, proto, IP4_ADDR);\n\n\tfprintf(stderr, \"%s IPv6 ... \", proto_str);\n\trun_one_test(AF_INET6, AF_INET6, proto, IP6_ADDR);\n\n\tfprintf(stderr, \"%s IPv4 mapped to IPv6 ... \", proto_str);\n\trun_one_test(AF_INET, AF_INET6, proto, IP4_MAPPED6);\n}\n\nint main(void)\n{\n\ttest_proto(SOCK_DGRAM, \"UDP\");\n\ttest_proto(SOCK_STREAM, \"TCP\");\n\ttest_proto(SOCK_DCCP, \"DCCP\");\n\n\tfprintf(stderr, \"SUCCESS\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}