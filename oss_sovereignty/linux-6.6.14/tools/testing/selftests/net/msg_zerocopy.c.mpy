{
  "module_name": "msg_zerocopy.c",
  "hash_id": "1fb6b0f80e2f95c9918b103edb1654932d9d66c873d31241dac3f774ad874f72",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/msg_zerocopy.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <error.h>\n#include <errno.h>\n#include <limits.h>\n#include <linux/errqueue.h>\n#include <linux/if_packet.h>\n#include <linux/ipv6.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n#include <netinet/ip.h>\n#include <netinet/ip6.h>\n#include <netinet/tcp.h>\n#include <netinet/udp.h>\n#include <poll.h>\n#include <sched.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <linux/rds.h>\n\n#ifndef SO_EE_ORIGIN_ZEROCOPY\n#define SO_EE_ORIGIN_ZEROCOPY\t\t5\n#endif\n\n#ifndef SO_ZEROCOPY\n#define SO_ZEROCOPY\t60\n#endif\n\n#ifndef SO_EE_CODE_ZEROCOPY_COPIED\n#define SO_EE_CODE_ZEROCOPY_COPIED\t1\n#endif\n\n#ifndef MSG_ZEROCOPY\n#define MSG_ZEROCOPY\t0x4000000\n#endif\n\nstatic int  cfg_cork;\nstatic bool cfg_cork_mixed;\nstatic int  cfg_cpu\t\t= -1;\t\t \nstatic int  cfg_family\t\t= PF_UNSPEC;\nstatic int  cfg_ifindex\t\t= 1;\nstatic int  cfg_payload_len;\nstatic int  cfg_port\t\t= 8000;\nstatic bool cfg_rx;\nstatic int  cfg_runtime_ms\t= 4200;\nstatic int  cfg_verbose;\nstatic int  cfg_waittime_ms\t= 500;\nstatic bool cfg_zerocopy;\n\nstatic socklen_t cfg_alen;\nstatic struct sockaddr_storage cfg_dst_addr;\nstatic struct sockaddr_storage cfg_src_addr;\n\nstatic char payload[IP_MAXPACKET];\nstatic long packets, bytes, completions, expected_completions;\nstatic int  zerocopied = -1;\nstatic uint32_t next_completion;\n\nstatic unsigned long gettimeofday_ms(void)\n{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\treturn (tv.tv_sec * 1000) + (tv.tv_usec / 1000);\n}\n\nstatic uint16_t get_ip_csum(const uint16_t *start, int num_words)\n{\n\tunsigned long sum = 0;\n\tint i;\n\n\tfor (i = 0; i < num_words; i++)\n\t\tsum += start[i];\n\n\twhile (sum >> 16)\n\t\tsum = (sum & 0xFFFF) + (sum >> 16);\n\n\treturn ~sum;\n}\n\nstatic int do_setcpu(int cpu)\n{\n\tcpu_set_t mask;\n\n\tCPU_ZERO(&mask);\n\tCPU_SET(cpu, &mask);\n\tif (sched_setaffinity(0, sizeof(mask), &mask))\n\t\tfprintf(stderr, \"cpu: unable to pin, may increase variance.\\n\");\n\telse if (cfg_verbose)\n\t\tfprintf(stderr, \"cpu: %u\\n\", cpu);\n\n\treturn 0;\n}\n\nstatic void do_setsockopt(int fd, int level, int optname, int val)\n{\n\tif (setsockopt(fd, level, optname, &val, sizeof(val)))\n\t\terror(1, errno, \"setsockopt %d.%d: %d\", level, optname, val);\n}\n\nstatic int do_poll(int fd, int events)\n{\n\tstruct pollfd pfd;\n\tint ret;\n\n\tpfd.events = events;\n\tpfd.revents = 0;\n\tpfd.fd = fd;\n\n\tret = poll(&pfd, 1, cfg_waittime_ms);\n\tif (ret == -1)\n\t\terror(1, errno, \"poll\");\n\n\treturn ret && (pfd.revents & events);\n}\n\nstatic int do_accept(int fd)\n{\n\tint fda = fd;\n\n\tfd = accept(fda, NULL, NULL);\n\tif (fd == -1)\n\t\terror(1, errno, \"accept\");\n\tif (close(fda))\n\t\terror(1, errno, \"close listen sock\");\n\n\treturn fd;\n}\n\nstatic void add_zcopy_cookie(struct msghdr *msg, uint32_t cookie)\n{\n\tstruct cmsghdr *cm;\n\n\tif (!msg->msg_control)\n\t\terror(1, errno, \"NULL cookie\");\n\tcm = (void *)msg->msg_control;\n\tcm->cmsg_len = CMSG_LEN(sizeof(cookie));\n\tcm->cmsg_level = SOL_RDS;\n\tcm->cmsg_type = RDS_CMSG_ZCOPY_COOKIE;\n\tmemcpy(CMSG_DATA(cm), &cookie, sizeof(cookie));\n}\n\nstatic bool do_sendmsg(int fd, struct msghdr *msg, bool do_zerocopy, int domain)\n{\n\tint ret, len, i, flags;\n\tstatic uint32_t cookie;\n\tchar ckbuf[CMSG_SPACE(sizeof(cookie))];\n\n\tlen = 0;\n\tfor (i = 0; i < msg->msg_iovlen; i++)\n\t\tlen += msg->msg_iov[i].iov_len;\n\n\tflags = MSG_DONTWAIT;\n\tif (do_zerocopy) {\n\t\tflags |= MSG_ZEROCOPY;\n\t\tif (domain == PF_RDS) {\n\t\t\tmemset(&msg->msg_control, 0, sizeof(msg->msg_control));\n\t\t\tmsg->msg_controllen = CMSG_SPACE(sizeof(cookie));\n\t\t\tmsg->msg_control = (struct cmsghdr *)ckbuf;\n\t\t\tadd_zcopy_cookie(msg, ++cookie);\n\t\t}\n\t}\n\n\tret = sendmsg(fd, msg, flags);\n\tif (ret == -1 && errno == EAGAIN)\n\t\treturn false;\n\tif (ret == -1)\n\t\terror(1, errno, \"send\");\n\tif (cfg_verbose && ret != len)\n\t\tfprintf(stderr, \"send: ret=%u != %u\\n\", ret, len);\n\n\tif (len) {\n\t\tpackets++;\n\t\tbytes += ret;\n\t\tif (do_zerocopy && ret)\n\t\t\texpected_completions++;\n\t}\n\tif (do_zerocopy && domain == PF_RDS) {\n\t\tmsg->msg_control = NULL;\n\t\tmsg->msg_controllen = 0;\n\t}\n\n\treturn true;\n}\n\nstatic void do_sendmsg_corked(int fd, struct msghdr *msg)\n{\n\tbool do_zerocopy = cfg_zerocopy;\n\tint i, payload_len, extra_len;\n\n\t \n\tpayload_len = cfg_payload_len / cfg_cork;\n\textra_len = cfg_payload_len - (cfg_cork * payload_len);\n\n\tdo_setsockopt(fd, IPPROTO_UDP, UDP_CORK, 1);\n\n\tfor (i = 0; i < cfg_cork; i++) {\n\n\t\t \n\t\tif (cfg_cork_mixed)\n\t\t\tdo_zerocopy = (i & 1);\n\n\t\tmsg->msg_iov[0].iov_len = payload_len + extra_len;\n\t\textra_len = 0;\n\n\t\tdo_sendmsg(fd, msg, do_zerocopy,\n\t\t\t   (cfg_dst_addr.ss_family == AF_INET ?\n\t\t\t    PF_INET : PF_INET6));\n\t}\n\n\tdo_setsockopt(fd, IPPROTO_UDP, UDP_CORK, 0);\n}\n\nstatic int setup_iph(struct iphdr *iph, uint16_t payload_len)\n{\n\tstruct sockaddr_in *daddr = (void *) &cfg_dst_addr;\n\tstruct sockaddr_in *saddr = (void *) &cfg_src_addr;\n\n\tmemset(iph, 0, sizeof(*iph));\n\n\tiph->version\t= 4;\n\tiph->tos\t= 0;\n\tiph->ihl\t= 5;\n\tiph->ttl\t= 2;\n\tiph->saddr\t= saddr->sin_addr.s_addr;\n\tiph->daddr\t= daddr->sin_addr.s_addr;\n\tiph->protocol\t= IPPROTO_EGP;\n\tiph->tot_len\t= htons(sizeof(*iph) + payload_len);\n\tiph->check\t= get_ip_csum((void *) iph, iph->ihl << 1);\n\n\treturn sizeof(*iph);\n}\n\nstatic int setup_ip6h(struct ipv6hdr *ip6h, uint16_t payload_len)\n{\n\tstruct sockaddr_in6 *daddr = (void *) &cfg_dst_addr;\n\tstruct sockaddr_in6 *saddr = (void *) &cfg_src_addr;\n\n\tmemset(ip6h, 0, sizeof(*ip6h));\n\n\tip6h->version\t\t= 6;\n\tip6h->payload_len\t= htons(payload_len);\n\tip6h->nexthdr\t\t= IPPROTO_EGP;\n\tip6h->hop_limit\t\t= 2;\n\tip6h->saddr\t\t= saddr->sin6_addr;\n\tip6h->daddr\t\t= daddr->sin6_addr;\n\n\treturn sizeof(*ip6h);\n}\n\n\nstatic void setup_sockaddr(int domain, const char *str_addr,\n\t\t\t   struct sockaddr_storage *sockaddr)\n{\n\tstruct sockaddr_in6 *addr6 = (void *) sockaddr;\n\tstruct sockaddr_in *addr4 = (void *) sockaddr;\n\n\tswitch (domain) {\n\tcase PF_INET:\n\t\tmemset(addr4, 0, sizeof(*addr4));\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_port = htons(cfg_port);\n\t\tif (str_addr &&\n\t\t    inet_pton(AF_INET, str_addr, &(addr4->sin_addr)) != 1)\n\t\t\terror(1, 0, \"ipv4 parse error: %s\", str_addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tmemset(addr6, 0, sizeof(*addr6));\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_port = htons(cfg_port);\n\t\tif (str_addr &&\n\t\t    inet_pton(AF_INET6, str_addr, &(addr6->sin6_addr)) != 1)\n\t\t\terror(1, 0, \"ipv6 parse error: %s\", str_addr);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"illegal domain\");\n\t}\n}\n\nstatic int do_setup_tx(int domain, int type, int protocol)\n{\n\tint fd;\n\n\tfd = socket(domain, type, protocol);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket t\");\n\n\tdo_setsockopt(fd, SOL_SOCKET, SO_SNDBUF, 1 << 21);\n\tif (cfg_zerocopy)\n\t\tdo_setsockopt(fd, SOL_SOCKET, SO_ZEROCOPY, 1);\n\n\tif (domain != PF_PACKET && domain != PF_RDS)\n\t\tif (connect(fd, (void *) &cfg_dst_addr, cfg_alen))\n\t\t\terror(1, errno, \"connect\");\n\n\tif (domain == PF_RDS) {\n\t\tif (bind(fd, (void *) &cfg_src_addr, cfg_alen))\n\t\t\terror(1, errno, \"bind\");\n\t}\n\n\treturn fd;\n}\n\nstatic uint32_t do_process_zerocopy_cookies(struct rds_zcopy_cookies *ck)\n{\n\tint i;\n\n\tif (ck->num > RDS_MAX_ZCOOKIES)\n\t\terror(1, 0, \"Returned %d cookies, max expected %d\\n\",\n\t\t      ck->num, RDS_MAX_ZCOOKIES);\n\tfor (i = 0; i < ck->num; i++)\n\t\tif (cfg_verbose >= 2)\n\t\t\tfprintf(stderr, \"%d\\n\", ck->cookies[i]);\n\treturn ck->num;\n}\n\nstatic bool do_recvmsg_completion(int fd)\n{\n\tchar cmsgbuf[CMSG_SPACE(sizeof(struct rds_zcopy_cookies))];\n\tstruct rds_zcopy_cookies *ck;\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr msg;\n\tbool ret = false;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\n\tif (recvmsg(fd, &msg, MSG_DONTWAIT))\n\t\treturn ret;\n\n\tif (msg.msg_flags & MSG_CTRUNC)\n\t\terror(1, errno, \"recvmsg notification: truncated\");\n\n\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\tif (cmsg->cmsg_level == SOL_RDS &&\n\t\t    cmsg->cmsg_type == RDS_CMSG_ZCOPY_COMPLETION) {\n\n\t\t\tck = (struct rds_zcopy_cookies *)CMSG_DATA(cmsg);\n\t\t\tcompletions += do_process_zerocopy_cookies(ck);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t\terror(0, 0, \"ignoring cmsg at level %d type %d\\n\",\n\t\t\t    cmsg->cmsg_level, cmsg->cmsg_type);\n\t}\n\treturn ret;\n}\n\nstatic bool do_recv_completion(int fd, int domain)\n{\n\tstruct sock_extended_err *serr;\n\tstruct msghdr msg = {};\n\tstruct cmsghdr *cm;\n\tuint32_t hi, lo, range;\n\tint ret, zerocopy;\n\tchar control[100];\n\n\tif (domain == PF_RDS)\n\t\treturn do_recvmsg_completion(fd);\n\n\tmsg.msg_control = control;\n\tmsg.msg_controllen = sizeof(control);\n\n\tret = recvmsg(fd, &msg, MSG_ERRQUEUE);\n\tif (ret == -1 && errno == EAGAIN)\n\t\treturn false;\n\tif (ret == -1)\n\t\terror(1, errno, \"recvmsg notification\");\n\tif (msg.msg_flags & MSG_CTRUNC)\n\t\terror(1, errno, \"recvmsg notification: truncated\");\n\n\tcm = CMSG_FIRSTHDR(&msg);\n\tif (!cm)\n\t\terror(1, 0, \"cmsg: no cmsg\");\n\tif (!((cm->cmsg_level == SOL_IP && cm->cmsg_type == IP_RECVERR) ||\n\t      (cm->cmsg_level == SOL_IPV6 && cm->cmsg_type == IPV6_RECVERR) ||\n\t      (cm->cmsg_level == SOL_PACKET && cm->cmsg_type == PACKET_TX_TIMESTAMP)))\n\t\terror(1, 0, \"serr: wrong type: %d.%d\",\n\t\t      cm->cmsg_level, cm->cmsg_type);\n\n\tserr = (void *) CMSG_DATA(cm);\n\n\tif (serr->ee_origin != SO_EE_ORIGIN_ZEROCOPY)\n\t\terror(1, 0, \"serr: wrong origin: %u\", serr->ee_origin);\n\tif (serr->ee_errno != 0)\n\t\terror(1, 0, \"serr: wrong error code: %u\", serr->ee_errno);\n\n\thi = serr->ee_data;\n\tlo = serr->ee_info;\n\trange = hi - lo + 1;\n\n\t \n\tif (lo != next_completion)\n\t\tfprintf(stderr, \"gap: %u..%u does not append to %u\\n\",\n\t\t\tlo, hi, next_completion);\n\tnext_completion = hi + 1;\n\n\tzerocopy = !(serr->ee_code & SO_EE_CODE_ZEROCOPY_COPIED);\n\tif (zerocopied == -1)\n\t\tzerocopied = zerocopy;\n\telse if (zerocopied != zerocopy) {\n\t\tfprintf(stderr, \"serr: inconsistent\\n\");\n\t\tzerocopied = zerocopy;\n\t}\n\n\tif (cfg_verbose >= 2)\n\t\tfprintf(stderr, \"completed: %u (h=%u l=%u)\\n\",\n\t\t\trange, hi, lo);\n\n\tcompletions += range;\n\treturn true;\n}\n\n \nstatic void do_recv_completions(int fd, int domain)\n{\n\twhile (do_recv_completion(fd, domain)) {}\n}\n\n \nstatic void do_recv_remaining_completions(int fd, int domain)\n{\n\tint64_t tstop = gettimeofday_ms() + cfg_waittime_ms;\n\n\twhile (completions < expected_completions &&\n\t       gettimeofday_ms() < tstop) {\n\t\tif (do_poll(fd, domain == PF_RDS ? POLLIN : POLLERR))\n\t\t\tdo_recv_completions(fd, domain);\n\t}\n\n\tif (completions < expected_completions)\n\t\tfprintf(stderr, \"missing notifications: %lu < %lu\\n\",\n\t\t\tcompletions, expected_completions);\n}\n\nstatic void do_tx(int domain, int type, int protocol)\n{\n\tstruct iovec iov[3] = { {0} };\n\tstruct sockaddr_ll laddr;\n\tstruct msghdr msg = {0};\n\tstruct ethhdr eth;\n\tunion {\n\t\tstruct ipv6hdr ip6h;\n\t\tstruct iphdr iph;\n\t} nh;\n\tuint64_t tstop;\n\tint fd;\n\n\tfd = do_setup_tx(domain, type, protocol);\n\n\tif (domain == PF_PACKET) {\n\t\tuint16_t proto = cfg_family == PF_INET ? ETH_P_IP : ETH_P_IPV6;\n\n\t\t \n\t\tif (type == SOCK_RAW) {\n\t\t\tmemset(eth.h_dest, 0x06, ETH_ALEN);\n\t\t\tmemset(eth.h_source, 0x02, ETH_ALEN);\n\t\t\teth.h_proto = htons(proto);\n\t\t\tiov[0].iov_base = &eth;\n\t\t\tiov[0].iov_len = sizeof(eth);\n\t\t\tmsg.msg_iovlen++;\n\t\t}\n\n\t\t \n\t\tmemset(&laddr, 0, sizeof(laddr));\n\t\tladdr.sll_family\t= AF_PACKET;\n\t\tladdr.sll_ifindex\t= cfg_ifindex;\n\t\tladdr.sll_protocol\t= htons(proto);\n\t\tladdr.sll_halen\t\t= ETH_ALEN;\n\n\t\tmemset(laddr.sll_addr, 0x06, ETH_ALEN);\n\n\t\tmsg.msg_name\t\t= &laddr;\n\t\tmsg.msg_namelen\t\t= sizeof(laddr);\n\t}\n\n\t \n\tif (domain == PF_PACKET || protocol == IPPROTO_RAW) {\n\t\tif (cfg_family == PF_INET)\n\t\t\tiov[1].iov_len = setup_iph(&nh.iph, cfg_payload_len);\n\t\telse\n\t\t\tiov[1].iov_len = setup_ip6h(&nh.ip6h, cfg_payload_len);\n\n\t\tiov[1].iov_base = (void *) &nh;\n\t\tmsg.msg_iovlen++;\n\t}\n\n\tif (domain == PF_RDS) {\n\t\tmsg.msg_name = &cfg_dst_addr;\n\t\tmsg.msg_namelen =  (cfg_dst_addr.ss_family == AF_INET ?\n\t\t\t\t    sizeof(struct sockaddr_in) :\n\t\t\t\t    sizeof(struct sockaddr_in6));\n\t}\n\n\tiov[2].iov_base = payload;\n\tiov[2].iov_len = cfg_payload_len;\n\tmsg.msg_iovlen++;\n\tmsg.msg_iov = &iov[3 - msg.msg_iovlen];\n\n\ttstop = gettimeofday_ms() + cfg_runtime_ms;\n\tdo {\n\t\tif (cfg_cork)\n\t\t\tdo_sendmsg_corked(fd, &msg);\n\t\telse\n\t\t\tdo_sendmsg(fd, &msg, cfg_zerocopy, domain);\n\n\t\twhile (!do_poll(fd, POLLOUT)) {\n\t\t\tif (cfg_zerocopy)\n\t\t\t\tdo_recv_completions(fd, domain);\n\t\t}\n\n\t} while (gettimeofday_ms() < tstop);\n\n\tif (cfg_zerocopy)\n\t\tdo_recv_remaining_completions(fd, domain);\n\n\tif (close(fd))\n\t\terror(1, errno, \"close\");\n\n\tfprintf(stderr, \"tx=%lu (%lu MB) txc=%lu zc=%c\\n\",\n\t\tpackets, bytes >> 20, completions,\n\t\tzerocopied == 1 ? 'y' : 'n');\n}\n\nstatic int do_setup_rx(int domain, int type, int protocol)\n{\n\tint fd;\n\n\t \n\tif (domain == PF_PACKET)\n\t\terror(1, 0, \"Use PF_INET/SOCK_RAW to read\");\n\n\tif (type == SOCK_RAW && protocol == IPPROTO_RAW)\n\t\terror(1, 0, \"IPPROTO_RAW: not supported on Rx\");\n\n\tfd = socket(domain, type, protocol);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket r\");\n\n\tdo_setsockopt(fd, SOL_SOCKET, SO_RCVBUF, 1 << 21);\n\tdo_setsockopt(fd, SOL_SOCKET, SO_RCVLOWAT, 1 << 16);\n\tdo_setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, 1);\n\n\tif (bind(fd, (void *) &cfg_dst_addr, cfg_alen))\n\t\terror(1, errno, \"bind\");\n\n\tif (type == SOCK_STREAM) {\n\t\tif (listen(fd, 1))\n\t\t\terror(1, errno, \"listen\");\n\t\tfd = do_accept(fd);\n\t}\n\n\treturn fd;\n}\n\n \nstatic void do_flush_tcp(int fd)\n{\n\tint ret;\n\n\t \n\tret = recv(fd, NULL, 1 << 21, MSG_TRUNC | MSG_DONTWAIT);\n\tif (ret == -1 && errno == EAGAIN)\n\t\treturn;\n\tif (ret == -1)\n\t\terror(1, errno, \"flush\");\n\tif (!ret)\n\t\treturn;\n\n\tpackets++;\n\tbytes += ret;\n}\n\n \nstatic void do_flush_datagram(int fd, int type)\n{\n\tint ret, off = 0;\n\tchar buf[64];\n\n\t \n\tret = recv(fd, buf, sizeof(buf), MSG_DONTWAIT | MSG_TRUNC);\n\tif (ret == -1 && errno == EAGAIN)\n\t\treturn;\n\n\t \n\tif (cfg_family == PF_INET && type == SOCK_RAW) {\n\t\toff += sizeof(struct iphdr);\n\t\tret -= sizeof(struct iphdr);\n\t}\n\n\tif (ret == -1)\n\t\terror(1, errno, \"recv\");\n\tif (ret != cfg_payload_len)\n\t\terror(1, 0, \"recv: ret=%u != %u\", ret, cfg_payload_len);\n\tif (ret > sizeof(buf) - off)\n\t\tret = sizeof(buf) - off;\n\tif (memcmp(buf + off, payload, ret))\n\t\terror(1, 0, \"recv: data mismatch\");\n\n\tpackets++;\n\tbytes += cfg_payload_len;\n}\n\nstatic void do_rx(int domain, int type, int protocol)\n{\n\tconst int cfg_receiver_wait_ms = 400;\n\tuint64_t tstop;\n\tint fd;\n\n\tfd = do_setup_rx(domain, type, protocol);\n\n\ttstop = gettimeofday_ms() + cfg_runtime_ms + cfg_receiver_wait_ms;\n\tdo {\n\t\tif (type == SOCK_STREAM)\n\t\t\tdo_flush_tcp(fd);\n\t\telse\n\t\t\tdo_flush_datagram(fd, type);\n\n\t\tdo_poll(fd, POLLIN);\n\n\t} while (gettimeofday_ms() < tstop);\n\n\tif (close(fd))\n\t\terror(1, errno, \"close\");\n\n\tfprintf(stderr, \"rx=%lu (%lu MB)\\n\", packets, bytes >> 20);\n}\n\nstatic void do_test(int domain, int type, int protocol)\n{\n\tint i;\n\n\tif (cfg_cork && (domain == PF_PACKET || type != SOCK_DGRAM))\n\t\terror(1, 0, \"can only cork udp sockets\");\n\n\tdo_setcpu(cfg_cpu);\n\n\tfor (i = 0; i < IP_MAXPACKET; i++)\n\t\tpayload[i] = 'a' + (i % 26);\n\n\tif (cfg_rx)\n\t\tdo_rx(domain, type, protocol);\n\telse\n\t\tdo_tx(domain, type, protocol);\n}\n\nstatic void usage(const char *filepath)\n{\n\terror(1, 0, \"Usage: %s [options] <test>\", filepath);\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tconst int max_payload_len = sizeof(payload) -\n\t\t\t\t    sizeof(struct ipv6hdr) -\n\t\t\t\t    sizeof(struct tcphdr) -\n\t\t\t\t    40  ;\n\tint c;\n\tchar *daddr = NULL, *saddr = NULL;\n\tchar *cfg_test;\n\n\tcfg_payload_len = max_payload_len;\n\n\twhile ((c = getopt(argc, argv, \"46c:C:D:i:mp:rs:S:t:vz\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tif (cfg_family != PF_UNSPEC)\n\t\t\t\terror(1, 0, \"Pass one of -4 or -6\");\n\t\t\tcfg_family = PF_INET;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tif (cfg_family != PF_UNSPEC)\n\t\t\t\terror(1, 0, \"Pass one of -4 or -6\");\n\t\t\tcfg_family = PF_INET6;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in6);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcfg_cork = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcfg_cpu = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdaddr = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcfg_ifindex = if_nametoindex(optarg);\n\t\t\tif (cfg_ifindex == 0)\n\t\t\t\terror(1, errno, \"invalid iface: %s\", optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcfg_cork_mixed = true;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcfg_port = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcfg_rx = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcfg_payload_len = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsaddr = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_runtime_ms = 200 + strtoul(optarg, NULL, 10) * 1000;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcfg_verbose++;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tcfg_zerocopy = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcfg_test = argv[argc - 1];\n\tif (strcmp(cfg_test, \"rds\") == 0) {\n\t\tif (!daddr)\n\t\t\terror(1, 0, \"-D <server addr> required for PF_RDS\\n\");\n\t\tif (!cfg_rx && !saddr)\n\t\t\terror(1, 0, \"-S <client addr> required for PF_RDS\\n\");\n\t}\n\tsetup_sockaddr(cfg_family, daddr, &cfg_dst_addr);\n\tsetup_sockaddr(cfg_family, saddr, &cfg_src_addr);\n\n\tif (cfg_payload_len > max_payload_len)\n\t\terror(1, 0, \"-s: payload exceeds max (%d)\", max_payload_len);\n\tif (cfg_cork_mixed && (!cfg_zerocopy || !cfg_cork))\n\t\terror(1, 0, \"-m: cork_mixed requires corking and zerocopy\");\n\n\tif (optind != argc - 1)\n\t\tusage(argv[0]);\n}\n\nint main(int argc, char **argv)\n{\n\tconst char *cfg_test;\n\n\tparse_opts(argc, argv);\n\n\tcfg_test = argv[argc - 1];\n\n\tif (!strcmp(cfg_test, \"packet\"))\n\t\tdo_test(PF_PACKET, SOCK_RAW, 0);\n\telse if (!strcmp(cfg_test, \"packet_dgram\"))\n\t\tdo_test(PF_PACKET, SOCK_DGRAM, 0);\n\telse if (!strcmp(cfg_test, \"raw\"))\n\t\tdo_test(cfg_family, SOCK_RAW, IPPROTO_EGP);\n\telse if (!strcmp(cfg_test, \"raw_hdrincl\"))\n\t\tdo_test(cfg_family, SOCK_RAW, IPPROTO_RAW);\n\telse if (!strcmp(cfg_test, \"tcp\"))\n\t\tdo_test(cfg_family, SOCK_STREAM, 0);\n\telse if (!strcmp(cfg_test, \"udp\"))\n\t\tdo_test(cfg_family, SOCK_DGRAM, 0);\n\telse if (!strcmp(cfg_test, \"rds\"))\n\t\tdo_test(PF_RDS, SOCK_SEQPACKET, 0);\n\telse\n\t\terror(1, 0, \"unknown cfg_test %s\", cfg_test);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}