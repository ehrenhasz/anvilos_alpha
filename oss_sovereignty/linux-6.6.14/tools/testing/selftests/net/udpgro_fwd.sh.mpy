{
  "module_name": "udpgro_fwd.sh",
  "hash_id": "a761c17dd99e986ec33fb9608665373e14e947da16cad2c55e646b90cd54f2d8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/udpgro_fwd.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\nBPF_FILE=\"../bpf/xdp_dummy.bpf.o\"\nreadonly BASE=\"ns-$(mktemp -u XXXXXX)\"\nreadonly SRC=2\nreadonly DST=1\nreadonly DST_NAT=100\nreadonly NS_SRC=$BASE$SRC\nreadonly NS_DST=$BASE$DST\n\n# \"baremetal\" network used for raw UDP traffic\nreadonly BM_NET_V4=192.168.1.\nreadonly BM_NET_V6=2001:db8::\n\n# \"overlay\" network used for UDP over UDP tunnel traffic\nreadonly OL_NET_V4=172.16.1.\nreadonly OL_NET_V6=2001:db8:1::\nreadonly NPROCS=`nproc`\n\ncleanup() {\n\tlocal ns\n\tlocal -r jobs=\"$(jobs -p)\"\n\t[ -n \"${jobs}\" ] && kill -1 ${jobs} 2>/dev/null\n\n\tfor ns in $NS_SRC $NS_DST; do\n\t\tip netns del $ns 2>/dev/null\n\tdone\n}\n\ntrap cleanup EXIT\n\ncreate_ns() {\n\tlocal net\n\tlocal ns\n\n\tfor ns in $NS_SRC $NS_DST; do\n\t\tip netns add $ns\n\t\tip -n $ns link set dev lo up\n\tdone\n\n\tip link add name veth$SRC type veth peer name veth$DST\n\n\tfor ns in $SRC $DST; do\n\t\tip link set dev veth$ns netns $BASE$ns\n\t\tip -n $BASE$ns link set dev veth$ns up\n\t\tip -n $BASE$ns addr add dev veth$ns $BM_NET_V4$ns/24\n\t\tip -n $BASE$ns addr add dev veth$ns $BM_NET_V6$ns/64 nodad\n\tdone\n\tip -n $NS_DST link set veth$DST xdp object ${BPF_FILE} section xdp 2>/dev/null\n}\n\ncreate_vxlan_endpoint() {\n\tlocal -r netns=$1\n\tlocal -r bm_dev=$2\n\tlocal -r bm_rem_addr=$3\n\tlocal -r vxlan_dev=$4\n\tlocal -r vxlan_id=$5\n\tlocal -r vxlan_port=4789\n\n\tip -n $netns link set dev $bm_dev up\n\tip -n $netns link add dev $vxlan_dev type vxlan id $vxlan_id \\\n\t\t\t\tdstport $vxlan_port remote $bm_rem_addr\n\tip -n $netns link set dev $vxlan_dev up\n}\n\ncreate_vxlan_pair() {\n\tlocal ns\n\n\tcreate_ns\n\n\tfor ns in $SRC $DST; do\n\t\t# note that 3 - $SRC == $DST and 3 - $DST == $SRC\n\t\tcreate_vxlan_endpoint $BASE$ns veth$ns $BM_NET_V4$((3 - $ns)) vxlan$ns 4\n\t\tip -n $BASE$ns addr add dev vxlan$ns $OL_NET_V4$ns/24\n\tdone\n\tfor ns in $SRC $DST; do\n\t\tcreate_vxlan_endpoint $BASE$ns veth$ns $BM_NET_V6$((3 - $ns)) vxlan6$ns 6\n\t\tip -n $BASE$ns addr add dev vxlan6$ns $OL_NET_V6$ns/24 nodad\n\tdone\n}\n\nis_ipv6() {\n\tif [[ $1 =~ .*:.* ]]; then\n\t\treturn 0\n\tfi\n\treturn 1\n}\n\nrun_test() {\n\tlocal -r msg=$1\n\tlocal -r dst=$2\n\tlocal -r pkts=$3\n\tlocal -r vxpkts=$4\n\tlocal bind=$5\n\tlocal rx_args=\"\"\n\tlocal rx_family=\"-4\"\n\tlocal family=-4\n\tlocal filter=IpInReceives\n\tlocal ipt=iptables\n\n\tprintf \"%-40s\" \"$msg\"\n\n\tif is_ipv6 $dst; then\n\t\t# rx program does not support '-6' and implies ipv6 usage by default\n\t\trx_family=\"\"\n\t\tfamily=-6\n\t\tfilter=Ip6InReceives\n\t\tipt=ip6tables\n\tfi\n\n\trx_args=\"$rx_family\"\n\t[ -n \"$bind\" ] && rx_args=\"$rx_args -b $bind\"\n\n\t# send a single GSO packet, segmented in 10 UDP frames.\n\t# Always expect 10 UDP frames on RX side as rx socket does\n\t# not enable GRO\n\tip netns exec $NS_DST $ipt -A INPUT -p udp --dport 4789\n\tip netns exec $NS_DST $ipt -A INPUT -p udp --dport 8000\n\tip netns exec $NS_DST ./udpgso_bench_rx -C 1000 -R 10 -n 10 -l 1300 $rx_args &\n\tlocal spid=$!\n\tsleep 0.1\n\tip netns exec $NS_SRC ./udpgso_bench_tx $family -M 1 -s 13000 -S 1300 -D $dst\n\tlocal retc=$?\n\twait $spid\n\tlocal rets=$?\n\tif [ ${rets} -ne 0 ] || [ ${retc} -ne 0 ]; then\n\t\techo \" fail client exit code $retc, server $rets\"\n\t\tret=1\n\t\treturn\n\tfi\n\n\tlocal rcv=`ip netns exec $NS_DST $ipt\"-save\" -c | grep 'dport 8000' | \\\n\t\t\t\t\t\t\t  sed -e 's/\\[//' -e 's/:.*//'`\n\tif [ $rcv != $pkts ]; then\n\t\techo \" fail - received $rcv packets, expected $pkts\"\n\t\tret=1\n\t\treturn\n\tfi\n\n\tlocal vxrcv=`ip netns exec $NS_DST $ipt\"-save\" -c | grep 'dport 4789' | \\\n\t\t\t\t\t\t\t    sed -e 's/\\[//' -e 's/:.*//'`\n\n\t# upper net can generate a little noise, allow some tolerance\n\tif [ $vxrcv -lt $vxpkts -o $vxrcv -gt $((vxpkts + 3)) ]; then\n\t\techo \" fail - received $vxrcv vxlan packets, expected $vxpkts\"\n\t\tret=1\n\t\treturn\n\tfi\n\techo \" ok\"\n}\n\nrun_bench() {\n\tlocal -r msg=$1\n\tlocal -r dst=$2\n\tlocal family=-4\n\n\tprintf \"%-40s\" \"$msg\"\n\tif [ $NPROCS -lt 2 ]; then\n\t\techo \" skip - needed 2 CPUs found $NPROCS\"\n\t\treturn\n\tfi\n\n\tis_ipv6 $dst && family=-6\n\n\t# bind the sender and the receiver to different CPUs to try\n\t# get reproducible results\n\tip netns exec $NS_DST bash -c \"echo 2 > /sys/class/net/veth$DST/queues/rx-0/rps_cpus\"\n\tip netns exec $NS_DST taskset 0x2 ./udpgso_bench_rx -C 1000 -R 10  &\n\tlocal spid=$!\n\tsleep 0.1\n\tip netns exec $NS_SRC taskset 0x1 ./udpgso_bench_tx $family -l 3 -S 1300 -D $dst\n\tlocal retc=$?\n\twait $spid\n\tlocal rets=$?\n\tif [ ${rets} -ne 0 ] || [ ${retc} -ne 0 ]; then\n\t\techo \" fail client exit code $retc, server $rets\"\n\t\tret=1\n\t\treturn\n\tfi\n}\n\nfor family in 4 6; do\n\tBM_NET=$BM_NET_V4\n\tOL_NET=$OL_NET_V4\n\tIPT=iptables\n\tSUFFIX=24\n\tVXDEV=vxlan\n\tPING=ping\n\n\tif [ $family = 6 ]; then\n\t\tBM_NET=$BM_NET_V6\n\t\tOL_NET=$OL_NET_V6\n\t\tSUFFIX=\"64 nodad\"\n\t\tVXDEV=vxlan6\n\t\tIPT=ip6tables\n\t\t# Use ping6 on systems where ping doesn't handle IPv6\n\t\tping -w 1 -c 1 ::1 > /dev/null 2>&1 || PING=\"ping6\"\n\tfi\n\n\techo \"IPv$family\"\n\n\tcreate_ns\n\trun_test \"No GRO\" $BM_NET$DST 10 0\n\tcleanup\n\n\tcreate_ns\n\tip netns exec $NS_DST ethtool -K veth$DST rx-gro-list on\n\trun_test \"GRO frag list\" $BM_NET$DST 1 0\n\tcleanup\n\n\t# UDP GRO fwd skips aggregation when find an udp socket with the GRO option\n\t# if there is an UDP tunnel in the running system, such lookup happen\n\t# take place.\n\t# use NAT to circumvent GRO FWD check\n\tcreate_ns\n\tip -n $NS_DST addr add dev veth$DST $BM_NET$DST_NAT/$SUFFIX\n\tip netns exec $NS_DST ethtool -K veth$DST rx-udp-gro-forwarding on\n\tip netns exec $NS_DST $IPT -t nat -I PREROUTING -d $BM_NET$DST_NAT \\\n\t\t\t\t\t-j DNAT --to-destination $BM_NET$DST\n\trun_test \"GRO fwd\" $BM_NET$DST_NAT 1 0 $BM_NET$DST\n\tcleanup\n\n\tcreate_ns\n\trun_bench \"UDP fwd perf\" $BM_NET$DST\n\tip netns exec $NS_DST ethtool -K veth$DST rx-udp-gro-forwarding on\n\trun_bench \"UDP GRO fwd perf\" $BM_NET$DST\n\tcleanup\n\n\tcreate_vxlan_pair\n\tip netns exec $NS_DST ethtool -K veth$DST rx-gro-list on\n\trun_test \"GRO frag list over UDP tunnel\" $OL_NET$DST 1 1\n\tcleanup\n\n\t# use NAT to circumvent GRO FWD check\n\tcreate_vxlan_pair\n\tip -n $NS_DST addr add dev $VXDEV$DST $OL_NET$DST_NAT/$SUFFIX\n\tip netns exec $NS_DST ethtool -K veth$DST rx-udp-gro-forwarding on\n\tip netns exec $NS_DST $IPT -t nat -I PREROUTING -d $OL_NET$DST_NAT \\\n\t\t\t\t\t-j DNAT --to-destination $OL_NET$DST\n\n\t# load arp cache before running the test to reduce the amount of\n\t# stray traffic on top of the UDP tunnel\n\tip netns exec $NS_SRC $PING -q -c 1 $OL_NET$DST_NAT >/dev/null\n\trun_test \"GRO fwd over UDP tunnel\" $OL_NET$DST_NAT 1 1 $OL_NET$DST\n\tcleanup\n\n\tcreate_vxlan_pair\n\trun_bench \"UDP tunnel fwd perf\" $OL_NET$DST\n\tip netns exec $NS_DST ethtool -K veth$DST rx-udp-gro-forwarding on\n\trun_bench \"UDP tunnel GRO fwd perf\" $OL_NET$DST\n\tcleanup\ndone\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}