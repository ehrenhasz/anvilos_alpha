{
  "module_name": "udpgso_bench_tx.c",
  "hash_id": "288f8dc3a339774d01d17700cc2674268983426f255d2e04ddb0e007bdaa19d2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/udpgso_bench_tx.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <linux/errqueue.h>\n#include <linux/net_tstamp.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netinet/ip6.h>\n#include <netinet/udp.h>\n#include <poll.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"../kselftest.h\"\n\n#ifndef ETH_MAX_MTU\n#define ETH_MAX_MTU 0xFFFFU\n#endif\n\n#ifndef UDP_SEGMENT\n#define UDP_SEGMENT\t\t103\n#endif\n\n#ifndef SO_ZEROCOPY\n#define SO_ZEROCOPY\t60\n#endif\n\n#ifndef SO_EE_ORIGIN_ZEROCOPY\n#define SO_EE_ORIGIN_ZEROCOPY 5\n#endif\n\n#ifndef MSG_ZEROCOPY\n#define MSG_ZEROCOPY\t0x4000000\n#endif\n\n#ifndef ENOTSUPP\n#define ENOTSUPP\t524\n#endif\n\n#define NUM_PKT\t\t100\n\nstatic bool\tcfg_cache_trash;\nstatic int\tcfg_cpu\t\t= -1;\nstatic int\tcfg_connected\t= true;\nstatic int\tcfg_family\t= PF_UNSPEC;\nstatic uint16_t\tcfg_mss;\nstatic int\tcfg_payload_len\t= (1472 * 42);\nstatic int\tcfg_port\t= 8000;\nstatic int\tcfg_runtime_ms\t= -1;\nstatic bool\tcfg_poll;\nstatic int\tcfg_poll_loop_timeout_ms = 2000;\nstatic bool\tcfg_segment;\nstatic bool\tcfg_sendmmsg;\nstatic bool\tcfg_tcp;\nstatic uint32_t\tcfg_tx_ts = SOF_TIMESTAMPING_TX_SOFTWARE;\nstatic bool\tcfg_tx_tstamp;\nstatic bool\tcfg_audit;\nstatic bool\tcfg_verbose;\nstatic bool\tcfg_zerocopy;\nstatic int\tcfg_msg_nr;\nstatic uint16_t\tcfg_gso_size;\nstatic unsigned long total_num_msgs;\nstatic unsigned long total_num_sends;\nstatic unsigned long stat_tx_ts;\nstatic unsigned long stat_tx_ts_errors;\nstatic unsigned long tstart;\nstatic unsigned long tend;\nstatic unsigned long stat_zcopies;\n\nstatic socklen_t cfg_alen;\nstatic struct sockaddr_storage cfg_dst_addr;\n\nstatic bool interrupted;\nstatic char buf[NUM_PKT][ETH_MAX_MTU];\n\nstatic void sigint_handler(int signum)\n{\n\tif (signum == SIGINT)\n\t\tinterrupted = true;\n}\n\nstatic unsigned long gettimeofday_ms(void)\n{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\treturn (tv.tv_sec * 1000) + (tv.tv_usec / 1000);\n}\n\nstatic int set_cpu(int cpu)\n{\n\tcpu_set_t mask;\n\n\tCPU_ZERO(&mask);\n\tCPU_SET(cpu, &mask);\n\tif (sched_setaffinity(0, sizeof(mask), &mask))\n\t\terror(1, 0, \"setaffinity %d\", cpu);\n\n\treturn 0;\n}\n\nstatic void setup_sockaddr(int domain, const char *str_addr, void *sockaddr)\n{\n\tstruct sockaddr_in6 *addr6 = (void *) sockaddr;\n\tstruct sockaddr_in *addr4 = (void *) sockaddr;\n\n\tswitch (domain) {\n\tcase PF_INET:\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_port = htons(cfg_port);\n\t\tif (inet_pton(AF_INET, str_addr, &(addr4->sin_addr)) != 1)\n\t\t\terror(1, 0, \"ipv4 parse error: %s\", str_addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_port = htons(cfg_port);\n\t\tif (inet_pton(AF_INET6, str_addr, &(addr6->sin6_addr)) != 1)\n\t\t\terror(1, 0, \"ipv6 parse error: %s\", str_addr);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"illegal domain\");\n\t}\n}\n\nstatic void flush_cmsg(struct cmsghdr *cmsg)\n{\n\tstruct sock_extended_err *err;\n\tstruct scm_timestamping *tss;\n\t__u32 lo;\n\t__u32 hi;\n\tint i;\n\n\tswitch (cmsg->cmsg_level) {\n\tcase SOL_SOCKET:\n\t\tif (cmsg->cmsg_type == SO_TIMESTAMPING) {\n\t\t\ti = (cfg_tx_ts == SOF_TIMESTAMPING_TX_HARDWARE) ? 2 : 0;\n\t\t\ttss = (struct scm_timestamping *)CMSG_DATA(cmsg);\n\t\t\tif (tss->ts[i].tv_sec == 0)\n\t\t\t\tstat_tx_ts_errors++;\n\t\t} else {\n\t\t\terror(1, 0, \"unknown SOL_SOCKET cmsg type=%u\\n\",\n\t\t\t      cmsg->cmsg_type);\n\t\t}\n\t\tbreak;\n\tcase SOL_IP:\n\tcase SOL_IPV6:\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase IP_RECVERR:\n\t\tcase IPV6_RECVERR:\n\t\t{\n\t\t\terr = (struct sock_extended_err *)CMSG_DATA(cmsg);\n\t\t\tswitch (err->ee_origin) {\n\t\t\tcase SO_EE_ORIGIN_TIMESTAMPING:\n\t\t\t\t \n\t\t\t\tstat_tx_ts++;\n\t\t\t\tbreak;\n\t\t\tcase SO_EE_ORIGIN_ICMP:\n\t\t\tcase SO_EE_ORIGIN_ICMP6:\n\t\t\t\tif (cfg_verbose)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"received ICMP error: type=%u, code=%u\\n\",\n\t\t\t\t\t\terr->ee_type, err->ee_code);\n\t\t\t\tbreak;\n\t\t\tcase SO_EE_ORIGIN_ZEROCOPY:\n\t\t\t{\n\t\t\t\tlo = err->ee_info;\n\t\t\t\thi = err->ee_data;\n\t\t\t\t \n\t\t\t\tstat_zcopies += hi - lo + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SO_EE_ORIGIN_LOCAL:\n\t\t\t\tif (cfg_verbose)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"received packet with local origin: %u\\n\",\n\t\t\t\t\t\terr->ee_origin);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror(0, 1, \"received packet with origin: %u\",\n\t\t\t\t      err->ee_origin);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\terror(0, 1, \"unknown IP msg type=%u\\n\",\n\t\t\t      cmsg->cmsg_type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror(0, 1, \"unknown cmsg level=%u\\n\",\n\t\t      cmsg->cmsg_level);\n\t}\n}\n\nstatic void flush_errqueue_recv(int fd)\n{\n\tchar control[CMSG_SPACE(sizeof(struct scm_timestamping)) +\n\t\t     CMSG_SPACE(sizeof(struct sock_extended_err)) +\n\t\t     CMSG_SPACE(sizeof(struct sockaddr_in6))] = {0};\n\tstruct msghdr msg = {0};\n\tstruct cmsghdr *cmsg;\n\tint ret;\n\n\twhile (1) {\n\t\tmsg.msg_control = control;\n\t\tmsg.msg_controllen = sizeof(control);\n\t\tret = recvmsg(fd, &msg, MSG_ERRQUEUE);\n\t\tif (ret == -1 && errno == EAGAIN)\n\t\t\tbreak;\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"errqueue\");\n\t\tif (msg.msg_flags != MSG_ERRQUEUE)\n\t\t\terror(1, 0, \"errqueue: flags 0x%x\\n\", msg.msg_flags);\n\t\tif (cfg_audit) {\n\t\t\tfor (cmsg = CMSG_FIRSTHDR(&msg);\n\t\t\t\t\tcmsg;\n\t\t\t\t\tcmsg = CMSG_NXTHDR(&msg, cmsg))\n\t\t\t\tflush_cmsg(cmsg);\n\t\t}\n\t\tmsg.msg_flags = 0;\n\t}\n}\n\nstatic void flush_errqueue(int fd, const bool do_poll,\n\t\t\t   unsigned long poll_timeout, const bool poll_err)\n{\n\tif (do_poll) {\n\t\tstruct pollfd fds = {0};\n\t\tint ret;\n\n\t\tfds.fd = fd;\n\t\tret = poll(&fds, 1, poll_timeout);\n\t\tif (ret == 0) {\n\t\t\tif ((cfg_verbose) && (poll_err))\n\t\t\t\tfprintf(stderr, \"poll timeout\\n\");\n\t\t} else if (ret < 0) {\n\t\t\terror(1, errno, \"poll\");\n\t\t}\n\t}\n\n\tflush_errqueue_recv(fd);\n}\n\nstatic void flush_errqueue_retry(int fd, unsigned long num_sends)\n{\n\tunsigned long tnow, tstop;\n\tbool first_try = true;\n\n\ttnow = gettimeofday_ms();\n\ttstop = tnow + cfg_poll_loop_timeout_ms;\n\tdo {\n\t\tflush_errqueue(fd, true, tstop - tnow, first_try);\n\t\tfirst_try = false;\n\t\ttnow = gettimeofday_ms();\n\t} while ((stat_zcopies != num_sends) && (tnow < tstop));\n}\n\nstatic int send_tcp(int fd, char *data)\n{\n\tint ret, done = 0, count = 0;\n\n\twhile (done < cfg_payload_len) {\n\t\tret = send(fd, data + done, cfg_payload_len - done,\n\t\t\t   cfg_zerocopy ? MSG_ZEROCOPY : 0);\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"write\");\n\n\t\tdone += ret;\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic int send_udp(int fd, char *data)\n{\n\tint ret, total_len, len, count = 0;\n\n\ttotal_len = cfg_payload_len;\n\n\twhile (total_len) {\n\t\tlen = total_len < cfg_mss ? total_len : cfg_mss;\n\n\t\tret = sendto(fd, data, len, cfg_zerocopy ? MSG_ZEROCOPY : 0,\n\t\t\t     cfg_connected ? NULL : (void *)&cfg_dst_addr,\n\t\t\t     cfg_connected ? 0 : cfg_alen);\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"write\");\n\t\tif (ret != len)\n\t\t\terror(1, errno, \"write: %uB != %uB\\n\", ret, len);\n\n\t\ttotal_len -= len;\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic void send_ts_cmsg(struct cmsghdr *cm)\n{\n\tuint32_t *valp;\n\n\tcm->cmsg_level = SOL_SOCKET;\n\tcm->cmsg_type = SO_TIMESTAMPING;\n\tcm->cmsg_len = CMSG_LEN(sizeof(cfg_tx_ts));\n\tvalp = (void *)CMSG_DATA(cm);\n\t*valp = cfg_tx_ts;\n}\n\nstatic int send_udp_sendmmsg(int fd, char *data)\n{\n\tchar control[CMSG_SPACE(sizeof(cfg_tx_ts))] = {0};\n\tconst int max_nr_msg = ETH_MAX_MTU / ETH_DATA_LEN;\n\tstruct mmsghdr mmsgs[max_nr_msg];\n\tstruct iovec iov[max_nr_msg];\n\tunsigned int off = 0, left;\n\tsize_t msg_controllen = 0;\n\tint i = 0, ret;\n\n\tmemset(mmsgs, 0, sizeof(mmsgs));\n\n\tif (cfg_tx_tstamp) {\n\t\tstruct msghdr msg = {0};\n\t\tstruct cmsghdr *cmsg;\n\n\t\tmsg.msg_control = control;\n\t\tmsg.msg_controllen = sizeof(control);\n\t\tcmsg = CMSG_FIRSTHDR(&msg);\n\t\tsend_ts_cmsg(cmsg);\n\t\tmsg_controllen += CMSG_SPACE(sizeof(cfg_tx_ts));\n\t}\n\n\tleft = cfg_payload_len;\n\twhile (left) {\n\t\tif (i == max_nr_msg)\n\t\t\terror(1, 0, \"sendmmsg: exceeds max_nr_msg\");\n\n\t\tiov[i].iov_base = data + off;\n\t\tiov[i].iov_len = cfg_mss < left ? cfg_mss : left;\n\n\t\tmmsgs[i].msg_hdr.msg_iov = iov + i;\n\t\tmmsgs[i].msg_hdr.msg_iovlen = 1;\n\n\t\tmmsgs[i].msg_hdr.msg_name = (void *)&cfg_dst_addr;\n\t\tmmsgs[i].msg_hdr.msg_namelen = cfg_alen;\n\t\tif (msg_controllen) {\n\t\t\tmmsgs[i].msg_hdr.msg_control = control;\n\t\t\tmmsgs[i].msg_hdr.msg_controllen = msg_controllen;\n\t\t}\n\n\t\toff += iov[i].iov_len;\n\t\tleft -= iov[i].iov_len;\n\t\ti++;\n\t}\n\n\tret = sendmmsg(fd, mmsgs, i, cfg_zerocopy ? MSG_ZEROCOPY : 0);\n\tif (ret == -1)\n\t\terror(1, errno, \"sendmmsg\");\n\n\treturn ret;\n}\n\nstatic void send_udp_segment_cmsg(struct cmsghdr *cm)\n{\n\tuint16_t *valp;\n\n\tcm->cmsg_level = SOL_UDP;\n\tcm->cmsg_type = UDP_SEGMENT;\n\tcm->cmsg_len = CMSG_LEN(sizeof(cfg_gso_size));\n\tvalp = (void *)CMSG_DATA(cm);\n\t*valp = cfg_gso_size;\n}\n\nstatic int send_udp_segment(int fd, char *data)\n{\n\tchar control[CMSG_SPACE(sizeof(cfg_gso_size)) +\n\t\t     CMSG_SPACE(sizeof(cfg_tx_ts))] = {0};\n\tstruct msghdr msg = {0};\n\tstruct iovec iov = {0};\n\tsize_t msg_controllen;\n\tstruct cmsghdr *cmsg;\n\tint ret;\n\n\tiov.iov_base = data;\n\tiov.iov_len = cfg_payload_len;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tmsg.msg_control = control;\n\tmsg.msg_controllen = sizeof(control);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tsend_udp_segment_cmsg(cmsg);\n\tmsg_controllen = CMSG_SPACE(sizeof(cfg_mss));\n\tif (cfg_tx_tstamp) {\n\t\tcmsg = CMSG_NXTHDR(&msg, cmsg);\n\t\tsend_ts_cmsg(cmsg);\n\t\tmsg_controllen += CMSG_SPACE(sizeof(cfg_tx_ts));\n\t}\n\n\tmsg.msg_controllen = msg_controllen;\n\tmsg.msg_name = (void *)&cfg_dst_addr;\n\tmsg.msg_namelen = cfg_alen;\n\n\tret = sendmsg(fd, &msg, cfg_zerocopy ? MSG_ZEROCOPY : 0);\n\tif (ret == -1)\n\t\terror(1, errno, \"sendmsg\");\n\tif (ret != iov.iov_len)\n\t\terror(1, 0, \"sendmsg: %u != %llu\\n\", ret,\n\t\t\t(unsigned long long)iov.iov_len);\n\n\treturn 1;\n}\n\nstatic void usage(const char *filepath)\n{\n\terror(1, 0, \"Usage: %s [-46acmHPtTuvz] [-C cpu] [-D dst ip] [-l secs] \"\n\t\t    \"[-L secs] [-M messagenr] [-p port] [-s sendsize] [-S gsosize]\",\n\t\t    filepath);\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tconst char *bind_addr = NULL;\n\tint max_len, hdrlen;\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"46acC:D:Hl:L:mM:p:s:PS:tTuvz\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tif (cfg_family != PF_UNSPEC)\n\t\t\t\terror(1, 0, \"Pass one of -4 or -6\");\n\t\t\tcfg_family = PF_INET;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tif (cfg_family != PF_UNSPEC)\n\t\t\t\terror(1, 0, \"Pass one of -4 or -6\");\n\t\t\tcfg_family = PF_INET6;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in6);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tcfg_audit = true;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcfg_cache_trash = true;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcfg_cpu = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tbind_addr = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tcfg_runtime_ms = strtoul(optarg, NULL, 10) * 1000;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tcfg_poll_loop_timeout_ms = strtoul(optarg, NULL, 10) * 1000;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcfg_sendmmsg = true;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tcfg_msg_nr = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcfg_port = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcfg_poll = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcfg_payload_len = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tcfg_gso_size = strtoul(optarg, NULL, 0);\n\t\t\tcfg_segment = true;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tcfg_tx_ts = SOF_TIMESTAMPING_TX_HARDWARE;\n\t\t\tcfg_tx_tstamp = true;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_tcp = true;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tcfg_tx_tstamp = true;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tcfg_connected = false;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcfg_verbose = true;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tcfg_zerocopy = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (!bind_addr)\n\t\tbind_addr = cfg_family == PF_INET6 ? \"::\" : \"0.0.0.0\";\n\n\tsetup_sockaddr(cfg_family, bind_addr, &cfg_dst_addr);\n\n\tif (optind != argc)\n\t\tusage(argv[0]);\n\n\tif (cfg_family == PF_UNSPEC)\n\t\terror(1, 0, \"must pass one of -4 or -6\");\n\tif (cfg_tcp && !cfg_connected)\n\t\terror(1, 0, \"connectionless tcp makes no sense\");\n\tif (cfg_segment && cfg_sendmmsg)\n\t\terror(1, 0, \"cannot combine segment offload and sendmmsg\");\n\tif (cfg_tx_tstamp && !(cfg_segment || cfg_sendmmsg))\n\t\terror(1, 0, \"Options -T and -H require either -S or -m option\");\n\n\tif (cfg_family == PF_INET)\n\t\thdrlen = sizeof(struct iphdr) + sizeof(struct udphdr);\n\telse\n\t\thdrlen = sizeof(struct ip6_hdr) + sizeof(struct udphdr);\n\n\tcfg_mss = ETH_DATA_LEN - hdrlen;\n\tmax_len = ETH_MAX_MTU - hdrlen;\n\tif (!cfg_gso_size)\n\t\tcfg_gso_size = cfg_mss;\n\n\tif (cfg_payload_len > max_len)\n\t\terror(1, 0, \"payload length %u exceeds max %u\",\n\t\t      cfg_payload_len, max_len);\n}\n\nstatic void set_pmtu_discover(int fd, bool is_ipv4)\n{\n\tint level, name, val;\n\n\tif (is_ipv4) {\n\t\tlevel\t= SOL_IP;\n\t\tname\t= IP_MTU_DISCOVER;\n\t\tval\t= IP_PMTUDISC_DO;\n\t} else {\n\t\tlevel\t= SOL_IPV6;\n\t\tname\t= IPV6_MTU_DISCOVER;\n\t\tval\t= IPV6_PMTUDISC_DO;\n\t}\n\n\tif (setsockopt(fd, level, name, &val, sizeof(val)))\n\t\terror(1, errno, \"setsockopt path mtu\");\n}\n\nstatic void set_tx_timestamping(int fd)\n{\n\tint val = SOF_TIMESTAMPING_OPT_CMSG | SOF_TIMESTAMPING_OPT_ID |\n\t\t\tSOF_TIMESTAMPING_OPT_TSONLY;\n\n\tif (cfg_tx_ts == SOF_TIMESTAMPING_TX_SOFTWARE)\n\t\tval |= SOF_TIMESTAMPING_SOFTWARE;\n\telse\n\t\tval |= SOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_TIMESTAMPING, &val, sizeof(val)))\n\t\terror(1, errno, \"setsockopt tx timestamping\");\n}\n\nstatic void print_audit_report(unsigned long num_msgs, unsigned long num_sends)\n{\n\tunsigned long tdelta;\n\n\ttdelta = tend - tstart;\n\tif (!tdelta)\n\t\treturn;\n\n\tfprintf(stderr, \"Summary over %lu.%03lu seconds...\\n\",\n\t\t\ttdelta / 1000, tdelta % 1000);\n\tfprintf(stderr,\n\t\t\"sum %s tx: %6lu MB/s %10lu calls (%lu/s) %10lu msgs (%lu/s)\\n\",\n\t\tcfg_tcp ? \"tcp\" : \"udp\",\n\t\t((num_msgs * cfg_payload_len) >> 10) / tdelta,\n\t\tnum_sends, num_sends * 1000 / tdelta,\n\t\tnum_msgs, num_msgs * 1000 / tdelta);\n\n\tif (cfg_tx_tstamp) {\n\t\tif (stat_tx_ts_errors)\n\t\t\terror(1, 0,\n\t\t\t      \"Expected clean TX Timestamps: %9lu msgs received %6lu errors\",\n\t\t\t      stat_tx_ts, stat_tx_ts_errors);\n\t\tif (stat_tx_ts != num_sends)\n\t\t\terror(1, 0,\n\t\t\t      \"Unexpected number of TX Timestamps: %9lu expected %9lu received\",\n\t\t\t      num_sends, stat_tx_ts);\n\t\tfprintf(stderr,\n\t\t\t\"Tx Timestamps: %19lu received %17lu errors\\n\",\n\t\t\tstat_tx_ts, stat_tx_ts_errors);\n\t}\n\n\tif (cfg_zerocopy) {\n\t\tif (stat_zcopies != num_sends)\n\t\t\terror(1, 0, \"Unexpected number of Zerocopy completions: %9lu expected %9lu received\",\n\t\t\t      num_sends, stat_zcopies);\n\t\tfprintf(stderr,\n\t\t\t\"Zerocopy acks: %19lu\\n\",\n\t\t\tstat_zcopies);\n\t}\n}\n\nstatic void print_report(unsigned long num_msgs, unsigned long num_sends)\n{\n\tfprintf(stderr,\n\t\t\"%s tx: %6lu MB/s %8lu calls/s %6lu msg/s\\n\",\n\t\tcfg_tcp ? \"tcp\" : \"udp\",\n\t\t(num_msgs * cfg_payload_len) >> 20,\n\t\tnum_sends, num_msgs);\n\n\tif (cfg_audit) {\n\t\ttotal_num_msgs += num_msgs;\n\t\ttotal_num_sends += num_sends;\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tunsigned long num_msgs, num_sends;\n\tunsigned long tnow, treport, tstop;\n\tint fd, i, val, ret;\n\n\tparse_opts(argc, argv);\n\n\tif (cfg_cpu > 0)\n\t\tset_cpu(cfg_cpu);\n\n\tfor (i = 0; i < sizeof(buf[0]); i++)\n\t\tbuf[0][i] = 'a' + (i % 26);\n\tfor (i = 1; i < NUM_PKT; i++)\n\t\tmemcpy(buf[i], buf[0], sizeof(buf[0]));\n\n\tsignal(SIGINT, sigint_handler);\n\n\tfd = socket(cfg_family, cfg_tcp ? SOCK_STREAM : SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket\");\n\n\tif (cfg_zerocopy) {\n\t\tval = 1;\n\n\t\tret = setsockopt(fd, SOL_SOCKET, SO_ZEROCOPY,\n\t\t\t\t &val, sizeof(val));\n\t\tif (ret) {\n\t\t\tif (errno == ENOPROTOOPT || errno == ENOTSUPP) {\n\t\t\t\tfprintf(stderr, \"SO_ZEROCOPY not supported\");\n\t\t\t\texit(KSFT_SKIP);\n\t\t\t}\n\t\t\terror(1, errno, \"setsockopt zerocopy\");\n\t\t}\n\t}\n\n\tif (cfg_connected &&\n\t    connect(fd, (void *)&cfg_dst_addr, cfg_alen))\n\t\terror(1, errno, \"connect\");\n\n\tif (cfg_segment)\n\t\tset_pmtu_discover(fd, cfg_family == PF_INET);\n\n\tif (cfg_tx_tstamp)\n\t\tset_tx_timestamping(fd);\n\n\tnum_msgs = num_sends = 0;\n\ttnow = gettimeofday_ms();\n\ttstart = tnow;\n\ttend = tnow;\n\ttstop = tnow + cfg_runtime_ms;\n\ttreport = tnow + 1000;\n\n\ti = 0;\n\tdo {\n\t\tif (cfg_tcp)\n\t\t\tnum_sends += send_tcp(fd, buf[i]);\n\t\telse if (cfg_segment)\n\t\t\tnum_sends += send_udp_segment(fd, buf[i]);\n\t\telse if (cfg_sendmmsg)\n\t\t\tnum_sends += send_udp_sendmmsg(fd, buf[i]);\n\t\telse\n\t\t\tnum_sends += send_udp(fd, buf[i]);\n\t\tnum_msgs++;\n\t\tif ((cfg_zerocopy && ((num_msgs & 0xF) == 0)) || cfg_tx_tstamp)\n\t\t\tflush_errqueue(fd, cfg_poll, 500, true);\n\n\t\tif (cfg_msg_nr && num_msgs >= cfg_msg_nr)\n\t\t\tbreak;\n\n\t\ttnow = gettimeofday_ms();\n\t\tif (tnow >= treport) {\n\t\t\tprint_report(num_msgs, num_sends);\n\t\t\tnum_msgs = num_sends = 0;\n\t\t\ttreport = tnow + 1000;\n\t\t}\n\n\t\t \n\t\tif (cfg_cache_trash)\n\t\t\ti = ++i < NUM_PKT ? i : 0;\n\n\t} while (!interrupted && (cfg_runtime_ms == -1 || tnow < tstop));\n\n\tif (cfg_zerocopy || cfg_tx_tstamp)\n\t\tflush_errqueue_retry(fd, num_sends);\n\n\tif (close(fd))\n\t\terror(1, errno, \"close\");\n\n\tif (cfg_audit) {\n\t\ttend = tnow;\n\t\ttotal_num_msgs += num_msgs;\n\t\ttotal_num_sends += num_sends;\n\t\tprint_audit_report(total_num_msgs, total_num_sends);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}