{
  "module_name": "icmp.sh",
  "hash_id": "01f82fd969b5c9c523d8d2c9068efd3f22158327b36388ba72a8d73a12ee2b99",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/icmp.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# Test for checking ICMP response with dummy address instead of 0.0.0.0.\n# Sets up two namespaces like:\n# +----------------------+                          +--------------------+\n# | ns1                  |    v4-via-v6 routes:     | ns2                |\n# |                      |                  '       |                    |\n# |             +--------+   -> 172.16.1.0/24 ->    +--------+           |\n# |             | veth0  +--------------------------+  veth0 |           |\n# |             +--------+   <- 172.16.0.0/24 <-    +--------+           |\n# |           172.16.0.1 |                          | 2001:db8:1::2/64   |\n# |     2001:db8:1::2/64 |                          |                    |\n# +----------------------+                          +--------------------+\n#\n# And then tries to ping 172.16.1.1 from ns1. This results in a \"net\n# unreachable\" message being sent from ns2, but there is no IPv4 address set in\n# that address space, so the kernel should substitute the dummy address\n# 192.0.0.8 defined in RFC7600.\n\nNS1=ns1\nNS2=ns2\nH1_IP=172.16.0.1/32\nH1_IP6=2001:db8:1::1\nRT1=172.16.1.0/24\nPINGADDR=172.16.1.1\nRT2=172.16.0.0/24\nH2_IP6=2001:db8:1::2\n\nTMPFILE=$(mktemp)\n\ncleanup()\n{\n    rm -f \"$TMPFILE\"\n    ip netns del $NS1\n    ip netns del $NS2\n}\n\ntrap cleanup EXIT\n\n# Namespaces\nip netns add $NS1\nip netns add $NS2\n\n# Connectivity\nip -netns $NS1 link add veth0 type veth peer name veth0 netns $NS2\nip -netns $NS1 link set dev veth0 up\nip -netns $NS2 link set dev veth0 up\nip -netns $NS1 addr add $H1_IP dev veth0\nip -netns $NS1 addr add $H1_IP6/64 dev veth0 nodad\nip -netns $NS2 addr add $H2_IP6/64 dev veth0 nodad\nip -netns $NS1 route add $RT1 via inet6 $H2_IP6\nip -netns $NS2 route add $RT2 via inet6 $H1_IP6\n\n# Make sure ns2 will respond with ICMP unreachable\nip netns exec $NS2 sysctl -qw net.ipv4.icmp_ratelimit=0 net.ipv4.ip_forward=1\n\n# Run the test - a ping runs in the background, and we capture ICMP responses\n# with tcpdump; -c 1 means it should exit on the first ping, but add a timeout\n# in case something goes wrong\nip netns exec $NS1 ping -w 3 -i 0.5 $PINGADDR >/dev/null &\nip netns exec $NS1 timeout 10 tcpdump -tpni veth0 -c 1 'icmp and icmp[icmptype] != icmp-echo' > $TMPFILE 2>/dev/null\n\n# Parse response and check for dummy address\n# tcpdump output looks like:\n# IP 192.0.0.8 > 172.16.0.1: ICMP net 172.16.1.1 unreachable, length 92\nRESP_IP=$(awk '{print $2}' < $TMPFILE)\nif [[ \"$RESP_IP\" != \"192.0.0.8\" ]]; then\n    echo \"FAIL - got ICMP response from $RESP_IP, should be 192.0.0.8\"\n    exit 1\nelse\n    echo \"OK\"\n    exit 0\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}