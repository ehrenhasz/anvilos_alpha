{
  "module_name": "tcp_mmap.c",
  "hash_id": "98c720b79a7e5a319939536962937345e537b78c5238cd0833ee511a398be478",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/tcp_mmap.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <pthread.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <error.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <time.h>\n#include <sys/time.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <poll.h>\n#include <linux/tcp.h>\n#include <assert.h>\n#include <openssl/pem.h>\n\n#ifndef MSG_ZEROCOPY\n#define MSG_ZEROCOPY    0x4000000\n#endif\n\n#ifndef min\n#define min(a, b)  ((a) < (b) ? (a) : (b))\n#endif\n\n#define FILE_SZ (1ULL << 35)\nstatic int cfg_family = AF_INET6;\nstatic socklen_t cfg_alen = sizeof(struct sockaddr_in6);\nstatic int cfg_port = 8787;\n\nstatic int rcvbuf;  \nstatic int sndbuf;  \nstatic int zflg;  \nstatic int xflg;  \nstatic int keepflag;  \nstatic int integrity;  \n\nstatic size_t chunk_size  = 512*1024;\n\nstatic size_t map_align;\n\nunsigned long htotal;\nunsigned int digest_len;\n\nstatic inline void prefetch(const void *x)\n{\n#if defined(__x86_64__)\n\tasm volatile(\"prefetcht0 %P0\" : : \"m\" (*(const char *)x));\n#endif\n}\n\nvoid hash_zone(void *zone, unsigned int length)\n{\n\tunsigned long temp = htotal;\n\n\twhile (length >= 8*sizeof(long)) {\n\t\tprefetch(zone + 384);\n\t\ttemp ^= *(unsigned long *)zone;\n\t\ttemp ^= *(unsigned long *)(zone + sizeof(long));\n\t\ttemp ^= *(unsigned long *)(zone + 2*sizeof(long));\n\t\ttemp ^= *(unsigned long *)(zone + 3*sizeof(long));\n\t\ttemp ^= *(unsigned long *)(zone + 4*sizeof(long));\n\t\ttemp ^= *(unsigned long *)(zone + 5*sizeof(long));\n\t\ttemp ^= *(unsigned long *)(zone + 6*sizeof(long));\n\t\ttemp ^= *(unsigned long *)(zone + 7*sizeof(long));\n\t\tzone += 8*sizeof(long);\n\t\tlength -= 8*sizeof(long);\n\t}\n\twhile (length >= 1) {\n\t\ttemp ^= *(unsigned char *)zone;\n\t\tzone += 1;\n\t\tlength--;\n\t}\n\thtotal = temp;\n}\n\n#define ALIGN_UP(x, align_to)\t(((x) + ((align_to)-1)) & ~((align_to)-1))\n#define ALIGN_PTR_UP(p, ptr_align_to)\t((typeof(p))ALIGN_UP((unsigned long)(p), ptr_align_to))\n\n\nstatic void *mmap_large_buffer(size_t need, size_t *allocated)\n{\n\tvoid *buffer;\n\tsize_t sz;\n\n\t \n\tsz = ALIGN_UP(need, map_align);\n\tbuffer = mmap(NULL, sz, PROT_READ | PROT_WRITE,\n\t\t      MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB, -1, 0);\n\n\tif (buffer == (void *)-1) {\n\t\tsz = need;\n\t\tbuffer = mmap(NULL, sz, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE,\n\t\t\t      -1, 0);\n\t\tif (buffer != (void *)-1)\n\t\t\tfprintf(stderr, \"MAP_HUGETLB attempt failed, look at /sys/kernel/mm/hugepages for optimal performance\\n\");\n\t}\n\t*allocated = sz;\n\treturn buffer;\n}\n\nstatic uint32_t tcp_info_get_rcv_mss(int fd)\n{\n\tsocklen_t sz = sizeof(struct tcp_info);\n\tstruct tcp_info info;\n\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_INFO, &info, &sz)) {\n\t\tfprintf(stderr, \"Error fetching TCP_INFO\\n\");\n\t\treturn 0;\n\t}\n\n\treturn info.tcpi_rcv_mss;\n}\n\nvoid *child_thread(void *arg)\n{\n\tunsigned char digest[SHA256_DIGEST_LENGTH];\n\tunsigned long total_mmap = 0, total = 0;\n\tstruct tcp_zerocopy_receive zc;\n\tunsigned char *buffer = NULL;\n\tunsigned long delta_usec;\n\tEVP_MD_CTX *ctx = NULL;\n\tint flags = MAP_SHARED;\n\tstruct timeval t0, t1;\n\tvoid *raddr = NULL;\n\tvoid *addr = NULL;\n\tdouble throughput;\n\tstruct rusage ru;\n\tsize_t buffer_sz;\n\tint lu, fd;\n\n\tfd = (int)(unsigned long)arg;\n\n\tgettimeofday(&t0, NULL);\n\n\tfcntl(fd, F_SETFL, O_NDELAY);\n\tbuffer = mmap_large_buffer(chunk_size, &buffer_sz);\n\tif (buffer == (void *)-1) {\n\t\tperror(\"mmap\");\n\t\tgoto error;\n\t}\n\tif (zflg) {\n\t\traddr = mmap(NULL, chunk_size + map_align, PROT_READ, flags, fd, 0);\n\t\tif (raddr == (void *)-1) {\n\t\t\tperror(\"mmap\");\n\t\t\tzflg = 0;\n\t\t} else {\n\t\t\taddr = ALIGN_PTR_UP(raddr, map_align);\n\t\t}\n\t}\n\tif (integrity) {\n\t\tctx = EVP_MD_CTX_new();\n\t\tif (!ctx) {\n\t\t\tperror(\"cannot enable SHA computing\");\n\t\t\tgoto error;\n\t\t}\n\t\tEVP_DigestInit_ex(ctx, EVP_sha256(), NULL);\n\t}\n\twhile (1) {\n\t\tstruct pollfd pfd = { .fd = fd, .events = POLLIN, };\n\t\tint sub;\n\n\t\tpoll(&pfd, 1, 10000);\n\t\tif (zflg) {\n\t\t\tsocklen_t zc_len = sizeof(zc);\n\t\t\tint res;\n\n\t\t\tmemset(&zc, 0, sizeof(zc));\n\t\t\tzc.address = (__u64)((unsigned long)addr);\n\t\t\tzc.length = min(chunk_size, FILE_SZ - total);\n\n\t\t\tres = getsockopt(fd, IPPROTO_TCP, TCP_ZEROCOPY_RECEIVE,\n\t\t\t\t\t &zc, &zc_len);\n\t\t\tif (res == -1)\n\t\t\t\tbreak;\n\n\t\t\tif (zc.length) {\n\t\t\t\tassert(zc.length <= chunk_size);\n\t\t\t\tif (integrity)\n\t\t\t\t\tEVP_DigestUpdate(ctx, addr, zc.length);\n\t\t\t\ttotal_mmap += zc.length;\n\t\t\t\tif (xflg)\n\t\t\t\t\thash_zone(addr, zc.length);\n\t\t\t\t \n\t\t\t\tmadvise(addr, zc.length, MADV_DONTNEED);\n\t\t\t\ttotal += zc.length;\n\t\t\t}\n\t\t\tif (zc.recv_skip_hint) {\n\t\t\t\tassert(zc.recv_skip_hint <= chunk_size);\n\t\t\t\tlu = read(fd, buffer, min(zc.recv_skip_hint,\n\t\t\t\t\t\t\t  FILE_SZ - total));\n\t\t\t\tif (lu > 0) {\n\t\t\t\t\tif (integrity)\n\t\t\t\t\t\tEVP_DigestUpdate(ctx, buffer, lu);\n\t\t\t\t\tif (xflg)\n\t\t\t\t\t\thash_zone(buffer, lu);\n\t\t\t\t\ttotal += lu;\n\t\t\t\t}\n\t\t\t\tif (lu == 0)\n\t\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tsub = 0;\n\t\twhile (sub < chunk_size) {\n\t\t\tlu = read(fd, buffer + sub, min(chunk_size - sub,\n\t\t\t\t\t\t\tFILE_SZ - total));\n\t\t\tif (lu == 0)\n\t\t\t\tgoto end;\n\t\t\tif (lu < 0)\n\t\t\t\tbreak;\n\t\t\tif (integrity)\n\t\t\t\tEVP_DigestUpdate(ctx, buffer + sub, lu);\n\t\t\tif (xflg)\n\t\t\t\thash_zone(buffer + sub, lu);\n\t\t\ttotal += lu;\n\t\t\tsub += lu;\n\t\t}\n\t}\nend:\n\tgettimeofday(&t1, NULL);\n\tdelta_usec = (t1.tv_sec - t0.tv_sec) * 1000000 + t1.tv_usec - t0.tv_usec;\n\n\tif (integrity) {\n\t\tfcntl(fd, F_SETFL, 0);\n\t\tEVP_DigestFinal_ex(ctx, digest, &digest_len);\n\t\tlu = read(fd, buffer, SHA256_DIGEST_LENGTH);\n\t\tif (lu != SHA256_DIGEST_LENGTH)\n\t\t\tperror(\"Error: Cannot read SHA256\\n\");\n\n\t\tif (memcmp(digest, buffer,\n\t\t\t   SHA256_DIGEST_LENGTH))\n\t\t\tfprintf(stderr, \"Error: SHA256 of the data is not right\\n\");\n\t\telse\n\t\t\tprintf(\"\\nSHA256 is correct\\n\");\n\t}\n\n\tthroughput = 0;\n\tif (delta_usec)\n\t\tthroughput = total * 8.0 / (double)delta_usec / 1000.0;\n\tgetrusage(RUSAGE_THREAD, &ru);\n\tif (total > 1024*1024) {\n\t\tunsigned long total_usec;\n\t\tunsigned long mb = total >> 20;\n\t\ttotal_usec = 1000000*ru.ru_utime.tv_sec + ru.ru_utime.tv_usec +\n\t\t\t     1000000*ru.ru_stime.tv_sec + ru.ru_stime.tv_usec;\n\t\tprintf(\"received %lg MB (%lg %% mmap'ed) in %lg s, %lg Gbit\\n\"\n\t\t       \"  cpu usage user:%lg sys:%lg, %lg usec per MB, %lu c-switches, rcv_mss %u\\n\",\n\t\t\t\ttotal / (1024.0 * 1024.0),\n\t\t\t\t100.0*total_mmap/total,\n\t\t\t\t(double)delta_usec / 1000000.0,\n\t\t\t\tthroughput,\n\t\t\t\t(double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000.0,\n\t\t\t\t(double)ru.ru_stime.tv_sec + (double)ru.ru_stime.tv_usec / 1000000.0,\n\t\t\t\t(double)total_usec/mb,\n\t\t\t\tru.ru_nvcsw,\n\t\t\t\ttcp_info_get_rcv_mss(fd));\n\t}\nerror:\n\tmunmap(buffer, buffer_sz);\n\tclose(fd);\n\tif (zflg)\n\t\tmunmap(raddr, chunk_size + map_align);\n\tpthread_exit(0);\n}\n\nstatic void apply_rcvsnd_buf(int fd)\n{\n\tif (rcvbuf && setsockopt(fd, SOL_SOCKET,\n\t\t\t\t SO_RCVBUF, &rcvbuf, sizeof(rcvbuf)) == -1) {\n\t\tperror(\"setsockopt SO_RCVBUF\");\n\t}\n\n\tif (sndbuf && setsockopt(fd, SOL_SOCKET,\n\t\t\t\t SO_SNDBUF, &sndbuf, sizeof(sndbuf)) == -1) {\n\t\tperror(\"setsockopt SO_SNDBUF\");\n\t}\n}\n\n\nstatic void setup_sockaddr(int domain, const char *str_addr,\n\t\t\t   struct sockaddr_storage *sockaddr)\n{\n\tstruct sockaddr_in6 *addr6 = (void *) sockaddr;\n\tstruct sockaddr_in *addr4 = (void *) sockaddr;\n\n\tswitch (domain) {\n\tcase PF_INET:\n\t\tmemset(addr4, 0, sizeof(*addr4));\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_port = htons(cfg_port);\n\t\tif (str_addr &&\n\t\t    inet_pton(AF_INET, str_addr, &(addr4->sin_addr)) != 1)\n\t\t\terror(1, 0, \"ipv4 parse error: %s\", str_addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tmemset(addr6, 0, sizeof(*addr6));\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_port = htons(cfg_port);\n\t\tif (str_addr &&\n\t\t    inet_pton(AF_INET6, str_addr, &(addr6->sin6_addr)) != 1)\n\t\t\terror(1, 0, \"ipv6 parse error: %s\", str_addr);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"illegal domain\");\n\t}\n}\n\nstatic void do_accept(int fdlisten)\n{\n\tpthread_attr_t attr;\n\tint rcvlowat;\n\n\tpthread_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\trcvlowat = chunk_size;\n\tif (setsockopt(fdlisten, SOL_SOCKET, SO_RCVLOWAT,\n\t\t       &rcvlowat, sizeof(rcvlowat)) == -1) {\n\t\tperror(\"setsockopt SO_RCVLOWAT\");\n\t}\n\n\tapply_rcvsnd_buf(fdlisten);\n\n\twhile (1) {\n\t\tstruct sockaddr_in addr;\n\t\tsocklen_t addrlen = sizeof(addr);\n\t\tpthread_t th;\n\t\tint fd, res;\n\n\t\tfd = accept(fdlisten, (struct sockaddr *)&addr, &addrlen);\n\t\tif (fd == -1) {\n\t\t\tperror(\"accept\");\n\t\t\tcontinue;\n\t\t}\n\t\tres = pthread_create(&th, &attr, child_thread,\n\t\t\t\t     (void *)(unsigned long)fd);\n\t\tif (res) {\n\t\t\terrno = res;\n\t\t\tperror(\"pthread_create\");\n\t\t\tclose(fd);\n\t\t}\n\t}\n}\n\n \nstatic unsigned long default_huge_page_size(void)\n{\n\tFILE *f = fopen(\"/proc/meminfo\", \"r\");\n\tunsigned long hps = 0;\n\tsize_t linelen = 0;\n\tchar *line = NULL;\n\n\tif (!f)\n\t\treturn 0;\n\twhile (getline(&line, &linelen, f) > 0) {\n\t\tif (sscanf(line, \"Hugepagesize:       %lu kB\", &hps) == 1) {\n\t\t\thps <<= 10;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(line);\n\tfclose(f);\n\treturn hps;\n}\n\nstatic void randomize(void *target, size_t count)\n{\n\tstatic int urandom = -1;\n\tssize_t got;\n\n\turandom = open(\"/dev/urandom\", O_RDONLY);\n\tif (urandom < 0) {\n\t\tperror(\"open /dev/urandom\");\n\t\texit(1);\n\t}\n\tgot = read(urandom, target, count);\n\tif (got != count) {\n\t\tperror(\"read /dev/urandom\");\n\t\texit(1);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tunsigned char digest[SHA256_DIGEST_LENGTH];\n\tstruct sockaddr_storage listenaddr, addr;\n\tunsigned int max_pacing_rate = 0;\n\tEVP_MD_CTX *ctx = NULL;\n\tunsigned char *buffer;\n\tuint64_t total = 0;\n\tchar *host = NULL;\n\tint fd, c, on = 1;\n\tsize_t buffer_sz;\n\tint sflg = 0;\n\tint mss = 0;\n\n\twhile ((c = getopt(argc, argv, \"46p:svr:w:H:zxkP:M:C:a:i\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tcfg_family = PF_INET;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tcfg_family = PF_INET6;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in6);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcfg_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\thost = optarg;\n\t\t\tbreak;\n\t\tcase 's':  \n\t\t\tsflg++;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trcvbuf = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tsndbuf = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tzflg = 1;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tmss = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\txflg = 1;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkeepflag = 1;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tmax_pacing_rate = atoi(optarg) ;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tchunk_size = atol(optarg);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tmap_align = atol(optarg);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tintegrity = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (!map_align) {\n\t\tmap_align = default_huge_page_size();\n\t\t \n\t\tif (!map_align)\n\t\t\tmap_align = 2*1024*1024;\n\t}\n\tif (sflg) {\n\t\tint fdlisten = socket(cfg_family, SOCK_STREAM, 0);\n\n\t\tif (fdlisten == -1) {\n\t\t\tperror(\"socket\");\n\t\t\texit(1);\n\t\t}\n\t\tapply_rcvsnd_buf(fdlisten);\n\t\tsetsockopt(fdlisten, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));\n\n\t\tsetup_sockaddr(cfg_family, host, &listenaddr);\n\n\t\tif (mss &&\n\t\t    setsockopt(fdlisten, IPPROTO_TCP, TCP_MAXSEG,\n\t\t\t       &mss, sizeof(mss)) == -1) {\n\t\t\tperror(\"setsockopt TCP_MAXSEG\");\n\t\t\texit(1);\n\t\t}\n\t\tif (bind(fdlisten, (const struct sockaddr *)&listenaddr, cfg_alen) == -1) {\n\t\t\tperror(\"bind\");\n\t\t\texit(1);\n\t\t}\n\t\tif (listen(fdlisten, 128) == -1) {\n\t\t\tperror(\"listen\");\n\t\t\texit(1);\n\t\t}\n\t\tdo_accept(fdlisten);\n\t}\n\n\tbuffer = mmap_large_buffer(chunk_size, &buffer_sz);\n\tif (buffer == (unsigned char *)-1) {\n\t\tperror(\"mmap\");\n\t\texit(1);\n\t}\n\n\tfd = socket(cfg_family, SOCK_STREAM, 0);\n\tif (fd == -1) {\n\t\tperror(\"socket\");\n\t\texit(1);\n\t}\n\tapply_rcvsnd_buf(fd);\n\n\tsetup_sockaddr(cfg_family, host, &addr);\n\n\tif (mss &&\n\t    setsockopt(fd, IPPROTO_TCP, TCP_MAXSEG, &mss, sizeof(mss)) == -1) {\n\t\tperror(\"setsockopt TCP_MAXSEG\");\n\t\texit(1);\n\t}\n\tif (connect(fd, (const struct sockaddr *)&addr, cfg_alen) == -1) {\n\t\tperror(\"connect\");\n\t\texit(1);\n\t}\n\tif (max_pacing_rate &&\n\t    setsockopt(fd, SOL_SOCKET, SO_MAX_PACING_RATE,\n\t\t       &max_pacing_rate, sizeof(max_pacing_rate)) == -1)\n\t\tperror(\"setsockopt SO_MAX_PACING_RATE\");\n\n\tif (zflg && setsockopt(fd, SOL_SOCKET, SO_ZEROCOPY,\n\t\t\t       &on, sizeof(on)) == -1) {\n\t\tperror(\"setsockopt SO_ZEROCOPY, (-z option disabled)\");\n\t\tzflg = 0;\n\t}\n\tif (integrity) {\n\t\trandomize(buffer, buffer_sz);\n\t\tctx = EVP_MD_CTX_new();\n\t\tif (!ctx) {\n\t\t\tperror(\"cannot enable SHA computing\");\n\t\t\texit(1);\n\t\t}\n\t\tEVP_DigestInit_ex(ctx, EVP_sha256(), NULL);\n\t}\n\twhile (total < FILE_SZ) {\n\t\tsize_t offset = total % chunk_size;\n\t\tint64_t wr = FILE_SZ - total;\n\n\t\tif (wr > chunk_size - offset)\n\t\t\twr = chunk_size - offset;\n\t\t \n\t\twr = send(fd, buffer + offset,\n\t\t\t  (size_t)wr, zflg ? MSG_ZEROCOPY : 0);\n\t\tif (wr <= 0)\n\t\t\tbreak;\n\t\tif (integrity)\n\t\t\tEVP_DigestUpdate(ctx, buffer + offset, wr);\n\t\ttotal += wr;\n\t}\n\tif (integrity && total == FILE_SZ) {\n\t\tEVP_DigestFinal_ex(ctx, digest, &digest_len);\n\t\tsend(fd, digest, (size_t)SHA256_DIGEST_LENGTH, 0);\n\t}\n\tclose(fd);\n\tmunmap(buffer, buffer_sz);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}