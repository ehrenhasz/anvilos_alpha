{
  "module_name": "bareudp.sh",
  "hash_id": "21671a58d838c19cc767958e7fa07c2f597f36a87590d023704435310e62bd16",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/bareudp.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n\n# Test various bareudp tunnel configurations.\n#\n# The bareudp module allows to tunnel network protocols like IP or MPLS over\n# UDP, without adding any intermediate header. This scripts tests several\n# configurations of bareudp (using IPv4 or IPv6 as underlay and transporting\n# IPv4, IPv6 or MPLS packets on the overlay).\n#\n# Network topology:\n#\n#   * A chain of 4 network namespaces, connected with veth pairs. Each veth\n#     is assigned an IPv4 and an IPv6 address. A host-route allows a veth to\n#     join its peer.\n#\n#   * NS0 and NS3 are at the extremities of the chain. They have additional\n#     IPv4 and IPv6 addresses on their loopback device. Routes are added in NS0\n#     and NS3, so that they can communicate using these overlay IP addresses.\n#     For IPv4 and IPv6 reachability tests, the route simply sets the peer's\n#     veth address as gateway. For MPLS reachability tests, an MPLS header is\n#     also pushed before the IP header.\n#\n#   * NS1 and NS2 are the intermediate namespaces. They use a bareudp device to\n#     encapsulate the traffic into UDP.\n#\n# +-----------------------------------------------------------------------+\n# |                                  NS0                                  |\n# |                                                                       |\n# |   lo:                                                                 |\n# |      * IPv4 address: 192.0.2.100/32                                   |\n# |      * IPv6 address: 2001:db8::100/128                                |\n# |      * IPv6 address: 2001:db8::200/128                                |\n# |      * IPv4 route: 192.0.2.103/32 reachable via 192.0.2.11            |\n# |      * IPv6 route: 2001:db8::103/128 reachable via 2001:db8::11       |\n# |      * IPv6 route: 2001:db8::203/128 reachable via 2001:db8::11       |\n# |                    (encapsulated with MPLS label 203)                 |\n# |                                                                       |\n# |   veth01:                                                             |\n# |   ^  * IPv4 address: 192.0.2.10, peer 192.0.2.11/32                   |\n# |   |  * IPv6 address: 2001:db8::10, peer 2001:db8::11/128              |\n# |   |                                                                   |\n# +---+-------------------------------------------------------------------+\n#     |\n#     | Traffic type: IP or MPLS (depending on test)\n#     |\n# +---+-------------------------------------------------------------------+\n# |   |                              NS1                                  |\n# |   |                                                                   |\n# |   v                                                                   |\n# |   veth10:                                                             |\n# |      * IPv4 address: 192.0.2.11, peer 192.0.2.10/32                   |\n# |      * IPv6 address: 2001:db8::11, peer 2001:db8::10/128              |\n# |                                                                       |\n# |   bareudp_ns1:                                                        |\n# |      * Encapsulate IP or MPLS packets received on veth10 into UDP     |\n# |        and send the resulting packets through veth12.                 |\n# |      * Decapsulate bareudp packets (either IP or MPLS, over UDP)      |\n# |        received on veth12 and send the inner packets through veth10.  |\n# |                                                                       |\n# |   veth12:                                                             |\n# |   ^  * IPv4 address: 192.0.2.21, peer 192.0.2.22/32                   |\n# |   |  * IPv6 address: 2001:db8::21, peer 2001:db8::22/128              |\n# |   |                                                                   |\n# +---+-------------------------------------------------------------------+\n#     |\n#     | Traffic type: IP or MPLS (depending on test), over UDP\n#     |\n# +---+-------------------------------------------------------------------+\n# |   |                              NS2                                  |\n# |   |                                                                   |\n# |   v                                                                   |\n# |   veth21:                                                             |\n# |      * IPv4 address: 192.0.2.22, peer 192.0.2.21/32                   |\n# |      * IPv6 address: 2001:db8::22, peer 2001:db8::21/128              |\n# |                                                                       |\n# |   bareudp_ns2:                                                        |\n# |      * Decapsulate bareudp packets (either IP or MPLS, over UDP)      |\n# |        received on veth21 and send the inner packets through veth23.  |\n# |      * Encapsulate IP or MPLS packets received on veth23 into UDP     |\n# |        and send the resulting packets through veth21.                 |\n# |                                                                       |\n# |   veth23:                                                             |\n# |   ^  * IPv4 address: 192.0.2.32, peer 192.0.2.33/32                   |\n# |   |  * IPv6 address: 2001:db8::32, peer 2001:db8::33/128              |\n# |   |                                                                   |\n# +---+-------------------------------------------------------------------+\n#     |\n#     | Traffic type: IP or MPLS (depending on test)\n#     |\n# +---+-------------------------------------------------------------------+\n# |   |                              NS3                                  |\n# |   v                                                                   |\n# |   veth32:                                                             |\n# |      * IPv4 address: 192.0.2.33, peer 192.0.2.32/32                   |\n# |      * IPv6 address: 2001:db8::33, peer 2001:db8::32/128              |\n# |                                                                       |\n# |   lo:                                                                 |\n# |      * IPv4 address: 192.0.2.103/32                                   |\n# |      * IPv6 address: 2001:db8::103/128                                |\n# |      * IPv6 address: 2001:db8::203/128                                |\n# |      * IPv4 route: 192.0.2.100/32 reachable via 192.0.2.32            |\n# |      * IPv6 route: 2001:db8::100/128 reachable via 2001:db8::32       |\n# |      * IPv6 route: 2001:db8::200/128 reachable via 2001:db8::32       |\n# |                    (encapsulated with MPLS label 200)                 |\n# |                                                                       |\n# +-----------------------------------------------------------------------+\n\nERR=4 # Return 4 by default, which is the SKIP code for kselftest\nPING6=\"ping\"\nPAUSE_ON_FAIL=\"no\"\n\nreadonly NS0=$(mktemp -u ns0-XXXXXXXX)\nreadonly NS1=$(mktemp -u ns1-XXXXXXXX)\nreadonly NS2=$(mktemp -u ns2-XXXXXXXX)\nreadonly NS3=$(mktemp -u ns3-XXXXXXXX)\n\n# Exit the script after having removed the network namespaces it created\n#\n# Parameters:\n#\n#   * The list of network namespaces to delete before exiting.\n#\nexit_cleanup()\n{\n\tfor ns in \"$@\"; do\n\t\tip netns delete \"${ns}\" 2>/dev/null || true\n\tdone\n\n\tif [ \"${ERR}\" -eq 4 ]; then\n\t\techo \"Error: Setting up the testing environment failed.\" >&2\n\tfi\n\n\texit \"${ERR}\"\n}\n\n# Create the four network namespaces used by the script (NS0, NS1, NS2 and NS3)\n#\n# New namespaces are cleaned up manually in case of error, to ensure that only\n# namespaces created by this script are deleted.\ncreate_namespaces()\n{\n\tip netns add \"${NS0}\" || exit_cleanup\n\tip netns add \"${NS1}\" || exit_cleanup \"${NS0}\"\n\tip netns add \"${NS2}\" || exit_cleanup \"${NS0}\" \"${NS1}\"\n\tip netns add \"${NS3}\" || exit_cleanup \"${NS0}\" \"${NS1}\" \"${NS2}\"\n}\n\n# The trap function handler\n#\nexit_cleanup_all()\n{\n\texit_cleanup \"${NS0}\" \"${NS1}\" \"${NS2}\" \"${NS3}\"\n}\n\n# Configure a network interface using a host route\n#\n# Parameters\n#\n#   * $1: the netns the network interface resides in,\n#   * $2: the network interface name,\n#   * $3: the local IPv4 address to assign to this interface,\n#   * $4: the IPv4 address of the remote network interface,\n#   * $5: the local IPv6 address to assign to this interface,\n#   * $6: the IPv6 address of the remote network interface.\n#\niface_config()\n{\n\tlocal NS=\"${1}\"; readonly NS\n\tlocal DEV=\"${2}\"; readonly DEV\n\tlocal LOCAL_IP4=\"${3}\"; readonly LOCAL_IP4\n\tlocal PEER_IP4=\"${4}\"; readonly PEER_IP4\n\tlocal LOCAL_IP6=\"${5}\"; readonly LOCAL_IP6\n\tlocal PEER_IP6=\"${6}\"; readonly PEER_IP6\n\n\tip -netns \"${NS}\" link set dev \"${DEV}\" up\n\tip -netns \"${NS}\" address add dev \"${DEV}\" \"${LOCAL_IP4}\" peer \"${PEER_IP4}\"\n\tip -netns \"${NS}\" address add dev \"${DEV}\" \"${LOCAL_IP6}\" peer \"${PEER_IP6}\" nodad\n}\n\n# Create base networking topology:\n#\n#   * set up the loopback device in all network namespaces (NS0..NS3),\n#   * set up a veth pair to connect each netns in sequence (NS0 with NS1,\n#     NS1 with NS2, etc.),\n#   * add and IPv4 and an IPv6 address on each veth interface,\n#   * prepare the ingress qdiscs in the intermediate namespaces.\n#\nsetup_underlay()\n{\n\tfor ns in \"${NS0}\" \"${NS1}\" \"${NS2}\" \"${NS3}\"; do\n\t\tip -netns \"${ns}\" link set dev lo up\n\tdone;\n\n\tip link add name veth01 netns \"${NS0}\" type veth peer name veth10 netns \"${NS1}\"\n\tip link add name veth12 netns \"${NS1}\" type veth peer name veth21 netns \"${NS2}\"\n\tip link add name veth23 netns \"${NS2}\" type veth peer name veth32 netns \"${NS3}\"\n\tiface_config \"${NS0}\" veth01 192.0.2.10 192.0.2.11/32 2001:db8::10 2001:db8::11/128\n\tiface_config \"${NS1}\" veth10 192.0.2.11 192.0.2.10/32 2001:db8::11 2001:db8::10/128\n\tiface_config \"${NS1}\" veth12 192.0.2.21 192.0.2.22/32 2001:db8::21 2001:db8::22/128\n\tiface_config \"${NS2}\" veth21 192.0.2.22 192.0.2.21/32 2001:db8::22 2001:db8::21/128\n\tiface_config \"${NS2}\" veth23 192.0.2.32 192.0.2.33/32 2001:db8::32 2001:db8::33/128\n\tiface_config \"${NS3}\" veth32 192.0.2.33 192.0.2.32/32 2001:db8::33 2001:db8::32/128\n\n\ttc -netns \"${NS1}\" qdisc add dev veth10 ingress\n\ttc -netns \"${NS2}\" qdisc add dev veth23 ingress\n}\n\n# Set up the IPv4, IPv6 and MPLS overlays.\n#\n# Configuration is similar for all protocols:\n#\n#   * add an overlay IP address on the loopback interface of each edge\n#     namespace,\n#   * route these IP addresses via the intermediate namespaces (for the MPLS\n#     tests, this is also where MPLS encapsulation is done),\n#   * add routes for these IP addresses (or MPLS labels) in the intermediate\n#     namespaces.\n#\n# The bareudp encapsulation isn't configured in setup_overlay_*(). That will be\n# done just before running the reachability tests.\n\nsetup_overlay_ipv4()\n{\n\t# Add the overlay IP addresses and route them through the veth devices\n\tip -netns \"${NS0}\" address add 192.0.2.100/32 dev lo\n\tip -netns \"${NS3}\" address add 192.0.2.103/32 dev lo\n\tip -netns \"${NS0}\" route add 192.0.2.103/32 src 192.0.2.100 via 192.0.2.11\n\tip -netns \"${NS3}\" route add 192.0.2.100/32 src 192.0.2.103 via 192.0.2.32\n\n\t# Route the overlay addresses in the intermediate namespaces\n\t# (used after bareudp decapsulation)\n\tip netns exec \"${NS1}\" sysctl -qw net.ipv4.ip_forward=1\n\tip netns exec \"${NS2}\" sysctl -qw net.ipv4.ip_forward=1\n\tip -netns \"${NS1}\" route add 192.0.2.100/32 via 192.0.2.10\n\tip -netns \"${NS2}\" route add 192.0.2.103/32 via 192.0.2.33\n\n\t# The intermediate namespaces don't have routes for the reverse path,\n\t# as it will be handled by tc. So we need to ensure that rp_filter is\n\t# not going to block the traffic.\n\tip netns exec \"${NS1}\" sysctl -qw net.ipv4.conf.all.rp_filter=0\n\tip netns exec \"${NS2}\" sysctl -qw net.ipv4.conf.all.rp_filter=0\n\tip netns exec \"${NS1}\" sysctl -qw net.ipv4.conf.default.rp_filter=0\n\tip netns exec \"${NS2}\" sysctl -qw net.ipv4.conf.default.rp_filter=0\n}\n\nsetup_overlay_ipv6()\n{\n\t# Add the overlay IP addresses and route them through the veth devices\n\tip -netns \"${NS0}\" address add 2001:db8::100/128 dev lo\n\tip -netns \"${NS3}\" address add 2001:db8::103/128 dev lo\n\tip -netns \"${NS0}\" route add 2001:db8::103/128 src 2001:db8::100 via 2001:db8::11\n\tip -netns \"${NS3}\" route add 2001:db8::100/128 src 2001:db8::103 via 2001:db8::32\n\n\t# Route the overlay addresses in the intermediate namespaces\n\t# (used after bareudp decapsulation)\n\tip netns exec \"${NS1}\" sysctl -qw net.ipv6.conf.all.forwarding=1\n\tip netns exec \"${NS2}\" sysctl -qw net.ipv6.conf.all.forwarding=1\n\tip -netns \"${NS1}\" route add 2001:db8::100/128 via 2001:db8::10\n\tip -netns \"${NS2}\" route add 2001:db8::103/128 via 2001:db8::33\n}\n\nsetup_overlay_mpls()\n{\n\t# Add specific overlay IP addresses, routed over MPLS\n\tip -netns \"${NS0}\" address add 2001:db8::200/128 dev lo\n\tip -netns \"${NS3}\" address add 2001:db8::203/128 dev lo\n\tip -netns \"${NS0}\" route add 2001:db8::203/128 src 2001:db8::200 encap mpls 203 via 2001:db8::11\n\tip -netns \"${NS3}\" route add 2001:db8::200/128 src 2001:db8::203 encap mpls 200 via 2001:db8::32\n\n\t# Route the MPLS packets in the intermediate namespaces\n\t# (used after bareudp decapsulation)\n\tip netns exec \"${NS1}\" sysctl -qw net.mpls.platform_labels=256\n\tip netns exec \"${NS2}\" sysctl -qw net.mpls.platform_labels=256\n\tip -netns \"${NS1}\" -family mpls route add 200 via inet6 2001:db8::10\n\tip -netns \"${NS2}\" -family mpls route add 203 via inet6 2001:db8::33\n}\n\n# Run \"ping\" from NS0 and print the result\n#\n# Parameters:\n#\n#   * $1: the variant of ping to use (normally either \"ping\" or \"ping6\"),\n#   * $2: the IP address to ping,\n#   * $3: a human readable description of the purpose of the test.\n#\n# If the test fails and PAUSE_ON_FAIL is active, the user is given the\n# possibility to continue with the next test or to quit immediately.\n#\nping_test_one()\n{\n\tlocal PING=\"$1\"; readonly PING\n\tlocal IP=\"$2\"; readonly IP\n\tlocal MSG=\"$3\"; readonly MSG\n\tlocal RET\n\n\tprintf \"TEST: %-60s  \" \"${MSG}\"\n\n\tset +e\n\tip netns exec \"${NS0}\" \"${PING}\" -w 5 -c 1 \"${IP}\" > /dev/null 2>&1\n\tRET=$?\n\tset -e\n\n\tif [ \"${RET}\" -eq 0 ]; then\n\t\tprintf \"[ OK ]\\n\"\n\telse\n\t\tERR=1\n\t\tprintf \"[FAIL]\\n\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\tprintf \"\\nHit enter to continue, 'q' to quit\\n\"\n\t\t\tread a\n\t\t\tif [ \"$a\" = \"q\" ]; then\n\t\t\t\texit 1\n\t\t\tfi\n\t\tfi\n\tfi\n}\n\n# Run reachability tests\n#\n# Parameters:\n#\n#   * $1: human readable string describing the underlay protocol.\n#\n# $IPV4, $IPV6, $MPLS_UC and $MULTIPROTO are inherited from the calling\n# function.\n#\nping_test()\n{\n\tlocal UNDERLAY=\"$1\"; readonly UNDERLAY\n\tlocal MODE\n\tlocal MSG\n\n\tif [ \"${MULTIPROTO}\" = \"multiproto\" ]; then\n\t\tMODE=\" (multiproto mode)\"\n\telse\n\t\tMODE=\"\"\n\tfi\n\n\tif [ $IPV4 ]; then\n\t\tping_test_one \"ping\" \"192.0.2.103\" \"IPv4 packets over ${UNDERLAY}${MODE}\"\n\tfi\n\tif [ $IPV6 ]; then\n\t\tping_test_one \"${PING6}\" \"2001:db8::103\" \"IPv6 packets over ${UNDERLAY}${MODE}\"\n\tfi\n\tif [ $MPLS_UC ]; then\n\t\tping_test_one \"${PING6}\" \"2001:db8::203\" \"Unicast MPLS packets over ${UNDERLAY}${MODE}\"\n\tfi\n}\n\n# Set up a bareudp overlay and run reachability tests over IPv4 and IPv6\n#\n# Parameters:\n#\n#   * $1: the packet type (protocol) to be handled by bareudp,\n#   * $2: a flag to activate or deactivate bareudp's \"multiproto\" mode.\n#\ntest_overlay()\n{\n\tlocal ETHERTYPE=\"$1\"; readonly ETHERTYPE\n\tlocal MULTIPROTO=\"$2\"; readonly MULTIPROTO\n\tlocal IPV4\n\tlocal IPV6\n\tlocal MPLS_UC\n\n\tcase \"${ETHERTYPE}\" in\n\t\t\"ipv4\")\n\t\t\tIPV4=\"ipv4\"\n\t\t\tif [ \"${MULTIPROTO}\" = \"multiproto\" ]; then\n\t\t\t\tIPV6=\"ipv6\"\n\t\t\telse\n\t\t\t\tIPV6=\"\"\n\t\t\tfi\n\t\t\tMPLS_UC=\"\"\n\t\t\t;;\n\t\t\"ipv6\")\n\t\t\tIPV6=\"ipv6\"\n\t\t\tIPV4=\"\"\n\t\t\tMPLS_UC=\"\"\n\t\t\t;;\n\t\t\"mpls_uc\")\n\t\t\tMPLS_UC=\"mpls_uc\"\n\t\t\tIPV4=\"\"\n\t\t\tIPV6=\"\"\n\t\t\t;;\n\t\t*)\n\t\t\texit 1\n\t\t\t;;\n\tesac\n\treadonly IPV4\n\treadonly IPV6\n\treadonly MPLS_UC\n\n\t# Create the bareudp devices in the intermediate namespaces\n\tip -netns \"${NS1}\" link add name bareudp_ns1 up type bareudp dstport 6635 ethertype \"${ETHERTYPE}\" \"${MULTIPROTO}\"\n\tip -netns \"${NS2}\" link add name bareudp_ns2 up type bareudp dstport 6635 ethertype \"${ETHERTYPE}\" \"${MULTIPROTO}\"\n\n\t# IPv4 over UDPv4\n\tif [ $IPV4 ]; then\n\t\t# Encapsulation instructions for bareudp over IPv4\n\t\ttc -netns \"${NS1}\" filter add dev veth10 ingress protocol ipv4         \\\n\t\t\tflower dst_ip 192.0.2.103/32                                   \\\n\t\t\taction tunnel_key set src_ip 192.0.2.21 dst_ip 192.0.2.22 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns1\n\t\ttc -netns \"${NS2}\" filter add dev veth23 ingress protocol ipv4         \\\n\t\t\tflower dst_ip 192.0.2.100/32                                   \\\n\t\t\taction tunnel_key set src_ip 192.0.2.22 dst_ip 192.0.2.21 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns2\n\tfi\n\n\t# IPv6 over UDPv4\n\tif [ $IPV6 ]; then\n\t\t# Encapsulation instructions for bareudp over IPv4\n\t\ttc -netns \"${NS1}\" filter add dev veth10 ingress protocol ipv6         \\\n\t\t\tflower dst_ip 2001:db8::103/128                                \\\n\t\t\taction tunnel_key set src_ip 192.0.2.21 dst_ip 192.0.2.22 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns1\n\t\ttc -netns \"${NS2}\" filter add dev veth23 ingress protocol ipv6         \\\n\t\t\tflower dst_ip 2001:db8::100/128                                \\\n\t\t\taction tunnel_key set src_ip 192.0.2.22 dst_ip 192.0.2.21 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns2\n\tfi\n\n\t# MPLS (unicast) over UDPv4\n\tif [ $MPLS_UC ]; then\n\t\tip netns exec \"${NS1}\" sysctl -qw net.mpls.conf.bareudp_ns1.input=1\n\t\tip netns exec \"${NS2}\" sysctl -qw net.mpls.conf.bareudp_ns2.input=1\n\n\t\t# Encapsulation instructions for bareudp over IPv4\n\t\ttc -netns \"${NS1}\" filter add dev veth10 ingress protocol mpls_uc      \\\n\t\t\tflower mpls_label 203                                          \\\n\t\t\taction tunnel_key set src_ip 192.0.2.21 dst_ip 192.0.2.22 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns1\n\t\ttc -netns \"${NS2}\" filter add dev veth23 ingress protocol mpls_uc      \\\n\t\t\tflower mpls_label 200                                          \\\n\t\t\taction tunnel_key set src_ip 192.0.2.22 dst_ip 192.0.2.21 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns2\n\tfi\n\n\t# Test IPv4 underlay\n\tping_test \"UDPv4\"\n\n\t# Cleanup bareudp encapsulation instructions, as they were specific to\n\t# the IPv4 underlay, before setting up and testing the IPv6 underlay\n\ttc -netns \"${NS1}\" filter delete dev veth10 ingress\n\ttc -netns \"${NS2}\" filter delete dev veth23 ingress\n\n\t# IPv4 over UDPv6\n\tif [ $IPV4 ]; then\n\t\t# New encapsulation instructions for bareudp over IPv6\n\t\ttc -netns \"${NS1}\" filter add dev veth10 ingress protocol ipv4             \\\n\t\t\tflower dst_ip 192.0.2.103/32                                       \\\n\t\t\taction tunnel_key set src_ip 2001:db8::21 dst_ip 2001:db8::22 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns1\n\t\ttc -netns \"${NS2}\" filter add dev veth23 ingress protocol ipv4             \\\n\t\t\tflower dst_ip 192.0.2.100/32                                       \\\n\t\t\taction tunnel_key set src_ip 2001:db8::22 dst_ip 2001:db8::21 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns2\n\tfi\n\n\t# IPv6 over UDPv6\n\tif [ $IPV6 ]; then\n\t\t# New encapsulation instructions for bareudp over IPv6\n\t\ttc -netns \"${NS1}\" filter add dev veth10 ingress protocol ipv6             \\\n\t\t\tflower dst_ip 2001:db8::103/128                                    \\\n\t\t\taction tunnel_key set src_ip 2001:db8::21 dst_ip 2001:db8::22 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns1\n\t\ttc -netns \"${NS2}\" filter add dev veth23 ingress protocol ipv6             \\\n\t\t\tflower dst_ip 2001:db8::100/128                                    \\\n\t\t\taction tunnel_key set src_ip 2001:db8::22 dst_ip 2001:db8::21 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns2\n\tfi\n\n\t# MPLS (unicast) over UDPv6\n\tif [ $MPLS_UC ]; then\n\t\t# New encapsulation instructions for bareudp over IPv6\n\t\ttc -netns \"${NS1}\" filter add dev veth10 ingress protocol mpls_uc          \\\n\t\t\tflower mpls_label 203                                              \\\n\t\t\taction tunnel_key set src_ip 2001:db8::21 dst_ip 2001:db8::22 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns1\n\t\ttc -netns \"${NS2}\" filter add dev veth23 ingress protocol mpls_uc          \\\n\t\t\tflower mpls_label 200                                              \\\n\t\t\taction tunnel_key set src_ip 2001:db8::22 dst_ip 2001:db8::21 id 0 \\\n\t\t\taction mirred egress redirect dev bareudp_ns2\n\tfi\n\n\t# Test IPv6 underlay\n\tping_test \"UDPv6\"\n\n\ttc -netns \"${NS1}\" filter delete dev veth10 ingress\n\ttc -netns \"${NS2}\" filter delete dev veth23 ingress\n\tip -netns \"${NS1}\" link delete bareudp_ns1\n\tip -netns \"${NS2}\" link delete bareudp_ns2\n}\n\ncheck_features()\n{\n\tip link help 2>&1 | grep -q bareudp\n\tif [ $? -ne 0 ]; then\n\t\techo \"Missing bareudp support in iproute2\" >&2\n\t\texit_cleanup\n\tfi\n\n\t# Use ping6 on systems where ping doesn't handle IPv6\n\tping -w 1 -c 1 ::1 > /dev/null 2>&1 || PING6=\"ping6\"\n}\n\nusage()\n{\n\techo \"Usage: $0 [-p]\"\n\texit 1\n}\n\nwhile getopts :p o\ndo\n\tcase $o in\n\t\tp) PAUSE_ON_FAIL=\"yes\";;\n\t\t*) usage;;\n\tesac\ndone\n\ncheck_features\n\n# Create namespaces before setting up the exit trap.\n# Otherwise, exit_cleanup_all() could delete namespaces that were not created\n# by this script.\ncreate_namespaces\n\nset -e\ntrap exit_cleanup_all EXIT\n\nsetup_underlay\nsetup_overlay_ipv4\nsetup_overlay_ipv6\nsetup_overlay_mpls\n\ntest_overlay ipv4 nomultiproto\ntest_overlay ipv6 nomultiproto\ntest_overlay ipv4 multiproto\ntest_overlay mpls_uc nomultiproto\n\nif [ \"${ERR}\" -eq 1 ]; then\n\techo \"Some tests failed.\" >&2\nelse\n\tERR=0\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}