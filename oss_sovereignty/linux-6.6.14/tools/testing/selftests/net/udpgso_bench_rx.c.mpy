{
  "module_name": "udpgso_bench_rx.c",
  "hash_id": "1288a8dc010d1f582034eaf6e7037456ba8e342b7e098c052b880f0762e94080",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/udpgso_bench_rx.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <error.h>\n#include <errno.h>\n#include <limits.h>\n#include <linux/errqueue.h>\n#include <linux/if_packet.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n#include <netinet/ip.h>\n#include <netinet/ip6.h>\n#include <netinet/tcp.h>\n#include <netinet/udp.h>\n#include <poll.h>\n#include <sched.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#ifndef UDP_GRO\n#define UDP_GRO\t\t104\n#endif\n\nstatic int  cfg_port\t\t= 8000;\nstatic bool cfg_tcp;\nstatic bool cfg_verify;\nstatic bool cfg_read_all;\nstatic bool cfg_gro_segment;\nstatic int  cfg_family\t\t= PF_INET6;\nstatic int  cfg_alen \t\t= sizeof(struct sockaddr_in6);\nstatic int  cfg_expected_pkt_nr;\nstatic int  cfg_expected_pkt_len;\nstatic int  cfg_expected_gso_size;\nstatic int  cfg_connect_timeout_ms;\nstatic int  cfg_rcv_timeout_ms;\nstatic struct sockaddr_storage cfg_bind_addr;\n\nstatic bool interrupted;\nstatic unsigned long packets, bytes;\n\nstatic void sigint_handler(int signum)\n{\n\tif (signum == SIGINT)\n\t\tinterrupted = true;\n}\n\nstatic void setup_sockaddr(int domain, const char *str_addr, void *sockaddr)\n{\n\tstruct sockaddr_in6 *addr6 = (void *) sockaddr;\n\tstruct sockaddr_in *addr4 = (void *) sockaddr;\n\n\tswitch (domain) {\n\tcase PF_INET:\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_port = htons(cfg_port);\n\t\tif (inet_pton(AF_INET, str_addr, &(addr4->sin_addr)) != 1)\n\t\t\terror(1, 0, \"ipv4 parse error: %s\", str_addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_port = htons(cfg_port);\n\t\tif (inet_pton(AF_INET6, str_addr, &(addr6->sin6_addr)) != 1)\n\t\t\terror(1, 0, \"ipv6 parse error: %s\", str_addr);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"illegal domain\");\n\t}\n}\n\nstatic unsigned long gettimeofday_ms(void)\n{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\treturn (tv.tv_sec * 1000) + (tv.tv_usec / 1000);\n}\n\nstatic void do_poll(int fd, int timeout_ms)\n{\n\tstruct pollfd pfd;\n\tint ret;\n\n\tpfd.events = POLLIN;\n\tpfd.revents = 0;\n\tpfd.fd = fd;\n\n\tdo {\n\t\tret = poll(&pfd, 1, 10);\n\t\tif (interrupted)\n\t\t\tbreak;\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"poll\");\n\t\tif (ret == 0) {\n\t\t\tif (!timeout_ms)\n\t\t\t\tcontinue;\n\n\t\t\ttimeout_ms -= 10;\n\t\t\tif (timeout_ms <= 0) {\n\t\t\t\tinterrupted = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (pfd.revents != POLLIN)\n\t\t\terror(1, errno, \"poll: 0x%x expected 0x%x\\n\",\n\t\t\t\t\tpfd.revents, POLLIN);\n\t} while (!ret);\n}\n\nstatic int do_socket(bool do_tcp)\n{\n\tint fd, val;\n\n\tfd = socket(cfg_family, cfg_tcp ? SOCK_STREAM : SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket\");\n\n\tval = 1 << 21;\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &val, sizeof(val)))\n\t\terror(1, errno, \"setsockopt rcvbuf\");\n\tval = 1;\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(val)))\n\t\terror(1, errno, \"setsockopt reuseport\");\n\n\tif (bind(fd, (void *)&cfg_bind_addr, cfg_alen))\n\t\terror(1, errno, \"bind\");\n\n\tif (do_tcp) {\n\t\tint accept_fd = fd;\n\n\t\tif (listen(accept_fd, 1))\n\t\t\terror(1, errno, \"listen\");\n\n\t\tdo_poll(accept_fd, cfg_connect_timeout_ms);\n\t\tif (interrupted)\n\t\t\texit(0);\n\n\t\tfd = accept(accept_fd, NULL, NULL);\n\t\tif (fd == -1)\n\t\t\terror(1, errno, \"accept\");\n\t\tif (close(accept_fd))\n\t\t\terror(1, errno, \"close accept fd\");\n\t}\n\n\treturn fd;\n}\n\n \nstatic void do_flush_tcp(int fd)\n{\n\tint ret;\n\n\twhile (true) {\n\t\t \n\t\tret = recv(fd, NULL, 1 << 21, MSG_TRUNC | MSG_DONTWAIT);\n\t\tif (ret == -1 && errno == EAGAIN)\n\t\t\treturn;\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"flush\");\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\texit(0);\n\t\t}\n\n\t\tpackets++;\n\t\tbytes += ret;\n\t}\n\n}\n\nstatic char sanitized_char(char val)\n{\n\treturn (val >= 'a' && val <= 'z') ? val : '.';\n}\n\nstatic void do_verify_udp(const char *data, int len)\n{\n\tchar cur = data[0];\n\tint i;\n\n\t \n\tif (cur < 'a' || cur > 'z')\n\t\terror(1, 0, \"data initial byte out of range\");\n\n\tfor (i = 1; i < len; i++) {\n\t\tif (cur == 'z')\n\t\t\tcur = 'a';\n\t\telse\n\t\t\tcur++;\n\n\t\tif (data[i] != cur)\n\t\t\terror(1, 0, \"data[%d]: len %d, %c(%hhu) != %c(%hhu)\\n\",\n\t\t\t      i, len,\n\t\t\t      sanitized_char(data[i]), data[i],\n\t\t\t      sanitized_char(cur), cur);\n\t}\n}\n\nstatic int recv_msg(int fd, char *buf, int len, int *gso_size)\n{\n\tchar control[CMSG_SPACE(sizeof(int))] = {0};\n\tstruct msghdr msg = {0};\n\tstruct iovec iov = {0};\n\tstruct cmsghdr *cmsg;\n\tint ret;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = len;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tmsg.msg_control = control;\n\tmsg.msg_controllen = sizeof(control);\n\n\t*gso_size = -1;\n\tret = recvmsg(fd, &msg, MSG_TRUNC | MSG_DONTWAIT);\n\tif (ret != -1) {\n\t\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;\n\t\t     cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tif (cmsg->cmsg_level == SOL_UDP\n\t\t\t    && cmsg->cmsg_type == UDP_GRO) {\n\t\t\t\t*gso_size = *(int *)CMSG_DATA(cmsg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic void do_flush_udp(int fd)\n{\n\tstatic char rbuf[ETH_MAX_MTU];\n\tint ret, len, gso_size = 0, budget = 256;\n\n\tlen = cfg_read_all ? sizeof(rbuf) : 0;\n\twhile (budget--) {\n\t\t \n\t\tif (!cfg_expected_gso_size)\n\t\t\tret = recv(fd, rbuf, len, MSG_TRUNC | MSG_DONTWAIT);\n\t\telse\n\t\t\tret = recv_msg(fd, rbuf, len, &gso_size);\n\t\tif (ret == -1 && errno == EAGAIN)\n\t\t\tbreak;\n\t\tif (ret == -1)\n\t\t\terror(1, errno, \"recv\");\n\t\tif (cfg_expected_pkt_len && ret != cfg_expected_pkt_len)\n\t\t\terror(1, 0, \"recv: bad packet len, got %d,\"\n\t\t\t      \" expected %d\\n\", ret, cfg_expected_pkt_len);\n\t\tif (len && cfg_verify) {\n\t\t\tif (ret == 0)\n\t\t\t\terror(1, errno, \"recv: 0 byte datagram\\n\");\n\n\t\t\tdo_verify_udp(rbuf, ret);\n\t\t}\n\t\tif (cfg_expected_gso_size && cfg_expected_gso_size != gso_size)\n\t\t\terror(1, 0, \"recv: bad gso size, got %d, expected %d \"\n\t\t\t      \"(-1 == no gso cmsg))\\n\", gso_size,\n\t\t\t      cfg_expected_gso_size);\n\n\t\tpackets++;\n\t\tbytes += ret;\n\t\tif (cfg_expected_pkt_nr && packets >= cfg_expected_pkt_nr)\n\t\t\tbreak;\n\t}\n}\n\nstatic void usage(const char *filepath)\n{\n\terror(1, 0, \"Usage: %s [-C connect_timeout] [-Grtv] [-b addr] [-p port]\"\n\t      \" [-l pktlen] [-n packetnr] [-R rcv_timeout] [-S gsosize]\",\n\t      filepath);\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tconst char *bind_addr = NULL;\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"4b:C:Gl:n:p:rR:S:tv\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tcfg_family = PF_INET;\n\t\t\tcfg_alen = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbind_addr = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcfg_connect_timeout_ms = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tcfg_gro_segment = true;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tcfg_expected_pkt_len = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcfg_expected_pkt_nr = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcfg_port = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcfg_read_all = true;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tcfg_rcv_timeout_ms = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tcfg_expected_gso_size = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_tcp = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcfg_verify = true;\n\t\t\tcfg_read_all = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (!bind_addr)\n\t\tbind_addr = cfg_family == PF_INET6 ? \"::\" : \"0.0.0.0\";\n\n\tsetup_sockaddr(cfg_family, bind_addr, &cfg_bind_addr);\n\n\tif (optind != argc)\n\t\tusage(argv[0]);\n\n\tif (cfg_tcp && cfg_verify)\n\t\terror(1, 0, \"TODO: implement verify mode for tcp\");\n}\n\nstatic void do_recv(void)\n{\n\tint timeout_ms = cfg_tcp ? cfg_rcv_timeout_ms : cfg_connect_timeout_ms;\n\tunsigned long tnow, treport;\n\tint fd;\n\n\tfd = do_socket(cfg_tcp);\n\n\tif (cfg_gro_segment && !cfg_tcp) {\n\t\tint val = 1;\n\t\tif (setsockopt(fd, IPPROTO_UDP, UDP_GRO, &val, sizeof(val)))\n\t\t\terror(1, errno, \"setsockopt UDP_GRO\");\n\t}\n\n\ttreport = gettimeofday_ms() + 1000;\n\tdo {\n\t\tdo_poll(fd, timeout_ms);\n\n\t\tif (cfg_tcp)\n\t\t\tdo_flush_tcp(fd);\n\t\telse\n\t\t\tdo_flush_udp(fd);\n\n\t\ttnow = gettimeofday_ms();\n\t\tif (tnow > treport) {\n\t\t\tif (packets)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s rx: %6lu MB/s %8lu calls/s\\n\",\n\t\t\t\t\tcfg_tcp ? \"tcp\" : \"udp\",\n\t\t\t\t\tbytes >> 20, packets);\n\t\t\tbytes = packets = 0;\n\t\t\ttreport = tnow + 1000;\n\t\t}\n\n\t\ttimeout_ms = cfg_rcv_timeout_ms;\n\n\t} while (!interrupted);\n\n\tif (cfg_expected_pkt_nr && (packets != cfg_expected_pkt_nr))\n\t\terror(1, 0, \"wrong packet number! got %ld, expected %d\\n\",\n\t\t      packets, cfg_expected_pkt_nr);\n\n\tif (close(fd))\n\t\terror(1, errno, \"close\");\n}\n\nint main(int argc, char **argv)\n{\n\tparse_opts(argc, argv);\n\n\tsignal(SIGINT, sigint_handler);\n\n\tdo_recv();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}