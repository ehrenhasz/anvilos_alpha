{
  "module_name": "pmtu.sh",
  "hash_id": "2ffc70ccb5405171fe2e54a9f0a748a159d7786136d5c2ab4fe04932fedef381",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/pmtu.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# Check that route PMTU values match expectations, and that initial device MTU\n# values are assigned correctly\n#\n# Tests currently implemented:\n#\n# - pmtu_ipv4\n#\tSet up two namespaces, A and B, with two paths between them over routers\n#\tR1 and R2 (also implemented with namespaces), with different MTUs:\n#\n#\t  segment a_r1    segment b_r1\t\ta_r1: 2000\n#\t.--------------R1--------------.\tb_r1: 1400\n#\tA                               B\ta_r2: 2000\n#\t'--------------R2--------------'\tb_r2: 1500\n#\t  segment a_r2    segment b_r2\n#\n#\tCheck that PMTU exceptions with the correct PMTU are created. Then\n#\tdecrease and increase the MTU of the local link for one of the paths,\n#\tA to R1, checking that route exception PMTU changes accordingly over\n#\tthis path. Also check that locked exceptions are created when an ICMP\n#\tmessage advertising a PMTU smaller than net.ipv4.route.min_pmtu is\n#\treceived\n#\n# - pmtu_ipv6\n#\tSame as pmtu_ipv4, except for locked PMTU tests, using IPv6\n#\n# - pmtu_ipv4_dscp_icmp_exception\n#\tSet up the same network topology as pmtu_ipv4, but use non-default\n#\trouting table in A. A fib-rule is used to jump to this routing table\n#\tbased on DSCP. Send ICMPv4 packets with the expected DSCP value and\n#\tverify that ECN doesn't interfere with the creation of PMTU exceptions.\n#\n# - pmtu_ipv4_dscp_udp_exception\n#\tSame as pmtu_ipv4_dscp_icmp_exception, but use UDP instead of ICMP.\n#\n# - pmtu_ipv4_vxlan4_exception\n#\tSet up the same network topology as pmtu_ipv4, create a VXLAN tunnel\n#\tover IPv4 between A and B, routed via R1. On the link between R1 and B,\n#\tset a MTU lower than the VXLAN MTU and the MTU on the link between A and\n#\tR1. Send IPv4 packets, exceeding the MTU between R1 and B, over VXLAN\n#\tfrom A to B and check that the PMTU exception is created with the right\n#\tvalue on A\n#\n# - pmtu_ipv6_vxlan4_exception\n#\tSame as pmtu_ipv4_vxlan4_exception, but send IPv6 packets from A to B\n#\n# - pmtu_ipv4_vxlan6_exception\n#\tSame as pmtu_ipv4_vxlan4_exception, but use IPv6 transport from A to B\n#\n# - pmtu_ipv6_vxlan6_exception\n#\tSame as pmtu_ipv4_vxlan6_exception, but send IPv6 packets from A to B\n#\n# - pmtu_ipv4_geneve4_exception\n#\tSame as pmtu_ipv4_vxlan4_exception, but using a GENEVE tunnel instead of\n#\tVXLAN\n#\n# - pmtu_ipv6_geneve4_exception\n#\tSame as pmtu_ipv6_vxlan4_exception, but using a GENEVE tunnel instead of\n#\tVXLAN\n#\n# - pmtu_ipv4_geneve6_exception\n#\tSame as pmtu_ipv4_vxlan6_exception, but using a GENEVE tunnel instead of\n#\tVXLAN\n#\n# - pmtu_ipv6_geneve6_exception\n#\tSame as pmtu_ipv6_vxlan6_exception, but using a GENEVE tunnel instead of\n#\tVXLAN\n#\n# - pmtu_ipv{4,6}_br_vxlan{4,6}_exception\n#\tSet up three namespaces, A, B, and C, with routing between A and B over\n#\tR1. R2 is unused in these tests. A has a veth connection to C, and is\n#\tconnected to B via a VXLAN endpoint, which is directly bridged to C.\n#\tMTU on the B-R1 link is lower than other MTUs.\n#\n#\tCheck that both C and A are able to communicate with B over the VXLAN\n#\ttunnel, and that PMTU exceptions with the correct values are created.\n#\n#\t                  segment a_r1    segment b_r1            b_r1: 4000\n#\t                .--------------R1--------------.    everything\n#\t   C---veth     A                               B         else: 5000\n#\t        ' bridge                                |\n#\t            '---- - - - - - VXLAN - - - - - - - '\n#\n# - pmtu_ipv{4,6}_br_geneve{4,6}_exception\n#\tSame as pmtu_ipv{4,6}_br_vxlan{4,6}_exception, with a GENEVE tunnel\n#\tinstead.\n#\n# - pmtu_ipv{4,6}_ovs_vxlan{4,6}_exception\n#\tSet up two namespaces, B, and C, with routing between the init namespace\n#\tand B over R1. A and R2 are unused in these tests. The init namespace\n#\thas a veth connection to C, and is connected to B via a VXLAN endpoint,\n#\twhich is handled by Open vSwitch and bridged to C. MTU on the B-R1 link\n#\tis lower than other MTUs.\n#\n#\tCheck that C is able to communicate with B over the VXLAN tunnel, and\n#\tthat PMTU exceptions with the correct values are created.\n#\n#\t                  segment a_r1    segment b_r1            b_r1: 4000\n#\t                .--------------R1--------------.    everything\n#\t   C---veth    init                             B         else: 5000\n#\t        '- ovs                                  |\n#\t            '---- - - - - - VXLAN - - - - - - - '\n#\n# - pmtu_ipv{4,6}_ovs_geneve{4,6}_exception\n#\tSame as pmtu_ipv{4,6}_ovs_vxlan{4,6}_exception, with a GENEVE tunnel\n#\tinstead.\n#\n# - pmtu_ipv{4,6}_fou{4,6}_exception\n#\tSame as pmtu_ipv4_vxlan4, but using a direct IPv4/IPv6 encapsulation\n#\t(FoU) over IPv4/IPv6, instead of VXLAN\n#\n# - pmtu_ipv{4,6}_fou{4,6}_exception\n#\tSame as pmtu_ipv4_vxlan4, but using a generic UDP IPv4/IPv6\n#\tencapsulation (GUE) over IPv4/IPv6, instead of VXLAN\n#\n# - pmtu_ipv{4,6}_ipv{4,6}_exception\n#\tSame as pmtu_ipv4_vxlan4, but using a IPv4/IPv6 tunnel over IPv4/IPv6,\n#\tinstead of VXLAN\n#\n# - pmtu_vti4_exception\n#\tSet up vti tunnel on top of veth, with xfrm states and policies, in two\n#\tnamespaces with matching endpoints. Check that route exception is not\n#\tcreated if link layer MTU is not exceeded, then exceed it and check that\n#\texception is created with the expected PMTU. The approach described\n#\tbelow for IPv6 doesn't apply here, because, on IPv4, administrative MTU\n#\tchanges alone won't affect PMTU\n#\n# - pmtu_vti4_udp_exception\n#       Same as pmtu_vti4_exception, but using ESP-in-UDP\n#\n# - pmtu_vti4_udp_routed_exception\n#       Set up vti tunnel on top of veth connected through routing namespace and\n#\tadd xfrm states and policies with ESP-in-UDP encapsulation. Check that\n#\troute exception is not created if link layer MTU is not exceeded, then\n#\tlower MTU on second part of routed environment and check that exception\n#\tis created with the expected PMTU.\n#\n# - pmtu_vti6_exception\n#\tSet up vti6 tunnel on top of veth, with xfrm states and policies, in two\n#\tnamespaces with matching endpoints. Check that route exception is\n#\tcreated by exceeding link layer MTU with ping to other endpoint. Then\n#\tdecrease and increase MTU of tunnel, checking that route exception PMTU\n#\tchanges accordingly\n#\n# - pmtu_vti6_udp_exception\n#       Same as pmtu_vti6_exception, but using ESP-in-UDP\n#\n# - pmtu_vti6_udp_routed_exception\n#\tSame as pmtu_vti6_udp_routed_exception but with routing between vti\n#\tendpoints\n#\n# - pmtu_vti4_default_mtu\n#\tSet up vti4 tunnel on top of veth, in two namespaces with matching\n#\tendpoints. Check that MTU assigned to vti interface is the MTU of the\n#\tlower layer (veth) minus additional lower layer headers (zero, for veth)\n#\tminus IPv4 header length\n#\n# - pmtu_vti6_default_mtu\n#\tSame as above, for IPv6\n#\n# - pmtu_vti4_link_add_mtu\n#\tSet up vti4 interface passing MTU value at link creation, check MTU is\n#\tconfigured, and that link is not created with invalid MTU values\n#\n# - pmtu_vti6_link_add_mtu\n#\tSame as above, for IPv6\n#\n# - pmtu_vti6_link_change_mtu\n#\tSet up two dummy interfaces with different MTUs, create a vti6 tunnel\n#\tand check that configured MTU is used on link creation and changes, and\n#\tthat MTU is properly calculated instead when MTU is not configured from\n#\tuserspace\n#\n# - cleanup_ipv4_exception\n#\tSimilar to pmtu_ipv4_vxlan4_exception, but explicitly generate PMTU\n#\texceptions on multiple CPUs and check that the veth device tear-down\n# \thappens in a timely manner\n#\n# - cleanup_ipv6_exception\n#\tSame as above, but use IPv6 transport from A to B\n#\n# - list_flush_ipv4_exception\n#\tUsing the same topology as in pmtu_ipv4, create exceptions, and check\n#\tthey are shown when listing exception caches, gone after flushing them\n#\n# - list_flush_ipv6_exception\n#\tUsing the same topology as in pmtu_ipv6, create exceptions, and check\n#\tthey are shown when listing exception caches, gone after flushing them\n#\n# - pmtu_ipv4_route_change\n#\tUse the same topology as in pmtu_ipv4, but issue a route replacement\n#\tcommand and delete the corresponding device afterward. This tests for\n#\tproper cleanup of the PMTU exceptions by the route replacement path.\n#\tDevice unregistration should complete successfully\n#\n# - pmtu_ipv6_route_change\n#\tSame as above but with IPv6\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\nPAUSE_ON_FAIL=no\nVERBOSE=0\nTRACING=0\n\n# Some systems don't have a ping6 binary anymore\nwhich ping6 > /dev/null 2>&1 && ping6=$(which ping6) || ping6=$(which ping)\n\n#               Name                          Description                  re-run with nh\ntests=\"\n\tpmtu_ipv4_exception\t\tipv4: PMTU exceptions\t\t\t1\n\tpmtu_ipv6_exception\t\tipv6: PMTU exceptions\t\t\t1\n\tpmtu_ipv4_dscp_icmp_exception\tICMPv4 with DSCP and ECN: PMTU exceptions\t1\n\tpmtu_ipv4_dscp_udp_exception\tUDPv4 with DSCP and ECN: PMTU exceptions\t1\n\tpmtu_ipv4_vxlan4_exception\tIPv4 over vxlan4: PMTU exceptions\t1\n\tpmtu_ipv6_vxlan4_exception\tIPv6 over vxlan4: PMTU exceptions\t1\n\tpmtu_ipv4_vxlan6_exception\tIPv4 over vxlan6: PMTU exceptions\t1\n\tpmtu_ipv6_vxlan6_exception\tIPv6 over vxlan6: PMTU exceptions\t1\n\tpmtu_ipv4_geneve4_exception\tIPv4 over geneve4: PMTU exceptions\t1\n\tpmtu_ipv6_geneve4_exception\tIPv6 over geneve4: PMTU exceptions\t1\n\tpmtu_ipv4_geneve6_exception\tIPv4 over geneve6: PMTU exceptions\t1\n\tpmtu_ipv6_geneve6_exception\tIPv6 over geneve6: PMTU exceptions\t1\n\tpmtu_ipv4_br_vxlan4_exception\tIPv4, bridged vxlan4: PMTU exceptions\t1\n\tpmtu_ipv6_br_vxlan4_exception\tIPv6, bridged vxlan4: PMTU exceptions\t1\n\tpmtu_ipv4_br_vxlan6_exception\tIPv4, bridged vxlan6: PMTU exceptions\t1\n\tpmtu_ipv6_br_vxlan6_exception\tIPv6, bridged vxlan6: PMTU exceptions\t1\n\tpmtu_ipv4_br_geneve4_exception\tIPv4, bridged geneve4: PMTU exceptions\t1\n\tpmtu_ipv6_br_geneve4_exception\tIPv6, bridged geneve4: PMTU exceptions\t1\n\tpmtu_ipv4_br_geneve6_exception\tIPv4, bridged geneve6: PMTU exceptions\t1\n\tpmtu_ipv6_br_geneve6_exception\tIPv6, bridged geneve6: PMTU exceptions\t1\n\tpmtu_ipv4_ovs_vxlan4_exception\tIPv4, OVS vxlan4: PMTU exceptions\t1\n\tpmtu_ipv6_ovs_vxlan4_exception\tIPv6, OVS vxlan4: PMTU exceptions\t1\n\tpmtu_ipv4_ovs_vxlan6_exception\tIPv4, OVS vxlan6: PMTU exceptions\t1\n\tpmtu_ipv6_ovs_vxlan6_exception\tIPv6, OVS vxlan6: PMTU exceptions\t1\n\tpmtu_ipv4_ovs_geneve4_exception\tIPv4, OVS geneve4: PMTU exceptions\t1\n\tpmtu_ipv6_ovs_geneve4_exception\tIPv6, OVS geneve4: PMTU exceptions\t1\n\tpmtu_ipv4_ovs_geneve6_exception\tIPv4, OVS geneve6: PMTU exceptions\t1\n\tpmtu_ipv6_ovs_geneve6_exception\tIPv6, OVS geneve6: PMTU exceptions\t1\n\tpmtu_ipv4_fou4_exception\tIPv4 over fou4: PMTU exceptions\t\t1\n\tpmtu_ipv6_fou4_exception\tIPv6 over fou4: PMTU exceptions\t\t1\n\tpmtu_ipv4_fou6_exception\tIPv4 over fou6: PMTU exceptions\t\t1\n\tpmtu_ipv6_fou6_exception\tIPv6 over fou6: PMTU exceptions\t\t1\n\tpmtu_ipv4_gue4_exception\tIPv4 over gue4: PMTU exceptions\t\t1\n\tpmtu_ipv6_gue4_exception\tIPv6 over gue4: PMTU exceptions\t\t1\n\tpmtu_ipv4_gue6_exception\tIPv4 over gue6: PMTU exceptions\t\t1\n\tpmtu_ipv6_gue6_exception\tIPv6 over gue6: PMTU exceptions\t\t1\n\tpmtu_ipv4_ipv4_exception\tIPv4 over IPv4: PMTU exceptions\t\t1\n\tpmtu_ipv6_ipv4_exception\tIPv6 over IPv4: PMTU exceptions\t\t1\n\tpmtu_ipv4_ipv6_exception\tIPv4 over IPv6: PMTU exceptions\t\t1\n\tpmtu_ipv6_ipv6_exception\tIPv6 over IPv6: PMTU exceptions\t\t1\n\tpmtu_vti6_exception\t\tvti6: PMTU exceptions\t\t\t0\n\tpmtu_vti4_exception\t\tvti4: PMTU exceptions\t\t\t0\n\tpmtu_vti6_udp_exception\t\tvti6: PMTU exceptions (ESP-in-UDP)\t0\n\tpmtu_vti4_udp_exception\t\tvti4: PMTU exceptions (ESP-in-UDP)\t0\n\tpmtu_vti6_udp_routed_exception\tvti6: PMTU exceptions, routed (ESP-in-UDP)\t0\n\tpmtu_vti4_udp_routed_exception\tvti4: PMTU exceptions, routed (ESP-in-UDP)\t0\n\tpmtu_vti4_default_mtu\t\tvti4: default MTU assignment\t\t0\n\tpmtu_vti6_default_mtu\t\tvti6: default MTU assignment\t\t0\n\tpmtu_vti4_link_add_mtu\t\tvti4: MTU setting on link creation\t0\n\tpmtu_vti6_link_add_mtu\t\tvti6: MTU setting on link creation\t0\n\tpmtu_vti6_link_change_mtu\tvti6: MTU changes on link changes\t0\n\tcleanup_ipv4_exception\t\tipv4: cleanup of cached exceptions\t1\n\tcleanup_ipv6_exception\t\tipv6: cleanup of cached exceptions\t1\n\tlist_flush_ipv4_exception\tipv4: list and flush cached exceptions\t1\n\tlist_flush_ipv6_exception\tipv6: list and flush cached exceptions\t1\n\tpmtu_ipv4_route_change\t\tipv4: PMTU exception w/route replace\t1\n\tpmtu_ipv6_route_change\t\tipv6: PMTU exception w/route replace\t1\"\n\nNS_A=\"ns-A\"\nNS_B=\"ns-B\"\nNS_C=\"ns-C\"\nNS_R1=\"ns-R1\"\nNS_R2=\"ns-R2\"\nns_a=\"ip netns exec ${NS_A}\"\nns_b=\"ip netns exec ${NS_B}\"\nns_c=\"ip netns exec ${NS_C}\"\nns_r1=\"ip netns exec ${NS_R1}\"\nns_r2=\"ip netns exec ${NS_R2}\"\n# Addressing and routing for tests with routers: four network segments, with\n# index SEGMENT between 1 and 4, a common prefix (PREFIX4 or PREFIX6) and an\n# identifier ID, which is 1 for hosts (A and B), 2 for routers (R1 and R2).\n# Addresses are:\n# - IPv4: PREFIX4.SEGMENT.ID (/24)\n# - IPv6: PREFIX6:SEGMENT::ID (/64)\nprefix4=\"10.0\"\nprefix6=\"fc00\"\na_r1=1\na_r2=2\nb_r1=3\nb_r2=4\n#\tns\tpeer\tsegment\nrouting_addrs=\"\n\tA\tR1\t${a_r1}\n\tA\tR2\t${a_r2}\n\tB\tR1\t${b_r1}\n\tB\tR2\t${b_r2}\n\"\n# Traffic from A to B goes through R1 by default, and through R2, if destined to\n# B's address on the b_r2 segment.\n# Traffic from B to A goes through R1.\n#\tns\tdestination\t\tgateway\nroutes=\"\n\tA\tdefault\t\t\t${prefix4}.${a_r1}.2\n\tA\t${prefix4}.${b_r2}.1\t${prefix4}.${a_r2}.2\n\tB\tdefault\t\t\t${prefix4}.${b_r1}.2\n\n\tA\tdefault\t\t\t${prefix6}:${a_r1}::2\n\tA\t${prefix6}:${b_r2}::1\t${prefix6}:${a_r2}::2\n\tB\tdefault\t\t\t${prefix6}:${b_r1}::2\n\"\nUSE_NH=\"no\"\n#\tns\tfamily\tnh id\t   destination\t\tgateway\nnexthops=\"\n\tA\t4\t41\t${prefix4}.${a_r1}.2\tveth_A-R1\n\tA\t4\t42\t${prefix4}.${a_r2}.2\tveth_A-R2\n\tB\t4\t41\t${prefix4}.${b_r1}.2\tveth_B-R1\n\n\tA\t6\t61\t${prefix6}:${a_r1}::2\tveth_A-R1\n\tA\t6\t62\t${prefix6}:${a_r2}::2\tveth_A-R2\n\tB\t6\t61\t${prefix6}:${b_r1}::2\tveth_B-R1\n\"\n\n# nexthop id correlates to id in nexthops config above\n#\tns    family\tprefix\t\t\tnh id\nroutes_nh=\"\n\tA\t4\tdefault\t\t\t41\n\tA\t4\t${prefix4}.${b_r2}.1\t42\n\tB\t4\tdefault\t\t\t41\n\n\tA\t6\tdefault\t\t\t61\n\tA\t6\t${prefix6}:${b_r2}::1\t62\n\tB\t6\tdefault\t\t\t61\n\"\n\npolicy_mark=0x04\nrt_table=main\n\nveth4_a_addr=\"192.168.1.1\"\nveth4_b_addr=\"192.168.1.2\"\nveth4_c_addr=\"192.168.2.10\"\nveth4_mask=\"24\"\nveth6_a_addr=\"fd00:1::a\"\nveth6_b_addr=\"fd00:1::b\"\nveth6_c_addr=\"fd00:2::c\"\nveth6_mask=\"64\"\n\ntunnel4_a_addr=\"192.168.2.1\"\ntunnel4_b_addr=\"192.168.2.2\"\ntunnel4_mask=\"24\"\ntunnel6_a_addr=\"fd00:2::a\"\ntunnel6_b_addr=\"fd00:2::b\"\ntunnel6_mask=\"64\"\n\ndummy6_0_prefix=\"fc00:1000::\"\ndummy6_1_prefix=\"fc00:1001::\"\ndummy6_mask=\"64\"\n\nerr_buf=\ntcpdump_pids=\nnettest_pids=\nsocat_pids=\ntmpoutfile=\n\nerr() {\n\terr_buf=\"${err_buf}${1}\n\"\n}\n\nerr_flush() {\n\techo -n \"${err_buf}\"\n\terr_buf=\n}\n\nrun_cmd() {\n\tcmd=\"$*\"\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\tprintf \"    COMMAND: $cmd\\n\"\n\tfi\n\n\tout=\"$($cmd 2>&1)\"\n\trc=$?\n\tif [ \"$VERBOSE\" = \"1\" -a -n \"$out\" ]; then\n\t\techo \"    $out\"\n\t\techo\n\tfi\n\n\treturn $rc\n}\n\nrun_cmd_bg() {\n\tcmd=\"$*\"\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\tprintf \"    COMMAND: %s &\\n\" \"${cmd}\"\n\tfi\n\n\t$cmd 2>&1 &\n}\n\n# Find the auto-generated name for this namespace\nnsname() {\n\teval echo \\$NS_$1\n}\n\nsetup_fou_or_gue() {\n\touter=\"${1}\"\n\tinner=\"${2}\"\n\tencap=\"${3}\"\n\n\tif [ \"${outer}\" = \"4\" ]; then\n\t\tmodprobe fou || return $ksft_skip\n\t\ta_addr=\"${prefix4}.${a_r1}.1\"\n\t\tb_addr=\"${prefix4}.${b_r1}.1\"\n\t\tif [ \"${inner}\" = \"4\" ]; then\n\t\t\ttype=\"ipip\"\n\t\t\tipproto=\"4\"\n\t\telse\n\t\t\ttype=\"sit\"\n\t\t\tipproto=\"41\"\n\t\tfi\n\telse\n\t\tmodprobe fou6 || return $ksft_skip\n\t\ta_addr=\"${prefix6}:${a_r1}::1\"\n\t\tb_addr=\"${prefix6}:${b_r1}::1\"\n\t\tif [ \"${inner}\" = \"4\" ]; then\n\t\t\ttype=\"ip6tnl\"\n\t\t\tmode=\"mode ipip6\"\n\t\t\tipproto=\"4 -6\"\n\t\telse\n\t\t\ttype=\"ip6tnl\"\n\t\t\tmode=\"mode ip6ip6\"\n\t\t\tipproto=\"41 -6\"\n\t\tfi\n\tfi\n\n\trun_cmd ${ns_a} ip fou add port 5555 ipproto ${ipproto} || return $ksft_skip\n\trun_cmd ${ns_a} ip link add ${encap}_a type ${type} ${mode} local ${a_addr} remote ${b_addr} encap ${encap} encap-sport auto encap-dport 5556 || return $ksft_skip\n\n\trun_cmd ${ns_b} ip fou add port 5556 ipproto ${ipproto}\n\trun_cmd ${ns_b} ip link add ${encap}_b type ${type} ${mode} local ${b_addr} remote ${a_addr} encap ${encap} encap-sport auto encap-dport 5555\n\n\tif [ \"${inner}\" = \"4\" ]; then\n\t\trun_cmd ${ns_a} ip addr add ${tunnel4_a_addr}/${tunnel4_mask} dev ${encap}_a\n\t\trun_cmd ${ns_b} ip addr add ${tunnel4_b_addr}/${tunnel4_mask} dev ${encap}_b\n\telse\n\t\trun_cmd ${ns_a} ip addr add ${tunnel6_a_addr}/${tunnel6_mask} dev ${encap}_a\n\t\trun_cmd ${ns_b} ip addr add ${tunnel6_b_addr}/${tunnel6_mask} dev ${encap}_b\n\tfi\n\n\trun_cmd ${ns_a} ip link set ${encap}_a up\n\trun_cmd ${ns_b} ip link set ${encap}_b up\n}\n\nsetup_fou44() {\n\tsetup_fou_or_gue 4 4 fou\n}\n\nsetup_fou46() {\n\tsetup_fou_or_gue 4 6 fou\n}\n\nsetup_fou64() {\n\tsetup_fou_or_gue 6 4 fou\n}\n\nsetup_fou66() {\n\tsetup_fou_or_gue 6 6 fou\n}\n\nsetup_gue44() {\n\tsetup_fou_or_gue 4 4 gue\n}\n\nsetup_gue46() {\n\tsetup_fou_or_gue 4 6 gue\n}\n\nsetup_gue64() {\n\tsetup_fou_or_gue 6 4 gue\n}\n\nsetup_gue66() {\n\tsetup_fou_or_gue 6 6 gue\n}\n\nsetup_ipvX_over_ipvY() {\n\tinner=${1}\n\touter=${2}\n\n\tif [ \"${outer}\" -eq 4 ]; then\n\t\ta_addr=\"${prefix4}.${a_r1}.1\"\n\t\tb_addr=\"${prefix4}.${b_r1}.1\"\n\t\tif [ \"${inner}\" -eq 4 ]; then\n\t\t\ttype=\"ipip\"\n\t\t\tmode=\"ipip\"\n\t\telse\n\t\t\ttype=\"sit\"\n\t\t\tmode=\"ip6ip\"\n\t\tfi\n\telse\n\t\ta_addr=\"${prefix6}:${a_r1}::1\"\n\t\tb_addr=\"${prefix6}:${b_r1}::1\"\n\t\ttype=\"ip6tnl\"\n\t\tif [ \"${inner}\" -eq 4 ]; then\n\t\t\tmode=\"ipip6\"\n\t\telse\n\t\t\tmode=\"ip6ip6\"\n\t\tfi\n\tfi\n\n\trun_cmd ${ns_a} ip link add ip_a type ${type} local ${a_addr} remote ${b_addr} mode ${mode} || return $ksft_skip\n\trun_cmd ${ns_b} ip link add ip_b type ${type} local ${b_addr} remote ${a_addr} mode ${mode}\n\n\trun_cmd ${ns_a} ip link set ip_a up\n\trun_cmd ${ns_b} ip link set ip_b up\n\n\tif [ \"${inner}\" = \"4\" ]; then\n\t\trun_cmd ${ns_a} ip addr add ${tunnel4_a_addr}/${tunnel4_mask} dev ip_a\n\t\trun_cmd ${ns_b} ip addr add ${tunnel4_b_addr}/${tunnel4_mask} dev ip_b\n\telse\n\t\trun_cmd ${ns_a} ip addr add ${tunnel6_a_addr}/${tunnel6_mask} dev ip_a\n\t\trun_cmd ${ns_b} ip addr add ${tunnel6_b_addr}/${tunnel6_mask} dev ip_b\n\tfi\n}\n\nsetup_ip4ip4() {\n\tsetup_ipvX_over_ipvY 4 4\n}\n\nsetup_ip6ip4() {\n\tsetup_ipvX_over_ipvY 6 4\n}\n\nsetup_ip4ip6() {\n\tsetup_ipvX_over_ipvY 4 6\n}\n\nsetup_ip6ip6() {\n\tsetup_ipvX_over_ipvY 6 6\n}\n\nsetup_namespaces() {\n\tfor n in ${NS_A} ${NS_B} ${NS_C} ${NS_R1} ${NS_R2}; do\n\t\tip netns add ${n} || return 1\n\n\t\t# Disable DAD, so that we don't have to wait to use the\n\t\t# configured IPv6 addresses\n\t\tip netns exec ${n} sysctl -q net/ipv6/conf/default/accept_dad=0\n\tdone\n}\n\nsetup_veth() {\n\trun_cmd ${ns_a} ip link add veth_a type veth peer name veth_b || return 1\n\trun_cmd ${ns_a} ip link set veth_b netns ${NS_B}\n\n\trun_cmd ${ns_a} ip addr add ${veth4_a_addr}/${veth4_mask} dev veth_a\n\trun_cmd ${ns_b} ip addr add ${veth4_b_addr}/${veth4_mask} dev veth_b\n\n\trun_cmd ${ns_a} ip addr add ${veth6_a_addr}/${veth6_mask} dev veth_a\n\trun_cmd ${ns_b} ip addr add ${veth6_b_addr}/${veth6_mask} dev veth_b\n\n\trun_cmd ${ns_a} ip link set veth_a up\n\trun_cmd ${ns_b} ip link set veth_b up\n}\n\nsetup_vti() {\n\tproto=${1}\n\tveth_a_addr=\"${2}\"\n\tveth_b_addr=\"${3}\"\n\tvti_a_addr=\"${4}\"\n\tvti_b_addr=\"${5}\"\n\tvti_mask=${6}\n\n\t[ ${proto} -eq 6 ] && vti_type=\"vti6\" || vti_type=\"vti\"\n\n\trun_cmd ${ns_a} ip link add vti${proto}_a type ${vti_type} local ${veth_a_addr} remote ${veth_b_addr} key 10 || return 1\n\trun_cmd ${ns_b} ip link add vti${proto}_b type ${vti_type} local ${veth_b_addr} remote ${veth_a_addr} key 10\n\n\trun_cmd ${ns_a} ip addr add ${vti_a_addr}/${vti_mask} dev vti${proto}_a\n\trun_cmd ${ns_b} ip addr add ${vti_b_addr}/${vti_mask} dev vti${proto}_b\n\n\trun_cmd ${ns_a} ip link set vti${proto}_a up\n\trun_cmd ${ns_b} ip link set vti${proto}_b up\n}\n\nsetup_vti4() {\n\tsetup_vti 4 ${veth4_a_addr} ${veth4_b_addr} ${tunnel4_a_addr} ${tunnel4_b_addr} ${tunnel4_mask}\n}\n\nsetup_vti6() {\n\tsetup_vti 6 ${veth6_a_addr} ${veth6_b_addr} ${tunnel6_a_addr} ${tunnel6_b_addr} ${tunnel6_mask}\n}\n\nsetup_vti4routed() {\n\tsetup_vti 4 ${prefix4}.${a_r1}.1 ${prefix4}.${b_r1}.1 ${tunnel4_a_addr} ${tunnel4_b_addr} ${tunnel4_mask}\n}\n\nsetup_vti6routed() {\n\tsetup_vti 6 ${prefix6}:${a_r1}::1 ${prefix6}:${b_r1}::1 ${tunnel6_a_addr} ${tunnel6_b_addr} ${tunnel6_mask}\n}\n\nsetup_vxlan_or_geneve() {\n\ttype=\"${1}\"\n\ta_addr=\"${2}\"\n\tb_addr=\"${3}\"\n\topts=\"${4}\"\n\tbr_if_a=\"${5}\"\n\n\tif [ \"${type}\" = \"vxlan\" ]; then\n\t\topts=\"${opts} ttl 64 dstport 4789\"\n\t\topts_a=\"local ${a_addr}\"\n\t\topts_b=\"local ${b_addr}\"\n\telse\n\t\topts_a=\"\"\n\t\topts_b=\"\"\n\tfi\n\n\trun_cmd ${ns_a} ip link add ${type}_a type ${type} id 1 ${opts_a} remote ${b_addr} ${opts} || return 1\n\trun_cmd ${ns_b} ip link add ${type}_b type ${type} id 1 ${opts_b} remote ${a_addr} ${opts}\n\n\tif [ -n \"${br_if_a}\" ]; then\n\t\trun_cmd ${ns_a} ip addr add ${tunnel4_a_addr}/${tunnel4_mask} dev ${br_if_a}\n\t\trun_cmd ${ns_a} ip addr add ${tunnel6_a_addr}/${tunnel6_mask} dev ${br_if_a}\n\t\trun_cmd ${ns_a} ip link set ${type}_a master ${br_if_a}\n\telse\n\t\trun_cmd ${ns_a} ip addr add ${tunnel4_a_addr}/${tunnel4_mask} dev ${type}_a\n\t\trun_cmd ${ns_a} ip addr add ${tunnel6_a_addr}/${tunnel6_mask} dev ${type}_a\n\tfi\n\n\trun_cmd ${ns_b} ip addr add ${tunnel4_b_addr}/${tunnel4_mask} dev ${type}_b\n\trun_cmd ${ns_b} ip addr add ${tunnel6_b_addr}/${tunnel6_mask} dev ${type}_b\n\n\trun_cmd ${ns_a} ip link set ${type}_a up\n\trun_cmd ${ns_b} ip link set ${type}_b up\n}\n\nsetup_geneve4() {\n\tsetup_vxlan_or_geneve geneve ${prefix4}.${a_r1}.1  ${prefix4}.${b_r1}.1  \"df set\"\n}\n\nsetup_vxlan4() {\n\tsetup_vxlan_or_geneve vxlan  ${prefix4}.${a_r1}.1  ${prefix4}.${b_r1}.1  \"df set\"\n}\n\nsetup_geneve6() {\n\tsetup_vxlan_or_geneve geneve ${prefix6}:${a_r1}::1 ${prefix6}:${b_r1}::1 \"\"\n}\n\nsetup_vxlan6() {\n\tsetup_vxlan_or_geneve vxlan  ${prefix6}:${a_r1}::1 ${prefix6}:${b_r1}::1 \"\"\n}\n\nsetup_bridged_geneve4() {\n\tsetup_vxlan_or_geneve geneve ${prefix4}.${a_r1}.1  ${prefix4}.${b_r1}.1  \"df set\" \"br0\"\n}\n\nsetup_bridged_vxlan4() {\n\tsetup_vxlan_or_geneve vxlan  ${prefix4}.${a_r1}.1  ${prefix4}.${b_r1}.1  \"df set\" \"br0\"\n}\n\nsetup_bridged_geneve6() {\n\tsetup_vxlan_or_geneve geneve ${prefix6}:${a_r1}::1 ${prefix6}:${b_r1}::1 \"\" \"br0\"\n}\n\nsetup_bridged_vxlan6() {\n\tsetup_vxlan_or_geneve vxlan  ${prefix6}:${a_r1}::1 ${prefix6}:${b_r1}::1 \"\" \"br0\"\n}\n\nsetup_xfrm() {\n\tproto=${1}\n\tveth_a_addr=\"${2}\"\n\tveth_b_addr=\"${3}\"\n\tencap=${4}\n\n\trun_cmd ${ns_a} ip -${proto} xfrm state add src ${veth_a_addr} dst ${veth_b_addr} spi 0x1000 proto esp aead 'rfc4106(gcm(aes))' 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f 128 mode tunnel ${encap} || return 1\n\trun_cmd ${ns_a} ip -${proto} xfrm state add src ${veth_b_addr} dst ${veth_a_addr} spi 0x1001 proto esp aead 'rfc4106(gcm(aes))' 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f 128 mode tunnel ${encap}\n\trun_cmd ${ns_a} ip -${proto} xfrm policy add dir out mark 10 tmpl src ${veth_a_addr} dst ${veth_b_addr} proto esp mode tunnel\n\trun_cmd ${ns_a} ip -${proto} xfrm policy add dir in mark 10 tmpl src ${veth_b_addr} dst ${veth_a_addr} proto esp mode tunnel\n\n\trun_cmd ${ns_b} ip -${proto} xfrm state add src ${veth_a_addr} dst ${veth_b_addr} spi 0x1000 proto esp aead 'rfc4106(gcm(aes))' 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f 128 mode tunnel ${encap}\n\trun_cmd ${ns_b} ip -${proto} xfrm state add src ${veth_b_addr} dst ${veth_a_addr} spi 0x1001 proto esp aead 'rfc4106(gcm(aes))' 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f 128 mode tunnel ${encap}\n\trun_cmd ${ns_b} ip -${proto} xfrm policy add dir out mark 10 tmpl src ${veth_b_addr} dst ${veth_a_addr} proto esp mode tunnel\n\trun_cmd ${ns_b} ip -${proto} xfrm policy add dir in mark 10 tmpl src ${veth_a_addr} dst ${veth_b_addr} proto esp mode tunnel\n}\n\nsetup_nettest_xfrm() {\n\tif ! which nettest >/dev/null; then\n\t\tPATH=$PWD:$PATH\n\t\tif ! which nettest >/dev/null; then\n\t\t\techo \"'nettest' command not found; skipping tests\"\n\t\t\treturn 1\n\t\tfi\n\tfi\n\n\t[ ${1} -eq 6 ] && proto=\"-6\" || proto=\"\"\n\tport=${2}\n\n\trun_cmd_bg \"${ns_a}\" nettest \"${proto}\" -q -D -s -x -p \"${port}\" -t 5\n\tnettest_pids=\"${nettest_pids} $!\"\n\n\trun_cmd_bg \"${ns_b}\" nettest \"${proto}\" -q -D -s -x -p \"${port}\" -t 5\n\tnettest_pids=\"${nettest_pids} $!\"\n}\n\nsetup_xfrm4() {\n\tsetup_xfrm 4 ${veth4_a_addr} ${veth4_b_addr}\n}\n\nsetup_xfrm6() {\n\tsetup_xfrm 6 ${veth6_a_addr} ${veth6_b_addr}\n}\n\nsetup_xfrm4udp() {\n\tsetup_xfrm 4 ${veth4_a_addr} ${veth4_b_addr} \"encap espinudp 4500 4500 0.0.0.0\"\n\tsetup_nettest_xfrm 4 4500\n}\n\nsetup_xfrm6udp() {\n\tsetup_xfrm 6 ${veth6_a_addr} ${veth6_b_addr} \"encap espinudp 4500 4500 0.0.0.0\"\n\tsetup_nettest_xfrm 6 4500\n}\n\nsetup_xfrm4udprouted() {\n\tsetup_xfrm 4 ${prefix4}.${a_r1}.1 ${prefix4}.${b_r1}.1 \"encap espinudp 4500 4500 0.0.0.0\"\n\tsetup_nettest_xfrm 4 4500\n}\n\nsetup_xfrm6udprouted() {\n\tsetup_xfrm 6 ${prefix6}:${a_r1}::1 ${prefix6}:${b_r1}::1 \"encap espinudp 4500 4500 0.0.0.0\"\n\tsetup_nettest_xfrm 6 4500\n}\n\nsetup_routing_old() {\n\tfor i in ${routes}; do\n\t\t[ \"${ns}\" = \"\" ]\t&& ns=\"${i}\"\t\t&& continue\n\t\t[ \"${addr}\" = \"\" ]\t&& addr=\"${i}\"\t\t&& continue\n\t\t[ \"${gw}\" = \"\" ]\t&& gw=\"${i}\"\n\n\t\tns_name=\"$(nsname ${ns})\"\n\n\t\tip -n \"${ns_name}\" route add \"${addr}\" table \"${rt_table}\" via \"${gw}\"\n\n\t\tns=\"\"; addr=\"\"; gw=\"\"\n\tdone\n}\n\nsetup_routing_new() {\n\tfor i in ${nexthops}; do\n\t\t[ \"${ns}\" = \"\" ]\t&& ns=\"${i}\"\t\t&& continue\n\t\t[ \"${fam}\" = \"\" ]\t&& fam=\"${i}\"\t\t&& continue\n\t\t[ \"${nhid}\" = \"\" ]\t&& nhid=\"${i}\"\t\t&& continue\n\t\t[ \"${gw}\" = \"\" ]\t&& gw=\"${i}\"\t\t&& continue\n\t\t[ \"${dev}\" = \"\" ]\t&& dev=\"${i}\"\n\n\t\tns_name=\"$(nsname ${ns})\"\n\n\t\tip -n ${ns_name} -${fam} nexthop add id ${nhid} via ${gw} dev ${dev}\n\n\t\tns=\"\"; fam=\"\"; nhid=\"\"; gw=\"\"; dev=\"\"\n\n\tdone\n\n\tfor i in ${routes_nh}; do\n\t\t[ \"${ns}\" = \"\" ]\t&& ns=\"${i}\"\t\t&& continue\n\t\t[ \"${fam}\" = \"\" ]\t&& fam=\"${i}\"\t\t&& continue\n\t\t[ \"${addr}\" = \"\" ]\t&& addr=\"${i}\"\t\t&& continue\n\t\t[ \"${nhid}\" = \"\" ]\t&& nhid=\"${i}\"\n\n\t\tns_name=\"$(nsname ${ns})\"\n\n\t\tip -n \"${ns_name}\" -\"${fam}\" route add \"${addr}\" table \"${rt_table}\" nhid \"${nhid}\"\n\n\t\tns=\"\"; fam=\"\"; addr=\"\"; nhid=\"\"\n\tdone\n}\n\nsetup_routing() {\n\tfor i in ${NS_R1} ${NS_R2}; do\n\t\tip netns exec ${i} sysctl -q net/ipv4/ip_forward=1\n\t\tip netns exec ${i} sysctl -q net/ipv6/conf/all/forwarding=1\n\tdone\n\n\tfor i in ${routing_addrs}; do\n\t\t[ \"${ns}\" = \"\" ]\t&& ns=\"${i}\"\t\t&& continue\n\t\t[ \"${peer}\" = \"\" ]\t&& peer=\"${i}\"\t\t&& continue\n\t\t[ \"${segment}\" = \"\" ]\t&& segment=\"${i}\"\n\n\t\tns_name=\"$(nsname ${ns})\"\n\t\tpeer_name=\"$(nsname ${peer})\"\n\t\tif=\"veth_${ns}-${peer}\"\n\t\tifpeer=\"veth_${peer}-${ns}\"\n\n\t\t# Create veth links\n\t\tip link add ${if} up netns ${ns_name} type veth peer name ${ifpeer} netns ${peer_name} || return 1\n\t\tip -n ${peer_name} link set dev ${ifpeer} up\n\n\t\t# Add addresses\n\t\tip -n ${ns_name}   addr add ${prefix4}.${segment}.1/24  dev ${if}\n\t\tip -n ${ns_name}   addr add ${prefix6}:${segment}::1/64 dev ${if}\n\n\t\tip -n ${peer_name} addr add ${prefix4}.${segment}.2/24  dev ${ifpeer}\n\t\tip -n ${peer_name} addr add ${prefix6}:${segment}::2/64 dev ${ifpeer}\n\n\t\tns=\"\"; peer=\"\"; segment=\"\"\n\tdone\n\n\tif [ \"$USE_NH\" = \"yes\" ]; then\n\t\tsetup_routing_new\n\telse\n\t\tsetup_routing_old\n\tfi\n\n\treturn 0\n}\n\nsetup_policy_routing() {\n\tsetup_routing\n\n\tip -netns \"${NS_A}\" -4 rule add dsfield \"${policy_mark}\" \\\n\t\ttable \"${rt_table}\"\n\n\t# Set the IPv4 Don't Fragment bit with tc, since socat doesn't seem to\n\t# have an option do to it.\n\ttc -netns \"${NS_A}\" qdisc replace dev veth_A-R1 root prio\n\ttc -netns \"${NS_A}\" qdisc replace dev veth_A-R2 root prio\n\ttc -netns \"${NS_A}\" filter add dev veth_A-R1                      \\\n\t\tprotocol ipv4 flower ip_proto udp                         \\\n\t\taction pedit ex munge ip df set 0x40 pipe csum ip and udp\n\ttc -netns \"${NS_A}\" filter add dev veth_A-R2                      \\\n\t\tprotocol ipv4 flower ip_proto udp                         \\\n\t\taction pedit ex munge ip df set 0x40 pipe csum ip and udp\n}\n\nsetup_bridge() {\n\trun_cmd ${ns_a} ip link add br0 type bridge || return $ksft_skip\n\trun_cmd ${ns_a} ip link set br0 up\n\n\trun_cmd ${ns_c} ip link add veth_C-A type veth peer name veth_A-C\n\trun_cmd ${ns_c} ip link set veth_A-C netns ns-A\n\n\trun_cmd ${ns_a} ip link set veth_A-C up\n\trun_cmd ${ns_c} ip link set veth_C-A up\n\trun_cmd ${ns_c} ip addr add ${veth4_c_addr}/${veth4_mask} dev veth_C-A\n\trun_cmd ${ns_c} ip addr add ${veth6_c_addr}/${veth6_mask} dev veth_C-A\n\trun_cmd ${ns_a} ip link set veth_A-C master br0\n}\n\nsetup_ovs_vxlan_or_geneve() {\n\ttype=\"${1}\"\n\ta_addr=\"${2}\"\n\tb_addr=\"${3}\"\n\n\tif [ \"${type}\" = \"vxlan\" ]; then\n\t\topts=\"${opts} ttl 64 dstport 4789\"\n\t\topts_b=\"local ${b_addr}\"\n\tfi\n\n\trun_cmd ovs-vsctl add-port ovs_br0 ${type}_a -- \\\n\t\tset interface ${type}_a type=${type} \\\n\t\toptions:remote_ip=${b_addr} options:key=1 options:csum=true || return 1\n\n\trun_cmd ${ns_b} ip link add ${type}_b type ${type} id 1 ${opts_b} remote ${a_addr} ${opts} || return 1\n\n\trun_cmd ${ns_b} ip addr add ${tunnel4_b_addr}/${tunnel4_mask} dev ${type}_b\n\trun_cmd ${ns_b} ip addr add ${tunnel6_b_addr}/${tunnel6_mask} dev ${type}_b\n\n\trun_cmd ${ns_b} ip link set ${type}_b up\n}\n\nsetup_ovs_geneve4() {\n\tsetup_ovs_vxlan_or_geneve geneve ${prefix4}.${a_r1}.1  ${prefix4}.${b_r1}.1\n}\n\nsetup_ovs_vxlan4() {\n\tsetup_ovs_vxlan_or_geneve vxlan  ${prefix4}.${a_r1}.1  ${prefix4}.${b_r1}.1\n}\n\nsetup_ovs_geneve6() {\n\tsetup_ovs_vxlan_or_geneve geneve ${prefix6}:${a_r1}::1 ${prefix6}:${b_r1}::1\n}\n\nsetup_ovs_vxlan6() {\n\tsetup_ovs_vxlan_or_geneve vxlan  ${prefix6}:${a_r1}::1 ${prefix6}:${b_r1}::1\n}\n\nsetup_ovs_bridge() {\n\trun_cmd ovs-vsctl add-br ovs_br0 || return $ksft_skip\n\trun_cmd ip link set ovs_br0 up\n\n\trun_cmd ${ns_c} ip link add veth_C-A type veth peer name veth_A-C\n\trun_cmd ${ns_c} ip link set veth_A-C netns 1\n\n\trun_cmd         ip link set veth_A-C up\n\trun_cmd ${ns_c} ip link set veth_C-A up\n\trun_cmd ${ns_c} ip addr add ${veth4_c_addr}/${veth4_mask} dev veth_C-A\n\trun_cmd ${ns_c} ip addr add ${veth6_c_addr}/${veth6_mask} dev veth_C-A\n\trun_cmd ovs-vsctl add-port ovs_br0 veth_A-C\n\n\t# Move veth_A-R1 to init\n\trun_cmd ${ns_a} ip link set veth_A-R1 netns 1\n\trun_cmd ip addr add ${prefix4}.${a_r1}.1/${veth4_mask} dev veth_A-R1\n\trun_cmd ip addr add ${prefix6}:${a_r1}::1/${veth6_mask} dev veth_A-R1\n\trun_cmd ip link set veth_A-R1 up\n\trun_cmd ip route add ${prefix4}.${b_r1}.1 via ${prefix4}.${a_r1}.2\n\trun_cmd ip route add ${prefix6}:${b_r1}::1 via ${prefix6}:${a_r1}::2\n}\n\nsetup() {\n\t[ \"$(id -u)\" -ne 0 ] && echo \"  need to run as root\" && return $ksft_skip\n\n\tfor arg do\n\t\teval setup_${arg} || { echo \"  ${arg} not supported\"; return 1; }\n\tdone\n}\n\ntrace() {\n\t[ $TRACING -eq 0 ] && return\n\n\tfor arg do\n\t\t[ \"${ns_cmd}\" = \"\" ] && ns_cmd=\"${arg}\" && continue\n\t\t${ns_cmd} tcpdump --immediate-mode -s 0 -i \"${arg}\" -w \"${name}_${arg}.pcap\" 2> /dev/null &\n\t\ttcpdump_pids=\"${tcpdump_pids} $!\"\n\t\tns_cmd=\n\tdone\n\tsleep 1\n}\n\ncleanup() {\n\tfor pid in ${tcpdump_pids}; do\n\t\tkill ${pid}\n\tdone\n\ttcpdump_pids=\n\n\tfor pid in ${nettest_pids}; do\n\t\tkill ${pid}\n\tdone\n\tnettest_pids=\n\n\tfor pid in ${socat_pids}; do\n\t\tkill \"${pid}\"\n\tdone\n\tsocat_pids=\n\n\tfor n in ${NS_A} ${NS_B} ${NS_C} ${NS_R1} ${NS_R2}; do\n\t\tip netns del ${n} 2> /dev/null\n\tdone\n\n\tip link del veth_A-C\t\t\t2>/dev/null\n\tip link del veth_A-R1\t\t\t2>/dev/null\n\tovs-vsctl --if-exists del-port vxlan_a\t2>/dev/null\n\tovs-vsctl --if-exists del-br ovs_br0\t2>/dev/null\n\trm -f \"$tmpoutfile\"\n}\n\nmtu() {\n\tns_cmd=\"${1}\"\n\tdev=\"${2}\"\n\tmtu=\"${3}\"\n\n\t${ns_cmd} ip link set dev ${dev} mtu ${mtu}\n}\n\nmtu_parse() {\n\tinput=\"${1}\"\n\n\tnext=0\n\tfor i in ${input}; do\n\t\t[ ${next} -eq 1 -a \"${i}\" = \"lock\" ] && next=2 && continue\n\t\t[ ${next} -eq 1 ] && echo \"${i}\" && return\n\t\t[ ${next} -eq 2 ] && echo \"lock ${i}\" && return\n\t\t[ \"${i}\" = \"mtu\" ] && next=1\n\tdone\n}\n\nlink_get() {\n\tns_cmd=\"${1}\"\n\tname=\"${2}\"\n\n\t${ns_cmd} ip link show dev \"${name}\"\n}\n\nlink_get_mtu() {\n\tns_cmd=\"${1}\"\n\tname=\"${2}\"\n\n\tmtu_parse \"$(link_get \"${ns_cmd}\" ${name})\"\n}\n\nroute_get_dst_exception() {\n\tns_cmd=\"${1}\"\n\tdst=\"${2}\"\n\tdsfield=\"${3}\"\n\n\tif [ -z \"${dsfield}\" ]; then\n\t\tdsfield=0\n\tfi\n\n\t${ns_cmd} ip route get \"${dst}\" dsfield \"${dsfield}\"\n}\n\nroute_get_dst_pmtu_from_exception() {\n\tns_cmd=\"${1}\"\n\tdst=\"${2}\"\n\tdsfield=\"${3}\"\n\n\tmtu_parse \"$(route_get_dst_exception \"${ns_cmd}\" \"${dst}\" \"${dsfield}\")\"\n}\n\ncheck_pmtu_value() {\n\texpected=\"${1}\"\n\tvalue=\"${2}\"\n\tevent=\"${3}\"\n\n\t[ \"${expected}\" = \"any\" ] && [ -n \"${value}\" ] && return 0\n\t[ \"${value}\" = \"${expected}\" ] && return 0\n\t[ -z \"${value}\" ] &&    err \"  PMTU exception wasn't created after ${event}\" && return 1\n\t[ -z \"${expected}\" ] && err \"  PMTU exception shouldn't exist after ${event}\" && return 1\n\terr \"  found PMTU exception with incorrect MTU ${value}, expected ${expected}, after ${event}\"\n\treturn 1\n}\n\ntest_pmtu_ipvX() {\n\tfamily=${1}\n\n\tsetup namespaces routing || return $ksft_skip\n\ttrace \"${ns_a}\"  veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_r1}\" veth_R1-B    \"${ns_b}\"  veth_B-R1 \\\n\t      \"${ns_a}\"  veth_A-R2    \"${ns_r2}\" veth_R2-A \\\n\t      \"${ns_r2}\" veth_R2-B    \"${ns_b}\"  veth_B-R2\n\n\tif [ ${family} -eq 4 ]; then\n\t\tping=ping\n\t\tdst1=\"${prefix4}.${b_r1}.1\"\n\t\tdst2=\"${prefix4}.${b_r2}.1\"\n\telse\n\t\tping=${ping6}\n\t\tdst1=\"${prefix6}:${b_r1}::1\"\n\t\tdst2=\"${prefix6}:${b_r2}::1\"\n\tfi\n\n\t# Set up initial MTU values\n\tmtu \"${ns_a}\"  veth_A-R1 2000\n\tmtu \"${ns_r1}\" veth_R1-A 2000\n\tmtu \"${ns_r1}\" veth_R1-B 1400\n\tmtu \"${ns_b}\"  veth_B-R1 1400\n\n\tmtu \"${ns_a}\"  veth_A-R2 2000\n\tmtu \"${ns_r2}\" veth_R2-A 2000\n\tmtu \"${ns_r2}\" veth_R2-B 1500\n\tmtu \"${ns_b}\"  veth_B-R2 1500\n\n\t# Create route exceptions\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1 -s 1800 ${dst1}\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1 -s 1800 ${dst2}\n\n\t# Check that exceptions have been created with the correct PMTU\n\tpmtu_1=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst1})\"\n\tcheck_pmtu_value \"1400\" \"${pmtu_1}\" \"exceeding MTU\" || return 1\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst2})\"\n\tcheck_pmtu_value \"1500\" \"${pmtu_2}\" \"exceeding MTU\" || return 1\n\n\t# Decrease local MTU below PMTU, check for PMTU decrease in route exception\n\tmtu \"${ns_a}\"  veth_A-R1 1300\n\tmtu \"${ns_r1}\" veth_R1-A 1300\n\tpmtu_1=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst1})\"\n\tcheck_pmtu_value \"1300\" \"${pmtu_1}\" \"decreasing local MTU\" || return 1\n\t# Second exception shouldn't be modified\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst2})\"\n\tcheck_pmtu_value \"1500\" \"${pmtu_2}\" \"changing local MTU on a link not on this path\" || return 1\n\n\t# Increase MTU, check for PMTU increase in route exception\n\tmtu \"${ns_a}\"  veth_A-R1 1700\n\tmtu \"${ns_r1}\" veth_R1-A 1700\n\tpmtu_1=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst1})\"\n\tcheck_pmtu_value \"1700\" \"${pmtu_1}\" \"increasing local MTU\" || return 1\n\t# Second exception shouldn't be modified\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst2})\"\n\tcheck_pmtu_value \"1500\" \"${pmtu_2}\" \"changing local MTU on a link not on this path\" || return 1\n\n\t# Skip PMTU locking tests for IPv6\n\t[ $family -eq 6 ] && return 0\n\n\t# Decrease remote MTU on path via R2, get new exception\n\tmtu \"${ns_r2}\" veth_R2-B 400\n\tmtu \"${ns_b}\"  veth_B-R2 400\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1 -s 1400 ${dst2}\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst2})\"\n\tcheck_pmtu_value \"lock 552\" \"${pmtu_2}\" \"exceeding MTU, with MTU < min_pmtu\" || return 1\n\n\t# Decrease local MTU below PMTU\n\tmtu \"${ns_a}\"  veth_A-R2 500\n\tmtu \"${ns_r2}\" veth_R2-A 500\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst2})\"\n\tcheck_pmtu_value \"500\" \"${pmtu_2}\" \"decreasing local MTU\" || return 1\n\n\t# Increase local MTU\n\tmtu \"${ns_a}\"  veth_A-R2 1500\n\tmtu \"${ns_r2}\" veth_R2-A 1500\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst2})\"\n\tcheck_pmtu_value \"1500\" \"${pmtu_2}\" \"increasing local MTU\" || return 1\n\n\t# Get new exception\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1 -s 1400 ${dst2}\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst2})\"\n\tcheck_pmtu_value \"lock 552\" \"${pmtu_2}\" \"exceeding MTU, with MTU < min_pmtu\" || return 1\n}\n\ntest_pmtu_ipv4_exception() {\n\ttest_pmtu_ipvX 4\n}\n\ntest_pmtu_ipv6_exception() {\n\ttest_pmtu_ipvX 6\n}\n\ntest_pmtu_ipv4_dscp_icmp_exception() {\n\trt_table=100\n\n\tsetup namespaces policy_routing || return $ksft_skip\n\ttrace \"${ns_a}\"  veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_r1}\" veth_R1-B    \"${ns_b}\"  veth_B-R1 \\\n\t      \"${ns_a}\"  veth_A-R2    \"${ns_r2}\" veth_R2-A \\\n\t      \"${ns_r2}\" veth_R2-B    \"${ns_b}\"  veth_B-R2\n\n\t# Set up initial MTU values\n\tmtu \"${ns_a}\"  veth_A-R1 2000\n\tmtu \"${ns_r1}\" veth_R1-A 2000\n\tmtu \"${ns_r1}\" veth_R1-B 1400\n\tmtu \"${ns_b}\"  veth_B-R1 1400\n\n\tmtu \"${ns_a}\"  veth_A-R2 2000\n\tmtu \"${ns_r2}\" veth_R2-A 2000\n\tmtu \"${ns_r2}\" veth_R2-B 1500\n\tmtu \"${ns_b}\"  veth_B-R2 1500\n\n\tlen=$((2000 - 20 - 8)) # Fills MTU of veth_A-R1\n\n\tdst1=\"${prefix4}.${b_r1}.1\"\n\tdst2=\"${prefix4}.${b_r2}.1\"\n\n\t# Create route exceptions\n\tdsfield=${policy_mark} # No ECN bit set (Not-ECT)\n\trun_cmd \"${ns_a}\" ping -q -M want -Q \"${dsfield}\" -c 1 -w 1 -s \"${len}\" \"${dst1}\"\n\n\tdsfield=$(printf \"%#x\" $((policy_mark + 0x02))) # ECN=2 (ECT(0))\n\trun_cmd \"${ns_a}\" ping -q -M want -Q \"${dsfield}\" -c 1 -w 1 -s \"${len}\" \"${dst2}\"\n\n\t# Check that exceptions have been created with the correct PMTU\n\tpmtu_1=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" \"${dst1}\" \"${policy_mark}\")\"\n\tcheck_pmtu_value \"1400\" \"${pmtu_1}\" \"exceeding MTU\" || return 1\n\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" \"${dst2}\" \"${policy_mark}\")\"\n\tcheck_pmtu_value \"1500\" \"${pmtu_2}\" \"exceeding MTU\" || return 1\n}\n\ntest_pmtu_ipv4_dscp_udp_exception() {\n\trt_table=100\n\n\tif ! which socat > /dev/null 2>&1; then\n\t\techo \"'socat' command not found; skipping tests\"\n\t\treturn $ksft_skip\n\tfi\n\n\tsetup namespaces policy_routing || return $ksft_skip\n\ttrace \"${ns_a}\"  veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_r1}\" veth_R1-B    \"${ns_b}\"  veth_B-R1 \\\n\t      \"${ns_a}\"  veth_A-R2    \"${ns_r2}\" veth_R2-A \\\n\t      \"${ns_r2}\" veth_R2-B    \"${ns_b}\"  veth_B-R2\n\n\t# Set up initial MTU values\n\tmtu \"${ns_a}\"  veth_A-R1 2000\n\tmtu \"${ns_r1}\" veth_R1-A 2000\n\tmtu \"${ns_r1}\" veth_R1-B 1400\n\tmtu \"${ns_b}\"  veth_B-R1 1400\n\n\tmtu \"${ns_a}\"  veth_A-R2 2000\n\tmtu \"${ns_r2}\" veth_R2-A 2000\n\tmtu \"${ns_r2}\" veth_R2-B 1500\n\tmtu \"${ns_b}\"  veth_B-R2 1500\n\n\tlen=$((2000 - 20 - 8)) # Fills MTU of veth_A-R1\n\n\tdst1=\"${prefix4}.${b_r1}.1\"\n\tdst2=\"${prefix4}.${b_r2}.1\"\n\n\t# Create route exceptions\n\trun_cmd_bg \"${ns_b}\" socat UDP-LISTEN:50000 OPEN:/dev/null,wronly=1\n\tsocat_pids=\"${socat_pids} $!\"\n\n\tdsfield=${policy_mark} # No ECN bit set (Not-ECT)\n\trun_cmd \"${ns_a}\" socat OPEN:/dev/zero,rdonly=1,readbytes=\"${len}\" \\\n\t\tUDP:\"${dst1}\":50000,tos=\"${dsfield}\"\n\n\tdsfield=$(printf \"%#x\" $((policy_mark + 0x02))) # ECN=2 (ECT(0))\n\trun_cmd \"${ns_a}\" socat OPEN:/dev/zero,rdonly=1,readbytes=\"${len}\" \\\n\t\tUDP:\"${dst2}\":50000,tos=\"${dsfield}\"\n\n\t# Check that exceptions have been created with the correct PMTU\n\tpmtu_1=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" \"${dst1}\" \"${policy_mark}\")\"\n\tcheck_pmtu_value \"1400\" \"${pmtu_1}\" \"exceeding MTU\" || return 1\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" \"${dst2}\" \"${policy_mark}\")\"\n\tcheck_pmtu_value \"1500\" \"${pmtu_2}\" \"exceeding MTU\" || return 1\n}\n\ntest_pmtu_ipvX_over_vxlanY_or_geneveY_exception() {\n\ttype=${1}\n\tfamily=${2}\n\touter_family=${3}\n\tll_mtu=4000\n\n\tif [ ${outer_family} -eq 4 ]; then\n\t\tsetup namespaces routing ${type}4 || return $ksft_skip\n\t\t#                      IPv4 header   UDP header   VXLAN/GENEVE header   Ethernet header\n\t\texp_mtu=$((${ll_mtu} - 20          - 8          - 8                   - 14))\n\telse\n\t\tsetup namespaces routing ${type}6 || return $ksft_skip\n\t\t#                      IPv6 header   UDP header   VXLAN/GENEVE header   Ethernet header\n\t\texp_mtu=$((${ll_mtu} - 40          - 8          - 8                   - 14))\n\tfi\n\n\ttrace \"${ns_a}\" ${type}_a    \"${ns_b}\"  ${type}_b \\\n\t      \"${ns_a}\" veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_b}\" veth_B-R1    \"${ns_r1}\" veth_R1-B\n\n\tif [ ${family} -eq 4 ]; then\n\t\tping=ping\n\t\tdst=${tunnel4_b_addr}\n\telse\n\t\tping=${ping6}\n\t\tdst=${tunnel6_b_addr}\n\tfi\n\n\t# Create route exception by exceeding link layer MTU\n\tmtu \"${ns_a}\"  veth_A-R1 $((${ll_mtu} + 1000))\n\tmtu \"${ns_r1}\" veth_R1-A $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\"  veth_B-R1 ${ll_mtu}\n\tmtu \"${ns_r1}\" veth_R1-B ${ll_mtu}\n\n\tmtu \"${ns_a}\" ${type}_a $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\" ${type}_b $((${ll_mtu} + 1000))\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1 -s $((${ll_mtu} + 500)) ${dst}\n\n\t# Check that exception was created\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst})\"\n\tcheck_pmtu_value ${exp_mtu} \"${pmtu}\" \"exceeding link layer MTU on ${type} interface\"\n}\n\ntest_pmtu_ipv4_vxlan4_exception() {\n\ttest_pmtu_ipvX_over_vxlanY_or_geneveY_exception vxlan  4 4\n}\n\ntest_pmtu_ipv6_vxlan4_exception() {\n\ttest_pmtu_ipvX_over_vxlanY_or_geneveY_exception vxlan  6 4\n}\n\ntest_pmtu_ipv4_geneve4_exception() {\n\ttest_pmtu_ipvX_over_vxlanY_or_geneveY_exception geneve 4 4\n}\n\ntest_pmtu_ipv6_geneve4_exception() {\n\ttest_pmtu_ipvX_over_vxlanY_or_geneveY_exception geneve 6 4\n}\n\ntest_pmtu_ipv4_vxlan6_exception() {\n\ttest_pmtu_ipvX_over_vxlanY_or_geneveY_exception vxlan  4 6\n}\n\ntest_pmtu_ipv6_vxlan6_exception() {\n\ttest_pmtu_ipvX_over_vxlanY_or_geneveY_exception vxlan  6 6\n}\n\ntest_pmtu_ipv4_geneve6_exception() {\n\ttest_pmtu_ipvX_over_vxlanY_or_geneveY_exception geneve 4 6\n}\n\ntest_pmtu_ipv6_geneve6_exception() {\n\ttest_pmtu_ipvX_over_vxlanY_or_geneveY_exception geneve 6 6\n}\n\ntest_pmtu_ipvX_over_bridged_vxlanY_or_geneveY_exception() {\n\ttype=${1}\n\tfamily=${2}\n\touter_family=${3}\n\tll_mtu=4000\n\n\tif [ ${outer_family} -eq 4 ]; then\n\t\tsetup namespaces routing bridge bridged_${type}4 || return $ksft_skip\n\t\t#                      IPv4 header   UDP header   VXLAN/GENEVE header   Ethernet header\n\t\texp_mtu=$((${ll_mtu} - 20          - 8          - 8                   - 14))\n\telse\n\t\tsetup namespaces routing bridge bridged_${type}6 || return $ksft_skip\n\t\t#                      IPv6 header   UDP header   VXLAN/GENEVE header   Ethernet header\n\t\texp_mtu=$((${ll_mtu} - 40          - 8          - 8                   - 14))\n\tfi\n\n\ttrace \"${ns_a}\" ${type}_a    \"${ns_b}\"  ${type}_b \\\n\t      \"${ns_a}\" veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_b}\" veth_B-R1    \"${ns_r1}\" veth_R1-B \\\n\t      \"${ns_a}\" br0          \"${ns_a}\"  veth-A-C  \\\n\t      \"${ns_c}\" veth_C-A\n\n\tif [ ${family} -eq 4 ]; then\n\t\tping=ping\n\t\tdst=${tunnel4_b_addr}\n\telse\n\t\tping=${ping6}\n\t\tdst=${tunnel6_b_addr}\n\tfi\n\n\t# Create route exception by exceeding link layer MTU\n\tmtu \"${ns_a}\"  veth_A-R1 $((${ll_mtu} + 1000))\n\tmtu \"${ns_a}\"  br0       $((${ll_mtu} + 1000))\n\tmtu \"${ns_a}\"  veth_A-C  $((${ll_mtu} + 1000))\n\tmtu \"${ns_c}\"  veth_C-A  $((${ll_mtu} + 1000))\n\tmtu \"${ns_r1}\" veth_R1-A $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\"  veth_B-R1 ${ll_mtu}\n\tmtu \"${ns_r1}\" veth_R1-B ${ll_mtu}\n\n\tmtu \"${ns_a}\" ${type}_a $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\" ${type}_b $((${ll_mtu} + 1000))\n\n\trun_cmd ${ns_c} ${ping} -q -M want -i 0.1 -c 10 -s $((${ll_mtu} + 500)) ${dst} || return 1\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1  -s $((${ll_mtu} + 500)) ${dst} || return 1\n\n\t# Check that exceptions were created\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_c}\" ${dst})\"\n\tcheck_pmtu_value ${exp_mtu} \"${pmtu}\" \"exceeding link layer MTU on bridged ${type} interface\"\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst})\"\n\tcheck_pmtu_value ${exp_mtu} \"${pmtu}\" \"exceeding link layer MTU on locally bridged ${type} interface\"\n\n\ttmpoutfile=$(mktemp)\n\n\t# Flush Exceptions, retry with TCP\n\trun_cmd ${ns_a} ip route flush cached ${dst}\n\trun_cmd ${ns_b} ip route flush cached ${dst}\n\trun_cmd ${ns_c} ip route flush cached ${dst}\n\n\tfor target in \"${ns_a}\" \"${ns_c}\" ; do\n\t\tif [ ${family} -eq 4 ]; then\n\t\t\tTCPDST=TCP:${dst}:50000\n\t\telse\n\t\t\tTCPDST=\"TCP:[${dst}]:50000\"\n\t\tfi\n\t\t${ns_b} socat -T 3 -u -6 TCP-LISTEN:50000 STDOUT > $tmpoutfile &\n\n\t\tsleep 1\n\n\t\tdd if=/dev/zero of=/dev/stdout status=none bs=1M count=1 | ${target} socat -T 3 -u STDIN $TCPDST,connect-timeout=3\n\n\t\tsize=$(du -sb $tmpoutfile)\n\t\tsize=${size%%/tmp/*}\n\n\t\t[ $size -ne 1048576 ] && err \"File size $size mismatches exepcted value in locally bridged vxlan test\" && return 1\n\tdone\n\n\trm -f \"$tmpoutfile\"\n\n\t# Check that exceptions were created\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_c}\" ${dst})\"\n\tcheck_pmtu_value ${exp_mtu} \"${pmtu}\" \"tcp: exceeding link layer MTU on bridged ${type} interface\"\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst})\"\n\tcheck_pmtu_value ${exp_mtu} \"${pmtu}\" \"tcp exceeding link layer MTU on locally bridged ${type} interface\"\n}\n\ntest_pmtu_ipv4_br_vxlan4_exception() {\n\ttest_pmtu_ipvX_over_bridged_vxlanY_or_geneveY_exception vxlan  4 4\n}\n\ntest_pmtu_ipv6_br_vxlan4_exception() {\n\ttest_pmtu_ipvX_over_bridged_vxlanY_or_geneveY_exception vxlan  6 4\n}\n\ntest_pmtu_ipv4_br_geneve4_exception() {\n\ttest_pmtu_ipvX_over_bridged_vxlanY_or_geneveY_exception geneve 4 4\n}\n\ntest_pmtu_ipv6_br_geneve4_exception() {\n\ttest_pmtu_ipvX_over_bridged_vxlanY_or_geneveY_exception geneve 6 4\n}\n\ntest_pmtu_ipv4_br_vxlan6_exception() {\n\ttest_pmtu_ipvX_over_bridged_vxlanY_or_geneveY_exception vxlan  4 6\n}\n\ntest_pmtu_ipv6_br_vxlan6_exception() {\n\ttest_pmtu_ipvX_over_bridged_vxlanY_or_geneveY_exception vxlan  6 6\n}\n\ntest_pmtu_ipv4_br_geneve6_exception() {\n\ttest_pmtu_ipvX_over_bridged_vxlanY_or_geneveY_exception geneve 4 6\n}\n\ntest_pmtu_ipv6_br_geneve6_exception() {\n\ttest_pmtu_ipvX_over_bridged_vxlanY_or_geneveY_exception geneve 6 6\n}\n\ntest_pmtu_ipvX_over_ovs_vxlanY_or_geneveY_exception() {\n\ttype=${1}\n\tfamily=${2}\n\touter_family=${3}\n\tll_mtu=4000\n\n\tif [ ${outer_family} -eq 4 ]; then\n\t\tsetup namespaces routing ovs_bridge ovs_${type}4 || return $ksft_skip\n\t\t#                      IPv4 header   UDP header   VXLAN/GENEVE header   Ethernet header\n\t\texp_mtu=$((${ll_mtu} - 20          - 8          - 8                   - 14))\n\telse\n\t\tsetup namespaces routing ovs_bridge ovs_${type}6 || return $ksft_skip\n\t\t#                      IPv6 header   UDP header   VXLAN/GENEVE header   Ethernet header\n\t\texp_mtu=$((${ll_mtu} - 40          - 8          - 8                   - 14))\n\tfi\n\n\tif [ \"${type}\" = \"vxlan\" ]; then\n\t\ttun_a=\"vxlan_sys_4789\"\n\telif [ \"${type}\" = \"geneve\" ]; then\n\t\ttun_a=\"genev_sys_6081\"\n\tfi\n\n\ttrace \"\"        \"${tun_a}\"  \"${ns_b}\"  ${type}_b \\\n\t      \"\"        veth_A-R1   \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_b}\" veth_B-R1   \"${ns_r1}\" veth_R1-B \\\n\t      \"\"        ovs_br0     \"\"         veth-A-C  \\\n\t      \"${ns_c}\" veth_C-A\n\n\tif [ ${family} -eq 4 ]; then\n\t\tping=ping\n\t\tdst=${tunnel4_b_addr}\n\telse\n\t\tping=${ping6}\n\t\tdst=${tunnel6_b_addr}\n\tfi\n\n\t# Create route exception by exceeding link layer MTU\n\tmtu \"\"         veth_A-R1 $((${ll_mtu} + 1000))\n\tmtu \"\"         ovs_br0   $((${ll_mtu} + 1000))\n\tmtu \"\"         veth_A-C  $((${ll_mtu} + 1000))\n\tmtu \"${ns_c}\"  veth_C-A  $((${ll_mtu} + 1000))\n\tmtu \"${ns_r1}\" veth_R1-A $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\"  veth_B-R1 ${ll_mtu}\n\tmtu \"${ns_r1}\" veth_R1-B ${ll_mtu}\n\n\tmtu \"\"        ${tun_a}  $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\" ${type}_b $((${ll_mtu} + 1000))\n\n\trun_cmd ${ns_c} ${ping} -q -M want -i 0.1 -c 20 -s $((${ll_mtu} + 500)) ${dst} || return 1\n\n\t# Check that exceptions were created\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_c}\" ${dst})\"\n\tcheck_pmtu_value ${exp_mtu} \"${pmtu}\" \"exceeding link layer MTU on Open vSwitch ${type} interface\"\n}\n\ntest_pmtu_ipv4_ovs_vxlan4_exception() {\n\ttest_pmtu_ipvX_over_ovs_vxlanY_or_geneveY_exception vxlan  4 4\n}\n\ntest_pmtu_ipv6_ovs_vxlan4_exception() {\n\ttest_pmtu_ipvX_over_ovs_vxlanY_or_geneveY_exception vxlan  6 4\n}\n\ntest_pmtu_ipv4_ovs_geneve4_exception() {\n\ttest_pmtu_ipvX_over_ovs_vxlanY_or_geneveY_exception geneve 4 4\n}\n\ntest_pmtu_ipv6_ovs_geneve4_exception() {\n\ttest_pmtu_ipvX_over_ovs_vxlanY_or_geneveY_exception geneve 6 4\n}\n\ntest_pmtu_ipv4_ovs_vxlan6_exception() {\n\ttest_pmtu_ipvX_over_ovs_vxlanY_or_geneveY_exception vxlan  4 6\n}\n\ntest_pmtu_ipv6_ovs_vxlan6_exception() {\n\ttest_pmtu_ipvX_over_ovs_vxlanY_or_geneveY_exception vxlan  6 6\n}\n\ntest_pmtu_ipv4_ovs_geneve6_exception() {\n\ttest_pmtu_ipvX_over_ovs_vxlanY_or_geneveY_exception geneve 4 6\n}\n\ntest_pmtu_ipv6_ovs_geneve6_exception() {\n\ttest_pmtu_ipvX_over_ovs_vxlanY_or_geneveY_exception geneve 6 6\n}\n\ntest_pmtu_ipvX_over_fouY_or_gueY() {\n\tinner_family=${1}\n\touter_family=${2}\n\tencap=${3}\n\tll_mtu=4000\n\n\tsetup namespaces routing ${encap}${outer_family}${inner_family} || return $ksft_skip\n\ttrace \"${ns_a}\" ${encap}_a   \"${ns_b}\"  ${encap}_b \\\n\t      \"${ns_a}\" veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_b}\" veth_B-R1    \"${ns_r1}\" veth_R1-B\n\n\tif [ ${inner_family} -eq 4 ]; then\n\t\tping=ping\n\t\tdst=${tunnel4_b_addr}\n\telse\n\t\tping=${ping6}\n\t\tdst=${tunnel6_b_addr}\n\tfi\n\n\tif [ \"${encap}\" = \"gue\" ]; then\n\t\tencap_overhead=4\n\telse\n\t\tencap_overhead=0\n\tfi\n\n\tif [ ${outer_family} -eq 4 ]; then\n\t\t#                      IPv4 header   UDP header\n\t\texp_mtu=$((${ll_mtu} - 20          - 8         - ${encap_overhead}))\n\telse\n\t\t#                      IPv6 header   Option 4   UDP header\n\t\texp_mtu=$((${ll_mtu} - 40          - 8        - 8       - ${encap_overhead}))\n\tfi\n\n\t# Create route exception by exceeding link layer MTU\n\tmtu \"${ns_a}\"  veth_A-R1 $((${ll_mtu} + 1000))\n\tmtu \"${ns_r1}\" veth_R1-A $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\"  veth_B-R1 ${ll_mtu}\n\tmtu \"${ns_r1}\" veth_R1-B ${ll_mtu}\n\n\tmtu \"${ns_a}\" ${encap}_a $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\" ${encap}_b $((${ll_mtu} + 1000))\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1 -s $((${ll_mtu} + 500)) ${dst}\n\n\t# Check that exception was created\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst})\"\n\tcheck_pmtu_value ${exp_mtu} \"${pmtu}\" \"exceeding link layer MTU on ${encap} interface\"\n}\n\ntest_pmtu_ipv4_fou4_exception() {\n\ttest_pmtu_ipvX_over_fouY_or_gueY 4 4 fou\n}\n\ntest_pmtu_ipv6_fou4_exception() {\n\ttest_pmtu_ipvX_over_fouY_or_gueY 6 4 fou\n}\n\ntest_pmtu_ipv4_fou6_exception() {\n\ttest_pmtu_ipvX_over_fouY_or_gueY 4 6 fou\n}\n\ntest_pmtu_ipv6_fou6_exception() {\n\ttest_pmtu_ipvX_over_fouY_or_gueY 6 6 fou\n}\n\ntest_pmtu_ipv4_gue4_exception() {\n\ttest_pmtu_ipvX_over_fouY_or_gueY 4 4 gue\n}\n\ntest_pmtu_ipv6_gue4_exception() {\n\ttest_pmtu_ipvX_over_fouY_or_gueY 6 4 gue\n}\n\ntest_pmtu_ipv4_gue6_exception() {\n\ttest_pmtu_ipvX_over_fouY_or_gueY 4 6 gue\n}\n\ntest_pmtu_ipv6_gue6_exception() {\n\ttest_pmtu_ipvX_over_fouY_or_gueY 6 6 gue\n}\n\ntest_pmtu_ipvX_over_ipvY_exception() {\n\tinner=${1}\n\touter=${2}\n\tll_mtu=4000\n\n\tsetup namespaces routing ip${inner}ip${outer} || return $ksft_skip\n\n\ttrace \"${ns_a}\" ip_a         \"${ns_b}\"  ip_b  \\\n\t      \"${ns_a}\" veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_b}\" veth_B-R1    \"${ns_r1}\" veth_R1-B\n\n\tif [ ${inner} -eq 4 ]; then\n\t\tping=ping\n\t\tdst=${tunnel4_b_addr}\n\telse\n\t\tping=${ping6}\n\t\tdst=${tunnel6_b_addr}\n\tfi\n\n\tif [ ${outer} -eq 4 ]; then\n\t\t#                      IPv4 header\n\t\texp_mtu=$((${ll_mtu} - 20))\n\telse\n\t\t#                      IPv6 header   Option 4\n\t\texp_mtu=$((${ll_mtu} - 40          - 8))\n\tfi\n\n\t# Create route exception by exceeding link layer MTU\n\tmtu \"${ns_a}\"  veth_A-R1 $((${ll_mtu} + 1000))\n\tmtu \"${ns_r1}\" veth_R1-A $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\"  veth_B-R1 ${ll_mtu}\n\tmtu \"${ns_r1}\" veth_R1-B ${ll_mtu}\n\n\tmtu \"${ns_a}\" ip_a $((${ll_mtu} + 1000)) || return\n\tmtu \"${ns_b}\" ip_b $((${ll_mtu} + 1000)) || return\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1 -s $((${ll_mtu} + 500)) ${dst}\n\n\t# Check that exception was created\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst})\"\n\tcheck_pmtu_value ${exp_mtu} \"${pmtu}\" \"exceeding link layer MTU on ip${inner}ip${outer} interface\"\n}\n\ntest_pmtu_ipv4_ipv4_exception() {\n\ttest_pmtu_ipvX_over_ipvY_exception 4 4\n}\n\ntest_pmtu_ipv6_ipv4_exception() {\n\ttest_pmtu_ipvX_over_ipvY_exception 6 4\n}\n\ntest_pmtu_ipv4_ipv6_exception() {\n\ttest_pmtu_ipvX_over_ipvY_exception 4 6\n}\n\ntest_pmtu_ipv6_ipv6_exception() {\n\ttest_pmtu_ipvX_over_ipvY_exception 6 6\n}\n\ntest_pmtu_vti4_exception() {\n\tsetup namespaces veth vti4 xfrm4 || return $ksft_skip\n\ttrace \"${ns_a}\" veth_a    \"${ns_b}\" veth_b \\\n\t      \"${ns_a}\" vti4_a    \"${ns_b}\" vti4_b\n\n\tveth_mtu=1500\n\tvti_mtu=$((veth_mtu - 20))\n\n\t#                                SPI   SN   IV  ICV   pad length   next header\n\tesp_payload_rfc4106=$((vti_mtu - 4   - 4  - 8 - 16  - 1          - 1))\n\tping_payload=$((esp_payload_rfc4106 - 28))\n\n\tmtu \"${ns_a}\" veth_a ${veth_mtu}\n\tmtu \"${ns_b}\" veth_b ${veth_mtu}\n\tmtu \"${ns_a}\" vti4_a ${vti_mtu}\n\tmtu \"${ns_b}\" vti4_b ${vti_mtu}\n\n\t# Send DF packet without exceeding link layer MTU, check that no\n\t# exception is created\n\trun_cmd ${ns_a} ping -q -M want -i 0.1 -w 1 -s ${ping_payload} ${tunnel4_b_addr}\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel4_b_addr})\"\n\tcheck_pmtu_value \"\" \"${pmtu}\" \"sending packet smaller than PMTU (IP payload length ${esp_payload_rfc4106})\" || return 1\n\n\t# Now exceed link layer MTU by one byte, check that exception is created\n\t# with the right PMTU value\n\trun_cmd ${ns_a} ping -q -M want -i 0.1 -w 1 -s $((ping_payload + 1)) ${tunnel4_b_addr}\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel4_b_addr})\"\n\tcheck_pmtu_value \"${esp_payload_rfc4106}\" \"${pmtu}\" \"exceeding PMTU (IP payload length $((esp_payload_rfc4106 + 1)))\"\n}\n\ntest_pmtu_vti6_exception() {\n\tsetup namespaces veth vti6 xfrm6 || return $ksft_skip\n\ttrace \"${ns_a}\" veth_a    \"${ns_b}\" veth_b \\\n\t      \"${ns_a}\" vti6_a    \"${ns_b}\" vti6_b\n\tfail=0\n\n\t# Create route exception by exceeding link layer MTU\n\tmtu \"${ns_a}\" veth_a 4000\n\tmtu \"${ns_b}\" veth_b 4000\n\tmtu \"${ns_a}\" vti6_a 5000\n\tmtu \"${ns_b}\" vti6_b 5000\n\trun_cmd ${ns_a} ${ping6} -q -i 0.1 -w 1 -s 60000 ${tunnel6_b_addr}\n\n\t# Check that exception was created\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel6_b_addr})\"\n\tcheck_pmtu_value any \"${pmtu}\" \"creating tunnel exceeding link layer MTU\" || return 1\n\n\t# Decrease tunnel MTU, check for PMTU decrease in route exception\n\tmtu \"${ns_a}\" vti6_a 3000\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel6_b_addr})\"\n\tcheck_pmtu_value \"3000\" \"${pmtu}\" \"decreasing tunnel MTU\" || fail=1\n\n\t# Increase tunnel MTU, check for PMTU increase in route exception\n\tmtu \"${ns_a}\" vti6_a 9000\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel6_b_addr})\"\n\tcheck_pmtu_value \"9000\" \"${pmtu}\" \"increasing tunnel MTU\" || fail=1\n\n\treturn ${fail}\n}\n\ntest_pmtu_vti4_udp_exception() {\n\tsetup namespaces veth vti4 xfrm4udp || return $ksft_skip\n\ttrace \"${ns_a}\" veth_a    \"${ns_b}\" veth_b \\\n\t      \"${ns_a}\" vti4_a    \"${ns_b}\" vti4_b\n\n\tveth_mtu=1500\n\tvti_mtu=$((veth_mtu - 20))\n\n\t#                                UDP   SPI   SN   IV  ICV   pad length   next header\n\tesp_payload_rfc4106=$((vti_mtu - 8   - 4   - 4  - 8 - 16  - 1          - 1))\n\tping_payload=$((esp_payload_rfc4106 - 28))\n\n\tmtu \"${ns_a}\" veth_a ${veth_mtu}\n\tmtu \"${ns_b}\" veth_b ${veth_mtu}\n\tmtu \"${ns_a}\" vti4_a ${vti_mtu}\n\tmtu \"${ns_b}\" vti4_b ${vti_mtu}\n\n\t# Send DF packet without exceeding link layer MTU, check that no\n\t# exception is created\n\trun_cmd ${ns_a} ping -q -M want -i 0.1 -w 1 -s ${ping_payload} ${tunnel4_b_addr}\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel4_b_addr})\"\n\tcheck_pmtu_value \"\" \"${pmtu}\" \"sending packet smaller than PMTU (IP payload length ${esp_payload_rfc4106})\" || return 1\n\n\t# Now exceed link layer MTU by one byte, check that exception is created\n\t# with the right PMTU value\n\trun_cmd ${ns_a} ping -q -M want -i 0.1 -w 1 -s $((ping_payload + 1)) ${tunnel4_b_addr}\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel4_b_addr})\"\n\tcheck_pmtu_value \"${esp_payload_rfc4106}\" \"${pmtu}\" \"exceeding PMTU (IP payload length $((esp_payload_rfc4106 + 1)))\"\n}\n\ntest_pmtu_vti6_udp_exception() {\n\tsetup namespaces veth vti6 xfrm6udp || return $ksft_skip\n\ttrace \"${ns_a}\" veth_a    \"${ns_b}\" veth_b \\\n\t      \"${ns_a}\" vti6_a    \"${ns_b}\" vti6_b\n\tfail=0\n\n\t# Create route exception by exceeding link layer MTU\n\tmtu \"${ns_a}\" veth_a 4000\n\tmtu \"${ns_b}\" veth_b 4000\n\tmtu \"${ns_a}\" vti6_a 5000\n\tmtu \"${ns_b}\" vti6_b 5000\n\trun_cmd ${ns_a} ${ping6} -q -i 0.1 -w 1 -s 60000 ${tunnel6_b_addr}\n\n\t# Check that exception was created\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel6_b_addr})\"\n\tcheck_pmtu_value any \"${pmtu}\" \"creating tunnel exceeding link layer MTU\" || return 1\n\n\t# Decrease tunnel MTU, check for PMTU decrease in route exception\n\tmtu \"${ns_a}\" vti6_a 3000\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel6_b_addr})\"\n\tcheck_pmtu_value \"3000\" \"${pmtu}\" \"decreasing tunnel MTU\" || fail=1\n\n\t# Increase tunnel MTU, check for PMTU increase in route exception\n\tmtu \"${ns_a}\" vti6_a 9000\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel6_b_addr})\"\n\tcheck_pmtu_value \"9000\" \"${pmtu}\" \"increasing tunnel MTU\" || fail=1\n\n\treturn ${fail}\n}\n\ntest_pmtu_vti4_udp_routed_exception() {\n\tsetup namespaces routing vti4routed xfrm4udprouted || return $ksft_skip\n\ttrace \"${ns_a}\" veth_A-R1    \"${ns_b}\" veth_B-R1 \\\n\t      \"${ns_a}\" vti4_a       \"${ns_b}\" vti4_b\n\n\tveth_mtu=1500\n\tvti_mtu=$((veth_mtu - 20))\n\n\t#                                UDP   SPI   SN   IV  ICV   pad length   next header\n\tesp_payload_rfc4106=$((vti_mtu - 8   - 4   - 4  - 8 - 16  - 1          - 1))\n\tping_payload=$((esp_payload_rfc4106 - 28))\n\n        mtu \"${ns_a}\"  veth_A-R1 ${veth_mtu}\n        mtu \"${ns_r1}\" veth_R1-A ${veth_mtu}\n        mtu \"${ns_b}\"  veth_B-R1 ${veth_mtu}\n        mtu \"${ns_r1}\" veth_R1-B ${veth_mtu}\n\n\tmtu \"${ns_a}\" vti4_a ${vti_mtu}\n\tmtu \"${ns_b}\" vti4_b ${vti_mtu}\n\n\t# Send DF packet without exceeding link layer MTU, check that no\n\t# exception is created\n\trun_cmd ${ns_a} ping -q -M want -i 0.1 -w 1 -s ${ping_payload} ${tunnel4_b_addr}\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel4_b_addr})\"\n\tcheck_pmtu_value \"\" \"${pmtu}\" \"sending packet smaller than PMTU (IP payload length ${esp_payload_rfc4106})\" || return 1\n\n\t# Now decrease link layer MTU by 8 bytes on R1, check that exception is created\n\t# with the right PMTU value\n        mtu \"${ns_r1}\" veth_R1-B $((veth_mtu - 8))\n\trun_cmd ${ns_a} ping -q -M want -i 0.1 -w 1 -s $((ping_payload)) ${tunnel4_b_addr}\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel4_b_addr})\"\n\tcheck_pmtu_value \"$((esp_payload_rfc4106 - 8))\" \"${pmtu}\" \"exceeding PMTU (IP payload length $((esp_payload_rfc4106)))\"\n}\n\ntest_pmtu_vti6_udp_routed_exception() {\n\tsetup namespaces routing vti6routed xfrm6udprouted || return $ksft_skip\n\ttrace \"${ns_a}\" veth_A-R1    \"${ns_b}\" veth_B-R1 \\\n\t      \"${ns_a}\" vti6_a       \"${ns_b}\" vti6_b\n\n\tveth_mtu=1500\n\tvti_mtu=$((veth_mtu - 40))\n\n\t#                                UDP   SPI   SN   IV  ICV   pad length   next header\n\tesp_payload_rfc4106=$((vti_mtu - 8   - 4   - 4  - 8 - 16  - 1          - 1))\n\tping_payload=$((esp_payload_rfc4106 - 48))\n\n        mtu \"${ns_a}\"  veth_A-R1 ${veth_mtu}\n        mtu \"${ns_r1}\" veth_R1-A ${veth_mtu}\n        mtu \"${ns_b}\"  veth_B-R1 ${veth_mtu}\n        mtu \"${ns_r1}\" veth_R1-B ${veth_mtu}\n\n\t# mtu \"${ns_a}\" vti6_a ${vti_mtu}\n\t# mtu \"${ns_b}\" vti6_b ${vti_mtu}\n\n\trun_cmd ${ns_a} ${ping6} -q -M want -i 0.1 -w 1 -s ${ping_payload} ${tunnel6_b_addr}\n\n\t# Check that exception was not created\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel6_b_addr})\"\n\tcheck_pmtu_value \"\" \"${pmtu}\" \"sending packet smaller than PMTU (IP payload length ${esp_payload_rfc4106})\" || return 1\n\n\t# Now decrease link layer MTU by 8 bytes on R1, check that exception is created\n\t# with the right PMTU value\n        mtu \"${ns_r1}\" veth_R1-B $((veth_mtu - 8))\n\trun_cmd ${ns_a} ${ping6} -q -M want -i 0.1 -w 1 -s $((ping_payload)) ${tunnel6_b_addr}\n\tpmtu=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${tunnel6_b_addr})\"\n\tcheck_pmtu_value \"$((esp_payload_rfc4106 - 8))\" \"${pmtu}\" \"exceeding PMTU (IP payload length $((esp_payload_rfc4106)))\"\n\n}\n\ntest_pmtu_vti4_default_mtu() {\n\tsetup namespaces veth vti4 || return $ksft_skip\n\n\t# Check that MTU of vti device is MTU of veth minus IPv4 header length\n\tveth_mtu=\"$(link_get_mtu \"${ns_a}\" veth_a)\"\n\tvti4_mtu=\"$(link_get_mtu \"${ns_a}\" vti4_a)\"\n\tif [ $((veth_mtu - vti4_mtu)) -ne 20 ]; then\n\t\terr \"  vti MTU ${vti4_mtu} is not veth MTU ${veth_mtu} minus IPv4 header length\"\n\t\treturn 1\n\tfi\n}\n\ntest_pmtu_vti6_default_mtu() {\n\tsetup namespaces veth vti6 || return $ksft_skip\n\n\t# Check that MTU of vti device is MTU of veth minus IPv6 header length\n\tveth_mtu=\"$(link_get_mtu \"${ns_a}\" veth_a)\"\n\tvti6_mtu=\"$(link_get_mtu \"${ns_a}\" vti6_a)\"\n\tif [ $((veth_mtu - vti6_mtu)) -ne 40 ]; then\n\t\terr \"  vti MTU ${vti6_mtu} is not veth MTU ${veth_mtu} minus IPv6 header length\"\n\t\treturn 1\n\tfi\n}\n\ntest_pmtu_vti4_link_add_mtu() {\n\tsetup namespaces || return $ksft_skip\n\n\trun_cmd ${ns_a} ip link add vti4_a type vti local ${veth4_a_addr} remote ${veth4_b_addr} key 10\n\t[ $? -ne 0 ] && err \"  vti not supported\" && return $ksft_skip\n\trun_cmd ${ns_a} ip link del vti4_a\n\n\tfail=0\n\n\tmin=68\n\tmax=$((65535 - 20))\n\t# Check invalid values first\n\tfor v in $((min - 1)) $((max + 1)); do\n\t\trun_cmd ${ns_a} ip link add vti4_a mtu ${v} type vti local ${veth4_a_addr} remote ${veth4_b_addr} key 10\n\t\t# This can fail, or MTU can be adjusted to a proper value\n\t\t[ $? -ne 0 ] && continue\n\t\tmtu=\"$(link_get_mtu \"${ns_a}\" vti4_a)\"\n\t\tif [ ${mtu} -lt ${min} -o ${mtu} -gt ${max} ]; then\n\t\t\terr \"  vti tunnel created with invalid MTU ${mtu}\"\n\t\t\tfail=1\n\t\tfi\n\t\trun_cmd ${ns_a} ip link del vti4_a\n\tdone\n\n\t# Now check valid values\n\tfor v in ${min} 1300 ${max}; do\n\t\trun_cmd ${ns_a} ip link add vti4_a mtu ${v} type vti local ${veth4_a_addr} remote ${veth4_b_addr} key 10\n\t\tmtu=\"$(link_get_mtu \"${ns_a}\" vti4_a)\"\n\t\trun_cmd ${ns_a} ip link del vti4_a\n\t\tif [ \"${mtu}\" != \"${v}\" ]; then\n\t\t\terr \"  vti MTU ${mtu} doesn't match configured value ${v}\"\n\t\t\tfail=1\n\t\tfi\n\tdone\n\n\treturn ${fail}\n}\n\ntest_pmtu_vti6_link_add_mtu() {\n\tsetup namespaces || return $ksft_skip\n\n\trun_cmd ${ns_a} ip link add vti6_a type vti6 local ${veth6_a_addr} remote ${veth6_b_addr} key 10\n\t[ $? -ne 0 ] && err \"  vti6 not supported\" && return $ksft_skip\n\trun_cmd ${ns_a} ip link del vti6_a\n\n\tfail=0\n\n\tmin=68\t\t\t# vti6 can carry IPv4 packets too\n\tmax=$((65535 - 40))\n\t# Check invalid values first\n\tfor v in $((min - 1)) $((max + 1)); do\n\t\trun_cmd ${ns_a} ip link add vti6_a mtu ${v} type vti6 local ${veth6_a_addr} remote ${veth6_b_addr} key 10\n\t\t# This can fail, or MTU can be adjusted to a proper value\n\t\t[ $? -ne 0 ] && continue\n\t\tmtu=\"$(link_get_mtu \"${ns_a}\" vti6_a)\"\n\t\tif [ ${mtu} -lt ${min} -o ${mtu} -gt ${max} ]; then\n\t\t\terr \"  vti6 tunnel created with invalid MTU ${v}\"\n\t\t\tfail=1\n\t\tfi\n\t\trun_cmd ${ns_a} ip link del vti6_a\n\tdone\n\n\t# Now check valid values\n\tfor v in 68 1280 1300 $((65535 - 40)); do\n\t\trun_cmd ${ns_a} ip link add vti6_a mtu ${v} type vti6 local ${veth6_a_addr} remote ${veth6_b_addr} key 10\n\t\tmtu=\"$(link_get_mtu \"${ns_a}\" vti6_a)\"\n\t\trun_cmd ${ns_a} ip link del vti6_a\n\t\tif [ \"${mtu}\" != \"${v}\" ]; then\n\t\t\terr \"  vti6 MTU ${mtu} doesn't match configured value ${v}\"\n\t\t\tfail=1\n\t\tfi\n\tdone\n\n\treturn ${fail}\n}\n\ntest_pmtu_vti6_link_change_mtu() {\n\tsetup namespaces || return $ksft_skip\n\n\trun_cmd ${ns_a} ip link add dummy0 mtu 1500 type dummy\n\t[ $? -ne 0 ] && err \"  dummy not supported\" && return $ksft_skip\n\trun_cmd ${ns_a} ip link add dummy1 mtu 3000 type dummy\n\trun_cmd ${ns_a} ip link set dummy0 up\n\trun_cmd ${ns_a} ip link set dummy1 up\n\n\trun_cmd ${ns_a} ip addr add ${dummy6_0_prefix}1/${dummy6_mask} dev dummy0\n\trun_cmd ${ns_a} ip addr add ${dummy6_1_prefix}1/${dummy6_mask} dev dummy1\n\n\tfail=0\n\n\t# Create vti6 interface bound to device, passing MTU, check it\n\trun_cmd ${ns_a} ip link add vti6_a mtu 1300 type vti6 remote ${dummy6_0_prefix}2 local ${dummy6_0_prefix}1\n\tmtu=\"$(link_get_mtu \"${ns_a}\" vti6_a)\"\n\tif [ ${mtu} -ne 1300 ]; then\n\t\terr \"  vti6 MTU ${mtu} doesn't match configured value 1300\"\n\t\tfail=1\n\tfi\n\n\t# Move to another device with different MTU, without passing MTU, check\n\t# MTU is adjusted\n\trun_cmd ${ns_a} ip link set vti6_a type vti6 remote ${dummy6_1_prefix}2 local ${dummy6_1_prefix}1\n\tmtu=\"$(link_get_mtu \"${ns_a}\" vti6_a)\"\n\tif [ ${mtu} -ne $((3000 - 40)) ]; then\n\t\terr \"  vti MTU ${mtu} is not dummy MTU 3000 minus IPv6 header length\"\n\t\tfail=1\n\tfi\n\n\t# Move it back, passing MTU, check MTU is not overridden\n\trun_cmd ${ns_a} ip link set vti6_a mtu 1280 type vti6 remote ${dummy6_0_prefix}2 local ${dummy6_0_prefix}1\n\tmtu=\"$(link_get_mtu \"${ns_a}\" vti6_a)\"\n\tif [ ${mtu} -ne 1280 ]; then\n\t\terr \"  vti6 MTU ${mtu} doesn't match configured value 1280\"\n\t\tfail=1\n\tfi\n\n\treturn ${fail}\n}\n\ncheck_command() {\n\tcmd=${1}\n\n\tif ! which ${cmd} > /dev/null 2>&1; then\n\t\terr \"  missing required command: '${cmd}'\"\n\t\treturn 1\n\tfi\n\treturn 0\n}\n\ntest_cleanup_vxlanX_exception() {\n\touter=\"${1}\"\n\tencap=\"vxlan\"\n\tll_mtu=4000\n\n\tcheck_command taskset || return $ksft_skip\n\tcpu_list=$(grep -m 2 processor /proc/cpuinfo | cut -d ' ' -f 2)\n\n\tsetup namespaces routing ${encap}${outer} || return $ksft_skip\n\ttrace \"${ns_a}\" ${encap}_a   \"${ns_b}\"  ${encap}_b \\\n\t      \"${ns_a}\" veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_b}\" veth_B-R1    \"${ns_r1}\" veth_R1-B\n\n\t# Create route exception by exceeding link layer MTU\n\tmtu \"${ns_a}\"  veth_A-R1 $((${ll_mtu} + 1000))\n\tmtu \"${ns_r1}\" veth_R1-A $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\"  veth_B-R1 ${ll_mtu}\n\tmtu \"${ns_r1}\" veth_R1-B ${ll_mtu}\n\n\tmtu \"${ns_a}\" ${encap}_a $((${ll_mtu} + 1000))\n\tmtu \"${ns_b}\" ${encap}_b $((${ll_mtu} + 1000))\n\n\t# Fill exception cache for multiple CPUs (2)\n\t# we can always use inner IPv4 for that\n\tfor cpu in ${cpu_list}; do\n\t\trun_cmd taskset --cpu-list ${cpu} ${ns_a} ping -q -M want -i 0.1 -w 1 -s $((${ll_mtu} + 500)) ${tunnel4_b_addr}\n\tdone\n\n\t${ns_a} ip link del dev veth_A-R1 &\n\tiplink_pid=$!\n\tsleep 1\n\tif [ \"$(cat /proc/${iplink_pid}/cmdline 2>/dev/null | tr -d '\\0')\" = \"iplinkdeldevveth_A-R1\" ]; then\n\t\terr \"  can't delete veth device in a timely manner, PMTU dst likely leaked\"\n\t\treturn 1\n\tfi\n}\n\ntest_cleanup_ipv6_exception() {\n\ttest_cleanup_vxlanX_exception 6\n}\n\ntest_cleanup_ipv4_exception() {\n\ttest_cleanup_vxlanX_exception 4\n}\n\nrun_test() {\n\t(\n\ttname=\"$1\"\n\ttdesc=\"$2\"\n\n\tunset IFS\n\n\t# Since cleanup() relies on variables modified by this subshell, it\n\t# has to run in this context.\n\ttrap cleanup EXIT\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\tprintf \"\\n##########################################################################\\n\\n\"\n\tfi\n\n\teval test_${tname}\n\tret=$?\n\n\tif [ $ret -eq 0 ]; then\n\t\tprintf \"TEST: %-60s  [ OK ]\\n\" \"${tdesc}\"\n\telif [ $ret -eq 1 ]; then\n\t\tprintf \"TEST: %-60s  [FAIL]\\n\" \"${tdesc}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo\n\t\t\techo \"Pausing. Hit enter to continue\"\n\t\t\tread a\n\t\tfi\n\t\terr_flush\n\t\texit 1\n\telif [ $ret -eq $ksft_skip ]; then\n\t\tprintf \"TEST: %-60s  [SKIP]\\n\" \"${tdesc}\"\n\t\terr_flush\n\tfi\n\n\treturn $ret\n\t)\n\tret=$?\n\tcase $ret in\n\t\t0)\n\t\t\tall_skipped=false\n\t\t\t[ $exitcode -eq $ksft_skip ] && exitcode=0\n\t\t;;\n\t\t$ksft_skip)\n\t\t\t[ $all_skipped = true ] && exitcode=$ksft_skip\n\t\t;;\n\t\t*)\n\t\t\tall_skipped=false\n\t\t\texitcode=1\n\t\t;;\n\tesac\n\n\treturn $ret\n}\n\nrun_test_nh() {\n\ttname=\"$1\"\n\ttdesc=\"$2\"\n\n\tUSE_NH=yes\n\trun_test \"${tname}\" \"${tdesc} - nexthop objects\"\n\tUSE_NH=no\n}\n\ntest_list_flush_ipv4_exception() {\n\tsetup namespaces routing || return $ksft_skip\n\ttrace \"${ns_a}\"  veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_r1}\" veth_R1-B    \"${ns_b}\"  veth_B-R1 \\\n\t      \"${ns_a}\"  veth_A-R2    \"${ns_r2}\" veth_R2-A \\\n\t      \"${ns_r2}\" veth_R2-B    \"${ns_b}\"  veth_B-R2\n\n\tdst_prefix1=\"${prefix4}.${b_r1}.\"\n\tdst2=\"${prefix4}.${b_r2}.1\"\n\n\t# Set up initial MTU values\n\tmtu \"${ns_a}\"  veth_A-R1 2000\n\tmtu \"${ns_r1}\" veth_R1-A 2000\n\tmtu \"${ns_r1}\" veth_R1-B 1500\n\tmtu \"${ns_b}\"  veth_B-R1 1500\n\n\tmtu \"${ns_a}\"  veth_A-R2 2000\n\tmtu \"${ns_r2}\" veth_R2-A 2000\n\tmtu \"${ns_r2}\" veth_R2-B 1500\n\tmtu \"${ns_b}\"  veth_B-R2 1500\n\n\tfail=0\n\n\t# Add 100 addresses for veth endpoint on B reached by default A route\n\tfor i in $(seq 100 199); do\n\t\trun_cmd ${ns_b} ip addr add \"${dst_prefix1}${i}\" dev veth_B-R1\n\tdone\n\n\t# Create 100 cached route exceptions for path via R1, one via R2. Note\n\t# that with IPv4 we need to actually cause a route lookup that matches\n\t# the exception caused by ICMP, in order to actually have a cached\n\t# route, so we need to ping each destination twice\n\tfor i in $(seq 100 199); do\n\t\trun_cmd ${ns_a} ping -q -M want -i 0.1 -c 2 -s 1800 \"${dst_prefix1}${i}\"\n\tdone\n\trun_cmd ${ns_a} ping -q -M want -i 0.1 -c 2 -s 1800 \"${dst2}\"\n\n\tif [ \"$(${ns_a} ip -oneline route list cache | wc -l)\" -ne 101 ]; then\n\t\terr \"  can't list cached exceptions\"\n\t\tfail=1\n\tfi\n\n\trun_cmd ${ns_a} ip route flush cache\n\tpmtu1=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst_prefix}1)\"\n\tpmtu2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst_prefix}2)\"\n\tif [ -n \"${pmtu1}\" ] || [ -n \"${pmtu2}\" ] || \\\n\t   [ -n \"$(${ns_a} ip route list cache)\" ]; then\n\t\terr \"  can't flush cached exceptions\"\n\t\tfail=1\n\tfi\n\n\treturn ${fail}\n}\n\ntest_list_flush_ipv6_exception() {\n\tsetup namespaces routing || return $ksft_skip\n\ttrace \"${ns_a}\"  veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_r1}\" veth_R1-B    \"${ns_b}\"  veth_B-R1 \\\n\t      \"${ns_a}\"  veth_A-R2    \"${ns_r2}\" veth_R2-A \\\n\t      \"${ns_r2}\" veth_R2-B    \"${ns_b}\"  veth_B-R2\n\n\tdst_prefix1=\"${prefix6}:${b_r1}::\"\n\tdst2=\"${prefix6}:${b_r2}::1\"\n\n\t# Set up initial MTU values\n\tmtu \"${ns_a}\"  veth_A-R1 2000\n\tmtu \"${ns_r1}\" veth_R1-A 2000\n\tmtu \"${ns_r1}\" veth_R1-B 1500\n\tmtu \"${ns_b}\"  veth_B-R1 1500\n\n\tmtu \"${ns_a}\"  veth_A-R2 2000\n\tmtu \"${ns_r2}\" veth_R2-A 2000\n\tmtu \"${ns_r2}\" veth_R2-B 1500\n\tmtu \"${ns_b}\"  veth_B-R2 1500\n\n\tfail=0\n\n\t# Add 100 addresses for veth endpoint on B reached by default A route\n\tfor i in $(seq 100 199); do\n\t\trun_cmd ${ns_b} ip addr add \"${dst_prefix1}${i}\" dev veth_B-R1\n\tdone\n\n\t# Create 100 cached route exceptions for path via R1, one via R2\n\tfor i in $(seq 100 199); do\n\t\trun_cmd ${ns_a} ping -q -M want -i 0.1 -w 1 -s 1800 \"${dst_prefix1}${i}\"\n\tdone\n\trun_cmd ${ns_a} ping -q -M want -i 0.1 -w 1 -s 1800 \"${dst2}\"\n\tif [ \"$(${ns_a} ip -oneline -6 route list cache | wc -l)\" -ne 101 ]; then\n\t\terr \"  can't list cached exceptions\"\n\t\tfail=1\n\tfi\n\n\trun_cmd ${ns_a} ip -6 route flush cache\n\tpmtu1=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" \"${dst_prefix1}100\")\"\n\tpmtu2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst2})\"\n\tif [ -n \"${pmtu1}\" ] || [ -n \"${pmtu2}\" ] || \\\n\t   [ -n \"$(${ns_a} ip -6 route list cache)\" ]; then\n\t\terr \"  can't flush cached exceptions\"\n\t\tfail=1\n\tfi\n\n\treturn ${fail}\n}\n\ntest_pmtu_ipvX_route_change() {\n\tfamily=${1}\n\n\tsetup namespaces routing || return 2\n\ttrace \"${ns_a}\"  veth_A-R1    \"${ns_r1}\" veth_R1-A \\\n\t      \"${ns_r1}\" veth_R1-B    \"${ns_b}\"  veth_B-R1 \\\n\t      \"${ns_a}\"  veth_A-R2    \"${ns_r2}\" veth_R2-A \\\n\t      \"${ns_r2}\" veth_R2-B    \"${ns_b}\"  veth_B-R2\n\n\tif [ ${family} -eq 4 ]; then\n\t\tping=ping\n\t\tdst1=\"${prefix4}.${b_r1}.1\"\n\t\tdst2=\"${prefix4}.${b_r2}.1\"\n\t\tgw=\"${prefix4}.${a_r1}.2\"\n\telse\n\t\tping=${ping6}\n\t\tdst1=\"${prefix6}:${b_r1}::1\"\n\t\tdst2=\"${prefix6}:${b_r2}::1\"\n\t\tgw=\"${prefix6}:${a_r1}::2\"\n\tfi\n\n\t# Set up initial MTU values\n\tmtu \"${ns_a}\"  veth_A-R1 2000\n\tmtu \"${ns_r1}\" veth_R1-A 2000\n\tmtu \"${ns_r1}\" veth_R1-B 1400\n\tmtu \"${ns_b}\"  veth_B-R1 1400\n\n\tmtu \"${ns_a}\"  veth_A-R2 2000\n\tmtu \"${ns_r2}\" veth_R2-A 2000\n\tmtu \"${ns_r2}\" veth_R2-B 1500\n\tmtu \"${ns_b}\"  veth_B-R2 1500\n\n\t# Create route exceptions\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1 -s 1800 ${dst1}\n\trun_cmd ${ns_a} ${ping} -q -M want -i 0.1 -w 1 -s 1800 ${dst2}\n\n\t# Check that exceptions have been created with the correct PMTU\n\tpmtu_1=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst1})\"\n\tcheck_pmtu_value \"1400\" \"${pmtu_1}\" \"exceeding MTU\" || return 1\n\tpmtu_2=\"$(route_get_dst_pmtu_from_exception \"${ns_a}\" ${dst2})\"\n\tcheck_pmtu_value \"1500\" \"${pmtu_2}\" \"exceeding MTU\" || return 1\n\n\t# Replace the route from A to R1\n\trun_cmd ${ns_a} ip route change default via ${gw}\n\n\t# Delete the device in A\n\trun_cmd ${ns_a} ip link del \"veth_A-R1\"\n}\n\ntest_pmtu_ipv4_route_change() {\n\ttest_pmtu_ipvX_route_change 4\n}\n\ntest_pmtu_ipv6_route_change() {\n\ttest_pmtu_ipvX_route_change 6\n}\n\nusage() {\n\techo\n\techo \"$0 [OPTIONS] [TEST]...\"\n\techo \"If no TEST argument is given, all tests will be run.\"\n\techo\n\techo \"Options\"\n\techo \"  --trace: capture traffic to TEST_INTERFACE.pcap\"\n\techo\n\techo \"Available tests${tests}\"\n\texit 1\n}\n\n################################################################################\n#\nexitcode=0\ndesc=0\nall_skipped=true\n\nwhile getopts :ptv o\ndo\n\tcase $o in\n\tp) PAUSE_ON_FAIL=yes;;\n\tv) VERBOSE=1;;\n\tt) if which tcpdump > /dev/null 2>&1; then\n\t\tTRACING=1\n\t   else\n\t\techo \"=== tcpdump not available, tracing disabled\"\n\t   fi\n\t   ;;\n\t*) usage;;\n\tesac\ndone\nshift $(($OPTIND-1))\n\nIFS=\"\t\n\"\n\nfor arg do\n\t# Check first that all requested tests are available before running any\n\tcommand -v > /dev/null \"test_${arg}\" || { echo \"=== Test ${arg} not found\"; usage; }\ndone\n\ntrap cleanup EXIT\n\n# start clean\ncleanup\n\nHAVE_NH=no\nip nexthop ls >/dev/null 2>&1\n[ $? -eq 0 ] && HAVE_NH=yes\n\nname=\"\"\ndesc=\"\"\nrerun_nh=0\nfor t in ${tests}; do\n\t[ \"${name}\" = \"\" ]\t&& name=\"${t}\"\t&& continue\n\t[ \"${desc}\" = \"\" ]\t&& desc=\"${t}\"\t&& continue\n\n\tif [ \"${HAVE_NH}\" = \"yes\" ]; then\n\t\trerun_nh=\"${t}\"\n\tfi\n\n\trun_this=1\n\tfor arg do\n\t\t[ \"${arg}\" != \"${arg#--*}\" ] && continue\n\t\t[ \"${arg}\" = \"${name}\" ] && run_this=1 && break\n\t\trun_this=0\n\tdone\n\tif [ $run_this -eq 1 ]; then\n\t\trun_test \"${name}\" \"${desc}\"\n\t\t# if test was skipped no need to retry with nexthop objects\n\t\t[ $? -eq $ksft_skip ] && rerun_nh=0\n\n\t\tif [ \"${rerun_nh}\" = \"1\" ]; then\n\t\t\trun_test_nh \"${name}\" \"${desc}\"\n\t\tfi\n\tfi\n\tname=\"\"\n\tdesc=\"\"\n\trerun_nh=0\ndone\n\nexit ${exitcode}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}