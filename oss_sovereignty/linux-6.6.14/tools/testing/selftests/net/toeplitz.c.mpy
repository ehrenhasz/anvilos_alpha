{
  "module_name": "toeplitz.c",
  "hash_id": "830c2d17bf7b7347567fd59addede38bf9e6a459e6360a5c5967fc6bcaf7b26d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/toeplitz.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <linux/filter.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <netinet/ip.h>\n#include <netinet/ip6.h>\n#include <netinet/tcp.h>\n#include <netinet/udp.h>\n#include <poll.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/sysinfo.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"../kselftest.h\"\n\n#define TOEPLITZ_KEY_MIN_LEN\t40\n#define TOEPLITZ_KEY_MAX_LEN\t60\n\n#define TOEPLITZ_STR_LEN(K)\t(((K) * 3) - 1)\t \n#define TOEPLITZ_STR_MIN_LEN\tTOEPLITZ_STR_LEN(TOEPLITZ_KEY_MIN_LEN)\n#define TOEPLITZ_STR_MAX_LEN\tTOEPLITZ_STR_LEN(TOEPLITZ_KEY_MAX_LEN)\n\n#define FOUR_TUPLE_MAX_LEN\t((sizeof(struct in6_addr) * 2) + (sizeof(uint16_t) * 2))\n\n#define RSS_MAX_CPUS (1 << 16)\t \n\n#define RPS_MAX_CPUS 16UL\t \n\n \nstatic uint16_t cfg_dport =\t8000;\nstatic int cfg_family =\t\tAF_INET6;\nstatic char *cfg_ifname =\t\"eth0\";\nstatic int cfg_num_queues;\nstatic int cfg_num_rps_cpus;\nstatic bool cfg_sink;\nstatic int cfg_type =\t\tSOCK_STREAM;\nstatic int cfg_timeout_msec =\t1000;\nstatic bool cfg_verbose;\n\n \nstatic int num_cpus;\nstatic int ring_block_nr;\nstatic int ring_block_sz;\n\n \nstatic int frames_received;\nstatic int frames_nohash;\nstatic int frames_error;\n\n#define log_verbose(args...)\tdo { if (cfg_verbose) fprintf(stderr, args); } while (0)\n\n \nstruct ring_state {\n\tint fd;\n\tchar *mmap;\n\tint idx;\n\tint cpu;\n};\n\nstatic unsigned int rx_irq_cpus[RSS_MAX_CPUS];\t \nstatic int rps_silo_to_cpu[RPS_MAX_CPUS];\nstatic unsigned char toeplitz_key[TOEPLITZ_KEY_MAX_LEN];\nstatic struct ring_state rings[RSS_MAX_CPUS];\n\nstatic inline uint32_t toeplitz(const unsigned char *four_tuple,\n\t\t\t\tconst unsigned char *key)\n{\n\tint i, bit, ret = 0;\n\tuint32_t key32;\n\n\tkey32 = ntohl(*((uint32_t *)key));\n\tkey += 4;\n\n\tfor (i = 0; i < FOUR_TUPLE_MAX_LEN; i++) {\n\t\tfor (bit = 7; bit >= 0; bit--) {\n\t\t\tif (four_tuple[i] & (1 << bit))\n\t\t\t\tret ^= key32;\n\n\t\t\tkey32 <<= 1;\n\t\t\tkey32 |= !!(key[0] & (1 << bit));\n\t\t}\n\t\tkey++;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void verify_rss(uint32_t rx_hash, int cpu)\n{\n\tint queue = rx_hash % cfg_num_queues;\n\n\tlog_verbose(\" rxq %d (cpu %d)\", queue, rx_irq_cpus[queue]);\n\tif (rx_irq_cpus[queue] != cpu) {\n\t\tlog_verbose(\". error: rss cpu mismatch (%d)\", cpu);\n\t\tframes_error++;\n\t}\n}\n\nstatic void verify_rps(uint64_t rx_hash, int cpu)\n{\n\tint silo = (rx_hash * cfg_num_rps_cpus) >> 32;\n\n\tlog_verbose(\" silo %d (cpu %d)\", silo, rps_silo_to_cpu[silo]);\n\tif (rps_silo_to_cpu[silo] != cpu) {\n\t\tlog_verbose(\". error: rps cpu mismatch (%d)\", cpu);\n\t\tframes_error++;\n\t}\n}\n\nstatic void log_rxhash(int cpu, uint32_t rx_hash,\n\t\t       const char *addrs, int addr_len)\n{\n\tchar saddr[INET6_ADDRSTRLEN], daddr[INET6_ADDRSTRLEN];\n\tuint16_t *ports;\n\n\tif (!inet_ntop(cfg_family, addrs, saddr, sizeof(saddr)) ||\n\t    !inet_ntop(cfg_family, addrs + addr_len, daddr, sizeof(daddr)))\n\t\terror(1, 0, \"address parse error\");\n\n\tports = (void *)addrs + (addr_len * 2);\n\tlog_verbose(\"cpu %d: rx_hash 0x%08x [saddr %s daddr %s sport %02hu dport %02hu]\",\n\t\t    cpu, rx_hash, saddr, daddr,\n\t\t    ntohs(ports[0]), ntohs(ports[1]));\n}\n\n \nstatic void verify_rxhash(const char *pkt, uint32_t rx_hash, int cpu)\n{\n\tunsigned char four_tuple[FOUR_TUPLE_MAX_LEN] = {0};\n\tuint32_t rx_hash_sw;\n\tconst char *addrs;\n\tint addr_len;\n\n\tif (cfg_family == AF_INET) {\n\t\taddr_len = sizeof(struct in_addr);\n\t\taddrs = pkt + offsetof(struct iphdr, saddr);\n\t} else {\n\t\taddr_len = sizeof(struct in6_addr);\n\t\taddrs = pkt + offsetof(struct ip6_hdr, ip6_src);\n\t}\n\n\tmemcpy(four_tuple, addrs, (addr_len * 2) + (sizeof(uint16_t) * 2));\n\trx_hash_sw = toeplitz(four_tuple, toeplitz_key);\n\n\tif (cfg_verbose)\n\t\tlog_rxhash(cpu, rx_hash, addrs, addr_len);\n\n\tif (rx_hash != rx_hash_sw) {\n\t\tlog_verbose(\" != expected 0x%x\\n\", rx_hash_sw);\n\t\tframes_error++;\n\t\treturn;\n\t}\n\n\tlog_verbose(\" OK\");\n\tif (cfg_num_queues)\n\t\tverify_rss(rx_hash, cpu);\n\telse if (cfg_num_rps_cpus)\n\t\tverify_rps(rx_hash, cpu);\n\tlog_verbose(\"\\n\");\n}\n\nstatic char *recv_frame(const struct ring_state *ring, char *frame)\n{\n\tstruct tpacket3_hdr *hdr = (void *)frame;\n\n\tif (hdr->hv1.tp_rxhash)\n\t\tverify_rxhash(frame + hdr->tp_net, hdr->hv1.tp_rxhash,\n\t\t\t      ring->cpu);\n\telse\n\t\tframes_nohash++;\n\n\treturn frame + hdr->tp_next_offset;\n}\n\n \nstatic bool recv_block(struct ring_state *ring)\n{\n\tstruct tpacket_block_desc *block;\n\tchar *frame;\n\tint i;\n\n\tblock = (void *)(ring->mmap + ring->idx * ring_block_sz);\n\tif (!(block->hdr.bh1.block_status & TP_STATUS_USER))\n\t\treturn false;\n\n\tframe = (char *)block;\n\tframe += block->hdr.bh1.offset_to_first_pkt;\n\n\tfor (i = 0; i < block->hdr.bh1.num_pkts; i++) {\n\t\tframe = recv_frame(ring, frame);\n\t\tframes_received++;\n\t}\n\n\tblock->hdr.bh1.block_status = TP_STATUS_KERNEL;\n\tring->idx = (ring->idx + 1) % ring_block_nr;\n\n\treturn true;\n}\n\n \nstatic void process_rings(void)\n{\n\tint i;\n\n\tusleep(1000 * cfg_timeout_msec);\n\n\tfor (i = 0; i < num_cpus; i++)\n\t\tdo {} while (recv_block(&rings[i]));\n\n\tfprintf(stderr, \"count: pass=%u nohash=%u fail=%u\\n\",\n\t\tframes_received - frames_nohash - frames_error,\n\t\tframes_nohash, frames_error);\n}\n\nstatic char *setup_ring(int fd)\n{\n\tstruct tpacket_req3 req3 = {0};\n\tvoid *ring;\n\n\treq3.tp_retire_blk_tov = cfg_timeout_msec / 8;\n\treq3.tp_feature_req_word = TP_FT_REQ_FILL_RXHASH;\n\n\treq3.tp_frame_size = 2048;\n\treq3.tp_frame_nr = 1 << 10;\n\treq3.tp_block_nr = 16;\n\n\treq3.tp_block_size = req3.tp_frame_size * req3.tp_frame_nr;\n\treq3.tp_block_size /= req3.tp_block_nr;\n\n\tif (setsockopt(fd, SOL_PACKET, PACKET_RX_RING, &req3, sizeof(req3)))\n\t\terror(1, errno, \"setsockopt PACKET_RX_RING\");\n\n\tring_block_sz = req3.tp_block_size;\n\tring_block_nr = req3.tp_block_nr;\n\n\tring = mmap(0, req3.tp_block_size * req3.tp_block_nr,\n\t\t    PROT_READ | PROT_WRITE,\n\t\t    MAP_SHARED | MAP_LOCKED | MAP_POPULATE, fd, 0);\n\tif (ring == MAP_FAILED)\n\t\terror(1, 0, \"mmap failed\");\n\n\treturn ring;\n}\n\nstatic void __set_filter(int fd, int off_proto, uint8_t proto, int off_dport)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD  + BPF_B   + BPF_ABS, SKF_AD_OFF + SKF_AD_PKTTYPE),\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, PACKET_HOST, 0, 4),\n\t\tBPF_STMT(BPF_LD  + BPF_B   + BPF_ABS, off_proto),\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, proto, 0, 2),\n\t\tBPF_STMT(BPF_LD  + BPF_H   + BPF_ABS, off_dport),\n\t\tBPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, cfg_dport, 1, 0),\n\t\tBPF_STMT(BPF_RET + BPF_K, 0),\n\t\tBPF_STMT(BPF_RET + BPF_K, 0xFFFF),\n\t};\n\tstruct sock_fprog prog = {};\n\n\tprog.filter = filter;\n\tprog.len = ARRAY_SIZE(filter);\n\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, &prog, sizeof(prog)))\n\t\terror(1, errno, \"setsockopt filter\");\n}\n\n \nstatic void set_filter(int fd)\n{\n\tconst int off_dport = offsetof(struct tcphdr, dest);\t \n\tuint8_t proto;\n\n\tproto = cfg_type == SOCK_STREAM ? IPPROTO_TCP : IPPROTO_UDP;\n\tif (cfg_family == AF_INET)\n\t\t__set_filter(fd, offsetof(struct iphdr, protocol), proto,\n\t\t\t     sizeof(struct iphdr) + off_dport);\n\telse\n\t\t__set_filter(fd, offsetof(struct ip6_hdr, ip6_nxt), proto,\n\t\t\t     sizeof(struct ip6_hdr) + off_dport);\n}\n\n \nstatic void set_filter_null(int fd)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_RET + BPF_K, 0),\n\t};\n\tstruct sock_fprog prog = {};\n\n\tprog.filter = filter;\n\tprog.len = ARRAY_SIZE(filter);\n\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, &prog, sizeof(prog)))\n\t\terror(1, errno, \"setsockopt filter\");\n}\n\nstatic int create_ring(char **ring)\n{\n\tstruct fanout_args args = {\n\t\t.id = 1,\n\t\t.type_flags = PACKET_FANOUT_CPU,\n\t\t.max_num_members = RSS_MAX_CPUS\n\t};\n\tstruct sockaddr_ll ll = { 0 };\n\tint fd, val;\n\n\tfd = socket(PF_PACKET, SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket creation failed\");\n\n\tval = TPACKET_V3;\n\tif (setsockopt(fd, SOL_PACKET, PACKET_VERSION, &val, sizeof(val)))\n\t\terror(1, errno, \"setsockopt PACKET_VERSION\");\n\t*ring = setup_ring(fd);\n\n\t \n\tset_filter_null(fd);\n\n\tll.sll_family = AF_PACKET;\n\tll.sll_ifindex = if_nametoindex(cfg_ifname);\n\tll.sll_protocol = cfg_family == AF_INET ? htons(ETH_P_IP) :\n\t\t\t\t\t\t  htons(ETH_P_IPV6);\n\tif (bind(fd, (void *)&ll, sizeof(ll)))\n\t\terror(1, errno, \"bind\");\n\n\t \n\tif (setsockopt(fd, SOL_PACKET, PACKET_FANOUT, &args, sizeof(args))) {\n\t\t \n\t\tif (cfg_num_queues || num_cpus > 256 ||\n\t\t    setsockopt(fd, SOL_PACKET, PACKET_FANOUT,\n\t\t\t       &args, sizeof(uint32_t)))\n\t\t\terror(1, errno, \"setsockopt PACKET_FANOUT cpu\");\n\t}\n\n\treturn fd;\n}\n\n \nstatic int setup_sink(void)\n{\n\tint fd, val;\n\n\tfd = socket(cfg_family, cfg_type, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket %d.%d\", cfg_family, cfg_type);\n\n\tval = 1 << 20;\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVBUFFORCE, &val, sizeof(val)))\n\t\terror(1, errno, \"setsockopt rcvbuf\");\n\n\treturn fd;\n}\n\nstatic void setup_rings(void)\n{\n\tint i;\n\n\tfor (i = 0; i < num_cpus; i++) {\n\t\trings[i].cpu = i;\n\t\trings[i].fd = create_ring(&rings[i].mmap);\n\t}\n\n\t \n\tfor (i = 0; i < num_cpus; i++)\n\t\tset_filter(rings[i].fd);\n}\n\nstatic void cleanup_rings(void)\n{\n\tint i;\n\n\tfor (i = 0; i < num_cpus; i++) {\n\t\tif (munmap(rings[i].mmap, ring_block_nr * ring_block_sz))\n\t\t\terror(1, errno, \"munmap\");\n\t\tif (close(rings[i].fd))\n\t\t\terror(1, errno, \"close\");\n\t}\n}\n\nstatic void parse_cpulist(const char *arg)\n{\n\tdo {\n\t\trx_irq_cpus[cfg_num_queues++] = strtol(arg, NULL, 10);\n\n\t\targ = strchr(arg, ',');\n\t\tif (!arg)\n\t\t\tbreak;\n\t\targ++;\t\t\t\n\t} while (1);\n}\n\nstatic void show_cpulist(void)\n{\n\tint i;\n\n\tfor (i = 0; i < cfg_num_queues; i++)\n\t\tfprintf(stderr, \"rxq %d: cpu %d\\n\", i, rx_irq_cpus[i]);\n}\n\nstatic void show_silos(void)\n{\n\tint i;\n\n\tfor (i = 0; i < cfg_num_rps_cpus; i++)\n\t\tfprintf(stderr, \"silo %d: cpu %d\\n\", i, rps_silo_to_cpu[i]);\n}\n\nstatic void parse_toeplitz_key(const char *str, int slen, unsigned char *key)\n{\n\tint i, ret, off;\n\n\tif (slen < TOEPLITZ_STR_MIN_LEN ||\n\t    slen > TOEPLITZ_STR_MAX_LEN + 1)\n\t\terror(1, 0, \"invalid toeplitz key\");\n\n\tfor (i = 0, off = 0; off < slen; i++, off += 3) {\n\t\tret = sscanf(str + off, \"%hhx\", &key[i]);\n\t\tif (ret != 1)\n\t\t\terror(1, 0, \"key parse error at %d off %d len %d\",\n\t\t\t      i, off, slen);\n\t}\n}\n\nstatic void parse_rps_bitmap(const char *arg)\n{\n\tunsigned long bitmap;\n\tint i;\n\n\tbitmap = strtoul(arg, NULL, 0);\n\n\tif (bitmap & ~(RPS_MAX_CPUS - 1))\n\t\terror(1, 0, \"rps bitmap 0x%lx out of bounds 0..%lu\",\n\t\t      bitmap, RPS_MAX_CPUS - 1);\n\n\tfor (i = 0; i < RPS_MAX_CPUS; i++)\n\t\tif (bitmap & 1UL << i)\n\t\t\trps_silo_to_cpu[cfg_num_rps_cpus++] = i;\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tstatic struct option long_options[] = {\n\t    {\"dport\",\trequired_argument, 0, 'd'},\n\t    {\"cpus\",\trequired_argument, 0, 'C'},\n\t    {\"key\",\trequired_argument, 0, 'k'},\n\t    {\"iface\",\trequired_argument, 0, 'i'},\n\t    {\"ipv4\",\tno_argument, 0, '4'},\n\t    {\"ipv6\",\tno_argument, 0, '6'},\n\t    {\"sink\",\tno_argument, 0, 's'},\n\t    {\"tcp\",\tno_argument, 0, 't'},\n\t    {\"timeout\",\trequired_argument, 0, 'T'},\n\t    {\"udp\",\tno_argument, 0, 'u'},\n\t    {\"verbose\",\tno_argument, 0, 'v'},\n\t    {\"rps\",\trequired_argument, 0, 'r'},\n\t    {0, 0, 0, 0}\n\t};\n\tbool have_toeplitz = false;\n\tint index, c;\n\n\twhile ((c = getopt_long(argc, argv, \"46C:d:i:k:r:stT:uv\", long_options, &index)) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tcfg_family = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tcfg_family = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tparse_cpulist(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcfg_dport = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcfg_ifname = optarg;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tparse_toeplitz_key(optarg, strlen(optarg),\n\t\t\t\t\t   toeplitz_key);\n\t\t\thave_toeplitz = true;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tparse_rps_bitmap(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcfg_sink = true;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_type = SOCK_STREAM;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tcfg_timeout_msec = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tcfg_type = SOCK_DGRAM;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcfg_verbose = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terror(1, 0, \"unknown option %c\", optopt);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!have_toeplitz)\n\t\terror(1, 0, \"Must supply rss key ('-k')\");\n\n\tnum_cpus = get_nprocs();\n\tif (num_cpus > RSS_MAX_CPUS)\n\t\terror(1, 0, \"increase RSS_MAX_CPUS\");\n\n\tif (cfg_num_queues && cfg_num_rps_cpus)\n\t\terror(1, 0,\n\t\t      \"Can't supply both RSS cpus ('-C') and RPS map ('-r')\");\n\tif (cfg_verbose) {\n\t\tshow_cpulist();\n\t\tshow_silos();\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tconst int min_tests = 10;\n\tint fd_sink = -1;\n\n\tparse_opts(argc, argv);\n\n\tif (cfg_sink)\n\t\tfd_sink = setup_sink();\n\n\tsetup_rings();\n\tprocess_rings();\n\tcleanup_rings();\n\n\tif (cfg_sink && close(fd_sink))\n\t\terror(1, errno, \"close sink\");\n\n\tif (frames_received - frames_nohash < min_tests)\n\t\terror(1, 0, \"too few frames for verification\");\n\n\treturn frames_error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}