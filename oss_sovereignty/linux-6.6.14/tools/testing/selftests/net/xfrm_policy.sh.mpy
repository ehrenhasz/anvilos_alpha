{
  "module_name": "xfrm_policy.sh",
  "hash_id": "b1925b2ad9c80f8fe2f6548fd6f0691962308b7da3e1db477aeca75993ea0e97",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/xfrm_policy.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Check xfrm policy resolution.  Topology:\n#\n# 1.2   1.1   3.1  3.10    2.1   2.2\n# eth1  eth1 veth0 veth0 eth1   eth1\n# ns1 ---- ns3 ----- ns4 ---- ns2\n#\n# ns3 and ns4 are connected via ipsec tunnel.\n# pings from ns1 to ns2 (and vice versa) are supposed to work like this:\n# ns1: ping 10.0.2.2: passes via ipsec tunnel.\n# ns2: ping 10.0.1.2: passes via ipsec tunnel.\n\n# ns1: ping 10.0.1.253: passes via ipsec tunnel (direct policy)\n# ns2: ping 10.0.2.253: passes via ipsec tunnel (direct policy)\n#\n# ns1: ping 10.0.2.254: does NOT pass via ipsec tunnel (exception)\n# ns2: ping 10.0.1.254: does NOT pass via ipsec tunnel (exception)\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\nret=0\npolicy_checks_ok=1\n\nKEY_SHA=0xdeadbeef1234567890abcdefabcdefabcdefabcd\nKEY_AES=0x0123456789abcdef0123456789012345\nSPI1=0x1\nSPI2=0x2\n\ndo_esp_policy() {\n    local ns=$1\n    local me=$2\n    local remote=$3\n    local lnet=$4\n    local rnet=$5\n\n    # to encrypt packets as they go out (includes forwarded packets that need encapsulation)\n    ip -net $ns xfrm policy add src $lnet dst $rnet dir out tmpl src $me dst $remote proto esp mode tunnel priority 100 action allow\n    # to fwd decrypted packets after esp processing:\n    ip -net $ns xfrm policy add src $rnet dst $lnet dir fwd tmpl src $remote dst $me proto esp mode tunnel priority 100 action allow\n}\n\ndo_esp() {\n    local ns=$1\n    local me=$2\n    local remote=$3\n    local lnet=$4\n    local rnet=$5\n    local spi_out=$6\n    local spi_in=$7\n\n    ip -net $ns xfrm state add src $remote dst $me proto esp spi $spi_in  enc aes $KEY_AES  auth sha1 $KEY_SHA  mode tunnel sel src $rnet dst $lnet\n    ip -net $ns xfrm state add src $me  dst $remote proto esp spi $spi_out enc aes $KEY_AES auth sha1 $KEY_SHA mode tunnel sel src $lnet dst $rnet\n\n    do_esp_policy $ns $me $remote $lnet $rnet\n}\n\n# add policies with different netmasks, to make sure kernel carries\n# the policies contained within new netmask over when search tree is\n# re-built.\n# peer netns that are supposed to be encapsulated via esp have addresses\n# in the 10.0.1.0/24 and 10.0.2.0/24 subnets, respectively.\n#\n# Adding a policy for '10.0.1.0/23' will make it necessary to\n# alter the prefix of 10.0.1.0 subnet.\n# In case new prefix overlaps with existing node, the node and all\n# policies it carries need to be merged with the existing one(s).\n#\n# Do that here.\ndo_overlap()\n{\n    local ns=$1\n\n    # adds new nodes to tree (neither network exists yet in policy database).\n    ip -net $ns xfrm policy add src 10.1.0.0/24 dst 10.0.0.0/24 dir fwd priority 200 action block\n\n    # adds a new node in the 10.0.0.0/24 tree (dst node exists).\n    ip -net $ns xfrm policy add src 10.2.0.0/24 dst 10.0.0.0/24 dir fwd priority 200 action block\n\n    # adds a 10.2.0.0/23 node, but for different dst.\n    ip -net $ns xfrm policy add src 10.2.0.0/23 dst 10.0.1.0/24 dir fwd priority 200 action block\n\n    # dst now overlaps with the 10.0.1.0/24 ESP policy in fwd.\n    # kernel must 'promote' existing one (10.0.0.0/24) to 10.0.0.0/23.\n    # But 10.0.0.0/23 also includes existing 10.0.1.0/24, so that node\n    # also has to be merged too, including source-sorted subtrees.\n    # old:\n    # 10.0.0.0/24 (node 1 in dst tree of the bin)\n    #    10.1.0.0/24 (node in src tree of dst node 1)\n    #    10.2.0.0/24 (node in src tree of dst node 1)\n    # 10.0.1.0/24 (node 2 in dst tree of the bin)\n    #    10.0.2.0/24 (node in src tree of dst node 2)\n    #    10.2.0.0/24 (node in src tree of dst node 2)\n    #\n    # The next 'policy add' adds dst '10.0.0.0/23', which means\n    # that dst node 1 and dst node 2 have to be merged including\n    # the sub-tree.  As no duplicates are allowed, policies in\n    # the two '10.0.2.0/24' are also merged.\n    #\n    # after the 'add', internal search tree should look like this:\n    # 10.0.0.0/23 (node in dst tree of bin)\n    #     10.0.2.0/24 (node in src tree of dst node)\n    #     10.1.0.0/24 (node in src tree of dst node)\n    #     10.2.0.0/24 (node in src tree of dst node)\n    #\n    # 10.0.0.0/24 and 10.0.1.0/24 nodes have been merged as 10.0.0.0/23.\n    ip -net $ns xfrm policy add src 10.1.0.0/24 dst 10.0.0.0/23 dir fwd priority 200 action block\n\n    # similar to above: add policies (with partially random address), with shrinking prefixes.\n    for p in 29 28 27;do\n      for k in $(seq 1 32); do\n       ip -net $ns xfrm policy add src 10.253.1.$((RANDOM%255))/$p dst 10.254.1.$((RANDOM%255))/$p dir fwd priority $((200+k)) action block 2>/dev/null\n      done\n    done\n}\n\ndo_esp_policy_get_check() {\n    local ns=$1\n    local lnet=$2\n    local rnet=$3\n\n    ip -net $ns xfrm policy get src $lnet dst $rnet dir out > /dev/null\n    if [ $? -ne 0 ] && [ $policy_checks_ok -eq 1 ] ;then\n        policy_checks_ok=0\n        echo \"FAIL: ip -net $ns xfrm policy get src $lnet dst $rnet dir out\"\n        ret=1\n    fi\n\n    ip -net $ns xfrm policy get src $rnet dst $lnet dir fwd > /dev/null\n    if [ $? -ne 0 ] && [ $policy_checks_ok -eq 1 ] ;then\n        policy_checks_ok=0\n        echo \"FAIL: ip -net $ns xfrm policy get src $rnet dst $lnet dir fwd\"\n        ret=1\n    fi\n}\n\ndo_exception() {\n    local ns=$1\n    local me=$2\n    local remote=$3\n    local encryptip=$4\n    local plain=$5\n\n    # network $plain passes without tunnel\n    ip -net $ns xfrm policy add dst $plain dir out priority 10 action allow\n\n    # direct policy for $encryptip, use tunnel, higher prio takes precedence\n    ip -net $ns xfrm policy add dst $encryptip dir out tmpl src $me dst $remote proto esp mode tunnel priority 1 action allow\n}\n\n# policies that are not supposed to match any packets generated in this test.\ndo_dummies4() {\n    local ns=$1\n\n    for i in $(seq 10 16);do\n      # dummy policy with wildcard src/dst.\n      echo netns exec $ns ip xfrm policy add src 0.0.0.0/0 dst 10.$i.99.0/30 dir out action block\n      echo netns exec $ns ip xfrm policy add src 10.$i.99.0/30 dst 0.0.0.0/0 dir out action block\n      for j in $(seq 32 64);do\n        echo netns exec $ns ip xfrm policy add src 10.$i.1.0/30 dst 10.$i.$j.0/30 dir out action block\n        # silly, as it encompasses the one above too, but its allowed:\n        echo netns exec $ns ip xfrm policy add src 10.$i.1.0/29 dst 10.$i.$j.0/29 dir out action block\n        # and yet again, even more broad one.\n        echo netns exec $ns ip xfrm policy add src 10.$i.1.0/24 dst 10.$i.$j.0/24 dir out action block\n        echo netns exec $ns ip xfrm policy add src 10.$i.$j.0/24 dst 10.$i.1.0/24 dir fwd action block\n      done\n    done | ip -batch /dev/stdin\n}\n\ndo_dummies6() {\n    local ns=$1\n\n    for i in $(seq 10 16);do\n      for j in $(seq 32 64);do\n       echo netns exec $ns ip xfrm policy add src dead:$i::/64 dst dead:$i:$j::/64 dir out action block\n       echo netns exec $ns ip xfrm policy add src dead:$i:$j::/64 dst dead:$i::/24 dir fwd action block\n      done\n    done | ip -batch /dev/stdin\n}\n\ncheck_ipt_policy_count()\n{\n\tns=$1\n\n\tip netns exec $ns iptables-save -c |grep policy | ( read c rest\n\t\tip netns exec $ns iptables -Z\n\t\tif [ x\"$c\" = x'[0:0]' ]; then\n\t\t\texit 0\n\t\telif [ x\"$c\" = x ]; then\n\t\t\techo \"ERROR: No counters\"\n\t\t\tret=1\n\t\t\texit 111\n\t\telse\n\t\t\texit 1\n\t\tfi\n\t)\n}\n\ncheck_xfrm() {\n\t# 0: iptables -m policy rule count == 0\n\t# 1: iptables -m policy rule count != 0\n\trval=$1\n\tip=$2\n\tlocal lret=0\n\n\tip netns exec ns1 ping -q -c 1 10.0.2.$ip > /dev/null\n\n\tcheck_ipt_policy_count ns3\n\tif [ $? -ne $rval ] ; then\n\t\tlret=1\n\tfi\n\tcheck_ipt_policy_count ns4\n\tif [ $? -ne $rval ] ; then\n\t\tlret=1\n\tfi\n\n\tip netns exec ns2 ping -q -c 1 10.0.1.$ip > /dev/null\n\n\tcheck_ipt_policy_count ns3\n\tif [ $? -ne $rval ] ; then\n\t\tlret=1\n\tfi\n\tcheck_ipt_policy_count ns4\n\tif [ $? -ne $rval ] ; then\n\t\tlret=1\n\tfi\n\n\treturn $lret\n}\n\ncheck_exceptions()\n{\n\tlogpostfix=\"$1\"\n\tlocal lret=0\n\n\t# ping to .254 should be excluded from the tunnel (exception is in place).\n\tcheck_xfrm 0 254\n\tif [ $? -ne 0 ]; then\n\t\techo \"FAIL: expected ping to .254 to fail ($logpostfix)\"\n\t\tlret=1\n\telse\n\t\techo \"PASS: ping to .254 bypassed ipsec tunnel ($logpostfix)\"\n\tfi\n\n\t# ping to .253 should use use ipsec due to direct policy exception.\n\tcheck_xfrm 1 253\n\tif [ $? -ne 0 ]; then\n\t\techo \"FAIL: expected ping to .253 to use ipsec tunnel ($logpostfix)\"\n\t\tlret=1\n\telse\n\t\techo \"PASS: direct policy matches ($logpostfix)\"\n\tfi\n\n\t# ping to .2 should use ipsec.\n\tcheck_xfrm 1 2\n\tif [ $? -ne 0 ]; then\n\t\techo \"FAIL: expected ping to .2 to use ipsec tunnel ($logpostfix)\"\n\t\tlret=1\n\telse\n\t\techo \"PASS: policy matches ($logpostfix)\"\n\tfi\n\n\treturn $lret\n}\n\ncheck_hthresh_repeat()\n{\n\tlocal log=$1\n\ti=0\n\n\tfor i in $(seq 1 10);do\n\t\tip -net ns1 xfrm policy update src e000:0001::0000 dst ff01::0014:0000:0001 dir in tmpl src :: dst :: proto esp mode tunnel priority 100 action allow || break\n\t\tip -net ns1 xfrm policy set hthresh6 0 28 || break\n\n\t\tip -net ns1 xfrm policy update src e000:0001::0000 dst ff01::01 dir in tmpl src :: dst :: proto esp mode tunnel priority 100 action allow || break\n\t\tip -net ns1 xfrm policy set hthresh6 0 28 || break\n\tdone\n\n\tif [ $i -ne 10 ] ;then\n\t\techo \"FAIL: $log\" 1>&2\n\t\tret=1\n\t\treturn 1\n\tfi\n\n\techo \"PASS: $log\"\n\treturn 0\n}\n\n# insert non-overlapping policies in a random order and check that\n# all of them can be fetched using the traffic selectors.\ncheck_random_order()\n{\n\tlocal ns=$1\n\tlocal log=$2\n\n\tfor i in $(seq 100); do\n\t\tip -net $ns xfrm policy flush\n\t\tfor j in $(seq 0 16 255 | sort -R); do\n\t\t\tip -net $ns xfrm policy add dst $j.0.0.0/24 dir out priority 10 action allow\n\t\tdone\n\t\tfor j in $(seq 0 16 255); do\n\t\t\tif ! ip -net $ns xfrm policy get dst $j.0.0.0/24 dir out > /dev/null; then\n\t\t\t\techo \"FAIL: $log\" 1>&2\n\t\t\t\treturn 1\n\t\t\tfi\n\t\tdone\n\tdone\n\n\tfor i in $(seq 100); do\n\t\tip -net $ns xfrm policy flush\n\t\tfor j in $(seq 0 16 255 | sort -R); do\n\t\t\tlocal addr=$(printf \"e000:0000:%02x00::/56\" $j)\n\t\t\tip -net $ns xfrm policy add dst $addr dir out priority 10 action allow\n\t\tdone\n\t\tfor j in $(seq 0 16 255); do\n\t\t\tlocal addr=$(printf \"e000:0000:%02x00::/56\" $j)\n\t\t\tif ! ip -net $ns xfrm policy get dst $addr dir out > /dev/null; then\n\t\t\t\techo \"FAIL: $log\" 1>&2\n\t\t\t\treturn 1\n\t\t\tfi\n\t\tdone\n\tdone\n\n\tip -net $ns xfrm policy flush\n\n\techo \"PASS: $log\"\n\treturn 0\n}\n\n#check for needed privileges\nif [ \"$(id -u)\" -ne 0 ];then\n\techo \"SKIP: Need root privileges\"\n\texit $ksft_skip\nfi\n\nip -Version 2>/dev/null >/dev/null\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without the ip tool\"\n\texit $ksft_skip\nfi\n\n# needed to check if policy lookup got valid ipsec result\niptables --version 2>/dev/null >/dev/null\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not run test without iptables tool\"\n\texit $ksft_skip\nfi\n\nfor i in 1 2 3 4; do\n    ip netns add ns$i\n    ip -net ns$i link set lo up\ndone\n\nDEV=veth0\nip link add $DEV netns ns1 type veth peer name eth1 netns ns3\nip link add $DEV netns ns2 type veth peer name eth1 netns ns4\n\nip link add $DEV netns ns3 type veth peer name veth0 netns ns4\n\nDEV=veth0\nfor i in 1 2; do\n    ip -net ns$i link set $DEV up\n    ip -net ns$i addr add 10.0.$i.2/24 dev $DEV\n    ip -net ns$i addr add dead:$i::2/64 dev $DEV\n\n    ip -net ns$i addr add 10.0.$i.253 dev $DEV\n    ip -net ns$i addr add 10.0.$i.254 dev $DEV\n    ip -net ns$i addr add dead:$i::fd dev $DEV\n    ip -net ns$i addr add dead:$i::fe dev $DEV\ndone\n\nfor i in 3 4; do\nip -net ns$i link set eth1 up\nip -net ns$i link set veth0 up\ndone\n\nip -net ns1 route add default via 10.0.1.1\nip -net ns2 route add default via 10.0.2.1\n\nip -net ns3 addr add 10.0.1.1/24 dev eth1\nip -net ns3 addr add 10.0.3.1/24 dev veth0\nip -net ns3 addr add 2001:1::1/64 dev eth1\nip -net ns3 addr add 2001:3::1/64 dev veth0\n\nip -net ns3 route add default via 10.0.3.10\n\nip -net ns4 addr add 10.0.2.1/24 dev eth1\nip -net ns4 addr add 10.0.3.10/24 dev veth0\nip -net ns4 addr add 2001:2::1/64 dev eth1\nip -net ns4 addr add 2001:3::10/64 dev veth0\nip -net ns4 route add default via 10.0.3.1\n\nfor j in 4 6; do\n\tfor i in 3 4;do\n\t\tip netns exec ns$i sysctl net.ipv$j.conf.eth1.forwarding=1 > /dev/null\n\t\tip netns exec ns$i sysctl net.ipv$j.conf.veth0.forwarding=1 > /dev/null\n\tdone\ndone\n\n# abuse iptables rule counter to check if ping matches a policy\nip netns exec ns3 iptables -p icmp -A FORWARD -m policy --dir out --pol ipsec\nip netns exec ns4 iptables -p icmp -A FORWARD -m policy --dir out --pol ipsec\nif [ $? -ne 0 ];then\n\techo \"SKIP: Could not insert iptables rule\"\n\tfor i in 1 2 3 4;do ip netns del ns$i;done\n\texit $ksft_skip\nfi\n\n#          localip  remoteip  localnet    remotenet\ndo_esp ns3 10.0.3.1 10.0.3.10 10.0.1.0/24 10.0.2.0/24 $SPI1 $SPI2\ndo_esp ns3 dead:3::1 dead:3::10 dead:1::/64 dead:2::/64 $SPI1 $SPI2\ndo_esp ns4 10.0.3.10 10.0.3.1 10.0.2.0/24 10.0.1.0/24 $SPI2 $SPI1\ndo_esp ns4 dead:3::10 dead:3::1 dead:2::/64 dead:1::/64 $SPI2 $SPI1\n\ndo_dummies4 ns3\ndo_dummies6 ns4\n\ndo_esp_policy_get_check ns3 10.0.1.0/24 10.0.2.0/24\ndo_esp_policy_get_check ns4 10.0.2.0/24 10.0.1.0/24\ndo_esp_policy_get_check ns3 dead:1::/64 dead:2::/64\ndo_esp_policy_get_check ns4 dead:2::/64 dead:1::/64\n\n# ping to .254 should use ipsec, exception is not installed.\ncheck_xfrm 1 254\nif [ $? -ne 0 ]; then\n\techo \"FAIL: expected ping to .254 to use ipsec tunnel\"\n\tret=1\nelse\n\techo \"PASS: policy before exception matches\"\nfi\n\n# installs exceptions\n#                localip  remoteip   encryptdst  plaindst\ndo_exception ns3 10.0.3.1 10.0.3.10 10.0.2.253 10.0.2.240/28\ndo_exception ns4 10.0.3.10 10.0.3.1 10.0.1.253 10.0.1.240/28\n\ndo_exception ns3 dead:3::1 dead:3::10 dead:2::fd  dead:2:f0::/96\ndo_exception ns4 dead:3::10 dead:3::1 dead:1::fd  dead:1:f0::/96\n\ncheck_exceptions \"exceptions\"\nif [ $? -ne 0 ]; then\n\tret=1\nfi\n\n# insert block policies with adjacent/overlapping netmasks\ndo_overlap ns3\n\ncheck_exceptions \"exceptions and block policies\"\nif [ $? -ne 0 ]; then\n\tret=1\nfi\n\nfor n in ns3 ns4;do\n\tip -net $n xfrm policy set hthresh4 28 24 hthresh6 126 125\n\tsleep $((RANDOM%5))\ndone\n\ncheck_exceptions \"exceptions and block policies after hresh changes\"\n\n# full flush of policy db, check everything gets freed incl. internal meta data\nip -net ns3 xfrm policy flush\n\ndo_esp_policy ns3 10.0.3.1 10.0.3.10 10.0.1.0/24 10.0.2.0/24\ndo_exception ns3 10.0.3.1 10.0.3.10 10.0.2.253 10.0.2.240/28\n\n# move inexact policies to hash table\nip -net ns3 xfrm policy set hthresh4 16 16\n\nsleep $((RANDOM%5))\ncheck_exceptions \"exceptions and block policies after hthresh change in ns3\"\n\n# restore original hthresh settings -- move policies back to tables\nfor n in ns3 ns4;do\n\tip -net $n xfrm policy set hthresh4 32 32 hthresh6 128 128\n\tsleep $((RANDOM%5))\ndone\ncheck_exceptions \"exceptions and block policies after htresh change to normal\"\n\ncheck_hthresh_repeat \"policies with repeated htresh change\"\n\ncheck_random_order ns3 \"policies inserted in random order\"\n\nfor i in 1 2 3 4;do ip netns del ns$i;done\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}