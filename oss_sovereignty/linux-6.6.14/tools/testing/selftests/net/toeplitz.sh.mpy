{
  "module_name": "toeplitz.sh",
  "hash_id": "d50cbac43d4caba8baa744e4f167546e18e6bc00af8cdf23485370eb7627b1fb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/toeplitz.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# extended toeplitz test: test rxhash plus, optionally, either (1) rss mapping\n# from rxhash to rx queue ('-rss') or (2) rps mapping from rxhash to cpu\n# ('-rps <rps_map>')\n#\n# irq-pattern-prefix can be derived from /sys/kernel/irq/*/action,\n# which is a driver-specific encoding.\n#\n# invoke as ./toeplitz.sh (-i <iface>) -u|-t -4|-6 \\\n# [(-rss -irq_prefix <irq-pattern-prefix>)|(-rps <rps_map>)]\n\nsource setup_loopback.sh\nreadonly SERVER_IP4=\"192.168.1.200/24\"\nreadonly SERVER_IP6=\"fda8::1/64\"\nreadonly SERVER_MAC=\"aa:00:00:00:00:02\"\n\nreadonly CLIENT_IP4=\"192.168.1.100/24\"\nreadonly CLIENT_IP6=\"fda8::2/64\"\nreadonly CLIENT_MAC=\"aa:00:00:00:00:01\"\n\nPORT=8000\nKEY=\"$(</proc/sys/net/core/netdev_rss_key)\"\nTEST_RSS=false\nRPS_MAP=\"\"\nPROTO_FLAG=\"\"\nIP_FLAG=\"\"\nDEV=\"eth0\"\n\n# Return the number of rxqs among which RSS is configured to spread packets.\n# This is determined by reading the RSS indirection table using ethtool.\nget_rss_cfg_num_rxqs() {\n\techo $(ethtool -x \"${DEV}\" |\n\t\tgrep -E [[:space:]]+[0-9]+:[[:space:]]+ |\n\t\tcut -d: -f2- |\n\t\tawk '{$1=$1};1' |\n\t\ttr ' ' '\\n' |\n\t\tsort -u |\n\t\twc -l)\n}\n\n# Return a list of the receive irq handler cpus.\n# The list is ordered by the irqs, so first rxq-0 cpu, then rxq-1 cpu, etc.\n# Reads /sys/kernel/irq/ in order, so algorithm depends on\n# irq_{rxq-0} < irq_{rxq-1}, etc.\nget_rx_irq_cpus() {\n\tCPUS=\"\"\n\t# sort so that irq 2 is read before irq 10\n\tSORTED_IRQS=$(for i in /sys/kernel/irq/*; do echo $i; done | sort -V)\n\t# Consider only as many queues as RSS actually uses. We assume that\n\t# if RSS_CFG_NUM_RXQS=N, then RSS uses rxqs 0-(N-1).\n\tRSS_CFG_NUM_RXQS=$(get_rss_cfg_num_rxqs)\n\tRXQ_COUNT=0\n\n\tfor i in ${SORTED_IRQS}\n\tdo\n\t\t[[ \"${RXQ_COUNT}\" -lt \"${RSS_CFG_NUM_RXQS}\" ]] || break\n\t\t# lookup relevant IRQs by action name\n\t\t[[ -e \"$i/actions\" ]] || continue\n\t\tcat \"$i/actions\" | grep -q \"${IRQ_PATTERN}\" || continue\n\t\tirqname=$(<\"$i/actions\")\n\n\t\t# does the IRQ get called\n\t\tirqcount=$(cat \"$i/per_cpu_count\" | tr -d '0,')\n\t\t[[ -n \"${irqcount}\" ]] || continue\n\n\t\t# lookup CPU\n\t\tirq=$(basename \"$i\")\n\t\tcpu=$(cat \"/proc/irq/$irq/smp_affinity_list\")\n\n\t\tif [[ -z \"${CPUS}\" ]]; then\n\t\t\tCPUS=\"${cpu}\"\n\t\telse\n\t\t\tCPUS=\"${CPUS},${cpu}\"\n\t\tfi\n\t\tRXQ_COUNT=$((RXQ_COUNT+1))\n\tdone\n\n\techo \"${CPUS}\"\n}\n\nget_disable_rfs_cmd() {\n\techo \"echo 0 > /proc/sys/net/core/rps_sock_flow_entries;\"\n}\n\nget_set_rps_bitmaps_cmd() {\n\tCMD=\"\"\n\tfor i in /sys/class/net/${DEV}/queues/rx-*/rps_cpus\n\tdo\n\t\tCMD=\"${CMD} echo $1 > ${i};\"\n\tdone\n\n\techo \"${CMD}\"\n}\n\nget_disable_rps_cmd() {\n\techo \"$(get_set_rps_bitmaps_cmd 0)\"\n}\n\ndie() {\n\techo \"$1\"\n\texit 1\n}\n\ncheck_nic_rxhash_enabled() {\n\tlocal -r pattern=\"receive-hashing:\\ on\"\n\n\tethtool -k \"${DEV}\" | grep -q \"${pattern}\" || die \"rxhash must be enabled\"\n}\n\nparse_opts() {\n\tlocal prog=$0\n\tshift 1\n\n\twhile [[ \"$1\" =~ \"-\" ]]; do\n\t\tif [[ \"$1\" = \"-irq_prefix\" ]]; then\n\t\t\tshift\n\t\t\tIRQ_PATTERN=\"^$1-[0-9]*$\"\n\t\telif [[ \"$1\" = \"-u\" || \"$1\" = \"-t\" ]]; then\n\t\t\tPROTO_FLAG=\"$1\"\n\t\telif [[ \"$1\" = \"-4\" ]]; then\n\t\t\tIP_FLAG=\"$1\"\n\t\t\tSERVER_IP=\"${SERVER_IP4}\"\n\t\t\tCLIENT_IP=\"${CLIENT_IP4}\"\n\t\telif [[ \"$1\" = \"-6\" ]]; then\n\t\t\tIP_FLAG=\"$1\"\n\t\t\tSERVER_IP=\"${SERVER_IP6}\"\n\t\t\tCLIENT_IP=\"${CLIENT_IP6}\"\n\t\telif [[ \"$1\" = \"-rss\" ]]; then\n\t\t\tTEST_RSS=true\n\t\telif [[ \"$1\" = \"-rps\" ]]; then\n\t\t\tshift\n\t\t\tRPS_MAP=\"$1\"\n\t\telif [[ \"$1\" = \"-i\" ]]; then\n\t\t\tshift\n\t\t\tDEV=\"$1\"\n\t\telse\n\t\t\tdie \"Usage: ${prog} (-i <iface>) -u|-t -4|-6 \\\n\t\t\t     [(-rss -irq_prefix <irq-pattern-prefix>)|(-rps <rps_map>)]\"\n\t\tfi\n\t\tshift\n\tdone\n}\n\nsetup() {\n\tsetup_loopback_environment \"${DEV}\"\n\n\t# Set up server_ns namespace and client_ns namespace\n\tsetup_macvlan_ns \"${DEV}\" server_ns server \\\n\t\"${SERVER_MAC}\" \"${SERVER_IP}\"\n\tsetup_macvlan_ns \"${DEV}\" client_ns client \\\n\t\"${CLIENT_MAC}\" \"${CLIENT_IP}\"\n}\n\ncleanup() {\n\tcleanup_macvlan_ns server_ns server client_ns client\n\tcleanup_loopback \"${DEV}\"\n}\n\nparse_opts $0 $@\n\nsetup\ntrap cleanup EXIT\n\ncheck_nic_rxhash_enabled\n\n# Actual test starts here\nif [[ \"${TEST_RSS}\" = true ]]; then\n\t# RPS/RFS must be disabled because they move packets between cpus,\n\t# which breaks the PACKET_FANOUT_CPU identification of RSS decisions.\n\teval \"$(get_disable_rfs_cmd) $(get_disable_rps_cmd)\" \\\n\t  ip netns exec server_ns ./toeplitz \"${IP_FLAG}\" \"${PROTO_FLAG}\" \\\n\t  -d \"${PORT}\" -i \"${DEV}\" -k \"${KEY}\" -T 1000 \\\n\t  -C \"$(get_rx_irq_cpus)\" -s -v &\nelif [[ ! -z \"${RPS_MAP}\" ]]; then\n\teval \"$(get_disable_rfs_cmd) $(get_set_rps_bitmaps_cmd ${RPS_MAP})\" \\\n\t  ip netns exec server_ns ./toeplitz \"${IP_FLAG}\" \"${PROTO_FLAG}\" \\\n\t  -d \"${PORT}\" -i \"${DEV}\" -k \"${KEY}\" -T 1000 \\\n\t  -r \"0x${RPS_MAP}\" -s -v &\nelse\n\tip netns exec server_ns ./toeplitz \"${IP_FLAG}\" \"${PROTO_FLAG}\" \\\n\t  -d \"${PORT}\" -i \"${DEV}\" -k \"${KEY}\" -T 1000 -s -v &\nfi\n\nserver_pid=$!\n\nip netns exec client_ns ./toeplitz_client.sh \"${PROTO_FLAG}\" \\\n  \"${IP_FLAG}\" \"${SERVER_IP%%/*}\" \"${PORT}\" &\n\nclient_pid=$!\n\nwait \"${server_pid}\"\nexit_code=$?\nkill -9 \"${client_pid}\"\nif [[ \"${exit_code}\" -eq 0 ]]; then\n\techo \"Test Succeeded!\"\nfi\nexit \"${exit_code}\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}