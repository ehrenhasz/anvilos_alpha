{
  "module_name": "reuseport_dualstack.c",
  "hash_id": "9d80a624706edaafc8045cd20018a30ab7c5a83ffe040a884b70e55be98dbf88",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/reuseport_dualstack.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <linux/in.h>\n#include <linux/unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nstatic const int PORT = 8888;\n\nstatic void build_rcv_fd(int family, int proto, int *rcv_fds, int count)\n{\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in  *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tint opt, i;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr4 = (struct sockaddr_in *)&addr;\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\t\taddr4->sin_port = htons(PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddr6 = (struct sockaddr_in6 *)&addr;\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_addr = in6addr_any;\n\t\taddr6->sin6_port = htons(PORT);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t}\n\n\tfor (i = 0; i < count; ++i) {\n\t\trcv_fds[i] = socket(family, proto, 0);\n\t\tif (rcv_fds[i] < 0)\n\t\t\terror(1, errno, \"failed to create receive socket\");\n\n\t\topt = 1;\n\t\tif (setsockopt(rcv_fds[i], SOL_SOCKET, SO_REUSEPORT, &opt,\n\t\t\t       sizeof(opt)))\n\t\t\terror(1, errno, \"failed to set SO_REUSEPORT\");\n\n\t\tif (bind(rcv_fds[i], (struct sockaddr *)&addr, sizeof(addr)))\n\t\t\terror(1, errno, \"failed to bind receive socket\");\n\n\t\tif (proto == SOCK_STREAM && listen(rcv_fds[i], 10))\n\t\t\terror(1, errno, \"failed to listen on receive port\");\n\t}\n}\n\nstatic void send_from_v4(int proto)\n{\n\tstruct sockaddr_in  saddr, daddr;\n\tint fd;\n\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = 0;\n\n\tdaddr.sin_family = AF_INET;\n\tdaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tdaddr.sin_port = htons(PORT);\n\n\tfd = socket(AF_INET, proto, 0);\n\tif (fd < 0)\n\t\terror(1, errno, \"failed to create send socket\");\n\n\tif (bind(fd, (struct sockaddr *)&saddr, sizeof(saddr)))\n\t\terror(1, errno, \"failed to bind send socket\");\n\n\tif (connect(fd, (struct sockaddr *)&daddr, sizeof(daddr)))\n\t\terror(1, errno, \"failed to connect send socket\");\n\n\tif (send(fd, \"a\", 1, 0) < 0)\n\t\terror(1, errno, \"failed to send message\");\n\n\tclose(fd);\n}\n\nstatic int receive_once(int epfd, int proto)\n{\n\tstruct epoll_event ev;\n\tint i, fd;\n\tchar buf[8];\n\n\ti = epoll_wait(epfd, &ev, 1, -1);\n\tif (i < 0)\n\t\terror(1, errno, \"epoll_wait failed\");\n\n\tif (proto == SOCK_STREAM) {\n\t\tfd = accept(ev.data.fd, NULL, NULL);\n\t\tif (fd < 0)\n\t\t\terror(1, errno, \"failed to accept\");\n\t\ti = recv(fd, buf, sizeof(buf), 0);\n\t\tclose(fd);\n\t} else {\n\t\ti = recv(ev.data.fd, buf, sizeof(buf), 0);\n\t}\n\n\tif (i < 0)\n\t\terror(1, errno, \"failed to recv\");\n\n\treturn ev.data.fd;\n}\n\nstatic void test(int *rcv_fds, int count, int proto)\n{\n\tstruct epoll_event ev;\n\tint epfd, i, test_fd;\n\tint test_family;\n\tsocklen_t len;\n\n\tepfd = epoll_create(1);\n\tif (epfd < 0)\n\t\terror(1, errno, \"failed to create epoll\");\n\n\tev.events = EPOLLIN;\n\tfor (i = 0; i < count; ++i) {\n\t\tev.data.fd = rcv_fds[i];\n\t\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, rcv_fds[i], &ev))\n\t\t\terror(1, errno, \"failed to register sock epoll\");\n\t}\n\n\tsend_from_v4(proto);\n\n\ttest_fd = receive_once(epfd, proto);\n\tlen = sizeof(test_family);\n\tif (getsockopt(test_fd, SOL_SOCKET, SO_DOMAIN, &test_family, &len))\n\t\terror(1, errno, \"failed to read socket domain\");\n\tif (test_family != AF_INET)\n\t\terror(1, 0, \"expected to receive on v4 socket but got v6 (%d)\",\n\t\t      test_family);\n\n\tclose(epfd);\n}\n\nint main(void)\n{\n\tint rcv_fds[32], i;\n\n\tfprintf(stderr, \"---- UDP IPv4 created before IPv6 ----\\n\");\n\tbuild_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds, 5);\n\tbuild_rcv_fd(AF_INET6, SOCK_DGRAM, &(rcv_fds[5]), 5);\n\ttest(rcv_fds, 10, SOCK_DGRAM);\n\tfor (i = 0; i < 10; ++i)\n\t\tclose(rcv_fds[i]);\n\n\tfprintf(stderr, \"---- UDP IPv6 created before IPv4 ----\\n\");\n\tbuild_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds, 5);\n\tbuild_rcv_fd(AF_INET, SOCK_DGRAM, &(rcv_fds[5]), 5);\n\ttest(rcv_fds, 10, SOCK_DGRAM);\n\tfor (i = 0; i < 10; ++i)\n\t\tclose(rcv_fds[i]);\n\n\t \n\tfprintf(stderr, \"---- UDP IPv4 created before IPv6 (large) ----\\n\");\n\tbuild_rcv_fd(AF_INET, SOCK_DGRAM, rcv_fds, 16);\n\tbuild_rcv_fd(AF_INET6, SOCK_DGRAM, &(rcv_fds[16]), 16);\n\ttest(rcv_fds, 32, SOCK_DGRAM);\n\tfor (i = 0; i < 32; ++i)\n\t\tclose(rcv_fds[i]);\n\n\tfprintf(stderr, \"---- UDP IPv6 created before IPv4 (large) ----\\n\");\n\tbuild_rcv_fd(AF_INET6, SOCK_DGRAM, rcv_fds, 16);\n\tbuild_rcv_fd(AF_INET, SOCK_DGRAM, &(rcv_fds[16]), 16);\n\ttest(rcv_fds, 32, SOCK_DGRAM);\n\tfor (i = 0; i < 32; ++i)\n\t\tclose(rcv_fds[i]);\n\n\tfprintf(stderr, \"---- TCP IPv4 created before IPv6 ----\\n\");\n\tbuild_rcv_fd(AF_INET, SOCK_STREAM, rcv_fds, 5);\n\tbuild_rcv_fd(AF_INET6, SOCK_STREAM, &(rcv_fds[5]), 5);\n\ttest(rcv_fds, 10, SOCK_STREAM);\n\tfor (i = 0; i < 10; ++i)\n\t\tclose(rcv_fds[i]);\n\n\tfprintf(stderr, \"---- TCP IPv6 created before IPv4 ----\\n\");\n\tbuild_rcv_fd(AF_INET6, SOCK_STREAM, rcv_fds, 5);\n\tbuild_rcv_fd(AF_INET, SOCK_STREAM, &(rcv_fds[5]), 5);\n\ttest(rcv_fds, 10, SOCK_STREAM);\n\tfor (i = 0; i < 10; ++i)\n\t\tclose(rcv_fds[i]);\n\n\tfprintf(stderr, \"SUCCESS\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}