{
  "module_name": "vxlan_bridge_1d.sh",
  "hash_id": "0ac80727958c6b9b2a90c2e93b6e114ac618f8393c3b7797c42dfa33d10b04b2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/vxlan_bridge_1d.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# +--------------------+                               +----------------------+\n# | H1 (vrf)           |                               |             H2 (vrf) |\n# |    + $h1           |                               |  + $h2               |\n# |    | 192.0.2.1/28  |                               |  | 192.0.2.2/28      |\n# +----|---------------+                               +--|-------------------+\n#      |                                                  |\n# +----|--------------------------------------------------|-------------------+\n# | SW |                                                  |                   |\n# | +--|--------------------------------------------------|-----------------+ |\n# | |  + $swp1                   BR1 (802.1d)             + $swp2           | |\n# | |                                                                       | |\n# | |  + vx1 (vxlan)                                                        | |\n# | |    local 192.0.2.17                                                   | |\n# | |    remote 192.0.2.34 192.0.2.50                                       | |\n# | |    id 1000 dstport $VXPORT                                            | |\n# | +-----------------------------------------------------------------------+ |\n# |                                                                           |\n# |  192.0.2.32/28 via 192.0.2.18                                             |\n# |  192.0.2.48/28 via 192.0.2.18                                             |\n# |                                                                           |\n# |    + $rp1                                                                 |\n# |    | 192.0.2.17/28                                                        |\n# +----|----------------------------------------------------------------------+\n#      |\n# +----|--------------------------------------------------------+\n# |    |                                             VRP2 (vrf) |\n# |    + $rp2                                                   |\n# |      192.0.2.18/28                                          |\n# |                                                             |   (maybe) HW\n# =============================================================================\n# |                                                             |  (likely) SW\n# |    + v1 (veth)                             + v3 (veth)      |\n# |    | 192.0.2.33/28                         | 192.0.2.49/28  |\n# +----|---------------------------------------|----------------+\n#      |                                       |\n# +----|------------------------------+   +----|------------------------------+\n# |    + v2 (veth)        NS1 (netns) |   |    + v4 (veth)        NS2 (netns) |\n# |      192.0.2.34/28                |   |      192.0.2.50/28                |\n# |                                   |   |                                   |\n# |   192.0.2.16/28 via 192.0.2.33    |   |   192.0.2.16/28 via 192.0.2.49    |\n# |   192.0.2.50/32 via 192.0.2.33    |   |   192.0.2.34/32 via 192.0.2.49    |\n# |                                   |   |                                   |\n# | +-------------------------------+ |   | +-------------------------------+ |\n# | |                  BR2 (802.1d) | |   | |                  BR2 (802.1d) | |\n# | |  + vx2 (vxlan)                | |   | |  + vx2 (vxlan)                | |\n# | |    local 192.0.2.34           | |   | |    local 192.0.2.50           | |\n# | |    remote 192.0.2.17          | |   | |    remote 192.0.2.17          | |\n# | |    remote 192.0.2.50          | |   | |    remote 192.0.2.34          | |\n# | |    id 1000 dstport $VXPORT    | |   | |    id 1000 dstport $VXPORT    | |\n# | |                               | |   | |                               | |\n# | |  + w1 (veth)                  | |   | |  + w1 (veth)                  | |\n# | +--|----------------------------+ |   | +--|----------------------------+ |\n# |    |                              |   |    |                              |\n# | +--|----------------------------+ |   | +--|----------------------------+ |\n# | |  |                  VW2 (vrf) | |   | |  |                  VW2 (vrf) | |\n# | |  + w2 (veth)                  | |   | |  + w2 (veth)                  | |\n# | |    192.0.2.3/28               | |   | |    192.0.2.4/28               | |\n# | +-------------------------------+ |   | +-------------------------------+ |\n# +-----------------------------------+   +-----------------------------------+\n\n: ${VXPORT:=4789}\nexport VXPORT\n\n: ${ALL_TESTS:=\"\n\tping_ipv4\n\ttest_flood\n\ttest_unicast\n\ttest_ttl\n\ttest_tos\n\ttest_ecn_encap\n\ttest_ecn_decap\n\treapply_config\n\tping_ipv4\n\ttest_flood\n\ttest_unicast\n\ttest_learning\n    \"}\n\nNUM_NETIFS=6\nsource lib.sh\n\nh1_create()\n{\n\tsimple_if_init $h1 192.0.2.1/28\n\ttc qdisc add dev $h1 clsact\n}\n\nh1_destroy()\n{\n\ttc qdisc del dev $h1 clsact\n\tsimple_if_fini $h1 192.0.2.1/28\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 192.0.2.2/28\n\ttc qdisc add dev $h2 clsact\n}\n\nh2_destroy()\n{\n\ttc qdisc del dev $h2 clsact\n\tsimple_if_fini $h2 192.0.2.2/28\n}\n\nrp1_set_addr()\n{\n\tip address add dev $rp1 192.0.2.17/28\n\n\tip route add 192.0.2.32/28 nexthop via 192.0.2.18\n\tip route add 192.0.2.48/28 nexthop via 192.0.2.18\n}\n\nrp1_unset_addr()\n{\n\tip route del 192.0.2.48/28 nexthop via 192.0.2.18\n\tip route del 192.0.2.32/28 nexthop via 192.0.2.18\n\n\tip address del dev $rp1 192.0.2.17/28\n}\n\nswitch_create()\n{\n\tip link add name br1 type bridge vlan_filtering 0 mcast_snooping 0\n\t# Make sure the bridge uses the MAC address of the local port and not\n\t# that of the VxLAN's device.\n\tip link set dev br1 address $(mac_get $swp1)\n\tip link set dev br1 up\n\n\tip link set dev $rp1 up\n\trp1_set_addr\n\n\tip link add name vx1 type vxlan id 1000\t\t\\\n\t\tlocal 192.0.2.17 dstport \"$VXPORT\"\t\\\n\t\tnolearning noudpcsum tos inherit ttl 100\n\tip link set dev vx1 up\n\n\tip link set dev vx1 master br1\n\tip link set dev $swp1 master br1\n\tip link set dev $swp1 up\n\n\tip link set dev $swp2 master br1\n\tip link set dev $swp2 up\n\n\tbridge fdb append dev vx1 00:00:00:00:00:00 dst 192.0.2.34 self\n\tbridge fdb append dev vx1 00:00:00:00:00:00 dst 192.0.2.50 self\n}\n\nswitch_destroy()\n{\n\trp1_unset_addr\n\tip link set dev $rp1 down\n\n\tbridge fdb del dev vx1 00:00:00:00:00:00 dst 192.0.2.50 self\n\tbridge fdb del dev vx1 00:00:00:00:00:00 dst 192.0.2.34 self\n\n\tip link set dev vx1 nomaster\n\tip link set dev vx1 down\n\tip link del dev vx1\n\n\tip link set dev $swp2 down\n\tip link set dev $swp2 nomaster\n\n\tip link set dev $swp1 down\n\tip link set dev $swp1 nomaster\n\n\tip link set dev br1 down\n\tip link del dev br1\n}\n\nvrp2_create()\n{\n\tsimple_if_init $rp2 192.0.2.18/28\n\t__simple_if_init v1 v$rp2 192.0.2.33/28\n\t__simple_if_init v3 v$rp2 192.0.2.49/28\n\ttc qdisc add dev v1 clsact\n}\n\nvrp2_destroy()\n{\n\ttc qdisc del dev v1 clsact\n\t__simple_if_fini v3 192.0.2.49/28\n\t__simple_if_fini v1 192.0.2.33/28\n\tsimple_if_fini $rp2 192.0.2.18/28\n}\n\nns_init_common()\n{\n\tlocal in_if=$1; shift\n\tlocal in_addr=$1; shift\n\tlocal other_in_addr=$1; shift\n\tlocal nh_addr=$1; shift\n\tlocal host_addr=$1; shift\n\n\tip link set dev $in_if up\n\tip address add dev $in_if $in_addr/28\n\ttc qdisc add dev $in_if clsact\n\n\tip link add name br2 type bridge vlan_filtering 0\n\tip link set dev br2 up\n\n\tip link add name w1 type veth peer name w2\n\n\tip link set dev w1 master br2\n\tip link set dev w1 up\n\n\tip link add name vx2 type vxlan id 1000 local $in_addr dstport \"$VXPORT\"\n\tip link set dev vx2 up\n\tbridge fdb append dev vx2 00:00:00:00:00:00 dst 192.0.2.17 self\n\tbridge fdb append dev vx2 00:00:00:00:00:00 dst $other_in_addr self\n\n\tip link set dev vx2 master br2\n\ttc qdisc add dev vx2 clsact\n\n\tsimple_if_init w2 $host_addr/28\n\n\tip route add 192.0.2.16/28 nexthop via $nh_addr\n\tip route add $other_in_addr/32 nexthop via $nh_addr\n}\nexport -f ns_init_common\n\nns1_create()\n{\n\tip netns add ns1\n\tip link set dev v2 netns ns1\n\tin_ns ns1 \\\n\t      ns_init_common v2 192.0.2.34 192.0.2.50 192.0.2.33 192.0.2.3\n}\n\nns1_destroy()\n{\n\tip netns exec ns1 ip link set dev v2 netns 1\n\tip netns del ns1\n}\n\nns2_create()\n{\n\tip netns add ns2\n\tip link set dev v4 netns ns2\n\tin_ns ns2 \\\n\t      ns_init_common v4 192.0.2.50 192.0.2.34 192.0.2.49 192.0.2.4\n}\n\nns2_destroy()\n{\n\tip netns exec ns2 ip link set dev v4 netns 1\n\tip netns del ns2\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\trp1=${NETIFS[p5]}\n\trp2=${NETIFS[p6]}\n\n\tvrf_prepare\n\tforwarding_enable\n\n\th1_create\n\th2_create\n\tswitch_create\n\n\tip link add name v1 type veth peer name v2\n\tip link add name v3 type veth peer name v4\n\tvrp2_create\n\tns1_create\n\tns2_create\n\n\tr1_mac=$(in_ns ns1 mac_get w2)\n\tr2_mac=$(in_ns ns2 mac_get w2)\n\th2_mac=$(mac_get $h2)\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tns2_destroy\n\tns1_destroy\n\tvrp2_destroy\n\tip link del dev v3\n\tip link del dev v1\n\n\tswitch_destroy\n\th2_destroy\n\th1_destroy\n\n\tforwarding_restore\n\tvrf_cleanup\n}\n\n# For the first round of tests, vx1 is the first device to get attached to the\n# bridge, and that at the point that the local IP is already configured. Try the\n# other scenario of attaching the device to an already-offloaded bridge, and\n# only then attach the local IP.\nreapply_config()\n{\n\techo \"Reapplying configuration\"\n\n\tbridge fdb del dev vx1 00:00:00:00:00:00 dst 192.0.2.50 self\n\tbridge fdb del dev vx1 00:00:00:00:00:00 dst 192.0.2.34 self\n\trp1_unset_addr\n\tip link set dev vx1 nomaster\n\tsleep 5\n\n\tip link set dev vx1 master br1\n\tbridge fdb append dev vx1 00:00:00:00:00:00 dst 192.0.2.34 self\n\tbridge fdb append dev vx1 00:00:00:00:00:00 dst 192.0.2.50 self\n\tsleep 1\n\trp1_set_addr\n\tsleep 5\n}\n\nping_ipv4()\n{\n\tping_test $h1 192.0.2.2 \": local->local\"\n\tping_test $h1 192.0.2.3 \": local->remote 1\"\n\tping_test $h1 192.0.2.4 \": local->remote 2\"\n}\n\nmaybe_in_ns()\n{\n\techo ${1:+in_ns} $1\n}\n\n__flood_counter_add_del()\n{\n\tlocal add_del=$1; shift\n\tlocal dev=$1; shift\n\tlocal ns=$1; shift\n\n\t# Putting the ICMP capture both to HW and to SW will end up\n\t# double-counting the packets that are trapped to slow path, such as for\n\t# the unicast test. Adding either skip_hw or skip_sw fixes this problem,\n\t# but with skip_hw, the flooded packets are not counted at all, because\n\t# those are dropped due to MAC address mismatch; and skip_sw is a no-go\n\t# for veth-based topologies.\n\t#\n\t# So try to install with skip_sw and fall back to skip_sw if that fails.\n\n\t$(maybe_in_ns $ns) __icmp_capture_add_del          \\\n\t\t\t   $add_del 100 \"\" $dev skip_sw 2>/dev/null || \\\n\t$(maybe_in_ns $ns) __icmp_capture_add_del          \\\n\t\t\t   $add_del 100 \"\" $dev skip_hw\n}\n\nflood_counter_install()\n{\n\t__flood_counter_add_del add \"$@\"\n}\n\nflood_counter_uninstall()\n{\n\t__flood_counter_add_del del \"$@\"\n}\n\nflood_fetch_stat()\n{\n\tlocal dev=$1; shift\n\tlocal ns=$1; shift\n\n\t$(maybe_in_ns $ns) tc_rule_stats_get $dev 100 ingress\n}\n\nflood_fetch_stats()\n{\n\tlocal counters=(\"${@}\")\n\tlocal counter\n\n\tfor counter in \"${counters[@]}\"; do\n\t\tflood_fetch_stat $counter\n\tdone\n}\n\nvxlan_flood_test()\n{\n\tlocal mac=$1; shift\n\tlocal dst=$1; shift\n\tlocal -a expects=(\"${@}\")\n\n\tlocal -a counters=($h2 \"vx2 ns1\" \"vx2 ns2\")\n\tlocal counter\n\tlocal key\n\n\tfor counter in \"${counters[@]}\"; do\n\t\tflood_counter_install $counter\n\tdone\n\n\tlocal -a t0s=($(flood_fetch_stats \"${counters[@]}\"))\n\t$MZ $h1 -c 10 -d 100msec -p 64 -b $mac -B $dst -t icmp -q\n\tsleep 1\n\tlocal -a t1s=($(flood_fetch_stats \"${counters[@]}\"))\n\n\tfor key in ${!t0s[@]}; do\n\t\tlocal delta=$((t1s[$key] - t0s[$key]))\n\t\tlocal expect=${expects[$key]}\n\n\t\t((expect == delta))\n\t\tcheck_err $? \"${counters[$key]}: Expected to capture $expect packets, got $delta.\"\n\tdone\n\n\tfor counter in \"${counters[@]}\"; do\n\t\tflood_counter_uninstall $counter\n\tdone\n}\n\n__test_flood()\n{\n\tlocal mac=$1; shift\n\tlocal dst=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tvxlan_flood_test $mac $dst 10 10 10\n\n\tlog_test \"VXLAN: $what\"\n}\n\ntest_flood()\n{\n\t__test_flood de:ad:be:ef:13:37 192.0.2.100 \"flood\"\n}\n\nvxlan_fdb_add_del()\n{\n\tlocal add_del=$1; shift\n\tlocal mac=$1; shift\n\tlocal dev=$1; shift\n\tlocal dst=$1; shift\n\n\tbridge fdb $add_del dev $dev $mac self static permanent \\\n\t\t${dst:+dst} $dst 2>/dev/null\n\tbridge fdb $add_del dev $dev $mac master static 2>/dev/null\n}\n\n__test_unicast()\n{\n\tlocal mac=$1; shift\n\tlocal dst=$1; shift\n\tlocal hit_idx=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tlocal -a expects=(0 0 0)\n\texpects[$hit_idx]=10\n\n\tvxlan_flood_test $mac $dst \"${expects[@]}\"\n\n\tlog_test \"VXLAN: $what\"\n}\n\ntest_unicast()\n{\n\tlocal -a targets=(\"$h2_mac $h2\"\n\t\t\t  \"$r1_mac vx1 192.0.2.34\"\n\t\t\t  \"$r2_mac vx1 192.0.2.50\")\n\tlocal target\n\n\tfor target in \"${targets[@]}\"; do\n\t\tvxlan_fdb_add_del add $target\n\tdone\n\n\t__test_unicast $h2_mac 192.0.2.2 0 \"local MAC unicast\"\n\t__test_unicast $r1_mac 192.0.2.3 1 \"remote MAC 1 unicast\"\n\t__test_unicast $r2_mac 192.0.2.4 2 \"remote MAC 2 unicast\"\n\n\tfor target in \"${targets[@]}\"; do\n\t\tvxlan_fdb_add_del del $target\n\tdone\n}\n\nvxlan_ping_test()\n{\n\tlocal ping_dev=$1; shift\n\tlocal ping_dip=$1; shift\n\tlocal ping_args=$1; shift\n\tlocal capture_dev=$1; shift\n\tlocal capture_dir=$1; shift\n\tlocal capture_pref=$1; shift\n\tlocal expect=$1; shift\n\n\tlocal t0=$(tc_rule_stats_get $capture_dev $capture_pref $capture_dir)\n\tping_do $ping_dev $ping_dip \"$ping_args\"\n\tlocal t1=$(tc_rule_stats_get $capture_dev $capture_pref $capture_dir)\n\tlocal delta=$((t1 - t0))\n\n\t# Tolerate a couple stray extra packets.\n\t((expect <= delta && delta <= expect + 2))\n\tcheck_err $? \"$capture_dev: Expected to capture $expect packets, got $delta.\"\n}\n\ntest_ttl()\n{\n\tRET=0\n\n\ttc filter add dev v1 egress pref 77 prot ip \\\n\t\tflower ip_ttl 99 action pass\n\tvxlan_ping_test $h1 192.0.2.3 \"\" v1 egress 77 10\n\ttc filter del dev v1 egress pref 77 prot ip\n\n\tlog_test \"VXLAN: envelope TTL\"\n}\n\ntest_tos()\n{\n\tRET=0\n\n\ttc filter add dev v1 egress pref 77 prot ip \\\n\t\tflower ip_tos 0x14 action pass\n\tvxlan_ping_test $h1 192.0.2.3 \"-Q 0x14\" v1 egress 77 10\n\tvxlan_ping_test $h1 192.0.2.3 \"-Q 0x18\" v1 egress 77 0\n\ttc filter del dev v1 egress pref 77 prot ip\n\n\tlog_test \"VXLAN: envelope TOS inheritance\"\n}\n\n__test_ecn_encap()\n{\n\tlocal q=$1; shift\n\tlocal tos=$1; shift\n\n\tRET=0\n\n\ttc filter add dev v1 egress pref 77 prot ip \\\n\t\tflower ip_tos $tos action pass\n\tsleep 1\n\tvxlan_ping_test $h1 192.0.2.3 \"-Q $q\" v1 egress 77 10\n\ttc filter del dev v1 egress pref 77 prot ip\n\n\tlog_test \"VXLAN: ECN encap: $q->$tos\"\n}\n\ntest_ecn_encap()\n{\n\t# In accordance with INET_ECN_encapsulate()\n\t__test_ecn_encap 0x00 0x00\n\t__test_ecn_encap 0x01 0x01\n\t__test_ecn_encap 0x02 0x02\n\t__test_ecn_encap 0x03 0x02\n}\n\nvxlan_encapped_ping_do()\n{\n\tlocal count=$1; shift\n\tlocal dev=$1; shift\n\tlocal next_hop_mac=$1; shift\n\tlocal dest_ip=$1; shift\n\tlocal dest_mac=$1; shift\n\tlocal inner_tos=$1; shift\n\tlocal outer_tos=$1; shift\n\n\t$MZ $dev -c $count -d 100msec -q \\\n\t\t-b $next_hop_mac -B $dest_ip \\\n\t\t-t udp tos=$outer_tos,sp=23456,dp=$VXPORT,p=$(:\n\t\t    )\"08:\"$(                      : VXLAN flags\n\t\t    )\"00:00:00:\"$(                : VXLAN reserved\n\t\t    )\"00:03:e8:\"$(                : VXLAN VNI\n\t\t    )\"00:\"$(                      : VXLAN reserved\n\t\t    )\"$dest_mac:\"$(               : ETH daddr\n\t\t    )\"$(mac_get w2):\"$(           : ETH saddr\n\t\t    )\"08:00:\"$(                   : ETH type\n\t\t    )\"45:\"$(                      : IP version + IHL\n\t\t    )\"$inner_tos:\"$(              : IP TOS\n\t\t    )\"00:54:\"$(                   : IP total length\n\t\t    )\"99:83:\"$(                   : IP identification\n\t\t    )\"40:00:\"$(                   : IP flags + frag off\n\t\t    )\"40:\"$(                      : IP TTL\n\t\t    )\"01:\"$(                      : IP proto\n\t\t    )\"00:00:\"$(                   : IP header csum\n\t\t    )\"c0:00:02:03:\"$(             : IP saddr: 192.0.2.3\n\t\t    )\"c0:00:02:01:\"$(             : IP daddr: 192.0.2.1\n\t\t    )\"08:\"$(                      : ICMP type\n\t\t    )\"00:\"$(                      : ICMP code\n\t\t    )\"8b:f2:\"$(                   : ICMP csum\n\t\t    )\"1f:6a:\"$(                   : ICMP request identifier\n\t\t    )\"00:01:\"$(                   : ICMP request sequence number\n\t\t    )\"4f:ff:c5:5b:00:00:00:00:\"$( : ICMP payload\n\t\t    )\"6d:74:0b:00:00:00:00:00:\"$( :\n\t\t    )\"10:11:12:13:14:15:16:17:\"$( :\n\t\t    )\"18:19:1a:1b:1c:1d:1e:1f:\"$( :\n\t\t    )\"20:21:22:23:24:25:26:27:\"$( :\n\t\t    )\"28:29:2a:2b:2c:2d:2e:2f:\"$( :\n\t\t    )\"30:31:32:33:34:35:36:37\"\n}\nexport -f vxlan_encapped_ping_do\n\nvxlan_encapped_ping_test()\n{\n\tlocal ping_dev=$1; shift\n\tlocal nh_dev=$1; shift\n\tlocal ping_dip=$1; shift\n\tlocal inner_tos=$1; shift\n\tlocal outer_tos=$1; shift\n\tlocal stat_get=$1; shift\n\tlocal expect=$1; shift\n\n\tlocal t0=$($stat_get)\n\n\tin_ns ns1 \\\n\t\tvxlan_encapped_ping_do 10 $ping_dev $(mac_get $nh_dev) \\\n\t\t\t$ping_dip $(mac_get $h1) \\\n\t\t\t$inner_tos $outer_tos\n\n\tlocal t1=$($stat_get)\n\tlocal delta=$((t1 - t0))\n\n\t# Tolerate a couple stray extra packets.\n\t((expect <= delta && delta <= expect + 2))\n\tcheck_err $? \"Expected to capture $expect packets, got $delta.\"\n}\nexport -f vxlan_encapped_ping_test\n\n__test_ecn_decap()\n{\n\tlocal orig_inner_tos=$1; shift\n\tlocal orig_outer_tos=$1; shift\n\tlocal decapped_tos=$1; shift\n\n\tRET=0\n\n\ttc filter add dev $h1 ingress pref 77 prot ip \\\n\t\tflower ip_tos $decapped_tos action drop\n\tsleep 1\n\tvxlan_encapped_ping_test v2 v1 192.0.2.17 \\\n\t\t\t\t $orig_inner_tos $orig_outer_tos \\\n\t\t\t\t \"tc_rule_stats_get $h1 77 ingress\" 10\n\ttc filter del dev $h1 ingress pref 77\n\n\tlog_test \"VXLAN: ECN decap: $orig_outer_tos/$orig_inner_tos->$decapped_tos\"\n}\n\ntest_ecn_decap_error()\n{\n\tlocal orig_inner_tos=00\n\tlocal orig_outer_tos=03\n\n\tRET=0\n\n\tvxlan_encapped_ping_test v2 v1 192.0.2.17 \\\n\t\t\t\t $orig_inner_tos $orig_outer_tos \\\n\t\t\t\t \"link_stats_rx_errors_get vx1\" 10\n\n\tlog_test \"VXLAN: ECN decap: $orig_outer_tos/$orig_inner_tos->error\"\n}\n\ntest_ecn_decap()\n{\n\t# In accordance with INET_ECN_decapsulate()\n\t__test_ecn_decap 00 00 0x00\n\t__test_ecn_decap 00 01 0x00\n\t__test_ecn_decap 00 02 0x00\n\t# 00 03 is tested in test_ecn_decap_error()\n\t__test_ecn_decap 01 00 0x01\n\t__test_ecn_decap 01 01 0x01\n\t__test_ecn_decap 01 02 0x01\n\t__test_ecn_decap 01 03 0x03\n\t__test_ecn_decap 02 00 0x02\n\t__test_ecn_decap 02 01 0x01\n\t__test_ecn_decap 02 02 0x02\n\t__test_ecn_decap 02 03 0x03\n\t__test_ecn_decap 03 00 0x03\n\t__test_ecn_decap 03 01 0x03\n\t__test_ecn_decap 03 02 0x03\n\t__test_ecn_decap 03 03 0x03\n\ttest_ecn_decap_error\n}\n\ntest_learning()\n{\n\tlocal mac=de:ad:be:ef:13:37\n\tlocal dst=192.0.2.100\n\n\t# Enable learning on the VxLAN device and set ageing time to 10 seconds\n\tip link set dev br1 type bridge ageing_time 1000\n\tip link set dev vx1 type vxlan ageing 10\n\tip link set dev vx1 type vxlan learning\n\treapply_config\n\n\t# Check that flooding works\n\tRET=0\n\n\tvxlan_flood_test $mac $dst 10 10 10\n\n\tlog_test \"VXLAN: flood before learning\"\n\n\t# Send a packet with source mac set to $mac from host w2 and check that\n\t# a corresponding entry is created in VxLAN device vx1\n\tRET=0\n\n\tin_ns ns1 $MZ w2 -c 1 -p 64 -a $mac -b ff:ff:ff:ff:ff:ff -B $dst \\\n\t\t-t icmp -q\n\tsleep 1\n\n\tbridge fdb show brport vx1 | grep $mac | grep -q self\n\tcheck_err $?\n\tbridge fdb show brport vx1 | grep $mac | grep -q -v self\n\tcheck_err $?\n\n\tlog_test \"VXLAN: show learned FDB entry\"\n\n\t# Repeat first test and check that packets only reach host w2 in ns1\n\tRET=0\n\n\tvxlan_flood_test $mac $dst 0 10 0\n\n\tlog_test \"VXLAN: learned FDB entry\"\n\n\t# Delete the learned FDB entry from the VxLAN and bridge devices and\n\t# check that packets are flooded\n\tRET=0\n\n\tbridge fdb del dev vx1 $mac master self\n\tsleep 1\n\n\tvxlan_flood_test $mac $dst 10 10 10\n\n\tlog_test \"VXLAN: deletion of learned FDB entry\"\n\n\t# Re-learn the first FDB entry and check that it is correctly aged-out\n\tRET=0\n\n\tin_ns ns1 $MZ w2 -c 1 -p 64 -a $mac -b ff:ff:ff:ff:ff:ff -B $dst \\\n\t\t-t icmp -q\n\tsleep 1\n\n\tbridge fdb show brport vx1 | grep $mac | grep -q self\n\tcheck_err $?\n\tbridge fdb show brport vx1 | grep $mac | grep -q -v self\n\tcheck_err $?\n\n\tvxlan_flood_test $mac $dst 0 10 0\n\n\tsleep 20\n\n\tbridge fdb show brport vx1 | grep $mac | grep -q self\n\tcheck_fail $?\n\tbridge fdb show brport vx1 | grep $mac | grep -q -v self\n\tcheck_fail $?\n\n\tvxlan_flood_test $mac $dst 10 10 10\n\n\tlog_test \"VXLAN: Ageing of learned FDB entry\"\n\n\t# Toggle learning on the bridge port and check that the bridge's FDB\n\t# is populated only when it should\n\tRET=0\n\n\tip link set dev vx1 type bridge_slave learning off\n\n\tin_ns ns1 $MZ w2 -c 1 -p 64 -a $mac -b ff:ff:ff:ff:ff:ff -B $dst \\\n\t\t-t icmp -q\n\tsleep 1\n\n\tbridge fdb show brport vx1 | grep $mac | grep -q -v self\n\tcheck_fail $?\n\n\tip link set dev vx1 type bridge_slave learning on\n\n\tin_ns ns1 $MZ w2 -c 1 -p 64 -a $mac -b ff:ff:ff:ff:ff:ff -B $dst \\\n\t\t-t icmp -q\n\tsleep 1\n\n\tbridge fdb show brport vx1 | grep $mac | grep -q -v self\n\tcheck_err $?\n\n\tlog_test \"VXLAN: learning toggling on bridge port\"\n\n\t# Restore previous settings\n\tip link set dev vx1 type vxlan nolearning\n\tip link set dev vx1 type vxlan ageing 300\n\tip link set dev br1 type bridge ageing_time 30000\n\treapply_config\n}\n\ntest_all()\n{\n\techo \"Running tests with UDP port $VXPORT\"\n\ttests_run\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\ntest_all\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}