{
  "module_name": "mirror_lib.sh",
  "hash_id": "10398c595962d29ece1a05d2ed77897c94da8f1a0aa3e38e8199a39e52fd978f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/mirror_lib.sh",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n\nmirror_install()\n{\n\tlocal from_dev=$1; shift\n\tlocal direction=$1; shift\n\tlocal to_dev=$1; shift\n\tlocal filter=$1; shift\n\n\ttc filter add dev $from_dev $direction \\\n\t   pref 1000 $filter \\\n\t   action mirred egress mirror dev $to_dev\n}\n\nmirror_uninstall()\n{\n\tlocal from_dev=$1; shift\n\tlocal direction=$1; shift\n\n\ttc filter del dev $swp1 $direction pref 1000\n}\n\nis_ipv6()\n{\n\tlocal addr=$1; shift\n\n\t[[ -z ${addr//[0-9a-fA-F:]/} ]]\n}\n\nmirror_test()\n{\n\tlocal vrf_name=$1; shift\n\tlocal sip=$1; shift\n\tlocal dip=$1; shift\n\tlocal dev=$1; shift\n\tlocal pref=$1; shift\n\tlocal expect=$1; shift\n\n\tif is_ipv6 $dip; then\n\t\tlocal proto=-6\n\t\tlocal type=\"icmp6 type=128\" # Echo request.\n\telse\n\t\tlocal proto=\n\t\tlocal type=\"icmp echoreq\"\n\tfi\n\n\tlocal t0=$(tc_rule_stats_get $dev $pref)\n\t$MZ $proto $vrf_name ${sip:+-A $sip} -B $dip -a own -b bc -q \\\n\t    -c 10 -d 100msec -t $type\n\tsleep 0.5\n\tlocal t1=$(tc_rule_stats_get $dev $pref)\n\tlocal delta=$((t1 - t0))\n\t# Tolerate a couple stray extra packets.\n\t((expect <= delta && delta <= expect + 2))\n\tcheck_err $? \"Expected to capture $expect packets, got $delta.\"\n}\n\ndo_test_span_dir_ips()\n{\n\tlocal expect=$1; shift\n\tlocal dev=$1; shift\n\tlocal direction=$1; shift\n\tlocal ip1=$1; shift\n\tlocal ip2=$1; shift\n\n\ticmp_capture_install $dev\n\tmirror_test v$h1 $ip1 $ip2 $dev 100 $expect\n\tmirror_test v$h2 $ip2 $ip1 $dev 100 $expect\n\ticmp_capture_uninstall $dev\n}\n\nquick_test_span_dir_ips()\n{\n\tdo_test_span_dir_ips 10 \"$@\"\n}\n\nfail_test_span_dir_ips()\n{\n\tdo_test_span_dir_ips 0 \"$@\"\n}\n\ntest_span_dir_ips()\n{\n\tlocal dev=$1; shift\n\tlocal direction=$1; shift\n\tlocal forward_type=$1; shift\n\tlocal backward_type=$1; shift\n\tlocal ip1=$1; shift\n\tlocal ip2=$1; shift\n\n\tquick_test_span_dir_ips \"$dev\" \"$direction\" \"$ip1\" \"$ip2\"\n\n\ticmp_capture_install $dev \"type $forward_type\"\n\tmirror_test v$h1 $ip1 $ip2 $dev 100 10\n\ticmp_capture_uninstall $dev\n\n\ticmp_capture_install $dev \"type $backward_type\"\n\tmirror_test v$h2 $ip2 $ip1 $dev 100 10\n\ticmp_capture_uninstall $dev\n}\n\nfail_test_span_dir()\n{\n\tfail_test_span_dir_ips \"$@\" 192.0.2.1 192.0.2.2\n}\n\ntest_span_dir()\n{\n\ttest_span_dir_ips \"$@\" 192.0.2.1 192.0.2.2\n}\n\ndo_test_span_vlan_dir_ips()\n{\n\tlocal expect=$1; shift\n\tlocal dev=$1; shift\n\tlocal vid=$1; shift\n\tlocal direction=$1; shift\n\tlocal ul_proto=$1; shift\n\tlocal ip1=$1; shift\n\tlocal ip2=$1; shift\n\n\t# Install the capture as skip_hw to avoid double-counting of packets.\n\t# The traffic is meant for local box anyway, so will be trapped to\n\t# kernel.\n\tvlan_capture_install $dev \"skip_hw vlan_id $vid vlan_ethtype $ul_proto\"\n\tmirror_test v$h1 $ip1 $ip2 $dev 100 $expect\n\tmirror_test v$h2 $ip2 $ip1 $dev 100 $expect\n\tvlan_capture_uninstall $dev\n}\n\nquick_test_span_vlan_dir_ips()\n{\n\tdo_test_span_vlan_dir_ips 10 \"$@\"\n}\n\nfail_test_span_vlan_dir_ips()\n{\n\tdo_test_span_vlan_dir_ips 0 \"$@\"\n}\n\nquick_test_span_vlan_dir()\n{\n\tquick_test_span_vlan_dir_ips \"$@\" 192.0.2.1 192.0.2.2\n}\n\nfail_test_span_vlan_dir()\n{\n\tfail_test_span_vlan_dir_ips \"$@\" 192.0.2.1 192.0.2.2\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}