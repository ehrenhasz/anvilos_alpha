{
  "module_name": "mirror_gre_changes.sh",
  "hash_id": "30a9fca4d91f62b25d78f6a32d37128c9822ba731d87454e68a08d7b2bd9ddfa",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/mirror_gre_changes.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# This test uses standard topology for testing gretap. See\n# mirror_gre_topo_lib.sh for more details.\n#\n# Test how mirrors to gretap and ip6gretap react to changes to relevant\n# configuration.\n\nALL_TESTS=\"\n\ttest_ttl\n\ttest_tun_up\n\ttest_egress_up\n\ttest_remote_ip\n\ttest_tun_del\n\ttest_route_del\n\"\n\nNUM_NETIFS=6\nsource lib.sh\nsource mirror_lib.sh\nsource mirror_gre_lib.sh\nsource mirror_gre_topo_lib.sh\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\tswp3=${NETIFS[p5]}\n\th3=${NETIFS[p6]}\n\n\tvrf_prepare\n\tmirror_gre_topo_create\n\n\t# This test downs $swp3, which deletes the configured IPv6 address\n\t# unless this sysctl is set.\n\tsysctl_set net.ipv6.conf.$swp3.keep_addr_on_down 1\n\n\tip address add dev $swp3 192.0.2.129/28\n\tip address add dev $h3 192.0.2.130/28\n\n\tip address add dev $swp3 2001:db8:2::1/64\n\tip address add dev $h3 2001:db8:2::2/64\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tip address del dev $h3 2001:db8:2::2/64\n\tip address del dev $swp3 2001:db8:2::1/64\n\n\tip address del dev $h3 192.0.2.130/28\n\tip address del dev $swp3 192.0.2.129/28\n\n\tsysctl_restore net.ipv6.conf.$swp3.keep_addr_on_down\n\n\tmirror_gre_topo_destroy\n\tvrf_cleanup\n}\n\ntest_span_gre_ttl()\n{\n\tlocal tundev=$1; shift\n\tlocal type=$1; shift\n\tlocal prot=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tmirror_install $swp1 ingress $tundev \\\n\t\t\"prot ip flower $tcflags ip_prot icmp\"\n\ttc filter add dev $h3 ingress pref 77 prot $prot \\\n\t\tflower skip_hw ip_ttl 50 action pass\n\n\tmirror_test v$h1 192.0.2.1 192.0.2.2 $h3 77 0\n\n\tip link set dev $tundev type $type ttl 50\n\tsleep 2\n\tmirror_test v$h1 192.0.2.1 192.0.2.2 $h3 77 10\n\n\tip link set dev $tundev type $type ttl 100\n\ttc filter del dev $h3 ingress pref 77\n\tmirror_uninstall $swp1 ingress\n\n\tlog_test \"$what: TTL change ($tcflags)\"\n}\n\ntest_span_gre_tun_up()\n{\n\tlocal tundev=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tip link set dev $tundev down\n\tmirror_install $swp1 ingress $tundev \"matchall $tcflags\"\n\tfail_test_span_gre_dir $tundev ingress\n\n\tip link set dev $tundev up\n\n\tquick_test_span_gre_dir $tundev ingress\n\tmirror_uninstall $swp1 ingress\n\n\tlog_test \"$what: tunnel down/up ($tcflags)\"\n}\n\ntest_span_gre_egress_up()\n{\n\tlocal tundev=$1; shift\n\tlocal remote_ip=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tip link set dev $swp3 down\n\tmirror_install $swp1 ingress $tundev \"matchall $tcflags\"\n\tfail_test_span_gre_dir $tundev ingress\n\n\t# After setting the device up, wait for neighbor to get resolved so that\n\t# we can expect mirroring to work.\n\tip link set dev $swp3 up\n\tsetup_wait_dev $swp3\n\tping -c 1 -I $swp3 $remote_ip &>/dev/null\n\n\tquick_test_span_gre_dir $tundev ingress\n\tmirror_uninstall $swp1 ingress\n\n\tlog_test \"$what: egress down/up ($tcflags)\"\n}\n\ntest_span_gre_remote_ip()\n{\n\tlocal tundev=$1; shift\n\tlocal type=$1; shift\n\tlocal correct_ip=$1; shift\n\tlocal wrong_ip=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tip link set dev $tundev type $type remote $wrong_ip\n\tmirror_install $swp1 ingress $tundev \"matchall $tcflags\"\n\tfail_test_span_gre_dir $tundev ingress\n\n\tip link set dev $tundev type $type remote $correct_ip\n\tquick_test_span_gre_dir $tundev ingress\n\tmirror_uninstall $swp1 ingress\n\n\tlog_test \"$what: remote address change ($tcflags)\"\n}\n\ntest_span_gre_tun_del()\n{\n\tlocal tundev=$1; shift\n\tlocal type=$1; shift\n\tlocal flags=$1; shift\n\tlocal local_ip=$1; shift\n\tlocal remote_ip=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tmirror_install $swp1 ingress $tundev \"matchall $tcflags\"\n\tquick_test_span_gre_dir $tundev ingress\n\tip link del dev $tundev\n\tfail_test_span_gre_dir $tundev ingress\n\n\ttunnel_create $tundev $type $local_ip $remote_ip \\\n\t\t      ttl 100 tos inherit $flags\n\n\t# Recreating the tunnel doesn't reestablish mirroring, so reinstall it\n\t# and verify it works for the follow-up tests.\n\tmirror_uninstall $swp1 ingress\n\tmirror_install $swp1 ingress $tundev \"matchall $tcflags\"\n\tquick_test_span_gre_dir $tundev ingress\n\tmirror_uninstall $swp1 ingress\n\n\tlog_test \"$what: tunnel deleted ($tcflags)\"\n}\n\ntest_span_gre_route_del()\n{\n\tlocal tundev=$1; shift\n\tlocal edev=$1; shift\n\tlocal route=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tmirror_install $swp1 ingress $tundev \"matchall $tcflags\"\n\tquick_test_span_gre_dir $tundev ingress\n\n\tip route del $route dev $edev\n\tfail_test_span_gre_dir $tundev ingress\n\n\tip route add $route dev $edev\n\tquick_test_span_gre_dir $tundev ingress\n\n\tmirror_uninstall $swp1 ingress\n\n\tlog_test \"$what: underlay route removal ($tcflags)\"\n}\n\ntest_ttl()\n{\n\ttest_span_gre_ttl gt4 gretap ip \"mirror to gretap\"\n\ttest_span_gre_ttl gt6 ip6gretap ipv6 \"mirror to ip6gretap\"\n}\n\ntest_tun_up()\n{\n\ttest_span_gre_tun_up gt4 \"mirror to gretap\"\n\ttest_span_gre_tun_up gt6 \"mirror to ip6gretap\"\n}\n\ntest_egress_up()\n{\n\ttest_span_gre_egress_up gt4 192.0.2.130 \"mirror to gretap\"\n\ttest_span_gre_egress_up gt6 2001:db8:2::2 \"mirror to ip6gretap\"\n}\n\ntest_remote_ip()\n{\n\ttest_span_gre_remote_ip gt4 gretap 192.0.2.130 192.0.2.132 \"mirror to gretap\"\n\ttest_span_gre_remote_ip gt6 ip6gretap 2001:db8:2::2 2001:db8:2::4 \"mirror to ip6gretap\"\n}\n\ntest_tun_del()\n{\n\ttest_span_gre_tun_del gt4 gretap \"\" \\\n\t\t\t      192.0.2.129 192.0.2.130 \"mirror to gretap\"\n\ttest_span_gre_tun_del gt6 ip6gretap allow-localremote \\\n\t\t\t      2001:db8:2::1 2001:db8:2::2 \"mirror to ip6gretap\"\n}\n\ntest_route_del()\n{\n\ttest_span_gre_route_del gt4 $swp3 192.0.2.128/28 \"mirror to gretap\"\n\ttest_span_gre_route_del gt6 $swp3 2001:db8:2::/64 \"mirror to ip6gretap\"\n}\n\ntest_all()\n{\n\tslow_path_trap_install $swp1 ingress\n\tslow_path_trap_install $swp1 egress\n\n\ttests_run\n\n\tslow_path_trap_uninstall $swp1 egress\n\tslow_path_trap_uninstall $swp1 ingress\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntcflags=\"skip_hw\"\ntest_all\n\nif ! tc_offload_check; then\n\techo \"WARN: Could not test offloaded functionality\"\nelse\n\ttcflags=\"skip_sw\"\n\ttest_all\nfi\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}