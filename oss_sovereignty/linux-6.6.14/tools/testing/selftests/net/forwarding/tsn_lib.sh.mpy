{
  "module_name": "tsn_lib.sh",
  "hash_id": "61d16e8bf0fde9161c2823913b5f1f407cd44a1369d6521ce7808f90d88a1b9f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/tsn_lib.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n# Copyright 2021-2022 NXP\n\nREQUIRE_ISOCHRON=${REQUIRE_ISOCHRON:=yes}\nREQUIRE_LINUXPTP=${REQUIRE_LINUXPTP:=yes}\n\n# Tunables\nUTC_TAI_OFFSET=37\nISOCHRON_CPU=1\n\nif [[ \"$REQUIRE_ISOCHRON\" = \"yes\" ]]; then\n\t# https://github.com/vladimiroltean/tsn-scripts\n\t# WARNING: isochron versions pre-1.0 are unstable,\n\t# always use the latest version\n\trequire_command isochron\nfi\nif [[ \"$REQUIRE_LINUXPTP\" = \"yes\" ]]; then\n\trequire_command phc2sys\n\trequire_command ptp4l\nfi\n\nphc2sys_start()\n{\n\tlocal uds_address=$1\n\tlocal extra_args=\"\"\n\n\tif ! [ -z \"${uds_address}\" ]; then\n\t\textra_args=\"${extra_args} -z ${uds_address}\"\n\tfi\n\n\tphc2sys_log=\"$(mktemp)\"\n\n\tchrt -f 10 phc2sys -m \\\n\t\t-a -rr \\\n\t\t--step_threshold 0.00002 \\\n\t\t--first_step_threshold 0.00002 \\\n\t\t${extra_args} \\\n\t\t> \"${phc2sys_log}\" 2>&1 &\n\tphc2sys_pid=$!\n\n\techo \"phc2sys logs to ${phc2sys_log} and has pid ${phc2sys_pid}\"\n\n\tsleep 1\n}\n\nphc2sys_stop()\n{\n\t{ kill ${phc2sys_pid} && wait ${phc2sys_pid}; } 2> /dev/null\n\trm \"${phc2sys_log}\" 2> /dev/null\n}\n\n# Replace space separators from interface list with underscores\nif_names_to_label()\n{\n\tlocal if_name_list=\"$1\"\n\n\techo \"${if_name_list/ /_}\"\n}\n\nptp4l_start()\n{\n\tlocal if_names=\"$1\"\n\tlocal slave_only=$2\n\tlocal uds_address=$3\n\tlocal log=\"ptp4l_log_$(if_names_to_label ${if_names})\"\n\tlocal pid=\"ptp4l_pid_$(if_names_to_label ${if_names})\"\n\tlocal extra_args=\"\"\n\n\tfor if_name in ${if_names}; do\n\t\textra_args=\"${extra_args} -i ${if_name}\"\n\tdone\n\n\tif [ \"${slave_only}\" = true ]; then\n\t\textra_args=\"${extra_args} -s\"\n\tfi\n\n\t# declare dynamic variables ptp4l_log_${if_name} and ptp4l_pid_${if_name}\n\t# as global, so that they can be referenced later\n\tdeclare -g \"${log}=$(mktemp)\"\n\n\tchrt -f 10 ptp4l -m -2 -P \\\n\t\t--step_threshold 0.00002 \\\n\t\t--first_step_threshold 0.00002 \\\n\t\t--tx_timestamp_timeout 100 \\\n\t\t--uds_address=\"${uds_address}\" \\\n\t\t${extra_args} \\\n\t\t> \"${!log}\" 2>&1 &\n\tdeclare -g \"${pid}=$!\"\n\n\techo \"ptp4l for interfaces ${if_names} logs to ${!log} and has pid ${!pid}\"\n\n\tsleep 1\n}\n\nptp4l_stop()\n{\n\tlocal if_names=\"$1\"\n\tlocal log=\"ptp4l_log_$(if_names_to_label ${if_names})\"\n\tlocal pid=\"ptp4l_pid_$(if_names_to_label ${if_names})\"\n\n\t{ kill ${!pid} && wait ${!pid}; } 2> /dev/null\n\trm \"${!log}\" 2> /dev/null\n}\n\ncpufreq_max()\n{\n\tlocal cpu=$1\n\tlocal freq=\"cpu${cpu}_freq\"\n\tlocal governor=\"cpu${cpu}_governor\"\n\n\t# Kernel may be compiled with CONFIG_CPU_FREQ disabled\n\tif ! [ -d /sys/bus/cpu/devices/cpu${cpu}/cpufreq ]; then\n\t\treturn\n\tfi\n\n\t# declare dynamic variables cpu${cpu}_freq and cpu${cpu}_governor as\n\t# global, so they can be referenced later\n\tdeclare -g \"${freq}=$(cat /sys/bus/cpu/devices/cpu${cpu}/cpufreq/scaling_min_freq)\"\n\tdeclare -g \"${governor}=$(cat /sys/bus/cpu/devices/cpu${cpu}/cpufreq/scaling_governor)\"\n\n\tcat /sys/bus/cpu/devices/cpu${cpu}/cpufreq/scaling_max_freq > \\\n\t\t/sys/bus/cpu/devices/cpu${cpu}/cpufreq/scaling_min_freq\n\techo -n \"performance\" > \\\n\t\t/sys/bus/cpu/devices/cpu${cpu}/cpufreq/scaling_governor\n}\n\ncpufreq_restore()\n{\n\tlocal cpu=$1\n\tlocal freq=\"cpu${cpu}_freq\"\n\tlocal governor=\"cpu${cpu}_governor\"\n\n\tif ! [ -d /sys/bus/cpu/devices/cpu${cpu}/cpufreq ]; then\n\t\treturn\n\tfi\n\n\techo \"${!freq}\" > /sys/bus/cpu/devices/cpu${cpu}/cpufreq/scaling_min_freq\n\techo -n \"${!governor}\" > \\\n\t\t/sys/bus/cpu/devices/cpu${cpu}/cpufreq/scaling_governor\n}\n\nisochron_recv_start()\n{\n\tlocal if_name=$1\n\tlocal uds=$2\n\tlocal stats_port=$3\n\tlocal extra_args=$4\n\tlocal pid=\"isochron_pid_${stats_port}\"\n\n\tif ! [ -z \"${uds}\" ]; then\n\t\textra_args=\"${extra_args} --unix-domain-socket ${uds}\"\n\tfi\n\n\tisochron rcv \\\n\t\t--interface ${if_name} \\\n\t\t--sched-priority 98 \\\n\t\t--sched-fifo \\\n\t\t--utc-tai-offset ${UTC_TAI_OFFSET} \\\n\t\t--stats-port ${stats_port} \\\n\t\t--quiet \\\n\t\t${extra_args} & \\\n\tdeclare -g \"${pid}=$!\"\n\n\tsleep 1\n}\n\nisochron_recv_stop()\n{\n\tlocal stats_port=$1\n\tlocal pid=\"isochron_pid_${stats_port}\"\n\n\t{ kill ${!pid} && wait ${!pid}; } 2> /dev/null\n}\n\nisochron_do()\n{\n\tlocal sender_if_name=$1; shift\n\tlocal receiver_if_name=$1; shift\n\tlocal sender_uds=$1; shift\n\tlocal receiver_uds=$1; shift\n\tlocal base_time=$1; shift\n\tlocal cycle_time=$1; shift\n\tlocal shift_time=$1; shift\n\tlocal num_pkts=$1; shift\n\tlocal vid=$1; shift\n\tlocal priority=$1; shift\n\tlocal dst_ip=$1; shift\n\tlocal isochron_dat=$1; shift\n\tlocal extra_args=\"\"\n\tlocal receiver_extra_args=\"\"\n\tlocal vrf=\"$(master_name_get ${sender_if_name})\"\n\tlocal use_l2=\"true\"\n\n\tif ! [ -z \"${dst_ip}\" ]; then\n\t\tuse_l2=\"false\"\n\tfi\n\n\tif ! [ -z \"${vrf}\" ]; then\n\t\tdst_ip=\"${dst_ip}%${vrf}\"\n\tfi\n\n\tif ! [ -z \"${vid}\" ]; then\n\t\tvid=\"--vid=${vid}\"\n\tfi\n\n\tif [ -z \"${receiver_uds}\" ]; then\n\t\textra_args=\"${extra_args} --omit-remote-sync\"\n\tfi\n\n\tif ! [ -z \"${shift_time}\" ]; then\n\t\textra_args=\"${extra_args} --shift-time=${shift_time}\"\n\tfi\n\n\tif [ \"${use_l2}\" = \"true\" ]; then\n\t\textra_args=\"${extra_args} --l2 --etype=0xdead ${vid}\"\n\t\treceiver_extra_args=\"--l2 --etype=0xdead\"\n\telse\n\t\textra_args=\"${extra_args} --l4 --ip-destination=${dst_ip}\"\n\t\treceiver_extra_args=\"--l4\"\n\tfi\n\n\tcpufreq_max ${ISOCHRON_CPU}\n\n\tisochron_recv_start \"${h2}\" \"${receiver_uds}\" 5000 \"${receiver_extra_args}\"\n\n\tisochron send \\\n\t\t--interface ${sender_if_name} \\\n\t\t--unix-domain-socket ${sender_uds} \\\n\t\t--priority ${priority} \\\n\t\t--base-time ${base_time} \\\n\t\t--cycle-time ${cycle_time} \\\n\t\t--num-frames ${num_pkts} \\\n\t\t--frame-size 64 \\\n\t\t--txtime \\\n\t\t--utc-tai-offset ${UTC_TAI_OFFSET} \\\n\t\t--cpu-mask $((1 << ${ISOCHRON_CPU})) \\\n\t\t--sched-fifo \\\n\t\t--sched-priority 98 \\\n\t\t--client 127.0.0.1 \\\n\t\t--sync-threshold 5000 \\\n\t\t--output-file ${isochron_dat} \\\n\t\t${extra_args} \\\n\t\t--quiet\n\n\tisochron_recv_stop 5000\n\n\tcpufreq_restore ${ISOCHRON_CPU}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}