{
  "module_name": "no_forwarding.sh",
  "hash_id": "0928a09aad5530b33fcbf37d504b98ac7f0b1321f966540c5d76ac794292545c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/no_forwarding.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\nALL_TESTS=\"standalone two_bridges one_bridge_two_pvids\"\nNUM_NETIFS=4\n\nsource lib.sh\n\nh1=${NETIFS[p1]}\nh2=${NETIFS[p3]}\nswp1=${NETIFS[p2]}\nswp2=${NETIFS[p4]}\n\nH1_IPV4=\"192.0.2.1\"\nH2_IPV4=\"192.0.2.2\"\nH1_IPV6=\"2001:db8:1::1\"\nH2_IPV6=\"2001:db8:1::2\"\n\nIPV4_ALLNODES=\"224.0.0.1\"\nIPV6_ALLNODES=\"ff02::1\"\nMACV4_ALLNODES=\"01:00:5e:00:00:01\"\nMACV6_ALLNODES=\"33:33:00:00:00:01\"\nNON_IP_MC=\"01:02:03:04:05:06\"\nNON_IP_PKT=\"00:04 48:45:4c:4f\"\nBC=\"ff:ff:ff:ff:ff:ff\"\n\n# The full 4K VLAN space is too much to check, so strategically pick some\n# values which should provide reasonable coverage\nvids=(0 1 2 5 10 20 50 100 200 500 1000 1000 2000 4000 4094)\n\nsend_non_ip()\n{\n\tlocal if_name=$1\n\tlocal smac=$2\n\tlocal dmac=$3\n\n\t$MZ -q $if_name \"$dmac $smac $NON_IP_PKT\"\n}\n\nsend_uc_ipv4()\n{\n\tlocal if_name=$1\n\tlocal dmac=$2\n\n\tip neigh add $H2_IPV4 lladdr $dmac dev $if_name\n\tping_do $if_name $H2_IPV4\n\tip neigh del $H2_IPV4 dev $if_name\n}\n\nsend_mc_ipv4()\n{\n\tlocal if_name=$1\n\n\tping_do $if_name $IPV4_ALLNODES \"-I $if_name\"\n}\n\nsend_uc_ipv6()\n{\n\tlocal if_name=$1\n\tlocal dmac=$2\n\n\tip -6 neigh add $H2_IPV6 lladdr $dmac dev $if_name\n\tping6_do $if_name $H2_IPV6\n\tip -6 neigh del $H2_IPV6 dev $if_name\n}\n\nsend_mc_ipv6()\n{\n\tlocal if_name=$1\n\n\tping6_do $if_name $IPV6_ALLNODES%$if_name\n}\n\ncheck_rcv()\n{\n\tlocal if_name=$1\n\tlocal type=$2\n\tlocal pattern=$3\n\tlocal should_fail=1\n\n\tRET=0\n\n\ttcpdump_show $if_name | grep -q \"$pattern\"\n\n\tcheck_err_fail \"$should_fail\" \"$?\" \"reception\"\n\n\tlog_test \"$type\"\n}\n\nrun_test()\n{\n\tlocal test_name=\"$1\"\n\tlocal smac=$(mac_get $h1)\n\tlocal dmac=$(mac_get $h2)\n\tlocal h1_ipv6_lladdr=$(ipv6_lladdr_get $h1)\n\tlocal vid=\n\n\techo \"$test_name: Sending packets\"\n\n\ttcpdump_start $h2\n\n\tsend_non_ip $h1 $smac $dmac\n\tsend_non_ip $h1 $smac $NON_IP_MC\n\tsend_non_ip $h1 $smac $BC\n\tsend_uc_ipv4 $h1 $dmac\n\tsend_mc_ipv4 $h1\n\tsend_uc_ipv6 $h1 $dmac\n\tsend_mc_ipv6 $h1\n\n\tfor vid in \"${vids[@]}\"; do\n\t\tvlan_create $h1 $vid\n\t\tsimple_if_init $h1.$vid $H1_IPV4/24 $H1_IPV6/64\n\n\t\tsend_non_ip $h1.$vid $smac $dmac\n\t\tsend_non_ip $h1.$vid $smac $NON_IP_MC\n\t\tsend_non_ip $h1.$vid $smac $BC\n\t\tsend_uc_ipv4 $h1.$vid $dmac\n\t\tsend_mc_ipv4 $h1.$vid\n\t\tsend_uc_ipv6 $h1.$vid $dmac\n\t\tsend_mc_ipv6 $h1.$vid\n\n\t\tsimple_if_fini $h1.$vid $H1_IPV4/24 $H1_IPV6/64\n\t\tvlan_destroy $h1 $vid\n\tdone\n\n\tsleep 1\n\n\techo \"$test_name: Checking which packets were received\"\n\n\ttcpdump_stop $h2\n\n\tcheck_rcv $h2 \"$test_name: Unicast non-IP untagged\" \\\n\t\t\"$smac > $dmac, 802.3, length 4:\"\n\n\tcheck_rcv $h2 \"$test_name: Multicast non-IP untagged\" \\\n\t\t\"$smac > $NON_IP_MC, 802.3, length 4:\"\n\n\tcheck_rcv $h2 \"$test_name: Broadcast non-IP untagged\" \\\n\t\t\"$smac > $BC, 802.3, length 4:\"\n\n\tcheck_rcv $h2 \"$test_name: Unicast IPv4 untagged\" \\\n\t\t\"$smac > $dmac, ethertype IPv4 (0x0800)\"\n\n\tcheck_rcv $h2 \"$test_name: Multicast IPv4 untagged\" \\\n\t\t\"$smac > $MACV4_ALLNODES, ethertype IPv4 (0x0800).*: $H1_IPV4 > $IPV4_ALLNODES\"\n\n\tcheck_rcv $h2 \"$test_name: Unicast IPv6 untagged\" \\\n\t\t\"$smac > $dmac, ethertype IPv6 (0x86dd).*8: $H1_IPV6 > $H2_IPV6\"\n\n\tcheck_rcv $h2 \"$test_name: Multicast IPv6 untagged\" \\\n\t\t\"$smac > $MACV6_ALLNODES, ethertype IPv6 (0x86dd).*: $h1_ipv6_lladdr > $IPV6_ALLNODES\"\n\n\tfor vid in \"${vids[@]}\"; do\n\t\tcheck_rcv $h2 \"$test_name: Unicast non-IP VID $vid\" \\\n\t\t\t\"$smac > $dmac, ethertype 802.1Q (0x8100).*vlan $vid,.*length 4\"\n\n\t\tcheck_rcv $h2 \"$test_name: Multicast non-IP VID $vid\" \\\n\t\t\t\"$smac > $NON_IP_MC, ethertype 802.1Q (0x8100).*vlan $vid,.*length 4\"\n\n\t\tcheck_rcv $h2 \"$test_name: Broadcast non-IP VID $vid\" \\\n\t\t\t\"$smac > $BC, ethertype 802.1Q (0x8100).*vlan $vid,.*length 4\"\n\n\t\tcheck_rcv $h2 \"$test_name: Unicast IPv4 VID $vid\" \\\n\t\t\t\"$smac > $dmac, ethertype 802.1Q (0x8100).*vlan $vid,.*ethertype IPv4 (0x0800), $H1_IPV4 > $H2_IPV4\"\n\n\t\tcheck_rcv $h2 \"$test_name: Multicast IPv4 VID $vid\" \\\n\t\t\t\"$smac > $MACV4_ALLNODES, ethertype 802.1Q (0x8100).*vlan $vid,.*ethertype IPv4 (0x0800), $H1_IPV4 > $IPV4_ALLNODES\"\n\n\t\tcheck_rcv $h2 \"$test_name: Unicast IPv6 VID $vid\" \\\n\t\t\t\"$smac > $dmac, ethertype 802.1Q (0x8100).*vlan $vid,.*ethertype IPv6 (0x86dd), $H1_IPV6 > $H2_IPV6\"\n\n\t\tcheck_rcv $h2 \"$test_name: Multicast IPv6 VID $vid\" \\\n\t\t\t\"$smac > $MACV6_ALLNODES, ethertype 802.1Q (0x8100).*vlan $vid,.*ethertype IPv6 (0x86dd), $h1_ipv6_lladdr > $IPV6_ALLNODES\"\n\tdone\n\n\ttcpdump_cleanup $h2\n}\n\nstandalone()\n{\n\trun_test \"Standalone switch ports\"\n}\n\ntwo_bridges()\n{\n\tip link add br0 type bridge && ip link set br0 up\n\tip link add br1 type bridge && ip link set br1 up\n\tip link set $swp1 master br0\n\tip link set $swp2 master br1\n\n\trun_test \"Switch ports in different bridges\"\n\n\tip link del br1\n\tip link del br0\n}\n\none_bridge_two_pvids()\n{\n\tip link add br0 type bridge vlan_filtering 1 vlan_default_pvid 0\n\tip link set br0 up\n\tip link set $swp1 master br0\n\tip link set $swp2 master br0\n\n\tbridge vlan add dev $swp1 vid 1 pvid untagged\n\tbridge vlan add dev $swp1 vid 2 pvid untagged\n\n\trun_test \"Switch ports in VLAN-aware bridge with different PVIDs\"\n\n\tip link del br0\n}\n\nh1_create()\n{\n\tsimple_if_init $h1 $H1_IPV4/24 $H1_IPV6/64\n}\n\nh1_destroy()\n{\n\tsimple_if_fini $h1 $H1_IPV4/24 $H1_IPV6/64\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 $H2_IPV4/24 $H2_IPV6/64\n}\n\nh2_destroy()\n{\n\tsimple_if_fini $h2 $H2_IPV4/24 $H2_IPV6/64\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n}\n\nsetup_prepare()\n{\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\t# we call simple_if_init from the test itself, but setup_wait expects\n\t# that we call it from here, and waits until the interfaces are up\n\tip link set dev $swp1 up\n\tip link set dev $swp2 up\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}