{
  "module_name": "hw_stats_l3.sh",
  "hash_id": "d8ce4ea8114255141bc9c4702ae5ccff43c9ecf4bd56b2ce2d9b56454d2741d3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/hw_stats_l3.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# +--------------------+                     +----------------------+\n# | H1                 |                     |                   H2 |\n# |                    |                     |                      |\n# |          $h1.200 + |                     | + $h2.200            |\n# |     192.0.2.1/28 | |                     | | 192.0.2.18/28      |\n# | 2001:db8:1::1/64 | |                     | | 2001:db8:2::1/64   |\n# |                  | |                     | |                    |\n# |              $h1 + |                     | + $h2                |\n# |                  | |                     | |                    |\n# +------------------|-+                     +-|--------------------+\n#                    |                         |\n# +------------------|-------------------------|--------------------+\n# | SW               |                         |                    |\n# |                  |                         |                    |\n# |             $rp1 +                         + $rp2               |\n# |                  |                         |                    |\n# |         $rp1.200 +                         + $rp2.200           |\n# |     192.0.2.2/28                             192.0.2.17/28      |\n# | 2001:db8:1::2/64                             2001:db8:2::2/64   |\n# |                                                                 |\n# +-----------------------------------------------------------------+\n\nALL_TESTS=\"\n\tping_ipv4\n\tping_ipv6\n\ttest_stats_rx_ipv4\n\ttest_stats_tx_ipv4\n\ttest_stats_rx_ipv6\n\ttest_stats_tx_ipv6\n\trespin_enablement\n\ttest_stats_rx_ipv4\n\ttest_stats_tx_ipv4\n\ttest_stats_rx_ipv6\n\ttest_stats_tx_ipv6\n\treapply_config\n\tping_ipv4\n\tping_ipv6\n\ttest_stats_rx_ipv4\n\ttest_stats_tx_ipv4\n\ttest_stats_rx_ipv6\n\ttest_stats_tx_ipv6\n\ttest_stats_report_rx\n\ttest_stats_report_tx\n\ttest_destroy_enabled\n\ttest_double_enable\n\"\nNUM_NETIFS=4\nsource lib.sh\n\nh1_create()\n{\n\tsimple_if_init $h1\n\tvlan_create $h1 200 v$h1 192.0.2.1/28 2001:db8:1::1/64\n\tip route add 192.0.2.16/28 vrf v$h1 nexthop via 192.0.2.2\n\tip -6 route add 2001:db8:2::/64 vrf v$h1 nexthop via 2001:db8:1::2\n}\n\nh1_destroy()\n{\n\tip -6 route del 2001:db8:2::/64 vrf v$h1 nexthop via 2001:db8:1::2\n\tip route del 192.0.2.16/28 vrf v$h1 nexthop via 192.0.2.2\n\tvlan_destroy $h1 200\n\tsimple_if_fini $h1\n}\n\nh2_create()\n{\n\tsimple_if_init $h2\n\tvlan_create $h2 200 v$h2 192.0.2.18/28 2001:db8:2::1/64\n\tip route add 192.0.2.0/28 vrf v$h2 nexthop via 192.0.2.17\n\tip -6 route add 2001:db8:1::/64 vrf v$h2 nexthop via 2001:db8:2::2\n}\n\nh2_destroy()\n{\n\tip -6 route del 2001:db8:1::/64 vrf v$h2 nexthop via 2001:db8:2::2\n\tip route del 192.0.2.0/28 vrf v$h2 nexthop via 192.0.2.17\n\tvlan_destroy $h2 200\n\tsimple_if_fini $h2\n}\n\nrouter_rp1_200_create()\n{\n\tip link add name $rp1.200 link $rp1 type vlan id 200\n\tip link set dev $rp1.200 addrgenmode eui64\n\tip link set dev $rp1.200 up\n\tip address add dev $rp1.200 192.0.2.2/28\n\tip address add dev $rp1.200 2001:db8:1::2/64\n\tip stats set dev $rp1.200 l3_stats on\n}\n\nrouter_rp1_200_destroy()\n{\n\tip stats set dev $rp1.200 l3_stats off\n\tip address del dev $rp1.200 2001:db8:1::2/64\n\tip address del dev $rp1.200 192.0.2.2/28\n\tip link del dev $rp1.200\n}\n\nrouter_create()\n{\n\tip link set dev $rp1 up\n\trouter_rp1_200_create\n\n\tip link set dev $rp2 up\n\tvlan_create $rp2 200 \"\" 192.0.2.17/28 2001:db8:2::2/64\n}\n\nrouter_destroy()\n{\n\tvlan_destroy $rp2 200\n\tip link set dev $rp2 down\n\n\trouter_rp1_200_destroy\n\tip link set dev $rp1 down\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\trp1=${NETIFS[p2]}\n\n\trp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\trp1mac=$(mac_get $rp1)\n\trp2mac=$(mac_get $rp2)\n\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\n\trouter_create\n\n\tforwarding_enable\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tforwarding_restore\n\n\trouter_destroy\n\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n}\n\nping_ipv4()\n{\n\tping_test $h1.200 192.0.2.18 \" IPv4\"\n}\n\nping_ipv6()\n{\n\tping_test $h1.200 2001:db8:2::1 \" IPv6\"\n}\n\nsend_packets_rx_ipv4()\n{\n\t# Send 21 packets instead of 20, because the first one might trap and go\n\t# through the SW datapath, which might not bump the HW counter.\n\t$MZ $h1.200 -c 21 -d 20msec -p 100 \\\n\t    -a own -b $rp1mac -A 192.0.2.1 -B 192.0.2.18 \\\n\t    -q -t udp sp=54321,dp=12345\n}\n\nsend_packets_rx_ipv6()\n{\n\t$MZ $h1.200 -6 -c 21 -d 20msec -p 100 \\\n\t    -a own -b $rp1mac -A 2001:db8:1::1 -B 2001:db8:2::1 \\\n\t    -q -t udp sp=54321,dp=12345\n}\n\nsend_packets_tx_ipv4()\n{\n\t$MZ $h2.200 -c 21 -d 20msec -p 100 \\\n\t    -a own -b $rp2mac -A 192.0.2.18 -B 192.0.2.1 \\\n\t    -q -t udp sp=54321,dp=12345\n}\n\nsend_packets_tx_ipv6()\n{\n\t$MZ $h2.200 -6 -c 21 -d 20msec -p 100 \\\n\t    -a own -b $rp2mac -A 2001:db8:2::1 -B 2001:db8:1::1 \\\n\t    -q -t udp sp=54321,dp=12345\n}\n\n___test_stats()\n{\n\tlocal dir=$1; shift\n\tlocal prot=$1; shift\n\n\tlocal a\n\tlocal b\n\n\ta=$(hw_stats_get l3_stats $rp1.200 ${dir} packets)\n\tsend_packets_${dir}_${prot}\n\t\"$@\"\n\tb=$(busywait \"$TC_HIT_TIMEOUT\" until_counter_is \">= $a + 20\" \\\n\t\t       hw_stats_get l3_stats $rp1.200 ${dir} packets)\n\tcheck_err $? \"Traffic not reflected in the counter: $a -> $b\"\n}\n\n__test_stats()\n{\n\tlocal dir=$1; shift\n\tlocal prot=$1; shift\n\n\tRET=0\n\t___test_stats \"$dir\" \"$prot\"\n\tlog_test \"Test $dir packets: $prot\"\n}\n\ntest_stats_rx_ipv4()\n{\n\t__test_stats rx ipv4\n}\n\ntest_stats_tx_ipv4()\n{\n\t__test_stats tx ipv4\n}\n\ntest_stats_rx_ipv6()\n{\n\t__test_stats rx ipv6\n}\n\ntest_stats_tx_ipv6()\n{\n\t__test_stats tx ipv6\n}\n\n# Make sure everything works well even after stats have been disabled and\n# reenabled on the same device without touching the L3 configuration.\nrespin_enablement()\n{\n\tlog_info \"Turning stats off and on again\"\n\tip stats set dev $rp1.200 l3_stats off\n\tip stats set dev $rp1.200 l3_stats on\n}\n\n# For the initial run, l3_stats is enabled on a completely set up netdevice. Now\n# do it the other way around: enabling the L3 stats on an L2 netdevice, and only\n# then apply the L3 configuration.\nreapply_config()\n{\n\tlog_info \"Reapplying configuration\"\n\n\trouter_rp1_200_destroy\n\n\tip link add name $rp1.200 link $rp1 type vlan id 200\n\tip link set dev $rp1.200 addrgenmode none\n\tip stats set dev $rp1.200 l3_stats on\n\tip link set dev $rp1.200 addrgenmode eui64\n\tip link set dev $rp1.200 up\n\tip address add dev $rp1.200 192.0.2.2/28\n\tip address add dev $rp1.200 2001:db8:1::2/64\n}\n\n__test_stats_report()\n{\n\tlocal dir=$1; shift\n\tlocal prot=$1; shift\n\n\tlocal a\n\tlocal b\n\n\tRET=0\n\n\ta=$(hw_stats_get l3_stats $rp1.200 ${dir} packets)\n\tsend_packets_${dir}_${prot}\n\tip address flush dev $rp1.200\n\tb=$(busywait \"$TC_HIT_TIMEOUT\" until_counter_is \">= $a + 20\" \\\n\t\t       hw_stats_get l3_stats $rp1.200 ${dir} packets)\n\tcheck_err $? \"Traffic not reflected in the counter: $a -> $b\"\n\tlog_test \"Test ${dir} packets: stats pushed on loss of L3\"\n\n\tip stats set dev $rp1.200 l3_stats off\n\tip link del dev $rp1.200\n\trouter_rp1_200_create\n}\n\ntest_stats_report_rx()\n{\n\t__test_stats_report rx ipv4\n}\n\ntest_stats_report_tx()\n{\n\t__test_stats_report tx ipv4\n}\n\ntest_destroy_enabled()\n{\n\tRET=0\n\n\tip link del dev $rp1.200\n\trouter_rp1_200_create\n\n\tlog_test \"Destroy l3_stats-enabled netdev\"\n}\n\ntest_double_enable()\n{\n\tRET=0\n\t___test_stats rx ipv4 \\\n\t\tip stats set dev $rp1.200 l3_stats on\n\tlog_test \"Test stat retention across a spurious enablement\"\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\nused=$(ip -j stats show dev $rp1.200 group offload subgroup hw_stats_info |\n\t   jq '.[].info.l3_stats.used')\nkind=$(ip -j -d link show dev $rp1 |\n\t   jq -r '.[].linkinfo.info_kind')\nif [[ $used != true ]]; then\n\tif [[ $kind == veth ]]; then\n\t\tlog_test_skip \"l3_stats not offloaded on veth interface\"\n\t\tEXIT_STATUS=$ksft_skip\n\telse\n\t\tRET=1 log_test \"l3_stats not offloaded\"\n\tfi\nelse\n\ttests_run\nfi\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}