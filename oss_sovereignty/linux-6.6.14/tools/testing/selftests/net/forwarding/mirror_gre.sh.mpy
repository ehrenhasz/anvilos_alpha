{
  "module_name": "mirror_gre.sh",
  "hash_id": "e345c2c04d8b7d625c26cab4a2f968040bc892fcd10ccbea572b0c62cb60c435",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/mirror_gre.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# This test uses standard topology for testing gretap. See\n# mirror_gre_topo_lib.sh for more details.\n#\n# Test for \"tc action mirred egress mirror\" when the device to mirror to is a\n# gretap or ip6gretap netdevice. Expect that the packets come out encapsulated,\n# and another gretap / ip6gretap netdevice is then capable of decapsulating the\n# traffic. Test that the payload is what is expected (ICMP ping request or\n# reply, depending on test).\n\nALL_TESTS=\"\n\ttest_gretap\n\ttest_ip6gretap\n\ttest_gretap_mac\n\ttest_ip6gretap_mac\n\ttest_two_spans\n\"\n\nNUM_NETIFS=6\nsource lib.sh\nsource mirror_lib.sh\nsource mirror_gre_lib.sh\nsource mirror_gre_topo_lib.sh\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\tswp3=${NETIFS[p5]}\n\th3=${NETIFS[p6]}\n\n\tvrf_prepare\n\tmirror_gre_topo_create\n\n\tip address add dev $swp3 192.0.2.129/28\n\tip address add dev $h3 192.0.2.130/28\n\n\tip address add dev $swp3 2001:db8:2::1/64\n\tip address add dev $h3 2001:db8:2::2/64\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tip address del dev $h3 2001:db8:2::2/64\n\tip address del dev $swp3 2001:db8:2::1/64\n\n\tip address del dev $h3 192.0.2.130/28\n\tip address del dev $swp3 192.0.2.129/28\n\n\tmirror_gre_topo_destroy\n\tvrf_cleanup\n}\n\ntest_span_gre_mac()\n{\n\tlocal tundev=$1; shift\n\tlocal direction=$1; shift\n\tlocal what=$1; shift\n\n\tcase \"$direction\" in\n\tingress) local src_mac=$(mac_get $h1); local dst_mac=$(mac_get $h2)\n\t\t;;\n\tegress) local src_mac=$(mac_get $h2); local dst_mac=$(mac_get $h1)\n\t\t;;\n\tesac\n\n\tRET=0\n\n\tmirror_install $swp1 $direction $tundev \"matchall $tcflags\"\n\ticmp_capture_install h3-${tundev} \"src_mac $src_mac dst_mac $dst_mac\"\n\n\tmirror_test v$h1 192.0.2.1 192.0.2.2 h3-${tundev} 100 10\n\n\ticmp_capture_uninstall h3-${tundev}\n\tmirror_uninstall $swp1 $direction\n\n\tlog_test \"$direction $what: envelope MAC ($tcflags)\"\n}\n\ntest_two_spans()\n{\n\tRET=0\n\n\tmirror_install $swp1 ingress gt4 \"matchall $tcflags\"\n\tmirror_install $swp1 egress gt6 \"matchall $tcflags\"\n\tquick_test_span_gre_dir gt4 ingress\n\tquick_test_span_gre_dir gt6 egress\n\n\tmirror_uninstall $swp1 ingress\n\tfail_test_span_gre_dir gt4 ingress\n\tquick_test_span_gre_dir gt6 egress\n\n\tmirror_install $swp1 ingress gt4 \"matchall $tcflags\"\n\tmirror_uninstall $swp1 egress\n\tquick_test_span_gre_dir gt4 ingress\n\tfail_test_span_gre_dir gt6 egress\n\n\tmirror_uninstall $swp1 ingress\n\tlog_test \"two simultaneously configured mirrors ($tcflags)\"\n}\n\ntest_gretap()\n{\n\tfull_test_span_gre_dir gt4 ingress 8 0 \"mirror to gretap\"\n\tfull_test_span_gre_dir gt4 egress 0 8 \"mirror to gretap\"\n}\n\ntest_ip6gretap()\n{\n\tfull_test_span_gre_dir gt6 ingress 8 0 \"mirror to ip6gretap\"\n\tfull_test_span_gre_dir gt6 egress 0 8 \"mirror to ip6gretap\"\n}\n\ntest_gretap_mac()\n{\n\ttest_span_gre_mac gt4 ingress \"mirror to gretap\"\n\ttest_span_gre_mac gt4 egress \"mirror to gretap\"\n}\n\ntest_ip6gretap_mac()\n{\n\ttest_span_gre_mac gt6 ingress \"mirror to ip6gretap\"\n\ttest_span_gre_mac gt6 egress \"mirror to ip6gretap\"\n}\n\ntest_all()\n{\n\tslow_path_trap_install $swp1 ingress\n\tslow_path_trap_install $swp1 egress\n\n\ttests_run\n\n\tslow_path_trap_uninstall $swp1 egress\n\tslow_path_trap_uninstall $swp1 ingress\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntcflags=\"skip_hw\"\ntest_all\n\nif ! tc_offload_check; then\n\techo \"WARN: Could not test offloaded functionality\"\nelse\n\ttcflags=\"skip_sw\"\n\ttest_all\nfi\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}