{
  "module_name": "vxlan_bridge_1d_ipv6.sh",
  "hash_id": "e2a9ae27e2063d872ad9651951564d911a7aafa551332326e84c24d4e26bc74a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/vxlan_bridge_1d_ipv6.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# +-----------------------+                          +------------------------+\n# | H1 (vrf)              |                          | H2 (vrf)               |\n# |    + $h1              |                          |    + $h2               |\n# |    | 192.0.2.1/28     |                          |    | 192.0.2.2/28      |\n# |    | 2001:db8:1::1/64 |                          |    | 2001:db8:1::2/64  |\n# +----|------------------+                          +----|-------------------+\n#      |                                                  |\n# +----|--------------------------------------------------|-------------------+\n# | SW |                                                  |                   |\n# | +--|--------------------------------------------------|-----------------+ |\n# | |  + $swp1                   BR1 (802.1d)             + $swp2           | |\n# | |                                                                       | |\n# | |  + vx1 (vxlan)                                                        | |\n# | |    local 2001:db8:3::1                                                | |\n# | |    remote 2001:db8:4::1 2001:db8:5::1                                 | |\n# | |    id 1000 dstport $VXPORT                                            | |\n# | +-----------------------------------------------------------------------+ |\n# |                                                                           |\n# |  2001:db8:4::0/64 via 2001:db8:3::2                                       |\n# |  2001:db8:5::0/64 via 2001:db8:3::2                                       |\n# |                                                                           |\n# |    + $rp1                                                                 |\n# |    | 2001:db8:3::1/64                                                     |\n# +----|----------------------------------------------------------------------+\n#      |\n# +----|----------------------------------------------------------+\n# |    |                                             VRP2 (vrf)   |\n# |    + $rp2                                                     |\n# |      2001:db8:3::2/64                                         |\n# |                                                               |  (maybe) HW\n# =============================================================================\n# |                                                               |  (likely) SW\n# |    + v1 (veth)                             + v3 (veth)        |\n# |    | 2001:db8:4::2/64                      | 2001:db8:5::2/64 |\n# +----|---------------------------------------|------------------+\n#      |                                       |\n# +----|--------------------------------+ +----|-------------------------------+\n# |    + v2 (veth)        NS1 (netns)   | |    + v4 (veth)        NS2 (netns)  |\n# |      2001:db8:4::1/64               | |      2001:db8:5::1/64              |\n# |                                     | |                                    |\n# | 2001:db8:3::0/64 via 2001:db8:4::2  | | 2001:db8:3::0/64 via 2001:db8:5::2 |\n# | 2001:db8:5::1/128 via 2001:db8:4::2 | | 2001:db8:4::1/128 via              |\n# |                                     | |         2001:db8:5::2              |\n# |                                     | |                                    |\n# | +-------------------------------+   | | +-------------------------------+  |\n# | |                  BR2 (802.1d) |   | | |                  BR2 (802.1d) |  |\n# | |  + vx2 (vxlan)                |   | | |  + vx2 (vxlan)                |  |\n# | |    local 2001:db8:4::1        |   | | |    local 2001:db8:5::1        |  |\n# | |    remote 2001:db8:3::1       |   | | |    remote 2001:db8:3::1       |  |\n# | |    remote 2001:db8:5::1       |   | | |    remote 2001:db8:4::1       |  |\n# | |    id 1000 dstport $VXPORT    |   | | |    id 1000 dstport $VXPORT    |  |\n# | |                               |   | | |                               |  |\n# | |  + w1 (veth)                  |   | | |  + w1 (veth)                  |  |\n# | +--|----------------------------+   | | +--|----------------------------+  |\n# |    |                                | |    |                               |\n# | +--|----------------------------+   | | +--|----------------------------+  |\n# | |  + w2 (veth)        VW2 (vrf) |   | | |  + w2 (veth)        VW2 (vrf) |  |\n# | |    192.0.2.3/28               |   | | |    192.0.2.4/28               |  |\n# | |    2001:db8:1::3/64           |   | | |    2001:db8:1::4/64           |  |\n# | +-------------------------------+   | | +-------------------------------+  |\n# +-------------------------------------+ +------------------------------------+\n\n: ${VXPORT:=4789}\nexport VXPORT\n\n: ${ALL_TESTS:=\"\n\tping_ipv4\n\tping_ipv6\n\ttest_flood\n\ttest_unicast\n\ttest_ttl\n\ttest_tos\n\ttest_ecn_encap\n\ttest_ecn_decap\n\treapply_config\n\tping_ipv4\n\tping_ipv6\n\ttest_flood\n\ttest_unicast\n\"}\n\nNUM_NETIFS=6\nsource lib.sh\nsource tc_common.sh\n\nh1_create()\n{\n\tsimple_if_init $h1 192.0.2.1/28 2001:db8:1::1/64\n\ttc qdisc add dev $h1 clsact\n}\n\nh1_destroy()\n{\n\ttc qdisc del dev $h1 clsact\n\tsimple_if_fini $h1 192.0.2.1/28 2001:db8:1::1/64\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 192.0.2.2/28 2001:db8:1::2/64\n\ttc qdisc add dev $h2 clsact\n}\n\nh2_destroy()\n{\n\ttc qdisc del dev $h2 clsact\n\tsimple_if_fini $h2 192.0.2.2/28 2001:db8:1::2/64\n}\n\nrp1_set_addr()\n{\n\tip address add dev $rp1 2001:db8:3::1/64\n\n\tip route add 2001:db8:4::0/64 nexthop via 2001:db8:3::2\n\tip route add 2001:db8:5::0/64 nexthop via 2001:db8:3::2\n}\n\nrp1_unset_addr()\n{\n\tip route del 2001:db8:5::0/64 nexthop via 2001:db8:3::2\n\tip route del 2001:db8:4::0/64 nexthop via 2001:db8:3::2\n\n\tip address del dev $rp1 2001:db8:3::1/64\n}\n\nswitch_create()\n{\n\tip link add name br1 type bridge vlan_filtering 0 mcast_snooping 0\n\t# Make sure the bridge uses the MAC address of the local port and not\n\t# that of the VxLAN's device.\n\tip link set dev br1 address $(mac_get $swp1)\n\tip link set dev br1 up\n\n\tip link set dev $rp1 up\n\trp1_set_addr\n\ttc qdisc add dev $rp1 clsact\n\n\tip link add name vx1 type vxlan id 1000\tlocal 2001:db8:3::1 \\\n\t\tdstport \"$VXPORT\" nolearning udp6zerocsumrx udp6zerocsumtx \\\n\t\ttos inherit ttl 100\n\tip link set dev vx1 up\n\n\tip link set dev vx1 master br1\n\tip link set dev $swp1 master br1\n\tip link set dev $swp1 up\n\ttc qdisc add dev $swp1 clsact\n\n\tip link set dev $swp2 master br1\n\tip link set dev $swp2 up\n\n\tbridge fdb append dev vx1 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\tbridge fdb append dev vx1 00:00:00:00:00:00 dst 2001:db8:5::1 self\n}\n\nswitch_destroy()\n{\n\tbridge fdb del dev vx1 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\tbridge fdb del dev vx1 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\n\tip link set dev $swp2 down\n\tip link set dev $swp2 nomaster\n\n\ttc qdisc del dev $swp1 clsact\n\tip link set dev $swp1 down\n\tip link set dev $swp1 nomaster\n\n\tip link set dev vx1 nomaster\n\tip link set dev vx1 down\n\tip link del dev vx1\n\n\ttc qdisc del dev $rp1 clsact\n\trp1_unset_addr\n\tip link set dev $rp1 down\n\n\tip link set dev br1 down\n\tip link del dev br1\n}\n\nvrp2_create()\n{\n\tsimple_if_init $rp2 2001:db8:3::2/64\n\t__simple_if_init v1 v$rp2 2001:db8:4::2/64\n\t__simple_if_init v3 v$rp2 2001:db8:5::2/64\n\ttc qdisc add dev v1 clsact\n}\n\nvrp2_destroy()\n{\n\ttc qdisc del dev v1 clsact\n\t__simple_if_fini v3 2001:db8:5::2/64\n\t__simple_if_fini v1 2001:db8:4::2/64\n\tsimple_if_fini $rp2 2001:db8:3::2/64\n}\n\nns_init_common()\n{\n\tlocal in_if=$1; shift\n\tlocal in_addr=$1; shift\n\tlocal other_in_addr=$1; shift\n\tlocal nh_addr=$1; shift\n\tlocal host_addr_ipv4=$1; shift\n\tlocal host_addr_ipv6=$1; shift\n\n\tip link set dev $in_if up\n\tip address add dev $in_if $in_addr/64\n\ttc qdisc add dev $in_if clsact\n\n\tip link add name br2 type bridge vlan_filtering 0\n\tip link set dev br2 up\n\n\tip link add name w1 type veth peer name w2\n\n\tip link set dev w1 master br2\n\tip link set dev w1 up\n\n\tip link add name vx2 type vxlan id 1000 local $in_addr \\\n\t\tdstport \"$VXPORT\" udp6zerocsumrx\n\tip link set dev vx2 up\n\tbridge fdb append dev vx2 00:00:00:00:00:00 dst 2001:db8:3::1 self\n\tbridge fdb append dev vx2 00:00:00:00:00:00 dst $other_in_addr self\n\n\tip link set dev vx2 master br2\n\ttc qdisc add dev vx2 clsact\n\n\tsimple_if_init w2 $host_addr_ipv4/28 $host_addr_ipv6/64\n\n\tip route add 2001:db8:3::0/64 nexthop via $nh_addr\n\tip route add $other_in_addr/128 nexthop via $nh_addr\n}\nexport -f ns_init_common\n\nns1_create()\n{\n\tip netns add ns1\n\tip link set dev v2 netns ns1\n\tin_ns ns1 \\\n\t      ns_init_common v2 2001:db8:4::1 2001:db8:5::1 2001:db8:4::2 \\\n\t      192.0.2.3 2001:db8:1::3\n}\n\nns1_destroy()\n{\n\tip netns exec ns1 ip link set dev v2 netns 1\n\tip netns del ns1\n}\n\nns2_create()\n{\n\tip netns add ns2\n\tip link set dev v4 netns ns2\n\tin_ns ns2 \\\n\t      ns_init_common v4 2001:db8:5::1 2001:db8:4::1 2001:db8:5::2 \\\n\t      192.0.2.4 2001:db8:1::4\n}\n\nns2_destroy()\n{\n\tip netns exec ns2 ip link set dev v4 netns 1\n\tip netns del ns2\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\trp1=${NETIFS[p5]}\n\trp2=${NETIFS[p6]}\n\n\tvrf_prepare\n\tforwarding_enable\n\n\th1_create\n\th2_create\n\tswitch_create\n\n\tip link add name v1 type veth peer name v2\n\tip link add name v3 type veth peer name v4\n\tvrp2_create\n\tns1_create\n\tns2_create\n\n\tr1_mac=$(in_ns ns1 mac_get w2)\n\tr2_mac=$(in_ns ns2 mac_get w2)\n\th2_mac=$(mac_get $h2)\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tns2_destroy\n\tns1_destroy\n\tvrp2_destroy\n\tip link del dev v3\n\tip link del dev v1\n\n\tswitch_destroy\n\th2_destroy\n\th1_destroy\n\n\tforwarding_restore\n\tvrf_cleanup\n}\n\n# For the first round of tests, vx1 is the first device to get\n# attached to the bridge, and at that point the local IP is already\n# configured. Try the other scenario of attaching the devices to a an\n# already-offloaded bridge, and only then assign the local IP.\nreapply_config()\n{\n\tlog_info \"Reapplying configuration\"\n\n\tbridge fdb del dev vx1 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\tbridge fdb del dev vx1 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\tip link set dev vx1 nomaster\n\trp1_unset_addr\n\tsleep 5\n\n\tip link set dev vx1 master br1\n\tbridge fdb append dev vx1 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\tbridge fdb append dev vx1 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\tsleep 1\n\trp1_set_addr\n\tsleep 5\n}\n\n__ping_ipv4()\n{\n\tlocal vxlan_local_ip=$1; shift\n\tlocal vxlan_remote_ip=$1; shift\n\tlocal src_ip=$1; shift\n\tlocal dst_ip=$1; shift\n\tlocal dev=$1; shift\n\tlocal info=$1; shift\n\n\tRET=0\n\n\ttc filter add dev $rp1 egress protocol ipv6 pref 1 handle 101 \\\n\t\tflower ip_proto udp src_ip $vxlan_local_ip \\\n\t\tdst_ip $vxlan_remote_ip dst_port $VXPORT $TC_FLAG action pass\n\t# Match ICMP-reply packets after decapsulation, so source IP is\n\t# destination IP of the ping and destination IP is source IP of the\n\t# ping.\n\ttc filter add dev $swp1 egress protocol ip pref 1 handle 101 \\\n\t\tflower src_ip $dst_ip dst_ip $src_ip \\\n\t\t$TC_FLAG action pass\n\n\t# Send 100 packets and verify that at least 100 packets hit the rule,\n\t# to overcome ARP noise.\n\tPING_COUNT=100 PING_TIMEOUT=11 ping_do $dev $dst_ip\n\tcheck_err $? \"Ping failed\"\n\n\ttc_check_at_least_x_packets \"dev $rp1 egress\" 101 10 100\n\tcheck_err $? \"Encapsulated packets did not go through router\"\n\n\ttc_check_at_least_x_packets \"dev $swp1 egress\" 101 10 100\n\tcheck_err $? \"Decapsulated packets did not go through switch\"\n\n\tlog_test \"ping: $info\"\n\n\ttc filter del dev $swp1 egress\n\ttc filter del dev $rp1 egress\n}\n\nping_ipv4()\n{\n\tRET=0\n\n\tlocal local_sw_ip=2001:db8:3::1\n\tlocal remote_ns1_ip=2001:db8:4::1\n\tlocal remote_ns2_ip=2001:db8:5::1\n\tlocal h1_ip=192.0.2.1\n\tlocal w2_ns1_ip=192.0.2.3\n\tlocal w2_ns2_ip=192.0.2.4\n\n\tping_test $h1 192.0.2.2 \": local->local\"\n\n\t__ping_ipv4 $local_sw_ip $remote_ns1_ip $h1_ip $w2_ns1_ip $h1 \\\n\t\t\"local->remote 1\"\n\t__ping_ipv4 $local_sw_ip $remote_ns2_ip $h1_ip $w2_ns2_ip $h1 \\\n\t\t\"local->remote 2\"\n}\n\n__ping_ipv6()\n{\n\tlocal vxlan_local_ip=$1; shift\n\tlocal vxlan_remote_ip=$1; shift\n\tlocal src_ip=$1; shift\n\tlocal dst_ip=$1; shift\n\tlocal dev=$1; shift\n\tlocal info=$1; shift\n\n\tRET=0\n\n\ttc filter add dev $rp1 egress protocol ipv6 pref 1 handle 101 \\\n\t\tflower ip_proto udp src_ip $vxlan_local_ip \\\n\t\tdst_ip $vxlan_remote_ip dst_port $VXPORT $TC_FLAG action pass\n\t# Match ICMP-reply packets after decapsulation, so source IP is\n\t# destination IP of the ping and destination IP is source IP of the\n\t# ping.\n\ttc filter add dev $swp1 egress protocol ipv6 pref 1 handle 101 \\\n\t\tflower src_ip $dst_ip dst_ip $src_ip $TC_FLAG action pass\n\n\t# Send 100 packets and verify that at least 100 packets hit the rule,\n\t# to overcome neighbor discovery noise.\n\tPING_COUNT=100 PING_TIMEOUT=11 ping6_do $dev $dst_ip\n\tcheck_err $? \"Ping failed\"\n\n\ttc_check_at_least_x_packets \"dev $rp1 egress\" 101 100\n\tcheck_err $? \"Encapsulated packets did not go through router\"\n\n\ttc_check_at_least_x_packets \"dev $swp1 egress\" 101 100\n\tcheck_err $? \"Decapsulated packets did not go through switch\"\n\n\tlog_test \"ping6: $info\"\n\n\ttc filter del dev $swp1 egress\n\ttc filter del dev $rp1 egress\n}\n\nping_ipv6()\n{\n\tRET=0\n\n\tlocal local_sw_ip=2001:db8:3::1\n\tlocal remote_ns1_ip=2001:db8:4::1\n\tlocal remote_ns2_ip=2001:db8:5::1\n\tlocal h1_ip=2001:db8:1::1\n\tlocal w2_ns1_ip=2001:db8:1::3\n\tlocal w2_ns2_ip=2001:db8:1::4\n\n\tping6_test $h1 2001:db8:1::2 \": local->local\"\n\n\t__ping_ipv6 $local_sw_ip $remote_ns1_ip $h1_ip $w2_ns1_ip $h1 \\\n\t\t\"local->remote 1\"\n\t__ping_ipv6 $local_sw_ip $remote_ns2_ip $h1_ip $w2_ns2_ip $h1 \\\n\t\t\"local->remote 2\"\n}\n\nmaybe_in_ns()\n{\n\techo ${1:+in_ns} $1\n}\n\n__flood_counter_add_del()\n{\n\tlocal add_del=$1; shift\n\tlocal dst_ip=$1; shift\n\tlocal dev=$1; shift\n\tlocal ns=$1; shift\n\n\t# Putting the ICMP capture both to HW and to SW will end up\n\t# double-counting the packets that are trapped to slow path, such as for\n\t# the unicast test. Adding either skip_hw or skip_sw fixes this problem,\n\t# but with skip_hw, the flooded packets are not counted at all, because\n\t# those are dropped due to MAC address mismatch; and skip_sw is a no-go\n\t# for veth-based topologies.\n\t#\n\t# So try to install with skip_sw and fall back to skip_sw if that fails.\n\n\t$(maybe_in_ns $ns) tc filter $add_del dev \"$dev\" ingress \\\n\t   proto ipv6 pref 100 flower dst_ip $dst_ip ip_proto \\\n\t   icmpv6 skip_sw action pass 2>/dev/null || \\\n\t$(maybe_in_ns $ns) tc filter $add_del dev \"$dev\" ingress \\\n\t   proto ipv6 pref 100 flower dst_ip $dst_ip ip_proto \\\n\t   icmpv6 skip_hw action pass\n}\n\nflood_counter_install()\n{\n\t__flood_counter_add_del add \"$@\"\n}\n\nflood_counter_uninstall()\n{\n\t__flood_counter_add_del del \"$@\"\n}\n\nflood_fetch_stat()\n{\n\tlocal dev=$1; shift\n\tlocal ns=$1; shift\n\n\t$(maybe_in_ns $ns) tc_rule_stats_get $dev 100 ingress\n}\n\nflood_fetch_stats()\n{\n\tlocal counters=(\"${@}\")\n\tlocal counter\n\n\tfor counter in \"${counters[@]}\"; do\n\t\tflood_fetch_stat $counter\n\tdone\n}\n\nvxlan_flood_test()\n{\n\tlocal mac=$1; shift\n\tlocal dst=$1; shift\n\tlocal -a expects=(\"${@}\")\n\n\tlocal -a counters=($h2 \"vx2 ns1\" \"vx2 ns2\")\n\tlocal counter\n\tlocal key\n\n\tfor counter in \"${counters[@]}\"; do\n\t\tflood_counter_install $dst $counter\n\tdone\n\n\tlocal -a t0s=($(flood_fetch_stats \"${counters[@]}\"))\n\t$MZ -6 $h1 -c 10 -d 100msec -p 64 -b $mac -B $dst -t icmp6 type=128 -q\n\tsleep 1\n\tlocal -a t1s=($(flood_fetch_stats \"${counters[@]}\"))\n\n\tfor key in ${!t0s[@]}; do\n\t\tlocal delta=$((t1s[$key] - t0s[$key]))\n\t\tlocal expect=${expects[$key]}\n\n\t\t((expect == delta))\n\t\tcheck_err $? \"${counters[$key]}: Expected to capture $expect packets, got $delta.\"\n\tdone\n\n\tfor counter in \"${counters[@]}\"; do\n\t\tflood_counter_uninstall $dst $counter\n\tdone\n}\n\n__test_flood()\n{\n\tlocal mac=$1; shift\n\tlocal dst=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tvxlan_flood_test $mac $dst 10 10 10\n\n\tlog_test \"VXLAN: $what\"\n}\n\ntest_flood()\n{\n\t__test_flood de:ad:be:ef:13:37 2001:db8:1::100 \"flood\"\n}\n\nvxlan_fdb_add_del()\n{\n\tlocal add_del=$1; shift\n\tlocal mac=$1; shift\n\tlocal dev=$1; shift\n\tlocal dst=$1; shift\n\n\tbridge fdb $add_del dev $dev $mac self static permanent \\\n\t\t${dst:+dst} $dst 2>/dev/null\n\tbridge fdb $add_del dev $dev $mac master static 2>/dev/null\n}\n\n__test_unicast()\n{\n\tlocal mac=$1; shift\n\tlocal dst=$1; shift\n\tlocal hit_idx=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tlocal -a expects=(0 0 0)\n\texpects[$hit_idx]=10\n\n\tvxlan_flood_test $mac $dst \"${expects[@]}\"\n\n\tlog_test \"VXLAN: $what\"\n}\n\ntest_unicast()\n{\n\tlocal -a targets=(\"$h2_mac $h2\"\n\t\t\t  \"$r1_mac vx1 2001:db8:4::1\"\n\t\t\t  \"$r2_mac vx1 2001:db8:5::1\")\n\tlocal target\n\n\tfor target in \"${targets[@]}\"; do\n\t\tvxlan_fdb_add_del add $target\n\tdone\n\n\t__test_unicast $h2_mac 2001:db8:1::2 0 \"local MAC unicast\"\n\t__test_unicast $r1_mac 2001:db8:1::3 1 \"remote MAC 1 unicast\"\n\t__test_unicast $r2_mac 2001:db8:1::4 2 \"remote MAC 2 unicast\"\n\n\tfor target in \"${targets[@]}\"; do\n\t\tvxlan_fdb_add_del del $target\n\tdone\n}\n\nvxlan_ping_test()\n{\n\tlocal ping_dev=$1; shift\n\tlocal ping_dip=$1; shift\n\tlocal ping_args=$1; shift\n\tlocal capture_dev=$1; shift\n\tlocal capture_dir=$1; shift\n\tlocal capture_pref=$1; shift\n\tlocal expect=$1; shift\n\n\tlocal t0=$(tc_rule_stats_get $capture_dev $capture_pref $capture_dir)\n\tping6_do $ping_dev $ping_dip \"$ping_args\"\n\tlocal t1=$(tc_rule_stats_get $capture_dev $capture_pref $capture_dir)\n\tlocal delta=$((t1 - t0))\n\n\t# Tolerate a couple stray extra packets.\n\t((expect <= delta && delta <= expect + 2))\n\tcheck_err $? \"$capture_dev: Expected to capture $expect packets, got $delta.\"\n}\n\ntest_ttl()\n{\n\tRET=0\n\n\ttc filter add dev v1 egress pref 77 protocol ipv6 \\\n\t\tflower ip_ttl 99 action pass\n\tvxlan_ping_test $h1 2001:db8:1::3 \"\" v1 egress 77 10\n\ttc filter del dev v1 egress pref 77 protocol ipv6\n\n\tlog_test \"VXLAN: envelope TTL\"\n}\n\ntest_tos()\n{\n\tRET=0\n\n\ttc filter add dev v1 egress pref 77 protocol ipv6 \\\n\t\tflower ip_tos 0x14 action pass\n\tvxlan_ping_test $h1 2001:db8:1::3 \"-Q 0x14\" v1 egress 77 10\n\tvxlan_ping_test $h1 2001:db8:1::3 \"-Q 0x18\" v1 egress 77 0\n\ttc filter del dev v1 egress pref 77 protocol ipv6\n\n\tlog_test \"VXLAN: envelope TOS inheritance\"\n}\n\n__test_ecn_encap()\n{\n\tlocal q=$1; shift\n\tlocal tos=$1; shift\n\n\tRET=0\n\n\ttc filter add dev v1 egress pref 77 protocol ipv6 \\\n\t\tflower ip_tos $tos action pass\n\tsleep 1\n\tvxlan_ping_test $h1 2001:db8:1::3 \"-Q $q\" v1 egress 77 10\n\ttc filter del dev v1 egress pref 77 protocol ipv6\n\n\tlog_test \"VXLAN: ECN encap: $q->$tos\"\n}\n\ntest_ecn_encap()\n{\n\t# In accordance with INET_ECN_encapsulate()\n\t__test_ecn_encap 0x00 0x00\n\t__test_ecn_encap 0x01 0x01\n\t__test_ecn_encap 0x02 0x02\n\t__test_ecn_encap 0x03 0x02\n}\n\nvxlan_encapped_ping_do()\n{\n\tlocal count=$1; shift\n\tlocal dev=$1; shift\n\tlocal next_hop_mac=$1; shift\n\tlocal dest_ip=$1; shift\n\tlocal dest_mac=$1; shift\n\tlocal inner_tos=$1; shift\n\tlocal outer_tos=$1; shift\n\tlocal saddr=\"20:01:0d:b8:00:01:00:00:00:00:00:00:00:00:00:03\"\n\tlocal daddr=\"20:01:0d:b8:00:01:00:00:00:00:00:00:00:00:00:01\"\n\n\t$MZ -6 $dev -c $count -d 100msec -q \\\n\t\t-b $next_hop_mac -B $dest_ip \\\n\t\t-t udp tos=$outer_tos,sp=23456,dp=$VXPORT,p=$(:\n\t\t    )\"08:\"$(                      : VXLAN flags\n\t\t    )\"00:00:00:\"$(                : VXLAN reserved\n\t\t    )\"00:03:e8:\"$(                : VXLAN VNI\n\t\t    )\"00:\"$(                      : VXLAN reserved\n\t\t    )\"$dest_mac:\"$(               : ETH daddr\n\t\t    )\"$(mac_get w2):\"$(           : ETH saddr\n\t\t    )\"86:dd:\"$(                   : ETH type\n\t\t    )\"6\"$(\t\t\t  : IP version\n\t\t    )\"$inner_tos\"$(               : Traffic class\n\t\t    )\"0:00:00:\"$(                 : Flow label\n\t\t    )\"00:08:\"$(                   : Payload length\n\t\t    )\"3a:\"$(                      : Next header\n\t\t    )\"04:\"$(                      : Hop limit\n\t\t    )\"$saddr:\"$(\t\t  : IP saddr\n\t\t    )\"$daddr:\"$(\t\t  : IP daddr\n\t\t    )\"80:\"$(\t\t\t  : ICMPv6.type\n\t\t    )\"00:\"$(\t\t\t  : ICMPv6.code\n\t\t    )\"00:\"$(\t\t\t  : ICMPv6.checksum\n\t\t    )\n}\nexport -f vxlan_encapped_ping_do\n\nvxlan_encapped_ping_test()\n{\n\tlocal ping_dev=$1; shift\n\tlocal nh_dev=$1; shift\n\tlocal ping_dip=$1; shift\n\tlocal inner_tos=$1; shift\n\tlocal outer_tos=$1; shift\n\tlocal stat_get=$1; shift\n\tlocal expect=$1; shift\n\n\tlocal t0=$($stat_get)\n\n\tin_ns ns1 \\\n\t\tvxlan_encapped_ping_do 10 $ping_dev $(mac_get $nh_dev) \\\n\t\t\t$ping_dip $(mac_get $h1) \\\n\t\t\t$inner_tos $outer_tos\n\tsleep 1\n\tlocal t1=$($stat_get)\n\tlocal delta=$((t1 - t0))\n\n\t# Tolerate a couple stray extra packets.\n\t((expect <= delta && delta <= expect + 2))\n\tcheck_err $? \"Expected to capture $expect packets, got $delta.\"\n}\nexport -f vxlan_encapped_ping_test\n\n__test_ecn_decap()\n{\n\tlocal orig_inner_tos=$1; shift\n\tlocal orig_outer_tos=$1; shift\n\tlocal decapped_tos=$1; shift\n\n\tRET=0\n\n\ttc filter add dev $h1 ingress pref 77 protocol ipv6 \\\n\t\tflower src_ip 2001:db8:1::3 dst_ip 2001:db8:1::1 \\\n\t\tip_tos $decapped_tos action drop\n\tsleep 1\n\tvxlan_encapped_ping_test v2 v1 2001:db8:3::1 \\\n\t\t\t\t $orig_inner_tos $orig_outer_tos \\\n\t\t\t\t \"tc_rule_stats_get $h1 77 ingress\" 10\n\ttc filter del dev $h1 ingress pref 77\n\n\tlog_test \"VXLAN: ECN decap: $orig_outer_tos/$orig_inner_tos->$decapped_tos\"\n}\n\ntest_ecn_decap_error()\n{\n\tlocal orig_inner_tos=\"0:0\"\n\tlocal orig_outer_tos=03\n\n\tRET=0\n\n\tvxlan_encapped_ping_test v2 v1 2001:db8:3::1 \\\n\t\t\t\t $orig_inner_tos $orig_outer_tos \\\n\t\t\t\t \"link_stats_rx_errors_get vx1\" 10\n\n\tlog_test \"VXLAN: ECN decap: $orig_outer_tos/$orig_inner_tos->error\"\n}\n\ntest_ecn_decap()\n{\n\t# In accordance with INET_ECN_decapsulate()\n\t__test_ecn_decap \"0:0\" 00 0x00\n\t__test_ecn_decap \"0:0\" 01 0x00\n\t__test_ecn_decap \"0:0\" 02 0x00\n\t# 00 03 is tested in test_ecn_decap_error()\n\t__test_ecn_decap \"0:1\" 00 0x01\n\t__test_ecn_decap \"0:1\" 01 0x01\n\t__test_ecn_decap \"0:1\" 02 0x01\n\t__test_ecn_decap \"0:1\" 03 0x03\n\t__test_ecn_decap \"0:2\" 00 0x02\n\t__test_ecn_decap \"0:2\" 01 0x01\n\t__test_ecn_decap \"0:2\" 02 0x02\n\t__test_ecn_decap \"0:2\" 03 0x03\n\t__test_ecn_decap \"0:3\" 00 0x03\n\t__test_ecn_decap \"0:3\" 01 0x03\n\t__test_ecn_decap \"0:3\" 02 0x03\n\t__test_ecn_decap \"0:3\" 03 0x03\n\ttest_ecn_decap_error\n}\n\ntest_all()\n{\n\tlog_info \"Running tests with UDP port $VXPORT\"\n\ttests_run\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\ntest_all\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}