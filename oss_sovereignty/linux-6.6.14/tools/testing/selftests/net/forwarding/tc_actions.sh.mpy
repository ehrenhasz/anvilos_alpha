{
  "module_name": "tc_actions.sh",
  "hash_id": "50dbf96a717f56f4240ba6b4a794d2492a41391752ceded2a127107141d03329",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/tc_actions.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\nALL_TESTS=\"gact_drop_and_ok_test mirred_egress_redirect_test \\\n\tmirred_egress_mirror_test matchall_mirred_egress_mirror_test \\\n\tgact_trap_test mirred_egress_to_ingress_test \\\n\tmirred_egress_to_ingress_tcp_test\"\nNUM_NETIFS=4\nsource tc_common.sh\nsource lib.sh\n\nrequire_command ncat\n\ntcflags=\"skip_hw\"\n\nh1_create()\n{\n\tsimple_if_init $h1 192.0.2.1/24\n\ttc qdisc add dev $h1 clsact\n}\n\nh1_destroy()\n{\n\ttc qdisc del dev $h1 clsact\n\tsimple_if_fini $h1 192.0.2.1/24\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 192.0.2.2/24\n\ttc qdisc add dev $h2 clsact\n}\n\nh2_destroy()\n{\n\ttc qdisc del dev $h2 clsact\n\tsimple_if_fini $h2 192.0.2.2/24\n}\n\nswitch_create()\n{\n\tsimple_if_init $swp1 192.0.2.2/24\n\ttc qdisc add dev $swp1 clsact\n\n\tsimple_if_init $swp2 192.0.2.1/24\n}\n\nswitch_destroy()\n{\n\tsimple_if_fini $swp2 192.0.2.1/24\n\n\ttc qdisc del dev $swp1 clsact\n\tsimple_if_fini $swp1 192.0.2.2/24\n}\n\nmirred_egress_test()\n{\n\tlocal action=$1\n\tlocal protocol=$2\n\tlocal classifier=$3\n\tlocal classifier_args=$4\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 101 flower \\\n\t\tdst_ip 192.0.2.2 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_fail $? \"Matched without redirect rule inserted\"\n\n\ttc filter add dev $swp1 ingress protocol $protocol pref 1 handle 101 \\\n\t\t$classifier $tcflags $classifier_args \\\n\t\taction mirred egress $action dev $swp2\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $h2 ingress\" 101 1\n\tcheck_err $? \"Did not match incoming $action packet\"\n\n\ttc filter del dev $swp1 ingress protocol $protocol pref 1 handle 101 \\\n\t\t$classifier\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 101 flower\n\n\tlog_test \"mirred egress $classifier $action ($tcflags)\"\n}\n\ngact_drop_and_ok_test()\n{\n\tRET=0\n\n\ttc filter add dev $swp1 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action drop\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $swp1 ingress\" 102 1\n\tcheck_err $? \"Packet was not dropped\"\n\n\ttc filter add dev $swp1 ingress protocol ip pref 1 handle 101 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action ok\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $swp1 ingress\" 101 1\n\tcheck_err $? \"Did not see passed packet\"\n\n\ttc_check_packets \"dev $swp1 ingress\" 102 2\n\tcheck_fail $? \"Packet was dropped and it should not reach here\"\n\n\ttc filter del dev $swp1 ingress protocol ip pref 2 handle 102 flower\n\ttc filter del dev $swp1 ingress protocol ip pref 1 handle 101 flower\n\n\tlog_test \"gact drop and ok ($tcflags)\"\n}\n\ngact_trap_test()\n{\n\tRET=0\n\n\tif [[ \"$tcflags\" != \"skip_sw\" ]]; then\n\t\treturn 0;\n\tfi\n\n\ttc filter add dev $swp1 ingress protocol ip pref 1 handle 101 flower \\\n\t\tskip_hw dst_ip 192.0.2.2 action drop\n\ttc filter add dev $swp1 ingress protocol ip pref 3 handle 103 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action mirred egress redirect \\\n\t\tdev $swp2\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $swp1 ingress\" 101 1\n\tcheck_fail $? \"Saw packet without trap rule inserted\"\n\n\ttc filter add dev $swp1 ingress protocol ip pref 2 handle 102 flower \\\n\t\t$tcflags dst_ip 192.0.2.2 action trap\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t ip -q\n\n\ttc_check_packets \"dev $swp1 ingress\" 102 1\n\tcheck_err $? \"Packet was not trapped\"\n\n\ttc_check_packets \"dev $swp1 ingress\" 101 1\n\tcheck_err $? \"Did not see trapped packet\"\n\n\ttc filter del dev $swp1 ingress protocol ip pref 3 handle 103 flower\n\ttc filter del dev $swp1 ingress protocol ip pref 2 handle 102 flower\n\ttc filter del dev $swp1 ingress protocol ip pref 1 handle 101 flower\n\n\tlog_test \"trap ($tcflags)\"\n}\n\nmirred_egress_to_ingress_test()\n{\n\tRET=0\n\n\ttc filter add dev $h1 protocol ip pref 100 handle 100 egress flower \\\n\t\tip_proto icmp src_ip 192.0.2.1 dst_ip 192.0.2.2 type 8 action \\\n\t\t\tct commit nat src addr 192.0.2.2 pipe \\\n\t\t\tct clear pipe \\\n\t\t\tct commit nat dst addr 192.0.2.1 pipe \\\n\t\t\tmirred ingress redirect dev $h1\n\n\ttc filter add dev $swp1 protocol ip pref 11 handle 111 ingress flower \\\n\t\tip_proto icmp src_ip 192.0.2.1 dst_ip 192.0.2.2 type 8 action drop\n\ttc filter add dev $swp1 protocol ip pref 12 handle 112 ingress flower \\\n\t\tip_proto icmp src_ip 192.0.2.1 dst_ip 192.0.2.2 type 0 action pass\n\n\t$MZ $h1 -c 1 -p 64 -a $h1mac -b $h2mac -A 192.0.2.1 -B 192.0.2.2 \\\n\t\t-t icmp \"ping,id=42,seq=10\" -q\n\n\ttc_check_packets \"dev $h1 egress\" 100 1\n\tcheck_err $? \"didn't mirror first packet\"\n\n\ttc_check_packets \"dev $swp1 ingress\" 111 1\n\tcheck_fail $? \"didn't redirect first packet\"\n\ttc_check_packets \"dev $swp1 ingress\" 112 1\n\tcheck_err $? \"didn't receive reply to first packet\"\n\n\tping 192.0.2.2 -I$h1 -c1 -w1 -q 1>/dev/null 2>&1\n\n\ttc_check_packets \"dev $h1 egress\" 100 2\n\tcheck_err $? \"didn't mirror second packet\"\n\ttc_check_packets \"dev $swp1 ingress\" 111 1\n\tcheck_fail $? \"didn't redirect second packet\"\n\ttc_check_packets \"dev $swp1 ingress\" 112 2\n\tcheck_err $? \"didn't receive reply to second packet\"\n\n\ttc filter del dev $h1 egress protocol ip pref 100 handle 100 flower\n\ttc filter del dev $swp1 ingress protocol ip pref 11 handle 111 flower\n\ttc filter del dev $swp1 ingress protocol ip pref 12 handle 112 flower\n\n\tlog_test \"mirred_egress_to_ingress ($tcflags)\"\n}\n\nmirred_egress_to_ingress_tcp_test()\n{\n\tmirred_e2i_tf1=$(mktemp) mirred_e2i_tf2=$(mktemp)\n\n\tRET=0\n\tdd conv=sparse status=none if=/dev/zero bs=1M count=2 of=$mirred_e2i_tf1\n\ttc filter add dev $h1 protocol ip pref 100 handle 100 egress flower \\\n\t\t$tcflags ip_proto tcp src_ip 192.0.2.1 dst_ip 192.0.2.2 \\\n\t\t\taction ct commit nat src addr 192.0.2.2 pipe \\\n\t\t\taction ct clear pipe \\\n\t\t\taction ct commit nat dst addr 192.0.2.1 pipe \\\n\t\t\taction ct clear pipe \\\n\t\t\taction skbedit ptype host pipe \\\n\t\t\taction mirred ingress redirect dev $h1\n\ttc filter add dev $h1 protocol ip pref 101 handle 101 egress flower \\\n\t\t$tcflags ip_proto icmp \\\n\t\t\taction mirred ingress redirect dev $h1\n\ttc filter add dev $h1 protocol ip pref 102 handle 102 ingress flower \\\n\t\tip_proto icmp \\\n\t\t\taction drop\n\n\tip vrf exec v$h1 ncat --recv-only -w10 -l -p 12345 -o $mirred_e2i_tf2 &\n\tlocal rpid=$!\n\tip vrf exec v$h1 ncat -w1 --send-only 192.0.2.2 12345 <$mirred_e2i_tf1\n\twait -n $rpid\n\tcmp -s $mirred_e2i_tf1 $mirred_e2i_tf2\n\tcheck_err $? \"server output check failed\"\n\n\t$MZ $h1 -c 10 -p 64 -a $h1mac -b $h1mac -A 192.0.2.1 -B 192.0.2.1 \\\n\t\t-t icmp \"ping,id=42,seq=5\" -q\n\ttc_check_packets \"dev $h1 egress\" 101 10\n\tcheck_err $? \"didn't mirred redirect ICMP\"\n\ttc_check_packets \"dev $h1 ingress\" 102 10\n\tcheck_err $? \"didn't drop mirred ICMP\"\n\tlocal overlimits=$(tc_rule_stats_get ${h1} 101 egress .overlimits)\n\ttest ${overlimits} = 10\n\tcheck_err $? \"wrong overlimits, expected 10 got ${overlimits}\"\n\n\ttc filter del dev $h1 egress protocol ip pref 100 handle 100 flower\n\ttc filter del dev $h1 egress protocol ip pref 101 handle 101 flower\n\ttc filter del dev $h1 ingress protocol ip pref 102 handle 102 flower\n\n\trm -f $mirred_e2i_tf1 $mirred_e2i_tf2\n\tlog_test \"mirred_egress_to_ingress_tcp ($tcflags)\"\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\th1mac=$(mac_get $h1)\n\th2mac=$(mac_get $h2)\n\n\tswp1origmac=$(mac_get $swp1)\n\tswp2origmac=$(mac_get $swp2)\n\tip link set $swp1 address $h2mac\n\tip link set $swp2 address $h1mac\n\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\tswitch_create\n}\n\ncleanup()\n{\n\tlocal tf\n\n\tpre_cleanup\n\n\tswitch_destroy\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n\n\tip link set $swp2 address $swp2origmac\n\tip link set $swp1 address $swp1origmac\n\n\tfor tf in $mirred_e2i_tf1 $mirred_e2i_tf2; do rm -f $tf; done\n}\n\nmirred_egress_redirect_test()\n{\n\tmirred_egress_test \"redirect\" \"ip\" \"flower\" \"dst_ip 192.0.2.2\"\n}\n\nmirred_egress_mirror_test()\n{\n\tmirred_egress_test \"mirror\" \"ip\" \"flower\" \"dst_ip 192.0.2.2\"\n}\n\nmatchall_mirred_egress_mirror_test()\n{\n\tmirred_egress_test \"mirror\" \"all\" \"matchall\" \"\"\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\ntc_offload_check\nif [[ $? -ne 0 ]]; then\n\tlog_info \"Could not test offloaded functionality\"\nelse\n\ttcflags=\"skip_sw\"\n\ttests_run\nfi\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}