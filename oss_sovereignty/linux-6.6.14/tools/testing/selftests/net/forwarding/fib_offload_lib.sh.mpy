{
  "module_name": "fib_offload_lib.sh",
  "hash_id": "2b87a8e1027c9128ca67761e5c99b3700d4e22d362a611f3d984290417b4bea9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/fib_offload_lib.sh",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# Various helpers and tests to verify FIB offload.\n\n__fib_trap_check()\n{\n\tlocal ns=$1; shift\n\tlocal family=$1; shift\n\tlocal route=$1; shift\n\tlocal should_fail=$1; shift\n\tlocal ret\n\n\tip -n $ns -j -p -$family route show $route \\\n\t\t| jq -e '.[][\"flags\"] | contains([\"trap\"])' &> /dev/null\n\tret=$?\n\tif [[ $should_fail == \"true\" ]]; then\n\t\tif [[ $ret -ne 0 ]]; then\n\t\t\treturn 0\n\t\telse\n\t\t\treturn 1\n\t\tfi\n\tfi\n\n\treturn $ret\n}\n\nfib_trap_check()\n{\n\tlocal ns=$1; shift\n\tlocal family=$1; shift\n\tlocal route=$1; shift\n\tlocal should_fail=$1; shift\n\n\tbusywait 5000 __fib_trap_check $ns $family \"$route\" $should_fail\n}\n\nfib4_trap_check()\n{\n\tlocal ns=$1; shift\n\tlocal route=$1; shift\n\tlocal should_fail=$1; shift\n\n\tfib_trap_check $ns 4 \"$route\" $should_fail\n}\n\nfib6_trap_check()\n{\n\tlocal ns=$1; shift\n\tlocal route=$1; shift\n\tlocal should_fail=$1; shift\n\n\tfib_trap_check $ns 6 \"$route\" $should_fail\n}\n\nfib_ipv4_identical_routes_test()\n{\n\tlocal ns=$1; shift\n\tlocal i\n\n\tRET=0\n\n\tfor i in $(seq 1 3); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\tdone\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 tos 0 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 tos 0 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route append 192.0.2.0/24 dev dummy2 tos 0 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy2 tos 0 metric 1024\" true\n\tcheck_err $? \"Appended route in hardware when should not\"\n\n\tip -n $ns route prepend 192.0.2.0/24 dev dummy3 tos 0 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy3 tos 0 metric 1024\" false\n\tcheck_err $? \"Prepended route not in hardware when should\"\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 tos 0 metric 1024\" true\n\tcheck_err $? \"Route was not replaced in hardware by prepended one\"\n\n\tlog_test \"IPv4 identical routes\"\n\n\tfor i in $(seq 1 3); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv4_tos_test()\n{\n\tlocal ns=$1; shift\n\n\tRET=0\n\n\tip -n $ns link add name dummy1 type dummy\n\tip -n $ns link set dev dummy1 up\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 tos 0 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 tos 0 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 tos 8 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 tos 8 metric 1024\" false\n\tcheck_err $? \"Highest TOS route not in hardware when should\"\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 tos 0 metric 1024\" true\n\tcheck_err $? \"Lowest TOS route still in hardware when should not\"\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 tos 4 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 tos 4 metric 1024\" true\n\tcheck_err $? \"Middle TOS route in hardware when should not\"\n\n\tlog_test \"IPv4 routes with TOS\"\n\n\tip -n $ns link del dev dummy1\n}\n\nfib_ipv4_metric_test()\n{\n\tlocal ns=$1; shift\n\n\tRET=0\n\n\tip -n $ns link add name dummy1 type dummy\n\tip -n $ns link set dev dummy1 up\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 metric 1022\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1022\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1024\" true\n\tcheck_err $? \"Highest metric route still in hardware when should not\"\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 metric 1023\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1023\" true\n\tcheck_err $? \"Middle metric route in hardware when should not\"\n\n\tlog_test \"IPv4 routes with metric\"\n\n\tip -n $ns link del dev dummy1\n}\n\nfib_ipv4_replace_test()\n{\n\tlocal ns=$1; shift\n\tlocal i\n\n\tRET=0\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\tdone\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route replace 192.0.2.0/24 dev dummy2 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy2 metric 1024\" false\n\tcheck_err $? \"Replacement route not in hardware when should\"\n\n\t# Add a route with an higher metric and make sure that replacing it\n\t# does not affect the lower metric one.\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 metric 1025\n\tip -n $ns route replace 192.0.2.0/24 dev dummy2 metric 1025\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy2 metric 1024\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy2 metric 1025\" true\n\tcheck_err $? \"Highest metric route in hardware when should not\"\n\n\tlog_test \"IPv4 route replace\"\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv4_delete_test()\n{\n\tlocal ns=$1; shift\n\tlocal metric\n\n\tRET=0\n\n\tip -n $ns link add name dummy1 type dummy\n\tip -n $ns link set dev dummy1 up\n\n\t# Insert multiple routes with the same prefix and length and varying\n\t# metrics. Make sure that throughout delete operations the lowest\n\t# metric route is the one in hardware.\n\tfor metric in $(seq 1024 1026); do\n\t\tip -n $ns route add 192.0.2.0/24 dev dummy1 metric $metric\n\tdone\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route del 192.0.2.0/24 dev dummy1 metric 1024\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1025\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\n\tip -n $ns route del 192.0.2.0/24 dev dummy1 metric 1026\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1025\" false\n\tcheck_err $? \"Sole route not in hardware when should\"\n\n\tlog_test \"IPv4 route delete\"\n\n\tip -n $ns link del dev dummy1\n}\n\nfib_ipv4_plen_test()\n{\n\tlocal ns=$1; shift\n\n\tRET=0\n\n\tip -n $ns link add name dummy1 type dummy\n\tip -n $ns link set dev dummy1 up\n\n\t# Add two routes with the same key and different prefix length and\n\t# make sure both are in hardware. It can be verified that both are\n\t# sharing the same leaf by checking the /proc/net/fib_trie\n\tip -n $ns route add 192.0.2.0/24 dev dummy1\n\tip -n $ns route add 192.0.2.0/25 dev dummy1\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1\" false\n\tcheck_err $? \"/24 not in hardware when should\"\n\n\tfib4_trap_check $ns \"192.0.2.0/25 dev dummy1\" false\n\tcheck_err $? \"/25 not in hardware when should\"\n\n\tlog_test \"IPv4 routes with different prefix length\"\n\n\tip -n $ns link del dev dummy1\n}\n\nfib_ipv4_replay_metric_test()\n{\n\tlocal ns=$1; shift\n\tlocal devlink_dev=$1; shift\n\n\tRET=0\n\n\tip -n $ns link add name dummy1 type dummy\n\tip -n $ns link set dev dummy1 up\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 metric 1024\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 metric 1025\n\n\tdevlink -N $ns dev reload $devlink_dev\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 metric 1025\" true\n\tcheck_err $? \"Highest metric route in hardware when should not\"\n\n\tlog_test \"IPv4 routes replay - metric\"\n\n\tip -n $ns link del dev dummy1\n}\n\nfib_ipv4_replay_tos_test()\n{\n\tlocal ns=$1; shift\n\tlocal devlink_dev=$1; shift\n\n\tRET=0\n\n\tip -n $ns link add name dummy1 type dummy\n\tip -n $ns link set dev dummy1 up\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 tos 0\n\tip -n $ns route add 192.0.2.0/24 dev dummy1 tos 4\n\n\tdevlink -N $ns dev reload $devlink_dev\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 tos 4\" false\n\tcheck_err $? \"Highest TOS route not in hardware when should\"\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1 tos 0\" true\n\tcheck_err $? \"Lowest TOS route in hardware when should not\"\n\n\tlog_test \"IPv4 routes replay - TOS\"\n\n\tip -n $ns link del dev dummy1\n}\n\nfib_ipv4_replay_plen_test()\n{\n\tlocal ns=$1; shift\n\tlocal devlink_dev=$1; shift\n\n\tRET=0\n\n\tip -n $ns link add name dummy1 type dummy\n\tip -n $ns link set dev dummy1 up\n\n\tip -n $ns route add 192.0.2.0/24 dev dummy1\n\tip -n $ns route add 192.0.2.0/25 dev dummy1\n\n\tdevlink -N $ns dev reload $devlink_dev\n\n\tfib4_trap_check $ns \"192.0.2.0/24 dev dummy1\" false\n\tcheck_err $? \"/24 not in hardware when should\"\n\n\tfib4_trap_check $ns \"192.0.2.0/25 dev dummy1\" false\n\tcheck_err $? \"/25 not in hardware when should\"\n\n\tlog_test \"IPv4 routes replay - prefix length\"\n\n\tip -n $ns link del dev dummy1\n}\n\nfib_ipv4_flush_test()\n{\n\tlocal ns=$1; shift\n\tlocal metric\n\n\tRET=0\n\n\tip -n $ns link add name dummy1 type dummy\n\tip -n $ns link set dev dummy1 up\n\n\t# Exercise the routes flushing code paths by inserting various\n\t# prefix routes on a netdev and then deleting it.\n\tfor metric in $(seq 1 20); do\n\t\tip -n $ns route add 192.0.2.0/24 dev dummy1 metric $metric\n\tdone\n\n\tip -n $ns link del dev dummy1\n\n\tlog_test \"IPv4 routes flushing\"\n}\n\nfib_ipv6_add_test()\n{\n\tlocal ns=$1; shift\n\n\tRET=0\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\tdone\n\n\tip -n $ns route add 2001:db8:1::/64 dev dummy1 metric 1024\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route append 2001:db8:1::/64 dev dummy2 metric 1024\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy2 metric 1024\" true\n\tcheck_err $? \"Route in hardware when should not\"\n\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware after appending route\"\n\n\tlog_test \"IPv6 single route add\"\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_metric_test()\n{\n\tlocal ns=$1; shift\n\n\tRET=0\n\n\tip -n $ns link add name dummy1 type dummy\n\tip -n $ns link set dev dummy1 up\n\n\tip -n $ns route add 2001:db8:1::/64 dev dummy1 metric 1024\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route add 2001:db8:1::/64 dev dummy1 metric 1022\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy1 metric 1022\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy1 metric 1024\" true\n\tcheck_err $? \"Highest metric route still in hardware when should not\"\n\n\tip -n $ns route add 2001:db8:1::/64 dev dummy1 metric 1023\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy1 metric 1023\" true\n\tcheck_err $? \"Middle metric route in hardware when should not\"\n\n\tlog_test \"IPv6 routes with metric\"\n\n\tip -n $ns link del dev dummy1\n}\n\nfib_ipv6_append_single_test()\n{\n\tlocal ns=$1; shift\n\n\t# When an IPv6 multipath route is added without the 'nexthop' keyword,\n\t# different code paths are taken compared to when the keyword is used.\n\t# This test tries to verify the former.\n\tRET=0\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\t\tip -n $ns address add 2001:db8:$i::1/64 dev dummy$i\n\tdone\n\n\tip -n $ns route add 2001:db8:10::/64 via 2001:db8:1::2 metric 1024\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route append 2001:db8:10::/64 via 2001:db8:2::2 metric 1024\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Route not in hardware after appending\"\n\n\tip -n $ns route add 2001:db8:10::/64 via 2001:db8:1::2 metric 1025\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1025\" true\n\tcheck_err $? \"Route in hardware when should not\"\n\n\tip -n $ns route append 2001:db8:10::/64 via 2001:db8:2::2 metric 1025\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1025\" true\n\tcheck_err $? \"Route in hardware when should not after appending\"\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\n\tlog_test \"IPv6 append single route without 'nexthop' keyword\"\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_replace_single_test()\n{\n\tlocal ns=$1; shift\n\tlocal i\n\n\tRET=0\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\tdone\n\n\tip -n $ns route add 2001:db8:1::/64 dev dummy1 metric 1024\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route replace 2001:db8:1::/64 dev dummy2 metric 1024\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy2 metric 1024\" false\n\tcheck_err $? \"Replacement route not in hardware when should\"\n\n\t# Add a route with an higher metric and make sure that replacing it\n\t# does not affect the lower metric one.\n\tip -n $ns route add 2001:db8:1::/64 dev dummy1 metric 1025\n\tip -n $ns route replace 2001:db8:1::/64 dev dummy2 metric 1025\n\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy2 metric 1024\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy2 metric 1025\" true\n\tcheck_err $? \"Highest metric route in hardware when should not\"\n\n\tlog_test \"IPv6 single route replace\"\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_metric_multipath_test()\n{\n\tlocal ns=$1; shift\n\n\tRET=0\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\t\tip -n $ns address add 2001:db8:$i::1/64 dev dummy$i\n\tdone\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1022 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1022\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1023 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" true\n\tcheck_err $? \"Highest metric route still in hardware when should not\"\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1023\" true\n\tcheck_err $? \"Middle metric route in hardware when should not\"\n\n\tlog_test \"IPv6 multipath routes with metric\"\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_append_multipath_test()\n{\n\tlocal ns=$1; shift\n\n\tRET=0\n\n\tfor i in $(seq 1 3); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\t\tip -n $ns address add 2001:db8:$i::1/64 dev dummy$i\n\tdone\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route append 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2 \\\n\t\tnexthop via 2001:db8:3::2 dev dummy3\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Route not in hardware after appending\"\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1025 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1025\" true\n\tcheck_err $? \"Route in hardware when should not\"\n\n\tip -n $ns route append 2001:db8:10::/64 metric 1025 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2 \\\n\t\tnexthop via 2001:db8:3::2 dev dummy3\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1025\" true\n\tcheck_err $? \"Route in hardware when should not after appending\"\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\n\tlog_test \"IPv6 append multipath route with 'nexthop' keyword\"\n\n\tfor i in $(seq 1 3); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_replace_multipath_test()\n{\n\tlocal ns=$1; shift\n\tlocal i\n\n\tRET=0\n\n\tfor i in $(seq 1 3); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\t\tip -n $ns address add 2001:db8:$i::1/64 dev dummy$i\n\tdone\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route replace 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:3::2 dev dummy3\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Replacement route not in hardware when should\"\n\n\t# Add a route with an higher metric and make sure that replacing it\n\t# does not affect the lower metric one.\n\tip -n $ns route add 2001:db8:10::/64 metric 1025 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route replace 2001:db8:10::/64 metric 1025 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:3::2 dev dummy3\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Lowest metric route not in hardware when should\"\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1025\" true\n\tcheck_err $? \"Highest metric route in hardware when should not\"\n\n\tlog_test \"IPv6 multipath route replace\"\n\n\tfor i in $(seq 1 3); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_append_multipath_to_single_test()\n{\n\tlocal ns=$1; shift\n\n\t# Test that when the first route in the leaf is not a multipath route\n\t# and we try to append a multipath route with the same metric to it, it\n\t# is not notified.\n\tRET=0\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\t\tip -n $ns address add 2001:db8:$i::1/64 dev dummy$i\n\tdone\n\n\tip -n $ns route add 2001:db8:10::/64 dev dummy1 metric 1024\n\tfib6_trap_check $ns \"2001:db8:10::/64 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware when should\"\n\n\tip -n $ns route append 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tfib6_trap_check $ns \"2001:db8:10::/64 dev dummy2 metric 1024\" true\n\tcheck_err $? \"Route in hardware when should not\"\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware after append\"\n\n\tlog_test \"IPv6 append multipath route to non-multipath route\"\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_delete_single_test()\n{\n\tlocal ns=$1; shift\n\n\t# Test various deletion scenarios, where only a single route is\n\t# deleted from the FIB node.\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\t\tip -n $ns address add 2001:db8:$i::1/64 dev dummy$i\n\tdone\n\n\t# Test deletion of a single route when it is the only route in the FIB\n\t# node.\n\tRET=0\n\n\tip -n $ns route add 2001:db8:10::/64 dev dummy1 metric 1024\n\tip -n $ns route del 2001:db8:10::/64 dev dummy1 metric 1024\n\n\tlog_test \"IPv6 delete sole single route\"\n\n\t# Test that deletion of last route does not affect the first one.\n\tRET=0\n\n\tip -n $ns route add 2001:db8:10::/64 dev dummy1 metric 1024\n\tip -n $ns route add 2001:db8:10::/64 dev dummy1 metric 1025\n\tip -n $ns route del 2001:db8:10::/64 dev dummy1 metric 1025\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 dev dummy1 metric 1024\" false\n\tcheck_err $? \"Route not in hardware after deleting higher metric route\"\n\n\tlog_test \"IPv6 delete single route not in hardware\"\n\n\tip -n $ns route del 2001:db8:10::/64 dev dummy1 metric 1024\n\n\t# Test that first route is replaced by next single route in the FIB\n\t# node.\n\tRET=0\n\n\tip -n $ns route add 2001:db8:10::/64 dev dummy1 metric 1024\n\tip -n $ns route add 2001:db8:10::/64 dev dummy1 metric 1025\n\tip -n $ns route del 2001:db8:10::/64 dev dummy1 metric 1024\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 dev dummy1 metric 1025\" false\n\tcheck_err $? \"Route not in hardware after deleting lowest metric route\"\n\n\tlog_test \"IPv6 delete single route - replaced by single\"\n\n\tip -n $ns route del 2001:db8:10::/64 dev dummy1 metric 1025\n\n\t# Test that first route is replaced by next multipath route in the FIB\n\t# node.\n\tRET=0\n\n\tip -n $ns route add 2001:db8:10::/64 dev dummy1 metric 1024\n\tip -n $ns route add 2001:db8:10::/64 metric 1025 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route del 2001:db8:10::/64 dev dummy1 metric 1024\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1025\" false\n\tcheck_err $? \"Route not in hardware after deleting lowest metric route\"\n\n\tlog_test \"IPv6 delete single route - replaced by multipath\"\n\n\tip -n $ns route del 2001:db8:10::/64 metric 1025\n\n\t# Test deletion of a single nexthop from a multipath route.\n\tip -n $ns route add 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route del 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Route not in hardware after deleting a single nexthop\"\n\n\tlog_test \"IPv6 delete single nexthop\"\n\n\tip -n $ns route del 2001:db8:10::/64 metric 1024\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_delete_multipath_test()\n{\n\tlocal ns=$1; shift\n\n\t# Test various deletion scenarios, where an entire multipath route is\n\t# deleted from the FIB node.\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\t\tip -n $ns address add 2001:db8:$i::1/64 dev dummy$i\n\tdone\n\n\t# Test deletion of a multipath route when it is the only route in the\n\t# FIB node.\n\tRET=0\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route del 2001:db8:10::/64 metric 1024\n\n\tlog_test \"IPv6 delete sole multipath route\"\n\n\t# Test that deletion of last route does not affect the first one.\n\tRET=0\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route add 2001:db8:10::/64 metric 1025 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route del 2001:db8:10::/64 metric 1025\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"Route not in hardware after deleting higher metric route\"\n\n\tlog_test \"IPv6 delete multipath route not in hardware\"\n\n\tip -n $ns route del 2001:db8:10::/64 metric 1024\n\n\t# Test that first route is replaced by next single route in the FIB\n\t# node.\n\tRET=0\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route add 2001:db8:10::/64 dev dummy1 metric 1025\n\tip -n $ns route del 2001:db8:10::/64 metric 1024\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 dev dummy1 metric 1025\" false\n\tcheck_err $? \"Route not in hardware after deleting lowest metric route\"\n\n\tlog_test \"IPv6 delete multipath route - replaced by single\"\n\n\tip -n $ns route del 2001:db8:10::/64 dev dummy1 metric 1025\n\n\t# Test that first route is replaced by next multipath route in the FIB\n\t# node.\n\tRET=0\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route add 2001:db8:10::/64 metric 1025 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route del 2001:db8:10::/64 metric 1024\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1025\" false\n\tcheck_err $? \"Route not in hardware after deleting lowest metric route\"\n\n\tlog_test \"IPv6 delete multipath route - replaced by multipath\"\n\n\tip -n $ns route del 2001:db8:10::/64 metric 1025\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_replay_single_test()\n{\n\tlocal ns=$1; shift\n\tlocal devlink_dev=$1; shift\n\n\tRET=0\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\tdone\n\n\tip -n $ns route add 2001:db8:1::/64 dev dummy1\n\tip -n $ns route append 2001:db8:1::/64 dev dummy2\n\n\tdevlink -N $ns dev reload $devlink_dev\n\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy1\" false\n\tcheck_err $? \"First route not in hardware when should\"\n\n\tfib6_trap_check $ns \"2001:db8:1::/64 dev dummy2\" true\n\tcheck_err $? \"Second route in hardware when should not\"\n\n\tlog_test \"IPv6 routes replay - single route\"\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n\nfib_ipv6_replay_multipath_test()\n{\n\tlocal ns=$1; shift\n\tlocal devlink_dev=$1; shift\n\n\tRET=0\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link add name dummy$i type dummy\n\t\tip -n $ns link set dev dummy$i up\n\t\tip -n $ns address add 2001:db8:$i::1/64 dev dummy$i\n\tdone\n\n\tip -n $ns route add 2001:db8:10::/64 metric 1024 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\tip -n $ns route add 2001:db8:10::/64 metric 1025 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy1 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy2\n\n\tdevlink -N $ns dev reload $devlink_dev\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1024\" false\n\tcheck_err $? \"First route not in hardware when should\"\n\n\tfib6_trap_check $ns \"2001:db8:10::/64 metric 1025\" true\n\tcheck_err $? \"Second route in hardware when should not\"\n\n\tlog_test \"IPv6 routes replay - multipath route\"\n\n\tfor i in $(seq 1 2); do\n\t\tip -n $ns link del dev dummy$i\n\tdone\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}