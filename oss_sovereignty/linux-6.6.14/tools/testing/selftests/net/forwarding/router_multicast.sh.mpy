{
  "module_name": "router_multicast.sh",
  "hash_id": "f50193a51089646880be98e3af5316645cc02a7d644028db9849fbe17368694a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/router_multicast.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# +------------------+\n# | H1 (v$h1)        |\n# | 2001:db8:1::2/64 |\n# | 198.51.100.2/28  |\n# |         $h1 +    |\n# +-------------|----+\n#               |\n# +-------------|-------------------------------+\n# | SW1         |                               |\n# |        $rp1 +                               |\n# | 198.51.100.1/28                             |\n# | 2001:db8:1::1/64                            |\n# |                                             |\n# | 2001:db8:2::1/64           2001:db8:3::1/64 |\n# | 198.51.100.17/28           198.51.100.33/28 |\n# |         $rp2 +                     $rp3 +   |\n# +--------------|--------------------------|---+\n#                |                          |\n#                |                          |\n# +--------------|---+       +--------------|---+\n# | H2 (v$h2)    |   |       | H3 (v$h3)    |   |\n# |          $h2 +   |       |          $h3 +   |\n# | 198.51.100.18/28 |       | 198.51.100.34/28 |\n# | 2001:db8:2::2/64 |       | 2001:db8:3::2/64 |\n# +------------------+       +------------------+\n#\n\nALL_TESTS=\"mcast_v4 mcast_v6 rpf_v4 rpf_v6 unres_v4 unres_v6\"\nNUM_NETIFS=6\nsource lib.sh\nsource tc_common.sh\n\nrequire_command $MCD\nrequire_command $MC_CLI\ntable_name=selftests\n\nh1_create()\n{\n\tsimple_if_init $h1 198.51.100.2/28 2001:db8:1::2/64\n\n\tip route add 198.51.100.16/28 vrf v$h1 nexthop via 198.51.100.1\n\tip route add 198.51.100.32/28 vrf v$h1 nexthop via 198.51.100.1\n\n\tip route add 2001:db8:2::/64 vrf v$h1 nexthop via 2001:db8:1::1\n\tip route add 2001:db8:3::/64 vrf v$h1 nexthop via 2001:db8:1::1\n\n\ttc qdisc add dev $h1 ingress\n}\n\nh1_destroy()\n{\n\ttc qdisc del dev $h1 ingress\n\n\tip route del 2001:db8:3::/64 vrf v$h1\n\tip route del 2001:db8:2::/64 vrf v$h1\n\n\tip route del 198.51.100.32/28 vrf v$h1\n\tip route del 198.51.100.16/28 vrf v$h1\n\n\tsimple_if_fini $h1 198.51.100.2/28 2001:db8:1::2/64\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 198.51.100.18/28 2001:db8:2::2/64\n\n\tip route add 198.51.100.0/28 vrf v$h2 nexthop via 198.51.100.17\n\tip route add 198.51.100.32/28 vrf v$h2 nexthop via 198.51.100.17\n\n\tip route add 2001:db8:1::/64 vrf v$h2 nexthop via 2001:db8:2::1\n\tip route add 2001:db8:3::/64 vrf v$h2 nexthop via 2001:db8:2::1\n\n\ttc qdisc add dev $h2 ingress\n}\n\nh2_destroy()\n{\n\ttc qdisc del dev $h2 ingress\n\n\tip route del 2001:db8:3::/64 vrf v$h2\n\tip route del 2001:db8:1::/64 vrf v$h2\n\n\tip route del 198.51.100.32/28 vrf v$h2\n\tip route del 198.51.100.0/28 vrf v$h2\n\n\tsimple_if_fini $h2 198.51.100.18/28 2001:db8:2::2/64\n}\n\nh3_create()\n{\n\tsimple_if_init $h3 198.51.100.34/28 2001:db8:3::2/64\n\n\tip route add 198.51.100.0/28 vrf v$h3 nexthop via 198.51.100.33\n\tip route add 198.51.100.16/28 vrf v$h3 nexthop via 198.51.100.33\n\n\tip route add 2001:db8:1::/64 vrf v$h3 nexthop via 2001:db8:3::1\n\tip route add 2001:db8:2::/64 vrf v$h3 nexthop via 2001:db8:3::1\n\n\ttc qdisc add dev $h3 ingress\n}\n\nh3_destroy()\n{\n\ttc qdisc del dev $h3 ingress\n\n\tip route del 2001:db8:2::/64 vrf v$h3\n\tip route del 2001:db8:1::/64 vrf v$h3\n\n\tip route del 198.51.100.16/28 vrf v$h3\n\tip route del 198.51.100.0/28 vrf v$h3\n\n\tsimple_if_fini $h3 198.51.100.34/28 2001:db8:3::2/64\n}\n\nrouter_create()\n{\n\tip link set dev $rp1 up\n\tip link set dev $rp2 up\n\tip link set dev $rp3 up\n\n\tip address add 198.51.100.1/28 dev $rp1\n\tip address add 198.51.100.17/28 dev $rp2\n\tip address add 198.51.100.33/28 dev $rp3\n\n\tip address add 2001:db8:1::1/64 dev $rp1\n\tip address add 2001:db8:2::1/64 dev $rp2\n\tip address add 2001:db8:3::1/64 dev $rp3\n\n\ttc qdisc add dev $rp3 ingress\n}\n\nrouter_destroy()\n{\n\ttc qdisc del dev $rp3 ingress\n\n\tip address del 2001:db8:3::1/64 dev $rp3\n\tip address del 2001:db8:2::1/64 dev $rp2\n\tip address del 2001:db8:1::1/64 dev $rp1\n\n\tip address del 198.51.100.33/28 dev $rp3\n\tip address del 198.51.100.17/28 dev $rp2\n\tip address del 198.51.100.1/28 dev $rp1\n\n\tip link set dev $rp3 down\n\tip link set dev $rp2 down\n\tip link set dev $rp1 down\n}\n\nstart_mcd()\n{\n\tSMCROUTEDIR=\"$(mktemp -d)\"\n\n\tfor ((i = 1; i <= $NUM_NETIFS; ++i)); do\n\t\techo \"phyint ${NETIFS[p$i]} enable\" >> \\\n\t\t\t$SMCROUTEDIR/$table_name.conf\n\tdone\n\n\t$MCD -N -I $table_name -f $SMCROUTEDIR/$table_name.conf \\\n\t\t-P $SMCROUTEDIR/$table_name.pid\n}\n\nkill_mcd()\n{\n\tpkill $MCD\n\trm -rf $SMCROUTEDIR\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\trp1=${NETIFS[p2]}\n\n\trp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\trp3=${NETIFS[p5]}\n\th3=${NETIFS[p6]}\n\n\tstart_mcd\n\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\th3_create\n\n\trouter_create\n\n\tforwarding_enable\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tforwarding_restore\n\n\trouter_destroy\n\n\th3_destroy\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n\n\tkill_mcd\n}\n\ncreate_mcast_sg()\n{\n\tlocal if_name=$1; shift\n\tlocal s_addr=$1; shift\n\tlocal mcast=$1; shift\n\tlocal dest_ifs=${@}\n\n\t$MC_CLI -I $table_name add $if_name $s_addr $mcast $dest_ifs\n}\n\ndelete_mcast_sg()\n{\n\tlocal if_name=$1; shift\n\tlocal s_addr=$1; shift\n\tlocal mcast=$1; shift\n\tlocal dest_ifs=${@}\n\n        $MC_CLI -I $table_name remove $if_name $s_addr $mcast $dest_ifs\n}\n\nmcast_v4()\n{\n\t# Add two interfaces to an MC group, send a packet to the MC group and\n\t# verify packets are received on both. Then delete the route and verify\n\t# packets are no longer received.\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 122 flower \\\n\t\tdst_ip 225.1.2.3 action drop\n\ttc filter add dev $h3 ingress protocol ip pref 1 handle 133 flower \\\n\t\tdst_ip 225.1.2.3 action drop\n\n\tcreate_mcast_sg $rp1 198.51.100.2 225.1.2.3 $rp2 $rp3\n\n\t# Send frames with the corresponding L2 destination address.\n\t$MZ $h1 -c 5 -p 128 -t udp -a 00:11:22:33:44:55 -b 01:00:5e:01:02:03 \\\n\t\t-A 198.51.100.2 -B 225.1.2.3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 122 5\n\tcheck_err $? \"Multicast not received on first host\"\n\ttc_check_packets \"dev $h3 ingress\" 133 5\n\tcheck_err $? \"Multicast not received on second host\"\n\n\tdelete_mcast_sg $rp1 198.51.100.2 225.1.2.3 $rp2 $rp3\n\n\t$MZ $h1 -c 5 -p 128 -t udp -a 00:11:22:33:44:55 -b 01:00:5e:01:02:03 \\\n\t\t-A 198.51.100.2 -B 225.1.2.3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 122 5\n\tcheck_err $? \"Multicast received on host although deleted\"\n\ttc_check_packets \"dev $h3 ingress\" 133 5\n\tcheck_err $? \"Multicast received on second host although deleted\"\n\n\ttc filter del dev $h3 ingress protocol ip pref 1 handle 133 flower\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 122 flower\n\n\tlog_test \"mcast IPv4\"\n}\n\nmcast_v6()\n{\n\t# Add two interfaces to an MC group, send a packet to the MC group and\n\t# verify packets are received on both. Then delete the route and verify\n\t# packets are no longer received.\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ipv6 pref 1 handle 122 flower \\\n\t\tdst_ip ff0e::3 action drop\n\ttc filter add dev $h3 ingress protocol ipv6 pref 1 handle 133 flower \\\n\t\tdst_ip ff0e::3 action drop\n\n\tcreate_mcast_sg $rp1 2001:db8:1::2 ff0e::3 $rp2 $rp3\n\n\t# Send frames with the corresponding L2 destination address.\n\t$MZ $h1 -6 -c 5 -p 128 -t udp -a 00:11:22:33:44:55 \\\n\t\t-b 33:33:00:00:00:03 -A 2001:db8:1::2 -B ff0e::3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 122 5\n\tcheck_err $? \"Multicast not received on first host\"\n\ttc_check_packets \"dev $h3 ingress\" 133 5\n\tcheck_err $? \"Multicast not received on second host\"\n\n\tdelete_mcast_sg $rp1 2001:db8:1::2 ff0e::3 $rp2 $rp3\n\n\t$MZ $h1 -6 -c 5 -p 128 -t udp -a 00:11:22:33:44:55 \\\n\t\t-b 33:33:00:00:00:03 -A 2001:db8:1::2 -B ff0e::3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 122 5\n\tcheck_err $? \"Multicast received on first host although deleted\"\n\ttc_check_packets \"dev $h3 ingress\" 133 5\n\tcheck_err $? \"Multicast received on second host although deleted\"\n\n\ttc filter del dev $h3 ingress protocol ipv6 pref 1 handle 133 flower\n\ttc filter del dev $h2 ingress protocol ipv6 pref 1 handle 122 flower\n\n\tlog_test \"mcast IPv6\"\n}\n\nrpf_v4()\n{\n\t# Add a multicast route from first router port to the other two. Send\n\t# matching packets and test that both hosts receive them. Then, send\n\t# the same packets via the third router port and test that they do not\n\t# reach any host due to RPF check. A filter with 'skip_hw' is added to\n\t# test that devices capable of multicast routing offload trap those\n\t# packets. The filter is essentialy a NOP in other scenarios.\n\n\tRET=0\n\n\ttc filter add dev $h1 ingress protocol ip pref 1 handle 1 flower \\\n\t\tdst_ip 225.1.2.3 ip_proto udp dst_port 12345 action drop\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 1 flower \\\n\t\tdst_ip 225.1.2.3 ip_proto udp dst_port 12345 action drop\n\ttc filter add dev $h3 ingress protocol ip pref 1 handle 1 flower \\\n\t\tdst_ip 225.1.2.3 ip_proto udp dst_port 12345 action drop\n\ttc filter add dev $rp3 ingress protocol ip pref 1 handle 1 flower \\\n\t\tskip_hw dst_ip 225.1.2.3 ip_proto udp dst_port 12345 action pass\n\n\tcreate_mcast_sg $rp1 198.51.100.2 225.1.2.3 $rp2 $rp3\n\n\t$MZ $h1 -c 5 -p 128 -t udp \"ttl=10,sp=54321,dp=12345\" \\\n\t\t-a 00:11:22:33:44:55 -b 01:00:5e:01:02:03 \\\n\t\t-A 198.51.100.2 -B 225.1.2.3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 1 5\n\tcheck_err $? \"Multicast not received on first host\"\n\ttc_check_packets \"dev $h3 ingress\" 1 5\n\tcheck_err $? \"Multicast not received on second host\"\n\n\t$MZ $h3 -c 5 -p 128 -t udp \"ttl=10,sp=54321,dp=12345\" \\\n\t\t-a 00:11:22:33:44:55 -b 01:00:5e:01:02:03 \\\n\t\t-A 198.51.100.2 -B 225.1.2.3 -q\n\n\ttc_check_packets \"dev $h1 ingress\" 1 0\n\tcheck_err $? \"Multicast received on first host when should not\"\n\ttc_check_packets \"dev $h2 ingress\" 1 5\n\tcheck_err $? \"Multicast received on second host when should not\"\n\ttc_check_packets \"dev $rp3 ingress\" 1 5\n\tcheck_err $? \"Packets not trapped due to RPF check\"\n\n\tdelete_mcast_sg $rp1 198.51.100.2 225.1.2.3 $rp2 $rp3\n\n\ttc filter del dev $rp3 ingress protocol ip pref 1 handle 1 flower\n\ttc filter del dev $h3 ingress protocol ip pref 1 handle 1 flower\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 1 flower\n\ttc filter del dev $h1 ingress protocol ip pref 1 handle 1 flower\n\n\tlog_test \"RPF IPv4\"\n}\n\nrpf_v6()\n{\n\tRET=0\n\n\ttc filter add dev $h1 ingress protocol ipv6 pref 1 handle 1 flower \\\n\t\tdst_ip ff0e::3 ip_proto udp dst_port 12345 action drop\n\ttc filter add dev $h2 ingress protocol ipv6 pref 1 handle 1 flower \\\n\t\tdst_ip ff0e::3 ip_proto udp dst_port 12345 action drop\n\ttc filter add dev $h3 ingress protocol ipv6 pref 1 handle 1 flower \\\n\t\tdst_ip ff0e::3 ip_proto udp dst_port 12345 action drop\n\ttc filter add dev $rp3 ingress protocol ipv6 pref 1 handle 1 flower \\\n\t\tskip_hw dst_ip ff0e::3 ip_proto udp dst_port 12345 action pass\n\n\tcreate_mcast_sg $rp1 2001:db8:1::2 ff0e::3 $rp2 $rp3\n\n\t$MZ $h1 -6 -c 5 -p 128 -t udp \"ttl=10,sp=54321,dp=12345\" \\\n\t\t-a 00:11:22:33:44:55 -b 33:33:00:00:00:03 \\\n\t\t-A 2001:db8:1::2 -B ff0e::3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 1 5\n\tcheck_err $? \"Multicast not received on first host\"\n\ttc_check_packets \"dev $h3 ingress\" 1 5\n\tcheck_err $? \"Multicast not received on second host\"\n\n\t$MZ $h3 -6 -c 5 -p 128 -t udp \"ttl=10,sp=54321,dp=12345\" \\\n\t\t-a 00:11:22:33:44:55 -b 33:33:00:00:00:03 \\\n\t\t-A 2001:db8:1::2 -B ff0e::3 -q\n\n\ttc_check_packets \"dev $h1 ingress\" 1 0\n\tcheck_err $? \"Multicast received on first host when should not\"\n\ttc_check_packets \"dev $h2 ingress\" 1 5\n\tcheck_err $? \"Multicast received on second host when should not\"\n\ttc_check_packets \"dev $rp3 ingress\" 1 5\n\tcheck_err $? \"Packets not trapped due to RPF check\"\n\n\tdelete_mcast_sg $rp1 2001:db8:1::2 ff0e::3 $rp2 $rp3\n\n\ttc filter del dev $rp3 ingress protocol ipv6 pref 1 handle 1 flower\n\ttc filter del dev $h3 ingress protocol ipv6 pref 1 handle 1 flower\n\ttc filter del dev $h2 ingress protocol ipv6 pref 1 handle 1 flower\n\ttc filter del dev $h1 ingress protocol ipv6 pref 1 handle 1 flower\n\n\tlog_test \"RPF IPv6\"\n}\n\nunres_v4()\n{\n\t# Send a multicast packet not corresponding to an installed route,\n\t# causing the kernel to queue the packet for resolution and emit an\n\t# IGMPMSG_NOCACHE notification. smcrouted will react to this\n\t# notification by consulting its (*, G) list and installing an (S, G)\n\t# route, which will be used to forward the queued packet.\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ip pref 1 handle 1 flower \\\n\t\tdst_ip 225.1.2.3 ip_proto udp dst_port 12345 action drop\n\ttc filter add dev $h3 ingress protocol ip pref 1 handle 1 flower \\\n\t\tdst_ip 225.1.2.3 ip_proto udp dst_port 12345 action drop\n\n\t# Forwarding should fail before installing a matching (*, G).\n\t$MZ $h1 -c 1 -p 128 -t udp \"ttl=10,sp=54321,dp=12345\" \\\n\t\t-a 00:11:22:33:44:55 -b 01:00:5e:01:02:03 \\\n\t\t-A 198.51.100.2 -B 225.1.2.3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 1 0\n\tcheck_err $? \"Multicast received on first host when should not\"\n\ttc_check_packets \"dev $h3 ingress\" 1 0\n\tcheck_err $? \"Multicast received on second host when should not\"\n\n\t# Create (*, G). Will not be installed in the kernel.\n\tcreate_mcast_sg $rp1 0.0.0.0 225.1.2.3 $rp2 $rp3\n\n\t$MZ $h1 -c 1 -p 128 -t udp \"ttl=10,sp=54321,dp=12345\" \\\n\t\t-a 00:11:22:33:44:55 -b 01:00:5e:01:02:03 \\\n\t\t-A 198.51.100.2 -B 225.1.2.3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 1 1\n\tcheck_err $? \"Multicast not received on first host\"\n\ttc_check_packets \"dev $h3 ingress\" 1 1\n\tcheck_err $? \"Multicast not received on second host\"\n\n\tdelete_mcast_sg $rp1 0.0.0.0 225.1.2.3 $rp2 $rp3\n\n\ttc filter del dev $h3 ingress protocol ip pref 1 handle 1 flower\n\ttc filter del dev $h2 ingress protocol ip pref 1 handle 1 flower\n\n\tlog_test \"Unresolved queue IPv4\"\n}\n\nunres_v6()\n{\n\t# Send a multicast packet not corresponding to an installed route,\n\t# causing the kernel to queue the packet for resolution and emit an\n\t# MRT6MSG_NOCACHE notification. smcrouted will react to this\n\t# notification by consulting its (*, G) list and installing an (S, G)\n\t# route, which will be used to forward the queued packet.\n\n\tRET=0\n\n\ttc filter add dev $h2 ingress protocol ipv6 pref 1 handle 1 flower \\\n\t\tdst_ip ff0e::3 ip_proto udp dst_port 12345 action drop\n\ttc filter add dev $h3 ingress protocol ipv6 pref 1 handle 1 flower \\\n\t\tdst_ip ff0e::3 ip_proto udp dst_port 12345 action drop\n\n\t# Forwarding should fail before installing a matching (*, G).\n\t$MZ $h1 -6 -c 1 -p 128 -t udp \"ttl=10,sp=54321,dp=12345\" \\\n\t\t-a 00:11:22:33:44:55 -b 33:33:00:00:00:03 \\\n\t\t-A 2001:db8:1::2 -B ff0e::3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 1 0\n\tcheck_err $? \"Multicast received on first host when should not\"\n\ttc_check_packets \"dev $h3 ingress\" 1 0\n\tcheck_err $? \"Multicast received on second host when should not\"\n\n\t# Create (*, G). Will not be installed in the kernel.\n\tcreate_mcast_sg $rp1 :: ff0e::3 $rp2 $rp3\n\n\t$MZ $h1 -6 -c 1 -p 128 -t udp \"ttl=10,sp=54321,dp=12345\" \\\n\t\t-a 00:11:22:33:44:55 -b 33:33:00:00:00:03 \\\n\t\t-A 2001:db8:1::2 -B ff0e::3 -q\n\n\ttc_check_packets \"dev $h2 ingress\" 1 1\n\tcheck_err $? \"Multicast not received on first host\"\n\ttc_check_packets \"dev $h3 ingress\" 1 1\n\tcheck_err $? \"Multicast not received on second host\"\n\n\tdelete_mcast_sg $rp1 :: ff0e::3 $rp2 $rp3\n\n\ttc filter del dev $h3 ingress protocol ipv6 pref 1 handle 1 flower\n\ttc filter del dev $h2 ingress protocol ipv6 pref 1 handle 1 flower\n\n\tlog_test \"Unresolved queue IPv6\"\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}