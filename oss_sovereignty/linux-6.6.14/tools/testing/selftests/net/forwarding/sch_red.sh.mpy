{
  "module_name": "sch_red.sh",
  "hash_id": "ccdcaf057d7f51c43e841d153ba55ae84ce5f00e373c9520fa8faa95b935589b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/sch_red.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# This test sends one stream of traffic from H1 through a TBF shaper, to a RED\n# within TBF shaper on $swp3. The two shapers have the same configuration, and\n# thus the resulting stream should fill all available bandwidth on the latter\n# shaper. A second stream is sent from H2 also via $swp3, and used to inject\n# additional traffic. Since all available bandwidth is taken, this traffic has\n# to go to backlog.\n#\n# +--------------------------+                     +--------------------------+\n# | H1                       |                     | H2                       |\n# |     + $h1                |                     |     + $h2                |\n# |     | 192.0.2.1/28       |                     |     | 192.0.2.2/28       |\n# |     | TBF 10Mbps         |                     |     |                    |\n# +-----|--------------------+                     +-----|--------------------+\n#       |                                                |\n# +-----|------------------------------------------------|--------------------+\n# | SW  |                                                |                    |\n# |  +--|------------------------------------------------|----------------+   |\n# |  |  + $swp1                                          + $swp2          |   |\n# |  |                               BR                                   |   |\n# |  |                                                                    |   |\n# |  |                                + $swp3                             |   |\n# |  |                                | TBF 10Mbps / RED                  |   |\n# |  +--------------------------------|-----------------------------------+   |\n# |                                   |                                       |\n# +-----------------------------------|---------------------------------------+\n#                                     |\n#                               +-----|--------------------+\n#\t\t\t        | H3  |                    |\n#\t\t\t        |     + $h1                |\n#\t\t\t        |       192.0.2.3/28       |\n#\t\t\t        |                          |\n#\t\t\t        +--------------------------+\n\nALL_TESTS=\"\n\tping_ipv4\n\tecn_test\n\tecn_nodrop_test\n\tred_test\n\tred_qevent_test\n\tecn_qevent_test\n\"\n\nNUM_NETIFS=6\nCHECK_TC=\"yes\"\nsource lib.sh\n\nBACKLOG=30000\nPKTSZ=1400\n\nh1_create()\n{\n\tsimple_if_init $h1 192.0.2.1/28\n\tmtu_set $h1 10000\n\ttc qdisc replace dev $h1 root handle 1: tbf \\\n\t   rate 10Mbit burst 10K limit 1M\n}\n\nh1_destroy()\n{\n\ttc qdisc del dev $h1 root\n\tmtu_restore $h1\n\tsimple_if_fini $h1 192.0.2.1/28\n}\n\nh2_create()\n{\n\tsimple_if_init $h2 192.0.2.2/28\n\tmtu_set $h2 10000\n}\n\nh2_destroy()\n{\n\tmtu_restore $h2\n\tsimple_if_fini $h2 192.0.2.2/28\n}\n\nh3_create()\n{\n\tsimple_if_init $h3 192.0.2.3/28\n\tmtu_set $h3 10000\n}\n\nh3_destroy()\n{\n\tmtu_restore $h3\n\tsimple_if_fini $h3 192.0.2.3/28\n}\n\nswitch_create()\n{\n\tip link add dev br up type bridge\n\tip link set dev $swp1 up master br\n\tip link set dev $swp2 up master br\n\tip link set dev $swp3 up master br\n\n\tmtu_set $swp1 10000\n\tmtu_set $swp2 10000\n\tmtu_set $swp3 10000\n\n\ttc qdisc replace dev $swp3 root handle 1: tbf \\\n\t   rate 10Mbit burst 10K limit 1M\n\tip link add name _drop_test up type dummy\n}\n\nswitch_destroy()\n{\n\tip link del dev _drop_test\n\ttc qdisc del dev $swp3 root\n\n\tmtu_restore $h3\n\tmtu_restore $h2\n\tmtu_restore $h1\n\n\tip link set dev $swp3 down nomaster\n\tip link set dev $swp2 down nomaster\n\tip link set dev $swp1 down nomaster\n\tip link del dev br\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\th2=${NETIFS[p3]}\n\tswp2=${NETIFS[p4]}\n\n\tswp3=${NETIFS[p5]}\n\th3=${NETIFS[p6]}\n\n\th3_mac=$(mac_get $h3)\n\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\th3_create\n\tswitch_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tswitch_destroy\n\th3_destroy\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n}\n\nping_ipv4()\n{\n\tping_test $h1 192.0.2.3 \" from host 1\"\n\tping_test $h2 192.0.2.3 \" from host 2\"\n}\n\nget_qdisc_backlog()\n{\n\tqdisc_stats_get $swp3 11: .backlog\n}\n\nget_nmarked()\n{\n\tqdisc_stats_get $swp3 11: .marked\n}\n\nget_qdisc_npackets()\n{\n\tqdisc_stats_get $swp3 11: .packets\n}\n\nget_nmirrored()\n{\n\tlink_stats_get _drop_test tx packets\n}\n\nsend_packets()\n{\n\tlocal proto=$1; shift\n\tlocal pkts=$1; shift\n\n\t$MZ $h2 -p $PKTSZ -a own -b $h3_mac -A 192.0.2.2 -B 192.0.2.3 -t $proto -q -c $pkts \"$@\"\n}\n\n# This sends traffic in an attempt to build a backlog of $size. Returns 0 on\n# success. After 10 failed attempts it bails out and returns 1. It dumps the\n# backlog size to stdout.\nbuild_backlog()\n{\n\tlocal size=$1; shift\n\tlocal proto=$1; shift\n\n\tlocal i=0\n\n\twhile :; do\n\t\tlocal cur=$(get_qdisc_backlog)\n\t\tlocal diff=$((size - cur))\n\t\tlocal pkts=$(((diff + PKTSZ - 1) / PKTSZ))\n\n\t\tif ((cur >= size)); then\n\t\t\techo $cur\n\t\t\treturn 0\n\t\telif ((i++ > 10)); then\n\t\t\techo $cur\n\t\t\treturn 1\n\t\tfi\n\n\t\tsend_packets $proto $pkts \"$@\"\n\t\tsleep 1\n\tdone\n}\n\ncheck_marking()\n{\n\tlocal cond=$1; shift\n\n\tlocal npackets_0=$(get_qdisc_npackets)\n\tlocal nmarked_0=$(get_nmarked)\n\tsleep 5\n\tlocal npackets_1=$(get_qdisc_npackets)\n\tlocal nmarked_1=$(get_nmarked)\n\n\tlocal nmarked_d=$((nmarked_1 - nmarked_0))\n\tlocal npackets_d=$((npackets_1 - npackets_0))\n\tlocal pct=$((100 * nmarked_d / npackets_d))\n\n\techo $pct\n\t((pct $cond))\n}\n\ncheck_mirroring()\n{\n\tlocal cond=$1; shift\n\n\tlocal npackets_0=$(get_qdisc_npackets)\n\tlocal nmirrored_0=$(get_nmirrored)\n\tsleep 5\n\tlocal npackets_1=$(get_qdisc_npackets)\n\tlocal nmirrored_1=$(get_nmirrored)\n\n\tlocal nmirrored_d=$((nmirrored_1 - nmirrored_0))\n\tlocal npackets_d=$((npackets_1 - npackets_0))\n\tlocal pct=$((100 * nmirrored_d / npackets_d))\n\n\techo $pct\n\t((pct $cond))\n}\n\necn_test_common()\n{\n\tlocal name=$1; shift\n\tlocal limit=$1; shift\n\tlocal backlog\n\tlocal pct\n\n\t# Build the below-the-limit backlog using UDP. We could use TCP just\n\t# fine, but this way we get a proof that UDP is accepted when queue\n\t# length is below the limit. The main stream is using TCP, and if the\n\t# limit is misconfigured, we would see this traffic being ECN marked.\n\tRET=0\n\tbacklog=$(build_backlog $((2 * limit / 3)) udp)\n\tcheck_err $? \"Could not build the requested backlog\"\n\tpct=$(check_marking \"== 0\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% marked packets, expected == 0.\"\n\tlog_test \"$name backlog < limit\"\n\n\t# Now push TCP, because non-TCP traffic would be early-dropped after the\n\t# backlog crosses the limit, and we want to make sure that the backlog\n\t# is above the limit.\n\tRET=0\n\tbacklog=$(build_backlog $((3 * limit / 2)) tcp tos=0x01)\n\tcheck_err $? \"Could not build the requested backlog\"\n\tpct=$(check_marking \">= 95\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% marked packets, expected >= 95.\"\n\tlog_test \"$name backlog > limit\"\n}\n\ndo_ecn_test()\n{\n\tlocal limit=$1; shift\n\tlocal name=ECN\n\n\t$MZ $h1 -p $PKTSZ -A 192.0.2.1 -B 192.0.2.3 -c 0 \\\n\t\t-a own -b $h3_mac -t tcp -q tos=0x01 &\n\tsleep 1\n\n\tecn_test_common \"$name\" $limit\n\n\t# Up there we saw that UDP gets accepted when backlog is below the\n\t# limit. Now that it is above, it should all get dropped, and backlog\n\t# building should fail.\n\tRET=0\n\tbuild_backlog $((2 * limit)) udp >/dev/null\n\tcheck_fail $? \"UDP traffic went into backlog instead of being early-dropped\"\n\tlog_test \"$name backlog > limit: UDP early-dropped\"\n\n\tstop_traffic\n\tsleep 1\n}\n\ndo_ecn_nodrop_test()\n{\n\tlocal limit=$1; shift\n\tlocal name=\"ECN nodrop\"\n\n\t$MZ $h1 -p $PKTSZ -A 192.0.2.1 -B 192.0.2.3 -c 0 \\\n\t\t-a own -b $h3_mac -t tcp -q tos=0x01 &\n\tsleep 1\n\n\tecn_test_common \"$name\" $limit\n\n\t# Up there we saw that UDP gets accepted when backlog is below the\n\t# limit. Now that it is above, in nodrop mode, make sure it goes to\n\t# backlog as well.\n\tRET=0\n\tbuild_backlog $((2 * limit)) udp >/dev/null\n\tcheck_err $? \"UDP traffic was early-dropped instead of getting into backlog\"\n\tlog_test \"$name backlog > limit: UDP not dropped\"\n\n\tstop_traffic\n\tsleep 1\n}\n\ndo_red_test()\n{\n\tlocal limit=$1; shift\n\tlocal backlog\n\tlocal pct\n\n\t# Use ECN-capable TCP to verify there's no marking even though the queue\n\t# is above limit.\n\t$MZ $h1 -p $PKTSZ -A 192.0.2.1 -B 192.0.2.3 -c 0 \\\n\t\t-a own -b $h3_mac -t tcp -q tos=0x01 &\n\n\t# Pushing below the queue limit should work.\n\tRET=0\n\tbacklog=$(build_backlog $((2 * limit / 3)) tcp tos=0x01)\n\tcheck_err $? \"Could not build the requested backlog\"\n\tpct=$(check_marking \"== 0\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% marked packets, expected == 0.\"\n\tlog_test \"RED backlog < limit\"\n\n\t# Pushing above should not.\n\tRET=0\n\tbacklog=$(build_backlog $((3 * limit / 2)) tcp tos=0x01)\n\tcheck_fail $? \"Traffic went into backlog instead of being early-dropped\"\n\tpct=$(check_marking \"== 0\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% marked packets, expected == 0.\"\n\tlog_test \"RED backlog > limit\"\n\n\tstop_traffic\n\tsleep 1\n}\n\ndo_red_qevent_test()\n{\n\tlocal limit=$1; shift\n\tlocal backlog\n\tlocal base\n\tlocal now\n\tlocal pct\n\n\tRET=0\n\n\t$MZ $h1 -p $PKTSZ -A 192.0.2.1 -B 192.0.2.3 -c 0 \\\n\t\t-a own -b $h3_mac -t udp -q &\n\tsleep 1\n\n\ttc filter add block 10 pref 1234 handle 102 matchall skip_hw \\\n\t   action mirred egress mirror dev _drop_test\n\n\t# Push to the queue until it's at the limit. The configured limit is\n\t# rounded by the qdisc, so this is the best we can do to get to the real\n\t# limit.\n\tbuild_backlog $((3 * limit / 2)) udp >/dev/null\n\n\tbase=$(get_nmirrored)\n\tsend_packets udp 100\n\tsleep 1\n\tnow=$(get_nmirrored)\n\t((now >= base + 100))\n\tcheck_err $? \"Dropped packets not observed: 100 expected, $((now - base)) seen\"\n\n\ttc filter del block 10 pref 1234 handle 102 matchall\n\n\tbase=$(get_nmirrored)\n\tsend_packets udp 100\n\tsleep 1\n\tnow=$(get_nmirrored)\n\t((now == base))\n\tcheck_err $? \"Dropped packets still observed: 0 expected, $((now - base)) seen\"\n\n\tlog_test \"RED early_dropped packets mirrored\"\n\n\tstop_traffic\n\tsleep 1\n}\n\ndo_ecn_qevent_test()\n{\n\tlocal limit=$1; shift\n\tlocal name=ECN\n\n\tRET=0\n\n\t$MZ $h1 -p $PKTSZ -A 192.0.2.1 -B 192.0.2.3 -c 0 \\\n\t\t-a own -b $h3_mac -t tcp -q tos=0x01 &\n\tsleep 1\n\n\ttc filter add block 10 pref 1234 handle 102 matchall skip_hw \\\n\t   action mirred egress mirror dev _drop_test\n\n\tbacklog=$(build_backlog $((2 * limit / 3)) tcp tos=0x01)\n\tcheck_err $? \"Could not build the requested backlog\"\n\tpct=$(check_mirroring \"== 0\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% mirrored packets, expected == 0.\"\n\n\tbacklog=$(build_backlog $((3 * limit / 2)) tcp tos=0x01)\n\tcheck_err $? \"Could not build the requested backlog\"\n\tpct=$(check_mirroring \">= 95\")\n\tcheck_err $? \"backlog $backlog / $limit Got $pct% mirrored packets, expected >= 95.\"\n\n\ttc filter del block 10 pref 1234 handle 102 matchall\n\n\tlog_test \"ECN marked packets mirrored\"\n\n\tstop_traffic\n\tsleep 1\n}\n\ninstall_qdisc()\n{\n\tlocal -a args=(\"$@\")\n\n\ttc qdisc replace dev $swp3 parent 1:1 handle 11: red \\\n\t   limit 1M avpkt $PKTSZ probability 1 \\\n\t   min $BACKLOG max $((BACKLOG + 1)) burst 38 \"${args[@]}\"\n\tsleep 1\n}\n\nuninstall_qdisc()\n{\n\ttc qdisc del dev $swp3 parent 1:1\n}\n\necn_test()\n{\n\tinstall_qdisc ecn\n\tdo_ecn_test $BACKLOG\n\tuninstall_qdisc\n}\n\necn_nodrop_test()\n{\n\tinstall_qdisc ecn nodrop\n\tdo_ecn_nodrop_test $BACKLOG\n\tuninstall_qdisc\n}\n\nred_test()\n{\n\tinstall_qdisc\n\tdo_red_test $BACKLOG\n\tuninstall_qdisc\n}\n\nred_qevent_test()\n{\n\tinstall_qdisc qevent early_drop block 10\n\tdo_red_qevent_test $BACKLOG\n\tuninstall_qdisc\n}\n\necn_qevent_test()\n{\n\tinstall_qdisc ecn qevent mark block 10\n\tdo_ecn_qevent_test $BACKLOG\n\tuninstall_qdisc\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\n\ntests_run\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}