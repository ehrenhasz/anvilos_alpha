{
  "module_name": "sch_tbf_core.sh",
  "hash_id": "a4a6adbbb45a402739fcaaf05fbf43e9f2025fdd765294fa08db33cb6b0512fb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/sch_tbf_core.sh",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n\n# This test sends a stream of traffic from H1 through a switch, to H2. On the\n# egress port from the switch ($swp2), a shaper is installed. The test verifies\n# that the rates on the port match the configured shaper.\n#\n# In order to test per-class shaping, $swp2 actually contains TBF under PRIO or\n# ETS, with two different configurations. Traffic is prioritized using 802.1p.\n#\n# +-------------------------------------------+\n# | H1                                        |\n# |     + $h1.10                  $h1.11 +    |\n# |     | 192.0.2.1/28     192.0.2.17/28 |    |\n# |     |                                |    |\n# |     \\______________    _____________/     |\n# |                    \\ /                    |\n# |                     + $h1                 |\n# +---------------------|---------------------+\n#                       |\n# +---------------------|---------------------+\n# | SW                  + $swp1               |\n# |     _______________/ \\_______________     |\n# |    /                                 \\    |\n# |  +-|--------------+   +--------------|-+  |\n# |  | + $swp1.10     |   |     $swp1.11 + |  |\n# |  |                |   |                |  |\n# |  |     BR10       |   |       BR11     |  |\n# |  |                |   |                |  |\n# |  | + $swp2.10     |   |     $swp2.11 + |  |\n# |  +-|--------------+   +--------------|-+  |\n# |    \\_______________   ______________/     |\n# |                    \\ /                    |\n# |                     + $swp2               |\n# +---------------------|---------------------+\n#                       |\n# +---------------------|---------------------+\n# | H2                  + $h2                 |\n# |      ______________/ \\______________      |\n# |     /                               \\     |\n# |     |                               |     |\n# |     + $h2.10                 $h2.11 +     |\n# |       192.0.2.2/28    192.0.2.18/28       |\n# +-------------------------------------------+\n\nNUM_NETIFS=4\nCHECK_TC=\"yes\"\nsource $lib_dir/lib.sh\n\nipaddr()\n{\n\tlocal host=$1; shift\n\tlocal vlan=$1; shift\n\n\techo 192.0.2.$((16 * (vlan - 10) + host))\n}\n\nhost_create()\n{\n\tlocal dev=$1; shift\n\tlocal host=$1; shift\n\n\tsimple_if_init $dev\n\tmtu_set $dev 10000\n\n\tvlan_create $dev 10 v$dev $(ipaddr $host 10)/28\n\tip link set dev $dev.10 type vlan egress 0:0\n\n\tvlan_create $dev 11 v$dev $(ipaddr $host 11)/28\n\tip link set dev $dev.11 type vlan egress 0:1\n}\n\nhost_destroy()\n{\n\tlocal dev=$1; shift\n\n\tvlan_destroy $dev 11\n\tvlan_destroy $dev 10\n\tmtu_restore $dev\n\tsimple_if_fini $dev\n}\n\nh1_create()\n{\n\thost_create $h1 1\n}\n\nh1_destroy()\n{\n\thost_destroy $h1\n}\n\nh2_create()\n{\n\thost_create $h2 2\n\n\ttc qdisc add dev $h2 clsact\n\ttc filter add dev $h2 ingress pref 1010 prot 802.1q \\\n\t   flower $TCFLAGS vlan_id 10 action pass\n\ttc filter add dev $h2 ingress pref 1011 prot 802.1q \\\n\t   flower $TCFLAGS vlan_id 11 action pass\n}\n\nh2_destroy()\n{\n\ttc qdisc del dev $h2 clsact\n\thost_destroy $h2\n}\n\nswitch_create()\n{\n\tlocal intf\n\tlocal vlan\n\n\tip link add dev br10 type bridge\n\tip link add dev br11 type bridge\n\n\tfor intf in $swp1 $swp2; do\n\t\tip link set dev $intf up\n\t\tmtu_set $intf 10000\n\n\t\tfor vlan in 10 11; do\n\t\t\tvlan_create $intf $vlan\n\t\t\tip link set dev $intf.$vlan master br$vlan\n\t\t\tip link set dev $intf.$vlan up\n\t\tdone\n\tdone\n\n\tfor vlan in 10 11; do\n\t\tip link set dev $swp1.$vlan type vlan ingress 0:0 1:1\n\tdone\n\n\tip link set dev br10 up\n\tip link set dev br11 up\n}\n\nswitch_destroy()\n{\n\tlocal intf\n\tlocal vlan\n\n\t# A test may have been interrupted mid-run, with Qdisc installed. Delete\n\t# it here.\n\ttc qdisc del dev $swp2 root 2>/dev/null\n\n\tip link set dev br11 down\n\tip link set dev br10 down\n\n\tfor intf in $swp2 $swp1; do\n\t\tfor vlan in 11 10; do\n\t\t\tip link set dev $intf.$vlan down\n\t\t\tip link set dev $intf.$vlan nomaster\n\t\t\tvlan_destroy $intf $vlan\n\t\tdone\n\n\t\tmtu_restore $intf\n\t\tip link set dev $intf down\n\tdone\n\n\tip link del dev br11\n\tip link del dev br10\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\tswp3=${NETIFS[p5]}\n\th3=${NETIFS[p6]}\n\n\tswp4=${NETIFS[p7]}\n\tswp5=${NETIFS[p8]}\n\n\th2_mac=$(mac_get $h2)\n\n\tvrf_prepare\n\n\th1_create\n\th2_create\n\tswitch_create\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tswitch_destroy\n\th2_destroy\n\th1_destroy\n\n\tvrf_cleanup\n}\n\nping_ipv4()\n{\n\tping_test $h1.10 $(ipaddr 2 10) \" vlan 10\"\n\tping_test $h1.11 $(ipaddr 2 11) \" vlan 11\"\n}\n\ntbf_get_counter()\n{\n\tlocal vlan=$1; shift\n\n\ttc_rule_stats_get $h2 10$vlan ingress .bytes\n}\n\ndo_tbf_test()\n{\n\tlocal vlan=$1; shift\n\tlocal mbit=$1; shift\n\n\tstart_traffic $h1.$vlan $(ipaddr 1 $vlan) $(ipaddr 2 $vlan) $h2_mac\n\tsleep 5 # Wait for the burst to dwindle\n\n\tlocal t2=$(busywait_for_counter 1000 +1 tbf_get_counter $vlan)\n\tsleep 10\n\tlocal t3=$(tbf_get_counter $vlan)\n\tstop_traffic\n\n\tRET=0\n\n\t# Note: TBF uses 10^6 Mbits, not 2^20 ones.\n\tlocal er=$((mbit * 1000 * 1000))\n\tlocal nr=$(rate $t2 $t3 10)\n\tlocal nr_pct=$((100 * (nr - er) / er))\n\t((-5 <= nr_pct && nr_pct <= 5))\n\tcheck_err $? \"Expected rate $(humanize $er), got $(humanize $nr), which is $nr_pct% off. Required accuracy is +-5%.\"\n\n\tlog_test \"TC $((vlan - 10)): TBF rate ${mbit}Mbit\"\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}