{
  "module_name": "lib.sh",
  "hash_id": "a0f34c6c858a2f8f960188c5a004050a3a33816ce977ca308d9253f456d254e6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/lib.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n##############################################################################\n# Defines\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\n# Can be overridden by the configuration file.\nPING=${PING:=ping}\nPING6=${PING6:=ping6}\nMZ=${MZ:=mausezahn}\nARPING=${ARPING:=arping}\nTEAMD=${TEAMD:=teamd}\nWAIT_TIME=${WAIT_TIME:=5}\nPAUSE_ON_FAIL=${PAUSE_ON_FAIL:=no}\nPAUSE_ON_CLEANUP=${PAUSE_ON_CLEANUP:=no}\nNETIF_TYPE=${NETIF_TYPE:=veth}\nNETIF_CREATE=${NETIF_CREATE:=yes}\nMCD=${MCD:=smcrouted}\nMC_CLI=${MC_CLI:=smcroutectl}\nPING_COUNT=${PING_COUNT:=10}\nPING_TIMEOUT=${PING_TIMEOUT:=5}\nWAIT_TIMEOUT=${WAIT_TIMEOUT:=20}\nINTERFACE_TIMEOUT=${INTERFACE_TIMEOUT:=600}\nLOW_AGEING_TIME=${LOW_AGEING_TIME:=1000}\nREQUIRE_JQ=${REQUIRE_JQ:=yes}\nREQUIRE_MZ=${REQUIRE_MZ:=yes}\nREQUIRE_MTOOLS=${REQUIRE_MTOOLS:=no}\nSTABLE_MAC_ADDRS=${STABLE_MAC_ADDRS:=no}\nTCPDUMP_EXTRA_FLAGS=${TCPDUMP_EXTRA_FLAGS:=}\nTROUTE6=${TROUTE6:=traceroute6}\n\nrelative_path=\"${BASH_SOURCE%/*}\"\nif [[ \"$relative_path\" == \"${BASH_SOURCE}\" ]]; then\n\trelative_path=\".\"\nfi\n\nif [[ -f $relative_path/forwarding.config ]]; then\n\tsource \"$relative_path/forwarding.config\"\nfi\n\n##############################################################################\n# Sanity checks\n\ncheck_tc_version()\n{\n\ttc -j &> /dev/null\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: iproute2 too old; tc is missing JSON support\"\n\t\texit $ksft_skip\n\tfi\n}\n\n# Old versions of tc don't understand \"mpls_uc\"\ncheck_tc_mpls_support()\n{\n\tlocal dev=$1; shift\n\n\ttc filter add dev $dev ingress protocol mpls_uc pref 1 handle 1 \\\n\t\tmatchall action pipe &> /dev/null\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: iproute2 too old; tc is missing MPLS support\"\n\t\treturn $ksft_skip\n\tfi\n\ttc filter del dev $dev ingress protocol mpls_uc pref 1 handle 1 \\\n\t\tmatchall\n}\n\n# Old versions of tc produce invalid json output for mpls lse statistics\ncheck_tc_mpls_lse_stats()\n{\n\tlocal dev=$1; shift\n\tlocal ret;\n\n\ttc filter add dev $dev ingress protocol mpls_uc pref 1 handle 1 \\\n\t\tflower mpls lse depth 2                                 \\\n\t\taction continue &> /dev/null\n\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: iproute2 too old; tc-flower is missing extended MPLS support\"\n\t\treturn $ksft_skip\n\tfi\n\n\ttc -j filter show dev $dev ingress protocol mpls_uc | jq . &> /dev/null\n\tret=$?\n\ttc filter del dev $dev ingress protocol mpls_uc pref 1 handle 1 \\\n\t\tflower\n\n\tif [[ $ret -ne 0 ]]; then\n\t\techo \"SKIP: iproute2 too old; tc-flower produces invalid json output for extended MPLS filters\"\n\t\treturn $ksft_skip\n\tfi\n}\n\ncheck_tc_shblock_support()\n{\n\ttc filter help 2>&1 | grep block &> /dev/null\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: iproute2 too old; tc is missing shared block support\"\n\t\texit $ksft_skip\n\tfi\n}\n\ncheck_tc_chain_support()\n{\n\ttc help 2>&1|grep chain &> /dev/null\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: iproute2 too old; tc is missing chain support\"\n\t\texit $ksft_skip\n\tfi\n}\n\ncheck_tc_action_hw_stats_support()\n{\n\ttc actions help 2>&1 | grep -q hw_stats\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: iproute2 too old; tc is missing action hw_stats support\"\n\t\texit $ksft_skip\n\tfi\n}\n\ncheck_tc_fp_support()\n{\n\ttc qdisc add dev lo mqprio help 2>&1 | grep -q \"fp \"\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: iproute2 too old; tc is missing frame preemption support\"\n\t\texit $ksft_skip\n\tfi\n}\n\ncheck_ethtool_lanes_support()\n{\n\tethtool --help 2>&1| grep lanes &> /dev/null\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: ethtool too old; it is missing lanes support\"\n\t\texit $ksft_skip\n\tfi\n}\n\ncheck_ethtool_mm_support()\n{\n\tethtool --help 2>&1| grep -- '--show-mm' &> /dev/null\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: ethtool too old; it is missing MAC Merge layer support\"\n\t\texit $ksft_skip\n\tfi\n}\n\ncheck_locked_port_support()\n{\n\tif ! bridge -d link show | grep -q \" locked\"; then\n\t\techo \"SKIP: iproute2 too old; Locked port feature not supported.\"\n\t\treturn $ksft_skip\n\tfi\n}\n\ncheck_port_mab_support()\n{\n\tif ! bridge -d link show | grep -q \"mab\"; then\n\t\techo \"SKIP: iproute2 too old; MacAuth feature not supported.\"\n\t\treturn $ksft_skip\n\tfi\n}\n\nskip_on_veth()\n{\n\tlocal kind=$(ip -j -d link show dev ${NETIFS[p1]} |\n\t\tjq -r '.[].linkinfo.info_kind')\n\n\tif [[ $kind == veth ]]; then\n\t\techo \"SKIP: Test cannot be run with veth pairs\"\n\t\texit $ksft_skip\n\tfi\n}\n\nif [[ \"$(id -u)\" -ne 0 ]]; then\n\techo \"SKIP: need root privileges\"\n\texit $ksft_skip\nfi\n\nif [[ \"$CHECK_TC\" = \"yes\" ]]; then\n\tcheck_tc_version\nfi\n\nrequire_command()\n{\n\tlocal cmd=$1; shift\n\n\tif [[ ! -x \"$(command -v \"$cmd\")\" ]]; then\n\t\techo \"SKIP: $cmd not installed\"\n\t\texit $ksft_skip\n\tfi\n}\n\nif [[ \"$REQUIRE_JQ\" = \"yes\" ]]; then\n\trequire_command jq\nfi\nif [[ \"$REQUIRE_MZ\" = \"yes\" ]]; then\n\trequire_command $MZ\nfi\nif [[ \"$REQUIRE_MTOOLS\" = \"yes\" ]]; then\n\t# https://github.com/vladimiroltean/mtools/\n\t# patched for IPv6 support\n\trequire_command msend\n\trequire_command mreceive\nfi\n\nif [[ ! -v NUM_NETIFS ]]; then\n\techo \"SKIP: importer does not define \\\"NUM_NETIFS\\\"\"\n\texit $ksft_skip\nfi\n\n##############################################################################\n# Command line options handling\n\ncount=0\n\nwhile [[ $# -gt 0 ]]; do\n\tif [[ \"$count\" -eq \"0\" ]]; then\n\t\tunset NETIFS\n\t\tdeclare -A NETIFS\n\tfi\n\tcount=$((count + 1))\n\tNETIFS[p$count]=\"$1\"\n\tshift\ndone\n\n##############################################################################\n# Network interfaces configuration\n\ncreate_netif_veth()\n{\n\tlocal i\n\n\tfor ((i = 1; i <= NUM_NETIFS; ++i)); do\n\t\tlocal j=$((i+1))\n\n\t\tif [ -z ${NETIFS[p$i]} ]; then\n\t\t\techo \"SKIP: Cannot create interface. Name not specified\"\n\t\t\texit $ksft_skip\n\t\tfi\n\n\t\tip link show dev ${NETIFS[p$i]} &> /dev/null\n\t\tif [[ $? -ne 0 ]]; then\n\t\t\tip link add ${NETIFS[p$i]} type veth \\\n\t\t\t\tpeer name ${NETIFS[p$j]}\n\t\t\tif [[ $? -ne 0 ]]; then\n\t\t\t\techo \"Failed to create netif\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\tfi\n\t\ti=$j\n\tdone\n}\n\ncreate_netif()\n{\n\tcase \"$NETIF_TYPE\" in\n\tveth) create_netif_veth\n\t      ;;\n\t*) echo \"Can not create interfaces of type \\'$NETIF_TYPE\\'\"\n\t   exit 1\n\t   ;;\n\tesac\n}\n\ndeclare -A MAC_ADDR_ORIG\nmac_addr_prepare()\n{\n\tlocal new_addr=\n\tlocal dev=\n\n\tfor ((i = 1; i <= NUM_NETIFS; ++i)); do\n\t\tdev=${NETIFS[p$i]}\n\t\tnew_addr=$(printf \"00:01:02:03:04:%02x\" $i)\n\n\t\tMAC_ADDR_ORIG[\"$dev\"]=$(ip -j link show dev $dev | jq -e '.[].address')\n\t\t# Strip quotes\n\t\tMAC_ADDR_ORIG[\"$dev\"]=${MAC_ADDR_ORIG[\"$dev\"]//\\\"/}\n\t\tip link set dev $dev address $new_addr\n\tdone\n}\n\nmac_addr_restore()\n{\n\tlocal dev=\n\n\tfor ((i = 1; i <= NUM_NETIFS; ++i)); do\n\t\tdev=${NETIFS[p$i]}\n\t\tip link set dev $dev address ${MAC_ADDR_ORIG[\"$dev\"]}\n\tdone\n}\n\nif [[ \"$NETIF_CREATE\" = \"yes\" ]]; then\n\tcreate_netif\nfi\n\nif [[ \"$STABLE_MAC_ADDRS\" = \"yes\" ]]; then\n\tmac_addr_prepare\nfi\n\nfor ((i = 1; i <= NUM_NETIFS; ++i)); do\n\tip link show dev ${NETIFS[p$i]} &> /dev/null\n\tif [[ $? -ne 0 ]]; then\n\t\techo \"SKIP: could not find all required interfaces\"\n\t\texit $ksft_skip\n\tfi\ndone\n\n##############################################################################\n# Helpers\n\n# Exit status to return at the end. Set in case one of the tests fails.\nEXIT_STATUS=0\n# Per-test return value. Clear at the beginning of each test.\nRET=0\n\ncheck_err()\n{\n\tlocal err=$1\n\tlocal msg=$2\n\n\tif [[ $RET -eq 0 && $err -ne 0 ]]; then\n\t\tRET=$err\n\t\tretmsg=$msg\n\tfi\n}\n\ncheck_fail()\n{\n\tlocal err=$1\n\tlocal msg=$2\n\n\tif [[ $RET -eq 0 && $err -eq 0 ]]; then\n\t\tRET=1\n\t\tretmsg=$msg\n\tfi\n}\n\ncheck_err_fail()\n{\n\tlocal should_fail=$1; shift\n\tlocal err=$1; shift\n\tlocal what=$1; shift\n\n\tif ((should_fail)); then\n\t\tcheck_fail $err \"$what succeeded, but should have failed\"\n\telse\n\t\tcheck_err $err \"$what failed\"\n\tfi\n}\n\nlog_test()\n{\n\tlocal test_name=$1\n\tlocal opt_str=$2\n\n\tif [[ $# -eq 2 ]]; then\n\t\topt_str=\"($opt_str)\"\n\tfi\n\n\tif [[ $RET -ne 0 ]]; then\n\t\tEXIT_STATUS=1\n\t\tprintf \"TEST: %-60s  [FAIL]\\n\" \"$test_name $opt_str\"\n\t\tif [[ ! -z \"$retmsg\" ]]; then\n\t\t\tprintf \"\\t%s\\n\" \"$retmsg\"\n\t\tfi\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo \"Hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\t\treturn 1\n\tfi\n\n\tprintf \"TEST: %-60s  [ OK ]\\n\" \"$test_name $opt_str\"\n\treturn 0\n}\n\nlog_test_skip()\n{\n\tlocal test_name=$1\n\tlocal opt_str=$2\n\n\tprintf \"TEST: %-60s  [SKIP]\\n\" \"$test_name $opt_str\"\n\treturn 0\n}\n\nlog_info()\n{\n\tlocal msg=$1\n\n\techo \"INFO: $msg\"\n}\n\nbusywait()\n{\n\tlocal timeout=$1; shift\n\n\tlocal start_time=\"$(date -u +%s%3N)\"\n\twhile true\n\tdo\n\t\tlocal out\n\t\tout=$(\"$@\")\n\t\tlocal ret=$?\n\t\tif ((!ret)); then\n\t\t\techo -n \"$out\"\n\t\t\treturn 0\n\t\tfi\n\n\t\tlocal current_time=\"$(date -u +%s%3N)\"\n\t\tif ((current_time - start_time > timeout)); then\n\t\t\techo -n \"$out\"\n\t\t\treturn 1\n\t\tfi\n\tdone\n}\n\nnot()\n{\n\t\"$@\"\n\t[[ $? != 0 ]]\n}\n\nget_max()\n{\n\tlocal arr=(\"$@\")\n\n\tmax=${arr[0]}\n\tfor cur in ${arr[@]}; do\n\t\tif [[ $cur -gt $max ]]; then\n\t\t\tmax=$cur\n\t\tfi\n\tdone\n\n\techo $max\n}\n\ngrep_bridge_fdb()\n{\n\tlocal addr=$1; shift\n\tlocal word\n\tlocal flag\n\n\tif [ \"$1\" == \"self\" ] || [ \"$1\" == \"master\" ]; then\n\t\tword=$1; shift\n\t\tif [ \"$1\" == \"-v\" ]; then\n\t\t\tflag=$1; shift\n\t\tfi\n\tfi\n\n\t$@ | grep $addr | grep $flag \"$word\"\n}\n\nwait_for_port_up()\n{\n\t\"$@\" | grep -q \"Link detected: yes\"\n}\n\nwait_for_offload()\n{\n\t\"$@\" | grep -q offload\n}\n\nwait_for_trap()\n{\n\t\"$@\" | grep -q trap\n}\n\nuntil_counter_is()\n{\n\tlocal expr=$1; shift\n\tlocal current=$(\"$@\")\n\n\techo $((current))\n\t((current $expr))\n}\n\nbusywait_for_counter()\n{\n\tlocal timeout=$1; shift\n\tlocal delta=$1; shift\n\n\tlocal base=$(\"$@\")\n\tbusywait \"$timeout\" until_counter_is \">= $((base + delta))\" \"$@\"\n}\n\nsetup_wait_dev()\n{\n\tlocal dev=$1; shift\n\tlocal wait_time=${1:-$WAIT_TIME}; shift\n\n\tsetup_wait_dev_with_timeout \"$dev\" $INTERFACE_TIMEOUT $wait_time\n\n\tif (($?)); then\n\t\tcheck_err 1\n\t\tlog_test setup_wait_dev \": Interface $dev does not come up.\"\n\t\texit 1\n\tfi\n}\n\nsetup_wait_dev_with_timeout()\n{\n\tlocal dev=$1; shift\n\tlocal max_iterations=${1:-$WAIT_TIMEOUT}; shift\n\tlocal wait_time=${1:-$WAIT_TIME}; shift\n\tlocal i\n\n\tfor ((i = 1; i <= $max_iterations; ++i)); do\n\t\tip link show dev $dev up \\\n\t\t\t| grep 'state UP' &> /dev/null\n\t\tif [[ $? -ne 0 ]]; then\n\t\t\tsleep 1\n\t\telse\n\t\t\tsleep $wait_time\n\t\t\treturn 0\n\t\tfi\n\tdone\n\n\treturn 1\n}\n\nsetup_wait()\n{\n\tlocal num_netifs=${1:-$NUM_NETIFS}\n\tlocal i\n\n\tfor ((i = 1; i <= num_netifs; ++i)); do\n\t\tsetup_wait_dev ${NETIFS[p$i]} 0\n\tdone\n\n\t# Make sure links are ready.\n\tsleep $WAIT_TIME\n}\n\ncmd_jq()\n{\n\tlocal cmd=$1\n\tlocal jq_exp=$2\n\tlocal jq_opts=$3\n\tlocal ret\n\tlocal output\n\n\toutput=\"$($cmd)\"\n\t# it the command fails, return error right away\n\tret=$?\n\tif [[ $ret -ne 0 ]]; then\n\t\treturn $ret\n\tfi\n\toutput=$(echo $output | jq -r $jq_opts \"$jq_exp\")\n\tret=$?\n\tif [[ $ret -ne 0 ]]; then\n\t\treturn $ret\n\tfi\n\techo $output\n\t# return success only in case of non-empty output\n\t[ ! -z \"$output\" ]\n}\n\npre_cleanup()\n{\n\tif [ \"${PAUSE_ON_CLEANUP}\" = \"yes\" ]; then\n\t\techo \"Pausing before cleanup, hit any key to continue\"\n\t\tread\n\tfi\n\n\tif [[ \"$STABLE_MAC_ADDRS\" = \"yes\" ]]; then\n\t\tmac_addr_restore\n\tfi\n}\n\nvrf_prepare()\n{\n\tip -4 rule add pref 32765 table local\n\tip -4 rule del pref 0\n\tip -6 rule add pref 32765 table local\n\tip -6 rule del pref 0\n}\n\nvrf_cleanup()\n{\n\tip -6 rule add pref 0 table local\n\tip -6 rule del pref 32765\n\tip -4 rule add pref 0 table local\n\tip -4 rule del pref 32765\n}\n\n__last_tb_id=0\ndeclare -A __TB_IDS\n\n__vrf_td_id_assign()\n{\n\tlocal vrf_name=$1\n\n\t__last_tb_id=$((__last_tb_id + 1))\n\t__TB_IDS[$vrf_name]=$__last_tb_id\n\treturn $__last_tb_id\n}\n\n__vrf_td_id_lookup()\n{\n\tlocal vrf_name=$1\n\n\treturn ${__TB_IDS[$vrf_name]}\n}\n\nvrf_create()\n{\n\tlocal vrf_name=$1\n\tlocal tb_id\n\n\t__vrf_td_id_assign $vrf_name\n\ttb_id=$?\n\n\tip link add dev $vrf_name type vrf table $tb_id\n\tip -4 route add table $tb_id unreachable default metric 4278198272\n\tip -6 route add table $tb_id unreachable default metric 4278198272\n}\n\nvrf_destroy()\n{\n\tlocal vrf_name=$1\n\tlocal tb_id\n\n\t__vrf_td_id_lookup $vrf_name\n\ttb_id=$?\n\n\tip -6 route del table $tb_id unreachable default metric 4278198272\n\tip -4 route del table $tb_id unreachable default metric 4278198272\n\tip link del dev $vrf_name\n}\n\n__addr_add_del()\n{\n\tlocal if_name=$1\n\tlocal add_del=$2\n\tlocal array\n\n\tshift\n\tshift\n\tarray=(\"${@}\")\n\n\tfor addrstr in \"${array[@]}\"; do\n\t\tip address $add_del $addrstr dev $if_name\n\tdone\n}\n\n__simple_if_init()\n{\n\tlocal if_name=$1; shift\n\tlocal vrf_name=$1; shift\n\tlocal addrs=(\"${@}\")\n\n\tip link set dev $if_name master $vrf_name\n\tip link set dev $if_name up\n\n\t__addr_add_del $if_name add \"${addrs[@]}\"\n}\n\n__simple_if_fini()\n{\n\tlocal if_name=$1; shift\n\tlocal addrs=(\"${@}\")\n\n\t__addr_add_del $if_name del \"${addrs[@]}\"\n\n\tip link set dev $if_name down\n\tip link set dev $if_name nomaster\n}\n\nsimple_if_init()\n{\n\tlocal if_name=$1\n\tlocal vrf_name\n\tlocal array\n\n\tshift\n\tvrf_name=v$if_name\n\tarray=(\"${@}\")\n\n\tvrf_create $vrf_name\n\tip link set dev $vrf_name up\n\t__simple_if_init $if_name $vrf_name \"${array[@]}\"\n}\n\nsimple_if_fini()\n{\n\tlocal if_name=$1\n\tlocal vrf_name\n\tlocal array\n\n\tshift\n\tvrf_name=v$if_name\n\tarray=(\"${@}\")\n\n\t__simple_if_fini $if_name \"${array[@]}\"\n\tvrf_destroy $vrf_name\n}\n\ntunnel_create()\n{\n\tlocal name=$1; shift\n\tlocal type=$1; shift\n\tlocal local=$1; shift\n\tlocal remote=$1; shift\n\n\tip link add name $name type $type \\\n\t   local $local remote $remote \"$@\"\n\tip link set dev $name up\n}\n\ntunnel_destroy()\n{\n\tlocal name=$1; shift\n\n\tip link del dev $name\n}\n\nvlan_create()\n{\n\tlocal if_name=$1; shift\n\tlocal vid=$1; shift\n\tlocal vrf=$1; shift\n\tlocal ips=(\"${@}\")\n\tlocal name=$if_name.$vid\n\n\tip link add name $name link $if_name type vlan id $vid\n\tif [ \"$vrf\" != \"\" ]; then\n\t\tip link set dev $name master $vrf\n\tfi\n\tip link set dev $name up\n\t__addr_add_del $name add \"${ips[@]}\"\n}\n\nvlan_destroy()\n{\n\tlocal if_name=$1; shift\n\tlocal vid=$1; shift\n\tlocal name=$if_name.$vid\n\n\tip link del dev $name\n}\n\nteam_create()\n{\n\tlocal if_name=$1; shift\n\tlocal mode=$1; shift\n\n\trequire_command $TEAMD\n\t$TEAMD -t $if_name -d -c '{\"runner\": {\"name\": \"'$mode'\"}}'\n\tfor slave in \"$@\"; do\n\t\tip link set dev $slave down\n\t\tip link set dev $slave master $if_name\n\t\tip link set dev $slave up\n\tdone\n\tip link set dev $if_name up\n}\n\nteam_destroy()\n{\n\tlocal if_name=$1; shift\n\n\t$TEAMD -t $if_name -k\n}\n\nmaster_name_get()\n{\n\tlocal if_name=$1\n\n\tip -j link show dev $if_name | jq -r '.[][\"master\"]'\n}\n\nlink_stats_get()\n{\n\tlocal if_name=$1; shift\n\tlocal dir=$1; shift\n\tlocal stat=$1; shift\n\n\tip -j -s link show dev $if_name \\\n\t\t| jq '.[][\"stats64\"][\"'$dir'\"][\"'$stat'\"]'\n}\n\nlink_stats_tx_packets_get()\n{\n\tlink_stats_get $1 tx packets\n}\n\nlink_stats_rx_errors_get()\n{\n\tlink_stats_get $1 rx errors\n}\n\ntc_rule_stats_get()\n{\n\tlocal dev=$1; shift\n\tlocal pref=$1; shift\n\tlocal dir=$1; shift\n\tlocal selector=${1:-.packets}; shift\n\n\ttc -j -s filter show dev $dev ${dir:-ingress} pref $pref \\\n\t    | jq \".[1].options.actions[].stats$selector\"\n}\n\ntc_rule_handle_stats_get()\n{\n\tlocal id=$1; shift\n\tlocal handle=$1; shift\n\tlocal selector=${1:-.packets}; shift\n\tlocal netns=${1:-\"\"}; shift\n\n\ttc $netns -j -s filter show $id \\\n\t    | jq \".[] | select(.options.handle == $handle) | \\\n\t\t  .options.actions[0].stats$selector\"\n}\n\nethtool_stats_get()\n{\n\tlocal dev=$1; shift\n\tlocal stat=$1; shift\n\n\tethtool -S $dev | grep \"^ *$stat:\" | head -n 1 | cut -d: -f2\n}\n\nethtool_std_stats_get()\n{\n\tlocal dev=$1; shift\n\tlocal grp=$1; shift\n\tlocal name=$1; shift\n\tlocal src=$1; shift\n\n\tethtool --json -S $dev --groups $grp -- --src $src | \\\n\t\tjq '.[].\"'\"$grp\"'\".\"'$name'\"'\n}\n\nqdisc_stats_get()\n{\n\tlocal dev=$1; shift\n\tlocal handle=$1; shift\n\tlocal selector=$1; shift\n\n\ttc -j -s qdisc show dev \"$dev\" \\\n\t    | jq '.[] | select(.handle == \"'\"$handle\"'\") | '\"$selector\"\n}\n\nqdisc_parent_stats_get()\n{\n\tlocal dev=$1; shift\n\tlocal parent=$1; shift\n\tlocal selector=$1; shift\n\n\ttc -j -s qdisc show dev \"$dev\" invisible \\\n\t    | jq '.[] | select(.parent == \"'\"$parent\"'\") | '\"$selector\"\n}\n\nipv6_stats_get()\n{\n\tlocal dev=$1; shift\n\tlocal stat=$1; shift\n\n\tcat /proc/net/dev_snmp6/$dev | grep \"^$stat\" | cut -f2\n}\n\nhw_stats_get()\n{\n\tlocal suite=$1; shift\n\tlocal if_name=$1; shift\n\tlocal dir=$1; shift\n\tlocal stat=$1; shift\n\n\tip -j stats show dev $if_name group offload subgroup $suite |\n\t\tjq \".[0].stats64.$dir.$stat\"\n}\n\nhumanize()\n{\n\tlocal speed=$1; shift\n\n\tfor unit in bps Kbps Mbps Gbps; do\n\t\tif (($(echo \"$speed < 1024\" | bc))); then\n\t\t\tbreak\n\t\tfi\n\n\t\tspeed=$(echo \"scale=1; $speed / 1024\" | bc)\n\tdone\n\n\techo \"$speed${unit}\"\n}\n\nrate()\n{\n\tlocal t0=$1; shift\n\tlocal t1=$1; shift\n\tlocal interval=$1; shift\n\n\techo $((8 * (t1 - t0) / interval))\n}\n\npackets_rate()\n{\n\tlocal t0=$1; shift\n\tlocal t1=$1; shift\n\tlocal interval=$1; shift\n\n\techo $(((t1 - t0) / interval))\n}\n\nmac_get()\n{\n\tlocal if_name=$1\n\n\tip -j link show dev $if_name | jq -r '.[][\"address\"]'\n}\n\nipv6_lladdr_get()\n{\n\tlocal if_name=$1\n\n\tip -j addr show dev $if_name | \\\n\t\tjq -r '.[][\"addr_info\"][] | select(.scope == \"link\").local' | \\\n\t\thead -1\n}\n\nbridge_ageing_time_get()\n{\n\tlocal bridge=$1\n\tlocal ageing_time\n\n\t# Need to divide by 100 to convert to seconds.\n\tageing_time=$(ip -j -d link show dev $bridge \\\n\t\t      | jq '.[][\"linkinfo\"][\"info_data\"][\"ageing_time\"]')\n\techo $((ageing_time / 100))\n}\n\ndeclare -A SYSCTL_ORIG\nsysctl_set()\n{\n\tlocal key=$1; shift\n\tlocal value=$1; shift\n\n\tSYSCTL_ORIG[$key]=$(sysctl -n $key)\n\tsysctl -qw $key=\"$value\"\n}\n\nsysctl_restore()\n{\n\tlocal key=$1; shift\n\n\tsysctl -qw $key=\"${SYSCTL_ORIG[$key]}\"\n}\n\nforwarding_enable()\n{\n\tsysctl_set net.ipv4.conf.all.forwarding 1\n\tsysctl_set net.ipv6.conf.all.forwarding 1\n}\n\nforwarding_restore()\n{\n\tsysctl_restore net.ipv6.conf.all.forwarding\n\tsysctl_restore net.ipv4.conf.all.forwarding\n}\n\ndeclare -A MTU_ORIG\nmtu_set()\n{\n\tlocal dev=$1; shift\n\tlocal mtu=$1; shift\n\n\tMTU_ORIG[\"$dev\"]=$(ip -j link show dev $dev | jq -e '.[].mtu')\n\tip link set dev $dev mtu $mtu\n}\n\nmtu_restore()\n{\n\tlocal dev=$1; shift\n\n\tip link set dev $dev mtu ${MTU_ORIG[\"$dev\"]}\n}\n\ntc_offload_check()\n{\n\tlocal num_netifs=${1:-$NUM_NETIFS}\n\n\tfor ((i = 1; i <= num_netifs; ++i)); do\n\t\tethtool -k ${NETIFS[p$i]} \\\n\t\t\t| grep \"hw-tc-offload: on\" &> /dev/null\n\t\tif [[ $? -ne 0 ]]; then\n\t\t\treturn 1\n\t\tfi\n\tdone\n\n\treturn 0\n}\n\ntrap_install()\n{\n\tlocal dev=$1; shift\n\tlocal direction=$1; shift\n\n\t# Some devices may not support or need in-hardware trapping of traffic\n\t# (e.g. the veth pairs that this library creates for non-existent\n\t# loopbacks). Use continue instead, so that there is a filter in there\n\t# (some tests check counters), and so that other filters are still\n\t# processed.\n\ttc filter add dev $dev $direction pref 1 \\\n\t\tflower skip_sw action trap 2>/dev/null \\\n\t    || tc filter add dev $dev $direction pref 1 \\\n\t\t       flower action continue\n}\n\ntrap_uninstall()\n{\n\tlocal dev=$1; shift\n\tlocal direction=$1; shift\n\n\ttc filter del dev $dev $direction pref 1 flower\n}\n\nslow_path_trap_install()\n{\n\t# For slow-path testing, we need to install a trap to get to\n\t# slow path the packets that would otherwise be switched in HW.\n\tif [ \"${tcflags/skip_hw}\" != \"$tcflags\" ]; then\n\t\ttrap_install \"$@\"\n\tfi\n}\n\nslow_path_trap_uninstall()\n{\n\tif [ \"${tcflags/skip_hw}\" != \"$tcflags\" ]; then\n\t\ttrap_uninstall \"$@\"\n\tfi\n}\n\n__icmp_capture_add_del()\n{\n\tlocal add_del=$1; shift\n\tlocal pref=$1; shift\n\tlocal vsuf=$1; shift\n\tlocal tundev=$1; shift\n\tlocal filter=$1; shift\n\n\ttc filter $add_del dev \"$tundev\" ingress \\\n\t   proto ip$vsuf pref $pref \\\n\t   flower ip_proto icmp$vsuf $filter \\\n\t   action pass\n}\n\nicmp_capture_install()\n{\n\t__icmp_capture_add_del add 100 \"\" \"$@\"\n}\n\nicmp_capture_uninstall()\n{\n\t__icmp_capture_add_del del 100 \"\" \"$@\"\n}\n\nicmp6_capture_install()\n{\n\t__icmp_capture_add_del add 100 v6 \"$@\"\n}\n\nicmp6_capture_uninstall()\n{\n\t__icmp_capture_add_del del 100 v6 \"$@\"\n}\n\n__vlan_capture_add_del()\n{\n\tlocal add_del=$1; shift\n\tlocal pref=$1; shift\n\tlocal dev=$1; shift\n\tlocal filter=$1; shift\n\n\ttc filter $add_del dev \"$dev\" ingress \\\n\t   proto 802.1q pref $pref \\\n\t   flower $filter \\\n\t   action pass\n}\n\nvlan_capture_install()\n{\n\t__vlan_capture_add_del add 100 \"$@\"\n}\n\nvlan_capture_uninstall()\n{\n\t__vlan_capture_add_del del 100 \"$@\"\n}\n\n__dscp_capture_add_del()\n{\n\tlocal add_del=$1; shift\n\tlocal dev=$1; shift\n\tlocal base=$1; shift\n\tlocal dscp;\n\n\tfor prio in {0..7}; do\n\t\tdscp=$((base + prio))\n\t\t__icmp_capture_add_del $add_del $((dscp + 100)) \"\" $dev \\\n\t\t\t\t       \"skip_hw ip_tos $((dscp << 2))\"\n\tdone\n}\n\ndscp_capture_install()\n{\n\tlocal dev=$1; shift\n\tlocal base=$1; shift\n\n\t__dscp_capture_add_del add $dev $base\n}\n\ndscp_capture_uninstall()\n{\n\tlocal dev=$1; shift\n\tlocal base=$1; shift\n\n\t__dscp_capture_add_del del $dev $base\n}\n\ndscp_fetch_stats()\n{\n\tlocal dev=$1; shift\n\tlocal base=$1; shift\n\n\tfor prio in {0..7}; do\n\t\tlocal dscp=$((base + prio))\n\t\tlocal t=$(tc_rule_stats_get $dev $((dscp + 100)))\n\t\techo \"[$dscp]=$t \"\n\tdone\n}\n\nmatchall_sink_create()\n{\n\tlocal dev=$1; shift\n\n\ttc qdisc add dev $dev clsact\n\ttc filter add dev $dev ingress \\\n\t   pref 10000 \\\n\t   matchall \\\n\t   action drop\n}\n\ntests_run()\n{\n\tlocal current_test\n\n\tfor current_test in ${TESTS:-$ALL_TESTS}; do\n\t\t$current_test\n\tdone\n}\n\nmultipath_eval()\n{\n\tlocal desc=\"$1\"\n\tlocal weight_rp12=$2\n\tlocal weight_rp13=$3\n\tlocal packets_rp12=$4\n\tlocal packets_rp13=$5\n\tlocal weights_ratio packets_ratio diff\n\n\tRET=0\n\n\tif [[ \"$weight_rp12\" -gt \"$weight_rp13\" ]]; then\n\t\tweights_ratio=$(echo \"scale=2; $weight_rp12 / $weight_rp13\" \\\n\t\t\t\t| bc -l)\n\telse\n\t\tweights_ratio=$(echo \"scale=2; $weight_rp13 / $weight_rp12\" \\\n\t\t\t\t| bc -l)\n\tfi\n\n\tif [[ \"$packets_rp12\" -eq \"0\" || \"$packets_rp13\" -eq \"0\" ]]; then\n\t       check_err 1 \"Packet difference is 0\"\n\t       log_test \"Multipath\"\n\t       log_info \"Expected ratio $weights_ratio\"\n\t       return\n\tfi\n\n\tif [[ \"$weight_rp12\" -gt \"$weight_rp13\" ]]; then\n\t\tpackets_ratio=$(echo \"scale=2; $packets_rp12 / $packets_rp13\" \\\n\t\t\t\t| bc -l)\n\telse\n\t\tpackets_ratio=$(echo \"scale=2; $packets_rp13 / $packets_rp12\" \\\n\t\t\t\t| bc -l)\n\tfi\n\n\tdiff=$(echo $weights_ratio - $packets_ratio | bc -l)\n\tdiff=${diff#-}\n\n\ttest \"$(echo \"$diff / $weights_ratio > 0.15\" | bc -l)\" -eq 0\n\tcheck_err $? \"Too large discrepancy between expected and measured ratios\"\n\tlog_test \"$desc\"\n\tlog_info \"Expected ratio $weights_ratio Measured ratio $packets_ratio\"\n}\n\nin_ns()\n{\n\tlocal name=$1; shift\n\n\tip netns exec $name bash <<-EOF\n\t\tNUM_NETIFS=0\n\t\tsource lib.sh\n\t\t$(for a in \"$@\"; do printf \"%q${IFS:0:1}\" \"$a\"; done)\n\tEOF\n}\n\n##############################################################################\n# Tests\n\nping_do()\n{\n\tlocal if_name=$1\n\tlocal dip=$2\n\tlocal args=$3\n\tlocal vrf_name\n\n\tvrf_name=$(master_name_get $if_name)\n\tip vrf exec $vrf_name \\\n\t\t$PING $args $dip -c $PING_COUNT -i 0.1 \\\n\t\t-w $PING_TIMEOUT &> /dev/null\n}\n\nping_test()\n{\n\tRET=0\n\n\tping_do $1 $2\n\tcheck_err $?\n\tlog_test \"ping$3\"\n}\n\nping_test_fails()\n{\n\tRET=0\n\n\tping_do $1 $2\n\tcheck_fail $?\n\tlog_test \"ping fails$3\"\n}\n\nping6_do()\n{\n\tlocal if_name=$1\n\tlocal dip=$2\n\tlocal args=$3\n\tlocal vrf_name\n\n\tvrf_name=$(master_name_get $if_name)\n\tip vrf exec $vrf_name \\\n\t\t$PING6 $args $dip -c $PING_COUNT -i 0.1 \\\n\t\t-w $PING_TIMEOUT &> /dev/null\n}\n\nping6_test()\n{\n\tRET=0\n\n\tping6_do $1 $2\n\tcheck_err $?\n\tlog_test \"ping6$3\"\n}\n\nping6_test_fails()\n{\n\tRET=0\n\n\tping6_do $1 $2\n\tcheck_fail $?\n\tlog_test \"ping6 fails$3\"\n}\n\nlearning_test()\n{\n\tlocal bridge=$1\n\tlocal br_port1=$2\t# Connected to `host1_if`.\n\tlocal host1_if=$3\n\tlocal host2_if=$4\n\tlocal mac=de:ad:be:ef:13:37\n\tlocal ageing_time\n\n\tRET=0\n\n\tbridge -j fdb show br $bridge brport $br_port1 \\\n\t\t| jq -e \".[] | select(.mac == \\\"$mac\\\")\" &> /dev/null\n\tcheck_fail $? \"Found FDB record when should not\"\n\n\t# Disable unknown unicast flooding on `br_port1` to make sure\n\t# packets are only forwarded through the port after a matching\n\t# FDB entry was installed.\n\tbridge link set dev $br_port1 flood off\n\n\tip link set $host1_if promisc on\n\ttc qdisc add dev $host1_if ingress\n\ttc filter add dev $host1_if ingress protocol ip pref 1 handle 101 \\\n\t\tflower dst_mac $mac action drop\n\n\t$MZ $host2_if -c 1 -p 64 -b $mac -t ip -q\n\tsleep 1\n\n\ttc -j -s filter show dev $host1_if ingress \\\n\t\t| jq -e \".[] | select(.options.handle == 101) \\\n\t\t| select(.options.actions[0].stats.packets == 1)\" &> /dev/null\n\tcheck_fail $? \"Packet reached first host when should not\"\n\n\t$MZ $host1_if -c 1 -p 64 -a $mac -t ip -q\n\tsleep 1\n\n\tbridge -j fdb show br $bridge brport $br_port1 \\\n\t\t| jq -e \".[] | select(.mac == \\\"$mac\\\")\" &> /dev/null\n\tcheck_err $? \"Did not find FDB record when should\"\n\n\t$MZ $host2_if -c 1 -p 64 -b $mac -t ip -q\n\tsleep 1\n\n\ttc -j -s filter show dev $host1_if ingress \\\n\t\t| jq -e \".[] | select(.options.handle == 101) \\\n\t\t| select(.options.actions[0].stats.packets == 1)\" &> /dev/null\n\tcheck_err $? \"Packet did not reach second host when should\"\n\n\t# Wait for 10 seconds after the ageing time to make sure FDB\n\t# record was aged-out.\n\tageing_time=$(bridge_ageing_time_get $bridge)\n\tsleep $((ageing_time + 10))\n\n\tbridge -j fdb show br $bridge brport $br_port1 \\\n\t\t| jq -e \".[] | select(.mac == \\\"$mac\\\")\" &> /dev/null\n\tcheck_fail $? \"Found FDB record when should not\"\n\n\tbridge link set dev $br_port1 learning off\n\n\t$MZ $host1_if -c 1 -p 64 -a $mac -t ip -q\n\tsleep 1\n\n\tbridge -j fdb show br $bridge brport $br_port1 \\\n\t\t| jq -e \".[] | select(.mac == \\\"$mac\\\")\" &> /dev/null\n\tcheck_fail $? \"Found FDB record when should not\"\n\n\tbridge link set dev $br_port1 learning on\n\n\ttc filter del dev $host1_if ingress protocol ip pref 1 handle 101 flower\n\ttc qdisc del dev $host1_if ingress\n\tip link set $host1_if promisc off\n\n\tbridge link set dev $br_port1 flood on\n\n\tlog_test \"FDB learning\"\n}\n\nflood_test_do()\n{\n\tlocal should_flood=$1\n\tlocal mac=$2\n\tlocal ip=$3\n\tlocal host1_if=$4\n\tlocal host2_if=$5\n\tlocal err=0\n\n\t# Add an ACL on `host2_if` which will tell us whether the packet\n\t# was flooded to it or not.\n\tip link set $host2_if promisc on\n\ttc qdisc add dev $host2_if ingress\n\ttc filter add dev $host2_if ingress protocol ip pref 1 handle 101 \\\n\t\tflower dst_mac $mac action drop\n\n\t$MZ $host1_if -c 1 -p 64 -b $mac -B $ip -t ip -q\n\tsleep 1\n\n\ttc -j -s filter show dev $host2_if ingress \\\n\t\t| jq -e \".[] | select(.options.handle == 101) \\\n\t\t| select(.options.actions[0].stats.packets == 1)\" &> /dev/null\n\tif [[ $? -ne 0 && $should_flood == \"true\" || \\\n\t      $? -eq 0 && $should_flood == \"false\" ]]; then\n\t\terr=1\n\tfi\n\n\ttc filter del dev $host2_if ingress protocol ip pref 1 handle 101 flower\n\ttc qdisc del dev $host2_if ingress\n\tip link set $host2_if promisc off\n\n\treturn $err\n}\n\nflood_unicast_test()\n{\n\tlocal br_port=$1\n\tlocal host1_if=$2\n\tlocal host2_if=$3\n\tlocal mac=de:ad:be:ef:13:37\n\tlocal ip=192.0.2.100\n\n\tRET=0\n\n\tbridge link set dev $br_port flood off\n\n\tflood_test_do false $mac $ip $host1_if $host2_if\n\tcheck_err $? \"Packet flooded when should not\"\n\n\tbridge link set dev $br_port flood on\n\n\tflood_test_do true $mac $ip $host1_if $host2_if\n\tcheck_err $? \"Packet was not flooded when should\"\n\n\tlog_test \"Unknown unicast flood\"\n}\n\nflood_multicast_test()\n{\n\tlocal br_port=$1\n\tlocal host1_if=$2\n\tlocal host2_if=$3\n\tlocal mac=01:00:5e:00:00:01\n\tlocal ip=239.0.0.1\n\n\tRET=0\n\n\tbridge link set dev $br_port mcast_flood off\n\n\tflood_test_do false $mac $ip $host1_if $host2_if\n\tcheck_err $? \"Packet flooded when should not\"\n\n\tbridge link set dev $br_port mcast_flood on\n\n\tflood_test_do true $mac $ip $host1_if $host2_if\n\tcheck_err $? \"Packet was not flooded when should\"\n\n\tlog_test \"Unregistered multicast flood\"\n}\n\nflood_test()\n{\n\t# `br_port` is connected to `host2_if`\n\tlocal br_port=$1\n\tlocal host1_if=$2\n\tlocal host2_if=$3\n\n\tflood_unicast_test $br_port $host1_if $host2_if\n\tflood_multicast_test $br_port $host1_if $host2_if\n}\n\n__start_traffic()\n{\n\tlocal pktsize=$1; shift\n\tlocal proto=$1; shift\n\tlocal h_in=$1; shift    # Where the traffic egresses the host\n\tlocal sip=$1; shift\n\tlocal dip=$1; shift\n\tlocal dmac=$1; shift\n\n\t$MZ $h_in -p $pktsize -A $sip -B $dip -c 0 \\\n\t\t-a own -b $dmac -t \"$proto\" -q \"$@\" &\n\tsleep 1\n}\n\nstart_traffic_pktsize()\n{\n\tlocal pktsize=$1; shift\n\n\t__start_traffic $pktsize udp \"$@\"\n}\n\nstart_tcp_traffic_pktsize()\n{\n\tlocal pktsize=$1; shift\n\n\t__start_traffic $pktsize tcp \"$@\"\n}\n\nstart_traffic()\n{\n\tstart_traffic_pktsize 8000 \"$@\"\n}\n\nstart_tcp_traffic()\n{\n\tstart_tcp_traffic_pktsize 8000 \"$@\"\n}\n\nstop_traffic()\n{\n\t# Suppress noise from killing mausezahn.\n\t{ kill %% && wait %%; } 2>/dev/null\n}\n\ndeclare -A cappid\ndeclare -A capfile\ndeclare -A capout\n\ntcpdump_start()\n{\n\tlocal if_name=$1; shift\n\tlocal ns=$1; shift\n\n\tcapfile[$if_name]=$(mktemp)\n\tcapout[$if_name]=$(mktemp)\n\n\tif [ -z $ns ]; then\n\t\tns_cmd=\"\"\n\telse\n\t\tns_cmd=\"ip netns exec ${ns}\"\n\tfi\n\n\tif [ -z $SUDO_USER ] ; then\n\t\tcapuser=\"\"\n\telse\n\t\tcapuser=\"-Z $SUDO_USER\"\n\tfi\n\n\t$ns_cmd tcpdump $TCPDUMP_EXTRA_FLAGS -e -n -Q in -i $if_name \\\n\t\t-s 65535 -B 32768 $capuser -w ${capfile[$if_name]} \\\n\t\t> \"${capout[$if_name]}\" 2>&1 &\n\tcappid[$if_name]=$!\n\n\tsleep 1\n}\n\ntcpdump_stop()\n{\n\tlocal if_name=$1\n\tlocal pid=${cappid[$if_name]}\n\n\t$ns_cmd kill \"$pid\" && wait \"$pid\"\n\tsleep 1\n}\n\ntcpdump_cleanup()\n{\n\tlocal if_name=$1\n\n\trm ${capfile[$if_name]} ${capout[$if_name]}\n}\n\ntcpdump_show()\n{\n\tlocal if_name=$1\n\n\ttcpdump -e -n -r ${capfile[$if_name]} 2>&1\n}\n\n# return 0 if the packet wasn't seen on host2_if or 1 if it was\nmcast_packet_test()\n{\n\tlocal mac=$1\n\tlocal src_ip=$2\n\tlocal ip=$3\n\tlocal host1_if=$4\n\tlocal host2_if=$5\n\tlocal seen=0\n\tlocal tc_proto=\"ip\"\n\tlocal mz_v6arg=\"\"\n\n\t# basic check to see if we were passed an IPv4 address, if not assume IPv6\n\tif [[ ! $ip =~ ^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$ ]]; then\n\t\ttc_proto=\"ipv6\"\n\t\tmz_v6arg=\"-6\"\n\tfi\n\n\t# Add an ACL on `host2_if` which will tell us whether the packet\n\t# was received by it or not.\n\ttc qdisc add dev $host2_if ingress\n\ttc filter add dev $host2_if ingress protocol $tc_proto pref 1 handle 101 \\\n\t\tflower ip_proto udp dst_mac $mac action drop\n\n\t$MZ $host1_if $mz_v6arg -c 1 -p 64 -b $mac -A $src_ip -B $ip -t udp \"dp=4096,sp=2048\" -q\n\tsleep 1\n\n\ttc -j -s filter show dev $host2_if ingress \\\n\t\t| jq -e \".[] | select(.options.handle == 101) \\\n\t\t| select(.options.actions[0].stats.packets == 1)\" &> /dev/null\n\tif [[ $? -eq 0 ]]; then\n\t\tseen=1\n\tfi\n\n\ttc filter del dev $host2_if ingress protocol $tc_proto pref 1 handle 101 flower\n\ttc qdisc del dev $host2_if ingress\n\n\treturn $seen\n}\n\nbrmcast_check_sg_entries()\n{\n\tlocal report=$1; shift\n\tlocal slist=(\"$@\")\n\tlocal sarg=\"\"\n\n\tfor src in \"${slist[@]}\"; do\n\t\tsarg=\"${sarg} and .source_list[].address == \\\"$src\\\"\"\n\tdone\n\tbridge -j -d -s mdb show dev br0 \\\n\t\t| jq -e \".[].mdb[] | \\\n\t\t\t select(.grp == \\\"$TEST_GROUP\\\" and .source_list != null $sarg)\" &>/dev/null\n\tcheck_err $? \"Wrong *,G entry source list after $report report\"\n\n\tfor sgent in \"${slist[@]}\"; do\n\t\tbridge -j -d -s mdb show dev br0 \\\n\t\t\t| jq -e \".[].mdb[] | \\\n\t\t\t\t select(.grp == \\\"$TEST_GROUP\\\" and .src == \\\"$sgent\\\")\" &>/dev/null\n\t\tcheck_err $? \"Missing S,G entry ($sgent, $TEST_GROUP)\"\n\tdone\n}\n\nbrmcast_check_sg_fwding()\n{\n\tlocal should_fwd=$1; shift\n\tlocal sources=(\"$@\")\n\n\tfor src in \"${sources[@]}\"; do\n\t\tlocal retval=0\n\n\t\tmcast_packet_test $TEST_GROUP_MAC $src $TEST_GROUP $h2 $h1\n\t\tretval=$?\n\t\tif [ $should_fwd -eq 1 ]; then\n\t\t\tcheck_fail $retval \"Didn't forward traffic from S,G ($src, $TEST_GROUP)\"\n\t\telse\n\t\t\tcheck_err $retval \"Forwarded traffic for blocked S,G ($src, $TEST_GROUP)\"\n\t\tfi\n\tdone\n}\n\nbrmcast_check_sg_state()\n{\n\tlocal is_blocked=$1; shift\n\tlocal sources=(\"$@\")\n\tlocal should_fail=1\n\n\tif [ $is_blocked -eq 1 ]; then\n\t\tshould_fail=0\n\tfi\n\n\tfor src in \"${sources[@]}\"; do\n\t\tbridge -j -d -s mdb show dev br0 \\\n\t\t\t| jq -e \".[].mdb[] | \\\n\t\t\t\t select(.grp == \\\"$TEST_GROUP\\\" and .source_list != null) |\n\t\t\t\t .source_list[] |\n\t\t\t\t select(.address == \\\"$src\\\") |\n\t\t\t\t select(.timer == \\\"0.00\\\")\" &>/dev/null\n\t\tcheck_err_fail $should_fail $? \"Entry $src has zero timer\"\n\n\t\tbridge -j -d -s mdb show dev br0 \\\n\t\t\t| jq -e \".[].mdb[] | \\\n\t\t\t\t select(.grp == \\\"$TEST_GROUP\\\" and .src == \\\"$src\\\" and \\\n\t\t\t\t .flags[] == \\\"blocked\\\")\" &>/dev/null\n\t\tcheck_err_fail $should_fail $? \"Entry $src has blocked flag\"\n\tdone\n}\n\nmc_join()\n{\n\tlocal if_name=$1\n\tlocal group=$2\n\tlocal vrf_name=$(master_name_get $if_name)\n\n\t# We don't care about actual reception, just about joining the\n\t# IP multicast group and adding the L2 address to the device's\n\t# MAC filtering table\n\tip vrf exec $vrf_name \\\n\t\tmreceive -g $group -I $if_name > /dev/null 2>&1 &\n\tmreceive_pid=$!\n\n\tsleep 1\n}\n\nmc_leave()\n{\n\tkill \"$mreceive_pid\" && wait \"$mreceive_pid\"\n}\n\nmc_send()\n{\n\tlocal if_name=$1\n\tlocal groups=$2\n\tlocal vrf_name=$(master_name_get $if_name)\n\n\tip vrf exec $vrf_name \\\n\t\tmsend -g $groups -I $if_name -c 1 > /dev/null 2>&1\n}\n\nstart_ip_monitor()\n{\n\tlocal mtype=$1; shift\n\tlocal ip=${1-ip}; shift\n\n\t# start the monitor in the background\n\ttmpfile=`mktemp /var/run/nexthoptestXXX`\n\tmpid=`($ip monitor $mtype > $tmpfile & echo $!) 2>/dev/null`\n\tsleep 0.2\n\techo \"$mpid $tmpfile\"\n}\n\nstop_ip_monitor()\n{\n\tlocal mpid=$1; shift\n\tlocal tmpfile=$1; shift\n\tlocal el=$1; shift\n\tlocal what=$1; shift\n\n\tsleep 0.2\n\tkill $mpid\n\tlocal lines=`grep '^\\w' $tmpfile | wc -l`\n\ttest $lines -eq $el\n\tcheck_err $? \"$what: $lines lines of events, expected $el\"\n\trm -rf $tmpfile\n}\n\nhw_stats_monitor_test()\n{\n\tlocal dev=$1; shift\n\tlocal type=$1; shift\n\tlocal make_suitable=$1; shift\n\tlocal make_unsuitable=$1; shift\n\tlocal ip=${1-ip}; shift\n\n\tRET=0\n\n\t# Expect a notification about enablement.\n\tlocal ipmout=$(start_ip_monitor stats \"$ip\")\n\t$ip stats set dev $dev ${type}_stats on\n\tstop_ip_monitor $ipmout 1 \"${type}_stats enablement\"\n\n\t# Expect a notification about offload.\n\tlocal ipmout=$(start_ip_monitor stats \"$ip\")\n\t$make_suitable\n\tstop_ip_monitor $ipmout 1 \"${type}_stats installation\"\n\n\t# Expect a notification about loss of offload.\n\tlocal ipmout=$(start_ip_monitor stats \"$ip\")\n\t$make_unsuitable\n\tstop_ip_monitor $ipmout 1 \"${type}_stats deinstallation\"\n\n\t# Expect a notification about disablement\n\tlocal ipmout=$(start_ip_monitor stats \"$ip\")\n\t$ip stats set dev $dev ${type}_stats off\n\tstop_ip_monitor $ipmout 1 \"${type}_stats disablement\"\n\n\tlog_test \"${type}_stats notifications\"\n}\n\nipv4_to_bytes()\n{\n\tlocal IP=$1; shift\n\n\tprintf '%02x:' ${IP//./ } |\n\t    sed 's/:$//'\n}\n\n# Convert a given IPv6 address, `IP' such that the :: token, if present, is\n# expanded, and each 16-bit group is padded with zeroes to be 4 hexadecimal\n# digits. An optional `BYTESEP' parameter can be given to further separate\n# individual bytes of each 16-bit group.\nexpand_ipv6()\n{\n\tlocal IP=$1; shift\n\tlocal bytesep=$1; shift\n\n\tlocal cvt_ip=${IP/::/_}\n\tlocal colons=${cvt_ip//[^:]/}\n\tlocal allcol=:::::::\n\t# IP where :: -> the appropriate number of colons:\n\tlocal allcol_ip=${cvt_ip/_/${allcol:${#colons}}}\n\n\techo $allcol_ip | tr : '\\n' |\n\t    sed s/^/0000/ |\n\t    sed 's/.*\\(..\\)\\(..\\)/\\1'\"$bytesep\"'\\2/' |\n\t    tr '\\n' : |\n\t    sed 's/:$//'\n}\n\nipv6_to_bytes()\n{\n\tlocal IP=$1; shift\n\n\texpand_ipv6 \"$IP\" :\n}\n\nu16_to_bytes()\n{\n\tlocal u16=$1; shift\n\n\tprintf \"%04x\" $u16 | sed 's/^/000/;s/^.*\\(..\\)\\(..\\)$/\\1:\\2/'\n}\n\n# Given a mausezahn-formatted payload (colon-separated bytes given as %02x),\n# possibly with a keyword CHECKSUM stashed where a 16-bit checksum should be,\n# calculate checksum as per RFC 1071, assuming the CHECKSUM field (if any)\n# stands for 00:00.\npayload_template_calc_checksum()\n{\n\tlocal payload=$1; shift\n\n\t(\n\t    # Set input radix.\n\t    echo \"16i\"\n\t    # Push zero for the initial checksum.\n\t    echo 0\n\n\t    # Pad the payload with a terminating 00: in case we get an odd\n\t    # number of bytes.\n\t    echo \"${payload%:}:00:\" |\n\t\tsed 's/CHECKSUM/00:00/g' |\n\t\ttr '[:lower:]' '[:upper:]' |\n\t\t# Add the word to the checksum.\n\t\tsed 's/\\(..\\):\\(..\\):/\\1\\2+\\n/g' |\n\t\t# Strip the extra odd byte we pushed if left unconverted.\n\t\tsed 's/\\(..\\):$//'\n\n\t    echo \"10000 ~ +\"\t# Calculate and add carry.\n\t    echo \"FFFF r - p\"\t# Bit-flip and print.\n\t) |\n\t    dc |\n\t    tr '[:upper:]' '[:lower:]'\n}\n\npayload_template_expand_checksum()\n{\n\tlocal payload=$1; shift\n\tlocal checksum=$1; shift\n\n\tlocal ckbytes=$(u16_to_bytes $checksum)\n\n\techo \"$payload\" | sed \"s/CHECKSUM/$ckbytes/g\"\n}\n\npayload_template_nbytes()\n{\n\tlocal payload=$1; shift\n\n\tpayload_template_expand_checksum \"${payload%:}\" 0 |\n\t\tsed 's/:/\\n/g' | wc -l\n}\n\nigmpv3_is_in_get()\n{\n\tlocal GRP=$1; shift\n\tlocal sources=(\"$@\")\n\n\tlocal igmpv3\n\tlocal nsources=$(u16_to_bytes ${#sources[@]})\n\n\t# IS_IN ( $sources )\n\tigmpv3=$(:\n\t\t)\"22:\"$(\t\t\t: Type - Membership Report\n\t\t)\"00:\"$(\t\t\t: Reserved\n\t\t)\"CHECKSUM:\"$(\t\t\t: Checksum\n\t\t)\"00:00:\"$(\t\t\t: Reserved\n\t\t)\"00:01:\"$(\t\t\t: Number of Group Records\n\t\t)\"01:\"$(\t\t\t: Record Type - IS_IN\n\t\t)\"00:\"$(\t\t\t: Aux Data Len\n\t\t)\"${nsources}:\"$(\t\t: Number of Sources\n\t\t)\"$(ipv4_to_bytes $GRP):\"$(\t: Multicast Address\n\t\t)\"$(for src in \"${sources[@]}\"; do\n\t\t\tipv4_to_bytes $src\n\t\t\techo -n :\n\t\t    done)\"$(\t\t\t: Source Addresses\n\t\t)\n\tlocal checksum=$(payload_template_calc_checksum \"$igmpv3\")\n\n\tpayload_template_expand_checksum \"$igmpv3\" $checksum\n}\n\nigmpv2_leave_get()\n{\n\tlocal GRP=$1; shift\n\n\tlocal payload=$(:\n\t\t)\"17:\"$(\t\t\t: Type - Leave Group\n\t\t)\"00:\"$(\t\t\t: Max Resp Time - not meaningful\n\t\t)\"CHECKSUM:\"$(\t\t\t: Checksum\n\t\t)\"$(ipv4_to_bytes $GRP)\"$(\t: Group Address\n\t\t)\n\tlocal checksum=$(payload_template_calc_checksum \"$payload\")\n\n\tpayload_template_expand_checksum \"$payload\" $checksum\n}\n\nmldv2_is_in_get()\n{\n\tlocal SIP=$1; shift\n\tlocal GRP=$1; shift\n\tlocal sources=(\"$@\")\n\n\tlocal hbh\n\tlocal icmpv6\n\tlocal nsources=$(u16_to_bytes ${#sources[@]})\n\n\thbh=$(:\n\t\t)\"3a:\"$(\t\t\t: Next Header - ICMPv6\n\t\t)\"00:\"$(\t\t\t: Hdr Ext Len\n\t\t)\"00:00:00:00:00:00:\"$(\t\t: Options and Padding\n\t\t)\n\n\ticmpv6=$(:\n\t\t)\"8f:\"$(\t\t\t: Type - MLDv2 Report\n\t\t)\"00:\"$(\t\t\t: Code\n\t\t)\"CHECKSUM:\"$(\t\t\t: Checksum\n\t\t)\"00:00:\"$(\t\t\t: Reserved\n\t\t)\"00:01:\"$(\t\t\t: Number of Group Records\n\t\t)\"01:\"$(\t\t\t: Record Type - IS_IN\n\t\t)\"00:\"$(\t\t\t: Aux Data Len\n\t\t)\"${nsources}:\"$(\t\t: Number of Sources\n\t\t)\"$(ipv6_to_bytes $GRP):\"$(\t: Multicast address\n\t\t)\"$(for src in \"${sources[@]}\"; do\n\t\t\tipv6_to_bytes $src\n\t\t\techo -n :\n\t\t    done)\"$(\t\t\t: Source Addresses\n\t\t)\n\n\tlocal len=$(u16_to_bytes $(payload_template_nbytes $icmpv6))\n\tlocal sudohdr=$(:\n\t\t)\"$(ipv6_to_bytes $SIP):\"$(\t: SIP\n\t\t)\"$(ipv6_to_bytes $GRP):\"$(\t: DIP is multicast address\n\t        )\"${len}:\"$(\t\t\t: Upper-layer length\n\t        )\"00:3a:\"$(\t\t\t: Zero and next-header\n\t        )\n\tlocal checksum=$(payload_template_calc_checksum ${sudohdr}${icmpv6})\n\n\tpayload_template_expand_checksum \"$hbh$icmpv6\" $checksum\n}\n\nmldv1_done_get()\n{\n\tlocal SIP=$1; shift\n\tlocal GRP=$1; shift\n\n\tlocal hbh\n\tlocal icmpv6\n\n\thbh=$(:\n\t\t)\"3a:\"$(\t\t\t: Next Header - ICMPv6\n\t\t)\"00:\"$(\t\t\t: Hdr Ext Len\n\t\t)\"00:00:00:00:00:00:\"$(\t\t: Options and Padding\n\t\t)\n\n\ticmpv6=$(:\n\t\t)\"84:\"$(\t\t\t: Type - MLDv1 Done\n\t\t)\"00:\"$(\t\t\t: Code\n\t\t)\"CHECKSUM:\"$(\t\t\t: Checksum\n\t\t)\"00:00:\"$(\t\t\t: Max Resp Delay - not meaningful\n\t\t)\"00:00:\"$(\t\t\t: Reserved\n\t\t)\"$(ipv6_to_bytes $GRP):\"$(\t: Multicast address\n\t\t)\n\n\tlocal len=$(u16_to_bytes $(payload_template_nbytes $icmpv6))\n\tlocal sudohdr=$(:\n\t\t)\"$(ipv6_to_bytes $SIP):\"$(\t: SIP\n\t\t)\"$(ipv6_to_bytes $GRP):\"$(\t: DIP is multicast address\n\t        )\"${len}:\"$(\t\t\t: Upper-layer length\n\t        )\"00:3a:\"$(\t\t\t: Zero and next-header\n\t        )\n\tlocal checksum=$(payload_template_calc_checksum ${sudohdr}${icmpv6})\n\n\tpayload_template_expand_checksum \"$hbh$icmpv6\" $checksum\n}\n\nbail_on_lldpad()\n{\n\tlocal reason1=\"$1\"; shift\n\tlocal reason2=\"$1\"; shift\n\n\tif systemctl is-active --quiet lldpad; then\n\n\t\tcat >/dev/stderr <<-EOF\n\t\tWARNING: lldpad is running\n\n\t\t\tlldpad will likely $reason1, and this test will\n\t\t\t$reason2. Both are not supported at the same time,\n\t\t\tone of them is arbitrarily going to overwrite the\n\t\t\tother. That will cause spurious failures (or, unlikely,\n\t\t\tpasses) of this test.\n\t\tEOF\n\n\t\tif [[ -z $ALLOW_LLDPAD ]]; then\n\t\t\tcat >/dev/stderr <<-EOF\n\n\t\t\t\tIf you want to run the test anyway, please set\n\t\t\t\tan environment variable ALLOW_LLDPAD to a\n\t\t\t\tnon-empty string.\n\t\t\tEOF\n\t\t\texit 1\n\t\telse\n\t\t\treturn\n\t\tfi\n\tfi\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}