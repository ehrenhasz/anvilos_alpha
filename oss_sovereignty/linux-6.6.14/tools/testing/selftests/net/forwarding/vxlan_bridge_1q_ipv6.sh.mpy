{
  "module_name": "vxlan_bridge_1q_ipv6.sh",
  "hash_id": "cbe10c9e78b663122eba8d89edbb342ca0e8905053c7f29725ae17f258420be9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/vxlan_bridge_1q_ipv6.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# +-----------------------+                          +------------------------+\n# | H1 (vrf)              |                          | H2 (vrf)               |\n# | + $h1.10              |                          | + $h2.10               |\n# | | 192.0.2.1/28        |                          | | 192.0.2.2/28         |\n# | | 2001:db8:1::1/64    |                          | | 2001:db8:1::2/64     |\n# | |                     |                          | |                      |\n# | |  + $h1.20           |                          | |  + $h2.20            |\n# | \\  | 198.51.100.1/24  |                          | \\  | 198.51.100.2/24   |\n# |  \\ | 2001:db8:2::1/64 |                          |  \\ | 2001:db8:2::2/64  |\n# |   \\|                  |                          |   \\|                   |\n# |    + $h1              |                          |    + $h2               |\n# +----|------------------+                          +----|-------------------+\n#      |                                                  |\n# +----|--------------------------------------------------|-------------------+\n# | SW |                                                  |                   |\n# | +--|--------------------------------------------------|-----------------+ |\n# | |  + $swp1                   BR1 (802.1q)             + $swp2           | |\n# | |     vid 10                                             vid 10         | |\n# | |     vid 20                                             vid 20         | |\n# | |                                                                       | |\n# | |  + vx10 (vxlan)                        + vx20 (vxlan)                 | |\n# | |    local:                                local:                       | |\n# | |    2001:db8:3::1                         2001:db8:3::1                | |\n# | |    remote:                               remote:                      | |\n# | |    2001:db8:4::1 2001:db8:5::1           2001:db8:4::1 2001:db8:5::1  | |\n# | |    id 1000 dstport $VXPORT               id 2000 dstport $VXPORT      | |\n# | |    vid 10 pvid untagged                  vid 20 pvid untagged         | |\n# | +-----------------------------------------------------------------------+ |\n# |                                                                           |\n# |  2001:db8:4::0/64 via 2001:db8:3::2                                       |\n# |  2001:db8:5::0/64 via 2001:db8:3::2                                       |\n# |                                                                           |\n# |    + $rp1                                                                 |\n# |    | 2001:db8:3::1/64                                                     |\n# +----|----------------------------------------------------------------------+\n#      |\n# +----|----------------------------------------------------------+\n# |    |                                             VRP2 (vrf)   |\n# |    + $rp2                                                     |\n# |      2001:db8:3::2/64                                         |\n# |                                                               |  (maybe) HW\n# =============================================================================\n# |                                                               |  (likely) SW\n# |    + v1 (veth)                             + v3 (veth)        |\n# |    | 2001:db8:4::2/64                      | 2001:db8:5::2/64 |\n# +----|---------------------------------------|------------------+\n#      |                                       |\n# +----|--------------------------------+ +----|-------------------------------+\n# |    + v2 (veth)        NS1 (netns)   | |    + v4 (veth)        NS2 (netns)  |\n# |      2001:db8:4::1/64               | |      2001:db8:5::1/64              |\n# |                                     | |                                    |\n# | 2001:db8:3::0/64 via 2001:db8:4::2  | | 2001:db8:3::0/64 via 2001:db8:5::2 |\n# | 2001:db8:5::1/128 via 2001:db8:4::2 | | 2001:db8:4::1/128 via              |\n# |                                     | |         2001:db8:5::2              |\n# |                                     | |                                    |\n# | +-------------------------------+   | | +-------------------------------+  |\n# | |                  BR2 (802.1q) |   | | |                  BR2 (802.1q) |  |\n# | |  + vx10 (vxlan)               |   | | |  + vx10 (vxlan)               |  |\n# | |    local 2001:db8:4::1        |   | | |    local 2001:db8:5::1        |  |\n# | |    remote 2001:db8:3::1       |   | | |    remote 2001:db8:3::1       |  |\n# | |    remote 2001:db8:5::1       |   | | |    remote 2001:db8:4::1       |  |\n# | |    id 1000 dstport $VXPORT    |   | | |    id 1000 dstport $VXPORT    |  |\n# | |    vid 10 pvid untagged       |   | | |    vid 10 pvid untagged       |  |\n# | |                               |   | | |                               |  |\n# | |  + vx20 (vxlan)               |   | | |  + vx20 (vxlan)               |  |\n# | |    local 2001:db8:4::1        |   | | |    local 2001:db8:5::1        |  |\n# | |    remote 2001:db8:3::1       |   | | |    remote 2001:db8:3::1       |  |\n# | |    remote 2001:db8:5::1       |   | | |    remote 2001:db8:4::1       |  |\n# | |    id 2000 dstport $VXPORT    |   | | |    id 2000 dstport $VXPORT    |  |\n# | |    vid 20 pvid untagged       |   | | |    vid 20 pvid untagged       |  |\n# | |                               |   | | |                               |  |\n# | |  + w1 (veth)                  |   | | |  + w1 (veth)                  |  |\n# | |  | vid 10                     |   | | |  | vid 10                     |  |\n# | |  | vid 20                     |   | | |  | vid 20                     |  |\n# | +--|----------------------------+   | | +--|----------------------------+  |\n# |    |                                | |    |                               |\n# | +--|----------------------------+   | | +--|----------------------------+  |\n# | |  + w2 (veth)        VW2 (vrf) |   | | |  + w2 (veth)        VW2 (vrf) |  |\n# | |  |\\                           |   | | |  |\\                           |  |\n# | |  | + w2.10                    |   | | |  | + w2.10                    |  |\n# | |  |   192.0.2.3/28             |   | | |  |   192.0.2.4/28             |  |\n# | |  |   2001:db8:1::3/64         |   | | |  |   2001:db8:1::4/64         |  |\n# | |  |                            |   | | |  |                            |  |\n# | |  + w2.20                      |   | | |  + w2.20                      |  |\n# | |    198.51.100.3/24            |   | | |    198.51.100.4/24            |  |\n# | |    2001:db8:2::3/64           |   | | |    2001:db8:2::4/64           |  |\n# | +-------------------------------+   | | +-------------------------------+  |\n# +-------------------------------------+ +------------------------------------+\n\n: ${VXPORT:=4789}\nexport VXPORT\n\n: ${ALL_TESTS:=\"\n\tping_ipv4\n\tping_ipv6\n\ttest_flood\n\ttest_unicast\n\treapply_config\n\tping_ipv4\n\tping_ipv6\n\ttest_flood\n\ttest_unicast\n\ttest_pvid\n\tping_ipv4\n\tping_ipv6\n\ttest_flood\n\ttest_pvid\n\"}\n\nNUM_NETIFS=6\nsource lib.sh\nsource tc_common.sh\n\nh1_create()\n{\n\tsimple_if_init $h1\n\ttc qdisc add dev $h1 clsact\n\tvlan_create $h1 10 v$h1 192.0.2.1/28 2001:db8:1::1/64\n\tvlan_create $h1 20 v$h1 198.51.100.1/24 2001:db8:2::1/64\n}\n\nh1_destroy()\n{\n\tvlan_destroy $h1 20\n\tvlan_destroy $h1 10\n\ttc qdisc del dev $h1 clsact\n\tsimple_if_fini $h1\n}\n\nh2_create()\n{\n\tsimple_if_init $h2\n\ttc qdisc add dev $h2 clsact\n\tvlan_create $h2 10 v$h2 192.0.2.2/28 2001:db8:1::2/64\n\tvlan_create $h2 20 v$h2 198.51.100.2/24 2001:db8:2::2/64\n}\n\nh2_destroy()\n{\n\tvlan_destroy $h2 20\n\tvlan_destroy $h2 10\n\ttc qdisc del dev $h2 clsact\n\tsimple_if_fini $h2\n}\n\nrp1_set_addr()\n{\n\tip address add dev $rp1 2001:db8:3::1/64\n\n\tip route add 2001:db8:4::0/64 nexthop via 2001:db8:3::2\n\tip route add 2001:db8:5::0/64 nexthop via 2001:db8:3::2\n}\n\nrp1_unset_addr()\n{\n\tip route del 2001:db8:5::0/64 nexthop via 2001:db8:3::2\n\tip route del 2001:db8:4::0/64 nexthop via 2001:db8:3::2\n\n\tip address del dev $rp1 2001:db8:3::1/64\n}\n\nswitch_create()\n{\n\tip link add name br1 type bridge vlan_filtering 1 vlan_default_pvid 0 \\\n\t\tmcast_snooping 0\n\t# Make sure the bridge uses the MAC address of the local port and not\n\t# that of the VxLAN's device.\n\tip link set dev br1 address $(mac_get $swp1)\n\tip link set dev br1 up\n\n\tip link set dev $rp1 up\n\trp1_set_addr\n\ttc qdisc add dev $rp1 clsact\n\n\tip link add name vx10 type vxlan id 1000 local 2001:db8:3::1 \\\n\t\tdstport \"$VXPORT\" nolearning udp6zerocsumrx udp6zerocsumtx \\\n\t\ttos inherit ttl 100\n\tip link set dev vx10 up\n\n\tip link set dev vx10 master br1\n\tbridge vlan add vid 10 dev vx10 pvid untagged\n\n\tip link add name vx20 type vxlan id 2000 local 2001:db8:3::1 \\\n\t\tdstport \"$VXPORT\" nolearning udp6zerocsumrx udp6zerocsumtx \\\n\t\ttos inherit ttl 100\n\tip link set dev vx20 up\n\n\tip link set dev vx20 master br1\n\tbridge vlan add vid 20 dev vx20 pvid untagged\n\n\tip link set dev $swp1 master br1\n\tip link set dev $swp1 up\n\ttc qdisc add dev $swp1 clsact\n\tbridge vlan add vid 10 dev $swp1\n\tbridge vlan add vid 20 dev $swp1\n\n\tip link set dev $swp2 master br1\n\tip link set dev $swp2 up\n\tbridge vlan add vid 10 dev $swp2\n\tbridge vlan add vid 20 dev $swp2\n\n\tbridge fdb append dev vx10 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\tbridge fdb append dev vx10 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\n\tbridge fdb append dev vx20 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\tbridge fdb append dev vx20 00:00:00:00:00:00 dst 2001:db8:5::1 self\n}\n\nswitch_destroy()\n{\n\tbridge fdb del dev vx20 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\tbridge fdb del dev vx20 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\n\tbridge fdb del dev vx10 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\tbridge fdb del dev vx10 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\n\tbridge vlan del vid 20 dev $swp2\n\tbridge vlan del vid 10 dev $swp2\n\tip link set dev $swp2 down\n\tip link set dev $swp2 nomaster\n\n\tbridge vlan del vid 20 dev $swp1\n\tbridge vlan del vid 10 dev $swp1\n\ttc qdisc del dev $swp1 clsact\n\tip link set dev $swp1 down\n\tip link set dev $swp1 nomaster\n\n\tbridge vlan del vid 20 dev vx20\n\tip link set dev vx20 nomaster\n\n\tip link set dev vx20 down\n\tip link del dev vx20\n\n\tbridge vlan del vid 10 dev vx10\n\tip link set dev vx10 nomaster\n\n\tip link set dev vx10 down\n\tip link del dev vx10\n\n\ttc qdisc del dev $rp1 clsact\n\trp1_unset_addr\n\tip link set dev $rp1 down\n\n\tip link set dev br1 down\n\tip link del dev br1\n}\n\nvrp2_create()\n{\n\tsimple_if_init $rp2 2001:db8:3::2/64\n\t__simple_if_init v1 v$rp2 2001:db8:4::2/64\n\t__simple_if_init v3 v$rp2 2001:db8:5::2/64\n\ttc qdisc add dev v1 clsact\n}\n\nvrp2_destroy()\n{\n\ttc qdisc del dev v1 clsact\n\t__simple_if_fini v3 2001:db8:5::2/64\n\t__simple_if_fini v1 2001:db8:4::2/64\n\tsimple_if_fini $rp2 2001:db8:3::2/64\n}\n\nns_init_common()\n{\n\tlocal in_if=$1; shift\n\tlocal in_addr=$1; shift\n\tlocal other_in_addr=$1; shift\n\tlocal nh_addr=$1; shift\n\tlocal host_addr1_ipv4=$1; shift\n\tlocal host_addr1_ipv6=$1; shift\n\tlocal host_addr2_ipv4=$1; shift\n\tlocal host_addr2_ipv6=$1; shift\n\n\tip link set dev $in_if up\n\tip address add dev $in_if $in_addr/64\n\ttc qdisc add dev $in_if clsact\n\n\tip link add name br2 type bridge vlan_filtering 1 vlan_default_pvid 0\n\tip link set dev br2 up\n\n\tip link add name w1 type veth peer name w2\n\n\tip link set dev w1 master br2\n\tip link set dev w1 up\n\n\tbridge vlan add vid 10 dev w1\n\tbridge vlan add vid 20 dev w1\n\n\tip link add name vx10 type vxlan id 1000 local $in_addr \\\n\t\tdstport \"$VXPORT\" udp6zerocsumrx\n\tip link set dev vx10 up\n\tbridge fdb append dev vx10 00:00:00:00:00:00 dst 2001:db8:3::1 self\n\tbridge fdb append dev vx10 00:00:00:00:00:00 dst $other_in_addr self\n\n\tip link set dev vx10 master br2\n\ttc qdisc add dev vx10 clsact\n\n\tbridge vlan add vid 10 dev vx10 pvid untagged\n\n\tip link add name vx20 type vxlan id 2000 local $in_addr \\\n\t\tdstport \"$VXPORT\" udp6zerocsumrx\n\tip link set dev vx20 up\n\tbridge fdb append dev vx20 00:00:00:00:00:00 dst 2001:db8:3::1 self\n\tbridge fdb append dev vx20 00:00:00:00:00:00 dst $other_in_addr self\n\n\tip link set dev vx20 master br2\n\ttc qdisc add dev vx20 clsact\n\n\tbridge vlan add vid 20 dev vx20 pvid untagged\n\n\tsimple_if_init w2\n        vlan_create w2 10 vw2 $host_addr1_ipv4/28 $host_addr1_ipv6/64\n        vlan_create w2 20 vw2 $host_addr2_ipv4/24 $host_addr2_ipv6/64\n\n\tip route add 2001:db8:3::0/64 nexthop via $nh_addr\n\tip route add $other_in_addr/128 nexthop via $nh_addr\n}\nexport -f ns_init_common\n\nns1_create()\n{\n\tip netns add ns1\n\tip link set dev v2 netns ns1\n\tin_ns ns1 \\\n\t      ns_init_common v2 2001:db8:4::1 2001:db8:5::1 2001:db8:4::2 \\\n\t      192.0.2.3 2001:db8:1::3 198.51.100.3 2001:db8:2::3\n}\n\nns1_destroy()\n{\n\tip netns exec ns1 ip link set dev v2 netns 1\n\tip netns del ns1\n}\n\nns2_create()\n{\n\tip netns add ns2\n\tip link set dev v4 netns ns2\n\tin_ns ns2 \\\n\t      ns_init_common v4 2001:db8:5::1 2001:db8:4::1 2001:db8:5::2 \\\n\t      192.0.2.4 2001:db8:1::4 198.51.100.4 2001:db8:2::4\n}\n\nns2_destroy()\n{\n\tip netns exec ns2 ip link set dev v4 netns 1\n\tip netns del ns2\n}\n\nsetup_prepare()\n{\n\th1=${NETIFS[p1]}\n\tswp1=${NETIFS[p2]}\n\n\tswp2=${NETIFS[p3]}\n\th2=${NETIFS[p4]}\n\n\trp1=${NETIFS[p5]}\n\trp2=${NETIFS[p6]}\n\n\tvrf_prepare\n\tforwarding_enable\n\n\th1_create\n\th2_create\n\tswitch_create\n\n\tip link add name v1 type veth peer name v2\n\tip link add name v3 type veth peer name v4\n\tvrp2_create\n\tns1_create\n\tns2_create\n\n\tr1_mac=$(in_ns ns1 mac_get w2)\n\tr2_mac=$(in_ns ns2 mac_get w2)\n\th2_mac=$(mac_get $h2)\n}\n\ncleanup()\n{\n\tpre_cleanup\n\n\tns2_destroy\n\tns1_destroy\n\tvrp2_destroy\n\tip link del dev v3\n\tip link del dev v1\n\n\tswitch_destroy\n\th2_destroy\n\th1_destroy\n\n\tforwarding_restore\n\tvrf_cleanup\n}\n\n# For the first round of tests, vx10 and vx20 were the first devices to get\n# attached to the bridge, and at that point the local IP is already\n# configured. Try the other scenario of attaching these devices to a bridge\n# that already has local ports members, and only then assign the local IP.\nreapply_config()\n{\n\tlog_info \"Reapplying configuration\"\n\n\tbridge fdb del dev vx20 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\tbridge fdb del dev vx20 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\n\tbridge fdb del dev vx10 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\tbridge fdb del dev vx10 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\n\tip link set dev vx20 nomaster\n\tip link set dev vx10 nomaster\n\n\trp1_unset_addr\n\tsleep 5\n\n\tip link set dev vx10 master br1\n\tbridge vlan add vid 10 dev vx10 pvid untagged\n\n\tip link set dev vx20 master br1\n\tbridge vlan add vid 20 dev vx20 pvid untagged\n\n\tbridge fdb append dev vx10 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\tbridge fdb append dev vx10 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\n\tbridge fdb append dev vx20 00:00:00:00:00:00 dst 2001:db8:4::1 self\n\tbridge fdb append dev vx20 00:00:00:00:00:00 dst 2001:db8:5::1 self\n\n\trp1_set_addr\n\tsleep 5\n}\n\n__ping_ipv4()\n{\n\tlocal vxlan_local_ip=$1; shift\n\tlocal vxlan_remote_ip=$1; shift\n\tlocal src_ip=$1; shift\n\tlocal dst_ip=$1; shift\n\tlocal dev=$1; shift\n\tlocal info=$1; shift\n\n\tRET=0\n\n\ttc filter add dev $rp1 egress protocol ipv6 pref 1 handle 101 \\\n\t\tflower ip_proto udp src_ip $vxlan_local_ip \\\n\t\tdst_ip $vxlan_remote_ip dst_port $VXPORT $TC_FLAG action pass\n\t# Match ICMP-reply packets after decapsulation, so source IP is\n\t# destination IP of the ping and destination IP is source IP of the\n\t# ping.\n\ttc filter add dev $swp1 egress protocol 802.1q pref 1 handle 101 \\\n\t\tflower vlan_ethtype ipv4 src_ip $dst_ip dst_ip $src_ip \\\n\t\t$TC_FLAG action pass\n\n\t# Send 100 packets and verify that at least 100 packets hit the rule,\n\t# to overcome ARP noise.\n\tPING_COUNT=100 PING_TIMEOUT=11 ping_do $dev $dst_ip\n\tcheck_err $? \"Ping failed\"\n\n\ttc_check_at_least_x_packets \"dev $rp1 egress\" 101 10 100\n\tcheck_err $? \"Encapsulated packets did not go through router\"\n\n\ttc_check_at_least_x_packets \"dev $swp1 egress\" 101 10 100\n\tcheck_err $? \"Decapsulated packets did not go through switch\"\n\n\tlog_test \"ping: $info\"\n\n\ttc filter del dev $swp1 egress\n\ttc filter del dev $rp1 egress\n}\n\nping_ipv4()\n{\n\tRET=0\n\n\tlocal local_sw_ip=2001:db8:3::1\n\tlocal remote_ns1_ip=2001:db8:4::1\n\tlocal remote_ns2_ip=2001:db8:5::1\n\tlocal h1_10_ip=192.0.2.1\n\tlocal h1_20_ip=198.51.100.1\n\tlocal w2_10_ns1_ip=192.0.2.3\n\tlocal w2_10_ns2_ip=192.0.2.4\n\tlocal w2_20_ns1_ip=198.51.100.3\n\tlocal w2_20_ns2_ip=198.51.100.4\n\n\tping_test $h1.10 192.0.2.2 \": local->local vid 10\"\n\tping_test $h1.20 198.51.100.2 \": local->local vid 20\"\n\n\t__ping_ipv4 $local_sw_ip $remote_ns1_ip $h1_10_ip $w2_10_ns1_ip $h1.10 \\\n\t\t\"local->remote 1 vid 10\"\n\t__ping_ipv4 $local_sw_ip $remote_ns2_ip $h1_10_ip $w2_10_ns2_ip $h1.10 \\\n\t\t\"local->remote 2 vid 10\"\n\t__ping_ipv4 $local_sw_ip $remote_ns1_ip $h1_20_ip $w2_20_ns1_ip $h1.20 \\\n\t\t\"local->remote 1 vid 20\"\n\t__ping_ipv4 $local_sw_ip $remote_ns2_ip $h1_20_ip $w2_20_ns2_ip $h1.20 \\\n\t\t\"local->remote 2 vid 20\"\n}\n\n__ping_ipv6()\n{\n\tlocal vxlan_local_ip=$1; shift\n\tlocal vxlan_remote_ip=$1; shift\n\tlocal src_ip=$1; shift\n\tlocal dst_ip=$1; shift\n\tlocal dev=$1; shift\n\tlocal info=$1; shift\n\n\tRET=0\n\n\ttc filter add dev $rp1 egress protocol ipv6 pref 1 handle 101 \\\n\t\tflower ip_proto udp src_ip $vxlan_local_ip \\\n\t\tdst_ip $vxlan_remote_ip dst_port $VXPORT $TC_FLAG action pass\n\t# Match ICMP-reply packets after decapsulation, so source IP is\n\t# destination IP of the ping and destination IP is source IP of the\n\t# ping.\n\ttc filter add dev $swp1 egress protocol 802.1q pref 1 handle 101 \\\n\t\tflower vlan_ethtype ipv6 src_ip $dst_ip dst_ip $src_ip \\\n\t\t$TC_FLAG action pass\n\n\t# Send 100 packets and verify that at least 100 packets hit the rule,\n\t# to overcome neighbor discovery noise.\n\tPING_COUNT=100 PING_TIMEOUT=11 ping6_do $dev $dst_ip\n\tcheck_err $? \"Ping failed\"\n\n\ttc_check_at_least_x_packets \"dev $rp1 egress\" 101 100\n\tcheck_err $? \"Encapsulated packets did not go through router\"\n\n\ttc_check_at_least_x_packets \"dev $swp1 egress\" 101 100\n\tcheck_err $? \"Decapsulated packets did not go through switch\"\n\n\tlog_test \"ping6: $info\"\n\n\ttc filter del dev $swp1 egress\n\ttc filter del dev $rp1 egress\n}\n\nping_ipv6()\n{\n\tRET=0\n\n\tlocal local_sw_ip=2001:db8:3::1\n\tlocal remote_ns1_ip=2001:db8:4::1\n\tlocal remote_ns2_ip=2001:db8:5::1\n\tlocal h1_10_ip=2001:db8:1::1\n\tlocal h1_20_ip=2001:db8:2::1\n\tlocal w2_10_ns1_ip=2001:db8:1::3\n\tlocal w2_10_ns2_ip=2001:db8:1::4\n\tlocal w2_20_ns1_ip=2001:db8:2::3\n\tlocal w2_20_ns2_ip=2001:db8:2::4\n\n\tping6_test $h1.10 2001:db8:1::2 \": local->local vid 10\"\n\tping6_test $h1.20 2001:db8:2::2 \": local->local vid 20\"\n\n\t__ping_ipv6 $local_sw_ip $remote_ns1_ip $h1_10_ip $w2_10_ns1_ip $h1.10 \\\n\t\t\"local->remote 1 vid 10\"\n\t__ping_ipv6 $local_sw_ip $remote_ns2_ip $h1_10_ip $w2_10_ns2_ip $h1.10 \\\n\t\t\"local->remote 2 vid 10\"\n\t__ping_ipv6 $local_sw_ip $remote_ns1_ip $h1_20_ip $w2_20_ns1_ip $h1.20 \\\n\t\t\"local->remote 1 vid 20\"\n\t__ping_ipv6 $local_sw_ip $remote_ns2_ip $h1_20_ip $w2_20_ns2_ip $h1.20 \\\n\t\t\"local->remote 2 vid 20\"\n}\n\nmaybe_in_ns()\n{\n\techo ${1:+in_ns} $1\n}\n\n__flood_counter_add_del()\n{\n\tlocal add_del=$1; shift\n\tlocal dst_ip=$1; shift\n\tlocal dev=$1; shift\n\tlocal ns=$1; shift\n\n\t# Putting the ICMP capture both to HW and to SW will end up\n\t# double-counting the packets that are trapped to slow path, such as for\n\t# the unicast test. Adding either skip_hw or skip_sw fixes this problem,\n\t# but with skip_hw, the flooded packets are not counted at all, because\n\t# those are dropped due to MAC address mismatch; and skip_sw is a no-go\n\t# for veth-based topologies.\n\t#\n\t# So try to install with skip_sw and fall back to skip_sw if that fails.\n\n\t$(maybe_in_ns $ns) tc filter $add_del dev \"$dev\" ingress \\\n\t   proto ipv6 pref 100 flower dst_ip $dst_ip ip_proto \\\n\t   icmpv6 skip_sw action pass 2>/dev/null || \\\n\t$(maybe_in_ns $ns) tc filter $add_del dev \"$dev\" ingress \\\n\t   proto ipv6 pref 100 flower dst_ip $dst_ip ip_proto \\\n\t   icmpv6 skip_hw action pass\n}\n\nflood_counter_install()\n{\n\t__flood_counter_add_del add \"$@\"\n}\n\nflood_counter_uninstall()\n{\n\t__flood_counter_add_del del \"$@\"\n}\n\nflood_fetch_stat()\n{\n\tlocal dev=$1; shift\n\tlocal ns=$1; shift\n\n\t$(maybe_in_ns $ns) tc_rule_stats_get $dev 100 ingress\n}\n\nflood_fetch_stats()\n{\n\tlocal counters=(\"${@}\")\n\tlocal counter\n\n\tfor counter in \"${counters[@]}\"; do\n\t\tflood_fetch_stat $counter\n\tdone\n}\n\nvxlan_flood_test()\n{\n\tlocal mac=$1; shift\n\tlocal dst=$1; shift\n\tlocal vid=$1; shift\n\tlocal -a expects=(\"${@}\")\n\n\tlocal -a counters=($h2 \"vx10 ns1\" \"vx20 ns1\" \"vx10 ns2\" \"vx20 ns2\")\n\tlocal counter\n\tlocal key\n\n\t# Packets reach the local host tagged whereas they reach the VxLAN\n\t# devices untagged. In order to be able to use the same filter for\n\t# all counters, make sure the packets also reach the local host\n\t# untagged\n\tbridge vlan add vid $vid dev $swp2 untagged\n\tfor counter in \"${counters[@]}\"; do\n\t\tflood_counter_install $dst $counter\n\tdone\n\n\tlocal -a t0s=($(flood_fetch_stats \"${counters[@]}\"))\n\t$MZ -6 $h1 -Q $vid -c 10 -d 100msec -p 64 -b $mac -B $dst -t icmp6 type=128 -q\n\tsleep 1\n\tlocal -a t1s=($(flood_fetch_stats \"${counters[@]}\"))\n\n\tfor key in ${!t0s[@]}; do\n\t\tlocal delta=$((t1s[$key] - t0s[$key]))\n\t\tlocal expect=${expects[$key]}\n\n\t\t((expect == delta))\n\t\tcheck_err $? \"${counters[$key]}: Expected to capture $expect packets, got $delta.\"\n\tdone\n\n\tfor counter in \"${counters[@]}\"; do\n\t\tflood_counter_uninstall $dst $counter\n\tdone\n\tbridge vlan add vid $vid dev $swp2\n}\n\n__test_flood()\n{\n\tlocal mac=$1; shift\n\tlocal dst=$1; shift\n\tlocal vid=$1; shift\n\tlocal what=$1; shift\n\tlocal -a expects=(\"${@}\")\n\n\tRET=0\n\n\tvxlan_flood_test $mac $dst $vid \"${expects[@]}\"\n\n\tlog_test \"VXLAN: $what\"\n}\n\ntest_flood()\n{\n\t__test_flood de:ad:be:ef:13:37 2001:db8:1::100 10 \"flood vlan 10\" \\\n\t\t10 10 0 10 0\n\t__test_flood ca:fe:be:ef:13:37 2001:db8:2::100 20 \"flood vlan 20\" \\\n\t\t10 0 10 0 10\n}\n\nvxlan_fdb_add_del()\n{\n\tlocal add_del=$1; shift\n\tlocal vid=$1; shift\n\tlocal mac=$1; shift\n\tlocal dev=$1; shift\n\tlocal dst=$1; shift\n\n\tbridge fdb $add_del dev $dev $mac self static permanent \\\n\t\t${dst:+dst} $dst 2>/dev/null\n\tbridge fdb $add_del dev $dev $mac master static vlan $vid 2>/dev/null\n}\n\n__test_unicast()\n{\n\tlocal mac=$1; shift\n\tlocal dst=$1; shift\n\tlocal hit_idx=$1; shift\n\tlocal vid=$1; shift\n\tlocal what=$1; shift\n\n\tRET=0\n\n\tlocal -a expects=(0 0 0 0 0)\n\texpects[$hit_idx]=10\n\n\tvxlan_flood_test $mac $dst $vid \"${expects[@]}\"\n\n\tlog_test \"VXLAN: $what\"\n}\n\ntest_unicast()\n{\n\tlocal -a targets=(\"$h2_mac $h2\"\n\t\t\t  \"$r1_mac vx10 2001:db8:4::1\"\n\t\t\t  \"$r2_mac vx10 2001:db8:5::1\")\n\tlocal target\n\n\tlog_info \"unicast vlan 10\"\n\n\tfor target in \"${targets[@]}\"; do\n\t\tvxlan_fdb_add_del add 10 $target\n\tdone\n\n\t__test_unicast $h2_mac 2001:db8:1::2 0 10 \"local MAC unicast\"\n\t__test_unicast $r1_mac 2001:db8:1::3 1 10 \"remote MAC 1 unicast\"\n\t__test_unicast $r2_mac 2001:db8:1::4 3 10 \"remote MAC 2 unicast\"\n\n\tfor target in \"${targets[@]}\"; do\n\t\tvxlan_fdb_add_del del 10 $target\n\tdone\n\n\tlog_info \"unicast vlan 20\"\n\n\ttargets=(\"$h2_mac $h2\" \"$r1_mac vx20 2001:db8:4::1\" \\\n\t\t \"$r2_mac vx20 2001:db8:5::1\")\n\n\tfor target in \"${targets[@]}\"; do\n\t\tvxlan_fdb_add_del add 20 $target\n\tdone\n\n\t__test_unicast $h2_mac 2001:db8:2::2 0 20 \"local MAC unicast\"\n\t__test_unicast $r1_mac 2001:db8:2::3 2 20 \"remote MAC 1 unicast\"\n\t__test_unicast $r2_mac 2001:db8:2::4 4 20 \"remote MAC 2 unicast\"\n\n\tfor target in \"${targets[@]}\"; do\n\t\tvxlan_fdb_add_del del 20 $target\n\tdone\n}\n\ntest_pvid()\n{\n\tlocal -a expects=(0 0 0 0 0)\n\tlocal mac=de:ad:be:ef:13:37\n\tlocal dst=2001:db8:1::100\n\tlocal vid=10\n\n\t# Check that flooding works\n\tRET=0\n\n\texpects[0]=10; expects[1]=10; expects[3]=10\n\tvxlan_flood_test $mac $dst $vid \"${expects[@]}\"\n\n\tlog_test \"VXLAN: flood before pvid off\"\n\n\t# Toggle PVID off and test that flood to remote hosts does not work\n\tRET=0\n\n\tbridge vlan add vid 10 dev vx10\n\n\texpects[0]=10; expects[1]=0; expects[3]=0\n\tvxlan_flood_test $mac $dst $vid \"${expects[@]}\"\n\n\tlog_test \"VXLAN: flood after pvid off\"\n\n\t# Toggle PVID on and test that flood to remote hosts does work\n\tRET=0\n\n\tbridge vlan add vid 10 dev vx10 pvid untagged\n\n\texpects[0]=10; expects[1]=10; expects[3]=10\n\tvxlan_flood_test $mac $dst $vid \"${expects[@]}\"\n\n\tlog_test \"VXLAN: flood after pvid on\"\n\n\t# Add a new VLAN and test that it does not affect flooding\n\tRET=0\n\n\tbridge vlan add vid 30 dev vx10\n\n\texpects[0]=10; expects[1]=10; expects[3]=10\n\tvxlan_flood_test $mac $dst $vid \"${expects[@]}\"\n\n\tbridge vlan del vid 30 dev vx10\n\n\tlog_test \"VXLAN: flood after vlan add\"\n\n\t# Remove currently mapped VLAN and test that flood to remote hosts does\n\t# not work\n\tRET=0\n\n\tbridge vlan del vid 10 dev vx10\n\n\texpects[0]=10; expects[1]=0; expects[3]=0\n\tvxlan_flood_test $mac $dst $vid \"${expects[@]}\"\n\n\tlog_test \"VXLAN: flood after vlan delete\"\n\n\t# Re-add the VLAN and test that flood to remote hosts does work\n\tRET=0\n\n\tbridge vlan add vid 10 dev vx10 pvid untagged\n\n\texpects[0]=10; expects[1]=10; expects[3]=10\n\tvxlan_flood_test $mac $dst $vid \"${expects[@]}\"\n\n\tlog_test \"VXLAN: flood after vlan re-add\"\n}\n\ntest_all()\n{\n\tlog_info \"Running tests with UDP port $VXPORT\"\n\ttests_run\n}\n\ntrap cleanup EXIT\n\nsetup_prepare\nsetup_wait\ntest_all\n\nexit $EXIT_STATUS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}