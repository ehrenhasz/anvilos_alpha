{
  "module_name": "devlink_lib.sh",
  "hash_id": "d769a20a5b657ff02b99ec3376905b9d238d062896b100491b151bc8bf6d6d55",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/forwarding/devlink_lib.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\n##############################################################################\n# Defines\n\nif [[ ! -v DEVLINK_DEV ]]; then\n\tDEVLINK_DEV=$(devlink port show \"${NETIFS[p1]:-$NETIF_NO_CABLE}\" -j \\\n\t\t\t     | jq -r '.port | keys[]' | cut -d/ -f-2)\n\tif [ -z \"$DEVLINK_DEV\" ]; then\n\t\techo \"SKIP: ${NETIFS[p1]} has no devlink device registered for it\"\n\t\texit $ksft_skip\n\tfi\n\tif [[ \"$(echo $DEVLINK_DEV | grep -c pci)\" -eq 0 ]]; then\n\t\techo \"SKIP: devlink device's bus is not PCI\"\n\t\texit $ksft_skip\n\tfi\n\n\tDEVLINK_VIDDID=$(lspci -s $(echo $DEVLINK_DEV | cut -d\"/\" -f2) \\\n\t\t\t -n | cut -d\" \" -f3)\nelif [[ ! -z \"$DEVLINK_DEV\" ]]; then\n\tdevlink dev show $DEVLINK_DEV &> /dev/null\n\tif [ $? -ne 0 ]; then\n\t\techo \"SKIP: devlink device \\\"$DEVLINK_DEV\\\" not found\"\n\t\texit $ksft_skip\n\tfi\nfi\n\n##############################################################################\n# Sanity checks\n\ndevlink help 2>&1 | grep resource &> /dev/null\nif [ $? -ne 0 ]; then\n\techo \"SKIP: iproute2 too old, missing devlink resource support\"\n\texit $ksft_skip\nfi\n\ndevlink help 2>&1 | grep trap &> /dev/null\nif [ $? -ne 0 ]; then\n\techo \"SKIP: iproute2 too old, missing devlink trap support\"\n\texit $ksft_skip\nfi\n\ndevlink dev help 2>&1 | grep info &> /dev/null\nif [ $? -ne 0 ]; then\n\techo \"SKIP: iproute2 too old, missing devlink dev info support\"\n\texit $ksft_skip\nfi\n\n##############################################################################\n# Devlink helpers\n\ndevlink_resource_names_to_path()\n{\n\tlocal resource\n\tlocal path=\"\"\n\n\tfor resource in \"${@}\"; do\n\t\tif [ \"$path\" == \"\" ]; then\n\t\t\tpath=\"$resource\"\n\t\telse\n\t\t\tpath=\"${path}/$resource\"\n\t\tfi\n\tdone\n\n\techo \"$path\"\n}\n\ndevlink_resource_get()\n{\n\tlocal name=$1\n\tlocal resource_name=.[][\\\"$DEVLINK_DEV\\\"]\n\n\tresource_name=\"$resource_name | .[] | select (.name == \\\"$name\\\")\"\n\n\tshift\n\tfor resource in \"${@}\"; do\n\t\tresource_name=\"${resource_name} | .[\\\"resources\\\"][] | \\\n\t\t\t       select (.name == \\\"$resource\\\")\"\n\tdone\n\n\tdevlink -j resource show \"$DEVLINK_DEV\" | jq \"$resource_name\"\n}\n\ndevlink_resource_size_get()\n{\n\tlocal size=$(devlink_resource_get \"$@\" | jq '.[\"size_new\"]')\n\n\tif [ \"$size\" == \"null\" ]; then\n\t\tdevlink_resource_get \"$@\" | jq '.[\"size\"]'\n\telse\n\t\techo \"$size\"\n\tfi\n}\n\ndevlink_resource_size_set()\n{\n\tlocal new_size=$1\n\tlocal path\n\n\tshift\n\tpath=$(devlink_resource_names_to_path \"$@\")\n\tdevlink resource set \"$DEVLINK_DEV\" path \"$path\" size \"$new_size\"\n\tcheck_err $? \"Failed setting path $path to size $size\"\n}\n\ndevlink_resource_occ_get()\n{\n\tdevlink_resource_get \"$@\" | jq '.[\"occ\"]'\n}\n\ndevlink_reload()\n{\n\tlocal still_pending\n\n\tdevlink dev reload \"$DEVLINK_DEV\" &> /dev/null\n\tcheck_err $? \"Failed reload\"\n\n\tstill_pending=$(devlink resource show \"$DEVLINK_DEV\" | \\\n\t\t\tgrep -c \"size_new\")\n\tcheck_err $still_pending \"Failed reload - There are still unset sizes\"\n}\n\ndeclare -A DEVLINK_ORIG\n\n# Changing pool type from static to dynamic causes reinterpretation of threshold\n# values. They therefore need to be saved before pool type is changed, then the\n# pool type can be changed, and then the new values need to be set up. Therefore\n# instead of saving the current state implicitly in the _set call, provide\n# functions for all three primitives: save, set, and restore.\n\ndevlink_port_pool_threshold()\n{\n\tlocal port=$1; shift\n\tlocal pool=$1; shift\n\n\tdevlink sb port pool show $port pool $pool -j \\\n\t\t| jq '.port_pool.\"'\"$port\"'\"[].threshold'\n}\n\ndevlink_port_pool_th_save()\n{\n\tlocal port=$1; shift\n\tlocal pool=$1; shift\n\tlocal key=\"port_pool($port,$pool).threshold\"\n\n\tDEVLINK_ORIG[$key]=$(devlink_port_pool_threshold $port $pool)\n}\n\ndevlink_port_pool_th_set()\n{\n\tlocal port=$1; shift\n\tlocal pool=$1; shift\n\tlocal th=$1; shift\n\n\tdevlink sb port pool set $port pool $pool th $th\n}\n\ndevlink_port_pool_th_restore()\n{\n\tlocal port=$1; shift\n\tlocal pool=$1; shift\n\tlocal key=\"port_pool($port,$pool).threshold\"\n\tlocal -a orig=(${DEVLINK_ORIG[$key]})\n\n\tif [[ -z $orig ]]; then\n\t\techo \"WARNING: Mismatched devlink_port_pool_th_restore\"\n\telse\n\t\tdevlink sb port pool set $port pool $pool th $orig\n\tfi\n}\n\ndevlink_pool_size_thtype()\n{\n\tlocal pool=$1; shift\n\n\tdevlink sb pool show \"$DEVLINK_DEV\" pool $pool -j \\\n\t    | jq -r '.pool[][] | (.size, .thtype)'\n}\n\ndevlink_pool_size_thtype_save()\n{\n\tlocal pool=$1; shift\n\tlocal key=\"pool($pool).size_thtype\"\n\n\tDEVLINK_ORIG[$key]=$(devlink_pool_size_thtype $pool)\n}\n\ndevlink_pool_size_thtype_set()\n{\n\tlocal pool=$1; shift\n\tlocal thtype=$1; shift\n\tlocal size=$1; shift\n\n\tdevlink sb pool set \"$DEVLINK_DEV\" pool $pool size $size thtype $thtype\n}\n\ndevlink_pool_size_thtype_restore()\n{\n\tlocal pool=$1; shift\n\tlocal key=\"pool($pool).size_thtype\"\n\tlocal -a orig=(${DEVLINK_ORIG[$key]})\n\n\tif [[ -z ${orig[0]} ]]; then\n\t\techo \"WARNING: Mismatched devlink_pool_size_thtype_restore\"\n\telse\n\t\tdevlink sb pool set \"$DEVLINK_DEV\" pool $pool \\\n\t\t\tsize ${orig[0]} thtype ${orig[1]}\n\tfi\n}\n\ndevlink_tc_bind_pool_th()\n{\n\tlocal port=$1; shift\n\tlocal tc=$1; shift\n\tlocal dir=$1; shift\n\n\tdevlink sb tc bind show $port tc $tc type $dir -j \\\n\t    | jq -r '.tc_bind[][] | (.pool, .threshold)'\n}\n\ndevlink_tc_bind_pool_th_save()\n{\n\tlocal port=$1; shift\n\tlocal tc=$1; shift\n\tlocal dir=$1; shift\n\tlocal key=\"tc_bind($port,$dir,$tc).pool_th\"\n\n\tDEVLINK_ORIG[$key]=$(devlink_tc_bind_pool_th $port $tc $dir)\n}\n\ndevlink_tc_bind_pool_th_set()\n{\n\tlocal port=$1; shift\n\tlocal tc=$1; shift\n\tlocal dir=$1; shift\n\tlocal pool=$1; shift\n\tlocal th=$1; shift\n\n\tdevlink sb tc bind set $port tc $tc type $dir pool $pool th $th\n}\n\ndevlink_tc_bind_pool_th_restore()\n{\n\tlocal port=$1; shift\n\tlocal tc=$1; shift\n\tlocal dir=$1; shift\n\tlocal key=\"tc_bind($port,$dir,$tc).pool_th\"\n\tlocal -a orig=(${DEVLINK_ORIG[$key]})\n\n\tif [[ -z ${orig[0]} ]]; then\n\t\techo \"WARNING: Mismatched devlink_tc_bind_pool_th_restore\"\n\telse\n\t\tdevlink sb tc bind set $port tc $tc type $dir \\\n\t\t\tpool ${orig[0]} th ${orig[1]}\n\tfi\n}\n\ndevlink_traps_num_get()\n{\n\tdevlink -j trap | jq '.[][\"'$DEVLINK_DEV'\"] | length'\n}\n\ndevlink_traps_get()\n{\n\tdevlink -j trap | jq -r '.[][\"'$DEVLINK_DEV'\"][].name'\n}\n\ndevlink_trap_type_get()\n{\n\tlocal trap_name=$1; shift\n\n\tdevlink -j trap show $DEVLINK_DEV trap $trap_name \\\n\t\t| jq -r '.[][][].type'\n}\n\ndevlink_trap_action_set()\n{\n\tlocal trap_name=$1; shift\n\tlocal action=$1; shift\n\n\t# Pipe output to /dev/null to avoid expected warnings.\n\tdevlink trap set $DEVLINK_DEV trap $trap_name \\\n\t\taction $action &> /dev/null\n}\n\ndevlink_trap_action_get()\n{\n\tlocal trap_name=$1; shift\n\n\tdevlink -j trap show $DEVLINK_DEV trap $trap_name \\\n\t\t| jq -r '.[][][].action'\n}\n\ndevlink_trap_group_get()\n{\n\tdevlink -j trap show $DEVLINK_DEV trap $trap_name \\\n\t\t| jq -r '.[][][].group'\n}\n\ndevlink_trap_metadata_test()\n{\n\tlocal trap_name=$1; shift\n\tlocal metadata=$1; shift\n\n\tdevlink -jv trap show $DEVLINK_DEV trap $trap_name \\\n\t\t| jq -e '.[][][].metadata | contains([\"'$metadata'\"])' \\\n\t\t&> /dev/null\n}\n\ndevlink_trap_rx_packets_get()\n{\n\tlocal trap_name=$1; shift\n\n\tdevlink -js trap show $DEVLINK_DEV trap $trap_name \\\n\t\t| jq '.[][][][\"stats\"][\"rx\"][\"packets\"]'\n}\n\ndevlink_trap_rx_bytes_get()\n{\n\tlocal trap_name=$1; shift\n\n\tdevlink -js trap show $DEVLINK_DEV trap $trap_name \\\n\t\t| jq '.[][][][\"stats\"][\"rx\"][\"bytes\"]'\n}\n\ndevlink_trap_drop_packets_get()\n{\n\tlocal trap_name=$1; shift\n\n\tdevlink -js trap show $DEVLINK_DEV trap $trap_name \\\n\t\t| jq '.[][][][\"stats\"][\"rx\"][\"dropped\"]'\n}\n\ndevlink_trap_stats_idle_test()\n{\n\tlocal trap_name=$1; shift\n\tlocal t0_packets t0_bytes\n\tlocal t1_packets t1_bytes\n\n\tt0_packets=$(devlink_trap_rx_packets_get $trap_name)\n\tt0_bytes=$(devlink_trap_rx_bytes_get $trap_name)\n\n\tsleep 1\n\n\tt1_packets=$(devlink_trap_rx_packets_get $trap_name)\n\tt1_bytes=$(devlink_trap_rx_bytes_get $trap_name)\n\n\tif [[ $t0_packets -eq $t1_packets && $t0_bytes -eq $t1_bytes ]]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\ndevlink_trap_drop_stats_idle_test()\n{\n\tlocal trap_name=$1; shift\n\tlocal t0_packets t0_bytes\n\n\tt0_packets=$(devlink_trap_drop_packets_get $trap_name)\n\n\tsleep 1\n\n\tt1_packets=$(devlink_trap_drop_packets_get $trap_name)\n\n\tif [[ $t0_packets -eq $t1_packets ]]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\ndevlink_traps_enable_all()\n{\n\tlocal trap_name\n\n\tfor trap_name in $(devlink_traps_get); do\n\t\tdevlink_trap_action_set $trap_name \"trap\"\n\tdone\n}\n\ndevlink_traps_disable_all()\n{\n\tfor trap_name in $(devlink_traps_get); do\n\t\tdevlink_trap_action_set $trap_name \"drop\"\n\tdone\n}\n\ndevlink_trap_groups_get()\n{\n\tdevlink -j trap group | jq -r '.[][\"'$DEVLINK_DEV'\"][].name'\n}\n\ndevlink_trap_group_action_set()\n{\n\tlocal group_name=$1; shift\n\tlocal action=$1; shift\n\n\t# Pipe output to /dev/null to avoid expected warnings.\n\tdevlink trap group set $DEVLINK_DEV group $group_name action $action \\\n\t\t&> /dev/null\n}\n\ndevlink_trap_group_rx_packets_get()\n{\n\tlocal group_name=$1; shift\n\n\tdevlink -js trap group show $DEVLINK_DEV group $group_name \\\n\t\t| jq '.[][][][\"stats\"][\"rx\"][\"packets\"]'\n}\n\ndevlink_trap_group_rx_bytes_get()\n{\n\tlocal group_name=$1; shift\n\n\tdevlink -js trap group show $DEVLINK_DEV group $group_name \\\n\t\t| jq '.[][][][\"stats\"][\"rx\"][\"bytes\"]'\n}\n\ndevlink_trap_group_stats_idle_test()\n{\n\tlocal group_name=$1; shift\n\tlocal t0_packets t0_bytes\n\tlocal t1_packets t1_bytes\n\n\tt0_packets=$(devlink_trap_group_rx_packets_get $group_name)\n\tt0_bytes=$(devlink_trap_group_rx_bytes_get $group_name)\n\n\tsleep 1\n\n\tt1_packets=$(devlink_trap_group_rx_packets_get $group_name)\n\tt1_bytes=$(devlink_trap_group_rx_bytes_get $group_name)\n\n\tif [[ $t0_packets -eq $t1_packets && $t0_bytes -eq $t1_bytes ]]; then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n}\n\ndevlink_trap_exception_test()\n{\n\tlocal trap_name=$1; shift\n\tlocal group_name\n\n\tgroup_name=$(devlink_trap_group_get $trap_name)\n\n\tdevlink_trap_stats_idle_test $trap_name\n\tcheck_fail $? \"Trap stats idle when packets should have been trapped\"\n\n\tdevlink_trap_group_stats_idle_test $group_name\n\tcheck_fail $? \"Trap group idle when packets should have been trapped\"\n}\n\ndevlink_trap_drop_test()\n{\n\tlocal trap_name=$1; shift\n\tlocal dev=$1; shift\n\tlocal handle=$1; shift\n\tlocal group_name\n\n\tgroup_name=$(devlink_trap_group_get $trap_name)\n\n\t# This is the common part of all the tests. It checks that stats are\n\t# initially idle, then non-idle after changing the trap action and\n\t# finally idle again. It also makes sure the packets are dropped and\n\t# never forwarded.\n\tdevlink_trap_stats_idle_test $trap_name\n\tcheck_err $? \"Trap stats not idle with initial drop action\"\n\tdevlink_trap_group_stats_idle_test $group_name\n\tcheck_err $? \"Trap group stats not idle with initial drop action\"\n\n\tdevlink_trap_action_set $trap_name \"trap\"\n\tdevlink_trap_stats_idle_test $trap_name\n\tcheck_fail $? \"Trap stats idle after setting action to trap\"\n\tdevlink_trap_group_stats_idle_test $group_name\n\tcheck_fail $? \"Trap group stats idle after setting action to trap\"\n\n\tdevlink_trap_action_set $trap_name \"drop\"\n\n\tdevlink_trap_stats_idle_test $trap_name\n\tcheck_err $? \"Trap stats not idle after setting action to drop\"\n\tdevlink_trap_group_stats_idle_test $group_name\n\tcheck_err $? \"Trap group stats not idle after setting action to drop\"\n\n\ttc_check_packets \"dev $dev egress\" $handle 0\n\tcheck_err $? \"Packets were not dropped\"\n}\n\ndevlink_trap_drop_cleanup()\n{\n\tlocal mz_pid=$1; shift\n\tlocal dev=$1; shift\n\tlocal proto=$1; shift\n\tlocal pref=$1; shift\n\tlocal handle=$1; shift\n\n\tkill $mz_pid && wait $mz_pid &> /dev/null\n\ttc filter del dev $dev egress protocol $proto pref $pref handle $handle flower\n}\n\ndevlink_trap_stats_check()\n{\n\tlocal trap_name=$1; shift\n\tlocal send_one=\"$@\"\n\tlocal t0_packets\n\tlocal t1_packets\n\n\tt0_packets=$(devlink_trap_rx_packets_get $trap_name)\n\n\t$send_one && sleep 1\n\n\tt1_packets=$(devlink_trap_rx_packets_get $trap_name)\n\n\t[[ $t1_packets -ne $t0_packets ]]\n}\n\ndevlink_trap_stats_test()\n{\n\tlocal test_name=$1; shift\n\n\tRET=0\n\n\tdevlink_trap_stats_check \"$@\"\n\tcheck_err $? \"Trap stats did not increase\"\n\n\tlog_test \"$test_name\"\n}\n\ndevlink_trap_policers_num_get()\n{\n\tdevlink -j -p trap policer show | jq '.[][\"'$DEVLINK_DEV'\"] | length'\n}\n\ndevlink_trap_policer_rate_get()\n{\n\tlocal policer_id=$1; shift\n\n\tdevlink -j -p trap policer show $DEVLINK_DEV policer $policer_id \\\n\t\t| jq '.[][][][\"rate\"]'\n}\n\ndevlink_trap_policer_burst_get()\n{\n\tlocal policer_id=$1; shift\n\n\tdevlink -j -p trap policer show $DEVLINK_DEV policer $policer_id \\\n\t\t| jq '.[][][][\"burst\"]'\n}\n\ndevlink_trap_policer_rx_dropped_get()\n{\n\tlocal policer_id=$1; shift\n\n\tdevlink -j -p -s trap policer show $DEVLINK_DEV policer $policer_id \\\n\t\t| jq '.[][][][\"stats\"][\"rx\"][\"dropped\"]'\n}\n\ndevlink_trap_group_policer_get()\n{\n\tlocal group_name=$1; shift\n\n\tdevlink -j -p trap group show $DEVLINK_DEV group $group_name \\\n\t\t| jq '.[][][][\"policer\"]'\n}\n\ndevlink_port_by_netdev()\n{\n\tlocal if_name=$1\n\n\tdevlink -j port show $if_name | jq -e '.[] | keys' | jq -r '.[]'\n}\n\ndevlink_cpu_port_get()\n{\n\tlocal cpu_dl_port_num=$(devlink port list | grep \"$DEVLINK_DEV\" |\n\t\t\t\tgrep cpu | cut -d/ -f3 | cut -d: -f1 |\n\t\t\t\tsed -n '1p')\n\n\techo \"$DEVLINK_DEV/$cpu_dl_port_num\"\n}\n\ndevlink_cell_size_get()\n{\n\tdevlink sb pool show \"$DEVLINK_DEV\" pool 0 -j \\\n\t    | jq '.pool[][].cell_size'\n}\n\ndevlink_pool_size_get()\n{\n\tdevlink sb show \"$DEVLINK_DEV\" -j | jq '.[][][][\"size\"]'\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}