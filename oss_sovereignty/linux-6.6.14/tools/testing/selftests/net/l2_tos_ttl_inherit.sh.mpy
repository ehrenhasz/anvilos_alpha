{
  "module_name": "l2_tos_ttl_inherit.sh",
  "hash_id": "bfab5ce10129ab0722c5ad12021f5ca26e7ba29630c53f9c8ffb79ed90487d10",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/l2_tos_ttl_inherit.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n\n# Author: Matthias May <matthias.may@westermo.com>\n#\n# This script evaluates ip tunnels that are capable of carrying L2 traffic\n# if they inherit or set the inheritable fields.\n# Namely these tunnels are: 'gretap', 'vxlan' and 'geneve'.\n# Checked inheritable fields are: TOS and TTL.\n# The outer tunnel protocol of 'IPv4' or 'IPv6' is verified-\n# As payload frames of type 'IPv4', 'IPv6' and 'other'(ARP) are verified.\n# In addition this script also checks if forcing a specific field in the\n# outer header is working.\n\n# Return 4 by default (Kselftest SKIP code)\nERR=4\n\nif [ \"$(id -u)\" != \"0\" ]; then\n\techo \"Please run as root.\"\n\texit $ERR\nfi\nif ! which tcpdump > /dev/null 2>&1; then\n\techo \"No tcpdump found. Required for this test.\"\n\texit $ERR\nfi\n\nexpected_tos=\"0x00\"\nexpected_ttl=\"0\"\nfailed=false\n\nreadonly NS0=$(mktemp -u ns0-XXXXXXXX)\nreadonly NS1=$(mktemp -u ns1-XXXXXXXX)\n\nRUN_NS0=\"ip netns exec ${NS0}\"\n\nget_random_tos() {\n\t# Get a random hex tos value between 0x00 and 0xfc, a multiple of 4\n\techo \"0x$(tr -dc '0-9a-f' < /dev/urandom | head -c 1)\\\n$(tr -dc '048c' < /dev/urandom | head -c 1)\"\n}\nget_random_ttl() {\n\t# Get a random dec value between 0 and 255\n\tprintf \"%d\" \"0x$(tr -dc '0-9a-f' < /dev/urandom | head -c 2)\"\n}\nget_field() {\n\t# Expects to get the 'head -n 1' of a captured frame by tcpdump.\n\t# Parses this first line and returns the specified field.\n\tlocal field=\"$1\"\n\tlocal input=\"$2\"\n\tlocal found=false\n\tinput=\"$(echo \"$input\" | tr -d '(),')\"\n\tfor input_field in $input; do\n\t\tif $found; then\n\t\t\techo \"$input_field\"\n\t\t\treturn\n\t\tfi\n\t\t# The next field that we iterate over is the looked for value\n\t\tif [ \"$input_field\" = \"$field\" ]; then\n\t\t\tfound=true\n\t\tfi\n\tdone\n\techo \"0\"\n}\nsetup() {\n\tlocal type=\"$1\"\n\tlocal outer=\"$2\"\n\tlocal inner=\"$3\"\n\tlocal tos_ttl=\"$4\"\n\tlocal vlan=\"$5\"\n\tlocal test_tos=\"0x00\"\n\tlocal test_ttl=\"0\"\n\n\t# We don't want a test-tos of 0x00,\n\t# because this is the value that we get when no tos is set.\n\texpected_tos=\"$(get_random_tos)\"\n\twhile [ \"$expected_tos\" = \"0x00\" ]; do\n\t\texpected_tos=\"$(get_random_tos)\"\n\tdone\n\tif [ \"$tos_ttl\" = \"random\" ]; then\n\t\ttest_tos=\"$expected_tos\"\n\t\ttos=\"fixed $test_tos\"\n\telif [ \"$tos_ttl\" = \"inherit\" ]; then\n\t\ttest_tos=\"$tos_ttl\"\n\t\ttos=\"inherit $expected_tos\"\n\tfi\n\n\t# We don't want a test-ttl of 64 or 0,\n\t# because 64 is when no ttl is set and 0 is not a valid ttl.\n\texpected_ttl=\"$(get_random_ttl)\"\n\twhile [ \"$expected_ttl\" = \"64\" ] || [ \"$expected_ttl\" = \"0\" ]; do\n\t\texpected_ttl=\"$(get_random_ttl)\"\n\tdone\n\n\tif [ \"$tos_ttl\" = \"random\" ]; then\n\t\ttest_ttl=\"$expected_ttl\"\n\t\tttl=\"fixed $test_ttl\"\n\telif [ \"$tos_ttl\" = \"inherit\" ]; then\n\t\ttest_ttl=\"$tos_ttl\"\n\t\tttl=\"inherit $expected_ttl\"\n\tfi\n\tprintf \"\u2502%7s \u2502%6s \u2502%6s \u2502%13s \u2502%13s \u2502%6s \u2502\" \\\n\t\"$type\" \"$outer\" \"$inner\" \"$tos\" \"$ttl\" \"$vlan\"\n\n\t# Create netns NS0 and NS1 and connect them with a veth pair\n\tip netns add \"${NS0}\"\n\tip netns add \"${NS1}\"\n\tip link add name veth0 netns \"${NS0}\" type veth \\\n\t\tpeer name veth1 netns \"${NS1}\"\n\tip -netns \"${NS0}\" link set dev veth0 up\n\tip -netns \"${NS1}\" link set dev veth1 up\n\tip -netns \"${NS0}\" address flush dev veth0\n\tip -netns \"${NS1}\" address flush dev veth1\n\n\tlocal local_addr1=\"\"\n\tlocal local_addr2=\"\"\n\tif [ \"$type\" = \"gre\" ] || [ \"$type\" = \"vxlan\" ]; then\n\t\tif [ \"$outer\" = \"4\" ]; then\n\t\t\tlocal_addr1=\"local 198.18.0.1\"\n\t\t\tlocal_addr2=\"local 198.18.0.2\"\n\t\telif [ \"$outer\" = \"6\" ]; then\n\t\t\tlocal_addr1=\"local fdd1:ced0:5d88:3fce::1\"\n\t\t\tlocal_addr2=\"local fdd1:ced0:5d88:3fce::2\"\n\t\tfi\n\tfi\n\tlocal vxlan=\"\"\n\tif [ \"$type\" = \"vxlan\" ]; then\n\t\tvxlan=\"vni 100 dstport 4789\"\n\tfi\n\tlocal geneve=\"\"\n\tif [ \"$type\" = \"geneve\" ]; then\n\t\tgeneve=\"vni 100\"\n\tfi\n\t# Create tunnel and assign outer IPv4/IPv6 addresses\n\tif [ \"$outer\" = \"4\" ]; then\n\t\tif [ \"$type\" = \"gre\" ]; then\n\t\t\ttype=\"gretap\"\n\t\tfi\n\t\tip -netns \"${NS0}\" address add 198.18.0.1/24 dev veth0\n\t\tip -netns \"${NS1}\" address add 198.18.0.2/24 dev veth1\n\t\tip -netns \"${NS0}\" link add name tep0 type $type $local_addr1 \\\n\t\t\tremote 198.18.0.2 tos $test_tos ttl $test_ttl         \\\n\t\t\t$vxlan $geneve\n\t\tip -netns \"${NS1}\" link add name tep1 type $type $local_addr2 \\\n\t\t\tremote 198.18.0.1 tos $test_tos ttl $test_ttl         \\\n\t\t\t$vxlan $geneve\n\telif [ \"$outer\" = \"6\" ]; then\n\t\tif [ \"$type\" = \"gre\" ]; then\n\t\t\ttype=\"ip6gretap\"\n\t\tfi\n\t\tip -netns \"${NS0}\" address add fdd1:ced0:5d88:3fce::1/64 \\\n\t\t\tdev veth0 nodad\n\t\tip -netns \"${NS1}\" address add fdd1:ced0:5d88:3fce::2/64 \\\n\t\t\tdev veth1 nodad\n\t\tip -netns \"${NS0}\" link add name tep0 type $type $local_addr1 \\\n\t\t\tremote fdd1:ced0:5d88:3fce::2 tos $test_tos           \\\n\t\t\tttl $test_ttl $vxlan $geneve\n\t\tip -netns \"${NS1}\" link add name tep1 type $type $local_addr2 \\\n\t\t\tremote fdd1:ced0:5d88:3fce::1 tos $test_tos           \\\n\t\t\tttl $test_ttl $vxlan $geneve\n\tfi\n\n\t# Bring L2-tunnel link up and create VLAN on top\n\tip -netns \"${NS0}\" link set tep0 up\n\tip -netns \"${NS1}\" link set tep1 up\n\tip -netns \"${NS0}\" address flush dev tep0\n\tip -netns \"${NS1}\" address flush dev tep1\n\tlocal parent\n\tif $vlan; then\n\t\tparent=\"vlan99-\"\n\t\tip -netns \"${NS0}\" link add link tep0 name ${parent}0 \\\n\t\t\ttype vlan id 99\n\t\tip -netns \"${NS1}\" link add link tep1 name ${parent}1 \\\n\t\t\ttype vlan id 99\n\t\tip -netns \"${NS0}\" link set dev ${parent}0 up\n\t\tip -netns \"${NS1}\" link set dev ${parent}1 up\n\t\tip -netns \"${NS0}\" address flush dev ${parent}0\n\t\tip -netns \"${NS1}\" address flush dev ${parent}1\n\telse\n\t\tparent=\"tep\"\n\tfi\n\n\t# Assign inner IPv4/IPv6 addresses\n\tif [ \"$inner\" = \"4\" ] || [ \"$inner\" = \"other\" ]; then\n\t\tip -netns \"${NS0}\" address add 198.19.0.1/24 brd + dev ${parent}0\n\t\tip -netns \"${NS1}\" address add 198.19.0.2/24 brd + dev ${parent}1\n\telif [ \"$inner\" = \"6\" ]; then\n\t\tip -netns \"${NS0}\" address add fdd4:96cf:4eae:443b::1/64 \\\n\t\t\tdev ${parent}0 nodad\n\t\tip -netns \"${NS1}\" address add fdd4:96cf:4eae:443b::2/64 \\\n\t\t\tdev ${parent}1 nodad\n\tfi\n}\n\nverify() {\n\tlocal outer=\"$1\"\n\tlocal inner=\"$2\"\n\tlocal tos_ttl=\"$3\"\n\tlocal vlan=\"$4\"\n\n\tlocal ping_pid out captured_tos captured_ttl result\n\n\tlocal ping_dst\n\tif [ \"$inner\" = \"4\" ]; then\n\t\tping_dst=\"198.19.0.2\"\n\telif [ \"$inner\" = \"6\" ]; then\n\t\tping_dst=\"fdd4:96cf:4eae:443b::2\"\n\telif [ \"$inner\" = \"other\" ]; then\n\t\tping_dst=\"198.19.0.3\" # Generates ARPs which are not IPv4/IPv6\n\tfi\n\tif [ \"$tos_ttl\" = \"inherit\" ]; then\n\t\t${RUN_NS0} ping -i 0.1 $ping_dst -Q \"$expected_tos\"          \\\n\t\t\t -t \"$expected_ttl\" 2>/dev/null 1>&2 & ping_pid=\"$!\"\n\telse\n\t\t${RUN_NS0} ping -i 0.1 $ping_dst 2>/dev/null 1>&2 & ping_pid=\"$!\"\n\tfi\n\tlocal tunnel_type_offset tunnel_type_proto req_proto_offset req_offset\n\tif [ \"$type\" = \"gre\" ]; then\n\t\ttunnel_type_proto=\"0x2f\"\n\telif [ \"$type\" = \"vxlan\" ] || [ \"$type\" = \"geneve\" ]; then\n\t\ttunnel_type_proto=\"0x11\"\n\tfi\n\tif [ \"$outer\" = \"4\" ]; then\n\t\ttunnel_type_offset=\"9\"\n\t\tif [ \"$inner\" = \"4\" ]; then\n\t\t\treq_proto_offset=\"47\"\n\t\t\treq_offset=\"58\"\n\t\t\tif [ \"$type\" = \"vxlan\" ] || [ \"$type\" = \"geneve\" ]; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 12))\"\n\t\t\t\treq_offset=\"$((req_offset + 12))\"\n\t\t\tfi\n\t\t\tif $vlan; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 4))\"\n\t\t\t\treq_offset=\"$((req_offset + 4))\"\n\t\t\tfi\n\t\t\tout=\"$(${RUN_NS0} tcpdump --immediate-mode -p -c 1 -v \\\n\t\t\t\t-i veth0 -n                                   \\\n\t\t\t\tip[$tunnel_type_offset] = $tunnel_type_proto and \\\n\t\t\t\tip[$req_proto_offset] = 0x01 and              \\\n\t\t\t\tip[$req_offset] = 0x08 2>/dev/null            \\\n\t\t\t\t| head -n 1)\"\n\t\telif [ \"$inner\" = \"6\" ]; then\n\t\t\treq_proto_offset=\"44\"\n\t\t\treq_offset=\"78\"\n\t\t\tif [ \"$type\" = \"vxlan\" ] || [ \"$type\" = \"geneve\" ]; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 12))\"\n\t\t\t\treq_offset=\"$((req_offset + 12))\"\n\t\t\tfi\n\t\t\tif $vlan; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 4))\"\n\t\t\t\treq_offset=\"$((req_offset + 4))\"\n\t\t\tfi\n\t\t\tout=\"$(${RUN_NS0} tcpdump --immediate-mode -p -c 1 -v \\\n\t\t\t\t-i veth0 -n                                   \\\n\t\t\t\tip[$tunnel_type_offset] = $tunnel_type_proto and \\\n\t\t\t\tip[$req_proto_offset] = 0x3a and              \\\n\t\t\t\tip[$req_offset] = 0x80 2>/dev/null            \\\n\t\t\t\t| head -n 1)\"\n\t\telif [ \"$inner\" = \"other\" ]; then\n\t\t\treq_proto_offset=\"36\"\n\t\t\treq_offset=\"45\"\n\t\t\tif [ \"$type\" = \"vxlan\" ] || [ \"$type\" = \"geneve\" ]; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 12))\"\n\t\t\t\treq_offset=\"$((req_offset + 12))\"\n\t\t\tfi\n\t\t\tif $vlan; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 4))\"\n\t\t\t\treq_offset=\"$((req_offset + 4))\"\n\t\t\tfi\n\t\t\tif [ \"$tos_ttl\" = \"inherit\" ]; then\n\t\t\t\texpected_tos=\"0x00\"\n\t\t\t\texpected_ttl=\"64\"\n\t\t\tfi\n\t\t\tout=\"$(${RUN_NS0} tcpdump --immediate-mode -p -c 1 -v \\\n\t\t\t\t-i veth0 -n                                   \\\n\t\t\t\tip[$tunnel_type_offset] = $tunnel_type_proto and \\\n\t\t\t\tip[$req_proto_offset] = 0x08 and              \\\n\t\t\t\tip[$((req_proto_offset + 1))] = 0x06 and      \\\n\t\t\t\tip[$req_offset] = 0x01 2>/dev/null            \\\n\t\t\t\t| head -n 1)\"\n\t\tfi\n\telif [ \"$outer\" = \"6\" ]; then\n\t\tif [ \"$type\" = \"gre\" ]; then\n\t\t\ttunnel_type_offset=\"40\"\n\t\telif [ \"$type\" = \"vxlan\" ] || [ \"$type\" = \"geneve\" ]; then\n\t\t\ttunnel_type_offset=\"6\"\n\t\tfi\n\t\tif [ \"$inner\" = \"4\" ]; then\n\t\t\tlocal req_proto_offset=\"75\"\n\t\t\tlocal req_offset=\"86\"\n\t\t\tif [ \"$type\" = \"vxlan\" ] || [ \"$type\" = \"geneve\" ]; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 4))\"\n\t\t\t\treq_offset=\"$((req_offset + 4))\"\n\t\t\tfi\n\t\t\tif $vlan; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 4))\"\n\t\t\t\treq_offset=\"$((req_offset + 4))\"\n\t\t\tfi\n\t\t\tout=\"$(${RUN_NS0} tcpdump --immediate-mode -p -c 1 -v \\\n\t\t\t\t-i veth0 -n                                   \\\n\t\t\t\tip6[$tunnel_type_offset] = $tunnel_type_proto and \\\n\t\t\t\tip6[$req_proto_offset] = 0x01 and             \\\n\t\t\t\tip6[$req_offset] = 0x08 2>/dev/null           \\\n\t\t\t\t| head -n 1)\"\n\t\telif [ \"$inner\" = \"6\" ]; then\n\t\t\tlocal req_proto_offset=\"72\"\n\t\t\tlocal req_offset=\"106\"\n\t\t\tif [ \"$type\" = \"vxlan\" ] || [ \"$type\" = \"geneve\" ]; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 4))\"\n\t\t\t\treq_offset=\"$((req_offset + 4))\"\n\t\t\tfi\n\t\t\tif $vlan; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 4))\"\n\t\t\t\treq_offset=\"$((req_offset + 4))\"\n\t\t\tfi\n\t\t\tout=\"$(${RUN_NS0} tcpdump --immediate-mode -p -c 1 -v \\\n\t\t\t\t-i veth0 -n                                   \\\n\t\t\t\tip6[$tunnel_type_offset] = $tunnel_type_proto and \\\n\t\t\t\tip6[$req_proto_offset] = 0x3a and             \\\n\t\t\t\tip6[$req_offset] = 0x80 2>/dev/null           \\\n\t\t\t\t| head -n 1)\"\n\t\telif [ \"$inner\" = \"other\" ]; then\n\t\t\tlocal req_proto_offset=\"64\"\n\t\t\tlocal req_offset=\"73\"\n\t\t\tif [ \"$type\" = \"vxlan\" ] || [ \"$type\" = \"geneve\" ]; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 4))\"\n\t\t\t\treq_offset=\"$((req_offset + 4))\"\n\t\t\tfi\n\t\t\tif $vlan; then\n\t\t\t\treq_proto_offset=\"$((req_proto_offset + 4))\"\n\t\t\t\treq_offset=\"$((req_offset + 4))\"\n\t\t\tfi\n\t\t\tif [ \"$tos_ttl\" = \"inherit\" ]; then\n\t\t\t\texpected_tos=\"0x00\"\n\t\t\t\texpected_ttl=\"64\"\n\t\t\tfi\n\t\t\tout=\"$(${RUN_NS0} tcpdump --immediate-mode -p -c 1 -v \\\n\t\t\t\t-i veth0 -n                                   \\\n\t\t\t\tip6[$tunnel_type_offset] = $tunnel_type_proto and \\\n\t\t\t\tip6[$req_proto_offset] = 0x08 and             \\\n\t\t\t\tip6[$((req_proto_offset + 1))] = 0x06 and     \\\n\t\t\t\tip6[$req_offset] = 0x01 2>/dev/null           \\\n\t\t\t\t| head -n 1)\"\n\t\tfi\n\tfi\n\tkill -9 $ping_pid\n\twait $ping_pid 2>/dev/null || true\n\tresult=\"FAIL\"\n\tif [ \"$outer\" = \"4\" ]; then\n\t\tcaptured_ttl=\"$(get_field \"ttl\" \"$out\")\"\n\t\tcaptured_tos=\"$(printf \"0x%02x\" \"$(get_field \"tos\" \"$out\")\")\"\n\t\tif [ \"$captured_tos\" = \"$expected_tos\" ] &&\n\t\t   [ \"$captured_ttl\" = \"$expected_ttl\" ]; then\n\t\t\tresult=\"OK\"\n\t\tfi\n\telif [ \"$outer\" = \"6\" ]; then\n\t\tcaptured_ttl=\"$(get_field \"hlim\" \"$out\")\"\n\t\tcaptured_tos=\"$(printf \"0x%02x\" \"$(get_field \"class\" \"$out\")\")\"\n\t\tif [ \"$captured_tos\" = \"$expected_tos\" ] &&\n\t\t   [ \"$captured_ttl\" = \"$expected_ttl\" ]; then\n\t\t\tresult=\"OK\"\n\t\tfi\n\tfi\n\n\tprintf \"%7s \u2502\\n\" \"$result\"\n\tif [ \"$result\" = \"FAIL\" ]; then\n\t\tfailed=true\n\t\tif [ \"$captured_tos\" != \"$expected_tos\" ]; then\n\t\t\tprintf \"\u2502%43s%27s \u2502\\n\" \\\n\t\t\t\"Expected TOS value: $expected_tos\" \\\n\t\t\t\"Captured TOS value: $captured_tos\"\n\t\tfi\n\t\tif [ \"$captured_ttl\" != \"$expected_ttl\" ]; then\n\t\t\tprintf \"\u2502%43s%27s \u2502\\n\" \\\n\t\t\t\"Expected TTL value: $expected_ttl\" \\\n\t\t\t\"Captured TTL value: $captured_ttl\"\n\t\tfi\n\t\tprintf \"\u2502%71s\u2502\\n\" \" \"\n\tfi\n}\n\ncleanup() {\n\tip netns del \"${NS0}\" 2>/dev/null\n\tip netns del \"${NS1}\" 2>/dev/null\n}\n\nexit_handler() {\n\t# Don't exit immediately if one of the intermediate commands fails.\n\t# We might be called at the end of the script, when the network\n\t# namespaces have already been deleted. So cleanup() may fail, but we\n\t# still need to run until 'exit $ERR' or the script won't return the\n\t# correct error code.\n\tset +e\n\n\tcleanup\n\n\texit $ERR\n}\n\n# Restore the default SIGINT handler (just in case) and exit.\n# The exit handler will take care of cleaning everything up.\ninterrupted() {\n\ttrap - INT\n\n\texit $ERR\n}\n\nset -e\ntrap exit_handler EXIT\ntrap interrupted INT\n\nprintf \"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\"\nprintf \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\"\nfor type in gre vxlan geneve; do\n\tif ! $(modprobe \"$type\" 2>/dev/null); then\n\t\tcontinue\n\tfi\n\tfor outer in 4 6; do\n\t\tprintf \"\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\"\n\t\tprintf \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\"\n\t\tprintf \"\u2502  Type  \u2502 outer | inner \u2502     tos      \u2502\"\n\t\tprintf \"      ttl     \u2502  vlan \u2502 result \u2502\\n\"\n\t\tfor inner in 4 6 other; do\n\t\t\tprintf \"\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\"\n\t\t\tprintf \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\"\n\t\t\tfor tos_ttl in inherit random; do\n\t\t\t\tfor vlan in false true; do\n\t\t\t\t\tsetup \"$type\" \"$outer\" \"$inner\" \\\n\t\t\t\t\t\"$tos_ttl\" \"$vlan\"\n\t\t\t\t\tverify \"$outer\" \"$inner\" \"$tos_ttl\" \\\n\t\t\t\t\t\"$vlan\"\n\t\t\t\t\tcleanup\n\t\t\t\tdone\n\t\t\tdone\n\t\tdone\n\tdone\ndone\nprintf \"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\"\nprintf \"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\"\n\n# All tests done.\n# Set ERR appropriately: it will be returned by the exit handler.\nif $failed; then\n\tERR=1\nelse\n\tERR=0\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}