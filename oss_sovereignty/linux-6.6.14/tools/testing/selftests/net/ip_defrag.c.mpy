{
  "module_name": "ip_defrag.c",
  "hash_id": "9967bb674da8742379fbc69203d7afc27ca4bfc7f1968d31163150ea88d1ea45",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/ip_defrag.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <linux/in.h>\n#include <netinet/ip.h>\n#include <netinet/ip6.h>\n#include <netinet/udp.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\nstatic bool\t\tcfg_do_ipv4;\nstatic bool\t\tcfg_do_ipv6;\nstatic bool\t\tcfg_verbose;\nstatic bool\t\tcfg_overlap;\nstatic bool\t\tcfg_permissive;\nstatic unsigned short\tcfg_port = 9000;\n\nconst struct in_addr addr4 = { .s_addr = __constant_htonl(INADDR_LOOPBACK + 2) };\nconst struct in6_addr addr6 = IN6ADDR_LOOPBACK_INIT;\n\n#define IP4_HLEN\t(sizeof(struct iphdr))\n#define IP6_HLEN\t(sizeof(struct ip6_hdr))\n#define UDP_HLEN\t(sizeof(struct udphdr))\n\n \n#define FRAG_HLEN\t8\n\nstatic int payload_len;\nstatic int max_frag_len;\n\n#define MSG_LEN_MAX\t10000\t \n\n#define IP4_MF\t\t(1u << 13)   \n#define IP6_MF\t\t(1)   \n\n#define CSUM_MANGLED_0 (0xffff)\n\nstatic uint8_t udp_payload[MSG_LEN_MAX];\nstatic uint8_t ip_frame[IP_MAXPACKET];\nstatic uint32_t ip_id = 0xabcd;\nstatic int msg_counter;\nstatic int frag_counter;\nstatic unsigned int seed;\n\n \nstatic void recv_validate_udp(int fd_udp)\n{\n\tssize_t ret;\n\tstatic uint8_t recv_buff[MSG_LEN_MAX];\n\n\tret = recv(fd_udp, recv_buff, payload_len, 0);\n\tmsg_counter++;\n\n\tif (cfg_overlap) {\n\t\tif (ret == -1 && (errno == ETIMEDOUT || errno == EAGAIN))\n\t\t\treturn;   \n\t\tif (!cfg_permissive) {\n\t\t\tif (ret != -1)\n\t\t\t\terror(1, 0, \"recv: expected timeout; got %d\",\n\t\t\t\t\t(int)ret);\n\t\t\terror(1, errno, \"recv: expected timeout: %d\", errno);\n\t\t}\n\t}\n\n\tif (ret == -1)\n\t\terror(1, errno, \"recv: payload_len = %d max_frag_len = %d\",\n\t\t\tpayload_len, max_frag_len);\n\tif (ret != payload_len)\n\t\terror(1, 0, \"recv: wrong size: %d vs %d\", (int)ret, payload_len);\n\tif (memcmp(udp_payload, recv_buff, payload_len))\n\t\terror(1, 0, \"recv: wrong data\");\n}\n\nstatic uint32_t raw_checksum(uint8_t *buf, int len, uint32_t sum)\n{\n\tint i;\n\n\tfor (i = 0; i < (len & ~1U); i += 2) {\n\t\tsum += (u_int16_t)ntohs(*((u_int16_t *)(buf + i)));\n\t\tif (sum > 0xffff)\n\t\t\tsum -= 0xffff;\n\t}\n\n\tif (i < len) {\n\t\tsum += buf[i] << 8;\n\t\tif (sum > 0xffff)\n\t\t\tsum -= 0xffff;\n\t}\n\n\treturn sum;\n}\n\nstatic uint16_t udp_checksum(struct ip *iphdr, struct udphdr *udphdr)\n{\n\tuint32_t sum = 0;\n\tuint16_t res;\n\n\tsum = raw_checksum((uint8_t *)&iphdr->ip_src, 2 * sizeof(iphdr->ip_src),\n\t\t\t\tIPPROTO_UDP + (uint32_t)(UDP_HLEN + payload_len));\n\tsum = raw_checksum((uint8_t *)udphdr, UDP_HLEN, sum);\n\tsum = raw_checksum((uint8_t *)udp_payload, payload_len, sum);\n\tres = 0xffff & ~sum;\n\tif (res)\n\t\treturn htons(res);\n\telse\n\t\treturn CSUM_MANGLED_0;\n}\n\nstatic uint16_t udp6_checksum(struct ip6_hdr *iphdr, struct udphdr *udphdr)\n{\n\tuint32_t sum = 0;\n\tuint16_t res;\n\n\tsum = raw_checksum((uint8_t *)&iphdr->ip6_src, 2 * sizeof(iphdr->ip6_src),\n\t\t\t\tIPPROTO_UDP);\n\tsum = raw_checksum((uint8_t *)&udphdr->len, sizeof(udphdr->len), sum);\n\tsum = raw_checksum((uint8_t *)udphdr, UDP_HLEN, sum);\n\tsum = raw_checksum((uint8_t *)udp_payload, payload_len, sum);\n\tres = 0xffff & ~sum;\n\tif (res)\n\t\treturn htons(res);\n\telse\n\t\treturn CSUM_MANGLED_0;\n}\n\nstatic void send_fragment(int fd_raw, struct sockaddr *addr, socklen_t alen,\n\t\t\t\tint offset, bool ipv6)\n{\n\tint frag_len;\n\tint res;\n\tint payload_offset = offset > 0 ? offset - UDP_HLEN : 0;\n\tuint8_t *frag_start = ipv6 ? ip_frame + IP6_HLEN + FRAG_HLEN :\n\t\t\t\t\tip_frame + IP4_HLEN;\n\n\tif (offset == 0) {\n\t\tstruct udphdr udphdr;\n\t\tudphdr.source = htons(cfg_port + 1);\n\t\tudphdr.dest = htons(cfg_port);\n\t\tudphdr.len = htons(UDP_HLEN + payload_len);\n\t\tudphdr.check = 0;\n\t\tif (ipv6)\n\t\t\tudphdr.check = udp6_checksum((struct ip6_hdr *)ip_frame, &udphdr);\n\t\telse\n\t\t\tudphdr.check = udp_checksum((struct ip *)ip_frame, &udphdr);\n\t\tmemcpy(frag_start, &udphdr, UDP_HLEN);\n\t}\n\n\tif (ipv6) {\n\t\tstruct ip6_hdr *ip6hdr = (struct ip6_hdr *)ip_frame;\n\t\tstruct ip6_frag *fraghdr = (struct ip6_frag *)(ip_frame + IP6_HLEN);\n\t\tif (payload_len - payload_offset <= max_frag_len && offset > 0) {\n\t\t\t \n\t\t\tfrag_len = FRAG_HLEN + payload_len - payload_offset;\n\t\t\tfraghdr->ip6f_offlg = htons(offset);\n\t\t} else {\n\t\t\tfrag_len = FRAG_HLEN + max_frag_len;\n\t\t\tfraghdr->ip6f_offlg = htons(offset | IP6_MF);\n\t\t}\n\t\tip6hdr->ip6_plen = htons(frag_len);\n\t\tif (offset == 0)\n\t\t\tmemcpy(frag_start + UDP_HLEN, udp_payload,\n\t\t\t\tfrag_len - FRAG_HLEN - UDP_HLEN);\n\t\telse\n\t\t\tmemcpy(frag_start, udp_payload + payload_offset,\n\t\t\t\tfrag_len - FRAG_HLEN);\n\t\tfrag_len += IP6_HLEN;\n\t} else {\n\t\tstruct ip *iphdr = (struct ip *)ip_frame;\n\t\tif (payload_len - payload_offset <= max_frag_len && offset > 0) {\n\t\t\t \n\t\t\tfrag_len = IP4_HLEN + payload_len - payload_offset;\n\t\t\tiphdr->ip_off = htons(offset / 8);\n\t\t} else {\n\t\t\tfrag_len = IP4_HLEN + max_frag_len;\n\t\t\tiphdr->ip_off = htons(offset / 8 | IP4_MF);\n\t\t}\n\t\tiphdr->ip_len = htons(frag_len);\n\t\tif (offset == 0)\n\t\t\tmemcpy(frag_start + UDP_HLEN, udp_payload,\n\t\t\t\tfrag_len - IP4_HLEN - UDP_HLEN);\n\t\telse\n\t\t\tmemcpy(frag_start, udp_payload + payload_offset,\n\t\t\t\tfrag_len - IP4_HLEN);\n\t}\n\n\tres = sendto(fd_raw, ip_frame, frag_len, 0, addr, alen);\n\tif (res < 0 && errno != EPERM)\n\t\terror(1, errno, \"send_fragment\");\n\tif (res >= 0 && res != frag_len)\n\t\terror(1, 0, \"send_fragment: %d vs %d\", res, frag_len);\n\n\tfrag_counter++;\n}\n\nstatic void send_udp_frags(int fd_raw, struct sockaddr *addr,\n\t\t\t\tsocklen_t alen, bool ipv6)\n{\n\tstruct ip *iphdr = (struct ip *)ip_frame;\n\tstruct ip6_hdr *ip6hdr = (struct ip6_hdr *)ip_frame;\n\tint res;\n\tint offset;\n\tint frag_len;\n\n\t \n\tif (ipv6) {\n\t\tstruct ip6_frag *fraghdr = (struct ip6_frag *)(ip_frame + IP6_HLEN);\n\t\t((struct sockaddr_in6 *)addr)->sin6_port = 0;\n\t\tmemset(ip6hdr, 0, sizeof(*ip6hdr));\n\t\tip6hdr->ip6_flow = htonl(6<<28);   \n\t\tip6hdr->ip6_nxt = IPPROTO_FRAGMENT;\n\t\tip6hdr->ip6_hops = 255;\n\t\tip6hdr->ip6_src = addr6;\n\t\tip6hdr->ip6_dst = addr6;\n\t\tfraghdr->ip6f_nxt = IPPROTO_UDP;\n\t\tfraghdr->ip6f_reserved = 0;\n\t\tfraghdr->ip6f_ident = htonl(ip_id++);\n\t} else {\n\t\tmemset(iphdr, 0, sizeof(*iphdr));\n\t\tiphdr->ip_hl = 5;\n\t\tiphdr->ip_v = 4;\n\t\tiphdr->ip_tos = 0;\n\t\tiphdr->ip_id = htons(ip_id++);\n\t\tiphdr->ip_ttl = 0x40;\n\t\tiphdr->ip_p = IPPROTO_UDP;\n\t\tiphdr->ip_src.s_addr = htonl(INADDR_LOOPBACK);\n\t\tiphdr->ip_dst = addr4;\n\t\tiphdr->ip_sum = 0;\n\t}\n\n\t \n\tif (!cfg_overlap && (rand() % 100 < 15)) {\n\t\toffset = 0;\n\t\twhile (offset < (UDP_HLEN + payload_len)) {\n\t\t\tsend_fragment(fd_raw, addr, alen, offset, ipv6);\n\t\t\toffset += max_frag_len;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (!cfg_overlap && (rand() % 100 < 20) &&\n\t\t\t(payload_len > 9 * max_frag_len)) {\n\t\toffset = 6 * max_frag_len;\n\t\twhile (offset < (UDP_HLEN + payload_len)) {\n\t\t\tsend_fragment(fd_raw, addr, alen, offset, ipv6);\n\t\t\toffset += max_frag_len;\n\t\t}\n\t\toffset = 3 * max_frag_len;\n\t\twhile (offset < 6 * max_frag_len) {\n\t\t\tsend_fragment(fd_raw, addr, alen, offset, ipv6);\n\t\t\toffset += max_frag_len;\n\t\t}\n\t\toffset = 0;\n\t\twhile (offset < 3 * max_frag_len) {\n\t\t\tsend_fragment(fd_raw, addr, alen, offset, ipv6);\n\t\t\toffset += max_frag_len;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\toffset = max_frag_len;\n\twhile (offset < (UDP_HLEN + payload_len)) {\n\t\tsend_fragment(fd_raw, addr, alen, offset, ipv6);\n\t\t \n\t\tif (rand() % 100 == 1)\n\t\t\tsend_fragment(fd_raw, addr, alen, offset, ipv6);\n\t\toffset += 2 * max_frag_len;\n\t}\n\n\tif (cfg_overlap) {\n\t\t \n\t\tif (max_frag_len * 4 < payload_len || max_frag_len < 16) {\n\t\t\t \n\t\t\toffset = 8;\n\t\t\tfrag_len = UDP_HLEN + max_frag_len;\n\t\t} else {\n\t\t\toffset = rand() % (payload_len / 2);\n\t\t\tfrag_len = 2 * max_frag_len + 1 + rand() % 256;\n\t\t}\n\t\tif (ipv6) {\n\t\t\tstruct ip6_frag *fraghdr = (struct ip6_frag *)(ip_frame + IP6_HLEN);\n\t\t\t \n\t\t\t \n\t\t\tfrag_len &= ~0x7;\n\t\t\tfraghdr->ip6f_offlg = htons(offset / 8 | IP6_MF);\n\t\t\tip6hdr->ip6_plen = htons(frag_len);\n\t\t\tfrag_len += IP6_HLEN;\n\t\t} else {\n\t\t\tfrag_len += IP4_HLEN;\n\t\t\tiphdr->ip_off = htons(offset / 8 | IP4_MF);\n\t\t\tiphdr->ip_len = htons(frag_len);\n\t\t}\n\t\tres = sendto(fd_raw, ip_frame, frag_len, 0, addr, alen);\n\t\tif (res < 0 && errno != EPERM)\n\t\t\terror(1, errno, \"sendto overlap: %d\", frag_len);\n\t\tif (res >= 0 && res != frag_len)\n\t\t\terror(1, 0, \"sendto overlap: %d vs %d\", (int)res, frag_len);\n\t\tfrag_counter++;\n\t}\n\n\t \n\toffset = 0;\n\twhile (offset < (UDP_HLEN + payload_len)) {\n\t\tsend_fragment(fd_raw, addr, alen, offset, ipv6);\n\t\t \n\t\tif (rand() % 100 == 1)\n\t\t\tsend_fragment(fd_raw, addr, alen, offset, ipv6);\n\t\toffset += 2 * max_frag_len;\n\t}\n}\n\nstatic void run_test(struct sockaddr *addr, socklen_t alen, bool ipv6)\n{\n\tint fd_tx_raw, fd_rx_udp;\n\t \n\tstruct timeval tv = { .tv_sec = 1, .tv_usec = 10 };\n\tint idx;\n\tint min_frag_len = 8;\n\n\t \n\tfor (idx = 0; idx < MSG_LEN_MAX; ++idx)\n\t\tudp_payload[idx] = idx % 256;\n\n\t \n\tfd_tx_raw = socket(addr->sa_family, SOCK_RAW, IPPROTO_RAW);\n\tif (fd_tx_raw == -1)\n\t\terror(1, errno, \"socket tx_raw\");\n\n\tfd_rx_udp = socket(addr->sa_family, SOCK_DGRAM, 0);\n\tif (fd_rx_udp == -1)\n\t\terror(1, errno, \"socket rx_udp\");\n\tif (bind(fd_rx_udp, addr, alen))\n\t\terror(1, errno, \"bind\");\n\t \n\tif (setsockopt(fd_rx_udp, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)))\n\t\terror(1, errno, \"setsockopt rcv timeout\");\n\n\tfor (payload_len = min_frag_len; payload_len < MSG_LEN_MAX;\n\t\t\tpayload_len += (rand() % 4096)) {\n\t\tif (cfg_verbose)\n\t\t\tprintf(\"payload_len: %d\\n\", payload_len);\n\n\t\tif (cfg_overlap) {\n\t\t\t \n\t\t\tmax_frag_len = min_frag_len +\n\t\t\t\trand() % (1500 - FRAG_HLEN - min_frag_len);\n\t\t\tsend_udp_frags(fd_tx_raw, addr, alen, ipv6);\n\t\t\trecv_validate_udp(fd_rx_udp);\n\t\t} else {\n\t\t\t \n\t\t\tmax_frag_len = min_frag_len;\n\t\t\tdo {\n\t\t\t\tsend_udp_frags(fd_tx_raw, addr, alen, ipv6);\n\t\t\t\trecv_validate_udp(fd_rx_udp);\n\t\t\t\tmax_frag_len += 8 * (rand() % 8);\n\t\t\t} while (max_frag_len < (1500 - FRAG_HLEN) &&\n\t\t\t\t max_frag_len <= payload_len);\n\t\t}\n\t}\n\n\t \n\tif (close(fd_tx_raw))\n\t\terror(1, errno, \"close tx_raw\");\n\tif (close(fd_rx_udp))\n\t\terror(1, errno, \"close rx_udp\");\n\n\tif (cfg_verbose)\n\t\tprintf(\"processed %d messages, %d fragments\\n\",\n\t\t\tmsg_counter, frag_counter);\n\n\tfprintf(stderr, \"PASS\\n\");\n}\n\n\nstatic void run_test_v4(void)\n{\n\tstruct sockaddr_in addr = {0};\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(cfg_port);\n\taddr.sin_addr = addr4;\n\n\trun_test((void *)&addr, sizeof(addr), false  );\n}\n\nstatic void run_test_v6(void)\n{\n\tstruct sockaddr_in6 addr = {0};\n\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(cfg_port);\n\taddr.sin6_addr = addr6;\n\n\trun_test((void *)&addr, sizeof(addr), true  );\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"46opv\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tcfg_do_ipv4 = true;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tcfg_do_ipv6 = true;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tcfg_overlap = true;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcfg_permissive = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcfg_verbose = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"%s: parse error\", argv[0]);\n\t\t}\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tparse_opts(argc, argv);\n\tseed = time(NULL);\n\tsrand(seed);\n\t \n\tprintf(\"seed = %d\\n\", seed);\n\n\tif (cfg_do_ipv4)\n\t\trun_test_v4();\n\tif (cfg_do_ipv6)\n\t\trun_test_v6();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}