{
  "module_name": "psock_snd.c",
  "hash_id": "43e89600c13f5160b3b8ccf532c9906ca9ffb21814a864b6c5cfcef97728941f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/psock_snd.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/if_packet.h>\n#include <linux/if_vlan.h>\n#include <linux/virtio_net.h>\n#include <net/if.h>\n#include <net/ethernet.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <poll.h>\n#include <sched.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"psock_lib.h\"\n\nstatic bool\tcfg_use_bind;\nstatic bool\tcfg_use_csum_off;\nstatic bool\tcfg_use_csum_off_bad;\nstatic bool\tcfg_use_dgram;\nstatic bool\tcfg_use_gso;\nstatic bool\tcfg_use_qdisc_bypass;\nstatic bool\tcfg_use_vlan;\nstatic bool\tcfg_use_vnet;\n\nstatic char\t*cfg_ifname = \"lo\";\nstatic int\tcfg_mtu\t= 1500;\nstatic int\tcfg_payload_len = DATA_LEN;\nstatic int\tcfg_truncate_len = INT_MAX;\nstatic uint16_t\tcfg_port = 8000;\n\n \n#define TEST_SZ\t(sizeof(struct virtio_net_hdr) + ETH_HLEN + ETH_MAX_MTU + 1)\n\nstatic char tbuf[TEST_SZ], rbuf[TEST_SZ];\n\nstatic unsigned long add_csum_hword(const uint16_t *start, int num_u16)\n{\n\tunsigned long sum = 0;\n\tint i;\n\n\tfor (i = 0; i < num_u16; i++)\n\t\tsum += start[i];\n\n\treturn sum;\n}\n\nstatic uint16_t build_ip_csum(const uint16_t *start, int num_u16,\n\t\t\t      unsigned long sum)\n{\n\tsum += add_csum_hword(start, num_u16);\n\n\twhile (sum >> 16)\n\t\tsum = (sum & 0xffff) + (sum >> 16);\n\n\treturn ~sum;\n}\n\nstatic int build_vnet_header(void *header)\n{\n\tstruct virtio_net_hdr *vh = header;\n\n\tvh->hdr_len = ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr);\n\n\tif (cfg_use_csum_off) {\n\t\tvh->flags |= VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\t\tvh->csum_start = ETH_HLEN + sizeof(struct iphdr);\n\t\tvh->csum_offset = __builtin_offsetof(struct udphdr, check);\n\n\t\t \n\t\tif (cfg_use_csum_off_bad)\n\t\t\tvh->csum_start += sizeof(struct udphdr) + cfg_payload_len -\n\t\t\t\t\t  vh->csum_offset - 1;\n\t}\n\n\tif (cfg_use_gso) {\n\t\tvh->gso_type = VIRTIO_NET_HDR_GSO_UDP;\n\t\tvh->gso_size = cfg_mtu - sizeof(struct iphdr);\n\t}\n\n\treturn sizeof(*vh);\n}\n\nstatic int build_eth_header(void *header)\n{\n\tstruct ethhdr *eth = header;\n\n\tif (cfg_use_vlan) {\n\t\tuint16_t *tag = header + ETH_HLEN;\n\n\t\teth->h_proto = htons(ETH_P_8021Q);\n\t\ttag[1] = htons(ETH_P_IP);\n\t\treturn ETH_HLEN + 4;\n\t}\n\n\teth->h_proto = htons(ETH_P_IP);\n\treturn ETH_HLEN;\n}\n\nstatic int build_ipv4_header(void *header, int payload_len)\n{\n\tstruct iphdr *iph = header;\n\n\tiph->ihl = 5;\n\tiph->version = 4;\n\tiph->ttl = 8;\n\tiph->tot_len = htons(sizeof(*iph) + sizeof(struct udphdr) + payload_len);\n\tiph->id = htons(1337);\n\tiph->protocol = IPPROTO_UDP;\n\tiph->saddr = htonl((172 << 24) | (17 << 16) | 2);\n\tiph->daddr = htonl((172 << 24) | (17 << 16) | 1);\n\tiph->check = build_ip_csum((void *) iph, iph->ihl << 1, 0);\n\n\treturn iph->ihl << 2;\n}\n\nstatic int build_udp_header(void *header, int payload_len)\n{\n\tconst int alen = sizeof(uint32_t);\n\tstruct udphdr *udph = header;\n\tint len = sizeof(*udph) + payload_len;\n\n\tudph->source = htons(9);\n\tudph->dest = htons(cfg_port);\n\tudph->len = htons(len);\n\n\tif (cfg_use_csum_off)\n\t\tudph->check = build_ip_csum(header - (2 * alen), alen,\n\t\t\t\t\t    htons(IPPROTO_UDP) + udph->len);\n\telse\n\t\tudph->check = 0;\n\n\treturn sizeof(*udph);\n}\n\nstatic int build_packet(int payload_len)\n{\n\tint off = 0;\n\n\toff += build_vnet_header(tbuf);\n\toff += build_eth_header(tbuf + off);\n\toff += build_ipv4_header(tbuf + off, payload_len);\n\toff += build_udp_header(tbuf + off, payload_len);\n\n\tif (off + payload_len > sizeof(tbuf))\n\t\terror(1, 0, \"payload length exceeds max\");\n\n\tmemset(tbuf + off, DATA_CHAR, payload_len);\n\n\treturn off + payload_len;\n}\n\nstatic void do_bind(int fd)\n{\n\tstruct sockaddr_ll laddr = {0};\n\n\tladdr.sll_family = AF_PACKET;\n\tladdr.sll_protocol = htons(ETH_P_IP);\n\tladdr.sll_ifindex = if_nametoindex(cfg_ifname);\n\tif (!laddr.sll_ifindex)\n\t\terror(1, errno, \"if_nametoindex\");\n\n\tif (bind(fd, (void *)&laddr, sizeof(laddr)))\n\t\terror(1, errno, \"bind\");\n}\n\nstatic void do_send(int fd, char *buf, int len)\n{\n\tint ret;\n\n\tif (!cfg_use_vnet) {\n\t\tbuf += sizeof(struct virtio_net_hdr);\n\t\tlen -= sizeof(struct virtio_net_hdr);\n\t}\n\tif (cfg_use_dgram) {\n\t\tbuf += ETH_HLEN;\n\t\tlen -= ETH_HLEN;\n\t}\n\n\tif (cfg_use_bind) {\n\t\tret = write(fd, buf, len);\n\t} else {\n\t\tstruct sockaddr_ll laddr = {0};\n\n\t\tladdr.sll_protocol = htons(ETH_P_IP);\n\t\tladdr.sll_ifindex = if_nametoindex(cfg_ifname);\n\t\tif (!laddr.sll_ifindex)\n\t\t\terror(1, errno, \"if_nametoindex\");\n\n\t\tret = sendto(fd, buf, len, 0, (void *)&laddr, sizeof(laddr));\n\t}\n\n\tif (ret == -1)\n\t\terror(1, errno, \"write\");\n\tif (ret != len)\n\t\terror(1, 0, \"write: %u %u\", ret, len);\n\n\tfprintf(stderr, \"tx: %u\\n\", ret);\n}\n\nstatic int do_tx(void)\n{\n\tconst int one = 1;\n\tint fd, len;\n\n\tfd = socket(PF_PACKET, cfg_use_dgram ? SOCK_DGRAM : SOCK_RAW, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket t\");\n\n\tif (cfg_use_bind)\n\t\tdo_bind(fd);\n\n\tif (cfg_use_qdisc_bypass &&\n\t    setsockopt(fd, SOL_PACKET, PACKET_QDISC_BYPASS, &one, sizeof(one)))\n\t\terror(1, errno, \"setsockopt qdisc bypass\");\n\n\tif (cfg_use_vnet &&\n\t    setsockopt(fd, SOL_PACKET, PACKET_VNET_HDR, &one, sizeof(one)))\n\t\terror(1, errno, \"setsockopt vnet\");\n\n\tlen = build_packet(cfg_payload_len);\n\n\tif (cfg_truncate_len < len)\n\t\tlen = cfg_truncate_len;\n\n\tdo_send(fd, tbuf, len);\n\n\tif (close(fd))\n\t\terror(1, errno, \"close t\");\n\n\treturn len;\n}\n\nstatic int setup_rx(void)\n{\n\tstruct timeval tv = { .tv_usec = 100 * 1000 };\n\tstruct sockaddr_in raddr = {0};\n\tint fd;\n\n\tfd = socket(PF_INET, SOCK_DGRAM, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket r\");\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)))\n\t\terror(1, errno, \"setsockopt rcv timeout\");\n\n\traddr.sin_family = AF_INET;\n\traddr.sin_port = htons(cfg_port);\n\traddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n\tif (bind(fd, (void *)&raddr, sizeof(raddr)))\n\t\terror(1, errno, \"bind r\");\n\n\treturn fd;\n}\n\nstatic void do_rx(int fd, int expected_len, char *expected)\n{\n\tint ret;\n\n\tret = recv(fd, rbuf, sizeof(rbuf), 0);\n\tif (ret == -1)\n\t\terror(1, errno, \"recv\");\n\tif (ret != expected_len)\n\t\terror(1, 0, \"recv: %u != %u\", ret, expected_len);\n\n\tif (memcmp(rbuf, expected, ret))\n\t\terror(1, 0, \"recv: data mismatch\");\n\n\tfprintf(stderr, \"rx: %u\\n\", ret);\n}\n\nstatic int setup_sniffer(void)\n{\n\tstruct timeval tv = { .tv_usec = 100 * 1000 };\n\tint fd;\n\n\tfd = socket(PF_PACKET, SOCK_RAW, 0);\n\tif (fd == -1)\n\t\terror(1, errno, \"socket p\");\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)))\n\t\terror(1, errno, \"setsockopt rcv timeout\");\n\n\tpair_udp_setfilter(fd);\n\tdo_bind(fd);\n\n\treturn fd;\n}\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"bcCdgl:qt:vV\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'b':\n\t\t\tcfg_use_bind = true;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcfg_use_csum_off = true;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcfg_use_csum_off_bad = true;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcfg_use_dgram = true;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tcfg_use_gso = true;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tcfg_payload_len = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tcfg_use_qdisc_bypass = true;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcfg_truncate_len = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcfg_use_vnet = true;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tcfg_use_vlan = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(1, 0, \"%s: parse error\", argv[0]);\n\t\t}\n\t}\n\n\tif (cfg_use_vlan && cfg_use_dgram)\n\t\terror(1, 0, \"option vlan (-V) conflicts with dgram (-d)\");\n\n\tif (cfg_use_csum_off && !cfg_use_vnet)\n\t\terror(1, 0, \"option csum offload (-c) requires vnet (-v)\");\n\n\tif (cfg_use_csum_off_bad && !cfg_use_csum_off)\n\t\terror(1, 0, \"option csum bad (-C) requires csum offload (-c)\");\n\n\tif (cfg_use_gso && !cfg_use_csum_off)\n\t\terror(1, 0, \"option gso (-g) requires csum offload (-c)\");\n}\n\nstatic void run_test(void)\n{\n\tint fdr, fds, total_len;\n\n\tfdr = setup_rx();\n\tfds = setup_sniffer();\n\n\ttotal_len = do_tx();\n\n\t \n\tif (cfg_payload_len == DATA_LEN && !cfg_use_vlan)\n\t\tdo_rx(fds, total_len - sizeof(struct virtio_net_hdr),\n\t\t      tbuf + sizeof(struct virtio_net_hdr));\n\n\tdo_rx(fdr, cfg_payload_len, tbuf + total_len - cfg_payload_len);\n\n\tif (close(fds))\n\t\terror(1, errno, \"close s\");\n\tif (close(fdr))\n\t\terror(1, errno, \"close r\");\n}\n\nint main(int argc, char **argv)\n{\n\tparse_opts(argc, argv);\n\n\tif (system(\"ip link set dev lo mtu 1500\"))\n\t\terror(1, errno, \"ip link set mtu\");\n\tif (system(\"ip addr add dev lo 172.17.0.1/24\"))\n\t\terror(1, errno, \"ip addr add\");\n\tif (system(\"sysctl -w net.ipv4.conf.lo.accept_local=1\"))\n\t\terror(1, errno, \"sysctl lo.accept_local\");\n\n\trun_test();\n\n\tfprintf(stderr, \"OK\\n\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}