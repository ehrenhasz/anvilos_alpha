{
  "module_name": "icmp_redirect.sh",
  "hash_id": "d25226c0856b282a55244edc4c8404c83158fb9dff69a0ac72b3a0971ee64b9b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/icmp_redirect.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# redirect test\n#\n#                     .253 +----+\n#                     +----| r1 |\n#                     |    +----+\n# +----+              |       |.1\n# | h1 |--------------+       |   10.1.1.0/30 2001:db8:1::0/126\n# +----+ .1           |       |.2\n#         172.16.1/24 |    +----+                   +----+\n#    2001:db8:16:1/64 +----| r2 |-------------------| h2 |\n#                     .254 +----+ .254           .2 +----+\n#                                    172.16.2/24\n#                                  2001:db8:16:2/64\n#\n# Route from h1 to h2 goes through r1, eth1 - connection between r1 and r2.\n# Route on r1 changed to go to r2 via eth0. This causes a redirect to be sent\n# from r1 to h1 telling h1 to use r2 when talking to h2.\n\nVERBOSE=0\nPAUSE_ON_FAIL=no\n\nH1_N1_IP=172.16.1.1\nR1_N1_IP=172.16.1.253\nR2_N1_IP=172.16.1.254\n\nH1_N1_IP6=2001:db8:16:1::1\nR1_N1_IP6=2001:db8:16:1::253\nR2_N1_IP6=2001:db8:16:1::254\n\nR1_R2_N1_IP=10.1.1.1\nR2_R1_N1_IP=10.1.1.2\n\nR1_R2_N1_IP6=2001:db8:1::1\nR2_R1_N1_IP6=2001:db8:1::2\n\nH2_N2=172.16.2.0/24\nH2_N2_6=2001:db8:16:2::/64\nH2_N2_IP=172.16.2.2\nR2_N2_IP=172.16.2.254\nH2_N2_IP6=2001:db8:16:2::2\nR2_N2_IP6=2001:db8:16:2::254\n\nVRF=red\nVRF_TABLE=1111\n\n################################################################################\n# helpers\n\nlog_section()\n{\n\techo\n\techo \"###########################################################################\"\n\techo \"$*\"\n\techo \"###########################################################################\"\n\techo\n}\n\nlog_test()\n{\n\tlocal rc=$1\n\tlocal expected=$2\n\tlocal msg=\"$3\"\n\tlocal xfail=$4\n\n\tif [ ${rc} -eq ${expected} ]; then\n\t\tprintf \"TEST: %-60s  [ OK ]\\n\" \"${msg}\"\n\t\tnsuccess=$((nsuccess+1))\n\telif [ ${rc} -eq ${xfail} ]; then\n\t\tprintf \"TEST: %-60s  [XFAIL]\\n\" \"${msg}\"\n\t\tnxfail=$((nxfail+1))\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"TEST: %-60s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n}\n\nlog_debug()\n{\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo \"$*\"\n\tfi\n}\n\nrun_cmd()\n{\n\tlocal cmd=\"$*\"\n\tlocal out\n\tlocal rc\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo \"COMMAND: $cmd\"\n\tfi\n\n\tout=$(eval $cmd 2>&1)\n\trc=$?\n\tif [ \"$VERBOSE\" = \"1\" -a -n \"$out\" ]; then\n\t\techo \"$out\"\n\tfi\n\n\t[ \"$VERBOSE\" = \"1\" ] && echo\n\n\treturn $rc\n}\n\nget_linklocal()\n{\n\tlocal ns=$1\n\tlocal dev=$2\n\tlocal addr\n\n\taddr=$(ip -netns $ns -6 -br addr show dev ${dev} | \\\n\tawk '{\n\t\tfor (i = 3; i <= NF; ++i) {\n\t\t\tif ($i ~ /^fe80/)\n\t\t\t\tprint $i\n\t\t}\n\t}'\n\t)\n\taddr=${addr/\\/*}\n\n\t[ -z \"$addr\" ] && return 1\n\n\techo $addr\n\n\treturn 0\n}\n\n################################################################################\n# setup and teardown\n\ncleanup()\n{\n\tlocal ns\n\n\tfor ns in h1 h2 r1 r2; do\n\t\tip netns del $ns 2>/dev/null\n\tdone\n}\n\ncreate_vrf()\n{\n\tlocal ns=$1\n\n\tip -netns ${ns} link add ${VRF} type vrf table ${VRF_TABLE}\n\tip -netns ${ns} link set ${VRF} up\n\tip -netns ${ns} route add vrf ${VRF} unreachable default metric 8192\n\tip -netns ${ns} -6 route add vrf ${VRF} unreachable default metric 8192\n\n\tip -netns ${ns} addr add 127.0.0.1/8 dev ${VRF}\n\tip -netns ${ns} -6 addr add ::1 dev ${VRF} nodad\n\n\tip -netns ${ns} ru del pref 0\n\tip -netns ${ns} ru add pref 32765 from all lookup local\n\tip -netns ${ns} -6 ru del pref 0\n\tip -netns ${ns} -6 ru add pref 32765 from all lookup local\n}\n\nsetup()\n{\n\tlocal ns\n\n\t#\n\t# create nodes as namespaces\n\t#\n\tfor ns in h1 h2 r1 r2; do\n\t\tip netns add $ns\n\t\tip -netns $ns li set lo up\n\n\t\tcase \"${ns}\" in\n\t\th[12]) ip netns exec $ns sysctl -q -w net.ipv4.conf.all.accept_redirects=1\n\t\t       ip netns exec $ns sysctl -q -w net.ipv6.conf.all.forwarding=0\n\t\t       ip netns exec $ns sysctl -q -w net.ipv6.conf.all.accept_redirects=1\n\t\t       ip netns exec $ns sysctl -q -w net.ipv6.conf.all.keep_addr_on_down=1\n\t\t\t;;\n\t\tr[12]) ip netns exec $ns sysctl -q -w net.ipv4.ip_forward=1\n\t\t       ip netns exec $ns sysctl -q -w net.ipv4.conf.all.send_redirects=1\n\t\t       ip netns exec $ns sysctl -q -w net.ipv4.conf.default.rp_filter=0\n\t\t       ip netns exec $ns sysctl -q -w net.ipv4.conf.all.rp_filter=0\n\n\t\t       ip netns exec $ns sysctl -q -w net.ipv6.conf.all.forwarding=1\n\t\t       ip netns exec $ns sysctl -q -w net.ipv6.route.mtu_expires=10\n\t\tesac\n\tdone\n\n\t#\n\t# create interconnects\n\t#\n\tip -netns h1 li add eth0 type veth peer name r1h1\n\tip -netns h1 li set r1h1 netns r1 name eth0 up\n\n\tip -netns h1 li add eth1 type veth peer name r2h1\n\tip -netns h1 li set r2h1 netns r2 name eth0 up\n\n\tip -netns h2 li add eth0 type veth peer name r2h2\n\tip -netns h2 li set eth0 up\n\tip -netns h2 li set r2h2 netns r2 name eth2 up\n\n\tip -netns r1 li add eth1 type veth peer name r2r1\n\tip -netns r1 li set eth1 up\n\tip -netns r1 li set r2r1 netns r2 name eth1 up\n\n\t#\n\t# h1\n\t#\n\tif [ \"${WITH_VRF}\" = \"yes\" ]; then\n\t\tcreate_vrf \"h1\"\n\t\tH1_VRF_ARG=\"vrf ${VRF}\"\n\t\tH1_PING_ARG=\"-I ${VRF}\"\n\telse\n\t\tH1_VRF_ARG=\n\t\tH1_PING_ARG=\n\tfi\n\tip -netns h1 li add br0 type bridge\n\tif [ \"${WITH_VRF}\" = \"yes\" ]; then\n\t\tip -netns h1 li set br0 vrf ${VRF} up\n\telse\n\t\tip -netns h1 li set br0 up\n\tfi\n\tip -netns h1 addr add dev br0 ${H1_N1_IP}/24\n\tip -netns h1 -6 addr add dev br0 ${H1_N1_IP6}/64 nodad\n\tip -netns h1 li set eth0 master br0 up\n\tip -netns h1 li set eth1 master br0 up\n\n\t#\n\t# h2\n\t#\n\tip -netns h2 addr add dev eth0 ${H2_N2_IP}/24\n\tip -netns h2 ro add default via ${R2_N2_IP} dev eth0\n\tip -netns h2 -6 addr add dev eth0 ${H2_N2_IP6}/64 nodad\n\tip -netns h2 -6 ro add default via ${R2_N2_IP6} dev eth0\n\n\t#\n\t# r1\n\t#\n\tip -netns r1 addr add dev eth0 ${R1_N1_IP}/24\n\tip -netns r1 -6 addr add dev eth0 ${R1_N1_IP6}/64 nodad\n\tip -netns r1 addr add dev eth1 ${R1_R2_N1_IP}/30\n\tip -netns r1 -6 addr add dev eth1 ${R1_R2_N1_IP6}/126 nodad\n\n\t#\n\t# r2\n\t#\n\tip -netns r2 addr add dev eth0 ${R2_N1_IP}/24\n\tip -netns r2 -6 addr add dev eth0 ${R2_N1_IP6}/64 nodad\n\tip -netns r2 addr add dev eth1 ${R2_R1_N1_IP}/30\n\tip -netns r2 -6 addr add dev eth1 ${R2_R1_N1_IP6}/126 nodad\n\tip -netns r2 addr add dev eth2 ${R2_N2_IP}/24\n\tip -netns r2 -6 addr add dev eth2 ${R2_N2_IP6}/64 nodad\n\n\tsleep 2\n\n\tR1_LLADDR=$(get_linklocal r1 eth0)\n\tif [ $? -ne 0 ]; then\n\t\techo \"Error: Failed to get link-local address of r1's eth0\"\n\t\texit 1\n\tfi\n\tlog_debug \"initial gateway is R1's lladdr = ${R1_LLADDR}\"\n\n\tR2_LLADDR=$(get_linklocal r2 eth0)\n\tif [ $? -ne 0 ]; then\n\t\techo \"Error: Failed to get link-local address of r2's eth0\"\n\t\texit 1\n\tfi\n\tlog_debug \"initial gateway is R2's lladdr = ${R2_LLADDR}\"\n}\n\nchange_h2_mtu()\n{\n\tlocal mtu=$1\n\n\trun_cmd ip -netns h2 li set eth0 mtu ${mtu}\n\trun_cmd ip -netns r2 li set eth2 mtu ${mtu}\n}\n\ncheck_exception()\n{\n\tlocal mtu=\"$1\"\n\tlocal with_redirect=\"$2\"\n\tlocal desc=\"$3\"\n\n\t# From 172.16.1.101: icmp_seq=1 Redirect Host(New nexthop: 172.16.1.102)\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo \"Commands to check for exception:\"\n\t\trun_cmd ip -netns h1 ro get ${H1_VRF_ARG} ${H2_N2_IP}\n\t\trun_cmd ip -netns h1 -6 ro get ${H1_VRF_ARG} ${H2_N2_IP6}\n\tfi\n\n\tif [ -n \"${mtu}\" ]; then\n\t\tmtu=\" mtu ${mtu}\"\n\tfi\n\tif [ \"$with_redirect\" = \"yes\" ]; then\n\t\tip -netns h1 ro get ${H1_VRF_ARG} ${H2_N2_IP} | \\\n\t\tgrep -q \"cache <redirected> expires [0-9]*sec${mtu}\"\n\telif [ -n \"${mtu}\" ]; then\n\t\tip -netns h1 ro get ${H1_VRF_ARG} ${H2_N2_IP} | \\\n\t\tgrep -q \"cache expires [0-9]*sec${mtu}\"\n\telse\n\t\t# want to verify that neither mtu nor redirected appears in\n\t\t# the route get output. The -v will wipe out the cache line\n\t\t# if either are set so the last grep -q will not find a match\n\t\tip -netns h1 ro get ${H1_VRF_ARG} ${H2_N2_IP} | \\\n\t\tgrep -E -v 'mtu|redirected' | grep -q \"cache\"\n\tfi\n\tlog_test $? 0 \"IPv4: ${desc}\" 0\n\n\t# No PMTU info for test \"redirect\" and \"mtu exception plus redirect\"\n\tif [ \"$with_redirect\" = \"yes\" ] && [ \"$desc\" != \"redirect exception plus mtu\" ]; then\n\t\tip -netns h1 -6 ro get ${H1_VRF_ARG} ${H2_N2_IP6} | \\\n\t\tgrep -v \"mtu\" | grep -q \"${H2_N2_IP6} .*via ${R2_LLADDR} dev br0\"\n\telif [ -n \"${mtu}\" ]; then\n\t\tip -netns h1 -6 ro get ${H1_VRF_ARG} ${H2_N2_IP6} | \\\n\t\tgrep -q \"${mtu}\"\n\telse\n\t\t# IPv6 is a bit harder. First strip out the match if it\n\t\t# contains an mtu exception and then look for the first\n\t\t# gateway - R1's lladdr\n\t\tip -netns h1 -6 ro get ${H1_VRF_ARG} ${H2_N2_IP6} | \\\n\t\tgrep -v \"mtu\" | grep -q \"${R1_LLADDR}\"\n\tfi\n\tlog_test $? 0 \"IPv6: ${desc}\" 1\n}\n\nrun_ping()\n{\n\tlocal sz=$1\n\n\trun_cmd ip netns exec h1 ping -q -M want -i 0.5 -c 10 -w 2 -s ${sz} ${H1_PING_ARG} ${H2_N2_IP}\n\trun_cmd ip netns exec h1 ${ping6} -q -M want -i 0.5 -c 10 -w 2 -s ${sz} ${H1_PING_ARG} ${H2_N2_IP6}\n}\n\nreplace_route_new()\n{\n\t# r1 to h2 via r2 and eth0\n\trun_cmd ip -netns r1 nexthop replace id 1 via ${R2_N1_IP} dev eth0\n\trun_cmd ip -netns r1 nexthop replace id 2 via ${R2_LLADDR} dev eth0\n}\n\nreset_route_new()\n{\n\trun_cmd ip -netns r1 nexthop flush\n\trun_cmd ip -netns h1 nexthop flush\n\n\tinitial_route_new\n}\n\ninitial_route_new()\n{\n\t# r1 to h2 via r2 and eth1\n\trun_cmd ip -netns r1 nexthop add id 1 via ${R2_R1_N1_IP} dev eth1\n\trun_cmd ip -netns r1 ro add ${H2_N2} nhid 1\n\n\trun_cmd ip -netns r1 nexthop add id 2 via ${R2_R1_N1_IP6} dev eth1\n\trun_cmd ip -netns r1 -6 ro add ${H2_N2_6} nhid 2\n\n\t# h1 to h2 via r1\n\trun_cmd ip -netns h1 nexthop add id 1 via ${R1_N1_IP} dev br0\n\trun_cmd ip -netns h1 ro add ${H1_VRF_ARG} ${H2_N2} nhid 1\n\n\trun_cmd ip -netns h1 nexthop add id 2 via ${R1_LLADDR} dev br0\n\trun_cmd ip -netns h1 -6 ro add ${H1_VRF_ARG} ${H2_N2_6} nhid 2\n}\n\nreplace_route_legacy()\n{\n\t# r1 to h2 via r2 and eth0\n\trun_cmd ip -netns r1    ro replace ${H2_N2}   via ${R2_N1_IP}  dev eth0\n\trun_cmd ip -netns r1 -6 ro replace ${H2_N2_6} via ${R2_LLADDR} dev eth0\n}\n\nreset_route_legacy()\n{\n\trun_cmd ip -netns r1    ro del ${H2_N2}\n\trun_cmd ip -netns r1 -6 ro del ${H2_N2_6}\n\n\trun_cmd ip -netns h1    ro del ${H1_VRF_ARG} ${H2_N2}\n\trun_cmd ip -netns h1 -6 ro del ${H1_VRF_ARG} ${H2_N2_6}\n\n\tinitial_route_legacy\n}\n\ninitial_route_legacy()\n{\n\t# r1 to h2 via r2 and eth1\n\trun_cmd ip -netns r1    ro add ${H2_N2}   via ${R2_R1_N1_IP}  dev eth1\n\trun_cmd ip -netns r1 -6 ro add ${H2_N2_6} via ${R2_R1_N1_IP6} dev eth1\n\n\t# h1 to h2 via r1\n\t# - IPv6 redirect only works if gateway is the LLA\n\trun_cmd ip -netns h1    ro add ${H1_VRF_ARG} ${H2_N2} via ${R1_N1_IP} dev br0\n\trun_cmd ip -netns h1 -6 ro add ${H1_VRF_ARG} ${H2_N2_6} via ${R1_LLADDR} dev br0\n}\n\ncheck_connectivity()\n{\n\tlocal rc\n\n\trun_cmd ip netns exec h1 ping -c1 -w1 ${H1_PING_ARG} ${H2_N2_IP}\n\trc=$?\n\trun_cmd ip netns exec h1 ${ping6} -c1 -w1 ${H1_PING_ARG} ${H2_N2_IP6}\n\t[ $? -ne 0 ] && rc=$?\n\n\treturn $rc\n}\n\ndo_test()\n{\n\tlocal ttype=\"$1\"\n\n\teval initial_route_${ttype}\n\n\t# verify connectivity\n\tcheck_connectivity\n\tif [ $? -ne 0 ]; then\n\t\techo \"Error: Basic connectivity is broken\"\n\t\tret=1\n\t\treturn\n\tfi\n\n\t# redirect exception followed by mtu\n\teval replace_route_${ttype}\n\trun_ping 64\n\tcheck_exception \"\" \"yes\" \"redirect exception\"\n\n\tcheck_connectivity\n\tif [ $? -ne 0 ]; then\n\t\techo \"Error: Basic connectivity is broken after redirect\"\n\t\tret=1\n\t\treturn\n\tfi\n\n\tchange_h2_mtu 1300\n\trun_ping 1350\n\tcheck_exception \"1300\" \"yes\" \"redirect exception plus mtu\"\n\n\t# remove exceptions and restore routing\n\tchange_h2_mtu 1500\n\teval reset_route_${ttype}\n\n\tcheck_connectivity\n\tif [ $? -ne 0 ]; then\n\t\techo \"Error: Basic connectivity is broken after reset\"\n\t\tret=1\n\t\treturn\n\tfi\n\tcheck_exception \"\" \"no\" \"routing reset\"\n\n\t# MTU exception followed by redirect\n\tchange_h2_mtu 1300\n\trun_ping 1350\n\tcheck_exception \"1300\" \"no\" \"mtu exception\"\n\n\teval replace_route_${ttype}\n\trun_ping 64\n\tcheck_exception \"1300\" \"yes\" \"mtu exception plus redirect\"\n\n\tcheck_connectivity\n\tif [ $? -ne 0 ]; then\n\t\techo \"Error: Basic connectivity is broken after redirect\"\n\t\tret=1\n\t\treturn\n\tfi\n}\n\n################################################################################\n# usage\n\nusage()\n{\n        cat <<EOF\nusage: ${0##*/} OPTS\n\n\t-p          Pause on fail\n\t-v          verbose mode (show commands and output)\nEOF\n}\n\n################################################################################\n# main\n\n# Some systems don't have a ping6 binary anymore\nwhich ping6 > /dev/null 2>&1 && ping6=$(which ping6) || ping6=$(which ping)\n\nret=0\nnsuccess=0\nnfail=0\nnxfail=0\n\nwhile getopts :pv o\ndo\n\tcase $o in\n                p) PAUSE_ON_FAIL=yes;;\n                v) VERBOSE=$(($VERBOSE + 1));;\n                *) usage; exit 1;;\n\tesac\ndone\n\ntrap cleanup EXIT\n\ncleanup\nWITH_VRF=no\nsetup\n\nlog_section \"Legacy routing\"\ndo_test \"legacy\"\n\ncleanup\nlog_section \"Legacy routing with VRF\"\nWITH_VRF=yes\nsetup\ndo_test \"legacy\"\n\ncleanup\nlog_section \"Routing with nexthop objects\"\nip nexthop ls >/dev/null 2>&1\nif [ $? -eq 0 ]; then\n\tWITH_VRF=no\n\tsetup\n\tdo_test \"new\"\n\n\tcleanup\n\tlog_section \"Routing with nexthop objects and VRF\"\n\tWITH_VRF=yes\n\tsetup\n\tdo_test \"new\"\nelse\n\techo \"Nexthop objects not supported; skipping tests\"\nfi\n\nprintf \"\\nTests passed: %3d\\n\" ${nsuccess}\nprintf \"Tests failed: %3d\\n\"   ${nfail}\nprintf \"Tests xfailed: %3d\\n\"  ${nxfail}\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}