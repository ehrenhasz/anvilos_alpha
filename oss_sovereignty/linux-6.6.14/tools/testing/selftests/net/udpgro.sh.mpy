{
  "module_name": "udpgro.sh",
  "hash_id": "5f9adea725a807ff05de8b4c8266b752ec658541b867b527ab6b6e0e7c70a259",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/udpgro.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Run a series of udpgro functional tests.\n\nreadonly PEER_NS=\"ns-peer-$(mktemp -u XXXXXX)\"\n\nBPF_FILE=\"../bpf/xdp_dummy.bpf.o\"\n\n# set global exit status, but never reset nonzero one.\ncheck_err()\n{\n\tif [ $ret -eq 0 ]; then\n\t\tret=$1\n\tfi\n}\n\ncleanup() {\n\tlocal -r jobs=\"$(jobs -p)\"\n\tlocal -r ns=\"$(ip netns list|grep $PEER_NS)\"\n\n\t[ -n \"${jobs}\" ] && kill -1 ${jobs} 2>/dev/null\n\t[ -n \"$ns\" ] && ip netns del $ns 2>/dev/null\n}\ntrap cleanup EXIT\n\ncfg_veth() {\n\tip netns add \"${PEER_NS}\"\n\tip -netns \"${PEER_NS}\" link set lo up\n\tip link add type veth\n\tip link set dev veth0 up\n\tip addr add dev veth0 192.168.1.2/24\n\tip addr add dev veth0 2001:db8::2/64 nodad\n\n\tip link set dev veth1 netns \"${PEER_NS}\"\n\tip -netns \"${PEER_NS}\" addr add dev veth1 192.168.1.1/24\n\tip -netns \"${PEER_NS}\" addr add dev veth1 2001:db8::1/64 nodad\n\tip -netns \"${PEER_NS}\" link set dev veth1 up\n\tip -n \"${PEER_NS}\" link set veth1 xdp object ${BPF_FILE} section xdp\n}\n\nrun_one() {\n\t# use 'rx' as separator between sender args and receiver args\n\tlocal -r all=\"$@\"\n\tlocal -r tx_args=${all%rx*}\n\tlocal -r rx_args=${all#*rx}\n\n\tcfg_veth\n\n\tip netns exec \"${PEER_NS}\" ./udpgso_bench_rx -C 1000 -R 10 ${rx_args} && \\\n\t\techo \"ok\" || \\\n\t\techo \"failed\" &\n\n\t# Hack: let bg programs complete the startup\n\tsleep 0.2\n\t./udpgso_bench_tx ${tx_args}\n\tret=$?\n\twait $(jobs -p)\n\treturn $ret\n}\n\nrun_test() {\n\tlocal -r args=$@\n\n\tprintf \" %-40s\" \"$1\"\n\t./in_netns.sh $0 __subprocess $2 rx -G -r $3\n}\n\nrun_one_nat() {\n\t# use 'rx' as separator between sender args and receiver args\n\tlocal addr1 addr2 pid family=\"\" ipt_cmd=ip6tables\n\tlocal -r all=\"$@\"\n\tlocal -r tx_args=${all%rx*}\n\tlocal -r rx_args=${all#*rx}\n\n\tif [[ ${tx_args} = *-4* ]]; then\n\t\tipt_cmd=iptables\n\t\tfamily=-4\n\t\taddr1=192.168.1.1\n\t\taddr2=192.168.1.3/24\n\telse\n\t\taddr1=2001:db8::1\n\t\taddr2=\"2001:db8::3/64 nodad\"\n\tfi\n\n\tcfg_veth\n\tip -netns \"${PEER_NS}\" addr add dev veth1 ${addr2}\n\n\t# fool the GRO engine changing the destination address ...\n\tip netns exec \"${PEER_NS}\" $ipt_cmd -t nat -I PREROUTING -d ${addr1} -j DNAT --to-destination ${addr2%/*}\n\n\t# ... so that GRO will match the UDP_GRO enabled socket, but packets\n\t# will land on the 'plain' one\n\tip netns exec \"${PEER_NS}\" ./udpgso_bench_rx -G ${family} -b ${addr1} -n 0 &\n\tpid=$!\n\tip netns exec \"${PEER_NS}\" ./udpgso_bench_rx -C 1000 -R 10 ${family} -b ${addr2%/*} ${rx_args} && \\\n\t\techo \"ok\" || \\\n\t\techo \"failed\"&\n\n\tsleep 0.1\n\t./udpgso_bench_tx ${tx_args}\n\tret=$?\n\tkill -INT $pid\n\twait $(jobs -p)\n\treturn $ret\n}\n\nrun_one_2sock() {\n\t# use 'rx' as separator between sender args and receiver args\n\tlocal -r all=\"$@\"\n\tlocal -r tx_args=${all%rx*}\n\tlocal -r rx_args=${all#*rx}\n\n\tcfg_veth\n\n\tip netns exec \"${PEER_NS}\" ./udpgso_bench_rx -C 1000 -R 10 ${rx_args} -p 12345 &\n\tip netns exec \"${PEER_NS}\" ./udpgso_bench_rx -C 2000 -R 10 ${rx_args} && \\\n\t\techo \"ok\" || \\\n\t\techo \"failed\" &\n\n\t# Hack: let bg programs complete the startup\n\tsleep 0.2\n\t./udpgso_bench_tx ${tx_args} -p 12345\n\tsleep 0.1\n\t# first UDP GSO socket should be closed at this point\n\t./udpgso_bench_tx ${tx_args}\n\tret=$?\n\twait $(jobs -p)\n\treturn $ret\n}\n\nrun_nat_test() {\n\tlocal -r args=$@\n\n\tprintf \" %-40s\" \"$1\"\n\t./in_netns.sh $0 __subprocess_nat $2 rx -r $3\n}\n\nrun_2sock_test() {\n\tlocal -r args=$@\n\n\tprintf \" %-40s\" \"$1\"\n\t./in_netns.sh $0 __subprocess_2sock $2 rx -G -r $3\n}\n\nrun_all() {\n\tlocal -r core_args=\"-l 4\"\n\tlocal -r ipv4_args=\"${core_args} -4 -D 192.168.1.1\"\n\tlocal -r ipv6_args=\"${core_args} -6 -D 2001:db8::1\"\n\tret=0\n\n\techo \"ipv4\"\n\trun_test \"no GRO\" \"${ipv4_args} -M 10 -s 1400\" \"-4 -n 10 -l 1400\"\n\tcheck_err $?\n\n\t# explicitly check we are not receiving UDP_SEGMENT cmsg (-S -1)\n\t# when GRO does not take place\n\trun_test \"no GRO chk cmsg\" \"${ipv4_args} -M 10 -s 1400\" \"-4 -n 10 -l 1400 -S -1\"\n\tcheck_err $?\n\n\t# the GSO packets are aggregated because:\n\t# * veth schedule napi after each xmit\n\t# * segmentation happens in BH context, veth napi poll is delayed after\n\t#   the transmission of the last segment\n\trun_test \"GRO\" \"${ipv4_args} -M 1 -s 14720 -S 0 \" \"-4 -n 1 -l 14720\"\n\tcheck_err $?\n\trun_test \"GRO chk cmsg\" \"${ipv4_args} -M 1 -s 14720 -S 0 \" \"-4 -n 1 -l 14720 -S 1472\"\n\tcheck_err $?\n\trun_test \"GRO with custom segment size\" \"${ipv4_args} -M 1 -s 14720 -S 500 \" \"-4 -n 1 -l 14720\"\n\tcheck_err $?\n\trun_test \"GRO with custom segment size cmsg\" \"${ipv4_args} -M 1 -s 14720 -S 500 \" \"-4 -n 1 -l 14720 -S 500\"\n\tcheck_err $?\n\n\trun_nat_test \"bad GRO lookup\" \"${ipv4_args} -M 1 -s 14720 -S 0\" \"-n 10 -l 1472\"\n\tcheck_err $?\n\trun_2sock_test \"multiple GRO socks\" \"${ipv4_args} -M 1 -s 14720 -S 0 \" \"-4 -n 1 -l 14720 -S 1472\"\n\tcheck_err $?\n\n\techo \"ipv6\"\n\trun_test \"no GRO\" \"${ipv6_args} -M 10 -s 1400\" \"-n 10 -l 1400\"\n\tcheck_err $?\n\trun_test \"no GRO chk cmsg\" \"${ipv6_args} -M 10 -s 1400\" \"-n 10 -l 1400 -S -1\"\n\tcheck_err $?\n\trun_test \"GRO\" \"${ipv6_args} -M 1 -s 14520 -S 0\" \"-n 1 -l 14520\"\n\tcheck_err $?\n\trun_test \"GRO chk cmsg\" \"${ipv6_args} -M 1 -s 14520 -S 0\" \"-n 1 -l 14520 -S 1452\"\n\tcheck_err $?\n\trun_test \"GRO with custom segment size\" \"${ipv6_args} -M 1 -s 14520 -S 500\" \"-n 1 -l 14520\"\n\tcheck_err $?\n\trun_test \"GRO with custom segment size cmsg\" \"${ipv6_args} -M 1 -s 14520 -S 500\" \"-n 1 -l 14520 -S 500\"\n\tcheck_err $?\n\n\trun_nat_test \"bad GRO lookup\" \"${ipv6_args} -M 1 -s 14520 -S 0\" \"-n 10 -l 1452\"\n\tcheck_err $?\n\trun_2sock_test \"multiple GRO socks\" \"${ipv6_args} -M 1 -s 14520 -S 0 \" \"-n 1 -l 14520 -S 1452\"\n\tcheck_err $?\n\treturn $ret\n}\n\nif [ ! -f ${BPF_FILE} ]; then\n\techo \"Missing ${BPF_FILE}. Build bpf selftest first\"\n\texit -1\nfi\n\nif [[ $# -eq 0 ]]; then\n\trun_all\nelif [[ $1 == \"__subprocess\" ]]; then\n\tshift\n\trun_one $@\nelif [[ $1 == \"__subprocess_nat\" ]]; then\n\tshift\n\trun_one_nat $@\nelif [[ $1 == \"__subprocess_2sock\" ]]; then\n\tshift\n\trun_one_2sock $@\nfi\n\nexit $?\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}