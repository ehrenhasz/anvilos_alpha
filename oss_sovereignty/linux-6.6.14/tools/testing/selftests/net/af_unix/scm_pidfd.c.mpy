{
  "module_name": "scm_pidfd.c",
  "hash_id": "841bad06e5377ed45b8bc4293fdee31c7e417253706ff107eed1e0ee61e9d316",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/af_unix/scm_pidfd.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <error.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <linux/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/un.h>\n#include <sys/signal.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include \"../../kselftest_harness.h\"\n\n#define clean_errno() (errno == 0 ? \"None\" : strerror(errno))\n#define log_err(MSG, ...)                                                   \\\n\tfprintf(stderr, \"(%s:%d: errno: %s) \" MSG \"\\n\", __FILE__, __LINE__, \\\n\t\tclean_errno(), ##__VA_ARGS__)\n\n#ifndef SCM_PIDFD\n#define SCM_PIDFD 0x04\n#endif\n\nstatic void child_die()\n{\n\texit(1);\n}\n\nstatic int safe_int(const char *numstr, int *converted)\n{\n\tchar *err = NULL;\n\tlong sli;\n\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno == ERANGE && (sli == LONG_MAX || sli == LONG_MIN))\n\t\treturn -ERANGE;\n\n\tif (errno != 0 && sli == 0)\n\t\treturn -EINVAL;\n\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\n\tif (sli > INT_MAX || sli < INT_MIN)\n\t\treturn -ERANGE;\n\n\t*converted = (int)sli;\n\treturn 0;\n}\n\nstatic int char_left_gc(const char *buffer, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] == ' ' || buffer[i] == '\\t')\n\t\t\tcontinue;\n\n\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nstatic int char_right_gc(const char *buffer, size_t len)\n{\n\tint i;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (buffer[i] == ' ' || buffer[i] == '\\t' ||\n\t\t    buffer[i] == '\\n' || buffer[i] == '\\0')\n\t\t\tcontinue;\n\n\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}\n\nstatic char *trim_whitespace_in_place(char *buffer)\n{\n\tbuffer += char_left_gc(buffer, strlen(buffer));\n\tbuffer[char_right_gc(buffer, strlen(buffer))] = '\\0';\n\treturn buffer;\n}\n\n \nstatic pid_t get_pid_from_fdinfo_file(int pidfd, const char *key, size_t keylen)\n{\n\tint ret;\n\tchar path[512];\n\tFILE *f;\n\tsize_t n = 0;\n\tpid_t result = -1;\n\tchar *line = NULL;\n\n\tsnprintf(path, sizeof(path), \"/proc/self/fdinfo/%d\", pidfd);\n\n\tf = fopen(path, \"re\");\n\tif (!f)\n\t\treturn -1;\n\n\twhile (getline(&line, &n, f) != -1) {\n\t\tchar *numstr;\n\n\t\tif (strncmp(line, key, keylen))\n\t\t\tcontinue;\n\n\t\tnumstr = trim_whitespace_in_place(line + 4);\n\t\tret = safe_int(numstr, &result);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tbreak;\n\t}\n\nout:\n\tfree(line);\n\tfclose(f);\n\treturn result;\n}\n\nstatic int cmsg_check(int fd)\n{\n\tstruct msghdr msg = { 0 };\n\tstruct cmsghdr *cmsg;\n\tstruct iovec iov;\n\tstruct ucred *ucred = NULL;\n\tint data = 0;\n\tchar control[CMSG_SPACE(sizeof(struct ucred)) +\n\t\t     CMSG_SPACE(sizeof(int))] = { 0 };\n\tint *pidfd = NULL;\n\tpid_t parent_pid;\n\tint err;\n\n\tiov.iov_base = &data;\n\tiov.iov_len = sizeof(data);\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = control;\n\tmsg.msg_controllen = sizeof(control);\n\n\terr = recvmsg(fd, &msg, 0);\n\tif (err < 0) {\n\t\tlog_err(\"recvmsg\");\n\t\treturn 1;\n\t}\n\n\tif (msg.msg_flags & (MSG_TRUNC | MSG_CTRUNC)) {\n\t\tlog_err(\"recvmsg: truncated\");\n\t\treturn 1;\n\t}\n\n\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;\n\t     cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\tif (cmsg->cmsg_level == SOL_SOCKET &&\n\t\t    cmsg->cmsg_type == SCM_PIDFD) {\n\t\t\tif (cmsg->cmsg_len < sizeof(*pidfd)) {\n\t\t\t\tlog_err(\"CMSG parse: SCM_PIDFD wrong len\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tpidfd = (void *)CMSG_DATA(cmsg);\n\t\t}\n\n\t\tif (cmsg->cmsg_level == SOL_SOCKET &&\n\t\t    cmsg->cmsg_type == SCM_CREDENTIALS) {\n\t\t\tif (cmsg->cmsg_len < sizeof(*ucred)) {\n\t\t\t\tlog_err(\"CMSG parse: SCM_CREDENTIALS wrong len\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tucred = (void *)CMSG_DATA(cmsg);\n\t\t}\n\t}\n\n\t \n\tif (data != 'x') {\n\t\tlog_err(\"recvmsg: data corruption\");\n\t\treturn 1;\n\t}\n\n\tif (!pidfd) {\n\t\tlog_err(\"CMSG parse: SCM_PIDFD not found\");\n\t\treturn 1;\n\t}\n\n\tif (!ucred) {\n\t\tlog_err(\"CMSG parse: SCM_CREDENTIALS not found\");\n\t\treturn 1;\n\t}\n\n\t \n\tparent_pid =\n\t\tget_pid_from_fdinfo_file(*pidfd, \"Pid:\", sizeof(\"Pid:\") - 1);\n\tif (parent_pid != getppid()) {\n\t\tlog_err(\"wrong SCM_PIDFD %d != %d\", parent_pid, getppid());\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstruct sock_addr {\n\tchar sock_name[32];\n\tstruct sockaddr_un listen_addr;\n\tsocklen_t addrlen;\n};\n\nFIXTURE(scm_pidfd)\n{\n\tint server;\n\tpid_t client_pid;\n\tint startup_pipe[2];\n\tstruct sock_addr server_addr;\n\tstruct sock_addr *client_addr;\n};\n\nFIXTURE_VARIANT(scm_pidfd)\n{\n\tint type;\n\tbool abstract;\n};\n\nFIXTURE_VARIANT_ADD(scm_pidfd, stream_pathname)\n{\n\t.type = SOCK_STREAM,\n\t.abstract = 0,\n};\n\nFIXTURE_VARIANT_ADD(scm_pidfd, stream_abstract)\n{\n\t.type = SOCK_STREAM,\n\t.abstract = 1,\n};\n\nFIXTURE_VARIANT_ADD(scm_pidfd, dgram_pathname)\n{\n\t.type = SOCK_DGRAM,\n\t.abstract = 0,\n};\n\nFIXTURE_VARIANT_ADD(scm_pidfd, dgram_abstract)\n{\n\t.type = SOCK_DGRAM,\n\t.abstract = 1,\n};\n\nFIXTURE_SETUP(scm_pidfd)\n{\n\tself->client_addr = mmap(NULL, sizeof(*self->client_addr), PROT_READ | PROT_WRITE,\n\t\t\t\t MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\tASSERT_NE(MAP_FAILED, self->client_addr);\n}\n\nFIXTURE_TEARDOWN(scm_pidfd)\n{\n\tclose(self->server);\n\n\tkill(self->client_pid, SIGKILL);\n\twaitpid(self->client_pid, NULL, 0);\n\n\tif (!variant->abstract) {\n\t\tunlink(self->server_addr.sock_name);\n\t\tunlink(self->client_addr->sock_name);\n\t}\n}\n\nstatic void fill_sockaddr(struct sock_addr *addr, bool abstract)\n{\n\tchar *sun_path_buf = (char *)&addr->listen_addr.sun_path;\n\n\taddr->listen_addr.sun_family = AF_UNIX;\n\taddr->addrlen = offsetof(struct sockaddr_un, sun_path);\n\tsnprintf(addr->sock_name, sizeof(addr->sock_name), \"scm_pidfd_%d\", getpid());\n\taddr->addrlen += strlen(addr->sock_name);\n\tif (abstract) {\n\t\t*sun_path_buf = '\\0';\n\t\taddr->addrlen++;\n\t\tsun_path_buf++;\n\t} else {\n\t\tunlink(addr->sock_name);\n\t}\n\tmemcpy(sun_path_buf, addr->sock_name, strlen(addr->sock_name));\n}\n\nstatic void client(FIXTURE_DATA(scm_pidfd) *self,\n\t\t   const FIXTURE_VARIANT(scm_pidfd) *variant)\n{\n\tint err;\n\tint cfd;\n\tsocklen_t len;\n\tstruct ucred peer_cred;\n\tint peer_pidfd;\n\tpid_t peer_pid;\n\tint on = 0;\n\n\tcfd = socket(AF_UNIX, variant->type, 0);\n\tif (cfd < 0) {\n\t\tlog_err(\"socket\");\n\t\tchild_die();\n\t}\n\n\tif (variant->type == SOCK_DGRAM) {\n\t\tfill_sockaddr(self->client_addr, variant->abstract);\n\n\t\tif (bind(cfd, (struct sockaddr *)&self->client_addr->listen_addr, self->client_addr->addrlen)) {\n\t\t\tlog_err(\"bind\");\n\t\t\tchild_die();\n\t\t}\n\t}\n\n\tif (connect(cfd, (struct sockaddr *)&self->server_addr.listen_addr,\n\t\t    self->server_addr.addrlen) != 0) {\n\t\tlog_err(\"connect\");\n\t\tchild_die();\n\t}\n\n\ton = 1;\n\tif (setsockopt(cfd, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on))) {\n\t\tlog_err(\"Failed to set SO_PASSCRED\");\n\t\tchild_die();\n\t}\n\n\tif (setsockopt(cfd, SOL_SOCKET, SO_PASSPIDFD, &on, sizeof(on))) {\n\t\tlog_err(\"Failed to set SO_PASSPIDFD\");\n\t\tchild_die();\n\t}\n\n\tclose(self->startup_pipe[1]);\n\n\tif (cmsg_check(cfd)) {\n\t\tlog_err(\"cmsg_check failed\");\n\t\tchild_die();\n\t}\n\n\t \n\tif (variant->type == SOCK_DGRAM)\n\t\treturn;\n\n\tlen = sizeof(peer_cred);\n\tif (getsockopt(cfd, SOL_SOCKET, SO_PEERCRED, &peer_cred, &len)) {\n\t\tlog_err(\"Failed to get SO_PEERCRED\");\n\t\tchild_die();\n\t}\n\n\tlen = sizeof(peer_pidfd);\n\tif (getsockopt(cfd, SOL_SOCKET, SO_PEERPIDFD, &peer_pidfd, &len)) {\n\t\tlog_err(\"Failed to get SO_PEERPIDFD\");\n\t\tchild_die();\n\t}\n\n\t \n\tif (peer_cred.pid != getppid()) {\n\t\tlog_err(\"peer_cred.pid != getppid(): %d != %d\", peer_cred.pid, getppid());\n\t\tchild_die();\n\t}\n\n\tpeer_pid = get_pid_from_fdinfo_file(peer_pidfd,\n\t\t\t\t\t    \"Pid:\", sizeof(\"Pid:\") - 1);\n\tif (peer_pid != peer_cred.pid) {\n\t\tlog_err(\"peer_pid != peer_cred.pid: %d != %d\", peer_pid, peer_cred.pid);\n\t\tchild_die();\n\t}\n}\n\nTEST_F(scm_pidfd, test)\n{\n\tint err;\n\tint pfd;\n\tint child_status = 0;\n\n\tself->server = socket(AF_UNIX, variant->type, 0);\n\tASSERT_NE(-1, self->server);\n\n\tfill_sockaddr(&self->server_addr, variant->abstract);\n\n\terr = bind(self->server, (struct sockaddr *)&self->server_addr.listen_addr, self->server_addr.addrlen);\n\tASSERT_EQ(0, err);\n\n\tif (variant->type == SOCK_STREAM) {\n\t\terr = listen(self->server, 1);\n\t\tASSERT_EQ(0, err);\n\t}\n\n\terr = pipe(self->startup_pipe);\n\tASSERT_NE(-1, err);\n\n\tself->client_pid = fork();\n\tASSERT_NE(-1, self->client_pid);\n\tif (self->client_pid == 0) {\n\t\tclose(self->server);\n\t\tclose(self->startup_pipe[0]);\n\t\tclient(self, variant);\n\t\texit(0);\n\t}\n\tclose(self->startup_pipe[1]);\n\n\tif (variant->type == SOCK_STREAM) {\n\t\tpfd = accept(self->server, NULL, NULL);\n\t\tASSERT_NE(-1, pfd);\n\t} else {\n\t\tpfd = self->server;\n\t}\n\n\t \n\tread(self->startup_pipe[0], &err, sizeof(int));\n\tclose(self->startup_pipe[0]);\n\n\tif (variant->type == SOCK_DGRAM) {\n\t\terr = sendto(pfd, \"x\", sizeof(char), 0, (struct sockaddr *)&self->client_addr->listen_addr, self->client_addr->addrlen);\n\t\tASSERT_NE(-1, err);\n\t} else {\n\t\terr = send(pfd, \"x\", sizeof(char), 0);\n\t\tASSERT_NE(-1, err);\n\t}\n\n\tclose(pfd);\n\twaitpid(self->client_pid, &child_status, 0);\n\tASSERT_EQ(0, WIFEXITED(child_status) ? WEXITSTATUS(child_status) : 1);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}