{
  "module_name": "reuseport_bpf_numa.c",
  "hash_id": "73370b1715c8d7517c099c25e863e725a445786d4f1ffec331177cfb12b60672",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/reuseport_bpf_numa.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/in.h>\n#include <linux/unistd.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <numa.h>\n\n#include \"../kselftest.h\"\n\nstatic const int PORT = 8888;\n\nstatic void build_rcv_group(int *rcv_fd, size_t len, int family, int proto)\n{\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in  *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tsize_t i;\n\tint opt;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr4 = (struct sockaddr_in *)&addr;\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\t\taddr4->sin_port = htons(PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddr6 = (struct sockaddr_in6 *)&addr;\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_addr = in6addr_any;\n\t\taddr6->sin6_port = htons(PORT);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t}\n\n\tfor (i = 0; i < len; ++i) {\n\t\trcv_fd[i] = socket(family, proto, 0);\n\t\tif (rcv_fd[i] < 0)\n\t\t\terror(1, errno, \"failed to create receive socket\");\n\n\t\topt = 1;\n\t\tif (setsockopt(rcv_fd[i], SOL_SOCKET, SO_REUSEPORT, &opt,\n\t\t\t       sizeof(opt)))\n\t\t\terror(1, errno, \"failed to set SO_REUSEPORT\");\n\n\t\tif (bind(rcv_fd[i], (struct sockaddr *)&addr, sizeof(addr)))\n\t\t\terror(1, errno, \"failed to bind receive socket\");\n\n\t\tif (proto == SOCK_STREAM && listen(rcv_fd[i], len * 10))\n\t\t\terror(1, errno, \"failed to listen on receive port\");\n\t}\n}\n\nstatic void attach_bpf(int fd)\n{\n\tstatic char bpf_log_buf[65536];\n\tstatic const char bpf_license[] = \"\";\n\n\tint bpf_fd;\n\tconst struct bpf_insn prog[] = {\n\t\t \n\t\t{ BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_get_numa_node_id },\n\t\t \n\t\t{ BPF_JMP | BPF_EXIT, 0, 0, 0, 0 }\n\t};\n\tunion bpf_attr attr;\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;\n\tattr.insn_cnt = ARRAY_SIZE(prog);\n\tattr.insns = (unsigned long) &prog;\n\tattr.license = (unsigned long) &bpf_license;\n\tattr.log_buf = (unsigned long) &bpf_log_buf;\n\tattr.log_size = sizeof(bpf_log_buf);\n\tattr.log_level = 1;\n\n\tbpf_fd = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));\n\tif (bpf_fd < 0)\n\t\terror(1, errno, \"ebpf error. log:\\n%s\\n\", bpf_log_buf);\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_REUSEPORT_EBPF, &bpf_fd,\n\t\t\tsizeof(bpf_fd)))\n\t\terror(1, errno, \"failed to set SO_ATTACH_REUSEPORT_EBPF\");\n\n\tclose(bpf_fd);\n}\n\nstatic void send_from_node(int node_id, int family, int proto)\n{\n\tstruct sockaddr_storage saddr, daddr;\n\tstruct sockaddr_in  *saddr4, *daddr4;\n\tstruct sockaddr_in6 *saddr6, *daddr6;\n\tint fd;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tsaddr4 = (struct sockaddr_in *)&saddr;\n\t\tsaddr4->sin_family = AF_INET;\n\t\tsaddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tsaddr4->sin_port = 0;\n\n\t\tdaddr4 = (struct sockaddr_in *)&daddr;\n\t\tdaddr4->sin_family = AF_INET;\n\t\tdaddr4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tdaddr4->sin_port = htons(PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsaddr6 = (struct sockaddr_in6 *)&saddr;\n\t\tsaddr6->sin6_family = AF_INET6;\n\t\tsaddr6->sin6_addr = in6addr_any;\n\t\tsaddr6->sin6_port = 0;\n\n\t\tdaddr6 = (struct sockaddr_in6 *)&daddr;\n\t\tdaddr6->sin6_family = AF_INET6;\n\t\tdaddr6->sin6_addr = in6addr_loopback;\n\t\tdaddr6->sin6_port = htons(PORT);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t}\n\n\tif (numa_run_on_node(node_id) < 0)\n\t\terror(1, errno, \"failed to pin to node\");\n\n\tfd = socket(family, proto, 0);\n\tif (fd < 0)\n\t\terror(1, errno, \"failed to create send socket\");\n\n\tif (bind(fd, (struct sockaddr *)&saddr, sizeof(saddr)))\n\t\terror(1, errno, \"failed to bind send socket\");\n\n\tif (connect(fd, (struct sockaddr *)&daddr, sizeof(daddr)))\n\t\terror(1, errno, \"failed to connect send socket\");\n\n\tif (send(fd, \"a\", 1, 0) < 0)\n\t\terror(1, errno, \"failed to send message\");\n\n\tclose(fd);\n}\n\nstatic\nvoid receive_on_node(int *rcv_fd, int len, int epfd, int node_id, int proto)\n{\n\tstruct epoll_event ev;\n\tint i, fd;\n\tchar buf[8];\n\n\ti = epoll_wait(epfd, &ev, 1, -1);\n\tif (i < 0)\n\t\terror(1, errno, \"epoll_wait failed\");\n\n\tif (proto == SOCK_STREAM) {\n\t\tfd = accept(ev.data.fd, NULL, NULL);\n\t\tif (fd < 0)\n\t\t\terror(1, errno, \"failed to accept\");\n\t\ti = recv(fd, buf, sizeof(buf), 0);\n\t\tclose(fd);\n\t} else {\n\t\ti = recv(ev.data.fd, buf, sizeof(buf), 0);\n\t}\n\n\tif (i < 0)\n\t\terror(1, errno, \"failed to recv\");\n\n\tfor (i = 0; i < len; ++i)\n\t\tif (ev.data.fd == rcv_fd[i])\n\t\t\tbreak;\n\tif (i == len)\n\t\terror(1, 0, \"failed to find socket\");\n\tfprintf(stderr, \"send node %d, receive socket %d\\n\", node_id, i);\n\tif (node_id != i)\n\t\terror(1, 0, \"node id/receive socket mismatch\");\n}\n\nstatic void test(int *rcv_fd, int len, int family, int proto)\n{\n\tstruct epoll_event ev;\n\tint epfd, node;\n\n\tbuild_rcv_group(rcv_fd, len, family, proto);\n\tattach_bpf(rcv_fd[0]);\n\n\tepfd = epoll_create(1);\n\tif (epfd < 0)\n\t\terror(1, errno, \"failed to create epoll\");\n\tfor (node = 0; node < len; ++node) {\n\t\tev.events = EPOLLIN;\n\t\tev.data.fd = rcv_fd[node];\n\t\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, rcv_fd[node], &ev))\n\t\t\terror(1, errno, \"failed to register sock epoll\");\n\t}\n\n\t \n\tfor (node = 0; node < len; ++node) {\n\t\tif (!numa_bitmask_isbitset(numa_nodes_ptr, node))\n\t\t\tcontinue;\n\t\tsend_from_node(node, family, proto);\n\t\treceive_on_node(rcv_fd, len, epfd, node, proto);\n\t}\n\n\t \n\tfor (node = len - 1; node >= 0; --node) {\n\t\tif (!numa_bitmask_isbitset(numa_nodes_ptr, node))\n\t\t\tcontinue;\n\t\tsend_from_node(node, family, proto);\n\t\treceive_on_node(rcv_fd, len, epfd, node, proto);\n\t}\n\n\tclose(epfd);\n\tfor (node = 0; node < len; ++node)\n\t\tclose(rcv_fd[node]);\n}\n\nint main(void)\n{\n\tint *rcv_fd, nodes;\n\n\tif (numa_available() < 0)\n\t\tksft_exit_skip(\"no numa api support\\n\");\n\n\tnodes = numa_max_node() + 1;\n\n\trcv_fd = calloc(nodes, sizeof(int));\n\tif (!rcv_fd)\n\t\terror(1, 0, \"failed to allocate array\");\n\n\tfprintf(stderr, \"---- IPv4 UDP ----\\n\");\n\ttest(rcv_fd, nodes, AF_INET, SOCK_DGRAM);\n\n\tfprintf(stderr, \"---- IPv6 UDP ----\\n\");\n\ttest(rcv_fd, nodes, AF_INET6, SOCK_DGRAM);\n\n\tfprintf(stderr, \"---- IPv4 TCP ----\\n\");\n\ttest(rcv_fd, nodes, AF_INET, SOCK_STREAM);\n\n\tfprintf(stderr, \"---- IPv6 TCP ----\\n\");\n\ttest(rcv_fd, nodes, AF_INET6, SOCK_STREAM);\n\n\tfree(rcv_fd);\n\n\tfprintf(stderr, \"SUCCESS\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}