{
  "module_name": "reuseport_bpf.c",
  "hash_id": "ec070842a5b55a8df20fce9b749d92149b4cdc452628a675266b877d8a006bb2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/reuseport_bpf.c",
  "human_readable_source": " \n\n#include <errno.h>\n#include <error.h>\n#include <fcntl.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/unistd.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/resource.h>\n#include <unistd.h>\n\n#include \"../kselftest.h\"\n\nstruct test_params {\n\tint recv_family;\n\tint send_family;\n\tint protocol;\n\tsize_t recv_socks;\n\tuint16_t recv_port;\n\tuint16_t send_port_min;\n};\n\nstatic size_t sockaddr_size(void)\n{\n\treturn sizeof(struct sockaddr_storage);\n}\n\nstatic struct sockaddr *new_any_sockaddr(int family, uint16_t port)\n{\n\tstruct sockaddr_storage *addr;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\n\taddr = malloc(sizeof(struct sockaddr_storage));\n\tmemset(addr, 0, sizeof(struct sockaddr_storage));\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr4 = (struct sockaddr_in *)addr;\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_addr.s_addr = htonl(INADDR_ANY);\n\t\taddr4->sin_port = htons(port);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddr6 = (struct sockaddr_in6 *)addr;\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_addr = in6addr_any;\n\t\taddr6->sin6_port = htons(port);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t}\n\treturn (struct sockaddr *)addr;\n}\n\nstatic struct sockaddr *new_loopback_sockaddr(int family, uint16_t port)\n{\n\tstruct sockaddr *addr = new_any_sockaddr(family, port);\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr4 = (struct sockaddr_in *)addr;\n\t\taddr4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddr6 = (struct sockaddr_in6 *)addr;\n\t\taddr6->sin6_addr = in6addr_loopback;\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"Unsupported family %d\", family);\n\t}\n\treturn addr;\n}\n\nstatic void attach_ebpf(int fd, uint16_t mod)\n{\n\tstatic char bpf_log_buf[65536];\n\tstatic const char bpf_license[] = \"GPL\";\n\n\tint bpf_fd;\n\tconst struct bpf_insn prog[] = {\n\t\t \n\t\t{ BPF_ALU64 | BPF_MOV | BPF_X, BPF_REG_6, BPF_REG_1, 0, 0 },\n\t\t \n\t\t{ BPF_LD | BPF_ABS | BPF_W, 0, 0, 0, 0 },\n\t\t \n\t\t{ BPF_ALU64 | BPF_MOD | BPF_K, BPF_REG_0, 0, 0, mod },\n\t\t \n\t\t{ BPF_JMP | BPF_EXIT, 0, 0, 0, 0 }\n\t};\n\tunion bpf_attr attr;\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;\n\tattr.insn_cnt = ARRAY_SIZE(prog);\n\tattr.insns = (unsigned long) &prog;\n\tattr.license = (unsigned long) &bpf_license;\n\tattr.log_buf = (unsigned long) &bpf_log_buf;\n\tattr.log_size = sizeof(bpf_log_buf);\n\tattr.log_level = 1;\n\tattr.kern_version = 0;\n\n\tbpf_fd = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));\n\tif (bpf_fd < 0)\n\t\terror(1, errno, \"ebpf error. log:\\n%s\\n\", bpf_log_buf);\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_REUSEPORT_EBPF, &bpf_fd,\n\t\t\tsizeof(bpf_fd)))\n\t\terror(1, errno, \"failed to set SO_ATTACH_REUSEPORT_EBPF\");\n\n\tclose(bpf_fd);\n}\n\nstatic void attach_cbpf(int fd, uint16_t mod)\n{\n\tstruct sock_filter code[] = {\n\t\t \n\t\t{ BPF_LD  | BPF_W | BPF_ABS, 0, 0, 0 },\n\t\t \n\t\t{ BPF_ALU | BPF_MOD, 0, 0, mod },\n\t\t \n\t\t{ BPF_RET | BPF_A, 0, 0, 0 },\n\t};\n\tstruct sock_fprog p = {\n\t\t.len = ARRAY_SIZE(code),\n\t\t.filter = code,\n\t};\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_ATTACH_REUSEPORT_CBPF, &p, sizeof(p)))\n\t\terror(1, errno, \"failed to set SO_ATTACH_REUSEPORT_CBPF\");\n}\n\nstatic void build_recv_group(const struct test_params p, int fd[], uint16_t mod,\n\t\t\t     void (*attach_bpf)(int, uint16_t))\n{\n\tstruct sockaddr * const addr =\n\t\tnew_any_sockaddr(p.recv_family, p.recv_port);\n\tint i, opt;\n\n\tfor (i = 0; i < p.recv_socks; ++i) {\n\t\tfd[i] = socket(p.recv_family, p.protocol, 0);\n\t\tif (fd[i] < 0)\n\t\t\terror(1, errno, \"failed to create recv %d\", i);\n\n\t\topt = 1;\n\t\tif (setsockopt(fd[i], SOL_SOCKET, SO_REUSEPORT, &opt,\n\t\t\t       sizeof(opt)))\n\t\t\terror(1, errno, \"failed to set SO_REUSEPORT on %d\", i);\n\n\t\tif (i == 0)\n\t\t\tattach_bpf(fd[i], mod);\n\n\t\tif (bind(fd[i], addr, sockaddr_size()))\n\t\t\terror(1, errno, \"failed to bind recv socket %d\", i);\n\n\t\tif (p.protocol == SOCK_STREAM) {\n\t\t\topt = 4;\n\t\t\tif (setsockopt(fd[i], SOL_TCP, TCP_FASTOPEN, &opt,\n\t\t\t\t       sizeof(opt)))\n\t\t\t\terror(1, errno,\n\t\t\t\t      \"failed to set TCP_FASTOPEN on %d\", i);\n\t\t\tif (listen(fd[i], p.recv_socks * 10))\n\t\t\t\terror(1, errno, \"failed to listen on socket\");\n\t\t}\n\t}\n\tfree(addr);\n}\n\nstatic void send_from(struct test_params p, uint16_t sport, char *buf,\n\t\t      size_t len)\n{\n\tstruct sockaddr * const saddr = new_any_sockaddr(p.send_family, sport);\n\tstruct sockaddr * const daddr =\n\t\tnew_loopback_sockaddr(p.send_family, p.recv_port);\n\tconst int fd = socket(p.send_family, p.protocol, 0), one = 1;\n\n\tif (fd < 0)\n\t\terror(1, errno, \"failed to create send socket\");\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)))\n\t\terror(1, errno, \"failed to set reuseaddr\");\n\n\tif (bind(fd, saddr, sockaddr_size()))\n\t\terror(1, errno, \"failed to bind send socket\");\n\n\tif (sendto(fd, buf, len, MSG_FASTOPEN, daddr, sockaddr_size()) < 0)\n\t\terror(1, errno, \"failed to send message\");\n\n\tclose(fd);\n\tfree(saddr);\n\tfree(daddr);\n}\n\nstatic void test_recv_order(const struct test_params p, int fd[], int mod)\n{\n\tchar recv_buf[8], send_buf[8];\n\tstruct msghdr msg;\n\tstruct iovec recv_io = { recv_buf, 8 };\n\tstruct epoll_event ev;\n\tint epfd, conn, i, sport, expected;\n\tuint32_t data, ndata;\n\n\tepfd = epoll_create(1);\n\tif (epfd < 0)\n\t\terror(1, errno, \"failed to create epoll\");\n\tfor (i = 0; i < p.recv_socks; ++i) {\n\t\tev.events = EPOLLIN;\n\t\tev.data.fd = fd[i];\n\t\tif (epoll_ctl(epfd, EPOLL_CTL_ADD, fd[i], &ev))\n\t\t\terror(1, errno, \"failed to register sock %d epoll\", i);\n\t}\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_iov = &recv_io;\n\tmsg.msg_iovlen = 1;\n\n\tfor (data = 0; data < p.recv_socks * 2; ++data) {\n\t\tsport = p.send_port_min + data;\n\t\tndata = htonl(data);\n\t\tmemcpy(send_buf, &ndata, sizeof(ndata));\n\t\tsend_from(p, sport, send_buf, sizeof(ndata));\n\n\t\ti = epoll_wait(epfd, &ev, 1, -1);\n\t\tif (i < 0)\n\t\t\terror(1, errno, \"epoll wait failed\");\n\n\t\tif (p.protocol == SOCK_STREAM) {\n\t\t\tconn = accept(ev.data.fd, NULL, NULL);\n\t\t\tif (conn < 0)\n\t\t\t\terror(1, errno, \"error accepting\");\n\t\t\ti = recvmsg(conn, &msg, 0);\n\t\t\tclose(conn);\n\t\t} else {\n\t\t\ti = recvmsg(ev.data.fd, &msg, 0);\n\t\t}\n\t\tif (i < 0)\n\t\t\terror(1, errno, \"recvmsg error\");\n\t\tif (i != sizeof(ndata))\n\t\t\terror(1, 0, \"expected size %zd got %d\",\n\t\t\t      sizeof(ndata), i);\n\n\t\tfor (i = 0; i < p.recv_socks; ++i)\n\t\t\tif (ev.data.fd == fd[i])\n\t\t\t\tbreak;\n\t\tmemcpy(&ndata, recv_buf, sizeof(ndata));\n\t\tfprintf(stderr, \"Socket %d: %d\\n\", i, ntohl(ndata));\n\n\t\texpected = (sport % mod);\n\t\tif (i != expected)\n\t\t\terror(1, 0, \"expected socket %d\", expected);\n\t}\n}\n\nstatic void test_reuseport_ebpf(struct test_params p)\n{\n\tint i, fd[p.recv_socks];\n\n\tfprintf(stderr, \"Testing EBPF mod %zd...\\n\", p.recv_socks);\n\tbuild_recv_group(p, fd, p.recv_socks, attach_ebpf);\n\ttest_recv_order(p, fd, p.recv_socks);\n\n\tp.send_port_min += p.recv_socks * 2;\n\tfprintf(stderr, \"Reprograming, testing mod %zd...\\n\", p.recv_socks / 2);\n\tattach_ebpf(fd[0], p.recv_socks / 2);\n\ttest_recv_order(p, fd, p.recv_socks / 2);\n\n\tfor (i = 0; i < p.recv_socks; ++i)\n\t\tclose(fd[i]);\n}\n\nstatic void test_reuseport_cbpf(struct test_params p)\n{\n\tint i, fd[p.recv_socks];\n\n\tfprintf(stderr, \"Testing CBPF mod %zd...\\n\", p.recv_socks);\n\tbuild_recv_group(p, fd, p.recv_socks, attach_cbpf);\n\ttest_recv_order(p, fd, p.recv_socks);\n\n\tp.send_port_min += p.recv_socks * 2;\n\tfprintf(stderr, \"Reprograming, testing mod %zd...\\n\", p.recv_socks / 2);\n\tattach_cbpf(fd[0], p.recv_socks / 2);\n\ttest_recv_order(p, fd, p.recv_socks / 2);\n\n\tfor (i = 0; i < p.recv_socks; ++i)\n\t\tclose(fd[i]);\n}\n\nstatic void test_extra_filter(const struct test_params p)\n{\n\tstruct sockaddr * const addr =\n\t\tnew_any_sockaddr(p.recv_family, p.recv_port);\n\tint fd1, fd2, opt;\n\n\tfprintf(stderr, \"Testing too many filters...\\n\");\n\tfd1 = socket(p.recv_family, p.protocol, 0);\n\tif (fd1 < 0)\n\t\terror(1, errno, \"failed to create socket 1\");\n\tfd2 = socket(p.recv_family, p.protocol, 0);\n\tif (fd2 < 0)\n\t\terror(1, errno, \"failed to create socket 2\");\n\n\topt = 1;\n\tif (setsockopt(fd1, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt)))\n\t\terror(1, errno, \"failed to set SO_REUSEPORT on socket 1\");\n\tif (setsockopt(fd2, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt)))\n\t\terror(1, errno, \"failed to set SO_REUSEPORT on socket 2\");\n\n\tattach_ebpf(fd1, 10);\n\tattach_ebpf(fd2, 10);\n\n\tif (bind(fd1, addr, sockaddr_size()))\n\t\terror(1, errno, \"failed to bind recv socket 1\");\n\n\tif (!bind(fd2, addr, sockaddr_size()) || errno != EADDRINUSE)\n\t\terror(1, errno, \"bind socket 2 should fail with EADDRINUSE\");\n\n\tfree(addr);\n}\n\nstatic void test_filter_no_reuseport(const struct test_params p)\n{\n\tstruct sockaddr * const addr =\n\t\tnew_any_sockaddr(p.recv_family, p.recv_port);\n\tconst char bpf_license[] = \"GPL\";\n\tstruct bpf_insn ecode[] = {\n\t\t{ BPF_ALU64 | BPF_MOV | BPF_K, BPF_REG_0, 0, 0, 10 },\n\t\t{ BPF_JMP | BPF_EXIT, 0, 0, 0, 0 }\n\t};\n\tstruct sock_filter ccode[] = {{ BPF_RET | BPF_A, 0, 0, 0 }};\n\tunion bpf_attr eprog;\n\tstruct sock_fprog cprog;\n\tint fd, bpf_fd;\n\n\tfprintf(stderr, \"Testing filters on non-SO_REUSEPORT socket...\\n\");\n\n\tmemset(&eprog, 0, sizeof(eprog));\n\teprog.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;\n\teprog.insn_cnt = ARRAY_SIZE(ecode);\n\teprog.insns = (unsigned long) &ecode;\n\teprog.license = (unsigned long) &bpf_license;\n\teprog.kern_version = 0;\n\n\tmemset(&cprog, 0, sizeof(cprog));\n\tcprog.len = ARRAY_SIZE(ccode);\n\tcprog.filter = ccode;\n\n\n\tbpf_fd = syscall(__NR_bpf, BPF_PROG_LOAD, &eprog, sizeof(eprog));\n\tif (bpf_fd < 0)\n\t\terror(1, errno, \"ebpf error\");\n\tfd = socket(p.recv_family, p.protocol, 0);\n\tif (fd < 0)\n\t\terror(1, errno, \"failed to create socket 1\");\n\n\tif (bind(fd, addr, sockaddr_size()))\n\t\terror(1, errno, \"failed to bind recv socket 1\");\n\n\terrno = 0;\n\tif (!setsockopt(fd, SOL_SOCKET, SO_ATTACH_REUSEPORT_EBPF, &bpf_fd,\n\t\t\tsizeof(bpf_fd)) || errno != EINVAL)\n\t\terror(1, errno, \"setsockopt should have returned EINVAL\");\n\n\terrno = 0;\n\tif (!setsockopt(fd, SOL_SOCKET, SO_ATTACH_REUSEPORT_CBPF, &cprog,\n\t\t       sizeof(cprog)) || errno != EINVAL)\n\t\terror(1, errno, \"setsockopt should have returned EINVAL\");\n\n\tfree(addr);\n}\n\nstatic void test_filter_without_bind(void)\n{\n\tint fd1, fd2, opt = 1;\n\n\tfprintf(stderr, \"Testing filter add without bind...\\n\");\n\tfd1 = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd1 < 0)\n\t\terror(1, errno, \"failed to create socket 1\");\n\tfd2 = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd2 < 0)\n\t\terror(1, errno, \"failed to create socket 2\");\n\tif (setsockopt(fd1, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt)))\n\t\terror(1, errno, \"failed to set SO_REUSEPORT on socket 1\");\n\tif (setsockopt(fd2, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt)))\n\t\terror(1, errno, \"failed to set SO_REUSEPORT on socket 2\");\n\n\tattach_ebpf(fd1, 10);\n\tattach_cbpf(fd2, 10);\n\n\tclose(fd1);\n\tclose(fd2);\n}\n\nvoid enable_fastopen(void)\n{\n\tint fd = open(\"/proc/sys/net/ipv4/tcp_fastopen\", 0);\n\tint rw_mask = 3;   \n\tint val, size;\n\tchar buf[16];\n\n\tif (fd < 0)\n\t\terror(1, errno, \"Unable to open tcp_fastopen sysctl\");\n\tif (read(fd, buf, sizeof(buf)) <= 0)\n\t\terror(1, errno, \"Unable to read tcp_fastopen sysctl\");\n\tval = atoi(buf);\n\tclose(fd);\n\n\tif ((val & rw_mask) != rw_mask) {\n\t\tfd = open(\"/proc/sys/net/ipv4/tcp_fastopen\", O_RDWR);\n\t\tif (fd < 0)\n\t\t\terror(1, errno,\n\t\t\t      \"Unable to open tcp_fastopen sysctl for writing\");\n\t\tval |= rw_mask;\n\t\tsize = snprintf(buf, 16, \"%d\", val);\n\t\tif (write(fd, buf, size) <= 0)\n\t\t\terror(1, errno, \"Unable to write tcp_fastopen sysctl\");\n\t\tclose(fd);\n\t}\n}\n\nstatic struct rlimit rlim_old;\n\nstatic  __attribute__((constructor)) void main_ctor(void)\n{\n\tgetrlimit(RLIMIT_MEMLOCK, &rlim_old);\n\n\tif (rlim_old.rlim_cur != RLIM_INFINITY) {\n\t\tstruct rlimit rlim_new;\n\n\t\trlim_new.rlim_cur = rlim_old.rlim_cur + (1UL << 20);\n\t\trlim_new.rlim_max = rlim_old.rlim_max + (1UL << 20);\n\t\tsetrlimit(RLIMIT_MEMLOCK, &rlim_new);\n\t}\n}\n\nstatic __attribute__((destructor)) void main_dtor(void)\n{\n\tsetrlimit(RLIMIT_MEMLOCK, &rlim_old);\n}\n\nint main(void)\n{\n\tfprintf(stderr, \"---- IPv4 UDP ----\\n\");\n\t \n\ttest_reuseport_ebpf((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8000,\n\t\t.send_port_min = 9000});\n\ttest_reuseport_ebpf((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 20,\n\t\t.recv_port = 8000,\n\t\t.send_port_min = 9000});\n\ttest_reuseport_cbpf((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8001,\n\t\t.send_port_min = 9020});\n\ttest_reuseport_cbpf((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 20,\n\t\t.recv_port = 8001,\n\t\t.send_port_min = 9020});\n\ttest_extra_filter((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_port = 8002});\n\ttest_filter_no_reuseport((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_port = 8008});\n\n\tfprintf(stderr, \"---- IPv6 UDP ----\\n\");\n\ttest_reuseport_ebpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET6,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8003,\n\t\t.send_port_min = 9040});\n\ttest_reuseport_ebpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET6,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 20,\n\t\t.recv_port = 8003,\n\t\t.send_port_min = 9040});\n\ttest_reuseport_cbpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET6,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8004,\n\t\t.send_port_min = 9060});\n\ttest_reuseport_cbpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET6,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 20,\n\t\t.recv_port = 8004,\n\t\t.send_port_min = 9060});\n\ttest_extra_filter((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_port = 8005});\n\ttest_filter_no_reuseport((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_port = 8009});\n\n\tfprintf(stderr, \"---- IPv6 UDP w/ mapped IPv4 ----\\n\");\n\ttest_reuseport_ebpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 20,\n\t\t.recv_port = 8006,\n\t\t.send_port_min = 9080});\n\ttest_reuseport_ebpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8006,\n\t\t.send_port_min = 9080});\n\ttest_reuseport_cbpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8007,\n\t\t.send_port_min = 9100});\n\ttest_reuseport_cbpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_DGRAM,\n\t\t.recv_socks = 20,\n\t\t.recv_port = 8007,\n\t\t.send_port_min = 9100});\n\n\t \n\tenable_fastopen();\n\tfprintf(stderr, \"---- IPv4 TCP ----\\n\");\n\ttest_reuseport_ebpf((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8008,\n\t\t.send_port_min = 9120});\n\ttest_reuseport_cbpf((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8009,\n\t\t.send_port_min = 9160});\n\ttest_extra_filter((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_port = 8010});\n\ttest_filter_no_reuseport((struct test_params) {\n\t\t.recv_family = AF_INET,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_port = 8011});\n\n\tfprintf(stderr, \"---- IPv6 TCP ----\\n\");\n\ttest_reuseport_ebpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET6,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8012,\n\t\t.send_port_min = 9200});\n\ttest_reuseport_cbpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET6,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8013,\n\t\t.send_port_min = 9240});\n\ttest_extra_filter((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_port = 8014});\n\ttest_filter_no_reuseport((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_port = 8015});\n\n\tfprintf(stderr, \"---- IPv6 TCP w/ mapped IPv4 ----\\n\");\n\ttest_reuseport_ebpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8016,\n\t\t.send_port_min = 9320});\n\ttest_reuseport_cbpf((struct test_params) {\n\t\t.recv_family = AF_INET6,\n\t\t.send_family = AF_INET,\n\t\t.protocol = SOCK_STREAM,\n\t\t.recv_socks = 10,\n\t\t.recv_port = 8017,\n\t\t.send_port_min = 9360});\n\n\ttest_filter_without_bind();\n\n\tfprintf(stderr, \"SUCCESS\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}