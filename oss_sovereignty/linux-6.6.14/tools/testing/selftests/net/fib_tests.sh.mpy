{
  "module_name": "fib_tests.sh",
  "hash_id": "912899e0fcb973c35b71bd858db716a298680bf8ac214727bf4804a00f4d9a0a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/fib_tests.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\n# This test is for checking IPv4 and IPv6 FIB behavior in response to\n# different events.\n\nret=0\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\n# all tests in this script. Can be overridden with -t option\nTESTS=\"unregister down carrier nexthop suppress ipv6_notify ipv4_notify \\\n       ipv6_rt ipv4_rt ipv6_addr_metric ipv4_addr_metric ipv6_route_metrics \\\n       ipv4_route_metrics ipv4_route_v6_gw rp_filter ipv4_del_addr \\\n       ipv6_del_addr ipv4_mangle ipv6_mangle ipv4_bcast_neigh fib6_gc_test \\\n       ipv4_mpath_list ipv6_mpath_list\"\n\nVERBOSE=0\nPAUSE_ON_FAIL=no\nPAUSE=no\nIP=\"$(which ip) -netns ns1\"\nNS_EXEC=\"$(which ip) netns exec ns1\"\n\nwhich ping6 > /dev/null 2>&1 && ping6=$(which ping6) || ping6=$(which ping)\n\nlog_test()\n{\n\tlocal rc=$1\n\tlocal expected=$2\n\tlocal msg=\"$3\"\n\n\tif [ ${rc} -eq ${expected} ]; then\n\t\tprintf \"    TEST: %-60s  [ OK ]\\n\" \"${msg}\"\n\t\tnsuccess=$((nsuccess+1))\n\telse\n\t\tret=1\n\t\tnfail=$((nfail+1))\n\t\tprintf \"    TEST: %-60s  [FAIL]\\n\" \"${msg}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\techo\n\t\t\techo \"hit enter to continue, 'q' to quit\"\n\t\t\tread a\n\t\t\t[ \"$a\" = \"q\" ] && exit 1\n\t\tfi\n\tfi\n\n\tif [ \"${PAUSE}\" = \"yes\" ]; then\n\t\techo\n\t\techo \"hit enter to continue, 'q' to quit\"\n\t\tread a\n\t\t[ \"$a\" = \"q\" ] && exit 1\n\tfi\n}\n\nsetup()\n{\n\tset -e\n\tip netns add ns1\n\tip netns set ns1 auto\n\t$IP link set dev lo up\n\tip netns exec ns1 sysctl -qw net.ipv4.ip_forward=1\n\tip netns exec ns1 sysctl -qw net.ipv6.conf.all.forwarding=1\n\n\t$IP link add dummy0 type dummy\n\t$IP link set dev dummy0 up\n\t$IP address add 198.51.100.1/24 dev dummy0\n\t$IP -6 address add 2001:db8:1::1/64 dev dummy0\n\tset +e\n\n}\n\ncleanup()\n{\n\t$IP link del dev dummy0 &> /dev/null\n\tip netns del ns1 &> /dev/null\n\tip netns del ns2 &> /dev/null\n}\n\nget_linklocal()\n{\n\tlocal dev=$1\n\tlocal addr\n\n\taddr=$($IP -6 -br addr show dev ${dev} | \\\n\tawk '{\n\t\tfor (i = 3; i <= NF; ++i) {\n\t\t\tif ($i ~ /^fe80/)\n\t\t\t\tprint $i\n\t\t}\n\t}'\n\t)\n\taddr=${addr/\\/*}\n\n\t[ -z \"$addr\" ] && return 1\n\n\techo $addr\n\n\treturn 0\n}\n\nfib_unreg_unicast_test()\n{\n\techo\n\techo \"Single path route test\"\n\n\tsetup\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link del dev dummy0\n\tset +e\n\n\techo \"    Nexthop device deleted\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch - no route\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch - no route\"\n\n\tcleanup\n}\n\nfib_unreg_multipath_test()\n{\n\n\techo\n\techo \"Multipath route test\"\n\n\tsetup\n\n\tset -e\n\t$IP link add dummy1 type dummy\n\t$IP link set dev dummy1 up\n\t$IP address add 192.0.2.1/24 dev dummy1\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy1\n\n\t$IP route add 203.0.113.0/24 \\\n\t\tnexthop via 198.51.100.2 dev dummy0 \\\n\t\tnexthop via 192.0.2.2 dev dummy1\n\t$IP -6 route add 2001:db8:3::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy0 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy1\n\tset +e\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link del dev dummy0\n\tset +e\n\n\techo \"    One nexthop device deleted\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 2 \"IPv4 - multipath route removed on delete\"\n\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\t# In IPv6 we do not flush the entire multipath route.\n\tlog_test $? 0 \"IPv6 - multipath down to single path\"\n\n\tset -e\n\t$IP link del dev dummy1\n\tset +e\n\n\techo \"    Second nexthop device deleted\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 2 \"IPv6 - no route\"\n\n\tcleanup\n}\n\nfib_unreg_test()\n{\n\tfib_unreg_unicast_test\n\tfib_unreg_multipath_test\n}\n\nfib_down_unicast_test()\n{\n\techo\n\techo \"Single path, admin down\"\n\n\tsetup\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link set dev dummy0 down\n\tset +e\n\n\techo \"    Route deleted on down\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch\"\n\n\tcleanup\n}\n\nfib_down_multipath_test_do()\n{\n\tlocal down_dev=$1\n\tlocal up_dev=$2\n\n\t$IP route get fibmatch 203.0.113.1 \\\n\t\toif $down_dev &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch on down device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 \\\n\t\toif $down_dev &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch on down device\"\n\n\t$IP route get fibmatch 203.0.113.1 \\\n\t\toif $up_dev &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch on up device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 \\\n\t\toif $up_dev &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch on up device\"\n\n\t$IP route get fibmatch 203.0.113.1 | \\\n\t\tgrep $down_dev | grep -q \"dead linkdown\"\n\tlog_test $? 0 \"IPv4 flags on down device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 | \\\n\t\tgrep $down_dev | grep -q \"dead linkdown\"\n\tlog_test $? 0 \"IPv6 flags on down device\"\n\n\t$IP route get fibmatch 203.0.113.1 | \\\n\t\tgrep $up_dev | grep -q \"dead linkdown\"\n\tlog_test $? 1 \"IPv4 flags on up device\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 | \\\n\t\tgrep $up_dev | grep -q \"dead linkdown\"\n\tlog_test $? 1 \"IPv6 flags on up device\"\n}\n\nfib_down_multipath_test()\n{\n\techo\n\techo \"Admin down multipath\"\n\n\tsetup\n\n\tset -e\n\t$IP link add dummy1 type dummy\n\t$IP link set dev dummy1 up\n\n\t$IP address add 192.0.2.1/24 dev dummy1\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy1\n\n\t$IP route add 203.0.113.0/24 \\\n\t\tnexthop via 198.51.100.2 dev dummy0 \\\n\t\tnexthop via 192.0.2.2 dev dummy1\n\t$IP -6 route add 2001:db8:3::/64 \\\n\t\tnexthop via 2001:db8:1::2 dev dummy0 \\\n\t\tnexthop via 2001:db8:2::2 dev dummy1\n\tset +e\n\n\techo \"    Verify start point\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\tset -e\n\t$IP link set dev dummy0 down\n\tset +e\n\n\techo \"    One device down, one up\"\n\tfib_down_multipath_test_do \"dummy0\" \"dummy1\"\n\n\tset -e\n\t$IP link set dev dummy0 up\n\t$IP link set dev dummy1 down\n\tset +e\n\n\techo \"    Other device down and up\"\n\tfib_down_multipath_test_do \"dummy1\" \"dummy0\"\n\n\tset -e\n\t$IP link set dev dummy0 down\n\tset +e\n\n\techo \"    Both devices down\"\n\t$IP route get fibmatch 203.0.113.1 &> /dev/null\n\tlog_test $? 2 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:3::1 &> /dev/null\n\tlog_test $? 2 \"IPv6 fibmatch\"\n\n\t$IP link del dev dummy1\n\tcleanup\n}\n\nfib_down_test()\n{\n\tfib_down_unicast_test\n\tfib_down_multipath_test\n}\n\n# Local routes should not be affected when carrier changes.\nfib_carrier_local_test()\n{\n\techo\n\techo \"Local carrier tests - single path\"\n\n\tsetup\n\n\tset -e\n\t$IP link set dev dummy0 carrier on\n\tset +e\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 - no linkdown flag\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 - no linkdown flag\"\n\n\tset -e\n\t$IP link set dev dummy0 carrier off\n\tsleep 1\n\tset +e\n\n\techo \"    Carrier off on nexthop\"\n\t$IP route get fibmatch 198.51.100.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 - linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:1::1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 - linkdown flag set\"\n\n\tset -e\n\t$IP address add 192.0.2.1/24 dev dummy0\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy0\n\tset +e\n\n\techo \"    Route to local address with carrier down\"\n\t$IP route get fibmatch 192.0.2.1 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:2::1 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 192.0.2.1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:2::1 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 linkdown flag set\"\n\n\tcleanup\n}\n\nfib_carrier_unicast_test()\n{\n\tret=0\n\n\techo\n\techo \"Single path route carrier test\"\n\n\tsetup\n\n\tset -e\n\t$IP link set dev dummy0 carrier on\n\tset +e\n\n\techo \"    Start point\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv4 no linkdown flag\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 1 \"IPv6 no linkdown flag\"\n\n\tset -e\n\t$IP link set dev dummy0 carrier off\n\tsleep 1\n\tset +e\n\n\techo \"    Carrier down\"\n\t$IP route get fibmatch 198.51.100.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 198.51.100.2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv4 linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:1::2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv6 linkdown flag set\"\n\n\tset -e\n\t$IP address add 192.0.2.1/24 dev dummy0\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy0\n\tset +e\n\n\techo \"    Second address added with carrier down\"\n\t$IP route get fibmatch 192.0.2.2 &> /dev/null\n\tlog_test $? 0 \"IPv4 fibmatch\"\n\t$IP -6 route get fibmatch 2001:db8:2::2 &> /dev/null\n\tlog_test $? 0 \"IPv6 fibmatch\"\n\n\t$IP route get fibmatch 192.0.2.2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv4 linkdown flag set\"\n\t$IP -6 route get fibmatch 2001:db8:2::2 | \\\n\t\tgrep -q \"linkdown\"\n\tlog_test $? 0 \"IPv6 linkdown flag set\"\n\n\tcleanup\n}\n\nfib_carrier_test()\n{\n\tfib_carrier_local_test\n\tfib_carrier_unicast_test\n}\n\nfib_rp_filter_test()\n{\n\techo\n\techo \"IPv4 rp_filter tests\"\n\n\tsetup\n\n\tset -e\n\tip netns add ns2\n\tip netns set ns2 auto\n\n\tip -netns ns2 link set dev lo up\n\n\t$IP link add name veth1 type veth peer name veth2\n\t$IP link set dev veth2 netns ns2\n\t$IP address add 192.0.2.1/24 dev veth1\n\tip -netns ns2 address add 192.0.2.1/24 dev veth2\n\t$IP link set dev veth1 up\n\tip -netns ns2 link set dev veth2 up\n\n\t$IP link set dev lo address 52:54:00:6a:c7:5e\n\t$IP link set dev veth1 address 52:54:00:6a:c7:5e\n\tip -netns ns2 link set dev lo address 52:54:00:6a:c7:5e\n\tip -netns ns2 link set dev veth2 address 52:54:00:6a:c7:5e\n\n\t# 1. (ns2) redirect lo's egress to veth2's egress\n\tip netns exec ns2 tc qdisc add dev lo parent root handle 1: fq_codel\n\tip netns exec ns2 tc filter add dev lo parent 1: protocol arp basic \\\n\t\taction mirred egress redirect dev veth2\n\tip netns exec ns2 tc filter add dev lo parent 1: protocol ip basic \\\n\t\taction mirred egress redirect dev veth2\n\n\t# 2. (ns1) redirect veth1's ingress to lo's ingress\n\t$NS_EXEC tc qdisc add dev veth1 ingress\n\t$NS_EXEC tc filter add dev veth1 ingress protocol arp basic \\\n\t\taction mirred ingress redirect dev lo\n\t$NS_EXEC tc filter add dev veth1 ingress protocol ip basic \\\n\t\taction mirred ingress redirect dev lo\n\n\t# 3. (ns1) redirect lo's egress to veth1's egress\n\t$NS_EXEC tc qdisc add dev lo parent root handle 1: fq_codel\n\t$NS_EXEC tc filter add dev lo parent 1: protocol arp basic \\\n\t\taction mirred egress redirect dev veth1\n\t$NS_EXEC tc filter add dev lo parent 1: protocol ip basic \\\n\t\taction mirred egress redirect dev veth1\n\n\t# 4. (ns2) redirect veth2's ingress to lo's ingress\n\tip netns exec ns2 tc qdisc add dev veth2 ingress\n\tip netns exec ns2 tc filter add dev veth2 ingress protocol arp basic \\\n\t\taction mirred ingress redirect dev lo\n\tip netns exec ns2 tc filter add dev veth2 ingress protocol ip basic \\\n\t\taction mirred ingress redirect dev lo\n\n\t$NS_EXEC sysctl -qw net.ipv4.conf.all.rp_filter=1\n\t$NS_EXEC sysctl -qw net.ipv4.conf.all.accept_local=1\n\t$NS_EXEC sysctl -qw net.ipv4.conf.all.route_localnet=1\n\tip netns exec ns2 sysctl -qw net.ipv4.conf.all.rp_filter=1\n\tip netns exec ns2 sysctl -qw net.ipv4.conf.all.accept_local=1\n\tip netns exec ns2 sysctl -qw net.ipv4.conf.all.route_localnet=1\n\tset +e\n\n\trun_cmd \"ip netns exec ns2 ping -w1 -c1 192.0.2.1\"\n\tlog_test $? 0 \"rp_filter passes local packets\"\n\n\trun_cmd \"ip netns exec ns2 ping -w1 -c1 127.0.0.1\"\n\tlog_test $? 0 \"rp_filter passes loopback packets\"\n\n\tcleanup\n}\n\n################################################################################\n# Tests on nexthop spec\n\n# run 'ip route add' with given spec\nadd_rt()\n{\n\tlocal desc=\"$1\"\n\tlocal erc=$2\n\tlocal vrf=$3\n\tlocal pfx=$4\n\tlocal gw=$5\n\tlocal dev=$6\n\tlocal cmd out rc\n\n\t[ \"$vrf\" = \"-\" ] && vrf=\"default\"\n\t[ -n \"$gw\" ] && gw=\"via $gw\"\n\t[ -n \"$dev\" ] && dev=\"dev $dev\"\n\n\tcmd=\"$IP route add vrf $vrf $pfx $gw $dev\"\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\tprintf \"\\n    COMMAND: $cmd\\n\"\n\tfi\n\n\tout=$(eval $cmd 2>&1)\n\trc=$?\n\tif [ \"$VERBOSE\" = \"1\" -a -n \"$out\" ]; then\n\t\techo \"    $out\"\n\tfi\n\tlog_test $rc $erc \"$desc\"\n}\n\nfib4_nexthop()\n{\n\techo\n\techo \"IPv4 nexthop tests\"\n\n\techo \"<<< write me >>>\"\n}\n\nfib6_nexthop()\n{\n\tlocal lldummy=$(get_linklocal dummy0)\n\tlocal llv1=$(get_linklocal dummy0)\n\n\tif [ -z \"$lldummy\" ]; then\n\t\techo \"Failed to get linklocal address for dummy0\"\n\t\treturn 1\n\tfi\n\tif [ -z \"$llv1\" ]; then\n\t\techo \"Failed to get linklocal address for veth1\"\n\t\treturn 1\n\tfi\n\n\techo\n\techo \"IPv6 nexthop tests\"\n\n\tadd_rt \"Directly connected nexthop, unicast address\" 0 \\\n\t\t- 2001:db8:101::/64 2001:db8:1::2\n\tadd_rt \"Directly connected nexthop, unicast address with device\" 0 \\\n\t\t- 2001:db8:102::/64 2001:db8:1::2 \"dummy0\"\n\tadd_rt \"Gateway is linklocal address\" 0 \\\n\t\t- 2001:db8:103::1/64 $llv1 \"veth0\"\n\n\t# fails because LL address requires a device\n\tadd_rt \"Gateway is linklocal address, no device\" 2 \\\n\t\t- 2001:db8:104::1/64 $llv1\n\n\t# local address can not be a gateway\n\tadd_rt \"Gateway can not be local unicast address\" 2 \\\n\t\t- 2001:db8:105::/64 2001:db8:1::1\n\tadd_rt \"Gateway can not be local unicast address, with device\" 2 \\\n\t\t- 2001:db8:106::/64 2001:db8:1::1 \"dummy0\"\n\tadd_rt \"Gateway can not be a local linklocal address\" 2 \\\n\t\t- 2001:db8:107::1/64 $lldummy \"dummy0\"\n\n\t# VRF tests\n\tadd_rt \"Gateway can be local address in a VRF\" 0 \\\n\t\t- 2001:db8:108::/64 2001:db8:51::2\n\tadd_rt \"Gateway can be local address in a VRF, with device\" 0 \\\n\t\t- 2001:db8:109::/64 2001:db8:51::2 \"veth0\"\n\tadd_rt \"Gateway can be local linklocal address in a VRF\" 0 \\\n\t\t- 2001:db8:110::1/64 $llv1 \"veth0\"\n\n\tadd_rt \"Redirect to VRF lookup\" 0 \\\n\t\t- 2001:db8:111::/64 \"\" \"red\"\n\n\tadd_rt \"VRF route, gateway can be local address in default VRF\" 0 \\\n\t\tred 2001:db8:112::/64 2001:db8:51::1\n\n\t# local address in same VRF fails\n\tadd_rt \"VRF route, gateway can not be a local address\" 2 \\\n\t\tred 2001:db8:113::1/64 2001:db8:2::1\n\tadd_rt \"VRF route, gateway can not be a local addr with device\" 2 \\\n\t\tred 2001:db8:114::1/64 2001:db8:2::1 \"dummy1\"\n}\n\n# Default VRF:\n#   dummy0 - 198.51.100.1/24 2001:db8:1::1/64\n#   veth0  - 192.0.2.1/24    2001:db8:51::1/64\n#\n# VRF red:\n#   dummy1 - 192.168.2.1/24 2001:db8:2::1/64\n#   veth1  - 192.0.2.2/24   2001:db8:51::2/64\n#\n#  [ dummy0   veth0 ]--[ veth1   dummy1 ]\n\nfib_nexthop_test()\n{\n\tsetup\n\n\tset -e\n\n\t$IP -4 rule add pref 32765 table local\n\t$IP -4 rule del pref 0\n\t$IP -6 rule add pref 32765 table local\n\t$IP -6 rule del pref 0\n\n\t$IP link add red type vrf table 1\n\t$IP link set red up\n\t$IP -4 route add vrf red unreachable default metric 4278198272\n\t$IP -6 route add vrf red unreachable default metric 4278198272\n\n\t$IP link add veth0 type veth peer name veth1\n\t$IP link set dev veth0 up\n\t$IP address add 192.0.2.1/24 dev veth0\n\t$IP -6 address add 2001:db8:51::1/64 dev veth0\n\n\t$IP link set dev veth1 vrf red up\n\t$IP address add 192.0.2.2/24 dev veth1\n\t$IP -6 address add 2001:db8:51::2/64 dev veth1\n\n\t$IP link add dummy1 type dummy\n\t$IP link set dev dummy1 vrf red up\n\t$IP address add 192.168.2.1/24 dev dummy1\n\t$IP -6 address add 2001:db8:2::1/64 dev dummy1\n\tset +e\n\n\tsleep 1\n\tfib4_nexthop\n\tfib6_nexthop\n\n\t(\n\t$IP link del dev dummy1\n\t$IP link del veth0\n\t$IP link del red\n\t) 2>/dev/null\n\tcleanup\n}\n\nfib6_notify_test()\n{\n\tsetup\n\n\techo\n\techo \"Fib6 info length calculation in route notify test\"\n\tset -e\n\n\tfor i in 10 20 30 40 50 60 70;\n\tdo\n\t\t$IP link add dummy_$i type dummy\n\t\t$IP link set dev dummy_$i up\n\t\t$IP -6 address add 2001:$i::1/64 dev dummy_$i\n\tdone\n\n\t$NS_EXEC ip monitor route &> errors.txt &\n\tsleep 2\n\n\t$IP -6 route add 2001::/64 \\\n                nexthop via 2001:10::2 dev dummy_10 \\\n                nexthop encap ip6 dst 2002::20 via 2001:20::2 dev dummy_20 \\\n                nexthop encap ip6 dst 2002::30 via 2001:30::2 dev dummy_30 \\\n                nexthop encap ip6 dst 2002::40 via 2001:40::2 dev dummy_40 \\\n                nexthop encap ip6 dst 2002::50 via 2001:50::2 dev dummy_50 \\\n                nexthop encap ip6 dst 2002::60 via 2001:60::2 dev dummy_60 \\\n                nexthop encap ip6 dst 2002::70 via 2001:70::2 dev dummy_70\n\n\tset +e\n\n\terr=`cat errors.txt |grep \"Message too long\"`\n\tif [ -z \"$err\" ];then\n\t\tret=0\n\telse\n\t\tret=1\n\tfi\n\n\tlog_test $ret 0 \"ipv6 route add notify\"\n\n\t{ kill %% && wait %%; } 2>/dev/null\n\n\t#rm errors.txt\n\n\tcleanup &> /dev/null\n}\n\n\nfib_notify_test()\n{\n\tsetup\n\n\techo\n\techo \"Fib4 info length calculation in route notify test\"\n\n\tset -e\n\n\tfor i in 10 20 30 40 50 60 70;\n\tdo\n\t\t$IP link add dummy_$i type dummy\n\t\t$IP link set dev dummy_$i up\n\t\t$IP address add 20.20.$i.2/24 dev dummy_$i\n\tdone\n\n\t$NS_EXEC ip monitor route &> errors.txt &\n\tsleep 2\n\n        $IP route add 10.0.0.0/24 \\\n                nexthop via 20.20.10.1 dev dummy_10 \\\n                nexthop encap ip dst 192.168.10.20 via 20.20.20.1 dev dummy_20 \\\n                nexthop encap ip dst 192.168.10.30 via 20.20.30.1 dev dummy_30 \\\n                nexthop encap ip dst 192.168.10.40 via 20.20.40.1 dev dummy_40 \\\n                nexthop encap ip dst 192.168.10.50 via 20.20.50.1 dev dummy_50 \\\n                nexthop encap ip dst 192.168.10.60 via 20.20.60.1 dev dummy_60 \\\n                nexthop encap ip dst 192.168.10.70 via 20.20.70.1 dev dummy_70\n\n\tset +e\n\n\terr=`cat errors.txt |grep \"Message too long\"`\n\tif [ -z \"$err\" ];then\n\t\tret=0\n\telse\n\t\tret=1\n\tfi\n\n\tlog_test $ret 0 \"ipv4 route add notify\"\n\n\t{ kill %% && wait %%; } 2>/dev/null\n\n\trm  errors.txt\n\n\tcleanup &> /dev/null\n}\n\nfib6_gc_test()\n{\n\tsetup\n\n\techo\n\techo \"Fib6 garbage collection test\"\n\tset -e\n\n\tEXPIRE=3\n\n\t# Check expiration of routes every $EXPIRE seconds (GC)\n\t$NS_EXEC sysctl -wq net.ipv6.route.gc_interval=$EXPIRE\n\n\t$IP link add dummy_10 type dummy\n\t$IP link set dev dummy_10 up\n\t$IP -6 address add 2001:10::1/64 dev dummy_10\n\n\t$NS_EXEC sysctl -wq net.ipv6.route.flush=1\n\n\t# Temporary routes\n\tfor i in $(seq 1 1000); do\n\t    # Expire route after $EXPIRE seconds\n\t    $IP -6 route add 2001:20::$i \\\n\t\tvia 2001:10::2 dev dummy_10 expires $EXPIRE\n\tdone\n\tsleep $(($EXPIRE * 2))\n\tN_EXP_SLEEP=$($IP -6 route list |grep expires|wc -l)\n\tif [ $N_EXP_SLEEP -ne 0 ]; then\n\t    echo \"FAIL: expected 0 routes with expires, got $N_EXP_SLEEP\"\n\t    ret=1\n\telse\n\t    ret=0\n\tfi\n\n\t# Permanent routes\n\tfor i in $(seq 1 5000); do\n\t    $IP -6 route add 2001:30::$i \\\n\t\tvia 2001:10::2 dev dummy_10\n\tdone\n\t# Temporary routes\n\tfor i in $(seq 1 1000); do\n\t    # Expire route after $EXPIRE seconds\n\t    $IP -6 route add 2001:20::$i \\\n\t\tvia 2001:10::2 dev dummy_10 expires $EXPIRE\n\tdone\n\tsleep $(($EXPIRE * 2))\n\tN_EXP_SLEEP=$($IP -6 route list |grep expires|wc -l)\n\tif [ $N_EXP_SLEEP -ne 0 ]; then\n\t    echo \"FAIL: expected 0 routes with expires,\" \\\n\t\t \"got $N_EXP_SLEEP (5000 permanent routes)\"\n\t    ret=1\n\telse\n\t    ret=0\n\tfi\n\n\tset +e\n\n\tlog_test $ret 0 \"ipv6 route garbage collection\"\n\n\tcleanup &> /dev/null\n}\n\nfib_suppress_test()\n{\n\techo\n\techo \"FIB rule with suppress_prefixlength\"\n\tsetup\n\n\t$IP link add dummy1 type dummy\n\t$IP link set dummy1 up\n\t$IP -6 route add default dev dummy1\n\t$IP -6 rule add table main suppress_prefixlength 0\n\tping -f -c 1000 -W 1 1234::1 >/dev/null 2>&1\n\t$IP -6 rule del table main suppress_prefixlength 0\n\t$IP link del dummy1\n\n\t# If we got here without crashing, we're good.\n\tlog_test 0 0 \"FIB rule suppress test\"\n\n\tcleanup\n}\n\n################################################################################\n# Tests on route add and replace\n\nrun_cmd()\n{\n\tlocal cmd=\"$1\"\n\tlocal out\n\tlocal stderr=\"2>/dev/null\"\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\tprintf \"    COMMAND: $cmd\\n\"\n\t\tstderr=\n\tfi\n\n\tout=$(eval $cmd $stderr)\n\trc=$?\n\tif [ \"$VERBOSE\" = \"1\" -a -n \"$out\" ]; then\n\t\techo \"    $out\"\n\tfi\n\n\t[ \"$VERBOSE\" = \"1\" ] && echo\n\n\treturn $rc\n}\n\ncheck_expected()\n{\n\tlocal out=\"$1\"\n\tlocal expected=\"$2\"\n\tlocal rc=0\n\n\t[ \"${out}\" = \"${expected}\" ] && return 0\n\n\tif [ -z \"${out}\" ]; then\n\t\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\t\tprintf \"\\nNo route entry found\\n\"\n\t\t\tprintf \"Expected:\\n\"\n\t\t\tprintf \"    ${expected}\\n\"\n\t\tfi\n\t\treturn 1\n\tfi\n\n\t# tricky way to convert output to 1-line without ip's\n\t# messy '\\'; this drops all extra white space\n\tout=$(echo ${out})\n\tif [ \"${out}\" != \"${expected}\" ]; then\n\t\trc=1\n\t\tif [ \"${VERBOSE}\" = \"1\" ]; then\n\t\t\tprintf \"    Unexpected route entry. Have:\\n\"\n\t\t\tprintf \"        ${out}\\n\"\n\t\t\tprintf \"    Expected:\\n\"\n\t\t\tprintf \"        ${expected}\\n\\n\"\n\t\tfi\n\tfi\n\n\treturn $rc\n}\n\n# add route for a prefix, flushing any existing routes first\n# expected to be the first step of a test\nadd_route6()\n{\n\tlocal pfx=\"$1\"\n\tlocal nh=\"$2\"\n\tlocal out\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo\n\t\techo \"    ##################################################\"\n\t\techo\n\tfi\n\n\trun_cmd \"$IP -6 ro flush ${pfx}\"\n\t[ $? -ne 0 ] && exit 1\n\n\tout=$($IP -6 ro ls match ${pfx})\n\tif [ -n \"$out\" ]; then\n\t\techo \"Failed to flush routes for prefix used for tests.\"\n\t\texit 1\n\tfi\n\n\trun_cmd \"$IP -6 ro add ${pfx} ${nh}\"\n\tif [ $? -ne 0 ]; then\n\t\techo \"Failed to add initial route for test.\"\n\t\texit 1\n\tfi\n}\n\n# add initial route - used in replace route tests\nadd_initial_route6()\n{\n\tadd_route6 \"2001:db8:104::/64\" \"$1\"\n}\n\ncheck_route6()\n{\n\tlocal pfx\n\tlocal expected=\"$1\"\n\tlocal out\n\tlocal rc=0\n\n\tset -- $expected\n\tpfx=$1\n\n\tout=$($IP -6 ro ls match ${pfx} | sed -e 's/ pref medium//')\n\tcheck_expected \"${out}\" \"${expected}\"\n}\n\nroute_cleanup()\n{\n\t$IP li del red 2>/dev/null\n\t$IP li del dummy1 2>/dev/null\n\t$IP li del veth1 2>/dev/null\n\t$IP li del veth3 2>/dev/null\n\n\tcleanup &> /dev/null\n}\n\nroute_setup()\n{\n\troute_cleanup\n\tsetup\n\n\t[ \"${VERBOSE}\" = \"1\" ] && set -x\n\tset -e\n\n\tip netns add ns2\n\tip netns set ns2 auto\n\tip -netns ns2 link set dev lo up\n\tip netns exec ns2 sysctl -qw net.ipv4.ip_forward=1\n\tip netns exec ns2 sysctl -qw net.ipv6.conf.all.forwarding=1\n\n\t$IP li add veth1 type veth peer name veth2\n\t$IP li add veth3 type veth peer name veth4\n\n\t$IP li set veth1 up\n\t$IP li set veth3 up\n\t$IP li set veth2 netns ns2 up\n\t$IP li set veth4 netns ns2 up\n\tip -netns ns2 li add dummy1 type dummy\n\tip -netns ns2 li set dummy1 up\n\n\t$IP -6 addr add 2001:db8:101::1/64 dev veth1 nodad\n\t$IP -6 addr add 2001:db8:103::1/64 dev veth3 nodad\n\t$IP addr add 172.16.101.1/24 dev veth1\n\t$IP addr add 172.16.103.1/24 dev veth3\n\n\tip -netns ns2 -6 addr add 2001:db8:101::2/64 dev veth2 nodad\n\tip -netns ns2 -6 addr add 2001:db8:103::2/64 dev veth4 nodad\n\tip -netns ns2 -6 addr add 2001:db8:104::1/64 dev dummy1 nodad\n\n\tip -netns ns2 addr add 172.16.101.2/24 dev veth2\n\tip -netns ns2 addr add 172.16.103.2/24 dev veth4\n\tip -netns ns2 addr add 172.16.104.1/24 dev dummy1\n\n\tset +e\n}\n\n# assumption is that basic add of a single path route works\n# otherwise just adding an address on an interface is broken\nipv6_rt_add()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 route add / append tests\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 via 2001:db8:103::2\"\n\tlog_test $? 2 \"Attempt to add duplicate route - gw\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 dev veth3\"\n\tlog_test $? 2 \"Attempt to add duplicate route - dev only\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add unreachable 2001:db8:104::/64\"\n\tlog_test $? 2 \"Attempt to add duplicate route - reject route\"\n\n\t# route append with same prefix adds a new route\n\t# - iproute2 sets NLM_F_CREATE | NLM_F_APPEND\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro append 2001:db8:104::/64 via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Append nexthop to existing route - gw\"\n\n\t# insert mpath directly\n\tadd_route6 \"2001:db8:104::/64\" \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Add multipath route\"\n\n\tadd_route6 \"2001:db8:104::/64\" \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\tlog_test $? 2 \"Attempt to add duplicate multipath route\"\n\n\t# insert of a second route without append but different metric\n\tadd_route6 \"2001:db8:104::/64\" \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 via 2001:db8:103::2 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\trun_cmd \"$IP -6 ro add 2001:db8:104::/64 via 2001:db8:103::3 metric 256\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route add with different metrics\"\n\n\trun_cmd \"$IP -6 ro del 2001:db8:104::/64 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:103::3 dev veth3 metric 256 2001:db8:104::/64 via 2001:db8:101::2 dev veth1 metric 1024\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route delete with metric\"\n}\n\nipv6_rt_replace_single()\n{\n\t# single path with single path\n\t#\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:103::2 dev veth3 metric 1024\"\n\tlog_test $? 0 \"Single path with single path\"\n\n\t# single path with multipath\n\t#\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::3 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Single path with multipath\"\n\n\t# single path with single path using MULTIPATH attribute\n\t#\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:103::2\"\n\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:103::2 dev veth3 metric 1024\"\n\tlog_test $? 0 \"Single path with single path via multipath attribute\"\n\n\t# route replace fails - invalid nexthop\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 via 2001:db8:104::2\"\n\tif [ $? -eq 0 ]; then\n\t\t# previous command is expected to fail so if it returns 0\n\t\t# that means the test failed.\n\t\tlog_test 0 1 \"Invalid nexthop\"\n\telse\n\t\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:101::2 dev veth1 metric 1024\"\n\t\tlog_test $? 0 \"Invalid nexthop\"\n\tfi\n\n\t# replace non-existent route\n\t# - note use of change versus replace since ip adds NLM_F_CREATE\n\t#   for replace\n\tadd_initial_route6 \"via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro change 2001:db8:105::/64 via 2001:db8:101::2\"\n\tlog_test $? 2 \"Single path - replace of non-existent route\"\n}\n\nipv6_rt_replace_mpath()\n{\n\t# multipath with multipath\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:103::3\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::3 dev veth1 weight 1 nexthop via 2001:db8:103::3 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath with multipath\"\n\n\t# multipath with single\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 via 2001:db8:101::3\"\n\tcheck_route6  \"2001:db8:104::/64 via 2001:db8:101::3 dev veth1 metric 1024\"\n\tlog_test $? 0 \"Multipath with single path\"\n\n\t# multipath with single\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3\"\n\tcheck_route6 \"2001:db8:104::/64 via 2001:db8:101::3 dev veth1 metric 1024\"\n\tlog_test $? 0 \"Multipath with single path via multipath attribute\"\n\n\t# multipath with dev-only\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 dev veth1\"\n\tcheck_route6 \"2001:db8:104::/64 dev veth1 metric 1024\"\n\tlog_test $? 0 \"Multipath with dev-only\"\n\n\t# route replace fails - invalid nexthop 1\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:111::3 nexthop via 2001:db8:103::3\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid first nexthop\"\n\n\t# route replace fails - invalid nexthop 2\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro replace 2001:db8:104::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:113::3\"\n\tcheck_route6  \"2001:db8:104::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid second nexthop\"\n\n\t# multipath non-existent route\n\tadd_initial_route6 \"nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trun_cmd \"$IP -6 ro change 2001:db8:105::/64 nexthop via 2001:db8:101::3 nexthop via 2001:db8:103::3\"\n\tlog_test $? 2 \"Multipath - replace of non-existent route\"\n}\n\nipv6_rt_replace()\n{\n\techo\n\techo \"IPv6 route replace tests\"\n\n\tipv6_rt_replace_single\n\tipv6_rt_replace_mpath\n}\n\nipv6_rt_dsfield()\n{\n\techo\n\techo \"IPv6 route with dsfield tests\"\n\n\trun_cmd \"$IP -6 route flush 2001:db8:102::/64\"\n\n\t# IPv6 doesn't support routing based on dsfield\n\trun_cmd \"$IP -6 route add 2001:db8:102::/64 dsfield 0x04 via 2001:db8:101::2\"\n\tlog_test $? 2 \"Reject route with dsfield\"\n}\n\nipv6_route_test()\n{\n\troute_setup\n\n\tipv6_rt_add\n\tipv6_rt_replace\n\tipv6_rt_dsfield\n\n\troute_cleanup\n}\n\nip_addr_metric_check()\n{\n\tip addr help 2>&1 | grep -q metric\n\tif [ $? -ne 0 ]; then\n\t\techo \"iproute2 command does not support metric for addresses. Skipping test\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\nipv6_addr_metric_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 prefix route tests\"\n\n\tip_addr_metric_check || return 1\n\n\tsetup\n\n\tset -e\n\t$IP li add dummy1 type dummy\n\t$IP li add dummy2 type dummy\n\t$IP li set dummy1 up\n\t$IP li set dummy2 up\n\n\t# default entry is metric 256\n\trun_cmd \"$IP -6 addr add dev dummy1 2001:db8:104::1/64\"\n\trun_cmd \"$IP -6 addr add dev dummy2 2001:db8:104::2/64\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::/64 dev dummy1 proto kernel metric 256 2001:db8:104::/64 dev dummy2 proto kernel metric 256\"\n\tlog_test $? 0 \"Default metric\"\n\n\tset -e\n\trun_cmd \"$IP -6 addr flush dev dummy1\"\n\trun_cmd \"$IP -6 addr add dev dummy1 2001:db8:104::1/64 metric 257\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 256 2001:db8:104::/64 dev dummy1 proto kernel metric 257\"\n\tlog_test $? 0 \"User specified metric on first device\"\n\n\tset -e\n\trun_cmd \"$IP -6 addr flush dev dummy2\"\n\trun_cmd \"$IP -6 addr add dev dummy2 2001:db8:104::2/64 metric 258\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::/64 dev dummy1 proto kernel metric 257 2001:db8:104::/64 dev dummy2 proto kernel metric 258\"\n\tlog_test $? 0 \"User specified metric on second device\"\n\n\trun_cmd \"$IP -6 addr del dev dummy1 2001:db8:104::1/64 metric 257\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 258\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Delete of address on first device\"\n\n\trun_cmd \"$IP -6 addr change dev dummy2 2001:db8:104::2/64 metric 259\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Modify metric of address\"\n\n\t# verify prefix route removed on down\n\trun_cmd \"ip netns exec ns1 sysctl -qw net.ipv6.conf.all.keep_addr_on_down=1\"\n\trun_cmd \"$IP li set dev dummy2 down\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tout=$($IP -6 ro ls match 2001:db8:104::/64)\n\t\tcheck_expected \"${out}\" \"\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route removed on link down\"\n\n\t# verify prefix route re-inserted with assigned metric\n\trun_cmd \"$IP li set dev dummy2 up\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:104::/64 dev dummy2 proto kernel metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route with metric on link up\"\n\n\t# verify peer metric added correctly\n\tset -e\n\trun_cmd \"$IP -6 addr flush dev dummy2\"\n\trun_cmd \"$IP -6 addr add dev dummy2 2001:db8:104::1 peer 2001:db8:104::2 metric 260\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::1 dev dummy2 proto kernel metric 260\"\n\tlog_test $? 0 \"Set metric with peer route on local side\"\n\tcheck_route6 \"2001:db8:104::2 dev dummy2 proto kernel metric 260\"\n\tlog_test $? 0 \"Set metric with peer route on peer side\"\n\n\tset -e\n\trun_cmd \"$IP -6 addr change dev dummy2 2001:db8:104::1 peer 2001:db8:104::3 metric 261\"\n\tset +e\n\n\tcheck_route6 \"2001:db8:104::1 dev dummy2 proto kernel metric 261\"\n\tlog_test $? 0 \"Modify metric and peer address on local side\"\n\tcheck_route6 \"2001:db8:104::3 dev dummy2 proto kernel metric 261\"\n\tlog_test $? 0 \"Modify metric and peer address on peer side\"\n\n\t$IP li del dummy1\n\t$IP li del dummy2\n\tcleanup\n}\n\nipv6_route_metrics_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 routes with metrics\"\n\n\troute_setup\n\n\t#\n\t# single path with metrics\n\t#\n\trun_cmd \"$IP -6 ro add 2001:db8:111::/64 via 2001:db8:101::2 mtu 1400\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6  \"2001:db8:111::/64 via 2001:db8:101::2 dev veth1 metric 1024 mtu 1400\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Single path route with mtu metric\"\n\n\n\t#\n\t# multipath via separate routes with metrics\n\t#\n\trun_cmd \"$IP -6 ro add 2001:db8:112::/64 via 2001:db8:101::2 mtu 1400\"\n\trun_cmd \"$IP -6 ro append 2001:db8:112::/64 via 2001:db8:103::2\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:112::/64 metric 1024 mtu 1400 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route via 2 single routes with mtu metric on first\"\n\n\t# second route is coalesced to first to make a multipath route.\n\t# MTU of the second path is hidden from display!\n\trun_cmd \"$IP -6 ro add 2001:db8:113::/64 via 2001:db8:101::2\"\n\trun_cmd \"$IP -6 ro append 2001:db8:113::/64 via 2001:db8:103::2 mtu 1400\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:113::/64 metric 1024 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route via 2 single routes with mtu metric on 2nd\"\n\n\trun_cmd \"$IP -6 ro del 2001:db8:113::/64 via 2001:db8:101::2\"\n\tif [ $? -eq 0 ]; then\n\t\tcheck_route6 \"2001:db8:113::/64 via 2001:db8:103::2 dev veth3 metric 1024 mtu 1400\"\n\t\tlog_test $? 0 \"    MTU of second leg\"\n\tfi\n\n\t#\n\t# multipath with metrics\n\t#\n\trun_cmd \"$IP -6 ro add 2001:db8:115::/64 mtu 1400 nexthop via 2001:db8:101::2 nexthop via 2001:db8:103::2\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route6  \"2001:db8:115::/64 metric 1024 mtu 1400 nexthop via 2001:db8:101::2 dev veth1 weight 1 nexthop via 2001:db8:103::2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route with mtu metric\"\n\n\t$IP -6 ro add 2001:db8:104::/64 via 2001:db8:101::2 mtu 1300\n\trun_cmd \"ip netns exec ns1 ${ping6} -w1 -c1 -s 1500 2001:db8:104::1\"\n\tlog_test $? 0 \"Using route with mtu metric\"\n\n\trun_cmd \"$IP -6 ro add 2001:db8:114::/64 via  2001:db8:101::2  congctl lock foo\"\n\tlog_test $? 2 \"Invalid metric (fails metric_convert)\"\n\n\troute_cleanup\n}\n\n# add route for a prefix, flushing any existing routes first\n# expected to be the first step of a test\nadd_route()\n{\n\tlocal pfx=\"$1\"\n\tlocal nh=\"$2\"\n\tlocal out\n\n\tif [ \"$VERBOSE\" = \"1\" ]; then\n\t\techo\n\t\techo \"    ##################################################\"\n\t\techo\n\tfi\n\n\trun_cmd \"$IP ro flush ${pfx}\"\n\t[ $? -ne 0 ] && exit 1\n\n\tout=$($IP ro ls match ${pfx})\n\tif [ -n \"$out\" ]; then\n\t\techo \"Failed to flush routes for prefix used for tests.\"\n\t\texit 1\n\tfi\n\n\trun_cmd \"$IP ro add ${pfx} ${nh}\"\n\tif [ $? -ne 0 ]; then\n\t\techo \"Failed to add initial route for test.\"\n\t\texit 1\n\tfi\n}\n\n# add initial route - used in replace route tests\nadd_initial_route()\n{\n\tadd_route \"172.16.104.0/24\" \"$1\"\n}\n\ncheck_route()\n{\n\tlocal pfx\n\tlocal expected=\"$1\"\n\tlocal out\n\n\tset -- $expected\n\tpfx=$1\n\t[ \"${pfx}\" = \"unreachable\" ] && pfx=$2\n\n\tout=$($IP ro ls match ${pfx})\n\tcheck_expected \"${out}\" \"${expected}\"\n}\n\n# assumption is that basic add of a single path route works\n# otherwise just adding an address on an interface is broken\nipv4_rt_add()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 route add / append tests\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 via 172.16.103.2\"\n\tlog_test $? 2 \"Attempt to add duplicate route - gw\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 dev veth3\"\n\tlog_test $? 2 \"Attempt to add duplicate route - dev only\"\n\n\t# route add same prefix - fails with EEXISTS b/c ip adds NLM_F_EXCL\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add unreachable 172.16.104.0/24\"\n\tlog_test $? 2 \"Attempt to add duplicate route - reject route\"\n\n\t# iproute2 prepend only sets NLM_F_CREATE\n\t# - adds a new route; does NOT convert existing route to ECMP\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro prepend 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.103.2 dev veth3 172.16.104.0/24 via 172.16.101.2 dev veth1\"\n\tlog_test $? 0 \"Add new nexthop for existing prefix\"\n\n\t# route append with same prefix adds a new route\n\t# - iproute2 sets NLM_F_CREATE | NLM_F_APPEND\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Append nexthop to existing route - gw\"\n\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 dev veth3\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 172.16.104.0/24 dev veth3 scope link\"\n\tlog_test $? 0 \"Append nexthop to existing route - dev only\"\n\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro append unreachable 172.16.104.0/24\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 unreachable 172.16.104.0/24\"\n\tlog_test $? 0 \"Append nexthop to existing route - reject route\"\n\n\trun_cmd \"$IP ro flush 172.16.104.0/24\"\n\trun_cmd \"$IP ro add unreachable 172.16.104.0/24\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"unreachable 172.16.104.0/24 172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Append nexthop to existing reject route - gw\"\n\n\trun_cmd \"$IP ro flush 172.16.104.0/24\"\n\trun_cmd \"$IP ro add unreachable 172.16.104.0/24\"\n\trun_cmd \"$IP ro append 172.16.104.0/24 dev veth3\"\n\tcheck_route \"unreachable 172.16.104.0/24 172.16.104.0/24 dev veth3 scope link\"\n\tlog_test $? 0 \"Append nexthop to existing reject route - dev only\"\n\n\t# insert mpath directly\n\tadd_route \"172.16.104.0/24\" \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"add multipath route\"\n\n\tadd_route \"172.16.104.0/24\" \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\tlog_test $? 2 \"Attempt to add duplicate multipath route\"\n\n\t# insert of a second route without append but different metric\n\tadd_route \"172.16.104.0/24\" \"via 172.16.101.2\"\n\trun_cmd \"$IP ro add 172.16.104.0/24 via 172.16.103.2 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\trun_cmd \"$IP ro add 172.16.104.0/24 via 172.16.103.3 metric 256\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route add with different metrics\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 metric 512\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1 172.16.104.0/24 via 172.16.103.3 dev veth3 metric 256\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Route delete with metric\"\n}\n\nipv4_rt_replace_single()\n{\n\t# single path with single path\n\t#\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Single path with single path\"\n\n\t# single path with multipath\n\t#\n\tadd_initial_route \"nexthop via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3 nexthop via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 nexthop via 172.16.101.3 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Single path with multipath\"\n\n\t# single path with reject\n\t#\n\tadd_initial_route \"nexthop via 172.16.101.2\"\n\trun_cmd \"$IP ro replace unreachable 172.16.104.0/24\"\n\tcheck_route \"unreachable 172.16.104.0/24\"\n\tlog_test $? 0 \"Single path with reject route\"\n\n\t# single path with single path using MULTIPATH attribute\n\t#\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.103.2\"\n\tcheck_route \"172.16.104.0/24 via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"Single path with single path via multipath attribute\"\n\n\t# route replace fails - invalid nexthop\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 via 2001:db8:104::2\"\n\tif [ $? -eq 0 ]; then\n\t\t# previous command is expected to fail so if it returns 0\n\t\t# that means the test failed.\n\t\tlog_test 0 1 \"Invalid nexthop\"\n\telse\n\t\tcheck_route \"172.16.104.0/24 via 172.16.101.2 dev veth1\"\n\t\tlog_test $? 0 \"Invalid nexthop\"\n\tfi\n\n\t# replace non-existent route\n\t# - note use of change versus replace since ip adds NLM_F_CREATE\n\t#   for replace\n\tadd_initial_route \"via 172.16.101.2\"\n\trun_cmd \"$IP ro change 172.16.105.0/24 via 172.16.101.2\"\n\tlog_test $? 2 \"Single path - replace of non-existent route\"\n}\n\nipv4_rt_replace_mpath()\n{\n\t# multipath with multipath\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3 nexthop via 172.16.103.3\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.3 dev veth1 weight 1 nexthop via 172.16.103.3 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath with multipath\"\n\n\t# multipath with single\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 via 172.16.101.3\"\n\tcheck_route  \"172.16.104.0/24 via 172.16.101.3 dev veth1\"\n\tlog_test $? 0 \"Multipath with single path\"\n\n\t# multipath with single\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3\"\n\tcheck_route \"172.16.104.0/24 via 172.16.101.3 dev veth1\"\n\tlog_test $? 0 \"Multipath with single path via multipath attribute\"\n\n\t# multipath with reject\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace unreachable 172.16.104.0/24\"\n\tcheck_route \"unreachable 172.16.104.0/24\"\n\tlog_test $? 0 \"Multipath with reject route\"\n\n\t# route replace fails - invalid nexthop 1\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.111.3 nexthop via 172.16.103.3\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid first nexthop\"\n\n\t# route replace fails - invalid nexthop 2\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro replace 172.16.104.0/24 nexthop via 172.16.101.3 nexthop via 172.16.113.3\"\n\tcheck_route  \"172.16.104.0/24 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tlog_test $? 0 \"Multipath - invalid second nexthop\"\n\n\t# multipath non-existent route\n\tadd_initial_route \"nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trun_cmd \"$IP ro change 172.16.105.0/24 nexthop via 172.16.101.3 nexthop via 172.16.103.3\"\n\tlog_test $? 2 \"Multipath - replace of non-existent route\"\n}\n\nipv4_rt_replace()\n{\n\techo\n\techo \"IPv4 route replace tests\"\n\n\tipv4_rt_replace_single\n\tipv4_rt_replace_mpath\n}\n\n# checks that cached input route on VRF port is deleted\n# when VRF is deleted\nipv4_local_rt_cache()\n{\n\trun_cmd \"ip addr add 10.0.0.1/32 dev lo\"\n\trun_cmd \"ip netns add test-ns\"\n\trun_cmd \"ip link add veth-outside type veth peer name veth-inside\"\n\trun_cmd \"ip link add vrf-100 type vrf table 1100\"\n\trun_cmd \"ip link set veth-outside master vrf-100\"\n\trun_cmd \"ip link set veth-inside netns test-ns\"\n\trun_cmd \"ip link set veth-outside up\"\n\trun_cmd \"ip link set vrf-100 up\"\n\trun_cmd \"ip route add 10.1.1.1/32 dev veth-outside table 1100\"\n\trun_cmd \"ip netns exec test-ns ip link set veth-inside up\"\n\trun_cmd \"ip netns exec test-ns ip addr add 10.1.1.1/32 dev veth-inside\"\n\trun_cmd \"ip netns exec test-ns ip route add 10.0.0.1/32 dev veth-inside\"\n\trun_cmd \"ip netns exec test-ns ip route add default via 10.0.0.1\"\n\trun_cmd \"ip netns exec test-ns ping 10.0.0.1 -c 1 -i 1\"\n\trun_cmd \"ip link delete vrf-100\"\n\n\t# if we do not hang test is a success\n\tlog_test $? 0 \"Cached route removed from VRF port device\"\n}\n\nipv4_rt_dsfield()\n{\n\techo\n\techo \"IPv4 route with dsfield tests\"\n\n\trun_cmd \"$IP route flush 172.16.102.0/24\"\n\n\t# New routes should reject dsfield options that interfere with ECN\n\trun_cmd \"$IP route add 172.16.102.0/24 dsfield 0x01 via 172.16.101.2\"\n\tlog_test $? 2 \"Reject route with dsfield 0x01\"\n\n\trun_cmd \"$IP route add 172.16.102.0/24 dsfield 0x02 via 172.16.101.2\"\n\tlog_test $? 2 \"Reject route with dsfield 0x02\"\n\n\trun_cmd \"$IP route add 172.16.102.0/24 dsfield 0x03 via 172.16.101.2\"\n\tlog_test $? 2 \"Reject route with dsfield 0x03\"\n\n\t# A generic route that doesn't take DSCP into account\n\trun_cmd \"$IP route add 172.16.102.0/24 via 172.16.101.2\"\n\n\t# A more specific route for DSCP 0x10\n\trun_cmd \"$IP route add 172.16.102.0/24 dsfield 0x10 via 172.16.103.2\"\n\n\t# DSCP 0x10 should match the specific route, no matter the ECN bits\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x10 | \\\n\t\tgrep -q \"via 172.16.103.2\"\n\tlog_test $? 0 \"IPv4 route with DSCP and ECN:Not-ECT\"\n\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x11 | \\\n\t\tgrep -q \"via 172.16.103.2\"\n\tlog_test $? 0 \"IPv4 route with DSCP and ECN:ECT(1)\"\n\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x12 | \\\n\t\tgrep -q \"via 172.16.103.2\"\n\tlog_test $? 0 \"IPv4 route with DSCP and ECN:ECT(0)\"\n\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x13 | \\\n\t\tgrep -q \"via 172.16.103.2\"\n\tlog_test $? 0 \"IPv4 route with DSCP and ECN:CE\"\n\n\t# Unknown DSCP should match the generic route, no matter the ECN bits\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x14 | \\\n\t\tgrep -q \"via 172.16.101.2\"\n\tlog_test $? 0 \"IPv4 route with unknown DSCP and ECN:Not-ECT\"\n\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x15 | \\\n\t\tgrep -q \"via 172.16.101.2\"\n\tlog_test $? 0 \"IPv4 route with unknown DSCP and ECN:ECT(1)\"\n\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x16 | \\\n\t\tgrep -q \"via 172.16.101.2\"\n\tlog_test $? 0 \"IPv4 route with unknown DSCP and ECN:ECT(0)\"\n\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x17 | \\\n\t\tgrep -q \"via 172.16.101.2\"\n\tlog_test $? 0 \"IPv4 route with unknown DSCP and ECN:CE\"\n\n\t# Null DSCP should match the generic route, no matter the ECN bits\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x00 | \\\n\t\tgrep -q \"via 172.16.101.2\"\n\tlog_test $? 0 \"IPv4 route with no DSCP and ECN:Not-ECT\"\n\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x01 | \\\n\t\tgrep -q \"via 172.16.101.2\"\n\tlog_test $? 0 \"IPv4 route with no DSCP and ECN:ECT(1)\"\n\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x02 | \\\n\t\tgrep -q \"via 172.16.101.2\"\n\tlog_test $? 0 \"IPv4 route with no DSCP and ECN:ECT(0)\"\n\n\t$IP route get fibmatch 172.16.102.1 dsfield 0x03 | \\\n\t\tgrep -q \"via 172.16.101.2\"\n\tlog_test $? 0 \"IPv4 route with no DSCP and ECN:CE\"\n}\n\nipv4_route_test()\n{\n\troute_setup\n\n\tipv4_rt_add\n\tipv4_rt_replace\n\tipv4_local_rt_cache\n\tipv4_rt_dsfield\n\n\troute_cleanup\n}\n\nipv4_addr_metric_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 prefix route tests\"\n\n\tip_addr_metric_check || return 1\n\n\tsetup\n\n\tset -e\n\t$IP li add dummy1 type dummy\n\t$IP li add dummy2 type dummy\n\t$IP li set dummy1 up\n\t$IP li set dummy2 up\n\n\t# default entry is metric 256\n\trun_cmd \"$IP addr add dev dummy1 172.16.104.1/24\"\n\trun_cmd \"$IP addr add dev dummy2 172.16.104.2/24\"\n\tset +e\n\n\tcheck_route \"172.16.104.0/24 dev dummy1 proto kernel scope link src 172.16.104.1 172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2\"\n\tlog_test $? 0 \"Default metric\"\n\n\tset -e\n\trun_cmd \"$IP addr flush dev dummy1\"\n\trun_cmd \"$IP addr add dev dummy1 172.16.104.1/24 metric 257\"\n\tset +e\n\n\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 172.16.104.0/24 dev dummy1 proto kernel scope link src 172.16.104.1 metric 257\"\n\tlog_test $? 0 \"User specified metric on first device\"\n\n\tset -e\n\trun_cmd \"$IP addr flush dev dummy2\"\n\trun_cmd \"$IP addr add dev dummy2 172.16.104.2/24 metric 258\"\n\tset +e\n\n\tcheck_route \"172.16.104.0/24 dev dummy1 proto kernel scope link src 172.16.104.1 metric 257 172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 258\"\n\tlog_test $? 0 \"User specified metric on second device\"\n\n\trun_cmd \"$IP addr del dev dummy1 172.16.104.1/24 metric 257\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 258\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Delete of address on first device\"\n\n\trun_cmd \"$IP addr change dev dummy2 172.16.104.2/24 metric 259\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Modify metric of address\"\n\n\t# verify prefix route removed on down\n\trun_cmd \"$IP li set dev dummy2 down\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tout=$($IP ro ls match 172.16.104.0/24)\n\t\tcheck_expected \"${out}\" \"\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route removed on link down\"\n\n\t# verify prefix route re-inserted with assigned metric\n\trun_cmd \"$IP li set dev dummy2 up\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.2 metric 259\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Prefix route with metric on link up\"\n\n\t# explicitly check for metric changes on edge scenarios\n\trun_cmd \"$IP addr flush dev dummy2\"\n\trun_cmd \"$IP addr add dev dummy2 172.16.104.0/24 metric 259\"\n\trun_cmd \"$IP addr change dev dummy2 172.16.104.0/24 metric 260\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 dev dummy2 proto kernel scope link src 172.16.104.0 metric 260\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Modify metric of .0/24 address\"\n\n\trun_cmd \"$IP addr flush dev dummy2\"\n\trun_cmd \"$IP addr add dev dummy2 172.16.104.1/32 peer 172.16.104.2 metric 260\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.2 dev dummy2 proto kernel scope link src 172.16.104.1 metric 260\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Set metric of address with peer route\"\n\n\trun_cmd \"$IP addr change dev dummy2 172.16.104.1/32 peer 172.16.104.3 metric 261\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.3 dev dummy2 proto kernel scope link src 172.16.104.1 metric 261\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Modify metric and peer address for peer route\"\n\n\t$IP li del dummy1\n\t$IP li del dummy2\n\tcleanup\n}\n\nipv4_route_metrics_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 route add / append tests\"\n\n\troute_setup\n\n\trun_cmd \"$IP ro add 172.16.111.0/24 via 172.16.101.2 mtu 1400\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.111.0/24 via 172.16.101.2 dev veth1 mtu 1400\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Single path route with mtu metric\"\n\n\n\trun_cmd \"$IP ro add 172.16.112.0/24 mtu 1400 nexthop via 172.16.101.2 nexthop via 172.16.103.2\"\n\trc=$?\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.112.0/24 mtu 1400 nexthop via 172.16.101.2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\t\trc=$?\n\tfi\n\tlog_test $rc 0 \"Multipath route with mtu metric\"\n\n\t$IP ro add 172.16.104.0/24 via 172.16.101.2 mtu 1300\n\trun_cmd \"ip netns exec ns1 ping -w1 -c1 -s 1500 172.16.104.1\"\n\tlog_test $? 0 \"Using route with mtu metric\"\n\n\trun_cmd \"$IP ro add 172.16.111.0/24 via 172.16.101.2 congctl lock foo\"\n\tlog_test $? 2 \"Invalid metric (fails metric_convert)\"\n\n\troute_cleanup\n}\n\nipv4_del_addr_test()\n{\n\techo\n\techo \"IPv4 delete address route tests\"\n\n\tsetup\n\n\tset -e\n\t$IP li add dummy1 type dummy\n\t$IP li set dummy1 up\n\t$IP li add dummy2 type dummy\n\t$IP li set dummy2 up\n\t$IP li add red type vrf table 1111\n\t$IP li set red up\n\t$IP ro add vrf red unreachable default\n\t$IP li set dummy2 vrf red\n\n\t$IP addr add dev dummy1 172.16.104.1/24\n\t$IP addr add dev dummy1 172.16.104.11/24\n\t$IP addr add dev dummy1 172.16.104.12/24\n\t$IP addr add dev dummy1 172.16.104.13/24\n\t$IP addr add dev dummy2 172.16.104.1/24\n\t$IP addr add dev dummy2 172.16.104.11/24\n\t$IP addr add dev dummy2 172.16.104.12/24\n\t$IP route add 172.16.105.0/24 via 172.16.104.2 src 172.16.104.11\n\t$IP route add 172.16.106.0/24 dev lo src 172.16.104.12\n\t$IP route add table 0 172.16.107.0/24 via 172.16.104.2 src 172.16.104.13\n\t$IP route add vrf red 172.16.105.0/24 via 172.16.104.2 src 172.16.104.11\n\t$IP route add vrf red 172.16.106.0/24 dev lo src 172.16.104.12\n\tset +e\n\n\t# removing address from device in vrf should only remove route from vrf table\n\techo \"    Regular FIB info\"\n\n\t$IP addr del dev dummy2 172.16.104.11/24\n\t$IP ro ls vrf red | grep -q 172.16.105.0/24\n\tlog_test $? 1 \"Route removed from VRF when source address deleted\"\n\n\t$IP ro ls | grep -q 172.16.105.0/24\n\tlog_test $? 0 \"Route in default VRF not removed\"\n\n\t$IP addr add dev dummy2 172.16.104.11/24\n\t$IP route add vrf red 172.16.105.0/24 via 172.16.104.2 src 172.16.104.11\n\n\t$IP addr del dev dummy1 172.16.104.11/24\n\t$IP ro ls | grep -q 172.16.105.0/24\n\tlog_test $? 1 \"Route removed in default VRF when source address deleted\"\n\n\t$IP ro ls vrf red | grep -q 172.16.105.0/24\n\tlog_test $? 0 \"Route in VRF is not removed by address delete\"\n\n\t# removing address from device in vrf should only remove route from vrf\n\t# table even when the associated fib info only differs in table ID\n\techo \"    Identical FIB info with different table ID\"\n\n\t$IP addr del dev dummy2 172.16.104.12/24\n\t$IP ro ls vrf red | grep -q 172.16.106.0/24\n\tlog_test $? 1 \"Route removed from VRF when source address deleted\"\n\n\t$IP ro ls | grep -q 172.16.106.0/24\n\tlog_test $? 0 \"Route in default VRF not removed\"\n\n\t$IP addr add dev dummy2 172.16.104.12/24\n\t$IP route add vrf red 172.16.106.0/24 dev lo src 172.16.104.12\n\n\t$IP addr del dev dummy1 172.16.104.12/24\n\t$IP ro ls | grep -q 172.16.106.0/24\n\tlog_test $? 1 \"Route removed in default VRF when source address deleted\"\n\n\t$IP ro ls vrf red | grep -q 172.16.106.0/24\n\tlog_test $? 0 \"Route in VRF is not removed by address delete\"\n\n\t# removing address from device in default vrf should remove route from\n\t# the default vrf even when route was inserted with a table ID of 0.\n\techo \"    Table ID 0\"\n\n\t$IP addr del dev dummy1 172.16.104.13/24\n\t$IP ro ls | grep -q 172.16.107.0/24\n\tlog_test $? 1 \"Route removed in default VRF when source address deleted\"\n\n\t$IP li del dummy1\n\t$IP li del dummy2\n\tcleanup\n}\n\nipv6_del_addr_test()\n{\n\techo\n\techo \"IPv6 delete address route tests\"\n\n\tsetup\n\n\tset -e\n\tfor i in $(seq 6); do\n\t\t$IP li add dummy${i} up type dummy\n\tdone\n\n\t$IP li add red up type vrf table 1111\n\t$IP ro add vrf red unreachable default\n\tfor i in $(seq 4 6); do\n\t\t$IP li set dummy${i} vrf red\n\tdone\n\n\t$IP addr add dev dummy1 fe80::1/128\n\t$IP addr add dev dummy1 2001:db8:101::1/64\n\t$IP addr add dev dummy1 2001:db8:101::10/64\n\t$IP addr add dev dummy1 2001:db8:101::11/64\n\t$IP addr add dev dummy1 2001:db8:101::12/64\n\t$IP addr add dev dummy1 2001:db8:101::13/64\n\t$IP addr add dev dummy1 2001:db8:101::14/64\n\t$IP addr add dev dummy1 2001:db8:101::15/64\n\t$IP addr add dev dummy2 fe80::1/128\n\t$IP addr add dev dummy2 2001:db8:101::1/64\n\t$IP addr add dev dummy2 2001:db8:101::11/64\n\t$IP addr add dev dummy3 fe80::1/128\n\n\t$IP addr add dev dummy4 2001:db8:101::1/64\n\t$IP addr add dev dummy4 2001:db8:101::10/64\n\t$IP addr add dev dummy4 2001:db8:101::11/64\n\t$IP addr add dev dummy4 2001:db8:101::12/64\n\t$IP addr add dev dummy4 2001:db8:101::13/64\n\t$IP addr add dev dummy4 2001:db8:101::14/64\n\t$IP addr add dev dummy5 2001:db8:101::1/64\n\t$IP addr add dev dummy5 2001:db8:101::11/64\n\n\t# Single device using src address\n\t$IP route add 2001:db8:110::/64 dev dummy3 src 2001:db8:101::10\n\t# Two devices with the same source address\n\t$IP route add 2001:db8:111::/64 dev dummy3 src 2001:db8:101::11\n\t# VRF with single device using src address\n\t$IP route add vrf red 2001:db8:110::/64 dev dummy6 src 2001:db8:101::10\n\t# VRF with two devices using src address\n\t$IP route add vrf red 2001:db8:111::/64 dev dummy6 src 2001:db8:101::11\n\t# src address and nexthop dev in same VRF\n\t$IP route add 2001:db8:112::/64 dev dummy3 src 2001:db8:101::12\n\t$IP route add vrf red 2001:db8:112::/64 dev dummy6 src 2001:db8:101::12\n\t# src address and nexthop device in different VRF\n\t$IP route add 2001:db8:113::/64 dev lo src 2001:db8:101::13\n\t$IP route add vrf red 2001:db8:113::/64 dev lo src 2001:db8:101::13\n\t# table ID 0\n\t$IP route add table 0 2001:db8:115::/64 via 2001:db8:101::2 src 2001:db8:101::15\n\t# Link local source route\n\t$IP route add 2001:db8:116::/64 dev dummy2 src fe80::1\n\t$IP route add 2001:db8:117::/64 dev dummy3 src fe80::1\n\tset +e\n\n\techo \"    Single device using src address\"\n\n\t$IP addr del dev dummy1 2001:db8:101::10/64\n\t$IP -6 route show | grep -q \"src 2001:db8:101::10 \"\n\tlog_test $? 1 \"Prefsrc removed when src address removed on other device\"\n\n\techo \"    Two devices with the same source address\"\n\n\t$IP addr del dev dummy1 2001:db8:101::11/64\n\t$IP -6 route show | grep -q \"src 2001:db8:101::11 \"\n\tlog_test $? 0 \"Prefsrc not removed when src address exist on other device\"\n\n\t$IP addr del dev dummy2 2001:db8:101::11/64\n\t$IP -6 route show | grep -q \"src 2001:db8:101::11 \"\n\tlog_test $? 1 \"Prefsrc removed when src address removed on all devices\"\n\n\techo \"    VRF with single device using src address\"\n\n\t$IP addr del dev dummy4 2001:db8:101::10/64\n\t$IP -6 route show vrf red | grep -q \"src 2001:db8:101::10 \"\n\tlog_test $? 1 \"Prefsrc removed when src address removed on other device\"\n\n\techo \"    VRF with two devices using src address\"\n\n\t$IP addr del dev dummy4 2001:db8:101::11/64\n\t$IP -6 route show vrf red | grep -q \"src 2001:db8:101::11 \"\n\tlog_test $? 0 \"Prefsrc not removed when src address exist on other device\"\n\n\t$IP addr del dev dummy5 2001:db8:101::11/64\n\t$IP -6 route show vrf red | grep -q \"src 2001:db8:101::11 \"\n\tlog_test $? 1 \"Prefsrc removed when src address removed on all devices\"\n\n\techo \"    src address and nexthop dev in same VRF\"\n\n\t$IP addr del dev dummy4 2001:db8:101::12/64\n\t$IP -6 route show vrf red | grep -q \"src 2001:db8:101::12 \"\n\tlog_test $? 1 \"Prefsrc removed from VRF when source address deleted\"\n\t$IP -6 route show | grep -q \" src 2001:db8:101::12 \"\n\tlog_test $? 0 \"Prefsrc in default VRF not removed\"\n\n\t$IP addr add dev dummy4 2001:db8:101::12/64\n\t$IP route replace vrf red 2001:db8:112::/64 dev dummy6 src 2001:db8:101::12\n\t$IP addr del dev dummy1 2001:db8:101::12/64\n\t$IP -6 route show vrf red | grep -q \"src 2001:db8:101::12 \"\n\tlog_test $? 0 \"Prefsrc not removed from VRF when source address exist\"\n\t$IP -6 route show | grep -q \" src 2001:db8:101::12 \"\n\tlog_test $? 1 \"Prefsrc in default VRF removed\"\n\n\techo \"    src address and nexthop device in different VRF\"\n\n\t$IP addr del dev dummy4 2001:db8:101::13/64\n\t$IP -6 route show vrf red | grep -q \"src 2001:db8:101::13 \"\n\tlog_test $? 0 \"Prefsrc not removed from VRF when nexthop dev in diff VRF\"\n\t$IP -6 route show | grep -q \"src 2001:db8:101::13 \"\n\tlog_test $? 0 \"Prefsrc not removed in default VRF\"\n\n\t$IP addr add dev dummy4 2001:db8:101::13/64\n\t$IP addr del dev dummy1 2001:db8:101::13/64\n\t$IP -6 route show vrf red | grep -q \"src 2001:db8:101::13 \"\n\tlog_test $? 1 \"Prefsrc removed from VRF when nexthop dev in diff VRF\"\n\t$IP -6 route show | grep -q \"src 2001:db8:101::13 \"\n\tlog_test $? 1 \"Prefsrc removed in default VRF\"\n\n\techo \"    Table ID 0\"\n\n\t$IP addr del dev dummy1 2001:db8:101::15/64\n\t$IP -6 route show | grep -q \"src 2001:db8:101::15\"\n\tlog_test $? 1 \"Prefsrc removed from default VRF when source address deleted\"\n\n\techo \"    Link local source route\"\n\t$IP addr del dev dummy1 fe80::1/128\n\t$IP -6 route show | grep -q \"2001:db8:116::/64 dev dummy2 src fe80::1\"\n\tlog_test $? 0 \"Prefsrc not removed when delete ll addr from other dev\"\n\t$IP addr del dev dummy2 fe80::1/128\n\t$IP -6 route show | grep -q \"2001:db8:116::/64 dev dummy2 src fe80::1\"\n\tlog_test $? 1 \"Prefsrc removed when delete ll addr\"\n\t$IP -6 route show | grep -q \"2001:db8:117::/64 dev dummy3 src fe80::1\"\n\tlog_test $? 0 \"Prefsrc not removed when delete ll addr from other dev\"\n\t$IP addr add dev dummy1 fe80::1/128\n\t$IP addr del dev dummy3 fe80::1/128\n\t$IP -6 route show | grep -q \"2001:db8:117::/64 dev dummy3 src fe80::1\"\n\tlog_test $? 1 \"Prefsrc removed even ll addr still exist on other dev\"\n\n\tfor i in $(seq 6); do\n\t\t$IP li del dummy${i}\n\tdone\n\tcleanup\n}\n\nipv4_route_v6_gw_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 route with IPv6 gateway tests\"\n\n\troute_setup\n\tsleep 2\n\n\t#\n\t# single path route\n\t#\n\trun_cmd \"$IP ro add 172.16.104.0/24 via inet6 2001:db8:101::2\"\n\trc=$?\n\tlog_test $rc 0 \"Single path route with IPv6 gateway\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 via inet6 2001:db8:101::2 dev veth1\"\n\tfi\n\n\trun_cmd \"ip netns exec ns1 ping -w1 -c1 172.16.104.1\"\n\tlog_test $rc 0 \"Single path route with IPv6 gateway - ping\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 via inet6 2001:db8:101::2\"\n\trc=$?\n\tlog_test $rc 0 \"Single path route delete\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.112.0/24\"\n\tfi\n\n\t#\n\t# multipath - v6 then v4\n\t#\n\trun_cmd \"$IP ro add 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3\"\n\trc=$?\n\tlog_test $rc 0 \"Multipath route add - v6 nexthop then v4\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1\"\n\tfi\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1\"\n\tlog_test $? 2 \"    Multipath route delete - nexthops in wrong order\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3\"\n\tlog_test $? 0 \"    Multipath route delete exact match\"\n\n\t#\n\t# multipath - v4 then v6\n\t#\n\trun_cmd \"$IP ro add 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1\"\n\trc=$?\n\tlog_test $rc 0 \"Multipath route add - v4 nexthop then v6\"\n\tif [ $rc -eq 0 ]; then\n\t\tcheck_route \"172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 weight 1 nexthop via inet6 2001:db8:101::2 dev veth1 weight 1\"\n\tfi\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3\"\n\tlog_test $? 2 \"    Multipath route delete - nexthops in wrong order\"\n\n\trun_cmd \"$IP ro del 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1\"\n\tlog_test $? 0 \"    Multipath route delete exact match\"\n\n\troute_cleanup\n}\n\nsocat_check()\n{\n\tif [ ! -x \"$(command -v socat)\" ]; then\n\t\techo \"socat command not found. Skipping test\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\niptables_check()\n{\n\tiptables -t mangle -L OUTPUT &> /dev/null\n\tif [ $? -ne 0 ]; then\n\t\techo \"iptables configuration not supported. Skipping test\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\nip6tables_check()\n{\n\tip6tables -t mangle -L OUTPUT &> /dev/null\n\tif [ $? -ne 0 ]; then\n\t\techo \"ip6tables configuration not supported. Skipping test\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\nipv4_mangle_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 mangling tests\"\n\n\tsocat_check || return 1\n\tiptables_check || return 1\n\n\troute_setup\n\tsleep 2\n\n\tlocal tmp_file=$(mktemp)\n\tip netns exec ns2 socat UDP4-LISTEN:54321,fork $tmp_file &\n\n\t# Add a FIB rule and a route that will direct our connection to the\n\t# listening server.\n\t$IP rule add pref 100 ipproto udp sport 12345 dport 54321 table 123\n\t$IP route add table 123 172.16.101.0/24 dev veth1\n\n\t# Add an unreachable route to the main table that will block our\n\t# connection in case the FIB rule is not hit.\n\t$IP route add unreachable 172.16.101.2/32\n\n\trun_cmd \"echo a | $NS_EXEC socat STDIN UDP4:172.16.101.2:54321,sourceport=12345\"\n\tlog_test $? 0 \"    Connection with correct parameters\"\n\n\trun_cmd \"echo a | $NS_EXEC socat STDIN UDP4:172.16.101.2:54321,sourceport=11111\"\n\tlog_test $? 1 \"    Connection with incorrect parameters\"\n\n\t# Add a mangling rule and make sure connection is still successful.\n\t$NS_EXEC iptables -t mangle -A OUTPUT -j MARK --set-mark 1\n\n\trun_cmd \"echo a | $NS_EXEC socat STDIN UDP4:172.16.101.2:54321,sourceport=12345\"\n\tlog_test $? 0 \"    Connection with correct parameters - mangling\"\n\n\t# Delete the mangling rule and make sure connection is still\n\t# successful.\n\t$NS_EXEC iptables -t mangle -D OUTPUT -j MARK --set-mark 1\n\n\trun_cmd \"echo a | $NS_EXEC socat STDIN UDP4:172.16.101.2:54321,sourceport=12345\"\n\tlog_test $? 0 \"    Connection with correct parameters - no mangling\"\n\n\t# Verify connections were indeed successful on server side.\n\t[[ $(cat $tmp_file | wc -l) -eq 3 ]]\n\tlog_test $? 0 \"    Connection check - server side\"\n\n\t$IP route del unreachable 172.16.101.2/32\n\t$IP route del table 123 172.16.101.0/24 dev veth1\n\t$IP rule del pref 100\n\n\t{ kill %% && wait %%; } 2>/dev/null\n\trm $tmp_file\n\n\troute_cleanup\n}\n\nipv6_mangle_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv6 mangling tests\"\n\n\tsocat_check || return 1\n\tip6tables_check || return 1\n\n\troute_setup\n\tsleep 2\n\n\tlocal tmp_file=$(mktemp)\n\tip netns exec ns2 socat UDP6-LISTEN:54321,fork $tmp_file &\n\n\t# Add a FIB rule and a route that will direct our connection to the\n\t# listening server.\n\t$IP -6 rule add pref 100 ipproto udp sport 12345 dport 54321 table 123\n\t$IP -6 route add table 123 2001:db8:101::/64 dev veth1\n\n\t# Add an unreachable route to the main table that will block our\n\t# connection in case the FIB rule is not hit.\n\t$IP -6 route add unreachable 2001:db8:101::2/128\n\n\trun_cmd \"echo a | $NS_EXEC socat STDIN UDP6:[2001:db8:101::2]:54321,sourceport=12345\"\n\tlog_test $? 0 \"    Connection with correct parameters\"\n\n\trun_cmd \"echo a | $NS_EXEC socat STDIN UDP6:[2001:db8:101::2]:54321,sourceport=11111\"\n\tlog_test $? 1 \"    Connection with incorrect parameters\"\n\n\t# Add a mangling rule and make sure connection is still successful.\n\t$NS_EXEC ip6tables -t mangle -A OUTPUT -j MARK --set-mark 1\n\n\trun_cmd \"echo a | $NS_EXEC socat STDIN UDP6:[2001:db8:101::2]:54321,sourceport=12345\"\n\tlog_test $? 0 \"    Connection with correct parameters - mangling\"\n\n\t# Delete the mangling rule and make sure connection is still\n\t# successful.\n\t$NS_EXEC ip6tables -t mangle -D OUTPUT -j MARK --set-mark 1\n\n\trun_cmd \"echo a | $NS_EXEC socat STDIN UDP6:[2001:db8:101::2]:54321,sourceport=12345\"\n\tlog_test $? 0 \"    Connection with correct parameters - no mangling\"\n\n\t# Verify connections were indeed successful on server side.\n\t[[ $(cat $tmp_file | wc -l) -eq 3 ]]\n\tlog_test $? 0 \"    Connection check - server side\"\n\n\t$IP -6 route del unreachable 2001:db8:101::2/128\n\t$IP -6 route del table 123 2001:db8:101::/64 dev veth1\n\t$IP -6 rule del pref 100\n\n\t{ kill %% && wait %%; } 2>/dev/null\n\trm $tmp_file\n\n\troute_cleanup\n}\n\nip_neigh_get_check()\n{\n\tip neigh help 2>&1 | grep -q 'ip neigh get'\n\tif [ $? -ne 0 ]; then\n\t\techo \"iproute2 command does not support neigh get. Skipping test\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\nipv4_bcast_neigh_test()\n{\n\tlocal rc\n\n\techo\n\techo \"IPv4 broadcast neighbour tests\"\n\n\tip_neigh_get_check || return 1\n\n\tsetup\n\n\tset -e\n\trun_cmd \"$IP neigh add 192.0.2.111 lladdr 00:11:22:33:44:55 nud perm dev dummy0\"\n\trun_cmd \"$IP neigh add 192.0.2.255 lladdr 00:11:22:33:44:55 nud perm dev dummy0\"\n\n\trun_cmd \"$IP neigh get 192.0.2.111 dev dummy0\"\n\trun_cmd \"$IP neigh get 192.0.2.255 dev dummy0\"\n\n\trun_cmd \"$IP address add 192.0.2.1/24 broadcast 192.0.2.111 dev dummy0\"\n\n\trun_cmd \"$IP neigh add 203.0.113.111 nud failed dev dummy0\"\n\trun_cmd \"$IP neigh add 203.0.113.255 nud failed dev dummy0\"\n\n\trun_cmd \"$IP neigh get 203.0.113.111 dev dummy0\"\n\trun_cmd \"$IP neigh get 203.0.113.255 dev dummy0\"\n\n\trun_cmd \"$IP address add 203.0.113.1/24 broadcast 203.0.113.111 dev dummy0\"\n\tset +e\n\n\trun_cmd \"$IP neigh get 192.0.2.111 dev dummy0\"\n\tlog_test $? 0 \"Resolved neighbour for broadcast address\"\n\n\trun_cmd \"$IP neigh get 192.0.2.255 dev dummy0\"\n\tlog_test $? 0 \"Resolved neighbour for network broadcast address\"\n\n\trun_cmd \"$IP neigh get 203.0.113.111 dev dummy0\"\n\tlog_test $? 2 \"Unresolved neighbour for broadcast address\"\n\n\trun_cmd \"$IP neigh get 203.0.113.255 dev dummy0\"\n\tlog_test $? 2 \"Unresolved neighbour for network broadcast address\"\n\n\tcleanup\n}\n\nmpath_dep_check()\n{\n\tif [ ! -x \"$(command -v mausezahn)\" ]; then\n\t\techo \"mausezahn command not found. Skipping test\"\n\t\treturn 1\n\tfi\n\n\tif [ ! -x \"$(command -v jq)\" ]; then\n\t\techo \"jq command not found. Skipping test\"\n\t\treturn 1\n\tfi\n\n\tif [ ! -x \"$(command -v bc)\" ]; then\n\t\techo \"bc command not found. Skipping test\"\n\t\treturn 1\n\tfi\n\n\tif [ ! -x \"$(command -v perf)\" ]; then\n\t\techo \"perf command not found. Skipping test\"\n\t\treturn 1\n\tfi\n\n\tperf list fib:* | grep -q fib_table_lookup\n\tif [ $? -ne 0 ]; then\n\t\techo \"IPv4 FIB tracepoint not found. Skipping test\"\n\t\treturn 1\n\tfi\n\n\tperf list fib6:* | grep -q fib6_table_lookup\n\tif [ $? -ne 0 ]; then\n\t\techo \"IPv6 FIB tracepoint not found. Skipping test\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\nlink_stats_get()\n{\n\tlocal ns=$1; shift\n\tlocal dev=$1; shift\n\tlocal dir=$1; shift\n\tlocal stat=$1; shift\n\n\tip -n $ns -j -s link show dev $dev \\\n\t\t| jq '.[][\"stats64\"][\"'$dir'\"][\"'$stat'\"]'\n}\n\nlist_rcv_eval()\n{\n\tlocal file=$1; shift\n\tlocal expected=$1; shift\n\n\tlocal count=$(tail -n 1 $file | jq '.[\"counter-value\"] | tonumber | floor')\n\tlocal ratio=$(echo \"scale=2; $count / $expected\" | bc -l)\n\tlocal res=$(echo \"$ratio >= 0.95\" | bc)\n\t[[ $res -eq 1 ]]\n\tlog_test $? 0 \"Multipath route hit ratio ($ratio)\"\n}\n\nipv4_mpath_list_test()\n{\n\techo\n\techo \"IPv4 multipath list receive tests\"\n\n\tmpath_dep_check || return 1\n\n\troute_setup\n\n\tset -e\n\trun_cmd \"ip netns exec ns1 ethtool -K veth1 tcp-segmentation-offload off\"\n\n\trun_cmd \"ip netns exec ns2 bash -c \\\"echo 20000 > /sys/class/net/veth2/gro_flush_timeout\\\"\"\n\trun_cmd \"ip netns exec ns2 bash -c \\\"echo 1 > /sys/class/net/veth2/napi_defer_hard_irqs\\\"\"\n\trun_cmd \"ip netns exec ns2 ethtool -K veth2 generic-receive-offload on\"\n\trun_cmd \"ip -n ns2 link add name nh1 up type dummy\"\n\trun_cmd \"ip -n ns2 link add name nh2 up type dummy\"\n\trun_cmd \"ip -n ns2 address add 172.16.201.1/24 dev nh1\"\n\trun_cmd \"ip -n ns2 address add 172.16.202.1/24 dev nh2\"\n\trun_cmd \"ip -n ns2 neigh add 172.16.201.2 lladdr 00:11:22:33:44:55 nud perm dev nh1\"\n\trun_cmd \"ip -n ns2 neigh add 172.16.202.2 lladdr 00:aa:bb:cc:dd:ee nud perm dev nh2\"\n\trun_cmd \"ip -n ns2 route add 203.0.113.0/24\n\t\tnexthop via 172.16.201.2 nexthop via 172.16.202.2\"\n\trun_cmd \"ip netns exec ns2 sysctl -qw net.ipv4.fib_multipath_hash_policy=1\"\n\trun_cmd \"ip netns exec ns2 sysctl -qw net.ipv4.conf.veth2.rp_filter=0\"\n\trun_cmd \"ip netns exec ns2 sysctl -qw net.ipv4.conf.all.rp_filter=0\"\n\trun_cmd \"ip netns exec ns2 sysctl -qw net.ipv4.conf.default.rp_filter=0\"\n\tset +e\n\n\tlocal dmac=$(ip -n ns2 -j link show dev veth2 | jq -r '.[][\"address\"]')\n\tlocal tmp_file=$(mktemp)\n\tlocal cmd=\"ip netns exec ns1 mausezahn veth1 -a own -b $dmac\n\t\t-A 172.16.101.1 -B 203.0.113.1 -t udp 'sp=12345,dp=0-65535' -q\"\n\n\t# Packets forwarded in a list using a multipath route must not reuse a\n\t# cached result so that a flow always hits the same nexthop. In other\n\t# words, the FIB lookup tracepoint needs to be triggered for every\n\t# packet.\n\tlocal t0_rx_pkts=$(link_stats_get ns2 veth2 rx packets)\n\trun_cmd \"perf stat -a -e fib:fib_table_lookup --filter 'err == 0' -j -o $tmp_file -- $cmd\"\n\tlocal t1_rx_pkts=$(link_stats_get ns2 veth2 rx packets)\n\tlocal diff=$(echo $t1_rx_pkts - $t0_rx_pkts | bc -l)\n\tlist_rcv_eval $tmp_file $diff\n\n\trm $tmp_file\n\troute_cleanup\n}\n\nipv6_mpath_list_test()\n{\n\techo\n\techo \"IPv6 multipath list receive tests\"\n\n\tmpath_dep_check || return 1\n\n\troute_setup\n\n\tset -e\n\trun_cmd \"ip netns exec ns1 ethtool -K veth1 tcp-segmentation-offload off\"\n\n\trun_cmd \"ip netns exec ns2 bash -c \\\"echo 20000 > /sys/class/net/veth2/gro_flush_timeout\\\"\"\n\trun_cmd \"ip netns exec ns2 bash -c \\\"echo 1 > /sys/class/net/veth2/napi_defer_hard_irqs\\\"\"\n\trun_cmd \"ip netns exec ns2 ethtool -K veth2 generic-receive-offload on\"\n\trun_cmd \"ip -n ns2 link add name nh1 up type dummy\"\n\trun_cmd \"ip -n ns2 link add name nh2 up type dummy\"\n\trun_cmd \"ip -n ns2 -6 address add 2001:db8:201::1/64 dev nh1\"\n\trun_cmd \"ip -n ns2 -6 address add 2001:db8:202::1/64 dev nh2\"\n\trun_cmd \"ip -n ns2 -6 neigh add 2001:db8:201::2 lladdr 00:11:22:33:44:55 nud perm dev nh1\"\n\trun_cmd \"ip -n ns2 -6 neigh add 2001:db8:202::2 lladdr 00:aa:bb:cc:dd:ee nud perm dev nh2\"\n\trun_cmd \"ip -n ns2 -6 route add 2001:db8:301::/64\n\t\tnexthop via 2001:db8:201::2 nexthop via 2001:db8:202::2\"\n\trun_cmd \"ip netns exec ns2 sysctl -qw net.ipv6.fib_multipath_hash_policy=1\"\n\tset +e\n\n\tlocal dmac=$(ip -n ns2 -j link show dev veth2 | jq -r '.[][\"address\"]')\n\tlocal tmp_file=$(mktemp)\n\tlocal cmd=\"ip netns exec ns1 mausezahn -6 veth1 -a own -b $dmac\n\t\t-A 2001:db8:101::1 -B 2001:db8:301::1 -t udp 'sp=12345,dp=0-65535' -q\"\n\n\t# Packets forwarded in a list using a multipath route must not reuse a\n\t# cached result so that a flow always hits the same nexthop. In other\n\t# words, the FIB lookup tracepoint needs to be triggered for every\n\t# packet.\n\tlocal t0_rx_pkts=$(link_stats_get ns2 veth2 rx packets)\n\trun_cmd \"perf stat -a -e fib6:fib6_table_lookup --filter 'err == 0' -j -o $tmp_file -- $cmd\"\n\tlocal t1_rx_pkts=$(link_stats_get ns2 veth2 rx packets)\n\tlocal diff=$(echo $t1_rx_pkts - $t0_rx_pkts | bc -l)\n\tlist_rcv_eval $tmp_file $diff\n\n\trm $tmp_file\n\troute_cleanup\n}\n\n################################################################################\n# usage\n\nusage()\n{\n\tcat <<EOF\nusage: ${0##*/} OPTS\n\n        -t <test>   Test(s) to run (default: all)\n                    (options: $TESTS)\n        -p          Pause on fail\n        -P          Pause after each test before cleanup\n        -v          verbose mode (show commands and output)\nEOF\n}\n\n################################################################################\n# main\n\ntrap cleanup EXIT\n\nwhile getopts :t:pPhv o\ndo\n\tcase $o in\n\t\tt) TESTS=$OPTARG;;\n\t\tp) PAUSE_ON_FAIL=yes;;\n\t\tP) PAUSE=yes;;\n\t\tv) VERBOSE=$(($VERBOSE + 1));;\n\t\th) usage; exit 0;;\n\t\t*) usage; exit 1;;\n\tesac\ndone\n\nPEER_CMD=\"ip netns exec ${PEER_NS}\"\n\n# make sure we don't pause twice\n[ \"${PAUSE}\" = \"yes\" ] && PAUSE_ON_FAIL=no\n\nif [ \"$(id -u)\" -ne 0 ];then\n\techo \"SKIP: Need root privileges\"\n\texit $ksft_skip;\nfi\n\nif [ ! -x \"$(command -v ip)\" ]; then\n\techo \"SKIP: Could not run test without ip tool\"\n\texit $ksft_skip\nfi\n\nip route help 2>&1 | grep -q fibmatch\nif [ $? -ne 0 ]; then\n\techo \"SKIP: iproute2 too old, missing fibmatch\"\n\texit $ksft_skip\nfi\n\n# start clean\ncleanup &> /dev/null\n\nfor t in $TESTS\ndo\n\tcase $t in\n\tfib_unreg_test|unregister)\tfib_unreg_test;;\n\tfib_down_test|down)\t\tfib_down_test;;\n\tfib_carrier_test|carrier)\tfib_carrier_test;;\n\tfib_rp_filter_test|rp_filter)\tfib_rp_filter_test;;\n\tfib_nexthop_test|nexthop)\tfib_nexthop_test;;\n\tfib_notify_test|ipv4_notify)\tfib_notify_test;;\n\tfib6_notify_test|ipv6_notify)\tfib6_notify_test;;\n\tfib_suppress_test|suppress)\tfib_suppress_test;;\n\tipv6_route_test|ipv6_rt)\tipv6_route_test;;\n\tipv4_route_test|ipv4_rt)\tipv4_route_test;;\n\tipv6_addr_metric)\t\tipv6_addr_metric_test;;\n\tipv4_addr_metric)\t\tipv4_addr_metric_test;;\n\tipv4_del_addr)\t\t\tipv4_del_addr_test;;\n\tipv6_del_addr)\t\t\tipv6_del_addr_test;;\n\tipv6_route_metrics)\t\tipv6_route_metrics_test;;\n\tipv4_route_metrics)\t\tipv4_route_metrics_test;;\n\tipv4_route_v6_gw)\t\tipv4_route_v6_gw_test;;\n\tipv4_mangle)\t\t\tipv4_mangle_test;;\n\tipv6_mangle)\t\t\tipv6_mangle_test;;\n\tipv4_bcast_neigh)\t\tipv4_bcast_neigh_test;;\n\tfib6_gc_test|ipv6_gc)\t\tfib6_gc_test;;\n\tipv4_mpath_list)\t\tipv4_mpath_list_test;;\n\tipv6_mpath_list)\t\tipv6_mpath_list_test;;\n\n\thelp) echo \"Test names: $TESTS\"; exit 0;;\n\tesac\ndone\n\nif [ \"$TESTS\" != \"none\" ]; then\n\tprintf \"\\nTests passed: %3d\\n\" ${nsuccess}\n\tprintf \"Tests failed: %3d\\n\"   ${nfail}\nfi\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}