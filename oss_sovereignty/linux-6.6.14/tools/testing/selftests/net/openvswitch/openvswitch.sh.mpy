{
  "module_name": "openvswitch.sh",
  "hash_id": "61efd840762c97203161a6c7c52c2683cc12ad99f3ee39c78a745ae2ebecc493",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/openvswitch/openvswitch.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# OVS kernel module self tests\n\ntrap ovs_exit_sig EXIT TERM INT ERR\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\nPAUSE_ON_FAIL=no\nVERBOSE=0\nTRACING=0\n\ntests=\"\n\tarp_ping\t\t\t\teth-arp: Basic arp ping between two NS\n\tct_connect_v4\t\t\t\tip4-ct-xon: Basic ipv4 tcp connection using ct\n\tconnect_v4\t\t\t\tip4-xon: Basic ipv4 ping between two NS\n\tnat_connect_v4\t\t\t\tip4-nat-xon: Basic ipv4 tcp connection via NAT\n\tnetlink_checks\t\t\t\tovsnl: validate netlink attrs and settings\n\tupcall_interfaces\t\t\tovs: test the upcall interfaces\n\tdrop_reason\t\t\t\tdrop: test drop reasons are emitted\"\n\ninfo() {\n    [ $VERBOSE = 0 ] || echo $*\n}\n\novs_base=`pwd`\nsbxs=\nsbx_add () {\n\tinfo \"adding sandbox '$1'\"\n\n\tsbxs=\"$sbxs $1\"\n\n\tNO_BIN=0\n\n\t# Create sandbox.\n\tlocal d=\"$ovs_base\"/$1\n\tif [ -e $d ]; then\n\t\tinfo \"removing $d\"\n\t\trm -rf \"$d\"\n\tfi\n\tmkdir \"$d\" || return 1\n\tovs_setenv $1\n}\n\novs_exit_sig() {\n\t[ -e ${ovs_dir}/cleanup ] && . \"$ovs_dir/cleanup\"\n}\n\non_exit() {\n\techo \"$1\" > ${ovs_dir}/cleanup.tmp\n\tcat ${ovs_dir}/cleanup >> ${ovs_dir}/cleanup.tmp\n\tmv ${ovs_dir}/cleanup.tmp ${ovs_dir}/cleanup\n}\n\novs_setenv() {\n\tsandbox=$1\n\n\tovs_dir=$ovs_base${1:+/$1}; export ovs_dir\n\n\ttest -e ${ovs_dir}/cleanup || : > ${ovs_dir}/cleanup\n}\n\novs_sbx() {\n\tif test \"X$2\" != X; then\n\t\t(ovs_setenv $1; shift; \"$@\" >> ${ovs_dir}/debug.log)\n\telse\n\t\tovs_setenv $1\n\tfi\n}\n\novs_add_dp () {\n\tinfo \"Adding DP/Bridge IF: sbx:$1 dp:$2 {$3, $4, $5}\"\n\tsbxname=\"$1\"\n\tshift\n\tovs_sbx \"$sbxname\" python3 $ovs_base/ovs-dpctl.py add-dp $*\n\ton_exit \"ovs_sbx $sbxname python3 $ovs_base/ovs-dpctl.py del-dp $1;\"\n}\n\novs_add_if () {\n\tinfo \"Adding IF to DP: br:$2 if:$3\"\n\tif [ \"$4\" != \"-u\" ]; then\n\t\tovs_sbx \"$1\" python3 $ovs_base/ovs-dpctl.py add-if \"$2\" \"$3\" \\\n\t\t    || return 1\n\telse\n\t\tpython3 $ovs_base/ovs-dpctl.py add-if \\\n\t\t    -u \"$2\" \"$3\" >$ovs_dir/$3.out 2>$ovs_dir/$3.err &\n\t\tpid=$!\n\t\ton_exit \"ovs_sbx $1 kill -TERM $pid 2>/dev/null\"\n\tfi\n}\n\novs_del_if () {\n\tinfo \"Deleting IF from DP: br:$2 if:$3\"\n\tovs_sbx \"$1\" python3 $ovs_base/ovs-dpctl.py del-if \"$2\" \"$3\" || return 1\n}\n\novs_netns_spawn_daemon() {\n\tsbx=$1\n\tshift\n\tnetns=$1\n\tshift\n\tinfo \"spawning cmd: $*\"\n\tip netns exec $netns $*  >> $ovs_dir/stdout  2>> $ovs_dir/stderr &\n\tpid=$!\n\tovs_sbx \"$sbx\" on_exit \"kill -TERM $pid 2>/dev/null\"\n}\n\novs_add_netns_and_veths () {\n\tinfo \"Adding netns attached: sbx:$1 dp:$2 {$3, $4, $5}\"\n\tovs_sbx \"$1\" ip netns add \"$3\" || return 1\n\ton_exit \"ovs_sbx $1 ip netns del $3\"\n\tovs_sbx \"$1\" ip link add \"$4\" type veth peer name \"$5\" || return 1\n\ton_exit \"ovs_sbx $1 ip link del $4 >/dev/null 2>&1\"\n\tovs_sbx \"$1\" ip link set \"$4\" up || return 1\n\tovs_sbx \"$1\" ip link set \"$5\" netns \"$3\" || return 1\n\tovs_sbx \"$1\" ip netns exec \"$3\" ip link set \"$5\" up || return 1\n\n\tif [ \"$6\" != \"\" ]; then\n\t\tovs_sbx \"$1\" ip netns exec \"$3\" ip addr add \"$6\" dev \"$5\" \\\n\t\t    || return 1\n\tfi\n\n\tif [ \"$7\" != \"-u\" ]; then\n\t\tovs_add_if \"$1\" \"$2\" \"$4\" || return 1\n\telse\n\t\tovs_add_if \"$1\" \"$2\" \"$4\" -u || return 1\n\tfi\n\n\t[ $TRACING -eq 1 ] && ovs_netns_spawn_daemon \"$1\" \"$ns\" \\\n\t\t\ttcpdump -i any -s 65535\n\n\treturn 0\n}\n\novs_add_flow () {\n\tinfo \"Adding flow to DP: sbx:$1 br:$2 flow:$3 act:$4\"\n\tovs_sbx \"$1\" python3 $ovs_base/ovs-dpctl.py add-flow \"$2\" \"$3\" \"$4\"\n\tif [ $? -ne 0 ]; then\n\t\techo \"Flow [ $3 : $4 ] failed\" >> ${ovs_dir}/debug.log\n\t\treturn 1\n\tfi\n\treturn 0\n}\n\novs_del_flows () {\n\tinfo \"Deleting all flows from DP: sbx:$1 br:$2\"\n\tovs_sbx \"$1\" python3 $ovs_base/ovs-dpctl.py del-flows \"$2\"\n\treturn 0\n}\n\novs_drop_record_and_run () {\n\tlocal sbx=$1\n\tshift\n\n\tperf record -a -q -e skb:kfree_skb -o ${ovs_dir}/perf.data $* \\\n\t\t>> ${ovs_dir}/stdout 2>> ${ovs_dir}/stderr\n\treturn $?\n}\n\novs_drop_reason_count()\n{\n\tlocal reason=$1\n\n\tlocal perf_output=`perf script -i ${ovs_dir}/perf.data -F trace:event,trace`\n\tlocal pattern=\"skb:kfree_skb:.*reason: $reason\"\n\n\treturn `echo \"$perf_output\" | grep \"$pattern\" | wc -l`\n}\n\nusage() {\n\techo\n\techo \"$0 [OPTIONS] [TEST]...\"\n\techo \"If no TEST argument is given, all tests will be run.\"\n\techo\n\techo \"Options\"\n\techo \"  -t: capture traffic via tcpdump\"\n\techo \"  -v: verbose\"\n\techo \"  -p: pause on failure\"\n\techo\n\techo \"Available tests${tests}\"\n\texit 1\n}\n\n# drop_reason test\n# - drop packets and verify the right drop reason is reported\ntest_drop_reason() {\n\twhich perf >/dev/null 2>&1 || return $ksft_skip\n\n\tsbx_add \"test_drop_reason\" || return $?\n\n\tovs_add_dp \"test_drop_reason\" dropreason || return 1\n\n\tinfo \"create namespaces\"\n\tfor ns in client server; do\n\t\tovs_add_netns_and_veths \"test_drop_reason\" \"dropreason\" \"$ns\" \\\n\t\t\t\"${ns:0:1}0\" \"${ns:0:1}1\" || return 1\n\tdone\n\n\t# Setup client namespace\n\tip netns exec client ip addr add 172.31.110.10/24 dev c1\n\tip netns exec client ip link set c1 up\n\n\t# Setup server namespace\n\tip netns exec server ip addr add 172.31.110.20/24 dev s1\n\tip netns exec server ip link set s1 up\n\n\t# Check if drop reasons can be sent\n\tovs_add_flow \"test_drop_reason\" dropreason \\\n\t\t'in_port(1),eth(),eth_type(0x0806),arp()' 'drop(10)' 2>/dev/null\n\tif [ $? == 1 ]; then\n\t\tinfo \"no support for drop reasons - skipping\"\n\t\tovs_exit_sig\n\t\treturn $ksft_skip\n\tfi\n\n\tovs_del_flows \"test_drop_reason\" dropreason\n\n\t# Allow ARP\n\tovs_add_flow \"test_drop_reason\" dropreason \\\n\t\t'in_port(1),eth(),eth_type(0x0806),arp()' '2' || return 1\n\tovs_add_flow \"test_drop_reason\" dropreason \\\n\t\t'in_port(2),eth(),eth_type(0x0806),arp()' '1' || return 1\n\n\t# Allow client ICMP traffic but drop return path\n\tovs_add_flow \"test_drop_reason\" dropreason \\\n\t\t\"in_port(1),eth(),eth_type(0x0800),ipv4(src=172.31.110.10,proto=1),icmp()\" '2'\n\tovs_add_flow \"test_drop_reason\" dropreason \\\n\t\t\"in_port(2),eth(),eth_type(0x0800),ipv4(src=172.31.110.20,proto=1),icmp()\" 'drop'\n\n\tovs_drop_record_and_run \"test_drop_reason\" ip netns exec client ping -c 2 172.31.110.20\n\tovs_drop_reason_count 0x30001 # OVS_DROP_FLOW_ACTION\n\tif [[ \"$?\" -ne \"2\" ]]; then\n\t\tinfo \"Did not detect expected drops: $?\"\n\t\treturn 1\n\tfi\n\n\t# Drop UDP 6000 traffic with an explicit action and an error code.\n\tovs_add_flow \"test_drop_reason\" dropreason \\\n\t\t\"in_port(1),eth(),eth_type(0x0800),ipv4(src=172.31.110.10,proto=17),udp(dst=6000)\" \\\n                'drop(42)'\n\t# Drop UDP 7000 traffic with an explicit action with no error code.\n\tovs_add_flow \"test_drop_reason\" dropreason \\\n\t\t\"in_port(1),eth(),eth_type(0x0800),ipv4(src=172.31.110.10,proto=17),udp(dst=7000)\" \\\n                'drop(0)'\n\n\tovs_drop_record_and_run \\\n            \"test_drop_reason\" ip netns exec client nc -i 1 -zuv 172.31.110.20 6000\n\tovs_drop_reason_count 0x30004 # OVS_DROP_EXPLICIT_ACTION_ERROR\n\tif [[ \"$?\" -ne \"1\" ]]; then\n\t\tinfo \"Did not detect expected explicit error drops: $?\"\n\t\treturn 1\n\tfi\n\n\tovs_drop_record_and_run \\\n            \"test_drop_reason\" ip netns exec client nc -i 1 -zuv 172.31.110.20 7000\n\tovs_drop_reason_count 0x30003 # OVS_DROP_EXPLICIT_ACTION\n\tif [[ \"$?\" -ne \"1\" ]]; then\n\t\tinfo \"Did not detect expected explicit drops: $?\"\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\n# arp_ping test\n# - client has 1500 byte MTU\n# - server has 1500 byte MTU\n# - send ARP ping between two ns\ntest_arp_ping () {\n\n\twhich arping >/dev/null 2>&1 || return $ksft_skip\n\n\tsbx_add \"test_arp_ping\" || return $?\n\n\tovs_add_dp \"test_arp_ping\" arpping || return 1\n\n\tinfo \"create namespaces\"\n\tfor ns in client server; do\n\t\tovs_add_netns_and_veths \"test_arp_ping\" \"arpping\" \"$ns\" \\\n\t\t    \"${ns:0:1}0\" \"${ns:0:1}1\" || return 1\n\tdone\n\n\t# Setup client namespace\n\tip netns exec client ip addr add 172.31.110.10/24 dev c1\n\tip netns exec client ip link set c1 up\n\tHW_CLIENT=`ip netns exec client ip link show dev c1 | grep -E 'link/ether [0-9a-f:]+' | awk '{print $2;}'`\n\tinfo \"Client hwaddr: $HW_CLIENT\"\n\n\t# Setup server namespace\n\tip netns exec server ip addr add 172.31.110.20/24 dev s1\n\tip netns exec server ip link set s1 up\n\tHW_SERVER=`ip netns exec server ip link show dev s1 | grep -E 'link/ether [0-9a-f:]+' | awk '{print $2;}'`\n\tinfo \"Server hwaddr: $HW_SERVER\"\n\n\tovs_add_flow \"test_arp_ping\" arpping \\\n\t\t\"in_port(1),eth(),eth_type(0x0806),arp(sip=172.31.110.10,tip=172.31.110.20,sha=$HW_CLIENT,tha=ff:ff:ff:ff:ff:ff)\" '2' || return 1\n\tovs_add_flow \"test_arp_ping\" arpping \\\n\t\t\"in_port(2),eth(),eth_type(0x0806),arp()\" '1' || return 1\n\n\tovs_sbx \"test_arp_ping\" ip netns exec client arping -I c1 172.31.110.20 -c 1 || return 1\n\n\treturn 0\n}\n\n# ct_connect_v4 test\n#  - client has 1500 byte MTU\n#  - server has 1500 byte MTU\n#  - use ICMP to ping in each direction\n#  - only allow CT state stuff to pass through new in c -> s\ntest_ct_connect_v4 () {\n\n\twhich nc >/dev/null 2>/dev/null || return $ksft_skip\n\n\tsbx_add \"test_ct_connect_v4\" || return $?\n\n\tovs_add_dp \"test_ct_connect_v4\" ct4 || return 1\n\tinfo \"create namespaces\"\n\tfor ns in client server; do\n\t\tovs_add_netns_and_veths \"test_ct_connect_v4\" \"ct4\" \"$ns\" \\\n\t\t    \"${ns:0:1}0\" \"${ns:0:1}1\" || return 1\n\tdone\n\n\tip netns exec client ip addr add 172.31.110.10/24 dev c1\n\tip netns exec client ip link set c1 up\n\tip netns exec server ip addr add 172.31.110.20/24 dev s1\n\tip netns exec server ip link set s1 up\n\n\t# Add forwarding for ARP and ip packets - completely wildcarded\n\tovs_add_flow \"test_ct_connect_v4\" ct4 \\\n\t\t'in_port(1),eth(),eth_type(0x0806),arp()' '2' || return 1\n\tovs_add_flow \"test_ct_connect_v4\" ct4 \\\n\t\t'in_port(2),eth(),eth_type(0x0806),arp()' '1' || return 1\n\tovs_add_flow \"test_ct_connect_v4\" ct4 \\\n\t\t     'ct_state(-trk),eth(),eth_type(0x0800),ipv4()' \\\n\t\t     'ct(commit),recirc(0x1)' || return 1\n\tovs_add_flow \"test_ct_connect_v4\" ct4 \\\n\t\t     'recirc_id(0x1),ct_state(+trk+new),in_port(1),eth(),eth_type(0x0800),ipv4(src=172.31.110.10)' \\\n\t\t     '2' || return 1\n\tovs_add_flow \"test_ct_connect_v4\" ct4 \\\n\t\t     'recirc_id(0x1),ct_state(+trk+est),in_port(1),eth(),eth_type(0x0800),ipv4(src=172.31.110.10)' \\\n\t\t     '2' || return 1\n\tovs_add_flow \"test_ct_connect_v4\" ct4 \\\n\t\t     'recirc_id(0x1),ct_state(+trk+est),in_port(2),eth(),eth_type(0x0800),ipv4(dst=172.31.110.10)' \\\n\t\t     '1' || return 1\n\tovs_add_flow \"test_ct_connect_v4\" ct4 \\\n\t\t     'recirc_id(0x1),ct_state(+trk+inv),eth(),eth_type(0x0800),ipv4()' 'drop' || \\\n\t\t     return 1\n\n\t# do a ping\n\tovs_sbx \"test_ct_connect_v4\" ip netns exec client ping 172.31.110.20 -c 3 || return 1\n\n\t# create an echo server in 'server'\n\techo \"server\" | \\\n\t\tovs_netns_spawn_daemon \"test_ct_connect_v4\" \"server\" \\\n\t\t\t\tnc -lvnp 4443\n\tovs_sbx \"test_ct_connect_v4\" ip netns exec client nc -i 1 -zv 172.31.110.20 4443 || return 1\n\n\t# Now test in the other direction (should fail)\n\techo \"client\" | \\\n\t\tovs_netns_spawn_daemon \"test_ct_connect_v4\" \"client\" \\\n\t\t\t\tnc -lvnp 4443\n\tovs_sbx \"test_ct_connect_v4\" ip netns exec client nc -i 1 -zv 172.31.110.10 4443\n\tif [ $? == 0 ]; then\n\t   info \"ct connect to client was successful\"\n\t   return 1\n\tfi\n\n\tinfo \"done...\"\n\treturn 0\n}\n\n# connect_v4 test\n#  - client has 1500 byte MTU\n#  - server has 1500 byte MTU\n#  - use ICMP to ping in each direction\ntest_connect_v4 () {\n\n\tsbx_add \"test_connect_v4\" || return $?\n\n\tovs_add_dp \"test_connect_v4\" cv4 || return 1\n\n\tinfo \"create namespaces\"\n\tfor ns in client server; do\n\t\tovs_add_netns_and_veths \"test_connect_v4\" \"cv4\" \"$ns\" \\\n\t\t    \"${ns:0:1}0\" \"${ns:0:1}1\" || return 1\n\tdone\n\n\n\tip netns exec client ip addr add 172.31.110.10/24 dev c1\n\tip netns exec client ip link set c1 up\n\tip netns exec server ip addr add 172.31.110.20/24 dev s1\n\tip netns exec server ip link set s1 up\n\n\t# Add forwarding for ARP and ip packets - completely wildcarded\n\tovs_add_flow \"test_connect_v4\" cv4 \\\n\t\t'in_port(1),eth(),eth_type(0x0806),arp()' '2' || return 1\n\tovs_add_flow \"test_connect_v4\" cv4 \\\n\t\t'in_port(2),eth(),eth_type(0x0806),arp()' '1' || return 1\n\tovs_add_flow \"test_connect_v4\" cv4 \\\n\t\t'in_port(1),eth(),eth_type(0x0800),ipv4(src=172.31.110.10)' '2' || return 1\n\tovs_add_flow \"test_connect_v4\" cv4 \\\n\t\t'in_port(2),eth(),eth_type(0x0800),ipv4(src=172.31.110.20)' '1' || return 1\n\n\t# do a ping\n\tovs_sbx \"test_connect_v4\" ip netns exec client ping 172.31.110.20 -c 3 || return 1\n\n\tinfo \"done...\"\n\treturn 0\n}\n\n# nat_connect_v4 test\n#  - client has 1500 byte MTU\n#  - server has 1500 byte MTU\n#  - use ICMP to ping in each direction\n#  - only allow CT state stuff to pass through new in c -> s\ntest_nat_connect_v4 () {\n\twhich nc >/dev/null 2>/dev/null || return $ksft_skip\n\n\tsbx_add \"test_nat_connect_v4\" || return $?\n\n\tovs_add_dp \"test_nat_connect_v4\" nat4 || return 1\n\tinfo \"create namespaces\"\n\tfor ns in client server; do\n\t\tovs_add_netns_and_veths \"test_nat_connect_v4\" \"nat4\" \"$ns\" \\\n\t\t    \"${ns:0:1}0\" \"${ns:0:1}1\" || return 1\n\tdone\n\n\tip netns exec client ip addr add 172.31.110.10/24 dev c1\n\tip netns exec client ip link set c1 up\n\tip netns exec server ip addr add 172.31.110.20/24 dev s1\n\tip netns exec server ip link set s1 up\n\n\tip netns exec client ip route add default via 172.31.110.20\n\n\tovs_add_flow \"test_nat_connect_v4\" nat4 \\\n\t\t'in_port(1),eth(),eth_type(0x0806),arp()' '2' || return 1\n\tovs_add_flow \"test_nat_connect_v4\" nat4 \\\n\t\t'in_port(2),eth(),eth_type(0x0806),arp()' '1' || return 1\n\tovs_add_flow \"test_nat_connect_v4\" nat4 \\\n\t\t\"ct_state(-trk),in_port(1),eth(),eth_type(0x0800),ipv4(dst=192.168.0.20)\" \\\n\t\t\"ct(commit,nat(dst=172.31.110.20)),recirc(0x1)\"\n\tovs_add_flow \"test_nat_connect_v4\" nat4 \\\n\t\t\"ct_state(-trk),in_port(2),eth(),eth_type(0x0800),ipv4()\" \\\n\t\t\"ct(commit,nat),recirc(0x2)\"\n\n\tovs_add_flow \"test_nat_connect_v4\" nat4 \\\n\t\t\"recirc_id(0x1),ct_state(+trk-inv),in_port(1),eth(),eth_type(0x0800),ipv4()\" \"2\"\n\tovs_add_flow \"test_nat_connect_v4\" nat4 \\\n\t\t\"recirc_id(0x2),ct_state(+trk-inv),in_port(2),eth(),eth_type(0x0800),ipv4()\" \"1\"\n\n\t# do a ping\n\tovs_sbx \"test_nat_connect_v4\" ip netns exec client ping 192.168.0.20 -c 3 || return 1\n\n\t# create an echo server in 'server'\n\techo \"server\" | \\\n\t\tovs_netns_spawn_daemon \"test_nat_connect_v4\" \"server\" \\\n\t\t\t\tnc -lvnp 4443\n\tovs_sbx \"test_nat_connect_v4\" ip netns exec client nc -i 1 -zv 192.168.0.20 4443 || return 1\n\n\t# Now test in the other direction (should fail)\n\techo \"client\" | \\\n\t\tovs_netns_spawn_daemon \"test_nat_connect_v4\" \"client\" \\\n\t\t\t\tnc -lvnp 4443\n\tovs_sbx \"test_nat_connect_v4\" ip netns exec client nc -i 1 -zv 172.31.110.10 4443\n\tif [ $? == 0 ]; then\n\t   info \"connect to client was successful\"\n\t   return 1\n\tfi\n\n\tinfo \"done...\"\n\treturn 0\n}\n\n# netlink_validation\n# - Create a dp\n# - check no warning with \"old version\" simulation\ntest_netlink_checks () {\n\tsbx_add \"test_netlink_checks\" || return 1\n\n\tinfo \"setting up new DP\"\n\tovs_add_dp \"test_netlink_checks\" nv0 || return 1\n\t# now try again\n\tPRE_TEST=$(dmesg | grep -E \"RIP: [0-9a-fA-Fx]+:ovs_dp_cmd_new\\+\")\n\tovs_add_dp \"test_netlink_checks\" nv0 -V 0 || return 1\n\tPOST_TEST=$(dmesg | grep -E \"RIP: [0-9a-fA-Fx]+:ovs_dp_cmd_new\\+\")\n\tif [ \"$PRE_TEST\" != \"$POST_TEST\" ]; then\n\t\tinfo \"failed - gen warning\"\n\t\treturn 1\n\tfi\n\n\tovs_add_netns_and_veths \"test_netlink_checks\" nv0 left left0 l0 || \\\n\t    return 1\n\tovs_add_netns_and_veths \"test_netlink_checks\" nv0 right right0 r0 || \\\n\t    return 1\n\t[ $(python3 $ovs_base/ovs-dpctl.py show nv0 | grep port | \\\n\t    wc -l) == 3 ] || \\\n\t      return 1\n\tovs_del_if \"test_netlink_checks\" nv0 right0 || return 1\n\t[ $(python3 $ovs_base/ovs-dpctl.py show nv0 | grep port | \\\n\t    wc -l) == 2 ] || \\\n\t      return 1\n\n\tERR_MSG=\"Flow actions may not be safe on all matching packets\"\n\tPRE_TEST=$(dmesg | grep -c \"${ERR_MSG}\")\n\tovs_add_flow \"test_netlink_checks\" nv0 \\\n\t\t'in_port(1),eth(),eth_type(0x0806),arp()' 'drop(0),2' \\\n\t\t&> /dev/null && return 1\n\tPOST_TEST=$(dmesg | grep -c \"${ERR_MSG}\")\n\tif [ \"$PRE_TEST\" == \"$POST_TEST\" ]; then\n\t\tinfo \"failed - error not generated\"\n\t\treturn 1\n\tfi\n\treturn 0\n}\n\ntest_upcall_interfaces() {\n\tsbx_add \"test_upcall_interfaces\" || return 1\n\n\tinfo \"setting up new DP\"\n\tovs_add_dp \"test_upcall_interfaces\" ui0 -V 2:1 || return 1\n\n\tovs_add_netns_and_veths \"test_upcall_interfaces\" ui0 upc left0 l0 \\\n\t    172.31.110.1/24 -u || return 1\n\n\tsleep 1\n\tinfo \"sending arping\"\n\tip netns exec upc arping -I l0 172.31.110.20 -c 1 \\\n\t    >$ovs_dir/arping.stdout 2>$ovs_dir/arping.stderr\n\n\tgrep -E \"MISS upcall\\[0/yes\\]: .*arp\\(sip=172.31.110.1,tip=172.31.110.20,op=1,sha=\" $ovs_dir/left0.out >/dev/null 2>&1 || return 1\n\treturn 0\n}\n\nrun_test() {\n\t(\n\ttname=\"$1\"\n\ttdesc=\"$2\"\n\n\tif ! lsmod | grep openvswitch >/dev/null 2>&1; then\n\t\tstdbuf -o0 printf \"TEST: %-60s  [NOMOD]\\n\" \"${tdesc}\"\n\t\treturn $ksft_skip\n\tfi\n\n\tif python3 ovs-dpctl.py -h 2>&1 | \\\n\t     grep -E \"Need to (install|upgrade) the python\" >/dev/null 2>&1; then\n\t\tstdbuf -o0 printf \"TEST: %-60s  [PYLIB]\\n\" \"${tdesc}\"\n\t\treturn $ksft_skip\n\tfi\n\tprintf \"TEST: %-60s  [START]\\n\" \"${tname}\"\n\n\tunset IFS\n\n\teval test_${tname}\n\tret=$?\n\n\tif [ $ret -eq 0 ]; then\n\t\tprintf \"TEST: %-60s  [ OK ]\\n\" \"${tdesc}\"\n\t\tovs_exit_sig\n\t\trm -rf \"$ovs_dir\"\n\telif [ $ret -eq 1 ]; then\n\t\tprintf \"TEST: %-60s  [FAIL]\\n\" \"${tdesc}\"\n\t\tif [ \"${PAUSE_ON_FAIL}\" = \"yes\" ]; then\n\t\t\techo\n\t\t\techo \"Pausing. Logs in $ovs_dir/. Hit enter to continue\"\n\t\t\tread a\n\t\tfi\n\t\tovs_exit_sig\n\t\t[ \"${PAUSE_ON_FAIL}\" = \"yes\" ] || rm -rf \"$ovs_dir\"\n\t\texit 1\n\telif [ $ret -eq $ksft_skip ]; then\n\t\tprintf \"TEST: %-60s  [SKIP]\\n\" \"${tdesc}\"\n\telif [ $ret -eq 2 ]; then\n\t\trm -rf test_${tname}\n\t\trun_test \"$1\" \"$2\"\n\tfi\n\n\treturn $ret\n\t)\n\tret=$?\n\tcase $ret in\n\t\t0)\n\t\t\t[ $all_skipped = true ] && [ $exitcode=$ksft_skip ] && exitcode=0\n\t\t\tall_skipped=false\n\t\t;;\n\t\t$ksft_skip)\n\t\t\t[ $all_skipped = true ] && exitcode=$ksft_skip\n\t\t;;\n\t\t*)\n\t\t\tall_skipped=false\n\t\t\texitcode=1\n\t\t;;\n\tesac\n\n\treturn $ret\n}\n\n\nexitcode=0\ndesc=0\nall_skipped=true\n\nwhile getopts :pvt o\ndo\n\tcase $o in\n\tp) PAUSE_ON_FAIL=yes;;\n\tv) VERBOSE=1;;\n\tt) if which tcpdump > /dev/null 2>&1; then\n\t\tTRACING=1\n\t   else\n\t\techo \"=== tcpdump not available, tracing disabled\"\n\t   fi\n\t   ;;\n\t*) usage;;\n\tesac\ndone\nshift $(($OPTIND-1))\n\nIFS=\"\t\n\"\n\nfor arg do\n\t# Check first that all requested tests are available before running any\n\tcommand -v > /dev/null \"test_${arg}\" || { echo \"=== Test ${arg} not found\"; usage; }\ndone\n\nname=\"\"\ndesc=\"\"\nfor t in ${tests}; do\n\t[ \"${name}\" = \"\" ]\t&& name=\"${t}\"\t&& continue\n\t[ \"${desc}\" = \"\" ]\t&& desc=\"${t}\"\n\n\trun_this=1\n\tfor arg do\n\t\t[ \"${arg}\" != \"${arg#--*}\" ] && continue\n\t\t[ \"${arg}\" = \"${name}\" ] && run_this=1 && break\n\t\trun_this=0\n\tdone\n\tif [ $run_this -eq 1 ]; then\n\t\trun_test \"${name}\" \"${desc}\"\n\tfi\n\tname=\"\"\n\tdesc=\"\"\ndone\n\nexit ${exitcode}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}