{
  "module_name": "ovs-dpctl.py",
  "hash_id": "e8e5e43dd662dafd08b41fd18b3925761b603d00ea03b1b09911de808a180b80",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/openvswitch/ovs-dpctl.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n\n# Controls the openvswitch module.  Part of the kselftest suite, but\n# can be used for some diagnostic purpose as well.\n\nimport argparse\nimport errno\nimport ipaddress\nimport logging\nimport multiprocessing\nimport re\nimport struct\nimport sys\nimport time\nimport types\nimport uuid\n\ntry:\n    from pyroute2 import NDB\n\n    from pyroute2.netlink import NLA_F_NESTED\n    from pyroute2.netlink import NLM_F_ACK\n    from pyroute2.netlink import NLM_F_DUMP\n    from pyroute2.netlink import NLM_F_REQUEST\n    from pyroute2.netlink import genlmsg\n    from pyroute2.netlink import nla\n    from pyroute2.netlink import nlmsg_atoms\n    from pyroute2.netlink.exceptions import NetlinkError\n    from pyroute2.netlink.generic import GenericNetlinkSocket\n    import pyroute2\n\nexcept ModuleNotFoundError:\n    print(\"Need to install the python pyroute2 package >= 0.6.\")\n    sys.exit(0)\n\n\nOVS_DATAPATH_FAMILY = \"ovs_datapath\"\nOVS_VPORT_FAMILY = \"ovs_vport\"\nOVS_FLOW_FAMILY = \"ovs_flow\"\nOVS_PACKET_FAMILY = \"ovs_packet\"\nOVS_METER_FAMILY = \"ovs_meter\"\nOVS_CT_LIMIT_FAMILY = \"ovs_ct_limit\"\n\nOVS_DATAPATH_VERSION = 2\nOVS_DP_CMD_NEW = 1\nOVS_DP_CMD_DEL = 2\nOVS_DP_CMD_GET = 3\nOVS_DP_CMD_SET = 4\n\nOVS_VPORT_CMD_NEW = 1\nOVS_VPORT_CMD_DEL = 2\nOVS_VPORT_CMD_GET = 3\nOVS_VPORT_CMD_SET = 4\n\nOVS_FLOW_CMD_NEW = 1\nOVS_FLOW_CMD_DEL = 2\nOVS_FLOW_CMD_GET = 3\nOVS_FLOW_CMD_SET = 4\n\n\ndef macstr(mac):\n    outstr = \":\".join([\"%02X\" % i for i in mac])\n    return outstr\n\n\ndef strcspn(str1, str2):\n    tot = 0\n    for char in str1:\n        if str2.find(char) != -1:\n            return tot\n        tot += 1\n    return tot\n\n\ndef strspn(str1, str2):\n    tot = 0\n    for char in str1:\n        if str2.find(char) == -1:\n            return tot\n        tot += 1\n    return tot\n\n\ndef intparse(statestr, defmask=\"0xffffffff\"):\n    totalparse = strspn(statestr, \"0123456789abcdefABCDEFx/\")\n    # scan until \"/\"\n    count = strspn(statestr, \"x0123456789abcdefABCDEF\")\n\n    firstnum = statestr[:count]\n    if firstnum[-1] == \"/\":\n        firstnum = firstnum[:-1]\n    k = int(firstnum, 0)\n\n    m = None\n    if defmask is not None:\n        secondnum = defmask\n        if statestr[count] == \"/\":\n            secondnum = statestr[count + 1 :]  # this is wrong...\n        m = int(secondnum, 0)\n\n    return statestr[totalparse + 1 :], k, m\n\n\ndef parse_flags(flag_str, flag_vals):\n    bitResult = 0\n    maskResult = 0\n\n    if len(flag_str) == 0:\n        return flag_str, bitResult, maskResult\n\n    if flag_str[0].isdigit():\n        idx = 0\n        while flag_str[idx].isdigit() or flag_str[idx] == \"x\":\n            idx += 1\n        digits = flag_str[:idx]\n        flag_str = flag_str[idx:]\n\n        bitResult = int(digits, 0)\n        maskResult = int(digits, 0)\n\n    while len(flag_str) > 0 and (flag_str[0] == \"+\" or flag_str[0] == \"-\"):\n        if flag_str[0] == \"+\":\n            setFlag = True\n        elif flag_str[0] == \"-\":\n            setFlag = False\n\n        flag_str = flag_str[1:]\n\n        flag_len = 0\n        while (\n            flag_str[flag_len] != \"+\"\n            and flag_str[flag_len] != \"-\"\n            and flag_str[flag_len] != \",\"\n            and flag_str[flag_len] != \")\"\n        ):\n            flag_len += 1\n\n        flag = flag_str[0:flag_len]\n\n        if flag in flag_vals:\n            if maskResult & flag_vals[flag]:\n                raise KeyError(\n                    \"Flag %s set once, cannot be set in multiples\" % flag\n                )\n\n            if setFlag:\n                bitResult |= flag_vals[flag]\n\n            maskResult |= flag_vals[flag]\n        else:\n            raise KeyError(\"Missing flag value: %s\" % flag)\n\n        flag_str = flag_str[flag_len:]\n\n    return flag_str, bitResult, maskResult\n\n\ndef parse_ct_state(statestr):\n    ct_flags = {\n        \"new\": 1 << 0,\n        \"est\": 1 << 1,\n        \"rel\": 1 << 2,\n        \"rpl\": 1 << 3,\n        \"inv\": 1 << 4,\n        \"trk\": 1 << 5,\n        \"snat\": 1 << 6,\n        \"dnat\": 1 << 7,\n    }\n\n    return parse_flags(statestr, ct_flags)\n\n\ndef convert_mac(data):\n    def to_bytes(mac):\n        mac_split = mac.split(\":\")\n        ret = bytearray([int(i, 16) for i in mac_split])\n        return bytes(ret)\n\n    mac_str, _, mask_str = data.partition('/')\n\n    if not mac_str:\n        mac_str = mask_str = \"00:00:00:00:00:00\"\n    elif not mask_str:\n        mask_str = \"FF:FF:FF:FF:FF:FF\"\n\n    return to_bytes(mac_str), to_bytes(mask_str)\n\ndef convert_ipv4(data):\n    ip, _, mask = data.partition('/')\n\n    if not ip:\n        ip = mask = 0\n    elif not mask:\n        mask = 0xFFFFFFFF\n    elif mask.isdigit():\n        mask = (0xFFFFFFFF << (32 - int(mask))) & 0xFFFFFFFF\n\n    return int(ipaddress.IPv4Address(ip)), int(ipaddress.IPv4Address(mask))\n\ndef convert_int(size):\n    def convert_int_sized(data):\n        value, _, mask = data.partition('/')\n\n        if not value:\n            return 0, 0\n        elif not mask:\n            return int(value, 0), pow(2, size) - 1\n        else:\n            return int(value, 0), int(mask, 0)\n\n    return convert_int_sized\n\ndef parse_starts_block(block_str, scanstr, returnskipped, scanregex=False):\n    if scanregex:\n        m = re.search(scanstr, block_str)\n        if m is None:\n            if returnskipped:\n                return block_str\n            return False\n        if returnskipped:\n            block_str = block_str[len(m.group(0)) :]\n            return block_str\n        return True\n\n    if block_str.startswith(scanstr):\n        if returnskipped:\n            block_str = block_str[len(scanstr) :]\n        else:\n            return True\n\n    if returnskipped:\n        return block_str\n\n    return False\n\n\ndef parse_extract_field(\n    block_str, fieldstr, scanfmt, convert, masked=False, defval=None\n):\n    if fieldstr and not block_str.startswith(fieldstr):\n        return block_str, defval\n\n    if fieldstr:\n        str_skiplen = len(fieldstr)\n        str_skipped = block_str[str_skiplen:]\n        if str_skiplen == 0:\n            return str_skipped, defval\n    else:\n        str_skiplen = 0\n        str_skipped = block_str\n\n    m = re.search(scanfmt, str_skipped)\n    if m is None:\n        raise ValueError(\"Bad fmt string\")\n\n    data = m.group(0)\n    if convert:\n        data = convert(m.group(0))\n\n    str_skipped = str_skipped[len(m.group(0)) :]\n    if masked:\n        if str_skipped[0] == \"/\":\n            raise ValueError(\"Masking support TBD...\")\n\n    str_skipped = str_skipped[strspn(str_skipped, \", \") :]\n    return str_skipped, data\n\n\nclass ovs_dp_msg(genlmsg):\n    # include the OVS version\n    # We need a custom header rather than just being able to rely on\n    # genlmsg because fields ends up not expressing everything correctly\n    # if we use the canonical example of setting fields = (('customfield',),)\n    fields = genlmsg.fields + ((\"dpifindex\", \"I\"),)\n\n\nclass ovsactions(nla):\n    nla_flags = NLA_F_NESTED\n\n    nla_map = (\n        (\"OVS_ACTION_ATTR_UNSPEC\", \"none\"),\n        (\"OVS_ACTION_ATTR_OUTPUT\", \"uint32\"),\n        (\"OVS_ACTION_ATTR_USERSPACE\", \"userspace\"),\n        (\"OVS_ACTION_ATTR_SET\", \"none\"),\n        (\"OVS_ACTION_ATTR_PUSH_VLAN\", \"none\"),\n        (\"OVS_ACTION_ATTR_POP_VLAN\", \"flag\"),\n        (\"OVS_ACTION_ATTR_SAMPLE\", \"none\"),\n        (\"OVS_ACTION_ATTR_RECIRC\", \"uint32\"),\n        (\"OVS_ACTION_ATTR_HASH\", \"none\"),\n        (\"OVS_ACTION_ATTR_PUSH_MPLS\", \"none\"),\n        (\"OVS_ACTION_ATTR_POP_MPLS\", \"flag\"),\n        (\"OVS_ACTION_ATTR_SET_MASKED\", \"none\"),\n        (\"OVS_ACTION_ATTR_CT\", \"ctact\"),\n        (\"OVS_ACTION_ATTR_TRUNC\", \"uint32\"),\n        (\"OVS_ACTION_ATTR_PUSH_ETH\", \"none\"),\n        (\"OVS_ACTION_ATTR_POP_ETH\", \"flag\"),\n        (\"OVS_ACTION_ATTR_CT_CLEAR\", \"flag\"),\n        (\"OVS_ACTION_ATTR_PUSH_NSH\", \"none\"),\n        (\"OVS_ACTION_ATTR_POP_NSH\", \"flag\"),\n        (\"OVS_ACTION_ATTR_METER\", \"none\"),\n        (\"OVS_ACTION_ATTR_CLONE\", \"none\"),\n        (\"OVS_ACTION_ATTR_CHECK_PKT_LEN\", \"none\"),\n        (\"OVS_ACTION_ATTR_ADD_MPLS\", \"none\"),\n        (\"OVS_ACTION_ATTR_DEC_TTL\", \"none\"),\n        (\"OVS_ACTION_ATTR_DROP\", \"uint32\"),\n    )\n\n    class ctact(nla):\n        nla_flags = NLA_F_NESTED\n\n        nla_map = (\n            (\"OVS_CT_ATTR_NONE\", \"none\"),\n            (\"OVS_CT_ATTR_COMMIT\", \"flag\"),\n            (\"OVS_CT_ATTR_ZONE\", \"uint16\"),\n            (\"OVS_CT_ATTR_MARK\", \"none\"),\n            (\"OVS_CT_ATTR_LABELS\", \"none\"),\n            (\"OVS_CT_ATTR_HELPER\", \"asciiz\"),\n            (\"OVS_CT_ATTR_NAT\", \"natattr\"),\n            (\"OVS_CT_ATTR_FORCE_COMMIT\", \"flag\"),\n            (\"OVS_CT_ATTR_EVENTMASK\", \"uint32\"),\n            (\"OVS_CT_ATTR_TIMEOUT\", \"asciiz\"),\n        )\n\n        class natattr(nla):\n            nla_flags = NLA_F_NESTED\n\n            nla_map = (\n                (\"OVS_NAT_ATTR_NONE\", \"none\"),\n                (\"OVS_NAT_ATTR_SRC\", \"flag\"),\n                (\"OVS_NAT_ATTR_DST\", \"flag\"),\n                (\"OVS_NAT_ATTR_IP_MIN\", \"ipaddr\"),\n                (\"OVS_NAT_ATTR_IP_MAX\", \"ipaddr\"),\n                (\"OVS_NAT_ATTR_PROTO_MIN\", \"uint16\"),\n                (\"OVS_NAT_ATTR_PROTO_MAX\", \"uint16\"),\n                (\"OVS_NAT_ATTR_PERSISTENT\", \"flag\"),\n                (\"OVS_NAT_ATTR_PROTO_HASH\", \"flag\"),\n                (\"OVS_NAT_ATTR_PROTO_RANDOM\", \"flag\"),\n            )\n\n            def dpstr(self, more=False):\n                print_str = \"nat(\"\n\n                if self.get_attr(\"OVS_NAT_ATTR_SRC\"):\n                    print_str += \"src\"\n                elif self.get_attr(\"OVS_NAT_ATTR_DST\"):\n                    print_str += \"dst\"\n                else:\n                    print_str += \"XXX-unknown-nat\"\n\n                if self.get_attr(\"OVS_NAT_ATTR_IP_MIN\") or self.get_attr(\n                    \"OVS_NAT_ATTR_IP_MAX\"\n                ):\n                    if self.get_attr(\"OVS_NAT_ATTR_IP_MIN\"):\n                        print_str += \"=%s,\" % str(\n                            self.get_attr(\"OVS_NAT_ATTR_IP_MIN\")\n                        )\n\n                    if self.get_attr(\"OVS_NAT_ATTR_IP_MAX\"):\n                        print_str += \"-%s,\" % str(\n                            self.get_attr(\"OVS_NAT_ATTR_IP_MAX\")\n                        )\n                else:\n                    print_str += \",\"\n\n                if self.get_attr(\"OVS_NAT_ATTR_PROTO_MIN\"):\n                    print_str += \"proto_min=%d,\" % self.get_attr(\n                        \"OVS_NAT_ATTR_PROTO_MIN\"\n                    )\n\n                if self.get_attr(\"OVS_NAT_ATTR_PROTO_MAX\"):\n                    print_str += \"proto_max=%d,\" % self.get_attr(\n                        \"OVS_NAT_ATTR_PROTO_MAX\"\n                    )\n\n                if self.get_attr(\"OVS_NAT_ATTR_PERSISTENT\"):\n                    print_str += \"persistent,\"\n                if self.get_attr(\"OVS_NAT_ATTR_HASH\"):\n                    print_str += \"hash,\"\n                if self.get_attr(\"OVS_NAT_ATTR_RANDOM\"):\n                    print_str += \"random\"\n                print_str += \")\"\n                return print_str\n\n        def dpstr(self, more=False):\n            print_str = \"ct(\"\n\n            if self.get_attr(\"OVS_CT_ATTR_COMMIT\") is not None:\n                print_str += \"commit,\"\n            if self.get_attr(\"OVS_CT_ATTR_ZONE\") is not None:\n                print_str += \"zone=%d,\" % self.get_attr(\"OVS_CT_ATTR_ZONE\")\n            if self.get_attr(\"OVS_CT_ATTR_HELPER\") is not None:\n                print_str += \"helper=%s,\" % self.get_attr(\"OVS_CT_ATTR_HELPER\")\n            if self.get_attr(\"OVS_CT_ATTR_NAT\") is not None:\n                print_str += self.get_attr(\"OVS_CT_ATTR_NAT\").dpstr(more)\n                print_str += \",\"\n            if self.get_attr(\"OVS_CT_ATTR_FORCE_COMMIT\") is not None:\n                print_str += \"force,\"\n            if self.get_attr(\"OVS_CT_ATTR_EVENTMASK\") is not None:\n                print_str += \"emask=0x%X,\" % self.get_attr(\n                    \"OVS_CT_ATTR_EVENTMASK\"\n                )\n            if self.get_attr(\"OVS_CT_ATTR_TIMEOUT\") is not None:\n                print_str += \"timeout=%s\" % self.get_attr(\n                    \"OVS_CT_ATTR_TIMEOUT\"\n                )\n            print_str += \")\"\n            return print_str\n\n    class userspace(nla):\n        nla_flags = NLA_F_NESTED\n\n        nla_map = (\n            (\"OVS_USERSPACE_ATTR_UNUSED\", \"none\"),\n            (\"OVS_USERSPACE_ATTR_PID\", \"uint32\"),\n            (\"OVS_USERSPACE_ATTR_USERDATA\", \"array(uint8)\"),\n            (\"OVS_USERSPACE_ATTR_EGRESS_TUN_PORT\", \"uint32\"),\n        )\n\n        def dpstr(self, more=False):\n            print_str = \"userspace(\"\n            if self.get_attr(\"OVS_USERSPACE_ATTR_PID\") is not None:\n                print_str += \"pid=%d,\" % self.get_attr(\n                    \"OVS_USERSPACE_ATTR_PID\"\n                )\n            if self.get_attr(\"OVS_USERSPACE_ATTR_USERDATA\") is not None:\n                print_str += \"userdata=\"\n                for f in self.get_attr(\"OVS_USERSPACE_ATTR_USERDATA\"):\n                    print_str += \"%x.\" % f\n            if self.get_attr(\"OVS_USERSPACE_ATTR_TUN_PORT\") is not None:\n                print_str += \"egress_tun_port=%d\" % self.get_attr(\n                    \"OVS_USERSPACE_ATTR_TUN_PORT\"\n                )\n            print_str += \")\"\n            return print_str\n\n    def dpstr(self, more=False):\n        print_str = \"\"\n\n        for field in self.nla_map:\n            if field[1] == \"none\" or self.get_attr(field[0]) is None:\n                continue\n            if print_str != \"\":\n                print_str += \",\"\n\n            if field[1] == \"uint32\":\n                if field[0] == \"OVS_ACTION_ATTR_OUTPUT\":\n                    print_str += \"%d\" % int(self.get_attr(field[0]))\n                elif field[0] == \"OVS_ACTION_ATTR_RECIRC\":\n                    print_str += \"recirc(0x%x)\" % int(self.get_attr(field[0]))\n                elif field[0] == \"OVS_ACTION_ATTR_TRUNC\":\n                    print_str += \"trunc(%d)\" % int(self.get_attr(field[0]))\n                elif field[0] == \"OVS_ACTION_ATTR_DROP\":\n                    print_str += \"drop(%d)\" % int(self.get_attr(field[0]))\n            elif field[1] == \"flag\":\n                if field[0] == \"OVS_ACTION_ATTR_CT_CLEAR\":\n                    print_str += \"ct_clear\"\n                elif field[0] == \"OVS_ACTION_ATTR_POP_VLAN\":\n                    print_str += \"pop_vlan\"\n                elif field[0] == \"OVS_ACTION_ATTR_POP_ETH\":\n                    print_str += \"pop_eth\"\n                elif field[0] == \"OVS_ACTION_ATTR_POP_NSH\":\n                    print_str += \"pop_nsh\"\n                elif field[0] == \"OVS_ACTION_ATTR_POP_MPLS\":\n                    print_str += \"pop_mpls\"\n            else:\n                datum = self.get_attr(field[0])\n                print_str += datum.dpstr(more)\n\n        return print_str\n\n    def parse(self, actstr):\n        while len(actstr) != 0:\n            parsed = False\n            if actstr.startswith(\"drop\"):\n                # If no reason is provided, the implicit drop is used (i.e no\n                # action). If some reason is given, an explicit action is used.\n                actstr, reason = parse_extract_field(\n                    actstr,\n                    \"drop(\",\n                    \"([0-9]+)\",\n                    lambda x: int(x, 0),\n                    False,\n                    None,\n                )\n                if reason is not None:\n                    self[\"attrs\"].append([\"OVS_ACTION_ATTR_DROP\", reason])\n                    parsed = True\n                else:\n                    return\n\n            elif parse_starts_block(actstr, \"^(\\d+)\", False, True):\n                actstr, output = parse_extract_field(\n                    actstr, None, \"(\\d+)\", lambda x: int(x), False, \"0\"\n                )\n                self[\"attrs\"].append([\"OVS_ACTION_ATTR_OUTPUT\", output])\n                parsed = True\n            elif parse_starts_block(actstr, \"recirc(\", False):\n                actstr, recircid = parse_extract_field(\n                    actstr,\n                    \"recirc(\",\n                    \"([0-9a-fA-Fx]+)\",\n                    lambda x: int(x, 0),\n                    False,\n                    0,\n                )\n                self[\"attrs\"].append([\"OVS_ACTION_ATTR_RECIRC\", recircid])\n                parsed = True\n\n            parse_flat_map = (\n                (\"ct_clear\", \"OVS_ACTION_ATTR_CT_CLEAR\"),\n                (\"pop_vlan\", \"OVS_ACTION_ATTR_POP_VLAN\"),\n                (\"pop_eth\", \"OVS_ACTION_ATTR_POP_ETH\"),\n                (\"pop_nsh\", \"OVS_ACTION_ATTR_POP_NSH\"),\n            )\n\n            for flat_act in parse_flat_map:\n                if parse_starts_block(actstr, flat_act[0], False):\n                    actstr += len(flat_act[0])\n                    self[\"attrs\"].append([flat_act[1]])\n                    actstr = actstr[strspn(actstr, \", \") :]\n                    parsed = True\n\n            if parse_starts_block(actstr, \"ct(\", False):\n                actstr = actstr[len(\"ct(\") :]\n                ctact = ovsactions.ctact()\n\n                for scan in (\n                    (\"commit\", \"OVS_CT_ATTR_COMMIT\", None),\n                    (\"force_commit\", \"OVS_CT_ATTR_FORCE_COMMIT\", None),\n                    (\"zone\", \"OVS_CT_ATTR_ZONE\", int),\n                    (\"mark\", \"OVS_CT_ATTR_MARK\", int),\n                    (\"helper\", \"OVS_CT_ATTR_HELPER\", lambda x, y: str(x)),\n                    (\"timeout\", \"OVS_CT_ATTR_TIMEOUT\", lambda x, y: str(x)),\n                ):\n                    if actstr.startswith(scan[0]):\n                        actstr = actstr[len(scan[0]) :]\n                        if scan[2] is not None:\n                            if actstr[0] != \"=\":\n                                raise ValueError(\"Invalid ct attr\")\n                            actstr = actstr[1:]\n                            pos = strcspn(actstr, \",)\")\n                            datum = scan[2](actstr[:pos], 0)\n                            ctact[\"attrs\"].append([scan[1], datum])\n                            actstr = actstr[pos:]\n                        else:\n                            ctact[\"attrs\"].append([scan[1], None])\n                        actstr = actstr[strspn(actstr, \", \") :]\n                    # it seems strange to put this here, but nat() is a complex\n                    # sub-action and this lets it sit anywhere in the ct() action\n                    if actstr.startswith(\"nat\"):\n                        actstr = actstr[3:]\n                        natact = ovsactions.ctact.natattr()\n\n                        if actstr.startswith(\"(\"):\n                            t = None\n                            actstr = actstr[1:]\n                            if actstr.startswith(\"src\"):\n                                t = \"OVS_NAT_ATTR_SRC\"\n                                actstr = actstr[3:]\n                            elif actstr.startswith(\"dst\"):\n                                t = \"OVS_NAT_ATTR_DST\"\n                                actstr = actstr[3:]\n\n                            actstr, ip_block_min = parse_extract_field(\n                                actstr, \"=\", \"([0-9a-fA-F\\.]+)\", str, False\n                            )\n                            actstr, ip_block_max = parse_extract_field(\n                                actstr, \"-\", \"([0-9a-fA-F\\.]+)\", str, False\n                            )\n\n                            actstr, proto_min = parse_extract_field(\n                                actstr, \":\", \"(\\d+)\", int, False\n                            )\n                            actstr, proto_max = parse_extract_field(\n                                actstr, \"-\", \"(\\d+)\", int, False\n                            )\n\n                            if t is not None:\n                                natact[\"attrs\"].append([t, None])\n\n                                if ip_block_min is not None:\n                                    natact[\"attrs\"].append(\n                                        [\"OVS_NAT_ATTR_IP_MIN\", ip_block_min]\n                                    )\n                                if ip_block_max is not None:\n                                    natact[\"attrs\"].append(\n                                        [\"OVS_NAT_ATTR_IP_MAX\", ip_block_max]\n                                    )\n                                if proto_min is not None:\n                                    natact[\"attrs\"].append(\n                                        [\"OVS_NAT_ATTR_PROTO_MIN\", proto_min]\n                                    )\n                                if proto_max is not None:\n                                    natact[\"attrs\"].append(\n                                        [\"OVS_NAT_ATTR_PROTO_MAX\", proto_max]\n                                    )\n\n                            for natscan in (\n                                (\"persistent\", \"OVS_NAT_ATTR_PERSISTENT\"),\n                                (\"hash\", \"OVS_NAT_ATTR_PROTO_HASH\"),\n                                (\"random\", \"OVS_NAT_ATTR_PROTO_RANDOM\"),\n                            ):\n                                if actstr.startswith(natscan[0]):\n                                    actstr = actstr[len(natscan[0]) :]\n                                    natact[\"attrs\"].append([natscan[1], None])\n                                    actstr = actstr[strspn(actstr, \", \") :]\n\n                        ctact[\"attrs\"].append([\"OVS_CT_ATTR_NAT\", natact])\n                        actstr = actstr[strspn(actstr, \",) \") :]\n\n                self[\"attrs\"].append([\"OVS_ACTION_ATTR_CT\", ctact])\n                parsed = True\n\n            actstr = actstr[strspn(actstr, \"), \") :]\n            if not parsed:\n                raise ValueError(\"Action str: '%s' not supported\" % actstr)\n\n\nclass ovskey(nla):\n    nla_flags = NLA_F_NESTED\n    nla_map = (\n        (\"OVS_KEY_ATTR_UNSPEC\", \"none\"),\n        (\"OVS_KEY_ATTR_ENCAP\", \"none\"),\n        (\"OVS_KEY_ATTR_PRIORITY\", \"uint32\"),\n        (\"OVS_KEY_ATTR_IN_PORT\", \"uint32\"),\n        (\"OVS_KEY_ATTR_ETHERNET\", \"ethaddr\"),\n        (\"OVS_KEY_ATTR_VLAN\", \"uint16\"),\n        (\"OVS_KEY_ATTR_ETHERTYPE\", \"be16\"),\n        (\"OVS_KEY_ATTR_IPV4\", \"ovs_key_ipv4\"),\n        (\"OVS_KEY_ATTR_IPV6\", \"ovs_key_ipv6\"),\n        (\"OVS_KEY_ATTR_TCP\", \"ovs_key_tcp\"),\n        (\"OVS_KEY_ATTR_UDP\", \"ovs_key_udp\"),\n        (\"OVS_KEY_ATTR_ICMP\", \"ovs_key_icmp\"),\n        (\"OVS_KEY_ATTR_ICMPV6\", \"ovs_key_icmpv6\"),\n        (\"OVS_KEY_ATTR_ARP\", \"ovs_key_arp\"),\n        (\"OVS_KEY_ATTR_ND\", \"ovs_key_nd\"),\n        (\"OVS_KEY_ATTR_SKB_MARK\", \"uint32\"),\n        (\"OVS_KEY_ATTR_TUNNEL\", \"none\"),\n        (\"OVS_KEY_ATTR_SCTP\", \"ovs_key_sctp\"),\n        (\"OVS_KEY_ATTR_TCP_FLAGS\", \"be16\"),\n        (\"OVS_KEY_ATTR_DP_HASH\", \"uint32\"),\n        (\"OVS_KEY_ATTR_RECIRC_ID\", \"uint32\"),\n        (\"OVS_KEY_ATTR_MPLS\", \"array(ovs_key_mpls)\"),\n        (\"OVS_KEY_ATTR_CT_STATE\", \"uint32\"),\n        (\"OVS_KEY_ATTR_CT_ZONE\", \"uint16\"),\n        (\"OVS_KEY_ATTR_CT_MARK\", \"uint32\"),\n        (\"OVS_KEY_ATTR_CT_LABELS\", \"none\"),\n        (\"OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4\", \"ovs_key_ct_tuple_ipv4\"),\n        (\"OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6\", \"ovs_key_ct_tuple_ipv6\"),\n        (\"OVS_KEY_ATTR_NSH\", \"none\"),\n        (\"OVS_KEY_ATTR_PACKET_TYPE\", \"none\"),\n        (\"OVS_KEY_ATTR_ND_EXTENSIONS\", \"none\"),\n        (\"OVS_KEY_ATTR_TUNNEL_INFO\", \"none\"),\n        (\"OVS_KEY_ATTR_IPV6_EXTENSIONS\", \"none\"),\n    )\n\n    class ovs_key_proto(nla):\n        fields = (\n            (\"src\", \"!H\"),\n            (\"dst\", \"!H\"),\n        )\n\n        fields_map = (\n            (\"src\", \"src\", \"%d\", lambda x: int(x) if x else 0,\n                convert_int(16)),\n            (\"dst\", \"dst\", \"%d\", lambda x: int(x) if x else 0,\n                convert_int(16)),\n        )\n\n        def __init__(\n            self,\n            protostr,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            self.proto_str = protostr\n            nla.__init__(\n                self,\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n        def parse(self, flowstr, typeInst):\n            if not flowstr.startswith(self.proto_str):\n                return None, None\n\n            k = typeInst()\n            m = typeInst()\n\n            flowstr = flowstr[len(self.proto_str) :]\n            if flowstr.startswith(\"(\"):\n                flowstr = flowstr[1:]\n\n            keybits = b\"\"\n            maskbits = b\"\"\n            for f in self.fields_map:\n                if flowstr.startswith(f[1]):\n                    # the following assumes that the field looks\n                    # something like 'field.' where '.' is a\n                    # character that we don't exactly care about.\n                    flowstr = flowstr[len(f[1]) + 1 :]\n                    splitchar = 0\n                    for c in flowstr:\n                        if c == \",\" or c == \")\":\n                            break\n                        splitchar += 1\n                    data = flowstr[:splitchar]\n                    flowstr = flowstr[splitchar:]\n                else:\n                    data = \"\"\n\n                if len(f) > 4:\n                    k[f[0]], m[f[0]] = f[4](data)\n                else:\n                    k[f[0]] = f[3](data)\n                    m[f[0]] = f[3](data)\n\n                flowstr = flowstr[strspn(flowstr, \", \") :]\n                if len(flowstr) == 0:\n                    return flowstr, k, m\n\n            flowstr = flowstr[strspn(flowstr, \"), \") :]\n\n            return flowstr, k, m\n\n        def dpstr(self, masked=None, more=False):\n            outstr = self.proto_str + \"(\"\n            first = False\n            for f in self.fields_map:\n                if first:\n                    outstr += \",\"\n                if masked is None:\n                    outstr += \"%s=\" % f[0]\n                    if isinstance(f[2], str):\n                        outstr += f[2] % self[f[1]]\n                    else:\n                        outstr += f[2](self[f[1]])\n                    first = True\n                elif more or f[3](masked[f[1]]) != 0:\n                    outstr += \"%s=\" % f[0]\n                    if isinstance(f[2], str):\n                        outstr += f[2] % self[f[1]]\n                    else:\n                        outstr += f[2](self[f[1]])\n                    outstr += \"/\"\n                    if isinstance(f[2], str):\n                        outstr += f[2] % masked[f[1]]\n                    else:\n                        outstr += f[2](masked[f[1]])\n                    first = True\n            outstr += \")\"\n            return outstr\n\n    class ethaddr(ovs_key_proto):\n        fields = (\n            (\"src\", \"!6s\"),\n            (\"dst\", \"!6s\"),\n        )\n\n        fields_map = (\n            (\n                \"src\",\n                \"src\",\n                macstr,\n                lambda x: int.from_bytes(x, \"big\"),\n                convert_mac,\n            ),\n            (\n                \"dst\",\n                \"dst\",\n                macstr,\n                lambda x: int.from_bytes(x, \"big\"),\n                convert_mac,\n            ),\n        )\n\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"eth\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_ipv4(ovs_key_proto):\n        fields = (\n            (\"src\", \"!I\"),\n            (\"dst\", \"!I\"),\n            (\"proto\", \"B\"),\n            (\"tos\", \"B\"),\n            (\"ttl\", \"B\"),\n            (\"frag\", \"B\"),\n        )\n\n        fields_map = (\n            (\n                \"src\",\n                \"src\",\n                lambda x: str(ipaddress.IPv4Address(x)),\n                int,\n                convert_ipv4,\n            ),\n            (\n                \"dst\",\n                \"dst\",\n                lambda x: str(ipaddress.IPv4Address(x)),\n                int,\n                convert_ipv4,\n            ),\n            (\"proto\", \"proto\", \"%d\", lambda x: int(x) if x else 0,\n                convert_int(8)),\n            (\"tos\", \"tos\", \"%d\", lambda x: int(x) if x else 0,\n                convert_int(8)),\n            (\"ttl\", \"ttl\", \"%d\", lambda x: int(x) if x else 0,\n                convert_int(8)),\n            (\"frag\", \"frag\", \"%d\", lambda x: int(x) if x else 0,\n                convert_int(8)),\n        )\n\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"ipv4\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_ipv6(ovs_key_proto):\n        fields = (\n            (\"src\", \"!16s\"),\n            (\"dst\", \"!16s\"),\n            (\"label\", \"!I\"),\n            (\"proto\", \"B\"),\n            (\"tclass\", \"B\"),\n            (\"hlimit\", \"B\"),\n            (\"frag\", \"B\"),\n        )\n\n        fields_map = (\n            (\n                \"src\",\n                \"src\",\n                lambda x: str(ipaddress.IPv6Address(x)),\n                lambda x: int.from_bytes(x, \"big\"),\n                lambda x: ipaddress.IPv6Address(x),\n            ),\n            (\n                \"dst\",\n                \"dst\",\n                lambda x: str(ipaddress.IPv6Address(x)),\n                lambda x: int.from_bytes(x, \"big\"),\n                lambda x: ipaddress.IPv6Address(x),\n            ),\n            (\"label\", \"label\", \"%d\", int),\n            (\"proto\", \"proto\", \"%d\", int),\n            (\"tclass\", \"tclass\", \"%d\", int),\n            (\"hlimit\", \"hlimit\", \"%d\", int),\n            (\"frag\", \"frag\", \"%d\", int),\n        )\n\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"ipv6\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_tcp(ovs_key_proto):\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"tcp\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_udp(ovs_key_proto):\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"udp\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_sctp(ovs_key_proto):\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"sctp\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_icmp(ovs_key_proto):\n        fields = (\n            (\"type\", \"B\"),\n            (\"code\", \"B\"),\n        )\n\n        fields_map = (\n            (\"type\", \"type\", \"%d\", lambda x: int(x) if x else 0),\n            (\"code\", \"code\", \"%d\", lambda x: int(x) if x else 0),\n        )\n\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"icmp\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_icmpv6(ovs_key_icmp):\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"icmpv6\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_arp(ovs_key_proto):\n        fields = (\n            (\"sip\", \"!I\"),\n            (\"tip\", \"!I\"),\n            (\"op\", \"!H\"),\n            (\"sha\", \"!6s\"),\n            (\"tha\", \"!6s\"),\n            (\"pad\", \"xx\"),\n        )\n\n        fields_map = (\n            (\n                \"sip\",\n                \"sip\",\n                lambda x: str(ipaddress.IPv4Address(x)),\n                int,\n                convert_ipv4,\n            ),\n            (\n                \"tip\",\n                \"tip\",\n                lambda x: str(ipaddress.IPv4Address(x)),\n                int,\n                convert_ipv4,\n            ),\n            (\"op\", \"op\", \"%d\", lambda x: int(x) if x else 0),\n            (\n                \"sha\",\n                \"sha\",\n                macstr,\n                lambda x: int.from_bytes(x, \"big\"),\n                convert_mac,\n            ),\n            (\n                \"tha\",\n                \"tha\",\n                macstr,\n                lambda x: int.from_bytes(x, \"big\"),\n                convert_mac,\n            ),\n        )\n\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"arp\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_nd(ovs_key_proto):\n        fields = (\n            (\"target\", \"!16s\"),\n            (\"sll\", \"!6s\"),\n            (\"tll\", \"!6s\"),\n        )\n\n        fields_map = (\n            (\n                \"target\",\n                \"target\",\n                lambda x: str(ipaddress.IPv6Address(x)),\n                lambda x: int.from_bytes(x, \"big\"),\n            ),\n            (\"sll\", \"sll\", macstr, lambda x: int.from_bytes(x, \"big\")),\n            (\"tll\", \"tll\", macstr, lambda x: int.from_bytes(x, \"big\")),\n        )\n\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"nd\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_ct_tuple_ipv4(ovs_key_proto):\n        fields = (\n            (\"src\", \"!I\"),\n            (\"dst\", \"!I\"),\n            (\"tp_src\", \"!H\"),\n            (\"tp_dst\", \"!H\"),\n            (\"proto\", \"B\"),\n        )\n\n        fields_map = (\n            (\n                \"src\",\n                \"src\",\n                lambda x: str(ipaddress.IPv4Address(x)),\n                int,\n                convert_ipv4,\n            ),\n            (\n                \"dst\",\n                \"dst\",\n                lambda x: str(ipaddress.IPv4Address(x)),\n                int,\n                convert_ipv4,\n            ),\n            (\"tp_src\", \"tp_src\", \"%d\", int),\n            (\"tp_dst\", \"tp_dst\", \"%d\", int),\n            (\"proto\", \"proto\", \"%d\", int),\n        )\n\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"ct_tuple4\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_ct_tuple_ipv6(nla):\n        fields = (\n            (\"src\", \"!16s\"),\n            (\"dst\", \"!16s\"),\n            (\"tp_src\", \"!H\"),\n            (\"tp_dst\", \"!H\"),\n            (\"proto\", \"B\"),\n        )\n\n        fields_map = (\n            (\n                \"src\",\n                \"src\",\n                lambda x: str(ipaddress.IPv6Address(x)),\n                lambda x: int.from_bytes(x, \"big\", convertmac),\n            ),\n            (\n                \"dst\",\n                \"dst\",\n                lambda x: str(ipaddress.IPv6Address(x)),\n                lambda x: int.from_bytes(x, \"big\"),\n            ),\n            (\"tp_src\", \"tp_src\", \"%d\", int),\n            (\"tp_dst\", \"tp_dst\", \"%d\", int),\n            (\"proto\", \"proto\", \"%d\", int),\n        )\n\n        def __init__(\n            self,\n            data=None,\n            offset=None,\n            parent=None,\n            length=None,\n            init=None,\n        ):\n            ovskey.ovs_key_proto.__init__(\n                self,\n                \"ct_tuple6\",\n                data=data,\n                offset=offset,\n                parent=parent,\n                length=length,\n                init=init,\n            )\n\n    class ovs_key_mpls(nla):\n        fields = ((\"lse\", \">I\"),)\n\n    def parse(self, flowstr, mask=None):\n        for field in (\n            (\"OVS_KEY_ATTR_PRIORITY\", \"skb_priority\", intparse),\n            (\"OVS_KEY_ATTR_SKB_MARK\", \"skb_mark\", intparse),\n            (\"OVS_KEY_ATTR_RECIRC_ID\", \"recirc_id\", intparse),\n            (\"OVS_KEY_ATTR_DP_HASH\", \"dp_hash\", intparse),\n            (\"OVS_KEY_ATTR_CT_STATE\", \"ct_state\", parse_ct_state),\n            (\"OVS_KEY_ATTR_CT_ZONE\", \"ct_zone\", intparse),\n            (\"OVS_KEY_ATTR_CT_MARK\", \"ct_mark\", intparse),\n            (\"OVS_KEY_ATTR_IN_PORT\", \"in_port\", intparse),\n            (\n                \"OVS_KEY_ATTR_ETHERNET\",\n                \"eth\",\n                ovskey.ethaddr,\n            ),\n            (\n                \"OVS_KEY_ATTR_ETHERTYPE\",\n                \"eth_type\",\n                lambda x: intparse(x, \"0xffff\"),\n            ),\n            (\n                \"OVS_KEY_ATTR_IPV4\",\n                \"ipv4\",\n                ovskey.ovs_key_ipv4,\n            ),\n            (\n                \"OVS_KEY_ATTR_IPV6\",\n                \"ipv6\",\n                ovskey.ovs_key_ipv6,\n            ),\n            (\n                \"OVS_KEY_ATTR_ARP\",\n                \"arp\",\n                ovskey.ovs_key_arp,\n            ),\n            (\n                \"OVS_KEY_ATTR_TCP\",\n                \"tcp\",\n                ovskey.ovs_key_tcp,\n            ),\n            (\n                \"OVS_KEY_ATTR_UDP\",\n                \"udp\",\n                ovskey.ovs_key_udp,\n            ),\n            (\n                \"OVS_KEY_ATTR_ICMP\",\n                \"icmp\",\n                ovskey.ovs_key_icmp,\n            ),\n            (\n                \"OVS_KEY_ATTR_TCP_FLAGS\",\n                \"tcp_flags\",\n                lambda x: parse_flags(x, None),\n            ),\n        ):\n            fld = field[1] + \"(\"\n            if not flowstr.startswith(fld):\n                continue\n\n            if not isinstance(field[2], types.FunctionType):\n                nk = field[2]()\n                flowstr, k, m = nk.parse(flowstr, field[2])\n            else:\n                flowstr = flowstr[len(fld) :]\n                flowstr, k, m = field[2](flowstr)\n\n            if m and mask is not None:\n                mask[\"attrs\"].append([field[0], m])\n            self[\"attrs\"].append([field[0], k])\n\n            flowstr = flowstr[strspn(flowstr, \"),\") :]\n\n        return flowstr\n\n    def dpstr(self, mask=None, more=False):\n        print_str = \"\"\n\n        for field in (\n            (\n                \"OVS_KEY_ATTR_PRIORITY\",\n                \"skb_priority\",\n                \"%d\",\n                lambda x: False,\n                True,\n            ),\n            (\n                \"OVS_KEY_ATTR_SKB_MARK\",\n                \"skb_mark\",\n                \"%d\",\n                lambda x: False,\n                True,\n            ),\n            (\n                \"OVS_KEY_ATTR_RECIRC_ID\",\n                \"recirc_id\",\n                \"0x%08X\",\n                lambda x: False,\n                True,\n            ),\n            (\n                \"OVS_KEY_ATTR_DP_HASH\",\n                \"dp_hash\",\n                \"0x%08X\",\n                lambda x: False,\n                True,\n            ),\n            (\n                \"OVS_KEY_ATTR_CT_STATE\",\n                \"ct_state\",\n                \"0x%04x\",\n                lambda x: False,\n                True,\n            ),\n            (\n                \"OVS_KEY_ATTR_CT_ZONE\",\n                \"ct_zone\",\n                \"0x%04x\",\n                lambda x: False,\n                True,\n            ),\n            (\n                \"OVS_KEY_ATTR_CT_MARK\",\n                \"ct_mark\",\n                \"0x%08x\",\n                lambda x: False,\n                True,\n            ),\n            (\n                \"OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4\",\n                None,\n                None,\n                False,\n                False,\n            ),\n            (\n                \"OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6\",\n                None,\n                None,\n                False,\n                False,\n            ),\n            (\n                \"OVS_KEY_ATTR_IN_PORT\",\n                \"in_port\",\n                \"%d\",\n                lambda x: True,\n                True,\n            ),\n            (\"OVS_KEY_ATTR_ETHERNET\", None, None, False, False),\n            (\n                \"OVS_KEY_ATTR_ETHERTYPE\",\n                \"eth_type\",\n                \"0x%04x\",\n                lambda x: int(x) == 0xFFFF,\n                True,\n            ),\n            (\"OVS_KEY_ATTR_IPV4\", None, None, False, False),\n            (\"OVS_KEY_ATTR_IPV6\", None, None, False, False),\n            (\"OVS_KEY_ATTR_ARP\", None, None, False, False),\n            (\"OVS_KEY_ATTR_TCP\", None, None, False, False),\n            (\n                \"OVS_KEY_ATTR_TCP_FLAGS\",\n                \"tcp_flags\",\n                \"0x%04x\",\n                lambda x: False,\n                True,\n            ),\n            (\"OVS_KEY_ATTR_UDP\", None, None, False, False),\n            (\"OVS_KEY_ATTR_SCTP\", None, None, False, False),\n            (\"OVS_KEY_ATTR_ICMP\", None, None, False, False),\n            (\"OVS_KEY_ATTR_ICMPV6\", None, None, False, False),\n            (\"OVS_KEY_ATTR_ND\", None, None, False, False),\n        ):\n            v = self.get_attr(field[0])\n            if v is not None:\n                m = None if mask is None else mask.get_attr(field[0])\n                if field[4] is False:\n                    print_str += v.dpstr(m, more)\n                    print_str += \",\"\n                else:\n                    if m is None or field[3](m):\n                        print_str += field[1] + \"(\"\n                        print_str += field[2] % v\n                        print_str += \"),\"\n                    elif more or m != 0:\n                        print_str += field[1] + \"(\"\n                        print_str += (field[2] % v) + \"/\" + (field[2] % m)\n                        print_str += \"),\"\n\n        return print_str\n\n\nclass OvsPacket(GenericNetlinkSocket):\n    OVS_PACKET_CMD_MISS = 1  # Flow table miss\n    OVS_PACKET_CMD_ACTION = 2  # USERSPACE action\n    OVS_PACKET_CMD_EXECUTE = 3  # Apply actions to packet\n\n    class ovs_packet_msg(ovs_dp_msg):\n        nla_map = (\n            (\"OVS_PACKET_ATTR_UNSPEC\", \"none\"),\n            (\"OVS_PACKET_ATTR_PACKET\", \"array(uint8)\"),\n            (\"OVS_PACKET_ATTR_KEY\", \"ovskey\"),\n            (\"OVS_PACKET_ATTR_ACTIONS\", \"ovsactions\"),\n            (\"OVS_PACKET_ATTR_USERDATA\", \"none\"),\n            (\"OVS_PACKET_ATTR_EGRESS_TUN_KEY\", \"none\"),\n            (\"OVS_PACKET_ATTR_UNUSED1\", \"none\"),\n            (\"OVS_PACKET_ATTR_UNUSED2\", \"none\"),\n            (\"OVS_PACKET_ATTR_PROBE\", \"none\"),\n            (\"OVS_PACKET_ATTR_MRU\", \"uint16\"),\n            (\"OVS_PACKET_ATTR_LEN\", \"uint32\"),\n            (\"OVS_PACKET_ATTR_HASH\", \"uint64\"),\n        )\n\n    def __init__(self):\n        GenericNetlinkSocket.__init__(self)\n        self.bind(OVS_PACKET_FAMILY, OvsPacket.ovs_packet_msg)\n\n    def upcall_handler(self, up=None):\n        print(\"listening on upcall packet handler:\", self.epid)\n        while True:\n            try:\n                msgs = self.get()\n                for msg in msgs:\n                    if not up:\n                        continue\n                    if msg[\"cmd\"] == OvsPacket.OVS_PACKET_CMD_MISS:\n                        up.miss(msg)\n                    elif msg[\"cmd\"] == OvsPacket.OVS_PACKET_CMD_ACTION:\n                        up.action(msg)\n                    elif msg[\"cmd\"] == OvsPacket.OVS_PACKET_CMD_EXECUTE:\n                        up.execute(msg)\n                    else:\n                        print(\"Unkonwn cmd: %d\" % msg[\"cmd\"])\n            except NetlinkError as ne:\n                raise ne\n\n\nclass OvsDatapath(GenericNetlinkSocket):\n    OVS_DP_F_VPORT_PIDS = 1 << 1\n    OVS_DP_F_DISPATCH_UPCALL_PER_CPU = 1 << 3\n\n    class dp_cmd_msg(ovs_dp_msg):\n        \"\"\"\n        Message class that will be used to communicate with the kernel module.\n        \"\"\"\n\n        nla_map = (\n            (\"OVS_DP_ATTR_UNSPEC\", \"none\"),\n            (\"OVS_DP_ATTR_NAME\", \"asciiz\"),\n            (\"OVS_DP_ATTR_UPCALL_PID\", \"array(uint32)\"),\n            (\"OVS_DP_ATTR_STATS\", \"dpstats\"),\n            (\"OVS_DP_ATTR_MEGAFLOW_STATS\", \"megaflowstats\"),\n            (\"OVS_DP_ATTR_USER_FEATURES\", \"uint32\"),\n            (\"OVS_DP_ATTR_PAD\", \"none\"),\n            (\"OVS_DP_ATTR_MASKS_CACHE_SIZE\", \"uint32\"),\n            (\"OVS_DP_ATTR_PER_CPU_PIDS\", \"array(uint32)\"),\n        )\n\n        class dpstats(nla):\n            fields = (\n                (\"hit\", \"=Q\"),\n                (\"missed\", \"=Q\"),\n                (\"lost\", \"=Q\"),\n                (\"flows\", \"=Q\"),\n            )\n\n        class megaflowstats(nla):\n            fields = (\n                (\"mask_hit\", \"=Q\"),\n                (\"masks\", \"=I\"),\n                (\"padding\", \"=I\"),\n                (\"cache_hits\", \"=Q\"),\n                (\"pad1\", \"=Q\"),\n            )\n\n    def __init__(self):\n        GenericNetlinkSocket.__init__(self)\n        self.bind(OVS_DATAPATH_FAMILY, OvsDatapath.dp_cmd_msg)\n\n    def info(self, dpname, ifindex=0):\n        msg = OvsDatapath.dp_cmd_msg()\n        msg[\"cmd\"] = OVS_DP_CMD_GET\n        msg[\"version\"] = OVS_DATAPATH_VERSION\n        msg[\"reserved\"] = 0\n        msg[\"dpifindex\"] = ifindex\n        msg[\"attrs\"].append([\"OVS_DP_ATTR_NAME\", dpname])\n\n        try:\n            reply = self.nlm_request(\n                msg, msg_type=self.prid, msg_flags=NLM_F_REQUEST\n            )\n            reply = reply[0]\n        except NetlinkError as ne:\n            if ne.code == errno.ENODEV:\n                reply = None\n            else:\n                raise ne\n\n        return reply\n\n    def create(\n        self, dpname, shouldUpcall=False, versionStr=None, p=OvsPacket()\n    ):\n        msg = OvsDatapath.dp_cmd_msg()\n        msg[\"cmd\"] = OVS_DP_CMD_NEW\n        if versionStr is None:\n            msg[\"version\"] = OVS_DATAPATH_VERSION\n        else:\n            msg[\"version\"] = int(versionStr.split(\":\")[0], 0)\n        msg[\"reserved\"] = 0\n        msg[\"dpifindex\"] = 0\n        msg[\"attrs\"].append([\"OVS_DP_ATTR_NAME\", dpname])\n\n        dpfeatures = 0\n        if versionStr is not None and versionStr.find(\":\") != -1:\n            dpfeatures = int(versionStr.split(\":\")[1], 0)\n        else:\n            if versionStr is None or versionStr.find(\":\") == -1:\n                dpfeatures |= OvsDatapath.OVS_DP_F_DISPATCH_UPCALL_PER_CPU\n                dpfeatures &= ~OvsDatapath.OVS_DP_F_VPORT_PIDS\n\n            nproc = multiprocessing.cpu_count()\n            procarray = []\n            for i in range(1, nproc):\n                procarray += [int(p.epid)]\n            msg[\"attrs\"].append([\"OVS_DP_ATTR_UPCALL_PID\", procarray])\n        msg[\"attrs\"].append([\"OVS_DP_ATTR_USER_FEATURES\", dpfeatures])\n        if not shouldUpcall:\n            msg[\"attrs\"].append([\"OVS_DP_ATTR_UPCALL_PID\", [0]])\n\n        try:\n            reply = self.nlm_request(\n                msg, msg_type=self.prid, msg_flags=NLM_F_REQUEST | NLM_F_ACK\n            )\n            reply = reply[0]\n        except NetlinkError as ne:\n            if ne.code == errno.EEXIST:\n                reply = None\n            else:\n                raise ne\n\n        return reply\n\n    def destroy(self, dpname):\n        msg = OvsDatapath.dp_cmd_msg()\n        msg[\"cmd\"] = OVS_DP_CMD_DEL\n        msg[\"version\"] = OVS_DATAPATH_VERSION\n        msg[\"reserved\"] = 0\n        msg[\"dpifindex\"] = 0\n        msg[\"attrs\"].append([\"OVS_DP_ATTR_NAME\", dpname])\n\n        try:\n            reply = self.nlm_request(\n                msg, msg_type=self.prid, msg_flags=NLM_F_REQUEST | NLM_F_ACK\n            )\n            reply = reply[0]\n        except NetlinkError as ne:\n            if ne.code == errno.ENODEV:\n                reply = None\n            else:\n                raise ne\n\n        return reply\n\n\nclass OvsVport(GenericNetlinkSocket):\n    OVS_VPORT_TYPE_NETDEV = 1\n    OVS_VPORT_TYPE_INTERNAL = 2\n    OVS_VPORT_TYPE_GRE = 3\n    OVS_VPORT_TYPE_VXLAN = 4\n    OVS_VPORT_TYPE_GENEVE = 5\n\n    class ovs_vport_msg(ovs_dp_msg):\n        nla_map = (\n            (\"OVS_VPORT_ATTR_UNSPEC\", \"none\"),\n            (\"OVS_VPORT_ATTR_PORT_NO\", \"uint32\"),\n            (\"OVS_VPORT_ATTR_TYPE\", \"uint32\"),\n            (\"OVS_VPORT_ATTR_NAME\", \"asciiz\"),\n            (\"OVS_VPORT_ATTR_OPTIONS\", \"none\"),\n            (\"OVS_VPORT_ATTR_UPCALL_PID\", \"array(uint32)\"),\n            (\"OVS_VPORT_ATTR_STATS\", \"vportstats\"),\n            (\"OVS_VPORT_ATTR_PAD\", \"none\"),\n            (\"OVS_VPORT_ATTR_IFINDEX\", \"uint32\"),\n            (\"OVS_VPORT_ATTR_NETNSID\", \"uint32\"),\n        )\n\n        class vportstats(nla):\n            fields = (\n                (\"rx_packets\", \"=Q\"),\n                (\"tx_packets\", \"=Q\"),\n                (\"rx_bytes\", \"=Q\"),\n                (\"tx_bytes\", \"=Q\"),\n                (\"rx_errors\", \"=Q\"),\n                (\"tx_errors\", \"=Q\"),\n                (\"rx_dropped\", \"=Q\"),\n                (\"tx_dropped\", \"=Q\"),\n            )\n\n    def type_to_str(vport_type):\n        if vport_type == OvsVport.OVS_VPORT_TYPE_NETDEV:\n            return \"netdev\"\n        elif vport_type == OvsVport.OVS_VPORT_TYPE_INTERNAL:\n            return \"internal\"\n        elif vport_type == OvsVport.OVS_VPORT_TYPE_GRE:\n            return \"gre\"\n        elif vport_type == OvsVport.OVS_VPORT_TYPE_VXLAN:\n            return \"vxlan\"\n        elif vport_type == OvsVport.OVS_VPORT_TYPE_GENEVE:\n            return \"geneve\"\n        raise ValueError(\"Unknown vport type:%d\" % vport_type)\n\n    def str_to_type(vport_type):\n        if vport_type == \"netdev\":\n            return OvsVport.OVS_VPORT_TYPE_NETDEV\n        elif vport_type == \"internal\":\n            return OvsVport.OVS_VPORT_TYPE_INTERNAL\n        elif vport_type == \"gre\":\n            return OvsVport.OVS_VPORT_TYPE_INTERNAL\n        elif vport_type == \"vxlan\":\n            return OvsVport.OVS_VPORT_TYPE_VXLAN\n        elif vport_type == \"geneve\":\n            return OvsVport.OVS_VPORT_TYPE_GENEVE\n        raise ValueError(\"Unknown vport type: '%s'\" % vport_type)\n\n    def __init__(self, packet=OvsPacket()):\n        GenericNetlinkSocket.__init__(self)\n        self.bind(OVS_VPORT_FAMILY, OvsVport.ovs_vport_msg)\n        self.upcall_packet = packet\n\n    def info(self, vport_name, dpifindex=0, portno=None):\n        msg = OvsVport.ovs_vport_msg()\n\n        msg[\"cmd\"] = OVS_VPORT_CMD_GET\n        msg[\"version\"] = OVS_DATAPATH_VERSION\n        msg[\"reserved\"] = 0\n        msg[\"dpifindex\"] = dpifindex\n\n        if portno is None:\n            msg[\"attrs\"].append([\"OVS_VPORT_ATTR_NAME\", vport_name])\n        else:\n            msg[\"attrs\"].append([\"OVS_VPORT_ATTR_PORT_NO\", portno])\n\n        try:\n            reply = self.nlm_request(\n                msg, msg_type=self.prid, msg_flags=NLM_F_REQUEST\n            )\n            reply = reply[0]\n        except NetlinkError as ne:\n            if ne.code == errno.ENODEV:\n                reply = None\n            else:\n                raise ne\n        return reply\n\n    def attach(self, dpindex, vport_ifname, ptype):\n        msg = OvsVport.ovs_vport_msg()\n\n        msg[\"cmd\"] = OVS_VPORT_CMD_NEW\n        msg[\"version\"] = OVS_DATAPATH_VERSION\n        msg[\"reserved\"] = 0\n        msg[\"dpifindex\"] = dpindex\n        port_type = OvsVport.str_to_type(ptype)\n\n        msg[\"attrs\"].append([\"OVS_VPORT_ATTR_TYPE\", port_type])\n        msg[\"attrs\"].append([\"OVS_VPORT_ATTR_NAME\", vport_ifname])\n        msg[\"attrs\"].append(\n            [\"OVS_VPORT_ATTR_UPCALL_PID\", [self.upcall_packet.epid]]\n        )\n\n        try:\n            reply = self.nlm_request(\n                msg, msg_type=self.prid, msg_flags=NLM_F_REQUEST | NLM_F_ACK\n            )\n            reply = reply[0]\n        except NetlinkError as ne:\n            if ne.code == errno.EEXIST:\n                reply = None\n            else:\n                raise ne\n        return reply\n\n    def reset_upcall(self, dpindex, vport_ifname, p=None):\n        msg = OvsVport.ovs_vport_msg()\n\n        msg[\"cmd\"] = OVS_VPORT_CMD_SET\n        msg[\"version\"] = OVS_DATAPATH_VERSION\n        msg[\"reserved\"] = 0\n        msg[\"dpifindex\"] = dpindex\n        msg[\"attrs\"].append([\"OVS_VPORT_ATTR_NAME\", vport_ifname])\n\n        if p == None:\n            p = self.upcall_packet\n        else:\n            self.upcall_packet = p\n\n        msg[\"attrs\"].append([\"OVS_VPORT_ATTR_UPCALL_PID\", [p.epid]])\n\n        try:\n            reply = self.nlm_request(\n                msg, msg_type=self.prid, msg_flags=NLM_F_REQUEST | NLM_F_ACK\n            )\n            reply = reply[0]\n        except NetlinkError as ne:\n            raise ne\n        return reply\n\n    def detach(self, dpindex, vport_ifname):\n        msg = OvsVport.ovs_vport_msg()\n\n        msg[\"cmd\"] = OVS_VPORT_CMD_DEL\n        msg[\"version\"] = OVS_DATAPATH_VERSION\n        msg[\"reserved\"] = 0\n        msg[\"dpifindex\"] = dpindex\n        msg[\"attrs\"].append([\"OVS_VPORT_ATTR_NAME\", vport_ifname])\n\n        try:\n            reply = self.nlm_request(\n                msg, msg_type=self.prid, msg_flags=NLM_F_REQUEST | NLM_F_ACK\n            )\n            reply = reply[0]\n        except NetlinkError as ne:\n            if ne.code == errno.ENODEV:\n                reply = None\n            else:\n                raise ne\n        return reply\n\n    def upcall_handler(self, handler=None):\n        self.upcall_packet.upcall_handler(handler)\n\n\nclass OvsFlow(GenericNetlinkSocket):\n    class ovs_flow_msg(ovs_dp_msg):\n        nla_map = (\n            (\"OVS_FLOW_ATTR_UNSPEC\", \"none\"),\n            (\"OVS_FLOW_ATTR_KEY\", \"ovskey\"),\n            (\"OVS_FLOW_ATTR_ACTIONS\", \"ovsactions\"),\n            (\"OVS_FLOW_ATTR_STATS\", \"flowstats\"),\n            (\"OVS_FLOW_ATTR_TCP_FLAGS\", \"uint8\"),\n            (\"OVS_FLOW_ATTR_USED\", \"uint64\"),\n            (\"OVS_FLOW_ATTR_CLEAR\", \"none\"),\n            (\"OVS_FLOW_ATTR_MASK\", \"ovskey\"),\n            (\"OVS_FLOW_ATTR_PROBE\", \"none\"),\n            (\"OVS_FLOW_ATTR_UFID\", \"array(uint32)\"),\n            (\"OVS_FLOW_ATTR_UFID_FLAGS\", \"uint32\"),\n        )\n\n        class flowstats(nla):\n            fields = (\n                (\"packets\", \"=Q\"),\n                (\"bytes\", \"=Q\"),\n            )\n\n        def dpstr(self, more=False):\n            ufid = self.get_attr(\"OVS_FLOW_ATTR_UFID\")\n            ufid_str = \"\"\n            if ufid is not None:\n                ufid_str = (\n                    \"ufid:{:08x}-{:04x}-{:04x}-{:04x}-{:04x}{:08x}\".format(\n                        ufid[0],\n                        ufid[1] >> 16,\n                        ufid[1] & 0xFFFF,\n                        ufid[2] >> 16,\n                        ufid[2] & 0,\n                        ufid[3],\n                    )\n                )\n\n            key_field = self.get_attr(\"OVS_FLOW_ATTR_KEY\")\n            keymsg = None\n            if key_field is not None:\n                keymsg = key_field\n\n            mask_field = self.get_attr(\"OVS_FLOW_ATTR_MASK\")\n            maskmsg = None\n            if mask_field is not None:\n                maskmsg = mask_field\n\n            acts_field = self.get_attr(\"OVS_FLOW_ATTR_ACTIONS\")\n            actsmsg = None\n            if acts_field is not None:\n                actsmsg = acts_field\n\n            print_str = \"\"\n\n            if more:\n                print_str += ufid_str + \",\"\n\n            if keymsg is not None:\n                print_str += keymsg.dpstr(maskmsg, more)\n\n            stats = self.get_attr(\"OVS_FLOW_ATTR_STATS\")\n            if stats is None:\n                print_str += \" packets:0, bytes:0,\"\n            else:\n                print_str += \" packets:%d, bytes:%d,\" % (\n                    stats[\"packets\"],\n                    stats[\"bytes\"],\n                )\n\n            used = self.get_attr(\"OVS_FLOW_ATTR_USED\")\n            print_str += \" used:\"\n            if used is None:\n                print_str += \"never,\"\n            else:\n                used_time = int(used)\n                cur_time_sec = time.clock_gettime(time.CLOCK_MONOTONIC)\n                used_time = (cur_time_sec * 1000) - used_time\n                print_str += \"{}s,\".format(used_time / 1000)\n\n            print_str += \" actions:\"\n            if (\n                actsmsg is None\n                or \"attrs\" not in actsmsg\n                or len(actsmsg[\"attrs\"]) == 0\n            ):\n                print_str += \"drop\"\n            else:\n                print_str += actsmsg.dpstr(more)\n\n            return print_str\n\n        def parse(self, flowstr, actstr, dpidx=0):\n            OVS_UFID_F_OMIT_KEY = 1 << 0\n            OVS_UFID_F_OMIT_MASK = 1 << 1\n            OVS_UFID_F_OMIT_ACTIONS = 1 << 2\n\n            self[\"cmd\"] = 0\n            self[\"version\"] = 0\n            self[\"reserved\"] = 0\n            self[\"dpifindex\"] = 0\n\n            if flowstr.startswith(\"ufid:\"):\n                count = 5\n                while flowstr[count] != \",\":\n                    count += 1\n                ufidstr = flowstr[5:count]\n                flowstr = flowstr[count + 1 :]\n            else:\n                ufidstr = str(uuid.uuid4())\n            uuidRawObj = uuid.UUID(ufidstr).fields\n\n            self[\"attrs\"].append(\n                [\n                    \"OVS_FLOW_ATTR_UFID\",\n                    [\n                        uuidRawObj[0],\n                        uuidRawObj[1] << 16 | uuidRawObj[2],\n                        uuidRawObj[3] << 24\n                        | uuidRawObj[4] << 16\n                        | uuidRawObj[5] & (0xFF << 32) >> 32,\n                        uuidRawObj[5] & (0xFFFFFFFF),\n                    ],\n                ]\n            )\n            self[\"attrs\"].append(\n                [\n                    \"OVS_FLOW_ATTR_UFID_FLAGS\",\n                    int(\n                        OVS_UFID_F_OMIT_KEY\n                        | OVS_UFID_F_OMIT_MASK\n                        | OVS_UFID_F_OMIT_ACTIONS\n                    ),\n                ]\n            )\n\n            k = ovskey()\n            m = ovskey()\n            k.parse(flowstr, m)\n            self[\"attrs\"].append([\"OVS_FLOW_ATTR_KEY\", k])\n            self[\"attrs\"].append([\"OVS_FLOW_ATTR_MASK\", m])\n\n            a = ovsactions()\n            a.parse(actstr)\n            self[\"attrs\"].append([\"OVS_FLOW_ATTR_ACTIONS\", a])\n\n    def __init__(self):\n        GenericNetlinkSocket.__init__(self)\n\n        self.bind(OVS_FLOW_FAMILY, OvsFlow.ovs_flow_msg)\n\n    def add_flow(self, dpifindex, flowmsg):\n        \"\"\"\n        Send a new flow message to the kernel.\n\n        dpifindex should be a valid datapath obtained by calling\n        into the OvsDatapath lookup\n\n        flowmsg is a flow object obtained by calling a dpparse\n        \"\"\"\n\n        flowmsg[\"cmd\"] = OVS_FLOW_CMD_NEW\n        flowmsg[\"version\"] = OVS_DATAPATH_VERSION\n        flowmsg[\"reserved\"] = 0\n        flowmsg[\"dpifindex\"] = dpifindex\n\n        try:\n            reply = self.nlm_request(\n                flowmsg,\n                msg_type=self.prid,\n                msg_flags=NLM_F_REQUEST | NLM_F_ACK,\n            )\n            reply = reply[0]\n        except NetlinkError as ne:\n            print(flowmsg)\n            raise ne\n        return reply\n\n    def del_flows(self, dpifindex):\n        \"\"\"\n        Send a del message to the kernel that will drop all flows.\n\n        dpifindex should be a valid datapath obtained by calling\n        into the OvsDatapath lookup\n        \"\"\"\n\n        flowmsg = OvsFlow.ovs_flow_msg()\n        flowmsg[\"cmd\"] = OVS_FLOW_CMD_DEL\n        flowmsg[\"version\"] = OVS_DATAPATH_VERSION\n        flowmsg[\"reserved\"] = 0\n        flowmsg[\"dpifindex\"] = dpifindex\n\n        try:\n            reply = self.nlm_request(\n                flowmsg,\n                msg_type=self.prid,\n                msg_flags=NLM_F_REQUEST | NLM_F_ACK,\n            )\n            reply = reply[0]\n        except NetlinkError as ne:\n            print(flowmsg)\n            raise ne\n        return reply\n\n    def dump(self, dpifindex, flowspec=None):\n        \"\"\"\n        Returns a list of messages containing flows.\n\n        dpifindex should be a valid datapath obtained by calling\n        into the OvsDatapath lookup\n\n        flowpsec is a string which represents a flow in the dpctl\n        format.\n        \"\"\"\n        msg = OvsFlow.ovs_flow_msg()\n\n        msg[\"cmd\"] = OVS_FLOW_CMD_GET\n        msg[\"version\"] = OVS_DATAPATH_VERSION\n        msg[\"reserved\"] = 0\n        msg[\"dpifindex\"] = dpifindex\n\n        msg_flags = NLM_F_REQUEST | NLM_F_ACK\n        if flowspec is None:\n            msg_flags |= NLM_F_DUMP\n        rep = None\n\n        try:\n            rep = self.nlm_request(\n                msg,\n                msg_type=self.prid,\n                msg_flags=msg_flags,\n            )\n        except NetlinkError as ne:\n            raise ne\n        return rep\n\n    def miss(self, packetmsg):\n        seq = packetmsg[\"header\"][\"sequence_number\"]\n        keystr = \"(none)\"\n        key_field = packetmsg.get_attr(\"OVS_PACKET_ATTR_KEY\")\n        if key_field is not None:\n            keystr = key_field.dpstr(None, True)\n\n        pktdata = packetmsg.get_attr(\"OVS_PACKET_ATTR_PACKET\")\n        pktpres = \"yes\" if pktdata is not None else \"no\"\n\n        print(\"MISS upcall[%d/%s]: %s\" % (seq, pktpres, keystr), flush=True)\n\n    def execute(self, packetmsg):\n        print(\"userspace execute command\")\n\n    def action(self, packetmsg):\n        print(\"userspace action command\")\n\n\ndef print_ovsdp_full(dp_lookup_rep, ifindex, ndb=NDB(), vpl=OvsVport()):\n    dp_name = dp_lookup_rep.get_attr(\"OVS_DP_ATTR_NAME\")\n    base_stats = dp_lookup_rep.get_attr(\"OVS_DP_ATTR_STATS\")\n    megaflow_stats = dp_lookup_rep.get_attr(\"OVS_DP_ATTR_MEGAFLOW_STATS\")\n    user_features = dp_lookup_rep.get_attr(\"OVS_DP_ATTR_USER_FEATURES\")\n    masks_cache_size = dp_lookup_rep.get_attr(\"OVS_DP_ATTR_MASKS_CACHE_SIZE\")\n\n    print(\"%s:\" % dp_name)\n    print(\n        \"  lookups: hit:%d missed:%d lost:%d\"\n        % (base_stats[\"hit\"], base_stats[\"missed\"], base_stats[\"lost\"])\n    )\n    print(\"  flows:%d\" % base_stats[\"flows\"])\n    pkts = base_stats[\"hit\"] + base_stats[\"missed\"]\n    avg = (megaflow_stats[\"mask_hit\"] / pkts) if pkts != 0 else 0.0\n    print(\n        \"  masks: hit:%d total:%d hit/pkt:%f\"\n        % (megaflow_stats[\"mask_hit\"], megaflow_stats[\"masks\"], avg)\n    )\n    print(\"  caches:\")\n    print(\"    masks-cache: size:%d\" % masks_cache_size)\n\n    if user_features is not None:\n        print(\"  features: 0x%X\" % user_features)\n\n    # port print out\n    for iface in ndb.interfaces:\n        rep = vpl.info(iface.ifname, ifindex)\n        if rep is not None:\n            print(\n                \"  port %d: %s (%s)\"\n                % (\n                    rep.get_attr(\"OVS_VPORT_ATTR_PORT_NO\"),\n                    rep.get_attr(\"OVS_VPORT_ATTR_NAME\"),\n                    OvsVport.type_to_str(rep.get_attr(\"OVS_VPORT_ATTR_TYPE\")),\n                )\n            )\n\n\ndef main(argv):\n    nlmsg_atoms.ovskey = ovskey\n    nlmsg_atoms.ovsactions = ovsactions\n\n    # version check for pyroute2\n    prverscheck = pyroute2.__version__.split(\".\")\n    if int(prverscheck[0]) == 0 and int(prverscheck[1]) < 6:\n        print(\"Need to upgrade the python pyroute2 package to >= 0.6.\")\n        sys.exit(0)\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"count\",\n        help=\"Increment 'verbose' output counter.\",\n        default=0,\n    )\n    subparsers = parser.add_subparsers()\n\n    showdpcmd = subparsers.add_parser(\"show\")\n    showdpcmd.add_argument(\n        \"showdp\", metavar=\"N\", type=str, nargs=\"?\", help=\"Datapath Name\"\n    )\n\n    adddpcmd = subparsers.add_parser(\"add-dp\")\n    adddpcmd.add_argument(\"adddp\", help=\"Datapath Name\")\n    adddpcmd.add_argument(\n        \"-u\",\n        \"--upcall\",\n        action=\"store_true\",\n        help=\"Leave open a reader for upcalls\",\n    )\n    adddpcmd.add_argument(\n        \"-V\",\n        \"--versioning\",\n        required=False,\n        help=\"Specify a custom version / feature string\",\n    )\n\n    deldpcmd = subparsers.add_parser(\"del-dp\")\n    deldpcmd.add_argument(\"deldp\", help=\"Datapath Name\")\n\n    addifcmd = subparsers.add_parser(\"add-if\")\n    addifcmd.add_argument(\"dpname\", help=\"Datapath Name\")\n    addifcmd.add_argument(\"addif\", help=\"Interface name for adding\")\n    addifcmd.add_argument(\n        \"-u\",\n        \"--upcall\",\n        action=\"store_true\",\n        help=\"Leave open a reader for upcalls\",\n    )\n    addifcmd.add_argument(\n        \"-t\",\n        \"--ptype\",\n        type=str,\n        default=\"netdev\",\n        choices=[\"netdev\", \"internal\"],\n        help=\"Interface type (default netdev)\",\n    )\n    delifcmd = subparsers.add_parser(\"del-if\")\n    delifcmd.add_argument(\"dpname\", help=\"Datapath Name\")\n    delifcmd.add_argument(\"delif\", help=\"Interface name for adding\")\n\n    dumpflcmd = subparsers.add_parser(\"dump-flows\")\n    dumpflcmd.add_argument(\"dumpdp\", help=\"Datapath Name\")\n\n    addflcmd = subparsers.add_parser(\"add-flow\")\n    addflcmd.add_argument(\"flbr\", help=\"Datapath name\")\n    addflcmd.add_argument(\"flow\", help=\"Flow specification\")\n    addflcmd.add_argument(\"acts\", help=\"Flow actions\")\n\n    delfscmd = subparsers.add_parser(\"del-flows\")\n    delfscmd.add_argument(\"flsbr\", help=\"Datapath name\")\n\n    args = parser.parse_args()\n\n    if args.verbose > 0:\n        if args.verbose > 1:\n            logging.basicConfig(level=logging.DEBUG)\n\n    ovspk = OvsPacket()\n    ovsdp = OvsDatapath()\n    ovsvp = OvsVport(ovspk)\n    ovsflow = OvsFlow()\n    ndb = NDB()\n\n    if hasattr(args, \"showdp\"):\n        found = False\n        for iface in ndb.interfaces:\n            rep = None\n            if args.showdp is None:\n                rep = ovsdp.info(iface.ifname, 0)\n            elif args.showdp == iface.ifname:\n                rep = ovsdp.info(iface.ifname, 0)\n\n            if rep is not None:\n                found = True\n                print_ovsdp_full(rep, iface.index, ndb, ovsvp)\n\n        if not found:\n            msg = \"No DP found\"\n            if args.showdp is not None:\n                msg += \":'%s'\" % args.showdp\n            print(msg)\n    elif hasattr(args, \"adddp\"):\n        rep = ovsdp.create(args.adddp, args.upcall, args.versioning, ovspk)\n        if rep is None:\n            print(\"DP '%s' already exists\" % args.adddp)\n        else:\n            print(\"DP '%s' added\" % args.adddp)\n        if args.upcall:\n            ovspk.upcall_handler(ovsflow)\n    elif hasattr(args, \"deldp\"):\n        ovsdp.destroy(args.deldp)\n    elif hasattr(args, \"addif\"):\n        rep = ovsdp.info(args.dpname, 0)\n        if rep is None:\n            print(\"DP '%s' not found.\" % args.dpname)\n            return 1\n        dpindex = rep[\"dpifindex\"]\n        rep = ovsvp.attach(rep[\"dpifindex\"], args.addif, args.ptype)\n        msg = \"vport '%s'\" % args.addif\n        if rep and rep[\"header\"][\"error\"] is None:\n            msg += \" added.\"\n        else:\n            msg += \" failed to add.\"\n        if args.upcall:\n            if rep is None:\n                rep = ovsvp.reset_upcall(dpindex, args.addif, ovspk)\n            ovsvp.upcall_handler(ovsflow)\n    elif hasattr(args, \"delif\"):\n        rep = ovsdp.info(args.dpname, 0)\n        if rep is None:\n            print(\"DP '%s' not found.\" % args.dpname)\n            return 1\n        rep = ovsvp.detach(rep[\"dpifindex\"], args.delif)\n        msg = \"vport '%s'\" % args.delif\n        if rep and rep[\"header\"][\"error\"] is None:\n            msg += \" removed.\"\n        else:\n            msg += \" failed to remove.\"\n    elif hasattr(args, \"dumpdp\"):\n        rep = ovsdp.info(args.dumpdp, 0)\n        if rep is None:\n            print(\"DP '%s' not found.\" % args.dumpdp)\n            return 1\n        rep = ovsflow.dump(rep[\"dpifindex\"])\n        for flow in rep:\n            print(flow.dpstr(True if args.verbose > 0 else False))\n    elif hasattr(args, \"flbr\"):\n        rep = ovsdp.info(args.flbr, 0)\n        if rep is None:\n            print(\"DP '%s' not found.\" % args.flbr)\n            return 1\n        flow = OvsFlow.ovs_flow_msg()\n        flow.parse(args.flow, args.acts, rep[\"dpifindex\"])\n        ovsflow.add_flow(rep[\"dpifindex\"], flow)\n    elif hasattr(args, \"flsbr\"):\n        rep = ovsdp.info(args.flsbr, 0)\n        if rep is None:\n            print(\"DP '%s' not found.\" % args.flsbr)\n        ovsflow.del_flows(rep[\"dpifindex\"])\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}