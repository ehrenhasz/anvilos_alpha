{
  "module_name": "tcp_inq.c",
  "hash_id": "aec9762268bf67173f6194833f04016eb8226698468ba061da8aed450cd2df39",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/tcp_inq.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n\n#include <error.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#ifndef TCP_INQ\n#define TCP_INQ 36\n#endif\n\n#ifndef TCP_CM_INQ\n#define TCP_CM_INQ TCP_INQ\n#endif\n\n#define BUF_SIZE 8192\n#define CMSG_SIZE 32\n\nstatic int family = AF_INET6;\nstatic socklen_t addr_len = sizeof(struct sockaddr_in6);\nstatic int port = 4974;\n\nstatic void setup_loopback_addr(int family, struct sockaddr_storage *sockaddr)\n{\n\tstruct sockaddr_in6 *addr6 = (void *) sockaddr;\n\tstruct sockaddr_in *addr4 = (void *) sockaddr;\n\n\tswitch (family) {\n\tcase PF_INET:\n\t\tmemset(addr4, 0, sizeof(*addr4));\n\t\taddr4->sin_family = AF_INET;\n\t\taddr4->sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\taddr4->sin_port = htons(port);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tmemset(addr6, 0, sizeof(*addr6));\n\t\taddr6->sin6_family = AF_INET6;\n\t\taddr6->sin6_addr = in6addr_loopback;\n\t\taddr6->sin6_port = htons(port);\n\t\tbreak;\n\tdefault:\n\t\terror(1, 0, \"illegal family\");\n\t}\n}\n\nvoid *start_server(void *arg)\n{\n\tint server_fd = (int)(unsigned long)arg;\n\tstruct sockaddr_in addr;\n\tsocklen_t addrlen = sizeof(addr);\n\tchar *buf;\n\tint fd;\n\tint r;\n\n\tbuf = malloc(BUF_SIZE);\n\n\tfor (;;) {\n\t\tfd = accept(server_fd, (struct sockaddr *)&addr, &addrlen);\n\t\tif (fd == -1) {\n\t\t\tperror(\"accept\");\n\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tr = send(fd, buf, BUF_SIZE, 0);\n\t\t} while (r < 0 && errno == EINTR);\n\t\tif (r < 0)\n\t\t\tperror(\"send\");\n\t\tif (r != BUF_SIZE)\n\t\t\tfprintf(stderr, \"can only send %d bytes\\n\", r);\n\t\t \n\t\tsleep(1);\n\t\tclose(fd);\n\t}\n\n\tfree(buf);\n\tclose(server_fd);\n\tpthread_exit(0);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct sockaddr_storage listen_addr, addr;\n\tint c, one = 1, inq = -1;\n\tpthread_t server_thread;\n\tchar cmsgbuf[CMSG_SIZE];\n\tstruct iovec iov[1];\n\tstruct cmsghdr *cm;\n\tstruct msghdr msg;\n\tint server_fd, fd;\n\tchar *buf;\n\n\twhile ((c = getopt(argc, argv, \"46p:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '4':\n\t\t\tfamily = PF_INET;\n\t\t\taddr_len = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tfamily = PF_INET6;\n\t\t\taddr_len = sizeof(struct sockaddr_in6);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tport = atoi(optarg);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tserver_fd = socket(family, SOCK_STREAM, 0);\n\tif (server_fd < 0)\n\t\terror(1, errno, \"server socket\");\n\tsetup_loopback_addr(family, &listen_addr);\n\tif (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR,\n\t\t       &one, sizeof(one)) != 0)\n\t\terror(1, errno, \"setsockopt(SO_REUSEADDR)\");\n\tif (bind(server_fd, (const struct sockaddr *)&listen_addr,\n\t\t addr_len) == -1)\n\t\terror(1, errno, \"bind\");\n\tif (listen(server_fd, 128) == -1)\n\t\terror(1, errno, \"listen\");\n\tif (pthread_create(&server_thread, NULL, start_server,\n\t\t\t   (void *)(unsigned long)server_fd) != 0)\n\t\terror(1, errno, \"pthread_create\");\n\n\tfd = socket(family, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\terror(1, errno, \"client socket\");\n\tsetup_loopback_addr(family, &addr);\n\tif (connect(fd, (const struct sockaddr *)&addr, addr_len) == -1)\n\t\terror(1, errno, \"connect\");\n\tif (setsockopt(fd, SOL_TCP, TCP_INQ, &one, sizeof(one)) != 0)\n\t\terror(1, errno, \"setsockopt(TCP_INQ)\");\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_iov = iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = cmsgbuf;\n\tmsg.msg_controllen = sizeof(cmsgbuf);\n\tmsg.msg_flags = 0;\n\n\tbuf = malloc(BUF_SIZE);\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = BUF_SIZE / 2;\n\n\tif (recvmsg(fd, &msg, 0) != iov[0].iov_len)\n\t\terror(1, errno, \"recvmsg\");\n\tif (msg.msg_flags & MSG_CTRUNC)\n\t\terror(1, 0, \"control message is truncated\");\n\n\tfor (cm = CMSG_FIRSTHDR(&msg); cm; cm = CMSG_NXTHDR(&msg, cm))\n\t\tif (cm->cmsg_level == SOL_TCP && cm->cmsg_type == TCP_CM_INQ)\n\t\t\tinq = *((int *) CMSG_DATA(cm));\n\n\tif (inq != BUF_SIZE - iov[0].iov_len) {\n\t\tfprintf(stderr, \"unexpected inq: %d\\n\", inq);\n\t\texit(1);\n\t}\n\n\tprintf(\"PASSED\\n\");\n\tfree(buf);\n\tclose(fd);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}