{
  "module_name": "tun.c",
  "hash_id": "2aa03e86fbd4dfa84527711af46dca47bc1811ddb251a1e872ed777d9098eb27",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/tun.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <linux/if.h>\n#include <linux/if_tun.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n\n#include \"../kselftest_harness.h\"\n\nstatic int tun_attach(int fd, char *dev)\n{\n\tstruct ifreq ifr;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrcpy(ifr.ifr_name, dev);\n\tifr.ifr_flags = IFF_ATTACH_QUEUE;\n\n\treturn ioctl(fd, TUNSETQUEUE, (void *) &ifr);\n}\n\nstatic int tun_detach(int fd, char *dev)\n{\n\tstruct ifreq ifr;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrcpy(ifr.ifr_name, dev);\n\tifr.ifr_flags = IFF_DETACH_QUEUE;\n\n\treturn ioctl(fd, TUNSETQUEUE, (void *) &ifr);\n}\n\nstatic int tun_alloc(char *dev)\n{\n\tstruct ifreq ifr;\n\tint fd, err;\n\n\tfd = open(\"/dev/net/tun\", O_RDWR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"can't open tun: %s\\n\", strerror(errno));\n\t\treturn fd;\n\t}\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrcpy(ifr.ifr_name, dev);\n\tifr.ifr_flags = IFF_TAP | IFF_NAPI | IFF_MULTI_QUEUE;\n\n\terr = ioctl(fd, TUNSETIFF, (void *) &ifr);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"can't TUNSETIFF: %s\\n\", strerror(errno));\n\t\tclose(fd);\n\t\treturn err;\n\t}\n\tstrcpy(dev, ifr.ifr_name);\n\treturn fd;\n}\n\nstatic int tun_delete(char *dev)\n{\n\tstruct {\n\t\tstruct nlmsghdr  nh;\n\t\tstruct ifinfomsg ifm;\n\t\tunsigned char    data[64];\n\t} req;\n\tstruct rtattr *rta;\n\tint ret, rtnl;\n\n\trtnl = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\n\tif (rtnl < 0) {\n\t\tfprintf(stderr, \"can't open rtnl: %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.nh.nlmsg_len = NLMSG_ALIGN(NLMSG_LENGTH(sizeof(req.ifm)));\n\treq.nh.nlmsg_flags = NLM_F_REQUEST;\n\treq.nh.nlmsg_type = RTM_DELLINK;\n\n\treq.ifm.ifi_family = AF_UNSPEC;\n\n\trta = (struct rtattr *)(((char *)&req) + NLMSG_ALIGN(req.nh.nlmsg_len));\n\trta->rta_type = IFLA_IFNAME;\n\trta->rta_len = RTA_LENGTH(IFNAMSIZ);\n\treq.nh.nlmsg_len += rta->rta_len;\n\tmemcpy(RTA_DATA(rta), dev, IFNAMSIZ);\n\n\tret = send(rtnl, &req, req.nh.nlmsg_len, 0);\n\tif (ret < 0)\n\t\tfprintf(stderr, \"can't send: %s\\n\", strerror(errno));\n\tret = (unsigned int)ret != req.nh.nlmsg_len;\n\n\tclose(rtnl);\n\treturn ret;\n}\n\nFIXTURE(tun)\n{\n\tchar ifname[IFNAMSIZ];\n\tint fd, fd2;\n};\n\nFIXTURE_SETUP(tun)\n{\n\tmemset(self->ifname, 0, sizeof(self->ifname));\n\n\tself->fd = tun_alloc(self->ifname);\n\tASSERT_GE(self->fd, 0);\n\n\tself->fd2 = tun_alloc(self->ifname);\n\tASSERT_GE(self->fd2, 0);\n}\n\nFIXTURE_TEARDOWN(tun)\n{\n\tif (self->fd >= 0)\n\t\tclose(self->fd);\n\tif (self->fd2 >= 0)\n\t\tclose(self->fd2);\n}\n\nTEST_F(tun, delete_detach_close) {\n\tEXPECT_EQ(tun_delete(self->ifname), 0);\n\tEXPECT_EQ(tun_detach(self->fd, self->ifname), -1);\n\tEXPECT_EQ(errno, 22);\n}\n\nTEST_F(tun, detach_delete_close) {\n\tEXPECT_EQ(tun_detach(self->fd, self->ifname), 0);\n\tEXPECT_EQ(tun_delete(self->ifname), 0);\n}\n\nTEST_F(tun, detach_close_delete) {\n\tEXPECT_EQ(tun_detach(self->fd, self->ifname), 0);\n\tclose(self->fd);\n\tself->fd = -1;\n\tEXPECT_EQ(tun_delete(self->ifname), 0);\n}\n\nTEST_F(tun, reattach_delete_close) {\n\tEXPECT_EQ(tun_detach(self->fd, self->ifname), 0);\n\tEXPECT_EQ(tun_attach(self->fd, self->ifname), 0);\n\tEXPECT_EQ(tun_delete(self->ifname), 0);\n}\n\nTEST_F(tun, reattach_close_delete) {\n\tEXPECT_EQ(tun_detach(self->fd, self->ifname), 0);\n\tEXPECT_EQ(tun_attach(self->fd, self->ifname), 0);\n\tclose(self->fd);\n\tself->fd = -1;\n\tEXPECT_EQ(tun_delete(self->ifname), 0);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}