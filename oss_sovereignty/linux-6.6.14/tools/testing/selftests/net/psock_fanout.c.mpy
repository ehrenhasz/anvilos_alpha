{
  "module_name": "psock_fanout.c",
  "hash_id": "db5f741939636f3a1135f1f67e33d4cdd52fea93d778808590572a62ecbceb49",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/net/psock_fanout.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\t\t \n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/unistd.h>\t \n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/if_packet.h>\n#include <net/if.h>\n#include <net/ethernet.h>\n#include <netinet/ip.h>\n#include <netinet/udp.h>\n#include <poll.h>\n#include <sched.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"psock_lib.h\"\n#include \"../kselftest.h\"\n\n#define RING_NUM_FRAMES\t\t\t20\n\nstatic uint32_t cfg_max_num_members;\n\n \nstatic int sock_fanout_open(uint16_t typeflags, uint16_t group_id)\n{\n\tstruct sockaddr_ll addr = {0};\n\tstruct fanout_args args;\n\tint fd, val, err;\n\n\tfd = socket(PF_PACKET, SOCK_RAW, 0);\n\tif (fd < 0) {\n\t\tperror(\"socket packet\");\n\t\texit(1);\n\t}\n\n\tpair_udp_setfilter(fd);\n\n\taddr.sll_family = AF_PACKET;\n\taddr.sll_protocol = htons(ETH_P_IP);\n\taddr.sll_ifindex = if_nametoindex(\"lo\");\n\tif (addr.sll_ifindex == 0) {\n\t\tperror(\"if_nametoindex\");\n\t\texit(1);\n\t}\n\tif (bind(fd, (void *) &addr, sizeof(addr))) {\n\t\tperror(\"bind packet\");\n\t\texit(1);\n\t}\n\n\tif (cfg_max_num_members) {\n\t\targs.id = group_id;\n\t\targs.type_flags = typeflags;\n\t\targs.max_num_members = cfg_max_num_members;\n\t\terr = setsockopt(fd, SOL_PACKET, PACKET_FANOUT, &args,\n\t\t\t\t sizeof(args));\n\t} else {\n\t\tval = (((int) typeflags) << 16) | group_id;\n\t\terr = setsockopt(fd, SOL_PACKET, PACKET_FANOUT, &val,\n\t\t\t\t sizeof(val));\n\t}\n\tif (err) {\n\t\tif (close(fd)) {\n\t\t\tperror(\"close packet\");\n\t\t\texit(1);\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic void sock_fanout_set_cbpf(int fd)\n{\n\tstruct sock_filter bpf_filter[] = {\n\t\tBPF_STMT(BPF_LD | BPF_B | BPF_ABS, 80),\t       \n\t\tBPF_STMT(BPF_RET | BPF_A, 0),\t\t       \n\t};\n\tstruct sock_fprog bpf_prog;\n\n\tbpf_prog.filter = bpf_filter;\n\tbpf_prog.len = ARRAY_SIZE(bpf_filter);\n\n\tif (setsockopt(fd, SOL_PACKET, PACKET_FANOUT_DATA, &bpf_prog,\n\t\t       sizeof(bpf_prog))) {\n\t\tperror(\"fanout data cbpf\");\n\t\texit(1);\n\t}\n}\n\nstatic void sock_fanout_getopts(int fd, uint16_t *typeflags, uint16_t *group_id)\n{\n\tint sockopt;\n\tsocklen_t sockopt_len = sizeof(sockopt);\n\n\tif (getsockopt(fd, SOL_PACKET, PACKET_FANOUT,\n\t\t       &sockopt, &sockopt_len)) {\n\t\tperror(\"failed to getsockopt\");\n\t\texit(1);\n\t}\n\t*typeflags = sockopt >> 16;\n\t*group_id = sockopt & 0xfffff;\n}\n\nstatic void sock_fanout_set_ebpf(int fd)\n{\n\tstatic char log_buf[65536];\n\n\tconst int len_off = __builtin_offsetof(struct __sk_buff, len);\n\tstruct bpf_insn prog[] = {\n\t\t{ BPF_ALU64 | BPF_MOV | BPF_X,   6, 1, 0, 0 },\n\t\t{ BPF_LDX   | BPF_W   | BPF_MEM, 0, 6, len_off, 0 },\n\t\t{ BPF_JMP   | BPF_JGE | BPF_K,   0, 0, 1, DATA_LEN },\n\t\t{ BPF_JMP   | BPF_JA  | BPF_K,   0, 0, 4, 0 },\n\t\t{ BPF_LD    | BPF_B   | BPF_ABS, 0, 0, 0, 0x50 },\n\t\t{ BPF_JMP   | BPF_JEQ | BPF_K,   0, 0, 2, DATA_CHAR },\n\t\t{ BPF_JMP   | BPF_JEQ | BPF_K,   0, 0, 1, DATA_CHAR_1 },\n\t\t{ BPF_ALU   | BPF_MOV | BPF_K,   0, 0, 0, 0 },\n\t\t{ BPF_JMP   | BPF_EXIT,          0, 0, 0, 0 }\n\t};\n\tunion bpf_attr attr;\n\tint pfd;\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;\n\tattr.insns = (unsigned long) prog;\n\tattr.insn_cnt = ARRAY_SIZE(prog);\n\tattr.license = (unsigned long) \"GPL\";\n\tattr.log_buf = (unsigned long) log_buf,\n\tattr.log_size = sizeof(log_buf),\n\tattr.log_level = 1,\n\n\tpfd = syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));\n\tif (pfd < 0) {\n\t\tperror(\"bpf\");\n\t\tfprintf(stderr, \"bpf verifier:\\n%s\\n\", log_buf);\n\t\texit(1);\n\t}\n\n\tif (setsockopt(fd, SOL_PACKET, PACKET_FANOUT_DATA, &pfd, sizeof(pfd))) {\n\t\tperror(\"fanout data ebpf\");\n\t\texit(1);\n\t}\n\n\tif (close(pfd)) {\n\t\tperror(\"close ebpf\");\n\t\texit(1);\n\t}\n}\n\nstatic char *sock_fanout_open_ring(int fd)\n{\n\tstruct tpacket_req req = {\n\t\t.tp_block_size = getpagesize(),\n\t\t.tp_frame_size = getpagesize(),\n\t\t.tp_block_nr   = RING_NUM_FRAMES,\n\t\t.tp_frame_nr   = RING_NUM_FRAMES,\n\t};\n\tchar *ring;\n\tint val = TPACKET_V2;\n\n\tif (setsockopt(fd, SOL_PACKET, PACKET_VERSION, (void *) &val,\n\t\t       sizeof(val))) {\n\t\tperror(\"packetsock ring setsockopt version\");\n\t\texit(1);\n\t}\n\tif (setsockopt(fd, SOL_PACKET, PACKET_RX_RING, (void *) &req,\n\t\t       sizeof(req))) {\n\t\tperror(\"packetsock ring setsockopt\");\n\t\texit(1);\n\t}\n\n\tring = mmap(0, req.tp_block_size * req.tp_block_nr,\n\t\t    PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (ring == MAP_FAILED) {\n\t\tperror(\"packetsock ring mmap\");\n\t\texit(1);\n\t}\n\n\treturn ring;\n}\n\nstatic int sock_fanout_read_ring(int fd, void *ring)\n{\n\tstruct tpacket2_hdr *header = ring;\n\tint count = 0;\n\n\twhile (count < RING_NUM_FRAMES && header->tp_status & TP_STATUS_USER) {\n\t\tcount++;\n\t\theader = ring + (count * getpagesize());\n\t}\n\n\treturn count;\n}\n\nstatic int sock_fanout_read(int fds[], char *rings[], const int expect[])\n{\n\tint ret[2];\n\n\tret[0] = sock_fanout_read_ring(fds[0], rings[0]);\n\tret[1] = sock_fanout_read_ring(fds[1], rings[1]);\n\n\tfprintf(stderr, \"info: count=%d,%d, expect=%d,%d\\n\",\n\t\t\tret[0], ret[1], expect[0], expect[1]);\n\n\tif ((!(ret[0] == expect[0] && ret[1] == expect[1])) &&\n\t    (!(ret[0] == expect[1] && ret[1] == expect[0]))) {\n\t\tfprintf(stderr, \"warning: incorrect queue lengths\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void test_control_single(void)\n{\n\tfprintf(stderr, \"test: control single socket\\n\");\n\n\tif (sock_fanout_open(PACKET_FANOUT_ROLLOVER |\n\t\t\t       PACKET_FANOUT_FLAG_ROLLOVER, 0) != -1) {\n\t\tfprintf(stderr, \"ERROR: opened socket with dual rollover\\n\");\n\t\texit(1);\n\t}\n}\n\n \nstatic void test_control_group(void)\n{\n\tint fds[2];\n\n\tfprintf(stderr, \"test: control multiple sockets\\n\");\n\n\tfds[0] = sock_fanout_open(PACKET_FANOUT_HASH, 0);\n\tif (fds[0] == -1) {\n\t\tfprintf(stderr, \"ERROR: failed to open HASH socket\\n\");\n\t\texit(1);\n\t}\n\tif (sock_fanout_open(PACKET_FANOUT_HASH |\n\t\t\t       PACKET_FANOUT_FLAG_DEFRAG, 0) != -1) {\n\t\tfprintf(stderr, \"ERROR: joined group with wrong flag defrag\\n\");\n\t\texit(1);\n\t}\n\tif (sock_fanout_open(PACKET_FANOUT_HASH |\n\t\t\t       PACKET_FANOUT_FLAG_ROLLOVER, 0) != -1) {\n\t\tfprintf(stderr, \"ERROR: joined group with wrong flag ro\\n\");\n\t\texit(1);\n\t}\n\tif (sock_fanout_open(PACKET_FANOUT_CPU, 0) != -1) {\n\t\tfprintf(stderr, \"ERROR: joined group with wrong mode\\n\");\n\t\texit(1);\n\t}\n\tfds[1] = sock_fanout_open(PACKET_FANOUT_HASH, 0);\n\tif (fds[1] == -1) {\n\t\tfprintf(stderr, \"ERROR: failed to join group\\n\");\n\t\texit(1);\n\t}\n\tif (close(fds[1]) || close(fds[0])) {\n\t\tfprintf(stderr, \"ERROR: closing sockets\\n\");\n\t\texit(1);\n\t}\n}\n\n \nstatic void test_control_group_max_num_members(void)\n{\n\tint fds[3];\n\n\tfprintf(stderr, \"test: control multiple sockets, max_num_members\\n\");\n\n\t \n\tcfg_max_num_members = (1 << 16) + 1;\n\tif (sock_fanout_open(PACKET_FANOUT_HASH, 0) != -1) {\n\t\tfprintf(stderr, \"ERROR: max_num_members > PACKET_FANOUT_MAX\\n\");\n\t\texit(1);\n\t}\n\n\tcfg_max_num_members = 256;\n\tfds[0] = sock_fanout_open(PACKET_FANOUT_HASH, 0);\n\tif (fds[0] == -1) {\n\t\tfprintf(stderr, \"ERROR: failed open\\n\");\n\t\texit(1);\n\t}\n\n\t \n\tcfg_max_num_members = 257;\n\tif (sock_fanout_open(PACKET_FANOUT_HASH, 0) != -1) {\n\t\tfprintf(stderr, \"ERROR: set different max_num_members\\n\");\n\t\texit(1);\n\t}\n\n\t \n\tcfg_max_num_members = 256;\n\tfds[1] = sock_fanout_open(PACKET_FANOUT_HASH, 0);\n\tif (fds[1] == -1) {\n\t\tfprintf(stderr, \"ERROR: failed to join group\\n\");\n\t\texit(1);\n\t}\n\n\t \n\tcfg_max_num_members = 0;\n\tfds[2] = sock_fanout_open(PACKET_FANOUT_HASH, 0);\n\tif (fds[2] == -1) {\n\t\tfprintf(stderr, \"ERROR: failed to join group\\n\");\n\t\texit(1);\n\t}\n\n\tif (close(fds[2]) || close(fds[1]) || close(fds[0])) {\n\t\tfprintf(stderr, \"ERROR: closing sockets\\n\");\n\t\texit(1);\n\t}\n}\n\n \nstatic void test_unique_fanout_group_ids(void)\n{\n\tint fds[3];\n\tuint16_t typeflags, first_group_id, second_group_id;\n\n\tfprintf(stderr, \"test: unique ids\\n\");\n\n\tfds[0] = sock_fanout_open(PACKET_FANOUT_HASH |\n\t\t\t\t  PACKET_FANOUT_FLAG_UNIQUEID, 0);\n\tif (fds[0] == -1) {\n\t\tfprintf(stderr, \"ERROR: failed to create a unique id group.\\n\");\n\t\texit(1);\n\t}\n\n\tsock_fanout_getopts(fds[0], &typeflags, &first_group_id);\n\tif (typeflags != PACKET_FANOUT_HASH) {\n\t\tfprintf(stderr, \"ERROR: unexpected typeflags %x\\n\", typeflags);\n\t\texit(1);\n\t}\n\n\tif (sock_fanout_open(PACKET_FANOUT_CPU, first_group_id) != -1) {\n\t\tfprintf(stderr, \"ERROR: joined group with wrong type.\\n\");\n\t\texit(1);\n\t}\n\n\tfds[1] = sock_fanout_open(PACKET_FANOUT_HASH, first_group_id);\n\tif (fds[1] == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: failed to join previously created group.\\n\");\n\t\texit(1);\n\t}\n\n\tfds[2] = sock_fanout_open(PACKET_FANOUT_HASH |\n\t\t\t\t  PACKET_FANOUT_FLAG_UNIQUEID, 0);\n\tif (fds[2] == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: failed to create a second unique id group.\\n\");\n\t\texit(1);\n\t}\n\n\tsock_fanout_getopts(fds[2], &typeflags, &second_group_id);\n\tif (sock_fanout_open(PACKET_FANOUT_HASH | PACKET_FANOUT_FLAG_UNIQUEID,\n\t\t\t     second_group_id) != -1) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: specified a group id when requesting unique id\\n\");\n\t\texit(1);\n\t}\n\n\tif (close(fds[0]) || close(fds[1]) || close(fds[2])) {\n\t\tfprintf(stderr, \"ERROR: closing sockets\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic int test_datapath(uint16_t typeflags, int port_off,\n\t\t\t const int expect1[], const int expect2[])\n{\n\tconst int expect0[] = { 0, 0 };\n\tchar *rings[2];\n\tuint8_t type = typeflags & 0xFF;\n\tint fds[2], fds_udp[2][2], ret;\n\n\tfprintf(stderr, \"\\ntest: datapath 0x%hx ports %hu,%hu\\n\",\n\t\ttypeflags, (uint16_t)PORT_BASE,\n\t\t(uint16_t)(PORT_BASE + port_off));\n\n\tfds[0] = sock_fanout_open(typeflags, 0);\n\tfds[1] = sock_fanout_open(typeflags, 0);\n\tif (fds[0] == -1 || fds[1] == -1) {\n\t\tfprintf(stderr, \"ERROR: failed open\\n\");\n\t\texit(1);\n\t}\n\tif (type == PACKET_FANOUT_CBPF)\n\t\tsock_fanout_set_cbpf(fds[0]);\n\telse if (type == PACKET_FANOUT_EBPF)\n\t\tsock_fanout_set_ebpf(fds[0]);\n\n\trings[0] = sock_fanout_open_ring(fds[0]);\n\trings[1] = sock_fanout_open_ring(fds[1]);\n\tpair_udp_open(fds_udp[0], PORT_BASE);\n\tpair_udp_open(fds_udp[1], PORT_BASE + port_off);\n\tsock_fanout_read(fds, rings, expect0);\n\n\t \n\tpair_udp_send(fds_udp[0], 15);\n\tpair_udp_send_char(fds_udp[1], 5, DATA_CHAR_1);\n\tret = sock_fanout_read(fds, rings, expect1);\n\n\t \n\tpair_udp_send_char(fds_udp[0], 15, DATA_CHAR_1);\n\t \n\tret |= sock_fanout_read(fds, rings, expect2);\n\n\tif (munmap(rings[1], RING_NUM_FRAMES * getpagesize()) ||\n\t    munmap(rings[0], RING_NUM_FRAMES * getpagesize())) {\n\t\tfprintf(stderr, \"close rings\\n\");\n\t\texit(1);\n\t}\n\tif (close(fds_udp[1][1]) || close(fds_udp[1][0]) ||\n\t    close(fds_udp[0][1]) || close(fds_udp[0][0]) ||\n\t    close(fds[1]) || close(fds[0])) {\n\t\tfprintf(stderr, \"close datapath\\n\");\n\t\texit(1);\n\t}\n\n\treturn ret;\n}\n\nstatic int set_cpuaffinity(int cpuid)\n{\n\tcpu_set_t mask;\n\n\tCPU_ZERO(&mask);\n\tCPU_SET(cpuid, &mask);\n\tif (sched_setaffinity(0, sizeof(mask), &mask)) {\n\t\tif (errno != EINVAL) {\n\t\t\tfprintf(stderr, \"setaffinity %d\\n\", cpuid);\n\t\t\texit(1);\n\t\t}\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tconst int expect_hash[2][2]\t= { { 15, 5 },  { 20, 5 } };\n\tconst int expect_hash_rb[2][2]\t= { { 15, 5 },  { 20, 15 } };\n\tconst int expect_lb[2][2]\t= { { 10, 10 }, { 18, 17 } };\n\tconst int expect_rb[2][2]\t= { { 15, 5 },  { 20, 15 } };\n\tconst int expect_cpu0[2][2]\t= { { 20, 0 },  { 20, 0 } };\n\tconst int expect_cpu1[2][2]\t= { { 0, 20 },  { 0, 20 } };\n\tconst int expect_bpf[2][2]\t= { { 15, 5 },  { 15, 20 } };\n\tconst int expect_uniqueid[2][2] = { { 20, 20},  { 20, 20 } };\n\tint port_off = 2, tries = 20, ret;\n\n\ttest_control_single();\n\ttest_control_group();\n\ttest_control_group_max_num_members();\n\ttest_unique_fanout_group_ids();\n\n\t \n\tcfg_max_num_members = 1 << 16;\n\t \n\tret = test_datapath(PACKET_FANOUT_HASH, port_off,\n\t\t\t    expect_hash[0], expect_hash[1]);\n\twhile (ret) {\n\t\tfprintf(stderr, \"info: trying alternate ports (%d)\\n\", tries);\n\t\tret = test_datapath(PACKET_FANOUT_HASH, ++port_off,\n\t\t\t\t    expect_hash[0], expect_hash[1]);\n\t\tif (!--tries) {\n\t\t\tfprintf(stderr, \"too many collisions\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tret |= test_datapath(PACKET_FANOUT_HASH | PACKET_FANOUT_FLAG_ROLLOVER,\n\t\t\t     port_off, expect_hash_rb[0], expect_hash_rb[1]);\n\tret |= test_datapath(PACKET_FANOUT_LB,\n\t\t\t     port_off, expect_lb[0], expect_lb[1]);\n\tret |= test_datapath(PACKET_FANOUT_ROLLOVER,\n\t\t\t     port_off, expect_rb[0], expect_rb[1]);\n\n\tret |= test_datapath(PACKET_FANOUT_CBPF,\n\t\t\t     port_off, expect_bpf[0], expect_bpf[1]);\n\tret |= test_datapath(PACKET_FANOUT_EBPF,\n\t\t\t     port_off, expect_bpf[0], expect_bpf[1]);\n\n\tset_cpuaffinity(0);\n\tret |= test_datapath(PACKET_FANOUT_CPU, port_off,\n\t\t\t     expect_cpu0[0], expect_cpu0[1]);\n\tif (!set_cpuaffinity(1))\n\t\t \n\t\tret |= test_datapath(PACKET_FANOUT_CPU, port_off,\n\t\t\t\t     expect_cpu1[0], expect_cpu1[1]);\n\n\tret |= test_datapath(PACKET_FANOUT_FLAG_UNIQUEID, port_off,\n\t\t\t     expect_uniqueid[0], expect_uniqueid[1]);\n\n\tif (ret)\n\t\treturn 1;\n\n\tprintf(\"OK. All tests passed\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}