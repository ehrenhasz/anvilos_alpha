{
  "module_name": "adi-test.c",
  "hash_id": "f8d7f32d92789a6b1d666bf48e865e97d29eb7adb6f9a5ec55ccb19c9e865088",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sparc64/drivers/adi-test.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"../../kselftest.h\"\n\n#define DEBUG_LEVEL_1_BIT\t(0x0001)\n#define DEBUG_LEVEL_2_BIT\t(0x0002)\n#define DEBUG_LEVEL_3_BIT\t(0x0004)\n#define DEBUG_LEVEL_4_BIT\t(0x0008)\n#define DEBUG_TIMING_BIT\t(0x1000)\n\n \n#define DEBUG 0x0001\n\n#define DEBUG_PRINT_L1(...)\tdebug_print(DEBUG_LEVEL_1_BIT, __VA_ARGS__)\n#define DEBUG_PRINT_L2(...)\tdebug_print(DEBUG_LEVEL_2_BIT, __VA_ARGS__)\n#define DEBUG_PRINT_L3(...)\tdebug_print(DEBUG_LEVEL_3_BIT, __VA_ARGS__)\n#define DEBUG_PRINT_L4(...)\tdebug_print(DEBUG_LEVEL_4_BIT, __VA_ARGS__)\n#define DEBUG_PRINT_T(...)\tdebug_print(DEBUG_TIMING_BIT, __VA_ARGS__)\n\nstatic void debug_print(int level, const char *s, ...)\n{\n\tva_list args;\n\n\tva_start(args, s);\n\n\tif (DEBUG & level)\n\t\tvfprintf(stdout, s, args);\n\tva_end(args);\n}\n\n#ifndef min\n#define min(x, y) ((x) < (y) ? x : y)\n#endif\n\n#define RETURN_FROM_TEST(_ret) \\\n\tdo { \\\n\t\tDEBUG_PRINT_L1( \\\n\t\t\t\"\\tTest %s returned %d\\n\", __func__, _ret); \\\n\t\treturn _ret; \\\n\t} while (0)\n\n#define ADI_BLKSZ\t64\n#define ADI_MAX_VERSION\t15\n\n#define TEST_STEP_FAILURE(_ret) \\\n\tdo { \\\n\t\tfprintf(stderr, \"\\tTest step failure: %d at %s:%d\\n\", \\\n\t\t\t_ret, __func__, __LINE__); \\\n\t\tgoto out; \\\n\t} while (0)\n\n#define RDTICK(_x) \\\n\tasm volatile(\" rd %%tick, %0\\n\" : \"=r\" (_x))\n\nstatic int random_version(void)\n{\n\tlong tick;\n\n\tRDTICK(tick);\n\n\treturn tick % (ADI_MAX_VERSION + 1);\n}\n\n#define MAX_RANGES_SUPPORTED\t5\nstatic const char system_ram_str[] = \"System RAM\\n\";\nstatic int range_count;\nstatic unsigned long long int start_addr[MAX_RANGES_SUPPORTED];\nstatic unsigned long long int   end_addr[MAX_RANGES_SUPPORTED];\n\nstruct stats {\n\tchar\t\tname[16];\n\tunsigned long\ttotal;\n\tunsigned long\tcount;\n\tunsigned long\tbytes;\n};\n\nstatic struct stats read_stats = {\n\t.name = \"read\", .total = 0, .count = 0, .bytes = 0};\nstatic struct stats pread_stats = {\n\t.name = \"pread\", .total = 0, .count = 0, .bytes = 0};\nstatic struct stats write_stats = {\n\t.name = \"write\", .total = 0, .count = 0, .bytes = 0};\nstatic struct stats pwrite_stats = {\n\t.name = \"pwrite\", .total = 0, .count = 0, .bytes = 0};\nstatic struct stats seek_stats = {\n\t.name = \"seek\", .total = 0, .count = 0, .bytes = 0};\n\nstatic void update_stats(struct stats * const ustats,\n\t\t\t unsigned long measurement, unsigned long bytes)\n{\n\tustats->total += measurement;\n\tustats->bytes += bytes;\n\tustats->count++;\n}\n\nstatic void print_ustats(const struct stats * const ustats)\n{\n\tDEBUG_PRINT_L1(\"%s\\t%7d\\t%7.0f\\t%7.0f\\n\",\n\t\t       ustats->name, ustats->count,\n\t\t       (float)ustats->total / (float)ustats->count,\n\t\t       (float)ustats->bytes / (float)ustats->count);\n}\n\nstatic void print_stats(void)\n{\n\tDEBUG_PRINT_L1(\"\\nSyscall\\tCall\\tAvgTime\\tAvgSize\\n\"\n\t\t       \"\\tCount\\t(ticks)\\t(bytes)\\n\"\n\t\t       \"-------------------------------\\n\");\n\n\tprint_ustats(&read_stats);\n\tprint_ustats(&pread_stats);\n\tprint_ustats(&write_stats);\n\tprint_ustats(&pwrite_stats);\n\tprint_ustats(&seek_stats);\n}\n\nstatic int build_memory_map(void)\n{\n\tchar line[256];\n\tFILE *fp;\n\tint i;\n\n\trange_count = 0;\n\n\tfp = fopen(\"/proc/iomem\", \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"/proc/iomem: error %d: %s\\n\",\n\t\t\terrno, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\twhile (fgets(line, sizeof(line), fp) != 0) {\n\t\tif (strstr(line, system_ram_str)) {\n\t\t\tchar *dash, *end_ptr;\n\n\t\t\t \n\t\t\tdash = strstr(line, \"-\");\n\t\t\tdash[0] = 0x20;\n\n\t\t\tstart_addr[range_count] = strtoull(line, &end_ptr, 16);\n\t\t\tend_addr[range_count] = strtoull(end_ptr, NULL, 16);\n\t\t\trange_count++;\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\tDEBUG_PRINT_L1(\"RAM Ranges\\n\");\n\tfor (i = 0; i < range_count; i++)\n\t\tDEBUG_PRINT_L1(\"\\trange %d: 0x%llx\\t- 0x%llx\\n\",\n\t\t\t       i, start_addr[i], end_addr[i]);\n\n\tif (range_count == 0) {\n\t\tfprintf(stderr, \"No valid address ranges found.  Error.\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_adi(int fd, unsigned char *buf, int buf_sz)\n{\n\tint ret, bytes_read = 0;\n\tlong start, end, elapsed_time = 0;\n\n\tdo {\n\t\tRDTICK(start);\n\t\tret = read(fd, buf + bytes_read, buf_sz - bytes_read);\n\t\tRDTICK(end);\n\t\tif (ret < 0)\n\t\t\treturn -errno;\n\n\t\telapsed_time += end - start;\n\t\tupdate_stats(&read_stats, elapsed_time, buf_sz);\n\t\tbytes_read += ret;\n\n\t} while (bytes_read < buf_sz);\n\n\tDEBUG_PRINT_T(\"\\tread elapsed timed = %ld\\n\", elapsed_time);\n\tDEBUG_PRINT_L3(\"\\tRead  %d bytes\\n\", bytes_read);\n\n\treturn bytes_read;\n}\n\nstatic int pread_adi(int fd, unsigned char *buf,\n\t\t     int buf_sz, unsigned long offset)\n{\n\tint ret, i, bytes_read = 0;\n\tunsigned long cur_offset;\n\tlong start, end, elapsed_time = 0;\n\n\tcur_offset = offset;\n\tdo {\n\t\tRDTICK(start);\n\t\tret = pread(fd, buf + bytes_read, buf_sz - bytes_read,\n\t\t\t    cur_offset);\n\t\tRDTICK(end);\n\t\tif (ret < 0)\n\t\t\treturn -errno;\n\n\t\telapsed_time += end - start;\n\t\tupdate_stats(&pread_stats, elapsed_time, buf_sz);\n\t\tbytes_read += ret;\n\t\tcur_offset += ret;\n\n\t} while (bytes_read < buf_sz);\n\n\tDEBUG_PRINT_T(\"\\tpread elapsed timed = %ld\\n\", elapsed_time);\n\tDEBUG_PRINT_L3(\"\\tRead  %d bytes starting at offset 0x%lx\\n\",\n\t\t       bytes_read, offset);\n\tfor (i = 0; i < bytes_read; i++)\n\t\tDEBUG_PRINT_L4(\"\\t\\t0x%lx\\t%d\\n\", offset + i, buf[i]);\n\n\treturn bytes_read;\n}\n\nstatic int write_adi(int fd, const unsigned char * const buf, int buf_sz)\n{\n\tint ret, bytes_written = 0;\n\tlong start, end, elapsed_time = 0;\n\n\tdo {\n\t\tRDTICK(start);\n\t\tret = write(fd, buf + bytes_written, buf_sz - bytes_written);\n\t\tRDTICK(end);\n\t\tif (ret < 0)\n\t\t\treturn -errno;\n\n\t\telapsed_time += (end - start);\n\t\tupdate_stats(&write_stats, elapsed_time, buf_sz);\n\t\tbytes_written += ret;\n\t} while (bytes_written < buf_sz);\n\n\tDEBUG_PRINT_T(\"\\twrite elapsed timed = %ld\\n\", elapsed_time);\n\tDEBUG_PRINT_L3(\"\\tWrote %d of %d bytes\\n\", bytes_written, buf_sz);\n\n\treturn bytes_written;\n}\n\nstatic int pwrite_adi(int fd, const unsigned char * const buf,\n\t\t      int buf_sz, unsigned long offset)\n{\n\tint ret, bytes_written = 0;\n\tunsigned long cur_offset;\n\tlong start, end, elapsed_time = 0;\n\n\tcur_offset = offset;\n\n\tdo {\n\t\tRDTICK(start);\n\t\tret = pwrite(fd, buf + bytes_written,\n\t\t\t     buf_sz - bytes_written, cur_offset);\n\t\tRDTICK(end);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"pwrite(): error %d: %s\\n\",\n\t\t\t\terrno, strerror(errno));\n\t\t\treturn -errno;\n\t\t}\n\n\t\telapsed_time += (end - start);\n\t\tupdate_stats(&pwrite_stats, elapsed_time, buf_sz);\n\t\tbytes_written += ret;\n\t\tcur_offset += ret;\n\n\t} while (bytes_written < buf_sz);\n\n\tDEBUG_PRINT_T(\"\\tpwrite elapsed timed = %ld\\n\", elapsed_time);\n\tDEBUG_PRINT_L3(\"\\tWrote %d of %d bytes starting at address 0x%lx\\n\",\n\t\t       bytes_written, buf_sz, offset);\n\n\treturn bytes_written;\n}\n\nstatic off_t seek_adi(int fd, off_t offset, int whence)\n{\n\tlong start, end;\n\toff_t ret;\n\n\tRDTICK(start);\n\tret = lseek(fd, offset, whence);\n\tRDTICK(end);\n\tDEBUG_PRINT_L2(\"\\tlseek ret = 0x%llx\\n\", ret);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tDEBUG_PRINT_T(\"\\tlseek elapsed timed = %ld\\n\", end - start);\n\tupdate_stats(&seek_stats, end - start, 0);\n\nout:\n\t(void)lseek(fd, 0, SEEK_END);\n\treturn ret;\n}\n\nstatic int test0_prpw_aligned_1byte(int fd)\n{\n\t \n\tunsigned long paddr =\n\t\t(end_addr[range_count - 1] - 0x1000) & ~(ADI_BLKSZ - 1);\n\tunsigned char version[1], expected_version;\n\tloff_t offset;\n\tint ret;\n\n\tversion[0] = random_version();\n\texpected_version = version[0];\n\n\toffset = paddr / ADI_BLKSZ;\n\n\tret = pwrite_adi(fd, version, sizeof(version), offset);\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tret = pread_adi(fd, version, sizeof(version), offset);\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tif (expected_version != version[0]) {\n\t\tDEBUG_PRINT_L2(\"\\tExpected version %d but read version %d\\n\",\n\t\t\t       expected_version, version[0]);\n\t\tTEST_STEP_FAILURE(-expected_version);\n\t}\n\n\tret = 0;\nout:\n\tRETURN_FROM_TEST(ret);\n}\n\n#define TEST1_VERSION_SZ\t4096\nstatic int test1_prpw_aligned_4096bytes(int fd)\n{\n\t \n\tunsigned long paddr =\n\t\t(end_addr[range_count - 1] - 0x6000) & ~(ADI_BLKSZ - 1);\n\tunsigned char version[TEST1_VERSION_SZ],\n\t\texpected_version[TEST1_VERSION_SZ];\n\tloff_t offset;\n\tint ret, i;\n\n\tfor (i = 0; i < TEST1_VERSION_SZ; i++) {\n\t\tversion[i] = random_version();\n\t\texpected_version[i] = version[i];\n\t}\n\n\toffset = paddr / ADI_BLKSZ;\n\n\tret = pwrite_adi(fd, version, sizeof(version), offset);\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tret = pread_adi(fd, version, sizeof(version), offset);\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tfor (i = 0; i < TEST1_VERSION_SZ; i++) {\n\t\tif (expected_version[i] != version[i]) {\n\t\t\tDEBUG_PRINT_L2(\n\t\t\t\t\"\\tExpected version %d but read version %d\\n\",\n\t\t\t\texpected_version, version[0]);\n\t\t\tTEST_STEP_FAILURE(-expected_version[i]);\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tRETURN_FROM_TEST(ret);\n}\n\n#define TEST2_VERSION_SZ\t10327\nstatic int test2_prpw_aligned_10327bytes(int fd)\n{\n\t \n\tunsigned long paddr =\n\t\t(start_addr[0] + 0x6000) & ~(ADI_BLKSZ - 1);\n\tunsigned char version[TEST2_VERSION_SZ],\n\t\texpected_version[TEST2_VERSION_SZ];\n\tloff_t offset;\n\tint ret, i;\n\n\tfor (i = 0; i < TEST2_VERSION_SZ; i++) {\n\t\tversion[i] = random_version();\n\t\texpected_version[i] = version[i];\n\t}\n\n\toffset = paddr / ADI_BLKSZ;\n\n\tret = pwrite_adi(fd, version, sizeof(version), offset);\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tret = pread_adi(fd, version, sizeof(version), offset);\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tfor (i = 0; i < TEST2_VERSION_SZ; i++) {\n\t\tif (expected_version[i] != version[i]) {\n\t\t\tDEBUG_PRINT_L2(\n\t\t\t\t\"\\tExpected version %d but read version %d\\n\",\n\t\t\t\texpected_version, version[0]);\n\t\t\tTEST_STEP_FAILURE(-expected_version[i]);\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tRETURN_FROM_TEST(ret);\n}\n\n#define TEST3_VERSION_SZ\t12541\nstatic int test3_prpw_unaligned_12541bytes(int fd)\n{\n\t \n\tunsigned long paddr =\n\t\t((start_addr[0] + 0xC000) & ~(ADI_BLKSZ - 1)) + 17;\n\tunsigned char version[TEST3_VERSION_SZ],\n\t\texpected_version[TEST3_VERSION_SZ];\n\tloff_t offset;\n\tint ret, i;\n\n\tfor (i = 0; i < TEST3_VERSION_SZ; i++) {\n\t\tversion[i] = random_version();\n\t\texpected_version[i] = version[i];\n\t}\n\n\toffset = paddr / ADI_BLKSZ;\n\n\tret = pwrite_adi(fd, version, sizeof(version), offset);\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tret = pread_adi(fd, version, sizeof(version), offset);\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tfor (i = 0; i < TEST3_VERSION_SZ; i++) {\n\t\tif (expected_version[i] != version[i]) {\n\t\t\tDEBUG_PRINT_L2(\n\t\t\t\t\"\\tExpected version %d but read version %d\\n\",\n\t\t\t\texpected_version, version[0]);\n\t\t\tTEST_STEP_FAILURE(-expected_version[i]);\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tRETURN_FROM_TEST(ret);\n}\n\nstatic int test4_lseek(int fd)\n{\n#define\tOFFSET_ADD\t(0x100)\n#define OFFSET_SUBTRACT\t(0xFFFFFFF000000000)\n\n\toff_t offset_out, offset_in;\n\tint ret;\n\n\n\toffset_in = 0x123456789abcdef0;\n\toffset_out = seek_adi(fd, offset_in, SEEK_SET);\n\tif (offset_out != offset_in) {\n\t\tret = -1;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\t \n\toffset_out = seek_adi(fd, offset_in, SEEK_SET);\n\tif (offset_out < 0 && errno == EINVAL)\n\t\tDEBUG_PRINT_L2(\n\t\t\t\"\\tSEEK_SET failed as designed. Not an error\\n\");\n\telse {\n\t\tret = -2;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\toffset_out = seek_adi(fd, 0, SEEK_CUR);\n\tif (offset_out != offset_in) {\n\t\tret = -3;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\toffset_out = seek_adi(fd, OFFSET_ADD, SEEK_CUR);\n\tif (offset_out != (offset_in + OFFSET_ADD)) {\n\t\tret = -4;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\toffset_out = seek_adi(fd, OFFSET_SUBTRACT, SEEK_CUR);\n\tif (offset_out != (offset_in + OFFSET_ADD + OFFSET_SUBTRACT)) {\n\t\tret = -5;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\tret = 0;\nout:\n\tRETURN_FROM_TEST(ret);\n}\n\nstatic int test5_rw_aligned_1byte(int fd)\n{\n\t \n\tunsigned long paddr =\n\t\t(end_addr[range_count - 1] - 0xF000) & ~(ADI_BLKSZ - 1);\n\tunsigned char version, expected_version;\n\tloff_t offset;\n\toff_t oret;\n\tint ret;\n\n\toffset = paddr / ADI_BLKSZ;\n\tversion = expected_version = random_version();\n\n\toret = seek_adi(fd, offset, SEEK_SET);\n\tif (oret != offset) {\n\t\tret = -1;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\tret = write_adi(fd, &version, sizeof(version));\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\toret = seek_adi(fd, offset, SEEK_SET);\n\tif (oret != offset) {\n\t\tret = -1;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\tret = read_adi(fd, &version, sizeof(version));\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tif (expected_version != version) {\n\t\tDEBUG_PRINT_L2(\"\\tExpected version %d but read version %d\\n\",\n\t\t\t       expected_version, version);\n\t\tTEST_STEP_FAILURE(-expected_version);\n\t}\n\n\tret = 0;\nout:\n\tRETURN_FROM_TEST(ret);\n}\n\n#define TEST6_VERSION_SZ        9434\nstatic int test6_rw_aligned_9434bytes(int fd)\n{\n\t \n\tunsigned long paddr =\n\t\t(end_addr[range_count - 1] - 0x5F000) & ~(ADI_BLKSZ - 1);\n\tunsigned char version[TEST6_VERSION_SZ],\n\t\t      expected_version[TEST6_VERSION_SZ];\n\tloff_t offset;\n\toff_t oret;\n\tint ret, i;\n\n\toffset = paddr / ADI_BLKSZ;\n\tfor (i = 0; i < TEST6_VERSION_SZ; i++)\n\t\tversion[i] = expected_version[i] = random_version();\n\n\toret = seek_adi(fd, offset, SEEK_SET);\n\tif (oret != offset) {\n\t\tret = -1;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\tret = write_adi(fd, version, sizeof(version));\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tmemset(version, 0, TEST6_VERSION_SZ);\n\n\toret = seek_adi(fd, offset, SEEK_SET);\n\tif (oret != offset) {\n\t\tret = -1;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\tret = read_adi(fd, version, sizeof(version));\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tfor (i = 0; i < TEST6_VERSION_SZ; i++) {\n\t\tif (expected_version[i] != version[i]) {\n\t\t\tDEBUG_PRINT_L2(\n\t\t\t\t\"\\tExpected version %d but read version %d\\n\",\n\t\t\t\texpected_version[i], version[i]);\n\t\t\tTEST_STEP_FAILURE(-expected_version[i]);\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tRETURN_FROM_TEST(ret);\n}\n\n#define TEST7_VERSION_SZ        14963\nstatic int test7_rw_aligned_14963bytes(int fd)\n{\n\t \n\tunsigned long paddr =\n\t  ((start_addr[range_count - 1] + 0xF000) & ~(ADI_BLKSZ - 1)) + 39;\n\tunsigned char version[TEST7_VERSION_SZ],\n\t\t      expected_version[TEST7_VERSION_SZ];\n\tloff_t offset;\n\toff_t oret;\n\tint ret, i;\n\n\toffset = paddr / ADI_BLKSZ;\n\tfor (i = 0; i < TEST7_VERSION_SZ; i++) {\n\t\tversion[i] = random_version();\n\t\texpected_version[i] = version[i];\n\t}\n\n\toret = seek_adi(fd, offset, SEEK_SET);\n\tif (oret != offset) {\n\t\tret = -1;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\tret = write_adi(fd, version, sizeof(version));\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tmemset(version, 0, TEST7_VERSION_SZ);\n\n\toret = seek_adi(fd, offset, SEEK_SET);\n\tif (oret != offset) {\n\t\tret = -1;\n\t\tTEST_STEP_FAILURE(ret);\n\t}\n\n\tret = read_adi(fd, version, sizeof(version));\n\tif (ret != sizeof(version))\n\t\tTEST_STEP_FAILURE(ret);\n\n\tfor (i = 0; i < TEST7_VERSION_SZ; i++) {\n\t\tif (expected_version[i] != version[i]) {\n\t\t\tDEBUG_PRINT_L2(\n\t\t\t\t\"\\tExpected version %d but read version %d\\n\",\n\t\t\t\texpected_version[i], version[i]);\n\t\t\tTEST_STEP_FAILURE(-expected_version[i]);\n\t\t}\n\n\t\tpaddr += ADI_BLKSZ;\n\t}\n\n\tret = 0;\nout:\n\tRETURN_FROM_TEST(ret);\n}\n\nstatic int (*tests[])(int fd) = {\n\ttest0_prpw_aligned_1byte,\n\ttest1_prpw_aligned_4096bytes,\n\ttest2_prpw_aligned_10327bytes,\n\ttest3_prpw_unaligned_12541bytes,\n\ttest4_lseek,\n\ttest5_rw_aligned_1byte,\n\ttest6_rw_aligned_9434bytes,\n\ttest7_rw_aligned_14963bytes,\n};\n#define TEST_COUNT\tARRAY_SIZE(tests)\n\nint main(int argc, char *argv[])\n{\n\tint fd, ret, test;\n\n\tret = build_memory_map();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfd = open(\"/dev/adi\", O_RDWR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"open: error %d: %s\\n\",\n\t\t\terrno, strerror(errno));\n\t\treturn -errno;\n\t}\n\n\tfor (test = 0; test < TEST_COUNT; test++) {\n\t\tDEBUG_PRINT_L1(\"Running test #%d\\n\", test);\n\n\t\tret = (*tests[test])(fd);\n\t\tif (ret != 0)\n\t\t\tksft_test_result_fail(\"Test #%d failed: error %d\\n\",\n\t\t\t\t\t      test, ret);\n\t\telse\n\t\t\tksft_test_result_pass(\"Test #%d passed\\n\", test);\n\t}\n\n\tprint_stats();\n\tclose(fd);\n\n\tif (ksft_get_fail_cnt() > 0)\n\t\tksft_exit_fail();\n\telse\n\t\tksft_exit_pass();\n\n\t \n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}