{
  "module_name": "vmtest.sh",
  "hash_id": "9d31fad84bf14522a460e12efc66371e6c703beab556956e49861fc7e8462607",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/hid/vmtest.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\nset -u\nset -e\n\n# This script currently only works for x86_64\nARCH=\"$(uname -m)\"\ncase \"${ARCH}\" in\nx86_64)\n\tQEMU_BINARY=qemu-system-x86_64\n\tBZIMAGE=\"arch/x86/boot/bzImage\"\n\t;;\n*)\n\techo \"Unsupported architecture\"\n\texit 1\n\t;;\nesac\nSCRIPT_DIR=\"$(dirname $(realpath $0))\"\nOUTPUT_DIR=\"$SCRIPT_DIR/results\"\nKCONFIG_REL_PATHS=(\"${SCRIPT_DIR}/config\" \"${SCRIPT_DIR}/config.common\" \"${SCRIPT_DIR}/config.${ARCH}\")\nB2C_URL=\"https://gitlab.freedesktop.org/mupuf/boot2container/-/raw/master/vm2c.py\"\nNUM_COMPILE_JOBS=\"$(nproc)\"\nLOG_FILE_BASE=\"$(date +\"hid_selftests.%Y-%m-%d_%H-%M-%S\")\"\nLOG_FILE=\"${LOG_FILE_BASE}.log\"\nEXIT_STATUS_FILE=\"${LOG_FILE_BASE}.exit_status\"\nCONTAINER_IMAGE=\"registry.freedesktop.org/libevdev/hid-tools/fedora/37:2023-02-17.1\"\n\nTARGETS=\"${TARGETS:=$(basename ${SCRIPT_DIR})}\"\nDEFAULT_COMMAND=\"pip3 install hid-tools; make -C tools/testing/selftests TARGETS=${TARGETS} run_tests\"\n\nusage()\n{\n\tcat <<EOF\nUsage: $0 [-i] [-s] [-d <output_dir>] -- [<command>]\n\n<command> is the command you would normally run when you are in\nthe source kernel direcory. e.g:\n\n\t$0 -- ./tools/testing/selftests/hid/hid_bpf\n\nIf no command is specified and a debug shell (-s) is not requested,\n\"${DEFAULT_COMMAND}\" will be run by default.\n\nIf you build your kernel using KBUILD_OUTPUT= or O= options, these\ncan be passed as environment variables to the script:\n\n  O=<kernel_build_path> $0 -- ./tools/testing/selftests/hid/hid_bpf\n\nor\n\n  KBUILD_OUTPUT=<kernel_build_path> $0 -- ./tools/testing/selftests/hid/hid_bpf\n\nOptions:\n\n\t-u)\t\tUpdate the boot2container script to a newer version.\n\t-d)\t\tUpdate the output directory (default: ${OUTPUT_DIR})\n\t-j)\t\tNumber of jobs for compilation, similar to -j in make\n\t\t\t(default: ${NUM_COMPILE_JOBS})\n\t-s)\t\tInstead of powering off the VM, start an interactive\n\t\t\tshell. If <command> is specified, the shell runs after\n\t\t\tthe command finishes executing\nEOF\n}\n\ndownload()\n{\n\tlocal file=\"$1\"\n\n\techo \"Downloading $file...\" >&2\n\tcurl -Lsf \"$file\" -o \"${@:2}\"\n}\n\nrecompile_kernel()\n{\n\tlocal kernel_checkout=\"$1\"\n\tlocal make_command=\"$2\"\n\n\tcd \"${kernel_checkout}\"\n\n\t${make_command} olddefconfig\n\t${make_command} headers\n\t${make_command}\n}\n\nupdate_selftests()\n{\n\tlocal kernel_checkout=\"$1\"\n\tlocal selftests_dir=\"${kernel_checkout}/tools/testing/selftests/hid\"\n\n\tcd \"${selftests_dir}\"\n\t${make_command}\n}\n\nrun_vm()\n{\n\tlocal run_dir=\"$1\"\n\tlocal b2c=\"$2\"\n\tlocal kernel_bzimage=\"$3\"\n\tlocal command=\"$4\"\n\tlocal post_command=\"\"\n\n\tcd \"${run_dir}\"\n\n\tif ! which \"${QEMU_BINARY}\" &> /dev/null; then\n\t\tcat <<EOF\nCould not find ${QEMU_BINARY}\nPlease install qemu or set the QEMU_BINARY environment variable.\nEOF\n\t\texit 1\n\tfi\n\n\t# alpine (used in post-container requires the PATH to have /bin\n\texport PATH=$PATH:/bin\n\n\tif [[ \"${debug_shell}\" != \"yes\" ]]\n\tthen\n\t\ttouch ${OUTPUT_DIR}/${LOG_FILE}\n\t\tcommand=\"mount bpffs -t bpf /sys/fs/bpf/; set -o pipefail ; ${command} 2>&1 | tee ${OUTPUT_DIR}/${LOG_FILE}\"\n\t\tpost_command=\"cat ${OUTPUT_DIR}/${LOG_FILE}\"\n\telse\n\t\tcommand=\"mount bpffs -t bpf /sys/fs/bpf/; ${command}\"\n\tfi\n\n\tset +e\n\t$b2c --command \"${command}\" \\\n\t     --kernel ${kernel_bzimage} \\\n\t     --workdir ${OUTPUT_DIR} \\\n\t     --image ${CONTAINER_IMAGE}\n\n\techo $? > ${OUTPUT_DIR}/${EXIT_STATUS_FILE}\n\n\tset -e\n\n\t${post_command}\n}\n\nis_rel_path()\n{\n\tlocal path=\"$1\"\n\n\t[[ ${path:0:1} != \"/\" ]]\n}\n\ndo_update_kconfig()\n{\n\tlocal kernel_checkout=\"$1\"\n\tlocal kconfig_file=\"$2\"\n\n\trm -f \"$kconfig_file\" 2> /dev/null\n\n\tfor config in \"${KCONFIG_REL_PATHS[@]}\"; do\n\t\tlocal kconfig_src=\"${config}\"\n\t\tcat \"$kconfig_src\" >> \"$kconfig_file\"\n\tdone\n}\n\nupdate_kconfig()\n{\n\tlocal kernel_checkout=\"$1\"\n\tlocal kconfig_file=\"$2\"\n\n\tif [[ -f \"${kconfig_file}\" ]]; then\n\t\tlocal local_modified=\"$(stat -c %Y \"${kconfig_file}\")\"\n\n\t\tfor config in \"${KCONFIG_REL_PATHS[@]}\"; do\n\t\t\tlocal kconfig_src=\"${config}\"\n\t\t\tlocal src_modified=\"$(stat -c %Y \"${kconfig_src}\")\"\n\t\t\t# Only update the config if it has been updated after the\n\t\t\t# previously cached config was created. This avoids\n\t\t\t# unnecessarily compiling the kernel and selftests.\n\t\t\tif [[ \"${src_modified}\" -gt \"${local_modified}\" ]]; then\n\t\t\t\tdo_update_kconfig \"$kernel_checkout\" \"$kconfig_file\"\n\t\t\t\t# Once we have found one outdated configuration\n\t\t\t\t# there is no need to check other ones.\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\telse\n\t\tdo_update_kconfig \"$kernel_checkout\" \"$kconfig_file\"\n\tfi\n}\n\nmain()\n{\n\tlocal script_dir=\"$(cd -P -- \"$(dirname -- \"${BASH_SOURCE[0]}\")\" && pwd -P)\"\n\tlocal kernel_checkout=$(realpath \"${script_dir}\"/../../../../)\n\t# By default the script searches for the kernel in the checkout directory but\n\t# it also obeys environment variables O= and KBUILD_OUTPUT=\n\tlocal kernel_bzimage=\"${kernel_checkout}/${BZIMAGE}\"\n\tlocal command=\"${DEFAULT_COMMAND}\"\n\tlocal update_b2c=\"no\"\n\tlocal debug_shell=\"no\"\n\n\twhile getopts ':hsud:j:' opt; do\n\t\tcase ${opt} in\n\t\tu)\n\t\t\tupdate_b2c=\"yes\"\n\t\t\t;;\n\t\td)\n\t\t\tOUTPUT_DIR=\"$OPTARG\"\n\t\t\t;;\n\t\tj)\n\t\t\tNUM_COMPILE_JOBS=\"$OPTARG\"\n\t\t\t;;\n\t\ts)\n\t\t\tcommand=\"/bin/sh\"\n\t\t\tdebug_shell=\"yes\"\n\t\t\t;;\n\t\th)\n\t\t\tusage\n\t\t\texit 0\n\t\t\t;;\n\t\t\\? )\n\t\t\techo \"Invalid Option: -$OPTARG\"\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\t\t: )\n\t\t\techo \"Invalid Option: -$OPTARG requires an argument\"\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\t\tesac\n\tdone\n\tshift $((OPTIND -1))\n\n\t# trap 'catch \"$?\"' EXIT\n\n\tif [[ \"${debug_shell}\" == \"no\" ]]; then\n\t\tif [[ $# -eq 0 ]]; then\n\t\t\techo \"No command specified, will run ${DEFAULT_COMMAND} in the vm\"\n\t\telse\n\t\t\tcommand=\"$@\"\n\n\t\t\tif [[ \"${command}\" == \"/bin/bash\" || \"${command}\" == \"bash\" ]]\n\t\t\tthen\n\t\t\t\tdebug_shell=\"yes\"\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tlocal kconfig_file=\"${OUTPUT_DIR}/latest.config\"\n\tlocal make_command=\"make -j ${NUM_COMPILE_JOBS} KCONFIG_CONFIG=${kconfig_file}\"\n\n\t# Figure out where the kernel is being built.\n\t# O takes precedence over KBUILD_OUTPUT.\n\tif [[ \"${O:=\"\"}\" != \"\" ]]; then\n\t\tif is_rel_path \"${O}\"; then\n\t\t\tO=\"$(realpath \"${PWD}/${O}\")\"\n\t\tfi\n\t\tkernel_bzimage=\"${O}/${BZIMAGE}\"\n\t\tmake_command=\"${make_command} O=${O}\"\n\telif [[ \"${KBUILD_OUTPUT:=\"\"}\" != \"\" ]]; then\n\t\tif is_rel_path \"${KBUILD_OUTPUT}\"; then\n\t\t\tKBUILD_OUTPUT=\"$(realpath \"${PWD}/${KBUILD_OUTPUT}\")\"\n\t\tfi\n\t\tkernel_bzimage=\"${KBUILD_OUTPUT}/${BZIMAGE}\"\n\t\tmake_command=\"${make_command} KBUILD_OUTPUT=${KBUILD_OUTPUT}\"\n\tfi\n\n\tlocal b2c=\"${OUTPUT_DIR}/vm2c.py\"\n\n\techo \"Output directory: ${OUTPUT_DIR}\"\n\n\tmkdir -p \"${OUTPUT_DIR}\"\n\tupdate_kconfig \"${kernel_checkout}\" \"${kconfig_file}\"\n\n\trecompile_kernel \"${kernel_checkout}\" \"${make_command}\"\n\n\tif [[ \"${update_b2c}\" == \"no\" && ! -f \"${b2c}\" ]]; then\n\t\techo \"vm2c script not found in ${b2c}\"\n\t\tupdate_b2c=\"yes\"\n\tfi\n\n\tif [[ \"${update_b2c}\" == \"yes\" ]]; then\n\t\tdownload $B2C_URL $b2c\n\t\tchmod +x $b2c\n\tfi\n\n\tupdate_selftests \"${kernel_checkout}\" \"${make_command}\"\n\trun_vm \"${kernel_checkout}\" $b2c \"${kernel_bzimage}\" \"${command}\"\n\tif [[ \"${debug_shell}\" != \"yes\" ]]; then\n\t\techo \"Logs saved in ${OUTPUT_DIR}/${LOG_FILE}\"\n\tfi\n\n\texit $(cat ${OUTPUT_DIR}/${EXIT_STATUS_FILE})\n}\n\nmain \"$@\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}