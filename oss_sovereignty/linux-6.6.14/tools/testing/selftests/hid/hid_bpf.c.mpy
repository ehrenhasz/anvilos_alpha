{
  "module_name": "hid_bpf.c",
  "hash_id": "046950dae70d8d41aa72c47ceb394a9aa46e7e783321a513a4629853458bdfba",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/hid/hid_bpf.c",
  "human_readable_source": "\n \n#include \"hid.skel.h\"\n\n#include \"../kselftest_harness.h\"\n\n#include <bpf/bpf.h>\n#include <fcntl.h>\n#include <fnmatch.h>\n#include <dirent.h>\n#include <poll.h>\n#include <pthread.h>\n#include <stdbool.h>\n#include <linux/hidraw.h>\n#include <linux/uhid.h>\n\n#define SHOW_UHID_DEBUG 0\n\nstatic unsigned char rdesc[] = {\n\t0x06, 0x00, 0xff,\t \n\t0x09, 0x21,\t\t \n\t0xa1, 0x01,\t\t \n\t0x09, 0x01,\t\t\t \n\t0xa1, 0x00,\t\t\t \n\t0x85, 0x02,\t\t\t\t \n\t0x19, 0x01,\t\t\t\t \n\t0x29, 0x08,\t\t\t\t \n\t0x15, 0x00,\t\t\t\t \n\t0x25, 0xff,\t\t\t\t \n\t0x95, 0x08,\t\t\t\t \n\t0x75, 0x08,\t\t\t\t \n\t0x81, 0x02,\t\t\t\t \n\t0xc0,\t\t\t\t \n\t0x09, 0x01,\t\t\t \n\t0xa1, 0x00,\t\t\t \n\t0x85, 0x01,\t\t\t\t \n\t0x06, 0x00, 0xff,\t\t\t \n\t0x19, 0x01,\t\t\t\t \n\t0x29, 0x03,\t\t\t\t \n\t0x15, 0x00,\t\t\t\t \n\t0x25, 0x01,\t\t\t\t \n\t0x95, 0x03,\t\t\t\t \n\t0x75, 0x01,\t\t\t\t \n\t0x81, 0x02,\t\t\t\t \n\t0x95, 0x01,\t\t\t\t \n\t0x75, 0x05,\t\t\t\t \n\t0x81, 0x01,\t\t\t\t \n\t0x05, 0x01,\t\t\t\t \n\t0x09, 0x30,\t\t\t\t \n\t0x09, 0x31,\t\t\t\t \n\t0x15, 0x81,\t\t\t\t \n\t0x25, 0x7f,\t\t\t\t \n\t0x75, 0x10,\t\t\t\t \n\t0x95, 0x02,\t\t\t\t \n\t0x81, 0x06,\t\t\t\t \n\n\t0x06, 0x00, 0xff,\t\t\t \n\t0x19, 0x01,\t\t\t\t \n\t0x29, 0x03,\t\t\t\t \n\t0x15, 0x00,\t\t\t\t \n\t0x25, 0x01,\t\t\t\t \n\t0x95, 0x03,\t\t\t\t \n\t0x75, 0x01,\t\t\t\t \n\t0x91, 0x02,\t\t\t\t \n\t0x95, 0x01,\t\t\t\t \n\t0x75, 0x05,\t\t\t\t \n\t0x91, 0x01,\t\t\t\t \n\n\t0x06, 0x00, 0xff,\t\t\t \n\t0x19, 0x06,\t\t\t\t \n\t0x29, 0x08,\t\t\t\t \n\t0x15, 0x00,\t\t\t\t \n\t0x25, 0x01,\t\t\t\t \n\t0x95, 0x03,\t\t\t\t \n\t0x75, 0x01,\t\t\t\t \n\t0xb1, 0x02,\t\t\t\t \n\t0x95, 0x01,\t\t\t\t \n\t0x75, 0x05,\t\t\t\t \n\t0x91, 0x01,\t\t\t\t \n\n\t0xc0,\t\t\t\t \n\t0xc0,\t\t\t \n};\n\nstatic __u8 feature_data[] = { 1, 2 };\n\nstruct attach_prog_args {\n\tint prog_fd;\n\tunsigned int hid;\n\tint retval;\n\tint insert_head;\n};\n\nstruct hid_hw_request_syscall_args {\n\t__u8 data[10];\n\tunsigned int hid;\n\tint retval;\n\tsize_t size;\n\tenum hid_report_type type;\n\t__u8 request_type;\n};\n\n#define ASSERT_OK(data) ASSERT_FALSE(data)\n#define ASSERT_OK_PTR(ptr) ASSERT_NE(NULL, ptr)\n\n#define UHID_LOG(fmt, ...) do { \\\n\tif (SHOW_UHID_DEBUG) \\\n\t\tTH_LOG(fmt, ##__VA_ARGS__); \\\n} while (0)\n\nstatic pthread_mutex_t uhid_started_mtx = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t uhid_started = PTHREAD_COND_INITIALIZER;\n\n \nstatic bool uhid_stopped;\n\nstatic int uhid_write(struct __test_metadata *_metadata, int fd, const struct uhid_event *ev)\n{\n\tssize_t ret;\n\n\tret = write(fd, ev, sizeof(*ev));\n\tif (ret < 0) {\n\t\tTH_LOG(\"Cannot write to uhid: %m\");\n\t\treturn -errno;\n\t} else if (ret != sizeof(*ev)) {\n\t\tTH_LOG(\"Wrong size written to uhid: %zd != %zu\",\n\t\t\tret, sizeof(ev));\n\t\treturn -EFAULT;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int uhid_create(struct __test_metadata *_metadata, int fd, int rand_nb)\n{\n\tstruct uhid_event ev;\n\tchar buf[25];\n\n\tsprintf(buf, \"test-uhid-device-%d\", rand_nb);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = UHID_CREATE;\n\tstrcpy((char *)ev.u.create.name, buf);\n\tev.u.create.rd_data = rdesc;\n\tev.u.create.rd_size = sizeof(rdesc);\n\tev.u.create.bus = BUS_USB;\n\tev.u.create.vendor = 0x0001;\n\tev.u.create.product = 0x0a37;\n\tev.u.create.version = 0;\n\tev.u.create.country = 0;\n\n\tsprintf(buf, \"%d\", rand_nb);\n\tstrcpy((char *)ev.u.create.phys, buf);\n\n\treturn uhid_write(_metadata, fd, &ev);\n}\n\nstatic void uhid_destroy(struct __test_metadata *_metadata, int fd)\n{\n\tstruct uhid_event ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = UHID_DESTROY;\n\n\tuhid_write(_metadata, fd, &ev);\n}\n\nstatic int uhid_event(struct __test_metadata *_metadata, int fd)\n{\n\tstruct uhid_event ev, answer;\n\tssize_t ret;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tret = read(fd, &ev, sizeof(ev));\n\tif (ret == 0) {\n\t\tUHID_LOG(\"Read HUP on uhid-cdev\");\n\t\treturn -EFAULT;\n\t} else if (ret < 0) {\n\t\tUHID_LOG(\"Cannot read uhid-cdev: %m\");\n\t\treturn -errno;\n\t} else if (ret != sizeof(ev)) {\n\t\tUHID_LOG(\"Invalid size read from uhid-dev: %zd != %zu\",\n\t\t\tret, sizeof(ev));\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (ev.type) {\n\tcase UHID_START:\n\t\tpthread_mutex_lock(&uhid_started_mtx);\n\t\tpthread_cond_signal(&uhid_started);\n\t\tpthread_mutex_unlock(&uhid_started_mtx);\n\n\t\tUHID_LOG(\"UHID_START from uhid-dev\");\n\t\tbreak;\n\tcase UHID_STOP:\n\t\tuhid_stopped = true;\n\n\t\tUHID_LOG(\"UHID_STOP from uhid-dev\");\n\t\tbreak;\n\tcase UHID_OPEN:\n\t\tUHID_LOG(\"UHID_OPEN from uhid-dev\");\n\t\tbreak;\n\tcase UHID_CLOSE:\n\t\tUHID_LOG(\"UHID_CLOSE from uhid-dev\");\n\t\tbreak;\n\tcase UHID_OUTPUT:\n\t\tUHID_LOG(\"UHID_OUTPUT from uhid-dev\");\n\t\tbreak;\n\tcase UHID_GET_REPORT:\n\t\tUHID_LOG(\"UHID_GET_REPORT from uhid-dev\");\n\n\t\tanswer.type = UHID_GET_REPORT_REPLY;\n\t\tanswer.u.get_report_reply.id = ev.u.get_report.id;\n\t\tanswer.u.get_report_reply.err = ev.u.get_report.rnum == 1 ? 0 : -EIO;\n\t\tanswer.u.get_report_reply.size = sizeof(feature_data);\n\t\tmemcpy(answer.u.get_report_reply.data, feature_data, sizeof(feature_data));\n\n\t\tuhid_write(_metadata, fd, &answer);\n\n\t\tbreak;\n\tcase UHID_SET_REPORT:\n\t\tUHID_LOG(\"UHID_SET_REPORT from uhid-dev\");\n\t\tbreak;\n\tdefault:\n\t\tTH_LOG(\"Invalid event from uhid-dev: %u\", ev.type);\n\t}\n\n\treturn 0;\n}\n\nstruct uhid_thread_args {\n\tint fd;\n\tstruct __test_metadata *_metadata;\n};\nstatic void *uhid_read_events_thread(void *arg)\n{\n\tstruct uhid_thread_args *args = (struct uhid_thread_args *)arg;\n\tstruct __test_metadata *_metadata = args->_metadata;\n\tstruct pollfd pfds[1];\n\tint fd = args->fd;\n\tint ret = 0;\n\n\tpfds[0].fd = fd;\n\tpfds[0].events = POLLIN;\n\n\tuhid_stopped = false;\n\n\twhile (!uhid_stopped) {\n\t\tret = poll(pfds, 1, 100);\n\t\tif (ret < 0) {\n\t\t\tTH_LOG(\"Cannot poll for fds: %m\");\n\t\t\tbreak;\n\t\t}\n\t\tif (pfds[0].revents & POLLIN) {\n\t\t\tret = uhid_event(_metadata, fd);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (void *)(long)ret;\n}\n\nstatic int uhid_start_listener(struct __test_metadata *_metadata, pthread_t *tid, int uhid_fd)\n{\n\tstruct uhid_thread_args args = {\n\t\t.fd = uhid_fd,\n\t\t._metadata = _metadata,\n\t};\n\tint err;\n\n\tpthread_mutex_lock(&uhid_started_mtx);\n\terr = pthread_create(tid, NULL, uhid_read_events_thread, (void *)&args);\n\tASSERT_EQ(0, err) {\n\t\tTH_LOG(\"Could not start the uhid thread: %d\", err);\n\t\tpthread_mutex_unlock(&uhid_started_mtx);\n\t\tclose(uhid_fd);\n\t\treturn -EIO;\n\t}\n\tpthread_cond_wait(&uhid_started, &uhid_started_mtx);\n\tpthread_mutex_unlock(&uhid_started_mtx);\n\n\treturn 0;\n}\n\nstatic int uhid_send_event(struct __test_metadata *_metadata, int fd, __u8 *buf, size_t size)\n{\n\tstruct uhid_event ev;\n\n\tif (size > sizeof(ev.u.input.data))\n\t\treturn -E2BIG;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = UHID_INPUT2;\n\tev.u.input2.size = size;\n\n\tmemcpy(ev.u.input2.data, buf, size);\n\n\treturn uhid_write(_metadata, fd, &ev);\n}\n\nstatic int setup_uhid(struct __test_metadata *_metadata, int rand_nb)\n{\n\tint fd;\n\tconst char *path = \"/dev/uhid\";\n\tint ret;\n\n\tfd = open(path, O_RDWR | O_CLOEXEC);\n\tASSERT_GE(fd, 0) TH_LOG(\"open uhid-cdev failed; %d\", fd);\n\n\tret = uhid_create(_metadata, fd, rand_nb);\n\tASSERT_EQ(0, ret) {\n\t\tTH_LOG(\"create uhid device failed: %d\", ret);\n\t\tclose(fd);\n\t}\n\n\treturn fd;\n}\n\nstatic bool match_sysfs_device(int dev_id, const char *workdir, struct dirent *dir)\n{\n\tconst char *target = \"0003:0001:0A37.*\";\n\tchar phys[512];\n\tchar uevent[1024];\n\tchar temp[512];\n\tint fd, nread;\n\tbool found = false;\n\n\tif (fnmatch(target, dir->d_name, 0))\n\t\treturn false;\n\n\t \n\tsprintf(uevent, \"%s/%s/uevent\", workdir, dir->d_name);\n\n\tfd = open(uevent, O_RDONLY | O_NONBLOCK);\n\tif (fd < 0)\n\t\treturn false;\n\n\tsprintf(phys, \"PHYS=%d\", dev_id);\n\n\tnread = read(fd, temp, ARRAY_SIZE(temp));\n\tif (nread > 0 && (strstr(temp, phys)) != NULL)\n\t\tfound = true;\n\n\tclose(fd);\n\n\treturn found;\n}\n\nstatic int get_hid_id(int dev_id)\n{\n\tconst char *workdir = \"/sys/devices/virtual/misc/uhid\";\n\tconst char *str_id;\n\tDIR *d;\n\tstruct dirent *dir;\n\tint found = -1, attempts = 3;\n\n\t \n\n\twhile (found < 0 && attempts > 0) {\n\t\tattempts--;\n\t\td = opendir(workdir);\n\t\tif (d) {\n\t\t\twhile ((dir = readdir(d)) != NULL) {\n\t\t\t\tif (!match_sysfs_device(dev_id, workdir, dir))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tstr_id = dir->d_name + sizeof(\"0003:0001:0A37.\");\n\t\t\t\tfound = (int)strtol(str_id, NULL, 16);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tclosedir(d);\n\t\t}\n\t\tif (found < 0)\n\t\t\tusleep(100000);\n\t}\n\n\treturn found;\n}\n\nstatic int get_hidraw(int dev_id)\n{\n\tconst char *workdir = \"/sys/devices/virtual/misc/uhid\";\n\tchar sysfs[1024];\n\tDIR *d, *subd;\n\tstruct dirent *dir, *subdir;\n\tint i, found = -1;\n\n\t \n\tfor (i = 5; i > 0; i--) {\n\t\tusleep(10);\n\t\td = opendir(workdir);\n\n\t\tif (!d)\n\t\t\tcontinue;\n\n\t\twhile ((dir = readdir(d)) != NULL) {\n\t\t\tif (!match_sysfs_device(dev_id, workdir, dir))\n\t\t\t\tcontinue;\n\n\t\t\tsprintf(sysfs, \"%s/%s/hidraw\", workdir, dir->d_name);\n\n\t\t\tsubd = opendir(sysfs);\n\t\t\tif (!subd)\n\t\t\t\tcontinue;\n\n\t\t\twhile ((subdir = readdir(subd)) != NULL) {\n\t\t\t\tif (fnmatch(\"hidraw*\", subdir->d_name, 0))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfound = atoi(subdir->d_name + strlen(\"hidraw\"));\n\t\t\t}\n\n\t\t\tclosedir(subd);\n\n\t\t\tif (found > 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tclosedir(d);\n\t}\n\n\treturn found;\n}\n\nstatic int open_hidraw(int dev_id)\n{\n\tint hidraw_number;\n\tchar hidraw_path[64] = { 0 };\n\n\thidraw_number = get_hidraw(dev_id);\n\tif (hidraw_number < 0)\n\t\treturn hidraw_number;\n\n\t \n\tsprintf(hidraw_path, \"/dev/hidraw%d\", hidraw_number);\n\treturn open(hidraw_path, O_RDWR | O_NONBLOCK);\n}\n\nFIXTURE(hid_bpf) {\n\tint dev_id;\n\tint uhid_fd;\n\tint hidraw_fd;\n\tint hid_id;\n\tpthread_t tid;\n\tstruct hid *skel;\n\tint hid_links[3];  \n};\nstatic void detach_bpf(FIXTURE_DATA(hid_bpf) * self)\n{\n\tint i;\n\n\tif (self->hidraw_fd)\n\t\tclose(self->hidraw_fd);\n\tself->hidraw_fd = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(self->hid_links); i++) {\n\t\tif (self->hid_links[i])\n\t\t\tclose(self->hid_links[i]);\n\t}\n\n\thid__destroy(self->skel);\n\tself->skel = NULL;\n}\n\nFIXTURE_TEARDOWN(hid_bpf) {\n\tvoid *uhid_err;\n\n\tuhid_destroy(_metadata, self->uhid_fd);\n\n\tdetach_bpf(self);\n\tpthread_join(self->tid, &uhid_err);\n}\n#define TEARDOWN_LOG(fmt, ...) do { \\\n\tTH_LOG(fmt, ##__VA_ARGS__); \\\n\thid_bpf_teardown(_metadata, self, variant); \\\n} while (0)\n\nFIXTURE_SETUP(hid_bpf)\n{\n\ttime_t t;\n\tint err;\n\n\t \n\tsrand((unsigned int)time(&t));\n\n\tself->dev_id = rand() % 1024;\n\n\tself->uhid_fd = setup_uhid(_metadata, self->dev_id);\n\n\t \n\tself->hid_id = get_hid_id(self->dev_id);\n\tASSERT_GT(self->hid_id, 0)\n\t\tTEARDOWN_LOG(\"Could not locate uhid device id: %d\", self->hid_id);\n\n\terr = uhid_start_listener(_metadata, &self->tid, self->uhid_fd);\n\tASSERT_EQ(0, err) TEARDOWN_LOG(\"could not start udev listener: %d\", err);\n}\n\nstruct test_program {\n\tconst char *name;\n\tint insert_head;\n};\n#define LOAD_PROGRAMS(progs) \\\n\tload_programs(progs, ARRAY_SIZE(progs), _metadata, self, variant)\n#define LOAD_BPF \\\n\tload_programs(NULL, 0, _metadata, self, variant)\nstatic void load_programs(const struct test_program programs[],\n\t\t\t  const size_t progs_count,\n\t\t\t  struct __test_metadata *_metadata,\n\t\t\t  FIXTURE_DATA(hid_bpf) * self,\n\t\t\t  const FIXTURE_VARIANT(hid_bpf) * variant)\n{\n\tint attach_fd, err = -EINVAL;\n\tstruct attach_prog_args args = {\n\t\t.retval = -1,\n\t};\n\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, tattr,\n\t\t\t    .ctx_in = &args,\n\t\t\t    .ctx_size_in = sizeof(args),\n\t);\n\n\tASSERT_LE(progs_count, ARRAY_SIZE(self->hid_links))\n\t\tTH_LOG(\"too many programs are to be loaded\");\n\n\t \n\tself->skel = hid__open();\n\tASSERT_OK_PTR(self->skel) TEARDOWN_LOG(\"Error while calling hid__open\");\n\n\tfor (int i = 0; i < progs_count; i++) {\n\t\tstruct bpf_program *prog;\n\n\t\tprog = bpf_object__find_program_by_name(*self->skel->skeleton->obj,\n\t\t\t\t\t\t\tprograms[i].name);\n\t\tASSERT_OK_PTR(prog) TH_LOG(\"can not find program by name '%s'\", programs[i].name);\n\n\t\tbpf_program__set_autoload(prog, true);\n\t}\n\n\terr = hid__load(self->skel);\n\tASSERT_OK(err) TH_LOG(\"hid_skel_load failed: %d\", err);\n\n\tattach_fd = bpf_program__fd(self->skel->progs.attach_prog);\n\tASSERT_GE(attach_fd, 0) TH_LOG(\"locate attach_prog: %d\", attach_fd);\n\n\tfor (int i = 0; i < progs_count; i++) {\n\t\tstruct bpf_program *prog;\n\n\t\tprog = bpf_object__find_program_by_name(*self->skel->skeleton->obj,\n\t\t\t\t\t\t\tprograms[i].name);\n\t\tASSERT_OK_PTR(prog) TH_LOG(\"can not find program by name '%s'\", programs[i].name);\n\n\t\targs.prog_fd = bpf_program__fd(prog);\n\t\targs.hid = self->hid_id;\n\t\targs.insert_head = programs[i].insert_head;\n\t\terr = bpf_prog_test_run_opts(attach_fd, &tattr);\n\t\tASSERT_GE(args.retval, 0)\n\t\t\tTH_LOG(\"attach_hid(%s): %d\", programs[i].name, args.retval);\n\n\t\tself->hid_links[i] = args.retval;\n\t}\n\n\tself->hidraw_fd = open_hidraw(self->dev_id);\n\tASSERT_GE(self->hidraw_fd, 0) TH_LOG(\"open_hidraw\");\n}\n\n \nTEST_F(hid_bpf, test_create_uhid)\n{\n}\n\n \nTEST_F(hid_bpf, raw_event)\n{\n\tconst struct test_program progs[] = {\n\t\t{ .name = \"hid_first_event\" },\n\t};\n\t__u8 buf[10] = {0};\n\tint err;\n\n\tLOAD_PROGRAMS(progs);\n\n\t \n\tASSERT_EQ(self->skel->data->callback_check, 52) TH_LOG(\"callback_check1\");\n\tASSERT_EQ(self->skel->data->callback2_check, 52) TH_LOG(\"callback2_check1\");\n\n\t \n\tbuf[0] = 1;\n\tbuf[1] = 42;\n\tuhid_send_event(_metadata, self->uhid_fd, buf, 6);\n\n\t \n\tASSERT_EQ(self->skel->data->callback_check, 42) TH_LOG(\"callback_check1\");\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\terr = read(self->hidraw_fd, buf, sizeof(buf));\n\tASSERT_EQ(err, 6) TH_LOG(\"read_hidraw\");\n\tASSERT_EQ(buf[0], 1);\n\tASSERT_EQ(buf[2], 47);\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\tbuf[0] = 1;\n\tbuf[1] = 47;\n\tuhid_send_event(_metadata, self->uhid_fd, buf, 6);\n\n\t \n\tASSERT_EQ(self->skel->data->callback_check, 47) TH_LOG(\"callback_check1\");\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\terr = read(self->hidraw_fd, buf, sizeof(buf));\n\tASSERT_EQ(err, 6) TH_LOG(\"read_hidraw\");\n\tASSERT_EQ(buf[2], 52);\n}\n\n \nTEST_F(hid_bpf, test_attach_detach)\n{\n\tconst struct test_program progs[] = {\n\t\t{ .name = \"hid_first_event\" },\n\t\t{ .name = \"hid_second_event\" },\n\t};\n\t__u8 buf[10] = {0};\n\tint err, link;\n\n\tLOAD_PROGRAMS(progs);\n\n\tlink = self->hid_links[0];\n\tASSERT_GT(link, 0) TH_LOG(\"HID-BPF link not created\");\n\n\t \n\tbuf[0] = 1;\n\tbuf[1] = 42;\n\tuhid_send_event(_metadata, self->uhid_fd, buf, 6);\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\terr = read(self->hidraw_fd, buf, sizeof(buf));\n\tASSERT_EQ(err, 6) TH_LOG(\"read_hidraw\");\n\tASSERT_EQ(buf[0], 1);\n\tASSERT_EQ(buf[2], 47);\n\n\t \n\tASSERT_EQ(buf[3], 52);\n\n\t \n#define PIN_PATH \"/sys/fs/bpf/hid_first_event\"\n\terr = bpf_obj_pin(link, PIN_PATH);\n\tASSERT_OK(err) TH_LOG(\"error while calling bpf_obj_pin\");\n\tremove(PIN_PATH);\n#undef PIN_PATH\n\tusleep(100000);\n\n\t \n\tdetach_bpf(self);\n\n\tself->hidraw_fd = open_hidraw(self->dev_id);\n\tASSERT_GE(self->hidraw_fd, 0) TH_LOG(\"open_hidraw\");\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\tbuf[0] = 1;\n\tbuf[1] = 47;\n\tuhid_send_event(_metadata, self->uhid_fd, buf, 6);\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\terr = read(self->hidraw_fd, buf, sizeof(buf));\n\tASSERT_EQ(err, 6) TH_LOG(\"read_hidraw_no_bpf\");\n\tASSERT_EQ(buf[0], 1);\n\tASSERT_EQ(buf[1], 47);\n\tASSERT_EQ(buf[2], 0);\n\tASSERT_EQ(buf[3], 0);\n\n\t \n\n\tLOAD_PROGRAMS(progs);\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\tbuf[0] = 1;\n\tbuf[1] = 42;\n\tuhid_send_event(_metadata, self->uhid_fd, buf, 6);\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\terr = read(self->hidraw_fd, buf, sizeof(buf));\n\tASSERT_EQ(err, 6) TH_LOG(\"read_hidraw\");\n\tASSERT_EQ(buf[0], 1);\n\tASSERT_EQ(buf[2], 47);\n\tASSERT_EQ(buf[3], 52);\n}\n\n \nTEST_F(hid_bpf, test_hid_change_report)\n{\n\tconst struct test_program progs[] = {\n\t\t{ .name = \"hid_change_report_id\" },\n\t};\n\t__u8 buf[10] = {0};\n\tint err;\n\n\tLOAD_PROGRAMS(progs);\n\n\t \n\tbuf[0] = 1;\n\tbuf[1] = 42;\n\tuhid_send_event(_metadata, self->uhid_fd, buf, 6);\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\terr = read(self->hidraw_fd, buf, sizeof(buf));\n\tASSERT_EQ(err, 9) TH_LOG(\"read_hidraw\");\n\tASSERT_EQ(buf[0], 2);\n\tASSERT_EQ(buf[1], 42);\n\tASSERT_EQ(buf[2], 0) TH_LOG(\"leftovers_from_previous_test\");\n}\n\n \nTEST_F(hid_bpf, test_hid_user_raw_request_call)\n{\n\tstruct hid_hw_request_syscall_args args = {\n\t\t.retval = -1,\n\t\t.type = HID_FEATURE_REPORT,\n\t\t.request_type = HID_REQ_GET_REPORT,\n\t\t.size = 10,\n\t};\n\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, tattrs,\n\t\t\t    .ctx_in = &args,\n\t\t\t    .ctx_size_in = sizeof(args),\n\t);\n\tint err, prog_fd;\n\n\tLOAD_BPF;\n\n\targs.hid = self->hid_id;\n\targs.data[0] = 1;  \n\n\tprog_fd = bpf_program__fd(self->skel->progs.hid_user_raw_request);\n\n\terr = bpf_prog_test_run_opts(prog_fd, &tattrs);\n\tASSERT_OK(err) TH_LOG(\"error while calling bpf_prog_test_run_opts\");\n\n\tASSERT_EQ(args.retval, 2);\n\n\tASSERT_EQ(args.data[1], 2);\n}\n\n \nTEST_F(hid_bpf, test_hid_attach_flags)\n{\n\tconst struct test_program progs[] = {\n\t\t{\n\t\t\t.name = \"hid_test_insert2\",\n\t\t\t.insert_head = 0,\n\t\t},\n\t\t{\n\t\t\t.name = \"hid_test_insert1\",\n\t\t\t.insert_head = 1,\n\t\t},\n\t\t{\n\t\t\t.name = \"hid_test_insert3\",\n\t\t\t.insert_head = 0,\n\t\t},\n\t};\n\t__u8 buf[10] = {0};\n\tint err;\n\n\tLOAD_PROGRAMS(progs);\n\n\t \n\tbuf[0] = 1;\n\tuhid_send_event(_metadata, self->uhid_fd, buf, 6);\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\terr = read(self->hidraw_fd, buf, sizeof(buf));\n\tASSERT_EQ(err, 6) TH_LOG(\"read_hidraw\");\n\tASSERT_EQ(buf[1], 1);\n\tASSERT_EQ(buf[2], 2);\n\tASSERT_EQ(buf[3], 3);\n}\n\n \nTEST_F(hid_bpf, test_rdesc_fixup)\n{\n\tstruct hidraw_report_descriptor rpt_desc = {0};\n\tconst struct test_program progs[] = {\n\t\t{ .name = \"hid_rdesc_fixup\" },\n\t};\n\tint err, desc_size;\n\n\tLOAD_PROGRAMS(progs);\n\n\t \n\tASSERT_EQ(self->skel->data->callback2_check, 0x21);\n\n\t \n\terr = ioctl(self->hidraw_fd, HIDIOCGRDESCSIZE, &desc_size);\n\tASSERT_GE(err, 0) TH_LOG(\"error while reading HIDIOCGRDESCSIZE: %d\", err);\n\n\t \n\tASSERT_GT(desc_size, sizeof(rdesc));\n\n\trpt_desc.size = desc_size;\n\terr = ioctl(self->hidraw_fd, HIDIOCGRDESC, &rpt_desc);\n\tASSERT_GE(err, 0) TH_LOG(\"error while reading HIDIOCGRDESC: %d\", err);\n\n\tASSERT_EQ(rpt_desc.value[4], 0x42);\n}\n\nstatic int libbpf_print_fn(enum libbpf_print_level level,\n\t\t\t   const char *format, va_list args)\n{\n\tchar buf[1024];\n\n\tif (level == LIBBPF_DEBUG)\n\t\treturn 0;\n\n\tsnprintf(buf, sizeof(buf), \"# %s\", format);\n\n\tvfprintf(stdout, buf, args);\n\treturn 0;\n}\n\nstatic void __attribute__((constructor)) __constructor_order_last(void)\n{\n\tif (!__constructor_order)\n\t\t__constructor_order = _CONSTRUCTOR_ORDER_BACKWARD;\n}\n\nint main(int argc, char **argv)\n{\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\tlibbpf_set_print(libbpf_print_fn);\n\n\treturn test_harness_run(argc, argv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}