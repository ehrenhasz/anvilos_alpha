{
  "module_name": "short_splice_read.sh",
  "hash_id": "b421b0b82697337f33313c0f48c4b9e87cbe124681962c5912b1e4e3900084e3",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/splice/short_splice_read.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# Test for mishandling of splice() on pseudofilesystems, which should catch\n# bugs like 11990a5bd7e5 (\"module: Correctly truncate sysfs sections output\")\n#\n# Since splice fallback was removed as part of the set_fs() rework, many of these\n# tests expect to fail now. See https://lore.kernel.org/lkml/202009181443.C2179FB@keescook/\nset -e\n\nDIR=$(dirname \"$0\")\n\nret=0\n\nexpect_success()\n{\n\ttitle=\"$1\"\n\tshift\n\n\techo \"\" >&2\n\techo \"$title ...\" >&2\n\n\tset +e\n\t\"$@\"\n\trc=$?\n\tset -e\n\n\tcase \"$rc\" in\n\t0)\n\t\techo \"ok: $title succeeded\" >&2\n\t\t;;\n\t1)\n\t\techo \"FAIL: $title should work\" >&2\n\t\tret=$(( ret + 1 ))\n\t\t;;\n\t*)\n\t\techo \"FAIL: something else went wrong\" >&2\n\t\tret=$(( ret + 1 ))\n\t\t;;\n\tesac\n}\n\nexpect_failure()\n{\n\ttitle=\"$1\"\n\tshift\n\n\techo \"\" >&2\n\techo \"$title ...\" >&2\n\n\tset +e\n\t\"$@\"\n\trc=$?\n\tset -e\n\n\tcase \"$rc\" in\n\t0)\n\t\techo \"FAIL: $title unexpectedly worked\" >&2\n\t\tret=$(( ret + 1 ))\n\t\t;;\n\t1)\n\t\techo \"ok: $title correctly failed\" >&2\n\t\t;;\n\t*)\n\t\techo \"FAIL: something else went wrong\" >&2\n\t\tret=$(( ret + 1 ))\n\t\t;;\n\tesac\n}\n\ndo_splice()\n{\n\tfilename=\"$1\"\n\tbytes=\"$2\"\n\texpected=\"$3\"\n\treport=\"$4\"\n\n\tout=$(\"$DIR\"/splice_read \"$filename\" \"$bytes\" | cat)\n\tif [ \"$out\" = \"$expected\" ] ; then\n\t\techo \"      matched $report\" >&2\n\t\treturn 0\n\telse\n\t\techo \"      no match: '$out' vs $report\" >&2\n\t\treturn 1\n\tfi\n}\n\ntest_splice()\n{\n\tfilename=\"$1\"\n\n\techo \"  checking $filename ...\" >&2\n\n\tfull=$(cat \"$filename\")\n\trc=$?\n\tif [ $rc -ne 0 ] ; then\n\t\treturn 2\n\tfi\n\n\ttwo=$(echo \"$full\" | grep -m1 . | cut -c-2)\n\n\t# Make sure full splice has the same contents as a standard read.\n\techo \"    splicing 4096 bytes ...\" >&2\n\tif ! do_splice \"$filename\" 4096 \"$full\" \"full read\" ; then\n\t\treturn 1\n\tfi\n\n\t# Make sure a partial splice see the first two characters.\n\techo \"    splicing 2 bytes ...\" >&2\n\tif ! do_splice \"$filename\" 2 \"$two\" \"'$two'\" ; then\n\t\treturn 1\n\tfi\n\n\treturn 0\n}\n\n### /proc/$pid/ has no splice interface; these should all fail.\nexpect_failure \"proc_single_open(), seq_read() splice\" test_splice /proc/$$/limits\nexpect_failure \"special open(), seq_read() splice\" test_splice /proc/$$/comm\n\n### /proc/sys/ has a splice interface; these should all succeed.\nexpect_success \"proc_handler: proc_dointvec_minmax() splice\" test_splice /proc/sys/fs/nr_open\nexpect_success \"proc_handler: proc_dostring() splice\" test_splice /proc/sys/kernel/modprobe\nexpect_success \"proc_handler: special read splice\" test_splice /proc/sys/kernel/version\n\n### /sys/ has no splice interface; these should all fail.\nif ! [ -d /sys/module/test_module/sections ] ; then\n\texpect_success \"test_module kernel module load\" modprobe test_module\nfi\nexpect_success \"kernfs attr splice\" test_splice /sys/module/test_module/coresize\nexpect_success \"kernfs binattr splice\" test_splice /sys/module/test_module/sections/.init.text\n\nexit $ret\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}