{
  "module_name": "kvm-transform.sh",
  "hash_id": "5513da033fd3b24c5f20a171af8075a10ee8fdd5dded807dbe087e5cfee8c621",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/rcutorture/bin/kvm-transform.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0+\n#\n# Transform a qemu-cmd file to allow reuse.\n#\n# Usage: kvm-transform.sh bzImage console.log jitter_dir seconds [ bootargs ] < qemu-cmd-in > qemu-cmd-out\n#\n#\tbzImage: Kernel and initrd from the same prior kvm.sh run.\n#\tconsole.log: File into which to place console output.\n#\tjitter_dir: Jitter directory for TORTURE_JITTER_START and\n#\t\tTORTURE_JITTER_STOP environment variables.\n#\tseconds: Run duaration for *.shutdown_secs module parameter.\n#\tbootargs: New kernel boot parameters.  Beware of Robert Tables.\n#\n# The original qemu-cmd file is provided on standard input.\n# The transformed qemu-cmd file is on standard output.\n# The transformation assumes that the qemu command is confined to a\n# single line.  It also assumes no whitespace in filenames.\n#\n# Copyright (C) 2020 Facebook, Inc.\n#\n# Authors: Paul E. McKenney <paulmck@kernel.org>\n\nT=`mktemp -d /tmp/kvm-transform.sh.XXXXXXXXXX`\ntrap 'rm -rf $T' 0 2\n\nimage=\"$1\"\nif test -z \"$image\"\nthen\n\techo Need kernel image file.\n\texit 1\nfi\nconsolelog=\"$2\"\nif test -z \"$consolelog\"\nthen\n\techo \"Need console log file name.\"\n\texit 1\nfi\njitter_dir=\"$3\"\nif test -z \"$jitter_dir\" || ! test -d \"$jitter_dir\"\nthen\n\techo \"Need valid jitter directory: '$jitter_dir'\"\n\texit 1\nfi\nseconds=\"$4\"\nif test -n \"$seconds\" && echo $seconds | grep -q '[^0-9]'\nthen\n\techo \"Invalid duration, should be numeric in seconds: '$seconds'\"\n\texit 1\nfi\nbootargs=\"$5\"\n\n# Build awk program.\necho \"BEGIN {\" > $T/bootarg.awk\necho $bootargs | tr -s ' ' '\\012' |\n\tawk -v dq='\"' '/./ { print \"\\tbootarg[\" NR \"] = \" dq $1 dq \";\" }' >> $T/bootarg.awk\necho $bootargs | tr -s ' ' '\\012' | sed -e 's/=.*$//' |\n\tawk -v dq='\"' '/./ { print \"\\tbootpar[\" NR \"] = \" dq $1 dq \";\" }' >> $T/bootarg.awk\ncat >> $T/bootarg.awk << '___EOF___'\n}\n\n/^# seconds=/ {\n\tif (seconds == \"\")\n\t\tprint $0;\n\telse\n\t\tprint \"# seconds=\" seconds;\n\tnext;\n}\n\n/^# TORTURE_JITTER_START=/ {\n\tprint \"# TORTURE_JITTER_START=\\\". jitterstart.sh \" $4 \" \" jitter_dir \" \" $6 \" \" $7;\n\tnext;\n}\n\n/^# TORTURE_JITTER_STOP=/ {\n\tprint \"# TORTURE_JITTER_STOP=\\\". jitterstop.sh \" \" \" jitter_dir \" \" $5;\n\tnext;\n}\n\n/^#/ {\n\tprint $0;\n\tnext;\n}\n\n{\n\tline = \"\";\n\tfor (i = 1; i <= NF; i++) {\n\t\tif (line == \"\") {\n\t\t\tline = $i;\n\t\t} else {\n\t\t\tline = line \" \" $i;\n\t\t}\n\t\tif ($i == \"-serial\") {\n\t\t\ti++;\n\t\t\tline = line \" file:\" consolelog;\n\t\t} else if ($i == \"-kernel\") {\n\t\t\ti++;\n\t\t\tline = line \" \" image;\n\t\t} else if ($i == \"-append\") {\n\t\t\tfor (i++; i <= NF; i++) {\n\t\t\t\targ = $i;\n\t\t\t\tlq = \"\";\n\t\t\t\trq = \"\";\n\t\t\t\tif (\"\" seconds != \"\" && $i ~ /\\.shutdown_secs=[0-9]*$/)\n\t\t\t\t\tsub(/[0-9]*$/, seconds, arg);\n\t\t\t\tif (arg ~ /^\"/) {\n\t\t\t\t\tlq = substr(arg, 1, 1);\n\t\t\t\t\targ  = substr(arg, 2);\n\t\t\t\t}\n\t\t\t\tif (arg ~ /\"$/) {\n\t\t\t\t\trq = substr(arg, length($i), 1);\n\t\t\t\t\targ = substr(arg, 1, length($i) - 1);\n\t\t\t\t}\n\t\t\t\tpar = arg;\n\t\t\t\tgsub(/=.*$/, \"\", par);\n\t\t\t\tj = 1;\n\t\t\t\twhile (bootpar[j] != \"\") {\n\t\t\t\t\tif (bootpar[j] == par) {\n\t\t\t\t\t\targ = \"\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (line == \"\")\n\t\t\t\t\tline = lq arg;\n\t\t\t\telse\n\t\t\t\t\tline = line \" \" lq arg;\n\t\t\t}\n\t\t\tfor (j in bootarg)\n\t\t\t\tline = line \" \" bootarg[j];\n\t\t\tline = line rq;\n\t\t}\n\t}\n\tprint line;\n}\n___EOF___\n\nawk -v image=\"$image\" -v consolelog=\"$consolelog\" -v jitter_dir=\"$jitter_dir\" \\\n    -v seconds=\"$seconds\" -f $T/bootarg.awk\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}