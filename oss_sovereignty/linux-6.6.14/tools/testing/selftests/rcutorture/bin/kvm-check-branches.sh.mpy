{
  "module_name": "kvm-check-branches.sh",
  "hash_id": "d215c2232cd122c4009754becda9857ebd3c4105287a1cb33faf8ceba642b582",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/rcutorture/bin/kvm-check-branches.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0+\n#\n# Run a group of kvm.sh tests on the specified commits.  This currently\n# unconditionally does three-minute runs on each scenario in CFLIST,\n# taking advantage of all available CPUs and trusting the \"make\" utility.\n# In the short term, adjustments can be made by editing this script and\n# CFLIST.  If some adjustments appear to have ongoing value, this script\n# might grow some command-line arguments.\n#\n# Usage: kvm-check-branches.sh commit1 commit2..commit3 commit4 ...\n#\n# This script considers its arguments one at a time.  If more elaborate\n# specification of commits is needed, please use \"git rev-list\" to\n# produce something that this simple script can understand.  The reason\n# for retaining the simplicity is that it allows the user to more easily\n# see which commit came from which branch.\n#\n# This script creates a yyyy.mm.dd-hh.mm.ss-group entry in the \"res\"\n# directory.  The calls to kvm.sh create the usual entries, but this script\n# moves them under the yyyy.mm.dd-hh.mm.ss-group entry, each in its own\n# directory numbered in run order, that is, \"0001\", \"0002\", and so on.\n# For successful runs, the large build artifacts are removed.  Doing this\n# reduces the disk space required by about two orders of magnitude for\n# successful runs.\n#\n# Copyright (C) Facebook, 2020\n#\n# Authors: Paul E. McKenney <paulmck@kernel.org>\n\nif ! git status > /dev/null 2>&1\nthen\n\techo '!!!' This script needs to run in a git archive. 1>&2\n\techo '!!!' Giving up. 1>&2\n\texit 1\nfi\n\n# Remember where we started so that we can get back at the end.\ncurcommit=\"`git status | head -1 | awk '{ print $NF }'`\"\n\nnfail=0\nntry=0\nresdir=\"tools/testing/selftests/rcutorture/res\"\nds=\"`date +%Y.%m.%d-%H.%M.%S`-group\"\nif ! test -e $resdir\nthen\n\tmkdir $resdir || :\nfi\nmkdir $resdir/$ds\necho Results directory: $resdir/$ds\n\nRCUTORTURE=\"`pwd`/tools/testing/selftests/rcutorture\"; export RCUTORTURE\nPATH=${RCUTORTURE}/bin:$PATH; export PATH\n. functions.sh\necho Using all `identify_qemu_vcpus` CPUs.\n\n# Each pass through this loop does one command-line argument.\nfor gitbr in $@\ndo\n\techo ' --- git branch ' $gitbr\n\n\t# Each pass through this loop tests one commit.\n\tfor i in `git rev-list \"$gitbr\"`\n\tdo\n\t\tntry=`expr $ntry + 1`\n\t\tidir=`awk -v ntry=\"$ntry\" 'END { printf \"%04d\", ntry; }' < /dev/null`\n\t\techo ' --- commit ' $i from branch $gitbr\n\t\tdate\n\t\tmkdir $resdir/$ds/$idir\n\t\techo $gitbr > $resdir/$ds/$idir/gitbr\n\t\techo $i >> $resdir/$ds/$idir/gitbr\n\n\t\t# Test the specified commit.\n\t\tgit checkout $i > $resdir/$ds/$idir/git-checkout.out 2>&1\n\t\techo git checkout return code: $? \"(Commit $ntry: $i)\"\n\t\tkvm.sh --allcpus --duration 3 --trust-make --datestamp \"$ds/$idir\" > $resdir/$ds/$idir/kvm.sh.out 2>&1\n\t\tret=$?\n\t\techo kvm.sh return code $ret for commit $i from branch $gitbr\n\t\techo Run results: $resdir/$ds/$idir\n\t\tif test \"$ret\" -ne 0\n\t\tthen\n\t\t\t# Failure, so leave all evidence intact.\n\t\t\tnfail=`expr $nfail + 1`\n\t\telse\n\t\t\t# Success, so remove large files to save about 1GB.\n\t\t\t( cd $resdir/$ds/$idir/$rrd; rm -f */vmlinux */bzImage */System.map */Module.symvers )\n\t\tfi\n\tdone\ndone\ndate\n\n# Go back to the original commit.\ngit checkout \"$curcommit\"\n\nif test $nfail -ne 0\nthen\n\techo '!!! ' $nfail failures in $ntry 'runs!!!'\n\texit 1\nelse\n\techo No failures in $ntry runs.\n\texit 0\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}