{
  "module_name": "kvm-recheck-rcuscale-ftrace.sh",
  "hash_id": "f4315fd9b7df7f78b45db574f1dada9c795b1dc8ccd188fcbfbcb9a23ff04911",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/rcutorture/bin/kvm-recheck-rcuscale-ftrace.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0+\n#\n# Analyze a given results directory for rcuscale performance measurements,\n# looking for ftrace data.  Exits with 0 if data was found, analyzed, and\n# printed.  Intended to be invoked from kvm-recheck-rcuscale.sh after\n# argument checking.\n#\n# Usage: kvm-recheck-rcuscale-ftrace.sh resdir\n#\n# Copyright (C) IBM Corporation, 2016\n#\n# Authors: Paul E. McKenney <paulmck@linux.ibm.com>\n\ni=\"$1\"\n. functions.sh\n\nif test \"`grep -c 'rcu_exp_grace_period.*start' < $i/console.log`\" -lt 100\nthen\n\texit 10\nfi\n\nsed -e 's/^\\[[^]]*]//' < $i/console.log |\ngrep 'us : rcu_exp_grace_period' |\nsed -e 's/us : / : /' |\ntr -d '\\015' |\nawk '\n$8 == \"start\" {\n\tif (startseq != \"\")\n\t\tnlost++;\n\tstarttask = $1;\n\tstarttime = $3;\n\tstartseq = $7;\n\tseqtask[startseq] = starttask;\n}\n\n$8 == \"end\" {\n\tif (startseq == $7) {\n\t\tcurgpdur = $3 - starttime;\n\t\tgptimes[++n] = curgpdur;\n\t\tgptaskcnt[starttask]++;\n\t\tsum += curgpdur;\n\t\tif (curgpdur > 1000)\n\t\t\tprint \"Long GP \" starttime \"us to \" $3 \"us (\" curgpdur \"us)\";\n\t\tstartseq = \"\";\n\t} else {\n\t\t# Lost a message or some such, reset.\n\t\tstartseq = \"\";\n\t\tnlost++;\n\t}\n}\n\n$8 == \"done\" && seqtask[$7] != $1 {\n\tpiggybackcnt[$1]++;\n}\n\nEND {\n\tnewNR = asort(gptimes);\n\tif (newNR <= 0) {\n\t\tprint \"No ftrace records found???\"\n\t\texit 10;\n\t}\n\tpct50 = int(newNR * 50 / 100);\n\tif (pct50 < 1)\n\t\tpct50 = 1;\n\tpct90 = int(newNR * 90 / 100);\n\tif (pct90 < 1)\n\t\tpct90 = 1;\n\tpct99 = int(newNR * 99 / 100);\n\tif (pct99 < 1)\n\t\tpct99 = 1;\n\tdiv = 10 ** int(log(gptimes[pct90]) / log(10) + .5) / 100;\n\tprint \"Histogram bucket size: \" div;\n\tlast = gptimes[1] - 10;\n\tcount = 0;\n\tfor (i = 1; i <= newNR; i++) {\n\t\tcurrent = div * int(gptimes[i] / div);\n\t\tif (last == current) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\tif (count > 0)\n\t\t\t\tprint last, count;\n\t\t\tcount = 1;\n\t\t\tlast = current;\n\t\t}\n\t}\n\tif (count > 0)\n\t\tprint last, count;\n\tprint \"Distribution of grace periods across tasks:\";\n\tfor (i in gptaskcnt) {\n\t\tprint \"\\t\" i, gptaskcnt[i];\n\t\tnbatches += gptaskcnt[i];\n\t}\n\tngps = nbatches;\n\tprint \"Distribution of piggybacking across tasks:\";\n\tfor (i in piggybackcnt) {\n\t\tprint \"\\t\" i, piggybackcnt[i];\n\t\tngps += piggybackcnt[i];\n\t}\n\tprint \"Average grace-period duration: \" sum / newNR \" microseconds\";\n\tprint \"Minimum grace-period duration: \" gptimes[1];\n\tprint \"50th percentile grace-period duration: \" gptimes[pct50];\n\tprint \"90th percentile grace-period duration: \" gptimes[pct90];\n\tprint \"99th percentile grace-period duration: \" gptimes[pct99];\n\tprint \"Maximum grace-period duration: \" gptimes[newNR];\n\tprint \"Grace periods: \" ngps + 0 \" Batches: \" nbatches + 0 \" Ratio: \" ngps / nbatches \" Lost: \" nlost + 0;\n\tprint \"Computed from ftrace data.\";\n}'\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}