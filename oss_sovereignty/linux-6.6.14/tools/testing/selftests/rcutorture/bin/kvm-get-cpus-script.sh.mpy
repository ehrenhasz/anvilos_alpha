{
  "module_name": "kvm-get-cpus-script.sh",
  "hash_id": "84df36f0215648a211eb9d125dc56e69874be362aae5027ac12d06be3efe0ea7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/rcutorture/bin/kvm-get-cpus-script.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0+\n#\n# Create an awk script that takes as input numbers of CPUs and outputs\n# lists of CPUs, one per line in both cases.\n#\n# Usage: kvm-get-cpus-script.sh /path/to/cpu/arrays /path/to/put/script [ /path/to/state ]\n#\n# The CPU arrays are output by kvm-assign-cpus.sh, and are valid awk\n# statements initializing the variables describing the system's topology.\n#\n# The optional state is input by this script (if the file exists and is\n# non-empty), and can also be output by this script.\n\ncpuarrays=\"${1-/sys/devices/system/node}\"\nscriptfile=\"${2}\"\nstatefile=\"${3}\"\n\nif ! test -f \"$cpuarrays\"\nthen\n\techo \"File not found: $cpuarrays\" 1>&2\n\texit 1\nfi\nscriptdir=\"`dirname \"$scriptfile\"`\"\nif ! test -d \"$scriptdir\" || ! test -x \"$scriptdir\" || ! test -w \"$scriptdir\"\nthen\n\techo \"Directory not usable for script output: $scriptdir\"\n\texit 1\nfi\n\ncat << '___EOF___' > \"$scriptfile\"\nBEGIN {\n___EOF___\ncat \"$cpuarrays\" >> \"$scriptfile\"\nif test -r \"$statefile\"\nthen\n\tcat \"$statefile\" >> \"$scriptfile\"\nfi\ncat << '___EOF___' >> \"$scriptfile\"\n}\n\n# Do we have the system architecture to guide CPU affinity?\nfunction gotcpus()\n{\n\treturn numnodes != \"\";\n}\n\n# Return a comma-separated list of the next n CPUs.\nfunction nextcpus(n,  i, s)\n{\n\tfor (i = 0; i < n; i++) {\n\t\tif (nodecpus[curnode] == \"\")\n\t\t\tcurnode = 0;\n\t\tif (cpu[curnode][curcpu[curnode]] == \"\")\n\t\t\tcurcpu[curnode] = 0;\n\t\tif (s != \"\")\n\t\t\ts = s \",\";\n\t\ts = s cpu[curnode][curcpu[curnode]];\n\t\tcurcpu[curnode]++;\n\t\tcurnode++\n\t}\n\treturn s;\n}\n\n# Dump out the current node/CPU state so that a later invocation of this\n# script can continue where this one left off.  Of course, this only works\n# when a state file was specified and where there was valid sysfs state.\n# Returns 1 if the state was dumped, 0 otherwise.\n#\n# Dumping the state for one system configuration and loading it into\n# another isn't likely to do what you want, whatever that might be.\nfunction dumpcpustate(  i, fn)\n{\n___EOF___\necho '\tfn = \"'\"$statefile\"'\";' >> $scriptfile\ncat << '___EOF___' >> \"$scriptfile\"\n\tif (fn != \"\" && gotcpus()) {\n\t\tprint \"curnode = \" curnode \";\" > fn;\n\t\tfor (i = 0; i < numnodes; i++)\n\t\t\tif (curcpu[i] != \"\")\n\t\t\t\tprint \"curcpu[\" i \"] = \" curcpu[i] \";\" >> fn;\n\t\treturn 1;\n\t}\n\tif (fn != \"\")\n\t\tprint \"# No CPU state to dump.\" > fn;\n\treturn 0;\n}\n___EOF___\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}