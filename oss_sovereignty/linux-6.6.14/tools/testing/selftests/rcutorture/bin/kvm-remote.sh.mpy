{
  "module_name": "kvm-remote.sh",
  "hash_id": "02d7cb013e16c1a0d5a289c3eb4dd8035e14896fcc79b35084208366938dede8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/rcutorture/bin/kvm-remote.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0+\n#\n# Run a series of tests on remote systems under KVM.\n#\n# Usage: kvm-remote.sh \"systems\" [ <kvm.sh args> ]\n#\t kvm-remote.sh \"systems\" /path/to/old/run [ <kvm-again.sh args> ]\n#\n# Copyright (C) 2021 Facebook, Inc.\n#\n# Authors: Paul E. McKenney <paulmck@kernel.org>\n\nscriptname=$0\nargs=\"$*\"\n\nif ! test -d tools/testing/selftests/rcutorture/bin\nthen\n\techo $scriptname must be run from top-level directory of kernel source tree.\n\texit 1\nfi\n\nRCUTORTURE=\"`pwd`/tools/testing/selftests/rcutorture\"; export RCUTORTURE\nPATH=${RCUTORTURE}/bin:$PATH; export PATH\n. functions.sh\n\nstarttime=\"`get_starttime`\"\n\nsystems=\"$1\"\nif test -z \"$systems\"\nthen\n\techo $scriptname: Empty list of systems will go nowhere good, giving up.\n\texit 1\nfi\nshift\n\n# Pathnames:\n# T:\t  /tmp/kvm-remote.sh.NNNNNN where \"NNNNNN\" is set by mktemp\n# resdir: /tmp/kvm-remote.sh.NNNNNN/res\n# rundir: /tmp/kvm-remote.sh.NNNNNN/res/$ds (\"-remote\" suffix)\n# oldrun: `pwd`/tools/testing/.../res/$otherds\n#\n# Pathname segments:\n# TD:\t  kvm-remote.sh.NNNNNN\n# ds:\t  yyyy.mm.dd-hh.mm.ss-remote\n\nT=\"`mktemp -d ${TMPDIR-/tmp}/kvm-remote.sh.XXXXXX`\"\ntrap 'rm -rf $T' 0\nTD=\"`basename \"$T\"`\"\n\nresdir=\"$T/res\"\nds=`date +%Y.%m.%d-%H.%M.%S`-remote\nrundir=$resdir/$ds\necho Results directory: $rundir\necho $scriptname $args\nif echo $1 | grep -q '^--'\nthen\n\t# Fresh build.  Create a datestamp unless the caller supplied one.\n\tdatestamp=\"`echo \"$@\" | awk -v ds=\"$ds\" '{\n\t\tfor (i = 1; i < NF; i++) {\n\t\t\tif ($i == \"--datestamp\") {\n\t\t\t\tds = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ds != \"\")\n\t\t\tprint \"--datestamp \" ds;\n\t}'`\"\n\tkvm.sh --remote \"$@\" $datestamp --buildonly > $T/kvm.sh.out 2>&1\n\tret=$?\n\tif test \"$ret\" -ne 0\n\tthen\n\t\techo $scriptname: kvm.sh failed exit code $?\n\t\tcat $T/kvm.sh.out\n\t\texit 2\n\tfi\n\toldrun=\"`grep -m 1 \"^Results directory: \" $T/kvm.sh.out | awk '{ print $3 }'`\"\n\ttouch \"$oldrun/remote-log\"\n\techo $scriptname $args >> \"$oldrun/remote-log\"\n\techo | tee -a \"$oldrun/remote-log\"\n\techo \" ----\" kvm.sh output: \"(`date`)\" | tee -a \"$oldrun/remote-log\"\n\tcat $T/kvm.sh.out | tee -a \"$oldrun/remote-log\"\n\t# We are going to run this, so remove the buildonly files.\n\trm -f \"$oldrun\"/*/buildonly\n\tkvm-again.sh $oldrun --dryrun --remote --rundir \"$rundir\" > $T/kvm-again.sh.out 2>&1\n\tret=$?\n\tif test \"$ret\" -ne 0\n\tthen\n\t\techo $scriptname: kvm-again.sh failed exit code $? | tee -a \"$oldrun/remote-log\"\n\t\tcat $T/kvm-again.sh.out | tee -a \"$oldrun/remote-log\"\n\t\texit 2\n\tfi\nelse\n\t# Re-use old run.\n\toldrun=\"$1\"\n\tif ! echo $oldrun | grep -q '^/'\n\tthen\n\t\toldrun=\"`pwd`/$oldrun\"\n\tfi\n\tshift\n\ttouch \"$oldrun/remote-log\"\n\techo $scriptname $args >> \"$oldrun/remote-log\"\n\tkvm-again.sh \"$oldrun\" \"$@\" --dryrun --remote --rundir \"$rundir\" > $T/kvm-again.sh.out 2>&1\n\tret=$?\n\tif test \"$ret\" -ne 0\n\tthen\n\t\techo $scriptname: kvm-again.sh failed exit code $? | tee -a \"$oldrun/remote-log\"\n\t\tcat $T/kvm-again.sh.out | tee -a \"$oldrun/remote-log\"\n\t\texit 2\n\tfi\n\tcp -a \"$rundir\" \"$RCUTORTURE/res/\"\n\toldrun=\"$RCUTORTURE/res/$ds\"\nfi\necho | tee -a \"$oldrun/remote-log\"\necho \" ----\" kvm-again.sh output: \"(`date`)\" | tee -a \"$oldrun/remote-log\"\ncat $T/kvm-again.sh.out\necho | tee -a \"$oldrun/remote-log\"\necho Remote run directory: $rundir | tee -a \"$oldrun/remote-log\"\necho Local build-side run directory: $oldrun | tee -a \"$oldrun/remote-log\"\n\n# Create the kvm-remote-N.sh scripts in the bin directory.\nawk < \"$rundir\"/scenarios -v dest=\"$T/bin\" -v rundir=\"$rundir\" '\n{\n\tn = $1;\n\tsub(/\\./, \"\", n);\n\tfn = dest \"/kvm-remote-\" n \".sh\"\n\tprint \"kvm-remote-noreap.sh \" rundir \" &\" > fn;\n\tscenarios = \"\";\n\tfor (i = 2; i <= NF; i++)\n\t\tscenarios = scenarios \" \" $i;\n\tprint \"kvm-test-1-run-batch.sh\" scenarios >> fn;\n\tprint \"sync\" >> fn;\n\tprint \"rm \" rundir \"/remote.run\" >> fn;\n}'\nchmod +x $T/bin/kvm-remote-*.sh\n( cd \"`dirname $T`\"; tar -chzf $T/binres.tgz \"$TD/bin\" \"$TD/res\" )\n\n# Check first to avoid the need for cleanup for system-name typos\nfor i in $systems\ndo\n\tssh -o BatchMode=yes $i getconf _NPROCESSORS_ONLN > $T/ssh.stdout 2> $T/ssh.stderr\n\tret=$?\n\tif test \"$ret\" -ne 0\n\tthen\n\t\techo \"System $i unreachable ($ret), giving up.\" | tee -a \"$oldrun/remote-log\"\n\t\techo ' --- ssh stdout: vvv' | tee -a \"$oldrun/remote-log\"\n\t\tcat $T/ssh.stdout | tee -a \"$oldrun/remote-log\"\n\t\techo ' --- ssh stdout: ^^^' | tee -a \"$oldrun/remote-log\"\n\t\techo ' --- ssh stderr: vvv' | tee -a \"$oldrun/remote-log\"\n\t\tcat $T/ssh.stderr | tee -a \"$oldrun/remote-log\"\n\t\techo ' --- ssh stderr: ^^^' | tee -a \"$oldrun/remote-log\"\n\t\texit 4\n\tfi\n\techo $i: `cat $T/ssh.stdout` CPUs \" \" `date` | tee -a \"$oldrun/remote-log\"\ndone\n\n# Download and expand the tarball on all systems.\necho Build-products tarball: `du -h $T/binres.tgz` | tee -a \"$oldrun/remote-log\"\nfor i in $systems\ndo\n\techo Downloading tarball to $i `date` | tee -a \"$oldrun/remote-log\"\n\tcat $T/binres.tgz | ssh -o BatchMode=yes $i \"cd /tmp; tar -xzf -\"\n\tret=$?\n\ttries=0\n\twhile test \"$ret\" -ne 0\n\tdo\n\t\techo Unable to download $T/binres.tgz to system $i, waiting and then retrying.  $tries prior retries. | tee -a \"$oldrun/remote-log\"\n\t\tsleep 60\n\t\tcat $T/binres.tgz | ssh -o BatchMode=yes $i \"cd /tmp; tar -xzf -\"\n\t\tret=$?\n\t\tif test \"$ret\" -ne 0\n\t\tthen\n\t\t\tif test \"$tries\" > 5\n\t\t\tthen\n\t\t\t\techo Unable to download $T/binres.tgz to system $i, giving up. | tee -a \"$oldrun/remote-log\"\n\t\t\t\texit 10\n\t\t\tfi\n\t\tfi\n\t\ttries=$((tries+1))\n\tdone\ndone\n\n# Function to check for presence of a file on the specified system.\n# Complain if the system cannot be reached, and retry after a wait.\n# Currently just waits forever if a machine disappears.\n#\n# Usage: checkremotefile system pathname\ncheckremotefile () {\n\tlocal ret\n\tlocal sleeptime=60\n\n\twhile :\n\tdo\n\t\tssh -o BatchMode=yes $1 \"test -f \\\"$2\\\"\"\n\t\tret=$?\n\t\tif test \"$ret\" -eq 255\n\t\tthen\n\t\t\techo \" ---\" ssh failure to $1 checking for file $2, retry after $sleeptime seconds. `date` | tee -a \"$oldrun/remote-log\"\n\t\telif test \"$ret\" -eq 0\n\t\tthen\n\t\t\treturn 0\n\t\telif test \"$ret\" -eq 1\n\t\tthen\n\t\t\techo \" ---\" File \\\"$2\\\" not found: ssh $1 test -f \\\"$2\\\" | tee -a \"$oldrun/remote-log\"\n\t\t\treturn 1\n\t\telse\n\t\t\techo \" ---\" Exit code $ret: ssh $1 test -f \\\"$2\\\", retry after $sleeptime seconds. `date` | tee -a \"$oldrun/remote-log\"\n\t\t\treturn $ret\n\t\tfi\n\t\tsleep $sleeptime\n\tdone\n}\n\n# Function to start batches on idle remote $systems\n#\n# Usage: startbatches curbatch nbatches\n#\n# Batches are numbered starting at 1.  Returns the next batch to start.\n# Be careful to redirect all debug output to FD 2 (stderr).\nstartbatches () {\n\tlocal curbatch=\"$1\"\n\tlocal nbatches=\"$2\"\n\tlocal ret\n\n\t# Each pass through the following loop examines one system.\n\tfor i in $systems\n\tdo\n\t\tif test \"$curbatch\" -gt \"$nbatches\"\n\t\tthen\n\t\t\techo $((nbatches + 1))\n\t\t\treturn 0\n\t\tfi\n\t\tif checkremotefile \"$i\" \"$resdir/$ds/remote.run\" 1>&2\n\t\tthen\n\t\t\tcontinue # System still running last test, skip.\n\t\tfi\n\t\tssh -o BatchMode=yes \"$i\" \"cd \\\"$resdir/$ds\\\"; touch remote.run; PATH=\\\"$T/bin:$PATH\\\" nohup kvm-remote-$curbatch.sh > kvm-remote-$curbatch.sh.out 2>&1 &\" 1>&2\n\t\tret=$?\n\t\tif test \"$ret\" -ne 0\n\t\tthen\n\t\t\techo ssh $i failed: exitcode $ret 1>&2\n\t\t\texit 11\n\t\tfi\n\t\techo \" ----\" System $i Batch `head -n $curbatch < \"$rundir\"/scenarios | tail -1` `date` 1>&2\n\t\tcurbatch=$((curbatch + 1))\n\tdone\n\techo $curbatch\n}\n\n# Launch all the scenarios.\nnbatches=\"`wc -l \"$rundir\"/scenarios | awk '{ print $1 }'`\"\ncurbatch=1\nwhile test \"$curbatch\" -le \"$nbatches\"\ndo\n\tstartbatches $curbatch $nbatches > $T/curbatch 2> $T/startbatches.stderr\n\tcurbatch=\"`cat $T/curbatch`\"\n\tif test -s \"$T/startbatches.stderr\"\n\tthen\n\t\tcat \"$T/startbatches.stderr\" | tee -a \"$oldrun/remote-log\"\n\tfi\n\tif test \"$curbatch\" -le \"$nbatches\"\n\tthen\n\t\tsleep 30\n\tfi\ndone\necho All batches started. `date` | tee -a \"$oldrun/remote-log\"\n\n# Wait for all remaining scenarios to complete and collect results.\nfor i in $systems\ndo\n\techo \" ---\" Waiting for $i `date` | tee -a \"$oldrun/remote-log\"\n\twhile checkremotefile \"$i\" \"$resdir/$ds/remote.run\"\n\tdo\n\t\tsleep 30\n\tdone\n\techo \" ---\" Collecting results from $i `date` | tee -a \"$oldrun/remote-log\"\n\t( cd \"$oldrun\"; ssh -o BatchMode=yes $i \"cd $rundir; tar -czf - kvm-remote-*.sh.out */console.log */kvm-test-1-run*.sh.out */qemu[_-]pid */qemu-retval */qemu-affinity; rm -rf $T > /dev/null 2>&1\" | tar -xzf - )\ndone\n\n( kvm-end-run-stats.sh \"$oldrun\" \"$starttime\"; echo $? > $T/exitcode ) | tee -a \"$oldrun/remote-log\"\nexit \"`cat $T/exitcode`\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}