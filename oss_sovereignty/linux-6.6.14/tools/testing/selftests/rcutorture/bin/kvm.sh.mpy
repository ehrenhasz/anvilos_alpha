{
  "module_name": "kvm.sh",
  "hash_id": "b642c39d8f6f592ecd6f18bdebfb332d6c347078842957070624b94c36967527",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/rcutorture/bin/kvm.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0+\n#\n# Run a series of tests under KVM.  By default, this series is specified\n# by the relevant CFLIST file, but can be overridden by the --configs\n# command-line argument.\n#\n# Usage: kvm.sh [ options ]\n#\n# Copyright (C) IBM Corporation, 2011\n#\n# Authors: Paul E. McKenney <paulmck@linux.ibm.com>\n\nscriptname=$0\nargs=\"$*\"\n\nT=\"`mktemp -d ${TMPDIR-/tmp}/kvm.sh.XXXXXX`\"\ntrap 'rm -rf $T' 0\n\ncd `dirname $scriptname`/../../../../../\n\n# This script knows only English.\nLANG=en_US.UTF-8; export LANG\n\ndur=$((30*60))\ndryrun=\"\"\nRCUTORTURE=\"`pwd`/tools/testing/selftests/rcutorture\"; export RCUTORTURE\nPATH=${RCUTORTURE}/bin:$PATH; export PATH\n. functions.sh\n\nTORTURE_ALLOTED_CPUS=\"`identify_qemu_vcpus`\"\nTORTURE_DEFCONFIG=defconfig\nTORTURE_BOOT_IMAGE=\"\"\nTORTURE_BUILDONLY=\nTORTURE_INITRD=\"$RCUTORTURE/initrd\"; export TORTURE_INITRD\nTORTURE_KCONFIG_ARG=\"\"\nTORTURE_KCONFIG_GDB_ARG=\"\"\nTORTURE_BOOT_GDB_ARG=\"\"\nTORTURE_QEMU_GDB_ARG=\"\"\nTORTURE_JITTER_START=\"\"\nTORTURE_JITTER_STOP=\"\"\nTORTURE_KCONFIG_KASAN_ARG=\"\"\nTORTURE_KCONFIG_KCSAN_ARG=\"\"\nTORTURE_KMAKE_ARG=\"\"\nTORTURE_QEMU_MEM=512\ntorture_qemu_mem_default=1\nTORTURE_REMOTE=\nTORTURE_SHUTDOWN_GRACE=180\nTORTURE_SUITE=rcu\nTORTURE_MOD=rcutorture\nTORTURE_TRUST_MAKE=\"\"\nresdir=\"\"\nconfigs=\"\"\ncpus=0\nds=`date +%Y.%m.%d-%H.%M.%S`\njitter=\"-1\"\n\nstartdate=\"`date`\"\nstarttime=\"`get_starttime`\"\n\nusage () {\n\techo \"Usage: $scriptname optional arguments:\"\n\techo \"       --allcpus\"\n\techo \"       --bootargs kernel-boot-arguments\"\n\techo \"       --bootimage relative-path-to-kernel-boot-image\"\n\techo \"       --buildonly\"\n\techo \"       --configs \\\"config-file list w/ repeat factor (3*TINY01)\\\"\"\n\techo \"       --cpus N\"\n\techo \"       --datestamp string\"\n\techo \"       --defconfig string\"\n\techo \"       --dryrun batches|scenarios|sched|script\"\n\techo \"       --duration minutes | <seconds>s | <hours>h | <days>d\"\n\techo \"       --gdb\"\n\techo \"       --help\"\n\techo \"       --interactive\"\n\techo \"       --jitter N [ maxsleep (us) [ maxspin (us) ] ]\"\n\techo \"       --kasan\"\n\techo \"       --kconfig Kconfig-options\"\n\techo \"       --kcsan\"\n\techo \"       --kmake-arg kernel-make-arguments\"\n\techo \"       --mac nn:nn:nn:nn:nn:nn\"\n\techo \"       --memory megabytes|nnnG\"\n\techo \"       --no-initrd\"\n\techo \"       --qemu-args qemu-arguments\"\n\techo \"       --qemu-cmd qemu-system-...\"\n\techo \"       --remote\"\n\techo \"       --results absolute-pathname\"\n\techo \"       --shutdown-grace seconds\"\n\techo \"       --torture lock|rcu|rcuscale|refscale|scf|X*\"\n\techo \"       --trust-make\"\n\texit 1\n}\n\nwhile test $# -gt 0\ndo\n\tcase \"$1\" in\n\t--allcpus)\n\t\tcpus=$TORTURE_ALLOTED_CPUS\n\t\tmax_cpus=$TORTURE_ALLOTED_CPUS\n\t\t;;\n\t--bootargs|--bootarg)\n\t\tcheckarg --bootargs \"(list of kernel boot arguments)\" \"$#\" \"$2\" '.*' '^--'\n\t\tTORTURE_BOOTARGS=\"$TORTURE_BOOTARGS $2\"\n\t\tshift\n\t\t;;\n\t--bootimage)\n\t\tcheckarg --bootimage \"(relative path to kernel boot image)\" \"$#\" \"$2\" '[a-zA-Z0-9][a-zA-Z0-9_]*' '^--'\n\t\tTORTURE_BOOT_IMAGE=\"$2\"\n\t\tshift\n\t\t;;\n\t--buildonly|--build-only)\n\t\tTORTURE_BUILDONLY=1\n\t\t;;\n\t--configs|--config)\n\t\tcheckarg --configs \"(list of config files)\" \"$#\" \"$2\" '^[^/.a-z]\\+$' '^--'\n\t\tconfigs=\"$configs $2\"\n\t\tshift\n\t\t;;\n\t--cpus)\n\t\tcheckarg --cpus \"(number)\" \"$#\" \"$2\" '^[0-9]*$' '^--'\n\t\tcpus=$2\n\t\tTORTURE_ALLOTED_CPUS=\"$2\"\n\t\tif test -z \"$TORTURE_REMOTE\"\n\t\tthen\n\t\t\tmax_cpus=\"`identify_qemu_vcpus`\"\n\t\t\tif test \"$TORTURE_ALLOTED_CPUS\" -gt \"$max_cpus\"\n\t\t\tthen\n\t\t\t\tTORTURE_ALLOTED_CPUS=$max_cpus\n\t\t\tfi\n\t\tfi\n\t\tshift\n\t\t;;\n\t--datestamp)\n\t\tcheckarg --datestamp \"(relative pathname)\" \"$#\" \"$2\" '^[a-zA-Z0-9._/-]*$' '^--'\n\t\tds=$2\n\t\tshift\n\t\t;;\n\t--defconfig)\n\t\tcheckarg --defconfig \"defconfigtype\" \"$#\" \"$2\" '^[^/][^/]*$' '^--'\n\t\tTORTURE_DEFCONFIG=$2\n\t\tshift\n\t\t;;\n\t--dryrun)\n\t\tcheckarg --dryrun \"batches|sched|script\" $# \"$2\" 'batches\\|scenarios\\|sched\\|script' '^--'\n\t\tdryrun=$2\n\t\tshift\n\t\t;;\n\t--duration)\n\t\tcheckarg --duration \"(minutes)\" $# \"$2\" '^[0-9][0-9]*\\(s\\|m\\|h\\|d\\|\\)$' '^error'\n\t\tmult=60\n\t\tif echo \"$2\" | grep -q 's$'\n\t\tthen\n\t\t\tmult=1\n\t\telif echo \"$2\" | grep -q 'h$'\n\t\tthen\n\t\t\tmult=3600\n\t\telif echo \"$2\" | grep -q 'd$'\n\t\tthen\n\t\t\tmult=86400\n\t\tfi\n\t\tts=`echo $2 | sed -e 's/[smhd]$//'`\n\t\tdur=$(($ts*mult))\n\t\tshift\n\t\t;;\n\t--gdb)\n\t\tTORTURE_KCONFIG_GDB_ARG=\"CONFIG_DEBUG_INFO_NONE=n CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y\"; export TORTURE_KCONFIG_GDB_ARG\n\t\tTORTURE_BOOT_GDB_ARG=\"nokaslr\"; export TORTURE_BOOT_GDB_ARG\n\t\tTORTURE_QEMU_GDB_ARG=\"-s -S\"; export TORTURE_QEMU_GDB_ARG\n\t\t;;\n\t--help|-h)\n\t\tusage\n\t\t;;\n\t--interactive)\n\t\tTORTURE_QEMU_INTERACTIVE=1; export TORTURE_QEMU_INTERACTIVE\n\t\t;;\n\t--jitter)\n\t\tcheckarg --jitter \"(# threads [ sleep [ spin ] ])\" $# \"$2\" '^-\\{,1\\}[0-9]\\+\\( \\+[0-9]\\+\\)\\{,2\\} *$' '^error$'\n\t\tjitter=\"$2\"\n\t\tshift\n\t\t;;\n\t--kasan)\n\t\tTORTURE_KCONFIG_KASAN_ARG=\"CONFIG_DEBUG_INFO_NONE=n CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y CONFIG_KASAN=y\"; export TORTURE_KCONFIG_KASAN_ARG\n\t\tif test -n \"$torture_qemu_mem_default\"\n\t\tthen\n\t\t\tTORTURE_QEMU_MEM=2G\n\t\tfi\n\t\t;;\n\t--kconfig|--kconfigs)\n\t\tcheckarg --kconfig \"(Kconfig options)\" $# \"$2\" '^\\(#CHECK#\\)\\?CONFIG_[A-Z0-9_]\\+=\\([ynm]\\|[0-9]\\+\\|\"[^\"]*\"\\)\\( \\(#CHECK#\\)\\?CONFIG_[A-Z0-9_]\\+=\\([ynm]\\|[0-9]\\+\\|\"[^\"]*\"\\)\\)*$' '^error$'\n\t\tTORTURE_KCONFIG_ARG=\"`echo \"$TORTURE_KCONFIG_ARG $2\" | sed -e 's/^ *//' -e 's/ *$//'`\"\n\t\tshift\n\t\t;;\n\t--kcsan)\n\t\tTORTURE_KCONFIG_KCSAN_ARG=\"CONFIG_DEBUG_INFO_NONE=n CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y CONFIG_KCSAN=y CONFIG_KCSAN_STRICT=y CONFIG_KCSAN_REPORT_ONCE_IN_MS=100000 CONFIG_KCSAN_VERBOSE=y CONFIG_DEBUG_LOCK_ALLOC=y CONFIG_PROVE_LOCKING=y\"; export TORTURE_KCONFIG_KCSAN_ARG\n\t\t;;\n\t--kmake-arg|--kmake-args)\n\t\tcheckarg --kmake-arg \"(kernel make arguments)\" $# \"$2\" '.*' '^error$'\n\t\tTORTURE_KMAKE_ARG=\"`echo \"$TORTURE_KMAKE_ARG $2\" | sed -e 's/^ *//' -e 's/ *$//'`\"\n\t\tshift\n\t\t;;\n\t--mac)\n\t\tcheckarg --mac \"(MAC address)\" $# \"$2\" '^\\([0-9a-fA-F]\\{2\\}:\\)\\{5\\}[0-9a-fA-F]\\{2\\}$' error\n\t\tTORTURE_QEMU_MAC=$2\n\t\tshift\n\t\t;;\n\t--memory)\n\t\tcheckarg --memory \"(memory size)\" $# \"$2\" '^[0-9]\\+[MG]\\?$' error\n\t\tTORTURE_QEMU_MEM=$2\n\t\ttorture_qemu_mem_default=\n\t\tshift\n\t\t;;\n\t--no-initrd)\n\t\tTORTURE_INITRD=\"\"; export TORTURE_INITRD\n\t\t;;\n\t--qemu-args|--qemu-arg)\n\t\tcheckarg --qemu-args \"(qemu arguments)\" $# \"$2\" '^-' '^error'\n\t\tTORTURE_QEMU_ARG=\"`echo \"$TORTURE_QEMU_ARG $2\" | sed -e 's/^ *//' -e 's/ *$//'`\"\n\t\tshift\n\t\t;;\n\t--qemu-cmd)\n\t\tcheckarg --qemu-cmd \"(qemu-system-...)\" $# \"$2\" 'qemu-system-' '^--'\n\t\tTORTURE_QEMU_CMD=\"$2\"\n\t\tshift\n\t\t;;\n\t--remote)\n\t\tTORTURE_REMOTE=1\n\t\t;;\n\t--results)\n\t\tcheckarg --results \"(absolute pathname)\" \"$#\" \"$2\" '^/' '^error'\n\t\tresdir=$2\n\t\tshift\n\t\t;;\n\t--shutdown-grace)\n\t\tcheckarg --shutdown-grace \"(seconds)\" \"$#\" \"$2\" '^[0-9]*$' '^error'\n\t\tTORTURE_SHUTDOWN_GRACE=$2\n\t\tshift\n\t\t;;\n\t--torture)\n\t\tcheckarg --torture \"(suite name)\" \"$#\" \"$2\" '^\\(lock\\|rcu\\|rcuscale\\|refscale\\|scf\\|X.*\\)$' '^--'\n\t\tTORTURE_SUITE=$2\n\t\tTORTURE_MOD=\"`echo $TORTURE_SUITE | sed -e 's/^\\(lock\\|rcu\\|scf\\)$/\\1torture/'`\"\n\t\tshift\n\t\tif test \"$TORTURE_SUITE\" = rcuscale || test \"$TORTURE_SUITE\" = refscale\n\t\tthen\n\t\t\t# If you really want jitter for refscale or\n\t\t\t# rcuscale, specify it after specifying the rcuscale\n\t\t\t# or the refscale.  (But why jitter in these cases?)\n\t\t\tjitter=0\n\t\tfi\n\t\t;;\n\t--trust-make)\n\t\tTORTURE_TRUST_MAKE=\"y\"\n\t\t;;\n\t*)\n\t\techo Unknown argument $1\n\t\tusage\n\t\t;;\n\tesac\n\tshift\ndone\n\nif test -n \"$dryrun\" || test -z \"$TORTURE_INITRD\" || tools/testing/selftests/rcutorture/bin/mkinitrd.sh\nthen\n\t:\nelse\n\techo No initrd and unable to create one, aborting test >&2\n\texit 1\nfi\n\nCONFIGFRAG=${RCUTORTURE}/configs/${TORTURE_SUITE}; export CONFIGFRAG\n\ndefaultconfigs=\"`tr '\\012' ' ' < $CONFIGFRAG/CFLIST`\"\nif test -z \"$configs\"\nthen\n\tconfigs=$defaultconfigs\nfi\n\nif test -z \"$resdir\"\nthen\n\tresdir=$RCUTORTURE/res\nfi\n\n# Create a file of test-name/#cpus pairs, sorted by decreasing #cpus.\nconfigs_derep=\nfor CF in $configs\ndo\n\tcase $CF in\n\t[0-9]\\**|[0-9][0-9]\\**|[0-9][0-9][0-9]\\**|[0-9][0-9][0-9][0-9]\\**)\n\t\tconfig_reps=`echo $CF | sed -e 's/\\*.*$//'`\n\t\tCF1=`echo $CF | sed -e 's/^[^*]*\\*//'`\n\t\t;;\n\t*)\n\t\tconfig_reps=1\n\t\tCF1=$CF\n\t\t;;\n\tesac\n\tfor ((cur_rep=0;cur_rep<$config_reps;cur_rep++))\n\tdo\n\t\tconfigs_derep=\"$configs_derep $CF1\"\n\tdone\ndone\ntouch $T/cfgcpu\nconfigs_derep=\"`echo $configs_derep | sed -e \"s/\\<CFLIST\\>/$defaultconfigs/g\"`\"\nif test -n \"$TORTURE_KCONFIG_GDB_ARG\"\nthen\n\tif test \"`echo $configs_derep | wc -w`\" -gt 1\n\tthen\n\t\techo \"The --config list is: $configs_derep.\"\n\t\techo \"Only one --config permitted with --gdb, terminating.\"\n\t\texit 1\n\tfi\nfi\necho 'BEGIN {' > $T/cfgcpu.awk\nfor CF1 in `echo $configs_derep | tr -s ' ' '\\012' | sort -u`\ndo\n\tif test -f \"$CONFIGFRAG/$CF1\"\n\tthen\n\t\tif echo \"$TORTURE_KCONFIG_ARG\" | grep -q '\\<CONFIG_NR_CPUS='\n\t\tthen\n\t\t\techo \"$TORTURE_KCONFIG_ARG\" | tr -s ' ' | tr ' ' '\\012' > $T/KCONFIG_ARG\n\t\t\tcpu_count=`configNR_CPUS.sh $T/KCONFIG_ARG`\n\t\telse\n\t\t\tcpu_count=`configNR_CPUS.sh $CONFIGFRAG/$CF1`\n\t\tfi\n\t\tcpu_count=`configfrag_boot_cpus \"$TORTURE_BOOTARGS\" \"$CONFIGFRAG/$CF1\" \"$cpu_count\"`\n\t\tcpu_count=`configfrag_boot_maxcpus \"$TORTURE_BOOTARGS\" \"$CONFIGFRAG/$CF1\" \"$cpu_count\"`\n\t\techo 'scenariocpu[\"'\"$CF1\"'\"] = '\"$cpu_count\"';' >> $T/cfgcpu.awk\n\telse\n\t\techo \"The --configs file $CF1 does not exist, terminating.\"\n\t\texit 1\n\tfi\ndone\ncat << '___EOF___' >> $T/cfgcpu.awk\n}\n{\n\tfor (i = 1; i <= NF; i++)\n\t\tprint $i, scenariocpu[$i];\n}\n___EOF___\necho $configs_derep | awk -f $T/cfgcpu.awk > $T/cfgcpu\nsort -k2nr $T/cfgcpu -T=\"$T\" > $T/cfgcpu.sort\n\n# Use a greedy bin-packing algorithm, sorting the list accordingly.\nawk < $T/cfgcpu.sort > $T/cfgcpu.pack -v ncpus=$cpus '\nBEGIN {\n\tnjobs = 0;\n}\n\n{\n\t# Read file of tests and corresponding required numbers of CPUs.\n\tcf[njobs] = $1;\n\tcpus[njobs] = $2;\n\tnjobs++;\n}\n\nEND {\n\tbatch = 0;\n\tnc = -1;\n\n\t# Each pass through the following loop creates on test batch that\n\t# can be executed concurrently given ncpus.  Note that a given test\n\t# that requires more than the available CPUs will run in its own\n\t# batch.  Such tests just have to make do with what is available.\n\twhile (nc != ncpus) {\n\t\tbatch++;\n\t\tnc = ncpus;\n\n\t\t# Each pass through the following loop considers one\n\t\t# test for inclusion in the current batch.\n\t\tfor (i = 0; i < njobs; i++) {\n\t\t\tif (done[i])\n\t\t\t\tcontinue; # Already part of a batch.\n\t\t\tif (nc >= cpus[i] || nc == ncpus) {\n\n\t\t\t\t# This test fits into the current batch.\n\t\t\t\tdone[i] = batch;\n\t\t\t\tnc -= cpus[i];\n\t\t\t\tif (nc <= 0)\n\t\t\t\t\tbreak; # Too-big test in its own batch.\n\t\t\t}\n\t\t}\n\t}\n\n\t# Dump out the tests in batch order.\n\tfor (b = 1; b <= batch; b++)\n\t\tfor (i = 0; i < njobs; i++)\n\t\t\tif (done[i] == b)\n\t\t\t\tprint cf[i], cpus[i];\n}'\n\n# Generate a script to execute the tests in appropriate batches.\ncat << ___EOF___ > $T/script\nCONFIGFRAG=\"$CONFIGFRAG\"; export CONFIGFRAG\nRCUTORTURE=\"$RCUTORTURE\"; export RCUTORTURE\nPATH=\"$PATH\"; export PATH\nTORTURE_ALLOTED_CPUS=\"$TORTURE_ALLOTED_CPUS\"; export TORTURE_ALLOTED_CPUS\nTORTURE_BOOT_IMAGE=\"$TORTURE_BOOT_IMAGE\"; export TORTURE_BOOT_IMAGE\nTORTURE_BUILDONLY=\"$TORTURE_BUILDONLY\"; export TORTURE_BUILDONLY\nTORTURE_DEFCONFIG=\"$TORTURE_DEFCONFIG\"; export TORTURE_DEFCONFIG\nTORTURE_INITRD=\"$TORTURE_INITRD\"; export TORTURE_INITRD\nTORTURE_KCONFIG_ARG=\"$TORTURE_KCONFIG_ARG\"; export TORTURE_KCONFIG_ARG\nTORTURE_KCONFIG_GDB_ARG=\"$TORTURE_KCONFIG_GDB_ARG\"; export TORTURE_KCONFIG_GDB_ARG\nTORTURE_BOOT_GDB_ARG=\"$TORTURE_BOOT_GDB_ARG\"; export TORTURE_BOOT_GDB_ARG\nTORTURE_QEMU_GDB_ARG=\"$TORTURE_QEMU_GDB_ARG\"; export TORTURE_QEMU_GDB_ARG\nTORTURE_KCONFIG_KASAN_ARG=\"$TORTURE_KCONFIG_KASAN_ARG\"; export TORTURE_KCONFIG_KASAN_ARG\nTORTURE_KCONFIG_KCSAN_ARG=\"$TORTURE_KCONFIG_KCSAN_ARG\"; export TORTURE_KCONFIG_KCSAN_ARG\nTORTURE_KMAKE_ARG=\"$TORTURE_KMAKE_ARG\"; export TORTURE_KMAKE_ARG\nTORTURE_MOD=\"$TORTURE_MOD\"; export TORTURE_MOD\nTORTURE_QEMU_CMD=\"$TORTURE_QEMU_CMD\"; export TORTURE_QEMU_CMD\nTORTURE_QEMU_INTERACTIVE=\"$TORTURE_QEMU_INTERACTIVE\"; export TORTURE_QEMU_INTERACTIVE\nTORTURE_QEMU_MAC=\"$TORTURE_QEMU_MAC\"; export TORTURE_QEMU_MAC\nTORTURE_QEMU_MEM=\"$TORTURE_QEMU_MEM\"; export TORTURE_QEMU_MEM\nTORTURE_SHUTDOWN_GRACE=\"$TORTURE_SHUTDOWN_GRACE\"; export TORTURE_SHUTDOWN_GRACE\nTORTURE_SUITE=\"$TORTURE_SUITE\"; export TORTURE_SUITE\nTORTURE_TRUST_MAKE=\"$TORTURE_TRUST_MAKE\"; export TORTURE_TRUST_MAKE\nif ! test -e $resdir\nthen\n\tmkdir -p \"$resdir\" || :\nfi\nmkdir -p $resdir/$ds\nTORTURE_RESDIR=\"$resdir/$ds\"; export TORTURE_RESDIR\nTORTURE_STOPFILE=\"$resdir/$ds/STOP.1\"; export TORTURE_STOPFILE\necho Results directory: $resdir/$ds\necho $scriptname $args\ntouch $resdir/$ds/log\necho $scriptname $args >> $resdir/$ds/log\necho ${TORTURE_SUITE} > $resdir/$ds/torture_suite\necho Build directory: `pwd` > $resdir/$ds/testid.txt\nif test -d .git\nthen\n\techo Current commit: `git rev-parse HEAD` >> $resdir/$ds/testid.txt\n\techo >> $resdir/$ds/testid.txt\n\techo ' ---' Output of \"'\"git status\"'\": >> $resdir/$ds/testid.txt\n\tgit status >> $resdir/$ds/testid.txt\n\techo >> $resdir/$ds/testid.txt\n\techo >> $resdir/$ds/testid.txt\n\techo ' ---' Output of \"'\"git diff HEAD\"'\": >> $resdir/$ds/testid.txt\n\tgit diff HEAD >> $resdir/$ds/testid.txt\nfi\n___EOF___\nkvm-assign-cpus.sh /sys/devices/system/node > $T/cpuarray.awk\nkvm-get-cpus-script.sh $T/cpuarray.awk $T/dumpbatches.awk\ncat << '___EOF___' >> $T/dumpbatches.awk\nBEGIN {\n\ti = 0;\n}\n\n{\n\tcf[i] = $1;\n\tcpus[i] = $2;\n\ti++;\n}\n\n# Dump out the scripting required to run one test batch.\nfunction dump(first, pastlast, batchnum,  affinitylist)\n{\n\tprint \"echo ----Start batch \" batchnum \": `date` | tee -a \" rd \"log\";\n\tprint \"needqemurun=\"\n\tjn=1\n\tnjitter = 0;\n\tsplit(jitter, ja);\n\tif (ja[1] == -1 && ncpus == 0)\n\t\tnjitter = 1;\n\telse if (ja[1] == -1)\n\t\tnjitter = ncpus;\n\telse\n\t\tnjitter = ja[1];\n\tprint \"TORTURE_JITTER_START=\\\". jitterstart.sh \" njitter \" \" rd \" \" dur \" \" ja[2] \" \" ja[3] \"\\\"; export TORTURE_JITTER_START\";\n\tprint \"TORTURE_JITTER_STOP=\\\". jitterstop.sh \" rd \" \\\"; export TORTURE_JITTER_STOP\"\n\tfor (j = first; j < pastlast; j++) {\n\t\tcpusr[jn] = cpus[j];\n\t\tif (cfrep[cf[j]] == \"\") {\n\t\t\tcfr[jn] = cf[j];\n\t\t\tcfrep[cf[j]] = 1;\n\t\t} else {\n\t\t\tcfrep[cf[j]]++;\n\t\t\tcfr[jn] = cf[j] \".\" cfrep[cf[j]];\n\t\t}\n\t\tbuilddir=rd cfr[jn] \"/build\";\n\t\tif (cpusr[jn] > ncpus && ncpus != 0)\n\t\t\tovf = \"-ovf\";\n\t\telse\n\t\t\tovf = \"\";\n\t\tprint \"echo \", cfr[jn], cpusr[jn] ovf \": Starting build. `date` | tee -a \" rd \"log\";\n\t\tprint \"mkdir \" rd cfr[jn] \" || :\";\n\t\tprint \"touch \" builddir \".wait\";\n\t\taffinitylist = \"\";\n\t\tif (gotcpus()) {\n\t\t\taffinitylist = nextcpus(cpusr[jn]);\n\t\t}\n\t\tif (affinitylist ~ /^[0-9,-][0-9,-]*$/)\n\t\t\tprint \"export TORTURE_AFFINITY=\" affinitylist;\n\t\telse\n\t\t\tprint \"export TORTURE_AFFINITY=\";\n\t\tprint \"kvm-test-1-run.sh \" CONFIGDIR cf[j], rd cfr[jn], dur \" \\\"\" TORTURE_QEMU_ARG \"\\\" \\\"\" TORTURE_BOOTARGS \"\\\" > \" rd cfr[jn]  \"/kvm-test-1-run.sh.out 2>&1 &\"\n\t\tprint \"echo \", cfr[jn], cpusr[jn] ovf \": Waiting for build to complete. `date` | tee -a \" rd \"log\";\n\t\tprint \"while test -f \" builddir \".wait\"\n\t\tprint \"do\"\n\t\tprint \"\\tsleep 1\"\n\t\tprint \"done\"\n\t\tprint \"echo \", cfr[jn], cpusr[jn] ovf \": Build complete. `date` | tee -a \" rd \"log\";\n\t\tjn++;\n\t}\n\tprint \"runfiles=\"\n\tfor (j = 1; j < jn; j++) {\n\t\tbuilddir=rd cfr[j] \"/build\";\n\t\tif (TORTURE_BUILDONLY)\n\t\t\tprint \"rm -f \" builddir \".ready\"\n\t\telse\n\t\t\tprint \"mv \" builddir \".ready \" builddir \".run\"\n\t\t\tprint \"runfiles=\\\"$runfiles \" builddir \".run\\\"\"\n\t\tfi\n\t\tprint \"if test -f \\\"\" rd cfr[j] \"/builtkernel\\\"\"\n\t\tprint \"then\"\n\t\tprint \"\\techo ----\", cfr[j], cpusr[j] ovf \": Kernel present. `date` | tee -a \" rd \"log\";\n\t\tprint \"\\tneedqemurun=1\"\n\t\tprint \"fi\"\n\t}\n\tif (TORTURE_BUILDONLY && njitter != 0) {\n\t\tnjitter = 0;\n\t\tprint \"echo Build-only run, so suppressing jitter | tee -a \" rd \"log\"\n\t}\n\tif (TORTURE_BUILDONLY) {\n\t\tprint \"needqemurun=\"\n\t}\n\tprint \"if test -n \\\"$needqemurun\\\"\"\n\tprint \"then\"\n\tprint \"\\techo ---- Starting kernels. `date` | tee -a \" rd \"log\";\n\tprint \"\\t$TORTURE_JITTER_START\";\n\tprint \"\\twhile ls $runfiles > /dev/null 2>&1\"\n\tprint \"\\tdo\"\n\tprint \"\\t\\t:\"\n\tprint \"\\tdone\"\n\tprint \"\\t$TORTURE_JITTER_STOP\";\n\tprint \"\\techo ---- All kernel runs complete. `date` | tee -a \" rd \"log\";\n\tprint \"else\"\n\tprint \"\\twait\"\n\tprint \"\\techo ---- No kernel runs. `date` | tee -a \" rd \"log\";\n\tprint \"fi\"\n\tfor (j = 1; j < jn; j++) {\n\t\tprint \"echo ----\", cfr[j], cpusr[j] ovf \": Build/run results: | tee -a \" rd \"log\";\n\t\tprint \"cat \" rd cfr[j]  \"/kvm-test-1-run.sh.out | tee -a \" rd \"log\";\n\t}\n}\n\nEND {\n\tnjobs = i;\n\tnc = ncpus;\n\tfirst = 0;\n\tbatchnum = 1;\n\n\t# Each pass through the following loop considers one test.\n\tfor (i = 0; i < njobs; i++) {\n\t\tif (ncpus == 0) {\n\t\t\t# Sequential test specified, each test its own batch.\n\t\t\tdump(i, i + 1, batchnum);\n\t\t\tfirst = i;\n\t\t\tbatchnum++;\n\t\t} else if (nc < cpus[i] && i != 0) {\n\t\t\t# Out of CPUs, dump out a batch.\n\t\t\tdump(first, i, batchnum);\n\t\t\tfirst = i;\n\t\t\tnc = ncpus;\n\t\t\tbatchnum++;\n\t\t}\n\t\t# Account for the CPUs needed by the current test.\n\t\tnc -= cpus[i];\n\t}\n\t# Dump the last batch.\n\tif (ncpus != 0)\n\t\tdump(first, i, batchnum);\n}\n___EOF___\nawk < $T/cfgcpu.pack \\\n\t-v TORTURE_BUILDONLY=\"$TORTURE_BUILDONLY\" \\\n\t-v CONFIGDIR=\"$CONFIGFRAG/\" \\\n\t-v RCUTORTURE=\"$RCUTORTURE\" \\\n\t-v ncpus=$cpus \\\n\t-v jitter=\"$jitter\" \\\n\t-v rd=$resdir/$ds/ \\\n\t-v dur=$dur \\\n\t-v TORTURE_QEMU_ARG=\"$TORTURE_QEMU_ARG\" \\\n\t-v TORTURE_BOOTARGS=\"$TORTURE_BOOTARGS\" \\\n\t-f $T/dumpbatches.awk >> $T/script\necho kvm-end-run-stats.sh \"$resdir/$ds\" \"$starttime\" >> $T/script\n\n# Extract the tests and their batches from the script.\ngrep -E 'Start batch|Starting build\\.' $T/script | grep -v \">>\" |\n\tsed -e 's/:.*$//' -e 's/^echo //' -e 's/-ovf//' |\n\tawk '\n\t/^----Start/ {\n\t\tbatchno = $3;\n\t\tnext;\n\t}\n\t{\n\t\tprint batchno, $1, $2\n\t}' > $T/batches\n\n# As above, but one line per batch.\ngrep -v '^#' $T/batches | awk '\nBEGIN {\n\toldbatch = 1;\n}\n\n{\n\tif (oldbatch != $1) {\n\t\tprint ++n \". \" curbatch;\n\t\tcurbatch = \"\";\n\t\toldbatch = $1;\n\t}\n\tcurbatch = curbatch \" \" $2;\n}\n\nEND {\n\tprint ++n \". \" curbatch;\n}' > $T/scenarios\n\nif test \"$dryrun\" = script\nthen\n\tcat $T/script\n\texit 0\nelif test \"$dryrun\" = sched\nthen\n\t# Extract the test run schedule from the script.\n\tgrep -E 'Start batch|Starting build\\.' $T/script | grep -v \">>\" |\n\t\tsed -e 's/:.*$//' -e 's/^echo //'\n\tnbuilds=\"`grep 'Starting build\\.' $T/script |\n\t\t  grep -v \">>\" | sed -e 's/:.*$//' -e 's/^echo //' |\n\t\t  awk '{ print $1 }' | grep -v '\\.' | wc -l`\"\n\techo Total number of builds: $nbuilds\n\tnbatches=\"`grep 'Start batch' $T/script | grep -v \">>\" | wc -l`\"\n\techo Total number of batches: $nbatches\n\texit 0\nelif test \"$dryrun\" = batches\nthen\n\tcat $T/batches\n\texit 0\nelif test \"$dryrun\" = scenarios\nthen\n\tcat $T/scenarios\n\texit 0\nelse\n\t# Not a dryrun.  Record the batches and the number of CPUs, then run the script.\n\tbash $T/script\n\tret=$?\n\tcp $T/batches $resdir/$ds/batches\n\tcp $T/scenarios $resdir/$ds/scenarios\n\techo '#' cpus=$cpus >> $resdir/$ds/batches\n\texit $ret\nfi\n\n# Tracing: trace_event=rcu:rcu_grace_period,rcu:rcu_future_grace_period,rcu:rcu_grace_period_init,rcu:rcu_nocb_wake,rcu:rcu_preempt_task,rcu:rcu_unlock_preempted_task,rcu:rcu_quiescent_state_report,rcu:rcu_fqs,rcu:rcu_callback,rcu:rcu_kfree_callback,rcu:rcu_batch_start,rcu:rcu_invoke_callback,rcu:rcu_invoke_kfree_callback,rcu:rcu_batch_end,rcu:rcu_torture_read,rcu:rcu_barrier\n# Function-graph tracing: ftrace=function_graph ftrace_graph_filter=sched_setaffinity,migration_cpu_stop\n# Also --kconfig \"CONFIG_FUNCTION_TRACER=y CONFIG_FUNCTION_GRAPH_TRACER=y\"\n# Control buffer size: --bootargs trace_buf_size=3k\n# Get trace-buffer dumps on all oopses: --bootargs ftrace_dump_on_oops\n# Ditto, but dump only the oopsing CPU: --bootargs ftrace_dump_on_oops=orig_cpu\n# Heavy-handed way to also dump on warnings: --bootargs panic_on_warn=1\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}