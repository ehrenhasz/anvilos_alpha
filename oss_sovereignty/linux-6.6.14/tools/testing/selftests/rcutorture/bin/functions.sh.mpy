{
  "module_name": "functions.sh",
  "hash_id": "a274c4064123268c87e5d4bfbc7479670570f417280e4f111a9cc3d7b95d6edc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/rcutorture/bin/functions.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0+\n#\n# Shell functions for the rest of the scripts.\n#\n# Copyright (C) IBM Corporation, 2013\n#\n# Authors: Paul E. McKenney <paulmck@linux.ibm.com>\n\n# bootparam_hotplug_cpu bootparam-string\n#\n# Returns 1 if the specified boot-parameter string tells rcutorture to\n# test CPU-hotplug operations.\nbootparam_hotplug_cpu () {\n\techo \"$1\" | grep -q \"torture\\.onoff_\"\n}\n\n# checkarg --argname argtype $# arg mustmatch cannotmatch\n#\n# Checks the specified argument \"arg\" against the mustmatch and cannotmatch\n# patterns.\ncheckarg () {\n\tif test $3 -le 1\n\tthen\n\t\techo $1 needs argument $2 matching \\\"$5\\\"\n\t\tusage\n\tfi\n\tif echo \"$4\" | grep -q -e \"$5\"\n\tthen\n\t\t:\n\telse\n\t\techo $1 $2 \\\"$4\\\" must match \\\"$5\\\"\n\t\tusage\n\tfi\n\tif echo \"$4\" | grep -q -e \"$6\"\n\tthen\n\t\techo $1 $2 \\\"$4\\\" must not match \\\"$6\\\"\n\t\tusage\n\tfi\n}\n\n# configfrag_boot_params bootparam-string config-fragment-file\n#\n# Adds boot parameters from the .boot file, if any.\nconfigfrag_boot_params () {\n\tif test -r \"$2.boot\"\n\tthen\n\t\techo `grep -v '^#' \"$2.boot\" | tr '\\012' ' '` $1\n\telse\n\t\techo $1\n\tfi\n}\n\n# configfrag_boot_cpus bootparam-string config-fragment-file config-cpus\n#\n# Decreases number of CPUs based on any nr_cpus= boot parameters specified.\nconfigfrag_boot_cpus () {\n\tlocal bootargs=\"`configfrag_boot_params \"$1\" \"$2\"`\"\n\tlocal nr_cpus\n\tif echo \"${bootargs}\" | grep -q 'nr_cpus=[0-9]'\n\tthen\n\t\tnr_cpus=\"`echo \"${bootargs}\" | sed -e 's/^.*nr_cpus=\\([0-9]*\\).*$/\\1/'`\"\n\t\tif test \"$3\" -gt \"$nr_cpus\"\n\t\tthen\n\t\t\techo $nr_cpus\n\t\telse\n\t\t\techo $3\n\t\tfi\n\telse\n\t\techo $3\n\tfi\n}\n\n# configfrag_boot_maxcpus bootparam-string config-fragment-file config-cpus\n#\n# Decreases number of CPUs based on any maxcpus= boot parameters specified.\n# This allows tests where additional CPUs come online later during the\n# test run.  However, the torture parameters will be set based on the\n# number of CPUs initially present, so the scripting should schedule\n# test runs based on the maxcpus= boot parameter controlling the initial\n# number of CPUs instead of on the ultimate number of CPUs.\nconfigfrag_boot_maxcpus () {\n\tlocal bootargs=\"`configfrag_boot_params \"$1\" \"$2\"`\"\n\tlocal maxcpus\n\tif echo \"${bootargs}\" | grep -q 'maxcpus=[0-9]'\n\tthen\n\t\tmaxcpus=\"`echo \"${bootargs}\" | sed -e 's/^.*maxcpus=\\([0-9]*\\).*$/\\1/'`\"\n\t\tif test \"$3\" -gt \"$maxcpus\"\n\t\tthen\n\t\t\techo $maxcpus\n\t\telse\n\t\t\techo $3\n\t\tfi\n\telse\n\t\techo $3\n\tfi\n}\n\n# configfrag_hotplug_cpu config-fragment-file\n#\n# Returns 1 if the config fragment specifies hotplug CPU.\nconfigfrag_hotplug_cpu () {\n\tif test ! -r \"$1\"\n\tthen\n\t\techo Unreadable config fragment \"$1\" 1>&2\n\t\texit -1\n\tfi\n\tgrep -q '^CONFIG_HOTPLUG_CPU=y$' \"$1\"\n}\n\n# get_starttime\n#\n# Returns a cookie identifying the current time.\nget_starttime () {\n\tawk 'BEGIN { print systime() }' < /dev/null\n}\n\n# get_starttime_duration starttime\n#\n# Given the return value from get_starttime, compute a human-readable\n# string denoting the time since get_starttime.\nget_starttime_duration () {\n\tawk -v starttime=$1 '\n\tBEGIN {\n\t\tts = systime() - starttime; \n\t\ttm = int(ts / 60);\n\t\tth = int(ts / 3600);\n\t\ttd = int(ts / 86400);\n\t\td = td;\n\t\th = th - td * 24;\n\t\tm = tm - th * 60;\n\t\ts = ts - tm * 60;\n\t\tif (d >= 1)\n\t\t\tprintf \"%dd %d:%02d:%02d\\n\", d, h, m, s\n\t\telse if (h >= 1)\n\t\t\tprintf \"%d:%02d:%02d\\n\", h, m, s\n\t\telse if (m >= 1)\n\t\t\tprintf \"%d:%02d.0\\n\", m, s\n\t\telse\n\t\t\tprint s \" seconds\"\n\t}' < /dev/null\n}\n\n# identify_boot_image qemu-cmd\n#\n# Returns the relative path to the kernel build image.  This will be\n# arch/<arch>/boot/bzImage or vmlinux if bzImage is not a target for the\n# architecture, unless overridden with the TORTURE_BOOT_IMAGE environment\n# variable.\nidentify_boot_image () {\n\tif test -n \"$TORTURE_BOOT_IMAGE\"\n\tthen\n\t\techo $TORTURE_BOOT_IMAGE\n\telse\n\t\tcase \"$1\" in\n\t\tqemu-system-x86_64|qemu-system-i386)\n\t\t\techo arch/x86/boot/bzImage\n\t\t\t;;\n\t\tqemu-system-aarch64)\n\t\t\techo arch/arm64/boot/Image\n\t\t\t;;\n\t\tqemu-system-s390x)\n\t\t\techo arch/s390/boot/bzImage\n\t\t\t;;\n\t\t*)\n\t\t\techo vmlinux\n\t\t\t;;\n\t\tesac\n\tfi\n}\n\n# identify_qemu builddir\n#\n# Returns our best guess as to which qemu command is appropriate for\n# the kernel at hand.  Override with the TORTURE_QEMU_CMD environment variable.\nidentify_qemu () {\n\tlocal u=\"`file \"$1\"`\"\n\tif test -n \"$TORTURE_QEMU_CMD\"\n\tthen\n\t\techo $TORTURE_QEMU_CMD\n\telif echo $u | grep -q x86-64\n\tthen\n\t\techo qemu-system-x86_64\n\telif echo $u | grep -q \"Intel 80386\"\n\tthen\n\t\techo qemu-system-i386\n\telif echo $u | grep -q aarch64\n\tthen\n\t\techo qemu-system-aarch64\n\telif echo $u | grep -q 'IBM S/390'\n\tthen\n\t\techo qemu-system-s390x\n\telif uname -a | grep -q ppc64\n\tthen\n\t\techo qemu-system-ppc64\n\telse\n\t\techo Cannot figure out what qemu command to use! 1>&2\n\t\techo file $1 output: $u\n\t\t# Usually this will be one of /usr/bin/qemu-system-*\n\t\t# Use TORTURE_QEMU_CMD environment variable or appropriate\n\t\t# argument to top-level script.\n\t\texit 1\n\tfi\n}\n\n# identify_qemu_append qemu-cmd\n#\n# Output arguments for the qemu \"-append\" string based on CPU type\n# and the TORTURE_QEMU_INTERACTIVE environment variable.\nidentify_qemu_append () {\n\techo debug_boot_weak_hash\n\techo panic=-1\n\tlocal console=ttyS0\n\tcase \"$1\" in\n\tqemu-system-x86_64|qemu-system-i386)\n\t\techo selinux=0 initcall_debug debug\n\t\t;;\n\tqemu-system-aarch64)\n\t\tconsole=ttyAMA0\n\t\t;;\n\tesac\n\tif test -n \"$TORTURE_QEMU_INTERACTIVE\"\n\tthen\n\t\techo root=/dev/sda\n\telse\n\t\techo console=$console\n\tfi\n}\n\n# identify_qemu_args qemu-cmd serial-file\n#\n# Output arguments for qemu arguments based on the TORTURE_QEMU_MAC\n# and TORTURE_QEMU_INTERACTIVE environment variables.\nidentify_qemu_args () {\n\tlocal KVM_CPU=\"\"\n\tcase \"$1\" in\n\tqemu-system-x86_64)\n\t\tKVM_CPU=kvm64\n\t\t;;\n\tqemu-system-i386)\n\t\tKVM_CPU=kvm32\n\t\t;;\n\tesac\n\tcase \"$1\" in\n\tqemu-system-x86_64|qemu-system-i386)\n\t\techo -machine q35,accel=kvm\n\t\techo -cpu ${KVM_CPU}\n\t\t;;\n\tqemu-system-aarch64)\n\t\techo -machine virt,gic-version=host -cpu host\n\t\t;;\n\tqemu-system-ppc64)\n\t\techo -M pseries -nodefaults\n\t\techo -device spapr-vscsi\n\t\tif test -n \"$TORTURE_QEMU_INTERACTIVE\" -a -n \"$TORTURE_QEMU_MAC\"\n\t\tthen\n\t\t\techo -device spapr-vlan,netdev=net0,mac=$TORTURE_QEMU_MAC\n\t\t\techo -netdev bridge,br=br0,id=net0\n\t\tfi\n\t\t;;\n\tesac\n\tif test -n \"$TORTURE_QEMU_INTERACTIVE\"\n\tthen\n\t\techo -monitor stdio -serial pty -S\n\telse\n\t\techo -serial file:$2\n\tfi\n}\n\n# identify_qemu_vcpus\n#\n# Returns the number of virtual CPUs available to the aggregate of the\n# guest OSes.\nidentify_qemu_vcpus () {\n\tgetconf _NPROCESSORS_ONLN\n}\n\n# print_bug\n#\n# Prints \"BUG: \" in red followed by remaining arguments\nprint_bug () {\n\tprintf '\\033[031mBUG: \\033[m'\n\techo $*\n}\n\n# print_warning\n#\n# Prints \"WARNING: \" in yellow followed by remaining arguments\nprint_warning () {\n\tprintf '\\033[033mWARNING: \\033[m'\n\techo $*\n}\n\n# specify_qemu_cpus qemu-cmd qemu-args #cpus\n#\n# Appends a string containing \"-smp XXX\" to qemu-args, unless the incoming\n# qemu-args already contains \"-smp\".\nspecify_qemu_cpus () {\n\tlocal nt;\n\n\tif echo $2 | grep -q -e -smp\n\tthen\n\t\techo $2\n\telse\n\t\tcase \"$1\" in\n\t\tqemu-system-x86_64|qemu-system-i386|qemu-system-aarch64)\n\t\t\techo $2 -smp $3\n\t\t\t;;\n\t\tqemu-system-ppc64)\n\t\t\tnt=\"`lscpu | sed -n 's/^Thread(s) per core:\\s*//p'`\"\n\t\t\techo $2 -smp cores=`expr \\( $3 + $nt - 1 \\) / $nt`,threads=$nt\n\t\t\t;;\n\t\tesac\n\tfi\n}\n\n# specify_qemu_net qemu-args\n#\n# Appends a string containing \"-net none\" to qemu-args, unless the incoming\n# qemu-args already contains \"-smp\" or unless the TORTURE_QEMU_INTERACTIVE\n# environment variable is set, in which case the string that is be added is\n# instead \"-net nic -net user\".\nspecify_qemu_net () {\n\tif echo $1 | grep -q -e -net\n\tthen\n\t\techo $1\n\telif test -n \"$TORTURE_QEMU_INTERACTIVE\"\n\tthen\n\t\techo $1 -net nic -net user\n\telse\n\t\techo $1 -net none\n\tfi\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}