{
  "module_name": "testptp.c",
  "hash_id": "4a381fcfefe59d19495050a5e75b2e344f41e3ab5eeaaef2a072e3784bd99b89",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ptp/testptp.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#define __SANE_USERSPACE_TYPES__         \n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <math.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/timex.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <linux/ptp_clock.h>\n\n#define DEVICE \"/dev/ptp0\"\n\n#ifndef ADJ_SETOFFSET\n#define ADJ_SETOFFSET 0x0100\n#endif\n\n#ifndef CLOCK_INVALID\n#define CLOCK_INVALID -1\n#endif\n\n#define NSEC_PER_SEC 1000000000LL\n\n \n#if !__GLIBC_PREREQ(2, 14)\n#include <sys/syscall.h>\nstatic int clock_adjtime(clockid_t id, struct timex *tx)\n{\n\treturn syscall(__NR_clock_adjtime, id, tx);\n}\n#endif\n\nstatic void show_flag_test(int rq_index, unsigned int flags, int err)\n{\n\tprintf(\"PTP_EXTTS_REQUEST%c flags 0x%08x : (%d) %s\\n\",\n\t       rq_index ? '1' + rq_index : ' ',\n\t       flags, err, strerror(errno));\n\t \n\terrno = 0;\n}\n\nstatic void do_flag_test(int fd, unsigned int index)\n{\n\tstruct ptp_extts_request extts_request;\n\tunsigned long request[2] = {\n\t\tPTP_EXTTS_REQUEST,\n\t\tPTP_EXTTS_REQUEST2,\n\t};\n\tunsigned int enable_flags[5] = {\n\t\tPTP_ENABLE_FEATURE,\n\t\tPTP_ENABLE_FEATURE | PTP_RISING_EDGE,\n\t\tPTP_ENABLE_FEATURE | PTP_FALLING_EDGE,\n\t\tPTP_ENABLE_FEATURE | PTP_RISING_EDGE | PTP_FALLING_EDGE,\n\t\tPTP_ENABLE_FEATURE | (PTP_EXTTS_VALID_FLAGS + 1),\n\t};\n\tint err, i, j;\n\n\tmemset(&extts_request, 0, sizeof(extts_request));\n\textts_request.index = index;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\textts_request.flags = enable_flags[j];\n\t\t\terr = ioctl(fd, request[i], &extts_request);\n\t\t\tshow_flag_test(i, extts_request.flags, err);\n\n\t\t\textts_request.flags = 0;\n\t\t\terr = ioctl(fd, request[i], &extts_request);\n\t\t}\n\t}\n}\n\nstatic clockid_t get_clockid(int fd)\n{\n#define CLOCKFD 3\n\treturn (((unsigned int) ~fd) << 3) | CLOCKFD;\n}\n\nstatic long ppb_to_scaled_ppm(int ppb)\n{\n\t \n\treturn (long) (ppb * 65.536);\n}\n\nstatic int64_t pctns(struct ptp_clock_time *t)\n{\n\treturn t->sec * NSEC_PER_SEC + t->nsec;\n}\n\nstatic void usage(char *progname)\n{\n\tfprintf(stderr,\n\t\t\"usage: %s [options]\\n\"\n\t\t\" -c         query the ptp clock's capabilities\\n\"\n\t\t\" -d name    device to open\\n\"\n\t\t\" -e val     read 'val' external time stamp events\\n\"\n\t\t\" -f val     adjust the ptp clock frequency by 'val' ppb\\n\"\n\t\t\" -g         get the ptp clock time\\n\"\n\t\t\" -h         prints this message\\n\"\n\t\t\" -i val     index for event/trigger\\n\"\n\t\t\" -k val     measure the time offset between system and phc clock\\n\"\n\t\t\"            for 'val' times (Maximum 25)\\n\"\n\t\t\" -l         list the current pin configuration\\n\"\n\t\t\" -L pin,val configure pin index 'pin' with function 'val'\\n\"\n\t\t\"            the channel index is taken from the '-i' option\\n\"\n\t\t\"            'val' specifies the auxiliary function:\\n\"\n\t\t\"            0 - none\\n\"\n\t\t\"            1 - external time stamp\\n\"\n\t\t\"            2 - periodic output\\n\"\n\t\t\" -n val     shift the ptp clock time by 'val' nanoseconds\\n\"\n\t\t\" -o val     phase offset (in nanoseconds) to be provided to the PHC servo\\n\"\n\t\t\" -p val     enable output with a period of 'val' nanoseconds\\n\"\n\t\t\" -H val     set output phase to 'val' nanoseconds (requires -p)\\n\"\n\t\t\" -w val     set output pulse width to 'val' nanoseconds (requires -p)\\n\"\n\t\t\" -P val     enable or disable (val=1|0) the system clock PPS\\n\"\n\t\t\" -s         set the ptp clock time from the system time\\n\"\n\t\t\" -S         set the system time from the ptp clock time\\n\"\n\t\t\" -t val     shift the ptp clock time by 'val' seconds\\n\"\n\t\t\" -T val     set the ptp clock time to 'val' seconds\\n\"\n\t\t\" -x val     get an extended ptp clock time with the desired number of samples (up to %d)\\n\"\n\t\t\" -X         get a ptp clock cross timestamp\\n\"\n\t\t\" -z         test combinations of rising/falling external time stamp flags\\n\",\n\t\tprogname, PTP_MAX_SAMPLES);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct ptp_clock_caps caps;\n\tstruct ptp_extts_event event;\n\tstruct ptp_extts_request extts_request;\n\tstruct ptp_perout_request perout_request;\n\tstruct ptp_pin_desc desc;\n\tstruct timespec ts;\n\tstruct timex tx;\n\tstruct ptp_clock_time *pct;\n\tstruct ptp_sys_offset *sysoff;\n\tstruct ptp_sys_offset_extended *soe;\n\tstruct ptp_sys_offset_precise *xts;\n\n\tchar *progname;\n\tunsigned int i;\n\tint c, cnt, fd;\n\n\tchar *device = DEVICE;\n\tclockid_t clkid;\n\tint adjfreq = 0x7fffffff;\n\tint adjtime = 0;\n\tint adjns = 0;\n\tint adjphase = 0;\n\tint capabilities = 0;\n\tint extts = 0;\n\tint flagtest = 0;\n\tint gettime = 0;\n\tint index = 0;\n\tint list_pins = 0;\n\tint pct_offset = 0;\n\tint getextended = 0;\n\tint getcross = 0;\n\tint n_samples = 0;\n\tint pin_index = -1, pin_func;\n\tint pps = -1;\n\tint seconds = 0;\n\tint settime = 0;\n\n\tint64_t t1, t2, tp;\n\tint64_t interval, offset;\n\tint64_t perout_phase = -1;\n\tint64_t pulsewidth = -1;\n\tint64_t perout = -1;\n\n\tprogname = strrchr(argv[0], '/');\n\tprogname = progname ? 1+progname : argv[0];\n\twhile (EOF != (c = getopt(argc, argv, \"cd:e:f:ghH:i:k:lL:n:o:p:P:sSt:T:w:x:Xz\"))) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tcapabilities = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\textts = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tadjfreq = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tgettime = 1;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tperout_phase = atoll(optarg);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tindex = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tpct_offset = 1;\n\t\t\tn_samples = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_pins = 1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tcnt = sscanf(optarg, \"%d,%d\", &pin_index, &pin_func);\n\t\t\tif (cnt != 2) {\n\t\t\t\tusage(progname);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tadjns = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tadjphase = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tperout = atoll(optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tpps = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsettime = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsettime = 2;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tadjtime = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tsettime = 3;\n\t\t\tseconds = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tpulsewidth = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tgetextended = atoi(optarg);\n\t\t\tif (getextended < 1 || getextended > PTP_MAX_SAMPLES) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"number of extended timestamp samples must be between 1 and %d; was asked for %d\\n\",\n\t\t\t\t\tPTP_MAX_SAMPLES, getextended);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tgetcross = 1;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tflagtest = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(progname);\n\t\t\treturn 0;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage(progname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfd = open(device, O_RDWR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"opening %s: %s\\n\", device, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tclkid = get_clockid(fd);\n\tif (CLOCK_INVALID == clkid) {\n\t\tfprintf(stderr, \"failed to read clock id\\n\");\n\t\treturn -1;\n\t}\n\n\tif (capabilities) {\n\t\tif (ioctl(fd, PTP_CLOCK_GETCAPS, &caps)) {\n\t\t\tperror(\"PTP_CLOCK_GETCAPS\");\n\t\t} else {\n\t\t\tprintf(\"capabilities:\\n\"\n\t\t\t       \"  %d maximum frequency adjustment (ppb)\\n\"\n\t\t\t       \"  %d programmable alarms\\n\"\n\t\t\t       \"  %d external time stamp channels\\n\"\n\t\t\t       \"  %d programmable periodic signals\\n\"\n\t\t\t       \"  %d pulse per second\\n\"\n\t\t\t       \"  %d programmable pins\\n\"\n\t\t\t       \"  %d cross timestamping\\n\"\n\t\t\t       \"  %d adjust_phase\\n\"\n\t\t\t       \"  %d maximum phase adjustment (ns)\\n\",\n\t\t\t       caps.max_adj,\n\t\t\t       caps.n_alarm,\n\t\t\t       caps.n_ext_ts,\n\t\t\t       caps.n_per_out,\n\t\t\t       caps.pps,\n\t\t\t       caps.n_pins,\n\t\t\t       caps.cross_timestamping,\n\t\t\t       caps.adjust_phase,\n\t\t\t       caps.max_phase_adj);\n\t\t}\n\t}\n\n\tif (0x7fffffff != adjfreq) {\n\t\tmemset(&tx, 0, sizeof(tx));\n\t\ttx.modes = ADJ_FREQUENCY;\n\t\ttx.freq = ppb_to_scaled_ppm(adjfreq);\n\t\tif (clock_adjtime(clkid, &tx)) {\n\t\t\tperror(\"clock_adjtime\");\n\t\t} else {\n\t\t\tputs(\"frequency adjustment okay\");\n\t\t}\n\t}\n\n\tif (adjtime || adjns) {\n\t\tmemset(&tx, 0, sizeof(tx));\n\t\ttx.modes = ADJ_SETOFFSET | ADJ_NANO;\n\t\ttx.time.tv_sec = adjtime;\n\t\ttx.time.tv_usec = adjns;\n\t\twhile (tx.time.tv_usec < 0) {\n\t\t\ttx.time.tv_sec  -= 1;\n\t\t\ttx.time.tv_usec += NSEC_PER_SEC;\n\t\t}\n\n\t\tif (clock_adjtime(clkid, &tx) < 0) {\n\t\t\tperror(\"clock_adjtime\");\n\t\t} else {\n\t\t\tputs(\"time shift okay\");\n\t\t}\n\t}\n\n\tif (adjphase) {\n\t\tmemset(&tx, 0, sizeof(tx));\n\t\ttx.modes = ADJ_OFFSET | ADJ_NANO;\n\t\ttx.offset = adjphase;\n\n\t\tif (clock_adjtime(clkid, &tx) < 0) {\n\t\t\tperror(\"clock_adjtime\");\n\t\t} else {\n\t\t\tputs(\"phase adjustment okay\");\n\t\t}\n\t}\n\n\tif (gettime) {\n\t\tif (clock_gettime(clkid, &ts)) {\n\t\t\tperror(\"clock_gettime\");\n\t\t} else {\n\t\t\tprintf(\"clock time: %ld.%09ld or %s\",\n\t\t\t       ts.tv_sec, ts.tv_nsec, ctime(&ts.tv_sec));\n\t\t}\n\t}\n\n\tif (settime == 1) {\n\t\tclock_gettime(CLOCK_REALTIME, &ts);\n\t\tif (clock_settime(clkid, &ts)) {\n\t\t\tperror(\"clock_settime\");\n\t\t} else {\n\t\t\tputs(\"set time okay\");\n\t\t}\n\t}\n\n\tif (settime == 2) {\n\t\tclock_gettime(clkid, &ts);\n\t\tif (clock_settime(CLOCK_REALTIME, &ts)) {\n\t\t\tperror(\"clock_settime\");\n\t\t} else {\n\t\t\tputs(\"set time okay\");\n\t\t}\n\t}\n\n\tif (settime == 3) {\n\t\tts.tv_sec = seconds;\n\t\tts.tv_nsec = 0;\n\t\tif (clock_settime(clkid, &ts)) {\n\t\t\tperror(\"clock_settime\");\n\t\t} else {\n\t\t\tputs(\"set time okay\");\n\t\t}\n\t}\n\n\tif (pin_index >= 0) {\n\t\tmemset(&desc, 0, sizeof(desc));\n\t\tdesc.index = pin_index;\n\t\tdesc.func = pin_func;\n\t\tdesc.chan = index;\n\t\tif (ioctl(fd, PTP_PIN_SETFUNC, &desc)) {\n\t\t\tperror(\"PTP_PIN_SETFUNC\");\n\t\t} else {\n\t\t\tputs(\"set pin function okay\");\n\t\t}\n\t}\n\n\tif (extts) {\n\t\tmemset(&extts_request, 0, sizeof(extts_request));\n\t\textts_request.index = index;\n\t\textts_request.flags = PTP_ENABLE_FEATURE;\n\t\tif (ioctl(fd, PTP_EXTTS_REQUEST, &extts_request)) {\n\t\t\tperror(\"PTP_EXTTS_REQUEST\");\n\t\t\textts = 0;\n\t\t} else {\n\t\t\tputs(\"external time stamp request okay\");\n\t\t}\n\t\tfor (; extts; extts--) {\n\t\t\tcnt = read(fd, &event, sizeof(event));\n\t\t\tif (cnt != sizeof(event)) {\n\t\t\t\tperror(\"read\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"event index %u at %lld.%09u\\n\", event.index,\n\t\t\t       event.t.sec, event.t.nsec);\n\t\t\tfflush(stdout);\n\t\t}\n\t\t \n\t\textts_request.flags = 0;\n\t\tif (ioctl(fd, PTP_EXTTS_REQUEST, &extts_request)) {\n\t\t\tperror(\"PTP_EXTTS_REQUEST\");\n\t\t}\n\t}\n\n\tif (flagtest) {\n\t\tdo_flag_test(fd, index);\n\t}\n\n\tif (list_pins) {\n\t\tint n_pins = 0;\n\t\tif (ioctl(fd, PTP_CLOCK_GETCAPS, &caps)) {\n\t\t\tperror(\"PTP_CLOCK_GETCAPS\");\n\t\t} else {\n\t\t\tn_pins = caps.n_pins;\n\t\t}\n\t\tfor (i = 0; i < n_pins; i++) {\n\t\t\tdesc.index = i;\n\t\t\tif (ioctl(fd, PTP_PIN_GETFUNC, &desc)) {\n\t\t\t\tperror(\"PTP_PIN_GETFUNC\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"name %s index %u func %u chan %u\\n\",\n\t\t\t       desc.name, desc.index, desc.func, desc.chan);\n\t\t}\n\t}\n\n\tif (pulsewidth >= 0 && perout < 0) {\n\t\tputs(\"-w can only be specified together with -p\");\n\t\treturn -1;\n\t}\n\n\tif (perout_phase >= 0 && perout < 0) {\n\t\tputs(\"-H can only be specified together with -p\");\n\t\treturn -1;\n\t}\n\n\tif (perout >= 0) {\n\t\tif (clock_gettime(clkid, &ts)) {\n\t\t\tperror(\"clock_gettime\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(&perout_request, 0, sizeof(perout_request));\n\t\tperout_request.index = index;\n\t\tperout_request.period.sec = perout / NSEC_PER_SEC;\n\t\tperout_request.period.nsec = perout % NSEC_PER_SEC;\n\t\tperout_request.flags = 0;\n\t\tif (pulsewidth >= 0) {\n\t\t\tperout_request.flags |= PTP_PEROUT_DUTY_CYCLE;\n\t\t\tperout_request.on.sec = pulsewidth / NSEC_PER_SEC;\n\t\t\tperout_request.on.nsec = pulsewidth % NSEC_PER_SEC;\n\t\t}\n\t\tif (perout_phase >= 0) {\n\t\t\tperout_request.flags |= PTP_PEROUT_PHASE;\n\t\t\tperout_request.phase.sec = perout_phase / NSEC_PER_SEC;\n\t\t\tperout_request.phase.nsec = perout_phase % NSEC_PER_SEC;\n\t\t} else {\n\t\t\tperout_request.start.sec = ts.tv_sec + 2;\n\t\t\tperout_request.start.nsec = 0;\n\t\t}\n\n\t\tif (ioctl(fd, PTP_PEROUT_REQUEST2, &perout_request)) {\n\t\t\tperror(\"PTP_PEROUT_REQUEST\");\n\t\t} else {\n\t\t\tputs(\"periodic output request okay\");\n\t\t}\n\t}\n\n\tif (pps != -1) {\n\t\tint enable = pps ? 1 : 0;\n\t\tif (ioctl(fd, PTP_ENABLE_PPS, enable)) {\n\t\t\tperror(\"PTP_ENABLE_PPS\");\n\t\t} else {\n\t\t\tputs(\"pps for system time request okay\");\n\t\t}\n\t}\n\n\tif (pct_offset) {\n\t\tif (n_samples <= 0 || n_samples > 25) {\n\t\t\tputs(\"n_samples should be between 1 and 25\");\n\t\t\tusage(progname);\n\t\t\treturn -1;\n\t\t}\n\n\t\tsysoff = calloc(1, sizeof(*sysoff));\n\t\tif (!sysoff) {\n\t\t\tperror(\"calloc\");\n\t\t\treturn -1;\n\t\t}\n\t\tsysoff->n_samples = n_samples;\n\n\t\tif (ioctl(fd, PTP_SYS_OFFSET, sysoff))\n\t\t\tperror(\"PTP_SYS_OFFSET\");\n\t\telse\n\t\t\tputs(\"system and phc clock time offset request okay\");\n\n\t\tpct = &sysoff->ts[0];\n\t\tfor (i = 0; i < sysoff->n_samples; i++) {\n\t\t\tt1 = pctns(pct+2*i);\n\t\t\ttp = pctns(pct+2*i+1);\n\t\t\tt2 = pctns(pct+2*i+2);\n\t\t\tinterval = t2 - t1;\n\t\t\toffset = (t2 + t1) / 2 - tp;\n\n\t\t\tprintf(\"system time: %lld.%09u\\n\",\n\t\t\t\t(pct+2*i)->sec, (pct+2*i)->nsec);\n\t\t\tprintf(\"phc    time: %lld.%09u\\n\",\n\t\t\t\t(pct+2*i+1)->sec, (pct+2*i+1)->nsec);\n\t\t\tprintf(\"system time: %lld.%09u\\n\",\n\t\t\t\t(pct+2*i+2)->sec, (pct+2*i+2)->nsec);\n\t\t\tprintf(\"system/phc clock time offset is %\" PRId64 \" ns\\n\"\n\t\t\t       \"system     clock time delay  is %\" PRId64 \" ns\\n\",\n\t\t\t\toffset, interval);\n\t\t}\n\n\t\tfree(sysoff);\n\t}\n\n\tif (getextended) {\n\t\tsoe = calloc(1, sizeof(*soe));\n\t\tif (!soe) {\n\t\t\tperror(\"calloc\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tsoe->n_samples = getextended;\n\n\t\tif (ioctl(fd, PTP_SYS_OFFSET_EXTENDED, soe)) {\n\t\t\tperror(\"PTP_SYS_OFFSET_EXTENDED\");\n\t\t} else {\n\t\t\tprintf(\"extended timestamp request returned %d samples\\n\",\n\t\t\t       getextended);\n\n\t\t\tfor (i = 0; i < getextended; i++) {\n\t\t\t\tprintf(\"sample #%2d: system time before: %lld.%09u\\n\",\n\t\t\t\t       i, soe->ts[i][0].sec, soe->ts[i][0].nsec);\n\t\t\t\tprintf(\"            phc time: %lld.%09u\\n\",\n\t\t\t\t       soe->ts[i][1].sec, soe->ts[i][1].nsec);\n\t\t\t\tprintf(\"            system time after: %lld.%09u\\n\",\n\t\t\t\t       soe->ts[i][2].sec, soe->ts[i][2].nsec);\n\t\t\t}\n\t\t}\n\n\t\tfree(soe);\n\t}\n\n\tif (getcross) {\n\t\txts = calloc(1, sizeof(*xts));\n\t\tif (!xts) {\n\t\t\tperror(\"calloc\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ioctl(fd, PTP_SYS_OFFSET_PRECISE, xts)) {\n\t\t\tperror(\"PTP_SYS_OFFSET_PRECISE\");\n\t\t} else {\n\t\t\tputs(\"system and phc crosstimestamping request okay\");\n\n\t\t\tprintf(\"device time: %lld.%09u\\n\",\n\t\t\t       xts->device.sec, xts->device.nsec);\n\t\t\tprintf(\"system time: %lld.%09u\\n\",\n\t\t\t       xts->sys_realtime.sec, xts->sys_realtime.nsec);\n\t\t\tprintf(\"monoraw time: %lld.%09u\\n\",\n\t\t\t       xts->sys_monoraw.sec, xts->sys_monoraw.nsec);\n\t\t}\n\n\t\tfree(xts);\n\t}\n\n\tclose(fd);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}