{
  "module_name": "nci_dev.c",
  "hash_id": "2dca4492489864b45f95036609e882e63a7557a4257e4df484923190bcb21397",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/nci/nci_dev.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <linux/genetlink.h>\n#include <sys/socket.h>\n#include <linux/nfc.h>\n\n#include \"../kselftest_harness.h\"\n\n#define GENLMSG_DATA(glh)\t((void *)(NLMSG_DATA(glh) + GENL_HDRLEN))\n#define GENLMSG_PAYLOAD(glh)\t(NLMSG_PAYLOAD(glh, 0) - GENL_HDRLEN)\n#define NLA_DATA(na)\t\t((void *)((char *)(na) + NLA_HDRLEN))\n#define NLA_PAYLOAD(len)\t((len) - NLA_HDRLEN)\n\n#define MAX_MSG_SIZE\t1024\n\n#define IOCTL_GET_NCIDEV_IDX\t0\n#define VIRTUAL_NFC_PROTOCOLS\t(NFC_PROTO_JEWEL_MASK | \\\n\t\t\t\t NFC_PROTO_MIFARE_MASK | \\\n\t\t\t\t NFC_PROTO_FELICA_MASK | \\\n\t\t\t\t NFC_PROTO_ISO14443_MASK | \\\n\t\t\t\t NFC_PROTO_ISO14443_B_MASK | \\\n\t\t\t\t NFC_PROTO_ISO15693_MASK)\n\nconst __u8 nci_reset_cmd[] = {0x20, 0x00, 0x01, 0x01};\nconst __u8 nci_init_cmd[] = {0x20, 0x01, 0x00};\nconst __u8 nci_rf_discovery_cmd[] = {0x21, 0x03, 0x09, 0x04, 0x00, 0x01,\n\t\t\t\t      0x01, 0x01, 0x02, 0x01, 0x06, 0x01};\nconst __u8 nci_init_cmd_v2[] = {0x20, 0x01, 0x02, 0x00, 0x00};\nconst __u8 nci_rf_disc_map_cmd[] = {0x21, 0x00, 0x07, 0x02, 0x04, 0x03,\n\t\t\t\t     0x02, 0x05, 0x03, 0x03};\nconst __u8 nci_rf_deact_cmd[] = {0x21, 0x06, 0x01, 0x00};\nconst __u8 nci_reset_rsp[] = {0x40, 0x00, 0x03, 0x00, 0x10, 0x01};\nconst __u8 nci_reset_rsp_v2[] = {0x40, 0x00, 0x01, 0x00};\nconst __u8 nci_reset_ntf[] = {0x60, 0x00, 0x09, 0x02, 0x01, 0x20, 0x0e,\n\t\t\t       0x04, 0x61, 0x00, 0x04, 0x02};\nconst __u8 nci_init_rsp[] = {0x40, 0x01, 0x14, 0x00, 0x02, 0x0e, 0x02,\n\t\t\t      0x00, 0x03, 0x01, 0x02, 0x03, 0x02, 0xc8,\n\t\t\t      0x00, 0xff, 0x10, 0x00, 0x0e, 0x12, 0x00,\n\t\t\t      0x00, 0x04};\nconst __u8 nci_init_rsp_v2[] = {0x40, 0x01, 0x1c, 0x00, 0x1a, 0x7e, 0x06,\n\t\t\t\t 0x00, 0x02, 0x92, 0x04, 0xff, 0xff, 0x01,\n\t\t\t\t 0x00, 0x40, 0x06, 0x00, 0x00, 0x01, 0x01,\n\t\t\t\t 0x00, 0x02, 0x00, 0x03, 0x01, 0x01, 0x06,\n\t\t\t\t 0x00, 0x80, 0x00};\nconst __u8 nci_rf_disc_map_rsp[] = {0x41, 0x00, 0x01, 0x00};\nconst __u8 nci_rf_disc_rsp[] = {0x41, 0x03, 0x01, 0x00};\nconst __u8 nci_rf_deact_rsp[] = {0x41, 0x06, 0x01, 0x00};\nconst __u8 nci_rf_deact_ntf[] = {0x61, 0x06, 0x02, 0x00, 0x00};\nconst __u8 nci_rf_activate_ntf[] = {0x61, 0x05, 0x1D, 0x01, 0x02, 0x04, 0x00,\n\t\t\t\t     0xFF, 0xFF, 0x0C, 0x44, 0x03, 0x07, 0x04,\n\t\t\t\t     0x62, 0x26, 0x11, 0x80, 0x1D, 0x80, 0x01,\n\t\t\t\t     0x20, 0x00, 0x00, 0x00, 0x06, 0x05, 0x75,\n\t\t\t\t     0x77, 0x81, 0x02, 0x80};\nconst __u8 nci_t4t_select_cmd[] = {0x00, 0x00, 0x0C, 0x00, 0xA4, 0x04, 0x00,\n\t\t\t\t    0x07, 0xD2, 0x76, 0x00, 0x00, 0x85, 0x01, 0x01};\nconst __u8 nci_t4t_select_cmd2[] = {0x00, 0x00, 0x07, 0x00, 0xA4, 0x00, 0x0C, 0x02,\n\t\t\t\t     0xE1, 0x03};\nconst __u8 nci_t4t_select_cmd3[] = {0x00, 0x00, 0x07, 0x00, 0xA4, 0x00, 0x0C, 0x02,\n\t\t\t\t     0xE1, 0x04};\nconst __u8 nci_t4t_read_cmd[] = {0x00, 0x00, 0x05, 0x00, 0xB0, 0x00, 0x00, 0x0F};\nconst __u8 nci_t4t_read_rsp[] = {0x00, 0x00, 0x11, 0x00, 0x0F, 0x20, 0x00, 0x3B,\n\t\t\t\t  0x00, 0x34, 0x04, 0x06, 0xE1, 0x04, 0x08, 0x00,\n\t\t\t\t  0x00, 0x00, 0x90, 0x00};\nconst __u8 nci_t4t_read_cmd2[] = {0x00, 0x00, 0x05, 0x00, 0xB0, 0x00, 0x00, 0x02};\nconst __u8 nci_t4t_read_rsp2[] = {0x00, 0x00, 0x04, 0x00, 0x0F, 0x90, 0x00};\nconst __u8 nci_t4t_read_cmd3[] = {0x00, 0x00, 0x05, 0x00, 0xB0, 0x00, 0x02, 0x0F};\nconst __u8 nci_t4t_read_rsp3[] = {0x00, 0x00, 0x11, 0xD1, 0x01, 0x0B, 0x54, 0x02,\n\t\t\t\t   0x65, 0x6E, 0x4E, 0x46, 0x43, 0x20, 0x54, 0x45,\n\t\t\t\t   0x53, 0x54, 0x90, 0x00};\nconst __u8 nci_t4t_rsp_ok[] = {0x00, 0x00, 0x02, 0x90, 0x00};\n\nstruct msgtemplate {\n\tstruct nlmsghdr n;\n\tstruct genlmsghdr g;\n\tchar buf[MAX_MSG_SIZE];\n};\n\nstatic int create_nl_socket(void)\n{\n\tint fd;\n\tstruct sockaddr_nl local;\n\n\tfd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&local, 0, sizeof(local));\n\tlocal.nl_family = AF_NETLINK;\n\n\tif (bind(fd, (struct sockaddr *)&local, sizeof(local)) < 0)\n\t\tgoto error;\n\n\treturn fd;\nerror:\n\tclose(fd);\n\treturn -1;\n}\n\nstatic int send_cmd_mt_nla(int sd, __u16 nlmsg_type, __u32 nlmsg_pid,\n\t\t\t   __u8 genl_cmd, int nla_num, __u16 nla_type[],\n\t\t\t   void *nla_data[], int nla_len[], __u16 flags)\n{\n\tstruct sockaddr_nl nladdr;\n\tstruct msgtemplate msg;\n\tstruct nlattr *na;\n\tint cnt, prv_len;\n\tint r, buflen;\n\tchar *buf;\n\n\tmsg.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);\n\tmsg.n.nlmsg_type = nlmsg_type;\n\tmsg.n.nlmsg_flags = flags;\n\tmsg.n.nlmsg_seq = 0;\n\tmsg.n.nlmsg_pid = nlmsg_pid;\n\tmsg.g.cmd = genl_cmd;\n\tmsg.g.version = 0x1;\n\n\tprv_len = 0;\n\tfor (cnt = 0; cnt < nla_num; cnt++) {\n\t\tna = (struct nlattr *)(GENLMSG_DATA(&msg) + prv_len);\n\t\tna->nla_type = nla_type[cnt];\n\t\tna->nla_len = nla_len[cnt] + NLA_HDRLEN;\n\n\t\tif (nla_len[cnt] > 0)\n\t\t\tmemcpy(NLA_DATA(na), nla_data[cnt], nla_len[cnt]);\n\n\t\tprv_len = NLA_ALIGN(nla_len[cnt]) + NLA_HDRLEN;\n\t\tmsg.n.nlmsg_len += prv_len;\n\t}\n\n\tbuf = (char *)&msg;\n\tbuflen = msg.n.nlmsg_len;\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\n\twhile ((r = sendto(sd, buf, buflen, 0, (struct sockaddr *)&nladdr,\n\t\t\t   sizeof(nladdr))) < buflen) {\n\t\tif (r > 0) {\n\t\t\tbuf += r;\n\t\t\tbuflen -= r;\n\t\t} else if (errno != EAGAIN) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int send_get_nfc_family(int sd, __u32 pid)\n{\n\t__u16 nla_get_family_type = CTRL_ATTR_FAMILY_NAME;\n\tvoid *nla_get_family_data;\n\tint nla_get_family_len;\n\tchar family_name[100];\n\n\tnla_get_family_len = strlen(NFC_GENL_NAME) + 1;\n\tstrcpy(family_name, NFC_GENL_NAME);\n\tnla_get_family_data = family_name;\n\n\treturn send_cmd_mt_nla(sd, GENL_ID_CTRL, pid, CTRL_CMD_GETFAMILY,\n\t\t\t\t1, &nla_get_family_type, &nla_get_family_data,\n\t\t\t\t&nla_get_family_len, NLM_F_REQUEST);\n}\n\nstatic int get_family_id(int sd, __u32 pid, __u32 *event_group)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct genlmsghdr g;\n\t\tchar buf[512];\n\t} ans;\n\tstruct nlattr *na;\n\tint resp_len;\n\t__u16 id;\n\tint len;\n\tint rc;\n\n\trc = send_get_nfc_family(sd, pid);\n\n\tif (rc < 0)\n\t\treturn 0;\n\n\tresp_len = recv(sd, &ans, sizeof(ans), 0);\n\n\tif (ans.n.nlmsg_type == NLMSG_ERROR || resp_len < 0 ||\n\t    !NLMSG_OK(&ans.n, resp_len))\n\t\treturn 0;\n\n\tlen = 0;\n\tresp_len = GENLMSG_PAYLOAD(&ans.n);\n\tna = (struct nlattr *)GENLMSG_DATA(&ans);\n\n\twhile (len < resp_len) {\n\t\tlen += NLA_ALIGN(na->nla_len);\n\t\tif (na->nla_type == CTRL_ATTR_FAMILY_ID) {\n\t\t\tid = *(__u16 *)NLA_DATA(na);\n\t\t} else if (na->nla_type == CTRL_ATTR_MCAST_GROUPS) {\n\t\t\tstruct nlattr *nested_na;\n\t\t\tstruct nlattr *group_na;\n\t\t\tint group_attr_len;\n\t\t\tint group_attr;\n\n\t\t\tnested_na = (struct nlattr *)((char *)na + NLA_HDRLEN);\n\t\t\tgroup_na = (struct nlattr *)((char *)nested_na + NLA_HDRLEN);\n\t\t\tgroup_attr_len = 0;\n\n\t\t\tfor (group_attr = CTRL_ATTR_MCAST_GRP_UNSPEC;\n\t\t\t\tgroup_attr < CTRL_ATTR_MCAST_GRP_MAX; group_attr++) {\n\t\t\t\tif (group_na->nla_type == CTRL_ATTR_MCAST_GRP_ID) {\n\t\t\t\t\t*event_group = *(__u32 *)((char *)group_na +\n\t\t\t\t\t\t\t\t  NLA_HDRLEN);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tgroup_attr_len += NLA_ALIGN(group_na->nla_len) +\n\t\t\t\t\t\t  NLA_HDRLEN;\n\t\t\t\tif (group_attr_len >= nested_na->nla_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tgroup_na = (struct nlattr *)((char *)group_na +\n\t\t\t\t\t\t\t     NLA_ALIGN(group_na->nla_len));\n\t\t\t}\n\t\t}\n\t\tna = (struct nlattr *)(GENLMSG_DATA(&ans) + len);\n\t}\n\treturn id;\n}\n\nstatic int send_cmd_with_idx(int sd, __u16 nlmsg_type, __u32 nlmsg_pid,\n\t\t\t     __u8 genl_cmd, int dev_id)\n{\n\t__u16 nla_type = NFC_ATTR_DEVICE_INDEX;\n\tvoid *nla_data = &dev_id;\n\tint nla_len = 4;\n\n\treturn send_cmd_mt_nla(sd, nlmsg_type, nlmsg_pid, genl_cmd, 1,\n\t\t\t\t&nla_type, &nla_data, &nla_len, NLM_F_REQUEST);\n}\n\nstatic int get_nci_devid(int sd, __u16 fid, __u32 pid, int dev_id, struct msgtemplate *msg)\n{\n\tint rc, resp_len;\n\n\trc = send_cmd_with_idx(sd, fid, pid, NFC_CMD_GET_DEVICE, dev_id);\n\tif (rc < 0) {\n\t\trc = -1;\n\t\tgoto error;\n\t}\n\n\tresp_len = recv(sd, msg, sizeof(*msg), 0);\n\tif (resp_len < 0) {\n\t\trc = -2;\n\t\tgoto error;\n\t}\n\n\tif (msg->n.nlmsg_type == NLMSG_ERROR ||\n\t    !NLMSG_OK(&msg->n, resp_len)) {\n\t\trc = -3;\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\treturn rc;\n}\n\nstatic __u8 get_dev_enable_state(struct msgtemplate *msg)\n{\n\tstruct nlattr *na;\n\tint resp_len;\n\tint len;\n\n\tresp_len = GENLMSG_PAYLOAD(&msg->n);\n\tna = (struct nlattr *)GENLMSG_DATA(msg);\n\tlen = 0;\n\n\twhile (len < resp_len) {\n\t\tlen += NLA_ALIGN(na->nla_len);\n\t\tif (na->nla_type == NFC_ATTR_DEVICE_POWERED)\n\t\t\treturn *(char *)NLA_DATA(na);\n\t\tna = (struct nlattr *)(GENLMSG_DATA(msg) + len);\n\t}\n\n\treturn resp_len;\n}\n\nFIXTURE(NCI) {\n\tint virtual_nci_fd;\n\tbool open_state;\n\tint dev_idex;\n\tbool isNCI2;\n\tint proto;\n\t__u32 pid;\n\t__u16 fid;\n\tint sd;\n};\n\nFIXTURE_VARIANT(NCI) {\n\tbool isNCI2;\n};\n\nFIXTURE_VARIANT_ADD(NCI, NCI1_0) {\n\t.isNCI2 = false,\n};\n\nFIXTURE_VARIANT_ADD(NCI, NCI2_0) {\n\t.isNCI2 = true,\n};\n\nstatic void *virtual_dev_open(void *data)\n{\n\tchar buf[258];\n\tint dev_fd;\n\tint len;\n\n\tdev_fd = *(int *)data;\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_reset_cmd))\n\t\tgoto error;\n\tif (memcmp(nci_reset_cmd, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_reset_rsp, sizeof(nci_reset_rsp));\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_init_cmd))\n\t\tgoto error;\n\tif (memcmp(nci_init_cmd, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_init_rsp, sizeof(nci_init_rsp));\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_rf_disc_map_cmd))\n\t\tgoto error;\n\tif (memcmp(nci_rf_disc_map_cmd, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_rf_disc_map_rsp, sizeof(nci_rf_disc_map_rsp));\n\n\treturn (void *)0;\nerror:\n\treturn (void *)-1;\n}\n\nstatic void *virtual_dev_open_v2(void *data)\n{\n\tchar buf[258];\n\tint dev_fd;\n\tint len;\n\n\tdev_fd = *(int *)data;\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_reset_cmd))\n\t\tgoto error;\n\tif (memcmp(nci_reset_cmd, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_reset_rsp_v2, sizeof(nci_reset_rsp_v2));\n\twrite(dev_fd, nci_reset_ntf, sizeof(nci_reset_ntf));\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_init_cmd_v2))\n\t\tgoto error;\n\tif (memcmp(nci_init_cmd_v2, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_init_rsp_v2, sizeof(nci_init_rsp_v2));\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_rf_disc_map_cmd))\n\t\tgoto error;\n\tif (memcmp(nci_rf_disc_map_cmd, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_rf_disc_map_rsp, sizeof(nci_rf_disc_map_rsp));\n\n\treturn (void *)0;\nerror:\n\treturn (void *)-1;\n}\n\nFIXTURE_SETUP(NCI)\n{\n\tstruct msgtemplate msg;\n\tpthread_t thread_t;\n\t__u32 event_group;\n\tint status;\n\tint rc;\n\n\tself->open_state = false;\n\tself->proto = VIRTUAL_NFC_PROTOCOLS;\n\tself->isNCI2 = variant->isNCI2;\n\n\tself->sd = create_nl_socket();\n\tASSERT_NE(self->sd, -1);\n\n\tself->pid = getpid();\n\tself->fid = get_family_id(self->sd, self->pid, &event_group);\n\tASSERT_NE(self->fid, -1);\n\n\tself->virtual_nci_fd = open(\"/dev/virtual_nci\", O_RDWR);\n\tASSERT_GT(self->virtual_nci_fd, -1);\n\n\trc = setsockopt(self->sd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &event_group,\n\t\t\tsizeof(event_group));\n\tASSERT_NE(rc, -1);\n\n\trc = ioctl(self->virtual_nci_fd, IOCTL_GET_NCIDEV_IDX, &self->dev_idex);\n\tASSERT_EQ(rc, 0);\n\n\trc = get_nci_devid(self->sd, self->fid, self->pid, self->dev_idex, &msg);\n\tASSERT_EQ(rc, 0);\n\tEXPECT_EQ(get_dev_enable_state(&msg), 0);\n\n\tif (self->isNCI2)\n\t\trc = pthread_create(&thread_t, NULL, virtual_dev_open_v2,\n\t\t\t\t    (void *)&self->virtual_nci_fd);\n\telse\n\t\trc = pthread_create(&thread_t, NULL, virtual_dev_open,\n\t\t\t\t    (void *)&self->virtual_nci_fd);\n\tASSERT_GT(rc, -1);\n\n\trc = send_cmd_with_idx(self->sd, self->fid, self->pid,\n\t\t\t       NFC_CMD_DEV_UP, self->dev_idex);\n\tEXPECT_EQ(rc, 0);\n\n\tpthread_join(thread_t, (void **)&status);\n\tASSERT_EQ(status, 0);\n\tself->open_state = true;\n}\n\nstatic void *virtual_deinit(void *data)\n{\n\tchar buf[258];\n\tint dev_fd;\n\tint len;\n\n\tdev_fd = *(int *)data;\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_reset_cmd))\n\t\tgoto error;\n\tif (memcmp(nci_reset_cmd, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_reset_rsp, sizeof(nci_reset_rsp));\n\n\treturn (void *)0;\nerror:\n\treturn (void *)-1;\n}\n\nstatic void *virtual_deinit_v2(void *data)\n{\n\tchar buf[258];\n\tint dev_fd;\n\tint len;\n\n\tdev_fd = *(int *)data;\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_reset_cmd))\n\t\tgoto error;\n\tif (memcmp(nci_reset_cmd, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_reset_rsp_v2, sizeof(nci_reset_rsp_v2));\n\twrite(dev_fd, nci_reset_ntf, sizeof(nci_reset_ntf));\n\n\treturn (void *)0;\nerror:\n\treturn (void *)-1;\n}\n\nFIXTURE_TEARDOWN(NCI)\n{\n\tpthread_t thread_t;\n\tint status;\n\tint rc;\n\n\tif (self->open_state) {\n\t\tif (self->isNCI2)\n\t\t\trc = pthread_create(&thread_t, NULL,\n\t\t\t\t\t    virtual_deinit_v2,\n\t\t\t\t\t    (void *)&self->virtual_nci_fd);\n\t\telse\n\t\t\trc = pthread_create(&thread_t, NULL, virtual_deinit,\n\t\t\t\t\t    (void *)&self->virtual_nci_fd);\n\n\t\tASSERT_GT(rc, -1);\n\t\trc = send_cmd_with_idx(self->sd, self->fid, self->pid,\n\t\t\t\t       NFC_CMD_DEV_DOWN, self->dev_idex);\n\t\tEXPECT_EQ(rc, 0);\n\n\t\tpthread_join(thread_t, (void **)&status);\n\t\tASSERT_EQ(status, 0);\n\t}\n\n\tclose(self->sd);\n\tclose(self->virtual_nci_fd);\n\tself->open_state = false;\n}\n\nTEST_F(NCI, init)\n{\n\tstruct msgtemplate msg;\n\tint rc;\n\n\trc = get_nci_devid(self->sd, self->fid, self->pid, self->dev_idex,\n\t\t\t   &msg);\n\tASSERT_EQ(rc, 0);\n\tEXPECT_EQ(get_dev_enable_state(&msg), 1);\n}\n\nstatic void *virtual_poll_start(void *data)\n{\n\tchar buf[258];\n\tint dev_fd;\n\tint len;\n\n\tdev_fd = *(int *)data;\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_rf_discovery_cmd))\n\t\tgoto error;\n\tif (memcmp(nci_rf_discovery_cmd, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_rf_disc_rsp, sizeof(nci_rf_disc_rsp));\n\n\treturn (void *)0;\nerror:\n\treturn (void *)-1;\n}\n\nstatic void *virtual_poll_stop(void *data)\n{\n\tchar buf[258];\n\tint dev_fd;\n\tint len;\n\n\tdev_fd = *(int *)data;\n\n\tlen = read(dev_fd, buf, 258);\n\tif (len <= 0)\n\t\tgoto error;\n\tif (len != sizeof(nci_rf_deact_cmd))\n\t\tgoto error;\n\tif (memcmp(nci_rf_deact_cmd, buf, len))\n\t\tgoto error;\n\twrite(dev_fd, nci_rf_deact_rsp, sizeof(nci_rf_deact_rsp));\n\n\treturn (void *)0;\nerror:\n\treturn (void *)-1;\n}\n\nint start_polling(int dev_idx, int proto, int virtual_fd, int sd, int fid, int pid)\n{\n\t__u16 nla_start_poll_type[2] = {NFC_ATTR_DEVICE_INDEX,\n\t\t\t\t\t NFC_ATTR_PROTOCOLS};\n\tvoid *nla_start_poll_data[2] = {&dev_idx, &proto};\n\tint nla_start_poll_len[2] = {4, 4};\n\tpthread_t thread_t;\n\tint status;\n\tint rc;\n\n\trc = pthread_create(&thread_t, NULL, virtual_poll_start,\n\t\t\t    (void *)&virtual_fd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = send_cmd_mt_nla(sd, fid, pid, NFC_CMD_START_POLL, 2, nla_start_poll_type,\n\t\t\t     nla_start_poll_data, nla_start_poll_len, NLM_F_REQUEST);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tpthread_join(thread_t, (void **)&status);\n\treturn status;\n}\n\nint stop_polling(int dev_idx, int virtual_fd, int sd, int fid, int pid)\n{\n\tpthread_t thread_t;\n\tint status;\n\tint rc;\n\n\trc = pthread_create(&thread_t, NULL, virtual_poll_stop,\n\t\t\t    (void *)&virtual_fd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = send_cmd_with_idx(sd, fid, pid,\n\t\t\t       NFC_CMD_STOP_POLL, dev_idx);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tpthread_join(thread_t, (void **)&status);\n\treturn status;\n}\n\nTEST_F(NCI, start_poll)\n{\n\tint status;\n\n\tstatus = start_polling(self->dev_idex, self->proto, self->virtual_nci_fd,\n\t\t\t       self->sd, self->fid, self->pid);\n\tEXPECT_EQ(status, 0);\n\n\tstatus = stop_polling(self->dev_idex, self->virtual_nci_fd, self->sd,\n\t\t\t      self->fid, self->pid);\n\tEXPECT_EQ(status, 0);\n}\n\nint get_taginfo(int dev_idx, int sd, int fid, int pid)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct genlmsghdr g;\n\t\tchar buf[512];\n\t} ans;\n\n\tstruct nlattr *na;\n\t__u32 protocol;\n\tint targetidx;\n\t__u8 sel_res;\n\tint resp_len;\n\tint len;\n\n\t__u16 tagid_type;\n\tvoid *tagid_type_data;\n\tint tagid_len;\n\n\ttagid_type = NFC_ATTR_DEVICE_INDEX;\n\ttagid_type_data = &dev_idx;\n\ttagid_len = 4;\n\n\tsend_cmd_mt_nla(sd, fid, pid, NFC_CMD_GET_TARGET, 1, &tagid_type,\n\t\t\t&tagid_type_data, &tagid_len, NLM_F_REQUEST | NLM_F_DUMP);\n\tresp_len = recv(sd, &ans, sizeof(ans), 0);\n\tif (ans.n.nlmsg_type == NLMSG_ERROR || resp_len < 0 ||\n\t    !NLMSG_OK(&ans.n, resp_len))\n\t\treturn -1;\n\n\tresp_len = GENLMSG_PAYLOAD(&ans.n);\n\tna = (struct nlattr *)GENLMSG_DATA(&ans);\n\n\tlen = 0;\n\ttargetidx = -1;\n\tprotocol = -1;\n\tsel_res = -1;\n\n\twhile (len < resp_len) {\n\t\tlen += NLA_ALIGN(na->nla_len);\n\n\t\tif (na->nla_type == NFC_ATTR_TARGET_INDEX)\n\t\t\ttargetidx = *(int *)((char *)na + NLA_HDRLEN);\n\t\telse if (na->nla_type == NFC_ATTR_TARGET_SEL_RES)\n\t\t\tsel_res = *(__u8 *)((char *)na + NLA_HDRLEN);\n\t\telse if (na->nla_type == NFC_ATTR_PROTOCOLS)\n\t\t\tprotocol = *(__u32 *)((char *)na + NLA_HDRLEN);\n\n\t\tna = (struct nlattr *)(GENLMSG_DATA(&ans) + len);\n\t}\n\n\tif (targetidx == -1 || sel_res != 0x20 || protocol != NFC_PROTO_ISO14443_MASK)\n\t\treturn -1;\n\n\treturn targetidx;\n}\n\nint connect_socket(int dev_idx, int target_idx)\n{\n\tstruct sockaddr_nfc addr;\n\tint sock;\n\tint err = 0;\n\n\tsock = socket(AF_NFC, SOCK_SEQPACKET, NFC_SOCKPROTO_RAW);\n\tif (sock == -1)\n\t\treturn -1;\n\n\taddr.sa_family = AF_NFC;\n\taddr.dev_idx = dev_idx;\n\taddr.target_idx = target_idx;\n\taddr.nfc_protocol = NFC_PROTO_ISO14443;\n\n\terr = connect(sock, (struct sockaddr *)&addr, sizeof(addr));\n\tif (err) {\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}\n\nint connect_tag(int dev_idx, int virtual_fd, int sd, int fid, int pid)\n{\n\tstruct genlmsghdr *genlhdr;\n\tstruct nlattr *na;\n\tchar evt_data[255];\n\tint target_idx;\n\tint resp_len;\n\tint evt_dev;\n\n\twrite(virtual_fd, nci_rf_activate_ntf, sizeof(nci_rf_activate_ntf));\n\tresp_len = recv(sd, evt_data, sizeof(evt_data), 0);\n\tif (resp_len < 0)\n\t\treturn -1;\n\n\tgenlhdr = (struct genlmsghdr *)((struct nlmsghdr *)evt_data + 1);\n\tna = (struct nlattr *)(genlhdr + 1);\n\tevt_dev = *(int *)((char *)na + NLA_HDRLEN);\n\tif (dev_idx != evt_dev)\n\t\treturn -1;\n\n\ttarget_idx = get_taginfo(dev_idx, sd, fid, pid);\n\tif (target_idx == -1)\n\t\treturn -1;\n\treturn connect_socket(dev_idx, target_idx);\n}\n\nint read_write_nci_cmd(int nfc_sock, int virtual_fd, const __u8 *cmd, __u32 cmd_len,\n\t\t       const __u8 *rsp, __u32 rsp_len)\n{\n\tchar buf[256];\n\tint len;\n\n\tsend(nfc_sock, &cmd[3], cmd_len - 3, 0);\n\tlen = read(virtual_fd, buf, cmd_len);\n\tif (len < 0 || memcmp(buf, cmd, cmd_len))\n\t\treturn -1;\n\n\twrite(virtual_fd, rsp, rsp_len);\n\tlen = recv(nfc_sock, buf, rsp_len - 2, 0);\n\tif (len < 0 || memcmp(&buf[1], &rsp[3], rsp_len - 3))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint read_tag(int nfc_sock, int virtual_fd)\n{\n\tif (read_write_nci_cmd(nfc_sock, virtual_fd, nci_t4t_select_cmd,\n\t\t\t       sizeof(nci_t4t_select_cmd), nci_t4t_rsp_ok,\n\t\t\t       sizeof(nci_t4t_rsp_ok)))\n\t\treturn -1;\n\n\tif (read_write_nci_cmd(nfc_sock, virtual_fd, nci_t4t_select_cmd2,\n\t\t\t       sizeof(nci_t4t_select_cmd2), nci_t4t_rsp_ok,\n\t\t\t       sizeof(nci_t4t_rsp_ok)))\n\t\treturn -1;\n\n\tif (read_write_nci_cmd(nfc_sock, virtual_fd, nci_t4t_read_cmd,\n\t\t\t       sizeof(nci_t4t_read_cmd), nci_t4t_read_rsp,\n\t\t\t       sizeof(nci_t4t_read_rsp)))\n\t\treturn -1;\n\n\tif (read_write_nci_cmd(nfc_sock, virtual_fd, nci_t4t_select_cmd3,\n\t\t\t       sizeof(nci_t4t_select_cmd3), nci_t4t_rsp_ok,\n\t\t\t       sizeof(nci_t4t_rsp_ok)))\n\t\treturn -1;\n\n\tif (read_write_nci_cmd(nfc_sock, virtual_fd, nci_t4t_read_cmd2,\n\t\t\t       sizeof(nci_t4t_read_cmd2), nci_t4t_read_rsp2,\n\t\t\t       sizeof(nci_t4t_read_rsp2)))\n\t\treturn -1;\n\n\treturn read_write_nci_cmd(nfc_sock, virtual_fd, nci_t4t_read_cmd3,\n\t\t\t\t  sizeof(nci_t4t_read_cmd3), nci_t4t_read_rsp3,\n\t\t\t\t  sizeof(nci_t4t_read_rsp3));\n}\n\nstatic void *virtual_deactivate_proc(void *data)\n{\n\tint virtual_fd;\n\tchar buf[256];\n\tint deactcmd_len;\n\tint len;\n\n\tvirtual_fd = *(int *)data;\n\tdeactcmd_len = sizeof(nci_rf_deact_cmd);\n\tlen = read(virtual_fd, buf, deactcmd_len);\n\tif (len != deactcmd_len || memcmp(buf, nci_rf_deact_cmd, deactcmd_len))\n\t\treturn (void *)-1;\n\n\twrite(virtual_fd, nci_rf_deact_rsp, sizeof(nci_rf_deact_rsp));\n\twrite(virtual_fd, nci_rf_deact_ntf, sizeof(nci_rf_deact_ntf));\n\n\treturn (void *)0;\n}\n\nint disconnect_tag(int nfc_sock, int virtual_fd)\n{\n\tpthread_t thread_t;\n\tchar buf[256];\n\tint status;\n\tint len;\n\n\tsend(nfc_sock, &nci_t4t_select_cmd3[3], sizeof(nci_t4t_select_cmd3) - 3, 0);\n\tlen = read(virtual_fd, buf, sizeof(nci_t4t_select_cmd3));\n\tif (len < 0 || memcmp(buf, nci_t4t_select_cmd3, sizeof(nci_t4t_select_cmd3)))\n\t\treturn -1;\n\n\tlen = recv(nfc_sock, buf, sizeof(nci_t4t_rsp_ok), 0);\n\tif (len != -1)\n\t\treturn -1;\n\n\tstatus = pthread_create(&thread_t, NULL, virtual_deactivate_proc,\n\t\t\t\t(void *)&virtual_fd);\n\n\tclose(nfc_sock);\n\tpthread_join(thread_t, (void **)&status);\n\treturn status;\n}\n\nTEST_F(NCI, t4t_tag_read)\n{\n\tint nfc_sock;\n\tint status;\n\n\tstatus = start_polling(self->dev_idex, self->proto, self->virtual_nci_fd,\n\t\t\t       self->sd, self->fid, self->pid);\n\tEXPECT_EQ(status, 0);\n\n\tnfc_sock = connect_tag(self->dev_idex, self->virtual_nci_fd, self->sd,\n\t\t\t       self->fid, self->pid);\n\tASSERT_GT(nfc_sock, -1);\n\n\tstatus = read_tag(nfc_sock, self->virtual_nci_fd);\n\tASSERT_EQ(status, 0);\n\n\tstatus = disconnect_tag(nfc_sock, self->virtual_nci_fd);\n\tEXPECT_EQ(status, 0);\n}\n\nTEST_F(NCI, deinit)\n{\n\tstruct msgtemplate msg;\n\tpthread_t thread_t;\n\tint status;\n\tint rc;\n\n\trc = get_nci_devid(self->sd, self->fid, self->pid, self->dev_idex,\n\t\t\t   &msg);\n\tASSERT_EQ(rc, 0);\n\tEXPECT_EQ(get_dev_enable_state(&msg), 1);\n\n\tif (self->isNCI2)\n\t\trc = pthread_create(&thread_t, NULL, virtual_deinit_v2,\n\t\t\t\t    (void *)&self->virtual_nci_fd);\n\telse\n\t\trc = pthread_create(&thread_t, NULL, virtual_deinit,\n\t\t\t\t    (void *)&self->virtual_nci_fd);\n\tASSERT_GT(rc, -1);\n\n\trc = send_cmd_with_idx(self->sd, self->fid, self->pid,\n\t\t\t       NFC_CMD_DEV_DOWN, self->dev_idex);\n\tEXPECT_EQ(rc, 0);\n\n\tpthread_join(thread_t, (void **)&status);\n\tself->open_state = 0;\n\tASSERT_EQ(status, 0);\n\n\trc = get_nci_devid(self->sd, self->fid, self->pid, self->dev_idex,\n\t\t\t   &msg);\n\tASSERT_EQ(rc, 0);\n\tEXPECT_EQ(get_dev_enable_state(&msg), 0);\n\n\t \n\tclose(self->virtual_nci_fd);\n\tself->virtual_nci_fd = -1;\n\trc = send_cmd_with_idx(self->sd, self->fid, self->pid,\n\t\t\t       NFC_CMD_DEV_UP, self->dev_idex);\n\tEXPECT_EQ(rc, 0);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}