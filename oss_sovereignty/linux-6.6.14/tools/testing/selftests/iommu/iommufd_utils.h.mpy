{
  "module_name": "iommufd_utils.h",
  "hash_id": "858071e47d2c38c00cba009f7b905c8bce95f2d00cb4e229877258e3effed8e4",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/iommu/iommufd_utils.h",
  "human_readable_source": " \n \n#ifndef __SELFTEST_IOMMUFD_UTILS\n#define __SELFTEST_IOMMUFD_UTILS\n\n#include <unistd.h>\n#include <stddef.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <stdint.h>\n#include <assert.h>\n\n#include \"../kselftest_harness.h\"\n#include \"../../../../drivers/iommu/iommufd/iommufd_test.h\"\n\n \n#define _IOMMU_TEST_CMD(x) IOMMU_TEST_CMD\n\nstatic void *buffer;\nstatic unsigned long BUFFER_SIZE;\n\nstatic unsigned long PAGE_SIZE;\n\n#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))\n#define offsetofend(TYPE, MEMBER) \\\n\t(offsetof(TYPE, MEMBER) + sizeof_field(TYPE, MEMBER))\n\n \n#define check_refs(_ptr, _length, _refs)                                      \\\n\t({                                                                    \\\n\t\tstruct iommu_test_cmd test_cmd = {                            \\\n\t\t\t.size = sizeof(test_cmd),                             \\\n\t\t\t.op = IOMMU_TEST_OP_MD_CHECK_REFS,                    \\\n\t\t\t.check_refs = { .length = _length,                    \\\n\t\t\t\t\t.uptr = (uintptr_t)(_ptr),            \\\n\t\t\t\t\t.refs = _refs },                      \\\n\t\t};                                                            \\\n\t\tASSERT_EQ(0,                                                  \\\n\t\t\t  ioctl(self->fd,                                     \\\n\t\t\t\t_IOMMU_TEST_CMD(IOMMU_TEST_OP_MD_CHECK_REFS), \\\n\t\t\t\t&test_cmd));                                  \\\n\t})\n\nstatic int _test_cmd_mock_domain(int fd, unsigned int ioas_id, __u32 *stdev_id,\n\t\t\t\t __u32 *hwpt_id, __u32 *idev_id)\n{\n\tstruct iommu_test_cmd cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.op = IOMMU_TEST_OP_MOCK_DOMAIN,\n\t\t.id = ioas_id,\n\t\t.mock_domain = {},\n\t};\n\tint ret;\n\n\tret = ioctl(fd, IOMMU_TEST_CMD, &cmd);\n\tif (ret)\n\t\treturn ret;\n\tif (stdev_id)\n\t\t*stdev_id = cmd.mock_domain.out_stdev_id;\n\tassert(cmd.id != 0);\n\tif (hwpt_id)\n\t\t*hwpt_id = cmd.mock_domain.out_hwpt_id;\n\tif (idev_id)\n\t\t*idev_id = cmd.mock_domain.out_idev_id;\n\treturn 0;\n}\n#define test_cmd_mock_domain(ioas_id, stdev_id, hwpt_id, idev_id)       \\\n\tASSERT_EQ(0, _test_cmd_mock_domain(self->fd, ioas_id, stdev_id, \\\n\t\t\t\t\t   hwpt_id, idev_id))\n#define test_err_mock_domain(_errno, ioas_id, stdev_id, hwpt_id)      \\\n\tEXPECT_ERRNO(_errno, _test_cmd_mock_domain(self->fd, ioas_id, \\\n\t\t\t\t\t\t   stdev_id, hwpt_id, NULL))\n\nstatic int _test_cmd_mock_domain_replace(int fd, __u32 stdev_id, __u32 pt_id,\n\t\t\t\t\t __u32 *hwpt_id)\n{\n\tstruct iommu_test_cmd cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.op = IOMMU_TEST_OP_MOCK_DOMAIN_REPLACE,\n\t\t.id = stdev_id,\n\t\t.mock_domain_replace = {\n\t\t\t.pt_id = pt_id,\n\t\t},\n\t};\n\tint ret;\n\n\tret = ioctl(fd, IOMMU_TEST_CMD, &cmd);\n\tif (ret)\n\t\treturn ret;\n\tif (hwpt_id)\n\t\t*hwpt_id = cmd.mock_domain_replace.pt_id;\n\treturn 0;\n}\n\n#define test_cmd_mock_domain_replace(stdev_id, pt_id)                         \\\n\tASSERT_EQ(0, _test_cmd_mock_domain_replace(self->fd, stdev_id, pt_id, \\\n\t\t\t\t\t\t   NULL))\n#define test_err_mock_domain_replace(_errno, stdev_id, pt_id)                  \\\n\tEXPECT_ERRNO(_errno, _test_cmd_mock_domain_replace(self->fd, stdev_id, \\\n\t\t\t\t\t\t\t   pt_id, NULL))\n\nstatic int _test_cmd_hwpt_alloc(int fd, __u32 device_id, __u32 pt_id,\n\t\t\t\t\t __u32 *hwpt_id)\n{\n\tstruct iommu_hwpt_alloc cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.dev_id = device_id,\n\t\t.pt_id = pt_id,\n\t};\n\tint ret;\n\n\tret = ioctl(fd, IOMMU_HWPT_ALLOC, &cmd);\n\tif (ret)\n\t\treturn ret;\n\tif (hwpt_id)\n\t\t*hwpt_id = cmd.out_hwpt_id;\n\treturn 0;\n}\n\n#define test_cmd_hwpt_alloc(device_id, pt_id, hwpt_id) \\\n\tASSERT_EQ(0, _test_cmd_hwpt_alloc(self->fd, device_id, pt_id, hwpt_id))\n\nstatic int _test_cmd_access_replace_ioas(int fd, __u32 access_id,\n\t\t\t\t\t unsigned int ioas_id)\n{\n\tstruct iommu_test_cmd cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.op = IOMMU_TEST_OP_ACCESS_REPLACE_IOAS,\n\t\t.id = access_id,\n\t\t.access_replace_ioas = { .ioas_id = ioas_id },\n\t};\n\tint ret;\n\n\tret = ioctl(fd, IOMMU_TEST_CMD, &cmd);\n\tif (ret)\n\t\treturn ret;\n\treturn 0;\n}\n#define test_cmd_access_replace_ioas(access_id, ioas_id) \\\n\tASSERT_EQ(0, _test_cmd_access_replace_ioas(self->fd, access_id, ioas_id))\n\nstatic int _test_cmd_create_access(int fd, unsigned int ioas_id,\n\t\t\t\t   __u32 *access_id, unsigned int flags)\n{\n\tstruct iommu_test_cmd cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.op = IOMMU_TEST_OP_CREATE_ACCESS,\n\t\t.id = ioas_id,\n\t\t.create_access = { .flags = flags },\n\t};\n\tint ret;\n\n\tret = ioctl(fd, IOMMU_TEST_CMD, &cmd);\n\tif (ret)\n\t\treturn ret;\n\t*access_id = cmd.create_access.out_access_fd;\n\treturn 0;\n}\n#define test_cmd_create_access(ioas_id, access_id, flags)                  \\\n\tASSERT_EQ(0, _test_cmd_create_access(self->fd, ioas_id, access_id, \\\n\t\t\t\t\t     flags))\n\nstatic int _test_cmd_destroy_access(unsigned int access_id)\n{\n\treturn close(access_id);\n}\n#define test_cmd_destroy_access(access_id) \\\n\tASSERT_EQ(0, _test_cmd_destroy_access(access_id))\n\nstatic int _test_cmd_destroy_access_pages(int fd, unsigned int access_id,\n\t\t\t\t\t  unsigned int access_pages_id)\n{\n\tstruct iommu_test_cmd cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.op = IOMMU_TEST_OP_DESTROY_ACCESS_PAGES,\n\t\t.id = access_id,\n\t\t.destroy_access_pages = { .access_pages_id = access_pages_id },\n\t};\n\treturn ioctl(fd, IOMMU_TEST_CMD, &cmd);\n}\n#define test_cmd_destroy_access_pages(access_id, access_pages_id)        \\\n\tASSERT_EQ(0, _test_cmd_destroy_access_pages(self->fd, access_id, \\\n\t\t\t\t\t\t    access_pages_id))\n#define test_err_destroy_access_pages(_errno, access_id, access_pages_id) \\\n\tEXPECT_ERRNO(_errno, _test_cmd_destroy_access_pages(              \\\n\t\t\t\t     self->fd, access_id, access_pages_id))\n\nstatic int _test_ioctl_destroy(int fd, unsigned int id)\n{\n\tstruct iommu_destroy cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.id = id,\n\t};\n\treturn ioctl(fd, IOMMU_DESTROY, &cmd);\n}\n#define test_ioctl_destroy(id) ASSERT_EQ(0, _test_ioctl_destroy(self->fd, id))\n\nstatic int _test_ioctl_ioas_alloc(int fd, __u32 *id)\n{\n\tstruct iommu_ioas_alloc cmd = {\n\t\t.size = sizeof(cmd),\n\t};\n\tint ret;\n\n\tret = ioctl(fd, IOMMU_IOAS_ALLOC, &cmd);\n\tif (ret)\n\t\treturn ret;\n\t*id = cmd.out_ioas_id;\n\treturn 0;\n}\n#define test_ioctl_ioas_alloc(id)                                   \\\n\t({                                                          \\\n\t\tASSERT_EQ(0, _test_ioctl_ioas_alloc(self->fd, id)); \\\n\t\tASSERT_NE(0, *(id));                                \\\n\t})\n\nstatic int _test_ioctl_ioas_map(int fd, unsigned int ioas_id, void *buffer,\n\t\t\t\tsize_t length, __u64 *iova, unsigned int flags)\n{\n\tstruct iommu_ioas_map cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.flags = flags,\n\t\t.ioas_id = ioas_id,\n\t\t.user_va = (uintptr_t)buffer,\n\t\t.length = length,\n\t};\n\tint ret;\n\n\tif (flags & IOMMU_IOAS_MAP_FIXED_IOVA)\n\t\tcmd.iova = *iova;\n\n\tret = ioctl(fd, IOMMU_IOAS_MAP, &cmd);\n\t*iova = cmd.iova;\n\treturn ret;\n}\n#define test_ioctl_ioas_map(buffer, length, iova_p)                        \\\n\tASSERT_EQ(0, _test_ioctl_ioas_map(self->fd, self->ioas_id, buffer, \\\n\t\t\t\t\t  length, iova_p,                  \\\n\t\t\t\t\t  IOMMU_IOAS_MAP_WRITEABLE |       \\\n\t\t\t\t\t\t  IOMMU_IOAS_MAP_READABLE))\n\n#define test_err_ioctl_ioas_map(_errno, buffer, length, iova_p)            \\\n\tEXPECT_ERRNO(_errno,                                               \\\n\t\t     _test_ioctl_ioas_map(self->fd, self->ioas_id, buffer, \\\n\t\t\t\t\t  length, iova_p,                  \\\n\t\t\t\t\t  IOMMU_IOAS_MAP_WRITEABLE |       \\\n\t\t\t\t\t\t  IOMMU_IOAS_MAP_READABLE))\n\n#define test_ioctl_ioas_map_id(ioas_id, buffer, length, iova_p)              \\\n\tASSERT_EQ(0, _test_ioctl_ioas_map(self->fd, ioas_id, buffer, length, \\\n\t\t\t\t\t  iova_p,                            \\\n\t\t\t\t\t  IOMMU_IOAS_MAP_WRITEABLE |         \\\n\t\t\t\t\t\t  IOMMU_IOAS_MAP_READABLE))\n\n#define test_ioctl_ioas_map_fixed(buffer, length, iova)                       \\\n\t({                                                                    \\\n\t\t__u64 __iova = iova;                                          \\\n\t\tASSERT_EQ(0, _test_ioctl_ioas_map(                            \\\n\t\t\t\t     self->fd, self->ioas_id, buffer, length, \\\n\t\t\t\t     &__iova,                                 \\\n\t\t\t\t     IOMMU_IOAS_MAP_FIXED_IOVA |              \\\n\t\t\t\t\t     IOMMU_IOAS_MAP_WRITEABLE |       \\\n\t\t\t\t\t     IOMMU_IOAS_MAP_READABLE));       \\\n\t})\n\n#define test_err_ioctl_ioas_map_fixed(_errno, buffer, length, iova)           \\\n\t({                                                                    \\\n\t\t__u64 __iova = iova;                                          \\\n\t\tEXPECT_ERRNO(_errno,                                          \\\n\t\t\t     _test_ioctl_ioas_map(                            \\\n\t\t\t\t     self->fd, self->ioas_id, buffer, length, \\\n\t\t\t\t     &__iova,                                 \\\n\t\t\t\t     IOMMU_IOAS_MAP_FIXED_IOVA |              \\\n\t\t\t\t\t     IOMMU_IOAS_MAP_WRITEABLE |       \\\n\t\t\t\t\t     IOMMU_IOAS_MAP_READABLE));       \\\n\t})\n\nstatic int _test_ioctl_ioas_unmap(int fd, unsigned int ioas_id, uint64_t iova,\n\t\t\t\t  size_t length, uint64_t *out_len)\n{\n\tstruct iommu_ioas_unmap cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.ioas_id = ioas_id,\n\t\t.iova = iova,\n\t\t.length = length,\n\t};\n\tint ret;\n\n\tret = ioctl(fd, IOMMU_IOAS_UNMAP, &cmd);\n\tif (out_len)\n\t\t*out_len = cmd.length;\n\treturn ret;\n}\n#define test_ioctl_ioas_unmap(iova, length)                                \\\n\tASSERT_EQ(0, _test_ioctl_ioas_unmap(self->fd, self->ioas_id, iova, \\\n\t\t\t\t\t    length, NULL))\n\n#define test_ioctl_ioas_unmap_id(ioas_id, iova, length)                      \\\n\tASSERT_EQ(0, _test_ioctl_ioas_unmap(self->fd, ioas_id, iova, length, \\\n\t\t\t\t\t    NULL))\n\n#define test_err_ioctl_ioas_unmap(_errno, iova, length)                      \\\n\tEXPECT_ERRNO(_errno, _test_ioctl_ioas_unmap(self->fd, self->ioas_id, \\\n\t\t\t\t\t\t    iova, length, NULL))\n\nstatic int _test_ioctl_set_temp_memory_limit(int fd, unsigned int limit)\n{\n\tstruct iommu_test_cmd memlimit_cmd = {\n\t\t.size = sizeof(memlimit_cmd),\n\t\t.op = IOMMU_TEST_OP_SET_TEMP_MEMORY_LIMIT,\n\t\t.memory_limit = { .limit = limit },\n\t};\n\n\treturn ioctl(fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_SET_TEMP_MEMORY_LIMIT),\n\t\t     &memlimit_cmd);\n}\n\n#define test_ioctl_set_temp_memory_limit(limit) \\\n\tASSERT_EQ(0, _test_ioctl_set_temp_memory_limit(self->fd, limit))\n\n#define test_ioctl_set_default_memory_limit() \\\n\ttest_ioctl_set_temp_memory_limit(65536)\n\nstatic void teardown_iommufd(int fd, struct __test_metadata *_metadata)\n{\n\tstruct iommu_test_cmd test_cmd = {\n\t\t.size = sizeof(test_cmd),\n\t\t.op = IOMMU_TEST_OP_MD_CHECK_REFS,\n\t\t.check_refs = { .length = BUFFER_SIZE,\n\t\t\t\t.uptr = (uintptr_t)buffer },\n\t};\n\n\tif (fd == -1)\n\t\treturn;\n\n\tEXPECT_EQ(0, close(fd));\n\n\tfd = open(\"/dev/iommu\", O_RDWR);\n\tEXPECT_NE(-1, fd);\n\tEXPECT_EQ(0, ioctl(fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_MD_CHECK_REFS),\n\t\t\t   &test_cmd));\n\tEXPECT_EQ(0, close(fd));\n}\n\n#define EXPECT_ERRNO(expected_errno, cmd)         \\\n\t({                                        \\\n\t\tASSERT_EQ(-1, cmd);               \\\n\t\tEXPECT_EQ(expected_errno, errno); \\\n\t})\n\n#endif\n\n \nstatic int _test_cmd_get_hw_info(int fd, __u32 device_id,\n\t\t\t\t void *data, size_t data_len)\n{\n\tstruct iommu_test_hw_info *info = (struct iommu_test_hw_info *)data;\n\tstruct iommu_hw_info cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.dev_id = device_id,\n\t\t.data_len = data_len,\n\t\t.data_uptr = (uint64_t)data,\n\t};\n\tint ret;\n\n\tret = ioctl(fd, IOMMU_GET_HW_INFO, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tassert(cmd.out_data_type == IOMMU_HW_INFO_TYPE_SELFTEST);\n\n\t \n\tassert(cmd.data_len == sizeof(struct iommu_test_hw_info));\n\n\t \n\tif (data_len > cmd.data_len) {\n\t\tchar *ptr = (char *)(data + cmd.data_len);\n\t\tint idx = 0;\n\n\t\twhile (idx < data_len - cmd.data_len) {\n\t\t\tassert(!*(ptr + idx));\n\t\t\tidx++;\n\t\t}\n\t}\n\n\tif (info) {\n\t\tif (data_len >= offsetofend(struct iommu_test_hw_info, test_reg))\n\t\t\tassert(info->test_reg == IOMMU_HW_INFO_SELFTEST_REGVAL);\n\t\tif (data_len >= offsetofend(struct iommu_test_hw_info, flags))\n\t\t\tassert(!info->flags);\n\t}\n\n\treturn 0;\n}\n\n#define test_cmd_get_hw_info(device_id, data, data_len)         \\\n\tASSERT_EQ(0, _test_cmd_get_hw_info(self->fd, device_id, \\\n\t\t\t\t\t   data, data_len))\n\n#define test_err_get_hw_info(_errno, device_id, data, data_len) \\\n\tEXPECT_ERRNO(_errno,                                    \\\n\t\t     _test_cmd_get_hw_info(self->fd, device_id, \\\n\t\t\t\t\t   data, data_len))\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}