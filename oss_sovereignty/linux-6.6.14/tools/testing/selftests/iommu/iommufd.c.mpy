{
  "module_name": "iommufd.c",
  "hash_id": "eb2eedbaa67a25c560164ef10e6ecf6c3f1bd2807a949bc4d29ac0280b69822c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/iommu/iommufd.c",
  "human_readable_source": "\n \n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/eventfd.h>\n\n#define __EXPORTED_HEADERS__\n#include <linux/vfio.h>\n\n#include \"iommufd_utils.h\"\n\nstatic unsigned long HUGEPAGE_SIZE;\n\n#define MOCK_PAGE_SIZE (PAGE_SIZE / 2)\n\nstatic unsigned long get_huge_page_size(void)\n{\n\tchar buf[80];\n\tint ret;\n\tint fd;\n\n\tfd = open(\"/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\",\n\t\t  O_RDONLY);\n\tif (fd < 0)\n\t\treturn 2 * 1024 * 1024;\n\n\tret = read(fd, buf, sizeof(buf));\n\tclose(fd);\n\tif (ret <= 0 || ret == sizeof(buf))\n\t\treturn 2 * 1024 * 1024;\n\tbuf[ret] = 0;\n\treturn strtoul(buf, NULL, 10);\n}\n\nstatic __attribute__((constructor)) void setup_sizes(void)\n{\n\tvoid *vrc;\n\tint rc;\n\n\tPAGE_SIZE = sysconf(_SC_PAGE_SIZE);\n\tHUGEPAGE_SIZE = get_huge_page_size();\n\n\tBUFFER_SIZE = PAGE_SIZE * 16;\n\trc = posix_memalign(&buffer, HUGEPAGE_SIZE, BUFFER_SIZE);\n\tassert(!rc);\n\tassert(buffer);\n\tassert((uintptr_t)buffer % HUGEPAGE_SIZE == 0);\n\tvrc = mmap(buffer, BUFFER_SIZE, PROT_READ | PROT_WRITE,\n\t\t   MAP_SHARED | MAP_ANONYMOUS | MAP_FIXED, -1, 0);\n\tassert(vrc == buffer);\n}\n\nFIXTURE(iommufd)\n{\n\tint fd;\n};\n\nFIXTURE_SETUP(iommufd)\n{\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tASSERT_NE(-1, self->fd);\n}\n\nFIXTURE_TEARDOWN(iommufd)\n{\n\tteardown_iommufd(self->fd, _metadata);\n}\n\nTEST_F(iommufd, simple_close)\n{\n}\n\nTEST_F(iommufd, cmd_fail)\n{\n\tstruct iommu_destroy cmd = { .size = sizeof(cmd), .id = 0 };\n\n\t \n\tEXPECT_ERRNO(ENOENT, _test_ioctl_destroy(self->fd, 0));\n\t \n\tEXPECT_ERRNO(EFAULT, ioctl(self->fd, IOMMU_DESTROY, NULL));\n\t \n\tEXPECT_ERRNO(ENOTTY,\n\t\t     ioctl(self->fd, _IO(IOMMUFD_TYPE, IOMMUFD_CMD_BASE - 1),\n\t\t\t   &cmd));\n}\n\nTEST_F(iommufd, cmd_length)\n{\n#define TEST_LENGTH(_struct, _ioctl)                                     \\\n\t{                                                                \\\n\t\tstruct {                                                 \\\n\t\t\tstruct _struct cmd;                              \\\n\t\t\tuint8_t extra;                                   \\\n\t\t} cmd = { .cmd = { .size = sizeof(struct _struct) - 1 }, \\\n\t\t\t  .extra = UINT8_MAX };                          \\\n\t\tint old_errno;                                           \\\n\t\tint rc;                                                  \\\n\t\t\t\t\t\t\t\t\t \\\n\t\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, _ioctl, &cmd));     \\\n\t\tcmd.cmd.size = sizeof(struct _struct) + 1;               \\\n\t\tEXPECT_ERRNO(E2BIG, ioctl(self->fd, _ioctl, &cmd));      \\\n\t\tcmd.cmd.size = sizeof(struct _struct);                   \\\n\t\trc = ioctl(self->fd, _ioctl, &cmd);                      \\\n\t\told_errno = errno;                                       \\\n\t\tcmd.cmd.size = sizeof(struct _struct) + 1;               \\\n\t\tcmd.extra = 0;                                           \\\n\t\tif (rc) {                                                \\\n\t\t\tEXPECT_ERRNO(old_errno,                          \\\n\t\t\t\t     ioctl(self->fd, _ioctl, &cmd));     \\\n\t\t} else {                                                 \\\n\t\t\tASSERT_EQ(0, ioctl(self->fd, _ioctl, &cmd));     \\\n\t\t}                                                        \\\n\t}\n\n\tTEST_LENGTH(iommu_destroy, IOMMU_DESTROY);\n\tTEST_LENGTH(iommu_hw_info, IOMMU_GET_HW_INFO);\n\tTEST_LENGTH(iommu_ioas_alloc, IOMMU_IOAS_ALLOC);\n\tTEST_LENGTH(iommu_ioas_iova_ranges, IOMMU_IOAS_IOVA_RANGES);\n\tTEST_LENGTH(iommu_ioas_allow_iovas, IOMMU_IOAS_ALLOW_IOVAS);\n\tTEST_LENGTH(iommu_ioas_map, IOMMU_IOAS_MAP);\n\tTEST_LENGTH(iommu_ioas_copy, IOMMU_IOAS_COPY);\n\tTEST_LENGTH(iommu_ioas_unmap, IOMMU_IOAS_UNMAP);\n\tTEST_LENGTH(iommu_option, IOMMU_OPTION);\n\tTEST_LENGTH(iommu_vfio_ioas, IOMMU_VFIO_IOAS);\n#undef TEST_LENGTH\n}\n\nTEST_F(iommufd, cmd_ex_fail)\n{\n\tstruct {\n\t\tstruct iommu_destroy cmd;\n\t\t__u64 future;\n\t} cmd = { .cmd = { .size = sizeof(cmd), .id = 0 } };\n\n\t \n\tEXPECT_ERRNO(ENOENT, ioctl(self->fd, IOMMU_DESTROY, &cmd));\n\t \n\tcmd.future = 1;\n\tEXPECT_ERRNO(E2BIG, ioctl(self->fd, IOMMU_DESTROY, &cmd));\n\t \n\tcmd.cmd.size = sizeof(cmd.cmd);\n\tEXPECT_ERRNO(ENOENT, ioctl(self->fd, IOMMU_DESTROY, &cmd));\n\t \n\tcmd.cmd.size = sizeof(cmd.cmd) - 1;\n\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, IOMMU_DESTROY, &cmd));\n}\n\nTEST_F(iommufd, global_options)\n{\n\tstruct iommu_option cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.option_id = IOMMU_OPTION_RLIMIT_MODE,\n\t\t.op = IOMMU_OPTION_OP_GET,\n\t\t.val64 = 1,\n\t};\n\n\tcmd.option_id = IOMMU_OPTION_RLIMIT_MODE;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\tASSERT_EQ(0, cmd.val64);\n\n\t \n\tcmd.op = IOMMU_OPTION_OP_SET;\n\tcmd.val64 = 1;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\tcmd.val64 = 2;\n\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\n\tcmd.op = IOMMU_OPTION_OP_GET;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\tASSERT_EQ(1, cmd.val64);\n\n\tcmd.op = IOMMU_OPTION_OP_SET;\n\tcmd.val64 = 0;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\n\tcmd.op = IOMMU_OPTION_OP_GET;\n\tcmd.option_id = IOMMU_OPTION_HUGE_PAGES;\n\tEXPECT_ERRNO(ENOENT, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\tcmd.op = IOMMU_OPTION_OP_SET;\n\tEXPECT_ERRNO(ENOENT, ioctl(self->fd, IOMMU_OPTION, &cmd));\n}\n\nFIXTURE(iommufd_ioas)\n{\n\tint fd;\n\tuint32_t ioas_id;\n\tuint32_t stdev_id;\n\tuint32_t hwpt_id;\n\tuint32_t device_id;\n\tuint64_t base_iova;\n};\n\nFIXTURE_VARIANT(iommufd_ioas)\n{\n\tunsigned int mock_domains;\n\tunsigned int memory_limit;\n};\n\nFIXTURE_SETUP(iommufd_ioas)\n{\n\tunsigned int i;\n\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tASSERT_NE(-1, self->fd);\n\ttest_ioctl_ioas_alloc(&self->ioas_id);\n\n\tif (!variant->memory_limit) {\n\t\ttest_ioctl_set_default_memory_limit();\n\t} else {\n\t\ttest_ioctl_set_temp_memory_limit(variant->memory_limit);\n\t}\n\n\tfor (i = 0; i != variant->mock_domains; i++) {\n\t\ttest_cmd_mock_domain(self->ioas_id, &self->stdev_id,\n\t\t\t\t     &self->hwpt_id, &self->device_id);\n\t\tself->base_iova = MOCK_APERTURE_START;\n\t}\n}\n\nFIXTURE_TEARDOWN(iommufd_ioas)\n{\n\ttest_ioctl_set_default_memory_limit();\n\tteardown_iommufd(self->fd, _metadata);\n}\n\nFIXTURE_VARIANT_ADD(iommufd_ioas, no_domain)\n{\n};\n\nFIXTURE_VARIANT_ADD(iommufd_ioas, mock_domain)\n{\n\t.mock_domains = 1,\n};\n\nFIXTURE_VARIANT_ADD(iommufd_ioas, two_mock_domain)\n{\n\t.mock_domains = 2,\n};\n\nFIXTURE_VARIANT_ADD(iommufd_ioas, mock_domain_limit)\n{\n\t.mock_domains = 1,\n\t.memory_limit = 16,\n};\n\nTEST_F(iommufd_ioas, ioas_auto_destroy)\n{\n}\n\nTEST_F(iommufd_ioas, ioas_destroy)\n{\n\tif (self->stdev_id) {\n\t\t \n\t\tEXPECT_ERRNO(EBUSY,\n\t\t\t     _test_ioctl_destroy(self->fd, self->ioas_id));\n\t} else {\n\t\t \n\t\ttest_ioctl_destroy(self->ioas_id);\n\t}\n}\n\nTEST_F(iommufd_ioas, hwpt_attach)\n{\n\t \n\tif (self->stdev_id) {\n\t\ttest_cmd_mock_domain(self->hwpt_id, NULL, NULL, NULL);\n\t} else {\n\t\ttest_err_mock_domain(ENOENT, self->hwpt_id, NULL, NULL);\n\t}\n}\n\nTEST_F(iommufd_ioas, ioas_area_destroy)\n{\n\t \n\ttest_ioctl_ioas_map_fixed(buffer, PAGE_SIZE, self->base_iova);\n\tif (self->stdev_id)\n\t\tEXPECT_ERRNO(EBUSY,\n\t\t\t     _test_ioctl_destroy(self->fd, self->ioas_id));\n\telse\n\t\ttest_ioctl_destroy(self->ioas_id);\n}\n\nTEST_F(iommufd_ioas, ioas_area_auto_destroy)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i != 10; i++) {\n\t\ttest_ioctl_ioas_map_fixed(buffer, PAGE_SIZE,\n\t\t\t\t\t  self->base_iova + i * PAGE_SIZE);\n\t}\n}\n\nTEST_F(iommufd_ioas, get_hw_info)\n{\n\tstruct iommu_test_hw_info buffer_exact;\n\tstruct iommu_test_hw_info_buffer_larger {\n\t\tstruct iommu_test_hw_info info;\n\t\tuint64_t trailing_bytes;\n\t} buffer_larger;\n\tstruct iommu_test_hw_info_buffer_smaller {\n\t\t__u32 flags;\n\t} buffer_smaller;\n\n\tif (self->device_id) {\n\t\t \n\t\ttest_cmd_get_hw_info(self->device_id, NULL, 0);\n\t\t \n\t\ttest_cmd_get_hw_info(self->device_id, &buffer_exact, sizeof(buffer_exact));\n\t\t \n\t\ttest_cmd_get_hw_info(self->device_id, &buffer_larger, sizeof(buffer_larger));\n\t\t \n\t\ttest_cmd_get_hw_info(self->device_id, &buffer_smaller, sizeof(buffer_smaller));\n\t} else {\n\t\ttest_err_get_hw_info(ENOENT, self->device_id,\n\t\t\t\t     &buffer_exact, sizeof(buffer_exact));\n\t\ttest_err_get_hw_info(ENOENT, self->device_id,\n\t\t\t\t     &buffer_larger, sizeof(buffer_larger));\n\t}\n}\n\nTEST_F(iommufd_ioas, area)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i != 10; i++)\n\t\ttest_err_ioctl_ioas_unmap(ENOENT, i * PAGE_SIZE, PAGE_SIZE);\n\n\t \n\tfor (i = 0; i != 10; i++)\n\t\ttest_ioctl_ioas_map_fixed(buffer, PAGE_SIZE,\n\t\t\t\t\t  self->base_iova + i * PAGE_SIZE);\n\tfor (i = 0; i != 10; i++)\n\t\ttest_ioctl_ioas_unmap(self->base_iova + i * PAGE_SIZE,\n\t\t\t\t      PAGE_SIZE);\n\n\t \n\ttest_ioctl_ioas_map_fixed(buffer, PAGE_SIZE * 2,\n\t\t\t\t  self->base_iova + 16 * PAGE_SIZE);\n\ttest_err_ioctl_ioas_unmap(ENOENT, self->base_iova + 16 * PAGE_SIZE,\n\t\t\t\t  PAGE_SIZE);\n\ttest_err_ioctl_ioas_unmap(ENOENT, self->base_iova + 17 * PAGE_SIZE,\n\t\t\t\t  PAGE_SIZE);\n\n\t \n\ttest_err_ioctl_ioas_map_fixed(EEXIST, buffer, PAGE_SIZE * 2,\n\t\t\t\t      self->base_iova + 16 * PAGE_SIZE);\n\ttest_err_ioctl_ioas_map_fixed(EEXIST, buffer, PAGE_SIZE,\n\t\t\t\t      self->base_iova + 16 * PAGE_SIZE);\n\ttest_err_ioctl_ioas_map_fixed(EEXIST, buffer, PAGE_SIZE,\n\t\t\t\t      self->base_iova + 17 * PAGE_SIZE);\n\ttest_err_ioctl_ioas_map_fixed(EEXIST, buffer, PAGE_SIZE * 2,\n\t\t\t\t      self->base_iova + 15 * PAGE_SIZE);\n\ttest_err_ioctl_ioas_map_fixed(EEXIST, buffer, PAGE_SIZE * 3,\n\t\t\t\t      self->base_iova + 15 * PAGE_SIZE);\n\n\t \n\ttest_ioctl_ioas_unmap(0, UINT64_MAX);\n\n\t \n\ttest_ioctl_ioas_unmap(0, UINT64_MAX);\n}\n\nTEST_F(iommufd_ioas, unmap_fully_contained_areas)\n{\n\tuint64_t unmap_len;\n\tint i;\n\n\t \n\tself->base_iova += 4 * PAGE_SIZE;\n\n\tfor (i = 0; i != 4; i++)\n\t\ttest_ioctl_ioas_map_fixed(buffer, 8 * PAGE_SIZE,\n\t\t\t\t\t  self->base_iova + i * 16 * PAGE_SIZE);\n\n\t \n\ttest_err_ioctl_ioas_unmap(ENOENT, self->base_iova - 4 * PAGE_SIZE,\n\t\t\t\t  8 * PAGE_SIZE);\n\ttest_err_ioctl_ioas_unmap(ENOENT,\n\t\t\t\t  self->base_iova + 3 * 16 * PAGE_SIZE +\n\t\t\t\t\t  8 * PAGE_SIZE - 4 * PAGE_SIZE,\n\t\t\t\t  8 * PAGE_SIZE);\n\n\t \n\tASSERT_EQ(0, _test_ioctl_ioas_unmap(self->fd, self->ioas_id,\n\t\t\t\t\t    self->base_iova - 4 * PAGE_SIZE,\n\t\t\t\t\t    3 * 16 * PAGE_SIZE + 8 * PAGE_SIZE +\n\t\t\t\t\t\t    4 * PAGE_SIZE,\n\t\t\t\t\t    &unmap_len));\n\tASSERT_EQ(32 * PAGE_SIZE, unmap_len);\n}\n\nTEST_F(iommufd_ioas, area_auto_iova)\n{\n\tstruct iommu_test_cmd test_cmd = {\n\t\t.size = sizeof(test_cmd),\n\t\t.op = IOMMU_TEST_OP_ADD_RESERVED,\n\t\t.id = self->ioas_id,\n\t\t.add_reserved = { .start = PAGE_SIZE * 4,\n\t\t\t\t  .length = PAGE_SIZE * 100 },\n\t};\n\tstruct iommu_iova_range ranges[1] = {};\n\tstruct iommu_ioas_allow_iovas allow_cmd = {\n\t\t.size = sizeof(allow_cmd),\n\t\t.ioas_id = self->ioas_id,\n\t\t.num_iovas = 1,\n\t\t.allowed_iovas = (uintptr_t)ranges,\n\t};\n\t__u64 iovas[10];\n\tint i;\n\n\t \n\tfor (i = 0; i != 10; i++)\n\t\ttest_ioctl_ioas_map(buffer, PAGE_SIZE, &iovas[i]);\n\tfor (i = 0; i != 10; i++)\n\t\ttest_ioctl_ioas_unmap(iovas[i], PAGE_SIZE);\n\n\t \n\tfor (i = 0; i != 10; i++) {\n\t\tsize_t length = PAGE_SIZE * (i + 1);\n\n\t\tif (self->stdev_id) {\n\t\t\ttest_ioctl_ioas_map(buffer, length, &iovas[i]);\n\t\t} else {\n\t\t\ttest_ioctl_ioas_map((void *)(1UL << 31), length,\n\t\t\t\t\t    &iovas[i]);\n\t\t}\n\t\tEXPECT_EQ(0, iovas[i] % (1UL << (ffs(length) - 1)));\n\t}\n\tfor (i = 0; i != 10; i++)\n\t\ttest_ioctl_ioas_unmap(iovas[i], PAGE_SIZE * (i + 1));\n\n\t \n\tASSERT_EQ(0,\n\t\t  ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ADD_RESERVED),\n\t\t\t&test_cmd));\n\tfor (i = 0; i != 10; i++) {\n\t\tsize_t length = PAGE_SIZE * (i + 1);\n\n\t\ttest_ioctl_ioas_map(buffer, length, &iovas[i]);\n\t\tEXPECT_EQ(0, iovas[i] % (1UL << (ffs(length) - 1)));\n\t\tEXPECT_EQ(false,\n\t\t\t  iovas[i] > test_cmd.add_reserved.start &&\n\t\t\t\t  iovas[i] <\n\t\t\t\t\t  test_cmd.add_reserved.start +\n\t\t\t\t\t\t  test_cmd.add_reserved.length);\n\t}\n\tfor (i = 0; i != 10; i++)\n\t\ttest_ioctl_ioas_unmap(iovas[i], PAGE_SIZE * (i + 1));\n\n\t \n\tranges[0].start = PAGE_SIZE;\n\tranges[0].last = PAGE_SIZE * 600;\n\tEXPECT_ERRNO(EADDRINUSE,\n\t\t     ioctl(self->fd, IOMMU_IOAS_ALLOW_IOVAS, &allow_cmd));\n\n\t \n\tif (self->stdev_id) {\n\t\tranges[0].start = MOCK_APERTURE_START + PAGE_SIZE;\n\t\tranges[0].last = MOCK_APERTURE_START + PAGE_SIZE * 600 - 1;\n\t} else {\n\t\tranges[0].start = PAGE_SIZE * 200;\n\t\tranges[0].last = PAGE_SIZE * 600 - 1;\n\t}\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_ALLOW_IOVAS, &allow_cmd));\n\tfor (i = 0; i != 10; i++) {\n\t\tsize_t length = PAGE_SIZE * (i + 1);\n\n\t\ttest_ioctl_ioas_map(buffer, length, &iovas[i]);\n\t\tEXPECT_EQ(0, iovas[i] % (1UL << (ffs(length) - 1)));\n\t\tEXPECT_EQ(true, iovas[i] >= ranges[0].start);\n\t\tEXPECT_EQ(true, iovas[i] <= ranges[0].last);\n\t\tEXPECT_EQ(true, iovas[i] + length > ranges[0].start);\n\t\tEXPECT_EQ(true, iovas[i] + length <= ranges[0].last + 1);\n\t}\n\tfor (i = 0; i != 10; i++)\n\t\ttest_ioctl_ioas_unmap(iovas[i], PAGE_SIZE * (i + 1));\n}\n\nTEST_F(iommufd_ioas, area_allowed)\n{\n\tstruct iommu_test_cmd test_cmd = {\n\t\t.size = sizeof(test_cmd),\n\t\t.op = IOMMU_TEST_OP_ADD_RESERVED,\n\t\t.id = self->ioas_id,\n\t\t.add_reserved = { .start = PAGE_SIZE * 4,\n\t\t\t\t  .length = PAGE_SIZE * 100 },\n\t};\n\tstruct iommu_iova_range ranges[1] = {};\n\tstruct iommu_ioas_allow_iovas allow_cmd = {\n\t\t.size = sizeof(allow_cmd),\n\t\t.ioas_id = self->ioas_id,\n\t\t.num_iovas = 1,\n\t\t.allowed_iovas = (uintptr_t)ranges,\n\t};\n\n\t \n\tallow_cmd.num_iovas = 1;\n\tranges[0].start = self->base_iova;\n\tranges[0].last = ranges[0].start + PAGE_SIZE * 600;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_ALLOW_IOVAS, &allow_cmd));\n\ttest_cmd.add_reserved.start = ranges[0].start + PAGE_SIZE;\n\ttest_cmd.add_reserved.length = PAGE_SIZE;\n\tEXPECT_ERRNO(EADDRINUSE,\n\t\t     ioctl(self->fd,\n\t\t\t   _IOMMU_TEST_CMD(IOMMU_TEST_OP_ADD_RESERVED),\n\t\t\t   &test_cmd));\n\tallow_cmd.num_iovas = 0;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_ALLOW_IOVAS, &allow_cmd));\n\n\t \n\tASSERT_EQ(0,\n\t\t  ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ADD_RESERVED),\n\t\t\t&test_cmd));\n\tallow_cmd.num_iovas = 1;\n\tranges[0].start = self->base_iova;\n\tranges[0].last = ranges[0].start + PAGE_SIZE * 600;\n\tEXPECT_ERRNO(EADDRINUSE,\n\t\t     ioctl(self->fd, IOMMU_IOAS_ALLOW_IOVAS, &allow_cmd));\n}\n\nTEST_F(iommufd_ioas, copy_area)\n{\n\tstruct iommu_ioas_copy copy_cmd = {\n\t\t.size = sizeof(copy_cmd),\n\t\t.flags = IOMMU_IOAS_MAP_FIXED_IOVA,\n\t\t.dst_ioas_id = self->ioas_id,\n\t\t.src_ioas_id = self->ioas_id,\n\t\t.length = PAGE_SIZE,\n\t};\n\n\ttest_ioctl_ioas_map_fixed(buffer, PAGE_SIZE, self->base_iova);\n\n\t \n\tcopy_cmd.src_iova = self->base_iova;\n\tcopy_cmd.dst_iova = self->base_iova + PAGE_SIZE;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_COPY, &copy_cmd));\n\n\t \n\tcopy_cmd.src_iova = self->base_iova;\n\tcopy_cmd.dst_iova = 0;\n\ttest_ioctl_ioas_alloc(&copy_cmd.dst_ioas_id);\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_COPY, &copy_cmd));\n}\n\nTEST_F(iommufd_ioas, iova_ranges)\n{\n\tstruct iommu_test_cmd test_cmd = {\n\t\t.size = sizeof(test_cmd),\n\t\t.op = IOMMU_TEST_OP_ADD_RESERVED,\n\t\t.id = self->ioas_id,\n\t\t.add_reserved = { .start = PAGE_SIZE, .length = PAGE_SIZE },\n\t};\n\tstruct iommu_iova_range *ranges = buffer;\n\tstruct iommu_ioas_iova_ranges ranges_cmd = {\n\t\t.size = sizeof(ranges_cmd),\n\t\t.ioas_id = self->ioas_id,\n\t\t.num_iovas = BUFFER_SIZE / sizeof(*ranges),\n\t\t.allowed_iovas = (uintptr_t)ranges,\n\t};\n\n\t \n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_IOVA_RANGES, &ranges_cmd));\n\tEXPECT_EQ(1, ranges_cmd.num_iovas);\n\tif (!self->stdev_id) {\n\t\tEXPECT_EQ(0, ranges[0].start);\n\t\tEXPECT_EQ(SIZE_MAX, ranges[0].last);\n\t\tEXPECT_EQ(1, ranges_cmd.out_iova_alignment);\n\t} else {\n\t\tEXPECT_EQ(MOCK_APERTURE_START, ranges[0].start);\n\t\tEXPECT_EQ(MOCK_APERTURE_LAST, ranges[0].last);\n\t\tEXPECT_EQ(MOCK_PAGE_SIZE, ranges_cmd.out_iova_alignment);\n\t}\n\n\t \n\tmemset(ranges, 0, BUFFER_SIZE);\n\tranges_cmd.num_iovas = 0;\n\tEXPECT_ERRNO(EMSGSIZE,\n\t\t     ioctl(self->fd, IOMMU_IOAS_IOVA_RANGES, &ranges_cmd));\n\tEXPECT_EQ(1, ranges_cmd.num_iovas);\n\tEXPECT_EQ(0, ranges[0].start);\n\tEXPECT_EQ(0, ranges[0].last);\n\n\t \n\tASSERT_EQ(0,\n\t\t  ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ADD_RESERVED),\n\t\t\t&test_cmd));\n\tranges_cmd.num_iovas = BUFFER_SIZE / sizeof(*ranges);\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_IOVA_RANGES, &ranges_cmd));\n\tif (!self->stdev_id) {\n\t\tEXPECT_EQ(2, ranges_cmd.num_iovas);\n\t\tEXPECT_EQ(0, ranges[0].start);\n\t\tEXPECT_EQ(PAGE_SIZE - 1, ranges[0].last);\n\t\tEXPECT_EQ(PAGE_SIZE * 2, ranges[1].start);\n\t\tEXPECT_EQ(SIZE_MAX, ranges[1].last);\n\t} else {\n\t\tEXPECT_EQ(1, ranges_cmd.num_iovas);\n\t\tEXPECT_EQ(MOCK_APERTURE_START, ranges[0].start);\n\t\tEXPECT_EQ(MOCK_APERTURE_LAST, ranges[0].last);\n\t}\n\n\t \n\tmemset(ranges, 0, BUFFER_SIZE);\n\tranges_cmd.num_iovas = 1;\n\tif (!self->stdev_id) {\n\t\tEXPECT_ERRNO(EMSGSIZE, ioctl(self->fd, IOMMU_IOAS_IOVA_RANGES,\n\t\t\t\t\t     &ranges_cmd));\n\t\tEXPECT_EQ(2, ranges_cmd.num_iovas);\n\t\tEXPECT_EQ(0, ranges[0].start);\n\t\tEXPECT_EQ(PAGE_SIZE - 1, ranges[0].last);\n\t} else {\n\t\tASSERT_EQ(0,\n\t\t\t  ioctl(self->fd, IOMMU_IOAS_IOVA_RANGES, &ranges_cmd));\n\t\tEXPECT_EQ(1, ranges_cmd.num_iovas);\n\t\tEXPECT_EQ(MOCK_APERTURE_START, ranges[0].start);\n\t\tEXPECT_EQ(MOCK_APERTURE_LAST, ranges[0].last);\n\t}\n\tEXPECT_EQ(0, ranges[1].start);\n\tEXPECT_EQ(0, ranges[1].last);\n}\n\nTEST_F(iommufd_ioas, access_domain_destory)\n{\n\tstruct iommu_test_cmd access_cmd = {\n\t\t.size = sizeof(access_cmd),\n\t\t.op = IOMMU_TEST_OP_ACCESS_PAGES,\n\t\t.access_pages = { .iova = self->base_iova + PAGE_SIZE,\n\t\t\t\t  .length = PAGE_SIZE},\n\t};\n\tsize_t buf_size = 2 * HUGEPAGE_SIZE;\n\tuint8_t *buf;\n\n\tbuf = mmap(0, buf_size, PROT_READ | PROT_WRITE,\n\t\t   MAP_SHARED | MAP_ANONYMOUS | MAP_HUGETLB | MAP_POPULATE, -1,\n\t\t   0);\n\tASSERT_NE(MAP_FAILED, buf);\n\ttest_ioctl_ioas_map_fixed(buf, buf_size, self->base_iova);\n\n\ttest_cmd_create_access(self->ioas_id, &access_cmd.id,\n\t\t\t       MOCK_FLAGS_ACCESS_CREATE_NEEDS_PIN_PAGES);\n\taccess_cmd.access_pages.uptr = (uintptr_t)buf + PAGE_SIZE;\n\tASSERT_EQ(0,\n\t\t  ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_PAGES),\n\t\t\t&access_cmd));\n\n\t \n\tif (self->stdev_id)\n\t\ttest_ioctl_destroy(self->stdev_id);\n\n\ttest_cmd_destroy_access_pages(\n\t\taccess_cmd.id, access_cmd.access_pages.out_access_pages_id);\n\ttest_cmd_destroy_access(access_cmd.id);\n\tASSERT_EQ(0, munmap(buf, buf_size));\n}\n\nTEST_F(iommufd_ioas, access_pin)\n{\n\tstruct iommu_test_cmd access_cmd = {\n\t\t.size = sizeof(access_cmd),\n\t\t.op = IOMMU_TEST_OP_ACCESS_PAGES,\n\t\t.access_pages = { .iova = MOCK_APERTURE_START,\n\t\t\t\t  .length = BUFFER_SIZE,\n\t\t\t\t  .uptr = (uintptr_t)buffer },\n\t};\n\tstruct iommu_test_cmd check_map_cmd = {\n\t\t.size = sizeof(check_map_cmd),\n\t\t.op = IOMMU_TEST_OP_MD_CHECK_MAP,\n\t\t.check_map = { .iova = MOCK_APERTURE_START,\n\t\t\t       .length = BUFFER_SIZE,\n\t\t\t       .uptr = (uintptr_t)buffer },\n\t};\n\tuint32_t access_pages_id;\n\tunsigned int npages;\n\n\ttest_cmd_create_access(self->ioas_id, &access_cmd.id,\n\t\t\t       MOCK_FLAGS_ACCESS_CREATE_NEEDS_PIN_PAGES);\n\n\tfor (npages = 1; npages < BUFFER_SIZE / PAGE_SIZE; npages++) {\n\t\tuint32_t mock_stdev_id;\n\t\tuint32_t mock_hwpt_id;\n\n\t\taccess_cmd.access_pages.length = npages * PAGE_SIZE;\n\n\t\t \n\t\ttest_ioctl_ioas_map_fixed(buffer, BUFFER_SIZE,\n\t\t\t\t\t  MOCK_APERTURE_START);\n\t\tASSERT_EQ(0, ioctl(self->fd,\n\t\t\t\t   _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_PAGES),\n\t\t\t\t   &access_cmd));\n\t\ttest_cmd_destroy_access_pages(\n\t\t\taccess_cmd.id,\n\t\t\taccess_cmd.access_pages.out_access_pages_id);\n\n\t\t \n\t\tASSERT_EQ(0, ioctl(self->fd,\n\t\t\t\t   _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_PAGES),\n\t\t\t\t   &access_cmd));\n\t\taccess_pages_id = access_cmd.access_pages.out_access_pages_id;\n\t\tASSERT_EQ(0, ioctl(self->fd,\n\t\t\t\t   _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_PAGES),\n\t\t\t\t   &access_cmd));\n\t\ttest_cmd_destroy_access_pages(\n\t\t\taccess_cmd.id,\n\t\t\taccess_cmd.access_pages.out_access_pages_id);\n\t\ttest_cmd_destroy_access_pages(access_cmd.id, access_pages_id);\n\n\t\t \n\t\tASSERT_EQ(0, ioctl(self->fd,\n\t\t\t\t   _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_PAGES),\n\t\t\t\t   &access_cmd));\n\t\ttest_cmd_mock_domain(self->ioas_id, &mock_stdev_id,\n\t\t\t\t     &mock_hwpt_id, NULL);\n\t\tcheck_map_cmd.id = mock_hwpt_id;\n\t\tASSERT_EQ(0, ioctl(self->fd,\n\t\t\t\t   _IOMMU_TEST_CMD(IOMMU_TEST_OP_MD_CHECK_MAP),\n\t\t\t\t   &check_map_cmd));\n\n\t\ttest_ioctl_destroy(mock_stdev_id);\n\t\ttest_cmd_destroy_access_pages(\n\t\t\taccess_cmd.id,\n\t\t\taccess_cmd.access_pages.out_access_pages_id);\n\n\t\ttest_ioctl_ioas_unmap(MOCK_APERTURE_START, BUFFER_SIZE);\n\t}\n\ttest_cmd_destroy_access(access_cmd.id);\n}\n\nTEST_F(iommufd_ioas, access_pin_unmap)\n{\n\tstruct iommu_test_cmd access_pages_cmd = {\n\t\t.size = sizeof(access_pages_cmd),\n\t\t.op = IOMMU_TEST_OP_ACCESS_PAGES,\n\t\t.access_pages = { .iova = MOCK_APERTURE_START,\n\t\t\t\t  .length = BUFFER_SIZE,\n\t\t\t\t  .uptr = (uintptr_t)buffer },\n\t};\n\n\ttest_cmd_create_access(self->ioas_id, &access_pages_cmd.id,\n\t\t\t       MOCK_FLAGS_ACCESS_CREATE_NEEDS_PIN_PAGES);\n\ttest_ioctl_ioas_map_fixed(buffer, BUFFER_SIZE, MOCK_APERTURE_START);\n\tASSERT_EQ(0,\n\t\t  ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_PAGES),\n\t\t\t&access_pages_cmd));\n\n\t \n\ttest_ioctl_ioas_unmap(MOCK_APERTURE_START, BUFFER_SIZE);\n\n\t \n\ttest_err_destroy_access_pages(\n\t\tENOENT, access_pages_cmd.id,\n\t\taccess_pages_cmd.access_pages.out_access_pages_id);\n}\n\nstatic void check_access_rw(struct __test_metadata *_metadata, int fd,\n\t\t\t    unsigned int access_id, uint64_t iova,\n\t\t\t    unsigned int def_flags)\n{\n\tuint16_t tmp[32];\n\tstruct iommu_test_cmd access_cmd = {\n\t\t.size = sizeof(access_cmd),\n\t\t.op = IOMMU_TEST_OP_ACCESS_RW,\n\t\t.id = access_id,\n\t\t.access_rw = { .uptr = (uintptr_t)tmp },\n\t};\n\tuint16_t *buffer16 = buffer;\n\tunsigned int i;\n\tvoid *tmp2;\n\n\tfor (i = 0; i != BUFFER_SIZE / sizeof(*buffer16); i++)\n\t\tbuffer16[i] = rand();\n\n\tfor (access_cmd.access_rw.iova = iova + PAGE_SIZE - 50;\n\t     access_cmd.access_rw.iova < iova + PAGE_SIZE + 50;\n\t     access_cmd.access_rw.iova++) {\n\t\tfor (access_cmd.access_rw.length = 1;\n\t\t     access_cmd.access_rw.length < sizeof(tmp);\n\t\t     access_cmd.access_rw.length++) {\n\t\t\taccess_cmd.access_rw.flags = def_flags;\n\t\t\tASSERT_EQ(0, ioctl(fd,\n\t\t\t\t\t   _IOMMU_TEST_CMD(\n\t\t\t\t\t\t   IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t\t\t   &access_cmd));\n\t\t\tASSERT_EQ(0,\n\t\t\t\t  memcmp(buffer + (access_cmd.access_rw.iova -\n\t\t\t\t\t\t   iova),\n\t\t\t\t\t tmp, access_cmd.access_rw.length));\n\n\t\t\tfor (i = 0; i != ARRAY_SIZE(tmp); i++)\n\t\t\t\ttmp[i] = rand();\n\t\t\taccess_cmd.access_rw.flags = def_flags |\n\t\t\t\t\t\t     MOCK_ACCESS_RW_WRITE;\n\t\t\tASSERT_EQ(0, ioctl(fd,\n\t\t\t\t\t   _IOMMU_TEST_CMD(\n\t\t\t\t\t\t   IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t\t\t   &access_cmd));\n\t\t\tASSERT_EQ(0,\n\t\t\t\t  memcmp(buffer + (access_cmd.access_rw.iova -\n\t\t\t\t\t\t   iova),\n\t\t\t\t\t tmp, access_cmd.access_rw.length));\n\t\t}\n\t}\n\n\t \n\ttmp2 = malloc(BUFFER_SIZE);\n\tASSERT_NE(NULL, tmp2);\n\taccess_cmd.access_rw.iova = iova;\n\taccess_cmd.access_rw.length = BUFFER_SIZE;\n\taccess_cmd.access_rw.flags = def_flags;\n\taccess_cmd.access_rw.uptr = (uintptr_t)tmp2;\n\tASSERT_EQ(0, ioctl(fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t   &access_cmd));\n\tASSERT_EQ(0, memcmp(buffer, tmp2, access_cmd.access_rw.length));\n\tfree(tmp2);\n}\n\nTEST_F(iommufd_ioas, access_rw)\n{\n\t__u32 access_id;\n\t__u64 iova;\n\n\ttest_cmd_create_access(self->ioas_id, &access_id, 0);\n\ttest_ioctl_ioas_map(buffer, BUFFER_SIZE, &iova);\n\tcheck_access_rw(_metadata, self->fd, access_id, iova, 0);\n\tcheck_access_rw(_metadata, self->fd, access_id, iova,\n\t\t\tMOCK_ACCESS_RW_SLOW_PATH);\n\ttest_ioctl_ioas_unmap(iova, BUFFER_SIZE);\n\ttest_cmd_destroy_access(access_id);\n}\n\nTEST_F(iommufd_ioas, access_rw_unaligned)\n{\n\t__u32 access_id;\n\t__u64 iova;\n\n\ttest_cmd_create_access(self->ioas_id, &access_id, 0);\n\n\t \n\tiova = self->base_iova + MOCK_PAGE_SIZE;\n\ttest_ioctl_ioas_map_fixed(buffer, BUFFER_SIZE, iova);\n\tcheck_access_rw(_metadata, self->fd, access_id, iova, 0);\n\ttest_ioctl_ioas_unmap(iova, BUFFER_SIZE);\n\ttest_cmd_destroy_access(access_id);\n}\n\nTEST_F(iommufd_ioas, fork_gone)\n{\n\t__u32 access_id;\n\tpid_t child;\n\n\ttest_cmd_create_access(self->ioas_id, &access_id, 0);\n\n\t \n\tchild = fork();\n\tif (!child) {\n\t\ttest_ioctl_ioas_map_fixed(buffer, BUFFER_SIZE,\n\t\t\t\t\t  MOCK_APERTURE_START);\n\t\texit(0);\n\t}\n\tASSERT_NE(-1, child);\n\tASSERT_EQ(child, waitpid(child, NULL, 0));\n\n\tif (self->stdev_id) {\n\t\t \n\t\ttest_cmd_mock_domain(self->ioas_id, NULL, NULL, NULL);\n\t\tcheck_access_rw(_metadata, self->fd, access_id,\n\t\t\t\tMOCK_APERTURE_START, 0);\n\n\t} else {\n\t\t \n\t\ttest_err_mock_domain(EFAULT, self->ioas_id, NULL, NULL);\n\t}\n\n\ttest_cmd_destroy_access(access_id);\n}\n\nTEST_F(iommufd_ioas, fork_present)\n{\n\t__u32 access_id;\n\tint pipefds[2];\n\tuint64_t tmp;\n\tpid_t child;\n\tint efd;\n\n\ttest_cmd_create_access(self->ioas_id, &access_id, 0);\n\n\tASSERT_EQ(0, pipe2(pipefds, O_CLOEXEC));\n\tefd = eventfd(0, EFD_CLOEXEC);\n\tASSERT_NE(-1, efd);\n\n\t \n\tchild = fork();\n\tif (!child) {\n\t\t__u64 iova;\n\t\tuint64_t one = 1;\n\n\t\tclose(pipefds[1]);\n\t\ttest_ioctl_ioas_map_fixed(buffer, BUFFER_SIZE,\n\t\t\t\t\t  MOCK_APERTURE_START);\n\t\tif (write(efd, &one, sizeof(one)) != sizeof(one))\n\t\t\texit(100);\n\t\tif (read(pipefds[0], &iova, 1) != 1)\n\t\t\texit(100);\n\t\texit(0);\n\t}\n\tclose(pipefds[0]);\n\tASSERT_NE(-1, child);\n\tASSERT_EQ(8, read(efd, &tmp, sizeof(tmp)));\n\n\t \n\ttest_cmd_mock_domain(self->ioas_id, NULL, NULL, NULL);\n\tcheck_access_rw(_metadata, self->fd, access_id, MOCK_APERTURE_START, 0);\n\n\tASSERT_EQ(0, close(pipefds[1]));\n\tASSERT_EQ(child, waitpid(child, NULL, 0));\n\n\ttest_cmd_destroy_access(access_id);\n}\n\nTEST_F(iommufd_ioas, ioas_option_huge_pages)\n{\n\tstruct iommu_option cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.option_id = IOMMU_OPTION_HUGE_PAGES,\n\t\t.op = IOMMU_OPTION_OP_GET,\n\t\t.val64 = 3,\n\t\t.object_id = self->ioas_id,\n\t};\n\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\tASSERT_EQ(1, cmd.val64);\n\n\tcmd.op = IOMMU_OPTION_OP_SET;\n\tcmd.val64 = 0;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\n\tcmd.op = IOMMU_OPTION_OP_GET;\n\tcmd.val64 = 3;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\tASSERT_EQ(0, cmd.val64);\n\n\tcmd.op = IOMMU_OPTION_OP_SET;\n\tcmd.val64 = 2;\n\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\n\tcmd.op = IOMMU_OPTION_OP_SET;\n\tcmd.val64 = 1;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n}\n\nTEST_F(iommufd_ioas, ioas_iova_alloc)\n{\n\tunsigned int length;\n\t__u64 iova;\n\n\tfor (length = 1; length != PAGE_SIZE * 2; length++) {\n\t\tif (variant->mock_domains && (length % MOCK_PAGE_SIZE)) {\n\t\t\ttest_err_ioctl_ioas_map(EINVAL, buffer, length, &iova);\n\t\t} else {\n\t\t\ttest_ioctl_ioas_map(buffer, length, &iova);\n\t\t\ttest_ioctl_ioas_unmap(iova, length);\n\t\t}\n\t}\n}\n\nTEST_F(iommufd_ioas, ioas_align_change)\n{\n\tstruct iommu_option cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.option_id = IOMMU_OPTION_HUGE_PAGES,\n\t\t.op = IOMMU_OPTION_OP_SET,\n\t\t.object_id = self->ioas_id,\n\t\t \n\t\t.val64 = 0,\n\t};\n\n\t \n\tif (variant->mock_domains)\n\t\treturn;\n\n\t \n\ttest_ioctl_ioas_map_fixed(buffer, PAGE_SIZE, MOCK_APERTURE_START);\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\n\t \n\ttest_err_ioctl_ioas_map_fixed(EINVAL, buffer + MOCK_PAGE_SIZE,\n\t\t\t\t      PAGE_SIZE,\n\t\t\t\t      MOCK_APERTURE_START + PAGE_SIZE);\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\n\t \n\tcmd.val64 = 1;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\n\t \n\ttest_ioctl_ioas_map_fixed(buffer + MOCK_PAGE_SIZE, PAGE_SIZE,\n\t\t\t\t  MOCK_APERTURE_START + PAGE_SIZE);\n\tcmd.val64 = 0;\n\tEXPECT_ERRNO(EADDRINUSE, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\n\ttest_ioctl_ioas_unmap(MOCK_APERTURE_START + PAGE_SIZE, PAGE_SIZE);\n\ttest_ioctl_ioas_unmap(MOCK_APERTURE_START, PAGE_SIZE);\n}\n\nTEST_F(iommufd_ioas, copy_sweep)\n{\n\tstruct iommu_ioas_copy copy_cmd = {\n\t\t.size = sizeof(copy_cmd),\n\t\t.flags = IOMMU_IOAS_MAP_FIXED_IOVA,\n\t\t.src_ioas_id = self->ioas_id,\n\t\t.dst_iova = MOCK_APERTURE_START,\n\t\t.length = MOCK_PAGE_SIZE,\n\t};\n\tunsigned int dst_ioas_id;\n\tuint64_t last_iova;\n\tuint64_t iova;\n\n\ttest_ioctl_ioas_alloc(&dst_ioas_id);\n\tcopy_cmd.dst_ioas_id = dst_ioas_id;\n\n\tif (variant->mock_domains)\n\t\tlast_iova = MOCK_APERTURE_START + BUFFER_SIZE - 1;\n\telse\n\t\tlast_iova = MOCK_APERTURE_START + BUFFER_SIZE - 2;\n\n\ttest_ioctl_ioas_map_fixed(buffer, last_iova - MOCK_APERTURE_START + 1,\n\t\t\t\t  MOCK_APERTURE_START);\n\n\tfor (iova = MOCK_APERTURE_START - PAGE_SIZE; iova <= last_iova;\n\t     iova += 511) {\n\t\tcopy_cmd.src_iova = iova;\n\t\tif (iova < MOCK_APERTURE_START ||\n\t\t    iova + copy_cmd.length - 1 > last_iova) {\n\t\t\tEXPECT_ERRNO(ENOENT, ioctl(self->fd, IOMMU_IOAS_COPY,\n\t\t\t\t\t\t   &copy_cmd));\n\t\t} else {\n\t\t\tASSERT_EQ(0,\n\t\t\t\t  ioctl(self->fd, IOMMU_IOAS_COPY, &copy_cmd));\n\t\t\ttest_ioctl_ioas_unmap_id(dst_ioas_id, copy_cmd.dst_iova,\n\t\t\t\t\t\t copy_cmd.length);\n\t\t}\n\t}\n\n\ttest_ioctl_destroy(dst_ioas_id);\n}\n\nFIXTURE(iommufd_mock_domain)\n{\n\tint fd;\n\tuint32_t ioas_id;\n\tuint32_t hwpt_id;\n\tuint32_t hwpt_ids[2];\n\tuint32_t stdev_ids[2];\n\tuint32_t idev_ids[2];\n\tint mmap_flags;\n\tsize_t mmap_buf_size;\n};\n\nFIXTURE_VARIANT(iommufd_mock_domain)\n{\n\tunsigned int mock_domains;\n\tbool hugepages;\n};\n\nFIXTURE_SETUP(iommufd_mock_domain)\n{\n\tunsigned int i;\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tASSERT_NE(-1, self->fd);\n\ttest_ioctl_ioas_alloc(&self->ioas_id);\n\n\tASSERT_GE(ARRAY_SIZE(self->hwpt_ids), variant->mock_domains);\n\n\tfor (i = 0; i != variant->mock_domains; i++)\n\t\ttest_cmd_mock_domain(self->ioas_id, &self->stdev_ids[i],\n\t\t\t\t     &self->hwpt_ids[i], &self->idev_ids[i]);\n\tself->hwpt_id = self->hwpt_ids[0];\n\n\tself->mmap_flags = MAP_SHARED | MAP_ANONYMOUS;\n\tself->mmap_buf_size = PAGE_SIZE * 8;\n\tif (variant->hugepages) {\n\t\t \n\t\tself->mmap_flags |= MAP_HUGETLB | MAP_POPULATE;\n\t\tself->mmap_buf_size = HUGEPAGE_SIZE * 2;\n\t}\n}\n\nFIXTURE_TEARDOWN(iommufd_mock_domain)\n{\n\tteardown_iommufd(self->fd, _metadata);\n}\n\nFIXTURE_VARIANT_ADD(iommufd_mock_domain, one_domain)\n{\n\t.mock_domains = 1,\n\t.hugepages = false,\n};\n\nFIXTURE_VARIANT_ADD(iommufd_mock_domain, two_domains)\n{\n\t.mock_domains = 2,\n\t.hugepages = false,\n};\n\nFIXTURE_VARIANT_ADD(iommufd_mock_domain, one_domain_hugepage)\n{\n\t.mock_domains = 1,\n\t.hugepages = true,\n};\n\nFIXTURE_VARIANT_ADD(iommufd_mock_domain, two_domains_hugepage)\n{\n\t.mock_domains = 2,\n\t.hugepages = true,\n};\n\n \n#define check_mock_iova(_ptr, _iova, _length)                                \\\n\t({                                                                   \\\n\t\tstruct iommu_test_cmd check_map_cmd = {                      \\\n\t\t\t.size = sizeof(check_map_cmd),                       \\\n\t\t\t.op = IOMMU_TEST_OP_MD_CHECK_MAP,                    \\\n\t\t\t.id = self->hwpt_id,                                 \\\n\t\t\t.check_map = { .iova = _iova,                        \\\n\t\t\t\t       .length = _length,                    \\\n\t\t\t\t       .uptr = (uintptr_t)(_ptr) },          \\\n\t\t};                                                           \\\n\t\tASSERT_EQ(0,                                                 \\\n\t\t\t  ioctl(self->fd,                                    \\\n\t\t\t\t_IOMMU_TEST_CMD(IOMMU_TEST_OP_MD_CHECK_MAP), \\\n\t\t\t\t&check_map_cmd));                            \\\n\t\tif (self->hwpt_ids[1]) {                                     \\\n\t\t\tcheck_map_cmd.id = self->hwpt_ids[1];                \\\n\t\t\tASSERT_EQ(0,                                         \\\n\t\t\t\t  ioctl(self->fd,                            \\\n\t\t\t\t\t_IOMMU_TEST_CMD(                     \\\n\t\t\t\t\t\tIOMMU_TEST_OP_MD_CHECK_MAP), \\\n\t\t\t\t\t&check_map_cmd));                    \\\n\t\t}                                                            \\\n\t})\n\nTEST_F(iommufd_mock_domain, basic)\n{\n\tsize_t buf_size = self->mmap_buf_size;\n\tuint8_t *buf;\n\t__u64 iova;\n\n\t \n\ttest_ioctl_ioas_map(buffer, PAGE_SIZE, &iova);\n\tcheck_mock_iova(buffer, iova, PAGE_SIZE);\n\n\tbuf = mmap(0, buf_size, PROT_READ | PROT_WRITE, self->mmap_flags, -1,\n\t\t   0);\n\tASSERT_NE(MAP_FAILED, buf);\n\n\t \n\tASSERT_EQ(0, munmap(buf + buf_size / 2, buf_size / 2));\n\ttest_err_ioctl_ioas_map(EFAULT, buf, buf_size, &iova);\n\n\t \n\tASSERT_EQ(0, munmap(buf, buf_size / 2));\n\ttest_err_ioctl_ioas_map(EFAULT, buf, buf_size, &iova);\n}\n\nTEST_F(iommufd_mock_domain, ro_unshare)\n{\n\tuint8_t *buf;\n\t__u64 iova;\n\tint fd;\n\n\tfd = open(\"/proc/self/exe\", O_RDONLY);\n\tASSERT_NE(-1, fd);\n\n\tbuf = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\tASSERT_NE(MAP_FAILED, buf);\n\tclose(fd);\n\n\t \n\tASSERT_EQ(0,\n\t\t  _test_ioctl_ioas_map(self->fd, self->ioas_id, buf, PAGE_SIZE,\n\t\t\t\t       &iova, IOMMU_IOAS_MAP_READABLE));\n\tcheck_mock_iova(buf, iova, PAGE_SIZE);\n\tmemset(buf, 1, PAGE_SIZE);\n\tcheck_mock_iova(buf, iova, PAGE_SIZE);\n\tASSERT_EQ(0, munmap(buf, PAGE_SIZE));\n}\n\nTEST_F(iommufd_mock_domain, all_aligns)\n{\n\tsize_t test_step = variant->hugepages ? (self->mmap_buf_size / 16) :\n\t\t\t\t\t\tMOCK_PAGE_SIZE;\n\tsize_t buf_size = self->mmap_buf_size;\n\tunsigned int start;\n\tunsigned int end;\n\tuint8_t *buf;\n\n\tbuf = mmap(0, buf_size, PROT_READ | PROT_WRITE, self->mmap_flags, -1,\n\t\t   0);\n\tASSERT_NE(MAP_FAILED, buf);\n\tcheck_refs(buf, buf_size, 0);\n\n\t \n\tfor (start = 0; start < buf_size; start += test_step) {\n\t\tif (variant->hugepages)\n\t\t\tend = buf_size;\n\t\telse\n\t\t\tend = start + MOCK_PAGE_SIZE;\n\t\tfor (; end < buf_size; end += MOCK_PAGE_SIZE) {\n\t\t\tsize_t length = end - start;\n\t\t\t__u64 iova;\n\n\t\t\ttest_ioctl_ioas_map(buf + start, length, &iova);\n\t\t\tcheck_mock_iova(buf + start, iova, length);\n\t\t\tcheck_refs(buf + start / PAGE_SIZE * PAGE_SIZE,\n\t\t\t\t   end / PAGE_SIZE * PAGE_SIZE -\n\t\t\t\t\t   start / PAGE_SIZE * PAGE_SIZE,\n\t\t\t\t   1);\n\n\t\t\ttest_ioctl_ioas_unmap(iova, length);\n\t\t}\n\t}\n\tcheck_refs(buf, buf_size, 0);\n\tASSERT_EQ(0, munmap(buf, buf_size));\n}\n\nTEST_F(iommufd_mock_domain, all_aligns_copy)\n{\n\tsize_t test_step = variant->hugepages ? self->mmap_buf_size / 16 :\n\t\t\t\t\t\tMOCK_PAGE_SIZE;\n\tsize_t buf_size = self->mmap_buf_size;\n\tunsigned int start;\n\tunsigned int end;\n\tuint8_t *buf;\n\n\tbuf = mmap(0, buf_size, PROT_READ | PROT_WRITE, self->mmap_flags, -1,\n\t\t   0);\n\tASSERT_NE(MAP_FAILED, buf);\n\tcheck_refs(buf, buf_size, 0);\n\n\t \n\tfor (start = 0; start < buf_size; start += test_step) {\n\t\tif (variant->hugepages)\n\t\t\tend = buf_size;\n\t\telse\n\t\t\tend = start + MOCK_PAGE_SIZE;\n\t\tfor (; end < buf_size; end += MOCK_PAGE_SIZE) {\n\t\t\tsize_t length = end - start;\n\t\t\tunsigned int old_id;\n\t\t\tuint32_t mock_stdev_id;\n\t\t\t__u64 iova;\n\n\t\t\ttest_ioctl_ioas_map(buf + start, length, &iova);\n\n\t\t\t \n\t\t\told_id = self->hwpt_ids[1];\n\t\t\ttest_cmd_mock_domain(self->ioas_id, &mock_stdev_id,\n\t\t\t\t\t     &self->hwpt_ids[1], NULL);\n\n\t\t\tcheck_mock_iova(buf + start, iova, length);\n\t\t\tcheck_refs(buf + start / PAGE_SIZE * PAGE_SIZE,\n\t\t\t\t   end / PAGE_SIZE * PAGE_SIZE -\n\t\t\t\t\t   start / PAGE_SIZE * PAGE_SIZE,\n\t\t\t\t   1);\n\n\t\t\ttest_ioctl_destroy(mock_stdev_id);\n\t\t\tself->hwpt_ids[1] = old_id;\n\n\t\t\ttest_ioctl_ioas_unmap(iova, length);\n\t\t}\n\t}\n\tcheck_refs(buf, buf_size, 0);\n\tASSERT_EQ(0, munmap(buf, buf_size));\n}\n\nTEST_F(iommufd_mock_domain, user_copy)\n{\n\tstruct iommu_test_cmd access_cmd = {\n\t\t.size = sizeof(access_cmd),\n\t\t.op = IOMMU_TEST_OP_ACCESS_PAGES,\n\t\t.access_pages = { .length = BUFFER_SIZE,\n\t\t\t\t  .uptr = (uintptr_t)buffer },\n\t};\n\tstruct iommu_ioas_copy copy_cmd = {\n\t\t.size = sizeof(copy_cmd),\n\t\t.flags = IOMMU_IOAS_MAP_FIXED_IOVA,\n\t\t.dst_ioas_id = self->ioas_id,\n\t\t.dst_iova = MOCK_APERTURE_START,\n\t\t.length = BUFFER_SIZE,\n\t};\n\tstruct iommu_ioas_unmap unmap_cmd = {\n\t\t.size = sizeof(unmap_cmd),\n\t\t.ioas_id = self->ioas_id,\n\t\t.iova = MOCK_APERTURE_START,\n\t\t.length = BUFFER_SIZE,\n\t};\n\tunsigned int new_ioas_id, ioas_id;\n\n\t \n\ttest_ioctl_ioas_alloc(&ioas_id);\n\ttest_ioctl_ioas_map_id(ioas_id, buffer, BUFFER_SIZE,\n\t\t\t       &copy_cmd.src_iova);\n\n\ttest_cmd_create_access(ioas_id, &access_cmd.id,\n\t\t\t       MOCK_FLAGS_ACCESS_CREATE_NEEDS_PIN_PAGES);\n\n\taccess_cmd.access_pages.iova = copy_cmd.src_iova;\n\tASSERT_EQ(0,\n\t\t  ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_PAGES),\n\t\t\t&access_cmd));\n\tcopy_cmd.src_ioas_id = ioas_id;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_COPY, &copy_cmd));\n\tcheck_mock_iova(buffer, MOCK_APERTURE_START, BUFFER_SIZE);\n\n\t \n\ttest_ioctl_ioas_alloc(&new_ioas_id);\n\ttest_ioctl_ioas_map_id(new_ioas_id, buffer, BUFFER_SIZE,\n\t\t\t       &copy_cmd.src_iova);\n\ttest_cmd_access_replace_ioas(access_cmd.id, new_ioas_id);\n\n\t \n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_UNMAP, &unmap_cmd));\n\ttest_ioctl_destroy(ioas_id);\n\n\t \n\taccess_cmd.access_pages.iova = copy_cmd.src_iova;\n\tASSERT_EQ(0,\n\t\t  ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_PAGES),\n\t\t\t&access_cmd));\n\tcopy_cmd.src_ioas_id = new_ioas_id;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_IOAS_COPY, &copy_cmd));\n\tcheck_mock_iova(buffer, MOCK_APERTURE_START, BUFFER_SIZE);\n\n\ttest_cmd_destroy_access_pages(\n\t\taccess_cmd.id, access_cmd.access_pages.out_access_pages_id);\n\ttest_cmd_destroy_access(access_cmd.id);\n\n\ttest_ioctl_destroy(new_ioas_id);\n}\n\nTEST_F(iommufd_mock_domain, replace)\n{\n\tuint32_t ioas_id;\n\n\ttest_ioctl_ioas_alloc(&ioas_id);\n\n\ttest_cmd_mock_domain_replace(self->stdev_ids[0], ioas_id);\n\n\t \n\tif (variant->mock_domains == 1)\n\t\ttest_err_mock_domain_replace(ENOENT, self->stdev_ids[0],\n\t\t\t\t\t     self->hwpt_ids[0]);\n\n\ttest_cmd_mock_domain_replace(self->stdev_ids[0], ioas_id);\n\tif (variant->mock_domains >= 2) {\n\t\ttest_cmd_mock_domain_replace(self->stdev_ids[0],\n\t\t\t\t\t     self->hwpt_ids[1]);\n\t\ttest_cmd_mock_domain_replace(self->stdev_ids[0],\n\t\t\t\t\t     self->hwpt_ids[1]);\n\t\ttest_cmd_mock_domain_replace(self->stdev_ids[0],\n\t\t\t\t\t     self->hwpt_ids[0]);\n\t}\n\n\ttest_cmd_mock_domain_replace(self->stdev_ids[0], self->ioas_id);\n\ttest_ioctl_destroy(ioas_id);\n}\n\nTEST_F(iommufd_mock_domain, alloc_hwpt)\n{\n\tint i;\n\n\tfor (i = 0; i != variant->mock_domains; i++) {\n\t\tuint32_t stddev_id;\n\t\tuint32_t hwpt_id;\n\n\t\ttest_cmd_hwpt_alloc(self->idev_ids[0], self->ioas_id, &hwpt_id);\n\t\ttest_cmd_mock_domain(hwpt_id, &stddev_id, NULL, NULL);\n\t\ttest_ioctl_destroy(stddev_id);\n\t\ttest_ioctl_destroy(hwpt_id);\n\t}\n}\n\n \n\nTEST_F(iommufd, simple_ioctls)\n{\n\tASSERT_EQ(VFIO_API_VERSION, ioctl(self->fd, VFIO_GET_API_VERSION));\n\tASSERT_EQ(1, ioctl(self->fd, VFIO_CHECK_EXTENSION, VFIO_TYPE1v2_IOMMU));\n}\n\nTEST_F(iommufd, unmap_cmd)\n{\n\tstruct vfio_iommu_type1_dma_unmap unmap_cmd = {\n\t\t.iova = MOCK_APERTURE_START,\n\t\t.size = PAGE_SIZE,\n\t};\n\n\tunmap_cmd.argsz = 1;\n\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, VFIO_IOMMU_UNMAP_DMA, &unmap_cmd));\n\n\tunmap_cmd.argsz = sizeof(unmap_cmd);\n\tunmap_cmd.flags = 1 << 31;\n\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, VFIO_IOMMU_UNMAP_DMA, &unmap_cmd));\n\n\tunmap_cmd.flags = 0;\n\tEXPECT_ERRNO(ENODEV, ioctl(self->fd, VFIO_IOMMU_UNMAP_DMA, &unmap_cmd));\n}\n\nTEST_F(iommufd, map_cmd)\n{\n\tstruct vfio_iommu_type1_dma_map map_cmd = {\n\t\t.iova = MOCK_APERTURE_START,\n\t\t.size = PAGE_SIZE,\n\t\t.vaddr = (__u64)buffer,\n\t};\n\n\tmap_cmd.argsz = 1;\n\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, VFIO_IOMMU_MAP_DMA, &map_cmd));\n\n\tmap_cmd.argsz = sizeof(map_cmd);\n\tmap_cmd.flags = 1 << 31;\n\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, VFIO_IOMMU_MAP_DMA, &map_cmd));\n\n\t \n\tmap_cmd.flags = VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE;\n\tEXPECT_ERRNO(ENODEV, ioctl(self->fd, VFIO_IOMMU_MAP_DMA, &map_cmd));\n}\n\nTEST_F(iommufd, info_cmd)\n{\n\tstruct vfio_iommu_type1_info info_cmd = {};\n\n\t \n\tinfo_cmd.argsz = 1;\n\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, VFIO_IOMMU_GET_INFO, &info_cmd));\n\n\tinfo_cmd.argsz = sizeof(info_cmd);\n\tEXPECT_ERRNO(ENODEV, ioctl(self->fd, VFIO_IOMMU_GET_INFO, &info_cmd));\n}\n\nTEST_F(iommufd, set_iommu_cmd)\n{\n\t \n\tEXPECT_ERRNO(ENODEV,\n\t\t     ioctl(self->fd, VFIO_SET_IOMMU, VFIO_TYPE1v2_IOMMU));\n\tEXPECT_ERRNO(ENODEV, ioctl(self->fd, VFIO_SET_IOMMU, VFIO_TYPE1_IOMMU));\n}\n\nTEST_F(iommufd, vfio_ioas)\n{\n\tstruct iommu_vfio_ioas vfio_ioas_cmd = {\n\t\t.size = sizeof(vfio_ioas_cmd),\n\t\t.op = IOMMU_VFIO_IOAS_GET,\n\t};\n\t__u32 ioas_id;\n\n\t \n\tEXPECT_ERRNO(ENODEV, ioctl(self->fd, IOMMU_VFIO_IOAS, &vfio_ioas_cmd));\n\n\t \n\tvfio_ioas_cmd.op = IOMMU_VFIO_IOAS_SET;\n\tEXPECT_ERRNO(ENOENT, ioctl(self->fd, IOMMU_VFIO_IOAS, &vfio_ioas_cmd));\n\n\t \n\ttest_ioctl_ioas_alloc(&ioas_id);\n\tvfio_ioas_cmd.ioas_id = ioas_id;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_VFIO_IOAS, &vfio_ioas_cmd));\n\n\t \n\tvfio_ioas_cmd.op = IOMMU_VFIO_IOAS_GET;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_VFIO_IOAS, &vfio_ioas_cmd));\n\tASSERT_EQ(ioas_id, vfio_ioas_cmd.ioas_id);\n\n\t \n\tvfio_ioas_cmd.op = IOMMU_VFIO_IOAS_CLEAR;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_VFIO_IOAS, &vfio_ioas_cmd));\n\tvfio_ioas_cmd.op = IOMMU_VFIO_IOAS_GET;\n\tEXPECT_ERRNO(ENODEV, ioctl(self->fd, IOMMU_VFIO_IOAS, &vfio_ioas_cmd));\n}\n\nFIXTURE(vfio_compat_mock_domain)\n{\n\tint fd;\n\tuint32_t ioas_id;\n};\n\nFIXTURE_VARIANT(vfio_compat_mock_domain)\n{\n\tunsigned int version;\n};\n\nFIXTURE_SETUP(vfio_compat_mock_domain)\n{\n\tstruct iommu_vfio_ioas vfio_ioas_cmd = {\n\t\t.size = sizeof(vfio_ioas_cmd),\n\t\t.op = IOMMU_VFIO_IOAS_SET,\n\t};\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tASSERT_NE(-1, self->fd);\n\n\t \n\ttest_ioctl_ioas_alloc(&self->ioas_id);\n\ttest_cmd_mock_domain(self->ioas_id, NULL, NULL, NULL);\n\n\t \n\tvfio_ioas_cmd.ioas_id = self->ioas_id;\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_VFIO_IOAS, &vfio_ioas_cmd));\n\tASSERT_EQ(0, ioctl(self->fd, VFIO_SET_IOMMU, variant->version));\n}\n\nFIXTURE_TEARDOWN(vfio_compat_mock_domain)\n{\n\tteardown_iommufd(self->fd, _metadata);\n}\n\nFIXTURE_VARIANT_ADD(vfio_compat_mock_domain, Ver1v2)\n{\n\t.version = VFIO_TYPE1v2_IOMMU,\n};\n\nFIXTURE_VARIANT_ADD(vfio_compat_mock_domain, Ver1v0)\n{\n\t.version = VFIO_TYPE1_IOMMU,\n};\n\nTEST_F(vfio_compat_mock_domain, simple_close)\n{\n}\n\nTEST_F(vfio_compat_mock_domain, option_huge_pages)\n{\n\tstruct iommu_option cmd = {\n\t\t.size = sizeof(cmd),\n\t\t.option_id = IOMMU_OPTION_HUGE_PAGES,\n\t\t.op = IOMMU_OPTION_OP_GET,\n\t\t.val64 = 3,\n\t\t.object_id = self->ioas_id,\n\t};\n\n\tASSERT_EQ(0, ioctl(self->fd, IOMMU_OPTION, &cmd));\n\tif (variant->version == VFIO_TYPE1_IOMMU) {\n\t\tASSERT_EQ(0, cmd.val64);\n\t} else {\n\t\tASSERT_EQ(1, cmd.val64);\n\t}\n}\n\n \nstatic bool is_filled(const void *buf, uint8_t c, size_t len)\n{\n\tconst uint8_t *cbuf = buf;\n\n\tfor (; len; cbuf++, len--)\n\t\tif (*cbuf != c)\n\t\t\treturn false;\n\treturn true;\n}\n\n#define ioctl_check_buf(fd, cmd)                                         \\\n\t({                                                               \\\n\t\tsize_t _cmd_len = *(__u32 *)buffer;                      \\\n\t\t\t\t\t\t\t\t\t \\\n\t\tmemset(buffer + _cmd_len, 0xAA, BUFFER_SIZE - _cmd_len); \\\n\t\tASSERT_EQ(0, ioctl(fd, cmd, buffer));                    \\\n\t\tASSERT_EQ(true, is_filled(buffer + _cmd_len, 0xAA,       \\\n\t\t\t\t\t  BUFFER_SIZE - _cmd_len));      \\\n\t})\n\nstatic void check_vfio_info_cap_chain(struct __test_metadata *_metadata,\n\t\t\t\t      struct vfio_iommu_type1_info *info_cmd)\n{\n\tconst struct vfio_info_cap_header *cap;\n\n\tASSERT_GE(info_cmd->argsz, info_cmd->cap_offset + sizeof(*cap));\n\tcap = buffer + info_cmd->cap_offset;\n\twhile (true) {\n\t\tsize_t cap_size;\n\n\t\tif (cap->next)\n\t\t\tcap_size = (buffer + cap->next) - (void *)cap;\n\t\telse\n\t\t\tcap_size = (buffer + info_cmd->argsz) - (void *)cap;\n\n\t\tswitch (cap->id) {\n\t\tcase VFIO_IOMMU_TYPE1_INFO_CAP_IOVA_RANGE: {\n\t\t\tstruct vfio_iommu_type1_info_cap_iova_range *data =\n\t\t\t\t(void *)cap;\n\n\t\t\tASSERT_EQ(1, data->header.version);\n\t\t\tASSERT_EQ(1, data->nr_iovas);\n\t\t\tEXPECT_EQ(MOCK_APERTURE_START,\n\t\t\t\t  data->iova_ranges[0].start);\n\t\t\tEXPECT_EQ(MOCK_APERTURE_LAST, data->iova_ranges[0].end);\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_IOMMU_TYPE1_INFO_DMA_AVAIL: {\n\t\t\tstruct vfio_iommu_type1_info_dma_avail *data =\n\t\t\t\t(void *)cap;\n\n\t\t\tASSERT_EQ(1, data->header.version);\n\t\t\tASSERT_EQ(sizeof(*data), cap_size);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tASSERT_EQ(false, true);\n\t\t\tbreak;\n\t\t}\n\t\tif (!cap->next)\n\t\t\tbreak;\n\n\t\tASSERT_GE(info_cmd->argsz, cap->next + sizeof(*cap));\n\t\tASSERT_GE(buffer + cap->next, (void *)cap);\n\t\tcap = buffer + cap->next;\n\t}\n}\n\nTEST_F(vfio_compat_mock_domain, get_info)\n{\n\tstruct vfio_iommu_type1_info *info_cmd = buffer;\n\tunsigned int i;\n\tsize_t caplen;\n\n\t \n\t*info_cmd = (struct vfio_iommu_type1_info){\n\t\t.argsz = offsetof(struct vfio_iommu_type1_info, cap_offset),\n\t};\n\tioctl_check_buf(self->fd, VFIO_IOMMU_GET_INFO);\n\tASSERT_NE(0, info_cmd->iova_pgsizes);\n\tASSERT_EQ(VFIO_IOMMU_INFO_PGSIZES | VFIO_IOMMU_INFO_CAPS,\n\t\t  info_cmd->flags);\n\n\t \n\t*info_cmd = (struct vfio_iommu_type1_info){\n\t\t.argsz = sizeof(*info_cmd),\n\t};\n\tioctl_check_buf(self->fd, VFIO_IOMMU_GET_INFO);\n\tASSERT_NE(0, info_cmd->iova_pgsizes);\n\tASSERT_EQ(VFIO_IOMMU_INFO_PGSIZES | VFIO_IOMMU_INFO_CAPS,\n\t\t  info_cmd->flags);\n\tASSERT_EQ(0, info_cmd->cap_offset);\n\tASSERT_LT(sizeof(*info_cmd), info_cmd->argsz);\n\n\t \n\tcaplen = info_cmd->argsz;\n\tfor (i = sizeof(*info_cmd); i < caplen; i++) {\n\t\t*info_cmd = (struct vfio_iommu_type1_info){\n\t\t\t.argsz = i,\n\t\t};\n\t\tioctl_check_buf(self->fd, VFIO_IOMMU_GET_INFO);\n\t\tASSERT_EQ(VFIO_IOMMU_INFO_PGSIZES | VFIO_IOMMU_INFO_CAPS,\n\t\t\t  info_cmd->flags);\n\t\tif (!info_cmd->cap_offset)\n\t\t\tcontinue;\n\t\tcheck_vfio_info_cap_chain(_metadata, info_cmd);\n\t}\n}\n\nstatic void shuffle_array(unsigned long *array, size_t nelms)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i != nelms; i++) {\n\t\tunsigned long tmp = array[i];\n\t\tunsigned int other = rand() % (nelms - i);\n\n\t\tarray[i] = array[other];\n\t\tarray[other] = tmp;\n\t}\n}\n\nTEST_F(vfio_compat_mock_domain, map)\n{\n\tstruct vfio_iommu_type1_dma_map map_cmd = {\n\t\t.argsz = sizeof(map_cmd),\n\t\t.flags = VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE,\n\t\t.vaddr = (uintptr_t)buffer,\n\t\t.size = BUFFER_SIZE,\n\t\t.iova = MOCK_APERTURE_START,\n\t};\n\tstruct vfio_iommu_type1_dma_unmap unmap_cmd = {\n\t\t.argsz = sizeof(unmap_cmd),\n\t\t.size = BUFFER_SIZE,\n\t\t.iova = MOCK_APERTURE_START,\n\t};\n\tunsigned long pages_iova[BUFFER_SIZE / PAGE_SIZE];\n\tunsigned int i;\n\n\t \n\tASSERT_EQ(0, ioctl(self->fd, VFIO_IOMMU_MAP_DMA, &map_cmd));\n\tASSERT_EQ(0, ioctl(self->fd, VFIO_IOMMU_UNMAP_DMA, &unmap_cmd));\n\tASSERT_EQ(BUFFER_SIZE, unmap_cmd.size);\n\n\t \n\tASSERT_EQ(0, ioctl(self->fd, VFIO_IOMMU_MAP_DMA, &map_cmd));\n\tunmap_cmd.flags = VFIO_DMA_UNMAP_FLAG_ALL;\n\tEXPECT_ERRNO(EINVAL, ioctl(self->fd, VFIO_IOMMU_UNMAP_DMA, &unmap_cmd));\n\n\tunmap_cmd.iova = 0;\n\tunmap_cmd.size = 0;\n\tASSERT_EQ(0, ioctl(self->fd, VFIO_IOMMU_UNMAP_DMA, &unmap_cmd));\n\tASSERT_EQ(BUFFER_SIZE, unmap_cmd.size);\n\n\t \n\tfor (i = 0; i != ARRAY_SIZE(pages_iova); i++) {\n\t\tmap_cmd.iova = pages_iova[i] =\n\t\t\tMOCK_APERTURE_START + i * PAGE_SIZE;\n\t\tmap_cmd.vaddr = (uintptr_t)buffer + i * PAGE_SIZE;\n\t\tmap_cmd.size = PAGE_SIZE;\n\t\tASSERT_EQ(0, ioctl(self->fd, VFIO_IOMMU_MAP_DMA, &map_cmd));\n\t}\n\tshuffle_array(pages_iova, ARRAY_SIZE(pages_iova));\n\n\tunmap_cmd.flags = 0;\n\tunmap_cmd.size = PAGE_SIZE;\n\tfor (i = 0; i != ARRAY_SIZE(pages_iova); i++) {\n\t\tunmap_cmd.iova = pages_iova[i];\n\t\tASSERT_EQ(0, ioctl(self->fd, VFIO_IOMMU_UNMAP_DMA, &unmap_cmd));\n\t}\n}\n\nTEST_F(vfio_compat_mock_domain, huge_map)\n{\n\tsize_t buf_size = HUGEPAGE_SIZE * 2;\n\tstruct vfio_iommu_type1_dma_map map_cmd = {\n\t\t.argsz = sizeof(map_cmd),\n\t\t.flags = VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE,\n\t\t.size = buf_size,\n\t\t.iova = MOCK_APERTURE_START,\n\t};\n\tstruct vfio_iommu_type1_dma_unmap unmap_cmd = {\n\t\t.argsz = sizeof(unmap_cmd),\n\t};\n\tunsigned long pages_iova[16];\n\tunsigned int i;\n\tvoid *buf;\n\n\t \n\tbuf = mmap(0, buf_size, PROT_READ | PROT_WRITE,\n\t\t   MAP_SHARED | MAP_ANONYMOUS | MAP_HUGETLB | MAP_POPULATE, -1,\n\t\t   0);\n\tASSERT_NE(MAP_FAILED, buf);\n\tmap_cmd.vaddr = (uintptr_t)buf;\n\tASSERT_EQ(0, ioctl(self->fd, VFIO_IOMMU_MAP_DMA, &map_cmd));\n\n\tunmap_cmd.size = buf_size / ARRAY_SIZE(pages_iova);\n\tfor (i = 0; i != ARRAY_SIZE(pages_iova); i++)\n\t\tpages_iova[i] = MOCK_APERTURE_START + (i * unmap_cmd.size);\n\tshuffle_array(pages_iova, ARRAY_SIZE(pages_iova));\n\n\t \n\tfor (i = 0; i != ARRAY_SIZE(pages_iova); i++) {\n\t\tunmap_cmd.iova = pages_iova[i];\n\t\tunmap_cmd.size = buf_size / ARRAY_SIZE(pages_iova);\n\t\tif (variant->version == VFIO_TYPE1_IOMMU) {\n\t\t\tASSERT_EQ(0, ioctl(self->fd, VFIO_IOMMU_UNMAP_DMA,\n\t\t\t\t\t   &unmap_cmd));\n\t\t} else {\n\t\t\tEXPECT_ERRNO(ENOENT,\n\t\t\t\t     ioctl(self->fd, VFIO_IOMMU_UNMAP_DMA,\n\t\t\t\t\t   &unmap_cmd));\n\t\t}\n\t}\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}