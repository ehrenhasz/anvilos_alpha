{
  "module_name": "iommufd_fail_nth.c",
  "hash_id": "6f0ea2400c5f532f9edd9c0f5e35b9e724fd3368d651d518e6a250b7ca1b80fd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/iommu/iommufd_fail_nth.c",
  "human_readable_source": "\n \n#include <fcntl.h>\n#include <dirent.h>\n\n#define __EXPORTED_HEADERS__\n#include <linux/vfio.h>\n\n#include \"iommufd_utils.h\"\n\nstatic bool have_fault_injection;\n\nstatic int writeat(int dfd, const char *fn, const char *val)\n{\n\tsize_t val_len = strlen(val);\n\tssize_t res;\n\tint fd;\n\n\tfd = openat(dfd, fn, O_WRONLY);\n\tif (fd == -1)\n\t\treturn -1;\n\tres = write(fd, val, val_len);\n\tassert(res == val_len);\n\tclose(fd);\n\treturn 0;\n}\n\nstatic __attribute__((constructor)) void setup_buffer(void)\n{\n\tPAGE_SIZE = sysconf(_SC_PAGE_SIZE);\n\n\tBUFFER_SIZE = 2*1024*1024;\n\n\tbuffer = mmap(0, BUFFER_SIZE, PROT_READ | PROT_WRITE,\n\t\t      MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n}\n\n \nstatic __attribute__((constructor)) void setup_fault_injection(void)\n{\n\tDIR *debugfs = opendir(\"/sys/kernel/debug/\");\n\tstruct dirent *dent;\n\n\tif (!debugfs)\n\t\treturn;\n\n\t \n\tif (writeat(dirfd(debugfs), \"failslab/ignore-gfp-wait\", \"N\"))\n\t\treturn;\n\twriteat(dirfd(debugfs), \"fail_page_alloc/ignore-gfp-wait\", \"N\");\n\twriteat(dirfd(debugfs), \"fail_page_alloc/ignore-gfp-highmem\", \"N\");\n\n\twhile ((dent = readdir(debugfs))) {\n\t\tchar fn[300];\n\n\t\tif (strncmp(dent->d_name, \"fail\", 4) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tsnprintf(fn, sizeof(fn), \"%s/verbose\", dent->d_name);\n\t\twriteat(dirfd(debugfs), fn, \"0\");\n\t}\n\tclosedir(debugfs);\n\thave_fault_injection = true;\n}\n\nstruct fail_nth_state {\n\tint proc_fd;\n\tunsigned int iteration;\n};\n\nstatic void fail_nth_first(struct __test_metadata *_metadata,\n\t\t\t   struct fail_nth_state *nth_state)\n{\n\tchar buf[300];\n\n\tsnprintf(buf, sizeof(buf), \"/proc/self/task/%u/fail-nth\", getpid());\n\tnth_state->proc_fd = open(buf, O_RDWR);\n\tASSERT_NE(-1, nth_state->proc_fd);\n}\n\nstatic bool fail_nth_next(struct __test_metadata *_metadata,\n\t\t\t  struct fail_nth_state *nth_state,\n\t\t\t  int test_result)\n{\n\tstatic const char disable_nth[] = \"0\";\n\tchar buf[300];\n\n\t \n\tASSERT_GT(400, nth_state->iteration);\n\tif (nth_state->iteration != 0) {\n\t\tssize_t res;\n\t\tssize_t res2;\n\n\t\tbuf[0] = 0;\n\t\t \n\t\tres = pread(nth_state->proc_fd, buf, sizeof(buf), 0);\n\t\tif (res == -1 && errno == EFAULT) {\n\t\t\tbuf[0] = '1';\n\t\t\tbuf[1] = '\\n';\n\t\t\tres = 2;\n\t\t}\n\n\t\tres2 = pwrite(nth_state->proc_fd, disable_nth,\n\t\t\t      ARRAY_SIZE(disable_nth) - 1, 0);\n\t\tif (res2 == -1 && errno == EFAULT) {\n\t\t\tres2 = pwrite(nth_state->proc_fd, disable_nth,\n\t\t\t\t      ARRAY_SIZE(disable_nth) - 1, 0);\n\t\t\tbuf[0] = '1';\n\t\t\tbuf[1] = '\\n';\n\t\t}\n\t\tASSERT_EQ(ARRAY_SIZE(disable_nth) - 1, res2);\n\n\t\t \n\t\tfflush(stdout);\n\t\tASSERT_LT(1, res);\n\t\tif (res != 2 || buf[0] != '0' || buf[1] != '\\n')\n\t\t\treturn false;\n\t} else {\n\t\t \n\t}\n\tnth_state->iteration++;\n\treturn true;\n}\n\n \nvoid __fail_nth_enable(struct __test_metadata *_metadata,\n\t\t       struct fail_nth_state *nth_state)\n{\n\tchar buf[300];\n\tsize_t len;\n\n\tif (!nth_state->iteration)\n\t\treturn;\n\n\tlen = snprintf(buf, sizeof(buf), \"%u\", nth_state->iteration);\n\tASSERT_EQ(len, pwrite(nth_state->proc_fd, buf, len, 0));\n}\n#define fail_nth_enable() __fail_nth_enable(_metadata, _nth_state)\n\n#define TEST_FAIL_NTH(fixture_name, name)                                           \\\n\tstatic int test_nth_##name(struct __test_metadata *_metadata,               \\\n\t\t\t\t   FIXTURE_DATA(fixture_name) *self,                \\\n\t\t\t\t   const FIXTURE_VARIANT(fixture_name)              \\\n\t\t\t\t\t   *variant,                                \\\n\t\t\t\t   struct fail_nth_state *_nth_state);              \\\n\tTEST_F(fixture_name, name)                                                  \\\n\t{                                                                           \\\n\t\tstruct fail_nth_state nth_state = {};                               \\\n\t\tint test_result = 0;                                                \\\n\t\t\t\t\t\t\t\t\t\t    \\\n\t\tif (!have_fault_injection)                                          \\\n\t\t\tSKIP(return,                                                \\\n\t\t\t\t   \"fault injection is not enabled in the kernel\"); \\\n\t\tfail_nth_first(_metadata, &nth_state);                              \\\n\t\tASSERT_EQ(0, test_nth_##name(_metadata, self, variant,              \\\n\t\t\t\t\t     &nth_state));                          \\\n\t\twhile (fail_nth_next(_metadata, &nth_state, test_result)) {         \\\n\t\t\tfixture_name##_teardown(_metadata, self, variant);          \\\n\t\t\tfixture_name##_setup(_metadata, self, variant);             \\\n\t\t\ttest_result = test_nth_##name(_metadata, self,              \\\n\t\t\t\t\t\t      variant, &nth_state);         \\\n\t\t};                                                                  \\\n\t\tASSERT_EQ(0, test_result);                                          \\\n\t}                                                                           \\\n\tstatic int test_nth_##name(                                                 \\\n\t\tstruct __test_metadata __attribute__((unused)) *_metadata,          \\\n\t\tFIXTURE_DATA(fixture_name) __attribute__((unused)) *self,           \\\n\t\tconst FIXTURE_VARIANT(fixture_name) __attribute__((unused))         \\\n\t\t\t*variant,                                                   \\\n\t\tstruct fail_nth_state *_nth_state)\n\nFIXTURE(basic_fail_nth)\n{\n\tint fd;\n\tuint32_t access_id;\n};\n\nFIXTURE_SETUP(basic_fail_nth)\n{\n\tself->fd = -1;\n\tself->access_id = 0;\n}\n\nFIXTURE_TEARDOWN(basic_fail_nth)\n{\n\tint rc;\n\n\tif (self->access_id) {\n\t\t \n\t\trc = _test_cmd_destroy_access(self->access_id);\n\t\tassert(rc == 0);\n\t}\n\tteardown_iommufd(self->fd, _metadata);\n}\n\n \nTEST_FAIL_NTH(basic_fail_nth, basic)\n{\n\tstruct iommu_iova_range ranges[10];\n\tuint32_t ioas_id;\n\t__u64 iova;\n\n\tfail_nth_enable();\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tif (self->fd == -1)\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_alloc(self->fd, &ioas_id))\n\t\treturn -1;\n\n\t{\n\t\tstruct iommu_ioas_iova_ranges ranges_cmd = {\n\t\t\t.size = sizeof(ranges_cmd),\n\t\t\t.num_iovas = ARRAY_SIZE(ranges),\n\t\t\t.ioas_id = ioas_id,\n\t\t\t.allowed_iovas = (uintptr_t)ranges,\n\t\t};\n\t\tif (ioctl(self->fd, IOMMU_IOAS_IOVA_RANGES, &ranges_cmd))\n\t\t\treturn -1;\n\t}\n\n\t{\n\t\tstruct iommu_ioas_allow_iovas allow_cmd = {\n\t\t\t.size = sizeof(allow_cmd),\n\t\t\t.ioas_id = ioas_id,\n\t\t\t.num_iovas = 1,\n\t\t\t.allowed_iovas = (uintptr_t)ranges,\n\t\t};\n\n\t\tranges[0].start = 16*1024;\n\t\tranges[0].last = BUFFER_SIZE + 16 * 1024 * 600 - 1;\n\t\tif (ioctl(self->fd, IOMMU_IOAS_ALLOW_IOVAS, &allow_cmd))\n\t\t\treturn -1;\n\t}\n\n\tif (_test_ioctl_ioas_map(self->fd, ioas_id, buffer, BUFFER_SIZE, &iova,\n\t\t\t\t IOMMU_IOAS_MAP_WRITEABLE |\n\t\t\t\t\t IOMMU_IOAS_MAP_READABLE))\n\t\treturn -1;\n\n\t{\n\t\tstruct iommu_ioas_copy copy_cmd = {\n\t\t\t.size = sizeof(copy_cmd),\n\t\t\t.flags = IOMMU_IOAS_MAP_WRITEABLE |\n\t\t\t\t IOMMU_IOAS_MAP_READABLE,\n\t\t\t.dst_ioas_id = ioas_id,\n\t\t\t.src_ioas_id = ioas_id,\n\t\t\t.src_iova = iova,\n\t\t\t.length = sizeof(ranges),\n\t\t};\n\n\t\tif (ioctl(self->fd, IOMMU_IOAS_COPY, &copy_cmd))\n\t\t\treturn -1;\n\t}\n\n\tif (_test_ioctl_ioas_unmap(self->fd, ioas_id, iova, BUFFER_SIZE,\n\t\t\t\t   NULL))\n\t\treturn -1;\n\t \n\t_test_ioctl_ioas_unmap(self->fd, ioas_id, iova, BUFFER_SIZE, NULL);\n\treturn 0;\n}\n\n \nTEST_FAIL_NTH(basic_fail_nth, map_domain)\n{\n\tuint32_t ioas_id;\n\t__u32 stdev_id;\n\t__u32 hwpt_id;\n\t__u64 iova;\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tif (self->fd == -1)\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_alloc(self->fd, &ioas_id))\n\t\treturn -1;\n\n\tif (_test_ioctl_set_temp_memory_limit(self->fd, 32))\n\t\treturn -1;\n\n\tfail_nth_enable();\n\n\tif (_test_cmd_mock_domain(self->fd, ioas_id, &stdev_id, &hwpt_id, NULL))\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_map(self->fd, ioas_id, buffer, 262144, &iova,\n\t\t\t\t IOMMU_IOAS_MAP_WRITEABLE |\n\t\t\t\t\t IOMMU_IOAS_MAP_READABLE))\n\t\treturn -1;\n\n\tif (_test_ioctl_destroy(self->fd, stdev_id))\n\t\treturn -1;\n\n\tif (_test_cmd_mock_domain(self->fd, ioas_id, &stdev_id, &hwpt_id, NULL))\n\t\treturn -1;\n\treturn 0;\n}\n\nTEST_FAIL_NTH(basic_fail_nth, map_two_domains)\n{\n\tuint32_t ioas_id;\n\t__u32 stdev_id2;\n\t__u32 stdev_id;\n\t__u32 hwpt_id2;\n\t__u32 hwpt_id;\n\t__u64 iova;\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tif (self->fd == -1)\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_alloc(self->fd, &ioas_id))\n\t\treturn -1;\n\n\tif (_test_ioctl_set_temp_memory_limit(self->fd, 32))\n\t\treturn -1;\n\n\tif (_test_cmd_mock_domain(self->fd, ioas_id, &stdev_id, &hwpt_id, NULL))\n\t\treturn -1;\n\n\tfail_nth_enable();\n\n\tif (_test_cmd_mock_domain(self->fd, ioas_id, &stdev_id2, &hwpt_id2,\n\t\t\t\t  NULL))\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_map(self->fd, ioas_id, buffer, 262144, &iova,\n\t\t\t\t IOMMU_IOAS_MAP_WRITEABLE |\n\t\t\t\t\t IOMMU_IOAS_MAP_READABLE))\n\t\treturn -1;\n\n\tif (_test_ioctl_destroy(self->fd, stdev_id))\n\t\treturn -1;\n\n\tif (_test_ioctl_destroy(self->fd, stdev_id2))\n\t\treturn -1;\n\n\tif (_test_cmd_mock_domain(self->fd, ioas_id, &stdev_id, &hwpt_id, NULL))\n\t\treturn -1;\n\tif (_test_cmd_mock_domain(self->fd, ioas_id, &stdev_id2, &hwpt_id2,\n\t\t\t\t  NULL))\n\t\treturn -1;\n\treturn 0;\n}\n\nTEST_FAIL_NTH(basic_fail_nth, access_rw)\n{\n\tuint64_t tmp_big[4096];\n\tuint32_t ioas_id;\n\tuint16_t tmp[32];\n\t__u64 iova;\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tif (self->fd == -1)\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_alloc(self->fd, &ioas_id))\n\t\treturn -1;\n\n\tif (_test_ioctl_set_temp_memory_limit(self->fd, 32))\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_map(self->fd, ioas_id, buffer, 262144, &iova,\n\t\t\t\t IOMMU_IOAS_MAP_WRITEABLE |\n\t\t\t\t\t IOMMU_IOAS_MAP_READABLE))\n\t\treturn -1;\n\n\tfail_nth_enable();\n\n\tif (_test_cmd_create_access(self->fd, ioas_id, &self->access_id, 0))\n\t\treturn -1;\n\n\t{\n\t\tstruct iommu_test_cmd access_cmd = {\n\t\t\t.size = sizeof(access_cmd),\n\t\t\t.op = IOMMU_TEST_OP_ACCESS_RW,\n\t\t\t.id = self->access_id,\n\t\t\t.access_rw = { .iova = iova,\n\t\t\t\t       .length = sizeof(tmp),\n\t\t\t\t       .uptr = (uintptr_t)tmp },\n\t\t};\n\n\t\t\n\t\tif (ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t  &access_cmd))\n\t\t\treturn -1;\n\n\t\taccess_cmd.access_rw.flags = MOCK_ACCESS_RW_WRITE;\n\t\tif (ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t  &access_cmd))\n\t\t\treturn -1;\n\n\t\taccess_cmd.access_rw.flags = MOCK_ACCESS_RW_SLOW_PATH;\n\t\tif (ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t  &access_cmd))\n\t\t\treturn -1;\n\t\taccess_cmd.access_rw.flags = MOCK_ACCESS_RW_SLOW_PATH |\n\t\t\t\t\t     MOCK_ACCESS_RW_WRITE;\n\t\tif (ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t  &access_cmd))\n\t\t\treturn -1;\n\t}\n\n\t{\n\t\tstruct iommu_test_cmd access_cmd = {\n\t\t\t.size = sizeof(access_cmd),\n\t\t\t.op = IOMMU_TEST_OP_ACCESS_RW,\n\t\t\t.id = self->access_id,\n\t\t\t.access_rw = { .iova = iova,\n\t\t\t\t       .flags = MOCK_ACCESS_RW_SLOW_PATH,\n\t\t\t\t       .length = sizeof(tmp_big),\n\t\t\t\t       .uptr = (uintptr_t)tmp_big },\n\t\t};\n\n\t\tif (ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t  &access_cmd))\n\t\t\treturn -1;\n\t}\n\tif (_test_cmd_destroy_access(self->access_id))\n\t\treturn -1;\n\tself->access_id = 0;\n\treturn 0;\n}\n\n \nTEST_FAIL_NTH(basic_fail_nth, access_pin)\n{\n\tuint32_t access_pages_id;\n\tuint32_t ioas_id;\n\t__u64 iova;\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tif (self->fd == -1)\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_alloc(self->fd, &ioas_id))\n\t\treturn -1;\n\n\tif (_test_ioctl_set_temp_memory_limit(self->fd, 32))\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_map(self->fd, ioas_id, buffer, BUFFER_SIZE, &iova,\n\t\t\t\t IOMMU_IOAS_MAP_WRITEABLE |\n\t\t\t\t\t IOMMU_IOAS_MAP_READABLE))\n\t\treturn -1;\n\n\tif (_test_cmd_create_access(self->fd, ioas_id, &self->access_id,\n\t\t\t\t    MOCK_FLAGS_ACCESS_CREATE_NEEDS_PIN_PAGES))\n\t\treturn -1;\n\n\tfail_nth_enable();\n\n\t{\n\t\tstruct iommu_test_cmd access_cmd = {\n\t\t\t.size = sizeof(access_cmd),\n\t\t\t.op = IOMMU_TEST_OP_ACCESS_PAGES,\n\t\t\t.id = self->access_id,\n\t\t\t.access_pages = { .iova = iova,\n\t\t\t\t\t  .length = BUFFER_SIZE,\n\t\t\t\t\t  .uptr = (uintptr_t)buffer },\n\t\t};\n\n\t\tif (ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t  &access_cmd))\n\t\t\treturn -1;\n\t\taccess_pages_id = access_cmd.access_pages.out_access_pages_id;\n\t}\n\n\tif (_test_cmd_destroy_access_pages(self->fd, self->access_id,\n\t\t\t\t\t   access_pages_id))\n\t\treturn -1;\n\n\tif (_test_cmd_destroy_access(self->access_id))\n\t\treturn -1;\n\tself->access_id = 0;\n\treturn 0;\n}\n\n \nTEST_FAIL_NTH(basic_fail_nth, access_pin_domain)\n{\n\tuint32_t access_pages_id;\n\tuint32_t ioas_id;\n\t__u32 stdev_id;\n\t__u32 hwpt_id;\n\t__u64 iova;\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tif (self->fd == -1)\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_alloc(self->fd, &ioas_id))\n\t\treturn -1;\n\n\tif (_test_ioctl_set_temp_memory_limit(self->fd, 32))\n\t\treturn -1;\n\n\tif (_test_cmd_mock_domain(self->fd, ioas_id, &stdev_id, &hwpt_id, NULL))\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_map(self->fd, ioas_id, buffer, BUFFER_SIZE, &iova,\n\t\t\t\t IOMMU_IOAS_MAP_WRITEABLE |\n\t\t\t\t\t IOMMU_IOAS_MAP_READABLE))\n\t\treturn -1;\n\n\tif (_test_cmd_create_access(self->fd, ioas_id, &self->access_id,\n\t\t\t\t    MOCK_FLAGS_ACCESS_CREATE_NEEDS_PIN_PAGES))\n\t\treturn -1;\n\n\tfail_nth_enable();\n\n\t{\n\t\tstruct iommu_test_cmd access_cmd = {\n\t\t\t.size = sizeof(access_cmd),\n\t\t\t.op = IOMMU_TEST_OP_ACCESS_PAGES,\n\t\t\t.id = self->access_id,\n\t\t\t.access_pages = { .iova = iova,\n\t\t\t\t\t  .length = BUFFER_SIZE,\n\t\t\t\t\t  .uptr = (uintptr_t)buffer },\n\t\t};\n\n\t\tif (ioctl(self->fd, _IOMMU_TEST_CMD(IOMMU_TEST_OP_ACCESS_RW),\n\t\t\t  &access_cmd))\n\t\t\treturn -1;\n\t\taccess_pages_id = access_cmd.access_pages.out_access_pages_id;\n\t}\n\n\tif (_test_cmd_destroy_access_pages(self->fd, self->access_id,\n\t\t\t\t\t   access_pages_id))\n\t\treturn -1;\n\n\tif (_test_cmd_destroy_access(self->access_id))\n\t\treturn -1;\n\tself->access_id = 0;\n\n\tif (_test_ioctl_destroy(self->fd, stdev_id))\n\t\treturn -1;\n\treturn 0;\n}\n\n \nTEST_FAIL_NTH(basic_fail_nth, device)\n{\n\tstruct iommu_test_hw_info info;\n\tuint32_t ioas_id;\n\tuint32_t ioas_id2;\n\tuint32_t stdev_id;\n\tuint32_t idev_id;\n\tuint32_t hwpt_id;\n\t__u64 iova;\n\n\tself->fd = open(\"/dev/iommu\", O_RDWR);\n\tif (self->fd == -1)\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_alloc(self->fd, &ioas_id))\n\t\treturn -1;\n\n\tif (_test_ioctl_ioas_alloc(self->fd, &ioas_id2))\n\t\treturn -1;\n\n\tiova = MOCK_APERTURE_START;\n\tif (_test_ioctl_ioas_map(self->fd, ioas_id, buffer, PAGE_SIZE, &iova,\n\t\t\t\t IOMMU_IOAS_MAP_FIXED_IOVA |\n\t\t\t\t\t IOMMU_IOAS_MAP_WRITEABLE |\n\t\t\t\t\t IOMMU_IOAS_MAP_READABLE))\n\t\treturn -1;\n\tif (_test_ioctl_ioas_map(self->fd, ioas_id2, buffer, PAGE_SIZE, &iova,\n\t\t\t\t IOMMU_IOAS_MAP_FIXED_IOVA |\n\t\t\t\t\t IOMMU_IOAS_MAP_WRITEABLE |\n\t\t\t\t\t IOMMU_IOAS_MAP_READABLE))\n\t\treturn -1;\n\n\tfail_nth_enable();\n\n\tif (_test_cmd_mock_domain(self->fd, ioas_id, &stdev_id, NULL,\n\t\t\t\t  &idev_id))\n\t\treturn -1;\n\n\tif (_test_cmd_get_hw_info(self->fd, idev_id, &info, sizeof(info)))\n\t\treturn -1;\n\n\tif (_test_cmd_hwpt_alloc(self->fd, idev_id, ioas_id, &hwpt_id))\n\t\treturn -1;\n\n\tif (_test_cmd_mock_domain_replace(self->fd, stdev_id, ioas_id2, NULL))\n\t\treturn -1;\n\n\tif (_test_cmd_mock_domain_replace(self->fd, stdev_id, hwpt_id, NULL))\n\t\treturn -1;\n\treturn 0;\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}