{
  "module_name": "kselftest_harness.h",
  "hash_id": "c92a1724307f3e89665c22d9e92853432866e4304dfb4a7496a33fb759e5009e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kselftest_harness.h",
  "human_readable_source": " \n \n\n \n\n#ifndef __KSELFTEST_HARNESS_H\n#define __KSELFTEST_HARNESS_H\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <asm/types.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <setjmp.h>\n\n#include \"kselftest.h\"\n\n#define TEST_TIMEOUT_DEFAULT 30\n\n \n#ifndef TH_LOG_STREAM\n#  define TH_LOG_STREAM stderr\n#endif\n\n#ifndef TH_LOG_ENABLED\n#  define TH_LOG_ENABLED 1\n#endif\n\n \n#define TH_LOG(fmt, ...) do { \\\n\tif (TH_LOG_ENABLED) \\\n\t\t__TH_LOG(fmt, ##__VA_ARGS__); \\\n} while (0)\n\n \n#define __TH_LOG(fmt, ...) \\\n\t\tfprintf(TH_LOG_STREAM, \"# %s:%d:%s:\" fmt \"\\n\", \\\n\t\t\t__FILE__, __LINE__, _metadata->name, ##__VA_ARGS__)\n\n \n#define SKIP(statement, fmt, ...) do { \\\n\tsnprintf(_metadata->results->reason, \\\n\t\t sizeof(_metadata->results->reason), fmt, ##__VA_ARGS__); \\\n\tif (TH_LOG_ENABLED) { \\\n\t\tfprintf(TH_LOG_STREAM, \"#      SKIP      %s\\n\", \\\n\t\t\t_metadata->results->reason); \\\n\t} \\\n\t_metadata->passed = 1; \\\n\t_metadata->skip = 1; \\\n\t_metadata->trigger = 0; \\\n\tstatement; \\\n} while (0)\n\n \n#define TEST(test_name) __TEST_IMPL(test_name, -1)\n\n \n#define TEST_SIGNAL(test_name, signal) __TEST_IMPL(test_name, signal)\n\n#define __TEST_IMPL(test_name, _signal) \\\n\tstatic void test_name(struct __test_metadata *_metadata); \\\n\tstatic inline void wrapper_##test_name( \\\n\t\tstruct __test_metadata *_metadata, \\\n\t\tstruct __fixture_variant_metadata *variant) \\\n\t{ \\\n\t\t_metadata->setup_completed = true; \\\n\t\tif (setjmp(_metadata->env) == 0) \\\n\t\t\ttest_name(_metadata); \\\n\t\t__test_check_assert(_metadata); \\\n\t} \\\n\tstatic struct __test_metadata _##test_name##_object = \\\n\t\t{ .name = #test_name, \\\n\t\t  .fn = &wrapper_##test_name, \\\n\t\t  .fixture = &_fixture_global, \\\n\t\t  .termsig = _signal, \\\n\t\t  .timeout = TEST_TIMEOUT_DEFAULT, }; \\\n\tstatic void __attribute__((constructor)) _register_##test_name(void) \\\n\t{ \\\n\t\t__register_test(&_##test_name##_object); \\\n\t} \\\n\tstatic void test_name( \\\n\t\tstruct __test_metadata __attribute__((unused)) *_metadata)\n\n \n#define FIXTURE_DATA(datatype_name) struct _test_data_##datatype_name\n\n \n#define FIXTURE(fixture_name) \\\n\tFIXTURE_VARIANT(fixture_name); \\\n\tstatic struct __fixture_metadata _##fixture_name##_fixture_object = \\\n\t\t{ .name =  #fixture_name, }; \\\n\tstatic void __attribute__((constructor)) \\\n\t_register_##fixture_name##_data(void) \\\n\t{ \\\n\t\t__register_fixture(&_##fixture_name##_fixture_object); \\\n\t} \\\n\tFIXTURE_DATA(fixture_name)\n\n \n#define FIXTURE_SETUP(fixture_name) \\\n\tvoid fixture_name##_setup( \\\n\t\tstruct __test_metadata __attribute__((unused)) *_metadata, \\\n\t\tFIXTURE_DATA(fixture_name) __attribute__((unused)) *self, \\\n\t\tconst FIXTURE_VARIANT(fixture_name) \\\n\t\t\t__attribute__((unused)) *variant)\n\n \n#define FIXTURE_TEARDOWN(fixture_name) \\\n\tvoid fixture_name##_teardown( \\\n\t\tstruct __test_metadata __attribute__((unused)) *_metadata, \\\n\t\tFIXTURE_DATA(fixture_name) __attribute__((unused)) *self, \\\n\t\tconst FIXTURE_VARIANT(fixture_name) \\\n\t\t\t__attribute__((unused)) *variant)\n\n \n#define FIXTURE_VARIANT(fixture_name) struct _fixture_variant_##fixture_name\n\n \n#define FIXTURE_VARIANT_ADD(fixture_name, variant_name) \\\n\textern FIXTURE_VARIANT(fixture_name) \\\n\t\t_##fixture_name##_##variant_name##_variant; \\\n\tstatic struct __fixture_variant_metadata \\\n\t\t_##fixture_name##_##variant_name##_object = \\\n\t\t{ .name = #variant_name, \\\n\t\t  .data = &_##fixture_name##_##variant_name##_variant}; \\\n\tstatic void __attribute__((constructor)) \\\n\t\t_register_##fixture_name##_##variant_name(void) \\\n\t{ \\\n\t\t__register_fixture_variant(&_##fixture_name##_fixture_object, \\\n\t\t\t&_##fixture_name##_##variant_name##_object);\t\\\n\t} \\\n\tFIXTURE_VARIANT(fixture_name) \\\n\t\t_##fixture_name##_##variant_name##_variant =\n\n \n#define TEST_F(fixture_name, test_name) \\\n\t__TEST_F_IMPL(fixture_name, test_name, -1, TEST_TIMEOUT_DEFAULT)\n\n#define TEST_F_SIGNAL(fixture_name, test_name, signal) \\\n\t__TEST_F_IMPL(fixture_name, test_name, signal, TEST_TIMEOUT_DEFAULT)\n\n#define TEST_F_TIMEOUT(fixture_name, test_name, timeout) \\\n\t__TEST_F_IMPL(fixture_name, test_name, -1, timeout)\n\n#define __TEST_F_IMPL(fixture_name, test_name, signal, tmout) \\\n\tstatic void fixture_name##_##test_name( \\\n\t\tstruct __test_metadata *_metadata, \\\n\t\tFIXTURE_DATA(fixture_name) *self, \\\n\t\tconst FIXTURE_VARIANT(fixture_name) *variant); \\\n\tstatic inline void wrapper_##fixture_name##_##test_name( \\\n\t\tstruct __test_metadata *_metadata, \\\n\t\tstruct __fixture_variant_metadata *variant) \\\n\t{ \\\n\t\t  \\\n\t\tFIXTURE_DATA(fixture_name) self; \\\n\t\tmemset(&self, 0, sizeof(FIXTURE_DATA(fixture_name))); \\\n\t\tif (setjmp(_metadata->env) == 0) { \\\n\t\t\tfixture_name##_setup(_metadata, &self, variant->data); \\\n\t\t\t  \\\n                       if (!_metadata->passed || _metadata->skip) \\\n\t\t\t\treturn; \\\n\t\t\t_metadata->setup_completed = true; \\\n\t\t\tfixture_name##_##test_name(_metadata, &self, variant->data); \\\n\t\t} \\\n\t\tif (_metadata->setup_completed) \\\n\t\t\tfixture_name##_teardown(_metadata, &self, variant->data); \\\n\t\t__test_check_assert(_metadata); \\\n\t} \\\n\tstatic struct __test_metadata \\\n\t\t      _##fixture_name##_##test_name##_object = { \\\n\t\t.name = #test_name, \\\n\t\t.fn = &wrapper_##fixture_name##_##test_name, \\\n\t\t.fixture = &_##fixture_name##_fixture_object, \\\n\t\t.termsig = signal, \\\n\t\t.timeout = tmout, \\\n\t }; \\\n\tstatic void __attribute__((constructor)) \\\n\t\t\t_register_##fixture_name##_##test_name(void) \\\n\t{ \\\n\t\t__register_test(&_##fixture_name##_##test_name##_object); \\\n\t} \\\n\tstatic void fixture_name##_##test_name( \\\n\t\tstruct __test_metadata __attribute__((unused)) *_metadata, \\\n\t\tFIXTURE_DATA(fixture_name) __attribute__((unused)) *self, \\\n\t\tconst FIXTURE_VARIANT(fixture_name) \\\n\t\t\t__attribute__((unused)) *variant)\n\n \n#define TEST_HARNESS_MAIN \\\n\tstatic void __attribute__((constructor)) \\\n\t__constructor_order_last(void) \\\n\t{ \\\n\t\tif (!__constructor_order) \\\n\t\t\t__constructor_order = _CONSTRUCTOR_ORDER_BACKWARD; \\\n\t} \\\n\tint main(int argc, char **argv) { \\\n\t\treturn test_harness_run(argc, argv); \\\n\t}\n\n \n\n \n#define ASSERT_EQ(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, ==, 1)\n\n \n#define ASSERT_NE(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, !=, 1)\n\n \n#define ASSERT_LT(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, <, 1)\n\n \n#define ASSERT_LE(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, <=, 1)\n\n \n#define ASSERT_GT(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, >, 1)\n\n \n#define ASSERT_GE(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, >=, 1)\n\n \n#define ASSERT_NULL(seen) \\\n\t__EXPECT(NULL, \"NULL\", seen, #seen, ==, 1)\n\n \n#define ASSERT_TRUE(seen) \\\n\t__EXPECT(0, \"0\", seen, #seen, !=, 1)\n\n \n#define ASSERT_FALSE(seen) \\\n\t__EXPECT(0, \"0\", seen, #seen, ==, 1)\n\n \n#define ASSERT_STREQ(expected, seen) \\\n\t__EXPECT_STR(expected, seen, ==, 1)\n\n \n#define ASSERT_STRNE(expected, seen) \\\n\t__EXPECT_STR(expected, seen, !=, 1)\n\n \n#define EXPECT_EQ(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, ==, 0)\n\n \n#define EXPECT_NE(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, !=, 0)\n\n \n#define EXPECT_LT(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, <, 0)\n\n \n#define EXPECT_LE(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, <=, 0)\n\n \n#define EXPECT_GT(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, >, 0)\n\n \n#define EXPECT_GE(expected, seen) \\\n\t__EXPECT(expected, #expected, seen, #seen, >=, 0)\n\n \n#define EXPECT_NULL(seen) \\\n\t__EXPECT(NULL, \"NULL\", seen, #seen, ==, 0)\n\n \n#define EXPECT_TRUE(seen) \\\n\t__EXPECT(0, \"0\", seen, #seen, !=, 0)\n\n \n#define EXPECT_FALSE(seen) \\\n\t__EXPECT(0, \"0\", seen, #seen, ==, 0)\n\n \n#define EXPECT_STREQ(expected, seen) \\\n\t__EXPECT_STR(expected, seen, ==, 0)\n\n \n#define EXPECT_STRNE(expected, seen) \\\n\t__EXPECT_STR(expected, seen, !=, 0)\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(a)\t(sizeof(a) / sizeof(a[0]))\n#endif\n\n \n#define OPTIONAL_HANDLER(_assert) \\\n\tfor (; _metadata->trigger; _metadata->trigger = \\\n\t\t\t__bail(_assert, _metadata))\n\n#define __INC_STEP(_metadata) \\\n\t \t\\\n\tif (_metadata->passed && _metadata->step < 253) \\\n\t\t_metadata->step++;\n\n#define is_signed_type(var)       (!!(((__typeof__(var))(-1)) < (__typeof__(var))1))\n\n#define __EXPECT(_expected, _expected_str, _seen, _seen_str, _t, _assert) do { \\\n\t  \\\n\t__typeof__(_expected) __exp = (_expected); \\\n\t__typeof__(_seen) __seen = (_seen); \\\n\tif (_assert) __INC_STEP(_metadata); \\\n\tif (!(__exp _t __seen)) { \\\n\t\t  \\\n\t\tswitch (is_signed_type(__exp) * 2 + is_signed_type(__seen)) { \\\n\t\tcase 0: { \\\n\t\t\tunsigned long long __exp_print = (uintptr_t)__exp; \\\n\t\t\tunsigned long long __seen_print = (uintptr_t)__seen; \\\n\t\t\t__TH_LOG(\"Expected %s (%llu) %s %s (%llu)\", \\\n\t\t\t\t _expected_str, __exp_print, #_t, \\\n\t\t\t\t _seen_str, __seen_print); \\\n\t\t\tbreak; \\\n\t\t\t} \\\n\t\tcase 1: { \\\n\t\t\tunsigned long long __exp_print = (uintptr_t)__exp; \\\n\t\t\tlong long __seen_print = (intptr_t)__seen; \\\n\t\t\t__TH_LOG(\"Expected %s (%llu) %s %s (%lld)\", \\\n\t\t\t\t _expected_str, __exp_print, #_t, \\\n\t\t\t\t _seen_str, __seen_print); \\\n\t\t\tbreak; \\\n\t\t\t} \\\n\t\tcase 2: { \\\n\t\t\tlong long __exp_print = (intptr_t)__exp; \\\n\t\t\tunsigned long long __seen_print = (uintptr_t)__seen; \\\n\t\t\t__TH_LOG(\"Expected %s (%lld) %s %s (%llu)\", \\\n\t\t\t\t _expected_str, __exp_print, #_t, \\\n\t\t\t\t _seen_str, __seen_print); \\\n\t\t\tbreak; \\\n\t\t\t} \\\n\t\tcase 3: { \\\n\t\t\tlong long __exp_print = (intptr_t)__exp; \\\n\t\t\tlong long __seen_print = (intptr_t)__seen; \\\n\t\t\t__TH_LOG(\"Expected %s (%lld) %s %s (%lld)\", \\\n\t\t\t\t _expected_str, __exp_print, #_t, \\\n\t\t\t\t _seen_str, __seen_print); \\\n\t\t\tbreak; \\\n\t\t\t} \\\n\t\t} \\\n\t\t_metadata->passed = 0; \\\n\t\t  \\\n\t\t_metadata->trigger = 1; \\\n\t} \\\n} while (0); OPTIONAL_HANDLER(_assert)\n\n#define __EXPECT_STR(_expected, _seen, _t, _assert) do { \\\n\tconst char *__exp = (_expected); \\\n\tconst char *__seen = (_seen); \\\n\tif (_assert) __INC_STEP(_metadata); \\\n\tif (!(strcmp(__exp, __seen) _t 0))  { \\\n\t\t__TH_LOG(\"Expected '%s' %s '%s'.\", __exp, #_t, __seen); \\\n\t\t_metadata->passed = 0; \\\n\t\t_metadata->trigger = 1; \\\n\t} \\\n} while (0); OPTIONAL_HANDLER(_assert)\n\n \n#define __LIST_APPEND(head, item) \\\n{ \\\n\t  \\\n\tif (head == NULL) { \\\n\t\thead = item; \\\n\t\titem->next = NULL; \\\n\t\titem->prev = item; \\\n\t\treturn;\t\\\n\t} \\\n\tif (__constructor_order == _CONSTRUCTOR_ORDER_FORWARD) { \\\n\t\titem->next = NULL; \\\n\t\titem->prev = head->prev; \\\n\t\titem->prev->next = item; \\\n\t\thead->prev = item; \\\n\t} else { \\\n\t\titem->next = head; \\\n\t\titem->next->prev = item; \\\n\t\titem->prev = item; \\\n\t\thead = item; \\\n\t} \\\n}\n\nstruct __test_results {\n\tchar reason[1024];\t \n};\n\nstruct __test_metadata;\nstruct __fixture_variant_metadata;\n\n \nstruct __fixture_metadata {\n\tconst char *name;\n\tstruct __test_metadata *tests;\n\tstruct __fixture_variant_metadata *variant;\n\tstruct __fixture_metadata *prev, *next;\n} _fixture_global __attribute__((unused)) = {\n\t.name = \"global\",\n\t.prev = &_fixture_global,\n};\n\nstatic struct __fixture_metadata *__fixture_list = &_fixture_global;\nstatic int __constructor_order;\n\n#define _CONSTRUCTOR_ORDER_FORWARD   1\n#define _CONSTRUCTOR_ORDER_BACKWARD -1\n\nstatic inline void __register_fixture(struct __fixture_metadata *f)\n{\n\t__LIST_APPEND(__fixture_list, f);\n}\n\nstruct __fixture_variant_metadata {\n\tconst char *name;\n\tconst void *data;\n\tstruct __fixture_variant_metadata *prev, *next;\n};\n\nstatic inline void\n__register_fixture_variant(struct __fixture_metadata *f,\n\t\t\t   struct __fixture_variant_metadata *variant)\n{\n\t__LIST_APPEND(f->variant, variant);\n}\n\n \nstruct __test_metadata {\n\tconst char *name;\n\tvoid (*fn)(struct __test_metadata *,\n\t\t   struct __fixture_variant_metadata *);\n\tpid_t pid;\t \n\tstruct __fixture_metadata *fixture;\n\tint termsig;\n\tint passed;\n\tint skip;\t \n\tint trigger;  \n\tint timeout;\t \n\tbool timed_out;\t \n\t__u8 step;\n\tbool no_print;  \n\tbool aborted;\t \n\tbool setup_completed;  \n\tjmp_buf env;\t \n\tstruct __test_results *results;\n\tstruct __test_metadata *prev, *next;\n};\n\n \nstatic inline void __register_test(struct __test_metadata *t)\n{\n\t__LIST_APPEND(t->fixture->tests, t);\n}\n\nstatic inline int __bail(int for_realz, struct __test_metadata *t)\n{\n\t \n\tif (for_realz) {\n\t\tt->aborted = true;\n\t\tlongjmp(t->env, 1);\n\t}\n\t \n\treturn 0;\n}\n\nstatic inline void __test_check_assert(struct __test_metadata *t)\n{\n\tif (t->aborted) {\n\t\tif (t->no_print)\n\t\t\t_exit(t->step);\n\t\tabort();\n\t}\n}\n\nstruct __test_metadata *__active_test;\nstatic void __timeout_handler(int sig, siginfo_t *info, void *ucontext)\n{\n\tstruct __test_metadata *t = __active_test;\n\n\t \n\tif (!t) {\n\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\"# no active test in SIGALRM handler!?\\n\");\n\t\tabort();\n\t}\n\tif (sig != SIGALRM || sig != info->si_signo) {\n\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\"# %s: SIGALRM handler caught signal %d!?\\n\",\n\t\t\tt->name, sig != SIGALRM ? sig : info->si_signo);\n\t\tabort();\n\t}\n\n\tt->timed_out = true;\n\t\n\tkill(-(t->pid), SIGKILL);\n}\n\nvoid __wait_for_test(struct __test_metadata *t)\n{\n\tstruct sigaction action = {\n\t\t.sa_sigaction = __timeout_handler,\n\t\t.sa_flags = SA_SIGINFO,\n\t};\n\tstruct sigaction saved_action;\n\tint status;\n\n\tif (sigaction(SIGALRM, &action, &saved_action)) {\n\t\tt->passed = 0;\n\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\"# %s: unable to install SIGALRM handler\\n\",\n\t\t\tt->name);\n\t\treturn;\n\t}\n\t__active_test = t;\n\tt->timed_out = false;\n\talarm(t->timeout);\n\twaitpid(t->pid, &status, 0);\n\talarm(0);\n\tif (sigaction(SIGALRM, &saved_action, NULL)) {\n\t\tt->passed = 0;\n\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\"# %s: unable to uninstall SIGALRM handler\\n\",\n\t\t\tt->name);\n\t\treturn;\n\t}\n\t__active_test = NULL;\n\n\tif (t->timed_out) {\n\t\tt->passed = 0;\n\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\"# %s: Test terminated by timeout\\n\", t->name);\n\t} else if (WIFEXITED(status)) {\n\t\tif (WEXITSTATUS(status) == 255) {\n\t\t\t \n\t\t\tt->passed = 1;\n\t\t\tt->skip = 1;\n\t\t} else if (t->termsig != -1) {\n\t\t\tt->passed = 0;\n\t\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\t\"# %s: Test exited normally instead of by signal (code: %d)\\n\",\n\t\t\t\tt->name,\n\t\t\t\tWEXITSTATUS(status));\n\t\t} else {\n\t\t\tswitch (WEXITSTATUS(status)) {\n\t\t\t \n\t\t\tcase 0:\n\t\t\t\tt->passed = 1;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tdefault:\n\t\t\t\tt->passed = 0;\n\t\t\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\t\t\"# %s: Test failed at step #%d\\n\",\n\t\t\t\t\tt->name,\n\t\t\t\t\tWEXITSTATUS(status));\n\t\t\t}\n\t\t}\n\t} else if (WIFSIGNALED(status)) {\n\t\tt->passed = 0;\n\t\tif (WTERMSIG(status) == SIGABRT) {\n\t\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\t\"# %s: Test terminated by assertion\\n\",\n\t\t\t\tt->name);\n\t\t} else if (WTERMSIG(status) == t->termsig) {\n\t\t\tt->passed = 1;\n\t\t} else {\n\t\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\t\"# %s: Test terminated unexpectedly by signal %d\\n\",\n\t\t\t\tt->name,\n\t\t\t\tWTERMSIG(status));\n\t\t}\n\t} else {\n\t\tfprintf(TH_LOG_STREAM,\n\t\t\t\"# %s: Test ended in some other way [%u]\\n\",\n\t\t\tt->name,\n\t\t\tstatus);\n\t}\n}\n\nstatic void test_harness_list_tests(void)\n{\n\tstruct __fixture_variant_metadata *v;\n\tstruct __fixture_metadata *f;\n\tstruct __test_metadata *t;\n\n\tfor (f = __fixture_list; f; f = f->next) {\n\t\tv = f->variant;\n\t\tt = f->tests;\n\n\t\tif (f == __fixture_list)\n\t\t\tfprintf(stderr, \"%-20s %-25s %s\\n\",\n\t\t\t\t\"# FIXTURE\", \"VARIANT\", \"TEST\");\n\t\telse\n\t\t\tfprintf(stderr, \"--------------------------------------------------------------------------------\\n\");\n\n\t\tdo {\n\t\t\tfprintf(stderr, \"%-20s %-25s %s\\n\",\n\t\t\t\tt == f->tests ? f->name : \"\",\n\t\t\t\tv ? v->name : \"\",\n\t\t\t\tt ? t->name : \"\");\n\n\t\t\tv = v ? v->next : NULL;\n\t\t\tt = t ? t->next : NULL;\n\t\t} while (v || t);\n\t}\n}\n\nstatic int test_harness_argv_check(int argc, char **argv)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"hlF:f:V:v:t:T:r:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'f':\n\t\tcase 'F':\n\t\tcase 'v':\n\t\tcase 'V':\n\t\tcase 't':\n\t\tcase 'T':\n\t\tcase 'r':\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\ttest_harness_list_tests();\n\t\t\treturn KSFT_SKIP;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Usage: %s [-h|-l] [-t|-T|-v|-V|-f|-F|-r name]\\n\"\n\t\t\t\t\"\\t-h       print help\\n\"\n\t\t\t\t\"\\t-l       list all tests\\n\"\n\t\t\t\t\"\\n\"\n\t\t\t\t\"\\t-t name  include test\\n\"\n\t\t\t\t\"\\t-T name  exclude test\\n\"\n\t\t\t\t\"\\t-v name  include variant\\n\"\n\t\t\t\t\"\\t-V name  exclude variant\\n\"\n\t\t\t\t\"\\t-f name  include fixture\\n\"\n\t\t\t\t\"\\t-F name  exclude fixture\\n\"\n\t\t\t\t\"\\t-r name  run specified test\\n\"\n\t\t\t\t\"\\n\"\n\t\t\t\t\"Test filter options can be specified \"\n\t\t\t\t\"multiple times. The filtering stops\\n\"\n\t\t\t\t\"at the first match. For example to \"\n\t\t\t\t\"include all tests from variant 'bla'\\n\"\n\t\t\t\t\"but not test 'foo' specify '-T foo -v bla'.\\n\"\n\t\t\t\t\"\", argv[0]);\n\t\t\treturn opt == 'h' ? KSFT_SKIP : KSFT_FAIL;\n\t\t}\n\t}\n\n\treturn KSFT_PASS;\n}\n\nstatic bool test_enabled(int argc, char **argv,\n\t\t\t struct __fixture_metadata *f,\n\t\t\t struct __fixture_variant_metadata *v,\n\t\t\t struct __test_metadata *t)\n{\n\tunsigned int flen = 0, vlen = 0, tlen = 0;\n\tbool has_positive = false;\n\tint opt;\n\n\toptind = 1;\n\twhile ((opt = getopt(argc, argv, \"F:f:V:v:t:T:r:\")) != -1) {\n\t\thas_positive |= islower(opt);\n\n\t\tswitch (tolower(opt)) {\n\t\tcase 't':\n\t\t\tif (!strcmp(t->name, optarg))\n\t\t\t\treturn islower(opt);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (!strcmp(f->name, optarg))\n\t\t\t\treturn islower(opt);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (!strcmp(v->name, optarg))\n\t\t\t\treturn islower(opt);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (!tlen) {\n\t\t\t\tflen = strlen(f->name);\n\t\t\t\tvlen = strlen(v->name);\n\t\t\t\ttlen = strlen(t->name);\n\t\t\t}\n\t\t\tif (strlen(optarg) == flen + 1 + vlen + !!vlen + tlen &&\n\t\t\t    !strncmp(f->name, &optarg[0], flen) &&\n\t\t\t    !strncmp(v->name, &optarg[flen + 1], vlen) &&\n\t\t\t    !strncmp(t->name, &optarg[flen + 1 + vlen + !!vlen], tlen))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\treturn !has_positive;\n}\n\nvoid __run_test(struct __fixture_metadata *f,\n\t\tstruct __fixture_variant_metadata *variant,\n\t\tstruct __test_metadata *t)\n{\n\t \n\tt->passed = 1;\n\tt->skip = 0;\n\tt->trigger = 0;\n\tt->step = 1;\n\tt->no_print = 0;\n\tmemset(t->results->reason, 0, sizeof(t->results->reason));\n\n\tksft_print_msg(\" RUN           %s%s%s.%s ...\\n\",\n\t       f->name, variant->name[0] ? \".\" : \"\", variant->name, t->name);\n\n\t \n\tfflush(stdout);\n\tfflush(stderr);\n\n\tt->pid = fork();\n\tif (t->pid < 0) {\n\t\tksft_print_msg(\"ERROR SPAWNING TEST CHILD\\n\");\n\t\tt->passed = 0;\n\t} else if (t->pid == 0) {\n\t\tsetpgrp();\n\t\tt->fn(t, variant);\n\t\tif (t->skip)\n\t\t\t_exit(255);\n\t\t \n\t\tif (t->passed)\n\t\t\t_exit(0);\n\t\t \n\t\t_exit(t->step);\n\t} else {\n\t\t__wait_for_test(t);\n\t}\n\tksft_print_msg(\"         %4s  %s%s%s.%s\\n\", t->passed ? \"OK\" : \"FAIL\",\n\t       f->name, variant->name[0] ? \".\" : \"\", variant->name, t->name);\n\n\tif (t->skip)\n\t\tksft_test_result_skip(\"%s\\n\", t->results->reason[0] ?\n\t\t\t\t\tt->results->reason : \"unknown\");\n\telse\n\t\tksft_test_result(t->passed, \"%s%s%s.%s\\n\",\n\t\t\tf->name, variant->name[0] ? \".\" : \"\", variant->name, t->name);\n}\n\nstatic int test_harness_run(int argc, char **argv)\n{\n\tstruct __fixture_variant_metadata no_variant = { .name = \"\", };\n\tstruct __fixture_variant_metadata *v;\n\tstruct __fixture_metadata *f;\n\tstruct __test_results *results;\n\tstruct __test_metadata *t;\n\tint ret;\n\tunsigned int case_count = 0, test_count = 0;\n\tunsigned int count = 0;\n\tunsigned int pass_count = 0;\n\n\tret = test_harness_argv_check(argc, argv);\n\tif (ret != KSFT_PASS)\n\t\treturn ret;\n\n\tfor (f = __fixture_list; f; f = f->next) {\n\t\tfor (v = f->variant ?: &no_variant; v; v = v->next) {\n\t\t\tunsigned int old_tests = test_count;\n\n\t\t\tfor (t = f->tests; t; t = t->next)\n\t\t\t\tif (test_enabled(argc, argv, f, v, t))\n\t\t\t\t\ttest_count++;\n\n\t\t\tif (old_tests != test_count)\n\t\t\t\tcase_count++;\n\t\t}\n\t}\n\n\tresults = mmap(NULL, sizeof(*results), PROT_READ | PROT_WRITE,\n\t\t       MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\n\tksft_print_header();\n\tksft_set_plan(test_count);\n\tksft_print_msg(\"Starting %u tests from %u test cases.\\n\",\n\t       test_count, case_count);\n\tfor (f = __fixture_list; f; f = f->next) {\n\t\tfor (v = f->variant ?: &no_variant; v; v = v->next) {\n\t\t\tfor (t = f->tests; t; t = t->next) {\n\t\t\t\tif (!test_enabled(argc, argv, f, v, t))\n\t\t\t\t\tcontinue;\n\t\t\t\tcount++;\n\t\t\t\tt->results = results;\n\t\t\t\t__run_test(f, v, t);\n\t\t\t\tt->results = NULL;\n\t\t\t\tif (t->passed)\n\t\t\t\t\tpass_count++;\n\t\t\t\telse\n\t\t\t\t\tret = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmunmap(results, sizeof(*results));\n\n\tksft_print_msg(\"%s: %u / %u tests passed.\\n\", ret ? \"FAILED\" : \"PASSED\",\n\t\t\tpass_count, count);\n\tksft_exit(ret == 0);\n\n\t \n\treturn KSFT_FAIL;\n}\n\nstatic void __attribute__((constructor)) __constructor_order_first(void)\n{\n\tif (!__constructor_order)\n\t\t__constructor_order = _CONSTRUCTOR_ORDER_FORWARD;\n}\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}