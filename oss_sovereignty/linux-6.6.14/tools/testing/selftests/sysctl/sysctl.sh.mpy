{
  "module_name": "sysctl.sh",
  "hash_id": "f5e6eaffc5a4f6f2fa6f50f750b42201730dc73ee7126006fefe7e122710d07a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/sysctl/sysctl.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0-or-later OR copyleft-next-0.3.1\n# Copyright (C) 2017 Luis R. Rodriguez <mcgrof@kernel.org>\n\n# This performs a series tests against the proc sysctl interface.\n\n# Kselftest framework requirement - SKIP code is 4.\nksft_skip=4\n\nTEST_NAME=\"sysctl\"\nTEST_DRIVER=\"test_${TEST_NAME}\"\nTEST_DIR=$(dirname $0)\nTEST_FILE=$(mktemp)\n\n# This represents\n#\n# TEST_ID:TEST_COUNT:ENABLED:TARGET:SKIP_NO_TARGET\n#\n# TEST_ID: is the test id number\n# TEST_COUNT: number of times we should run the test\n# ENABLED: 1 if enabled, 0 otherwise\n# TARGET: test target file required on the test_sysctl module\n# SKIP_NO_TARGET: 1 skip if TARGET not there\n#                 0 run eventhough TARGET not there\n#\n# Once these are enabled please leave them as-is. Write your own test,\n# we have tons of space.\nALL_TESTS=\"0001:1:1:int_0001:1\"\nALL_TESTS=\"$ALL_TESTS 0002:1:1:string_0001:1\"\nALL_TESTS=\"$ALL_TESTS 0003:1:1:int_0002:1\"\nALL_TESTS=\"$ALL_TESTS 0004:1:1:uint_0001:1\"\nALL_TESTS=\"$ALL_TESTS 0005:3:1:int_0003:1\"\nALL_TESTS=\"$ALL_TESTS 0006:50:1:bitmap_0001:1\"\nALL_TESTS=\"$ALL_TESTS 0007:1:1:boot_int:1\"\nALL_TESTS=\"$ALL_TESTS 0008:1:1:match_int:1\"\nALL_TESTS=\"$ALL_TESTS 0009:1:1:unregister_error:0\"\nALL_TESTS=\"$ALL_TESTS 0010:1:1:mnt/mnt_error:0\"\n\nfunction allow_user_defaults()\n{\n\tif [ -z $DIR ]; then\n\t\tDIR=\"/sys/module/test_sysctl/\"\n\tfi\n\tif [ -z $DEFAULT_NUM_TESTS ]; then\n\t\tDEFAULT_NUM_TESTS=50\n\tfi\n\tif [ -z $SYSCTL ]; then\n\t\tSYSCTL=\"/proc/sys/debug/test_sysctl\"\n\tfi\n\tif [ -z $PROD_SYSCTL ]; then\n\t\tPROD_SYSCTL=\"/proc/sys\"\n\tfi\n\tif [ -z $WRITES_STRICT ]; then\n\t\tWRITES_STRICT=\"${PROD_SYSCTL}/kernel/sysctl_writes_strict\"\n\tfi\n}\n\nfunction check_production_sysctl_writes_strict()\n{\n\techo -n \"Checking production write strict setting ... \"\n\tif [ ! -e ${WRITES_STRICT} ]; then\n\t\techo \"FAIL, but skip in case of old kernel\" >&2\n\telse\n\t\told_strict=$(cat ${WRITES_STRICT})\n\t\tif [ \"$old_strict\" = \"1\" ]; then\n\t\t\techo \"ok\"\n\t\telse\n\t\t\techo \"FAIL, strict value is 0 but force to 1 to continue\" >&2\n\t\t\techo \"1\" > ${WRITES_STRICT}\n\t\tfi\n\tfi\n\n\tif [ -z $PAGE_SIZE ]; then\n\t\tPAGE_SIZE=$(getconf PAGESIZE)\n\tfi\n\tif [ -z $MAX_DIGITS ]; then\n\t\tMAX_DIGITS=$(($PAGE_SIZE/8))\n\tfi\n\tif [ -z $INT_MAX ]; then\n\t\tINT_MAX=$(getconf INT_MAX)\n\tfi\n\tif [ -z $UINT_MAX ]; then\n\t\tUINT_MAX=$(getconf UINT_MAX)\n\tfi\n}\n\ntest_reqs()\n{\n\tuid=$(id -u)\n\tif [ $uid -ne 0 ]; then\n\t\techo $msg must be run as root >&2\n\t\texit $ksft_skip\n\tfi\n\n\tif ! which perl 2> /dev/null > /dev/null; then\n\t\techo \"$0: You need perl installed\"\n\t\texit $ksft_skip\n\tfi\n\tif ! which getconf 2> /dev/null > /dev/null; then\n\t\techo \"$0: You need getconf installed\"\n\t\texit $ksft_skip\n\tfi\n\tif ! which diff 2> /dev/null > /dev/null; then\n\t\techo \"$0: You need diff installed\"\n\t\texit $ksft_skip\n\tfi\n}\n\nfunction load_req_mod()\n{\n\tif [ ! -d $SYSCTL ]; then\n\t\tif ! modprobe -q -n $TEST_DRIVER; then\n\t\t\techo \"$0: module $TEST_DRIVER not found [SKIP]\"\n\t\t\techo \"You must set CONFIG_TEST_SYSCTL=m in your kernel\" >&2\n\t\t\texit $ksft_skip\n\t\tfi\n\t\tmodprobe $TEST_DRIVER\n\t\tif [ $? -ne 0 ]; then\n\t\t\techo \"$0: modprobe $TEST_DRIVER failed.\"\n\t\t\texit\n\t\tfi\n\tfi\n}\n\nreset_vals()\n{\n\tVAL=\"\"\n\tTRIGGER=$(basename ${TARGET})\n\tcase \"$TRIGGER\" in\n\t\tint_0001)\n\t\t\tVAL=\"60\"\n\t\t\t;;\n\t\tint_0002)\n\t\t\tVAL=\"1\"\n\t\t\t;;\n\t\tuint_0001)\n\t\t\tVAL=\"314\"\n\t\t\t;;\n\t\tstring_0001)\n\t\t\tVAL=\"(none)\"\n\t\t\t;;\n\t\tbitmap_0001)\n\t\t\tVAL=\"\"\n\t\t\t;;\n\t\t*)\n\t\t\t;;\n\tesac\n\techo -n $VAL > $TARGET\n}\n\nset_orig()\n{\n\tif [ ! -z $TARGET ] && [ ! -z $ORIG ]; then\n\t\tif [ -f ${TARGET} ]; then\n\t\t\techo \"${ORIG}\" > \"${TARGET}\"\n\t\tfi\n\tfi\n}\n\nset_test()\n{\n\techo \"${TEST_STR}\" > \"${TARGET}\"\n}\n\nverify()\n{\n\tlocal seen\n\tseen=$(cat \"$1\")\n\tif [ \"${seen}\" != \"${TEST_STR}\" ]; then\n\t\treturn 1\n\tfi\n\treturn 0\n}\n\n# proc files get read a page at a time, which can confuse diff,\n# and get you incorrect results on proc files with long data. To use\n# diff against them you must first extract the output to a file, and\n# then compare against that file.\nverify_diff_proc_file()\n{\n\tTMP_DUMP_FILE=$(mktemp)\n\tcat $1 > $TMP_DUMP_FILE\n\n\tif ! diff -w -q $TMP_DUMP_FILE $2; then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\n}\n\nverify_diff_w()\n{\n\techo \"$TEST_STR\" | diff -q -w -u - $1 > /dev/null\n\treturn $?\n}\n\ntest_rc()\n{\n\tif [[ $rc != 0 ]]; then\n\t\techo \"Failed test, return value: $rc\" >&2\n\t\texit $rc\n\tfi\n}\n\ntest_finish()\n{\n\tset_orig\n\trm -f \"${TEST_FILE}\"\n\n\tif [ ! -z ${old_strict} ]; then\n\t\techo ${old_strict} > ${WRITES_STRICT}\n\tfi\n\texit $rc\n}\n\nrun_numerictests()\n{\n\techo \"== Testing sysctl behavior against ${TARGET} ==\"\n\n\trc=0\n\n\techo -n \"Writing test file ... \"\n\techo \"${TEST_STR}\" > \"${TEST_FILE}\"\n\tif ! verify \"${TEST_FILE}\"; then\n\t\techo \"FAIL\" >&2\n\t\texit 1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Checking sysctl is not set to test value ... \"\n\tif verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\texit 1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Writing sysctl from shell ... \"\n\tset_test\n\tif ! verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\texit 1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Resetting sysctl to original value ... \"\n\tset_orig\n\tif verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\texit 1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\t# Now that we've validated the sanity of \"set_test\" and \"set_orig\",\n\t# we can use those functions to set starting states before running\n\t# specific behavioral tests.\n\n\techo -n \"Writing entire sysctl in single write ... \"\n\tset_orig\n\tdd if=\"${TEST_FILE}\" of=\"${TARGET}\" bs=4096 2>/dev/null\n\tif ! verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Writing middle of sysctl after synchronized seek ... \"\n\tset_test\n\tdd if=\"${TEST_FILE}\" of=\"${TARGET}\" bs=1 seek=1 skip=1 2>/dev/null\n\tif ! verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Writing beyond end of sysctl ... \"\n\tset_orig\n\tdd if=\"${TEST_FILE}\" of=\"${TARGET}\" bs=20 seek=2 2>/dev/null\n\tif verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Writing sysctl with multiple long writes ... \"\n\tset_orig\n\t(perl -e 'print \"A\" x 50;'; echo \"${TEST_STR}\") | \\\n\t\tdd of=\"${TARGET}\" bs=50 2>/dev/null\n\tif verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n}\n\ncheck_failure()\n{\n\techo -n \"Testing that $1 fails as expected...\"\n\treset_vals\n\tTEST_STR=\"$1\"\n\torig=\"$(cat $TARGET)\"\n\techo -n \"$TEST_STR\" > $TARGET 2> /dev/null\n\n\t# write should fail and $TARGET should retain its original value\n\tif [ $? = 0 ] || [ \"$(cat $TARGET)\" != \"$orig\" ]; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n}\n\nrun_wideint_tests()\n{\n\t# sysctl conversion functions receive a boolean sign and ulong\n\t# magnitude; here we list the magnitudes we want to test (each of\n\t# which will be tested in both positive and negative forms).  Since\n\t# none of these values fit in 32 bits, writing them to an int- or\n\t# uint-typed sysctl should fail.\n\tlocal magnitudes=(\n\t\t# common boundary-condition values (zero, +1, -1, INT_MIN,\n\t\t# and INT_MAX respectively) if truncated to lower 32 bits\n\t\t# (potential for being falsely deemed in range)\n\t\t0x0000000100000000\n\t\t0x0000000100000001\n\t\t0x00000001ffffffff\n\t\t0x0000000180000000\n\t\t0x000000017fffffff\n\n\t\t# these look like negatives, but without a leading '-' are\n\t\t# actually large positives (should be rejected as above\n\t\t# despite being zero/+1/-1/INT_MIN/INT_MAX in the lower 32)\n\t\t0xffffffff00000000\n\t\t0xffffffff00000001\n\t\t0xffffffffffffffff\n\t\t0xffffffff80000000\n\t\t0xffffffff7fffffff\n\t)\n\n\tfor sign in '' '-'; do\n\t\tfor mag in \"${magnitudes[@]}\"; do\n\t\t\tcheck_failure \"${sign}${mag}\"\n\t\tdone\n\tdone\n}\n\n# Your test must accept digits 3 and 4 to use this\nrun_limit_digit()\n{\n\techo -n \"Checking ignoring spaces up to PAGE_SIZE works on write ...\"\n\treset_vals\n\n\tLIMIT=$((MAX_DIGITS -1))\n\tTEST_STR=\"3\"\n\t(perl -e 'print \" \" x '$LIMIT';'; echo \"${TEST_STR}\") | \\\n\t\tdd of=\"${TARGET}\" 2>/dev/null\n\n\tif ! verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n\n\techo -n \"Checking passing PAGE_SIZE of spaces fails on write ...\"\n\treset_vals\n\n\tLIMIT=$((MAX_DIGITS))\n\tTEST_STR=\"4\"\n\t(perl -e 'print \" \" x '$LIMIT';'; echo \"${TEST_STR}\") | \\\n\t\tdd of=\"${TARGET}\" 2>/dev/null\n\n\tif verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n}\n\n# You are using an int\nrun_limit_digit_int()\n{\n\techo -n \"Testing INT_MAX works ...\"\n\treset_vals\n\tTEST_STR=\"$INT_MAX\"\n\techo -n $TEST_STR > $TARGET\n\n\tif ! verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n\n\techo -n \"Testing INT_MAX + 1 will fail as expected...\"\n\treset_vals\n\tlet TEST_STR=$INT_MAX+1\n\techo -n $TEST_STR > $TARGET 2> /dev/null\n\n\tif verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n\n\techo -n \"Testing negative values will work as expected...\"\n\treset_vals\n\tTEST_STR=\"-3\"\n\techo -n $TEST_STR > $TARGET 2> /dev/null\n\tif ! verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n}\n\n# You used an int array\nrun_limit_digit_int_array()\n{\n\techo -n \"Testing array works as expected ... \"\n\tTEST_STR=\"4 3 2 1\"\n\techo -n $TEST_STR > $TARGET\n\n\tif ! verify_diff_w \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n\n\techo -n \"Testing skipping trailing array elements works ... \"\n\t# Do not reset_vals, carry on the values from the last test.\n\t# If we only echo in two digits the last two are left intact\n\tTEST_STR=\"100 101\"\n\techo -n $TEST_STR > $TARGET\n\t# After we echo in, to help diff we need to set on TEST_STR what\n\t# we expect the result to be.\n\tTEST_STR=\"100 101 2 1\"\n\n\tif ! verify_diff_w \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n\n\techo -n \"Testing PAGE_SIZE limit on array works ... \"\n\t# Do not reset_vals, carry on the values from the last test.\n\t# Even if you use an int array, you are still restricted to\n\t# MAX_DIGITS, this is a known limitation. Test limit works.\n\tLIMIT=$((MAX_DIGITS -1))\n\tTEST_STR=\"9\"\n\t(perl -e 'print \" \" x '$LIMIT';'; echo \"${TEST_STR}\") | \\\n\t\tdd of=\"${TARGET}\" 2>/dev/null\n\n\tTEST_STR=\"9 101 2 1\"\n\tif ! verify_diff_w \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n\n\techo -n \"Testing exceeding PAGE_SIZE limit fails as expected ... \"\n\t# Do not reset_vals, carry on the values from the last test.\n\t# Now go over limit.\n\tLIMIT=$((MAX_DIGITS))\n\tTEST_STR=\"7\"\n\t(perl -e 'print \" \" x '$LIMIT';'; echo \"${TEST_STR}\") | \\\n\t\tdd of=\"${TARGET}\" 2>/dev/null\n\n\tTEST_STR=\"7 101 2 1\"\n\tif verify_diff_w \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n}\n\n# You are using an unsigned int\nrun_limit_digit_uint()\n{\n\techo -n \"Testing UINT_MAX works ...\"\n\treset_vals\n\tTEST_STR=\"$UINT_MAX\"\n\techo -n $TEST_STR > $TARGET\n\n\tif ! verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n\n\techo -n \"Testing UINT_MAX + 1 will fail as expected...\"\n\treset_vals\n\tTEST_STR=$(($UINT_MAX+1))\n\techo -n $TEST_STR > $TARGET 2> /dev/null\n\n\tif verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n\n\techo -n \"Testing negative values will not work as expected ...\"\n\treset_vals\n\tTEST_STR=\"-3\"\n\techo -n $TEST_STR > $TARGET 2> /dev/null\n\n\tif verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\ttest_rc\n}\n\nrun_stringtests()\n{\n\techo -n \"Writing entire sysctl in short writes ... \"\n\tset_orig\n\tdd if=\"${TEST_FILE}\" of=\"${TARGET}\" bs=1 2>/dev/null\n\tif ! verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Writing middle of sysctl after unsynchronized seek ... \"\n\tset_test\n\tdd if=\"${TEST_FILE}\" of=\"${TARGET}\" bs=1 seek=1 2>/dev/null\n\tif verify \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Checking sysctl maxlen is at least $MAXLEN ... \"\n\tset_orig\n\tperl -e 'print \"A\" x ('\"${MAXLEN}\"'-2), \"B\";' | \\\n\t\tdd of=\"${TARGET}\" bs=\"${MAXLEN}\" 2>/dev/null\n\tif ! grep -q B \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Checking sysctl keeps original string on overflow append ... \"\n\tset_orig\n\tperl -e 'print \"A\" x ('\"${MAXLEN}\"'-1), \"B\";' | \\\n\t\tdd of=\"${TARGET}\" bs=$(( MAXLEN - 1 )) 2>/dev/null\n\tif grep -q B \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Checking sysctl stays NULL terminated on write ... \"\n\tset_orig\n\tperl -e 'print \"A\" x ('\"${MAXLEN}\"'-1), \"B\";' | \\\n\t\tdd of=\"${TARGET}\" bs=\"${MAXLEN}\" 2>/dev/null\n\tif grep -q B \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\techo -n \"Checking sysctl stays NULL terminated on overwrite ... \"\n\tset_orig\n\tperl -e 'print \"A\" x ('\"${MAXLEN}\"'-1), \"BB\";' | \\\n\t\tdd of=\"${TARGET}\" bs=$(( $MAXLEN + 1 )) 2>/dev/null\n\tif grep -q B \"${TARGET}\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\tfi\n\n\ttest_rc\n}\n\ntarget_exists()\n{\n\tTARGET=\"${SYSCTL}/$1\"\n\tTEST_ID=\"$2\"\n\n\tif [ ! -f ${TARGET} ] ; then\n\t\treturn 0\n\tfi\n\treturn 1\n}\n\nrun_bitmaptest() {\n\t# Total length of bitmaps string to use, a bit under\n\t# the maximum input size of the test node\n\tLENGTH=$((RANDOM % 65000))\n\n\t# First bit to set\n\tBIT=$((RANDOM % 1024))\n\n\t# String containing our list of bits to set\n\tTEST_STR=$BIT\n\n\t# build up the string\n\twhile [ \"${#TEST_STR}\" -le \"$LENGTH\" ]; do\n\t\t# Make sure next entry is discontiguous,\n\t\t# skip ahead at least 2\n\t\tBIT=$((BIT + $((2 + RANDOM % 10))))\n\n\t\t# Add new bit to the list\n\t\tTEST_STR=\"${TEST_STR},${BIT}\"\n\n\t\t# Randomly make it a range\n\t\tif [ \"$((RANDOM % 2))\" -eq \"1\" ]; then\n\t\t\tRANGE_END=$((BIT + $((1 + RANDOM % 10))))\n\t\t\tTEST_STR=\"${TEST_STR}-${RANGE_END}\"\n\t\t\tBIT=$RANGE_END\n\t\tfi\n\tdone\n\n\techo -n \"Checking bitmap handler... \"\n\tTEST_FILE=$(mktemp)\n\techo -n \"$TEST_STR\" > $TEST_FILE\n\n\tcat $TEST_FILE > $TARGET 2> /dev/null\n\tif [ $? -ne 0 ]; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\t\ttest_rc\n\tfi\n\n\tif ! verify_diff_proc_file \"$TARGET\" \"$TEST_FILE\"; then\n\t\techo \"FAIL\" >&2\n\t\trc=1\n\telse\n\t\techo \"ok\"\n\t\trc=0\n\tfi\n\ttest_rc\n}\n\nsysctl_test_0001()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0001)\"\n\treset_vals\n\tORIG=$(cat \"${TARGET}\")\n\tTEST_STR=$(( $ORIG + 1 ))\n\n\trun_numerictests\n\trun_wideint_tests\n\trun_limit_digit\n}\n\nsysctl_test_0002()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0002)\"\n\treset_vals\n\tORIG=$(cat \"${TARGET}\")\n\tTEST_STR=\"Testing sysctl\"\n\t# Only string sysctls support seeking/appending.\n\tMAXLEN=65\n\n\trun_numerictests\n\trun_stringtests\n}\n\nsysctl_test_0003()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0003)\"\n\treset_vals\n\tORIG=$(cat \"${TARGET}\")\n\tTEST_STR=$(( $ORIG + 1 ))\n\n\trun_numerictests\n\trun_wideint_tests\n\trun_limit_digit\n\trun_limit_digit_int\n}\n\nsysctl_test_0004()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0004)\"\n\treset_vals\n\tORIG=$(cat \"${TARGET}\")\n\tTEST_STR=$(( $ORIG + 1 ))\n\n\trun_numerictests\n\trun_wideint_tests\n\trun_limit_digit\n\trun_limit_digit_uint\n}\n\nsysctl_test_0005()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0005)\"\n\treset_vals\n\tORIG=$(cat \"${TARGET}\")\n\n\trun_limit_digit_int_array\n}\n\nsysctl_test_0006()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0006)\"\n\treset_vals\n\tORIG=\"\"\n\trun_bitmaptest\n}\n\nsysctl_test_0007()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0007)\"\n\tif [ ! -f $TARGET ]; then\n\t\techo \"Skipping test for $TARGET as it is not present ...\"\n\t\treturn $ksft_skip\n\tfi\n\n\tif [ -d $DIR ]; then\n\t\techo \"Boot param test only possible sysctl_test is built-in, not module:\"\n\t\tcat $TEST_DIR/config >&2\n\t\treturn $ksft_skip\n\tfi\n\n\techo -n \"Testing if $TARGET is set to 1 ...\"\n\tORIG=$(cat \"${TARGET}\")\n\n\tif [ x$ORIG = \"x1\" ]; then\n\t\techo \"ok\"\n\t\treturn 0\n\tfi\n\techo \"FAIL\"\n\techo \"Checking if /proc/cmdline contains setting of the expected parameter ...\"\n\tif [ ! -f /proc/cmdline ]; then\n\t\techo \"/proc/cmdline does not exist, test inconclusive\"\n\t\treturn 0\n\tfi\n\n\tFOUND=$(grep -c \"sysctl[./]debug[./]test_sysctl[./]boot_int=1\" /proc/cmdline)\n\tif [ $FOUND = \"1\" ]; then\n\t\techo \"Kernel param found but $TARGET is not 1, TEST FAILED\"\n\t\trc=1\n\t\ttest_rc\n\tfi\n\n\techo \"Skipping test, expected kernel parameter missing.\"\n\techo \"To perform this test, make sure kernel is booted with parameter: sysctl.debug.test_sysctl.boot_int=1\"\n\treturn $ksft_skip\n}\n\nsysctl_test_0008()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0008)\"\n\tif [ ! -f $TARGET ]; then\n\t\techo \"Skipping test for $TARGET as it is not present ...\"\n\t\treturn $ksft_skip\n\tfi\n\n\techo -n \"Testing if $TARGET is matched in kernel\"\n\tORIG_VALUE=$(cat \"${TARGET}\")\n\n\tif [ $ORIG_VALUE -ne 1 ]; then\n\t\techo \"TEST FAILED\"\n\t\trc=1\n\t\ttest_rc\n\tfi\n\n\techo \"ok\"\n\treturn 0\n}\n\nsysctl_test_0009()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0009)\"\n\techo -n \"Testing if $TARGET unregistered correctly ...\"\n\tif [ -d $TARGET ]; then\n\t\techo \"TEST FAILED\"\n\t\trc=1\n\t\ttest_rc\n\tfi\n\n\techo \"ok\"\n\treturn 0\n}\n\nsysctl_test_0010()\n{\n\tTARGET=\"${SYSCTL}/$(get_test_target 0010)\"\n\techo -n \"Testing that $TARGET was not created  ...\"\n\tif [ -d $TARGET ]; then\n\t\techo \"TEST FAILED\"\n\t\trc=1\n\t\ttest_rc\n\tfi\n\n\techo \"ok\"\n\treturn 0\n}\n\nlist_tests()\n{\n\techo \"Test ID list:\"\n\techo\n\techo \"TEST_ID x NUM_TEST\"\n\techo \"TEST_ID:   Test ID\"\n\techo \"NUM_TESTS: Number of recommended times to run the test\"\n\techo\n\techo \"0001 x $(get_test_count 0001) - tests proc_dointvec_minmax()\"\n\techo \"0002 x $(get_test_count 0002) - tests proc_dostring()\"\n\techo \"0003 x $(get_test_count 0003) - tests proc_dointvec()\"\n\techo \"0004 x $(get_test_count 0004) - tests proc_douintvec()\"\n\techo \"0005 x $(get_test_count 0005) - tests proc_douintvec() array\"\n\techo \"0006 x $(get_test_count 0006) - tests proc_do_large_bitmap()\"\n\techo \"0007 x $(get_test_count 0007) - tests setting sysctl from kernel boot param\"\n\techo \"0008 x $(get_test_count 0008) - tests sysctl macro values match\"\n\techo \"0009 x $(get_test_count 0009) - tests sysct unregister\"\n\techo \"0010 x $(get_test_count 0010) - tests sysct mount point\"\n}\n\nusage()\n{\n\tNUM_TESTS=$(grep -o ' ' <<<\"$ALL_TESTS\" | grep -c .)\n\tlet NUM_TESTS=$NUM_TESTS+1\n\tMAX_TEST=$(printf \"%04d\\n\" $NUM_TESTS)\n\techo \"Usage: $0 [ -t <4-number-digit> ] | [ -w <4-number-digit> ] |\"\n\techo \"\t\t [ -s <4-number-digit> ] | [ -c <4-number-digit> <test- count>\"\n\techo \"           [ all ] [ -h | --help ] [ -l ]\"\n\techo \"\"\n\techo \"Valid tests: 0001-$MAX_TEST\"\n\techo \"\"\n\techo \"    all     Runs all tests (default)\"\n\techo \"    -t      Run test ID the number amount of times is recommended\"\n\techo \"    -w      Watch test ID run until it runs into an error\"\n\techo \"    -c      Run test ID once\"\n\techo \"    -s      Run test ID x test-count number of times\"\n\techo \"    -l      List all test ID list\"\n\techo \" -h|--help  Help\"\n\techo\n\techo \"If an error every occurs execution will immediately terminate.\"\n\techo \"If you are adding a new test try using -w <test-ID> first to\"\n\techo \"make sure the test passes a series of tests.\"\n\techo\n\techo Example uses:\n\techo\n\techo \"$TEST_NAME.sh            -- executes all tests\"\n\techo \"$TEST_NAME.sh -t 0002    -- Executes test ID 0002 number of times is recomended\"\n\techo \"$TEST_NAME.sh -w 0002    -- Watch test ID 0002 run until an error occurs\"\n\techo \"$TEST_NAME.sh -s 0002    -- Run test ID 0002 once\"\n\techo \"$TEST_NAME.sh -c 0002 3  -- Run test ID 0002 three times\"\n\techo\n\tlist_tests\n\texit 1\n}\n\nfunction test_num()\n{\n\tre='^[0-9]+$'\n\tif ! [[ $1 =~ $re ]]; then\n\t\tusage\n\tfi\n}\nfunction remove_leading_zeros()\n{\n\techo $1 | sed 's/^0*//'\n}\n\nfunction get_test_count()\n{\n\ttest_num $1\n\tawk_field=$(remove_leading_zeros $1)\n\tTEST_DATA=$(echo $ALL_TESTS | awk '{print $'$awk_field'}')\n\techo ${TEST_DATA} | awk -F\":\" '{print $2}'\n}\n\nfunction get_test_enabled()\n{\n\ttest_num $1\n\tawk_field=$(remove_leading_zeros $1)\n\tTEST_DATA=$(echo $ALL_TESTS | awk '{print $'$awk_field'}')\n\techo ${TEST_DATA} | awk -F\":\" '{print $3}'\n}\n\nfunction get_test_target()\n{\n\ttest_num $1\n\tawk_field=$(remove_leading_zeros $1)\n\tTEST_DATA=$(echo $ALL_TESTS | awk '{print $'$awk_field'}')\n\techo ${TEST_DATA} | awk -F\":\" '{print $4}'\n}\n\nfunction get_test_skip_no_target()\n{\n\ttest_num $1\n\tawk_field=$(remove_leading_zeros $1)\n\tTEST_DATA=$(echo $ALL_TESTS | awk '{print $'$awk_field'}')\n\techo ${TEST_DATA} | awk -F\":\" '{print $5}'\n}\n\nfunction skip_test()\n{\n\tTEST_ID=$1\n\tTEST_TARGET=$2\n\tif target_exists $TEST_TARGET $TEST_ID; then\n\t\tTEST_SKIP=$(get_test_skip_no_target $TEST_ID)\n\t\tif [[ $TEST_SKIP -eq \"1\" ]]; then\n\t\t\techo \"Target for test $TEST_ID: $TEST_TARGET not exist, skipping test ...\"\n\t\t\treturn 0\n\t\tfi\n\tfi\n\treturn 1\n}\n\nfunction run_all_tests()\n{\n\tfor i in $ALL_TESTS ; do\n\t\tTEST_ID=${i%:*:*:*:*}\n\t\tENABLED=$(get_test_enabled $TEST_ID)\n\t\tTEST_COUNT=$(get_test_count $TEST_ID)\n\t\tTEST_TARGET=$(get_test_target $TEST_ID)\n\n\t\tif [[ $ENABLED -eq \"1\" ]]; then\n\t\t\ttest_case $TEST_ID $TEST_COUNT $TEST_TARGET\n\t\tfi\n\tdone\n}\n\nfunction watch_log()\n{\n\tif [ $# -ne 3 ]; then\n\t\tclear\n\tfi\n\tdate\n\techo \"Running test: $2 - run #$1\"\n}\n\nfunction watch_case()\n{\n\ti=0\n\twhile [ 1 ]; do\n\n\t\tif [ $# -eq 1 ]; then\n\t\t\ttest_num $1\n\t\t\twatch_log $i ${TEST_NAME}_test_$1\n\t\t\t${TEST_NAME}_test_$1\n\t\telse\n\t\t\twatch_log $i all\n\t\t\trun_all_tests\n\t\tfi\n\t\tlet i=$i+1\n\tdone\n}\n\nfunction test_case()\n{\n\tTEST_ID=$1\n\tNUM_TESTS=$2\n\tTARGET=$3\n\n\tif skip_test $TEST_ID $TARGET; then\n\t\treturn\n\tfi\n\n\ti=0\n\twhile [ $i -lt $NUM_TESTS ]; do\n\t\ttest_num $TEST_ID\n\t\twatch_log $i ${TEST_NAME}_test_${TEST_ID} noclear\n\t\tRUN_TEST=${TEST_NAME}_test_${TEST_ID}\n\t\t$RUN_TEST\n\t\tlet i=$i+1\n\tdone\n}\n\nfunction parse_args()\n{\n\tif [ $# -eq 0 ]; then\n\t\trun_all_tests\n\telse\n\t\tif [[ \"$1\" = \"all\" ]]; then\n\t\t\trun_all_tests\n\t\telif [[ \"$1\" = \"-w\" ]]; then\n\t\t\tshift\n\t\t\twatch_case $@\n\t\telif [[ \"$1\" = \"-t\" ]]; then\n\t\t\tshift\n\t\t\ttest_num $1\n\t\t\ttest_case $1 $(get_test_count $1) $(get_test_target $1)\n\t\telif [[ \"$1\" = \"-c\" ]]; then\n\t\t\tshift\n\t\t\ttest_num $1\n\t\t\ttest_num $2\n\t\t\ttest_case $1 $2 $(get_test_target $1)\n\t\telif [[ \"$1\" = \"-s\" ]]; then\n\t\t\tshift\n\t\t\ttest_case $1 1 $(get_test_target $1)\n\t\telif [[ \"$1\" = \"-l\" ]]; then\n\t\t\tlist_tests\n\t\telif [[ \"$1\" = \"-h\" || \"$1\" = \"--help\" ]]; then\n\t\t\tusage\n\t\telse\n\t\t\tusage\n\t\tfi\n\tfi\n}\n\ntest_reqs\nallow_user_defaults\ncheck_production_sysctl_writes_strict\nload_req_mod\n\ntrap \"test_finish\" EXIT\n\nparse_args $@\n\nexit 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}