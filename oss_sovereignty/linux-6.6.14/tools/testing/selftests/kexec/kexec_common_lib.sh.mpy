{
  "module_name": "kexec_common_lib.sh",
  "hash_id": "286e3cfcc6bb519264b55f587f46df17eea4089f855e51d9d4323dab49c2f2e7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/kexec/kexec_common_lib.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# Kselftest framework defines: ksft_pass=0, ksft_fail=1, ksft_skip=4\n\nVERBOSE=\"${VERBOSE:-1}\"\nIKCONFIG=\"/tmp/config-`uname -r`\"\nKERNEL_IMAGE=\"/boot/vmlinuz-`uname -r`\"\nSECURITYFS=$(grep \"securityfs\" /proc/mounts | awk '{print $2}')\n\nlog_info()\n{\n\t[ $VERBOSE -ne 0 ] && echo \"[INFO] $1\"\n}\n\n# The ksefltest framework requirement returns 0 for PASS.\nlog_pass()\n{\n\t[ $VERBOSE -ne 0 ] && echo \"$1 [PASS]\"\n\texit 0\n}\n\n# The ksefltest framework requirement returns 1 for FAIL.\nlog_fail()\n{\n\t[ $VERBOSE -ne 0 ] && echo \"$1 [FAIL]\"\n\texit 1\n}\n\n# The ksefltest framework requirement returns 4 for SKIP.\nlog_skip()\n{\n\t[ $VERBOSE -ne 0 ] && echo \"$1\"\n\texit 4\n}\n\n# Check efivar SecureBoot-$(the UUID) and SetupMode-$(the UUID).\n# (Based on kdump-lib.sh)\nget_efivarfs_secureboot_mode()\n{\n\tlocal efivarfs=\"/sys/firmware/efi/efivars\"\n\tlocal secure_boot_file=\"\"\n\tlocal setup_mode_file=\"\"\n\tlocal secureboot_mode=0\n\tlocal setup_mode=0\n\n\t# Make sure that efivar_fs is mounted in the normal location\n\tif ! grep -q \"^\\S\\+ $efivarfs efivarfs\" /proc/mounts; then\n\t\tlog_info \"efivars is not mounted on $efivarfs\"\n\t\treturn 0;\n\tfi\n\tsecure_boot_file=$(find \"$efivarfs\" -name SecureBoot-* 2>/dev/null)\n\tsetup_mode_file=$(find \"$efivarfs\" -name SetupMode-* 2>/dev/null)\n\tif [ -f \"$secure_boot_file\" ] && [ -f \"$setup_mode_file\" ]; then\n\t\tsecureboot_mode=$(hexdump -v -e '/1 \"%d\\ \"' \\\n\t\t\t\"$secure_boot_file\"|cut -d' ' -f 5)\n\t\tsetup_mode=$(hexdump -v -e '/1 \"%d\\ \"' \\\n\t\t\t\"$setup_mode_file\"|cut -d' ' -f 5)\n\n\t\tif [ $secureboot_mode -eq 1 ] && [ $setup_mode -eq 0 ]; then\n\t\t\tlog_info \"secure boot mode enabled (CONFIG_EFIVAR_FS)\"\n\t\t\treturn 1;\n\t\tfi\n\tfi\n\treturn 0;\n}\n\n# On powerpc platform, check device-tree property\n# /proc/device-tree/ibm,secureboot/os-secureboot-enforcing\n# to detect secureboot state.\nget_ppc64_secureboot_mode()\n{\n\tlocal secure_boot_file=\"/proc/device-tree/ibm,secureboot/os-secureboot-enforcing\"\n\t# Check for secure boot file existence\n\tif [ -f $secure_boot_file ]; then\n\t\tlog_info \"Secureboot is enabled (Device tree)\"\n\t\treturn 1;\n\tfi\n\tlog_info \"Secureboot is not enabled (Device tree)\"\n\treturn 0;\n}\n\n# Return the architecture of the system\nget_arch()\n{\n\techo $(arch)\n}\n\n# Check efivar SecureBoot-$(the UUID) and SetupMode-$(the UUID).\n# The secure boot mode can be accessed as the last integer of\n# \"od -An -t u1 /sys/firmware/efi/efivars/SecureBoot-*\".  The efi\n# SetupMode can be similarly accessed.\n# Return 1 for SecureBoot mode enabled and SetupMode mode disabled.\nget_secureboot_mode()\n{\n\tlocal secureboot_mode=0\n\tlocal system_arch=$(get_arch)\n\n\tif [ \"$system_arch\" == \"ppc64le\" ]; then\n\t\tget_ppc64_secureboot_mode\n\t\tsecureboot_mode=$?\n\telse\n\t\tget_efivarfs_secureboot_mode\n\t\tsecureboot_mode=$?\n\tfi\n\n\tif [ $secureboot_mode -eq 0 ]; then\n\t\tlog_info \"secure boot mode not enabled\"\n\tfi\n\treturn $secureboot_mode;\n}\n\nrequire_root_privileges()\n{\n\tif [ $(id -ru) -ne 0 ]; then\n\t\tlog_skip \"requires root privileges\"\n\tfi\n}\n\n# Look for config option in Kconfig file.\n# Return 1 for found and 0 for not found.\nkconfig_enabled()\n{\n\tlocal config=\"$1\"\n\tlocal msg=\"$2\"\n\n\tgrep -E -q $config $IKCONFIG\n\tif [ $? -eq 0 ]; then\n\t\tlog_info \"$msg\"\n\t\treturn 1\n\tfi\n\treturn 0\n}\n\n# Attempt to get the kernel config first by checking the modules directory\n# then via proc, and finally by extracting it from the kernel image or the\n# configs.ko using scripts/extract-ikconfig.\n# Return 1 for found.\nget_kconfig()\n{\n\tlocal proc_config=\"/proc/config.gz\"\n\tlocal module_dir=\"/lib/modules/`uname -r`\"\n\tlocal configs_module=\"$module_dir/kernel/kernel/configs.ko*\"\n\n\tif [ -f $module_dir/config ]; then\n\t\tIKCONFIG=$module_dir/config\n\t\treturn 1\n\tfi\n\n\tif [ ! -f $proc_config ]; then\n\t\tmodprobe configs > /dev/null 2>&1\n\tfi\n\tif [ -f $proc_config ]; then\n\t\tcat $proc_config | gunzip > $IKCONFIG 2>/dev/null\n\t\tif [ $? -eq 0 ]; then\n\t\t\treturn 1\n\t\tfi\n\tfi\n\n\tlocal extract_ikconfig=\"$module_dir/source/scripts/extract-ikconfig\"\n\tif [ ! -f $extract_ikconfig ]; then\n\t\tlog_skip \"extract-ikconfig not found\"\n\tfi\n\n\t$extract_ikconfig $KERNEL_IMAGE > $IKCONFIG 2>/dev/null\n\tif [ $? -eq 1 ]; then\n\t\tif [ ! -f $configs_module ]; then\n\t\t\tlog_skip \"CONFIG_IKCONFIG not enabled\"\n\t\tfi\n\t\t$extract_ikconfig $configs_module > $IKCONFIG\n\t\tif [ $? -eq 1 ]; then\n\t\t\tlog_skip \"CONFIG_IKCONFIG not enabled\"\n\t\tfi\n\tfi\n\treturn 1\n}\n\n# Make sure that securityfs is mounted\nmount_securityfs()\n{\n\tif [ -z $SECURITYFS ]; then\n\t\tSECURITYFS=/sys/kernel/security\n\t\tmount -t securityfs security $SECURITYFS\n\tfi\n\n\tif [ ! -d \"$SECURITYFS\" ]; then\n\t\tlog_fail \"$SECURITYFS :securityfs is not mounted\"\n\tfi\n}\n\n# The policy rule format is an \"action\" followed by key-value pairs.  This\n# function supports up to two key-value pairs, in any order.\n# For example: action func=<keyword> [appraise_type=<type>]\n# Return 1 for found and 0 for not found.\ncheck_ima_policy()\n{\n\tlocal action=\"$1\"\n\tlocal keypair1=\"$2\"\n\tlocal keypair2=\"$3\"\n\tlocal ret=0\n\n\tmount_securityfs\n\n\tlocal ima_policy=$SECURITYFS/ima/policy\n\tif [ ! -e $ima_policy ]; then\n\t\tlog_fail \"$ima_policy not found\"\n\tfi\n\n\tif [ -n $keypair2 ]; then\n\t\tgrep -e \"^$action.*$keypair1\" \"$ima_policy\" | \\\n\t\t\tgrep -q -e \"$keypair2\"\n\telse\n\t\tgrep -q -e \"^$action.*$keypair1\" \"$ima_policy\"\n\tfi\n\n\t# invert \"grep -q\" result, returning 1 for found.\n\t[ $? -eq 0 ] && ret=1\n\treturn $ret\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}