{
  "module_name": "regression_test.txt",
  "hash_id": "7cb378ae3c39a7f6018e6c0dfdfd27214f71a50069dad77c0bda97d7d6f5c611",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/media_tests/regression_test.txt",
  "human_readable_source": "Testing for regressions in Media Controller API register, ioctl, syscall,\nand unregister paths. There have a few problems that result in user-after\nfree on media_device, media_devnode, and cdev pointers when the driver is\nunbound while ioctl is in progress.\n\nTest Procedure:\n\nRun bin/unbind loop while ioctls are in progress.\nRun rmmod and modprobe.\nDisconnect the device.\n\nSetup:\n\nBuild media_device_test\ncd tools/testing/selftests/media_tests\nmake\n\nRegressions test for cdev user-after free error on /dev/mediaX when driver\nis unbound:\n\nStart media_device_test to regression test media devnode dynamic alloc\nand cdev user-after-free fixes. This opens media dev files and sits in\na loop running media ioctl MEDIA_IOC_DEVICE_INFO command once every 10\nseconds. The idea is when device file goes away, media devnode and cdev\nshould stick around until this test exits.\n\nThe test for a random number of iterations or until user kills it with a\nsleep 10 in between the ioctl calls.\n\nsudo ./media_device_test -d /dev/mediaX\n\nRegression test for media_devnode unregister race with ioctl_syscall:\n\nStart 6 open_loop_test.sh tests with different /dev/mediaX files. When\ndevice file goes away after unbind, device file name changes. Start the\ntest with possible device names. If we start with /dev/media0 for example,\nafter unbind, /dev/media1 or /dev/media2 could get created. The idea is\nkeep ioctls going while bind/unbind runs.\n\nCopy bind_unbind_sample.txt and make changes to specify the driver name\nand number to run bind and unbind. Start the bind_unbind.sh\n\nRun dmesg looking for any user-after free errors or mutex lock errors.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}