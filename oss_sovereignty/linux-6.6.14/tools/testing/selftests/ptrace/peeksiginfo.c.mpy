{
  "module_name": "peeksiginfo.c",
  "hash_id": "db4b3b9c0909963deb979b0ea1ff13191ccbbabd51dd94ac4a1250f9dfd21d46",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ptrace/peeksiginfo.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <linux/types.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/user.h>\n#include <sys/mman.h>\n\n#include \"linux/ptrace.h\"\n\nstatic int sys_rt_sigqueueinfo(pid_t tgid, int sig, siginfo_t *uinfo)\n{\n\treturn syscall(SYS_rt_sigqueueinfo, tgid, sig, uinfo);\n}\n\nstatic int sys_rt_tgsigqueueinfo(pid_t tgid, pid_t tid,\n\t\t\t\t\tint sig, siginfo_t *uinfo)\n{\n\treturn syscall(SYS_rt_tgsigqueueinfo, tgid, tid, sig, uinfo);\n}\n\nstatic int sys_ptrace(int request, pid_t pid, void *addr, void *data)\n{\n\treturn syscall(SYS_ptrace, request, pid, addr, data);\n}\n\n#define SIGNR 10\n#define TEST_SICODE_PRIV\t-1\n#define TEST_SICODE_SHARE\t-2\n\n#ifndef PAGE_SIZE\n#define PAGE_SIZE sysconf(_SC_PAGESIZE)\n#endif\n\n#define err(fmt, ...)\t\t\t\t\t\t\\\n\t\tfprintf(stderr,\t\t\t\t\t\\\n\t\t\t\"Error (%s:%d): \" fmt,\t\t\t\\\n\t\t\t__FILE__, __LINE__, ##__VA_ARGS__)\n\nstatic int check_error_paths(pid_t child)\n{\n\tstruct ptrace_peeksiginfo_args arg;\n\tint ret, exit_code = -1;\n\tvoid *addr_rw, *addr_ro;\n\n\t \n\taddr_rw = mmap(NULL, 2 * PAGE_SIZE, PROT_READ | PROT_WRITE,\n\t\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tif (addr_rw == MAP_FAILED) {\n\t\terr(\"mmap() failed: %m\\n\");\n\t\treturn 1;\n\t}\n\n\taddr_ro = mmap(addr_rw + PAGE_SIZE, PAGE_SIZE, PROT_READ,\n\t\t\tMAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);\n\tif (addr_ro == MAP_FAILED) {\n\t\terr(\"mmap() failed: %m\\n\");\n\t\tgoto out;\n\t}\n\n\targ.nr = SIGNR;\n\targ.off = 0;\n\n\t \n\targ.flags = ~0;\n\tret = sys_ptrace(PTRACE_PEEKSIGINFO, child, &arg, addr_rw);\n\tif (ret != -1 || errno != EINVAL) {\n\t\terr(\"sys_ptrace() returns %d (expected -1),\"\n\t\t\t\t\" errno %d (expected %d): %m\\n\",\n\t\t\t\tret, errno, EINVAL);\n\t\tgoto out;\n\t}\n\targ.flags = 0;\n\n\t \n\tret = sys_ptrace(PTRACE_PEEKSIGINFO, child, &arg,\n\t\t\t\t\taddr_ro - sizeof(siginfo_t) * 2);\n\tif (ret != 2) {\n\t\terr(\"sys_ptrace() returns %d (expected 2): %m\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = sys_ptrace(PTRACE_PEEKSIGINFO, child, &arg, addr_ro);\n\tif (ret != -1 && errno != EFAULT) {\n\t\terr(\"sys_ptrace() returns %d (expected -1),\"\n\t\t\t\t\" errno %d (expected %d): %m\\n\",\n\t\t\t\tret, errno, EFAULT);\n\t\tgoto out;\n\t}\n\n\texit_code = 0;\nout:\n\tmunmap(addr_rw, 2 * PAGE_SIZE);\n\treturn exit_code;\n}\n\nint check_direct_path(pid_t child, int shared, int nr)\n{\n\tstruct ptrace_peeksiginfo_args arg = {.flags = 0, .nr = nr, .off = 0};\n\tint i, j, ret, exit_code = -1;\n\tsiginfo_t siginfo[SIGNR];\n\tint si_code;\n\n\tif (shared == 1) {\n\t\targ.flags = PTRACE_PEEKSIGINFO_SHARED;\n\t\tsi_code = TEST_SICODE_SHARE;\n\t} else {\n\t\targ.flags = 0;\n\t\tsi_code = TEST_SICODE_PRIV;\n\t}\n\n\tfor (i = 0; i < SIGNR; ) {\n\t\targ.off = i;\n\t\tret = sys_ptrace(PTRACE_PEEKSIGINFO, child, &arg, siginfo);\n\t\tif (ret == -1) {\n\t\t\terr(\"ptrace() failed: %m\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\tfor (j = 0; j < ret; j++, i++) {\n\t\t\tif (siginfo[j].si_code == si_code &&\n\t\t\t    siginfo[j].si_int == i)\n\t\t\t\tcontinue;\n\n\t\t\terr(\"%d: Wrong siginfo i=%d si_code=%d si_int=%d\\n\",\n\t\t\t     shared, i, siginfo[j].si_code, siginfo[j].si_int);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (i != SIGNR) {\n\t\terr(\"Only %d signals were read\\n\", i);\n\t\tgoto out;\n\t}\n\n\texit_code = 0;\nout:\n\treturn exit_code;\n}\n\nint main(int argc, char *argv[])\n{\n\tsiginfo_t siginfo;\n\tint i, exit_code = 1;\n\tsigset_t blockmask;\n\tpid_t child;\n\n\tsigemptyset(&blockmask);\n\tsigaddset(&blockmask, SIGRTMIN);\n\tsigprocmask(SIG_BLOCK, &blockmask, NULL);\n\n\tchild = fork();\n\tif (child == -1) {\n\t\terr(\"fork() failed: %m\");\n\t\treturn 1;\n\t} else if (child == 0) {\n\t\tpid_t ppid = getppid();\n\t\twhile (1) {\n\t\t\tif (ppid != getppid())\n\t\t\t\tbreak;\n\t\t\tsleep(1);\n\t\t}\n\t\treturn 1;\n\t}\n\n\t \n\tfor (i = 0; i < SIGNR; i++) {\n\t\tsiginfo.si_code = TEST_SICODE_SHARE;\n\t\tsiginfo.si_int = i;\n\t\tsys_rt_sigqueueinfo(child, SIGRTMIN, &siginfo);\n\n\t\tsiginfo.si_code = TEST_SICODE_PRIV;\n\t\tsiginfo.si_int = i;\n\t\tsys_rt_tgsigqueueinfo(child, child, SIGRTMIN, &siginfo);\n\t}\n\n\tif (sys_ptrace(PTRACE_ATTACH, child, NULL, NULL) == -1)\n\t\treturn 1;\n\n\twaitpid(child, NULL, 0);\n\n\t \n\tif (check_direct_path(child, 0, 1))\n\t\tgoto out;\n\t \n\tif (check_direct_path(child, 0, SIGNR))\n\t\tgoto out;\n\n\t \n\tif (check_direct_path(child, 1, 3))\n\t\tgoto out;\n\n\tif (check_error_paths(child))\n\t\tgoto out;\n\n\tprintf(\"PASS\\n\");\n\texit_code = 0;\nout:\n\tif (sys_ptrace(PTRACE_KILL, child, NULL, NULL) == -1)\n\t\treturn 1;\n\n\twaitpid(child, NULL, 0);\n\n\treturn exit_code;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}