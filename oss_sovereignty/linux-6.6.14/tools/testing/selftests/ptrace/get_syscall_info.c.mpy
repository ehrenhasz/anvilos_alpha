{
  "module_name": "get_syscall_info.c",
  "hash_id": "770d89c05dd4dab55496974cdb304858434ee4f1f36f721af59f95d4eefcf164",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/ptrace/get_syscall_info.c",
  "human_readable_source": "\n \n\n#include \"../kselftest_harness.h\"\n#include <err.h>\n#include <signal.h>\n#include <asm/unistd.h>\n#include \"linux/ptrace.h\"\n\nstatic int\nkill_tracee(pid_t pid)\n{\n\tif (!pid)\n\t\treturn 0;\n\n\tint saved_errno = errno;\n\n\tint rc = kill(pid, SIGKILL);\n\n\terrno = saved_errno;\n\treturn rc;\n}\n\nstatic long\nsys_ptrace(int request, pid_t pid, unsigned long addr, unsigned long data)\n{\n\treturn syscall(__NR_ptrace, request, pid, addr, data);\n}\n\n#define LOG_KILL_TRACEE(fmt, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tkill_tracee(pid);\t\t\t\t\\\n\t\tTH_LOG(\"wait #%d: \" fmt,\t\t\t\\\n\t\t       ptrace_stop, ##__VA_ARGS__);\t\t\\\n\t} while (0)\n\nTEST(get_syscall_info)\n{\n\tstatic const unsigned long args[][7] = {\n\t\t \n\t\t{\n\t\t\t__NR_chdir,\n\t\t\t(unsigned long) \"\",\n\t\t\t0xbad1fed1,\n\t\t\t0xbad2fed2,\n\t\t\t0xbad3fed3,\n\t\t\t0xbad4fed4,\n\t\t\t0xbad5fed5\n\t\t},\n\t\t{\n\t\t\t__NR_gettid,\n\t\t\t0xcaf0bea0,\n\t\t\t0xcaf1bea1,\n\t\t\t0xcaf2bea2,\n\t\t\t0xcaf3bea3,\n\t\t\t0xcaf4bea4,\n\t\t\t0xcaf5bea5\n\t\t},\n\t\t{\n\t\t\t__NR_exit_group,\n\t\t\t0,\n\t\t\t0xfac1c0d1,\n\t\t\t0xfac2c0d2,\n\t\t\t0xfac3c0d3,\n\t\t\t0xfac4c0d4,\n\t\t\t0xfac5c0d5\n\t\t}\n\t};\n\tconst unsigned long *exp_args;\n\n\tpid_t pid = fork();\n\n\tASSERT_LE(0, pid) {\n\t\tTH_LOG(\"fork: %m\");\n\t}\n\n\tif (pid == 0) {\n\t\t \n\t\tpid = getpid();\n\t\tASSERT_EQ(0, sys_ptrace(PTRACE_TRACEME, 0, 0, 0)) {\n\t\t\tTH_LOG(\"PTRACE_TRACEME: %m\");\n\t\t}\n\t\tASSERT_EQ(0, kill(pid, SIGSTOP)) {\n\t\t\t \n\t\t\tTH_LOG(\"kill SIGSTOP: %m\");\n\t\t}\n\t\tfor (unsigned int i = 0; i < ARRAY_SIZE(args); ++i) {\n\t\t\tsyscall(args[i][0],\n\t\t\t\targs[i][1], args[i][2], args[i][3],\n\t\t\t\targs[i][4], args[i][5], args[i][6]);\n\t\t}\n\t\t \n\t\t_exit(1);\n\t}\n\n\tconst struct {\n\t\tunsigned int is_error;\n\t\tint rval;\n\t} *exp_param, exit_param[] = {\n\t\t{ 1, -ENOENT },\t \n\t\t{ 0, pid }\t \n\t};\n\n\tunsigned int ptrace_stop;\n\n\tfor (ptrace_stop = 0; ; ++ptrace_stop) {\n\t\tstruct ptrace_syscall_info info = {\n\t\t\t.op = 0xff\t \n\t\t};\n\t\tconst size_t size = sizeof(info);\n\t\tconst int expected_none_size =\n\t\t\t(void *) &info.entry - (void *) &info;\n\t\tconst int expected_entry_size =\n\t\t\t(void *) &info.entry.args[6] - (void *) &info;\n\t\tconst int expected_exit_size =\n\t\t\t(void *) (&info.exit.is_error + 1) -\n\t\t\t(void *) &info;\n\t\tint status;\n\t\tlong rc;\n\n\t\tASSERT_EQ(pid, wait(&status)) {\n\t\t\t \n\t\t\tLOG_KILL_TRACEE(\"wait: %m\");\n\t\t}\n\t\tif (WIFEXITED(status)) {\n\t\t\tpid = 0;\t \n\t\t\tASSERT_EQ(0, WEXITSTATUS(status));\n\t\t\tbreak;\n\t\t}\n\t\tASSERT_FALSE(WIFSIGNALED(status)) {\n\t\t\tpid = 0;\t \n\t\t\tLOG_KILL_TRACEE(\"unexpected signal %u\",\n\t\t\t\t\tWTERMSIG(status));\n\t\t}\n\t\tASSERT_TRUE(WIFSTOPPED(status)) {\n\t\t\t \n\t\t\tLOG_KILL_TRACEE(\"unexpected wait status %#x\", status);\n\t\t}\n\n\t\tswitch (WSTOPSIG(status)) {\n\t\tcase SIGSTOP:\n\t\t\tASSERT_EQ(0, ptrace_stop) {\n\t\t\t\tLOG_KILL_TRACEE(\"unexpected signal stop\");\n\t\t\t}\n\t\t\tASSERT_EQ(0, sys_ptrace(PTRACE_SETOPTIONS, pid, 0,\n\t\t\t\t\t\tPTRACE_O_TRACESYSGOOD)) {\n\t\t\t\tLOG_KILL_TRACEE(\"PTRACE_SETOPTIONS: %m\");\n\t\t\t}\n\t\t\tASSERT_LT(0, (rc = sys_ptrace(PTRACE_GET_SYSCALL_INFO,\n\t\t\t\t\t\t      pid, size,\n\t\t\t\t\t\t      (unsigned long) &info))) {\n\t\t\t\tLOG_KILL_TRACEE(\"PTRACE_GET_SYSCALL_INFO: %m\");\n\t\t\t}\n\t\t\tASSERT_EQ(expected_none_size, rc) {\n\t\t\t\tLOG_KILL_TRACEE(\"signal stop mismatch\");\n\t\t\t}\n\t\t\tASSERT_EQ(PTRACE_SYSCALL_INFO_NONE, info.op) {\n\t\t\t\tLOG_KILL_TRACEE(\"signal stop mismatch\");\n\t\t\t}\n\t\t\tASSERT_TRUE(info.arch) {\n\t\t\t\tLOG_KILL_TRACEE(\"signal stop mismatch\");\n\t\t\t}\n\t\t\tASSERT_TRUE(info.instruction_pointer) {\n\t\t\t\tLOG_KILL_TRACEE(\"signal stop mismatch\");\n\t\t\t}\n\t\t\tASSERT_TRUE(info.stack_pointer) {\n\t\t\t\tLOG_KILL_TRACEE(\"signal stop mismatch\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SIGTRAP | 0x80:\n\t\t\tASSERT_LT(0, (rc = sys_ptrace(PTRACE_GET_SYSCALL_INFO,\n\t\t\t\t\t\t      pid, size,\n\t\t\t\t\t\t      (unsigned long) &info))) {\n\t\t\t\tLOG_KILL_TRACEE(\"PTRACE_GET_SYSCALL_INFO: %m\");\n\t\t\t}\n\t\t\tswitch (ptrace_stop) {\n\t\t\tcase 1:  \n\t\t\tcase 3:  \n\t\t\tcase 5:  \n\t\t\t\texp_args = args[ptrace_stop / 2];\n\t\t\t\tASSERT_EQ(expected_entry_size, rc) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(PTRACE_SYSCALL_INFO_ENTRY, info.op) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_TRUE(info.arch) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_TRUE(info.instruction_pointer) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_TRUE(info.stack_pointer) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(exp_args[0], info.entry.nr) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(exp_args[1], info.entry.args[0]) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(exp_args[2], info.entry.args[1]) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(exp_args[3], info.entry.args[2]) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(exp_args[4], info.entry.args[3]) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(exp_args[5], info.entry.args[4]) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(exp_args[6], info.entry.args[5]) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"entry stop mismatch\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\tcase 4:  \n\t\t\t\texp_param = &exit_param[ptrace_stop / 2 - 1];\n\t\t\t\tASSERT_EQ(expected_exit_size, rc) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"exit stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(PTRACE_SYSCALL_INFO_EXIT, info.op) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"exit stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_TRUE(info.arch) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"exit stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_TRUE(info.instruction_pointer) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"exit stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_TRUE(info.stack_pointer) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"exit stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(exp_param->is_error,\n\t\t\t\t\t  info.exit.is_error) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"exit stop mismatch\");\n\t\t\t\t}\n\t\t\t\tASSERT_EQ(exp_param->rval, info.exit.rval) {\n\t\t\t\t\tLOG_KILL_TRACEE(\"exit stop mismatch\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLOG_KILL_TRACEE(\"unexpected syscall stop\");\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tLOG_KILL_TRACEE(\"unexpected stop signal %#x\",\n\t\t\t\t\tWSTOPSIG(status));\n\t\t\tabort();\n\t\t}\n\n\t\tASSERT_EQ(0, sys_ptrace(PTRACE_SYSCALL, pid, 0, 0)) {\n\t\t\tLOG_KILL_TRACEE(\"PTRACE_SYSCALL: %m\");\n\t\t}\n\t}\n\n\tASSERT_EQ(ARRAY_SIZE(args) * 2, ptrace_stop);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}