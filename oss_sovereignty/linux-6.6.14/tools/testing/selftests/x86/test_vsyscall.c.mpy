{
  "module_name": "test_vsyscall.c",
  "hash_id": "1c94e33eb82fccf0413d45b4226c03a7df8f5e4b7163e1a27385ee9c72f40d99",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/test_vsyscall.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <sys/ucontext.h>\n#include <errno.h>\n#include <err.h>\n#include <sched.h>\n#include <stdbool.h>\n#include <setjmp.h>\n#include <sys/uio.h>\n\n#include \"helpers.h\"\n\n#ifdef __x86_64__\n# define VSYS(x) (x)\n#else\n# define VSYS(x) 0\n#endif\n\n#ifndef SYS_getcpu\n# ifdef __x86_64__\n#  define SYS_getcpu 309\n# else\n#  define SYS_getcpu 318\n# endif\n#endif\n\n \n#define MAPS_LINE_LEN 128\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\n \nbool vsyscall_map_r = false, vsyscall_map_x = false;\n\ntypedef long (*gtod_t)(struct timeval *tv, struct timezone *tz);\nconst gtod_t vgtod = (gtod_t)VSYS(0xffffffffff600000);\ngtod_t vdso_gtod;\n\ntypedef int (*vgettime_t)(clockid_t, struct timespec *);\nvgettime_t vdso_gettime;\n\ntypedef long (*time_func_t)(time_t *t);\nconst time_func_t vtime = (time_func_t)VSYS(0xffffffffff600400);\ntime_func_t vdso_time;\n\ntypedef long (*getcpu_t)(unsigned *, unsigned *, void *);\nconst getcpu_t vgetcpu = (getcpu_t)VSYS(0xffffffffff600800);\ngetcpu_t vdso_getcpu;\n\nstatic void init_vdso(void)\n{\n\tvoid *vdso = dlopen(\"linux-vdso.so.1\", RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n\tif (!vdso)\n\t\tvdso = dlopen(\"linux-gate.so.1\", RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD);\n\tif (!vdso) {\n\t\tprintf(\"[WARN]\\tfailed to find vDSO\\n\");\n\t\treturn;\n\t}\n\n\tvdso_gtod = (gtod_t)dlsym(vdso, \"__vdso_gettimeofday\");\n\tif (!vdso_gtod)\n\t\tprintf(\"[WARN]\\tfailed to find gettimeofday in vDSO\\n\");\n\n\tvdso_gettime = (vgettime_t)dlsym(vdso, \"__vdso_clock_gettime\");\n\tif (!vdso_gettime)\n\t\tprintf(\"[WARN]\\tfailed to find clock_gettime in vDSO\\n\");\n\n\tvdso_time = (time_func_t)dlsym(vdso, \"__vdso_time\");\n\tif (!vdso_time)\n\t\tprintf(\"[WARN]\\tfailed to find time in vDSO\\n\");\n\n\tvdso_getcpu = (getcpu_t)dlsym(vdso, \"__vdso_getcpu\");\n\tif (!vdso_getcpu)\n\t\tprintf(\"[WARN]\\tfailed to find getcpu in vDSO\\n\");\n}\n\nstatic int init_vsys(void)\n{\n#ifdef __x86_64__\n\tint nerrs = 0;\n\tFILE *maps;\n\tchar line[MAPS_LINE_LEN];\n\tbool found = false;\n\n\tmaps = fopen(\"/proc/self/maps\", \"r\");\n\tif (!maps) {\n\t\tprintf(\"[WARN]\\tCould not open /proc/self/maps -- assuming vsyscall is r-x\\n\");\n\t\tvsyscall_map_r = true;\n\t\treturn 0;\n\t}\n\n\twhile (fgets(line, MAPS_LINE_LEN, maps)) {\n\t\tchar r, x;\n\t\tvoid *start, *end;\n\t\tchar name[MAPS_LINE_LEN];\n\n\t\t \n\t\tif (sscanf(line, \"%p-%p %c-%cp %*x %*x:%*x %*u %s\",\n\t\t\t   &start, &end, &r, &x, name) != 5)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, \"[vsyscall]\"))\n\t\t\tcontinue;\n\n\t\tprintf(\"\\tvsyscall map: %s\", line);\n\n\t\tif (start != (void *)0xffffffffff600000 ||\n\t\t    end != (void *)0xffffffffff601000) {\n\t\t\tprintf(\"[FAIL]\\taddress range is nonsense\\n\");\n\t\t\tnerrs++;\n\t\t}\n\n\t\tprintf(\"\\tvsyscall permissions are %c-%c\\n\", r, x);\n\t\tvsyscall_map_r = (r == 'r');\n\t\tvsyscall_map_x = (x == 'x');\n\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\tfclose(maps);\n\n\tif (!found) {\n\t\tprintf(\"\\tno vsyscall map in /proc/self/maps\\n\");\n\t\tvsyscall_map_r = false;\n\t\tvsyscall_map_x = false;\n\t}\n\n\treturn nerrs;\n#else\n\treturn 0;\n#endif\n}\n\n \nstatic inline long sys_gtod(struct timeval *tv, struct timezone *tz)\n{\n\treturn syscall(SYS_gettimeofday, tv, tz);\n}\n\nstatic inline int sys_clock_gettime(clockid_t id, struct timespec *ts)\n{\n\treturn syscall(SYS_clock_gettime, id, ts);\n}\n\nstatic inline long sys_time(time_t *t)\n{\n\treturn syscall(SYS_time, t);\n}\n\nstatic inline long sys_getcpu(unsigned * cpu, unsigned * node,\n\t\t\t      void* cache)\n{\n\treturn syscall(SYS_getcpu, cpu, node, cache);\n}\n\nstatic jmp_buf jmpbuf;\nstatic volatile unsigned long segv_err;\n\nstatic void sigsegv(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t *)ctx_void;\n\n\tsegv_err =  ctx->uc_mcontext.gregs[REG_ERR];\n\tsiglongjmp(jmpbuf, 1);\n}\n\nstatic double tv_diff(const struct timeval *a, const struct timeval *b)\n{\n\treturn (double)(a->tv_sec - b->tv_sec) +\n\t\t(double)((int)a->tv_usec - (int)b->tv_usec) * 1e-6;\n}\n\nstatic int check_gtod(const struct timeval *tv_sys1,\n\t\t      const struct timeval *tv_sys2,\n\t\t      const struct timezone *tz_sys,\n\t\t      const char *which,\n\t\t      const struct timeval *tv_other,\n\t\t      const struct timezone *tz_other)\n{\n\tint nerrs = 0;\n\tdouble d1, d2;\n\n\tif (tz_other && (tz_sys->tz_minuteswest != tz_other->tz_minuteswest || tz_sys->tz_dsttime != tz_other->tz_dsttime)) {\n\t\tprintf(\"[FAIL] %s tz mismatch\\n\", which);\n\t\tnerrs++;\n\t}\n\n\td1 = tv_diff(tv_other, tv_sys1);\n\td2 = tv_diff(tv_sys2, tv_other); \n\tprintf(\"\\t%s time offsets: %lf %lf\\n\", which, d1, d2);\n\n\tif (d1 < 0 || d2 < 0) {\n\t\tprintf(\"[FAIL]\\t%s time was inconsistent with the syscall\\n\", which);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\t%s gettimeofday()'s timeval was okay\\n\", which);\n\t}\n\n\treturn nerrs;\n}\n\nstatic int test_gtod(void)\n{\n\tstruct timeval tv_sys1, tv_sys2, tv_vdso, tv_vsys;\n\tstruct timezone tz_sys, tz_vdso, tz_vsys;\n\tlong ret_vdso = -1;\n\tlong ret_vsys = -1;\n\tint nerrs = 0;\n\n\tprintf(\"[RUN]\\ttest gettimeofday()\\n\");\n\n\tif (sys_gtod(&tv_sys1, &tz_sys) != 0)\n\t\terr(1, \"syscall gettimeofday\");\n\tif (vdso_gtod)\n\t\tret_vdso = vdso_gtod(&tv_vdso, &tz_vdso);\n\tif (vsyscall_map_x)\n\t\tret_vsys = vgtod(&tv_vsys, &tz_vsys);\n\tif (sys_gtod(&tv_sys2, &tz_sys) != 0)\n\t\terr(1, \"syscall gettimeofday\");\n\n\tif (vdso_gtod) {\n\t\tif (ret_vdso == 0) {\n\t\t\tnerrs += check_gtod(&tv_sys1, &tv_sys2, &tz_sys, \"vDSO\", &tv_vdso, &tz_vdso);\n\t\t} else {\n\t\t\tprintf(\"[FAIL]\\tvDSO gettimeofday() failed: %ld\\n\", ret_vdso);\n\t\t\tnerrs++;\n\t\t}\n\t}\n\n\tif (vsyscall_map_x) {\n\t\tif (ret_vsys == 0) {\n\t\t\tnerrs += check_gtod(&tv_sys1, &tv_sys2, &tz_sys, \"vsyscall\", &tv_vsys, &tz_vsys);\n\t\t} else {\n\t\t\tprintf(\"[FAIL]\\tvsys gettimeofday() failed: %ld\\n\", ret_vsys);\n\t\t\tnerrs++;\n\t\t}\n\t}\n\n\treturn nerrs;\n}\n\nstatic int test_time(void) {\n\tint nerrs = 0;\n\n\tprintf(\"[RUN]\\ttest time()\\n\");\n\tlong t_sys1, t_sys2, t_vdso = 0, t_vsys = 0;\n\tlong t2_sys1 = -1, t2_sys2 = -1, t2_vdso = -1, t2_vsys = -1;\n\tt_sys1 = sys_time(&t2_sys1);\n\tif (vdso_time)\n\t\tt_vdso = vdso_time(&t2_vdso);\n\tif (vsyscall_map_x)\n\t\tt_vsys = vtime(&t2_vsys);\n\tt_sys2 = sys_time(&t2_sys2);\n\tif (t_sys1 < 0 || t_sys1 != t2_sys1 || t_sys2 < 0 || t_sys2 != t2_sys2) {\n\t\tprintf(\"[FAIL]\\tsyscall failed (ret1:%ld output1:%ld ret2:%ld output2:%ld)\\n\", t_sys1, t2_sys1, t_sys2, t2_sys2);\n\t\tnerrs++;\n\t\treturn nerrs;\n\t}\n\n\tif (vdso_time) {\n\t\tif (t_vdso < 0 || t_vdso != t2_vdso) {\n\t\t\tprintf(\"[FAIL]\\tvDSO failed (ret:%ld output:%ld)\\n\", t_vdso, t2_vdso);\n\t\t\tnerrs++;\n\t\t} else if (t_vdso < t_sys1 || t_vdso > t_sys2) {\n\t\t\tprintf(\"[FAIL]\\tvDSO returned the wrong time (%ld %ld %ld)\\n\", t_sys1, t_vdso, t_sys2);\n\t\t\tnerrs++;\n\t\t} else {\n\t\t\tprintf(\"[OK]\\tvDSO time() is okay\\n\");\n\t\t}\n\t}\n\n\tif (vsyscall_map_x) {\n\t\tif (t_vsys < 0 || t_vsys != t2_vsys) {\n\t\t\tprintf(\"[FAIL]\\tvsyscall failed (ret:%ld output:%ld)\\n\", t_vsys, t2_vsys);\n\t\t\tnerrs++;\n\t\t} else if (t_vsys < t_sys1 || t_vsys > t_sys2) {\n\t\t\tprintf(\"[FAIL]\\tvsyscall returned the wrong time (%ld %ld %ld)\\n\", t_sys1, t_vsys, t_sys2);\n\t\t\tnerrs++;\n\t\t} else {\n\t\t\tprintf(\"[OK]\\tvsyscall time() is okay\\n\");\n\t\t}\n\t}\n\n\treturn nerrs;\n}\n\nstatic int test_getcpu(int cpu)\n{\n\tint nerrs = 0;\n\tlong ret_sys, ret_vdso = -1, ret_vsys = -1;\n\n\tprintf(\"[RUN]\\tgetcpu() on CPU %d\\n\", cpu);\n\n\tcpu_set_t cpuset;\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(cpu, &cpuset);\n\tif (sched_setaffinity(0, sizeof(cpuset), &cpuset) != 0) {\n\t\tprintf(\"[SKIP]\\tfailed to force CPU %d\\n\", cpu);\n\t\treturn nerrs;\n\t}\n\n\tunsigned cpu_sys, cpu_vdso, cpu_vsys, node_sys, node_vdso, node_vsys;\n\tunsigned node = 0;\n\tbool have_node = false;\n\tret_sys = sys_getcpu(&cpu_sys, &node_sys, 0);\n\tif (vdso_getcpu)\n\t\tret_vdso = vdso_getcpu(&cpu_vdso, &node_vdso, 0);\n\tif (vsyscall_map_x)\n\t\tret_vsys = vgetcpu(&cpu_vsys, &node_vsys, 0);\n\n\tif (ret_sys == 0) {\n\t\tif (cpu_sys != cpu) {\n\t\t\tprintf(\"[FAIL]\\tsyscall reported CPU %hu but should be %d\\n\", cpu_sys, cpu);\n\t\t\tnerrs++;\n\t\t}\n\n\t\thave_node = true;\n\t\tnode = node_sys;\n\t}\n\n\tif (vdso_getcpu) {\n\t\tif (ret_vdso) {\n\t\t\tprintf(\"[FAIL]\\tvDSO getcpu() failed\\n\");\n\t\t\tnerrs++;\n\t\t} else {\n\t\t\tif (!have_node) {\n\t\t\t\thave_node = true;\n\t\t\t\tnode = node_vdso;\n\t\t\t}\n\n\t\t\tif (cpu_vdso != cpu) {\n\t\t\t\tprintf(\"[FAIL]\\tvDSO reported CPU %hu but should be %d\\n\", cpu_vdso, cpu);\n\t\t\t\tnerrs++;\n\t\t\t} else {\n\t\t\t\tprintf(\"[OK]\\tvDSO reported correct CPU\\n\");\n\t\t\t}\n\n\t\t\tif (node_vdso != node) {\n\t\t\t\tprintf(\"[FAIL]\\tvDSO reported node %hu but should be %hu\\n\", node_vdso, node);\n\t\t\t\tnerrs++;\n\t\t\t} else {\n\t\t\t\tprintf(\"[OK]\\tvDSO reported correct node\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vsyscall_map_x) {\n\t\tif (ret_vsys) {\n\t\t\tprintf(\"[FAIL]\\tvsyscall getcpu() failed\\n\");\n\t\t\tnerrs++;\n\t\t} else {\n\t\t\tif (!have_node) {\n\t\t\t\thave_node = true;\n\t\t\t\tnode = node_vsys;\n\t\t\t}\n\n\t\t\tif (cpu_vsys != cpu) {\n\t\t\t\tprintf(\"[FAIL]\\tvsyscall reported CPU %hu but should be %d\\n\", cpu_vsys, cpu);\n\t\t\t\tnerrs++;\n\t\t\t} else {\n\t\t\t\tprintf(\"[OK]\\tvsyscall reported correct CPU\\n\");\n\t\t\t}\n\n\t\t\tif (node_vsys != node) {\n\t\t\t\tprintf(\"[FAIL]\\tvsyscall reported node %hu but should be %hu\\n\", node_vsys, node);\n\t\t\t\tnerrs++;\n\t\t\t} else {\n\t\t\t\tprintf(\"[OK]\\tvsyscall reported correct node\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nerrs;\n}\n\nstatic int test_vsys_r(void)\n{\n#ifdef __x86_64__\n\tprintf(\"[RUN]\\tChecking read access to the vsyscall page\\n\");\n\tbool can_read;\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\t*(volatile int *)0xffffffffff600000;\n\t\tcan_read = true;\n\t} else {\n\t\tcan_read = false;\n\t}\n\n\tif (can_read && !vsyscall_map_r) {\n\t\tprintf(\"[FAIL]\\tWe have read access, but we shouldn't\\n\");\n\t\treturn 1;\n\t} else if (!can_read && vsyscall_map_r) {\n\t\tprintf(\"[FAIL]\\tWe don't have read access, but we should\\n\");\n\t\treturn 1;\n\t} else if (can_read) {\n\t\tprintf(\"[OK]\\tWe have read access\\n\");\n\t} else {\n\t\tprintf(\"[OK]\\tWe do not have read access: #PF(0x%lx)\\n\",\n\t\t       segv_err);\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int test_vsys_x(void)\n{\n#ifdef __x86_64__\n\tif (vsyscall_map_x) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tprintf(\"[RUN]\\tMake sure that vsyscalls really page fault\\n\");\n\n\tbool can_exec;\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tvgtod(NULL, NULL);\n\t\tcan_exec = true;\n\t} else {\n\t\tcan_exec = false;\n\t}\n\n\tif (can_exec) {\n\t\tprintf(\"[FAIL]\\tExecuting the vsyscall did not page fault\\n\");\n\t\treturn 1;\n\t} else if (segv_err & (1 << 4)) {  \n\t\tprintf(\"[OK]\\tExecuting the vsyscall page failed: #PF(0x%lx)\\n\",\n\t\t       segv_err);\n\t} else {\n\t\tprintf(\"[FAIL]\\tExecution failed with the wrong error: #PF(0x%lx)\\n\",\n\t\t       segv_err);\n\t\treturn 1;\n\t}\n#endif\n\n\treturn 0;\n}\n\n \nstatic int test_process_vm_readv(void)\n{\n#ifdef __x86_64__\n\tchar buf[4096];\n\tstruct iovec local, remote;\n\tint ret;\n\n\tprintf(\"[RUN]\\tprocess_vm_readv() from vsyscall page\\n\");\n\n\tlocal.iov_base = buf;\n\tlocal.iov_len = 4096;\n\tremote.iov_base = (void *)0xffffffffff600000;\n\tremote.iov_len = 4096;\n\tret = process_vm_readv(getpid(), &local, 1, &remote, 1, 0);\n\tif (ret != 4096) {\n\t\t \n\t\tprintf(\"[%s]\\tprocess_vm_readv() failed (ret = %d, errno = %d)\\n\", vsyscall_map_r ? \"FAIL\" : \"OK\", ret, errno);\n\t\treturn vsyscall_map_r ? 1 : 0;\n\t}\n\n\tif (vsyscall_map_r) {\n\t\tif (!memcmp(buf, remote.iov_base, sizeof(buf))) {\n\t\t\tprintf(\"[OK]\\tIt worked and read correct data\\n\");\n\t\t} else {\n\t\t\tprintf(\"[FAIL]\\tIt worked but returned incorrect data\\n\");\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tprintf(\"[FAIL]\\tprocess_rm_readv() succeeded, but it should have failed in this configuration\\n\");\n\t\treturn 1;\n\t}\n#endif\n\n\treturn 0;\n}\n\n#ifdef __x86_64__\nstatic volatile sig_atomic_t num_vsyscall_traps;\n\nstatic void sigtrap(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t *)ctx_void;\n\tunsigned long ip = ctx->uc_mcontext.gregs[REG_RIP];\n\n\tif (((ip ^ 0xffffffffff600000UL) & ~0xfffUL) == 0)\n\t\tnum_vsyscall_traps++;\n}\n\nstatic int test_emulation(void)\n{\n\ttime_t tmp;\n\tbool is_native;\n\n\tif (!vsyscall_map_x)\n\t\treturn 0;\n\n\tprintf(\"[RUN]\\tchecking that vsyscalls are emulated\\n\");\n\tsethandler(SIGTRAP, sigtrap, 0);\n\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\tvtime(&tmp);\n\tset_eflags(get_eflags() & ~X86_EFLAGS_TF);\n\n\t \n\tis_native = (num_vsyscall_traps > 1);\n\n\tprintf(\"[%s]\\tvsyscalls are %s (%d instructions in vsyscall page)\\n\",\n\t       (is_native ? \"FAIL\" : \"OK\"),\n\t       (is_native ? \"native\" : \"emulated\"),\n\t       (int)num_vsyscall_traps);\n\n\treturn is_native;\n}\n#endif\n\nint main(int argc, char **argv)\n{\n\tint nerrs = 0;\n\n\tinit_vdso();\n\tnerrs += init_vsys();\n\n\tnerrs += test_gtod();\n\tnerrs += test_time();\n\tnerrs += test_getcpu(0);\n\tnerrs += test_getcpu(1);\n\n\tsethandler(SIGSEGV, sigsegv, 0);\n\tnerrs += test_vsys_r();\n\tnerrs += test_vsys_x();\n\n\tnerrs += test_process_vm_readv();\n\n#ifdef __x86_64__\n\tnerrs += test_emulation();\n#endif\n\n\treturn nerrs ? 1 : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}