{
  "module_name": "entry_from_vm86.c",
  "hash_id": "6adc6d3278eba80ac8b74ca913f36fb642914b80286c89f1330d054738616a89",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/entry_from_vm86.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <assert.h>\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <sys/signal.h>\n#include <sys/ucontext.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n#include <sys/mman.h>\n#include <err.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <sys/vm86.h>\n\nstatic unsigned long load_addr = 0x10000;\nstatic int nerrs = 0;\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void clearhandler(int sig)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_DFL;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic sig_atomic_t got_signal;\n\nstatic void sighandler(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\n\tif (ctx->uc_mcontext.gregs[REG_EFL] & X86_EFLAGS_VM ||\n\t    (ctx->uc_mcontext.gregs[REG_CS] & 3) != 3) {\n\t\tprintf(\"[FAIL]\\tSignal frame should not reflect vm86 mode\\n\");\n\t\tnerrs++;\n\t}\n\n\tconst char *signame;\n\tif (sig == SIGSEGV)\n\t\tsigname = \"SIGSEGV\";\n\telse if (sig == SIGILL)\n\t\tsigname = \"SIGILL\";\n\telse\n\t\tsigname = \"unexpected signal\";\n\n\tprintf(\"[INFO]\\t%s: FLAGS = 0x%lx, CS = 0x%hx\\n\", signame,\n\t       (unsigned long)ctx->uc_mcontext.gregs[REG_EFL],\n\t       (unsigned short)ctx->uc_mcontext.gregs[REG_CS]);\n\n\tgot_signal = 1;\n}\n\nasm (\n\t\".pushsection .rodata\\n\\t\"\n\t\".type vmcode_bound, @object\\n\\t\"\n\t\"vmcode:\\n\\t\"\n\t\"vmcode_bound:\\n\\t\"\n\t\".code16\\n\\t\"\n\t\"bound %ax, (2048)\\n\\t\"\n\t\"int3\\n\\t\"\n\t\"vmcode_sysenter:\\n\\t\"\n\t\"sysenter\\n\\t\"\n\t\"vmcode_syscall:\\n\\t\"\n\t\"syscall\\n\\t\"\n\t\"vmcode_sti:\\n\\t\"\n\t\"sti\\n\\t\"\n\t\"vmcode_int3:\\n\\t\"\n\t\"int3\\n\\t\"\n\t\"vmcode_int80:\\n\\t\"\n\t\"int $0x80\\n\\t\"\n\t\"vmcode_popf_hlt:\\n\\t\"\n\t\"push %ax\\n\\t\"\n\t\"popf\\n\\t\"\n\t\"hlt\\n\\t\"\n\t\"vmcode_umip:\\n\\t\"\n\t \n\t\"smsw (2052)\\n\\t\"\n\t\"sidt (2054)\\n\\t\"\n\t\"sgdt (2060)\\n\\t\"\n\t \n\t\"mov $2066, %bx\\n\\t\"\n\t\"smsw (%bx)\\n\\t\"\n\t\"mov $2068, %bx\\n\\t\"\n\t\"sidt (%bx)\\n\\t\"\n\t\"mov $2074, %bx\\n\\t\"\n\t\"sgdt (%bx)\\n\\t\"\n\t \n\t\"smsw %ax\\n\\t\"\n\t\"mov %ax, (2080)\\n\\t\"\n\t\"int3\\n\\t\"\n\t\"vmcode_umip_str:\\n\\t\"\n\t\"str %eax\\n\\t\"\n\t\"vmcode_umip_sldt:\\n\\t\"\n\t\"sldt %eax\\n\\t\"\n\t\"int3\\n\\t\"\n\t\".size vmcode, . - vmcode\\n\\t\"\n\t\"end_vmcode:\\n\\t\"\n\t\".code32\\n\\t\"\n\t\".popsection\"\n\t);\n\nextern unsigned char vmcode[], end_vmcode[];\nextern unsigned char vmcode_bound[], vmcode_sysenter[], vmcode_syscall[],\n\tvmcode_sti[], vmcode_int3[], vmcode_int80[], vmcode_popf_hlt[],\n\tvmcode_umip[], vmcode_umip_str[], vmcode_umip_sldt[];\n\n \nstatic bool do_test(struct vm86plus_struct *v86, unsigned long eip,\n\t\t    unsigned int rettype, unsigned int retarg,\n\t\t    const char *text)\n{\n\tlong ret;\n\n\tprintf(\"[RUN]\\t%s from vm86 mode\\n\", text);\n\tv86->regs.eip = eip;\n\tret = vm86(VM86_ENTER, v86);\n\n\tif (ret == -1 && (errno == ENOSYS || errno == EPERM)) {\n\t\tprintf(\"[SKIP]\\tvm86 %s\\n\",\n\t\t       errno == ENOSYS ? \"not supported\" : \"not allowed\");\n\t\treturn false;\n\t}\n\n\tif (VM86_TYPE(ret) == VM86_INTx) {\n\t\tchar trapname[32];\n\t\tint trapno = VM86_ARG(ret);\n\t\tif (trapno == 13)\n\t\t\tstrcpy(trapname, \"GP\");\n\t\telse if (trapno == 5)\n\t\t\tstrcpy(trapname, \"BR\");\n\t\telse if (trapno == 14)\n\t\t\tstrcpy(trapname, \"PF\");\n\t\telse\n\t\t\tsprintf(trapname, \"%d\", trapno);\n\n\t\tprintf(\"[INFO]\\tExited vm86 mode due to #%s\\n\", trapname);\n\t} else if (VM86_TYPE(ret) == VM86_UNKNOWN) {\n\t\tprintf(\"[INFO]\\tExited vm86 mode due to unhandled GP fault\\n\");\n\t} else if (VM86_TYPE(ret) == VM86_TRAP) {\n\t\tprintf(\"[INFO]\\tExited vm86 mode due to a trap (arg=%ld)\\n\",\n\t\t       VM86_ARG(ret));\n\t} else if (VM86_TYPE(ret) == VM86_SIGNAL) {\n\t\tprintf(\"[INFO]\\tExited vm86 mode due to a signal\\n\");\n\t} else if (VM86_TYPE(ret) == VM86_STI) {\n\t\tprintf(\"[INFO]\\tExited vm86 mode due to STI\\n\");\n\t} else {\n\t\tprintf(\"[INFO]\\tExited vm86 mode due to type %ld, arg %ld\\n\",\n\t\t       VM86_TYPE(ret), VM86_ARG(ret));\n\t}\n\n\tif (rettype == -1 ||\n\t    (VM86_TYPE(ret) == rettype && VM86_ARG(ret) == retarg)) {\n\t\tprintf(\"[OK]\\tReturned correctly\\n\");\n\t} else {\n\t\tprintf(\"[FAIL]\\tIncorrect return reason (started at eip = 0x%lx, ended at eip = 0x%lx)\\n\", eip, v86->regs.eip);\n\t\tnerrs++;\n\t}\n\n\treturn true;\n}\n\nvoid do_umip_tests(struct vm86plus_struct *vm86, unsigned char *test_mem)\n{\n\tstruct table_desc {\n\t\tunsigned short limit;\n\t\tunsigned long base;\n\t} __attribute__((packed));\n\n\t \n\tstruct table_desc gdt1 = { .base = 0x3c3c3c3c, .limit = 0x9999 };\n\tstruct table_desc gdt2 = { .base = 0x1a1a1a1a, .limit = 0xaeae };\n\tstruct table_desc idt1 = { .base = 0x7b7b7b7b, .limit = 0xf1f1 };\n\tstruct table_desc idt2 = { .base = 0x89898989, .limit = 0x1313 };\n\tunsigned short msw1 = 0x1414, msw2 = 0x2525, msw3 = 3737;\n\n\t \n\tdo_test(vm86, vmcode_umip - vmcode, VM86_TRAP, 3, \"UMIP tests\");\n\n\t \n\tmsw1 = *(unsigned short *)(test_mem + 2052);\n\tmemcpy(&idt1, test_mem + 2054, sizeof(idt1));\n\tmemcpy(&gdt1, test_mem + 2060, sizeof(gdt1));\n\n\t \n\tmsw2 = *(unsigned short *)(test_mem + 2066);\n\tmemcpy(&idt2, test_mem + 2068, sizeof(idt2));\n\tmemcpy(&gdt2, test_mem + 2074, sizeof(gdt2));\n\n\t \n\tmsw3 = *(unsigned short *)(test_mem + 2080);\n\n\tprintf(\"[INFO]\\tResult from SMSW:[0x%04x]\\n\", msw1);\n\tprintf(\"[INFO]\\tResult from SIDT: limit[0x%04x]base[0x%08lx]\\n\",\n\t       idt1.limit, idt1.base);\n\tprintf(\"[INFO]\\tResult from SGDT: limit[0x%04x]base[0x%08lx]\\n\",\n\t       gdt1.limit, gdt1.base);\n\n\tif (msw1 != msw2 || msw1 != msw3)\n\t\tprintf(\"[FAIL]\\tAll the results of SMSW should be the same.\\n\");\n\telse\n\t\tprintf(\"[PASS]\\tAll the results from SMSW are identical.\\n\");\n\n\tif (memcmp(&gdt1, &gdt2, sizeof(gdt1)))\n\t\tprintf(\"[FAIL]\\tAll the results of SGDT should be the same.\\n\");\n\telse\n\t\tprintf(\"[PASS]\\tAll the results from SGDT are identical.\\n\");\n\n\tif (memcmp(&idt1, &idt2, sizeof(idt1)))\n\t\tprintf(\"[FAIL]\\tAll the results of SIDT should be the same.\\n\");\n\telse\n\t\tprintf(\"[PASS]\\tAll the results from SIDT are identical.\\n\");\n\n\tsethandler(SIGILL, sighandler, 0);\n\tdo_test(vm86, vmcode_umip_str - vmcode, VM86_SIGNAL, 0,\n\t\t\"STR instruction\");\n\tclearhandler(SIGILL);\n\n\tsethandler(SIGILL, sighandler, 0);\n\tdo_test(vm86, vmcode_umip_sldt - vmcode, VM86_SIGNAL, 0,\n\t\t\"SLDT instruction\");\n\tclearhandler(SIGILL);\n}\n\nint main(void)\n{\n\tstruct vm86plus_struct v86;\n\tunsigned char *addr = mmap((void *)load_addr, 4096,\n\t\t\t\t   PROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t\t   MAP_ANONYMOUS | MAP_PRIVATE, -1,0);\n\tif (addr != (unsigned char *)load_addr)\n\t\terr(1, \"mmap\");\n\n\tmemcpy(addr, vmcode, end_vmcode - vmcode);\n\taddr[2048] = 2;\n\taddr[2050] = 3;\n\n\tmemset(&v86, 0, sizeof(v86));\n\n\tv86.regs.cs = load_addr / 16;\n\tv86.regs.ss = load_addr / 16;\n\tv86.regs.ds = load_addr / 16;\n\tv86.regs.es = load_addr / 16;\n\n\t \n\tv86.regs.esp = 4096;\n\n\tassert((v86.regs.cs & 3) == 0);\t \n\n\t \n\tdo_test(&v86, vmcode_bound - vmcode, VM86_INTx, 5, \"#BR\");\n\n\t \n\tsethandler(SIGILL, sighandler, 0);\n\tdo_test(&v86, vmcode_sysenter - vmcode, -1, 0, \"SYSENTER\");\n\tclearhandler(SIGILL);\n\n\t \n\tsethandler(SIGILL, sighandler, 0);\n\tdo_test(&v86, vmcode_syscall - vmcode, VM86_SIGNAL, 0, \"SYSCALL\");\n\tclearhandler(SIGILL);\n\n\t \n\tv86.regs.eflags |= X86_EFLAGS_VIP;\n\tv86.regs.eflags &= ~X86_EFLAGS_IF;\n\tdo_test(&v86, vmcode_sti - vmcode, VM86_STI, 0, \"STI with VIP set\");\n\n\t \n\tv86.regs.eflags = X86_EFLAGS_VIP;\n\tv86.regs.eax = 0;\n\tdo_test(&v86, vmcode_popf_hlt - vmcode, VM86_UNKNOWN, 0, \"POPF with VIP set and IF clear\");\n\n\t \n\tv86.regs.eflags = X86_EFLAGS_VIP;\n\tv86.regs.eax = X86_EFLAGS_IF;\n\tdo_test(&v86, vmcode_popf_hlt - vmcode, VM86_STI, 0, \"POPF with VIP and IF set\");\n\n\t \n\tv86.regs.eflags = 0;\n\tv86.regs.eax = X86_EFLAGS_IF;\n\tdo_test(&v86, vmcode_popf_hlt - vmcode, VM86_UNKNOWN, 0, \"POPF with VIP clear and IF set\");\n\n\tv86.regs.eflags = 0;\n\n\t \n\tdo_test(&v86, vmcode_int3 - vmcode, VM86_TRAP, 3, \"INT3\");\n\n\t \n\tv86.regs.eax = (unsigned int)-1;\n\tdo_test(&v86, vmcode_int80 - vmcode, VM86_INTx, 0x80, \"int80\");\n\n\t \n\tdo_umip_tests(&v86, addr);\n\n\t \n\tv86.regs.cs = 0;\n\tv86.regs.ss = 0;\n\tsethandler(SIGSEGV, sighandler, 0);\n\tgot_signal = 0;\n\tif (do_test(&v86, 0, VM86_SIGNAL, 0, \"Execute null pointer\") &&\n\t    !got_signal) {\n\t\tprintf(\"[FAIL]\\tDid not receive SIGSEGV\\n\");\n\t\tnerrs++;\n\t}\n\tclearhandler(SIGSEGV);\n\n\t \n\tif (fork() == 0)\n\t\treturn 0;\n\n\treturn (nerrs == 0 ? 0 : 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}