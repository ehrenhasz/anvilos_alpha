{
  "module_name": "ldt_gdt.c",
  "hash_id": "d30dfad376cafc1819f555fb2e07e5bcc2a7f5e724764c6aecfc4e6cb1b8f9a0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/ldt_gdt.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <err.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <signal.h>\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <asm/ldt.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <sched.h>\n#include <linux/futex.h>\n#include <sys/mman.h>\n#include <asm/prctl.h>\n#include <sys/prctl.h>\n\n#define AR_ACCESSED\t\t(1<<8)\n\n#define AR_TYPE_RODATA\t\t(0 * (1<<9))\n#define AR_TYPE_RWDATA\t\t(1 * (1<<9))\n#define AR_TYPE_RODATA_EXPDOWN\t(2 * (1<<9))\n#define AR_TYPE_RWDATA_EXPDOWN\t(3 * (1<<9))\n#define AR_TYPE_XOCODE\t\t(4 * (1<<9))\n#define AR_TYPE_XRCODE\t\t(5 * (1<<9))\n#define AR_TYPE_XOCODE_CONF\t(6 * (1<<9))\n#define AR_TYPE_XRCODE_CONF\t(7 * (1<<9))\n\n#define AR_DPL3\t\t\t(3 * (1<<13))\n\n#define AR_S\t\t\t(1 << 12)\n#define AR_P\t\t\t(1 << 15)\n#define AR_AVL\t\t\t(1 << 20)\n#define AR_L\t\t\t(1 << 21)\n#define AR_DB\t\t\t(1 << 22)\n#define AR_G\t\t\t(1 << 23)\n\n#ifdef __x86_64__\n# define INT80_CLOBBERS \"r8\", \"r9\", \"r10\", \"r11\"\n#else\n# define INT80_CLOBBERS\n#endif\n\nstatic int nerrs;\n\n \nstatic const unsigned int *counter_page;\nstatic struct user_desc *low_user_desc;\nstatic struct user_desc *low_user_desc_clear;   \nstatic int gdt_entry_num;\n\nstatic void check_invalid_segment(uint16_t index, int ldt)\n{\n\tuint32_t has_limit = 0, has_ar = 0, limit, ar;\n\tuint32_t selector = (index << 3) | (ldt << 2) | 3;\n\n\tasm (\"lsl %[selector], %[limit]\\n\\t\"\n\t     \"jnz 1f\\n\\t\"\n\t     \"movl $1, %[has_limit]\\n\\t\"\n\t     \"1:\"\n\t     : [limit] \"=r\" (limit), [has_limit] \"+rm\" (has_limit)\n\t     : [selector] \"r\" (selector));\n\tasm (\"larl %[selector], %[ar]\\n\\t\"\n\t     \"jnz 1f\\n\\t\"\n\t     \"movl $1, %[has_ar]\\n\\t\"\n\t     \"1:\"\n\t     : [ar] \"=r\" (ar), [has_ar] \"+rm\" (has_ar)\n\t     : [selector] \"r\" (selector));\n\n\tif (has_limit || has_ar) {\n\t\tprintf(\"[FAIL]\\t%s entry %hu is valid but should be invalid\\n\",\n\t\t       (ldt ? \"LDT\" : \"GDT\"), index);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\t%s entry %hu is invalid\\n\",\n\t\t       (ldt ? \"LDT\" : \"GDT\"), index);\n\t}\n}\n\nstatic void check_valid_segment(uint16_t index, int ldt,\n\t\t\t\tuint32_t expected_ar, uint32_t expected_limit,\n\t\t\t\tbool verbose)\n{\n\tuint32_t has_limit = 0, has_ar = 0, limit, ar;\n\tuint32_t selector = (index << 3) | (ldt << 2) | 3;\n\n\tasm (\"lsl %[selector], %[limit]\\n\\t\"\n\t     \"jnz 1f\\n\\t\"\n\t     \"movl $1, %[has_limit]\\n\\t\"\n\t     \"1:\"\n\t     : [limit] \"=r\" (limit), [has_limit] \"+rm\" (has_limit)\n\t     : [selector] \"r\" (selector));\n\tasm (\"larl %[selector], %[ar]\\n\\t\"\n\t     \"jnz 1f\\n\\t\"\n\t     \"movl $1, %[has_ar]\\n\\t\"\n\t     \"1:\"\n\t     : [ar] \"=r\" (ar), [has_ar] \"+rm\" (has_ar)\n\t     : [selector] \"r\" (selector));\n\n\tif (!has_limit || !has_ar) {\n\t\tprintf(\"[FAIL]\\t%s entry %hu is invalid but should be valid\\n\",\n\t\t       (ldt ? \"LDT\" : \"GDT\"), index);\n\t\tnerrs++;\n\t\treturn;\n\t}\n\n\t \n\tar &= ~0xF0000;\n\n\t \n\tif (ar != expected_ar && ar != (expected_ar | AR_ACCESSED)) {\n\t\tprintf(\"[FAIL]\\t%s entry %hu has AR 0x%08X but expected 0x%08X\\n\",\n\t\t       (ldt ? \"LDT\" : \"GDT\"), index, ar, expected_ar);\n\t\tnerrs++;\n\t} else if (limit != expected_limit) {\n\t\tprintf(\"[FAIL]\\t%s entry %hu has limit 0x%08X but expected 0x%08X\\n\",\n\t\t       (ldt ? \"LDT\" : \"GDT\"), index, limit, expected_limit);\n\t\tnerrs++;\n\t} else if (verbose) {\n\t\tprintf(\"[OK]\\t%s entry %hu has AR 0x%08X and limit 0x%08X\\n\",\n\t\t       (ldt ? \"LDT\" : \"GDT\"), index, ar, limit);\n\t}\n}\n\nstatic bool install_valid_mode(const struct user_desc *d, uint32_t ar,\n\t\t\t       bool oldmode, bool ldt)\n{\n\tstruct user_desc desc = *d;\n\tint ret;\n\n\tif (!ldt) {\n#ifndef __i386__\n\t\t \n\t\treturn false;\n#endif\n\t\tif (!gdt_entry_num)\n\t\t\treturn false;\n\t\tdesc.entry_number = gdt_entry_num;\n\n\t\tret = syscall(SYS_set_thread_area, &desc);\n\t} else {\n\t\tret = syscall(SYS_modify_ldt, oldmode ? 1 : 0x11,\n\t\t\t      &desc, sizeof(desc));\n\n\t\tif (ret < -1)\n\t\t\terrno = -ret;\n\n\t\tif (ret != 0 && errno == ENOSYS) {\n\t\t\tprintf(\"[OK]\\tmodify_ldt returned -ENOSYS\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (ret == 0) {\n\t\tuint32_t limit = desc.limit;\n\t\tif (desc.limit_in_pages)\n\t\t\tlimit = (limit << 12) + 4095;\n\t\tcheck_valid_segment(desc.entry_number, ldt, ar, limit, true);\n\t\treturn true;\n\t} else {\n\t\tif (desc.seg_32bit) {\n\t\t\tprintf(\"[FAIL]\\tUnexpected %s failure %d\\n\",\n\t\t\t       ldt ? \"modify_ldt\" : \"set_thread_area\",\n\t\t\t       errno);\n\t\t\tnerrs++;\n\t\t\treturn false;\n\t\t} else {\n\t\t\tprintf(\"[OK]\\t%s rejected 16 bit segment\\n\",\n\t\t\t       ldt ? \"modify_ldt\" : \"set_thread_area\");\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nstatic bool install_valid(const struct user_desc *desc, uint32_t ar)\n{\n\tbool ret = install_valid_mode(desc, ar, false, true);\n\n\tif (desc->contents <= 1 && desc->seg_32bit &&\n\t    !desc->seg_not_present) {\n\t\t \n\t\tinstall_valid_mode(desc, ar, false, false);\n\t}\n\n\treturn ret;\n}\n\nstatic void install_invalid(const struct user_desc *desc, bool oldmode)\n{\n\tint ret = syscall(SYS_modify_ldt, oldmode ? 1 : 0x11,\n\t\t\t  desc, sizeof(*desc));\n\tif (ret < -1)\n\t\terrno = -ret;\n\tif (ret == 0) {\n\t\tcheck_invalid_segment(desc->entry_number, 1);\n\t} else if (errno == ENOSYS) {\n\t\tprintf(\"[OK]\\tmodify_ldt returned -ENOSYS\\n\");\n\t} else {\n\t\tif (desc->seg_32bit) {\n\t\t\tprintf(\"[FAIL]\\tUnexpected modify_ldt failure %d\\n\",\n\t\t\t       errno);\n\t\t\tnerrs++;\n\t\t} else {\n\t\t\tprintf(\"[OK]\\tmodify_ldt rejected 16 bit segment\\n\");\n\t\t}\n\t}\n}\n\nstatic int safe_modify_ldt(int func, struct user_desc *ptr,\n\t\t\t   unsigned long bytecount)\n{\n\tint ret = syscall(SYS_modify_ldt, 0x11, ptr, bytecount);\n\tif (ret < -1)\n\t\terrno = -ret;\n\treturn ret;\n}\n\nstatic void fail_install(struct user_desc *desc)\n{\n\tif (safe_modify_ldt(0x11, desc, sizeof(*desc)) == 0) {\n\t\tprintf(\"[FAIL]\\tmodify_ldt accepted a bad descriptor\\n\");\n\t\tnerrs++;\n\t} else if (errno == ENOSYS) {\n\t\tprintf(\"[OK]\\tmodify_ldt returned -ENOSYS\\n\");\n\t} else {\n\t\tprintf(\"[OK]\\tmodify_ldt failure %d\\n\", errno);\n\t}\n}\n\nstatic void do_simple_tests(void)\n{\n\tstruct user_desc desc = {\n\t\t.entry_number    = 0,\n\t\t.base_addr       = 0,\n\t\t.limit           = 10,\n\t\t.seg_32bit       = 1,\n\t\t.contents        = 2,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 0,\n\t\t.seg_not_present = 0,\n\t\t.useable         = 0\n\t};\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE | AR_S | AR_P | AR_DB);\n\n\tdesc.limit_in_pages = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE |\n\t\t      AR_S | AR_P | AR_DB | AR_G);\n\n\tcheck_invalid_segment(1, 1);\n\n\tdesc.entry_number = 2;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE |\n\t\t      AR_S | AR_P | AR_DB | AR_G);\n\n\tcheck_invalid_segment(1, 1);\n\n\tdesc.base_addr = 0xf0000000;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE |\n\t\t      AR_S | AR_P | AR_DB | AR_G);\n\n\tdesc.useable = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE |\n\t\t      AR_S | AR_P | AR_DB | AR_G | AR_AVL);\n\n\tdesc.seg_not_present = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE |\n\t\t      AR_S | AR_DB | AR_G | AR_AVL);\n\n\tdesc.seg_32bit = 0;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE |\n\t\t      AR_S | AR_G | AR_AVL);\n\n\tdesc.seg_32bit = 1;\n\tdesc.contents = 0;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RWDATA |\n\t\t      AR_S | AR_DB | AR_G | AR_AVL);\n\n\tdesc.read_exec_only = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RODATA |\n\t\t      AR_S | AR_DB | AR_G | AR_AVL);\n\n\tdesc.contents = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RODATA_EXPDOWN |\n\t\t      AR_S | AR_DB | AR_G | AR_AVL);\n\n\tdesc.read_exec_only = 0;\n\tdesc.limit_in_pages = 0;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RWDATA_EXPDOWN |\n\t\t      AR_S | AR_DB | AR_AVL);\n\n\tdesc.contents = 3;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE_CONF |\n\t\t      AR_S | AR_DB | AR_AVL);\n\n\tdesc.read_exec_only = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XOCODE_CONF |\n\t\t      AR_S | AR_DB | AR_AVL);\n\n\tdesc.read_exec_only = 0;\n\tdesc.contents = 2;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE |\n\t\t      AR_S | AR_DB | AR_AVL);\n\n\tdesc.read_exec_only = 1;\n\n#ifdef __x86_64__\n\tdesc.lm = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XOCODE |\n\t\t      AR_S | AR_DB | AR_AVL);\n\tdesc.lm = 0;\n#endif\n\n\tbool entry1_okay = install_valid(&desc, AR_DPL3 | AR_TYPE_XOCODE |\n\t\t\t\t\t AR_S | AR_DB | AR_AVL);\n\n\tif (entry1_okay) {\n\t\tprintf(\"[RUN]\\tTest fork\\n\");\n\t\tpid_t child = fork();\n\t\tif (child == 0) {\n\t\t\tnerrs = 0;\n\t\t\tcheck_valid_segment(desc.entry_number, 1,\n\t\t\t\t\t    AR_DPL3 | AR_TYPE_XOCODE |\n\t\t\t\t\t    AR_S | AR_DB | AR_AVL, desc.limit,\n\t\t\t\t\t    true);\n\t\t\tcheck_invalid_segment(1, 1);\n\t\t\texit(nerrs ? 1 : 0);\n\t\t} else {\n\t\t\tint status;\n\t\t\tif (waitpid(child, &status, 0) != child ||\n\t\t\t    !WIFEXITED(status)) {\n\t\t\t\tprintf(\"[FAIL]\\tChild died\\n\");\n\t\t\t\tnerrs++;\n\t\t\t} else if (WEXITSTATUS(status) != 0) {\n\t\t\t\tprintf(\"[FAIL]\\tChild failed\\n\");\n\t\t\t\tnerrs++;\n\t\t\t} else {\n\t\t\t\tprintf(\"[OK]\\tChild succeeded\\n\");\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"[RUN]\\tTest size\\n\");\n\t\tint i;\n\t\tfor (i = 0; i < 8192; i++) {\n\t\t\tdesc.entry_number = i;\n\t\t\tdesc.limit = i;\n\t\t\tif (safe_modify_ldt(0x11, &desc, sizeof(desc)) != 0) {\n\t\t\t\tprintf(\"[FAIL]\\tFailed to install entry %d\\n\", i);\n\t\t\t\tnerrs++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tcheck_valid_segment(j, 1, AR_DPL3 | AR_TYPE_XOCODE |\n\t\t\t\t\t    AR_S | AR_DB | AR_AVL, j, false);\n\t\t}\n\t\tprintf(\"[DONE]\\tSize test\\n\");\n\t} else {\n\t\tprintf(\"[SKIP]\\tSkipping fork and size tests because we have no LDT\\n\");\n\t}\n\n\t \n\tdesc.entry_number = 8192;\n\tfail_install(&desc);\n\n\t \n\tmemset(&desc, 0, sizeof(desc));\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RWDATA | AR_S | AR_P);\n\n\tdesc.seg_not_present = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RWDATA | AR_S);\n\n\tdesc.seg_not_present = 0;\n\tdesc.read_exec_only = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RODATA | AR_S | AR_P);\n\n\tdesc.read_exec_only = 0;\n\tdesc.seg_not_present = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RWDATA | AR_S);\n\n\tdesc.read_exec_only = 1;\n\tdesc.limit = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RODATA | AR_S);\n\n\tdesc.limit = 0;\n\tdesc.base_addr = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RODATA | AR_S);\n\n\tdesc.base_addr = 0;\n\tinstall_invalid(&desc, false);\n\n\tdesc.seg_not_present = 0;\n\tdesc.seg_32bit = 1;\n\tdesc.read_exec_only = 0;\n\tdesc.limit = 0xfffff;\n\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RWDATA | AR_S | AR_P | AR_DB);\n\n\tdesc.limit_in_pages = 1;\n\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RWDATA | AR_S | AR_P | AR_DB | AR_G);\n\tdesc.read_exec_only = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RODATA | AR_S | AR_P | AR_DB | AR_G);\n\tdesc.contents = 1;\n\tdesc.read_exec_only = 0;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RWDATA_EXPDOWN | AR_S | AR_P | AR_DB | AR_G);\n\tdesc.read_exec_only = 1;\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_RODATA_EXPDOWN | AR_S | AR_P | AR_DB | AR_G);\n\n\tdesc.limit = 0;\n\tinstall_invalid(&desc, true);\n}\n\n \nstatic volatile unsigned int ftx;\n\nstatic void *threadproc(void *ctx)\n{\n\tcpu_set_t cpuset;\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(1, &cpuset);\n\tif (sched_setaffinity(0, sizeof(cpuset), &cpuset) != 0)\n\t\terr(1, \"sched_setaffinity to CPU 1\");\t \n\n\twhile (1) {\n\t\tsyscall(SYS_futex, &ftx, FUTEX_WAIT, 0, NULL, NULL, 0);\n\t\twhile (ftx != 2) {\n\t\t\tif (ftx >= 3)\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tconst struct user_desc desc = {};\n\t\tif (syscall(SYS_modify_ldt, 1, &desc, sizeof(desc)) != 0)\n\t\t\terr(1, \"modify_ldt\");\n\n\t\t \n\t\tunsigned int x = -2;\n\t\tasm volatile (\"lock xaddl %[x], %[ftx]\" :\n\t\t\t      [x] \"+r\" (x), [ftx] \"+m\" (ftx));\n\t\tif (x != 2)\n\t\t\treturn NULL;\n\t}\n}\n\n#ifdef __i386__\n\n#ifndef SA_RESTORE\n#define SA_RESTORER 0x04000000\n#endif\n\n \nstruct fake_ksigaction {\n\tvoid *handler;   \n\tunsigned long sa_flags;\n\tvoid (*sa_restorer)(void);\n\tunsigned char sigset[8];\n};\n\nstatic void fix_sa_restorer(int sig)\n{\n\tstruct fake_ksigaction ksa;\n\n\tif (syscall(SYS_rt_sigaction, sig, NULL, &ksa, 8) == 0) {\n\t\t \n\t\tif (!(ksa.sa_flags & SA_RESTORER) && ksa.sa_restorer) {\n\t\t\tksa.sa_restorer = NULL;\n\t\t\tif (syscall(SYS_rt_sigaction, sig, &ksa, NULL,\n\t\t\t\t    sizeof(ksa.sigset)) != 0)\n\t\t\t\terr(1, \"rt_sigaction\");\n\t\t}\n\t}\n}\n#else\nstatic void fix_sa_restorer(int sig)\n{\n\t \n}\n#endif\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n\n\tfix_sa_restorer(sig);\n}\n\nstatic jmp_buf jmpbuf;\n\nstatic void sigsegv(int sig, siginfo_t *info, void *ctx_void)\n{\n\tsiglongjmp(jmpbuf, 1);\n}\n\nstatic void do_multicpu_tests(void)\n{\n\tcpu_set_t cpuset;\n\tpthread_t thread;\n\tint failures = 0, iters = 5, i;\n\tunsigned short orig_ss;\n\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(1, &cpuset);\n\tif (sched_setaffinity(0, sizeof(cpuset), &cpuset) != 0) {\n\t\tprintf(\"[SKIP]\\tCannot set affinity to CPU 1\\n\");\n\t\treturn;\n\t}\n\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(0, &cpuset);\n\tif (sched_setaffinity(0, sizeof(cpuset), &cpuset) != 0) {\n\t\tprintf(\"[SKIP]\\tCannot set affinity to CPU 0\\n\");\n\t\treturn;\n\t}\n\n\tsethandler(SIGSEGV, sigsegv, 0);\n#ifdef __i386__\n\t \n\tsethandler(SIGILL, sigsegv, 0);\n#endif\n\n\tprintf(\"[RUN]\\tCross-CPU LDT invalidation\\n\");\n\n\tif (pthread_create(&thread, 0, threadproc, 0) != 0)\n\t\terr(1, \"pthread_create\");\n\n\tasm volatile (\"mov %%ss, %0\" : \"=rm\" (orig_ss));\n\n\tfor (i = 0; i < 5; i++) {\n\t\tif (sigsetjmp(jmpbuf, 1) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\twhile (ftx != 0)\n\t\t\t;\n\n\t\tstruct user_desc desc = {\n\t\t\t.entry_number    = 0,\n\t\t\t.base_addr       = 0,\n\t\t\t.limit           = 0xfffff,\n\t\t\t.seg_32bit       = 1,\n\t\t\t.contents        = 0,  \n\t\t\t.read_exec_only  = 0,\n\t\t\t.limit_in_pages  = 1,\n\t\t\t.seg_not_present = 0,\n\t\t\t.useable         = 0\n\t\t};\n\n\t\tif (safe_modify_ldt(0x11, &desc, sizeof(desc)) != 0) {\n\t\t\tif (errno != ENOSYS)\n\t\t\t\terr(1, \"modify_ldt\");\n\t\t\tprintf(\"[SKIP]\\tmodify_ldt unavailable\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tftx = 1;\n\t\tsyscall(SYS_futex, &ftx, FUTEX_WAKE, 0, NULL, NULL, 0);\n\n\t\tasm volatile (\"mov %0, %%ss\" : : \"r\" (0x7));\n\n\t\t \n\t\tftx = 2;\n\n\t\twhile (ftx != 0)\n\t\t\t;\n\n\t\t \n\n\t\tfailures++;\n\t\tasm volatile (\"mov %0, %%ss\" : : \"rm\" (orig_ss));\n\t}\n\n\tftx = 100;   \n\tsyscall(SYS_futex, &ftx, FUTEX_WAKE, 0, NULL, NULL, 0);\n\n\tif (pthread_join(thread, NULL) != 0)\n\t\terr(1, \"pthread_join\");\n\n\tif (failures) {\n\t\tprintf(\"[FAIL]\\t%d of %d iterations failed\\n\", failures, iters);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tAll %d iterations succeeded\\n\", iters);\n\t}\n}\n\nstatic int finish_exec_test(void)\n{\n\t \n\tcheck_invalid_segment(0, 1);\n\n\treturn nerrs ? 1 : 0;\n}\n\nstatic void do_exec_test(void)\n{\n\tprintf(\"[RUN]\\tTest exec\\n\");\n\n\tstruct user_desc desc = {\n\t\t.entry_number    = 0,\n\t\t.base_addr       = 0,\n\t\t.limit           = 42,\n\t\t.seg_32bit       = 1,\n\t\t.contents        = 2,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 0,\n\t\t.seg_not_present = 0,\n\t\t.useable         = 0\n\t};\n\tinstall_valid(&desc, AR_DPL3 | AR_TYPE_XRCODE | AR_S | AR_P | AR_DB);\n\n\tpid_t child = fork();\n\tif (child == 0) {\n\t\texecl(\"/proc/self/exe\", \"ldt_gdt_test_exec\", NULL);\n\t\tprintf(\"[FAIL]\\tCould not exec self\\n\");\n\t\texit(1);\t \n\t} else {\n\t\tint status;\n\t\tif (waitpid(child, &status, 0) != child ||\n\t\t    !WIFEXITED(status)) {\n\t\t\tprintf(\"[FAIL]\\tChild died\\n\");\n\t\t\tnerrs++;\n\t\t} else if (WEXITSTATUS(status) != 0) {\n\t\t\tprintf(\"[FAIL]\\tChild failed\\n\");\n\t\t\tnerrs++;\n\t\t} else {\n\t\t\tprintf(\"[OK]\\tChild succeeded\\n\");\n\t\t}\n\t}\n}\n\nstatic void setup_counter_page(void)\n{\n\tunsigned int *page = mmap(NULL, 4096, PROT_READ | PROT_WRITE,\n\t\t\t MAP_ANONYMOUS | MAP_PRIVATE | MAP_32BIT, -1, 0);\n\tif (page == MAP_FAILED)\n\t\terr(1, \"mmap\");\n\n\tfor (int i = 0; i < 1024; i++)\n\t\tpage[i] = i;\n\tcounter_page = page;\n}\n\nstatic int invoke_set_thread_area(void)\n{\n\tint ret;\n\tasm volatile (\"int $0x80\"\n\t\t      : \"=a\" (ret), \"+m\" (low_user_desc) :\n\t\t\t\"a\" (243), \"b\" (low_user_desc)\n\t\t      : INT80_CLOBBERS);\n\treturn ret;\n}\n\nstatic void setup_low_user_desc(void)\n{\n\tlow_user_desc = mmap(NULL, 2 * sizeof(struct user_desc),\n\t\t\t     PROT_READ | PROT_WRITE,\n\t\t\t     MAP_ANONYMOUS | MAP_PRIVATE | MAP_32BIT, -1, 0);\n\tif (low_user_desc == MAP_FAILED)\n\t\terr(1, \"mmap\");\n\n\tlow_user_desc->entry_number\t= -1;\n\tlow_user_desc->base_addr\t= (unsigned long)&counter_page[1];\n\tlow_user_desc->limit\t\t= 0xfffff;\n\tlow_user_desc->seg_32bit\t= 1;\n\tlow_user_desc->contents\t\t= 0;  \n\tlow_user_desc->read_exec_only\t= 0;\n\tlow_user_desc->limit_in_pages\t= 1;\n\tlow_user_desc->seg_not_present\t= 0;\n\tlow_user_desc->useable\t\t= 0;\n\n\tif (invoke_set_thread_area() == 0) {\n\t\tgdt_entry_num = low_user_desc->entry_number;\n\t\tprintf(\"[NOTE]\\tset_thread_area is available; will use GDT index %d\\n\", gdt_entry_num);\n\t} else {\n\t\tprintf(\"[NOTE]\\tset_thread_area is unavailable\\n\");\n\t}\n\n\tlow_user_desc_clear = low_user_desc + 1;\n\tlow_user_desc_clear->entry_number = gdt_entry_num;\n\tlow_user_desc_clear->read_exec_only = 1;\n\tlow_user_desc_clear->seg_not_present = 1;\n}\n\nstatic void test_gdt_invalidation(void)\n{\n\tif (!gdt_entry_num)\n\t\treturn;\t \n\n\tunsigned short prev_sel;\n\tunsigned short sel;\n\tunsigned int eax;\n\tconst char *result;\n#ifdef __x86_64__\n\tunsigned long saved_base;\n\tunsigned long new_base;\n#endif\n\n\t \n\tinvoke_set_thread_area();\n\teax = 243;\n\tsel = (gdt_entry_num << 3) | 3;\n\tasm volatile (\"movw %%ds, %[prev_sel]\\n\\t\"\n\t\t      \"movw %[sel], %%ds\\n\\t\"\n#ifdef __i386__\n\t\t      \"pushl %%ebx\\n\\t\"\n#endif\n\t\t      \"movl %[arg1], %%ebx\\n\\t\"\n\t\t      \"int $0x80\\n\\t\"\t \n#ifdef __i386__\n\t\t      \"popl %%ebx\\n\\t\"\n#endif\n\t\t      \"movw %%ds, %[sel]\\n\\t\"\n\t\t      \"movw %[prev_sel], %%ds\"\n\t\t      : [prev_sel] \"=&r\" (prev_sel), [sel] \"+r\" (sel),\n\t\t\t\"+a\" (eax)\n\t\t      : \"m\" (low_user_desc_clear),\n\t\t\t[arg1] \"r\" ((unsigned int)(unsigned long)low_user_desc_clear)\n\t\t      : INT80_CLOBBERS);\n\n\tif (sel != 0) {\n\t\tresult = \"FAIL\";\n\t\tnerrs++;\n\t} else {\n\t\tresult = \"OK\";\n\t}\n\tprintf(\"[%s]\\tInvalidate DS with set_thread_area: new DS = 0x%hx\\n\",\n\t       result, sel);\n\n\t \n\tinvoke_set_thread_area();\n\teax = 243;\n\tsel = (gdt_entry_num << 3) | 3;\n\tasm volatile (\"movw %%es, %[prev_sel]\\n\\t\"\n\t\t      \"movw %[sel], %%es\\n\\t\"\n#ifdef __i386__\n\t\t      \"pushl %%ebx\\n\\t\"\n#endif\n\t\t      \"movl %[arg1], %%ebx\\n\\t\"\n\t\t      \"int $0x80\\n\\t\"\t \n#ifdef __i386__\n\t\t      \"popl %%ebx\\n\\t\"\n#endif\n\t\t      \"movw %%es, %[sel]\\n\\t\"\n\t\t      \"movw %[prev_sel], %%es\"\n\t\t      : [prev_sel] \"=&r\" (prev_sel), [sel] \"+r\" (sel),\n\t\t\t\"+a\" (eax)\n\t\t      : \"m\" (low_user_desc_clear),\n\t\t\t[arg1] \"r\" ((unsigned int)(unsigned long)low_user_desc_clear)\n\t\t      : INT80_CLOBBERS);\n\n\tif (sel != 0) {\n\t\tresult = \"FAIL\";\n\t\tnerrs++;\n\t} else {\n\t\tresult = \"OK\";\n\t}\n\tprintf(\"[%s]\\tInvalidate ES with set_thread_area: new ES = 0x%hx\\n\",\n\t       result, sel);\n\n\t \n\tinvoke_set_thread_area();\n\teax = 243;\n\tsel = (gdt_entry_num << 3) | 3;\n#ifdef __x86_64__\n\tsyscall(SYS_arch_prctl, ARCH_GET_FS, &saved_base);\n#endif\n\tasm volatile (\"movw %%fs, %[prev_sel]\\n\\t\"\n\t\t      \"movw %[sel], %%fs\\n\\t\"\n#ifdef __i386__\n\t\t      \"pushl %%ebx\\n\\t\"\n#endif\n\t\t      \"movl %[arg1], %%ebx\\n\\t\"\n\t\t      \"int $0x80\\n\\t\"\t \n#ifdef __i386__\n\t\t      \"popl %%ebx\\n\\t\"\n#endif\n\t\t      \"movw %%fs, %[sel]\\n\\t\"\n\t\t      : [prev_sel] \"=&r\" (prev_sel), [sel] \"+r\" (sel),\n\t\t\t\"+a\" (eax)\n\t\t      : \"m\" (low_user_desc_clear),\n\t\t\t[arg1] \"r\" ((unsigned int)(unsigned long)low_user_desc_clear)\n\t\t      : INT80_CLOBBERS);\n\n#ifdef __x86_64__\n\tsyscall(SYS_arch_prctl, ARCH_GET_FS, &new_base);\n#endif\n\n\t \n\tasm volatile (\"movw %[prev_sel], %%fs\" : : [prev_sel] \"rm\" (prev_sel));\n#ifdef __x86_64__\n\tif (saved_base)\n\t\tsyscall(SYS_arch_prctl, ARCH_SET_FS, saved_base);\n#endif\n\n\tif (sel != 0) {\n\t\tresult = \"FAIL\";\n\t\tnerrs++;\n\t} else {\n\t\tresult = \"OK\";\n\t}\n\tprintf(\"[%s]\\tInvalidate FS with set_thread_area: new FS = 0x%hx\\n\",\n\t       result, sel);\n\n#ifdef __x86_64__\n\tif (sel == 0 && new_base != 0) {\n\t\tnerrs++;\n\t\tprintf(\"[FAIL]\\tNew FSBASE was 0x%lx\\n\", new_base);\n\t} else {\n\t\tprintf(\"[OK]\\tNew FSBASE was zero\\n\");\n\t}\n#endif\n\n\t \n\tinvoke_set_thread_area();\n\teax = 243;\n\tsel = (gdt_entry_num << 3) | 3;\n#ifdef __x86_64__\n\tsyscall(SYS_arch_prctl, ARCH_GET_GS, &saved_base);\n#endif\n\tasm volatile (\"movw %%gs, %[prev_sel]\\n\\t\"\n\t\t      \"movw %[sel], %%gs\\n\\t\"\n#ifdef __i386__\n\t\t      \"pushl %%ebx\\n\\t\"\n#endif\n\t\t      \"movl %[arg1], %%ebx\\n\\t\"\n\t\t      \"int $0x80\\n\\t\"\t \n#ifdef __i386__\n\t\t      \"popl %%ebx\\n\\t\"\n#endif\n\t\t      \"movw %%gs, %[sel]\\n\\t\"\n\t\t      : [prev_sel] \"=&r\" (prev_sel), [sel] \"+r\" (sel),\n\t\t\t\"+a\" (eax)\n\t\t      : \"m\" (low_user_desc_clear),\n\t\t\t[arg1] \"r\" ((unsigned int)(unsigned long)low_user_desc_clear)\n\t\t      : INT80_CLOBBERS);\n\n#ifdef __x86_64__\n\tsyscall(SYS_arch_prctl, ARCH_GET_GS, &new_base);\n#endif\n\n\t \n\tasm volatile (\"movw %[prev_sel], %%gs\" : : [prev_sel] \"rm\" (prev_sel));\n#ifdef __x86_64__\n\tif (saved_base)\n\t\tsyscall(SYS_arch_prctl, ARCH_SET_GS, saved_base);\n#endif\n\n\tif (sel != 0) {\n\t\tresult = \"FAIL\";\n\t\tnerrs++;\n\t} else {\n\t\tresult = \"OK\";\n\t}\n\tprintf(\"[%s]\\tInvalidate GS with set_thread_area: new GS = 0x%hx\\n\",\n\t       result, sel);\n\n#ifdef __x86_64__\n\tif (sel == 0 && new_base != 0) {\n\t\tnerrs++;\n\t\tprintf(\"[FAIL]\\tNew GSBASE was 0x%lx\\n\", new_base);\n\t} else {\n\t\tprintf(\"[OK]\\tNew GSBASE was zero\\n\");\n\t}\n#endif\n}\n\nint main(int argc, char **argv)\n{\n\tif (argc == 1 && !strcmp(argv[0], \"ldt_gdt_test_exec\"))\n\t\treturn finish_exec_test();\n\n\tsetup_counter_page();\n\tsetup_low_user_desc();\n\n\tdo_simple_tests();\n\n\tdo_multicpu_tests();\n\n\tdo_exec_test();\n\n\ttest_gdt_invalidation();\n\n\treturn nerrs ? 1 : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}