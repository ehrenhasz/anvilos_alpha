{
  "module_name": "syscall_arg_fault.c",
  "hash_id": "0cba9c4d296acb3f59cc94f6c2e35cde033088db1d49af8496b41d7956cea783",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/syscall_arg_fault.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/signal.h>\n#include <sys/ucontext.h>\n#include <err.h>\n#include <setjmp.h>\n#include <errno.h>\n\n#include \"helpers.h\"\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic volatile sig_atomic_t sig_traps;\nstatic sigjmp_buf jmpbuf;\n\nstatic volatile sig_atomic_t n_errs;\n\n#ifdef __x86_64__\n#define REG_AX REG_RAX\n#define REG_IP REG_RIP\n#else\n#define REG_AX REG_EAX\n#define REG_IP REG_EIP\n#endif\n\nstatic void sigsegv_or_sigbus(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\tlong ax = (long)ctx->uc_mcontext.gregs[REG_AX];\n\n\tif (ax != -EFAULT && ax != -ENOSYS) {\n\t\tprintf(\"[FAIL]\\tAX had the wrong value: 0x%lx\\n\",\n\t\t       (unsigned long)ax);\n\t\tprintf(\"\\tIP = 0x%lx\\n\", (unsigned long)ctx->uc_mcontext.gregs[REG_IP]);\n\t\tn_errs++;\n\t} else {\n\t\tprintf(\"[OK]\\tSeems okay\\n\");\n\t}\n\n\tsiglongjmp(jmpbuf, 1);\n}\n\nstatic volatile sig_atomic_t sigtrap_consecutive_syscalls;\n\nstatic void sigtrap(int sig, siginfo_t *info, void *ctx_void)\n{\n\t \n\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\tunsigned short *ip = (unsigned short *)ctx->uc_mcontext.gregs[REG_IP];\n\n\tif (*ip == 0x340f || *ip == 0x050f) {\n\t\t \n\t\tsigtrap_consecutive_syscalls++;\n\t\tif (sigtrap_consecutive_syscalls > 3) {\n\t\t\tprintf(\"[WARN]\\tGot stuck single-stepping -- you probably have a KVM bug\\n\");\n\t\t\tsiglongjmp(jmpbuf, 1);\n\t\t}\n\t} else {\n\t\tsigtrap_consecutive_syscalls = 0;\n\t}\n}\n\nstatic void sigill(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\tunsigned short *ip = (unsigned short *)ctx->uc_mcontext.gregs[REG_IP];\n\n\tif (*ip == 0x0b0f) {\n\t\t \n\t\tprintf(\"[OK]\\tSYSCALL returned normally\\n\");\n\t} else {\n\t\tprintf(\"[SKIP]\\tIllegal instruction\\n\");\n\t}\n\tsiglongjmp(jmpbuf, 1);\n}\n\nint main()\n{\n\tstack_t stack = {\n\t\t \n\t\t.ss_sp = malloc(sizeof(char) * SIGSTKSZ),\n\t\t.ss_size = SIGSTKSZ,\n\t};\n\tif (sigaltstack(&stack, NULL) != 0)\n\t\terr(1, \"sigaltstack\");\n\n\tsethandler(SIGSEGV, sigsegv_or_sigbus, SA_ONSTACK);\n\t \n\tsethandler(SIGBUS, sigsegv_or_sigbus, SA_ONSTACK);\n\tsethandler(SIGILL, sigill, SA_ONSTACK);\n\n\t \n\n\tprintf(\"[RUN]\\tSYSENTER with invalid state\\n\");\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tasm volatile (\n\t\t\t\"movl $-1, %%eax\\n\\t\"\n\t\t\t\"movl $-1, %%ebx\\n\\t\"\n\t\t\t\"movl $-1, %%ecx\\n\\t\"\n\t\t\t\"movl $-1, %%edx\\n\\t\"\n\t\t\t\"movl $-1, %%esi\\n\\t\"\n\t\t\t\"movl $-1, %%edi\\n\\t\"\n\t\t\t\"movl $-1, %%ebp\\n\\t\"\n\t\t\t\"movl $-1, %%esp\\n\\t\"\n\t\t\t\"sysenter\"\n\t\t\t: : : \"memory\", \"flags\");\n\t}\n\n\tprintf(\"[RUN]\\tSYSCALL with invalid state\\n\");\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tasm volatile (\n\t\t\t\"movl $-1, %%eax\\n\\t\"\n\t\t\t\"movl $-1, %%ebx\\n\\t\"\n\t\t\t\"movl $-1, %%ecx\\n\\t\"\n\t\t\t\"movl $-1, %%edx\\n\\t\"\n\t\t\t\"movl $-1, %%esi\\n\\t\"\n\t\t\t\"movl $-1, %%edi\\n\\t\"\n\t\t\t\"movl $-1, %%ebp\\n\\t\"\n\t\t\t\"movl $-1, %%esp\\n\\t\"\n\t\t\t\"syscall\\n\\t\"\n\t\t\t\"ud2\"\t\t \n\t\t\t: : : \"memory\", \"flags\");\n\t}\n\n\tprintf(\"[RUN]\\tSYSENTER with TF and invalid state\\n\");\n\tsethandler(SIGTRAP, sigtrap, SA_ONSTACK);\n\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tsigtrap_consecutive_syscalls = 0;\n\t\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\t\tasm volatile (\n\t\t\t\"movl $-1, %%eax\\n\\t\"\n\t\t\t\"movl $-1, %%ebx\\n\\t\"\n\t\t\t\"movl $-1, %%ecx\\n\\t\"\n\t\t\t\"movl $-1, %%edx\\n\\t\"\n\t\t\t\"movl $-1, %%esi\\n\\t\"\n\t\t\t\"movl $-1, %%edi\\n\\t\"\n\t\t\t\"movl $-1, %%ebp\\n\\t\"\n\t\t\t\"movl $-1, %%esp\\n\\t\"\n\t\t\t\"sysenter\"\n\t\t\t: : : \"memory\", \"flags\");\n\t}\n\tset_eflags(get_eflags() & ~X86_EFLAGS_TF);\n\n\tprintf(\"[RUN]\\tSYSCALL with TF and invalid state\\n\");\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tsigtrap_consecutive_syscalls = 0;\n\t\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\t\tasm volatile (\n\t\t\t\"movl $-1, %%eax\\n\\t\"\n\t\t\t\"movl $-1, %%ebx\\n\\t\"\n\t\t\t\"movl $-1, %%ecx\\n\\t\"\n\t\t\t\"movl $-1, %%edx\\n\\t\"\n\t\t\t\"movl $-1, %%esi\\n\\t\"\n\t\t\t\"movl $-1, %%edi\\n\\t\"\n\t\t\t\"movl $-1, %%ebp\\n\\t\"\n\t\t\t\"movl $-1, %%esp\\n\\t\"\n\t\t\t\"syscall\\n\\t\"\n\t\t\t\"ud2\"\t\t \n\t\t\t: : : \"memory\", \"flags\");\n\t}\n\tset_eflags(get_eflags() & ~X86_EFLAGS_TF);\n\n#ifdef __x86_64__\n\tprintf(\"[RUN]\\tSYSENTER with TF, invalid state, and GSBASE < 0\\n\");\n\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tsigtrap_consecutive_syscalls = 0;\n\n\t\tasm volatile (\"wrgsbase %%rax\\n\\t\"\n\t\t\t      :: \"a\" (0xffffffffffff0000UL));\n\n\t\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\t\tasm volatile (\n\t\t\t\"movl $-1, %%eax\\n\\t\"\n\t\t\t\"movl $-1, %%ebx\\n\\t\"\n\t\t\t\"movl $-1, %%ecx\\n\\t\"\n\t\t\t\"movl $-1, %%edx\\n\\t\"\n\t\t\t\"movl $-1, %%esi\\n\\t\"\n\t\t\t\"movl $-1, %%edi\\n\\t\"\n\t\t\t\"movl $-1, %%ebp\\n\\t\"\n\t\t\t\"movl $-1, %%esp\\n\\t\"\n\t\t\t\"sysenter\"\n\t\t\t: : : \"memory\", \"flags\");\n\t}\n\tset_eflags(get_eflags() & ~X86_EFLAGS_TF);\n#endif\n\n\tfree(stack.ss_sp);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}