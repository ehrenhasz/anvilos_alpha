{
  "module_name": "sigaltstack.c",
  "hash_id": "aac87ed4f7c56c91cc5ab78302ea9000608f0b7266a7fc509579df50466f11ae",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/sigaltstack.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <signal.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <err.h>\n#include <errno.h>\n#include <limits.h>\n#include <sys/mman.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <setjmp.h>\n\n \n#define ENFORCED_MINSIGSTKSZ\t2048\n\n#ifndef AT_MINSIGSTKSZ\n#  define AT_MINSIGSTKSZ\t51\n#endif\n\nstatic int nerrs;\n\nstatic bool sigalrm_expected;\n\nstatic unsigned long at_minstack_size;\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void clearhandler(int sig)\n{\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_DFL;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic int setup_altstack(void *start, unsigned long size)\n{\n\tstack_t ss;\n\n\tmemset(&ss, 0, sizeof(ss));\n\tss.ss_size = size;\n\tss.ss_sp = start;\n\n\treturn sigaltstack(&ss, NULL);\n}\n\nstatic jmp_buf jmpbuf;\n\nstatic void sigsegv(int sig, siginfo_t *info, void *ctx_void)\n{\n\tif (sigalrm_expected) {\n\t\tprintf(\"[FAIL]\\tWrong signal delivered: SIGSEGV (expected SIGALRM).\");\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tSIGSEGV signal delivered.\\n\");\n\t}\n\n\tsiglongjmp(jmpbuf, 1);\n}\n\nstatic void sigalrm(int sig, siginfo_t *info, void *ctx_void)\n{\n\tif (!sigalrm_expected) {\n\t\tprintf(\"[FAIL]\\tWrong signal delivered: SIGALRM (expected SIGSEGV).\");\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tSIGALRM signal delivered.\\n\");\n\t}\n}\n\nstatic void test_sigaltstack(void *altstack, unsigned long size)\n{\n\tif (setup_altstack(altstack, size))\n\t\terr(1, \"sigaltstack()\");\n\n\tsigalrm_expected = (size > at_minstack_size) ? true : false;\n\n\tsethandler(SIGSEGV, sigsegv, 0);\n\tsethandler(SIGALRM, sigalrm, SA_ONSTACK);\n\n\tif (!sigsetjmp(jmpbuf, 1)) {\n\t\tprintf(\"[RUN]\\tTest an alternate signal stack of %ssufficient size.\\n\",\n\t\t       sigalrm_expected ? \"\" : \"in\");\n\t\tprintf(\"\\tRaise SIGALRM. %s is expected to be delivered.\\n\",\n\t\t       sigalrm_expected ? \"It\" : \"SIGSEGV\");\n\t\traise(SIGALRM);\n\t}\n\n\tclearhandler(SIGALRM);\n\tclearhandler(SIGSEGV);\n}\n\nint main(void)\n{\n\tvoid *altstack;\n\n\tat_minstack_size = getauxval(AT_MINSIGSTKSZ);\n\n\taltstack = mmap(NULL, at_minstack_size + SIGSTKSZ, PROT_READ | PROT_WRITE,\n\t\t\tMAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n\tif (altstack == MAP_FAILED)\n\t\terr(1, \"mmap()\");\n\n\tif ((ENFORCED_MINSIGSTKSZ + 1) < at_minstack_size)\n\t\ttest_sigaltstack(altstack, ENFORCED_MINSIGSTKSZ + 1);\n\n\ttest_sigaltstack(altstack, at_minstack_size + SIGSTKSZ);\n\n\treturn nerrs == 0 ? 0 : 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}