{
  "module_name": "amx.c",
  "hash_id": "087f08d9ea806c793b783619dca36f3fb0586ec6fc012cb3b18b5961e2d715bd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/amx.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <err.h>\n#include <errno.h>\n#include <pthread.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <x86intrin.h>\n\n#include <sys/auxv.h>\n#include <sys/mman.h>\n#include <sys/shm.h>\n#include <sys/ptrace.h>\n#include <sys/syscall.h>\n#include <sys/wait.h>\n#include <sys/uio.h>\n\n#include \"../kselftest.h\"  \n\n#ifndef __x86_64__\n# error This test is 64-bit only\n#endif\n\n#define XSAVE_HDR_OFFSET\t512\n#define XSAVE_HDR_SIZE\t\t64\n\nstruct xsave_buffer {\n\tunion {\n\t\tstruct {\n\t\t\tchar legacy[XSAVE_HDR_OFFSET];\n\t\t\tchar header[XSAVE_HDR_SIZE];\n\t\t\tchar extended[0];\n\t\t};\n\t\tchar bytes[0];\n\t};\n};\n\nstatic inline uint64_t xgetbv(uint32_t index)\n{\n\tuint32_t eax, edx;\n\n\tasm volatile(\"xgetbv;\"\n\t\t     : \"=a\" (eax), \"=d\" (edx)\n\t\t     : \"c\" (index));\n\treturn eax + ((uint64_t)edx << 32);\n}\n\nstatic inline void xsave(struct xsave_buffer *xbuf, uint64_t rfbm)\n{\n\tuint32_t rfbm_lo = rfbm;\n\tuint32_t rfbm_hi = rfbm >> 32;\n\n\tasm volatile(\"xsave (%%rdi)\"\n\t\t     : : \"D\" (xbuf), \"a\" (rfbm_lo), \"d\" (rfbm_hi)\n\t\t     : \"memory\");\n}\n\nstatic inline void xrstor(struct xsave_buffer *xbuf, uint64_t rfbm)\n{\n\tuint32_t rfbm_lo = rfbm;\n\tuint32_t rfbm_hi = rfbm >> 32;\n\n\tasm volatile(\"xrstor (%%rdi)\"\n\t\t     : : \"D\" (xbuf), \"a\" (rfbm_lo), \"d\" (rfbm_hi));\n}\n\n \n#define fatal_error(msg, ...)\terr(1, \"[FAIL]\\t\" msg, ##__VA_ARGS__)\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\tfatal_error(\"sigaction\");\n}\n\nstatic void clearhandler(int sig)\n{\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_DFL;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\tfatal_error(\"sigaction\");\n}\n\n#define XFEATURE_XTILECFG\t17\n#define XFEATURE_XTILEDATA\t18\n#define XFEATURE_MASK_XTILECFG\t(1 << XFEATURE_XTILECFG)\n#define XFEATURE_MASK_XTILEDATA\t(1 << XFEATURE_XTILEDATA)\n#define XFEATURE_MASK_XTILE\t(XFEATURE_MASK_XTILECFG | XFEATURE_MASK_XTILEDATA)\n\n#define CPUID_LEAF1_ECX_XSAVE_MASK\t(1 << 26)\n#define CPUID_LEAF1_ECX_OSXSAVE_MASK\t(1 << 27)\nstatic inline void check_cpuid_xsave(void)\n{\n\tuint32_t eax, ebx, ecx, edx;\n\n\t \n\t__cpuid_count(1, 0, eax, ebx, ecx, edx);\n\tif (!(ecx & CPUID_LEAF1_ECX_XSAVE_MASK))\n\t\tfatal_error(\"cpuid: no CPU xsave support\");\n\tif (!(ecx & CPUID_LEAF1_ECX_OSXSAVE_MASK))\n\t\tfatal_error(\"cpuid: no OS xsave support\");\n}\n\nstatic uint32_t xbuf_size;\n\nstatic struct {\n\tuint32_t xbuf_offset;\n\tuint32_t size;\n} xtiledata;\n\n#define CPUID_LEAF_XSTATE\t\t0xd\n#define CPUID_SUBLEAF_XSTATE_USER\t0x0\n#define TILE_CPUID\t\t\t0x1d\n#define TILE_PALETTE_ID\t\t\t0x1\n\nstatic void check_cpuid_xtiledata(void)\n{\n\tuint32_t eax, ebx, ecx, edx;\n\n\t__cpuid_count(CPUID_LEAF_XSTATE, CPUID_SUBLEAF_XSTATE_USER,\n\t\t      eax, ebx, ecx, edx);\n\n\t \n\txbuf_size = ebx;\n\n\t__cpuid_count(CPUID_LEAF_XSTATE, XFEATURE_XTILEDATA,\n\t\t      eax, ebx, ecx, edx);\n\t \n\tif (!eax || !ebx)\n\t\tfatal_error(\"xstate cpuid: invalid tile data size/offset: %d/%d\",\n\t\t\t\teax, ebx);\n\n\txtiledata.size\t      = eax;\n\txtiledata.xbuf_offset = ebx;\n}\n\n \n\nstruct xsave_buffer *alloc_xbuf(void)\n{\n\tstruct xsave_buffer *xbuf;\n\n\t \n\txbuf = aligned_alloc(64, xbuf_size);\n\tif (!xbuf)\n\t\tfatal_error(\"aligned_alloc()\");\n\treturn xbuf;\n}\n\nstatic inline void clear_xstate_header(struct xsave_buffer *buffer)\n{\n\tmemset(&buffer->header, 0, sizeof(buffer->header));\n}\n\nstatic inline uint64_t get_xstatebv(struct xsave_buffer *buffer)\n{\n\t \n\treturn *(uint64_t *)&buffer->header;\n}\n\nstatic inline void set_xstatebv(struct xsave_buffer *buffer, uint64_t bv)\n{\n\t \n\t*(uint64_t *)(&buffer->header) = bv;\n}\n\nstatic void set_rand_tiledata(struct xsave_buffer *xbuf)\n{\n\tint *ptr = (int *)&xbuf->bytes[xtiledata.xbuf_offset];\n\tint data;\n\tint i;\n\n\t \n\tdata = rand() | 1;\n\n\tfor (i = 0; i < xtiledata.size / sizeof(int); i++, ptr++)\n\t\t*ptr = data;\n}\n\nstruct xsave_buffer *stashed_xsave;\n\nstatic void init_stashed_xsave(void)\n{\n\tstashed_xsave = alloc_xbuf();\n\tif (!stashed_xsave)\n\t\tfatal_error(\"failed to allocate stashed_xsave\\n\");\n\tclear_xstate_header(stashed_xsave);\n}\n\nstatic void free_stashed_xsave(void)\n{\n\tfree(stashed_xsave);\n}\n\n \n#define SW_BYTES_OFFSET\t\t464\n \n#define SW_BYTES_BV_OFFSET\t(SW_BYTES_OFFSET + 8)\n\nstatic inline struct _fpx_sw_bytes *get_fpx_sw_bytes(void *buffer)\n{\n\treturn (struct _fpx_sw_bytes *)(buffer + SW_BYTES_OFFSET);\n}\n\nstatic inline uint64_t get_fpx_sw_bytes_features(void *buffer)\n{\n\treturn *(uint64_t *)(buffer + SW_BYTES_BV_OFFSET);\n}\n\n \n#define SIGNAL_BUF_LEN 1000\nchar signal_message_buffer[SIGNAL_BUF_LEN];\nvoid sig_print(char *msg)\n{\n\tint left = SIGNAL_BUF_LEN - strlen(signal_message_buffer) - 1;\n\n\tstrncat(signal_message_buffer, msg, left);\n}\n\nstatic volatile bool noperm_signaled;\nstatic int noperm_errs;\n \nstatic void handle_noperm(int sig, siginfo_t *si, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t *)ctx_void;\n\tvoid *xbuf = ctx->uc_mcontext.fpregs;\n\tstruct _fpx_sw_bytes *sw_bytes;\n\tuint64_t features;\n\n\t \n\tsignal_message_buffer[0] = '\\0';\n\tsig_print(\"\\tAt SIGILL handler,\\n\");\n\n\tif (si->si_code != ILL_ILLOPC) {\n\t\tnoperm_errs++;\n\t\tsig_print(\"[FAIL]\\tInvalid signal code.\\n\");\n\t} else {\n\t\tsig_print(\"[OK]\\tValid signal code (ILL_ILLOPC).\\n\");\n\t}\n\n\tsw_bytes = get_fpx_sw_bytes(xbuf);\n\t \n\tif (sw_bytes->xstate_size <= xtiledata.xbuf_offset) {\n\t\tsig_print(\"[OK]\\tValid xstate size\\n\");\n\t} else {\n\t\tnoperm_errs++;\n\t\tsig_print(\"[FAIL]\\tInvalid xstate size\\n\");\n\t}\n\n\tfeatures = get_fpx_sw_bytes_features(xbuf);\n\t \n\tif ((features & XFEATURE_MASK_XTILEDATA) == 0) {\n\t\tsig_print(\"[OK]\\tValid xstate mask\\n\");\n\t} else {\n\t\tnoperm_errs++;\n\t\tsig_print(\"[FAIL]\\tInvalid xstate mask\\n\");\n\t}\n\n\tnoperm_signaled = true;\n\tctx->uc_mcontext.gregs[REG_RIP] += 3;  \n}\n\n \nstatic inline bool xrstor_safe(struct xsave_buffer *xbuf, uint64_t mask)\n{\n\tnoperm_signaled = false;\n\txrstor(xbuf, mask);\n\n\t \n\tprintf(\"%s\", signal_message_buffer);\n\t \n\tsignal_message_buffer[0] = '\\0';\n\n\tif (noperm_errs)\n\t\tfatal_error(\"saw %d errors in noperm signal handler\\n\", noperm_errs);\n\n\treturn !noperm_signaled;\n}\n\n \nstatic inline bool load_rand_tiledata(struct xsave_buffer *xbuf)\n{\n\tclear_xstate_header(xbuf);\n\tset_xstatebv(xbuf, XFEATURE_MASK_XTILEDATA);\n\tset_rand_tiledata(xbuf);\n\treturn xrstor_safe(xbuf, XFEATURE_MASK_XTILEDATA);\n}\n\n \nstatic inline void init_xtiledata(void)\n{\n\tclear_xstate_header(stashed_xsave);\n\txrstor_safe(stashed_xsave, XFEATURE_MASK_XTILEDATA);\n}\n\nenum expected_result { FAIL_EXPECTED, SUCCESS_EXPECTED };\n\n \n\n#define ARCH_GET_XCOMP_PERM\t0x1022\n#define ARCH_REQ_XCOMP_PERM\t0x1023\n\nstatic void req_xtiledata_perm(void)\n{\n\tsyscall(SYS_arch_prctl, ARCH_REQ_XCOMP_PERM, XFEATURE_XTILEDATA);\n}\n\nstatic void validate_req_xcomp_perm(enum expected_result exp)\n{\n\tunsigned long bitmask, expected_bitmask;\n\tlong rc;\n\n\trc = syscall(SYS_arch_prctl, ARCH_GET_XCOMP_PERM, &bitmask);\n\tif (rc) {\n\t\tfatal_error(\"prctl(ARCH_GET_XCOMP_PERM) error: %ld\", rc);\n\t} else if (!(bitmask & XFEATURE_MASK_XTILECFG)) {\n\t\tfatal_error(\"ARCH_GET_XCOMP_PERM returns XFEATURE_XTILECFG off.\");\n\t}\n\n\trc = syscall(SYS_arch_prctl, ARCH_REQ_XCOMP_PERM, XFEATURE_XTILEDATA);\n\tif (exp == FAIL_EXPECTED) {\n\t\tif (rc) {\n\t\t\tprintf(\"[OK]\\tARCH_REQ_XCOMP_PERM saw expected failure..\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tfatal_error(\"ARCH_REQ_XCOMP_PERM saw unexpected success.\\n\");\n\t} else if (rc) {\n\t\tfatal_error(\"ARCH_REQ_XCOMP_PERM saw unexpected failure.\\n\");\n\t}\n\n\texpected_bitmask = bitmask | XFEATURE_MASK_XTILEDATA;\n\n\trc = syscall(SYS_arch_prctl, ARCH_GET_XCOMP_PERM, &bitmask);\n\tif (rc) {\n\t\tfatal_error(\"prctl(ARCH_GET_XCOMP_PERM) error: %ld\", rc);\n\t} else if (bitmask != expected_bitmask) {\n\t\tfatal_error(\"ARCH_REQ_XCOMP_PERM set a wrong bitmask: %lx, expected: %lx.\\n\",\n\t\t\t    bitmask, expected_bitmask);\n\t} else {\n\t\tprintf(\"\\tARCH_REQ_XCOMP_PERM is successful.\\n\");\n\t}\n}\n\nstatic void validate_xcomp_perm(enum expected_result exp)\n{\n\tbool load_success = load_rand_tiledata(stashed_xsave);\n\n\tif (exp == FAIL_EXPECTED) {\n\t\tif (load_success) {\n\t\t\tnoperm_errs++;\n\t\t\tprintf(\"[FAIL]\\tLoad tiledata succeeded.\\n\");\n\t\t} else {\n\t\t\tprintf(\"[OK]\\tLoad tiledata failed.\\n\");\n\t\t}\n\t} else if (exp == SUCCESS_EXPECTED) {\n\t\tif (load_success) {\n\t\t\tprintf(\"[OK]\\tLoad tiledata succeeded.\\n\");\n\t\t} else {\n\t\t\tnoperm_errs++;\n\t\t\tprintf(\"[FAIL]\\tLoad tiledata failed.\\n\");\n\t\t}\n\t}\n}\n\n#ifndef AT_MINSIGSTKSZ\n#  define AT_MINSIGSTKSZ\t51\n#endif\n\nstatic void *alloc_altstack(unsigned int size)\n{\n\tvoid *altstack;\n\n\taltstack = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\tMAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n\n\tif (altstack == MAP_FAILED)\n\t\tfatal_error(\"mmap() for altstack\");\n\n\treturn altstack;\n}\n\nstatic void setup_altstack(void *addr, unsigned long size, enum expected_result exp)\n{\n\tstack_t ss;\n\tint rc;\n\n\tmemset(&ss, 0, sizeof(ss));\n\tss.ss_size = size;\n\tss.ss_sp = addr;\n\n\trc = sigaltstack(&ss, NULL);\n\n\tif (exp == FAIL_EXPECTED) {\n\t\tif (rc) {\n\t\t\tprintf(\"[OK]\\tsigaltstack() failed.\\n\");\n\t\t} else {\n\t\t\tfatal_error(\"sigaltstack() succeeded unexpectedly.\\n\");\n\t\t}\n\t} else if (rc) {\n\t\tfatal_error(\"sigaltstack()\");\n\t}\n}\n\nstatic void test_dynamic_sigaltstack(void)\n{\n\tunsigned int small_size, enough_size;\n\tunsigned long minsigstksz;\n\tvoid *altstack;\n\n\tminsigstksz = getauxval(AT_MINSIGSTKSZ);\n\tprintf(\"\\tAT_MINSIGSTKSZ = %lu\\n\", minsigstksz);\n\t \n\tif (minsigstksz == 0) {\n\t\tprintf(\"no support for AT_MINSIGSTKSZ, skipping sigaltstack tests\\n\");\n\t\treturn;\n\t}\n\n\tenough_size = minsigstksz * 2;\n\n\taltstack = alloc_altstack(enough_size);\n\tprintf(\"\\tAllocate memory for altstack (%u bytes).\\n\", enough_size);\n\n\t \n\tsmall_size = minsigstksz - xtiledata.size;\n\tprintf(\"\\tAfter sigaltstack() with small size (%u bytes).\\n\", small_size);\n\tsetup_altstack(altstack, small_size, SUCCESS_EXPECTED);\n\tvalidate_req_xcomp_perm(FAIL_EXPECTED);\n\n\t \n\tprintf(\"\\tAfter sigaltstack() with enough size (%u bytes).\\n\", enough_size);\n\tsetup_altstack(altstack, enough_size, SUCCESS_EXPECTED);\n\tvalidate_req_xcomp_perm(SUCCESS_EXPECTED);\n\n\t \n\tprintf(\"\\tThen, sigaltstack() with small size (%u bytes).\\n\", small_size);\n\tsetup_altstack(altstack, small_size, FAIL_EXPECTED);\n}\n\nstatic void test_dynamic_state(void)\n{\n\tpid_t parent, child, grandchild;\n\n\tparent = fork();\n\tif (parent < 0) {\n\t\t \n\t\tfatal_error(\"fork\");\n\t} else if (parent > 0) {\n\t\tint status;\n\t\t \n\n\t\twait(&status);\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\t\tfatal_error(\"arch_prctl test parent exit\");\n\t\treturn;\n\t}\n\t \n\n\tprintf(\"[RUN]\\tCheck ARCH_REQ_XCOMP_PERM around process fork() and sigaltack() test.\\n\");\n\n\tprintf(\"\\tFork a child.\\n\");\n\tchild = fork();\n\tif (child < 0) {\n\t\tfatal_error(\"fork\");\n\t} else if (child > 0) {\n\t\tint status;\n\n\t\twait(&status);\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\t\tfatal_error(\"arch_prctl test child exit\");\n\t\t_exit(0);\n\t}\n\n\t \n\tprintf(\"\\tTest XCOMP_PERM at child.\\n\");\n\tvalidate_xcomp_perm(FAIL_EXPECTED);\n\n\t \n\tprintf(\"\\tTest dynamic sigaltstack at child:\\n\");\n\ttest_dynamic_sigaltstack();\n\n\t \n\tprintf(\"\\tTest XCOMP_PERM again at child.\\n\");\n\tvalidate_xcomp_perm(SUCCESS_EXPECTED);\n\n\tprintf(\"\\tFork a grandchild.\\n\");\n\tgrandchild = fork();\n\tif (grandchild < 0) {\n\t\t \n\t\tfatal_error(\"fork\");\n\t} else if (!grandchild) {\n\t\t \n\t\tprintf(\"\\tTest XCOMP_PERM at grandchild.\\n\");\n\n\t\t \n\t\tvalidate_xcomp_perm(SUCCESS_EXPECTED);\n\t} else {\n\t\tint status;\n\t\t \n\n\t\twait(&status);\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\t\tfatal_error(\"fork test grandchild\");\n\t}\n\n\t_exit(0);\n}\n\nstatic inline int __compare_tiledata_state(struct xsave_buffer *xbuf1, struct xsave_buffer *xbuf2)\n{\n\treturn memcmp(&xbuf1->bytes[xtiledata.xbuf_offset],\n\t\t      &xbuf2->bytes[xtiledata.xbuf_offset],\n\t\t      xtiledata.size);\n}\n\n \nstatic inline bool __validate_tiledata_regs(struct xsave_buffer *xbuf1)\n{\n\tstruct xsave_buffer *xbuf2;\n\tint ret;\n\n\txbuf2 = alloc_xbuf();\n\tif (!xbuf2)\n\t\tfatal_error(\"failed to allocate XSAVE buffer\\n\");\n\n\txsave(xbuf2, XFEATURE_MASK_XTILEDATA);\n\tret = __compare_tiledata_state(xbuf1, xbuf2);\n\n\tfree(xbuf2);\n\n\tif (ret == 0)\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline void validate_tiledata_regs_same(struct xsave_buffer *xbuf)\n{\n\tint ret = __validate_tiledata_regs(xbuf);\n\n\tif (ret != 0)\n\t\tfatal_error(\"TILEDATA registers changed\");\n}\n\nstatic inline void validate_tiledata_regs_changed(struct xsave_buffer *xbuf)\n{\n\tint ret = __validate_tiledata_regs(xbuf);\n\n\tif (ret == 0)\n\t\tfatal_error(\"TILEDATA registers did not change\");\n}\n\n \n\nstatic void test_fork(void)\n{\n\tpid_t child, grandchild;\n\n\tchild = fork();\n\tif (child < 0) {\n\t\t \n\t\tfatal_error(\"fork\");\n\t} else if (child > 0) {\n\t\t \n\t\tint status;\n\n\t\twait(&status);\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\t\tfatal_error(\"fork test child\");\n\t\treturn;\n\t}\n\t \n\tprintf(\"[RUN]\\tCheck tile data inheritance.\\n\\tBefore fork(), load tiledata\\n\");\n\n\tload_rand_tiledata(stashed_xsave);\n\n\tgrandchild = fork();\n\tif (grandchild < 0) {\n\t\t \n\t\tfatal_error(\"fork\");\n\t} else if (grandchild > 0) {\n\t\t \n\t\tint status;\n\n\t\twait(&status);\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\t\tfatal_error(\"fork test grand child\");\n\t\t_exit(0);\n\t}\n\t \n\n\t \n\tvalidate_tiledata_regs_changed(stashed_xsave);\n\n\t_exit(0);\n}\n\n \n\nstatic struct _ctxtswtest_cfg {\n\tunsigned int iterations;\n\tunsigned int num_threads;\n} ctxtswtest_config;\n\nstruct futex_info {\n\tpthread_t thread;\n\tint nr;\n\tpthread_mutex_t mutex;\n\tstruct futex_info *next;\n};\n\nstatic void *check_tiledata(void *info)\n{\n\tstruct futex_info *finfo = (struct futex_info *)info;\n\tstruct xsave_buffer *xbuf;\n\tint i;\n\n\txbuf = alloc_xbuf();\n\tif (!xbuf)\n\t\tfatal_error(\"unable to allocate XSAVE buffer\");\n\n\t \n\tload_rand_tiledata(xbuf);\n\tfor (i = 0; i < ctxtswtest_config.iterations; i++) {\n\t\tpthread_mutex_lock(&finfo->mutex);\n\n\t\t \n\t\tvalidate_tiledata_regs_same(xbuf);\n\n\t\t \n\t\tload_rand_tiledata(xbuf);\n\n\t\t \n\t\tpthread_mutex_unlock(&finfo->next->mutex);\n\t}\n\n\tfree(xbuf);\n\t \n\treturn finfo;\n}\n\nstatic int create_threads(int num, struct futex_info *finfo)\n{\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tint next_nr;\n\n\t\tfinfo[i].nr = i;\n\t\t \n\t\tpthread_mutex_init(&finfo[i].mutex, NULL);\n\t\tpthread_mutex_lock(&finfo[i].mutex);\n\n\t\tnext_nr = (i + 1) % num;\n\t\tfinfo[i].next = &finfo[next_nr];\n\n\t\tif (pthread_create(&finfo[i].thread, NULL, check_tiledata, &finfo[i]))\n\t\t\tfatal_error(\"pthread_create()\");\n\t}\n\treturn 0;\n}\n\nstatic void affinitize_cpu0(void)\n{\n\tcpu_set_t cpuset;\n\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(0, &cpuset);\n\n\tif (sched_setaffinity(0, sizeof(cpuset), &cpuset) != 0)\n\t\tfatal_error(\"sched_setaffinity to CPU 0\");\n}\n\nstatic void test_context_switch(void)\n{\n\tstruct futex_info *finfo;\n\tint i;\n\n\t \n\taffinitize_cpu0();\n\n\treq_xtiledata_perm();\n\n\tprintf(\"[RUN]\\tCheck tiledata context switches, %d iterations, %d threads.\\n\",\n\t       ctxtswtest_config.iterations,\n\t       ctxtswtest_config.num_threads);\n\n\n\tfinfo = malloc(sizeof(*finfo) * ctxtswtest_config.num_threads);\n\tif (!finfo)\n\t\tfatal_error(\"malloc()\");\n\n\tcreate_threads(ctxtswtest_config.num_threads, finfo);\n\n\t \n\tpthread_mutex_unlock(&finfo[0].mutex);\n\n\t \n\tfor (i = 0; i < ctxtswtest_config.num_threads; i++) {\n\t\tvoid *thread_retval;\n\t\tint rc;\n\n\t\trc = pthread_join(finfo[i].thread, &thread_retval);\n\n\t\tif (rc)\n\t\t\tfatal_error(\"pthread_join() failed for thread %d err: %d\\n\",\n\t\t\t\t\ti, rc);\n\n\t\tif (thread_retval != &finfo[i])\n\t\t\tfatal_error(\"unexpected thread retval for thread %d: %p\\n\",\n\t\t\t\t\ti, thread_retval);\n\n\t}\n\n\tprintf(\"[OK]\\tNo incorrect case was found.\\n\");\n\n\tfree(finfo);\n}\n\n \n\n \nstatic inline void ptracee_firstuse_tiledata(void)\n{\n\tload_rand_tiledata(stashed_xsave);\n\tinit_xtiledata();\n}\n\n \nstatic void ptracer_inject_tiledata(pid_t target)\n{\n\tstruct xsave_buffer *xbuf;\n\tstruct iovec iov;\n\n\txbuf = alloc_xbuf();\n\tif (!xbuf)\n\t\tfatal_error(\"unable to allocate XSAVE buffer\");\n\n\tprintf(\"\\tRead the init'ed tiledata via ptrace().\\n\");\n\n\tiov.iov_base = xbuf;\n\tiov.iov_len = xbuf_size;\n\n\tmemset(stashed_xsave, 0, xbuf_size);\n\n\tif (ptrace(PTRACE_GETREGSET, target, (uint32_t)NT_X86_XSTATE, &iov))\n\t\tfatal_error(\"PTRACE_GETREGSET\");\n\n\tif (!__compare_tiledata_state(stashed_xsave, xbuf))\n\t\tprintf(\"[OK]\\tThe init'ed tiledata was read from ptracee.\\n\");\n\telse\n\t\tprintf(\"[FAIL]\\tThe init'ed tiledata was not read from ptracee.\\n\");\n\n\tprintf(\"\\tInject tiledata via ptrace().\\n\");\n\n\tload_rand_tiledata(xbuf);\n\n\tmemcpy(&stashed_xsave->bytes[xtiledata.xbuf_offset],\n\t       &xbuf->bytes[xtiledata.xbuf_offset],\n\t       xtiledata.size);\n\n\tif (ptrace(PTRACE_SETREGSET, target, (uint32_t)NT_X86_XSTATE, &iov))\n\t\tfatal_error(\"PTRACE_SETREGSET\");\n\n\tif (ptrace(PTRACE_GETREGSET, target, (uint32_t)NT_X86_XSTATE, &iov))\n\t\tfatal_error(\"PTRACE_GETREGSET\");\n\n\tif (!__compare_tiledata_state(stashed_xsave, xbuf))\n\t\tprintf(\"[OK]\\tTiledata was correctly written to ptracee.\\n\");\n\telse\n\t\tprintf(\"[FAIL]\\tTiledata was not correctly written to ptracee.\\n\");\n}\n\nstatic void test_ptrace(void)\n{\n\tpid_t child;\n\tint status;\n\n\tchild = fork();\n\tif (child < 0) {\n\t\terr(1, \"fork\");\n\t} else if (!child) {\n\t\tif (ptrace(PTRACE_TRACEME, 0, NULL, NULL))\n\t\t\terr(1, \"PTRACE_TRACEME\");\n\n\t\tptracee_firstuse_tiledata();\n\n\t\traise(SIGTRAP);\n\t\t_exit(0);\n\t}\n\n\tdo {\n\t\twait(&status);\n\t} while (WSTOPSIG(status) != SIGTRAP);\n\n\tptracer_inject_tiledata(child);\n\n\tptrace(PTRACE_DETACH, child, NULL, NULL);\n\twait(&status);\n\tif (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\terr(1, \"ptrace test\");\n}\n\nint main(void)\n{\n\t \n\tcheck_cpuid_xsave();\n\tcheck_cpuid_xtiledata();\n\n\tinit_stashed_xsave();\n\tsethandler(SIGILL, handle_noperm, 0);\n\n\ttest_dynamic_state();\n\n\t \n\treq_xtiledata_perm();\n\n\ttest_fork();\n\n\tctxtswtest_config.iterations = 10;\n\tctxtswtest_config.num_threads = 5;\n\ttest_context_switch();\n\n\ttest_ptrace();\n\n\tclearhandler(SIGILL);\n\tfree_stashed_xsave();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}