{
  "module_name": "test_syscall_vdso.c",
  "hash_id": "c1e651c7ac68a463bd0faf0812daae5b0316a2bef122b9787b2d142d56a45bfc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/test_syscall_vdso.c",
  "human_readable_source": "\n \n \n#undef _GNU_SOURCE\n#define _GNU_SOURCE 1\n#undef __USE_GNU\n#define __USE_GNU 1\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <elf.h>\n#include <sys/ptrace.h>\n#include <sys/wait.h>\n\n#if !defined(__i386__)\nint main(int argc, char **argv, char **envp)\n{\n\tprintf(\"[SKIP]\\tNot a 32-bit x86 userspace\\n\");\n\treturn 0;\n}\n#else\n\nlong syscall_addr;\nlong get_syscall(char **envp)\n{\n\tElf32_auxv_t *auxv;\n\twhile (*envp++ != NULL)\n\t\tcontinue;\n\tfor (auxv = (void *)envp; auxv->a_type != AT_NULL; auxv++)\n\t\tif (auxv->a_type == AT_SYSINFO)\n\t\t\treturn auxv->a_un.a_val;\n\tprintf(\"[WARN]\\tAT_SYSINFO not supplied\\n\");\n\treturn 0;\n}\n\nasm (\n\t\"\t.pushsection .text\\n\"\n\t\"\t.global\tint80\\n\"\n\t\"int80:\\n\"\n\t\"\tint\t$0x80\\n\"\n\t\"\tret\\n\"\n\t\"\t.popsection\\n\"\n);\nextern char int80;\n\nstruct regs64 {\n\tuint64_t rax, rbx, rcx, rdx;\n\tuint64_t rsi, rdi, rbp, rsp;\n\tuint64_t r8,  r9,  r10, r11;\n\tuint64_t r12, r13, r14, r15;\n};\nstruct regs64 regs64;\nint kernel_is_64bit;\n\nasm (\n\t\"\t.pushsection .text\\n\"\n\t\"\t.code64\\n\"\n\t\"get_regs64:\\n\"\n\t\"\tpush\t%rax\\n\"\n\t\"\tmov\t$regs64, %eax\\n\"\n\t\"\tpop\t0*8(%rax)\\n\"\n\t\"\tmovq\t%rbx, 1*8(%rax)\\n\"\n\t\"\tmovq\t%rcx, 2*8(%rax)\\n\"\n\t\"\tmovq\t%rdx, 3*8(%rax)\\n\"\n\t\"\tmovq\t%rsi, 4*8(%rax)\\n\"\n\t\"\tmovq\t%rdi, 5*8(%rax)\\n\"\n\t\"\tmovq\t%rbp, 6*8(%rax)\\n\"\n\t\"\tmovq\t%rsp, 7*8(%rax)\\n\"\n\t\"\tmovq\t%r8,  8*8(%rax)\\n\"\n\t\"\tmovq\t%r9,  9*8(%rax)\\n\"\n\t\"\tmovq\t%r10, 10*8(%rax)\\n\"\n\t\"\tmovq\t%r11, 11*8(%rax)\\n\"\n\t\"\tmovq\t%r12, 12*8(%rax)\\n\"\n\t\"\tmovq\t%r13, 13*8(%rax)\\n\"\n\t\"\tmovq\t%r14, 14*8(%rax)\\n\"\n\t\"\tmovq\t%r15, 15*8(%rax)\\n\"\n\t\"\tret\\n\"\n\t\"poison_regs64:\\n\"\n\t\"\tmovq\t$0x7f7f7f7f, %r8\\n\"\n\t\"\tshl\t$32, %r8\\n\"\n\t\"\torq\t$0x7f7f7f7f, %r8\\n\"\n\t\"\tmovq\t%r8, %r9\\n\"\n\t\"\tincq\t%r9\\n\"\n\t\"\tmovq\t%r9, %r10\\n\"\n\t\"\tincq\t%r10\\n\"\n\t\"\tmovq\t%r10, %r11\\n\"\n\t\"\tincq\t%r11\\n\"\n\t\"\tmovq\t%r11, %r12\\n\"\n\t\"\tincq\t%r12\\n\"\n\t\"\tmovq\t%r12, %r13\\n\"\n\t\"\tincq\t%r13\\n\"\n\t\"\tmovq\t%r13, %r14\\n\"\n\t\"\tincq\t%r14\\n\"\n\t\"\tmovq\t%r14, %r15\\n\"\n\t\"\tincq\t%r15\\n\"\n\t\"\tret\\n\"\n\t\"\t.code32\\n\"\n\t\"\t.popsection\\n\"\n);\nextern void get_regs64(void);\nextern void poison_regs64(void);\nextern unsigned long call64_from_32(void (*function)(void));\nvoid print_regs64(void)\n{\n\tif (!kernel_is_64bit)\n\t\treturn;\n\tprintf(\"ax:%016llx bx:%016llx cx:%016llx dx:%016llx\\n\", regs64.rax,  regs64.rbx,  regs64.rcx,  regs64.rdx);\n\tprintf(\"si:%016llx di:%016llx bp:%016llx sp:%016llx\\n\", regs64.rsi,  regs64.rdi,  regs64.rbp,  regs64.rsp);\n\tprintf(\" 8:%016llx  9:%016llx 10:%016llx 11:%016llx\\n\", regs64.r8 ,  regs64.r9 ,  regs64.r10,  regs64.r11);\n\tprintf(\"12:%016llx 13:%016llx 14:%016llx 15:%016llx\\n\", regs64.r12,  regs64.r13,  regs64.r14,  regs64.r15);\n}\n\nint check_regs64(void)\n{\n\tint err = 0;\n\tint num = 8;\n\tuint64_t *r64 = &regs64.r8;\n\tuint64_t expected = 0x7f7f7f7f7f7f7f7fULL;\n\n\tif (!kernel_is_64bit)\n\t\treturn 0;\n\n\tdo {\n\t\tif (*r64 == expected++)\n\t\t\tcontinue;  \n\t\tif (syscall_addr != (long)&int80) {\n\t\t\t \n\t\t\tif (*r64 == 0)\n\t\t\t\tcontinue;\n\t\t\tif (num == 11) {\n\t\t\t\tprintf(\"[NOTE]\\tR11 has changed:%016llx - assuming clobbered by SYSRET insn\\n\", *r64);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t}\n\t\tprintf(\"[FAIL]\\tR%d has changed:%016llx\\n\", num, *r64);\n\t\terr++;\n\t} while (r64++, ++num < 16);\n\n\tif (!err)\n\t\tprintf(\"[OK]\\tR8..R15 did not leak kernel data\\n\");\n\treturn err;\n}\n\nint nfds;\nfd_set rfds;\nfd_set wfds;\nfd_set efds;\nstruct timespec timeout;\nsigset_t sigmask;\nstruct {\n\tsigset_t *sp;\n\tint sz;\n} sigmask_desc;\n\nvoid prep_args()\n{\n\tnfds = 42;\n\tFD_ZERO(&rfds);\n\tFD_ZERO(&wfds);\n\tFD_ZERO(&efds);\n\tFD_SET(0, &rfds);\n\tFD_SET(1, &wfds);\n\tFD_SET(2, &efds);\n\ttimeout.tv_sec = 0;\n\ttimeout.tv_nsec = 123;\n\tsigemptyset(&sigmask);\n\tsigaddset(&sigmask, SIGINT);\n\tsigaddset(&sigmask, SIGUSR2);\n\tsigaddset(&sigmask, SIGRTMAX);\n\tsigmask_desc.sp = &sigmask;\n\tsigmask_desc.sz = 8;  \n}\n\nstatic void print_flags(const char *name, unsigned long r)\n{\n\tstatic const char *bitarray[] = {\n\t\"\\n\" ,\"c\\n\" , \n\t\"0 \" ,\"1 \"  , \n\t\"\"   ,\"p \"  , \n\t\"0 \" ,\"3? \" ,\n\t\"\"   ,\"a \"  , \n\t\"0 \" ,\"5? \" ,\n\t\"\"   ,\"z \"  , \n\t\"\"   ,\"s \"  , \n\t\"\"   ,\"t \"  , \n\t\"\"   ,\"i \"  , \n\t\"\"   ,\"d \"  , \n\t\"\"   ,\"o \"  , \n\t\"0 \" ,\"1 \"  , \n\t\"0\"  ,\"1\"   , \n\t\"\"   ,\"n \"  , \n\t\"0 \" ,\"15? \",\n\t\"\"   ,\"r \"  , \n\t\"\"   ,\"v \"  , \n\t\"\"   ,\"ac \" , \n\t\"\"   ,\"vif \", \n\t\"\"   ,\"vip \", \n\t\"\"   ,\"id \" , \n\tNULL\n\t};\n\tconst char **bitstr;\n\tint bit;\n\n\tprintf(\"%s=%016lx \", name, r);\n\tbitstr = bitarray + 42;\n\tbit = 21;\n\tif ((r >> 22) != 0)\n\t\tprintf(\"(extra bits are set) \");\n\tdo {\n\t\tif (bitstr[(r >> bit) & 1][0])\n\t\t\tfputs(bitstr[(r >> bit) & 1], stdout);\n\t\tbitstr -= 2;\n\t\tbit--;\n\t} while (bit >= 0);\n}\n\nint run_syscall(void)\n{\n\tlong flags, bad_arg;\n\n\tprep_args();\n\n\tif (kernel_is_64bit)\n\t\tcall64_from_32(poison_regs64);\n\t \n\n\tasm(\"\\n\"\n\t \n\t\"\tpush\t%%ebp\\n\"\n\t\"\tmov\t$308, %%eax\\n\"      \n\t\"\tmov\tnfds, %%ebx\\n\"      \n\t\"\tmov\t$rfds, %%ecx\\n\"     \n\t\"\tmov\t$wfds, %%edx\\n\"     \n\t\"\tmov\t$efds, %%esi\\n\"     \n\t\"\tmov\t$timeout, %%edi\\n\"  \n\t\"\tmov\t$sigmask_desc, %%ebp\\n\"  \n\t\"\tpush\t$0x200ed7\\n\"       \n\t\"\tpopf\\n\"\t\t \n\t\"\tcall\t*syscall_addr\\n\"\n\t \n\t\"\tpushf\\n\"\n\t\"\tpop\t%%eax\\n\"\n\t\"\tcld\\n\"\n\t\"\tcmp\tnfds, %%ebx\\n\"      \n\t\"\tmov\t$1, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$rfds, %%ecx\\n\"     \n\t\"\tmov\t$2, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$wfds, %%edx\\n\"     \n\t\"\tmov\t$3, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$efds, %%esi\\n\"     \n\t\"\tmov\t$4, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$timeout, %%edi\\n\"  \n\t\"\tmov\t$5, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmpl\t$sigmask_desc, %%ebp\\n\"  \n\t\"\tmov\t$6, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tmov\t$0, %%ebx\\n\"\n\t\"1:\\n\"\n\t\"\tpop\t%%ebp\\n\"\n\t: \"=a\" (flags), \"=b\" (bad_arg)\n\t:\n\t: \"cx\", \"dx\", \"si\", \"di\"\n\t);\n\n\tif (kernel_is_64bit) {\n\t\tmemset(&regs64, 0x77, sizeof(regs64));\n\t\tcall64_from_32(get_regs64);\n\t\t \n\t}\n\n\t \n\tif ((0x200ed7 ^ flags) != 0) {\n\t\tprint_flags(\"[WARN]\\tFlags before\", 0x200ed7);\n\t\tprint_flags(\"[WARN]\\tFlags  after\", flags);\n\t\tprint_flags(\"[WARN]\\tFlags change\", (0x200ed7 ^ flags));\n\t}\n\n\tif (bad_arg) {\n\t\tprintf(\"[FAIL]\\targ#%ld clobbered\\n\", bad_arg);\n\t\treturn 1;\n\t}\n\tprintf(\"[OK]\\tArguments are preserved across syscall\\n\");\n\n\treturn check_regs64();\n}\n\nint run_syscall_twice()\n{\n\tint exitcode = 0;\n\tlong sv;\n\n\tif (syscall_addr) {\n\t\tprintf(\"[RUN]\\tExecuting 6-argument 32-bit syscall via VDSO\\n\");\n\t\texitcode = run_syscall();\n\t}\n\tsv = syscall_addr;\n\tsyscall_addr = (long)&int80;\n\tprintf(\"[RUN]\\tExecuting 6-argument 32-bit syscall via INT 80\\n\");\n\texitcode += run_syscall();\n\tsyscall_addr = sv;\n\treturn exitcode;\n}\n\nvoid ptrace_me()\n{\n\tpid_t pid;\n\n\tfflush(NULL);\n\tpid = fork();\n\tif (pid < 0)\n\t\texit(1);\n\tif (pid == 0) {\n\t\t \n\t\tif (ptrace(PTRACE_TRACEME, 0L, 0L, 0L) != 0)\n\t\t\texit(0);\n\t\traise(SIGSTOP);\n\t\treturn;\n\t}\n\t \n\tprintf(\"[RUN]\\tRunning tests under ptrace\\n\");\n\twhile (1) {\n\t\tint status;\n\t\tpid = waitpid(-1, &status, __WALL);\n\t\tif (WIFEXITED(status))\n\t\t\texit(WEXITSTATUS(status));\n\t\tif (WIFSIGNALED(status))\n\t\t\texit(WTERMSIG(status));\n\t\tif (pid <= 0 || !WIFSTOPPED(status))  \n\t\t\texit(255);\n\t\t \n\t\tptrace(PTRACE_SYSCALL, pid, 0L, 0L  );\n\t}\n}\n\nint main(int argc, char **argv, char **envp)\n{\n\tint exitcode = 0;\n\tint cs;\n\n\tasm(\"\\n\"\n\t\"\tmovl\t%%cs, %%eax\\n\"\n\t: \"=a\" (cs)\n\t);\n\tkernel_is_64bit = (cs == 0x23);\n\tif (!kernel_is_64bit)\n\t\tprintf(\"[NOTE]\\tNot a 64-bit kernel, won't test R8..R15 leaks\\n\");\n\n\t \n\tsyscall_addr = get_syscall(envp);\n\n\texitcode += run_syscall_twice();\n\tptrace_me();\n\texitcode += run_syscall_twice();\n\n\treturn exitcode;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}