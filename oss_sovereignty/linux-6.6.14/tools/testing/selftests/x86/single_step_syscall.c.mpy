{
  "module_name": "single_step_syscall.c",
  "hash_id": "1f0078703ba085d11203fd9efa4fb46f12d3ea016f991e6faf1cdc5b2efabc77",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/single_step_syscall.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <sys/time.h>\n#include <time.h>\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n#include <sys/mman.h>\n#include <sys/signal.h>\n#include <sys/ucontext.h>\n#include <asm/ldt.h>\n#include <err.h>\n#include <setjmp.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <sys/ptrace.h>\n#include <sys/user.h>\n\n#include \"helpers.h\"\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void clearhandler(int sig)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_DFL;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic volatile sig_atomic_t sig_traps, sig_eflags;\nsigjmp_buf jmpbuf;\n\n#ifdef __x86_64__\n# define REG_IP REG_RIP\n# define WIDTH \"q\"\n# define INT80_CLOBBERS \"r8\", \"r9\", \"r10\", \"r11\"\n#else\n# define REG_IP REG_EIP\n# define WIDTH \"l\"\n# define INT80_CLOBBERS\n#endif\n\nstatic void sigtrap(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\n\tif (get_eflags() & X86_EFLAGS_TF) {\n\t\tset_eflags(get_eflags() & ~X86_EFLAGS_TF);\n\t\tprintf(\"[WARN]\\tSIGTRAP handler had TF set\\n\");\n\t\t_exit(1);\n\t}\n\n\tsig_traps++;\n\n\tif (sig_traps == 10000 || sig_traps == 10001) {\n\t\tprintf(\"[WARN]\\tHit %d SIGTRAPs with si_addr 0x%lx, ip 0x%lx\\n\",\n\t\t       (int)sig_traps,\n\t\t       (unsigned long)info->si_addr,\n\t\t       (unsigned long)ctx->uc_mcontext.gregs[REG_IP]);\n\t}\n}\n\nstatic char const * const signames[] = {\n\t[SIGSEGV] = \"SIGSEGV\",\n\t[SIGBUS] = \"SIBGUS\",\n\t[SIGTRAP] = \"SIGTRAP\",\n\t[SIGILL] = \"SIGILL\",\n};\n\nstatic void print_and_longjmp(int sig, siginfo_t *si, void *ctx_void)\n{\n\tucontext_t *ctx = ctx_void;\n\n\tprintf(\"\\tGot %s with RIP=%lx, TF=%ld\\n\", signames[sig],\n\t       (unsigned long)ctx->uc_mcontext.gregs[REG_IP],\n\t       (unsigned long)ctx->uc_mcontext.gregs[REG_EFL] & X86_EFLAGS_TF);\n\n\tsig_eflags = (unsigned long)ctx->uc_mcontext.gregs[REG_EFL];\n\tsiglongjmp(jmpbuf, 1);\n}\n\nstatic void check_result(void)\n{\n\tunsigned long new_eflags = get_eflags();\n\tset_eflags(new_eflags & ~X86_EFLAGS_TF);\n\n\tif (!sig_traps) {\n\t\tprintf(\"[FAIL]\\tNo SIGTRAP\\n\");\n\t\texit(1);\n\t}\n\n\tif (!(new_eflags & X86_EFLAGS_TF)) {\n\t\tprintf(\"[FAIL]\\tTF was cleared\\n\");\n\t\texit(1);\n\t}\n\n\tprintf(\"[OK]\\tSurvived with TF set and %d traps\\n\", (int)sig_traps);\n\tsig_traps = 0;\n}\n\nstatic void fast_syscall_no_tf(void)\n{\n\tsig_traps = 0;\n\tprintf(\"[RUN]\\tFast syscall with TF cleared\\n\");\n\tfflush(stdout);   \n\tif (get_eflags() & X86_EFLAGS_TF) {\n\t\tprintf(\"[FAIL]\\tTF is now set\\n\");\n\t\texit(1);\n\t}\n\tif (sig_traps) {\n\t\tprintf(\"[FAIL]\\tGot SIGTRAP\\n\");\n\t\texit(1);\n\t}\n\tprintf(\"[OK]\\tNothing unexpected happened\\n\");\n}\n\nint main()\n{\n#ifdef CAN_BUILD_32\n\tint tmp;\n#endif\n\n\tsethandler(SIGTRAP, sigtrap, 0);\n\n\tprintf(\"[RUN]\\tSet TF and check nop\\n\");\n\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\tasm volatile (\"nop\");\n\tcheck_result();\n\n#ifdef __x86_64__\n\tprintf(\"[RUN]\\tSet TF and check syscall-less opportunistic sysret\\n\");\n\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\textern unsigned char post_nop[];\n\tasm volatile (\"pushf\" WIDTH \"\\n\\t\"\n\t\t      \"pop\" WIDTH \" %%r11\\n\\t\"\n\t\t      \"nop\\n\\t\"\n\t\t      \"post_nop:\"\n\t\t      : : \"c\" (post_nop) : \"r11\");\n\tcheck_result();\n#endif\n#ifdef CAN_BUILD_32\n\tprintf(\"[RUN]\\tSet TF and check int80\\n\");\n\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\tasm volatile (\"int $0x80\" : \"=a\" (tmp) : \"a\" (SYS_getpid)\n\t\t\t: INT80_CLOBBERS);\n\tcheck_result();\n#endif\n\n\t \n\tsyscall(SYS_getpid);   \n\tprintf(\"[RUN]\\tSet TF and check a fast syscall\\n\");\n\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\tsyscall(SYS_getpid);\n\tcheck_result();\n\n\t \n\tfast_syscall_no_tf();\n\n\t \n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tunsigned long nr = SYS_getpid;\n\t\tprintf(\"[RUN]\\tSet TF and check SYSENTER\\n\");\n\t\tstack_t stack = {\n\t\t\t.ss_sp = malloc(sizeof(char) * SIGSTKSZ),\n\t\t\t.ss_size = SIGSTKSZ,\n\t\t};\n\t\tif (sigaltstack(&stack, NULL) != 0)\n\t\t\terr(1, \"sigaltstack\");\n\t\tsethandler(SIGSEGV, print_and_longjmp,\n\t\t\t   SA_RESETHAND | SA_ONSTACK);\n\t\tsethandler(SIGILL, print_and_longjmp, SA_RESETHAND);\n\t\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\t\tfree(stack.ss_sp);\n\t\t \n\t\tasm volatile (\"xorl %%ebp, %%ebp; SYSENTER\" : \"+a\" (nr) :: \"flags\", \"rcx\"\n#ifdef __x86_64__\n\t\t\t\t, \"r11\"\n#endif\n\t\t\t);\n\n\t\t \n\t}\n\tclearhandler(SIGSEGV);\n\tclearhandler(SIGILL);\n\tif (!(sig_eflags & X86_EFLAGS_TF)) {\n\t\tprintf(\"[FAIL]\\tTF was cleared\\n\");\n\t\texit(1);\n\t}\n\n\t \n\tfast_syscall_no_tf();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}