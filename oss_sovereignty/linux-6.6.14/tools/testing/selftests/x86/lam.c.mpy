{
  "module_name": "lam.c",
  "hash_id": "b796559f55e3794e50c83c525aa9801a43bb895a634596e896f72f30b736d4a7",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/lam.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/syscall.h>\n#include <time.h>\n#include <signal.h>\n#include <setjmp.h>\n#include <sys/mman.h>\n#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <sched.h>\n\n#include <sys/uio.h>\n#include <linux/io_uring.h>\n#include \"../kselftest.h\"\n\n#ifndef __x86_64__\n# error This test is 64-bit only\n#endif\n\n \n#define LAM_NONE                0\n#define LAM_U57_BITS            6\n\n#define LAM_U57_MASK            (0x3fULL << 57)\n \n#define ARCH_GET_UNTAG_MASK     0x4001\n#define ARCH_ENABLE_TAGGED_ADDR 0x4002\n#define ARCH_GET_MAX_TAG_BITS   0x4003\n#define ARCH_FORCE_TAGGED_SVA\t0x4004\n\n \n#define FUNC_MALLOC             0x1\n#define FUNC_BITS               0x2\n#define FUNC_MMAP               0x4\n#define FUNC_SYSCALL            0x8\n#define FUNC_URING              0x10\n#define FUNC_INHERITE           0x20\n#define FUNC_PASID              0x40\n\n#define TEST_MASK               0x7f\n\n#define LOW_ADDR                (0x1UL << 30)\n#define HIGH_ADDR               (0x3UL << 48)\n\n#define MALLOC_LEN              32\n\n#define PAGE_SIZE               (4 << 10)\n\n#define STACK_SIZE\t\t65536\n\n#define barrier() ({\t\t\t\t\t\t\\\n\t\t   __asm__ __volatile__(\"\" : : : \"memory\");\t\\\n})\n\n#define URING_QUEUE_SZ 1\n#define URING_BLOCK_SZ 2048\n\n \n#define LAM_CMD_BIT 0x1\n#define PAS_CMD_BIT 0x2\n#define SVA_CMD_BIT 0x4\n\n#define PAS_CMD(cmd1, cmd2, cmd3) (((cmd3) << 8) | ((cmd2) << 4) | ((cmd1) << 0))\n\nstruct testcases {\n\tunsigned int later;\n\tint expected;  \n\tunsigned long lam;\n\tuint64_t addr;\n\tuint64_t cmd;\n\tint (*test_func)(struct testcases *test);\n\tconst char *msg;\n};\n\n \nstruct file_io {\n\tint file_fd;\n\toff_t file_sz;\n\tstruct iovec iovecs[];\n};\n\nstruct io_uring_queue {\n\tunsigned int *head;\n\tunsigned int *tail;\n\tunsigned int *ring_mask;\n\tunsigned int *ring_entries;\n\tunsigned int *flags;\n\tunsigned int *array;\n\tunion {\n\t\tstruct io_uring_cqe *cqes;\n\t\tstruct io_uring_sqe *sqes;\n\t} queue;\n\tsize_t ring_sz;\n};\n\nstruct io_ring {\n\tint ring_fd;\n\tstruct io_uring_queue sq_ring;\n\tstruct io_uring_queue cq_ring;\n};\n\nint tests_cnt;\njmp_buf segv_env;\n\nstatic void segv_handler(int sig)\n{\n\tksft_print_msg(\"Get segmentation fault(%d).\", sig);\n\n\tsiglongjmp(segv_env, 1);\n}\n\nstatic inline int cpu_has_lam(void)\n{\n\tunsigned int cpuinfo[4];\n\n\t__cpuid_count(0x7, 1, cpuinfo[0], cpuinfo[1], cpuinfo[2], cpuinfo[3]);\n\n\treturn (cpuinfo[0] & (1 << 26));\n}\n\n \nstatic inline int cpu_has_la57(void)\n{\n\tunsigned int cpuinfo[4];\n\n\t__cpuid_count(0x7, 0, cpuinfo[0], cpuinfo[1], cpuinfo[2], cpuinfo[3]);\n\n\treturn (cpuinfo[2] & (1 << 16));\n}\n\n \nstatic int set_lam(unsigned long lam)\n{\n\tint ret = 0;\n\tuint64_t ptr = 0;\n\n\tif (lam != LAM_U57_BITS && lam != LAM_NONE)\n\t\treturn -1;\n\n\t \n\tsyscall(SYS_arch_prctl, ARCH_ENABLE_TAGGED_ADDR, lam);\n\n\t \n\tsyscall(SYS_arch_prctl, ARCH_GET_UNTAG_MASK, &ptr);\n\n\t \n\tif (lam == LAM_U57_BITS)\n\t\tret = (ptr != ~(LAM_U57_MASK));\n\telse if (lam == LAM_NONE)\n\t\tret = (ptr != -1ULL);\n\n\treturn ret;\n}\n\nstatic unsigned long get_default_tag_bits(void)\n{\n\tpid_t pid;\n\tint lam = LAM_NONE;\n\tint ret = 0;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"Fork failed.\");\n\t} else if (pid == 0) {\n\t\t \n\t\tif (set_lam(LAM_U57_BITS) == 0)\n\t\t\tlam = LAM_U57_BITS;\n\t\telse\n\t\t\tlam = LAM_NONE;\n\t\texit(lam);\n\t} else {\n\t\twait(&ret);\n\t\tlam = WEXITSTATUS(ret);\n\t}\n\n\treturn lam;\n}\n\n \nstatic int get_lam(void)\n{\n\tuint64_t ptr = 0;\n\tint ret = -1;\n\t \n\tif (syscall(SYS_arch_prctl, ARCH_GET_UNTAG_MASK, &ptr) == -1)\n\t\treturn -1;\n\n\t \n\tif (ptr == ~(LAM_U57_MASK))\n\t\tret = LAM_U57_BITS;\n\telse if (ptr == -1ULL)\n\t\tret = LAM_NONE;\n\n\n\treturn ret;\n}\n\n \nstatic uint64_t set_metadata(uint64_t src, unsigned long lam)\n{\n\tuint64_t metadata;\n\n\tsrand(time(NULL));\n\n\tswitch (lam) {\n\tcase LAM_U57_BITS:  \n\t\t \n\t\tmetadata = (rand() % ((1UL << LAM_U57_BITS) - 1) + 1) << 57;\n\t\tmetadata |= (src & ~(LAM_U57_MASK));\n\t\tbreak;\n\tdefault:\n\t\tmetadata = src;\n\t\tbreak;\n\t}\n\n\treturn metadata;\n}\n\n \nstatic int handle_lam_test(void *src, unsigned int lam)\n{\n\tchar *ptr;\n\n\tstrcpy((char *)src, \"USER POINTER\");\n\n\tptr = (char *)set_metadata((uint64_t)src, lam);\n\tif (src == ptr)\n\t\treturn 0;\n\n\t \n\tstrcpy((char *)ptr, \"METADATA POINTER\");\n\n\treturn (!!strcmp((char *)src, (char *)ptr));\n}\n\n\nint handle_max_bits(struct testcases *test)\n{\n\tunsigned long exp_bits = get_default_tag_bits();\n\tunsigned long bits = 0;\n\n\tif (exp_bits != LAM_NONE)\n\t\texp_bits = LAM_U57_BITS;\n\n\t \n\tif (syscall(SYS_arch_prctl, ARCH_GET_MAX_TAG_BITS, &bits) == -1)\n\t\treturn 1;\n\n\treturn (exp_bits != bits);\n}\n\n \nstatic int handle_malloc(struct testcases *test)\n{\n\tchar *ptr = NULL;\n\tint ret = 0;\n\n\tif (test->later == 0 && test->lam != 0)\n\t\tif (set_lam(test->lam) == -1)\n\t\t\treturn 1;\n\n\tptr = (char *)malloc(MALLOC_LEN);\n\tif (ptr == NULL) {\n\t\tperror(\"malloc() failure\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (sigsetjmp(segv_env, 1) == 0) {\n\t\tsignal(SIGSEGV, segv_handler);\n\t\tret = handle_lam_test(ptr, test->lam);\n\t} else {\n\t\tret = 2;\n\t}\n\n\tif (test->later != 0 && test->lam != 0)\n\t\tif (set_lam(test->lam) == -1 && ret == 0)\n\t\t\tret = 1;\n\n\tfree(ptr);\n\n\treturn ret;\n}\n\nstatic int handle_mmap(struct testcases *test)\n{\n\tvoid *ptr;\n\tunsigned int flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED;\n\tint ret = 0;\n\n\tif (test->later == 0 && test->lam != 0)\n\t\tif (set_lam(test->lam) != 0)\n\t\t\treturn 1;\n\n\tptr = mmap((void *)test->addr, PAGE_SIZE, PROT_READ | PROT_WRITE,\n\t\t   flags, -1, 0);\n\tif (ptr == MAP_FAILED) {\n\t\tif (test->addr == HIGH_ADDR)\n\t\t\tif (!cpu_has_la57())\n\t\t\t\treturn 3;  \n\t\treturn 1;\n\t}\n\n\tif (test->later != 0 && test->lam != 0)\n\t\tif (set_lam(test->lam) != 0)\n\t\t\tret = 1;\n\n\tif (ret == 0) {\n\t\tif (sigsetjmp(segv_env, 1) == 0) {\n\t\t\tsignal(SIGSEGV, segv_handler);\n\t\t\tret = handle_lam_test(ptr, test->lam);\n\t\t} else {\n\t\t\tret = 2;\n\t\t}\n\t}\n\n\tmunmap(ptr, PAGE_SIZE);\n\treturn ret;\n}\n\nstatic int handle_syscall(struct testcases *test)\n{\n\tstruct utsname unme, *pu;\n\tint ret = 0;\n\n\tif (test->later == 0 && test->lam != 0)\n\t\tif (set_lam(test->lam) != 0)\n\t\t\treturn 1;\n\n\tif (sigsetjmp(segv_env, 1) == 0) {\n\t\tsignal(SIGSEGV, segv_handler);\n\t\tpu = (struct utsname *)set_metadata((uint64_t)&unme, test->lam);\n\t\tret = uname(pu);\n\t\tif (ret < 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = 2;\n\t}\n\n\tif (test->later != 0 && test->lam != 0)\n\t\tif (set_lam(test->lam) != -1 && ret == 0)\n\t\t\tret = 1;\n\n\treturn ret;\n}\n\nint sys_uring_setup(unsigned int entries, struct io_uring_params *p)\n{\n\treturn (int)syscall(__NR_io_uring_setup, entries, p);\n}\n\nint sys_uring_enter(int fd, unsigned int to, unsigned int min, unsigned int flags)\n{\n\treturn (int)syscall(__NR_io_uring_enter, fd, to, min, flags, NULL, 0);\n}\n\n \nint mmap_io_uring(struct io_uring_params p, struct io_ring *s)\n{\n\tstruct io_uring_queue *sring = &s->sq_ring;\n\tstruct io_uring_queue *cring = &s->cq_ring;\n\n\tsring->ring_sz = p.sq_off.array + p.sq_entries * sizeof(unsigned int);\n\tcring->ring_sz = p.cq_off.cqes + p.cq_entries * sizeof(struct io_uring_cqe);\n\n\tif (p.features & IORING_FEAT_SINGLE_MMAP) {\n\t\tif (cring->ring_sz > sring->ring_sz)\n\t\t\tsring->ring_sz = cring->ring_sz;\n\n\t\tcring->ring_sz = sring->ring_sz;\n\t}\n\n\tvoid *sq_ptr = mmap(0, sring->ring_sz, PROT_READ | PROT_WRITE,\n\t\t\t    MAP_SHARED | MAP_POPULATE, s->ring_fd,\n\t\t\t    IORING_OFF_SQ_RING);\n\n\tif (sq_ptr == MAP_FAILED) {\n\t\tperror(\"sub-queue!\");\n\t\treturn 1;\n\t}\n\n\tvoid *cq_ptr = sq_ptr;\n\n\tif (!(p.features & IORING_FEAT_SINGLE_MMAP)) {\n\t\tcq_ptr = mmap(0, cring->ring_sz, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_POPULATE, s->ring_fd,\n\t\t\t      IORING_OFF_CQ_RING);\n\t\tif (cq_ptr == MAP_FAILED) {\n\t\t\tperror(\"cpl-queue!\");\n\t\t\tmunmap(sq_ptr, sring->ring_sz);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tsring->head = sq_ptr + p.sq_off.head;\n\tsring->tail = sq_ptr + p.sq_off.tail;\n\tsring->ring_mask = sq_ptr + p.sq_off.ring_mask;\n\tsring->ring_entries = sq_ptr + p.sq_off.ring_entries;\n\tsring->flags = sq_ptr + p.sq_off.flags;\n\tsring->array = sq_ptr + p.sq_off.array;\n\n\t \n\ts->sq_ring.queue.sqes = mmap(0, p.sq_entries * sizeof(struct io_uring_sqe),\n\t\t\t\t     PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,\n\t\t\t\t     s->ring_fd, IORING_OFF_SQES);\n\tif (s->sq_ring.queue.sqes == MAP_FAILED) {\n\t\tmunmap(sq_ptr, sring->ring_sz);\n\t\tif (sq_ptr != cq_ptr) {\n\t\t\tksft_print_msg(\"failed to mmap uring queue!\");\n\t\t\tmunmap(cq_ptr, cring->ring_sz);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcring->head = cq_ptr + p.cq_off.head;\n\tcring->tail = cq_ptr + p.cq_off.tail;\n\tcring->ring_mask = cq_ptr + p.cq_off.ring_mask;\n\tcring->ring_entries = cq_ptr + p.cq_off.ring_entries;\n\tcring->queue.cqes = cq_ptr + p.cq_off.cqes;\n\n\treturn 0;\n}\n\n \nint setup_io_uring(struct io_ring *s)\n{\n\tstruct io_uring_params para;\n\n\tmemset(&para, 0, sizeof(para));\n\ts->ring_fd = sys_uring_setup(URING_QUEUE_SZ, &para);\n\tif (s->ring_fd < 0)\n\t\treturn 1;\n\n\treturn mmap_io_uring(para, s);\n}\n\n \nint handle_uring_cq(struct io_ring *s)\n{\n\tstruct file_io *fi = NULL;\n\tstruct io_uring_queue *cring = &s->cq_ring;\n\tstruct io_uring_cqe *cqe;\n\tunsigned int head;\n\toff_t len = 0;\n\n\thead = *cring->head;\n\n\tdo {\n\t\tbarrier();\n\t\tif (head == *cring->tail)\n\t\t\tbreak;\n\t\t \n\t\tcqe = &cring->queue.cqes[head & *s->cq_ring.ring_mask];\n\t\tfi = (struct file_io *)cqe->user_data;\n\t\tif (cqe->res < 0)\n\t\t\tbreak;\n\n\t\tint blocks = (int)(fi->file_sz + URING_BLOCK_SZ - 1) / URING_BLOCK_SZ;\n\n\t\tfor (int i = 0; i < blocks; i++)\n\t\t\tlen += fi->iovecs[i].iov_len;\n\n\t\thead++;\n\t} while (1);\n\n\t*cring->head = head;\n\tbarrier();\n\n\treturn (len != fi->file_sz);\n}\n\n \nint handle_uring_sq(struct io_ring *ring, struct file_io *fi, unsigned long lam)\n{\n\tint file_fd = fi->file_fd;\n\tstruct io_uring_queue *sring = &ring->sq_ring;\n\tunsigned int index = 0, cur_block = 0, tail = 0, next_tail = 0;\n\tstruct io_uring_sqe *sqe;\n\n\toff_t remain = fi->file_sz;\n\tint blocks = (int)(remain + URING_BLOCK_SZ - 1) / URING_BLOCK_SZ;\n\n\twhile (remain) {\n\t\toff_t bytes = remain;\n\t\tvoid *buf;\n\n\t\tif (bytes > URING_BLOCK_SZ)\n\t\t\tbytes = URING_BLOCK_SZ;\n\n\t\tfi->iovecs[cur_block].iov_len = bytes;\n\n\t\tif (posix_memalign(&buf, URING_BLOCK_SZ, URING_BLOCK_SZ))\n\t\t\treturn 1;\n\n\t\tfi->iovecs[cur_block].iov_base = (void *)set_metadata((uint64_t)buf, lam);\n\t\tremain -= bytes;\n\t\tcur_block++;\n\t}\n\n\tnext_tail = *sring->tail;\n\ttail = next_tail;\n\tnext_tail++;\n\n\tbarrier();\n\n\tindex = tail & *ring->sq_ring.ring_mask;\n\n\tsqe = &ring->sq_ring.queue.sqes[index];\n\tsqe->fd = file_fd;\n\tsqe->flags = 0;\n\tsqe->opcode = IORING_OP_READV;\n\tsqe->addr = (unsigned long)fi->iovecs;\n\tsqe->len = blocks;\n\tsqe->off = 0;\n\tsqe->user_data = (uint64_t)fi;\n\n\tsring->array[index] = index;\n\ttail = next_tail;\n\n\tif (*sring->tail != tail) {\n\t\t*sring->tail = tail;\n\t\tbarrier();\n\t}\n\n\tif (sys_uring_enter(ring->ring_fd, 1, 1, IORING_ENTER_GETEVENTS) < 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nint do_uring(unsigned long lam)\n{\n\tstruct io_ring *ring;\n\tstruct file_io *fi;\n\tstruct stat st;\n\tint ret = 1;\n\tchar path[PATH_MAX] = {0};\n\n\t \n\tif (readlink(\"/proc/self/exe\", path, PATH_MAX - 1) <= 0)\n\t\treturn 1;\n\n\tint file_fd = open(path, O_RDONLY);\n\n\tif (file_fd < 0)\n\t\treturn 1;\n\n\tif (fstat(file_fd, &st) < 0)\n\t\treturn 1;\n\n\toff_t file_sz = st.st_size;\n\n\tint blocks = (int)(file_sz + URING_BLOCK_SZ - 1) / URING_BLOCK_SZ;\n\n\tfi = malloc(sizeof(*fi) + sizeof(struct iovec) * blocks);\n\tif (!fi)\n\t\treturn 1;\n\n\tfi->file_sz = file_sz;\n\tfi->file_fd = file_fd;\n\n\tring = malloc(sizeof(*ring));\n\tif (!ring)\n\t\treturn 1;\n\n\tmemset(ring, 0, sizeof(struct io_ring));\n\n\tif (setup_io_uring(ring))\n\t\tgoto out;\n\n\tif (handle_uring_sq(ring, fi, lam))\n\t\tgoto out;\n\n\tret = handle_uring_cq(ring);\n\nout:\n\tfree(ring);\n\n\tfor (int i = 0; i < blocks; i++) {\n\t\tif (fi->iovecs[i].iov_base) {\n\t\t\tuint64_t addr = ((uint64_t)fi->iovecs[i].iov_base);\n\n\t\t\tswitch (lam) {\n\t\t\tcase LAM_U57_BITS:  \n\t\t\t\taddr = (addr & ~(LAM_U57_MASK));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree((void *)addr);\n\t\t\tfi->iovecs[i].iov_base = NULL;\n\t\t}\n\t}\n\n\tfree(fi);\n\n\treturn ret;\n}\n\nint handle_uring(struct testcases *test)\n{\n\tint ret = 0;\n\n\tif (test->later == 0 && test->lam != 0)\n\t\tif (set_lam(test->lam) != 0)\n\t\t\treturn 1;\n\n\tif (sigsetjmp(segv_env, 1) == 0) {\n\t\tsignal(SIGSEGV, segv_handler);\n\t\tret = do_uring(test->lam);\n\t} else {\n\t\tret = 2;\n\t}\n\n\treturn ret;\n}\n\nstatic int fork_test(struct testcases *test)\n{\n\tint ret, child_ret;\n\tpid_t pid;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"Fork failed.\");\n\t\tret = 1;\n\t} else if (pid == 0) {\n\t\tret = test->test_func(test);\n\t\texit(ret);\n\t} else {\n\t\twait(&child_ret);\n\t\tret = WEXITSTATUS(child_ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int handle_execve(struct testcases *test)\n{\n\tint ret, child_ret;\n\tint lam = test->lam;\n\tpid_t pid;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"Fork failed.\");\n\t\tret = 1;\n\t} else if (pid == 0) {\n\t\tchar path[PATH_MAX] = {0};\n\n\t\t \n\t\tif (set_lam(lam) != 0)\n\t\t\treturn 1;\n\n\t\t \n\t\tif (readlink(\"/proc/self/exe\", path, PATH_MAX - 1) <= 0)\n\t\t\texit(-1);\n\n\t\t \n\t\tif (execlp(path, path, \"-t 0x0\", NULL) < 0) {\n\t\t\tperror(\"error on exec\");\n\t\t\texit(-1);\n\t\t}\n\t} else {\n\t\twait(&child_ret);\n\t\tret = WEXITSTATUS(child_ret);\n\t\tif (ret != LAM_NONE)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_inheritance(struct testcases *test)\n{\n\tint ret, child_ret;\n\tint lam = test->lam;\n\tpid_t pid;\n\n\t \n\tif (set_lam(lam) != 0)\n\t\treturn 1;\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tperror(\"Fork failed.\");\n\t\treturn 1;\n\t} else if (pid == 0) {\n\t\t \n\t\tint child_lam = get_lam();\n\n\t\texit(child_lam);\n\t} else {\n\t\twait(&child_ret);\n\t\tret = WEXITSTATUS(child_ret);\n\n\t\tif (lam != ret)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int thread_fn_get_lam(void *arg)\n{\n\treturn get_lam();\n}\n\nstatic int thread_fn_set_lam(void *arg)\n{\n\tstruct testcases *test = arg;\n\n\treturn set_lam(test->lam);\n}\n\nstatic int handle_thread(struct testcases *test)\n{\n\tchar stack[STACK_SIZE];\n\tint ret, child_ret;\n\tint lam = 0;\n\tpid_t pid;\n\n\t \n\tif (!test->later) {\n\t\tlam = test->lam;\n\t\tif (set_lam(lam) != 0)\n\t\t\treturn 1;\n\t}\n\n\tpid = clone(thread_fn_get_lam, stack + STACK_SIZE,\n\t\t    SIGCHLD | CLONE_FILES | CLONE_FS | CLONE_VM, NULL);\n\tif (pid < 0) {\n\t\tperror(\"Clone failed.\");\n\t\treturn 1;\n\t}\n\n\twaitpid(pid, &child_ret, 0);\n\tret = WEXITSTATUS(child_ret);\n\n\tif (lam != ret)\n\t\treturn 1;\n\n\tif (test->later) {\n\t\tif (set_lam(test->lam) != 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_thread_enable(struct testcases *test)\n{\n\tchar stack[STACK_SIZE];\n\tint ret, child_ret;\n\tint lam = test->lam;\n\tpid_t pid;\n\n\tpid = clone(thread_fn_set_lam, stack + STACK_SIZE,\n\t\t    SIGCHLD | CLONE_FILES | CLONE_FS | CLONE_VM, test);\n\tif (pid < 0) {\n\t\tperror(\"Clone failed.\");\n\t\treturn 1;\n\t}\n\n\twaitpid(pid, &child_ret, 0);\n\tret = WEXITSTATUS(child_ret);\n\n\tif (lam != ret)\n\t\treturn 1;\n\n\treturn 0;\n}\nstatic void run_test(struct testcases *test, int count)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct testcases *t = test + i;\n\n\t\t \n\t\ttests_cnt++;\n\t\tret = fork_test(t);\n\n\t\t \n\t\tif (ret == 3) {\n\t\t\tksft_test_result_skip(t->msg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret != 0)\n\t\t\tret = (t->expected == ret);\n\t\telse\n\t\t\tret = !(t->expected);\n\n\t\tksft_test_result(ret, t->msg);\n\t}\n}\n\nstatic struct testcases uring_cases[] = {\n\t{\n\t\t.later = 0,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_uring,\n\t\t.msg = \"URING: LAM_U57. Dereferencing pointer with metadata\\n\",\n\t},\n\t{\n\t\t.later = 1,\n\t\t.expected = 1,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_uring,\n\t\t.msg = \"URING:[Negative] Disable LAM. Dereferencing pointer with metadata.\\n\",\n\t},\n};\n\nstatic struct testcases malloc_cases[] = {\n\t{\n\t\t.later = 0,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_malloc,\n\t\t.msg = \"MALLOC: LAM_U57. Dereferencing pointer with metadata\\n\",\n\t},\n\t{\n\t\t.later = 1,\n\t\t.expected = 2,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_malloc,\n\t\t.msg = \"MALLOC:[Negative] Disable LAM. Dereferencing pointer with metadata.\\n\",\n\t},\n};\n\nstatic struct testcases bits_cases[] = {\n\t{\n\t\t.test_func = handle_max_bits,\n\t\t.msg = \"BITS: Check default tag bits\\n\",\n\t},\n};\n\nstatic struct testcases syscall_cases[] = {\n\t{\n\t\t.later = 0,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_syscall,\n\t\t.msg = \"SYSCALL: LAM_U57. syscall with metadata\\n\",\n\t},\n\t{\n\t\t.later = 1,\n\t\t.expected = 1,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_syscall,\n\t\t.msg = \"SYSCALL:[Negative] Disable LAM. Dereferencing pointer with metadata.\\n\",\n\t},\n};\n\nstatic struct testcases mmap_cases[] = {\n\t{\n\t\t.later = 1,\n\t\t.expected = 0,\n\t\t.lam = LAM_U57_BITS,\n\t\t.addr = HIGH_ADDR,\n\t\t.test_func = handle_mmap,\n\t\t.msg = \"MMAP: First mmap high address, then set LAM_U57.\\n\",\n\t},\n\t{\n\t\t.later = 0,\n\t\t.expected = 0,\n\t\t.lam = LAM_U57_BITS,\n\t\t.addr = HIGH_ADDR,\n\t\t.test_func = handle_mmap,\n\t\t.msg = \"MMAP: First LAM_U57, then High address.\\n\",\n\t},\n\t{\n\t\t.later = 0,\n\t\t.expected = 0,\n\t\t.lam = LAM_U57_BITS,\n\t\t.addr = LOW_ADDR,\n\t\t.test_func = handle_mmap,\n\t\t.msg = \"MMAP: First LAM_U57, then Low address.\\n\",\n\t},\n};\n\nstatic struct testcases inheritance_cases[] = {\n\t{\n\t\t.expected = 0,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_inheritance,\n\t\t.msg = \"FORK: LAM_U57, child process should get LAM mode same as parent\\n\",\n\t},\n\t{\n\t\t.expected = 0,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_thread,\n\t\t.msg = \"THREAD: LAM_U57, child thread should get LAM mode same as parent\\n\",\n\t},\n\t{\n\t\t.expected = 1,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_thread_enable,\n\t\t.msg = \"THREAD: [NEGATIVE] Enable LAM in child.\\n\",\n\t},\n\t{\n\t\t.expected = 1,\n\t\t.later = 1,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_thread,\n\t\t.msg = \"THREAD: [NEGATIVE] Enable LAM in parent after thread created.\\n\",\n\t},\n\t{\n\t\t.expected = 0,\n\t\t.lam = LAM_U57_BITS,\n\t\t.test_func = handle_execve,\n\t\t.msg = \"EXECVE: LAM_U57, child process should get disabled LAM mode\\n\",\n\t},\n};\n\nstatic void cmd_help(void)\n{\n\tprintf(\"usage: lam [-h] [-t test list]\\n\");\n\tprintf(\"\\t-t test list: run tests specified in the test list, default:0x%x\\n\", TEST_MASK);\n\tprintf(\"\\t\\t0x1:malloc; 0x2:max_bits; 0x4:mmap; 0x8:syscall; 0x10:io_uring; 0x20:inherit;\\n\");\n\tprintf(\"\\t-h: help\\n\");\n}\n\n \nuint8_t file_Exists(const char *fileName)\n{\n\tstruct stat buffer;\n\n\tuint8_t ret = (stat(fileName, &buffer) == 0);\n\n\treturn ret;\n}\n\n \nconst char *dsa_configs[] = {\n\t\"echo 1 > /sys/bus/dsa/devices/dsa0/wq0.1/group_id\",\n\t\"echo shared > /sys/bus/dsa/devices/dsa0/wq0.1/mode\",\n\t\"echo 10 > /sys/bus/dsa/devices/dsa0/wq0.1/priority\",\n\t\"echo 16 > /sys/bus/dsa/devices/dsa0/wq0.1/size\",\n\t\"echo 15 > /sys/bus/dsa/devices/dsa0/wq0.1/threshold\",\n\t\"echo user > /sys/bus/dsa/devices/dsa0/wq0.1/type\",\n\t\"echo MyApp1 > /sys/bus/dsa/devices/dsa0/wq0.1/name\",\n\t\"echo 1 > /sys/bus/dsa/devices/dsa0/engine0.1/group_id\",\n\t\"echo dsa0 > /sys/bus/dsa/drivers/idxd/bind\",\n\t \n\t\"echo wq0.1 > /sys/bus/dsa/drivers/user/bind\",\n};\n\n \nconst char *dsaDeviceFile = \"/dev/dsa/wq0.1\";\n \nconst char *dsaPasidEnable = \"/sys/bus/dsa/devices/dsa0/pasid_enabled\";\n\n \nint Check_DSA_Kernel_Setting(void)\n{\n\tchar command[256] = \"\";\n\tchar buf[256] = \"\";\n\tchar *ptr;\n\tint rv = -1;\n\n\tsnprintf(command, sizeof(command) - 1, \"cat %s\", dsaPasidEnable);\n\n\tFILE *cmd = popen(command, \"r\");\n\n\tif (cmd) {\n\t\twhile (fgets(buf, sizeof(buf) - 1, cmd) != NULL);\n\n\t\tpclose(cmd);\n\t\trv = strtol(buf, &ptr, 16);\n\t}\n\n\treturn rv;\n}\n\n \nint Dsa_Init_Sysfs(void)\n{\n\tuint len = ARRAY_SIZE(dsa_configs);\n\tconst char **p = dsa_configs;\n\n\tif (file_Exists(dsaDeviceFile) == 1)\n\t\treturn 0;\n\n\t \n\tif (file_Exists(dsaPasidEnable) != 1) {\n\t\tprintf(\"Please make sure idxd driver was loaded\\n\");\n\t\treturn 3;\n\t}\n\n\t \n\tif (Check_DSA_Kernel_Setting() != 1) {\n\t\tprintf(\"Please enable SVA.(Add intel_iommu=on,sm_on in kernel cmdline)\\n\");\n\t\treturn 3;\n\t}\n\n\t \n\tfor (int i = 0; i < len; i++) {\n\t\tif (system(p[i]))\n\t\t\treturn 1;\n\t}\n\n\t \n\treturn (file_Exists(dsaDeviceFile) != 1);\n}\n\n \nvoid *allocate_dsa_pasid(void)\n{\n\tint fd;\n\tvoid *wq;\n\n\tfd = open(dsaDeviceFile, O_RDWR);\n\tif (fd < 0) {\n\t\tperror(\"open\");\n\t\treturn MAP_FAILED;\n\t}\n\n\twq = mmap(NULL, 0x1000, PROT_WRITE,\n\t\t\t   MAP_SHARED | MAP_POPULATE, fd, 0);\n\tif (wq == MAP_FAILED)\n\t\tperror(\"mmap\");\n\n\treturn wq;\n}\n\nint set_force_svm(void)\n{\n\tint ret = 0;\n\n\tret = syscall(SYS_arch_prctl, ARCH_FORCE_TAGGED_SVA);\n\n\treturn ret;\n}\n\nint handle_pasid(struct testcases *test)\n{\n\tuint tmp = test->cmd;\n\tuint runed = 0x0;\n\tint ret = 0;\n\tvoid *wq = NULL;\n\n\tret = Dsa_Init_Sysfs();\n\tif (ret != 0)\n\t\treturn ret;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tint err = 0;\n\n\t\tif (tmp & 0x1) {\n\t\t\t \n\t\t\tif ((runed & 0x1) == 0)\t{\n\t\t\t\terr = set_lam(LAM_U57_BITS);\n\t\t\t\truned = runed | 0x1;\n\t\t\t} else\n\t\t\t\terr = 1;\n\t\t} else if (tmp & 0x4) {\n\t\t\t \n\t\t\tif ((runed & 0x4) == 0)\t{\n\t\t\t\terr = set_force_svm();\n\t\t\t\truned = runed | 0x4;\n\t\t\t} else\n\t\t\t\terr = 1;\n\t\t} else if (tmp & 0x2) {\n\t\t\t \n\t\t\tif ((runed & 0x2) == 0) {\n\t\t\t\truned = runed | 0x2;\n\t\t\t\twq = allocate_dsa_pasid();\n\t\t\t\tif (wq == MAP_FAILED)\n\t\t\t\t\terr = 1;\n\t\t\t} else\n\t\t\t\terr = 1;\n\t\t}\n\n\t\tret = ret + err;\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\ttmp = tmp >> 4;\n\t}\n\n\tif (wq != MAP_FAILED && wq != NULL)\n\t\tif (munmap(wq, 0x1000))\n\t\t\tprintf(\"munmap failed %d\\n\", errno);\n\n\tif (runed != 0x7)\n\t\tret = 1;\n\n\treturn (ret != 0);\n}\n\n \nstatic struct testcases pasid_cases[] = {\n\t{\n\t\t.expected = 1,\n\t\t.cmd = PAS_CMD(LAM_CMD_BIT, PAS_CMD_BIT, SVA_CMD_BIT),\n\t\t.test_func = handle_pasid,\n\t\t.msg = \"PASID: [Negative] Execute LAM, PASID, SVA in sequence\\n\",\n\t},\n\t{\n\t\t.expected = 0,\n\t\t.cmd = PAS_CMD(LAM_CMD_BIT, SVA_CMD_BIT, PAS_CMD_BIT),\n\t\t.test_func = handle_pasid,\n\t\t.msg = \"PASID: Execute LAM, SVA, PASID in sequence\\n\",\n\t},\n\t{\n\t\t.expected = 1,\n\t\t.cmd = PAS_CMD(PAS_CMD_BIT, LAM_CMD_BIT, SVA_CMD_BIT),\n\t\t.test_func = handle_pasid,\n\t\t.msg = \"PASID: [Negative] Execute PASID, LAM, SVA in sequence\\n\",\n\t},\n\t{\n\t\t.expected = 0,\n\t\t.cmd = PAS_CMD(PAS_CMD_BIT, SVA_CMD_BIT, LAM_CMD_BIT),\n\t\t.test_func = handle_pasid,\n\t\t.msg = \"PASID: Execute PASID, SVA, LAM in sequence\\n\",\n\t},\n\t{\n\t\t.expected = 0,\n\t\t.cmd = PAS_CMD(SVA_CMD_BIT, LAM_CMD_BIT, PAS_CMD_BIT),\n\t\t.test_func = handle_pasid,\n\t\t.msg = \"PASID: Execute SVA, LAM, PASID in sequence\\n\",\n\t},\n\t{\n\t\t.expected = 0,\n\t\t.cmd = PAS_CMD(SVA_CMD_BIT, PAS_CMD_BIT, LAM_CMD_BIT),\n\t\t.test_func = handle_pasid,\n\t\t.msg = \"PASID: Execute SVA, PASID, LAM in sequence\\n\",\n\t},\n};\n\nint main(int argc, char **argv)\n{\n\tint c = 0;\n\tunsigned int tests = TEST_MASK;\n\n\ttests_cnt = 0;\n\n\tif (!cpu_has_lam()) {\n\t\tksft_print_msg(\"Unsupported LAM feature!\\n\");\n\t\treturn -1;\n\t}\n\n\twhile ((c = getopt(argc, argv, \"ht:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 't':\n\t\t\ttests = strtoul(optarg, NULL, 16);\n\t\t\tif (tests && !(tests & TEST_MASK)) {\n\t\t\t\tksft_print_msg(\"Invalid argument!\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tcmd_help();\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tksft_print_msg(\"Invalid argument\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif (!tests)\n\t\treturn (get_lam());\n\n\t \n\tif (tests & FUNC_MALLOC)\n\t\trun_test(malloc_cases, ARRAY_SIZE(malloc_cases));\n\n\tif (tests & FUNC_BITS)\n\t\trun_test(bits_cases, ARRAY_SIZE(bits_cases));\n\n\tif (tests & FUNC_MMAP)\n\t\trun_test(mmap_cases, ARRAY_SIZE(mmap_cases));\n\n\tif (tests & FUNC_SYSCALL)\n\t\trun_test(syscall_cases, ARRAY_SIZE(syscall_cases));\n\n\tif (tests & FUNC_URING)\n\t\trun_test(uring_cases, ARRAY_SIZE(uring_cases));\n\n\tif (tests & FUNC_INHERITE)\n\t\trun_test(inheritance_cases, ARRAY_SIZE(inheritance_cases));\n\n\tif (tests & FUNC_PASID)\n\t\trun_test(pasid_cases, ARRAY_SIZE(pasid_cases));\n\n\tksft_set_plan(tests_cnt);\n\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}