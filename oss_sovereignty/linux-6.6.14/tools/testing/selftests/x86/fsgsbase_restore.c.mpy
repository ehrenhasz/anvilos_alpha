{
  "module_name": "fsgsbase_restore.c",
  "hash_id": "8fbe072a23c1eef5ded99a55318ff04f61fc8efa52ce67b707b20fedb4f16f97",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/fsgsbase_restore.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <err.h>\n#include <sys/user.h>\n#include <asm/prctl.h>\n#include <sys/prctl.h>\n#include <asm/ldt.h>\n#include <sys/mman.h>\n#include <stddef.h>\n#include <sys/ptrace.h>\n#include <sys/wait.h>\n#include <stdint.h>\n\n#define EXPECTED_VALUE 0x1337f00d\n\n#ifdef __x86_64__\n# define SEG \"%gs\"\n#else\n# define SEG \"%fs\"\n#endif\n\nstatic unsigned int dereference_seg_base(void)\n{\n\tint ret;\n\tasm volatile (\"mov %\" SEG \":(0), %0\" : \"=rm\" (ret));\n\treturn ret;\n}\n\nstatic void init_seg(void)\n{\n\tunsigned int *target = mmap(\n\t\tNULL, sizeof(unsigned int),\n\t\tPROT_READ | PROT_WRITE,\n\t\tMAP_PRIVATE | MAP_ANONYMOUS | MAP_32BIT, -1, 0);\n\tif (target == MAP_FAILED)\n\t\terr(1, \"mmap\");\n\n\t*target = EXPECTED_VALUE;\n\n\tprintf(\"\\tsegment base address = 0x%lx\\n\", (unsigned long)target);\n\n\tstruct user_desc desc = {\n\t\t.entry_number    = 0,\n\t\t.base_addr       = (unsigned int)(uintptr_t)target,\n\t\t.limit           = sizeof(unsigned int) - 1,\n\t\t.seg_32bit       = 1,\n\t\t.contents        = 0,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 0,\n\t\t.seg_not_present = 0,\n\t\t.useable         = 0\n\t};\n\tif (syscall(SYS_modify_ldt, 1, &desc, sizeof(desc)) == 0) {\n\t\tprintf(\"\\tusing LDT slot 0\\n\");\n\t\tasm volatile (\"mov %0, %\" SEG :: \"rm\" ((unsigned short)0x7));\n\t} else {\n\t\t \n\n\t\tstruct user_desc *low_desc = mmap(\n\t\t\tNULL, sizeof(desc),\n\t\t\tPROT_READ | PROT_WRITE,\n\t\t\tMAP_PRIVATE | MAP_ANONYMOUS | MAP_32BIT, -1, 0);\n\t\tmemcpy(low_desc, &desc, sizeof(desc));\n\n\t\tlow_desc->entry_number = -1;\n\n\t\t \n\t\tlong ret;\n\t\tasm volatile (\"int $0x80\"\n\t\t\t      : \"=a\" (ret), \"+m\" (*low_desc)\n\t\t\t      : \"a\" (243), \"b\" (low_desc)\n#ifdef __x86_64__\n\t\t\t      : \"r8\", \"r9\", \"r10\", \"r11\"\n#endif\n\t\t\t);\n\t\tmemcpy(&desc, low_desc, sizeof(desc));\n\t\tmunmap(low_desc, sizeof(desc));\n\n\t\tif (ret != 0) {\n\t\t\tprintf(\"[NOTE]\\tcould not create a segment -- can't test anything\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tprintf(\"\\tusing GDT slot %d\\n\", desc.entry_number);\n\n\t\tunsigned short sel = (unsigned short)((desc.entry_number << 3) | 0x3);\n\t\tasm volatile (\"mov %0, %\" SEG :: \"rm\" (sel));\n\t}\n}\n\nstatic void tracee_zap_segment(void)\n{\n\t \n\tprintf(\"\\tTracee: in tracee_zap_segment()\\n\");\n\n\t \n\tunsigned short sel;\n\tasm volatile (\"mov %%ss, %0\\n\\t\"\n\t\t      \"mov %0, %\" SEG\n\t\t      : \"=rm\" (sel));\n\n\tpid_t pid = getpid(), tid = syscall(SYS_gettid);\n\n\tprintf(\"\\tTracee is going back to sleep\\n\");\n\tsyscall(SYS_tgkill, pid, tid, SIGSTOP);\n\n\t \n\twhile (true) {\n\t\tprintf(\"[FAIL]\\tTracee hit unreachable code\\n\");\n\t\tpause();\n\t}\n}\n\nint main()\n{\n\tprintf(\"\\tSetting up a segment\\n\");\n\tinit_seg();\n\n\tunsigned int val = dereference_seg_base();\n\tif (val != EXPECTED_VALUE) {\n\t\tprintf(\"[FAIL]\\tseg[0] == %x; should be %x\\n\", val, EXPECTED_VALUE);\n\t\treturn 1;\n\t}\n\tprintf(\"[OK]\\tThe segment points to the right place.\\n\");\n\n\tpid_t chld = fork();\n\tif (chld < 0)\n\t\terr(1, \"fork\");\n\n\tif (chld == 0) {\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0, 0);\n\n\t\tif (ptrace(PTRACE_TRACEME, 0, 0, 0) != 0)\n\t\t\terr(1, \"PTRACE_TRACEME\");\n\n\t\tpid_t pid = getpid(), tid = syscall(SYS_gettid);\n\n\t\tprintf(\"\\tTracee will take a nap until signaled\\n\");\n\t\tsyscall(SYS_tgkill, pid, tid, SIGSTOP);\n\n\t\tprintf(\"\\tTracee was resumed.  Will re-check segment.\\n\");\n\n\t\tval = dereference_seg_base();\n\t\tif (val != EXPECTED_VALUE) {\n\t\t\tprintf(\"[FAIL]\\tseg[0] == %x; should be %x\\n\", val, EXPECTED_VALUE);\n\t\t\texit(1);\n\t\t}\n\n\t\tprintf(\"[OK]\\tThe segment points to the right place.\\n\");\n\t\texit(0);\n\t}\n\n\tint status;\n\n\t \n\tif (waitpid(chld, &status, 0) != chld || !WIFSTOPPED(status))\n\t\terr(1, \"waitpid\");\n\n\tstruct user_regs_struct regs;\n\n\tif (ptrace(PTRACE_GETREGS, chld, NULL, &regs) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\n#ifdef __x86_64__\n\tprintf(\"\\tChild GS=0x%lx, GSBASE=0x%lx\\n\", (unsigned long)regs.gs, (unsigned long)regs.gs_base);\n#else\n\tprintf(\"\\tChild FS=0x%lx\\n\", (unsigned long)regs.xfs);\n#endif\n\n\tstruct user_regs_struct regs2 = regs;\n#ifdef __x86_64__\n\tregs2.rip = (unsigned long)tracee_zap_segment;\n\tregs2.rsp -= 128;\t \n#else\n\tregs2.eip = (unsigned long)tracee_zap_segment;\n#endif\n\n\tprintf(\"\\tTracer: redirecting tracee to tracee_zap_segment()\\n\");\n\tif (ptrace(PTRACE_SETREGS, chld, NULL, &regs2) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\tif (ptrace(PTRACE_CONT, chld, NULL, NULL) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\n\t \n\tif (waitpid(chld, &status, 0) != chld || !WIFSTOPPED(status))\n\t\terr(1, \"waitpid\");\n\n\tprintf(\"\\tTracer: restoring tracee state\\n\");\n\tif (ptrace(PTRACE_SETREGS, chld, NULL, &regs) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\tif (ptrace(PTRACE_DETACH, chld, NULL, NULL) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\n\t \n\tif (waitpid(chld, &status, 0) != chld)\n\t\terr(1, \"waitpid\");\n\n\tif (WIFSIGNALED(status)) {\n\t\tprintf(\"[FAIL]\\tTracee crashed\\n\");\n\t\treturn 1;\n\t}\n\n\tif (!WIFEXITED(status)) {\n\t\tprintf(\"[FAIL]\\tTracee stopped for an unexpected reason: %d\\n\", status);\n\t\treturn 1;\n\t}\n\n\tint exitcode = WEXITSTATUS(status);\n\tif (exitcode != 0) {\n\t\tprintf(\"[FAIL]\\tTracee reported failure\\n\");\n\t\treturn 1;\n\t}\n\n\tprintf(\"[OK]\\tAll is well.\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}