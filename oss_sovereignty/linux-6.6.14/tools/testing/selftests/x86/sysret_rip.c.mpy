{
  "module_name": "sysret_rip.c",
  "hash_id": "5861c04706f280ec2ca71b56e3e78d14e5a48ce9e137110e0043a7aa60a9f11f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/sysret_rip.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n#include <sys/signal.h>\n#include <sys/ucontext.h>\n#include <sys/syscall.h>\n#include <err.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <setjmp.h>\n#include <sys/user.h>\n#include <sys/mman.h>\n#include <assert.h>\n\n\nasm (\n\t\".pushsection \\\".text\\\", \\\"ax\\\"\\n\\t\"\n\t\".balign 4096\\n\\t\"\n\t\"test_page: .globl test_page\\n\\t\"\n\t\".fill 4094,1,0xcc\\n\\t\"\n\t\"test_syscall_insn:\\n\\t\"\n\t\"syscall\\n\\t\"\n\t\".ifne . - test_page - 4096\\n\\t\"\n\t\".error \\\"test page is not one page long\\\"\\n\\t\"\n\t\".endif\\n\\t\"\n\t\".popsection\"\n    );\n\nextern const char test_page[];\nstatic void const *current_test_page_addr = test_page;\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void clearhandler(int sig)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_DFL;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\n \nstatic gregset_t initial_regs;\n\nstatic volatile unsigned long rip;\n\nstatic void sigsegv_for_sigreturn_test(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\n\tif (rip != ctx->uc_mcontext.gregs[REG_RIP]) {\n\t\tprintf(\"[FAIL]\\tRequested RIP=0x%lx but got RIP=0x%lx\\n\",\n\t\t       rip, (unsigned long)ctx->uc_mcontext.gregs[REG_RIP]);\n\t\tfflush(stdout);\n\t\t_exit(1);\n\t}\n\n\tmemcpy(&ctx->uc_mcontext.gregs, &initial_regs, sizeof(gregset_t));\n\n\tprintf(\"[OK]\\tGot SIGSEGV at RIP=0x%lx\\n\", rip);\n}\n\nstatic void sigusr1(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\n\tmemcpy(&initial_regs, &ctx->uc_mcontext.gregs, sizeof(gregset_t));\n\n\t \n\tctx->uc_mcontext.gregs[REG_RIP] = rip;\n\tctx->uc_mcontext.gregs[REG_RCX] = rip;\n\n\t \n\tassert(ctx->uc_mcontext.gregs[REG_EFL] ==\n\t       ctx->uc_mcontext.gregs[REG_R11]);\n\n\tsethandler(SIGSEGV, sigsegv_for_sigreturn_test, SA_RESETHAND);\n\n\treturn;\n}\n\nstatic void test_sigreturn_to(unsigned long ip)\n{\n\trip = ip;\n\tprintf(\"[RUN]\\tsigreturn to 0x%lx\\n\", ip);\n\traise(SIGUSR1);\n}\n\nstatic jmp_buf jmpbuf;\n\nstatic void sigsegv_for_fallthrough(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\n\tif (rip != ctx->uc_mcontext.gregs[REG_RIP]) {\n\t\tprintf(\"[FAIL]\\tExpected SIGSEGV at 0x%lx but got RIP=0x%lx\\n\",\n\t\t       rip, (unsigned long)ctx->uc_mcontext.gregs[REG_RIP]);\n\t\tfflush(stdout);\n\t\t_exit(1);\n\t}\n\n\tsiglongjmp(jmpbuf, 1);\n}\n\nstatic void test_syscall_fallthrough_to(unsigned long ip)\n{\n\tvoid *new_address = (void *)(ip - 4096);\n\tvoid *ret;\n\n\tprintf(\"[RUN]\\tTrying a SYSCALL that falls through to 0x%lx\\n\", ip);\n\n\tret = mremap((void *)current_test_page_addr, 4096, 4096,\n\t\t     MREMAP_MAYMOVE | MREMAP_FIXED, new_address);\n\tif (ret == MAP_FAILED) {\n\t\tif (ip <= (1UL << 47) - PAGE_SIZE) {\n\t\t\terr(1, \"mremap to %p\", new_address);\n\t\t} else {\n\t\t\tprintf(\"[OK]\\tmremap to %p failed\\n\", new_address);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ret != new_address)\n\t\terrx(1, \"mremap malfunctioned: asked for %p but got %p\\n\",\n\t\t     new_address, ret);\n\n\tcurrent_test_page_addr = new_address;\n\trip = ip;\n\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tasm volatile (\"call *%[syscall_insn]\" :: \"a\" (SYS_getpid),\n\t\t\t      [syscall_insn] \"rm\" (ip - 2));\n\t\terrx(1, \"[FAIL]\\tSyscall trampoline returned\");\n\t}\n\n\tprintf(\"[OK]\\tWe survived\\n\");\n}\n\nint main()\n{\n\t \n\tsethandler(SIGUSR1, sigusr1, 0);\n\tfor (int i = 47; i < 64; i++)\n\t\ttest_sigreturn_to(1UL<<i);\n\n\tclearhandler(SIGUSR1);\n\n\tsethandler(SIGSEGV, sigsegv_for_fallthrough, 0);\n\n\t \n\ttest_syscall_fallthrough_to((1UL << 47) - 2*PAGE_SIZE);\n\n\t \n\tfor (int i = 47; i < 64; i++) {\n\t\ttest_syscall_fallthrough_to((1UL<<i) - PAGE_SIZE);\n\t\ttest_syscall_fallthrough_to(1UL<<i);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}