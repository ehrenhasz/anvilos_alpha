{
  "module_name": "syscall_numbering.c",
  "hash_id": "b24bbf5216500c8acdf0f45532dc5fdd4f40bc7cd0bc6cae869bc9e41608b928",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/syscall_numbering.c",
  "human_readable_source": " \n \n\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <signal.h>\n#include <sysexits.h>\n\n#include <sys/ptrace.h>\n#include <sys/user.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n\n#include <linux/ptrace.h>\n\n \n#define SYS_READ\t  0\n#define SYS_WRITE\t  1\n#define SYS_GETPID\t 39\n \n#define X64_IOCTL\t 16\n#define X64_READV\t 19\n#define X64_WRITEV\t 20\n \n#define X32_IOCTL\t514\n#define X32_READV\t515\n#define X32_WRITEV\t516\n\n#define X32_BIT 0x40000000\n\nstatic int nullfd = -1;\t\t \nstatic bool with_x32;\t\t \n\nenum ptrace_pass {\n\tPTP_NOTHING,\n\tPTP_GETREGS,\n\tPTP_WRITEBACK,\n\tPTP_FUZZRET,\n\tPTP_FUZZHIGH,\n\tPTP_INTNUM,\n\tPTP_DONE\n};\n\nstatic const char * const ptrace_pass_name[] =\n{\n\t[PTP_NOTHING]\t= \"just stop, no data read\",\n\t[PTP_GETREGS]\t= \"only getregs\",\n\t[PTP_WRITEBACK]\t= \"getregs, unmodified setregs\",\n\t[PTP_FUZZRET]\t= \"modifying the default return\",\n\t[PTP_FUZZHIGH]\t= \"clobbering the top 32 bits\",\n\t[PTP_INTNUM]\t= \"sign-extending the syscall number\",\n};\n\n \nstruct shared {\n\tunsigned int nerr;\t \n\tunsigned int indent;\t \n\tenum ptrace_pass ptrace_pass;\n\tbool probing_syscall;\t \n};\nstatic volatile struct shared *sh;\n\nstatic inline unsigned int offset(void)\n{\n\tunsigned int level = sh ? sh->indent : 0;\n\n\treturn 8 + level * 4;\n}\n\n#define msg(lvl, fmt, ...) printf(\"%-*s\" fmt, offset(), \"[\" #lvl \"]\", \\\n\t\t\t\t  ## __VA_ARGS__)\n\n#define run(fmt, ...)  msg(RUN,  fmt, ## __VA_ARGS__)\n#define info(fmt, ...) msg(INFO, fmt, ## __VA_ARGS__)\n#define ok(fmt, ...)   msg(OK,   fmt, ## __VA_ARGS__)\n\n#define fail(fmt, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tmsg(FAIL, fmt, ## __VA_ARGS__);\t\t\\\n\t\tsh->nerr++;\t\t\t\t\\\n       } while (0)\n\n#define crit(fmt, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tsh->indent = 0;\t\t\t\t\\\n\t\tmsg(FAIL, fmt, ## __VA_ARGS__);\t\t\\\n\t\tmsg(SKIP, \"Unable to run test\\n\");\t\\\n\t\texit(EX_OSERR);\t\t\t\t\\\n       } while (0)\n\n \n#define MODIFIED_BY_PTRACE\t-9999\n\n \nstatic long long probe_syscall(int msb, int lsb)\n{\n\tregister long long arg1 asm(\"rdi\") = nullfd;\n\tregister long long arg2 asm(\"rsi\") = 0;\n\tregister long long arg3 asm(\"rdx\") = 0;\n\tregister long long arg4 asm(\"r10\") = 0;\n\tregister long long arg5 asm(\"r8\")  = 0;\n\tregister long long arg6 asm(\"r9\")  = 0;\n\tlong long nr = ((long long)msb << 32) | (unsigned int)lsb;\n\tlong long ret;\n\n\t \n\tsh->probing_syscall = true;\n\tasm volatile(\"syscall\"\n\t\t     : \"=a\" (ret)\n\t\t     : \"a\" (nr), \"b\" (nr),\n\t\t       \"r\" (arg1), \"r\" (arg2), \"r\" (arg3),\n\t\t       \"r\" (arg4), \"r\" (arg5), \"r\" (arg6)\n\t\t     : \"rcx\", \"r11\", \"memory\", \"cc\");\n\tsh->probing_syscall = false;\n\n\treturn ret;\n}\n\nstatic const char *syscall_str(int msb, int start, int end)\n{\n\tstatic char buf[64];\n\tconst char * const type = (start & X32_BIT) ? \"x32\" : \"x64\";\n\tint lsb = start;\n\n\t \n\tif (lsb < 0)\n\t\tlsb |= X32_BIT;\n\telse\n\t\tlsb &= ~X32_BIT;\n\n\tif (start == end)\n\t\tsnprintf(buf, sizeof buf, \"%s syscall %d:%d\",\n\t\t\t type, msb, lsb);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%s syscalls %d:%d..%d\",\n\t\t\t type, msb, lsb, lsb + (end-start));\n\n\treturn buf;\n}\n\nstatic unsigned int _check_for(int msb, int start, int end, long long expect,\n\t\t\t       const char *expect_str)\n{\n\tunsigned int err = 0;\n\n\tsh->indent++;\n\tif (start != end)\n\t\tsh->indent++;\n\n\tfor (int nr = start; nr <= end; nr++) {\n\t\tlong long ret = probe_syscall(msb, nr);\n\n\t\tif (ret != expect) {\n\t\t\tfail(\"%s returned %lld, but it should have returned %s\\n\",\n\t\t\t       syscall_str(msb, nr, nr),\n\t\t\t       ret, expect_str);\n\t\t\terr++;\n\t\t}\n\t}\n\n\tif (start != end)\n\t\tsh->indent--;\n\n\tif (err) {\n\t\tif (start != end)\n\t\t\tfail(\"%s had %u failure%s\\n\",\n\t\t\t     syscall_str(msb, start, end),\n\t\t\t     err, err == 1 ? \"s\" : \"\");\n\t} else {\n\t\tok(\"%s returned %s as expected\\n\",\n\t\t   syscall_str(msb, start, end), expect_str);\n\t}\n\n\tsh->indent--;\n\n\treturn err;\n}\n\n#define check_for(msb,start,end,expect) \\\n\t_check_for(msb,start,end,expect,#expect)\n\nstatic bool check_zero(int msb, int nr)\n{\n\treturn check_for(msb, nr, nr, 0);\n}\n\nstatic bool check_enosys(int msb, int nr)\n{\n\treturn check_for(msb, nr, nr, -ENOSYS);\n}\n\n \nstatic bool test_x32(void)\n{\n\tlong long ret;\n\tpid_t mypid = getpid();\n\n\trun(\"Checking for x32 by calling x32 getpid()\\n\");\n\tret = probe_syscall(0, SYS_GETPID | X32_BIT);\n\n\tsh->indent++;\n\tif (ret == mypid) {\n\t\tinfo(\"x32 is supported\\n\");\n\t\twith_x32 = true;\n\t} else if (ret == -ENOSYS) {\n\t\tinfo(\"x32 is not supported\\n\");\n\t\twith_x32 = false;\n\t} else {\n\t\tfail(\"x32 getpid() returned %lld, but it should have returned either %lld or -ENOSYS\\n\", ret, (long long)mypid);\n\t\twith_x32 = false;\n\t}\n\tsh->indent--;\n\treturn with_x32;\n}\n\nstatic void test_syscalls_common(int msb)\n{\n\tenum ptrace_pass pass = sh->ptrace_pass;\n\n\trun(\"Checking some common syscalls as 64 bit\\n\");\n\tcheck_zero(msb, SYS_READ);\n\tcheck_zero(msb, SYS_WRITE);\n\n\trun(\"Checking some 64-bit only syscalls as 64 bit\\n\");\n\tcheck_zero(msb, X64_READV);\n\tcheck_zero(msb, X64_WRITEV);\n\n\trun(\"Checking out of range system calls\\n\");\n\tcheck_for(msb, -64, -2, -ENOSYS);\n\tif (pass >= PTP_FUZZRET)\n\t\tcheck_for(msb, -1, -1, MODIFIED_BY_PTRACE);\n\telse\n\t\tcheck_for(msb, -1, -1, -ENOSYS);\n\tcheck_for(msb, X32_BIT-64, X32_BIT-1, -ENOSYS);\n\tcheck_for(msb, -64-X32_BIT, -1-X32_BIT, -ENOSYS);\n\tcheck_for(msb, INT_MAX-64, INT_MAX-1, -ENOSYS);\n}\n\nstatic void test_syscalls_with_x32(int msb)\n{\n\t \n\trun(\"Checking x32 syscalls as 64 bit\\n\");\n\tcheck_for(msb, 512, 547, -ENOSYS);\n\n\trun(\"Checking some common syscalls as x32\\n\");\n\tcheck_zero(msb, SYS_READ   | X32_BIT);\n\tcheck_zero(msb, SYS_WRITE  | X32_BIT);\n\n\trun(\"Checking some x32 syscalls as x32\\n\");\n\tcheck_zero(msb, X32_READV  | X32_BIT);\n\tcheck_zero(msb, X32_WRITEV | X32_BIT);\n\n\trun(\"Checking some 64-bit syscalls as x32\\n\");\n\tcheck_enosys(msb, X64_IOCTL  | X32_BIT);\n\tcheck_enosys(msb, X64_READV  | X32_BIT);\n\tcheck_enosys(msb, X64_WRITEV | X32_BIT);\n}\n\nstatic void test_syscalls_without_x32(int msb)\n{\n\trun(\"Checking for absence of x32 system calls\\n\");\n\tcheck_for(msb, 0 | X32_BIT, 999 | X32_BIT, -ENOSYS);\n}\n\nstatic void test_syscall_numbering(void)\n{\n\tstatic const int msbs[] = {\n\t\t0, 1, -1, X32_BIT-1, X32_BIT, X32_BIT-1, -X32_BIT, INT_MAX,\n\t\tINT_MIN, INT_MIN+1\n\t};\n\n\tsh->indent++;\n\n\t \n\tfor (size_t i = 0; i < sizeof(msbs)/sizeof(msbs[0]); i++) {\n\t\tint msb = msbs[i];\n\t\trun(\"Checking system calls with msb = %d (0x%x)\\n\",\n\t\t    msb, msb);\n\n\t\tsh->indent++;\n\n\t\ttest_syscalls_common(msb);\n\t\tif (with_x32)\n\t\t\ttest_syscalls_with_x32(msb);\n\t\telse\n\t\t\ttest_syscalls_without_x32(msb);\n\n\t\tsh->indent--;\n\t}\n\n\tsh->indent--;\n}\n\nstatic void syscall_numbering_tracee(void)\n{\n\tenum ptrace_pass pass;\n\n\tif (ptrace(PTRACE_TRACEME, 0, 0, 0)) {\n\t\tcrit(\"Failed to request tracing\\n\");\n\t\treturn;\n\t}\n\traise(SIGSTOP);\n\n\tfor (sh->ptrace_pass = pass = PTP_NOTHING; pass < PTP_DONE;\n\t     sh->ptrace_pass = ++pass) {\n\t\trun(\"Running tests under ptrace: %s\\n\", ptrace_pass_name[pass]);\n\t\ttest_syscall_numbering();\n\t}\n}\n\nstatic void mess_with_syscall(pid_t testpid, enum ptrace_pass pass)\n{\n\tstruct user_regs_struct regs;\n\n\tsh->probing_syscall = false;  \n\n\t \n\tif (pass == PTP_NOTHING || pass == PTP_DONE)\n\t\treturn;\n\n\tptrace(PTRACE_GETREGS, testpid, NULL, &regs);\n\n\tif (regs.orig_rax != regs.rbx) {\n\t\tfail(\"orig_rax %#llx doesn't match syscall number %#llx\\n\",\n\t\t     (unsigned long long)regs.orig_rax,\n\t\t     (unsigned long long)regs.rbx);\n\t}\n\n\tswitch (pass) {\n\tcase PTP_GETREGS:\n\t\t \n\t\treturn;\n\tcase PTP_WRITEBACK:\n\t\t \n\t\tbreak;\n\tcase PTP_FUZZRET:\n\t\tregs.rax = MODIFIED_BY_PTRACE;\n\t\tbreak;\n\tcase PTP_FUZZHIGH:\n\t\tregs.rax = MODIFIED_BY_PTRACE;\n\t\tregs.orig_rax = regs.orig_rax | 0xffffffff00000000ULL;\n\t\tbreak;\n\tcase PTP_INTNUM:\n\t\tregs.rax = MODIFIED_BY_PTRACE;\n\t\tregs.orig_rax = (int)regs.orig_rax;\n\t\tbreak;\n\tdefault:\n\t\tcrit(\"invalid ptrace_pass\\n\");\n\t\tbreak;\n\t}\n\n\tptrace(PTRACE_SETREGS, testpid, NULL, &regs);\n}\n\nstatic void syscall_numbering_tracer(pid_t testpid)\n{\n\tint wstatus;\n\n\tdo {\n\t\tpid_t wpid = waitpid(testpid, &wstatus, 0);\n\t\tif (wpid < 0 && errno != EINTR)\n\t\t\tbreak;\n\t\tif (wpid != testpid)\n\t\t\tcontinue;\n\t\tif (!WIFSTOPPED(wstatus))\n\t\t\tbreak;\t \n\n\t\tif (sh->probing_syscall && WSTOPSIG(wstatus) == SIGTRAP)\n\t\t\tmess_with_syscall(testpid, sh->ptrace_pass);\n\t} while (sh->ptrace_pass != PTP_DONE &&\n\t\t !ptrace(PTRACE_SYSCALL, testpid, NULL, NULL));\n\n\tptrace(PTRACE_DETACH, testpid, NULL, NULL);\n\n\t \n\twhile (waitpid(testpid, &wstatus, 0) != testpid || !WIFEXITED(wstatus))\n\t\t ;\n}\n\nstatic void test_traced_syscall_numbering(void)\n{\n\tpid_t testpid;\n\n\t \n\ttestpid = fork();\n\n\tif (testpid < 0) {\n\t\tcrit(\"Unable to launch tracer process\\n\");\n\t} else if (testpid == 0) {\n\t\tsyscall_numbering_tracee();\n\t\t_exit(0);\n\t} else {\n\t\tsyscall_numbering_tracer(testpid);\n\t}\n}\n\nint main(void)\n{\n\tunsigned int nerr;\n\n\t \n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\n\t \n\tnullfd = open(\"/dev/null\", O_RDWR);\n\tif (nullfd < 0) {\n\t\tcrit(\"Unable to open /dev/null: %s\\n\", strerror(errno));\n\t}\n\n\t \n\tsh = mmap(NULL, sysconf(_SC_PAGE_SIZE), PROT_READ|PROT_WRITE,\n\t\t  MAP_ANONYMOUS|MAP_SHARED, 0, 0);\n\tif (sh == MAP_FAILED) {\n\t\tcrit(\"Unable to allocated shared memory block: %s\\n\",\n\t\t     strerror(errno));\n\t}\n\n\twith_x32 = test_x32();\n\n\trun(\"Running tests without ptrace...\\n\");\n\ttest_syscall_numbering();\n\n\ttest_traced_syscall_numbering();\n\n\tnerr = sh->nerr;\n\tif (!nerr) {\n\t\tok(\"All system calls succeeded or failed as expected\\n\");\n\t\treturn 0;\n\t} else {\n\t\tfail(\"A total of %u system call%s had incorrect behavior\\n\",\n\t\t     nerr, nerr != 1 ? \"s\" : \"\");\n\t\treturn 1;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}