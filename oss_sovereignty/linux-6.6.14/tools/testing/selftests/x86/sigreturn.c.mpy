{
  "module_name": "sigreturn.c",
  "hash_id": "d453bb69fffe1b8fb78ac3d07b10c14acc67d6da5e86a0c97496ac9f9a98f65c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/sigreturn.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <sys/time.h>\n#include <time.h>\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <inttypes.h>\n#include <sys/mman.h>\n#include <sys/signal.h>\n#include <sys/ucontext.h>\n#include <asm/ldt.h>\n#include <err.h>\n#include <setjmp.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <sys/ptrace.h>\n#include <sys/user.h>\n\n \ntypedef unsigned int u32;\ntypedef unsigned short u16;\n#include \"../../../../arch/x86/include/asm/desc_defs.h\"\n\n \n#ifdef __x86_64__\n \n#define UC_SIGCONTEXT_SS       0x2\n#define UC_STRICT_RESTORE_SS   0x4\n#endif\n\n \n#define LDT_OFFSET 6\n\n \nstatic unsigned char stack16[65536] __attribute__((aligned(4096)));\n\n \nasm (\".pushsection .text\\n\\t\"\n     \".type int3, @function\\n\\t\"\n     \".align 4096\\n\\t\"\n     \"int3:\\n\\t\"\n     \"mov %ss,%ecx\\n\\t\"\n     \"int3\\n\\t\"\n     \".size int3, . - int3\\n\\t\"\n     \".align 4096, 0xcc\\n\\t\"\n     \".popsection\");\nextern char int3[4096];\n\n \nstatic unsigned short ldt_nonexistent_sel;\nstatic unsigned short code16_sel, data16_sel, npcode32_sel, npdata32_sel;\n\nstatic unsigned short gdt_data16_idx, gdt_npdata32_idx;\n\nstatic unsigned short GDT3(int idx)\n{\n\treturn (idx << 3) | 3;\n}\n\nstatic unsigned short LDT3(int idx)\n{\n\treturn (idx << 3) | 7;\n}\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void clearhandler(int sig)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_DFL;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void add_ldt(const struct user_desc *desc, unsigned short *var,\n\t\t    const char *name)\n{\n\tif (syscall(SYS_modify_ldt, 1, desc, sizeof(*desc)) == 0) {\n\t\t*var = LDT3(desc->entry_number);\n\t} else {\n\t\tprintf(\"[NOTE]\\tFailed to create %s segment\\n\", name);\n\t\t*var = 0;\n\t}\n}\n\nstatic void setup_ldt(void)\n{\n\tif ((unsigned long)stack16 > (1ULL << 32) - sizeof(stack16))\n\t\terrx(1, \"stack16 is too high\\n\");\n\tif ((unsigned long)int3 > (1ULL << 32) - sizeof(int3))\n\t\terrx(1, \"int3 is too high\\n\");\n\n\tldt_nonexistent_sel = LDT3(LDT_OFFSET + 2);\n\n\tconst struct user_desc code16_desc = {\n\t\t.entry_number    = LDT_OFFSET + 0,\n\t\t.base_addr       = (unsigned long)int3,\n\t\t.limit           = 4095,\n\t\t.seg_32bit       = 0,\n\t\t.contents        = 2,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 0,\n\t\t.seg_not_present = 0,\n\t\t.useable         = 0\n\t};\n\tadd_ldt(&code16_desc, &code16_sel, \"code16\");\n\n\tconst struct user_desc data16_desc = {\n\t\t.entry_number    = LDT_OFFSET + 1,\n\t\t.base_addr       = (unsigned long)stack16,\n\t\t.limit           = 0xffff,\n\t\t.seg_32bit       = 0,\n\t\t.contents        = 0,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 0,\n\t\t.seg_not_present = 0,\n\t\t.useable         = 0\n\t};\n\tadd_ldt(&data16_desc, &data16_sel, \"data16\");\n\n\tconst struct user_desc npcode32_desc = {\n\t\t.entry_number    = LDT_OFFSET + 3,\n\t\t.base_addr       = (unsigned long)int3,\n\t\t.limit           = 4095,\n\t\t.seg_32bit       = 1,\n\t\t.contents        = 2,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 0,\n\t\t.seg_not_present = 1,\n\t\t.useable         = 0\n\t};\n\tadd_ldt(&npcode32_desc, &npcode32_sel, \"npcode32\");\n\n\tconst struct user_desc npdata32_desc = {\n\t\t.entry_number    = LDT_OFFSET + 4,\n\t\t.base_addr       = (unsigned long)stack16,\n\t\t.limit           = 0xffff,\n\t\t.seg_32bit       = 1,\n\t\t.contents        = 0,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 0,\n\t\t.seg_not_present = 1,\n\t\t.useable         = 0\n\t};\n\tadd_ldt(&npdata32_desc, &npdata32_sel, \"npdata32\");\n\n\tstruct user_desc gdt_data16_desc = {\n\t\t.entry_number    = -1,\n\t\t.base_addr       = (unsigned long)stack16,\n\t\t.limit           = 0xffff,\n\t\t.seg_32bit       = 0,\n\t\t.contents        = 0,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 0,\n\t\t.seg_not_present = 0,\n\t\t.useable         = 0\n\t};\n\n\tif (syscall(SYS_set_thread_area, &gdt_data16_desc) == 0) {\n\t\t \n\t\tprintf(\"[WARN]\\tset_thread_area allocated data16 at index %d\\n\",\n\t\t       gdt_data16_desc.entry_number);\n\t\tgdt_data16_idx = gdt_data16_desc.entry_number;\n\t} else {\n\t\tprintf(\"[OK]\\tset_thread_area refused 16-bit data\\n\");\n\t}\n\n\tstruct user_desc gdt_npdata32_desc = {\n\t\t.entry_number    = -1,\n\t\t.base_addr       = (unsigned long)stack16,\n\t\t.limit           = 0xffff,\n\t\t.seg_32bit       = 1,\n\t\t.contents        = 0,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 0,\n\t\t.seg_not_present = 1,\n\t\t.useable         = 0\n\t};\n\n\tif (syscall(SYS_set_thread_area, &gdt_npdata32_desc) == 0) {\n\t\t \n\t\tprintf(\"[WARN]\\tset_thread_area allocated npdata32 at index %d\\n\",\n\t\t       gdt_npdata32_desc.entry_number);\n\t\tgdt_npdata32_idx = gdt_npdata32_desc.entry_number;\n\t} else {\n\t\tprintf(\"[OK]\\tset_thread_area refused 16-bit data\\n\");\n\t}\n}\n\n \nstatic gregset_t initial_regs, requested_regs, resulting_regs;\n\n \nstatic volatile unsigned short sig_cs, sig_ss;\nstatic volatile sig_atomic_t sig_trapped, sig_err, sig_trapno;\n#ifdef __x86_64__\nstatic volatile sig_atomic_t sig_corrupt_final_ss;\n#endif\n\n \n#ifdef __x86_64__\n# define REG_IP REG_RIP\n# define REG_SP REG_RSP\n# define REG_CX REG_RCX\n\nstruct selectors {\n\tunsigned short cs, gs, fs, ss;\n};\n\nstatic unsigned short *ssptr(ucontext_t *ctx)\n{\n\tstruct selectors *sels = (void *)&ctx->uc_mcontext.gregs[REG_CSGSFS];\n\treturn &sels->ss;\n}\n\nstatic unsigned short *csptr(ucontext_t *ctx)\n{\n\tstruct selectors *sels = (void *)&ctx->uc_mcontext.gregs[REG_CSGSFS];\n\treturn &sels->cs;\n}\n#else\n# define REG_IP REG_EIP\n# define REG_SP REG_ESP\n# define REG_CX REG_ECX\n\nstatic greg_t *ssptr(ucontext_t *ctx)\n{\n\treturn &ctx->uc_mcontext.gregs[REG_SS];\n}\n\nstatic greg_t *csptr(ucontext_t *ctx)\n{\n\treturn &ctx->uc_mcontext.gregs[REG_CS];\n}\n#endif\n\n \nint cs_bitness(unsigned short cs)\n{\n\tuint32_t valid = 0, ar;\n\tasm (\"lar %[cs], %[ar]\\n\\t\"\n\t     \"jnz 1f\\n\\t\"\n\t     \"mov $1, %[valid]\\n\\t\"\n\t     \"1:\"\n\t     : [ar] \"=r\" (ar), [valid] \"+rm\" (valid)\n\t     : [cs] \"r\" (cs));\n\n\tif (!valid)\n\t\treturn -1;\n\n\tbool db = (ar & (1 << 22));\n\tbool l = (ar & (1 << 21));\n\n\tif (!(ar & (1<<11)))\n\t    return -1;\t \n\n\tif (l && !db)\n\t\treturn 64;\n\telse if (!l && db)\n\t\treturn 32;\n\telse if (!l && !db)\n\t\treturn 16;\n\telse\n\t\treturn -1;\t \n}\n\n \nbool is_valid_ss(unsigned short cs)\n{\n\tuint32_t valid = 0, ar;\n\tasm (\"lar %[cs], %[ar]\\n\\t\"\n\t     \"jnz 1f\\n\\t\"\n\t     \"mov $1, %[valid]\\n\\t\"\n\t     \"1:\"\n\t     : [ar] \"=r\" (ar), [valid] \"+rm\" (valid)\n\t     : [cs] \"r\" (cs));\n\n\tif (!valid)\n\t\treturn false;\n\n\tif ((ar & AR_TYPE_MASK) != AR_TYPE_RWDATA &&\n\t    (ar & AR_TYPE_MASK) != AR_TYPE_RWDATA_EXPDOWN)\n\t\treturn false;\n\n\treturn (ar & AR_P);\n}\n\n \nstatic volatile sig_atomic_t nerrs;\n\nstatic void validate_signal_ss(int sig, ucontext_t *ctx)\n{\n#ifdef __x86_64__\n\tbool was_64bit = (cs_bitness(*csptr(ctx)) == 64);\n\n\tif (!(ctx->uc_flags & UC_SIGCONTEXT_SS)) {\n\t\tprintf(\"[FAIL]\\tUC_SIGCONTEXT_SS was not set\\n\");\n\t\tnerrs++;\n\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (!!(ctx->uc_flags & UC_STRICT_RESTORE_SS) != was_64bit) {\n\t\tprintf(\"[FAIL]\\tUC_STRICT_RESTORE_SS was wrong in signal %d\\n\",\n\t\t       sig);\n\t\tnerrs++;\n\t}\n\n\tif (is_valid_ss(*ssptr(ctx))) {\n\t\t \n\t\tunsigned short hw_ss;\n\t\tasm (\"mov %%ss, %0\" : \"=rm\" (hw_ss));\n\t\tif (hw_ss != *ssptr(ctx)) {\n\t\t\tprintf(\"[FAIL]\\tHW SS didn't match saved SS\\n\");\n\t\t\tnerrs++;\n\t\t}\n\t}\n#endif\n}\n\n \nstatic void sigusr1(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\n\tvalidate_signal_ss(sig, ctx);\n\n\tmemcpy(&initial_regs, &ctx->uc_mcontext.gregs, sizeof(gregset_t));\n\n\t*csptr(ctx) = sig_cs;\n\t*ssptr(ctx) = sig_ss;\n\n\tctx->uc_mcontext.gregs[REG_IP] =\n\t\tsig_cs == code16_sel ? 0 : (unsigned long)&int3;\n\tctx->uc_mcontext.gregs[REG_SP] = (unsigned long)0x8badf00d5aadc0deULL;\n\tctx->uc_mcontext.gregs[REG_CX] = 0;\n\n#ifdef __i386__\n\t \n\tctx->uc_mcontext.gregs[REG_DS] = 0;\n\tctx->uc_mcontext.gregs[REG_ES] = 0;\n#endif\n\n\tmemcpy(&requested_regs, &ctx->uc_mcontext.gregs, sizeof(gregset_t));\n\trequested_regs[REG_CX] = *ssptr(ctx);\t \n\n\treturn;\n}\n\n \nstatic void sigtrap(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\n\tvalidate_signal_ss(sig, ctx);\n\n\tsig_err = ctx->uc_mcontext.gregs[REG_ERR];\n\tsig_trapno = ctx->uc_mcontext.gregs[REG_TRAPNO];\n\n\tunsigned short ss;\n\tasm (\"mov %%ss,%0\" : \"=r\" (ss));\n\n\tgreg_t asm_ss = ctx->uc_mcontext.gregs[REG_CX];\n\tif (asm_ss != sig_ss && sig == SIGTRAP) {\n\t\t \n\t\tprintf(\"[FAIL]\\tSIGTRAP: ss = %hx, frame ss = %hx, ax = %llx\\n\",\n\t\t       ss, *ssptr(ctx), (unsigned long long)asm_ss);\n\t\tnerrs++;\n\t}\n\n\tmemcpy(&resulting_regs, &ctx->uc_mcontext.gregs, sizeof(gregset_t));\n\tmemcpy(&ctx->uc_mcontext.gregs, &initial_regs, sizeof(gregset_t));\n\n#ifdef __x86_64__\n\tif (sig_corrupt_final_ss) {\n\t\tif (ctx->uc_flags & UC_STRICT_RESTORE_SS) {\n\t\t\tprintf(\"[FAIL]\\tUC_STRICT_RESTORE_SS was set inappropriately\\n\");\n\t\t\tnerrs++;\n\t\t} else {\n\t\t\t \n\t\t\tprintf(\"\\tCorrupting SS on return to 64-bit mode\\n\");\n\t\t\t*ssptr(ctx) = 0;\n\t\t}\n\t}\n#endif\n\n\tsig_trapped = sig;\n}\n\n#ifdef __x86_64__\n \nstatic void sigusr2(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\n\tif (!(ctx->uc_flags & UC_STRICT_RESTORE_SS)) {\n\t\tprintf(\"[FAIL]\\traise(2) didn't set UC_STRICT_RESTORE_SS\\n\");\n\t\tnerrs++;\n\t\treturn;   \n\t}\n\n\tctx->uc_flags &= ~UC_STRICT_RESTORE_SS;\n\t*ssptr(ctx) = 0;\n\n\t \n}\n\nstatic int test_nonstrict_ss(void)\n{\n\tclearhandler(SIGUSR1);\n\tclearhandler(SIGTRAP);\n\tclearhandler(SIGSEGV);\n\tclearhandler(SIGILL);\n\tsethandler(SIGUSR2, sigusr2, 0);\n\n\tnerrs = 0;\n\n\tprintf(\"[RUN]\\tClear UC_STRICT_RESTORE_SS and corrupt SS\\n\");\n\traise(SIGUSR2);\n\tif (!nerrs)\n\t\tprintf(\"[OK]\\tIt worked\\n\");\n\n\treturn nerrs;\n}\n#endif\n\n \nint find_cs(int bitness)\n{\n\tunsigned short my_cs;\n\n\tasm (\"mov %%cs,%0\" :  \"=r\" (my_cs));\n\n\tif (cs_bitness(my_cs) == bitness)\n\t\treturn my_cs;\n\tif (cs_bitness(my_cs + (2 << 3)) == bitness)\n\t\treturn my_cs + (2 << 3);\n\tif (my_cs > (2<<3) && cs_bitness(my_cs - (2 << 3)) == bitness)\n\t    return my_cs - (2 << 3);\n\tif (cs_bitness(code16_sel) == bitness)\n\t\treturn code16_sel;\n\n\tprintf(\"[WARN]\\tCould not find %d-bit CS\\n\", bitness);\n\treturn -1;\n}\n\nstatic int test_valid_sigreturn(int cs_bits, bool use_16bit_ss, int force_ss)\n{\n\tint cs = find_cs(cs_bits);\n\tif (cs == -1) {\n\t\tprintf(\"[SKIP]\\tCode segment unavailable for %d-bit CS, %d-bit SS\\n\",\n\t\t       cs_bits, use_16bit_ss ? 16 : 32);\n\t\treturn 0;\n\t}\n\n\tif (force_ss != -1) {\n\t\tsig_ss = force_ss;\n\t} else {\n\t\tif (use_16bit_ss) {\n\t\t\tif (!data16_sel) {\n\t\t\t\tprintf(\"[SKIP]\\tData segment unavailable for %d-bit CS, 16-bit SS\\n\",\n\t\t\t\t       cs_bits);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsig_ss = data16_sel;\n\t\t} else {\n\t\t\tasm volatile (\"mov %%ss,%0\" : \"=r\" (sig_ss));\n\t\t}\n\t}\n\n\tsig_cs = cs;\n\n\tprintf(\"[RUN]\\tValid sigreturn: %d-bit CS (%hx), %d-bit SS (%hx%s)\\n\",\n\t       cs_bits, sig_cs, use_16bit_ss ? 16 : 32, sig_ss,\n\t       (sig_ss & 4) ? \"\" : \", GDT\");\n\n\traise(SIGUSR1);\n\n\tnerrs = 0;\n\n\t \n\tfor (int i = 0; i < NGREG; i++) {\n\t\tgreg_t req = requested_regs[i], res = resulting_regs[i];\n\n\t\tif (i == REG_TRAPNO || i == REG_IP)\n\t\t\tcontinue;\t \n\n\t\tif (i == REG_SP) {\n\t\t\t \n\n\t\t\tif (res == req)\n\t\t\t\tcontinue;\n\n\t\t\tif (cs_bits != 64 && ((res ^ req) & 0xFFFFFFFF) == 0) {\n\t\t\t\tprintf(\"[NOTE]\\tSP: %llx -> %llx\\n\",\n\t\t\t\t       (unsigned long long)req,\n\t\t\t\t       (unsigned long long)res);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintf(\"[FAIL]\\tSP mismatch: requested 0x%llx; got 0x%llx\\n\",\n\t\t\t       (unsigned long long)requested_regs[i],\n\t\t\t       (unsigned long long)resulting_regs[i]);\n\t\t\tnerrs++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbool ignore_reg = false;\n#if __i386__\n\t\tif (i == REG_UESP)\n\t\t\tignore_reg = true;\n#else\n\t\tif (i == REG_CSGSFS) {\n\t\t\tstruct selectors *req_sels =\n\t\t\t\t(void *)&requested_regs[REG_CSGSFS];\n\t\t\tstruct selectors *res_sels =\n\t\t\t\t(void *)&resulting_regs[REG_CSGSFS];\n\t\t\tif (req_sels->cs != res_sels->cs) {\n\t\t\t\tprintf(\"[FAIL]\\tCS mismatch: requested 0x%hx; got 0x%hx\\n\",\n\t\t\t\t       req_sels->cs, res_sels->cs);\n\t\t\t\tnerrs++;\n\t\t\t}\n\n\t\t\tif (req_sels->ss != res_sels->ss) {\n\t\t\t\tprintf(\"[FAIL]\\tSS mismatch: requested 0x%hx; got 0x%hx\\n\",\n\t\t\t\t       req_sels->ss, res_sels->ss);\n\t\t\t\tnerrs++;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\t \n\t\tif (i == REG_CX && req != res) {\n\t\t\tprintf(\"[FAIL]\\tCX (saved SP) mismatch: requested 0x%llx; got 0x%llx\\n\",\n\t\t\t       (unsigned long long)req,\n\t\t\t       (unsigned long long)res);\n\t\t\tnerrs++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (req != res && !ignore_reg) {\n\t\t\tprintf(\"[FAIL]\\tReg %d mismatch: requested 0x%llx; got 0x%llx\\n\",\n\t\t\t       i, (unsigned long long)req,\n\t\t\t       (unsigned long long)res);\n\t\t\tnerrs++;\n\t\t}\n\t}\n\n\tif (nerrs == 0)\n\t\tprintf(\"[OK]\\tall registers okay\\n\");\n\n\treturn nerrs;\n}\n\nstatic int test_bad_iret(int cs_bits, unsigned short ss, int force_cs)\n{\n\tint cs = force_cs == -1 ? find_cs(cs_bits) : force_cs;\n\tif (cs == -1)\n\t\treturn 0;\n\n\tsig_cs = cs;\n\tsig_ss = ss;\n\n\tprintf(\"[RUN]\\t%d-bit CS (%hx), bogus SS (%hx)\\n\",\n\t       cs_bits, sig_cs, sig_ss);\n\n\tsig_trapped = 0;\n\traise(SIGUSR1);\n\tif (sig_trapped) {\n\t\tchar errdesc[32] = \"\";\n\t\tif (sig_err) {\n\t\t\tconst char *src = (sig_err & 1) ? \" EXT\" : \"\";\n\t\t\tconst char *table;\n\t\t\tif ((sig_err & 0x6) == 0x0)\n\t\t\t\ttable = \"GDT\";\n\t\t\telse if ((sig_err & 0x6) == 0x4)\n\t\t\t\ttable = \"LDT\";\n\t\t\telse if ((sig_err & 0x6) == 0x2)\n\t\t\t\ttable = \"IDT\";\n\t\t\telse\n\t\t\t\ttable = \"???\";\n\n\t\t\tsprintf(errdesc, \"%s%s index %d, \",\n\t\t\t\ttable, src, sig_err >> 3);\n\t\t}\n\n\t\tchar trapname[32];\n\t\tif (sig_trapno == 13)\n\t\t\tstrcpy(trapname, \"GP\");\n\t\telse if (sig_trapno == 11)\n\t\t\tstrcpy(trapname, \"NP\");\n\t\telse if (sig_trapno == 12)\n\t\t\tstrcpy(trapname, \"SS\");\n\t\telse if (sig_trapno == 32)\n\t\t\tstrcpy(trapname, \"IRET\");   \n\t\telse\n\t\t\tsprintf(trapname, \"%d\", sig_trapno);\n\n\t\tprintf(\"[OK]\\tGot #%s(0x%lx) (i.e. %s%s)\\n\",\n\t\t       trapname, (unsigned long)sig_err,\n\t\t       errdesc, strsignal(sig_trapped));\n\t\treturn 0;\n\t} else {\n\t\t \n\t\tprintf(\"[FAIL]\\tDid not get SIGSEGV\\n\");\n\t\treturn 1;\n\t}\n}\n\nint main()\n{\n\tint total_nerrs = 0;\n\tunsigned short my_cs, my_ss;\n\n\tasm volatile (\"mov %%cs,%0\" : \"=r\" (my_cs));\n\tasm volatile (\"mov %%ss,%0\" : \"=r\" (my_ss));\n\tsetup_ldt();\n\n\tstack_t stack = {\n\t\t \n\t\t.ss_sp = malloc(sizeof(char) * SIGSTKSZ),\n\t\t.ss_size = SIGSTKSZ,\n\t};\n\tif (sigaltstack(&stack, NULL) != 0)\n\t\terr(1, \"sigaltstack\");\n\n\tsethandler(SIGUSR1, sigusr1, 0);\n\tsethandler(SIGTRAP, sigtrap, SA_ONSTACK);\n\n\t \n\ttotal_nerrs += test_valid_sigreturn(64, false, -1);\n\ttotal_nerrs += test_valid_sigreturn(32, false, -1);\n\ttotal_nerrs += test_valid_sigreturn(16, false, -1);\n\n\t \n\ttotal_nerrs += test_valid_sigreturn(64, true, -1);\n\ttotal_nerrs += test_valid_sigreturn(32, true, -1);\n\ttotal_nerrs += test_valid_sigreturn(16, true, -1);\n\n\tif (gdt_data16_idx) {\n\t\t \n\t\ttotal_nerrs += test_valid_sigreturn(64, true,\n\t\t\t\t\t\t    GDT3(gdt_data16_idx));\n\t\ttotal_nerrs += test_valid_sigreturn(32, true,\n\t\t\t\t\t\t    GDT3(gdt_data16_idx));\n\t\ttotal_nerrs += test_valid_sigreturn(16, true,\n\t\t\t\t\t\t    GDT3(gdt_data16_idx));\n\t}\n\n#ifdef __x86_64__\n\t \n\tsig_corrupt_final_ss = 1;\n\ttotal_nerrs += test_valid_sigreturn(32, false, -1);\n\ttotal_nerrs += test_valid_sigreturn(32, true, -1);\n\tsig_corrupt_final_ss = 0;\n#endif\n\n\t \n\tclearhandler(SIGTRAP);\n\tsethandler(SIGSEGV, sigtrap, SA_ONSTACK);\n\tsethandler(SIGBUS, sigtrap, SA_ONSTACK);\n\tsethandler(SIGILL, sigtrap, SA_ONSTACK);   \n\n\t \n\ttest_bad_iret(64, ldt_nonexistent_sel, -1);\n\ttest_bad_iret(32, ldt_nonexistent_sel, -1);\n\ttest_bad_iret(16, ldt_nonexistent_sel, -1);\n\n\t \n\ttest_bad_iret(64, my_cs, -1);\n\ttest_bad_iret(32, my_cs, -1);\n\ttest_bad_iret(16, my_cs, -1);\n\n\t \n\ttest_bad_iret(32, my_ss, npcode32_sel);\n\n\t \n\ttest_bad_iret(32, npdata32_sel, -1);\n\n\t \n\tif (gdt_npdata32_idx)\n\t\ttest_bad_iret(32, GDT3(gdt_npdata32_idx), -1);\n\n#ifdef __x86_64__\n\ttotal_nerrs += test_nonstrict_ss();\n#endif\n\n\tfree(stack.ss_sp);\n\treturn total_nerrs ? 1 : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}