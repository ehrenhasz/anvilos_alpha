{
  "module_name": "fsgsbase.c",
  "hash_id": "7dc31be436a3d15f2fa5f0597b6ab78bd58bf954d6c7cea7b7c7e0a7608b1399",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/fsgsbase.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <err.h>\n#include <sys/user.h>\n#include <asm/prctl.h>\n#include <sys/prctl.h>\n#include <signal.h>\n#include <limits.h>\n#include <sys/ucontext.h>\n#include <sched.h>\n#include <linux/futex.h>\n#include <pthread.h>\n#include <asm/ldt.h>\n#include <sys/mman.h>\n#include <stddef.h>\n#include <sys/ptrace.h>\n#include <sys/wait.h>\n#include <setjmp.h>\n\n#ifndef __x86_64__\n# error This test is 64-bit only\n#endif\n\nstatic volatile sig_atomic_t want_segv;\nstatic volatile unsigned long segv_addr;\n\nstatic unsigned short *shared_scratch;\n\nstatic int nerrs;\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void clearhandler(int sig)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_DFL;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void sigsegv(int sig, siginfo_t *si, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t*)ctx_void;\n\n\tif (!want_segv) {\n\t\tclearhandler(SIGSEGV);\n\t\treturn;   \n\t}\n\n\twant_segv = false;\n\tsegv_addr = (unsigned long)si->si_addr;\n\n\tctx->uc_mcontext.gregs[REG_RIP] += 4;\t \n\n}\n\nstatic jmp_buf jmpbuf;\n\nstatic void sigill(int sig, siginfo_t *si, void *ctx_void)\n{\n\tsiglongjmp(jmpbuf, 1);\n}\n\nstatic bool have_fsgsbase;\n\nstatic inline unsigned long rdgsbase(void)\n{\n\tunsigned long gsbase;\n\n\tasm volatile(\"rdgsbase %0\" : \"=r\" (gsbase) :: \"memory\");\n\n\treturn gsbase;\n}\n\nstatic inline unsigned long rdfsbase(void)\n{\n\tunsigned long fsbase;\n\n\tasm volatile(\"rdfsbase %0\" : \"=r\" (fsbase) :: \"memory\");\n\n\treturn fsbase;\n}\n\nstatic inline void wrgsbase(unsigned long gsbase)\n{\n\tasm volatile(\"wrgsbase %0\" :: \"r\" (gsbase) : \"memory\");\n}\n\nstatic inline void wrfsbase(unsigned long fsbase)\n{\n\tasm volatile(\"wrfsbase %0\" :: \"r\" (fsbase) : \"memory\");\n}\n\nenum which_base { FS, GS };\n\nstatic unsigned long read_base(enum which_base which)\n{\n\tunsigned long offset;\n\t \n\n\twant_segv = true;\n\n\toffset = 0;\n\tif (which == FS) {\n\t\t \n\t\tasm volatile (\"mov %%fs:(%%rcx), %%rax\" : : \"c\" (offset) : \"rax\");\n\t} else {\n\t\tasm volatile (\"mov %%gs:(%%rcx), %%rax\" : : \"c\" (offset) : \"rax\");\n\t}\n\tif (!want_segv)\n\t\treturn segv_addr + offset;\n\n\t \n\n\toffset = (ULONG_MAX >> 1) + 1;\n\tif (which == FS) {\n\t\tasm volatile (\"mov %%fs:(%%rcx), %%rax\"\n\t\t\t      : : \"c\" (offset) : \"rax\");\n\t} else {\n\t\tasm volatile (\"mov %%gs:(%%rcx), %%rax\"\n\t\t\t      : : \"c\" (offset) : \"rax\");\n\t}\n\tif (!want_segv)\n\t\treturn segv_addr + offset;\n\n\tabort();\n}\n\nstatic void check_gs_value(unsigned long value)\n{\n\tunsigned long base;\n\tunsigned short sel;\n\n\tprintf(\"[RUN]\\tARCH_SET_GS to 0x%lx\\n\", value);\n\tif (syscall(SYS_arch_prctl, ARCH_SET_GS, value) != 0)\n\t\terr(1, \"ARCH_SET_GS\");\n\n\tasm volatile (\"mov %%gs, %0\" : \"=rm\" (sel));\n\tbase = read_base(GS);\n\tif (base == value) {\n\t\tprintf(\"[OK]\\tGSBASE was set as expected (selector 0x%hx)\\n\",\n\t\t       sel);\n\t} else {\n\t\tnerrs++;\n\t\tprintf(\"[FAIL]\\tGSBASE was not as expected: got 0x%lx (selector 0x%hx)\\n\",\n\t\t       base, sel);\n\t}\n\n\tif (syscall(SYS_arch_prctl, ARCH_GET_GS, &base) != 0)\n\t\terr(1, \"ARCH_GET_GS\");\n\tif (base == value) {\n\t\tprintf(\"[OK]\\tARCH_GET_GS worked as expected (selector 0x%hx)\\n\",\n\t\t       sel);\n\t} else {\n\t\tnerrs++;\n\t\tprintf(\"[FAIL]\\tARCH_GET_GS was not as expected: got 0x%lx (selector 0x%hx)\\n\",\n\t\t       base, sel);\n\t}\n}\n\nstatic void mov_0_gs(unsigned long initial_base, bool schedule)\n{\n\tunsigned long base, arch_base;\n\n\tprintf(\"[RUN]\\tARCH_SET_GS to 0x%lx then mov 0 to %%gs%s\\n\", initial_base, schedule ? \" and schedule \" : \"\");\n\tif (syscall(SYS_arch_prctl, ARCH_SET_GS, initial_base) != 0)\n\t\terr(1, \"ARCH_SET_GS\");\n\n\tif (schedule)\n\t\tusleep(10);\n\n\tasm volatile (\"mov %0, %%gs\" : : \"rm\" (0));\n\tbase = read_base(GS);\n\tif (syscall(SYS_arch_prctl, ARCH_GET_GS, &arch_base) != 0)\n\t\terr(1, \"ARCH_GET_GS\");\n\tif (base == arch_base) {\n\t\tprintf(\"[OK]\\tGSBASE is 0x%lx\\n\", base);\n\t} else {\n\t\tnerrs++;\n\t\tprintf(\"[FAIL]\\tGSBASE changed to 0x%lx but kernel reports 0x%lx\\n\", base, arch_base);\n\t}\n}\n\nstatic volatile unsigned long remote_base;\nstatic volatile bool remote_hard_zero;\nstatic volatile unsigned int ftx;\n\n \n#define HARD_ZERO 0xa1fa5f343cb85fa4\n\nstatic void do_remote_base()\n{\n\tunsigned long to_set = remote_base;\n\tbool hard_zero = false;\n\tif (to_set == HARD_ZERO) {\n\t\tto_set = 0;\n\t\thard_zero = true;\n\t}\n\n\tif (syscall(SYS_arch_prctl, ARCH_SET_GS, to_set) != 0)\n\t\terr(1, \"ARCH_SET_GS\");\n\n\tif (hard_zero)\n\t\tasm volatile (\"mov %0, %%gs\" : : \"rm\" ((unsigned short)0));\n\n\tunsigned short sel;\n\tasm volatile (\"mov %%gs, %0\" : \"=rm\" (sel));\n\tprintf(\"\\tother thread: ARCH_SET_GS(0x%lx)%s -- sel is 0x%hx\\n\",\n\t       to_set, hard_zero ? \" and clear gs\" : \"\", sel);\n}\n\nstatic __thread int set_thread_area_entry_number = -1;\n\nstatic unsigned short load_gs(void)\n{\n\t \n\n\t \n\tif (syscall(SYS_arch_prctl, ARCH_SET_GS, 0) != 0)\n\t\terr(1, \"ARCH_SET_GS\");\n\n\t \n\tstruct user_desc desc = {\n\t\t.entry_number    = 0,\n\t\t.base_addr       = 0xBAADF00D,\n\t\t.limit           = 0xfffff,\n\t\t.seg_32bit       = 1,\n\t\t.contents        = 0,  \n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 1,\n\t\t.seg_not_present = 0,\n\t\t.useable         = 0\n\t};\n\tif (syscall(SYS_modify_ldt, 1, &desc, sizeof(desc)) == 0) {\n\t\tprintf(\"\\tusing LDT slot 0\\n\");\n\t\tasm volatile (\"mov %0, %%gs\" : : \"rm\" ((unsigned short)0x7));\n\t\treturn 0x7;\n\t} else {\n\t\t \n\n\t\tstruct user_desc *low_desc = mmap(\n\t\t\tNULL, sizeof(desc),\n\t\t\tPROT_READ | PROT_WRITE,\n\t\t\tMAP_PRIVATE | MAP_ANONYMOUS | MAP_32BIT, -1, 0);\n\t\tmemcpy(low_desc, &desc, sizeof(desc));\n\n\t\tlow_desc->entry_number = set_thread_area_entry_number;\n\n\t\t \n\t\tlong ret;\n\t\tasm volatile (\"int $0x80\"\n\t\t\t      : \"=a\" (ret), \"+m\" (*low_desc)\n\t\t\t      : \"a\" (243), \"b\" (low_desc)\n\t\t\t      : \"r8\", \"r9\", \"r10\", \"r11\");\n\t\tmemcpy(&desc, low_desc, sizeof(desc));\n\t\tmunmap(low_desc, sizeof(desc));\n\n\t\tif (ret != 0) {\n\t\t\tprintf(\"[NOTE]\\tcould not create a segment -- test won't do anything\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tprintf(\"\\tusing GDT slot %d\\n\", desc.entry_number);\n\t\tset_thread_area_entry_number = desc.entry_number;\n\n\t\tunsigned short gs = (unsigned short)((desc.entry_number << 3) | 0x3);\n\t\tasm volatile (\"mov %0, %%gs\" : : \"rm\" (gs));\n\t\treturn gs;\n\t}\n}\n\nvoid test_wrbase(unsigned short index, unsigned long base)\n{\n\tunsigned short newindex;\n\tunsigned long newbase;\n\n\tprintf(\"[RUN]\\tGS = 0x%hx, GSBASE = 0x%lx\\n\", index, base);\n\n\tasm volatile (\"mov %0, %%gs\" : : \"rm\" (index));\n\twrgsbase(base);\n\n\tremote_base = 0;\n\tftx = 1;\n\tsyscall(SYS_futex, &ftx, FUTEX_WAKE, 0, NULL, NULL, 0);\n\twhile (ftx != 0)\n\t\tsyscall(SYS_futex, &ftx, FUTEX_WAIT, 1, NULL, NULL, 0);\n\n\tasm volatile (\"mov %%gs, %0\" : \"=rm\" (newindex));\n\tnewbase = rdgsbase();\n\n\tif (newindex == index && newbase == base) {\n\t\tprintf(\"[OK]\\tIndex and base were preserved\\n\");\n\t} else {\n\t\tprintf(\"[FAIL]\\tAfter switch, GS = 0x%hx and GSBASE = 0x%lx\\n\",\n\t\t       newindex, newbase);\n\t\tnerrs++;\n\t}\n}\n\nstatic void *threadproc(void *ctx)\n{\n\twhile (1) {\n\t\twhile (ftx == 0)\n\t\t\tsyscall(SYS_futex, &ftx, FUTEX_WAIT, 0, NULL, NULL, 0);\n\t\tif (ftx == 3)\n\t\t\treturn NULL;\n\n\t\tif (ftx == 1) {\n\t\t\tdo_remote_base();\n\t\t} else if (ftx == 2) {\n\t\t\t \n\n\t\t\tload_gs();\n\t\t\tasm volatile (\"mov %0, %%gs\" : : \"rm\" ((unsigned short)0));\n\t\t} else {\n\t\t\terrx(1, \"helper thread got bad command\");\n\t\t}\n\n\t\tftx = 0;\n\t\tsyscall(SYS_futex, &ftx, FUTEX_WAKE, 0, NULL, NULL, 0);\n\t}\n}\n\nstatic void set_gs_and_switch_to(unsigned long local,\n\t\t\t\t unsigned short force_sel,\n\t\t\t\t unsigned long remote)\n{\n\tunsigned long base;\n\tunsigned short sel_pre_sched, sel_post_sched;\n\n\tbool hard_zero = false;\n\tif (local == HARD_ZERO) {\n\t\thard_zero = true;\n\t\tlocal = 0;\n\t}\n\n\tprintf(\"[RUN]\\tARCH_SET_GS(0x%lx)%s, then schedule to 0x%lx\\n\",\n\t       local, hard_zero ? \" and clear gs\" : \"\", remote);\n\tif (force_sel)\n\t\tprintf(\"\\tBefore schedule, set selector to 0x%hx\\n\", force_sel);\n\tif (syscall(SYS_arch_prctl, ARCH_SET_GS, local) != 0)\n\t\terr(1, \"ARCH_SET_GS\");\n\tif (hard_zero)\n\t\tasm volatile (\"mov %0, %%gs\" : : \"rm\" ((unsigned short)0));\n\n\tif (read_base(GS) != local) {\n\t\tnerrs++;\n\t\tprintf(\"[FAIL]\\tGSBASE wasn't set as expected\\n\");\n\t}\n\n\tif (force_sel) {\n\t\tasm volatile (\"mov %0, %%gs\" : : \"rm\" (force_sel));\n\t\tsel_pre_sched = force_sel;\n\t\tlocal = read_base(GS);\n\n\t\t \n\t\tasm volatile (\"mov %0, %%gs\" : : \"rm\" (force_sel));\n\t} else {\n\t\tasm volatile (\"mov %%gs, %0\" : \"=rm\" (sel_pre_sched));\n\t}\n\n\tremote_base = remote;\n\tftx = 1;\n\tsyscall(SYS_futex, &ftx, FUTEX_WAKE, 0, NULL, NULL, 0);\n\twhile (ftx != 0)\n\t\tsyscall(SYS_futex, &ftx, FUTEX_WAIT, 1, NULL, NULL, 0);\n\n\tasm volatile (\"mov %%gs, %0\" : \"=rm\" (sel_post_sched));\n\tbase = read_base(GS);\n\tif (base == local && sel_pre_sched == sel_post_sched) {\n\t\tprintf(\"[OK]\\tGS/BASE remained 0x%hx/0x%lx\\n\",\n\t\t       sel_pre_sched, local);\n\t} else if (base == local && sel_pre_sched >= 1 && sel_pre_sched <= 3 &&\n\t\t   sel_post_sched == 0) {\n\t\t \n\t\tprintf(\"[OK]\\tGS/BASE changed from 0x%hx/0x%lx to 0x%hx/0x%lx because IRET is defective\\n\",\n\t\t       sel_pre_sched, local, sel_post_sched, base);\n\t} else {\n\t\tnerrs++;\n\t\tprintf(\"[FAIL]\\tGS/BASE changed from 0x%hx/0x%lx to 0x%hx/0x%lx\\n\",\n\t\t       sel_pre_sched, local, sel_post_sched, base);\n\t}\n}\n\nstatic void test_unexpected_base(void)\n{\n\tunsigned long base;\n\n\tprintf(\"[RUN]\\tARCH_SET_GS(0), clear gs, then manipulate GSBASE in a different thread\\n\");\n\tif (syscall(SYS_arch_prctl, ARCH_SET_GS, 0) != 0)\n\t\terr(1, \"ARCH_SET_GS\");\n\tasm volatile (\"mov %0, %%gs\" : : \"rm\" ((unsigned short)0));\n\n\tftx = 2;\n\tsyscall(SYS_futex, &ftx, FUTEX_WAKE, 0, NULL, NULL, 0);\n\twhile (ftx != 0)\n\t\tsyscall(SYS_futex, &ftx, FUTEX_WAIT, 1, NULL, NULL, 0);\n\n\tbase = read_base(GS);\n\tif (base == 0) {\n\t\tprintf(\"[OK]\\tGSBASE remained 0\\n\");\n\t} else {\n\t\tnerrs++;\n\t\tprintf(\"[FAIL]\\tGSBASE changed to 0x%lx\\n\", base);\n\t}\n}\n\n#define USER_REGS_OFFSET(r) offsetof(struct user_regs_struct, r)\n\nstatic void test_ptrace_write_gs_read_base(void)\n{\n\tint status;\n\tpid_t child = fork();\n\n\tif (child < 0)\n\t\terr(1, \"fork\");\n\n\tif (child == 0) {\n\t\tprintf(\"[RUN]\\tPTRACE_POKE GS, read GSBASE back\\n\");\n\n\t\tprintf(\"[RUN]\\tARCH_SET_GS to 1\\n\");\n\t\tif (syscall(SYS_arch_prctl, ARCH_SET_GS, 1) != 0)\n\t\t\terr(1, \"ARCH_SET_GS\");\n\n\t\tif (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0)\n\t\t\terr(1, \"PTRACE_TRACEME\");\n\n\t\traise(SIGTRAP);\n\t\t_exit(0);\n\t}\n\n\twait(&status);\n\n\tif (WSTOPSIG(status) == SIGTRAP) {\n\t\tunsigned long base;\n\t\tunsigned long gs_offset = USER_REGS_OFFSET(gs);\n\t\tunsigned long base_offset = USER_REGS_OFFSET(gs_base);\n\n\t\t \n\t\tbase = ptrace(PTRACE_PEEKUSER, child, base_offset, NULL);\n\t\tif (base == 1) {\n\t\t\tprintf(\"[OK]\\tGSBASE started at 1\\n\");\n\t\t} else {\n\t\t\tnerrs++;\n\t\t\tprintf(\"[FAIL]\\tGSBASE started at 0x%lx\\n\", base);\n\t\t}\n\n\t\tprintf(\"[RUN]\\tSet GS = 0x7, read GSBASE\\n\");\n\n\t\t \n\t\tif (ptrace(PTRACE_POKEUSER, child, gs_offset, 0x7) != 0)\n\t\t\terr(1, \"PTRACE_POKEUSER\");\n\n\t\t \n\t\tbase = ptrace(PTRACE_PEEKUSER, child, base_offset, NULL);\n\n\t\tif (base == 0 || base == 1) {\n\t\t\tprintf(\"[OK]\\tGSBASE reads as 0x%lx with invalid GS\\n\", base);\n\t\t} else {\n\t\t\tnerrs++;\n\t\t\tprintf(\"[FAIL]\\tGSBASE=0x%lx (should be 0 or 1)\\n\", base);\n\t\t}\n\t}\n\n\tptrace(PTRACE_CONT, child, NULL, NULL);\n\n\twait(&status);\n\tif (!WIFEXITED(status))\n\t\tprintf(\"[WARN]\\tChild didn't exit cleanly.\\n\");\n}\n\nstatic void test_ptrace_write_gsbase(void)\n{\n\tint status;\n\tpid_t child = fork();\n\n\tif (child < 0)\n\t\terr(1, \"fork\");\n\n\tif (child == 0) {\n\t\tprintf(\"[RUN]\\tPTRACE_POKE(), write GSBASE from ptracer\\n\");\n\n\t\t*shared_scratch = load_gs();\n\n\t\tif (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0)\n\t\t\terr(1, \"PTRACE_TRACEME\");\n\n\t\traise(SIGTRAP);\n\t\t_exit(0);\n\t}\n\n\twait(&status);\n\n\tif (WSTOPSIG(status) == SIGTRAP) {\n\t\tunsigned long gs, base;\n\t\tunsigned long gs_offset = USER_REGS_OFFSET(gs);\n\t\tunsigned long base_offset = USER_REGS_OFFSET(gs_base);\n\n\t\tgs = ptrace(PTRACE_PEEKUSER, child, gs_offset, NULL);\n\n\t\tif (gs != *shared_scratch) {\n\t\t\tnerrs++;\n\t\t\tprintf(\"[FAIL]\\tGS is not prepared with nonzero\\n\");\n\t\t\tgoto END;\n\t\t}\n\n\t\tif (ptrace(PTRACE_POKEUSER, child, base_offset, 0xFF) != 0)\n\t\t\terr(1, \"PTRACE_POKEUSER\");\n\n\t\tgs = ptrace(PTRACE_PEEKUSER, child, gs_offset, NULL);\n\t\tbase = ptrace(PTRACE_PEEKUSER, child, base_offset, NULL);\n\n\t\t \n\t\tif (gs != *shared_scratch) {\n\t\t\tnerrs++;\n\t\t\tprintf(\"[FAIL]\\tGS changed to %lx\\n\", gs);\n\n\t\t\t \n\t\t\tif (gs == 0)\n\t\t\t\tprintf(\"\\tNote: this is expected behavior on older kernels.\\n\");\n\t\t} else if (have_fsgsbase && (base != 0xFF)) {\n\t\t\tnerrs++;\n\t\t\tprintf(\"[FAIL]\\tGSBASE changed to %lx\\n\", base);\n\t\t} else {\n\t\t\tprintf(\"[OK]\\tGS remained 0x%hx\", *shared_scratch);\n\t\t\tif (have_fsgsbase)\n\t\t\t\tprintf(\" and GSBASE changed to 0xFF\");\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\nEND:\n\tptrace(PTRACE_CONT, child, NULL, NULL);\n\twait(&status);\n\tif (!WIFEXITED(status))\n\t\tprintf(\"[WARN]\\tChild didn't exit cleanly.\\n\");\n}\n\nint main()\n{\n\tpthread_t thread;\n\n\tshared_scratch = mmap(NULL, 4096, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n\n\t \n\ttest_ptrace_write_gs_read_base();\n\n\t \n\tsethandler(SIGILL, sigill, 0);\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\trdfsbase();\n\t\thave_fsgsbase = true;\n\t\tprintf(\"\\tFSGSBASE instructions are enabled\\n\");\n\t} else {\n\t\tprintf(\"\\tFSGSBASE instructions are disabled\\n\");\n\t}\n\tclearhandler(SIGILL);\n\n\tsethandler(SIGSEGV, sigsegv, 0);\n\n\tcheck_gs_value(0);\n\tcheck_gs_value(1);\n\tcheck_gs_value(0x200000000);\n\tcheck_gs_value(0);\n\tcheck_gs_value(0x200000000);\n\tcheck_gs_value(1);\n\n\tfor (int sched = 0; sched < 2; sched++) {\n\t\tmov_0_gs(0, !!sched);\n\t\tmov_0_gs(1, !!sched);\n\t\tmov_0_gs(0x200000000, !!sched);\n\t}\n\n\t \n\n\tcpu_set_t cpuset;\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(0, &cpuset);\n\tif (sched_setaffinity(0, sizeof(cpuset), &cpuset) != 0)\n\t\terr(1, \"sched_setaffinity to CPU 0\");\t \n\n\tif (pthread_create(&thread, 0, threadproc, 0) != 0)\n\t\terr(1, \"pthread_create\");\n\n\tstatic unsigned long bases_with_hard_zero[] = {\n\t\t0, HARD_ZERO, 1, 0x200000000,\n\t};\n\n\tfor (int local = 0; local < 4; local++) {\n\t\tfor (int remote = 0; remote < 4; remote++) {\n\t\t\tfor (unsigned short s = 0; s < 5; s++) {\n\t\t\t\tunsigned short sel = s;\n\t\t\t\tif (s == 4)\n\t\t\t\t\tasm (\"mov %%ss, %0\" : \"=rm\" (sel));\n\t\t\t\tset_gs_and_switch_to(\n\t\t\t\t\tbases_with_hard_zero[local],\n\t\t\t\t\tsel,\n\t\t\t\t\tbases_with_hard_zero[remote]);\n\t\t\t}\n\t\t}\n\t}\n\n\ttest_unexpected_base();\n\n\tif (have_fsgsbase) {\n\t\tunsigned short ss;\n\n\t\tasm volatile (\"mov %%ss, %0\" : \"=rm\" (ss));\n\n\t\ttest_wrbase(0, 0);\n\t\ttest_wrbase(0, 1);\n\t\ttest_wrbase(0, 0x200000000);\n\t\ttest_wrbase(0, 0xffffffffffffffff);\n\t\ttest_wrbase(ss, 0);\n\t\ttest_wrbase(ss, 1);\n\t\ttest_wrbase(ss, 0x200000000);\n\t\ttest_wrbase(ss, 0xffffffffffffffff);\n\t}\n\n\tftx = 3;   \n\tsyscall(SYS_futex, &ftx, FUTEX_WAKE, 0, NULL, NULL, 0);\n\n\tif (pthread_join(thread, NULL) != 0)\n\t\terr(1, \"pthread_join\");\n\n\ttest_ptrace_write_gsbase();\n\n\treturn nerrs == 0 ? 0 : 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}