{
  "module_name": "unwind_vdso.c",
  "hash_id": "2a9bb8df7688361fa7775f63363c62279df200e5029ec6023e2649139ce3686a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/unwind_vdso.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <features.h>\n#include <stdio.h>\n\n#include \"helpers.h\"\n\n#if defined(__GLIBC__) && __GLIBC__ == 2 && __GLIBC_MINOR__ < 16\n\nint main()\n{\n\t \n\tprintf(\"[SKIP]\\tGLIBC before 2.16 cannot compile this test\\n\");\n\treturn 0;\n}\n\n#else\n\n#include <sys/time.h>\n#include <stdlib.h>\n#include <syscall.h>\n#include <unistd.h>\n#include <string.h>\n#include <inttypes.h>\n#include <sys/mman.h>\n#include <signal.h>\n#include <sys/ucontext.h>\n#include <err.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <sys/ptrace.h>\n#include <sys/user.h>\n#include <link.h>\n#include <sys/auxv.h>\n#include <dlfcn.h>\n#include <unwind.h>\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic volatile sig_atomic_t nerrs;\nstatic unsigned long sysinfo;\nstatic bool got_sysinfo = false;\nstatic unsigned long return_address;\n\nstruct unwind_state {\n\tunsigned long ip;\t \n\tint depth;\t\t \n};\n\n_Unwind_Reason_Code trace_fn(struct _Unwind_Context * ctx, void *opaque)\n{\n\tstruct unwind_state *state = opaque;\n\tunsigned long ip = _Unwind_GetIP(ctx);\n\n\tif (state->depth == -1) {\n\t\tif (ip == state->ip)\n\t\t\tstate->depth = 0;\n\t\telse\n\t\t\treturn _URC_NO_REASON;\t \n\t}\n\tprintf(\"\\t  0x%lx\\n\", ip);\n\n\tif (ip == return_address) {\n\t\t \n\t\tunsigned long eax = _Unwind_GetGR(ctx, 0);\n\t\tunsigned long ecx = _Unwind_GetGR(ctx, 1);\n\t\tunsigned long edx = _Unwind_GetGR(ctx, 2);\n\t\tunsigned long ebx = _Unwind_GetGR(ctx, 3);\n\t\tunsigned long ebp = _Unwind_GetGR(ctx, 5);\n\t\tunsigned long esi = _Unwind_GetGR(ctx, 6);\n\t\tunsigned long edi = _Unwind_GetGR(ctx, 7);\n\t\tbool ok = (eax == SYS_getpid || eax == getpid()) &&\n\t\t\tebx == 1 && ecx == 2 && edx == 3 &&\n\t\t\tesi == 4 && edi == 5 && ebp == 6;\n\n\t\tif (!ok)\n\t\t\tnerrs++;\n\t\tprintf(\"[%s]\\t  NR = %ld, args = %ld, %ld, %ld, %ld, %ld, %ld\\n\",\n\t\t       (ok ? \"OK\" : \"FAIL\"),\n\t\t       eax, ebx, ecx, edx, esi, edi, ebp);\n\n\t\treturn _URC_NORMAL_STOP;\n\t} else {\n\t\tstate->depth++;\n\t\treturn _URC_NO_REASON;\n\t}\n}\n\nstatic void sigtrap(int sig, siginfo_t *info, void *ctx_void)\n{\n\tucontext_t *ctx = (ucontext_t *)ctx_void;\n\tstruct unwind_state state;\n\tunsigned long ip = ctx->uc_mcontext.gregs[REG_EIP];\n\n\tif (!got_sysinfo && ip == sysinfo) {\n\t\tgot_sysinfo = true;\n\n\t\t \n\t\treturn_address = *(unsigned long *)(unsigned long)ctx->uc_mcontext.gregs[REG_ESP];\n\n\t\tprintf(\"\\tIn vsyscall at 0x%lx, returning to 0x%lx\\n\",\n\t\t       ip, return_address);\n\t}\n\n\tif (!got_sysinfo)\n\t\treturn;\t\t \n\n\tif (ip == return_address) {\n\t\tctx->uc_mcontext.gregs[REG_EFL] &= ~X86_EFLAGS_TF;\n\t\tprintf(\"\\tVsyscall is done\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\tSIGTRAP at 0x%lx\\n\", ip);\n\n\tstate.ip = ip;\n\tstate.depth = -1;\n\t_Unwind_Backtrace(trace_fn, &state);\n}\n\nint main()\n{\n\tsysinfo = getauxval(AT_SYSINFO);\n\tprintf(\"\\tAT_SYSINFO is 0x%lx\\n\", sysinfo);\n\n\tDl_info info;\n\tif (!dladdr((void *)sysinfo, &info)) {\n\t\tprintf(\"[WARN]\\tdladdr failed on AT_SYSINFO\\n\");\n\t} else {\n\t\tprintf(\"[OK]\\tAT_SYSINFO maps to %s, loaded at 0x%p\\n\",\n\t\t       info.dli_fname, info.dli_fbase);\n\t}\n\n\tsethandler(SIGTRAP, sigtrap, 0);\n\n\tsyscall(SYS_getpid);   \n\tprintf(\"[RUN]\\tSet TF and check a fast syscall\\n\");\n\tset_eflags(get_eflags() | X86_EFLAGS_TF);\n\tsyscall(SYS_getpid, 1, 2, 3, 4, 5, 6);\n\tif (!got_sysinfo) {\n\t\tset_eflags(get_eflags() & ~X86_EFLAGS_TF);\n\n\t\t \n\t\tprintf(\"[WARN]\\tsyscall(2) didn't enter AT_SYSINFO\\n\");\n\t}\n\n\tif (get_eflags() & X86_EFLAGS_TF) {\n\t\tprintf(\"[FAIL]\\tTF is still set\\n\");\n\t\tnerrs++;\n\t}\n\n\tif (nerrs) {\n\t\tprintf(\"[FAIL]\\tThere were errors\\n\");\n\t\treturn 1;\n\t} else {\n\t\tprintf(\"[OK]\\tAll is well\\n\");\n\t\treturn 0;\n\t}\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}