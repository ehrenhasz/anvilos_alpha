{
  "module_name": "mov_ss_trap.c",
  "hash_id": "730b80b852991624d24412fd3cbb0f0927a8ea7a685a6312d76de5361efd60ff",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/mov_ss_trap.c",
  "human_readable_source": " \n \n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/user.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <err.h>\n#include <string.h>\n#include <setjmp.h>\n#include <sys/prctl.h>\n\n#define X86_EFLAGS_RF (1UL << 16)\n\n#if __x86_64__\n# define REG_IP REG_RIP\n#else\n# define REG_IP REG_EIP\n#endif\n\nunsigned short ss;\nextern unsigned char breakpoint_insn[];\nsigjmp_buf jmpbuf;\n\nstatic void enable_watchpoint(void)\n{\n\tpid_t parent = getpid();\n\tint status;\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terr(1, \"fork\");\n\n\tif (child) {\n\t\tif (waitpid(child, &status, 0) != child)\n\t\t\terr(1, \"waitpid for child\");\n\t} else {\n\t\tunsigned long dr0, dr1, dr7;\n\n\t\tdr0 = (unsigned long)&ss;\n\t\tdr1 = (unsigned long)breakpoint_insn;\n\t\tdr7 = ((1UL << 1) |\t \n\t\t       (3UL << 16) |\t \n\t\t       (1UL << 18) |\t \n\t\t       (1UL << 3));\t \n\n\t\tif (ptrace(PTRACE_ATTACH, parent, NULL, NULL) != 0)\n\t\t\terr(1, \"PTRACE_ATTACH\");\n\n\t\tif (waitpid(parent, &status, 0) != parent)\n\t\t\terr(1, \"waitpid for child\");\n\n\t\tif (ptrace(PTRACE_POKEUSER, parent, (void *)offsetof(struct user, u_debugreg[0]), dr0) != 0)\n\t\t\terr(1, \"PTRACE_POKEUSER DR0\");\n\n\t\tif (ptrace(PTRACE_POKEUSER, parent, (void *)offsetof(struct user, u_debugreg[1]), dr1) != 0)\n\t\t\terr(1, \"PTRACE_POKEUSER DR1\");\n\n\t\tif (ptrace(PTRACE_POKEUSER, parent, (void *)offsetof(struct user, u_debugreg[7]), dr7) != 0)\n\t\t\terr(1, \"PTRACE_POKEUSER DR7\");\n\n\t\tprintf(\"\\tDR0 = %lx, DR1 = %lx, DR7 = %lx\\n\", dr0, dr1, dr7);\n\n\t\tif (ptrace(PTRACE_DETACH, parent, NULL, NULL) != 0)\n\t\t\terr(1, \"PTRACE_DETACH\");\n\n\t\texit(0);\n\t}\n}\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic char const * const signames[] = {\n\t[SIGSEGV] = \"SIGSEGV\",\n\t[SIGBUS] = \"SIBGUS\",\n\t[SIGTRAP] = \"SIGTRAP\",\n\t[SIGILL] = \"SIGILL\",\n};\n\nstatic void sigtrap(int sig, siginfo_t *si, void *ctx_void)\n{\n\tucontext_t *ctx = ctx_void;\n\n\tprintf(\"\\tGot SIGTRAP with RIP=%lx, EFLAGS.RF=%d\\n\",\n\t       (unsigned long)ctx->uc_mcontext.gregs[REG_IP],\n\t       !!(ctx->uc_mcontext.gregs[REG_EFL] & X86_EFLAGS_RF));\n}\n\nstatic void handle_and_return(int sig, siginfo_t *si, void *ctx_void)\n{\n\tucontext_t *ctx = ctx_void;\n\n\tprintf(\"\\tGot %s with RIP=%lx\\n\", signames[sig],\n\t       (unsigned long)ctx->uc_mcontext.gregs[REG_IP]);\n}\n\nstatic void handle_and_longjmp(int sig, siginfo_t *si, void *ctx_void)\n{\n\tucontext_t *ctx = ctx_void;\n\n\tprintf(\"\\tGot %s with RIP=%lx\\n\", signames[sig],\n\t       (unsigned long)ctx->uc_mcontext.gregs[REG_IP]);\n\n\tsiglongjmp(jmpbuf, 1);\n}\n\nint main()\n{\n\tunsigned long nr;\n\n\tasm volatile (\"mov %%ss, %[ss]\" : [ss] \"=m\" (ss));\n\tprintf(\"\\tSS = 0x%hx, &SS = 0x%p\\n\", ss, &ss);\n\n\tif (prctl(PR_SET_PTRACER, PR_SET_PTRACER_ANY, 0, 0, 0) == 0)\n\t\tprintf(\"\\tPR_SET_PTRACER_ANY succeeded\\n\");\n\n\tprintf(\"\\tSet up a watchpoint\\n\");\n\tsethandler(SIGTRAP, sigtrap, 0);\n\tenable_watchpoint();\n\n\tprintf(\"[RUN]\\tRead from watched memory (should get SIGTRAP)\\n\");\n\tasm volatile (\"mov %[ss], %[tmp]\" : [tmp] \"=r\" (nr) : [ss] \"m\" (ss));\n\n\tprintf(\"[RUN]\\tMOV SS; INT3\\n\");\n\tasm volatile (\"mov %[ss], %%ss; int3\" :: [ss] \"m\" (ss));\n\n\tprintf(\"[RUN]\\tMOV SS; INT 3\\n\");\n\tasm volatile (\"mov %[ss], %%ss; .byte 0xcd, 0x3\" :: [ss] \"m\" (ss));\n\n\tprintf(\"[RUN]\\tMOV SS; CS CS INT3\\n\");\n\tasm volatile (\"mov %[ss], %%ss; .byte 0x2e, 0x2e; int3\" :: [ss] \"m\" (ss));\n\n\tprintf(\"[RUN]\\tMOV SS; CSx14 INT3\\n\");\n\tasm volatile (\"mov %[ss], %%ss; .fill 14,1,0x2e; int3\" :: [ss] \"m\" (ss));\n\n\tprintf(\"[RUN]\\tMOV SS; INT 4\\n\");\n\tsethandler(SIGSEGV, handle_and_return, SA_RESETHAND);\n\tasm volatile (\"mov %[ss], %%ss; int $4\" :: [ss] \"m\" (ss));\n\n#ifdef __i386__\n\tprintf(\"[RUN]\\tMOV SS; INTO\\n\");\n\tsethandler(SIGSEGV, handle_and_return, SA_RESETHAND);\n\tnr = -1;\n\tasm volatile (\"add $1, %[tmp]; mov %[ss], %%ss; into\"\n\t\t      : [tmp] \"+r\" (nr) : [ss] \"m\" (ss));\n#endif\n\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tprintf(\"[RUN]\\tMOV SS; ICEBP\\n\");\n\n\t\t \n\t\tsethandler(SIGILL, handle_and_longjmp, SA_RESETHAND);\n\n\t\tasm volatile (\"mov %[ss], %%ss; .byte 0xf1\" :: [ss] \"m\" (ss));\n\t}\n\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tprintf(\"[RUN]\\tMOV SS; CLI\\n\");\n\t\tsethandler(SIGSEGV, handle_and_longjmp, SA_RESETHAND);\n\t\tasm volatile (\"mov %[ss], %%ss; cli\" :: [ss] \"m\" (ss));\n\t}\n\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tprintf(\"[RUN]\\tMOV SS; #PF\\n\");\n\t\tsethandler(SIGSEGV, handle_and_longjmp, SA_RESETHAND);\n\t\tasm volatile (\"mov %[ss], %%ss; mov (-1), %[tmp]\"\n\t\t\t      : [tmp] \"=r\" (nr) : [ss] \"m\" (ss));\n\t}\n\n\t \n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tprintf(\"[RUN]\\tMOV SS; INT 1\\n\");\n\t\tsethandler(SIGSEGV, handle_and_longjmp, SA_RESETHAND);\n\t\tasm volatile (\"mov %[ss], %%ss; int $1\" :: [ss] \"m\" (ss));\n\t}\n\n#ifdef __x86_64__\n\t \n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tprintf(\"[RUN]\\tMOV SS; SYSCALL\\n\");\n\t\tsethandler(SIGILL, handle_and_longjmp, SA_RESETHAND);\n\t\tnr = SYS_getpid;\n\t\t \n\t\tasm volatile (\"btc $63, %%rsp\\n\\t\"\n\t\t\t      \"mov %[ss], %%ss; syscall\\n\\t\"\n\t\t\t      \"btc $63, %%rsp\"\n\t\t\t      : \"+a\" (nr) : [ss] \"m\" (ss)\n\t\t\t      : \"rcx\"\n#ifdef __x86_64__\n\t\t\t\t, \"r11\"\n#endif\n\t\t\t);\n\t}\n#endif\n\n\tprintf(\"[RUN]\\tMOV SS; breakpointed NOP\\n\");\n\tasm volatile (\"mov %[ss], %%ss; breakpoint_insn: nop\" :: [ss] \"m\" (ss));\n\n\t \n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tprintf(\"[RUN]\\tMOV SS; SYSENTER\\n\");\n\t\tstack_t stack = {\n\t\t\t.ss_sp = malloc(sizeof(char) * SIGSTKSZ),\n\t\t\t.ss_size = SIGSTKSZ,\n\t\t};\n\t\tif (sigaltstack(&stack, NULL) != 0)\n\t\t\terr(1, \"sigaltstack\");\n\t\tsethandler(SIGSEGV, handle_and_longjmp, SA_RESETHAND | SA_ONSTACK);\n\t\tnr = SYS_getpid;\n\t\tfree(stack.ss_sp);\n\t\t \n\t\tasm volatile (\"xorl %%ebp, %%ebp; mov %[ss], %%ss; SYSENTER\" : \"+a\" (nr)\n\t\t\t      : [ss] \"m\" (ss) : \"flags\", \"rcx\"\n#ifdef __x86_64__\n\t\t\t\t, \"r11\"\n#endif\n\t\t\t);\n\n\t\t \n\t}\n\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tprintf(\"[RUN]\\tMOV SS; INT $0x80\\n\");\n\t\tsethandler(SIGSEGV, handle_and_longjmp, SA_RESETHAND);\n\t\tnr = 20;\t \n\t\tasm volatile (\"mov %[ss], %%ss; int $0x80\"\n\t\t\t      : \"+a\" (nr) : [ss] \"m\" (ss)\n\t\t\t      : \"flags\"\n#ifdef __x86_64__\n\t\t\t\t, \"r8\", \"r9\", \"r10\", \"r11\"\n#endif\n\t\t\t);\n\t}\n\n\tprintf(\"[OK]\\tI aten't dead\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}