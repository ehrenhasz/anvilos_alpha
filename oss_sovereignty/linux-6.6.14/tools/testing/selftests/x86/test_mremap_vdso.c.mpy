{
  "module_name": "test_mremap_vdso.c",
  "hash_id": "bc47ef75cbc0fe9b68c21ee46ea09914f320241b07037f0c1c2b8e2553a30b76",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/test_mremap_vdso.c",
  "human_readable_source": "\n \n \n#define _GNU_SOURCE\n#include <stdio.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n\n#include <sys/mman.h>\n#include <sys/auxv.h>\n#include <sys/syscall.h>\n#include <sys/wait.h>\n\n#define PAGE_SIZE\t4096\n\nstatic int try_to_remap(void *vdso_addr, unsigned long size)\n{\n\tvoid *dest_addr, *new_addr;\n\n\t \n\tdest_addr = mmap(0, size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n\tif (dest_addr == MAP_FAILED) {\n\t\tprintf(\"[WARN]\\tmmap failed (%d): %m\\n\", errno);\n\t\treturn 0;\n\t}\n\n\tprintf(\"[NOTE]\\tMoving vDSO: [%p, %#lx] -> [%p, %#lx]\\n\",\n\t\tvdso_addr, (unsigned long)vdso_addr + size,\n\t\tdest_addr, (unsigned long)dest_addr + size);\n\tfflush(stdout);\n\n\tnew_addr = mremap(vdso_addr, size, size,\n\t\t\tMREMAP_FIXED|MREMAP_MAYMOVE, dest_addr);\n\tif ((unsigned long)new_addr == (unsigned long)-1) {\n\t\tmunmap(dest_addr, size);\n\t\tif (errno == EINVAL) {\n\t\t\tprintf(\"[NOTE]\\tvDSO partial move failed, will try with bigger size\\n\");\n\t\t\treturn -1;  \n\t\t}\n\t\tprintf(\"[FAIL]\\tmremap failed (%d): %m\\n\", errno);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n\n}\n\nint main(int argc, char **argv, char **envp)\n{\n\tpid_t child;\n\n\tchild = fork();\n\tif (child == -1) {\n\t\tprintf(\"[WARN]\\tfailed to fork (%d): %m\\n\", errno);\n\t\treturn 1;\n\t}\n\n\tif (child == 0) {\n\t\tunsigned long vdso_size = PAGE_SIZE;\n\t\tunsigned long auxval;\n\t\tint ret = -1;\n\n\t\tauxval = getauxval(AT_SYSINFO_EHDR);\n\t\tprintf(\"\\tAT_SYSINFO_EHDR is %#lx\\n\", auxval);\n\t\tif (!auxval || auxval == -ENOENT) {\n\t\t\tprintf(\"[WARN]\\tgetauxval failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\twhile (ret < 0) {\n\t\t\tret = try_to_remap((void *)auxval, vdso_size);\n\t\t\tvdso_size += PAGE_SIZE;\n\t\t}\n\n#ifdef __i386__\n\t\t \n\t\tasm volatile (\"int $0x80\" : : \"a\" (__NR_exit), \"b\" (!!ret));\n#else  \n\t\tsyscall(SYS_exit, ret);\n#endif\n\t} else {\n\t\tint status;\n\n\t\tif (waitpid(child, &status, 0) != child ||\n\t\t\t!WIFEXITED(status)) {\n\t\t\tprintf(\"[FAIL]\\tmremap() of the vDSO does not work on this kernel!\\n\");\n\t\t\treturn 1;\n\t\t} else if (WEXITSTATUS(status) != 0) {\n\t\t\tprintf(\"[FAIL]\\tChild failed with %d\\n\",\n\t\t\t\t\tWEXITSTATUS(status));\n\t\t\treturn 1;\n\t\t}\n\t\tprintf(\"[OK]\\n\");\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}