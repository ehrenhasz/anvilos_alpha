{
  "module_name": "ptrace_syscall.c",
  "hash_id": "163dc43346f9f6f71b68274ff1456c740420e63adf76a58a23ee77d1ca2fbd9a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/ptrace_syscall.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sys/user.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <err.h>\n#include <string.h>\n#include <asm/ptrace-abi.h>\n#include <sys/auxv.h>\n\n \n#ifdef __x86_64__\n# define user_syscall_nr\torig_rax\n# define user_arg0\t\trdi\n# define user_arg1\t\trsi\n# define user_arg2\t\trdx\n# define user_arg3\t\tr10\n# define user_arg4\t\tr8\n# define user_arg5\t\tr9\n# define user_ip\t\trip\n# define user_ax\t\trax\n#else\n# define user_syscall_nr\torig_eax\n# define user_arg0\t\tebx\n# define user_arg1\t\tecx\n# define user_arg2\t\tedx\n# define user_arg3\t\tesi\n# define user_arg4\t\tedi\n# define user_arg5\t\tebp\n# define user_ip\t\teip\n# define user_ax\t\teax\n#endif\n\nstatic int nerrs = 0;\n\nstruct syscall_args32 {\n\tuint32_t nr, arg0, arg1, arg2, arg3, arg4, arg5;\n};\n\n#ifdef __i386__\nextern void sys32_helper(struct syscall_args32 *, void *);\nextern void int80_and_ret(void);\n#endif\n\n \nstatic void do_full_int80(struct syscall_args32 *args)\n{\n#ifdef __x86_64__\n\tregister unsigned long bp asm(\"bp\") = args->arg5;\n\tasm volatile (\"int $0x80\"\n\t\t      : \"+a\" (args->nr),\n\t\t\t\"+b\" (args->arg0), \"+c\" (args->arg1), \"+d\" (args->arg2),\n\t\t\t\"+S\" (args->arg3), \"+D\" (args->arg4), \"+r\" (bp)\n\t\t\t: : \"r8\", \"r9\", \"r10\", \"r11\");\n\targs->arg5 = bp;\n#else\n\tsys32_helper(args, int80_and_ret);\n#endif\n}\n\n#ifdef __i386__\nstatic void (*vsyscall32)(void);\n\n \nstatic void do_full_vsyscall32(struct syscall_args32 *args)\n{\n\tsys32_helper(args, vsyscall32);\n}\n#endif\n\nstatic siginfo_t wait_trap(pid_t chld)\n{\n\tsiginfo_t si;\n\tif (waitid(P_PID, chld, &si, WEXITED|WSTOPPED) != 0)\n\t\terr(1, \"waitid\");\n\tif (si.si_pid != chld)\n\t\terrx(1, \"got unexpected pid in event\\n\");\n\tif (si.si_code != CLD_TRAPPED)\n\t\terrx(1, \"got unexpected event type %d\\n\", si.si_code);\n\treturn si;\n}\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void setsigign(int sig, int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = (void *)SIG_IGN;\n\tsa.sa_flags = flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic void clearhandler(int sig)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_DFL;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\n#ifdef __x86_64__\n# define REG_BP REG_RBP\n#else\n# define REG_BP REG_EBP\n#endif\n\nstatic void empty_handler(int sig, siginfo_t *si, void *ctx_void)\n{\n}\n\nstatic void test_sys32_regs(void (*do_syscall)(struct syscall_args32 *))\n{\n\tstruct syscall_args32 args = {\n\t\t.nr = 224,\t \n\t\t.arg0 = 10, .arg1 = 11, .arg2 = 12,\n\t\t.arg3 = 13, .arg4 = 14, .arg5 = 15,\n\t};\n\n\tdo_syscall(&args);\n\n\tif (args.nr != getpid() ||\n\t    args.arg0 != 10 || args.arg1 != 11 || args.arg2 != 12 ||\n\t    args.arg3 != 13 || args.arg4 != 14 || args.arg5 != 15) {\n\t\tprintf(\"[FAIL]\\tgetpid() failed to preserve regs\\n\");\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tgetpid() preserves regs\\n\");\n\t}\n\n\tsethandler(SIGUSR1, empty_handler, 0);\n\n\targs.nr = 37;\t \n\targs.arg0 = getpid();\n\targs.arg1 = SIGUSR1;\n\tdo_syscall(&args);\n\tif (args.nr != 0 ||\n\t    args.arg0 != getpid() || args.arg1 != SIGUSR1 || args.arg2 != 12 ||\n\t    args.arg3 != 13 || args.arg4 != 14 || args.arg5 != 15) {\n\t\tprintf(\"[FAIL]\\tkill(getpid(), SIGUSR1) failed to preserve regs\\n\");\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tkill(getpid(), SIGUSR1) preserves regs\\n\");\n\t}\n\tclearhandler(SIGUSR1);\n}\n\nstatic void test_ptrace_syscall_restart(void)\n{\n\tprintf(\"[RUN]\\tptrace-induced syscall restart\\n\");\n\tpid_t chld = fork();\n\tif (chld < 0)\n\t\terr(1, \"fork\");\n\n\tif (chld == 0) {\n\t\tif (ptrace(PTRACE_TRACEME, 0, 0, 0) != 0)\n\t\t\terr(1, \"PTRACE_TRACEME\");\n\n\t\tpid_t pid = getpid(), tid = syscall(SYS_gettid);\n\n\t\tprintf(\"\\tChild will make one syscall\\n\");\n\t\tsyscall(SYS_tgkill, pid, tid, SIGSTOP);\n\n\t\tsyscall(SYS_gettid, 10, 11, 12, 13, 14, 15);\n\t\t_exit(0);\n\t}\n\n\tint status;\n\n\t \n\tif (waitpid(chld, &status, 0) != chld || !WIFSTOPPED(status))\n\t\terr(1, \"waitpid\");\n\n\tstruct user_regs_struct regs;\n\n\tprintf(\"[RUN]\\tSYSEMU\\n\");\n\tif (ptrace(PTRACE_SYSEMU, chld, 0, 0) != 0)\n\t\terr(1, \"PTRACE_SYSEMU\");\n\twait_trap(chld);\n\n\tif (ptrace(PTRACE_GETREGS, chld, 0, &regs) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\n\tif (regs.user_syscall_nr != SYS_gettid ||\n\t    regs.user_arg0 != 10 || regs.user_arg1 != 11 ||\n\t    regs.user_arg2 != 12 || regs.user_arg3 != 13 ||\n\t    regs.user_arg4 != 14 || regs.user_arg5 != 15) {\n\t\tprintf(\"[FAIL]\\tInitial args are wrong (nr=%lu, args=%lu %lu %lu %lu %lu %lu)\\n\", (unsigned long)regs.user_syscall_nr, (unsigned long)regs.user_arg0, (unsigned long)regs.user_arg1, (unsigned long)regs.user_arg2, (unsigned long)regs.user_arg3, (unsigned long)regs.user_arg4, (unsigned long)regs.user_arg5);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tInitial nr and args are correct\\n\");\n\t}\n\n\tprintf(\"[RUN]\\tRestart the syscall (ip = 0x%lx)\\n\",\n\t       (unsigned long)regs.user_ip);\n\n\t \n\tregs.user_ax = regs.user_syscall_nr;\n\tregs.user_ip -= 2;\n\tif (ptrace(PTRACE_SETREGS, chld, 0, &regs) != 0)\n\t\terr(1, \"PTRACE_SETREGS\");\n\n\tif (ptrace(PTRACE_SYSEMU, chld, 0, 0) != 0)\n\t\terr(1, \"PTRACE_SYSEMU\");\n\twait_trap(chld);\n\n\tif (ptrace(PTRACE_GETREGS, chld, 0, &regs) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\n\tif (regs.user_syscall_nr != SYS_gettid ||\n\t    regs.user_arg0 != 10 || regs.user_arg1 != 11 ||\n\t    regs.user_arg2 != 12 || regs.user_arg3 != 13 ||\n\t    regs.user_arg4 != 14 || regs.user_arg5 != 15) {\n\t\tprintf(\"[FAIL]\\tRestart nr or args are wrong (nr=%lu, args=%lu %lu %lu %lu %lu %lu)\\n\", (unsigned long)regs.user_syscall_nr, (unsigned long)regs.user_arg0, (unsigned long)regs.user_arg1, (unsigned long)regs.user_arg2, (unsigned long)regs.user_arg3, (unsigned long)regs.user_arg4, (unsigned long)regs.user_arg5);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tRestarted nr and args are correct\\n\");\n\t}\n\n\tprintf(\"[RUN]\\tChange nr and args and restart the syscall (ip = 0x%lx)\\n\",\n\t       (unsigned long)regs.user_ip);\n\n\tregs.user_ax = SYS_getpid;\n\tregs.user_arg0 = 20;\n\tregs.user_arg1 = 21;\n\tregs.user_arg2 = 22;\n\tregs.user_arg3 = 23;\n\tregs.user_arg4 = 24;\n\tregs.user_arg5 = 25;\n\tregs.user_ip -= 2;\n\n\tif (ptrace(PTRACE_SETREGS, chld, 0, &regs) != 0)\n\t\terr(1, \"PTRACE_SETREGS\");\n\n\tif (ptrace(PTRACE_SYSEMU, chld, 0, 0) != 0)\n\t\terr(1, \"PTRACE_SYSEMU\");\n\twait_trap(chld);\n\n\tif (ptrace(PTRACE_GETREGS, chld, 0, &regs) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\n\tif (regs.user_syscall_nr != SYS_getpid ||\n\t    regs.user_arg0 != 20 || regs.user_arg1 != 21 || regs.user_arg2 != 22 ||\n\t    regs.user_arg3 != 23 || regs.user_arg4 != 24 || regs.user_arg5 != 25) {\n\t\tprintf(\"[FAIL]\\tRestart nr or args are wrong (nr=%lu, args=%lu %lu %lu %lu %lu %lu)\\n\", (unsigned long)regs.user_syscall_nr, (unsigned long)regs.user_arg0, (unsigned long)regs.user_arg1, (unsigned long)regs.user_arg2, (unsigned long)regs.user_arg3, (unsigned long)regs.user_arg4, (unsigned long)regs.user_arg5);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tReplacement nr and args are correct\\n\");\n\t}\n\n\tif (ptrace(PTRACE_CONT, chld, 0, 0) != 0)\n\t\terr(1, \"PTRACE_CONT\");\n\tif (waitpid(chld, &status, 0) != chld)\n\t\terr(1, \"waitpid\");\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n\t\tprintf(\"[FAIL]\\tChild failed\\n\");\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tChild exited cleanly\\n\");\n\t}\n}\n\nstatic void test_restart_under_ptrace(void)\n{\n\tprintf(\"[RUN]\\tkernel syscall restart under ptrace\\n\");\n\tpid_t chld = fork();\n\tif (chld < 0)\n\t\terr(1, \"fork\");\n\n\tif (chld == 0) {\n\t\tif (ptrace(PTRACE_TRACEME, 0, 0, 0) != 0)\n\t\t\terr(1, \"PTRACE_TRACEME\");\n\n\t\tpid_t pid = getpid(), tid = syscall(SYS_gettid);\n\n\t\tprintf(\"\\tChild will take a nap until signaled\\n\");\n\t\tsetsigign(SIGUSR1, SA_RESTART);\n\t\tsyscall(SYS_tgkill, pid, tid, SIGSTOP);\n\n\t\tsyscall(SYS_pause, 0, 0, 0, 0, 0, 0);\n\t\t_exit(0);\n\t}\n\n\tint status;\n\n\t \n\tif (waitpid(chld, &status, 0) != chld || !WIFSTOPPED(status))\n\t\terr(1, \"waitpid\");\n\n\tstruct user_regs_struct regs;\n\n\tprintf(\"[RUN]\\tSYSCALL\\n\");\n\tif (ptrace(PTRACE_SYSCALL, chld, 0, 0) != 0)\n\t\terr(1, \"PTRACE_SYSCALL\");\n\twait_trap(chld);\n\n\t \n\n\tif (ptrace(PTRACE_GETREGS, chld, 0, &regs) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\n\tif (regs.user_syscall_nr != SYS_pause ||\n\t    regs.user_arg0 != 0 || regs.user_arg1 != 0 ||\n\t    regs.user_arg2 != 0 || regs.user_arg3 != 0 ||\n\t    regs.user_arg4 != 0 || regs.user_arg5 != 0) {\n\t\tprintf(\"[FAIL]\\tInitial args are wrong (nr=%lu, args=%lu %lu %lu %lu %lu %lu)\\n\", (unsigned long)regs.user_syscall_nr, (unsigned long)regs.user_arg0, (unsigned long)regs.user_arg1, (unsigned long)regs.user_arg2, (unsigned long)regs.user_arg3, (unsigned long)regs.user_arg4, (unsigned long)regs.user_arg5);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tInitial nr and args are correct\\n\");\n\t}\n\n\t \n\tkill(chld, SIGUSR1);\n\n\t \n\tprintf(\"[RUN]\\tSYSCALL\\n\");\n\tif (ptrace(PTRACE_SYSCALL, chld, 0, 0) != 0)\n\t\terr(1, \"PTRACE_SYSCALL\");\n\twait_trap(chld);\n\n\tif (ptrace(PTRACE_GETREGS, chld, 0, &regs) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\n\tif (regs.user_syscall_nr != SYS_pause ||\n\t    regs.user_arg0 != 0 || regs.user_arg1 != 0 ||\n\t    regs.user_arg2 != 0 || regs.user_arg3 != 0 ||\n\t    regs.user_arg4 != 0 || regs.user_arg5 != 0) {\n\t\tprintf(\"[FAIL]\\tArgs after SIGUSR1 are wrong (nr=%lu, args=%lu %lu %lu %lu %lu %lu)\\n\", (unsigned long)regs.user_syscall_nr, (unsigned long)regs.user_arg0, (unsigned long)regs.user_arg1, (unsigned long)regs.user_arg2, (unsigned long)regs.user_arg3, (unsigned long)regs.user_arg4, (unsigned long)regs.user_arg5);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tArgs after SIGUSR1 are correct (ax = %ld)\\n\",\n\t\t       (long)regs.user_ax);\n\t}\n\n\t \n\tif (ptrace(PTRACE_SETREGS, chld, 0, &regs) != 0)\n\t\terr(1, \"PTRACE_SETREGS\");\n\n\t \n\tif (ptrace(PTRACE_CONT, chld, 0, 0) != 0)\n\t\terr(1, \"PTRACE_CONT\");\n\tif (waitpid(chld, &status, 0) != chld)\n\t\terr(1, \"waitpid\");\n\tif (!WIFSTOPPED(status)) {\n\t\tprintf(\"[FAIL]\\tChild was stopped for SIGUSR1 (status = 0x%x)\\n\", status);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tChild got SIGUSR1\\n\");\n\t}\n\n\t \n\tprintf(\"[RUN]\\tStep again\\n\");\n\tif (ptrace(PTRACE_SYSCALL, chld, 0, 0) != 0)\n\t\terr(1, \"PTRACE_SYSCALL\");\n\twait_trap(chld);\n\n\t \n\n\tif (ptrace(PTRACE_GETREGS, chld, 0, &regs) != 0)\n\t\terr(1, \"PTRACE_GETREGS\");\n\n\tif (regs.user_syscall_nr != SYS_pause ||\n\t    regs.user_arg0 != 0 || regs.user_arg1 != 0 ||\n\t    regs.user_arg2 != 0 || regs.user_arg3 != 0 ||\n\t    regs.user_arg4 != 0 || regs.user_arg5 != 0) {\n\t\tprintf(\"[FAIL]\\tpause did not restart (nr=%lu, args=%lu %lu %lu %lu %lu %lu)\\n\", (unsigned long)regs.user_syscall_nr, (unsigned long)regs.user_arg0, (unsigned long)regs.user_arg1, (unsigned long)regs.user_arg2, (unsigned long)regs.user_arg3, (unsigned long)regs.user_arg4, (unsigned long)regs.user_arg5);\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tpause(2) restarted correctly\\n\");\n\t}\n\n\t \n\tkill(chld, SIGKILL);\n\tif (waitpid(chld, &status, 0) != chld)\n\t\terr(1, \"waitpid\");\n}\n\nint main()\n{\n\tprintf(\"[RUN]\\tCheck int80 return regs\\n\");\n\ttest_sys32_regs(do_full_int80);\n\n#if defined(__i386__) && (!defined(__GLIBC__) || __GLIBC__ > 2 || __GLIBC_MINOR__ >= 16)\n\tvsyscall32 = (void *)getauxval(AT_SYSINFO);\n\tif (vsyscall32) {\n\t\tprintf(\"[RUN]\\tCheck AT_SYSINFO return regs\\n\");\n\t\ttest_sys32_regs(do_full_vsyscall32);\n\t} else {\n\t\tprintf(\"[SKIP]\\tAT_SYSINFO is not available\\n\");\n\t}\n#endif\n\n\ttest_ptrace_syscall_restart();\n\n\ttest_restart_under_ptrace();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}