{
  "module_name": "iopl.c",
  "hash_id": "271794abb7ca71195a6b4a4fa394af7d1d81dd44e4f8e9ffd0614f11b26d752f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/iopl.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <err.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <signal.h>\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <stdbool.h>\n#include <sched.h>\n#include <sys/io.h>\n\nstatic int nerrs = 0;\n\nstatic void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),\n\t\t       int flags)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO | flags;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n\n}\n\nstatic void clearhandler(int sig)\n{\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = SIG_DFL;\n\tsigemptyset(&sa.sa_mask);\n\tif (sigaction(sig, &sa, 0))\n\t\terr(1, \"sigaction\");\n}\n\nstatic jmp_buf jmpbuf;\n\nstatic void sigsegv(int sig, siginfo_t *si, void *ctx_void)\n{\n\tsiglongjmp(jmpbuf, 1);\n}\n\nstatic bool try_outb(unsigned short port)\n{\n\tsethandler(SIGSEGV, sigsegv, SA_RESETHAND);\n\tif (sigsetjmp(jmpbuf, 1) != 0) {\n\t\treturn false;\n\t} else {\n\t\tasm volatile (\"outb %%al, %w[port]\"\n\t\t\t      : : [port] \"Nd\" (port), \"a\" (0));\n\t\treturn true;\n\t}\n\tclearhandler(SIGSEGV);\n}\n\nstatic void expect_ok_outb(unsigned short port)\n{\n\tif (!try_outb(port)) {\n\t\tprintf(\"[FAIL]\\toutb to 0x%02hx failed\\n\", port);\n\t\texit(1);\n\t}\n\n\tprintf(\"[OK]\\toutb to 0x%02hx worked\\n\", port);\n}\n\nstatic void expect_gp_outb(unsigned short port)\n{\n\tif (try_outb(port)) {\n\t\tprintf(\"[FAIL]\\toutb to 0x%02hx worked\\n\", port);\n\t\tnerrs++;\n\t}\n\n\tprintf(\"[OK]\\toutb to 0x%02hx failed\\n\", port);\n}\n\n#define RET_FAULTED\t0\n#define RET_FAIL\t1\n#define RET_EMUL\t2\n\nstatic int try_cli(void)\n{\n\tunsigned long flags;\n\n\tsethandler(SIGSEGV, sigsegv, SA_RESETHAND);\n\tif (sigsetjmp(jmpbuf, 1) != 0) {\n\t\treturn RET_FAULTED;\n\t} else {\n\t\tasm volatile(\"cli; pushf; pop %[flags]\"\n\t\t\t\t: [flags] \"=rm\" (flags));\n\n\t\t \n\t\tif (!(flags & (1 << 9)))\n\t\t\treturn RET_FAIL;\n\t\telse\n\t\t\treturn RET_EMUL;\n\t}\n\tclearhandler(SIGSEGV);\n}\n\nstatic int try_sti(bool irqs_off)\n{\n\tunsigned long flags;\n\n\tsethandler(SIGSEGV, sigsegv, SA_RESETHAND);\n\tif (sigsetjmp(jmpbuf, 1) != 0) {\n\t\treturn RET_FAULTED;\n\t} else {\n\t\tasm volatile(\"sti; pushf; pop %[flags]\"\n\t\t\t\t: [flags] \"=rm\" (flags));\n\n\t\t \n\t\tif (irqs_off && (flags & (1 << 9)))\n\t\t\treturn RET_FAIL;\n\t\telse\n\t\t\treturn RET_EMUL;\n\t}\n\tclearhandler(SIGSEGV);\n}\n\nstatic void expect_gp_sti(bool irqs_off)\n{\n\tint ret = try_sti(irqs_off);\n\n\tswitch (ret) {\n\tcase RET_FAULTED:\n\t\tprintf(\"[OK]\\tSTI faulted\\n\");\n\t\tbreak;\n\tcase RET_EMUL:\n\t\tprintf(\"[OK]\\tSTI NOPped\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"[FAIL]\\tSTI worked\\n\");\n\t\tnerrs++;\n\t}\n}\n\n \nstatic bool test_cli(void)\n{\n\tint ret = try_cli();\n\n\tswitch (ret) {\n\tcase RET_FAULTED:\n\t\tprintf(\"[OK]\\tCLI faulted\\n\");\n\t\tbreak;\n\tcase RET_EMUL:\n\t\tprintf(\"[OK]\\tCLI NOPped\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"[FAIL]\\tCLI worked\\n\");\n\t\tnerrs++;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint main(void)\n{\n\tcpu_set_t cpuset;\n\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(0, &cpuset);\n\tif (sched_setaffinity(0, sizeof(cpuset), &cpuset) != 0)\n\t\terr(1, \"sched_setaffinity to CPU 0\");\n\n\t \n\tswitch(iopl(3)) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOSYS:\n\t\tprintf(\"[OK]\\tiopl() nor supported\\n\");\n\t\treturn 0;\n\tdefault:\n\t\tprintf(\"[OK]\\tiopl(3) failed (%d) -- try running as root\\n\",\n\t\t       errno);\n\t\treturn 0;\n\t}\n\n\t \n\texpect_gp_sti(test_cli());\n\texpect_ok_outb(0x80);\n\n\t \n\tif (ioperm(0x80, 1, 1) != 0)\n\t\terr(1, \"ioperm(0x80, 1, 1) failed\\n\");\n\n\t \n\tif (iopl(0) != 0)\n\t\terr(1, \"iopl(0)\");\n\n\t \n\texpect_ok_outb(0x80);\n\texpect_gp_outb(0xed);\n\t \n\tif (ioperm(0x80, 1, 0) != 0)\n\t\terr(1, \"ioperm(0x80, 1, 0) failed\\n\");\n\n\tpid_t child = fork();\n\tif (child == -1)\n\t\terr(1, \"fork\");\n\n\tif (child == 0) {\n\t\tprintf(\"\\tchild: set IOPL to 3\\n\");\n\t\tif (iopl(3) != 0)\n\t\t\terr(1, \"iopl\");\n\n\t\tprintf(\"[RUN]\\tchild: write to 0x80\\n\");\n\t\tasm volatile (\"outb %%al, $0x80\" : : \"a\" (0));\n\n\t\treturn 0;\n\t} else {\n\t\tint status;\n\t\tif (waitpid(child, &status, 0) != child ||\n\t\t    !WIFEXITED(status)) {\n\t\t\tprintf(\"[FAIL]\\tChild died\\n\");\n\t\t\tnerrs++;\n\t\t} else if (WEXITSTATUS(status) != 0) {\n\t\t\tprintf(\"[FAIL]\\tChild failed\\n\");\n\t\t\tnerrs++;\n\t\t} else {\n\t\t\tprintf(\"[OK]\\tChild succeeded\\n\");\n\t\t}\n\t}\n\n\tprintf(\"[RUN]\\tparent: write to 0x80 (should fail)\\n\");\n\n\texpect_gp_outb(0x80);\n\texpect_gp_sti(test_cli());\n\n\t \n\tprintf(\"\\tiopl(3)\\n\");\n\tif (iopl(3) != 0)\n\t\terr(1, \"iopl(3)\");\n\n\tprintf(\"\\tDrop privileges\\n\");\n\tif (setresuid(1, 1, 1) != 0) {\n\t\tprintf(\"[WARN]\\tDropping privileges failed\\n\");\n\t\tgoto done;\n\t}\n\n\tprintf(\"[RUN]\\tiopl(3) unprivileged but with IOPL==3\\n\");\n\tif (iopl(3) != 0) {\n\t\tprintf(\"[FAIL]\\tiopl(3) should work if iopl is already 3 even if unprivileged\\n\");\n\t\tnerrs++;\n\t}\n\n\tprintf(\"[RUN]\\tiopl(0) unprivileged\\n\");\n\tif (iopl(0) != 0) {\n\t\tprintf(\"[FAIL]\\tiopl(0) should work if iopl is already 3 even if unprivileged\\n\");\n\t\tnerrs++;\n\t}\n\n\tprintf(\"[RUN]\\tiopl(3) unprivileged\\n\");\n\tif (iopl(3) == 0) {\n\t\tprintf(\"[FAIL]\\tiopl(3) should fail if when unprivileged if iopl==0\\n\");\n\t\tnerrs++;\n\t} else {\n\t\tprintf(\"[OK]\\tFailed as expected\\n\");\n\t}\n\ndone:\n\treturn nerrs ? 1 : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}