{
  "module_name": "test_shadow_stack.c",
  "hash_id": "60f5d4efaebb80ba1bcf8b37f50dc3ee8fc8c91dbf4909dde6abecb1d4ee67fc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/x86/test_shadow_stack.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <sys/syscall.h>\n#include <asm/mman.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <x86intrin.h>\n#include <asm/prctl.h>\n#include <sys/prctl.h>\n#include <stdint.h>\n#include <signal.h>\n#include <pthread.h>\n#include <sys/ioctl.h>\n#include <linux/userfaultfd.h>\n#include <setjmp.h>\n#include <sys/ptrace.h>\n#include <sys/signal.h>\n#include <linux/elf.h>\n\n \n#ifndef __NR_map_shadow_stack\n#define __NR_map_shadow_stack\t453\n\n#define SHADOW_STACK_SET_TOKEN\t(1ULL << 0)\n\n#define ARCH_SHSTK_ENABLE\t0x5001\n#define ARCH_SHSTK_DISABLE\t0x5002\n#define ARCH_SHSTK_LOCK\t\t0x5003\n#define ARCH_SHSTK_UNLOCK\t0x5004\n#define ARCH_SHSTK_STATUS\t0x5005\n\n#define ARCH_SHSTK_SHSTK\t(1ULL <<  0)\n#define ARCH_SHSTK_WRSS\t\t(1ULL <<  1)\n\n#define NT_X86_SHSTK\t0x204\n#endif\n\n#define SS_SIZE 0x200000\n#define PAGE_SIZE 0x1000\n\n#if (__GNUC__ < 8) || (__GNUC__ == 8 && __GNUC_MINOR__ < 5)\nint main(int argc, char *argv[])\n{\n\tprintf(\"[SKIP]\\tCompiler does not support CET.\\n\");\n\treturn 0;\n}\n#else\nvoid write_shstk(unsigned long *addr, unsigned long val)\n{\n\tasm volatile(\"wrssq %[val], (%[addr])\\n\"\n\t\t     : \"=m\" (addr)\n\t\t     : [addr] \"r\" (addr), [val] \"r\" (val));\n}\n\nstatic inline unsigned long __attribute__((always_inline)) get_ssp(void)\n{\n\tunsigned long ret = 0;\n\n\tasm volatile(\"xor %0, %0; rdsspq %0\" : \"=r\" (ret));\n\treturn ret;\n}\n\n \n#define ARCH_PRCTL(arg1, arg2)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tlong _ret;\t\t\t\t\t\t\\\n\tregister long _num  asm(\"eax\") = __NR_arch_prctl;\t\\\n\tregister long _arg1 asm(\"rdi\") = (long)(arg1);\t\t\\\n\tregister long _arg2 asm(\"rsi\") = (long)(arg2);\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tasm volatile (\t\t\t\t\t\t\\\n\t\t\"syscall\\n\"\t\t\t\t\t\\\n\t\t: \"=a\"(_ret)\t\t\t\t\t\\\n\t\t: \"r\"(_arg1), \"r\"(_arg2),\t\t\t\\\n\t\t  \"0\"(_num)\t\t\t\t\t\\\n\t\t: \"rcx\", \"r11\", \"memory\", \"cc\"\t\t\t\\\n\t);\t\t\t\t\t\t\t\\\n\t_ret;\t\t\t\t\t\t\t\\\n})\n\nvoid *create_shstk(void *addr)\n{\n\treturn (void *)syscall(__NR_map_shadow_stack, addr, SS_SIZE, SHADOW_STACK_SET_TOKEN);\n}\n\nvoid *create_normal_mem(void *addr)\n{\n\treturn mmap(addr, SS_SIZE, PROT_READ | PROT_WRITE,\n\t\t    MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n}\n\nvoid free_shstk(void *shstk)\n{\n\tmunmap(shstk, SS_SIZE);\n}\n\nint reset_shstk(void *shstk)\n{\n\treturn madvise(shstk, SS_SIZE, MADV_DONTNEED);\n}\n\nvoid try_shstk(unsigned long new_ssp)\n{\n\tunsigned long ssp;\n\n\tprintf(\"[INFO]\\tnew_ssp = %lx, *new_ssp = %lx\\n\",\n\t       new_ssp, *((unsigned long *)new_ssp));\n\n\tssp = get_ssp();\n\tprintf(\"[INFO]\\tchanging ssp from %lx to %lx\\n\", ssp, new_ssp);\n\n\tasm volatile(\"rstorssp (%0)\\n\":: \"r\" (new_ssp));\n\tasm volatile(\"saveprevssp\");\n\tprintf(\"[INFO]\\tssp is now %lx\\n\", get_ssp());\n\n\t \n\tssp -= 8;\n\tasm volatile(\"rstorssp (%0)\\n\":: \"r\" (ssp));\n\tasm volatile(\"saveprevssp\");\n}\n\nint test_shstk_pivot(void)\n{\n\tvoid *shstk = create_shstk(0);\n\n\tif (shstk == MAP_FAILED) {\n\t\tprintf(\"[FAIL]\\tError creating shadow stack: %d\\n\", errno);\n\t\treturn 1;\n\t}\n\ttry_shstk((unsigned long)shstk + SS_SIZE - 8);\n\tfree_shstk(shstk);\n\n\tprintf(\"[OK]\\tShadow stack pivot\\n\");\n\treturn 0;\n}\n\nint test_shstk_faults(void)\n{\n\tunsigned long *shstk = create_shstk(0);\n\n\t \n\tif (*shstk != 0)\n\t\tgoto err;\n\n\t \n\twrite_shstk(shstk, 1);\n\tif (*shstk != 1)\n\t\tgoto err;\n\n\t \n\tif (reset_shstk((void *)shstk))\n\t\tgoto err;\n\n\twrite_shstk(shstk, 1);\n\tif (*shstk != 1)\n\t\tgoto err;\n\n\tprintf(\"[OK]\\tShadow stack faults\\n\");\n\treturn 0;\n\nerr:\n\treturn 1;\n}\n\nunsigned long saved_ssp;\nunsigned long saved_ssp_val;\nvolatile bool segv_triggered;\n\nvoid __attribute__((noinline)) violate_ss(void)\n{\n\tsaved_ssp = get_ssp();\n\tsaved_ssp_val = *(unsigned long *)saved_ssp;\n\n\t \n\tprintf(\"[INFO]\\tCorrupting shadow stack\\n\");\n\twrite_shstk((void *)saved_ssp, 0);\n}\n\nvoid segv_handler(int signum, siginfo_t *si, void *uc)\n{\n\tprintf(\"[INFO]\\tGenerated shadow stack violation successfully\\n\");\n\n\tsegv_triggered = true;\n\n\t \n\twrite_shstk((void *)saved_ssp, saved_ssp_val);\n}\n\nint test_shstk_violation(void)\n{\n\tstruct sigaction sa = {};\n\n\tsa.sa_sigaction = segv_handler;\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGSEGV, &sa, NULL))\n\t\treturn 1;\n\n\tsegv_triggered = false;\n\n\t \n\tasm volatile(\"\" : : : \"memory\");\n\n\tviolate_ss();\n\n\tsignal(SIGSEGV, SIG_DFL);\n\n\tprintf(\"[OK]\\tShadow stack violation test\\n\");\n\n\treturn !segv_triggered;\n}\n\n \n#define MAGIC_VAL 0x12345678\nbool is_shstk_access;\nvoid *shstk_ptr;\nint fd;\n\nvoid reset_test_shstk(void *addr)\n{\n\tif (shstk_ptr)\n\t\tfree_shstk(shstk_ptr);\n\tshstk_ptr = create_shstk(addr);\n}\n\nvoid test_access_fix_handler(int signum, siginfo_t *si, void *uc)\n{\n\tprintf(\"[INFO]\\tViolation from %s\\n\", is_shstk_access ? \"shstk access\" : \"normal write\");\n\n\tsegv_triggered = true;\n\n\t \n\tif (is_shstk_access) {\n\t\treset_test_shstk(shstk_ptr);\n\t\treturn;\n\t}\n\n\tfree_shstk(shstk_ptr);\n\tcreate_normal_mem(shstk_ptr);\n}\n\nbool test_shstk_access(void *ptr)\n{\n\tis_shstk_access = true;\n\tsegv_triggered = false;\n\twrite_shstk(ptr, MAGIC_VAL);\n\n\tasm volatile(\"\" : : : \"memory\");\n\n\treturn segv_triggered;\n}\n\nbool test_write_access(void *ptr)\n{\n\tis_shstk_access = false;\n\tsegv_triggered = false;\n\t*(unsigned long *)ptr = MAGIC_VAL;\n\n\tasm volatile(\"\" : : : \"memory\");\n\n\treturn segv_triggered;\n}\n\nbool gup_write(void *ptr)\n{\n\tunsigned long val;\n\n\tlseek(fd, (unsigned long)ptr, SEEK_SET);\n\tif (write(fd, &val, sizeof(val)) < 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nbool gup_read(void *ptr)\n{\n\tunsigned long val;\n\n\tlseek(fd, (unsigned long)ptr, SEEK_SET);\n\tif (read(fd, &val, sizeof(val)) < 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint test_gup(void)\n{\n\tstruct sigaction sa = {};\n\tint status;\n\tpid_t pid;\n\n\tsa.sa_sigaction = test_access_fix_handler;\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGSEGV, &sa, NULL))\n\t\treturn 1;\n\n\tsegv_triggered = false;\n\n\tfd = open(\"/proc/self/mem\", O_RDWR);\n\tif (fd == -1)\n\t\treturn 1;\n\n\treset_test_shstk(0);\n\tif (gup_read(shstk_ptr))\n\t\treturn 1;\n\tif (test_shstk_access(shstk_ptr))\n\t\treturn 1;\n\tprintf(\"[INFO]\\tGup read -> shstk access success\\n\");\n\n\treset_test_shstk(0);\n\tif (gup_write(shstk_ptr))\n\t\treturn 1;\n\tif (test_shstk_access(shstk_ptr))\n\t\treturn 1;\n\tprintf(\"[INFO]\\tGup write -> shstk access success\\n\");\n\n\treset_test_shstk(0);\n\tif (gup_read(shstk_ptr))\n\t\treturn 1;\n\tif (!test_write_access(shstk_ptr))\n\t\treturn 1;\n\tprintf(\"[INFO]\\tGup read -> write access success\\n\");\n\n\treset_test_shstk(0);\n\tif (gup_write(shstk_ptr))\n\t\treturn 1;\n\tif (!test_write_access(shstk_ptr))\n\t\treturn 1;\n\tprintf(\"[INFO]\\tGup write -> write access success\\n\");\n\n\tclose(fd);\n\n\t \n\treset_test_shstk(0);\n\tpid = fork();\n\tif (!pid) {\n\t\tfd = open(\"/proc/self/mem\", O_RDWR);\n\t\tif (fd == -1)\n\t\t\texit(1);\n\n\t\tif (gup_write(shstk_ptr)) {\n\t\t\tclose(fd);\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\texit(0);\n\t}\n\twaitpid(pid, &status, 0);\n\tif (WEXITSTATUS(status)) {\n\t\tprintf(\"[FAIL]\\tWrite in child failed\\n\");\n\t\treturn 1;\n\t}\n\tif (*(unsigned long *)shstk_ptr == MAGIC_VAL) {\n\t\tprintf(\"[FAIL]\\tWrite in child wrote through to shared memory\\n\");\n\t\treturn 1;\n\t}\n\n\tprintf(\"[INFO]\\tCow gup write -> write access success\\n\");\n\n\tfree_shstk(shstk_ptr);\n\n\tsignal(SIGSEGV, SIG_DFL);\n\n\tprintf(\"[OK]\\tShadow gup test\\n\");\n\n\treturn 0;\n}\n\nint test_mprotect(void)\n{\n\tstruct sigaction sa = {};\n\n\tsa.sa_sigaction = test_access_fix_handler;\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGSEGV, &sa, NULL))\n\t\treturn 1;\n\n\tsegv_triggered = false;\n\n\t \n\treset_test_shstk(0);\n\tif (mprotect(shstk_ptr, SS_SIZE, PROT_READ) < 0) {\n\t\tprintf(\"[FAIL]\\tmprotect(PROT_READ) failed\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (!test_shstk_access(shstk_ptr)) {\n\t\tprintf(\"[FAIL]\\tShadow stack access to read-only memory succeeded\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (mprotect(shstk_ptr, SS_SIZE, PROT_READ) < 0) {\n\t\tprintf(\"[FAIL]\\tmprotect(PROT_READ) failed\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (mprotect(shstk_ptr, SS_SIZE, PROT_WRITE | PROT_READ) < 0) {\n\t\tprintf(\"[FAIL]\\tmprotect(PROT_WRITE) failed\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (test_shstk_access(shstk_ptr)) {\n\t\tprintf(\"[FAIL]\\tShadow stack access to mprotect() writable memory failed\\n\");\n\t\treturn 1;\n\t}\n\n\tfree_shstk(shstk_ptr);\n\n\tsignal(SIGSEGV, SIG_DFL);\n\n\tprintf(\"[OK]\\tmprotect() test\\n\");\n\n\treturn 0;\n}\n\nchar zero[4096];\n\nstatic void *uffd_thread(void *arg)\n{\n\tstruct uffdio_copy req;\n\tint uffd = *(int *)arg;\n\tstruct uffd_msg msg;\n\tint ret;\n\n\twhile (1) {\n\t\tret = read(uffd, &msg, sizeof(msg));\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\telse if (errno == EAGAIN)\n\t\t\tcontinue;\n\t\treturn (void *)1;\n\t}\n\n\treq.dst = msg.arg.pagefault.address;\n\treq.src = (__u64)zero;\n\treq.len = 4096;\n\treq.mode = 0;\n\n\tif (ioctl(uffd, UFFDIO_COPY, &req))\n\t\treturn (void *)1;\n\n\treturn (void *)0;\n}\n\nint test_userfaultfd(void)\n{\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_api uffdio_api;\n\tstruct sigaction sa = {};\n\tpthread_t thread;\n\tvoid *res;\n\tint uffd;\n\n\tsa.sa_sigaction = test_access_fix_handler;\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGSEGV, &sa, NULL))\n\t\treturn 1;\n\n\tuffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\tif (uffd < 0) {\n\t\tprintf(\"[SKIP]\\tUserfaultfd unavailable.\\n\");\n\t\treturn 0;\n\t}\n\n\treset_test_shstk(0);\n\n\tuffdio_api.api = UFFD_API;\n\tuffdio_api.features = 0;\n\tif (ioctl(uffd, UFFDIO_API, &uffdio_api))\n\t\tgoto err;\n\n\tuffdio_register.range.start = (__u64)shstk_ptr;\n\tuffdio_register.range.len = 4096;\n\tuffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n\tif (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register))\n\t\tgoto err;\n\n\tif (pthread_create(&thread, NULL, &uffd_thread, &uffd))\n\t\tgoto err;\n\n\treset_shstk(shstk_ptr);\n\ttest_shstk_access(shstk_ptr);\n\n\tif (pthread_join(thread, &res))\n\t\tgoto err;\n\n\tif (test_shstk_access(shstk_ptr))\n\t\tgoto err;\n\n\tfree_shstk(shstk_ptr);\n\n\tsignal(SIGSEGV, SIG_DFL);\n\n\tif (!res)\n\t\tprintf(\"[OK]\\tUserfaultfd test\\n\");\n\treturn !!res;\nerr:\n\tfree_shstk(shstk_ptr);\n\tclose(uffd);\n\tsignal(SIGSEGV, SIG_DFL);\n\treturn 1;\n}\n\n \nstruct node {\n\tstruct node *next;\n\tvoid *mapping;\n};\n\n \nint test_guard_gap(void)\n{\n\tvoid *free_area, *shstk, *test_map = (void *)0xFFFFFFFFFFFFFFFF;\n\tstruct node *head = NULL, *cur;\n\n\tfree_area = mmap(0, SS_SIZE * 3, PROT_READ | PROT_WRITE,\n\t\t\t MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tmunmap(free_area, SS_SIZE * 3);\n\n\tshstk = create_shstk(free_area + SS_SIZE);\n\tif (shstk == MAP_FAILED)\n\t\treturn 1;\n\n\twhile (test_map > shstk) {\n\t\ttest_map = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE,\n\t\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\t\tif (test_map == MAP_FAILED)\n\t\t\treturn 1;\n\t\tcur = malloc(sizeof(*cur));\n\t\tcur->mapping = test_map;\n\n\t\tcur->next = head;\n\t\thead = cur;\n\t}\n\n\twhile (head) {\n\t\tcur = head;\n\t\thead = cur->next;\n\t\tmunmap(cur->mapping, PAGE_SIZE);\n\t\tfree(cur);\n\t}\n\n\tfree_shstk(shstk);\n\n\tif (shstk - test_map - PAGE_SIZE != PAGE_SIZE)\n\t\treturn 1;\n\n\tprintf(\"[OK]\\tGuard gap test\\n\");\n\n\treturn 0;\n}\n\n \n#define __NR_compat_sigaction 67\n\n \nint sigaction32(int signum, const struct sigaction *restrict act,\n\t\tstruct sigaction *restrict oldact)\n{\n\tregister long syscall_reg asm(\"eax\") = __NR_compat_sigaction;\n\tregister long signum_reg asm(\"ebx\") = signum;\n\tregister long act_reg asm(\"ecx\") = (long)act;\n\tregister long oldact_reg asm(\"edx\") = (long)oldact;\n\tint ret = 0;\n\n\tasm volatile (\"int $0x80;\"\n\t\t      : \"=a\"(ret), \"=m\"(oldact)\n\t\t      : \"r\"(syscall_reg), \"r\"(signum_reg), \"r\"(act_reg),\n\t\t\t\"r\"(oldact_reg)\n\t\t      : \"r8\", \"r9\", \"r10\", \"r11\"\n\t\t     );\n\n\treturn ret;\n}\n\nsigjmp_buf jmp_buffer;\n\nvoid segv_gp_handler(int signum, siginfo_t *si, void *uc)\n{\n\tsegv_triggered = true;\n\n\t \n\tARCH_PRCTL(ARCH_SHSTK_DISABLE, ARCH_SHSTK_SHSTK);\n\tsiglongjmp(jmp_buffer, -1);\n}\n\n \nint test_32bit(void)\n{\n\tstruct sigaction sa = {};\n\tstruct sigaction *sa32;\n\n\t \n\tsa32 = mmap(0, 4096, PROT_READ | PROT_WRITE,\n\t\t    MAP_32BIT | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n\tsa32->sa_flags = SA_SIGINFO;\n\n\tsa.sa_sigaction = segv_gp_handler;\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGSEGV, &sa, NULL))\n\t\treturn 1;\n\n\n\tsegv_triggered = false;\n\n\t \n\tasm volatile(\"\" : : : \"memory\");\n\n\t \n\tsa32->sa_handler = (void *)sa32;\n\tif (sigaction32(SIGUSR1, sa32, NULL))\n\t\treturn 1;\n\n\tif (!sigsetjmp(jmp_buffer, 1))\n\t\traise(SIGUSR1);\n\n\tif (segv_triggered)\n\t\tprintf(\"[OK]\\t32 bit test\\n\");\n\n\treturn !segv_triggered;\n}\n\nvoid segv_handler_ptrace(int signum, siginfo_t *si, void *uc)\n{\n\t \n\texit(0);\n}\n\nint test_ptrace(void)\n{\n\tunsigned long saved_ssp, ssp = 0;\n\tstruct sigaction sa= {};\n\tstruct iovec iov;\n\tint status;\n\tint pid;\n\n\tiov.iov_base = &ssp;\n\tiov.iov_len = sizeof(ssp);\n\n\tpid = fork();\n\tif (!pid) {\n\t\tssp = get_ssp();\n\n\t\tsa.sa_sigaction = segv_handler_ptrace;\n\t\tsa.sa_flags = SA_SIGINFO;\n\t\tif (sigaction(SIGSEGV, &sa, NULL))\n\t\t\treturn 1;\n\n\t\tptrace(PTRACE_TRACEME, NULL, NULL, NULL);\n\t\t \n\t\traise(SIGTRAP);\n\n\t\texit(1);\n\t}\n\n\twhile (waitpid(pid, &status, 0) != -1 && WSTOPSIG(status) != SIGTRAP);\n\n\tif (ptrace(PTRACE_GETREGSET, pid, NT_X86_SHSTK, &iov)) {\n\t\tprintf(\"[INFO]\\tFailed to PTRACE_GETREGS\\n\");\n\t\tgoto out_kill;\n\t}\n\n\tif (!ssp) {\n\t\tprintf(\"[INFO]\\tPtrace child SSP was 0\\n\");\n\t\tgoto out_kill;\n\t}\n\n\tsaved_ssp = ssp;\n\n\tiov.iov_len = 0;\n\tif (!ptrace(PTRACE_SETREGSET, pid, NT_X86_SHSTK, &iov)) {\n\t\tprintf(\"[INFO]\\tToo small size accepted via PTRACE_SETREGS\\n\");\n\t\tgoto out_kill;\n\t}\n\n\tiov.iov_len = sizeof(ssp) + 1;\n\tif (!ptrace(PTRACE_SETREGSET, pid, NT_X86_SHSTK, &iov)) {\n\t\tprintf(\"[INFO]\\tToo large size accepted via PTRACE_SETREGS\\n\");\n\t\tgoto out_kill;\n\t}\n\n\tssp += 1;\n\tif (!ptrace(PTRACE_SETREGSET, pid, NT_X86_SHSTK, &iov)) {\n\t\tprintf(\"[INFO]\\tUnaligned SSP written via PTRACE_SETREGS\\n\");\n\t\tgoto out_kill;\n\t}\n\n\tssp = 0xFFFFFFFFFFFF0000;\n\tif (!ptrace(PTRACE_SETREGSET, pid, NT_X86_SHSTK, &iov)) {\n\t\tprintf(\"[INFO]\\tKernel range SSP written via PTRACE_SETREGS\\n\");\n\t\tgoto out_kill;\n\t}\n\n\t \n\tssp = saved_ssp + 8;\n\tiov.iov_len = sizeof(ssp);\n\tif (ptrace(PTRACE_SETREGSET, pid, NT_X86_SHSTK, &iov)) {\n\t\tprintf(\"[INFO]\\tFailed to PTRACE_SETREGS\\n\");\n\t\tgoto out_kill;\n\t}\n\n\tif (ptrace(PTRACE_DETACH, pid, NULL, NULL)) {\n\t\tprintf(\"[INFO]\\tFailed to PTRACE_DETACH\\n\");\n\t\tgoto out_kill;\n\t}\n\n\twaitpid(pid, &status, 0);\n\tif (WEXITSTATUS(status))\n\t\treturn 1;\n\n\tprintf(\"[OK]\\tPtrace test\\n\");\n\treturn 0;\n\nout_kill:\n\tkill(pid, SIGKILL);\n\treturn 1;\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret = 0;\n\n\tif (ARCH_PRCTL(ARCH_SHSTK_ENABLE, ARCH_SHSTK_SHSTK)) {\n\t\tprintf(\"[SKIP]\\tCould not enable Shadow stack\\n\");\n\t\treturn 1;\n\t}\n\n\tif (ARCH_PRCTL(ARCH_SHSTK_DISABLE, ARCH_SHSTK_SHSTK)) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tDisabling shadow stack failed\\n\");\n\t}\n\n\tif (ARCH_PRCTL(ARCH_SHSTK_ENABLE, ARCH_SHSTK_SHSTK)) {\n\t\tprintf(\"[SKIP]\\tCould not re-enable Shadow stack\\n\");\n\t\treturn 1;\n\t}\n\n\tif (ARCH_PRCTL(ARCH_SHSTK_ENABLE, ARCH_SHSTK_WRSS)) {\n\t\tprintf(\"[SKIP]\\tCould not enable WRSS\\n\");\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!get_ssp()) {\n\t\tprintf(\"[FAIL]\\tShadow stack disabled\\n\");\n\t\treturn 1;\n\t}\n\n\tif (test_shstk_pivot()) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tShadow stack pivot\\n\");\n\t\tgoto out;\n\t}\n\n\tif (test_shstk_faults()) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tShadow stack fault test\\n\");\n\t\tgoto out;\n\t}\n\n\tif (test_shstk_violation()) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tShadow stack violation test\\n\");\n\t\tgoto out;\n\t}\n\n\tif (test_gup()) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tShadow shadow stack gup\\n\");\n\t\tgoto out;\n\t}\n\n\tif (test_mprotect()) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tShadow shadow mprotect test\\n\");\n\t\tgoto out;\n\t}\n\n\tif (test_userfaultfd()) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tUserfaultfd test\\n\");\n\t\tgoto out;\n\t}\n\n\tif (test_guard_gap()) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tGuard gap test\\n\");\n\t\tgoto out;\n\t}\n\n\tif (test_ptrace()) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tptrace test\\n\");\n\t}\n\n\tif (test_32bit()) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\t32 bit test\\n\");\n\t\tgoto out;\n\t}\n\n\treturn ret;\n\nout:\n\t \n\tif (ARCH_PRCTL(ARCH_SHSTK_DISABLE, ARCH_SHSTK_SHSTK)) {\n\t\tret = 1;\n\t\tprintf(\"[FAIL]\\tDisabling shadow stack failed\\n\");\n\t}\n\n\treturn ret;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}