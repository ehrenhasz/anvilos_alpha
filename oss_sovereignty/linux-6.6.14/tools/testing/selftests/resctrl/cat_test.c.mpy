{
  "module_name": "cat_test.c",
  "hash_id": "ad0196ce44265751bf82a296a562b97b2d09cbe9141a2d4bf7a8987bb402d4f9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/resctrl/cat_test.c",
  "human_readable_source": "\n \n#include \"resctrl.h\"\n#include <unistd.h>\n\n#define RESULT_FILE_NAME1\t\"result_cat1\"\n#define RESULT_FILE_NAME2\t\"result_cat2\"\n#define NUM_OF_RUNS\t\t5\n#define MAX_DIFF_PERCENT\t4\n#define MAX_DIFF\t\t1000000\n\n \nstatic int cat_setup(struct resctrl_val_param *p)\n{\n\tchar schemata[64];\n\tint ret = 0;\n\n\t \n\tif (p->num_of_runs >= NUM_OF_RUNS)\n\t\treturn END_OF_TESTS;\n\n\tif (p->num_of_runs == 0) {\n\t\tsprintf(schemata, \"%lx\", p->mask);\n\t\tret = write_schemata(p->ctrlgrp, schemata, p->cpu_no,\n\t\t\t\t     p->resctrl_val);\n\t}\n\tp->num_of_runs++;\n\n\treturn ret;\n}\n\nstatic int check_results(struct resctrl_val_param *param, size_t span)\n{\n\tchar *token_array[8], temp[512];\n\tunsigned long sum_llc_perf_miss = 0;\n\tint runs = 0, no_of_bits = 0;\n\tFILE *fp;\n\n\tksft_print_msg(\"Checking for pass/fail\\n\");\n\tfp = fopen(param->filename, \"r\");\n\tif (!fp) {\n\t\tperror(\"# Cannot open file\");\n\n\t\treturn errno;\n\t}\n\n\twhile (fgets(temp, sizeof(temp), fp)) {\n\t\tchar *token = strtok(temp, \":\\t\");\n\t\tint fields = 0;\n\n\t\twhile (token) {\n\t\t\ttoken_array[fields++] = token;\n\t\t\ttoken = strtok(NULL, \":\\t\");\n\t\t}\n\t\t \n\t\tif (runs > 0)\n\t\t\tsum_llc_perf_miss += strtoul(token_array[3], NULL, 0);\n\t\truns++;\n\t}\n\n\tfclose(fp);\n\tno_of_bits = count_bits(param->mask);\n\n\treturn show_cache_info(sum_llc_perf_miss, no_of_bits, span / 64,\n\t\t\t       MAX_DIFF, MAX_DIFF_PERCENT, runs - 1,\n\t\t\t       get_vendor() == ARCH_INTEL, false);\n}\n\nvoid cat_test_cleanup(void)\n{\n\tremove(RESULT_FILE_NAME1);\n\tremove(RESULT_FILE_NAME2);\n}\n\nint cat_perf_miss_val(int cpu_no, int n, char *cache_type)\n{\n\tunsigned long l_mask, l_mask_1;\n\tint ret, pipefd[2], sibling_cpu_no;\n\tunsigned long cache_size = 0;\n\tunsigned long long_mask;\n\tchar cbm_mask[256];\n\tint count_of_bits;\n\tchar pipe_message;\n\tsize_t span;\n\n\t \n\tret = get_cbm_mask(cache_type, cbm_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tlong_mask = strtoul(cbm_mask, NULL, 16);\n\n\t \n\tret = get_cache_size(cpu_no, cache_type, &cache_size);\n\tif (ret)\n\t\treturn ret;\n\tksft_print_msg(\"Cache size :%lu\\n\", cache_size);\n\n\t \n\tcount_of_bits = count_bits(long_mask);\n\n\tif (!n)\n\t\tn = count_of_bits / 2;\n\n\tif (n > count_of_bits - 1) {\n\t\tksft_print_msg(\"Invalid input value for no_of_bits n!\\n\");\n\t\tksft_print_msg(\"Please enter value in range 1 to %d\\n\",\n\t\t\t       count_of_bits - 1);\n\t\treturn -1;\n\t}\n\n\t \n\tsibling_cpu_no = get_core_sibling(cpu_no);\n\tif (sibling_cpu_no < 0)\n\t\treturn -1;\n\n\tstruct resctrl_val_param param = {\n\t\t.resctrl_val\t= CAT_STR,\n\t\t.cpu_no\t\t= cpu_no,\n\t\t.setup\t\t= cat_setup,\n\t};\n\n\tl_mask = long_mask >> n;\n\tl_mask_1 = ~l_mask & long_mask;\n\n\t \n\tspan = cache_size * (count_of_bits - n) / count_of_bits;\n\tstrcpy(param.ctrlgrp, \"c2\");\n\tstrcpy(param.mongrp, \"m2\");\n\tstrcpy(param.filename, RESULT_FILE_NAME2);\n\tparam.mask = l_mask;\n\tparam.num_of_runs = 0;\n\n\tif (pipe(pipefd)) {\n\t\tperror(\"# Unable to create pipe\");\n\t\treturn errno;\n\t}\n\n\tfflush(stdout);\n\tbm_pid = fork();\n\n\t \n\tif (bm_pid == 0) {\n\t\tparam.mask = l_mask_1;\n\t\tstrcpy(param.ctrlgrp, \"c1\");\n\t\tstrcpy(param.mongrp, \"m1\");\n\t\tspan = cache_size * n / count_of_bits;\n\t\tstrcpy(param.filename, RESULT_FILE_NAME1);\n\t\tparam.num_of_runs = 0;\n\t\tparam.cpu_no = sibling_cpu_no;\n\t}\n\n\tremove(param.filename);\n\n\tret = cat_val(&param, span);\n\tif (ret == 0)\n\t\tret = check_results(&param, span);\n\n\tif (bm_pid == 0) {\n\t\t \n\t\tclose(pipefd[0]);\n\t\tpipe_message = 1;\n\t\tif (write(pipefd[1], &pipe_message, sizeof(pipe_message)) <\n\t\t    sizeof(pipe_message))\n\t\t\t \n\t\t\tperror(\"# failed signaling parent process\");\n\n\t\tclose(pipefd[1]);\n\t\twhile (1)\n\t\t\t;\n\t} else {\n\t\t \n\t\tclose(pipefd[1]);\n\t\tpipe_message = 0;\n\t\twhile (pipe_message != 1) {\n\t\t\tif (read(pipefd[0], &pipe_message,\n\t\t\t\t sizeof(pipe_message)) < sizeof(pipe_message)) {\n\t\t\t\tperror(\"# failed reading from child process\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tclose(pipefd[0]);\n\t\tkill(bm_pid, SIGKILL);\n\t}\n\n\tcat_test_cleanup();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}