{
  "module_name": "mbm_test.c",
  "hash_id": "9dd29b6dc7083ae2a2fce2298d8535dfb2eb3781100f09fd4061ecc7a82038d8",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/resctrl/mbm_test.c",
  "human_readable_source": "\n \n#include \"resctrl.h\"\n\n#define RESULT_FILE_NAME\t\"result_mbm\"\n#define MAX_DIFF_PERCENT\t8\n#define NUM_OF_RUNS\t\t5\n\nstatic int\nshow_bw_info(unsigned long *bw_imc, unsigned long *bw_resc, size_t span)\n{\n\tunsigned long avg_bw_imc = 0, avg_bw_resc = 0;\n\tunsigned long sum_bw_imc = 0, sum_bw_resc = 0;\n\tint runs, ret, avg_diff_per;\n\tfloat avg_diff = 0;\n\n\t \n\tfor (runs = 1; runs < NUM_OF_RUNS ; runs++) {\n\t\tsum_bw_imc += bw_imc[runs];\n\t\tsum_bw_resc += bw_resc[runs];\n\t}\n\n\tavg_bw_imc = sum_bw_imc / 4;\n\tavg_bw_resc = sum_bw_resc / 4;\n\tavg_diff = (float)labs(avg_bw_resc - avg_bw_imc) / avg_bw_imc;\n\tavg_diff_per = (int)(avg_diff * 100);\n\n\tret = avg_diff_per > MAX_DIFF_PERCENT;\n\tksft_print_msg(\"%s Check MBM diff within %d%%\\n\",\n\t\t       ret ? \"Fail:\" : \"Pass:\", MAX_DIFF_PERCENT);\n\tksft_print_msg(\"avg_diff_per: %d%%\\n\", avg_diff_per);\n\tksft_print_msg(\"Span (MB): %zu\\n\", span / MB);\n\tksft_print_msg(\"avg_bw_imc: %lu\\n\", avg_bw_imc);\n\tksft_print_msg(\"avg_bw_resc: %lu\\n\", avg_bw_resc);\n\n\treturn ret;\n}\n\nstatic int check_results(size_t span)\n{\n\tunsigned long bw_imc[NUM_OF_RUNS], bw_resc[NUM_OF_RUNS];\n\tchar temp[1024], *token_array[8];\n\tchar output[] = RESULT_FILE_NAME;\n\tint runs, ret;\n\tFILE *fp;\n\n\tksft_print_msg(\"Checking for pass/fail\\n\");\n\n\tfp = fopen(output, \"r\");\n\tif (!fp) {\n\t\tperror(output);\n\n\t\treturn errno;\n\t}\n\n\truns = 0;\n\twhile (fgets(temp, sizeof(temp), fp)) {\n\t\tchar *token = strtok(temp, \":\\t\");\n\t\tint i = 0;\n\n\t\twhile (token) {\n\t\t\ttoken_array[i++] = token;\n\t\t\ttoken = strtok(NULL, \":\\t\");\n\t\t}\n\n\t\tbw_resc[runs] = strtoul(token_array[5], NULL, 0);\n\t\tbw_imc[runs] = strtoul(token_array[3], NULL, 0);\n\t\truns++;\n\t}\n\n\tret = show_bw_info(bw_imc, bw_resc, span);\n\n\tfclose(fp);\n\n\treturn ret;\n}\n\nstatic int mbm_setup(struct resctrl_val_param *p)\n{\n\tint ret = 0;\n\n\t \n\tif (p->num_of_runs >= NUM_OF_RUNS)\n\t\treturn END_OF_TESTS;\n\n\t \n\tif (p->num_of_runs == 0)\n\t\tret = write_schemata(p->ctrlgrp, \"100\", p->cpu_no,\n\t\t\t\t     p->resctrl_val);\n\n\tp->num_of_runs++;\n\n\treturn ret;\n}\n\nvoid mbm_test_cleanup(void)\n{\n\tremove(RESULT_FILE_NAME);\n}\n\nint mbm_bw_change(int cpu_no, const char * const *benchmark_cmd)\n{\n\tstruct resctrl_val_param param = {\n\t\t.resctrl_val\t= MBM_STR,\n\t\t.ctrlgrp\t= \"c1\",\n\t\t.mongrp\t\t= \"m1\",\n\t\t.cpu_no\t\t= cpu_no,\n\t\t.filename\t= RESULT_FILE_NAME,\n\t\t.bw_report\t= \"reads\",\n\t\t.setup\t\t= mbm_setup\n\t};\n\tint ret;\n\n\tremove(RESULT_FILE_NAME);\n\n\tret = resctrl_val(benchmark_cmd, &param);\n\tif (ret)\n\t\tgoto out;\n\n\tret = check_results(DEFAULT_SPAN);\n\nout:\n\tmbm_test_cleanup();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}