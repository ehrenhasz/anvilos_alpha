{
  "module_name": "cache.c",
  "hash_id": "688946eb313ec9923c14f0e1d4208e9e5afcf1e844e1a717c65f6b1388d9de3f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/resctrl/cache.c",
  "human_readable_source": "\n\n#include <stdint.h>\n#include \"resctrl.h\"\n\nstruct read_format {\n\t__u64 nr;\t\t\t \n\tstruct {\n\t\t__u64 value;\t\t \n\t} values[2];\n};\n\nstatic struct perf_event_attr pea_llc_miss;\nstatic struct read_format rf_cqm;\nstatic int fd_lm;\nchar llc_occup_path[1024];\n\nstatic void initialize_perf_event_attr(void)\n{\n\tpea_llc_miss.type = PERF_TYPE_HARDWARE;\n\tpea_llc_miss.size = sizeof(struct perf_event_attr);\n\tpea_llc_miss.read_format = PERF_FORMAT_GROUP;\n\tpea_llc_miss.exclude_kernel = 1;\n\tpea_llc_miss.exclude_hv = 1;\n\tpea_llc_miss.exclude_idle = 1;\n\tpea_llc_miss.exclude_callchain_kernel = 1;\n\tpea_llc_miss.inherit = 1;\n\tpea_llc_miss.exclude_guest = 1;\n\tpea_llc_miss.disabled = 1;\n}\n\nstatic void ioctl_perf_event_ioc_reset_enable(void)\n{\n\tioctl(fd_lm, PERF_EVENT_IOC_RESET, 0);\n\tioctl(fd_lm, PERF_EVENT_IOC_ENABLE, 0);\n}\n\nstatic int perf_event_open_llc_miss(pid_t pid, int cpu_no)\n{\n\tfd_lm = perf_event_open(&pea_llc_miss, pid, cpu_no, -1,\n\t\t\t\tPERF_FLAG_FD_CLOEXEC);\n\tif (fd_lm == -1) {\n\t\tperror(\"Error opening leader\");\n\t\tctrlc_handler(0, NULL, NULL);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void initialize_llc_perf(void)\n{\n\tmemset(&pea_llc_miss, 0, sizeof(struct perf_event_attr));\n\tmemset(&rf_cqm, 0, sizeof(struct read_format));\n\n\t \n\tinitialize_perf_event_attr();\n\n\tpea_llc_miss.config = PERF_COUNT_HW_CACHE_MISSES;\n\n\trf_cqm.nr = 1;\n}\n\nstatic int reset_enable_llc_perf(pid_t pid, int cpu_no)\n{\n\tint ret = 0;\n\n\tret = perf_event_open_llc_miss(pid, cpu_no);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tioctl_perf_event_ioc_reset_enable();\n\n\treturn 0;\n}\n\n \nstatic int get_llc_perf(unsigned long *llc_perf_miss)\n{\n\t__u64 total_misses;\n\tint ret;\n\n\t \n\n\tioctl(fd_lm, PERF_EVENT_IOC_DISABLE, 0);\n\n\tret = read(fd_lm, &rf_cqm, sizeof(struct read_format));\n\tif (ret == -1) {\n\t\tperror(\"Could not get llc misses through perf\");\n\t\treturn -1;\n\t}\n\n\ttotal_misses = rf_cqm.values[0].value;\n\t*llc_perf_miss = total_misses;\n\n\treturn 0;\n}\n\n \nstatic int get_llc_occu_resctrl(unsigned long *llc_occupancy)\n{\n\tFILE *fp;\n\n\tfp = fopen(llc_occup_path, \"r\");\n\tif (!fp) {\n\t\tperror(\"Failed to open results file\");\n\n\t\treturn errno;\n\t}\n\tif (fscanf(fp, \"%lu\", llc_occupancy) <= 0) {\n\t\tperror(\"Could not get llc occupancy\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}\n\n \nstatic int print_results_cache(char *filename, int bm_pid,\n\t\t\t       unsigned long llc_value)\n{\n\tFILE *fp;\n\n\tif (strcmp(filename, \"stdio\") == 0 || strcmp(filename, \"stderr\") == 0) {\n\t\tprintf(\"Pid: %d \\t LLC_value: %lu\\n\", bm_pid,\n\t\t       llc_value);\n\t} else {\n\t\tfp = fopen(filename, \"a\");\n\t\tif (!fp) {\n\t\t\tperror(\"Cannot open results file\");\n\n\t\t\treturn errno;\n\t\t}\n\t\tfprintf(fp, \"Pid: %d \\t llc_value: %lu\\n\", bm_pid, llc_value);\n\t\tfclose(fp);\n\t}\n\n\treturn 0;\n}\n\nint measure_cache_vals(struct resctrl_val_param *param, int bm_pid)\n{\n\tunsigned long llc_perf_miss = 0, llc_occu_resc = 0, llc_value = 0;\n\tint ret;\n\n\t \n\tif (!strncmp(param->resctrl_val, CAT_STR, sizeof(CAT_STR))) {\n\t\tret = get_llc_perf(&llc_perf_miss);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tllc_value = llc_perf_miss;\n\t}\n\n\t \n\tif (!strncmp(param->resctrl_val, CMT_STR, sizeof(CMT_STR))) {\n\t\tret = get_llc_occu_resctrl(&llc_occu_resc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tllc_value = llc_occu_resc;\n\t}\n\tret = print_results_cache(param->filename, bm_pid, llc_value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint cat_val(struct resctrl_val_param *param, size_t span)\n{\n\tint memflush = 1, operation = 0, ret = 0;\n\tchar *resctrl_val = param->resctrl_val;\n\tpid_t bm_pid;\n\n\tif (strcmp(param->filename, \"\") == 0)\n\t\tsprintf(param->filename, \"stdio\");\n\n\tbm_pid = getpid();\n\n\t \n\tret = taskset_benchmark(bm_pid, param->cpu_no);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = write_bm_pid_to_resctrl(bm_pid, param->ctrlgrp, param->mongrp,\n\t\t\t\t      resctrl_val);\n\tif (ret)\n\t\treturn ret;\n\n\tinitialize_llc_perf();\n\n\t \n\twhile (1) {\n\t\tret = param->setup(param);\n\t\tif (ret == END_OF_TESTS) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = reset_enable_llc_perf(bm_pid, param->cpu_no);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (run_fill_buf(span, memflush, operation, true)) {\n\t\t\tfprintf(stderr, \"Error-running fill buffer\\n\");\n\t\t\tret = -1;\n\t\t\tgoto pe_close;\n\t\t}\n\n\t\tsleep(1);\n\t\tret = measure_cache_vals(param, bm_pid);\n\t\tif (ret)\n\t\t\tgoto pe_close;\n\t}\n\n\treturn ret;\n\npe_close:\n\tclose(fd_lm);\n\treturn ret;\n}\n\n \nint show_cache_info(unsigned long sum_llc_val, int no_of_bits,\n\t\t    size_t cache_span, unsigned long max_diff,\n\t\t    unsigned long max_diff_percent, unsigned long num_of_runs,\n\t\t    bool platform, bool cmt)\n{\n\tunsigned long avg_llc_val = 0;\n\tfloat diff_percent;\n\tlong avg_diff = 0;\n\tint ret;\n\n\tavg_llc_val = sum_llc_val / num_of_runs;\n\tavg_diff = (long)abs(cache_span - avg_llc_val);\n\tdiff_percent = ((float)cache_span - avg_llc_val) / cache_span * 100;\n\n\tret = platform && abs((int)diff_percent) > max_diff_percent &&\n\t      (cmt ? (abs(avg_diff) > max_diff) : true);\n\n\tksft_print_msg(\"%s Check cache miss rate within %d%%\\n\",\n\t\t       ret ? \"Fail:\" : \"Pass:\", max_diff_percent);\n\n\tksft_print_msg(\"Percent diff=%d\\n\", abs((int)diff_percent));\n\tksft_print_msg(\"Number of bits: %d\\n\", no_of_bits);\n\tksft_print_msg(\"Average LLC val: %lu\\n\", avg_llc_val);\n\tksft_print_msg(\"Cache span (%s): %zu\\n\", cmt ? \"bytes\" : \"lines\",\n\t\t       cache_span);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}