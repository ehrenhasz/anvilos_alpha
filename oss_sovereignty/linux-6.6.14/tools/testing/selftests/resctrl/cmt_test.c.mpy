{
  "module_name": "cmt_test.c",
  "hash_id": "b80634a3019f09c185670cdcc73ea6f922b430daaa65975e3124b07210cb2138",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/resctrl/cmt_test.c",
  "human_readable_source": "\n \n#include \"resctrl.h\"\n#include <unistd.h>\n\n#define RESULT_FILE_NAME\t\"result_cmt\"\n#define NUM_OF_RUNS\t\t5\n#define MAX_DIFF\t\t2000000\n#define MAX_DIFF_PERCENT\t15\n\nstatic int cmt_setup(struct resctrl_val_param *p)\n{\n\t \n\tif (p->num_of_runs >= NUM_OF_RUNS)\n\t\treturn END_OF_TESTS;\n\n\tp->num_of_runs++;\n\n\treturn 0;\n}\n\nstatic int check_results(struct resctrl_val_param *param, size_t span, int no_of_bits)\n{\n\tchar *token_array[8], temp[512];\n\tunsigned long sum_llc_occu_resc = 0;\n\tint runs = 0;\n\tFILE *fp;\n\n\tksft_print_msg(\"Checking for pass/fail\\n\");\n\tfp = fopen(param->filename, \"r\");\n\tif (!fp) {\n\t\tperror(\"# Error in opening file\\n\");\n\n\t\treturn errno;\n\t}\n\n\twhile (fgets(temp, sizeof(temp), fp)) {\n\t\tchar *token = strtok(temp, \":\\t\");\n\t\tint fields = 0;\n\n\t\twhile (token) {\n\t\t\ttoken_array[fields++] = token;\n\t\t\ttoken = strtok(NULL, \":\\t\");\n\t\t}\n\n\t\t \n\t\tif (runs > 0)\n\t\t\tsum_llc_occu_resc += strtoul(token_array[3], NULL, 0);\n\t\truns++;\n\t}\n\tfclose(fp);\n\n\treturn show_cache_info(sum_llc_occu_resc, no_of_bits, span,\n\t\t\t       MAX_DIFF, MAX_DIFF_PERCENT, runs - 1,\n\t\t\t       true, true);\n}\n\nvoid cmt_test_cleanup(void)\n{\n\tremove(RESULT_FILE_NAME);\n}\n\nint cmt_resctrl_val(int cpu_no, int n, const char * const *benchmark_cmd)\n{\n\tconst char * const *cmd = benchmark_cmd;\n\tconst char *new_cmd[BENCHMARK_ARGS];\n\tunsigned long cache_size = 0;\n\tunsigned long long_mask;\n\tchar *span_str = NULL;\n\tchar cbm_mask[256];\n\tint count_of_bits;\n\tsize_t span;\n\tint ret, i;\n\n\tret = get_cbm_mask(\"L3\", cbm_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tlong_mask = strtoul(cbm_mask, NULL, 16);\n\n\tret = get_cache_size(cpu_no, \"L3\", &cache_size);\n\tif (ret)\n\t\treturn ret;\n\tksft_print_msg(\"Cache size :%lu\\n\", cache_size);\n\n\tcount_of_bits = count_bits(long_mask);\n\n\tif (n < 1 || n > count_of_bits) {\n\t\tksft_print_msg(\"Invalid input value for numbr_of_bits n!\\n\");\n\t\tksft_print_msg(\"Please enter value in range 1 to %d\\n\", count_of_bits);\n\t\treturn -1;\n\t}\n\n\tstruct resctrl_val_param param = {\n\t\t.resctrl_val\t= CMT_STR,\n\t\t.ctrlgrp\t= \"c1\",\n\t\t.mongrp\t\t= \"m1\",\n\t\t.cpu_no\t\t= cpu_no,\n\t\t.filename\t= RESULT_FILE_NAME,\n\t\t.mask\t\t= ~(long_mask << n) & long_mask,\n\t\t.num_of_runs\t= 0,\n\t\t.setup\t\t= cmt_setup,\n\t};\n\n\tspan = cache_size * n / count_of_bits;\n\n\tif (strcmp(cmd[0], \"fill_buf\") == 0) {\n\t\t \n\t\tfor (i = 0; benchmark_cmd[i]; i++)\n\t\t\tnew_cmd[i] = benchmark_cmd[i];\n\t\tnew_cmd[i] = NULL;\n\n\t\tret = asprintf(&span_str, \"%zu\", span);\n\t\tif (ret < 0)\n\t\t\treturn -1;\n\t\tnew_cmd[1] = span_str;\n\t\tcmd = new_cmd;\n\t}\n\n\tremove(RESULT_FILE_NAME);\n\n\tret = resctrl_val(cmd, &param);\n\tif (ret)\n\t\tgoto out;\n\n\tret = check_results(&param, span, n);\n\nout:\n\tcmt_test_cleanup();\n\tfree(span_str);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}