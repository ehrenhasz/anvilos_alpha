{
  "module_name": "resctrl_val.c",
  "hash_id": "446686083f92730358f20adda76c05f63c8b21f58f3bca93221da1dadfc59ca9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/resctrl/resctrl_val.c",
  "human_readable_source": "\n \n#include \"resctrl.h\"\n\n#define UNCORE_IMC\t\t\"uncore_imc\"\n#define READ_FILE_NAME\t\t\"events/cas_count_read\"\n#define WRITE_FILE_NAME\t\t\"events/cas_count_write\"\n#define DYN_PMU_PATH\t\t\"/sys/bus/event_source/devices\"\n#define SCALE\t\t\t0.00006103515625\n#define MAX_IMCS\t\t20\n#define MAX_TOKENS\t\t5\n#define READ\t\t\t0\n#define WRITE\t\t\t1\n#define CON_MON_MBM_LOCAL_BYTES_PATH\t\t\t\t\\\n\t\"%s/%s/mon_groups/%s/mon_data/mon_L3_%02d/mbm_local_bytes\"\n\n#define CON_MBM_LOCAL_BYTES_PATH\t\t\\\n\t\"%s/%s/mon_data/mon_L3_%02d/mbm_local_bytes\"\n\n#define MON_MBM_LOCAL_BYTES_PATH\t\t\\\n\t\"%s/mon_groups/%s/mon_data/mon_L3_%02d/mbm_local_bytes\"\n\n#define MBM_LOCAL_BYTES_PATH\t\t\t\\\n\t\"%s/mon_data/mon_L3_%02d/mbm_local_bytes\"\n\n#define CON_MON_LCC_OCCUP_PATH\t\t\\\n\t\"%s/%s/mon_groups/%s/mon_data/mon_L3_%02d/llc_occupancy\"\n\n#define CON_LCC_OCCUP_PATH\t\t\\\n\t\"%s/%s/mon_data/mon_L3_%02d/llc_occupancy\"\n\n#define MON_LCC_OCCUP_PATH\t\t\\\n\t\"%s/mon_groups/%s/mon_data/mon_L3_%02d/llc_occupancy\"\n\n#define LCC_OCCUP_PATH\t\t\t\\\n\t\"%s/mon_data/mon_L3_%02d/llc_occupancy\"\n\nstruct membw_read_format {\n\t__u64 value;          \n\t__u64 time_enabled;   \n\t__u64 time_running;   \n\t__u64 id;             \n};\n\nstruct imc_counter_config {\n\t__u32 type;\n\t__u64 event;\n\t__u64 umask;\n\tstruct perf_event_attr pe;\n\tstruct membw_read_format return_value;\n\tint fd;\n};\n\nstatic char mbm_total_path[1024];\nstatic int imcs;\nstatic struct imc_counter_config imc_counters_config[MAX_IMCS][2];\n\nvoid membw_initialize_perf_event_attr(int i, int j)\n{\n\tmemset(&imc_counters_config[i][j].pe, 0,\n\t       sizeof(struct perf_event_attr));\n\timc_counters_config[i][j].pe.type = imc_counters_config[i][j].type;\n\timc_counters_config[i][j].pe.size = sizeof(struct perf_event_attr);\n\timc_counters_config[i][j].pe.disabled = 1;\n\timc_counters_config[i][j].pe.inherit = 1;\n\timc_counters_config[i][j].pe.exclude_guest = 0;\n\timc_counters_config[i][j].pe.config =\n\t\timc_counters_config[i][j].umask << 8 |\n\t\timc_counters_config[i][j].event;\n\timc_counters_config[i][j].pe.sample_type = PERF_SAMPLE_IDENTIFIER;\n\timc_counters_config[i][j].pe.read_format =\n\t\tPERF_FORMAT_TOTAL_TIME_ENABLED | PERF_FORMAT_TOTAL_TIME_RUNNING;\n}\n\nvoid membw_ioctl_perf_event_ioc_reset_enable(int i, int j)\n{\n\tioctl(imc_counters_config[i][j].fd, PERF_EVENT_IOC_RESET, 0);\n\tioctl(imc_counters_config[i][j].fd, PERF_EVENT_IOC_ENABLE, 0);\n}\n\nvoid membw_ioctl_perf_event_ioc_disable(int i, int j)\n{\n\tioctl(imc_counters_config[i][j].fd, PERF_EVENT_IOC_DISABLE, 0);\n}\n\n \nvoid get_event_and_umask(char *cas_count_cfg, int count, bool op)\n{\n\tchar *token[MAX_TOKENS];\n\tint i = 0;\n\n\tstrcat(cas_count_cfg, \",\");\n\ttoken[0] = strtok(cas_count_cfg, \"=,\");\n\n\tfor (i = 1; i < MAX_TOKENS; i++)\n\t\ttoken[i] = strtok(NULL, \"=,\");\n\n\tfor (i = 0; i < MAX_TOKENS; i++) {\n\t\tif (!token[i])\n\t\t\tbreak;\n\t\tif (strcmp(token[i], \"event\") == 0) {\n\t\t\tif (op == READ)\n\t\t\t\timc_counters_config[count][READ].event =\n\t\t\t\tstrtol(token[i + 1], NULL, 16);\n\t\t\telse\n\t\t\t\timc_counters_config[count][WRITE].event =\n\t\t\t\tstrtol(token[i + 1], NULL, 16);\n\t\t}\n\t\tif (strcmp(token[i], \"umask\") == 0) {\n\t\t\tif (op == READ)\n\t\t\t\timc_counters_config[count][READ].umask =\n\t\t\t\tstrtol(token[i + 1], NULL, 16);\n\t\t\telse\n\t\t\t\timc_counters_config[count][WRITE].umask =\n\t\t\t\tstrtol(token[i + 1], NULL, 16);\n\t\t}\n\t}\n}\n\nstatic int open_perf_event(int i, int cpu_no, int j)\n{\n\timc_counters_config[i][j].fd =\n\t\tperf_event_open(&imc_counters_config[i][j].pe, -1, cpu_no, -1,\n\t\t\t\tPERF_FLAG_FD_CLOEXEC);\n\n\tif (imc_counters_config[i][j].fd == -1) {\n\t\tfprintf(stderr, \"Error opening leader %llx\\n\",\n\t\t\timc_counters_config[i][j].pe.config);\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int read_from_imc_dir(char *imc_dir, int count)\n{\n\tchar cas_count_cfg[1024], imc_counter_cfg[1024], imc_counter_type[1024];\n\tFILE *fp;\n\n\t \n\tsprintf(imc_counter_type, \"%s%s\", imc_dir, \"type\");\n\tfp = fopen(imc_counter_type, \"r\");\n\tif (!fp) {\n\t\tperror(\"Failed to open imc counter type file\");\n\n\t\treturn -1;\n\t}\n\tif (fscanf(fp, \"%u\", &imc_counters_config[count][READ].type) <= 0) {\n\t\tperror(\"Could not get imc type\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\timc_counters_config[count][WRITE].type =\n\t\t\t\timc_counters_config[count][READ].type;\n\n\t \n\tsprintf(imc_counter_cfg, \"%s%s\", imc_dir, READ_FILE_NAME);\n\tfp = fopen(imc_counter_cfg, \"r\");\n\tif (!fp) {\n\t\tperror(\"Failed to open imc config file\");\n\n\t\treturn -1;\n\t}\n\tif (fscanf(fp, \"%s\", cas_count_cfg) <= 0) {\n\t\tperror(\"Could not get imc cas count read\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\tget_event_and_umask(cas_count_cfg, count, READ);\n\n\t \n\tsprintf(imc_counter_cfg, \"%s%s\", imc_dir, WRITE_FILE_NAME);\n\tfp = fopen(imc_counter_cfg, \"r\");\n\tif (!fp) {\n\t\tperror(\"Failed to open imc config file\");\n\n\t\treturn -1;\n\t}\n\tif  (fscanf(fp, \"%s\", cas_count_cfg) <= 0) {\n\t\tperror(\"Could not get imc cas count write\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\tget_event_and_umask(cas_count_cfg, count, WRITE);\n\n\treturn 0;\n}\n\n \nstatic int num_of_imcs(void)\n{\n\tchar imc_dir[512], *temp;\n\tunsigned int count = 0;\n\tstruct dirent *ep;\n\tint ret;\n\tDIR *dp;\n\n\tdp = opendir(DYN_PMU_PATH);\n\tif (dp) {\n\t\twhile ((ep = readdir(dp))) {\n\t\t\ttemp = strstr(ep->d_name, UNCORE_IMC);\n\t\t\tif (!temp)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttemp = temp + sizeof(UNCORE_IMC);\n\n\t\t\t \n\t\t\tif (temp[0] >= '0' && temp[0] <= '9') {\n\t\t\t\tsprintf(imc_dir, \"%s/%s/\", DYN_PMU_PATH,\n\t\t\t\t\tep->d_name);\n\t\t\t\tret = read_from_imc_dir(imc_dir, count);\n\t\t\t\tif (ret) {\n\t\t\t\t\tclosedir(dp);\n\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tclosedir(dp);\n\t\tif (count == 0) {\n\t\t\tperror(\"Unable find iMC counters!\\n\");\n\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tperror(\"Unable to open PMU directory!\\n\");\n\n\t\treturn -1;\n\t}\n\n\treturn count;\n}\n\nstatic int initialize_mem_bw_imc(void)\n{\n\tint imc, j;\n\n\timcs = num_of_imcs();\n\tif (imcs <= 0)\n\t\treturn imcs;\n\n\t \n\tfor (imc = 0; imc < imcs; imc++) {\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tmembw_initialize_perf_event_attr(imc, j);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int get_mem_bw_imc(int cpu_no, char *bw_report, float *bw_imc)\n{\n\tfloat reads, writes, of_mul_read, of_mul_write;\n\tint imc, j, ret;\n\n\t \n\treads = 0, writes = 0, of_mul_read = 1, of_mul_write = 1;\n\tfor (imc = 0; imc < imcs; imc++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tret = open_perf_event(imc, cpu_no, j);\n\t\t\tif (ret)\n\t\t\t\treturn -1;\n\t\t}\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tmembw_ioctl_perf_event_ioc_reset_enable(imc, j);\n\t}\n\n\tsleep(1);\n\n\t \n\tfor (imc = 0; imc < imcs; imc++) {\n\t\tfor (j = 0; j < 2; j++)\n\t\t\tmembw_ioctl_perf_event_ioc_disable(imc, j);\n\t}\n\n\t \n\tfor (imc = 0; imc < imcs; imc++) {\n\t\tstruct imc_counter_config *r =\n\t\t\t&imc_counters_config[imc][READ];\n\t\tstruct imc_counter_config *w =\n\t\t\t&imc_counters_config[imc][WRITE];\n\n\t\tif (read(r->fd, &r->return_value,\n\t\t\t sizeof(struct membw_read_format)) == -1) {\n\t\t\tperror(\"Couldn't get read b/w through iMC\");\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (read(w->fd, &w->return_value,\n\t\t\t sizeof(struct membw_read_format)) == -1) {\n\t\t\tperror(\"Couldn't get write bw through iMC\");\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t__u64 r_time_enabled = r->return_value.time_enabled;\n\t\t__u64 r_time_running = r->return_value.time_running;\n\n\t\tif (r_time_enabled != r_time_running)\n\t\t\tof_mul_read = (float)r_time_enabled /\n\t\t\t\t\t(float)r_time_running;\n\n\t\t__u64 w_time_enabled = w->return_value.time_enabled;\n\t\t__u64 w_time_running = w->return_value.time_running;\n\n\t\tif (w_time_enabled != w_time_running)\n\t\t\tof_mul_write = (float)w_time_enabled /\n\t\t\t\t\t(float)w_time_running;\n\t\treads += r->return_value.value * of_mul_read * SCALE;\n\t\twrites += w->return_value.value * of_mul_write * SCALE;\n\t}\n\n\tfor (imc = 0; imc < imcs; imc++) {\n\t\tclose(imc_counters_config[imc][READ].fd);\n\t\tclose(imc_counters_config[imc][WRITE].fd);\n\t}\n\n\tif (strcmp(bw_report, \"reads\") == 0) {\n\t\t*bw_imc = reads;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(bw_report, \"writes\") == 0) {\n\t\t*bw_imc = writes;\n\t\treturn 0;\n\t}\n\n\t*bw_imc = reads + writes;\n\treturn 0;\n}\n\nvoid set_mbm_path(const char *ctrlgrp, const char *mongrp, int resource_id)\n{\n\tif (ctrlgrp && mongrp)\n\t\tsprintf(mbm_total_path, CON_MON_MBM_LOCAL_BYTES_PATH,\n\t\t\tRESCTRL_PATH, ctrlgrp, mongrp, resource_id);\n\telse if (!ctrlgrp && mongrp)\n\t\tsprintf(mbm_total_path, MON_MBM_LOCAL_BYTES_PATH, RESCTRL_PATH,\n\t\t\tmongrp, resource_id);\n\telse if (ctrlgrp && !mongrp)\n\t\tsprintf(mbm_total_path, CON_MBM_LOCAL_BYTES_PATH, RESCTRL_PATH,\n\t\t\tctrlgrp, resource_id);\n\telse if (!ctrlgrp && !mongrp)\n\t\tsprintf(mbm_total_path, MBM_LOCAL_BYTES_PATH, RESCTRL_PATH,\n\t\t\tresource_id);\n}\n\n \nstatic void initialize_mem_bw_resctrl(const char *ctrlgrp, const char *mongrp,\n\t\t\t\t      int cpu_no, char *resctrl_val)\n{\n\tint resource_id;\n\n\tif (get_resource_id(cpu_no, &resource_id) < 0) {\n\t\tperror(\"Could not get resource_id\");\n\t\treturn;\n\t}\n\n\tif (!strncmp(resctrl_val, MBM_STR, sizeof(MBM_STR)))\n\t\tset_mbm_path(ctrlgrp, mongrp, resource_id);\n\n\tif (!strncmp(resctrl_val, MBA_STR, sizeof(MBA_STR))) {\n\t\tif (ctrlgrp)\n\t\t\tsprintf(mbm_total_path, CON_MBM_LOCAL_BYTES_PATH,\n\t\t\t\tRESCTRL_PATH, ctrlgrp, resource_id);\n\t\telse\n\t\t\tsprintf(mbm_total_path, MBM_LOCAL_BYTES_PATH,\n\t\t\t\tRESCTRL_PATH, resource_id);\n\t}\n}\n\n \nstatic int get_mem_bw_resctrl(unsigned long *mbm_total)\n{\n\tFILE *fp;\n\n\tfp = fopen(mbm_total_path, \"r\");\n\tif (!fp) {\n\t\tperror(\"Failed to open total bw file\");\n\n\t\treturn -1;\n\t}\n\tif (fscanf(fp, \"%lu\", mbm_total) <= 0) {\n\t\tperror(\"Could not get mbm local bytes\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}\n\npid_t bm_pid, ppid;\n\nvoid ctrlc_handler(int signum, siginfo_t *info, void *ptr)\n{\n\t \n\tif (bm_pid)\n\t\tkill(bm_pid, SIGKILL);\n\tumount_resctrlfs();\n\ttests_cleanup();\n\tksft_print_msg(\"Ending\\n\\n\");\n\n\texit(EXIT_SUCCESS);\n}\n\n \nint signal_handler_register(void)\n{\n\tstruct sigaction sigact = {};\n\tint ret = 0;\n\n\tbm_pid = 0;\n\n\tsigact.sa_sigaction = ctrlc_handler;\n\tsigemptyset(&sigact.sa_mask);\n\tsigact.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGINT, &sigact, NULL) ||\n\t    sigaction(SIGTERM, &sigact, NULL) ||\n\t    sigaction(SIGHUP, &sigact, NULL)) {\n\t\tperror(\"# sigaction\");\n\t\tret = -1;\n\t}\n\treturn ret;\n}\n\n \nvoid signal_handler_unregister(void)\n{\n\tstruct sigaction sigact = {};\n\n\tsigact.sa_handler = SIG_DFL;\n\tsigemptyset(&sigact.sa_mask);\n\tif (sigaction(SIGINT, &sigact, NULL) ||\n\t    sigaction(SIGTERM, &sigact, NULL) ||\n\t    sigaction(SIGHUP, &sigact, NULL)) {\n\t\tperror(\"# sigaction\");\n\t}\n}\n\n \nstatic int print_results_bw(char *filename,  int bm_pid, float bw_imc,\n\t\t\t    unsigned long bw_resc)\n{\n\tunsigned long diff = fabs(bw_imc - bw_resc);\n\tFILE *fp;\n\n\tif (strcmp(filename, \"stdio\") == 0 || strcmp(filename, \"stderr\") == 0) {\n\t\tprintf(\"Pid: %d \\t Mem_BW_iMC: %f \\t \", bm_pid, bw_imc);\n\t\tprintf(\"Mem_BW_resc: %lu \\t Difference: %lu\\n\", bw_resc, diff);\n\t} else {\n\t\tfp = fopen(filename, \"a\");\n\t\tif (!fp) {\n\t\t\tperror(\"Cannot open results file\");\n\n\t\t\treturn errno;\n\t\t}\n\t\tif (fprintf(fp, \"Pid: %d \\t Mem_BW_iMC: %f \\t Mem_BW_resc: %lu \\t Difference: %lu\\n\",\n\t\t\t    bm_pid, bw_imc, bw_resc, diff) <= 0) {\n\t\t\tfclose(fp);\n\t\t\tperror(\"Could not log results.\");\n\n\t\t\treturn errno;\n\t\t}\n\t\tfclose(fp);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_cmt_path(const char *ctrlgrp, const char *mongrp, char sock_num)\n{\n\tif (strlen(ctrlgrp) && strlen(mongrp))\n\t\tsprintf(llc_occup_path,\tCON_MON_LCC_OCCUP_PATH,\tRESCTRL_PATH,\n\t\t\tctrlgrp, mongrp, sock_num);\n\telse if (!strlen(ctrlgrp) && strlen(mongrp))\n\t\tsprintf(llc_occup_path,\tMON_LCC_OCCUP_PATH, RESCTRL_PATH,\n\t\t\tmongrp, sock_num);\n\telse if (strlen(ctrlgrp) && !strlen(mongrp))\n\t\tsprintf(llc_occup_path,\tCON_LCC_OCCUP_PATH, RESCTRL_PATH,\n\t\t\tctrlgrp, sock_num);\n\telse if (!strlen(ctrlgrp) && !strlen(mongrp))\n\t\tsprintf(llc_occup_path, LCC_OCCUP_PATH,\tRESCTRL_PATH, sock_num);\n}\n\n \nstatic void initialize_llc_occu_resctrl(const char *ctrlgrp, const char *mongrp,\n\t\t\t\t\tint cpu_no, char *resctrl_val)\n{\n\tint resource_id;\n\n\tif (get_resource_id(cpu_no, &resource_id) < 0) {\n\t\tperror(\"# Unable to resource_id\");\n\t\treturn;\n\t}\n\n\tif (!strncmp(resctrl_val, CMT_STR, sizeof(CMT_STR)))\n\t\tset_cmt_path(ctrlgrp, mongrp, resource_id);\n}\n\nstatic int\nmeasure_vals(struct resctrl_val_param *param, unsigned long *bw_resc_start)\n{\n\tunsigned long bw_resc, bw_resc_end;\n\tfloat bw_imc;\n\tint ret;\n\n\t \n\tret = get_mem_bw_imc(param->cpu_no, param->bw_report, &bw_imc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = get_mem_bw_resctrl(&bw_resc_end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbw_resc = (bw_resc_end - *bw_resc_start) / MB;\n\tret = print_results_bw(param->filename, bm_pid, bw_imc, bw_resc);\n\tif (ret)\n\t\treturn ret;\n\n\t*bw_resc_start = bw_resc_end;\n\n\treturn 0;\n}\n\n \nint resctrl_val(const char * const *benchmark_cmd, struct resctrl_val_param *param)\n{\n\tchar *resctrl_val = param->resctrl_val;\n\tunsigned long bw_resc_start = 0;\n\tstruct sigaction sigact;\n\tint ret = 0, pipefd[2];\n\tchar pipe_message = 0;\n\tunion sigval value;\n\n\tif (strcmp(param->filename, \"\") == 0)\n\t\tsprintf(param->filename, \"stdio\");\n\n\tif (!strncmp(resctrl_val, MBA_STR, sizeof(MBA_STR)) ||\n\t    !strncmp(resctrl_val, MBM_STR, sizeof(MBM_STR))) {\n\t\tret = validate_bw_report_request(param->bw_report);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tppid = getpid();\n\n\tif (pipe(pipefd)) {\n\t\tperror(\"# Unable to create pipe\");\n\n\t\treturn -1;\n\t}\n\n\t \n\tfflush(stdout);\n\tbm_pid = fork();\n\tif (bm_pid == -1) {\n\t\tperror(\"# Unable to fork\");\n\n\t\treturn -1;\n\t}\n\n\tif (bm_pid == 0) {\n\t\t \n\t\tsigfillset(&sigact.sa_mask);\n\t\tsigdelset(&sigact.sa_mask, SIGUSR1);\n\n\t\tsigact.sa_sigaction = run_benchmark;\n\t\tsigact.sa_flags = SA_SIGINFO;\n\n\t\t \n\t\tif (sigaction(SIGUSR1, &sigact, NULL))\n\t\t\tPARENT_EXIT(\"Can't register child for signal\");\n\n\t\t \n\t\tclose(pipefd[0]);\n\t\tpipe_message = 1;\n\t\tif (write(pipefd[1], &pipe_message, sizeof(pipe_message)) <\n\t\t    sizeof(pipe_message)) {\n\t\t\tperror(\"# failed signaling parent process\");\n\t\t\tclose(pipefd[1]);\n\t\t\treturn -1;\n\t\t}\n\t\tclose(pipefd[1]);\n\n\t\t \n\t\tsigsuspend(&sigact.sa_mask);\n\n\t\tPARENT_EXIT(\"Child is done\");\n\t}\n\n\tksft_print_msg(\"Benchmark PID: %d\\n\", bm_pid);\n\n\t \n\tvalue.sival_ptr = (void *)benchmark_cmd;\n\n\t \n\tret = taskset_benchmark(bm_pid, param->cpu_no);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = write_bm_pid_to_resctrl(bm_pid, param->ctrlgrp, param->mongrp,\n\t\t\t\t      resctrl_val);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!strncmp(resctrl_val, MBM_STR, sizeof(MBM_STR)) ||\n\t    !strncmp(resctrl_val, MBA_STR, sizeof(MBA_STR))) {\n\t\tret = initialize_mem_bw_imc();\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tinitialize_mem_bw_resctrl(param->ctrlgrp, param->mongrp,\n\t\t\t\t\t  param->cpu_no, resctrl_val);\n\t} else if (!strncmp(resctrl_val, CMT_STR, sizeof(CMT_STR)))\n\t\tinitialize_llc_occu_resctrl(param->ctrlgrp, param->mongrp,\n\t\t\t\t\t    param->cpu_no, resctrl_val);\n\n\t \n\tclose(pipefd[1]);\n\twhile (pipe_message != 1) {\n\t\tif (read(pipefd[0], &pipe_message, sizeof(pipe_message)) <\n\t\t    sizeof(pipe_message)) {\n\t\t\tperror(\"# failed reading message from child process\");\n\t\t\tclose(pipefd[0]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tclose(pipefd[0]);\n\n\t \n\tif (sigqueue(bm_pid, SIGUSR1, value) == -1) {\n\t\tperror(\"# sigqueue SIGUSR1 to child\");\n\t\tret = errno;\n\t\tgoto out;\n\t}\n\n\t \n\tsleep(1);\n\n\t \n\twhile (1) {\n\t\tret = param->setup(param);\n\t\tif (ret == END_OF_TESTS) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (!strncmp(resctrl_val, MBM_STR, sizeof(MBM_STR)) ||\n\t\t    !strncmp(resctrl_val, MBA_STR, sizeof(MBA_STR))) {\n\t\t\tret = measure_vals(param, &bw_resc_start);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (!strncmp(resctrl_val, CMT_STR, sizeof(CMT_STR))) {\n\t\t\tsleep(1);\n\t\t\tret = measure_cache_vals(param, bm_pid);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkill(bm_pid, SIGKILL);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}