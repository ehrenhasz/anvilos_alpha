{
  "module_name": "resctrlfs.c",
  "hash_id": "a4ce982e65db55a3fbf4df2dba7d432ae4529c3d5abece651f144eeb3a3b8d73",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/resctrl/resctrlfs.c",
  "human_readable_source": "\n \n#include <limits.h>\n\n#include \"resctrl.h\"\n\nstatic int find_resctrl_mount(char *buffer)\n{\n\tFILE *mounts;\n\tchar line[256], *fs, *mntpoint;\n\n\tmounts = fopen(\"/proc/mounts\", \"r\");\n\tif (!mounts) {\n\t\tperror(\"/proc/mounts\");\n\t\treturn -ENXIO;\n\t}\n\twhile (!feof(mounts)) {\n\t\tif (!fgets(line, 256, mounts))\n\t\t\tbreak;\n\t\tfs = strtok(line, \" \\t\");\n\t\tif (!fs)\n\t\t\tcontinue;\n\t\tmntpoint = strtok(NULL, \" \\t\");\n\t\tif (!mntpoint)\n\t\t\tcontinue;\n\t\tfs = strtok(NULL, \" \\t\");\n\t\tif (!fs)\n\t\t\tcontinue;\n\t\tif (strcmp(fs, \"resctrl\"))\n\t\t\tcontinue;\n\n\t\tfclose(mounts);\n\t\tif (buffer)\n\t\t\tstrncpy(buffer, mntpoint, 256);\n\n\t\treturn 0;\n\t}\n\n\tfclose(mounts);\n\n\treturn -ENOENT;\n}\n\n \nint mount_resctrlfs(void)\n{\n\tint ret;\n\n\tret = find_resctrl_mount(NULL);\n\tif (ret != -ENOENT)\n\t\treturn -1;\n\n\tksft_print_msg(\"Mounting resctrl to \\\"%s\\\"\\n\", RESCTRL_PATH);\n\tret = mount(\"resctrl\", RESCTRL_PATH, \"resctrl\", 0, NULL);\n\tif (ret)\n\t\tperror(\"# mount\");\n\n\treturn ret;\n}\n\nint umount_resctrlfs(void)\n{\n\tchar mountpoint[256];\n\tint ret;\n\n\tret = find_resctrl_mount(mountpoint);\n\tif (ret == -ENOENT)\n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\n\n\tif (umount(mountpoint)) {\n\t\tperror(\"# Unable to umount resctrl\");\n\n\t\treturn errno;\n\t}\n\n\treturn 0;\n}\n\n \nint get_resource_id(int cpu_no, int *resource_id)\n{\n\tchar phys_pkg_path[1024];\n\tFILE *fp;\n\n\tif (get_vendor() == ARCH_AMD)\n\t\tsprintf(phys_pkg_path, \"%s%d/cache/index3/id\",\n\t\t\tPHYS_ID_PATH, cpu_no);\n\telse\n\t\tsprintf(phys_pkg_path, \"%s%d/topology/physical_package_id\",\n\t\t\tPHYS_ID_PATH, cpu_no);\n\n\tfp = fopen(phys_pkg_path, \"r\");\n\tif (!fp) {\n\t\tperror(\"Failed to open physical_package_id\");\n\n\t\treturn -1;\n\t}\n\tif (fscanf(fp, \"%d\", resource_id) <= 0) {\n\t\tperror(\"Could not get socket number or l3 id\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}\n\n \nint get_cache_size(int cpu_no, char *cache_type, unsigned long *cache_size)\n{\n\tchar cache_path[1024], cache_str[64];\n\tint length, i, cache_num;\n\tFILE *fp;\n\n\tif (!strcmp(cache_type, \"L3\")) {\n\t\tcache_num = 3;\n\t} else if (!strcmp(cache_type, \"L2\")) {\n\t\tcache_num = 2;\n\t} else {\n\t\tperror(\"Invalid cache level\");\n\t\treturn -1;\n\t}\n\n\tsprintf(cache_path, \"/sys/bus/cpu/devices/cpu%d/cache/index%d/size\",\n\t\tcpu_no, cache_num);\n\tfp = fopen(cache_path, \"r\");\n\tif (!fp) {\n\t\tperror(\"Failed to open cache size\");\n\n\t\treturn -1;\n\t}\n\tif (fscanf(fp, \"%s\", cache_str) <= 0) {\n\t\tperror(\"Could not get cache_size\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\tlength = (int)strlen(cache_str);\n\n\t*cache_size = 0;\n\n\tfor (i = 0; i < length; i++) {\n\t\tif ((cache_str[i] >= '0') && (cache_str[i] <= '9'))\n\n\t\t\t*cache_size = *cache_size * 10 + (cache_str[i] - '0');\n\n\t\telse if (cache_str[i] == 'K')\n\n\t\t\t*cache_size = *cache_size * 1024;\n\n\t\telse if (cache_str[i] == 'M')\n\n\t\t\t*cache_size = *cache_size * 1024 * 1024;\n\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define CORE_SIBLINGS_PATH\t\"/sys/bus/cpu/devices/cpu\"\n\n \nint get_cbm_mask(char *cache_type, char *cbm_mask)\n{\n\tchar cbm_mask_path[1024];\n\tFILE *fp;\n\n\tif (!cbm_mask)\n\t\treturn -1;\n\n\tsprintf(cbm_mask_path, \"%s/%s/cbm_mask\", INFO_PATH, cache_type);\n\n\tfp = fopen(cbm_mask_path, \"r\");\n\tif (!fp) {\n\t\tperror(\"Failed to open cache level\");\n\n\t\treturn -1;\n\t}\n\tif (fscanf(fp, \"%s\", cbm_mask) <= 0) {\n\t\tperror(\"Could not get max cbm_mask\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}\n\n \nint get_core_sibling(int cpu_no)\n{\n\tchar core_siblings_path[1024], cpu_list_str[64];\n\tint sibling_cpu_no = -1;\n\tFILE *fp;\n\n\tsprintf(core_siblings_path, \"%s%d/topology/core_siblings_list\",\n\t\tCORE_SIBLINGS_PATH, cpu_no);\n\n\tfp = fopen(core_siblings_path, \"r\");\n\tif (!fp) {\n\t\tperror(\"Failed to open core siblings path\");\n\n\t\treturn -1;\n\t}\n\tif (fscanf(fp, \"%s\", cpu_list_str) <= 0) {\n\t\tperror(\"Could not get core_siblings list\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\tchar *token = strtok(cpu_list_str, \"-,\");\n\n\twhile (token) {\n\t\tsibling_cpu_no = atoi(token);\n\t\t \n\t\tif (sibling_cpu_no != 0 && sibling_cpu_no != cpu_no)\n\t\t\tbreak;\n\t\ttoken = strtok(NULL, \"-,\");\n\t}\n\n\treturn sibling_cpu_no;\n}\n\n \nint taskset_benchmark(pid_t bm_pid, int cpu_no)\n{\n\tcpu_set_t my_set;\n\n\tCPU_ZERO(&my_set);\n\tCPU_SET(cpu_no, &my_set);\n\n\tif (sched_setaffinity(bm_pid, sizeof(cpu_set_t), &my_set)) {\n\t\tperror(\"Unable to taskset benchmark\");\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nvoid run_benchmark(int signum, siginfo_t *info, void *ucontext)\n{\n\tint operation, ret, memflush;\n\tchar **benchmark_cmd;\n\tsize_t span;\n\tbool once;\n\tFILE *fp;\n\n\tbenchmark_cmd = info->si_ptr;\n\n\t \n\tfp = freopen(\"/dev/null\", \"w\", stdout);\n\tif (!fp)\n\t\tPARENT_EXIT(\"Unable to direct benchmark status to /dev/null\");\n\n\tif (strcmp(benchmark_cmd[0], \"fill_buf\") == 0) {\n\t\t \n\t\tspan = strtoul(benchmark_cmd[1], NULL, 10);\n\t\tmemflush =  atoi(benchmark_cmd[2]);\n\t\toperation = atoi(benchmark_cmd[3]);\n\t\tif (!strcmp(benchmark_cmd[4], \"true\"))\n\t\t\tonce = true;\n\t\telse if (!strcmp(benchmark_cmd[4], \"false\"))\n\t\t\tonce = false;\n\t\telse\n\t\t\tPARENT_EXIT(\"Invalid once parameter\");\n\n\t\tif (run_fill_buf(span, memflush, operation, once))\n\t\t\tfprintf(stderr, \"Error in running fill buffer\\n\");\n\t} else {\n\t\t \n\t\tret = execvp(benchmark_cmd[0], benchmark_cmd);\n\t\tif (ret)\n\t\t\tperror(\"wrong\\n\");\n\t}\n\n\tfclose(stdout);\n\tPARENT_EXIT(\"Unable to run specified benchmark\");\n}\n\n \nstatic int create_grp(const char *grp_name, char *grp, const char *parent_grp)\n{\n\tint found_grp = 0;\n\tstruct dirent *ep;\n\tDIR *dp;\n\n\t \n\tif (strlen(grp_name) == 0)\n\t\treturn 0;\n\n\t \n\tdp = opendir(parent_grp);\n\tif (dp) {\n\t\twhile ((ep = readdir(dp)) != NULL) {\n\t\t\tif (strcmp(ep->d_name, grp_name) == 0)\n\t\t\t\tfound_grp = 1;\n\t\t}\n\t\tclosedir(dp);\n\t} else {\n\t\tperror(\"Unable to open resctrl for group\");\n\n\t\treturn -1;\n\t}\n\n\t \n\tif (found_grp == 0) {\n\t\tif (mkdir(grp, 0) == -1) {\n\t\t\tperror(\"Unable to create group\");\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int write_pid_to_tasks(char *tasks, pid_t pid)\n{\n\tFILE *fp;\n\n\tfp = fopen(tasks, \"w\");\n\tif (!fp) {\n\t\tperror(\"Failed to open tasks file\");\n\n\t\treturn -1;\n\t}\n\tif (fprintf(fp, \"%d\\n\", pid) < 0) {\n\t\tperror(\"Failed to wr pid to tasks file\");\n\t\tfclose(fp);\n\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}\n\n \nint write_bm_pid_to_resctrl(pid_t bm_pid, char *ctrlgrp, char *mongrp,\n\t\t\t    char *resctrl_val)\n{\n\tchar controlgroup[128], monitorgroup[512], monitorgroup_p[256];\n\tchar tasks[1024];\n\tint ret = 0;\n\n\tif (strlen(ctrlgrp))\n\t\tsprintf(controlgroup, \"%s/%s\", RESCTRL_PATH, ctrlgrp);\n\telse\n\t\tsprintf(controlgroup, \"%s\", RESCTRL_PATH);\n\n\t \n\tret = create_grp(ctrlgrp, controlgroup, RESCTRL_PATH);\n\tif (ret)\n\t\tgoto out;\n\tsprintf(tasks, \"%s/tasks\", controlgroup);\n\tret = write_pid_to_tasks(tasks, bm_pid);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (!strncmp(resctrl_val, CMT_STR, sizeof(CMT_STR)) ||\n\t    !strncmp(resctrl_val, MBM_STR, sizeof(MBM_STR))) {\n\t\tif (strlen(mongrp)) {\n\t\t\tsprintf(monitorgroup_p, \"%s/mon_groups\", controlgroup);\n\t\t\tsprintf(monitorgroup, \"%s/%s\", monitorgroup_p, mongrp);\n\t\t\tret = create_grp(mongrp, monitorgroup, monitorgroup_p);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tsprintf(tasks, \"%s/mon_groups/%s/tasks\",\n\t\t\t\tcontrolgroup, mongrp);\n\t\t\tret = write_pid_to_tasks(tasks, bm_pid);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tksft_print_msg(\"Writing benchmark parameters to resctrl FS\\n\");\n\tif (ret)\n\t\tperror(\"# writing to resctrlfs\");\n\n\treturn ret;\n}\n\n \nint write_schemata(char *ctrlgrp, char *schemata, int cpu_no, char *resctrl_val)\n{\n\tchar controlgroup[1024], schema[1024], reason[64];\n\tint resource_id, ret = 0;\n\tFILE *fp;\n\n\tif (strncmp(resctrl_val, MBA_STR, sizeof(MBA_STR)) &&\n\t    strncmp(resctrl_val, MBM_STR, sizeof(MBM_STR)) &&\n\t    strncmp(resctrl_val, CAT_STR, sizeof(CAT_STR)) &&\n\t    strncmp(resctrl_val, CMT_STR, sizeof(CMT_STR)))\n\t\treturn -ENOENT;\n\n\tif (!schemata) {\n\t\tksft_print_msg(\"Skipping empty schemata update\\n\");\n\n\t\treturn -1;\n\t}\n\n\tif (get_resource_id(cpu_no, &resource_id) < 0) {\n\t\tsprintf(reason, \"Failed to get resource id\");\n\t\tret = -1;\n\n\t\tgoto out;\n\t}\n\n\tif (strlen(ctrlgrp) != 0)\n\t\tsprintf(controlgroup, \"%s/%s/schemata\", RESCTRL_PATH, ctrlgrp);\n\telse\n\t\tsprintf(controlgroup, \"%s/schemata\", RESCTRL_PATH);\n\n\tif (!strncmp(resctrl_val, CAT_STR, sizeof(CAT_STR)) ||\n\t    !strncmp(resctrl_val, CMT_STR, sizeof(CMT_STR)))\n\t\tsprintf(schema, \"%s%d%c%s\", \"L3:\", resource_id, '=', schemata);\n\tif (!strncmp(resctrl_val, MBA_STR, sizeof(MBA_STR)) ||\n\t    !strncmp(resctrl_val, MBM_STR, sizeof(MBM_STR)))\n\t\tsprintf(schema, \"%s%d%c%s\", \"MB:\", resource_id, '=', schemata);\n\n\tfp = fopen(controlgroup, \"w\");\n\tif (!fp) {\n\t\tsprintf(reason, \"Failed to open control group\");\n\t\tret = -1;\n\n\t\tgoto out;\n\t}\n\n\tif (fprintf(fp, \"%s\\n\", schema) < 0) {\n\t\tsprintf(reason, \"Failed to write schemata in control group\");\n\t\tfclose(fp);\n\t\tret = -1;\n\n\t\tgoto out;\n\t}\n\tfclose(fp);\n\nout:\n\tksft_print_msg(\"Write schema \\\"%s\\\" to resctrl FS%s%s\\n\",\n\t\t       schema, ret ? \" # \" : \"\",\n\t\t       ret ? reason : \"\");\n\n\treturn ret;\n}\n\nbool check_resctrlfs_support(void)\n{\n\tFILE *inf = fopen(\"/proc/filesystems\", \"r\");\n\tDIR *dp;\n\tchar *res;\n\tbool ret = false;\n\n\tif (!inf)\n\t\treturn false;\n\n\tres = fgrep(inf, \"nodev\\tresctrl\\n\");\n\n\tif (res) {\n\t\tret = true;\n\t\tfree(res);\n\t}\n\n\tfclose(inf);\n\n\tksft_print_msg(\"%s Check kernel supports resctrl filesystem\\n\",\n\t\t       ret ? \"Pass:\" : \"Fail:\");\n\n\tif (!ret)\n\t\treturn ret;\n\n\tdp = opendir(RESCTRL_PATH);\n\tksft_print_msg(\"%s Check resctrl mountpoint \\\"%s\\\" exists\\n\",\n\t\t       dp ? \"Pass:\" : \"Fail:\", RESCTRL_PATH);\n\tif (dp)\n\t\tclosedir(dp);\n\n\tksft_print_msg(\"resctrl filesystem %s mounted\\n\",\n\t\t       find_resctrl_mount(NULL) ? \"not\" : \"is\");\n\n\treturn ret;\n}\n\nchar *fgrep(FILE *inf, const char *str)\n{\n\tchar line[256];\n\tint slen = strlen(str);\n\n\twhile (!feof(inf)) {\n\t\tif (!fgets(line, 256, inf))\n\t\t\tbreak;\n\t\tif (strncmp(line, str, slen))\n\t\t\tcontinue;\n\n\t\treturn strdup(line);\n\t}\n\n\treturn NULL;\n}\n\n \nbool validate_resctrl_feature_request(const char *resource, const char *feature)\n{\n\tchar res_path[PATH_MAX];\n\tstruct stat statbuf;\n\tchar *res;\n\tFILE *inf;\n\tint ret;\n\n\tif (!resource)\n\t\treturn false;\n\n\tret = find_resctrl_mount(NULL);\n\tif (ret)\n\t\treturn false;\n\n\tsnprintf(res_path, sizeof(res_path), \"%s/%s\", INFO_PATH, resource);\n\n\tif (stat(res_path, &statbuf))\n\t\treturn false;\n\n\tif (!feature)\n\t\treturn true;\n\n\tsnprintf(res_path, sizeof(res_path), \"%s/%s/mon_features\", INFO_PATH, resource);\n\tinf = fopen(res_path, \"r\");\n\tif (!inf)\n\t\treturn false;\n\n\tres = fgrep(inf, feature);\n\tfree(res);\n\tfclose(inf);\n\n\treturn !!res;\n}\n\nint filter_dmesg(void)\n{\n\tchar line[1024];\n\tFILE *fp;\n\tint pipefds[2];\n\tpid_t pid;\n\tint ret;\n\n\tret = pipe(pipefds);\n\tif (ret) {\n\t\tperror(\"pipe\");\n\t\treturn ret;\n\t}\n\tfflush(stdout);\n\tpid = fork();\n\tif (pid == 0) {\n\t\tclose(pipefds[0]);\n\t\tdup2(pipefds[1], STDOUT_FILENO);\n\t\texeclp(\"dmesg\", \"dmesg\", NULL);\n\t\tperror(\"executing dmesg\");\n\t\texit(1);\n\t}\n\tclose(pipefds[1]);\n\tfp = fdopen(pipefds[0], \"r\");\n\tif (!fp) {\n\t\tperror(\"fdopen(pipe)\");\n\t\tkill(pid, SIGTERM);\n\n\t\treturn -1;\n\t}\n\n\twhile (fgets(line, 1024, fp)) {\n\t\tif (strstr(line, \"intel_rdt:\"))\n\t\t\tksft_print_msg(\"dmesg: %s\", line);\n\t\tif (strstr(line, \"resctrl:\"))\n\t\t\tksft_print_msg(\"dmesg: %s\", line);\n\t}\n\tfclose(fp);\n\twaitpid(pid, NULL, 0);\n\n\treturn 0;\n}\n\nint validate_bw_report_request(char *bw_report)\n{\n\tif (strcmp(bw_report, \"reads\") == 0)\n\t\treturn 0;\n\tif (strcmp(bw_report, \"writes\") == 0)\n\t\treturn 0;\n\tif (strcmp(bw_report, \"nt-writes\") == 0) {\n\t\tstrcpy(bw_report, \"writes\");\n\t\treturn 0;\n\t}\n\tif (strcmp(bw_report, \"total\") == 0)\n\t\treturn 0;\n\n\tfprintf(stderr, \"Requested iMC B/W report type unavailable\\n\");\n\n\treturn -1;\n}\n\nint perf_event_open(struct perf_event_attr *hw_event, pid_t pid, int cpu,\n\t\t    int group_fd, unsigned long flags)\n{\n\tint ret;\n\n\tret = syscall(__NR_perf_event_open, hw_event, pid, cpu,\n\t\t      group_fd, flags);\n\treturn ret;\n}\n\nunsigned int count_bits(unsigned long n)\n{\n\tunsigned int count = 0;\n\n\twhile (n) {\n\t\tcount += n & 1;\n\t\tn >>= 1;\n\t}\n\n\treturn count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}