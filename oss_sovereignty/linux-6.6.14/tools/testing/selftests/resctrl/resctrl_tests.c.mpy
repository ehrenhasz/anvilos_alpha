{
  "module_name": "resctrl_tests.c",
  "hash_id": "7bfcccb2ba0d64b6654fc040558389b04a1be8cef0da007754803dd88597e7ca",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/resctrl/resctrl_tests.c",
  "human_readable_source": "\n \n#include \"resctrl.h\"\n\nstatic int detect_vendor(void)\n{\n\tFILE *inf = fopen(\"/proc/cpuinfo\", \"r\");\n\tint vendor_id = 0;\n\tchar *s = NULL;\n\tchar *res;\n\n\tif (!inf)\n\t\treturn vendor_id;\n\n\tres = fgrep(inf, \"vendor_id\");\n\n\tif (res)\n\t\ts = strchr(res, ':');\n\n\tif (s && !strcmp(s, \": GenuineIntel\\n\"))\n\t\tvendor_id = ARCH_INTEL;\n\telse if (s && !strcmp(s, \": AuthenticAMD\\n\"))\n\t\tvendor_id = ARCH_AMD;\n\n\tfclose(inf);\n\tfree(res);\n\treturn vendor_id;\n}\n\nint get_vendor(void)\n{\n\tstatic int vendor = -1;\n\n\tif (vendor == -1)\n\t\tvendor = detect_vendor();\n\tif (vendor == 0)\n\t\tksft_print_msg(\"Can not get vendor info...\\n\");\n\n\treturn vendor;\n}\n\nstatic void cmd_help(void)\n{\n\tprintf(\"usage: resctrl_tests [-h] [-b \\\"benchmark_cmd [options]\\\"] [-t test list] [-n no_of_bits]\\n\");\n\tprintf(\"\\t-b benchmark_cmd [options]: run specified benchmark for MBM, MBA and CMT\\n\");\n\tprintf(\"\\t   default benchmark is builtin fill_buf\\n\");\n\tprintf(\"\\t-t test list: run tests specified in the test list, \");\n\tprintf(\"e.g. -t mbm,mba,cmt,cat\\n\");\n\tprintf(\"\\t-n no_of_bits: run cache tests using specified no of bits in cache bit mask\\n\");\n\tprintf(\"\\t-p cpu_no: specify CPU number to run the test. 1 is default\\n\");\n\tprintf(\"\\t-h: help\\n\");\n}\n\nvoid tests_cleanup(void)\n{\n\tmbm_test_cleanup();\n\tmba_test_cleanup();\n\tcmt_test_cleanup();\n\tcat_test_cleanup();\n}\n\nstatic int test_prepare(void)\n{\n\tint res;\n\n\tres = signal_handler_register();\n\tif (res) {\n\t\tksft_print_msg(\"Failed to register signal handler\\n\");\n\t\treturn res;\n\t}\n\n\tres = mount_resctrlfs();\n\tif (res) {\n\t\tsignal_handler_unregister();\n\t\tksft_print_msg(\"Failed to mount resctrl FS\\n\");\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nstatic void test_cleanup(void)\n{\n\tumount_resctrlfs();\n\tsignal_handler_unregister();\n}\n\nstatic void run_mbm_test(const char * const *benchmark_cmd, int cpu_no)\n{\n\tint res;\n\n\tksft_print_msg(\"Starting MBM BW change ...\\n\");\n\n\tif (test_prepare()) {\n\t\tksft_exit_fail_msg(\"Abnormal failure when preparing for the test\\n\");\n\t\treturn;\n\t}\n\n\tif (!validate_resctrl_feature_request(\"L3_MON\", \"mbm_total_bytes\") ||\n\t    !validate_resctrl_feature_request(\"L3_MON\", \"mbm_local_bytes\") ||\n\t    (get_vendor() != ARCH_INTEL)) {\n\t\tksft_test_result_skip(\"Hardware does not support MBM or MBM is disabled\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tres = mbm_bw_change(cpu_no, benchmark_cmd);\n\tksft_test_result(!res, \"MBM: bw change\\n\");\n\tif ((get_vendor() == ARCH_INTEL) && res)\n\t\tksft_print_msg(\"Intel MBM may be inaccurate when Sub-NUMA Clustering is enabled. Check BIOS configuration.\\n\");\n\ncleanup:\n\ttest_cleanup();\n}\n\nstatic void run_mba_test(const char * const *benchmark_cmd, int cpu_no)\n{\n\tint res;\n\n\tksft_print_msg(\"Starting MBA Schemata change ...\\n\");\n\n\tif (test_prepare()) {\n\t\tksft_exit_fail_msg(\"Abnormal failure when preparing for the test\\n\");\n\t\treturn;\n\t}\n\n\tif (!validate_resctrl_feature_request(\"MB\", NULL) ||\n\t    !validate_resctrl_feature_request(\"L3_MON\", \"mbm_local_bytes\") ||\n\t    (get_vendor() != ARCH_INTEL)) {\n\t\tksft_test_result_skip(\"Hardware does not support MBA or MBA is disabled\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tres = mba_schemata_change(cpu_no, benchmark_cmd);\n\tksft_test_result(!res, \"MBA: schemata change\\n\");\n\ncleanup:\n\ttest_cleanup();\n}\n\nstatic void run_cmt_test(const char * const *benchmark_cmd, int cpu_no)\n{\n\tint res;\n\n\tksft_print_msg(\"Starting CMT test ...\\n\");\n\n\tif (test_prepare()) {\n\t\tksft_exit_fail_msg(\"Abnormal failure when preparing for the test\\n\");\n\t\treturn;\n\t}\n\n\tif (!validate_resctrl_feature_request(\"L3_MON\", \"llc_occupancy\") ||\n\t    !validate_resctrl_feature_request(\"L3\", NULL)) {\n\t\tksft_test_result_skip(\"Hardware does not support CMT or CMT is disabled\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tres = cmt_resctrl_val(cpu_no, 5, benchmark_cmd);\n\tksft_test_result(!res, \"CMT: test\\n\");\n\tif ((get_vendor() == ARCH_INTEL) && res)\n\t\tksft_print_msg(\"Intel CMT may be inaccurate when Sub-NUMA Clustering is enabled. Check BIOS configuration.\\n\");\n\ncleanup:\n\ttest_cleanup();\n}\n\nstatic void run_cat_test(int cpu_no, int no_of_bits)\n{\n\tint res;\n\n\tksft_print_msg(\"Starting CAT test ...\\n\");\n\n\tif (test_prepare()) {\n\t\tksft_exit_fail_msg(\"Abnormal failure when preparing for the test\\n\");\n\t\treturn;\n\t}\n\n\tif (!validate_resctrl_feature_request(\"L3\", NULL)) {\n\t\tksft_test_result_skip(\"Hardware does not support CAT or CAT is disabled\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tres = cat_perf_miss_val(cpu_no, no_of_bits, \"L3\");\n\tksft_test_result(!res, \"CAT: test\\n\");\n\ncleanup:\n\ttest_cleanup();\n}\n\nint main(int argc, char **argv)\n{\n\tbool has_ben = false, mbm_test = true, mba_test = true, cmt_test = true;\n\tint c, cpu_no = 1, argc_new = argc, i, no_of_bits = 0;\n\tconst char *benchmark_cmd[BENCHMARK_ARGS];\n\tint ben_ind, ben_count, tests = 0;\n\tchar *span_str = NULL;\n\tbool cat_test = true;\n\tint ret;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-b\") == 0) {\n\t\t\tben_ind = i + 1;\n\t\t\tben_count = argc - ben_ind;\n\t\t\targc_new = ben_ind - 1;\n\t\t\thas_ben = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile ((c = getopt(argc_new, argv, \"ht:b:n:p:\")) != -1) {\n\t\tchar *token;\n\n\t\tswitch (c) {\n\t\tcase 't':\n\t\t\ttoken = strtok(optarg, \",\");\n\n\t\t\tmbm_test = false;\n\t\t\tmba_test = false;\n\t\t\tcmt_test = false;\n\t\t\tcat_test = false;\n\t\t\twhile (token) {\n\t\t\t\tif (!strncmp(token, MBM_STR, sizeof(MBM_STR))) {\n\t\t\t\t\tmbm_test = true;\n\t\t\t\t\ttests++;\n\t\t\t\t} else if (!strncmp(token, MBA_STR, sizeof(MBA_STR))) {\n\t\t\t\t\tmba_test = true;\n\t\t\t\t\ttests++;\n\t\t\t\t} else if (!strncmp(token, CMT_STR, sizeof(CMT_STR))) {\n\t\t\t\t\tcmt_test = true;\n\t\t\t\t\ttests++;\n\t\t\t\t} else if (!strncmp(token, CAT_STR, sizeof(CAT_STR))) {\n\t\t\t\t\tcat_test = true;\n\t\t\t\t\ttests++;\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"invalid argument\\n\");\n\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\ttoken = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcpu_no = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tno_of_bits = atoi(optarg);\n\t\t\tif (no_of_bits <= 0) {\n\t\t\t\tprintf(\"Bail out! invalid argument for no_of_bits\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tcmd_help();\n\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tprintf(\"invalid argument\\n\");\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tksft_print_header();\n\n\t \n\tif (geteuid() != 0)\n\t\treturn ksft_exit_skip(\"Not running as root. Skipping...\\n\");\n\n\tif (has_ben) {\n\t\tif (argc - ben_ind >= BENCHMARK_ARGS)\n\t\t\tksft_exit_fail_msg(\"Too long benchmark command.\\n\");\n\n\t\t \n\t\tfor (i = 0; i < argc - ben_ind; i++)\n\t\t\tbenchmark_cmd[i] = argv[i + ben_ind];\n\t\tbenchmark_cmd[ben_count] = NULL;\n\t} else {\n\t\t \n\t\tbenchmark_cmd[0] = \"fill_buf\";\n\t\tret = asprintf(&span_str, \"%u\", DEFAULT_SPAN);\n\t\tif (ret < 0)\n\t\t\tksft_exit_fail_msg(\"Out of memory!\\n\");\n\t\tbenchmark_cmd[1] = span_str;\n\t\tbenchmark_cmd[2] = \"1\";\n\t\tbenchmark_cmd[3] = \"0\";\n\t\tbenchmark_cmd[4] = \"false\";\n\t\tbenchmark_cmd[5] = NULL;\n\t}\n\n\tif (!check_resctrlfs_support())\n\t\treturn ksft_exit_skip(\"resctrl FS does not exist. Enable X86_CPU_RESCTRL config option.\\n\");\n\n\tif (umount_resctrlfs())\n\t\treturn ksft_exit_skip(\"resctrl FS unmount failed.\\n\");\n\n\tfilter_dmesg();\n\n\tksft_set_plan(tests ? : 4);\n\n\tif (mbm_test)\n\t\trun_mbm_test(benchmark_cmd, cpu_no);\n\n\tif (mba_test)\n\t\trun_mba_test(benchmark_cmd, cpu_no);\n\n\tif (cmt_test)\n\t\trun_cmt_test(benchmark_cmd, cpu_no);\n\n\tif (cat_test)\n\t\trun_cat_test(cpu_no, no_of_bits);\n\n\tfree(span_str);\n\tksft_finished();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}