{
  "module_name": "fill_buf.c",
  "hash_id": "759759dcc88f24dee028de6ad9ea380eb9f1df2c9e91fcb588217eef274e4a11",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/resctrl/fill_buf.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <inttypes.h>\n#include <string.h>\n\n#include \"resctrl.h\"\n\n#define CL_SIZE\t\t\t(64)\n#define PAGE_SIZE\t\t(4 * 1024)\n#define MB\t\t\t(1024 * 1024)\n\nstatic void sb(void)\n{\n#if defined(__i386) || defined(__x86_64)\n\tasm volatile(\"sfence\\n\\t\"\n\t\t     : : : \"memory\");\n#endif\n}\n\nstatic void cl_flush(void *p)\n{\n#if defined(__i386) || defined(__x86_64)\n\tasm volatile(\"clflush (%0)\\n\\t\"\n\t\t     : : \"r\"(p) : \"memory\");\n#endif\n}\n\nstatic void mem_flush(unsigned char *buf, size_t buf_size)\n{\n\tunsigned char *cp = buf;\n\tsize_t i = 0;\n\n\tbuf_size = buf_size / CL_SIZE;  \n\n\tfor (i = 0; i < buf_size; i++)\n\t\tcl_flush(&cp[i * CL_SIZE]);\n\n\tsb();\n}\n\nstatic void *malloc_and_init_memory(size_t buf_size)\n{\n\tvoid *p = NULL;\n\tuint64_t *p64;\n\tsize_t s64;\n\tint ret;\n\n\tret = posix_memalign(&p, PAGE_SIZE, buf_size);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tp64 = (uint64_t *)p;\n\ts64 = buf_size / sizeof(uint64_t);\n\n\twhile (s64 > 0) {\n\t\t*p64 = (uint64_t)rand();\n\t\tp64 += (CL_SIZE / sizeof(uint64_t));\n\t\ts64 -= (CL_SIZE / sizeof(uint64_t));\n\t}\n\n\treturn p;\n}\n\nstatic int fill_one_span_read(unsigned char *buf, size_t buf_size)\n{\n\tunsigned char *end_ptr = buf + buf_size;\n\tunsigned char sum, *p;\n\n\tsum = 0;\n\tp = buf;\n\twhile (p < end_ptr) {\n\t\tsum += *p;\n\t\tp += (CL_SIZE / 2);\n\t}\n\n\treturn sum;\n}\n\nstatic void fill_one_span_write(unsigned char *buf, size_t buf_size)\n{\n\tunsigned char *end_ptr = buf + buf_size;\n\tunsigned char *p;\n\n\tp = buf;\n\twhile (p < end_ptr) {\n\t\t*p = '1';\n\t\tp += (CL_SIZE / 2);\n\t}\n}\n\nstatic int fill_cache_read(unsigned char *buf, size_t buf_size, bool once)\n{\n\tint ret = 0;\n\tFILE *fp;\n\n\twhile (1) {\n\t\tret = fill_one_span_read(buf, buf_size);\n\t\tif (once)\n\t\t\tbreak;\n\t}\n\n\t \n\tfp = fopen(\"/dev/null\", \"w\");\n\tif (!fp) {\n\t\tperror(\"Unable to write to /dev/null\");\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"Sum: %d \", ret);\n\tfclose(fp);\n\n\treturn 0;\n}\n\nstatic int fill_cache_write(unsigned char *buf, size_t buf_size, bool once)\n{\n\twhile (1) {\n\t\tfill_one_span_write(buf, buf_size);\n\t\tif (once)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int fill_cache(size_t buf_size, int memflush, int op, bool once)\n{\n\tunsigned char *buf;\n\tint ret;\n\n\tbuf = malloc_and_init_memory(buf_size);\n\tif (!buf)\n\t\treturn -1;\n\n\t \n\tif (memflush)\n\t\tmem_flush(buf, buf_size);\n\n\tif (op == 0)\n\t\tret = fill_cache_read(buf, buf_size, once);\n\telse\n\t\tret = fill_cache_write(buf, buf_size, once);\n\n\tfree(buf);\n\n\tif (ret) {\n\t\tprintf(\"\\n Error in fill cache read/write...\\n\");\n\t\treturn -1;\n\t}\n\n\n\treturn 0;\n}\n\nint run_fill_buf(size_t span, int memflush, int op, bool once)\n{\n\tsize_t cache_size = span;\n\tint ret;\n\n\tret = fill_cache(cache_size, memflush, op, once);\n\tif (ret) {\n\t\tprintf(\"\\n Error in fill cache\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}