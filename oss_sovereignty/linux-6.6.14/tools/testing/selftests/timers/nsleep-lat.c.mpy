{
  "module_name": "nsleep-lat.c",
  "hash_id": "cf330c1389ab9f0e0e6821338f4f61f05ee270d8312bee78522b766cf3e98598",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/nsleep-lat.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/timex.h>\n#include <string.h>\n#include <signal.h>\n#include \"../kselftest.h\"\n\n#define NSEC_PER_SEC 1000000000ULL\n\n#define UNRESONABLE_LATENCY 40000000  \n\n\n#define CLOCK_REALTIME\t\t\t0\n#define CLOCK_MONOTONIC\t\t\t1\n#define CLOCK_PROCESS_CPUTIME_ID\t2\n#define CLOCK_THREAD_CPUTIME_ID\t\t3\n#define CLOCK_MONOTONIC_RAW\t\t4\n#define CLOCK_REALTIME_COARSE\t\t5\n#define CLOCK_MONOTONIC_COARSE\t\t6\n#define CLOCK_BOOTTIME\t\t\t7\n#define CLOCK_REALTIME_ALARM\t\t8\n#define CLOCK_BOOTTIME_ALARM\t\t9\n#define CLOCK_HWSPECIFIC\t\t10\n#define CLOCK_TAI\t\t\t11\n#define NR_CLOCKIDS\t\t\t12\n\n#define UNSUPPORTED 0xf00f\n\nchar *clockstring(int clockid)\n{\n\tswitch (clockid) {\n\tcase CLOCK_REALTIME:\n\t\treturn \"CLOCK_REALTIME\";\n\tcase CLOCK_MONOTONIC:\n\t\treturn \"CLOCK_MONOTONIC\";\n\tcase CLOCK_PROCESS_CPUTIME_ID:\n\t\treturn \"CLOCK_PROCESS_CPUTIME_ID\";\n\tcase CLOCK_THREAD_CPUTIME_ID:\n\t\treturn \"CLOCK_THREAD_CPUTIME_ID\";\n\tcase CLOCK_MONOTONIC_RAW:\n\t\treturn \"CLOCK_MONOTONIC_RAW\";\n\tcase CLOCK_REALTIME_COARSE:\n\t\treturn \"CLOCK_REALTIME_COARSE\";\n\tcase CLOCK_MONOTONIC_COARSE:\n\t\treturn \"CLOCK_MONOTONIC_COARSE\";\n\tcase CLOCK_BOOTTIME:\n\t\treturn \"CLOCK_BOOTTIME\";\n\tcase CLOCK_REALTIME_ALARM:\n\t\treturn \"CLOCK_REALTIME_ALARM\";\n\tcase CLOCK_BOOTTIME_ALARM:\n\t\treturn \"CLOCK_BOOTTIME_ALARM\";\n\tcase CLOCK_TAI:\n\t\treturn \"CLOCK_TAI\";\n\t};\n\treturn \"UNKNOWN_CLOCKID\";\n}\n\nstruct timespec timespec_add(struct timespec ts, unsigned long long ns)\n{\n\tts.tv_nsec += ns;\n\twhile (ts.tv_nsec >= NSEC_PER_SEC) {\n\t\tts.tv_nsec -= NSEC_PER_SEC;\n\t\tts.tv_sec++;\n\t}\n\treturn ts;\n}\n\n\nlong long timespec_sub(struct timespec a, struct timespec b)\n{\n\tlong long ret = NSEC_PER_SEC * b.tv_sec + b.tv_nsec;\n\n\tret -= NSEC_PER_SEC * a.tv_sec + a.tv_nsec;\n\treturn ret;\n}\n\nint nanosleep_lat_test(int clockid, long long ns)\n{\n\tstruct timespec start, end, target;\n\tlong long latency = 0;\n\tint i, count;\n\n\ttarget.tv_sec = ns/NSEC_PER_SEC;\n\ttarget.tv_nsec = ns%NSEC_PER_SEC;\n\n\tif (clock_gettime(clockid, &start))\n\t\treturn UNSUPPORTED;\n\tif (clock_nanosleep(clockid, 0, &target, NULL))\n\t\treturn UNSUPPORTED;\n\n\tcount = 10;\n\n\t \n\tclock_gettime(clockid, &start);\n\tfor (i = 0; i < count; i++)\n\t\tclock_nanosleep(clockid, 0, &target, NULL);\n\tclock_gettime(clockid, &end);\n\n\tif (((timespec_sub(start, end)/count)-ns) > UNRESONABLE_LATENCY) {\n\t\tprintf(\"Large rel latency: %lld ns :\", (timespec_sub(start, end)/count)-ns);\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tclock_gettime(clockid, &start);\n\t\ttarget = timespec_add(start, ns);\n\t\tclock_nanosleep(clockid, TIMER_ABSTIME, &target, NULL);\n\t\tclock_gettime(clockid, &end);\n\t\tlatency += timespec_sub(target, end);\n\t}\n\n\tif (latency/count > UNRESONABLE_LATENCY) {\n\t\tprintf(\"Large abs latency: %lld ns :\", latency/count);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n\nint main(int argc, char **argv)\n{\n\tlong long length;\n\tint clockid, ret;\n\n\tfor (clockid = CLOCK_REALTIME; clockid < NR_CLOCKIDS; clockid++) {\n\n\t\t \n\t\tif (clockid == CLOCK_PROCESS_CPUTIME_ID ||\n\t\t\t\tclockid == CLOCK_THREAD_CPUTIME_ID ||\n\t\t\t\tclockid == CLOCK_HWSPECIFIC)\n\t\t\tcontinue;\n\n\t\tprintf(\"nsleep latency %-26s \", clockstring(clockid));\n\t\tfflush(stdout);\n\n\t\tlength = 10;\n\t\twhile (length <= (NSEC_PER_SEC * 10)) {\n\t\t\tret = nanosleep_lat_test(clockid, length);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tlength *= 100;\n\n\t\t}\n\n\t\tif (ret == UNSUPPORTED) {\n\t\t\tprintf(\"[UNSUPPORTED]\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tprintf(\"[FAILED]\\n\");\n\t\t\treturn ksft_exit_fail();\n\t\t}\n\t\tprintf(\"[OK]\\n\");\n\t}\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}