{
  "module_name": "leap-a-day.c",
  "hash_id": "5bd71f40e5d29d075525175a8d58db52fcf31a4b5f70eab2877c024024fe04fd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/leap-a-day.c",
  "human_readable_source": " \n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/timex.h>\n#include <sys/errno.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include \"../kselftest.h\"\n\n#define NSEC_PER_SEC 1000000000ULL\n#define CLOCK_TAI 11\n\ntime_t next_leap;\nint error_found;\n\n \nstatic inline int in_order(struct timespec a, struct timespec b)\n{\n\tif (a.tv_sec < b.tv_sec)\n\t\treturn 1;\n\tif (a.tv_sec > b.tv_sec)\n\t\treturn 0;\n\tif (a.tv_nsec > b.tv_nsec)\n\t\treturn 0;\n\treturn 1;\n}\n\nstruct timespec timespec_add(struct timespec ts, unsigned long long ns)\n{\n\tts.tv_nsec += ns;\n\twhile (ts.tv_nsec >= NSEC_PER_SEC) {\n\t\tts.tv_nsec -= NSEC_PER_SEC;\n\t\tts.tv_sec++;\n\t}\n\treturn ts;\n}\n\nchar *time_state_str(int state)\n{\n\tswitch (state) {\n\tcase TIME_OK:\treturn \"TIME_OK\";\n\tcase TIME_INS:\treturn \"TIME_INS\";\n\tcase TIME_DEL:\treturn \"TIME_DEL\";\n\tcase TIME_OOP:\treturn \"TIME_OOP\";\n\tcase TIME_WAIT:\treturn \"TIME_WAIT\";\n\tcase TIME_BAD:\treturn \"TIME_BAD\";\n\t}\n\treturn \"ERROR\";\n}\n\n \nint clear_time_state(void)\n{\n\tstruct timex tx;\n\tint ret;\n\n\t \n\ttx.modes = ADJ_STATUS;\n\ttx.status = STA_PLL;\n\tret = adjtimex(&tx);\n\n\t \n\ttx.modes = ADJ_MAXERROR;\n\ttx.maxerror = 0;\n\tret = adjtimex(&tx);\n\n\t \n\ttx.modes = ADJ_STATUS;\n\ttx.status = 0;\n\tret = adjtimex(&tx);\n\n\treturn ret;\n}\n\n \nvoid handler(int unused)\n{\n\tclear_time_state();\n\texit(0);\n}\n\nvoid sigalarm(int signo)\n{\n\tstruct timex tx;\n\tint ret;\n\n\ttx.modes = 0;\n\tret = adjtimex(&tx);\n\n\tif (tx.time.tv_sec < next_leap) {\n\t\tprintf(\"Error: Early timer expiration! (Should be %ld)\\n\", next_leap);\n\t\terror_found = 1;\n\t\tprintf(\"adjtimex: %10ld sec + %6ld us (%i)\\t%s\\n\",\n\t\t\t\t\ttx.time.tv_sec,\n\t\t\t\t\ttx.time.tv_usec,\n\t\t\t\t\ttx.tai,\n\t\t\t\t\ttime_state_str(ret));\n\t}\n\tif (ret != TIME_WAIT) {\n\t\tprintf(\"Error: Timer seeing incorrect NTP state? (Should be TIME_WAIT)\\n\");\n\t\terror_found = 1;\n\t\tprintf(\"adjtimex: %10ld sec + %6ld us (%i)\\t%s\\n\",\n\t\t\t\t\ttx.time.tv_sec,\n\t\t\t\t\ttx.time.tv_usec,\n\t\t\t\t\ttx.tai,\n\t\t\t\t\ttime_state_str(ret));\n\t}\n}\n\n\n \nvoid test_hrtimer_failure(void)\n{\n\tstruct timespec now, target;\n\n\tclock_gettime(CLOCK_REALTIME, &now);\n\ttarget = timespec_add(now, NSEC_PER_SEC/2);\n\tclock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &target, NULL);\n\tclock_gettime(CLOCK_REALTIME, &now);\n\n\tif (!in_order(target, now)) {\n\t\tprintf(\"ERROR: hrtimer early expiration failure observed.\\n\");\n\t\terror_found = 1;\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\ttimer_t tm1;\n\tstruct itimerspec its1;\n\tstruct sigevent se;\n\tstruct sigaction act;\n\tint signum = SIGRTMAX;\n\tint settime = 1;\n\tint tai_time = 0;\n\tint insert = 1;\n\tint iterations = 10;\n\tint opt;\n\n\t \n\twhile ((opt = getopt(argc, argv, \"sti:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'w':\n\t\t\tprintf(\"Only setting leap-flag, not changing time. It could take up to a day for leap to trigger.\\n\");\n\t\t\tsettime = 0;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\titerations = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttai_time = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Usage: %s [-w] [-i <iterations>]\\n\", argv[0]);\n\t\t\tprintf(\"\t-w: Set flag and wait for leap second each iteration\");\n\t\t\tprintf(\"\t    (default sets time to right before leapsecond)\\n\");\n\t\t\tprintf(\"\t-i: Number of iterations (-1 = infinite, default is 10)\\n\");\n\t\t\tprintf(\"\t-t: Print TAI time\\n\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\t \n\tif (tai_time) {\n\t\tstruct timespec ts;\n\n\t\tif (clock_gettime(CLOCK_TAI, &ts)) {\n\t\t\tprintf(\"System doesn't support CLOCK_TAI\\n\");\n\t\t\tksft_exit_fail();\n\t\t}\n\t}\n\n\tsignal(SIGINT, handler);\n\tsignal(SIGKILL, handler);\n\n\t \n\tsigfillset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = sigalarm;\n\tsigaction(signum, &act, NULL);\n\n\tif (iterations < 0)\n\t\tprintf(\"This runs continuously. Press ctrl-c to stop\\n\");\n\telse\n\t\tprintf(\"Running for %i iterations. Press ctrl-c to stop\\n\", iterations);\n\n\tprintf(\"\\n\");\n\twhile (1) {\n\t\tint ret;\n\t\tstruct timespec ts;\n\t\tstruct timex tx;\n\t\ttime_t now;\n\n\t\t \n\t\tclock_gettime(CLOCK_REALTIME, &ts);\n\n\t\t \n\t\tnext_leap = ts.tv_sec;\n\t\tnext_leap += 86400 - (next_leap % 86400);\n\n\t\tif (settime) {\n\t\t\tstruct timeval tv;\n\n\t\t\ttv.tv_sec = next_leap - 10;\n\t\t\ttv.tv_usec = 0;\n\t\t\tsettimeofday(&tv, NULL);\n\t\t\tprintf(\"Setting time to %s\", ctime(&tv.tv_sec));\n\t\t}\n\n\t\t \n\t\tclear_time_state();\n\n\t\t \n\t\ttx.modes = ADJ_STATUS;\n\t\tif (insert)\n\t\t\ttx.status = STA_INS;\n\t\telse\n\t\t\ttx.status = STA_DEL;\n\t\tret = adjtimex(&tx);\n\t\tif (ret < 0) {\n\t\t\tprintf(\"Error: Problem setting STA_INS/STA_DEL!: %s\\n\",\n\t\t\t\t\t\t\ttime_state_str(ret));\n\t\t\treturn ksft_exit_fail();\n\t\t}\n\n\t\t \n\t\ttx.modes = 0;\n\t\tret = adjtimex(&tx);\n\t\tif (tx.status != STA_INS && tx.status != STA_DEL) {\n\t\t\tprintf(\"Error: STA_INS/STA_DEL not set!: %s\\n\",\n\t\t\t\t\t\t\ttime_state_str(ret));\n\t\t\treturn ksft_exit_fail();\n\t\t}\n\n\t\tif (tai_time) {\n\t\t\tprintf(\"Using TAI time,\"\n\t\t\t\t\" no inconsistencies should be seen!\\n\");\n\t\t}\n\n\t\tprintf(\"Scheduling leap second for %s\", ctime(&next_leap));\n\n\t\t \n\t\tprintf(\"Setting timer for %ld -  %s\", next_leap, ctime(&next_leap));\n\t\tmemset(&se, 0, sizeof(se));\n\t\tse.sigev_notify = SIGEV_SIGNAL;\n\t\tse.sigev_signo = signum;\n\t\tse.sigev_value.sival_int = 0;\n\t\tif (timer_create(CLOCK_REALTIME, &se, &tm1) == -1) {\n\t\t\tprintf(\"Error: timer_create failed\\n\");\n\t\t\treturn ksft_exit_fail();\n\t\t}\n\t\tits1.it_value.tv_sec = next_leap;\n\t\tits1.it_value.tv_nsec = 0;\n\t\tits1.it_interval.tv_sec = 0;\n\t\tits1.it_interval.tv_nsec = 0;\n\t\ttimer_settime(tm1, TIMER_ABSTIME, &its1, NULL);\n\n\t\t \n\t\tts.tv_sec = next_leap - 3;\n\t\tts.tv_nsec = 0;\n\n\n\t\twhile (clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &ts, NULL))\n\t\t\tprintf(\"Something woke us up, returning to sleep\\n\");\n\n\t\t \n\t\ttx.modes = 0;\n\t\tret = adjtimex(&tx);\n\t\tif (tx.status != STA_INS && tx.status != STA_DEL) {\n\t\t\tprintf(\"Something cleared STA_INS/STA_DEL, setting it again.\\n\");\n\t\t\ttx.modes = ADJ_STATUS;\n\t\t\tif (insert)\n\t\t\t\ttx.status = STA_INS;\n\t\t\telse\n\t\t\t\ttx.status = STA_DEL;\n\t\t\tret = adjtimex(&tx);\n\t\t}\n\n\t\t \n\t\tnow = tx.time.tv_sec;\n\t\twhile (now < next_leap + 2) {\n\t\t\tchar buf[26];\n\t\t\tstruct timespec tai;\n\t\t\tint ret;\n\n\t\t\ttx.modes = 0;\n\t\t\tret = adjtimex(&tx);\n\n\t\t\tif (tai_time) {\n\t\t\t\tclock_gettime(CLOCK_TAI, &tai);\n\t\t\t\tprintf(\"%ld sec, %9ld ns\\t%s\\n\",\n\t\t\t\t\t\ttai.tv_sec,\n\t\t\t\t\t\ttai.tv_nsec,\n\t\t\t\t\t\ttime_state_str(ret));\n\t\t\t} else {\n\t\t\t\tctime_r(&tx.time.tv_sec, buf);\n\t\t\t\tbuf[strlen(buf)-1] = 0;  \n\n\t\t\t\tprintf(\"%s + %6ld us (%i)\\t%s\\n\",\n\t\t\t\t\t\tbuf,\n\t\t\t\t\t\ttx.time.tv_usec,\n\t\t\t\t\t\ttx.tai,\n\t\t\t\t\t\ttime_state_str(ret));\n\t\t\t}\n\t\t\tnow = tx.time.tv_sec;\n\t\t\t \n\t\t\tts.tv_sec = 0;\n\t\t\tts.tv_nsec = NSEC_PER_SEC / 2;\n\t\t\tclock_nanosleep(CLOCK_MONOTONIC, 0, &ts, NULL);\n\t\t}\n\t\t \n\t\tinsert = !insert;\n\n\t\t \n\t\ttest_hrtimer_failure();\n\n\t\tprintf(\"Leap complete\\n\");\n\t\tif (error_found) {\n\t\t\tprintf(\"Errors observed\\n\");\n\t\t\tclear_time_state();\n\t\t\treturn ksft_exit_fail();\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tif ((iterations != -1) && !(--iterations))\n\t\t\tbreak;\n\t}\n\n\tclear_time_state();\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}