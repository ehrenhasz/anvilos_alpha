{
  "module_name": "alarmtimer-suspend.c",
  "hash_id": "1826133b18d2250b36ab5234177e3a287fade5b7c85b73a983a11af7c202e937",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/alarmtimer-suspend.c",
  "human_readable_source": " \n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include \"../kselftest.h\"\n\n#define CLOCK_REALTIME\t\t\t0\n#define CLOCK_MONOTONIC\t\t\t1\n#define CLOCK_PROCESS_CPUTIME_ID\t2\n#define CLOCK_THREAD_CPUTIME_ID\t\t3\n#define CLOCK_MONOTONIC_RAW\t\t4\n#define CLOCK_REALTIME_COARSE\t\t5\n#define CLOCK_MONOTONIC_COARSE\t\t6\n#define CLOCK_BOOTTIME\t\t\t7\n#define CLOCK_REALTIME_ALARM\t\t8\n#define CLOCK_BOOTTIME_ALARM\t\t9\n#define CLOCK_HWSPECIFIC\t\t10\n#define CLOCK_TAI\t\t\t11\n#define NR_CLOCKIDS\t\t\t12\n\n\n#define NSEC_PER_SEC 1000000000ULL\n#define UNREASONABLE_LAT (NSEC_PER_SEC * 5)  \n\n#define SUSPEND_SECS 15\nint alarmcount;\nint alarm_clock_id;\nstruct timespec start_time;\n\n\nchar *clockstring(int clockid)\n{\n\tswitch (clockid) {\n\tcase CLOCK_REALTIME:\n\t\treturn \"CLOCK_REALTIME\";\n\tcase CLOCK_MONOTONIC:\n\t\treturn \"CLOCK_MONOTONIC\";\n\tcase CLOCK_PROCESS_CPUTIME_ID:\n\t\treturn \"CLOCK_PROCESS_CPUTIME_ID\";\n\tcase CLOCK_THREAD_CPUTIME_ID:\n\t\treturn \"CLOCK_THREAD_CPUTIME_ID\";\n\tcase CLOCK_MONOTONIC_RAW:\n\t\treturn \"CLOCK_MONOTONIC_RAW\";\n\tcase CLOCK_REALTIME_COARSE:\n\t\treturn \"CLOCK_REALTIME_COARSE\";\n\tcase CLOCK_MONOTONIC_COARSE:\n\t\treturn \"CLOCK_MONOTONIC_COARSE\";\n\tcase CLOCK_BOOTTIME:\n\t\treturn \"CLOCK_BOOTTIME\";\n\tcase CLOCK_REALTIME_ALARM:\n\t\treturn \"CLOCK_REALTIME_ALARM\";\n\tcase CLOCK_BOOTTIME_ALARM:\n\t\treturn \"CLOCK_BOOTTIME_ALARM\";\n\tcase CLOCK_TAI:\n\t\treturn \"CLOCK_TAI\";\n\t}\n\treturn \"UNKNOWN_CLOCKID\";\n}\n\n\nlong long timespec_sub(struct timespec a, struct timespec b)\n{\n\tlong long ret = NSEC_PER_SEC * b.tv_sec + b.tv_nsec;\n\n\tret -= NSEC_PER_SEC * a.tv_sec + a.tv_nsec;\n\treturn ret;\n}\n\nint final_ret;\n\nvoid sigalarm(int signo)\n{\n\tlong long delta_ns;\n\tstruct timespec ts;\n\n\tclock_gettime(alarm_clock_id, &ts);\n\talarmcount++;\n\n\tdelta_ns = timespec_sub(start_time, ts);\n\tdelta_ns -= NSEC_PER_SEC * SUSPEND_SECS * alarmcount;\n\n\tprintf(\"ALARM(%i): %ld:%ld latency: %lld ns \", alarmcount, ts.tv_sec,\n\t\t\t\t\t\t\tts.tv_nsec, delta_ns);\n\n\tif (delta_ns > UNREASONABLE_LAT) {\n\t\tprintf(\"[FAIL]\\n\");\n\t\tfinal_ret = -1;\n\t} else\n\t\tprintf(\"[OK]\\n\");\n\n}\n\nint main(void)\n{\n\ttimer_t tm1;\n\tstruct itimerspec its1, its2;\n\tstruct sigevent se;\n\tstruct sigaction act;\n\tint signum = SIGRTMAX;\n\n\t \n\tsigfillset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = sigalarm;\n\tsigaction(signum, &act, NULL);\n\n\t \n\tmemset(&se, 0, sizeof(se));\n\tse.sigev_notify = SIGEV_SIGNAL;\n\tse.sigev_signo = signum;\n\tse.sigev_value.sival_int = 0;\n\n\tfor (alarm_clock_id = CLOCK_REALTIME_ALARM;\n\t\t\talarm_clock_id <= CLOCK_BOOTTIME_ALARM;\n\t\t\talarm_clock_id++) {\n\n\t\talarmcount = 0;\n\t\tif (timer_create(alarm_clock_id, &se, &tm1) == -1) {\n\t\t\tprintf(\"timer_create failed, %s unsupported?\\n\",\n\t\t\t\t\tclockstring(alarm_clock_id));\n\t\t\tbreak;\n\t\t}\n\n\t\tclock_gettime(alarm_clock_id, &start_time);\n\t\tprintf(\"Start time (%s): %ld:%ld\\n\", clockstring(alarm_clock_id),\n\t\t\t\tstart_time.tv_sec, start_time.tv_nsec);\n\t\tprintf(\"Setting alarm for every %i seconds\\n\", SUSPEND_SECS);\n\t\tits1.it_value = start_time;\n\t\tits1.it_value.tv_sec += SUSPEND_SECS;\n\t\tits1.it_interval.tv_sec = SUSPEND_SECS;\n\t\tits1.it_interval.tv_nsec = 0;\n\n\t\ttimer_settime(tm1, TIMER_ABSTIME, &its1, &its2);\n\n\t\twhile (alarmcount < 5)\n\t\t\tsleep(1);  \n\n\t\tprintf(\"Starting suspend loops\\n\");\n\t\twhile (alarmcount < 10) {\n\t\t\tint ret;\n\n\t\t\tsleep(3);\n\t\t\tret = system(\"echo mem > /sys/power/state\");\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\ttimer_delete(tm1);\n\t}\n\tif (final_ret)\n\t\treturn ksft_exit_fail();\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}