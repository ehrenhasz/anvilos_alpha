{
  "module_name": "posix_timers.c",
  "hash_id": "d46d63aa654338969b4ac5ad58a38c41accd55c54f1a5ef7fbafb9aa25ac6eb1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/posix_timers.c",
  "human_readable_source": "\n \n\n#include <sys/time.h>\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <pthread.h>\n\n#include \"../kselftest.h\"\n\n#define DELAY 2\n#define USECS_PER_SEC 1000000\n\nstatic volatile int done;\n\n \nstatic void user_loop(void)\n{\n\twhile (!done);\n}\n\n \nstatic void kernel_loop(void)\n{\n\tvoid *addr = sbrk(0);\n\tint err = 0;\n\n\twhile (!done && !err) {\n\t\terr = brk(addr + 4096);\n\t\terr |= brk(addr);\n\t}\n}\n\n \nstatic void idle_loop(void)\n{\n\tpause();\n}\n\nstatic void sig_handler(int nr)\n{\n\tdone = 1;\n}\n\n \nstatic int check_diff(struct timeval start, struct timeval end)\n{\n\tlong long diff;\n\n\tdiff = end.tv_usec - start.tv_usec;\n\tdiff += (end.tv_sec - start.tv_sec) * USECS_PER_SEC;\n\n\tif (abs(diff - DELAY * USECS_PER_SEC) > USECS_PER_SEC / 2) {\n\t\tprintf(\"Diff too high: %lld..\", diff);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_itimer(int which)\n{\n\tint err;\n\tstruct timeval start, end;\n\tstruct itimerval val = {\n\t\t.it_value.tv_sec = DELAY,\n\t};\n\n\tprintf(\"Check itimer \");\n\n\tif (which == ITIMER_VIRTUAL)\n\t\tprintf(\"virtual... \");\n\telse if (which == ITIMER_PROF)\n\t\tprintf(\"prof... \");\n\telse if (which == ITIMER_REAL)\n\t\tprintf(\"real... \");\n\n\tfflush(stdout);\n\n\tdone = 0;\n\n\tif (which == ITIMER_VIRTUAL)\n\t\tsignal(SIGVTALRM, sig_handler);\n\telse if (which == ITIMER_PROF)\n\t\tsignal(SIGPROF, sig_handler);\n\telse if (which == ITIMER_REAL)\n\t\tsignal(SIGALRM, sig_handler);\n\n\terr = gettimeofday(&start, NULL);\n\tif (err < 0) {\n\t\tperror(\"Can't call gettimeofday()\\n\");\n\t\treturn -1;\n\t}\n\n\terr = setitimer(which, &val, NULL);\n\tif (err < 0) {\n\t\tperror(\"Can't set timer\\n\");\n\t\treturn -1;\n\t}\n\n\tif (which == ITIMER_VIRTUAL)\n\t\tuser_loop();\n\telse if (which == ITIMER_PROF)\n\t\tkernel_loop();\n\telse if (which == ITIMER_REAL)\n\t\tidle_loop();\n\n\terr = gettimeofday(&end, NULL);\n\tif (err < 0) {\n\t\tperror(\"Can't call gettimeofday()\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!check_diff(start, end))\n\t\tprintf(\"[OK]\\n\");\n\telse\n\t\tprintf(\"[FAIL]\\n\");\n\n\treturn 0;\n}\n\nstatic int check_timer_create(int which)\n{\n\tint err;\n\ttimer_t id;\n\tstruct timeval start, end;\n\tstruct itimerspec val = {\n\t\t.it_value.tv_sec = DELAY,\n\t};\n\n\tprintf(\"Check timer_create() \");\n\tif (which == CLOCK_THREAD_CPUTIME_ID) {\n\t\tprintf(\"per thread... \");\n\t} else if (which == CLOCK_PROCESS_CPUTIME_ID) {\n\t\tprintf(\"per process... \");\n\t}\n\tfflush(stdout);\n\n\tdone = 0;\n\terr = timer_create(which, NULL, &id);\n\tif (err < 0) {\n\t\tperror(\"Can't create timer\\n\");\n\t\treturn -1;\n\t}\n\tsignal(SIGALRM, sig_handler);\n\n\terr = gettimeofday(&start, NULL);\n\tif (err < 0) {\n\t\tperror(\"Can't call gettimeofday()\\n\");\n\t\treturn -1;\n\t}\n\n\terr = timer_settime(id, 0, &val, NULL);\n\tif (err < 0) {\n\t\tperror(\"Can't set timer\\n\");\n\t\treturn -1;\n\t}\n\n\tuser_loop();\n\n\terr = gettimeofday(&end, NULL);\n\tif (err < 0) {\n\t\tperror(\"Can't call gettimeofday()\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!check_diff(start, end))\n\t\tprintf(\"[OK]\\n\");\n\telse\n\t\tprintf(\"[FAIL]\\n\");\n\n\treturn 0;\n}\n\nint remain;\n__thread int got_signal;\n\nstatic void *distribution_thread(void *arg)\n{\n\twhile (__atomic_load_n(&remain, __ATOMIC_RELAXED));\n\treturn NULL;\n}\n\nstatic void distribution_handler(int nr)\n{\n\tif (!__atomic_exchange_n(&got_signal, 1, __ATOMIC_RELAXED))\n\t\t__atomic_fetch_sub(&remain, 1, __ATOMIC_RELAXED);\n}\n\n \nstatic int check_timer_distribution(void)\n{\n\tint err, i;\n\ttimer_t id;\n\tconst int nthreads = 10;\n\tpthread_t threads[nthreads];\n\tstruct itimerspec val = {\n\t\t.it_value.tv_sec = 0,\n\t\t.it_value.tv_nsec = 1000 * 1000,\n\t\t.it_interval.tv_sec = 0,\n\t\t.it_interval.tv_nsec = 1000 * 1000,\n\t};\n\n\tprintf(\"Check timer_create() per process signal distribution... \");\n\tfflush(stdout);\n\n\tremain = nthreads + 1;   \n\tsignal(SIGALRM, distribution_handler);\n\terr = timer_create(CLOCK_PROCESS_CPUTIME_ID, NULL, &id);\n\tif (err < 0) {\n\t\tperror(\"Can't create timer\\n\");\n\t\treturn -1;\n\t}\n\terr = timer_settime(id, 0, &val, NULL);\n\tif (err < 0) {\n\t\tperror(\"Can't set timer\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < nthreads; i++) {\n\t\tif (pthread_create(&threads[i], NULL, distribution_thread, NULL)) {\n\t\t\tperror(\"Can't create thread\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\twhile (__atomic_load_n(&remain, __ATOMIC_RELAXED));\n\n\tfor (i = 0; i < nthreads; i++) {\n\t\tif (pthread_join(threads[i], NULL)) {\n\t\t\tperror(\"Can't join thread\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (timer_delete(id)) {\n\t\tperror(\"Can't delete timer\\n\");\n\t\treturn -1;\n\t}\n\n\tprintf(\"[OK]\\n\");\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tprintf(\"Testing posix timers. False negative may happen on CPU execution \\n\");\n\tprintf(\"based timers if other threads run on the CPU...\\n\");\n\n\tif (check_itimer(ITIMER_VIRTUAL) < 0)\n\t\treturn ksft_exit_fail();\n\n\tif (check_itimer(ITIMER_PROF) < 0)\n\t\treturn ksft_exit_fail();\n\n\tif (check_itimer(ITIMER_REAL) < 0)\n\t\treturn ksft_exit_fail();\n\n\tif (check_timer_create(CLOCK_THREAD_CPUTIME_ID) < 0)\n\t\treturn ksft_exit_fail();\n\n\t \n\tif (check_timer_create(CLOCK_PROCESS_CPUTIME_ID) < 0)\n\t\treturn ksft_exit_fail();\n\n\tif (check_timer_distribution() < 0)\n\t\treturn ksft_exit_fail();\n\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}