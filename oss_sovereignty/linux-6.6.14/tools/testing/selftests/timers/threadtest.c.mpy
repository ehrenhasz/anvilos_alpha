{
  "module_name": "threadtest.c",
  "hash_id": "80e99945c3812586a4f6160b870e71f4ab73a9b321d674f7fc038fbadef97c03",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/threadtest.c",
  "human_readable_source": " \n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include \"../kselftest.h\"\n\n \npthread_mutex_t list_lock = PTHREAD_MUTEX_INITIALIZER;\n \npthread_mutex_t print_lock = PTHREAD_MUTEX_INITIALIZER;\n\n\n#define MAX_THREADS 128\n#define LISTSIZE 128\n\nint done = 0;\n\nstruct timespec global_list[LISTSIZE];\nint listcount = 0;\n\n\nvoid checklist(struct timespec *list, int size)\n{\n\tint i, j;\n\tstruct timespec *a, *b;\n\n\t \n\tfor (i = 0; i < size-1; i++) {\n\t\ta = &list[i];\n\t\tb = &list[i+1];\n\n\t\t \n\t\tif ((b->tv_sec <= a->tv_sec) &&\n\t\t\t(b->tv_nsec < a->tv_nsec)) {\n\n\t\t\t \n\t\t\tdone = 1;\n\n\t\t\t \n\t\t\tpthread_mutex_lock(&print_lock);\n\n\t\t\t \n\t\t\tprintf(\"\\n\");\n\t\t\tfor (j = 0; j < size; j++) {\n\t\t\t\tif (j == i)\n\t\t\t\t\tprintf(\"---------------\\n\");\n\t\t\t\tprintf(\"%lu:%lu\\n\", list[j].tv_sec, list[j].tv_nsec);\n\t\t\t\tif (j == i+1)\n\t\t\t\t\tprintf(\"---------------\\n\");\n\t\t\t}\n\t\t\tprintf(\"[FAILED]\\n\");\n\n\t\t\tpthread_mutex_unlock(&print_lock);\n\t\t}\n\t}\n}\n\n \nvoid *shared_thread(void *arg)\n{\n\twhile (!done) {\n\t\t \n\t\tpthread_mutex_lock(&list_lock);\n\n\t\t \n\t\tif (listcount >= LISTSIZE) {\n\t\t\tchecklist(global_list, LISTSIZE);\n\t\t\tlistcount = 0;\n\t\t}\n\t\tclock_gettime(CLOCK_MONOTONIC, &global_list[listcount++]);\n\n\t\tpthread_mutex_unlock(&list_lock);\n\t}\n\treturn NULL;\n}\n\n\n \nvoid *independent_thread(void *arg)\n{\n\tstruct timespec my_list[LISTSIZE];\n\tint count;\n\n\twhile (!done) {\n\t\t \n\t\tfor (count = 0; count < LISTSIZE; count++)\n\t\t\tclock_gettime(CLOCK_MONOTONIC, &my_list[count]);\n\t\tchecklist(my_list, LISTSIZE);\n\t}\n\treturn NULL;\n}\n\n#define DEFAULT_THREAD_COUNT 8\n#define DEFAULT_RUNTIME 30\n\nint main(int argc, char **argv)\n{\n\tint thread_count, i;\n\ttime_t start, now, runtime;\n\tchar buf[255];\n\tpthread_t pth[MAX_THREADS];\n\tint opt;\n\tvoid *tret;\n\tint ret = 0;\n\tvoid *(*thread)(void *) = shared_thread;\n\n\tthread_count = DEFAULT_THREAD_COUNT;\n\truntime = DEFAULT_RUNTIME;\n\n\t \n\twhile ((opt = getopt(argc, argv, \"t:n:i\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 't':\n\t\t\truntime = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tthread_count = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tthread = independent_thread;\n\t\t\tprintf(\"using independent threads\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Usage: %s [-t <secs>] [-n <numthreads>] [-i]\\n\", argv[0]);\n\t\t\tprintf(\"\t-t: time to run\\n\");\n\t\t\tprintf(\"\t-n: number of threads\\n\");\n\t\t\tprintf(\"\t-i: use independent threads\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (thread_count > MAX_THREADS)\n\t\tthread_count = MAX_THREADS;\n\n\n\tsetbuf(stdout, NULL);\n\n\tstart = time(0);\n\tstrftime(buf, 255, \"%a, %d %b %Y %T %z\", localtime(&start));\n\tprintf(\"%s\\n\", buf);\n\tprintf(\"Testing consistency with %i threads for %ld seconds: \", thread_count, runtime);\n\tfflush(stdout);\n\n\t \n\tfor (i = 0; i < thread_count; i++)\n\t\tpthread_create(&pth[i], 0, thread, 0);\n\n\twhile (time(&now) < start + runtime) {\n\t\tsleep(1);\n\t\tif (done) {\n\t\t\tret = 1;\n\t\t\tstrftime(buf, 255, \"%a, %d %b %Y %T %z\", localtime(&now));\n\t\t\tprintf(\"%s\\n\", buf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tprintf(\"[OK]\\n\");\n\tdone = 1;\n\nout:\n\t \n\tfor (i = 0; i < thread_count; i++)\n\t\tpthread_join(pth[i], &tret);\n\n\t \n\tif (ret)\n\t\tksft_exit_fail();\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}