{
  "module_name": "nanosleep.c",
  "hash_id": "134b29bbd849fb345f01918ba0820f8c908f79650d5badd2432c8e53941a4fe6",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/nanosleep.c",
  "human_readable_source": " \n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/timex.h>\n#include <string.h>\n#include <signal.h>\n#include \"../kselftest.h\"\n\n#define NSEC_PER_SEC 1000000000ULL\n\n#define CLOCK_REALTIME\t\t\t0\n#define CLOCK_MONOTONIC\t\t\t1\n#define CLOCK_PROCESS_CPUTIME_ID\t2\n#define CLOCK_THREAD_CPUTIME_ID\t\t3\n#define CLOCK_MONOTONIC_RAW\t\t4\n#define CLOCK_REALTIME_COARSE\t\t5\n#define CLOCK_MONOTONIC_COARSE\t\t6\n#define CLOCK_BOOTTIME\t\t\t7\n#define CLOCK_REALTIME_ALARM\t\t8\n#define CLOCK_BOOTTIME_ALARM\t\t9\n#define CLOCK_HWSPECIFIC\t\t10\n#define CLOCK_TAI\t\t\t11\n#define NR_CLOCKIDS\t\t\t12\n\n#define UNSUPPORTED 0xf00f\n\nchar *clockstring(int clockid)\n{\n\tswitch (clockid) {\n\tcase CLOCK_REALTIME:\n\t\treturn \"CLOCK_REALTIME\";\n\tcase CLOCK_MONOTONIC:\n\t\treturn \"CLOCK_MONOTONIC\";\n\tcase CLOCK_PROCESS_CPUTIME_ID:\n\t\treturn \"CLOCK_PROCESS_CPUTIME_ID\";\n\tcase CLOCK_THREAD_CPUTIME_ID:\n\t\treturn \"CLOCK_THREAD_CPUTIME_ID\";\n\tcase CLOCK_MONOTONIC_RAW:\n\t\treturn \"CLOCK_MONOTONIC_RAW\";\n\tcase CLOCK_REALTIME_COARSE:\n\t\treturn \"CLOCK_REALTIME_COARSE\";\n\tcase CLOCK_MONOTONIC_COARSE:\n\t\treturn \"CLOCK_MONOTONIC_COARSE\";\n\tcase CLOCK_BOOTTIME:\n\t\treturn \"CLOCK_BOOTTIME\";\n\tcase CLOCK_REALTIME_ALARM:\n\t\treturn \"CLOCK_REALTIME_ALARM\";\n\tcase CLOCK_BOOTTIME_ALARM:\n\t\treturn \"CLOCK_BOOTTIME_ALARM\";\n\tcase CLOCK_TAI:\n\t\treturn \"CLOCK_TAI\";\n\t};\n\treturn \"UNKNOWN_CLOCKID\";\n}\n\n \nstatic inline int in_order(struct timespec a, struct timespec b)\n{\n\tif (a.tv_sec < b.tv_sec)\n\t\treturn 1;\n\tif (a.tv_sec > b.tv_sec)\n\t\treturn 0;\n\tif (a.tv_nsec > b.tv_nsec)\n\t\treturn 0;\n\treturn 1;\n}\n\nstruct timespec timespec_add(struct timespec ts, unsigned long long ns)\n{\n\tts.tv_nsec += ns;\n\twhile (ts.tv_nsec >= NSEC_PER_SEC) {\n\t\tts.tv_nsec -= NSEC_PER_SEC;\n\t\tts.tv_sec++;\n\t}\n\treturn ts;\n}\n\nint nanosleep_test(int clockid, long long ns)\n{\n\tstruct timespec now, target, rel;\n\n\t \n\tif (clock_gettime(clockid, &now))\n\t\treturn UNSUPPORTED;\n\ttarget = timespec_add(now, ns);\n\n\tif (clock_nanosleep(clockid, TIMER_ABSTIME, &target, NULL))\n\t\treturn UNSUPPORTED;\n\tclock_gettime(clockid, &now);\n\n\tif (!in_order(target, now))\n\t\treturn -1;\n\n\t \n\tclock_gettime(clockid, &now);\n\trel.tv_sec = 0;\n\trel.tv_nsec = 0;\n\trel = timespec_add(rel, ns);\n\ttarget = timespec_add(now, ns);\n\tclock_nanosleep(clockid, 0, &rel, NULL);\n\tclock_gettime(clockid, &now);\n\n\tif (!in_order(target, now))\n\t\treturn -1;\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tlong long length;\n\tint clockid, ret;\n\n\tksft_print_header();\n\tksft_set_plan(NR_CLOCKIDS);\n\n\tfor (clockid = CLOCK_REALTIME; clockid < NR_CLOCKIDS; clockid++) {\n\n\t\t \n\t\tif (clockid == CLOCK_PROCESS_CPUTIME_ID ||\n\t\t\t\tclockid == CLOCK_THREAD_CPUTIME_ID ||\n\t\t\t\tclockid == CLOCK_HWSPECIFIC) {\n\t\t\tksft_test_result_skip(\"%-31s\\n\", clockstring(clockid));\n\t\t\tcontinue;\n\t\t}\n\n\t\tfflush(stdout);\n\n\t\tlength = 10;\n\t\twhile (length <= (NSEC_PER_SEC * 10)) {\n\t\t\tret = nanosleep_test(clockid, length);\n\t\t\tif (ret == UNSUPPORTED) {\n\t\t\t\tksft_test_result_skip(\"%-31s\\n\", clockstring(clockid));\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (ret < 0) {\n\t\t\t\tksft_test_result_fail(\"%-31s\\n\", clockstring(clockid));\n\t\t\t\tksft_exit_fail();\n\t\t\t}\n\t\t\tlength *= 100;\n\t\t}\n\t\tksft_test_result_pass(\"%-31s\\n\", clockstring(clockid));\nnext:\n\t\tret = 0;\n\t}\n\tksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}