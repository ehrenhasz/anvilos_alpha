{
  "module_name": "raw_skew.c",
  "hash_id": "50be3b9baf4f27bd5f425401de9e240a8f540d244f6695b9e83f72f1ab2c5fe2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/raw_skew.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/timex.h>\n#include <time.h>\n#include \"../kselftest.h\"\n\n#define CLOCK_MONOTONIC_RAW\t\t4\n#define NSEC_PER_SEC 1000000000LL\n\n#define shift_right(x, s) ({\t\t\\\n\t__typeof__(x) __x = (x);\t\\\n\t__typeof__(s) __s = (s);\t\\\n\t__x < 0 ? -(-__x >> __s) : __x >> __s; \\\n})\n\nlong long llabs(long long val)\n{\n\tif (val < 0)\n\t\tval = -val;\n\treturn val;\n}\n\nunsigned long long ts_to_nsec(struct timespec ts)\n{\n\treturn ts.tv_sec * NSEC_PER_SEC + ts.tv_nsec;\n}\n\nstruct timespec nsec_to_ts(long long ns)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = ns/NSEC_PER_SEC;\n\tts.tv_nsec = ns%NSEC_PER_SEC;\n\treturn ts;\n}\n\nlong long diff_timespec(struct timespec start, struct timespec end)\n{\n\tlong long start_ns, end_ns;\n\n\tstart_ns = ts_to_nsec(start);\n\tend_ns = ts_to_nsec(end);\n\treturn end_ns - start_ns;\n}\n\nvoid get_monotonic_and_raw(struct timespec *mon, struct timespec *raw)\n{\n\tstruct timespec start, mid, end;\n\tlong long diff = 0, tmp;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tlong long newdiff;\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &start);\n\t\tclock_gettime(CLOCK_MONOTONIC_RAW, &mid);\n\t\tclock_gettime(CLOCK_MONOTONIC, &end);\n\n\t\tnewdiff = diff_timespec(start, end);\n\t\tif (diff == 0 || newdiff < diff) {\n\t\t\tdiff = newdiff;\n\t\t\t*raw = mid;\n\t\t\ttmp = (ts_to_nsec(start) + ts_to_nsec(end))/2;\n\t\t\t*mon = nsec_to_ts(tmp);\n\t\t}\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tstruct timespec mon, raw, start, end;\n\tlong long delta1, delta2, interval, eppm, ppm;\n\tstruct timex tx1, tx2;\n\n\tsetbuf(stdout, NULL);\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &raw)) {\n\t\tprintf(\"ERR: NO CLOCK_MONOTONIC_RAW\\n\");\n\t\treturn -1;\n\t}\n\n\ttx1.modes = 0;\n\tadjtimex(&tx1);\n\tget_monotonic_and_raw(&mon, &raw);\n\tstart = mon;\n\tdelta1 = diff_timespec(mon, raw);\n\n\tif (tx1.offset)\n\t\tprintf(\"WARNING: ADJ_OFFSET in progress, this will cause inaccurate results\\n\");\n\n\tprintf(\"Estimating clock drift: \");\n\tfflush(stdout);\n\tsleep(120);\n\n\tget_monotonic_and_raw(&mon, &raw);\n\tend = mon;\n\ttx2.modes = 0;\n\tadjtimex(&tx2);\n\tdelta2 = diff_timespec(mon, raw);\n\n\tinterval = diff_timespec(start, end);\n\n\t \n\teppm = ((delta2-delta1)*NSEC_PER_SEC)/interval;\n\teppm = -eppm;\n\tprintf(\"%lld.%i(est)\", eppm/1000, abs((int)(eppm%1000)));\n\n\t \n\tppm = (long long)(tx1.freq + tx2.freq) * 1000 / 2;\n\tppm = shift_right(ppm, 16);\n\tprintf(\" %lld.%i(act)\", ppm/1000, abs((int)(ppm%1000)));\n\n\tif (llabs(eppm - ppm) > 1000) {\n\t\tif (tx1.offset || tx2.offset ||\n\t\t    tx1.freq != tx2.freq || tx1.tick != tx2.tick) {\n\t\t\tprintf(\"\t[SKIP]\\n\");\n\t\t\treturn ksft_exit_skip(\"The clock was adjusted externally. Shutdown NTPd or other time sync daemons\\n\");\n\t\t}\n\t\tprintf(\"\t[FAILED]\\n\");\n\t\treturn ksft_exit_fail();\n\t}\n\tprintf(\"\t[OK]\\n\");\n\treturn  ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}