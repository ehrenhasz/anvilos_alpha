{
  "module_name": "clocksource-switch.c",
  "hash_id": "9e3e6e1890d7462d3528d92bfa69465b28808f3c05c2e5ccbc0eeb4d49608850",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/clocksource-switch.c",
  "human_readable_source": " \n\n\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/timex.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include \"../kselftest.h\"\n\n\nint get_clocksources(char list[][30])\n{\n\tint fd, i;\n\tsize_t size;\n\tchar buf[512];\n\tchar *head, *tmp;\n\n\tfd = open(\"/sys/devices/system/clocksource/clocksource0/available_clocksource\", O_RDONLY);\n\n\tsize = read(fd, buf, 512);\n\n\tclose(fd);\n\n\tfor (i = 0; i < 10; i++)\n\t\tlist[i][0] = '\\0';\n\n\thead = buf;\n\ti = 0;\n\twhile (head - buf < size) {\n\t\t \n\t\tfor (tmp = head; *tmp != ' '; tmp++) {\n\t\t\tif (*tmp == '\\n')\n\t\t\t\tbreak;\n\t\t\tif (*tmp == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\t*tmp = '\\0';\n\t\tstrcpy(list[i], head);\n\t\thead = tmp + 1;\n\t\ti++;\n\t}\n\n\treturn i-1;\n}\n\nint get_cur_clocksource(char *buf, size_t size)\n{\n\tint fd;\n\n\tfd = open(\"/sys/devices/system/clocksource/clocksource0/current_clocksource\", O_RDONLY);\n\n\tsize = read(fd, buf, size);\n\n\treturn 0;\n}\n\nint change_clocksource(char *clocksource)\n{\n\tint fd;\n\tssize_t size;\n\n\tfd = open(\"/sys/devices/system/clocksource/clocksource0/current_clocksource\", O_WRONLY);\n\n\tif (fd < 0)\n\t\treturn -1;\n\n\tsize = write(fd, clocksource, strlen(clocksource));\n\n\tif (size < 0)\n\t\treturn -1;\n\n\tclose(fd);\n\treturn 0;\n}\n\n\nint run_tests(int secs)\n{\n\tint ret;\n\tchar buf[255];\n\n\tsprintf(buf, \"./inconsistency-check -t %i\", secs);\n\tret = system(buf);\n\tif (WIFEXITED(ret) && WEXITSTATUS(ret))\n\t\treturn WEXITSTATUS(ret);\n\tret = system(\"./nanosleep\");\n\treturn WIFEXITED(ret) ? WEXITSTATUS(ret) : 0;\n}\n\n\nchar clocksource_list[10][30];\n\nint main(int argc, char **argv)\n{\n\tchar orig_clk[512];\n\tint count, i, status, opt;\n\tint do_sanity_check = 1;\n\tint runtime = 60;\n\tpid_t pid;\n\n\t \n\twhile ((opt = getopt(argc, argv, \"st:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\tdo_sanity_check = 0;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\truntime = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Usage: %s [-s] [-t <secs>]\\n\", argv[0]);\n\t\t\tprintf(\"\t-s: skip sanity checks\\n\");\n\t\t\tprintf(\"\t-t: Number of seconds to run\\n\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\tget_cur_clocksource(orig_clk, 512);\n\n\tcount = get_clocksources(clocksource_list);\n\n\tif (change_clocksource(clocksource_list[0])) {\n\t\tprintf(\"Error: You probably need to run this as root\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (do_sanity_check) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tprintf(\"Validating clocksource %s\\n\",\n\t\t\t\tclocksource_list[i]);\n\t\t\tif (change_clocksource(clocksource_list[i])) {\n\t\t\t\tstatus = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (run_tests(5)) {\n\t\t\t\tstatus = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"Running Asynchronous Switching Tests...\\n\");\n\tpid = fork();\n\tif (!pid)\n\t\treturn run_tests(runtime);\n\n\twhile (pid != waitpid(pid, &status, WNOHANG))\n\t\tfor (i = 0; i < count; i++)\n\t\t\tif (change_clocksource(clocksource_list[i])) {\n\t\t\t\tstatus = -1;\n\t\t\t\tgoto out;\n\t\t\t}\nout:\n\tchange_clocksource(orig_clk);\n\n\t \n\tksft_print_header();\n\tksft_set_plan(1);\n\tksft_test_result(!status, \"clocksource-switch\\n\");\n\tksft_exit(!status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}