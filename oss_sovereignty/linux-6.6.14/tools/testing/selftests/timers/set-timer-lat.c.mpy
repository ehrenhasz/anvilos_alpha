{
  "module_name": "set-timer-lat.c",
  "hash_id": "de065e8ade0d9792dd133cc86f933e7f9a26406338ffff310b28ad2eaf53aa37",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/set-timer-lat.c",
  "human_readable_source": " \n\n\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include \"../kselftest.h\"\n\n#define CLOCK_REALTIME\t\t\t0\n#define CLOCK_MONOTONIC\t\t\t1\n#define CLOCK_PROCESS_CPUTIME_ID\t2\n#define CLOCK_THREAD_CPUTIME_ID\t\t3\n#define CLOCK_MONOTONIC_RAW\t\t4\n#define CLOCK_REALTIME_COARSE\t\t5\n#define CLOCK_MONOTONIC_COARSE\t\t6\n#define CLOCK_BOOTTIME\t\t\t7\n#define CLOCK_REALTIME_ALARM\t\t8\n#define CLOCK_BOOTTIME_ALARM\t\t9\n#define CLOCK_HWSPECIFIC\t\t10\n#define CLOCK_TAI\t\t\t11\n#define NR_CLOCKIDS\t\t\t12\n\n\n#define NSEC_PER_SEC 1000000000ULL\n#define UNRESONABLE_LATENCY 40000000  \n\n#define TIMER_SECS 1\nint alarmcount;\nint clock_id;\nstruct timespec start_time;\nlong long max_latency_ns;\nint timer_fired_early;\n\nchar *clockstring(int clockid)\n{\n\tswitch (clockid) {\n\tcase CLOCK_REALTIME:\n\t\treturn \"CLOCK_REALTIME\";\n\tcase CLOCK_MONOTONIC:\n\t\treturn \"CLOCK_MONOTONIC\";\n\tcase CLOCK_PROCESS_CPUTIME_ID:\n\t\treturn \"CLOCK_PROCESS_CPUTIME_ID\";\n\tcase CLOCK_THREAD_CPUTIME_ID:\n\t\treturn \"CLOCK_THREAD_CPUTIME_ID\";\n\tcase CLOCK_MONOTONIC_RAW:\n\t\treturn \"CLOCK_MONOTONIC_RAW\";\n\tcase CLOCK_REALTIME_COARSE:\n\t\treturn \"CLOCK_REALTIME_COARSE\";\n\tcase CLOCK_MONOTONIC_COARSE:\n\t\treturn \"CLOCK_MONOTONIC_COARSE\";\n\tcase CLOCK_BOOTTIME:\n\t\treturn \"CLOCK_BOOTTIME\";\n\tcase CLOCK_REALTIME_ALARM:\n\t\treturn \"CLOCK_REALTIME_ALARM\";\n\tcase CLOCK_BOOTTIME_ALARM:\n\t\treturn \"CLOCK_BOOTTIME_ALARM\";\n\tcase CLOCK_TAI:\n\t\treturn \"CLOCK_TAI\";\n\t};\n\treturn \"UNKNOWN_CLOCKID\";\n}\n\n\nlong long timespec_sub(struct timespec a, struct timespec b)\n{\n\tlong long ret = NSEC_PER_SEC * b.tv_sec + b.tv_nsec;\n\n\tret -= NSEC_PER_SEC * a.tv_sec + a.tv_nsec;\n\treturn ret;\n}\n\n\nvoid sigalarm(int signo)\n{\n\tlong long delta_ns;\n\tstruct timespec ts;\n\n\tclock_gettime(clock_id, &ts);\n\talarmcount++;\n\n\tdelta_ns = timespec_sub(start_time, ts);\n\tdelta_ns -= NSEC_PER_SEC * TIMER_SECS * alarmcount;\n\n\tif (delta_ns < 0)\n\t\ttimer_fired_early = 1;\n\n\tif (delta_ns > max_latency_ns)\n\t\tmax_latency_ns = delta_ns;\n}\n\nvoid describe_timer(int flags, int interval)\n{\n\tprintf(\"%-22s %s %s \",\n\t\t\tclockstring(clock_id),\n\t\t\tflags ? \"ABSTIME\":\"RELTIME\",\n\t\t\tinterval ? \"PERIODIC\":\"ONE-SHOT\");\n}\n\nint setup_timer(int clock_id, int flags, int interval, timer_t *tm1)\n{\n\tstruct sigevent se;\n\tstruct itimerspec its1, its2;\n\tint err;\n\n\t \n\tmemset(&se, 0, sizeof(se));\n\tse.sigev_notify = SIGEV_SIGNAL;\n\tse.sigev_signo = SIGRTMAX;\n\tse.sigev_value.sival_int = 0;\n\n\tmax_latency_ns = 0;\n\talarmcount = 0;\n\ttimer_fired_early = 0;\n\n\terr = timer_create(clock_id, &se, tm1);\n\tif (err) {\n\t\tif ((clock_id == CLOCK_REALTIME_ALARM) ||\n\t\t    (clock_id == CLOCK_BOOTTIME_ALARM)) {\n\t\t\tprintf(\"%-22s %s missing CAP_WAKE_ALARM?    : [UNSUPPORTED]\\n\",\n\t\t\t\t\tclockstring(clock_id),\n\t\t\t\t\tflags ? \"ABSTIME\":\"RELTIME\");\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\t\tprintf(\"%s - timer_create() failed\\n\", clockstring(clock_id));\n\t\treturn -1;\n\t}\n\n\tclock_gettime(clock_id, &start_time);\n\tif (flags) {\n\t\tits1.it_value = start_time;\n\t\tits1.it_value.tv_sec += TIMER_SECS;\n\t} else {\n\t\tits1.it_value.tv_sec = TIMER_SECS;\n\t\tits1.it_value.tv_nsec = 0;\n\t}\n\tits1.it_interval.tv_sec = interval;\n\tits1.it_interval.tv_nsec = 0;\n\n\terr = timer_settime(*tm1, flags, &its1, &its2);\n\tif (err) {\n\t\tprintf(\"%s - timer_settime() failed\\n\", clockstring(clock_id));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint check_timer_latency(int flags, int interval)\n{\n\tint err = 0;\n\n\tdescribe_timer(flags, interval);\n\tprintf(\"timer fired early: %7d : \", timer_fired_early);\n\tif (!timer_fired_early) {\n\t\tprintf(\"[OK]\\n\");\n\t} else {\n\t\tprintf(\"[FAILED]\\n\");\n\t\terr = -1;\n\t}\n\n\tdescribe_timer(flags, interval);\n\tprintf(\"max latency: %10lld ns : \", max_latency_ns);\n\n\tif (max_latency_ns < UNRESONABLE_LATENCY) {\n\t\tprintf(\"[OK]\\n\");\n\t} else {\n\t\tprintf(\"[FAILED]\\n\");\n\t\terr = -1;\n\t}\n\treturn err;\n}\n\nint check_alarmcount(int flags, int interval)\n{\n\tdescribe_timer(flags, interval);\n\tprintf(\"count: %19d : \", alarmcount);\n\tif (alarmcount == 1) {\n\t\tprintf(\"[OK]\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"[FAILED]\\n\");\n\treturn -1;\n}\n\nint do_timer(int clock_id, int flags)\n{\n\ttimer_t tm1;\n\tconst int interval = TIMER_SECS;\n\tint err;\n\n\terr = setup_timer(clock_id, flags, interval, &tm1);\n\t \n\tif (err)\n\t\treturn err == 1 ? 0 : err;\n\n\twhile (alarmcount < 5)\n\t\tsleep(1);\n\n\ttimer_delete(tm1);\n\treturn check_timer_latency(flags, interval);\n}\n\nint do_timer_oneshot(int clock_id, int flags)\n{\n\ttimer_t tm1;\n\tconst int interval = 0;\n\tstruct timeval timeout;\n\tint err;\n\n\terr = setup_timer(clock_id, flags, interval, &tm1);\n\t \n\tif (err)\n\t\treturn err == 1 ? 0 : err;\n\n\tmemset(&timeout, 0, sizeof(timeout));\n\ttimeout.tv_sec = 5;\n\tdo {\n\t\terr = select(0, NULL, NULL, NULL, &timeout);\n\t} while (err == -1 && errno == EINTR);\n\n\ttimer_delete(tm1);\n\terr = check_timer_latency(flags, interval);\n\terr |= check_alarmcount(flags, interval);\n\treturn err;\n}\n\nint main(void)\n{\n\tstruct sigaction act;\n\tint signum = SIGRTMAX;\n\tint ret = 0;\n\n\t \n\tsigfillset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = sigalarm;\n\tsigaction(signum, &act, NULL);\n\n\tprintf(\"Setting timers for every %i seconds\\n\", TIMER_SECS);\n\tfor (clock_id = 0; clock_id < NR_CLOCKIDS; clock_id++) {\n\n\t\tif ((clock_id == CLOCK_PROCESS_CPUTIME_ID) ||\n\t\t\t\t(clock_id == CLOCK_THREAD_CPUTIME_ID) ||\n\t\t\t\t(clock_id == CLOCK_MONOTONIC_RAW) ||\n\t\t\t\t(clock_id == CLOCK_REALTIME_COARSE) ||\n\t\t\t\t(clock_id == CLOCK_MONOTONIC_COARSE) ||\n\t\t\t\t(clock_id == CLOCK_HWSPECIFIC))\n\t\t\tcontinue;\n\n\t\tret |= do_timer(clock_id, TIMER_ABSTIME);\n\t\tret |= do_timer(clock_id, 0);\n\t\tret |= do_timer_oneshot(clock_id, TIMER_ABSTIME);\n\t\tret |= do_timer_oneshot(clock_id, 0);\n\t}\n\tif (ret)\n\t\treturn ksft_exit_fail();\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}