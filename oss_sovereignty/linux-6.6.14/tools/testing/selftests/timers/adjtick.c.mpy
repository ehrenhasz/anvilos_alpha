{
  "module_name": "adjtick.c",
  "hash_id": "70cd5debd10023a1d880e08310b28af45e071cf13d12d1ba71b05703ae0debf0",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/adjtick.c",
  "human_readable_source": " \n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/timex.h>\n#include <time.h>\n\n#include \"../kselftest.h\"\n\n#define CLOCK_MONOTONIC_RAW\t4\n\n#define NSEC_PER_SEC\t\t1000000000LL\n#define USEC_PER_SEC\t\t1000000\n\n#define MILLION\t\t\t1000000\n\nlong systick;\n\nlong long llabs(long long val)\n{\n\tif (val < 0)\n\t\tval = -val;\n\treturn val;\n}\n\nunsigned long long ts_to_nsec(struct timespec ts)\n{\n\treturn ts.tv_sec * NSEC_PER_SEC + ts.tv_nsec;\n}\n\nstruct timespec nsec_to_ts(long long ns)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = ns/NSEC_PER_SEC;\n\tts.tv_nsec = ns%NSEC_PER_SEC;\n\n\treturn ts;\n}\n\nlong long diff_timespec(struct timespec start, struct timespec end)\n{\n\tlong long start_ns, end_ns;\n\n\tstart_ns = ts_to_nsec(start);\n\tend_ns = ts_to_nsec(end);\n\n\treturn end_ns - start_ns;\n}\n\nvoid get_monotonic_and_raw(struct timespec *mon, struct timespec *raw)\n{\n\tstruct timespec start, mid, end;\n\tlong long diff = 0, tmp;\n\tint i;\n\n\tclock_gettime(CLOCK_MONOTONIC, mon);\n\tclock_gettime(CLOCK_MONOTONIC_RAW, raw);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tlong long newdiff;\n\n\t\tclock_gettime(CLOCK_MONOTONIC, &start);\n\t\tclock_gettime(CLOCK_MONOTONIC_RAW, &mid);\n\t\tclock_gettime(CLOCK_MONOTONIC, &end);\n\n\t\tnewdiff = diff_timespec(start, end);\n\t\tif (diff == 0 || newdiff < diff) {\n\t\t\tdiff = newdiff;\n\t\t\t*raw = mid;\n\t\t\ttmp = (ts_to_nsec(start) + ts_to_nsec(end))/2;\n\t\t\t*mon = nsec_to_ts(tmp);\n\t\t}\n\t}\n}\n\nlong long get_ppm_drift(void)\n{\n\tstruct timespec mon_start, raw_start, mon_end, raw_end;\n\tlong long delta1, delta2, eppm;\n\n\tget_monotonic_and_raw(&mon_start, &raw_start);\n\n\tsleep(15);\n\n\tget_monotonic_and_raw(&mon_end, &raw_end);\n\n\tdelta1 = diff_timespec(mon_start, mon_end);\n\tdelta2 = diff_timespec(raw_start, raw_end);\n\n\teppm = (delta1*MILLION)/delta2 - MILLION;\n\n\treturn eppm;\n}\n\nint check_tick_adj(long tickval)\n{\n\tlong long eppm, ppm;\n\tstruct timex tx1;\n\n\ttx1.modes\t = ADJ_TICK;\n\ttx1.modes\t|= ADJ_OFFSET;\n\ttx1.modes\t|= ADJ_FREQUENCY;\n\ttx1.modes\t|= ADJ_STATUS;\n\n\ttx1.status\t= STA_PLL;\n\ttx1.offset\t= 0;\n\ttx1.freq\t= 0;\n\ttx1.tick\t= tickval;\n\n\tadjtimex(&tx1);\n\n\tsleep(1);\n\n\tppm = ((long long)tickval * MILLION)/systick - MILLION;\n\tprintf(\"Estimating tick (act: %ld usec, %lld ppm): \", tickval, ppm);\n\n\teppm = get_ppm_drift();\n\tprintf(\"%lld usec, %lld ppm\", systick + (systick * eppm / MILLION), eppm);\n\tfflush(stdout);\n\n\ttx1.modes = 0;\n\tadjtimex(&tx1);\n\n\tif (tx1.offset || tx1.freq || tx1.tick != tickval) {\n\t\tprintf(\"\t[ERROR]\\n\");\n\t\tprintf(\"\\tUnexpected adjtimex return values, make sure ntpd is not running.\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (llabs(eppm - ppm) > 100) {\n\t\tprintf(\"\t[FAILED]\\n\");\n\t\treturn -1;\n\t}\n\tprintf(\"\t[OK]\\n\");\n\n\treturn  0;\n}\n\nint main(int argc, char **argv)\n{\n\tstruct timespec raw;\n\tlong tick, max, interval, err;\n\tstruct timex tx1;\n\n\terr = 0;\n\tsetbuf(stdout, NULL);\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &raw)) {\n\t\tprintf(\"ERR: NO CLOCK_MONOTONIC_RAW\\n\");\n\t\treturn -1;\n\t}\n\n\tprintf(\"Each iteration takes about 15 seconds\\n\");\n\n\tsystick = sysconf(_SC_CLK_TCK);\n\tsystick = USEC_PER_SEC/sysconf(_SC_CLK_TCK);\n\tmax = systick/10;  \n\tinterval = max/4;  \n\n\tfor (tick = (systick - max); tick < (systick + max); tick += interval) {\n\t\tif (check_tick_adj(tick)) {\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\ttx1.modes\t = ADJ_TICK;\n\ttx1.modes\t|= ADJ_OFFSET;\n\ttx1.modes\t|= ADJ_FREQUENCY;\n\n\ttx1.offset\t = 0;\n\ttx1.freq\t = 0;\n\ttx1.tick\t = systick;\n\n\tadjtimex(&tx1);\n\n\tif (err)\n\t\treturn ksft_exit_fail();\n\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}