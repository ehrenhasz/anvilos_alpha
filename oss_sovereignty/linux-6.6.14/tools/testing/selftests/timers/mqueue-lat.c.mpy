{
  "module_name": "mqueue-lat.c",
  "hash_id": "554d8089dea12b9b6a946e158db8133aa8b0ea5246ea45bb2f7771b1760396c5",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/mqueue-lat.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/timex.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <mqueue.h>\n#include \"../kselftest.h\"\n\n#define NSEC_PER_SEC 1000000000ULL\n\n#define TARGET_TIMEOUT\t\t100000000\t \n#define UNRESONABLE_LATENCY\t40000000\t \n\n\nlong long timespec_sub(struct timespec a, struct timespec b)\n{\n\tlong long ret = NSEC_PER_SEC * b.tv_sec + b.tv_nsec;\n\n\tret -= NSEC_PER_SEC * a.tv_sec + a.tv_nsec;\n\treturn ret;\n}\n\nstruct timespec timespec_add(struct timespec ts, unsigned long long ns)\n{\n\tts.tv_nsec += ns;\n\twhile (ts.tv_nsec >= NSEC_PER_SEC) {\n\t\tts.tv_nsec -= NSEC_PER_SEC;\n\t\tts.tv_sec++;\n\t}\n\treturn ts;\n}\n\nint mqueue_lat_test(void)\n{\n\n\tmqd_t q;\n\tstruct mq_attr attr;\n\tstruct timespec start, end, now, target;\n\tint i, count, ret;\n\n\tq = mq_open(\"/foo\", O_CREAT | O_RDONLY, 0666, NULL);\n\tif (q < 0) {\n\t\tperror(\"mq_open\");\n\t\treturn -1;\n\t}\n\tmq_getattr(q, &attr);\n\n\n\tcount = 100;\n\tclock_gettime(CLOCK_MONOTONIC, &start);\n\n\tfor (i = 0; i < count; i++) {\n\t\tchar buf[attr.mq_msgsize];\n\n\t\tclock_gettime(CLOCK_REALTIME, &now);\n\t\ttarget = now;\n\t\ttarget = timespec_add(now, TARGET_TIMEOUT);  \n\n\t\tret = mq_timedreceive(q, buf, sizeof(buf), NULL, &target);\n\t\tif (ret < 0 && errno != ETIMEDOUT) {\n\t\t\tperror(\"mq_timedreceive\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tclock_gettime(CLOCK_MONOTONIC, &end);\n\n\tmq_close(q);\n\n\tif ((timespec_sub(start, end)/count) > TARGET_TIMEOUT + UNRESONABLE_LATENCY)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint ret;\n\n\tprintf(\"Mqueue latency :                          \");\n\tfflush(stdout);\n\n\tret = mqueue_lat_test();\n\tif (ret < 0) {\n\t\tprintf(\"[FAILED]\\n\");\n\t\treturn ksft_exit_fail();\n\t}\n\tprintf(\"[OK]\\n\");\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}