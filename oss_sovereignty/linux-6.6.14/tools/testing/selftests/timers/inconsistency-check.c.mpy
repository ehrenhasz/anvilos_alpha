{
  "module_name": "inconsistency-check.c",
  "hash_id": "22547a5fbddcd0ba45423f197b2516326ad3df82217e226aeaf6bb29e3d84398",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/inconsistency-check.c",
  "human_readable_source": " \n\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/timex.h>\n#include <string.h>\n#include <signal.h>\n#include \"../kselftest.h\"\n\n#define CALLS_PER_LOOP 64\n#define NSEC_PER_SEC 1000000000ULL\n\n#define CLOCK_REALTIME\t\t\t0\n#define CLOCK_MONOTONIC\t\t\t1\n#define CLOCK_PROCESS_CPUTIME_ID\t2\n#define CLOCK_THREAD_CPUTIME_ID\t\t3\n#define CLOCK_MONOTONIC_RAW\t\t4\n#define CLOCK_REALTIME_COARSE\t\t5\n#define CLOCK_MONOTONIC_COARSE\t\t6\n#define CLOCK_BOOTTIME\t\t\t7\n#define CLOCK_REALTIME_ALARM\t\t8\n#define CLOCK_BOOTTIME_ALARM\t\t9\n#define CLOCK_HWSPECIFIC\t\t10\n#define CLOCK_TAI\t\t\t11\n#define NR_CLOCKIDS\t\t\t12\n\nchar *clockstring(int clockid)\n{\n\tswitch (clockid) {\n\tcase CLOCK_REALTIME:\n\t\treturn \"CLOCK_REALTIME\";\n\tcase CLOCK_MONOTONIC:\n\t\treturn \"CLOCK_MONOTONIC\";\n\tcase CLOCK_PROCESS_CPUTIME_ID:\n\t\treturn \"CLOCK_PROCESS_CPUTIME_ID\";\n\tcase CLOCK_THREAD_CPUTIME_ID:\n\t\treturn \"CLOCK_THREAD_CPUTIME_ID\";\n\tcase CLOCK_MONOTONIC_RAW:\n\t\treturn \"CLOCK_MONOTONIC_RAW\";\n\tcase CLOCK_REALTIME_COARSE:\n\t\treturn \"CLOCK_REALTIME_COARSE\";\n\tcase CLOCK_MONOTONIC_COARSE:\n\t\treturn \"CLOCK_MONOTONIC_COARSE\";\n\tcase CLOCK_BOOTTIME:\n\t\treturn \"CLOCK_BOOTTIME\";\n\tcase CLOCK_REALTIME_ALARM:\n\t\treturn \"CLOCK_REALTIME_ALARM\";\n\tcase CLOCK_BOOTTIME_ALARM:\n\t\treturn \"CLOCK_BOOTTIME_ALARM\";\n\tcase CLOCK_TAI:\n\t\treturn \"CLOCK_TAI\";\n\t}\n\treturn \"UNKNOWN_CLOCKID\";\n}\n\n \nstatic inline int in_order(struct timespec a, struct timespec b)\n{\n\t \n\tif ((unsigned long)a.tv_sec < (unsigned long)b.tv_sec)\n\t\treturn 1;\n\tif ((unsigned long)a.tv_sec > (unsigned long)b.tv_sec)\n\t\treturn 0;\n\tif (a.tv_nsec > b.tv_nsec)\n\t\treturn 0;\n\treturn 1;\n}\n\n\n\nint consistency_test(int clock_type, unsigned long seconds)\n{\n\tstruct timespec list[CALLS_PER_LOOP];\n\tint i, inconsistent;\n\tlong now, then;\n\ttime_t t;\n\tchar *start_str;\n\n\tclock_gettime(clock_type, &list[0]);\n\tnow = then = list[0].tv_sec;\n\n\t \n\tt = time(0);\n\tstart_str = ctime(&t);\n\n\twhile (seconds == -1 || now - then < seconds) {\n\t\tinconsistent = -1;\n\n\t\t \n\t\tfor (i = 0; i < CALLS_PER_LOOP; i++)\n\t\t\tclock_gettime(clock_type, &list[i]);\n\n\t\t \n\t\tfor (i = 0; i < CALLS_PER_LOOP - 1; i++)\n\t\t\tif (!in_order(list[i], list[i+1]))\n\t\t\t\tinconsistent = i;\n\n\t\t \n\t\tif (inconsistent >= 0) {\n\t\t\tunsigned long long delta;\n\n\t\t\tksft_print_msg(\"\\%s\\n\", start_str);\n\t\t\tfor (i = 0; i < CALLS_PER_LOOP; i++) {\n\t\t\t\tif (i == inconsistent)\n\t\t\t\t\tksft_print_msg(\"--------------------\\n\");\n\t\t\t\tksft_print_msg(\"%lu:%lu\\n\", list[i].tv_sec,\n\t\t\t\t\t\t\tlist[i].tv_nsec);\n\t\t\t\tif (i == inconsistent + 1)\n\t\t\t\t\tksft_print_msg(\"--------------------\\n\");\n\t\t\t}\n\t\t\tdelta = list[inconsistent].tv_sec * NSEC_PER_SEC;\n\t\t\tdelta += list[inconsistent].tv_nsec;\n\t\t\tdelta -= list[inconsistent+1].tv_sec * NSEC_PER_SEC;\n\t\t\tdelta -= list[inconsistent+1].tv_nsec;\n\t\t\tksft_print_msg(\"Delta: %llu ns\\n\", delta);\n\t\t\tfflush(0);\n\t\t\t \n\t\t\tt = time(0);\n\t\t\tksft_print_msg(\"%s\\n\", ctime(&t));\n\t\t\treturn -1;\n\t\t}\n\t\tnow = list[0].tv_sec;\n\t}\n\treturn 0;\n}\n\n\nint main(int argc, char *argv[])\n{\n\tint clockid, opt;\n\tint userclock = CLOCK_REALTIME;\n\tint maxclocks = NR_CLOCKIDS;\n\tint runtime = 10;\n\tstruct timespec ts;\n\n\t \n\twhile ((opt = getopt(argc, argv, \"t:c:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 't':\n\t\t\truntime = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tuserclock = atoi(optarg);\n\t\t\tmaxclocks = userclock + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Usage: %s [-t <secs>] [-c <clockid>]\\n\", argv[0]);\n\t\t\tprintf(\"\t-t: Number of seconds to run\\n\");\n\t\t\tprintf(\"\t-c: clockid to use (default, all clockids)\\n\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\tsetbuf(stdout, NULL);\n\n\tksft_print_header();\n\tksft_set_plan(maxclocks - userclock);\n\n\tfor (clockid = userclock; clockid < maxclocks; clockid++) {\n\n\t\tif (clockid == CLOCK_HWSPECIFIC || clock_gettime(clockid, &ts)) {\n\t\t\tksft_test_result_skip(\"%-31s\\n\", clockstring(clockid));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (consistency_test(clockid, runtime)) {\n\t\t\tksft_test_result_fail(\"%-31s\\n\", clockstring(clockid));\n\t\t\tksft_exit_fail();\n\t\t} else {\n\t\t\tksft_test_result_pass(\"%-31s\\n\", clockstring(clockid));\n\t\t}\n\t}\n\tksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}