{
  "module_name": "freq-step.c",
  "hash_id": "2fb52bafda8a4a6d1430a0b7b4c879871efca02e6606ab57e25a54b5db8d8533",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/timers/freq-step.c",
  "human_readable_source": "\n \n\n#include <math.h>\n#include <stdio.h>\n#include <sys/timex.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"../kselftest.h\"\n\n#define SAMPLES 100\n#define SAMPLE_READINGS 10\n#define MEAN_SAMPLE_INTERVAL 0.1\n#define STEP_INTERVAL 1.0\n#define MAX_PRECISION 500e-9\n#define MAX_FREQ_ERROR 0.02e-6\n#define MAX_STDDEV 50e-9\n\n#ifndef ADJ_SETOFFSET\n  #define ADJ_SETOFFSET 0x0100\n#endif\n\nstruct sample {\n\tdouble offset;\n\tdouble time;\n};\n\nstatic time_t mono_raw_base;\nstatic time_t mono_base;\nstatic long user_hz;\nstatic double precision;\nstatic double mono_freq_offset;\n\nstatic double diff_timespec(struct timespec *ts1, struct timespec *ts2)\n{\n\treturn ts1->tv_sec - ts2->tv_sec + (ts1->tv_nsec - ts2->tv_nsec) / 1e9;\n}\n\nstatic double get_sample(struct sample *sample)\n{\n\tdouble delay, mindelay = 0.0;\n\tstruct timespec ts1, ts2, ts3;\n\tint i;\n\n\tfor (i = 0; i < SAMPLE_READINGS; i++) {\n\t\tclock_gettime(CLOCK_MONOTONIC_RAW, &ts1);\n\t\tclock_gettime(CLOCK_MONOTONIC, &ts2);\n\t\tclock_gettime(CLOCK_MONOTONIC_RAW, &ts3);\n\n\t\tts1.tv_sec -= mono_raw_base;\n\t\tts2.tv_sec -= mono_base;\n\t\tts3.tv_sec -= mono_raw_base;\n\n\t\tdelay = diff_timespec(&ts3, &ts1);\n\t\tif (delay <= 1e-9) {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!i || delay < mindelay) {\n\t\t\tsample->offset = diff_timespec(&ts2, &ts1);\n\t\t\tsample->offset -= delay / 2.0;\n\t\t\tsample->time = ts1.tv_sec + ts1.tv_nsec / 1e9;\n\t\t\tmindelay = delay;\n\t\t}\n\t}\n\n\treturn mindelay;\n}\n\nstatic void reset_ntp_error(void)\n{\n\tstruct timex txc;\n\n\ttxc.modes = ADJ_SETOFFSET;\n\ttxc.time.tv_sec = 0;\n\ttxc.time.tv_usec = 0;\n\n\tif (adjtimex(&txc) < 0) {\n\t\tperror(\"[FAIL] adjtimex\");\n\t\tksft_exit_fail();\n\t}\n}\n\nstatic void set_frequency(double freq)\n{\n\tstruct timex txc;\n\tint tick_offset;\n\n\ttick_offset = 1e6 * freq / user_hz;\n\n\ttxc.modes = ADJ_TICK | ADJ_FREQUENCY;\n\ttxc.tick = 1000000 / user_hz + tick_offset;\n\ttxc.freq = (1e6 * freq - user_hz * tick_offset) * (1 << 16);\n\n\tif (adjtimex(&txc) < 0) {\n\t\tperror(\"[FAIL] adjtimex\");\n\t\tksft_exit_fail();\n\t}\n}\n\nstatic void regress(struct sample *samples, int n, double *intercept,\n\t\t    double *slope, double *r_stddev, double *r_max)\n{\n\tdouble x, y, r, x_sum, y_sum, xy_sum, x2_sum, r2_sum;\n\tint i;\n\n\tx_sum = 0.0, y_sum = 0.0, xy_sum = 0.0, x2_sum = 0.0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tx = samples[i].time;\n\t\ty = samples[i].offset;\n\n\t\tx_sum += x;\n\t\ty_sum += y;\n\t\txy_sum += x * y;\n\t\tx2_sum += x * x;\n\t}\n\n\t*slope = (xy_sum - x_sum * y_sum / n) / (x2_sum - x_sum * x_sum / n);\n\t*intercept = (y_sum - *slope * x_sum) / n;\n\n\t*r_max = 0.0, r2_sum = 0.0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tx = samples[i].time;\n\t\ty = samples[i].offset;\n\t\tr = fabs(x * *slope + *intercept - y);\n\t\tif (*r_max < r)\n\t\t\t*r_max = r;\n\t\tr2_sum += r * r;\n\t}\n\n\t*r_stddev = sqrt(r2_sum / n);\n}\n\nstatic int run_test(int calibration, double freq_base, double freq_step)\n{\n\tstruct sample samples[SAMPLES];\n\tdouble intercept, slope, stddev1, max1, stddev2, max2;\n\tdouble freq_error1, freq_error2;\n\tint i;\n\n\tset_frequency(freq_base);\n\n\tfor (i = 0; i < 10; i++)\n\t\tusleep(1e6 * MEAN_SAMPLE_INTERVAL / 10);\n\n\treset_ntp_error();\n\n\tset_frequency(freq_base + freq_step);\n\n\tfor (i = 0; i < 10; i++)\n\t\tusleep(rand() % 2000000 * STEP_INTERVAL / 10);\n\n\tset_frequency(freq_base);\n\n\tfor (i = 0; i < SAMPLES; i++) {\n\t\tusleep(rand() % 2000000 * MEAN_SAMPLE_INTERVAL);\n\t\tget_sample(&samples[i]);\n\t}\n\n\tif (calibration) {\n\t\tregress(samples, SAMPLES, &intercept, &slope, &stddev1, &max1);\n\t\tmono_freq_offset = slope;\n\t\tprintf(\"CLOCK_MONOTONIC_RAW frequency offset: %11.3f ppm\\n\",\n\t\t       1e6 * mono_freq_offset);\n\t\treturn 0;\n\t}\n\n\tregress(samples, SAMPLES / 2, &intercept, &slope, &stddev1, &max1);\n\tfreq_error1 = slope * (1.0 - mono_freq_offset) - mono_freq_offset -\n\t\t\tfreq_base;\n\n\tregress(samples + SAMPLES / 2, SAMPLES / 2, &intercept, &slope,\n\t\t&stddev2, &max2);\n\tfreq_error2 = slope * (1.0 - mono_freq_offset) - mono_freq_offset -\n\t\t\tfreq_base;\n\n\tprintf(\"%6.0f %+10.3f %6.0f %7.0f %+10.3f %6.0f %7.0f\\t\",\n\t       1e6 * freq_step,\n\t       1e6 * freq_error1, 1e9 * stddev1, 1e9 * max1,\n\t       1e6 * freq_error2, 1e9 * stddev2, 1e9 * max2);\n\n\tif (fabs(freq_error2) > MAX_FREQ_ERROR || stddev2 > MAX_STDDEV) {\n\t\tprintf(\"[FAIL]\\n\");\n\t\treturn 1;\n\t}\n\n\tprintf(\"[OK]\\n\");\n\treturn 0;\n}\n\nstatic void init_test(void)\n{\n\tstruct timespec ts;\n\tstruct sample sample;\n\n\tif (clock_gettime(CLOCK_MONOTONIC_RAW, &ts)) {\n\t\tperror(\"[FAIL] clock_gettime(CLOCK_MONOTONIC_RAW)\");\n\t\tksft_exit_fail();\n\t}\n\n\tmono_raw_base = ts.tv_sec;\n\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts)) {\n\t\tperror(\"[FAIL] clock_gettime(CLOCK_MONOTONIC)\");\n\t\tksft_exit_fail();\n\t}\n\n\tmono_base = ts.tv_sec;\n\n\tuser_hz = sysconf(_SC_CLK_TCK);\n\n\tprecision = get_sample(&sample) / 2.0;\n\tprintf(\"CLOCK_MONOTONIC_RAW+CLOCK_MONOTONIC precision: %.0f ns\\t\\t\",\n\t       1e9 * precision);\n\n\tif (precision > MAX_PRECISION)\n\t\tksft_exit_skip(\"precision: %.0f ns > MAX_PRECISION: %.0f ns\\n\",\n\t\t\t\t1e9 * precision, 1e9 * MAX_PRECISION);\n\n\tprintf(\"[OK]\\n\");\n\tsrand(ts.tv_sec ^ ts.tv_nsec);\n\n\trun_test(1, 0.0, 0.0);\n}\n\nint main(int argc, char **argv)\n{\n\tdouble freq_base, freq_step;\n\tint i, j, fails = 0;\n\n\tinit_test();\n\n\tprintf(\"Checking response to frequency step:\\n\");\n\tprintf(\"  Step           1st interval              2nd interval\\n\");\n\tprintf(\"             Freq    Dev     Max       Freq    Dev     Max\\n\");\n\n\tfor (i = 2; i >= 0; i--) {\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tfreq_base = (rand() % (1 << 24) - (1 << 23)) / 65536e6;\n\t\t\tfreq_step = 10e-6 * (1 << (6 * i));\n\t\t\tfails += run_test(0, freq_base, freq_step);\n\t\t}\n\t}\n\n\tset_frequency(0.0);\n\n\tif (fails)\n\t\treturn ksft_exit_fail();\n\n\treturn ksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}