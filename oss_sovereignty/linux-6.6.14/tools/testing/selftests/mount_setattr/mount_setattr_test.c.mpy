{
  "module_name": "mount_setattr_test.c",
  "hash_id": "333044e56fe4799db40dbc8977fa5a09076854aff836b63e927e7e4b736094b2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/mount_setattr/mount_setattr_test.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <errno.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <sys/wait.h>\n#include <sys/vfs.h>\n#include <sys/statvfs.h>\n#include <sys/sysinfo.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <linux/mount.h>\n\n#include \"../kselftest_harness.h\"\n\n#ifndef CLONE_NEWNS\n#define CLONE_NEWNS 0x00020000\n#endif\n\n#ifndef CLONE_NEWUSER\n#define CLONE_NEWUSER 0x10000000\n#endif\n\n#ifndef MS_REC\n#define MS_REC 16384\n#endif\n\n#ifndef MS_RELATIME\n#define MS_RELATIME (1 << 21)\n#endif\n\n#ifndef MS_STRICTATIME\n#define MS_STRICTATIME (1 << 24)\n#endif\n\n#ifndef MOUNT_ATTR_RDONLY\n#define MOUNT_ATTR_RDONLY 0x00000001\n#endif\n\n#ifndef MOUNT_ATTR_NOSUID\n#define MOUNT_ATTR_NOSUID 0x00000002\n#endif\n\n#ifndef MOUNT_ATTR_NOEXEC\n#define MOUNT_ATTR_NOEXEC 0x00000008\n#endif\n\n#ifndef MOUNT_ATTR_NODIRATIME\n#define MOUNT_ATTR_NODIRATIME 0x00000080\n#endif\n\n#ifndef MOUNT_ATTR__ATIME\n#define MOUNT_ATTR__ATIME 0x00000070\n#endif\n\n#ifndef MOUNT_ATTR_RELATIME\n#define MOUNT_ATTR_RELATIME 0x00000000\n#endif\n\n#ifndef MOUNT_ATTR_NOATIME\n#define MOUNT_ATTR_NOATIME 0x00000010\n#endif\n\n#ifndef MOUNT_ATTR_STRICTATIME\n#define MOUNT_ATTR_STRICTATIME 0x00000020\n#endif\n\n#ifndef AT_RECURSIVE\n#define AT_RECURSIVE 0x8000\n#endif\n\n#ifndef MS_SHARED\n#define MS_SHARED (1 << 20)\n#endif\n\n#define DEFAULT_THREADS 4\n#define ptr_to_int(p) ((int)((intptr_t)(p)))\n#define int_to_ptr(u) ((void *)((intptr_t)(u)))\n\n#ifndef __NR_mount_setattr\n\t#if defined __alpha__\n\t\t#define __NR_mount_setattr 552\n\t#elif defined _MIPS_SIM\n\t\t#if _MIPS_SIM == _MIPS_SIM_ABI32\t \n\t\t\t#define __NR_mount_setattr (442 + 4000)\n\t\t#endif\n\t\t#if _MIPS_SIM == _MIPS_SIM_NABI32\t \n\t\t\t#define __NR_mount_setattr (442 + 6000)\n\t\t#endif\n\t\t#if _MIPS_SIM == _MIPS_SIM_ABI64\t \n\t\t\t#define __NR_mount_setattr (442 + 5000)\n\t\t#endif\n\t#elif defined __ia64__\n\t\t#define __NR_mount_setattr (442 + 1024)\n\t#else\n\t\t#define __NR_mount_setattr 442\n\t#endif\n#endif\n\n#ifndef __NR_open_tree\n\t#if defined __alpha__\n\t\t#define __NR_open_tree 538\n\t#elif defined _MIPS_SIM\n\t\t#if _MIPS_SIM == _MIPS_SIM_ABI32\t \n\t\t\t#define __NR_open_tree 4428\n\t\t#endif\n\t\t#if _MIPS_SIM == _MIPS_SIM_NABI32\t \n\t\t\t#define __NR_open_tree 6428\n\t\t#endif\n\t\t#if _MIPS_SIM == _MIPS_SIM_ABI64\t \n\t\t\t#define __NR_open_tree 5428\n\t\t#endif\n\t#elif defined __ia64__\n\t\t#define __NR_open_tree (428 + 1024)\n\t#else\n\t\t#define __NR_open_tree 428\n\t#endif\n#endif\n\n#ifndef MOUNT_ATTR_IDMAP\n#define MOUNT_ATTR_IDMAP 0x00100000\n#endif\n\n#ifndef MOUNT_ATTR_NOSYMFOLLOW\n#define MOUNT_ATTR_NOSYMFOLLOW 0x00200000\n#endif\n\nstatic inline int sys_mount_setattr(int dfd, const char *path, unsigned int flags,\n\t\t\t\t    struct mount_attr *attr, size_t size)\n{\n\treturn syscall(__NR_mount_setattr, dfd, path, flags, attr, size);\n}\n\n#ifndef OPEN_TREE_CLONE\n#define OPEN_TREE_CLONE 1\n#endif\n\n#ifndef OPEN_TREE_CLOEXEC\n#define OPEN_TREE_CLOEXEC O_CLOEXEC\n#endif\n\n#ifndef AT_RECURSIVE\n#define AT_RECURSIVE 0x8000  \n#endif\n\nstatic inline int sys_open_tree(int dfd, const char *filename, unsigned int flags)\n{\n\treturn syscall(__NR_open_tree, dfd, filename, flags);\n}\n\nstatic ssize_t write_nointr(int fd, const void *buf, size_t count)\n{\n\tssize_t ret;\n\n\tdo {\n\t\tret = write(fd, buf, count);\n\t} while (ret < 0 && errno == EINTR);\n\n\treturn ret;\n}\n\nstatic int write_file(const char *path, const void *buf, size_t count)\n{\n\tint fd;\n\tssize_t ret;\n\n\tfd = open(path, O_WRONLY | O_CLOEXEC | O_NOCTTY | O_NOFOLLOW);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tret = write_nointr(fd, buf, count);\n\tclose(fd);\n\tif (ret < 0 || (size_t)ret != count)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int create_and_enter_userns(void)\n{\n\tuid_t uid;\n\tgid_t gid;\n\tchar map[100];\n\n\tuid = getuid();\n\tgid = getgid();\n\n\tif (unshare(CLONE_NEWUSER))\n\t\treturn -1;\n\n\tif (write_file(\"/proc/self/setgroups\", \"deny\", sizeof(\"deny\") - 1) &&\n\t    errno != ENOENT)\n\t\treturn -1;\n\n\tsnprintf(map, sizeof(map), \"0 %d 1\", uid);\n\tif (write_file(\"/proc/self/uid_map\", map, strlen(map)))\n\t\treturn -1;\n\n\n\tsnprintf(map, sizeof(map), \"0 %d 1\", gid);\n\tif (write_file(\"/proc/self/gid_map\", map, strlen(map)))\n\t\treturn -1;\n\n\tif (setgid(0))\n\t\treturn -1;\n\n\tif (setuid(0))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int prepare_unpriv_mountns(void)\n{\n\tif (create_and_enter_userns())\n\t\treturn -1;\n\n\tif (unshare(CLONE_NEWNS))\n\t\treturn -1;\n\n\tif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, 0))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n#ifndef ST_NOSYMFOLLOW\n#define ST_NOSYMFOLLOW 0x2000  \n#endif\n\nstatic int read_mnt_flags(const char *path)\n{\n\tint ret;\n\tstruct statvfs stat;\n\tunsigned int mnt_flags;\n\n\tret = statvfs(path, &stat);\n\tif (ret != 0)\n\t\treturn -EINVAL;\n\n\tif (stat.f_flag & ~(ST_RDONLY | ST_NOSUID | ST_NODEV | ST_NOEXEC |\n\t\t\t    ST_NOATIME | ST_NODIRATIME | ST_RELATIME |\n\t\t\t    ST_SYNCHRONOUS | ST_MANDLOCK | ST_NOSYMFOLLOW))\n\t\treturn -EINVAL;\n\n\tmnt_flags = 0;\n\tif (stat.f_flag & ST_RDONLY)\n\t\tmnt_flags |= MS_RDONLY;\n\tif (stat.f_flag & ST_NOSUID)\n\t\tmnt_flags |= MS_NOSUID;\n\tif (stat.f_flag & ST_NODEV)\n\t\tmnt_flags |= MS_NODEV;\n\tif (stat.f_flag & ST_NOEXEC)\n\t\tmnt_flags |= MS_NOEXEC;\n\tif (stat.f_flag & ST_NOATIME)\n\t\tmnt_flags |= MS_NOATIME;\n\tif (stat.f_flag & ST_NODIRATIME)\n\t\tmnt_flags |= MS_NODIRATIME;\n\tif (stat.f_flag & ST_RELATIME)\n\t\tmnt_flags |= MS_RELATIME;\n\tif (stat.f_flag & ST_SYNCHRONOUS)\n\t\tmnt_flags |= MS_SYNCHRONOUS;\n\tif (stat.f_flag & ST_MANDLOCK)\n\t\tmnt_flags |= ST_MANDLOCK;\n\tif (stat.f_flag & ST_NOSYMFOLLOW)\n\t\tmnt_flags |= ST_NOSYMFOLLOW;\n\n\treturn mnt_flags;\n}\n\nstatic char *get_field(char *src, int nfields)\n{\n\tint i;\n\tchar *p = src;\n\n\tfor (i = 0; i < nfields; i++) {\n\t\twhile (*p && *p != ' ' && *p != '\\t')\n\t\t\tp++;\n\n\t\tif (!*p)\n\t\t\tbreak;\n\n\t\tp++;\n\t}\n\n\treturn p;\n}\n\nstatic void null_endofword(char *word)\n{\n\twhile (*word && *word != ' ' && *word != '\\t')\n\t\tword++;\n\t*word = '\\0';\n}\n\nstatic bool is_shared_mount(const char *path)\n{\n\tsize_t len = 0;\n\tchar *line = NULL;\n\tFILE *f = NULL;\n\n\tf = fopen(\"/proc/self/mountinfo\", \"re\");\n\tif (!f)\n\t\treturn false;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *opts, *target;\n\n\t\ttarget = get_field(line, 4);\n\t\tif (!target)\n\t\t\tcontinue;\n\n\t\topts = get_field(target, 2);\n\t\tif (!opts)\n\t\t\tcontinue;\n\n\t\tnull_endofword(target);\n\n\t\tif (strcmp(target, path) != 0)\n\t\t\tcontinue;\n\n\t\tnull_endofword(opts);\n\t\tif (strstr(opts, \"shared:\"))\n\t\t\treturn true;\n\t}\n\n\tfree(line);\n\tfclose(f);\n\n\treturn false;\n}\n\nstatic void *mount_setattr_thread(void *data)\n{\n\tstruct mount_attr attr = {\n\t\t.attr_set\t= MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOSUID,\n\t\t.attr_clr\t= 0,\n\t\t.propagation\t= MS_SHARED,\n\t};\n\n\tif (sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)))\n\t\tpthread_exit(int_to_ptr(-1));\n\n\tpthread_exit(int_to_ptr(0));\n}\n\n \n#ifndef SKIP\n#define SKIP(s, ...)\tXFAIL(s, ##__VA_ARGS__)\n#endif\n\nstatic bool mount_setattr_supported(void)\n{\n\tint ret;\n\n\tret = sys_mount_setattr(-EBADF, \"\", AT_EMPTY_PATH, NULL, 0);\n\tif (ret < 0 && errno == ENOSYS)\n\t\treturn false;\n\n\treturn true;\n}\n\nFIXTURE(mount_setattr) {\n};\n\n#define NOSYMFOLLOW_TARGET \"/mnt/A/AA/data\"\n#define NOSYMFOLLOW_SYMLINK \"/mnt/A/AA/symlink\"\n\nFIXTURE_SETUP(mount_setattr)\n{\n\tint fd = -EBADF;\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tASSERT_EQ(prepare_unpriv_mountns(), 0);\n\n\t(void)umount2(\"/mnt\", MNT_DETACH);\n\t(void)umount2(\"/tmp\", MNT_DETACH);\n\n\tASSERT_EQ(mount(\"testing\", \"/tmp\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mkdir(\"/tmp/B\", 0777), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/tmp/B\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mkdir(\"/tmp/B/BB\", 0777), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/tmp/B/BB\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/mnt\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mkdir(\"/mnt/A\", 0777), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/mnt/A\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mkdir(\"/mnt/A/AA\", 0777), 0);\n\n\tASSERT_EQ(mount(\"/tmp\", \"/mnt/A/AA\", NULL, MS_BIND | MS_REC, NULL), 0);\n\n\tASSERT_EQ(mkdir(\"/mnt/B\", 0777), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/mnt/B\", \"ramfs\",\n\t\t\tMS_NOATIME | MS_NODEV | MS_NOSUID, 0), 0);\n\n\tASSERT_EQ(mkdir(\"/mnt/B/BB\", 0777), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/tmp/B/BB\", \"devpts\",\n\t\t\tMS_RELATIME | MS_NOEXEC | MS_RDONLY, 0), 0);\n\n\tfd = creat(NOSYMFOLLOW_TARGET, O_RDWR | O_CLOEXEC);\n\tASSERT_GT(fd, 0);\n\tASSERT_EQ(symlink(NOSYMFOLLOW_TARGET, NOSYMFOLLOW_SYMLINK), 0);\n\tASSERT_EQ(close(fd), 0);\n}\n\nFIXTURE_TEARDOWN(mount_setattr)\n{\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\t(void)umount2(\"/mnt/A\", MNT_DETACH);\n\t(void)umount2(\"/tmp\", MNT_DETACH);\n}\n\nTEST_F(mount_setattr, invalid_attributes)\n{\n\tstruct mount_attr invalid_attr = {\n\t\t.attr_set = (1U << 31),\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &invalid_attr,\n\t\t\t\t    sizeof(invalid_attr)), 0);\n\n\tinvalid_attr.attr_set\t= 0;\n\tinvalid_attr.attr_clr\t= (1U << 31);\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &invalid_attr,\n\t\t\t\t    sizeof(invalid_attr)), 0);\n\n\tinvalid_attr.attr_clr\t\t= 0;\n\tinvalid_attr.propagation\t= (1U << 31);\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &invalid_attr,\n\t\t\t\t    sizeof(invalid_attr)), 0);\n\n\tinvalid_attr.attr_set\t\t= (1U << 31);\n\tinvalid_attr.attr_clr\t\t= (1U << 31);\n\tinvalid_attr.propagation\t= (1U << 31);\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &invalid_attr,\n\t\t\t\t    sizeof(invalid_attr)), 0);\n\n\tASSERT_NE(sys_mount_setattr(-1, \"mnt/A\", AT_RECURSIVE, &invalid_attr,\n\t\t\t\t    sizeof(invalid_attr)), 0);\n}\n\nTEST_F(mount_setattr, extensibility)\n{\n\tunsigned int old_flags = 0, new_flags = 0, expected_flags = 0;\n\tchar *s = \"dummy\";\n\tstruct mount_attr invalid_attr = {};\n\tstruct mount_attr_large {\n\t\tstruct mount_attr attr1;\n\t\tstruct mount_attr attr2;\n\t\tstruct mount_attr attr3;\n\t} large_attr = {};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\told_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_GT(old_flags, 0);\n\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, NULL,\n\t\t\t\t    sizeof(invalid_attr)), 0);\n\tASSERT_EQ(errno, EFAULT);\n\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, (void *)s,\n\t\t\t\t    sizeof(invalid_attr)), 0);\n\tASSERT_EQ(errno, EINVAL);\n\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &invalid_attr, 0), 0);\n\tASSERT_EQ(errno, EINVAL);\n\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &invalid_attr,\n\t\t\t\t    sizeof(invalid_attr) / 2), 0);\n\tASSERT_EQ(errno, EINVAL);\n\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &invalid_attr,\n\t\t\t\t    sizeof(invalid_attr) / 2), 0);\n\tASSERT_EQ(errno, EINVAL);\n\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE,\n\t\t\t\t    (void *)&large_attr, sizeof(large_attr)), 0);\n\n\tlarge_attr.attr3.attr_set = MOUNT_ATTR_RDONLY;\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE,\n\t\t\t\t    (void *)&large_attr, sizeof(large_attr)), 0);\n\n\tlarge_attr.attr3.attr_set = 0;\n\tlarge_attr.attr1.attr_set = MOUNT_ATTR_RDONLY;\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE,\n\t\t\t\t    (void *)&large_attr, sizeof(large_attr)), 0);\n\n\texpected_flags = old_flags;\n\texpected_flags |= MS_RDONLY;\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n}\n\nTEST_F(mount_setattr, basic)\n{\n\tunsigned int old_flags = 0, new_flags = 0, expected_flags = 0;\n\tstruct mount_attr attr = {\n\t\t.attr_set\t= MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOEXEC | MOUNT_ATTR_RELATIME,\n\t\t.attr_clr\t= MOUNT_ATTR__ATIME,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\told_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_GT(old_flags, 0);\n\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", 0, &attr, sizeof(attr)), 0);\n\n\texpected_flags = old_flags;\n\texpected_flags |= MS_RDONLY;\n\texpected_flags |= MS_NOEXEC;\n\texpected_flags &= ~MS_NOATIME;\n\texpected_flags |= MS_RELATIME;\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, old_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, old_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, old_flags);\n}\n\nTEST_F(mount_setattr, basic_recursive)\n{\n\tint fd;\n\tunsigned int old_flags = 0, new_flags = 0, expected_flags = 0;\n\tstruct mount_attr attr = {\n\t\t.attr_set\t= MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOEXEC | MOUNT_ATTR_RELATIME,\n\t\t.attr_clr\t= MOUNT_ATTR__ATIME,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\told_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_GT(old_flags, 0);\n\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags = old_flags;\n\texpected_flags |= MS_RDONLY;\n\texpected_flags |= MS_NOEXEC;\n\texpected_flags &= ~MS_NOATIME;\n\texpected_flags |= MS_RELATIME;\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.attr_clr = MOUNT_ATTR_RDONLY;\n\tattr.propagation = MS_SHARED;\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags &= ~MS_RDONLY;\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A\"), true);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA\"), true);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA/B\"), true);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA/B/BB\"), true);\n\n\tfd = open(\"/mnt/A/AA/B/b\", O_RDWR | O_CLOEXEC | O_CREAT | O_EXCL, 0777);\n\tASSERT_GE(fd, 0);\n\n\t \n\tattr.attr_set = MOUNT_ATTR_RDONLY;\n\tASSERT_LT(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A\"), true);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA\"), true);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA/B\"), true);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA/B/BB\"), true);\n\n\tEXPECT_EQ(close(fd), 0);\n}\n\nTEST_F(mount_setattr, mount_has_writers)\n{\n\tint fd, dfd;\n\tunsigned int old_flags = 0, new_flags = 0;\n\tstruct mount_attr attr = {\n\t\t.attr_set\t= MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOEXEC | MOUNT_ATTR_RELATIME,\n\t\t.attr_clr\t= MOUNT_ATTR__ATIME,\n\t\t.propagation\t= MS_SHARED,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\told_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_GT(old_flags, 0);\n\n\tfd = open(\"/mnt/A/AA/B/b\", O_RDWR | O_CLOEXEC | O_CREAT | O_EXCL, 0777);\n\tASSERT_GE(fd, 0);\n\n\t \n\tASSERT_LT(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, old_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A\"), false);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, old_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA\"), false);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, old_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA/B\"), false);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, old_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA/B/BB\"), false);\n\n\tdfd = open(\"/mnt/A/AA/B\", O_DIRECTORY | O_CLOEXEC);\n\tASSERT_GE(dfd, 0);\n\tEXPECT_EQ(fsync(dfd), 0);\n\tEXPECT_EQ(close(dfd), 0);\n\n\tEXPECT_EQ(fsync(fd), 0);\n\tEXPECT_EQ(close(fd), 0);\n\n\t \n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n}\n\nTEST_F(mount_setattr, mixed_mount_options)\n{\n\tunsigned int old_flags1 = 0, old_flags2 = 0, new_flags = 0, expected_flags = 0;\n\tstruct mount_attr attr = {\n\t\t.attr_clr = MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOSUID | MOUNT_ATTR_NOEXEC | MOUNT_ATTR__ATIME,\n\t\t.attr_set = MOUNT_ATTR_RELATIME,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\told_flags1 = read_mnt_flags(\"/mnt/B\");\n\tASSERT_GT(old_flags1, 0);\n\n\told_flags2 = read_mnt_flags(\"/mnt/B/BB\");\n\tASSERT_GT(old_flags2, 0);\n\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/B\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags = old_flags2;\n\texpected_flags &= ~(MS_RDONLY | MS_NOEXEC | MS_NOATIME | MS_NOSUID);\n\texpected_flags |= MS_RELATIME;\n\n\tnew_flags = read_mnt_flags(\"/mnt/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\texpected_flags = old_flags2;\n\texpected_flags &= ~(MS_RDONLY | MS_NOEXEC | MS_NOATIME | MS_NOSUID);\n\texpected_flags |= MS_RELATIME;\n\n\tnew_flags = read_mnt_flags(\"/mnt/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n}\n\nTEST_F(mount_setattr, time_changes)\n{\n\tunsigned int old_flags = 0, new_flags = 0, expected_flags = 0;\n\tstruct mount_attr attr = {\n\t\t.attr_set\t= MOUNT_ATTR_NODIRATIME | MOUNT_ATTR_NOATIME,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\tattr.attr_set = MOUNT_ATTR_STRICTATIME;\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\tattr.attr_set = MOUNT_ATTR_STRICTATIME | MOUNT_ATTR_NOATIME;\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\tattr.attr_set = MOUNT_ATTR_STRICTATIME | MOUNT_ATTR_NOATIME;\n\tattr.attr_clr = MOUNT_ATTR__ATIME;\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\tattr.attr_set = 0;\n\tattr.attr_clr = MOUNT_ATTR_STRICTATIME;\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\tattr.attr_clr = MOUNT_ATTR_NOATIME;\n\tASSERT_NE(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\told_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_GT(old_flags, 0);\n\n\tattr.attr_set = MOUNT_ATTR_NODIRATIME | MOUNT_ATTR_NOATIME;\n\tattr.attr_clr = MOUNT_ATTR__ATIME;\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags = old_flags;\n\texpected_flags |= MS_NOATIME;\n\texpected_flags |= MS_NODIRATIME;\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.attr_set &= ~MOUNT_ATTR_NOATIME;\n\tattr.attr_set |= MOUNT_ATTR_RELATIME;\n\tattr.attr_clr |= MOUNT_ATTR__ATIME;\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags &= ~MS_NOATIME;\n\texpected_flags |= MS_RELATIME;\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.attr_set &= ~MOUNT_ATTR_RELATIME;\n\tattr.attr_set |= MOUNT_ATTR_STRICTATIME;\n\tattr.attr_clr |= MOUNT_ATTR__ATIME;\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags &= ~MS_RELATIME;\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.attr_set &= ~MOUNT_ATTR_STRICTATIME;\n\tattr.attr_set |= MOUNT_ATTR_NOATIME;\n\tattr.attr_clr |= MOUNT_ATTR__ATIME;\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags |= MS_NOATIME;\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tmemset(&attr, 0, sizeof(attr));\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.attr_clr = MOUNT_ATTR_NODIRATIME;\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags &= ~MS_NODIRATIME;\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n}\n\nTEST_F(mount_setattr, multi_threaded)\n{\n\tint i, j, nthreads, ret = 0;\n\tunsigned int old_flags = 0, new_flags = 0, expected_flags = 0;\n\tpthread_attr_t pattr;\n\tpthread_t threads[DEFAULT_THREADS];\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\told_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_GT(old_flags, 0);\n\n\t \n\tnthreads = get_nprocs_conf();\n\tif (nthreads > DEFAULT_THREADS)\n\t\tnthreads = DEFAULT_THREADS;\n\n\tpthread_attr_init(&pattr);\n\tfor (i = 0; i < nthreads; i++)\n\t\tASSERT_EQ(pthread_create(&threads[i], &pattr, mount_setattr_thread, NULL), 0);\n\n\tfor (j = 0; j < i; j++) {\n\t\tvoid *retptr = NULL;\n\n\t\tEXPECT_EQ(pthread_join(threads[j], &retptr), 0);\n\n\t\tret += ptr_to_int(retptr);\n\t\tEXPECT_EQ(ret, 0);\n\t}\n\tpthread_attr_destroy(&pattr);\n\n\tASSERT_EQ(ret, 0);\n\n\texpected_flags = old_flags;\n\texpected_flags |= MS_RDONLY;\n\texpected_flags |= MS_NOSUID;\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A\"), true);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA\"), true);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA/B\"), true);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tASSERT_EQ(is_shared_mount(\"/mnt/A/AA/B/BB\"), true);\n}\n\nTEST_F(mount_setattr, wrong_user_namespace)\n{\n\tint ret;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_RDONLY,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tEXPECT_EQ(create_and_enter_userns(), 0);\n\tret = sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr));\n\tASSERT_LT(ret, 0);\n\tASSERT_EQ(errno, EPERM);\n}\n\nTEST_F(mount_setattr, wrong_mount_namespace)\n{\n\tint fd, ret;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_RDONLY,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tfd = open(\"/mnt/A\", O_DIRECTORY | O_CLOEXEC);\n\tASSERT_GE(fd, 0);\n\n\tASSERT_EQ(unshare(CLONE_NEWNS), 0);\n\n\tret = sys_mount_setattr(fd, \"\", AT_EMPTY_PATH | AT_RECURSIVE, &attr, sizeof(attr));\n\tASSERT_LT(ret, 0);\n\tASSERT_EQ(errno, EINVAL);\n}\n\nFIXTURE(mount_setattr_idmapped) {\n};\n\nFIXTURE_SETUP(mount_setattr_idmapped)\n{\n\tint img_fd = -EBADF;\n\n\tASSERT_EQ(unshare(CLONE_NEWNS), 0);\n\n\tASSERT_EQ(mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, 0), 0);\n\n\t(void)umount2(\"/mnt\", MNT_DETACH);\n\t(void)umount2(\"/tmp\", MNT_DETACH);\n\n\tASSERT_EQ(mount(\"testing\", \"/tmp\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mkdir(\"/tmp/B\", 0777), 0);\n\tASSERT_EQ(mknodat(-EBADF, \"/tmp/B/b\", S_IFREG | 0644, 0), 0);\n\tASSERT_EQ(chown(\"/tmp/B/b\", 0, 0), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/tmp/B\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mkdir(\"/tmp/B/BB\", 0777), 0);\n\tASSERT_EQ(mknodat(-EBADF, \"/tmp/B/BB/b\", S_IFREG | 0644, 0), 0);\n\tASSERT_EQ(chown(\"/tmp/B/BB/b\", 0, 0), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/tmp/B/BB\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/mnt\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mkdir(\"/mnt/A\", 0777), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/mnt/A\", \"tmpfs\", MS_NOATIME | MS_NODEV,\n\t\t\t\"size=100000,mode=700\"), 0);\n\n\tASSERT_EQ(mkdir(\"/mnt/A/AA\", 0777), 0);\n\n\tASSERT_EQ(mount(\"/tmp\", \"/mnt/A/AA\", NULL, MS_BIND | MS_REC, NULL), 0);\n\n\tASSERT_EQ(mkdir(\"/mnt/B\", 0777), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/mnt/B\", \"ramfs\",\n\t\t\tMS_NOATIME | MS_NODEV | MS_NOSUID, 0), 0);\n\n\tASSERT_EQ(mkdir(\"/mnt/B/BB\", 0777), 0);\n\n\tASSERT_EQ(mount(\"testing\", \"/tmp/B/BB\", \"devpts\",\n\t\t\tMS_RELATIME | MS_NOEXEC | MS_RDONLY, 0), 0);\n\n\tASSERT_EQ(mkdir(\"/mnt/C\", 0777), 0);\n\tASSERT_EQ(mkdir(\"/mnt/D\", 0777), 0);\n\timg_fd = openat(-EBADF, \"/mnt/C/ext4.img\", O_CREAT | O_WRONLY, 0600);\n\tASSERT_GE(img_fd, 0);\n\tASSERT_EQ(ftruncate(img_fd, 1024 * 2048), 0);\n\tASSERT_EQ(system(\"mkfs.ext4 -q /mnt/C/ext4.img\"), 0);\n\tASSERT_EQ(system(\"mount -o loop -t ext4 /mnt/C/ext4.img /mnt/D/\"), 0);\n\tASSERT_EQ(close(img_fd), 0);\n}\n\nFIXTURE_TEARDOWN(mount_setattr_idmapped)\n{\n\t(void)umount2(\"/mnt/A\", MNT_DETACH);\n\t(void)umount2(\"/tmp\", MNT_DETACH);\n}\n\n \nTEST_F(mount_setattr_idmapped, invalid_fd_negative)\n{\n\tstruct mount_attr attr = {\n\t\t.attr_set\t= MOUNT_ATTR_IDMAP,\n\t\t.userns_fd\t= -EBADF,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tASSERT_NE(sys_mount_setattr(-1, \"/\", 0, &attr, sizeof(attr)), 0) {\n\t\tTH_LOG(\"failure: created idmapped mount with negative fd\");\n\t}\n}\n\n \nTEST_F(mount_setattr_idmapped, invalid_fd_large)\n{\n\tstruct mount_attr attr = {\n\t\t.attr_set\t= MOUNT_ATTR_IDMAP,\n\t\t.userns_fd\t= INT64_MAX,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tASSERT_NE(sys_mount_setattr(-1, \"/\", 0, &attr, sizeof(attr)), 0) {\n\t\tTH_LOG(\"failure: created idmapped mount with too large fd value\");\n\t}\n}\n\n \nTEST_F(mount_setattr_idmapped, invalid_fd_closed)\n{\n\tint fd;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_IDMAP,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tfd = open(\"/dev/null\", O_RDONLY | O_CLOEXEC);\n\tASSERT_GE(fd, 0);\n\tASSERT_GE(close(fd), 0);\n\n\tattr.userns_fd = fd;\n\tASSERT_NE(sys_mount_setattr(-1, \"/\", 0, &attr, sizeof(attr)), 0) {\n\t\tTH_LOG(\"failure: created idmapped mount with closed fd\");\n\t}\n}\n\n \nTEST_F(mount_setattr_idmapped, invalid_fd_initial_userns)\n{\n\tint open_tree_fd = -EBADF;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_IDMAP,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\topen_tree_fd = sys_open_tree(-EBADF, \"/mnt/D\",\n\t\t\t\t     AT_NO_AUTOMOUNT |\n\t\t\t\t     AT_SYMLINK_NOFOLLOW |\n\t\t\t\t     OPEN_TREE_CLOEXEC | OPEN_TREE_CLONE);\n\tASSERT_GE(open_tree_fd, 0);\n\n\tattr.userns_fd = open(\"/proc/1/ns/user\", O_RDONLY | O_CLOEXEC);\n\tASSERT_GE(attr.userns_fd, 0);\n\tASSERT_NE(sys_mount_setattr(open_tree_fd, \"\", AT_EMPTY_PATH, &attr, sizeof(attr)), 0);\n\tASSERT_EQ(errno, EPERM);\n\tASSERT_EQ(close(attr.userns_fd), 0);\n\tASSERT_EQ(close(open_tree_fd), 0);\n}\n\nstatic int map_ids(pid_t pid, unsigned long nsid, unsigned long hostid,\n\t\t   unsigned long range)\n{\n\tchar map[100], procfile[256];\n\n\tsnprintf(procfile, sizeof(procfile), \"/proc/%d/uid_map\", pid);\n\tsnprintf(map, sizeof(map), \"%lu %lu %lu\", nsid, hostid, range);\n\tif (write_file(procfile, map, strlen(map)))\n\t\treturn -1;\n\n\n\tsnprintf(procfile, sizeof(procfile), \"/proc/%d/gid_map\", pid);\n\tsnprintf(map, sizeof(map), \"%lu %lu %lu\", nsid, hostid, range);\n\tif (write_file(procfile, map, strlen(map)))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n#define __STACK_SIZE (8 * 1024 * 1024)\nstatic pid_t do_clone(int (*fn)(void *), void *arg, int flags)\n{\n\tvoid *stack;\n\n\tstack = malloc(__STACK_SIZE);\n\tif (!stack)\n\t\treturn -ENOMEM;\n\n#ifdef __ia64__\n\treturn __clone2(fn, stack, __STACK_SIZE, flags | SIGCHLD, arg, NULL);\n#else\n\treturn clone(fn, stack + __STACK_SIZE, flags | SIGCHLD, arg, NULL);\n#endif\n}\n\nstatic int get_userns_fd_cb(void *data)\n{\n\treturn kill(getpid(), SIGSTOP);\n}\n\nstatic int wait_for_pid(pid_t pid)\n{\n\tint status, ret;\n\nagain:\n\tret = waitpid(pid, &status, 0);\n\tif (ret == -1) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\n\t\treturn -1;\n\t}\n\n\tif (!WIFEXITED(status))\n\t\treturn -1;\n\n\treturn WEXITSTATUS(status);\n}\n\nstatic int get_userns_fd(unsigned long nsid, unsigned long hostid, unsigned long range)\n{\n\tint ret;\n\tpid_t pid;\n\tchar path[256];\n\n\tpid = do_clone(get_userns_fd_cb, NULL, CLONE_NEWUSER);\n\tif (pid < 0)\n\t\treturn -errno;\n\n\tret = map_ids(pid, nsid, hostid, range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsnprintf(path, sizeof(path), \"/proc/%d/ns/user\", pid);\n\tret = open(path, O_RDONLY | O_CLOEXEC);\n\tkill(pid, SIGKILL);\n\twait_for_pid(pid);\n\treturn ret;\n}\n\n \nTEST_F(mount_setattr_idmapped, attached_mount_inside_current_mount_namespace)\n{\n\tint open_tree_fd = -EBADF;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_IDMAP,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\topen_tree_fd = sys_open_tree(-EBADF, \"/mnt/D\",\n\t\t\t\t     AT_EMPTY_PATH |\n\t\t\t\t     AT_NO_AUTOMOUNT |\n\t\t\t\t     AT_SYMLINK_NOFOLLOW |\n\t\t\t\t     OPEN_TREE_CLOEXEC);\n\tASSERT_GE(open_tree_fd, 0);\n\n\tattr.userns_fd\t= get_userns_fd(0, 10000, 10000);\n\tASSERT_GE(attr.userns_fd, 0);\n\tASSERT_NE(sys_mount_setattr(open_tree_fd, \"\", AT_EMPTY_PATH, &attr, sizeof(attr)), 0);\n\tASSERT_EQ(close(attr.userns_fd), 0);\n\tASSERT_EQ(close(open_tree_fd), 0);\n}\n\n \nTEST_F(mount_setattr_idmapped, attached_mount_outside_current_mount_namespace)\n{\n\tint open_tree_fd = -EBADF;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_IDMAP,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\topen_tree_fd = sys_open_tree(-EBADF, \"/mnt/D\",\n\t\t\t\t     AT_EMPTY_PATH |\n\t\t\t\t     AT_NO_AUTOMOUNT |\n\t\t\t\t     AT_SYMLINK_NOFOLLOW |\n\t\t\t\t     OPEN_TREE_CLOEXEC);\n\tASSERT_GE(open_tree_fd, 0);\n\n\tASSERT_EQ(unshare(CLONE_NEWNS), 0);\n\n\tattr.userns_fd\t= get_userns_fd(0, 10000, 10000);\n\tASSERT_GE(attr.userns_fd, 0);\n\tASSERT_NE(sys_mount_setattr(open_tree_fd, \"\", AT_EMPTY_PATH, &attr,\n\t\t\t\t    sizeof(attr)), 0);\n\tASSERT_EQ(close(attr.userns_fd), 0);\n\tASSERT_EQ(close(open_tree_fd), 0);\n}\n\n \nTEST_F(mount_setattr_idmapped, detached_mount_inside_current_mount_namespace)\n{\n\tint open_tree_fd = -EBADF;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_IDMAP,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\topen_tree_fd = sys_open_tree(-EBADF, \"/mnt/D\",\n\t\t\t\t     AT_EMPTY_PATH |\n\t\t\t\t     AT_NO_AUTOMOUNT |\n\t\t\t\t     AT_SYMLINK_NOFOLLOW |\n\t\t\t\t     OPEN_TREE_CLOEXEC |\n\t\t\t\t     OPEN_TREE_CLONE);\n\tASSERT_GE(open_tree_fd, 0);\n\n\t \n\tattr.userns_fd\t= get_userns_fd(0, 10000, 10000);\n\tASSERT_GE(attr.userns_fd, 0);\n\tASSERT_EQ(sys_mount_setattr(open_tree_fd, \"\",\n\t\t\t\t    AT_EMPTY_PATH, &attr, sizeof(attr)), 0);\n\tASSERT_EQ(close(attr.userns_fd), 0);\n\tASSERT_EQ(close(open_tree_fd), 0);\n}\n\n \nTEST_F(mount_setattr_idmapped, detached_mount_outside_current_mount_namespace)\n{\n\tint open_tree_fd = -EBADF;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_IDMAP,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\topen_tree_fd = sys_open_tree(-EBADF, \"/mnt/D\",\n\t\t\t\t     AT_EMPTY_PATH |\n\t\t\t\t     AT_NO_AUTOMOUNT |\n\t\t\t\t     AT_SYMLINK_NOFOLLOW |\n\t\t\t\t     OPEN_TREE_CLOEXEC |\n\t\t\t\t     OPEN_TREE_CLONE);\n\tASSERT_GE(open_tree_fd, 0);\n\n\tASSERT_EQ(unshare(CLONE_NEWNS), 0);\n\n\t \n\tattr.userns_fd\t= get_userns_fd(0, 10000, 10000);\n\tASSERT_GE(attr.userns_fd, 0);\n\tASSERT_EQ(sys_mount_setattr(open_tree_fd, \"\",\n\t\t\t\t    AT_EMPTY_PATH, &attr, sizeof(attr)), 0);\n\tASSERT_EQ(close(attr.userns_fd), 0);\n\tASSERT_EQ(close(open_tree_fd), 0);\n}\n\n \nTEST_F(mount_setattr_idmapped, change_idmapping)\n{\n\tint open_tree_fd = -EBADF;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_IDMAP,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\topen_tree_fd = sys_open_tree(-EBADF, \"/mnt/D\",\n\t\t\t\t     AT_EMPTY_PATH |\n\t\t\t\t     AT_NO_AUTOMOUNT |\n\t\t\t\t     AT_SYMLINK_NOFOLLOW |\n\t\t\t\t     OPEN_TREE_CLOEXEC |\n\t\t\t\t     OPEN_TREE_CLONE);\n\tASSERT_GE(open_tree_fd, 0);\n\n\tattr.userns_fd\t= get_userns_fd(0, 10000, 10000);\n\tASSERT_GE(attr.userns_fd, 0);\n\tASSERT_EQ(sys_mount_setattr(open_tree_fd, \"\",\n\t\t\t\t    AT_EMPTY_PATH, &attr, sizeof(attr)), 0);\n\tASSERT_EQ(close(attr.userns_fd), 0);\n\n\t \n\tattr.userns_fd\t= get_userns_fd(0, 20000, 10000);\n\tASSERT_GE(attr.userns_fd, 0);\n\tASSERT_NE(sys_mount_setattr(open_tree_fd, \"\", AT_EMPTY_PATH, &attr, sizeof(attr)), 0);\n\tASSERT_EQ(close(attr.userns_fd), 0);\n\tASSERT_EQ(close(open_tree_fd), 0);\n}\n\nstatic bool expected_uid_gid(int dfd, const char *path, int flags,\n\t\t\t     uid_t expected_uid, gid_t expected_gid)\n{\n\tint ret;\n\tstruct stat st;\n\n\tret = fstatat(dfd, path, &st, flags);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn st.st_uid == expected_uid && st.st_gid == expected_gid;\n}\n\nTEST_F(mount_setattr_idmapped, idmap_mount_tree_invalid)\n{\n\tint open_tree_fd = -EBADF;\n\tstruct mount_attr attr = {\n\t\t.attr_set = MOUNT_ATTR_IDMAP,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tASSERT_EQ(expected_uid_gid(-EBADF, \"/tmp/B/b\", 0, 0, 0), 0);\n\tASSERT_EQ(expected_uid_gid(-EBADF, \"/tmp/B/BB/b\", 0, 0, 0), 0);\n\n\topen_tree_fd = sys_open_tree(-EBADF, \"/mnt/A\",\n\t\t\t\t     AT_RECURSIVE |\n\t\t\t\t     AT_EMPTY_PATH |\n\t\t\t\t     AT_NO_AUTOMOUNT |\n\t\t\t\t     AT_SYMLINK_NOFOLLOW |\n\t\t\t\t     OPEN_TREE_CLOEXEC |\n\t\t\t\t     OPEN_TREE_CLONE);\n\tASSERT_GE(open_tree_fd, 0);\n\n\tattr.userns_fd\t= get_userns_fd(0, 10000, 10000);\n\tASSERT_GE(attr.userns_fd, 0);\n\tASSERT_NE(sys_mount_setattr(open_tree_fd, \"\", AT_EMPTY_PATH, &attr, sizeof(attr)), 0);\n\tASSERT_EQ(close(attr.userns_fd), 0);\n\tASSERT_EQ(close(open_tree_fd), 0);\n\n\tASSERT_EQ(expected_uid_gid(-EBADF, \"/tmp/B/b\", 0, 0, 0), 0);\n\tASSERT_EQ(expected_uid_gid(-EBADF, \"/tmp/B/BB/b\", 0, 0, 0), 0);\n\tASSERT_EQ(expected_uid_gid(open_tree_fd, \"B/b\", 0, 0, 0), 0);\n\tASSERT_EQ(expected_uid_gid(open_tree_fd, \"B/BB/b\", 0, 0, 0), 0);\n}\n\nTEST_F(mount_setattr, mount_attr_nosymfollow)\n{\n\tint fd;\n\tunsigned int old_flags = 0, new_flags = 0, expected_flags = 0;\n\tstruct mount_attr attr = {\n\t\t.attr_set\t= MOUNT_ATTR_NOSYMFOLLOW,\n\t};\n\n\tif (!mount_setattr_supported())\n\t\tSKIP(return, \"mount_setattr syscall not supported\");\n\n\tfd = open(NOSYMFOLLOW_SYMLINK, O_RDWR | O_CLOEXEC);\n\tASSERT_GT(fd, 0);\n\tASSERT_EQ(close(fd), 0);\n\n\told_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_GT(old_flags, 0);\n\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags = old_flags;\n\texpected_flags |= ST_NOSYMFOLLOW;\n\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tfd = open(NOSYMFOLLOW_SYMLINK, O_RDWR | O_CLOEXEC);\n\tASSERT_LT(fd, 0);\n\tASSERT_EQ(errno, ELOOP);\n\n\tattr.attr_set &= ~MOUNT_ATTR_NOSYMFOLLOW;\n\tattr.attr_clr |= MOUNT_ATTR_NOSYMFOLLOW;\n\n\tASSERT_EQ(sys_mount_setattr(-1, \"/mnt/A\", AT_RECURSIVE, &attr, sizeof(attr)), 0);\n\n\texpected_flags &= ~ST_NOSYMFOLLOW;\n\tnew_flags = read_mnt_flags(\"/mnt/A\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tnew_flags = read_mnt_flags(\"/mnt/A/AA/B/BB\");\n\tASSERT_EQ(new_flags, expected_flags);\n\n\tfd = open(NOSYMFOLLOW_SYMLINK, O_RDWR | O_CLOEXEC);\n\tASSERT_GT(fd, 0);\n\tASSERT_EQ(close(fd), 0);\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}