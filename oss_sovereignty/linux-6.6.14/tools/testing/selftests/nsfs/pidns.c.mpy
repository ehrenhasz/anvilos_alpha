{
  "module_name": "pidns.c",
  "hash_id": "b818e4b9a8abdc8bf118c5cb832c320f9653c338c0e636d9278587c3c5d9d967",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/nsfs/pidns.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sched.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n\n#define pr_err(fmt, ...) \\\n\t\t({ \\\n\t\t\tfprintf(stderr, \"%s:%d:\" fmt \": %m\\n\", \\\n\t\t\t\t__func__, __LINE__, ##__VA_ARGS__); \\\n\t\t\t1; \\\n\t\t})\n\n#define NSIO\t0xb7\n#define NS_GET_USERNS   _IO(NSIO, 0x1)\n#define NS_GET_PARENT   _IO(NSIO, 0x2)\n\n#define __stack_aligned__\t__attribute__((aligned(16)))\nstruct cr_clone_arg {\n\tchar stack[128] __stack_aligned__;\n\tchar stack_ptr[];\n};\n\nstatic int child(void *args)\n{\n\tprctl(PR_SET_PDEATHSIG, SIGKILL);\n\twhile (1)\n\t\tsleep(1);\n\texit(0);\n}\n\nint main(int argc, char *argv[])\n{\n\tchar *ns_strs[] = {\"pid\", \"user\"};\n\tchar path[] = \"/proc/0123456789/ns/pid\";\n\tstruct cr_clone_arg ca;\n\tstruct stat st1, st2;\n\tint ns, pns, i;\n\tpid_t pid;\n\n\tpid = clone(child, ca.stack_ptr, CLONE_NEWUSER | CLONE_NEWPID | SIGCHLD, NULL);\n\tif (pid < 0)\n\t\treturn pr_err(\"clone\");\n\n\tfor (i = 0; i < 2; i++) {\n\t\tsnprintf(path, sizeof(path), \"/proc/%d/ns/%s\", pid, ns_strs[i]);\n\t\tns = open(path, O_RDONLY);\n\t\tif (ns < 0)\n\t\t\treturn pr_err(\"Unable to open %s\", path);\n\n\t\tpns = ioctl(ns, NS_GET_PARENT);\n\t\tif (pns < 0)\n\t\t\treturn pr_err(\"Unable to get a parent pidns\");\n\n\t\tsnprintf(path, sizeof(path), \"/proc/self/ns/%s\", ns_strs[i]);\n\t\tif (stat(path, &st2))\n\t\t\treturn pr_err(\"Unable to stat %s\", path);\n\t\tif (fstat(pns, &st1))\n\t\t\treturn pr_err(\"Unable to stat the parent pidns\");\n\t\tif (st1.st_ino != st2.st_ino)\n\t\t\treturn pr_err(\"NS_GET_PARENT returned a wrong namespace\");\n\n\t\tif (ioctl(pns, NS_GET_PARENT) >= 0 || errno != EPERM)\n\t\t\treturn pr_err(\"Don't get EPERM\");\n\t}\n\n\tkill(pid, SIGKILL);\n\twait(NULL);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}