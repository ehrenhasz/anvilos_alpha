{
  "module_name": "owner.c",
  "hash_id": "43e5c45d51b2060b081cb85f859dc20ec82ceb3b3999569245b610a1a839a214",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/nsfs/owner.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n#include <sched.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n\n#define NSIO    0xb7\n#define NS_GET_USERNS   _IO(NSIO, 0x1)\n\n#define pr_err(fmt, ...) \\\n\t\t({ \\\n\t\t\tfprintf(stderr, \"%s:%d:\" fmt \": %m\\n\", \\\n\t\t\t\t__func__, __LINE__, ##__VA_ARGS__); \\\n\t\t\t1; \\\n\t\t})\n\nint main(int argc, char *argvp[])\n{\n\tint pfd[2], ns, uns, init_uns;\n\tstruct stat st1, st2;\n\tchar path[128];\n\tpid_t pid;\n\tchar c;\n\n\tif (pipe(pfd))\n\t\treturn 1;\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn pr_err(\"fork\");\n\tif (pid == 0) {\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL);\n\t\tif (unshare(CLONE_NEWUTS | CLONE_NEWUSER))\n\t\t\treturn pr_err(\"unshare\");\n\t\tclose(pfd[0]);\n\t\tclose(pfd[1]);\n\t\twhile (1)\n\t\t\tsleep(1);\n\t\treturn 0;\n\t}\n\tclose(pfd[1]);\n\tif (read(pfd[0], &c, 1) != 0)\n\t\treturn pr_err(\"Unable to read from pipe\");\n\tclose(pfd[0]);\n\n\tsnprintf(path, sizeof(path), \"/proc/%d/ns/uts\", pid);\n\tns = open(path, O_RDONLY);\n\tif (ns < 0)\n\t\treturn pr_err(\"Unable to open %s\", path);\n\n\tuns = ioctl(ns, NS_GET_USERNS);\n\tif (uns < 0)\n\t\treturn pr_err(\"Unable to get an owning user namespace\");\n\n\tif (fstat(uns, &st1))\n\t\treturn pr_err(\"fstat\");\n\n\tsnprintf(path, sizeof(path), \"/proc/%d/ns/user\", pid);\n\tif (stat(path, &st2))\n\t\treturn pr_err(\"stat\");\n\n\tif (st1.st_ino != st2.st_ino)\n\t\treturn pr_err(\"NS_GET_USERNS returned a wrong namespace\");\n\n\tinit_uns = ioctl(uns, NS_GET_USERNS);\n\tif (uns < 0)\n\t\treturn pr_err(\"Unable to get an owning user namespace\");\n\n\tif (ioctl(init_uns, NS_GET_USERNS) >= 0 || errno != EPERM)\n\t\treturn pr_err(\"Don't get EPERM\");\n\n\tif (unshare(CLONE_NEWUSER))\n\t\treturn pr_err(\"unshare\");\n\n\tif (ioctl(ns, NS_GET_USERNS) >= 0 || errno != EPERM)\n\t\treturn pr_err(\"Don't get EPERM\");\n\tif (ioctl(init_uns, NS_GET_USERNS) >= 0 || errno != EPERM)\n\t\treturn pr_err(\"Don't get EPERM\");\n\n\tkill(pid, SIGKILL);\n\twait(NULL);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}