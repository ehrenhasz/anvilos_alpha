{
  "module_name": "rlimits-per-userns.c",
  "hash_id": "dc08f07fa6c8f2a1c27706c4c01dcc6e3a6c1c24f48d5afc1f91f98ce3f28d94",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/rlimits/rlimits-per-userns.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sched.h>\n#include <signal.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <err.h>\n\n#define NR_CHILDS 2\n\nstatic char *service_prog;\nstatic uid_t user   = 60000;\nstatic uid_t group  = 60000;\n\nstatic void setrlimit_nproc(rlim_t n)\n{\n\tpid_t pid = getpid();\n\tstruct rlimit limit = {\n\t\t.rlim_cur = n,\n\t\t.rlim_max = n\n\t};\n\n\twarnx(\"(pid=%d): Setting RLIMIT_NPROC=%ld\", pid, n);\n\n\tif (setrlimit(RLIMIT_NPROC, &limit) < 0)\n\t\terr(EXIT_FAILURE, \"(pid=%d): setrlimit(RLIMIT_NPROC)\", pid);\n}\n\nstatic pid_t fork_child(void)\n{\n\tpid_t pid = fork();\n\n\tif (pid < 0)\n\t\terr(EXIT_FAILURE, \"fork\");\n\n\tif (pid > 0)\n\t\treturn pid;\n\n\tpid = getpid();\n\n\twarnx(\"(pid=%d): New process starting ...\", pid);\n\n\tif (prctl(PR_SET_PDEATHSIG, SIGKILL) < 0)\n\t\terr(EXIT_FAILURE, \"(pid=%d): prctl(PR_SET_PDEATHSIG)\", pid);\n\n\tsignal(SIGUSR1, SIG_DFL);\n\n\twarnx(\"(pid=%d): Changing to uid=%d, gid=%d\", pid, user, group);\n\n\tif (setgid(group) < 0)\n\t\terr(EXIT_FAILURE, \"(pid=%d): setgid(%d)\", pid, group);\n\tif (setuid(user) < 0)\n\t\terr(EXIT_FAILURE, \"(pid=%d): setuid(%d)\", pid, user);\n\n\twarnx(\"(pid=%d): Service running ...\", pid);\n\n\twarnx(\"(pid=%d): Unshare user namespace\", pid);\n\tif (unshare(CLONE_NEWUSER) < 0)\n\t\terr(EXIT_FAILURE, \"unshare(CLONE_NEWUSER)\");\n\n\tchar *const argv[] = { \"service\", NULL };\n\tchar *const envp[] = { \"I_AM_SERVICE=1\", NULL };\n\n\twarnx(\"(pid=%d): Executing real service ...\", pid);\n\n\texecve(service_prog, argv, envp);\n\terr(EXIT_FAILURE, \"(pid=%d): execve\", pid);\n}\n\nint main(int argc, char **argv)\n{\n\tsize_t i;\n\tpid_t child[NR_CHILDS];\n\tint wstatus[NR_CHILDS];\n\tint childs = NR_CHILDS;\n\tpid_t pid;\n\n\tif (getenv(\"I_AM_SERVICE\")) {\n\t\tpause();\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tservice_prog = argv[0];\n\tpid = getpid();\n\n\twarnx(\"(pid=%d) Starting testcase\", pid);\n\n\t \n\tsetrlimit_nproc(1);\n\n\tfor (i = 0; i < NR_CHILDS; i++) {\n\t\tchild[i] = fork_child();\n\t\twstatus[i] = 0;\n\t\tusleep(250000);\n\t}\n\n\twhile (1) {\n\t\tfor (i = 0; i < NR_CHILDS; i++) {\n\t\t\tif (child[i] <= 0)\n\t\t\t\tcontinue;\n\n\t\t\terrno = 0;\n\t\t\tpid_t ret = waitpid(child[i], &wstatus[i], WNOHANG);\n\n\t\t\tif (!ret || (!WIFEXITED(wstatus[i]) && !WIFSIGNALED(wstatus[i])))\n\t\t\t\tcontinue;\n\n\t\t\tif (ret < 0 && errno != ECHILD)\n\t\t\t\twarn(\"(pid=%d): waitpid(%d)\", pid, child[i]);\n\n\t\t\tchild[i] *= -1;\n\t\t\tchilds -= 1;\n\t\t}\n\n\t\tif (!childs)\n\t\t\tbreak;\n\n\t\tusleep(250000);\n\n\t\tfor (i = 0; i < NR_CHILDS; i++) {\n\t\t\tif (child[i] <= 0)\n\t\t\t\tcontinue;\n\t\t\tkill(child[i], SIGUSR1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < NR_CHILDS; i++) {\n\t\tif (WIFEXITED(wstatus[i]))\n\t\t\twarnx(\"(pid=%d): pid %d exited, status=%d\",\n\t\t\t\tpid, -child[i], WEXITSTATUS(wstatus[i]));\n\t\telse if (WIFSIGNALED(wstatus[i]))\n\t\t\twarnx(\"(pid=%d): pid %d killed by signal %d\",\n\t\t\t\tpid, -child[i], WTERMSIG(wstatus[i]));\n\n\t\tif (WIFSIGNALED(wstatus[i]) && WTERMSIG(wstatus[i]) == SIGUSR1)\n\t\t\tcontinue;\n\n\t\twarnx(\"(pid=%d): Test failed\", pid);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\twarnx(\"(pid=%d): Test passed\", pid);\n\texit(EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}