{
  "module_name": "pac.c",
  "hash_id": "8055cd9c03ec571a0cf2c686df08d822634a792a79c72313b48455c8f4b1ada2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/pauth/pac.c",
  "human_readable_source": "\n\n\n#define _GNU_SOURCE\n\n#include <sys/auxv.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <setjmp.h>\n#include <sched.h>\n\n#include \"../../kselftest_harness.h\"\n#include \"helper.h\"\n\n#define PAC_COLLISION_ATTEMPTS 10\n \n#define PAC_MASK (~0xff80ffffffffffff)\n#define ARBITRARY_VALUE (0x1234)\n#define ASSERT_PAUTH_ENABLED() \\\ndo { \\\n\tunsigned long hwcaps = getauxval(AT_HWCAP); \\\n\t  \\\n\tif (!(hwcaps & HWCAP_PACA))\t\t\t\t\t\\\n\t\tSKIP(return, \"PAUTH not enabled\"); \\\n} while (0)\n#define ASSERT_GENERIC_PAUTH_ENABLED() \\\ndo { \\\n\tunsigned long hwcaps = getauxval(AT_HWCAP); \\\n\t  \\\n\tif (!(hwcaps & HWCAP_PACG)) \\\n\t\tSKIP(return, \"Generic PAUTH not enabled\");\t\\\n} while (0)\n\nvoid sign_specific(struct signatures *sign, size_t val)\n{\n\tsign->keyia = keyia_sign(val);\n\tsign->keyib = keyib_sign(val);\n\tsign->keyda = keyda_sign(val);\n\tsign->keydb = keydb_sign(val);\n}\n\nvoid sign_all(struct signatures *sign, size_t val)\n{\n\tsign->keyia = keyia_sign(val);\n\tsign->keyib = keyib_sign(val);\n\tsign->keyda = keyda_sign(val);\n\tsign->keydb = keydb_sign(val);\n\tsign->keyg  = keyg_sign(val);\n}\n\nint n_same(struct signatures *old, struct signatures *new, int nkeys)\n{\n\tint res = 0;\n\n\tres += old->keyia == new->keyia;\n\tres += old->keyib == new->keyib;\n\tres += old->keyda == new->keyda;\n\tres += old->keydb == new->keydb;\n\tif (nkeys == NKEYS)\n\t\tres += old->keyg == new->keyg;\n\n\treturn res;\n}\n\nint n_same_single_set(struct signatures *sign, int nkeys)\n{\n\tsize_t vals[nkeys];\n\tint same = 0;\n\n\tvals[0] = sign->keyia & PAC_MASK;\n\tvals[1] = sign->keyib & PAC_MASK;\n\tvals[2] = sign->keyda & PAC_MASK;\n\tvals[3] = sign->keydb & PAC_MASK;\n\n\tif (nkeys >= 4)\n\t\tvals[4] = sign->keyg & PAC_MASK;\n\n\tfor (int i = 0; i < nkeys - 1; i++) {\n\t\tfor (int j = i + 1; j < nkeys; j++) {\n\t\t\tif (vals[i] == vals[j])\n\t\t\t\tsame += 1;\n\t\t}\n\t}\n\treturn same;\n}\n\nint exec_sign_all(struct signatures *signed_vals, size_t val)\n{\n\tint new_stdin[2];\n\tint new_stdout[2];\n\tint status;\n\tint i;\n\tssize_t ret;\n\tpid_t pid;\n\tcpu_set_t mask;\n\n\tret = pipe(new_stdin);\n\tif (ret == -1) {\n\t\tperror(\"pipe returned error\");\n\t\treturn -1;\n\t}\n\n\tret = pipe(new_stdout);\n\tif (ret == -1) {\n\t\tperror(\"pipe returned error\");\n\t\treturn -1;\n\t}\n\n\t \n\tsched_getaffinity(0, sizeof(mask), &mask);\n\n\tfor (i = 0; i < sizeof(cpu_set_t); i++)\n\t\tif (CPU_ISSET(i, &mask))\n\t\t\tbreak;\n\n\tCPU_ZERO(&mask);\n\tCPU_SET(i, &mask);\n\tsched_setaffinity(0, sizeof(mask), &mask);\n\n\tpid = fork();\n\t\n\tif (pid == 0) {\n\t\tdup2(new_stdin[0], STDIN_FILENO);\n\t\tif (ret == -1) {\n\t\t\tperror(\"dup2 returned error\");\n\t\t\texit(1);\n\t\t}\n\n\t\tdup2(new_stdout[1], STDOUT_FILENO);\n\t\tif (ret == -1) {\n\t\t\tperror(\"dup2 returned error\");\n\t\t\texit(1);\n\t\t}\n\n\t\tclose(new_stdin[0]);\n\t\tclose(new_stdin[1]);\n\t\tclose(new_stdout[0]);\n\t\tclose(new_stdout[1]);\n\n\t\tret = execl(\"exec_target\", \"exec_target\", (char *)NULL);\n\t\tif (ret == -1) {\n\t\t\tperror(\"exec returned error\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tclose(new_stdin[0]);\n\tclose(new_stdout[1]);\n\n\tret = write(new_stdin[1], &val, sizeof(size_t));\n\tif (ret == -1) {\n\t\tperror(\"write returned error\");\n\t\treturn -1;\n\t}\n\n\t \n\twaitpid(pid, &status, 0);\n\tif (WIFEXITED(status) == 0) {\n\t\tfprintf(stderr, \"worker exited unexpectedly\\n\");\n\t\treturn -1;\n\t}\n\tif (WEXITSTATUS(status) != 0) {\n\t\tfprintf(stderr, \"worker exited with error\\n\");\n\t\treturn -1;\n\t}\n\n\tret = read(new_stdout[0], signed_vals, sizeof(struct signatures));\n\tif (ret == -1) {\n\t\tperror(\"read returned error\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nsigjmp_buf jmpbuf;\nvoid pac_signal_handler(int signum, siginfo_t *si, void *uc)\n{\n\tif (signum == SIGSEGV || signum == SIGILL)\n\t\tsiglongjmp(jmpbuf, 1);\n}\n\n \nTEST(corrupt_pac)\n{\n\tstruct sigaction sa;\n\n\tASSERT_PAUTH_ENABLED();\n\tif (sigsetjmp(jmpbuf, 1) == 0) {\n\t\tsa.sa_sigaction = pac_signal_handler;\n\t\tsa.sa_flags = SA_SIGINFO | SA_RESETHAND;\n\t\tsigemptyset(&sa.sa_mask);\n\n\t\tsigaction(SIGSEGV, &sa, NULL);\n\t\tsigaction(SIGILL, &sa, NULL);\n\n\t\tpac_corruptor();\n\t\tASSERT_TRUE(0) TH_LOG(\"SIGSEGV/SIGILL signal did not occur\");\n\t}\n}\n\n \nTEST(pac_instructions_not_nop)\n{\n\tsize_t keyia = 0;\n\tsize_t keyib = 0;\n\tsize_t keyda = 0;\n\tsize_t keydb = 0;\n\n\tASSERT_PAUTH_ENABLED();\n\n\tfor (int i = 0; i < PAC_COLLISION_ATTEMPTS; i++) {\n\t\tkeyia |= keyia_sign(i) & PAC_MASK;\n\t\tkeyib |= keyib_sign(i) & PAC_MASK;\n\t\tkeyda |= keyda_sign(i) & PAC_MASK;\n\t\tkeydb |= keydb_sign(i) & PAC_MASK;\n\t}\n\n\tASSERT_NE(0, keyia) TH_LOG(\"keyia instructions did nothing\");\n\tASSERT_NE(0, keyib) TH_LOG(\"keyib instructions did nothing\");\n\tASSERT_NE(0, keyda) TH_LOG(\"keyda instructions did nothing\");\n\tASSERT_NE(0, keydb) TH_LOG(\"keydb instructions did nothing\");\n}\n\nTEST(pac_instructions_not_nop_generic)\n{\n\tsize_t keyg = 0;\n\n\tASSERT_GENERIC_PAUTH_ENABLED();\n\n\tfor (int i = 0; i < PAC_COLLISION_ATTEMPTS; i++)\n\t\tkeyg |= keyg_sign(i) & PAC_MASK;\n\n\tASSERT_NE(0, keyg)  TH_LOG(\"keyg instructions did nothing\");\n}\n\nTEST(single_thread_different_keys)\n{\n\tint same = 10;\n\tint nkeys = NKEYS;\n\tint tmp;\n\tstruct signatures signed_vals;\n\tunsigned long hwcaps = getauxval(AT_HWCAP);\n\n\t \n\tASSERT_PAUTH_ENABLED();\n\tif (!(hwcaps & HWCAP_PACG)) {\n\t\tTH_LOG(\"WARNING: Generic PAUTH not enabled. Skipping generic key checks\");\n\t\tnkeys = NKEYS - 1;\n\t}\n\n\t \n\tfor (int i = 0; i < PAC_COLLISION_ATTEMPTS; i++) {\n\t\tif (nkeys == NKEYS)\n\t\t\tsign_all(&signed_vals, i);\n\t\telse\n\t\t\tsign_specific(&signed_vals, i);\n\n\t\ttmp = n_same_single_set(&signed_vals, nkeys);\n\t\tif (tmp < same)\n\t\t\tsame = tmp;\n\t}\n\n\tASSERT_EQ(0, same) TH_LOG(\"%d keys clashed every time\", same);\n}\n\n \nTEST(exec_changed_keys)\n{\n\tstruct signatures new_keys;\n\tstruct signatures old_keys;\n\tint ret;\n\tint same = 10;\n\tint nkeys = NKEYS;\n\tunsigned long hwcaps = getauxval(AT_HWCAP);\n\n\t \n\tASSERT_PAUTH_ENABLED();\n\tif (!(hwcaps & HWCAP_PACG)) {\n\t\tTH_LOG(\"WARNING: Generic PAUTH not enabled. Skipping generic key checks\");\n\t\tnkeys = NKEYS - 1;\n\t}\n\n\tfor (int i = 0; i < PAC_COLLISION_ATTEMPTS; i++) {\n\t\tret = exec_sign_all(&new_keys, i);\n\t\tASSERT_EQ(0, ret) TH_LOG(\"failed to run worker\");\n\n\t\tif (nkeys == NKEYS)\n\t\t\tsign_all(&old_keys, i);\n\t\telse\n\t\t\tsign_specific(&old_keys, i);\n\n\t\tret = n_same(&old_keys, &new_keys, nkeys);\n\t\tif (ret < same)\n\t\t\tsame = ret;\n\t}\n\n\tASSERT_EQ(0, same) TH_LOG(\"exec() did not change %d keys\", same);\n}\n\nTEST(context_switch_keep_keys)\n{\n\tint ret;\n\tstruct signatures trash;\n\tstruct signatures before;\n\tstruct signatures after;\n\n\tASSERT_PAUTH_ENABLED();\n\n\tsign_specific(&before, ARBITRARY_VALUE);\n\n\t \n\tret = exec_sign_all(&trash, ARBITRARY_VALUE);\n\tASSERT_EQ(0, ret) TH_LOG(\"failed to run worker\");\n\n\tsign_specific(&after, ARBITRARY_VALUE);\n\n\tASSERT_EQ(before.keyia, after.keyia) TH_LOG(\"keyia changed after context switching\");\n\tASSERT_EQ(before.keyib, after.keyib) TH_LOG(\"keyib changed after context switching\");\n\tASSERT_EQ(before.keyda, after.keyda) TH_LOG(\"keyda changed after context switching\");\n\tASSERT_EQ(before.keydb, after.keydb) TH_LOG(\"keydb changed after context switching\");\n}\n\nTEST(context_switch_keep_keys_generic)\n{\n\tint ret;\n\tstruct signatures trash;\n\tsize_t before;\n\tsize_t after;\n\n\tASSERT_GENERIC_PAUTH_ENABLED();\n\n\tbefore = keyg_sign(ARBITRARY_VALUE);\n\n\t \n\tret = exec_sign_all(&trash, ARBITRARY_VALUE);\n\tASSERT_EQ(0, ret) TH_LOG(\"failed to run worker\");\n\n\tafter = keyg_sign(ARBITRARY_VALUE);\n\n\tASSERT_EQ(before, after) TH_LOG(\"keyg changed after context switching\");\n}\n\nTEST_HARNESS_MAIN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}