{
  "module_name": "syscall-abi.c",
  "hash_id": "e4867c59021389a1f807f08633f94502d0a6e0b7e345eb8376d875726e773e97",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/abi/syscall-abi.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <asm/hwcap.h>\n#include <asm/sigcontext.h>\n#include <asm/unistd.h>\n\n#include \"../../kselftest.h\"\n\n#include \"syscall-abi.h\"\n\n \n#define ARCH_SVE_VQ_MAX 16\n\nstatic int default_sme_vl;\n\nstatic int sve_vl_count;\nstatic unsigned int sve_vls[ARCH_SVE_VQ_MAX];\nstatic int sme_vl_count;\nstatic unsigned int sme_vls[ARCH_SVE_VQ_MAX];\n\nextern void do_syscall(int sve_vl, int sme_vl);\n\nstatic void fill_random(void *buf, size_t size)\n{\n\tint i;\n\tuint32_t *lbuf = buf;\n\n\t \n\tfor (i = 0; i < size / sizeof(uint32_t); i++)\n\t\tlbuf[i] = random();\n}\n\n \nstatic struct syscall_cfg {\n\tint syscall_nr;\n\tconst char *name;\n} syscalls[] = {\n\t{ __NR_getpid,\t\t\"getpid()\" },\n\t{ __NR_sched_yield,\t\"sched_yield()\" },\n};\n\n#define NUM_GPR 31\nuint64_t gpr_in[NUM_GPR];\nuint64_t gpr_out[NUM_GPR];\n\nstatic void setup_gpr(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t      uint64_t svcr)\n{\n\tfill_random(gpr_in, sizeof(gpr_in));\n\tgpr_in[8] = cfg->syscall_nr;\n\tmemset(gpr_out, 0, sizeof(gpr_out));\n}\n\nstatic int check_gpr(struct syscall_cfg *cfg, int sve_vl, int sme_vl, uint64_t svcr)\n{\n\tint errors = 0;\n\tint i;\n\n\t \n\tfor (i = 9; i < ARRAY_SIZE(gpr_in); i++) {\n\t\tif (gpr_in[i] != gpr_out[i]) {\n\t\t\tksft_print_msg(\"%s SVE VL %d mismatch in GPR %d: %llx != %llx\\n\",\n\t\t\t\t       cfg->name, sve_vl, i,\n\t\t\t\t       gpr_in[i], gpr_out[i]);\n\t\t\terrors++;\n\t\t}\n\t}\n\n\treturn errors;\n}\n\n#define NUM_FPR 32\nuint64_t fpr_in[NUM_FPR * 2];\nuint64_t fpr_out[NUM_FPR * 2];\nuint64_t fpr_zero[NUM_FPR * 2];\n\nstatic void setup_fpr(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t      uint64_t svcr)\n{\n\tfill_random(fpr_in, sizeof(fpr_in));\n\tmemset(fpr_out, 0, sizeof(fpr_out));\n}\n\nstatic int check_fpr(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t     uint64_t svcr)\n{\n\tint errors = 0;\n\tint i;\n\n\tif (!sve_vl && !(svcr & SVCR_SM_MASK)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(fpr_in); i++) {\n\t\t\tif (fpr_in[i] != fpr_out[i]) {\n\t\t\t\tksft_print_msg(\"%s Q%d/%d mismatch %llx != %llx\\n\",\n\t\t\t\t\t       cfg->name,\n\t\t\t\t\t       i / 2, i % 2,\n\t\t\t\t\t       fpr_in[i], fpr_out[i]);\n\t\t\t\terrors++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (svcr & SVCR_SM_MASK) {\n\t\tif (memcmp(fpr_zero, fpr_out, sizeof(fpr_out)) != 0) {\n\t\t\tksft_print_msg(\"%s FPSIMD registers non-zero exiting SM\\n\",\n\t\t\t\t       cfg->name);\n\t\t\terrors++;\n\t\t}\n\t}\n\n\treturn errors;\n}\n\n#define SVE_Z_SHARED_BYTES (128 / 8)\n\nstatic uint8_t z_zero[__SVE_ZREG_SIZE(ARCH_SVE_VQ_MAX)];\nuint8_t z_in[SVE_NUM_ZREGS * __SVE_ZREG_SIZE(ARCH_SVE_VQ_MAX)];\nuint8_t z_out[SVE_NUM_ZREGS * __SVE_ZREG_SIZE(ARCH_SVE_VQ_MAX)];\n\nstatic void setup_z(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t    uint64_t svcr)\n{\n\tfill_random(z_in, sizeof(z_in));\n\tfill_random(z_out, sizeof(z_out));\n}\n\nstatic int check_z(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t   uint64_t svcr)\n{\n\tsize_t reg_size = sve_vl;\n\tint errors = 0;\n\tint i;\n\n\tif (!sve_vl)\n\t\treturn 0;\n\n\tfor (i = 0; i < SVE_NUM_ZREGS; i++) {\n\t\tuint8_t *in = &z_in[reg_size * i];\n\t\tuint8_t *out = &z_out[reg_size * i];\n\n\t\tif (svcr & SVCR_SM_MASK) {\n\t\t\t \n\t\t\tif (memcmp(z_zero, out, reg_size) != 0) {\n\t\t\t\tksft_print_msg(\"%s SVE VL %d Z%d non-zero\\n\",\n\t\t\t\t\t       cfg->name, sve_vl, i);\n\t\t\t\terrors++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (memcmp(in, out, SVE_Z_SHARED_BYTES) != 0) {\n\t\t\t\tksft_print_msg(\"%s SVE VL %d Z%d low 128 bits changed\\n\",\n\t\t\t\t\t       cfg->name, sve_vl, i);\n\t\t\t\terrors++;\n\t\t\t}\n\n\t\t\tif (reg_size > SVE_Z_SHARED_BYTES &&\n\t\t\t    (memcmp(z_zero, out + SVE_Z_SHARED_BYTES,\n\t\t\t\t    reg_size - SVE_Z_SHARED_BYTES) != 0)) {\n\t\t\t\tksft_print_msg(\"%s SVE VL %d Z%d high bits non-zero\\n\",\n\t\t\t\t\t       cfg->name, sve_vl, i);\n\t\t\t\terrors++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors;\n}\n\nuint8_t p_in[SVE_NUM_PREGS * __SVE_PREG_SIZE(ARCH_SVE_VQ_MAX)];\nuint8_t p_out[SVE_NUM_PREGS * __SVE_PREG_SIZE(ARCH_SVE_VQ_MAX)];\n\nstatic void setup_p(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t    uint64_t svcr)\n{\n\tfill_random(p_in, sizeof(p_in));\n\tfill_random(p_out, sizeof(p_out));\n}\n\nstatic int check_p(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t   uint64_t svcr)\n{\n\tsize_t reg_size = sve_vq_from_vl(sve_vl) * 2;  \n\n\tint errors = 0;\n\tint i;\n\n\tif (!sve_vl)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < SVE_NUM_PREGS * reg_size; i++)\n\t\tif (p_out[i])\n\t\t\terrors++;\n\tif (errors)\n\t\tksft_print_msg(\"%s SVE VL %d predicate registers non-zero\\n\",\n\t\t\t       cfg->name, sve_vl);\n\n\treturn errors;\n}\n\nuint8_t ffr_in[__SVE_PREG_SIZE(ARCH_SVE_VQ_MAX)];\nuint8_t ffr_out[__SVE_PREG_SIZE(ARCH_SVE_VQ_MAX)];\n\nstatic void setup_ffr(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t      uint64_t svcr)\n{\n\t \n\tif ((svcr & SVCR_SM_MASK) &&\n\t    !(getauxval(AT_HWCAP2) & HWCAP2_SME_FA64)) {\n\t\tmemset(&ffr_in, 0, sizeof(ffr_in));\n\t\treturn;\n\t}\n\n\t \n\tmemset(ffr_in, 0xff, sizeof(ffr_in));\n\tfill_random(ffr_out, sizeof(ffr_out));\n}\n\nstatic int check_ffr(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t     uint64_t svcr)\n{\n\tsize_t reg_size = sve_vq_from_vl(sve_vl) * 2;   \n\tint errors = 0;\n\tint i;\n\n\tif (!sve_vl)\n\t\treturn 0;\n\n\tif ((svcr & SVCR_SM_MASK) &&\n\t    !(getauxval(AT_HWCAP2) & HWCAP2_SME_FA64))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < reg_size; i++)\n\t\tif (ffr_out[i])\n\t\t\terrors++;\n\tif (errors)\n\t\tksft_print_msg(\"%s SVE VL %d FFR non-zero\\n\",\n\t\t\t       cfg->name, sve_vl);\n\n\treturn errors;\n}\n\nuint64_t svcr_in, svcr_out;\n\nstatic void setup_svcr(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t    uint64_t svcr)\n{\n\tsvcr_in = svcr;\n}\n\nstatic int check_svcr(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t      uint64_t svcr)\n{\n\tint errors = 0;\n\n\tif (svcr_out & SVCR_SM_MASK) {\n\t\tksft_print_msg(\"%s Still in SM, SVCR %llx\\n\",\n\t\t\t       cfg->name, svcr_out);\n\t\terrors++;\n\t}\n\n\tif ((svcr_in & SVCR_ZA_MASK) != (svcr_out & SVCR_ZA_MASK)) {\n\t\tksft_print_msg(\"%s PSTATE.ZA changed, SVCR %llx != %llx\\n\",\n\t\t\t       cfg->name, svcr_in, svcr_out);\n\t\terrors++;\n\t}\n\n\treturn errors;\n}\n\nuint8_t za_in[ZA_SIG_REGS_SIZE(ARCH_SVE_VQ_MAX)];\nuint8_t za_out[ZA_SIG_REGS_SIZE(ARCH_SVE_VQ_MAX)];\n\nstatic void setup_za(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t     uint64_t svcr)\n{\n\tfill_random(za_in, sizeof(za_in));\n\tmemset(za_out, 0, sizeof(za_out));\n}\n\nstatic int check_za(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t    uint64_t svcr)\n{\n\tsize_t reg_size = sme_vl * sme_vl;\n\tint errors = 0;\n\n\tif (!(svcr & SVCR_ZA_MASK))\n\t\treturn 0;\n\n\tif (memcmp(za_in, za_out, reg_size) != 0) {\n\t\tksft_print_msg(\"SME VL %d ZA does not match\\n\", sme_vl);\n\t\terrors++;\n\t}\n\n\treturn errors;\n}\n\nuint8_t zt_in[ZT_SIG_REG_BYTES] __attribute__((aligned(16)));\nuint8_t zt_out[ZT_SIG_REG_BYTES] __attribute__((aligned(16)));\n\nstatic void setup_zt(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t     uint64_t svcr)\n{\n\tfill_random(zt_in, sizeof(zt_in));\n\tmemset(zt_out, 0, sizeof(zt_out));\n}\n\nstatic int check_zt(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t    uint64_t svcr)\n{\n\tint errors = 0;\n\n\tif (!(getauxval(AT_HWCAP2) & HWCAP2_SME2))\n\t\treturn 0;\n\n\tif (!(svcr & SVCR_ZA_MASK))\n\t\treturn 0;\n\n\tif (memcmp(zt_in, zt_out, sizeof(zt_in)) != 0) {\n\t\tksft_print_msg(\"SME VL %d ZT does not match\\n\", sme_vl);\n\t\terrors++;\n\t}\n\n\treturn errors;\n}\n\ntypedef void (*setup_fn)(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t\t uint64_t svcr);\ntypedef int (*check_fn)(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t\tuint64_t svcr);\n\n \nstatic struct {\n\tsetup_fn setup;\n\tcheck_fn check;\n} regset[] = {\n\t{ setup_gpr, check_gpr },\n\t{ setup_fpr, check_fpr },\n\t{ setup_z, check_z },\n\t{ setup_p, check_p },\n\t{ setup_ffr, check_ffr },\n\t{ setup_svcr, check_svcr },\n\t{ setup_za, check_za },\n\t{ setup_zt, check_zt },\n};\n\nstatic bool do_test(struct syscall_cfg *cfg, int sve_vl, int sme_vl,\n\t\t    uint64_t svcr)\n{\n\tint errors = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(regset); i++)\n\t\tregset[i].setup(cfg, sve_vl, sme_vl, svcr);\n\n\tdo_syscall(sve_vl, sme_vl);\n\n\tfor (i = 0; i < ARRAY_SIZE(regset); i++)\n\t\terrors += regset[i].check(cfg, sve_vl, sme_vl, svcr);\n\n\treturn errors == 0;\n}\n\nstatic void test_one_syscall(struct syscall_cfg *cfg)\n{\n\tint sve, sme;\n\tint ret;\n\n\t \n\tksft_test_result(do_test(cfg, 0, default_sme_vl, 0),\n\t\t\t \"%s FPSIMD\\n\", cfg->name);\n\n\tfor (sve = 0; sve < sve_vl_count; sve++) {\n\t\tret = prctl(PR_SVE_SET_VL, sve_vls[sve]);\n\t\tif (ret == -1)\n\t\t\tksft_exit_fail_msg(\"PR_SVE_SET_VL failed: %s (%d)\\n\",\n\t\t\t\t\t   strerror(errno), errno);\n\n\t\tksft_test_result(do_test(cfg, sve_vls[sve], default_sme_vl, 0),\n\t\t\t\t \"%s SVE VL %d\\n\", cfg->name, sve_vls[sve]);\n\n\t\tfor (sme = 0; sme < sme_vl_count; sme++) {\n\t\t\tret = prctl(PR_SME_SET_VL, sme_vls[sme]);\n\t\t\tif (ret == -1)\n\t\t\t\tksft_exit_fail_msg(\"PR_SME_SET_VL failed: %s (%d)\\n\",\n\t\t\t\t\t\t   strerror(errno), errno);\n\n\t\t\tksft_test_result(do_test(cfg, sve_vls[sve],\n\t\t\t\t\t\t sme_vls[sme],\n\t\t\t\t\t\t SVCR_ZA_MASK | SVCR_SM_MASK),\n\t\t\t\t\t \"%s SVE VL %d/SME VL %d SM+ZA\\n\",\n\t\t\t\t\t cfg->name, sve_vls[sve],\n\t\t\t\t\t sme_vls[sme]);\n\t\t\tksft_test_result(do_test(cfg, sve_vls[sve],\n\t\t\t\t\t\t sme_vls[sme], SVCR_SM_MASK),\n\t\t\t\t\t \"%s SVE VL %d/SME VL %d SM\\n\",\n\t\t\t\t\t cfg->name, sve_vls[sve],\n\t\t\t\t\t sme_vls[sme]);\n\t\t\tksft_test_result(do_test(cfg, sve_vls[sve],\n\t\t\t\t\t\t sme_vls[sme], SVCR_ZA_MASK),\n\t\t\t\t\t \"%s SVE VL %d/SME VL %d ZA\\n\",\n\t\t\t\t\t cfg->name, sve_vls[sve],\n\t\t\t\t\t sme_vls[sme]);\n\t\t}\n\t}\n\n\tfor (sme = 0; sme < sme_vl_count; sme++) {\n\t\tret = prctl(PR_SME_SET_VL, sme_vls[sme]);\n\t\tif (ret == -1)\n\t\t\tksft_exit_fail_msg(\"PR_SME_SET_VL failed: %s (%d)\\n\",\n\t\t\t\t\t\t   strerror(errno), errno);\n\n\t\tksft_test_result(do_test(cfg, 0, sme_vls[sme],\n\t\t\t\t\t SVCR_ZA_MASK | SVCR_SM_MASK),\n\t\t\t\t \"%s SME VL %d SM+ZA\\n\",\n\t\t\t\t cfg->name, sme_vls[sme]);\n\t\tksft_test_result(do_test(cfg, 0, sme_vls[sme], SVCR_SM_MASK),\n\t\t\t\t \"%s SME VL %d SM\\n\",\n\t\t\t\t cfg->name, sme_vls[sme]);\n\t\tksft_test_result(do_test(cfg, 0, sme_vls[sme], SVCR_ZA_MASK),\n\t\t\t\t \"%s SME VL %d ZA\\n\",\n\t\t\t\t cfg->name, sme_vls[sme]);\n\t}\n}\n\nvoid sve_count_vls(void)\n{\n\tunsigned int vq;\n\tint vl;\n\n\tif (!(getauxval(AT_HWCAP) & HWCAP_SVE))\n\t\treturn;\n\n\t \n\tfor (vq = ARCH_SVE_VQ_MAX; vq > 0; vq /= 2) {\n\t\tvl = prctl(PR_SVE_SET_VL, vq * 16);\n\t\tif (vl == -1)\n\t\t\tksft_exit_fail_msg(\"PR_SVE_SET_VL failed: %s (%d)\\n\",\n\t\t\t\t\t   strerror(errno), errno);\n\n\t\tvl &= PR_SVE_VL_LEN_MASK;\n\n\t\tif (vq != sve_vq_from_vl(vl))\n\t\t\tvq = sve_vq_from_vl(vl);\n\n\t\tsve_vls[sve_vl_count++] = vl;\n\t}\n}\n\nvoid sme_count_vls(void)\n{\n\tunsigned int vq;\n\tint vl;\n\n\tif (!(getauxval(AT_HWCAP2) & HWCAP2_SME))\n\t\treturn;\n\n\t \n\tfor (vq = ARCH_SVE_VQ_MAX; vq > 0; vq /= 2) {\n\t\tvl = prctl(PR_SME_SET_VL, vq * 16);\n\t\tif (vl == -1)\n\t\t\tksft_exit_fail_msg(\"PR_SME_SET_VL failed: %s (%d)\\n\",\n\t\t\t\t\t   strerror(errno), errno);\n\n\t\tvl &= PR_SME_VL_LEN_MASK;\n\n\t\t \n\t\tif (sve_vq_from_vl(vl) > vq)\n\t\t\tbreak;\n\n\t\tif (vq != sve_vq_from_vl(vl))\n\t\t\tvq = sve_vq_from_vl(vl);\n\n\t\tsme_vls[sme_vl_count++] = vl;\n\t}\n\n\t \n\tdefault_sme_vl = sme_vls[0];\n}\n\nint main(void)\n{\n\tint i;\n\tint tests = 1;   \n\tint sme_ver;\n\n\tsrandom(getpid());\n\n\tksft_print_header();\n\n\tsve_count_vls();\n\tsme_count_vls();\n\n\ttests += sve_vl_count;\n\ttests += sme_vl_count * 3;\n\ttests += (sve_vl_count * sme_vl_count) * 3;\n\tksft_set_plan(ARRAY_SIZE(syscalls) * tests);\n\n\tif (getauxval(AT_HWCAP2) & HWCAP2_SME2)\n\t\tsme_ver = 2;\n\telse\n\t\tsme_ver = 1;\n\n\tif (getauxval(AT_HWCAP2) & HWCAP2_SME_FA64)\n\t\tksft_print_msg(\"SME%d with FA64\\n\", sme_ver);\n\telse if (getauxval(AT_HWCAP2) & HWCAP2_SME)\n\t\tksft_print_msg(\"SME%d without FA64\\n\", sme_ver);\n\n\tfor (i = 0; i < ARRAY_SIZE(syscalls); i++)\n\t\ttest_one_syscall(&syscalls[i]);\n\n\tksft_print_cnts();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}