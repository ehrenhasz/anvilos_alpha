{
  "module_name": "tpidr2.c",
  "hash_id": "bb356b2ad10806ca4d89c96cdafdd49ee18c019e854aa8409a043ec9c31f6056",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/abi/tpidr2.c",
  "human_readable_source": "\n\n#include <linux/sched.h>\n#include <linux/wait.h>\n\n#define SYS_TPIDR2 \"S3_3_C13_C0_5\"\n\n#define EXPECTED_TESTS 5\n\nstatic void putstr(const char *str)\n{\n\twrite(1, str, strlen(str));\n}\n\nstatic void putnum(unsigned int num)\n{\n\tchar c;\n\n\tif (num / 10)\n\t\tputnum(num / 10);\n\n\tc = '0' + (num % 10);\n\twrite(1, &c, 1);\n}\n\nstatic int tests_run;\nstatic int tests_passed;\nstatic int tests_failed;\nstatic int tests_skipped;\n\nstatic void set_tpidr2(uint64_t val)\n{\n\tasm volatile (\n\t\t\"msr\t\" SYS_TPIDR2 \", %0\\n\"\n\t\t:\n\t\t: \"r\"(val)\n\t\t: \"cc\");\n}\n\nstatic uint64_t get_tpidr2(void)\n{\n\tuint64_t val;\n\n\tasm volatile (\n\t\t\"mrs\t%0, \" SYS_TPIDR2 \"\\n\"\n\t\t: \"=r\"(val)\n\t\t:\n\t\t: \"cc\");\n\n\treturn val;\n}\n\nstatic void print_summary(void)\n{\n\tif (tests_passed + tests_failed + tests_skipped != EXPECTED_TESTS)\n\t\tputstr(\"# UNEXPECTED TEST COUNT: \");\n\n\tputstr(\"# Totals: pass:\");\n\tputnum(tests_passed);\n\tputstr(\" fail:\");\n\tputnum(tests_failed);\n\tputstr(\" xfail:0 xpass:0 skip:\");\n\tputnum(tests_skipped);\n\tputstr(\" error:0\\n\");\n}\n\n \nstatic int default_value(void)\n{\n\treturn get_tpidr2() == 0;\n}\n\n \nstatic int write_read(void)\n{\n\tset_tpidr2(getpid());\n\n\treturn getpid() == get_tpidr2();\n}\n\n \nstatic int write_sleep_read(void)\n{\n\tset_tpidr2(getpid());\n\n\tmsleep(100);\n\n\treturn getpid() == get_tpidr2();\n}\n\n \nstatic int write_fork_read(void)\n{\n\tpid_t newpid, waiting, oldpid;\n\tint status;\n\n\tset_tpidr2(getpid());\n\n\toldpid = getpid();\n\tnewpid = fork();\n\tif (newpid == 0) {\n\t\t \n\t\tif (get_tpidr2() != oldpid) {\n\t\t\tputstr(\"# TPIDR2 changed in child: \");\n\t\t\tputnum(get_tpidr2());\n\t\t\tputstr(\"\\n\");\n\t\t\texit(0);\n\t\t}\n\n\t\tset_tpidr2(getpid());\n\t\tif (get_tpidr2() == getpid()) {\n\t\t\texit(1);\n\t\t} else {\n\t\t\tputstr(\"# Failed to set TPIDR2 in child\\n\");\n\t\t\texit(0);\n\t\t}\n\t}\n\tif (newpid < 0) {\n\t\tputstr(\"# fork() failed: -\");\n\t\tputnum(-newpid);\n\t\tputstr(\"\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (;;) {\n\t\twaiting = waitpid(newpid, &status, 0);\n\n\t\tif (waiting < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tputstr(\"# waitpid() failed: \");\n\t\t\tputnum(errno);\n\t\t\tputstr(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (waiting != newpid) {\n\t\t\tputstr(\"# waitpid() returned wrong PID\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!WIFEXITED(status)) {\n\t\t\tputstr(\"# child did not exit\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (getpid() != get_tpidr2()) {\n\t\t\tputstr(\"# TPIDR2 corrupted in parent\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn WEXITSTATUS(status);\n\t}\n}\n\n \nstatic int sys_clone(unsigned long clone_flags, unsigned long newsp,\n\t\t     int *parent_tidptr, unsigned long tls,\n\t\t     int *child_tidptr)\n{\n\treturn my_syscall5(__NR_clone, clone_flags, newsp, parent_tidptr, tls,\n\t\t\t   child_tidptr);\n}\n\n \nstatic int write_clone_read(void)\n{\n\tint parent_tid, child_tid;\n\tpid_t parent, waiting;\n\tint ret, status;\n\n\tparent = getpid();\n\tset_tpidr2(parent);\n\n\tret = sys_clone(CLONE_SETTLS, 0, &parent_tid, 0, &child_tid);\n\tif (ret == -1) {\n\t\tputstr(\"# clone() failed\\n\");\n\t\tputnum(errno);\n\t\tputstr(\"\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ret == 0) {\n\t\t \n\t\tif (get_tpidr2() != 0) {\n\t\t\tputstr(\"# TPIDR2 non-zero in child: \");\n\t\t\tputnum(get_tpidr2());\n\t\t\tputstr(\"\\n\");\n\t\t\texit(0);\n\t\t}\n\n\t\tif (gettid() == 0)\n\t\t\tputstr(\"# Child TID==0\\n\");\n\t\tset_tpidr2(gettid());\n\t\tif (get_tpidr2() == gettid()) {\n\t\t\texit(1);\n\t\t} else {\n\t\t\tputstr(\"# Failed to set TPIDR2 in child\\n\");\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\twaiting = wait4(ret, &status, __WCLONE, NULL);\n\n\t\tif (waiting < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tputstr(\"# wait4() failed: \");\n\t\t\tputnum(errno);\n\t\t\tputstr(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (waiting != ret) {\n\t\t\tputstr(\"# wait4() returned wrong PID \");\n\t\t\tputnum(waiting);\n\t\t\tputstr(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!WIFEXITED(status)) {\n\t\t\tputstr(\"# child did not exit\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (parent != get_tpidr2()) {\n\t\t\tputstr(\"# TPIDR2 corrupted in parent\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn WEXITSTATUS(status);\n\t}\n}\n\n#define run_test(name)\t\t\t     \\\n\tif (name()) {\t\t\t     \\\n\t\ttests_passed++;\t\t     \\\n\t} else {\t\t\t     \\\n\t\ttests_failed++;\t\t     \\\n\t\tputstr(\"not \");\t\t     \\\n\t}\t\t\t\t     \\\n\tputstr(\"ok \");\t\t\t     \\\n\tputnum(++tests_run);\t\t     \\\n\tputstr(\" \" #name \"\\n\");\n\nint main(int argc, char **argv)\n{\n\tint ret, i;\n\n\tputstr(\"TAP version 13\\n\");\n\tputstr(\"1..\");\n\tputnum(EXPECTED_TESTS);\n\tputstr(\"\\n\");\n\n\tputstr(\"# PID: \");\n\tputnum(getpid());\n\tputstr(\"\\n\");\n\n\t \n\tret = open(\"/proc/sys/abi/sme_default_vector_length\", O_RDONLY, 0);\n\tif (ret >= 0) {\n\t\trun_test(default_value);\n\t\trun_test(write_read);\n\t\trun_test(write_sleep_read);\n\t\trun_test(write_fork_read);\n\t\trun_test(write_clone_read);\n\n\t} else {\n\t\tputstr(\"# SME support not present\\n\");\n\n\t\tfor (i = 0; i < EXPECTED_TESTS; i++) {\n\t\t\tputstr(\"ok \");\n\t\t\tputnum(i);\n\t\t\tputstr(\" skipped, TPIDR2 not supported\\n\");\n\t\t}\n\n\t\ttests_skipped += EXPECTED_TESTS;\n\t}\n\n\tprint_summary();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}