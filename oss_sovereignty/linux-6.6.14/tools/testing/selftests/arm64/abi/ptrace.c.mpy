{
  "module_name": "ptrace.c",
  "hash_id": "50377c38fe1759c205244e2ece10d042c6a1f78de0a1ea09bac1a50da90f6785",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/abi/ptrace.c",
  "human_readable_source": "\n \n#include <errno.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n#include <asm/sigcontext.h>\n#include <asm/ptrace.h>\n\n#include \"../../kselftest.h\"\n\n#define EXPECTED_TESTS 11\n\n#define MAX_TPIDRS 2\n\nstatic bool have_sme(void)\n{\n\treturn getauxval(AT_HWCAP2) & HWCAP2_SME;\n}\n\nstatic void test_tpidr(pid_t child)\n{\n\tuint64_t read_val[MAX_TPIDRS];\n\tuint64_t write_val[MAX_TPIDRS];\n\tstruct iovec read_iov, write_iov;\n\tbool test_tpidr2 = false;\n\tint ret, i;\n\n\tread_iov.iov_base = read_val;\n\twrite_iov.iov_base = write_val;\n\n\t \n\tread_iov.iov_len = sizeof(uint64_t);\n\tret = ptrace(PTRACE_GETREGSET, child, NT_ARM_TLS, &read_iov);\n\tksft_test_result(ret == 0, \"read_tpidr_one\\n\");\n\n\t \n\twrite_iov.iov_len = sizeof(uint64_t);\n\twrite_val[0] = read_val[0]++;\n\tret = ptrace(PTRACE_SETREGSET, child, NT_ARM_TLS, &write_iov);\n\tksft_test_result(ret == 0, \"write_tpidr_one\\n\");\n\n\t \n\tret = ptrace(PTRACE_GETREGSET, child, NT_ARM_TLS, &read_iov);\n\tksft_test_result(ret == 0 && write_val[0] == read_val[0],\n\t\t\t \"verify_tpidr_one\\n\");\n\n\t \n\tread_iov.iov_len = sizeof(read_val);\n\tret = ptrace(PTRACE_GETREGSET, child, NT_ARM_TLS, &read_iov);\n\tif (ret == 0) {\n\t\t \n\t\tif (read_iov.iov_len >= sizeof(read_val))\n\t\t\ttest_tpidr2 = true;\n\n\t\tif (have_sme() && test_tpidr2) {\n\t\t\tksft_test_result(test_tpidr2, \"count_tpidrs\\n\");\n\t\t} else {\n\t\t\tksft_test_result(read_iov.iov_len % sizeof(uint64_t) == 0,\n\t\t\t\t\t \"count_tpidrs\\n\");\n\t\t}\n\t} else {\n\t\tksft_test_result_fail(\"count_tpidrs\\n\");\n\t}\n\n\tif (test_tpidr2) {\n\t\t \n\t\twrite_iov.iov_len = sizeof(write_val);\n\t\tfor (i = 0; i < MAX_TPIDRS; i++)\n\t\t\twrite_val[i] = read_val[i] + 1;\n\t\tret = ptrace(PTRACE_SETREGSET, child, NT_ARM_TLS, &write_iov);\n\n\t\tksft_test_result(ret == 0 &&\n\t\t\t\t write_iov.iov_len == sizeof(write_val),\n\t\t\t\t \"tpidr2_write\\n\");\n\n\t\t \n\t\tread_iov.iov_len = sizeof(read_val);\n\t\tret = ptrace(PTRACE_GETREGSET, child, NT_ARM_TLS, &read_iov);\n\n\t\tif (have_sme()) {\n\t\t\t \n\t\t\tksft_test_result(ret == 0 &&\n\t\t\t\t\t read_iov.iov_len >= sizeof(read_val) &&\n\t\t\t\t\t memcmp(read_val, write_val,\n\t\t\t\t\t\tsizeof(read_val)) == 0,\n\t\t\t\t\t \"tpidr2_read\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tksft_test_result(ret == 0 &&\n\t\t\t\t\t read_iov.iov_len >= sizeof(read_val) &&\n\t\t\t\t\t read_val[0] == write_val[0] &&\n\t\t\t\t\t read_val[1] == 0,\n\t\t\t\t\t \"tpidr2_read\\n\");\n\t\t}\n\n\t\t \n\t\twrite_iov.iov_len = sizeof(uint64_t);\n\t\tmemcpy(write_val, read_val, sizeof(read_val));\n\t\twrite_val[0] += 1;\n\t\tret = ptrace(PTRACE_SETREGSET, child, NT_ARM_TLS, &write_iov);\n\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\tread_iov.iov_len = sizeof(read_val);\n\t\t\tret = ptrace(PTRACE_GETREGSET, child, NT_ARM_TLS,\n\t\t\t\t     &read_iov);\n\n\t\t\tksft_test_result(ret == 0 &&\n\t\t\t\t\t read_iov.iov_len >= sizeof(read_val) &&\n\t\t\t\t\t memcmp(read_val, write_val,\n\t\t\t\t\t\tsizeof(read_val)) == 0,\n\t\t\t\t\t \"write_tpidr_only\\n\");\n\t\t} else {\n\t\t\tksft_test_result_fail(\"write_tpidr_only\\n\");\n\t\t}\n\t} else {\n\t\tksft_test_result_skip(\"tpidr2_write\\n\");\n\t\tksft_test_result_skip(\"tpidr2_read\\n\");\n\t\tksft_test_result_skip(\"write_tpidr_only\\n\");\n\t}\n}\n\nstatic void test_hw_debug(pid_t child, int type, const char *type_name)\n{\n\tstruct user_hwdebug_state state;\n\tstruct iovec iov;\n\tint slots, arch, ret;\n\n\tiov.iov_len = sizeof(state);\n\tiov.iov_base = &state;\n\n\t \n\tret = ptrace(PTRACE_GETREGSET, child, type, &iov);\n\tksft_test_result(ret == 0, \"read_%s\\n\", type_name);\n\n\tif (ret == 0) {\n\t\t \n\t\tslots = state.dbg_info & 0xff;\n\t\tarch = (state.dbg_info >> 8) & 0xf;\n\n\t\tksft_print_msg(\"%s version %d with %d slots\\n\", type_name,\n\t\t\t       arch, slots);\n\n\t\t \n\t\tksft_test_result(arch, \"%s_arch_set\\n\", type_name);\n\t} else {\n\t\tksft_test_result_skip(\"%s_arch_set\\n\");\n\t}\n}\n\nstatic int do_child(void)\n{\n\tif (ptrace(PTRACE_TRACEME, -1, NULL, NULL))\n\t\tksft_exit_fail_msg(\"PTRACE_TRACEME\", strerror(errno));\n\n\tif (raise(SIGSTOP))\n\t\tksft_exit_fail_msg(\"raise(SIGSTOP)\", strerror(errno));\n\n\treturn EXIT_SUCCESS;\n}\n\nstatic int do_parent(pid_t child)\n{\n\tint ret = EXIT_FAILURE;\n\tpid_t pid;\n\tint status;\n\tsiginfo_t si;\n\n\t \n\twhile (1) {\n\t\tint sig;\n\n\t\tpid = wait(&status);\n\t\tif (pid == -1) {\n\t\t\tperror(\"wait\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (pid != child)\n\t\t\tcontinue;\n\n\t\tif (WIFEXITED(status) || WIFSIGNALED(status))\n\t\t\tksft_exit_fail_msg(\"Child died unexpectedly\\n\");\n\n\t\tif (!WIFSTOPPED(status))\n\t\t\tgoto error;\n\n\t\tsig = WSTOPSIG(status);\n\n\t\tif (ptrace(PTRACE_GETSIGINFO, pid, NULL, &si)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tgoto disappeared;\n\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tsig = 0;  \n\t\t\t\tgoto cont;\n\t\t\t}\n\n\t\t\tksft_test_result_fail(\"PTRACE_GETSIGINFO: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sig == SIGSTOP && si.si_code == SI_TKILL &&\n\t\t    si.si_pid == pid)\n\t\t\tbreak;\n\n\tcont:\n\t\tif (ptrace(PTRACE_CONT, pid, NULL, sig)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tgoto disappeared;\n\n\t\t\tksft_test_result_fail(\"PTRACE_CONT: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tksft_print_msg(\"Parent is %d, child is %d\\n\", getpid(), child);\n\n\ttest_tpidr(child);\n\ttest_hw_debug(child, NT_ARM_HW_WATCH, \"NT_ARM_HW_WATCH\");\n\ttest_hw_debug(child, NT_ARM_HW_BREAK, \"NT_ARM_HW_BREAK\");\n\n\tret = EXIT_SUCCESS;\n\nerror:\n\tkill(child, SIGKILL);\n\ndisappeared:\n\treturn ret;\n}\n\nint main(void)\n{\n\tint ret = EXIT_SUCCESS;\n\tpid_t child;\n\n\tsrandom(getpid());\n\n\tksft_print_header();\n\n\tksft_set_plan(EXPECTED_TESTS);\n\n\tchild = fork();\n\tif (!child)\n\t\treturn do_child();\n\n\tif (do_parent(child))\n\t\tret = EXIT_FAILURE;\n\n\tksft_print_cnts();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}