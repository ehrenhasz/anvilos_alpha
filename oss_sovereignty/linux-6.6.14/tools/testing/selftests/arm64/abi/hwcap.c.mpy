{
  "module_name": "hwcap.c",
  "hash_id": "c3316b86fa9b42d90126436588c677bb8cdf6ccdca32c40c5d246a975ca1d465",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/abi/hwcap.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <asm/hwcap.h>\n#include <asm/sigcontext.h>\n#include <asm/unistd.h>\n\n#include \"../../kselftest.h\"\n\n#define TESTS_PER_HWCAP 3\n\n \ntypedef void (*sig_fn)(void);\n\nstatic void aes_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x4e284800\" : : : );\n}\n\nstatic void atomics_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0xb82003ff\" : : : );\n}\n\nstatic void crc32_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x1ac14800\" : : : );\n}\n\nstatic void cssc_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0xdac01c00\" : : : \"x0\");\n}\n\nstatic void fp_sigill(void)\n{\n\tasm volatile(\"fmov s0, #1\");\n}\n\nstatic void ilrcpc_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x994083e0\" : : : );\n}\n\nstatic void jscvt_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x1e7e0000\" : : : );\n}\n\nstatic void lrcpc_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0xb8bfc3e0\" : : : );\n}\n\nstatic void mops_sigill(void)\n{\n\tchar dst[1], src[1];\n\tregister char *dstp asm (\"x0\") = dst;\n\tregister char *srcp asm (\"x1\") = src;\n\tregister long size asm (\"x2\") = 1;\n\n\t \n\tasm volatile(\".inst 0x1d010440\"\n\t\t     : \"+r\" (dstp), \"+r\" (srcp), \"+r\" (size)\n\t\t     :\n\t\t     : \"cc\", \"memory\");\n}\n\nstatic void pmull_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x0ee0e000\" : : : );\n}\n\nstatic void rng_sigill(void)\n{\n\tasm volatile(\"mrs x0, S3_3_C2_C4_0\" : : : \"x0\");\n}\n\nstatic void sha1_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x5e280800\" : : : );\n}\n\nstatic void sha2_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x5e004000\" : : : );\n}\n\nstatic void sha512_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0xce608000\" : : : );\n}\n\nstatic void sme_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x04bf5800\" : : : \"x0\");\n}\n\nstatic void sme2_sigill(void)\n{\n\t \n\tasm volatile(\"msr S0_3_C4_C5_3, xzr\" : : : );\n\n\t \n\tasm volatile(\".inst 0xc0480001\" : : : );\n\n\t \n\tasm volatile(\"msr S0_3_C4_C6_3, xzr\" : : : );\n}\n\nstatic void sme2p1_sigill(void)\n{\n\t \n\tasm volatile(\"msr S0_3_C4_C3_3, xzr\" : : : );\n\n\t \n\tasm volatile(\".inst 0xc120C000\" : : : );\n\n\t \n\tasm volatile(\"msr S0_3_C4_C6_3, xzr\" : : : );\n}\n\nstatic void smei16i32_sigill(void)\n{\n\t \n\tasm volatile(\"msr S0_3_C4_C7_3, xzr\" : : : );\n\n\t \n\tasm volatile(\".inst 0xa0800000\" : : : );\n\n\t \n\tasm volatile(\"msr S0_3_C4_C6_3, xzr\" : : : );\n}\n\nstatic void smebi32i32_sigill(void)\n{\n\t \n\tasm volatile(\"msr S0_3_C4_C7_3, xzr\" : : : );\n\n\t \n\tasm volatile(\".inst 0x80800008\" : : : );\n\n\t \n\tasm volatile(\"msr S0_3_C4_C6_3, xzr\" : : : );\n}\n\nstatic void smeb16b16_sigill(void)\n{\n\t \n\tasm volatile(\"msr S0_3_C4_C7_3, xzr\" : : : );\n\n\t \n\tasm volatile(\".inst 0xC1E41C00\" : : : );\n\n\t \n\tasm volatile(\"msr S0_3_C4_C6_3, xzr\" : : : );\n}\n\nstatic void smef16f16_sigill(void)\n{\n\t \n\tasm volatile(\"msr S0_3_C4_C7_3, xzr\" : : : );\n\n\t \n\tasm volatile(\".inst 0xc1a41C00\" : : : );\n\n\t \n\tasm volatile(\"msr S0_3_C4_C6_3, xzr\" : : : );\n}\n\nstatic void sve_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x04bf5000\" : : : \"x0\");\n}\n\nstatic void sve2_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x4408A000\" : : : \"z0\");\n}\n\nstatic void sve2p1_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x65000000\" : : : \"z0\");\n}\n\nstatic void sveaes_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x4522e400\" : : : \"z0\");\n}\n\nstatic void svepmull_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x45006800\" : : : \"z0\");\n}\n\nstatic void svebitperm_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x4500b400\" : : : \"z0\");\n}\n\nstatic void svesha3_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x4203800\" : : : \"z0\");\n}\n\nstatic void svesm4_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x4523e000\" : : : \"z0\");\n}\n\nstatic void svei8mm_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x44a01800\" : : : \"z0\");\n}\n\nstatic void svef32mm_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x64a0e400\" : : : \"z0\");\n}\n\nstatic void svef64mm_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x64e0e400\" : : : \"z0\");\n}\n\nstatic void svebf16_sigill(void)\n{\n\t \n\tasm volatile(\".inst 0x658aa000\" : : : \"z0\");\n}\n\nstatic void hbc_sigill(void)\n{\n\t \n\tasm volatile(\"cmp xzr, xzr\\n\"\n\t\t     \".inst 0x54000030\" : : : \"cc\");\n}\n\nstatic void uscat_sigbus(void)\n{\n\t \n\tasm volatile(\"ADD x1, sp, #2\" : : : );\n\t \n\tasm volatile(\".inst 0xb820003f\" : : : );\n}\n\nstatic const struct hwcap_data {\n\tconst char *name;\n\tunsigned long at_hwcap;\n\tunsigned long hwcap_bit;\n\tconst char *cpuinfo;\n\tsig_fn sigill_fn;\n\tbool sigill_reliable;\n\tsig_fn sigbus_fn;\n\tbool sigbus_reliable;\n} hwcaps[] = {\n\t{\n\t\t.name = \"AES\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_AES,\n\t\t.cpuinfo = \"aes\",\n\t\t.sigill_fn = aes_sigill,\n\t},\n\t{\n\t\t.name = \"CRC32\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_CRC32,\n\t\t.cpuinfo = \"crc32\",\n\t\t.sigill_fn = crc32_sigill,\n\t},\n\t{\n\t\t.name = \"CSSC\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_CSSC,\n\t\t.cpuinfo = \"cssc\",\n\t\t.sigill_fn = cssc_sigill,\n\t},\n\t{\n\t\t.name = \"FP\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_FP,\n\t\t.cpuinfo = \"fp\",\n\t\t.sigill_fn = fp_sigill,\n\t},\n\t{\n\t\t.name = \"JSCVT\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_JSCVT,\n\t\t.cpuinfo = \"jscvt\",\n\t\t.sigill_fn = jscvt_sigill,\n\t},\n\t{\n\t\t.name = \"LRCPC\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_LRCPC,\n\t\t.cpuinfo = \"lrcpc\",\n\t\t.sigill_fn = lrcpc_sigill,\n\t},\n\t{\n\t\t.name = \"LRCPC2\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_ILRCPC,\n\t\t.cpuinfo = \"ilrcpc\",\n\t\t.sigill_fn = ilrcpc_sigill,\n\t},\n\t{\n\t\t.name = \"LSE\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_ATOMICS,\n\t\t.cpuinfo = \"atomics\",\n\t\t.sigill_fn = atomics_sigill,\n\t},\n\t{\n\t\t.name = \"LSE2\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_USCAT,\n\t\t.cpuinfo = \"uscat\",\n\t\t.sigill_fn = atomics_sigill,\n\t\t.sigbus_fn = uscat_sigbus,\n\t\t.sigbus_reliable = true,\n\t},\n\t{\n\t\t.name = \"MOPS\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_MOPS,\n\t\t.cpuinfo = \"mops\",\n\t\t.sigill_fn = mops_sigill,\n\t\t.sigill_reliable = true,\n\t},\n\t{\n\t\t.name = \"PMULL\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_PMULL,\n\t\t.cpuinfo = \"pmull\",\n\t\t.sigill_fn = pmull_sigill,\n\t},\n\t{\n\t\t.name = \"RNG\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_RNG,\n\t\t.cpuinfo = \"rng\",\n\t\t.sigill_fn = rng_sigill,\n\t},\n\t{\n\t\t.name = \"RPRFM\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_RPRFM,\n\t\t.cpuinfo = \"rprfm\",\n\t},\n\t{\n\t\t.name = \"SHA1\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_SHA1,\n\t\t.cpuinfo = \"sha1\",\n\t\t.sigill_fn = sha1_sigill,\n\t},\n\t{\n\t\t.name = \"SHA2\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_SHA2,\n\t\t.cpuinfo = \"sha2\",\n\t\t.sigill_fn = sha2_sigill,\n\t},\n\t{\n\t\t.name = \"SHA512\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_SHA512,\n\t\t.cpuinfo = \"sha512\",\n\t\t.sigill_fn = sha512_sigill,\n\t},\n\t{\n\t\t.name = \"SME\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SME,\n\t\t.cpuinfo = \"sme\",\n\t\t.sigill_fn = sme_sigill,\n\t\t.sigill_reliable = true,\n\t},\n\t{\n\t\t.name = \"SME2\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SME2,\n\t\t.cpuinfo = \"sme2\",\n\t\t.sigill_fn = sme2_sigill,\n\t\t.sigill_reliable = true,\n\t},\n\t{\n\t\t.name = \"SME 2.1\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SME2P1,\n\t\t.cpuinfo = \"sme2p1\",\n\t\t.sigill_fn = sme2p1_sigill,\n\t},\n\t{\n\t\t.name = \"SME I16I32\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SME_I16I32,\n\t\t.cpuinfo = \"smei16i32\",\n\t\t.sigill_fn = smei16i32_sigill,\n\t},\n\t{\n\t\t.name = \"SME BI32I32\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SME_BI32I32,\n\t\t.cpuinfo = \"smebi32i32\",\n\t\t.sigill_fn = smebi32i32_sigill,\n\t},\n\t{\n\t\t.name = \"SME B16B16\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SME_B16B16,\n\t\t.cpuinfo = \"smeb16b16\",\n\t\t.sigill_fn = smeb16b16_sigill,\n\t},\n\t{\n\t\t.name = \"SME F16F16\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SME_F16F16,\n\t\t.cpuinfo = \"smef16f16\",\n\t\t.sigill_fn = smef16f16_sigill,\n\t},\n\t{\n\t\t.name = \"SVE\",\n\t\t.at_hwcap = AT_HWCAP,\n\t\t.hwcap_bit = HWCAP_SVE,\n\t\t.cpuinfo = \"sve\",\n\t\t.sigill_fn = sve_sigill,\n\t\t.sigill_reliable = true,\n\t},\n\t{\n\t\t.name = \"SVE 2\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVE2,\n\t\t.cpuinfo = \"sve2\",\n\t\t.sigill_fn = sve2_sigill,\n\t},\n\t{\n\t\t.name = \"SVE 2.1\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVE2P1,\n\t\t.cpuinfo = \"sve2p1\",\n\t\t.sigill_fn = sve2p1_sigill,\n\t},\n\t{\n\t\t.name = \"SVE AES\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVEAES,\n\t\t.cpuinfo = \"sveaes\",\n\t\t.sigill_fn = sveaes_sigill,\n\t},\n\t{\n\t\t.name = \"SVE2 PMULL\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVEPMULL,\n\t\t.cpuinfo = \"svepmull\",\n\t\t.sigill_fn = svepmull_sigill,\n\t},\n\t{\n\t\t.name = \"SVE2 BITPERM\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVEBITPERM,\n\t\t.cpuinfo = \"svebitperm\",\n\t\t.sigill_fn = svebitperm_sigill,\n\t},\n\t{\n\t\t.name = \"SVE2 SHA3\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVESHA3,\n\t\t.cpuinfo = \"svesha3\",\n\t\t.sigill_fn = svesha3_sigill,\n\t},\n\t{\n\t\t.name = \"SVE2 SM4\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVESM4,\n\t\t.cpuinfo = \"svesm4\",\n\t\t.sigill_fn = svesm4_sigill,\n\t},\n\t{\n\t\t.name = \"SVE2 I8MM\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVEI8MM,\n\t\t.cpuinfo = \"svei8mm\",\n\t\t.sigill_fn = svei8mm_sigill,\n\t},\n\t{\n\t\t.name = \"SVE2 F32MM\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVEF32MM,\n\t\t.cpuinfo = \"svef32mm\",\n\t\t.sigill_fn = svef32mm_sigill,\n\t},\n\t{\n\t\t.name = \"SVE2 F64MM\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVEF64MM,\n\t\t.cpuinfo = \"svef64mm\",\n\t\t.sigill_fn = svef64mm_sigill,\n\t},\n\t{\n\t\t.name = \"SVE2 BF16\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVEBF16,\n\t\t.cpuinfo = \"svebf16\",\n\t\t.sigill_fn = svebf16_sigill,\n\t},\n\t{\n\t\t.name = \"SVE2 EBF16\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_SVE_EBF16,\n\t\t.cpuinfo = \"sveebf16\",\n\t},\n\t{\n\t\t.name = \"HBC\",\n\t\t.at_hwcap = AT_HWCAP2,\n\t\t.hwcap_bit = HWCAP2_HBC,\n\t\t.cpuinfo = \"hbc\",\n\t\t.sigill_fn = hbc_sigill,\n\t\t.sigill_reliable = true,\n\t},\n};\n\ntypedef void (*sighandler_fn)(int, siginfo_t *, void *);\n\n#define DEF_SIGHANDLER_FUNC(SIG, NUM)\t\t\t\t\t\\\nstatic bool seen_##SIG;\t\t\t\t\t\t\t\\\nstatic void handle_##SIG(int sig, siginfo_t *info, void *context)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tucontext_t *uc = context;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tseen_##SIG = true;\t\t\t\t\t\t\\\n\t \t\t\t\\\n\tuc->uc_mcontext.pc += 4;\t\t\t\t\t\\\n}\n\nDEF_SIGHANDLER_FUNC(sigill, SIGILL);\nDEF_SIGHANDLER_FUNC(sigbus, SIGBUS);\n\nbool cpuinfo_present(const char *name)\n{\n\tFILE *f;\n\tchar buf[2048], name_space[30], name_newline[30];\n\tchar *s;\n\n\t \n\tsnprintf(name_space, sizeof(name_space), \" %s \", name);\n\tsnprintf(name_newline, sizeof(name_newline), \" %s\\n\", name);\n\n\tf = fopen(\"/proc/cpuinfo\", \"r\");\n\tif (!f) {\n\t\tksft_print_msg(\"Failed to open /proc/cpuinfo\\n\");\n\t\treturn false;\n\t}\n\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\t \n\t\tif (strncmp(buf, \"Features\\t:\", strlen(\"Features\\t:\")) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tfclose(f);\n\n\t\ts = strstr(buf, name_space);\n\t\tif (s)\n\t\t\treturn true;\n\t\ts = strstr(buf, name_newline);\n\t\tif (s)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\tksft_print_msg(\"Failed to find Features in /proc/cpuinfo\\n\");\n\tfclose(f);\n\treturn false;\n}\n\nstatic int install_sigaction(int signum, sighandler_fn handler)\n{\n\tint ret;\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_RESTART | SA_SIGINFO;\n\tsigemptyset(&sa.sa_mask);\n\tret = sigaction(signum, &sa, NULL);\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"Failed to install SIGNAL handler: %s (%d)\\n\",\n\t\t\t\t   strerror(errno), errno);\n\n\treturn ret;\n}\n\nstatic void uninstall_sigaction(int signum)\n{\n\tif (sigaction(signum, NULL, NULL) < 0)\n\t\tksft_exit_fail_msg(\"Failed to uninstall SIGNAL handler: %s (%d)\\n\",\n\t\t\t\t   strerror(errno), errno);\n}\n\n#define DEF_INST_RAISE_SIG(SIG, NUM)\t\t\t\t\t\\\nstatic bool inst_raise_##SIG(const struct hwcap_data *hwcap,\t\t\\\n\t\t\t\tbool have_hwcap)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (!hwcap->SIG##_fn) {\t\t\t\t\t\t\\\n\t\tksft_test_result_skip(#SIG\"_%s\\n\", hwcap->name);\t\\\n\t\t \t\\\n\t\treturn true;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tinstall_sigaction(NUM, handle_##SIG);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tseen_##SIG = false;\t\t\t\t\t\t\\\n\thwcap->SIG##_fn();\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (have_hwcap) {\t\t\t\t\t\t\\\n\t\t \t\t\\\n\t\tksft_test_result(!seen_##SIG,\t\t\t\t\\\n\t\t\t\t#SIG\"_%s\\n\", hwcap->name);\t\t\\\n\t} else if (hwcap->SIG##_reliable) {\t\t\t\t\\\n\t\t \t\t\t\t\\\n\t\tksft_test_result(seen_##SIG,\t\t\t\t\\\n\t\t\t\t#SIG\"_%s\\n\", hwcap->name);\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\t \t\t\t\\\n\t\tksft_print_msg(#SIG\"_%sreported for %s\\n\",\t\t\\\n\t\t\t\tseen_##SIG ? \"\" : \"not \",\t\t\\\n\t\t\t\thwcap->name);\t\t\t\t\\\n\t\tksft_test_result_skip(#SIG\"_%s\\n\",\t\t\t\\\n\t\t\t\t\thwcap->name);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tuninstall_sigaction(NUM);\t\t\t\t\t\\\n\treturn seen_##SIG;\t\t\t\t\t\t\\\n}\n\nDEF_INST_RAISE_SIG(sigill, SIGILL);\nDEF_INST_RAISE_SIG(sigbus, SIGBUS);\n\nint main(void)\n{\n\tint i;\n\tconst struct hwcap_data *hwcap;\n\tbool have_cpuinfo, have_hwcap, raise_sigill;\n\n\tksft_print_header();\n\tksft_set_plan(ARRAY_SIZE(hwcaps) * TESTS_PER_HWCAP);\n\n\tfor (i = 0; i < ARRAY_SIZE(hwcaps); i++) {\n\t\thwcap = &hwcaps[i];\n\n\t\thave_hwcap = getauxval(hwcap->at_hwcap) & hwcap->hwcap_bit;\n\t\thave_cpuinfo = cpuinfo_present(hwcap->cpuinfo);\n\n\t\tif (have_hwcap)\n\t\t\tksft_print_msg(\"%s present\\n\", hwcap->name);\n\n\t\tksft_test_result(have_hwcap == have_cpuinfo,\n\t\t\t\t \"cpuinfo_match_%s\\n\", hwcap->name);\n\n\t\t \n\t\traise_sigill = inst_raise_sigill(hwcap, have_hwcap);\n\t\tif (!raise_sigill)\n\t\t\tinst_raise_sigbus(hwcap, have_hwcap);\n\t\telse\n\t\t\tksft_test_result_skip(\"sigbus_%s\\n\", hwcap->name);\n\t}\n\n\tksft_print_cnts();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}