{
  "module_name": "check_mmap_options.c",
  "hash_id": "a8cf9e83a1f5fa13dfd9a5babf5a0128288495144cad9b74827dd76ec130505f",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/mte/check_mmap_options.c",
  "human_readable_source": "\n\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ucontext.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include \"kselftest.h\"\n#include \"mte_common_util.h\"\n#include \"mte_def.h\"\n\n#define RUNS\t\t\t(MT_TAG_COUNT)\n#define UNDERFLOW\t\tMT_GRANULE_SIZE\n#define OVERFLOW\t\tMT_GRANULE_SIZE\n#define TAG_CHECK_ON\t\t0\n#define TAG_CHECK_OFF\t\t1\n\nstatic size_t page_size;\nstatic int sizes[] = {\n\t1, 537, 989, 1269, MT_GRANULE_SIZE - 1, MT_GRANULE_SIZE,\n\t  0,   0,   0\n};\n\nstatic int check_mte_memory(char *ptr, int size, int mode, int tag_check)\n{\n\tmte_initialize_current_context(mode, (uintptr_t)ptr, size);\n\tmemset(ptr, '1', size);\n\tmte_wait_after_trig();\n\tif (cur_mte_cxt.fault_valid == true)\n\t\treturn KSFT_FAIL;\n\n\tmte_initialize_current_context(mode, (uintptr_t)ptr, -UNDERFLOW);\n\tmemset(ptr - UNDERFLOW, '2', UNDERFLOW);\n\tmte_wait_after_trig();\n\tif (cur_mte_cxt.fault_valid == false && tag_check == TAG_CHECK_ON)\n\t\treturn KSFT_FAIL;\n\tif (cur_mte_cxt.fault_valid == true && tag_check == TAG_CHECK_OFF)\n\t\treturn KSFT_FAIL;\n\n\tmte_initialize_current_context(mode, (uintptr_t)ptr, size + OVERFLOW);\n\tmemset(ptr + size, '3', OVERFLOW);\n\tmte_wait_after_trig();\n\tif (cur_mte_cxt.fault_valid == false && tag_check == TAG_CHECK_ON)\n\t\treturn KSFT_FAIL;\n\tif (cur_mte_cxt.fault_valid == true && tag_check == TAG_CHECK_OFF)\n\t\treturn KSFT_FAIL;\n\n\treturn KSFT_PASS;\n}\n\nstatic int check_anonymous_memory_mapping(int mem_type, int mode, int mapping, int tag_check)\n{\n\tchar *ptr, *map_ptr;\n\tint run, result, map_size;\n\tint item = ARRAY_SIZE(sizes);\n\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\tfor (run = 0; run < item; run++) {\n\t\tmap_size = sizes[run] + OVERFLOW + UNDERFLOW;\n\t\tmap_ptr = (char *)mte_allocate_memory(map_size, mem_type, mapping, false);\n\t\tif (check_allocated_memory(map_ptr, map_size, mem_type, false) != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\n\t\tptr = map_ptr + UNDERFLOW;\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, sizes[run]);\n\t\t \n\t\tptr = mte_insert_tags((void *)ptr, sizes[run]);\n\t\tif (!ptr || cur_mte_cxt.fault_valid == true) {\n\t\t\tksft_print_msg(\"FAIL: Insert tags on anonymous mmap memory\\n\");\n\t\t\tmunmap((void *)map_ptr, map_size);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tresult = check_mte_memory(ptr, sizes[run], mode, tag_check);\n\t\tmte_clear_tags((void *)ptr, sizes[run]);\n\t\tmte_free_memory((void *)map_ptr, map_size, mem_type, false);\n\t\tif (result == KSFT_FAIL)\n\t\t\treturn KSFT_FAIL;\n\t}\n\treturn KSFT_PASS;\n}\n\nstatic int check_file_memory_mapping(int mem_type, int mode, int mapping, int tag_check)\n{\n\tchar *ptr, *map_ptr;\n\tint run, fd, map_size;\n\tint total = ARRAY_SIZE(sizes);\n\tint result = KSFT_PASS;\n\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\tfor (run = 0; run < total; run++) {\n\t\tfd = create_temp_file();\n\t\tif (fd == -1)\n\t\t\treturn KSFT_FAIL;\n\n\t\tmap_size = sizes[run] + UNDERFLOW + OVERFLOW;\n\t\tmap_ptr = (char *)mte_allocate_file_memory(map_size, mem_type, mapping, false, fd);\n\t\tif (check_allocated_memory(map_ptr, map_size, mem_type, false) != KSFT_PASS) {\n\t\t\tclose(fd);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tptr = map_ptr + UNDERFLOW;\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, sizes[run]);\n\t\t \n\t\tptr = mte_insert_tags((void *)ptr, sizes[run]);\n\t\tif (!ptr || cur_mte_cxt.fault_valid == true) {\n\t\t\tksft_print_msg(\"FAIL: Insert tags on file based memory\\n\");\n\t\t\tmunmap((void *)map_ptr, map_size);\n\t\t\tclose(fd);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tresult = check_mte_memory(ptr, sizes[run], mode, tag_check);\n\t\tmte_clear_tags((void *)ptr, sizes[run]);\n\t\tmunmap((void *)map_ptr, map_size);\n\t\tclose(fd);\n\t\tif (result == KSFT_FAIL)\n\t\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic int check_clear_prot_mte_flag(int mem_type, int mode, int mapping)\n{\n\tchar *ptr, *map_ptr;\n\tint run, prot_flag, result, fd, map_size;\n\tint total = ARRAY_SIZE(sizes);\n\n\tprot_flag = PROT_READ | PROT_WRITE;\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\tfor (run = 0; run < total; run++) {\n\t\tmap_size = sizes[run] + OVERFLOW + UNDERFLOW;\n\t\tptr = (char *)mte_allocate_memory_tag_range(sizes[run], mem_type, mapping,\n\t\t\t\t\t\t\t    UNDERFLOW, OVERFLOW);\n\t\tif (check_allocated_memory_range(ptr, sizes[run], mem_type,\n\t\t\t\t\t\t UNDERFLOW, OVERFLOW) != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\t\tmap_ptr = ptr - UNDERFLOW;\n\t\t \n\t\tif (mprotect(map_ptr, map_size, prot_flag)) {\n\t\t\tmte_free_memory_tag_range((void *)ptr, sizes[run], mem_type,\n\t\t\t\t\t\t  UNDERFLOW, OVERFLOW);\n\t\t\tksft_print_msg(\"FAIL: mprotect not ignoring clear PROT_MTE property\\n\");\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tresult = check_mte_memory(ptr, sizes[run], mode, TAG_CHECK_ON);\n\t\tmte_free_memory_tag_range((void *)ptr, sizes[run], mem_type, UNDERFLOW, OVERFLOW);\n\t\tif (result != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\n\t\tfd = create_temp_file();\n\t\tif (fd == -1)\n\t\t\treturn KSFT_FAIL;\n\t\tptr = (char *)mte_allocate_file_memory_tag_range(sizes[run], mem_type, mapping,\n\t\t\t\t\t\t\t\t UNDERFLOW, OVERFLOW, fd);\n\t\tif (check_allocated_memory_range(ptr, sizes[run], mem_type,\n\t\t\t\t\t\t UNDERFLOW, OVERFLOW) != KSFT_PASS) {\n\t\t\tclose(fd);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tmap_ptr = ptr - UNDERFLOW;\n\t\t \n\t\tif (mprotect(map_ptr, map_size, prot_flag)) {\n\t\t\tksft_print_msg(\"FAIL: mprotect not ignoring clear PROT_MTE property\\n\");\n\t\t\tmte_free_memory_tag_range((void *)ptr, sizes[run], mem_type,\n\t\t\t\t\t\t  UNDERFLOW, OVERFLOW);\n\t\t\tclose(fd);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tresult = check_mte_memory(ptr, sizes[run], mode, TAG_CHECK_ON);\n\t\tmte_free_memory_tag_range((void *)ptr, sizes[run], mem_type, UNDERFLOW, OVERFLOW);\n\t\tclose(fd);\n\t\tif (result != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\t}\n\treturn KSFT_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\tint err;\n\tint item = ARRAY_SIZE(sizes);\n\n\terr = mte_default_setup();\n\tif (err)\n\t\treturn err;\n\tpage_size = getpagesize();\n\tif (!page_size) {\n\t\tksft_print_msg(\"ERR: Unable to get page size\\n\");\n\t\treturn KSFT_FAIL;\n\t}\n\tsizes[item - 3] = page_size - 1;\n\tsizes[item - 2] = page_size;\n\tsizes[item - 1] = page_size + 1;\n\n\t \n\tmte_register_signal(SIGBUS, mte_default_handler);\n\tmte_register_signal(SIGSEGV, mte_default_handler);\n\n\t \n\tksft_set_plan(22);\n\n\tmte_enable_pstate_tco();\n\n\tevaluate_test(check_anonymous_memory_mapping(USE_MMAP, MTE_SYNC_ERR, MAP_PRIVATE, TAG_CHECK_OFF),\n\t\"Check anonymous memory with private mapping, sync error mode, mmap memory and tag check off\\n\");\n\tevaluate_test(check_file_memory_mapping(USE_MPROTECT, MTE_SYNC_ERR, MAP_PRIVATE, TAG_CHECK_OFF),\n\t\"Check file memory with private mapping, sync error mode, mmap/mprotect memory and tag check off\\n\");\n\n\tmte_disable_pstate_tco();\n\tevaluate_test(check_anonymous_memory_mapping(USE_MMAP, MTE_NONE_ERR, MAP_PRIVATE, TAG_CHECK_OFF),\n\t\"Check anonymous memory with private mapping, no error mode, mmap memory and tag check off\\n\");\n\tevaluate_test(check_file_memory_mapping(USE_MPROTECT, MTE_NONE_ERR, MAP_PRIVATE, TAG_CHECK_OFF),\n\t\"Check file memory with private mapping, no error mode, mmap/mprotect memory and tag check off\\n\");\n\n\tevaluate_test(check_anonymous_memory_mapping(USE_MMAP, MTE_SYNC_ERR, MAP_PRIVATE, TAG_CHECK_ON),\n\t\"Check anonymous memory with private mapping, sync error mode, mmap memory and tag check on\\n\");\n\tevaluate_test(check_anonymous_memory_mapping(USE_MPROTECT, MTE_SYNC_ERR, MAP_PRIVATE, TAG_CHECK_ON),\n\t\"Check anonymous memory with private mapping, sync error mode, mmap/mprotect memory and tag check on\\n\");\n\tevaluate_test(check_anonymous_memory_mapping(USE_MMAP, MTE_SYNC_ERR, MAP_SHARED, TAG_CHECK_ON),\n\t\"Check anonymous memory with shared mapping, sync error mode, mmap memory and tag check on\\n\");\n\tevaluate_test(check_anonymous_memory_mapping(USE_MPROTECT, MTE_SYNC_ERR, MAP_SHARED, TAG_CHECK_ON),\n\t\"Check anonymous memory with shared mapping, sync error mode, mmap/mprotect memory and tag check on\\n\");\n\tevaluate_test(check_anonymous_memory_mapping(USE_MMAP, MTE_ASYNC_ERR, MAP_PRIVATE, TAG_CHECK_ON),\n\t\"Check anonymous memory with private mapping, async error mode, mmap memory and tag check on\\n\");\n\tevaluate_test(check_anonymous_memory_mapping(USE_MPROTECT, MTE_ASYNC_ERR, MAP_PRIVATE, TAG_CHECK_ON),\n\t\"Check anonymous memory with private mapping, async error mode, mmap/mprotect memory and tag check on\\n\");\n\tevaluate_test(check_anonymous_memory_mapping(USE_MMAP, MTE_ASYNC_ERR, MAP_SHARED, TAG_CHECK_ON),\n\t\"Check anonymous memory with shared mapping, async error mode, mmap memory and tag check on\\n\");\n\tevaluate_test(check_anonymous_memory_mapping(USE_MPROTECT, MTE_ASYNC_ERR, MAP_SHARED, TAG_CHECK_ON),\n\t\"Check anonymous memory with shared mapping, async error mode, mmap/mprotect memory and tag check on\\n\");\n\n\tevaluate_test(check_file_memory_mapping(USE_MMAP, MTE_SYNC_ERR, MAP_PRIVATE, TAG_CHECK_ON),\n\t\"Check file memory with private mapping, sync error mode, mmap memory and tag check on\\n\");\n\tevaluate_test(check_file_memory_mapping(USE_MPROTECT, MTE_SYNC_ERR, MAP_PRIVATE, TAG_CHECK_ON),\n\t\"Check file memory with private mapping, sync error mode, mmap/mprotect memory and tag check on\\n\");\n\tevaluate_test(check_file_memory_mapping(USE_MMAP, MTE_SYNC_ERR, MAP_SHARED, TAG_CHECK_ON),\n\t\"Check file memory with shared mapping, sync error mode, mmap memory and tag check on\\n\");\n\tevaluate_test(check_file_memory_mapping(USE_MPROTECT, MTE_SYNC_ERR, MAP_SHARED, TAG_CHECK_ON),\n\t\"Check file memory with shared mapping, sync error mode, mmap/mprotect memory and tag check on\\n\");\n\tevaluate_test(check_file_memory_mapping(USE_MMAP, MTE_ASYNC_ERR, MAP_PRIVATE, TAG_CHECK_ON),\n\t\"Check file memory with private mapping, async error mode, mmap memory and tag check on\\n\");\n\tevaluate_test(check_file_memory_mapping(USE_MPROTECT, MTE_ASYNC_ERR, MAP_PRIVATE, TAG_CHECK_ON),\n\t\"Check file memory with private mapping, async error mode, mmap/mprotect memory and tag check on\\n\");\n\tevaluate_test(check_file_memory_mapping(USE_MMAP, MTE_ASYNC_ERR, MAP_SHARED, TAG_CHECK_ON),\n\t\"Check file memory with shared mapping, async error mode, mmap memory and tag check on\\n\");\n\tevaluate_test(check_file_memory_mapping(USE_MPROTECT, MTE_ASYNC_ERR, MAP_SHARED, TAG_CHECK_ON),\n\t\"Check file memory with shared mapping, async error mode, mmap/mprotect memory and tag check on\\n\");\n\n\tevaluate_test(check_clear_prot_mte_flag(USE_MMAP, MTE_SYNC_ERR, MAP_PRIVATE),\n\t\"Check clear PROT_MTE flags with private mapping, sync error mode and mmap memory\\n\");\n\tevaluate_test(check_clear_prot_mte_flag(USE_MPROTECT, MTE_SYNC_ERR, MAP_PRIVATE),\n\t\"Check clear PROT_MTE flags with private mapping and sync error mode and mmap/mprotect memory\\n\");\n\n\tmte_restore_setup();\n\tksft_print_cnts();\n\treturn ksft_get_fail_cnt() == 0 ? KSFT_PASS : KSFT_FAIL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}