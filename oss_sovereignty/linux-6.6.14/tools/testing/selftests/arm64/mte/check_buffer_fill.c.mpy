{
  "module_name": "check_buffer_fill.c",
  "hash_id": "dad5e0a620e872b8c3d225667ba8c42c4e3096b8e961243d8e8ce8245a0fa268",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/mte/check_buffer_fill.c",
  "human_readable_source": "\n\n\n#define _GNU_SOURCE\n\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"kselftest.h\"\n#include \"mte_common_util.h\"\n#include \"mte_def.h\"\n\n#define OVERFLOW_RANGE MT_GRANULE_SIZE\n\nstatic int sizes[] = {\n\t1, 555, 1033, MT_GRANULE_SIZE - 1, MT_GRANULE_SIZE,\n\t  0,   0,   0\n};\n\nenum mte_block_test_alloc {\n\tUNTAGGED_TAGGED,\n\tTAGGED_UNTAGGED,\n\tTAGGED_TAGGED,\n\tBLOCK_ALLOC_MAX,\n};\n\nstatic int check_buffer_by_byte(int mem_type, int mode)\n{\n\tchar *ptr;\n\tint i, j, item;\n\tbool err;\n\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\titem = ARRAY_SIZE(sizes);\n\n\tfor (i = 0; i < item; i++) {\n\t\tptr = (char *)mte_allocate_memory(sizes[i], mem_type, 0, true);\n\t\tif (check_allocated_memory(ptr, sizes[i], mem_type, true) != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, sizes[i]);\n\t\t \n\t\tfor (j = 0; j < sizes[i]; j++)\n\t\t\tptr[j] = '1';\n\t\tmte_wait_after_trig();\n\t\terr = cur_mte_cxt.fault_valid;\n\t\t \n\t\tfor (j = 0; j < sizes[i] && !err; j++) {\n\t\t\tif (ptr[j] != '1')\n\t\t\t\terr = true;\n\t\t}\n\t\tmte_free_memory((void *)ptr, sizes[i], mem_type, true);\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (!err)\n\t\treturn KSFT_PASS;\n\telse\n\t\treturn KSFT_FAIL;\n}\n\nstatic int check_buffer_underflow_by_byte(int mem_type, int mode,\n\t\t\t\t\t  int underflow_range)\n{\n\tchar *ptr;\n\tint i, j, item, last_index;\n\tbool err;\n\tchar *und_ptr = NULL;\n\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\titem = ARRAY_SIZE(sizes);\n\tfor (i = 0; i < item; i++) {\n\t\tptr = (char *)mte_allocate_memory_tag_range(sizes[i], mem_type, 0,\n\t\t\t\t\t\t\t    underflow_range, 0);\n\t\tif (check_allocated_memory_range(ptr, sizes[i], mem_type,\n\t\t\t\t\t       underflow_range, 0) != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, -underflow_range);\n\t\tlast_index = 0;\n\t\t \n\t\tfor (j = sizes[i] - 1; (j >= -underflow_range) &&\n\t\t\t\t       (!cur_mte_cxt.fault_valid); j--) {\n\t\t\tptr[j] = '1';\n\t\t\tlast_index = j;\n\t\t}\n\t\tmte_wait_after_trig();\n\t\terr = false;\n\t\t \n\t\tfor (j = 0; j < sizes[i]; j++) {\n\t\t\tif (ptr[j] != '1') {\n\t\t\t\terr = true;\n\t\t\t\tksft_print_msg(\"Buffer is not filled at index:%d of ptr:0x%lx\\n\",\n\t\t\t\t\t\tj, ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (err)\n\t\t\tgoto check_buffer_underflow_by_byte_err;\n\n\t\tswitch (mode) {\n\t\tcase MTE_NONE_ERR:\n\t\t\tif (cur_mte_cxt.fault_valid == true || last_index != -underflow_range) {\n\t\t\t\terr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tund_ptr = (char *) MT_CLEAR_TAG((size_t) ptr - underflow_range);\n\t\t\tfor (j = 0 ; j < underflow_range; j++) {\n\t\t\t\tif (und_ptr[j] != '1') {\n\t\t\t\t\terr = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MTE_ASYNC_ERR:\n\t\t\t \n\t\t\tif (cur_mte_cxt.fault_valid == false) {\n\t\t\t\terr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tund_ptr = (char *) MT_CLEAR_TAG((size_t) ptr);\n\t\t\tfor (j = last_index ; j < 0 ; j++) {\n\t\t\t\tif (und_ptr[j] != '1') {\n\t\t\t\t\terr = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MTE_SYNC_ERR:\n\t\t\t \n\t\t\tif (!cur_mte_cxt.fault_valid || (last_index != (-1))) {\n\t\t\t\terr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tund_ptr = (char *) MT_CLEAR_TAG((size_t) ptr);\n\t\t\tif (und_ptr[-1] == '1')\n\t\t\t\terr = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = true;\n\t\tbreak;\n\t\t}\ncheck_buffer_underflow_by_byte_err:\n\t\tmte_free_memory_tag_range((void *)ptr, sizes[i], mem_type, underflow_range, 0);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn (err ? KSFT_FAIL : KSFT_PASS);\n}\n\nstatic int check_buffer_overflow_by_byte(int mem_type, int mode,\n\t\t\t\t\t  int overflow_range)\n{\n\tchar *ptr;\n\tint i, j, item, last_index;\n\tbool err;\n\tsize_t tagged_size, overflow_size;\n\tchar *over_ptr = NULL;\n\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\titem = ARRAY_SIZE(sizes);\n\tfor (i = 0; i < item; i++) {\n\t\tptr = (char *)mte_allocate_memory_tag_range(sizes[i], mem_type, 0,\n\t\t\t\t\t\t\t    0, overflow_range);\n\t\tif (check_allocated_memory_range(ptr, sizes[i], mem_type,\n\t\t\t\t\t\t 0, overflow_range) != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\n\t\ttagged_size = MT_ALIGN_UP(sizes[i]);\n\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, sizes[i] + overflow_range);\n\n\t\t \n\t\tfor (j = 0, last_index = 0 ; (j < (sizes[i] + overflow_range)) &&\n\t\t\t\t\t     (cur_mte_cxt.fault_valid == false); j++) {\n\t\t\tptr[j] = '1';\n\t\t\tlast_index = j;\n\t\t}\n\t\tmte_wait_after_trig();\n\t\terr = false;\n\t\t \n\t\tfor (j = 0; j < sizes[i]; j++) {\n\t\t\tif (ptr[j] != '1') {\n\t\t\t\terr = true;\n\t\t\t\tksft_print_msg(\"Buffer is not filled at index:%d of ptr:0x%lx\\n\",\n\t\t\t\t\t\tj, ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (err)\n\t\t\tgoto check_buffer_overflow_by_byte_err;\n\n\t\toverflow_size = overflow_range - (tagged_size - sizes[i]);\n\n\t\tswitch (mode) {\n\t\tcase MTE_NONE_ERR:\n\t\t\tif ((cur_mte_cxt.fault_valid == true) ||\n\t\t\t    (last_index != (sizes[i] + overflow_range - 1))) {\n\t\t\t\terr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tover_ptr = (char *) MT_CLEAR_TAG((size_t) ptr + tagged_size);\n\t\t\tfor (j = 0 ; j < overflow_size; j++) {\n\t\t\t\tif (over_ptr[j] != '1') {\n\t\t\t\t\terr = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MTE_ASYNC_ERR:\n\t\t\t \n\t\t\tif (cur_mte_cxt.fault_valid == false) {\n\t\t\t\terr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tover_ptr = (char *) MT_CLEAR_TAG((size_t) ptr);\n\t\t\tfor (j = tagged_size ; j < last_index; j++) {\n\t\t\t\tif (over_ptr[j] != '1') {\n\t\t\t\t\terr = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MTE_SYNC_ERR:\n\t\t\t \n\t\t\tif (!cur_mte_cxt.fault_valid || (last_index != tagged_size)) {\n\t\t\t\terr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tover_ptr = (char *) MT_CLEAR_TAG((size_t) ptr + tagged_size);\n\t\t\tfor (j = 0 ; j < overflow_size; j++) {\n\t\t\t\tif (over_ptr[j] == '1')\n\t\t\t\t\terr = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = true;\n\t\tbreak;\n\t\t}\ncheck_buffer_overflow_by_byte_err:\n\t\tmte_free_memory_tag_range((void *)ptr, sizes[i], mem_type, 0, overflow_range);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn (err ? KSFT_FAIL : KSFT_PASS);\n}\n\nstatic int check_buffer_by_block_iterate(int mem_type, int mode, size_t size)\n{\n\tchar *src, *dst;\n\tint j, result = KSFT_PASS;\n\tenum mte_block_test_alloc alloc_type = UNTAGGED_TAGGED;\n\n\tfor (alloc_type = UNTAGGED_TAGGED; alloc_type < (int) BLOCK_ALLOC_MAX; alloc_type++) {\n\t\tswitch (alloc_type) {\n\t\tcase UNTAGGED_TAGGED:\n\t\t\tsrc = (char *)mte_allocate_memory(size, mem_type, 0, false);\n\t\t\tif (check_allocated_memory(src, size, mem_type, false) != KSFT_PASS)\n\t\t\t\treturn KSFT_FAIL;\n\n\t\t\tdst = (char *)mte_allocate_memory(size, mem_type, 0, true);\n\t\t\tif (check_allocated_memory(dst, size, mem_type, true) != KSFT_PASS) {\n\t\t\t\tmte_free_memory((void *)src, size, mem_type, false);\n\t\t\t\treturn KSFT_FAIL;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase TAGGED_UNTAGGED:\n\t\t\tdst = (char *)mte_allocate_memory(size, mem_type, 0, false);\n\t\t\tif (check_allocated_memory(dst, size, mem_type, false) != KSFT_PASS)\n\t\t\t\treturn KSFT_FAIL;\n\n\t\t\tsrc = (char *)mte_allocate_memory(size, mem_type, 0, true);\n\t\t\tif (check_allocated_memory(src, size, mem_type, true) != KSFT_PASS) {\n\t\t\t\tmte_free_memory((void *)dst, size, mem_type, false);\n\t\t\t\treturn KSFT_FAIL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAGGED_TAGGED:\n\t\t\tsrc = (char *)mte_allocate_memory(size, mem_type, 0, true);\n\t\t\tif (check_allocated_memory(src, size, mem_type, true) != KSFT_PASS)\n\t\t\t\treturn KSFT_FAIL;\n\n\t\t\tdst = (char *)mte_allocate_memory(size, mem_type, 0, true);\n\t\t\tif (check_allocated_memory(dst, size, mem_type, true) != KSFT_PASS) {\n\t\t\t\tmte_free_memory((void *)src, size, mem_type, true);\n\t\t\t\treturn KSFT_FAIL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\n\t\tcur_mte_cxt.fault_valid = false;\n\t\tresult = KSFT_PASS;\n\t\tmte_initialize_current_context(mode, (uintptr_t)dst, size);\n\t\t \n\t\tmemset((void *)src, (int)'1', size);\n\t\tmemcpy((void *)dst, (void *)src, size);\n\t\tmte_wait_after_trig();\n\t\tif (cur_mte_cxt.fault_valid) {\n\t\t\tresult = KSFT_FAIL;\n\t\t\tgoto check_buffer_by_block_err;\n\t\t}\n\t\t \n\t\tfor (j = 0; j < size; j++) {\n\t\t\tif (src[j] != dst[j] || src[j] != '1') {\n\t\t\t\tresult = KSFT_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\ncheck_buffer_by_block_err:\n\t\tmte_free_memory((void *)src, size, mem_type,\n\t\t\t\tMT_FETCH_TAG((uintptr_t)src) ? true : false);\n\t\tmte_free_memory((void *)dst, size, mem_type,\n\t\t\t\tMT_FETCH_TAG((uintptr_t)dst) ? true : false);\n\t\tif (result != KSFT_PASS)\n\t\t\treturn result;\n\t}\n\treturn result;\n}\n\nstatic int check_buffer_by_block(int mem_type, int mode)\n{\n\tint i, item, result = KSFT_PASS;\n\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\titem = ARRAY_SIZE(sizes);\n\tcur_mte_cxt.fault_valid = false;\n\tfor (i = 0; i < item; i++) {\n\t\tresult = check_buffer_by_block_iterate(mem_type, mode, sizes[i]);\n\t\tif (result != KSFT_PASS)\n\t\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic int compare_memory_tags(char *ptr, size_t size, int tag)\n{\n\tint i, new_tag;\n\n\tfor (i = 0 ; i < size ; i += MT_GRANULE_SIZE) {\n\t\tnew_tag = MT_FETCH_TAG((uintptr_t)(mte_get_tag_address(ptr + i)));\n\t\tif (tag != new_tag) {\n\t\t\tksft_print_msg(\"FAIL: child mte tag mismatch\\n\");\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t}\n\treturn KSFT_PASS;\n}\n\nstatic int check_memory_initial_tags(int mem_type, int mode, int mapping)\n{\n\tchar *ptr;\n\tint run, fd;\n\tint total = ARRAY_SIZE(sizes);\n\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\tfor (run = 0; run < total; run++) {\n\t\t \n\t\tptr = (char *)mte_allocate_memory(sizes[run], mem_type, mapping, false);\n\t\tif (check_allocated_memory(ptr, sizes[run], mem_type, false) != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\t\tif (compare_memory_tags(ptr, sizes[run], 0) != KSFT_PASS) {\n\t\t\tmte_free_memory((void *)ptr, sizes[run], mem_type, false);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tmte_free_memory((void *)ptr, sizes[run], mem_type, false);\n\n\t\t \n\t\tfd = create_temp_file();\n\t\tif (fd == -1)\n\t\t\treturn KSFT_FAIL;\n\t\tptr = (char *)mte_allocate_file_memory(sizes[run], mem_type, mapping, false, fd);\n\t\tif (check_allocated_memory(ptr, sizes[run], mem_type, false) != KSFT_PASS) {\n\t\t\tclose(fd);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tif (compare_memory_tags(ptr, sizes[run], 0) != KSFT_PASS) {\n\t\t\tmte_free_memory((void *)ptr, sizes[run], mem_type, false);\n\t\t\tclose(fd);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tmte_free_memory((void *)ptr, sizes[run], mem_type, false);\n\t\tclose(fd);\n\t}\n\treturn KSFT_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\tint err;\n\tsize_t page_size = getpagesize();\n\tint item = ARRAY_SIZE(sizes);\n\n\tsizes[item - 3] = page_size - 1;\n\tsizes[item - 2] = page_size;\n\tsizes[item - 1] = page_size + 1;\n\n\terr = mte_default_setup();\n\tif (err)\n\t\treturn err;\n\n\t \n\tmte_register_signal(SIGSEGV, mte_default_handler);\n\n\t \n\tksft_set_plan(20);\n\n\t \n\tevaluate_test(check_buffer_by_byte(USE_MMAP, MTE_SYNC_ERR),\n\t\"Check buffer correctness by byte with sync err mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_by_byte(USE_MMAP, MTE_ASYNC_ERR),\n\t\"Check buffer correctness by byte with async err mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_by_byte(USE_MPROTECT, MTE_SYNC_ERR),\n\t\"Check buffer correctness by byte with sync err mode and mmap/mprotect memory\\n\");\n\tevaluate_test(check_buffer_by_byte(USE_MPROTECT, MTE_ASYNC_ERR),\n\t\"Check buffer correctness by byte with async err mode and mmap/mprotect memory\\n\");\n\n\t \n\tevaluate_test(check_buffer_underflow_by_byte(USE_MMAP, MTE_SYNC_ERR, MT_GRANULE_SIZE),\n\t\"Check buffer write underflow by byte with sync mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_underflow_by_byte(USE_MMAP, MTE_ASYNC_ERR, MT_GRANULE_SIZE),\n\t\"Check buffer write underflow by byte with async mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_underflow_by_byte(USE_MMAP, MTE_NONE_ERR, MT_GRANULE_SIZE),\n\t\"Check buffer write underflow by byte with tag check fault ignore and mmap memory\\n\");\n\n\t \n\tevaluate_test(check_buffer_underflow_by_byte(USE_MMAP, MTE_SYNC_ERR, page_size),\n\t\"Check buffer write underflow by byte with sync mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_underflow_by_byte(USE_MMAP, MTE_ASYNC_ERR, page_size),\n\t\"Check buffer write underflow by byte with async mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_underflow_by_byte(USE_MMAP, MTE_NONE_ERR, page_size),\n\t\"Check buffer write underflow by byte with tag check fault ignore and mmap memory\\n\");\n\n\t \n\tevaluate_test(check_buffer_overflow_by_byte(USE_MMAP, MTE_SYNC_ERR, MT_GRANULE_SIZE),\n\t\"Check buffer write overflow by byte with sync mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_overflow_by_byte(USE_MMAP, MTE_ASYNC_ERR, MT_GRANULE_SIZE),\n\t\"Check buffer write overflow by byte with async mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_overflow_by_byte(USE_MMAP, MTE_NONE_ERR, MT_GRANULE_SIZE),\n\t\"Check buffer write overflow by byte with tag fault ignore mode and mmap memory\\n\");\n\n\t \n\tevaluate_test(check_buffer_by_block(USE_MMAP, MTE_SYNC_ERR),\n\t\"Check buffer write correctness by block with sync mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_by_block(USE_MMAP, MTE_ASYNC_ERR),\n\t\"Check buffer write correctness by block with async mode and mmap memory\\n\");\n\tevaluate_test(check_buffer_by_block(USE_MMAP, MTE_NONE_ERR),\n\t\"Check buffer write correctness by block with tag fault ignore and mmap memory\\n\");\n\n\t \n\tevaluate_test(check_memory_initial_tags(USE_MMAP, MTE_SYNC_ERR, MAP_PRIVATE),\n\t\"Check initial tags with private mapping, sync error mode and mmap memory\\n\");\n\tevaluate_test(check_memory_initial_tags(USE_MPROTECT, MTE_SYNC_ERR, MAP_PRIVATE),\n\t\"Check initial tags with private mapping, sync error mode and mmap/mprotect memory\\n\");\n\tevaluate_test(check_memory_initial_tags(USE_MMAP, MTE_SYNC_ERR, MAP_SHARED),\n\t\"Check initial tags with shared mapping, sync error mode and mmap memory\\n\");\n\tevaluate_test(check_memory_initial_tags(USE_MPROTECT, MTE_SYNC_ERR, MAP_SHARED),\n\t\"Check initial tags with shared mapping, sync error mode and mmap/mprotect memory\\n\");\n\n\tmte_restore_setup();\n\tksft_print_cnts();\n\treturn ksft_get_fail_cnt() == 0 ? KSFT_PASS : KSFT_FAIL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}