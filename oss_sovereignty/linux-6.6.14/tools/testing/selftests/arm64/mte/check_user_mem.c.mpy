{
  "module_name": "check_user_mem.c",
  "hash_id": "0fb774c5e170ed76ecf6977e009fd11b81200826d7a14dd9ceb8df585b99e2e9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/mte/check_user_mem.c",
  "human_readable_source": "\n\n\n#define _GNU_SOURCE\n\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ucontext.h>\n#include <unistd.h>\n#include <sys/uio.h>\n#include <sys/mman.h>\n\n#include \"kselftest.h\"\n#include \"mte_common_util.h\"\n#include \"mte_def.h\"\n\nstatic size_t page_sz;\n\n#define TEST_NAME_MAX 100\n\nenum test_type {\n\tREAD_TEST,\n\tWRITE_TEST,\n\tREADV_TEST,\n\tWRITEV_TEST,\n\tLAST_TEST,\n};\n\nstatic int check_usermem_access_fault(int mem_type, int mode, int mapping,\n                                      int tag_offset, int tag_len,\n                                      enum test_type test_type)\n{\n\tint fd, i, err;\n\tchar val = 'A';\n\tssize_t len, syscall_len;\n\tvoid *ptr, *ptr_next;\n\tint fileoff, ptroff, size;\n\tint sizes[] = {1, 2, 3, 8, 16, 32, 4096, page_sz};\n\n\terr = KSFT_PASS;\n\tlen = 2 * page_sz;\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\tfd = create_temp_file();\n\tif (fd == -1)\n\t\treturn KSFT_FAIL;\n\tfor (i = 0; i < len; i++)\n\t\tif (write(fd, &val, sizeof(val)) != sizeof(val))\n\t\t\treturn KSFT_FAIL;\n\tlseek(fd, 0, 0);\n\tptr = mte_allocate_memory(len, mem_type, mapping, true);\n\tif (check_allocated_memory(ptr, len, mem_type, true) != KSFT_PASS) {\n\t\tclose(fd);\n\t\treturn KSFT_FAIL;\n\t}\n\tmte_initialize_current_context(mode, (uintptr_t)ptr, len);\n\t \n\tsyscall_len = read(fd, ptr, len);\n\tmte_wait_after_trig();\n\tif (cur_mte_cxt.fault_valid || syscall_len < len)\n\t\tgoto usermem_acc_err;\n\t \n\tfor (i = 0; i < len; i++)\n\t\tif (*(char *)(ptr + i) != val)\n\t\t\tbreak;\n\tif (i < len)\n\t\tgoto usermem_acc_err;\n\n\tif (!tag_len)\n\t\ttag_len = len - tag_offset;\n\t \n\tptr_next = (void *)((unsigned long)ptr + tag_offset);\n\tptr_next = mte_insert_new_tag(ptr_next);\n\tmte_set_tag_address_range(ptr_next, tag_len);\n\n\tfor (fileoff = 0; fileoff < 16; fileoff++) {\n\t\tfor (ptroff = 0; ptroff < 16; ptroff++) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(sizes); i++) {\n\t\t\t\tsize = sizes[i];\n\t\t\t\tlseek(fd, 0, 0);\n\n\t\t\t\t \n\t\t\t\tswitch (test_type) {\n\t\t\t\tcase READ_TEST:\n\t\t\t\t\tsyscall_len = read(fd, ptr + ptroff, size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase WRITE_TEST:\n\t\t\t\t\tsyscall_len = write(fd, ptr + ptroff, size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase READV_TEST: {\n\t\t\t\t\tstruct iovec iov[1];\n\t\t\t\t\tiov[0].iov_base = ptr + ptroff;\n\t\t\t\t\tiov[0].iov_len = size;\n\t\t\t\t\tsyscall_len = readv(fd, iov, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase WRITEV_TEST: {\n\t\t\t\t\tstruct iovec iov[1];\n\t\t\t\t\tiov[0].iov_base = ptr + ptroff;\n\t\t\t\t\tiov[0].iov_len = size;\n\t\t\t\t\tsyscall_len = writev(fd, iov, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LAST_TEST:\n\t\t\t\t\tgoto usermem_acc_err;\n\t\t\t\t}\n\n\t\t\t\tmte_wait_after_trig();\n\t\t\t\t \n\t\t\t\tif (cur_mte_cxt.fault_valid) {\n\t\t\t\t\tgoto usermem_acc_err;\n\t\t\t\t}\n\t\t\t\tif (mode == MTE_SYNC_ERR && syscall_len < len) {\n\t\t\t\t\t \n\t\t\t\t} else if (mode == MTE_ASYNC_ERR && syscall_len == size) {\n\t\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\tgoto usermem_acc_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgoto exit;\n\nusermem_acc_err:\n\terr = KSFT_FAIL;\nexit:\n\tmte_free_memory((void *)ptr, len, mem_type, true);\n\tclose(fd);\n\treturn err;\n}\n\nvoid format_test_name(char* name, int name_len, int type, int sync, int map, int len, int offset) {\n\tconst char* test_type;\n\tconst char* mte_type;\n\tconst char* map_type;\n\n\tswitch (type) {\n\tcase READ_TEST:\n\t\ttest_type = \"read\";\n\t\tbreak;\n\tcase WRITE_TEST:\n\t\ttest_type = \"write\";\n\t\tbreak;\n\tcase READV_TEST:\n\t\ttest_type = \"readv\";\n\t\tbreak;\n\tcase WRITEV_TEST:\n\t\ttest_type = \"writev\";\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t\tbreak;\n\t}\n\n\tswitch (sync) {\n\tcase MTE_SYNC_ERR:\n\t\tmte_type = \"MTE_SYNC_ERR\";\n\t\tbreak;\n\tcase MTE_ASYNC_ERR:\n\t\tmte_type = \"MTE_ASYNC_ERR\";\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t\tbreak;\n\t}\n\n\tswitch (map) {\n\tcase MAP_SHARED:\n\t\tmap_type = \"MAP_SHARED\";\n\t\tbreak;\n\tcase MAP_PRIVATE:\n\t\tmap_type = \"MAP_PRIVATE\";\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t\tbreak;\n\t}\n\n\tsnprintf(name, name_len,\n\t         \"test type: %s, %s, %s, tag len: %d, tag offset: %d\\n\",\n\t         test_type, mte_type, map_type, len, offset);\n}\n\nint main(int argc, char *argv[])\n{\n\tint err;\n\tint t, s, m, l, o;\n\tint mte_sync[] = {MTE_SYNC_ERR, MTE_ASYNC_ERR};\n\tint maps[] = {MAP_SHARED, MAP_PRIVATE};\n\tint tag_lens[] = {0, MT_GRANULE_SIZE};\n\tint tag_offsets[] = {page_sz, MT_GRANULE_SIZE};\n\tchar test_name[TEST_NAME_MAX];\n\n\tpage_sz = getpagesize();\n\tif (!page_sz) {\n\t\tksft_print_msg(\"ERR: Unable to get page size\\n\");\n\t\treturn KSFT_FAIL;\n\t}\n\terr = mte_default_setup();\n\tif (err)\n\t\treturn err;\n\n\t \n\tmte_register_signal(SIGSEGV, mte_default_handler);\n\n\t \n\tksft_set_plan(64);\n\n\tfor (t = 0; t < LAST_TEST; t++) {\n\t\tfor (s = 0; s < ARRAY_SIZE(mte_sync); s++) {\n\t\t\tfor (m = 0; m < ARRAY_SIZE(maps); m++) {\n\t\t\t\tfor (l = 0; l < ARRAY_SIZE(tag_lens); l++) {\n\t\t\t\t\tfor (o = 0; o < ARRAY_SIZE(tag_offsets); o++) {\n\t\t\t\t\t\tint sync = mte_sync[s];\n\t\t\t\t\t\tint map = maps[m];\n\t\t\t\t\t\tint offset = tag_offsets[o];\n\t\t\t\t\t\tint tag_len = tag_lens[l];\n\t\t\t\t\t\tint res = check_usermem_access_fault(USE_MMAP, sync,\n\t\t\t\t\t\t                                     map, offset,\n\t\t\t\t\t\t                                     tag_len, t);\n\t\t\t\t\t\tformat_test_name(test_name, TEST_NAME_MAX,\n\t\t\t\t\t\t                 t, sync, map, tag_len, offset);\n\t\t\t\t\t\tevaluate_test(res, test_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmte_restore_setup();\n\tksft_print_cnts();\n\treturn ksft_get_fail_cnt() == 0 ? KSFT_PASS : KSFT_FAIL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}