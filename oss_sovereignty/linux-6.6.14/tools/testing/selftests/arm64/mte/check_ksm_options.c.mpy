{
  "module_name": "check_ksm_options.c",
  "hash_id": "a4107838aa76dc08e8151879fe2c9b30a70200a76ba0db4e3b9e15d2f247e19a",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/mte/check_ksm_options.c",
  "human_readable_source": "\n\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ucontext.h>\n#include <sys/mman.h>\n\n#include \"kselftest.h\"\n#include \"mte_common_util.h\"\n#include \"mte_def.h\"\n\n#define TEST_UNIT\t10\n#define PATH_KSM\t\"/sys/kernel/mm/ksm/\"\n#define MAX_LOOP\t4\n\nstatic size_t page_sz;\nstatic unsigned long ksm_sysfs[5];\n\nstatic unsigned long read_sysfs(char *str)\n{\n\tFILE *f;\n\tunsigned long val = 0;\n\n\tf = fopen(str, \"r\");\n\tif (!f) {\n\t\tksft_print_msg(\"ERR: missing %s\\n\", str);\n\t\treturn 0;\n\t}\n\tif (fscanf(f, \"%lu\", &val) != 1) {\n\t\tksft_print_msg(\"ERR: parsing %s\\n\", str);\n\t\tval = 0;\n\t}\n\tfclose(f);\n\treturn val;\n}\n\nstatic void write_sysfs(char *str, unsigned long val)\n{\n\tFILE *f;\n\n\tf = fopen(str, \"w\");\n\tif (!f) {\n\t\tksft_print_msg(\"ERR: missing %s\\n\", str);\n\t\treturn;\n\t}\n\tfprintf(f, \"%lu\", val);\n\tfclose(f);\n}\n\nstatic void mte_ksm_setup(void)\n{\n\tksm_sysfs[0] = read_sysfs(PATH_KSM \"merge_across_nodes\");\n\twrite_sysfs(PATH_KSM \"merge_across_nodes\", 1);\n\tksm_sysfs[1] = read_sysfs(PATH_KSM \"sleep_millisecs\");\n\twrite_sysfs(PATH_KSM \"sleep_millisecs\", 0);\n\tksm_sysfs[2] = read_sysfs(PATH_KSM \"run\");\n\twrite_sysfs(PATH_KSM \"run\", 1);\n\tksm_sysfs[3] = read_sysfs(PATH_KSM \"max_page_sharing\");\n\twrite_sysfs(PATH_KSM \"max_page_sharing\", ksm_sysfs[3] + TEST_UNIT);\n\tksm_sysfs[4] = read_sysfs(PATH_KSM \"pages_to_scan\");\n\twrite_sysfs(PATH_KSM \"pages_to_scan\", ksm_sysfs[4] + TEST_UNIT);\n}\n\nstatic void mte_ksm_restore(void)\n{\n\twrite_sysfs(PATH_KSM \"merge_across_nodes\", ksm_sysfs[0]);\n\twrite_sysfs(PATH_KSM \"sleep_millisecs\", ksm_sysfs[1]);\n\twrite_sysfs(PATH_KSM \"run\", ksm_sysfs[2]);\n\twrite_sysfs(PATH_KSM \"max_page_sharing\", ksm_sysfs[3]);\n\twrite_sysfs(PATH_KSM \"pages_to_scan\", ksm_sysfs[4]);\n}\n\nstatic void mte_ksm_scan(void)\n{\n\tint cur_count = read_sysfs(PATH_KSM \"full_scans\");\n\tint scan_count = cur_count + 1;\n\tint max_loop_count = MAX_LOOP;\n\n\twhile ((cur_count < scan_count) && max_loop_count) {\n\t\tsleep(1);\n\t\tcur_count = read_sysfs(PATH_KSM \"full_scans\");\n\t\tmax_loop_count--;\n\t}\n#ifdef DEBUG\n\tksft_print_msg(\"INFO: pages_shared=%lu pages_sharing=%lu\\n\",\n\t\t\tread_sysfs(PATH_KSM \"pages_shared\"),\n\t\t\tread_sysfs(PATH_KSM \"pages_sharing\"));\n#endif\n}\n\nstatic int check_madvise_options(int mem_type, int mode, int mapping)\n{\n\tchar *ptr;\n\tint err, ret;\n\n\terr = KSFT_FAIL;\n\tif (access(PATH_KSM, F_OK) == -1) {\n\t\tksft_print_msg(\"ERR: Kernel KSM config not enabled\\n\");\n\t\treturn err;\n\t}\n\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\tptr = mte_allocate_memory(TEST_UNIT * page_sz, mem_type, mapping, true);\n\tif (check_allocated_memory(ptr, TEST_UNIT * page_sz, mem_type, false) != KSFT_PASS)\n\t\treturn KSFT_FAIL;\n\n\t \n\tmemset(ptr, 'A', TEST_UNIT * page_sz);\n\tret = madvise(ptr, TEST_UNIT * page_sz, MADV_MERGEABLE);\n\tif (ret) {\n\t\tksft_print_msg(\"ERR: madvise failed to set MADV_UNMERGEABLE\\n\");\n\t\tgoto madvise_err;\n\t}\n\tmte_ksm_scan();\n\t \n\tif ((read_sysfs(PATH_KSM \"pages_shared\") < 1) ||\n\t    (read_sysfs(PATH_KSM \"pages_sharing\") < (TEST_UNIT - 1)))\n\t\terr = KSFT_PASS;\nmadvise_err:\n\tmte_free_memory(ptr, TEST_UNIT * page_sz, mem_type, true);\n\treturn err;\n}\n\nint main(int argc, char *argv[])\n{\n\tint err;\n\n\terr = mte_default_setup();\n\tif (err)\n\t\treturn err;\n\tpage_sz = getpagesize();\n\tif (!page_sz) {\n\t\tksft_print_msg(\"ERR: Unable to get page size\\n\");\n\t\treturn KSFT_FAIL;\n\t}\n\t \n\tmte_register_signal(SIGBUS, mte_default_handler);\n\tmte_register_signal(SIGSEGV, mte_default_handler);\n\n\t \n\tksft_set_plan(4);\n\n\t \n\tmte_ksm_setup();\n\n\tevaluate_test(check_madvise_options(USE_MMAP, MTE_SYNC_ERR, MAP_PRIVATE),\n\t\t\"Check KSM mte page merge for private mapping, sync mode and mmap memory\\n\");\n\tevaluate_test(check_madvise_options(USE_MMAP, MTE_ASYNC_ERR, MAP_PRIVATE),\n\t\t\"Check KSM mte page merge for private mapping, async mode and mmap memory\\n\");\n\tevaluate_test(check_madvise_options(USE_MMAP, MTE_SYNC_ERR, MAP_SHARED),\n\t\t\"Check KSM mte page merge for shared mapping, sync mode and mmap memory\\n\");\n\tevaluate_test(check_madvise_options(USE_MMAP, MTE_ASYNC_ERR, MAP_SHARED),\n\t\t\"Check KSM mte page merge for shared mapping, async mode and mmap memory\\n\");\n\n\tmte_ksm_restore();\n\tmte_restore_setup();\n\tksft_print_cnts();\n\treturn ksft_get_fail_cnt() == 0 ? KSFT_PASS : KSFT_FAIL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}