{
  "module_name": "mte_common_util.c",
  "hash_id": "9014139df8b7cad941f2bd43b4f60f5283848826f0a7ee60cb57ecbbaa667c6d",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/mte/mte_common_util.c",
  "human_readable_source": "\n\n\n#include <fcntl.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <linux/auxvec.h>\n#include <sys/auxv.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n\n#include <asm/hwcap.h>\n\n#include \"kselftest.h\"\n#include \"mte_common_util.h\"\n#include \"mte_def.h\"\n\n#define INIT_BUFFER_SIZE       256\n\nstruct mte_fault_cxt cur_mte_cxt;\nstatic unsigned int mte_cur_mode;\nstatic unsigned int mte_cur_pstate_tco;\n\nvoid mte_default_handler(int signum, siginfo_t *si, void *uc)\n{\n\tunsigned long addr = (unsigned long)si->si_addr;\n\n\tif (signum == SIGSEGV) {\n#ifdef DEBUG\n\t\tksft_print_msg(\"INFO: SIGSEGV signal at pc=%lx, fault addr=%lx, si_code=%lx\\n\",\n\t\t\t\t((ucontext_t *)uc)->uc_mcontext.pc, addr, si->si_code);\n#endif\n\t\tif (si->si_code == SEGV_MTEAERR) {\n\t\t\tif (cur_mte_cxt.trig_si_code == si->si_code)\n\t\t\t\tcur_mte_cxt.fault_valid = true;\n\t\t\telse\n\t\t\t\tksft_print_msg(\"Got unexpected SEGV_MTEAERR at pc=$lx, fault addr=%lx\\n\",\n\t\t\t\t\t       ((ucontext_t *)uc)->uc_mcontext.pc,\n\t\t\t\t\t       addr);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\telse if (si->si_code == SEGV_MTESERR) {\n\t\t\tif (cur_mte_cxt.trig_si_code == si->si_code &&\n\t\t\t    ((cur_mte_cxt.trig_range >= 0 &&\n\t\t\t      addr >= MT_CLEAR_TAG(cur_mte_cxt.trig_addr) &&\n\t\t\t      addr <= (MT_CLEAR_TAG(cur_mte_cxt.trig_addr) + cur_mte_cxt.trig_range)) ||\n\t\t\t     (cur_mte_cxt.trig_range < 0 &&\n\t\t\t      addr <= MT_CLEAR_TAG(cur_mte_cxt.trig_addr) &&\n\t\t\t      addr >= (MT_CLEAR_TAG(cur_mte_cxt.trig_addr) + cur_mte_cxt.trig_range)))) {\n\t\t\t\tcur_mte_cxt.fault_valid = true;\n\t\t\t\t \n\t\t\t\t((ucontext_t *)uc)->uc_mcontext.pc += 4;\n\t\t\t} else {\n\t\t\t\tksft_print_msg(\"Invalid MTE synchronous exception caught!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else {\n\t\t\tksft_print_msg(\"Unknown SIGSEGV exception caught!\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else if (signum == SIGBUS) {\n\t\tksft_print_msg(\"INFO: SIGBUS signal at pc=%lx, fault addr=%lx, si_code=%lx\\n\",\n\t\t\t\t((ucontext_t *)uc)->uc_mcontext.pc, addr, si->si_code);\n\t\tif ((cur_mte_cxt.trig_range >= 0 &&\n\t\t     addr >= MT_CLEAR_TAG(cur_mte_cxt.trig_addr) &&\n\t\t     addr <= (MT_CLEAR_TAG(cur_mte_cxt.trig_addr) + cur_mte_cxt.trig_range)) ||\n\t\t    (cur_mte_cxt.trig_range < 0 &&\n\t\t     addr <= MT_CLEAR_TAG(cur_mte_cxt.trig_addr) &&\n\t\t     addr >= (MT_CLEAR_TAG(cur_mte_cxt.trig_addr) + cur_mte_cxt.trig_range))) {\n\t\t\tcur_mte_cxt.fault_valid = true;\n\t\t\t \n\t\t\t((ucontext_t *)uc)->uc_mcontext.pc += 4;\n\t\t}\n\t}\n}\n\nvoid mte_register_signal(int signal, void (*handler)(int, siginfo_t *, void *))\n{\n\tstruct sigaction sa;\n\n\tsa.sa_sigaction = handler;\n\tsa.sa_flags = SA_SIGINFO;\n\tsigemptyset(&sa.sa_mask);\n\tsigaction(signal, &sa, NULL);\n}\n\nvoid mte_wait_after_trig(void)\n{\n\tsched_yield();\n}\n\nvoid *mte_insert_tags(void *ptr, size_t size)\n{\n\tvoid *tag_ptr;\n\tint align_size;\n\n\tif (!ptr || (unsigned long)(ptr) & MT_ALIGN_GRANULE) {\n\t\tksft_print_msg(\"FAIL: Addr=%lx: invalid\\n\", ptr);\n\t\treturn NULL;\n\t}\n\talign_size = MT_ALIGN_UP(size);\n\ttag_ptr = mte_insert_random_tag(ptr);\n\tmte_set_tag_address_range(tag_ptr, align_size);\n\treturn tag_ptr;\n}\n\nvoid mte_clear_tags(void *ptr, size_t size)\n{\n\tif (!ptr || (unsigned long)(ptr) & MT_ALIGN_GRANULE) {\n\t\tksft_print_msg(\"FAIL: Addr=%lx: invalid\\n\", ptr);\n\t\treturn;\n\t}\n\tsize = MT_ALIGN_UP(size);\n\tptr = (void *)MT_CLEAR_TAG((unsigned long)ptr);\n\tmte_clear_tag_address_range(ptr, size);\n}\n\nstatic void *__mte_allocate_memory_range(size_t size, int mem_type, int mapping,\n\t\t\t\t\t size_t range_before, size_t range_after,\n\t\t\t\t\t bool tags, int fd)\n{\n\tvoid *ptr;\n\tint prot_flag, map_flag;\n\tsize_t entire_size = size + range_before + range_after;\n\n\tswitch (mem_type) {\n\tcase USE_MALLOC:\n\t\treturn malloc(entire_size) + range_before;\n\tcase USE_MMAP:\n\tcase USE_MPROTECT:\n\t\tbreak;\n\tdefault:\n\t\tksft_print_msg(\"FAIL: Invalid allocate request\\n\");\n\t\treturn NULL;\n\t}\n\n\tprot_flag = PROT_READ | PROT_WRITE;\n\tif (mem_type == USE_MMAP)\n\t\tprot_flag |= PROT_MTE;\n\n\tmap_flag = mapping;\n\tif (fd == -1)\n\t\tmap_flag = MAP_ANONYMOUS | map_flag;\n\tif (!(mapping & MAP_SHARED))\n\t\tmap_flag |= MAP_PRIVATE;\n\tptr = mmap(NULL, entire_size, prot_flag, map_flag, fd, 0);\n\tif (ptr == MAP_FAILED) {\n\t\tksft_print_msg(\"FAIL: mmap allocation\\n\");\n\t\treturn NULL;\n\t}\n\tif (mem_type == USE_MPROTECT) {\n\t\tif (mprotect(ptr, entire_size, prot_flag | PROT_MTE)) {\n\t\t\tmunmap(ptr, size);\n\t\t\tksft_print_msg(\"FAIL: mprotect PROT_MTE property\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (tags)\n\t\tptr = mte_insert_tags(ptr + range_before, size);\n\treturn ptr;\n}\n\nvoid *mte_allocate_memory_tag_range(size_t size, int mem_type, int mapping,\n\t\t\t\t    size_t range_before, size_t range_after)\n{\n\treturn __mte_allocate_memory_range(size, mem_type, mapping, range_before,\n\t\t\t\t\t   range_after, true, -1);\n}\n\nvoid *mte_allocate_memory(size_t size, int mem_type, int mapping, bool tags)\n{\n\treturn __mte_allocate_memory_range(size, mem_type, mapping, 0, 0, tags, -1);\n}\n\nvoid *mte_allocate_file_memory(size_t size, int mem_type, int mapping, bool tags, int fd)\n{\n\tint index;\n\tchar buffer[INIT_BUFFER_SIZE];\n\n\tif (mem_type != USE_MPROTECT && mem_type != USE_MMAP) {\n\t\tksft_print_msg(\"FAIL: Invalid mmap file request\\n\");\n\t\treturn NULL;\n\t}\n\t \n\tlseek(fd, 0, SEEK_SET);\n\tfor (index = INIT_BUFFER_SIZE; index < size; index += INIT_BUFFER_SIZE) {\n\t\tif (write(fd, buffer, INIT_BUFFER_SIZE) != INIT_BUFFER_SIZE) {\n\t\t\tperror(\"initialising buffer\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tindex -= INIT_BUFFER_SIZE;\n\tif (write(fd, buffer, size - index) != size - index) {\n\t\tperror(\"initialising buffer\");\n\t\treturn NULL;\n\t}\n\treturn __mte_allocate_memory_range(size, mem_type, mapping, 0, 0, tags, fd);\n}\n\nvoid *mte_allocate_file_memory_tag_range(size_t size, int mem_type, int mapping,\n\t\t\t\t\t size_t range_before, size_t range_after, int fd)\n{\n\tint index;\n\tchar buffer[INIT_BUFFER_SIZE];\n\tint map_size = size + range_before + range_after;\n\n\tif (mem_type != USE_MPROTECT && mem_type != USE_MMAP) {\n\t\tksft_print_msg(\"FAIL: Invalid mmap file request\\n\");\n\t\treturn NULL;\n\t}\n\t \n\tlseek(fd, 0, SEEK_SET);\n\tfor (index = INIT_BUFFER_SIZE; index < map_size; index += INIT_BUFFER_SIZE)\n\t\tif (write(fd, buffer, INIT_BUFFER_SIZE) != INIT_BUFFER_SIZE) {\n\t\t\tperror(\"initialising buffer\");\n\t\t\treturn NULL;\n\t\t}\n\tindex -= INIT_BUFFER_SIZE;\n\tif (write(fd, buffer, map_size - index) != map_size - index) {\n\t\tperror(\"initialising buffer\");\n\t\treturn NULL;\n\t}\n\treturn __mte_allocate_memory_range(size, mem_type, mapping, range_before,\n\t\t\t\t\t   range_after, true, fd);\n}\n\nstatic void __mte_free_memory_range(void *ptr, size_t size, int mem_type,\n\t\t\t\t    size_t range_before, size_t range_after, bool tags)\n{\n\tswitch (mem_type) {\n\tcase USE_MALLOC:\n\t\tfree(ptr - range_before);\n\t\tbreak;\n\tcase USE_MMAP:\n\tcase USE_MPROTECT:\n\t\tif (tags)\n\t\t\tmte_clear_tags(ptr, size);\n\t\tmunmap(ptr - range_before, size + range_before + range_after);\n\t\tbreak;\n\tdefault:\n\t\tksft_print_msg(\"FAIL: Invalid free request\\n\");\n\t\tbreak;\n\t}\n}\n\nvoid mte_free_memory_tag_range(void *ptr, size_t size, int mem_type,\n\t\t\t       size_t range_before, size_t range_after)\n{\n\t__mte_free_memory_range(ptr, size, mem_type, range_before, range_after, true);\n}\n\nvoid mte_free_memory(void *ptr, size_t size, int mem_type, bool tags)\n{\n\t__mte_free_memory_range(ptr, size, mem_type, 0, 0, tags);\n}\n\nvoid mte_initialize_current_context(int mode, uintptr_t ptr, ssize_t range)\n{\n\tcur_mte_cxt.fault_valid = false;\n\tcur_mte_cxt.trig_addr = ptr;\n\tcur_mte_cxt.trig_range = range;\n\tif (mode == MTE_SYNC_ERR)\n\t\tcur_mte_cxt.trig_si_code = SEGV_MTESERR;\n\telse if (mode == MTE_ASYNC_ERR)\n\t\tcur_mte_cxt.trig_si_code = SEGV_MTEAERR;\n\telse\n\t\tcur_mte_cxt.trig_si_code = 0;\n}\n\nint mte_switch_mode(int mte_option, unsigned long incl_mask)\n{\n\tunsigned long en = 0;\n\n\tswitch (mte_option) {\n\tcase MTE_NONE_ERR:\n\tcase MTE_SYNC_ERR:\n\tcase MTE_ASYNC_ERR:\n\t\tbreak;\n\tdefault:\n\t\tksft_print_msg(\"FAIL: Invalid MTE option %x\\n\", mte_option);\n\t\treturn -EINVAL;\n\t}\n\n\tif (incl_mask & ~MT_INCLUDE_TAG_MASK) {\n\t\tksft_print_msg(\"FAIL: Invalid incl_mask %lx\\n\", incl_mask);\n\t\treturn -EINVAL;\n\t}\n\n\ten = PR_TAGGED_ADDR_ENABLE;\n\tswitch (mte_option) {\n\tcase MTE_SYNC_ERR:\n\t\ten |= PR_MTE_TCF_SYNC;\n\t\tbreak;\n\tcase MTE_ASYNC_ERR:\n\t\ten |= PR_MTE_TCF_ASYNC;\n\t\tbreak;\n\tcase MTE_NONE_ERR:\n\t\ten |= PR_MTE_TCF_NONE;\n\t\tbreak;\n\t}\n\n\ten |= (incl_mask << PR_MTE_TAG_SHIFT);\n\t \n\tif (prctl(PR_SET_TAGGED_ADDR_CTRL, en, 0, 0, 0) != 0) {\n\t\tksft_print_msg(\"FAIL:prctl PR_SET_TAGGED_ADDR_CTRL for mte mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint mte_default_setup(void)\n{\n\tunsigned long hwcaps2 = getauxval(AT_HWCAP2);\n\tunsigned long en = 0;\n\tint ret;\n\n\tif (!(hwcaps2 & HWCAP2_MTE)) {\n\t\tksft_print_msg(\"SKIP: MTE features unavailable\\n\");\n\t\treturn KSFT_SKIP;\n\t}\n\t \n\tret = prctl(PR_GET_TAGGED_ADDR_CTRL, en, 0, 0, 0);\n\tif (ret < 0) {\n\t\tksft_print_msg(\"FAIL:prctl PR_GET_TAGGED_ADDR_CTRL with error =%d\\n\", ret);\n\t\treturn KSFT_FAIL;\n\t}\n\tif (ret & PR_MTE_TCF_SYNC)\n\t\tmte_cur_mode = MTE_SYNC_ERR;\n\telse if (ret & PR_MTE_TCF_ASYNC)\n\t\tmte_cur_mode = MTE_ASYNC_ERR;\n\telse if (ret & PR_MTE_TCF_NONE)\n\t\tmte_cur_mode = MTE_NONE_ERR;\n\n\tmte_cur_pstate_tco = mte_get_pstate_tco();\n\t \n\tmte_disable_pstate_tco();\n\treturn 0;\n}\n\nvoid mte_restore_setup(void)\n{\n\tmte_switch_mode(mte_cur_mode, MTE_ALLOW_NON_ZERO_TAG);\n\tif (mte_cur_pstate_tco == MT_PSTATE_TCO_EN)\n\t\tmte_enable_pstate_tco();\n\telse if (mte_cur_pstate_tco == MT_PSTATE_TCO_DIS)\n\t\tmte_disable_pstate_tco();\n}\n\nint create_temp_file(void)\n{\n\tint fd;\n\tchar filename[] = \"/dev/shm/tmp_XXXXXX\";\n\n\t \n\tfd = mkstemp(&filename[0]);\n\tif (fd == -1) {\n\t\tperror(filename);\n\t\tksft_print_msg(\"FAIL: Unable to open temporary file\\n\");\n\t\treturn 0;\n\t}\n\tunlink(&filename[0]);\n\treturn fd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}