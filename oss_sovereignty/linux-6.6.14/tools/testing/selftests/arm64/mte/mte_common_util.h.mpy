{
  "module_name": "mte_common_util.h",
  "hash_id": "185ceeb12dba511d6d1efc77dbdb254733bb2da2a57c2623fc396656007db7b9",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/mte/mte_common_util.h",
  "human_readable_source": " \n \n\n#ifndef _MTE_COMMON_UTIL_H\n#define _MTE_COMMON_UTIL_H\n\n#include <signal.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <sys/auxv.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include \"mte_def.h\"\n#include \"kselftest.h\"\n\nenum mte_mem_type {\n\tUSE_MALLOC,\n\tUSE_MMAP,\n\tUSE_MPROTECT,\n};\n\nenum mte_mode {\n\tMTE_NONE_ERR,\n\tMTE_SYNC_ERR,\n\tMTE_ASYNC_ERR,\n};\n\nstruct mte_fault_cxt {\n\t \n\tunsigned long trig_addr;\n\t \n\tssize_t trig_range;\n\t \n\tunsigned long trig_si_code;\n\t \n\tbool fault_valid;\n};\n\nextern struct mte_fault_cxt cur_mte_cxt;\n\n \nvoid mte_default_handler(int signum, siginfo_t *si, void *uc);\nvoid mte_register_signal(int signal, void (*handler)(int, siginfo_t *, void *));\nvoid mte_wait_after_trig(void);\nvoid *mte_allocate_memory(size_t size, int mem_type, int mapping, bool tags);\nvoid *mte_allocate_memory_tag_range(size_t size, int mem_type, int mapping,\n\t\t\t\t    size_t range_before, size_t range_after);\nvoid *mte_allocate_file_memory(size_t size, int mem_type, int mapping,\n\t\t\t       bool tags, int fd);\nvoid *mte_allocate_file_memory_tag_range(size_t size, int mem_type, int mapping,\n\t\t\t\t\t size_t range_before, size_t range_after, int fd);\nvoid mte_free_memory(void *ptr, size_t size, int mem_type, bool tags);\nvoid mte_free_memory_tag_range(void *ptr, size_t size, int mem_type,\n\t\t\t       size_t range_before, size_t range_after);\nvoid *mte_insert_tags(void *ptr, size_t size);\nvoid mte_clear_tags(void *ptr, size_t size);\nint mte_default_setup(void);\nvoid mte_restore_setup(void);\nint mte_switch_mode(int mte_option, unsigned long incl_mask);\nvoid mte_initialize_current_context(int mode, uintptr_t ptr, ssize_t range);\n\n \nint create_temp_file(void);\n\n \nvoid *mte_insert_random_tag(void *ptr);\nvoid *mte_insert_new_tag(void *ptr);\nvoid *mte_get_tag_address(void *ptr);\nvoid mte_set_tag_address_range(void *ptr, int range);\nvoid mte_clear_tag_address_range(void *ptr, int range);\nvoid mte_disable_pstate_tco(void);\nvoid mte_enable_pstate_tco(void);\nunsigned int mte_get_pstate_tco(void);\n\n \nstatic inline void evaluate_test(int err, const char *msg)\n{\n\tswitch (err) {\n\tcase KSFT_PASS:\n\t\tksft_test_result_pass(msg);\n\t\tbreak;\n\tcase KSFT_FAIL:\n\t\tksft_test_result_fail(msg);\n\t\tbreak;\n\tcase KSFT_SKIP:\n\t\tksft_test_result_skip(msg);\n\t\tbreak;\n\tdefault:\n\t\tksft_test_result_error(\"Unknown return code %d from %s\",\n\t\t\t\t       err, msg);\n\t\tbreak;\n\t}\n}\n\nstatic inline int check_allocated_memory(void *ptr, size_t size,\n\t\t\t\t\t int mem_type, bool tags)\n{\n\tif (ptr == NULL) {\n\t\tksft_print_msg(\"FAIL: memory allocation\\n\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tif (tags && !MT_FETCH_TAG((uintptr_t)ptr)) {\n\t\tksft_print_msg(\"FAIL: tag not found at addr(%p)\\n\", ptr);\n\t\tmte_free_memory((void *)ptr, size, mem_type, false);\n\t\treturn KSFT_FAIL;\n\t}\n\n\treturn KSFT_PASS;\n}\n\nstatic inline int check_allocated_memory_range(void *ptr, size_t size, int mem_type,\n\t\t\t\t\t       size_t range_before, size_t range_after)\n{\n\tif (ptr == NULL) {\n\t\tksft_print_msg(\"FAIL: memory allocation\\n\");\n\t\treturn KSFT_FAIL;\n\t}\n\n\tif (!MT_FETCH_TAG((uintptr_t)ptr)) {\n\t\tksft_print_msg(\"FAIL: tag not found at addr(%p)\\n\", ptr);\n\t\tmte_free_memory_tag_range((void *)ptr, size, mem_type, range_before,\n\t\t\t\t\t  range_after);\n\t\treturn KSFT_FAIL;\n\t}\n\treturn KSFT_PASS;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}