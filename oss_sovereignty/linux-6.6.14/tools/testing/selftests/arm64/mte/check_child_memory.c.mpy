{
  "module_name": "check_child_memory.c",
  "hash_id": "798ae2d5d5af78c6a476cfedda4b80732159c4dd82d713690446840821d666ad",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/mte/check_child_memory.c",
  "human_readable_source": "\n\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ucontext.h>\n#include <sys/wait.h>\n\n#include \"kselftest.h\"\n#include \"mte_common_util.h\"\n#include \"mte_def.h\"\n\n#define BUFFER_SIZE\t\t(5 * MT_GRANULE_SIZE)\n#define RUNS\t\t\t(MT_TAG_COUNT)\n#define UNDERFLOW\t\tMT_GRANULE_SIZE\n#define OVERFLOW\t\tMT_GRANULE_SIZE\n\nstatic size_t page_size;\nstatic int sizes[] = {\n\t1, 537, 989, 1269, MT_GRANULE_SIZE - 1, MT_GRANULE_SIZE,\n\t  0,   0,   0\n};\n\nstatic int check_child_tag_inheritance(char *ptr, int size, int mode)\n{\n\tint i, parent_tag, child_tag, fault, child_status;\n\tpid_t child;\n\n\tparent_tag = MT_FETCH_TAG((uintptr_t)ptr);\n\tfault = 0;\n\n\tchild = fork();\n\tif (child == -1) {\n\t\tksft_print_msg(\"FAIL: child process creation\\n\");\n\t\treturn KSFT_FAIL;\n\t} else if (child == 0) {\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, size);\n\t\t \n\t\tmemset(ptr, '1', size);\n\t\tmte_wait_after_trig();\n\t\tif (cur_mte_cxt.fault_valid == true) {\n\t\t\tfault = 1;\n\t\t\tgoto check_child_tag_inheritance_err;\n\t\t}\n\t\tfor (i = 0 ; i < size ; i += MT_GRANULE_SIZE) {\n\t\t\tchild_tag = MT_FETCH_TAG((uintptr_t)(mte_get_tag_address(ptr + i)));\n\t\t\tif (parent_tag != child_tag) {\n\t\t\t\tksft_print_msg(\"FAIL: child mte tag mismatch\\n\");\n\t\t\t\tfault = 1;\n\t\t\t\tgoto check_child_tag_inheritance_err;\n\t\t\t}\n\t\t}\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, -UNDERFLOW);\n\t\tmemset(ptr - UNDERFLOW, '2', UNDERFLOW);\n\t\tmte_wait_after_trig();\n\t\tif (cur_mte_cxt.fault_valid == false) {\n\t\t\tfault = 1;\n\t\t\tgoto check_child_tag_inheritance_err;\n\t\t}\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, size + OVERFLOW);\n\t\tmemset(ptr + size, '3', OVERFLOW);\n\t\tmte_wait_after_trig();\n\t\tif (cur_mte_cxt.fault_valid == false) {\n\t\t\tfault = 1;\n\t\t\tgoto check_child_tag_inheritance_err;\n\t\t}\ncheck_child_tag_inheritance_err:\n\t\t_exit(fault);\n\t}\n\t \n\twait(&child_status);\n\tif (WIFEXITED(child_status))\n\t\tfault = WEXITSTATUS(child_status);\n\telse\n\t\tfault = 1;\n\treturn (fault) ? KSFT_FAIL : KSFT_PASS;\n}\n\nstatic int check_child_memory_mapping(int mem_type, int mode, int mapping)\n{\n\tchar *ptr;\n\tint run, result;\n\tint item = ARRAY_SIZE(sizes);\n\n\titem = ARRAY_SIZE(sizes);\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\tfor (run = 0; run < item; run++) {\n\t\tptr = (char *)mte_allocate_memory_tag_range(sizes[run], mem_type, mapping,\n\t\t\t\t\t\t\t    UNDERFLOW, OVERFLOW);\n\t\tif (check_allocated_memory_range(ptr, sizes[run], mem_type,\n\t\t\t\t\t\t UNDERFLOW, OVERFLOW) != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\t\tresult = check_child_tag_inheritance(ptr, sizes[run], mode);\n\t\tmte_free_memory_tag_range((void *)ptr, sizes[run], mem_type, UNDERFLOW, OVERFLOW);\n\t\tif (result == KSFT_FAIL)\n\t\t\treturn result;\n\t}\n\treturn KSFT_PASS;\n}\n\nstatic int check_child_file_mapping(int mem_type, int mode, int mapping)\n{\n\tchar *ptr, *map_ptr;\n\tint run, fd, map_size, result = KSFT_PASS;\n\tint total = ARRAY_SIZE(sizes);\n\n\tmte_switch_mode(mode, MTE_ALLOW_NON_ZERO_TAG);\n\tfor (run = 0; run < total; run++) {\n\t\tfd = create_temp_file();\n\t\tif (fd == -1)\n\t\t\treturn KSFT_FAIL;\n\n\t\tmap_size = sizes[run] + OVERFLOW + UNDERFLOW;\n\t\tmap_ptr = (char *)mte_allocate_file_memory(map_size, mem_type, mapping, false, fd);\n\t\tif (check_allocated_memory(map_ptr, map_size, mem_type, false) != KSFT_PASS) {\n\t\t\tclose(fd);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tptr = map_ptr + UNDERFLOW;\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, sizes[run]);\n\t\t \n\t\tptr = mte_insert_tags((void *)ptr, sizes[run]);\n\t\tif (!ptr || cur_mte_cxt.fault_valid == true) {\n\t\t\tksft_print_msg(\"FAIL: Insert tags on file based memory\\n\");\n\t\t\tmunmap((void *)map_ptr, map_size);\n\t\t\tclose(fd);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tresult = check_child_tag_inheritance(ptr, sizes[run], mode);\n\t\tmte_clear_tags((void *)ptr, sizes[run]);\n\t\tmunmap((void *)map_ptr, map_size);\n\t\tclose(fd);\n\t\tif (result != KSFT_PASS)\n\t\t\treturn KSFT_FAIL;\n\t}\n\treturn KSFT_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\tint err;\n\tint item = ARRAY_SIZE(sizes);\n\n\tpage_size = getpagesize();\n\tif (!page_size) {\n\t\tksft_print_msg(\"ERR: Unable to get page size\\n\");\n\t\treturn KSFT_FAIL;\n\t}\n\tsizes[item - 3] = page_size - 1;\n\tsizes[item - 2] = page_size;\n\tsizes[item - 1] = page_size + 1;\n\n\terr = mte_default_setup();\n\tif (err)\n\t\treturn err;\n\n\t \n\tmte_register_signal(SIGSEGV, mte_default_handler);\n\tmte_register_signal(SIGBUS, mte_default_handler);\n\n\t \n\tksft_set_plan(12);\n\n\tevaluate_test(check_child_memory_mapping(USE_MMAP, MTE_SYNC_ERR, MAP_PRIVATE),\n\t\t\"Check child anonymous memory with private mapping, precise mode and mmap memory\\n\");\n\tevaluate_test(check_child_memory_mapping(USE_MMAP, MTE_SYNC_ERR, MAP_SHARED),\n\t\t\"Check child anonymous memory with shared mapping, precise mode and mmap memory\\n\");\n\tevaluate_test(check_child_memory_mapping(USE_MMAP, MTE_ASYNC_ERR, MAP_PRIVATE),\n\t\t\"Check child anonymous memory with private mapping, imprecise mode and mmap memory\\n\");\n\tevaluate_test(check_child_memory_mapping(USE_MMAP, MTE_ASYNC_ERR, MAP_SHARED),\n\t\t\"Check child anonymous memory with shared mapping, imprecise mode and mmap memory\\n\");\n\tevaluate_test(check_child_memory_mapping(USE_MPROTECT, MTE_SYNC_ERR, MAP_PRIVATE),\n\t\t\"Check child anonymous memory with private mapping, precise mode and mmap/mprotect memory\\n\");\n\tevaluate_test(check_child_memory_mapping(USE_MPROTECT, MTE_SYNC_ERR, MAP_SHARED),\n\t\t\"Check child anonymous memory with shared mapping, precise mode and mmap/mprotect memory\\n\");\n\n\tevaluate_test(check_child_file_mapping(USE_MMAP, MTE_SYNC_ERR, MAP_PRIVATE),\n\t\t\"Check child file memory with private mapping, precise mode and mmap memory\\n\");\n\tevaluate_test(check_child_file_mapping(USE_MMAP, MTE_SYNC_ERR, MAP_SHARED),\n\t\t\"Check child file memory with shared mapping, precise mode and mmap memory\\n\");\n\tevaluate_test(check_child_memory_mapping(USE_MMAP, MTE_ASYNC_ERR, MAP_PRIVATE),\n\t\t\"Check child file memory with private mapping, imprecise mode and mmap memory\\n\");\n\tevaluate_test(check_child_memory_mapping(USE_MMAP, MTE_ASYNC_ERR, MAP_SHARED),\n\t\t\"Check child file memory with shared mapping, imprecise mode and mmap memory\\n\");\n\tevaluate_test(check_child_memory_mapping(USE_MPROTECT, MTE_SYNC_ERR, MAP_PRIVATE),\n\t\t\"Check child file memory with private mapping, precise mode and mmap/mprotect memory\\n\");\n\tevaluate_test(check_child_memory_mapping(USE_MPROTECT, MTE_SYNC_ERR, MAP_SHARED),\n\t\t\"Check child file memory with shared mapping, precise mode and mmap/mprotect memory\\n\");\n\n\tmte_restore_setup();\n\tksft_print_cnts();\n\treturn ksft_get_fail_cnt() == 0 ? KSFT_PASS : KSFT_FAIL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}