{
  "module_name": "check_tags_inclusion.c",
  "hash_id": "dc734ddf202f09f7537fb1f8368bfa140284a853384ba97658e9091b1af04073",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/mte/check_tags_inclusion.c",
  "human_readable_source": "\n\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ucontext.h>\n#include <sys/wait.h>\n\n#include \"kselftest.h\"\n#include \"mte_common_util.h\"\n#include \"mte_def.h\"\n\n#define BUFFER_SIZE\t\t(5 * MT_GRANULE_SIZE)\n#define RUNS\t\t\t(MT_TAG_COUNT * 2)\n#define MTE_LAST_TAG_MASK\t(0x7FFF)\n\nstatic int verify_mte_pointer_validity(char *ptr, int mode)\n{\n\tmte_initialize_current_context(mode, (uintptr_t)ptr, BUFFER_SIZE);\n\t \n\tmemset(ptr, '1', BUFFER_SIZE);\n\tmte_wait_after_trig();\n\tif (cur_mte_cxt.fault_valid) {\n\t\tksft_print_msg(\"Unexpected fault recorded for %p-%p in mode %x\\n\",\n\t\t\t       ptr, ptr + BUFFER_SIZE, mode);\n\t\treturn KSFT_FAIL;\n\t}\n\t \n\tif (!MT_FETCH_TAG((uintptr_t)ptr))\n\t\treturn KSFT_PASS;\n\tmte_initialize_current_context(mode, (uintptr_t)ptr, BUFFER_SIZE + 1);\n\t \n\tptr[BUFFER_SIZE] = '2';\n\tmte_wait_after_trig();\n\tif (!cur_mte_cxt.fault_valid) {\n\t\tksft_print_msg(\"No valid fault recorded for %p in mode %x\\n\",\n\t\t\t       ptr, mode);\n\t\treturn KSFT_FAIL;\n\t} else {\n\t\treturn KSFT_PASS;\n\t}\n}\n\nstatic int check_single_included_tags(int mem_type, int mode)\n{\n\tchar *ptr;\n\tint tag, run, ret, result = KSFT_PASS;\n\n\tptr = mte_allocate_memory(BUFFER_SIZE + MT_GRANULE_SIZE, mem_type, 0, false);\n\tif (check_allocated_memory(ptr, BUFFER_SIZE + MT_GRANULE_SIZE,\n\t\t\t\t   mem_type, false) != KSFT_PASS)\n\t\treturn KSFT_FAIL;\n\n\tfor (tag = 0; (tag < MT_TAG_COUNT) && (result == KSFT_PASS); tag++) {\n\t\tret = mte_switch_mode(mode, MT_INCLUDE_VALID_TAG(tag));\n\t\tif (ret != 0)\n\t\t\tresult = KSFT_FAIL;\n\t\t \n\t\tfor (run = 0; (run < RUNS) && (result == KSFT_PASS); run++) {\n\t\t\tptr = mte_insert_tags(ptr, BUFFER_SIZE);\n\t\t\t \n\t\t\tif (MT_FETCH_TAG((uintptr_t)ptr) == tag) {\n\t\t\t\tksft_print_msg(\"FAIL: wrong tag = 0x%x with include mask=0x%x\\n\",\n\t\t\t\t\t       MT_FETCH_TAG((uintptr_t)ptr),\n\t\t\t\t\t       MT_INCLUDE_VALID_TAG(tag));\n\t\t\t\tresult = KSFT_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = verify_mte_pointer_validity(ptr, mode);\n\t\t}\n\t}\n\tmte_free_memory_tag_range(ptr, BUFFER_SIZE, mem_type, 0, MT_GRANULE_SIZE);\n\treturn result;\n}\n\nstatic int check_multiple_included_tags(int mem_type, int mode)\n{\n\tchar *ptr;\n\tint tag, run, result = KSFT_PASS;\n\tunsigned long excl_mask = 0;\n\n\tptr = mte_allocate_memory(BUFFER_SIZE + MT_GRANULE_SIZE, mem_type, 0, false);\n\tif (check_allocated_memory(ptr, BUFFER_SIZE + MT_GRANULE_SIZE,\n\t\t\t\t   mem_type, false) != KSFT_PASS)\n\t\treturn KSFT_FAIL;\n\n\tfor (tag = 0; (tag < MT_TAG_COUNT - 1) && (result == KSFT_PASS); tag++) {\n\t\texcl_mask |= 1 << tag;\n\t\tmte_switch_mode(mode, MT_INCLUDE_VALID_TAGS(excl_mask));\n\t\t \n\t\tfor (run = 0; (run < RUNS) && (result == KSFT_PASS); run++) {\n\t\t\tptr = mte_insert_tags(ptr, BUFFER_SIZE);\n\t\t\t \n\t\t\tif (MT_FETCH_TAG((uintptr_t)ptr) < tag) {\n\t\t\t\tksft_print_msg(\"FAIL: wrong tag = 0x%x with include mask=0x%x\\n\",\n\t\t\t\t\t       MT_FETCH_TAG((uintptr_t)ptr),\n\t\t\t\t\t       MT_INCLUDE_VALID_TAGS(excl_mask));\n\t\t\t\tresult = KSFT_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = verify_mte_pointer_validity(ptr, mode);\n\t\t}\n\t}\n\tmte_free_memory_tag_range(ptr, BUFFER_SIZE, mem_type, 0, MT_GRANULE_SIZE);\n\treturn result;\n}\n\nstatic int check_all_included_tags(int mem_type, int mode)\n{\n\tchar *ptr;\n\tint run, ret, result = KSFT_PASS;\n\n\tptr = mte_allocate_memory(BUFFER_SIZE + MT_GRANULE_SIZE, mem_type, 0, false);\n\tif (check_allocated_memory(ptr, BUFFER_SIZE + MT_GRANULE_SIZE,\n\t\t\t\t   mem_type, false) != KSFT_PASS)\n\t\treturn KSFT_FAIL;\n\n\tret = mte_switch_mode(mode, MT_INCLUDE_TAG_MASK);\n\tif (ret != 0)\n\t\treturn KSFT_FAIL;\n\t \n\tfor (run = 0; (run < RUNS) && (result == KSFT_PASS); run++) {\n\t\tptr = (char *)mte_insert_tags(ptr, BUFFER_SIZE);\n\t\t \n\t\tresult = verify_mte_pointer_validity(ptr, mode);\n\t}\n\tmte_free_memory_tag_range(ptr, BUFFER_SIZE, mem_type, 0, MT_GRANULE_SIZE);\n\treturn result;\n}\n\nstatic int check_none_included_tags(int mem_type, int mode)\n{\n\tchar *ptr;\n\tint run, ret;\n\n\tptr = mte_allocate_memory(BUFFER_SIZE, mem_type, 0, false);\n\tif (check_allocated_memory(ptr, BUFFER_SIZE, mem_type, false) != KSFT_PASS)\n\t\treturn KSFT_FAIL;\n\n\tret = mte_switch_mode(mode, MT_EXCLUDE_TAG_MASK);\n\tif (ret != 0)\n\t\treturn KSFT_FAIL;\n\t \n\tfor (run = 0; run < RUNS; run++) {\n\t\tptr = (char *)mte_insert_tags(ptr, BUFFER_SIZE);\n\t\t \n\t\tif (MT_FETCH_TAG((uintptr_t)ptr)) {\n\t\t\tksft_print_msg(\"FAIL: included tag value found\\n\");\n\t\t\tmte_free_memory((void *)ptr, BUFFER_SIZE, mem_type, true);\n\t\t\treturn KSFT_FAIL;\n\t\t}\n\t\tmte_initialize_current_context(mode, (uintptr_t)ptr, BUFFER_SIZE);\n\t\t \n\t\tmemset(ptr, '1', BUFFER_SIZE);\n\t\tmte_wait_after_trig();\n\t\tif (cur_mte_cxt.fault_valid)\n\t\t\tbreak;\n\t}\n\tmte_free_memory(ptr, BUFFER_SIZE, mem_type, false);\n\tif (cur_mte_cxt.fault_valid)\n\t\treturn KSFT_FAIL;\n\telse\n\t\treturn KSFT_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\tint err;\n\n\terr = mte_default_setup();\n\tif (err)\n\t\treturn err;\n\n\t \n\tmte_register_signal(SIGSEGV, mte_default_handler);\n\n\t \n\tksft_set_plan(4);\n\n\tevaluate_test(check_single_included_tags(USE_MMAP, MTE_SYNC_ERR),\n\t\t      \"Check an included tag value with sync mode\\n\");\n\tevaluate_test(check_multiple_included_tags(USE_MMAP, MTE_SYNC_ERR),\n\t\t      \"Check different included tags value with sync mode\\n\");\n\tevaluate_test(check_none_included_tags(USE_MMAP, MTE_SYNC_ERR),\n\t\t      \"Check none included tags value with sync mode\\n\");\n\tevaluate_test(check_all_included_tags(USE_MMAP, MTE_SYNC_ERR),\n\t\t      \"Check all included tags value with sync mode\\n\");\n\n\tmte_restore_setup();\n\tksft_print_cnts();\n\treturn ksft_get_fail_cnt() == 0 ? KSFT_PASS : KSFT_FAIL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}