{
  "module_name": "check_gcr_el1_cswitch.c",
  "hash_id": "1594510d0996e04b83f07ee831fa576db170633eaa3be562fe54af3bcd13a7cc",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/mte/check_gcr_el1_cswitch.c",
  "human_readable_source": "\n\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <pthread.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include \"kselftest.h\"\n#include \"mte_common_util.h\"\n\n#include \"mte_def.h\"\n\n#define NUM_ITERATIONS\t\t1024\n#define MAX_THREADS\t\t5\n#define THREAD_ITERATIONS\t1000\n\nvoid *execute_thread(void *x)\n{\n\tpid_t pid = *((pid_t *)x);\n\tpid_t tid = gettid();\n\tuint64_t prctl_tag_mask;\n\tuint64_t prctl_set;\n\tuint64_t prctl_get;\n\tuint64_t prctl_tcf;\n\n\tsrand(time(NULL) ^ (pid << 16) ^ (tid << 16));\n\n\tprctl_tag_mask = rand() & 0xffff;\n\n\tif (prctl_tag_mask % 2)\n\t\tprctl_tcf = PR_MTE_TCF_SYNC;\n\telse\n\t\tprctl_tcf = PR_MTE_TCF_ASYNC;\n\n\tprctl_set = PR_TAGGED_ADDR_ENABLE | prctl_tcf | (prctl_tag_mask << PR_MTE_TAG_SHIFT);\n\n\tfor (int j = 0; j < THREAD_ITERATIONS; j++) {\n\t\tif (prctl(PR_SET_TAGGED_ADDR_CTRL, prctl_set, 0, 0, 0)) {\n\t\t\tperror(\"prctl() failed\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tprctl_get = prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0);\n\n\t\tif (prctl_set != prctl_get) {\n\t\t\tksft_print_msg(\"Error: prctl_set: 0x%lx != prctl_get: 0x%lx\\n\",\n\t\t\t\t\t\tprctl_set, prctl_get);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn (void *)KSFT_PASS;\n\nfail:\n\treturn (void *)KSFT_FAIL;\n}\n\nint execute_test(pid_t pid)\n{\n\tpthread_t thread_id[MAX_THREADS];\n\tint thread_data[MAX_THREADS];\n\n\tfor (int i = 0; i < MAX_THREADS; i++)\n\t\tpthread_create(&thread_id[i], NULL,\n\t\t\t       execute_thread, (void *)&pid);\n\n\tfor (int i = 0; i < MAX_THREADS; i++)\n\t\tpthread_join(thread_id[i], (void *)&thread_data[i]);\n\n\tfor (int i = 0; i < MAX_THREADS; i++)\n\t\tif (thread_data[i] == KSFT_FAIL)\n\t\t\treturn KSFT_FAIL;\n\n\treturn KSFT_PASS;\n}\n\nint mte_gcr_fork_test(void)\n{\n\tpid_t pid;\n\tint results[NUM_ITERATIONS];\n\tpid_t cpid;\n\tint res;\n\n\tfor (int i = 0; i < NUM_ITERATIONS; i++) {\n\t\tpid = fork();\n\n\t\tif (pid < 0)\n\t\t\treturn KSFT_FAIL;\n\n\t\tif (pid == 0) {\n\t\t\tcpid = getpid();\n\n\t\t\tres = execute_test(cpid);\n\n\t\t\texit(res);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < NUM_ITERATIONS; i++) {\n\t\twait(&res);\n\n\t\tif (WIFEXITED(res))\n\t\t\tresults[i] = WEXITSTATUS(res);\n\t\telse\n\t\t\t--i;\n\t}\n\n\tfor (int i = 0; i < NUM_ITERATIONS; i++)\n\t\tif (results[i] == KSFT_FAIL)\n\t\t\treturn KSFT_FAIL;\n\n\treturn KSFT_PASS;\n}\n\nint main(int argc, char *argv[])\n{\n\tint err;\n\n\terr = mte_default_setup();\n\tif (err)\n\t\treturn err;\n\n\tksft_set_plan(1);\n\n\tevaluate_test(mte_gcr_fork_test(),\n\t\t\"Verify that GCR_EL1 is set correctly on context switch\\n\");\n\n\tmte_restore_setup();\n\tksft_print_cnts();\n\n\treturn ksft_get_fail_cnt() == 0 ? KSFT_PASS : KSFT_FAIL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}