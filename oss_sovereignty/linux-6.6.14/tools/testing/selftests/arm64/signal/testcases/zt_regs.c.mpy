{
  "module_name": "zt_regs.c",
  "hash_id": "2feac64c50f596d1d99ae4ff0af35c485c80458653642a9ff8cd236b46453a30",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/signal/testcases/zt_regs.c",
  "human_readable_source": "\n \n\n#include <signal.h>\n#include <ucontext.h>\n#include <sys/prctl.h>\n\n#include \"test_signals_utils.h\"\n#include \"testcases.h\"\n\nstatic union {\n\tucontext_t uc;\n\tchar buf[1024 * 128];\n} context;\n\nstatic void enable_za(void)\n{\n\t \n\tasm volatile(\".inst 0xd503457f\" : : : );\n}\n\nint zt_regs_run(struct tdescr *td, siginfo_t *si, ucontext_t *uc)\n{\n\tsize_t offset;\n\tstruct _aarch64_ctx *head = GET_BUF_RESV_HEAD(context);\n\tstruct zt_context *zt;\n\tchar *zeros;\n\n\t \n\tenable_za();\n\tif (!get_current_context(td, &context.uc, sizeof(context)))\n\t\treturn 1;\n\n\thead = get_header(head, ZT_MAGIC, GET_BUF_RESV_SIZE(context), &offset);\n\tif (!head) {\n\t\tfprintf(stderr, \"No ZT context\\n\");\n\t\treturn 1;\n\t}\n\n\tzt = (struct zt_context *)head;\n\tif (zt->nregs == 0) {\n\t\tfprintf(stderr, \"Got context with no registers\\n\");\n\t\treturn 1;\n\t}\n\n\tfprintf(stderr, \"Got expected size %u for %d registers\\n\",\n\t\thead->size, zt->nregs);\n\n\t \n\tzeros = malloc(ZT_SIG_REGS_SIZE(zt->nregs));\n\tif (!zeros) {\n\t\tfprintf(stderr, \"Out of memory, nregs=%u\\n\", zt->nregs);\n\t\treturn 1;\n\t}\n\tmemset(zeros, 0, ZT_SIG_REGS_SIZE(zt->nregs));\n\n\tif (memcmp(zeros, (char *)zt + ZT_SIG_REGS_OFFSET,\n\t\t   ZT_SIG_REGS_SIZE(zt->nregs)) != 0) {\n\t\tfprintf(stderr, \"ZT data invalid\\n\");\n\t\tfree(zeros);\n\t\treturn 1;\n\t}\n\n\tfree(zeros);\n\n\ttd->pass = 1;\n\n\treturn 0;\n}\n\nstruct tdescr tde = {\n\t.name = \"ZT register data\",\n\t.descr = \"Validate that ZT is present and has data when ZA is enabled\",\n\t.feats_required = FEAT_SME2,\n\t.timeout = 3,\n\t.sanity_disabled = true,\n\t.run = zt_regs_run,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}