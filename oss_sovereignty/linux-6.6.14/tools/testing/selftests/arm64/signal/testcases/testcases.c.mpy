{
  "module_name": "testcases.c",
  "hash_id": "7cf47d225b4cfb4ff291c8784d37da3dae2870d364d256d07c5e42146a8e87bb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/signal/testcases/testcases.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <string.h>\n\n#include \"testcases.h\"\n\nstruct _aarch64_ctx *get_header(struct _aarch64_ctx *head, uint32_t magic,\n\t\t\t\tsize_t resv_sz, size_t *offset)\n{\n\tsize_t offs = 0;\n\tstruct _aarch64_ctx *found = NULL;\n\n\tif (!head || resv_sz < HDR_SZ)\n\t\treturn found;\n\n\twhile (offs <= resv_sz - HDR_SZ &&\n\t       head->magic != magic && head->magic) {\n\t\toffs += head->size;\n\t\thead = GET_RESV_NEXT_HEAD(head);\n\t}\n\tif (head->magic == magic) {\n\t\tfound = head;\n\t\tif (offset)\n\t\t\t*offset = offs;\n\t}\n\n\treturn found;\n}\n\nbool validate_extra_context(struct extra_context *extra, char **err,\n\t\t\t    void **extra_data, size_t *extra_size)\n{\n\tstruct _aarch64_ctx *term;\n\n\tif (!extra || !err)\n\t\treturn false;\n\n\tfprintf(stderr, \"Validating EXTRA...\\n\");\n\tterm = GET_RESV_NEXT_HEAD(&extra->head);\n\tif (!term || term->magic || term->size) {\n\t\t*err = \"Missing terminator after EXTRA context\";\n\t\treturn false;\n\t}\n\tif (extra->datap & 0x0fUL)\n\t\t*err = \"Extra DATAP misaligned\";\n\telse if (extra->size & 0x0fUL)\n\t\t*err = \"Extra SIZE misaligned\";\n\telse if (extra->datap != (uint64_t)term + 0x10UL)\n\t\t*err = \"Extra DATAP misplaced (not contiguous)\";\n\tif (*err)\n\t\treturn false;\n\n\t*extra_data = (void *)extra->datap;\n\t*extra_size = extra->size;\n\n\treturn true;\n}\n\nbool validate_sve_context(struct sve_context *sve, char **err)\n{\n\t \n\tsize_t regs_size\n\t\t= ((SVE_SIG_CONTEXT_SIZE(sve_vq_from_vl(sve->vl)) + 15) / 16) * 16;\n\n\tif (!sve || !err)\n\t\treturn false;\n\n\t \n\tif ((sve->head.size != sizeof(struct sve_context)) &&\n\t    (sve->head.size != regs_size)) {\n\t\t*err = \"bad size for SVE context\";\n\t\treturn false;\n\t}\n\n\tif (!sve_vl_valid(sve->vl)) {\n\t\t*err = \"SVE VL invalid\";\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool validate_za_context(struct za_context *za, char **err)\n{\n\t \n\tsize_t regs_size\n\t\t= ((ZA_SIG_CONTEXT_SIZE(sve_vq_from_vl(za->vl)) + 15) / 16) * 16;\n\n\tif (!za || !err)\n\t\treturn false;\n\n\t \n\tif ((za->head.size != sizeof(struct za_context)) &&\n\t    (za->head.size != regs_size)) {\n\t\t*err = \"bad size for ZA context\";\n\t\treturn false;\n\t}\n\n\tif (!sve_vl_valid(za->vl)) {\n\t\t*err = \"SME VL in ZA context invalid\";\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool validate_zt_context(struct zt_context *zt, char **err)\n{\n\tif (!zt || !err)\n\t\treturn false;\n\n\t \n\tif (zt->nregs == 0) {\n\t\t*err = \"no registers\";\n\t\treturn false;\n\t}\n\n\t \n\tif (zt->head.size != ZT_SIG_CONTEXT_SIZE(zt->nregs)) {\n\t\t*err = \"register count does not match size\";\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool validate_reserved(ucontext_t *uc, size_t resv_sz, char **err)\n{\n\tbool terminated = false;\n\tsize_t offs = 0;\n\tint flags = 0;\n\tint new_flags, i;\n\tstruct extra_context *extra = NULL;\n\tstruct sve_context *sve = NULL;\n\tstruct za_context *za = NULL;\n\tstruct zt_context *zt = NULL;\n\tstruct _aarch64_ctx *head =\n\t\t(struct _aarch64_ctx *)uc->uc_mcontext.__reserved;\n\tvoid *extra_data = NULL;\n\tsize_t extra_sz = 0;\n\tchar magic[4];\n\n\tif (!err)\n\t\treturn false;\n\t \n\twhile (head && !terminated && offs < resv_sz) {\n\t\tif ((uint64_t)head & 0x0fUL) {\n\t\t\t*err = \"Misaligned HEAD\";\n\t\t\treturn false;\n\t\t}\n\n\t\tnew_flags = 0;\n\n\t\tswitch (head->magic) {\n\t\tcase 0:\n\t\t\tif (head->size) {\n\t\t\t\t*err = \"Bad size for terminator\";\n\t\t\t} else if (extra_data) {\n\t\t\t\t \n\t\t\t\thead = extra_data;\n\t\t\t\tresv_sz = extra_sz;\n\t\t\t\toffs = 0;\n\n\t\t\t\textra_data = NULL;\n\t\t\t\textra_sz = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tterminated = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FPSIMD_MAGIC:\n\t\t\tif (flags & FPSIMD_CTX)\n\t\t\t\t*err = \"Multiple FPSIMD_MAGIC\";\n\t\t\telse if (head->size !=\n\t\t\t\t sizeof(struct fpsimd_context))\n\t\t\t\t*err = \"Bad size for fpsimd_context\";\n\t\t\tnew_flags |= FPSIMD_CTX;\n\t\t\tbreak;\n\t\tcase ESR_MAGIC:\n\t\t\tif (head->size != sizeof(struct esr_context))\n\t\t\t\t*err = \"Bad size for esr_context\";\n\t\t\tbreak;\n\t\tcase TPIDR2_MAGIC:\n\t\t\tif (head->size != sizeof(struct tpidr2_context))\n\t\t\t\t*err = \"Bad size for tpidr2_context\";\n\t\t\tbreak;\n\t\tcase SVE_MAGIC:\n\t\t\tif (flags & SVE_CTX)\n\t\t\t\t*err = \"Multiple SVE_MAGIC\";\n\t\t\t \n\t\t\tsve = (struct sve_context *)head;\n\t\t\tnew_flags |= SVE_CTX;\n\t\t\tbreak;\n\t\tcase ZA_MAGIC:\n\t\t\tif (flags & ZA_CTX)\n\t\t\t\t*err = \"Multiple ZA_MAGIC\";\n\t\t\t \n\t\t\tza = (struct za_context *)head;\n\t\t\tnew_flags |= ZA_CTX;\n\t\t\tbreak;\n\t\tcase ZT_MAGIC:\n\t\t\tif (flags & ZT_CTX)\n\t\t\t\t*err = \"Multiple ZT_MAGIC\";\n\t\t\t \n\t\t\tzt = (struct zt_context *)head;\n\t\t\tnew_flags |= ZT_CTX;\n\t\t\tbreak;\n\t\tcase EXTRA_MAGIC:\n\t\t\tif (flags & EXTRA_CTX)\n\t\t\t\t*err = \"Multiple EXTRA_MAGIC\";\n\t\t\telse if (head->size !=\n\t\t\t\t sizeof(struct extra_context))\n\t\t\t\t*err = \"Bad size for extra_context\";\n\t\t\tnew_flags |= EXTRA_CTX;\n\t\t\textra = (struct extra_context *)head;\n\t\t\tbreak;\n\t\tcase KSFT_BAD_MAGIC:\n\t\t\t \n\t\t\t*err = \"BAD MAGIC !\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tmemcpy(magic, &head->magic, sizeof(magic));\n\t\t\tfor (i = 0; i < sizeof(magic); i++)\n\t\t\t\tif (!isalnum(magic[i]))\n\t\t\t\t\tmagic[i] = '?';\n\n\t\t\tfprintf(stdout,\n\t\t\t\t\"SKIP Unknown MAGIC: 0x%X (%c%c%c%c) - Is KSFT arm64/signal up to date ?\\n\",\n\t\t\t\thead->magic,\n\t\t\t\tmagic[3], magic[2], magic[1], magic[0]);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*err)\n\t\t\treturn false;\n\n\t\toffs += head->size;\n\t\tif (resv_sz < offs + sizeof(*head)) {\n\t\t\t*err = \"HEAD Overrun\";\n\t\t\treturn false;\n\t\t}\n\n\t\tif (new_flags & EXTRA_CTX)\n\t\t\tif (!validate_extra_context(extra, err,\n\t\t\t\t\t\t    &extra_data, &extra_sz))\n\t\t\t\treturn false;\n\t\tif (new_flags & SVE_CTX)\n\t\t\tif (!validate_sve_context(sve, err))\n\t\t\t\treturn false;\n\t\tif (new_flags & ZA_CTX)\n\t\t\tif (!validate_za_context(za, err))\n\t\t\t\treturn false;\n\t\tif (new_flags & ZT_CTX)\n\t\t\tif (!validate_zt_context(zt, err))\n\t\t\t\treturn false;\n\n\t\tflags |= new_flags;\n\n\t\thead = GET_RESV_NEXT_HEAD(head);\n\t}\n\n\tif (terminated && !(flags & FPSIMD_CTX)) {\n\t\t*err = \"Missing FPSIMD\";\n\t\treturn false;\n\t}\n\n\tif (terminated && (flags & ZT_CTX) && !(flags & ZA_CTX)) {\n\t\t*err = \"ZT context but no ZA context\";\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstruct _aarch64_ctx *get_starting_head(struct _aarch64_ctx *shead,\n\t\t\t\t       size_t need_sz, size_t resv_sz,\n\t\t\t\t       size_t *offset)\n{\n\tsize_t offs = 0;\n\tstruct _aarch64_ctx *head;\n\n\thead = get_terminator(shead, resv_sz, &offs);\n\t \n\tif (!head)\n\t\treturn head;\n\tif (resv_sz - offs < need_sz) {\n\t\tfprintf(stderr, \"Low on space:%zd. Discarding extra_context.\\n\",\n\t\t\tresv_sz - offs);\n\t\thead = get_header(shead, EXTRA_MAGIC, resv_sz, &offs);\n\t\tif (!head || resv_sz - offs < need_sz) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Failed to reclaim space on sigframe.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"Available space:%zd\\n\", resv_sz - offs);\n\tif (offset)\n\t\t*offset = offs;\n\treturn head;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}