{
  "module_name": "ssve_za_regs.c",
  "hash_id": "e86f75b906d2f7fd0d794f85a58b7ee6809bbd797c39084d043d0fb71ef9f5de",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/signal/testcases/ssve_za_regs.c",
  "human_readable_source": "\n \n\n#include <signal.h>\n#include <ucontext.h>\n#include <sys/prctl.h>\n\n#include \"test_signals_utils.h\"\n#include \"testcases.h\"\n\nstatic union {\n\tucontext_t uc;\n\tchar buf[1024 * 128];\n} context;\nstatic unsigned int vls[SVE_VQ_MAX];\nunsigned int nvls = 0;\n\nstatic bool sme_get_vls(struct tdescr *td)\n{\n\tint vq, vl;\n\n\t \n\tfor (vq = SVE_VQ_MAX; vq > 0; --vq) {\n\t\tvl = prctl(PR_SME_SET_VL, vq * 16);\n\t\tif (vl == -1)\n\t\t\treturn false;\n\n\t\tvl &= PR_SME_VL_LEN_MASK;\n\n\t\t \n\t\tif (vq < sve_vq_from_vl(vl))\n\t\t\tbreak;\n\n\t\t \n\t\tvq = sve_vq_from_vl(vl);\n\n\t\tvls[nvls++] = vl;\n\t}\n\n\t \n\tif (nvls < 1) {\n\t\tfprintf(stderr, \"Only %d VL supported\\n\", nvls);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void setup_regs(void)\n{\n\t \n\tasm volatile(\".inst 0xd503437f\" : : : );\n\n\t \n\tasm volatile(\".inst 0xd503457f\" : : : );\n}\n\nstatic char zeros[ZA_SIG_REGS_SIZE(SVE_VQ_MAX)];\n\nstatic int do_one_sme_vl(struct tdescr *td, siginfo_t *si, ucontext_t *uc,\n\t\t\t unsigned int vl)\n{\n\tsize_t offset;\n\tstruct _aarch64_ctx *head = GET_BUF_RESV_HEAD(context);\n\tstruct _aarch64_ctx *regs;\n\tstruct sve_context *ssve;\n\tstruct za_context *za;\n\tint ret;\n\n\tfprintf(stderr, \"Testing VL %d\\n\", vl);\n\n\tret = prctl(PR_SME_SET_VL, vl);\n\tif (ret != vl) {\n\t\tfprintf(stderr, \"Failed to set VL, got %d\\n\", ret);\n\t\treturn 1;\n\t}\n\n\t \n\tsetup_regs();\n\tif (!get_current_context(td, &context.uc, sizeof(context)))\n\t\treturn 1;\n\n\tregs = get_header(head, SVE_MAGIC, GET_BUF_RESV_SIZE(context),\n\t\t\t  &offset);\n\tif (!regs) {\n\t\tfprintf(stderr, \"No SVE context\\n\");\n\t\treturn 1;\n\t}\n\n\tssve = (struct sve_context *)regs;\n\tif (ssve->vl != vl) {\n\t\tfprintf(stderr, \"Got SSVE VL %d, expected %d\\n\", ssve->vl, vl);\n\t\treturn 1;\n\t}\n\n\tif (!(ssve->flags & SVE_SIG_FLAG_SM)) {\n\t\tfprintf(stderr, \"SVE_SIG_FLAG_SM not set in SVE record\\n\");\n\t\treturn 1;\n\t}\n\n\tfprintf(stderr, \"Got expected SSVE size %u and VL %d\\n\",\n\t\tregs->size, ssve->vl);\n\n\tregs = get_header(head, ZA_MAGIC, GET_BUF_RESV_SIZE(context),\n\t\t\t  &offset);\n\tif (!regs) {\n\t\tfprintf(stderr, \"No ZA context\\n\");\n\t\treturn 1;\n\t}\n\n\tza = (struct za_context *)regs;\n\tif (za->vl != vl) {\n\t\tfprintf(stderr, \"Got ZA VL %d, expected %d\\n\", za->vl, vl);\n\t\treturn 1;\n\t}\n\n\tfprintf(stderr, \"Got expected ZA size %u and VL %d\\n\",\n\t\tregs->size, za->vl);\n\n\t \n\tif (memcmp(zeros, (char *)za + ZA_SIG_REGS_OFFSET,\n\t\t   ZA_SIG_REGS_SIZE(sve_vq_from_vl(za->vl))) != 0) {\n\t\tfprintf(stderr, \"ZA data invalid\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int sme_regs(struct tdescr *td, siginfo_t *si, ucontext_t *uc)\n{\n\tint i;\n\n\tfor (i = 0; i < nvls; i++) {\n\t\tif (do_one_sme_vl(td, si, uc, vls[i]))\n\t\t\treturn 1;\n\t}\n\n\ttd->pass = 1;\n\n\treturn 0;\n}\n\nstruct tdescr tde = {\n\t.name = \"Streaming SVE registers\",\n\t.descr = \"Check that we get the right Streaming SVE registers reported\",\n\t.feats_required = FEAT_SME,\n\t.timeout = 3,\n\t.init = sme_get_vls,\n\t.run = sme_regs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}