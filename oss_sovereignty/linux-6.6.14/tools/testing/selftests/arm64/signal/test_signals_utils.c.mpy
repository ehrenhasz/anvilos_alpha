{
  "module_name": "test_signals_utils.c",
  "hash_id": "be960ae5c877c2ae87c245e9c694ff5e599d83063a6173b37564a198319d172c",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/signal/test_signals_utils.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n#include <sys/auxv.h>\n#include <linux/auxvec.h>\n#include <ucontext.h>\n\n#include <asm/unistd.h>\n\n#include <kselftest.h>\n\n#include \"test_signals.h\"\n#include \"test_signals_utils.h\"\n#include \"testcases/testcases.h\"\n\n\nextern struct tdescr *current;\n\nstatic int sig_copyctx = SIGTRAP;\n\nstatic char const *const feats_names[FMAX_END] = {\n\t\" SSBS \",\n\t\" SVE \",\n\t\" SME \",\n\t\" FA64 \",\n\t\" SME2 \",\n};\n\n#define MAX_FEATS_SZ\t128\nstatic char feats_string[MAX_FEATS_SZ];\n\nstatic inline char *feats_to_string(unsigned long feats)\n{\n\tsize_t flen = MAX_FEATS_SZ - 1;\n\n\tfeats_string[0] = '\\0';\n\n\tfor (int i = 0; i < FMAX_END; i++) {\n\t\tif (feats & (1UL << i)) {\n\t\t\tsize_t tlen = strlen(feats_names[i]);\n\n\t\t\tassert(flen > tlen);\n\t\t\tflen -= tlen;\n\t\t\tstrncat(feats_string, feats_names[i], flen);\n\t\t}\n\t}\n\n\treturn feats_string;\n}\n\nstatic void unblock_signal(int signum)\n{\n\tsigset_t sset;\n\n\tsigemptyset(&sset);\n\tsigaddset(&sset, signum);\n\tsigprocmask(SIG_UNBLOCK, &sset, NULL);\n}\n\nstatic void default_result(struct tdescr *td, bool force_exit)\n{\n\tif (td->result == KSFT_SKIP) {\n\t\tfprintf(stderr, \"==>> completed. SKIP.\\n\");\n\t} else if (td->pass) {\n\t\tfprintf(stderr, \"==>> completed. PASS(1)\\n\");\n\t\ttd->result = KSFT_PASS;\n\t} else {\n\t\tfprintf(stdout, \"==>> completed. FAIL(0)\\n\");\n\t\ttd->result = KSFT_FAIL;\n\t}\n\n\tif (force_exit)\n\t\texit(td->result);\n}\n\n \n\nstatic bool handle_signal_unsupported(struct tdescr *td,\n\t\t\t\t      siginfo_t *si, void *uc)\n{\n\tif (feats_ok(td))\n\t\treturn false;\n\n\t \n\t((ucontext_t *)uc)->uc_mcontext.pc += 4;\n\n\tif (!td->initialized) {\n\t\tfprintf(stderr,\n\t\t\t\"Got SIG_UNSUPP @test_init. Ignore.\\n\");\n\t} else {\n\t\tfprintf(stderr,\n\t\t\t\"-- RX SIG_UNSUPP on unsupported feat...OK\\n\");\n\t\ttd->pass = 1;\n\t\tdefault_result(current, 1);\n\t}\n\n\treturn true;\n}\n\nstatic bool handle_signal_trigger(struct tdescr *td,\n\t\t\t\t  siginfo_t *si, void *uc)\n{\n\ttd->triggered = 1;\n\t \n\ttd->run(td, si, uc);\n\n\treturn true;\n}\n\nstatic bool handle_signal_ok(struct tdescr *td,\n\t\t\t     siginfo_t *si, void *uc)\n{\n\t \n\tassert(!td->sig_trig || td->triggered);\n\tfprintf(stderr,\n\t\t\"SIG_OK -- SP:0x%llX  si_addr@:%p  si_code:%d  token@:%p  offset:%ld\\n\",\n\t\t((ucontext_t *)uc)->uc_mcontext.sp,\n\t\tsi->si_addr, si->si_code, td->token, td->token - si->si_addr);\n\t \n\tif (!td->sanity_disabled && !td->token) {\n\t\tfprintf(stdout,\n\t\t\t\"current->token ZEROED...test is probably broken!\\n\");\n\t\tabort();\n\t}\n\t \n\tif (td->sig_ok == SIGSEGV && si->si_code != SEGV_ACCERR) {\n\t\tfprintf(stdout,\n\t\t\t\"si_code != SEGV_ACCERR...test is probably broken!\\n\");\n\t\tabort();\n\t}\n\ttd->pass = 1;\n\t \n\tdefault_result(current, 1);\n\n\treturn true;\n}\n\nstatic bool handle_signal_copyctx(struct tdescr *td,\n\t\t\t\t  siginfo_t *si, void *uc_in)\n{\n\tucontext_t *uc = uc_in;\n\tstruct _aarch64_ctx *head;\n\tstruct extra_context *extra, *copied_extra;\n\tsize_t offset = 0;\n\tsize_t to_copy;\n\n\tASSERT_GOOD_CONTEXT(uc);\n\n\t \n\tuc->uc_mcontext.pc += 4;\n\n\t \n\thead = (struct _aarch64_ctx *)uc->uc_mcontext.__reserved;\n\thead = get_header(head, EXTRA_MAGIC, td->live_sz, &offset);\n\tif (head) {\n\t\textra = (struct extra_context *)head;\n\n\t\t \n\t\tto_copy = __builtin_offsetof(ucontext_t,\n\t\t\t\t\t     uc_mcontext.__reserved);\n\t\tto_copy += offset + sizeof(struct extra_context) + 16;\n\t\tto_copy += extra->size;\n\t\tcopied_extra = (struct extra_context *)&(td->live_uc->uc_mcontext.__reserved[offset]);\n\t} else {\n\t\tcopied_extra = NULL;\n\t\tto_copy = sizeof(ucontext_t);\n\t}\n\n\tif (to_copy > td->live_sz) {\n\t\tfprintf(stderr,\n\t\t\t\"Not enough space to grab context, %lu/%lu bytes\\n\",\n\t\t\ttd->live_sz, to_copy);\n\t\treturn false;\n\t}\n\n\tmemcpy(td->live_uc, uc, to_copy);\n\n\t \n\tif (copied_extra)\n\t\tcopied_extra->head.size = sizeof(*copied_extra) + 16;\n\n\ttd->live_uc_valid = 1;\n\tfprintf(stderr,\n\t\t\"%lu byte GOOD CONTEXT grabbed from sig_copyctx handler\\n\",\n\t\tto_copy);\n\n\treturn true;\n}\n\nstatic void default_handler(int signum, siginfo_t *si, void *uc)\n{\n\tif (current->sig_unsupp && signum == current->sig_unsupp &&\n\t    handle_signal_unsupported(current, si, uc)) {\n\t\tfprintf(stderr, \"Handled SIG_UNSUPP\\n\");\n\t} else if (current->sig_trig && signum == current->sig_trig &&\n\t\t   handle_signal_trigger(current, si, uc)) {\n\t\tfprintf(stderr, \"Handled SIG_TRIG\\n\");\n\t} else if (current->sig_ok && signum == current->sig_ok &&\n\t\t   handle_signal_ok(current, si, uc)) {\n\t\tfprintf(stderr, \"Handled SIG_OK\\n\");\n\t} else if (signum == sig_copyctx && current->live_uc &&\n\t\t   handle_signal_copyctx(current, si, uc)) {\n\t\tfprintf(stderr, \"Handled SIG_COPYCTX\\n\");\n\t} else {\n\t\tif (signum == SIGALRM && current->timeout) {\n\t\t\tfprintf(stderr, \"-- Timeout !\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"-- RX UNEXPECTED SIGNAL: %d code %d address %p\\n\",\n\t\t\t\tsignum, si->si_code, si->si_addr);\n\t\t}\n\t\tdefault_result(current, 1);\n\t}\n}\n\nstatic int default_setup(struct tdescr *td)\n{\n\tstruct sigaction sa;\n\n\tsa.sa_sigaction = default_handler;\n\tsa.sa_flags = SA_SIGINFO | SA_RESTART;\n\tsa.sa_flags |= td->sa_flags;\n\tsigemptyset(&sa.sa_mask);\n\t \n\tfor (int sig = 1; sig < 32; sig++)\n\t\tsigaction(sig, &sa, NULL);\n\t \n\tfor (int sig = SIGRTMIN; sig <= SIGRTMAX; sig++)\n\t\tsigaction(sig, &sa, NULL);\n\n\t \n\tif (td->sig_trig)\n\t\tunblock_signal(td->sig_trig);\n\tif (td->sig_ok)\n\t\tunblock_signal(td->sig_ok);\n\tif (td->sig_unsupp)\n\t\tunblock_signal(td->sig_unsupp);\n\n\tif (td->timeout) {\n\t\tunblock_signal(SIGALRM);\n\t\talarm(td->timeout);\n\t}\n\tfprintf(stderr, \"Registered handlers for all signals.\\n\");\n\n\treturn 1;\n}\n\nstatic inline int default_trigger(struct tdescr *td)\n{\n\treturn !raise(td->sig_trig);\n}\n\nint test_init(struct tdescr *td)\n{\n\tif (td->sig_trig == sig_copyctx) {\n\t\tfprintf(stdout,\n\t\t\t\"Signal %d is RESERVED, cannot be used as a trigger. Aborting\\n\",\n\t\t\tsig_copyctx);\n\t\treturn 0;\n\t}\n\t \n\tunblock_signal(sig_copyctx);\n\n\ttd->minsigstksz = getauxval(AT_MINSIGSTKSZ);\n\tif (!td->minsigstksz)\n\t\ttd->minsigstksz = MINSIGSTKSZ;\n\tfprintf(stderr, \"Detected MINSTKSIGSZ:%d\\n\", td->minsigstksz);\n\n\tif (td->feats_required || td->feats_incompatible) {\n\t\ttd->feats_supported = 0;\n\t\t \n\t\tif (getauxval(AT_HWCAP) & HWCAP_SSBS)\n\t\t\ttd->feats_supported |= FEAT_SSBS;\n\t\tif (getauxval(AT_HWCAP) & HWCAP_SVE)\n\t\t\ttd->feats_supported |= FEAT_SVE;\n\t\tif (getauxval(AT_HWCAP2) & HWCAP2_SME)\n\t\t\ttd->feats_supported |= FEAT_SME;\n\t\tif (getauxval(AT_HWCAP2) & HWCAP2_SME_FA64)\n\t\t\ttd->feats_supported |= FEAT_SME_FA64;\n\t\tif (getauxval(AT_HWCAP2) & HWCAP2_SME2)\n\t\t\ttd->feats_supported |= FEAT_SME2;\n\t\tif (feats_ok(td)) {\n\t\t\tif (td->feats_required & td->feats_supported)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Required Features: [%s] supported\\n\",\n\t\t\t\t\tfeats_to_string(td->feats_required &\n\t\t\t\t\t\t\ttd->feats_supported));\n\t\t\tif (!(td->feats_incompatible & td->feats_supported))\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Incompatible Features: [%s] absent\\n\",\n\t\t\t\t\tfeats_to_string(td->feats_incompatible));\n\t\t} else {\n\t\t\tif ((td->feats_required & td->feats_supported) !=\n\t\t\t    td->feats_supported)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Required Features: [%s] NOT supported\\n\",\n\t\t\t\t\tfeats_to_string(td->feats_required &\n\t\t\t\t\t\t\t~td->feats_supported));\n\t\t\tif (td->feats_incompatible & td->feats_supported)\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Incompatible Features: [%s] supported\\n\",\n\t\t\t\t\tfeats_to_string(td->feats_incompatible &\n\t\t\t\t\t\t\t~td->feats_supported));\n\n\n\t\t\ttd->result = KSFT_SKIP;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (td->init && !td->init(td)) {\n\t\tfprintf(stderr, \"FAILED Testcase initialization.\\n\");\n\t\treturn 0;\n\t}\n\ttd->initialized = 1;\n\tfprintf(stderr, \"Testcase initialized.\\n\");\n\n\treturn 1;\n}\n\nint test_setup(struct tdescr *td)\n{\n\t \n\tassert(current);\n\tassert(td);\n\tassert(td->name);\n\tassert(td->run);\n\n\t \n\ttd->result = KSFT_FAIL;\n\tif (td->setup)\n\t\treturn td->setup(td);\n\telse\n\t\treturn default_setup(td);\n}\n\nint test_run(struct tdescr *td)\n{\n\tif (td->trigger)\n\t\treturn td->trigger(td);\n\telse if (td->sig_trig)\n\t\treturn default_trigger(td);\n\telse\n\t\treturn td->run(td, NULL, NULL);\n}\n\nvoid test_result(struct tdescr *td)\n{\n\tif (td->initialized && td->result != KSFT_SKIP && td->check_result)\n\t\ttd->check_result(td);\n\tdefault_result(td, 0);\n}\n\nvoid test_cleanup(struct tdescr *td)\n{\n\tif (td->cleanup)\n\t\ttd->cleanup(td);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}