{
  "module_name": "test.c",
  "hash_id": "4310261f892ccfb870766fba0f8ecb803529cfc0409b251506e90a203b92c4a2",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/bti/test.c",
  "human_readable_source": "\n \n\n#include \"system.h\"\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <linux/errno.h>\n#include <linux/auxvec.h>\n#include <linux/signal.h>\n#include <asm/sigcontext.h>\n#include <asm/ucontext.h>\n\ntypedef struct ucontext ucontext_t;\n\n#include \"btitest.h\"\n#include \"signal.h\"\n\n#define EXPECTED_TESTS 18\n\nstatic volatile unsigned int test_num = 1;\nstatic unsigned int test_passed;\nstatic unsigned int test_failed;\nstatic unsigned int test_skipped;\n\nstatic void fdputs(int fd, const char *str)\n{\n\tsize_t len = 0;\n\tconst char *p = str;\n\n\twhile (*p++)\n\t\t++len;\n\n\twrite(fd, str, len);\n}\n\nstatic void putstr(const char *str)\n{\n\tfdputs(1, str);\n}\n\nstatic void putnum(unsigned int num)\n{\n\tchar c;\n\n\tif (num / 10)\n\t\tputnum(num / 10);\n\n\tc = '0' + (num % 10);\n\twrite(1, &c, 1);\n}\n\n#define puttestname(test_name, trampoline_name) do {\t\\\n\tputstr(test_name);\t\t\t\t\\\n\tputstr(\"/\");\t\t\t\t\t\\\n\tputstr(trampoline_name);\t\t\t\\\n} while (0)\n\nvoid print_summary(void)\n{\n\tputstr(\"# Totals: pass:\");\n\tputnum(test_passed);\n\tputstr(\" fail:\");\n\tputnum(test_failed);\n\tputstr(\" xfail:0 xpass:0 skip:\");\n\tputnum(test_skipped);\n\tputstr(\" error:0\\n\");\n}\n\nstatic const char *volatile current_test_name;\nstatic const char *volatile current_trampoline_name;\nstatic volatile int sigill_expected, sigill_received;\n\nstatic void handler(int n, siginfo_t *si __always_unused,\n\t\t    void *uc_ __always_unused)\n{\n\tucontext_t *uc = uc_;\n\n\tputstr(\"# \\t[SIGILL in \");\n\tputtestname(current_test_name, current_trampoline_name);\n\tputstr(\", BTYPE=\");\n\twrite(1, &\"00011011\"[((uc->uc_mcontext.pstate & PSR_BTYPE_MASK)\n\t\t\t      >> PSR_BTYPE_SHIFT) * 2], 2);\n\tif (!sigill_expected) {\n\t\tputstr(\"]\\n\");\n\t\tputstr(\"not ok \");\n\t\tputnum(test_num);\n\t\tputstr(\" \");\n\t\tputtestname(current_test_name, current_trampoline_name);\n\t\tputstr(\"(unexpected SIGILL)\\n\");\n\t\tprint_summary();\n\t\texit(128 + n);\n\t}\n\n\tputstr(\" (expected)]\\n\");\n\tsigill_received = 1;\n\t \n\tuc->uc_mcontext.pstate &= ~PSR_BTYPE_MASK;\n}\n\n \nstatic bool have_bti;\n\nstatic void __do_test(void (*trampoline)(void (*)(void)),\n\t\t      void (*fn)(void),\n\t\t      const char *trampoline_name,\n\t\t      const char *name,\n\t\t      int expect_sigill)\n{\n\t \n\tif (!BTI || !have_bti)\n\t\texpect_sigill = 0;\n\n\tsigill_expected = expect_sigill;\n\tsigill_received = 0;\n\tcurrent_test_name = name;\n\tcurrent_trampoline_name = trampoline_name;\n\n\ttrampoline(fn);\n\n\tif (expect_sigill && !sigill_received) {\n\t\tputstr(\"not ok \");\n\t\ttest_failed++;\n\t} else {\n\t\tputstr(\"ok \");\n\t\ttest_passed++;\n\t}\n\tputnum(test_num++);\n\tputstr(\" \");\n\tputtestname(name, trampoline_name);\n\tputstr(\"\\n\");\n}\n\n#define do_test(expect_sigill_br_x0,\t\t\t\t\t\\\n\t\texpect_sigill_br_x16,\t\t\t\t\t\\\n\t\texpect_sigill_blr,\t\t\t\t\t\\\n\t\tname)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t__do_test(call_using_br_x0, name, \"call_using_br_x0\", #name,\t\\\n\t\t  expect_sigill_br_x0);\t\t\t\t\t\\\n\t__do_test(call_using_br_x16, name, \"call_using_br_x16\", #name,\t\\\n\t\t  expect_sigill_br_x16);\t\t\t\t\\\n\t__do_test(call_using_blr, name, \"call_using_blr\", #name,\t\\\n\t\t  expect_sigill_blr);\t\t\t\t\t\\\n} while (0)\n\nvoid start(int *argcp)\n{\n\tstruct sigaction sa;\n\tvoid *const *p;\n\tconst struct auxv_entry {\n\t\tunsigned long type;\n\t\tunsigned long val;\n\t} *auxv;\n\tunsigned long hwcap = 0, hwcap2 = 0;\n\n\tputstr(\"TAP version 13\\n\");\n\tputstr(\"1..\");\n\tputnum(EXPECTED_TESTS);\n\tputstr(\"\\n\");\n\n\t \n\tp = (void *const *)argcp + 1 + *argcp + 1;  \n\t \n\twhile (*p++)\n\t\t;\n\tfor (auxv = (const struct auxv_entry *)p; auxv->type != AT_NULL; ++auxv) {\n\t\tswitch (auxv->type) {\n\t\tcase AT_HWCAP:\n\t\t\thwcap = auxv->val;\n\t\t\tbreak;\n\t\tcase AT_HWCAP2:\n\t\t\thwcap2 = auxv->val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (hwcap & HWCAP_PACA)\n\t\tputstr(\"# HWCAP_PACA present\\n\");\n\telse\n\t\tputstr(\"# HWCAP_PACA not present\\n\");\n\n\tif (hwcap2 & HWCAP2_BTI) {\n\t\tputstr(\"# HWCAP2_BTI present\\n\");\n\t\tif (!(hwcap & HWCAP_PACA))\n\t\t\tputstr(\"# Bad hardware?  Expect problems.\\n\");\n\t\thave_bti = true;\n\t} else {\n\t\tputstr(\"# HWCAP2_BTI not present\\n\");\n\t\thave_bti = false;\n\t}\n\n\tputstr(\"# Test binary\");\n\tif (!BTI)\n\t\tputstr(\" not\");\n\tputstr(\" built for BTI\\n\");\n\n\tsa.sa_handler = (sighandler_t)(void *)handler;\n\tsa.sa_flags = SA_SIGINFO;\n\tsigemptyset(&sa.sa_mask);\n\tsigaction(SIGILL, &sa, NULL);\n\tsigaddset(&sa.sa_mask, SIGILL);\n\tsigprocmask(SIG_UNBLOCK, &sa.sa_mask, NULL);\n\n\tdo_test(1, 1, 1, nohint_func);\n\tdo_test(1, 1, 1, bti_none_func);\n\tdo_test(1, 0, 0, bti_c_func);\n\tdo_test(0, 0, 1, bti_j_func);\n\tdo_test(0, 0, 0, bti_jc_func);\n\tdo_test(1, 0, 0, paciasp_func);\n\n\tprint_summary();\n\n\tif (test_num - 1 != EXPECTED_TESTS)\n\t\tputstr(\"# WARNING - EXPECTED TEST COUNT WRONG\\n\");\n\n\tif (test_failed)\n\t\texit(1);\n\telse\n\t\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}