{
  "module_name": "vlset.c",
  "hash_id": "4f0ab6be2cda28829f6e99b3fe49599a62f5213701eade2a03ca194274a1bd99",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/fp/vlset.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <assert.h>\n#include <errno.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <asm/hwcap.h>\n#include <asm/sigcontext.h>\n\nstatic int inherit = 0;\nstatic int no_inherit = 0;\nstatic int force = 0;\nstatic unsigned long vl;\nstatic int set_ctl = PR_SVE_SET_VL;\nstatic int get_ctl = PR_SVE_GET_VL;\n\nstatic const struct option options[] = {\n\t{ \"force\",\tno_argument, NULL, 'f' },\n\t{ \"inherit\",\tno_argument, NULL, 'i' },\n\t{ \"max\",\tno_argument, NULL, 'M' },\n\t{ \"no-inherit\",\tno_argument, &no_inherit, 1 },\n\t{ \"sme\",\tno_argument, NULL, 's' },\n\t{ \"help\",\tno_argument, NULL, '?' },\n\t{}\n};\n\nstatic char const *program_name;\n\nstatic int parse_options(int argc, char **argv)\n{\n\tint c;\n\tchar *rest;\n\n\tprogram_name = strrchr(argv[0], '/');\n\tif (program_name)\n\t\t++program_name;\n\telse\n\t\tprogram_name = argv[0];\n\n\twhile ((c = getopt_long(argc, argv, \"Mfhi\", options, NULL)) != -1)\n\t\tswitch (c) {\n\t\tcase 'M':\tvl = SVE_VL_MAX; break;\n\t\tcase 'f':\tforce = 1; break;\n\t\tcase 'i':\tinherit = 1; break;\n\t\tcase 's':\tset_ctl = PR_SME_SET_VL;\n\t\t\t\tget_ctl = PR_SME_GET_VL;\n\t\t\t\tbreak;\n\t\tcase 0:\t\tbreak;\n\t\tdefault:\tgoto error;\n\t\t}\n\n\tif (inherit && no_inherit)\n\t\tgoto error;\n\n\tif (!vl) {\n\t\t \n\t\tif (optind >= argc)\n\t\t\tgoto error;\n\n\t\terrno = 0;\n\t\tvl = strtoul(argv[optind], &rest, 0);\n\t\tif (*rest) {\n\t\t\tvl = ULONG_MAX;\n\t\t\terrno = EINVAL;\n\t\t}\n\t\tif (vl == ULONG_MAX && errno) {\n\t\t\tfprintf(stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprogram_name, argv[optind], strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\n\t\t++optind;\n\t}\n\n\t \n\tif (optind >= argc)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tfprintf(stderr,\n\t\t\"Usage: %s [-f | --force] \"\n\t\t\"[-i | --inherit | --no-inherit] \"\n\t\t\"{-M | --max | <vector length>} \"\n\t\t\"<command> [<arguments> ...]\\n\",\n\t\tprogram_name);\n\treturn -1;\n}\n\nint main(int argc, char **argv)\n{\n\tint ret = 126;\t \n\tlong flags;\n\tchar *path;\n\tint t, e;\n\n\tif (parse_options(argc, argv))\n\t\treturn 2;\t \n\n\tif (vl & ~(vl & PR_SVE_VL_LEN_MASK)) {\n\t\tfprintf(stderr, \"%s: Invalid vector length %lu\\n\",\n\t\t\tprogram_name, vl);\n\t\treturn 2;\t \n\t}\n\n\tif (!(getauxval(AT_HWCAP) & HWCAP_SVE)) {\n\t\tfprintf(stderr, \"%s: Scalable Vector Extension not present\\n\",\n\t\t\tprogram_name);\n\n\t\tif (!force)\n\t\t\tgoto error;\n\n\t\tfputs(\"Going ahead anyway (--force):  \"\n\t\t      \"This is a debug option.  Don't rely on it.\\n\",\n\t\t      stderr);\n\t}\n\n\tflags = PR_SVE_SET_VL_ONEXEC;\n\tif (inherit)\n\t\tflags |= PR_SVE_VL_INHERIT;\n\n\tt = prctl(set_ctl, vl | flags);\n\tif (t < 0) {\n\t\tfprintf(stderr, \"%s: PR_SVE_SET_VL: %s\\n\",\n\t\t\tprogram_name, strerror(errno));\n\t\tgoto error;\n\t}\n\n\tt = prctl(get_ctl);\n\tif (t == -1) {\n\t\tfprintf(stderr, \"%s: PR_SVE_GET_VL: %s\\n\",\n\t\t\tprogram_name, strerror(errno));\n\t\tgoto error;\n\t}\n\tflags = PR_SVE_VL_LEN_MASK;\n\tflags = t & ~flags;\n\n\tassert(optind < argc);\n\tpath = argv[optind];\n\n\texecvp(path, &argv[optind]);\n\te = errno;\n\tif (errno == ENOENT)\n\t\tret = 127;\t \n\tfprintf(stderr, \"%s: %s: %s\\n\", program_name, path, strerror(e));\n\nerror:\n\treturn ret;\t\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}