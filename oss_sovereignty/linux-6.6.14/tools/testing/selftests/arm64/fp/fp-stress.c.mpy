{
  "module_name": "fp-stress.c",
  "hash_id": "f5e19d92c41ad4a44eb142a16c56291dc4bdcf15f8383664359ee12c49ade0cd",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/fp/fp-stress.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#define _POSIX_C_SOURCE 199309L\n\n#include <errno.h>\n#include <getopt.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/epoll.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n#include <asm/hwcap.h>\n\n#include \"../../kselftest.h\"\n\n#define MAX_VLS 16\n\nstruct child_data {\n\tchar *name, *output;\n\tpid_t pid;\n\tint stdout;\n\tbool output_seen;\n\tbool exited;\n\tint exit_status;\n};\n\nstatic int epoll_fd;\nstatic struct child_data *children;\nstatic struct epoll_event *evs;\nstatic int tests;\nstatic int num_children;\nstatic bool terminate;\n\nstatic int startup_pipe[2];\n\nstatic int num_processors(void)\n{\n\tlong nproc = sysconf(_SC_NPROCESSORS_CONF);\n\tif (nproc < 0) {\n\t\tperror(\"Unable to read number of processors\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn nproc;\n}\n\nstatic void child_start(struct child_data *child, const char *program)\n{\n\tint ret, pipefd[2], i;\n\tstruct epoll_event ev;\n\n\tret = pipe(pipefd);\n\tif (ret != 0)\n\t\tksft_exit_fail_msg(\"Failed to create stdout pipe: %s (%d)\\n\",\n\t\t\t\t   strerror(errno), errno);\n\n\tchild->pid = fork();\n\tif (child->pid == -1)\n\t\tksft_exit_fail_msg(\"fork() failed: %s (%d)\\n\",\n\t\t\t\t   strerror(errno), errno);\n\n\tif (!child->pid) {\n\t\t \n\t\tret = dup2(pipefd[1], 1);\n\t\tif (ret == -1) {\n\t\t\tfprintf(stderr, \"dup2() %d\\n\", errno);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t \n\t\tret = dup2(startup_pipe[0], 3);\n\t\tif (ret == -1) {\n\t\t\tfprintf(stderr, \"dup2() %d\\n\", errno);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t \n\t\tfor (i = 4; i < 8192; i++)\n\t\t\tclose(i);\n\n\t\t \n\t\tret = read(3, &i, sizeof(i));\n\t\tif (ret < 0)\n\t\t\tfprintf(stderr, \"read(startp pipe) failed: %s (%d)\\n\",\n\t\t\t\tstrerror(errno), errno);\n\t\tif (ret > 0)\n\t\t\tfprintf(stderr, \"%d bytes of data on startup pipe\\n\",\n\t\t\t\tret);\n\t\tclose(3);\n\n\t\tret = execl(program, program, NULL);\n\t\tfprintf(stderr, \"execl(%s) failed: %d (%s)\\n\",\n\t\t\tprogram, errno, strerror(errno));\n\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\t \n\t\tclose(pipefd[1]);\n\t\tchild->stdout = pipefd[0];\n\t\tchild->output = NULL;\n\t\tchild->exited = false;\n\t\tchild->output_seen = false;\n\n\t\tev.events = EPOLLIN | EPOLLHUP;\n\t\tev.data.ptr = child;\n\n\t\tret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, child->stdout, &ev);\n\t\tif (ret < 0) {\n\t\t\tksft_exit_fail_msg(\"%s EPOLL_CTL_ADD failed: %s (%d)\\n\",\n\t\t\t\t\t   child->name, strerror(errno), errno);\n\t\t}\n\t}\n}\n\nstatic bool child_output_read(struct child_data *child)\n{\n\tchar read_data[1024];\n\tchar work[1024];\n\tint ret, len, cur_work, cur_read;\n\n\tret = read(child->stdout, read_data, sizeof(read_data));\n\tif (ret < 0) {\n\t\tif (errno == EINTR)\n\t\t\treturn true;\n\n\t\tksft_print_msg(\"%s: read() failed: %s (%d)\\n\",\n\t\t\t       child->name, strerror(errno),\n\t\t\t       errno);\n\t\treturn false;\n\t}\n\tlen = ret;\n\n\tchild->output_seen = true;\n\n\t \n\tif (child->output) {\n\t\tstrncpy(work, child->output, sizeof(work) - 1);\n\t\tcur_work = strnlen(work, sizeof(work));\n\t\tfree(child->output);\n\t\tchild->output = NULL;\n\t} else {\n\t\tcur_work = 0;\n\t}\n\n\tcur_read = 0;\n\twhile (cur_read < len) {\n\t\twork[cur_work] = read_data[cur_read++];\n\n\t\tif (work[cur_work] == '\\n') {\n\t\t\twork[cur_work] = '\\0';\n\t\t\tksft_print_msg(\"%s: %s\\n\", child->name, work);\n\t\t\tcur_work = 0;\n\t\t} else {\n\t\t\tcur_work++;\n\t\t}\n\t}\n\n\tif (cur_work) {\n\t\twork[cur_work] = '\\0';\n\t\tret = asprintf(&child->output, \"%s\", work);\n\t\tif (ret == -1)\n\t\t\tksft_exit_fail_msg(\"Out of memory\\n\");\n\t}\n\n\treturn false;\n}\n\nstatic void child_output(struct child_data *child, uint32_t events,\n\t\t\t bool flush)\n{\n\tbool read_more;\n\n\tif (events & EPOLLIN) {\n\t\tdo {\n\t\t\tread_more = child_output_read(child);\n\t\t} while (read_more);\n\t}\n\n\tif (events & EPOLLHUP) {\n\t\tclose(child->stdout);\n\t\tchild->stdout = -1;\n\t\tflush = true;\n\t}\n\n\tif (flush && child->output) {\n\t\tksft_print_msg(\"%s: %s<EOF>\\n\", child->name, child->output);\n\t\tfree(child->output);\n\t\tchild->output = NULL;\n\t}\n}\n\nstatic void child_tickle(struct child_data *child)\n{\n\tif (child->output_seen && !child->exited)\n\t\tkill(child->pid, SIGUSR2);\n}\n\nstatic void child_stop(struct child_data *child)\n{\n\tif (!child->exited)\n\t\tkill(child->pid, SIGTERM);\n}\n\nstatic void child_cleanup(struct child_data *child)\n{\n\tpid_t ret;\n\tint status;\n\tbool fail = false;\n\n\tif (!child->exited) {\n\t\tdo {\n\t\t\tret = waitpid(child->pid, &status, 0);\n\t\t\tif (ret == -1 && errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tif (ret == -1) {\n\t\t\t\tksft_print_msg(\"waitpid(%d) failed: %s (%d)\\n\",\n\t\t\t\t\t       child->pid, strerror(errno),\n\t\t\t\t\t       errno);\n\t\t\t\tfail = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!WIFEXITED(status));\n\t\tchild->exit_status = WEXITSTATUS(status);\n\t}\n\n\tif (!child->output_seen) {\n\t\tksft_print_msg(\"%s no output seen\\n\", child->name);\n\t\tfail = true;\n\t}\n\n\tif (child->exit_status != 0) {\n\t\tksft_print_msg(\"%s exited with error code %d\\n\",\n\t\t\t       child->name, child->exit_status);\n\t\tfail = true;\n\t}\n\n\tksft_test_result(!fail, \"%s\\n\", child->name);\n}\n\nstatic void handle_child_signal(int sig, siginfo_t *info, void *context)\n{\n\tint i;\n\tbool found = false;\n\n\tfor (i = 0; i < num_children; i++) {\n\t\tif (children[i].pid == info->si_pid) {\n\t\t\tchildren[i].exited = true;\n\t\t\tchildren[i].exit_status = info->si_status;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tksft_print_msg(\"SIGCHLD for unknown PID %d with status %d\\n\",\n\t\t\t       info->si_pid, info->si_status);\n}\n\nstatic void handle_exit_signal(int sig, siginfo_t *info, void *context)\n{\n\tint i;\n\n\t \n\tif (terminate)\n\t\treturn;\n\n\tksft_print_msg(\"Got signal, exiting...\\n\");\n\n\tterminate = true;\n\n\t \n\tfor (i = 0; i < num_children; i++)\n\t\tchild_stop(&children[i]);\n}\n\nstatic void start_fpsimd(struct child_data *child, int cpu, int copy)\n{\n\tint ret;\n\n\tret = asprintf(&child->name, \"FPSIMD-%d-%d\", cpu, copy);\n\tif (ret == -1)\n\t\tksft_exit_fail_msg(\"asprintf() failed\\n\");\n\n\tchild_start(child, \"./fpsimd-test\");\n\n\tksft_print_msg(\"Started %s\\n\", child->name);\n}\n\nstatic void start_sve(struct child_data *child, int vl, int cpu)\n{\n\tint ret;\n\n\tret = prctl(PR_SVE_SET_VL, vl | PR_SVE_VL_INHERIT);\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"Failed to set SVE VL %d\\n\", vl);\n\n\tret = asprintf(&child->name, \"SVE-VL-%d-%d\", vl, cpu);\n\tif (ret == -1)\n\t\tksft_exit_fail_msg(\"asprintf() failed\\n\");\n\n\tchild_start(child, \"./sve-test\");\n\n\tksft_print_msg(\"Started %s\\n\", child->name);\n}\n\nstatic void start_ssve(struct child_data *child, int vl, int cpu)\n{\n\tint ret;\n\n\tret = asprintf(&child->name, \"SSVE-VL-%d-%d\", vl, cpu);\n\tif (ret == -1)\n\t\tksft_exit_fail_msg(\"asprintf() failed\\n\");\n\n\tret = prctl(PR_SME_SET_VL, vl | PR_SME_VL_INHERIT);\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"Failed to set SME VL %d\\n\", ret);\n\n\tchild_start(child, \"./ssve-test\");\n\n\tksft_print_msg(\"Started %s\\n\", child->name);\n}\n\nstatic void start_za(struct child_data *child, int vl, int cpu)\n{\n\tint ret;\n\n\tret = prctl(PR_SME_SET_VL, vl | PR_SVE_VL_INHERIT);\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"Failed to set SME VL %d\\n\", ret);\n\n\tret = asprintf(&child->name, \"ZA-VL-%d-%d\", vl, cpu);\n\tif (ret == -1)\n\t\tksft_exit_fail_msg(\"asprintf() failed\\n\");\n\n\tchild_start(child, \"./za-test\");\n\n\tksft_print_msg(\"Started %s\\n\", child->name);\n}\n\nstatic void start_zt(struct child_data *child, int cpu)\n{\n\tint ret;\n\n\tret = asprintf(&child->name, \"ZT-%d\", cpu);\n\tif (ret == -1)\n\t\tksft_exit_fail_msg(\"asprintf() failed\\n\");\n\n\tchild_start(child, \"./zt-test\");\n\n\tksft_print_msg(\"Started %s\\n\", child->name);\n}\n\nstatic void probe_vls(int vls[], int *vl_count, int set_vl)\n{\n\tunsigned int vq;\n\tint vl;\n\n\t*vl_count = 0;\n\n\tfor (vq = SVE_VQ_MAX; vq > 0; vq /= 2) {\n\t\tvl = prctl(set_vl, vq * 16);\n\t\tif (vl == -1)\n\t\t\tksft_exit_fail_msg(\"SET_VL failed: %s (%d)\\n\",\n\t\t\t\t\t   strerror(errno), errno);\n\n\t\tvl &= PR_SVE_VL_LEN_MASK;\n\n\t\tif (*vl_count && (vl == vls[*vl_count - 1]))\n\t\t\tbreak;\n\n\t\tvq = sve_vq_from_vl(vl);\n\n\t\tvls[*vl_count] = vl;\n\t\t*vl_count += 1;\n\t}\n}\n\n \nstatic void drain_output(bool flush)\n{\n\tint ret = 1;\n\tint i;\n\n\twhile (ret > 0) {\n\t\tret = epoll_wait(epoll_fd, evs, tests, 0);\n\t\tif (ret < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tksft_print_msg(\"epoll_wait() failed: %s (%d)\\n\",\n\t\t\t\t       strerror(errno), errno);\n\t\t}\n\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tchild_output(evs[i].data.ptr, evs[i].events, flush);\n\t}\n}\n\nstatic const struct option options[] = {\n\t{ \"timeout\",\trequired_argument, NULL, 't' },\n\t{ }\n};\n\nint main(int argc, char **argv)\n{\n\tint ret;\n\tint timeout = 10;\n\tint cpus, i, j, c;\n\tint sve_vl_count, sme_vl_count, fpsimd_per_cpu;\n\tbool all_children_started = false;\n\tint seen_children;\n\tint sve_vls[MAX_VLS], sme_vls[MAX_VLS];\n\tbool have_sme2;\n\tstruct sigaction sa;\n\n\twhile ((c = getopt_long(argc, argv, \"t:\", options, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 't':\n\t\t\tret = sscanf(optarg, \"%d\", &timeout);\n\t\t\tif (ret != 1)\n\t\t\t\tksft_exit_fail_msg(\"Failed to parse timeout %s\\n\",\n\t\t\t\t\t\t   optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tksft_exit_fail_msg(\"Unknown argument\\n\");\n\t\t}\n\t}\n\n\tcpus = num_processors();\n\ttests = 0;\n\n\tif (getauxval(AT_HWCAP) & HWCAP_SVE) {\n\t\tprobe_vls(sve_vls, &sve_vl_count, PR_SVE_SET_VL);\n\t\ttests += sve_vl_count * cpus;\n\t} else {\n\t\tsve_vl_count = 0;\n\t}\n\n\tif (getauxval(AT_HWCAP2) & HWCAP2_SME) {\n\t\tprobe_vls(sme_vls, &sme_vl_count, PR_SME_SET_VL);\n\t\ttests += sme_vl_count * cpus * 2;\n\t} else {\n\t\tsme_vl_count = 0;\n\t}\n\n\tif (getauxval(AT_HWCAP2) & HWCAP2_SME2) {\n\t\ttests += cpus;\n\t\thave_sme2 = true;\n\t} else {\n\t\thave_sme2 = false;\n\t}\n\n\t \n\tif (!sve_vl_count && !sme_vl_count)\n\t\tfpsimd_per_cpu = 2;\n\telse\n\t\tfpsimd_per_cpu = 1;\n\ttests += cpus * fpsimd_per_cpu;\n\n\tksft_print_header();\n\tksft_set_plan(tests);\n\n\tksft_print_msg(\"%d CPUs, %d SVE VLs, %d SME VLs, SME2 %s\\n\",\n\t\t       cpus, sve_vl_count, sme_vl_count,\n\t\t       have_sme2 ? \"present\" : \"absent\");\n\n\tif (timeout > 0)\n\t\tksft_print_msg(\"Will run for %ds\\n\", timeout);\n\telse\n\t\tksft_print_msg(\"Will run until terminated\\n\");\n\n\tchildren = calloc(sizeof(*children), tests);\n\tif (!children)\n\t\tksft_exit_fail_msg(\"Unable to allocate child data\\n\");\n\n\tret = epoll_create1(EPOLL_CLOEXEC);\n\tif (ret < 0)\n\t\tksft_exit_fail_msg(\"epoll_create1() failed: %s (%d)\\n\",\n\t\t\t\t   strerror(errno), ret);\n\tepoll_fd = ret;\n\n\t \n\tret = pipe(startup_pipe);\n\tif (ret != 0)\n\t\tksft_exit_fail_msg(\"Failed to create startup pipe: %s (%d)\\n\",\n\t\t\t\t   strerror(errno), errno);\n\n\t \n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_sigaction = handle_exit_signal;\n\tsa.sa_flags = SA_RESTART | SA_SIGINFO;\n\tsigemptyset(&sa.sa_mask);\n\tret = sigaction(SIGINT, &sa, NULL);\n\tif (ret < 0)\n\t\tksft_print_msg(\"Failed to install SIGINT handler: %s (%d)\\n\",\n\t\t\t       strerror(errno), errno);\n\tret = sigaction(SIGTERM, &sa, NULL);\n\tif (ret < 0)\n\t\tksft_print_msg(\"Failed to install SIGTERM handler: %s (%d)\\n\",\n\t\t\t       strerror(errno), errno);\n\tsa.sa_sigaction = handle_child_signal;\n\tret = sigaction(SIGCHLD, &sa, NULL);\n\tif (ret < 0)\n\t\tksft_print_msg(\"Failed to install SIGCHLD handler: %s (%d)\\n\",\n\t\t\t       strerror(errno), errno);\n\n\tevs = calloc(tests, sizeof(*evs));\n\tif (!evs)\n\t\tksft_exit_fail_msg(\"Failed to allocated %d epoll events\\n\",\n\t\t\t\t   tests);\n\n\tfor (i = 0; i < cpus; i++) {\n\t\tfor (j = 0; j < fpsimd_per_cpu; j++)\n\t\t\tstart_fpsimd(&children[num_children++], i, j);\n\n\t\tfor (j = 0; j < sve_vl_count; j++)\n\t\t\tstart_sve(&children[num_children++], sve_vls[j], i);\n\n\t\tfor (j = 0; j < sme_vl_count; j++) {\n\t\t\tstart_ssve(&children[num_children++], sme_vls[j], i);\n\t\t\tstart_za(&children[num_children++], sme_vls[j], i);\n\t\t}\n\n\t\tif (have_sme2)\n\t\t\tstart_zt(&children[num_children++], i);\n\t}\n\n\t \n\tclose(startup_pipe[0]);\n\tclose(startup_pipe[1]);\n\n\tfor (;;) {\n\t\t \n\t\tif (terminate)\n\t\t\tbreak;\n\n\t\t \n\t\tret = epoll_wait(epoll_fd, evs, tests, 1000);\n\t\tif (ret < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tksft_exit_fail_msg(\"epoll_wait() failed: %s (%d)\\n\",\n\t\t\t\t\t   strerror(errno), errno);\n\t\t}\n\n\t\t \n\t\tif (ret > 0) {\n\t\t\tfor (i = 0; i < ret; i++) {\n\t\t\t\tchild_output(evs[i].data.ptr, evs[i].events,\n\t\t\t\t\t     false);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (!all_children_started) {\n\t\t\tseen_children = 0;\n\n\t\t\tfor (i = 0; i < num_children; i++)\n\t\t\t\tif (children[i].output_seen ||\n\t\t\t\t    children[i].exited)\n\t\t\t\t\tseen_children++;\n\n\t\t\tif (seen_children != num_children) {\n\t\t\t\tksft_print_msg(\"Waiting for %d children\\n\",\n\t\t\t\t\t       num_children - seen_children);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tall_children_started = true;\n\t\t}\n\n\t\tksft_print_msg(\"Sending signals, timeout remaining: %d\\n\",\n\t\t\t       timeout);\n\n\t\tfor (i = 0; i < num_children; i++)\n\t\t\tchild_tickle(&children[i]);\n\n\t\t \n\t\tif (timeout < 0)\n\t\t\tcontinue;\n\t\tif (--timeout == 0)\n\t\t\tbreak;\n\t}\n\n\tksft_print_msg(\"Finishing up...\\n\");\n\tterminate = true;\n\n\tfor (i = 0; i < tests; i++)\n\t\tchild_stop(&children[i]);\n\n\tdrain_output(false);\n\n\tfor (i = 0; i < tests; i++)\n\t\tchild_cleanup(&children[i]);\n\n\tdrain_output(true);\n\n\tksft_print_cnts();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}