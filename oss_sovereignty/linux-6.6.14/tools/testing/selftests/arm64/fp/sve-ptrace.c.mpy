{
  "module_name": "sve-ptrace.c",
  "hash_id": "dbc1d0bf92371d142b2e0bdfa973371e5f9d252b04b69369f6ca0bc2edf42f0e",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/fp/sve-ptrace.c",
  "human_readable_source": "\n \n#include <errno.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n#include <asm/sigcontext.h>\n#include <asm/ptrace.h>\n\n#include \"../../kselftest.h\"\n\n \n#ifndef NT_ARM_SVE\n#define NT_ARM_SVE 0x405\n#endif\n\n#ifndef NT_ARM_SSVE\n#define NT_ARM_SSVE 0x40b\n#endif\n\n \n#define TEST_VQ_MAX 17\n\nstruct vec_type {\n\tconst char *name;\n\tunsigned long hwcap_type;\n\tunsigned long hwcap;\n\tint regset;\n\tint prctl_set;\n};\n\nstatic const struct vec_type vec_types[] = {\n\t{\n\t\t.name = \"SVE\",\n\t\t.hwcap_type = AT_HWCAP,\n\t\t.hwcap = HWCAP_SVE,\n\t\t.regset = NT_ARM_SVE,\n\t\t.prctl_set = PR_SVE_SET_VL,\n\t},\n\t{\n\t\t.name = \"Streaming SVE\",\n\t\t.hwcap_type = AT_HWCAP2,\n\t\t.hwcap = HWCAP2_SME,\n\t\t.regset = NT_ARM_SSVE,\n\t\t.prctl_set = PR_SME_SET_VL,\n\t},\n};\n\n#define VL_TESTS (((TEST_VQ_MAX - SVE_VQ_MIN) + 1) * 4)\n#define FLAG_TESTS 2\n#define FPSIMD_TESTS 2\n\n#define EXPECTED_TESTS ((VL_TESTS + FLAG_TESTS + FPSIMD_TESTS) * ARRAY_SIZE(vec_types))\n\nstatic void fill_buf(char *buf, size_t size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tbuf[i] = random();\n}\n\nstatic int do_child(void)\n{\n\tif (ptrace(PTRACE_TRACEME, -1, NULL, NULL))\n\t\tksft_exit_fail_msg(\"PTRACE_TRACEME\", strerror(errno));\n\n\tif (raise(SIGSTOP))\n\t\tksft_exit_fail_msg(\"raise(SIGSTOP)\", strerror(errno));\n\n\treturn EXIT_SUCCESS;\n}\n\nstatic int get_fpsimd(pid_t pid, struct user_fpsimd_state *fpsimd)\n{\n\tstruct iovec iov;\n\n\tiov.iov_base = fpsimd;\n\tiov.iov_len = sizeof(*fpsimd);\n\treturn ptrace(PTRACE_GETREGSET, pid, NT_PRFPREG, &iov);\n}\n\nstatic int set_fpsimd(pid_t pid, struct user_fpsimd_state *fpsimd)\n{\n\tstruct iovec iov;\n\n\tiov.iov_base = fpsimd;\n\tiov.iov_len = sizeof(*fpsimd);\n\treturn ptrace(PTRACE_SETREGSET, pid, NT_PRFPREG, &iov);\n}\n\nstatic struct user_sve_header *get_sve(pid_t pid, const struct vec_type *type,\n\t\t\t\t       void **buf, size_t *size)\n{\n\tstruct user_sve_header *sve;\n\tvoid *p;\n\tsize_t sz = sizeof *sve;\n\tstruct iovec iov;\n\n\twhile (1) {\n\t\tif (*size < sz) {\n\t\t\tp = realloc(*buf, sz);\n\t\t\tif (!p) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t*buf = p;\n\t\t\t*size = sz;\n\t\t}\n\n\t\tiov.iov_base = *buf;\n\t\tiov.iov_len = sz;\n\t\tif (ptrace(PTRACE_GETREGSET, pid, type->regset, &iov))\n\t\t\tgoto error;\n\n\t\tsve = *buf;\n\t\tif (sve->size <= sz)\n\t\t\tbreak;\n\n\t\tsz = sve->size;\n\t}\n\n\treturn sve;\n\nerror:\n\treturn NULL;\n}\n\nstatic int set_sve(pid_t pid, const struct vec_type *type,\n\t\t   const struct user_sve_header *sve)\n{\n\tstruct iovec iov;\n\n\tiov.iov_base = (void *)sve;\n\tiov.iov_len = sve->size;\n\treturn ptrace(PTRACE_SETREGSET, pid, type->regset, &iov);\n}\n\n \nstatic void ptrace_set_get_inherit(pid_t child, const struct vec_type *type)\n{\n\tstruct user_sve_header sve;\n\tstruct user_sve_header *new_sve = NULL;\n\tsize_t new_sve_size = 0;\n\tint ret;\n\n\t \n\tmemset(&sve, 0, sizeof(sve));\n\tsve.size = sizeof(sve);\n\tsve.vl = sve_vl_from_vq(SVE_VQ_MIN);\n\tsve.flags = SVE_PT_VL_INHERIT;\n\tret = set_sve(child, type, &sve);\n\tif (ret != 0) {\n\t\tksft_test_result_fail(\"Failed to set %s SVE_PT_VL_INHERIT\\n\",\n\t\t\t\t      type->name);\n\t\treturn;\n\t}\n\n\t \n\tif (!get_sve(child, type, (void **)&new_sve, &new_sve_size)) {\n\t\tksft_test_result_fail(\"Failed to read %s SVE flags\\n\",\n\t\t\t\t      type->name);\n\t\treturn;\n\t}\n\n\tksft_test_result(new_sve->flags & SVE_PT_VL_INHERIT,\n\t\t\t \"%s SVE_PT_VL_INHERIT set\\n\", type->name);\n\n\t \n\tsve.flags &= ~SVE_PT_VL_INHERIT;\n\tret = set_sve(child, type, &sve);\n\tif (ret != 0) {\n\t\tksft_test_result_fail(\"Failed to clear %s SVE_PT_VL_INHERIT\\n\",\n\t\t\t\t      type->name);\n\t\treturn;\n\t}\n\n\tif (!get_sve(child, type, (void **)&new_sve, &new_sve_size)) {\n\t\tksft_test_result_fail(\"Failed to read %s SVE flags\\n\",\n\t\t\t\t      type->name);\n\t\treturn;\n\t}\n\n\tksft_test_result(!(new_sve->flags & SVE_PT_VL_INHERIT),\n\t\t\t \"%s SVE_PT_VL_INHERIT cleared\\n\", type->name);\n\n\tfree(new_sve);\n}\n\n \nstatic void ptrace_set_get_vl(pid_t child, const struct vec_type *type,\n\t\t\t      unsigned int vl, bool *supported)\n{\n\tstruct user_sve_header sve;\n\tstruct user_sve_header *new_sve = NULL;\n\tsize_t new_sve_size = 0;\n\tint ret, prctl_vl;\n\n\t*supported = false;\n\n\t \n\tprctl_vl = prctl(type->prctl_set, vl);\n\tif (prctl_vl == -1)\n\t\tksft_exit_fail_msg(\"prctl(PR_%s_SET_VL) failed: %s (%d)\\n\",\n\t\t\t\t   type->name, strerror(errno), errno);\n\n\t \n\t*supported = (prctl_vl == vl);\n\n\t \n\tmemset(&sve, 0, sizeof(sve));\n\tsve.size = sizeof(sve);\n\tsve.vl = vl;\n\tret = set_sve(child, type, &sve);\n\tif (ret != 0) {\n\t\tksft_test_result_fail(\"Failed to set %s VL %u\\n\",\n\t\t\t\t      type->name, vl);\n\t\treturn;\n\t}\n\n\t \n\tif (!get_sve(child, type, (void **)&new_sve, &new_sve_size)) {\n\t\tksft_test_result_fail(\"Failed to read %s VL %u\\n\",\n\t\t\t\t      type->name, vl);\n\t\treturn;\n\t}\n\n\tksft_test_result(new_sve->vl = prctl_vl, \"Set %s VL %u\\n\",\n\t\t\t type->name, vl);\n\n\tfree(new_sve);\n}\n\nstatic void check_u32(unsigned int vl, const char *reg,\n\t\t      uint32_t *in, uint32_t *out, int *errors)\n{\n\tif (*in != *out) {\n\t\tprintf(\"# VL %d %s wrote %x read %x\\n\",\n\t\t       vl, reg, *in, *out);\n\t\t(*errors)++;\n\t}\n}\n\n \nstatic void ptrace_sve_fpsimd(pid_t child, const struct vec_type *type)\n{\n\tvoid *svebuf;\n\tstruct user_sve_header *sve;\n\tstruct user_fpsimd_state *fpsimd, new_fpsimd;\n\tunsigned int i, j;\n\tunsigned char *p;\n\tint ret;\n\n\tsvebuf = malloc(SVE_PT_SIZE(0, SVE_PT_REGS_FPSIMD));\n\tif (!svebuf) {\n\t\tksft_test_result_fail(\"Failed to allocate FPSIMD buffer\\n\");\n\t\treturn;\n\t}\n\n\tmemset(svebuf, 0, SVE_PT_SIZE(0, SVE_PT_REGS_FPSIMD));\n\tsve = svebuf;\n\tsve->flags = SVE_PT_REGS_FPSIMD;\n\tsve->size = SVE_PT_SIZE(0, SVE_PT_REGS_FPSIMD);\n\tsve->vl = 16;   \n\n\t \n\tfpsimd = (struct user_fpsimd_state *)((char *)sve +\n\t\t\t\t\t      SVE_PT_FPSIMD_OFFSET);\n\tfor (i = 0; i < 32; ++i) {\n\t\tp = (unsigned char *)&fpsimd->vregs[i];\n\n\t\tfor (j = 0; j < sizeof(fpsimd->vregs[i]); ++j)\n\t\t\tp[j] = j;\n\t}\n\n\tret = set_sve(child, type, sve);\n\tksft_test_result(ret == 0, \"%s FPSIMD set via SVE: %d\\n\",\n\t\t\t type->name, ret);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (get_fpsimd(child, &new_fpsimd)) {\n\t\tksft_test_result_fail(\"get_fpsimd(): %s\\n\",\n\t\t\t\t      strerror(errno));\n\t\tgoto out;\n\t}\n\tif (memcmp(fpsimd, &new_fpsimd, sizeof(*fpsimd)) == 0)\n\t\tksft_test_result_pass(\"%s get_fpsimd() gave same state\\n\",\n\t\t\t\t      type->name);\n\telse\n\t\tksft_test_result_fail(\"%s get_fpsimd() gave different state\\n\",\n\t\t\t\t      type->name);\n\nout:\n\tfree(svebuf);\n}\n\n \nstatic void ptrace_set_sve_get_sve_data(pid_t child,\n\t\t\t\t\tconst struct vec_type *type,\n\t\t\t\t\tunsigned int vl)\n{\n\tvoid *write_buf;\n\tvoid *read_buf = NULL;\n\tstruct user_sve_header *write_sve;\n\tstruct user_sve_header *read_sve;\n\tsize_t read_sve_size = 0;\n\tunsigned int vq = sve_vq_from_vl(vl);\n\tint ret, i;\n\tsize_t data_size;\n\tint errors = 0;\n\n\tdata_size = SVE_PT_SVE_OFFSET + SVE_PT_SVE_SIZE(vq, SVE_PT_REGS_SVE);\n\twrite_buf = malloc(data_size);\n\tif (!write_buf) {\n\t\tksft_test_result_fail(\"Error allocating %d byte buffer for %s VL %u\\n\",\n\t\t\t\t      data_size, type->name, vl);\n\t\treturn;\n\t}\n\twrite_sve = write_buf;\n\n\t \n\tmemset(write_sve, 0, data_size);\n\twrite_sve->size = data_size;\n\twrite_sve->vl = vl;\n\twrite_sve->flags = SVE_PT_REGS_SVE;\n\n\tfor (i = 0; i < __SVE_NUM_ZREGS; i++)\n\t\tfill_buf(write_buf + SVE_PT_SVE_ZREG_OFFSET(vq, i),\n\t\t\t SVE_PT_SVE_ZREG_SIZE(vq));\n\n\tfor (i = 0; i < __SVE_NUM_PREGS; i++)\n\t\tfill_buf(write_buf + SVE_PT_SVE_PREG_OFFSET(vq, i),\n\t\t\t SVE_PT_SVE_PREG_SIZE(vq));\n\n\tfill_buf(write_buf + SVE_PT_SVE_FPSR_OFFSET(vq), SVE_PT_SVE_FPSR_SIZE);\n\tfill_buf(write_buf + SVE_PT_SVE_FPCR_OFFSET(vq), SVE_PT_SVE_FPCR_SIZE);\n\n\t \n\n\tret = set_sve(child, type, write_sve);\n\tif (ret != 0) {\n\t\tksft_test_result_fail(\"Failed to set %s VL %u data\\n\",\n\t\t\t\t      type->name, vl);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!get_sve(child, type, (void **)&read_buf, &read_sve_size)) {\n\t\tksft_test_result_fail(\"Failed to read %s VL %u data\\n\",\n\t\t\t\t      type->name, vl);\n\t\tgoto out;\n\t}\n\tread_sve = read_buf;\n\n\t \n\tif (read_sve->size < write_sve->size) {\n\t\tksft_test_result_fail(\"%s wrote %d bytes, only read %d\\n\",\n\t\t\t\t      type->name, write_sve->size,\n\t\t\t\t      read_sve->size);\n\t\tgoto out_read;\n\t}\n\n\tfor (i = 0; i < __SVE_NUM_ZREGS; i++) {\n\t\tif (memcmp(write_buf + SVE_PT_SVE_ZREG_OFFSET(vq, i),\n\t\t\t   read_buf + SVE_PT_SVE_ZREG_OFFSET(vq, i),\n\t\t\t   SVE_PT_SVE_ZREG_SIZE(vq)) != 0) {\n\t\t\tprintf(\"# Mismatch in %u Z%d\\n\", vl, i);\n\t\t\terrors++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < __SVE_NUM_PREGS; i++) {\n\t\tif (memcmp(write_buf + SVE_PT_SVE_PREG_OFFSET(vq, i),\n\t\t\t   read_buf + SVE_PT_SVE_PREG_OFFSET(vq, i),\n\t\t\t   SVE_PT_SVE_PREG_SIZE(vq)) != 0) {\n\t\t\tprintf(\"# Mismatch in %u P%d\\n\", vl, i);\n\t\t\terrors++;\n\t\t}\n\t}\n\n\tcheck_u32(vl, \"FPSR\", write_buf + SVE_PT_SVE_FPSR_OFFSET(vq),\n\t\t  read_buf + SVE_PT_SVE_FPSR_OFFSET(vq), &errors);\n\tcheck_u32(vl, \"FPCR\", write_buf + SVE_PT_SVE_FPCR_OFFSET(vq),\n\t\t  read_buf + SVE_PT_SVE_FPCR_OFFSET(vq), &errors);\n\n\tksft_test_result(errors == 0, \"Set and get %s data for VL %u\\n\",\n\t\t\t type->name, vl);\n\nout_read:\n\tfree(read_buf);\nout:\n\tfree(write_buf);\n}\n\n \nstatic void ptrace_set_sve_get_fpsimd_data(pid_t child,\n\t\t\t\t\t   const struct vec_type *type,\n\t\t\t\t\t   unsigned int vl)\n{\n\tvoid *write_buf;\n\tstruct user_sve_header *write_sve;\n\tunsigned int vq = sve_vq_from_vl(vl);\n\tstruct user_fpsimd_state fpsimd_state;\n\tint ret, i;\n\tsize_t data_size;\n\tint errors = 0;\n\n\tif (__BYTE_ORDER == __BIG_ENDIAN) {\n\t\tksft_test_result_skip(\"Big endian not supported\\n\");\n\t\treturn;\n\t}\n\n\tdata_size = SVE_PT_SVE_OFFSET + SVE_PT_SVE_SIZE(vq, SVE_PT_REGS_SVE);\n\twrite_buf = malloc(data_size);\n\tif (!write_buf) {\n\t\tksft_test_result_fail(\"Error allocating %d byte buffer for %s VL %u\\n\",\n\t\t\t\t      data_size, type->name, vl);\n\t\treturn;\n\t}\n\twrite_sve = write_buf;\n\n\t \n\tmemset(write_sve, 0, data_size);\n\twrite_sve->size = data_size;\n\twrite_sve->vl = vl;\n\twrite_sve->flags = SVE_PT_REGS_SVE;\n\n\tfor (i = 0; i < __SVE_NUM_ZREGS; i++)\n\t\tfill_buf(write_buf + SVE_PT_SVE_ZREG_OFFSET(vq, i),\n\t\t\t SVE_PT_SVE_ZREG_SIZE(vq));\n\n\tfill_buf(write_buf + SVE_PT_SVE_FPSR_OFFSET(vq), SVE_PT_SVE_FPSR_SIZE);\n\tfill_buf(write_buf + SVE_PT_SVE_FPCR_OFFSET(vq), SVE_PT_SVE_FPCR_SIZE);\n\n\tret = set_sve(child, type, write_sve);\n\tif (ret != 0) {\n\t\tksft_test_result_fail(\"Failed to set %s VL %u data\\n\",\n\t\t\t\t      type->name, vl);\n\t\tgoto out;\n\t}\n\n\t \n\tif (get_fpsimd(child, &fpsimd_state)) {\n\t\tksft_test_result_fail(\"Failed to read %s VL %u FPSIMD data\\n\",\n\t\t\t\t      type->name, vl);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < __SVE_NUM_ZREGS; i++) {\n\t\t__uint128_t tmp = 0;\n\n\t\t \n\t\tmemcpy(&tmp, write_buf + SVE_PT_SVE_ZREG_OFFSET(vq, i),\n\t\t       sizeof(tmp));\n\n\t\tif (tmp != fpsimd_state.vregs[i]) {\n\t\t\tprintf(\"# Mismatch in FPSIMD for %s VL %u Z%d\\n\",\n\t\t\t       type->name, vl, i);\n\t\t\terrors++;\n\t\t}\n\t}\n\n\tcheck_u32(vl, \"FPSR\", write_buf + SVE_PT_SVE_FPSR_OFFSET(vq),\n\t\t  &fpsimd_state.fpsr, &errors);\n\tcheck_u32(vl, \"FPCR\", write_buf + SVE_PT_SVE_FPCR_OFFSET(vq),\n\t\t  &fpsimd_state.fpcr, &errors);\n\n\tksft_test_result(errors == 0, \"Set and get FPSIMD data for %s VL %u\\n\",\n\t\t\t type->name, vl);\n\nout:\n\tfree(write_buf);\n}\n\n \nstatic void ptrace_set_fpsimd_get_sve_data(pid_t child,\n\t\t\t\t\t   const struct vec_type *type,\n\t\t\t\t\t   unsigned int vl)\n{\n\tvoid *read_buf = NULL;\n\tunsigned char *p;\n\tstruct user_sve_header *read_sve;\n\tunsigned int vq = sve_vq_from_vl(vl);\n\tstruct user_fpsimd_state write_fpsimd;\n\tint ret, i, j;\n\tsize_t read_sve_size = 0;\n\tsize_t expected_size;\n\tint errors = 0;\n\n\tif (__BYTE_ORDER == __BIG_ENDIAN) {\n\t\tksft_test_result_skip(\"Big endian not supported\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 32; ++i) {\n\t\tp = (unsigned char *)&write_fpsimd.vregs[i];\n\n\t\tfor (j = 0; j < sizeof(write_fpsimd.vregs[i]); ++j)\n\t\t\tp[j] = j;\n\t}\n\n\tret = set_fpsimd(child, &write_fpsimd);\n\tif (ret != 0) {\n\t\tksft_test_result_fail(\"Failed to set FPSIMD state: %d\\n)\",\n\t\t\t\t      ret);\n\t\treturn;\n\t}\n\n\tif (!get_sve(child, type, (void **)&read_buf, &read_sve_size)) {\n\t\tksft_test_result_fail(\"Failed to read %s VL %u data\\n\",\n\t\t\t\t      type->name, vl);\n\t\treturn;\n\t}\n\tread_sve = read_buf;\n\n\tif (read_sve->vl != vl) {\n\t\tksft_test_result_fail(\"Child VL != expected VL %d\\n\",\n\t\t\t\t      read_sve->vl, vl);\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (read_sve->flags & SVE_PT_REGS_MASK) {\n\tcase SVE_PT_REGS_FPSIMD:\n\t\texpected_size = SVE_PT_FPSIMD_SIZE(vq, SVE_PT_REGS_FPSIMD);\n\t\tif (read_sve_size < expected_size) {\n\t\t\tksft_test_result_fail(\"Read %d bytes, expected %d\\n\",\n\t\t\t\t\t      read_sve_size, expected_size);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = memcmp(&write_fpsimd, read_buf + SVE_PT_FPSIMD_OFFSET,\n\t\t\t     sizeof(write_fpsimd));\n\t\tif (ret != 0) {\n\t\t\tksft_print_msg(\"Read FPSIMD data mismatch\\n\");\n\t\t\terrors++;\n\t\t}\n\t\tbreak;\n\n\tcase SVE_PT_REGS_SVE:\n\t\texpected_size = SVE_PT_SVE_SIZE(vq, SVE_PT_REGS_SVE);\n\t\tif (read_sve_size < expected_size) {\n\t\t\tksft_test_result_fail(\"Read %d bytes, expected %d\\n\",\n\t\t\t\t\t      read_sve_size, expected_size);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < __SVE_NUM_ZREGS; i++) {\n\t\t\t__uint128_t tmp = 0;\n\n\t\t\t \n\t\t\tmemcpy(&tmp, read_buf + SVE_PT_SVE_ZREG_OFFSET(vq, i),\n\t\t\t       sizeof(tmp));\n\n\t\t\tif (tmp != write_fpsimd.vregs[i]) {\n\t\t\t\tksft_print_msg(\"Mismatch in FPSIMD for %s VL %u Z%d/V%d\\n\",\n\t\t\t\t\t       type->name, vl, i, i);\n\t\t\t\terrors++;\n\t\t\t}\n\t\t}\n\n\t\tcheck_u32(vl, \"FPSR\", &write_fpsimd.fpsr,\n\t\t\t  read_buf + SVE_PT_SVE_FPSR_OFFSET(vq), &errors);\n\t\tcheck_u32(vl, \"FPCR\", &write_fpsimd.fpcr,\n\t\t\t  read_buf + SVE_PT_SVE_FPCR_OFFSET(vq), &errors);\n\t\tbreak;\n\tdefault:\n\t\tksft_print_msg(\"Unexpected regs type %d\\n\",\n\t\t\t       read_sve->flags & SVE_PT_REGS_MASK);\n\t\terrors++;\n\t\tbreak;\n\t}\n\n\tksft_test_result(errors == 0, \"Set FPSIMD, read via SVE for %s VL %u\\n\",\n\t\t\t type->name, vl);\n\nout:\n\tfree(read_buf);\n}\n\nstatic int do_parent(pid_t child)\n{\n\tint ret = EXIT_FAILURE;\n\tpid_t pid;\n\tint status, i;\n\tsiginfo_t si;\n\tunsigned int vq, vl;\n\tbool vl_supported;\n\n\tksft_print_msg(\"Parent is %d, child is %d\\n\", getpid(), child);\n\n\t \n\twhile (1) {\n\t\tint sig;\n\n\t\tpid = wait(&status);\n\t\tif (pid == -1) {\n\t\t\tperror(\"wait\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (pid != child)\n\t\t\tcontinue;\n\n\t\tif (WIFEXITED(status) || WIFSIGNALED(status))\n\t\t\tksft_exit_fail_msg(\"Child died unexpectedly\\n\");\n\n\t\tif (!WIFSTOPPED(status))\n\t\t\tgoto error;\n\n\t\tsig = WSTOPSIG(status);\n\n\t\tif (ptrace(PTRACE_GETSIGINFO, pid, NULL, &si)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tgoto disappeared;\n\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tsig = 0;  \n\t\t\t\tgoto cont;\n\t\t\t}\n\n\t\t\tksft_test_result_fail(\"PTRACE_GETSIGINFO: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sig == SIGSTOP && si.si_code == SI_TKILL &&\n\t\t    si.si_pid == pid)\n\t\t\tbreak;\n\n\tcont:\n\t\tif (ptrace(PTRACE_CONT, pid, NULL, sig)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tgoto disappeared;\n\n\t\t\tksft_test_result_fail(\"PTRACE_CONT: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vec_types); i++) {\n\t\t \n\t\tif (getauxval(vec_types[i].hwcap_type) & vec_types[i].hwcap) {\n\t\t\tptrace_sve_fpsimd(child, &vec_types[i]);\n\t\t} else {\n\t\t\tksft_test_result_skip(\"%s FPSIMD set via SVE\\n\",\n\t\t\t\t\t      vec_types[i].name);\n\t\t\tksft_test_result_skip(\"%s FPSIMD read\\n\",\n\t\t\t\t\t      vec_types[i].name);\n\t\t}\n\n\t\t \n\t\tif (getauxval(vec_types[i].hwcap_type) & vec_types[i].hwcap) {\n\t\t\tptrace_set_get_inherit(child, &vec_types[i]);\n\t\t} else {\n\t\t\tksft_test_result_skip(\"%s SVE_PT_VL_INHERIT set\\n\",\n\t\t\t\t\t      vec_types[i].name);\n\t\t\tksft_test_result_skip(\"%s SVE_PT_VL_INHERIT cleared\\n\",\n\t\t\t\t\t      vec_types[i].name);\n\t\t}\n\n\t\t \n\t\tfor (vq = SVE_VQ_MIN; vq <= TEST_VQ_MAX; vq++) {\n\t\t\tvl = sve_vl_from_vq(vq);\n\n\t\t\t \n\t\t\tif (getauxval(vec_types[i].hwcap_type) &\n\t\t\t    vec_types[i].hwcap) {\n\t\t\t\tptrace_set_get_vl(child, &vec_types[i], vl,\n\t\t\t\t\t\t  &vl_supported);\n\t\t\t} else {\n\t\t\t\tksft_test_result_skip(\"%s get/set VL %d\\n\",\n\t\t\t\t\t\t      vec_types[i].name, vl);\n\t\t\t\tvl_supported = false;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (vl_supported) {\n\t\t\t\tptrace_set_sve_get_sve_data(child, &vec_types[i], vl);\n\t\t\t\tptrace_set_sve_get_fpsimd_data(child, &vec_types[i], vl);\n\t\t\t\tptrace_set_fpsimd_get_sve_data(child, &vec_types[i], vl);\n\t\t\t} else {\n\t\t\t\tksft_test_result_skip(\"%s set SVE get SVE for VL %d\\n\",\n\t\t\t\t\t\t      vec_types[i].name, vl);\n\t\t\t\tksft_test_result_skip(\"%s set SVE get FPSIMD for VL %d\\n\",\n\t\t\t\t\t\t      vec_types[i].name, vl);\n\t\t\t\tksft_test_result_skip(\"%s set FPSIMD get SVE for VL %d\\n\",\n\t\t\t\t\t\t      vec_types[i].name, vl);\n\t\t\t}\n\t\t}\n\t}\n\n\tret = EXIT_SUCCESS;\n\nerror:\n\tkill(child, SIGKILL);\n\ndisappeared:\n\treturn ret;\n}\n\nint main(void)\n{\n\tint ret = EXIT_SUCCESS;\n\tpid_t child;\n\n\tsrandom(getpid());\n\n\tksft_print_header();\n\tksft_set_plan(EXPECTED_TESTS);\n\n\tif (!(getauxval(AT_HWCAP) & HWCAP_SVE))\n\t\tksft_exit_skip(\"SVE not available\\n\");\n\n\tchild = fork();\n\tif (!child)\n\t\treturn do_child();\n\n\tif (do_parent(child))\n\t\tret = EXIT_FAILURE;\n\n\tksft_print_cnts();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}