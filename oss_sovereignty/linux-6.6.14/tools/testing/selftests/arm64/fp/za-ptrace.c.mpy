{
  "module_name": "za-ptrace.c",
  "hash_id": "fbf11a46d2e1f230670285187399ececca66a38d13fe377938c96117e17899f1",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/fp/za-ptrace.c",
  "human_readable_source": "\n \n#include <errno.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n#include <asm/sigcontext.h>\n#include <asm/ptrace.h>\n\n#include \"../../kselftest.h\"\n\n \n#ifndef NT_ARM_ZA\n#define NT_ARM_ZA 0x40c\n#endif\n\n \n#define TEST_VQ_MAX 17\n\n#define EXPECTED_TESTS (((TEST_VQ_MAX - SVE_VQ_MIN) + 1) * 3)\n\nstatic void fill_buf(char *buf, size_t size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tbuf[i] = random();\n}\n\nstatic int do_child(void)\n{\n\tif (ptrace(PTRACE_TRACEME, -1, NULL, NULL))\n\t\tksft_exit_fail_msg(\"PTRACE_TRACEME\", strerror(errno));\n\n\tif (raise(SIGSTOP))\n\t\tksft_exit_fail_msg(\"raise(SIGSTOP)\", strerror(errno));\n\n\treturn EXIT_SUCCESS;\n}\n\nstatic struct user_za_header *get_za(pid_t pid, void **buf, size_t *size)\n{\n\tstruct user_za_header *za;\n\tvoid *p;\n\tsize_t sz = sizeof(*za);\n\tstruct iovec iov;\n\n\twhile (1) {\n\t\tif (*size < sz) {\n\t\t\tp = realloc(*buf, sz);\n\t\t\tif (!p) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t*buf = p;\n\t\t\t*size = sz;\n\t\t}\n\n\t\tiov.iov_base = *buf;\n\t\tiov.iov_len = sz;\n\t\tif (ptrace(PTRACE_GETREGSET, pid, NT_ARM_ZA, &iov))\n\t\t\tgoto error;\n\n\t\tza = *buf;\n\t\tif (za->size <= sz)\n\t\t\tbreak;\n\n\t\tsz = za->size;\n\t}\n\n\treturn za;\n\nerror:\n\treturn NULL;\n}\n\nstatic int set_za(pid_t pid, const struct user_za_header *za)\n{\n\tstruct iovec iov;\n\n\tiov.iov_base = (void *)za;\n\tiov.iov_len = za->size;\n\treturn ptrace(PTRACE_SETREGSET, pid, NT_ARM_ZA, &iov);\n}\n\n \nstatic void ptrace_set_get_vl(pid_t child, unsigned int vl, bool *supported)\n{\n\tstruct user_za_header za;\n\tstruct user_za_header *new_za = NULL;\n\tsize_t new_za_size = 0;\n\tint ret, prctl_vl;\n\n\t*supported = false;\n\n\t \n\tprctl_vl = prctl(PR_SME_SET_VL, vl);\n\tif (prctl_vl == -1)\n\t\tksft_exit_fail_msg(\"prctl(PR_SME_SET_VL) failed: %s (%d)\\n\",\n\t\t\t\t   strerror(errno), errno);\n\n\t \n\t*supported = (prctl_vl == vl);\n\n\t \n\tmemset(&za, 0, sizeof(za));\n\tza.size = sizeof(za);\n\tza.vl = vl;\n\tret = set_za(child, &za);\n\tif (ret != 0) {\n\t\tksft_test_result_fail(\"Failed to set VL %u\\n\", vl);\n\t\treturn;\n\t}\n\n\t \n\tif (!get_za(child, (void **)&new_za, &new_za_size)) {\n\t\tksft_test_result_fail(\"Failed to read VL %u\\n\", vl);\n\t\treturn;\n\t}\n\n\tksft_test_result(new_za->vl = prctl_vl, \"Set VL %u\\n\", vl);\n\n\tfree(new_za);\n}\n\n \nstatic void ptrace_set_no_data(pid_t child, unsigned int vl)\n{\n\tvoid *read_buf = NULL;\n\tstruct user_za_header write_za;\n\tstruct user_za_header *read_za;\n\tsize_t read_za_size = 0;\n\tint ret;\n\n\t \n\tmemset(&write_za, 0, sizeof(write_za));\n\twrite_za.size = ZA_PT_ZA_OFFSET;\n\twrite_za.vl = vl;\n\n\tret = set_za(child, &write_za);\n\tif (ret != 0) {\n\t\tksft_test_result_fail(\"Failed to set VL %u no data\\n\", vl);\n\t\treturn;\n\t}\n\n\t \n\tif (!get_za(child, (void **)&read_buf, &read_za_size)) {\n\t\tksft_test_result_fail(\"Failed to read VL %u no data\\n\", vl);\n\t\treturn;\n\t}\n\tread_za = read_buf;\n\n\t \n\tif (read_za->size < write_za.size) {\n\t\tksft_test_result_fail(\"VL %u wrote %d bytes, only read %d\\n\",\n\t\t\t\t      vl, write_za.size, read_za->size);\n\t\tgoto out_read;\n\t}\n\n\tksft_test_result(read_za->size == write_za.size,\n\t\t\t \"Disabled ZA for VL %u\\n\", vl);\n\nout_read:\n\tfree(read_buf);\n}\n\n \nstatic void ptrace_set_get_data(pid_t child, unsigned int vl)\n{\n\tvoid *write_buf;\n\tvoid *read_buf = NULL;\n\tstruct user_za_header *write_za;\n\tstruct user_za_header *read_za;\n\tsize_t read_za_size = 0;\n\tunsigned int vq = sve_vq_from_vl(vl);\n\tint ret;\n\tsize_t data_size;\n\n\tdata_size = ZA_PT_SIZE(vq);\n\twrite_buf = malloc(data_size);\n\tif (!write_buf) {\n\t\tksft_test_result_fail(\"Error allocating %d byte buffer for VL %u\\n\",\n\t\t\t\t      data_size, vl);\n\t\treturn;\n\t}\n\twrite_za = write_buf;\n\n\t \n\tmemset(write_za, 0, data_size);\n\twrite_za->size = data_size;\n\twrite_za->vl = vl;\n\n\tfill_buf(write_buf + ZA_PT_ZA_OFFSET, ZA_PT_ZA_SIZE(vq));\n\n\tret = set_za(child, write_za);\n\tif (ret != 0) {\n\t\tksft_test_result_fail(\"Failed to set VL %u data\\n\", vl);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!get_za(child, (void **)&read_buf, &read_za_size)) {\n\t\tksft_test_result_fail(\"Failed to read VL %u data\\n\", vl);\n\t\tgoto out;\n\t}\n\tread_za = read_buf;\n\n\t \n\tif (read_za->size < write_za->size) {\n\t\tksft_test_result_fail(\"VL %u wrote %d bytes, only read %d\\n\",\n\t\t\t\t      vl, write_za->size, read_za->size);\n\t\tgoto out_read;\n\t}\n\n\tksft_test_result(memcmp(write_buf + ZA_PT_ZA_OFFSET,\n\t\t\t\tread_buf + ZA_PT_ZA_OFFSET,\n\t\t\t\tZA_PT_ZA_SIZE(vq)) == 0,\n\t\t\t \"Data match for VL %u\\n\", vl);\n\nout_read:\n\tfree(read_buf);\nout:\n\tfree(write_buf);\n}\n\nstatic int do_parent(pid_t child)\n{\n\tint ret = EXIT_FAILURE;\n\tpid_t pid;\n\tint status;\n\tsiginfo_t si;\n\tunsigned int vq, vl;\n\tbool vl_supported;\n\n\t \n\twhile (1) {\n\t\tint sig;\n\n\t\tpid = wait(&status);\n\t\tif (pid == -1) {\n\t\t\tperror(\"wait\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (pid != child)\n\t\t\tcontinue;\n\n\t\tif (WIFEXITED(status) || WIFSIGNALED(status))\n\t\t\tksft_exit_fail_msg(\"Child died unexpectedly\\n\");\n\n\t\tif (!WIFSTOPPED(status))\n\t\t\tgoto error;\n\n\t\tsig = WSTOPSIG(status);\n\n\t\tif (ptrace(PTRACE_GETSIGINFO, pid, NULL, &si)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tgoto disappeared;\n\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tsig = 0;  \n\t\t\t\tgoto cont;\n\t\t\t}\n\n\t\t\tksft_test_result_fail(\"PTRACE_GETSIGINFO: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sig == SIGSTOP && si.si_code == SI_TKILL &&\n\t\t    si.si_pid == pid)\n\t\t\tbreak;\n\n\tcont:\n\t\tif (ptrace(PTRACE_CONT, pid, NULL, sig)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tgoto disappeared;\n\n\t\t\tksft_test_result_fail(\"PTRACE_CONT: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tksft_print_msg(\"Parent is %d, child is %d\\n\", getpid(), child);\n\n\t \n\tfor (vq = SVE_VQ_MIN; vq <= TEST_VQ_MAX; vq++) {\n\t\tvl = sve_vl_from_vq(vq);\n\n\t\t \n\t\tptrace_set_get_vl(child, vl, &vl_supported);\n\n\t\t \n\t\tif (vl_supported) {\n\t\t\tptrace_set_no_data(child, vl);\n\t\t\tptrace_set_get_data(child, vl);\n\t\t} else {\n\t\t\tksft_test_result_skip(\"Disabled ZA for VL %u\\n\", vl);\n\t\t\tksft_test_result_skip(\"Get and set data for VL %u\\n\",\n\t\t\t\t\t      vl);\n\t\t}\n\t}\n\n\tret = EXIT_SUCCESS;\n\nerror:\n\tkill(child, SIGKILL);\n\ndisappeared:\n\treturn ret;\n}\n\nint main(void)\n{\n\tint ret = EXIT_SUCCESS;\n\tpid_t child;\n\n\tsrandom(getpid());\n\n\tksft_print_header();\n\n\tif (!(getauxval(AT_HWCAP2) & HWCAP2_SME)) {\n\t\tksft_set_plan(1);\n\t\tksft_exit_skip(\"SME not available\\n\");\n\t}\n\n\tksft_set_plan(EXPECTED_TESTS);\n\n\tchild = fork();\n\tif (!child)\n\t\treturn do_child();\n\n\tif (do_parent(child))\n\t\tret = EXIT_FAILURE;\n\n\tksft_print_cnts();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}