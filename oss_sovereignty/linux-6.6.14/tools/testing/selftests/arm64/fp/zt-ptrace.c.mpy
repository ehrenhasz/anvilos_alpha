{
  "module_name": "zt-ptrace.c",
  "hash_id": "1ceb25b8d97e7af327d573164d8902b8d8f883629d3ada7a8c979641383cc26b",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/fp/zt-ptrace.c",
  "human_readable_source": "\n \n#include <errno.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n#include <asm/sigcontext.h>\n#include <asm/ptrace.h>\n\n#include \"../../kselftest.h\"\n\n \n#ifndef NT_ARM_ZA\n#define NT_ARM_ZA 0x40c\n#endif\n#ifndef NT_ARM_ZT\n#define NT_ARM_ZT 0x40d\n#endif\n\n#define EXPECTED_TESTS 3\n\nstatic int sme_vl;\n\nstatic void fill_buf(char *buf, size_t size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tbuf[i] = random();\n}\n\nstatic int do_child(void)\n{\n\tif (ptrace(PTRACE_TRACEME, -1, NULL, NULL))\n\t\tksft_exit_fail_msg(\"PTRACE_TRACEME\", strerror(errno));\n\n\tif (raise(SIGSTOP))\n\t\tksft_exit_fail_msg(\"raise(SIGSTOP)\", strerror(errno));\n\n\treturn EXIT_SUCCESS;\n}\n\nstatic struct user_za_header *get_za(pid_t pid, void **buf, size_t *size)\n{\n\tstruct user_za_header *za;\n\tvoid *p;\n\tsize_t sz = sizeof(*za);\n\tstruct iovec iov;\n\n\twhile (1) {\n\t\tif (*size < sz) {\n\t\t\tp = realloc(*buf, sz);\n\t\t\tif (!p) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t*buf = p;\n\t\t\t*size = sz;\n\t\t}\n\n\t\tiov.iov_base = *buf;\n\t\tiov.iov_len = sz;\n\t\tif (ptrace(PTRACE_GETREGSET, pid, NT_ARM_ZA, &iov))\n\t\t\tgoto error;\n\n\t\tza = *buf;\n\t\tif (za->size <= sz)\n\t\t\tbreak;\n\n\t\tsz = za->size;\n\t}\n\n\treturn za;\n\nerror:\n\treturn NULL;\n}\n\nstatic int set_za(pid_t pid, const struct user_za_header *za)\n{\n\tstruct iovec iov;\n\n\tiov.iov_base = (void *)za;\n\tiov.iov_len = za->size;\n\treturn ptrace(PTRACE_SETREGSET, pid, NT_ARM_ZA, &iov);\n}\n\nstatic int get_zt(pid_t pid, char zt[ZT_SIG_REG_BYTES])\n{\n\tstruct iovec iov;\n\n\tiov.iov_base = zt;\n\tiov.iov_len = ZT_SIG_REG_BYTES;\n\treturn ptrace(PTRACE_GETREGSET, pid, NT_ARM_ZT, &iov);\n}\n\n\nstatic int set_zt(pid_t pid, const char zt[ZT_SIG_REG_BYTES])\n{\n\tstruct iovec iov;\n\n\tiov.iov_base = (void *)zt;\n\tiov.iov_len = ZT_SIG_REG_BYTES;\n\treturn ptrace(PTRACE_SETREGSET, pid, NT_ARM_ZT, &iov);\n}\n\n \nstatic void ptrace_za_disabled_read_zt(pid_t child)\n{\n\tstruct user_za_header za;\n\tchar zt[ZT_SIG_REG_BYTES];\n\tint ret, i;\n\tbool fail = false;\n\n\t \n\tmemset(&za, 0, sizeof(za));\n\tza.vl = sme_vl;\n\tza.size = sizeof(za);\n\n\tret = set_za(child, &za);\n\tif (ret != 0) {\n\t\tksft_print_msg(\"Failed to disable ZA\\n\");\n\t\tfail = true;\n\t}\n\n\t \n\tret = get_zt(child, zt);\n\tif (ret != 0) {\n\t\tksft_print_msg(\"Failed to read ZT\\n\");\n\t\tfail = true;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(zt); i++) {\n\t\tif (zt[i]) {\n\t\t\tksft_print_msg(\"zt[%d]: 0x%x != 0\\n\", i, zt[i]);\n\t\t\tfail = true;\n\t\t}\n\t}\n\n\tksft_test_result(!fail, \"ptrace_za_disabled_read_zt\\n\");\n}\n\n \nstatic void ptrace_set_get_zt(pid_t child)\n{\n\tchar zt_in[ZT_SIG_REG_BYTES];\n\tchar zt_out[ZT_SIG_REG_BYTES];\n\tint ret, i;\n\tbool fail = false;\n\n\tfill_buf(zt_in, sizeof(zt_in));\n\n\tret = set_zt(child, zt_in);\n\tif (ret != 0) {\n\t\tksft_print_msg(\"Failed to set ZT\\n\");\n\t\tfail = true;\n\t}\n\n\tret = get_zt(child, zt_out);\n\tif (ret != 0) {\n\t\tksft_print_msg(\"Failed to read ZT\\n\");\n\t\tfail = true;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(zt_in); i++) {\n\t\tif (zt_in[i] != zt_out[i]) {\n\t\t\tksft_print_msg(\"zt[%d]: 0x%x != 0x%x\\n\", i, \n\t\t\t\t       zt_in[i], zt_out[i]);\n\t\t\tfail = true;\n\t\t}\n\t}\n\n\tksft_test_result(!fail, \"ptrace_set_get_zt\\n\");\n}\n\n \nstatic void ptrace_enable_za_via_zt(pid_t child)\n{\n\tstruct user_za_header za_in;\n\tstruct user_za_header *za_out;\n\tchar zt[ZT_SIG_REG_BYTES];\n\tchar *za_data;\n\tsize_t za_out_size;\n\tint ret, i, vq;\n\tbool fail = false;\n\n\t \n\tmemset(&za_in, 0, sizeof(za_in));\n\tza_in.vl = sme_vl;\n\tza_in.size = sizeof(za_in);\n\n\tret = set_za(child, &za_in);\n\tif (ret != 0) {\n\t\tksft_print_msg(\"Failed to disable ZA\\n\");\n\t\tfail = true;\n\t}\n\n\t \n\tfill_buf(zt, sizeof(zt));\n\tret = set_zt(child, zt);\n\tif (ret != 0) {\n\t\tksft_print_msg(\"Failed to set ZT\\n\");\n\t\tfail = true;\n\t}\n\n\t \n\tza_out = NULL;\n\tza_out_size = 0;\n\tif (get_za(child, (void **)&za_out, &za_out_size)) {\n\t\t \n\t\tif (za_out->vl != sme_vl) {\n\t\t\tksft_print_msg(\"VL changed from %d to %d\\n\",\n\t\t\t\t       sme_vl, za_out->vl);\n\t\t\tfail = true;\n\t\t}\n\t\tvq = __sve_vq_from_vl(za_out->vl);\n\t\tza_data = (char *)za_out + ZA_PT_ZA_OFFSET;\n\n\t\t \n\t\tif (za_out->size < ZA_PT_SIZE(vq)) {\n\t\t\tksft_print_msg(\"ZA data less than expected: %u < %u\\n\",\n\t\t\t\t       za_out->size, ZA_PT_SIZE(vq));\n\t\t\tfail = true;\n\t\t\tvq = 0;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ZA_PT_ZA_SIZE(vq); i++) {\n\t\t\tif (za_data[i]) {\n\t\t\t\tksft_print_msg(\"ZA byte %d is %x\\n\",\n\t\t\t\t\t       i, za_data[i]);\n\t\t\t\tfail = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tksft_print_msg(\"Failed to read ZA\\n\");\n\t\tfail = true;\n\t}\n\n\tksft_test_result(!fail, \"ptrace_enable_za_via_zt\\n\");\n}\n\nstatic int do_parent(pid_t child)\n{\n\tint ret = EXIT_FAILURE;\n\tpid_t pid;\n\tint status;\n\tsiginfo_t si;\n\n\t \n\twhile (1) {\n\t\tint sig;\n\n\t\tpid = wait(&status);\n\t\tif (pid == -1) {\n\t\t\tperror(\"wait\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (pid != child)\n\t\t\tcontinue;\n\n\t\tif (WIFEXITED(status) || WIFSIGNALED(status))\n\t\t\tksft_exit_fail_msg(\"Child died unexpectedly\\n\");\n\n\t\tif (!WIFSTOPPED(status))\n\t\t\tgoto error;\n\n\t\tsig = WSTOPSIG(status);\n\n\t\tif (ptrace(PTRACE_GETSIGINFO, pid, NULL, &si)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tgoto disappeared;\n\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tsig = 0;  \n\t\t\t\tgoto cont;\n\t\t\t}\n\n\t\t\tksft_test_result_fail(\"PTRACE_GETSIGINFO: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sig == SIGSTOP && si.si_code == SI_TKILL &&\n\t\t    si.si_pid == pid)\n\t\t\tbreak;\n\n\tcont:\n\t\tif (ptrace(PTRACE_CONT, pid, NULL, sig)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tgoto disappeared;\n\n\t\t\tksft_test_result_fail(\"PTRACE_CONT: %s\\n\",\n\t\t\t\t\t      strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tksft_print_msg(\"Parent is %d, child is %d\\n\", getpid(), child);\n\n\tptrace_za_disabled_read_zt(child);\n\tptrace_set_get_zt(child);\n\tptrace_enable_za_via_zt(child);\n\n\tret = EXIT_SUCCESS;\n\nerror:\n\tkill(child, SIGKILL);\n\ndisappeared:\n\treturn ret;\n}\n\nint main(void)\n{\n\tint ret = EXIT_SUCCESS;\n\tpid_t child;\n\n\tsrandom(getpid());\n\n\tksft_print_header();\n\n\tif (!(getauxval(AT_HWCAP2) & HWCAP2_SME2)) {\n\t\tksft_set_plan(1);\n\t\tksft_exit_skip(\"SME2 not available\\n\");\n\t}\n\n\t \n\tsme_vl = prctl(PR_SME_GET_VL);\n\tif (sme_vl == -1) {\n\t\tksft_set_plan(1);\n\t\tksft_exit_skip(\"Failed to read SME VL: %d (%s)\\n\",\n\t\t\t       errno, strerror(errno));\n\t}\n\n\tksft_set_plan(EXPECTED_TESTS);\n\n\tchild = fork();\n\tif (!child)\n\t\treturn do_child();\n\n\tif (do_parent(child))\n\t\tret = EXIT_FAILURE;\n\n\tksft_print_cnts();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}