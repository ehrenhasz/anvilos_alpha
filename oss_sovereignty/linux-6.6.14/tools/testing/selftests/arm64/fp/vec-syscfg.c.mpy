{
  "module_name": "vec-syscfg.c",
  "hash_id": "0ffa87ac8939508b4e9804a165ede893730c92b83eeeb00d1d15351cca18d799",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/selftests/arm64/fp/vec-syscfg.c",
  "human_readable_source": "\n \n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <asm/sigcontext.h>\n#include <asm/hwcap.h>\n\n#include \"../../kselftest.h\"\n#include \"rdvl.h\"\n\n#define ARCH_MIN_VL SVE_VL_MIN\n\nstruct vec_data {\n\tconst char *name;\n\tunsigned long hwcap_type;\n\tunsigned long hwcap;\n\tconst char *rdvl_binary;\n\tint (*rdvl)(void);\n\n\tint prctl_get;\n\tint prctl_set;\n\tconst char *default_vl_file;\n\n\tint default_vl;\n\tint min_vl;\n\tint max_vl;\n};\n\n#define VEC_SVE 0\n#define VEC_SME 1\n\nstatic struct vec_data vec_data[] = {\n\t[VEC_SVE] = {\n\t\t.name = \"SVE\",\n\t\t.hwcap_type = AT_HWCAP,\n\t\t.hwcap = HWCAP_SVE,\n\t\t.rdvl = rdvl_sve,\n\t\t.rdvl_binary = \"./rdvl-sve\",\n\t\t.prctl_get = PR_SVE_GET_VL,\n\t\t.prctl_set = PR_SVE_SET_VL,\n\t\t.default_vl_file = \"/proc/sys/abi/sve_default_vector_length\",\n\t},\n\t[VEC_SME] = {\n\t\t.name = \"SME\",\n\t\t.hwcap_type = AT_HWCAP2,\n\t\t.hwcap = HWCAP2_SME,\n\t\t.rdvl = rdvl_sme,\n\t\t.rdvl_binary = \"./rdvl-sme\",\n\t\t.prctl_get = PR_SME_GET_VL,\n\t\t.prctl_set = PR_SME_SET_VL,\n\t\t.default_vl_file = \"/proc/sys/abi/sme_default_vector_length\",\n\t},\n};\n\nstatic int stdio_read_integer(FILE *f, const char *what, int *val)\n{\n\tint n = 0;\n\tint ret;\n\n\tret = fscanf(f, \"%d%*1[\\n]%n\", val, &n);\n\tif (ret < 1 || n < 1) {\n\t\tksft_print_msg(\"failed to parse integer from %s\\n\", what);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int get_child_rdvl(struct vec_data *data)\n{\n\tFILE *out;\n\tint pipefd[2];\n\tpid_t pid, child;\n\tint read_vl, ret;\n\n\tret = pipe(pipefd);\n\tif (ret == -1) {\n\t\tksft_print_msg(\"pipe() failed: %d (%s)\\n\",\n\t\t\t       errno, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tfflush(stdout);\n\n\tchild = fork();\n\tif (child == -1) {\n\t\tksft_print_msg(\"fork() failed: %d (%s)\\n\",\n\t\t\t       errno, strerror(errno));\n\t\tclose(pipefd[0]);\n\t\tclose(pipefd[1]);\n\t\treturn -1;\n\t}\n\n\t \n\tif (child == 0) {\n\t\t \n\t\tret = dup2(pipefd[1], 1);\n\t\tif (ret == -1) {\n\t\t\tfprintf(stderr, \"dup2() %d\\n\", errno);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t \n\t\tret = execl(data->rdvl_binary, data->rdvl_binary, NULL);\n\t\tfprintf(stderr, \"execl(%s) failed: %d (%s)\\n\",\n\t\t\tdata->rdvl_binary, errno, strerror(errno));\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tclose(pipefd[1]);\n\n\t \n\tdo {\n\t\tpid = wait(&ret);\n\t\tif (pid == -1) {\n\t\t\tksft_print_msg(\"wait() failed: %d (%s)\\n\",\n\t\t\t\t       errno, strerror(errno));\n\t\t\tclose(pipefd[0]);\n\t\t\treturn -1;\n\t\t}\n\t} while (pid != child);\n\n\tassert(pid == child);\n\n\tif (!WIFEXITED(ret)) {\n\t\tksft_print_msg(\"child exited abnormally\\n\");\n\t\tclose(pipefd[0]);\n\t\treturn -1;\n\t}\n\n\tif (WEXITSTATUS(ret) != 0) {\n\t\tksft_print_msg(\"child returned error %d\\n\",\n\t\t\t       WEXITSTATUS(ret));\n\t\tclose(pipefd[0]);\n\t\treturn -1;\n\t}\n\n\tout = fdopen(pipefd[0], \"r\");\n\tif (!out) {\n\t\tksft_print_msg(\"failed to open child stdout\\n\");\n\t\tclose(pipefd[0]);\n\t\treturn -1;\n\t}\n\n\tret = stdio_read_integer(out, \"child\", &read_vl);\n\tfclose(out);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn read_vl;\n}\n\nstatic int file_read_integer(const char *name, int *val)\n{\n\tFILE *f;\n\tint ret;\n\n\tf = fopen(name, \"r\");\n\tif (!f) {\n\t\tksft_test_result_fail(\"Unable to open %s: %d (%s)\\n\",\n\t\t\t\t      name, errno,\n\t\t\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tret = stdio_read_integer(f, name, val);\n\tfclose(f);\n\n\treturn ret;\n}\n\nstatic int file_write_integer(const char *name, int val)\n{\n\tFILE *f;\n\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\tksft_test_result_fail(\"Unable to open %s: %d (%s)\\n\",\n\t\t\t\t      name, errno,\n\t\t\t\t      strerror(errno));\n\t\treturn -1;\n\t}\n\n\tfprintf(f, \"%d\", val);\n\tfclose(f);\n\n\treturn 0;\n}\n\n \nstatic void proc_read_default(struct vec_data *data)\n{\n\tint default_vl, child_vl, ret;\n\n\tret = file_read_integer(data->default_vl_file, &default_vl);\n\tif (ret != 0)\n\t\treturn;\n\n\t \n\tchild_vl = get_child_rdvl(data);\n\tif (child_vl != default_vl) {\n\t\tksft_test_result_fail(\"%s is %d but child VL is %d\\n\",\n\t\t\t\t      data->default_vl_file,\n\t\t\t\t      default_vl, child_vl);\n\t\treturn;\n\t}\n\n\tksft_test_result_pass(\"%s default vector length %d\\n\", data->name,\n\t\t\t      default_vl);\n\tdata->default_vl = default_vl;\n}\n\n \nstatic void proc_write_min(struct vec_data *data)\n{\n\tint ret, new_default, child_vl;\n\n\tif (geteuid() != 0) {\n\t\tksft_test_result_skip(\"Need to be root to write to /proc\\n\");\n\t\treturn;\n\t}\n\n\tret = file_write_integer(data->default_vl_file, ARCH_MIN_VL);\n\tif (ret != 0)\n\t\treturn;\n\n\t \n\tret = file_read_integer(data->default_vl_file, &new_default);\n\tif (ret != 0)\n\t\treturn;\n\n\t \n\tchild_vl = get_child_rdvl(data);\n\tif (child_vl != new_default) {\n\t\tksft_test_result_fail(\"%s is %d but child VL is %d\\n\",\n\t\t\t\t      data->default_vl_file,\n\t\t\t\t      new_default, child_vl);\n\t\treturn;\n\t}\n\n\tksft_test_result_pass(\"%s minimum vector length %d\\n\", data->name,\n\t\t\t      new_default);\n\tdata->min_vl = new_default;\n\n\tfile_write_integer(data->default_vl_file, data->default_vl);\n}\n\n \nstatic void proc_write_max(struct vec_data *data)\n{\n\tint ret, new_default, child_vl;\n\n\tif (geteuid() != 0) {\n\t\tksft_test_result_skip(\"Need to be root to write to /proc\\n\");\n\t\treturn;\n\t}\n\n\t \n\tret = file_write_integer(data->default_vl_file, -1);\n\tif (ret != 0)\n\t\treturn;\n\n\t \n\tret = file_read_integer(data->default_vl_file, &new_default);\n\tif (ret != 0)\n\t\treturn;\n\n\t \n\tchild_vl = get_child_rdvl(data);\n\tif (child_vl != new_default) {\n\t\tksft_test_result_fail(\"%s is %d but child VL is %d\\n\",\n\t\t\t\t      data->default_vl_file,\n\t\t\t\t      new_default, child_vl);\n\t\treturn;\n\t}\n\n\tksft_test_result_pass(\"%s maximum vector length %d\\n\", data->name,\n\t\t\t      new_default);\n\tdata->max_vl = new_default;\n\n\tfile_write_integer(data->default_vl_file, data->default_vl);\n}\n\n \nstatic void prctl_get(struct vec_data *data)\n{\n\tint ret;\n\n\tret = prctl(data->prctl_get);\n\tif (ret == -1) {\n\t\tksft_test_result_fail(\"%s prctl() read failed: %d (%s)\\n\",\n\t\t\t\t      data->name, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\t \n\tret &= PR_SVE_VL_LEN_MASK;\n\n\t \n\tif (ret == data->rdvl())\n\t\tksft_test_result_pass(\"%s current VL is %d\\n\",\n\t\t\t\t      data->name, ret);\n\telse\n\t\tksft_test_result_fail(\"%s prctl() VL %d but RDVL is %d\\n\",\n\t\t\t\t      data->name, ret, data->rdvl());\n}\n\n \nstatic void prctl_set_same(struct vec_data *data)\n{\n\tint cur_vl = data->rdvl();\n\tint ret;\n\n\tret = prctl(data->prctl_set, cur_vl);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"%s prctl set failed: %d (%s)\\n\",\n\t\t\t\t      data->name, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tksft_test_result(cur_vl == data->rdvl(),\n\t\t\t \"%s set VL %d and have VL %d\\n\",\n\t\t\t data->name, cur_vl, data->rdvl());\n}\n\n \nstatic void prctl_set(struct vec_data *data)\n{\n\tint ret;\n\n\tif (data->min_vl == data->max_vl) {\n\t\tksft_test_result_skip(\"%s only one VL supported\\n\",\n\t\t\t\t      data->name);\n\t\treturn;\n\t}\n\n\t \n\tret = prctl(data->prctl_set, data->min_vl);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"%s prctl set failed for %d: %d (%s)\\n\",\n\t\t\t\t      data->name, data->min_vl,\n\t\t\t\t      errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tif ((ret & PR_SVE_VL_LEN_MASK) != data->min_vl) {\n\t\tksft_test_result_fail(\"%s prctl set %d but return value is %d\\n\",\n\t\t\t\t      data->name, data->min_vl, data->rdvl());\n\t\treturn;\n\t}\n\n\tif (data->rdvl() != data->min_vl) {\n\t\tksft_test_result_fail(\"%s set %d but RDVL is %d\\n\",\n\t\t\t\t      data->name, data->min_vl, data->rdvl());\n\t\treturn;\n\t}\n\n\t \n\tret = prctl(data->prctl_set, data->max_vl);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"%s prctl set failed for %d: %d (%s)\\n\",\n\t\t\t\t      data->name, data->max_vl,\n\t\t\t\t      errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tif ((ret & PR_SVE_VL_LEN_MASK) != data->max_vl) {\n\t\tksft_test_result_fail(\"%s prctl() set %d but return value is %d\\n\",\n\t\t\t\t      data->name, data->max_vl, data->rdvl());\n\t\treturn;\n\t}\n\n\t \n\tret = prctl(data->prctl_get);\n\tif (ret == -1) {\n\t\tksft_test_result_fail(\"%s prctl() read failed: %d (%s)\\n\",\n\t\t\t\t      data->name, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tif (ret & PR_SVE_VL_INHERIT) {\n\t\tksft_test_result_fail(\"%s prctl() reports _INHERIT\\n\",\n\t\t\t\t      data->name);\n\t\treturn;\n\t}\n\n\tksft_test_result_pass(\"%s prctl() set min/max\\n\", data->name);\n}\n\n \nstatic void prctl_set_no_child(struct vec_data *data)\n{\n\tint ret, child_vl;\n\n\tif (data->min_vl == data->max_vl) {\n\t\tksft_test_result_skip(\"%s only one VL supported\\n\",\n\t\t\t\t      data->name);\n\t\treturn;\n\t}\n\n\tret = prctl(data->prctl_set, data->min_vl);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"%s prctl set failed for %d: %d (%s)\\n\",\n\t\t\t\t      data->name, data->min_vl,\n\t\t\t\t      errno, strerror(errno));\n\t\treturn;\n\t}\n\n\t \n\tret = file_write_integer(data->default_vl_file, data->max_vl);\n\tif (ret != 0)\n\t\treturn;\n\n\t \n\tchild_vl = get_child_rdvl(data);\n\tif (child_vl != data->max_vl) {\n\t\tksft_test_result_fail(\"%s is %d but child VL is %d\\n\",\n\t\t\t\t      data->default_vl_file,\n\t\t\t\t      data->max_vl, child_vl);\n\t\treturn;\n\t}\n\n\tksft_test_result_pass(\"%s vector length used default\\n\", data->name);\n\n\tfile_write_integer(data->default_vl_file, data->default_vl);\n}\n\n \nstatic void prctl_set_for_child(struct vec_data *data)\n{\n\tint ret, child_vl;\n\n\tif (data->min_vl == data->max_vl) {\n\t\tksft_test_result_skip(\"%s only one VL supported\\n\",\n\t\t\t\t      data->name);\n\t\treturn;\n\t}\n\n\tret = prctl(data->prctl_set, data->min_vl | PR_SVE_VL_INHERIT);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"%s prctl set failed for %d: %d (%s)\\n\",\n\t\t\t\t      data->name, data->min_vl,\n\t\t\t\t      errno, strerror(errno));\n\t\treturn;\n\t}\n\n\t \n\tret = prctl(data->prctl_get);\n\tif (ret == -1) {\n\t\tksft_test_result_fail(\"%s prctl() read failed: %d (%s)\\n\",\n\t\t\t\t      data->name, errno, strerror(errno));\n\t\treturn;\n\t}\n\tif (!(ret & PR_SVE_VL_INHERIT)) {\n\t\tksft_test_result_fail(\"%s prctl() does not report _INHERIT\\n\",\n\t\t\t\t      data->name);\n\t\treturn;\n\t}\n\n\t \n\tret = file_write_integer(data->default_vl_file, data->max_vl);\n\tif (ret != 0)\n\t\treturn;\n\n\t \n\tchild_vl = get_child_rdvl(data);\n\tif (child_vl != data->min_vl) {\n\t\tksft_test_result_fail(\"%s is %d but child VL is %d\\n\",\n\t\t\t\t      data->default_vl_file,\n\t\t\t\t      data->min_vl, child_vl);\n\t\treturn;\n\t}\n\n\tksft_test_result_pass(\"%s vector length was inherited\\n\", data->name);\n\n\tfile_write_integer(data->default_vl_file, data->default_vl);\n}\n\n \nstatic void prctl_set_onexec(struct vec_data *data)\n{\n\tint ret, child_vl;\n\n\tif (data->min_vl == data->max_vl) {\n\t\tksft_test_result_skip(\"%s only one VL supported\\n\",\n\t\t\t\t      data->name);\n\t\treturn;\n\t}\n\n\t \n\tret = file_write_integer(data->default_vl_file, data->max_vl);\n\tif (ret != 0)\n\t\treturn;\n\n\tret = prctl(data->prctl_set, data->max_vl);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"%s prctl set failed for %d: %d (%s)\\n\",\n\t\t\t\t      data->name, data->min_vl,\n\t\t\t\t      errno, strerror(errno));\n\t\treturn;\n\t}\n\n\t \n\tret = prctl(data->prctl_set, data->min_vl | PR_SVE_SET_VL_ONEXEC);\n\tif (ret < 0) {\n\t\tksft_test_result_fail(\"%s prctl set failed for %d: %d (%s)\\n\",\n\t\t\t\t      data->name, data->min_vl,\n\t\t\t\t      errno, strerror(errno));\n\t\treturn;\n\t}\n\n\t \n\tif (data->rdvl() != data->max_vl) {\n\t\tksft_test_result_fail(\"%s VL changed by _ONEXEC prctl()\\n\",\n\t\t\t\t      data->name);\n\t\treturn;\n\t}\n\n\t \n\tchild_vl = get_child_rdvl(data);\n\tif (child_vl != data->min_vl) {\n\t\tksft_test_result_fail(\"Set %d _ONEXEC but child VL is %d\\n\",\n\t\t\t\t      data->min_vl, child_vl);\n\t\treturn;\n\t}\n\n\tksft_test_result_pass(\"%s vector length set on exec\\n\", data->name);\n\n\tfile_write_integer(data->default_vl_file, data->default_vl);\n}\n\n \nstatic void prctl_set_all_vqs(struct vec_data *data)\n{\n\tint ret, vq, vl, new_vl, i;\n\tint orig_vls[ARRAY_SIZE(vec_data)];\n\tint errors = 0;\n\n\tif (!data->min_vl || !data->max_vl) {\n\t\tksft_test_result_skip(\"%s Failed to enumerate VLs, not testing VL setting\\n\",\n\t\t\t\t      data->name);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vec_data); i++)\n\t\torig_vls[i] = vec_data[i].rdvl();\n\n\tfor (vq = SVE_VQ_MIN; vq <= SVE_VQ_MAX; vq++) {\n\t\tvl = sve_vl_from_vq(vq);\n\n\t\t \n\t\tret = prctl(data->prctl_set, vl);\n\t\tif (ret < 0) {\n\t\t\terrors++;\n\t\t\tksft_print_msg(\"%s prctl set failed for %d: %d (%s)\\n\",\n\t\t\t\t       data->name, vl,\n\t\t\t\t       errno, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tnew_vl = ret & PR_SVE_VL_LEN_MASK;\n\n\t\t \n\t\tif (data->rdvl() != new_vl) {\n\t\t\tksft_print_msg(\"Set %s VL %d but RDVL reports %d\\n\",\n\t\t\t\t       data->name, new_vl, data->rdvl());\n\t\t\terrors++;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(vec_data); i++) {\n\t\t\tif (&vec_data[i] == data)\n\t\t\t\tcontinue;\n\n\t\t\tif (!(getauxval(vec_data[i].hwcap_type) & vec_data[i].hwcap))\n\t\t\t\tcontinue;\n\n\t\t\tif (vec_data[i].rdvl() != orig_vls[i]) {\n\t\t\t\tksft_print_msg(\"%s VL changed from %d to %d\\n\",\n\t\t\t\t\t       vec_data[i].name, orig_vls[i],\n\t\t\t\t\t       vec_data[i].rdvl());\n\t\t\t\terrors++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (new_vl == vl)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (vl < data->min_vl) {\n\t\t\tif (new_vl != data->min_vl) {\n\t\t\t\tksft_print_msg(\"%s VL %d returned %d not minimum %d\\n\",\n\t\t\t\t\t       data->name, vl, new_vl,\n\t\t\t\t\t       data->min_vl);\n\t\t\t\terrors++;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (vl > data->max_vl) {\n\t\t\tif (new_vl != data->max_vl) {\n\t\t\t\tksft_print_msg(\"%s VL %d returned %d not maximum %d\\n\",\n\t\t\t\t\t       data->name, vl, new_vl,\n\t\t\t\t\t       data->max_vl);\n\t\t\t\terrors++;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(new_vl < vl)) {\n\t\t\tksft_print_msg(\"%s VL %d returned %d, did not round down\\n\",\n\t\t\t\t       data->name, vl, new_vl);\n\t\t\terrors++;\n\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tksft_test_result(errors == 0, \"%s prctl() set all VLs, %d errors\\n\",\n\t\t\t data->name, errors);\n}\n\ntypedef void (*test_type)(struct vec_data *);\n\nstatic const test_type tests[] = {\n\t \n\tproc_read_default,\n\tproc_write_min,\n\tproc_write_max,\n\n\tprctl_get,\n\tprctl_set_same,\n\tprctl_set,\n\tprctl_set_no_child,\n\tprctl_set_for_child,\n\tprctl_set_onexec,\n\tprctl_set_all_vqs,\n};\n\nstatic inline void smstart(void)\n{\n\tasm volatile(\"msr S0_3_C4_C7_3, xzr\");\n}\n\nstatic inline void smstart_sm(void)\n{\n\tasm volatile(\"msr S0_3_C4_C3_3, xzr\");\n}\n\nstatic inline void smstop(void)\n{\n\tasm volatile(\"msr S0_3_C4_C6_3, xzr\");\n}\n\n\n \nstatic void change_sve_with_za(void)\n{\n\tstruct vec_data *sve_data = &vec_data[VEC_SVE];\n\tbool pass = true;\n\tint ret, i;\n\n\tif (sve_data->min_vl == sve_data->max_vl) {\n\t\tksft_print_msg(\"Only one SVE VL supported, can't change\\n\");\n\t\tksft_test_result_skip(\"change_sve_while_sme\\n\");\n\t\treturn;\n\t}\n\n\t \n\tret = prctl(sve_data->prctl_set, sve_data->min_vl);\n\tif (ret != sve_data->min_vl) {\n\t\tksft_print_msg(\"Failed to set SVE VL %d: %d\\n\",\n\t\t\t       sve_data->min_vl, ret);\n\t\tpass = false;\n\t}\n\n\t \n\tsmstart();\n\n\t \n\tret = prctl(sve_data->prctl_set, sve_data->max_vl);\n\tif (ret != sve_data->max_vl) {\n\t\tksft_print_msg(\"Failed to set SVE VL %d: %d\\n\",\n\t\t\t       sve_data->max_vl, ret);\n\t\tpass = false;\n\t}\n\n\t \n\tfor (i = 0; i < 100000000; i++)\n\t\tsmstart_sm();\n\n\t \n\n\t \n\tsmstop();\n\tret = prctl(sve_data->prctl_set, sve_data->default_vl);\n\tif (ret != sve_data->default_vl) {\n\t        ksft_print_msg(\"Failed to restore SVE VL %d: %d\\n\",\n\t\t\t       sve_data->default_vl, ret);\n\t\tpass = false;\n\t}\n\n\tksft_test_result(pass, \"change_sve_with_za\\n\");\n}\n\ntypedef void (*test_all_type)(void);\n\nstatic const struct {\n\tconst char *name;\n\ttest_all_type test;\n}  all_types_tests[] = {\n\t{ \"change_sve_with_za\", change_sve_with_za },\n};\n\nint main(void)\n{\n\tbool all_supported = true;\n\tint i, j;\n\n\tksft_print_header();\n\tksft_set_plan(ARRAY_SIZE(tests) * ARRAY_SIZE(vec_data) +\n\t\t      ARRAY_SIZE(all_types_tests));\n\n\tfor (i = 0; i < ARRAY_SIZE(vec_data); i++) {\n\t\tstruct vec_data *data = &vec_data[i];\n\t\tunsigned long supported;\n\n\t\tsupported = getauxval(data->hwcap_type) & data->hwcap;\n\t\tif (!supported)\n\t\t\tall_supported = false;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(tests); j++) {\n\t\t\tif (supported)\n\t\t\t\ttests[j](data);\n\t\t\telse\n\t\t\t\tksft_test_result_skip(\"%s not supported\\n\",\n\t\t\t\t\t\t      data->name);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(all_types_tests); i++) {\n\t\tif (all_supported)\n\t\t\tall_types_tests[i].test();\n\t\telse\n\t\t\tksft_test_result_skip(\"%s\\n\", all_types_tests[i].name);\n\t}\n\n\tksft_exit_pass();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}