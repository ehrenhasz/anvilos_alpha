{
  "module_name": "test-cipher.c",
  "hash_id": "12229736b15cf8c29e95756e1021fc2493e7bfbbf1f69ef29ab26616bd10d8fb",
  "original_prompt": "Ingested from linux-6.6.14/tools/testing/crypto/chacha20-s390/test-cipher.c",
  "human_readable_source": " \n\n#include <asm/elf.h>\n#include <asm/uaccess.h>\n#include <asm/smp.h>\n#include <crypto/skcipher.h>\n#include <crypto/akcipher.h>\n#include <crypto/acompress.h>\n#include <crypto/rng.h>\n#include <crypto/drbg.h>\n#include <crypto/kpp.h>\n#include <crypto/internal/simd.h>\n#include <crypto/chacha.h>\n#include <crypto/aead.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/fips.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/scatterlist.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/zlib.h>\n#include <linux/once.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic unsigned int data_size __read_mostly = 256;\nstatic unsigned int debug __read_mostly = 0;\n\n \nstruct skcipher_def {\n\tstruct scatterlist sginp, sgout;\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tstruct crypto_wait wait;\n};\n\n \nstatic int test_lib_chacha(u8 *revert, u8 *cipher, u8 *plain)\n{\n\tu32 chacha_state[CHACHA_STATE_WORDS];\n\tu8 iv[16], key[32];\n\tu64 start, end;\n\n\tmemset(key, 'X', sizeof(key));\n\tmemset(iv, 'I', sizeof(iv));\n\n\tif (debug) {\n\t\tprint_hex_dump(KERN_INFO, \"key: \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, key, 32, 1);\n\n\t\tprint_hex_dump(KERN_INFO, \"iv:  \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, iv, 16, 1);\n\t}\n\n\t \n\tchacha_init_arch(chacha_state, (u32*)key, iv);\n\n\tstart = ktime_get_ns();\n\tchacha_crypt_arch(chacha_state, cipher, plain, data_size, 20);\n\tend = ktime_get_ns();\n\n\n\tif (debug)\n\t\tprint_hex_dump(KERN_INFO, \"encr:\", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, cipher,\n\t\t\t       (data_size > 64 ? 64 : data_size), 1);\n\n\tpr_info(\"lib encryption took: %lld nsec\", end - start);\n\n\t \n\tchacha_init_arch(chacha_state, (u32 *)key, iv);\n\n\tstart = ktime_get_ns();\n\tchacha_crypt_arch(chacha_state, revert, cipher, data_size, 20);\n\tend = ktime_get_ns();\n\n\tif (debug)\n\t\tprint_hex_dump(KERN_INFO, \"decr:\", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, revert,\n\t\t\t       (data_size > 64 ? 64 : data_size), 1);\n\n\tpr_info(\"lib decryption took: %lld nsec\", end - start);\n\n\treturn 0;\n}\n\n \nstatic unsigned int test_skcipher_encdec(struct skcipher_def *sk,\n\t\t\t\t\t int enc)\n{\n\tint rc;\n\n\tif (enc) {\n\t\trc = crypto_wait_req(crypto_skcipher_encrypt(sk->req),\n\t\t\t\t     &sk->wait);\n\t\tif (rc)\n\t\t\tpr_info(\"skcipher encrypt returned with result\"\n\t\t\t\t\"%d\\n\", rc);\n\t}\n\telse\n\t{\n\t\trc = crypto_wait_req(crypto_skcipher_decrypt(sk->req),\n\t\t\t\t     &sk->wait);\n\t\tif (rc)\n\t\t\tpr_info(\"skcipher decrypt returned with result\"\n\t\t\t\t\"%d\\n\", rc);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int test_skcipher(char *name, u8 *revert, u8 *cipher, u8 *plain)\n{\n\tstruct skcipher_def sk;\n\tstruct crypto_skcipher *skcipher = NULL;\n\tstruct skcipher_request *req = NULL;\n\tu8 iv[16], key[32];\n\tu64 start, end;\n\tint ret = -EFAULT;\n\n\tskcipher = crypto_alloc_skcipher(name, 0, 0);\n\tif (IS_ERR(skcipher)) {\n\t\tpr_info(\"could not allocate skcipher %s handle\\n\", name);\n\t\treturn PTR_ERR(skcipher);\n\t}\n\n\treq = skcipher_request_alloc(skcipher, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_info(\"could not allocate skcipher request\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\t  crypto_req_done,\n\t\t\t\t\t  &sk.wait);\n\n\tmemset(key, 'X', sizeof(key));\n\tmemset(iv, 'I', sizeof(iv));\n\n\tif (crypto_skcipher_setkey(skcipher, key, 32)) {\n\t\tpr_info(\"key could not be set\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (debug) {\n\t\tprint_hex_dump(KERN_INFO, \"key: \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, key, 32, 1);\n\n\t\tprint_hex_dump(KERN_INFO, \"iv:  \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, iv, 16, 1);\n\t}\n\n\tsk.tfm = skcipher;\n\tsk.req = req;\n\n\t \n\tsg_init_one(&sk.sginp, plain, data_size);\n\tsg_init_one(&sk.sgout, cipher, data_size);\n\tskcipher_request_set_crypt(req, &sk.sginp, &sk.sgout,\n\t\t\t\t   data_size, iv);\n\tcrypto_init_wait(&sk.wait);\n\n\t \n\tstart = ktime_get_ns();\n\tret = test_skcipher_encdec(&sk, 1);\n\tend = ktime_get_ns();\n\n\tif (ret)\n\t\tgoto out;\n\n\tpr_info(\"%s tfm encryption successful, took %lld nsec\\n\", name, end - start);\n\n\tif (debug)\n\t\tprint_hex_dump(KERN_INFO, \"encr:\", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, cipher,\n\t\t\t       (data_size > 64 ? 64 : data_size), 1);\n\n\t \n\tmemset(iv, 'I', sizeof(iv));\n\n\tsg_init_one(&sk.sginp, cipher, data_size);\n\tsg_init_one(&sk.sgout, revert, data_size);\n\tskcipher_request_set_crypt(req, &sk.sginp, &sk.sgout,\n\t\t\t\t   data_size, iv);\n\tcrypto_init_wait(&sk.wait);\n\n\t \n\tstart = ktime_get_ns();\n\tret = test_skcipher_encdec(&sk, 0);\n\tend = ktime_get_ns();\n\n\tif (ret)\n\t\tgoto out;\n\n\tpr_info(\"%s tfm decryption successful, took %lld nsec\\n\", name, end - start);\n\n\tif (debug)\n\t\tprint_hex_dump(KERN_INFO, \"decr:\", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, revert,\n\t\t\t       (data_size > 64 ? 64 : data_size), 1);\n\n\t \n\tif (debug)\n\t\tpr_info(\"skcipher %s: cryptlen %d blksize %d stride %d \"\n\t\t\t\"ivsize %d alignmask 0x%x\\n\",\n\t\t\tname, sk.req->cryptlen,\n\t\t\tcrypto_skcipher_blocksize(sk.tfm),\n\t\t\tcrypto_skcipher_alg(sk.tfm)->walksize,\n\t\t\tcrypto_skcipher_ivsize(sk.tfm),\n\t\t\tcrypto_skcipher_alignmask(sk.tfm));\n\nout:\n\tif (skcipher)\n\t\tcrypto_free_skcipher(skcipher);\n\tif (req)\n\t\tskcipher_request_free(req);\n\treturn ret;\n}\n\nstatic int __init chacha_s390_test_init(void)\n{\n\tu8 *plain = NULL, *revert = NULL;\n\tu8 *cipher_generic = NULL, *cipher_s390 = NULL;\n\tint ret = -1;\n\n\tpr_info(\"s390 ChaCha20 test module: size=%d debug=%d\\n\",\n\t\tdata_size, debug);\n\n\t \n\tplain = vmalloc(data_size);\n\tif (!plain) {\n\t\tpr_info(\"could not allocate plain buffer\\n\");\n\t\tret = -2;\n\t\tgoto out;\n\t}\n\tmemset(plain, 'a', data_size);\n\tget_random_bytes(plain, (data_size > 256 ? 256 : data_size));\n\n\tcipher_generic = vzalloc(data_size);\n\tif (!cipher_generic) {\n\t\tpr_info(\"could not allocate cipher_generic buffer\\n\");\n\t\tret = -2;\n\t\tgoto out;\n\t}\n\n\tcipher_s390 = vzalloc(data_size);\n\tif (!cipher_s390) {\n\t\tpr_info(\"could not allocate cipher_s390 buffer\\n\");\n\t\tret = -2;\n\t\tgoto out;\n\t}\n\n\trevert = vzalloc(data_size);\n\tif (!revert) {\n\t\tpr_info(\"could not allocate revert buffer\\n\");\n\t\tret = -2;\n\t\tgoto out;\n\t}\n\n\tif (debug)\n\t\tprint_hex_dump(KERN_INFO, \"src: \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, plain,\n\t\t\t       (data_size > 64 ? 64 : data_size), 1);\n\n\t \n\tret = test_skcipher(\"chacha20-generic\", revert, cipher_generic, plain);\n\tif (ret)\n\t\tgoto out;\n\n\tif (memcmp(plain, revert, data_size)) {\n\t\tpr_info(\"generic en/decryption check FAILED\\n\");\n\t\tret = -2;\n\t\tgoto out;\n\t}\n\telse\n\t\tpr_info(\"generic en/decryption check OK\\n\");\n\n\tmemset(revert, 0, data_size);\n\n\t \n\tret = test_skcipher(\"chacha20-s390\", revert, cipher_s390, plain);\n\tif (ret)\n\t\tgoto out;\n\n\tif (memcmp(plain, revert, data_size)) {\n\t\tpr_info(\"s390 en/decryption check FAILED\\n\");\n\t\tret = -2;\n\t\tgoto out;\n\t}\n\telse\n\t\tpr_info(\"s390 en/decryption check OK\\n\");\n\n\tif (memcmp(cipher_generic, cipher_s390, data_size)) {\n\t\tpr_info(\"s390 vs generic check FAILED\\n\");\n\t\tret = -2;\n\t\tgoto out;\n\t}\n\telse\n\t\tpr_info(\"s390 vs generic check OK\\n\");\n\n\tmemset(cipher_s390, 0, data_size);\n\tmemset(revert, 0, data_size);\n\n\t \n\ttest_lib_chacha(revert, cipher_s390, plain);\n\n\tif (memcmp(plain, revert, data_size)) {\n\t\tpr_info(\"lib en/decryption check FAILED\\n\");\n\t\tret = -2;\n\t\tgoto out;\n\t}\n\telse\n\t\tpr_info(\"lib en/decryption check OK\\n\");\n\n\tif (memcmp(cipher_generic, cipher_s390, data_size)) {\n\t\tpr_info(\"lib vs generic check FAILED\\n\");\n\t\tret = -2;\n\t\tgoto out;\n\t}\n\telse\n\t\tpr_info(\"lib vs generic check OK\\n\");\n\n\tpr_info(\"--- chacha20 s390 test end ---\\n\");\n\nout:\n\tif (plain)\n\t\tvfree(plain);\n\tif (cipher_generic)\n\t\tvfree(cipher_generic);\n\tif (cipher_s390)\n\t\tvfree(cipher_s390);\n\tif (revert)\n\t\tvfree(revert);\n\n\treturn -1;\n}\n\nstatic void __exit chacha_s390_test_exit(void)\n{\n\tpr_info(\"s390 ChaCha20 test module exit\\n\");\n}\n\nmodule_param_named(size, data_size, uint, 0660);\nmodule_param(debug, int, 0660);\nMODULE_PARM_DESC(size, \"Size of a plaintext\");\nMODULE_PARM_DESC(debug, \"Debug level (0=off,1=on)\");\n\nmodule_init(chacha_s390_test_init);\nmodule_exit(chacha_s390_test_exit);\n\nMODULE_DESCRIPTION(\"s390 ChaCha20 self-test\");\nMODULE_AUTHOR(\"Vladis Dronov <vdronoff@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}