{
  "module_name": "orc_gen.c",
  "hash_id": "f345ed203d017041ca1c8072f61cf410bda8bc9213dd4d4d88a36ce8d7ca1a86",
  "original_prompt": "Ingested from linux-6.6.14/tools/objtool/orc_gen.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <string.h>\n\n#include <linux/objtool_types.h>\n#include <asm/orc_types.h>\n\n#include <objtool/check.h>\n#include <objtool/warn.h>\n#include <objtool/endianness.h>\n\nstatic int init_orc_entry(struct orc_entry *orc, struct cfi_state *cfi,\n\t\t\t  struct instruction *insn)\n{\n\tstruct cfi_reg *bp = &cfi->regs[CFI_BP];\n\n\tmemset(orc, 0, sizeof(*orc));\n\n\tif (!cfi) {\n\t\t \n\t\torc->type = ORC_TYPE_UNDEFINED;\n\t\treturn 0;\n\t}\n\n\tswitch (cfi->type) {\n\tcase UNWIND_HINT_TYPE_UNDEFINED:\n\t\torc->type = ORC_TYPE_UNDEFINED;\n\t\treturn 0;\n\tcase UNWIND_HINT_TYPE_END_OF_STACK:\n\t\torc->type = ORC_TYPE_END_OF_STACK;\n\t\treturn 0;\n\tcase UNWIND_HINT_TYPE_CALL:\n\t\torc->type = ORC_TYPE_CALL;\n\t\tbreak;\n\tcase UNWIND_HINT_TYPE_REGS:\n\t\torc->type = ORC_TYPE_REGS;\n\t\tbreak;\n\tcase UNWIND_HINT_TYPE_REGS_PARTIAL:\n\t\torc->type = ORC_TYPE_REGS_PARTIAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN_INSN(insn, \"unknown unwind hint type %d\", cfi->type);\n\t\treturn -1;\n\t}\n\n\torc->signal = cfi->signal;\n\n\tswitch (cfi->cfa.base) {\n\tcase CFI_SP:\n\t\torc->sp_reg = ORC_REG_SP;\n\t\tbreak;\n\tcase CFI_SP_INDIRECT:\n\t\torc->sp_reg = ORC_REG_SP_INDIRECT;\n\t\tbreak;\n\tcase CFI_BP:\n\t\torc->sp_reg = ORC_REG_BP;\n\t\tbreak;\n\tcase CFI_BP_INDIRECT:\n\t\torc->sp_reg = ORC_REG_BP_INDIRECT;\n\t\tbreak;\n\tcase CFI_R10:\n\t\torc->sp_reg = ORC_REG_R10;\n\t\tbreak;\n\tcase CFI_R13:\n\t\torc->sp_reg = ORC_REG_R13;\n\t\tbreak;\n\tcase CFI_DI:\n\t\torc->sp_reg = ORC_REG_DI;\n\t\tbreak;\n\tcase CFI_DX:\n\t\torc->sp_reg = ORC_REG_DX;\n\t\tbreak;\n\tdefault:\n\t\tWARN_INSN(insn, \"unknown CFA base reg %d\", cfi->cfa.base);\n\t\treturn -1;\n\t}\n\n\tswitch (bp->base) {\n\tcase CFI_UNDEFINED:\n\t\torc->bp_reg = ORC_REG_UNDEFINED;\n\t\tbreak;\n\tcase CFI_CFA:\n\t\torc->bp_reg = ORC_REG_PREV_SP;\n\t\tbreak;\n\tcase CFI_BP:\n\t\torc->bp_reg = ORC_REG_BP;\n\t\tbreak;\n\tdefault:\n\t\tWARN_INSN(insn, \"unknown BP base reg %d\", bp->base);\n\t\treturn -1;\n\t}\n\n\torc->sp_offset = cfi->cfa.offset;\n\torc->bp_offset = bp->offset;\n\n\treturn 0;\n}\n\nstatic int write_orc_entry(struct elf *elf, struct section *orc_sec,\n\t\t\t   struct section *ip_sec, unsigned int idx,\n\t\t\t   struct section *insn_sec, unsigned long insn_off,\n\t\t\t   struct orc_entry *o)\n{\n\tstruct orc_entry *orc;\n\n\t \n\torc = (struct orc_entry *)orc_sec->data->d_buf + idx;\n\tmemcpy(orc, o, sizeof(*orc));\n\torc->sp_offset = bswap_if_needed(elf, orc->sp_offset);\n\torc->bp_offset = bswap_if_needed(elf, orc->bp_offset);\n\n\t \n\tif (!elf_init_reloc_text_sym(elf, ip_sec, idx * sizeof(int), idx,\n\t\t\t\t     insn_sec, insn_off))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstruct orc_list_entry {\n\tstruct list_head list;\n\tstruct orc_entry orc;\n\tstruct section *insn_sec;\n\tunsigned long insn_off;\n};\n\nstatic int orc_list_add(struct list_head *orc_list, struct orc_entry *orc,\n\t\t\tstruct section *sec, unsigned long offset)\n{\n\tstruct orc_list_entry *entry = malloc(sizeof(*entry));\n\n\tif (!entry) {\n\t\tWARN(\"malloc failed\");\n\t\treturn -1;\n\t}\n\n\tentry->orc\t= *orc;\n\tentry->insn_sec = sec;\n\tentry->insn_off = offset;\n\n\tlist_add_tail(&entry->list, orc_list);\n\treturn 0;\n}\n\nstatic unsigned long alt_group_len(struct alt_group *alt_group)\n{\n\treturn alt_group->last_insn->offset +\n\t       alt_group->last_insn->len -\n\t       alt_group->first_insn->offset;\n}\n\nint orc_create(struct objtool_file *file)\n{\n\tstruct section *sec, *orc_sec;\n\tunsigned int nr = 0, idx = 0;\n\tstruct orc_list_entry *entry;\n\tstruct list_head orc_list;\n\n\tstruct orc_entry null = { .type = ORC_TYPE_UNDEFINED };\n\n\t \n\tINIT_LIST_HEAD(&orc_list);\n\tfor_each_sec(file, sec) {\n\t\tstruct orc_entry orc, prev_orc = {0};\n\t\tstruct instruction *insn;\n\t\tbool empty = true;\n\n\t\tif (!sec->text)\n\t\t\tcontinue;\n\n\t\tsec_for_each_insn(file, sec, insn) {\n\t\t\tstruct alt_group *alt_group = insn->alt_group;\n\t\t\tint i;\n\n\t\t\tif (!alt_group) {\n\t\t\t\tif (init_orc_entry(&orc, insn->cfi, insn))\n\t\t\t\t\treturn -1;\n\t\t\t\tif (!memcmp(&prev_orc, &orc, sizeof(orc)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (orc_list_add(&orc_list, &orc, sec,\n\t\t\t\t\t\t insn->offset))\n\t\t\t\t\treturn -1;\n\t\t\t\tnr++;\n\t\t\t\tprev_orc = orc;\n\t\t\t\tempty = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (i = 0; i < alt_group_len(alt_group); i++) {\n\t\t\t\tstruct cfi_state *cfi = alt_group->cfi[i];\n\t\t\t\tif (!cfi)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tif (init_orc_entry(&orc, cfi, insn))\n\t\t\t\t\treturn -1;\n\t\t\t\tif (!memcmp(&prev_orc, &orc, sizeof(orc)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (orc_list_add(&orc_list, &orc, insn->sec,\n\t\t\t\t\t\t insn->offset + i))\n\t\t\t\t\treturn -1;\n\t\t\t\tnr++;\n\t\t\t\tprev_orc = orc;\n\t\t\t\tempty = false;\n\t\t\t}\n\n\t\t\t \n\t\t\tinsn = alt_group->last_insn;\n\t\t}\n\n\t\t \n\t\tif (!empty) {\n\t\t\torc_list_add(&orc_list, &null, sec, sec->sh.sh_size);\n\t\t\tnr++;\n\t\t}\n\t}\n\tif (!nr)\n\t\treturn 0;\n\n\t \n\tsec = find_section_by_name(file->elf, \".orc_unwind\");\n\tif (sec) {\n\t\tWARN(\"file already has .orc_unwind section, skipping\");\n\t\treturn -1;\n\t}\n\torc_sec = elf_create_section(file->elf, \".orc_unwind\",\n\t\t\t\t     sizeof(struct orc_entry), nr);\n\tif (!orc_sec)\n\t\treturn -1;\n\n\tsec = elf_create_section_pair(file->elf, \".orc_unwind_ip\", sizeof(int), nr, nr);\n\tif (!sec)\n\t\treturn -1;\n\n\t \n\tlist_for_each_entry(entry, &orc_list, list) {\n\t\tif (write_orc_entry(file->elf, orc_sec, sec, idx++,\n\t\t\t\t    entry->insn_sec, entry->insn_off,\n\t\t\t\t    &entry->orc))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}