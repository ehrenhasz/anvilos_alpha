{
  "module_name": "objtool.txt",
  "hash_id": "41ea7048de09e0931d6f20b79f3465ae2ac52ff22d963d6032d984199598f74a",
  "original_prompt": "Ingested from linux-6.6.14/tools/objtool/Documentation/objtool.txt",
  "human_readable_source": "Objtool\n=======\n\nThe kernel CONFIG_OBJTOOL option enables a host tool named 'objtool'\nwhich runs at compile time.  It can do various validations and\ntransformations on .o files.\n\nObjtool has become an integral part of the x86-64 kernel toolchain.  The\nkernel depends on it for a variety of security and performance features\n(and other types of features as well).\n\n\nFeatures\n--------\n\nObjtool has the following features:\n\n- Stack unwinding metadata validation -- useful for helping to ensure\n  stack traces are reliable for live patching\n\n- ORC unwinder metadata generation -- a faster and more precise\n  alternative to frame pointer based unwinding\n\n- Retpoline validation -- ensures that all indirect calls go through\n  retpoline thunks, for Spectre v2 mitigations\n\n- Retpoline call site annotation -- annotates all retpoline thunk call\n  sites, enabling the kernel to patch them inline, to prevent \"thunk\n  funneling\" for both security and performance reasons\n\n- Non-instrumentation validation -- validates non-instrumentable\n  (\"noinstr\") code rules, preventing instrumentation in low-level C\n  entry code\n\n- Static call annotation -- annotates static call sites, enabling the\n  kernel to implement inline static calls, a faster alternative to some\n  indirect branches\n\n- Uaccess validation -- validates uaccess rules for a proper\n  implementation of Supervisor Mode Access Protection (SMAP)\n\n- Straight Line Speculation validation -- validates certain SLS\n  mitigations\n\n- Indirect Branch Tracking validation -- validates Intel CET IBT rules\n  to ensure that all functions referenced by function pointers have\n  corresponding ENDBR instructions\n\n- Indirect Branch Tracking annotation -- annotates unused ENDBR\n  instruction sites, enabling the kernel to \"seal\" them (replace them\n  with NOPs) to further harden IBT\n\n- Function entry annotation -- annotates function entries, enabling\n  kernel function tracing\n\n- Other toolchain hacks which will go unmentioned at this time...\n\nEach feature can be enabled individually or in combination using the\nobjtool cmdline.\n\n\nObjects\n-------\n\nTypically, objtool runs on every translation unit (TU, aka \".o file\") in\nthe kernel.  If a TU is part of a kernel module, the '--module' option\nis added.\n\nHowever:\n\n- If noinstr validation is enabled, it also runs on vmlinux.o, with all\n  options removed and '--noinstr' added.\n\n- If IBT or LTO is enabled, it doesn't run on TUs at all.  Instead it\n  runs on vmlinux.o and linked modules, with all options.\n\nIn summary:\n\n  A) Legacy mode:\n             TU: objtool [--module] <options>\n        vmlinux: N/A\n         module: N/A\n\n  B) CONFIG_NOINSTR_VALIDATION=y && !(CONFIG_X86_KERNEL_IBT=y || CONFIG_LTO=y):\n             TU: objtool [--module] <options>\t// no --noinstr\n        vmlinux: objtool --noinstr\t\t// other options removed\n         module: N/A\n\n  C) CONFIG_X86_KERNEL_IBT=y || CONFIG_LTO=y:\n             TU: N/A\n        vmlinux: objtool --noinstr <options>\n         module: objtool --module --noinstr <options>\n\n\nStack validation\n----------------\n\nObjtool's stack validation feature analyzes every .o file and ensures\nthe validity of its stack metadata.  It enforces a set of rules on asm\ncode and C inline assembly code so that stack traces can be reliable.\n\nFor each function, it recursively follows all possible code paths and\nvalidates the correct frame pointer state at each instruction.\n\nIt also follows code paths involving special sections, like\n.altinstructions, __jump_table, and __ex_table, which can add\nalternative execution paths to a given instruction (or set of\ninstructions).  Similarly, it knows how to follow switch statements, for\nwhich gcc sometimes uses jump tables.\n\nHere are some of the benefits of validating stack metadata:\n\na) More reliable stack traces for frame pointer enabled kernels\n\n   Frame pointers are used for debugging purposes.  They allow runtime\n   code and debug tools to be able to walk the stack to determine the\n   chain of function call sites that led to the currently executing\n   code.\n\n   For some architectures, frame pointers are enabled by\n   CONFIG_FRAME_POINTER.  For some other architectures they may be\n   required by the ABI (sometimes referred to as \"backchain pointers\").\n\n   For C code, gcc automatically generates instructions for setting up\n   frame pointers when the -fno-omit-frame-pointer option is used.\n\n   But for asm code, the frame setup instructions have to be written by\n   hand, which most people don't do.  So the end result is that\n   CONFIG_FRAME_POINTER is honored for C code but not for most asm code.\n\n   For stack traces based on frame pointers to be reliable, all\n   functions which call other functions must first create a stack frame\n   and update the frame pointer.  If a first function doesn't properly\n   create a stack frame before calling a second function, the *caller*\n   of the first function will be skipped on the stack trace.\n\n   For example, consider the following example backtrace with frame\n   pointers enabled:\n\n     [<ffffffff81812584>] dump_stack+0x4b/0x63\n     [<ffffffff812d6dc2>] cmdline_proc_show+0x12/0x30\n     [<ffffffff8127f568>] seq_read+0x108/0x3e0\n     [<ffffffff812cce62>] proc_reg_read+0x42/0x70\n     [<ffffffff81256197>] __vfs_read+0x37/0x100\n     [<ffffffff81256b16>] vfs_read+0x86/0x130\n     [<ffffffff81257898>] SyS_read+0x58/0xd0\n     [<ffffffff8181c1f2>] entry_SYSCALL_64_fastpath+0x12/0x76\n\n   It correctly shows that the caller of cmdline_proc_show() is\n   seq_read().\n\n   If we remove the frame pointer logic from cmdline_proc_show() by\n   replacing the frame pointer related instructions with nops, here's\n   what it looks like instead:\n\n     [<ffffffff81812584>] dump_stack+0x4b/0x63\n     [<ffffffff812d6dc2>] cmdline_proc_show+0x12/0x30\n     [<ffffffff812cce62>] proc_reg_read+0x42/0x70\n     [<ffffffff81256197>] __vfs_read+0x37/0x100\n     [<ffffffff81256b16>] vfs_read+0x86/0x130\n     [<ffffffff81257898>] SyS_read+0x58/0xd0\n     [<ffffffff8181c1f2>] entry_SYSCALL_64_fastpath+0x12/0x76\n\n   Notice that cmdline_proc_show()'s caller, seq_read(), has been\n   skipped.  Instead the stack trace seems to show that\n   cmdline_proc_show() was called by proc_reg_read().\n\n   The benefit of objtool here is that because it ensures that *all*\n   functions honor CONFIG_FRAME_POINTER, no functions will ever[*] be\n   skipped on a stack trace.\n\n   [*] unless an interrupt or exception has occurred at the very\n       beginning of a function before the stack frame has been created,\n       or at the very end of the function after the stack frame has been\n       destroyed.  This is an inherent limitation of frame pointers.\n\nb) ORC (Oops Rewind Capability) unwind table generation\n\n   An alternative to frame pointers and DWARF, ORC unwind data can be\n   used to walk the stack.  Unlike frame pointers, ORC data is out of\n   band.  So it doesn't affect runtime performance and it can be\n   reliable even when interrupts or exceptions are involved.\n\n   For more details, see Documentation/arch/x86/orc-unwinder.rst.\n\nc) Higher live patching compatibility rate\n\n   Livepatch has an optional \"consistency model\", which is needed for\n   more complex patches.  In order for the consistency model to work,\n   stack traces need to be reliable (or an unreliable condition needs to\n   be detectable).  Objtool makes that possible.\n\n   For more details, see the livepatch documentation in the Linux kernel\n   source tree at Documentation/livepatch/livepatch.rst.\n\nTo achieve the validation, objtool enforces the following rules:\n\n1. Each callable function must be annotated as such with the ELF\n   function type.  In asm code, this is typically done using the\n   ENTRY/ENDPROC macros.  If objtool finds a return instruction\n   outside of a function, it flags an error since that usually indicates\n   callable code which should be annotated accordingly.\n\n   This rule is needed so that objtool can properly identify each\n   callable function in order to analyze its stack metadata.\n\n2. Conversely, each section of code which is *not* callable should *not*\n   be annotated as an ELF function.  The ENDPROC macro shouldn't be used\n   in this case.\n\n   This rule is needed so that objtool can ignore non-callable code.\n   Such code doesn't have to follow any of the other rules.\n\n3. Each callable function which calls another function must have the\n   correct frame pointer logic, if required by CONFIG_FRAME_POINTER or\n   the architecture's back chain rules.  This can by done in asm code\n   with the FRAME_BEGIN/FRAME_END macros.\n\n   This rule ensures that frame pointer based stack traces will work as\n   designed.  If function A doesn't create a stack frame before calling\n   function B, the _caller_ of function A will be skipped on the stack\n   trace.\n\n4. Dynamic jumps and jumps to undefined symbols are only allowed if:\n\n   a) the jump is part of a switch statement; or\n\n   b) the jump matches sibling call semantics and the frame pointer has\n      the same value it had on function entry.\n\n   This rule is needed so that objtool can reliably analyze all of a\n   function's code paths.  If a function jumps to code in another file,\n   and it's not a sibling call, objtool has no way to follow the jump\n   because it only analyzes a single file at a time.\n\n5. A callable function may not execute kernel entry/exit instructions.\n   The only code which needs such instructions is kernel entry code,\n   which shouldn't be be in callable functions anyway.\n\n   This rule is just a sanity check to ensure that callable functions\n   return normally.\n\n\nObjtool warnings\n----------------\n\nNOTE: When requesting help with an objtool warning, please recreate with\nOBJTOOL_VERBOSE=1 (e.g., \"make OBJTOOL_VERBOSE=1\") and send the full\noutput, including any disassembly or backtrace below the warning, to the\nobjtool maintainers.\n\nFor asm files, if you're getting an error which doesn't make sense,\nfirst make sure that the affected code follows the above rules.\n\nFor C files, the common culprits are inline asm statements and calls to\n\"noreturn\" functions.  See below for more details.\n\nAnother possible cause for errors in C code is if the Makefile removes\n-fno-omit-frame-pointer or adds -fomit-frame-pointer to the gcc options.\n\nHere are some examples of common warnings reported by objtool, what\nthey mean, and suggestions for how to fix them.  When in doubt, ping\nthe objtool maintainers.\n\n\n1. file.o: warning: objtool: func()+0x128: call without frame pointer save/setup\n\n   The func() function made a function call without first saving and/or\n   updating the frame pointer, and CONFIG_FRAME_POINTER is enabled.\n\n   If the error is for an asm file, and func() is indeed a callable\n   function, add proper frame pointer logic using the FRAME_BEGIN and\n   FRAME_END macros.  Otherwise, if it's not a callable function, remove\n   its ELF function annotation by changing ENDPROC to END, and instead\n   use the manual unwind hint macros in asm/unwind_hints.h.\n\n   If it's a GCC-compiled .c file, the error may be because the function\n   uses an inline asm() statement which has a \"call\" instruction.  An\n   asm() statement with a call instruction must declare the use of the\n   stack pointer in its output operand.  On x86_64, this means adding\n   the ASM_CALL_CONSTRAINT as an output constraint:\n\n     asm volatile(\"call func\" : ASM_CALL_CONSTRAINT);\n\n   Otherwise the stack frame may not get created before the call.\n\n\n2. file.o: warning: objtool: .text+0x53: unreachable instruction\n\n   Objtool couldn't find a code path to reach the instruction.\n\n   If the error is for an asm file, and the instruction is inside (or\n   reachable from) a callable function, the function should be annotated\n   with the ENTRY/ENDPROC macros (ENDPROC is the important one).\n   Otherwise, the code should probably be annotated with the unwind hint\n   macros in asm/unwind_hints.h so objtool and the unwinder can know the\n   stack state associated with the code.\n\n   If you're 100% sure the code won't affect stack traces, or if you're\n   a just a bad person, you can tell objtool to ignore it.  See the\n   \"Adding exceptions\" section below.\n\n   If it's not actually in a callable function (e.g. kernel entry code),\n   change ENDPROC to END.\n\n3. file.o: warning: objtool: foo+0x48c: bar() is missing a __noreturn annotation\n\n   The call from foo() to bar() doesn't return, but bar() is missing the\n   __noreturn annotation.  NOTE: In addition to annotating the function\n   with __noreturn, please also add it to tools/objtool/noreturns.h.\n\n4. file.o: warning: objtool: func(): can't find starting instruction\n   or\n   file.o: warning: objtool: func()+0x11dd: can't decode instruction\n\n   Does the file have data in a text section?  If so, that can confuse\n   objtool's instruction decoder.  Move the data to a more appropriate\n   section like .data or .rodata.\n\n\n5. file.o: warning: objtool: func()+0x6: unsupported instruction in callable function\n\n   This is a kernel entry/exit instruction like sysenter or iret.  Such\n   instructions aren't allowed in a callable function, and are most\n   likely part of the kernel entry code.  They should usually not have\n   the callable function annotation (ENDPROC) and should always be\n   annotated with the unwind hint macros in asm/unwind_hints.h.\n\n\n6. file.o: warning: objtool: func()+0x26: sibling call from callable instruction with modified stack frame\n\n   This is a dynamic jump or a jump to an undefined symbol.  Objtool\n   assumed it's a sibling call and detected that the frame pointer\n   wasn't first restored to its original state.\n\n   If it's not really a sibling call, you may need to move the\n   destination code to the local file.\n\n   If the instruction is not actually in a callable function (e.g.\n   kernel entry code), change ENDPROC to END and annotate manually with\n   the unwind hint macros in asm/unwind_hints.h.\n\n\n7. file: warning: objtool: func()+0x5c: stack state mismatch\n\n   The instruction's frame pointer state is inconsistent, depending on\n   which execution path was taken to reach the instruction.\n\n   Make sure that, when CONFIG_FRAME_POINTER is enabled, the function\n   pushes and sets up the frame pointer (for x86_64, this means rbp) at\n   the beginning of the function and pops it at the end of the function.\n   Also make sure that no other code in the function touches the frame\n   pointer.\n\n   Another possibility is that the code has some asm or inline asm which\n   does some unusual things to the stack or the frame pointer.  In such\n   cases it's probably appropriate to use the unwind hint macros in\n   asm/unwind_hints.h.\n\n\n8. file.o: warning: objtool: funcA() falls through to next function funcB()\n\n   This means that funcA() doesn't end with a return instruction or an\n   unconditional jump, and that objtool has determined that the function\n   can fall through into the next function.  There could be different\n   reasons for this:\n\n   1) funcA()'s last instruction is a call to a \"noreturn\" function like\n      panic().  In this case the noreturn function needs to be added to\n      objtool's hard-coded global_noreturns array.  Feel free to bug the\n      objtool maintainer, or you can submit a patch.\n\n   2) funcA() uses the unreachable() annotation in a section of code\n      that is actually reachable.\n\n   3) If funcA() calls an inline function, the object code for funcA()\n      might be corrupt due to a gcc bug.  For more details, see:\n      https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70646\n\n9. file.o: warning: objtool: funcA() call to funcB() with UACCESS enabled\n\n   This means that an unexpected call to a non-whitelisted function exists\n   outside of arch-specific guards.\n   X86: SMAP (stac/clac): __uaccess_begin()/__uaccess_end()\n   ARM: PAN: uaccess_enable()/uaccess_disable()\n\n   These functions should be called to denote a minimal critical section around\n   access to __user variables. See also: https://lwn.net/Articles/517475/\n\n   The intention of the warning is to prevent calls to funcB() from eventually\n   calling schedule(), potentially leaking the AC flags state, and not\n   restoring them correctly.\n\n   It also helps verify that there are no unexpected calls to funcB() which may\n   access user space pages with protections against doing so disabled.\n\n   To fix, either:\n   1) remove explicit calls to funcB() from funcA().\n   2) add the correct guards before and after calls to low level functions like\n      __get_user_size()/__put_user_size().\n   3) add funcB to uaccess_safe_builtin whitelist in tools/objtool/check.c, if\n      funcB obviously does not call schedule(), and is marked notrace (since\n      function tracing inserts additional calls, which is not obvious from the\n      sources).\n\n10. file.o: warning: func()+0x5c: stack layout conflict in alternatives\n\n    This means that in the use of the alternative() or ALTERNATIVE()\n    macro, the code paths have conflicting modifications to the stack.\n    The problem is that there is only one ORC unwind table, which means\n    that the ORC unwind entries must be consistent for all possible\n    instruction boundaries regardless of which code has been patched.\n    This limitation can be overcome by massaging the alternatives with\n    NOPs to shift the stack changes around so they no longer conflict.\n\n11. file.o: warning: unannotated intra-function call\n\n   This warning means that a direct call is done to a destination which\n   is not at the beginning of a function. If this is a legit call, you\n   can remove this warning by putting the ANNOTATE_INTRA_FUNCTION_CALL\n   directive right before the call.\n\n12. file.o: warning: func(): not an indirect call target\n\n   This means that objtool is running with --ibt and a function expected\n   to be an indirect call target is not. In particular, this happens for\n   init_module() or cleanup_module() if a module relies on these special\n   names and does not use module_init() / module_exit() macros to create\n   them.\n\n\nIf the error doesn't seem to make sense, it could be a bug in objtool.\nFeel free to ask the objtool maintainer for help.\n\n\nAdding exceptions\n-----------------\n\nIf you _really_ need objtool to ignore something, and are 100% sure\nthat it won't affect kernel stack traces, you can tell objtool to\nignore it:\n\n- To skip validation of a function, use the STACK_FRAME_NON_STANDARD\n  macro.\n\n- To skip validation of a file, add\n\n    OBJECT_FILES_NON_STANDARD_filename.o := y\n\n  to the Makefile.\n\n- To skip validation of a directory, add\n\n    OBJECT_FILES_NON_STANDARD := y\n\n  to the Makefile.\n\nNOTE: OBJECT_FILES_NON_STANDARD doesn't work for link time validation of\nvmlinux.o or a linked module.  So it should only be used for files which\naren't linked into vmlinux or a module.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}