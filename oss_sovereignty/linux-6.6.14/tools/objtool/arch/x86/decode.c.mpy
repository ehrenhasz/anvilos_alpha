{
  "module_name": "decode.c",
  "hash_id": "5e3eeb8be3340ecea98dc348c2cdd241282d3690564f8b4ab8e05a2f5d47ba02",
  "original_prompt": "Ingested from linux-6.6.14/tools/objtool/arch/x86/decode.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define unlikely(cond) (cond)\n#include <asm/insn.h>\n#include \"../../../arch/x86/lib/inat.c\"\n#include \"../../../arch/x86/lib/insn.c\"\n\n#define CONFIG_64BIT 1\n#include <asm/nops.h>\n\n#include <asm/orc_types.h>\n#include <objtool/check.h>\n#include <objtool/elf.h>\n#include <objtool/arch.h>\n#include <objtool/warn.h>\n#include <objtool/endianness.h>\n#include <objtool/builtin.h>\n#include <arch/elf.h>\n\nint arch_ftrace_match(char *name)\n{\n\treturn !strcmp(name, \"__fentry__\");\n}\n\nstatic int is_x86_64(const struct elf *elf)\n{\n\tswitch (elf->ehdr.e_machine) {\n\tcase EM_X86_64:\n\t\treturn 1;\n\tcase EM_386:\n\t\treturn 0;\n\tdefault:\n\t\tWARN(\"unexpected ELF machine type %d\", elf->ehdr.e_machine);\n\t\treturn -1;\n\t}\n}\n\nbool arch_callee_saved_reg(unsigned char reg)\n{\n\tswitch (reg) {\n\tcase CFI_BP:\n\tcase CFI_BX:\n\tcase CFI_R12:\n\tcase CFI_R13:\n\tcase CFI_R14:\n\tcase CFI_R15:\n\t\treturn true;\n\n\tcase CFI_AX:\n\tcase CFI_CX:\n\tcase CFI_DX:\n\tcase CFI_SI:\n\tcase CFI_DI:\n\tcase CFI_SP:\n\tcase CFI_R8:\n\tcase CFI_R9:\n\tcase CFI_R10:\n\tcase CFI_R11:\n\tcase CFI_RA:\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nunsigned long arch_dest_reloc_offset(int addend)\n{\n\treturn addend + 4;\n}\n\nunsigned long arch_jump_destination(struct instruction *insn)\n{\n\treturn insn->offset + insn->len + insn->immediate;\n}\n\nbool arch_pc_relative_reloc(struct reloc *reloc)\n{\n\t \n\tswitch (reloc_type(reloc)) {\n\tcase R_X86_64_PC8:\n\tcase R_X86_64_PC16:\n\tcase R_X86_64_PC32:\n\tcase R_X86_64_PC64:\n\n\tcase R_X86_64_PLT32:\n\tcase R_X86_64_GOTPC32:\n\tcase R_X86_64_GOTPCREL:\n\t\treturn true;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n#define ADD_OP(op) \\\n\tif (!(op = calloc(1, sizeof(*op)))) \\\n\t\treturn -1; \\\n\telse for (*ops_list = op, ops_list = &op->next; op; op = NULL)\n\n \n\n#define mod_is_mem()\t(modrm_mod != 3)\n#define mod_is_reg()\t(modrm_mod == 3)\n\n#define is_RIP()   ((modrm_rm & 7) == CFI_BP && modrm_mod == 0)\n#define have_SIB() ((modrm_rm & 7) == CFI_SP && mod_is_mem())\n\n#define rm_is(reg) (have_SIB() ? \\\n\t\t    sib_base == (reg) && sib_index == CFI_SP : \\\n\t\t    modrm_rm == (reg))\n\n#define rm_is_mem(reg)\t(mod_is_mem() && !is_RIP() && rm_is(reg))\n#define rm_is_reg(reg)\t(mod_is_reg() && modrm_rm == (reg))\n\nstatic bool has_notrack_prefix(struct insn *insn)\n{\n\tint i;\n\n\tfor (i = 0; i < insn->prefixes.nbytes; i++) {\n\t\tif (insn->prefixes.bytes[i] == 0x3e)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint arch_decode_instruction(struct objtool_file *file, const struct section *sec,\n\t\t\t    unsigned long offset, unsigned int maxlen,\n\t\t\t    struct instruction *insn)\n{\n\tstruct stack_op **ops_list = &insn->stack_ops;\n\tconst struct elf *elf = file->elf;\n\tstruct insn ins;\n\tint x86_64, ret;\n\tunsigned char op1, op2, op3, prefix,\n\t\t      rex = 0, rex_b = 0, rex_r = 0, rex_w = 0, rex_x = 0,\n\t\t      modrm = 0, modrm_mod = 0, modrm_rm = 0, modrm_reg = 0,\n\t\t      sib = 0,   sib_index = 0, sib_base = 0;\n\tstruct stack_op *op = NULL;\n\tstruct symbol *sym;\n\tu64 imm;\n\n\tx86_64 = is_x86_64(elf);\n\tif (x86_64 == -1)\n\t\treturn -1;\n\n\tret = insn_decode(&ins, sec->data->d_buf + offset, maxlen,\n\t\t\t  x86_64 ? INSN_MODE_64 : INSN_MODE_32);\n\tif (ret < 0) {\n\t\tWARN(\"can't decode instruction at %s:0x%lx\", sec->name, offset);\n\t\treturn -1;\n\t}\n\n\tinsn->len = ins.length;\n\tinsn->type = INSN_OTHER;\n\n\tif (ins.vex_prefix.nbytes)\n\t\treturn 0;\n\n\tprefix = ins.prefixes.bytes[0];\n\n\top1 = ins.opcode.bytes[0];\n\top2 = ins.opcode.bytes[1];\n\top3 = ins.opcode.bytes[2];\n\n\tif (ins.rex_prefix.nbytes) {\n\t\trex = ins.rex_prefix.bytes[0];\n\t\trex_w = X86_REX_W(rex) >> 3;\n\t\trex_r = X86_REX_R(rex) >> 2;\n\t\trex_x = X86_REX_X(rex) >> 1;\n\t\trex_b = X86_REX_B(rex);\n\t}\n\n\tif (ins.modrm.nbytes) {\n\t\tmodrm = ins.modrm.bytes[0];\n\t\tmodrm_mod = X86_MODRM_MOD(modrm);\n\t\tmodrm_reg = X86_MODRM_REG(modrm) + 8*rex_r;\n\t\tmodrm_rm  = X86_MODRM_RM(modrm)  + 8*rex_b;\n\t}\n\n\tif (ins.sib.nbytes) {\n\t\tsib = ins.sib.bytes[0];\n\t\t \n\t\tsib_index = X86_SIB_INDEX(sib) + 8*rex_x;\n\t\tsib_base  = X86_SIB_BASE(sib)  + 8*rex_b;\n\t}\n\n\tswitch (op1) {\n\n\tcase 0x1:\n\tcase 0x29:\n\t\tif (rex_w && rm_is_reg(CFI_SP)) {\n\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_ADD;\n\t\t\t\top->src.reg = modrm_reg;\n\t\t\t\top->dest.type = OP_DEST_REG;\n\t\t\t\top->dest.reg = CFI_SP;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 0x50 ... 0x57:\n\n\t\t \n\t\tADD_OP(op) {\n\t\t\top->src.type = OP_SRC_REG;\n\t\t\top->src.reg = (op1 & 0x7) + 8*rex_b;\n\t\t\top->dest.type = OP_DEST_PUSH;\n\t\t}\n\n\t\tbreak;\n\n\tcase 0x58 ... 0x5f:\n\n\t\t \n\t\tADD_OP(op) {\n\t\t\top->src.type = OP_SRC_POP;\n\t\t\top->dest.type = OP_DEST_REG;\n\t\t\top->dest.reg = (op1 & 0x7) + 8*rex_b;\n\t\t}\n\n\t\tbreak;\n\n\tcase 0x68:\n\tcase 0x6a:\n\t\t \n\t\tADD_OP(op) {\n\t\t\top->src.type = OP_SRC_CONST;\n\t\t\top->dest.type = OP_DEST_PUSH;\n\t\t}\n\t\tbreak;\n\n\tcase 0x70 ... 0x7f:\n\t\tinsn->type = INSN_JUMP_CONDITIONAL;\n\t\tbreak;\n\n\tcase 0x80 ... 0x83:\n\t\t \n\n\t\t \n\t\tif (!rex_w)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!rm_is_reg(CFI_SP))\n\t\t\tbreak;\n\n\t\timm = ins.immediate.value;\n\t\tif (op1 & 2) {  \n\t\t\tif (op1 & 1) {  \n\t\t\t\timm <<= 32;\n\t\t\t\timm = (s64)imm >> 32;\n\t\t\t} else {  \n\t\t\t\timm <<= 56;\n\t\t\t\timm = (s64)imm >> 56;\n\t\t\t}\n\t\t}\n\n\t\tswitch (modrm_reg & 7) {\n\t\tcase 5:\n\t\t\timm = -imm;\n\t\t\t \n\t\tcase 0:\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_ADD;\n\t\t\t\top->src.reg = CFI_SP;\n\t\t\t\top->src.offset = imm;\n\t\t\t\top->dest.type = OP_DEST_REG;\n\t\t\t\top->dest.reg = CFI_SP;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_AND;\n\t\t\t\top->src.reg = CFI_SP;\n\t\t\t\top->src.offset = ins.immediate.value;\n\t\t\t\top->dest.type = OP_DEST_REG;\n\t\t\t\top->dest.reg = CFI_SP;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase 0x89:\n\t\tif (!rex_w)\n\t\t\tbreak;\n\n\t\tif (modrm_reg == CFI_SP) {\n\n\t\t\tif (mod_is_reg()) {\n\t\t\t\t \n\t\t\t\tADD_OP(op) {\n\t\t\t\t\top->src.type = OP_SRC_REG;\n\t\t\t\t\top->src.reg = CFI_SP;\n\t\t\t\t\top->dest.type = OP_DEST_REG;\n\t\t\t\t\top->dest.reg = modrm_rm;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (is_RIP())\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (have_SIB()) {\n\t\t\t\t\tmodrm_rm = sib_base;\n\t\t\t\t\tif (sib_index != CFI_SP)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tADD_OP(op) {\n\t\t\t\t\top->src.type = OP_SRC_REG;\n\t\t\t\t\top->src.reg = CFI_SP;\n\t\t\t\t\top->dest.type = OP_DEST_REG_INDIRECT;\n\t\t\t\t\top->dest.reg = modrm_rm;\n\t\t\t\t\top->dest.offset = ins.displacement.value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rm_is_reg(CFI_SP)) {\n\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_REG;\n\t\t\t\top->src.reg = modrm_reg;\n\t\t\t\top->dest.type = OP_DEST_REG;\n\t\t\t\top->dest.reg = CFI_SP;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\tcase 0x88:\n\t\tif (!rex_w)\n\t\t\tbreak;\n\n\t\tif (rm_is_mem(CFI_BP)) {\n\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_REG;\n\t\t\t\top->src.reg = modrm_reg;\n\t\t\t\top->dest.type = OP_DEST_REG_INDIRECT;\n\t\t\t\top->dest.reg = CFI_BP;\n\t\t\t\top->dest.offset = ins.displacement.value;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rm_is_mem(CFI_SP)) {\n\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_REG;\n\t\t\t\top->src.reg = modrm_reg;\n\t\t\t\top->dest.type = OP_DEST_REG_INDIRECT;\n\t\t\t\top->dest.reg = CFI_SP;\n\t\t\t\top->dest.offset = ins.displacement.value;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase 0x8b:\n\t\tif (!rex_w)\n\t\t\tbreak;\n\n\t\tif (rm_is_mem(CFI_BP)) {\n\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_REG_INDIRECT;\n\t\t\t\top->src.reg = CFI_BP;\n\t\t\t\top->src.offset = ins.displacement.value;\n\t\t\t\top->dest.type = OP_DEST_REG;\n\t\t\t\top->dest.reg = modrm_reg;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rm_is_mem(CFI_SP)) {\n\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_REG_INDIRECT;\n\t\t\t\top->src.reg = CFI_SP;\n\t\t\t\top->src.offset = ins.displacement.value;\n\t\t\t\top->dest.type = OP_DEST_REG;\n\t\t\t\top->dest.reg = modrm_reg;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase 0x8d:\n\t\tif (mod_is_reg()) {\n\t\t\tWARN(\"invalid LEA encoding at %s:0x%lx\", sec->name, offset);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!rex_w)\n\t\t\tbreak;\n\n\t\t \n\t\tif (is_RIP())\n\t\t\tbreak;\n\n\t\t \n\t\tif (have_SIB()) {\n\t\t\tmodrm_rm = sib_base;\n\t\t\tif (sib_index != CFI_SP)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tADD_OP(op) {\n\t\t\top->src.offset = ins.displacement.value;\n\t\t\tif (!op->src.offset) {\n\t\t\t\t \n\t\t\t\top->src.type = OP_SRC_REG;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\top->src.type = OP_SRC_ADD;\n\t\t\t}\n\t\t\top->src.reg = modrm_rm;\n\t\t\top->dest.type = OP_DEST_REG;\n\t\t\top->dest.reg = modrm_reg;\n\t\t}\n\t\tbreak;\n\n\tcase 0x8f:\n\t\t \n\t\tADD_OP(op) {\n\t\t\top->src.type = OP_SRC_POP;\n\t\t\top->dest.type = OP_DEST_MEM;\n\t\t}\n\t\tbreak;\n\n\tcase 0x90:\n\t\tinsn->type = INSN_NOP;\n\t\tbreak;\n\n\tcase 0x9c:\n\t\t \n\t\tADD_OP(op) {\n\t\t\top->src.type = OP_SRC_CONST;\n\t\t\top->dest.type = OP_DEST_PUSHF;\n\t\t}\n\t\tbreak;\n\n\tcase 0x9d:\n\t\t \n\t\tADD_OP(op) {\n\t\t\top->src.type = OP_SRC_POPF;\n\t\t\top->dest.type = OP_DEST_MEM;\n\t\t}\n\t\tbreak;\n\n\tcase 0x0f:\n\n\t\tif (op2 == 0x01) {\n\n\t\t\tif (modrm == 0xca)\n\t\t\t\tinsn->type = INSN_CLAC;\n\t\t\telse if (modrm == 0xcb)\n\t\t\t\tinsn->type = INSN_STAC;\n\n\t\t} else if (op2 >= 0x80 && op2 <= 0x8f) {\n\n\t\t\tinsn->type = INSN_JUMP_CONDITIONAL;\n\n\t\t} else if (op2 == 0x05 || op2 == 0x07 || op2 == 0x34 ||\n\t\t\t   op2 == 0x35) {\n\n\t\t\t \n\t\t\tinsn->type = INSN_CONTEXT_SWITCH;\n\n\t\t} else if (op2 == 0x0b || op2 == 0xb9) {\n\n\t\t\t \n\t\t\tinsn->type = INSN_BUG;\n\n\t\t} else if (op2 == 0x0d || op2 == 0x1f) {\n\n\t\t\t \n\t\t\tinsn->type = INSN_NOP;\n\n\t\t} else if (op2 == 0x1e) {\n\n\t\t\tif (prefix == 0xf3 && (modrm == 0xfa || modrm == 0xfb))\n\t\t\t\tinsn->type = INSN_ENDBR;\n\n\n\t\t} else if (op2 == 0x38 && op3 == 0xf8) {\n\t\t\tif (ins.prefixes.nbytes == 1 &&\n\t\t\t    ins.prefixes.bytes[0] == 0xf2) {\n\t\t\t\t \n\t\t\t\tWARN(\"ENQCMD instruction at %s:%lx\", sec->name,\n\t\t\t\t     offset);\n\t\t\t}\n\n\t\t} else if (op2 == 0xa0 || op2 == 0xa8) {\n\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_CONST;\n\t\t\t\top->dest.type = OP_DEST_PUSH;\n\t\t\t}\n\n\t\t} else if (op2 == 0xa1 || op2 == 0xa9) {\n\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_POP;\n\t\t\t\top->dest.type = OP_DEST_MEM;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase 0xc9:\n\t\t \n\t\tADD_OP(op) {\n\t\t\top->src.type = OP_SRC_REG;\n\t\t\top->src.reg = CFI_BP;\n\t\t\top->dest.type = OP_DEST_REG;\n\t\t\top->dest.reg = CFI_SP;\n\t\t}\n\t\tADD_OP(op) {\n\t\t\top->src.type = OP_SRC_POP;\n\t\t\top->dest.type = OP_DEST_REG;\n\t\t\top->dest.reg = CFI_BP;\n\t\t}\n\t\tbreak;\n\n\tcase 0xcc:\n\t\t \n\t\tinsn->type = INSN_TRAP;\n\t\tbreak;\n\n\tcase 0xe3:\n\t\t \n\t\tinsn->type = INSN_JUMP_CONDITIONAL;\n\t\tbreak;\n\n\tcase 0xe9:\n\tcase 0xeb:\n\t\tinsn->type = INSN_JUMP_UNCONDITIONAL;\n\t\tbreak;\n\n\tcase 0xc2:\n\tcase 0xc3:\n\t\tinsn->type = INSN_RETURN;\n\t\tbreak;\n\n\tcase 0xc7:  \n\t\tif (!opts.noinstr)\n\t\t\tbreak;\n\n\t\tif (ins.length == 3+4+4 && !strncmp(sec->name, \".init.text\", 10)) {\n\t\t\tstruct reloc *immr, *disp;\n\t\t\tstruct symbol *func;\n\t\t\tint idx;\n\n\t\t\timmr = find_reloc_by_dest(elf, (void *)sec, offset+3);\n\t\t\tdisp = find_reloc_by_dest(elf, (void *)sec, offset+7);\n\n\t\t\tif (!immr || strcmp(immr->sym->name, \"pv_ops\"))\n\t\t\t\tbreak;\n\n\t\t\tidx = (reloc_addend(immr) + 8) / sizeof(void *);\n\n\t\t\tfunc = disp->sym;\n\t\t\tif (disp->sym->type == STT_SECTION)\n\t\t\t\tfunc = find_symbol_by_offset(disp->sym->sec, reloc_addend(disp));\n\t\t\tif (!func) {\n\t\t\t\tWARN(\"no func for pv_ops[]\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tobjtool_pv_add(file, idx, func);\n\t\t}\n\n\t\tbreak;\n\n\tcase 0xcf:  \n\t\t \n\t\tsym = find_symbol_containing(sec, offset);\n\t\tif (sym && sym->type == STT_FUNC) {\n\t\t\tADD_OP(op) {\n\t\t\t\t \n\t\t\t\top->src.type = OP_SRC_ADD;\n\t\t\t\top->src.reg = CFI_SP;\n\t\t\t\top->src.offset = 5*8;\n\t\t\t\top->dest.type = OP_DEST_REG;\n\t\t\t\top->dest.reg = CFI_SP;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\tcase 0xca:  \n\tcase 0xcb:  \n\t\tinsn->type = INSN_CONTEXT_SWITCH;\n\t\tbreak;\n\n\tcase 0xe0:  \n\tcase 0xe1:  \n\tcase 0xe2:  \n\t\tinsn->type = INSN_JUMP_CONDITIONAL;\n\t\tbreak;\n\n\tcase 0xe8:\n\t\tinsn->type = INSN_CALL;\n\t\t \n\t\tADD_OP(op) {\n\t\t\top->src.type = OP_SRC_CONST;\n\t\t\top->dest.type = OP_DEST_PUSH;\n\t\t}\n\t\tbreak;\n\n\tcase 0xfc:\n\t\tinsn->type = INSN_CLD;\n\t\tbreak;\n\n\tcase 0xfd:\n\t\tinsn->type = INSN_STD;\n\t\tbreak;\n\n\tcase 0xff:\n\t\tif (modrm_reg == 2 || modrm_reg == 3) {\n\n\t\t\tinsn->type = INSN_CALL_DYNAMIC;\n\t\t\tif (has_notrack_prefix(&ins))\n\t\t\t\tWARN(\"notrack prefix found at %s:0x%lx\", sec->name, offset);\n\n\t\t} else if (modrm_reg == 4) {\n\n\t\t\tinsn->type = INSN_JUMP_DYNAMIC;\n\t\t\tif (has_notrack_prefix(&ins))\n\t\t\t\tWARN(\"notrack prefix found at %s:0x%lx\", sec->name, offset);\n\n\t\t} else if (modrm_reg == 5) {\n\n\t\t\t \n\t\t\tinsn->type = INSN_CONTEXT_SWITCH;\n\n\t\t} else if (modrm_reg == 6) {\n\n\t\t\t \n\t\t\tADD_OP(op) {\n\t\t\t\top->src.type = OP_SRC_CONST;\n\t\t\t\top->dest.type = OP_DEST_PUSH;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tinsn->immediate = ins.immediate.nbytes ? ins.immediate.value : 0;\n\n\treturn 0;\n}\n\nvoid arch_initial_func_cfi_state(struct cfi_init_state *state)\n{\n\tint i;\n\n\tfor (i = 0; i < CFI_NUM_REGS; i++) {\n\t\tstate->regs[i].base = CFI_UNDEFINED;\n\t\tstate->regs[i].offset = 0;\n\t}\n\n\t \n\tstate->cfa.base = CFI_SP;\n\tstate->cfa.offset = 8;\n\n\t \n\tstate->regs[CFI_RA].base = CFI_CFA;\n\tstate->regs[CFI_RA].offset = -8;\n}\n\nconst char *arch_nop_insn(int len)\n{\n\tstatic const char nops[5][5] = {\n\t\t{ BYTES_NOP1 },\n\t\t{ BYTES_NOP2 },\n\t\t{ BYTES_NOP3 },\n\t\t{ BYTES_NOP4 },\n\t\t{ BYTES_NOP5 },\n\t};\n\n\tif (len < 1 || len > 5) {\n\t\tWARN(\"invalid NOP size: %d\\n\", len);\n\t\treturn NULL;\n\t}\n\n\treturn nops[len-1];\n}\n\n#define BYTE_RET\t0xC3\n\nconst char *arch_ret_insn(int len)\n{\n\tstatic const char ret[5][5] = {\n\t\t{ BYTE_RET },\n\t\t{ BYTE_RET, 0xcc },\n\t\t{ BYTE_RET, 0xcc, BYTES_NOP1 },\n\t\t{ BYTE_RET, 0xcc, BYTES_NOP2 },\n\t\t{ BYTE_RET, 0xcc, BYTES_NOP3 },\n\t};\n\n\tif (len < 1 || len > 5) {\n\t\tWARN(\"invalid RET size: %d\\n\", len);\n\t\treturn NULL;\n\t}\n\n\treturn ret[len-1];\n}\n\nint arch_decode_hint_reg(u8 sp_reg, int *base)\n{\n\tswitch (sp_reg) {\n\tcase ORC_REG_UNDEFINED:\n\t\t*base = CFI_UNDEFINED;\n\t\tbreak;\n\tcase ORC_REG_SP:\n\t\t*base = CFI_SP;\n\t\tbreak;\n\tcase ORC_REG_BP:\n\t\t*base = CFI_BP;\n\t\tbreak;\n\tcase ORC_REG_SP_INDIRECT:\n\t\t*base = CFI_SP_INDIRECT;\n\t\tbreak;\n\tcase ORC_REG_R10:\n\t\t*base = CFI_R10;\n\t\tbreak;\n\tcase ORC_REG_R13:\n\t\t*base = CFI_R13;\n\t\tbreak;\n\tcase ORC_REG_DI:\n\t\t*base = CFI_DI;\n\t\tbreak;\n\tcase ORC_REG_DX:\n\t\t*base = CFI_DX;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nbool arch_is_retpoline(struct symbol *sym)\n{\n\treturn !strncmp(sym->name, \"__x86_indirect_\", 15);\n}\n\nbool arch_is_rethunk(struct symbol *sym)\n{\n\treturn !strcmp(sym->name, \"__x86_return_thunk\");\n}\n\nbool arch_is_embedded_insn(struct symbol *sym)\n{\n\treturn !strcmp(sym->name, \"retbleed_return_thunk\") ||\n\t       !strcmp(sym->name, \"srso_safe_ret\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}