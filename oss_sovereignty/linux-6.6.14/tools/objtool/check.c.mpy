{
  "module_name": "check.c",
  "hash_id": "3e6c2b13820ca1554946e71ae9330fe2bfee1e692d8c8dce927578226ad4c177",
  "original_prompt": "Ingested from linux-6.6.14/tools/objtool/check.c",
  "human_readable_source": "\n \n\n#include <string.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <sys/mman.h>\n\n#include <objtool/builtin.h>\n#include <objtool/cfi.h>\n#include <objtool/arch.h>\n#include <objtool/check.h>\n#include <objtool/special.h>\n#include <objtool/warn.h>\n#include <objtool/endianness.h>\n\n#include <linux/objtool_types.h>\n#include <linux/hashtable.h>\n#include <linux/kernel.h>\n#include <linux/static_call_types.h>\n\nstruct alternative {\n\tstruct alternative *next;\n\tstruct instruction *insn;\n\tbool skip_orig;\n};\n\nstatic unsigned long nr_cfi, nr_cfi_reused, nr_cfi_cache;\n\nstatic struct cfi_init_state initial_func_cfi;\nstatic struct cfi_state init_cfi;\nstatic struct cfi_state func_cfi;\nstatic struct cfi_state force_undefined_cfi;\n\nstruct instruction *find_insn(struct objtool_file *file,\n\t\t\t      struct section *sec, unsigned long offset)\n{\n\tstruct instruction *insn;\n\n\thash_for_each_possible(file->insn_hash, insn, hash, sec_offset_hash(sec, offset)) {\n\t\tif (insn->sec == sec && insn->offset == offset)\n\t\t\treturn insn;\n\t}\n\n\treturn NULL;\n}\n\nstruct instruction *next_insn_same_sec(struct objtool_file *file,\n\t\t\t\t       struct instruction *insn)\n{\n\tif (insn->idx == INSN_CHUNK_MAX)\n\t\treturn find_insn(file, insn->sec, insn->offset + insn->len);\n\n\tinsn++;\n\tif (!insn->len)\n\t\treturn NULL;\n\n\treturn insn;\n}\n\nstatic struct instruction *next_insn_same_func(struct objtool_file *file,\n\t\t\t\t\t       struct instruction *insn)\n{\n\tstruct instruction *next = next_insn_same_sec(file, insn);\n\tstruct symbol *func = insn_func(insn);\n\n\tif (!func)\n\t\treturn NULL;\n\n\tif (next && insn_func(next) == func)\n\t\treturn next;\n\n\t \n\tif (func == func->cfunc)\n\t\treturn NULL;\n\n\t \n\treturn find_insn(file, func->cfunc->sec, func->cfunc->offset);\n}\n\nstatic struct instruction *prev_insn_same_sec(struct objtool_file *file,\n\t\t\t\t\t      struct instruction *insn)\n{\n\tif (insn->idx == 0) {\n\t\tif (insn->prev_len)\n\t\t\treturn find_insn(file, insn->sec, insn->offset - insn->prev_len);\n\t\treturn NULL;\n\t}\n\n\treturn insn - 1;\n}\n\nstatic struct instruction *prev_insn_same_sym(struct objtool_file *file,\n\t\t\t\t\t      struct instruction *insn)\n{\n\tstruct instruction *prev = prev_insn_same_sec(file, insn);\n\n\tif (prev && insn_func(prev) == insn_func(insn))\n\t\treturn prev;\n\n\treturn NULL;\n}\n\n#define for_each_insn(file, insn)\t\t\t\t\t\\\n\tfor (struct section *__sec, *__fake = (struct section *)1;\t\\\n\t     __fake; __fake = NULL)\t\t\t\t\t\\\n\t\tfor_each_sec(file, __sec)\t\t\t\t\\\n\t\t\tsec_for_each_insn(file, __sec, insn)\n\n#define func_for_each_insn(file, func, insn)\t\t\t\t\\\n\tfor (insn = find_insn(file, func->sec, func->offset);\t\t\\\n\t     insn;\t\t\t\t\t\t\t\\\n\t     insn = next_insn_same_func(file, insn))\n\n#define sym_for_each_insn(file, sym, insn)\t\t\t\t\\\n\tfor (insn = find_insn(file, sym->sec, sym->offset);\t\t\\\n\t     insn && insn->offset < sym->offset + sym->len;\t\t\\\n\t     insn = next_insn_same_sec(file, insn))\n\n#define sym_for_each_insn_continue_reverse(file, sym, insn)\t\t\\\n\tfor (insn = prev_insn_same_sec(file, insn);\t\t\t\\\n\t     insn && insn->offset >= sym->offset;\t\t\t\\\n\t     insn = prev_insn_same_sec(file, insn))\n\n#define sec_for_each_insn_from(file, insn)\t\t\t\t\\\n\tfor (; insn; insn = next_insn_same_sec(file, insn))\n\n#define sec_for_each_insn_continue(file, insn)\t\t\t\t\\\n\tfor (insn = next_insn_same_sec(file, insn); insn;\t\t\\\n\t     insn = next_insn_same_sec(file, insn))\n\nstatic inline struct symbol *insn_call_dest(struct instruction *insn)\n{\n\tif (insn->type == INSN_JUMP_DYNAMIC ||\n\t    insn->type == INSN_CALL_DYNAMIC)\n\t\treturn NULL;\n\n\treturn insn->_call_dest;\n}\n\nstatic inline struct reloc *insn_jump_table(struct instruction *insn)\n{\n\tif (insn->type == INSN_JUMP_DYNAMIC ||\n\t    insn->type == INSN_CALL_DYNAMIC)\n\t\treturn insn->_jump_table;\n\n\treturn NULL;\n}\n\nstatic bool is_jump_table_jump(struct instruction *insn)\n{\n\tstruct alt_group *alt_group = insn->alt_group;\n\n\tif (insn_jump_table(insn))\n\t\treturn true;\n\n\t \n\treturn alt_group && alt_group->orig_group &&\n\t       insn_jump_table(alt_group->orig_group->first_insn);\n}\n\nstatic bool is_sibling_call(struct instruction *insn)\n{\n\t \n\tif (insn_func(insn)) {\n\t\t \n\t\tif (insn->type == INSN_JUMP_DYNAMIC)\n\t\t\treturn !is_jump_table_jump(insn);\n\t}\n\n\t \n\treturn (is_static_jump(insn) && insn_call_dest(insn));\n}\n\n \nstatic bool __dead_end_function(struct objtool_file *file, struct symbol *func,\n\t\t\t\tint recursion)\n{\n\tint i;\n\tstruct instruction *insn;\n\tbool empty = true;\n\n#define NORETURN(func) __stringify(func),\n\tstatic const char * const global_noreturns[] = {\n#include \"noreturns.h\"\n\t};\n#undef NORETURN\n\n\tif (!func)\n\t\treturn false;\n\n\tif (func->bind == STB_GLOBAL || func->bind == STB_WEAK)\n\t\tfor (i = 0; i < ARRAY_SIZE(global_noreturns); i++)\n\t\t\tif (!strcmp(func->name, global_noreturns[i]))\n\t\t\t\treturn true;\n\n\tif (func->bind == STB_WEAK)\n\t\treturn false;\n\n\tif (!func->len)\n\t\treturn false;\n\n\tinsn = find_insn(file, func->sec, func->offset);\n\tif (!insn || !insn_func(insn))\n\t\treturn false;\n\n\tfunc_for_each_insn(file, func, insn) {\n\t\tempty = false;\n\n\t\tif (insn->type == INSN_RETURN)\n\t\t\treturn false;\n\t}\n\n\tif (empty)\n\t\treturn false;\n\n\t \n\tfunc_for_each_insn(file, func, insn) {\n\t\tif (is_sibling_call(insn)) {\n\t\t\tstruct instruction *dest = insn->jump_dest;\n\n\t\t\tif (!dest)\n\t\t\t\t \n\t\t\t\treturn false;\n\n\t\t\t \n\t\t\tif (recursion == 5) {\n\t\t\t\t \n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn __dead_end_function(file, insn_func(dest), recursion+1);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool dead_end_function(struct objtool_file *file, struct symbol *func)\n{\n\treturn __dead_end_function(file, func, 0);\n}\n\nstatic void init_cfi_state(struct cfi_state *cfi)\n{\n\tint i;\n\n\tfor (i = 0; i < CFI_NUM_REGS; i++) {\n\t\tcfi->regs[i].base = CFI_UNDEFINED;\n\t\tcfi->vals[i].base = CFI_UNDEFINED;\n\t}\n\tcfi->cfa.base = CFI_UNDEFINED;\n\tcfi->drap_reg = CFI_UNDEFINED;\n\tcfi->drap_offset = -1;\n}\n\nstatic void init_insn_state(struct objtool_file *file, struct insn_state *state,\n\t\t\t    struct section *sec)\n{\n\tmemset(state, 0, sizeof(*state));\n\tinit_cfi_state(&state->cfi);\n\n\t \n\tif (opts.link && opts.noinstr && sec)\n\t\tstate->noinstr = sec->noinstr;\n}\n\nstatic struct cfi_state *cfi_alloc(void)\n{\n\tstruct cfi_state *cfi = calloc(sizeof(struct cfi_state), 1);\n\tif (!cfi) {\n\t\tWARN(\"calloc failed\");\n\t\texit(1);\n\t}\n\tnr_cfi++;\n\treturn cfi;\n}\n\nstatic int cfi_bits;\nstatic struct hlist_head *cfi_hash;\n\nstatic inline bool cficmp(struct cfi_state *cfi1, struct cfi_state *cfi2)\n{\n\treturn memcmp((void *)cfi1 + sizeof(cfi1->hash),\n\t\t      (void *)cfi2 + sizeof(cfi2->hash),\n\t\t      sizeof(struct cfi_state) - sizeof(struct hlist_node));\n}\n\nstatic inline u32 cfi_key(struct cfi_state *cfi)\n{\n\treturn jhash((void *)cfi + sizeof(cfi->hash),\n\t\t     sizeof(*cfi) - sizeof(cfi->hash), 0);\n}\n\nstatic struct cfi_state *cfi_hash_find_or_add(struct cfi_state *cfi)\n{\n\tstruct hlist_head *head = &cfi_hash[hash_min(cfi_key(cfi), cfi_bits)];\n\tstruct cfi_state *obj;\n\n\thlist_for_each_entry(obj, head, hash) {\n\t\tif (!cficmp(cfi, obj)) {\n\t\t\tnr_cfi_cache++;\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\tobj = cfi_alloc();\n\t*obj = *cfi;\n\thlist_add_head(&obj->hash, head);\n\n\treturn obj;\n}\n\nstatic void cfi_hash_add(struct cfi_state *cfi)\n{\n\tstruct hlist_head *head = &cfi_hash[hash_min(cfi_key(cfi), cfi_bits)];\n\n\thlist_add_head(&cfi->hash, head);\n}\n\nstatic void *cfi_hash_alloc(unsigned long size)\n{\n\tcfi_bits = max(10, ilog2(size));\n\tcfi_hash = mmap(NULL, sizeof(struct hlist_head) << cfi_bits,\n\t\t\tPROT_READ|PROT_WRITE,\n\t\t\tMAP_PRIVATE|MAP_ANON, -1, 0);\n\tif (cfi_hash == (void *)-1L) {\n\t\tWARN(\"mmap fail cfi_hash\");\n\t\tcfi_hash = NULL;\n\t}  else if (opts.stats) {\n\t\tprintf(\"cfi_bits: %d\\n\", cfi_bits);\n\t}\n\n\treturn cfi_hash;\n}\n\nstatic unsigned long nr_insns;\nstatic unsigned long nr_insns_visited;\n\n \nstatic int decode_instructions(struct objtool_file *file)\n{\n\tstruct section *sec;\n\tstruct symbol *func;\n\tunsigned long offset;\n\tstruct instruction *insn;\n\tint ret;\n\n\tfor_each_sec(file, sec) {\n\t\tstruct instruction *insns = NULL;\n\t\tu8 prev_len = 0;\n\t\tu8 idx = 0;\n\n\t\tif (!(sec->sh.sh_flags & SHF_EXECINSTR))\n\t\t\tcontinue;\n\n\t\tif (strcmp(sec->name, \".altinstr_replacement\") &&\n\t\t    strcmp(sec->name, \".altinstr_aux\") &&\n\t\t    strncmp(sec->name, \".discard.\", 9))\n\t\t\tsec->text = true;\n\n\t\tif (!strcmp(sec->name, \".noinstr.text\") ||\n\t\t    !strcmp(sec->name, \".entry.text\") ||\n\t\t    !strcmp(sec->name, \".cpuidle.text\") ||\n\t\t    !strncmp(sec->name, \".text..__x86.\", 13))\n\t\t\tsec->noinstr = true;\n\n\t\t \n\t\tif (!strcmp(sec->name, \".init.text\") && !opts.module)\n\t\t\tsec->init = true;\n\n\t\tfor (offset = 0; offset < sec->sh.sh_size; offset += insn->len) {\n\t\t\tif (!insns || idx == INSN_CHUNK_MAX) {\n\t\t\t\tinsns = calloc(sizeof(*insn), INSN_CHUNK_SIZE);\n\t\t\t\tif (!insns) {\n\t\t\t\t\tWARN(\"malloc failed\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tidx = 0;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tinsn = &insns[idx];\n\t\t\tinsn->idx = idx;\n\n\t\t\tINIT_LIST_HEAD(&insn->call_node);\n\t\t\tinsn->sec = sec;\n\t\t\tinsn->offset = offset;\n\t\t\tinsn->prev_len = prev_len;\n\n\t\t\tret = arch_decode_instruction(file, sec, offset,\n\t\t\t\t\t\t      sec->sh.sh_size - offset,\n\t\t\t\t\t\t      insn);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tprev_len = insn->len;\n\n\t\t\t \n\t\t\tif (insn->type == INSN_BUG)\n\t\t\t\tinsn->dead_end = true;\n\n\t\t\thash_add(file->insn_hash, &insn->hash, sec_offset_hash(sec, insn->offset));\n\t\t\tnr_insns++;\n\t\t}\n\n \n\n\t\tsec_for_each_sym(sec, func) {\n\t\t\tif (func->type != STT_NOTYPE && func->type != STT_FUNC)\n\t\t\t\tcontinue;\n\n\t\t\tif (func->offset == sec->sh.sh_size) {\n\t\t\t\t \n\t\t\t\tif (func->type == STT_NOTYPE)\n\t\t\t\t\tcontinue;\n\t\t\t\tWARN(\"%s(): STT_FUNC at end of section\",\n\t\t\t\t     func->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (func->embedded_insn || func->alias != func)\n\t\t\t\tcontinue;\n\n\t\t\tif (!find_insn(file, sec, func->offset)) {\n\t\t\t\tWARN(\"%s(): can't find starting instruction\",\n\t\t\t\t     func->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tsym_for_each_insn(file, func, insn) {\n\t\t\t\tinsn->sym = func;\n\t\t\t\tif (func->type == STT_FUNC &&\n\t\t\t\t    insn->type == INSN_ENDBR &&\n\t\t\t\t    list_empty(&insn->call_node)) {\n\t\t\t\t\tif (insn->offset == func->offset) {\n\t\t\t\t\t\tlist_add_tail(&insn->call_node, &file->endbr_list);\n\t\t\t\t\t\tfile->nr_endbr++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfile->nr_endbr_int++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (opts.stats)\n\t\tprintf(\"nr_insns: %lu\\n\", nr_insns);\n\n\treturn 0;\n}\n\n \nstatic int add_pv_ops(struct objtool_file *file, const char *symname)\n{\n\tstruct symbol *sym, *func;\n\tunsigned long off, end;\n\tstruct reloc *reloc;\n\tint idx;\n\n\tsym = find_symbol_by_name(file->elf, symname);\n\tif (!sym)\n\t\treturn 0;\n\n\toff = sym->offset;\n\tend = off + sym->len;\n\tfor (;;) {\n\t\treloc = find_reloc_by_dest_range(file->elf, sym->sec, off, end - off);\n\t\tif (!reloc)\n\t\t\tbreak;\n\n\t\tfunc = reloc->sym;\n\t\tif (func->type == STT_SECTION)\n\t\t\tfunc = find_symbol_by_offset(reloc->sym->sec,\n\t\t\t\t\t\t     reloc_addend(reloc));\n\n\t\tidx = (reloc_offset(reloc) - sym->offset) / sizeof(unsigned long);\n\n\t\tobjtool_pv_add(file, idx, func);\n\n\t\toff = reloc_offset(reloc) + 1;\n\t\tif (off > end)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int init_pv_ops(struct objtool_file *file)\n{\n\tstatic const char *pv_ops_tables[] = {\n\t\t\"pv_ops\",\n\t\t\"xen_cpu_ops\",\n\t\t\"xen_irq_ops\",\n\t\t\"xen_mmu_ops\",\n\t\tNULL,\n\t};\n\tconst char *pv_ops;\n\tstruct symbol *sym;\n\tint idx, nr;\n\n\tif (!opts.noinstr)\n\t\treturn 0;\n\n\tfile->pv_ops = NULL;\n\n\tsym = find_symbol_by_name(file->elf, \"pv_ops\");\n\tif (!sym)\n\t\treturn 0;\n\n\tnr = sym->len / sizeof(unsigned long);\n\tfile->pv_ops = calloc(sizeof(struct pv_state), nr);\n\tif (!file->pv_ops)\n\t\treturn -1;\n\n\tfor (idx = 0; idx < nr; idx++)\n\t\tINIT_LIST_HEAD(&file->pv_ops[idx].targets);\n\n\tfor (idx = 0; (pv_ops = pv_ops_tables[idx]); idx++)\n\t\tadd_pv_ops(file, pv_ops);\n\n\treturn 0;\n}\n\nstatic struct instruction *find_last_insn(struct objtool_file *file,\n\t\t\t\t\t  struct section *sec)\n{\n\tstruct instruction *insn = NULL;\n\tunsigned int offset;\n\tunsigned int end = (sec->sh.sh_size > 10) ? sec->sh.sh_size - 10 : 0;\n\n\tfor (offset = sec->sh.sh_size - 1; offset >= end && !insn; offset--)\n\t\tinsn = find_insn(file, sec, offset);\n\n\treturn insn;\n}\n\n \nstatic int add_dead_ends(struct objtool_file *file)\n{\n\tstruct section *rsec;\n\tstruct reloc *reloc;\n\tstruct instruction *insn;\n\ts64 addend;\n\n\t \n\trsec = find_section_by_name(file->elf, \".rela.discard.unreachable\");\n\tif (!rsec)\n\t\tgoto reachable;\n\n\tfor_each_reloc(rsec, reloc) {\n\n\t\tif (reloc->sym->type != STT_SECTION) {\n\t\t\tWARN(\"unexpected relocation symbol type in %s\", rsec->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\taddend = reloc_addend(reloc);\n\n\t\tinsn = find_insn(file, reloc->sym->sec, addend);\n\t\tif (insn)\n\t\t\tinsn = prev_insn_same_sec(file, insn);\n\t\telse if (addend == reloc->sym->sec->sh.sh_size) {\n\t\t\tinsn = find_last_insn(file, reloc->sym->sec);\n\t\t\tif (!insn) {\n\t\t\t\tWARN(\"can't find unreachable insn at %s+0x%\" PRIx64,\n\t\t\t\t     reloc->sym->sec->name, addend);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tWARN(\"can't find unreachable insn at %s+0x%\" PRIx64,\n\t\t\t     reloc->sym->sec->name, addend);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn->dead_end = true;\n\t}\n\nreachable:\n\t \n\trsec = find_section_by_name(file->elf, \".rela.discard.reachable\");\n\tif (!rsec)\n\t\treturn 0;\n\n\tfor_each_reloc(rsec, reloc) {\n\n\t\tif (reloc->sym->type != STT_SECTION) {\n\t\t\tWARN(\"unexpected relocation symbol type in %s\", rsec->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\taddend = reloc_addend(reloc);\n\n\t\tinsn = find_insn(file, reloc->sym->sec, addend);\n\t\tif (insn)\n\t\t\tinsn = prev_insn_same_sec(file, insn);\n\t\telse if (addend == reloc->sym->sec->sh.sh_size) {\n\t\t\tinsn = find_last_insn(file, reloc->sym->sec);\n\t\t\tif (!insn) {\n\t\t\t\tWARN(\"can't find reachable insn at %s+0x%\" PRIx64,\n\t\t\t\t     reloc->sym->sec->name, addend);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tWARN(\"can't find reachable insn at %s+0x%\" PRIx64,\n\t\t\t     reloc->sym->sec->name, addend);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn->dead_end = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_static_call_sections(struct objtool_file *file)\n{\n\tstruct static_call_site *site;\n\tstruct section *sec;\n\tstruct instruction *insn;\n\tstruct symbol *key_sym;\n\tchar *key_name, *tmp;\n\tint idx;\n\n\tsec = find_section_by_name(file->elf, \".static_call_sites\");\n\tif (sec) {\n\t\tINIT_LIST_HEAD(&file->static_call_list);\n\t\tWARN(\"file already has .static_call_sites section, skipping\");\n\t\treturn 0;\n\t}\n\n\tif (list_empty(&file->static_call_list))\n\t\treturn 0;\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->static_call_list, call_node)\n\t\tidx++;\n\n\tsec = elf_create_section_pair(file->elf, \".static_call_sites\",\n\t\t\t\t      sizeof(*site), idx, idx * 2);\n\tif (!sec)\n\t\treturn -1;\n\n\t \n\tsec->sh.sh_flags |= SHF_WRITE;\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->static_call_list, call_node) {\n\n\t\t \n\t\tif (!elf_init_reloc_text_sym(file->elf, sec,\n\t\t\t\t\t     idx * sizeof(*site), idx * 2,\n\t\t\t\t\t     insn->sec, insn->offset))\n\t\t\treturn -1;\n\n\t\t \n\t\tkey_name = strdup(insn_call_dest(insn)->name);\n\t\tif (!key_name) {\n\t\t\tperror(\"strdup\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (strncmp(key_name, STATIC_CALL_TRAMP_PREFIX_STR,\n\t\t\t    STATIC_CALL_TRAMP_PREFIX_LEN)) {\n\t\t\tWARN(\"static_call: trampoline name malformed: %s\", key_name);\n\t\t\tfree(key_name);\n\t\t\treturn -1;\n\t\t}\n\t\ttmp = key_name + STATIC_CALL_TRAMP_PREFIX_LEN - STATIC_CALL_KEY_PREFIX_LEN;\n\t\tmemcpy(tmp, STATIC_CALL_KEY_PREFIX_STR, STATIC_CALL_KEY_PREFIX_LEN);\n\n\t\tkey_sym = find_symbol_by_name(file->elf, tmp);\n\t\tif (!key_sym) {\n\t\t\tif (!opts.module) {\n\t\t\t\tWARN(\"static_call: can't find static_call_key symbol: %s\", tmp);\n\t\t\t\tfree(key_name);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t \n\t\t\tkey_sym = insn_call_dest(insn);\n\t\t}\n\t\tfree(key_name);\n\n\t\t \n\t\tif (!elf_init_reloc_data_sym(file->elf, sec,\n\t\t\t\t\t     idx * sizeof(*site) + 4,\n\t\t\t\t\t     (idx * 2) + 1, key_sym,\n\t\t\t\t\t     is_sibling_call(insn) * STATIC_CALL_SITE_TAIL))\n\t\t\treturn -1;\n\n\t\tidx++;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_retpoline_sites_sections(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tstruct section *sec;\n\tint idx;\n\n\tsec = find_section_by_name(file->elf, \".retpoline_sites\");\n\tif (sec) {\n\t\tWARN(\"file already has .retpoline_sites, skipping\");\n\t\treturn 0;\n\t}\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->retpoline_call_list, call_node)\n\t\tidx++;\n\n\tif (!idx)\n\t\treturn 0;\n\n\tsec = elf_create_section_pair(file->elf, \".retpoline_sites\",\n\t\t\t\t      sizeof(int), idx, idx);\n\tif (!sec)\n\t\treturn -1;\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->retpoline_call_list, call_node) {\n\n\t\tif (!elf_init_reloc_text_sym(file->elf, sec,\n\t\t\t\t\t     idx * sizeof(int), idx,\n\t\t\t\t\t     insn->sec, insn->offset))\n\t\t\treturn -1;\n\n\t\tidx++;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_return_sites_sections(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tstruct section *sec;\n\tint idx;\n\n\tsec = find_section_by_name(file->elf, \".return_sites\");\n\tif (sec) {\n\t\tWARN(\"file already has .return_sites, skipping\");\n\t\treturn 0;\n\t}\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->return_thunk_list, call_node)\n\t\tidx++;\n\n\tif (!idx)\n\t\treturn 0;\n\n\tsec = elf_create_section_pair(file->elf, \".return_sites\",\n\t\t\t\t      sizeof(int), idx, idx);\n\tif (!sec)\n\t\treturn -1;\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->return_thunk_list, call_node) {\n\n\t\tif (!elf_init_reloc_text_sym(file->elf, sec,\n\t\t\t\t\t     idx * sizeof(int), idx,\n\t\t\t\t\t     insn->sec, insn->offset))\n\t\t\treturn -1;\n\n\t\tidx++;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_ibt_endbr_seal_sections(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tstruct section *sec;\n\tint idx;\n\n\tsec = find_section_by_name(file->elf, \".ibt_endbr_seal\");\n\tif (sec) {\n\t\tWARN(\"file already has .ibt_endbr_seal, skipping\");\n\t\treturn 0;\n\t}\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->endbr_list, call_node)\n\t\tidx++;\n\n\tif (opts.stats) {\n\t\tprintf(\"ibt: ENDBR at function start: %d\\n\", file->nr_endbr);\n\t\tprintf(\"ibt: ENDBR inside functions:  %d\\n\", file->nr_endbr_int);\n\t\tprintf(\"ibt: superfluous ENDBR:       %d\\n\", idx);\n\t}\n\n\tif (!idx)\n\t\treturn 0;\n\n\tsec = elf_create_section_pair(file->elf, \".ibt_endbr_seal\",\n\t\t\t\t      sizeof(int), idx, idx);\n\tif (!sec)\n\t\treturn -1;\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->endbr_list, call_node) {\n\n\t\tint *site = (int *)sec->data->d_buf + idx;\n\t\tstruct symbol *sym = insn->sym;\n\t\t*site = 0;\n\n\t\tif (opts.module && sym && sym->type == STT_FUNC &&\n\t\t    insn->offset == sym->offset &&\n\t\t    (!strcmp(sym->name, \"init_module\") ||\n\t\t     !strcmp(sym->name, \"cleanup_module\")))\n\t\t\tWARN(\"%s(): not an indirect call target\", sym->name);\n\n\t\tif (!elf_init_reloc_text_sym(file->elf, sec,\n\t\t\t\t\t     idx * sizeof(int), idx,\n\t\t\t\t\t     insn->sec, insn->offset))\n\t\t\treturn -1;\n\n\t\tidx++;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_cfi_sections(struct objtool_file *file)\n{\n\tstruct section *sec;\n\tstruct symbol *sym;\n\tint idx;\n\n\tsec = find_section_by_name(file->elf, \".cfi_sites\");\n\tif (sec) {\n\t\tINIT_LIST_HEAD(&file->call_list);\n\t\tWARN(\"file already has .cfi_sites section, skipping\");\n\t\treturn 0;\n\t}\n\n\tidx = 0;\n\tfor_each_sym(file, sym) {\n\t\tif (sym->type != STT_FUNC)\n\t\t\tcontinue;\n\n\t\tif (strncmp(sym->name, \"__cfi_\", 6))\n\t\t\tcontinue;\n\n\t\tidx++;\n\t}\n\n\tsec = elf_create_section_pair(file->elf, \".cfi_sites\",\n\t\t\t\t      sizeof(unsigned int), idx, idx);\n\tif (!sec)\n\t\treturn -1;\n\n\tidx = 0;\n\tfor_each_sym(file, sym) {\n\t\tif (sym->type != STT_FUNC)\n\t\t\tcontinue;\n\n\t\tif (strncmp(sym->name, \"__cfi_\", 6))\n\t\t\tcontinue;\n\n\t\tif (!elf_init_reloc_text_sym(file->elf, sec,\n\t\t\t\t\t     idx * sizeof(unsigned int), idx,\n\t\t\t\t\t     sym->sec, sym->offset))\n\t\t\treturn -1;\n\n\t\tidx++;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_mcount_loc_sections(struct objtool_file *file)\n{\n\tsize_t addr_size = elf_addr_size(file->elf);\n\tstruct instruction *insn;\n\tstruct section *sec;\n\tint idx;\n\n\tsec = find_section_by_name(file->elf, \"__mcount_loc\");\n\tif (sec) {\n\t\tINIT_LIST_HEAD(&file->mcount_loc_list);\n\t\tWARN(\"file already has __mcount_loc section, skipping\");\n\t\treturn 0;\n\t}\n\n\tif (list_empty(&file->mcount_loc_list))\n\t\treturn 0;\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->mcount_loc_list, call_node)\n\t\tidx++;\n\n\tsec = elf_create_section_pair(file->elf, \"__mcount_loc\", addr_size,\n\t\t\t\t      idx, idx);\n\tif (!sec)\n\t\treturn -1;\n\n\tsec->sh.sh_addralign = addr_size;\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->mcount_loc_list, call_node) {\n\n\t\tstruct reloc *reloc;\n\n\t\treloc = elf_init_reloc_text_sym(file->elf, sec, idx * addr_size, idx,\n\t\t\t\t\t       insn->sec, insn->offset);\n\t\tif (!reloc)\n\t\t\treturn -1;\n\n\t\tset_reloc_type(file->elf, reloc, addr_size == 8 ? R_ABS64 : R_ABS32);\n\n\t\tidx++;\n\t}\n\n\treturn 0;\n}\n\nstatic int create_direct_call_sections(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tstruct section *sec;\n\tint idx;\n\n\tsec = find_section_by_name(file->elf, \".call_sites\");\n\tif (sec) {\n\t\tINIT_LIST_HEAD(&file->call_list);\n\t\tWARN(\"file already has .call_sites section, skipping\");\n\t\treturn 0;\n\t}\n\n\tif (list_empty(&file->call_list))\n\t\treturn 0;\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->call_list, call_node)\n\t\tidx++;\n\n\tsec = elf_create_section_pair(file->elf, \".call_sites\",\n\t\t\t\t      sizeof(unsigned int), idx, idx);\n\tif (!sec)\n\t\treturn -1;\n\n\tidx = 0;\n\tlist_for_each_entry(insn, &file->call_list, call_node) {\n\n\t\tif (!elf_init_reloc_text_sym(file->elf, sec,\n\t\t\t\t\t     idx * sizeof(unsigned int), idx,\n\t\t\t\t\t     insn->sec, insn->offset))\n\t\t\treturn -1;\n\n\t\tidx++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void add_ignores(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tstruct section *rsec;\n\tstruct symbol *func;\n\tstruct reloc *reloc;\n\n\trsec = find_section_by_name(file->elf, \".rela.discard.func_stack_frame_non_standard\");\n\tif (!rsec)\n\t\treturn;\n\n\tfor_each_reloc(rsec, reloc) {\n\t\tswitch (reloc->sym->type) {\n\t\tcase STT_FUNC:\n\t\t\tfunc = reloc->sym;\n\t\t\tbreak;\n\n\t\tcase STT_SECTION:\n\t\t\tfunc = find_func_by_offset(reloc->sym->sec, reloc_addend(reloc));\n\t\t\tif (!func)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWARN(\"unexpected relocation symbol type in %s: %d\",\n\t\t\t     rsec->name, reloc->sym->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfunc_for_each_insn(file, func, insn)\n\t\t\tinsn->ignore = true;\n\t}\n}\n\n \nstatic const char *uaccess_safe_builtin[] = {\n\t \n\t\"kasan_report\",\n\t\"kasan_check_range\",\n\t \n\t\"__asan_loadN_noabort\",\n\t\"__asan_load1_noabort\",\n\t\"__asan_load2_noabort\",\n\t\"__asan_load4_noabort\",\n\t\"__asan_load8_noabort\",\n\t\"__asan_load16_noabort\",\n\t\"__asan_storeN_noabort\",\n\t\"__asan_store1_noabort\",\n\t\"__asan_store2_noabort\",\n\t\"__asan_store4_noabort\",\n\t\"__asan_store8_noabort\",\n\t\"__asan_store16_noabort\",\n\t\"__kasan_check_read\",\n\t\"__kasan_check_write\",\n\t \n\t\"__asan_report_load_n_noabort\",\n\t\"__asan_report_load1_noabort\",\n\t\"__asan_report_load2_noabort\",\n\t\"__asan_report_load4_noabort\",\n\t\"__asan_report_load8_noabort\",\n\t\"__asan_report_load16_noabort\",\n\t\"__asan_report_store_n_noabort\",\n\t\"__asan_report_store1_noabort\",\n\t\"__asan_report_store2_noabort\",\n\t\"__asan_report_store4_noabort\",\n\t\"__asan_report_store8_noabort\",\n\t\"__asan_report_store16_noabort\",\n\t \n\t\"__kcsan_check_access\",\n\t\"__kcsan_mb\",\n\t\"__kcsan_wmb\",\n\t\"__kcsan_rmb\",\n\t\"__kcsan_release\",\n\t\"kcsan_found_watchpoint\",\n\t\"kcsan_setup_watchpoint\",\n\t\"kcsan_check_scoped_accesses\",\n\t\"kcsan_disable_current\",\n\t\"kcsan_enable_current_nowarn\",\n\t \n\t\"__tsan_func_entry\",\n\t\"__tsan_func_exit\",\n\t\"__tsan_read_range\",\n\t\"__tsan_write_range\",\n\t\"__tsan_read1\",\n\t\"__tsan_read2\",\n\t\"__tsan_read4\",\n\t\"__tsan_read8\",\n\t\"__tsan_read16\",\n\t\"__tsan_write1\",\n\t\"__tsan_write2\",\n\t\"__tsan_write4\",\n\t\"__tsan_write8\",\n\t\"__tsan_write16\",\n\t\"__tsan_read_write1\",\n\t\"__tsan_read_write2\",\n\t\"__tsan_read_write4\",\n\t\"__tsan_read_write8\",\n\t\"__tsan_read_write16\",\n\t\"__tsan_volatile_read1\",\n\t\"__tsan_volatile_read2\",\n\t\"__tsan_volatile_read4\",\n\t\"__tsan_volatile_read8\",\n\t\"__tsan_volatile_read16\",\n\t\"__tsan_volatile_write1\",\n\t\"__tsan_volatile_write2\",\n\t\"__tsan_volatile_write4\",\n\t\"__tsan_volatile_write8\",\n\t\"__tsan_volatile_write16\",\n\t\"__tsan_atomic8_load\",\n\t\"__tsan_atomic16_load\",\n\t\"__tsan_atomic32_load\",\n\t\"__tsan_atomic64_load\",\n\t\"__tsan_atomic8_store\",\n\t\"__tsan_atomic16_store\",\n\t\"__tsan_atomic32_store\",\n\t\"__tsan_atomic64_store\",\n\t\"__tsan_atomic8_exchange\",\n\t\"__tsan_atomic16_exchange\",\n\t\"__tsan_atomic32_exchange\",\n\t\"__tsan_atomic64_exchange\",\n\t\"__tsan_atomic8_fetch_add\",\n\t\"__tsan_atomic16_fetch_add\",\n\t\"__tsan_atomic32_fetch_add\",\n\t\"__tsan_atomic64_fetch_add\",\n\t\"__tsan_atomic8_fetch_sub\",\n\t\"__tsan_atomic16_fetch_sub\",\n\t\"__tsan_atomic32_fetch_sub\",\n\t\"__tsan_atomic64_fetch_sub\",\n\t\"__tsan_atomic8_fetch_and\",\n\t\"__tsan_atomic16_fetch_and\",\n\t\"__tsan_atomic32_fetch_and\",\n\t\"__tsan_atomic64_fetch_and\",\n\t\"__tsan_atomic8_fetch_or\",\n\t\"__tsan_atomic16_fetch_or\",\n\t\"__tsan_atomic32_fetch_or\",\n\t\"__tsan_atomic64_fetch_or\",\n\t\"__tsan_atomic8_fetch_xor\",\n\t\"__tsan_atomic16_fetch_xor\",\n\t\"__tsan_atomic32_fetch_xor\",\n\t\"__tsan_atomic64_fetch_xor\",\n\t\"__tsan_atomic8_fetch_nand\",\n\t\"__tsan_atomic16_fetch_nand\",\n\t\"__tsan_atomic32_fetch_nand\",\n\t\"__tsan_atomic64_fetch_nand\",\n\t\"__tsan_atomic8_compare_exchange_strong\",\n\t\"__tsan_atomic16_compare_exchange_strong\",\n\t\"__tsan_atomic32_compare_exchange_strong\",\n\t\"__tsan_atomic64_compare_exchange_strong\",\n\t\"__tsan_atomic8_compare_exchange_weak\",\n\t\"__tsan_atomic16_compare_exchange_weak\",\n\t\"__tsan_atomic32_compare_exchange_weak\",\n\t\"__tsan_atomic64_compare_exchange_weak\",\n\t\"__tsan_atomic8_compare_exchange_val\",\n\t\"__tsan_atomic16_compare_exchange_val\",\n\t\"__tsan_atomic32_compare_exchange_val\",\n\t\"__tsan_atomic64_compare_exchange_val\",\n\t\"__tsan_atomic_thread_fence\",\n\t\"__tsan_atomic_signal_fence\",\n\t\"__tsan_unaligned_read16\",\n\t\"__tsan_unaligned_write16\",\n\t \n\t\"write_comp_data\",\n\t\"check_kcov_mode\",\n\t\"__sanitizer_cov_trace_pc\",\n\t\"__sanitizer_cov_trace_const_cmp1\",\n\t\"__sanitizer_cov_trace_const_cmp2\",\n\t\"__sanitizer_cov_trace_const_cmp4\",\n\t\"__sanitizer_cov_trace_const_cmp8\",\n\t\"__sanitizer_cov_trace_cmp1\",\n\t\"__sanitizer_cov_trace_cmp2\",\n\t\"__sanitizer_cov_trace_cmp4\",\n\t\"__sanitizer_cov_trace_cmp8\",\n\t\"__sanitizer_cov_trace_switch\",\n\t \n\t\"kmsan_copy_to_user\",\n\t\"kmsan_report\",\n\t\"kmsan_unpoison_entry_regs\",\n\t\"kmsan_unpoison_memory\",\n\t\"__msan_chain_origin\",\n\t\"__msan_get_context_state\",\n\t\"__msan_instrument_asm_store\",\n\t\"__msan_metadata_ptr_for_load_1\",\n\t\"__msan_metadata_ptr_for_load_2\",\n\t\"__msan_metadata_ptr_for_load_4\",\n\t\"__msan_metadata_ptr_for_load_8\",\n\t\"__msan_metadata_ptr_for_load_n\",\n\t\"__msan_metadata_ptr_for_store_1\",\n\t\"__msan_metadata_ptr_for_store_2\",\n\t\"__msan_metadata_ptr_for_store_4\",\n\t\"__msan_metadata_ptr_for_store_8\",\n\t\"__msan_metadata_ptr_for_store_n\",\n\t\"__msan_poison_alloca\",\n\t\"__msan_warning\",\n\t \n\t\"ubsan_type_mismatch_common\",\n\t\"__ubsan_handle_type_mismatch\",\n\t\"__ubsan_handle_type_mismatch_v1\",\n\t\"__ubsan_handle_shift_out_of_bounds\",\n\t\"__ubsan_handle_load_invalid_value\",\n\t \n\t\"stackleak_track_stack\",\n\t \n\t\"csum_partial_copy_generic\",\n\t\"copy_mc_fragile\",\n\t\"copy_mc_fragile_handle_tail\",\n\t\"copy_mc_enhanced_fast_string\",\n\t\"ftrace_likely_update\",  \n\t\"rep_stos_alternative\",\n\t\"rep_movs_alternative\",\n\t\"__copy_user_nocache\",\n\tNULL\n};\n\nstatic void add_uaccess_safe(struct objtool_file *file)\n{\n\tstruct symbol *func;\n\tconst char **name;\n\n\tif (!opts.uaccess)\n\t\treturn;\n\n\tfor (name = uaccess_safe_builtin; *name; name++) {\n\t\tfunc = find_symbol_by_name(file->elf, *name);\n\t\tif (!func)\n\t\t\tcontinue;\n\n\t\tfunc->uaccess_safe = true;\n\t}\n}\n\n \nstatic int add_ignore_alternatives(struct objtool_file *file)\n{\n\tstruct section *rsec;\n\tstruct reloc *reloc;\n\tstruct instruction *insn;\n\n\trsec = find_section_by_name(file->elf, \".rela.discard.ignore_alts\");\n\tif (!rsec)\n\t\treturn 0;\n\n\tfor_each_reloc(rsec, reloc) {\n\t\tif (reloc->sym->type != STT_SECTION) {\n\t\t\tWARN(\"unexpected relocation symbol type in %s\", rsec->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn = find_insn(file, reloc->sym->sec, reloc_addend(reloc));\n\t\tif (!insn) {\n\t\t\tWARN(\"bad .discard.ignore_alts entry\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn->ignore_alts = true;\n\t}\n\n\treturn 0;\n}\n\n \n__weak bool arch_is_retpoline(struct symbol *sym)\n{\n\treturn false;\n}\n\n \n__weak bool arch_is_rethunk(struct symbol *sym)\n{\n\treturn false;\n}\n\n \n__weak bool arch_is_embedded_insn(struct symbol *sym)\n{\n\treturn false;\n}\n\nstatic struct reloc *insn_reloc(struct objtool_file *file, struct instruction *insn)\n{\n\tstruct reloc *reloc;\n\n\tif (insn->no_reloc)\n\t\treturn NULL;\n\n\tif (!file)\n\t\treturn NULL;\n\n\treloc = find_reloc_by_dest_range(file->elf, insn->sec,\n\t\t\t\t\t insn->offset, insn->len);\n\tif (!reloc) {\n\t\tinsn->no_reloc = 1;\n\t\treturn NULL;\n\t}\n\n\treturn reloc;\n}\n\nstatic void remove_insn_ops(struct instruction *insn)\n{\n\tstruct stack_op *op, *next;\n\n\tfor (op = insn->stack_ops; op; op = next) {\n\t\tnext = op->next;\n\t\tfree(op);\n\t}\n\tinsn->stack_ops = NULL;\n}\n\nstatic void annotate_call_site(struct objtool_file *file,\n\t\t\t       struct instruction *insn, bool sibling)\n{\n\tstruct reloc *reloc = insn_reloc(file, insn);\n\tstruct symbol *sym = insn_call_dest(insn);\n\n\tif (!sym)\n\t\tsym = reloc->sym;\n\n\t \n\tif (!strcmp(insn->sec->name, \".altinstr_replacement\"))\n\t\treturn;\n\n\tif (sym->static_call_tramp) {\n\t\tlist_add_tail(&insn->call_node, &file->static_call_list);\n\t\treturn;\n\t}\n\n\tif (sym->retpoline_thunk) {\n\t\tlist_add_tail(&insn->call_node, &file->retpoline_call_list);\n\t\treturn;\n\t}\n\n\t \n\tif (opts.hack_noinstr && insn->sec->noinstr && sym->profiling_func) {\n\t\tif (reloc)\n\t\t\tset_reloc_type(file->elf, reloc, R_NONE);\n\n\t\telf_write_insn(file->elf, insn->sec,\n\t\t\t       insn->offset, insn->len,\n\t\t\t       sibling ? arch_ret_insn(insn->len)\n\t\t\t               : arch_nop_insn(insn->len));\n\n\t\tinsn->type = sibling ? INSN_RETURN : INSN_NOP;\n\n\t\tif (sibling) {\n\t\t\t \n\t\t\tinsn->retpoline_safe = true;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (opts.mcount && sym->fentry) {\n\t\tif (sibling)\n\t\t\tWARN_INSN(insn, \"tail call to __fentry__ !?!?\");\n\t\tif (opts.mnop) {\n\t\t\tif (reloc)\n\t\t\t\tset_reloc_type(file->elf, reloc, R_NONE);\n\n\t\t\telf_write_insn(file->elf, insn->sec,\n\t\t\t\t       insn->offset, insn->len,\n\t\t\t\t       arch_nop_insn(insn->len));\n\n\t\t\tinsn->type = INSN_NOP;\n\t\t}\n\n\t\tlist_add_tail(&insn->call_node, &file->mcount_loc_list);\n\t\treturn;\n\t}\n\n\tif (insn->type == INSN_CALL && !insn->sec->init)\n\t\tlist_add_tail(&insn->call_node, &file->call_list);\n\n\tif (!sibling && dead_end_function(file, sym))\n\t\tinsn->dead_end = true;\n}\n\nstatic void add_call_dest(struct objtool_file *file, struct instruction *insn,\n\t\t\t  struct symbol *dest, bool sibling)\n{\n\tinsn->_call_dest = dest;\n\tif (!dest)\n\t\treturn;\n\n\t \n\tremove_insn_ops(insn);\n\n\tannotate_call_site(file, insn, sibling);\n}\n\nstatic void add_retpoline_call(struct objtool_file *file, struct instruction *insn)\n{\n\t \n\tswitch (insn->type) {\n\tcase INSN_CALL:\n\t\tinsn->type = INSN_CALL_DYNAMIC;\n\t\tbreak;\n\tcase INSN_JUMP_UNCONDITIONAL:\n\t\tinsn->type = INSN_JUMP_DYNAMIC;\n\t\tbreak;\n\tcase INSN_JUMP_CONDITIONAL:\n\t\tinsn->type = INSN_JUMP_DYNAMIC_CONDITIONAL;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tinsn->retpoline_safe = true;\n\n\t \n\tremove_insn_ops(insn);\n\n\tannotate_call_site(file, insn, false);\n}\n\nstatic void add_return_call(struct objtool_file *file, struct instruction *insn, bool add)\n{\n\t \n\tinsn->type = INSN_RETURN;\n\tinsn->retpoline_safe = true;\n\n\tif (add)\n\t\tlist_add_tail(&insn->call_node, &file->return_thunk_list);\n}\n\nstatic bool is_first_func_insn(struct objtool_file *file,\n\t\t\t       struct instruction *insn, struct symbol *sym)\n{\n\tif (insn->offset == sym->offset)\n\t\treturn true;\n\n\t \n\tif (opts.ibt) {\n\t\tstruct instruction *prev = prev_insn_same_sym(file, insn);\n\n\t\tif (prev && prev->type == INSN_ENDBR &&\n\t\t    insn->offset == sym->offset + prev->len)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool jump_is_sibling_call(struct objtool_file *file,\n\t\t\t\t struct instruction *from, struct instruction *to)\n{\n\tstruct symbol *fs = from->sym;\n\tstruct symbol *ts = to->sym;\n\n\t \n\tif (!fs || !ts)\n\t\treturn false;\n\n\t \n\tif (!is_first_func_insn(file, to, ts))\n\t\treturn false;\n\n\t \n\tif (ts->type == STT_NOTYPE)\n\t\treturn false;\n\n\t \n\treturn fs->pfunc != ts->pfunc;\n}\n\n \nstatic int add_jump_destinations(struct objtool_file *file)\n{\n\tstruct instruction *insn, *jump_dest;\n\tstruct reloc *reloc;\n\tstruct section *dest_sec;\n\tunsigned long dest_off;\n\n\tfor_each_insn(file, insn) {\n\t\tif (insn->jump_dest) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_static_jump(insn))\n\t\t\tcontinue;\n\n\t\treloc = insn_reloc(file, insn);\n\t\tif (!reloc) {\n\t\t\tdest_sec = insn->sec;\n\t\t\tdest_off = arch_jump_destination(insn);\n\t\t} else if (reloc->sym->type == STT_SECTION) {\n\t\t\tdest_sec = reloc->sym->sec;\n\t\t\tdest_off = arch_dest_reloc_offset(reloc_addend(reloc));\n\t\t} else if (reloc->sym->retpoline_thunk) {\n\t\t\tadd_retpoline_call(file, insn);\n\t\t\tcontinue;\n\t\t} else if (reloc->sym->return_thunk) {\n\t\t\tadd_return_call(file, insn, true);\n\t\t\tcontinue;\n\t\t} else if (insn_func(insn)) {\n\t\t\t \n\t\t\tadd_call_dest(file, insn, reloc->sym, true);\n\t\t\tcontinue;\n\t\t} else if (reloc->sym->sec->idx) {\n\t\t\tdest_sec = reloc->sym->sec;\n\t\t\tdest_off = reloc->sym->sym.st_value +\n\t\t\t\t   arch_dest_reloc_offset(reloc_addend(reloc));\n\t\t} else {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tjump_dest = find_insn(file, dest_sec, dest_off);\n\t\tif (!jump_dest) {\n\t\t\tstruct symbol *sym = find_symbol_by_offset(dest_sec, dest_off);\n\n\t\t\t \n\t\t\tif (sym && sym->embedded_insn) {\n\t\t\t\tadd_return_call(file, insn, false);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tWARN_INSN(insn, \"can't find jump dest instruction at %s+0x%lx\",\n\t\t\t\t  dest_sec->name, dest_off);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (insn_func(insn) && insn_func(jump_dest) &&\n\t\t    insn_func(insn) != insn_func(jump_dest)) {\n\n\t\t\t \n\t\t\tif (!strstr(insn_func(insn)->name, \".cold\") &&\n\t\t\t    strstr(insn_func(jump_dest)->name, \".cold\")) {\n\t\t\t\tinsn_func(insn)->cfunc = insn_func(jump_dest);\n\t\t\t\tinsn_func(jump_dest)->pfunc = insn_func(insn);\n\t\t\t}\n\t\t}\n\n\t\tif (jump_is_sibling_call(file, insn, jump_dest)) {\n\t\t\t \n\t\t\tadd_call_dest(file, insn, insn_func(jump_dest), true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinsn->jump_dest = jump_dest;\n\t}\n\n\treturn 0;\n}\n\nstatic struct symbol *find_call_destination(struct section *sec, unsigned long offset)\n{\n\tstruct symbol *call_dest;\n\n\tcall_dest = find_func_by_offset(sec, offset);\n\tif (!call_dest)\n\t\tcall_dest = find_symbol_by_offset(sec, offset);\n\n\treturn call_dest;\n}\n\n \nstatic int add_call_destinations(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tunsigned long dest_off;\n\tstruct symbol *dest;\n\tstruct reloc *reloc;\n\n\tfor_each_insn(file, insn) {\n\t\tif (insn->type != INSN_CALL)\n\t\t\tcontinue;\n\n\t\treloc = insn_reloc(file, insn);\n\t\tif (!reloc) {\n\t\t\tdest_off = arch_jump_destination(insn);\n\t\t\tdest = find_call_destination(insn->sec, dest_off);\n\n\t\t\tadd_call_dest(file, insn, dest, false);\n\n\t\t\tif (insn->ignore)\n\t\t\t\tcontinue;\n\n\t\t\tif (!insn_call_dest(insn)) {\n\t\t\t\tWARN_INSN(insn, \"unannotated intra-function call\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (insn_func(insn) && insn_call_dest(insn)->type != STT_FUNC) {\n\t\t\t\tWARN_INSN(insn, \"unsupported call to non-function\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t} else if (reloc->sym->type == STT_SECTION) {\n\t\t\tdest_off = arch_dest_reloc_offset(reloc_addend(reloc));\n\t\t\tdest = find_call_destination(reloc->sym->sec, dest_off);\n\t\t\tif (!dest) {\n\t\t\t\tWARN_INSN(insn, \"can't find call dest symbol at %s+0x%lx\",\n\t\t\t\t\t  reloc->sym->sec->name, dest_off);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tadd_call_dest(file, insn, dest, false);\n\n\t\t} else if (reloc->sym->retpoline_thunk) {\n\t\t\tadd_retpoline_call(file, insn);\n\n\t\t} else\n\t\t\tadd_call_dest(file, insn, reloc->sym, false);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int handle_group_alt(struct objtool_file *file,\n\t\t\t    struct special_alt *special_alt,\n\t\t\t    struct instruction *orig_insn,\n\t\t\t    struct instruction **new_insn)\n{\n\tstruct instruction *last_new_insn = NULL, *insn, *nop = NULL;\n\tstruct alt_group *orig_alt_group, *new_alt_group;\n\tunsigned long dest_off;\n\n\torig_alt_group = orig_insn->alt_group;\n\tif (!orig_alt_group) {\n\t\tstruct instruction *last_orig_insn = NULL;\n\n\t\torig_alt_group = malloc(sizeof(*orig_alt_group));\n\t\tif (!orig_alt_group) {\n\t\t\tWARN(\"malloc failed\");\n\t\t\treturn -1;\n\t\t}\n\t\torig_alt_group->cfi = calloc(special_alt->orig_len,\n\t\t\t\t\t     sizeof(struct cfi_state *));\n\t\tif (!orig_alt_group->cfi) {\n\t\t\tWARN(\"calloc failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn = orig_insn;\n\t\tsec_for_each_insn_from(file, insn) {\n\t\t\tif (insn->offset >= special_alt->orig_off + special_alt->orig_len)\n\t\t\t\tbreak;\n\n\t\t\tinsn->alt_group = orig_alt_group;\n\t\t\tlast_orig_insn = insn;\n\t\t}\n\t\torig_alt_group->orig_group = NULL;\n\t\torig_alt_group->first_insn = orig_insn;\n\t\torig_alt_group->last_insn = last_orig_insn;\n\t\torig_alt_group->nop = NULL;\n\t} else {\n\t\tif (orig_alt_group->last_insn->offset + orig_alt_group->last_insn->len -\n\t\t    orig_alt_group->first_insn->offset != special_alt->orig_len) {\n\t\t\tWARN_INSN(orig_insn, \"weirdly overlapping alternative! %ld != %d\",\n\t\t\t\t  orig_alt_group->last_insn->offset +\n\t\t\t\t  orig_alt_group->last_insn->len -\n\t\t\t\t  orig_alt_group->first_insn->offset,\n\t\t\t\t  special_alt->orig_len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tnew_alt_group = malloc(sizeof(*new_alt_group));\n\tif (!new_alt_group) {\n\t\tWARN(\"malloc failed\");\n\t\treturn -1;\n\t}\n\n\tif (special_alt->new_len < special_alt->orig_len) {\n\t\t \n\t\tnop = malloc(sizeof(*nop));\n\t\tif (!nop) {\n\t\t\tWARN(\"malloc failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(nop, 0, sizeof(*nop));\n\n\t\tnop->sec = special_alt->new_sec;\n\t\tnop->offset = special_alt->new_off + special_alt->new_len;\n\t\tnop->len = special_alt->orig_len - special_alt->new_len;\n\t\tnop->type = INSN_NOP;\n\t\tnop->sym = orig_insn->sym;\n\t\tnop->alt_group = new_alt_group;\n\t\tnop->ignore = orig_insn->ignore_alts;\n\t}\n\n\tif (!special_alt->new_len) {\n\t\t*new_insn = nop;\n\t\tgoto end;\n\t}\n\n\tinsn = *new_insn;\n\tsec_for_each_insn_from(file, insn) {\n\t\tstruct reloc *alt_reloc;\n\n\t\tif (insn->offset >= special_alt->new_off + special_alt->new_len)\n\t\t\tbreak;\n\n\t\tlast_new_insn = insn;\n\n\t\tinsn->ignore = orig_insn->ignore_alts;\n\t\tinsn->sym = orig_insn->sym;\n\t\tinsn->alt_group = new_alt_group;\n\n\t\t \n\t\talt_reloc = insn_reloc(file, insn);\n\t\tif (alt_reloc && arch_pc_relative_reloc(alt_reloc) &&\n\t\t    !arch_support_alt_relocation(special_alt, insn, alt_reloc)) {\n\n\t\t\tWARN_INSN(insn, \"unsupported relocation in alternatives section\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!is_static_jump(insn))\n\t\t\tcontinue;\n\n\t\tif (!insn->immediate)\n\t\t\tcontinue;\n\n\t\tdest_off = arch_jump_destination(insn);\n\t\tif (dest_off == special_alt->new_off + special_alt->new_len) {\n\t\t\tinsn->jump_dest = next_insn_same_sec(file, orig_alt_group->last_insn);\n\t\t\tif (!insn->jump_dest) {\n\t\t\t\tWARN_INSN(insn, \"can't find alternative jump destination\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!last_new_insn) {\n\t\tWARN_FUNC(\"can't find last new alternative instruction\",\n\t\t\t  special_alt->new_sec, special_alt->new_off);\n\t\treturn -1;\n\t}\n\nend:\n\tnew_alt_group->orig_group = orig_alt_group;\n\tnew_alt_group->first_insn = *new_insn;\n\tnew_alt_group->last_insn = last_new_insn;\n\tnew_alt_group->nop = nop;\n\tnew_alt_group->cfi = orig_alt_group->cfi;\n\treturn 0;\n}\n\n \nstatic int handle_jump_alt(struct objtool_file *file,\n\t\t\t   struct special_alt *special_alt,\n\t\t\t   struct instruction *orig_insn,\n\t\t\t   struct instruction **new_insn)\n{\n\tif (orig_insn->type != INSN_JUMP_UNCONDITIONAL &&\n\t    orig_insn->type != INSN_NOP) {\n\n\t\tWARN_INSN(orig_insn, \"unsupported instruction at jump label\");\n\t\treturn -1;\n\t}\n\n\tif (opts.hack_jump_label && special_alt->key_addend & 2) {\n\t\tstruct reloc *reloc = insn_reloc(file, orig_insn);\n\n\t\tif (reloc)\n\t\t\tset_reloc_type(file->elf, reloc, R_NONE);\n\t\telf_write_insn(file->elf, orig_insn->sec,\n\t\t\t       orig_insn->offset, orig_insn->len,\n\t\t\t       arch_nop_insn(orig_insn->len));\n\t\torig_insn->type = INSN_NOP;\n\t}\n\n\tif (orig_insn->type == INSN_NOP) {\n\t\tif (orig_insn->len == 2)\n\t\t\tfile->jl_nop_short++;\n\t\telse\n\t\t\tfile->jl_nop_long++;\n\n\t\treturn 0;\n\t}\n\n\tif (orig_insn->len == 2)\n\t\tfile->jl_short++;\n\telse\n\t\tfile->jl_long++;\n\n\t*new_insn = next_insn_same_sec(file, orig_insn);\n\treturn 0;\n}\n\n \nstatic int add_special_section_alts(struct objtool_file *file)\n{\n\tstruct list_head special_alts;\n\tstruct instruction *orig_insn, *new_insn;\n\tstruct special_alt *special_alt, *tmp;\n\tstruct alternative *alt;\n\tint ret;\n\n\tret = special_get_alts(file->elf, &special_alts);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_for_each_entry_safe(special_alt, tmp, &special_alts, list) {\n\n\t\torig_insn = find_insn(file, special_alt->orig_sec,\n\t\t\t\t      special_alt->orig_off);\n\t\tif (!orig_insn) {\n\t\t\tWARN_FUNC(\"special: can't find orig instruction\",\n\t\t\t\t  special_alt->orig_sec, special_alt->orig_off);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnew_insn = NULL;\n\t\tif (!special_alt->group || special_alt->new_len) {\n\t\t\tnew_insn = find_insn(file, special_alt->new_sec,\n\t\t\t\t\t     special_alt->new_off);\n\t\t\tif (!new_insn) {\n\t\t\t\tWARN_FUNC(\"special: can't find new instruction\",\n\t\t\t\t\t  special_alt->new_sec,\n\t\t\t\t\t  special_alt->new_off);\n\t\t\t\tret = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (special_alt->group) {\n\t\t\tif (!special_alt->orig_len) {\n\t\t\t\tWARN_INSN(orig_insn, \"empty alternative entry\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = handle_group_alt(file, special_alt, orig_insn,\n\t\t\t\t\t       &new_insn);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else if (special_alt->jump_or_nop) {\n\t\t\tret = handle_jump_alt(file, special_alt, orig_insn,\n\t\t\t\t\t      &new_insn);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\talt = malloc(sizeof(*alt));\n\t\tif (!alt) {\n\t\t\tWARN(\"malloc failed\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\talt->insn = new_insn;\n\t\talt->skip_orig = special_alt->skip_orig;\n\t\torig_insn->ignore_alts |= special_alt->skip_alt;\n\t\talt->next = orig_insn->alts;\n\t\torig_insn->alts = alt;\n\n\t\tlist_del(&special_alt->list);\n\t\tfree(special_alt);\n\t}\n\n\tif (opts.stats) {\n\t\tprintf(\"jl\\\\\\tNOP\\tJMP\\n\");\n\t\tprintf(\"short:\\t%ld\\t%ld\\n\", file->jl_nop_short, file->jl_short);\n\t\tprintf(\"long:\\t%ld\\t%ld\\n\", file->jl_nop_long, file->jl_long);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int add_jump_table(struct objtool_file *file, struct instruction *insn,\n\t\t\t  struct reloc *next_table)\n{\n\tstruct symbol *pfunc = insn_func(insn)->pfunc;\n\tstruct reloc *table = insn_jump_table(insn);\n\tstruct instruction *dest_insn;\n\tunsigned int prev_offset = 0;\n\tstruct reloc *reloc = table;\n\tstruct alternative *alt;\n\n\t \n\tfor_each_reloc_from(table->sec, reloc) {\n\n\t\t \n\t\tif (reloc != table && reloc == next_table)\n\t\t\tbreak;\n\n\t\t \n\t\tif (prev_offset && reloc_offset(reloc) != prev_offset + 8)\n\t\t\tbreak;\n\n\t\t \n\t\tif (reloc->sym->sec == pfunc->sec &&\n\t\t    reloc_addend(reloc) == pfunc->offset)\n\t\t\tbreak;\n\n\t\tdest_insn = find_insn(file, reloc->sym->sec, reloc_addend(reloc));\n\t\tif (!dest_insn)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!insn_func(dest_insn) || insn_func(dest_insn)->pfunc != pfunc)\n\t\t\tbreak;\n\n\t\talt = malloc(sizeof(*alt));\n\t\tif (!alt) {\n\t\t\tWARN(\"malloc failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\talt->insn = dest_insn;\n\t\talt->next = insn->alts;\n\t\tinsn->alts = alt;\n\t\tprev_offset = reloc_offset(reloc);\n\t}\n\n\tif (!prev_offset) {\n\t\tWARN_INSN(insn, \"can't find switch jump table\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct reloc *find_jump_table(struct objtool_file *file,\n\t\t\t\t      struct symbol *func,\n\t\t\t\t      struct instruction *insn)\n{\n\tstruct reloc *table_reloc;\n\tstruct instruction *dest_insn, *orig_insn = insn;\n\n\t \n\tfor (;\n\t     insn && insn_func(insn) && insn_func(insn)->pfunc == func;\n\t     insn = insn->first_jump_src ?: prev_insn_same_sym(file, insn)) {\n\n\t\tif (insn != orig_insn && insn->type == INSN_JUMP_DYNAMIC)\n\t\t\tbreak;\n\n\t\t \n\t\tif (insn->type == INSN_JUMP_UNCONDITIONAL &&\n\t\t    insn->jump_dest &&\n\t\t    (insn->jump_dest->offset <= insn->offset ||\n\t\t     insn->jump_dest->offset > orig_insn->offset))\n\t\t    break;\n\n\t\ttable_reloc = arch_find_switch_table(file, insn);\n\t\tif (!table_reloc)\n\t\t\tcontinue;\n\t\tdest_insn = find_insn(file, table_reloc->sym->sec, reloc_addend(table_reloc));\n\t\tif (!dest_insn || !insn_func(dest_insn) || insn_func(dest_insn)->pfunc != func)\n\t\t\tcontinue;\n\n\t\treturn table_reloc;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void mark_func_jump_tables(struct objtool_file *file,\n\t\t\t\t    struct symbol *func)\n{\n\tstruct instruction *insn, *last = NULL;\n\tstruct reloc *reloc;\n\n\tfunc_for_each_insn(file, func, insn) {\n\t\tif (!last)\n\t\t\tlast = insn;\n\n\t\t \n\t\tif (insn->type == INSN_JUMP_UNCONDITIONAL && insn->jump_dest &&\n\t\t    insn->offset > last->offset &&\n\t\t    insn->jump_dest->offset > insn->offset &&\n\t\t    !insn->jump_dest->first_jump_src) {\n\n\t\t\tinsn->jump_dest->first_jump_src = insn;\n\t\t\tlast = insn->jump_dest;\n\t\t}\n\n\t\tif (insn->type != INSN_JUMP_DYNAMIC)\n\t\t\tcontinue;\n\n\t\treloc = find_jump_table(file, func, insn);\n\t\tif (reloc)\n\t\t\tinsn->_jump_table = reloc;\n\t}\n}\n\nstatic int add_func_jump_tables(struct objtool_file *file,\n\t\t\t\t  struct symbol *func)\n{\n\tstruct instruction *insn, *insn_t1 = NULL, *insn_t2;\n\tint ret = 0;\n\n\tfunc_for_each_insn(file, func, insn) {\n\t\tif (!insn_jump_table(insn))\n\t\t\tcontinue;\n\n\t\tif (!insn_t1) {\n\t\t\tinsn_t1 = insn;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinsn_t2 = insn;\n\n\t\tret = add_jump_table(file, insn_t1, insn_jump_table(insn_t2));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tinsn_t1 = insn_t2;\n\t}\n\n\tif (insn_t1)\n\t\tret = add_jump_table(file, insn_t1, NULL);\n\n\treturn ret;\n}\n\n \nstatic int add_jump_table_alts(struct objtool_file *file)\n{\n\tstruct symbol *func;\n\tint ret;\n\n\tif (!file->rodata)\n\t\treturn 0;\n\n\tfor_each_sym(file, func) {\n\t\tif (func->type != STT_FUNC)\n\t\t\tcontinue;\n\n\t\tmark_func_jump_tables(file, func);\n\t\tret = add_func_jump_tables(file, func);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void set_func_state(struct cfi_state *state)\n{\n\tstate->cfa = initial_func_cfi.cfa;\n\tmemcpy(&state->regs, &initial_func_cfi.regs,\n\t       CFI_NUM_REGS * sizeof(struct cfi_reg));\n\tstate->stack_size = initial_func_cfi.cfa.offset;\n\tstate->type = UNWIND_HINT_TYPE_CALL;\n}\n\nstatic int read_unwind_hints(struct objtool_file *file)\n{\n\tstruct cfi_state cfi = init_cfi;\n\tstruct section *sec;\n\tstruct unwind_hint *hint;\n\tstruct instruction *insn;\n\tstruct reloc *reloc;\n\tint i;\n\n\tsec = find_section_by_name(file->elf, \".discard.unwind_hints\");\n\tif (!sec)\n\t\treturn 0;\n\n\tif (!sec->rsec) {\n\t\tWARN(\"missing .rela.discard.unwind_hints section\");\n\t\treturn -1;\n\t}\n\n\tif (sec->sh.sh_size % sizeof(struct unwind_hint)) {\n\t\tWARN(\"struct unwind_hint size mismatch\");\n\t\treturn -1;\n\t}\n\n\tfile->hints = true;\n\n\tfor (i = 0; i < sec->sh.sh_size / sizeof(struct unwind_hint); i++) {\n\t\thint = (struct unwind_hint *)sec->data->d_buf + i;\n\n\t\treloc = find_reloc_by_dest(file->elf, sec, i * sizeof(*hint));\n\t\tif (!reloc) {\n\t\t\tWARN(\"can't find reloc for unwind_hints[%d]\", i);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn = find_insn(file, reloc->sym->sec, reloc_addend(reloc));\n\t\tif (!insn) {\n\t\t\tWARN(\"can't find insn for unwind_hints[%d]\", i);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn->hint = true;\n\n\t\tif (hint->type == UNWIND_HINT_TYPE_UNDEFINED) {\n\t\t\tinsn->cfi = &force_undefined_cfi;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hint->type == UNWIND_HINT_TYPE_SAVE) {\n\t\t\tinsn->hint = false;\n\t\t\tinsn->save = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hint->type == UNWIND_HINT_TYPE_RESTORE) {\n\t\t\tinsn->restore = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hint->type == UNWIND_HINT_TYPE_REGS_PARTIAL) {\n\t\t\tstruct symbol *sym = find_symbol_by_offset(insn->sec, insn->offset);\n\n\t\t\tif (sym && sym->bind == STB_GLOBAL) {\n\t\t\t\tif (opts.ibt && insn->type != INSN_ENDBR && !insn->noendbr) {\n\t\t\t\t\tWARN_INSN(insn, \"UNWIND_HINT_IRET_REGS without ENDBR\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hint->type == UNWIND_HINT_TYPE_FUNC) {\n\t\t\tinsn->cfi = &func_cfi;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->cfi)\n\t\t\tcfi = *(insn->cfi);\n\n\t\tif (arch_decode_hint_reg(hint->sp_reg, &cfi.cfa.base)) {\n\t\t\tWARN_INSN(insn, \"unsupported unwind_hint sp base reg %d\", hint->sp_reg);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcfi.cfa.offset = bswap_if_needed(file->elf, hint->sp_offset);\n\t\tcfi.type = hint->type;\n\t\tcfi.signal = hint->signal;\n\n\t\tinsn->cfi = cfi_hash_find_or_add(&cfi);\n\t}\n\n\treturn 0;\n}\n\nstatic int read_noendbr_hints(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tstruct section *rsec;\n\tstruct reloc *reloc;\n\n\trsec = find_section_by_name(file->elf, \".rela.discard.noendbr\");\n\tif (!rsec)\n\t\treturn 0;\n\n\tfor_each_reloc(rsec, reloc) {\n\t\tinsn = find_insn(file, reloc->sym->sec,\n\t\t\t\t reloc->sym->offset + reloc_addend(reloc));\n\t\tif (!insn) {\n\t\t\tWARN(\"bad .discard.noendbr entry\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn->noendbr = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_retpoline_hints(struct objtool_file *file)\n{\n\tstruct section *rsec;\n\tstruct instruction *insn;\n\tstruct reloc *reloc;\n\n\trsec = find_section_by_name(file->elf, \".rela.discard.retpoline_safe\");\n\tif (!rsec)\n\t\treturn 0;\n\n\tfor_each_reloc(rsec, reloc) {\n\t\tif (reloc->sym->type != STT_SECTION) {\n\t\t\tWARN(\"unexpected relocation symbol type in %s\", rsec->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn = find_insn(file, reloc->sym->sec, reloc_addend(reloc));\n\t\tif (!insn) {\n\t\t\tWARN(\"bad .discard.retpoline_safe entry\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (insn->type != INSN_JUMP_DYNAMIC &&\n\t\t    insn->type != INSN_CALL_DYNAMIC &&\n\t\t    insn->type != INSN_RETURN &&\n\t\t    insn->type != INSN_NOP) {\n\t\t\tWARN_INSN(insn, \"retpoline_safe hint not an indirect jump/call/ret/nop\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn->retpoline_safe = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_instr_hints(struct objtool_file *file)\n{\n\tstruct section *rsec;\n\tstruct instruction *insn;\n\tstruct reloc *reloc;\n\n\trsec = find_section_by_name(file->elf, \".rela.discard.instr_end\");\n\tif (!rsec)\n\t\treturn 0;\n\n\tfor_each_reloc(rsec, reloc) {\n\t\tif (reloc->sym->type != STT_SECTION) {\n\t\t\tWARN(\"unexpected relocation symbol type in %s\", rsec->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn = find_insn(file, reloc->sym->sec, reloc_addend(reloc));\n\t\tif (!insn) {\n\t\t\tWARN(\"bad .discard.instr_end entry\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn->instr--;\n\t}\n\n\trsec = find_section_by_name(file->elf, \".rela.discard.instr_begin\");\n\tif (!rsec)\n\t\treturn 0;\n\n\tfor_each_reloc(rsec, reloc) {\n\t\tif (reloc->sym->type != STT_SECTION) {\n\t\t\tWARN(\"unexpected relocation symbol type in %s\", rsec->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn = find_insn(file, reloc->sym->sec, reloc_addend(reloc));\n\t\tif (!insn) {\n\t\t\tWARN(\"bad .discard.instr_begin entry\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn->instr++;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_validate_unret_hints(struct objtool_file *file)\n{\n\tstruct section *rsec;\n\tstruct instruction *insn;\n\tstruct reloc *reloc;\n\n\trsec = find_section_by_name(file->elf, \".rela.discard.validate_unret\");\n\tif (!rsec)\n\t\treturn 0;\n\n\tfor_each_reloc(rsec, reloc) {\n\t\tif (reloc->sym->type != STT_SECTION) {\n\t\t\tWARN(\"unexpected relocation symbol type in %s\", rsec->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn = find_insn(file, reloc->sym->sec, reloc_addend(reloc));\n\t\tif (!insn) {\n\t\t\tWARN(\"bad .discard.instr_end entry\");\n\t\t\treturn -1;\n\t\t}\n\t\tinsn->unret = 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int read_intra_function_calls(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tstruct section *rsec;\n\tstruct reloc *reloc;\n\n\trsec = find_section_by_name(file->elf, \".rela.discard.intra_function_calls\");\n\tif (!rsec)\n\t\treturn 0;\n\n\tfor_each_reloc(rsec, reloc) {\n\t\tunsigned long dest_off;\n\n\t\tif (reloc->sym->type != STT_SECTION) {\n\t\t\tWARN(\"unexpected relocation symbol type in %s\",\n\t\t\t     rsec->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinsn = find_insn(file, reloc->sym->sec, reloc_addend(reloc));\n\t\tif (!insn) {\n\t\t\tWARN(\"bad .discard.intra_function_call entry\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (insn->type != INSN_CALL) {\n\t\t\tWARN_INSN(insn, \"intra_function_call not a direct call\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tinsn->type = INSN_JUMP_UNCONDITIONAL;\n\n\t\tdest_off = arch_jump_destination(insn);\n\t\tinsn->jump_dest = find_insn(file, insn->sec, dest_off);\n\t\tif (!insn->jump_dest) {\n\t\t\tWARN_INSN(insn, \"can't find call dest at %s+0x%lx\",\n\t\t\t\t  insn->sec->name, dest_off);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool is_profiling_func(const char *name)\n{\n\t \n\tif (!strncmp(name, \"__sanitizer_cov_\", 16))\n\t\treturn true;\n\n\t \n\tif (!strncmp(name, \"__tsan_func_\", 12) ||\n\t    !strcmp(name, \"__tsan_atomic_signal_fence\"))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int classify_symbols(struct objtool_file *file)\n{\n\tstruct symbol *func;\n\n\tfor_each_sym(file, func) {\n\t\tif (func->bind != STB_GLOBAL)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(func->name, STATIC_CALL_TRAMP_PREFIX_STR,\n\t\t\t     strlen(STATIC_CALL_TRAMP_PREFIX_STR)))\n\t\t\tfunc->static_call_tramp = true;\n\n\t\tif (arch_is_retpoline(func))\n\t\t\tfunc->retpoline_thunk = true;\n\n\t\tif (arch_is_rethunk(func))\n\t\t\tfunc->return_thunk = true;\n\n\t\tif (arch_is_embedded_insn(func))\n\t\t\tfunc->embedded_insn = true;\n\n\t\tif (arch_ftrace_match(func->name))\n\t\t\tfunc->fentry = true;\n\n\t\tif (is_profiling_func(func->name))\n\t\t\tfunc->profiling_func = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void mark_rodata(struct objtool_file *file)\n{\n\tstruct section *sec;\n\tbool found = false;\n\n\t \n\tfor_each_sec(file, sec) {\n\t\tif (!strncmp(sec->name, \".rodata\", 7) &&\n\t\t    !strstr(sec->name, \".str1.\")) {\n\t\t\tsec->rodata = true;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfile->rodata = found;\n}\n\nstatic int decode_sections(struct objtool_file *file)\n{\n\tint ret;\n\n\tmark_rodata(file);\n\n\tret = init_pv_ops(file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = classify_symbols(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = decode_instructions(file);\n\tif (ret)\n\t\treturn ret;\n\n\tadd_ignores(file);\n\tadd_uaccess_safe(file);\n\n\tret = add_ignore_alternatives(file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = read_noendbr_hints(file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (opts.stackval || opts.orc || opts.uaccess || opts.noinstr) {\n\t\tret = add_special_section_alts(file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = add_jump_destinations(file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = read_intra_function_calls(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = add_call_destinations(file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = add_dead_ends(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = add_jump_table_alts(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = read_unwind_hints(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = read_retpoline_hints(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = read_instr_hints(file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = read_validate_unret_hints(file);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic bool is_special_call(struct instruction *insn)\n{\n\tif (insn->type == INSN_CALL) {\n\t\tstruct symbol *dest = insn_call_dest(insn);\n\n\t\tif (!dest)\n\t\t\treturn false;\n\n\t\tif (dest->fentry || dest->embedded_insn)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool has_modified_stack_frame(struct instruction *insn, struct insn_state *state)\n{\n\tstruct cfi_state *cfi = &state->cfi;\n\tint i;\n\n\tif (cfi->cfa.base != initial_func_cfi.cfa.base || cfi->drap)\n\t\treturn true;\n\n\tif (cfi->cfa.offset != initial_func_cfi.cfa.offset)\n\t\treturn true;\n\n\tif (cfi->stack_size != initial_func_cfi.cfa.offset)\n\t\treturn true;\n\n\tfor (i = 0; i < CFI_NUM_REGS; i++) {\n\t\tif (cfi->regs[i].base != initial_func_cfi.regs[i].base ||\n\t\t    cfi->regs[i].offset != initial_func_cfi.regs[i].offset)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool check_reg_frame_pos(const struct cfi_reg *reg,\n\t\t\t\tint expected_offset)\n{\n\treturn reg->base == CFI_CFA &&\n\t       reg->offset == expected_offset;\n}\n\nstatic bool has_valid_stack_frame(struct insn_state *state)\n{\n\tstruct cfi_state *cfi = &state->cfi;\n\n\tif (cfi->cfa.base == CFI_BP &&\n\t    check_reg_frame_pos(&cfi->regs[CFI_BP], -cfi->cfa.offset) &&\n\t    check_reg_frame_pos(&cfi->regs[CFI_RA], -cfi->cfa.offset + 8))\n\t\treturn true;\n\n\tif (cfi->drap && cfi->regs[CFI_BP].base == CFI_BP)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int update_cfi_state_regs(struct instruction *insn,\n\t\t\t\t  struct cfi_state *cfi,\n\t\t\t\t  struct stack_op *op)\n{\n\tstruct cfi_reg *cfa = &cfi->cfa;\n\n\tif (cfa->base != CFI_SP && cfa->base != CFI_SP_INDIRECT)\n\t\treturn 0;\n\n\t \n\tif (op->dest.type == OP_DEST_PUSH || op->dest.type == OP_DEST_PUSHF)\n\t\tcfa->offset += 8;\n\n\t \n\tif (op->src.type == OP_SRC_POP || op->src.type == OP_SRC_POPF)\n\t\tcfa->offset -= 8;\n\n\t \n\tif (op->dest.type == OP_DEST_REG && op->src.type == OP_SRC_ADD &&\n\t    op->dest.reg == CFI_SP && op->src.reg == CFI_SP)\n\t\tcfa->offset -= op->src.offset;\n\n\treturn 0;\n}\n\nstatic void save_reg(struct cfi_state *cfi, unsigned char reg, int base, int offset)\n{\n\tif (arch_callee_saved_reg(reg) &&\n\t    cfi->regs[reg].base == CFI_UNDEFINED) {\n\t\tcfi->regs[reg].base = base;\n\t\tcfi->regs[reg].offset = offset;\n\t}\n}\n\nstatic void restore_reg(struct cfi_state *cfi, unsigned char reg)\n{\n\tcfi->regs[reg].base = initial_func_cfi.regs[reg].base;\n\tcfi->regs[reg].offset = initial_func_cfi.regs[reg].offset;\n}\n\n \nstatic int update_cfi_state(struct instruction *insn,\n\t\t\t    struct instruction *next_insn,\n\t\t\t    struct cfi_state *cfi, struct stack_op *op)\n{\n\tstruct cfi_reg *cfa = &cfi->cfa;\n\tstruct cfi_reg *regs = cfi->regs;\n\n\t \n\tif (cfi->force_undefined)\n\t\treturn 0;\n\n\t \n\tif (cfa->base == CFI_UNDEFINED) {\n\t\tif (insn_func(insn)) {\n\t\t\tWARN_INSN(insn, \"undefined stack state\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (cfi->type == UNWIND_HINT_TYPE_REGS ||\n\t    cfi->type == UNWIND_HINT_TYPE_REGS_PARTIAL)\n\t\treturn update_cfi_state_regs(insn, cfi, op);\n\n\tswitch (op->dest.type) {\n\n\tcase OP_DEST_REG:\n\t\tswitch (op->src.type) {\n\n\t\tcase OP_SRC_REG:\n\t\t\tif (op->src.reg == CFI_SP && op->dest.reg == CFI_BP &&\n\t\t\t    cfa->base == CFI_SP &&\n\t\t\t    check_reg_frame_pos(&regs[CFI_BP], -cfa->offset)) {\n\n\t\t\t\t \n\t\t\t\tcfa->base = op->dest.reg;\n\t\t\t\tcfi->bp_scratch = false;\n\t\t\t}\n\n\t\t\telse if (op->src.reg == CFI_SP &&\n\t\t\t\t op->dest.reg == CFI_BP && cfi->drap) {\n\n\t\t\t\t \n\t\t\t\tregs[CFI_BP].base = CFI_BP;\n\t\t\t\tregs[CFI_BP].offset = -cfi->stack_size;\n\t\t\t\tcfi->bp_scratch = false;\n\t\t\t}\n\n\t\t\telse if (op->src.reg == CFI_SP && cfa->base == CFI_SP) {\n\n\t\t\t\t \n\t\t\t\tcfi->vals[op->dest.reg].base = CFI_CFA;\n\t\t\t\tcfi->vals[op->dest.reg].offset = -cfi->stack_size;\n\t\t\t}\n\n\t\t\telse if (op->src.reg == CFI_BP && op->dest.reg == CFI_SP &&\n\t\t\t\t (cfa->base == CFI_BP || cfa->base == cfi->drap_reg)) {\n\n\t\t\t\t \n\t\t\t\tcfi->stack_size = -cfi->regs[CFI_BP].offset;\n\t\t\t}\n\n\t\t\telse if (op->dest.reg == cfa->base) {\n\n\t\t\t\t \n\t\t\t\tif (cfa->base == CFI_SP &&\n\t\t\t\t    cfi->vals[op->src.reg].base == CFI_CFA) {\n\n\t\t\t\t\t \n\t\t\t\t\tcfa->offset = -cfi->vals[op->src.reg].offset;\n\t\t\t\t\tcfi->stack_size = cfa->offset;\n\n\t\t\t\t} else if (cfa->base == CFI_SP &&\n\t\t\t\t\t   cfi->vals[op->src.reg].base == CFI_SP_INDIRECT &&\n\t\t\t\t\t   cfi->vals[op->src.reg].offset == cfa->offset) {\n\n\t\t\t\t\t \n\t\t\t\t\tcfa->base = CFI_SP_INDIRECT;\n\n\t\t\t\t} else {\n\t\t\t\t\tcfa->base = CFI_UNDEFINED;\n\t\t\t\t\tcfa->offset = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (op->dest.reg == CFI_SP &&\n\t\t\t\t cfi->vals[op->src.reg].base == CFI_SP_INDIRECT &&\n\t\t\t\t cfi->vals[op->src.reg].offset == cfa->offset) {\n\n\t\t\t\t \n\t\t\t\tcfi->stack_size += 8;\n\t\t\t}\n\n\n\t\t\tbreak;\n\n\t\tcase OP_SRC_ADD:\n\t\t\tif (op->dest.reg == CFI_SP && op->src.reg == CFI_SP) {\n\n\t\t\t\t \n\t\t\t\tcfi->stack_size -= op->src.offset;\n\t\t\t\tif (cfa->base == CFI_SP)\n\t\t\t\t\tcfa->offset -= op->src.offset;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (op->dest.reg == CFI_SP && op->src.reg == CFI_BP) {\n\n\t\t\t\t \n\t\t\t\tcfi->stack_size = -(op->src.offset + regs[CFI_BP].offset);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (op->src.reg == CFI_SP && cfa->base == CFI_SP) {\n\n\t\t\t\t \n\t\t\t\tcfi->drap_reg = op->dest.reg;\n\n\t\t\t\t \n\t\t\t\tcfi->vals[op->dest.reg].base = CFI_CFA;\n\t\t\t\tcfi->vals[op->dest.reg].offset = \\\n\t\t\t\t\t-cfi->stack_size + op->src.offset;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cfi->drap && op->dest.reg == CFI_SP &&\n\t\t\t    op->src.reg == cfi->drap_reg) {\n\n\t\t\t\t  \n\t\t\t\tcfa->base = CFI_SP;\n\t\t\t\tcfa->offset = cfi->stack_size = -op->src.offset;\n\t\t\t\tcfi->drap_reg = CFI_UNDEFINED;\n\t\t\t\tcfi->drap = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (op->dest.reg == cfi->cfa.base && !(next_insn && next_insn->hint)) {\n\t\t\t\tWARN_INSN(insn, \"unsupported stack register modification\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase OP_SRC_AND:\n\t\t\tif (op->dest.reg != CFI_SP ||\n\t\t\t    (cfi->drap_reg != CFI_UNDEFINED && cfa->base != CFI_SP) ||\n\t\t\t    (cfi->drap_reg == CFI_UNDEFINED && cfa->base != CFI_BP)) {\n\t\t\t\tWARN_INSN(insn, \"unsupported stack pointer realignment\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (cfi->drap_reg != CFI_UNDEFINED) {\n\t\t\t\t \n\t\t\t\tcfa->base = cfi->drap_reg;\n\t\t\t\tcfa->offset = cfi->stack_size = 0;\n\t\t\t\tcfi->drap = true;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tbreak;\n\n\t\tcase OP_SRC_POP:\n\t\tcase OP_SRC_POPF:\n\t\t\tif (op->dest.reg == CFI_SP && cfa->base == CFI_SP_INDIRECT) {\n\n\t\t\t\t \n\t\t\t\tcfa->base = CFI_SP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!cfi->drap && op->dest.reg == cfa->base) {\n\n\t\t\t\t \n\t\t\t\tcfa->base = CFI_SP;\n\t\t\t}\n\n\t\t\tif (cfi->drap && cfa->base == CFI_BP_INDIRECT &&\n\t\t\t    op->dest.reg == cfi->drap_reg &&\n\t\t\t    cfi->drap_offset == -cfi->stack_size) {\n\n\t\t\t\t \n\t\t\t\tcfa->base = cfi->drap_reg;\n\t\t\t\tcfa->offset = 0;\n\t\t\t\tcfi->drap_offset = -1;\n\n\t\t\t} else if (cfi->stack_size == -regs[op->dest.reg].offset) {\n\n\t\t\t\t \n\t\t\t\trestore_reg(cfi, op->dest.reg);\n\t\t\t}\n\n\t\t\tcfi->stack_size -= 8;\n\t\t\tif (cfa->base == CFI_SP)\n\t\t\t\tcfa->offset -= 8;\n\n\t\t\tbreak;\n\n\t\tcase OP_SRC_REG_INDIRECT:\n\t\t\tif (!cfi->drap && op->dest.reg == cfa->base &&\n\t\t\t    op->dest.reg == CFI_BP) {\n\n\t\t\t\t \n\t\t\t\tcfa->base = CFI_SP;\n\t\t\t\tcfa->offset = cfi->stack_size;\n\t\t\t}\n\n\t\t\tif (cfi->drap && op->src.reg == CFI_BP &&\n\t\t\t    op->src.offset == cfi->drap_offset) {\n\n\t\t\t\t \n\t\t\t\tcfa->base = cfi->drap_reg;\n\t\t\t\tcfa->offset = 0;\n\t\t\t\tcfi->drap_offset = -1;\n\t\t\t}\n\n\t\t\tif (cfi->drap && op->src.reg == CFI_BP &&\n\t\t\t    op->src.offset == regs[op->dest.reg].offset) {\n\n\t\t\t\t \n\t\t\t\trestore_reg(cfi, op->dest.reg);\n\n\t\t\t} else if (op->src.reg == cfa->base &&\n\t\t\t    op->src.offset == regs[op->dest.reg].offset + cfa->offset) {\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\trestore_reg(cfi, op->dest.reg);\n\n\t\t\t} else if (op->src.reg == CFI_SP &&\n\t\t\t\t   op->src.offset == regs[op->dest.reg].offset + cfi->stack_size) {\n\n\t\t\t\t \n\t\t\t\trestore_reg(cfi, op->dest.reg);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWARN_INSN(insn, \"unknown stack-related instruction\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\n\tcase OP_DEST_PUSH:\n\tcase OP_DEST_PUSHF:\n\t\tcfi->stack_size += 8;\n\t\tif (cfa->base == CFI_SP)\n\t\t\tcfa->offset += 8;\n\n\t\tif (op->src.type != OP_SRC_REG)\n\t\t\tbreak;\n\n\t\tif (cfi->drap) {\n\t\t\tif (op->src.reg == cfa->base && op->src.reg == cfi->drap_reg) {\n\n\t\t\t\t \n\t\t\t\tcfa->base = CFI_BP_INDIRECT;\n\t\t\t\tcfa->offset = -cfi->stack_size;\n\n\t\t\t\t \n\t\t\t\tcfi->drap_offset = -cfi->stack_size;\n\n\t\t\t} else if (op->src.reg == CFI_BP && cfa->base == cfi->drap_reg) {\n\n\t\t\t\t \n\t\t\t\tcfi->stack_size = 0;\n\n\t\t\t} else {\n\n\t\t\t\t \n\t\t\t\tsave_reg(cfi, op->src.reg, CFI_BP, -cfi->stack_size);\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t \n\t\t\tsave_reg(cfi, op->src.reg, CFI_CFA, -cfi->stack_size);\n\t\t}\n\n\t\t \n\t\tif (opts.stackval && insn_func(insn) && op->src.reg == CFI_BP &&\n\t\t    cfa->base != CFI_BP)\n\t\t\tcfi->bp_scratch = true;\n\t\tbreak;\n\n\tcase OP_DEST_REG_INDIRECT:\n\n\t\tif (cfi->drap) {\n\t\t\tif (op->src.reg == cfa->base && op->src.reg == cfi->drap_reg) {\n\n\t\t\t\t \n\t\t\t\tcfa->base = CFI_BP_INDIRECT;\n\t\t\t\tcfa->offset = op->dest.offset;\n\n\t\t\t\t \n\t\t\t\tcfi->drap_offset = op->dest.offset;\n\t\t\t} else {\n\n\t\t\t\t \n\t\t\t\tsave_reg(cfi, op->src.reg, CFI_BP, op->dest.offset);\n\t\t\t}\n\n\t\t} else if (op->dest.reg == cfa->base) {\n\n\t\t\t \n\t\t\t \n\t\t\tsave_reg(cfi, op->src.reg, CFI_CFA,\n\t\t\t\t op->dest.offset - cfi->cfa.offset);\n\n\t\t} else if (op->dest.reg == CFI_SP) {\n\n\t\t\t \n\t\t\tsave_reg(cfi, op->src.reg, CFI_CFA,\n\t\t\t\t op->dest.offset - cfi->stack_size);\n\n\t\t} else if (op->src.reg == CFI_SP && op->dest.offset == 0) {\n\n\t\t\t \n\t\t\tcfi->vals[op->dest.reg].base = CFI_SP_INDIRECT;\n\t\t\tcfi->vals[op->dest.reg].offset = cfa->offset;\n\t\t}\n\n\t\tbreak;\n\n\tcase OP_DEST_MEM:\n\t\tif (op->src.type != OP_SRC_POP && op->src.type != OP_SRC_POPF) {\n\t\t\tWARN_INSN(insn, \"unknown stack-related memory operation\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tcfi->stack_size -= 8;\n\t\tif (cfa->base == CFI_SP)\n\t\t\tcfa->offset -= 8;\n\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_INSN(insn, \"unknown stack-related instruction\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int propagate_alt_cfi(struct objtool_file *file, struct instruction *insn)\n{\n\tstruct cfi_state **alt_cfi;\n\tint group_off;\n\n\tif (!insn->alt_group)\n\t\treturn 0;\n\n\tif (!insn->cfi) {\n\t\tWARN(\"CFI missing\");\n\t\treturn -1;\n\t}\n\n\talt_cfi = insn->alt_group->cfi;\n\tgroup_off = insn->offset - insn->alt_group->first_insn->offset;\n\n\tif (!alt_cfi[group_off]) {\n\t\talt_cfi[group_off] = insn->cfi;\n\t} else {\n\t\tif (cficmp(alt_cfi[group_off], insn->cfi)) {\n\t\t\tstruct alt_group *orig_group = insn->alt_group->orig_group ?: insn->alt_group;\n\t\t\tstruct instruction *orig = orig_group->first_insn;\n\t\t\tchar *where = offstr(insn->sec, insn->offset);\n\t\t\tWARN_INSN(orig, \"stack layout conflict in alternatives: %s\", where);\n\t\t\tfree(where);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_insn_ops(struct instruction *insn,\n\t\t\t   struct instruction *next_insn,\n\t\t\t   struct insn_state *state)\n{\n\tstruct stack_op *op;\n\n\tfor (op = insn->stack_ops; op; op = op->next) {\n\n\t\tif (update_cfi_state(insn, next_insn, &state->cfi, op))\n\t\t\treturn 1;\n\n\t\tif (!insn->alt_group)\n\t\t\tcontinue;\n\n\t\tif (op->dest.type == OP_DEST_PUSHF) {\n\t\t\tif (!state->uaccess_stack) {\n\t\t\t\tstate->uaccess_stack = 1;\n\t\t\t} else if (state->uaccess_stack >> 31) {\n\t\t\t\tWARN_INSN(insn, \"PUSHF stack exhausted\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tstate->uaccess_stack <<= 1;\n\t\t\tstate->uaccess_stack  |= state->uaccess;\n\t\t}\n\n\t\tif (op->src.type == OP_SRC_POPF) {\n\t\t\tif (state->uaccess_stack) {\n\t\t\t\tstate->uaccess = state->uaccess_stack & 1;\n\t\t\t\tstate->uaccess_stack >>= 1;\n\t\t\t\tif (state->uaccess_stack == 1)\n\t\t\t\t\tstate->uaccess_stack = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool insn_cfi_match(struct instruction *insn, struct cfi_state *cfi2)\n{\n\tstruct cfi_state *cfi1 = insn->cfi;\n\tint i;\n\n\tif (!cfi1) {\n\t\tWARN(\"CFI missing\");\n\t\treturn false;\n\t}\n\n\tif (memcmp(&cfi1->cfa, &cfi2->cfa, sizeof(cfi1->cfa))) {\n\n\t\tWARN_INSN(insn, \"stack state mismatch: cfa1=%d%+d cfa2=%d%+d\",\n\t\t\t  cfi1->cfa.base, cfi1->cfa.offset,\n\t\t\t  cfi2->cfa.base, cfi2->cfa.offset);\n\n\t} else if (memcmp(&cfi1->regs, &cfi2->regs, sizeof(cfi1->regs))) {\n\t\tfor (i = 0; i < CFI_NUM_REGS; i++) {\n\t\t\tif (!memcmp(&cfi1->regs[i], &cfi2->regs[i],\n\t\t\t\t    sizeof(struct cfi_reg)))\n\t\t\t\tcontinue;\n\n\t\t\tWARN_INSN(insn, \"stack state mismatch: reg1[%d]=%d%+d reg2[%d]=%d%+d\",\n\t\t\t\t  i, cfi1->regs[i].base, cfi1->regs[i].offset,\n\t\t\t\t  i, cfi2->regs[i].base, cfi2->regs[i].offset);\n\t\t\tbreak;\n\t\t}\n\n\t} else if (cfi1->type != cfi2->type) {\n\n\t\tWARN_INSN(insn, \"stack state mismatch: type1=%d type2=%d\",\n\t\t\t  cfi1->type, cfi2->type);\n\n\t} else if (cfi1->drap != cfi2->drap ||\n\t\t   (cfi1->drap && cfi1->drap_reg != cfi2->drap_reg) ||\n\t\t   (cfi1->drap && cfi1->drap_offset != cfi2->drap_offset)) {\n\n\t\tWARN_INSN(insn, \"stack state mismatch: drap1=%d(%d,%d) drap2=%d(%d,%d)\",\n\t\t\t  cfi1->drap, cfi1->drap_reg, cfi1->drap_offset,\n\t\t\t  cfi2->drap, cfi2->drap_reg, cfi2->drap_offset);\n\n\t} else\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool func_uaccess_safe(struct symbol *func)\n{\n\tif (func)\n\t\treturn func->uaccess_safe;\n\n\treturn false;\n}\n\nstatic inline const char *call_dest_name(struct instruction *insn)\n{\n\tstatic char pvname[19];\n\tstruct reloc *reloc;\n\tint idx;\n\n\tif (insn_call_dest(insn))\n\t\treturn insn_call_dest(insn)->name;\n\n\treloc = insn_reloc(NULL, insn);\n\tif (reloc && !strcmp(reloc->sym->name, \"pv_ops\")) {\n\t\tidx = (reloc_addend(reloc) / sizeof(void *));\n\t\tsnprintf(pvname, sizeof(pvname), \"pv_ops[%d]\", idx);\n\t\treturn pvname;\n\t}\n\n\treturn \"{dynamic}\";\n}\n\nstatic bool pv_call_dest(struct objtool_file *file, struct instruction *insn)\n{\n\tstruct symbol *target;\n\tstruct reloc *reloc;\n\tint idx;\n\n\treloc = insn_reloc(file, insn);\n\tif (!reloc || strcmp(reloc->sym->name, \"pv_ops\"))\n\t\treturn false;\n\n\tidx = (arch_dest_reloc_offset(reloc_addend(reloc)) / sizeof(void *));\n\n\tif (file->pv_ops[idx].clean)\n\t\treturn true;\n\n\tfile->pv_ops[idx].clean = true;\n\n\tlist_for_each_entry(target, &file->pv_ops[idx].targets, pv_target) {\n\t\tif (!target->sec->noinstr) {\n\t\t\tWARN(\"pv_ops[%d]: %s\", idx, target->name);\n\t\t\tfile->pv_ops[idx].clean = false;\n\t\t}\n\t}\n\n\treturn file->pv_ops[idx].clean;\n}\n\nstatic inline bool noinstr_call_dest(struct objtool_file *file,\n\t\t\t\t     struct instruction *insn,\n\t\t\t\t     struct symbol *func)\n{\n\t \n\tif (!func) {\n\t\tif (file->pv_ops)\n\t\t\treturn pv_call_dest(file, insn);\n\n\t\treturn false;\n\t}\n\n\t \n\tif (func->sec->noinstr)\n\t\treturn true;\n\n\t \n\tif (func->static_call_tramp)\n\t\treturn true;\n\n\t \n\tif (!strncmp(func->name, \"__ubsan_handle_\", 15))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int validate_call(struct objtool_file *file,\n\t\t\t struct instruction *insn,\n\t\t\t struct insn_state *state)\n{\n\tif (state->noinstr && state->instr <= 0 &&\n\t    !noinstr_call_dest(file, insn, insn_call_dest(insn))) {\n\t\tWARN_INSN(insn, \"call to %s() leaves .noinstr.text section\", call_dest_name(insn));\n\t\treturn 1;\n\t}\n\n\tif (state->uaccess && !func_uaccess_safe(insn_call_dest(insn))) {\n\t\tWARN_INSN(insn, \"call to %s() with UACCESS enabled\", call_dest_name(insn));\n\t\treturn 1;\n\t}\n\n\tif (state->df) {\n\t\tWARN_INSN(insn, \"call to %s() with DF set\", call_dest_name(insn));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_sibling_call(struct objtool_file *file,\n\t\t\t\t struct instruction *insn,\n\t\t\t\t struct insn_state *state)\n{\n\tif (insn_func(insn) && has_modified_stack_frame(insn, state)) {\n\t\tWARN_INSN(insn, \"sibling call from callable instruction with modified stack frame\");\n\t\treturn 1;\n\t}\n\n\treturn validate_call(file, insn, state);\n}\n\nstatic int validate_return(struct symbol *func, struct instruction *insn, struct insn_state *state)\n{\n\tif (state->noinstr && state->instr > 0) {\n\t\tWARN_INSN(insn, \"return with instrumentation enabled\");\n\t\treturn 1;\n\t}\n\n\tif (state->uaccess && !func_uaccess_safe(func)) {\n\t\tWARN_INSN(insn, \"return with UACCESS enabled\");\n\t\treturn 1;\n\t}\n\n\tif (!state->uaccess && func_uaccess_safe(func)) {\n\t\tWARN_INSN(insn, \"return with UACCESS disabled from a UACCESS-safe function\");\n\t\treturn 1;\n\t}\n\n\tif (state->df) {\n\t\tWARN_INSN(insn, \"return with DF set\");\n\t\treturn 1;\n\t}\n\n\tif (func && has_modified_stack_frame(insn, state)) {\n\t\tWARN_INSN(insn, \"return with modified stack frame\");\n\t\treturn 1;\n\t}\n\n\tif (state->cfi.bp_scratch) {\n\t\tWARN_INSN(insn, \"BP used as a scratch register\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct instruction *next_insn_to_validate(struct objtool_file *file,\n\t\t\t\t\t\t struct instruction *insn)\n{\n\tstruct alt_group *alt_group = insn->alt_group;\n\n\t \n\tif (alt_group) {\n\t\tif (alt_group->nop) {\n\t\t\t \n\t\t\tif (insn == alt_group->last_insn)\n\t\t\t\treturn alt_group->nop;\n\t\t\tif (insn == alt_group->nop)\n\t\t\t\tgoto next_orig;\n\t\t}\n\t\tif (insn == alt_group->last_insn && alt_group->orig_group)\n\t\t\tgoto next_orig;\n\t}\n\n\treturn next_insn_same_sec(file, insn);\n\nnext_orig:\n\treturn next_insn_same_sec(file, alt_group->orig_group->last_insn);\n}\n\n \nstatic int validate_branch(struct objtool_file *file, struct symbol *func,\n\t\t\t   struct instruction *insn, struct insn_state state)\n{\n\tstruct alternative *alt;\n\tstruct instruction *next_insn, *prev_insn = NULL;\n\tstruct section *sec;\n\tu8 visited;\n\tint ret;\n\n\tsec = insn->sec;\n\n\twhile (1) {\n\t\tnext_insn = next_insn_to_validate(file, insn);\n\n\t\tif (func && insn_func(insn) && func != insn_func(insn)->pfunc) {\n\t\t\t \n\t\t\tif (!strncmp(func->name, \"__cfi_\", 6) ||\n\t\t\t    !strncmp(func->name, \"__pfx_\", 6))\n\t\t\t\treturn 0;\n\n\t\t\tWARN(\"%s() falls through to next function %s()\",\n\t\t\t     func->name, insn_func(insn)->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (func && insn->ignore) {\n\t\t\tWARN_INSN(insn, \"BUG: why am I validating an ignored function?\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tvisited = VISITED_BRANCH << state.uaccess;\n\t\tif (insn->visited & VISITED_BRANCH_MASK) {\n\t\t\tif (!insn->hint && !insn_cfi_match(insn, &state.cfi))\n\t\t\t\treturn 1;\n\n\t\t\tif (insn->visited & visited)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tnr_insns_visited++;\n\t\t}\n\n\t\tif (state.noinstr)\n\t\t\tstate.instr += insn->instr;\n\n\t\tif (insn->hint) {\n\t\t\tif (insn->restore) {\n\t\t\t\tstruct instruction *save_insn, *i;\n\n\t\t\t\ti = insn;\n\t\t\t\tsave_insn = NULL;\n\n\t\t\t\tsym_for_each_insn_continue_reverse(file, func, i) {\n\t\t\t\t\tif (i->save) {\n\t\t\t\t\t\tsave_insn = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!save_insn) {\n\t\t\t\t\tWARN_INSN(insn, \"no corresponding CFI save for CFI restore\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (!save_insn->visited) {\n\t\t\t\t\tWARN_INSN(insn, \"objtool isn't smart enough to handle this CFI save/restore combo\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tinsn->cfi = save_insn->cfi;\n\t\t\t\tnr_cfi_reused++;\n\t\t\t}\n\n\t\t\tstate.cfi = *insn->cfi;\n\t\t} else {\n\t\t\t \n\n\t\t\tif (prev_insn && !cficmp(prev_insn->cfi, &state.cfi)) {\n\t\t\t\tinsn->cfi = prev_insn->cfi;\n\t\t\t\tnr_cfi_reused++;\n\t\t\t} else {\n\t\t\t\tinsn->cfi = cfi_hash_find_or_add(&state.cfi);\n\t\t\t}\n\t\t}\n\n\t\tinsn->visited |= visited;\n\n\t\tif (propagate_alt_cfi(file, insn))\n\t\t\treturn 1;\n\n\t\tif (!insn->ignore_alts && insn->alts) {\n\t\t\tbool skip_orig = false;\n\n\t\t\tfor (alt = insn->alts; alt; alt = alt->next) {\n\t\t\t\tif (alt->skip_orig)\n\t\t\t\t\tskip_orig = true;\n\n\t\t\t\tret = validate_branch(file, func, alt->insn, state);\n\t\t\t\tif (ret) {\n\t\t\t\t\tBT_INSN(insn, \"(alt)\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip_orig)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (handle_insn_ops(insn, next_insn, &state))\n\t\t\treturn 1;\n\n\t\tswitch (insn->type) {\n\n\t\tcase INSN_RETURN:\n\t\t\treturn validate_return(func, insn, &state);\n\n\t\tcase INSN_CALL:\n\t\tcase INSN_CALL_DYNAMIC:\n\t\t\tret = validate_call(file, insn, &state);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (opts.stackval && func && !is_special_call(insn) &&\n\t\t\t    !has_valid_stack_frame(&state)) {\n\t\t\t\tWARN_INSN(insn, \"call without frame pointer save/setup\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (insn->dead_end)\n\t\t\t\treturn 0;\n\n\t\t\tbreak;\n\n\t\tcase INSN_JUMP_CONDITIONAL:\n\t\tcase INSN_JUMP_UNCONDITIONAL:\n\t\t\tif (is_sibling_call(insn)) {\n\t\t\t\tret = validate_sibling_call(file, insn, &state);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t} else if (insn->jump_dest) {\n\t\t\t\tret = validate_branch(file, func,\n\t\t\t\t\t\t      insn->jump_dest, state);\n\t\t\t\tif (ret) {\n\t\t\t\t\tBT_INSN(insn, \"(branch)\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (insn->type == INSN_JUMP_UNCONDITIONAL)\n\t\t\t\treturn 0;\n\n\t\t\tbreak;\n\n\t\tcase INSN_JUMP_DYNAMIC:\n\t\tcase INSN_JUMP_DYNAMIC_CONDITIONAL:\n\t\t\tif (is_sibling_call(insn)) {\n\t\t\t\tret = validate_sibling_call(file, insn, &state);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (insn->type == INSN_JUMP_DYNAMIC)\n\t\t\t\treturn 0;\n\n\t\t\tbreak;\n\n\t\tcase INSN_CONTEXT_SWITCH:\n\t\t\tif (func && (!next_insn || !next_insn->hint)) {\n\t\t\t\tWARN_INSN(insn, \"unsupported instruction in callable function\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\tcase INSN_STAC:\n\t\t\tif (state.uaccess) {\n\t\t\t\tWARN_INSN(insn, \"recursive UACCESS enable\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tstate.uaccess = true;\n\t\t\tbreak;\n\n\t\tcase INSN_CLAC:\n\t\t\tif (!state.uaccess && func) {\n\t\t\t\tWARN_INSN(insn, \"redundant UACCESS disable\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (func_uaccess_safe(func) && !state.uaccess_stack) {\n\t\t\t\tWARN_INSN(insn, \"UACCESS-safe disables UACCESS\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tstate.uaccess = false;\n\t\t\tbreak;\n\n\t\tcase INSN_STD:\n\t\t\tif (state.df) {\n\t\t\t\tWARN_INSN(insn, \"recursive STD\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tstate.df = true;\n\t\t\tbreak;\n\n\t\tcase INSN_CLD:\n\t\t\tif (!state.df && func) {\n\t\t\t\tWARN_INSN(insn, \"redundant CLD\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tstate.df = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (insn->dead_end)\n\t\t\treturn 0;\n\n\t\tif (!next_insn) {\n\t\t\tif (state.cfi.cfa.base == CFI_UNDEFINED)\n\t\t\t\treturn 0;\n\t\t\tWARN(\"%s: unexpected end of section\", sec->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tprev_insn = insn;\n\t\tinsn = next_insn;\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_unwind_hint(struct objtool_file *file,\n\t\t\t\t  struct instruction *insn,\n\t\t\t\t  struct insn_state *state)\n{\n\tif (insn->hint && !insn->visited && !insn->ignore) {\n\t\tint ret = validate_branch(file, insn_func(insn), insn, *state);\n\t\tif (ret)\n\t\t\tBT_INSN(insn, \"<=== (hint)\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_unwind_hints(struct objtool_file *file, struct section *sec)\n{\n\tstruct instruction *insn;\n\tstruct insn_state state;\n\tint warnings = 0;\n\n\tif (!file->hints)\n\t\treturn 0;\n\n\tinit_insn_state(file, &state, sec);\n\n\tif (sec) {\n\t\tsec_for_each_insn(file, sec, insn)\n\t\t\twarnings += validate_unwind_hint(file, insn, &state);\n\t} else {\n\t\tfor_each_insn(file, insn)\n\t\t\twarnings += validate_unwind_hint(file, insn, &state);\n\t}\n\n\treturn warnings;\n}\n\n \nstatic int validate_unret(struct objtool_file *file, struct instruction *insn)\n{\n\tstruct instruction *next, *dest;\n\tint ret;\n\n\tfor (;;) {\n\t\tnext = next_insn_to_validate(file, insn);\n\n\t\tif (insn->visited & VISITED_UNRET)\n\t\t\treturn 0;\n\n\t\tinsn->visited |= VISITED_UNRET;\n\n\t\tif (!insn->ignore_alts && insn->alts) {\n\t\t\tstruct alternative *alt;\n\t\t\tbool skip_orig = false;\n\n\t\t\tfor (alt = insn->alts; alt; alt = alt->next) {\n\t\t\t\tif (alt->skip_orig)\n\t\t\t\t\tskip_orig = true;\n\n\t\t\t\tret = validate_unret(file, alt->insn);\n\t\t\t\tif (ret) {\n\t\t\t\t\tBT_INSN(insn, \"(alt)\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip_orig)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tswitch (insn->type) {\n\n\t\tcase INSN_CALL_DYNAMIC:\n\t\tcase INSN_JUMP_DYNAMIC:\n\t\tcase INSN_JUMP_DYNAMIC_CONDITIONAL:\n\t\t\tWARN_INSN(insn, \"early indirect call\");\n\t\t\treturn 1;\n\n\t\tcase INSN_JUMP_UNCONDITIONAL:\n\t\tcase INSN_JUMP_CONDITIONAL:\n\t\t\tif (!is_sibling_call(insn)) {\n\t\t\t\tif (!insn->jump_dest) {\n\t\t\t\t\tWARN_INSN(insn, \"unresolved jump target after linking?!?\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tret = validate_unret(file, insn->jump_dest);\n\t\t\t\tif (ret) {\n\t\t\t\t\tBT_INSN(insn, \"(branch%s)\",\n\t\t\t\t\t\tinsn->type == INSN_JUMP_CONDITIONAL ? \"-cond\" : \"\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tif (insn->type == INSN_JUMP_UNCONDITIONAL)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\tcase INSN_CALL:\n\t\t\tdest = find_insn(file, insn_call_dest(insn)->sec,\n\t\t\t\t\t insn_call_dest(insn)->offset);\n\t\t\tif (!dest) {\n\t\t\t\tWARN(\"Unresolved function after linking!?: %s\",\n\t\t\t\t     insn_call_dest(insn)->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tret = validate_unret(file, dest);\n\t\t\tif (ret) {\n\t\t\t\tBT_INSN(insn, \"(call)\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t \n\t\t\treturn 0;\n\n\t\tcase INSN_RETURN:\n\t\t\tWARN_INSN(insn, \"RET before UNTRAIN\");\n\t\t\treturn 1;\n\n\t\tcase INSN_NOP:\n\t\t\tif (insn->retpoline_safe)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!next) {\n\t\t\tWARN_INSN(insn, \"teh end!\");\n\t\t\treturn -1;\n\t\t}\n\t\tinsn = next;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int validate_unrets(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tint ret, warnings = 0;\n\n\tfor_each_insn(file, insn) {\n\t\tif (!insn->unret)\n\t\t\tcontinue;\n\n\t\tret = validate_unret(file, insn);\n\t\tif (ret < 0) {\n\t\t\tWARN_INSN(insn, \"Failed UNRET validation\");\n\t\t\treturn ret;\n\t\t}\n\t\twarnings += ret;\n\t}\n\n\treturn warnings;\n}\n\nstatic int validate_retpoline(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tint warnings = 0;\n\n\tfor_each_insn(file, insn) {\n\t\tif (insn->type != INSN_JUMP_DYNAMIC &&\n\t\t    insn->type != INSN_CALL_DYNAMIC &&\n\t\t    insn->type != INSN_RETURN)\n\t\t\tcontinue;\n\n\t\tif (insn->retpoline_safe)\n\t\t\tcontinue;\n\n\t\tif (insn->sec->init)\n\t\t\tcontinue;\n\n\t\tif (insn->type == INSN_RETURN) {\n\t\t\tif (opts.rethunk) {\n\t\t\t\tWARN_INSN(insn, \"'naked' return found in RETHUNK build\");\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tWARN_INSN(insn, \"indirect %s found in RETPOLINE build\",\n\t\t\t\t  insn->type == INSN_JUMP_DYNAMIC ? \"jump\" : \"call\");\n\t\t}\n\n\t\twarnings++;\n\t}\n\n\treturn warnings;\n}\n\nstatic bool is_kasan_insn(struct instruction *insn)\n{\n\treturn (insn->type == INSN_CALL &&\n\t\t!strcmp(insn_call_dest(insn)->name, \"__asan_handle_no_return\"));\n}\n\nstatic bool is_ubsan_insn(struct instruction *insn)\n{\n\treturn (insn->type == INSN_CALL &&\n\t\t!strcmp(insn_call_dest(insn)->name,\n\t\t\t\"__ubsan_handle_builtin_unreachable\"));\n}\n\nstatic bool ignore_unreachable_insn(struct objtool_file *file, struct instruction *insn)\n{\n\tint i;\n\tstruct instruction *prev_insn;\n\n\tif (insn->ignore || insn->type == INSN_NOP || insn->type == INSN_TRAP)\n\t\treturn true;\n\n\t \n\tif (!strcmp(insn->sec->name, \".altinstr_replacement\") ||\n\t    !strcmp(insn->sec->name, \".altinstr_aux\"))\n\t\treturn true;\n\n\t \n\tif (opts.link && !insn_func(insn)) {\n\t\tint size = find_symbol_hole_containing(insn->sec, insn->offset);\n\t\tunsigned long end = insn->offset + size;\n\n\t\tif (!size)  \n\t\t\treturn false;\n\n\t\tif (size < 0)  \n\t\t\treturn true;\n\n\t\tsec_for_each_insn_continue(file, insn) {\n\t\t\t \n\t\t\tif (insn->visited)\n\t\t\t\treturn true;\n\n\t\t\tif (insn->offset >= end)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (insn->jump_dest && insn_func(insn->jump_dest) &&\n\t\t\t    strstr(insn_func(insn->jump_dest)->name, \".cold\")) {\n\t\t\t\tstruct instruction *dest = insn->jump_dest;\n\t\t\t\tfunc_for_each_insn(file, insn_func(dest), dest)\n\t\t\t\t\tdest->ignore = true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tif (!insn_func(insn))\n\t\treturn false;\n\n\tif (insn_func(insn)->static_call_tramp)\n\t\treturn true;\n\n\t \n\tprev_insn = prev_insn_same_sec(file, insn);\n\tif (prev_insn->dead_end &&\n\t    (insn->type == INSN_BUG ||\n\t     (insn->type == INSN_JUMP_UNCONDITIONAL &&\n\t      insn->jump_dest && insn->jump_dest->type == INSN_BUG)))\n\t\treturn true;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\n\t\tif (is_kasan_insn(insn) || is_ubsan_insn(insn))\n\t\t\treturn true;\n\n\t\tif (insn->type == INSN_JUMP_UNCONDITIONAL) {\n\t\t\tif (insn->jump_dest &&\n\t\t\t    insn_func(insn->jump_dest) == insn_func(insn)) {\n\t\t\t\tinsn = insn->jump_dest;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (insn->offset + insn->len >= insn_func(insn)->offset + insn_func(insn)->len)\n\t\t\tbreak;\n\n\t\tinsn = next_insn_same_sec(file, insn);\n\t}\n\n\treturn false;\n}\n\nstatic int add_prefix_symbol(struct objtool_file *file, struct symbol *func)\n{\n\tstruct instruction *insn, *prev;\n\tstruct cfi_state *cfi;\n\n\tinsn = find_insn(file, func->sec, func->offset);\n\tif (!insn)\n\t\treturn -1;\n\n\tfor (prev = prev_insn_same_sec(file, insn);\n\t     prev;\n\t     prev = prev_insn_same_sec(file, prev)) {\n\t\tu64 offset;\n\n\t\tif (prev->type != INSN_NOP)\n\t\t\treturn -1;\n\n\t\toffset = func->offset - prev->offset;\n\n\t\tif (offset > opts.prefix)\n\t\t\treturn -1;\n\n\t\tif (offset < opts.prefix)\n\t\t\tcontinue;\n\n\t\telf_create_prefix_symbol(file->elf, func, opts.prefix);\n\t\tbreak;\n\t}\n\n\tif (!prev)\n\t\treturn -1;\n\n\tif (!insn->cfi) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tcfi = cfi_hash_find_or_add(insn->cfi);\n\tfor (; prev != insn; prev = next_insn_same_sec(file, prev))\n\t\tprev->cfi = cfi;\n\n\treturn 0;\n}\n\nstatic int add_prefix_symbols(struct objtool_file *file)\n{\n\tstruct section *sec;\n\tstruct symbol *func;\n\n\tfor_each_sec(file, sec) {\n\t\tif (!(sec->sh.sh_flags & SHF_EXECINSTR))\n\t\t\tcontinue;\n\n\t\tsec_for_each_sym(sec, func) {\n\t\t\tif (func->type != STT_FUNC)\n\t\t\t\tcontinue;\n\n\t\t\tadd_prefix_symbol(file, func);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_symbol(struct objtool_file *file, struct section *sec,\n\t\t\t   struct symbol *sym, struct insn_state *state)\n{\n\tstruct instruction *insn;\n\tint ret;\n\n\tif (!sym->len) {\n\t\tWARN(\"%s() is missing an ELF size annotation\", sym->name);\n\t\treturn 1;\n\t}\n\n\tif (sym->pfunc != sym || sym->alias != sym)\n\t\treturn 0;\n\n\tinsn = find_insn(file, sec, sym->offset);\n\tif (!insn || insn->ignore || insn->visited)\n\t\treturn 0;\n\n\tstate->uaccess = sym->uaccess_safe;\n\n\tret = validate_branch(file, insn_func(insn), insn, *state);\n\tif (ret)\n\t\tBT_INSN(insn, \"<=== (sym)\");\n\treturn ret;\n}\n\nstatic int validate_section(struct objtool_file *file, struct section *sec)\n{\n\tstruct insn_state state;\n\tstruct symbol *func;\n\tint warnings = 0;\n\n\tsec_for_each_sym(sec, func) {\n\t\tif (func->type != STT_FUNC)\n\t\t\tcontinue;\n\n\t\tinit_insn_state(file, &state, sec);\n\t\tset_func_state(&state.cfi);\n\n\t\twarnings += validate_symbol(file, sec, func, &state);\n\t}\n\n\treturn warnings;\n}\n\nstatic int validate_noinstr_sections(struct objtool_file *file)\n{\n\tstruct section *sec;\n\tint warnings = 0;\n\n\tsec = find_section_by_name(file->elf, \".noinstr.text\");\n\tif (sec) {\n\t\twarnings += validate_section(file, sec);\n\t\twarnings += validate_unwind_hints(file, sec);\n\t}\n\n\tsec = find_section_by_name(file->elf, \".entry.text\");\n\tif (sec) {\n\t\twarnings += validate_section(file, sec);\n\t\twarnings += validate_unwind_hints(file, sec);\n\t}\n\n\tsec = find_section_by_name(file->elf, \".cpuidle.text\");\n\tif (sec) {\n\t\twarnings += validate_section(file, sec);\n\t\twarnings += validate_unwind_hints(file, sec);\n\t}\n\n\treturn warnings;\n}\n\nstatic int validate_functions(struct objtool_file *file)\n{\n\tstruct section *sec;\n\tint warnings = 0;\n\n\tfor_each_sec(file, sec) {\n\t\tif (!(sec->sh.sh_flags & SHF_EXECINSTR))\n\t\t\tcontinue;\n\n\t\twarnings += validate_section(file, sec);\n\t}\n\n\treturn warnings;\n}\n\nstatic void mark_endbr_used(struct instruction *insn)\n{\n\tif (!list_empty(&insn->call_node))\n\t\tlist_del_init(&insn->call_node);\n}\n\nstatic bool noendbr_range(struct objtool_file *file, struct instruction *insn)\n{\n\tstruct symbol *sym = find_symbol_containing(insn->sec, insn->offset-1);\n\tstruct instruction *first;\n\n\tif (!sym)\n\t\treturn false;\n\n\tfirst = find_insn(file, sym->sec, sym->offset);\n\tif (!first)\n\t\treturn false;\n\n\tif (first->type != INSN_ENDBR && !first->noendbr)\n\t\treturn false;\n\n\treturn insn->offset == sym->offset + sym->len;\n}\n\nstatic int validate_ibt_insn(struct objtool_file *file, struct instruction *insn)\n{\n\tstruct instruction *dest;\n\tstruct reloc *reloc;\n\tunsigned long off;\n\tint warnings = 0;\n\n\t \n\tswitch (insn->type) {\n\tcase INSN_CALL:\n\tcase INSN_CALL_DYNAMIC:\n\tcase INSN_JUMP_CONDITIONAL:\n\tcase INSN_JUMP_UNCONDITIONAL:\n\tcase INSN_JUMP_DYNAMIC:\n\tcase INSN_JUMP_DYNAMIC_CONDITIONAL:\n\tcase INSN_RETURN:\n\tcase INSN_NOP:\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (reloc = insn_reloc(file, insn);\n\t     reloc;\n\t     reloc = find_reloc_by_dest_range(file->elf, insn->sec,\n\t\t\t\t\t      reloc_offset(reloc) + 1,\n\t\t\t\t\t      (insn->offset + insn->len) - (reloc_offset(reloc) + 1))) {\n\n\t\t \n\t\tif (reloc->sym->static_call_tramp)\n\t\t\tcontinue;\n\n\t\toff = reloc->sym->offset;\n\t\tif (reloc_type(reloc) == R_X86_64_PC32 ||\n\t\t    reloc_type(reloc) == R_X86_64_PLT32)\n\t\t\toff += arch_dest_reloc_offset(reloc_addend(reloc));\n\t\telse\n\t\t\toff += reloc_addend(reloc);\n\n\t\tdest = find_insn(file, reloc->sym->sec, off);\n\t\tif (!dest)\n\t\t\tcontinue;\n\n\t\tif (dest->type == INSN_ENDBR) {\n\t\t\tmark_endbr_used(dest);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn_func(dest) && insn_func(insn) &&\n\t\t    insn_func(dest)->pfunc == insn_func(insn)->pfunc) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (dest->noendbr)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (noendbr_range(file, dest))\n\t\t\tcontinue;\n\n\t\tWARN_INSN(insn, \"relocation to !ENDBR: %s\", offstr(dest->sec, dest->offset));\n\n\t\twarnings++;\n\t}\n\n\treturn warnings;\n}\n\nstatic int validate_ibt_data_reloc(struct objtool_file *file,\n\t\t\t\t   struct reloc *reloc)\n{\n\tstruct instruction *dest;\n\n\tdest = find_insn(file, reloc->sym->sec,\n\t\t\t reloc->sym->offset + reloc_addend(reloc));\n\tif (!dest)\n\t\treturn 0;\n\n\tif (dest->type == INSN_ENDBR) {\n\t\tmark_endbr_used(dest);\n\t\treturn 0;\n\t}\n\n\tif (dest->noendbr)\n\t\treturn 0;\n\n\tWARN_FUNC(\"data relocation to !ENDBR: %s\",\n\t\t  reloc->sec->base, reloc_offset(reloc),\n\t\t  offstr(dest->sec, dest->offset));\n\n\treturn 1;\n}\n\n \nstatic int validate_ibt(struct objtool_file *file)\n{\n\tstruct section *sec;\n\tstruct reloc *reloc;\n\tstruct instruction *insn;\n\tint warnings = 0;\n\n\tfor_each_insn(file, insn)\n\t\twarnings += validate_ibt_insn(file, insn);\n\n\tfor_each_sec(file, sec) {\n\n\t\t \n\t\tif (sec->sh.sh_flags & SHF_EXECINSTR)\n\t\t\tcontinue;\n\n\t\tif (!sec->rsec)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((!strncmp(sec->name, \".discard\", 8) &&\n\t\t     strcmp(sec->name, \".discard.ibt_endbr_noseal\"))\t||\n\t\t    !strncmp(sec->name, \".debug\", 6)\t\t\t||\n\t\t    !strcmp(sec->name, \".altinstructions\")\t\t||\n\t\t    !strcmp(sec->name, \".ibt_endbr_seal\")\t\t||\n\t\t    !strcmp(sec->name, \".orc_unwind_ip\")\t\t||\n\t\t    !strcmp(sec->name, \".parainstructions\")\t\t||\n\t\t    !strcmp(sec->name, \".retpoline_sites\")\t\t||\n\t\t    !strcmp(sec->name, \".smp_locks\")\t\t\t||\n\t\t    !strcmp(sec->name, \".static_call_sites\")\t\t||\n\t\t    !strcmp(sec->name, \"_error_injection_whitelist\")\t||\n\t\t    !strcmp(sec->name, \"_kprobe_blacklist\")\t\t||\n\t\t    !strcmp(sec->name, \"__bug_table\")\t\t\t||\n\t\t    !strcmp(sec->name, \"__ex_table\")\t\t\t||\n\t\t    !strcmp(sec->name, \"__jump_table\")\t\t\t||\n\t\t    !strcmp(sec->name, \"__mcount_loc\")\t\t\t||\n\t\t    !strcmp(sec->name, \".kcfi_traps\")\t\t\t||\n\t\t    strstr(sec->name, \"__patchable_function_entries\"))\n\t\t\tcontinue;\n\n\t\tfor_each_reloc(sec->rsec, reloc)\n\t\t\twarnings += validate_ibt_data_reloc(file, reloc);\n\t}\n\n\treturn warnings;\n}\n\nstatic int validate_sls(struct objtool_file *file)\n{\n\tstruct instruction *insn, *next_insn;\n\tint warnings = 0;\n\n\tfor_each_insn(file, insn) {\n\t\tnext_insn = next_insn_same_sec(file, insn);\n\n\t\tif (insn->retpoline_safe)\n\t\t\tcontinue;\n\n\t\tswitch (insn->type) {\n\t\tcase INSN_RETURN:\n\t\t\tif (!next_insn || next_insn->type != INSN_TRAP) {\n\t\t\t\tWARN_INSN(insn, \"missing int3 after ret\");\n\t\t\t\twarnings++;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase INSN_JUMP_DYNAMIC:\n\t\t\tif (!next_insn || next_insn->type != INSN_TRAP) {\n\t\t\t\tWARN_INSN(insn, \"missing int3 after indirect jump\");\n\t\t\t\twarnings++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn warnings;\n}\n\nstatic bool ignore_noreturn_call(struct instruction *insn)\n{\n\tstruct symbol *call_dest = insn_call_dest(insn);\n\n\t \n\tif (!strcmp(call_dest->name, \"exc_double_fault\")) {\n\t\t \n\t\tinsn->sym->warned = 1;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int validate_reachable_instructions(struct objtool_file *file)\n{\n\tstruct instruction *insn, *prev_insn;\n\tstruct symbol *call_dest;\n\tint warnings = 0;\n\n\tif (file->ignore_unreachables)\n\t\treturn 0;\n\n\tfor_each_insn(file, insn) {\n\t\tif (insn->visited || ignore_unreachable_insn(file, insn))\n\t\t\tcontinue;\n\n\t\tprev_insn = prev_insn_same_sec(file, insn);\n\t\tif (prev_insn && prev_insn->dead_end) {\n\t\t\tcall_dest = insn_call_dest(prev_insn);\n\t\t\tif (call_dest && !ignore_noreturn_call(prev_insn)) {\n\t\t\t\tWARN_INSN(insn, \"%s() is missing a __noreturn annotation\",\n\t\t\t\t\t  call_dest->name);\n\t\t\t\twarnings++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tWARN_INSN(insn, \"unreachable instruction\");\n\t\twarnings++;\n\t}\n\n\treturn warnings;\n}\n\n \nstatic int disas_funcs(const char *funcs)\n{\n\tconst char *objdump_str, *cross_compile;\n\tint size, ret;\n\tchar *cmd;\n\n\tcross_compile = getenv(\"CROSS_COMPILE\");\n\n\tobjdump_str = \"%sobjdump -wdr %s | gawk -M -v _funcs='%s' '\"\n\t\t\t\"BEGIN { split(_funcs, funcs); }\"\n\t\t\t\"/^$/ { func_match = 0; }\"\n\t\t\t\"/<.*>:/ { \"\n\t\t\t\t\"f = gensub(/.*<(.*)>:/, \\\"\\\\\\\\1\\\", 1);\"\n\t\t\t\t\"for (i in funcs) {\"\n\t\t\t\t\t\"if (funcs[i] == f) {\"\n\t\t\t\t\t\t\"func_match = 1;\"\n\t\t\t\t\t\t\"base = strtonum(\\\"0x\\\" $1);\"\n\t\t\t\t\t\t\"break;\"\n\t\t\t\t\t\"}\"\n\t\t\t\t\"}\"\n\t\t\t\"}\"\n\t\t\t\"{\"\n\t\t\t\t\"if (func_match) {\"\n\t\t\t\t\t\"addr = strtonum(\\\"0x\\\" $1);\"\n\t\t\t\t\t\"printf(\\\"%%04x \\\", addr - base);\"\n\t\t\t\t\t\"print;\"\n\t\t\t\t\"}\"\n\t\t\t\"}' 1>&2\";\n\n\t \n\tsize = snprintf(NULL, 0, objdump_str, cross_compile, objname, funcs) + 1;\n\tif (size <= 0) {\n\t\tWARN(\"objdump string size calculation failed\");\n\t\treturn -1;\n\t}\n\n\tcmd = malloc(size);\n\n\t \n\tsnprintf(cmd, size, objdump_str, cross_compile, objname, funcs);\n\tret = system(cmd);\n\tif (ret) {\n\t\tWARN(\"disassembly failed: %d\", ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int disas_warned_funcs(struct objtool_file *file)\n{\n\tstruct symbol *sym;\n\tchar *funcs = NULL, *tmp;\n\n\tfor_each_sym(file, sym) {\n\t\tif (sym->warned) {\n\t\t\tif (!funcs) {\n\t\t\t\tfuncs = malloc(strlen(sym->name) + 1);\n\t\t\t\tstrcpy(funcs, sym->name);\n\t\t\t} else {\n\t\t\t\ttmp = malloc(strlen(funcs) + strlen(sym->name) + 2);\n\t\t\t\tsprintf(tmp, \"%s %s\", funcs, sym->name);\n\t\t\t\tfree(funcs);\n\t\t\t\tfuncs = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (funcs)\n\t\tdisas_funcs(funcs);\n\n\treturn 0;\n}\n\nstruct insn_chunk {\n\tvoid *addr;\n\tstruct insn_chunk *next;\n};\n\n \nstatic void free_insns(struct objtool_file *file)\n{\n\tstruct instruction *insn;\n\tstruct insn_chunk *chunks = NULL, *chunk;\n\n\tfor_each_insn(file, insn) {\n\t\tif (!insn->idx) {\n\t\t\tchunk = malloc(sizeof(*chunk));\n\t\t\tchunk->addr = insn;\n\t\t\tchunk->next = chunks;\n\t\t\tchunks = chunk;\n\t\t}\n\t}\n\n\tfor (chunk = chunks; chunk; chunk = chunk->next)\n\t\tfree(chunk->addr);\n}\n\nint check(struct objtool_file *file)\n{\n\tint ret, warnings = 0;\n\n\tarch_initial_func_cfi_state(&initial_func_cfi);\n\tinit_cfi_state(&init_cfi);\n\tinit_cfi_state(&func_cfi);\n\tset_func_state(&func_cfi);\n\tinit_cfi_state(&force_undefined_cfi);\n\tforce_undefined_cfi.force_undefined = true;\n\n\tif (!cfi_hash_alloc(1UL << (file->elf->symbol_bits - 3)))\n\t\tgoto out;\n\n\tcfi_hash_add(&init_cfi);\n\tcfi_hash_add(&func_cfi);\n\n\tret = decode_sections(file);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twarnings += ret;\n\n\tif (!nr_insns)\n\t\tgoto out;\n\n\tif (opts.retpoline) {\n\t\tret = validate_retpoline(file);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.stackval || opts.orc || opts.uaccess) {\n\t\tret = validate_functions(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\n\t\tret = validate_unwind_hints(file, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\n\t\tif (!warnings) {\n\t\t\tret = validate_reachable_instructions(file);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\twarnings += ret;\n\t\t}\n\n\t} else if (opts.noinstr) {\n\t\tret = validate_noinstr_sections(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.unret) {\n\t\t \n\t\tret = validate_unrets(file);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.ibt) {\n\t\tret = validate_ibt(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.sls) {\n\t\tret = validate_sls(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.static_call) {\n\t\tret = create_static_call_sections(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.retpoline) {\n\t\tret = create_retpoline_sites_sections(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.cfi) {\n\t\tret = create_cfi_sections(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.rethunk) {\n\t\tret = create_return_sites_sections(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\n\t\tif (opts.hack_skylake) {\n\t\t\tret = create_direct_call_sections(file);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\twarnings += ret;\n\t\t}\n\t}\n\n\tif (opts.mcount) {\n\t\tret = create_mcount_loc_sections(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.prefix) {\n\t\tret = add_prefix_symbols(file);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.ibt) {\n\t\tret = create_ibt_endbr_seal_sections(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\t}\n\n\tif (opts.orc && nr_insns) {\n\t\tret = orc_create(file);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twarnings += ret;\n\t}\n\n\tfree_insns(file);\n\n\tif (opts.verbose)\n\t\tdisas_warned_funcs(file);\n\n\tif (opts.stats) {\n\t\tprintf(\"nr_insns_visited: %ld\\n\", nr_insns_visited);\n\t\tprintf(\"nr_cfi: %ld\\n\", nr_cfi);\n\t\tprintf(\"nr_cfi_reused: %ld\\n\", nr_cfi_reused);\n\t\tprintf(\"nr_cfi_cache: %ld\\n\", nr_cfi_cache);\n\t}\n\nout:\n\t \n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}