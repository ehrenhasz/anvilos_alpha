{
  "module_name": "special.c",
  "hash_id": "ec023afdd01e940231516ca2872be38f2b4b4953539b1eb7f0413253f4a8994f",
  "original_prompt": "Ingested from linux-6.6.14/tools/objtool/special.c",
  "human_readable_source": "\n \n\n \n\n#include <stdlib.h>\n#include <string.h>\n\n#include <arch/special.h>\n#include <objtool/builtin.h>\n#include <objtool/special.h>\n#include <objtool/warn.h>\n#include <objtool/endianness.h>\n\nstruct special_entry {\n\tconst char *sec;\n\tbool group, jump_or_nop;\n\tunsigned char size, orig, new;\n\tunsigned char orig_len, new_len;  \n\tunsigned char feature;  \n\tunsigned char key;  \n};\n\nstatic const struct special_entry entries[] = {\n\t{\n\t\t.sec = \".altinstructions\",\n\t\t.group = true,\n\t\t.size = ALT_ENTRY_SIZE,\n\t\t.orig = ALT_ORIG_OFFSET,\n\t\t.orig_len = ALT_ORIG_LEN_OFFSET,\n\t\t.new = ALT_NEW_OFFSET,\n\t\t.new_len = ALT_NEW_LEN_OFFSET,\n\t\t.feature = ALT_FEATURE_OFFSET,\n\t},\n\t{\n\t\t.sec = \"__jump_table\",\n\t\t.jump_or_nop = true,\n\t\t.size = JUMP_ENTRY_SIZE,\n\t\t.orig = JUMP_ORIG_OFFSET,\n\t\t.new = JUMP_NEW_OFFSET,\n\t\t.key = JUMP_KEY_OFFSET,\n\t},\n\t{\n\t\t.sec = \"__ex_table\",\n\t\t.size = EX_ENTRY_SIZE,\n\t\t.orig = EX_ORIG_OFFSET,\n\t\t.new = EX_NEW_OFFSET,\n\t},\n\t{},\n};\n\nvoid __weak arch_handle_alternative(unsigned short feature, struct special_alt *alt)\n{\n}\n\nstatic void reloc_to_sec_off(struct reloc *reloc, struct section **sec,\n\t\t\t     unsigned long *off)\n{\n\t*sec = reloc->sym->sec;\n\t*off = reloc->sym->offset + reloc_addend(reloc);\n}\n\nstatic int get_alt_entry(struct elf *elf, const struct special_entry *entry,\n\t\t\t struct section *sec, int idx,\n\t\t\t struct special_alt *alt)\n{\n\tstruct reloc *orig_reloc, *new_reloc;\n\tunsigned long offset;\n\n\toffset = idx * entry->size;\n\n\talt->group = entry->group;\n\talt->jump_or_nop = entry->jump_or_nop;\n\n\tif (alt->group) {\n\t\talt->orig_len = *(unsigned char *)(sec->data->d_buf + offset +\n\t\t\t\t\t\t   entry->orig_len);\n\t\talt->new_len = *(unsigned char *)(sec->data->d_buf + offset +\n\t\t\t\t\t\t  entry->new_len);\n\t}\n\n\tif (entry->feature) {\n\t\tunsigned short feature;\n\n\t\tfeature = bswap_if_needed(elf,\n\t\t\t\t\t  *(unsigned short *)(sec->data->d_buf +\n\t\t\t\t\t\t\t      offset +\n\t\t\t\t\t\t\t      entry->feature));\n\t\tarch_handle_alternative(feature, alt);\n\t}\n\n\torig_reloc = find_reloc_by_dest(elf, sec, offset + entry->orig);\n\tif (!orig_reloc) {\n\t\tWARN_FUNC(\"can't find orig reloc\", sec, offset + entry->orig);\n\t\treturn -1;\n\t}\n\n\treloc_to_sec_off(orig_reloc, &alt->orig_sec, &alt->orig_off);\n\n\tif (!entry->group || alt->new_len) {\n\t\tnew_reloc = find_reloc_by_dest(elf, sec, offset + entry->new);\n\t\tif (!new_reloc) {\n\t\t\tWARN_FUNC(\"can't find new reloc\",\n\t\t\t\t  sec, offset + entry->new);\n\t\t\treturn -1;\n\t\t}\n\n\t\treloc_to_sec_off(new_reloc, &alt->new_sec, &alt->new_off);\n\n\t\t \n\t\tif (alt->new_off >= 0x7ffffff0)\n\t\t\talt->new_off -= 0x7ffffff0;\n\t}\n\n\tif (entry->key) {\n\t\tstruct reloc *key_reloc;\n\n\t\tkey_reloc = find_reloc_by_dest(elf, sec, offset + entry->key);\n\t\tif (!key_reloc) {\n\t\t\tWARN_FUNC(\"can't find key reloc\",\n\t\t\t\t  sec, offset + entry->key);\n\t\t\treturn -1;\n\t\t}\n\t\talt->key_addend = reloc_addend(key_reloc);\n\t}\n\n\treturn 0;\n}\n\n \nint special_get_alts(struct elf *elf, struct list_head *alts)\n{\n\tconst struct special_entry *entry;\n\tstruct section *sec;\n\tunsigned int nr_entries;\n\tstruct special_alt *alt;\n\tint idx, ret;\n\n\tINIT_LIST_HEAD(alts);\n\n\tfor (entry = entries; entry->sec; entry++) {\n\t\tsec = find_section_by_name(elf, entry->sec);\n\t\tif (!sec)\n\t\t\tcontinue;\n\n\t\tif (sec->sh.sh_size % entry->size != 0) {\n\t\t\tWARN(\"%s size not a multiple of %d\",\n\t\t\t     sec->name, entry->size);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnr_entries = sec->sh.sh_size / entry->size;\n\n\t\tfor (idx = 0; idx < nr_entries; idx++) {\n\t\t\talt = malloc(sizeof(*alt));\n\t\t\tif (!alt) {\n\t\t\t\tWARN(\"malloc failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmemset(alt, 0, sizeof(*alt));\n\n\t\t\tret = get_alt_entry(elf, entry, sec, idx, alt);\n\t\t\tif (ret > 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tlist_add_tail(&alt->list, alts);\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}