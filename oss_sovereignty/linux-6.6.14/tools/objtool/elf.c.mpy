{
  "module_name": "elf.c",
  "hash_id": "72389575c5d147eb4017dd2ac5af1fe70f4252abca14f1fd3e211fea79b17002",
  "original_prompt": "Ingested from linux-6.6.14/tools/objtool/elf.c",
  "human_readable_source": "\n \n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <linux/interval_tree_generic.h>\n#include <objtool/builtin.h>\n\n#include <objtool/elf.h>\n#include <objtool/warn.h>\n\n#define MAX_NAME_LEN 128\n\nstatic inline u32 str_hash(const char *str)\n{\n\treturn jhash(str, strlen(str), 0);\n}\n\n#define __elf_table(name)\t(elf->name##_hash)\n#define __elf_bits(name)\t(elf->name##_bits)\n\n#define __elf_table_entry(name, key) \\\n\t__elf_table(name)[hash_min(key, __elf_bits(name))]\n\n#define elf_hash_add(name, node, key)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct elf_hash_node *__node = node;\t\t\t\t\\\n\t__node->next = __elf_table_entry(name, key);\t\t\t\\\n\t__elf_table_entry(name, key) = __node;\t\t\t\t\\\n})\n\nstatic inline void __elf_hash_del(struct elf_hash_node *node,\n\t\t\t\t  struct elf_hash_node **head)\n{\n\tstruct elf_hash_node *cur, *prev;\n\n\tif (node == *head) {\n\t\t*head = node->next;\n\t\treturn;\n\t}\n\n\tfor (prev = NULL, cur = *head; cur; prev = cur, cur = cur->next) {\n\t\tif (cur == node) {\n\t\t\tprev->next = cur->next;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n#define elf_hash_del(name, node, key) \\\n\t__elf_hash_del(node, &__elf_table_entry(name, key))\n\n#define elf_list_entry(ptr, type, member)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) __ptr = (ptr);\t\t\t\t\t\\\n\t__ptr ? container_of(__ptr, type, member) : NULL;\t\t\\\n})\n\n#define elf_hash_for_each_possible(name, obj, member, key)\t\t\\\n\tfor (obj = elf_list_entry(__elf_table_entry(name, key), typeof(*obj), member); \\\n\t     obj;\t\t\t\t\t\t\t\\\n\t     obj = elf_list_entry(obj->member.next, typeof(*(obj)), member))\n\n#define elf_alloc_hash(name, size) \\\n({ \\\n\t__elf_bits(name) = max(10, ilog2(size)); \\\n\t__elf_table(name) = mmap(NULL, sizeof(struct elf_hash_node *) << __elf_bits(name), \\\n\t\t\t\t PROT_READ|PROT_WRITE, \\\n\t\t\t\t MAP_PRIVATE|MAP_ANON, -1, 0); \\\n\tif (__elf_table(name) == (void *)-1L) { \\\n\t\tWARN(\"mmap fail \" #name); \\\n\t\t__elf_table(name) = NULL; \\\n\t} \\\n\t__elf_table(name); \\\n})\n\nstatic inline unsigned long __sym_start(struct symbol *s)\n{\n\treturn s->offset;\n}\n\nstatic inline unsigned long __sym_last(struct symbol *s)\n{\n\treturn s->offset + s->len - 1;\n}\n\nINTERVAL_TREE_DEFINE(struct symbol, node, unsigned long, __subtree_last,\n\t\t     __sym_start, __sym_last, static, __sym)\n\n#define __sym_for_each(_iter, _tree, _start, _end)\t\t\t\\\n\tfor (_iter = __sym_iter_first((_tree), (_start), (_end));\t\\\n\t     _iter; _iter = __sym_iter_next(_iter, (_start), (_end)))\n\nstruct symbol_hole {\n\tunsigned long key;\n\tconst struct symbol *sym;\n};\n\n \nstatic int symbol_hole_by_offset(const void *key, const struct rb_node *node)\n{\n\tconst struct symbol *s = rb_entry(node, struct symbol, node);\n\tstruct symbol_hole *sh = (void *)key;\n\n\tif (sh->key < s->offset)\n\t\treturn -1;\n\n\tif (sh->key >= s->offset + s->len) {\n\t\tif (s->type != STT_SECTION)\n\t\t\tsh->sym = s;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstruct section *find_section_by_name(const struct elf *elf, const char *name)\n{\n\tstruct section *sec;\n\n\telf_hash_for_each_possible(section_name, sec, name_hash, str_hash(name)) {\n\t\tif (!strcmp(sec->name, name))\n\t\t\treturn sec;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct section *find_section_by_index(struct elf *elf,\n\t\t\t\t\t     unsigned int idx)\n{\n\tstruct section *sec;\n\n\telf_hash_for_each_possible(section, sec, hash, idx) {\n\t\tif (sec->idx == idx)\n\t\t\treturn sec;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct symbol *find_symbol_by_index(struct elf *elf, unsigned int idx)\n{\n\tstruct symbol *sym;\n\n\telf_hash_for_each_possible(symbol, sym, hash, idx) {\n\t\tif (sym->idx == idx)\n\t\t\treturn sym;\n\t}\n\n\treturn NULL;\n}\n\nstruct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset)\n{\n\tstruct rb_root_cached *tree = (struct rb_root_cached *)&sec->symbol_tree;\n\tstruct symbol *iter;\n\n\t__sym_for_each(iter, tree, offset, offset) {\n\t\tif (iter->offset == offset && iter->type != STT_SECTION)\n\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\nstruct symbol *find_func_by_offset(struct section *sec, unsigned long offset)\n{\n\tstruct rb_root_cached *tree = (struct rb_root_cached *)&sec->symbol_tree;\n\tstruct symbol *iter;\n\n\t__sym_for_each(iter, tree, offset, offset) {\n\t\tif (iter->offset == offset && iter->type == STT_FUNC)\n\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\nstruct symbol *find_symbol_containing(const struct section *sec, unsigned long offset)\n{\n\tstruct rb_root_cached *tree = (struct rb_root_cached *)&sec->symbol_tree;\n\tstruct symbol *iter;\n\n\t__sym_for_each(iter, tree, offset, offset) {\n\t\tif (iter->type != STT_SECTION)\n\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\n \nint find_symbol_hole_containing(const struct section *sec, unsigned long offset)\n{\n\tstruct symbol_hole hole = {\n\t\t.key = offset,\n\t\t.sym = NULL,\n\t};\n\tstruct rb_node *n;\n\tstruct symbol *s;\n\n\t \n\tn = rb_find(&hole, &sec->symbol_tree.rb_root, symbol_hole_by_offset);\n\n\t \n\tif (n)\n\t\treturn 0;  \n\n\t \n\tif (!hole.sym)\n\t\treturn 0;  \n\n\t \n\tn = rb_next(&hole.sym->node);\n\tif (!n)\n\t\treturn -1;  \n\n\t \n\ts = rb_entry(n, struct symbol, node);\n\treturn s->offset - offset;\n}\n\nstruct symbol *find_func_containing(struct section *sec, unsigned long offset)\n{\n\tstruct rb_root_cached *tree = (struct rb_root_cached *)&sec->symbol_tree;\n\tstruct symbol *iter;\n\n\t__sym_for_each(iter, tree, offset, offset) {\n\t\tif (iter->type == STT_FUNC)\n\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\nstruct symbol *find_symbol_by_name(const struct elf *elf, const char *name)\n{\n\tstruct symbol *sym;\n\n\telf_hash_for_each_possible(symbol_name, sym, name_hash, str_hash(name)) {\n\t\tif (!strcmp(sym->name, name))\n\t\t\treturn sym;\n\t}\n\n\treturn NULL;\n}\n\nstruct reloc *find_reloc_by_dest_range(const struct elf *elf, struct section *sec,\n\t\t\t\t     unsigned long offset, unsigned int len)\n{\n\tstruct reloc *reloc, *r = NULL;\n\tstruct section *rsec;\n\tunsigned long o;\n\n\trsec = sec->rsec;\n\tif (!rsec)\n\t\treturn NULL;\n\n\tfor_offset_range(o, offset, offset + len) {\n\t\telf_hash_for_each_possible(reloc, reloc, hash,\n\t\t\t\t\t   sec_offset_hash(rsec, o)) {\n\t\t\tif (reloc->sec != rsec)\n\t\t\t\tcontinue;\n\n\t\t\tif (reloc_offset(reloc) >= offset &&\n\t\t\t    reloc_offset(reloc) < offset + len) {\n\t\t\t\tif (!r || reloc_offset(reloc) < reloc_offset(r))\n\t\t\t\t\tr = reloc;\n\t\t\t}\n\t\t}\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn NULL;\n}\n\nstruct reloc *find_reloc_by_dest(const struct elf *elf, struct section *sec, unsigned long offset)\n{\n\treturn find_reloc_by_dest_range(elf, sec, offset, 1);\n}\n\nstatic bool is_dwarf_section(struct section *sec)\n{\n\treturn !strncmp(sec->name, \".debug_\", 7);\n}\n\nstatic int read_sections(struct elf *elf)\n{\n\tElf_Scn *s = NULL;\n\tstruct section *sec;\n\tsize_t shstrndx, sections_nr;\n\tint i;\n\n\tif (elf_getshdrnum(elf->elf, &sections_nr)) {\n\t\tWARN_ELF(\"elf_getshdrnum\");\n\t\treturn -1;\n\t}\n\n\tif (elf_getshdrstrndx(elf->elf, &shstrndx)) {\n\t\tWARN_ELF(\"elf_getshdrstrndx\");\n\t\treturn -1;\n\t}\n\n\tif (!elf_alloc_hash(section, sections_nr) ||\n\t    !elf_alloc_hash(section_name, sections_nr))\n\t\treturn -1;\n\n\telf->section_data = calloc(sections_nr, sizeof(*sec));\n\tif (!elf->section_data) {\n\t\tperror(\"calloc\");\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < sections_nr; i++) {\n\t\tsec = &elf->section_data[i];\n\n\t\tINIT_LIST_HEAD(&sec->symbol_list);\n\n\t\ts = elf_getscn(elf->elf, i);\n\t\tif (!s) {\n\t\t\tWARN_ELF(\"elf_getscn\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tsec->idx = elf_ndxscn(s);\n\n\t\tif (!gelf_getshdr(s, &sec->sh)) {\n\t\t\tWARN_ELF(\"gelf_getshdr\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tsec->name = elf_strptr(elf->elf, shstrndx, sec->sh.sh_name);\n\t\tif (!sec->name) {\n\t\t\tWARN_ELF(\"elf_strptr\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (sec->sh.sh_size != 0 && !is_dwarf_section(sec)) {\n\t\t\tsec->data = elf_getdata(s, NULL);\n\t\t\tif (!sec->data) {\n\t\t\t\tWARN_ELF(\"elf_getdata\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (sec->data->d_off != 0 ||\n\t\t\t    sec->data->d_size != sec->sh.sh_size) {\n\t\t\t\tWARN(\"unexpected data attributes for %s\",\n\t\t\t\t     sec->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tlist_add_tail(&sec->list, &elf->sections);\n\t\telf_hash_add(section, &sec->hash, sec->idx);\n\t\telf_hash_add(section_name, &sec->name_hash, str_hash(sec->name));\n\n\t\tif (is_reloc_sec(sec))\n\t\t\telf->num_relocs += sec_num_entries(sec);\n\t}\n\n\tif (opts.stats) {\n\t\tprintf(\"nr_sections: %lu\\n\", (unsigned long)sections_nr);\n\t\tprintf(\"section_bits: %d\\n\", elf->section_bits);\n\t}\n\n\t \n\tif (elf_nextscn(elf->elf, s)) {\n\t\tWARN(\"section entry mismatch\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void elf_add_symbol(struct elf *elf, struct symbol *sym)\n{\n\tstruct list_head *entry;\n\tstruct rb_node *pnode;\n\tstruct symbol *iter;\n\n\tINIT_LIST_HEAD(&sym->pv_target);\n\tsym->alias = sym;\n\n\tsym->type = GELF_ST_TYPE(sym->sym.st_info);\n\tsym->bind = GELF_ST_BIND(sym->sym.st_info);\n\n\tif (sym->type == STT_FILE)\n\t\telf->num_files++;\n\n\tsym->offset = sym->sym.st_value;\n\tsym->len = sym->sym.st_size;\n\n\t__sym_for_each(iter, &sym->sec->symbol_tree, sym->offset, sym->offset) {\n\t\tif (iter->offset == sym->offset && iter->type == sym->type)\n\t\t\titer->alias = sym;\n\t}\n\n\t__sym_insert(sym, &sym->sec->symbol_tree);\n\tpnode = rb_prev(&sym->node);\n\tif (pnode)\n\t\tentry = &rb_entry(pnode, struct symbol, node)->list;\n\telse\n\t\tentry = &sym->sec->symbol_list;\n\tlist_add(&sym->list, entry);\n\telf_hash_add(symbol, &sym->hash, sym->idx);\n\telf_hash_add(symbol_name, &sym->name_hash, str_hash(sym->name));\n\n\t \n\tif (!sym->len)\n\t\t__sym_remove(sym, &sym->sec->symbol_tree);\n}\n\nstatic int read_symbols(struct elf *elf)\n{\n\tstruct section *symtab, *symtab_shndx, *sec;\n\tstruct symbol *sym, *pfunc;\n\tint symbols_nr, i;\n\tchar *coldstr;\n\tElf_Data *shndx_data = NULL;\n\tElf32_Word shndx;\n\n\tsymtab = find_section_by_name(elf, \".symtab\");\n\tif (symtab) {\n\t\tsymtab_shndx = find_section_by_name(elf, \".symtab_shndx\");\n\t\tif (symtab_shndx)\n\t\t\tshndx_data = symtab_shndx->data;\n\n\t\tsymbols_nr = sec_num_entries(symtab);\n\t} else {\n\t\t \n\t\tsymbols_nr = 0;\n\t}\n\n\tif (!elf_alloc_hash(symbol, symbols_nr) ||\n\t    !elf_alloc_hash(symbol_name, symbols_nr))\n\t\treturn -1;\n\n\telf->symbol_data = calloc(symbols_nr, sizeof(*sym));\n\tif (!elf->symbol_data) {\n\t\tperror(\"calloc\");\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < symbols_nr; i++) {\n\t\tsym = &elf->symbol_data[i];\n\n\t\tsym->idx = i;\n\n\t\tif (!gelf_getsymshndx(symtab->data, shndx_data, i, &sym->sym,\n\t\t\t\t      &shndx)) {\n\t\t\tWARN_ELF(\"gelf_getsymshndx\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tsym->name = elf_strptr(elf->elf, symtab->sh.sh_link,\n\t\t\t\t       sym->sym.st_name);\n\t\tif (!sym->name) {\n\t\t\tWARN_ELF(\"elf_strptr\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif ((sym->sym.st_shndx > SHN_UNDEF &&\n\t\t     sym->sym.st_shndx < SHN_LORESERVE) ||\n\t\t    (shndx_data && sym->sym.st_shndx == SHN_XINDEX)) {\n\t\t\tif (sym->sym.st_shndx != SHN_XINDEX)\n\t\t\t\tshndx = sym->sym.st_shndx;\n\n\t\t\tsym->sec = find_section_by_index(elf, shndx);\n\t\t\tif (!sym->sec) {\n\t\t\t\tWARN(\"couldn't find section for symbol %s\",\n\t\t\t\t     sym->name);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (GELF_ST_TYPE(sym->sym.st_info) == STT_SECTION) {\n\t\t\t\tsym->name = sym->sec->name;\n\t\t\t\tsym->sec->sym = sym;\n\t\t\t}\n\t\t} else\n\t\t\tsym->sec = find_section_by_index(elf, 0);\n\n\t\telf_add_symbol(elf, sym);\n\t}\n\n\tif (opts.stats) {\n\t\tprintf(\"nr_symbols: %lu\\n\", (unsigned long)symbols_nr);\n\t\tprintf(\"symbol_bits: %d\\n\", elf->symbol_bits);\n\t}\n\n\t \n\tlist_for_each_entry(sec, &elf->sections, list) {\n\t\tsec_for_each_sym(sec, sym) {\n\t\t\tchar pname[MAX_NAME_LEN + 1];\n\t\t\tsize_t pnamelen;\n\t\t\tif (sym->type != STT_FUNC)\n\t\t\t\tcontinue;\n\n\t\t\tif (sym->pfunc == NULL)\n\t\t\t\tsym->pfunc = sym;\n\n\t\t\tif (sym->cfunc == NULL)\n\t\t\t\tsym->cfunc = sym;\n\n\t\t\tcoldstr = strstr(sym->name, \".cold\");\n\t\t\tif (!coldstr)\n\t\t\t\tcontinue;\n\n\t\t\tpnamelen = coldstr - sym->name;\n\t\t\tif (pnamelen > MAX_NAME_LEN) {\n\t\t\t\tWARN(\"%s(): parent function name exceeds maximum length of %d characters\",\n\t\t\t\t     sym->name, MAX_NAME_LEN);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstrncpy(pname, sym->name, pnamelen);\n\t\t\tpname[pnamelen] = '\\0';\n\t\t\tpfunc = find_symbol_by_name(elf, pname);\n\n\t\t\tif (!pfunc) {\n\t\t\t\tWARN(\"%s(): can't find parent function\",\n\t\t\t\t     sym->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tsym->pfunc = pfunc;\n\t\t\tpfunc->cfunc = sym;\n\n\t\t\t \n\t\t\tif (sym->sec == pfunc->sec &&\n\t\t\t    sym->offset >= pfunc->offset &&\n\t\t\t    sym->offset + sym->len == pfunc->offset + pfunc->len) {\n\t\t\t\tpfunc->len -= sym->len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfree(sym);\n\treturn -1;\n}\n\n \nstatic int elf_update_sym_relocs(struct elf *elf, struct symbol *sym)\n{\n\tstruct reloc *reloc;\n\n\tfor (reloc = sym->relocs; reloc; reloc = reloc->sym_next_reloc)\n\t\tset_reloc_sym(elf, reloc, reloc->sym->idx);\n\n\treturn 0;\n}\n\n \nstatic int elf_update_symbol(struct elf *elf, struct section *symtab,\n\t\t\t     struct section *symtab_shndx, struct symbol *sym)\n{\n\tElf32_Word shndx = sym->sec ? sym->sec->idx : SHN_UNDEF;\n\tElf_Data *symtab_data = NULL, *shndx_data = NULL;\n\tElf64_Xword entsize = symtab->sh.sh_entsize;\n\tint max_idx, idx = sym->idx;\n\tElf_Scn *s, *t = NULL;\n\tbool is_special_shndx = sym->sym.st_shndx >= SHN_LORESERVE &&\n\t\t\t\tsym->sym.st_shndx != SHN_XINDEX;\n\n\tif (is_special_shndx)\n\t\tshndx = sym->sym.st_shndx;\n\n\ts = elf_getscn(elf->elf, symtab->idx);\n\tif (!s) {\n\t\tWARN_ELF(\"elf_getscn\");\n\t\treturn -1;\n\t}\n\n\tif (symtab_shndx) {\n\t\tt = elf_getscn(elf->elf, symtab_shndx->idx);\n\t\tif (!t) {\n\t\t\tWARN_ELF(\"elf_getscn\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t \n\t\tsymtab_data = elf_getdata(s, symtab_data);\n\t\tif (t)\n\t\t\tshndx_data = elf_getdata(t, shndx_data);\n\n\t\t \n\t\tif (!symtab_data) {\n\t\t\t \n\t\t\tint num = max(1U, sym->idx/3);\n\t\t\tvoid *buf;\n\n\t\t\tif (idx) {\n\t\t\t\t \n\t\t\t\tWARN(\"index out of range\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t \n\t\t\tsymtab_data = elf_newdata(s);\n\t\t\tif (t)\n\t\t\t\tshndx_data = elf_newdata(t);\n\n\t\t\tbuf = calloc(num, entsize);\n\t\t\tif (!buf) {\n\t\t\t\tWARN(\"malloc\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tsymtab_data->d_buf = buf;\n\t\t\tsymtab_data->d_size = num * entsize;\n\t\t\tsymtab_data->d_align = 1;\n\t\t\tsymtab_data->d_type = ELF_T_SYM;\n\n\t\t\tmark_sec_changed(elf, symtab, true);\n\t\t\tsymtab->truncate = true;\n\n\t\t\tif (t) {\n\t\t\t\tbuf = calloc(num, sizeof(Elf32_Word));\n\t\t\t\tif (!buf) {\n\t\t\t\t\tWARN(\"malloc\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tshndx_data->d_buf = buf;\n\t\t\t\tshndx_data->d_size = num * sizeof(Elf32_Word);\n\t\t\t\tshndx_data->d_align = sizeof(Elf32_Word);\n\t\t\t\tshndx_data->d_type = ELF_T_WORD;\n\n\t\t\t\tmark_sec_changed(elf, symtab_shndx, true);\n\t\t\t\tsymtab_shndx->truncate = true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!symtab_data->d_size) {\n\t\t\tWARN(\"zero size data\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tmax_idx = symtab_data->d_size / entsize;\n\t\tif (idx < max_idx)\n\t\t\tbreak;\n\n\t\t \n\t\tidx -= max_idx;\n\t}\n\n\t \n\tif (idx < 0) {\n\t\tWARN(\"negative index\");\n\t\treturn -1;\n\t}\n\n\t \n\tif ((shndx >= SHN_UNDEF && shndx < SHN_LORESERVE) || is_special_shndx) {\n\t\tsym->sym.st_shndx = shndx;\n\t\tif (!shndx_data)\n\t\t\tshndx = 0;\n\t} else {\n\t\tsym->sym.st_shndx = SHN_XINDEX;\n\t\tif (!shndx_data) {\n\t\t\tWARN(\"no .symtab_shndx\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!gelf_update_symshndx(symtab_data, shndx_data, idx, &sym->sym, shndx)) {\n\t\tWARN_ELF(\"gelf_update_symshndx\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct symbol *\n__elf_create_symbol(struct elf *elf, struct symbol *sym)\n{\n\tstruct section *symtab, *symtab_shndx;\n\tElf32_Word first_non_local, new_idx;\n\tstruct symbol *old;\n\n\tsymtab = find_section_by_name(elf, \".symtab\");\n\tif (symtab) {\n\t\tsymtab_shndx = find_section_by_name(elf, \".symtab_shndx\");\n\t} else {\n\t\tWARN(\"no .symtab\");\n\t\treturn NULL;\n\t}\n\n\tnew_idx = sec_num_entries(symtab);\n\n\tif (GELF_ST_BIND(sym->sym.st_info) != STB_LOCAL)\n\t\tgoto non_local;\n\n\t \n\tfirst_non_local = symtab->sh.sh_info;\n\told = find_symbol_by_index(elf, first_non_local);\n\tif (old) {\n\n\t\telf_hash_del(symbol, &old->hash, old->idx);\n\t\telf_hash_add(symbol, &old->hash, new_idx);\n\t\told->idx = new_idx;\n\n\t\tif (elf_update_symbol(elf, symtab, symtab_shndx, old)) {\n\t\t\tWARN(\"elf_update_symbol move\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (elf_update_sym_relocs(elf, old))\n\t\t\treturn NULL;\n\n\t\tnew_idx = first_non_local;\n\t}\n\n\t \n\tsymtab->sh.sh_info += 1;\n\nnon_local:\n\tsym->idx = new_idx;\n\tif (elf_update_symbol(elf, symtab, symtab_shndx, sym)) {\n\t\tWARN(\"elf_update_symbol\");\n\t\treturn NULL;\n\t}\n\n\tsymtab->sh.sh_size += symtab->sh.sh_entsize;\n\tmark_sec_changed(elf, symtab, true);\n\n\tif (symtab_shndx) {\n\t\tsymtab_shndx->sh.sh_size += sizeof(Elf32_Word);\n\t\tmark_sec_changed(elf, symtab_shndx, true);\n\t}\n\n\treturn sym;\n}\n\nstatic struct symbol *\nelf_create_section_symbol(struct elf *elf, struct section *sec)\n{\n\tstruct symbol *sym = calloc(1, sizeof(*sym));\n\n\tif (!sym) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\n\tsym->name = sec->name;\n\tsym->sec = sec;\n\n\t \n\tsym->sym.st_info = GELF_ST_INFO(STB_LOCAL, STT_SECTION);\n\t \n\t \n\t \n\n\tsym = __elf_create_symbol(elf, sym);\n\tif (sym)\n\t\telf_add_symbol(elf, sym);\n\n\treturn sym;\n}\n\nstatic int elf_add_string(struct elf *elf, struct section *strtab, char *str);\n\nstruct symbol *\nelf_create_prefix_symbol(struct elf *elf, struct symbol *orig, long size)\n{\n\tstruct symbol *sym = calloc(1, sizeof(*sym));\n\tsize_t namelen = strlen(orig->name) + sizeof(\"__pfx_\");\n\tchar *name = malloc(namelen);\n\n\tif (!sym || !name) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\n\tsnprintf(name, namelen, \"__pfx_%s\", orig->name);\n\n\tsym->name = name;\n\tsym->sec = orig->sec;\n\n\tsym->sym.st_name = elf_add_string(elf, NULL, name);\n\tsym->sym.st_info = orig->sym.st_info;\n\tsym->sym.st_value = orig->sym.st_value - size;\n\tsym->sym.st_size = size;\n\n\tsym = __elf_create_symbol(elf, sym);\n\tif (sym)\n\t\telf_add_symbol(elf, sym);\n\n\treturn sym;\n}\n\nstatic struct reloc *elf_init_reloc(struct elf *elf, struct section *rsec,\n\t\t\t\t    unsigned int reloc_idx,\n\t\t\t\t    unsigned long offset, struct symbol *sym,\n\t\t\t\t    s64 addend, unsigned int type)\n{\n\tstruct reloc *reloc, empty = { 0 };\n\n\tif (reloc_idx >= sec_num_entries(rsec)) {\n\t\tWARN(\"%s: bad reloc_idx %u for %s with %d relocs\",\n\t\t     __func__, reloc_idx, rsec->name, sec_num_entries(rsec));\n\t\treturn NULL;\n\t}\n\n\treloc = &rsec->relocs[reloc_idx];\n\n\tif (memcmp(reloc, &empty, sizeof(empty))) {\n\t\tWARN(\"%s: %s: reloc %d already initialized!\",\n\t\t     __func__, rsec->name, reloc_idx);\n\t\treturn NULL;\n\t}\n\n\treloc->sec = rsec;\n\treloc->sym = sym;\n\n\tset_reloc_offset(elf, reloc, offset);\n\tset_reloc_sym(elf, reloc, sym->idx);\n\tset_reloc_type(elf, reloc, type);\n\tset_reloc_addend(elf, reloc, addend);\n\n\telf_hash_add(reloc, &reloc->hash, reloc_hash(reloc));\n\treloc->sym_next_reloc = sym->relocs;\n\tsym->relocs = reloc;\n\n\treturn reloc;\n}\n\nstruct reloc *elf_init_reloc_text_sym(struct elf *elf, struct section *sec,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      unsigned int reloc_idx,\n\t\t\t\t      struct section *insn_sec,\n\t\t\t\t      unsigned long insn_off)\n{\n\tstruct symbol *sym = insn_sec->sym;\n\tint addend = insn_off;\n\n\tif (!(insn_sec->sh.sh_flags & SHF_EXECINSTR)) {\n\t\tWARN(\"bad call to %s() for data symbol %s\",\n\t\t     __func__, sym->name);\n\t\treturn NULL;\n\t}\n\n\tif (!sym) {\n\t\t \n\t\tsym = elf_create_section_symbol(elf, insn_sec);\n\t\tif (!sym)\n\t\t\treturn NULL;\n\n\t\tinsn_sec->sym = sym;\n\t}\n\n\treturn elf_init_reloc(elf, sec->rsec, reloc_idx, offset, sym, addend,\n\t\t\t      elf_text_rela_type(elf));\n}\n\nstruct reloc *elf_init_reloc_data_sym(struct elf *elf, struct section *sec,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      unsigned int reloc_idx,\n\t\t\t\t      struct symbol *sym,\n\t\t\t\t      s64 addend)\n{\n\tif (sym->sec && (sec->sh.sh_flags & SHF_EXECINSTR)) {\n\t\tWARN(\"bad call to %s() for text symbol %s\",\n\t\t     __func__, sym->name);\n\t\treturn NULL;\n\t}\n\n\treturn elf_init_reloc(elf, sec->rsec, reloc_idx, offset, sym, addend,\n\t\t\t      elf_data_rela_type(elf));\n}\n\nstatic int read_relocs(struct elf *elf)\n{\n\tunsigned long nr_reloc, max_reloc = 0;\n\tstruct section *rsec;\n\tstruct reloc *reloc;\n\tunsigned int symndx;\n\tstruct symbol *sym;\n\tint i;\n\n\tif (!elf_alloc_hash(reloc, elf->num_relocs))\n\t\treturn -1;\n\n\tlist_for_each_entry(rsec, &elf->sections, list) {\n\t\tif (!is_reloc_sec(rsec))\n\t\t\tcontinue;\n\n\t\trsec->base = find_section_by_index(elf, rsec->sh.sh_info);\n\t\tif (!rsec->base) {\n\t\t\tWARN(\"can't find base section for reloc section %s\",\n\t\t\t     rsec->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\trsec->base->rsec = rsec;\n\n\t\tnr_reloc = 0;\n\t\trsec->relocs = calloc(sec_num_entries(rsec), sizeof(*reloc));\n\t\tif (!rsec->relocs) {\n\t\t\tperror(\"calloc\");\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sec_num_entries(rsec); i++) {\n\t\t\treloc = &rsec->relocs[i];\n\n\t\t\treloc->sec = rsec;\n\t\t\tsymndx = reloc_sym(reloc);\n\t\t\treloc->sym = sym = find_symbol_by_index(elf, symndx);\n\t\t\tif (!reloc->sym) {\n\t\t\t\tWARN(\"can't find reloc entry symbol %d for %s\",\n\t\t\t\t     symndx, rsec->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\telf_hash_add(reloc, &reloc->hash, reloc_hash(reloc));\n\t\t\treloc->sym_next_reloc = sym->relocs;\n\t\t\tsym->relocs = reloc;\n\n\t\t\tnr_reloc++;\n\t\t}\n\t\tmax_reloc = max(max_reloc, nr_reloc);\n\t}\n\n\tif (opts.stats) {\n\t\tprintf(\"max_reloc: %lu\\n\", max_reloc);\n\t\tprintf(\"num_relocs: %lu\\n\", elf->num_relocs);\n\t\tprintf(\"reloc_bits: %d\\n\", elf->reloc_bits);\n\t}\n\n\treturn 0;\n}\n\nstruct elf *elf_open_read(const char *name, int flags)\n{\n\tstruct elf *elf;\n\tElf_Cmd cmd;\n\n\telf_version(EV_CURRENT);\n\n\telf = malloc(sizeof(*elf));\n\tif (!elf) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\tmemset(elf, 0, sizeof(*elf));\n\n\tINIT_LIST_HEAD(&elf->sections);\n\n\telf->fd = open(name, flags);\n\tif (elf->fd == -1) {\n\t\tfprintf(stderr, \"objtool: Can't open '%s': %s\\n\",\n\t\t\tname, strerror(errno));\n\t\tgoto err;\n\t}\n\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tcmd = ELF_C_READ_MMAP;\n\telse if ((flags & O_ACCMODE) == O_RDWR)\n\t\tcmd = ELF_C_RDWR;\n\telse  \n\t\tcmd = ELF_C_WRITE;\n\n\telf->elf = elf_begin(elf->fd, cmd, NULL);\n\tif (!elf->elf) {\n\t\tWARN_ELF(\"elf_begin\");\n\t\tgoto err;\n\t}\n\n\tif (!gelf_getehdr(elf->elf, &elf->ehdr)) {\n\t\tWARN_ELF(\"gelf_getehdr\");\n\t\tgoto err;\n\t}\n\n\tif (read_sections(elf))\n\t\tgoto err;\n\n\tif (read_symbols(elf))\n\t\tgoto err;\n\n\tif (read_relocs(elf))\n\t\tgoto err;\n\n\treturn elf;\n\nerr:\n\telf_close(elf);\n\treturn NULL;\n}\n\nstatic int elf_add_string(struct elf *elf, struct section *strtab, char *str)\n{\n\tElf_Data *data;\n\tElf_Scn *s;\n\tint len;\n\n\tif (!strtab)\n\t\tstrtab = find_section_by_name(elf, \".strtab\");\n\tif (!strtab) {\n\t\tWARN(\"can't find .strtab section\");\n\t\treturn -1;\n\t}\n\n\ts = elf_getscn(elf->elf, strtab->idx);\n\tif (!s) {\n\t\tWARN_ELF(\"elf_getscn\");\n\t\treturn -1;\n\t}\n\n\tdata = elf_newdata(s);\n\tif (!data) {\n\t\tWARN_ELF(\"elf_newdata\");\n\t\treturn -1;\n\t}\n\n\tdata->d_buf = str;\n\tdata->d_size = strlen(str) + 1;\n\tdata->d_align = 1;\n\n\tlen = strtab->sh.sh_size;\n\tstrtab->sh.sh_size += data->d_size;\n\n\tmark_sec_changed(elf, strtab, true);\n\n\treturn len;\n}\n\nstruct section *elf_create_section(struct elf *elf, const char *name,\n\t\t\t\t   size_t entsize, unsigned int nr)\n{\n\tstruct section *sec, *shstrtab;\n\tsize_t size = entsize * nr;\n\tElf_Scn *s;\n\n\tsec = malloc(sizeof(*sec));\n\tif (!sec) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\tmemset(sec, 0, sizeof(*sec));\n\n\tINIT_LIST_HEAD(&sec->symbol_list);\n\n\ts = elf_newscn(elf->elf);\n\tif (!s) {\n\t\tWARN_ELF(\"elf_newscn\");\n\t\treturn NULL;\n\t}\n\n\tsec->name = strdup(name);\n\tif (!sec->name) {\n\t\tperror(\"strdup\");\n\t\treturn NULL;\n\t}\n\n\tsec->idx = elf_ndxscn(s);\n\n\tsec->data = elf_newdata(s);\n\tif (!sec->data) {\n\t\tWARN_ELF(\"elf_newdata\");\n\t\treturn NULL;\n\t}\n\n\tsec->data->d_size = size;\n\tsec->data->d_align = 1;\n\n\tif (size) {\n\t\tsec->data->d_buf = malloc(size);\n\t\tif (!sec->data->d_buf) {\n\t\t\tperror(\"malloc\");\n\t\t\treturn NULL;\n\t\t}\n\t\tmemset(sec->data->d_buf, 0, size);\n\t}\n\n\tif (!gelf_getshdr(s, &sec->sh)) {\n\t\tWARN_ELF(\"gelf_getshdr\");\n\t\treturn NULL;\n\t}\n\n\tsec->sh.sh_size = size;\n\tsec->sh.sh_entsize = entsize;\n\tsec->sh.sh_type = SHT_PROGBITS;\n\tsec->sh.sh_addralign = 1;\n\tsec->sh.sh_flags = SHF_ALLOC;\n\n\t \n\tshstrtab = find_section_by_name(elf, \".shstrtab\");\n\tif (!shstrtab)\n\t\tshstrtab = find_section_by_name(elf, \".strtab\");\n\tif (!shstrtab) {\n\t\tWARN(\"can't find .shstrtab or .strtab section\");\n\t\treturn NULL;\n\t}\n\tsec->sh.sh_name = elf_add_string(elf, shstrtab, sec->name);\n\tif (sec->sh.sh_name == -1)\n\t\treturn NULL;\n\n\tlist_add_tail(&sec->list, &elf->sections);\n\telf_hash_add(section, &sec->hash, sec->idx);\n\telf_hash_add(section_name, &sec->name_hash, str_hash(sec->name));\n\n\tmark_sec_changed(elf, sec, true);\n\n\treturn sec;\n}\n\nstatic struct section *elf_create_rela_section(struct elf *elf,\n\t\t\t\t\t       struct section *sec,\n\t\t\t\t\t       unsigned int reloc_nr)\n{\n\tstruct section *rsec;\n\tchar *rsec_name;\n\n\trsec_name = malloc(strlen(sec->name) + strlen(\".rela\") + 1);\n\tif (!rsec_name) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\tstrcpy(rsec_name, \".rela\");\n\tstrcat(rsec_name, sec->name);\n\n\trsec = elf_create_section(elf, rsec_name, elf_rela_size(elf), reloc_nr);\n\tfree(rsec_name);\n\tif (!rsec)\n\t\treturn NULL;\n\n\trsec->data->d_type = ELF_T_RELA;\n\trsec->sh.sh_type = SHT_RELA;\n\trsec->sh.sh_addralign = elf_addr_size(elf);\n\trsec->sh.sh_link = find_section_by_name(elf, \".symtab\")->idx;\n\trsec->sh.sh_info = sec->idx;\n\trsec->sh.sh_flags = SHF_INFO_LINK;\n\n\trsec->relocs = calloc(sec_num_entries(rsec), sizeof(struct reloc));\n\tif (!rsec->relocs) {\n\t\tperror(\"calloc\");\n\t\treturn NULL;\n\t}\n\n\tsec->rsec = rsec;\n\trsec->base = sec;\n\n\treturn rsec;\n}\n\nstruct section *elf_create_section_pair(struct elf *elf, const char *name,\n\t\t\t\t\tsize_t entsize, unsigned int nr,\n\t\t\t\t\tunsigned int reloc_nr)\n{\n\tstruct section *sec;\n\n\tsec = elf_create_section(elf, name, entsize, nr);\n\tif (!sec)\n\t\treturn NULL;\n\n\tif (!elf_create_rela_section(elf, sec, reloc_nr))\n\t\treturn NULL;\n\n\treturn sec;\n}\n\nint elf_write_insn(struct elf *elf, struct section *sec,\n\t\t   unsigned long offset, unsigned int len,\n\t\t   const char *insn)\n{\n\tElf_Data *data = sec->data;\n\n\tif (data->d_type != ELF_T_BYTE || data->d_off) {\n\t\tWARN(\"write to unexpected data for section: %s\", sec->name);\n\t\treturn -1;\n\t}\n\n\tmemcpy(data->d_buf + offset, insn, len);\n\n\tmark_sec_changed(elf, sec, true);\n\n\treturn 0;\n}\n\n \nstatic int elf_truncate_section(struct elf *elf, struct section *sec)\n{\n\tu64 size = sec->sh.sh_size;\n\tbool truncated = false;\n\tElf_Data *data = NULL;\n\tElf_Scn *s;\n\n\ts = elf_getscn(elf->elf, sec->idx);\n\tif (!s) {\n\t\tWARN_ELF(\"elf_getscn\");\n\t\treturn -1;\n\t}\n\n\tfor (;;) {\n\t\t \n\t\tdata = elf_getdata(s, data);\n\n\t\tif (!data) {\n\t\t\tif (size) {\n\t\t\t\tWARN(\"end of section data but non-zero size left\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (truncated) {\n\t\t\t \n\t\t\tWARN(\"truncated; but more data\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!data->d_size) {\n\t\t\tWARN(\"zero size data\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (data->d_size > size) {\n\t\t\ttruncated = true;\n\t\t\tdata->d_size = size;\n\t\t}\n\n\t\tsize -= data->d_size;\n\t}\n}\n\nint elf_write(struct elf *elf)\n{\n\tstruct section *sec;\n\tElf_Scn *s;\n\n\tif (opts.dryrun)\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(sec, &elf->sections, list) {\n\t\tif (sec->truncate)\n\t\t\telf_truncate_section(elf, sec);\n\n\t\tif (sec_changed(sec)) {\n\t\t\ts = elf_getscn(elf->elf, sec->idx);\n\t\t\tif (!s) {\n\t\t\t\tWARN_ELF(\"elf_getscn\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!gelf_update_shdr(s, &sec->sh)) {\n\t\t\t\tWARN_ELF(\"gelf_update_shdr\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tmark_sec_changed(elf, sec, false);\n\t\t}\n\t}\n\n\t \n\telf_flagelf(elf->elf, ELF_C_SET, ELF_F_DIRTY);\n\n\t \n\tif (elf_update(elf->elf, ELF_C_WRITE) < 0) {\n\t\tWARN_ELF(\"elf_update\");\n\t\treturn -1;\n\t}\n\n\telf->changed = false;\n\n\treturn 0;\n}\n\nvoid elf_close(struct elf *elf)\n{\n\tif (elf->elf)\n\t\telf_end(elf->elf);\n\n\tif (elf->fd > 0)\n\t\tclose(elf->fd);\n\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}