{
  "module_name": "check.h",
  "hash_id": "82f97c38294b3da9b917640779d6bca31e7e60b7e6fc6718f4838efc27831f53",
  "original_prompt": "Ingested from linux-6.6.14/tools/objtool/include/objtool/check.h",
  "human_readable_source": " \n \n\n#ifndef _CHECK_H\n#define _CHECK_H\n\n#include <stdbool.h>\n#include <objtool/cfi.h>\n#include <objtool/arch.h>\n\nstruct insn_state {\n\tstruct cfi_state cfi;\n\tunsigned int uaccess_stack;\n\tbool uaccess;\n\tbool df;\n\tbool noinstr;\n\ts8 instr;\n};\n\nstruct alt_group {\n\t \n\tstruct alt_group *orig_group;\n\n\t \n\tstruct instruction *first_insn, *last_insn, *nop;\n\n\t \n\tstruct cfi_state **cfi;\n};\n\n#define INSN_CHUNK_BITS\t\t8\n#define INSN_CHUNK_SIZE\t\t(1 << INSN_CHUNK_BITS)\n#define INSN_CHUNK_MAX\t\t(INSN_CHUNK_SIZE - 1)\n\nstruct instruction {\n\tstruct hlist_node hash;\n\tstruct list_head call_node;\n\tstruct section *sec;\n\tunsigned long offset;\n\tunsigned long immediate;\n\n\tu8 len;\n\tu8 prev_len;\n\tu8 type;\n\ts8 instr;\n\n\tu32 idx\t\t\t: INSN_CHUNK_BITS,\n\t    dead_end\t\t: 1,\n\t    ignore\t\t: 1,\n\t    ignore_alts\t\t: 1,\n\t    hint\t\t: 1,\n\t    save\t\t: 1,\n\t    restore\t\t: 1,\n\t    retpoline_safe\t: 1,\n\t    noendbr\t\t: 1,\n\t    unret\t\t: 1,\n\t    visited\t\t: 4,\n\t    no_reloc\t\t: 1;\n\t\t \n\n\tstruct alt_group *alt_group;\n\tstruct instruction *jump_dest;\n\tstruct instruction *first_jump_src;\n\tunion {\n\t\tstruct symbol *_call_dest;\n\t\tstruct reloc *_jump_table;\n\t};\n\tstruct alternative *alts;\n\tstruct symbol *sym;\n\tstruct stack_op *stack_ops;\n\tstruct cfi_state *cfi;\n};\n\nstatic inline struct symbol *insn_func(struct instruction *insn)\n{\n\tstruct symbol *sym = insn->sym;\n\n\tif (sym && sym->type != STT_FUNC)\n\t\tsym = NULL;\n\n\treturn sym;\n}\n\n#define VISITED_BRANCH\t\t0x01\n#define VISITED_BRANCH_UACCESS\t0x02\n#define VISITED_BRANCH_MASK\t0x03\n#define VISITED_UNRET\t\t0x04\n\nstatic inline bool is_static_jump(struct instruction *insn)\n{\n\treturn insn->type == INSN_JUMP_CONDITIONAL ||\n\t       insn->type == INSN_JUMP_UNCONDITIONAL;\n}\n\nstatic inline bool is_dynamic_jump(struct instruction *insn)\n{\n\treturn insn->type == INSN_JUMP_DYNAMIC ||\n\t       insn->type == INSN_JUMP_DYNAMIC_CONDITIONAL;\n}\n\nstatic inline bool is_jump(struct instruction *insn)\n{\n\treturn is_static_jump(insn) || is_dynamic_jump(insn);\n}\n\nstruct instruction *find_insn(struct objtool_file *file,\n\t\t\t      struct section *sec, unsigned long offset);\n\nstruct instruction *next_insn_same_sec(struct objtool_file *file, struct instruction *insn);\n\n#define sec_for_each_insn(file, _sec, insn)\t\t\t\t\\\n\tfor (insn = find_insn(file, _sec, 0);\t\t\t\t\\\n\t     insn && insn->sec == _sec;\t\t\t\t\t\\\n\t     insn = next_insn_same_sec(file, insn))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}