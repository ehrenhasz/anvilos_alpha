{
  "module_name": "elf.h",
  "hash_id": "aa9e1734687958dc313719ae6122b77a93e0a1eb404f87c7e1aa0bc80754ab51",
  "original_prompt": "Ingested from linux-6.6.14/tools/objtool/include/objtool/elf.h",
  "human_readable_source": " \n \n\n#ifndef _OBJTOOL_ELF_H\n#define _OBJTOOL_ELF_H\n\n#include <stdio.h>\n#include <gelf.h>\n#include <linux/list.h>\n#include <linux/hashtable.h>\n#include <linux/rbtree.h>\n#include <linux/jhash.h>\n#include <arch/elf.h>\n\n#ifdef LIBELF_USE_DEPRECATED\n# define elf_getshdrnum    elf_getshnum\n# define elf_getshdrstrndx elf_getshstrndx\n#endif\n\n \n#ifndef ELF_C_READ_MMAP\n#define ELF_C_READ_MMAP ELF_C_READ\n#endif\n\nstruct elf_hash_node {\n\tstruct elf_hash_node *next;\n};\n\nstruct section {\n\tstruct list_head list;\n\tstruct elf_hash_node hash;\n\tstruct elf_hash_node name_hash;\n\tGElf_Shdr sh;\n\tstruct rb_root_cached symbol_tree;\n\tstruct list_head symbol_list;\n\tstruct section *base, *rsec;\n\tstruct symbol *sym;\n\tElf_Data *data;\n\tchar *name;\n\tint idx;\n\tbool _changed, text, rodata, noinstr, init, truncate;\n\tstruct reloc *relocs;\n};\n\nstruct symbol {\n\tstruct list_head list;\n\tstruct rb_node node;\n\tstruct elf_hash_node hash;\n\tstruct elf_hash_node name_hash;\n\tGElf_Sym sym;\n\tstruct section *sec;\n\tchar *name;\n\tunsigned int idx, len;\n\tunsigned long offset;\n\tunsigned long __subtree_last;\n\tstruct symbol *pfunc, *cfunc, *alias;\n\tunsigned char bind, type;\n\tu8 uaccess_safe      : 1;\n\tu8 static_call_tramp : 1;\n\tu8 retpoline_thunk   : 1;\n\tu8 return_thunk      : 1;\n\tu8 fentry            : 1;\n\tu8 profiling_func    : 1;\n\tu8 warned\t     : 1;\n\tu8 embedded_insn     : 1;\n\tstruct list_head pv_target;\n\tstruct reloc *relocs;\n};\n\nstruct reloc {\n\tstruct elf_hash_node hash;\n\tstruct section *sec;\n\tstruct symbol *sym;\n\tstruct reloc *sym_next_reloc;\n};\n\nstruct elf {\n\tElf *elf;\n\tGElf_Ehdr ehdr;\n\tint fd;\n\tbool changed;\n\tchar *name;\n\tunsigned int num_files;\n\tstruct list_head sections;\n\tunsigned long num_relocs;\n\n\tint symbol_bits;\n\tint symbol_name_bits;\n\tint section_bits;\n\tint section_name_bits;\n\tint reloc_bits;\n\n\tstruct elf_hash_node **symbol_hash;\n\tstruct elf_hash_node **symbol_name_hash;\n\tstruct elf_hash_node **section_hash;\n\tstruct elf_hash_node **section_name_hash;\n\tstruct elf_hash_node **reloc_hash;\n\n\tstruct section *section_data;\n\tstruct symbol *symbol_data;\n};\n\nstruct elf *elf_open_read(const char *name, int flags);\n\nstruct section *elf_create_section(struct elf *elf, const char *name,\n\t\t\t\t   size_t entsize, unsigned int nr);\nstruct section *elf_create_section_pair(struct elf *elf, const char *name,\n\t\t\t\t\tsize_t entsize, unsigned int nr,\n\t\t\t\t\tunsigned int reloc_nr);\n\nstruct symbol *elf_create_prefix_symbol(struct elf *elf, struct symbol *orig, long size);\n\nstruct reloc *elf_init_reloc_text_sym(struct elf *elf, struct section *sec,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      unsigned int reloc_idx,\n\t\t\t\t      struct section *insn_sec,\n\t\t\t\t      unsigned long insn_off);\n\nstruct reloc *elf_init_reloc_data_sym(struct elf *elf, struct section *sec,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      unsigned int reloc_idx,\n\t\t\t\t      struct symbol *sym,\n\t\t\t\t      s64 addend);\n\nint elf_write_insn(struct elf *elf, struct section *sec,\n\t\t   unsigned long offset, unsigned int len,\n\t\t   const char *insn);\nint elf_write(struct elf *elf);\nvoid elf_close(struct elf *elf);\n\nstruct section *find_section_by_name(const struct elf *elf, const char *name);\nstruct symbol *find_func_by_offset(struct section *sec, unsigned long offset);\nstruct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);\nstruct symbol *find_symbol_by_name(const struct elf *elf, const char *name);\nstruct symbol *find_symbol_containing(const struct section *sec, unsigned long offset);\nint find_symbol_hole_containing(const struct section *sec, unsigned long offset);\nstruct reloc *find_reloc_by_dest(const struct elf *elf, struct section *sec, unsigned long offset);\nstruct reloc *find_reloc_by_dest_range(const struct elf *elf, struct section *sec,\n\t\t\t\t     unsigned long offset, unsigned int len);\nstruct symbol *find_func_containing(struct section *sec, unsigned long offset);\n\n \nstatic inline bool has_multiple_files(struct elf *elf)\n{\n\treturn elf->num_files > 1;\n}\n\nstatic inline size_t elf_addr_size(struct elf *elf)\n{\n\treturn elf->ehdr.e_ident[EI_CLASS] == ELFCLASS32 ? 4 : 8;\n}\n\nstatic inline size_t elf_rela_size(struct elf *elf)\n{\n\treturn elf_addr_size(elf) == 4 ? sizeof(Elf32_Rela) : sizeof(Elf64_Rela);\n}\n\nstatic inline unsigned int elf_data_rela_type(struct elf *elf)\n{\n\treturn elf_addr_size(elf) == 4 ? R_DATA32 : R_DATA64;\n}\n\nstatic inline unsigned int elf_text_rela_type(struct elf *elf)\n{\n\treturn elf_addr_size(elf) == 4 ? R_TEXT32 : R_TEXT64;\n}\n\nstatic inline bool is_reloc_sec(struct section *sec)\n{\n\treturn sec->sh.sh_type == SHT_RELA || sec->sh.sh_type == SHT_REL;\n}\n\nstatic inline bool sec_changed(struct section *sec)\n{\n\treturn sec->_changed;\n}\n\nstatic inline void mark_sec_changed(struct elf *elf, struct section *sec,\n\t\t\t\t    bool changed)\n{\n\tsec->_changed = changed;\n\telf->changed |= changed;\n}\n\nstatic inline unsigned int sec_num_entries(struct section *sec)\n{\n\treturn sec->sh.sh_size / sec->sh.sh_entsize;\n}\n\nstatic inline unsigned int reloc_idx(struct reloc *reloc)\n{\n\treturn reloc - reloc->sec->relocs;\n}\n\nstatic inline void *reloc_rel(struct reloc *reloc)\n{\n\tstruct section *rsec = reloc->sec;\n\n\treturn rsec->data->d_buf + (reloc_idx(reloc) * rsec->sh.sh_entsize);\n}\n\nstatic inline bool is_32bit_reloc(struct reloc *reloc)\n{\n\t \n\treturn reloc->sec->sh.sh_entsize < 16;\n}\n\n#define __get_reloc_field(reloc, field)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tis_32bit_reloc(reloc) ?\t\t\t\t\t\t\\\n\t\t((Elf32_Rela *)reloc_rel(reloc))->field :\t\t\\\n\t\t((Elf64_Rela *)reloc_rel(reloc))->field;\t\t\\\n})\n\n#define __set_reloc_field(reloc, field, val)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif (is_32bit_reloc(reloc))\t\t\t\t\t\\\n\t\t((Elf32_Rela *)reloc_rel(reloc))->field = val;\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t((Elf64_Rela *)reloc_rel(reloc))->field = val;\t\t\\\n})\n\nstatic inline u64 reloc_offset(struct reloc *reloc)\n{\n\treturn __get_reloc_field(reloc, r_offset);\n}\n\nstatic inline void set_reloc_offset(struct elf *elf, struct reloc *reloc, u64 offset)\n{\n\t__set_reloc_field(reloc, r_offset, offset);\n\tmark_sec_changed(elf, reloc->sec, true);\n}\n\nstatic inline s64 reloc_addend(struct reloc *reloc)\n{\n\treturn __get_reloc_field(reloc, r_addend);\n}\n\nstatic inline void set_reloc_addend(struct elf *elf, struct reloc *reloc, s64 addend)\n{\n\t__set_reloc_field(reloc, r_addend, addend);\n\tmark_sec_changed(elf, reloc->sec, true);\n}\n\n\nstatic inline unsigned int reloc_sym(struct reloc *reloc)\n{\n\tu64 info = __get_reloc_field(reloc, r_info);\n\n\treturn is_32bit_reloc(reloc) ?\n\t\tELF32_R_SYM(info) :\n\t\tELF64_R_SYM(info);\n}\n\nstatic inline unsigned int reloc_type(struct reloc *reloc)\n{\n\tu64 info = __get_reloc_field(reloc, r_info);\n\n\treturn is_32bit_reloc(reloc) ?\n\t\tELF32_R_TYPE(info) :\n\t\tELF64_R_TYPE(info);\n}\n\nstatic inline void set_reloc_sym(struct elf *elf, struct reloc *reloc, unsigned int sym)\n{\n\tu64 info = is_32bit_reloc(reloc) ?\n\t\tELF32_R_INFO(sym, reloc_type(reloc)) :\n\t\tELF64_R_INFO(sym, reloc_type(reloc));\n\n\t__set_reloc_field(reloc, r_info, info);\n\n\tmark_sec_changed(elf, reloc->sec, true);\n}\nstatic inline void set_reloc_type(struct elf *elf, struct reloc *reloc, unsigned int type)\n{\n\tu64 info = is_32bit_reloc(reloc) ?\n\t\tELF32_R_INFO(reloc_sym(reloc), type) :\n\t\tELF64_R_INFO(reloc_sym(reloc), type);\n\n\t__set_reloc_field(reloc, r_info, info);\n\n\tmark_sec_changed(elf, reloc->sec, true);\n}\n\n#define for_each_sec(file, sec)\t\t\t\t\t\t\\\n\tlist_for_each_entry(sec, &file->elf->sections, list)\n\n#define sec_for_each_sym(sec, sym)\t\t\t\t\t\\\n\tlist_for_each_entry(sym, &sec->symbol_list, list)\n\n#define for_each_sym(file, sym)\t\t\t\t\t\t\\\n\tfor (struct section *__sec, *__fake = (struct section *)1;\t\\\n\t     __fake; __fake = NULL)\t\t\t\t\t\\\n\t\tfor_each_sec(file, __sec)\t\t\t\t\\\n\t\t\tsec_for_each_sym(__sec, sym)\n\n#define for_each_reloc(rsec, reloc)\t\t\t\t\t\\\n\tfor (int __i = 0, __fake = 1; __fake; __fake = 0)\t\t\\\n\t\tfor (reloc = rsec->relocs;\t\t\t\t\\\n\t\t     __i < sec_num_entries(rsec);\t\t\t\\\n\t\t     __i++, reloc++)\n\n#define for_each_reloc_from(rsec, reloc)\t\t\t\t\\\n\tfor (int __i = reloc_idx(reloc);\t\t\t\t\\\n\t     __i < sec_num_entries(rsec);\t\t\t\t\\\n\t     __i++, reloc++)\n\n#define OFFSET_STRIDE_BITS\t4\n#define OFFSET_STRIDE\t\t(1UL << OFFSET_STRIDE_BITS)\n#define OFFSET_STRIDE_MASK\t(~(OFFSET_STRIDE - 1))\n\n#define for_offset_range(_offset, _start, _end)\t\t\t\\\n\tfor (_offset = ((_start) & OFFSET_STRIDE_MASK);\t\t\\\n\t     _offset >= ((_start) & OFFSET_STRIDE_MASK) &&\t\\\n\t     _offset <= ((_end) & OFFSET_STRIDE_MASK);\t\t\\\n\t     _offset += OFFSET_STRIDE)\n\nstatic inline u32 sec_offset_hash(struct section *sec, unsigned long offset)\n{\n\tu32 ol, oh, idx = sec->idx;\n\n\toffset &= OFFSET_STRIDE_MASK;\n\n\tol = offset;\n\toh = (offset >> 16) >> 16;\n\n\t__jhash_mix(ol, oh, idx);\n\n\treturn ol;\n}\n\nstatic inline u32 reloc_hash(struct reloc *reloc)\n{\n\treturn sec_offset_hash(reloc->sec, reloc_offset(reloc));\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}