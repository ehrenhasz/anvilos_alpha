{
  "module_name": "builtin-check.c",
  "hash_id": "35376fd90d3953f6a4a2d119ac6220143f7c980ed14dccb3a7d9b47a7468d82f",
  "original_prompt": "Ingested from linux-6.6.14/tools/objtool/builtin-check.c",
  "human_readable_source": "\n \n\n#include <subcmd/parse-options.h>\n#include <string.h>\n#include <stdlib.h>\n#include <objtool/builtin.h>\n#include <objtool/objtool.h>\n\n#define ERROR(format, ...)\t\t\t\t\\\n\tfprintf(stderr,\t\t\t\t\t\\\n\t\t\"error: objtool: \" format \"\\n\",\t\t\\\n\t\t##__VA_ARGS__)\n\nstruct opts opts;\n\nstatic const char * const check_usage[] = {\n\t\"objtool <actions> [<options>] file.o\",\n\tNULL,\n};\n\nstatic const char * const env_usage[] = {\n\t\"OBJTOOL_ARGS=\\\"<options>\\\"\",\n\tNULL,\n};\n\nstatic int parse_dump(const struct option *opt, const char *str, int unset)\n{\n\tif (!str || !strcmp(str, \"orc\")) {\n\t\topts.dump_orc = true;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int parse_hacks(const struct option *opt, const char *str, int unset)\n{\n\tbool found = false;\n\n\t \n\n\tif (!str || strstr(str, \"jump_label\")) {\n\t\topts.hack_jump_label = true;\n\t\tfound = true;\n\t}\n\n\tif (!str || strstr(str, \"noinstr\")) {\n\t\topts.hack_noinstr = true;\n\t\tfound = true;\n\t}\n\n\tif (!str || strstr(str, \"skylake\")) {\n\t\topts.hack_skylake = true;\n\t\tfound = true;\n\t}\n\n\treturn found ? 0 : -1;\n}\n\nstatic const struct option check_options[] = {\n\tOPT_GROUP(\"Actions:\"),\n\tOPT_CALLBACK_OPTARG('h', \"hacks\", NULL, NULL, \"jump_label,noinstr,skylake\", \"patch toolchain bugs/limitations\", parse_hacks),\n\tOPT_BOOLEAN('i', \"ibt\", &opts.ibt, \"validate and annotate IBT\"),\n\tOPT_BOOLEAN('m', \"mcount\", &opts.mcount, \"annotate mcount/fentry calls for ftrace\"),\n\tOPT_BOOLEAN('n', \"noinstr\", &opts.noinstr, \"validate noinstr rules\"),\n\tOPT_BOOLEAN('o', \"orc\", &opts.orc, \"generate ORC metadata\"),\n\tOPT_BOOLEAN('r', \"retpoline\", &opts.retpoline, \"validate and annotate retpoline usage\"),\n\tOPT_BOOLEAN(0,   \"rethunk\", &opts.rethunk, \"validate and annotate rethunk usage\"),\n\tOPT_BOOLEAN(0,   \"unret\", &opts.unret, \"validate entry unret placement\"),\n\tOPT_INTEGER(0,   \"prefix\", &opts.prefix, \"generate prefix symbols\"),\n\tOPT_BOOLEAN('l', \"sls\", &opts.sls, \"validate straight-line-speculation mitigations\"),\n\tOPT_BOOLEAN('s', \"stackval\", &opts.stackval, \"validate frame pointer rules\"),\n\tOPT_BOOLEAN('t', \"static-call\", &opts.static_call, \"annotate static calls\"),\n\tOPT_BOOLEAN('u', \"uaccess\", &opts.uaccess, \"validate uaccess rules for SMAP\"),\n\tOPT_BOOLEAN(0  , \"cfi\", &opts.cfi, \"annotate kernel control flow integrity (kCFI) function preambles\"),\n\tOPT_CALLBACK_OPTARG(0, \"dump\", NULL, NULL, \"orc\", \"dump metadata\", parse_dump),\n\n\tOPT_GROUP(\"Options:\"),\n\tOPT_BOOLEAN(0, \"backtrace\", &opts.backtrace, \"unwind on error\"),\n\tOPT_BOOLEAN(0, \"backup\", &opts.backup, \"create .orig files before modification\"),\n\tOPT_BOOLEAN(0, \"dry-run\", &opts.dryrun, \"don't write modifications\"),\n\tOPT_BOOLEAN(0, \"link\", &opts.link, \"object is a linked object\"),\n\tOPT_BOOLEAN(0, \"module\", &opts.module, \"object is part of a kernel module\"),\n\tOPT_BOOLEAN(0, \"mnop\", &opts.mnop, \"nop out mcount call sites\"),\n\tOPT_BOOLEAN(0, \"no-unreachable\", &opts.no_unreachable, \"skip 'unreachable instruction' warnings\"),\n\tOPT_BOOLEAN(0, \"sec-address\", &opts.sec_address, \"print section addresses in warnings\"),\n\tOPT_BOOLEAN(0, \"stats\", &opts.stats, \"print statistics\"),\n\tOPT_BOOLEAN('v', \"verbose\", &opts.verbose, \"verbose warnings\"),\n\n\tOPT_END(),\n};\n\nint cmd_parse_options(int argc, const char **argv, const char * const usage[])\n{\n\tconst char *envv[16] = { };\n\tchar *env;\n\tint envc;\n\n\tenv = getenv(\"OBJTOOL_ARGS\");\n\tif (env) {\n\t\tenvv[0] = \"OBJTOOL_ARGS\";\n\t\tfor (envc = 1; envc < ARRAY_SIZE(envv); ) {\n\t\t\tenvv[envc++] = env;\n\t\t\tenv = strchr(env, ' ');\n\t\t\tif (!env)\n\t\t\t\tbreak;\n\t\t\t*env = '\\0';\n\t\t\tenv++;\n\t\t}\n\n\t\tparse_options(envc, envv, check_options, env_usage, 0);\n\t}\n\n\tenv = getenv(\"OBJTOOL_VERBOSE\");\n\tif (env && !strcmp(env, \"1\"))\n\t\topts.verbose = true;\n\n\targc = parse_options(argc, argv, check_options, usage, 0);\n\tif (argc != 1)\n\t\tusage_with_options(usage, check_options);\n\treturn argc;\n}\n\nstatic bool opts_valid(void)\n{\n\tif (opts.hack_jump_label\t||\n\t    opts.hack_noinstr\t\t||\n\t    opts.ibt\t\t\t||\n\t    opts.mcount\t\t\t||\n\t    opts.noinstr\t\t||\n\t    opts.orc\t\t\t||\n\t    opts.retpoline\t\t||\n\t    opts.rethunk\t\t||\n\t    opts.sls\t\t\t||\n\t    opts.stackval\t\t||\n\t    opts.static_call\t\t||\n\t    opts.uaccess) {\n\t\tif (opts.dump_orc) {\n\t\t\tERROR(\"--dump can't be combined with other options\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tif (opts.unret && !opts.rethunk) {\n\t\tERROR(\"--unret requires --rethunk\");\n\t\treturn false;\n\t}\n\n\tif (opts.dump_orc)\n\t\treturn true;\n\n\tERROR(\"At least one command required\");\n\treturn false;\n}\n\nstatic bool mnop_opts_valid(void)\n{\n\tif (opts.mnop && !opts.mcount) {\n\t\tERROR(\"--mnop requires --mcount\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool link_opts_valid(struct objtool_file *file)\n{\n\tif (opts.link)\n\t\treturn true;\n\n\tif (has_multiple_files(file->elf)) {\n\t\tERROR(\"Linked object detected, forcing --link\");\n\t\topts.link = true;\n\t\treturn true;\n\t}\n\n\tif (opts.noinstr) {\n\t\tERROR(\"--noinstr requires --link\");\n\t\treturn false;\n\t}\n\n\tif (opts.ibt) {\n\t\tERROR(\"--ibt requires --link\");\n\t\treturn false;\n\t}\n\n\tif (opts.unret) {\n\t\tERROR(\"--unret requires --link\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint objtool_run(int argc, const char **argv)\n{\n\tconst char *objname;\n\tstruct objtool_file *file;\n\tint ret;\n\n\targc = cmd_parse_options(argc, argv, check_usage);\n\tobjname = argv[0];\n\n\tif (!opts_valid())\n\t\treturn 1;\n\n\tif (opts.dump_orc)\n\t\treturn orc_dump(objname);\n\n\tfile = objtool_open_read(objname);\n\tif (!file)\n\t\treturn 1;\n\n\tif (!mnop_opts_valid())\n\t\treturn 1;\n\n\tif (!link_opts_valid(file))\n\t\treturn 1;\n\n\tret = check(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (file->elf->changed)\n\t\treturn elf_write(file->elf);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}