{
  "module_name": "cpufreq.c",
  "hash_id": "4dfef4a680b4a6e9993347452f6ad8c563800bc110665f565014bb2536eadabb",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/lib/cpufreq.c",
  "human_readable_source": "\n \n\n\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"cpufreq.h\"\n#include \"cpupower_intern.h\"\n\n \n\n \n \nstatic unsigned int sysfs_cpufreq_read_file(unsigned int cpu, const char *fname,\n\t\t\t\t\t    char *buf, size_t buflen)\n{\n\tchar path[SYSFS_PATH_MAX];\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/cpufreq/%s\",\n\t\t\t cpu, fname);\n\treturn cpupower_read_sysfs(path, buf, buflen);\n}\n\n \n \nstatic unsigned int sysfs_cpufreq_write_file(unsigned int cpu,\n\t\t\t\t\t     const char *fname,\n\t\t\t\t\t     const char *value, size_t len)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tint fd;\n\tssize_t numwrite;\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/cpufreq/%s\",\n\t\t\t cpu, fname);\n\n\tfd = open(path, O_WRONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumwrite = write(fd, value, len);\n\tif (numwrite < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\tclose(fd);\n\n\treturn (unsigned int) numwrite;\n}\n\n \n\nenum cpufreq_value {\n\tCPUINFO_CUR_FREQ,\n\tCPUINFO_MIN_FREQ,\n\tCPUINFO_MAX_FREQ,\n\tCPUINFO_LATENCY,\n\tSCALING_CUR_FREQ,\n\tSCALING_MIN_FREQ,\n\tSCALING_MAX_FREQ,\n\tSTATS_NUM_TRANSITIONS,\n\tMAX_CPUFREQ_VALUE_READ_FILES\n};\n\nstatic const char *cpufreq_value_files[MAX_CPUFREQ_VALUE_READ_FILES] = {\n\t[CPUINFO_CUR_FREQ] = \"cpuinfo_cur_freq\",\n\t[CPUINFO_MIN_FREQ] = \"cpuinfo_min_freq\",\n\t[CPUINFO_MAX_FREQ] = \"cpuinfo_max_freq\",\n\t[CPUINFO_LATENCY]  = \"cpuinfo_transition_latency\",\n\t[SCALING_CUR_FREQ] = \"scaling_cur_freq\",\n\t[SCALING_MIN_FREQ] = \"scaling_min_freq\",\n\t[SCALING_MAX_FREQ] = \"scaling_max_freq\",\n\t[STATS_NUM_TRANSITIONS] = \"stats/total_trans\"\n};\n\nunsigned long cpufreq_get_sysfs_value_from_table(unsigned int cpu,\n\t\t\t\t\t\t const char **table,\n\t\t\t\t\t\t unsigned int index,\n\t\t\t\t\t\t unsigned int size)\n{\n\tunsigned long value;\n\tunsigned int len;\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *endp;\n\n\tif (!table || index >= size || !table[index])\n\t\treturn 0;\n\n\tlen = sysfs_cpufreq_read_file(cpu, table[index], linebuf,\n\t\t\t\t      sizeof(linebuf));\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tvalue = strtoul(linebuf, &endp, 0);\n\n\tif (endp == linebuf || errno == ERANGE)\n\t\treturn 0;\n\n\treturn value;\n}\n\nstatic unsigned long sysfs_cpufreq_get_one_value(unsigned int cpu,\n\t\t\t\t\t\t enum cpufreq_value which)\n{\n\treturn cpufreq_get_sysfs_value_from_table(cpu, cpufreq_value_files,\n\t\t\t\t\t\t  which,\n\t\t\t\t\t\t  MAX_CPUFREQ_VALUE_READ_FILES);\n}\n\n \n\nenum cpufreq_string {\n\tSCALING_DRIVER,\n\tSCALING_GOVERNOR,\n\tMAX_CPUFREQ_STRING_FILES\n};\n\nstatic const char *cpufreq_string_files[MAX_CPUFREQ_STRING_FILES] = {\n\t[SCALING_DRIVER] = \"scaling_driver\",\n\t[SCALING_GOVERNOR] = \"scaling_governor\",\n};\n\n\nstatic char *sysfs_cpufreq_get_one_string(unsigned int cpu,\n\t\t\t\t\t  enum cpufreq_string which)\n{\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *result;\n\tunsigned int len;\n\n\tif (which >= MAX_CPUFREQ_STRING_FILES)\n\t\treturn NULL;\n\n\tlen = sysfs_cpufreq_read_file(cpu, cpufreq_string_files[which],\n\t\t\t\tlinebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\tresult = strdup(linebuf);\n\tif (result == NULL)\n\t\treturn NULL;\n\n\tif (result[strlen(result) - 1] == '\\n')\n\t\tresult[strlen(result) - 1] = '\\0';\n\n\treturn result;\n}\n\n \n\nenum cpufreq_write {\n\tWRITE_SCALING_MIN_FREQ,\n\tWRITE_SCALING_MAX_FREQ,\n\tWRITE_SCALING_GOVERNOR,\n\tWRITE_SCALING_SET_SPEED,\n\tMAX_CPUFREQ_WRITE_FILES\n};\n\nstatic const char *cpufreq_write_files[MAX_CPUFREQ_WRITE_FILES] = {\n\t[WRITE_SCALING_MIN_FREQ] = \"scaling_min_freq\",\n\t[WRITE_SCALING_MAX_FREQ] = \"scaling_max_freq\",\n\t[WRITE_SCALING_GOVERNOR] = \"scaling_governor\",\n\t[WRITE_SCALING_SET_SPEED] = \"scaling_setspeed\",\n};\n\nstatic int sysfs_cpufreq_write_one_value(unsigned int cpu,\n\t\t\t\t\t enum cpufreq_write which,\n\t\t\t\t\t const char *new_value, size_t len)\n{\n\tif (which >= MAX_CPUFREQ_WRITE_FILES)\n\t\treturn 0;\n\n\tif (sysfs_cpufreq_write_file(cpu, cpufreq_write_files[which],\n\t\t\t\t\tnew_value, len) != len)\n\t\treturn -ENODEV;\n\n\treturn 0;\n};\n\nunsigned long cpufreq_get_freq_kernel(unsigned int cpu)\n{\n\treturn sysfs_cpufreq_get_one_value(cpu, SCALING_CUR_FREQ);\n}\n\nunsigned long cpufreq_get_freq_hardware(unsigned int cpu)\n{\n\treturn sysfs_cpufreq_get_one_value(cpu, CPUINFO_CUR_FREQ);\n}\n\nunsigned long cpufreq_get_transition_latency(unsigned int cpu)\n{\n\treturn sysfs_cpufreq_get_one_value(cpu, CPUINFO_LATENCY);\n}\n\nint cpufreq_get_hardware_limits(unsigned int cpu,\n\t\t\t\tunsigned long *min,\n\t\t\t\tunsigned long *max)\n{\n\tif ((!min) || (!max))\n\t\treturn -EINVAL;\n\n\t*min = sysfs_cpufreq_get_one_value(cpu, CPUINFO_MIN_FREQ);\n\tif (!*min)\n\t\treturn -ENODEV;\n\n\t*max = sysfs_cpufreq_get_one_value(cpu, CPUINFO_MAX_FREQ);\n\tif (!*max)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nchar *cpufreq_get_driver(unsigned int cpu)\n{\n\treturn sysfs_cpufreq_get_one_string(cpu, SCALING_DRIVER);\n}\n\nvoid cpufreq_put_driver(char *ptr)\n{\n\tif (!ptr)\n\t\treturn;\n\tfree(ptr);\n}\n\nstruct cpufreq_policy *cpufreq_get_policy(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\n\tpolicy = malloc(sizeof(struct cpufreq_policy));\n\tif (!policy)\n\t\treturn NULL;\n\n\tpolicy->governor = sysfs_cpufreq_get_one_string(cpu, SCALING_GOVERNOR);\n\tif (!policy->governor) {\n\t\tfree(policy);\n\t\treturn NULL;\n\t}\n\tpolicy->min = sysfs_cpufreq_get_one_value(cpu, SCALING_MIN_FREQ);\n\tpolicy->max = sysfs_cpufreq_get_one_value(cpu, SCALING_MAX_FREQ);\n\tif ((!policy->min) || (!policy->max)) {\n\t\tfree(policy->governor);\n\t\tfree(policy);\n\t\treturn NULL;\n\t}\n\n\treturn policy;\n}\n\nvoid cpufreq_put_policy(struct cpufreq_policy *policy)\n{\n\tif ((!policy) || (!policy->governor))\n\t\treturn;\n\n\tfree(policy->governor);\n\tpolicy->governor = NULL;\n\tfree(policy);\n}\n\nstruct cpufreq_available_governors *cpufreq_get_available_governors(unsigned\n\t\t\t\t\t\t\t\tint cpu)\n{\n\tstruct cpufreq_available_governors *first = NULL;\n\tstruct cpufreq_available_governors *current = NULL;\n\tchar linebuf[MAX_LINE_LEN];\n\tunsigned int pos, i;\n\tunsigned int len;\n\n\tlen = sysfs_cpufreq_read_file(cpu, \"scaling_available_governors\",\n\t\t\t\tlinebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\tpos = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (linebuf[i] == ' ' || linebuf[i] == '\\n') {\n\t\t\tif (i - pos < 2)\n\t\t\t\tcontinue;\n\t\t\tif (current) {\n\t\t\t\tcurrent->next = malloc(sizeof(*current));\n\t\t\t\tif (!current->next)\n\t\t\t\t\tgoto error_out;\n\t\t\t\tcurrent = current->next;\n\t\t\t} else {\n\t\t\t\tfirst = malloc(sizeof(*first));\n\t\t\t\tif (!first)\n\t\t\t\t\treturn NULL;\n\t\t\t\tcurrent = first;\n\t\t\t}\n\t\t\tcurrent->first = first;\n\t\t\tcurrent->next = NULL;\n\n\t\t\tcurrent->governor = malloc(i - pos + 1);\n\t\t\tif (!current->governor)\n\t\t\t\tgoto error_out;\n\n\t\t\tmemcpy(current->governor, linebuf + pos, i - pos);\n\t\t\tcurrent->governor[i - pos] = '\\0';\n\t\t\tpos = i + 1;\n\t\t}\n\t}\n\n\treturn first;\n\n error_out:\n\twhile (first) {\n\t\tcurrent = first->next;\n\t\tif (first->governor)\n\t\t\tfree(first->governor);\n\t\tfree(first);\n\t\tfirst = current;\n\t}\n\treturn NULL;\n}\n\nvoid cpufreq_put_available_governors(struct cpufreq_available_governors *any)\n{\n\tstruct cpufreq_available_governors *tmp, *next;\n\n\tif (!any)\n\t\treturn;\n\n\ttmp = any->first;\n\twhile (tmp) {\n\t\tnext = tmp->next;\n\t\tif (tmp->governor)\n\t\t\tfree(tmp->governor);\n\t\tfree(tmp);\n\t\ttmp = next;\n\t}\n}\n\n\nstruct cpufreq_available_frequencies\n*cpufreq_get_available_frequencies(unsigned int cpu)\n{\n\tstruct cpufreq_available_frequencies *first = NULL;\n\tstruct cpufreq_available_frequencies *current = NULL;\n\tchar one_value[SYSFS_PATH_MAX];\n\tchar linebuf[MAX_LINE_LEN];\n\tunsigned int pos, i;\n\tunsigned int len;\n\n\tlen = sysfs_cpufreq_read_file(cpu, \"scaling_available_frequencies\",\n\t\t\t\t      linebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\tpos = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (linebuf[i] == ' ' || linebuf[i] == '\\n') {\n\t\t\tif (i - pos < 2)\n\t\t\t\tcontinue;\n\t\t\tif (i - pos >= SYSFS_PATH_MAX)\n\t\t\t\tgoto error_out;\n\t\t\tif (current) {\n\t\t\t\tcurrent->next = malloc(sizeof(*current));\n\t\t\t\tif (!current->next)\n\t\t\t\t\tgoto error_out;\n\t\t\t\tcurrent = current->next;\n\t\t\t} else {\n\t\t\t\tfirst = malloc(sizeof(*first));\n\t\t\t\tif (!first)\n\t\t\t\t\treturn NULL;\n\t\t\t\tcurrent = first;\n\t\t\t}\n\t\t\tcurrent->first = first;\n\t\t\tcurrent->next = NULL;\n\n\t\t\tmemcpy(one_value, linebuf + pos, i - pos);\n\t\t\tone_value[i - pos] = '\\0';\n\t\t\tif (sscanf(one_value, \"%lu\", &current->frequency) != 1)\n\t\t\t\tgoto error_out;\n\n\t\t\tpos = i + 1;\n\t\t}\n\t}\n\n\treturn first;\n\n error_out:\n\twhile (first) {\n\t\tcurrent = first->next;\n\t\tfree(first);\n\t\tfirst = current;\n\t}\n\treturn NULL;\n}\n\nstruct cpufreq_available_frequencies\n*cpufreq_get_boost_frequencies(unsigned int cpu)\n{\n\tstruct cpufreq_available_frequencies *first = NULL;\n\tstruct cpufreq_available_frequencies *current = NULL;\n\tchar one_value[SYSFS_PATH_MAX];\n\tchar linebuf[MAX_LINE_LEN];\n\tunsigned int pos, i;\n\tunsigned int len;\n\n\tlen = sysfs_cpufreq_read_file(cpu, \"scaling_boost_frequencies\",\n\t\t\t\t      linebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\tpos = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (linebuf[i] == ' ' || linebuf[i] == '\\n') {\n\t\t\tif (i - pos < 2)\n\t\t\t\tcontinue;\n\t\t\tif (i - pos >= SYSFS_PATH_MAX)\n\t\t\t\tgoto error_out;\n\t\t\tif (current) {\n\t\t\t\tcurrent->next = malloc(sizeof(*current));\n\t\t\t\tif (!current->next)\n\t\t\t\t\tgoto error_out;\n\t\t\t\tcurrent = current->next;\n\t\t\t} else {\n\t\t\t\tfirst = malloc(sizeof(*first));\n\t\t\t\tif (!first)\n\t\t\t\t\treturn NULL;\n\t\t\t\tcurrent = first;\n\t\t\t}\n\t\t\tcurrent->first = first;\n\t\t\tcurrent->next = NULL;\n\n\t\t\tmemcpy(one_value, linebuf + pos, i - pos);\n\t\t\tone_value[i - pos] = '\\0';\n\t\t\tif (sscanf(one_value, \"%lu\", &current->frequency) != 1)\n\t\t\t\tgoto error_out;\n\n\t\t\tpos = i + 1;\n\t\t}\n\t}\n\n\treturn first;\n\n error_out:\n\twhile (first) {\n\t\tcurrent = first->next;\n\t\tfree(first);\n\t\tfirst = current;\n\t}\n\treturn NULL;\n}\n\nvoid cpufreq_put_available_frequencies(struct cpufreq_available_frequencies *any)\n{\n\tstruct cpufreq_available_frequencies *tmp, *next;\n\n\tif (!any)\n\t\treturn;\n\n\ttmp = any->first;\n\twhile (tmp) {\n\t\tnext = tmp->next;\n\t\tfree(tmp);\n\t\ttmp = next;\n\t}\n}\n\nvoid cpufreq_put_boost_frequencies(struct cpufreq_available_frequencies *any)\n{\n\tcpufreq_put_available_frequencies(any);\n}\n\nstatic struct cpufreq_affected_cpus *sysfs_get_cpu_list(unsigned int cpu,\n\t\t\t\t\t\t\tconst char *file)\n{\n\tstruct cpufreq_affected_cpus *first = NULL;\n\tstruct cpufreq_affected_cpus *current = NULL;\n\tchar one_value[SYSFS_PATH_MAX];\n\tchar linebuf[MAX_LINE_LEN];\n\tunsigned int pos, i;\n\tunsigned int len;\n\n\tlen = sysfs_cpufreq_read_file(cpu, file, linebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\tpos = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (i == len || linebuf[i] == ' ' || linebuf[i] == '\\n') {\n\t\t\tif (i - pos  < 1)\n\t\t\t\tcontinue;\n\t\t\tif (i - pos >= SYSFS_PATH_MAX)\n\t\t\t\tgoto error_out;\n\t\t\tif (current) {\n\t\t\t\tcurrent->next = malloc(sizeof(*current));\n\t\t\t\tif (!current->next)\n\t\t\t\t\tgoto error_out;\n\t\t\t\tcurrent = current->next;\n\t\t\t} else {\n\t\t\t\tfirst = malloc(sizeof(*first));\n\t\t\t\tif (!first)\n\t\t\t\t\treturn NULL;\n\t\t\t\tcurrent = first;\n\t\t\t}\n\t\t\tcurrent->first = first;\n\t\t\tcurrent->next = NULL;\n\n\t\t\tmemcpy(one_value, linebuf + pos, i - pos);\n\t\t\tone_value[i - pos] = '\\0';\n\n\t\t\tif (sscanf(one_value, \"%u\", &current->cpu) != 1)\n\t\t\t\tgoto error_out;\n\n\t\t\tpos = i + 1;\n\t\t}\n\t}\n\n\treturn first;\n\n error_out:\n\twhile (first) {\n\t\tcurrent = first->next;\n\t\tfree(first);\n\t\tfirst = current;\n\t}\n\treturn NULL;\n}\n\nstruct cpufreq_affected_cpus *cpufreq_get_affected_cpus(unsigned int cpu)\n{\n\treturn sysfs_get_cpu_list(cpu, \"affected_cpus\");\n}\n\nvoid cpufreq_put_affected_cpus(struct cpufreq_affected_cpus *any)\n{\n\tstruct cpufreq_affected_cpus *tmp, *next;\n\n\tif (!any)\n\t\treturn;\n\n\ttmp = any->first;\n\twhile (tmp) {\n\t\tnext = tmp->next;\n\t\tfree(tmp);\n\t\ttmp = next;\n\t}\n}\n\n\nstruct cpufreq_affected_cpus *cpufreq_get_related_cpus(unsigned int cpu)\n{\n\treturn sysfs_get_cpu_list(cpu, \"related_cpus\");\n}\n\nvoid cpufreq_put_related_cpus(struct cpufreq_affected_cpus *any)\n{\n\tcpufreq_put_affected_cpus(any);\n}\n\nstatic int verify_gov(char *new_gov, char *passed_gov)\n{\n\tunsigned int i, j = 0;\n\n\tif (!passed_gov || (strlen(passed_gov) > 19))\n\t\treturn -EINVAL;\n\n\tstrncpy(new_gov, passed_gov, 20);\n\tfor (i = 0; i < 20; i++) {\n\t\tif (j) {\n\t\t\tnew_gov[i] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tif ((new_gov[i] >= 'a') && (new_gov[i] <= 'z'))\n\t\t\tcontinue;\n\n\t\tif ((new_gov[i] >= 'A') && (new_gov[i] <= 'Z'))\n\t\t\tcontinue;\n\n\t\tif (new_gov[i] == '-')\n\t\t\tcontinue;\n\n\t\tif (new_gov[i] == '_')\n\t\t\tcontinue;\n\n\t\tif (new_gov[i] == '\\0') {\n\t\t\tj = 1;\n\t\t\tcontinue;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\tnew_gov[19] = '\\0';\n\treturn 0;\n}\n\nint cpufreq_set_policy(unsigned int cpu, struct cpufreq_policy *policy)\n{\n\tchar min[SYSFS_PATH_MAX];\n\tchar max[SYSFS_PATH_MAX];\n\tchar gov[SYSFS_PATH_MAX];\n\tint ret;\n\tunsigned long old_min;\n\tint write_max_first;\n\n\tif (!policy || !(policy->governor))\n\t\treturn -EINVAL;\n\n\tif (policy->max < policy->min)\n\t\treturn -EINVAL;\n\n\tif (verify_gov(gov, policy->governor))\n\t\treturn -EINVAL;\n\n\tsnprintf(min, SYSFS_PATH_MAX, \"%lu\", policy->min);\n\tsnprintf(max, SYSFS_PATH_MAX, \"%lu\", policy->max);\n\n\told_min = sysfs_cpufreq_get_one_value(cpu, SCALING_MIN_FREQ);\n\twrite_max_first = (old_min && (policy->max < old_min) ? 0 : 1);\n\n\tif (write_max_first) {\n\t\tret = sysfs_cpufreq_write_one_value(cpu, WRITE_SCALING_MAX_FREQ,\n\t\t\t\t\t\t    max, strlen(max));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = sysfs_cpufreq_write_one_value(cpu, WRITE_SCALING_MIN_FREQ, min,\n\t\t\t\t\t    strlen(min));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!write_max_first) {\n\t\tret = sysfs_cpufreq_write_one_value(cpu, WRITE_SCALING_MAX_FREQ,\n\t\t\t\t\t\t    max, strlen(max));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn sysfs_cpufreq_write_one_value(cpu, WRITE_SCALING_GOVERNOR,\n\t\t\t\t\t     gov, strlen(gov));\n}\n\n\nint cpufreq_modify_policy_min(unsigned int cpu, unsigned long min_freq)\n{\n\tchar value[SYSFS_PATH_MAX];\n\n\tsnprintf(value, SYSFS_PATH_MAX, \"%lu\", min_freq);\n\n\treturn sysfs_cpufreq_write_one_value(cpu, WRITE_SCALING_MIN_FREQ,\n\t\t\t\t\t     value, strlen(value));\n}\n\n\nint cpufreq_modify_policy_max(unsigned int cpu, unsigned long max_freq)\n{\n\tchar value[SYSFS_PATH_MAX];\n\n\tsnprintf(value, SYSFS_PATH_MAX, \"%lu\", max_freq);\n\n\treturn sysfs_cpufreq_write_one_value(cpu, WRITE_SCALING_MAX_FREQ,\n\t\t\t\t\t     value, strlen(value));\n}\n\nint cpufreq_modify_policy_governor(unsigned int cpu, char *governor)\n{\n\tchar new_gov[SYSFS_PATH_MAX];\n\n\tif ((!governor) || (strlen(governor) > 19))\n\t\treturn -EINVAL;\n\n\tif (verify_gov(new_gov, governor))\n\t\treturn -EINVAL;\n\n\treturn sysfs_cpufreq_write_one_value(cpu, WRITE_SCALING_GOVERNOR,\n\t\t\t\t\t     new_gov, strlen(new_gov));\n}\n\nint cpufreq_set_frequency(unsigned int cpu, unsigned long target_frequency)\n{\n\tstruct cpufreq_policy *pol = cpufreq_get_policy(cpu);\n\tchar userspace_gov[] = \"userspace\";\n\tchar freq[SYSFS_PATH_MAX];\n\tint ret;\n\n\tif (!pol)\n\t\treturn -ENODEV;\n\n\tif (strncmp(pol->governor, userspace_gov, 9) != 0) {\n\t\tret = cpufreq_modify_policy_governor(cpu, userspace_gov);\n\t\tif (ret) {\n\t\t\tcpufreq_put_policy(pol);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcpufreq_put_policy(pol);\n\n\tsnprintf(freq, SYSFS_PATH_MAX, \"%lu\", target_frequency);\n\n\treturn sysfs_cpufreq_write_one_value(cpu, WRITE_SCALING_SET_SPEED,\n\t\t\t\t\t     freq, strlen(freq));\n}\n\nstruct cpufreq_stats *cpufreq_get_stats(unsigned int cpu,\n\t\t\t\t\tunsigned long long *total_time)\n{\n\tstruct cpufreq_stats *first = NULL;\n\tstruct cpufreq_stats *current = NULL;\n\tchar one_value[SYSFS_PATH_MAX];\n\tchar linebuf[MAX_LINE_LEN];\n\tunsigned int pos, i;\n\tunsigned int len;\n\n\tlen = sysfs_cpufreq_read_file(cpu, \"stats/time_in_state\",\n\t\t\t\tlinebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\t*total_time = 0;\n\tpos = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (i == strlen(linebuf) || linebuf[i] == '\\n')\t{\n\t\t\tif (i - pos < 2)\n\t\t\t\tcontinue;\n\t\t\tif ((i - pos) >= SYSFS_PATH_MAX)\n\t\t\t\tgoto error_out;\n\t\t\tif (current) {\n\t\t\t\tcurrent->next = malloc(sizeof(*current));\n\t\t\t\tif (!current->next)\n\t\t\t\t\tgoto error_out;\n\t\t\t\tcurrent = current->next;\n\t\t\t} else {\n\t\t\t\tfirst = malloc(sizeof(*first));\n\t\t\t\tif (!first)\n\t\t\t\t\treturn NULL;\n\t\t\t\tcurrent = first;\n\t\t\t}\n\t\t\tcurrent->first = first;\n\t\t\tcurrent->next = NULL;\n\n\t\t\tmemcpy(one_value, linebuf + pos, i - pos);\n\t\t\tone_value[i - pos] = '\\0';\n\t\t\tif (sscanf(one_value, \"%lu %llu\",\n\t\t\t\t\t&current->frequency,\n\t\t\t\t\t&current->time_in_state) != 2)\n\t\t\t\tgoto error_out;\n\n\t\t\t*total_time = *total_time + current->time_in_state;\n\t\t\tpos = i + 1;\n\t\t}\n\t}\n\n\treturn first;\n\n error_out:\n\twhile (first) {\n\t\tcurrent = first->next;\n\t\tfree(first);\n\t\tfirst = current;\n\t}\n\treturn NULL;\n}\n\nvoid cpufreq_put_stats(struct cpufreq_stats *any)\n{\n\tstruct cpufreq_stats *tmp, *next;\n\n\tif (!any)\n\t\treturn;\n\n\ttmp = any->first;\n\twhile (tmp) {\n\t\tnext = tmp->next;\n\t\tfree(tmp);\n\t\ttmp = next;\n\t}\n}\n\nunsigned long cpufreq_get_transitions(unsigned int cpu)\n{\n\treturn sysfs_cpufreq_get_one_value(cpu, STATS_NUM_TRANSITIONS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}