{
  "module_name": "cpupower.c",
  "hash_id": "4a2a5e4077700f379bb62c480f2215c091346b8dc4dc6c4bd51cecb53fc31271",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/lib/cpupower.c",
  "human_readable_source": "\n \n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n\n#include \"cpupower.h\"\n#include \"cpupower_intern.h\"\n\nint is_valid_path(const char *path)\n{\n\tif (access(path, F_OK) == -1)\n\t\treturn 0;\n\treturn 1;\n}\n\nunsigned int cpupower_read_sysfs(const char *path, char *buf, size_t buflen)\n{\n\tssize_t numread;\n\tint fd;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumread = read(fd, buf, buflen - 1);\n\tif (numread < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\tbuf[numread] = '\\0';\n\tclose(fd);\n\n\treturn (unsigned int) numread;\n}\n\nunsigned int cpupower_write_sysfs(const char *path, char *buf, size_t buflen)\n{\n\tssize_t numwritten;\n\tint fd;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumwritten = write(fd, buf, buflen - 1);\n\tif (numwritten < 1) {\n\t\tperror(path);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tclose(fd);\n\n\treturn (unsigned int) numwritten;\n}\n\n \nint cpupower_is_cpu_online(unsigned int cpu)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tint fd;\n\tssize_t numread;\n\tunsigned long long value;\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *endp;\n\tstruct stat statbuf;\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u\", cpu);\n\n\tif (stat(path, &statbuf) != 0)\n\t\treturn 0;\n\n\t \n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/online\", cpu);\n\tif (stat(path, &statbuf) != 0)\n\t\treturn 1;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn -errno;\n\n\tnumread = read(fd, linebuf, MAX_LINE_LEN - 1);\n\tif (numread < 1) {\n\t\tclose(fd);\n\t\treturn -EIO;\n\t}\n\tlinebuf[numread] = '\\0';\n\tclose(fd);\n\n\tvalue = strtoull(linebuf, &endp, 0);\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\treturn value;\n}\n\n \nstatic int sysfs_topology_read_file(unsigned int cpu, const char *fname, int *result)\n{\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *endp;\n\tchar path[SYSFS_PATH_MAX];\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/topology/%s\",\n\t\t\t cpu, fname);\n\tif (cpupower_read_sysfs(path, linebuf, MAX_LINE_LEN) == 0)\n\t\treturn -1;\n\t*result = strtol(linebuf, &endp, 0);\n\tif (endp == linebuf || errno == ERANGE)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int __compare(const void *t1, const void *t2)\n{\n\tstruct cpuid_core_info *top1 = (struct cpuid_core_info *)t1;\n\tstruct cpuid_core_info *top2 = (struct cpuid_core_info *)t2;\n\tif (top1->pkg < top2->pkg)\n\t\treturn -1;\n\telse if (top1->pkg > top2->pkg)\n\t\treturn 1;\n\telse if (top1->core < top2->core)\n\t\treturn -1;\n\telse if (top1->core > top2->core)\n\t\treturn 1;\n\telse if (top1->cpu < top2->cpu)\n\t\treturn -1;\n\telse if (top1->cpu > top2->cpu)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nint get_cpu_topology(struct cpupower_topology *cpu_top)\n{\n\tint cpu, last_pkg, cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\tcpu_top->core_info = malloc(sizeof(struct cpuid_core_info) * cpus);\n\tif (cpu_top->core_info == NULL)\n\t\treturn -ENOMEM;\n\tcpu_top->pkgs = cpu_top->cores = 0;\n\tfor (cpu = 0; cpu < cpus; cpu++) {\n\t\tcpu_top->core_info[cpu].cpu = cpu;\n\t\tcpu_top->core_info[cpu].is_online = cpupower_is_cpu_online(cpu);\n\t\tif(sysfs_topology_read_file(\n\t\t\tcpu,\n\t\t\t\"physical_package_id\",\n\t\t\t&(cpu_top->core_info[cpu].pkg)) < 0) {\n\t\t\tcpu_top->core_info[cpu].pkg = -1;\n\t\t\tcpu_top->core_info[cpu].core = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif(sysfs_topology_read_file(\n\t\t\tcpu,\n\t\t\t\"core_id\",\n\t\t\t&(cpu_top->core_info[cpu].core)) < 0) {\n\t\t\tcpu_top->core_info[cpu].pkg = -1;\n\t\t\tcpu_top->core_info[cpu].core = -1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tqsort(cpu_top->core_info, cpus, sizeof(struct cpuid_core_info),\n\t      __compare);\n\n\t \n\tlast_pkg = cpu_top->core_info[0].pkg;\n\tfor(cpu = 1; cpu < cpus; cpu++) {\n\t\tif (cpu_top->core_info[cpu].pkg != last_pkg &&\n\t\t\t\tcpu_top->core_info[cpu].pkg != -1) {\n\n\t\t\tlast_pkg = cpu_top->core_info[cpu].pkg;\n\t\t\tcpu_top->pkgs++;\n\t\t}\n\t}\n\tif (!(cpu_top->core_info[0].pkg == -1))\n\t\tcpu_top->pkgs++;\n\n\t \n\treturn cpus;\n}\n\nvoid cpu_topology_release(struct cpupower_topology cpu_top)\n{\n\tfree(cpu_top.core_info);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}