{
  "module_name": "cpuidle.c",
  "hash_id": "eb4b62dd051b149c4bddfd370b900a3a6f6014002026480c3848e53519b4bcde",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/lib/cpuidle.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"cpuidle.h\"\n#include \"cpupower_intern.h\"\n\n \nstatic\nunsigned int cpuidle_state_file_exists(unsigned int cpu,\n\t\t\t\t       unsigned int idlestate,\n\t\t\t\t       const char *fname)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tstruct stat statbuf;\n\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/cpuidle/state%u/%s\",\n\t\t cpu, idlestate, fname);\n\tif (stat(path, &statbuf) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic\nunsigned int cpuidle_state_read_file(unsigned int cpu,\n\t\t\t\t\t    unsigned int idlestate,\n\t\t\t\t\t    const char *fname, char *buf,\n\t\t\t\t\t    size_t buflen)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tint fd;\n\tssize_t numread;\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/cpuidle/state%u/%s\",\n\t\t cpu, idlestate, fname);\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumread = read(fd, buf, buflen - 1);\n\tif (numread < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\tbuf[numread] = '\\0';\n\tclose(fd);\n\n\treturn (unsigned int) numread;\n}\n\n \nstatic\nunsigned int cpuidle_state_write_file(unsigned int cpu,\n\t\t\t\t      unsigned int idlestate,\n\t\t\t\t      const char *fname,\n\t\t\t\t      const char *value, size_t len)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tint fd;\n\tssize_t numwrite;\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/cpuidle/state%u/%s\",\n\t\t cpu, idlestate, fname);\n\n\tfd = open(path, O_WRONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumwrite = write(fd, value, len);\n\tif (numwrite < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\tclose(fd);\n\n\treturn (unsigned int) numwrite;\n}\n\n \n\nenum idlestate_value {\n\tIDLESTATE_USAGE,\n\tIDLESTATE_POWER,\n\tIDLESTATE_LATENCY,\n\tIDLESTATE_TIME,\n\tIDLESTATE_DISABLE,\n\tMAX_IDLESTATE_VALUE_FILES\n};\n\nstatic const char *idlestate_value_files[MAX_IDLESTATE_VALUE_FILES] = {\n\t[IDLESTATE_USAGE] = \"usage\",\n\t[IDLESTATE_POWER] = \"power\",\n\t[IDLESTATE_LATENCY] = \"latency\",\n\t[IDLESTATE_TIME]  = \"time\",\n\t[IDLESTATE_DISABLE]  = \"disable\",\n};\n\nstatic\nunsigned long long cpuidle_state_get_one_value(unsigned int cpu,\n\t\t\t\t\t       unsigned int idlestate,\n\t\t\t\t\t       enum idlestate_value which)\n{\n\tunsigned long long value;\n\tunsigned int len;\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *endp;\n\n\tif (which >= MAX_IDLESTATE_VALUE_FILES)\n\t\treturn 0;\n\n\tlen = cpuidle_state_read_file(cpu, idlestate,\n\t\t\t\t      idlestate_value_files[which],\n\t\t\t\t      linebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn 0;\n\n\tvalue = strtoull(linebuf, &endp, 0);\n\n\tif (endp == linebuf || errno == ERANGE)\n\t\treturn 0;\n\n\treturn value;\n}\n\n \n\nenum idlestate_string {\n\tIDLESTATE_DESC,\n\tIDLESTATE_NAME,\n\tMAX_IDLESTATE_STRING_FILES\n};\n\nstatic const char *idlestate_string_files[MAX_IDLESTATE_STRING_FILES] = {\n\t[IDLESTATE_DESC] = \"desc\",\n\t[IDLESTATE_NAME] = \"name\",\n};\n\n\nstatic char *cpuidle_state_get_one_string(unsigned int cpu,\n\t\t\t\t\tunsigned int idlestate,\n\t\t\t\t\tenum idlestate_string which)\n{\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *result;\n\tunsigned int len;\n\n\tif (which >= MAX_IDLESTATE_STRING_FILES)\n\t\treturn NULL;\n\n\tlen = cpuidle_state_read_file(cpu, idlestate,\n\t\t\t\t      idlestate_string_files[which],\n\t\t\t\t      linebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\tresult = strdup(linebuf);\n\tif (result == NULL)\n\t\treturn NULL;\n\n\tif (result[strlen(result) - 1] == '\\n')\n\t\tresult[strlen(result) - 1] = '\\0';\n\n\treturn result;\n}\n\n \nint cpuidle_is_state_disabled(unsigned int cpu,\n\t\t\t\tunsigned int idlestate)\n{\n\tif (cpuidle_state_count(cpu) <= idlestate)\n\t\treturn -1;\n\n\tif (!cpuidle_state_file_exists(cpu, idlestate,\n\t\t\t\t idlestate_value_files[IDLESTATE_DISABLE]))\n\t\treturn -2;\n\treturn cpuidle_state_get_one_value(cpu, idlestate, IDLESTATE_DISABLE);\n}\n\n \nint cpuidle_state_disable(unsigned int cpu,\n\t\t\t    unsigned int idlestate,\n\t\t\t    unsigned int disable)\n{\n\tchar value[SYSFS_PATH_MAX];\n\tint bytes_written;\n\n\tif (cpuidle_state_count(cpu) <= idlestate)\n\t\treturn -1;\n\n\tif (!cpuidle_state_file_exists(cpu, idlestate,\n\t\t\t\t idlestate_value_files[IDLESTATE_DISABLE]))\n\t\treturn -2;\n\n\tsnprintf(value, SYSFS_PATH_MAX, \"%u\", disable);\n\n\tbytes_written = cpuidle_state_write_file(cpu, idlestate, \"disable\",\n\t\t\t\t\t\t   value, sizeof(disable));\n\tif (bytes_written)\n\t\treturn 0;\n\treturn -3;\n}\n\nunsigned long cpuidle_state_latency(unsigned int cpu,\n\t\t\t\t\t  unsigned int idlestate)\n{\n\treturn cpuidle_state_get_one_value(cpu, idlestate, IDLESTATE_LATENCY);\n}\n\nunsigned long cpuidle_state_usage(unsigned int cpu,\n\t\t\t\t\tunsigned int idlestate)\n{\n\treturn cpuidle_state_get_one_value(cpu, idlestate, IDLESTATE_USAGE);\n}\n\nunsigned long long cpuidle_state_time(unsigned int cpu,\n\t\t\t\t\tunsigned int idlestate)\n{\n\treturn cpuidle_state_get_one_value(cpu, idlestate, IDLESTATE_TIME);\n}\n\nchar *cpuidle_state_name(unsigned int cpu, unsigned int idlestate)\n{\n\treturn cpuidle_state_get_one_string(cpu, idlestate, IDLESTATE_NAME);\n}\n\nchar *cpuidle_state_desc(unsigned int cpu, unsigned int idlestate)\n{\n\treturn cpuidle_state_get_one_string(cpu, idlestate, IDLESTATE_DESC);\n}\n\n \nunsigned int cpuidle_state_count(unsigned int cpu)\n{\n\tchar file[SYSFS_PATH_MAX];\n\tstruct stat statbuf;\n\tint idlestates = 1;\n\n\n\tsnprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU \"cpuidle\");\n\tif (stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))\n\t\treturn 0;\n\n\tsnprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU \"cpu%u/cpuidle/state0\", cpu);\n\tif (stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))\n\t\treturn 0;\n\n\twhile (stat(file, &statbuf) == 0 && S_ISDIR(statbuf.st_mode)) {\n\t\tsnprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU\n\t\t\t \"cpu%u/cpuidle/state%d\", cpu, idlestates);\n\t\tidlestates++;\n\t}\n\tidlestates--;\n\treturn idlestates;\n}\n\n \n\n \nstatic unsigned int sysfs_cpuidle_read_file(const char *fname, char *buf,\n\t\t\t\t\t    size_t buflen)\n{\n\tchar path[SYSFS_PATH_MAX];\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpuidle/%s\", fname);\n\n\treturn cpupower_read_sysfs(path, buf, buflen);\n}\n\n\n\n \n\nenum cpuidle_string {\n\tCPUIDLE_GOVERNOR,\n\tCPUIDLE_GOVERNOR_RO,\n\tCPUIDLE_DRIVER,\n\tMAX_CPUIDLE_STRING_FILES\n};\n\nstatic const char *cpuidle_string_files[MAX_CPUIDLE_STRING_FILES] = {\n\t[CPUIDLE_GOVERNOR]\t= \"current_governor\",\n\t[CPUIDLE_GOVERNOR_RO]\t= \"current_governor_ro\",\n\t[CPUIDLE_DRIVER]\t= \"current_driver\",\n};\n\n\nstatic char *sysfs_cpuidle_get_one_string(enum cpuidle_string which)\n{\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *result;\n\tunsigned int len;\n\n\tif (which >= MAX_CPUIDLE_STRING_FILES)\n\t\treturn NULL;\n\n\tlen = sysfs_cpuidle_read_file(cpuidle_string_files[which],\n\t\t\t\tlinebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\tresult = strdup(linebuf);\n\tif (result == NULL)\n\t\treturn NULL;\n\n\tif (result[strlen(result) - 1] == '\\n')\n\t\tresult[strlen(result) - 1] = '\\0';\n\n\treturn result;\n}\n\nchar *cpuidle_get_governor(void)\n{\n\tchar *tmp = sysfs_cpuidle_get_one_string(CPUIDLE_GOVERNOR_RO);\n\tif (!tmp)\n\t\treturn sysfs_cpuidle_get_one_string(CPUIDLE_GOVERNOR);\n\telse\n\t\treturn tmp;\n}\n\nchar *cpuidle_get_driver(void)\n{\n\treturn sysfs_cpuidle_get_one_string(CPUIDLE_DRIVER);\n}\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}