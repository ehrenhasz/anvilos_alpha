{
  "module_name": "cpufreq-set.c",
  "hash_id": "7e6e5a92f085789fb4cd4937fa061ea527a01b636bbb8a266eeb59a4551ee909",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/cpufreq-set.c",
  "human_readable_source": "\n \n\n\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <ctype.h>\n\n#include <getopt.h>\n\n#include \"cpufreq.h\"\n#include \"cpuidle.h\"\n#include \"helpers/helpers.h\"\n\n#define NORM_FREQ_LEN 32\n\nstatic struct option set_opts[] = {\n\t{\"min\",\t\trequired_argument,\tNULL, 'd'},\n\t{\"max\",\t\trequired_argument,\tNULL, 'u'},\n\t{\"governor\",\trequired_argument,\tNULL, 'g'},\n\t{\"freq\",\trequired_argument,\tNULL, 'f'},\n\t{\"related\",\tno_argument,\t\tNULL, 'r'},\n\t{ },\n};\n\nstatic void print_error(void)\n{\n\tprintf(_(\"Error setting new values. Common errors:\\n\"\n\t\t\t\"- Do you have proper administration rights? (super-user?)\\n\"\n\t\t\t\"- Is the governor you requested available and modprobed?\\n\"\n\t\t\t\"- Trying to set an invalid policy?\\n\"\n\t\t\t\"- Trying to set a specific frequency, but userspace governor is not available,\\n\"\n\t\t\t\"   for example because of hardware which cannot be set to a specific frequency\\n\"\n\t\t\t\"   or because the userspace governor isn't loaded?\\n\"));\n};\n\nstruct freq_units {\n\tchar\t\t*str_unit;\n\tint\t\tpower_of_ten;\n};\n\nconst struct freq_units def_units[] = {\n\t{\"hz\", -3},\n\t{\"khz\", 0},  \n\t{\"mhz\", 3},\n\t{\"ghz\", 6},\n\t{\"thz\", 9},\n\t{NULL, 0}\n};\n\nstatic void print_unknown_arg(void)\n{\n\tprintf(_(\"invalid or unknown argument\\n\"));\n}\n\nstatic unsigned long string_to_frequency(const char *str)\n{\n\tchar normalized[NORM_FREQ_LEN];\n\tconst struct freq_units *unit;\n\tconst char *scan;\n\tchar *end;\n\tunsigned long freq;\n\tint power = 0, match_count = 0, i, cp, pad;\n\n\twhile (*str == '0')\n\t\tstr++;\n\n\tfor (scan = str; isdigit(*scan) || *scan == '.'; scan++) {\n\t\tif (*scan == '.' && match_count == 0)\n\t\t\tmatch_count = 1;\n\t\telse if (*scan == '.' && match_count == 1)\n\t\t\treturn 0;\n\t}\n\n\tif (*scan) {\n\t\tmatch_count = 0;\n\t\tfor (unit = def_units; unit->str_unit; unit++) {\n\t\t\tfor (i = 0;\n\t\t\t     scan[i] && tolower(scan[i]) == unit->str_unit[i];\n\t\t\t     ++i)\n\t\t\t\tcontinue;\n\t\t\tif (scan[i])\n\t\t\t\tcontinue;\n\t\t\tmatch_count++;\n\t\t\tpower = unit->power_of_ten;\n\t\t}\n\t\tif (match_count != 1)\n\t\t\treturn 0;\n\t}\n\n\t \n\tfor (cp = 0; isdigit(str[cp]); cp++)\n\t\tcontinue;\n\n\tif (str[cp] == '.') {\n\t\twhile (power > -1 && isdigit(str[cp+1])) {\n\t\t\tcp++;\n\t\t\tpower--;\n\t\t}\n\t}\n\tif (power >= -1) {\t\t \n\t\tpad = power + 1;\n\t} else {\t\t\t \n\t\tpad = 0;\n\t\tcp += power + 1;\n\t}\n\t \n\tif (cp <= 0 || cp + pad > NORM_FREQ_LEN - 1)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < cp; i++, str++) {\n\t\tif (*str == '.')\n\t\t\tstr++;\n\t\tnormalized[i] = *str;\n\t}\n\t \n\tfor (; i < cp + pad; i++)\n\t\tnormalized[i] = '0';\n\n\t \n\tmatch_count = (normalized[i-1] >= '5');\n\t \n\tnormalized[i-1] = 0;  \n\n\t \n\terrno = 0;\n\tfreq = strtoul(normalized, &end, 10);\n\tif (errno)\n\t\treturn 0;\n\telse {\n\t\tif (match_count && freq != ULONG_MAX)\n\t\t\tfreq++;\n\t\treturn freq;\n\t}\n}\n\nstatic int do_new_policy(unsigned int cpu, struct cpufreq_policy *new_pol)\n{\n\tstruct cpufreq_policy *cur_pol = cpufreq_get_policy(cpu);\n\tint ret;\n\n\tif (!cur_pol) {\n\t\tprintf(_(\"wrong, unknown or unhandled CPU?\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!new_pol->min)\n\t\tnew_pol->min = cur_pol->min;\n\n\tif (!new_pol->max)\n\t\tnew_pol->max = cur_pol->max;\n\n\tif (!new_pol->governor)\n\t\tnew_pol->governor = cur_pol->governor;\n\n\tret = cpufreq_set_policy(cpu, new_pol);\n\n\tcpufreq_put_policy(cur_pol);\n\n\treturn ret;\n}\n\n\nstatic int do_one_cpu(unsigned int cpu, struct cpufreq_policy *new_pol,\n\t\tunsigned long freq, unsigned int pc)\n{\n\tswitch (pc) {\n\tcase 0:\n\t\treturn cpufreq_set_frequency(cpu, freq);\n\n\tcase 1:\n\t\t \n\t\tif (new_pol->min)\n\t\t\treturn cpufreq_modify_policy_min(cpu, new_pol->min);\n\t\telse if (new_pol->max)\n\t\t\treturn cpufreq_modify_policy_max(cpu, new_pol->max);\n\t\telse if (new_pol->governor)\n\t\t\treturn cpufreq_modify_policy_governor(cpu,\n\t\t\t\t\t\t\tnew_pol->governor);\n\n\tdefault:\n\t\t \n\t\treturn do_new_policy(cpu, new_pol);\n\t}\n}\n\nint cmd_freq_set(int argc, char **argv)\n{\n\textern char *optarg;\n\textern int optind, opterr, optopt;\n\tint ret = 0, cont = 1;\n\tint double_parm = 0, related = 0, policychange = 0;\n\tunsigned long freq = 0;\n\tchar gov[20];\n\tunsigned int cpu;\n\n\tstruct cpufreq_policy new_pol = {\n\t\t.min = 0,\n\t\t.max = 0,\n\t\t.governor = NULL,\n\t};\n\n\t \n\tdo {\n\t\tret = getopt_long(argc, argv, \"d:u:g:f:r\", set_opts, NULL);\n\t\tswitch (ret) {\n\t\tcase '?':\n\t\t\tprint_unknown_arg();\n\t\t\treturn -EINVAL;\n\t\tcase -1:\n\t\t\tcont = 0;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (related)\n\t\t\t\tdouble_parm++;\n\t\t\trelated++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (new_pol.min)\n\t\t\t\tdouble_parm++;\n\t\t\tpolicychange++;\n\t\t\tnew_pol.min = string_to_frequency(optarg);\n\t\t\tif (new_pol.min == 0) {\n\t\t\t\tprint_unknown_arg();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (new_pol.max)\n\t\t\t\tdouble_parm++;\n\t\t\tpolicychange++;\n\t\t\tnew_pol.max = string_to_frequency(optarg);\n\t\t\tif (new_pol.max == 0) {\n\t\t\t\tprint_unknown_arg();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (freq)\n\t\t\t\tdouble_parm++;\n\t\t\tfreq = string_to_frequency(optarg);\n\t\t\tif (freq == 0) {\n\t\t\t\tprint_unknown_arg();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif (new_pol.governor)\n\t\t\t\tdouble_parm++;\n\t\t\tpolicychange++;\n\t\t\tif ((strlen(optarg) < 3) || (strlen(optarg) > 18)) {\n\t\t\t\tprint_unknown_arg();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif ((sscanf(optarg, \"%19s\", gov)) != 1) {\n\t\t\t\tprint_unknown_arg();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnew_pol.governor = gov;\n\t\t\tbreak;\n\t\t}\n\t} while (cont);\n\n\t \n\tif (double_parm) {\n\t\tprintf(\"the same parameter was passed more than once\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (freq && policychange) {\n\t\tprintf(_(\"the -f/--freq parameter cannot be combined with -d/--min, -u/--max or\\n\"\n\t\t\t\t\"-g/--governor parameters\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!freq && !policychange) {\n\t\tprintf(_(\"At least one parameter out of -f/--freq, -d/--min, -u/--max, and\\n\"\n\t\t\t\t\"-g/--governor must be passed\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bitmask_isallclear(cpus_chosen))\n\t\tbitmask_setall(cpus_chosen);\n\n\t \n\tif (related) {\n\t\tfor (cpu = bitmask_first(cpus_chosen);\n\t\t     cpu <= bitmask_last(cpus_chosen); cpu++) {\n\t\t\tstruct cpufreq_affected_cpus *cpus;\n\n\t\t\tif (!bitmask_isbitset(cpus_chosen, cpu) ||\n\t\t\t    cpupower_is_cpu_online(cpu) != 1)\n\t\t\t\tcontinue;\n\n\t\t\tcpus = cpufreq_get_related_cpus(cpu);\n\t\t\tif (!cpus)\n\t\t\t\tbreak;\n\t\t\twhile (cpus->next) {\n\t\t\t\tbitmask_setbit(cpus_chosen, cpus->cpu);\n\t\t\t\tcpus = cpus->next;\n\t\t\t}\n\t\t\t \n\t\t\tbitmask_setbit(cpus_chosen, cpus->cpu);\n\t\t\tcpufreq_put_related_cpus(cpus);\n\t\t}\n\t}\n\n\tget_cpustate();\n\n\t \n\tfor (cpu = bitmask_first(cpus_chosen);\n\t     cpu <= bitmask_last(cpus_chosen); cpu++) {\n\n\t\tif (!bitmask_isbitset(cpus_chosen, cpu) ||\n\t\t    cpupower_is_cpu_online(cpu) != 1)\n\t\t\tcontinue;\n\n\t\tprintf(_(\"Setting cpu: %d\\n\"), cpu);\n\t\tret = do_one_cpu(cpu, &new_pol, freq, policychange);\n\t\tif (ret) {\n\t\t\tprint_error();\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tprint_offline_cpus();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}