{
  "module_name": "powercap-info.c",
  "hash_id": "919e0b6a64e601aeadc3f0da72598563feb008c6e2801ccf39b0483745bdf598",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/powercap-info.c",
  "human_readable_source": "\n \n\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n\n#include <getopt.h>\n\n#include \"powercap.h\"\n#include \"helpers/helpers.h\"\n\nint powercap_show_all;\n\nstatic struct option info_opts[] = {\n\t{ \"all\",\t\tno_argument,\t\t NULL,\t 'a'},\n\t{ },\n};\n\nstatic int powercap_print_one_zone(struct powercap_zone *zone)\n{\n\tint mode, i, ret = 0;\n\tchar pr_prefix[1024] = \"\";\n\n\tfor (i = 0; i < zone->tree_depth && i < POWERCAP_MAX_TREE_DEPTH; i++)\n\t\tstrcat(pr_prefix, \"\\t\");\n\n\tprintf(\"%sZone: %s\", pr_prefix, zone->name);\n\tret = powercap_zone_get_enabled(zone, &mode);\n\tif (ret < 0)\n\t\treturn ret;\n\tprintf(\" (%s)\\n\", mode ? \"enabled\" : \"disabled\");\n\n\tif (zone->has_power_uw)\n\t\tprintf(_(\"%sPower can be monitored in micro Jules\\n\"),\n\t\t       pr_prefix);\n\n\tif (zone->has_energy_uj)\n\t\tprintf(_(\"%sPower can be monitored in micro Watts\\n\"),\n\t\t       pr_prefix);\n\n\tprintf(\"\\n\");\n\n\tif (ret != 0)\n\t\treturn ret;\n\treturn ret;\n}\n\nstatic int powercap_show(void)\n{\n\tstruct powercap_zone *root_zone;\n\tchar line[MAX_LINE_LEN] = \"\";\n\tint ret, val;\n\n\tret = powercap_get_driver(line, MAX_LINE_LEN);\n\tif (ret < 0) {\n\t\tprintf(_(\"No powercapping driver loaded\\n\"));\n\t\treturn ret;\n\t}\n\n\tprintf(\"Driver: %s\\n\", line);\n\tret = powercap_get_enabled(&val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!val) {\n\t\tprintf(_(\"Powercapping is disabled\\n\"));\n\t\treturn -1;\n\t}\n\n\tprintf(_(\"Powercap domain hierarchy:\\n\\n\"));\n\troot_zone = powercap_init_zones();\n\n\tif (root_zone == NULL) {\n\t\tprintf(_(\"No powercap info found\\n\"));\n\t\treturn 1;\n\t}\n\n\tpowercap_walk_zones(root_zone, powercap_print_one_zone);\n\n\treturn 0;\n}\n\nint cmd_cap_set(int argc, char **argv)\n{\n\treturn 0;\n};\nint cmd_cap_info(int argc, char **argv)\n{\n\tint ret = 0, cont = 1;\n\n\tdo {\n\t\tret = getopt_long(argc, argv, \"a\", info_opts, NULL);\n\t\tswitch (ret) {\n\t\tcase '?':\n\t\t\tcont = 0;\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tcont = 0;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tpowercap_show_all = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, _(\"invalid or unknown argument\\n\"));\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t} while (cont);\n\n\tpowercap_show();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}