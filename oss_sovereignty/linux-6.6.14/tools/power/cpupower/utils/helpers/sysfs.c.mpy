{
  "module_name": "sysfs.c",
  "hash_id": "af1f3d09141fc507918c1ec0aecfda1ee35c4c9d2be8c453f9bbc5a3f35d3e18",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/helpers/sysfs.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"helpers/sysfs.h\"\n\nunsigned int sysfs_read_file(const char *path, char *buf, size_t buflen)\n{\n\tint fd;\n\tssize_t numread;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumread = read(fd, buf, buflen - 1);\n\tif (numread < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\tbuf[numread] = '\\0';\n\tclose(fd);\n\n\treturn (unsigned int) numread;\n}\n\n \nint sysfs_is_cpu_online(unsigned int cpu)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tint fd;\n\tssize_t numread;\n\tunsigned long long value;\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *endp;\n\tstruct stat statbuf;\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u\", cpu);\n\n\tif (stat(path, &statbuf) != 0)\n\t\treturn 0;\n\n\t \n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/online\", cpu);\n\tif (stat(path, &statbuf) != 0)\n\t\treturn 1;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn -errno;\n\n\tnumread = read(fd, linebuf, MAX_LINE_LEN - 1);\n\tif (numread < 1) {\n\t\tclose(fd);\n\t\treturn -EIO;\n\t}\n\tlinebuf[numread] = '\\0';\n\tclose(fd);\n\n\tvalue = strtoull(linebuf, &endp, 0);\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\treturn value;\n}\n\n \n\n\n \n\n \nunsigned int sysfs_idlestate_file_exists(unsigned int cpu,\n\t\t\t\t\t unsigned int idlestate,\n\t\t\t\t\t const char *fname)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tstruct stat statbuf;\n\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/cpuidle/state%u/%s\",\n\t\t cpu, idlestate, fname);\n\tif (stat(path, &statbuf) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nunsigned int sysfs_idlestate_read_file(unsigned int cpu, unsigned int idlestate,\n\t\t\t     const char *fname, char *buf, size_t buflen)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tint fd;\n\tssize_t numread;\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/cpuidle/state%u/%s\",\n\t\t cpu, idlestate, fname);\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumread = read(fd, buf, buflen - 1);\n\tif (numread < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\tbuf[numread] = '\\0';\n\tclose(fd);\n\n\treturn (unsigned int) numread;\n}\n\n \nstatic\nunsigned int sysfs_idlestate_write_file(unsigned int cpu,\n\t\t\t\t\tunsigned int idlestate,\n\t\t\t\t\tconst char *fname,\n\t\t\t\t\tconst char *value, size_t len)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tint fd;\n\tssize_t numwrite;\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/cpuidle/state%u/%s\",\n\t\t cpu, idlestate, fname);\n\n\tfd = open(path, O_WRONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumwrite = write(fd, value, len);\n\tif (numwrite < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\tclose(fd);\n\n\treturn (unsigned int) numwrite;\n}\n\n \n\nenum idlestate_value {\n\tIDLESTATE_USAGE,\n\tIDLESTATE_POWER,\n\tIDLESTATE_LATENCY,\n\tIDLESTATE_TIME,\n\tIDLESTATE_DISABLE,\n\tMAX_IDLESTATE_VALUE_FILES\n};\n\nstatic const char *idlestate_value_files[MAX_IDLESTATE_VALUE_FILES] = {\n\t[IDLESTATE_USAGE] = \"usage\",\n\t[IDLESTATE_POWER] = \"power\",\n\t[IDLESTATE_LATENCY] = \"latency\",\n\t[IDLESTATE_TIME]  = \"time\",\n\t[IDLESTATE_DISABLE]  = \"disable\",\n};\n\nstatic unsigned long long sysfs_idlestate_get_one_value(unsigned int cpu,\n\t\t\t\t\t\t     unsigned int idlestate,\n\t\t\t\t\t\t     enum idlestate_value which)\n{\n\tunsigned long long value;\n\tunsigned int len;\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *endp;\n\n\tif (which >= MAX_IDLESTATE_VALUE_FILES)\n\t\treturn 0;\n\n\tlen = sysfs_idlestate_read_file(cpu, idlestate,\n\t\t\t\t\tidlestate_value_files[which],\n\t\t\t\t\tlinebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn 0;\n\n\tvalue = strtoull(linebuf, &endp, 0);\n\n\tif (endp == linebuf || errno == ERANGE)\n\t\treturn 0;\n\n\treturn value;\n}\n\n \n\nenum idlestate_string {\n\tIDLESTATE_DESC,\n\tIDLESTATE_NAME,\n\tMAX_IDLESTATE_STRING_FILES\n};\n\nstatic const char *idlestate_string_files[MAX_IDLESTATE_STRING_FILES] = {\n\t[IDLESTATE_DESC] = \"desc\",\n\t[IDLESTATE_NAME] = \"name\",\n};\n\n\nstatic char *sysfs_idlestate_get_one_string(unsigned int cpu,\n\t\t\t\t\tunsigned int idlestate,\n\t\t\t\t\tenum idlestate_string which)\n{\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *result;\n\tunsigned int len;\n\n\tif (which >= MAX_IDLESTATE_STRING_FILES)\n\t\treturn NULL;\n\n\tlen = sysfs_idlestate_read_file(cpu, idlestate,\n\t\t\t\t\tidlestate_string_files[which],\n\t\t\t\t\tlinebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\tresult = strdup(linebuf);\n\tif (result == NULL)\n\t\treturn NULL;\n\n\tif (result[strlen(result) - 1] == '\\n')\n\t\tresult[strlen(result) - 1] = '\\0';\n\n\treturn result;\n}\n\n \nint sysfs_is_idlestate_disabled(unsigned int cpu,\n\t\t\t\tunsigned int idlestate)\n{\n\tif (sysfs_get_idlestate_count(cpu) <= idlestate)\n\t\treturn -1;\n\n\tif (!sysfs_idlestate_file_exists(cpu, idlestate,\n\t\t\t\t idlestate_value_files[IDLESTATE_DISABLE]))\n\t\treturn -2;\n\treturn sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_DISABLE);\n}\n\n \nint sysfs_idlestate_disable(unsigned int cpu,\n\t\t\t    unsigned int idlestate,\n\t\t\t    unsigned int disable)\n{\n\tchar value[SYSFS_PATH_MAX];\n\tint bytes_written;\n\n\tif (sysfs_get_idlestate_count(cpu) <= idlestate)\n\t\treturn -1;\n\n\tif (!sysfs_idlestate_file_exists(cpu, idlestate,\n\t\t\t\t idlestate_value_files[IDLESTATE_DISABLE]))\n\t\treturn -2;\n\n\tsnprintf(value, SYSFS_PATH_MAX, \"%u\", disable);\n\n\tbytes_written = sysfs_idlestate_write_file(cpu, idlestate, \"disable\",\n\t\t\t\t\t\t   value, sizeof(disable));\n\tif (bytes_written)\n\t\treturn 0;\n\treturn -3;\n}\n\nunsigned long sysfs_get_idlestate_latency(unsigned int cpu,\n\t\t\t\t\t  unsigned int idlestate)\n{\n\treturn sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_LATENCY);\n}\n\nunsigned long sysfs_get_idlestate_usage(unsigned int cpu,\n\t\t\t\t\tunsigned int idlestate)\n{\n\treturn sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_USAGE);\n}\n\nunsigned long long sysfs_get_idlestate_time(unsigned int cpu,\n\t\t\t\t\tunsigned int idlestate)\n{\n\treturn sysfs_idlestate_get_one_value(cpu, idlestate, IDLESTATE_TIME);\n}\n\nchar *sysfs_get_idlestate_name(unsigned int cpu, unsigned int idlestate)\n{\n\treturn sysfs_idlestate_get_one_string(cpu, idlestate, IDLESTATE_NAME);\n}\n\nchar *sysfs_get_idlestate_desc(unsigned int cpu, unsigned int idlestate)\n{\n\treturn sysfs_idlestate_get_one_string(cpu, idlestate, IDLESTATE_DESC);\n}\n\n \nunsigned int sysfs_get_idlestate_count(unsigned int cpu)\n{\n\tchar file[SYSFS_PATH_MAX];\n\tstruct stat statbuf;\n\tint idlestates = 1;\n\n\n\tsnprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU \"cpuidle\");\n\tif (stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))\n\t\treturn 0;\n\n\tsnprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU \"cpu%u/cpuidle/state0\", cpu);\n\tif (stat(file, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))\n\t\treturn 0;\n\n\twhile (stat(file, &statbuf) == 0 && S_ISDIR(statbuf.st_mode)) {\n\t\tsnprintf(file, SYSFS_PATH_MAX, PATH_TO_CPU\n\t\t\t \"cpu%u/cpuidle/state%d\", cpu, idlestates);\n\t\tidlestates++;\n\t}\n\tidlestates--;\n\treturn idlestates;\n}\n\n \n\n \nstatic unsigned int sysfs_cpuidle_read_file(const char *fname, char *buf,\n\t\t\t\t\t    size_t buflen)\n{\n\tchar path[SYSFS_PATH_MAX];\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpuidle/%s\", fname);\n\n\treturn sysfs_read_file(path, buf, buflen);\n}\n\n\n\n \n\nenum cpuidle_string {\n\tCPUIDLE_GOVERNOR,\n\tCPUIDLE_GOVERNOR_RO,\n\tCPUIDLE_DRIVER,\n\tMAX_CPUIDLE_STRING_FILES\n};\n\nstatic const char *cpuidle_string_files[MAX_CPUIDLE_STRING_FILES] = {\n\t[CPUIDLE_GOVERNOR]\t= \"current_governor\",\n\t[CPUIDLE_GOVERNOR_RO]\t= \"current_governor_ro\",\n\t[CPUIDLE_DRIVER]\t= \"current_driver\",\n};\n\n\nstatic char *sysfs_cpuidle_get_one_string(enum cpuidle_string which)\n{\n\tchar linebuf[MAX_LINE_LEN];\n\tchar *result;\n\tunsigned int len;\n\n\tif (which >= MAX_CPUIDLE_STRING_FILES)\n\t\treturn NULL;\n\n\tlen = sysfs_cpuidle_read_file(cpuidle_string_files[which],\n\t\t\t\tlinebuf, sizeof(linebuf));\n\tif (len == 0)\n\t\treturn NULL;\n\n\tresult = strdup(linebuf);\n\tif (result == NULL)\n\t\treturn NULL;\n\n\tif (result[strlen(result) - 1] == '\\n')\n\t\tresult[strlen(result) - 1] = '\\0';\n\n\treturn result;\n}\n\nchar *sysfs_get_cpuidle_governor(void)\n{\n\tchar *tmp = sysfs_cpuidle_get_one_string(CPUIDLE_GOVERNOR_RO);\n\tif (!tmp)\n\t\treturn sysfs_cpuidle_get_one_string(CPUIDLE_GOVERNOR);\n\telse\n\t\treturn tmp;\n}\n\nchar *sysfs_get_cpuidle_driver(void)\n{\n\treturn sysfs_cpuidle_get_one_string(CPUIDLE_DRIVER);\n}\n \n\n \nint sysfs_get_sched(const char *smt_mc)\n{\n\treturn -ENODEV;\n}\n\n \nint sysfs_set_sched(const char *smt_mc, int val)\n{\n\treturn -ENODEV;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}