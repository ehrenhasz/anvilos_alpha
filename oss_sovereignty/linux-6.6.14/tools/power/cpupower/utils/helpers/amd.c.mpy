{
  "module_name": "amd.c",
  "hash_id": "b1c190f931a8691e464e8422e2b7eaa1875f9c639a25f8fddbd6b6705b4bfad8",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/helpers/amd.c",
  "human_readable_source": "\n#if defined(__i386__) || defined(__x86_64__)\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdint.h>\n\n#include <pci/pci.h>\n\n#include \"helpers/helpers.h\"\n#include \"cpufreq.h\"\n#include \"acpi_cppc.h\"\n\n \n#define MSR_AMD_PSTATE_STATUS\t0xc0010063\n#define MSR_AMD_PSTATE\t\t0xc0010064\n#define MSR_AMD_PSTATE_LIMIT\t0xc0010061\n\nunion core_pstate {\n\t \n\tstruct {\n\t\tunsigned fid:6;\n\t\tunsigned did:3;\n\t\tunsigned vid:7;\n\t\tunsigned res1:6;\n\t\tunsigned nbdid:1;\n\t\tunsigned res2:2;\n\t\tunsigned nbvid:7;\n\t\tunsigned iddval:8;\n\t\tunsigned idddiv:2;\n\t\tunsigned res3:21;\n\t\tunsigned en:1;\n\t} pstate;\n\t \n\tstruct {\n\t\tunsigned fid:8;\n\t\tunsigned did:6;\n\t\tunsigned vid:8;\n\t\tunsigned iddval:8;\n\t\tunsigned idddiv:2;\n\t\tunsigned res1:31;\n\t\tunsigned en:1;\n\t} pstatedef;\n\tunsigned long long val;\n};\n\nstatic int get_did(union core_pstate pstate)\n{\n\tint t;\n\n\tif (cpupower_cpu_info.caps & CPUPOWER_CAP_AMD_PSTATEDEF)\n\t\tt = pstate.pstatedef.did;\n\telse if (cpupower_cpu_info.family == 0x12)\n\t\tt = pstate.val & 0xf;\n\telse\n\t\tt = pstate.pstate.did;\n\n\treturn t;\n}\n\nstatic int get_cof(union core_pstate pstate)\n{\n\tint t;\n\tint fid, did, cof;\n\n\tdid = get_did(pstate);\n\tif (cpupower_cpu_info.caps & CPUPOWER_CAP_AMD_PSTATEDEF) {\n\t\tfid = pstate.pstatedef.fid;\n\t\tcof = 200 * fid / did;\n\t} else {\n\t\tt = 0x10;\n\t\tfid = pstate.pstate.fid;\n\t\tif (cpupower_cpu_info.family == 0x11)\n\t\t\tt = 0x8;\n\t\tcof = (100 * (fid + t)) >> did;\n\t}\n\treturn cof;\n}\n\n \nint decode_pstates(unsigned int cpu, int boost_states,\n\t\t   unsigned long *pstates, int *no)\n{\n\tint i, psmax;\n\tunion core_pstate pstate;\n\tunsigned long long val;\n\n\t \n\tif (!(cpupower_cpu_info.caps & CPUPOWER_CAP_AMD_HW_PSTATE))\n\t\treturn -1;\n\n\tif (read_msr(cpu, MSR_AMD_PSTATE_LIMIT, &val))\n\t\treturn -1;\n\n\tpsmax = (val >> 4) & 0x7;\n\tpsmax += boost_states;\n\tfor (i = 0; i <= psmax; i++) {\n\t\tif (i >= MAX_HW_PSTATES) {\n\t\t\tfprintf(stderr, \"HW pstates [%d] exceeding max [%d]\\n\",\n\t\t\t\tpsmax, MAX_HW_PSTATES);\n\t\t\treturn -1;\n\t\t}\n\t\tif (read_msr(cpu, MSR_AMD_PSTATE + i, &pstate.val))\n\t\t\treturn -1;\n\n\t\t \n\t\tif (!pstate.pstatedef.en)\n\t\t\tcontinue;\n\n\t\tpstates[i] = get_cof(pstate);\n\t}\n\t*no = i;\n\treturn 0;\n}\n\nint amd_pci_get_num_boost_states(int *active, int *states)\n{\n\tstruct pci_access *pci_acc;\n\tstruct pci_dev *device;\n\tuint8_t val = 0;\n\n\t*active = *states = 0;\n\n\tdevice = pci_slot_func_init(&pci_acc, 0x18, 4);\n\n\tif (device == NULL)\n\t\treturn -ENODEV;\n\n\tval = pci_read_byte(device, 0x15c);\n\tif (val & 3)\n\t\t*active = 1;\n\telse\n\t\t*active = 0;\n\t*states = (val >> 2) & 7;\n\n\tpci_cleanup(pci_acc);\n\treturn 0;\n}\n\n \n\n \nenum amd_pstate_value {\n\tAMD_PSTATE_HIGHEST_PERF,\n\tAMD_PSTATE_MAX_FREQ,\n\tAMD_PSTATE_LOWEST_NONLINEAR_FREQ,\n\tMAX_AMD_PSTATE_VALUE_READ_FILES,\n};\n\nstatic const char *amd_pstate_value_files[MAX_AMD_PSTATE_VALUE_READ_FILES] = {\n\t[AMD_PSTATE_HIGHEST_PERF] = \"amd_pstate_highest_perf\",\n\t[AMD_PSTATE_MAX_FREQ] = \"amd_pstate_max_freq\",\n\t[AMD_PSTATE_LOWEST_NONLINEAR_FREQ] = \"amd_pstate_lowest_nonlinear_freq\",\n};\n\nstatic unsigned long amd_pstate_get_data(unsigned int cpu,\n\t\t\t\t\t enum amd_pstate_value value)\n{\n\treturn cpufreq_get_sysfs_value_from_table(cpu,\n\t\t\t\t\t\t  amd_pstate_value_files,\n\t\t\t\t\t\t  value,\n\t\t\t\t\t\t  MAX_AMD_PSTATE_VALUE_READ_FILES);\n}\n\nvoid amd_pstate_boost_init(unsigned int cpu, int *support, int *active)\n{\n\tunsigned long highest_perf, nominal_perf, cpuinfo_min,\n\t\t      cpuinfo_max, amd_pstate_max;\n\n\thighest_perf = amd_pstate_get_data(cpu, AMD_PSTATE_HIGHEST_PERF);\n\tnominal_perf = acpi_cppc_get_data(cpu, NOMINAL_PERF);\n\n\t*support = highest_perf > nominal_perf ? 1 : 0;\n\tif (!(*support))\n\t\treturn;\n\n\tcpufreq_get_hardware_limits(cpu, &cpuinfo_min, &cpuinfo_max);\n\tamd_pstate_max = amd_pstate_get_data(cpu, AMD_PSTATE_MAX_FREQ);\n\n\t*active = cpuinfo_max == amd_pstate_max ? 1 : 0;\n}\n\nvoid amd_pstate_show_perf_and_freq(unsigned int cpu, int no_rounding)\n{\n\tprintf(_(\"    AMD PSTATE Highest Performance: %lu. Maximum Frequency: \"),\n\t       amd_pstate_get_data(cpu, AMD_PSTATE_HIGHEST_PERF));\n\t \n\tprint_speed(amd_pstate_get_data(cpu, AMD_PSTATE_MAX_FREQ), no_rounding);\n\tprintf(\".\\n\");\n\n\tprintf(_(\"    AMD PSTATE Nominal Performance: %lu. Nominal Frequency: \"),\n\t       acpi_cppc_get_data(cpu, NOMINAL_PERF));\n\tprint_speed(acpi_cppc_get_data(cpu, NOMINAL_FREQ) * 1000,\n\t\t    no_rounding);\n\tprintf(\".\\n\");\n\n\tprintf(_(\"    AMD PSTATE Lowest Non-linear Performance: %lu. Lowest Non-linear Frequency: \"),\n\t       acpi_cppc_get_data(cpu, LOWEST_NONLINEAR_PERF));\n\tprint_speed(amd_pstate_get_data(cpu, AMD_PSTATE_LOWEST_NONLINEAR_FREQ),\n\t\t    no_rounding);\n\tprintf(\".\\n\");\n\n\tprintf(_(\"    AMD PSTATE Lowest Performance: %lu. Lowest Frequency: \"),\n\t       acpi_cppc_get_data(cpu, LOWEST_PERF));\n\tprint_speed(acpi_cppc_get_data(cpu, LOWEST_FREQ) * 1000, no_rounding);\n\tprintf(\".\\n\");\n}\n\n \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}