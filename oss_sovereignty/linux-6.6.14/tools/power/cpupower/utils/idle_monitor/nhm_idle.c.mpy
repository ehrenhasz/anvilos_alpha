{
  "module_name": "nhm_idle.c",
  "hash_id": "4863ccf2cd9464627b9f77105ca9f1160681a34e1691d3fd1ae60281d55767c0",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/idle_monitor/nhm_idle.c",
  "human_readable_source": "\n \n\n#if defined(__i386__) || defined(__x86_64__)\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"helpers/helpers.h\"\n#include \"idle_monitor/cpupower-monitor.h\"\n\n#define MSR_PKG_C3_RESIDENCY\t0x3F8\n#define MSR_PKG_C6_RESIDENCY\t0x3F9\n#define MSR_CORE_C3_RESIDENCY\t0x3FC\n#define MSR_CORE_C6_RESIDENCY\t0x3FD\n\n#define MSR_TSC\t0x10\n\n#define NHM_CSTATE_COUNT 4\n\nenum intel_nhm_id { C3 = 0, C6, PC3, PC6, TSC = 0xFFFF };\n\nstatic int nhm_get_count_percent(unsigned int self_id, double *percent,\n\t\t\t\t unsigned int cpu);\n\nstatic cstate_t nhm_cstates[NHM_CSTATE_COUNT] = {\n\t{\n\t\t.name\t\t\t= \"C3\",\n\t\t.desc\t\t\t= N_(\"Processor Core C3\"),\n\t\t.id\t\t\t= C3,\n\t\t.range\t\t\t= RANGE_CORE,\n\t\t.get_count_percent\t= nhm_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"C6\",\n\t\t.desc\t\t\t= N_(\"Processor Core C6\"),\n\t\t.id\t\t\t= C6,\n\t\t.range\t\t\t= RANGE_CORE,\n\t\t.get_count_percent\t= nhm_get_count_percent,\n\t},\n\n\t{\n\t\t.name\t\t\t= \"PC3\",\n\t\t.desc\t\t\t= N_(\"Processor Package C3\"),\n\t\t.id\t\t\t= PC3,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= nhm_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"PC6\",\n\t\t.desc\t\t\t= N_(\"Processor Package C6\"),\n\t\t.id\t\t\t= PC6,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= nhm_get_count_percent,\n\t},\n};\n\nstatic unsigned long long tsc_at_measure_start;\nstatic unsigned long long tsc_at_measure_end;\nstatic unsigned long long *previous_count[NHM_CSTATE_COUNT];\nstatic unsigned long long *current_count[NHM_CSTATE_COUNT];\n \nstatic int *is_valid;\n\nstatic int nhm_get_count(enum intel_nhm_id id, unsigned long long *val,\n\t\t\tunsigned int cpu)\n{\n\tint msr;\n\n\tswitch (id) {\n\tcase C3:\n\t\tmsr = MSR_CORE_C3_RESIDENCY;\n\t\tbreak;\n\tcase C6:\n\t\tmsr = MSR_CORE_C6_RESIDENCY;\n\t\tbreak;\n\tcase PC3:\n\t\tmsr = MSR_PKG_C3_RESIDENCY;\n\t\tbreak;\n\tcase PC6:\n\t\tmsr = MSR_PKG_C6_RESIDENCY;\n\t\tbreak;\n\tcase TSC:\n\t\tmsr = MSR_TSC;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\tif (read_msr(cpu, msr, val))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int nhm_get_count_percent(unsigned int id, double *percent,\n\t\t\t\t unsigned int cpu)\n{\n\t*percent = 0.0;\n\n\tif (!is_valid[cpu])\n\t\treturn -1;\n\n\t*percent = (100.0 *\n\t\t(current_count[id][cpu] - previous_count[id][cpu])) /\n\t\t(tsc_at_measure_end - tsc_at_measure_start);\n\n\tdprint(\"%s: previous: %llu - current: %llu - (%u)\\n\",\n\t\tnhm_cstates[id].name, previous_count[id][cpu],\n\t\tcurrent_count[id][cpu], cpu);\n\n\tdprint(\"%s: tsc_diff: %llu - count_diff: %llu - percent: %2.f (%u)\\n\",\n\t       nhm_cstates[id].name,\n\t       (unsigned long long) tsc_at_measure_end - tsc_at_measure_start,\n\t       current_count[id][cpu] - previous_count[id][cpu],\n\t       *percent, cpu);\n\n\treturn 0;\n}\n\nstatic int nhm_start(void)\n{\n\tint num, cpu;\n\tunsigned long long dbg, val;\n\n\tnhm_get_count(TSC, &tsc_at_measure_start, base_cpu);\n\n\tfor (num = 0; num < NHM_CSTATE_COUNT; num++) {\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\t\tis_valid[cpu] = !nhm_get_count(num, &val, cpu);\n\t\t\tprevious_count[num][cpu] = val;\n\t\t}\n\t}\n\tnhm_get_count(TSC, &dbg, base_cpu);\n\tdprint(\"TSC diff: %llu\\n\", dbg - tsc_at_measure_start);\n\treturn 0;\n}\n\nstatic int nhm_stop(void)\n{\n\tunsigned long long val;\n\tunsigned long long dbg;\n\tint num, cpu;\n\n\tnhm_get_count(TSC, &tsc_at_measure_end, base_cpu);\n\n\tfor (num = 0; num < NHM_CSTATE_COUNT; num++) {\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\t\tis_valid[cpu] = !nhm_get_count(num, &val, cpu);\n\t\t\tcurrent_count[num][cpu] = val;\n\t\t}\n\t}\n\tnhm_get_count(TSC, &dbg, base_cpu);\n\tdprint(\"TSC diff: %llu\\n\", dbg - tsc_at_measure_end);\n\n\treturn 0;\n}\n\nstruct cpuidle_monitor intel_nhm_monitor;\n\nstruct cpuidle_monitor *intel_nhm_register(void)\n{\n\tint num;\n\n\tif (cpupower_cpu_info.vendor != X86_VENDOR_INTEL)\n\t\treturn NULL;\n\n\tif (!(cpupower_cpu_info.caps & CPUPOWER_CAP_INV_TSC))\n\t\treturn NULL;\n\n\tif (!(cpupower_cpu_info.caps & CPUPOWER_CAP_APERF))\n\t\treturn NULL;\n\n\t \n\tis_valid = calloc(cpu_count, sizeof(int));\n\tfor (num = 0; num < NHM_CSTATE_COUNT; num++) {\n\t\tprevious_count[num] = calloc(cpu_count,\n\t\t\t\t\tsizeof(unsigned long long));\n\t\tcurrent_count[num]  = calloc(cpu_count,\n\t\t\t\t\tsizeof(unsigned long long));\n\t}\n\n\tintel_nhm_monitor.name_len = strlen(intel_nhm_monitor.name);\n\treturn &intel_nhm_monitor;\n}\n\nvoid intel_nhm_unregister(void)\n{\n\tint num;\n\n\tfor (num = 0; num < NHM_CSTATE_COUNT; num++) {\n\t\tfree(previous_count[num]);\n\t\tfree(current_count[num]);\n\t}\n\tfree(is_valid);\n}\n\nstruct cpuidle_monitor intel_nhm_monitor = {\n\t.name\t\t\t= \"Nehalem\",\n\t.hw_states_num\t\t= NHM_CSTATE_COUNT,\n\t.hw_states\t\t= nhm_cstates,\n\t.start\t\t\t= nhm_start,\n\t.stop\t\t\t= nhm_stop,\n\t.do_register\t\t= intel_nhm_register,\n\t.unregister\t\t= intel_nhm_unregister,\n\t.flags.needs_root\t= 1,\n\t.overflow_s\t\t= 922000000  \n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}