{
  "module_name": "hsw_ext_idle.c",
  "hash_id": "6397bcf6e683c1a64c2560bc8b5e610a4bcd8d80831989255687a68781da730f",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/idle_monitor/hsw_ext_idle.c",
  "human_readable_source": "\n \n\n#if defined(__i386__) || defined(__x86_64__)\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"helpers/helpers.h\"\n#include \"idle_monitor/cpupower-monitor.h\"\n\n#define MSR_PKG_C8_RESIDENCY           0x00000630\n#define MSR_PKG_C9_RESIDENCY           0x00000631\n#define MSR_PKG_C10_RESIDENCY          0x00000632\n\n#define MSR_TSC\t0x10\n\nenum intel_hsw_ext_id { PC8 = 0, PC9, PC10, HSW_EXT_CSTATE_COUNT,\n\t\t\tTSC = 0xFFFF };\n\nstatic int hsw_ext_get_count_percent(unsigned int self_id, double *percent,\n\t\t\t\t unsigned int cpu);\n\nstatic cstate_t hsw_ext_cstates[HSW_EXT_CSTATE_COUNT] = {\n\t{\n\t\t.name\t\t\t= \"PC8\",\n\t\t.desc\t\t\t= N_(\"Processor Package C8\"),\n\t\t.id\t\t\t= PC8,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= hsw_ext_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"PC9\",\n\t\t.desc\t\t\t= N_(\"Processor Package C9\"),\n\t\t.id\t\t\t= PC9,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= hsw_ext_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"PC10\",\n\t\t.desc\t\t\t= N_(\"Processor Package C10\"),\n\t\t.id\t\t\t= PC10,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= hsw_ext_get_count_percent,\n\t},\n};\n\nstatic unsigned long long tsc_at_measure_start;\nstatic unsigned long long tsc_at_measure_end;\nstatic unsigned long long *previous_count[HSW_EXT_CSTATE_COUNT];\nstatic unsigned long long *current_count[HSW_EXT_CSTATE_COUNT];\n \nstatic int *is_valid;\n\nstatic int hsw_ext_get_count(enum intel_hsw_ext_id id, unsigned long long *val,\n\t\t\tunsigned int cpu)\n{\n\tint msr;\n\n\tswitch (id) {\n\tcase PC8:\n\t\tmsr = MSR_PKG_C8_RESIDENCY;\n\t\tbreak;\n\tcase PC9:\n\t\tmsr = MSR_PKG_C9_RESIDENCY;\n\t\tbreak;\n\tcase PC10:\n\t\tmsr = MSR_PKG_C10_RESIDENCY;\n\t\tbreak;\n\tcase TSC:\n\t\tmsr = MSR_TSC;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\tif (read_msr(cpu, msr, val))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int hsw_ext_get_count_percent(unsigned int id, double *percent,\n\t\t\t\t unsigned int cpu)\n{\n\t*percent = 0.0;\n\n\tif (!is_valid[cpu])\n\t\treturn -1;\n\n\t*percent = (100.0 *\n\t\t(current_count[id][cpu] - previous_count[id][cpu])) /\n\t\t(tsc_at_measure_end - tsc_at_measure_start);\n\n\tdprint(\"%s: previous: %llu - current: %llu - (%u)\\n\",\n\t\thsw_ext_cstates[id].name, previous_count[id][cpu],\n\t\tcurrent_count[id][cpu], cpu);\n\n\tdprint(\"%s: tsc_diff: %llu - count_diff: %llu - percent: %2.f (%u)\\n\",\n\t       hsw_ext_cstates[id].name,\n\t       (unsigned long long) tsc_at_measure_end - tsc_at_measure_start,\n\t       current_count[id][cpu] - previous_count[id][cpu],\n\t       *percent, cpu);\n\n\treturn 0;\n}\n\nstatic int hsw_ext_start(void)\n{\n\tint num, cpu;\n\tunsigned long long val;\n\n\tfor (num = 0; num < HSW_EXT_CSTATE_COUNT; num++) {\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\t\thsw_ext_get_count(num, &val, cpu);\n\t\t\tprevious_count[num][cpu] = val;\n\t\t}\n\t}\n\thsw_ext_get_count(TSC, &tsc_at_measure_start, base_cpu);\n\treturn 0;\n}\n\nstatic int hsw_ext_stop(void)\n{\n\tunsigned long long val;\n\tint num, cpu;\n\n\thsw_ext_get_count(TSC, &tsc_at_measure_end, base_cpu);\n\n\tfor (num = 0; num < HSW_EXT_CSTATE_COUNT; num++) {\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\t\tis_valid[cpu] = !hsw_ext_get_count(num, &val, cpu);\n\t\t\tcurrent_count[num][cpu] = val;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstruct cpuidle_monitor intel_hsw_ext_monitor;\n\nstatic struct cpuidle_monitor *hsw_ext_register(void)\n{\n\tint num;\n\n\tif (cpupower_cpu_info.vendor != X86_VENDOR_INTEL\n\t    || cpupower_cpu_info.family != 6)\n\t\treturn NULL;\n\n\tswitch (cpupower_cpu_info.model) {\n\tcase 0x45:  \n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tis_valid = calloc(cpu_count, sizeof(int));\n\tfor (num = 0; num < HSW_EXT_CSTATE_COUNT; num++) {\n\t\tprevious_count[num] = calloc(cpu_count,\n\t\t\t\t\tsizeof(unsigned long long));\n\t\tcurrent_count[num]  = calloc(cpu_count,\n\t\t\t\t\tsizeof(unsigned long long));\n\t}\n\tintel_hsw_ext_monitor.name_len = strlen(intel_hsw_ext_monitor.name);\n\treturn &intel_hsw_ext_monitor;\n}\n\nvoid hsw_ext_unregister(void)\n{\n\tint num;\n\tfree(is_valid);\n\tfor (num = 0; num < HSW_EXT_CSTATE_COUNT; num++) {\n\t\tfree(previous_count[num]);\n\t\tfree(current_count[num]);\n\t}\n}\n\nstruct cpuidle_monitor intel_hsw_ext_monitor = {\n\t.name\t\t\t= \"HaswellExtended\",\n\t.hw_states\t\t= hsw_ext_cstates,\n\t.hw_states_num\t\t= HSW_EXT_CSTATE_COUNT,\n\t.start\t\t\t= hsw_ext_start,\n\t.stop\t\t\t= hsw_ext_stop,\n\t.do_register\t\t= hsw_ext_register,\n\t.unregister\t\t= hsw_ext_unregister,\n\t.flags.needs_root\t= 1,\n\t.overflow_s\t\t= 922000000  \n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}