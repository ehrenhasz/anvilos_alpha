{
  "module_name": "amd_fam14h_idle.c",
  "hash_id": "950505e4feb7f48e15140f69f888ae5abbc0a7baf96088d80b96a858ad499a58",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/idle_monitor/amd_fam14h_idle.c",
  "human_readable_source": "\n \n\n#if defined(__i386__) || defined(__x86_64__)\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <time.h>\n#include <string.h>\n\n#include <pci/pci.h>\n\n#include \"idle_monitor/cpupower-monitor.h\"\n#include \"helpers/helpers.h\"\n\n#define PCI_NON_PC0_OFFSET\t0xb0\n#define PCI_PC1_OFFSET\t\t0xb4\n#define PCI_PC6_OFFSET\t\t0xb8\n\n#define PCI_MONITOR_ENABLE_REG  0xe0\n\n#define PCI_NON_PC0_ENABLE_BIT\t0\n#define PCI_PC1_ENABLE_BIT\t1\n#define PCI_PC6_ENABLE_BIT\t2\n\n#define PCI_NBP1_STAT_OFFSET\t0x98\n#define PCI_NBP1_ACTIVE_BIT\t2\n#define PCI_NBP1_ENTERED_BIT\t1\n\n#define PCI_NBP1_CAP_OFFSET\t0x90\n#define PCI_NBP1_CAPABLE_BIT    31\n\n#define OVERFLOW_MS\t\t343597  \n\nenum amd_fam14h_states {NON_PC0 = 0, PC1, PC6, NBP1,\n\t\t\tAMD_FAM14H_STATE_NUM};\n\nstatic int fam14h_get_count_percent(unsigned int self_id, double *percent,\n\t\t\t\t    unsigned int cpu);\nstatic int fam14h_nbp1_count(unsigned int id, unsigned long long *count,\n\t\t\t     unsigned int cpu);\n\nstatic cstate_t amd_fam14h_cstates[AMD_FAM14H_STATE_NUM] = {\n\t{\n\t\t.name\t\t\t= \"!PC0\",\n\t\t.desc\t\t\t= N_(\"Package in sleep state (PC1 or deeper)\"),\n\t\t.id\t\t\t= NON_PC0,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= fam14h_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"PC1\",\n\t\t.desc\t\t\t= N_(\"Processor Package C1\"),\n\t\t.id\t\t\t= PC1,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= fam14h_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"PC6\",\n\t\t.desc\t\t\t= N_(\"Processor Package C6\"),\n\t\t.id\t\t\t= PC6,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= fam14h_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"NBP1\",\n\t\t.desc\t\t\t= N_(\"North Bridge P1 boolean counter (returns 0 or 1)\"),\n\t\t.id\t\t\t= NBP1,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count\t\t= fam14h_nbp1_count,\n\t},\n};\n\nstatic struct pci_access *pci_acc;\nstatic struct pci_dev *amd_fam14h_pci_dev;\nstatic int nbp1_entered;\n\nstatic struct timespec start_time;\nstatic unsigned long long timediff;\n\n#ifdef DEBUG\nstruct timespec dbg_time;\nlong dbg_timediff;\n#endif\n\nstatic unsigned long long *previous_count[AMD_FAM14H_STATE_NUM];\nstatic unsigned long long *current_count[AMD_FAM14H_STATE_NUM];\n\nstatic int amd_fam14h_get_pci_info(struct cstate *state,\n\t\t\t\t   unsigned int *pci_offset,\n\t\t\t\t   unsigned int *enable_bit,\n\t\t\t\t   unsigned int cpu)\n{\n\tswitch (state->id) {\n\tcase NON_PC0:\n\t\t*enable_bit = PCI_NON_PC0_ENABLE_BIT;\n\t\t*pci_offset = PCI_NON_PC0_OFFSET;\n\t\tbreak;\n\tcase PC1:\n\t\t*enable_bit = PCI_PC1_ENABLE_BIT;\n\t\t*pci_offset = PCI_PC1_OFFSET;\n\t\tbreak;\n\tcase PC6:\n\t\t*enable_bit = PCI_PC6_ENABLE_BIT;\n\t\t*pci_offset = PCI_PC6_OFFSET;\n\t\tbreak;\n\tcase NBP1:\n\t\t*enable_bit = PCI_NBP1_ENTERED_BIT;\n\t\t*pci_offset = PCI_NBP1_STAT_OFFSET;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int amd_fam14h_init(cstate_t *state, unsigned int cpu)\n{\n\tint enable_bit, pci_offset, ret;\n\tuint32_t val;\n\n\tret = amd_fam14h_get_pci_info(state, &pci_offset, &enable_bit, cpu);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (state->id == NBP1) {\n\t\tval = pci_read_long(amd_fam14h_pci_dev, pci_offset);\n\t\tval |= 1 << enable_bit;\n\t\tval = pci_write_long(amd_fam14h_pci_dev, pci_offset, val);\n\t\treturn ret;\n\t}\n\n\t \n\tval = pci_read_long(amd_fam14h_pci_dev, PCI_MONITOR_ENABLE_REG);\n\tdprint(\"Init %s: read at offset: 0x%x val: %u\\n\", state->name,\n\t       PCI_MONITOR_ENABLE_REG, (unsigned int) val);\n\tval |= 1 << enable_bit;\n\tpci_write_long(amd_fam14h_pci_dev, PCI_MONITOR_ENABLE_REG, val);\n\n\tdprint(\"Init %s: offset: 0x%x enable_bit: %d - val: %u (%u)\\n\",\n\t       state->name, PCI_MONITOR_ENABLE_REG, enable_bit,\n\t       (unsigned int) val, cpu);\n\n\t \n\tpci_write_long(amd_fam14h_pci_dev, pci_offset, 0);\n\tprevious_count[state->id][cpu] = 0;\n\n\treturn 0;\n}\n\nstatic int amd_fam14h_disable(cstate_t *state, unsigned int cpu)\n{\n\tint enable_bit, pci_offset, ret;\n\tuint32_t val;\n\n\tret = amd_fam14h_get_pci_info(state, &pci_offset, &enable_bit, cpu);\n\tif (ret)\n\t\treturn ret;\n\n\tval = pci_read_long(amd_fam14h_pci_dev, pci_offset);\n\tdprint(\"%s: offset: 0x%x %u\\n\", state->name, pci_offset, val);\n\tif (state->id == NBP1) {\n\t\t \n\t\tnbp1_entered = (val & (1 << PCI_NBP1_ACTIVE_BIT)) |\n\t\t\t(val & (1 << PCI_NBP1_ENTERED_BIT));\n\n\t\tdprint(\"NBP1 was %sentered - 0x%x - enable_bit: \"\n\t\t       \"%d - pci_offset: 0x%x\\n\",\n\t\t       nbp1_entered ? \"\" : \"not \",\n\t\t       val, enable_bit, pci_offset);\n\t\treturn ret;\n\t}\n\tcurrent_count[state->id][cpu] = val;\n\n\tdprint(\"%s: Current -  %llu (%u)\\n\", state->name,\n\t       current_count[state->id][cpu], cpu);\n\tdprint(\"%s: Previous - %llu (%u)\\n\", state->name,\n\t       previous_count[state->id][cpu], cpu);\n\n\tval = pci_read_long(amd_fam14h_pci_dev, PCI_MONITOR_ENABLE_REG);\n\tval &= ~(1 << enable_bit);\n\tpci_write_long(amd_fam14h_pci_dev, PCI_MONITOR_ENABLE_REG, val);\n\n\treturn 0;\n}\n\nstatic int fam14h_nbp1_count(unsigned int id, unsigned long long *count,\n\t\t\t     unsigned int cpu)\n{\n\tif (id == NBP1) {\n\t\tif (nbp1_entered)\n\t\t\t*count = 1;\n\t\telse\n\t\t\t*count = 0;\n\t\treturn 0;\n\t}\n\treturn -1;\n}\nstatic int fam14h_get_count_percent(unsigned int id, double *percent,\n\t\t\t\t    unsigned int cpu)\n{\n\tunsigned long diff;\n\n\tif (id >= AMD_FAM14H_STATE_NUM)\n\t\treturn -1;\n\t \n\tdiff = current_count[id][cpu] - previous_count[id][cpu];\n\n\tif (timediff == 0)\n\t\t*percent = 0.0;\n\telse\n\t\t*percent = 100.0 * diff / timediff / 12.5;\n\n\tdprint(\"Timediff: %llu - res~: %lu us - percent: %.2f %%\\n\",\n\t       timediff, diff * 10 / 125, *percent);\n\n\treturn 0;\n}\n\nstatic int amd_fam14h_start(void)\n{\n\tint num, cpu;\n\tclock_gettime(CLOCK_REALTIME, &start_time);\n\tfor (num = 0; num < AMD_FAM14H_STATE_NUM; num++) {\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++)\n\t\t\tamd_fam14h_init(&amd_fam14h_cstates[num], cpu);\n\t}\n#ifdef DEBUG\n\tclock_gettime(CLOCK_REALTIME, &dbg_time);\n\tdbg_timediff = timespec_diff_us(start_time, dbg_time);\n\tdprint(\"Enabling counters took: %lu us\\n\",\n\t       dbg_timediff);\n#endif\n\treturn 0;\n}\n\nstatic int amd_fam14h_stop(void)\n{\n\tint num, cpu;\n\tstruct timespec end_time;\n\n\tclock_gettime(CLOCK_REALTIME, &end_time);\n\n\tfor (num = 0; num < AMD_FAM14H_STATE_NUM; num++) {\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++)\n\t\t\tamd_fam14h_disable(&amd_fam14h_cstates[num], cpu);\n\t}\n#ifdef DEBUG\n\tclock_gettime(CLOCK_REALTIME, &dbg_time);\n\tdbg_timediff = timespec_diff_us(end_time, dbg_time);\n\tdprint(\"Disabling counters took: %lu ns\\n\", dbg_timediff);\n#endif\n\ttimediff = timespec_diff_us(start_time, end_time);\n\tif (timediff / 1000 > OVERFLOW_MS)\n\t\tprint_overflow_err((unsigned int)timediff / 1000000,\n\t\t\t\t   OVERFLOW_MS / 1000);\n\n\treturn 0;\n}\n\nstatic int is_nbp1_capable(void)\n{\n\tuint32_t val;\n\tval = pci_read_long(amd_fam14h_pci_dev, PCI_NBP1_CAP_OFFSET);\n\treturn val & (1 << 31);\n}\n\nstruct cpuidle_monitor *amd_fam14h_register(void)\n{\n\tint num;\n\n\tif (cpupower_cpu_info.vendor != X86_VENDOR_AMD)\n\t\treturn NULL;\n\n\tif (cpupower_cpu_info.family == 0x14)\n\t\tstrncpy(amd_fam14h_monitor.name, \"Fam_14h\",\n\t\t\tMONITOR_NAME_LEN - 1);\n\telse if (cpupower_cpu_info.family == 0x12)\n\t\tstrncpy(amd_fam14h_monitor.name, \"Fam_12h\",\n\t\t\tMONITOR_NAME_LEN - 1);\n\telse\n\t\treturn NULL;\n\n\t \n\tfor (num = 0; num < AMD_FAM14H_STATE_NUM - 1; num++) {\n\t\tprevious_count[num] = calloc(cpu_count,\n\t\t\t\t\t      sizeof(unsigned long long));\n\t\tcurrent_count[num]  = calloc(cpu_count,\n\t\t\t\t\t      sizeof(unsigned long long));\n\t}\n\n\t \n\tamd_fam14h_pci_dev = pci_slot_func_init(&pci_acc, 0x18, 6);\n\tif (amd_fam14h_pci_dev == NULL || pci_acc == NULL)\n\t\treturn NULL;\n\n\tif (!is_nbp1_capable())\n\t\tamd_fam14h_monitor.hw_states_num = AMD_FAM14H_STATE_NUM - 1;\n\n\tamd_fam14h_monitor.name_len = strlen(amd_fam14h_monitor.name);\n\treturn &amd_fam14h_monitor;\n}\n\nstatic void amd_fam14h_unregister(void)\n{\n\tint num;\n\tfor (num = 0; num < AMD_FAM14H_STATE_NUM - 1; num++) {\n\t\tfree(previous_count[num]);\n\t\tfree(current_count[num]);\n\t}\n\tpci_cleanup(pci_acc);\n}\n\nstruct cpuidle_monitor amd_fam14h_monitor = {\n\t.name\t\t\t= \"\",\n\t.hw_states\t\t= amd_fam14h_cstates,\n\t.hw_states_num\t\t= AMD_FAM14H_STATE_NUM,\n\t.start\t\t\t= amd_fam14h_start,\n\t.stop\t\t\t= amd_fam14h_stop,\n\t.do_register\t\t= amd_fam14h_register,\n\t.unregister\t\t= amd_fam14h_unregister,\n\t.flags.needs_root\t= 1,\n\t.overflow_s\t\t= OVERFLOW_MS / 1000,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}