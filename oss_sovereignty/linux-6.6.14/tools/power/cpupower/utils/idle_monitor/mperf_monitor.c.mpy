{
  "module_name": "mperf_monitor.c",
  "hash_id": "7a4287900342dadf7dcc01279021a16c1b0531d876e76a7a05c804b8a4b30872",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/idle_monitor/mperf_monitor.c",
  "human_readable_source": "\n \n\n#if defined(__i386__) || defined(__x86_64__)\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#include <cpufreq.h>\n\n#include \"helpers/helpers.h\"\n#include \"idle_monitor/cpupower-monitor.h\"\n\n#define MSR_APERF\t0xE8\n#define MSR_MPERF\t0xE7\n\n#define RDPRU \".byte 0x0f, 0x01, 0xfd\"\n#define RDPRU_ECX_MPERF\t0\n#define RDPRU_ECX_APERF\t1\n\n#define MSR_TSC\t0x10\n\n#define MSR_AMD_HWCR 0xc0010015\n\nenum mperf_id { C0 = 0, Cx, AVG_FREQ, MPERF_CSTATE_COUNT };\n\nstatic int mperf_get_count_percent(unsigned int self_id, double *percent,\n\t\t\t\t   unsigned int cpu);\nstatic int mperf_get_count_freq(unsigned int id, unsigned long long *count,\n\t\t\t\tunsigned int cpu);\nstatic struct timespec time_start, time_end;\n\nstatic cstate_t mperf_cstates[MPERF_CSTATE_COUNT] = {\n\t{\n\t\t.name\t\t\t= \"C0\",\n\t\t.desc\t\t\t= N_(\"Processor Core not idle\"),\n\t\t.id\t\t\t= C0,\n\t\t.range\t\t\t= RANGE_THREAD,\n\t\t.get_count_percent\t= mperf_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"Cx\",\n\t\t.desc\t\t\t= N_(\"Processor Core in an idle state\"),\n\t\t.id\t\t\t= Cx,\n\t\t.range\t\t\t= RANGE_THREAD,\n\t\t.get_count_percent\t= mperf_get_count_percent,\n\t},\n\n\t{\n\t\t.name\t\t\t= \"Freq\",\n\t\t.desc\t\t\t= N_(\"Average Frequency (including boost) in MHz\"),\n\t\t.id\t\t\t= AVG_FREQ,\n\t\t.range\t\t\t= RANGE_THREAD,\n\t\t.get_count\t\t= mperf_get_count_freq,\n\t},\n};\n\nenum MAX_FREQ_MODE { MAX_FREQ_SYSFS, MAX_FREQ_TSC_REF };\nstatic int max_freq_mode;\n \nstatic unsigned long max_frequency;\n\nstatic unsigned long long *tsc_at_measure_start;\nstatic unsigned long long *tsc_at_measure_end;\nstatic unsigned long long *mperf_previous_count;\nstatic unsigned long long *aperf_previous_count;\nstatic unsigned long long *mperf_current_count;\nstatic unsigned long long *aperf_current_count;\n\n \nstatic int *is_valid;\n\nstatic int mperf_get_tsc(unsigned long long *tsc)\n{\n\tint ret;\n\n\tret = read_msr(base_cpu, MSR_TSC, tsc);\n\tif (ret)\n\t\tdprint(\"Reading TSC MSR failed, returning %llu\\n\", *tsc);\n\treturn ret;\n}\n\nstatic int get_aperf_mperf(int cpu, unsigned long long *aval,\n\t\t\t\t    unsigned long long *mval)\n{\n\tunsigned long low_a, high_a;\n\tunsigned long low_m, high_m;\n\tint ret;\n\n\t \n\tif (mperf_monitor.flags.per_cpu_schedule) {\n\t\tif (bind_cpu(cpu))\n\t\t\treturn 1;\n\t}\n\n\tif (cpupower_cpu_info.caps & CPUPOWER_CAP_AMD_RDPRU) {\n\t\tasm volatile(RDPRU\n\t\t\t     : \"=a\" (low_a), \"=d\" (high_a)\n\t\t\t     : \"c\" (RDPRU_ECX_APERF));\n\t\tasm volatile(RDPRU\n\t\t\t     : \"=a\" (low_m), \"=d\" (high_m)\n\t\t\t     : \"c\" (RDPRU_ECX_MPERF));\n\n\t\t*aval = ((low_a) | (high_a) << 32);\n\t\t*mval = ((low_m) | (high_m) << 32);\n\n\t\treturn 0;\n\t}\n\n\tret  = read_msr(cpu, MSR_APERF, aval);\n\tret |= read_msr(cpu, MSR_MPERF, mval);\n\n\treturn ret;\n}\n\nstatic int mperf_init_stats(unsigned int cpu)\n{\n\tunsigned long long aval, mval;\n\tint ret;\n\n\tret = get_aperf_mperf(cpu, &aval, &mval);\n\taperf_previous_count[cpu] = aval;\n\tmperf_previous_count[cpu] = mval;\n\tis_valid[cpu] = !ret;\n\n\treturn 0;\n}\n\nstatic int mperf_measure_stats(unsigned int cpu)\n{\n\tunsigned long long aval, mval;\n\tint ret;\n\n\tret = get_aperf_mperf(cpu, &aval, &mval);\n\taperf_current_count[cpu] = aval;\n\tmperf_current_count[cpu] = mval;\n\tis_valid[cpu] = !ret;\n\n\treturn 0;\n}\n\nstatic int mperf_get_count_percent(unsigned int id, double *percent,\n\t\t\t\t   unsigned int cpu)\n{\n\tunsigned long long aperf_diff, mperf_diff, tsc_diff;\n\tunsigned long long timediff;\n\n\tif (!is_valid[cpu])\n\t\treturn -1;\n\n\tif (id != C0 && id != Cx)\n\t\treturn -1;\n\n\tmperf_diff = mperf_current_count[cpu] - mperf_previous_count[cpu];\n\taperf_diff = aperf_current_count[cpu] - aperf_previous_count[cpu];\n\n\tif (max_freq_mode == MAX_FREQ_TSC_REF) {\n\t\ttsc_diff = tsc_at_measure_end[cpu] - tsc_at_measure_start[cpu];\n\t\t*percent = 100.0 * mperf_diff / tsc_diff;\n\t\tdprint(\"%s: TSC Ref - mperf_diff: %llu, tsc_diff: %llu\\n\",\n\t\t       mperf_cstates[id].name, mperf_diff, tsc_diff);\n\t} else if (max_freq_mode == MAX_FREQ_SYSFS) {\n\t\ttimediff = max_frequency * timespec_diff_us(time_start, time_end);\n\t\t*percent = 100.0 * mperf_diff / timediff;\n\t\tdprint(\"%s: MAXFREQ - mperf_diff: %llu, time_diff: %llu\\n\",\n\t\t       mperf_cstates[id].name, mperf_diff, timediff);\n\t} else\n\t\treturn -1;\n\n\tif (id == Cx)\n\t\t*percent = 100.0 - *percent;\n\n\tdprint(\"%s: previous: %llu - current: %llu - (%u)\\n\",\n\t\tmperf_cstates[id].name, mperf_diff, aperf_diff, cpu);\n\tdprint(\"%s: %f\\n\", mperf_cstates[id].name, *percent);\n\treturn 0;\n}\n\nstatic int mperf_get_count_freq(unsigned int id, unsigned long long *count,\n\t\t\t\tunsigned int cpu)\n{\n\tunsigned long long aperf_diff, mperf_diff, time_diff, tsc_diff;\n\n\tif (id != AVG_FREQ)\n\t\treturn 1;\n\n\tif (!is_valid[cpu])\n\t\treturn -1;\n\n\tmperf_diff = mperf_current_count[cpu] - mperf_previous_count[cpu];\n\taperf_diff = aperf_current_count[cpu] - aperf_previous_count[cpu];\n\n\tif (max_freq_mode == MAX_FREQ_TSC_REF) {\n\t\t \n\t\ttsc_diff = tsc_at_measure_end[cpu] - tsc_at_measure_start[cpu];\n\t\ttime_diff = timespec_diff_us(time_start, time_end);\n\t\tmax_frequency = tsc_diff / time_diff;\n\t}\n\n\t*count = max_frequency * ((double)aperf_diff / mperf_diff);\n\tdprint(\"%s: Average freq based on %s maximum frequency:\\n\",\n\t       mperf_cstates[id].name,\n\t       (max_freq_mode == MAX_FREQ_TSC_REF) ? \"TSC calculated\" : \"sysfs read\");\n\tdprint(\"max_frequency: %lu\\n\", max_frequency);\n\tdprint(\"aperf_diff: %llu\\n\", aperf_diff);\n\tdprint(\"mperf_diff: %llu\\n\", mperf_diff);\n\tdprint(\"avg freq:   %llu\\n\", *count);\n\treturn 0;\n}\n\nstatic int mperf_start(void)\n{\n\tint cpu;\n\n\tclock_gettime(CLOCK_REALTIME, &time_start);\n\n\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\tmperf_get_tsc(&tsc_at_measure_start[cpu]);\n\t\tmperf_init_stats(cpu);\n\t}\n\n\treturn 0;\n}\n\nstatic int mperf_stop(void)\n{\n\tint cpu;\n\n\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\tmperf_measure_stats(cpu);\n\t\tmperf_get_tsc(&tsc_at_measure_end[cpu]);\n\t}\n\n\tclock_gettime(CLOCK_REALTIME, &time_end);\n\treturn 0;\n}\n\n \nstatic int init_maxfreq_mode(void)\n{\n\tint ret;\n\tunsigned long long hwcr;\n\tunsigned long min;\n\n\tif (!(cpupower_cpu_info.caps & CPUPOWER_CAP_INV_TSC))\n\t\tgoto use_sysfs;\n\n\tif (cpupower_cpu_info.vendor == X86_VENDOR_AMD ||\n\t    cpupower_cpu_info.vendor == X86_VENDOR_HYGON) {\n\t\t \n\t\tret = read_msr(0, MSR_AMD_HWCR, &hwcr);\n\t\t \n\t\tif (ret != 0) {\n\t\t\tdprint(\"TSC read 0x%x failed - assume TSC working\\n\",\n\t\t\t       MSR_AMD_HWCR);\n\t\t\treturn 0;\n\t\t} else if (1 & (hwcr >> 24)) {\n\t\t\tmax_freq_mode = MAX_FREQ_TSC_REF;\n\t\t\treturn 0;\n\t\t} else {   }\n\t} else if (cpupower_cpu_info.vendor == X86_VENDOR_INTEL) {\n\t\t \n\t\tmax_freq_mode = MAX_FREQ_TSC_REF;\n\t\treturn 0;\n\t}\nuse_sysfs:\n\tif (cpufreq_get_hardware_limits(0, &min, &max_frequency)) {\n\t\tdprint(\"Cannot retrieve max freq from cpufreq kernel \"\n\t\t       \"subsystem\\n\");\n\t\treturn -1;\n\t}\n\tmax_freq_mode = MAX_FREQ_SYSFS;\n\tmax_frequency /= 1000;  \n\treturn 0;\n}\n\n \nstruct cpuidle_monitor mperf_monitor;\nstruct cpuidle_monitor *mperf_register(void)\n{\n\tif (!(cpupower_cpu_info.caps & CPUPOWER_CAP_APERF))\n\t\treturn NULL;\n\n\tif (init_maxfreq_mode())\n\t\treturn NULL;\n\n\tif (cpupower_cpu_info.vendor == X86_VENDOR_AMD)\n\t\tmperf_monitor.flags.per_cpu_schedule = 1;\n\n\t \n\tis_valid = calloc(cpu_count, sizeof(int));\n\tmperf_previous_count = calloc(cpu_count, sizeof(unsigned long long));\n\taperf_previous_count = calloc(cpu_count, sizeof(unsigned long long));\n\tmperf_current_count = calloc(cpu_count, sizeof(unsigned long long));\n\taperf_current_count = calloc(cpu_count, sizeof(unsigned long long));\n\ttsc_at_measure_start = calloc(cpu_count, sizeof(unsigned long long));\n\ttsc_at_measure_end = calloc(cpu_count, sizeof(unsigned long long));\n\tmperf_monitor.name_len = strlen(mperf_monitor.name);\n\treturn &mperf_monitor;\n}\n\nvoid mperf_unregister(void)\n{\n\tfree(mperf_previous_count);\n\tfree(aperf_previous_count);\n\tfree(mperf_current_count);\n\tfree(aperf_current_count);\n\tfree(tsc_at_measure_start);\n\tfree(tsc_at_measure_end);\n\tfree(is_valid);\n}\n\nstruct cpuidle_monitor mperf_monitor = {\n\t.name\t\t\t= \"Mperf\",\n\t.hw_states_num\t\t= MPERF_CSTATE_COUNT,\n\t.hw_states\t\t= mperf_cstates,\n\t.start\t\t\t= mperf_start,\n\t.stop\t\t\t= mperf_stop,\n\t.do_register\t\t= mperf_register,\n\t.unregister\t\t= mperf_unregister,\n\t.flags.needs_root\t= 1,\n\t.overflow_s\t\t= 922000000  \n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}