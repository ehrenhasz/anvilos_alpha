{
  "module_name": "cpuidle_sysfs.c",
  "hash_id": "9e50bd188165151472e6c1992bed113c0bce954979d73fafb4861ad533634e25",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/idle_monitor/cpuidle_sysfs.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <limits.h>\n#include <cpuidle.h>\n\n#include \"helpers/helpers.h\"\n#include \"idle_monitor/cpupower-monitor.h\"\n\n#define CPUIDLE_STATES_MAX 10\nstatic cstate_t cpuidle_cstates[CPUIDLE_STATES_MAX];\nstruct cpuidle_monitor cpuidle_sysfs_monitor;\n\nstatic unsigned long long **previous_count;\nstatic unsigned long long **current_count;\nstatic struct timespec start_time;\nstatic unsigned long long timediff;\n\nstatic int cpuidle_get_count_percent(unsigned int id, double *percent,\n\t\t\t\t     unsigned int cpu)\n{\n\tunsigned long long statediff = current_count[cpu][id]\n\t\t- previous_count[cpu][id];\n\tdprint(\"%s: - diff: %llu - percent: %f (%u)\\n\",\n\t       cpuidle_cstates[id].name, timediff, *percent, cpu);\n\n\tif (timediff == 0)\n\t\t*percent = 0.0;\n\telse\n\t\t*percent = ((100.0 * statediff) / timediff);\n\n\tdprint(\"%s: - timediff: %llu - statediff: %llu - percent: %f (%u)\\n\",\n\t       cpuidle_cstates[id].name, timediff, statediff, *percent, cpu);\n\n\treturn 0;\n}\n\nstatic int cpuidle_start(void)\n{\n\tint cpu, state;\n\tclock_gettime(CLOCK_REALTIME, &start_time);\n\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\tfor (state = 0; state < cpuidle_sysfs_monitor.hw_states_num;\n\t\t     state++) {\n\t\t\tprevious_count[cpu][state] =\n\t\t\t\tcpuidle_state_time(cpu, state);\n\t\t\tdprint(\"CPU %d - State: %d - Val: %llu\\n\",\n\t\t\t       cpu, state, previous_count[cpu][state]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cpuidle_stop(void)\n{\n\tint cpu, state;\n\tstruct timespec end_time;\n\tclock_gettime(CLOCK_REALTIME, &end_time);\n\ttimediff = timespec_diff_us(start_time, end_time);\n\n\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\tfor (state = 0; state < cpuidle_sysfs_monitor.hw_states_num;\n\t\t     state++) {\n\t\t\tcurrent_count[cpu][state] =\n\t\t\t\tcpuidle_state_time(cpu, state);\n\t\t\tdprint(\"CPU %d - State: %d - Val: %llu\\n\",\n\t\t\t       cpu, state, previous_count[cpu][state]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid fix_up_intel_idle_driver_name(char *tmp, int num)\n{\n\t \n\tif (!strncmp(tmp, \"NHM-\", 4)) {\n\t\tswitch (num) {\n\t\tcase 1:\n\t\t\tstrcpy(tmp, \"C1\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstrcpy(tmp, \"C3\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstrcpy(tmp, \"C6\");\n\t\t\tbreak;\n\t\t}\n\t} else if (!strncmp(tmp, \"SNB-\", 4)) {\n\t\tswitch (num) {\n\t\tcase 1:\n\t\t\tstrcpy(tmp, \"C1\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstrcpy(tmp, \"C3\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstrcpy(tmp, \"C6\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tstrcpy(tmp, \"C7\");\n\t\t\tbreak;\n\t\t}\n\t} else if (!strncmp(tmp, \"ATM-\", 4)) {\n\t\tswitch (num) {\n\t\tcase 1:\n\t\t\tstrcpy(tmp, \"C1\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstrcpy(tmp, \"C2\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstrcpy(tmp, \"C4\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tstrcpy(tmp, \"C6\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n#ifdef __powerpc__\nvoid map_power_idle_state_name(char *tmp)\n{\n\tif (!strncmp(tmp, \"stop0_lite\", CSTATE_NAME_LEN))\n\t\tstrcpy(tmp, \"stop0L\");\n\telse if (!strncmp(tmp, \"stop1_lite\", CSTATE_NAME_LEN))\n\t\tstrcpy(tmp, \"stop1L\");\n\telse if (!strncmp(tmp, \"stop2_lite\", CSTATE_NAME_LEN))\n\t\tstrcpy(tmp, \"stop2L\");\n}\n#else\nvoid map_power_idle_state_name(char *tmp) { }\n#endif\n\nstatic struct cpuidle_monitor *cpuidle_register(void)\n{\n\tint num;\n\tchar *tmp;\n\tint this_cpu;\n\n\tthis_cpu = sched_getcpu();\n\n\t \n\tcpuidle_sysfs_monitor.hw_states_num = cpuidle_state_count(this_cpu);\n\n\tif (cpuidle_sysfs_monitor.hw_states_num <= 0)\n\t\treturn NULL;\n\n\tfor (num = 0; num < cpuidle_sysfs_monitor.hw_states_num; num++) {\n\t\ttmp = cpuidle_state_name(this_cpu, num);\n\t\tif (tmp == NULL)\n\t\t\tcontinue;\n\n\t\tmap_power_idle_state_name(tmp);\n\t\tfix_up_intel_idle_driver_name(tmp, num);\n\t\tstrncpy(cpuidle_cstates[num].name, tmp, CSTATE_NAME_LEN - 1);\n\t\tfree(tmp);\n\n\t\ttmp = cpuidle_state_desc(this_cpu, num);\n\t\tif (tmp == NULL)\n\t\t\tcontinue;\n\t\tstrncpy(cpuidle_cstates[num].desc, tmp,\tCSTATE_DESC_LEN - 1);\n\t\tfree(tmp);\n\n\t\tcpuidle_cstates[num].range = RANGE_THREAD;\n\t\tcpuidle_cstates[num].id = num;\n\t\tcpuidle_cstates[num].get_count_percent =\n\t\t\tcpuidle_get_count_percent;\n\t}\n\n\t \n\tprevious_count = malloc(sizeof(long long *) * cpu_count);\n\tcurrent_count = malloc(sizeof(long long *) * cpu_count);\n\tfor (num = 0; num < cpu_count; num++) {\n\t\tprevious_count[num] = malloc(sizeof(long long) *\n\t\t\t\t\tcpuidle_sysfs_monitor.hw_states_num);\n\t\tcurrent_count[num] = malloc(sizeof(long long) *\n\t\t\t\t\tcpuidle_sysfs_monitor.hw_states_num);\n\t}\n\n\tcpuidle_sysfs_monitor.name_len = strlen(cpuidle_sysfs_monitor.name);\n\treturn &cpuidle_sysfs_monitor;\n}\n\nvoid cpuidle_unregister(void)\n{\n\tint num;\n\n\tfor (num = 0; num < cpu_count; num++) {\n\t\tfree(previous_count[num]);\n\t\tfree(current_count[num]);\n\t}\n\tfree(previous_count);\n\tfree(current_count);\n}\n\nstruct cpuidle_monitor cpuidle_sysfs_monitor = {\n\t.name\t\t\t= \"Idle_Stats\",\n\t.hw_states\t\t= cpuidle_cstates,\n\t.start\t\t\t= cpuidle_start,\n\t.stop\t\t\t= cpuidle_stop,\n\t.do_register\t\t= cpuidle_register,\n\t.unregister\t\t= cpuidle_unregister,\n\t.flags.needs_root\t= 0,\n\t.overflow_s\t\t= UINT_MAX,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}