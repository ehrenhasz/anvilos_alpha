{
  "module_name": "cpupower-monitor.c",
  "hash_id": "043e3e28973d8c14c6d858e0b383ee1f70b7cc55add28f031589a919f5dff28c",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/idle_monitor/cpupower-monitor.c",
  "human_readable_source": "\n \n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <libgen.h>\n\n#include \"idle_monitor/cpupower-monitor.h\"\n#include \"idle_monitor/idle_monitors.h\"\n#include \"helpers/helpers.h\"\n\n \n#define DEF(x) & x ## _monitor ,\nstruct cpuidle_monitor *all_monitors[] = {\n#include \"idle_monitors.def\"\n0\n};\n\nint cpu_count;\n\nstatic struct cpuidle_monitor *monitors[MONITORS_MAX];\nstatic unsigned int avail_monitors;\n\nstatic char *progname;\n\nenum operation_mode_e { list = 1, show, show_all };\nstatic int mode;\nstatic int interval = 1;\nstatic char *show_monitors_param;\nstatic struct cpupower_topology cpu_top;\nstatic unsigned int wake_cpus;\n\n \nstatic char range_abbr[RANGE_MAX] = { 'T', 'C', 'P', 'M', };\n\nstatic void print_wrong_arg_exit(void)\n{\n\tprintf(_(\"invalid or unknown argument\\n\"));\n\texit(EXIT_FAILURE);\n}\n\nlong long timespec_diff_us(struct timespec start, struct timespec end)\n{\n\tstruct timespec temp;\n\tif ((end.tv_nsec - start.tv_nsec) < 0) {\n\t\ttemp.tv_sec = end.tv_sec - start.tv_sec - 1;\n\t\ttemp.tv_nsec = 1000000000 + end.tv_nsec - start.tv_nsec;\n\t} else {\n\t\ttemp.tv_sec = end.tv_sec - start.tv_sec;\n\t\ttemp.tv_nsec = end.tv_nsec - start.tv_nsec;\n\t}\n\treturn (temp.tv_sec * 1000000) + (temp.tv_nsec / 1000);\n}\n\nvoid print_n_spaces(int n)\n{\n\tint x;\n\tfor (x = 0; x < n; x++)\n\t\tprintf(\" \");\n}\n\n \nint fill_string_with_spaces(char *s, int n)\n{\n\tchar *temp;\n\tint len = strlen(s);\n\n\tif (len >= n)\n\t\treturn -1;\n\n\ttemp = malloc(sizeof(char) * (n+1));\n\tfor (; len < n; len++)\n\t\ts[len] = ' ';\n\ts[len] = '\\0';\n\tsnprintf(temp, n+1, \" %s\", s);\n\tstrcpy(s, temp);\n\tfree(temp);\n\treturn 0;\n}\n\n#define MAX_COL_WIDTH 6\nvoid print_header(int topology_depth)\n{\n\tint unsigned mon;\n\tint state, need_len;\n\tcstate_t s;\n\tchar buf[128] = \"\";\n\n\tfill_string_with_spaces(buf, topology_depth * 5 - 1);\n\tprintf(\"%s|\", buf);\n\n\tfor (mon = 0; mon < avail_monitors; mon++) {\n\t\tneed_len = monitors[mon]->hw_states_num * (MAX_COL_WIDTH + 1)\n\t\t\t- 1;\n\t\tif (mon != 0)\n\t\t\tprintf(\"||\");\n\t\tsprintf(buf, \"%s\", monitors[mon]->name);\n\t\tfill_string_with_spaces(buf, need_len);\n\t\tprintf(\"%s\", buf);\n\t}\n\tprintf(\"\\n\");\n\n\tif (topology_depth > 2)\n\t\tprintf(\" PKG|\");\n\tif (topology_depth > 1)\n\t\tprintf(\"CORE|\");\n\tif (topology_depth > 0)\n\t\tprintf(\" CPU|\");\n\n\tfor (mon = 0; mon < avail_monitors; mon++) {\n\t\tif (mon != 0)\n\t\t\tprintf(\"||\");\n\t\tfor (state = 0; state < monitors[mon]->hw_states_num; state++) {\n\t\t\tif (state != 0)\n\t\t\t\tprintf(\"|\");\n\t\t\ts = monitors[mon]->hw_states[state];\n\t\t\tsprintf(buf, \"%s\", s.name);\n\t\t\tfill_string_with_spaces(buf, MAX_COL_WIDTH);\n\t\t\tprintf(\"%s\", buf);\n\t\t}\n\t\tprintf(\" \");\n\t}\n\tprintf(\"\\n\");\n}\n\n\nvoid print_results(int topology_depth, int cpu)\n{\n\tunsigned int mon;\n\tint state, ret;\n\tdouble percent;\n\tunsigned long long result;\n\tcstate_t s;\n\n\t \n\tif (!bitmask_isbitset(cpus_chosen, cpu_top.core_info[cpu].cpu))\n\t\treturn;\n\tif (!cpu_top.core_info[cpu].is_online &&\n\t    cpu_top.core_info[cpu].pkg == -1)\n\t\treturn;\n\n\tif (topology_depth > 2)\n\t\tprintf(\"%4d|\", cpu_top.core_info[cpu].pkg);\n\tif (topology_depth > 1)\n\t\tprintf(\"%4d|\", cpu_top.core_info[cpu].core);\n\tif (topology_depth > 0)\n\t\tprintf(\"%4d|\", cpu_top.core_info[cpu].cpu);\n\n\tfor (mon = 0; mon < avail_monitors; mon++) {\n\t\tif (mon != 0)\n\t\t\tprintf(\"||\");\n\n\t\tfor (state = 0; state < monitors[mon]->hw_states_num; state++) {\n\t\t\tif (state != 0)\n\t\t\t\tprintf(\"|\");\n\n\t\t\ts = monitors[mon]->hw_states[state];\n\n\t\t\tif (s.get_count_percent) {\n\t\t\t\tret = s.get_count_percent(s.id, &percent,\n\t\t\t\t\t\t  cpu_top.core_info[cpu].cpu);\n\t\t\t\tif (ret)\n\t\t\t\t\tprintf(\"******\");\n\t\t\t\telse if (percent >= 100.0)\n\t\t\t\t\tprintf(\"%6.1f\", percent);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%6.2f\", percent);\n\t\t\t} else if (s.get_count) {\n\t\t\t\tret = s.get_count(s.id, &result,\n\t\t\t\t\t\t  cpu_top.core_info[cpu].cpu);\n\t\t\t\tif (ret)\n\t\t\t\t\tprintf(\"******\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%6llu\", result);\n\t\t\t} else {\n\t\t\t\tprintf(_(\"Monitor %s, Counter %s has no count \"\n\t\t\t\t\t \"function. Implementation error\\n\"),\n\t\t\t\t       monitors[mon]->name, s.name);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (!cpu_top.core_info[cpu].is_online &&\n\t    cpu_top.core_info[cpu].pkg != -1) {\n\t\tprintf(_(\" *is offline\\n\"));\n\t\treturn;\n\t} else\n\t\tprintf(\"\\n\");\n}\n\n\n \n\nstatic void parse_monitor_param(char *param)\n{\n\tunsigned int num;\n\tint mon, hits = 0;\n\tchar *tmp = param, *token;\n\tstruct cpuidle_monitor *tmp_mons[MONITORS_MAX];\n\n\n\tfor (mon = 0; mon < MONITORS_MAX; mon++, tmp = NULL) {\n\t\ttoken = strtok(tmp, \",\");\n\t\tif (token == NULL)\n\t\t\tbreak;\n\t\tif (strlen(token) >= MONITOR_NAME_LEN) {\n\t\t\tprintf(_(\"%s: max monitor name length\"\n\t\t\t\t \" (%d) exceeded\\n\"), token, MONITOR_NAME_LEN);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (num = 0; num < avail_monitors; num++) {\n\t\t\tif (!strcmp(monitors[num]->name, token)) {\n\t\t\t\tdprint(\"Found requested monitor: %s\\n\", token);\n\t\t\t\ttmp_mons[hits] = monitors[num];\n\t\t\t\thits++;\n\t\t\t}\n\t\t}\n\t}\n\tif (hits == 0) {\n\t\tprintf(_(\"No matching monitor found in %s, \"\n\t\t\t \"try -l option\\n\"), param);\n\t\texit(EXIT_FAILURE);\n\t}\n\t \n\tmemcpy(monitors, tmp_mons,\n\t\tsizeof(struct cpuidle_monitor *) * MONITORS_MAX);\n\tavail_monitors = hits;\n}\n\nvoid list_monitors(void)\n{\n\tunsigned int mon;\n\tint state;\n\tcstate_t s;\n\n\tfor (mon = 0; mon < avail_monitors; mon++) {\n\t\tprintf(_(\"Monitor \\\"%s\\\" (%d states) - Might overflow after %u \"\n\t\t\t \"s\\n\"),\n\t\t\tmonitors[mon]->name, monitors[mon]->hw_states_num,\n\t\t\tmonitors[mon]->overflow_s);\n\n\t\tfor (state = 0; state < monitors[mon]->hw_states_num; state++) {\n\t\t\ts = monitors[mon]->hw_states[state];\n\t\t\t \n\t\t\tprintf(\"%s\\t[%c] -> %s\\n\", s.name, range_abbr[s.range],\n\t\t\t       gettext(s.desc));\n\t\t}\n\t}\n}\n\nint fork_it(char **argv)\n{\n\tint status;\n\tunsigned int num;\n\tunsigned long long timediff;\n\tpid_t child_pid;\n\tstruct timespec start, end;\n\n\tchild_pid = fork();\n\tclock_gettime(CLOCK_REALTIME, &start);\n\n\tfor (num = 0; num < avail_monitors; num++)\n\t\tmonitors[num]->start();\n\n\tif (!child_pid) {\n\t\t \n\t\texecvp(argv[0], argv);\n\t} else {\n\t\t \n\t\tif (child_pid == -1) {\n\t\t\tperror(\"fork\");\n\t\t\texit(1);\n\t\t}\n\n\t\tsignal(SIGINT, SIG_IGN);\n\t\tsignal(SIGQUIT, SIG_IGN);\n\t\tif (waitpid(child_pid, &status, 0) == -1) {\n\t\t\tperror(\"wait\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tclock_gettime(CLOCK_REALTIME, &end);\n\tfor (num = 0; num < avail_monitors; num++)\n\t\tmonitors[num]->stop();\n\n\ttimediff = timespec_diff_us(start, end);\n\tif (WIFEXITED(status))\n\t\tprintf(_(\"%s took %.5f seconds and exited with status %d\\n\"),\n\t\t\targv[0], timediff / (1000.0 * 1000),\n\t\t\tWEXITSTATUS(status));\n\treturn 0;\n}\n\nint do_interval_measure(int i)\n{\n\tunsigned int num;\n\tint cpu;\n\n\tif (wake_cpus)\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++)\n\t\t\tbind_cpu(cpu);\n\n\tfor (num = 0; num < avail_monitors; num++) {\n\t\tdprint(\"HW C-state residency monitor: %s - States: %d\\n\",\n\t\t       monitors[num]->name, monitors[num]->hw_states_num);\n\t\tmonitors[num]->start();\n\t}\n\n\tsleep(i);\n\n\tif (wake_cpus)\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++)\n\t\t\tbind_cpu(cpu);\n\n\tfor (num = 0; num < avail_monitors; num++)\n\t\tmonitors[num]->stop();\n\n\n\treturn 0;\n}\n\nstatic void cmdline(int argc, char *argv[])\n{\n\tint opt;\n\tprogname = basename(argv[0]);\n\n\twhile ((opt = getopt(argc, argv, \"+lci:m:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'l':\n\t\t\tif (mode)\n\t\t\t\tprint_wrong_arg_exit();\n\t\t\tmode = list;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\t \n\t\t\tif (mode && mode != show)\n\t\t\t\tprint_wrong_arg_exit();\n\t\t\tinterval = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (mode)\n\t\t\t\tprint_wrong_arg_exit();\n\t\t\tmode = show;\n\t\t\tshow_monitors_param = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\twake_cpus = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_wrong_arg_exit();\n\t\t}\n\t}\n\tif (!mode)\n\t\tmode = show_all;\n}\n\nint cmd_monitor(int argc, char **argv)\n{\n\tunsigned int num;\n\tstruct cpuidle_monitor *test_mon;\n\tint cpu;\n\n\tcmdline(argc, argv);\n\tcpu_count = get_cpu_topology(&cpu_top);\n\tif (cpu_count < 0) {\n\t\tprintf(_(\"Cannot read number of available processors\\n\"));\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (!cpu_top.core_info[0].is_online)\n\t\tprintf(\"WARNING: at least one cpu is offline\\n\");\n\n\t \n\tif (bitmask_isallclear(cpus_chosen))\n\t\tbitmask_setall(cpus_chosen);\n\n\tdprint(\"System has up to %d CPU cores\\n\", cpu_count);\n\n\tfor (num = 0; all_monitors[num]; num++) {\n\t\tdprint(\"Try to register: %s\\n\", all_monitors[num]->name);\n\t\ttest_mon = all_monitors[num]->do_register();\n\t\tif (test_mon) {\n\t\t\tif (test_mon->flags.needs_root && !run_as_root) {\n\t\t\t\tfprintf(stderr, _(\"Available monitor %s needs \"\n\t\t\t\t\t  \"root access\\n\"), test_mon->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmonitors[avail_monitors] = test_mon;\n\t\t\tdprint(\"%s registered\\n\", all_monitors[num]->name);\n\t\t\tavail_monitors++;\n\t\t}\n\t}\n\n\tif (avail_monitors == 0) {\n\t\tprintf(_(\"No HW Cstate monitors found\\n\"));\n\t\treturn 1;\n\t}\n\n\tif (mode == list) {\n\t\tlist_monitors();\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tif (mode == show)\n\t\tparse_monitor_param(show_monitors_param);\n\n\tdprint(\"Packages: %d - Cores: %d - CPUs: %d\\n\",\n\t       cpu_top.pkgs, cpu_top.cores, cpu_count);\n\n\t \n\tif (argc - optind)\n\t\tfork_it(argv + optind);\n\telse\n\t\tdo_interval_measure(interval);\n\n\t \n\tif (cpu_top.pkgs > 1)\n\t\tprint_header(3);\n\telse\n\t\tprint_header(1);\n\n\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\tif (cpu_top.pkgs > 1)\n\t\t\tprint_results(3, cpu);\n\t\telse\n\t\t\tprint_results(1, cpu);\n\t}\n\n\tfor (num = 0; num < avail_monitors; num++) {\n\t\tif (monitors[num]->unregister)\n\t\t\tmonitors[num]->unregister();\n\t}\n\tcpu_topology_release(cpu_top);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}