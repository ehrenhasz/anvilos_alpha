{
  "module_name": "rapl_monitor.c",
  "hash_id": "047697835937522d3ec370bf0e4e291a0f3f6c7dfe7dd01e75fdecd40d7738c2",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/idle_monitor/rapl_monitor.c",
  "human_readable_source": "\n \n\n#if defined(__i386__) || defined(__x86_64__)\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <time.h>\n#include <string.h>\n\n#include <pci/pci.h>\n\n#include \"idle_monitor/cpupower-monitor.h\"\n#include \"helpers/helpers.h\"\n#include \"powercap.h\"\n\n#define MAX_RAPL_ZONES 10\n\nint rapl_zone_count;\ncstate_t rapl_zones[MAX_RAPL_ZONES];\nstruct powercap_zone *rapl_zones_pt[MAX_RAPL_ZONES] = { 0 };\n\nunsigned long long rapl_zone_previous_count[MAX_RAPL_ZONES];\nunsigned long long rapl_zone_current_count[MAX_RAPL_ZONES];\nunsigned long long rapl_max_count;\n\nstatic int rapl_get_count_uj(unsigned int id, unsigned long long *count,\n\t\t\t     unsigned int cpu)\n{\n\tif (rapl_zones_pt[id] == NULL)\n\t\t \n\t\treturn -1;\n\n\t*count = rapl_zone_current_count[id] - rapl_zone_previous_count[id];\n\n\treturn 0;\n}\n\nstatic int powercap_count_zones(struct powercap_zone *zone)\n{\n\tuint64_t val;\n\tint uj;\n\n\tif (rapl_zone_count >= MAX_RAPL_ZONES)\n\t\treturn -1;\n\n\tif (!zone->has_energy_uj)\n\t\treturn 0;\n\n\tprintf(\"%s\\n\", zone->sys_name);\n\tuj = powercap_get_energy_uj(zone, &val);\n\tprintf(\"%d\\n\", uj);\n\n\tstrncpy(rapl_zones[rapl_zone_count].name, zone->name, CSTATE_NAME_LEN - 1);\n\tstrcpy(rapl_zones[rapl_zone_count].desc, \"\");\n\trapl_zones[rapl_zone_count].id = rapl_zone_count;\n\trapl_zones[rapl_zone_count].range = RANGE_MACHINE;\n\trapl_zones[rapl_zone_count].get_count = rapl_get_count_uj;\n\trapl_zones_pt[rapl_zone_count] = zone;\n\trapl_zone_count++;\n\n\treturn 0;\n}\n\nstatic int rapl_start(void)\n{\n\tint i, ret;\n\tuint64_t uj_val;\n\n\tfor (i = 0; i < rapl_zone_count; i++) {\n\t\tret = powercap_get_energy_uj(rapl_zones_pt[i], &uj_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trapl_zone_previous_count[i] = uj_val;\n\t}\n\n\treturn 0;\n}\n\nstatic int rapl_stop(void)\n{\n\tint i;\n\tuint64_t uj_val;\n\n\tfor (i = 0; i < rapl_zone_count; i++) {\n\t\tint ret;\n\n\t\tret = powercap_get_energy_uj(rapl_zones_pt[i], &uj_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trapl_zone_current_count[i] = uj_val;\n\t\tif (rapl_max_count < uj_val)\n\t\t\trapl_max_count = uj_val - rapl_zone_previous_count[i];\n\t}\n\treturn 0;\n}\n\nstruct cpuidle_monitor *rapl_register(void)\n{\n\tstruct powercap_zone *root_zone;\n\tchar line[MAX_LINE_LEN] = \"\";\n\tint ret, val;\n\n\tret = powercap_get_driver(line, MAX_LINE_LEN);\n\tif (ret < 0) {\n\t\tdprint(\"No powercapping driver loaded\\n\");\n\t\treturn NULL;\n\t}\n\n\tdprint(\"Driver: %s\\n\", line);\n\tret = powercap_get_enabled(&val);\n\tif (ret < 0)\n\t\treturn NULL;\n\tif (!val) {\n\t\tdprint(\"Powercapping is disabled\\n\");\n\t\treturn NULL;\n\t}\n\n\tdprint(\"Powercap domain hierarchy:\\n\\n\");\n\troot_zone = powercap_init_zones();\n\n\tif (root_zone == NULL) {\n\t\tdprint(\"No powercap info found\\n\");\n\t\treturn NULL;\n\t}\n\n\tpowercap_walk_zones(root_zone, powercap_count_zones);\n\trapl_monitor.hw_states_num = rapl_zone_count;\n\n\treturn &rapl_monitor;\n}\n\nstruct cpuidle_monitor rapl_monitor = {\n\t.name\t\t\t= \"RAPL\",\n\t.hw_states\t\t= rapl_zones,\n\t.hw_states_num\t\t= 0,\n\t.start\t\t\t= rapl_start,\n\t.stop\t\t\t= rapl_stop,\n\t.do_register\t\t= rapl_register,\n\t.flags.needs_root\t= 0,\n\t.overflow_s\t\t= 60 * 60 * 24 * 100,  \n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}