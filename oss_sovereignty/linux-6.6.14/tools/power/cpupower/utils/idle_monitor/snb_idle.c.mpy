{
  "module_name": "snb_idle.c",
  "hash_id": "bca788a76990cc6126d2f0f871195ae3da507a802f9b990ed08221d1de0bd66f",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/idle_monitor/snb_idle.c",
  "human_readable_source": "\n \n\n#if defined(__i386__) || defined(__x86_64__)\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"helpers/helpers.h\"\n#include \"idle_monitor/cpupower-monitor.h\"\n\n#define MSR_PKG_C2_RESIDENCY\t0x60D\n#define MSR_PKG_C7_RESIDENCY\t0x3FA\n#define MSR_CORE_C7_RESIDENCY\t0x3FE\n\n#define MSR_TSC\t0x10\n\nenum intel_snb_id { C7 = 0, PC2, PC7, SNB_CSTATE_COUNT, TSC = 0xFFFF };\n\nstatic int snb_get_count_percent(unsigned int self_id, double *percent,\n\t\t\t\t unsigned int cpu);\n\nstatic cstate_t snb_cstates[SNB_CSTATE_COUNT] = {\n\t{\n\t\t.name\t\t\t= \"C7\",\n\t\t.desc\t\t\t= N_(\"Processor Core C7\"),\n\t\t.id\t\t\t= C7,\n\t\t.range\t\t\t= RANGE_CORE,\n\t\t.get_count_percent\t= snb_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"PC2\",\n\t\t.desc\t\t\t= N_(\"Processor Package C2\"),\n\t\t.id\t\t\t= PC2,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= snb_get_count_percent,\n\t},\n\t{\n\t\t.name\t\t\t= \"PC7\",\n\t\t.desc\t\t\t= N_(\"Processor Package C7\"),\n\t\t.id\t\t\t= PC7,\n\t\t.range\t\t\t= RANGE_PACKAGE,\n\t\t.get_count_percent\t= snb_get_count_percent,\n\t},\n};\n\nstatic unsigned long long tsc_at_measure_start;\nstatic unsigned long long tsc_at_measure_end;\nstatic unsigned long long *previous_count[SNB_CSTATE_COUNT];\nstatic unsigned long long *current_count[SNB_CSTATE_COUNT];\n \nstatic int *is_valid;\n\nstatic int snb_get_count(enum intel_snb_id id, unsigned long long *val,\n\t\t\tunsigned int cpu)\n{\n\tint msr;\n\n\tswitch (id) {\n\tcase C7:\n\t\tmsr = MSR_CORE_C7_RESIDENCY;\n\t\tbreak;\n\tcase PC2:\n\t\tmsr = MSR_PKG_C2_RESIDENCY;\n\t\tbreak;\n\tcase PC7:\n\t\tmsr = MSR_PKG_C7_RESIDENCY;\n\t\tbreak;\n\tcase TSC:\n\t\tmsr = MSR_TSC;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\tif (read_msr(cpu, msr, val))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int snb_get_count_percent(unsigned int id, double *percent,\n\t\t\t\t unsigned int cpu)\n{\n\t*percent = 0.0;\n\n\tif (!is_valid[cpu])\n\t\treturn -1;\n\n\t*percent = (100.0 *\n\t\t(current_count[id][cpu] - previous_count[id][cpu])) /\n\t\t(tsc_at_measure_end - tsc_at_measure_start);\n\n\tdprint(\"%s: previous: %llu - current: %llu - (%u)\\n\",\n\t\tsnb_cstates[id].name, previous_count[id][cpu],\n\t\tcurrent_count[id][cpu], cpu);\n\n\tdprint(\"%s: tsc_diff: %llu - count_diff: %llu - percent: %2.f (%u)\\n\",\n\t       snb_cstates[id].name,\n\t       (unsigned long long) tsc_at_measure_end - tsc_at_measure_start,\n\t       current_count[id][cpu] - previous_count[id][cpu],\n\t       *percent, cpu);\n\n\treturn 0;\n}\n\nstatic int snb_start(void)\n{\n\tint num, cpu;\n\tunsigned long long val;\n\n\tfor (num = 0; num < SNB_CSTATE_COUNT; num++) {\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\t\tsnb_get_count(num, &val, cpu);\n\t\t\tprevious_count[num][cpu] = val;\n\t\t}\n\t}\n\tsnb_get_count(TSC, &tsc_at_measure_start, base_cpu);\n\treturn 0;\n}\n\nstatic int snb_stop(void)\n{\n\tunsigned long long val;\n\tint num, cpu;\n\n\tsnb_get_count(TSC, &tsc_at_measure_end, base_cpu);\n\n\tfor (num = 0; num < SNB_CSTATE_COUNT; num++) {\n\t\tfor (cpu = 0; cpu < cpu_count; cpu++) {\n\t\t\tis_valid[cpu] = !snb_get_count(num, &val, cpu);\n\t\t\tcurrent_count[num][cpu] = val;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstruct cpuidle_monitor intel_snb_monitor;\n\nstatic struct cpuidle_monitor *snb_register(void)\n{\n\tint num;\n\n\tif (cpupower_cpu_info.vendor != X86_VENDOR_INTEL\n\t    || cpupower_cpu_info.family != 6)\n\t\treturn NULL;\n\n\tswitch (cpupower_cpu_info.model) {\n\tcase 0x2A:  \n\tcase 0x2D:  \n\tcase 0x3A:  \n\tcase 0x3E:  \n\tcase 0x3C:  \n\tcase 0x3F:  \n\tcase 0x45:  \n\tcase 0x46:  \n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tis_valid = calloc(cpu_count, sizeof(int));\n\tfor (num = 0; num < SNB_CSTATE_COUNT; num++) {\n\t\tprevious_count[num] = calloc(cpu_count,\n\t\t\t\t\tsizeof(unsigned long long));\n\t\tcurrent_count[num]  = calloc(cpu_count,\n\t\t\t\t\tsizeof(unsigned long long));\n\t}\n\tintel_snb_monitor.name_len = strlen(intel_snb_monitor.name);\n\treturn &intel_snb_monitor;\n}\n\nvoid snb_unregister(void)\n{\n\tint num;\n\tfree(is_valid);\n\tfor (num = 0; num < SNB_CSTATE_COUNT; num++) {\n\t\tfree(previous_count[num]);\n\t\tfree(current_count[num]);\n\t}\n}\n\nstruct cpuidle_monitor intel_snb_monitor = {\n\t.name\t\t\t= \"SandyBridge\",\n\t.hw_states\t\t= snb_cstates,\n\t.hw_states_num\t\t= SNB_CSTATE_COUNT,\n\t.start\t\t\t= snb_start,\n\t.stop\t\t\t= snb_stop,\n\t.do_register\t\t= snb_register,\n\t.unregister\t\t= snb_unregister,\n\t.flags.needs_root\t= 1,\n\t.overflow_s\t\t= 922000000  \n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}