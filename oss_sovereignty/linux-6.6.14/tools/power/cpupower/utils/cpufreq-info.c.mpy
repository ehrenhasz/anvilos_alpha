{
  "module_name": "cpufreq-info.c",
  "hash_id": "89b5cd2eef5bdab5caa36a38463cd55509c3e18d4baddc08e94c153b0db7da21",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/cpufreq-info.c",
  "human_readable_source": "\n \n\n\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#include <getopt.h>\n\n#include \"cpufreq.h\"\n#include \"helpers/sysfs.h\"\n#include \"helpers/helpers.h\"\n#include \"helpers/bitmask.h\"\n\n#define LINE_LEN 10\n\nstatic unsigned int count_cpus(void)\n{\n\tFILE *fp;\n\tchar value[LINE_LEN];\n\tunsigned int ret = 0;\n\tunsigned int cpunr = 0;\n\n\tfp = fopen(\"/proc/stat\", \"r\");\n\tif (!fp) {\n\t\tprintf(_(\"Couldn't count the number of CPUs (%s: %s), assuming 1\\n\"), \"/proc/stat\", strerror(errno));\n\t\treturn 1;\n\t}\n\n\twhile (!feof(fp)) {\n\t\tif (!fgets(value, LINE_LEN, fp))\n\t\t\tcontinue;\n\t\tvalue[LINE_LEN - 1] = '\\0';\n\t\tif (strlen(value) < (LINE_LEN - 2))\n\t\t\tcontinue;\n\t\tif (strstr(value, \"cpu \"))\n\t\t\tcontinue;\n\t\tif (sscanf(value, \"cpu%d \", &cpunr) != 1)\n\t\t\tcontinue;\n\t\tif (cpunr > ret)\n\t\t\tret = cpunr;\n\t}\n\tfclose(fp);\n\n\t \n\treturn ret + 1;\n}\n\n\nstatic void proc_cpufreq_output(void)\n{\n\tunsigned int cpu, nr_cpus;\n\tstruct cpufreq_policy *policy;\n\tunsigned int min_pctg = 0;\n\tunsigned int max_pctg = 0;\n\tunsigned long min, max;\n\n\tprintf(_(\"          minimum CPU frequency  -  maximum CPU frequency  -  governor\\n\"));\n\n\tnr_cpus = count_cpus();\n\tfor (cpu = 0; cpu < nr_cpus; cpu++) {\n\t\tpolicy = cpufreq_get_policy(cpu);\n\t\tif (!policy)\n\t\t\tcontinue;\n\n\t\tif (cpufreq_get_hardware_limits(cpu, &min, &max)) {\n\t\t\tmax = 0;\n\t\t} else {\n\t\t\tmin_pctg = (policy->min * 100) / max;\n\t\t\tmax_pctg = (policy->max * 100) / max;\n\t\t}\n\t\tprintf(\"CPU%3d    %9lu kHz (%3d %%)  -  %9lu kHz (%3d %%)  -  %s\\n\",\n\t\t\tcpu , policy->min, max ? min_pctg : 0, policy->max,\n\t\t\tmax ? max_pctg : 0, policy->governor);\n\n\t\tcpufreq_put_policy(policy);\n\t}\n}\n\nstatic int no_rounding;\nstatic void print_duration(unsigned long duration)\n{\n\tunsigned long tmp;\n\n\tif (no_rounding) {\n\t\tif (duration > 1000000)\n\t\t\tprintf(\"%u.%06u ms\", ((unsigned int) duration/1000000),\n\t\t\t\t((unsigned int) duration%1000000));\n\t\telse if (duration > 100000)\n\t\t\tprintf(\"%u us\", ((unsigned int) duration/1000));\n\t\telse if (duration > 1000)\n\t\t\tprintf(\"%u.%03u us\", ((unsigned int) duration/1000),\n\t\t\t\t((unsigned int) duration%1000));\n\t\telse\n\t\t\tprintf(\"%lu ns\", duration);\n\t} else {\n\t\tif (duration > 1000000) {\n\t\t\ttmp = duration%10000;\n\t\t\tif (tmp >= 5000)\n\t\t\t\tduration += 10000;\n\t\t\tprintf(\"%u.%02u ms\", ((unsigned int) duration/1000000),\n\t\t\t\t((unsigned int) (duration%1000000)/10000));\n\t\t} else if (duration > 100000) {\n\t\t\ttmp = duration%1000;\n\t\t\tif (tmp >= 500)\n\t\t\t\tduration += 1000;\n\t\t\tprintf(\"%u us\", ((unsigned int) duration / 1000));\n\t\t} else if (duration > 1000) {\n\t\t\ttmp = duration%100;\n\t\t\tif (tmp >= 50)\n\t\t\t\tduration += 100;\n\t\t\tprintf(\"%u.%01u us\", ((unsigned int) duration/1000),\n\t\t\t\t((unsigned int) (duration%1000)/100));\n\t\t} else\n\t\t\tprintf(\"%lu ns\", duration);\n\t}\n\treturn;\n}\n\nstatic int get_boost_mode_x86(unsigned int cpu)\n{\n\tint support, active, b_states = 0, ret, pstate_no, i;\n\t \n\tunsigned long pstates[MAX_HW_PSTATES] = {0,};\n\n\tret = cpufreq_has_boost_support(cpu, &support, &active, &b_states);\n\tif (ret) {\n\t\tprintf(_(\"Error while evaluating Boost Capabilities\"\n\t\t\t\t\" on CPU %d -- are you root?\\n\"), cpu);\n\t\treturn ret;\n\t}\n\t \n\n\tprintf(_(\"  boost state support:\\n\"));\n\n\tprintf(_(\"    Supported: %s\\n\"), support ? _(\"yes\") : _(\"no\"));\n\tprintf(_(\"    Active: %s\\n\"), active ? _(\"yes\") : _(\"no\"));\n\n\tif (cpupower_cpu_info.vendor == X86_VENDOR_AMD &&\n\t    cpupower_cpu_info.caps & CPUPOWER_CAP_AMD_PSTATE) {\n\t\treturn 0;\n\t} else if ((cpupower_cpu_info.vendor == X86_VENDOR_AMD &&\n\t\t    cpupower_cpu_info.family >= 0x10) ||\n\t\t   cpupower_cpu_info.vendor == X86_VENDOR_HYGON) {\n\t\tret = decode_pstates(cpu, b_states, pstates, &pstate_no);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tprintf(_(\"    Boost States: %d\\n\"), b_states);\n\t\tprintf(_(\"    Total States: %d\\n\"), pstate_no);\n\t\tfor (i = 0; i < pstate_no; i++) {\n\t\t\tif (!pstates[i])\n\t\t\t\tcontinue;\n\t\t\tif (i < b_states)\n\t\t\t\tprintf(_(\"    Pstate-Pb%d: %luMHz (boost state)\"\n\t\t\t\t\t \"\\n\"), i, pstates[i]);\n\t\t\telse\n\t\t\t\tprintf(_(\"    Pstate-P%d:  %luMHz\\n\"),\n\t\t\t\t       i - b_states, pstates[i]);\n\t\t}\n\t} else if (cpupower_cpu_info.caps & CPUPOWER_CAP_HAS_TURBO_RATIO) {\n\t\tdouble bclk;\n\t\tunsigned long long intel_turbo_ratio = 0;\n\t\tunsigned int ratio;\n\n\t\t \n\t\tif (cpupower_cpu_info.caps & CPUPOWER_CAP_IS_SNB)\n\t\t\tbclk = 100.00;\n\t\telse\n\t\t\tbclk = 133.33;\n\t\tintel_turbo_ratio = msr_intel_get_turbo_ratio(cpu);\n\t\tdprint (\"    Ratio: 0x%llx - bclk: %f\\n\",\n\t\t\tintel_turbo_ratio, bclk);\n\n\t\tratio = (intel_turbo_ratio >> 24) & 0xFF;\n\t\tif (ratio)\n\t\t\tprintf(_(\"    %.0f MHz max turbo 4 active cores\\n\"),\n\t\t\t       ratio * bclk);\n\n\t\tratio = (intel_turbo_ratio >> 16) & 0xFF;\n\t\tif (ratio)\n\t\t\tprintf(_(\"    %.0f MHz max turbo 3 active cores\\n\"),\n\t\t\t       ratio * bclk);\n\n\t\tratio = (intel_turbo_ratio >> 8) & 0xFF;\n\t\tif (ratio)\n\t\t\tprintf(_(\"    %.0f MHz max turbo 2 active cores\\n\"),\n\t\t\t       ratio * bclk);\n\n\t\tratio = (intel_turbo_ratio >> 0) & 0xFF;\n\t\tif (ratio)\n\t\t\tprintf(_(\"    %.0f MHz max turbo 1 active cores\\n\"),\n\t\t\t       ratio * bclk);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int get_boost_mode(unsigned int cpu)\n{\n\tstruct cpufreq_available_frequencies *freqs;\n\n\tif (cpupower_cpu_info.vendor == X86_VENDOR_AMD ||\n\t    cpupower_cpu_info.vendor == X86_VENDOR_HYGON ||\n\t    cpupower_cpu_info.vendor == X86_VENDOR_INTEL)\n\t\treturn get_boost_mode_x86(cpu);\n\n\tfreqs = cpufreq_get_boost_frequencies(cpu);\n\tif (freqs) {\n\t\tprintf(_(\"  boost frequency steps: \"));\n\t\twhile (freqs->next) {\n\t\t\tprint_speed(freqs->frequency, no_rounding);\n\t\t\tprintf(\", \");\n\t\t\tfreqs = freqs->next;\n\t\t}\n\t\tprint_speed(freqs->frequency, no_rounding);\n\t\tprintf(\"\\n\");\n\t\tcpufreq_put_available_frequencies(freqs);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int get_freq_kernel(unsigned int cpu, unsigned int human)\n{\n\tunsigned long freq = cpufreq_get_freq_kernel(cpu);\n\tprintf(_(\"  current CPU frequency: \"));\n\tif (!freq) {\n\t\tprintf(_(\" Unable to call to kernel\\n\"));\n\t\treturn -EINVAL;\n\t}\n\tif (human) {\n\t\tprint_speed(freq, no_rounding);\n\t} else\n\t\tprintf(\"%lu\", freq);\n\tprintf(_(\" (asserted by call to kernel)\\n\"));\n\treturn 0;\n}\n\n\n \n\nstatic int get_freq_hardware(unsigned int cpu, unsigned int human)\n{\n\tunsigned long freq = cpufreq_get_freq_hardware(cpu);\n\tprintf(_(\"  current CPU frequency: \"));\n\tif (!freq) {\n\t\tprintf(\"Unable to call hardware\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (human) {\n\t\tprint_speed(freq, no_rounding);\n\t} else\n\t\tprintf(\"%lu\", freq);\n\tprintf(_(\" (asserted by call to hardware)\\n\"));\n\treturn 0;\n}\n\n \n\nstatic int get_hardware_limits(unsigned int cpu, unsigned int human)\n{\n\tunsigned long min, max;\n\n\tif (cpufreq_get_hardware_limits(cpu, &min, &max)) {\n\t\tprintf(_(\"Not Available\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\tif (human) {\n\t\tprintf(_(\"  hardware limits: \"));\n\t\tprint_speed(min, no_rounding);\n\t\tprintf(\" - \");\n\t\tprint_speed(max, no_rounding);\n\t\tprintf(\"\\n\");\n\t} else {\n\t\tprintf(\"%lu %lu\\n\", min, max);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int get_driver(unsigned int cpu)\n{\n\tchar *driver = cpufreq_get_driver(cpu);\n\tif (!driver) {\n\t\tprintf(_(\"  no or unknown cpufreq driver is active on this CPU\\n\"));\n\t\treturn -EINVAL;\n\t}\n\tprintf(\"  driver: %s\\n\", driver);\n\tcpufreq_put_driver(driver);\n\treturn 0;\n}\n\n \n\nstatic int get_policy(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_get_policy(cpu);\n\tif (!policy) {\n\t\tprintf(_(\"  Unable to determine current policy\\n\"));\n\t\treturn -EINVAL;\n\t}\n\tprintf(_(\"  current policy: frequency should be within \"));\n\tprint_speed(policy->min, no_rounding);\n\tprintf(_(\" and \"));\n\tprint_speed(policy->max, no_rounding);\n\n\tprintf(\".\\n                  \");\n\tprintf(_(\"The governor \\\"%s\\\" may decide which speed to use\\n\"\n\t       \"                  within this range.\\n\"),\n\t       policy->governor);\n\tcpufreq_put_policy(policy);\n\treturn 0;\n}\n\n \n\nstatic int get_available_governors(unsigned int cpu)\n{\n\tstruct cpufreq_available_governors *governors =\n\t\tcpufreq_get_available_governors(cpu);\n\n\tprintf(_(\"  available cpufreq governors: \"));\n\tif (!governors) {\n\t\tprintf(_(\"Not Available\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\twhile (governors->next) {\n\t\tprintf(\"%s \", governors->governor);\n\t\tgovernors = governors->next;\n\t}\n\tprintf(\"%s\\n\", governors->governor);\n\tcpufreq_put_available_governors(governors);\n\treturn 0;\n}\n\n\n \n\nstatic int get_affected_cpus(unsigned int cpu)\n{\n\tstruct cpufreq_affected_cpus *cpus = cpufreq_get_affected_cpus(cpu);\n\n\tprintf(_(\"  CPUs which need to have their frequency coordinated by software: \"));\n\tif (!cpus) {\n\t\tprintf(_(\"Not Available\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\twhile (cpus->next) {\n\t\tprintf(\"%d \", cpus->cpu);\n\t\tcpus = cpus->next;\n\t}\n\tprintf(\"%d\\n\", cpus->cpu);\n\tcpufreq_put_affected_cpus(cpus);\n\treturn 0;\n}\n\n \n\nstatic int get_related_cpus(unsigned int cpu)\n{\n\tstruct cpufreq_affected_cpus *cpus = cpufreq_get_related_cpus(cpu);\n\n\tprintf(_(\"  CPUs which run at the same hardware frequency: \"));\n\tif (!cpus) {\n\t\tprintf(_(\"Not Available\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\twhile (cpus->next) {\n\t\tprintf(\"%d \", cpus->cpu);\n\t\tcpus = cpus->next;\n\t}\n\tprintf(\"%d\\n\", cpus->cpu);\n\tcpufreq_put_related_cpus(cpus);\n\treturn 0;\n}\n\n \n\nstatic int get_freq_stats(unsigned int cpu, unsigned int human)\n{\n\tunsigned long total_trans = cpufreq_get_transitions(cpu);\n\tunsigned long long total_time;\n\tstruct cpufreq_stats *stats = cpufreq_get_stats(cpu, &total_time);\n\twhile (stats) {\n\t\tif (human) {\n\t\t\tprint_speed(stats->frequency, no_rounding);\n\t\t\tprintf(\":%.2f%%\",\n\t\t\t\t(100.0 * stats->time_in_state) / total_time);\n\t\t} else\n\t\t\tprintf(\"%lu:%llu\",\n\t\t\t\tstats->frequency, stats->time_in_state);\n\t\tstats = stats->next;\n\t\tif (stats)\n\t\t\tprintf(\", \");\n\t}\n\tcpufreq_put_stats(stats);\n\tif (total_trans)\n\t\tprintf(\"  (%lu)\\n\", total_trans);\n\treturn 0;\n}\n\n \n\nstatic int get_latency(unsigned int cpu, unsigned int human)\n{\n\tunsigned long latency = cpufreq_get_transition_latency(cpu);\n\n\tprintf(_(\"  maximum transition latency: \"));\n\tif (!latency || latency == UINT_MAX) {\n\t\tprintf(_(\" Cannot determine or is not supported.\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\tif (human) {\n\t\tprint_duration(latency);\n\t\tprintf(\"\\n\");\n\t} else\n\t\tprintf(\"%lu\\n\", latency);\n\treturn 0;\n}\n\n \n\nstatic int get_perf_cap(unsigned int cpu)\n{\n\tif (cpupower_cpu_info.vendor == X86_VENDOR_AMD &&\n\t    cpupower_cpu_info.caps & CPUPOWER_CAP_AMD_PSTATE)\n\t\tamd_pstate_show_perf_and_freq(cpu, no_rounding);\n\n\treturn 0;\n}\n\nstatic void debug_output_one(unsigned int cpu)\n{\n\tstruct cpufreq_available_frequencies *freqs;\n\n\tget_driver(cpu);\n\tget_related_cpus(cpu);\n\tget_affected_cpus(cpu);\n\tget_latency(cpu, 1);\n\tget_hardware_limits(cpu, 1);\n\n\tfreqs = cpufreq_get_available_frequencies(cpu);\n\tif (freqs) {\n\t\tprintf(_(\"  available frequency steps:  \"));\n\t\twhile (freqs->next) {\n\t\t\tprint_speed(freqs->frequency, no_rounding);\n\t\t\tprintf(\", \");\n\t\t\tfreqs = freqs->next;\n\t\t}\n\t\tprint_speed(freqs->frequency, no_rounding);\n\t\tprintf(\"\\n\");\n\t\tcpufreq_put_available_frequencies(freqs);\n\t}\n\n\tget_available_governors(cpu);\n\tget_policy(cpu);\n\tif (get_freq_hardware(cpu, 1) < 0)\n\t\tget_freq_kernel(cpu, 1);\n\tget_boost_mode(cpu);\n\tget_perf_cap(cpu);\n}\n\nstatic struct option info_opts[] = {\n\t{\"debug\",\t no_argument,\t\t NULL,\t 'e'},\n\t{\"boost\",\t no_argument,\t\t NULL,\t 'b'},\n\t{\"freq\",\t no_argument,\t\t NULL,\t 'f'},\n\t{\"hwfreq\",\t no_argument,\t\t NULL,\t 'w'},\n\t{\"hwlimits\",\t no_argument,\t\t NULL,\t 'l'},\n\t{\"driver\",\t no_argument,\t\t NULL,\t 'd'},\n\t{\"policy\",\t no_argument,\t\t NULL,\t 'p'},\n\t{\"governors\",\t no_argument,\t\t NULL,\t 'g'},\n\t{\"related-cpus\",  no_argument,\t NULL,\t 'r'},\n\t{\"affected-cpus\", no_argument,\t NULL,\t 'a'},\n\t{\"stats\",\t no_argument,\t\t NULL,\t 's'},\n\t{\"latency\",\t no_argument,\t\t NULL,\t 'y'},\n\t{\"proc\",\t no_argument,\t\t NULL,\t 'o'},\n\t{\"human\",\t no_argument,\t\t NULL,\t 'm'},\n\t{\"no-rounding\", no_argument,\t NULL,\t 'n'},\n\t{\"performance\", no_argument,\t NULL,\t 'c'},\n\t{ },\n};\n\nint cmd_freq_info(int argc, char **argv)\n{\n\textern char *optarg;\n\textern int optind, opterr, optopt;\n\tint ret = 0, cont = 1;\n\tunsigned int cpu = 0;\n\tunsigned int human = 0;\n\tint output_param = 0;\n\n\tdo {\n\t\tret = getopt_long(argc, argv, \"oefwldpgrasmybnc\", info_opts,\n\t\t\t\t  NULL);\n\t\tswitch (ret) {\n\t\tcase '?':\n\t\t\toutput_param = '?';\n\t\t\tcont = 0;\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tcont = 0;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\tcase 'o':\n\t\tcase 'a':\n\t\tcase 'r':\n\t\tcase 'g':\n\t\tcase 'p':\n\t\tcase 'd':\n\t\tcase 'l':\n\t\tcase 'w':\n\t\tcase 'f':\n\t\tcase 'e':\n\t\tcase 's':\n\t\tcase 'y':\n\t\tcase 'c':\n\t\t\tif (output_param) {\n\t\t\t\toutput_param = -1;\n\t\t\t\tcont = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutput_param = ret;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (human) {\n\t\t\t\toutput_param = -1;\n\t\t\t\tcont = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thuman = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tno_rounding = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"invalid or unknown argument\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t} while (cont);\n\n\tswitch (output_param) {\n\tcase 'o':\n\t\tif (!bitmask_isallclear(cpus_chosen)) {\n\t\t\tprintf(_(\"The argument passed to this tool can't be \"\n\t\t\t\t \"combined with passing a --cpu argument\\n\"));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\toutput_param = 'e';\n\t}\n\n\tret = 0;\n\n\t \n\tif (bitmask_isallclear(cpus_chosen))\n\t\tbitmask_setbit(cpus_chosen, base_cpu);\n\n\tswitch (output_param) {\n\tcase -1:\n\t\tprintf(_(\"You can't specify more than one --cpu parameter and/or\\n\"\n\t\t       \"more than one output-specific argument\\n\"));\n\t\treturn -EINVAL;\n\tcase '?':\n\t\tprintf(_(\"invalid or unknown argument\\n\"));\n\t\treturn -EINVAL;\n\tcase 'o':\n\t\tproc_cpufreq_output();\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\tfor (cpu = bitmask_first(cpus_chosen);\n\t     cpu <= bitmask_last(cpus_chosen); cpu++) {\n\n\t\tif (!bitmask_isbitset(cpus_chosen, cpu))\n\t\t\tcontinue;\n\n\t\tprintf(_(\"analyzing CPU %d:\\n\"), cpu);\n\n\t\tif (sysfs_is_cpu_online(cpu) != 1) {\n\t\t\tprintf(_(\" *is offline\\n\"));\n\t\t\tprintf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (output_param) {\n\t\tcase 'b':\n\t\t\tget_boost_mode(cpu);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdebug_output_one(cpu);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tret = get_affected_cpus(cpu);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tret = get_related_cpus(cpu);\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tret = get_available_governors(cpu);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tret = get_policy(cpu);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tret = get_driver(cpu);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tret = get_hardware_limits(cpu, human);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tret = get_freq_hardware(cpu, human);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tret = get_freq_kernel(cpu, human);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tret = get_freq_stats(cpu, human);\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tret = get_latency(cpu, human);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tret = get_perf_cap(cpu);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}