{
  "module_name": "cpuidle-info.c",
  "hash_id": "2b8e1b768ca8b7669770966721f8eca86377e0cc35df13ed80c610e143022fe9",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/cpuidle-info.c",
  "human_readable_source": "\n \n\n\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n\n#include <cpuidle.h>\n\n#include \"helpers/sysfs.h\"\n#include \"helpers/helpers.h\"\n#include \"helpers/bitmask.h\"\n\n#define LINE_LEN 10\n\nstatic void cpuidle_cpu_output(unsigned int cpu, int verbose)\n{\n\tunsigned int idlestates, idlestate;\n\tchar *tmp;\n\n\tidlestates = cpuidle_state_count(cpu);\n\tif (idlestates == 0) {\n\t\tprintf(_(\"CPU %u: No idle states\\n\"), cpu);\n\t\treturn;\n\t}\n\n\tprintf(_(\"Number of idle states: %d\\n\"), idlestates);\n\tprintf(_(\"Available idle states:\"));\n\tfor (idlestate = 0; idlestate < idlestates; idlestate++) {\n\t\ttmp = cpuidle_state_name(cpu, idlestate);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tprintf(\" %s\", tmp);\n\t\tfree(tmp);\n\t}\n\tprintf(\"\\n\");\n\n\tif (!verbose)\n\t\treturn;\n\n\tfor (idlestate = 0; idlestate < idlestates; idlestate++) {\n\t\tint disabled = cpuidle_is_state_disabled(cpu, idlestate);\n\t\t \n\t\tif (disabled < 0)\n\t\t\tdisabled = 0;\n\t\ttmp = cpuidle_state_name(cpu, idlestate);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tprintf(\"%s%s:\\n\", tmp, (disabled) ? \" (DISABLED) \" : \"\");\n\t\tfree(tmp);\n\n\t\ttmp = cpuidle_state_desc(cpu, idlestate);\n\t\tif (!tmp)\n\t\t\tcontinue;\n\t\tprintf(_(\"Flags/Description: %s\\n\"), tmp);\n\t\tfree(tmp);\n\n\t\tprintf(_(\"Latency: %lu\\n\"),\n\t\t       cpuidle_state_latency(cpu, idlestate));\n\t\tprintf(_(\"Usage: %lu\\n\"),\n\t\t       cpuidle_state_usage(cpu, idlestate));\n\t\tprintf(_(\"Duration: %llu\\n\"),\n\t\t       cpuidle_state_time(cpu, idlestate));\n\t}\n}\n\nstatic void cpuidle_general_output(void)\n{\n\tchar *tmp;\n\n\ttmp = cpuidle_get_driver();\n\tif (!tmp) {\n\t\tprintf(_(\"Could not determine cpuidle driver\\n\"));\n\t\treturn;\n\t}\n\n\tprintf(_(\"CPUidle driver: %s\\n\"), tmp);\n\tfree(tmp);\n\n\ttmp = cpuidle_get_governor();\n\tif (!tmp) {\n\t\tprintf(_(\"Could not determine cpuidle governor\\n\"));\n\t\treturn;\n\t}\n\n\tprintf(_(\"CPUidle governor: %s\\n\"), tmp);\n\tfree(tmp);\n}\n\nstatic void proc_cpuidle_cpu_output(unsigned int cpu)\n{\n\tlong max_allowed_cstate = 2000000000;\n\tunsigned int cstate, cstates;\n\n\tcstates = cpuidle_state_count(cpu);\n\tif (cstates == 0) {\n\t\tprintf(_(\"CPU %u: No C-states info\\n\"), cpu);\n\t\treturn;\n\t}\n\n\tprintf(_(\"active state:            C0\\n\"));\n\tprintf(_(\"max_cstate:              C%u\\n\"), cstates-1);\n\tprintf(_(\"maximum allowed latency: %lu usec\\n\"), max_allowed_cstate);\n\tprintf(_(\"states:\\t\\n\"));\n\tfor (cstate = 1; cstate < cstates; cstate++) {\n\t\tprintf(_(\"    C%d:                  \"\n\t\t\t \"type[C%d] \"), cstate, cstate);\n\t\tprintf(_(\"promotion[--] demotion[--] \"));\n\t\tprintf(_(\"latency[%03lu] \"),\n\t\t       cpuidle_state_latency(cpu, cstate));\n\t\tprintf(_(\"usage[%08lu] \"),\n\t\t       cpuidle_state_usage(cpu, cstate));\n\t\tprintf(_(\"duration[%020Lu] \\n\"),\n\t\t       cpuidle_state_time(cpu, cstate));\n\t}\n}\n\nstatic struct option info_opts[] = {\n\t{\"silent\", no_argument, NULL, 's'},\n\t{\"proc\", no_argument, NULL, 'o'},\n\t{ },\n};\n\nstatic inline void cpuidle_exit(int fail)\n{\n\texit(EXIT_FAILURE);\n}\n\nint cmd_idle_info(int argc, char **argv)\n{\n\textern char *optarg;\n\textern int optind, opterr, optopt;\n\tint ret = 0, cont = 1, output_param = 0, verbose = 1;\n\tunsigned int cpu = 0;\n\n\tdo {\n\t\tret = getopt_long(argc, argv, \"os\", info_opts, NULL);\n\t\tif (ret == -1)\n\t\t\tbreak;\n\t\tswitch (ret) {\n\t\tcase '?':\n\t\t\toutput_param = '?';\n\t\t\tcont = 0;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tverbose = 0;\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tcont = 0;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (output_param) {\n\t\t\t\toutput_param = -1;\n\t\t\t\tcont = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutput_param = ret;\n\t\t\tbreak;\n\t\t}\n\t} while (cont);\n\n\tswitch (output_param) {\n\tcase -1:\n\t\tprintf(_(\"You can't specify more than one \"\n\t\t\t \"output-specific argument\\n\"));\n\t\tcpuidle_exit(EXIT_FAILURE);\n\tcase '?':\n\t\tprintf(_(\"invalid or unknown argument\\n\"));\n\t\tcpuidle_exit(EXIT_FAILURE);\n\t}\n\n\t \n\tif (bitmask_isallclear(cpus_chosen))\n\t\tbitmask_setbit(cpus_chosen, base_cpu);\n\n\tif (output_param == 0)\n\t\tcpuidle_general_output();\n\n\tfor (cpu = bitmask_first(cpus_chosen);\n\t     cpu <= bitmask_last(cpus_chosen); cpu++) {\n\n\t\tif (!bitmask_isbitset(cpus_chosen, cpu))\n\t\t\tcontinue;\n\n\t\tprintf(_(\"analyzing CPU %d:\\n\"), cpu);\n\n\t\tif (sysfs_is_cpu_online(cpu) != 1) {\n\t\t\tprintf(_(\" *is offline\\n\"));\n\t\t\tprintf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (output_param) {\n\n\t\tcase 'o':\n\t\t\tproc_cpuidle_cpu_output(cpu);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tprintf(\"\\n\");\n\t\t\tcpuidle_cpu_output(cpu, verbose);\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}