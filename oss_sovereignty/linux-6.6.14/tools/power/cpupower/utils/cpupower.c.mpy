{
  "module_name": "cpupower.c",
  "hash_id": "ff44d614783e5c9bed827f430f238517901d0cc32e1f8a6fced6da135e9019c6",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/cpupower.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sched.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n\n#include \"builtin.h\"\n#include \"helpers/helpers.h\"\n#include \"helpers/bitmask.h\"\n\n#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))\n\nstatic int cmd_help(int argc, const char **argv);\n\n \nstruct cpupower_cpu_info cpupower_cpu_info;\nint run_as_root;\nint base_cpu;\n \nstruct bitmask *cpus_chosen;\nstruct bitmask *online_cpus;\nstruct bitmask *offline_cpus;\n\n#ifdef DEBUG\nint be_verbose;\n#endif\n\nstatic void print_help(void);\n\nstruct cmd_struct {\n\tconst char *cmd;\n\tint (*main)(int, const char **);\n\tint needs_root;\n};\n\nstatic struct cmd_struct commands[] = {\n\t{ \"frequency-info\",\tcmd_freq_info,\t0\t},\n\t{ \"frequency-set\",\tcmd_freq_set,\t1\t},\n\t{ \"idle-info\",\t\tcmd_idle_info,\t0\t},\n\t{ \"idle-set\",\t\tcmd_idle_set,\t1\t},\n\t{ \"powercap-info\",\tcmd_cap_info,\t0\t},\n\t{ \"set\",\t\tcmd_set,\t1\t},\n\t{ \"info\",\t\tcmd_info,\t0\t},\n\t{ \"monitor\",\t\tcmd_monitor,\t0\t},\n\t{ \"help\",\t\tcmd_help,\t0\t},\n\t \n};\n\nstatic void print_help(void)\n{\n\tunsigned int i;\n\n#ifdef DEBUG\n\tprintf(_(\"Usage:\\tcpupower [-d|--debug] [-c|--cpu cpulist ] <command> [<args>]\\n\"));\n#else\n\tprintf(_(\"Usage:\\tcpupower [-c|--cpu cpulist ] <command> [<args>]\\n\"));\n#endif\n\tprintf(_(\"Supported commands are:\\n\"));\n\tfor (i = 0; i < ARRAY_SIZE(commands); i++)\n\t\tprintf(\"\\t%s\\n\", commands[i].cmd);\n\tprintf(_(\"\\nNot all commands can make use of the -c cpulist option.\\n\"));\n\tprintf(_(\"\\nUse 'cpupower help <command>' for getting help for above commands.\\n\"));\n}\n\nstatic int print_man_page(const char *subpage)\n{\n\tint len;\n\tchar *page;\n\n\tlen = 10;  \n\tif (subpage != NULL)\n\t\tlen += strlen(subpage);\n\n\tpage = malloc(len);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tsprintf(page, \"cpupower\");\n\tif ((subpage != NULL) && strcmp(subpage, \"help\")) {\n\t\tstrcat(page, \"-\");\n\t\tstrcat(page, subpage);\n\t}\n\n\texeclp(\"man\", \"man\", page, NULL);\n\n\t \n\treturn -EINVAL;\n}\n\nstatic int cmd_help(int argc, const char **argv)\n{\n\tif (argc > 1) {\n\t\tprint_man_page(argv[1]);  \n\t\treturn EXIT_FAILURE;\n\t}\n\n\tprint_help();\n\treturn EXIT_SUCCESS;\n}\n\nstatic void print_version(void)\n{\n\tprintf(PACKAGE \" \" VERSION \"\\n\");\n\tprintf(_(\"Report errors and bugs to %s, please.\\n\"), PACKAGE_BUGREPORT);\n}\n\nstatic void handle_options(int *argc, const char ***argv)\n{\n\tint ret, x, new_argc = 0;\n\n\tif (*argc < 1)\n\t\treturn;\n\n\tfor (x = 0;  x < *argc && ((*argv)[x])[0] == '-'; x++) {\n\t\tconst char *param = (*argv)[x];\n\t\tif (!strcmp(param, \"-h\") || !strcmp(param, \"--help\")) {\n\t\t\tprint_help();\n\t\t\texit(EXIT_SUCCESS);\n\t\t} else if (!strcmp(param, \"-c\") || !strcmp(param, \"--cpu\")) {\n\t\t\tif (*argc < 2) {\n\t\t\t\tprint_help();\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tif (!strcmp((*argv)[x+1], \"all\"))\n\t\t\t\tbitmask_setall(cpus_chosen);\n\t\t\telse {\n\t\t\t\tret = bitmask_parselist(\n\t\t\t\t\t\t(*argv)[x+1], cpus_chosen);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tfprintf(stderr, _(\"Error parsing cpu \"\n\t\t\t\t\t\t\t  \"list\\n\"));\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += 1;\n\t\t\t \n\t\t\tnew_argc += 2;\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param, \"-v\") ||\n\t\t\t!strcmp(param, \"--version\")) {\n\t\t\tprint_version();\n\t\t\texit(EXIT_SUCCESS);\n#ifdef DEBUG\n\t\t} else if (!strcmp(param, \"-d\") || !strcmp(param, \"--debug\")) {\n\t\t\tbe_verbose = 1;\n\t\t\tnew_argc++;\n\t\t\tcontinue;\n#endif\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown option: %s\\n\", param);\n\t\t\tprint_help();\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\t*argc -= new_argc;\n\t*argv += new_argc;\n}\n\nint main(int argc, const char *argv[])\n{\n\tconst char *cmd;\n\tunsigned int i, ret;\n\tstruct stat statbuf;\n\tstruct utsname uts;\n\tchar pathname[32];\n\n\tcpus_chosen = bitmask_alloc(sysconf(_SC_NPROCESSORS_CONF));\n\tonline_cpus = bitmask_alloc(sysconf(_SC_NPROCESSORS_CONF));\n\toffline_cpus = bitmask_alloc(sysconf(_SC_NPROCESSORS_CONF));\n\n\targc--;\n\targv += 1;\n\n\thandle_options(&argc, &argv);\n\n\tcmd = argv[0];\n\n\tif (argc < 1) {\n\t\tprint_help();\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tsetlocale(LC_ALL, \"\");\n\ttextdomain(PACKAGE);\n\n\t \n\tif (argc > 1 && !strcmp(argv[1], \"--help\")) {\n\t\targv[1] = argv[0];\n\t\targv[0] = cmd = \"help\";\n\t}\n\n\tbase_cpu = sched_getcpu();\n\tif (base_cpu < 0) {\n\t\tfprintf(stderr, _(\"No valid cpus found.\\n\"));\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tget_cpu_info(&cpupower_cpu_info);\n\trun_as_root = !geteuid();\n\tif (run_as_root) {\n\t\tret = uname(&uts);\n\t\tsprintf(pathname, \"/dev/cpu/%d/msr\", base_cpu);\n\t\tif (!ret && !strcmp(uts.machine, \"x86_64\") &&\n\t\t    stat(pathname, &statbuf) != 0) {\n\t\t\tif (system(\"modprobe msr\") == -1)\n\tfprintf(stderr, _(\"MSR access not available.\\n\"));\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(commands); i++) {\n\t\tstruct cmd_struct *p = commands + i;\n\t\tif (strcmp(p->cmd, cmd))\n\t\t\tcontinue;\n\t\tif (!run_as_root && p->needs_root) {\n\t\t\tfprintf(stderr, _(\"Subcommand %s needs root \"\n\t\t\t\t\t  \"privileges\\n\"), cmd);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\tret = p->main(argc, argv);\n\t\tif (cpus_chosen)\n\t\t\tbitmask_free(cpus_chosen);\n\t\tif (online_cpus)\n\t\t\tbitmask_free(online_cpus);\n\t\tif (offline_cpus)\n\t\t\tbitmask_free(offline_cpus);\n\t\treturn ret;\n\t}\n\tprint_help();\n\treturn EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}