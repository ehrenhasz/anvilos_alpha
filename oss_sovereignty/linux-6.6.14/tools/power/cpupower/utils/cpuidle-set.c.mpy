{
  "module_name": "cpuidle-set.c",
  "hash_id": "bbb2ba1cc0ad2c4fbbc4c13c6a480cded3e5b552d201e4638f6f0c471c64c4fa",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/utils/cpuidle-set.c",
  "human_readable_source": "\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <ctype.h>\n#include <getopt.h>\n\n#include <cpufreq.h>\n#include <cpuidle.h>\n\n#include \"helpers/helpers.h\"\n\nstatic struct option info_opts[] = {\n     {\"disable\",\trequired_argument,\t\tNULL, 'd'},\n     {\"enable\",\t\trequired_argument,\t\tNULL, 'e'},\n     {\"disable-by-latency\", required_argument,\t\tNULL, 'D'},\n     {\"enable-all\",\tno_argument,\t\t\tNULL, 'E'},\n     { },\n};\n\n\nint cmd_idle_set(int argc, char **argv)\n{\n\textern char *optarg;\n\textern int optind, opterr, optopt;\n\tint ret = 0, cont = 1, param = 0, disabled;\n\tunsigned long long latency = 0, state_latency;\n\tunsigned int cpu = 0, idlestate = 0, idlestates = 0;\n\tchar *endptr;\n\n\tdo {\n\t\tret = getopt_long(argc, argv, \"d:e:ED:\", info_opts, NULL);\n\t\tif (ret == -1)\n\t\t\tbreak;\n\t\tswitch (ret) {\n\t\tcase '?':\n\t\t\tparam = '?';\n\t\t\tcont = 0;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'e':\n\t\t\tif (param) {\n\t\t\t\tparam = -1;\n\t\t\t\tcont = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparam = ret;\n\t\t\tstrtol(optarg, &endptr, 10);\n\t\t\tif (*endptr != '\\0') {\n\t\t\t\tprintf(_(\"Bad value: %s, Integer expected\\n\"), optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t} else {\n\t\t\t\tidlestate = atoi(optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (param) {\n\t\t\t\tparam = -1;\n\t\t\t\tcont = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparam = ret;\n\t\t\tlatency = strtoull(optarg, &endptr, 10);\n\t\t\tif (*endptr != '\\0') {\n\t\t\t\tprintf(_(\"Bad latency value: %s\\n\"), optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tif (param) {\n\t\t\t\tparam = -1;\n\t\t\t\tcont = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparam = ret;\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tcont = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (cont);\n\n\tswitch (param) {\n\tcase -1:\n\t\tprintf(_(\"You can't specify more than one \"\n\t\t\t \"output-specific argument\\n\"));\n\t\texit(EXIT_FAILURE);\n\tcase '?':\n\t\tprintf(_(\"invalid or unknown argument\\n\"));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tget_cpustate();\n\n\t \n\tif (bitmask_isallclear(cpus_chosen))\n\t\tbitmask_setall(cpus_chosen);\n\n\tfor (cpu = bitmask_first(cpus_chosen);\n\t     cpu <= bitmask_last(cpus_chosen); cpu++) {\n\n\t\tif (!bitmask_isbitset(cpus_chosen, cpu))\n\t\t\tcontinue;\n\n\t\tif (cpupower_is_cpu_online(cpu) != 1)\n\t\t\tcontinue;\n\n\t\tidlestates = cpuidle_state_count(cpu);\n\t\tif (idlestates <= 0)\n\t\t\tcontinue;\n\n\t\tswitch (param) {\n\t\tcase 'd':\n\t\t\tret = cpuidle_state_disable(cpu, idlestate, 1);\n\t\t\tif (ret == 0)\n\t\tprintf(_(\"Idlestate %u disabled on CPU %u\\n\"),  idlestate, cpu);\n\t\t\telse if (ret == -1)\n\t\tprintf(_(\"Idlestate %u not available on CPU %u\\n\"),\n\t\t       idlestate, cpu);\n\t\t\telse if (ret == -2)\n\t\tprintf(_(\"Idlestate disabling not supported by kernel\\n\"));\n\t\t\telse\n\t\tprintf(_(\"Idlestate %u not disabled on CPU %u\\n\"),\n\t\t       idlestate, cpu);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tret = cpuidle_state_disable(cpu, idlestate, 0);\n\t\t\tif (ret == 0)\n\t\tprintf(_(\"Idlestate %u enabled on CPU %u\\n\"),  idlestate, cpu);\n\t\t\telse if (ret == -1)\n\t\tprintf(_(\"Idlestate %u not available on CPU %u\\n\"),\n\t\t       idlestate, cpu);\n\t\t\telse if (ret == -2)\n\t\tprintf(_(\"Idlestate enabling not supported by kernel\\n\"));\n\t\t\telse\n\t\tprintf(_(\"Idlestate %u not enabled on CPU %u\\n\"),\n\t\t       idlestate, cpu);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tfor (idlestate = 0; idlestate < idlestates; idlestate++) {\n\t\t\t\tdisabled = cpuidle_is_state_disabled\n\t\t\t\t\t(cpu, idlestate);\n\t\t\t\tstate_latency = cpuidle_state_latency\n\t\t\t\t\t(cpu, idlestate);\n\t\t\t\tif (disabled == 1) {\n\t\t\t\t\tif (latency > state_latency){\n\t\t\t\t\t\tret = cpuidle_state_disable\n\t\t\t\t\t\t\t(cpu, idlestate, 0);\n\t\t\t\t\t\tif (ret == 0)\n\t\tprintf(_(\"Idlestate %u enabled on CPU %u\\n\"),  idlestate, cpu);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (latency <= state_latency){\n\t\t\t\t\tret = cpuidle_state_disable\n\t\t\t\t\t\t(cpu, idlestate, 1);\n\t\t\t\t\tif (ret == 0)\n\t\tprintf(_(\"Idlestate %u disabled on CPU %u\\n\"), idlestate, cpu);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tfor (idlestate = 0; idlestate < idlestates; idlestate++) {\n\t\t\t\tdisabled = cpuidle_is_state_disabled\n\t\t\t\t\t(cpu, idlestate);\n\t\t\t\tif (disabled == 1) {\n\t\t\t\t\tret = cpuidle_state_disable\n\t\t\t\t\t\t(cpu, idlestate, 0);\n\t\t\t\t\tif (ret == 0)\n\t\tprintf(_(\"Idlestate %u enabled on CPU %u\\n\"), idlestate, cpu);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tprintf(_(\"Invalid or unknown argument\\n\"));\n\t\t\texit(EXIT_FAILURE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprint_offline_cpus();\n\treturn EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}