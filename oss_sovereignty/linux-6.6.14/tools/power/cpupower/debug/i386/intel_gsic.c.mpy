{
  "module_name": "intel_gsic.c",
  "hash_id": "ab844327ce3addad98dbbce23335b0abbc4da48a9fd3fd663e25a681b5907a8f",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/debug/i386/intel_gsic.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <string.h>\n#include <lrmi.h>\n\nint main (void)\n{\n\tstruct LRMI_regs\tr;\n\tint\t\t\tretval;\n\n\tif (!LRMI_init())\n\t\treturn 0;\n\n\tmemset(&r, 0, sizeof(r));\n\n\tr.eax = 0x0000E980;\n\tr.edx = 0x47534943;\n\n\tretval = LRMI_int(0x15, &r);\n\n\tif (!retval) {\n\t\tprintf(\"Failed!\\n\");\n\t\treturn 0;\n\t}\n\tif (r.eax == 0x47534943) {\n\t\tprintf(\"BIOS supports GSIC call:\\n\");\n\t\tprintf(\"\\tsignature: %c%c%c%c\\n\",\n\t\t       (r.eax >> 24) & 0xff,\n\t\t       (r.eax >> 16) & 0xff,\n\t\t       (r.eax >> 8) & 0xff,\n\t\t       (r.eax) & 0xff);\n\t\tprintf(\"\\tcommand port = 0x%.4x\\n\",\n\t\t       r.ebx & 0xffff);\n\t\tprintf(\"\\tcommand =      0x%.4x\\n\",\n\t\t       (r.ebx >> 16) & 0xffff);\n\t\tprintf(\"\\tevent port =   0x%.8x\\n\", r.ecx);\n\t\tprintf(\"\\tflags =        0x%.8x\\n\", r.edx);\n\t\tif (((r.ebx >> 16) & 0xffff) != 0x82) {\n\t\t\tprintf(\"non-default command value. If speedstep-smi \"\n\t\t\t       \"doesn't work out of the box,\\nyou may want to \"\n\t\t\t       \"try out the default value by passing \"\n\t\t\t       \"smi_cmd=0x82 to the module\\n ON YOUR OWN \"\n\t\t\t       \"RISK.\\n\");\n\t\t}\n\t\tif ((r.ebx & 0xffff) != 0xb2) {\n\t\t\tprintf(\"non-default command port. If speedstep-smi \"\n\t\t\t       \"doesn't work out of the box,\\nyou may want to \"\n\t\t\t       \"try out the default value by passing \"\n\t\t\t       \"smi_port=0x82 to the module\\n ON YOUR OWN \"\n\t\t\t       \"RISK.\\n\");\n\t\t}\n\t} else {\n\t\tprintf(\"BIOS DOES NOT support GSIC call.  Dumping registers anyway:\\n\");\n\t\tprintf(\"eax = 0x%.8x\\n\", r.eax);\n\t\tprintf(\"ebx = 0x%.8x\\n\", r.ebx);\n\t\tprintf(\"ecx = 0x%.8x\\n\", r.ecx);\n\t\tprintf(\"edx = 0x%.8x\\n\", r.edx);\n\t\tprintf(\"Note also that some BIOS do not support the initial \"\n\t\t       \"GSIC call, but the newer\\nspeedstep-smi driver may \"\n\t\t       \"work.\\nFor this, you need to pass some arguments to \"\n\t\t       \"the speedstep-smi driver:\\n\");\n\t\tprintf(\"\\tsmi_cmd=0x?? smi_port=0x?? smi_sig=1\\n\");\n\t\tprintf(\"\\nUnfortunately, you have to know what exactly are \"\n\t\t       \"smi_cmd and smi_port, and this\\nis system \"\n\t\t       \"dependent.\\n\");\n\t}\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}