{
  "module_name": "cpupower-monitor.1",
  "hash_id": "9c58511a38959605c9282b56cafd92fa4ef1e0461cadfaf19c6d077045551503",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/cpupower/man/cpupower-monitor.1",
  "human_readable_source": ".TH CPUPOWER\\-MONITOR \"1\" \"22/02/2011\" \"\" \"cpupower Manual\"\n.SH NAME\ncpupower\\-monitor \\- Report processor frequency and idle statistics\n.SH SYNOPSIS\n.ft B\n.B cpupower monitor\n.RB \"\\-l\"\n\n.B cpupower monitor\n.RB [ -c ] [ \"\\-m <mon1>,\" [ \"<mon2>,...\" ] ]\n.RB [ \"\\-i seconds\" ]\n.br\n.B cpupower monitor\n.RB [ -c ][ \"\\-m <mon1>,\" [ \"<mon2>,...\" ] ]\n.RB command\n.br\n.SH DESCRIPTION\n\\fBcpupower-monitor \\fP reports processor topology, frequency and idle power\nstate statistics. Either \\fBcommand\\fP is forked and\nstatistics are printed upon its completion, or statistics are printed periodically.\n\n\\fBcpupower-monitor \\fP implements independent processor sleep state and\nfrequency counters. Some are retrieved from kernel statistics, some are\ndirectly reading out hardware registers. Use \\-l to get an overview which are\nsupported on your system.\n\n.SH Options\n.PP\n\\-l\n.RS 4\nList available monitors on your system. Additional details about each monitor\nare shown:\n.RS 2\n.IP \\(bu\nThe name in quotation marks which can be passed to the \\-m parameter.\n.IP \\(bu\nThe number of different counters the monitor supports in brackets.\n.IP \\(bu\nThe amount of time in seconds the counters might overflow, due to\nimplementation constraints.\n.IP \\(bu\nThe name and a description of each counter and its processor hierarchy level\ncoverage in square brackets:\n.RS 4\n.IP \\(bu\n[T] \\-> Thread\n.IP \\(bu\n[C] \\-> Core\n.IP \\(bu\n[P] \\-> Processor Package (Socket)\n.IP \\(bu\n[M] \\-> Machine/Platform wide counter\n.RE\n.RE\n.RE\n.PP\n\\-m <mon1>,<mon2>,...\n.RS 4\nOnly display specific monitors. Use the monitor string(s) provided by \\-l option.\n.RE\n.PP\n\\-i seconds\n.RS 4\nMeasure interval.\n.RE\n.PP\n\\-c\n.RS 4\nSchedule the process on every core before starting and ending measuring.\nThis could be needed for the Idle_Stats monitor when no other MSR based\nmonitor (has to be run on the core that is measured) is run in parallel.\nThis is to wake up the processors from deeper sleep states and let the\nkernel re\n-account its cpuidle (C-state) information before reading the\ncpuidle timings from sysfs.\n.RE\n.PP\ncommand\n.RS 4\nMeasure idle and frequency characteristics of an arbitrary command/workload.\nThe executable \\fBcommand\\fP is forked and upon its exit, statistics gathered since it was\nforked are displayed.\n.RE\n.PP\n\\-v\n.RS 4\nIncrease verbosity if the binary was compiled with the DEBUG option set.\n.RE\n\n.SH MONITOR DESCRIPTIONS\n.SS \"Idle_Stats\"\nShows statistics of the cpuidle kernel subsystem. Values are retrieved from\n/sys/devices/system/cpu/cpu*/cpuidle/state*/.\nThe kernel updates these values every time an idle state is entered or\nleft. Therefore there can be some inaccuracy when cores are in an idle\nstate for some time when the measure starts or ends. In worst case it can happen\nthat one core stayed in an idle state for the whole measure time and the idle\nstate usage time as exported by the kernel did not get updated. In this case\na state residency of 0 percent is shown while it was 100.\n\n.SS \"Mperf\"\nThe name comes from the aperf/mperf (average and maximum) MSR registers used\nwhich are available on recent X86 processors. It shows the average frequency\n(including boost frequencies).\nThe fact that on all recent hardware the mperf timer stops ticking in any idle\nstate it is also used to show C0 (processor is active) and Cx (processor is in\nany sleep state) times. These counters do not have the inaccuracy restrictions\nthe \"Idle_Stats\" counters may show.\nMay work poorly on Linux-2.6.20 through 2.6.29, as the \\fBacpi-cpufreq \\fP\nkernel frequency driver periodically cleared aperf/mperf registers in those\nkernels.\n\n.SS \"Nehalem\" \"SandyBridge\" \"HaswellExtended\"\nIntel Core and Package sleep state counters.\nThreads (hyperthreaded cores) may not be able to enter deeper core states if\nits sibling is utilized.\nDeepest package sleep states may in reality show up as machine/platform wide\nsleep states and can only be entered if all cores are idle. Look up Intel\nmanuals (some are provided in the References section) for further details.\nThe monitors are named after the CPU family where the sleep state capabilities\ngot introduced and may not match exactly the CPU name of the platform.\nFor example an IvyBridge processor has sleep state capabilities which got\nintroduced in Nehalem and SandyBridge processor families.\nThus on an IvyBridge processor one will get Nehalem and SandyBridge sleep\nstate monitors.\nHaswellExtended extra package sleep state capabilities are available only in a\nspecific Haswell (family 0x45) and probably also other future processors.\n\n.SS \"Fam_12h\" \"Fam_14h\"\nAMD laptop and desktop processor (family 12h and 14h) sleep state counters.\nThe registers are accessed via PCI and therefore can still be read out while\ncores have been offlined.\n\nThere is one special counter: NBP1 (North Bridge P1).\nThis one always returns 0 or 1, depending on whether the North Bridge P1\npower state got entered at least once during measure time.\nBeing able to enter NBP1 state also depends on graphics power management.\nTherefore this counter can be used to verify whether the graphics' driver\npower management is working as expected.\n\n.SH EXAMPLES\n\ncpupower monitor -l\" may show:\n.RS 4\nMonitor \"Mperf\" (3 states) \\- Might overflow after 922000000 s\n\n   ...\n\nMonitor \"Idle_Stats\" (3 states) \\- Might overflow after 4294967295 s\n\n   ...\n\n.RE\ncpupower monitor \\-m \"Idle_Stats,Mperf\" scp /tmp/test /nfs/tmp\n\nMonitor the scp command, show both Mperf and Idle_Stats states counter\nstatistics, but in exchanged order.\n\n\n\n.RE\nBe careful that the typical command to fully utilize one CPU by doing:\n\ncpupower monitor cat /dev/zero >/dev/null\n\nDoes not work as expected, because the measured output is redirected to\n/dev/null. This could get workarounded by putting the line into an own, tiny\nshell script. Hit CTRL\\-c to terminate the command and get the measure output\ndisplayed.\n\n.SH REFERENCES\n\"BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 14h Processors\"\nhttps://support.amd.com/us/Processor_TechDocs/43170.pdf\n\n\"Intel\u00ae Turbo Boost Technology\nin Intel\u00ae Core\u2122 Microarchitecture (Nehalem) Based Processors\"\nhttp://download.intel.com/design/processor/applnots/320354.pdf\n\n\"Intel\u00ae 64 and IA-32 Architectures Software Developer's Manual\nVolume 3B: System Programming Guide\"\nhttps://www.intel.com/products/processor/manuals\n\n.SH FILES\n.ta\n.nf\n/dev/cpu/*/msr\n/sys/devices/system/cpu/cpu*/cpuidle/state*/.\n.fi\n\n.SH \"SEE ALSO\"\npowertop(8), msr(4), vmstat(8)\n.PP\n.SH AUTHORS\n.nf\nWritten by Thomas Renninger <trenn@suse.de>\n\nNehalem, SandyBridge monitors and command passing\nbased on turbostat.8 from Len Brown <len.brown@intel.com>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}