{
  "module_name": "acpidbg.c",
  "hash_id": "d15ec76f86f110c878b9a7f9d0c03a5e35550e212356358cf44e81cccc00a2f5",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/acpi/tools/acpidbg/acpidbg.c",
  "human_readable_source": "\n \n\n#include <acpi/acpi.h>\n\n \n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <error.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <sys/select.h>\n#include \"../../../../../include/linux/circ_buf.h\"\n\n#define ACPI_AML_FILE\t\t\"/sys/kernel/debug/acpi/acpidbg\"\n#define ACPI_AML_SEC_TICK\t1\n#define ACPI_AML_USEC_PEEK\t200\n#define ACPI_AML_BUF_SIZE\t4096\n\n#define ACPI_AML_BATCH_WRITE_CMD\t0x00  \n#define ACPI_AML_BATCH_READ_LOG\t\t0x01  \n#define ACPI_AML_BATCH_WRITE_LOG\t0x02  \n\n#define ACPI_AML_LOG_START\t\t0x00\n#define ACPI_AML_PROMPT_START\t\t0x01\n#define ACPI_AML_PROMPT_STOP\t\t0x02\n#define ACPI_AML_LOG_STOP\t\t0x03\n#define ACPI_AML_PROMPT_ROLL\t\t0x04\n\n#define ACPI_AML_INTERACTIVE\t0x00\n#define ACPI_AML_BATCH\t\t0x01\n\n#define circ_count(circ) \\\n\t(CIRC_CNT((circ)->head, (circ)->tail, ACPI_AML_BUF_SIZE))\n#define circ_count_to_end(circ) \\\n\t(CIRC_CNT_TO_END((circ)->head, (circ)->tail, ACPI_AML_BUF_SIZE))\n#define circ_space(circ) \\\n\t(CIRC_SPACE((circ)->head, (circ)->tail, ACPI_AML_BUF_SIZE))\n#define circ_space_to_end(circ) \\\n\t(CIRC_SPACE_TO_END((circ)->head, (circ)->tail, ACPI_AML_BUF_SIZE))\n\n#define acpi_aml_cmd_count()\tcirc_count(&acpi_aml_cmd_crc)\n#define acpi_aml_log_count()\tcirc_count(&acpi_aml_log_crc)\n#define acpi_aml_cmd_space()\tcirc_space(&acpi_aml_cmd_crc)\n#define acpi_aml_log_space()\tcirc_space(&acpi_aml_log_crc)\n\n#define ACPI_AML_DO(_fd, _op, _buf, _ret)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t_ret = acpi_aml_##_op(_fd, &acpi_aml_##_buf##_crc);\t\\\n\t\tif (_ret == 0) {\t\t\t\t\t\\\n\t\t\tfprintf(stderr,\t\t\t\t\t\\\n\t\t\t\t\"%s %s pipe closed.\\n\", #_buf, #_op);\t\\\n\t\t\treturn;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n#define ACPI_AML_BATCH_DO(_fd, _op, _buf, _ret)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t_ret = acpi_aml_##_op##_batch_##_buf(_fd,\t\t\\\n\t\t\t &acpi_aml_##_buf##_crc);\t\t\t\\\n\t\tif (_ret == 0)\t\t\t\t\t\t\\\n\t\t\treturn;\t\t\t\t\t\t\\\n\t} while (0)\n\n\nstatic char acpi_aml_cmd_buf[ACPI_AML_BUF_SIZE];\nstatic char acpi_aml_log_buf[ACPI_AML_BUF_SIZE];\nstatic struct circ_buf acpi_aml_cmd_crc = {\n\t.buf = acpi_aml_cmd_buf,\n\t.head = 0,\n\t.tail = 0,\n};\nstatic struct circ_buf acpi_aml_log_crc = {\n\t.buf = acpi_aml_log_buf,\n\t.head = 0,\n\t.tail = 0,\n};\nstatic const char *acpi_aml_file_path = ACPI_AML_FILE;\nstatic unsigned long acpi_aml_mode = ACPI_AML_INTERACTIVE;\nstatic bool acpi_aml_exit;\n\nstatic bool acpi_aml_batch_drain;\nstatic unsigned long acpi_aml_batch_state;\nstatic char acpi_aml_batch_prompt;\nstatic char acpi_aml_batch_roll;\nstatic unsigned long acpi_aml_log_state;\nstatic char *acpi_aml_batch_cmd = NULL;\nstatic char *acpi_aml_batch_pos = NULL;\n\nstatic int acpi_aml_set_fl(int fd, int flags)\n{\n\tint ret;\n\n\tret = fcntl(fd, F_GETFL, 0);\n\tif (ret < 0) {\n\t\tperror(\"fcntl(F_GETFL)\");\n\t\treturn ret;\n\t}\n\tflags |= ret;\n\tret = fcntl(fd, F_SETFL, flags);\n\tif (ret < 0) {\n\t\tperror(\"fcntl(F_SETFL)\");\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic int acpi_aml_set_fd(int fd, int maxfd, fd_set *set)\n{\n\tif (fd > maxfd)\n\t\tmaxfd = fd;\n\tFD_SET(fd, set);\n\treturn maxfd;\n}\n\nstatic int acpi_aml_read(int fd, struct circ_buf *crc)\n{\n\tchar *p;\n\tint len;\n\n\tp = &crc->buf[crc->head];\n\tlen = circ_space_to_end(crc);\n\tlen = read(fd, p, len);\n\tif (len < 0)\n\t\tperror(\"read\");\n\telse if (len > 0)\n\t\tcrc->head = (crc->head + len) & (ACPI_AML_BUF_SIZE - 1);\n\treturn len;\n}\n\nstatic int acpi_aml_read_batch_cmd(int unused, struct circ_buf *crc)\n{\n\tchar *p;\n\tint len;\n\tint remained = strlen(acpi_aml_batch_pos);\n\n\tp = &crc->buf[crc->head];\n\tlen = circ_space_to_end(crc);\n\tif (len > remained) {\n\t\tmemcpy(p, acpi_aml_batch_pos, remained);\n\t\tacpi_aml_batch_pos += remained;\n\t\tlen = remained;\n\t} else {\n\t\tmemcpy(p, acpi_aml_batch_pos, len);\n\t\tacpi_aml_batch_pos += len;\n\t}\n\tif (len > 0)\n\t\tcrc->head = (crc->head + len) & (ACPI_AML_BUF_SIZE - 1);\n\treturn len;\n}\n\nstatic int acpi_aml_read_batch_log(int fd, struct circ_buf *crc)\n{\n\tchar *p;\n\tint len;\n\tint ret = 0;\n\n\tp = &crc->buf[crc->head];\n\tlen = circ_space_to_end(crc);\n\twhile (ret < len && acpi_aml_log_state != ACPI_AML_LOG_STOP) {\n\t\tif (acpi_aml_log_state == ACPI_AML_PROMPT_ROLL) {\n\t\t\t*p = acpi_aml_batch_roll;\n\t\t\tlen = 1;\n\t\t\tcrc->head = (crc->head + 1) & (ACPI_AML_BUF_SIZE - 1);\n\t\t\tret += 1;\n\t\t\tacpi_aml_log_state = ACPI_AML_LOG_START;\n\t\t} else {\n\t\t\tlen = read(fd, p, 1);\n\t\t\tif (len <= 0) {\n\t\t\t\tif (len < 0)\n\t\t\t\t\tperror(\"read\");\n\t\t\t\tret = len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch (acpi_aml_log_state) {\n\t\tcase ACPI_AML_LOG_START:\n\t\t\tif (*p == '\\n')\n\t\t\t\tacpi_aml_log_state = ACPI_AML_PROMPT_START;\n\t\t\tcrc->head = (crc->head + 1) & (ACPI_AML_BUF_SIZE - 1);\n\t\t\tret += 1;\n\t\t\tbreak;\n\t\tcase ACPI_AML_PROMPT_START:\n\t\t\tif (*p == ACPI_DEBUGGER_COMMAND_PROMPT ||\n\t\t\t    *p == ACPI_DEBUGGER_EXECUTE_PROMPT) {\n\t\t\t\tacpi_aml_batch_prompt = *p;\n\t\t\t\tacpi_aml_log_state = ACPI_AML_PROMPT_STOP;\n\t\t\t} else {\n\t\t\t\tif (*p != '\\n')\n\t\t\t\t\tacpi_aml_log_state = ACPI_AML_LOG_START;\n\t\t\t\tcrc->head = (crc->head + 1) & (ACPI_AML_BUF_SIZE - 1);\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACPI_AML_PROMPT_STOP:\n\t\t\tif (*p == ' ') {\n\t\t\t\tacpi_aml_log_state = ACPI_AML_LOG_STOP;\n\t\t\t\tacpi_aml_exit = true;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tacpi_aml_log_state = ACPI_AML_PROMPT_ROLL;\n\t\t\t\tacpi_aml_batch_roll = *p;\n\t\t\t\t*p = acpi_aml_batch_prompt;\n\t\t\t\tcrc->head = (crc->head + 1) & (ACPI_AML_BUF_SIZE - 1);\n\t\t\t\tret += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int acpi_aml_write(int fd, struct circ_buf *crc)\n{\n\tchar *p;\n\tint len;\n\n\tp = &crc->buf[crc->tail];\n\tlen = circ_count_to_end(crc);\n\tlen = write(fd, p, len);\n\tif (len < 0)\n\t\tperror(\"write\");\n\telse if (len > 0)\n\t\tcrc->tail = (crc->tail + len) & (ACPI_AML_BUF_SIZE - 1);\n\treturn len;\n}\n\nstatic int acpi_aml_write_batch_log(int fd, struct circ_buf *crc)\n{\n\tchar *p;\n\tint len;\n\n\tp = &crc->buf[crc->tail];\n\tlen = circ_count_to_end(crc);\n\tif (!acpi_aml_batch_drain) {\n\t\tlen = write(fd, p, len);\n\t\tif (len < 0)\n\t\t\tperror(\"write\");\n\t}\n\tif (len > 0)\n\t\tcrc->tail = (crc->tail + len) & (ACPI_AML_BUF_SIZE - 1);\n\treturn len;\n}\n\nstatic int acpi_aml_write_batch_cmd(int fd, struct circ_buf *crc)\n{\n\tint len;\n\n\tlen = acpi_aml_write(fd, crc);\n\tif (circ_count_to_end(crc) == 0)\n\t\tacpi_aml_batch_state = ACPI_AML_BATCH_READ_LOG;\n\treturn len;\n}\n\nstatic void acpi_aml_loop(int fd)\n{\n\tfd_set rfds;\n\tfd_set wfds;\n\tstruct timeval tv;\n\tint ret;\n\tint maxfd = 0;\n\n\tif (acpi_aml_mode == ACPI_AML_BATCH) {\n\t\tacpi_aml_log_state = ACPI_AML_LOG_START;\n\t\tacpi_aml_batch_pos = acpi_aml_batch_cmd;\n\t\tif (acpi_aml_batch_drain)\n\t\t\tacpi_aml_batch_state = ACPI_AML_BATCH_READ_LOG;\n\t\telse\n\t\t\tacpi_aml_batch_state = ACPI_AML_BATCH_WRITE_CMD;\n\t}\n\tacpi_aml_exit = false;\n\twhile (!acpi_aml_exit) {\n\t\ttv.tv_sec = ACPI_AML_SEC_TICK;\n\t\ttv.tv_usec = 0;\n\t\tFD_ZERO(&rfds);\n\t\tFD_ZERO(&wfds);\n\n\t\tif (acpi_aml_cmd_space()) {\n\t\t\tif (acpi_aml_mode == ACPI_AML_INTERACTIVE)\n\t\t\t\tmaxfd = acpi_aml_set_fd(STDIN_FILENO, maxfd, &rfds);\n\t\t\telse if (strlen(acpi_aml_batch_pos) &&\n\t\t\t\t acpi_aml_batch_state == ACPI_AML_BATCH_WRITE_CMD)\n\t\t\t\tACPI_AML_BATCH_DO(STDIN_FILENO, read, cmd, ret);\n\t\t}\n\t\tif (acpi_aml_cmd_count() &&\n\t\t    (acpi_aml_mode == ACPI_AML_INTERACTIVE ||\n\t\t     acpi_aml_batch_state == ACPI_AML_BATCH_WRITE_CMD))\n\t\t\tmaxfd = acpi_aml_set_fd(fd, maxfd, &wfds);\n\t\tif (acpi_aml_log_space() &&\n\t\t    (acpi_aml_mode == ACPI_AML_INTERACTIVE ||\n\t\t     acpi_aml_batch_state == ACPI_AML_BATCH_READ_LOG))\n\t\t\tmaxfd = acpi_aml_set_fd(fd, maxfd, &rfds);\n\t\tif (acpi_aml_log_count())\n\t\t\tmaxfd = acpi_aml_set_fd(STDOUT_FILENO, maxfd, &wfds);\n\n\t\tret = select(maxfd+1, &rfds, &wfds, NULL, &tv);\n\t\tif (ret < 0) {\n\t\t\tperror(\"select\");\n\t\t\tbreak;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (FD_ISSET(STDIN_FILENO, &rfds))\n\t\t\t\tACPI_AML_DO(STDIN_FILENO, read, cmd, ret);\n\t\t\tif (FD_ISSET(fd, &wfds)) {\n\t\t\t\tif (acpi_aml_mode == ACPI_AML_BATCH)\n\t\t\t\t\tACPI_AML_BATCH_DO(fd, write, cmd, ret);\n\t\t\t\telse\n\t\t\t\t\tACPI_AML_DO(fd, write, cmd, ret);\n\t\t\t}\n\t\t\tif (FD_ISSET(fd, &rfds)) {\n\t\t\t\tif (acpi_aml_mode == ACPI_AML_BATCH)\n\t\t\t\t\tACPI_AML_BATCH_DO(fd, read, log, ret);\n\t\t\t\telse\n\t\t\t\t\tACPI_AML_DO(fd, read, log, ret);\n\t\t\t}\n\t\t\tif (FD_ISSET(STDOUT_FILENO, &wfds)) {\n\t\t\t\tif (acpi_aml_mode == ACPI_AML_BATCH)\n\t\t\t\t\tACPI_AML_BATCH_DO(STDOUT_FILENO, write, log, ret);\n\t\t\t\telse\n\t\t\t\t\tACPI_AML_DO(STDOUT_FILENO, write, log, ret);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool acpi_aml_readable(int fd)\n{\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint ret;\n\tint maxfd = 0;\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = ACPI_AML_USEC_PEEK;\n\tFD_ZERO(&rfds);\n\tmaxfd = acpi_aml_set_fd(fd, maxfd, &rfds);\n\tret = select(maxfd+1, &rfds, NULL, NULL, &tv);\n\tif (ret < 0)\n\t\tperror(\"select\");\n\tif (ret > 0 && FD_ISSET(fd, &rfds))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic void acpi_aml_flush(int fd)\n{\n\twhile (acpi_aml_readable(fd)) {\n\t\tacpi_aml_batch_drain = true;\n\t\tacpi_aml_loop(fd);\n\t\tacpi_aml_batch_drain = false;\n\t}\n}\n\nvoid usage(FILE *file, char *progname)\n{\n\tfprintf(file, \"usage: %s [-b cmd] [-f file] [-h]\\n\", progname);\n\tfprintf(file, \"\\nOptions:\\n\");\n\tfprintf(file, \"  -b     Specify command to be executed in batch mode\\n\");\n\tfprintf(file, \"  -f     Specify interface file other than\");\n\tfprintf(file, \"         /sys/kernel/debug/acpi/acpidbg\\n\");\n\tfprintf(file, \"  -h     Print this help message\\n\");\n}\n\nint main(int argc, char **argv)\n{\n\tint fd = -1;\n\tint ch;\n\tint len;\n\tint ret = EXIT_SUCCESS;\n\n\twhile ((ch = getopt(argc, argv, \"b:f:h\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'b':\n\t\t\tif (acpi_aml_batch_cmd) {\n\t\t\t\tfprintf(stderr, \"Already specify %s\\n\",\n\t\t\t\t\tacpi_aml_batch_cmd);\n\t\t\t\tret = EXIT_FAILURE;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tlen = strlen(optarg);\n\t\t\tacpi_aml_batch_cmd = calloc(len + 2, 1);\n\t\t\tif (!acpi_aml_batch_cmd) {\n\t\t\t\tperror(\"calloc\");\n\t\t\t\tret = EXIT_FAILURE;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tmemcpy(acpi_aml_batch_cmd, optarg, len);\n\t\t\tacpi_aml_batch_cmd[len] = '\\n';\n\t\t\tacpi_aml_mode = ACPI_AML_BATCH;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tacpi_aml_file_path = optarg;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout, argv[0]);\n\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage(stderr, argv[0]);\n\t\t\tret = EXIT_FAILURE;\n\t\t\tgoto exit;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfd = open(acpi_aml_file_path, O_RDWR | O_NONBLOCK);\n\tif (fd < 0) {\n\t\tperror(\"open\");\n\t\tret = EXIT_FAILURE;\n\t\tgoto exit;\n\t}\n\tacpi_aml_set_fl(STDIN_FILENO, O_NONBLOCK);\n\tacpi_aml_set_fl(STDOUT_FILENO, O_NONBLOCK);\n\n\tif (acpi_aml_mode == ACPI_AML_BATCH)\n\t\tacpi_aml_flush(fd);\n\tacpi_aml_loop(fd);\n\nexit:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (acpi_aml_batch_cmd)\n\t\tfree(acpi_aml_batch_cmd);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}