{
  "module_name": "ec_access.c",
  "hash_id": "17fcd308d0af1e37d3f95b43e56fcedefdc7f4aea7619294124c0a66e45d17bf",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/acpi/tools/ec/ec_access.c",
  "human_readable_source": "\n \n\n#include <fcntl.h>\n#include <err.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n\n#define EC_SPACE_SIZE 256\n#define SYSFS_PATH \"/sys/kernel/debug/ec/ec0/io\"\n\n \n\nstatic int read_mode = -1;\nstatic int sleep_time;\nstatic int write_byte_offset = -1;\nstatic int read_byte_offset = -1;\nstatic uint8_t write_value = -1;\n\nvoid usage(char progname[], int exit_status)\n{\n\tprintf(\"Usage:\\n\");\n\tprintf(\"1) %s -r [-s sleep]\\n\", basename(progname));\n\tprintf(\"2) %s -b byte_offset\\n\", basename(progname));\n\tprintf(\"3) %s -w byte_offset -v value\\n\\n\", basename(progname));\n\n\tputs(\"\\t-r [-s sleep]      : Dump EC registers\");\n\tputs(\"\\t                     If sleep is given, sleep x seconds,\");\n\tputs(\"\\t                     re-read EC registers and show changes\");\n\tputs(\"\\t-b offset          : Read value at byte_offset (in hex)\");\n\tputs(\"\\t-w offset -v value : Write value at byte_offset\");\n\tputs(\"\\t-h                 : Print this help\\n\\n\");\n\tputs(\"Offsets and values are in hexadecimal number system.\");\n\tputs(\"The offset and value must be between 0 and 0xff.\");\n\texit(exit_status);\n}\n\nvoid parse_opts(int argc, char *argv[])\n{\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"rs:b:w:v:h\")) != -1) {\n\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\tif (read_mode != -1)\n\t\t\t\tusage(argv[0], EXIT_FAILURE);\n\t\t\tread_mode = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (read_mode != -1 && read_mode != 1)\n\t\t\t\tusage(argv[0], EXIT_FAILURE);\n\n\t\t\tsleep_time = atoi(optarg);\n\t\t\tif (sleep_time <= 0) {\n\t\t\t\tsleep_time = 0;\n\t\t\t\tusage(argv[0], EXIT_FAILURE);\n\t\t\t\tprintf(\"Bad sleep time: %s\\n\", optarg);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (read_mode != -1)\n\t\t\t\tusage(argv[0], EXIT_FAILURE);\n\t\t\tread_mode = 1;\n\t\t\tread_byte_offset = strtoul(optarg, NULL, 16);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (read_mode != -1)\n\t\t\t\tusage(argv[0], EXIT_FAILURE);\n\t\t\tread_mode = 0;\n\t\t\twrite_byte_offset = strtoul(optarg, NULL, 16);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\twrite_value = strtoul(optarg, NULL, 16);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0], EXIT_SUCCESS);\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option!\\n\");\n\t\t\tusage(argv[0], EXIT_FAILURE);\n\t\t}\n\t}\n\tif (read_mode == 0) {\n\t\tif (write_byte_offset < 0 ||\n\t\t    write_byte_offset >= EC_SPACE_SIZE) {\n\t\t\tfprintf(stderr, \"Wrong byte offset 0x%.2x, valid: \"\n\t\t\t\t\"[0-0x%.2x]\\n\",\n\t\t\t\twrite_byte_offset, EC_SPACE_SIZE - 1);\n\t\t\tusage(argv[0], EXIT_FAILURE);\n\t\t}\n\t\tif (write_value < 0 ||\n\t\t    write_value >= 255) {\n\t\t\tfprintf(stderr, \"Wrong byte offset 0x%.2x, valid:\"\n\t\t\t\t\"[0-0xff]\\n\", write_byte_offset);\n\t\t\tusage(argv[0], EXIT_FAILURE);\n\t\t}\n\t}\n\tif (read_mode == 1 && read_byte_offset != -1) {\n\t\tif (read_byte_offset < -1 ||\n\t\t    read_byte_offset >= EC_SPACE_SIZE) {\n\t\t\tfprintf(stderr, \"Wrong byte offset 0x%.2x, valid: \"\n\t\t\t\t\"[0-0x%.2x]\\n\",\n\t\t\t\tread_byte_offset, EC_SPACE_SIZE - 1);\n\t\t\tusage(argv[0], EXIT_FAILURE);\n\t\t}\n\t}\n\t \n}\n\nvoid dump_ec(int fd)\n{\n\tchar buf[EC_SPACE_SIZE];\n\tchar buf2[EC_SPACE_SIZE];\n\tint byte_off, bytes_read;\n\n\tbytes_read = read(fd, buf, EC_SPACE_SIZE);\n\n\tif (bytes_read == -1)\n\t\terr(EXIT_FAILURE, \"Could not read from %s\\n\", SYSFS_PATH);\n\n\tif (bytes_read != EC_SPACE_SIZE)\n\t\tfprintf(stderr, \"Could only read %d bytes\\n\", bytes_read);\n\n\tprintf(\"     00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F\");\n\tfor (byte_off = 0; byte_off < bytes_read; byte_off++) {\n\t\tif ((byte_off % 16) == 0)\n\t\t\tprintf(\"\\n%.2X: \", byte_off);\n\t\tprintf(\" %.2x \", (uint8_t)buf[byte_off]);\n\t}\n\tprintf(\"\\n\");\n\n\tif (!sleep_time)\n\t\treturn;\n\n\tprintf(\"\\n\");\n\tlseek(fd, 0, SEEK_SET);\n\tsleep(sleep_time);\n\n\tbytes_read = read(fd, buf2, EC_SPACE_SIZE);\n\n\tif (bytes_read == -1)\n\t\terr(EXIT_FAILURE, \"Could not read from %s\\n\", SYSFS_PATH);\n\n\tif (bytes_read != EC_SPACE_SIZE)\n\t\tfprintf(stderr, \"Could only read %d bytes\\n\", bytes_read);\n\n\tprintf(\"     00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F\");\n\tfor (byte_off = 0; byte_off < bytes_read; byte_off++) {\n\t\tif ((byte_off % 16) == 0)\n\t\t\tprintf(\"\\n%.2X: \", byte_off);\n\n\t\tif (buf[byte_off] == buf2[byte_off])\n\t\t\tprintf(\" %.2x \", (uint8_t)buf2[byte_off]);\n\t\telse\n\t\t\tprintf(\"*%.2x \", (uint8_t)buf2[byte_off]);\n\t}\n\tprintf(\"\\n\");\n}\n\nvoid read_ec_val(int fd, int byte_offset)\n{\n\tuint8_t buf;\n\tint error;\n\n\terror = lseek(fd, byte_offset, SEEK_SET);\n\tif (error != byte_offset)\n\t\terr(EXIT_FAILURE, \"Cannot set offset to 0x%.2x\", byte_offset);\n\n\terror = read(fd, &buf, 1);\n\tif (error != 1)\n\t\terr(EXIT_FAILURE, \"Could not read byte 0x%.2x from %s\\n\",\n\t\t    byte_offset, SYSFS_PATH);\n\tprintf(\"0x%.2x\\n\", buf);\n\treturn;\n}\n\nvoid write_ec_val(int fd, int byte_offset, uint8_t value)\n{\n\tint error;\n\n\terror = lseek(fd, byte_offset, SEEK_SET);\n\tif (error != byte_offset)\n\t\terr(EXIT_FAILURE, \"Cannot set offset to 0x%.2x\", byte_offset);\n\n\terror = write(fd, &value, 1);\n\tif (error != 1)\n\t\terr(EXIT_FAILURE, \"Cannot write value 0x%.2x to offset 0x%.2x\",\n\t\t    value, byte_offset);\n}\n\nint main(int argc, char *argv[])\n{\n\tint file_mode = O_RDONLY;\n\tint fd;\n\n\tparse_opts(argc, argv);\n\n\tif (read_mode == 0)\n\t\tfile_mode = O_WRONLY;\n\telse if (read_mode == 1)\n\t\tfile_mode = O_RDONLY;\n\telse\n\t\tusage(argv[0], EXIT_FAILURE);\n\n\tfd = open(SYSFS_PATH, file_mode);\n\tif (fd == -1)\n\t\terr(EXIT_FAILURE, \"%s\", SYSFS_PATH);\n\n\tif (read_mode)\n\t\tif (read_byte_offset == -1)\n\t\t\tdump_ec(fd);\n\t\telse if (read_byte_offset < 0 ||\n\t\t\t read_byte_offset >= EC_SPACE_SIZE)\n\t\t\tusage(argv[0], EXIT_FAILURE);\n\t\telse\n\t\t\tread_ec_val(fd, read_byte_offset);\n\telse\n\t\twrite_ec_val(fd, write_byte_offset, write_value);\n\tclose(fd);\n\n\texit(EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}