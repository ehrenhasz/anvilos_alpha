{
  "module_name": "pfrut.c",
  "hash_id": "a215b0d3342d6fcaaeb6e29015eeaea1fb09887535f495f89363302d271d4426",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/acpi/tools/pfrut/pfrut.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <uuid/uuid.h>\n#include PFRUT_HEADER\n\nchar *capsule_name;\nint action, query_cap, log_type, log_level, log_read, log_getinfo,\n\trevid, log_revid;\nint set_log_level, set_log_type,\n\tset_revid, set_log_revid;\n\nchar *progname;\n\n#define LOG_ERR\t\t0\n#define LOG_WARN\t1\n#define LOG_INFO\t2\n#define LOG_VERB\t4\n#define LOG_EXEC_IDX\t0\n#define LOG_HISTORY_IDX\t1\n#define REVID_1\t\t1\n#define REVID_2\t\t2\n\nstatic int valid_log_level(int level)\n{\n\treturn level == LOG_ERR || level == LOG_WARN ||\n\t       level == LOG_INFO || level == LOG_VERB;\n}\n\nstatic int valid_log_type(int type)\n{\n\treturn type == LOG_EXEC_IDX || type == LOG_HISTORY_IDX;\n}\n\nstatic inline int valid_log_revid(int id)\n{\n\treturn id == REVID_1 || id == REVID_2;\n}\n\nstatic void help(void)\n{\n\tfprintf(stderr,\n\t\t\"usage: %s [OPTIONS]\\n\"\n\t\t\" code injection:\\n\"\n\t\t\"  -l, --load\\n\"\n\t\t\"  -s, --stage\\n\"\n\t\t\"  -a, --activate\\n\"\n\t\t\"  -u, --update [stage and activate]\\n\"\n\t\t\"  -q, --query\\n\"\n\t\t\"  -d, --revid update\\n\"\n\t\t\" telemetry:\\n\"\n\t\t\"  -G, --getloginfo\\n\"\n\t\t\"  -T, --type(0:execution, 1:history)\\n\"\n\t\t\"  -L, --level(0, 1, 2, 4)\\n\"\n\t\t\"  -R, --read\\n\"\n\t\t\"  -D, --revid log\\n\",\n\t\tprogname);\n}\n\nchar *option_string = \"l:sauqd:GT:L:RD:h\";\nstatic struct option long_options[] = {\n\t{\"load\", required_argument, 0, 'l'},\n\t{\"stage\", no_argument, 0, 's'},\n\t{\"activate\", no_argument, 0, 'a'},\n\t{\"update\", no_argument, 0, 'u'},\n\t{\"query\", no_argument, 0, 'q'},\n\t{\"getloginfo\", no_argument, 0, 'G'},\n\t{\"type\", required_argument, 0, 'T'},\n\t{\"level\", required_argument, 0, 'L'},\n\t{\"read\", no_argument, 0, 'R'},\n\t{\"setrev\", required_argument, 0, 'd'},\n\t{\"setrevlog\", required_argument, 0, 'D'},\n\t{\"help\", no_argument, 0, 'h'},\n\t{}\n};\n\nstatic void parse_options(int argc, char **argv)\n{\n\tint option_index = 0;\n\tchar *pathname, *endptr;\n\tint opt;\n\n\tpathname = strdup(argv[0]);\n\tprogname = basename(pathname);\n\n\twhile ((opt = getopt_long_only(argc, argv, option_string,\n\t\t\t\t       long_options, &option_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'l':\n\t\t\tcapsule_name = optarg;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\taction = 1;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\taction = 2;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\taction = 3;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tquery_cap = 1;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tlog_getinfo = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tlog_type = strtol(optarg, &endptr, 0);\n\t\t\tif (*endptr || (log_type != 0 && log_type != 1)) {\n\t\t\t\tprintf(\"Number expected: type(0:execution, 1:history) - Quit.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tset_log_type = 1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tlog_level = strtol(optarg, &endptr, 0);\n\t\t\tif (*endptr ||\n\t\t\t    (log_level != 0 && log_level != 1 &&\n\t\t\t     log_level != 2 && log_level != 4)) {\n\t\t\t\tprintf(\"Number expected: level(0, 1, 2, 4) - Quit.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tset_log_level = 1;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tlog_read = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\trevid = atoi(optarg);\n\t\t\tset_revid = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tlog_revid = atoi(optarg);\n\t\t\tset_log_revid = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thelp();\n\t\t\texit(0);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid print_cap(struct pfru_update_cap_info *cap)\n{\n\tchar *uuid;\n\n\tuuid = malloc(37);\n\tif (!uuid) {\n\t\tperror(\"Can not allocate uuid buffer\\n\");\n\t\texit(1);\n\t}\n\n\tuuid_unparse(cap->code_type, uuid);\n\tprintf(\"code injection image type:%s\\n\", uuid);\n\tprintf(\"fw_version:%d\\n\", cap->fw_version);\n\tprintf(\"code_rt_version:%d\\n\", cap->code_rt_version);\n\n\tuuid_unparse(cap->drv_type, uuid);\n\tprintf(\"driver update image type:%s\\n\", uuid);\n\tprintf(\"drv_rt_version:%d\\n\", cap->drv_rt_version);\n\tprintf(\"drv_svn:%d\\n\", cap->drv_svn);\n\n\tuuid_unparse(cap->platform_id, uuid);\n\tprintf(\"platform id:%s\\n\", uuid);\n\tuuid_unparse(cap->oem_id, uuid);\n\tprintf(\"oem id:%s\\n\", uuid);\n\tprintf(\"oem information length:%d\\n\", cap->oem_info_len);\n\n\tfree(uuid);\n}\n\nint main(int argc, char *argv[])\n{\n\tint fd_update, fd_update_log, fd_capsule;\n\tstruct pfrt_log_data_info data_info;\n\tstruct pfrt_log_info info;\n\tstruct pfru_update_cap_info cap;\n\tvoid *addr_map_capsule;\n\tstruct stat st;\n\tchar *log_buf;\n\tint ret;\n\n\tif (getuid() != 0) {\n\t\tprintf(\"Please run the tool as root - Exiting.\\n\");\n\t\treturn 1;\n\t}\n\n\tparse_options(argc, argv);\n\n\tfd_update = open(\"/dev/acpi_pfr_update0\", O_RDWR);\n\tif (fd_update < 0) {\n\t\tprintf(\"PFRU device not supported - Quit...\\n\");\n\t\treturn 1;\n\t}\n\n\tfd_update_log = open(\"/dev/acpi_pfr_telemetry0\", O_RDWR);\n\tif (fd_update_log < 0) {\n\t\tprintf(\"PFRT device not supported - Quit...\\n\");\n\t\treturn 1;\n\t}\n\n\tif (query_cap) {\n\t\tret = ioctl(fd_update, PFRU_IOC_QUERY_CAP, &cap);\n\t\tif (ret)\n\t\t\tperror(\"Query Update Capability info failed.\");\n\t\telse\n\t\t\tprint_cap(&cap);\n\n\t\tclose(fd_update);\n\t\tclose(fd_update_log);\n\n\t\treturn ret;\n\t}\n\n\tif (log_getinfo) {\n\t\tret = ioctl(fd_update_log, PFRT_LOG_IOC_GET_DATA_INFO, &data_info);\n\t\tif (ret) {\n\t\t\tperror(\"Get telemetry data info failed.\");\n\t\t\tclose(fd_update);\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tret = ioctl(fd_update_log, PFRT_LOG_IOC_GET_INFO, &info);\n\t\tif (ret) {\n\t\t\tperror(\"Get telemetry info failed.\");\n\t\t\tclose(fd_update);\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tprintf(\"log_level:%d\\n\", info.log_level);\n\t\tprintf(\"log_type:%d\\n\", info.log_type);\n\t\tprintf(\"log_revid:%d\\n\", info.log_revid);\n\t\tprintf(\"max_data_size:%d\\n\", data_info.max_data_size);\n\t\tprintf(\"chunk1_size:%d\\n\", data_info.chunk1_size);\n\t\tprintf(\"chunk2_size:%d\\n\", data_info.chunk2_size);\n\t\tprintf(\"rollover_cnt:%d\\n\", data_info.rollover_cnt);\n\t\tprintf(\"reset_cnt:%d\\n\", data_info.reset_cnt);\n\n\t\treturn 0;\n\t}\n\n\tinfo.log_level = -1;\n\tinfo.log_type = -1;\n\tinfo.log_revid = -1;\n\n\tif (set_log_level) {\n\t\tif (!valid_log_level(log_level)) {\n\t\t\tprintf(\"Invalid log level %d\\n\",\n\t\t\t       log_level);\n\t\t} else {\n\t\t\tinfo.log_level = log_level;\n\t\t}\n\t}\n\n\tif (set_log_type) {\n\t\tif (!valid_log_type(log_type)) {\n\t\t\tprintf(\"Invalid log type %d\\n\",\n\t\t\t       log_type);\n\t\t} else {\n\t\t\tinfo.log_type = log_type;\n\t\t}\n\t}\n\n\tif (set_log_revid) {\n\t\tif (!valid_log_revid(log_revid)) {\n\t\t\tprintf(\"Invalid log revid %d, unchanged.\\n\",\n\t\t\t       log_revid);\n\t\t} else {\n\t\t\tinfo.log_revid = log_revid;\n\t\t}\n\t}\n\n\tret = ioctl(fd_update_log, PFRT_LOG_IOC_SET_INFO, &info);\n\tif (ret) {\n\t\tperror(\"Log information set failed.(log_level, log_type, log_revid)\");\n\t\tclose(fd_update);\n\t\tclose(fd_update_log);\n\n\t\treturn 1;\n\t}\n\n\tif (set_revid) {\n\t\tret = ioctl(fd_update, PFRU_IOC_SET_REV, &revid);\n\t\tif (ret) {\n\t\t\tperror(\"pfru update revid set failed\");\n\t\t\tclose(fd_update);\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tprintf(\"pfru update revid set to %d\\n\", revid);\n\t}\n\n\tif (capsule_name) {\n\t\tfd_capsule = open(capsule_name, O_RDONLY);\n\t\tif (fd_capsule < 0) {\n\t\t\tperror(\"Can not open capsule file...\");\n\t\t\tclose(fd_update);\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (fstat(fd_capsule, &st) < 0) {\n\t\t\tperror(\"Can not fstat capsule file...\");\n\t\t\tclose(fd_capsule);\n\t\t\tclose(fd_update);\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\taddr_map_capsule = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED,\n\t\t\t\t\tfd_capsule, 0);\n\t\tif (addr_map_capsule == MAP_FAILED) {\n\t\t\tperror(\"Failed to mmap capsule file.\");\n\t\t\tclose(fd_capsule);\n\t\t\tclose(fd_update);\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tret = write(fd_update, (char *)addr_map_capsule, st.st_size);\n\t\tprintf(\"Load %d bytes of capsule file into the system\\n\",\n\t\t       ret);\n\n\t\tif (ret == -1) {\n\t\t\tperror(\"Failed to load capsule file\");\n\t\t\tclose(fd_capsule);\n\t\t\tclose(fd_update);\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tmunmap(addr_map_capsule, st.st_size);\n\t\tclose(fd_capsule);\n\t\tprintf(\"Load done.\\n\");\n\t}\n\n\tif (action) {\n\t\tif (action == 1) {\n\t\t\tret = ioctl(fd_update, PFRU_IOC_STAGE, NULL);\n\t\t} else if (action == 2) {\n\t\t\tret = ioctl(fd_update, PFRU_IOC_ACTIVATE, NULL);\n\t\t} else if (action == 3) {\n\t\t\tret = ioctl(fd_update, PFRU_IOC_STAGE_ACTIVATE, NULL);\n\t\t} else {\n\t\t\tclose(fd_update);\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\t\tprintf(\"Update finished, return %d\\n\", ret);\n\t}\n\n\tclose(fd_update);\n\n\tif (log_read) {\n\t\tvoid *p_mmap;\n\t\tint max_data_sz;\n\n\t\tret = ioctl(fd_update_log, PFRT_LOG_IOC_GET_DATA_INFO, &data_info);\n\t\tif (ret) {\n\t\t\tperror(\"Get telemetry data info failed.\");\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tmax_data_sz = data_info.max_data_size;\n\t\tif (!max_data_sz) {\n\t\t\tprintf(\"No telemetry data available.\\n\");\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tlog_buf = malloc(max_data_sz + 1);\n\t\tif (!log_buf) {\n\t\t\tperror(\"log_buf allocate failed.\");\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tp_mmap = mmap(NULL, max_data_sz, PROT_READ, MAP_SHARED, fd_update_log, 0);\n\t\tif (p_mmap == MAP_FAILED) {\n\t\t\tperror(\"mmap error.\");\n\t\t\tclose(fd_update_log);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tmemcpy(log_buf, p_mmap, max_data_sz);\n\t\tlog_buf[max_data_sz] = '\\0';\n\t\tprintf(\"%s\\n\", log_buf);\n\t\tfree(log_buf);\n\n\t\tmunmap(p_mmap, max_data_sz);\n\t}\n\n\tclose(fd_update_log);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}