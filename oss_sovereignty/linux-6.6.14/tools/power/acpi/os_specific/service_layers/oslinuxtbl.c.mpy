{
  "module_name": "oslinuxtbl.c",
  "hash_id": "de2bd3ee1ed1dba124a044066aa208dc3e16f73ff40160ad5b66fcb1850ab434",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/acpi/os_specific/service_layers/oslinuxtbl.c",
  "human_readable_source": "\n \n\n#include \"acpidump.h\"\n\n#define _COMPONENT          ACPI_OS_SERVICES\nACPI_MODULE_NAME(\"oslinuxtbl\")\n\n#ifndef PATH_MAX\n#define PATH_MAX 256\n#endif\n \ntypedef struct osl_table_info {\n\tstruct osl_table_info *next;\n\tu32 instance;\n\tchar signature[ACPI_NAMESEG_SIZE];\n\n} osl_table_info;\n\n \n\nstatic acpi_status osl_table_initialize(void);\n\nstatic acpi_status\nosl_table_name_from_file(char *filename, char *signature, u32 *instance);\n\nstatic acpi_status osl_add_table_to_list(char *signature, u32 instance);\n\nstatic acpi_status\nosl_read_table_from_file(char *filename,\n\t\t\t acpi_size file_offset,\n\t\t\t struct acpi_table_header **table);\n\nstatic acpi_status\nosl_map_table(acpi_size address,\n\t      char *signature, struct acpi_table_header **table);\n\nstatic void osl_unmap_table(struct acpi_table_header *table);\n\nstatic acpi_physical_address\nosl_find_rsdp_via_efi_by_keyword(FILE * file, const char *keyword);\n\nstatic acpi_physical_address osl_find_rsdp_via_efi(void);\n\nstatic acpi_status osl_load_rsdp(void);\n\nstatic acpi_status osl_list_customized_tables(char *directory);\n\nstatic acpi_status\nosl_get_customized_table(char *pathname,\n\t\t\t char *signature,\n\t\t\t u32 instance,\n\t\t\t struct acpi_table_header **table,\n\t\t\t acpi_physical_address *address);\n\nstatic acpi_status osl_list_bios_tables(void);\n\nstatic acpi_status\nosl_get_bios_table(char *signature,\n\t\t   u32 instance,\n\t\t   struct acpi_table_header **table,\n\t\t   acpi_physical_address *address);\n\nstatic acpi_status osl_get_last_status(acpi_status default_status);\n\n \n\n#define DYNAMIC_TABLE_DIR   \"/sys/firmware/acpi/tables/dynamic\"\n#define STATIC_TABLE_DIR    \"/sys/firmware/acpi/tables\"\n#define EFI_SYSTAB          \"/sys/firmware/efi/systab\"\n\n \n\nu8 gbl_dump_dynamic_tables = TRUE;\n\n \n\nu8 gbl_table_list_initialized = FALSE;\n\n \n\nstruct acpi_table_rsdp gbl_rsdp;\nstruct acpi_table_fadt *gbl_fadt = NULL;\nstruct acpi_table_rsdt *gbl_rsdt = NULL;\nstruct acpi_table_xsdt *gbl_xsdt = NULL;\n\n \n\nacpi_physical_address gbl_fadt_address = 0;\nacpi_physical_address gbl_rsdp_address = 0;\n\n \n\nu8 gbl_revision = 0;\n\nstruct osl_table_info *gbl_table_list_head = NULL;\nu32 gbl_table_count = 0;\n\n \n\nstatic acpi_status osl_get_last_status(acpi_status default_status)\n{\n\n\tswitch (errno) {\n\tcase EACCES:\n\tcase EPERM:\n\n\t\treturn (AE_ACCESS);\n\n\tcase ENOENT:\n\n\t\treturn (AE_NOT_FOUND);\n\n\tcase ENOMEM:\n\n\t\treturn (AE_NO_MEMORY);\n\n\tdefault:\n\n\t\treturn (default_status);\n\t}\n}\n\n \n\nacpi_status\nacpi_os_get_table_by_address(acpi_physical_address address,\n\t\t\t     struct acpi_table_header **table)\n{\n\tu32 table_length;\n\tstruct acpi_table_header *mapped_table;\n\tstruct acpi_table_header *local_table = NULL;\n\tacpi_status status = AE_OK;\n\n\t \n\n\tstatus = osl_table_initialize();\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tstatus = osl_map_table(address, NULL, &mapped_table);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\ttable_length = ap_get_table_length(mapped_table);\n\tif (table_length == 0) {\n\t\tstatus = AE_BAD_HEADER;\n\t\tgoto exit;\n\t}\n\n\tlocal_table = calloc(1, table_length);\n\tif (!local_table) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(local_table, mapped_table, table_length);\n\nexit:\n\tosl_unmap_table(mapped_table);\n\t*table = local_table;\n\treturn (status);\n}\n\n \n\nacpi_status\nacpi_os_get_table_by_name(char *signature,\n\t\t\t  u32 instance,\n\t\t\t  struct acpi_table_header **table,\n\t\t\t  acpi_physical_address *address)\n{\n\tacpi_status status;\n\n\t \n\n\tstatus = osl_table_initialize();\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tif (!gbl_dump_customized_tables) {\n\n\t\t \n\n\t\tstatus =\n\t\t    osl_get_bios_table(signature, instance, table, address);\n\t} else {\n\t\t \n\n\t\tstatus = osl_get_customized_table(STATIC_TABLE_DIR, signature,\n\t\t\t\t\t\t  instance, table, address);\n\t}\n\n\tif (ACPI_FAILURE(status) && status == AE_LIMIT) {\n\t\tif (gbl_dump_dynamic_tables) {\n\n\t\t\t \n\n\t\t\tstatus =\n\t\t\t    osl_get_customized_table(DYNAMIC_TABLE_DIR,\n\t\t\t\t\t\t     signature, instance, table,\n\t\t\t\t\t\t     address);\n\t\t}\n\t}\n\n\treturn (status);\n}\n\n \n\nstatic acpi_status osl_add_table_to_list(char *signature, u32 instance)\n{\n\tstruct osl_table_info *new_info;\n\tstruct osl_table_info *next;\n\tu32 next_instance = 0;\n\tu8 found = FALSE;\n\n\tnew_info = calloc(1, sizeof(struct osl_table_info));\n\tif (!new_info) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tACPI_COPY_NAMESEG(new_info->signature, signature);\n\n\tif (!gbl_table_list_head) {\n\t\tgbl_table_list_head = new_info;\n\t} else {\n\t\tnext = gbl_table_list_head;\n\t\twhile (1) {\n\t\t\tif (ACPI_COMPARE_NAMESEG(next->signature, signature)) {\n\t\t\t\tif (next->instance == instance) {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t}\n\t\t\t\tif (next->instance >= next_instance) {\n\t\t\t\t\tnext_instance = next->instance + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!next->next) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext = next->next;\n\t\t}\n\t\tnext->next = new_info;\n\t}\n\n\tif (found) {\n\t\tif (instance) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%4.4s: Warning unmatched table instance %d, expected %d\\n\",\n\t\t\t\tsignature, instance, next_instance);\n\t\t}\n\t\tinstance = next_instance;\n\t}\n\n\tnew_info->instance = instance;\n\tgbl_table_count++;\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_os_get_table_by_index(u32 index,\n\t\t\t   struct acpi_table_header **table,\n\t\t\t   u32 *instance, acpi_physical_address *address)\n{\n\tstruct osl_table_info *info;\n\tacpi_status status;\n\tu32 i;\n\n\t \n\n\tstatus = osl_table_initialize();\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\t \n\n\tif (index >= gbl_table_count) {\n\t\treturn (AE_LIMIT);\n\t}\n\n\t \n\n\tinfo = gbl_table_list_head;\n\tfor (i = 0; i < index; i++) {\n\t\tinfo = info->next;\n\t}\n\n\t \n\n\tstatus = acpi_os_get_table_by_name(info->signature, info->instance,\n\t\t\t\t\t   table, address);\n\n\tif (ACPI_SUCCESS(status)) {\n\t\t*instance = info->instance;\n\t}\n\treturn (status);\n}\n\n \n\nstatic acpi_physical_address\nosl_find_rsdp_via_efi_by_keyword(FILE * file, const char *keyword)\n{\n\tchar buffer[80];\n\tunsigned long long address = 0;\n\tchar format[32];\n\n\tsnprintf(format, 32, \"%s=%s\", keyword, \"%llx\");\n\tfseek(file, 0, SEEK_SET);\n\twhile (fgets(buffer, 80, file)) {\n\t\tif (sscanf(buffer, format, &address) == 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ((acpi_physical_address)(address));\n}\n\n \n\nstatic acpi_physical_address osl_find_rsdp_via_efi(void)\n{\n\tFILE *file;\n\tacpi_physical_address address = 0;\n\n\tfile = fopen(EFI_SYSTAB, \"r\");\n\tif (file) {\n\t\taddress = osl_find_rsdp_via_efi_by_keyword(file, \"ACPI20\");\n\t\tif (!address) {\n\t\t\taddress =\n\t\t\t    osl_find_rsdp_via_efi_by_keyword(file, \"ACPI\");\n\t\t}\n\t\tfclose(file);\n\t}\n\n\treturn (address);\n}\n\n \n\nstatic acpi_status osl_load_rsdp(void)\n{\n\tstruct acpi_table_header *mapped_table;\n\tu8 *rsdp_address;\n\tacpi_physical_address rsdp_base;\n\tacpi_size rsdp_size;\n\n\t \n\n\trsdp_size = sizeof(struct acpi_table_rsdp);\n\tif (gbl_rsdp_base) {\n\t\trsdp_base = gbl_rsdp_base;\n\t} else {\n\t\trsdp_base = osl_find_rsdp_via_efi();\n\t}\n\n\tif (!rsdp_base) {\n\t\trsdp_base = ACPI_HI_RSDP_WINDOW_BASE;\n\t\trsdp_size = ACPI_HI_RSDP_WINDOW_SIZE;\n\t}\n\n\trsdp_address = acpi_os_map_memory(rsdp_base, rsdp_size);\n\tif (!rsdp_address) {\n\t\treturn (osl_get_last_status(AE_BAD_ADDRESS));\n\t}\n\n\t \n\n\tmapped_table = ACPI_CAST_PTR(struct acpi_table_header,\n\t\t\t\t     acpi_tb_scan_memory_for_rsdp(rsdp_address,\n\t\t\t\t\t\t\t\t  rsdp_size));\n\tif (!mapped_table) {\n\t\tacpi_os_unmap_memory(rsdp_address, rsdp_size);\n\t\treturn (AE_NOT_FOUND);\n\t}\n\n\tgbl_rsdp_address =\n\t    rsdp_base + (ACPI_CAST8(mapped_table) - rsdp_address);\n\n\tmemcpy(&gbl_rsdp, mapped_table, sizeof(struct acpi_table_rsdp));\n\tacpi_os_unmap_memory(rsdp_address, rsdp_size);\n\n\treturn (AE_OK);\n}\n\n \n\nstatic u8 osl_can_use_xsdt(void)\n{\n\tif (gbl_revision && !acpi_gbl_do_not_use_xsdt) {\n\t\treturn (TRUE);\n\t} else {\n\t\treturn (FALSE);\n\t}\n}\n\n \n\nstatic acpi_status osl_table_initialize(void)\n{\n\tacpi_status status;\n\tacpi_physical_address address;\n\n\tif (gbl_table_list_initialized) {\n\t\treturn (AE_OK);\n\t}\n\n\tif (!gbl_dump_customized_tables) {\n\n\t\t \n\n\t\tstatus = osl_load_rsdp();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\t \n\n\t\tif (gbl_rsdp.revision && !gbl_do_not_dump_xsdt) {\n\t\t\tif (gbl_xsdt) {\n\t\t\t\tfree(gbl_xsdt);\n\t\t\t\tgbl_xsdt = NULL;\n\t\t\t}\n\n\t\t\tgbl_revision = 2;\n\t\t\tstatus = osl_get_bios_table(ACPI_SIG_XSDT, 0,\n\t\t\t\t\t\t    ACPI_CAST_PTR(struct\n\t\t\t\t\t\t\t\t  acpi_table_header\n\t\t\t\t\t\t\t\t  *, &gbl_xsdt),\n\t\t\t\t\t\t    &address);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn (status);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (gbl_rsdp.rsdt_physical_address) {\n\t\t\tif (gbl_rsdt) {\n\t\t\t\tfree(gbl_rsdt);\n\t\t\t\tgbl_rsdt = NULL;\n\t\t\t}\n\n\t\t\tstatus = osl_get_bios_table(ACPI_SIG_RSDT, 0,\n\t\t\t\t\t\t    ACPI_CAST_PTR(struct\n\t\t\t\t\t\t\t\t  acpi_table_header\n\t\t\t\t\t\t\t\t  *, &gbl_rsdt),\n\t\t\t\t\t\t    &address);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn (status);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (gbl_fadt) {\n\t\t\tfree(gbl_fadt);\n\t\t\tgbl_fadt = NULL;\n\t\t}\n\n\t\tstatus = osl_get_bios_table(ACPI_SIG_FADT, 0,\n\t\t\t\t\t    ACPI_CAST_PTR(struct\n\t\t\t\t\t\t\t  acpi_table_header *,\n\t\t\t\t\t\t\t  &gbl_fadt),\n\t\t\t\t\t    &gbl_fadt_address);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\t \n\n\t\tstatus = osl_add_table_to_list(ACPI_RSDP_NAME, 0);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\tstatus = osl_add_table_to_list(ACPI_SIG_RSDT, 0);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\tif (gbl_revision == 2) {\n\t\t\tstatus = osl_add_table_to_list(ACPI_SIG_XSDT, 0);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn (status);\n\t\t\t}\n\t\t}\n\n\t\tstatus = osl_add_table_to_list(ACPI_SIG_DSDT, 0);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\tstatus = osl_add_table_to_list(ACPI_SIG_FACS, 0);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\t \n\n\t\tstatus = osl_list_bios_tables();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t} else {\n\t\t \n\n\t\tstatus = osl_list_customized_tables(STATIC_TABLE_DIR);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\tif (gbl_dump_dynamic_tables) {\n\n\t\t \n\n\t\tstatus = osl_list_customized_tables(DYNAMIC_TABLE_DIR);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\t}\n\n\tgbl_table_list_initialized = TRUE;\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status osl_list_bios_tables(void)\n{\n\tstruct acpi_table_header *mapped_table = NULL;\n\tu8 *table_data;\n\tu8 number_of_tables;\n\tu8 item_size;\n\tacpi_physical_address table_address = 0;\n\tacpi_status status = AE_OK;\n\tu32 i;\n\n\tif (osl_can_use_xsdt()) {\n\t\titem_size = sizeof(u64);\n\t\ttable_data =\n\t\t    ACPI_CAST8(gbl_xsdt) + sizeof(struct acpi_table_header);\n\t\tnumber_of_tables =\n\t\t    (u8)((gbl_xsdt->header.length -\n\t\t\t  sizeof(struct acpi_table_header))\n\t\t\t / item_size);\n\t} else {\t\t \n\n\t\titem_size = sizeof(u32);\n\t\ttable_data =\n\t\t    ACPI_CAST8(gbl_rsdt) + sizeof(struct acpi_table_header);\n\t\tnumber_of_tables =\n\t\t    (u8)((gbl_rsdt->header.length -\n\t\t\t  sizeof(struct acpi_table_header))\n\t\t\t / item_size);\n\t}\n\n\t \n\n\tfor (i = 0; i < number_of_tables; ++i, table_data += item_size) {\n\t\tif (osl_can_use_xsdt()) {\n\t\t\ttable_address =\n\t\t\t    (acpi_physical_address)(*ACPI_CAST64(table_data));\n\t\t} else {\n\t\t\ttable_address =\n\t\t\t    (acpi_physical_address)(*ACPI_CAST32(table_data));\n\t\t}\n\n\t\t \n\n\t\tif (table_address == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = osl_map_table(table_address, NULL, &mapped_table);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\tosl_add_table_to_list(mapped_table->signature, 0);\n\t\tosl_unmap_table(mapped_table);\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nosl_get_bios_table(char *signature,\n\t\t   u32 instance,\n\t\t   struct acpi_table_header **table,\n\t\t   acpi_physical_address *address)\n{\n\tstruct acpi_table_header *local_table = NULL;\n\tstruct acpi_table_header *mapped_table = NULL;\n\tu8 *table_data;\n\tu8 number_of_tables;\n\tu8 item_size;\n\tu32 current_instance = 0;\n\tacpi_physical_address table_address;\n\tacpi_physical_address first_table_address = 0;\n\tu32 table_length = 0;\n\tacpi_status status = AE_OK;\n\tu32 i;\n\n\t \n\n\tif (ACPI_COMPARE_NAMESEG(signature, ACPI_RSDP_NAME) ||\n\t    ACPI_COMPARE_NAMESEG(signature, ACPI_SIG_RSDT) ||\n\t    ACPI_COMPARE_NAMESEG(signature, ACPI_SIG_XSDT) ||\n\t    ACPI_COMPARE_NAMESEG(signature, ACPI_SIG_DSDT) ||\n\t    ACPI_COMPARE_NAMESEG(signature, ACPI_SIG_FACS)) {\n\nfind_next_instance:\n\n\t\ttable_address = 0;\n\n\t\t \n\t\tif (ACPI_COMPARE_NAMESEG(signature, ACPI_SIG_DSDT)) {\n\t\t\tif (current_instance < 2) {\n\t\t\t\tif ((gbl_fadt->header.length >=\n\t\t\t\t     MIN_FADT_FOR_XDSDT) && gbl_fadt->Xdsdt\n\t\t\t\t    && current_instance == 0) {\n\t\t\t\t\ttable_address =\n\t\t\t\t\t    (acpi_physical_address)gbl_fadt->\n\t\t\t\t\t    Xdsdt;\n\t\t\t\t} else\n\t\t\t\t    if ((gbl_fadt->header.length >=\n\t\t\t\t\t MIN_FADT_FOR_DSDT)\n\t\t\t\t\t&& gbl_fadt->dsdt !=\n\t\t\t\t\tfirst_table_address) {\n\t\t\t\t\ttable_address =\n\t\t\t\t\t    (acpi_physical_address)gbl_fadt->\n\t\t\t\t\t    dsdt;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ACPI_COMPARE_NAMESEG(signature, ACPI_SIG_FACS)) {\n\t\t\tif (current_instance < 2) {\n\t\t\t\tif ((gbl_fadt->header.length >=\n\t\t\t\t     MIN_FADT_FOR_XFACS) && gbl_fadt->Xfacs\n\t\t\t\t    && current_instance == 0) {\n\t\t\t\t\ttable_address =\n\t\t\t\t\t    (acpi_physical_address)gbl_fadt->\n\t\t\t\t\t    Xfacs;\n\t\t\t\t} else\n\t\t\t\t    if ((gbl_fadt->header.length >=\n\t\t\t\t\t MIN_FADT_FOR_FACS)\n\t\t\t\t\t&& gbl_fadt->facs !=\n\t\t\t\t\tfirst_table_address) {\n\t\t\t\t\ttable_address =\n\t\t\t\t\t    (acpi_physical_address)gbl_fadt->\n\t\t\t\t\t    facs;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ACPI_COMPARE_NAMESEG(signature, ACPI_SIG_XSDT)) {\n\t\t\tif (!gbl_revision) {\n\t\t\t\treturn (AE_BAD_SIGNATURE);\n\t\t\t}\n\t\t\tif (current_instance == 0) {\n\t\t\t\ttable_address =\n\t\t\t\t    (acpi_physical_address)gbl_rsdp.\n\t\t\t\t    xsdt_physical_address;\n\t\t\t}\n\t\t} else if (ACPI_COMPARE_NAMESEG(signature, ACPI_SIG_RSDT)) {\n\t\t\tif (current_instance == 0) {\n\t\t\t\ttable_address =\n\t\t\t\t    (acpi_physical_address)gbl_rsdp.\n\t\t\t\t    rsdt_physical_address;\n\t\t\t}\n\t\t} else {\n\t\t\tif (current_instance == 0) {\n\t\t\t\ttable_address =\n\t\t\t\t    (acpi_physical_address)gbl_rsdp_address;\n\t\t\t\tsignature = ACPI_SIG_RSDP;\n\t\t\t}\n\t\t}\n\n\t\tif (table_address == 0) {\n\t\t\tgoto exit_find_table;\n\t\t}\n\n\t\t \n\n\t\tstatus = osl_map_table(table_address, signature, &mapped_table);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn (status);\n\t\t}\n\n\t\ttable_length = ap_get_table_length(mapped_table);\n\t\tif (first_table_address == 0) {\n\t\t\tfirst_table_address = table_address;\n\t\t}\n\n\t\t \n\n\t\tif (current_instance != instance) {\n\t\t\tosl_unmap_table(mapped_table);\n\t\t\tmapped_table = NULL;\n\t\t\tcurrent_instance++;\n\t\t\tgoto find_next_instance;\n\t\t}\n\t} else {\t\t \n\n\t\tif (osl_can_use_xsdt()) {\n\t\t\titem_size = sizeof(u64);\n\t\t\ttable_data =\n\t\t\t    ACPI_CAST8(gbl_xsdt) +\n\t\t\t    sizeof(struct acpi_table_header);\n\t\t\tnumber_of_tables =\n\t\t\t    (u8)((gbl_xsdt->header.length -\n\t\t\t\t  sizeof(struct acpi_table_header))\n\t\t\t\t / item_size);\n\t\t} else {\t \n\n\t\t\titem_size = sizeof(u32);\n\t\t\ttable_data =\n\t\t\t    ACPI_CAST8(gbl_rsdt) +\n\t\t\t    sizeof(struct acpi_table_header);\n\t\t\tnumber_of_tables =\n\t\t\t    (u8)((gbl_rsdt->header.length -\n\t\t\t\t  sizeof(struct acpi_table_header))\n\t\t\t\t / item_size);\n\t\t}\n\n\t\t \n\n\t\tfor (i = 0; i < number_of_tables; ++i, table_data += item_size) {\n\t\t\tif (osl_can_use_xsdt()) {\n\t\t\t\ttable_address =\n\t\t\t\t    (acpi_physical_address)(*ACPI_CAST64\n\t\t\t\t\t\t\t    (table_data));\n\t\t\t} else {\n\t\t\t\ttable_address =\n\t\t\t\t    (acpi_physical_address)(*ACPI_CAST32\n\t\t\t\t\t\t\t    (table_data));\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (table_address == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstatus =\n\t\t\t    osl_map_table(table_address, NULL, &mapped_table);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\treturn (status);\n\t\t\t}\n\t\t\ttable_length = mapped_table->length;\n\n\t\t\t \n\n\t\t\tif (!ACPI_COMPARE_NAMESEG\n\t\t\t    (mapped_table->signature, signature)) {\n\t\t\t\tosl_unmap_table(mapped_table);\n\t\t\t\tmapped_table = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (current_instance != instance) {\n\t\t\t\tosl_unmap_table(mapped_table);\n\t\t\t\tmapped_table = NULL;\n\t\t\t\tcurrent_instance++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\nexit_find_table:\n\n\tif (!mapped_table) {\n\t\treturn (AE_LIMIT);\n\t}\n\n\tif (table_length == 0) {\n\t\tstatus = AE_BAD_HEADER;\n\t\tgoto exit;\n\t}\n\n\t \n\n\tlocal_table = calloc(1, table_length);\n\tif (!local_table) {\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(local_table, mapped_table, table_length);\n\t*address = table_address;\n\t*table = local_table;\n\nexit:\n\tosl_unmap_table(mapped_table);\n\treturn (status);\n}\n\n \n\nstatic acpi_status osl_list_customized_tables(char *directory)\n{\n\tvoid *table_dir;\n\tu32 instance;\n\tchar temp_name[ACPI_NAMESEG_SIZE];\n\tchar *filename;\n\tacpi_status status = AE_OK;\n\n\t \n\n\ttable_dir = acpi_os_open_directory(directory, \"*\", REQUEST_FILE_ONLY);\n\tif (!table_dir) {\n\t\treturn (osl_get_last_status(AE_NOT_FOUND));\n\t}\n\n\t \n\n\twhile ((filename = acpi_os_get_next_filename(table_dir))) {\n\n\t\t \n\n\t\tstatus =\n\t\t    osl_table_name_from_file(filename, temp_name, &instance);\n\n\t\t \n\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tstatus = osl_add_table_to_list(temp_name, instance);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tacpi_os_close_directory(table_dir);\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nosl_map_table(acpi_size address,\n\t      char *signature, struct acpi_table_header **table)\n{\n\tstruct acpi_table_header *mapped_table;\n\tu32 length;\n\n\tif (!address) {\n\t\treturn (AE_BAD_ADDRESS);\n\t}\n\n\t \n\tmapped_table =\n\t    acpi_os_map_memory(address, sizeof(struct acpi_table_header));\n\tif (!mapped_table) {\n\t\tfprintf(stderr, \"Could not map table header at 0x%8.8X%8.8X\\n\",\n\t\t\tACPI_FORMAT_UINT64(address));\n\t\treturn (osl_get_last_status(AE_BAD_ADDRESS));\n\t}\n\n\t \n\n\tif (signature) {\n\t\tif (ACPI_VALIDATE_RSDP_SIG(signature)) {\n\t\t\tif (!ACPI_VALIDATE_RSDP_SIG(mapped_table->signature)) {\n\t\t\t\tacpi_os_unmap_memory(mapped_table,\n\t\t\t\t\t\t     sizeof(struct\n\t\t\t\t\t\t\t    acpi_table_header));\n\t\t\t\treturn (AE_BAD_SIGNATURE);\n\t\t\t}\n\t\t} else\n\t\t    if (!ACPI_COMPARE_NAMESEG\n\t\t\t(signature, mapped_table->signature)) {\n\t\t\tacpi_os_unmap_memory(mapped_table,\n\t\t\t\t\t     sizeof(struct acpi_table_header));\n\t\t\treturn (AE_BAD_SIGNATURE);\n\t\t}\n\t}\n\n\t \n\n\tlength = ap_get_table_length(mapped_table);\n\tacpi_os_unmap_memory(mapped_table, sizeof(struct acpi_table_header));\n\tif (length == 0) {\n\t\treturn (AE_BAD_HEADER);\n\t}\n\n\tmapped_table = acpi_os_map_memory(address, length);\n\tif (!mapped_table) {\n\t\tfprintf(stderr,\n\t\t\t\"Could not map table at 0x%8.8X%8.8X length %8.8X\\n\",\n\t\t\tACPI_FORMAT_UINT64(address), length);\n\t\treturn (osl_get_last_status(AE_INVALID_TABLE_LENGTH));\n\t}\n\n\t(void)ap_is_valid_checksum(mapped_table);\n\n\t*table = mapped_table;\n\treturn (AE_OK);\n}\n\n \n\nstatic void osl_unmap_table(struct acpi_table_header *table)\n{\n\tif (table) {\n\t\tacpi_os_unmap_memory(table, ap_get_table_length(table));\n\t}\n}\n\n \n\nstatic acpi_status\nosl_table_name_from_file(char *filename, char *signature, u32 *instance)\n{\n\n\t \n\n\tif (strlen(filename) < ACPI_NAMESEG_SIZE) {\n\t\treturn (AE_BAD_SIGNATURE);\n\t}\n\n\t \n\n\tif (isdigit((int)filename[ACPI_NAMESEG_SIZE])) {\n\t\tsscanf(&filename[ACPI_NAMESEG_SIZE], \"%u\", instance);\n\t} else if (strlen(filename) != ACPI_NAMESEG_SIZE) {\n\t\treturn (AE_BAD_SIGNATURE);\n\t} else {\n\t\t*instance = 0;\n\t}\n\n\t \n\n\tACPI_COPY_NAMESEG(signature, filename);\n\treturn (AE_OK);\n}\n\n \n\nstatic acpi_status\nosl_read_table_from_file(char *filename,\n\t\t\t acpi_size file_offset,\n\t\t\t struct acpi_table_header **table)\n{\n\tFILE *table_file;\n\tstruct acpi_table_header header;\n\tstruct acpi_table_header *local_table = NULL;\n\tu32 table_length;\n\ts32 count;\n\tacpi_status status = AE_OK;\n\n\t \n\n\ttable_file = fopen(filename, \"rb\");\n\tif (table_file == NULL) {\n\t\tfprintf(stderr, \"Could not open table file: %s\\n\", filename);\n\t\treturn (osl_get_last_status(AE_NOT_FOUND));\n\t}\n\n\tfseek(table_file, file_offset, SEEK_SET);\n\n\t \n\n\tcount = fread(&header, 1, sizeof(struct acpi_table_header), table_file);\n\tif (count != sizeof(struct acpi_table_header)) {\n\t\tfprintf(stderr, \"Could not read table header: %s\\n\", filename);\n\t\tstatus = AE_BAD_HEADER;\n\t\tgoto exit;\n\t}\n\n#ifdef ACPI_OBSOLETE_FUNCTIONS\n\n\t \n\n\tif (signature) {\n\t\tif (ACPI_VALIDATE_RSDP_SIG(signature)) {\n\t\t\tif (!ACPI_VALIDATE_RSDP_SIG(header.signature)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Incorrect RSDP signature: found %8.8s\\n\",\n\t\t\t\t\theader.signature);\n\t\t\t\tstatus = AE_BAD_SIGNATURE;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else if (!ACPI_COMPARE_NAMESEG(signature, header.signature)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Incorrect signature: Expecting %4.4s, found %4.4s\\n\",\n\t\t\t\tsignature, header.signature);\n\t\t\tstatus = AE_BAD_SIGNATURE;\n\t\t\tgoto exit;\n\t\t}\n\t}\n#endif\n\n\ttable_length = ap_get_table_length(&header);\n\tif (table_length == 0) {\n\t\tstatus = AE_BAD_HEADER;\n\t\tgoto exit;\n\t}\n\n\t \n\n\tlocal_table = calloc(1, table_length);\n\tif (!local_table) {\n\t\tfprintf(stderr,\n\t\t\t\"%4.4s: Could not allocate buffer for table of length %X\\n\",\n\t\t\theader.signature, table_length);\n\t\tstatus = AE_NO_MEMORY;\n\t\tgoto exit;\n\t}\n\n\tfseek(table_file, file_offset, SEEK_SET);\n\n\tcount = fread(local_table, 1, table_length, table_file);\n\tif (count != table_length) {\n\t\tfprintf(stderr, \"%4.4s: Could not read table content\\n\",\n\t\t\theader.signature);\n\t\tstatus = AE_INVALID_TABLE_LENGTH;\n\t\tgoto exit;\n\t}\n\n\t \n\n\t(void)ap_is_valid_checksum(local_table);\n\nexit:\n\tfclose(table_file);\n\t*table = local_table;\n\treturn (status);\n}\n\n \n\nstatic acpi_status\nosl_get_customized_table(char *pathname,\n\t\t\t char *signature,\n\t\t\t u32 instance,\n\t\t\t struct acpi_table_header **table,\n\t\t\t acpi_physical_address *address)\n{\n\tvoid *table_dir;\n\tu32 current_instance = 0;\n\tchar temp_name[ACPI_NAMESEG_SIZE];\n\tchar table_filename[PATH_MAX];\n\tchar *filename;\n\tacpi_status status;\n\n\t \n\n\ttable_dir = acpi_os_open_directory(pathname, \"*\", REQUEST_FILE_ONLY);\n\tif (!table_dir) {\n\t\treturn (osl_get_last_status(AE_NOT_FOUND));\n\t}\n\n\t \n\n\twhile ((filename = acpi_os_get_next_filename(table_dir))) {\n\n\t\t \n\n\t\tif (!ACPI_COMPARE_NAMESEG(filename, signature)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tstatus =\n\t\t    osl_table_name_from_file(filename, temp_name,\n\t\t\t\t\t     &current_instance);\n\n\t\t \n\n\t\tif (ACPI_FAILURE(status) || current_instance != instance) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tif (instance != 0) {\n\t\t\tsprintf(table_filename, \"%s/%4.4s%d\", pathname,\n\t\t\t\ttemp_name, instance);\n\t\t} else {\n\t\t\tsprintf(table_filename, \"%s/%4.4s\", pathname,\n\t\t\t\ttemp_name);\n\t\t}\n\t\tbreak;\n\t}\n\n\tacpi_os_close_directory(table_dir);\n\n\tif (!filename) {\n\t\treturn (AE_LIMIT);\n\t}\n\n\t \n\n\t*address = 0;\n\tstatus = osl_read_table_from_file(table_filename, 0, table);\n\n\treturn (status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}