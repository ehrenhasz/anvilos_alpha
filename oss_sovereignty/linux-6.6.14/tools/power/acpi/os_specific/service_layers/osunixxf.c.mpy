{
  "module_name": "osunixxf.c",
  "hash_id": "09cfb4d77d421bed34c0561d6b9261dcb53fed79ec350d8f1d4582d0787ee5a3",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/acpi/os_specific/service_layers/osunixxf.c",
  "human_readable_source": "\n \n\n \n#include <acpi/acpi.h>\n#include \"accommon.h\"\n#include \"amlcode.h\"\n#include \"acparser.h\"\n#include \"acdebug.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <semaphore.h>\n#include <pthread.h>\n#include <errno.h>\n\n#define _COMPONENT          ACPI_OS_SERVICES\nACPI_MODULE_NAME(\"osunixxf\")\n\n \nvoid\nae_table_override(struct acpi_table_header *existing_table,\n\t\t  struct acpi_table_header **new_table);\n\ntypedef void *(*PTHREAD_CALLBACK) (void *);\n\n \n\n#define ACPI_VPRINTF_BUFFER_SIZE    512\n#define _ASCII_NEWLINE              '\\n'\n\n \n\n#ifdef ACPI_EXEC_APP\n#include <termios.h>\n\nstruct termios original_term_attributes;\nint term_attributes_were_set = 0;\n\nacpi_status acpi_ut_read_line(char *buffer, u32 buffer_length, u32 *bytes_read);\n\nstatic void os_enter_line_edit_mode(void);\n\nstatic void os_exit_line_edit_mode(void);\n\n \n\nstatic void os_enter_line_edit_mode(void)\n{\n\tstruct termios local_term_attributes;\n\n\tterm_attributes_were_set = 0;\n\n\t \n\n\tif (!isatty(STDIN_FILENO)) {\n\t\treturn;\n\t}\n\n\t \n\n\tif (tcgetattr(STDIN_FILENO, &original_term_attributes)) {\n\t\tfprintf(stderr, \"Could not get terminal attributes!\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\tmemcpy(&local_term_attributes, &original_term_attributes,\n\t       sizeof(struct termios));\n\n\tlocal_term_attributes.c_lflag &= ~(ICANON | ECHO);\n\tlocal_term_attributes.c_cc[VMIN] = 1;\n\tlocal_term_attributes.c_cc[VTIME] = 0;\n\n\tif (tcsetattr(STDIN_FILENO, TCSANOW, &local_term_attributes)) {\n\t\tfprintf(stderr, \"Could not set terminal attributes!\\n\");\n\t\treturn;\n\t}\n\n\tterm_attributes_were_set = 1;\n}\n\nstatic void os_exit_line_edit_mode(void)\n{\n\n\tif (!term_attributes_were_set) {\n\t\treturn;\n\t}\n\n\t \n\n\tif (tcsetattr(STDIN_FILENO, TCSANOW, &original_term_attributes)) {\n\t\tfprintf(stderr, \"Could not restore terminal attributes!\\n\");\n\t}\n}\n\n#else\n\n \n\n#define os_enter_line_edit_mode()\n#define os_exit_line_edit_mode()\n#endif\n\n \n\nacpi_status acpi_os_initialize(void)\n{\n\tacpi_status status;\n\n\tacpi_gbl_output_file = stdout;\n\n\tos_enter_line_edit_mode();\n\n\tstatus = acpi_os_create_lock(&acpi_gbl_print_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn (status);\n\t}\n\n\treturn (AE_OK);\n}\n\nacpi_status acpi_os_terminate(void)\n{\n\n\tos_exit_line_edit_mode();\n\treturn (AE_OK);\n}\n\n#ifndef ACPI_USE_NATIVE_RSDP_POINTER\n \n\nacpi_physical_address acpi_os_get_root_pointer(void)\n{\n\n\treturn (0);\n}\n#endif\n\n \n\nacpi_status\nacpi_os_predefined_override(const struct acpi_predefined_names *init_val,\n\t\t\t    acpi_string *new_val)\n{\n\n\tif (!init_val || !new_val) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t*new_val = NULL;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_os_table_override(struct acpi_table_header *existing_table,\n\t\t       struct acpi_table_header **new_table)\n{\n\n\tif (!existing_table || !new_table) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\t*new_table = NULL;\n\n#ifdef ACPI_EXEC_APP\n\n\tae_table_override(existing_table, new_table);\n\treturn (AE_OK);\n#else\n\n\treturn (AE_NO_ACPI_TABLES);\n#endif\n}\n\n \n\nacpi_status\nacpi_os_physical_table_override(struct acpi_table_header *existing_table,\n\t\t\t\tacpi_physical_address *new_address,\n\t\t\t\tu32 *new_table_length)\n{\n\n\treturn (AE_SUPPORT);\n}\n\n \n\nacpi_status acpi_os_enter_sleep(u8 sleep_state, u32 rega_value, u32 regb_value)\n{\n\n\treturn (AE_OK);\n}\n\n \n\nvoid acpi_os_redirect_output(void *destination)\n{\n\n\tacpi_gbl_output_file = destination;\n}\n\n \n\nvoid ACPI_INTERNAL_VAR_XFACE acpi_os_printf(const char *fmt, ...)\n{\n\tva_list args;\n\tu8 flags;\n\n\tflags = acpi_gbl_db_output_flags;\n\tif (flags & ACPI_DB_REDIRECTABLE_OUTPUT) {\n\n\t\t \n\n\t\tif (acpi_gbl_debug_file) {\n\n\t\t\t \n\n\t\t\tva_start(args, fmt);\n\t\t\tvfprintf(acpi_gbl_debug_file, fmt, args);\n\t\t\tva_end(args);\n\t\t} else {\n\t\t\t \n\n\t\t\tflags |= ACPI_DB_CONSOLE_OUTPUT;\n\t\t}\n\t}\n\n\tif (flags & ACPI_DB_CONSOLE_OUTPUT) {\n\t\tva_start(args, fmt);\n\t\tvfprintf(acpi_gbl_output_file, fmt, args);\n\t\tva_end(args);\n\t}\n}\n\n \n\nvoid acpi_os_vprintf(const char *fmt, va_list args)\n{\n\tu8 flags;\n\tchar buffer[ACPI_VPRINTF_BUFFER_SIZE];\n\n\t \n\tvsnprintf(buffer, ACPI_VPRINTF_BUFFER_SIZE, fmt, args);\n\n\tflags = acpi_gbl_db_output_flags;\n\tif (flags & ACPI_DB_REDIRECTABLE_OUTPUT) {\n\n\t\t \n\n\t\tif (acpi_gbl_debug_file) {\n\n\t\t\t \n\n\t\t\tfputs(buffer, acpi_gbl_debug_file);\n\t\t} else {\n\t\t\t \n\n\t\t\tflags |= ACPI_DB_CONSOLE_OUTPUT;\n\t\t}\n\t}\n\n\tif (flags & ACPI_DB_CONSOLE_OUTPUT) {\n\t\tfputs(buffer, acpi_gbl_output_file);\n\t}\n}\n\n#ifndef ACPI_EXEC_APP\n \n\nacpi_status acpi_os_get_line(char *buffer, u32 buffer_length, u32 *bytes_read)\n{\n\tint input_char;\n\tu32 end_of_line;\n\n\t \n\n\tfor (end_of_line = 0;; end_of_line++) {\n\t\tif (end_of_line >= buffer_length) {\n\t\t\treturn (AE_BUFFER_OVERFLOW);\n\t\t}\n\n\t\tif ((input_char = getchar()) == EOF) {\n\t\t\treturn (AE_ERROR);\n\t\t}\n\n\t\tif (!input_char || input_char == _ASCII_NEWLINE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer[end_of_line] = (char)input_char;\n\t}\n\n\t \n\n\tbuffer[end_of_line] = 0;\n\n\t \n\n\tif (bytes_read) {\n\t\t*bytes_read = end_of_line;\n\t}\n\n\treturn (AE_OK);\n}\n#endif\n\n#ifndef ACPI_USE_NATIVE_MEMORY_MAPPING\n \n\nvoid *acpi_os_map_memory(acpi_physical_address where, acpi_size length)\n{\n\n\treturn (ACPI_TO_POINTER((acpi_size)where));\n}\n\n \n\nvoid acpi_os_unmap_memory(void *where, acpi_size length)\n{\n\n\treturn;\n}\n#endif\n\n \n\nvoid *acpi_os_allocate(acpi_size size)\n{\n\tvoid *mem;\n\n\tmem = (void *)malloc((size_t) size);\n\treturn (mem);\n}\n\n#ifdef USE_NATIVE_ALLOCATE_ZEROED\n \n\nvoid *acpi_os_allocate_zeroed(acpi_size size)\n{\n\tvoid *mem;\n\n\tmem = (void *)calloc(1, (size_t) size);\n\treturn (mem);\n}\n#endif\n\n \n\nvoid acpi_os_free(void *mem)\n{\n\n\tfree(mem);\n}\n\n#ifdef ACPI_SINGLE_THREADED\n \n\nacpi_status\nacpi_os_create_semaphore(u32 max_units,\n\t\t\t u32 initial_units, acpi_handle *out_handle)\n{\n\t*out_handle = (acpi_handle)1;\n\treturn (AE_OK);\n}\n\nacpi_status acpi_os_delete_semaphore(acpi_handle handle)\n{\n\treturn (AE_OK);\n}\n\nacpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)\n{\n\treturn (AE_OK);\n}\n\nacpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)\n{\n\treturn (AE_OK);\n}\n\n#else\n \n\nacpi_status\nacpi_os_create_semaphore(u32 max_units,\n\t\t\t u32 initial_units, acpi_handle *out_handle)\n{\n\tsem_t *sem;\n\n\tif (!out_handle) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n#ifdef __APPLE__\n\t{\n\t\tstatic int semaphore_count = 0;\n\t\tchar semaphore_name[32];\n\n\t\tsnprintf(semaphore_name, sizeof(semaphore_name), \"acpi_sem_%d\",\n\t\t\t semaphore_count++);\n\t\tprintf(\"%s\\n\", semaphore_name);\n\t\tsem =\n\t\t    sem_open(semaphore_name, O_EXCL | O_CREAT, 0755,\n\t\t\t     initial_units);\n\t\tif (!sem) {\n\t\t\treturn (AE_NO_MEMORY);\n\t\t}\n\t\tsem_unlink(semaphore_name);\t \n\t}\n\n#else\n\tsem = acpi_os_allocate(sizeof(sem_t));\n\tif (!sem) {\n\t\treturn (AE_NO_MEMORY);\n\t}\n\n\tif (sem_init(sem, 0, initial_units) == -1) {\n\t\tacpi_os_free(sem);\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n#endif\n\n\t*out_handle = (acpi_handle)sem;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_os_delete_semaphore(acpi_handle handle)\n{\n\tsem_t *sem = (sem_t *) handle;\n\n\tif (!sem) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n#ifdef __APPLE__\n\tif (sem_close(sem) == -1) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n#else\n\tif (sem_destroy(sem) == -1) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n#endif\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 msec_timeout)\n{\n\tacpi_status status = AE_OK;\n\tsem_t *sem = (sem_t *) handle;\n\tint ret_val;\n#ifndef ACPI_USE_ALTERNATE_TIMEOUT\n\tstruct timespec time;\n#endif\n\n\tif (!sem) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tswitch (msec_timeout) {\n\t\t \n\tcase 0:\n\n\t\tif (sem_trywait(sem) == -1) {\n\t\t\tstatus = (AE_TIME);\n\t\t}\n\t\tbreak;\n\n\t\t \n\n\tcase ACPI_WAIT_FOREVER:\n\n\t\twhile (((ret_val = sem_wait(sem)) == -1) && (errno == EINTR)) {\n\t\t\tcontinue;\t \n\t\t}\n\t\tif (ret_val != 0) {\n\t\t\tstatus = (AE_TIME);\n\t\t}\n\t\tbreak;\n\n\t\t \n\n\tdefault:\n\n#ifdef ACPI_USE_ALTERNATE_TIMEOUT\n\t\t \n\t\twhile (msec_timeout) {\n\t\t\tif (sem_trywait(sem) == 0) {\n\n\t\t\t\t \n\t\t\t\treturn (AE_OK);\n\t\t\t}\n\n\t\t\tif (msec_timeout >= 10) {\n\t\t\t\tmsec_timeout -= 10;\n\t\t\t\tusleep(10 * ACPI_USEC_PER_MSEC);\t \n\t\t\t} else {\n\t\t\t\tmsec_timeout--;\n\t\t\t\tusleep(ACPI_USEC_PER_MSEC);\t \n\t\t\t}\n\t\t}\n\t\tstatus = (AE_TIME);\n#else\n\t\t \n\t\tif (clock_gettime(CLOCK_REALTIME, &time) == -1) {\n\t\t\tperror(\"clock_gettime\");\n\t\t\treturn (AE_TIME);\n\t\t}\n\n\t\ttime.tv_sec += (msec_timeout / ACPI_MSEC_PER_SEC);\n\t\ttime.tv_nsec +=\n\t\t    ((msec_timeout % ACPI_MSEC_PER_SEC) * ACPI_NSEC_PER_MSEC);\n\n\t\t \n\n\t\tif (time.tv_nsec >= ACPI_NSEC_PER_SEC) {\n\t\t\ttime.tv_sec += (time.tv_nsec / ACPI_NSEC_PER_SEC);\n\t\t\ttime.tv_nsec = (time.tv_nsec % ACPI_NSEC_PER_SEC);\n\t\t}\n\n\t\twhile (((ret_val = sem_timedwait(sem, &time)) == -1)\n\t\t       && (errno == EINTR)) {\n\t\t\tcontinue;\t \n\n\t\t}\n\n\t\tif (ret_val != 0) {\n\t\t\tif (errno != ETIMEDOUT) {\n\t\t\t\tperror(\"sem_timedwait\");\n\t\t\t}\n\t\t\tstatus = (AE_TIME);\n\t\t}\n#endif\n\t\tbreak;\n\t}\n\n\treturn (status);\n}\n\n \n\nacpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)\n{\n\tsem_t *sem = (sem_t *) handle;\n\n\tif (!sem) {\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\tif (sem_post(sem) == -1) {\n\t\treturn (AE_LIMIT);\n\t}\n\n\treturn (AE_OK);\n}\n\n#endif\t\t\t\t \n\n \n\nacpi_status acpi_os_create_lock(acpi_spinlock * out_handle)\n{\n\n\treturn (acpi_os_create_semaphore(1, 1, out_handle));\n}\n\nvoid acpi_os_delete_lock(acpi_spinlock handle)\n{\n\tacpi_os_delete_semaphore(handle);\n}\n\nacpi_cpu_flags acpi_os_acquire_lock(acpi_handle handle)\n{\n\tacpi_os_wait_semaphore(handle, 1, 0xFFFF);\n\treturn (0);\n}\n\nvoid acpi_os_release_lock(acpi_spinlock handle, acpi_cpu_flags flags)\n{\n\tacpi_os_signal_semaphore(handle, 1);\n}\n\n \n\nu32\nacpi_os_install_interrupt_handler(u32 interrupt_number,\n\t\t\t\t  acpi_osd_handler service_routine,\n\t\t\t\t  void *context)\n{\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_os_remove_interrupt_handler(u32 interrupt_number,\n\t\t\t\t acpi_osd_handler service_routine)\n{\n\n\treturn (AE_OK);\n}\n\n \n\nvoid acpi_os_stall(u32 microseconds)\n{\n\n\tif (microseconds) {\n\t\tusleep(microseconds);\n\t}\n}\n\n \n\nvoid acpi_os_sleep(u64 milliseconds)\n{\n\n\t \n\n\tsleep(milliseconds / ACPI_MSEC_PER_SEC);\n\n\t \n\tusleep((milliseconds % ACPI_MSEC_PER_SEC) * ACPI_USEC_PER_MSEC);\n}\n\n \n\nu64 acpi_os_get_timer(void)\n{\n\tstruct timeval time;\n\n\t \n\n\tgettimeofday(&time, NULL);\n\n\t \n\n\treturn (((u64)time.tv_sec * ACPI_100NSEC_PER_SEC) +\n\t\t((u64)time.tv_usec * ACPI_100NSEC_PER_USEC));\n}\n\n \n\nacpi_status\nacpi_os_read_pci_configuration(struct acpi_pci_id *pci_id,\n\t\t\t       u32 pci_register, u64 *value, u32 width)\n{\n\n\t*value = 0;\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_os_write_pci_configuration(struct acpi_pci_id *pci_id,\n\t\t\t\tu32 pci_register, u64 value, u32 width)\n{\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_os_read_port(acpi_io_address address, u32 *value, u32 width)\n{\n\n\tswitch (width) {\n\tcase 8:\n\n\t\t*value = 0xFF;\n\t\tbreak;\n\n\tcase 16:\n\n\t\t*value = 0xFFFF;\n\t\tbreak;\n\n\tcase 32:\n\n\t\t*value = 0xFFFFFFFF;\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status acpi_os_write_port(acpi_io_address address, u32 value, u32 width)\n{\n\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_os_read_memory(acpi_physical_address address, u64 *value, u32 width)\n{\n\n\tswitch (width) {\n\tcase 8:\n\tcase 16:\n\tcase 32:\n\tcase 64:\n\n\t\t*value = 0;\n\t\tbreak;\n\n\tdefault:\n\n\t\treturn (AE_BAD_PARAMETER);\n\t}\n\treturn (AE_OK);\n}\n\n \n\nacpi_status\nacpi_os_write_memory(acpi_physical_address address, u64 value, u32 width)\n{\n\n\treturn (AE_OK);\n}\n\n \n\nu8 acpi_os_readable(void *pointer, acpi_size length)\n{\n\n\treturn (TRUE);\n}\n\n \n\nu8 acpi_os_writable(void *pointer, acpi_size length)\n{\n\n\treturn (TRUE);\n}\n\n \n\nacpi_status acpi_os_signal(u32 function, void *info)\n{\n\n\tswitch (function) {\n\tcase ACPI_SIGNAL_FATAL:\n\n\t\tbreak;\n\n\tcase ACPI_SIGNAL_BREAKPOINT:\n\n\t\tbreak;\n\n\tdefault:\n\n\t\tbreak;\n\t}\n\n\treturn (AE_OK);\n}\n\n \n\n#ifndef ACPI_SINGLE_THREADED\n \n\nacpi_thread_id acpi_os_get_thread_id(void)\n{\n\tpthread_t thread;\n\n\tthread = pthread_self();\n\treturn (ACPI_CAST_PTHREAD_T(thread));\n}\n\n \n\nacpi_status\nacpi_os_execute(acpi_execute_type type,\n\t\tacpi_osd_exec_callback function, void *context)\n{\n\tpthread_t thread;\n\tint ret;\n\n\tret =\n\t    pthread_create(&thread, NULL, (PTHREAD_CALLBACK) function, context);\n\tif (ret) {\n\t\tacpi_os_printf(\"Create thread failed\");\n\t}\n\treturn (0);\n}\n\n#else\t\t\t\t \nacpi_thread_id acpi_os_get_thread_id(void)\n{\n\treturn (1);\n}\n\nacpi_status\nacpi_os_execute(acpi_execute_type type,\n\t\tacpi_osd_exec_callback function, void *context)\n{\n\n\tfunction(context);\n\n\treturn (AE_OK);\n}\n\n#endif\t\t\t\t \n\n \n\nvoid acpi_os_wait_events_complete(void)\n{\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}