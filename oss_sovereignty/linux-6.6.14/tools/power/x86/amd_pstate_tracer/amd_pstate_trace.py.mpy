{
  "module_name": "amd_pstate_trace.py",
  "hash_id": "3a47c2d32409a8e78a0282d0c1a036e5eebd054b11629467a1614ab92ea1493d",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/amd_pstate_tracer/amd_pstate_trace.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n# -*- coding: utf-8 -*-\n#\n\"\"\" This utility can be used to debug and tune the performance of the\nAMD P-State driver. It imports intel_pstate_tracer to analyze AMD P-State\ntrace event.\n\nPrerequisites:\n    Python version 2.7.x or higher\n    gnuplot 5.0 or higher\n    gnuplot-py 1.8 or higher\n    (Most of the distributions have these required packages. They may be called\n     gnuplot-py, phython-gnuplot or phython3-gnuplot, gnuplot-nox, ... )\n\n    Kernel config for Linux trace is enabled\n\n    see print_help(): for Usage and Output details\n\n\"\"\"\nfrom __future__ import print_function\nfrom datetime import datetime\nimport subprocess\nimport os\nimport time\nimport re\nimport signal\nimport sys\nimport getopt\nimport Gnuplot\nfrom numpy import *\nfrom decimal import *\nsys.path.append('../intel_pstate_tracer')\n#import intel_pstate_tracer\nimport intel_pstate_tracer as ipt\n\n__license__ = \"GPL version 2\"\n\nMAX_CPUS = 256\n# Define the csv file columns\nC_COMM = 15\nC_ELAPSED = 14\nC_SAMPLE = 13\nC_DURATION = 12\nC_LOAD = 11\nC_TSC = 10\nC_APERF = 9\nC_MPERF = 8\nC_FREQ = 7\nC_MAX_PERF = 6\nC_DES_PERF = 5\nC_MIN_PERF = 4\nC_USEC = 3\nC_SEC = 2\nC_CPU = 1\n\nglobal sample_num, last_sec_cpu, last_usec_cpu, start_time, test_name, trace_file\n\ngetcontext().prec = 11\n\nsample_num =0\nlast_sec_cpu = [0] * MAX_CPUS\nlast_usec_cpu = [0] * MAX_CPUS\n\ndef plot_per_cpu_freq(cpu_index):\n    \"\"\" Plot per cpu frequency \"\"\"\n\n    file_name = 'cpu{:0>3}.csv'.format(cpu_index)\n    if os.path.exists(file_name):\n        output_png = \"cpu%03d_frequency.png\" % cpu_index\n        g_plot = ipt.common_gnuplot_settings()\n        g_plot('set output \"' + output_png + '\"')\n        g_plot('set yrange [0:7]')\n        g_plot('set ytics 0, 1')\n        g_plot('set ylabel \"CPU Frequency (GHz)\"')\n        g_plot('set title \"{} : frequency : CPU {:0>3} : {:%F %H:%M}\"'.format(test_name, cpu_index, datetime.now()))\n        g_plot('set ylabel \"CPU frequency\"')\n        g_plot('set key off')\n        ipt.set_4_plot_linestyles(g_plot)\n        g_plot('plot \"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 1 axis x1y1'.format(C_ELAPSED, C_FREQ))\n\ndef plot_per_cpu_des_perf(cpu_index):\n    \"\"\" Plot per cpu desired perf \"\"\"\n\n    file_name = 'cpu{:0>3}.csv'.format(cpu_index)\n    if os.path.exists(file_name):\n        output_png = \"cpu%03d_des_perf.png\" % cpu_index\n        g_plot = ipt.common_gnuplot_settings()\n        g_plot('set output \"' + output_png + '\"')\n        g_plot('set yrange [0:255]')\n        g_plot('set ylabel \"des perf\"')\n        g_plot('set title \"{} : cpu des perf : CPU {:0>3} : {:%F %H:%M}\"'.format(test_name, cpu_index, datetime.now()))\n        g_plot('set key off')\n        ipt.set_4_plot_linestyles(g_plot)\n        g_plot('plot \"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 1 axis x1y1'.format(C_ELAPSED, C_DES_PERF))\n\ndef plot_per_cpu_load(cpu_index):\n    \"\"\" Plot per cpu load \"\"\"\n\n    file_name = 'cpu{:0>3}.csv'.format(cpu_index)\n    if os.path.exists(file_name):\n        output_png = \"cpu%03d_load.png\" % cpu_index\n        g_plot = ipt.common_gnuplot_settings()\n        g_plot('set output \"' + output_png + '\"')\n        g_plot('set yrange [0:100]')\n        g_plot('set ytics 0, 10')\n        g_plot('set ylabel \"CPU load (percent)\"')\n        g_plot('set title \"{} : cpu load : CPU {:0>3} : {:%F %H:%M}\"'.format(test_name, cpu_index, datetime.now()))\n        g_plot('set key off')\n        ipt.set_4_plot_linestyles(g_plot)\n        g_plot('plot \"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 1 axis x1y1'.format(C_ELAPSED, C_LOAD))\n\ndef plot_all_cpu_frequency():\n    \"\"\" Plot all cpu frequencies \"\"\"\n\n    output_png = 'all_cpu_frequencies.png'\n    g_plot = ipt.common_gnuplot_settings()\n    g_plot('set output \"' + output_png + '\"')\n    g_plot('set ylabel \"CPU Frequency (GHz)\"')\n    g_plot('set title \"{} : cpu frequencies : {:%F %H:%M}\"'.format(test_name, datetime.now()))\n\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 7 ps 1 title i\".format(C_ELAPSED, C_FREQ)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef plot_all_cpu_des_perf():\n    \"\"\" Plot all cpu desired perf \"\"\"\n\n    output_png = 'all_cpu_des_perf.png'\n    g_plot = ipt.common_gnuplot_settings()\n    g_plot('set output \"' + output_png + '\"')\n    g_plot('set ylabel \"des perf\"')\n    g_plot('set title \"{} : cpu des perf : {:%F %H:%M}\"'.format(test_name, datetime.now()))\n\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 255 ps 1 title i\".format(C_ELAPSED, C_DES_PERF)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef plot_all_cpu_load():\n    \"\"\" Plot all cpu load  \"\"\"\n\n    output_png = 'all_cpu_load.png'\n    g_plot = ipt.common_gnuplot_settings()\n    g_plot('set output \"' + output_png + '\"')\n    g_plot('set yrange [0:100]')\n    g_plot('set ylabel \"CPU load (percent)\"')\n    g_plot('set title \"{} : cpu load : {:%F %H:%M}\"'.format(test_name, datetime.now()))\n\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 255 ps 1 title i\".format(C_ELAPSED, C_LOAD)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef store_csv(cpu_int, time_pre_dec, time_post_dec, min_perf, des_perf, max_perf, freq_ghz, mperf, aperf, tsc, common_comm, load, duration_ms, sample_num, elapsed_time, cpu_mask):\n    \"\"\" Store master csv file information \"\"\"\n\n    global graph_data_present\n\n    if cpu_mask[cpu_int] == 0:\n        return\n\n    try:\n        f_handle = open('cpu.csv', 'a')\n        string_buffer = \"CPU_%03u, %05u, %06u, %u, %u, %u, %.4f, %u, %u, %u, %.2f, %.3f, %u, %.3f, %s\\n\" % (cpu_int, int(time_pre_dec), int(time_post_dec), int(min_perf), int(des_perf), int(max_perf), freq_ghz, int(mperf), int(aperf), int(tsc), load, duration_ms, sample_num, elapsed_time, common_comm)\n        f_handle.write(string_buffer)\n        f_handle.close()\n    except:\n        print('IO error cpu.csv')\n        return\n\n    graph_data_present = True;\n\n\ndef cleanup_data_files():\n    \"\"\" clean up existing data files \"\"\"\n\n    if os.path.exists('cpu.csv'):\n        os.remove('cpu.csv')\n    f_handle = open('cpu.csv', 'a')\n    f_handle.write('common_cpu, common_secs, common_usecs, min_perf, des_perf, max_perf, freq, mperf, aperf, tsc, load, duration_ms, sample_num, elapsed_time, common_comm')\n    f_handle.write('\\n')\n    f_handle.close()\n\ndef read_trace_data(file_name, cpu_mask):\n    \"\"\" Read and parse trace data \"\"\"\n\n    global current_max_cpu\n    global sample_num, last_sec_cpu, last_usec_cpu, start_time\n\n    try:\n        data = open(file_name, 'r').read()\n    except:\n        print('Error opening ', file_name)\n        sys.exit(2)\n\n    for line in data.splitlines():\n        search_obj = \\\n            re.search(r'(^(.*?)\\[)((\\d+)[^\\]])(.*?)(\\d+)([.])(\\d+)(.*?amd_min_perf=)(\\d+)(.*?amd_des_perf=)(\\d+)(.*?amd_max_perf=)(\\d+)(.*?freq=)(\\d+)(.*?mperf=)(\\d+)(.*?aperf=)(\\d+)(.*?tsc=)(\\d+)'\n                      , line)\n\n        if search_obj:\n            cpu = search_obj.group(3)\n            cpu_int = int(cpu)\n            cpu = str(cpu_int)\n\n            time_pre_dec = search_obj.group(6)\n            time_post_dec = search_obj.group(8)\n            min_perf = search_obj.group(10)\n            des_perf = search_obj.group(12)\n            max_perf = search_obj.group(14)\n            freq = search_obj.group(16)\n            mperf = search_obj.group(18)\n            aperf = search_obj.group(20)\n            tsc = search_obj.group(22)\n\n            common_comm = search_obj.group(2).replace(' ', '')\n\n            if sample_num == 0 :\n                start_time = Decimal(time_pre_dec) + Decimal(time_post_dec) / Decimal(1000000)\n            sample_num += 1\n\n            if last_sec_cpu[cpu_int] == 0 :\n                last_sec_cpu[cpu_int] = time_pre_dec\n                last_usec_cpu[cpu_int] = time_post_dec\n            else :\n                duration_us = (int(time_pre_dec) - int(last_sec_cpu[cpu_int])) * 1000000 + (int(time_post_dec) - int(last_usec_cpu[cpu_int]))\n                duration_ms = Decimal(duration_us) / Decimal(1000)\n                last_sec_cpu[cpu_int] = time_pre_dec\n                last_usec_cpu[cpu_int] = time_post_dec\n                elapsed_time = Decimal(time_pre_dec) + Decimal(time_post_dec) / Decimal(1000000) - start_time\n                load = Decimal(int(mperf)*100)/ Decimal(tsc)\n                freq_ghz = Decimal(freq)/Decimal(1000000)\n                store_csv(cpu_int, time_pre_dec, time_post_dec, min_perf, des_perf, max_perf, freq_ghz, mperf, aperf, tsc, common_comm, load, duration_ms, sample_num, elapsed_time, cpu_mask)\n\n            if cpu_int > current_max_cpu:\n                current_max_cpu = cpu_int\n# Now separate the main overall csv file into per CPU csv files.\n    ipt.split_csv(current_max_cpu, cpu_mask)\n\n\ndef signal_handler(signal, frame):\n    print(' SIGINT: Forcing cleanup before exit.')\n    if interval:\n        ipt.disable_trace(trace_file)\n        ipt.clear_trace_file()\n        ipt.free_trace_buffer()\n        sys.exit(0)\n\ntrace_file = \"/sys/kernel/tracing/events/amd_cpu/enable\"\nsignal.signal(signal.SIGINT, signal_handler)\n\ninterval = \"\"\nfile_name = \"\"\ncpu_list = \"\"\ntest_name = \"\"\nmemory = \"10240\"\ngraph_data_present = False;\n\nvalid1 = False\nvalid2 = False\n\ncpu_mask = zeros((MAX_CPUS,), dtype=int)\n\n\ntry:\n    opts, args = getopt.getopt(sys.argv[1:],\"ht:i:c:n:m:\",[\"help\",\"trace_file=\",\"interval=\",\"cpu=\",\"name=\",\"memory=\"])\nexcept getopt.GetoptError:\n    ipt.print_help('amd_pstate')\n    sys.exit(2)\nfor opt, arg in opts:\n    if opt == '-h':\n        print()\n        sys.exit()\n    elif opt in (\"-t\", \"--trace_file\"):\n        valid1 = True\n        location = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))\n        file_name = os.path.join(location, arg)\n    elif opt in (\"-i\", \"--interval\"):\n        valid1 = True\n        interval = arg\n    elif opt in (\"-c\", \"--cpu\"):\n        cpu_list = arg\n    elif opt in (\"-n\", \"--name\"):\n        valid2 = True\n        test_name = arg\n    elif opt in (\"-m\", \"--memory\"):\n        memory = arg\n\nif not (valid1 and valid2):\n    ipt.print_help('amd_pstate')\n    sys.exit()\n\nif cpu_list:\n    for p in re.split(\"[,]\", cpu_list):\n        if int(p) < MAX_CPUS :\n            cpu_mask[int(p)] = 1\nelse:\n    for i in range (0, MAX_CPUS):\n        cpu_mask[i] = 1\n\nif not os.path.exists('results'):\n    os.mkdir('results')\n    ipt.fix_ownership('results')\n\nos.chdir('results')\nif os.path.exists(test_name):\n    print('The test name directory already exists. Please provide a unique test name. Test re-run not supported, yet.')\n    sys.exit()\nos.mkdir(test_name)\nipt.fix_ownership(test_name)\nos.chdir(test_name)\n\ncur_version = sys.version_info\nprint('python version (should be >= 2.7):')\nprint(cur_version)\n\ncleanup_data_files()\n\nif interval:\n    file_name = \"/sys/kernel/tracing/trace\"\n    ipt.clear_trace_file()\n    ipt.set_trace_buffer_size(memory)\n    ipt.enable_trace(trace_file)\n    time.sleep(int(interval))\n    ipt.disable_trace(trace_file)\n\ncurrent_max_cpu = 0\n\nread_trace_data(file_name, cpu_mask)\n\nif interval:\n    ipt.clear_trace_file()\n    ipt.free_trace_buffer()\n\nif graph_data_present == False:\n    print('No valid data to plot')\n    sys.exit(2)\n\nfor cpu_no in range(0, current_max_cpu + 1):\n    plot_per_cpu_freq(cpu_no)\n    plot_per_cpu_des_perf(cpu_no)\n    plot_per_cpu_load(cpu_no)\n\nplot_all_cpu_des_perf()\nplot_all_cpu_frequency()\nplot_all_cpu_load()\n\nfor root, dirs, files in os.walk('.'):\n    for f in files:\n        ipt.fix_ownership(f)\n\nos.chdir('../../')\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}