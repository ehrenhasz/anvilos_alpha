{
  "module_name": "isst-daemon.c",
  "hash_id": "cdf818f0e8c56099dd3f90d1c7329277ee40f19159504aa5b0e48b22536049e6",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/intel-speed-select/isst-daemon.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <getopt.h>\n#include <signal.h>\n#include <time.h>\n\n#include \"isst.h\"\n\nstatic int per_package_levels_info[MAX_PACKAGE_COUNT][MAX_DIE_PER_PACKAGE][MAX_PUNIT_PER_DIE];\nstatic time_t per_package_levels_tm[MAX_PACKAGE_COUNT][MAX_DIE_PER_PACKAGE][MAX_PUNIT_PER_DIE];\n\nstatic void init_levels(void)\n{\n\tint i, j, k;\n\n\tfor (i = 0; i < MAX_PACKAGE_COUNT; ++i)\n\t\tfor (j = 0; j < MAX_DIE_PER_PACKAGE; ++j)\n\t\t\tfor (k = 0; k < MAX_PUNIT_PER_DIE; ++k)\n\t\t\t\tper_package_levels_info[i][j][k] = -1;\n}\n\nvoid process_level_change(struct isst_id *id)\n{\n\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\tstruct isst_pkg_ctdp pkg_dev;\n\ttime_t tm;\n\tint ret;\n\n\tif (id->pkg < 0 || id->die < 0 || id->punit < 0) {\n\t\tdebug_printf(\"Invalid package/die info for cpu:%d\\n\", id->cpu);\n\t\treturn;\n\t}\n\n\ttm = time(NULL);\n\tif (tm - per_package_levels_tm[id->pkg][id->die][id->punit] < 2)\n\t\treturn;\n\n\tper_package_levels_tm[id->pkg][id->die][id->punit] = tm;\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret) {\n\t\tdebug_printf(\"Can't get tdp levels for cpu:%d\\n\", id->cpu);\n\t\treturn;\n\t}\n\n\tdebug_printf(\"Get Config level %d pkg:%d die:%d current_level:%d\\n\", id->cpu,\n\t\t      id->pkg, id->die, pkg_dev.current_level);\n\n\tif (pkg_dev.locked) {\n\t\tdebug_printf(\"config TDP s locked \\n\");\n\t\treturn;\n\t}\n\n\tif (per_package_levels_info[id->pkg][id->die][id->punit] == pkg_dev.current_level)\n\t\treturn;\n\n\tdebug_printf(\"**Config level change for cpu:%d pkg:%d die:%d from %d to %d\\n\",\n\t\t      id->cpu, id->pkg, id->die, per_package_levels_info[id->pkg][id->die][id->punit],\n\t\t      pkg_dev.current_level);\n\n\tper_package_levels_info[id->pkg][id->die][id->punit] = pkg_dev.current_level;\n\n\tctdp_level.core_cpumask_size =\n\t\talloc_cpu_set(&ctdp_level.core_cpumask);\n\tret = isst_get_coremask_info(id, pkg_dev.current_level, &ctdp_level);\n\tif (ret) {\n\t\tfree_cpu_set(ctdp_level.core_cpumask);\n\t\tdebug_printf(\"Can't get core_mask:%d\\n\", id->cpu);\n\t\treturn;\n\t}\n\n\tif (use_cgroupv2()) {\n\t\tint ret;\n\n\t\tret = enable_cpuset_controller();\n\t\tif (ret)\n\t\t\tgoto use_offline;\n\n\t\tisolate_cpus(id, ctdp_level.core_cpumask_size, ctdp_level.core_cpumask, pkg_dev.current_level);\n\n\t\tgoto free_mask;\n\t}\n\nuse_offline:\n\tif (ctdp_level.cpu_count) {\n\t\tint i, max_cpus = get_topo_max_cpus();\n\t\tfor (i = 0; i < max_cpus; ++i) {\n\t\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\t\tcontinue;\n\t\t\tif (CPU_ISSET_S(i, ctdp_level.core_cpumask_size, ctdp_level.core_cpumask)) {\n\t\t\t\tfprintf(stderr, \"online cpu %d\\n\", i);\n\t\t\t\tset_cpu_online_offline(i, 1);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"offline cpu %d\\n\", i);\n\t\t\t\tset_cpu_online_offline(i, 0);\n\t\t\t}\n\t\t}\n\t}\nfree_mask:\n\tfree_cpu_set(ctdp_level.core_cpumask);\n}\n\nstatic void _poll_for_config_change(struct isst_id *id, void *arg1, void *arg2,\n\t\t\t\t    void *arg3, void *arg4)\n{\n\tprocess_level_change(id);\n}\n\nstatic void poll_for_config_change(void)\n{\n\tfor_each_online_power_domain_in_set(_poll_for_config_change, NULL, NULL,\n\t\t\t\t       NULL, NULL);\n}\n\nstatic int done = 0;\nstatic int pid_file_handle;\n\nstatic void signal_handler(int sig)\n{\n\tswitch (sig) {\n\tcase SIGINT:\n\tcase SIGTERM:\n\t\tdone = 1;\n\t\thfi_exit();\n\t\texit(0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void daemonize(char *rundir, char *pidfile)\n{\n\tint pid, sid, i;\n\tchar str[10];\n\tstruct sigaction sig_actions;\n\tsigset_t sig_set;\n\tint ret;\n\n\tif (getppid() == 1)\n\t\treturn;\n\n\tsigemptyset(&sig_set);\n\tsigaddset(&sig_set, SIGCHLD);\n\tsigaddset(&sig_set, SIGTSTP);\n\tsigaddset(&sig_set, SIGTTOU);\n\tsigaddset(&sig_set, SIGTTIN);\n\tsigprocmask(SIG_BLOCK, &sig_set, NULL);\n\n\tsig_actions.sa_handler = signal_handler;\n\tsigemptyset(&sig_actions.sa_mask);\n\tsig_actions.sa_flags = 0;\n\n\tsigaction(SIGHUP, &sig_actions, NULL);\n\tsigaction(SIGTERM, &sig_actions, NULL);\n\tsigaction(SIGINT, &sig_actions, NULL);\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\t \n\t\texit(EXIT_FAILURE);\n\t}\n\tif (pid > 0)\n\t\texit(EXIT_SUCCESS);\n\n\tumask(027);\n\n\tsid = setsid();\n\tif (sid < 0)\n\t\texit(EXIT_FAILURE);\n\n\t \n\tfor (i = getdtablesize(); i >= 0; --i)\n\t\tclose(i);\n\n\ti = open(\"/dev/null\", O_RDWR);\n\tif (i < 0)\n\t\texit(EXIT_FAILURE);\n\n\tret = dup(i);\n\tif (ret == -1)\n\t\texit(EXIT_FAILURE);\n\n\tret = chdir(rundir);\n\tif (ret == -1)\n\t\texit(EXIT_FAILURE);\n\n\tpid_file_handle = open(pidfile, O_RDWR | O_CREAT, 0600);\n\tif (pid_file_handle == -1) {\n\t\t \n\t\texit(1);\n\t}\n\t \n#ifdef LOCKF_SUPPORT\n\tif (lockf(pid_file_handle, F_TLOCK, 0) == -1) {\n#else\n\tif (flock(pid_file_handle, LOCK_EX|LOCK_NB) < 0) {\n#endif\n\t\t \n\t\tfprintf(stderr, \"Couldn't get lock file %d\\n\", getpid());\n\t\texit(1);\n\t}\n\tsnprintf(str, sizeof(str), \"%d\\n\", getpid());\n\tret = write(pid_file_handle, str, strlen(str));\n\tif (ret == -1)\n\t\texit(EXIT_FAILURE);\n\n\tclose(i);\n}\n\nint isst_daemon(int debug_mode, int poll_interval, int no_daemon)\n{\n\tint ret;\n\n\tif (!no_daemon && poll_interval < 0 && !debug_mode) {\n\t\tfprintf(stderr, \"OOB mode is enabled and will run as daemon\\n\");\n\t\tdaemonize((char *) \"/tmp/\",\n\t\t\t\t(char *)\"/tmp/hfi-events.pid\");\n\t} else {\n\t\tsignal(SIGINT, signal_handler);\n\t}\n\n\tinit_levels();\n\n\tif (poll_interval < 0) {\n\t\tret = hfi_main();\n\t\tif (ret) {\n\t\t\tfprintf(stderr, \"HFI initialization failed\\n\");\n\t\t}\n\t\tfprintf(stderr, \"Must specify poll-interval\\n\");\n\t\treturn ret;\n\t}\n\n\tdebug_printf(\"Starting loop\\n\");\n\twhile (!done) {\n\t\tsleep(poll_interval);\n\t\tpoll_for_config_change();\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}