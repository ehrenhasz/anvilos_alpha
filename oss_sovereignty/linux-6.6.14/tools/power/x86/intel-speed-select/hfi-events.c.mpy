{
  "module_name": "hfi-events.c",
  "hash_id": "78be54f897042fce7310445d941a4d747f59d55fb12402f1cc3850378528cf07",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/intel-speed-select/hfi-events.c",
  "human_readable_source": "\n \n\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <getopt.h>\n#include <signal.h>\n#include <netlink/genl/genl.h>\n#include <netlink/genl/family.h>\n#include <netlink/genl/ctrl.h>\n\n#include <linux/thermal.h>\n#include \"isst.h\"\n\nstruct hfi_event_data {\n\tstruct nl_sock *nl_handle;\n\tstruct nl_cb *nl_cb;\n};\n\nstruct hfi_event_data drv;\n\nstatic int ack_handler(struct nl_msg *msg, void *arg)\n{\n\tint *err = arg;\n\t*err = 0;\n\treturn NL_STOP;\n}\n\nstatic int finish_handler(struct nl_msg *msg, void *arg)\n{\n\tint *ret = arg;\n\t*ret = 0;\n\treturn NL_SKIP;\n}\n\nstatic int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err,\n\t\t\t void *arg)\n{\n\tint *ret = arg;\n\t*ret = err->error;\n\treturn NL_SKIP;\n}\n\nstatic int seq_check_handler(struct nl_msg *msg, void *arg)\n{\n\treturn NL_OK;\n}\n\nstatic int send_and_recv_msgs(struct hfi_event_data *drv,\n\t\t\t      struct nl_msg *msg,\n\t\t\t      int (*valid_handler)(struct nl_msg *, void *),\n\t\t\t      void *valid_data)\n{\n\tstruct nl_cb *cb;\n\tint err = -ENOMEM;\n\n\tcb = nl_cb_clone(drv->nl_cb);\n\tif (!cb)\n\t\tgoto out;\n\n\terr = nl_send_auto_complete(drv->nl_handle, msg);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = 1;\n\n\tnl_cb_err(cb, NL_CB_CUSTOM, error_handler, &err);\n\tnl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, &err);\n\tnl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, &err);\n\n\tif (valid_handler)\n\t\tnl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM,\n\t\t\t  valid_handler, valid_data);\n\n\twhile (err > 0)\n\t\tnl_recvmsgs(drv->nl_handle, cb);\n out:\n\tnl_cb_put(cb);\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstruct family_data {\n\tconst char *group;\n\tint id;\n};\n\nstatic int family_handler(struct nl_msg *msg, void *arg)\n{\n\tstruct family_data *res = arg;\n\tstruct nlattr *tb[CTRL_ATTR_MAX + 1];\n\tstruct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));\n\tstruct nlattr *mcgrp;\n\tint i;\n\n\tnla_parse(tb, CTRL_ATTR_MAX, genlmsg_attrdata(gnlh, 0),\n\t\t  genlmsg_attrlen(gnlh, 0), NULL);\n\tif (!tb[CTRL_ATTR_MCAST_GROUPS])\n\t\treturn NL_SKIP;\n\n\tnla_for_each_nested(mcgrp, tb[CTRL_ATTR_MCAST_GROUPS], i) {\n\t\tstruct nlattr *tb2[CTRL_ATTR_MCAST_GRP_MAX + 1];\n\t\tnla_parse(tb2, CTRL_ATTR_MCAST_GRP_MAX, nla_data(mcgrp),\n\t\t\t  nla_len(mcgrp), NULL);\n\t\tif (!tb2[CTRL_ATTR_MCAST_GRP_NAME] ||\n\t\t    !tb2[CTRL_ATTR_MCAST_GRP_ID] ||\n\t\t    strncmp(nla_data(tb2[CTRL_ATTR_MCAST_GRP_NAME]),\n\t\t\t\tres->group,\n\t\t\t\tnla_len(tb2[CTRL_ATTR_MCAST_GRP_NAME])) != 0)\n\t\t\tcontinue;\n\t\tres->id = nla_get_u32(tb2[CTRL_ATTR_MCAST_GRP_ID]);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl_get_multicast_id(struct hfi_event_data *drv,\n\t\t\t       const char *family, const char *group)\n{\n\tstruct nl_msg *msg;\n\tint ret = -1;\n\tstruct family_data res = { group, -ENOENT };\n\n\tmsg = nlmsg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tgenlmsg_put(msg, 0, 0, genl_ctrl_resolve(drv->nl_handle, \"nlctrl\"),\n\t\t    0, 0, CTRL_CMD_GETFAMILY, 0);\n\tNLA_PUT_STRING(msg, CTRL_ATTR_FAMILY_NAME, family);\n\n\tret = send_and_recv_msgs(drv, msg, family_handler, &res);\n\tmsg = NULL;\n\tif (ret == 0)\n\t\tret = res.id;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn ret;\n}\n\nstruct perf_cap {\n\tint cpu;\n\tint perf;\n\tint eff;\n};\n\nstatic void process_hfi_event(struct perf_cap *perf_cap)\n{\n\tstruct isst_id id;\n\n\tset_isst_id(&id, perf_cap->cpu);\n\tprocess_level_change(&id);\n}\n\nstatic int handle_event(struct nl_msg *n, void *arg)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(n);\n\tstruct genlmsghdr *genlhdr = genlmsg_hdr(nlh);\n\tstruct nlattr *attrs[THERMAL_GENL_ATTR_MAX + 1];\n\tint ret;\n\tstruct perf_cap perf_cap = {0};\n\n\tret = genlmsg_parse(nlh, 0, attrs, THERMAL_GENL_ATTR_MAX, NULL);\n\n\tdebug_printf(\"Received event %d parse_rer:%d\\n\", genlhdr->cmd, ret);\n\tif (genlhdr->cmd == THERMAL_GENL_EVENT_CPU_CAPABILITY_CHANGE) {\n\t\tstruct nlattr *cap;\n\t\tint j, index = 0;\n\n\t\tdebug_printf(\"THERMAL_GENL_EVENT_CPU_CAPABILITY_CHANGE\\n\");\n\t\tnla_for_each_nested(cap, attrs[THERMAL_GENL_ATTR_CPU_CAPABILITY], j) {\n\t\t\tswitch (index) {\n\t\t\tcase 0:\n\t\t\t\tperf_cap.cpu = nla_get_u32(cap);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tperf_cap.perf = nla_get_u32(cap);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tperf_cap.eff = nla_get_u32(cap);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++index;\n\t\t\tif (index == 3) {\n\t\t\t\tindex = 0;\n\t\t\t\tprocess_hfi_event(&perf_cap);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int _hfi_exit;\n\nstatic int check_hf_suport(void)\n{\n\tunsigned int eax = 0, ebx = 0, ecx = 0, edx = 0;\n\n\t__cpuid(6, eax, ebx, ecx, edx);\n\tif (eax & BIT(19))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint hfi_main(void)\n{\n\tstruct nl_sock *sock;\n\tstruct nl_cb *cb;\n\tint err = 0;\n\tint mcast_id;\n\n\tif (!check_hf_suport()) {\n\t\tfprintf(stderr, \"CPU Doesn't support HFI\\n\");\n\t\treturn -1;\n\t}\n\n\tsock = nl_socket_alloc();\n\tif (!sock) {\n\t\tfprintf(stderr, \"nl_socket_alloc failed\\n\");\n\t\treturn -1;\n\t}\n\n\tif (genl_connect(sock)) {\n\t\tfprintf(stderr, \"genl_connect(sk_event) failed\\n\");\n\t\tgoto free_sock;\n\t}\n\n\tdrv.nl_handle = sock;\n\tdrv.nl_cb = cb = nl_cb_alloc(NL_CB_DEFAULT);\n\tif (drv.nl_cb == NULL) {\n\t\tprintf(\"Failed to allocate netlink callbacks\");\n\t\tgoto free_sock;\n\t}\n\n\tmcast_id = nl_get_multicast_id(&drv, THERMAL_GENL_FAMILY_NAME,\n\t\t\t\t   THERMAL_GENL_EVENT_GROUP_NAME);\n\tif (mcast_id < 0) {\n\t\tfprintf(stderr, \"nl_get_multicast_id failed\\n\");\n\t\tgoto free_sock;\n\t}\n\n\tif (nl_socket_add_membership(sock, mcast_id)) {\n\t\tfprintf(stderr, \"nl_socket_add_membership failed\");\n\t\tgoto free_sock;\n\t}\n\n\tnl_cb_set(cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM, seq_check_handler, 0);\n\tnl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, handle_event, NULL);\n\n\tdebug_printf(\"hfi is initialized\\n\");\n\n\twhile (!_hfi_exit && !err) {\n\t\terr = nl_recvmsgs(sock, cb);\n\t\tdebug_printf(\"nl_recv_message err:%d\\n\", err);\n\t}\n\n\treturn 0;\n\n\t \nfree_sock:\n\tnl_socket_free(sock);\n\n\treturn -1;\n}\n\nvoid hfi_exit(void)\n{\n\t_hfi_exit = 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}