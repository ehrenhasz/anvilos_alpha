{
  "module_name": "isst-core-mbox.c",
  "hash_id": "949f0b421050e7ae0e65f2eabbe4908133c25e8829f405aaf117d59c4cea2443",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/intel-speed-select/isst-core-mbox.c",
  "human_readable_source": "\n \n#include \"isst.h\"\n\nstatic int mbox_delay;\nstatic int mbox_retries = 3;\n\n#define MAX_TRL_LEVELS_EMR\t5\n\nstatic int mbox_get_disp_freq_multiplier(void)\n{\n        return DISP_FREQ_MULTIPLIER;\n}\n\nstatic int mbox_get_trl_max_levels(void)\n{\n\tif (is_emr_platform())\n\t\treturn MAX_TRL_LEVELS_EMR;\n\n        return 3;\n}\n\nstatic char *mbox_get_trl_level_name(int level)\n{\n\tif (is_emr_platform()) {\n\t\tstatic char level_str[18];\n\n\t\tif (level >= MAX_TRL_LEVELS_EMR)\n\t\t\treturn NULL;\n\n\t\tsnprintf(level_str, sizeof(level_str), \"level-%d\", level);\n\t\treturn level_str;\n\t}\n\n        switch (level) {\n        case 0:\n                return \"sse\";\n        case 1:\n                return \"avx2\";\n        case 2:\n                return \"avx512\";\n        default:\n                return NULL;\n        }\n}\n\nstatic void mbox_update_platform_param(enum isst_platform_param param, int value)\n{\n\tswitch (param) {\n\tcase ISST_PARAM_MBOX_DELAY:\n\t\tmbox_delay = value;\n\t\tbreak;\n\tcase ISST_PARAM_MBOX_RETRIES:\n\t\tmbox_retries = value;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mbox_is_punit_valid(struct isst_id *id)\n{\n\tif (id->cpu < 0)\n\t\treturn 0;\n\n\tif (id->pkg < 0 || id->die < 0 || id->punit)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int _send_mmio_command(unsigned int cpu, unsigned int reg, int write,\n\t\t\t\t  unsigned int *value)\n{\n\tstruct isst_if_io_regs io_regs;\n\tconst char *pathname = \"/dev/isst_interface\";\n\tint cmd;\n\tFILE *outf = get_output_file();\n\tint fd;\n\n\tdebug_printf(\"mmio_cmd cpu:%d reg:%d write:%d\\n\", cpu, reg, write);\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\terr(-1, \"%s open failed\", pathname);\n\n\tio_regs.req_count = 1;\n\tio_regs.io_reg[0].logical_cpu = cpu;\n\tio_regs.io_reg[0].reg = reg;\n\tcmd = ISST_IF_IO_CMD;\n\tif (write) {\n\t\tio_regs.io_reg[0].read_write = 1;\n\t\tio_regs.io_reg[0].value = *value;\n\t} else {\n\t\tio_regs.io_reg[0].read_write = 0;\n\t}\n\n\tif (ioctl(fd, cmd, &io_regs) == -1) {\n\t\tif (errno == ENOTTY) {\n\t\t\tperror(\"ISST_IF_IO_COMMAND\\n\");\n\t\t\tfprintf(stderr, \"Check presence of kernel modules: isst_if_mmio\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tfprintf(outf, \"Error: mmio_cmd cpu:%d reg:%x read_write:%x\\n\",\n\t\t\tcpu, reg, write);\n\t} else {\n\t\tif (!write)\n\t\t\t*value = io_regs.io_reg[0].value;\n\n\t\tdebug_printf(\n\t\t\t\"mmio_cmd response: cpu:%d reg:%x rd_write:%x resp:%x\\n\",\n\t\t\tcpu, reg, write, *value);\n\t}\n\n\tclose(fd);\n\n\treturn 0;\n}\n\nint _send_mbox_command(unsigned int cpu, unsigned char command,\n\t\t\t   unsigned char sub_command, unsigned int parameter,\n\t\t\t   unsigned int req_data, unsigned int *resp)\n{\n\tconst char *pathname = \"/dev/isst_interface\";\n\tint fd, retry;\n\tstruct isst_if_mbox_cmds mbox_cmds = { 0 };\n\n\tdebug_printf(\n\t\t\"mbox_send: cpu:%d command:%x sub_command:%x parameter:%x req_data:%x\\n\",\n\t\tcpu, command, sub_command, parameter, req_data);\n\n\tif (!is_skx_based_platform() && command == CONFIG_CLOS &&\n\t    sub_command != CLOS_PM_QOS_CONFIG) {\n\t\tunsigned int value;\n\t\tint write = 0;\n\t\tint clos_id, core_id, ret = 0;\n\n\t\tdebug_printf(\"CPU %d\\n\", cpu);\n\n\t\tif (parameter & BIT(MBOX_CMD_WRITE_BIT)) {\n\t\t\tvalue = req_data;\n\t\t\twrite = 1;\n\t\t}\n\n\t\tswitch (sub_command) {\n\t\tcase CLOS_PQR_ASSOC:\n\t\t\tcore_id = parameter & 0xff;\n\t\t\tret = _send_mmio_command(\n\t\t\t\tcpu, PQR_ASSOC_OFFSET + core_id * 4, write,\n\t\t\t\t&value);\n\t\t\tif (!ret && !write)\n\t\t\t\t*resp = value;\n\t\t\tbreak;\n\t\tcase CLOS_PM_CLOS:\n\t\t\tclos_id = parameter & 0x03;\n\t\t\tret = _send_mmio_command(\n\t\t\t\tcpu, PM_CLOS_OFFSET + clos_id * 4, write,\n\t\t\t\t&value);\n\t\t\tif (!ret && !write)\n\t\t\t\t*resp = value;\n\t\t\tbreak;\n\t\tcase CLOS_STATUS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tmbox_cmds.cmd_count = 1;\n\tmbox_cmds.mbox_cmd[0].logical_cpu = cpu;\n\tmbox_cmds.mbox_cmd[0].command = command;\n\tmbox_cmds.mbox_cmd[0].sub_command = sub_command;\n\tmbox_cmds.mbox_cmd[0].parameter = parameter;\n\tmbox_cmds.mbox_cmd[0].req_data = req_data;\n\n\tif (mbox_delay)\n\t\tusleep(mbox_delay * 1000);\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\terr(-1, \"%s open failed\", pathname);\n\n\tretry = mbox_retries;\n\tdo {\n\t\tif (ioctl(fd, ISST_IF_MBOX_COMMAND, &mbox_cmds) == -1) {\n\t\t\tif (errno == ENOTTY) {\n\t\t\t\tperror(\"ISST_IF_MBOX_COMMAND\\n\");\n\t\t\t\tfprintf(stderr, \"Check presence of kernel modules: isst_if_mbox_pci or isst_if_mbox_msr\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tdebug_printf(\n\t\t\t\t\"Error: mbox_cmd cpu:%d command:%x sub_command:%x parameter:%x req_data:%x errorno:%d\\n\",\n\t\t\t\tcpu, command, sub_command, parameter, req_data, errno);\n\t\t\t--retry;\n\t\t} else {\n\t\t\t*resp = mbox_cmds.mbox_cmd[0].resp_data;\n\t\t\tdebug_printf(\n\t\t\t\t\"mbox_cmd response: cpu:%d command:%x sub_command:%x parameter:%x req_data:%x resp:%x\\n\",\n\t\t\t\tcpu, command, sub_command, parameter, req_data, *resp);\n\t\t\tbreak;\n\t\t}\n\t} while (retry);\n\n\tclose(fd);\n\n\tif (!retry) {\n\t\tdebug_printf(\"Failed mbox command even after retries\\n\");\n\t\treturn -1;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int mbox_read_pm_config(struct isst_id *id, int *cp_state, int *cp_cap)\n{\n\tunsigned int resp;\n\tint ret;\n\n\tret = _send_mbox_command(id->cpu, READ_PM_CONFIG, PM_FEATURE, 0, 0,\n\t\t\t\t\t&resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d READ_PM_CONFIG resp:%x\\n\", id->cpu, resp);\n\n\t*cp_state = resp & BIT(16);\n\t*cp_cap = resp & BIT(0) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int mbox_get_config_levels(struct isst_id *id, struct isst_pkg_ctdp *pkg_dev)\n{\n\tunsigned int resp;\n\tint ret;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t     CONFIG_TDP_GET_LEVELS_INFO, 0, 0, &resp);\n\tif (ret) {\n\t\tpkg_dev->levels = 0;\n\t\tpkg_dev->locked = 1;\n\t\tpkg_dev->current_level = 0;\n\t\tpkg_dev->version = 0;\n\t\tpkg_dev->enabled = 0;\n\t\treturn 0;\n\t}\n\n\tdebug_printf(\"cpu:%d CONFIG_TDP_GET_LEVELS_INFO resp:%x\\n\", id->cpu, resp);\n\n\tpkg_dev->version = resp & 0xff;\n\tpkg_dev->levels = (resp >> 8) & 0xff;\n\tpkg_dev->current_level = (resp >> 16) & 0xff;\n\tpkg_dev->locked = !!(resp & BIT(24));\n\tpkg_dev->enabled = !!(resp & BIT(31));\n\n\treturn 0;\n}\n\nstatic int mbox_get_ctdp_control(struct isst_id *id, int config_index,\n\t\t\t  struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tint cp_state, cp_cap;\n\tunsigned int resp;\n\tint ret;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t     CONFIG_TDP_GET_TDP_CONTROL, 0,\n\t\t\t\t     config_index, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tctdp_level->fact_support = resp & BIT(0);\n\tctdp_level->pbf_support = !!(resp & BIT(1));\n\tctdp_level->fact_enabled = !!(resp & BIT(16));\n\tctdp_level->pbf_enabled = !!(resp & BIT(17));\n\n\tret = isst_read_pm_config(id, &cp_state, &cp_cap);\n\tif (ret) {\n\t\tdebug_printf(\"cpu:%d pm_config is not supported\\n\", id->cpu);\n\t} else {\n\t\tdebug_printf(\"cpu:%d pm_config SST-CP state:%d cap:%d\\n\", id->cpu, cp_state, cp_cap);\n\t\tctdp_level->sst_cp_support = cp_cap;\n\t\tctdp_level->sst_cp_enabled = cp_state;\n\t}\n\n\tdebug_printf(\n\t\t\"cpu:%d CONFIG_TDP_GET_TDP_CONTROL resp:%x fact_support:%d pbf_support: %d fact_enabled:%d pbf_enabled:%d\\n\",\n\t\tid->cpu, resp, ctdp_level->fact_support, ctdp_level->pbf_support,\n\t\tctdp_level->fact_enabled, ctdp_level->pbf_enabled);\n\n\treturn 0;\n}\n\nstatic void _get_uncore_p0_p1_info(struct isst_id *id, int config_index,\n\t\t\t\tstruct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tunsigned int resp;\n\tint ret;\n\n\tctdp_level->uncore_pm = 0;\n\tctdp_level->uncore_p0 = 0;\n\tctdp_level->uncore_p1 = 0;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t     CONFIG_TDP_GET_RATIO_INFO, 0,\n\t\t\t\t     (BIT(16) | config_index) , &resp);\n\tif (ret) {\n\t\tgoto try_uncore_mbox;\n\t}\n\n\tctdp_level->uncore_p0 = resp & GENMASK(7, 0);\n\tctdp_level->uncore_p1 = (resp & GENMASK(15, 8)) >> 8;\n\tctdp_level->uncore_pm = (resp & GENMASK(31, 24)) >> 24;\n\n\tdebug_printf(\n\t\t\"cpu:%d ctdp:%d CONFIG_TDP_GET_RATIO_INFO resp:%x uncore p0:%d uncore p1:%d uncore pm:%d\\n\",\n\t\tid->cpu, config_index, resp, ctdp_level->uncore_p0, ctdp_level->uncore_p1,\n\t\tctdp_level->uncore_pm);\n\n\treturn;\n\ntry_uncore_mbox:\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t     CONFIG_TDP_GET_UNCORE_P0_P1_INFO, 0,\n\t\t\t\t     config_index, &resp);\n\tif (ret) {\n\t\tctdp_level->uncore_p0 = 0;\n\t\tctdp_level->uncore_p1 = 0;\n\t\treturn;\n\t}\n\n\tctdp_level->uncore_p0 = resp & GENMASK(7, 0);\n\tctdp_level->uncore_p1 = (resp & GENMASK(15, 8)) >> 8;\n\tdebug_printf(\n\t\t\"cpu:%d ctdp:%d CONFIG_TDP_GET_UNCORE_P0_P1_INFO resp:%x uncore p0:%d uncore p1:%d\\n\",\n\t\tid->cpu, config_index, resp, ctdp_level->uncore_p0,\n\t\tctdp_level->uncore_p1);\n}\n\nstatic int _set_uncore_min_max(struct isst_id *id, int max, int freq)\n{\n\tchar buffer[128], freq_str[16];\n\tint fd, ret, len;\n\n\tif (max)\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/intel_uncore_frequency/package_%02d_die_%02d/max_freq_khz\", id->pkg, id->die);\n\telse\n\t        snprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/intel_uncore_frequency/package_%02d_die_%02d/min_freq_khz\", id->pkg, id->die);\n\n\tfd = open(buffer, O_WRONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tsnprintf(freq_str, sizeof(freq_str), \"%d\", freq);\n\tlen = strlen(freq_str);\n\tret = write(fd, freq_str, len);\n\tif (ret == -1) {\n\t\tclose(fd);\n\t\treturn ret;\n\t}\n\tclose(fd);\n\n\treturn 0;\n}\n\nstatic void mbox_adjust_uncore_freq(struct isst_id *id, int config_index,\n\t\t\t\tstruct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\t_get_uncore_p0_p1_info(id, config_index, ctdp_level);\n\tif (ctdp_level->uncore_pm)\n\t\t_set_uncore_min_max(id, 0, ctdp_level->uncore_pm * 100000);\n\n\tif (ctdp_level->uncore_p0)\n\t\t_set_uncore_min_max(id, 1, ctdp_level->uncore_p0 * 100000);\n}\n\nstatic void _get_p1_info(struct isst_id *id, int config_index,\n\t\t      struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tunsigned int resp;\n\tint ret;\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP, CONFIG_TDP_GET_P1_INFO, 0,\n\t\t\t\t     config_index, &resp);\n\tif (ret) {\n\t\tctdp_level->sse_p1 = 0;\n\t\tctdp_level->avx2_p1 = 0;\n\t\tctdp_level->avx512_p1 = 0;\n\t\treturn;\n\t}\n\n\tctdp_level->sse_p1 = resp & GENMASK(7, 0);\n\tctdp_level->avx2_p1 = (resp & GENMASK(15, 8)) >> 8;\n\tctdp_level->avx512_p1 = (resp & GENMASK(23, 16)) >> 16;\n\tctdp_level->amx_p1 = (resp & GENMASK(31, 24)) >> 24;\n\tdebug_printf(\n\t\t\"cpu:%d ctdp:%d CONFIG_TDP_GET_P1_INFO resp:%x sse_p1:%d avx2_p1:%d avx512_p1:%d amx_p1:%d\\n\",\n\t\tid->cpu, config_index, resp, ctdp_level->sse_p1,\n\t\tctdp_level->avx2_p1, ctdp_level->avx512_p1, ctdp_level->amx_p1);\n}\n\nstatic void _get_uncore_mem_freq(struct isst_id *id, int config_index,\n\t\t\t      struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tunsigned int resp;\n\tint ret;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP, CONFIG_TDP_GET_MEM_FREQ,\n\t\t\t\t     0, config_index, &resp);\n\tif (ret) {\n\t\tctdp_level->mem_freq = 0;\n\t\treturn;\n\t}\n\n\tctdp_level->mem_freq = resp & GENMASK(7, 0);\n\tif (is_spr_platform() || is_emr_platform()) {\n\t\tctdp_level->mem_freq *= 200;\n\t} else if (is_icx_platform()) {\n\t\tif (ctdp_level->mem_freq < 7) {\n\t\t\tctdp_level->mem_freq = (12 - ctdp_level->mem_freq) * 133.33 * 2 * 10;\n\t\t\tctdp_level->mem_freq /= 10;\n\t\t\tif (ctdp_level->mem_freq % 10 > 5)\n\t\t\t\tctdp_level->mem_freq++;\n\t\t} else {\n\t\t\tctdp_level->mem_freq = 0;\n\t\t}\n\t} else {\n\t\tctdp_level->mem_freq = 0;\n\t}\n\tdebug_printf(\n\t\t\"cpu:%d ctdp:%d CONFIG_TDP_GET_MEM_FREQ resp:%x uncore mem_freq:%d\\n\",\n\t\tid->cpu, config_index, resp, ctdp_level->mem_freq);\n}\n\nstatic int mbox_get_tdp_info(struct isst_id *id, int config_index,\n\t\t      struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tunsigned int resp;\n\tint ret;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP, CONFIG_TDP_GET_TDP_INFO,\n\t\t\t\t     0, config_index, &resp);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Invalid level, Can't get TDP information at level\", 1, config_index);\n\t\treturn ret;\n\t}\n\n\tctdp_level->pkg_tdp = resp & GENMASK(14, 0);\n\tctdp_level->tdp_ratio = (resp & GENMASK(23, 16)) >> 16;\n\n\tdebug_printf(\n\t\t\"cpu:%d ctdp:%d CONFIG_TDP_GET_TDP_INFO resp:%x tdp_ratio:%d pkg_tdp:%d\\n\",\n\t\tid->cpu, config_index, resp, ctdp_level->tdp_ratio,\n\t\tctdp_level->pkg_tdp);\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP, CONFIG_TDP_GET_TJMAX_INFO,\n\t\t\t\t     0, config_index, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tctdp_level->t_proc_hot = resp & GENMASK(7, 0);\n\n\t_get_uncore_p0_p1_info(id, config_index, ctdp_level);\n\t_get_p1_info(id, config_index, ctdp_level);\n\t_get_uncore_mem_freq(id, config_index, ctdp_level);\n\n\tdebug_printf(\n\t\t\"cpu:%d ctdp:%d CONFIG_TDP_GET_TJMAX_INFO resp:%x t_proc_hot:%d\\n\",\n\t\tid->cpu, config_index, resp, ctdp_level->t_proc_hot);\n\n\treturn 0;\n}\n\nstatic int mbox_get_pwr_info(struct isst_id *id, int config_index,\n\t\t      struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tunsigned int resp;\n\tint ret;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP, CONFIG_TDP_GET_PWR_INFO,\n\t\t\t\t     0, config_index, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tctdp_level->pkg_max_power = resp & GENMASK(14, 0);\n\tctdp_level->pkg_min_power = (resp & GENMASK(30, 16)) >> 16;\n\n\tdebug_printf(\n\t\t\"cpu:%d ctdp:%d CONFIG_TDP_GET_PWR_INFO resp:%x pkg_max_power:%d pkg_min_power:%d\\n\",\n\t\tid->cpu, config_index, resp, ctdp_level->pkg_max_power,\n\t\tctdp_level->pkg_min_power);\n\n\treturn 0;\n}\n\nstatic int mbox_get_coremask_info(struct isst_id *id, int config_index,\n\t\t\t   struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tunsigned int resp;\n\tint i, ret;\n\n\tctdp_level->cpu_count = 0;\n\tfor (i = 0; i < 2; ++i) {\n\t\tunsigned long long mask;\n\t\tint cpu_count = 0;\n\n\t\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t\t     CONFIG_TDP_GET_CORE_MASK, 0,\n\t\t\t\t\t     (i << 8) | config_index, &resp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdebug_printf(\n\t\t\t\"cpu:%d ctdp:%d mask:%d CONFIG_TDP_GET_CORE_MASK resp:%x\\n\",\n\t\t\tid->cpu, config_index, i, resp);\n\n\t\tmask = (unsigned long long)resp << (32 * i);\n\t\tset_cpu_mask_from_punit_coremask(id, mask,\n\t\t\t\t\t\t ctdp_level->core_cpumask_size,\n\t\t\t\t\t\t ctdp_level->core_cpumask,\n\t\t\t\t\t\t &cpu_count);\n\t\tctdp_level->cpu_count += cpu_count;\n\t\tdebug_printf(\"cpu:%d ctdp:%d mask:%d cpu count:%d\\n\", id->cpu,\n\t\t\t     config_index, i, ctdp_level->cpu_count);\n\t}\n\n\treturn 0;\n}\n\nstatic int mbox_get_get_trl(struct isst_id *id, int level, int avx_level, int *trl)\n{\n\tunsigned int req, resp;\n\tint ret;\n\n\treq = level | (avx_level << 16);\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t     CONFIG_TDP_GET_TURBO_LIMIT_RATIOS, 0, req,\n\t\t\t\t     &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\n\t\t\"cpu:%d CONFIG_TDP_GET_TURBO_LIMIT_RATIOS req:%x resp:%x\\n\",\n\t\tid->cpu, req, resp);\n\n\ttrl[0] = resp & GENMASK(7, 0);\n\ttrl[1] = (resp & GENMASK(15, 8)) >> 8;\n\ttrl[2] = (resp & GENMASK(23, 16)) >> 16;\n\ttrl[3] = (resp & GENMASK(31, 24)) >> 24;\n\n\treq = level | BIT(8) | (avx_level << 16);\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t     CONFIG_TDP_GET_TURBO_LIMIT_RATIOS, 0, req,\n\t\t\t\t     &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CONFIG_TDP_GET_TURBO_LIMIT req:%x resp:%x\\n\", id->cpu,\n\t\t     req, resp);\n\n\ttrl[4] = resp & GENMASK(7, 0);\n\ttrl[5] = (resp & GENMASK(15, 8)) >> 8;\n\ttrl[6] = (resp & GENMASK(23, 16)) >> 16;\n\ttrl[7] = (resp & GENMASK(31, 24)) >> 24;\n\n\treturn 0;\n}\n\nstatic int mbox_get_get_trls(struct isst_id *id, int level, struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tint trl_max_levels = isst_get_trl_max_levels();\n\tint i, ret;\n\n\tfor (i = 0; i < trl_max_levels; i++) {\n\t\tret = mbox_get_get_trl(id, level, i, ctdp_level->trl_ratios[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int mbox_get_trl_bucket_info(struct isst_id *id, int level, unsigned long long *buckets_info)\n{\n\tint ret;\n\n\tdebug_printf(\"cpu:%d bucket info via MSR\\n\", id->cpu);\n\n\t*buckets_info = 0;\n\n\tret = isst_send_msr_command(id->cpu, 0x1ae, 0, buckets_info);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d bucket info via MSR successful 0x%llx\\n\", id->cpu,\n\t\t     *buckets_info);\n\n\treturn 0;\n}\n\nstatic int mbox_set_tdp_level(struct isst_id *id, int tdp_level)\n{\n\tunsigned int resp;\n\tint ret;\n\n\n\tif (isst_get_config_tdp_lock_status(id)) {\n\t\tisst_display_error_info_message(1, \"TDP is locked\", 0, 0);\n\t\treturn -1;\n\n\t}\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP, CONFIG_TDP_SET_LEVEL, 0,\n\t\t\t\t     tdp_level, &resp);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Set TDP level failed for level\", 1, tdp_level);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mbox_get_pbf_info(struct isst_id *id, int level, struct isst_pbf_info *pbf_info)\n{\n\tint max_punit_core, max_mask_index;\n\tunsigned int req, resp;\n\tint i, ret;\n\n\tmax_punit_core = get_max_punit_core_id(id);\n\tmax_mask_index = max_punit_core > 32 ? 2 : 1;\n\n\tfor (i = 0; i < max_mask_index; ++i) {\n\t\tunsigned long long mask;\n\t\tint count;\n\n\t\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t\t     CONFIG_TDP_PBF_GET_CORE_MASK_INFO,\n\t\t\t\t\t     0, (i << 8) | level, &resp);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdebug_printf(\n\t\t\t\"cpu:%d CONFIG_TDP_PBF_GET_CORE_MASK_INFO resp:%x\\n\",\n\t\t\tid->cpu, resp);\n\n\t\tmask = (unsigned long long)resp << (32 * i);\n\t\tset_cpu_mask_from_punit_coremask(id, mask,\n\t\t\t\t\t\t pbf_info->core_cpumask_size,\n\t\t\t\t\t\t pbf_info->core_cpumask,\n\t\t\t\t\t\t &count);\n\t}\n\n\treq = level;\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t     CONFIG_TDP_PBF_GET_P1HI_P1LO_INFO, 0, req,\n\t\t\t\t     &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CONFIG_TDP_PBF_GET_P1HI_P1LO_INFO resp:%x\\n\", id->cpu,\n\t\t     resp);\n\n\tpbf_info->p1_low = resp & 0xff;\n\tpbf_info->p1_high = (resp & GENMASK(15, 8)) >> 8;\n\n\treq = level;\n\tret = _send_mbox_command(\n\t\tid->cpu, CONFIG_TDP, CONFIG_TDP_PBF_GET_TDP_INFO, 0, req, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CONFIG_TDP_PBF_GET_TDP_INFO resp:%x\\n\", id->cpu, resp);\n\n\tpbf_info->tdp = resp & 0xffff;\n\n\treq = level;\n\tret = _send_mbox_command(\n\t\tid->cpu, CONFIG_TDP, CONFIG_TDP_PBF_GET_TJ_MAX_INFO, 0, req, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CONFIG_TDP_PBF_GET_TJ_MAX_INFO resp:%x\\n\", id->cpu,\n\t\t     resp);\n\tpbf_info->t_control = (resp >> 8) & 0xff;\n\tpbf_info->t_prochot = resp & 0xff;\n\n\treturn 0;\n}\n\nstatic int mbox_set_pbf_fact_status(struct isst_id *id, int pbf, int enable)\n{\n\tstruct isst_pkg_ctdp pkg_dev;\n\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\tint current_level;\n\tunsigned int req = 0, resp;\n\tint ret;\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret)\n\t\tdebug_printf(\"cpu:%d No support for dynamic ISST\\n\", id->cpu);\n\n\tcurrent_level = pkg_dev.current_level;\n\n\tret = isst_get_ctdp_control(id, current_level, &ctdp_level);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pbf) {\n\t\tif (ctdp_level.fact_enabled)\n\t\t\treq = BIT(16);\n\n\t\tif (enable)\n\t\t\treq |= BIT(17);\n\t\telse\n\t\t\treq &= ~BIT(17);\n\t} else {\n\n\t\tif (enable && !ctdp_level.sst_cp_enabled)\n\t\t\tisst_display_error_info_message(0, \"Make sure to execute before: core-power enable\", 0, 0);\n\n\t\tif (ctdp_level.pbf_enabled)\n\t\t\treq = BIT(17);\n\n\t\tif (enable)\n\t\t\treq |= BIT(16);\n\t\telse\n\t\t\treq &= ~BIT(16);\n\t}\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t     CONFIG_TDP_SET_TDP_CONTROL, 0, req, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CONFIG_TDP_SET_TDP_CONTROL pbf/fact:%d req:%x\\n\",\n\t\t     id->cpu, pbf, req);\n\n\treturn 0;\n}\n\nstatic int _get_fact_bucket_info(struct isst_id *id, int level,\n\t\t\t      struct isst_fact_bucket_info *bucket_info)\n{\n\tunsigned int resp;\n\tint i, k, ret;\n\n\tfor (i = 0; i < 2; ++i) {\n\t\tint j;\n\n\t\tret = _send_mbox_command(\n\t\t\tid->cpu, CONFIG_TDP,\n\t\t\tCONFIG_TDP_GET_FACT_HP_TURBO_LIMIT_NUMCORES, 0,\n\t\t\t(i << 8) | level, &resp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdebug_printf(\n\t\t\t\"cpu:%d CONFIG_TDP_GET_FACT_HP_TURBO_LIMIT_NUMCORES index:%d level:%d resp:%x\\n\",\n\t\t\tid->cpu, i, level, resp);\n\n\t\tfor (j = 0; j < 4; ++j) {\n\t\t\tbucket_info[j + (i * 4)].hp_cores =\n\t\t\t\t(resp >> (j * 8)) & 0xff;\n\t\t}\n\t}\n\n\tfor (k = 0; k < 3; ++k) {\n\t\tfor (i = 0; i < 2; ++i) {\n\t\t\tint j;\n\n\t\t\tret = _send_mbox_command(\n\t\t\t\tid->cpu, CONFIG_TDP,\n\t\t\t\tCONFIG_TDP_GET_FACT_HP_TURBO_LIMIT_RATIOS, 0,\n\t\t\t\t(k << 16) | (i << 8) | level, &resp);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tdebug_printf(\n\t\t\t\t\"cpu:%d CONFIG_TDP_GET_FACT_HP_TURBO_LIMIT_RATIOS index:%d level:%d avx:%d resp:%x\\n\",\n\t\t\t\tid->cpu, i, level, k, resp);\n\n\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\tbucket_info[j + (i * 4)].hp_ratios[k] =\n\t\t\t\t\t(resp >> (j * 8)) & 0xff;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mbox_get_fact_info(struct isst_id *id, int level, int fact_bucket, struct isst_fact_info *fact_info)\n{\n\tunsigned int resp;\n\tint j, ret, print;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_TDP,\n\t\t\t\t     CONFIG_TDP_GET_FACT_LP_CLIPPING_RATIO, 0,\n\t\t\t\t     level, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CONFIG_TDP_GET_FACT_LP_CLIPPING_RATIO resp:%x\\n\",\n\t\t     id->cpu, resp);\n\n\tfact_info->lp_ratios[0] = resp & 0xff;\n\tfact_info->lp_ratios[1] = (resp >> 8) & 0xff;\n\tfact_info->lp_ratios[2] = (resp >> 16) & 0xff;\n\n\tret = _get_fact_bucket_info(id, level, fact_info->bucket_info);\n\tif (ret)\n\t\treturn ret;\n\n\tprint = 0;\n\tfor (j = 0; j < ISST_FACT_MAX_BUCKETS; ++j) {\n\t\tif (fact_bucket != 0xff && fact_bucket != j)\n\t\t\tcontinue;\n\n\t\tif (!fact_info->bucket_info[j].hp_cores)\n\t\t\tbreak;\n\n\t\tprint = 1;\n\t}\n\tif (!print) {\n\t\tisst_display_error_info_message(1, \"Invalid bucket\", 0, 0);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int mbox_get_clos_information(struct isst_id *id, int *enable, int *type)\n{\n\tunsigned int resp;\n\tint ret;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,\n\t\t\t\t     &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CLOS_PM_QOS_CONFIG resp:%x\\n\", id->cpu, resp);\n\n\tif (resp & BIT(1))\n\t\t*enable = 1;\n\telse\n\t\t*enable = 0;\n\n\tif (resp & BIT(2))\n\t\t*type = 1;\n\telse\n\t\t*type = 0;\n\n\treturn 0;\n}\n\nstatic int _write_pm_config(struct isst_id *id, int cp_state)\n{\n\tunsigned int req, resp;\n\tint ret;\n\n\tif (cp_state)\n\t\treq = BIT(16);\n\telse\n\t\treq = 0;\n\n\tret = _send_mbox_command(id->cpu, WRITE_PM_CONFIG, PM_FEATURE, 0, req,\n\t\t\t\t     &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d WRITE_PM_CONFIG resp:%x\\n\", id->cpu, resp);\n\n\treturn 0;\n}\n\nstatic int mbox_pm_qos_config(struct isst_id *id, int enable_clos, int priority_type)\n{\n\tunsigned int req, resp;\n\tint ret;\n\n\tif (!enable_clos) {\n\t\tstruct isst_pkg_ctdp pkg_dev;\n\t\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\n\t\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\t\tif (ret) {\n\t\t\tdebug_printf(\"isst_get_ctdp_levels\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = isst_get_ctdp_control(id, pkg_dev.current_level,\n\t\t\t\t\t    &ctdp_level);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ctdp_level.fact_enabled) {\n\t\t\tisst_display_error_info_message(1, \"Ignoring request, turbo-freq feature is still enabled\", 0, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = _write_pm_config(id, 0);\n\t\tif (ret)\n\t\t\tisst_display_error_info_message(0, \"WRITE_PM_CONFIG command failed, ignoring error\", 0, 0);\n\t} else {\n\t\tret = _write_pm_config(id, 1);\n\t\tif (ret)\n\t\t\tisst_display_error_info_message(0, \"WRITE_PM_CONFIG command failed, ignoring error\", 0, 0);\n\t}\n\n\tret = _send_mbox_command(id->cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG, 0, 0,\n\t\t\t\t     &resp);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"CLOS_PM_QOS_CONFIG command failed\", 0, 0);\n\t\treturn ret;\n\t}\n\n\tdebug_printf(\"cpu:%d CLOS_PM_QOS_CONFIG resp:%x\\n\", id->cpu, resp);\n\n\treq = resp;\n\n\tif (enable_clos)\n\t\treq = req | BIT(1);\n\telse\n\t\treq = req & ~BIT(1);\n\n\tif (priority_type > 1)\n\t\tisst_display_error_info_message(1, \"Invalid priority type: Changing type to ordered\", 0, 0);\n\n\tif (priority_type)\n\t\treq = req | BIT(2);\n\telse\n\t\treq = req & ~BIT(2);\n\n\tret = _send_mbox_command(id->cpu, CONFIG_CLOS, CLOS_PM_QOS_CONFIG,\n\t\t\t\t     BIT(MBOX_CMD_WRITE_BIT), req, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CLOS_PM_QOS_CONFIG priority type:%d req:%x\\n\", id->cpu,\n\t\t     priority_type, req);\n\n\treturn 0;\n}\n\nstatic int mbox_pm_get_clos(struct isst_id *id, int clos, struct isst_clos_config *clos_config)\n{\n\tunsigned int resp;\n\tint ret;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_CLOS, CLOS_PM_CLOS, clos, 0,\n\t\t\t\t     &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tclos_config->epp = resp & 0x0f;\n\tclos_config->clos_prop_prio = (resp >> 4) & 0x0f;\n\tclos_config->clos_min = (resp >> 8) & 0xff;\n\tclos_config->clos_max = (resp >> 16) & 0xff;\n\tclos_config->clos_desired = (resp >> 24) & 0xff;\n\n\treturn 0;\n}\n\nstatic int mbox_set_clos(struct isst_id *id, int clos, struct isst_clos_config *clos_config)\n{\n\tunsigned int req, resp;\n\tunsigned int param;\n\tint ret;\n\n\treq = clos_config->epp & 0x0f;\n\treq |= (clos_config->clos_prop_prio & 0x0f) << 4;\n\treq |= (clos_config->clos_min & 0xff) << 8;\n\treq |= (clos_config->clos_max & 0xff) << 16;\n\treq |= (clos_config->clos_desired & 0xff) << 24;\n\n\tparam = BIT(MBOX_CMD_WRITE_BIT) | clos;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_CLOS, CLOS_PM_CLOS, param, req,\n\t\t\t\t     &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CLOS_PM_CLOS param:%x req:%x\\n\", id->cpu, param, req);\n\n\treturn 0;\n}\n\nstatic int mbox_clos_get_assoc_status(struct isst_id *id, int *clos_id)\n{\n\tunsigned int resp;\n\tunsigned int param;\n\tint core_id, ret;\n\n\tcore_id = find_phy_core_num(id->cpu);\n\tparam = core_id;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_CLOS, CLOS_PQR_ASSOC, param, 0,\n\t\t\t\t     &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CLOS_PQR_ASSOC param:%x resp:%x\\n\", id->cpu, param,\n\t\t     resp);\n\t*clos_id = (resp >> 16) & 0x03;\n\n\treturn 0;\n}\n\nstatic int mbox_clos_associate(struct isst_id *id, int clos_id)\n{\n\tunsigned int req, resp;\n\tunsigned int param;\n\tint core_id, ret;\n\n\treq = (clos_id & 0x03) << 16;\n\tcore_id = find_phy_core_num(id->cpu);\n\tparam = BIT(MBOX_CMD_WRITE_BIT) | core_id;\n\n\tret = _send_mbox_command(id->cpu, CONFIG_CLOS, CLOS_PQR_ASSOC, param,\n\t\t\t\t     req, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu:%d CLOS_PQR_ASSOC param:%x req:%x\\n\", id->cpu, param,\n\t\t     req);\n\n\treturn 0;\n}\n\nstatic struct isst_platform_ops mbox_ops = {\n\t.get_disp_freq_multiplier = mbox_get_disp_freq_multiplier,\n\t.get_trl_max_levels = mbox_get_trl_max_levels,\n\t.get_trl_level_name = mbox_get_trl_level_name,\n\t.update_platform_param = mbox_update_platform_param,\n\t.is_punit_valid = mbox_is_punit_valid,\n\t.read_pm_config = mbox_read_pm_config,\n\t.get_config_levels = mbox_get_config_levels,\n\t.get_ctdp_control = mbox_get_ctdp_control,\n\t.get_tdp_info = mbox_get_tdp_info,\n\t.get_pwr_info = mbox_get_pwr_info,\n\t.get_coremask_info = mbox_get_coremask_info,\n\t.get_get_trl = mbox_get_get_trl,\n\t.get_get_trls = mbox_get_get_trls,\n\t.get_trl_bucket_info = mbox_get_trl_bucket_info,\n\t.set_tdp_level = mbox_set_tdp_level,\n\t.get_pbf_info = mbox_get_pbf_info,\n\t.set_pbf_fact_status = mbox_set_pbf_fact_status,\n\t.get_fact_info = mbox_get_fact_info,\n\t.adjust_uncore_freq = mbox_adjust_uncore_freq,\n\t.get_clos_information = mbox_get_clos_information,\n\t.pm_qos_config = mbox_pm_qos_config,\n\t.pm_get_clos = mbox_pm_get_clos,\n\t.set_clos = mbox_set_clos,\n\t.clos_get_assoc_status = mbox_clos_get_assoc_status,\n\t.clos_associate = mbox_clos_associate,\n};\n\nstruct isst_platform_ops *mbox_get_platform_ops(void)\n{\n\treturn &mbox_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}