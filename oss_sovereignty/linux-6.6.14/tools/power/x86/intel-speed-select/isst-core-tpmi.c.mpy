{
  "module_name": "isst-core-tpmi.c",
  "hash_id": "d8baac48fd0bc32cde85752ed9989d7e28013373be15da66d24a260a2de91392",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/intel-speed-select/isst-core-tpmi.c",
  "human_readable_source": "\n \n\n#include <linux/isst_if.h>\n#include \"isst.h\"\n\nint tpmi_process_ioctl(int ioctl_no, void *info)\n{\n\tconst char *pathname = \"/dev/isst_interface\";\n\tint fd;\n\n\tif (is_debug_enabled()) {\n\t\tdebug_printf(\"Issue IOCTL: \");\n\t\tswitch (ioctl_no) {\n\t\tcase ISST_IF_CORE_POWER_STATE:\n\t\t\tdebug_printf(\"ISST_IF_CORE_POWER_STATE\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_CLOS_PARAM:\n\t\t\tdebug_printf(\"ISST_IF_CLOS_PARAM\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_CLOS_ASSOC:\n\t\t\tdebug_printf(\"ISST_IF_CLOS_ASSOC\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_PERF_LEVELS:\n\t\t\tdebug_printf(\"ISST_IF_PERF_LEVELS\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_PERF_SET_LEVEL:\n\t\t\tdebug_printf(\"ISST_IF_PERF_SET_LEVEL\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_PERF_SET_FEATURE:\n\t\t\tdebug_printf(\"ISST_IF_PERF_SET_FEATURE\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_GET_PERF_LEVEL_INFO:\n\t\t\tdebug_printf(\"ISST_IF_GET_PERF_LEVEL_INFO\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_GET_PERF_LEVEL_CPU_MASK:\n\t\t\tdebug_printf(\"ISST_IF_GET_PERF_LEVEL_CPU_MASK\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_GET_BASE_FREQ_INFO:\n\t\t\tdebug_printf(\"ISST_IF_GET_BASE_FREQ_INFO\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_GET_BASE_FREQ_CPU_MASK:\n\t\t\tdebug_printf(\"ISST_IF_GET_BASE_FREQ_CPU_MASK\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_GET_TURBO_FREQ_INFO:\n\t\t\tdebug_printf(\"ISST_IF_GET_TURBO_FREQ_INFO\\n\");\n\t\t\tbreak;\n\t\tcase ISST_IF_COUNT_TPMI_INSTANCES:\n\t\t\tdebug_printf(\"ISST_IF_COUNT_TPMI_INSTANCES\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdebug_printf(\"%d\\n\", ioctl_no);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (ioctl(fd, ioctl_no, info) == -1) {\n\t\tdebug_printf(\"IOCTL %d Failed\\n\", ioctl_no);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tclose(fd);\n\n\treturn 0;\n}\n\nstatic int tpmi_get_disp_freq_multiplier(void)\n{\n\treturn 1;\n}\n\nstatic int tpmi_get_trl_max_levels(void)\n{\n\treturn TRL_MAX_LEVELS;\n}\n\nstatic char *tpmi_get_trl_level_name(int level)\n{\n\tswitch (level) {\n\tcase 0:\n\t\treturn \"level-0\";\n\tcase 1:\n\t\treturn \"level-1\";\n\tcase 2:\n\t\treturn \"level-2\";\n\tcase 3:\n\t\treturn \"level-3\";\n\tcase 4:\n\t\treturn \"level-4\";\n\tcase 5:\n\t\treturn \"level-5\";\n\tcase 6:\n\t\treturn \"level-6\";\n\tcase 7:\n\t\treturn \"level-7\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n\nstatic void tpmi_update_platform_param(enum isst_platform_param param, int value)\n{\n\t \n}\n\nstatic int tpmi_is_punit_valid(struct isst_id *id)\n{\n\tstruct isst_tpmi_instance_count info;\n\tint ret;\n\n\tif (id->punit < 0)\n\t\treturn 0;\n\n\tinfo.socket_id = id->pkg;\n\tret = tpmi_process_ioctl(ISST_IF_COUNT_TPMI_INSTANCES, &info);\n\tif (ret == -1)\n\t\treturn 0;\n\n\tif (info.valid_mask & BIT(id->punit))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int tpmi_read_pm_config(struct isst_id *id, int *cp_state, int *cp_cap)\n{\n\tstruct isst_core_power info;\n\tint ret;\n\n\tinfo.get_set = 0;\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tret = tpmi_process_ioctl(ISST_IF_CORE_POWER_STATE, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\t*cp_state = info.enable;\n\t*cp_cap = info.supported;\n\n\treturn 0;\n}\n\nint tpmi_get_config_levels(struct isst_id *id, struct isst_pkg_ctdp *pkg_dev)\n{\n\tstruct isst_perf_level_info info;\n\tint ret;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\n\tret = tpmi_process_ioctl(ISST_IF_PERF_LEVELS, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tpkg_dev->version = info.feature_rev;\n\tpkg_dev->levels = info.max_level;\n\tpkg_dev->locked = info.locked;\n\tpkg_dev->current_level = info.current_level;\n\tpkg_dev->locked = info.locked;\n\tpkg_dev->enabled = info.enabled;\n\n\treturn 0;\n}\n\nstatic int tpmi_get_ctdp_control(struct isst_id *id, int config_index,\n\t\t\t\t struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tstruct isst_core_power core_power_info;\n\tstruct isst_perf_level_info info;\n\tint level_mask;\n\tint ret;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\n\tret = tpmi_process_ioctl(ISST_IF_PERF_LEVELS, &info);\n\tif (ret == -1)\n\t\treturn -1;\n\n\tif (config_index != 0xff)\n\t\tlevel_mask = 1 << config_index;\n\telse\n\t\tlevel_mask = config_index;\n\n\tif (!(info.level_mask & level_mask))\n\t\treturn -1;\n\n\tctdp_level->fact_support = info.sst_tf_support;\n\tctdp_level->pbf_support = info.sst_bf_support;\n\tctdp_level->fact_enabled = !!(info.feature_state & BIT(1));\n\tctdp_level->pbf_enabled = !!(info.feature_state & BIT(0));\n\n\tcore_power_info.get_set = 0;\n\tcore_power_info.socket_id = id->pkg;\n\tcore_power_info.power_domain_id = id->punit;\n\n\tret = tpmi_process_ioctl(ISST_IF_CORE_POWER_STATE, &core_power_info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tctdp_level->sst_cp_support = core_power_info.supported;\n\tctdp_level->sst_cp_enabled = core_power_info.enable;\n\n\tdebug_printf\n\t    (\"cpu:%d CONFIG_TDP_GET_TDP_CONTROL fact_support:%d pbf_support: %d fact_enabled:%d pbf_enabled:%d\\n\",\n\t     id->cpu, ctdp_level->fact_support, ctdp_level->pbf_support,\n\t     ctdp_level->fact_enabled, ctdp_level->pbf_enabled);\n\n\treturn 0;\n}\n\nstatic int tpmi_get_tdp_info(struct isst_id *id, int config_index,\n\t\t\t     struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tstruct isst_perf_level_data_info info;\n\tint ret;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.level = config_index;\n\n\tret = tpmi_process_ioctl(ISST_IF_GET_PERF_LEVEL_INFO, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tctdp_level->pkg_tdp = info.thermal_design_power_w;\n\tctdp_level->tdp_ratio = info.tdp_ratio;\n\tctdp_level->sse_p1 = info.base_freq_mhz;\n\tctdp_level->avx2_p1 = info.base_freq_avx2_mhz;\n\tctdp_level->avx512_p1 = info.base_freq_avx512_mhz;\n\tctdp_level->amx_p1 = info.base_freq_amx_mhz;\n\n\tctdp_level->t_proc_hot = info.tjunction_max_c;\n\tctdp_level->mem_freq = info.max_memory_freq_mhz;\n\tctdp_level->cooling_type = info.cooling_type;\n\n\tctdp_level->uncore_p0 = info.p0_fabric_freq_mhz;\n\tctdp_level->uncore_p1 = info.p1_fabric_freq_mhz;\n\tctdp_level->uncore_pm = info.pm_fabric_freq_mhz;\n\n\tdebug_printf\n\t    (\"cpu:%d ctdp:%d CONFIG_TDP_GET_TDP_INFO tdp_ratio:%d pkg_tdp:%d ctdp_level->t_proc_hot:%d\\n\",\n\t     id->cpu, config_index, ctdp_level->tdp_ratio, ctdp_level->pkg_tdp,\n\t     ctdp_level->t_proc_hot);\n\n\treturn 0;\n}\n\nstatic int tpmi_get_pwr_info(struct isst_id *id, int config_index,\n\t\t\t     struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\t \n\tctdp_level->pkg_max_power = 0;\n\tctdp_level->pkg_min_power = 0;\n\n\tdebug_printf\n\t    (\"cpu:%d ctdp:%d CONFIG_TDP_GET_PWR_INFO pkg_max_power:%d pkg_min_power:%d\\n\",\n\t     id->cpu, config_index, ctdp_level->pkg_max_power,\n\t     ctdp_level->pkg_min_power);\n\n\treturn 0;\n}\n\nint tpmi_get_coremask_info(struct isst_id *id, int config_index,\n\t\t\t   struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tstruct isst_perf_level_cpu_mask info;\n\tint ret, cpu_count;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.level = config_index;\n\tinfo.punit_cpu_map = 1;\n\n\tret = tpmi_process_ioctl(ISST_IF_GET_PERF_LEVEL_CPU_MASK, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tset_cpu_mask_from_punit_coremask(id, info.mask,\n\t\t\t\t\t ctdp_level->core_cpumask_size,\n\t\t\t\t\t ctdp_level->core_cpumask, &cpu_count);\n\tctdp_level->cpu_count = cpu_count;\n\n\tdebug_printf(\"cpu:%d ctdp:%d core_mask ino cpu count:%d\\n\",\n\t\t     id->cpu, config_index, ctdp_level->cpu_count);\n\n\treturn 0;\n}\n\nstatic int tpmi_get_get_trls(struct isst_id *id, int config_index,\n\t\t\t     struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tstruct isst_perf_level_data_info info;\n\tint ret, i, j;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.level = config_index;\n\n\tret = tpmi_process_ioctl(ISST_IF_GET_PERF_LEVEL_INFO, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tif (info.max_buckets > TRL_MAX_BUCKETS)\n\t\tinfo.max_buckets = TRL_MAX_BUCKETS;\n\n\tif (info.max_trl_levels > TRL_MAX_LEVELS)\n\t\tinfo.max_trl_levels = TRL_MAX_LEVELS;\n\n\tfor (i = 0; i < info.max_trl_levels; ++i)\n\t\tfor (j = 0; j < info.max_buckets; ++j)\n\t\t\tctdp_level->trl_ratios[i][j] = info.trl_freq_mhz[i][j];\n\n\treturn 0;\n}\n\nstatic int tpmi_get_get_trl(struct isst_id *id, int level, int config_index,\n\t\t\t    int *trl)\n{\n\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\tint ret, i;\n\n\tret = tpmi_get_get_trls(id, config_index, &ctdp_level);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < 8; ++i)\n\t\ttrl[i] = ctdp_level.trl_ratios[0][i];\n\n\treturn 0;\n}\n\nstatic int tpmi_get_trl_bucket_info(struct isst_id *id, int config_index,\n\t\t\t\t    unsigned long long *buckets_info)\n{\n\tstruct isst_perf_level_data_info info;\n\tunsigned char *mask = (unsigned char *)buckets_info;\n\tint ret, i;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.level = config_index;\n\n\tret = tpmi_process_ioctl(ISST_IF_GET_PERF_LEVEL_INFO, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tif (info.max_buckets > TRL_MAX_BUCKETS)\n\t\tinfo.max_buckets = TRL_MAX_BUCKETS;\n\n\tfor (i = 0; i < info.max_buckets; ++i)\n\t\tmask[i] = info.bucket_core_counts[i];\n\n\tdebug_printf(\"cpu:%d TRL bucket info: 0x%llx\\n\", id->cpu,\n\t\t     *buckets_info);\n\n\treturn 0;\n}\n\nstatic int tpmi_set_tdp_level(struct isst_id *id, int tdp_level)\n{\n\tstruct isst_perf_level_control info;\n\tint ret;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.level = tdp_level;\n\n\tret = tpmi_process_ioctl(ISST_IF_PERF_SET_LEVEL, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int _pbf_get_coremask_info(struct isst_id *id, int config_index,\n\t\t\t\t  struct isst_pbf_info *pbf_info)\n{\n\tstruct isst_perf_level_cpu_mask info;\n\tint ret, cpu_count;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.level = config_index;\n\tinfo.punit_cpu_map = 1;\n\n\tret = tpmi_process_ioctl(ISST_IF_GET_BASE_FREQ_CPU_MASK, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tset_cpu_mask_from_punit_coremask(id, info.mask,\n\t\t\t\t\t pbf_info->core_cpumask_size,\n\t\t\t\t\t pbf_info->core_cpumask, &cpu_count);\n\n\tdebug_printf(\"cpu:%d ctdp:%d pbf core_mask info cpu count:%d\\n\",\n\t\t     id->cpu, config_index, cpu_count);\n\n\treturn 0;\n}\n\nstatic int tpmi_get_pbf_info(struct isst_id *id, int level,\n\t\t\t     struct isst_pbf_info *pbf_info)\n{\n\tstruct isst_base_freq_info info;\n\tint ret;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.level = level;\n\n\tret = tpmi_process_ioctl(ISST_IF_GET_BASE_FREQ_INFO, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tpbf_info->p1_low = info.low_base_freq_mhz;\n\tpbf_info->p1_high = info.high_base_freq_mhz;\n\tpbf_info->tdp = info.thermal_design_power_w;\n\tpbf_info->t_prochot = info.tjunction_max_c;\n\n\tdebug_printf(\"cpu:%d ctdp:%d pbf info:%d:%d:%d:%d\\n\",\n\t\t     id->cpu, level, pbf_info->p1_low, pbf_info->p1_high,\n\t\t     pbf_info->tdp, pbf_info->t_prochot);\n\n\treturn _pbf_get_coremask_info(id, level, pbf_info);\n}\n\nstatic int tpmi_set_pbf_fact_status(struct isst_id *id, int pbf, int enable)\n{\n\tstruct isst_pkg_ctdp pkg_dev;\n\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\tint current_level;\n\tstruct isst_perf_feature_control info;\n\tint ret;\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret)\n\t\tdebug_printf(\"cpu:%d No support for dynamic ISST\\n\", id->cpu);\n\n\tcurrent_level = pkg_dev.current_level;\n\n\tret = isst_get_ctdp_control(id, current_level, &ctdp_level);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\n\tinfo.feature = 0;\n\n\tif (pbf) {\n\t\tif (ctdp_level.fact_enabled)\n\t\t\tinfo.feature |= BIT(1);\n\n\t\tif (enable)\n\t\t\tinfo.feature |= BIT(0);\n\t\telse\n\t\t\tinfo.feature &= ~BIT(0);\n\t} else {\n\n\t\tif (enable && !ctdp_level.sst_cp_enabled)\n\t\t\tisst_display_error_info_message(0,\n\t\t\t\t\t\t\t\"Make sure to execute before: core-power enable\",\n\t\t\t\t\t\t\t0, 0);\n\n\t\tif (ctdp_level.pbf_enabled)\n\t\t\tinfo.feature |= BIT(0);\n\n\t\tif (enable)\n\t\t\tinfo.feature |= BIT(1);\n\t\telse\n\t\t\tinfo.feature &= ~BIT(1);\n\t}\n\n\tret = tpmi_process_ioctl(ISST_IF_PERF_SET_FEATURE, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tpmi_get_fact_info(struct isst_id *id, int level, int fact_bucket,\n\t\t\t      struct isst_fact_info *fact_info)\n{\n\tstruct isst_turbo_freq_info info;\n\tint i, j;\n\tint ret;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.level = level;\n\n\tret = tpmi_process_ioctl(ISST_IF_GET_TURBO_FREQ_INFO, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tfor (i = 0; i < info.max_clip_freqs; ++i)\n\t\tfact_info->lp_ratios[i] = info.lp_clip_freq_mhz[i];\n\n\tif (info.max_buckets > TRL_MAX_BUCKETS)\n\t\tinfo.max_buckets = TRL_MAX_BUCKETS;\n\n\tif (info.max_trl_levels > TRL_MAX_LEVELS)\n\t\tinfo.max_trl_levels = TRL_MAX_LEVELS;\n\n\tfor (i = 0; i < info.max_trl_levels; ++i) {\n\t\tfor (j = 0; j < info.max_buckets; ++j)\n\t\t\tfact_info->bucket_info[j].hp_ratios[i] =\n\t\t\t    info.trl_freq_mhz[i][j];\n\t}\n\n\tfor (i = 0; i < info.max_buckets; ++i)\n\t\tfact_info->bucket_info[i].hp_cores = info.bucket_core_counts[i];\n\n\treturn 0;\n}\n\nstatic void _set_uncore_min_max(struct isst_id *id, int max, int freq)\n{\n\tDIR *dir;\n\tFILE *filep;\n\tstruct dirent *entry;\n\tchar buffer[512];\n\tunsigned int tmp_id;\n\tint ret;\n\n\tdir = opendir(\"/sys/devices/system/cpu/intel_uncore_frequency/\");\n\tif (!dir)\n\t\treturn;\n\n\twhile ((entry = readdir(dir)) != NULL ) {\n\t\t \n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/intel_uncore_frequency/%s/domain_id\", entry->d_name);\n\n\t\tfilep = fopen(buffer, \"r\");\n\t\tif (!filep)\n\t\t\tgoto end;\n\n\t\tret = fscanf(filep, \"%u\", &tmp_id);\n\t\tfclose(filep);\n\t\tif (ret != 1)\n\t\t\tgoto end;\n\n\t\tif (tmp_id != id->punit)\n\t\t\tcontinue;\n\n\t\t \n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/intel_uncore_frequency/%s/package_id\", entry->d_name);\n\n\t\tfilep = fopen(buffer, \"r\");\n\t\tif (!filep)\n\t\t\tgoto end;\n\n\t\tret = fscanf(filep, \"%u\", &tmp_id);\n\t\tfclose(filep);\n\n\t\tif (ret != 1)\n\t\t\tgoto end;\n\n\t\tif (tmp_id != id->pkg)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (max)\n\t\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t \"/sys/devices/system/cpu/intel_uncore_frequency/%s/max_freq_khz\", entry->d_name);\n\t\t else\n\t\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t \"/sys/devices/system/cpu/intel_uncore_frequency/%s/min_freq_khz\", entry->d_name);\n\n\t\tfilep = fopen(buffer, \"w\");\n\t\tif (!filep)\n\t\t\tgoto end;\n\n\t\tfprintf(filep, \"%d\\n\", freq);\n\t\tfclose(filep);\n\t\tbreak;\n\t}\n\nend:\n\tclosedir(dir);\n}\n\nstatic void tpmi_adjust_uncore_freq(struct isst_id *id, int config_index,\n\t\t\t\tstruct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tstruct isst_perf_level_data_info info;\n\tint ret;\n\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.level = config_index;\n\n\tret = tpmi_process_ioctl(ISST_IF_GET_PERF_LEVEL_INFO, &info);\n\tif (ret == -1)\n\t\treturn;\n\n\tctdp_level->uncore_p0 = info.p0_fabric_freq_mhz;\n\tctdp_level->uncore_p1 = info.p1_fabric_freq_mhz;\n\tctdp_level->uncore_pm = info.pm_fabric_freq_mhz;\n\n\tif (ctdp_level->uncore_pm)\n\t\t_set_uncore_min_max(id, 0, ctdp_level->uncore_pm * 100000);\n\n\tif (ctdp_level->uncore_p0)\n\t\t_set_uncore_min_max(id, 1, ctdp_level->uncore_p0 * 100000);\n\n\treturn;\n}\n\nstatic int tpmi_get_clos_information(struct isst_id *id, int *enable, int *type)\n{\n\tstruct isst_core_power info;\n\tint ret;\n\n\tinfo.get_set = 0;\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tret = tpmi_process_ioctl(ISST_IF_CORE_POWER_STATE, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\t*enable = info.enable;\n\t*type = info.priority_type;\n\n\treturn 0;\n}\n\nstatic int tpmi_pm_qos_config(struct isst_id *id, int enable_clos,\n\t\t\t      int priority_type)\n{\n\tstruct isst_core_power info;\n\tint i, ret, saved_punit;\n\n\tinfo.get_set = 1;\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.enable = enable_clos;\n\tinfo.priority_type = priority_type;\n\n\tsaved_punit = id->punit;\n\n\t \n\tfor (i = 0; i < MAX_PUNIT_PER_DIE; i++) {\n\t\tid->punit = i;\n\t\tif (isst_is_punit_valid(id)) {\n\t\t\tinfo.power_domain_id = i;\n\t\t\tret = tpmi_process_ioctl(ISST_IF_CORE_POWER_STATE, &info);\n\t\t\tif (ret == -1) {\n\t\t\t\tid->punit = saved_punit;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tid->punit = saved_punit;\n\n\treturn 0;\n}\n\nint tpmi_pm_get_clos(struct isst_id *id, int clos,\n\t\t     struct isst_clos_config *clos_config)\n{\n\tstruct isst_clos_param info;\n\tint ret;\n\n\tinfo.get_set = 0;\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.clos = clos;\n\n\tret = tpmi_process_ioctl(ISST_IF_CLOS_PARAM, &info);\n\tif (ret == -1)\n\t\treturn ret;\n\n\tclos_config->epp = 0;\n\tclos_config->clos_prop_prio = info.prop_prio;\n\tclos_config->clos_min = info.min_freq_mhz;\n\tclos_config->clos_max = info.max_freq_mhz;\n\tclos_config->clos_desired = 0;\n\n\tdebug_printf(\"cpu:%d clos:%d min:%d max:%d\\n\", id->cpu, clos,\n\t\t     clos_config->clos_min, clos_config->clos_max);\n\n\treturn 0;\n}\n\nint tpmi_set_clos(struct isst_id *id, int clos,\n\t\t  struct isst_clos_config *clos_config)\n{\n\tstruct isst_clos_param info;\n\tint i, ret, saved_punit;\n\n\tinfo.get_set = 1;\n\tinfo.socket_id = id->pkg;\n\tinfo.power_domain_id = id->punit;\n\tinfo.clos = clos;\n\tinfo.prop_prio = clos_config->clos_prop_prio;\n\n\tinfo.min_freq_mhz = clos_config->clos_min;\n\tinfo.max_freq_mhz = clos_config->clos_max;\n\n\tif (info.min_freq_mhz <= 0xff)\n\t\tinfo.min_freq_mhz *= 100;\n\tif (info.max_freq_mhz <= 0xff)\n\t\tinfo.max_freq_mhz *= 100;\n\n\tsaved_punit = id->punit;\n\n\t \n\tfor (i = 0; i < MAX_PUNIT_PER_DIE; i++) {\n\t\tid->punit = i;\n\t\tif (isst_is_punit_valid(id)) {\n\t\t\tinfo.power_domain_id = i;\n\t\t\tret = tpmi_process_ioctl(ISST_IF_CLOS_PARAM, &info);\n\t\t\tif (ret == -1) {\n\t\t\t\tid->punit = saved_punit;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tid->punit = saved_punit;\n\n\tdebug_printf(\"set cpu:%d clos:%d min:%d max:%d\\n\", id->cpu, clos,\n\t\t     clos_config->clos_min, clos_config->clos_max);\n\n\treturn 0;\n}\n\nstatic int tpmi_clos_get_assoc_status(struct isst_id *id, int *clos_id)\n{\n\tstruct isst_if_clos_assoc_cmds assoc_cmds;\n\tint ret;\n\n\tassoc_cmds.cmd_count = 1;\n\tassoc_cmds.get_set = 0;\n\tassoc_cmds.punit_cpu_map = 1;\n\tassoc_cmds.assoc_info[0].logical_cpu = find_phy_core_num(id->cpu);\n\tassoc_cmds.assoc_info[0].socket_id = id->pkg;\n\tassoc_cmds.assoc_info[0].power_domain_id = id->punit;\n\n\tret = tpmi_process_ioctl(ISST_IF_CLOS_ASSOC, &assoc_cmds);\n\tif (ret == -1)\n\t\treturn ret;\n\n\t*clos_id = assoc_cmds.assoc_info[0].clos;\n\n\treturn 0;\n}\n\nstatic int tpmi_clos_associate(struct isst_id *id, int clos_id)\n{\n\tstruct isst_if_clos_assoc_cmds assoc_cmds;\n\tint ret;\n\n\tassoc_cmds.cmd_count = 1;\n\tassoc_cmds.get_set = 1;\n\tassoc_cmds.punit_cpu_map = 1;\n\tassoc_cmds.assoc_info[0].logical_cpu = find_phy_core_num(id->cpu);\n\tassoc_cmds.assoc_info[0].clos = clos_id;\n\tassoc_cmds.assoc_info[0].socket_id = id->pkg;\n\tassoc_cmds.assoc_info[0].power_domain_id = id->punit;\n\n\tret = tpmi_process_ioctl(ISST_IF_CLOS_ASSOC, &assoc_cmds);\n\tif (ret == -1)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct isst_platform_ops tpmi_ops = {\n\t.get_disp_freq_multiplier = tpmi_get_disp_freq_multiplier,\n\t.get_trl_max_levels = tpmi_get_trl_max_levels,\n\t.get_trl_level_name = tpmi_get_trl_level_name,\n\t.update_platform_param = tpmi_update_platform_param,\n\t.is_punit_valid = tpmi_is_punit_valid,\n\t.read_pm_config = tpmi_read_pm_config,\n\t.get_config_levels = tpmi_get_config_levels,\n\t.get_ctdp_control = tpmi_get_ctdp_control,\n\t.get_tdp_info = tpmi_get_tdp_info,\n\t.get_pwr_info = tpmi_get_pwr_info,\n\t.get_coremask_info = tpmi_get_coremask_info,\n\t.get_get_trl = tpmi_get_get_trl,\n\t.get_get_trls = tpmi_get_get_trls,\n\t.get_trl_bucket_info = tpmi_get_trl_bucket_info,\n\t.set_tdp_level = tpmi_set_tdp_level,\n\t.get_pbf_info = tpmi_get_pbf_info,\n\t.set_pbf_fact_status = tpmi_set_pbf_fact_status,\n\t.get_fact_info = tpmi_get_fact_info,\n\t.adjust_uncore_freq = tpmi_adjust_uncore_freq,\n\t.get_clos_information = tpmi_get_clos_information,\n\t.pm_qos_config = tpmi_pm_qos_config,\n\t.pm_get_clos = tpmi_pm_get_clos,\n\t.set_clos = tpmi_set_clos,\n\t.clos_get_assoc_status = tpmi_clos_get_assoc_status,\n\t.clos_associate = tpmi_clos_associate,\n};\n\nstruct isst_platform_ops *tpmi_get_platform_ops(void)\n{\n\treturn &tpmi_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}