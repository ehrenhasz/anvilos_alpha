{
  "module_name": "isst-config.c",
  "hash_id": "17fc552ad01810170d4538ce9a948993b6e81ed6c8258b794931916761149fe0",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/intel-speed-select/isst-config.c",
  "human_readable_source": "\n \n\n#include <linux/isst_if.h>\n#include <sys/utsname.h>\n\n#include \"isst.h\"\n\nstruct process_cmd_struct {\n\tchar *feature;\n\tchar *command;\n\tvoid (*process_fn)(int arg);\n\tint arg;\n};\n\nstatic const char *version_str = \"v1.17\";\n\nstatic const int supported_api_ver = 2;\nstatic struct isst_if_platform_info isst_platform_info;\nstatic char *progname;\nstatic int debug_flag;\nstatic FILE *outf;\n\nstatic int cpu_model;\nstatic int cpu_stepping;\n\n#define MAX_CPUS_IN_ONE_REQ 256\nstatic short max_target_cpus;\nstatic unsigned short target_cpus[MAX_CPUS_IN_ONE_REQ];\n\nstatic int topo_max_cpus;\nstatic size_t present_cpumask_size;\nstatic cpu_set_t *present_cpumask;\nstatic size_t target_cpumask_size;\nstatic cpu_set_t *target_cpumask;\nstatic int tdp_level = 0xFF;\nstatic int fact_bucket = 0xFF;\nstatic int fact_avx = 0xFF;\nstatic unsigned long long fact_trl;\nstatic int out_format_json;\nstatic int cmd_help;\nstatic int force_online_offline;\nstatic int auto_mode;\nstatic int fact_enable_fail;\nstatic int cgroupv2;\n\n \nstatic int current_clos = -1;\nstatic int clos_epp = -1;\nstatic int clos_prop_prio = -1;\nstatic int clos_min = -1;\nstatic int clos_max = -1;\nstatic int clos_desired = -1;\nstatic int clos_priority_type;\n\nstruct _cpu_map {\n\tunsigned short core_id;\n\tunsigned short pkg_id;\n\tunsigned short die_id;\n\tunsigned short punit_id;\n\tunsigned short punit_cpu;\n\tunsigned short punit_cpu_core;\n\tunsigned short initialized;\n};\nstruct _cpu_map *cpu_map;\n\nstruct cpu_topology {\n\tshort cpu;\n\tshort core_id;\n\tshort pkg_id;\n\tshort die_id;\n};\n\nFILE *get_output_file(void)\n{\n\treturn outf;\n}\n\nint is_debug_enabled(void)\n{\n\treturn debug_flag;\n}\n\nvoid debug_printf(const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\n\tif (debug_flag)\n\t\tvprintf(format, args);\n\n\tva_end(args);\n}\n\n\nint is_clx_n_platform(void)\n{\n\tif (cpu_model == 0x55)\n\t\tif (cpu_stepping == 0x6 || cpu_stepping == 0x7)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nint is_skx_based_platform(void)\n{\n\tif (cpu_model == 0x55)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint is_spr_platform(void)\n{\n\tif (cpu_model == 0x8F)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint is_emr_platform(void)\n{\n\tif (cpu_model == 0xCF)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n\nint is_icx_platform(void)\n{\n\tif (cpu_model == 0x6A || cpu_model == 0x6C)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int update_cpu_model(void)\n{\n\tunsigned int ebx, ecx, edx;\n\tunsigned int fms, family;\n\n\t__cpuid(1, fms, ebx, ecx, edx);\n\tfamily = (fms >> 8) & 0xf;\n\tcpu_model = (fms >> 4) & 0xf;\n\tif (family == 6 || family == 0xf)\n\t\tcpu_model += ((fms >> 16) & 0xf) << 4;\n\n\tcpu_stepping = fms & 0xf;\n\t \n\tif (is_clx_n_platform()) {\n\t\tFILE *fp;\n\t\tsize_t n = 0;\n\t\tchar *line = NULL;\n\t\tint ret = 1;\n\n\t\tfp = fopen(\"/proc/cpuinfo\", \"r\");\n\t\tif (!fp)\n\t\t\terr(-1, \"cannot open /proc/cpuinfo\\n\");\n\n\t\twhile (getline(&line, &n, fp) > 0) {\n\t\t\tif (strstr(line, \"model name\")) {\n\t\t\t\tif (strstr(line, \"6252N\") ||\n\t\t\t\t    strstr(line, \"6230N\") ||\n\t\t\t\t    strstr(line, \"5218N\"))\n\t\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(line);\n\t\tfclose(fp);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint api_version(void)\n{\n        return isst_platform_info.api_version;\n}\n\n \nstatic FILE *fopen_or_exit(const char *path, const char *mode)\n{\n\tFILE *filep = fopen(path, mode);\n\n\tif (!filep)\n\t\terr(1, \"%s: open failed\", path);\n\n\treturn filep;\n}\n\n \nstatic int parse_int_file(int fatal, const char *fmt, ...)\n{\n\tva_list args;\n\tchar path[PATH_MAX];\n\tFILE *filep;\n\tint value;\n\n\tva_start(args, fmt);\n\tvsnprintf(path, sizeof(path), fmt, args);\n\tva_end(args);\n\tif (fatal) {\n\t\tfilep = fopen_or_exit(path, \"r\");\n\t} else {\n\t\tfilep = fopen(path, \"r\");\n\t\tif (!filep)\n\t\t\treturn -1;\n\t}\n\tif (fscanf(filep, \"%d\", &value) != 1)\n\t\terr(1, \"%s: failed to parse number from file\", path);\n\tfclose(filep);\n\n\treturn value;\n}\n\nint cpufreq_sysfs_present(void)\n{\n\tDIR *dir;\n\n\tdir = opendir(\"/sys/devices/system/cpu/cpu0/cpufreq\");\n\tif (dir) {\n\t\tclosedir(dir);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint out_format_is_json(void)\n{\n\treturn out_format_json;\n}\n\nstatic int get_stored_topology_info(int cpu, int *core_id, int *pkg_id, int *die_id)\n{\n\tconst char *pathname = \"/var/run/isst_cpu_topology.dat\";\n\tstruct cpu_topology cpu_top;\n\tFILE *fp;\n\tint ret;\n\n\tfp = fopen(pathname, \"rb\");\n\tif (!fp)\n\t\treturn -1;\n\n\tret = fseek(fp, cpu * sizeof(cpu_top), SEEK_SET);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = fread(&cpu_top, sizeof(cpu_top), 1, fp);\n\tif (ret != 1) {\n\t\tret = -1;\n\t\tgoto err_ret;\n\t}\n\n\t*pkg_id = cpu_top.pkg_id;\n\t*core_id = cpu_top.core_id;\n\t*die_id = cpu_top.die_id;\n\tret = 0;\n\nerr_ret:\n\tfclose(fp);\n\n\treturn ret;\n}\n\nstatic void store_cpu_topology(void)\n{\n\tconst char *pathname = \"/var/run/isst_cpu_topology.dat\";\n\tFILE *fp;\n\tint i;\n\n\tfp = fopen(pathname, \"rb\");\n\tif (fp) {\n\t\t \n\t\tfclose(fp);\n\t\treturn;\n\t}\n\n\tfp = fopen(pathname, \"wb\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Can't create file:%s\\n\", pathname);\n\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Caching topology information\\n\");\n\n\tfor (i = 0; i < topo_max_cpus; ++i) {\n\t\tstruct cpu_topology cpu_top;\n\n\t\tcpu_top.core_id = parse_int_file(0,\n\t\t\t\"/sys/devices/system/cpu/cpu%d/topology/core_id\", i);\n\t\tif (cpu_top.core_id < 0)\n\t\t\tcpu_top.core_id = -1;\n\n\t\tcpu_top.pkg_id = parse_int_file(0,\n\t\t\t\"/sys/devices/system/cpu/cpu%d/topology/physical_package_id\", i);\n\t\tif (cpu_top.pkg_id < 0)\n\t\t\tcpu_top.pkg_id = -1;\n\n\t\tcpu_top.die_id = parse_int_file(0,\n\t\t\t\"/sys/devices/system/cpu/cpu%d/topology/die_id\", i);\n\t\tif (cpu_top.die_id < 0)\n\t\t\tcpu_top.die_id = -1;\n\n\t\tcpu_top.cpu = i;\n\n\t\tif (fwrite(&cpu_top, sizeof(cpu_top), 1, fp) != 1) {\n\t\t\tfprintf(stderr, \"Can't write to:%s\\n\", pathname);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n}\n\nstatic int get_physical_package_id(int cpu)\n{\n\tint ret;\n\n\tif (cpu < 0)\n\t\treturn -1;\n\n\tif (cpu_map && cpu_map[cpu].initialized)\n\t\treturn cpu_map[cpu].pkg_id;\n\n\tret = parse_int_file(0,\n\t\t\t\"/sys/devices/system/cpu/cpu%d/topology/physical_package_id\",\n\t\t\tcpu);\n\tif (ret < 0) {\n\t\tint core_id, pkg_id, die_id;\n\n\t\tret = get_stored_topology_info(cpu, &core_id, &pkg_id, &die_id);\n\t\tif (!ret)\n\t\t\treturn pkg_id;\n\t}\n\n\treturn ret;\n}\n\nstatic int get_physical_core_id(int cpu)\n{\n\tint ret;\n\n\tif (cpu < 0)\n\t\treturn -1;\n\n\tif (cpu_map && cpu_map[cpu].initialized)\n\t\treturn cpu_map[cpu].core_id;\n\n\tret = parse_int_file(0,\n\t\t\t\"/sys/devices/system/cpu/cpu%d/topology/core_id\",\n\t\t\tcpu);\n\tif (ret < 0) {\n\t\tint core_id, pkg_id, die_id;\n\n\t\tret = get_stored_topology_info(cpu, &core_id, &pkg_id, &die_id);\n\t\tif (!ret)\n\t\t\treturn core_id;\n\t}\n\n\treturn ret;\n}\n\nstatic int get_physical_die_id(int cpu)\n{\n\tint ret;\n\n\tif (cpu < 0)\n\t\treturn -1;\n\n\tif (cpu_map && cpu_map[cpu].initialized)\n\t\treturn cpu_map[cpu].die_id;\n\n\tret = parse_int_file(0,\n\t\t\t\"/sys/devices/system/cpu/cpu%d/topology/die_id\",\n\t\t\tcpu);\n\tif (ret < 0) {\n\t\tint core_id, pkg_id, die_id;\n\n\t\tret = get_stored_topology_info(cpu, &core_id, &pkg_id, &die_id);\n\t\tif (!ret) {\n\t\t\tif (die_id < 0)\n\t\t\t\tdie_id = 0;\n\n\t\t\treturn die_id;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int get_physical_punit_id(int cpu)\n{\n\tif (cpu < 0)\n\t\treturn -1;\n\n\tif (cpu_map && cpu_map[cpu].initialized)\n\t\treturn cpu_map[cpu].punit_id;\n\n\treturn -1;\n}\n\nvoid set_isst_id(struct isst_id *id, int cpu)\n{\n\tid->cpu = cpu;\n\n\tid->pkg = get_physical_package_id(cpu);\n\tif (id->pkg >= MAX_PACKAGE_COUNT)\n\t\tid->pkg = -1;\n\n\tid->die = get_physical_die_id(cpu);\n\tif (id->die >= MAX_DIE_PER_PACKAGE)\n\t\tid->die = -1;\n\n\tid->punit = get_physical_punit_id(cpu);\n\tif (id->punit >= MAX_PUNIT_PER_DIE)\n\t\tid->punit = -1;\n}\n\nint is_cpu_in_power_domain(int cpu, struct isst_id *id)\n{\n\tstruct isst_id tid;\n\n\tset_isst_id(&tid, cpu);\n\n\tif (id->pkg == tid.pkg && id->die == tid.die && id->punit == tid.punit)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint get_cpufreq_base_freq(int cpu)\n{\n\treturn parse_int_file(0, \"/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency\", cpu);\n}\n\nint get_topo_max_cpus(void)\n{\n\treturn topo_max_cpus;\n}\n\nstatic unsigned int is_cpu_online(int cpu)\n{\n\tchar buffer[128];\n\tint fd, ret;\n\tunsigned char online;\n\n\tsnprintf(buffer, sizeof(buffer),\n\t\t \"/sys/devices/system/cpu/cpu%d/online\", cpu);\n\n\tfd = open(buffer, O_RDONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tret = read(fd, &online, sizeof(online));\n\tclose(fd);\n\n\tif (ret == -1)\n\t\treturn ret;\n\n\tif (online == '1')\n\t\tonline = 1;\n\telse\n\t\tonline = 0;\n\n\treturn online;\n}\n\nstatic int get_kernel_version(int *major, int *minor)\n{\n\tstruct utsname buf;\n\tint ret;\n\n\tret = uname(&buf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sscanf(buf.release, \"%d.%d\", major, minor);\n\tif (ret != 2)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#define CPU0_HOTPLUG_DEPRECATE_MAJOR_VER\t6\n#define CPU0_HOTPLUG_DEPRECATE_MINOR_VER\t5\n\nvoid set_cpu_online_offline(int cpu, int state)\n{\n\tchar buffer[128];\n\tint fd, ret;\n\n\tif (!cpu) {\n\t\tint major, minor;\n\n\t\tret = get_kernel_version(&major, &minor);\n\t\tif (!ret) {\n\t\t\tif (major > CPU0_HOTPLUG_DEPRECATE_MAJOR_VER || (major == CPU0_HOTPLUG_DEPRECATE_MAJOR_VER &&\n\t\t\t\tminor >= CPU0_HOTPLUG_DEPRECATE_MINOR_VER)) {\n\t\t\t\tdebug_printf(\"Ignore CPU 0 offline/online for kernel version >= %d.%d\\n\", major, minor);\n\t\t\t\tdebug_printf(\"Use cgroups to isolate CPU 0\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnprintf(buffer, sizeof(buffer),\n\t\t \"/sys/devices/system/cpu/cpu%d/online\", cpu);\n\n\tfd = open(buffer, O_WRONLY);\n\tif (fd < 0) {\n\t\tif (!cpu && state) {\n\t\t\tfprintf(stderr, \"This system is not configured for CPU 0 online/offline\\n\");\n\t\t\tfprintf(stderr, \"Ignoring online request for CPU 0 as this is already online\\n\");\n\t\t\treturn;\n\t\t}\n\t\terr(-1, \"%s open failed\", buffer);\n\t}\n\n\tif (state)\n\t\tret = write(fd, \"1\\n\", 2);\n\telse\n\t\tret = write(fd, \"0\\n\", 2);\n\n\tif (ret == -1)\n\t\tperror(\"Online/Offline: Operation failed\\n\");\n\n\tclose(fd);\n}\n\nstatic void force_all_cpus_online(void)\n{\n\tint i;\n\n\tfprintf(stderr, \"Forcing all CPUs online\\n\");\n\n\tfor (i = 0; i < topo_max_cpus; ++i)\n\t\tset_cpu_online_offline(i, 1);\n\n\tunlink(\"/var/run/isst_cpu_topology.dat\");\n}\n\nvoid for_each_online_power_domain_in_set(void (*callback)(struct isst_id *, void *, void *,\n\t\t\t\t\t\t     void *, void *),\n\t\t\t\t    void *arg1, void *arg2, void *arg3,\n\t\t\t\t    void *arg4)\n{\n\tstruct isst_id id;\n\tint cpus[MAX_PACKAGE_COUNT][MAX_DIE_PER_PACKAGE][MAX_PUNIT_PER_DIE];\n\tint valid_mask[MAX_PACKAGE_COUNT][MAX_DIE_PER_PACKAGE] = {0};\n\tint i, j, k;\n\n\tmemset(cpus, -1, sizeof(cpus));\n\n\tfor (i = 0; i < topo_max_cpus; ++i) {\n\t\tint online;\n\n\t\tif (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))\n\t\t\tcontinue;\n\n\t\tonline = parse_int_file(\n\t\t\ti != 0, \"/sys/devices/system/cpu/cpu%d/online\", i);\n\t\tif (online < 0)\n\t\t\tonline = 1;  \n\n\t\tif (!online)\n\t\t\tcontinue;\n\n\t\tset_isst_id(&id, i);\n\n\t\tif (id.pkg < 0 || id.die < 0 || id.punit < 0)\n\t\t\tcontinue;\n\n\t\tvalid_mask[id.pkg][id.die] = 1;\n\n\t\tif (cpus[id.pkg][id.die][id.punit] == -1)\n\t\t\tcpus[id.pkg][id.die][id.punit] = i;\n\t}\n\n\tfor (i = 0; i < MAX_PACKAGE_COUNT; i++) {\n\t\tfor (j = 0; j < MAX_DIE_PER_PACKAGE; j++) {\n\t\t\t \n\t\t\tif (!valid_mask[i][j])\n\t\t\t\tcontinue;\n\t\t\tfor (k = 0; k < MAX_PUNIT_PER_DIE; k++) {\n\t\t\t\tid.cpu = cpus[i][j][k];\n\t\t\t\tid.pkg = i;\n\t\t\t\tid.die = j;\n\t\t\t\tid.punit = k;\n\t\t\t\tif (isst_is_punit_valid(&id))\n\t\t\t\t\tcallback(&id, arg1, arg2, arg3, arg4);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void for_each_online_target_cpu_in_set(\n\tvoid (*callback)(struct isst_id *, void *, void *, void *, void *), void *arg1,\n\tvoid *arg2, void *arg3, void *arg4)\n{\n\tint i, found = 0;\n\tstruct isst_id id;\n\n\tfor (i = 0; i < topo_max_cpus; ++i) {\n\t\tint online;\n\n\t\tif (!CPU_ISSET_S(i, target_cpumask_size, target_cpumask))\n\t\t\tcontinue;\n\t\tif (i)\n\t\t\tonline = parse_int_file(\n\t\t\t\t1, \"/sys/devices/system/cpu/cpu%d/online\", i);\n\t\telse\n\t\t\tonline =\n\t\t\t\t1;  \n\n\t\tset_isst_id(&id, i);\n\t\tif (online && callback) {\n\t\t\tcallback(&id, arg1, arg2, arg3, arg4);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfprintf(stderr, \"No valid CPU in the list\\n\");\n}\n\n#define BITMASK_SIZE 32\nstatic void set_max_cpu_num(void)\n{\n\tFILE *filep;\n\tunsigned long dummy;\n\tint i;\n\n\ttopo_max_cpus = 0;\n\tfor (i = 0; i < 256; ++i) {\n\t\tchar path[256];\n\n\t\tsnprintf(path, sizeof(path),\n\t\t\t \"/sys/devices/system/cpu/cpu%d/topology/thread_siblings\", i);\n\t\tfilep = fopen(path, \"r\");\n\t\tif (filep)\n\t\t\tbreak;\n\t}\n\n\tif (!filep) {\n\t\tfprintf(stderr, \"Can't get max cpu number\\n\");\n\t\texit(0);\n\t}\n\n\twhile (fscanf(filep, \"%lx,\", &dummy) == 1)\n\t\ttopo_max_cpus += BITMASK_SIZE;\n\tfclose(filep);\n\n\tdebug_printf(\"max cpus %d\\n\", topo_max_cpus);\n}\n\nsize_t alloc_cpu_set(cpu_set_t **cpu_set)\n{\n\tcpu_set_t *_cpu_set;\n\tsize_t size;\n\n\t_cpu_set = CPU_ALLOC((topo_max_cpus + 1));\n\tif (_cpu_set == NULL)\n\t\terr(3, \"CPU_ALLOC\");\n\tsize = CPU_ALLOC_SIZE((topo_max_cpus + 1));\n\tCPU_ZERO_S(size, _cpu_set);\n\n\t*cpu_set = _cpu_set;\n\treturn size;\n}\n\nvoid free_cpu_set(cpu_set_t *cpu_set)\n{\n\tCPU_FREE(cpu_set);\n}\n\nstatic int cpu_cnt[MAX_PACKAGE_COUNT][MAX_DIE_PER_PACKAGE][MAX_PUNIT_PER_DIE];\n\nint get_max_punit_core_id(struct isst_id *id)\n{\n\tint max_id = 0;\n\tint i;\n\n\tfor (i = 0; i < topo_max_cpus; ++i)\n\t{\n\t\tif (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))\n\t\t\tcontinue;\n\n\t\tif (is_cpu_in_power_domain(i, id) &&\n\t\t    cpu_map[i].punit_cpu_core > max_id)\n\t\t\tmax_id = cpu_map[i].punit_cpu_core;\n\t}\n\n\treturn max_id;\n}\n\nint get_cpu_count(struct isst_id *id)\n{\n\tif (id->pkg < 0 || id->die < 0 || id->punit < 0)\n\t\treturn 0;\n\n\treturn cpu_cnt[id->pkg][id->die][id->punit];\n}\n\nstatic void update_punit_cpu_info(__u32 physical_cpu, struct _cpu_map *cpu_map)\n{\n\tif (api_version() > 1) {\n\t\t \n\t\tcpu_map->punit_id = (physical_cpu >> 11) & 0x1f;\n\t\tcpu_map->punit_cpu_core = (physical_cpu >> 3) & 0xff;\n\t\tcpu_map->punit_cpu = physical_cpu & 0x7ff;\n\t} else {\n\t\tint punit_id;\n\n\t\t \n\t\tcpu_map->punit_cpu = physical_cpu & 0x1ff;\n\t\tcpu_map->punit_cpu_core = (cpu_map->punit_cpu >> 1);  \n\t\tpunit_id = (physical_cpu >> 9) & 0x1f;\n\n\t\tif (punit_id >= MAX_PUNIT_PER_DIE)\n\t\t\tpunit_id = 0;\n\n\t\tcpu_map->punit_id = punit_id;\n\t}\n}\n\nstatic void create_cpu_map(void)\n{\n\tconst char *pathname = \"/dev/isst_interface\";\n\tsize_t size;\n\tDIR *dir;\n\tint i, fd = 0;\n\tstruct isst_if_cpu_maps map;\n\n\t \n\tcpu_map = calloc(topo_max_cpus, sizeof(*cpu_map));\n\tif (!cpu_map)\n\t\terr(3, \"cpumap\");\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0 && !is_clx_n_platform())\n\t\terr(-1, \"%s open failed\", pathname);\n\n\tsize = alloc_cpu_set(&present_cpumask);\n\tpresent_cpumask_size = size;\n\n\tfor (i = 0; i < topo_max_cpus; ++i) {\n\t\tchar buffer[256];\n\t\tint pkg_id, die_id, core_id, punit_id;\n\n\t\t \n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/cpu%d\", i);\n\t\tdir = opendir(buffer);\n\t\tif (!dir)\n\t\t\tcontinue;\n\t\tclosedir(dir);\n\n\t\tCPU_SET_S(i, size, present_cpumask);\n\n\t\tpkg_id = get_physical_package_id(i);\n\t\tdie_id = get_physical_die_id(i);\n\t\tcore_id = get_physical_core_id(i);\n\n\t\tif (pkg_id < 0 || die_id < 0 || core_id < 0)\n\t\t\tcontinue;\n\n\t\tcpu_map[i].pkg_id = pkg_id;\n\t\tcpu_map[i].die_id = die_id;\n\t\tcpu_map[i].core_id = core_id;\n\n\n\t\tpunit_id = 0;\n\n\t\tif (fd >= 0) {\n\t\t\tmap.cmd_count = 1;\n\t\t\tmap.cpu_map[0].logical_cpu = i;\n\t\t\tdebug_printf(\" map logical_cpu:%d\\n\",\n\t\t\t\t     map.cpu_map[0].logical_cpu);\n\t\t\tif (ioctl(fd, ISST_IF_GET_PHY_ID, &map) == -1) {\n\t\t\t\tperror(\"ISST_IF_GET_PHY_ID\");\n\t\t\t\tfprintf(outf, \"Error: map logical_cpu:%d\\n\",\n\t\t\t\t\tmap.cpu_map[0].logical_cpu);\n\t\t\t} else {\n\t\t\t\tupdate_punit_cpu_info(map.cpu_map[0].physical_cpu, &cpu_map[i]);\n\t\t\t\tpunit_id = cpu_map[i].punit_id;\n\t\t\t}\n\t\t}\n\t\tcpu_map[i].initialized = 1;\n\n\t\tcpu_cnt[pkg_id][die_id][punit_id]++;\n\n\t\tdebug_printf(\n\t\t\t\"map logical_cpu:%d core: %d die:%d pkg:%d punit:%d punit_cpu:%d punit_core:%d\\n\",\n\t\t\ti, cpu_map[i].core_id, cpu_map[i].die_id,\n\t\t\tcpu_map[i].pkg_id, cpu_map[i].punit_id,\n\t\t\tcpu_map[i].punit_cpu, cpu_map[i].punit_cpu_core);\n\t}\n\tif (fd >= 0)\n\t\tclose(fd);\n\n\tsize = alloc_cpu_set(&target_cpumask);\n\ttarget_cpumask_size = size;\n\tfor (i = 0; i < max_target_cpus; ++i) {\n\t\tif (!CPU_ISSET_S(target_cpus[i], present_cpumask_size,\n\t\t\t\t present_cpumask))\n\t\t\tcontinue;\n\n\t\tCPU_SET_S(target_cpus[i], size, target_cpumask);\n\t}\n}\n\nvoid set_cpu_mask_from_punit_coremask(struct isst_id *id, unsigned long long core_mask,\n\t\t\t\t      size_t core_cpumask_size,\n\t\t\t\t      cpu_set_t *core_cpumask, int *cpu_cnt)\n{\n\tint i, cnt = 0;\n\n\tif (id->cpu < 0)\n\t\treturn;\n\n\t*cpu_cnt = 0;\n\n\tfor (i = 0; i < 64; ++i) {\n\t\tif (core_mask & BIT_ULL(i)) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < topo_max_cpus; ++j) {\n\t\t\t\tif (!CPU_ISSET_S(j, present_cpumask_size, present_cpumask))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (is_cpu_in_power_domain(j, id) &&\n\t\t\t\t    cpu_map[j].punit_cpu_core == i) {\n\t\t\t\t\tCPU_SET_S(j, core_cpumask_size,\n\t\t\t\t\t\t  core_cpumask);\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*cpu_cnt = cnt;\n}\n\nint find_phy_core_num(int logical_cpu)\n{\n\tif (logical_cpu < topo_max_cpus)\n\t\treturn cpu_map[logical_cpu].punit_cpu_core;\n\n\treturn -EINVAL;\n}\n\nint use_cgroupv2(void)\n{\n\treturn cgroupv2;\n}\n\nint enable_cpuset_controller(void)\n{\n\tint fd, ret;\n\n\tfd = open(\"/sys/fs/cgroup/cgroup.subtree_control\", O_RDWR, 0);\n\tif (fd < 0) {\n\t\tdebug_printf(\"Can't activate cpuset controller\\n\");\n\t\tdebug_printf(\"Either you are not root user or CGroup v2 is not supported\\n\");\n\t\treturn fd;\n\t}\n\n\tret = write(fd, \" +cpuset\", strlen(\" +cpuset\"));\n\tclose(fd);\n\n\tif (ret == -1) {\n\t\tdebug_printf(\"Can't activate cpuset controller: Write failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint isolate_cpus(struct isst_id *id, int mask_size, cpu_set_t *cpu_mask, int level)\n{\n\tint i, first, curr_index, index, ret, fd;\n\tstatic char str[512], dir_name[64];\n\tstatic char cpuset_cpus[128];\n\tint str_len = sizeof(str);\n\tDIR *dir;\n\n\tsnprintf(dir_name, sizeof(dir_name), \"/sys/fs/cgroup/%d-%d-%d\", id->pkg, id->die, id->punit);\n\tdir = opendir(dir_name);\n\tif (!dir) {\n\t\tret = mkdir(dir_name, 0744);\n\t\tif (ret) {\n\t\t\tdebug_printf(\"Can't create dir:%s errno:%d\\n\", dir_name, errno);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tclosedir(dir);\n\n\tif (!level) {\n\t\tsprintf(cpuset_cpus, \"%s/cpuset.cpus.partition\", dir_name);\n\n\t\tfd = open(cpuset_cpus, O_RDWR, 0);\n\t\tif (fd < 0) {\n\t\t\treturn fd;\n\t\t}\n\n\t\tret = write(fd, \"member\", strlen(\"member\"));\n\t\tif (ret == -1) {\n\t\t\tprintf(\"Can't update to member\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!CPU_COUNT_S(mask_size, cpu_mask)) {\n\t\treturn -1;\n\t}\n\n\tcurr_index = 0;\n\tfirst = 1;\n\tstr[0] = '\\0';\n\tfor (i = 0; i < get_topo_max_cpus(); ++i) {\n\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\tcontinue;\n\n\t\tif (CPU_ISSET_S(i, mask_size, cpu_mask))\n\t\t\tcontinue;\n\n\t\tif (!first) {\n\t\t\tindex = snprintf(&str[curr_index],\n\t\t\t\t\t str_len - curr_index, \",\");\n\t\t\tcurr_index += index;\n\t\t\tif (curr_index >= str_len)\n\t\t\t\tbreak;\n\t\t}\n\t\tindex = snprintf(&str[curr_index], str_len - curr_index, \"%d\",\n\t\t\t\t i);\n\t\tcurr_index += index;\n\t\tif (curr_index >= str_len)\n\t\t\tbreak;\n\t\tfirst = 0;\n\t}\n\n\tdebug_printf(\"isolated CPUs list: package:%d curr_index:%d [%s]\\n\", id->pkg, curr_index ,str);\n\n\tsnprintf(cpuset_cpus, sizeof(cpuset_cpus), \"%s/cpuset.cpus\", dir_name);\n\n\tfd = open(cpuset_cpus, O_RDWR, 0);\n\tif (fd < 0) {\n\t\treturn fd;\n\t}\n\n\tret = write(fd, str, strlen(str));\n\tclose(fd);\n\n\tif (ret == -1) {\n\t\tdebug_printf(\"Can't activate cpuset controller: Write failed\\n\");\n\t\treturn ret;\n\t}\n\n\tsnprintf(cpuset_cpus, sizeof(cpuset_cpus), \"%s/cpuset.cpus.partition\", dir_name);\n\n\tfd = open(cpuset_cpus, O_RDWR, 0);\n\tif (fd < 0) {\n\t\treturn fd;\n\t}\n\n\tret = write(fd, \"isolated\", strlen(\"isolated\"));\n\tif (ret == -1) {\n\t\tdebug_printf(\"Can't update to isolated\\n\");\n\t\tret = write(fd, \"root\", strlen(\"root\"));\n\t\tif (ret == -1)\n\t\t\tdebug_printf(\"Can't update to root\\n\");\n\t}\n\n\tclose(fd);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int isst_fill_platform_info(void)\n{\n\tconst char *pathname = \"/dev/isst_interface\";\n\tint fd;\n\n\tif (is_clx_n_platform()) {\n\t\tisst_platform_info.api_version = 1;\n\t\tgoto set_platform_ops;\n\t}\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\terr(-1, \"%s open failed\", pathname);\n\n\tif (ioctl(fd, ISST_IF_GET_PLATFORM_INFO, &isst_platform_info) == -1) {\n\t\tperror(\"ISST_IF_GET_PLATFORM_INFO\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tclose(fd);\n\n\tif (isst_platform_info.api_version > supported_api_ver) {\n\t\tprintf(\"Incompatible API versions; Upgrade of tool is required\\n\");\n\t\treturn -1;\n\t}\n\nset_platform_ops:\n\tif (isst_set_platform_ops(isst_platform_info.api_version)) {\n\t\tfprintf(stderr, \"Failed to set platform callbacks\\n\");\n\t\texit(0);\n\t}\n\treturn 0;\n}\n\nvoid get_isst_status(struct isst_id *id, void *arg1, void *arg2, void *arg3, void *arg4)\n{\n\tstruct isst_pkg_ctdp pkg_dev;\n\tstruct isst_id *tid = (struct isst_id *)arg2;\n\tint *mask = (int *)arg3;\n\tint *max_level = (int *)arg4;\n\tint j, ret;\n\n\t \n\tif (id->cpu < 0 || tid->cpu >= 0)\n\t\treturn;\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret)\n\t\treturn;\n\n\tif (pkg_dev.enabled)\n\t\t*mask |= BIT(0);\n\n\tif (pkg_dev.locked)\n\t\t*mask |= BIT(1);\n\n\tif (*max_level < pkg_dev.levels)\n\t\t*max_level = pkg_dev.levels;\n\n\tfor (j = 0; j <= pkg_dev.levels; ++j) {\n\t\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\n\t\tret = isst_get_ctdp_control(id, j, &ctdp_level);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (ctdp_level.fact_support)\n\t\t\t*mask |= BIT(2);\n\n\t\tif (ctdp_level.pbf_support)\n\t\t\t*mask |= BIT(3);\n\t}\n\n\ttid->cpu = id->cpu;\n\ttid->pkg = id->pkg;\n\ttid->die = id->die;\n\ttid->punit = id->punit;\n}\n\nstatic void isst_print_extended_platform_info(void)\n{\n\tint cp_state, cp_cap;\n\tstruct isst_id id;\n\tint mask = 0, max_level = 0;\n\n\tid.cpu = -1;\n\tfor_each_online_power_domain_in_set(get_isst_status, NULL, &id, &mask, &max_level);\n\n\tif (mask & BIT(0)) {\n\t\tfprintf(outf, \"Intel(R) SST-PP (feature perf-profile) is supported\\n\");\n\t} else {\n\t\tfprintf(outf, \"Intel(R) SST-PP (feature perf-profile) is not supported\\n\");\n\t\tfprintf(outf, \"Only performance level 0 (base level) is present\\n\");\n\t}\n\n\tif (mask & BIT(1))\n\t\tfprintf(outf, \"TDP level change control is locked\\n\");\n\telse\n\t\tfprintf(outf, \"TDP level change control is unlocked, max level: %d\\n\", max_level);\n\n\tif (mask & BIT(2))\n\t\tfprintf(outf, \"Intel(R) SST-TF (feature turbo-freq) is supported\\n\");\n\telse\n\t\tfprintf(outf, \"Intel(R) SST-TF (feature turbo-freq) is not supported\\n\");\n\n\tif (mask & BIT(3))\n\t\tfprintf(outf, \"Intel(R) SST-BF (feature base-freq) is supported\\n\");\n\telse\n\t\tfprintf(outf, \"Intel(R) SST-BF (feature base-freq) is not supported\\n\");\n\n\tif (isst_read_pm_config(&id, &cp_state, &cp_cap)) {\n\t\tfprintf(outf, \"Intel(R) SST-CP (feature core-power) status is unknown\\n\");\n\t\treturn;\n\t}\n\n\tif (cp_cap)\n\t\tfprintf(outf, \"Intel(R) SST-CP (feature core-power) is supported\\n\");\n\telse\n\t\tfprintf(outf, \"Intel(R) SST-CP (feature core-power) is not supported\\n\");\n}\n\nstatic void isst_print_platform_information(void)\n{\n\tif (is_clx_n_platform()) {\n\t\tfprintf(stderr, \"\\nThis option in not supported on this platform\\n\");\n\t\texit(0);\n\t}\n\n\t \n\tset_max_cpu_num();\n\tcreate_cpu_map();\n\n\tfprintf(outf, \"Platform: API version : %d\\n\",\n\t\tisst_platform_info.api_version);\n\tfprintf(outf, \"Platform: Driver version : %d\\n\",\n\t\tisst_platform_info.driver_version);\n\tfprintf(outf, \"Platform: mbox supported : %d\\n\",\n\t\tisst_platform_info.mbox_supported);\n\tfprintf(outf, \"Platform: mmio supported : %d\\n\",\n\t\tisst_platform_info.mmio_supported);\n\tisst_print_extended_platform_info();\n\n\texit(0);\n}\n\nstatic char *local_str0, *local_str1;\nstatic void exec_on_get_ctdp_cpu(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t\t void *arg4)\n{\n\tint (*fn_ptr)(struct isst_id *id, void *arg);\n\tint ret;\n\n\tfn_ptr = arg1;\n\tret = fn_ptr(id, arg2);\n\tif (ret)\n\t\tisst_display_error_info_message(1, \"get_tdp_* failed\", 0, 0);\n\telse\n\t\tisst_ctdp_display_core_info(id, outf, arg3,\n\t\t\t\t\t    *(unsigned int *)arg4,\n\t\t\t\t\t    local_str0, local_str1);\n}\n\n#define _get_tdp_level(desc, suffix, object, help, str0, str1)\t\t\t\\\n\tstatic void get_tdp_##object(int arg)                                    \\\n\t{                                                                         \\\n\t\tstruct isst_pkg_ctdp ctdp;                                        \\\n\\\n\t\tif (cmd_help) {                                                   \\\n\t\t\tfprintf(stderr,                                           \\\n\t\t\t\t\"Print %s [No command arguments are required]\\n\", \\\n\t\t\t\thelp);                                            \\\n\t\t\texit(0);                                                  \\\n\t\t}                                                                 \\\n\t\tlocal_str0 = str0;\t\t\t\t\t\t  \\\n\t\tlocal_str1 = str1;\t\t\t\t\t\t  \\\n\t\tisst_ctdp_display_information_start(outf);                        \\\n\t\tif (max_target_cpus)                                              \\\n\t\t\tfor_each_online_target_cpu_in_set(                        \\\n\t\t\t\texec_on_get_ctdp_cpu, isst_get_ctdp_##suffix,     \\\n\t\t\t\t&ctdp, desc, &ctdp.object);                       \\\n\t\telse                                                              \\\n\t\t\tfor_each_online_power_domain_in_set(exec_on_get_ctdp_cpu,      \\\n\t\t\t\t\t\t       isst_get_ctdp_##suffix,    \\\n\t\t\t\t\t\t       &ctdp, desc,               \\\n\t\t\t\t\t\t       &ctdp.object);             \\\n\t\tisst_ctdp_display_information_end(outf);                          \\\n\t}\n\n_get_tdp_level(\"get-config-levels\", levels, levels, \"Max TDP level\", NULL, NULL);\n_get_tdp_level(\"get-config-version\", levels, version, \"TDP version\", NULL, NULL);\n_get_tdp_level(\"get-config-enabled\", levels, enabled, \"perf-profile enable status\", \"disabled\", \"enabled\");\n_get_tdp_level(\"get-config-current_level\", levels, current_level,\n\t       \"Current TDP Level\", NULL, NULL);\n_get_tdp_level(\"get-lock-status\", levels, locked, \"TDP lock status\", \"unlocked\", \"locked\");\n\nstruct isst_pkg_ctdp clx_n_pkg_dev;\n\nstatic int clx_n_get_base_ratio(void)\n{\n\tFILE *fp;\n\tchar *begin, *end, *line = NULL;\n\tchar number[5];\n\tfloat value = 0;\n\tsize_t n = 0;\n\n\tfp = fopen(\"/proc/cpuinfo\", \"r\");\n\tif (!fp)\n\t\terr(-1, \"cannot open /proc/cpuinfo\\n\");\n\n\twhile (getline(&line, &n, fp) > 0) {\n\t\tif (strstr(line, \"model name\")) {\n\t\t\t \n\t\t\tbegin = strstr(line, \"@ \") + 2;\n\t\t\tend = strstr(line, \"GHz\");\n\t\t\tstrncpy(number, begin, end - begin);\n\t\t\tvalue = atof(number) * 10;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(line);\n\tfclose(fp);\n\n\treturn (int)(value);\n}\n\nstatic int clx_n_config(struct isst_id *id)\n{\n\tint i, ret;\n\tunsigned long cpu_bf;\n\tstruct isst_pkg_ctdp_level_info *ctdp_level;\n\tstruct isst_pbf_info *pbf_info;\n\n\tctdp_level = &clx_n_pkg_dev.ctdp_level[0];\n\tpbf_info = &ctdp_level->pbf_info;\n\tctdp_level->core_cpumask_size =\n\t\t\talloc_cpu_set(&ctdp_level->core_cpumask);\n\n\t \n\tctdp_level->tdp_ratio = clx_n_get_base_ratio();\n\tif (ctdp_level->tdp_ratio == 0) {\n\t\tdebug_printf(\"CLX: cn base ratio is zero\\n\");\n\t\tret = -1;\n\t\tgoto error_ret;\n\t}\n\n\t \n\tpbf_info->p1_high = 0;\n\tpbf_info->p1_low = ~0;\n\n\tfor (i = 0; i < topo_max_cpus; i++) {\n\t\tif (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))\n\t\t\tcontinue;\n\n\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\tcontinue;\n\n\t\tCPU_SET_S(i, ctdp_level->core_cpumask_size,\n\t\t\t  ctdp_level->core_cpumask);\n\n\t\tcpu_bf = parse_int_file(1,\n\t\t\t\"/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency\",\n\t\t\t\t\ti);\n\t\tif (cpu_bf > pbf_info->p1_high)\n\t\t\tpbf_info->p1_high = cpu_bf;\n\t\tif (cpu_bf < pbf_info->p1_low)\n\t\t\tpbf_info->p1_low = cpu_bf;\n\t}\n\n\tif (pbf_info->p1_high == ~0UL) {\n\t\tdebug_printf(\"CLX: maximum base frequency not set\\n\");\n\t\tret = -1;\n\t\tgoto error_ret;\n\t}\n\n\tif (pbf_info->p1_low == 0) {\n\t\tdebug_printf(\"CLX: minimum base frequency not set\\n\");\n\t\tret = -1;\n\t\tgoto error_ret;\n\t}\n\n\t \n\tpbf_info->p1_high = pbf_info->p1_high / 100000;\n\tpbf_info->p1_low = pbf_info->p1_low / 100000;\n\n\t \n\tpbf_info->core_cpumask_size = alloc_cpu_set(&pbf_info->core_cpumask);\n\tfor (i = 0; i < topo_max_cpus; i++) {\n\t\tif (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))\n\t\t\tcontinue;\n\n\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\tcontinue;\n\n\t\tcpu_bf = parse_int_file(1,\n\t\t\t\"/sys/devices/system/cpu/cpu%d/cpufreq/base_frequency\",\n\t\t\t\t\ti);\n\t\tcpu_bf = cpu_bf / 100000;\n\t\tif (cpu_bf == pbf_info->p1_high)\n\t\t\tCPU_SET_S(i, pbf_info->core_cpumask_size,\n\t\t\t\t  pbf_info->core_cpumask);\n\t}\n\n\t \n\tctdp_level->processed = 1;\n\tctdp_level->pbf_support = 1;  \n\tctdp_level->pbf_enabled = 1;\n\tctdp_level->fact_support = 0;  \n\tctdp_level->fact_enabled = 0;\n\n\treturn 0;\n\nerror_ret:\n\tfree_cpu_set(ctdp_level->core_cpumask);\n\treturn ret;\n}\n\nstatic void dump_clx_n_config_for_cpu(struct isst_id *id, void *arg1, void *arg2,\n\t\t\t\t   void *arg3, void *arg4)\n{\n\tint ret;\n\n\tif (tdp_level != 0xff && tdp_level != 0) {\n\t\tisst_display_error_info_message(1, \"Invalid level\", 1, tdp_level);\n\t\texit(0);\n\t}\n\n\tret = clx_n_config(id);\n\tif (ret) {\n\t\tdebug_printf(\"clx_n_config failed\");\n\t} else {\n\t\tstruct isst_pkg_ctdp_level_info *ctdp_level;\n\t\tstruct isst_pbf_info *pbf_info;\n\n\t\tctdp_level = &clx_n_pkg_dev.ctdp_level[0];\n\t\tpbf_info = &ctdp_level->pbf_info;\n\t\tclx_n_pkg_dev.processed = 1;\n\t\tisst_ctdp_display_information(id, outf, tdp_level, &clx_n_pkg_dev);\n\t\tfree_cpu_set(ctdp_level->core_cpumask);\n\t\tfree_cpu_set(pbf_info->core_cpumask);\n\t}\n}\n\nstatic void dump_isst_config_for_cpu(struct isst_id *id, void *arg1, void *arg2,\n\t\t\t\t     void *arg3, void *arg4)\n{\n\tstruct isst_pkg_ctdp pkg_dev;\n\tint ret;\n\n\tmemset(&pkg_dev, 0, sizeof(pkg_dev));\n\tret = isst_get_process_ctdp(id, tdp_level, &pkg_dev);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Failed to get perf-profile info on cpu\", 1, id->cpu);\n\t\tisst_ctdp_display_information_end(outf);\n\t\texit(1);\n\t} else {\n\t\tisst_ctdp_display_information(id, outf, tdp_level, &pkg_dev);\n\t\tisst_get_process_ctdp_complete(id, &pkg_dev);\n\t}\n}\n\nstatic void dump_isst_config(int arg)\n{\n\tvoid *fn;\n\n\tif (cmd_help) {\n\t\tfprintf(stderr,\n\t\t\t\"Print Intel(R) Speed Select Technology Performance profile configuration\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"including base frequency and turbo frequency configurations\\n\");\n\t\tfprintf(stderr, \"Optional: -l|--level : Specify tdp level\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tIf no arguments, dump information for all TDP levels\\n\");\n\t\texit(0);\n\t}\n\n\tif (!is_clx_n_platform())\n\t\tfn = dump_isst_config_for_cpu;\n\telse\n\t\tfn = dump_clx_n_config_for_cpu;\n\n\tisst_ctdp_display_information_start(outf);\n\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(fn, NULL, NULL, NULL, NULL);\n\telse\n\t\tfor_each_online_power_domain_in_set(fn, NULL, NULL, NULL, NULL);\n\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void adjust_scaling_max_from_base_freq(int cpu);\n\nstatic void set_tdp_level_for_cpu(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t\t  void *arg4)\n{\n\tstruct isst_pkg_ctdp pkg_dev;\n\tint ret;\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Get TDP level failed\", 0, 0);\n\t\tisst_ctdp_display_information_end(outf);\n\t\texit(1);\n\t}\n\n\tif (pkg_dev.current_level == tdp_level) {\n\t\tdebug_printf(\"TDP level already set. Skipped\\n\");\n\t\tgoto display_result;\n\t}\n\n\tret = isst_set_tdp_level(id, tdp_level);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Set TDP level failed\", 0, 0);\n\t\tisst_ctdp_display_information_end(outf);\n\t\texit(1);\n\t}\n\ndisplay_result:\n\tisst_display_result(id, outf, \"perf-profile\", \"set_tdp_level\", ret);\n\tif (force_online_offline && id->cpu >= 0) {\n\t\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\n\t\t \n\t\tusleep(2000);\n\n\t\t \n\t\tisst_adjust_uncore_freq(id, tdp_level, &ctdp_level);\n\n\t\tfprintf(stderr, \"Option is set to online/offline\\n\");\n\t\tctdp_level.core_cpumask_size =\n\t\t\talloc_cpu_set(&ctdp_level.core_cpumask);\n\t\tret = isst_get_coremask_info(id, tdp_level, &ctdp_level);\n\t\tif (ret) {\n\t\t\tisst_display_error_info_message(1, \"Can't get coremask, online/offline option is ignored\", 0, 0);\n\t\t\tgoto free_mask;\n\t\t}\n\n\t\tif (use_cgroupv2()) {\n\t\t\tint ret;\n\n\t\t\tfprintf(stderr, \"Using cgroup v2 in lieu of online/offline\\n\");\n\t\t\tret = enable_cpuset_controller();\n\t\t\tif (ret)\n\t\t\t\tgoto use_offline;\n\n\t\t\tret = isolate_cpus(id, ctdp_level.core_cpumask_size, ctdp_level.core_cpumask, tdp_level);\n\t\t\tif (ret)\n\t\t\t\tgoto use_offline;\n\n\t\t\tgoto free_mask;\n\t\t}\n\nuse_offline:\n\t\tif (ctdp_level.cpu_count) {\n\t\t\tint i, max_cpus = get_topo_max_cpus();\n\t\t\tfor (i = 0; i < max_cpus; ++i) {\n\t\t\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (CPU_ISSET_S(i, ctdp_level.core_cpumask_size, ctdp_level.core_cpumask)) {\n\t\t\t\t\tfprintf(stderr, \"online cpu %d\\n\", i);\n\t\t\t\t\tset_cpu_online_offline(i, 1);\n\t\t\t\t\tadjust_scaling_max_from_base_freq(i);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"offline cpu %d\\n\", i);\n\t\t\t\t\tset_cpu_online_offline(i, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\nfree_mask:\n\t\tfree_cpu_set(ctdp_level.core_cpumask);\n\t}\n}\n\nstatic void set_tdp_level(int arg)\n{\n\tif (cmd_help) {\n\t\tfprintf(stderr, \"Set Config TDP level\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\t Arguments: -l|--level : Specify tdp level\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\t Optional Arguments: -o | online : online/offline for the tdp level\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\t  online/offline operation has limitations, refer to Linux hotplug documentation\\n\");\n\t\texit(0);\n\t}\n\n\tif (tdp_level == 0xff) {\n\t\tisst_display_error_info_message(1, \"Invalid command: specify tdp_level\", 0, 0);\n\t\texit(1);\n\t}\n\tisst_ctdp_display_information_start(outf);\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(set_tdp_level_for_cpu, NULL,\n\t\t\t\t\t\t  NULL, NULL, NULL);\n\telse\n\t\tfor_each_online_power_domain_in_set(set_tdp_level_for_cpu, NULL,\n\t\t\t\t\t       NULL, NULL, NULL);\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void clx_n_dump_pbf_config_for_cpu(struct isst_id *id, void *arg1, void *arg2,\n\t\t\t\t       void *arg3, void *arg4)\n{\n\tint ret;\n\n\tret = clx_n_config(id);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"clx_n_config failed\", 0, 0);\n\t} else {\n\t\tstruct isst_pkg_ctdp_level_info *ctdp_level;\n\t\tstruct isst_pbf_info *pbf_info;\n\n\t\tctdp_level = &clx_n_pkg_dev.ctdp_level[0];\n\t\tpbf_info = &ctdp_level->pbf_info;\n\t\tisst_pbf_display_information(id, outf, tdp_level, pbf_info);\n\t\tfree_cpu_set(ctdp_level->core_cpumask);\n\t\tfree_cpu_set(pbf_info->core_cpumask);\n\t}\n}\n\nstatic void dump_pbf_config_for_cpu(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t\t    void *arg4)\n{\n\tstruct isst_pbf_info pbf_info;\n\tint ret;\n\n\tret = isst_get_pbf_info(id, tdp_level, &pbf_info);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Failed to get base-freq info at this level\", 1, tdp_level);\n\t\tisst_ctdp_display_information_end(outf);\n\t\texit(1);\n\t} else {\n\t\tisst_pbf_display_information(id, outf, tdp_level, &pbf_info);\n\t\tfree_cpu_set(pbf_info.core_cpumask);\n\t}\n}\n\nstatic void dump_pbf_config(int arg)\n{\n\tvoid *fn;\n\n\tif (cmd_help) {\n\t\tfprintf(stderr,\n\t\t\t\"Print Intel(R) Speed Select Technology base frequency configuration for a TDP level\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tArguments: -l|--level : Specify tdp level\\n\");\n\t\texit(0);\n\t}\n\n\tif (tdp_level == 0xff) {\n\t\tisst_display_error_info_message(1, \"Invalid command: specify tdp_level\", 0, 0);\n\t\texit(1);\n\t}\n\n\tif (!is_clx_n_platform())\n\t\tfn = dump_pbf_config_for_cpu;\n\telse\n\t\tfn = clx_n_dump_pbf_config_for_cpu;\n\n\tisst_ctdp_display_information_start(outf);\n\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(fn, NULL, NULL, NULL, NULL);\n\telse\n\t\tfor_each_online_power_domain_in_set(fn, NULL, NULL, NULL, NULL);\n\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic int set_clos_param(struct isst_id *id, int clos, int epp, int wt, int min, int max)\n{\n\tstruct isst_clos_config clos_config;\n\tint ret;\n\n\tret = isst_pm_get_clos(id, clos, &clos_config);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"isst_pm_get_clos failed\", 0, 0);\n\t\treturn ret;\n\t}\n\tclos_config.clos_min = min;\n\tclos_config.clos_max = max;\n\tclos_config.epp = epp;\n\tclos_config.clos_prop_prio = wt;\n\tret = isst_set_clos(id, clos, &clos_config);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"isst_set_clos failed\", 0, 0);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_cpufreq_scaling_min_max(int cpu, int max, int freq)\n{\n\tchar buffer[128], freq_str[16];\n\tint fd, ret, len;\n\n\tif (max)\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_max_freq\", cpu);\n\telse\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_min_freq\", cpu);\n\n\tfd = open(buffer, O_WRONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tsnprintf(freq_str, sizeof(freq_str), \"%d\", freq);\n\tlen = strlen(freq_str);\n\tret = write(fd, freq_str, len);\n\tif (ret == -1) {\n\t\tclose(fd);\n\t\treturn ret;\n\t}\n\tclose(fd);\n\n\treturn 0;\n}\n\nstatic int no_turbo(void)\n{\n\treturn parse_int_file(0, \"/sys/devices/system/cpu/intel_pstate/no_turbo\");\n}\n\nstatic void adjust_scaling_max_from_base_freq(int cpu)\n{\n\tint base_freq, scaling_max_freq;\n\n\tscaling_max_freq = parse_int_file(0, \"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_max_freq\", cpu);\n\tbase_freq = get_cpufreq_base_freq(cpu);\n\tif (scaling_max_freq < base_freq || no_turbo())\n\t\tset_cpufreq_scaling_min_max(cpu, 1, base_freq);\n}\n\nstatic void adjust_scaling_min_from_base_freq(int cpu)\n{\n\tint base_freq, scaling_min_freq;\n\n\tscaling_min_freq = parse_int_file(0, \"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_min_freq\", cpu);\n\tbase_freq = get_cpufreq_base_freq(cpu);\n\tif (scaling_min_freq < base_freq)\n\t\tset_cpufreq_scaling_min_max(cpu, 0, base_freq);\n}\n\nstatic int set_clx_pbf_cpufreq_scaling_min_max(struct isst_id *id)\n{\n\tstruct isst_pkg_ctdp_level_info *ctdp_level;\n\tstruct isst_pbf_info *pbf_info;\n\tint i, freq, freq_high, freq_low;\n\tint ret;\n\n\tret = clx_n_config(id);\n\tif (ret) {\n\t\tdebug_printf(\"cpufreq_scaling_min_max failed for CLX\");\n\t\treturn ret;\n\t}\n\n\tctdp_level = &clx_n_pkg_dev.ctdp_level[0];\n\tpbf_info = &ctdp_level->pbf_info;\n\tfreq_high = pbf_info->p1_high * 100000;\n\tfreq_low = pbf_info->p1_low * 100000;\n\n\tfor (i = 0; i < get_topo_max_cpus(); ++i) {\n\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\tcontinue;\n\n\t\tif (CPU_ISSET_S(i, pbf_info->core_cpumask_size,\n\t\t\t\t  pbf_info->core_cpumask))\n\t\t\tfreq = freq_high;\n\t\telse\n\t\t\tfreq = freq_low;\n\n\t\tset_cpufreq_scaling_min_max(i, 1, freq);\n\t\tset_cpufreq_scaling_min_max(i, 0, freq);\n\t}\n\n\treturn 0;\n}\n\nstatic int set_cpufreq_scaling_min_max_from_cpuinfo(int cpu, int cpuinfo_max, int scaling_max)\n{\n\tchar buffer[128], min_freq[16];\n\tint fd, ret, len;\n\n\tif (!CPU_ISSET_S(cpu, present_cpumask_size, present_cpumask))\n\t\treturn -1;\n\n\tif (cpuinfo_max)\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_max_freq\", cpu);\n\telse\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/cpu%d/cpufreq/cpuinfo_min_freq\", cpu);\n\n\tfd = open(buffer, O_RDONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tlen = read(fd, min_freq, sizeof(min_freq));\n\tclose(fd);\n\n\tif (len < 0)\n\t\treturn len;\n\n\tif (scaling_max)\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_max_freq\", cpu);\n\telse\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_min_freq\", cpu);\n\n\tfd = open(buffer, O_WRONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tmin_freq[15] = '\\0';\n\tlen = strlen(min_freq);\n\tret = write(fd, min_freq, len);\n\tif (ret == -1) {\n\t\tclose(fd);\n\t\treturn ret;\n\t}\n\tclose(fd);\n\n\treturn 0;\n}\n\nstatic void set_scaling_min_to_cpuinfo_max(struct isst_id *id)\n{\n\tint i;\n\n\tif (id->cpu < 0)\n\t\treturn;\n\n\tfor (i = 0; i < get_topo_max_cpus(); ++i) {\n\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\tcontinue;\n\n\t\tif (is_cpu_online(i) != 1)\n\t\t\tcontinue;\n\n\t\tadjust_scaling_max_from_base_freq(i);\n\t\tset_cpufreq_scaling_min_max_from_cpuinfo(i, 1, 0);\n\t\tadjust_scaling_min_from_base_freq(i);\n\t}\n}\n\nstatic void set_scaling_min_to_cpuinfo_min(struct isst_id *id)\n{\n\tint i;\n\n\tif (id->cpu < 0)\n\t\treturn;\n\n\tfor (i = 0; i < get_topo_max_cpus(); ++i) {\n\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\tcontinue;\n\n\t\tif (is_cpu_online(i) != 1)\n\t\t\tcontinue;\n\n\t\tadjust_scaling_max_from_base_freq(i);\n\t\tset_cpufreq_scaling_min_max_from_cpuinfo(i, 0, 0);\n\t}\n}\n\nstatic void set_scaling_max_to_cpuinfo_max(struct isst_id *id)\n{\n\tint i;\n\n\tfor (i = 0; i < get_topo_max_cpus(); ++i) {\n\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\tcontinue;\n\n\t\tset_cpufreq_scaling_min_max_from_cpuinfo(i, 1, 1);\n\t}\n}\n\nstatic int set_core_priority_and_min(struct isst_id *id, int mask_size,\n\t\t\t\t     cpu_set_t *cpu_mask, int min_high,\n\t\t\t\t     int min_low)\n{\n\tint ret, i;\n\n\tif (!CPU_COUNT_S(mask_size, cpu_mask))\n\t\treturn -1;\n\n\tret = set_clos_param(id, 0, 0, 0, min_high, 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = set_clos_param(id, 1, 15, 15, min_low, 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = set_clos_param(id, 2, 15, 15, min_low, 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = set_clos_param(id, 3, 15, 15, min_low, 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < get_topo_max_cpus(); ++i) {\n\t\tint clos;\n\t\tstruct isst_id tid;\n\n\t\tif (!is_cpu_in_power_domain(i, id))\n\t\t\tcontinue;\n\n\t\tif (CPU_ISSET_S(i, mask_size, cpu_mask))\n\t\t\tclos = 0;\n\t\telse\n\t\t\tclos = 3;\n\n\t\tdebug_printf(\"Associate cpu: %d clos: %d\\n\", i, clos);\n\t\tset_isst_id(&tid, i);\n\t\tret = isst_clos_associate(&tid, clos);\n\t\tif (ret) {\n\t\t\tisst_display_error_info_message(1, \"isst_clos_associate failed\", 0, 0);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int set_pbf_core_power(struct isst_id *id)\n{\n\tstruct isst_pbf_info pbf_info;\n\tstruct isst_pkg_ctdp pkg_dev;\n\tint ret;\n\n\tif (id->cpu < 0)\n\t\treturn 0;\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret) {\n\t\tdebug_printf(\"isst_get_ctdp_levels failed\");\n\t\treturn ret;\n\t}\n\tdebug_printf(\"Current_level: %d\\n\", pkg_dev.current_level);\n\n\tret = isst_get_pbf_info(id, pkg_dev.current_level, &pbf_info);\n\tif (ret) {\n\t\tdebug_printf(\"isst_get_pbf_info failed\");\n\t\treturn ret;\n\t}\n\tdebug_printf(\"p1_high: %d p1_low: %d\\n\", pbf_info.p1_high,\n\t\t     pbf_info.p1_low);\n\n\tret = set_core_priority_and_min(id, pbf_info.core_cpumask_size,\n\t\t\t\t\tpbf_info.core_cpumask,\n\t\t\t\t\tpbf_info.p1_high, pbf_info.p1_low);\n\tif (ret) {\n\t\tdebug_printf(\"set_core_priority_and_min failed\");\n\t\treturn ret;\n\t}\n\n\tret = isst_pm_qos_config(id, 1, 1);\n\tif (ret) {\n\t\tdebug_printf(\"isst_pm_qos_config failed\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void set_pbf_for_cpu(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t    void *arg4)\n{\n\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\tstruct isst_pkg_ctdp pkg_dev;\n\tint ret;\n\tint status = *(int *)arg4;\n\n\tif (is_clx_n_platform()) {\n\t\tret = 0;\n\t\tif (status) {\n\t\t\tset_clx_pbf_cpufreq_scaling_min_max(id);\n\n\t\t} else {\n\t\t\tset_scaling_max_to_cpuinfo_max(id);\n\t\t\tset_scaling_min_to_cpuinfo_min(id);\n\t\t}\n\t\tgoto disp_result;\n\t}\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Failed to get number of levels\", 0, 0);\n\t\tgoto disp_result;\n\t}\n\n\tret = isst_get_ctdp_control(id, pkg_dev.current_level, &ctdp_level);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Failed to get current level\", 0, 0);\n\t\tgoto disp_result;\n\t}\n\n\tif (!ctdp_level.pbf_support) {\n\t\tisst_display_error_info_message(1, \"base-freq feature is not present at this level\", 1, pkg_dev.current_level);\n\t\tret = -1;\n\t\tgoto disp_result;\n\t}\n\n\tif (auto_mode && status) {\n\t\tret = set_pbf_core_power(id);\n\t\tif (ret)\n\t\t\tgoto disp_result;\n\t}\n\n\tret = isst_set_pbf_fact_status(id, 1, status);\n\tif (ret) {\n\t\tdebug_printf(\"isst_set_pbf_fact_status failed\");\n\t\tif (auto_mode)\n\t\t\tisst_pm_qos_config(id, 0, 0);\n\t} else {\n\t\tif (auto_mode) {\n\t\t\tif (status)\n\t\t\t\tset_scaling_min_to_cpuinfo_max(id);\n\t\t\telse\n\t\t\t\tset_scaling_min_to_cpuinfo_min(id);\n\t\t}\n\t}\n\n\tif (auto_mode && !status)\n\t\tisst_pm_qos_config(id, 0, 1);\n\ndisp_result:\n\tif (status)\n\t\tisst_display_result(id, outf, \"base-freq\", \"enable\",\n\t\t\t\t    ret);\n\telse\n\t\tisst_display_result(id, outf, \"base-freq\", \"disable\",\n\t\t\t\t    ret);\n}\n\nstatic void set_pbf_enable(int arg)\n{\n\tint enable = arg;\n\n\tif (cmd_help) {\n\t\tif (enable) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Enable Intel Speed Select Technology base frequency feature\\n\");\n\t\t\tif (is_clx_n_platform()) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"\\tOn this platform this command doesn't enable feature in the hardware.\\n\");\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"\\tIt updates the cpufreq scaling_min_freq to match cpufreq base_frequency.\\n\");\n\t\t\t\texit(0);\n\n\t\t\t}\n\t\t\tfprintf(stderr,\n\t\t\t\t\"\\tOptional Arguments: -a|--auto : Use priority of cores to set core-power associations\\n\");\n\t\t} else {\n\n\t\t\tif (is_clx_n_platform()) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"\\tOn this platform this command doesn't disable feature in the hardware.\\n\");\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"\\tIt updates the cpufreq scaling_min_freq to match cpuinfo_min_freq\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Disable Intel Speed Select Technology base frequency feature\\n\");\n\t\t\tfprintf(stderr,\n\t\t\t\t\"\\tOptional Arguments: -a|--auto : Also disable core-power associations\\n\");\n\t\t}\n\t\texit(0);\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(set_pbf_for_cpu, NULL, NULL,\n\t\t\t\t\t\t  NULL, &enable);\n\telse\n\t\tfor_each_online_power_domain_in_set(set_pbf_for_cpu, NULL, NULL,\n\t\t\t\t\t       NULL, &enable);\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void dump_fact_config_for_cpu(struct isst_id *id, void *arg1, void *arg2,\n\t\t\t\t     void *arg3, void *arg4)\n{\n\tstruct isst_fact_info fact_info;\n\tint ret;\n\n\tret = isst_get_fact_info(id, tdp_level, fact_bucket, &fact_info);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Failed to get turbo-freq info at this level\", 1, tdp_level);\n\t\tisst_ctdp_display_information_end(outf);\n\t\texit(1);\n\t} else {\n\t\tisst_fact_display_information(id, outf, tdp_level, fact_bucket,\n\t\t\t\t\t      fact_avx, &fact_info);\n\t}\n}\n\nstatic void dump_fact_config(int arg)\n{\n\tif (cmd_help) {\n\t\tfprintf(stderr,\n\t\t\t\"Print complete Intel Speed Select Technology turbo frequency configuration for a TDP level. Other arguments are optional.\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tArguments: -l|--level : Specify tdp level\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tArguments: -b|--bucket : Bucket index to dump\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tArguments: -r|--trl-type : Specify trl type: sse|avx2|avx512\\n\");\n\t\texit(0);\n\t}\n\n\tif (tdp_level == 0xff) {\n\t\tisst_display_error_info_message(1, \"Invalid command: specify tdp_level\\n\", 0, 0);\n\t\texit(1);\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(dump_fact_config_for_cpu,\n\t\t\t\t\t\t  NULL, NULL, NULL, NULL);\n\telse\n\t\tfor_each_online_power_domain_in_set(dump_fact_config_for_cpu, NULL,\n\t\t\t\t\t       NULL, NULL, NULL);\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void set_fact_for_cpu(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t     void *arg4)\n{\n\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\tstruct isst_pkg_ctdp pkg_dev;\n\tint ret;\n\tint status = *(int *)arg4;\n\n\tif (status && no_turbo()) {\n\t\tisst_display_error_info_message(1, \"Turbo mode is disabled\", 0, 0);\n\t\tret = -1;\n\t\tgoto disp_results;\n\t}\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Failed to get number of levels\", 0, 0);\n\t\tgoto disp_results;\n\t}\n\n\tret = isst_get_ctdp_control(id, pkg_dev.current_level, &ctdp_level);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Failed to get current level\", 0, 0);\n\t\tgoto disp_results;\n\t}\n\n\tif (!ctdp_level.fact_support) {\n\t\tisst_display_error_info_message(1, \"turbo-freq feature is not present at this level\", 1, pkg_dev.current_level);\n\t\tret = -1;\n\t\tgoto disp_results;\n\t}\n\n\tif (status) {\n\t\tret = isst_pm_qos_config(id, 1, 1);\n\t\tif (ret)\n\t\t\tgoto disp_results;\n\t}\n\n\tret = isst_set_pbf_fact_status(id, 0, status);\n\tif (ret) {\n\t\tdebug_printf(\"isst_set_pbf_fact_status failed\");\n\t\tif (auto_mode)\n\t\t\tisst_pm_qos_config(id, 0, 0);\n\n\t\tgoto disp_results;\n\t}\n\n\t \n\tif (status) {\n\t\tstruct isst_pkg_ctdp pkg_dev;\n\n\t\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\t\tif (!ret && id->cpu >= 0)\n\t\t\tret = isst_set_trl(id, fact_trl);\n\t\tif (ret && auto_mode)\n\t\t\tisst_pm_qos_config(id, 0, 0);\n\t} else {\n\t\tif (auto_mode)\n\t\t\tisst_pm_qos_config(id, 0, 0);\n\t}\n\ndisp_results:\n\tif (status) {\n\t\tisst_display_result(id, outf, \"turbo-freq\", \"enable\", ret);\n\t\tif (ret)\n\t\t\tfact_enable_fail = ret;\n\t} else {\n\t\t \n\t\tisst_set_trl_from_current_tdp(id, fact_trl);\n\t\tisst_display_result(id, outf, \"turbo-freq\", \"disable\", ret);\n\t}\n}\n\nstatic void set_fact_enable(int arg)\n{\n\tint i, ret, enable = arg;\n\tstruct isst_id id;\n\n\tif (cmd_help) {\n\t\tif (enable) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Enable Intel Speed Select Technology Turbo frequency feature\\n\");\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Optional: -t|--trl : Specify turbo ratio limit\\n\");\n\t\t\tfprintf(stderr,\n\t\t\t\t\"\\tOptional Arguments: -a|--auto : Designate specified target CPUs with\");\n\t\t\tfprintf(stderr,\n\t\t\t\t\"-C|--cpu option as as high priority using core-power feature\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Disable Intel Speed Select Technology turbo frequency feature\\n\");\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Optional: -t|--trl : Specify turbo ratio limit\\n\");\n\t\t\tfprintf(stderr,\n\t\t\t\t\"\\tOptional Arguments: -a|--auto : Also disable core-power associations\\n\");\n\t\t}\n\t\texit(0);\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(set_fact_for_cpu, NULL, NULL,\n\t\t\t\t\t\t  NULL, &enable);\n\telse\n\t\tfor_each_online_power_domain_in_set(set_fact_for_cpu, NULL, NULL,\n\t\t\t\t\t       NULL, &enable);\n\n\tif (!fact_enable_fail && enable && auto_mode) {\n\t\t \n\t\tfor (i = 0; i < get_topo_max_cpus(); ++i) {\n\t\t\tchar buffer[128], sibling_list[128], *cpu_str;\n\t\t\tint fd, len;\n\n\t\t\tif (!CPU_ISSET_S(i, target_cpumask_size, target_cpumask))\n\t\t\t\tcontinue;\n\n\t\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\t \"/sys/devices/system/cpu/cpu%d/topology/thread_siblings_list\", i);\n\n\t\t\tfd = open(buffer, O_RDONLY);\n\t\t\tif (fd < 0)\n\t\t\t\tcontinue;\n\n\t\t\tlen = read(fd, sibling_list, sizeof(sibling_list));\n\t\t\tclose(fd);\n\n\t\t\tif (len < 0)\n\t\t\t\tcontinue;\n\n\t\t\tsibling_list[127] = '\\0';\n\t\t\tcpu_str = strtok(sibling_list, \",\");\n\t\t\twhile (cpu_str != NULL) {\n\t\t\t\tint cpu;\n\n\t\t\t\tsscanf(cpu_str, \"%d\", &cpu);\n\t\t\t\tCPU_SET_S(cpu, target_cpumask_size, target_cpumask);\n\t\t\t\tcpu_str = strtok(NULL, \",\");\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < get_topo_max_cpus(); ++i) {\n\t\t\tint clos;\n\n\t\t\tif (!CPU_ISSET_S(i, present_cpumask_size, present_cpumask))\n\t\t\t\tcontinue;\n\n\t\t\tif (is_cpu_online(i) != 1)\n\t\t\t\tcontinue;\n\n\t\t\tset_isst_id(&id, i);\n\t\t\tret = set_clos_param(&id, 0, 0, 0, 0, 0xff);\n\t\t\tif (ret)\n\t\t\t\tgoto error_disp;\n\n\t\t\tret = set_clos_param(&id, 1, 15, 15, 0, 0xff);\n\t\t\tif (ret)\n\t\t\t\tgoto error_disp;\n\n\t\t\tret = set_clos_param(&id, 2, 15, 15, 0, 0xff);\n\t\t\tif (ret)\n\t\t\t\tgoto error_disp;\n\n\t\t\tret = set_clos_param(&id, 3, 15, 15, 0, 0xff);\n\t\t\tif (ret)\n\t\t\t\tgoto error_disp;\n\n\t\t\tif (CPU_ISSET_S(i, target_cpumask_size, target_cpumask))\n\t\t\t\tclos = 0;\n\t\t\telse\n\t\t\t\tclos = 3;\n\n\t\t\tdebug_printf(\"Associate cpu: %d clos: %d\\n\", i, clos);\n\t\t\tret = isst_clos_associate(&id, clos);\n\t\t\tif (ret)\n\t\t\t\tgoto error_disp;\n\t\t}\n\t\tset_isst_id(&id, -1);\n\t\tisst_display_result(&id, outf, \"turbo-freq --auto\", \"enable\", 0);\n\t}\n\n\tisst_ctdp_display_information_end(outf);\n\n\treturn;\n\nerror_disp:\n\tisst_display_result(&id, outf, \"turbo-freq --auto\", \"enable\", ret);\n\tisst_ctdp_display_information_end(outf);\n\n}\n\nstatic void enable_clos_qos_config(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t\t   void *arg4)\n{\n\tint ret;\n\tint status = *(int *)arg4;\n\n\tif (is_skx_based_platform())\n\t\tclos_priority_type = 1;\n\n\tret = isst_pm_qos_config(id, status, clos_priority_type);\n\tif (ret)\n\t\tisst_display_error_info_message(1, \"isst_pm_qos_config failed\", 0, 0);\n\n\tif (status)\n\t\tisst_display_result(id, outf, \"core-power\", \"enable\",\n\t\t\t\t    ret);\n\telse\n\t\tisst_display_result(id, outf, \"core-power\", \"disable\",\n\t\t\t\t    ret);\n}\n\nstatic void set_clos_enable(int arg)\n{\n\tint enable = arg;\n\n\tif (cmd_help) {\n\t\tif (enable) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Enable core-power for a package/die\\n\");\n\t\t\tif (!is_skx_based_platform()) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"\\tClos Enable: Specify priority type with [--priority|-p]\\n\");\n\t\t\t\tfprintf(stderr, \"\\t\\t 0: Proportional, 1: Ordered\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Disable core-power: [No command arguments are required]\\n\");\n\t\t}\n\t\texit(0);\n\t}\n\n\tif (enable && cpufreq_sysfs_present()) {\n\t\tfprintf(stderr,\n\t\t\t\"cpufreq subsystem and core-power enable will interfere with each other!\\n\");\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(enable_clos_qos_config, NULL,\n\t\t\t\t\t\t  NULL, NULL, &enable);\n\telse\n\t\tfor_each_online_power_domain_in_set(enable_clos_qos_config, NULL,\n\t\t\t\t\t       NULL, NULL, &enable);\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void dump_clos_config_for_cpu(struct isst_id *id, void *arg1, void *arg2,\n\t\t\t\t     void *arg3, void *arg4)\n{\n\tstruct isst_clos_config clos_config;\n\tint ret;\n\n\tret = isst_pm_get_clos(id, current_clos, &clos_config);\n\tif (ret)\n\t\tisst_display_error_info_message(1, \"isst_pm_get_clos failed\", 0, 0);\n\telse\n\t\tisst_clos_display_information(id, outf, current_clos,\n\t\t\t\t\t      &clos_config);\n}\n\nstatic void dump_clos_config(int arg)\n{\n\tif (cmd_help) {\n\t\tfprintf(stderr,\n\t\t\t\"Print Intel Speed Select Technology core power configuration\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tArguments: [-c | --clos]: Specify clos id\\n\");\n\t\texit(0);\n\t}\n\tif (current_clos < 0 || current_clos > 3) {\n\t\tisst_display_error_info_message(1, \"Invalid clos id\\n\", 0, 0);\n\t\tisst_ctdp_display_information_end(outf);\n\t\texit(0);\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(dump_clos_config_for_cpu,\n\t\t\t\t\t\t  NULL, NULL, NULL, NULL);\n\telse\n\t\tfor_each_online_power_domain_in_set(dump_clos_config_for_cpu, NULL,\n\t\t\t\t\t       NULL, NULL, NULL);\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void get_clos_info_for_cpu(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t\t  void *arg4)\n{\n\tint enable, ret, prio_type;\n\n\tret = isst_clos_get_clos_information(id, &enable, &prio_type);\n\tif (ret)\n\t\tisst_display_error_info_message(1, \"isst_clos_get_info failed\", 0, 0);\n\telse {\n\t\tint cp_state, cp_cap;\n\n\t\tisst_read_pm_config(id, &cp_state, &cp_cap);\n\t\tisst_clos_display_clos_information(id, outf, enable, prio_type,\n\t\t\t\t\t\t   cp_state, cp_cap);\n\t}\n}\n\nstatic void dump_clos_info(int arg)\n{\n\tif (cmd_help) {\n\t\tfprintf(stderr,\n\t\t\t\"Print Intel Speed Select Technology core power information\\n\");\n\t\tfprintf(stderr, \"\\t Optionally specify targeted cpu id with [--cpu|-c]\\n\");\n\t\texit(0);\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(get_clos_info_for_cpu, NULL,\n\t\t\t\t\t\t  NULL, NULL, NULL);\n\telse\n\t\tfor_each_online_power_domain_in_set(get_clos_info_for_cpu, NULL,\n\t\t\t\t\t       NULL, NULL, NULL);\n\tisst_ctdp_display_information_end(outf);\n\n}\n\nstatic void set_clos_config_for_cpu(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t\t    void *arg4)\n{\n\tstruct isst_clos_config clos_config;\n\tint ret;\n\n\tif (id->cpu < 0)\n\t\treturn;\n\n\tclos_config.epp = clos_epp;\n\tclos_config.clos_prop_prio = clos_prop_prio;\n\tclos_config.clos_min = clos_min;\n\tclos_config.clos_max = clos_max;\n\tclos_config.clos_desired = clos_desired;\n\tret = isst_set_clos(id, current_clos, &clos_config);\n\tif (ret)\n\t\tisst_display_error_info_message(1, \"isst_set_clos failed\", 0, 0);\n\telse\n\t\tisst_display_result(id, outf, \"core-power\", \"config\", ret);\n}\n\nstatic void set_clos_config(int arg)\n{\n\tif (cmd_help) {\n\t\tfprintf(stderr,\n\t\t\t\"Set core-power configuration for one of the four clos ids\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tSpecify targeted clos id with [--clos|-c]\\n\");\n\t\tif (!is_skx_based_platform()) {\n\t\t\tfprintf(stderr, \"\\tSpecify clos EPP with [--epp|-e]\\n\");\n\t\t\tfprintf(stderr,\n\t\t\t\t\"\\tSpecify clos Proportional Priority [--weight|-w]\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\tSpecify clos min in MHz with [--min|-n]\\n\");\n\t\tfprintf(stderr, \"\\tSpecify clos max in MHz with [--max|-m]\\n\");\n\t\texit(0);\n\t}\n\n\tif (current_clos < 0 || current_clos > 3) {\n\t\tisst_display_error_info_message(1, \"Invalid clos id\\n\", 0, 0);\n\t\texit(0);\n\t}\n\tif (!is_skx_based_platform() && (clos_epp < 0 || clos_epp > 0x0F)) {\n\t\tfprintf(stderr, \"clos epp is not specified or invalid, default: 0\\n\");\n\t\tclos_epp = 0;\n\t}\n\tif (!is_skx_based_platform() && (clos_prop_prio < 0 || clos_prop_prio > 0x0F)) {\n\t\tfprintf(stderr,\n\t\t\t\"clos frequency weight is not specified or invalid, default: 0\\n\");\n\t\tclos_prop_prio = 0;\n\t}\n\tif (clos_min < 0) {\n\t\tfprintf(stderr, \"clos min is not specified, default: 0\\n\");\n\t\tclos_min = 0;\n\t}\n\tif (clos_max < 0) {\n\t\tfprintf(stderr, \"clos max is not specified, default: Max frequency (ratio 0xff)\\n\");\n\t\tclos_max = 0xff;\n\t}\n\tif (clos_desired) {\n\t\tfprintf(stderr, \"clos desired is not supported on this platform\\n\");\n\t\tclos_desired = 0x00;\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(set_clos_config_for_cpu, NULL,\n\t\t\t\t\t\t  NULL, NULL, NULL);\n\telse\n\t\tfor_each_online_power_domain_in_set(set_clos_config_for_cpu, NULL,\n\t\t\t\t\t       NULL, NULL, NULL);\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void set_clos_assoc_for_cpu(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t\t   void *arg4)\n{\n\tint ret;\n\n\tret = isst_clos_associate(id, current_clos);\n\tif (ret)\n\t\tdebug_printf(\"isst_clos_associate failed\");\n\telse\n\t\tisst_display_result(id, outf, \"core-power\", \"assoc\", ret);\n}\n\nstatic void set_clos_assoc(int arg)\n{\n\tif (cmd_help) {\n\t\tfprintf(stderr, \"Associate a clos id to a CPU\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tSpecify targeted clos id with [--clos|-c]\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tFor example to associate clos 1 to CPU 0: issue\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"\\tintel-speed-select --cpu 0 core-power assoc --clos 1\\n\");\n\t\texit(0);\n\t}\n\n\tif (current_clos < 0 || current_clos > 3) {\n\t\tisst_display_error_info_message(1, \"Invalid clos id\\n\", 0, 0);\n\t\texit(0);\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(set_clos_assoc_for_cpu, NULL,\n\t\t\t\t\t\t  NULL, NULL, NULL);\n\telse {\n\t\tisst_display_error_info_message(1, \"Invalid target cpu. Specify with [-c|--cpu]\", 0, 0);\n\t}\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void get_clos_assoc_for_cpu(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\t\t   void *arg4)\n{\n\tint clos, ret;\n\n\tret = isst_clos_get_assoc_status(id, &clos);\n\tif (ret)\n\t\tisst_display_error_info_message(1, \"isst_clos_get_assoc_status failed\", 0, 0);\n\telse\n\t\tisst_clos_display_assoc_information(id, outf, clos);\n}\n\nstatic void get_clos_assoc(int arg)\n{\n\tif (cmd_help) {\n\t\tfprintf(stderr, \"Get associate clos id to a CPU\\n\");\n\t\tfprintf(stderr, \"\\tSpecify targeted cpu id with [--cpu|-c]\\n\");\n\t\texit(0);\n\t}\n\n\tif (!max_target_cpus) {\n\t\tisst_display_error_info_message(1, \"Invalid target cpu. Specify with [-c|--cpu]\", 0, 0);\n\t\texit(0);\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\tfor_each_online_target_cpu_in_set(get_clos_assoc_for_cpu, NULL,\n\t\t\t\t\t  NULL, NULL, NULL);\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void set_turbo_mode_for_cpu(struct isst_id *id, int status)\n{\n\tint base_freq;\n\n\tif (status) {\n\t\tbase_freq = get_cpufreq_base_freq(id->cpu);\n\t\tset_cpufreq_scaling_min_max(id->cpu, 1, base_freq);\n\t} else {\n\t\tset_scaling_max_to_cpuinfo_max(id);\n\t}\n\n\tif (status) {\n\t\tisst_display_result(id, outf, \"turbo-mode\", \"enable\", 0);\n\t} else {\n\t\tisst_display_result(id, outf, \"turbo-mode\", \"disable\", 0);\n\t}\n}\n\nstatic void set_turbo_mode(int arg)\n{\n\tint i, enable = arg;\n\tstruct isst_id id;\n\n\tif (cmd_help) {\n\t\tif (enable)\n\t\t\tfprintf(stderr, \"Set turbo mode enable\\n\");\n\t\telse\n\t\t\tfprintf(stderr, \"Set turbo mode disable\\n\");\n\t\texit(0);\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\n\tfor (i = 0; i < topo_max_cpus; ++i) {\n\t\tint online;\n\n\t\tif (i)\n\t\t\tonline = parse_int_file(\n\t\t\t\t1, \"/sys/devices/system/cpu/cpu%d/online\", i);\n\t\telse\n\t\t\tonline =\n\t\t\t\t1;  \n\n\t\tif (online) {\n\t\t\tset_isst_id(&id, i);\n\t\t\tset_turbo_mode_for_cpu(&id, enable);\n\t\t}\n\n\t}\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic void get_set_trl(struct isst_id *id, void *arg1, void *arg2, void *arg3,\n\t\t\tvoid *arg4)\n{\n\tunsigned long long trl;\n\tint set = *(int *)arg4;\n\tint ret;\n\n\tif (set && !fact_trl) {\n\t\tisst_display_error_info_message(1, \"Invalid TRL. Specify with [-t|--trl]\", 0, 0);\n\t\texit(0);\n\t}\n\n\tif (set) {\n\t\tret = isst_set_trl(id, fact_trl);\n\t\tisst_display_result(id, outf, \"turbo-mode\", \"set-trl\", ret);\n\t\treturn;\n\t}\n\n\tret = isst_get_trl(id, &trl);\n\tif (ret)\n\t\tisst_display_result(id, outf, \"turbo-mode\", \"get-trl\", ret);\n\telse\n\t\tisst_trl_display_information(id, outf, trl);\n}\n\nstatic void process_trl(int arg)\n{\n\tif (cmd_help) {\n\t\tif (arg) {\n\t\t\tfprintf(stderr, \"Set TRL (turbo ratio limits)\\n\");\n\t\t\tfprintf(stderr, \"\\t t|--trl: Specify turbo ratio limit for setting TRL\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"Get TRL (turbo ratio limits)\\n\");\n\t\t}\n\t\texit(0);\n\t}\n\n\tisst_ctdp_display_information_start(outf);\n\tif (max_target_cpus)\n\t\tfor_each_online_target_cpu_in_set(get_set_trl, NULL,\n\t\t\t\t\t\t  NULL, NULL, &arg);\n\telse\n\t\tfor_each_online_power_domain_in_set(get_set_trl, NULL,\n\t\t\t\t\t       NULL, NULL, &arg);\n\tisst_ctdp_display_information_end(outf);\n}\n\nstatic struct process_cmd_struct clx_n_cmds[] = {\n\t{ \"perf-profile\", \"info\", dump_isst_config, 0 },\n\t{ \"base-freq\", \"info\", dump_pbf_config, 0 },\n\t{ \"base-freq\", \"enable\", set_pbf_enable, 1 },\n\t{ \"base-freq\", \"disable\", set_pbf_enable, 0 },\n\t{ NULL, NULL, NULL, 0 }\n};\n\nstatic struct process_cmd_struct isst_cmds[] = {\n\t{ \"perf-profile\", \"get-lock-status\", get_tdp_locked, 0 },\n\t{ \"perf-profile\", \"get-config-levels\", get_tdp_levels, 0 },\n\t{ \"perf-profile\", \"get-config-version\", get_tdp_version, 0 },\n\t{ \"perf-profile\", \"get-config-enabled\", get_tdp_enabled, 0 },\n\t{ \"perf-profile\", \"get-config-current-level\", get_tdp_current_level,\n\t 0 },\n\t{ \"perf-profile\", \"set-config-level\", set_tdp_level, 0 },\n\t{ \"perf-profile\", \"info\", dump_isst_config, 0 },\n\t{ \"base-freq\", \"info\", dump_pbf_config, 0 },\n\t{ \"base-freq\", \"enable\", set_pbf_enable, 1 },\n\t{ \"base-freq\", \"disable\", set_pbf_enable, 0 },\n\t{ \"turbo-freq\", \"info\", dump_fact_config, 0 },\n\t{ \"turbo-freq\", \"enable\", set_fact_enable, 1 },\n\t{ \"turbo-freq\", \"disable\", set_fact_enable, 0 },\n\t{ \"core-power\", \"info\", dump_clos_info, 0 },\n\t{ \"core-power\", \"enable\", set_clos_enable, 1 },\n\t{ \"core-power\", \"disable\", set_clos_enable, 0 },\n\t{ \"core-power\", \"config\", set_clos_config, 0 },\n\t{ \"core-power\", \"get-config\", dump_clos_config, 0 },\n\t{ \"core-power\", \"assoc\", set_clos_assoc, 0 },\n\t{ \"core-power\", \"get-assoc\", get_clos_assoc, 0 },\n\t{ \"turbo-mode\", \"enable\", set_turbo_mode, 0 },\n\t{ \"turbo-mode\", \"disable\", set_turbo_mode, 1 },\n\t{ \"turbo-mode\", \"get-trl\", process_trl, 0 },\n\t{ \"turbo-mode\", \"set-trl\", process_trl, 1 },\n\t{ NULL, NULL, NULL }\n};\n\n \nvoid parse_cpu_command(char *optarg)\n{\n\tunsigned int start, end, invalid_count;\n\tchar *next;\n\n\tnext = optarg;\n\tinvalid_count = 0;\n\n\twhile (next && *next) {\n\t\tif (*next == '-')  \n\t\t\tgoto error;\n\n\t\tstart = strtoul(next, &next, 10);\n\n\t\tif (max_target_cpus < MAX_CPUS_IN_ONE_REQ)\n\t\t\ttarget_cpus[max_target_cpus++] = start;\n\t\telse\n\t\t\tinvalid_count = 1;\n\n\t\tif (*next == '\\0')\n\t\t\tbreak;\n\n\t\tif (*next == ',') {\n\t\t\tnext += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*next == '-') {\n\t\t\tnext += 1;  \n\t\t} else if (*next == '.') {\n\t\t\tnext += 1;\n\t\t\tif (*next == '.')\n\t\t\t\tnext += 1;  \n\t\t\telse\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tend = strtoul(next, &next, 10);\n\t\tif (end <= start)\n\t\t\tgoto error;\n\n\t\twhile (++start <= end) {\n\t\t\tif (max_target_cpus < MAX_CPUS_IN_ONE_REQ)\n\t\t\t\ttarget_cpus[max_target_cpus++] = start;\n\t\t\telse\n\t\t\t\tinvalid_count = 1;\n\t\t}\n\n\t\tif (*next == ',')\n\t\t\tnext += 1;\n\t\telse if (*next != '\\0')\n\t\t\tgoto error;\n\t}\n\n\tif (invalid_count) {\n\t\tisst_ctdp_display_information_start(outf);\n\t\tisst_display_error_info_message(1, \"Too many CPUs in one request: max is\", 1, MAX_CPUS_IN_ONE_REQ - 1);\n\t\tisst_ctdp_display_information_end(outf);\n\t\texit(-1);\n\t}\n\n#ifdef DEBUG\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < max_target_cpus; ++i)\n\t\t\tprintf(\"cpu [%d] in arg\\n\", target_cpus[i]);\n\t}\n#endif\n\treturn;\n\nerror:\n\tfprintf(stderr, \"\\\"--cpu %s\\\" malformed\\n\", optarg);\n\texit(-1);\n}\n\nstatic void parse_cmd_args(int argc, int start, char **argv)\n{\n\tint opt;\n\tint option_index;\n\n\tstatic struct option long_options[] = {\n\t\t{ \"bucket\", required_argument, 0, 'b' },\n\t\t{ \"level\", required_argument, 0, 'l' },\n\t\t{ \"online\", required_argument, 0, 'o' },\n\t\t{ \"trl-type\", required_argument, 0, 'r' },\n\t\t{ \"trl\", required_argument, 0, 't' },\n\t\t{ \"help\", no_argument, 0, 'h' },\n\t\t{ \"clos\", required_argument, 0, 'c' },\n\t\t{ \"desired\", required_argument, 0, 'd' },\n\t\t{ \"epp\", required_argument, 0, 'e' },\n\t\t{ \"min\", required_argument, 0, 'n' },\n\t\t{ \"max\", required_argument, 0, 'm' },\n\t\t{ \"priority\", required_argument, 0, 'p' },\n\t\t{ \"weight\", required_argument, 0, 'w' },\n\t\t{ \"auto\", no_argument, 0, 'a' },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\n\toption_index = start;\n\n\toptind = start + 1;\n\twhile ((opt = getopt_long(argc, argv, \"b:l:t:c:d:e:n:m:p:w:r:hoa\",\n\t\t\t\t  long_options, &option_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\tauto_mode = 1;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tfact_bucket = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tcmd_help = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\ttdp_level = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tforce_online_offline = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tsscanf(optarg, \"0x%llx\", &fact_trl);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (!strncmp(optarg, \"sse\", 3)) {\n\t\t\t\tfact_avx = 0x01;\n\t\t\t} else if (!strncmp(optarg, \"avx2\", 4)) {\n\t\t\t\tfact_avx = 0x02;\n\t\t\t} else if (!strncmp(optarg, \"avx512\", 6)) {\n\t\t\t\tfact_avx = 0x04;\n\t\t\t} else {\n\t\t\t\tfprintf(outf, \"Invalid sse,avx options\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t \n\t\tcase 'c':\n\t\t\tcurrent_clos = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tclos_desired = atoi(optarg);\n\t\t\tclos_desired /= isst_get_disp_freq_multiplier();\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tclos_epp = atoi(optarg);\n\t\t\tif (is_skx_based_platform()) {\n\t\t\t\tisst_display_error_info_message(1, \"epp can't be specified on this platform\", 0, 0);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tclos_min = atoi(optarg);\n\t\t\tclos_min /= isst_get_disp_freq_multiplier();\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tclos_max = atoi(optarg);\n\t\t\tclos_max /= isst_get_disp_freq_multiplier();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tclos_priority_type = atoi(optarg);\n\t\t\tif (is_skx_based_platform() && !clos_priority_type) {\n\t\t\t\tisst_display_error_info_message(1, \"Invalid clos priority type: proportional for this platform\", 0, 0);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tclos_prop_prio = atoi(optarg);\n\t\t\tif (is_skx_based_platform()) {\n\t\t\t\tisst_display_error_info_message(1, \"weight can't be specified on this platform\", 0, 0);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Unknown option: ignore\\n\");\n\t\t}\n\t}\n\n\tif (argv[optind])\n\t\tprintf(\"Garbage at the end of command: ignore\\n\");\n}\n\nstatic void isst_help(void)\n{\n\tprintf(\"perf-profile:\\tAn architectural mechanism that allows multiple optimized \\n\\\n\t\tperformance profiles per system via static and/or dynamic\\n\\\n\t\tadjustment of core count, workload, Tjmax, and\\n\\\n\t\tTDP, etc.\\n\");\n\tprintf(\"\\nCommands : For feature=perf-profile\\n\");\n\tprintf(\"\\tinfo\\n\");\n\n\tif (!is_clx_n_platform()) {\n\t\tprintf(\"\\tget-lock-status\\n\");\n\t\tprintf(\"\\tget-config-levels\\n\");\n\t\tprintf(\"\\tget-config-version\\n\");\n\t\tprintf(\"\\tget-config-enabled\\n\");\n\t\tprintf(\"\\tget-config-current-level\\n\");\n\t\tprintf(\"\\tset-config-level\\n\");\n\t}\n}\n\nstatic void pbf_help(void)\n{\n\tprintf(\"base-freq:\\tEnables users to increase guaranteed base frequency\\n\\\n\t\ton certain cores (high priority cores) in exchange for lower\\n\\\n\t\tbase frequency on remaining cores (low priority cores).\\n\");\n\tprintf(\"\\tcommand : info\\n\");\n\tprintf(\"\\tcommand : enable\\n\");\n\tprintf(\"\\tcommand : disable\\n\");\n}\n\nstatic void fact_help(void)\n{\n\tprintf(\"turbo-freq:\\tEnables the ability to set different turbo ratio\\n\\\n\t\tlimits to cores based on priority.\\n\");\n\tprintf(\"\\nCommand: For feature=turbo-freq\\n\");\n\tprintf(\"\\tcommand : info\\n\");\n\tprintf(\"\\tcommand : enable\\n\");\n\tprintf(\"\\tcommand : disable\\n\");\n}\n\nstatic void turbo_mode_help(void)\n{\n\tprintf(\"turbo-mode:\\tEnables users to enable/disable turbo mode by adjusting frequency settings. Also allows to get and set turbo ratio limits (TRL).\\n\");\n\tprintf(\"\\tcommand : enable\\n\");\n\tprintf(\"\\tcommand : disable\\n\");\n\tprintf(\"\\tcommand : get-trl\\n\");\n\tprintf(\"\\tcommand : set-trl\\n\");\n}\n\n\nstatic void core_power_help(void)\n{\n\tprintf(\"core-power:\\tInterface that allows user to define per core/tile\\n\\\n\t\tpriority.\\n\");\n\tprintf(\"\\nCommands : For feature=core-power\\n\");\n\tprintf(\"\\tinfo\\n\");\n\tprintf(\"\\tenable\\n\");\n\tprintf(\"\\tdisable\\n\");\n\tprintf(\"\\tconfig\\n\");\n\tprintf(\"\\tget-config\\n\");\n\tprintf(\"\\tassoc\\n\");\n\tprintf(\"\\tget-assoc\\n\");\n}\n\nstruct process_cmd_help_struct {\n\tchar *feature;\n\tvoid (*process_fn)(void);\n};\n\nstatic struct process_cmd_help_struct isst_help_cmds[] = {\n\t{ \"perf-profile\", isst_help },\n\t{ \"base-freq\", pbf_help },\n\t{ \"turbo-freq\", fact_help },\n\t{ \"core-power\", core_power_help },\n\t{ \"turbo-mode\", turbo_mode_help },\n\t{ NULL, NULL }\n};\n\nstatic struct process_cmd_help_struct clx_n_help_cmds[] = {\n\t{ \"perf-profile\", isst_help },\n\t{ \"base-freq\", pbf_help },\n\t{ NULL, NULL }\n};\n\nvoid process_command(int argc, char **argv,\n\t\t     struct process_cmd_help_struct *help_cmds,\n\t\t     struct process_cmd_struct *cmds)\n{\n\tint i = 0, matched = 0;\n\tchar *feature = argv[optind];\n\tchar *cmd = argv[optind + 1];\n\n\tif (!feature || !cmd)\n\t\treturn;\n\n\tdebug_printf(\"feature name [%s] command [%s]\\n\", feature, cmd);\n\tif (!strcmp(cmd, \"-h\") || !strcmp(cmd, \"--help\")) {\n\t\twhile (help_cmds[i].feature) {\n\t\t\tif (!strcmp(help_cmds[i].feature, feature)) {\n\t\t\t\thelp_cmds[i].process_fn();\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\t}\n\n\ti = 0;\n\twhile (cmds[i].feature) {\n\t\tif (!strcmp(cmds[i].feature, feature) &&\n\t\t    !strcmp(cmds[i].command, cmd)) {\n\t\t\tparse_cmd_args(argc, optind + 1, argv);\n\t\t\tcmds[i].process_fn(cmds[i].arg);\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t}\n\t\t++i;\n\t}\n\n\tif (!matched)\n\t\tfprintf(stderr, \"Invalid command\\n\");\n}\n\nstatic void usage(void)\n{\n\tif (is_clx_n_platform()) {\n\t\tfprintf(stderr, \"\\nThere is limited support of Intel Speed Select features on this platform.\\n\");\n\t\tfprintf(stderr, \"Everything is pre-configured using BIOS options, this tool can't enable any feature in the hardware.\\n\\n\");\n\t}\n\n\tprintf(\"\\nUsage:\\n\");\n\tprintf(\"intel-speed-select [OPTIONS] FEATURE COMMAND COMMAND_ARGUMENTS\\n\");\n\tprintf(\"\\nUse this tool to enumerate and control the Intel Speed Select Technology features:\\n\");\n\tif (is_clx_n_platform())\n\t\tprintf(\"\\nFEATURE : [perf-profile|base-freq]\\n\");\n\telse\n\t\tprintf(\"\\nFEATURE : [perf-profile|base-freq|turbo-freq|core-power|turbo-mode]\\n\");\n\tprintf(\"\\nFor help on each feature, use -h|--help\\n\");\n\tprintf(\"\\tFor example:  intel-speed-select perf-profile -h\\n\");\n\n\tprintf(\"\\nFor additional help on each command for a feature, use --h|--help\\n\");\n\tprintf(\"\\tFor example:  intel-speed-select perf-profile get-lock-status -h\\n\");\n\tprintf(\"\\t\\t This will print help for the command \\\"get-lock-status\\\" for the feature \\\"perf-profile\\\"\\n\");\n\n\tprintf(\"\\nOPTIONS\\n\");\n\tprintf(\"\\t[-c|--cpu] : logical cpu number\\n\");\n\tprintf(\"\\t\\tDefault: Die scoped for all dies in the system with multiple dies/package\\n\");\n\tprintf(\"\\t\\t\\t Or Package scoped for all Packages when each package contains one die\\n\");\n\tprintf(\"\\t[-d|--debug] : Debug mode\\n\");\n\tprintf(\"\\t[-f|--format] : output format [json|text]. Default: text\\n\");\n\tprintf(\"\\t[-h|--help] : Print help\\n\");\n\tprintf(\"\\t[-i|--info] : Print platform information\\n\");\n\tprintf(\"\\t[-a|--all-cpus-online] : Force online every CPU in the system\\n\");\n\tprintf(\"\\t[-o|--out] : Output file\\n\");\n\tprintf(\"\\t\\t\\tDefault : stderr\\n\");\n\tprintf(\"\\t[-p|--pause] : Delay between two mail box commands in milliseconds\\n\");\n\tprintf(\"\\t[-r|--retry] : Retry count for mail box commands on failure, default 3\\n\");\n\tprintf(\"\\t[-v|--version] : Print version\\n\");\n\tprintf(\"\\t[-b|--oob : Start a daemon to process HFI events for perf profile change from Out of Band agent.\\n\");\n\tprintf(\"\\t[-n|--no-daemon : Don't run as daemon. By default --oob will turn on daemon mode\\n\");\n\tprintf(\"\\t[-w|--delay : Delay for reading config level state change in OOB poll mode.\\n\");\n\tprintf(\"\\t[-g|--cgroupv2 : Try to use cgroup v2 CPU isolation instead of CPU online/offline.\\n\");\n\tprintf(\"\\nResult format\\n\");\n\tprintf(\"\\tResult display uses a common format for each command:\\n\");\n\tprintf(\"\\tResults are formatted in text/JSON with\\n\");\n\tprintf(\"\\t\\tPackage, Die, CPU, and command specific results.\\n\");\n\n\tprintf(\"\\nExamples\\n\");\n\tprintf(\"\\tTo get platform information:\\n\");\n\tprintf(\"\\t\\tintel-speed-select --info\\n\");\n\tprintf(\"\\tTo get full perf-profile information dump:\\n\");\n\tprintf(\"\\t\\tintel-speed-select perf-profile info\\n\");\n\tprintf(\"\\tTo get full base-freq information dump:\\n\");\n\tprintf(\"\\t\\tintel-speed-select base-freq info -l 0\\n\");\n\tif (!is_clx_n_platform()) {\n\t\tprintf(\"\\tTo get full turbo-freq information dump:\\n\");\n\t\tprintf(\"\\t\\tintel-speed-select turbo-freq info -l 0\\n\");\n\t}\n\texit(1);\n}\n\nstatic void print_version(void)\n{\n\tfprintf(outf, \"Version %s\\n\", version_str);\n\texit(0);\n}\n\nstatic void cmdline(int argc, char **argv)\n{\n\tconst char *pathname = \"/dev/isst_interface\";\n\tchar *ptr;\n\tFILE *fp;\n\tint opt, force_cpus_online = 0;\n\tint option_index = 0;\n\tint ret;\n\tint oob_mode = 0;\n\tint poll_interval = -1;\n\tint no_daemon = 0;\n\tint mbox_delay = 0, mbox_retries = 3;\n\n\tstatic struct option long_options[] = {\n\t\t{ \"all-cpus-online\", no_argument, 0, 'a' },\n\t\t{ \"cpu\", required_argument, 0, 'c' },\n\t\t{ \"debug\", no_argument, 0, 'd' },\n\t\t{ \"format\", required_argument, 0, 'f' },\n\t\t{ \"help\", no_argument, 0, 'h' },\n\t\t{ \"info\", no_argument, 0, 'i' },\n\t\t{ \"pause\", required_argument, 0, 'p' },\n\t\t{ \"out\", required_argument, 0, 'o' },\n\t\t{ \"retry\", required_argument, 0, 'r' },\n\t\t{ \"version\", no_argument, 0, 'v' },\n\t\t{ \"oob\", no_argument, 0, 'b' },\n\t\t{ \"no-daemon\", no_argument, 0, 'n' },\n\t\t{ \"poll-interval\", required_argument, 0, 'w' },\n\t\t{ \"cgroupv2\", required_argument, 0, 'g' },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\n\tif (geteuid() != 0) {\n\t\tfprintf(stderr, \"Must run as root\\n\");\n\t\texit(0);\n\t}\n\n\tret = update_cpu_model();\n\tif (ret)\n\t\terr(-1, \"Invalid CPU model (%d)\\n\", cpu_model);\n\tprintf(\"Intel(R) Speed Select Technology\\n\");\n\tprintf(\"Executing on CPU model:%d[0x%x]\\n\", cpu_model, cpu_model);\n\n\tif (!is_clx_n_platform()) {\n\t\tfp = fopen(pathname, \"rb\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Intel speed select drivers are not loaded on this system.\\n\");\n\t\t\tfprintf(stderr, \"Verify that kernel config includes CONFIG_INTEL_SPEED_SELECT_INTERFACE.\\n\");\n\t\t\tfprintf(stderr, \"If the config is included then this is not a supported platform.\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tfclose(fp);\n\t}\n\n\tret = isst_fill_platform_info();\n\tif (ret)\n\t\tgoto out;\n\n\tprogname = argv[0];\n\twhile ((opt = getopt_long_only(argc, argv, \"+c:df:hio:vabw:ng\", long_options,\n\t\t\t\t       &option_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\tforce_cpus_online = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tparse_cpu_command(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdebug_flag = 1;\n\t\t\tprintf(\"Debug Mode ON\\n\");\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (!strncmp(optarg, \"json\", 4))\n\t\t\t\tout_format_json = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tisst_print_platform_information();\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (outf)\n\t\t\t\tfclose(outf);\n\t\t\toutf = fopen_or_exit(optarg, \"w\");\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tret = strtol(optarg, &ptr, 10);\n\t\t\tif (!ret)\n\t\t\t\tfprintf(stderr, \"Invalid pause interval, ignore\\n\");\n\t\t\telse\n\t\t\t\tmbox_delay = ret;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tret = strtol(optarg, &ptr, 10);\n\t\t\tif (!ret)\n\t\t\t\tfprintf(stderr, \"Invalid retry count, ignore\\n\");\n\t\t\telse\n\t\t\t\tmbox_retries = ret;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\toob_mode = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tno_daemon = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tret = strtol(optarg, &ptr, 10);\n\t\t\tif (!ret) {\n\t\t\t\tfprintf(stderr, \"Invalid poll interval count\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tpoll_interval = ret;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tcgroupv2 = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (optind > (argc - 2) && !oob_mode) {\n\t\tusage();\n\t\texit(0);\n\t}\n\n\tisst_update_platform_param(ISST_PARAM_MBOX_DELAY, mbox_delay);\n\tisst_update_platform_param(ISST_PARAM_MBOX_RETRIES, mbox_retries);\n\n\tset_max_cpu_num();\n\tif (force_cpus_online)\n\t\tforce_all_cpus_online();\n\tstore_cpu_topology();\n\tcreate_cpu_map();\n\n\tif (oob_mode) {\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"OOB mode is enabled in debug mode\\n\");\n\n\t\tret = isst_daemon(debug_flag, poll_interval, no_daemon);\n\t\tif (ret)\n\t\t\tfprintf(stderr, \"OOB mode enable failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!is_clx_n_platform()) {\n\t\tprocess_command(argc, argv, isst_help_cmds, isst_cmds);\n\t} else {\n\t\tprocess_command(argc, argv, clx_n_help_cmds, clx_n_cmds);\n\t}\nout:\n\tfree_cpu_set(present_cpumask);\n\tfree_cpu_set(target_cpumask);\n}\n\nint main(int argc, char **argv)\n{\n\toutf = stderr;\n\tcmdline(argc, argv);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}