{
  "module_name": "isst-core.c",
  "hash_id": "a851ddfaab0400a6f76e61267b239fa488134eebe54e4d2d8049f53810658f59",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/intel-speed-select/isst-core.c",
  "human_readable_source": "\n \n\n#include \"isst.h\"\n\nstatic struct isst_platform_ops\t\t*isst_ops;\n\n#define CHECK_CB(_name)\t\\\n\tdo {\t\\\n\t\tif (!isst_ops || !isst_ops->_name) {\t\\\n\t\t\tfprintf(stderr, \"Invalid ops\\n\");\t\\\n\t\t\texit(0);\t\\\n\t\t}\t\\\n\t} while (0)\n\nint isst_set_platform_ops(int api_version)\n{\n\tswitch (api_version) {\n\tcase 1:\n\t\tisst_ops = mbox_get_platform_ops();\n\t\tbreak;\n\tcase 2:\n\t\tisst_ops = tpmi_get_platform_ops();\n\t\tbreak;\n\tdefault:\n\t\tisst_ops = NULL;\n\t\tbreak;\n\t}\n\n\tif (!isst_ops)\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid isst_update_platform_param(enum isst_platform_param param, int value)\n{\n\tCHECK_CB(update_platform_param);\n\n\tisst_ops->update_platform_param(param, value);\n}\n\nint isst_get_disp_freq_multiplier(void)\n{\n\tCHECK_CB(get_disp_freq_multiplier);\n\treturn isst_ops->get_disp_freq_multiplier();\n}\n\nint isst_get_trl_max_levels(void)\n{\n\tCHECK_CB(get_trl_max_levels);\n\treturn isst_ops->get_trl_max_levels();\n}\n\nchar *isst_get_trl_level_name(int level)\n{\n\tCHECK_CB(get_trl_level_name);\n\treturn isst_ops->get_trl_level_name(level);\n}\n\nint isst_is_punit_valid(struct isst_id *id)\n{\n\tCHECK_CB(is_punit_valid);\n\treturn isst_ops->is_punit_valid(id);\n}\n\nint isst_send_msr_command(unsigned int cpu, unsigned int msr, int write,\n\t\t\t  unsigned long long *req_resp)\n{\n\tstruct isst_if_msr_cmds msr_cmds;\n\tconst char *pathname = \"/dev/isst_interface\";\n\tFILE *outf = get_output_file();\n\tint fd;\n\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\terr(-1, \"%s open failed\", pathname);\n\n\tmsr_cmds.cmd_count = 1;\n\tmsr_cmds.msr_cmd[0].logical_cpu = cpu;\n\tmsr_cmds.msr_cmd[0].msr = msr;\n\tmsr_cmds.msr_cmd[0].read_write = write;\n\tif (write)\n\t\tmsr_cmds.msr_cmd[0].data = *req_resp;\n\n\tif (ioctl(fd, ISST_IF_MSR_COMMAND, &msr_cmds) == -1) {\n\t\tperror(\"ISST_IF_MSR_COMMAND\");\n\t\tfprintf(outf, \"Error: msr_cmd cpu:%d msr:%x read_write:%d\\n\",\n\t\t\tcpu, msr, write);\n\t} else {\n\t\tif (!write)\n\t\t\t*req_resp = msr_cmds.msr_cmd[0].data;\n\n\t\tdebug_printf(\n\t\t\t\"msr_cmd response: cpu:%d msr:%x rd_write:%x resp:%llx %llx\\n\",\n\t\t\tcpu, msr, write, *req_resp, msr_cmds.msr_cmd[0].data);\n\t}\n\n\tclose(fd);\n\n\treturn 0;\n}\n\nint isst_read_pm_config(struct isst_id *id, int *cp_state, int *cp_cap)\n{\n\tCHECK_CB(read_pm_config);\n\treturn isst_ops->read_pm_config(id, cp_state, cp_cap);\n}\n\nint isst_get_ctdp_levels(struct isst_id *id, struct isst_pkg_ctdp *pkg_dev)\n{\n\tCHECK_CB(get_config_levels);\n\treturn isst_ops->get_config_levels(id, pkg_dev);\n}\n\nint isst_get_ctdp_control(struct isst_id *id, int config_index,\n\t\t\t  struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tCHECK_CB(get_ctdp_control);\n\treturn isst_ops->get_ctdp_control(id, config_index, ctdp_level);\n}\n\nint isst_get_tdp_info(struct isst_id *id, int config_index,\n\t\t      struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tCHECK_CB(get_tdp_info);\n\treturn isst_ops->get_tdp_info(id, config_index, ctdp_level);\n}\n\nint isst_get_pwr_info(struct isst_id *id, int config_index,\n\t\t      struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tCHECK_CB(get_pwr_info);\n\treturn isst_ops->get_pwr_info(id, config_index, ctdp_level);\n}\n\nint isst_get_coremask_info(struct isst_id *id, int config_index,\n\t\t\t   struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tCHECK_CB(get_coremask_info);\n\treturn isst_ops->get_coremask_info(id, config_index, ctdp_level);\n}\n\nint isst_get_get_trl_from_msr(struct isst_id *id, int *trl)\n{\n\tunsigned long long msr_trl;\n\tint ret;\n\n\tret = isst_send_msr_command(id->cpu, 0x1AD, 0, &msr_trl);\n\tif (ret)\n\t\treturn ret;\n\n\ttrl[0] = msr_trl & GENMASK(7, 0);\n\ttrl[1] = (msr_trl & GENMASK(15, 8)) >> 8;\n\ttrl[2] = (msr_trl & GENMASK(23, 16)) >> 16;\n\ttrl[3] = (msr_trl & GENMASK(31, 24)) >> 24;\n\ttrl[4] = (msr_trl & GENMASK(39, 32)) >> 32;\n\ttrl[5] = (msr_trl & GENMASK(47, 40)) >> 40;\n\ttrl[6] = (msr_trl & GENMASK(55, 48)) >> 48;\n\ttrl[7] = (msr_trl & GENMASK(63, 56)) >> 56;\n\n\treturn 0;\n}\n\nint isst_get_get_trl(struct isst_id *id, int level, int avx_level, int *trl)\n{\n\tCHECK_CB(get_get_trl);\n\treturn isst_ops->get_get_trl(id, level, avx_level, trl);\n}\n\nint isst_get_get_trls(struct isst_id *id, int level, struct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tCHECK_CB(get_get_trls);\n\treturn isst_ops->get_get_trls(id, level, ctdp_level);\n}\n\nint isst_get_trl_bucket_info(struct isst_id *id, int level, unsigned long long *buckets_info)\n{\n\tCHECK_CB(get_trl_bucket_info);\n\treturn isst_ops->get_trl_bucket_info(id, level, buckets_info);\n}\n\nint isst_set_tdp_level(struct isst_id *id, int tdp_level)\n{\n\tCHECK_CB(set_tdp_level);\n\treturn isst_ops->set_tdp_level(id, tdp_level);\n}\n\nint isst_get_pbf_info(struct isst_id *id, int level, struct isst_pbf_info *pbf_info)\n{\n\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\tstruct isst_pkg_ctdp pkg_dev;\n\tint ret;\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Failed to get number of levels\", 0, 0);\n\t\treturn ret;\n\t}\n\n\tif (level > pkg_dev.levels) {\n\t\tisst_display_error_info_message(1, \"Invalid level\", 1, level);\n\t\treturn -1;\n\t}\n\n\tret = isst_get_ctdp_control(id, level, &ctdp_level);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ctdp_level.pbf_support) {\n\t\tisst_display_error_info_message(1, \"base-freq feature is not present at this level\", 1, level);\n\t\treturn -1;\n\t}\n\n\tpbf_info->core_cpumask_size = alloc_cpu_set(&pbf_info->core_cpumask);\n\n\tCHECK_CB(get_pbf_info);\n\treturn isst_ops->get_pbf_info(id, level, pbf_info);\n}\n\nint isst_set_pbf_fact_status(struct isst_id *id, int pbf, int enable)\n{\n\tCHECK_CB(set_pbf_fact_status);\n\treturn isst_ops->set_pbf_fact_status(id, pbf, enable);\n}\n\n\n\nint isst_get_fact_info(struct isst_id *id, int level, int fact_bucket, struct isst_fact_info *fact_info)\n{\n\tstruct isst_pkg_ctdp_level_info ctdp_level;\n\tstruct isst_pkg_ctdp pkg_dev;\n\tint ret;\n\n\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\tif (ret) {\n\t\tisst_display_error_info_message(1, \"Failed to get number of levels\", 0, 0);\n\t\treturn ret;\n\t}\n\n\tif (level > pkg_dev.levels) {\n\t\tisst_display_error_info_message(1, \"Invalid level\", 1, level);\n\t\treturn -1;\n\t}\n\n\tret = isst_get_ctdp_control(id, level, &ctdp_level);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ctdp_level.fact_support) {\n\t\tisst_display_error_info_message(1, \"turbo-freq feature is not present at this level\", 1, level);\n\t\treturn -1;\n\t}\n\tCHECK_CB(get_fact_info);\n\treturn isst_ops->get_fact_info(id, level, fact_bucket, fact_info);\n}\n\nint isst_get_trl(struct isst_id *id, unsigned long long *trl)\n{\n\tint ret;\n\n\tret = isst_send_msr_command(id->cpu, 0x1AD, 0, trl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint isst_set_trl(struct isst_id *id, unsigned long long trl)\n{\n\tint ret;\n\n\tif (!trl)\n\t\ttrl = 0xFFFFFFFFFFFFFFFFULL;\n\n\tret = isst_send_msr_command(id->cpu, 0x1AD, 1, &trl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint isst_set_trl_from_current_tdp(struct isst_id *id, unsigned long long trl)\n{\n\tunsigned long long msr_trl;\n\tint ret;\n\n\tif (id->cpu < 0)\n\t\treturn 0;\n\n\tif (trl) {\n\t\tmsr_trl = trl;\n\t} else {\n\t\tstruct isst_pkg_ctdp pkg_dev;\n\t\tint trl[8];\n\t\tint i;\n\n\t\tret = isst_get_ctdp_levels(id, &pkg_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = isst_get_get_trl(id, pkg_dev.current_level, 0, trl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmsr_trl = 0;\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\tunsigned long long _trl = trl[i];\n\n\t\t\tmsr_trl |= (_trl << (i * 8));\n\t\t}\n\t}\n\tret = isst_send_msr_command(id->cpu, 0x1AD, 1, &msr_trl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint isst_get_config_tdp_lock_status(struct isst_id *id)\n{\n\tunsigned long long tdp_control = 0;\n\tint ret;\n\n\tret = isst_send_msr_command(id->cpu, 0x64b, 0, &tdp_control);\n\tif (ret)\n\t\treturn ret;\n\n\tret = !!(tdp_control & BIT(31));\n\n\treturn ret;\n}\n\nvoid isst_get_process_ctdp_complete(struct isst_id *id, struct isst_pkg_ctdp *pkg_dev)\n{\n\tint i;\n\n\tif (!pkg_dev->processed)\n\t\treturn;\n\n\tfor (i = 0; i < pkg_dev->levels; ++i) {\n\t\tstruct isst_pkg_ctdp_level_info *ctdp_level;\n\n\t\tctdp_level = &pkg_dev->ctdp_level[i];\n\t\tif (ctdp_level->pbf_support)\n\t\t\tfree_cpu_set(ctdp_level->pbf_info.core_cpumask);\n\t\tfree_cpu_set(ctdp_level->core_cpumask);\n\t}\n}\n\nvoid isst_adjust_uncore_freq(struct isst_id *id, int config_index,\n\t\t\t\tstruct isst_pkg_ctdp_level_info *ctdp_level)\n{\n\tCHECK_CB(adjust_uncore_freq);\n\treturn isst_ops->adjust_uncore_freq(id, config_index, ctdp_level);\n}\n\nint isst_get_process_ctdp(struct isst_id *id, int tdp_level, struct isst_pkg_ctdp *pkg_dev)\n{\n\tint i, ret, valid = 0;\n\n\tif (pkg_dev->processed)\n\t\treturn 0;\n\n\tret = isst_get_ctdp_levels(id, pkg_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdebug_printf(\"cpu: %d ctdp enable:%d current level: %d levels:%d\\n\",\n\t\t     id->cpu, pkg_dev->enabled, pkg_dev->current_level,\n\t\t     pkg_dev->levels);\n\n\tif (tdp_level != 0xff && tdp_level > pkg_dev->levels) {\n\t\tisst_display_error_info_message(1, \"Invalid level\", 0, 0);\n\t\treturn -1;\n\t}\n\n\tif (!pkg_dev->enabled)\n\t\tisst_display_error_info_message(0, \"perf-profile feature is not supported, just base-config level 0 is valid\", 0, 0);\n\n\tfor (i = 0; i <= pkg_dev->levels; ++i) {\n\t\tstruct isst_pkg_ctdp_level_info *ctdp_level;\n\n\t\tif (tdp_level != 0xff && i != tdp_level)\n\t\t\tcontinue;\n\n\t\tdebug_printf(\"cpu:%d Get Information for TDP level:%d\\n\", id->cpu,\n\t\t\t     i);\n\t\tctdp_level = &pkg_dev->ctdp_level[i];\n\n\t\tctdp_level->level = i;\n\t\tctdp_level->control_cpu = id->cpu;\n\t\tctdp_level->pkg_id = id->pkg;\n\t\tctdp_level->die_id = id->die;\n\n\t\tret = isst_get_ctdp_control(id, i, ctdp_level);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tvalid = 1;\n\t\tpkg_dev->processed = 1;\n\t\tctdp_level->processed = 1;\n\n\t\tif (ctdp_level->pbf_support) {\n\t\t\tret = isst_get_pbf_info(id, i, &ctdp_level->pbf_info);\n\t\t\tif (!ret)\n\t\t\t\tctdp_level->pbf_found = 1;\n\t\t}\n\n\t\tif (ctdp_level->fact_support) {\n\t\t\tret = isst_get_fact_info(id, i, 0xff,\n\t\t\t\t\t\t &ctdp_level->fact_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (!pkg_dev->enabled && is_skx_based_platform()) {\n\t\t\tint freq;\n\n\t\t\tfreq = get_cpufreq_base_freq(id->cpu);\n\t\t\tif (freq > 0) {\n\t\t\t\tctdp_level->sse_p1 = freq / 100000;\n\t\t\t\tctdp_level->tdp_ratio = ctdp_level->sse_p1;\n\t\t\t}\n\n\t\t\tisst_get_get_trl_from_msr(id, ctdp_level->trl_ratios[0]);\n\t\t\tisst_get_trl_bucket_info(id, i, &ctdp_level->trl_cores);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = isst_get_tdp_info(id, i, ctdp_level);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = isst_get_pwr_info(id, i, ctdp_level);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tctdp_level->core_cpumask_size =\n\t\t\talloc_cpu_set(&ctdp_level->core_cpumask);\n\t\tret = isst_get_coremask_info(id, i, ctdp_level);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = isst_get_trl_bucket_info(id, i, &ctdp_level->trl_cores);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = isst_get_get_trls(id, i, ctdp_level);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!valid)\n\t\tisst_display_error_info_message(0, \"Invalid level, Can't get TDP control information at specified levels on cpu\", 1, id->cpu);\n\n\treturn 0;\n}\n\nint isst_clos_get_clos_information(struct isst_id *id, int *enable, int *type)\n{\n\tCHECK_CB(get_clos_information);\n\treturn isst_ops->get_clos_information(id, enable, type);\n}\n\nint isst_pm_qos_config(struct isst_id *id, int enable_clos, int priority_type)\n{\n\tCHECK_CB(pm_qos_config);\n\treturn isst_ops->pm_qos_config(id, enable_clos, priority_type);\n}\n\nint isst_pm_get_clos(struct isst_id *id, int clos, struct isst_clos_config *clos_config)\n{\n\tCHECK_CB(pm_get_clos);\n\treturn isst_ops->pm_get_clos(id, clos, clos_config);\n}\n\nint isst_set_clos(struct isst_id *id, int clos, struct isst_clos_config *clos_config)\n{\n\tCHECK_CB(set_clos);\n\treturn isst_ops->set_clos(id, clos, clos_config);\n}\n\nint isst_clos_get_assoc_status(struct isst_id *id, int *clos_id)\n{\n\tCHECK_CB(clos_get_assoc_status);\n\treturn isst_ops->clos_get_assoc_status(id, clos_id);\n}\n\nint isst_clos_associate(struct isst_id *id, int clos_id)\n{\n\tCHECK_CB(clos_associate);\n\treturn isst_ops->clos_associate(id, clos_id);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}