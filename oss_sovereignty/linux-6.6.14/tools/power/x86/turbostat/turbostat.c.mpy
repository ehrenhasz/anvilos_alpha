{
  "module_name": "turbostat.c",
  "hash_id": "afb409f01bd44e38571257c3370e18a51ab0f6da5ec219e11c0689324566b906",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/turbostat/turbostat.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include MSRHEADER\n#include INTEL_FAMILY_HEADER\n#include <stdarg.h>\n#include <stdio.h>\n#include <err.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/select.h>\n#include <sys/resource.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/time.h>\n#include <stdlib.h>\n#include <getopt.h>\n#include <dirent.h>\n#include <string.h>\n#include <ctype.h>\n#include <sched.h>\n#include <time.h>\n#include <cpuid.h>\n#include <sys/capability.h>\n#include <errno.h>\n#include <math.h>\n#include <linux/perf_event.h>\n#include <asm/unistd.h>\n#include <stdbool.h>\n\n#define UNUSED(x) (void)(x)\n\n \n\n \n#define\tNAME_BYTES 20\n#define PATH_BYTES 128\n\nenum counter_scope { SCOPE_CPU, SCOPE_CORE, SCOPE_PACKAGE };\nenum counter_type { COUNTER_ITEMS, COUNTER_CYCLES, COUNTER_SECONDS, COUNTER_USEC };\nenum counter_format { FORMAT_RAW, FORMAT_DELTA, FORMAT_PERCENT };\n\nstruct msr_counter {\n\tunsigned int msr_num;\n\tchar name[NAME_BYTES];\n\tchar path[PATH_BYTES];\n\tunsigned int width;\n\tenum counter_type type;\n\tenum counter_format format;\n\tstruct msr_counter *next;\n\tunsigned int flags;\n#define\tFLAGS_HIDE\t(1 << 0)\n#define\tFLAGS_SHOW\t(1 << 1)\n#define\tSYSFS_PERCPU\t(1 << 1)\n};\n\nstruct msr_counter bic[] = {\n\t{ 0x0, \"usec\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Time_Of_Day_Seconds\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Package\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Node\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Avg_MHz\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Busy%\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Bzy_MHz\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"TSC_MHz\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"IRQ\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"SMI\", \"\", 32, 0, FORMAT_DELTA, NULL, 0 },\n\t{ 0x0, \"sysfs\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CPU%c1\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CPU%c3\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CPU%c6\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CPU%c7\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"ThreadC\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CoreTmp\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CoreCnt\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"PkgTmp\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"GFX%rc6\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"GFXMHz\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Pkg%pc2\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Pkg%pc3\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Pkg%pc6\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Pkg%pc7\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Pkg%pc8\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Pkg%pc9\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Pk%pc10\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CPU%LPI\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"SYS%LPI\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"PkgWatt\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CorWatt\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"GFXWatt\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"PkgCnt\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"RAMWatt\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"PKG_%\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"RAM_%\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Pkg_J\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Cor_J\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"GFX_J\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"RAM_J\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Mod%c6\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Totl%C0\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Any%C0\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"GFX%C0\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CPUGFX%\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Core\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CPU\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"APIC\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"X2APIC\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"Die\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"GFXAMHz\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"IPC\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"CoreThr\", \"\", 0, 0, 0, NULL, 0 },\n\t{ 0x0, \"UncMHz\", \"\", 0, 0, 0, NULL, 0 },\n};\n\n#define MAX_BIC (sizeof(bic) / sizeof(struct msr_counter))\n#define\tBIC_USEC\t(1ULL << 0)\n#define\tBIC_TOD\t\t(1ULL << 1)\n#define\tBIC_Package\t(1ULL << 2)\n#define\tBIC_Node\t(1ULL << 3)\n#define\tBIC_Avg_MHz\t(1ULL << 4)\n#define\tBIC_Busy\t(1ULL << 5)\n#define\tBIC_Bzy_MHz\t(1ULL << 6)\n#define\tBIC_TSC_MHz\t(1ULL << 7)\n#define\tBIC_IRQ\t\t(1ULL << 8)\n#define\tBIC_SMI\t\t(1ULL << 9)\n#define\tBIC_sysfs\t(1ULL << 10)\n#define\tBIC_CPU_c1\t(1ULL << 11)\n#define\tBIC_CPU_c3\t(1ULL << 12)\n#define\tBIC_CPU_c6\t(1ULL << 13)\n#define\tBIC_CPU_c7\t(1ULL << 14)\n#define\tBIC_ThreadC\t(1ULL << 15)\n#define\tBIC_CoreTmp\t(1ULL << 16)\n#define\tBIC_CoreCnt\t(1ULL << 17)\n#define\tBIC_PkgTmp\t(1ULL << 18)\n#define\tBIC_GFX_rc6\t(1ULL << 19)\n#define\tBIC_GFXMHz\t(1ULL << 20)\n#define\tBIC_Pkgpc2\t(1ULL << 21)\n#define\tBIC_Pkgpc3\t(1ULL << 22)\n#define\tBIC_Pkgpc6\t(1ULL << 23)\n#define\tBIC_Pkgpc7\t(1ULL << 24)\n#define\tBIC_Pkgpc8\t(1ULL << 25)\n#define\tBIC_Pkgpc9\t(1ULL << 26)\n#define\tBIC_Pkgpc10\t(1ULL << 27)\n#define BIC_CPU_LPI\t(1ULL << 28)\n#define BIC_SYS_LPI\t(1ULL << 29)\n#define\tBIC_PkgWatt\t(1ULL << 30)\n#define\tBIC_CorWatt\t(1ULL << 31)\n#define\tBIC_GFXWatt\t(1ULL << 32)\n#define\tBIC_PkgCnt\t(1ULL << 33)\n#define\tBIC_RAMWatt\t(1ULL << 34)\n#define\tBIC_PKG__\t(1ULL << 35)\n#define\tBIC_RAM__\t(1ULL << 36)\n#define\tBIC_Pkg_J\t(1ULL << 37)\n#define\tBIC_Cor_J\t(1ULL << 38)\n#define\tBIC_GFX_J\t(1ULL << 39)\n#define\tBIC_RAM_J\t(1ULL << 40)\n#define\tBIC_Mod_c6\t(1ULL << 41)\n#define\tBIC_Totl_c0\t(1ULL << 42)\n#define\tBIC_Any_c0\t(1ULL << 43)\n#define\tBIC_GFX_c0\t(1ULL << 44)\n#define\tBIC_CPUGFX\t(1ULL << 45)\n#define\tBIC_Core\t(1ULL << 46)\n#define\tBIC_CPU\t\t(1ULL << 47)\n#define\tBIC_APIC\t(1ULL << 48)\n#define\tBIC_X2APIC\t(1ULL << 49)\n#define\tBIC_Die\t\t(1ULL << 50)\n#define\tBIC_GFXACTMHz\t(1ULL << 51)\n#define\tBIC_IPC\t\t(1ULL << 52)\n#define\tBIC_CORE_THROT_CNT\t(1ULL << 53)\n#define\tBIC_UNCORE_MHZ\t\t(1ULL << 54)\n\n#define BIC_TOPOLOGY (BIC_Package | BIC_Node | BIC_CoreCnt | BIC_PkgCnt | BIC_Core | BIC_CPU | BIC_Die )\n#define BIC_THERMAL_PWR ( BIC_CoreTmp | BIC_PkgTmp | BIC_PkgWatt | BIC_CorWatt | BIC_GFXWatt | BIC_RAMWatt | BIC_PKG__ | BIC_RAM__)\n#define BIC_FREQUENCY ( BIC_Avg_MHz | BIC_Busy | BIC_Bzy_MHz | BIC_TSC_MHz | BIC_GFXMHz | BIC_GFXACTMHz | BIC_UNCORE_MHZ)\n#define BIC_IDLE ( BIC_sysfs | BIC_CPU_c1 | BIC_CPU_c3 | BIC_CPU_c6 | BIC_CPU_c7 | BIC_GFX_rc6 | BIC_Pkgpc2 | BIC_Pkgpc3 | BIC_Pkgpc6 | BIC_Pkgpc7 | BIC_Pkgpc8 | BIC_Pkgpc9 | BIC_Pkgpc10 | BIC_CPU_LPI | BIC_SYS_LPI | BIC_Mod_c6 | BIC_Totl_c0 | BIC_Any_c0 | BIC_GFX_c0 | BIC_CPUGFX)\n#define BIC_OTHER ( BIC_IRQ | BIC_SMI | BIC_ThreadC | BIC_CoreTmp | BIC_IPC)\n\n#define BIC_DISABLED_BY_DEFAULT\t(BIC_USEC | BIC_TOD | BIC_APIC | BIC_X2APIC)\n\nunsigned long long bic_enabled = (0xFFFFFFFFFFFFFFFFULL & ~BIC_DISABLED_BY_DEFAULT);\nunsigned long long bic_present = BIC_USEC | BIC_TOD | BIC_sysfs | BIC_APIC | BIC_X2APIC;\n\n#define DO_BIC(COUNTER_NAME) (bic_enabled & bic_present & COUNTER_NAME)\n#define DO_BIC_READ(COUNTER_NAME) (bic_present & COUNTER_NAME)\n#define ENABLE_BIC(COUNTER_NAME) (bic_enabled |= COUNTER_NAME)\n#define BIC_PRESENT(COUNTER_BIT) (bic_present |= COUNTER_BIT)\n#define BIC_NOT_PRESENT(COUNTER_BIT) (bic_present &= ~COUNTER_BIT)\n#define BIC_IS_ENABLED(COUNTER_BIT) (bic_enabled & COUNTER_BIT)\n\nchar *proc_stat = \"/proc/stat\";\nFILE *outf;\nint *fd_percpu;\nint *fd_instr_count_percpu;\nstruct timeval interval_tv = { 5, 0 };\nstruct timespec interval_ts = { 5, 0 };\n\n \nunsigned int model_orig;\n\nunsigned int num_iterations;\nunsigned int header_iterations;\nunsigned int debug;\nunsigned int quiet;\nunsigned int shown;\nunsigned int sums_need_wide_columns;\nunsigned int rapl_joules;\nunsigned int summary_only;\nunsigned int list_header_only;\nunsigned int dump_only;\nunsigned int do_snb_cstates;\nunsigned int do_knl_cstates;\nunsigned int do_slm_cstates;\nunsigned int use_c1_residency_msr;\nunsigned int has_aperf;\nunsigned int has_epb;\nunsigned int has_turbo;\nunsigned int is_hybrid;\nunsigned int do_irtl_snb;\nunsigned int do_irtl_hsw;\nunsigned int units = 1000000;\t \nunsigned int genuine_intel;\nunsigned int authentic_amd;\nunsigned int hygon_genuine;\nunsigned int max_level, max_extended_level;\nunsigned int has_invariant_tsc;\nunsigned int do_nhm_platform_info;\nunsigned int no_MSR_MISC_PWR_MGMT;\nunsigned int aperf_mperf_multiplier = 1;\ndouble bclk;\ndouble base_hz;\nunsigned int has_base_hz;\ndouble tsc_tweak = 1.0;\nunsigned int show_pkg_only;\nunsigned int show_core_only;\nchar *output_buffer, *outp;\nunsigned int do_rapl;\nunsigned int do_dts;\nunsigned int do_ptm;\nunsigned int do_ipc;\nunsigned long long gfx_cur_rc6_ms;\nunsigned long long cpuidle_cur_cpu_lpi_us;\nunsigned long long cpuidle_cur_sys_lpi_us;\nunsigned int gfx_cur_mhz;\nunsigned int gfx_act_mhz;\nunsigned int tj_max;\nunsigned int tj_max_override;\nint tcc_offset_bits;\ndouble rapl_power_units, rapl_time_units;\ndouble rapl_dram_energy_units, rapl_energy_units;\ndouble rapl_joule_counter_range;\nunsigned int do_core_perf_limit_reasons;\nunsigned int has_automatic_cstate_conversion;\nunsigned int dis_cstate_prewake;\nunsigned int do_gfx_perf_limit_reasons;\nunsigned int do_ring_perf_limit_reasons;\nunsigned int crystal_hz;\nunsigned long long tsc_hz;\nint base_cpu;\ndouble discover_bclk(unsigned int family, unsigned int model);\nunsigned int has_hwp;\t\t \n\t\t\t \nunsigned int has_hwp_notify;\t \nunsigned int has_hwp_activity_window;\t \nunsigned int has_hwp_epp;\t \nunsigned int has_hwp_pkg;\t \nunsigned int has_misc_feature_control;\nunsigned int first_counter_read = 1;\nint ignore_stdin;\n\n#define RAPL_PKG\t\t(1 << 0)\n\t\t\t\t\t \n\t\t\t\t\t \n#define RAPL_PKG_PERF_STATUS\t(1 << 1)\n\t\t\t\t\t \n#define RAPL_PKG_POWER_INFO\t(1 << 2)\n\t\t\t\t\t \n\n#define RAPL_DRAM\t\t(1 << 3)\n\t\t\t\t\t \n\t\t\t\t\t \n#define RAPL_DRAM_PERF_STATUS\t(1 << 4)\n\t\t\t\t\t \n#define RAPL_DRAM_POWER_INFO\t(1 << 5)\n\t\t\t\t\t \n\n#define RAPL_CORES_POWER_LIMIT\t(1 << 6)\n\t\t\t\t\t \n#define RAPL_CORE_POLICY\t(1 << 7)\n\t\t\t\t\t \n\n#define RAPL_GFX\t\t(1 << 8)\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t \n\n#define RAPL_CORES_ENERGY_STATUS\t(1 << 9)\n\t\t\t\t\t \n#define RAPL_PER_CORE_ENERGY\t(1 << 10)\n\t\t\t\t\t \n#define RAPL_AMD_F17H\t\t(1 << 11)\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define RAPL_CORES (RAPL_CORES_ENERGY_STATUS | RAPL_CORES_POWER_LIMIT)\n#define\tTJMAX_DEFAULT\t100\n\n \n#define MSR_RAPL_PWR_UNIT\t0xc0010299\n#define MSR_CORE_ENERGY_STAT\t0xc001029a\n#define MSR_PKG_ENERGY_STAT\t0xc001029b\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint backwards_count;\nchar *progname;\n\n#define CPU_SUBSET_MAXCPUS\t1024\t \ncpu_set_t *cpu_present_set, *cpu_affinity_set, *cpu_subset;\nsize_t cpu_present_setsize, cpu_affinity_setsize, cpu_subset_size;\n#define MAX_ADDED_COUNTERS 8\n#define MAX_ADDED_THREAD_COUNTERS 24\n#define BITMASK_SIZE 32\n\nstruct thread_data {\n\tstruct timeval tv_begin;\n\tstruct timeval tv_end;\n\tstruct timeval tv_delta;\n\tunsigned long long tsc;\n\tunsigned long long aperf;\n\tunsigned long long mperf;\n\tunsigned long long c1;\n\tunsigned long long instr_count;\n\tunsigned long long irq_count;\n\tunsigned int smi_count;\n\tunsigned int cpu_id;\n\tunsigned int apic_id;\n\tunsigned int x2apic_id;\n\tunsigned int flags;\n\tbool is_atom;\n#define CPU_IS_FIRST_THREAD_IN_CORE\t0x2\n#define CPU_IS_FIRST_CORE_IN_PACKAGE\t0x4\n\tunsigned long long counter[MAX_ADDED_THREAD_COUNTERS];\n} *thread_even, *thread_odd;\n\nstruct core_data {\n\tunsigned long long c3;\n\tunsigned long long c6;\n\tunsigned long long c7;\n\tunsigned long long mc6_us;\t \n\tunsigned int core_temp_c;\n\tunsigned int core_energy;\t \n\tunsigned int core_id;\n\tunsigned long long core_throt_cnt;\n\tunsigned long long counter[MAX_ADDED_COUNTERS];\n} *core_even, *core_odd;\n\nstruct pkg_data {\n\tunsigned long long pc2;\n\tunsigned long long pc3;\n\tunsigned long long pc6;\n\tunsigned long long pc7;\n\tunsigned long long pc8;\n\tunsigned long long pc9;\n\tunsigned long long pc10;\n\tunsigned long long cpu_lpi;\n\tunsigned long long sys_lpi;\n\tunsigned long long pkg_wtd_core_c0;\n\tunsigned long long pkg_any_core_c0;\n\tunsigned long long pkg_any_gfxe_c0;\n\tunsigned long long pkg_both_core_gfxe_c0;\n\tlong long gfx_rc6_ms;\n\tunsigned int gfx_mhz;\n\tunsigned int gfx_act_mhz;\n\tunsigned int package_id;\n\tunsigned long long energy_pkg;\t \n\tunsigned long long energy_dram;\t \n\tunsigned long long energy_cores;\t \n\tunsigned long long energy_gfx;\t \n\tunsigned long long rapl_pkg_perf_status;\t \n\tunsigned long long rapl_dram_perf_status;\t \n\tunsigned int pkg_temp_c;\n\tunsigned int uncore_mhz;\n\tunsigned long long counter[MAX_ADDED_COUNTERS];\n} *package_even, *package_odd;\n\n#define ODD_COUNTERS thread_odd, core_odd, package_odd\n#define EVEN_COUNTERS thread_even, core_even, package_even\n\n#define GET_THREAD(thread_base, thread_no, core_no, node_no, pkg_no)\t      \\\n\t((thread_base) +\t\t\t\t\t\t      \\\n\t ((pkg_no) *\t\t\t\t\t\t\t      \\\n\t  topo.nodes_per_pkg * topo.cores_per_node * topo.threads_per_core) + \\\n\t ((node_no) * topo.cores_per_node * topo.threads_per_core) +\t      \\\n\t ((core_no) * topo.threads_per_core) +\t\t\t\t      \\\n\t (thread_no))\n\n#define GET_CORE(core_base, core_no, node_no, pkg_no)\t\t\t\\\n\t((core_base) +\t\t\t\t\t\t\t\\\n\t ((pkg_no) *  topo.nodes_per_pkg * topo.cores_per_node) +\t\\\n\t ((node_no) * topo.cores_per_node) +\t\t\t\t\\\n\t (core_no))\n\n#define GET_PKG(pkg_base, pkg_no) (pkg_base + pkg_no)\n\n \nenum {\n\tIDX_PKG_ENERGY,\n\tIDX_DRAM_ENERGY,\n\tIDX_PP0_ENERGY,\n\tIDX_PP1_ENERGY,\n\tIDX_PKG_PERF,\n\tIDX_DRAM_PERF,\n\tIDX_COUNT,\n};\n\nint get_msr_sum(int cpu, off_t offset, unsigned long long *msr);\n\nstruct msr_sum_array {\n\t \n\tstruct {\n\t\t \n\t\tunsigned long long sum;\n\t\t \n\t\tunsigned long long last;\n\t} entries[IDX_COUNT];\n};\n\n \nstruct msr_sum_array *per_cpu_msr_sum;\n\noff_t idx_to_offset(int idx)\n{\n\toff_t offset;\n\n\tswitch (idx) {\n\tcase IDX_PKG_ENERGY:\n\t\tif (do_rapl & RAPL_AMD_F17H)\n\t\t\toffset = MSR_PKG_ENERGY_STAT;\n\t\telse\n\t\t\toffset = MSR_PKG_ENERGY_STATUS;\n\t\tbreak;\n\tcase IDX_DRAM_ENERGY:\n\t\toffset = MSR_DRAM_ENERGY_STATUS;\n\t\tbreak;\n\tcase IDX_PP0_ENERGY:\n\t\toffset = MSR_PP0_ENERGY_STATUS;\n\t\tbreak;\n\tcase IDX_PP1_ENERGY:\n\t\toffset = MSR_PP1_ENERGY_STATUS;\n\t\tbreak;\n\tcase IDX_PKG_PERF:\n\t\toffset = MSR_PKG_PERF_STATUS;\n\t\tbreak;\n\tcase IDX_DRAM_PERF:\n\t\toffset = MSR_DRAM_PERF_STATUS;\n\t\tbreak;\n\tdefault:\n\t\toffset = -1;\n\t}\n\treturn offset;\n}\n\nint offset_to_idx(off_t offset)\n{\n\tint idx;\n\n\tswitch (offset) {\n\tcase MSR_PKG_ENERGY_STATUS:\n\tcase MSR_PKG_ENERGY_STAT:\n\t\tidx = IDX_PKG_ENERGY;\n\t\tbreak;\n\tcase MSR_DRAM_ENERGY_STATUS:\n\t\tidx = IDX_DRAM_ENERGY;\n\t\tbreak;\n\tcase MSR_PP0_ENERGY_STATUS:\n\t\tidx = IDX_PP0_ENERGY;\n\t\tbreak;\n\tcase MSR_PP1_ENERGY_STATUS:\n\t\tidx = IDX_PP1_ENERGY;\n\t\tbreak;\n\tcase MSR_PKG_PERF_STATUS:\n\t\tidx = IDX_PKG_PERF;\n\t\tbreak;\n\tcase MSR_DRAM_PERF_STATUS:\n\t\tidx = IDX_DRAM_PERF;\n\t\tbreak;\n\tdefault:\n\t\tidx = -1;\n\t}\n\treturn idx;\n}\n\nint idx_valid(int idx)\n{\n\tswitch (idx) {\n\tcase IDX_PKG_ENERGY:\n\t\treturn do_rapl & (RAPL_PKG | RAPL_AMD_F17H);\n\tcase IDX_DRAM_ENERGY:\n\t\treturn do_rapl & RAPL_DRAM;\n\tcase IDX_PP0_ENERGY:\n\t\treturn do_rapl & RAPL_CORES_ENERGY_STATUS;\n\tcase IDX_PP1_ENERGY:\n\t\treturn do_rapl & RAPL_GFX;\n\tcase IDX_PKG_PERF:\n\t\treturn do_rapl & RAPL_PKG_PERF_STATUS;\n\tcase IDX_DRAM_PERF:\n\t\treturn do_rapl & RAPL_DRAM_PERF_STATUS;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstruct sys_counters {\n\tunsigned int added_thread_counters;\n\tunsigned int added_core_counters;\n\tunsigned int added_package_counters;\n\tstruct msr_counter *tp;\n\tstruct msr_counter *cp;\n\tstruct msr_counter *pp;\n} sys;\n\nstruct system_summary {\n\tstruct thread_data threads;\n\tstruct core_data cores;\n\tstruct pkg_data packages;\n} average;\n\nstruct cpu_topology {\n\tint physical_package_id;\n\tint die_id;\n\tint logical_cpu_id;\n\tint physical_node_id;\n\tint logical_node_id;\t \n\tint physical_core_id;\n\tint thread_id;\n\tcpu_set_t *put_ids;\t \n} *cpus;\n\nstruct topo_params {\n\tint num_packages;\n\tint num_die;\n\tint num_cpus;\n\tint num_cores;\n\tint max_cpu_num;\n\tint max_node_num;\n\tint nodes_per_pkg;\n\tint cores_per_node;\n\tint threads_per_core;\n} topo;\n\nstruct timeval tv_even, tv_odd, tv_delta;\n\nint *irq_column_2_cpu;\t\t \nint *irqs_per_cpu;\t\t \n\nvoid setup_all_buffers(void);\n\nchar *sys_lpi_file;\nchar *sys_lpi_file_sysfs = \"/sys/devices/system/cpu/cpuidle/low_power_idle_system_residency_us\";\nchar *sys_lpi_file_debugfs = \"/sys/kernel/debug/pmc_core/slp_s0_residency_usec\";\n\nint cpu_is_not_present(int cpu)\n{\n\treturn !CPU_ISSET_S(cpu, cpu_present_setsize, cpu_present_set);\n}\n\n \n\nint for_all_cpus(int (func) (struct thread_data *, struct core_data *, struct pkg_data *),\n\t\t struct thread_data *thread_base, struct core_data *core_base, struct pkg_data *pkg_base)\n{\n\tint retval, pkg_no, core_no, thread_no, node_no;\n\n\tfor (pkg_no = 0; pkg_no < topo.num_packages; ++pkg_no) {\n\t\tfor (node_no = 0; node_no < topo.nodes_per_pkg; node_no++) {\n\t\t\tfor (core_no = 0; core_no < topo.cores_per_node; ++core_no) {\n\t\t\t\tfor (thread_no = 0; thread_no < topo.threads_per_core; ++thread_no) {\n\t\t\t\t\tstruct thread_data *t;\n\t\t\t\t\tstruct core_data *c;\n\t\t\t\t\tstruct pkg_data *p;\n\n\t\t\t\t\tt = GET_THREAD(thread_base, thread_no, core_no, node_no, pkg_no);\n\n\t\t\t\t\tif (cpu_is_not_present(t->cpu_id))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tc = GET_CORE(core_base, core_no, node_no, pkg_no);\n\t\t\t\t\tp = GET_PKG(pkg_base, pkg_no);\n\n\t\t\t\t\tretval = func(t, c, p);\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\treturn retval;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint cpu_migrate(int cpu)\n{\n\tCPU_ZERO_S(cpu_affinity_setsize, cpu_affinity_set);\n\tCPU_SET_S(cpu, cpu_affinity_setsize, cpu_affinity_set);\n\tif (sched_setaffinity(0, cpu_affinity_setsize, cpu_affinity_set) == -1)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\nint get_msr_fd(int cpu)\n{\n\tchar pathname[32];\n\tint fd;\n\n\tfd = fd_percpu[cpu];\n\n\tif (fd)\n\t\treturn fd;\n\n\tsprintf(pathname, \"/dev/cpu/%d/msr\", cpu);\n\tfd = open(pathname, O_RDONLY);\n\tif (fd < 0)\n\t\terr(-1, \"%s open failed, try chown or chmod +r /dev/cpu/*/msr, or run as root\", pathname);\n\n\tfd_percpu[cpu] = fd;\n\n\treturn fd;\n}\n\nstatic long perf_event_open(struct perf_event_attr *hw_event, pid_t pid, int cpu, int group_fd, unsigned long flags)\n{\n\treturn syscall(__NR_perf_event_open, hw_event, pid, cpu, group_fd, flags);\n}\n\nstatic int perf_instr_count_open(int cpu_num)\n{\n\tstruct perf_event_attr pea;\n\tint fd;\n\n\tmemset(&pea, 0, sizeof(struct perf_event_attr));\n\tpea.type = PERF_TYPE_HARDWARE;\n\tpea.size = sizeof(struct perf_event_attr);\n\tpea.config = PERF_COUNT_HW_INSTRUCTIONS;\n\n\t \n\tfd = perf_event_open(&pea, -1, cpu_num, -1, 0);\n\tif (fd == -1) {\n\t\twarnx(\"capget(CAP_PERFMON) failed, try \\\"# setcap cap_sys_admin=ep %s\\\"\", progname);\n\t\tBIC_NOT_PRESENT(BIC_IPC);\n\t}\n\n\treturn fd;\n}\n\nint get_instr_count_fd(int cpu)\n{\n\tif (fd_instr_count_percpu[cpu])\n\t\treturn fd_instr_count_percpu[cpu];\n\n\tfd_instr_count_percpu[cpu] = perf_instr_count_open(cpu);\n\n\treturn fd_instr_count_percpu[cpu];\n}\n\nint get_msr(int cpu, off_t offset, unsigned long long *msr)\n{\n\tssize_t retval;\n\n\tretval = pread(get_msr_fd(cpu), msr, sizeof(*msr), offset);\n\n\tif (retval != sizeof *msr)\n\t\terr(-1, \"cpu%d: msr offset 0x%llx read failed\", cpu, (unsigned long long)offset);\n\n\treturn 0;\n}\n\n#define MAX_DEFERRED 16\nchar *deferred_add_names[MAX_DEFERRED];\nchar *deferred_skip_names[MAX_DEFERRED];\nint deferred_add_index;\nint deferred_skip_index;\n\n \nenum show_hide_mode { SHOW_LIST, HIDE_LIST } global_show_hide_mode = HIDE_LIST;\n\nvoid help(void)\n{\n\tfprintf(outf,\n\t\t\"Usage: turbostat [OPTIONS][(--interval seconds) | COMMAND ...]\\n\"\n\t\t\"\\n\"\n\t\t\"Turbostat forks the specified COMMAND and prints statistics\\n\"\n\t\t\"when COMMAND completes.\\n\"\n\t\t\"If no COMMAND is specified, turbostat wakes every 5-seconds\\n\"\n\t\t\"to print statistics, until interrupted.\\n\"\n\t\t\"  -a, --add\tadd a counter\\n\"\n\t\t\"\t\t  eg. --add msr0x10,u64,cpu,delta,MY_TSC\\n\"\n\t\t\"  -c, --cpu\tcpu-set\tlimit output to summary plus cpu-set:\\n\"\n\t\t\"\t\t  {core | package | j,k,l..m,n-p }\\n\"\n\t\t\"  -d, --debug\tdisplays usec, Time_Of_Day_Seconds and more debugging\\n\"\n\t\t\"  -D, --Dump\tdisplays the raw counter values\\n\"\n\t\t\"  -e, --enable\t[all | column]\\n\"\n\t\t\"\t\tshows all or the specified disabled column\\n\"\n\t\t\"  -H, --hide [column|column,column,...]\\n\"\n\t\t\"\t\thide the specified column(s)\\n\"\n\t\t\"  -i, --interval sec.subsec\\n\"\n\t\t\"\t\tOverride default 5-second measurement interval\\n\"\n\t\t\"  -J, --Joules\tdisplays energy in Joules instead of Watts\\n\"\n\t\t\"  -l, --list\tlist column headers only\\n\"\n\t\t\"  -n, --num_iterations num\\n\"\n\t\t\"\t\tnumber of the measurement iterations\\n\"\n\t\t\"  -N, --header_iterations num\\n\"\n\t\t\"\t\tprint header every num iterations\\n\"\n\t\t\"  -o, --out file\\n\"\n\t\t\"\t\tcreate or truncate \\\"file\\\" for all output\\n\"\n\t\t\"  -q, --quiet\tskip decoding system configuration header\\n\"\n\t\t\"  -s, --show [column|column,column,...]\\n\"\n\t\t\"\t\tshow only the specified column(s)\\n\"\n\t\t\"  -S, --Summary\\n\"\n\t\t\"\t\tlimits output to 1-line system summary per interval\\n\"\n\t\t\"  -T, --TCC temperature\\n\"\n\t\t\"\t\tsets the Thermal Control Circuit temperature in\\n\"\n\t\t\"\t\t  degrees Celsius\\n\"\n\t\t\"  -h, --help\tprint this help message\\n\"\n\t\t\"  -v, --version\tprint version information\\n\" \"\\n\" \"For more help, run \\\"man turbostat\\\"\\n\");\n}\n\n \nunsigned long long bic_lookup(char *name_list, enum show_hide_mode mode)\n{\n\tunsigned int i;\n\tunsigned long long retval = 0;\n\n\twhile (name_list) {\n\t\tchar *comma;\n\n\t\tcomma = strchr(name_list, ',');\n\n\t\tif (comma)\n\t\t\t*comma = '\\0';\n\n\t\tfor (i = 0; i < MAX_BIC; ++i) {\n\t\t\tif (!strcmp(name_list, bic[i].name)) {\n\t\t\t\tretval |= (1ULL << i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!strcmp(name_list, \"all\")) {\n\t\t\t\tretval |= ~0;\n\t\t\t\tbreak;\n\t\t\t} else if (!strcmp(name_list, \"topology\")) {\n\t\t\t\tretval |= BIC_TOPOLOGY;\n\t\t\t\tbreak;\n\t\t\t} else if (!strcmp(name_list, \"power\")) {\n\t\t\t\tretval |= BIC_THERMAL_PWR;\n\t\t\t\tbreak;\n\t\t\t} else if (!strcmp(name_list, \"idle\")) {\n\t\t\t\tretval |= BIC_IDLE;\n\t\t\t\tbreak;\n\t\t\t} else if (!strcmp(name_list, \"frequency\")) {\n\t\t\t\tretval |= BIC_FREQUENCY;\n\t\t\t\tbreak;\n\t\t\t} else if (!strcmp(name_list, \"other\")) {\n\t\t\t\tretval |= BIC_OTHER;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif (i == MAX_BIC) {\n\t\t\tif (mode == SHOW_LIST) {\n\t\t\t\tdeferred_add_names[deferred_add_index++] = name_list;\n\t\t\t\tif (deferred_add_index >= MAX_DEFERRED) {\n\t\t\t\t\tfprintf(stderr, \"More than max %d un-recognized --add options '%s'\\n\",\n\t\t\t\t\t\tMAX_DEFERRED, name_list);\n\t\t\t\t\thelp();\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdeferred_skip_names[deferred_skip_index++] = name_list;\n\t\t\t\tif (debug)\n\t\t\t\t\tfprintf(stderr, \"deferred \\\"%s\\\"\\n\", name_list);\n\t\t\t\tif (deferred_skip_index >= MAX_DEFERRED) {\n\t\t\t\t\tfprintf(stderr, \"More than max %d un-recognized --skip options '%s'\\n\",\n\t\t\t\t\t\tMAX_DEFERRED, name_list);\n\t\t\t\t\thelp();\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tname_list = comma;\n\t\tif (name_list)\n\t\t\tname_list++;\n\n\t}\n\treturn retval;\n}\n\nvoid print_header(char *delim)\n{\n\tstruct msr_counter *mp;\n\tint printed = 0;\n\n\tif (DO_BIC(BIC_USEC))\n\t\toutp += sprintf(outp, \"%susec\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_TOD))\n\t\toutp += sprintf(outp, \"%sTime_Of_Day_Seconds\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Package))\n\t\toutp += sprintf(outp, \"%sPackage\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Die))\n\t\toutp += sprintf(outp, \"%sDie\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Node))\n\t\toutp += sprintf(outp, \"%sNode\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Core))\n\t\toutp += sprintf(outp, \"%sCore\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_CPU))\n\t\toutp += sprintf(outp, \"%sCPU\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_APIC))\n\t\toutp += sprintf(outp, \"%sAPIC\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_X2APIC))\n\t\toutp += sprintf(outp, \"%sX2APIC\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Avg_MHz))\n\t\toutp += sprintf(outp, \"%sAvg_MHz\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Busy))\n\t\toutp += sprintf(outp, \"%sBusy%%\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Bzy_MHz))\n\t\toutp += sprintf(outp, \"%sBzy_MHz\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_TSC_MHz))\n\t\toutp += sprintf(outp, \"%sTSC_MHz\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_IPC))\n\t\toutp += sprintf(outp, \"%sIPC\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_IRQ)) {\n\t\tif (sums_need_wide_columns)\n\t\t\toutp += sprintf(outp, \"%s     IRQ\", (printed++ ? delim : \"\"));\n\t\telse\n\t\t\toutp += sprintf(outp, \"%sIRQ\", (printed++ ? delim : \"\"));\n\t}\n\n\tif (DO_BIC(BIC_SMI))\n\t\toutp += sprintf(outp, \"%sSMI\", (printed++ ? delim : \"\"));\n\n\tfor (mp = sys.tp; mp; mp = mp->next) {\n\n\t\tif (mp->format == FORMAT_RAW) {\n\t\t\tif (mp->width == 64)\n\t\t\t\toutp += sprintf(outp, \"%s%18.18s\", (printed++ ? delim : \"\"), mp->name);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%10.10s\", (printed++ ? delim : \"\"), mp->name);\n\t\t} else {\n\t\t\tif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\n\t\t\t\toutp += sprintf(outp, \"%s%8s\", (printed++ ? delim : \"\"), mp->name);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%s\", (printed++ ? delim : \"\"), mp->name);\n\t\t}\n\t}\n\n\tif (DO_BIC(BIC_CPU_c1))\n\t\toutp += sprintf(outp, \"%sCPU%%c1\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_CPU_c3))\n\t\toutp += sprintf(outp, \"%sCPU%%c3\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_CPU_c6))\n\t\toutp += sprintf(outp, \"%sCPU%%c6\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_CPU_c7))\n\t\toutp += sprintf(outp, \"%sCPU%%c7\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_Mod_c6))\n\t\toutp += sprintf(outp, \"%sMod%%c6\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_CoreTmp))\n\t\toutp += sprintf(outp, \"%sCoreTmp\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_CORE_THROT_CNT))\n\t\toutp += sprintf(outp, \"%sCoreThr\", (printed++ ? delim : \"\"));\n\n\tif (do_rapl && !rapl_joules) {\n\t\tif (DO_BIC(BIC_CorWatt) && (do_rapl & RAPL_PER_CORE_ENERGY))\n\t\t\toutp += sprintf(outp, \"%sCorWatt\", (printed++ ? delim : \"\"));\n\t} else if (do_rapl && rapl_joules) {\n\t\tif (DO_BIC(BIC_Cor_J) && (do_rapl & RAPL_PER_CORE_ENERGY))\n\t\t\toutp += sprintf(outp, \"%sCor_J\", (printed++ ? delim : \"\"));\n\t}\n\n\tfor (mp = sys.cp; mp; mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW) {\n\t\t\tif (mp->width == 64)\n\t\t\t\toutp += sprintf(outp, \"%s%18.18s\", delim, mp->name);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%10.10s\", delim, mp->name);\n\t\t} else {\n\t\t\tif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\n\t\t\t\toutp += sprintf(outp, \"%s%8s\", delim, mp->name);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%s\", delim, mp->name);\n\t\t}\n\t}\n\n\tif (DO_BIC(BIC_PkgTmp))\n\t\toutp += sprintf(outp, \"%sPkgTmp\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_GFX_rc6))\n\t\toutp += sprintf(outp, \"%sGFX%%rc6\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_GFXMHz))\n\t\toutp += sprintf(outp, \"%sGFXMHz\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_GFXACTMHz))\n\t\toutp += sprintf(outp, \"%sGFXAMHz\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_Totl_c0))\n\t\toutp += sprintf(outp, \"%sTotl%%C0\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Any_c0))\n\t\toutp += sprintf(outp, \"%sAny%%C0\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_GFX_c0))\n\t\toutp += sprintf(outp, \"%sGFX%%C0\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_CPUGFX))\n\t\toutp += sprintf(outp, \"%sCPUGFX%%\", (printed++ ? delim : \"\"));\n\n\tif (DO_BIC(BIC_Pkgpc2))\n\t\toutp += sprintf(outp, \"%sPkg%%pc2\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Pkgpc3))\n\t\toutp += sprintf(outp, \"%sPkg%%pc3\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Pkgpc6))\n\t\toutp += sprintf(outp, \"%sPkg%%pc6\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Pkgpc7))\n\t\toutp += sprintf(outp, \"%sPkg%%pc7\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Pkgpc8))\n\t\toutp += sprintf(outp, \"%sPkg%%pc8\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Pkgpc9))\n\t\toutp += sprintf(outp, \"%sPkg%%pc9\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_Pkgpc10))\n\t\toutp += sprintf(outp, \"%sPk%%pc10\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_CPU_LPI))\n\t\toutp += sprintf(outp, \"%sCPU%%LPI\", (printed++ ? delim : \"\"));\n\tif (DO_BIC(BIC_SYS_LPI))\n\t\toutp += sprintf(outp, \"%sSYS%%LPI\", (printed++ ? delim : \"\"));\n\n\tif (do_rapl && !rapl_joules) {\n\t\tif (DO_BIC(BIC_PkgWatt))\n\t\t\toutp += sprintf(outp, \"%sPkgWatt\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_CorWatt) && !(do_rapl & RAPL_PER_CORE_ENERGY))\n\t\t\toutp += sprintf(outp, \"%sCorWatt\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_GFXWatt))\n\t\t\toutp += sprintf(outp, \"%sGFXWatt\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_RAMWatt))\n\t\t\toutp += sprintf(outp, \"%sRAMWatt\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_PKG__))\n\t\t\toutp += sprintf(outp, \"%sPKG_%%\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_RAM__))\n\t\t\toutp += sprintf(outp, \"%sRAM_%%\", (printed++ ? delim : \"\"));\n\t} else if (do_rapl && rapl_joules) {\n\t\tif (DO_BIC(BIC_Pkg_J))\n\t\t\toutp += sprintf(outp, \"%sPkg_J\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_Cor_J) && !(do_rapl & RAPL_PER_CORE_ENERGY))\n\t\t\toutp += sprintf(outp, \"%sCor_J\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_GFX_J))\n\t\t\toutp += sprintf(outp, \"%sGFX_J\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_RAM_J))\n\t\t\toutp += sprintf(outp, \"%sRAM_J\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_PKG__))\n\t\t\toutp += sprintf(outp, \"%sPKG_%%\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_RAM__))\n\t\t\toutp += sprintf(outp, \"%sRAM_%%\", (printed++ ? delim : \"\"));\n\t}\n\tif (DO_BIC(BIC_UNCORE_MHZ))\n\t\toutp += sprintf(outp, \"%sUncMHz\", (printed++ ? delim : \"\"));\n\n\tfor (mp = sys.pp; mp; mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW) {\n\t\t\tif (mp->width == 64)\n\t\t\t\toutp += sprintf(outp, \"%s%18.18s\", delim, mp->name);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%10.10s\", delim, mp->name);\n\t\t} else {\n\t\t\tif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\n\t\t\t\toutp += sprintf(outp, \"%s%8s\", delim, mp->name);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%s\", delim, mp->name);\n\t\t}\n\t}\n\n\toutp += sprintf(outp, \"\\n\");\n}\n\nint dump_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint i;\n\tstruct msr_counter *mp;\n\n\toutp += sprintf(outp, \"t %p, c %p, p %p\\n\", t, c, p);\n\n\tif (t) {\n\t\toutp += sprintf(outp, \"CPU: %d flags 0x%x\\n\", t->cpu_id, t->flags);\n\t\toutp += sprintf(outp, \"TSC: %016llX\\n\", t->tsc);\n\t\toutp += sprintf(outp, \"aperf: %016llX\\n\", t->aperf);\n\t\toutp += sprintf(outp, \"mperf: %016llX\\n\", t->mperf);\n\t\toutp += sprintf(outp, \"c1: %016llX\\n\", t->c1);\n\n\t\tif (DO_BIC(BIC_IPC))\n\t\t\toutp += sprintf(outp, \"IPC: %lld\\n\", t->instr_count);\n\n\t\tif (DO_BIC(BIC_IRQ))\n\t\t\toutp += sprintf(outp, \"IRQ: %lld\\n\", t->irq_count);\n\t\tif (DO_BIC(BIC_SMI))\n\t\t\toutp += sprintf(outp, \"SMI: %d\\n\", t->smi_count);\n\n\t\tfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\n\t\t\toutp += sprintf(outp, \"tADDED [%d] msr0x%x: %08llX\\n\", i, mp->msr_num, t->counter[i]);\n\t\t}\n\t}\n\n\tif (c) {\n\t\toutp += sprintf(outp, \"core: %d\\n\", c->core_id);\n\t\toutp += sprintf(outp, \"c3: %016llX\\n\", c->c3);\n\t\toutp += sprintf(outp, \"c6: %016llX\\n\", c->c6);\n\t\toutp += sprintf(outp, \"c7: %016llX\\n\", c->c7);\n\t\toutp += sprintf(outp, \"DTS: %dC\\n\", c->core_temp_c);\n\t\toutp += sprintf(outp, \"cpu_throt_count: %016llX\\n\", c->core_throt_cnt);\n\t\toutp += sprintf(outp, \"Joules: %0X\\n\", c->core_energy);\n\n\t\tfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\n\t\t\toutp += sprintf(outp, \"cADDED [%d] msr0x%x: %08llX\\n\", i, mp->msr_num, c->counter[i]);\n\t\t}\n\t\toutp += sprintf(outp, \"mc6_us: %016llX\\n\", c->mc6_us);\n\t}\n\n\tif (p) {\n\t\toutp += sprintf(outp, \"package: %d\\n\", p->package_id);\n\n\t\toutp += sprintf(outp, \"Weighted cores: %016llX\\n\", p->pkg_wtd_core_c0);\n\t\toutp += sprintf(outp, \"Any cores: %016llX\\n\", p->pkg_any_core_c0);\n\t\toutp += sprintf(outp, \"Any GFX: %016llX\\n\", p->pkg_any_gfxe_c0);\n\t\toutp += sprintf(outp, \"CPU + GFX: %016llX\\n\", p->pkg_both_core_gfxe_c0);\n\n\t\toutp += sprintf(outp, \"pc2: %016llX\\n\", p->pc2);\n\t\tif (DO_BIC(BIC_Pkgpc3))\n\t\t\toutp += sprintf(outp, \"pc3: %016llX\\n\", p->pc3);\n\t\tif (DO_BIC(BIC_Pkgpc6))\n\t\t\toutp += sprintf(outp, \"pc6: %016llX\\n\", p->pc6);\n\t\tif (DO_BIC(BIC_Pkgpc7))\n\t\t\toutp += sprintf(outp, \"pc7: %016llX\\n\", p->pc7);\n\t\toutp += sprintf(outp, \"pc8: %016llX\\n\", p->pc8);\n\t\toutp += sprintf(outp, \"pc9: %016llX\\n\", p->pc9);\n\t\toutp += sprintf(outp, \"pc10: %016llX\\n\", p->pc10);\n\t\toutp += sprintf(outp, \"cpu_lpi: %016llX\\n\", p->cpu_lpi);\n\t\toutp += sprintf(outp, \"sys_lpi: %016llX\\n\", p->sys_lpi);\n\t\toutp += sprintf(outp, \"Joules PKG: %0llX\\n\", p->energy_pkg);\n\t\toutp += sprintf(outp, \"Joules COR: %0llX\\n\", p->energy_cores);\n\t\toutp += sprintf(outp, \"Joules GFX: %0llX\\n\", p->energy_gfx);\n\t\toutp += sprintf(outp, \"Joules RAM: %0llX\\n\", p->energy_dram);\n\t\toutp += sprintf(outp, \"Throttle PKG: %0llX\\n\", p->rapl_pkg_perf_status);\n\t\toutp += sprintf(outp, \"Throttle RAM: %0llX\\n\", p->rapl_dram_perf_status);\n\t\toutp += sprintf(outp, \"PTM: %dC\\n\", p->pkg_temp_c);\n\n\t\tfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\n\t\t\toutp += sprintf(outp, \"pADDED [%d] msr0x%x: %08llX\\n\", i, mp->msr_num, p->counter[i]);\n\t\t}\n\t}\n\n\toutp += sprintf(outp, \"\\n\");\n\n\treturn 0;\n}\n\n \nint format_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tdouble interval_float, tsc;\n\tchar *fmt8;\n\tint i;\n\tstruct msr_counter *mp;\n\tchar *delim = \"\\t\";\n\tint printed = 0;\n\n\t \n\tif (show_core_only && !(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\n\t\treturn 0;\n\n\t \n\tif (show_pkg_only && !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\t \n\tif ((t != &average.threads) && (cpu_subset && !CPU_ISSET_S(t->cpu_id, cpu_subset_size, cpu_subset)))\n\t\treturn 0;\n\n\tif (DO_BIC(BIC_USEC)) {\n\t\t \n\t\tstruct timeval tv;\n\n\t\ttimersub(&t->tv_end, &t->tv_begin, &tv);\n\t\toutp += sprintf(outp, \"%5ld\\t\", tv.tv_sec * 1000000 + tv.tv_usec);\n\t}\n\n\t \n\tif (DO_BIC(BIC_TOD))\n\t\toutp += sprintf(outp, \"%10ld.%06ld\\t\", t->tv_end.tv_sec, t->tv_end.tv_usec);\n\n\tinterval_float = t->tv_delta.tv_sec + t->tv_delta.tv_usec / 1000000.0;\n\n\ttsc = t->tsc * tsc_tweak;\n\n\t \n\tif (t == &average.threads) {\n\t\tif (DO_BIC(BIC_Package))\n\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_Die))\n\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_Node))\n\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_Core))\n\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_CPU))\n\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_APIC))\n\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\tif (DO_BIC(BIC_X2APIC))\n\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t} else {\n\t\tif (DO_BIC(BIC_Package)) {\n\t\t\tif (p)\n\t\t\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), p->package_id);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\t}\n\t\tif (DO_BIC(BIC_Die)) {\n\t\t\tif (c)\n\t\t\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), cpus[t->cpu_id].die_id);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\t}\n\t\tif (DO_BIC(BIC_Node)) {\n\t\t\tif (t)\n\t\t\t\toutp += sprintf(outp, \"%s%d\",\n\t\t\t\t\t\t(printed++ ? delim : \"\"), cpus[t->cpu_id].physical_node_id);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\t}\n\t\tif (DO_BIC(BIC_Core)) {\n\t\t\tif (c)\n\t\t\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), c->core_id);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s-\", (printed++ ? delim : \"\"));\n\t\t}\n\t\tif (DO_BIC(BIC_CPU))\n\t\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), t->cpu_id);\n\t\tif (DO_BIC(BIC_APIC))\n\t\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), t->apic_id);\n\t\tif (DO_BIC(BIC_X2APIC))\n\t\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), t->x2apic_id);\n\t}\n\n\tif (DO_BIC(BIC_Avg_MHz))\n\t\toutp += sprintf(outp, \"%s%.0f\", (printed++ ? delim : \"\"), 1.0 / units * t->aperf / interval_float);\n\n\tif (DO_BIC(BIC_Busy))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * t->mperf / tsc);\n\n\tif (DO_BIC(BIC_Bzy_MHz)) {\n\t\tif (has_base_hz)\n\t\t\toutp +=\n\t\t\t    sprintf(outp, \"%s%.0f\", (printed++ ? delim : \"\"), base_hz / units * t->aperf / t->mperf);\n\t\telse\n\t\t\toutp += sprintf(outp, \"%s%.0f\", (printed++ ? delim : \"\"),\n\t\t\t\t\ttsc / units * t->aperf / t->mperf / interval_float);\n\t}\n\n\tif (DO_BIC(BIC_TSC_MHz))\n\t\toutp += sprintf(outp, \"%s%.0f\", (printed++ ? delim : \"\"), 1.0 * t->tsc / units / interval_float);\n\n\tif (DO_BIC(BIC_IPC))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 1.0 * t->instr_count / t->aperf);\n\n\t \n\tif (DO_BIC(BIC_IRQ)) {\n\t\tif (sums_need_wide_columns)\n\t\t\toutp += sprintf(outp, \"%s%8lld\", (printed++ ? delim : \"\"), t->irq_count);\n\t\telse\n\t\t\toutp += sprintf(outp, \"%s%lld\", (printed++ ? delim : \"\"), t->irq_count);\n\t}\n\n\t \n\tif (DO_BIC(BIC_SMI))\n\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), t->smi_count);\n\n\t \n\tfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW) {\n\t\t\tif (mp->width == 32)\n\t\t\t\toutp +=\n\t\t\t\t    sprintf(outp, \"%s0x%08x\", (printed++ ? delim : \"\"), (unsigned int)t->counter[i]);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s0x%016llx\", (printed++ ? delim : \"\"), t->counter[i]);\n\t\t} else if (mp->format == FORMAT_DELTA) {\n\t\t\tif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\n\t\t\t\toutp += sprintf(outp, \"%s%8lld\", (printed++ ? delim : \"\"), t->counter[i]);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%lld\", (printed++ ? delim : \"\"), t->counter[i]);\n\t\t} else if (mp->format == FORMAT_PERCENT) {\n\t\t\tif (mp->type == COUNTER_USEC)\n\t\t\t\toutp +=\n\t\t\t\t    sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"),\n\t\t\t\t\t    t->counter[i] / interval_float / 10000);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * t->counter[i] / tsc);\n\t\t}\n\t}\n\n\t \n\tif (DO_BIC(BIC_CPU_c1))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * t->c1 / tsc);\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\n\t\tgoto done;\n\n\tif (DO_BIC(BIC_CPU_c3))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * c->c3 / tsc);\n\tif (DO_BIC(BIC_CPU_c6))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * c->c6 / tsc);\n\tif (DO_BIC(BIC_CPU_c7))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * c->c7 / tsc);\n\n\t \n\tif (DO_BIC(BIC_Mod_c6))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * c->mc6_us / tsc);\n\n\tif (DO_BIC(BIC_CoreTmp))\n\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), c->core_temp_c);\n\n\t \n\tif (DO_BIC(BIC_CORE_THROT_CNT))\n\t\toutp += sprintf(outp, \"%s%lld\", (printed++ ? delim : \"\"), c->core_throt_cnt);\n\n\tfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW) {\n\t\t\tif (mp->width == 32)\n\t\t\t\toutp +=\n\t\t\t\t    sprintf(outp, \"%s0x%08x\", (printed++ ? delim : \"\"), (unsigned int)c->counter[i]);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s0x%016llx\", (printed++ ? delim : \"\"), c->counter[i]);\n\t\t} else if (mp->format == FORMAT_DELTA) {\n\t\t\tif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\n\t\t\t\toutp += sprintf(outp, \"%s%8lld\", (printed++ ? delim : \"\"), c->counter[i]);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%lld\", (printed++ ? delim : \"\"), c->counter[i]);\n\t\t} else if (mp->format == FORMAT_PERCENT) {\n\t\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * c->counter[i] / tsc);\n\t\t}\n\t}\n\n\tfmt8 = \"%s%.2f\";\n\n\tif (DO_BIC(BIC_CorWatt) && (do_rapl & RAPL_PER_CORE_ENERGY))\n\t\toutp +=\n\t\t    sprintf(outp, fmt8, (printed++ ? delim : \"\"), c->core_energy * rapl_energy_units / interval_float);\n\tif (DO_BIC(BIC_Cor_J) && (do_rapl & RAPL_PER_CORE_ENERGY))\n\t\toutp += sprintf(outp, fmt8, (printed++ ? delim : \"\"), c->core_energy * rapl_energy_units);\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\tgoto done;\n\n\t \n\tif (DO_BIC(BIC_PkgTmp))\n\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), p->pkg_temp_c);\n\n\t \n\tif (DO_BIC(BIC_GFX_rc6)) {\n\t\tif (p->gfx_rc6_ms == -1) {\t \n\t\t\toutp += sprintf(outp, \"%s**.**\", (printed++ ? delim : \"\"));\n\t\t} else {\n\t\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"),\n\t\t\t\t\tp->gfx_rc6_ms / 10.0 / interval_float);\n\t\t}\n\t}\n\n\t \n\tif (DO_BIC(BIC_GFXMHz))\n\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), p->gfx_mhz);\n\n\t \n\tif (DO_BIC(BIC_GFXACTMHz))\n\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), p->gfx_act_mhz);\n\n\t \n\tif (DO_BIC(BIC_Totl_c0))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pkg_wtd_core_c0 / tsc);\n\tif (DO_BIC(BIC_Any_c0))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pkg_any_core_c0 / tsc);\n\tif (DO_BIC(BIC_GFX_c0))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pkg_any_gfxe_c0 / tsc);\n\tif (DO_BIC(BIC_CPUGFX))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pkg_both_core_gfxe_c0 / tsc);\n\n\tif (DO_BIC(BIC_Pkgpc2))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pc2 / tsc);\n\tif (DO_BIC(BIC_Pkgpc3))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pc3 / tsc);\n\tif (DO_BIC(BIC_Pkgpc6))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pc6 / tsc);\n\tif (DO_BIC(BIC_Pkgpc7))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pc7 / tsc);\n\tif (DO_BIC(BIC_Pkgpc8))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pc8 / tsc);\n\tif (DO_BIC(BIC_Pkgpc9))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pc9 / tsc);\n\tif (DO_BIC(BIC_Pkgpc10))\n\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->pc10 / tsc);\n\n\tif (DO_BIC(BIC_CPU_LPI))\n\t\toutp +=\n\t\t    sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->cpu_lpi / 1000000.0 / interval_float);\n\tif (DO_BIC(BIC_SYS_LPI))\n\t\toutp +=\n\t\t    sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->sys_lpi / 1000000.0 / interval_float);\n\n\tif (DO_BIC(BIC_PkgWatt))\n\t\toutp +=\n\t\t    sprintf(outp, fmt8, (printed++ ? delim : \"\"), p->energy_pkg * rapl_energy_units / interval_float);\n\n\tif (DO_BIC(BIC_CorWatt) && !(do_rapl & RAPL_PER_CORE_ENERGY))\n\t\toutp +=\n\t\t    sprintf(outp, fmt8, (printed++ ? delim : \"\"), p->energy_cores * rapl_energy_units / interval_float);\n\tif (DO_BIC(BIC_GFXWatt))\n\t\toutp +=\n\t\t    sprintf(outp, fmt8, (printed++ ? delim : \"\"), p->energy_gfx * rapl_energy_units / interval_float);\n\tif (DO_BIC(BIC_RAMWatt))\n\t\toutp +=\n\t\t    sprintf(outp, fmt8, (printed++ ? delim : \"\"),\n\t\t\t    p->energy_dram * rapl_dram_energy_units / interval_float);\n\tif (DO_BIC(BIC_Pkg_J))\n\t\toutp += sprintf(outp, fmt8, (printed++ ? delim : \"\"), p->energy_pkg * rapl_energy_units);\n\tif (DO_BIC(BIC_Cor_J) && !(do_rapl & RAPL_PER_CORE_ENERGY))\n\t\toutp += sprintf(outp, fmt8, (printed++ ? delim : \"\"), p->energy_cores * rapl_energy_units);\n\tif (DO_BIC(BIC_GFX_J))\n\t\toutp += sprintf(outp, fmt8, (printed++ ? delim : \"\"), p->energy_gfx * rapl_energy_units);\n\tif (DO_BIC(BIC_RAM_J))\n\t\toutp += sprintf(outp, fmt8, (printed++ ? delim : \"\"), p->energy_dram * rapl_dram_energy_units);\n\tif (DO_BIC(BIC_PKG__))\n\t\toutp +=\n\t\t    sprintf(outp, fmt8, (printed++ ? delim : \"\"),\n\t\t\t    100.0 * p->rapl_pkg_perf_status * rapl_time_units / interval_float);\n\tif (DO_BIC(BIC_RAM__))\n\t\toutp +=\n\t\t    sprintf(outp, fmt8, (printed++ ? delim : \"\"),\n\t\t\t    100.0 * p->rapl_dram_perf_status * rapl_time_units / interval_float);\n\t \n\tif (DO_BIC(BIC_UNCORE_MHZ))\n\t\toutp += sprintf(outp, \"%s%d\", (printed++ ? delim : \"\"), p->uncore_mhz);\n\n\tfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW) {\n\t\t\tif (mp->width == 32)\n\t\t\t\toutp +=\n\t\t\t\t    sprintf(outp, \"%s0x%08x\", (printed++ ? delim : \"\"), (unsigned int)p->counter[i]);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s0x%016llx\", (printed++ ? delim : \"\"), p->counter[i]);\n\t\t} else if (mp->format == FORMAT_DELTA) {\n\t\t\tif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\n\t\t\t\toutp += sprintf(outp, \"%s%8lld\", (printed++ ? delim : \"\"), p->counter[i]);\n\t\t\telse\n\t\t\t\toutp += sprintf(outp, \"%s%lld\", (printed++ ? delim : \"\"), p->counter[i]);\n\t\t} else if (mp->format == FORMAT_PERCENT) {\n\t\t\toutp += sprintf(outp, \"%s%.2f\", (printed++ ? delim : \"\"), 100.0 * p->counter[i] / tsc);\n\t\t}\n\t}\n\ndone:\n\tif (*(outp - 1) != '\\n')\n\t\toutp += sprintf(outp, \"\\n\");\n\n\treturn 0;\n}\n\nvoid flush_output_stdout(void)\n{\n\tFILE *filep;\n\n\tif (outf == stderr)\n\t\tfilep = stdout;\n\telse\n\t\tfilep = outf;\n\n\tfputs(output_buffer, filep);\n\tfflush(filep);\n\n\toutp = output_buffer;\n}\n\nvoid flush_output_stderr(void)\n{\n\tfputs(output_buffer, outf);\n\tfflush(outf);\n\toutp = output_buffer;\n}\n\nvoid format_all_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tstatic int count;\n\n\tif ((!count || (header_iterations && !(count % header_iterations))) || !summary_only)\n\t\tprint_header(\"\\t\");\n\n\tformat_counters(&average.threads, &average.cores, &average.packages);\n\n\tcount++;\n\n\tif (summary_only)\n\t\treturn;\n\n\tfor_all_cpus(format_counters, t, c, p);\n}\n\n#define DELTA_WRAP32(new, old)\t\t\t\\\n\told = ((((unsigned long long)new << 32) - ((unsigned long long)old << 32)) >> 32);\n\nint delta_package(struct pkg_data *new, struct pkg_data *old)\n{\n\tint i;\n\tstruct msr_counter *mp;\n\n\tif (DO_BIC(BIC_Totl_c0))\n\t\told->pkg_wtd_core_c0 = new->pkg_wtd_core_c0 - old->pkg_wtd_core_c0;\n\tif (DO_BIC(BIC_Any_c0))\n\t\told->pkg_any_core_c0 = new->pkg_any_core_c0 - old->pkg_any_core_c0;\n\tif (DO_BIC(BIC_GFX_c0))\n\t\told->pkg_any_gfxe_c0 = new->pkg_any_gfxe_c0 - old->pkg_any_gfxe_c0;\n\tif (DO_BIC(BIC_CPUGFX))\n\t\told->pkg_both_core_gfxe_c0 = new->pkg_both_core_gfxe_c0 - old->pkg_both_core_gfxe_c0;\n\n\told->pc2 = new->pc2 - old->pc2;\n\tif (DO_BIC(BIC_Pkgpc3))\n\t\told->pc3 = new->pc3 - old->pc3;\n\tif (DO_BIC(BIC_Pkgpc6))\n\t\told->pc6 = new->pc6 - old->pc6;\n\tif (DO_BIC(BIC_Pkgpc7))\n\t\told->pc7 = new->pc7 - old->pc7;\n\told->pc8 = new->pc8 - old->pc8;\n\told->pc9 = new->pc9 - old->pc9;\n\told->pc10 = new->pc10 - old->pc10;\n\told->cpu_lpi = new->cpu_lpi - old->cpu_lpi;\n\told->sys_lpi = new->sys_lpi - old->sys_lpi;\n\told->pkg_temp_c = new->pkg_temp_c;\n\n\t \n\tif (old->gfx_rc6_ms > new->gfx_rc6_ms)\n\t\told->gfx_rc6_ms = -1;\n\telse\n\t\told->gfx_rc6_ms = new->gfx_rc6_ms - old->gfx_rc6_ms;\n\n\told->uncore_mhz = new->uncore_mhz;\n\told->gfx_mhz = new->gfx_mhz;\n\told->gfx_act_mhz = new->gfx_act_mhz;\n\n\told->energy_pkg = new->energy_pkg - old->energy_pkg;\n\told->energy_cores = new->energy_cores - old->energy_cores;\n\told->energy_gfx = new->energy_gfx - old->energy_gfx;\n\told->energy_dram = new->energy_dram - old->energy_dram;\n\told->rapl_pkg_perf_status = new->rapl_pkg_perf_status - old->rapl_pkg_perf_status;\n\told->rapl_dram_perf_status = new->rapl_dram_perf_status - old->rapl_dram_perf_status;\n\n\tfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW)\n\t\t\told->counter[i] = new->counter[i];\n\t\telse\n\t\t\told->counter[i] = new->counter[i] - old->counter[i];\n\t}\n\n\treturn 0;\n}\n\nvoid delta_core(struct core_data *new, struct core_data *old)\n{\n\tint i;\n\tstruct msr_counter *mp;\n\n\told->c3 = new->c3 - old->c3;\n\told->c6 = new->c6 - old->c6;\n\told->c7 = new->c7 - old->c7;\n\told->core_temp_c = new->core_temp_c;\n\told->core_throt_cnt = new->core_throt_cnt;\n\told->mc6_us = new->mc6_us - old->mc6_us;\n\n\tDELTA_WRAP32(new->core_energy, old->core_energy);\n\n\tfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW)\n\t\t\told->counter[i] = new->counter[i];\n\t\telse\n\t\t\told->counter[i] = new->counter[i] - old->counter[i];\n\t}\n}\n\nint soft_c1_residency_display(int bic)\n{\n\tif (!DO_BIC(BIC_CPU_c1) || use_c1_residency_msr)\n\t\treturn 0;\n\n\treturn DO_BIC_READ(bic);\n}\n\n \nint delta_thread(struct thread_data *new, struct thread_data *old, struct core_data *core_delta)\n{\n\tint i;\n\tstruct msr_counter *mp;\n\n\t \n\tif (DO_BIC(BIC_APIC))\n\t\tnew->apic_id = old->apic_id;\n\tif (DO_BIC(BIC_X2APIC))\n\t\tnew->x2apic_id = old->x2apic_id;\n\n\t \n\n\ttimersub(&new->tv_begin, &old->tv_begin, &old->tv_delta);\n\told->tv_begin = new->tv_begin;\n\told->tv_end = new->tv_end;\n\n\told->tsc = new->tsc - old->tsc;\n\n\t \n\tif (old->tsc < (1000 * 1000))\n\t\terrx(-3, \"Insanely slow TSC rate, TSC stops in idle?\\n\"\n\t\t     \"You can disable all c-states by booting with \\\"idle=poll\\\"\\n\"\n\t\t     \"or just the deep ones with \\\"processor.max_cstate=1\\\"\");\n\n\told->c1 = new->c1 - old->c1;\n\n\tif (DO_BIC(BIC_Avg_MHz) || DO_BIC(BIC_Busy) || DO_BIC(BIC_Bzy_MHz) || soft_c1_residency_display(BIC_Avg_MHz)) {\n\t\tif ((new->aperf > old->aperf) && (new->mperf > old->mperf)) {\n\t\t\told->aperf = new->aperf - old->aperf;\n\t\t\told->mperf = new->mperf - old->mperf;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (use_c1_residency_msr) {\n\t\t \n\t} else {\n\t\t \n\t\tif ((old->mperf + core_delta->c3 + core_delta->c6 + core_delta->c7) > (old->tsc * tsc_tweak))\n\t\t\told->c1 = 0;\n\t\telse {\n\t\t\t \n\t\t\told->c1 = (old->tsc * tsc_tweak) - old->mperf - core_delta->c3\n\t\t\t    - core_delta->c6 - core_delta->c7;\n\t\t}\n\t}\n\n\tif (old->mperf == 0) {\n\t\tif (debug > 1)\n\t\t\tfprintf(outf, \"cpu%d MPERF 0!\\n\", old->cpu_id);\n\t\told->mperf = 1;\t \n\t}\n\n\tif (DO_BIC(BIC_IPC))\n\t\told->instr_count = new->instr_count - old->instr_count;\n\n\tif (DO_BIC(BIC_IRQ))\n\t\told->irq_count = new->irq_count - old->irq_count;\n\n\tif (DO_BIC(BIC_SMI))\n\t\told->smi_count = new->smi_count - old->smi_count;\n\n\tfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW)\n\t\t\told->counter[i] = new->counter[i];\n\t\telse\n\t\t\told->counter[i] = new->counter[i] - old->counter[i];\n\t}\n\treturn 0;\n}\n\nint delta_cpu(struct thread_data *t, struct core_data *c,\n\t      struct pkg_data *p, struct thread_data *t2, struct core_data *c2, struct pkg_data *p2)\n{\n\tint retval = 0;\n\n\t \n\tif (t->flags & CPU_IS_FIRST_THREAD_IN_CORE)\n\t\tdelta_core(c, c2);\n\n\t \n\tretval = delta_thread(t, t2, c2);\t \n\tif (retval)\n\t\treturn retval;\n\n\t \n\tif (t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE)\n\t\tretval = delta_package(p, p2);\n\n\treturn retval;\n}\n\nvoid clear_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint i;\n\tstruct msr_counter *mp;\n\n\tt->tv_begin.tv_sec = 0;\n\tt->tv_begin.tv_usec = 0;\n\tt->tv_end.tv_sec = 0;\n\tt->tv_end.tv_usec = 0;\n\tt->tv_delta.tv_sec = 0;\n\tt->tv_delta.tv_usec = 0;\n\n\tt->tsc = 0;\n\tt->aperf = 0;\n\tt->mperf = 0;\n\tt->c1 = 0;\n\n\tt->instr_count = 0;\n\n\tt->irq_count = 0;\n\tt->smi_count = 0;\n\n\t \n\tt->flags = CPU_IS_FIRST_THREAD_IN_CORE | CPU_IS_FIRST_CORE_IN_PACKAGE;\n\n\tc->c3 = 0;\n\tc->c6 = 0;\n\tc->c7 = 0;\n\tc->mc6_us = 0;\n\tc->core_temp_c = 0;\n\tc->core_energy = 0;\n\tc->core_throt_cnt = 0;\n\n\tp->pkg_wtd_core_c0 = 0;\n\tp->pkg_any_core_c0 = 0;\n\tp->pkg_any_gfxe_c0 = 0;\n\tp->pkg_both_core_gfxe_c0 = 0;\n\n\tp->pc2 = 0;\n\tif (DO_BIC(BIC_Pkgpc3))\n\t\tp->pc3 = 0;\n\tif (DO_BIC(BIC_Pkgpc6))\n\t\tp->pc6 = 0;\n\tif (DO_BIC(BIC_Pkgpc7))\n\t\tp->pc7 = 0;\n\tp->pc8 = 0;\n\tp->pc9 = 0;\n\tp->pc10 = 0;\n\tp->cpu_lpi = 0;\n\tp->sys_lpi = 0;\n\n\tp->energy_pkg = 0;\n\tp->energy_dram = 0;\n\tp->energy_cores = 0;\n\tp->energy_gfx = 0;\n\tp->rapl_pkg_perf_status = 0;\n\tp->rapl_dram_perf_status = 0;\n\tp->pkg_temp_c = 0;\n\n\tp->gfx_rc6_ms = 0;\n\tp->uncore_mhz = 0;\n\tp->gfx_mhz = 0;\n\tp->gfx_act_mhz = 0;\n\tfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next)\n\t\tt->counter[i] = 0;\n\n\tfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next)\n\t\tc->counter[i] = 0;\n\n\tfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next)\n\t\tp->counter[i] = 0;\n}\n\nint sum_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint i;\n\tstruct msr_counter *mp;\n\n\t \n\tif (DO_BIC(BIC_APIC))\n\t\taverage.threads.apic_id = t->apic_id;\n\tif (DO_BIC(BIC_X2APIC))\n\t\taverage.threads.x2apic_id = t->x2apic_id;\n\n\t \n\tif (average.threads.tv_begin.tv_sec == 0)\n\t\taverage.threads.tv_begin = t->tv_begin;\n\n\t \n\taverage.threads.tv_end = t->tv_end;\n\n\taverage.threads.tsc += t->tsc;\n\taverage.threads.aperf += t->aperf;\n\taverage.threads.mperf += t->mperf;\n\taverage.threads.c1 += t->c1;\n\n\taverage.threads.instr_count += t->instr_count;\n\n\taverage.threads.irq_count += t->irq_count;\n\taverage.threads.smi_count += t->smi_count;\n\n\tfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW)\n\t\t\tcontinue;\n\t\taverage.threads.counter[i] += t->counter[i];\n\t}\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\n\t\treturn 0;\n\n\taverage.cores.c3 += c->c3;\n\taverage.cores.c6 += c->c6;\n\taverage.cores.c7 += c->c7;\n\taverage.cores.mc6_us += c->mc6_us;\n\n\taverage.cores.core_temp_c = MAX(average.cores.core_temp_c, c->core_temp_c);\n\taverage.cores.core_throt_cnt = MAX(average.cores.core_throt_cnt, c->core_throt_cnt);\n\n\taverage.cores.core_energy += c->core_energy;\n\n\tfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW)\n\t\t\tcontinue;\n\t\taverage.cores.counter[i] += c->counter[i];\n\t}\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tif (DO_BIC(BIC_Totl_c0))\n\t\taverage.packages.pkg_wtd_core_c0 += p->pkg_wtd_core_c0;\n\tif (DO_BIC(BIC_Any_c0))\n\t\taverage.packages.pkg_any_core_c0 += p->pkg_any_core_c0;\n\tif (DO_BIC(BIC_GFX_c0))\n\t\taverage.packages.pkg_any_gfxe_c0 += p->pkg_any_gfxe_c0;\n\tif (DO_BIC(BIC_CPUGFX))\n\t\taverage.packages.pkg_both_core_gfxe_c0 += p->pkg_both_core_gfxe_c0;\n\n\taverage.packages.pc2 += p->pc2;\n\tif (DO_BIC(BIC_Pkgpc3))\n\t\taverage.packages.pc3 += p->pc3;\n\tif (DO_BIC(BIC_Pkgpc6))\n\t\taverage.packages.pc6 += p->pc6;\n\tif (DO_BIC(BIC_Pkgpc7))\n\t\taverage.packages.pc7 += p->pc7;\n\taverage.packages.pc8 += p->pc8;\n\taverage.packages.pc9 += p->pc9;\n\taverage.packages.pc10 += p->pc10;\n\n\taverage.packages.cpu_lpi = p->cpu_lpi;\n\taverage.packages.sys_lpi = p->sys_lpi;\n\n\taverage.packages.energy_pkg += p->energy_pkg;\n\taverage.packages.energy_dram += p->energy_dram;\n\taverage.packages.energy_cores += p->energy_cores;\n\taverage.packages.energy_gfx += p->energy_gfx;\n\n\taverage.packages.gfx_rc6_ms = p->gfx_rc6_ms;\n\taverage.packages.uncore_mhz = p->uncore_mhz;\n\taverage.packages.gfx_mhz = p->gfx_mhz;\n\taverage.packages.gfx_act_mhz = p->gfx_act_mhz;\n\n\taverage.packages.pkg_temp_c = MAX(average.packages.pkg_temp_c, p->pkg_temp_c);\n\n\taverage.packages.rapl_pkg_perf_status += p->rapl_pkg_perf_status;\n\taverage.packages.rapl_dram_perf_status += p->rapl_dram_perf_status;\n\n\tfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW)\n\t\t\tcontinue;\n\t\taverage.packages.counter[i] += p->counter[i];\n\t}\n\treturn 0;\n}\n\n \nvoid compute_average(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint i;\n\tstruct msr_counter *mp;\n\n\tclear_counters(&average.threads, &average.cores, &average.packages);\n\n\tfor_all_cpus(sum_counters, t, c, p);\n\n\t \n\taverage.threads.tv_delta = tv_delta;\n\n\taverage.threads.tsc /= topo.num_cpus;\n\taverage.threads.aperf /= topo.num_cpus;\n\taverage.threads.mperf /= topo.num_cpus;\n\taverage.threads.instr_count /= topo.num_cpus;\n\taverage.threads.c1 /= topo.num_cpus;\n\n\tif (average.threads.irq_count > 9999999)\n\t\tsums_need_wide_columns = 1;\n\n\taverage.cores.c3 /= topo.num_cores;\n\taverage.cores.c6 /= topo.num_cores;\n\taverage.cores.c7 /= topo.num_cores;\n\taverage.cores.mc6_us /= topo.num_cores;\n\n\tif (DO_BIC(BIC_Totl_c0))\n\t\taverage.packages.pkg_wtd_core_c0 /= topo.num_packages;\n\tif (DO_BIC(BIC_Any_c0))\n\t\taverage.packages.pkg_any_core_c0 /= topo.num_packages;\n\tif (DO_BIC(BIC_GFX_c0))\n\t\taverage.packages.pkg_any_gfxe_c0 /= topo.num_packages;\n\tif (DO_BIC(BIC_CPUGFX))\n\t\taverage.packages.pkg_both_core_gfxe_c0 /= topo.num_packages;\n\n\taverage.packages.pc2 /= topo.num_packages;\n\tif (DO_BIC(BIC_Pkgpc3))\n\t\taverage.packages.pc3 /= topo.num_packages;\n\tif (DO_BIC(BIC_Pkgpc6))\n\t\taverage.packages.pc6 /= topo.num_packages;\n\tif (DO_BIC(BIC_Pkgpc7))\n\t\taverage.packages.pc7 /= topo.num_packages;\n\n\taverage.packages.pc8 /= topo.num_packages;\n\taverage.packages.pc9 /= topo.num_packages;\n\taverage.packages.pc10 /= topo.num_packages;\n\n\tfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW)\n\t\t\tcontinue;\n\t\tif (mp->type == COUNTER_ITEMS) {\n\t\t\tif (average.threads.counter[i] > 9999999)\n\t\t\t\tsums_need_wide_columns = 1;\n\t\t\tcontinue;\n\t\t}\n\t\taverage.threads.counter[i] /= topo.num_cpus;\n\t}\n\tfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW)\n\t\t\tcontinue;\n\t\tif (mp->type == COUNTER_ITEMS) {\n\t\t\tif (average.cores.counter[i] > 9999999)\n\t\t\t\tsums_need_wide_columns = 1;\n\t\t}\n\t\taverage.cores.counter[i] /= topo.num_cores;\n\t}\n\tfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\n\t\tif (mp->format == FORMAT_RAW)\n\t\t\tcontinue;\n\t\tif (mp->type == COUNTER_ITEMS) {\n\t\t\tif (average.packages.counter[i] > 9999999)\n\t\t\t\tsums_need_wide_columns = 1;\n\t\t}\n\t\taverage.packages.counter[i] /= topo.num_packages;\n\t}\n}\n\nstatic unsigned long long rdtsc(void)\n{\n\tunsigned int low, high;\n\n\tasm volatile (\"rdtsc\":\"=a\" (low), \"=d\"(high));\n\n\treturn low | ((unsigned long long)high) << 32;\n}\n\n \nFILE *fopen_or_die(const char *path, const char *mode)\n{\n\tFILE *filep = fopen(path, mode);\n\n\tif (!filep)\n\t\terr(1, \"%s: open failed\", path);\n\treturn filep;\n}\n\n \nunsigned long long snapshot_sysfs_counter(char *path)\n{\n\tFILE *fp;\n\tint retval;\n\tunsigned long long counter;\n\n\tfp = fopen_or_die(path, \"r\");\n\n\tretval = fscanf(fp, \"%lld\", &counter);\n\tif (retval != 1)\n\t\terr(1, \"snapshot_sysfs_counter(%s)\", path);\n\n\tfclose(fp);\n\n\treturn counter;\n}\n\nint get_mp(int cpu, struct msr_counter *mp, unsigned long long *counterp)\n{\n\tif (mp->msr_num != 0) {\n\t\tif (get_msr(cpu, mp->msr_num, counterp))\n\t\t\treturn -1;\n\t} else {\n\t\tchar path[128 + PATH_BYTES];\n\n\t\tif (mp->flags & SYSFS_PERCPU) {\n\t\t\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/%s\", cpu, mp->path);\n\n\t\t\t*counterp = snapshot_sysfs_counter(path);\n\t\t} else {\n\t\t\t*counterp = snapshot_sysfs_counter(mp->path);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nunsigned long long get_uncore_mhz(int package, int die)\n{\n\tchar path[128];\n\n\tsprintf(path, \"/sys/devices/system/cpu/intel_uncore_frequency/package_0%d_die_0%d/current_freq_khz\", package,\n\t\tdie);\n\n\treturn (snapshot_sysfs_counter(path) / 1000);\n}\n\nint get_epb(int cpu)\n{\n\tchar path[128 + PATH_BYTES];\n\tunsigned long long msr;\n\tint ret, epb = -1;\n\tFILE *fp;\n\n\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/power/energy_perf_bias\", cpu);\n\n\tfp = fopen(path, \"r\");\n\tif (!fp)\n\t\tgoto msr_fallback;\n\n\tret = fscanf(fp, \"%d\", &epb);\n\tif (ret != 1)\n\t\terr(1, \"%s(%s)\", __func__, path);\n\n\tfclose(fp);\n\n\treturn epb;\n\nmsr_fallback:\n\tget_msr(cpu, MSR_IA32_ENERGY_PERF_BIAS, &msr);\n\n\treturn msr & 0xf;\n}\n\nvoid get_apic_id(struct thread_data *t)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\tif (DO_BIC(BIC_APIC)) {\n\t\teax = ebx = ecx = edx = 0;\n\t\t__cpuid(1, eax, ebx, ecx, edx);\n\n\t\tt->apic_id = (ebx >> 24) & 0xff;\n\t}\n\n\tif (!DO_BIC(BIC_X2APIC))\n\t\treturn;\n\n\tif (authentic_amd || hygon_genuine) {\n\t\tunsigned int topology_extensions;\n\n\t\tif (max_extended_level < 0x8000001e)\n\t\t\treturn;\n\n\t\teax = ebx = ecx = edx = 0;\n\t\t__cpuid(0x80000001, eax, ebx, ecx, edx);\n\t\ttopology_extensions = ecx & (1 << 22);\n\n\t\tif (topology_extensions == 0)\n\t\t\treturn;\n\n\t\teax = ebx = ecx = edx = 0;\n\t\t__cpuid(0x8000001e, eax, ebx, ecx, edx);\n\n\t\tt->x2apic_id = eax;\n\t\treturn;\n\t}\n\n\tif (!genuine_intel)\n\t\treturn;\n\n\tif (max_level < 0xb)\n\t\treturn;\n\n\tecx = 0;\n\t__cpuid(0xb, eax, ebx, ecx, edx);\n\tt->x2apic_id = edx;\n\n\tif (debug && (t->apic_id != (t->x2apic_id & 0xff)))\n\t\tfprintf(outf, \"cpu%d: BIOS BUG: apic 0x%x x2apic 0x%x\\n\", t->cpu_id, t->apic_id, t->x2apic_id);\n}\n\nint get_core_throt_cnt(int cpu, unsigned long long *cnt)\n{\n\tchar path[128 + PATH_BYTES];\n\tunsigned long long tmp;\n\tFILE *fp;\n\tint ret;\n\n\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/thermal_throttle/core_throttle_count\", cpu);\n\tfp = fopen(path, \"r\");\n\tif (!fp)\n\t\treturn -1;\n\tret = fscanf(fp, \"%lld\", &tmp);\n\tfclose(fp);\n\tif (ret != 1)\n\t\treturn -1;\n\t*cnt = tmp;\n\n\treturn 0;\n}\n\n \nint get_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint cpu = t->cpu_id;\n\tunsigned long long msr;\n\tint aperf_mperf_retry_count = 0;\n\tstruct msr_counter *mp;\n\tint i;\n\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(outf, \"get_counters: Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tgettimeofday(&t->tv_begin, (struct timezone *)NULL);\n\n\tif (first_counter_read)\n\t\tget_apic_id(t);\nretry:\n\tt->tsc = rdtsc();\t \n\n\tif (DO_BIC(BIC_Avg_MHz) || DO_BIC(BIC_Busy) || DO_BIC(BIC_Bzy_MHz) || soft_c1_residency_display(BIC_Avg_MHz)) {\n\t\tunsigned long long tsc_before, tsc_between, tsc_after, aperf_time, mperf_time;\n\n\t\t \n\n\t\t \n\n\t\tif (get_msr(cpu, MSR_IA32_APERF, &t->aperf))\n\t\t\treturn -3;\n\n\t\tt->tsc = rdtsc();\t \n\n\t\ttsc_before = t->tsc;\n\n\t\tif (get_msr(cpu, MSR_IA32_APERF, &t->aperf))\n\t\t\treturn -3;\n\n\t\ttsc_between = rdtsc();\n\n\t\tif (get_msr(cpu, MSR_IA32_MPERF, &t->mperf))\n\t\t\treturn -4;\n\n\t\ttsc_after = rdtsc();\n\n\t\taperf_time = tsc_between - tsc_before;\n\t\tmperf_time = tsc_after - tsc_between;\n\n\t\t \n\t\tif ((aperf_time > (2 * mperf_time)) || (mperf_time > (2 * aperf_time))) {\n\t\t\taperf_mperf_retry_count++;\n\t\t\tif (aperf_mperf_retry_count < 5)\n\t\t\t\tgoto retry;\n\t\t\telse\n\t\t\t\twarnx(\"cpu%d jitter %lld %lld\", cpu, aperf_time, mperf_time);\n\t\t}\n\t\taperf_mperf_retry_count = 0;\n\n\t\tt->aperf = t->aperf * aperf_mperf_multiplier;\n\t\tt->mperf = t->mperf * aperf_mperf_multiplier;\n\t}\n\n\tif (DO_BIC(BIC_IPC))\n\t\tif (read(get_instr_count_fd(cpu), &t->instr_count, sizeof(long long)) != sizeof(long long))\n\t\t\treturn -4;\n\n\tif (DO_BIC(BIC_IRQ))\n\t\tt->irq_count = irqs_per_cpu[cpu];\n\tif (DO_BIC(BIC_SMI)) {\n\t\tif (get_msr(cpu, MSR_SMI_COUNT, &msr))\n\t\t\treturn -5;\n\t\tt->smi_count = msr & 0xFFFFFFFF;\n\t}\n\tif (DO_BIC(BIC_CPU_c1) && use_c1_residency_msr) {\n\t\tif (get_msr(cpu, MSR_CORE_C1_RES, &t->c1))\n\t\t\treturn -6;\n\t}\n\n\tfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\n\t\tif (get_mp(cpu, mp, &t->counter[i]))\n\t\t\treturn -10;\n\t}\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\n\t\tgoto done;\n\n\tif (DO_BIC(BIC_CPU_c3) || soft_c1_residency_display(BIC_CPU_c3)) {\n\t\tif (get_msr(cpu, MSR_CORE_C3_RESIDENCY, &c->c3))\n\t\t\treturn -6;\n\t}\n\n\tif ((DO_BIC(BIC_CPU_c6) || soft_c1_residency_display(BIC_CPU_c6)) && !do_knl_cstates) {\n\t\tif (get_msr(cpu, MSR_CORE_C6_RESIDENCY, &c->c6))\n\t\t\treturn -7;\n\t} else if (do_knl_cstates && soft_c1_residency_display(BIC_CPU_c6)) {\n\t\tif (get_msr(cpu, MSR_KNL_CORE_C6_RESIDENCY, &c->c6))\n\t\t\treturn -7;\n\t}\n\n\tif (DO_BIC(BIC_CPU_c7) || soft_c1_residency_display(BIC_CPU_c7)) {\n\t\tif (get_msr(cpu, MSR_CORE_C7_RESIDENCY, &c->c7))\n\t\t\treturn -8;\n\t\telse if (t->is_atom) {\n\t\t\t \n\t\t\tc->c6 -= c->c7;\n\t\t}\n\t}\n\n\tif (DO_BIC(BIC_Mod_c6))\n\t\tif (get_msr(cpu, MSR_MODULE_C6_RES_MS, &c->mc6_us))\n\t\t\treturn -8;\n\n\tif (DO_BIC(BIC_CoreTmp)) {\n\t\tif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\n\t\t\treturn -9;\n\t\tc->core_temp_c = tj_max - ((msr >> 16) & 0x7F);\n\t}\n\n\tif (DO_BIC(BIC_CORE_THROT_CNT))\n\t\tget_core_throt_cnt(cpu, &c->core_throt_cnt);\n\n\tif (do_rapl & RAPL_AMD_F17H) {\n\t\tif (get_msr(cpu, MSR_CORE_ENERGY_STAT, &msr))\n\t\t\treturn -14;\n\t\tc->core_energy = msr & 0xFFFFFFFF;\n\t}\n\n\tfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\n\t\tif (get_mp(cpu, mp, &c->counter[i]))\n\t\t\treturn -10;\n\t}\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\tgoto done;\n\n\tif (DO_BIC(BIC_Totl_c0)) {\n\t\tif (get_msr(cpu, MSR_PKG_WEIGHTED_CORE_C0_RES, &p->pkg_wtd_core_c0))\n\t\t\treturn -10;\n\t}\n\tif (DO_BIC(BIC_Any_c0)) {\n\t\tif (get_msr(cpu, MSR_PKG_ANY_CORE_C0_RES, &p->pkg_any_core_c0))\n\t\t\treturn -11;\n\t}\n\tif (DO_BIC(BIC_GFX_c0)) {\n\t\tif (get_msr(cpu, MSR_PKG_ANY_GFXE_C0_RES, &p->pkg_any_gfxe_c0))\n\t\t\treturn -12;\n\t}\n\tif (DO_BIC(BIC_CPUGFX)) {\n\t\tif (get_msr(cpu, MSR_PKG_BOTH_CORE_GFXE_C0_RES, &p->pkg_both_core_gfxe_c0))\n\t\t\treturn -13;\n\t}\n\tif (DO_BIC(BIC_Pkgpc3))\n\t\tif (get_msr(cpu, MSR_PKG_C3_RESIDENCY, &p->pc3))\n\t\t\treturn -9;\n\tif (DO_BIC(BIC_Pkgpc6)) {\n\t\tif (do_slm_cstates) {\n\t\t\tif (get_msr(cpu, MSR_ATOM_PKG_C6_RESIDENCY, &p->pc6))\n\t\t\t\treturn -10;\n\t\t} else {\n\t\t\tif (get_msr(cpu, MSR_PKG_C6_RESIDENCY, &p->pc6))\n\t\t\t\treturn -10;\n\t\t}\n\t}\n\n\tif (DO_BIC(BIC_Pkgpc2))\n\t\tif (get_msr(cpu, MSR_PKG_C2_RESIDENCY, &p->pc2))\n\t\t\treturn -11;\n\tif (DO_BIC(BIC_Pkgpc7))\n\t\tif (get_msr(cpu, MSR_PKG_C7_RESIDENCY, &p->pc7))\n\t\t\treturn -12;\n\tif (DO_BIC(BIC_Pkgpc8))\n\t\tif (get_msr(cpu, MSR_PKG_C8_RESIDENCY, &p->pc8))\n\t\t\treturn -13;\n\tif (DO_BIC(BIC_Pkgpc9))\n\t\tif (get_msr(cpu, MSR_PKG_C9_RESIDENCY, &p->pc9))\n\t\t\treturn -13;\n\tif (DO_BIC(BIC_Pkgpc10))\n\t\tif (get_msr(cpu, MSR_PKG_C10_RESIDENCY, &p->pc10))\n\t\t\treturn -13;\n\n\tif (DO_BIC(BIC_CPU_LPI))\n\t\tp->cpu_lpi = cpuidle_cur_cpu_lpi_us;\n\tif (DO_BIC(BIC_SYS_LPI))\n\t\tp->sys_lpi = cpuidle_cur_sys_lpi_us;\n\n\tif (do_rapl & RAPL_PKG) {\n\t\tif (get_msr_sum(cpu, MSR_PKG_ENERGY_STATUS, &msr))\n\t\t\treturn -13;\n\t\tp->energy_pkg = msr;\n\t}\n\tif (do_rapl & RAPL_CORES_ENERGY_STATUS) {\n\t\tif (get_msr_sum(cpu, MSR_PP0_ENERGY_STATUS, &msr))\n\t\t\treturn -14;\n\t\tp->energy_cores = msr;\n\t}\n\tif (do_rapl & RAPL_DRAM) {\n\t\tif (get_msr_sum(cpu, MSR_DRAM_ENERGY_STATUS, &msr))\n\t\t\treturn -15;\n\t\tp->energy_dram = msr;\n\t}\n\tif (do_rapl & RAPL_GFX) {\n\t\tif (get_msr_sum(cpu, MSR_PP1_ENERGY_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->energy_gfx = msr;\n\t}\n\tif (do_rapl & RAPL_PKG_PERF_STATUS) {\n\t\tif (get_msr_sum(cpu, MSR_PKG_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_pkg_perf_status = msr;\n\t}\n\tif (do_rapl & RAPL_DRAM_PERF_STATUS) {\n\t\tif (get_msr_sum(cpu, MSR_DRAM_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_dram_perf_status = msr;\n\t}\n\tif (do_rapl & RAPL_AMD_F17H) {\n\t\tif (get_msr_sum(cpu, MSR_PKG_ENERGY_STAT, &msr))\n\t\t\treturn -13;\n\t\tp->energy_pkg = msr;\n\t}\n\tif (DO_BIC(BIC_PkgTmp)) {\n\t\tif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\n\t\t\treturn -17;\n\t\tp->pkg_temp_c = tj_max - ((msr >> 16) & 0x7F);\n\t}\n\n\tif (DO_BIC(BIC_GFX_rc6))\n\t\tp->gfx_rc6_ms = gfx_cur_rc6_ms;\n\n\t \n\tif (DO_BIC(BIC_UNCORE_MHZ))\n\t\tp->uncore_mhz = get_uncore_mhz(p->package_id, 0);\n\n\tif (DO_BIC(BIC_GFXMHz))\n\t\tp->gfx_mhz = gfx_cur_mhz;\n\n\tif (DO_BIC(BIC_GFXACTMHz))\n\t\tp->gfx_act_mhz = gfx_act_mhz;\n\n\tfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\n\t\tif (get_mp(cpu, mp, &p->counter[i]))\n\t\t\treturn -10;\n\t}\ndone:\n\tgettimeofday(&t->tv_end, (struct timezone *)NULL);\n\n\treturn 0;\n}\n\n \n\n#define PCLUKN 0\t\t \n#define PCLRSV 1\t\t \n#define PCL__0 2\t\t \n#define PCL__1 3\t\t \n#define PCL__2 4\t\t \n#define PCL__3 5\t\t \n#define PCL__4 6\t\t \n#define PCL__6 7\t\t \n#define PCL_6N 8\t\t \n#define PCL_6R 9\t\t \n#define PCL__7 10\t\t \n#define PCL_7S 11\t\t \n#define PCL__8 12\t\t \n#define PCL__9 13\t\t \n#define PCL_10 14\t\t \n#define PCLUNL 15\t\t \n\nint pkg_cstate_limit = PCLUKN;\nchar *pkg_cstate_limit_strings[] = { \"reserved\", \"unknown\", \"pc0\", \"pc1\", \"pc2\",\n\t\"pc3\", \"pc4\", \"pc6\", \"pc6n\", \"pc6r\", \"pc7\", \"pc7s\", \"pc8\", \"pc9\", \"pc10\", \"unlimited\"\n};\n\nint nhm_pkg_cstate_limits[16] =\n    { PCL__0, PCL__1, PCL__3, PCL__6, PCL__7, PCLRSV, PCLRSV, PCLUNL, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV,\n\tPCLRSV, PCLRSV\n};\n\nint snb_pkg_cstate_limits[16] =\n    { PCL__0, PCL__2, PCL_6N, PCL_6R, PCL__7, PCL_7S, PCLRSV, PCLUNL, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV,\n\tPCLRSV, PCLRSV\n};\n\nint hsw_pkg_cstate_limits[16] =\n    { PCL__0, PCL__2, PCL__3, PCL__6, PCL__7, PCL_7S, PCL__8, PCL__9, PCLUNL, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV,\n\tPCLRSV, PCLRSV\n};\n\nint slv_pkg_cstate_limits[16] =\n    { PCL__0, PCL__1, PCLRSV, PCLRSV, PCL__4, PCLRSV, PCL__6, PCL__7, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV,\n\tPCL__6, PCL__7\n};\n\nint amt_pkg_cstate_limits[16] =\n    { PCLUNL, PCL__1, PCL__2, PCLRSV, PCLRSV, PCLRSV, PCL__6, PCL__7, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV,\n\tPCLRSV, PCLRSV\n};\n\nint phi_pkg_cstate_limits[16] =\n    { PCL__0, PCL__2, PCL_6N, PCL_6R, PCLRSV, PCLRSV, PCLRSV, PCLUNL, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV,\n\tPCLRSV, PCLRSV\n};\n\nint glm_pkg_cstate_limits[16] =\n    { PCLUNL, PCL__1, PCL__3, PCL__6, PCL__7, PCL_7S, PCL__8, PCL__9, PCL_10, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV,\n\tPCLRSV, PCLRSV\n};\n\nint skx_pkg_cstate_limits[16] =\n    { PCL__0, PCL__2, PCL_6N, PCL_6R, PCLRSV, PCLRSV, PCLRSV, PCLUNL, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV,\n\tPCLRSV, PCLRSV\n};\n\nint icx_pkg_cstate_limits[16] =\n    { PCL__0, PCL__2, PCL__6, PCL__6, PCLRSV, PCLRSV, PCLRSV, PCLUNL, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV, PCLRSV,\n\tPCLRSV, PCLRSV\n};\n\nstatic void calculate_tsc_tweak()\n{\n\ttsc_tweak = base_hz / tsc_hz;\n}\n\nvoid prewake_cstate_probe(unsigned int family, unsigned int model);\n\nstatic void dump_nhm_platform_info(void)\n{\n\tunsigned long long msr;\n\tunsigned int ratio;\n\n\tget_msr(base_cpu, MSR_PLATFORM_INFO, &msr);\n\n\tfprintf(outf, \"cpu%d: MSR_PLATFORM_INFO: 0x%08llx\\n\", base_cpu, msr);\n\n\tratio = (msr >> 40) & 0xFF;\n\tfprintf(outf, \"%d * %.1f = %.1f MHz max efficiency frequency\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 8) & 0xFF;\n\tfprintf(outf, \"%d * %.1f = %.1f MHz base frequency\\n\", ratio, bclk, ratio * bclk);\n\n\tget_msr(base_cpu, MSR_IA32_POWER_CTL, &msr);\n\tfprintf(outf, \"cpu%d: MSR_IA32_POWER_CTL: 0x%08llx (C1E auto-promotion: %sabled)\\n\",\n\t\tbase_cpu, msr, msr & 0x2 ? \"EN\" : \"DIS\");\n\n\t \n\tif (dis_cstate_prewake)\n\t\tfprintf(outf, \"C-state Pre-wake: %sabled\\n\", msr & 0x40000000 ? \"DIS\" : \"EN\");\n\n\treturn;\n}\n\nstatic void dump_hsw_turbo_ratio_limits(void)\n{\n\tunsigned long long msr;\n\tunsigned int ratio;\n\n\tget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT2, &msr);\n\n\tfprintf(outf, \"cpu%d: MSR_TURBO_RATIO_LIMIT2: 0x%08llx\\n\", base_cpu, msr);\n\n\tratio = (msr >> 8) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 18 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 0) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 17 active cores\\n\", ratio, bclk, ratio * bclk);\n\treturn;\n}\n\nstatic void dump_ivt_turbo_ratio_limits(void)\n{\n\tunsigned long long msr;\n\tunsigned int ratio;\n\n\tget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT1, &msr);\n\n\tfprintf(outf, \"cpu%d: MSR_TURBO_RATIO_LIMIT1: 0x%08llx\\n\", base_cpu, msr);\n\n\tratio = (msr >> 56) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 16 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 48) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 15 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 40) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 14 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 32) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 13 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 24) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 12 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 16) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 11 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 8) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 10 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 0) & 0xFF;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 9 active cores\\n\", ratio, bclk, ratio * bclk);\n\treturn;\n}\n\nint has_turbo_ratio_group_limits(int family, int model)\n{\n\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ATOM_GOLDMONT:\n\tcase INTEL_FAM6_SKYLAKE_X:\n\tcase INTEL_FAM6_ICELAKE_X:\n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\n\tcase INTEL_FAM6_ATOM_GOLDMONT_D:\n\tcase INTEL_FAM6_ATOM_TREMONT_D:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void dump_turbo_ratio_limits(int trl_msr_offset, int family, int model)\n{\n\tunsigned long long msr, core_counts;\n\tint shift;\n\n\tget_msr(base_cpu, trl_msr_offset, &msr);\n\tfprintf(outf, \"cpu%d: MSR_%sTURBO_RATIO_LIMIT: 0x%08llx\\n\",\n\t\tbase_cpu, trl_msr_offset == MSR_SECONDARY_TURBO_RATIO_LIMIT ? \"SECONDARY_\" : \"\", msr);\n\n\tif (has_turbo_ratio_group_limits(family, model)) {\n\t\tget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT1, &core_counts);\n\t\tfprintf(outf, \"cpu%d: MSR_TURBO_RATIO_LIMIT1: 0x%08llx\\n\", base_cpu, core_counts);\n\t} else {\n\t\tcore_counts = 0x0807060504030201;\n\t}\n\n\tfor (shift = 56; shift >= 0; shift -= 8) {\n\t\tunsigned int ratio, group_size;\n\n\t\tratio = (msr >> shift) & 0xFF;\n\t\tgroup_size = (core_counts >> shift) & 0xFF;\n\t\tif (ratio)\n\t\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo %d active cores\\n\",\n\t\t\t\tratio, bclk, ratio * bclk, group_size);\n\t}\n\n\treturn;\n}\n\nstatic void dump_atom_turbo_ratio_limits(void)\n{\n\tunsigned long long msr;\n\tunsigned int ratio;\n\n\tget_msr(base_cpu, MSR_ATOM_CORE_RATIOS, &msr);\n\tfprintf(outf, \"cpu%d: MSR_ATOM_CORE_RATIOS: 0x%08llx\\n\", base_cpu, msr & 0xFFFFFFFF);\n\n\tratio = (msr >> 0) & 0x3F;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz minimum operating frequency\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 8) & 0x3F;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz low frequency mode (LFM)\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 16) & 0x3F;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz base frequency\\n\", ratio, bclk, ratio * bclk);\n\n\tget_msr(base_cpu, MSR_ATOM_CORE_TURBO_RATIOS, &msr);\n\tfprintf(outf, \"cpu%d: MSR_ATOM_CORE_TURBO_RATIOS: 0x%08llx\\n\", base_cpu, msr & 0xFFFFFFFF);\n\n\tratio = (msr >> 24) & 0x3F;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 4 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 16) & 0x3F;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 3 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 8) & 0x3F;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 2 active cores\\n\", ratio, bclk, ratio * bclk);\n\n\tratio = (msr >> 0) & 0x3F;\n\tif (ratio)\n\t\tfprintf(outf, \"%d * %.1f = %.1f MHz max turbo 1 active core\\n\", ratio, bclk, ratio * bclk);\n}\n\nstatic void dump_knl_turbo_ratio_limits(void)\n{\n\tconst unsigned int buckets_no = 7;\n\n\tunsigned long long msr;\n\tint delta_cores, delta_ratio;\n\tint i, b_nr;\n\tunsigned int cores[buckets_no];\n\tunsigned int ratio[buckets_no];\n\n\tget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT, &msr);\n\n\tfprintf(outf, \"cpu%d: MSR_TURBO_RATIO_LIMIT: 0x%08llx\\n\", base_cpu, msr);\n\n\t \n\n\tb_nr = 0;\n\tcores[b_nr] = (msr & 0xFF) >> 1;\n\tratio[b_nr] = (msr >> 8) & 0xFF;\n\n\tfor (i = 16; i < 64; i += 8) {\n\t\tdelta_cores = (msr >> i) & 0x1F;\n\t\tdelta_ratio = (msr >> (i + 5)) & 0x7;\n\n\t\tcores[b_nr + 1] = cores[b_nr] + delta_cores;\n\t\tratio[b_nr + 1] = ratio[b_nr] - delta_ratio;\n\t\tb_nr++;\n\t}\n\n\tfor (i = buckets_no - 1; i >= 0; i--)\n\t\tif (i > 0 ? ratio[i] != ratio[i - 1] : 1)\n\t\t\tfprintf(outf,\n\t\t\t\t\"%d * %.1f = %.1f MHz max turbo %d active cores\\n\",\n\t\t\t\tratio[i], bclk, ratio[i] * bclk, cores[i]);\n}\n\nstatic void dump_nhm_cst_cfg(void)\n{\n\tunsigned long long msr;\n\n\tget_msr(base_cpu, MSR_PKG_CST_CONFIG_CONTROL, &msr);\n\n\tfprintf(outf, \"cpu%d: MSR_PKG_CST_CONFIG_CONTROL: 0x%08llx\", base_cpu, msr);\n\n\tfprintf(outf, \" (%s%s%s%s%slocked, pkg-cstate-limit=%d (%s)\",\n\t\t(msr & SNB_C3_AUTO_UNDEMOTE) ? \"UNdemote-C3, \" : \"\",\n\t\t(msr & SNB_C1_AUTO_UNDEMOTE) ? \"UNdemote-C1, \" : \"\",\n\t\t(msr & NHM_C3_AUTO_DEMOTE) ? \"demote-C3, \" : \"\",\n\t\t(msr & NHM_C1_AUTO_DEMOTE) ? \"demote-C1, \" : \"\",\n\t\t(msr & (1 << 15)) ? \"\" : \"UN\", (unsigned int)msr & 0xF, pkg_cstate_limit_strings[pkg_cstate_limit]);\n\n#define AUTOMATIC_CSTATE_CONVERSION\t\t(1UL << 16)\n\tif (has_automatic_cstate_conversion) {\n\t\tfprintf(outf, \", automatic c-state conversion=%s\", (msr & AUTOMATIC_CSTATE_CONVERSION) ? \"on\" : \"off\");\n\t}\n\n\tfprintf(outf, \")\\n\");\n\n\treturn;\n}\n\nstatic void dump_config_tdp(void)\n{\n\tunsigned long long msr;\n\n\tget_msr(base_cpu, MSR_CONFIG_TDP_NOMINAL, &msr);\n\tfprintf(outf, \"cpu%d: MSR_CONFIG_TDP_NOMINAL: 0x%08llx\", base_cpu, msr);\n\tfprintf(outf, \" (base_ratio=%d)\\n\", (unsigned int)msr & 0xFF);\n\n\tget_msr(base_cpu, MSR_CONFIG_TDP_LEVEL_1, &msr);\n\tfprintf(outf, \"cpu%d: MSR_CONFIG_TDP_LEVEL_1: 0x%08llx (\", base_cpu, msr);\n\tif (msr) {\n\t\tfprintf(outf, \"PKG_MIN_PWR_LVL1=%d \", (unsigned int)(msr >> 48) & 0x7FFF);\n\t\tfprintf(outf, \"PKG_MAX_PWR_LVL1=%d \", (unsigned int)(msr >> 32) & 0x7FFF);\n\t\tfprintf(outf, \"LVL1_RATIO=%d \", (unsigned int)(msr >> 16) & 0xFF);\n\t\tfprintf(outf, \"PKG_TDP_LVL1=%d\", (unsigned int)(msr) & 0x7FFF);\n\t}\n\tfprintf(outf, \")\\n\");\n\n\tget_msr(base_cpu, MSR_CONFIG_TDP_LEVEL_2, &msr);\n\tfprintf(outf, \"cpu%d: MSR_CONFIG_TDP_LEVEL_2: 0x%08llx (\", base_cpu, msr);\n\tif (msr) {\n\t\tfprintf(outf, \"PKG_MIN_PWR_LVL2=%d \", (unsigned int)(msr >> 48) & 0x7FFF);\n\t\tfprintf(outf, \"PKG_MAX_PWR_LVL2=%d \", (unsigned int)(msr >> 32) & 0x7FFF);\n\t\tfprintf(outf, \"LVL2_RATIO=%d \", (unsigned int)(msr >> 16) & 0xFF);\n\t\tfprintf(outf, \"PKG_TDP_LVL2=%d\", (unsigned int)(msr) & 0x7FFF);\n\t}\n\tfprintf(outf, \")\\n\");\n\n\tget_msr(base_cpu, MSR_CONFIG_TDP_CONTROL, &msr);\n\tfprintf(outf, \"cpu%d: MSR_CONFIG_TDP_CONTROL: 0x%08llx (\", base_cpu, msr);\n\tif ((msr) & 0x3)\n\t\tfprintf(outf, \"TDP_LEVEL=%d \", (unsigned int)(msr) & 0x3);\n\tfprintf(outf, \" lock=%d\", (unsigned int)(msr >> 31) & 1);\n\tfprintf(outf, \")\\n\");\n\n\tget_msr(base_cpu, MSR_TURBO_ACTIVATION_RATIO, &msr);\n\tfprintf(outf, \"cpu%d: MSR_TURBO_ACTIVATION_RATIO: 0x%08llx (\", base_cpu, msr);\n\tfprintf(outf, \"MAX_NON_TURBO_RATIO=%d\", (unsigned int)(msr) & 0xFF);\n\tfprintf(outf, \" lock=%d\", (unsigned int)(msr >> 31) & 1);\n\tfprintf(outf, \")\\n\");\n}\n\nunsigned int irtl_time_units[] = { 1, 32, 1024, 32768, 1048576, 33554432, 0, 0 };\n\nvoid print_irtl(void)\n{\n\tunsigned long long msr;\n\n\tget_msr(base_cpu, MSR_PKGC3_IRTL, &msr);\n\tfprintf(outf, \"cpu%d: MSR_PKGC3_IRTL: 0x%08llx (\", base_cpu, msr);\n\tfprintf(outf, \"%svalid, %lld ns)\\n\", msr & (1 << 15) ? \"\" : \"NOT\",\n\t\t(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\n\n\tget_msr(base_cpu, MSR_PKGC6_IRTL, &msr);\n\tfprintf(outf, \"cpu%d: MSR_PKGC6_IRTL: 0x%08llx (\", base_cpu, msr);\n\tfprintf(outf, \"%svalid, %lld ns)\\n\", msr & (1 << 15) ? \"\" : \"NOT\",\n\t\t(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\n\n\tget_msr(base_cpu, MSR_PKGC7_IRTL, &msr);\n\tfprintf(outf, \"cpu%d: MSR_PKGC7_IRTL: 0x%08llx (\", base_cpu, msr);\n\tfprintf(outf, \"%svalid, %lld ns)\\n\", msr & (1 << 15) ? \"\" : \"NOT\",\n\t\t(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\n\n\tif (!do_irtl_hsw)\n\t\treturn;\n\n\tget_msr(base_cpu, MSR_PKGC8_IRTL, &msr);\n\tfprintf(outf, \"cpu%d: MSR_PKGC8_IRTL: 0x%08llx (\", base_cpu, msr);\n\tfprintf(outf, \"%svalid, %lld ns)\\n\", msr & (1 << 15) ? \"\" : \"NOT\",\n\t\t(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\n\n\tget_msr(base_cpu, MSR_PKGC9_IRTL, &msr);\n\tfprintf(outf, \"cpu%d: MSR_PKGC9_IRTL: 0x%08llx (\", base_cpu, msr);\n\tfprintf(outf, \"%svalid, %lld ns)\\n\", msr & (1 << 15) ? \"\" : \"NOT\",\n\t\t(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\n\n\tget_msr(base_cpu, MSR_PKGC10_IRTL, &msr);\n\tfprintf(outf, \"cpu%d: MSR_PKGC10_IRTL: 0x%08llx (\", base_cpu, msr);\n\tfprintf(outf, \"%svalid, %lld ns)\\n\", msr & (1 << 15) ? \"\" : \"NOT\",\n\t\t(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\n\n}\n\nvoid free_fd_percpu(void)\n{\n\tint i;\n\n\tfor (i = 0; i < topo.max_cpu_num + 1; ++i) {\n\t\tif (fd_percpu[i] != 0)\n\t\t\tclose(fd_percpu[i]);\n\t}\n\n\tfree(fd_percpu);\n}\n\nvoid free_all_buffers(void)\n{\n\tint i;\n\n\tCPU_FREE(cpu_present_set);\n\tcpu_present_set = NULL;\n\tcpu_present_setsize = 0;\n\n\tCPU_FREE(cpu_affinity_set);\n\tcpu_affinity_set = NULL;\n\tcpu_affinity_setsize = 0;\n\n\tfree(thread_even);\n\tfree(core_even);\n\tfree(package_even);\n\n\tthread_even = NULL;\n\tcore_even = NULL;\n\tpackage_even = NULL;\n\n\tfree(thread_odd);\n\tfree(core_odd);\n\tfree(package_odd);\n\n\tthread_odd = NULL;\n\tcore_odd = NULL;\n\tpackage_odd = NULL;\n\n\tfree(output_buffer);\n\toutput_buffer = NULL;\n\toutp = NULL;\n\n\tfree_fd_percpu();\n\n\tfree(irq_column_2_cpu);\n\tfree(irqs_per_cpu);\n\n\tfor (i = 0; i <= topo.max_cpu_num; ++i) {\n\t\tif (cpus[i].put_ids)\n\t\t\tCPU_FREE(cpus[i].put_ids);\n\t}\n\tfree(cpus);\n}\n\n \nint parse_int_file(const char *fmt, ...)\n{\n\tva_list args;\n\tchar path[PATH_MAX];\n\tFILE *filep;\n\tint value;\n\n\tva_start(args, fmt);\n\tvsnprintf(path, sizeof(path), fmt, args);\n\tva_end(args);\n\tfilep = fopen(path, \"r\");\n\tif (!filep)\n\t\treturn 0;\n\tif (fscanf(filep, \"%d\", &value) != 1)\n\t\terr(1, \"%s: failed to parse number from file\", path);\n\tfclose(filep);\n\treturn value;\n}\n\n \nint cpu_is_first_core_in_package(int cpu)\n{\n\treturn cpu == parse_int_file(\"/sys/devices/system/cpu/cpu%d/topology/core_siblings_list\", cpu);\n}\n\nint get_physical_package_id(int cpu)\n{\n\treturn parse_int_file(\"/sys/devices/system/cpu/cpu%d/topology/physical_package_id\", cpu);\n}\n\nint get_die_id(int cpu)\n{\n\treturn parse_int_file(\"/sys/devices/system/cpu/cpu%d/topology/die_id\", cpu);\n}\n\nint get_core_id(int cpu)\n{\n\treturn parse_int_file(\"/sys/devices/system/cpu/cpu%d/topology/core_id\", cpu);\n}\n\nvoid set_node_data(void)\n{\n\tint pkg, node, lnode, cpu, cpux;\n\tint cpu_count;\n\n\t \n\tfor (cpu = 0; cpu <= topo.max_cpu_num; ++cpu)\n\t\tcpus[cpu].logical_node_id = -1;\n\n\tcpu_count = 0;\n\tfor (pkg = 0; pkg < topo.num_packages; pkg++) {\n\t\tlnode = 0;\n\t\tfor (cpu = 0; cpu <= topo.max_cpu_num; ++cpu) {\n\t\t\tif (cpus[cpu].physical_package_id != pkg)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (cpus[cpu].logical_node_id != -1)\n\t\t\t\tcontinue;\n\t\t\tcpus[cpu].logical_node_id = lnode;\n\t\t\tnode = cpus[cpu].physical_node_id;\n\t\t\tcpu_count++;\n\t\t\t \n\t\t\tfor (cpux = cpu; cpux <= topo.max_cpu_num; cpux++) {\n\t\t\t\tif ((cpus[cpux].physical_package_id == pkg) && (cpus[cpux].physical_node_id == node)) {\n\t\t\t\t\tcpus[cpux].logical_node_id = lnode;\n\t\t\t\t\tcpu_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlnode++;\n\t\t\tif (lnode > topo.nodes_per_pkg)\n\t\t\t\ttopo.nodes_per_pkg = lnode;\n\t\t}\n\t\tif (cpu_count >= topo.max_cpu_num)\n\t\t\tbreak;\n\t}\n}\n\nint get_physical_node_id(struct cpu_topology *thiscpu)\n{\n\tchar path[80];\n\tFILE *filep;\n\tint i;\n\tint cpu = thiscpu->logical_cpu_id;\n\n\tfor (i = 0; i <= topo.max_cpu_num; i++) {\n\t\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/node%i/cpulist\", cpu, i);\n\t\tfilep = fopen(path, \"r\");\n\t\tif (!filep)\n\t\t\tcontinue;\n\t\tfclose(filep);\n\t\treturn i;\n\t}\n\treturn -1;\n}\n\nint get_thread_siblings(struct cpu_topology *thiscpu)\n{\n\tchar path[80], character;\n\tFILE *filep;\n\tunsigned long map;\n\tint so, shift, sib_core;\n\tint cpu = thiscpu->logical_cpu_id;\n\tint offset = topo.max_cpu_num + 1;\n\tsize_t size;\n\tint thread_id = 0;\n\n\tthiscpu->put_ids = CPU_ALLOC((topo.max_cpu_num + 1));\n\tif (thiscpu->thread_id < 0)\n\t\tthiscpu->thread_id = thread_id++;\n\tif (!thiscpu->put_ids)\n\t\treturn -1;\n\n\tsize = CPU_ALLOC_SIZE((topo.max_cpu_num + 1));\n\tCPU_ZERO_S(size, thiscpu->put_ids);\n\n\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/topology/thread_siblings\", cpu);\n\tfilep = fopen(path, \"r\");\n\n\tif (!filep) {\n\t\twarnx(\"%s: open failed\", path);\n\t\treturn -1;\n\t}\n\tdo {\n\t\toffset -= BITMASK_SIZE;\n\t\tif (fscanf(filep, \"%lx%c\", &map, &character) != 2)\n\t\t\terr(1, \"%s: failed to parse file\", path);\n\t\tfor (shift = 0; shift < BITMASK_SIZE; shift++) {\n\t\t\tif ((map >> shift) & 0x1) {\n\t\t\t\tso = shift + offset;\n\t\t\t\tsib_core = get_core_id(so);\n\t\t\t\tif (sib_core == thiscpu->physical_core_id) {\n\t\t\t\t\tCPU_SET_S(so, size, thiscpu->put_ids);\n\t\t\t\t\tif ((so != cpu) && (cpus[so].thread_id < 0))\n\t\t\t\t\t\tcpus[so].thread_id = thread_id++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (character == ',');\n\tfclose(filep);\n\n\treturn CPU_COUNT_S(size, thiscpu->put_ids);\n}\n\n \n\nint for_all_cpus_2(int (func) (struct thread_data *, struct core_data *,\n\t\t\t       struct pkg_data *, struct thread_data *, struct core_data *,\n\t\t\t       struct pkg_data *), struct thread_data *thread_base,\n\t\t   struct core_data *core_base, struct pkg_data *pkg_base,\n\t\t   struct thread_data *thread_base2, struct core_data *core_base2, struct pkg_data *pkg_base2)\n{\n\tint retval, pkg_no, node_no, core_no, thread_no;\n\n\tfor (pkg_no = 0; pkg_no < topo.num_packages; ++pkg_no) {\n\t\tfor (node_no = 0; node_no < topo.nodes_per_pkg; ++node_no) {\n\t\t\tfor (core_no = 0; core_no < topo.cores_per_node; ++core_no) {\n\t\t\t\tfor (thread_no = 0; thread_no < topo.threads_per_core; ++thread_no) {\n\t\t\t\t\tstruct thread_data *t, *t2;\n\t\t\t\t\tstruct core_data *c, *c2;\n\t\t\t\t\tstruct pkg_data *p, *p2;\n\n\t\t\t\t\tt = GET_THREAD(thread_base, thread_no, core_no, node_no, pkg_no);\n\n\t\t\t\t\tif (cpu_is_not_present(t->cpu_id))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tt2 = GET_THREAD(thread_base2, thread_no, core_no, node_no, pkg_no);\n\n\t\t\t\t\tc = GET_CORE(core_base, core_no, node_no, pkg_no);\n\t\t\t\t\tc2 = GET_CORE(core_base2, core_no, node_no, pkg_no);\n\n\t\t\t\t\tp = GET_PKG(pkg_base, pkg_no);\n\t\t\t\t\tp2 = GET_PKG(pkg_base2, pkg_no);\n\n\t\t\t\t\tretval = func(t, c, p, t2, c2, p2);\n\t\t\t\t\tif (retval)\n\t\t\t\t\t\treturn retval;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint for_all_proc_cpus(int (func) (int))\n{\n\tFILE *fp;\n\tint cpu_num;\n\tint retval;\n\n\tfp = fopen_or_die(proc_stat, \"r\");\n\n\tretval = fscanf(fp, \"cpu %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\\n\");\n\tif (retval != 0)\n\t\terr(1, \"%s: failed to parse format\", proc_stat);\n\n\twhile (1) {\n\t\tretval = fscanf(fp, \"cpu%u %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\\n\", &cpu_num);\n\t\tif (retval != 1)\n\t\t\tbreak;\n\n\t\tretval = func(cpu_num);\n\t\tif (retval) {\n\t\t\tfclose(fp);\n\t\t\treturn (retval);\n\t\t}\n\t}\n\tfclose(fp);\n\treturn 0;\n}\n\nvoid re_initialize(void)\n{\n\tfree_all_buffers();\n\tsetup_all_buffers();\n\tfprintf(outf, \"turbostat: re-initialized with num_cpus %d\\n\", topo.num_cpus);\n}\n\nvoid set_max_cpu_num(void)\n{\n\tFILE *filep;\n\tint base_cpu;\n\tunsigned long dummy;\n\tchar pathname[64];\n\n\tbase_cpu = sched_getcpu();\n\tif (base_cpu < 0)\n\t\terr(1, \"cannot find calling cpu ID\");\n\tsprintf(pathname, \"/sys/devices/system/cpu/cpu%d/topology/thread_siblings\", base_cpu);\n\n\tfilep = fopen_or_die(pathname, \"r\");\n\ttopo.max_cpu_num = 0;\n\twhile (fscanf(filep, \"%lx,\", &dummy) == 1)\n\t\ttopo.max_cpu_num += BITMASK_SIZE;\n\tfclose(filep);\n\ttopo.max_cpu_num--;\t \n}\n\n \nint count_cpus(int cpu)\n{\n\tUNUSED(cpu);\n\n\ttopo.num_cpus++;\n\treturn 0;\n}\n\nint mark_cpu_present(int cpu)\n{\n\tCPU_SET_S(cpu, cpu_present_setsize, cpu_present_set);\n\treturn 0;\n}\n\nint init_thread_id(int cpu)\n{\n\tcpus[cpu].thread_id = -1;\n\treturn 0;\n}\n\n \nint snapshot_proc_interrupts(void)\n{\n\tstatic FILE *fp;\n\tint column, retval;\n\n\tif (fp == NULL)\n\t\tfp = fopen_or_die(\"/proc/interrupts\", \"r\");\n\telse\n\t\trewind(fp);\n\n\t \n\tfor (column = 0; column < topo.num_cpus; ++column) {\n\t\tint cpu_number;\n\n\t\tretval = fscanf(fp, \" CPU%d\", &cpu_number);\n\t\tif (retval != 1)\n\t\t\tbreak;\n\n\t\tif (cpu_number > topo.max_cpu_num) {\n\t\t\twarn(\"/proc/interrupts: cpu%d: > %d\", cpu_number, topo.max_cpu_num);\n\t\t\treturn 1;\n\t\t}\n\n\t\tirq_column_2_cpu[column] = cpu_number;\n\t\tirqs_per_cpu[cpu_number] = 0;\n\t}\n\n\t \n\twhile (1) {\n\t\tint column;\n\t\tchar buf[64];\n\n\t\tretval = fscanf(fp, \" %s:\", buf);\t \n\t\tif (retval != 1)\n\t\t\tbreak;\n\n\t\t \n\t\tfor (column = 0; column < topo.num_cpus; ++column) {\n\n\t\t\tint cpu_number, irq_count;\n\n\t\t\tretval = fscanf(fp, \" %d\", &irq_count);\n\t\t\tif (retval != 1)\n\t\t\t\tbreak;\n\n\t\t\tcpu_number = irq_column_2_cpu[column];\n\t\t\tirqs_per_cpu[cpu_number] += irq_count;\n\n\t\t}\n\n\t\twhile (getc(fp) != '\\n') ;\t \n\n\t}\n\treturn 0;\n}\n\n \nint snapshot_gfx_rc6_ms(void)\n{\n\tFILE *fp;\n\tint retval;\n\n\tfp = fopen_or_die(\"/sys/class/drm/card0/power/rc6_residency_ms\", \"r\");\n\n\tretval = fscanf(fp, \"%lld\", &gfx_cur_rc6_ms);\n\tif (retval != 1)\n\t\terr(1, \"GFX rc6\");\n\n\tfclose(fp);\n\n\treturn 0;\n}\n\n \nint snapshot_gfx_mhz(void)\n{\n\tstatic FILE *fp;\n\tint retval;\n\n\tif (fp == NULL)\n\t\tfp = fopen_or_die(\"/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz\", \"r\");\n\telse {\n\t\trewind(fp);\n\t\tfflush(fp);\n\t}\n\n\tretval = fscanf(fp, \"%d\", &gfx_cur_mhz);\n\tif (retval != 1)\n\t\terr(1, \"GFX MHz\");\n\n\treturn 0;\n}\n\n \nint snapshot_gfx_act_mhz(void)\n{\n\tstatic FILE *fp;\n\tint retval;\n\n\tif (fp == NULL)\n\t\tfp = fopen_or_die(\"/sys/class/graphics/fb0/device/drm/card0/gt_act_freq_mhz\", \"r\");\n\telse {\n\t\trewind(fp);\n\t\tfflush(fp);\n\t}\n\n\tretval = fscanf(fp, \"%d\", &gfx_act_mhz);\n\tif (retval != 1)\n\t\terr(1, \"GFX ACT MHz\");\n\n\treturn 0;\n}\n\n \nint snapshot_cpu_lpi_us(void)\n{\n\tFILE *fp;\n\tint retval;\n\n\tfp = fopen_or_die(\"/sys/devices/system/cpu/cpuidle/low_power_idle_cpu_residency_us\", \"r\");\n\n\tretval = fscanf(fp, \"%lld\", &cpuidle_cur_cpu_lpi_us);\n\tif (retval != 1) {\n\t\tfprintf(stderr, \"Disabling Low Power Idle CPU output\\n\");\n\t\tBIC_NOT_PRESENT(BIC_CPU_LPI);\n\t\tfclose(fp);\n\t\treturn -1;\n\t}\n\n\tfclose(fp);\n\n\treturn 0;\n}\n\n \nint snapshot_sys_lpi_us(void)\n{\n\tFILE *fp;\n\tint retval;\n\n\tfp = fopen_or_die(sys_lpi_file, \"r\");\n\n\tretval = fscanf(fp, \"%lld\", &cpuidle_cur_sys_lpi_us);\n\tif (retval != 1) {\n\t\tfprintf(stderr, \"Disabling Low Power Idle System output\\n\");\n\t\tBIC_NOT_PRESENT(BIC_SYS_LPI);\n\t\tfclose(fp);\n\t\treturn -1;\n\t}\n\tfclose(fp);\n\n\treturn 0;\n}\n\n \nint snapshot_proc_sysfs_files(void)\n{\n\tif (DO_BIC(BIC_IRQ))\n\t\tif (snapshot_proc_interrupts())\n\t\t\treturn 1;\n\n\tif (DO_BIC(BIC_GFX_rc6))\n\t\tsnapshot_gfx_rc6_ms();\n\n\tif (DO_BIC(BIC_GFXMHz))\n\t\tsnapshot_gfx_mhz();\n\n\tif (DO_BIC(BIC_GFXACTMHz))\n\t\tsnapshot_gfx_act_mhz();\n\n\tif (DO_BIC(BIC_CPU_LPI))\n\t\tsnapshot_cpu_lpi_us();\n\n\tif (DO_BIC(BIC_SYS_LPI))\n\t\tsnapshot_sys_lpi_us();\n\n\treturn 0;\n}\n\nint exit_requested;\n\nstatic void signal_handler(int signal)\n{\n\tswitch (signal) {\n\tcase SIGINT:\n\t\texit_requested = 1;\n\t\tif (debug)\n\t\t\tfprintf(stderr, \" SIGINT\\n\");\n\t\tbreak;\n\tcase SIGUSR1:\n\t\tif (debug > 1)\n\t\t\tfprintf(stderr, \"SIGUSR1\\n\");\n\t\tbreak;\n\t}\n}\n\nvoid setup_signal_handler(void)\n{\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\n\tsa.sa_handler = &signal_handler;\n\n\tif (sigaction(SIGINT, &sa, NULL) < 0)\n\t\terr(1, \"sigaction SIGINT\");\n\tif (sigaction(SIGUSR1, &sa, NULL) < 0)\n\t\terr(1, \"sigaction SIGUSR1\");\n}\n\nvoid do_sleep(void)\n{\n\tstruct timeval tout;\n\tstruct timespec rest;\n\tfd_set readfds;\n\tint retval;\n\n\tFD_ZERO(&readfds);\n\tFD_SET(0, &readfds);\n\n\tif (ignore_stdin) {\n\t\tnanosleep(&interval_ts, NULL);\n\t\treturn;\n\t}\n\n\ttout = interval_tv;\n\tretval = select(1, &readfds, NULL, NULL, &tout);\n\n\tif (retval == 1) {\n\t\tswitch (getc(stdin)) {\n\t\tcase 'q':\n\t\t\texit_requested = 1;\n\t\t\tbreak;\n\t\tcase EOF:\n\t\t\t \n\t\t\tignore_stdin = 1;\n\t\t\t \n\t\t\trest.tv_sec = (tout.tv_sec + tout.tv_usec / 1000000);\n\t\t\trest.tv_nsec = (tout.tv_usec % 1000000) * 1000;\n\t\t\tnanosleep(&rest, NULL);\n\t\t}\n\t}\n}\n\nint get_msr_sum(int cpu, off_t offset, unsigned long long *msr)\n{\n\tint ret, idx;\n\tunsigned long long msr_cur, msr_last;\n\n\tif (!per_cpu_msr_sum)\n\t\treturn 1;\n\n\tidx = offset_to_idx(offset);\n\tif (idx < 0)\n\t\treturn idx;\n\t \n\tret = get_msr(cpu, offset, &msr_cur);\n\tif (ret)\n\t\treturn ret;\n\tmsr_last = per_cpu_msr_sum[cpu].entries[idx].last;\n\tDELTA_WRAP32(msr_cur, msr_last);\n\t*msr = msr_last + per_cpu_msr_sum[cpu].entries[idx].sum;\n\n\treturn 0;\n}\n\ntimer_t timerid;\n\n \nstatic int update_msr_sum(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint i, ret;\n\tint cpu = t->cpu_id;\n\n\tUNUSED(c);\n\tUNUSED(p);\n\n\tfor (i = IDX_PKG_ENERGY; i < IDX_COUNT; i++) {\n\t\tunsigned long long msr_cur, msr_last;\n\t\toff_t offset;\n\n\t\tif (!idx_valid(i))\n\t\t\tcontinue;\n\t\toffset = idx_to_offset(i);\n\t\tif (offset < 0)\n\t\t\tcontinue;\n\t\tret = get_msr(cpu, offset, &msr_cur);\n\t\tif (ret) {\n\t\t\tfprintf(outf, \"Can not update msr(0x%llx)\\n\", (unsigned long long)offset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmsr_last = per_cpu_msr_sum[cpu].entries[i].last;\n\t\tper_cpu_msr_sum[cpu].entries[i].last = msr_cur & 0xffffffff;\n\n\t\tDELTA_WRAP32(msr_cur, msr_last);\n\t\tper_cpu_msr_sum[cpu].entries[i].sum += msr_last;\n\t}\n\treturn 0;\n}\n\nstatic void msr_record_handler(union sigval v)\n{\n\tUNUSED(v);\n\n\tfor_all_cpus(update_msr_sum, EVEN_COUNTERS);\n}\n\nvoid msr_sum_record(void)\n{\n\tstruct itimerspec its;\n\tstruct sigevent sev;\n\n\tper_cpu_msr_sum = calloc(topo.max_cpu_num + 1, sizeof(struct msr_sum_array));\n\tif (!per_cpu_msr_sum) {\n\t\tfprintf(outf, \"Can not allocate memory for long time MSR.\\n\");\n\t\treturn;\n\t}\n\t \n\tmemset(&sev, 0, sizeof(struct sigevent));\n\tsev.sigev_notify = SIGEV_THREAD;\n\tsev.sigev_notify_function = msr_record_handler;\n\n\tsev.sigev_value.sival_ptr = &timerid;\n\tif (timer_create(CLOCK_REALTIME, &sev, &timerid) == -1) {\n\t\tfprintf(outf, \"Can not create timer.\\n\");\n\t\tgoto release_msr;\n\t}\n\n\tits.it_value.tv_sec = 0;\n\tits.it_value.tv_nsec = 1;\n\t \n\tits.it_interval.tv_sec = rapl_joule_counter_range / 2;\n\tits.it_interval.tv_nsec = 0;\n\n\tif (timer_settime(timerid, 0, &its, NULL) == -1) {\n\t\tfprintf(outf, \"Can not set timer.\\n\");\n\t\tgoto release_timer;\n\t}\n\treturn;\n\nrelease_timer:\n\ttimer_delete(timerid);\nrelease_msr:\n\tfree(per_cpu_msr_sum);\n}\n\n \nint set_my_sched_priority(int priority)\n{\n\tint retval;\n\tint original_priority;\n\n\terrno = 0;\n\toriginal_priority = getpriority(PRIO_PROCESS, 0);\n\tif (errno && (original_priority == -1))\n\t\terr(errno, \"getpriority\");\n\n\tretval = setpriority(PRIO_PROCESS, 0, priority);\n\tif (retval)\n\t\terrx(retval, \"capget(CAP_SYS_NICE) failed,try \\\"# setcap cap_sys_nice=ep %s\\\"\", progname);\n\n\terrno = 0;\n\tretval = getpriority(PRIO_PROCESS, 0);\n\tif (retval != priority)\n\t\terr(retval, \"getpriority(%d) != setpriority(%d)\", retval, priority);\n\n\treturn original_priority;\n}\n\nvoid turbostat_loop()\n{\n\tint retval;\n\tint restarted = 0;\n\tunsigned int done_iters = 0;\n\n\tsetup_signal_handler();\n\n\t \n\tset_my_sched_priority(-20);\n\nrestart:\n\trestarted++;\n\n\tsnapshot_proc_sysfs_files();\n\tretval = for_all_cpus(get_counters, EVEN_COUNTERS);\n\tfirst_counter_read = 0;\n\tif (retval < -1) {\n\t\texit(retval);\n\t} else if (retval == -1) {\n\t\tif (restarted > 10) {\n\t\t\texit(retval);\n\t\t}\n\t\tre_initialize();\n\t\tgoto restart;\n\t}\n\trestarted = 0;\n\tdone_iters = 0;\n\tgettimeofday(&tv_even, (struct timezone *)NULL);\n\n\twhile (1) {\n\t\tif (for_all_proc_cpus(cpu_is_not_present)) {\n\t\t\tre_initialize();\n\t\t\tgoto restart;\n\t\t}\n\t\tdo_sleep();\n\t\tif (snapshot_proc_sysfs_files())\n\t\t\tgoto restart;\n\t\tretval = for_all_cpus(get_counters, ODD_COUNTERS);\n\t\tif (retval < -1) {\n\t\t\texit(retval);\n\t\t} else if (retval == -1) {\n\t\t\tre_initialize();\n\t\t\tgoto restart;\n\t\t}\n\t\tgettimeofday(&tv_odd, (struct timezone *)NULL);\n\t\ttimersub(&tv_odd, &tv_even, &tv_delta);\n\t\tif (for_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS)) {\n\t\t\tre_initialize();\n\t\t\tgoto restart;\n\t\t}\n\t\tcompute_average(EVEN_COUNTERS);\n\t\tformat_all_counters(EVEN_COUNTERS);\n\t\tflush_output_stdout();\n\t\tif (exit_requested)\n\t\t\tbreak;\n\t\tif (num_iterations && ++done_iters >= num_iterations)\n\t\t\tbreak;\n\t\tdo_sleep();\n\t\tif (snapshot_proc_sysfs_files())\n\t\t\tgoto restart;\n\t\tretval = for_all_cpus(get_counters, EVEN_COUNTERS);\n\t\tif (retval < -1) {\n\t\t\texit(retval);\n\t\t} else if (retval == -1) {\n\t\t\tre_initialize();\n\t\t\tgoto restart;\n\t\t}\n\t\tgettimeofday(&tv_even, (struct timezone *)NULL);\n\t\ttimersub(&tv_even, &tv_odd, &tv_delta);\n\t\tif (for_all_cpus_2(delta_cpu, EVEN_COUNTERS, ODD_COUNTERS)) {\n\t\t\tre_initialize();\n\t\t\tgoto restart;\n\t\t}\n\t\tcompute_average(ODD_COUNTERS);\n\t\tformat_all_counters(ODD_COUNTERS);\n\t\tflush_output_stdout();\n\t\tif (exit_requested)\n\t\t\tbreak;\n\t\tif (num_iterations && ++done_iters >= num_iterations)\n\t\t\tbreak;\n\t}\n}\n\nvoid check_dev_msr()\n{\n\tstruct stat sb;\n\tchar pathname[32];\n\n\tsprintf(pathname, \"/dev/cpu/%d/msr\", base_cpu);\n\tif (stat(pathname, &sb))\n\t\tif (system(\"/sbin/modprobe msr > /dev/null 2>&1\"))\n\t\t\terr(-5, \"no /dev/cpu/0/msr, Try \\\"# modprobe msr\\\" \");\n}\n\n \nint check_for_cap_sys_rawio(void)\n{\n\tcap_t caps;\n\tcap_flag_value_t cap_flag_value;\n\n\tcaps = cap_get_proc();\n\tif (caps == NULL)\n\t\terr(-6, \"cap_get_proc\\n\");\n\n\tif (cap_get_flag(caps, CAP_SYS_RAWIO, CAP_EFFECTIVE, &cap_flag_value))\n\t\terr(-6, \"cap_get\\n\");\n\n\tif (cap_flag_value != CAP_SET) {\n\t\twarnx(\"capget(CAP_SYS_RAWIO) failed,\" \" try \\\"# setcap cap_sys_rawio=ep %s\\\"\", progname);\n\t\treturn 1;\n\t}\n\n\tif (cap_free(caps) == -1)\n\t\terr(-6, \"cap_free\\n\");\n\n\treturn 0;\n}\n\nvoid check_permissions(void)\n{\n\tint do_exit = 0;\n\tchar pathname[32];\n\n\t \n\tdo_exit += check_for_cap_sys_rawio();\n\n\t \n\tsprintf(pathname, \"/dev/cpu/%d/msr\", base_cpu);\n\tif (euidaccess(pathname, R_OK)) {\n\t\tdo_exit++;\n\t\twarn(\"/dev/cpu/0/msr open failed, try chown or chmod +r /dev/cpu/*/msr\");\n\t}\n\n\t \n\tif (do_exit)\n\t\tif (getuid() != 0)\n\t\t\twarnx(\"... or simply run as root\");\n\n\tif (do_exit)\n\t\texit(-6);\n}\n\n \nint probe_nhm_msrs(unsigned int family, unsigned int model)\n{\n\tunsigned long long msr;\n\tunsigned int base_ratio;\n\tint *pkg_cstate_limits;\n\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tbclk = discover_bclk(family, model);\n\n\tswitch (model) {\n\tcase INTEL_FAM6_NEHALEM:\t \n\tcase INTEL_FAM6_NEHALEM_EX:\t \n\t\tpkg_cstate_limits = nhm_pkg_cstate_limits;\n\t\tbreak;\n\tcase INTEL_FAM6_SANDYBRIDGE:\t \n\tcase INTEL_FAM6_SANDYBRIDGE_X:\t \n\tcase INTEL_FAM6_IVYBRIDGE:\t \n\tcase INTEL_FAM6_IVYBRIDGE_X:\t \n\t\tpkg_cstate_limits = snb_pkg_cstate_limits;\n\t\thas_misc_feature_control = 1;\n\t\tbreak;\n\tcase INTEL_FAM6_HASWELL:\t \n\tcase INTEL_FAM6_HASWELL_G:\t \n\tcase INTEL_FAM6_HASWELL_X:\t \n\tcase INTEL_FAM6_HASWELL_L:\t \n\tcase INTEL_FAM6_BROADWELL:\t \n\tcase INTEL_FAM6_BROADWELL_G:\t \n\tcase INTEL_FAM6_BROADWELL_X:\t \n\tcase INTEL_FAM6_SKYLAKE_L:\t \n\tcase INTEL_FAM6_CANNONLAKE_L:\t \n\t\tpkg_cstate_limits = hsw_pkg_cstate_limits;\n\t\thas_misc_feature_control = 1;\n\t\tbreak;\n\tcase INTEL_FAM6_SKYLAKE_X:\t \n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\t \n\t\tpkg_cstate_limits = skx_pkg_cstate_limits;\n\t\thas_misc_feature_control = 1;\n\t\tbreak;\n\tcase INTEL_FAM6_ICELAKE_X:\t \n\t\tpkg_cstate_limits = icx_pkg_cstate_limits;\n\t\thas_misc_feature_control = 1;\n\t\tbreak;\n\tcase INTEL_FAM6_ATOM_SILVERMONT:\t \n\t\tno_MSR_MISC_PWR_MGMT = 1;\n\t\t \n\tcase INTEL_FAM6_ATOM_SILVERMONT_D:\t \n\t\tpkg_cstate_limits = slv_pkg_cstate_limits;\n\t\tbreak;\n\tcase INTEL_FAM6_ATOM_AIRMONT:\t \n\t\tpkg_cstate_limits = amt_pkg_cstate_limits;\n\t\tno_MSR_MISC_PWR_MGMT = 1;\n\t\tbreak;\n\tcase INTEL_FAM6_XEON_PHI_KNL:\t \n\t\tpkg_cstate_limits = phi_pkg_cstate_limits;\n\t\tbreak;\n\tcase INTEL_FAM6_ATOM_GOLDMONT:\t \n\tcase INTEL_FAM6_ATOM_GOLDMONT_PLUS:\n\tcase INTEL_FAM6_ATOM_GOLDMONT_D:\t \n\tcase INTEL_FAM6_ATOM_TREMONT:\t \n\tcase INTEL_FAM6_ATOM_TREMONT_D:\t \n\t\tpkg_cstate_limits = glm_pkg_cstate_limits;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tget_msr(base_cpu, MSR_PKG_CST_CONFIG_CONTROL, &msr);\n\tpkg_cstate_limit = pkg_cstate_limits[msr & 0xF];\n\n\tget_msr(base_cpu, MSR_PLATFORM_INFO, &msr);\n\tbase_ratio = (msr >> 8) & 0xFF;\n\n\tbase_hz = base_ratio * bclk * 1000000;\n\thas_base_hz = 1;\n\treturn 1;\n}\n\n \n\nint has_slv_msrs(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ATOM_SILVERMONT:\n\tcase INTEL_FAM6_ATOM_SILVERMONT_MID:\n\tcase INTEL_FAM6_ATOM_AIRMONT_MID:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_dnv(unsigned int family, unsigned int model)\n{\n\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ATOM_GOLDMONT_D:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_bdx(unsigned int family, unsigned int model)\n{\n\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_BROADWELL_X:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_skx(unsigned int family, unsigned int model)\n{\n\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_SKYLAKE_X:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_icx(unsigned int family, unsigned int model)\n{\n\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ICELAKE_X:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_spr(unsigned int family, unsigned int model)\n{\n\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_ehl(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ATOM_TREMONT:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_jvl(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ATOM_TREMONT_D:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint has_turbo_ratio_limit(unsigned int family, unsigned int model)\n{\n\tif (has_slv_msrs(family, model))\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\t\t \n\tcase INTEL_FAM6_NEHALEM_EX:\t \n\tcase INTEL_FAM6_XEON_PHI_KNL:\t \n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nint has_atom_turbo_ratio_limit(unsigned int family, unsigned int model)\n{\n\tif (has_slv_msrs(family, model))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint has_ivt_turbo_ratio_limit(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_IVYBRIDGE_X:\t \n\tcase INTEL_FAM6_HASWELL_X:\t \n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint has_hsw_turbo_ratio_limit(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_HASWELL_X:\t \n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint has_knl_turbo_ratio_limit(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_XEON_PHI_KNL:\t \n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint has_glm_turbo_ratio_limit(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ATOM_GOLDMONT:\n\tcase INTEL_FAM6_SKYLAKE_X:\n\tcase INTEL_FAM6_ICELAKE_X:\n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint has_config_tdp(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_IVYBRIDGE:\t \n\tcase INTEL_FAM6_HASWELL:\t \n\tcase INTEL_FAM6_HASWELL_X:\t \n\tcase INTEL_FAM6_HASWELL_L:\t \n\tcase INTEL_FAM6_HASWELL_G:\t \n\tcase INTEL_FAM6_BROADWELL:\t \n\tcase INTEL_FAM6_BROADWELL_G:\t \n\tcase INTEL_FAM6_BROADWELL_X:\t \n\tcase INTEL_FAM6_SKYLAKE_L:\t \n\tcase INTEL_FAM6_CANNONLAKE_L:\t \n\tcase INTEL_FAM6_SKYLAKE_X:\t \n\tcase INTEL_FAM6_ICELAKE_X:\t \n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\t \n\tcase INTEL_FAM6_XEON_PHI_KNL:\t \n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nvoid check_tcc_offset(int model)\n{\n\tunsigned long long msr;\n\n\tif (!genuine_intel)\n\t\treturn;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_SKYLAKE_L:\n\tcase INTEL_FAM6_SKYLAKE:\n\tcase INTEL_FAM6_KABYLAKE_L:\n\tcase INTEL_FAM6_KABYLAKE:\n\tcase INTEL_FAM6_ICELAKE_L:\n\tcase INTEL_FAM6_ICELAKE:\n\tcase INTEL_FAM6_TIGERLAKE_L:\n\tcase INTEL_FAM6_TIGERLAKE:\n\tcase INTEL_FAM6_COMETLAKE:\n\t\tif (!get_msr(base_cpu, MSR_PLATFORM_INFO, &msr)) {\n\t\t\tmsr = (msr >> 30) & 1;\n\t\t\tif (msr)\n\t\t\t\ttcc_offset_bits = 6;\n\t\t}\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n}\n\nstatic void remove_underbar(char *s)\n{\n\tchar *to = s;\n\n\twhile (*s) {\n\t\tif (*s != '_')\n\t\t\t*to++ = *s;\n\t\ts++;\n\t}\n\n\t*to = 0;\n}\n\nstatic void dump_turbo_ratio_info(unsigned int family, unsigned int model)\n{\n\tif (!has_turbo)\n\t\treturn;\n\n\tif (has_hsw_turbo_ratio_limit(family, model))\n\t\tdump_hsw_turbo_ratio_limits();\n\n\tif (has_ivt_turbo_ratio_limit(family, model))\n\t\tdump_ivt_turbo_ratio_limits();\n\n\tif (has_turbo_ratio_limit(family, model)) {\n\t\tdump_turbo_ratio_limits(MSR_TURBO_RATIO_LIMIT, family, model);\n\n\t\tif (is_hybrid)\n\t\t\tdump_turbo_ratio_limits(MSR_SECONDARY_TURBO_RATIO_LIMIT, family, model);\n\t}\n\n\tif (has_atom_turbo_ratio_limit(family, model))\n\t\tdump_atom_turbo_ratio_limits();\n\n\tif (has_knl_turbo_ratio_limit(family, model))\n\t\tdump_knl_turbo_ratio_limits();\n\n\tif (has_config_tdp(family, model))\n\t\tdump_config_tdp();\n}\n\nstatic void dump_cstate_pstate_config_info(unsigned int family, unsigned int model)\n{\n\tif (!do_nhm_platform_info)\n\t\treturn;\n\n\tdump_nhm_platform_info();\n\tdump_turbo_ratio_info(family, model);\n\tdump_nhm_cst_cfg();\n}\n\nstatic int read_sysfs_int(char *path)\n{\n\tFILE *input;\n\tint retval = -1;\n\n\tinput = fopen(path, \"r\");\n\tif (input == NULL) {\n\t\tif (debug)\n\t\t\tfprintf(outf, \"NSFOD %s\\n\", path);\n\t\treturn (-1);\n\t}\n\tif (fscanf(input, \"%d\", &retval) != 1)\n\t\terr(1, \"%s: failed to read int from file\", path);\n\tfclose(input);\n\n\treturn (retval);\n}\n\nstatic void dump_sysfs_file(char *path)\n{\n\tFILE *input;\n\tchar cpuidle_buf[64];\n\n\tinput = fopen(path, \"r\");\n\tif (input == NULL) {\n\t\tif (debug)\n\t\t\tfprintf(outf, \"NSFOD %s\\n\", path);\n\t\treturn;\n\t}\n\tif (!fgets(cpuidle_buf, sizeof(cpuidle_buf), input))\n\t\terr(1, \"%s: failed to read file\", path);\n\tfclose(input);\n\n\tfprintf(outf, \"%s: %s\", strrchr(path, '/') + 1, cpuidle_buf);\n}\n\nstatic void intel_uncore_frequency_probe(void)\n{\n\tint i, j;\n\tchar path[128];\n\n\tif (!genuine_intel)\n\t\treturn;\n\n\tif (access(\"/sys/devices/system/cpu/intel_uncore_frequency/package_00_die_00\", R_OK))\n\t\treturn;\n\n\tif (!access(\"/sys/devices/system/cpu/intel_uncore_frequency/package_00_die_00/current_freq_khz\", R_OK))\n\t\tBIC_PRESENT(BIC_UNCORE_MHZ);\n\n\tif (quiet)\n\t\treturn;\n\n\tfor (i = 0; i < topo.num_packages; ++i) {\n\t\tfor (j = 0; j < topo.num_die; ++j) {\n\t\t\tint k, l;\n\n\t\t\tsprintf(path, \"/sys/devices/system/cpu/intel_uncore_frequency/package_0%d_die_0%d/min_freq_khz\",\n\t\t\t\ti, j);\n\t\t\tk = read_sysfs_int(path);\n\t\t\tsprintf(path, \"/sys/devices/system/cpu/intel_uncore_frequency/package_0%d_die_0%d/max_freq_khz\",\n\t\t\t\ti, j);\n\t\t\tl = read_sysfs_int(path);\n\t\t\tfprintf(outf, \"Uncore Frequency pkg%d die%d: %d - %d MHz \", i, j, k / 1000, l / 1000);\n\n\t\t\tsprintf(path,\n\t\t\t\t\"/sys/devices/system/cpu/intel_uncore_frequency/package_0%d_die_0%d/initial_min_freq_khz\",\n\t\t\t\ti, j);\n\t\t\tk = read_sysfs_int(path);\n\t\t\tsprintf(path,\n\t\t\t\t\"/sys/devices/system/cpu/intel_uncore_frequency/package_0%d_die_0%d/initial_max_freq_khz\",\n\t\t\t\ti, j);\n\t\t\tl = read_sysfs_int(path);\n\t\t\tfprintf(outf, \"(%d - %d MHz)\\n\", k / 1000, l / 1000);\n\t\t}\n\t}\n}\n\nstatic void dump_sysfs_cstate_config(void)\n{\n\tchar path[64];\n\tchar name_buf[16];\n\tchar desc[64];\n\tFILE *input;\n\tint state;\n\tchar *sp;\n\n\tif (access(\"/sys/devices/system/cpu/cpuidle\", R_OK)) {\n\t\tfprintf(outf, \"cpuidle not loaded\\n\");\n\t\treturn;\n\t}\n\n\tdump_sysfs_file(\"/sys/devices/system/cpu/cpuidle/current_driver\");\n\tdump_sysfs_file(\"/sys/devices/system/cpu/cpuidle/current_governor\");\n\tdump_sysfs_file(\"/sys/devices/system/cpu/cpuidle/current_governor_ro\");\n\n\tfor (state = 0; state < 10; ++state) {\n\n\t\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/cpuidle/state%d/name\", base_cpu, state);\n\t\tinput = fopen(path, \"r\");\n\t\tif (input == NULL)\n\t\t\tcontinue;\n\t\tif (!fgets(name_buf, sizeof(name_buf), input))\n\t\t\terr(1, \"%s: failed to read file\", path);\n\n\t\t \n\t\tsp = strchr(name_buf, '-');\n\t\tif (!sp)\n\t\t\tsp = strchrnul(name_buf, '\\n');\n\t\t*sp = '\\0';\n\t\tfclose(input);\n\n\t\tremove_underbar(name_buf);\n\n\t\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/cpuidle/state%d/desc\", base_cpu, state);\n\t\tinput = fopen(path, \"r\");\n\t\tif (input == NULL)\n\t\t\tcontinue;\n\t\tif (!fgets(desc, sizeof(desc), input))\n\t\t\terr(1, \"%s: failed to read file\", path);\n\n\t\tfprintf(outf, \"cpu%d: %s: %s\", base_cpu, name_buf, desc);\n\t\tfclose(input);\n\t}\n}\n\nstatic void dump_sysfs_pstate_config(void)\n{\n\tchar path[64];\n\tchar driver_buf[64];\n\tchar governor_buf[64];\n\tFILE *input;\n\tint turbo;\n\n\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_driver\", base_cpu);\n\tinput = fopen(path, \"r\");\n\tif (input == NULL) {\n\t\tfprintf(outf, \"NSFOD %s\\n\", path);\n\t\treturn;\n\t}\n\tif (!fgets(driver_buf, sizeof(driver_buf), input))\n\t\terr(1, \"%s: failed to read file\", path);\n\tfclose(input);\n\n\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_governor\", base_cpu);\n\tinput = fopen(path, \"r\");\n\tif (input == NULL) {\n\t\tfprintf(outf, \"NSFOD %s\\n\", path);\n\t\treturn;\n\t}\n\tif (!fgets(governor_buf, sizeof(governor_buf), input))\n\t\terr(1, \"%s: failed to read file\", path);\n\tfclose(input);\n\n\tfprintf(outf, \"cpu%d: cpufreq driver: %s\", base_cpu, driver_buf);\n\tfprintf(outf, \"cpu%d: cpufreq governor: %s\", base_cpu, governor_buf);\n\n\tsprintf(path, \"/sys/devices/system/cpu/cpufreq/boost\");\n\tinput = fopen(path, \"r\");\n\tif (input != NULL) {\n\t\tif (fscanf(input, \"%d\", &turbo) != 1)\n\t\t\terr(1, \"%s: failed to parse number from file\", path);\n\t\tfprintf(outf, \"cpufreq boost: %d\\n\", turbo);\n\t\tfclose(input);\n\t}\n\n\tsprintf(path, \"/sys/devices/system/cpu/intel_pstate/no_turbo\");\n\tinput = fopen(path, \"r\");\n\tif (input != NULL) {\n\t\tif (fscanf(input, \"%d\", &turbo) != 1)\n\t\t\terr(1, \"%s: failed to parse number from file\", path);\n\t\tfprintf(outf, \"cpufreq intel_pstate no_turbo: %d\\n\", turbo);\n\t\tfclose(input);\n\t}\n}\n\n \nint print_epb(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tchar *epb_string;\n\tint cpu, epb;\n\n\tUNUSED(c);\n\tUNUSED(p);\n\n\tif (!has_epb)\n\t\treturn 0;\n\n\tcpu = t->cpu_id;\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(outf, \"print_epb: Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tepb = get_epb(cpu);\n\tif (epb < 0)\n\t\treturn 0;\n\n\tswitch (epb) {\n\tcase ENERGY_PERF_BIAS_PERFORMANCE:\n\t\tepb_string = \"performance\";\n\t\tbreak;\n\tcase ENERGY_PERF_BIAS_NORMAL:\n\t\tepb_string = \"balanced\";\n\t\tbreak;\n\tcase ENERGY_PERF_BIAS_POWERSAVE:\n\t\tepb_string = \"powersave\";\n\t\tbreak;\n\tdefault:\n\t\tepb_string = \"custom\";\n\t\tbreak;\n\t}\n\tfprintf(outf, \"cpu%d: EPB: %d (%s)\\n\", cpu, epb, epb_string);\n\n\treturn 0;\n}\n\n \nint print_hwp(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tunsigned long long msr;\n\tint cpu;\n\n\tUNUSED(c);\n\tUNUSED(p);\n\n\tif (!has_hwp)\n\t\treturn 0;\n\n\tcpu = t->cpu_id;\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(outf, \"print_hwp: Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tif (get_msr(cpu, MSR_PM_ENABLE, &msr))\n\t\treturn 0;\n\n\tfprintf(outf, \"cpu%d: MSR_PM_ENABLE: 0x%08llx (%sHWP)\\n\", cpu, msr, (msr & (1 << 0)) ? \"\" : \"No-\");\n\n\t \n\tif ((msr & (1 << 0)) == 0)\n\t\treturn 0;\n\n\tif (get_msr(cpu, MSR_HWP_CAPABILITIES, &msr))\n\t\treturn 0;\n\n\tfprintf(outf, \"cpu%d: MSR_HWP_CAPABILITIES: 0x%08llx \"\n\t\t\"(high %d guar %d eff %d low %d)\\n\",\n\t\tcpu, msr,\n\t\t(unsigned int)HWP_HIGHEST_PERF(msr),\n\t\t(unsigned int)HWP_GUARANTEED_PERF(msr),\n\t\t(unsigned int)HWP_MOSTEFFICIENT_PERF(msr), (unsigned int)HWP_LOWEST_PERF(msr));\n\n\tif (get_msr(cpu, MSR_HWP_REQUEST, &msr))\n\t\treturn 0;\n\n\tfprintf(outf, \"cpu%d: MSR_HWP_REQUEST: 0x%08llx \"\n\t\t\"(min %d max %d des %d epp 0x%x window 0x%x pkg 0x%x)\\n\",\n\t\tcpu, msr,\n\t\t(unsigned int)(((msr) >> 0) & 0xff),\n\t\t(unsigned int)(((msr) >> 8) & 0xff),\n\t\t(unsigned int)(((msr) >> 16) & 0xff),\n\t\t(unsigned int)(((msr) >> 24) & 0xff),\n\t\t(unsigned int)(((msr) >> 32) & 0xff3), (unsigned int)(((msr) >> 42) & 0x1));\n\n\tif (has_hwp_pkg) {\n\t\tif (get_msr(cpu, MSR_HWP_REQUEST_PKG, &msr))\n\t\t\treturn 0;\n\n\t\tfprintf(outf, \"cpu%d: MSR_HWP_REQUEST_PKG: 0x%08llx \"\n\t\t\t\"(min %d max %d des %d epp 0x%x window 0x%x)\\n\",\n\t\t\tcpu, msr,\n\t\t\t(unsigned int)(((msr) >> 0) & 0xff),\n\t\t\t(unsigned int)(((msr) >> 8) & 0xff),\n\t\t\t(unsigned int)(((msr) >> 16) & 0xff),\n\t\t\t(unsigned int)(((msr) >> 24) & 0xff), (unsigned int)(((msr) >> 32) & 0xff3));\n\t}\n\tif (has_hwp_notify) {\n\t\tif (get_msr(cpu, MSR_HWP_INTERRUPT, &msr))\n\t\t\treturn 0;\n\n\t\tfprintf(outf, \"cpu%d: MSR_HWP_INTERRUPT: 0x%08llx \"\n\t\t\t\"(%s_Guaranteed_Perf_Change, %s_Excursion_Min)\\n\",\n\t\t\tcpu, msr, ((msr) & 0x1) ? \"EN\" : \"Dis\", ((msr) & 0x2) ? \"EN\" : \"Dis\");\n\t}\n\tif (get_msr(cpu, MSR_HWP_STATUS, &msr))\n\t\treturn 0;\n\n\tfprintf(outf, \"cpu%d: MSR_HWP_STATUS: 0x%08llx \"\n\t\t\"(%sGuaranteed_Perf_Change, %sExcursion_Min)\\n\",\n\t\tcpu, msr, ((msr) & 0x1) ? \"\" : \"No-\", ((msr) & 0x4) ? \"\" : \"No-\");\n\n\treturn 0;\n}\n\n \nint print_perf_limit(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tunsigned long long msr;\n\tint cpu;\n\n\tUNUSED(c);\n\tUNUSED(p);\n\n\tcpu = t->cpu_id;\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(outf, \"print_perf_limit: Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tif (do_core_perf_limit_reasons) {\n\t\tget_msr(cpu, MSR_CORE_PERF_LIMIT_REASONS, &msr);\n\t\tfprintf(outf, \"cpu%d: MSR_CORE_PERF_LIMIT_REASONS, 0x%08llx\", cpu, msr);\n\t\tfprintf(outf, \" (Active: %s%s%s%s%s%s%s%s%s%s%s%s%s%s)\",\n\t\t\t(msr & 1 << 15) ? \"bit15, \" : \"\",\n\t\t\t(msr & 1 << 14) ? \"bit14, \" : \"\",\n\t\t\t(msr & 1 << 13) ? \"Transitions, \" : \"\",\n\t\t\t(msr & 1 << 12) ? \"MultiCoreTurbo, \" : \"\",\n\t\t\t(msr & 1 << 11) ? \"PkgPwrL2, \" : \"\",\n\t\t\t(msr & 1 << 10) ? \"PkgPwrL1, \" : \"\",\n\t\t\t(msr & 1 << 9) ? \"CorePwr, \" : \"\",\n\t\t\t(msr & 1 << 8) ? \"Amps, \" : \"\",\n\t\t\t(msr & 1 << 6) ? \"VR-Therm, \" : \"\",\n\t\t\t(msr & 1 << 5) ? \"Auto-HWP, \" : \"\",\n\t\t\t(msr & 1 << 4) ? \"Graphics, \" : \"\",\n\t\t\t(msr & 1 << 2) ? \"bit2, \" : \"\",\n\t\t\t(msr & 1 << 1) ? \"ThermStatus, \" : \"\", (msr & 1 << 0) ? \"PROCHOT, \" : \"\");\n\t\tfprintf(outf, \" (Logged: %s%s%s%s%s%s%s%s%s%s%s%s%s%s)\\n\",\n\t\t\t(msr & 1 << 31) ? \"bit31, \" : \"\",\n\t\t\t(msr & 1 << 30) ? \"bit30, \" : \"\",\n\t\t\t(msr & 1 << 29) ? \"Transitions, \" : \"\",\n\t\t\t(msr & 1 << 28) ? \"MultiCoreTurbo, \" : \"\",\n\t\t\t(msr & 1 << 27) ? \"PkgPwrL2, \" : \"\",\n\t\t\t(msr & 1 << 26) ? \"PkgPwrL1, \" : \"\",\n\t\t\t(msr & 1 << 25) ? \"CorePwr, \" : \"\",\n\t\t\t(msr & 1 << 24) ? \"Amps, \" : \"\",\n\t\t\t(msr & 1 << 22) ? \"VR-Therm, \" : \"\",\n\t\t\t(msr & 1 << 21) ? \"Auto-HWP, \" : \"\",\n\t\t\t(msr & 1 << 20) ? \"Graphics, \" : \"\",\n\t\t\t(msr & 1 << 18) ? \"bit18, \" : \"\",\n\t\t\t(msr & 1 << 17) ? \"ThermStatus, \" : \"\", (msr & 1 << 16) ? \"PROCHOT, \" : \"\");\n\n\t}\n\tif (do_gfx_perf_limit_reasons) {\n\t\tget_msr(cpu, MSR_GFX_PERF_LIMIT_REASONS, &msr);\n\t\tfprintf(outf, \"cpu%d: MSR_GFX_PERF_LIMIT_REASONS, 0x%08llx\", cpu, msr);\n\t\tfprintf(outf, \" (Active: %s%s%s%s%s%s%s%s)\",\n\t\t\t(msr & 1 << 0) ? \"PROCHOT, \" : \"\",\n\t\t\t(msr & 1 << 1) ? \"ThermStatus, \" : \"\",\n\t\t\t(msr & 1 << 4) ? \"Graphics, \" : \"\",\n\t\t\t(msr & 1 << 6) ? \"VR-Therm, \" : \"\",\n\t\t\t(msr & 1 << 8) ? \"Amps, \" : \"\",\n\t\t\t(msr & 1 << 9) ? \"GFXPwr, \" : \"\",\n\t\t\t(msr & 1 << 10) ? \"PkgPwrL1, \" : \"\", (msr & 1 << 11) ? \"PkgPwrL2, \" : \"\");\n\t\tfprintf(outf, \" (Logged: %s%s%s%s%s%s%s%s)\\n\",\n\t\t\t(msr & 1 << 16) ? \"PROCHOT, \" : \"\",\n\t\t\t(msr & 1 << 17) ? \"ThermStatus, \" : \"\",\n\t\t\t(msr & 1 << 20) ? \"Graphics, \" : \"\",\n\t\t\t(msr & 1 << 22) ? \"VR-Therm, \" : \"\",\n\t\t\t(msr & 1 << 24) ? \"Amps, \" : \"\",\n\t\t\t(msr & 1 << 25) ? \"GFXPwr, \" : \"\",\n\t\t\t(msr & 1 << 26) ? \"PkgPwrL1, \" : \"\", (msr & 1 << 27) ? \"PkgPwrL2, \" : \"\");\n\t}\n\tif (do_ring_perf_limit_reasons) {\n\t\tget_msr(cpu, MSR_RING_PERF_LIMIT_REASONS, &msr);\n\t\tfprintf(outf, \"cpu%d: MSR_RING_PERF_LIMIT_REASONS, 0x%08llx\", cpu, msr);\n\t\tfprintf(outf, \" (Active: %s%s%s%s%s%s)\",\n\t\t\t(msr & 1 << 0) ? \"PROCHOT, \" : \"\",\n\t\t\t(msr & 1 << 1) ? \"ThermStatus, \" : \"\",\n\t\t\t(msr & 1 << 6) ? \"VR-Therm, \" : \"\",\n\t\t\t(msr & 1 << 8) ? \"Amps, \" : \"\",\n\t\t\t(msr & 1 << 10) ? \"PkgPwrL1, \" : \"\", (msr & 1 << 11) ? \"PkgPwrL2, \" : \"\");\n\t\tfprintf(outf, \" (Logged: %s%s%s%s%s%s)\\n\",\n\t\t\t(msr & 1 << 16) ? \"PROCHOT, \" : \"\",\n\t\t\t(msr & 1 << 17) ? \"ThermStatus, \" : \"\",\n\t\t\t(msr & 1 << 22) ? \"VR-Therm, \" : \"\",\n\t\t\t(msr & 1 << 24) ? \"Amps, \" : \"\",\n\t\t\t(msr & 1 << 26) ? \"PkgPwrL1, \" : \"\", (msr & 1 << 27) ? \"PkgPwrL2, \" : \"\");\n\t}\n\treturn 0;\n}\n\n#define\tRAPL_POWER_GRANULARITY\t0x7FFF\t \n#define\tRAPL_TIME_GRANULARITY\t0x3F\t \n\ndouble get_tdp_intel(unsigned int model)\n{\n\tunsigned long long msr;\n\n\tif (do_rapl & RAPL_PKG_POWER_INFO)\n\t\tif (!get_msr(base_cpu, MSR_PKG_POWER_INFO, &msr))\n\t\t\treturn ((msr >> 0) & RAPL_POWER_GRANULARITY) * rapl_power_units;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ATOM_SILVERMONT:\n\tcase INTEL_FAM6_ATOM_SILVERMONT_D:\n\t\treturn 30.0;\n\tdefault:\n\t\treturn 135.0;\n\t}\n}\n\ndouble get_tdp_amd(unsigned int family)\n{\n\tUNUSED(family);\n\n\t \n\treturn 280.0;\n}\n\n \nstatic double rapl_dram_energy_units_probe(int model, double rapl_energy_units)\n{\n\t \n\n\tswitch (model) {\n\tcase INTEL_FAM6_HASWELL_X:\t \n\tcase INTEL_FAM6_BROADWELL_X:\t \n\tcase INTEL_FAM6_SKYLAKE_X:\t \n\tcase INTEL_FAM6_XEON_PHI_KNL:\t \n\tcase INTEL_FAM6_ICELAKE_X:\t \n\t\treturn (rapl_dram_energy_units = 15.3 / 1000000);\n\tdefault:\n\t\treturn (rapl_energy_units);\n\t}\n}\n\nvoid rapl_probe_intel(unsigned int family, unsigned int model)\n{\n\tunsigned long long msr;\n\tunsigned int time_unit;\n\tdouble tdp;\n\n\tif (family != 6)\n\t\treturn;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_SANDYBRIDGE:\n\tcase INTEL_FAM6_IVYBRIDGE:\n\tcase INTEL_FAM6_HASWELL:\t \n\tcase INTEL_FAM6_HASWELL_L:\t \n\tcase INTEL_FAM6_HASWELL_G:\t \n\tcase INTEL_FAM6_BROADWELL:\t \n\tcase INTEL_FAM6_BROADWELL_G:\t \n\t\tdo_rapl = RAPL_PKG | RAPL_CORES | RAPL_CORE_POLICY | RAPL_GFX | RAPL_PKG_POWER_INFO;\n\t\tif (rapl_joules) {\n\t\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\t\tBIC_PRESENT(BIC_Cor_J);\n\t\t\tBIC_PRESENT(BIC_GFX_J);\n\t\t} else {\n\t\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\t\tBIC_PRESENT(BIC_CorWatt);\n\t\t\tBIC_PRESENT(BIC_GFXWatt);\n\t\t}\n\t\tbreak;\n\tcase INTEL_FAM6_ATOM_GOLDMONT:\t \n\tcase INTEL_FAM6_ATOM_GOLDMONT_PLUS:\n\t\tdo_rapl = RAPL_PKG | RAPL_PKG_POWER_INFO;\n\t\tif (rapl_joules)\n\t\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\telse\n\t\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\tbreak;\n\tcase INTEL_FAM6_ATOM_TREMONT:\t \n\t\tdo_rapl =\n\t\t    RAPL_PKG | RAPL_CORES | RAPL_CORE_POLICY | RAPL_DRAM | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS\n\t\t    | RAPL_GFX | RAPL_PKG_POWER_INFO;\n\t\tif (rapl_joules) {\n\t\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\t\tBIC_PRESENT(BIC_Cor_J);\n\t\t\tBIC_PRESENT(BIC_RAM_J);\n\t\t\tBIC_PRESENT(BIC_GFX_J);\n\t\t} else {\n\t\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\t\tBIC_PRESENT(BIC_CorWatt);\n\t\t\tBIC_PRESENT(BIC_RAMWatt);\n\t\t\tBIC_PRESENT(BIC_GFXWatt);\n\t\t}\n\t\tbreak;\n\tcase INTEL_FAM6_ATOM_TREMONT_D:\t \n\t\tdo_rapl = RAPL_PKG | RAPL_PKG_PERF_STATUS | RAPL_PKG_POWER_INFO;\n\t\tBIC_PRESENT(BIC_PKG__);\n\t\tif (rapl_joules)\n\t\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\telse\n\t\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\tbreak;\n\tcase INTEL_FAM6_SKYLAKE_L:\t \n\tcase INTEL_FAM6_CANNONLAKE_L:\t \n\t\tdo_rapl =\n\t\t    RAPL_PKG | RAPL_CORES | RAPL_CORE_POLICY | RAPL_DRAM | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS\n\t\t    | RAPL_GFX | RAPL_PKG_POWER_INFO;\n\t\tBIC_PRESENT(BIC_PKG__);\n\t\tBIC_PRESENT(BIC_RAM__);\n\t\tif (rapl_joules) {\n\t\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\t\tBIC_PRESENT(BIC_Cor_J);\n\t\t\tBIC_PRESENT(BIC_RAM_J);\n\t\t\tBIC_PRESENT(BIC_GFX_J);\n\t\t} else {\n\t\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\t\tBIC_PRESENT(BIC_CorWatt);\n\t\t\tBIC_PRESENT(BIC_RAMWatt);\n\t\t\tBIC_PRESENT(BIC_GFXWatt);\n\t\t}\n\t\tbreak;\n\tcase INTEL_FAM6_HASWELL_X:\t \n\tcase INTEL_FAM6_BROADWELL_X:\t \n\tcase INTEL_FAM6_SKYLAKE_X:\t \n\tcase INTEL_FAM6_ICELAKE_X:\t \n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\t \n\tcase INTEL_FAM6_XEON_PHI_KNL:\t \n\t\tdo_rapl =\n\t\t    RAPL_PKG | RAPL_DRAM | RAPL_DRAM_POWER_INFO | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS |\n\t\t    RAPL_PKG_POWER_INFO;\n\t\tBIC_PRESENT(BIC_PKG__);\n\t\tBIC_PRESENT(BIC_RAM__);\n\t\tif (rapl_joules) {\n\t\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\t\tBIC_PRESENT(BIC_RAM_J);\n\t\t} else {\n\t\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\t\tBIC_PRESENT(BIC_RAMWatt);\n\t\t}\n\t\tbreak;\n\tcase INTEL_FAM6_SANDYBRIDGE_X:\n\tcase INTEL_FAM6_IVYBRIDGE_X:\n\t\tdo_rapl =\n\t\t    RAPL_PKG | RAPL_CORES | RAPL_CORE_POLICY | RAPL_DRAM | RAPL_DRAM_POWER_INFO | RAPL_PKG_PERF_STATUS |\n\t\t    RAPL_DRAM_PERF_STATUS | RAPL_PKG_POWER_INFO;\n\t\tBIC_PRESENT(BIC_PKG__);\n\t\tBIC_PRESENT(BIC_RAM__);\n\t\tif (rapl_joules) {\n\t\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\t\tBIC_PRESENT(BIC_Cor_J);\n\t\t\tBIC_PRESENT(BIC_RAM_J);\n\t\t} else {\n\t\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\t\tBIC_PRESENT(BIC_CorWatt);\n\t\t\tBIC_PRESENT(BIC_RAMWatt);\n\t\t}\n\t\tbreak;\n\tcase INTEL_FAM6_ATOM_SILVERMONT:\t \n\tcase INTEL_FAM6_ATOM_SILVERMONT_D:\t \n\t\tdo_rapl = RAPL_PKG | RAPL_CORES;\n\t\tif (rapl_joules) {\n\t\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\t\tBIC_PRESENT(BIC_Cor_J);\n\t\t} else {\n\t\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\t\tBIC_PRESENT(BIC_CorWatt);\n\t\t}\n\t\tbreak;\n\tcase INTEL_FAM6_ATOM_GOLDMONT_D:\t \n\t\tdo_rapl =\n\t\t    RAPL_PKG | RAPL_DRAM | RAPL_DRAM_POWER_INFO | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS |\n\t\t    RAPL_PKG_POWER_INFO | RAPL_CORES_ENERGY_STATUS;\n\t\tBIC_PRESENT(BIC_PKG__);\n\t\tBIC_PRESENT(BIC_RAM__);\n\t\tif (rapl_joules) {\n\t\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\t\tBIC_PRESENT(BIC_Cor_J);\n\t\t\tBIC_PRESENT(BIC_RAM_J);\n\t\t} else {\n\t\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\t\tBIC_PRESENT(BIC_CorWatt);\n\t\t\tBIC_PRESENT(BIC_RAMWatt);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tif (get_msr(base_cpu, MSR_RAPL_POWER_UNIT, &msr))\n\t\treturn;\n\n\trapl_power_units = 1.0 / (1 << (msr & 0xF));\n\tif (model == INTEL_FAM6_ATOM_SILVERMONT)\n\t\trapl_energy_units = 1.0 * (1 << (msr >> 8 & 0x1F)) / 1000000;\n\telse\n\t\trapl_energy_units = 1.0 / (1 << (msr >> 8 & 0x1F));\n\n\trapl_dram_energy_units = rapl_dram_energy_units_probe(model, rapl_energy_units);\n\n\ttime_unit = msr >> 16 & 0xF;\n\tif (time_unit == 0)\n\t\ttime_unit = 0xA;\n\n\trapl_time_units = 1.0 / (1 << (time_unit));\n\n\ttdp = get_tdp_intel(model);\n\n\trapl_joule_counter_range = 0xFFFFFFFF * rapl_energy_units / tdp;\n\tif (!quiet)\n\t\tfprintf(outf, \"RAPL: %.0f sec. Joule Counter Range, at %.0f Watts\\n\", rapl_joule_counter_range, tdp);\n}\n\nvoid rapl_probe_amd(unsigned int family, unsigned int model)\n{\n\tunsigned long long msr;\n\tunsigned int eax, ebx, ecx, edx;\n\tunsigned int has_rapl = 0;\n\tdouble tdp;\n\n\tUNUSED(model);\n\n\tif (max_extended_level >= 0x80000007) {\n\t\t__cpuid(0x80000007, eax, ebx, ecx, edx);\n\t\t \n\t\thas_rapl = edx & (1 << 14);\n\t}\n\n\tif (!has_rapl || family < 0x17)\n\t\treturn;\n\n\tdo_rapl = RAPL_AMD_F17H | RAPL_PER_CORE_ENERGY;\n\tif (rapl_joules) {\n\t\tBIC_PRESENT(BIC_Pkg_J);\n\t\tBIC_PRESENT(BIC_Cor_J);\n\t} else {\n\t\tBIC_PRESENT(BIC_PkgWatt);\n\t\tBIC_PRESENT(BIC_CorWatt);\n\t}\n\n\tif (get_msr(base_cpu, MSR_RAPL_PWR_UNIT, &msr))\n\t\treturn;\n\n\trapl_time_units = ldexp(1.0, -(msr >> 16 & 0xf));\n\trapl_energy_units = ldexp(1.0, -(msr >> 8 & 0x1f));\n\trapl_power_units = ldexp(1.0, -(msr & 0xf));\n\n\ttdp = get_tdp_amd(family);\n\n\trapl_joule_counter_range = 0xFFFFFFFF * rapl_energy_units / tdp;\n\tif (!quiet)\n\t\tfprintf(outf, \"RAPL: %.0f sec. Joule Counter Range, at %.0f Watts\\n\", rapl_joule_counter_range, tdp);\n}\n\n \nvoid rapl_probe(unsigned int family, unsigned int model)\n{\n\tif (genuine_intel)\n\t\trapl_probe_intel(family, model);\n\tif (authentic_amd || hygon_genuine)\n\t\trapl_probe_amd(family, model);\n}\n\nvoid perf_limit_reasons_probe(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn;\n\n\tif (family != 6)\n\t\treturn;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_HASWELL:\t \n\tcase INTEL_FAM6_HASWELL_L:\t \n\tcase INTEL_FAM6_HASWELL_G:\t \n\t\tdo_gfx_perf_limit_reasons = 1;\n\t\t \n\tcase INTEL_FAM6_HASWELL_X:\t \n\t\tdo_core_perf_limit_reasons = 1;\n\t\tdo_ring_perf_limit_reasons = 1;\n\tdefault:\n\t\treturn;\n\t}\n}\n\nvoid automatic_cstate_conversion_probe(unsigned int family, unsigned int model)\n{\n\tif (family != 6)\n\t\treturn;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_BROADWELL_X:\n\tcase INTEL_FAM6_SKYLAKE_X:\n\t\thas_automatic_cstate_conversion = 1;\n\t}\n}\n\nvoid prewake_cstate_probe(unsigned int family, unsigned int model)\n{\n\tif (is_icx(family, model) || is_spr(family, model))\n\t\tdis_cstate_prewake = 1;\n}\n\nint print_thermal(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tunsigned long long msr;\n\tunsigned int dts, dts2;\n\tint cpu;\n\n\tUNUSED(c);\n\tUNUSED(p);\n\n\tif (!(do_dts || do_ptm))\n\t\treturn 0;\n\n\tcpu = t->cpu_id;\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\n\t\treturn 0;\n\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(outf, \"print_thermal: Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tif (do_ptm && (t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE)) {\n\t\tif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\n\t\t\treturn 0;\n\n\t\tdts = (msr >> 16) & 0x7F;\n\t\tfprintf(outf, \"cpu%d: MSR_IA32_PACKAGE_THERM_STATUS: 0x%08llx (%d C)\\n\", cpu, msr, tj_max - dts);\n\n\t\tif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, &msr))\n\t\t\treturn 0;\n\n\t\tdts = (msr >> 16) & 0x7F;\n\t\tdts2 = (msr >> 8) & 0x7F;\n\t\tfprintf(outf, \"cpu%d: MSR_IA32_PACKAGE_THERM_INTERRUPT: 0x%08llx (%d C, %d C)\\n\",\n\t\t\tcpu, msr, tj_max - dts, tj_max - dts2);\n\t}\n\n\tif (do_dts && debug) {\n\t\tunsigned int resolution;\n\n\t\tif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\n\t\t\treturn 0;\n\n\t\tdts = (msr >> 16) & 0x7F;\n\t\tresolution = (msr >> 27) & 0xF;\n\t\tfprintf(outf, \"cpu%d: MSR_IA32_THERM_STATUS: 0x%08llx (%d C +/- %d)\\n\",\n\t\t\tcpu, msr, tj_max - dts, resolution);\n\n\t\tif (get_msr(cpu, MSR_IA32_THERM_INTERRUPT, &msr))\n\t\t\treturn 0;\n\n\t\tdts = (msr >> 16) & 0x7F;\n\t\tdts2 = (msr >> 8) & 0x7F;\n\t\tfprintf(outf, \"cpu%d: MSR_IA32_THERM_INTERRUPT: 0x%08llx (%d C, %d C)\\n\",\n\t\t\tcpu, msr, tj_max - dts, tj_max - dts2);\n\t}\n\n\treturn 0;\n}\n\nvoid print_power_limit_msr(int cpu, unsigned long long msr, char *label)\n{\n\tfprintf(outf, \"cpu%d: %s: %sabled (%0.3f Watts, %f sec, clamp %sabled)\\n\",\n\t\tcpu, label,\n\t\t((msr >> 15) & 1) ? \"EN\" : \"DIS\",\n\t\t((msr >> 0) & 0x7FFF) * rapl_power_units,\n\t\t(1.0 + (((msr >> 22) & 0x3) / 4.0)) * (1 << ((msr >> 17) & 0x1F)) * rapl_time_units,\n\t\t(((msr >> 16) & 1) ? \"EN\" : \"DIS\"));\n\n\treturn;\n}\n\nint print_rapl(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tunsigned long long msr;\n\tconst char *msr_name;\n\tint cpu;\n\n\tUNUSED(c);\n\tUNUSED(p);\n\n\tif (!do_rapl)\n\t\treturn 0;\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tcpu = t->cpu_id;\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(outf, \"print_rapl: Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tif (do_rapl & RAPL_AMD_F17H) {\n\t\tmsr_name = \"MSR_RAPL_PWR_UNIT\";\n\t\tif (get_msr(cpu, MSR_RAPL_PWR_UNIT, &msr))\n\t\t\treturn -1;\n\t} else {\n\t\tmsr_name = \"MSR_RAPL_POWER_UNIT\";\n\t\tif (get_msr(cpu, MSR_RAPL_POWER_UNIT, &msr))\n\t\t\treturn -1;\n\t}\n\n\tfprintf(outf, \"cpu%d: %s: 0x%08llx (%f Watts, %f Joules, %f sec.)\\n\", cpu, msr_name, msr,\n\t\trapl_power_units, rapl_energy_units, rapl_time_units);\n\n\tif (do_rapl & RAPL_PKG_POWER_INFO) {\n\n\t\tif (get_msr(cpu, MSR_PKG_POWER_INFO, &msr))\n\t\t\treturn -5;\n\n\t\tfprintf(outf, \"cpu%d: MSR_PKG_POWER_INFO: 0x%08llx (%.0f W TDP, RAPL %.0f - %.0f W, %f sec.)\\n\",\n\t\t\tcpu, msr,\n\t\t\t((msr >> 0) & RAPL_POWER_GRANULARITY) * rapl_power_units,\n\t\t\t((msr >> 16) & RAPL_POWER_GRANULARITY) * rapl_power_units,\n\t\t\t((msr >> 32) & RAPL_POWER_GRANULARITY) * rapl_power_units,\n\t\t\t((msr >> 48) & RAPL_TIME_GRANULARITY) * rapl_time_units);\n\n\t}\n\tif (do_rapl & RAPL_PKG) {\n\n\t\tif (get_msr(cpu, MSR_PKG_POWER_LIMIT, &msr))\n\t\t\treturn -9;\n\n\t\tfprintf(outf, \"cpu%d: MSR_PKG_POWER_LIMIT: 0x%08llx (%slocked)\\n\",\n\t\t\tcpu, msr, (msr >> 63) & 1 ? \"\" : \"UN\");\n\n\t\tprint_power_limit_msr(cpu, msr, \"PKG Limit #1\");\n\t\tfprintf(outf, \"cpu%d: PKG Limit #2: %sabled (%0.3f Watts, %f* sec, clamp %sabled)\\n\",\n\t\t\tcpu,\n\t\t\t((msr >> 47) & 1) ? \"EN\" : \"DIS\",\n\t\t\t((msr >> 32) & 0x7FFF) * rapl_power_units,\n\t\t\t(1.0 + (((msr >> 54) & 0x3) / 4.0)) * (1 << ((msr >> 49) & 0x1F)) * rapl_time_units,\n\t\t\t((msr >> 48) & 1) ? \"EN\" : \"DIS\");\n\n\t\tif (get_msr(cpu, MSR_VR_CURRENT_CONFIG, &msr))\n\t\t\treturn -9;\n\n\t\tfprintf(outf, \"cpu%d: MSR_VR_CURRENT_CONFIG: 0x%08llx\\n\", cpu, msr);\n\t\tfprintf(outf, \"cpu%d: PKG Limit #4: %f Watts (%slocked)\\n\",\n\t\t\tcpu, ((msr >> 0) & 0x1FFF) * rapl_power_units, (msr >> 31) & 1 ? \"\" : \"UN\");\n\t}\n\n\tif (do_rapl & RAPL_DRAM_POWER_INFO) {\n\t\tif (get_msr(cpu, MSR_DRAM_POWER_INFO, &msr))\n\t\t\treturn -6;\n\n\t\tfprintf(outf, \"cpu%d: MSR_DRAM_POWER_INFO,: 0x%08llx (%.0f W TDP, RAPL %.0f - %.0f W, %f sec.)\\n\",\n\t\t\tcpu, msr,\n\t\t\t((msr >> 0) & RAPL_POWER_GRANULARITY) * rapl_power_units,\n\t\t\t((msr >> 16) & RAPL_POWER_GRANULARITY) * rapl_power_units,\n\t\t\t((msr >> 32) & RAPL_POWER_GRANULARITY) * rapl_power_units,\n\t\t\t((msr >> 48) & RAPL_TIME_GRANULARITY) * rapl_time_units);\n\t}\n\tif (do_rapl & RAPL_DRAM) {\n\t\tif (get_msr(cpu, MSR_DRAM_POWER_LIMIT, &msr))\n\t\t\treturn -9;\n\t\tfprintf(outf, \"cpu%d: MSR_DRAM_POWER_LIMIT: 0x%08llx (%slocked)\\n\",\n\t\t\tcpu, msr, (msr >> 31) & 1 ? \"\" : \"UN\");\n\n\t\tprint_power_limit_msr(cpu, msr, \"DRAM Limit\");\n\t}\n\tif (do_rapl & RAPL_CORE_POLICY) {\n\t\tif (get_msr(cpu, MSR_PP0_POLICY, &msr))\n\t\t\treturn -7;\n\n\t\tfprintf(outf, \"cpu%d: MSR_PP0_POLICY: %lld\\n\", cpu, msr & 0xF);\n\t}\n\tif (do_rapl & RAPL_CORES_POWER_LIMIT) {\n\t\tif (get_msr(cpu, MSR_PP0_POWER_LIMIT, &msr))\n\t\t\treturn -9;\n\t\tfprintf(outf, \"cpu%d: MSR_PP0_POWER_LIMIT: 0x%08llx (%slocked)\\n\",\n\t\t\tcpu, msr, (msr >> 31) & 1 ? \"\" : \"UN\");\n\t\tprint_power_limit_msr(cpu, msr, \"Cores Limit\");\n\t}\n\tif (do_rapl & RAPL_GFX) {\n\t\tif (get_msr(cpu, MSR_PP1_POLICY, &msr))\n\t\t\treturn -8;\n\n\t\tfprintf(outf, \"cpu%d: MSR_PP1_POLICY: %lld\\n\", cpu, msr & 0xF);\n\n\t\tif (get_msr(cpu, MSR_PP1_POWER_LIMIT, &msr))\n\t\t\treturn -9;\n\t\tfprintf(outf, \"cpu%d: MSR_PP1_POWER_LIMIT: 0x%08llx (%slocked)\\n\",\n\t\t\tcpu, msr, (msr >> 31) & 1 ? \"\" : \"UN\");\n\t\tprint_power_limit_msr(cpu, msr, \"GFX Limit\");\n\t}\n\treturn 0;\n}\n\n \n\nint has_snb_msrs(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_SANDYBRIDGE:\n\tcase INTEL_FAM6_SANDYBRIDGE_X:\n\tcase INTEL_FAM6_IVYBRIDGE:\t \n\tcase INTEL_FAM6_IVYBRIDGE_X:\t \n\tcase INTEL_FAM6_HASWELL:\t \n\tcase INTEL_FAM6_HASWELL_X:\t \n\tcase INTEL_FAM6_HASWELL_L:\t \n\tcase INTEL_FAM6_HASWELL_G:\t \n\tcase INTEL_FAM6_BROADWELL:\t \n\tcase INTEL_FAM6_BROADWELL_G:\t \n\tcase INTEL_FAM6_BROADWELL_X:\t \n\tcase INTEL_FAM6_SKYLAKE_L:\t \n\tcase INTEL_FAM6_CANNONLAKE_L:\t \n\tcase INTEL_FAM6_SKYLAKE_X:\t \n\tcase INTEL_FAM6_ICELAKE_X:\t \n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\t \n\tcase INTEL_FAM6_ATOM_GOLDMONT:\t \n\tcase INTEL_FAM6_ATOM_GOLDMONT_PLUS:\n\tcase INTEL_FAM6_ATOM_GOLDMONT_D:\t \n\tcase INTEL_FAM6_ATOM_TREMONT:\t \n\tcase INTEL_FAM6_ATOM_TREMONT_D:\t \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nint has_c8910_msrs(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_HASWELL_L:\t \n\tcase INTEL_FAM6_BROADWELL:\t \n\tcase INTEL_FAM6_SKYLAKE_L:\t \n\tcase INTEL_FAM6_CANNONLAKE_L:\t \n\tcase INTEL_FAM6_ATOM_GOLDMONT:\t \n\tcase INTEL_FAM6_ATOM_GOLDMONT_PLUS:\n\tcase INTEL_FAM6_ATOM_TREMONT:\t \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nint has_skl_msrs(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_SKYLAKE_L:\t \n\tcase INTEL_FAM6_CANNONLAKE_L:\t \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_slm(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_ATOM_SILVERMONT:\t \n\tcase INTEL_FAM6_ATOM_SILVERMONT_D:\t \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_knl(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_XEON_PHI_KNL:\t \n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_cnl(unsigned int family, unsigned int model)\n{\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (family != 6)\n\t\treturn 0;\n\n\tswitch (model) {\n\tcase INTEL_FAM6_CANNONLAKE_L:\t \n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nunsigned int get_aperf_mperf_multiplier(unsigned int family, unsigned int model)\n{\n\tif (is_knl(family, model))\n\t\treturn 1024;\n\treturn 1;\n}\n\n#define SLM_BCLK_FREQS 5\ndouble slm_freq_table[SLM_BCLK_FREQS] = { 83.3, 100.0, 133.3, 116.7, 80.0 };\n\ndouble slm_bclk(void)\n{\n\tunsigned long long msr = 3;\n\tunsigned int i;\n\tdouble freq;\n\n\tif (get_msr(base_cpu, MSR_FSB_FREQ, &msr))\n\t\tfprintf(outf, \"SLM BCLK: unknown\\n\");\n\n\ti = msr & 0xf;\n\tif (i >= SLM_BCLK_FREQS) {\n\t\tfprintf(outf, \"SLM BCLK[%d] invalid\\n\", i);\n\t\ti = 3;\n\t}\n\tfreq = slm_freq_table[i];\n\n\tif (!quiet)\n\t\tfprintf(outf, \"SLM BCLK: %.1f Mhz\\n\", freq);\n\n\treturn freq;\n}\n\ndouble discover_bclk(unsigned int family, unsigned int model)\n{\n\tif (has_snb_msrs(family, model) || is_knl(family, model))\n\t\treturn 100.00;\n\telse if (is_slm(family, model))\n\t\treturn slm_bclk();\n\telse\n\t\treturn 133.33;\n}\n\nint get_cpu_type(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\n\tUNUSED(c);\n\tUNUSED(p);\n\n\tif (!genuine_intel)\n\t\treturn 0;\n\n\tif (cpu_migrate(t->cpu_id)) {\n\t\tfprintf(outf, \"Could not migrate to CPU %d\\n\", t->cpu_id);\n\t\treturn -1;\n\t}\n\n\tif (max_level < 0x1a)\n\t\treturn 0;\n\n\t__cpuid(0x1a, eax, ebx, ecx, edx);\n\teax = (eax >> 24) & 0xFF;\n\tif (eax == 0x20)\n\t\tt->is_atom = true;\n\treturn 0;\n}\n\n \nint set_temperature_target(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tunsigned long long msr;\n\tunsigned int tcc_default, tcc_offset;\n\tint cpu;\n\n\tUNUSED(c);\n\tUNUSED(p);\n\n\t \n\tif (!(do_dts || do_ptm))\n\t\treturn 0;\n\n\t \n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tcpu = t->cpu_id;\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(outf, \"Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tif (tj_max_override != 0) {\n\t\ttj_max = tj_max_override;\n\t\tfprintf(outf, \"cpu%d: Using cmdline TCC Target (%d C)\\n\", cpu, tj_max);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!do_nhm_platform_info)\n\t\tgoto guess;\n\n\tif (get_msr(base_cpu, MSR_IA32_TEMPERATURE_TARGET, &msr))\n\t\tgoto guess;\n\n\ttcc_default = (msr >> 16) & 0xFF;\n\n\tif (!quiet) {\n\t\tswitch (tcc_offset_bits) {\n\t\tcase 4:\n\t\t\ttcc_offset = (msr >> 24) & 0xF;\n\t\t\tfprintf(outf, \"cpu%d: MSR_IA32_TEMPERATURE_TARGET: 0x%08llx (%d C) (%d default - %d offset)\\n\",\n\t\t\t\tcpu, msr, tcc_default - tcc_offset, tcc_default, tcc_offset);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\ttcc_offset = (msr >> 24) & 0x3F;\n\t\t\tfprintf(outf, \"cpu%d: MSR_IA32_TEMPERATURE_TARGET: 0x%08llx (%d C) (%d default - %d offset)\\n\",\n\t\t\t\tcpu, msr, tcc_default - tcc_offset, tcc_default, tcc_offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(outf, \"cpu%d: MSR_IA32_TEMPERATURE_TARGET: 0x%08llx (%d C)\\n\", cpu, msr, tcc_default);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!tcc_default)\n\t\tgoto guess;\n\n\ttj_max = tcc_default;\n\n\treturn 0;\n\nguess:\n\ttj_max = TJMAX_DEFAULT;\n\tfprintf(outf, \"cpu%d: Guessing tjMax %d C, Please use -T to specify\\n\", cpu, tj_max);\n\n\treturn 0;\n}\n\nvoid decode_feature_control_msr(void)\n{\n\tunsigned long long msr;\n\n\tif (!get_msr(base_cpu, MSR_IA32_FEAT_CTL, &msr))\n\t\tfprintf(outf, \"cpu%d: MSR_IA32_FEATURE_CONTROL: 0x%08llx (%sLocked %s)\\n\",\n\t\t\tbase_cpu, msr, msr & FEAT_CTL_LOCKED ? \"\" : \"UN-\", msr & (1 << 18) ? \"SGX\" : \"\");\n}\n\nvoid decode_misc_enable_msr(void)\n{\n\tunsigned long long msr;\n\n\tif (!genuine_intel)\n\t\treturn;\n\n\tif (!get_msr(base_cpu, MSR_IA32_MISC_ENABLE, &msr))\n\t\tfprintf(outf, \"cpu%d: MSR_IA32_MISC_ENABLE: 0x%08llx (%sTCC %sEIST %sMWAIT %sPREFETCH %sTURBO)\\n\",\n\t\t\tbase_cpu, msr,\n\t\t\tmsr & MSR_IA32_MISC_ENABLE_TM1 ? \"\" : \"No-\",\n\t\t\tmsr & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP ? \"\" : \"No-\",\n\t\t\tmsr & MSR_IA32_MISC_ENABLE_MWAIT ? \"\" : \"No-\",\n\t\t\tmsr & MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE ? \"No-\" : \"\",\n\t\t\tmsr & MSR_IA32_MISC_ENABLE_TURBO_DISABLE ? \"No-\" : \"\");\n}\n\nvoid decode_misc_feature_control(void)\n{\n\tunsigned long long msr;\n\n\tif (!has_misc_feature_control)\n\t\treturn;\n\n\tif (!get_msr(base_cpu, MSR_MISC_FEATURE_CONTROL, &msr))\n\t\tfprintf(outf,\n\t\t\t\"cpu%d: MSR_MISC_FEATURE_CONTROL: 0x%08llx (%sL2-Prefetch %sL2-Prefetch-pair %sL1-Prefetch %sL1-IP-Prefetch)\\n\",\n\t\t\tbase_cpu, msr, msr & (0 << 0) ? \"No-\" : \"\", msr & (1 << 0) ? \"No-\" : \"\",\n\t\t\tmsr & (2 << 0) ? \"No-\" : \"\", msr & (3 << 0) ? \"No-\" : \"\");\n}\n\n \nvoid decode_misc_pwr_mgmt_msr(void)\n{\n\tunsigned long long msr;\n\n\tif (!do_nhm_platform_info)\n\t\treturn;\n\n\tif (no_MSR_MISC_PWR_MGMT)\n\t\treturn;\n\n\tif (!get_msr(base_cpu, MSR_MISC_PWR_MGMT, &msr))\n\t\tfprintf(outf, \"cpu%d: MSR_MISC_PWR_MGMT: 0x%08llx (%sable-EIST_Coordination %sable-EPB %sable-OOB)\\n\",\n\t\t\tbase_cpu, msr,\n\t\t\tmsr & (1 << 0) ? \"DIS\" : \"EN\", msr & (1 << 1) ? \"EN\" : \"DIS\", msr & (1 << 8) ? \"EN\" : \"DIS\");\n}\n\n \nvoid decode_c6_demotion_policy_msr(void)\n{\n\tunsigned long long msr;\n\n\tif (!get_msr(base_cpu, MSR_CC6_DEMOTION_POLICY_CONFIG, &msr))\n\t\tfprintf(outf, \"cpu%d: MSR_CC6_DEMOTION_POLICY_CONFIG: 0x%08llx (%sable-CC6-Demotion)\\n\",\n\t\t\tbase_cpu, msr, msr & (1 << 0) ? \"EN\" : \"DIS\");\n\n\tif (!get_msr(base_cpu, MSR_MC6_DEMOTION_POLICY_CONFIG, &msr))\n\t\tfprintf(outf, \"cpu%d: MSR_MC6_DEMOTION_POLICY_CONFIG: 0x%08llx (%sable-MC6-Demotion)\\n\",\n\t\t\tbase_cpu, msr, msr & (1 << 0) ? \"EN\" : \"DIS\");\n}\n\n \nunsigned int intel_model_duplicates(unsigned int model)\n{\n\n\tswitch (model) {\n\tcase INTEL_FAM6_NEHALEM_EP:\t \n\tcase INTEL_FAM6_NEHALEM:\t \n\tcase 0x1F:\t\t \n\tcase INTEL_FAM6_WESTMERE:\t \n\tcase INTEL_FAM6_WESTMERE_EP:\t \n\t\treturn INTEL_FAM6_NEHALEM;\n\n\tcase INTEL_FAM6_NEHALEM_EX:\t \n\tcase INTEL_FAM6_WESTMERE_EX:\t \n\t\treturn INTEL_FAM6_NEHALEM_EX;\n\n\tcase INTEL_FAM6_XEON_PHI_KNM:\n\t\treturn INTEL_FAM6_XEON_PHI_KNL;\n\n\tcase INTEL_FAM6_BROADWELL_X:\n\tcase INTEL_FAM6_BROADWELL_D:\t \n\t\treturn INTEL_FAM6_BROADWELL_X;\n\n\tcase INTEL_FAM6_SKYLAKE_L:\n\tcase INTEL_FAM6_SKYLAKE:\n\tcase INTEL_FAM6_KABYLAKE_L:\n\tcase INTEL_FAM6_KABYLAKE:\n\tcase INTEL_FAM6_COMETLAKE_L:\n\tcase INTEL_FAM6_COMETLAKE:\n\t\treturn INTEL_FAM6_SKYLAKE_L;\n\n\tcase INTEL_FAM6_ICELAKE_L:\n\tcase INTEL_FAM6_ICELAKE_NNPI:\n\tcase INTEL_FAM6_TIGERLAKE_L:\n\tcase INTEL_FAM6_TIGERLAKE:\n\tcase INTEL_FAM6_ROCKETLAKE:\n\tcase INTEL_FAM6_LAKEFIELD:\n\tcase INTEL_FAM6_ALDERLAKE:\n\tcase INTEL_FAM6_ALDERLAKE_L:\n\tcase INTEL_FAM6_ATOM_GRACEMONT:\n\tcase INTEL_FAM6_RAPTORLAKE:\n\tcase INTEL_FAM6_RAPTORLAKE_P:\n\tcase INTEL_FAM6_RAPTORLAKE_S:\n\tcase INTEL_FAM6_METEORLAKE:\n\tcase INTEL_FAM6_METEORLAKE_L:\n\t\treturn INTEL_FAM6_CANNONLAKE_L;\n\n\tcase INTEL_FAM6_ATOM_TREMONT_L:\n\t\treturn INTEL_FAM6_ATOM_TREMONT;\n\n\tcase INTEL_FAM6_ICELAKE_D:\n\t\treturn INTEL_FAM6_ICELAKE_X;\n\n\tcase INTEL_FAM6_EMERALDRAPIDS_X:\n\t\treturn INTEL_FAM6_SAPPHIRERAPIDS_X;\n\t}\n\treturn model;\n}\n\nvoid print_dev_latency(void)\n{\n\tchar *path = \"/dev/cpu_dma_latency\";\n\tint fd;\n\tint value;\n\tint retval;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0) {\n\t\twarnx(\"capget(CAP_SYS_ADMIN) failed, try \\\"# setcap cap_sys_admin=ep %s\\\"\", progname);\n\t\treturn;\n\t}\n\n\tretval = read(fd, (void *)&value, sizeof(int));\n\tif (retval != sizeof(int)) {\n\t\twarn(\"read failed %s\", path);\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tfprintf(outf, \"/dev/cpu_dma_latency: %d usec (%s)\\n\", value, value == 2000000000 ? \"default\" : \"constrained\");\n\n\tclose(fd);\n}\n\n \nvoid linux_perf_init(void)\n{\n\tif (!BIC_IS_ENABLED(BIC_IPC))\n\t\treturn;\n\n\tif (access(\"/proc/sys/kernel/perf_event_paranoid\", F_OK))\n\t\treturn;\n\n\tfd_instr_count_percpu = calloc(topo.max_cpu_num + 1, sizeof(int));\n\tif (fd_instr_count_percpu == NULL)\n\t\terr(-1, \"calloc fd_instr_count_percpu\");\n\n\tBIC_PRESENT(BIC_IPC);\n}\n\nvoid process_cpuid()\n{\n\tunsigned int eax, ebx, ecx, edx;\n\tunsigned int fms, family, model, stepping, ecx_flags, edx_flags;\n\tunsigned long long ucode_patch = 0;\n\n\teax = ebx = ecx = edx = 0;\n\n\t__cpuid(0, max_level, ebx, ecx, edx);\n\n\tif (ebx == 0x756e6547 && ecx == 0x6c65746e && edx == 0x49656e69)\n\t\tgenuine_intel = 1;\n\telse if (ebx == 0x68747541 && ecx == 0x444d4163 && edx == 0x69746e65)\n\t\tauthentic_amd = 1;\n\telse if (ebx == 0x6f677948 && ecx == 0x656e6975 && edx == 0x6e65476e)\n\t\thygon_genuine = 1;\n\n\tif (!quiet)\n\t\tfprintf(outf, \"CPUID(0): %.4s%.4s%.4s 0x%x CPUID levels\\n\",\n\t\t\t(char *)&ebx, (char *)&edx, (char *)&ecx, max_level);\n\n\t__cpuid(1, fms, ebx, ecx, edx);\n\tfamily = (fms >> 8) & 0xf;\n\tmodel = (fms >> 4) & 0xf;\n\tstepping = fms & 0xf;\n\tif (family == 0xf)\n\t\tfamily += (fms >> 20) & 0xff;\n\tif (family >= 6)\n\t\tmodel += ((fms >> 16) & 0xf) << 4;\n\tecx_flags = ecx;\n\tedx_flags = edx;\n\n\tif (get_msr(sched_getcpu(), MSR_IA32_UCODE_REV, &ucode_patch))\n\t\twarnx(\"get_msr(UCODE)\");\n\n\t \n\tebx = ecx = edx = 0;\n\t__cpuid(0x80000000, max_extended_level, ebx, ecx, edx);\n\n\tif (!quiet) {\n\t\tfprintf(outf, \"CPUID(1): family:model:stepping 0x%x:%x:%x (%d:%d:%d) microcode 0x%x\\n\",\n\t\t\tfamily, model, stepping, family, model, stepping,\n\t\t\t(unsigned int)((ucode_patch >> 32) & 0xFFFFFFFF));\n\t\tfprintf(outf, \"CPUID(0x80000000): max_extended_levels: 0x%x\\n\", max_extended_level);\n\t\tfprintf(outf, \"CPUID(1): %s %s %s %s %s %s %s %s %s %s\\n\",\n\t\t\tecx_flags & (1 << 0) ? \"SSE3\" : \"-\",\n\t\t\tecx_flags & (1 << 3) ? \"MONITOR\" : \"-\",\n\t\t\tecx_flags & (1 << 6) ? \"SMX\" : \"-\",\n\t\t\tecx_flags & (1 << 7) ? \"EIST\" : \"-\",\n\t\t\tecx_flags & (1 << 8) ? \"TM2\" : \"-\",\n\t\t\tedx_flags & (1 << 4) ? \"TSC\" : \"-\",\n\t\t\tedx_flags & (1 << 5) ? \"MSR\" : \"-\",\n\t\t\tedx_flags & (1 << 22) ? \"ACPI-TM\" : \"-\",\n\t\t\tedx_flags & (1 << 28) ? \"HT\" : \"-\", edx_flags & (1 << 29) ? \"TM\" : \"-\");\n\t}\n\tif (genuine_intel) {\n\t\tmodel_orig = model;\n\t\tmodel = intel_model_duplicates(model);\n\t}\n\n\tif (!(edx_flags & (1 << 5)))\n\t\terrx(1, \"CPUID: no MSR\");\n\n\tif (max_extended_level >= 0x80000007) {\n\n\t\t \n\t\t__cpuid(0x80000007, eax, ebx, ecx, edx);\n\t\thas_invariant_tsc = edx & (1 << 8);\n\t}\n\n\t \n\n\t__cpuid(0x6, eax, ebx, ecx, edx);\n\thas_aperf = ecx & (1 << 0);\n\tif (has_aperf) {\n\t\tBIC_PRESENT(BIC_Avg_MHz);\n\t\tBIC_PRESENT(BIC_Busy);\n\t\tBIC_PRESENT(BIC_Bzy_MHz);\n\t}\n\tdo_dts = eax & (1 << 0);\n\tif (do_dts)\n\t\tBIC_PRESENT(BIC_CoreTmp);\n\thas_turbo = eax & (1 << 1);\n\tdo_ptm = eax & (1 << 6);\n\tif (do_ptm)\n\t\tBIC_PRESENT(BIC_PkgTmp);\n\thas_hwp = eax & (1 << 7);\n\thas_hwp_notify = eax & (1 << 8);\n\thas_hwp_activity_window = eax & (1 << 9);\n\thas_hwp_epp = eax & (1 << 10);\n\thas_hwp_pkg = eax & (1 << 11);\n\thas_epb = ecx & (1 << 3);\n\n\tif (!quiet)\n\t\tfprintf(outf, \"CPUID(6): %sAPERF, %sTURBO, %sDTS, %sPTM, %sHWP, \"\n\t\t\t\"%sHWPnotify, %sHWPwindow, %sHWPepp, %sHWPpkg, %sEPB\\n\",\n\t\t\thas_aperf ? \"\" : \"No-\",\n\t\t\thas_turbo ? \"\" : \"No-\",\n\t\t\tdo_dts ? \"\" : \"No-\",\n\t\t\tdo_ptm ? \"\" : \"No-\",\n\t\t\thas_hwp ? \"\" : \"No-\",\n\t\t\thas_hwp_notify ? \"\" : \"No-\",\n\t\t\thas_hwp_activity_window ? \"\" : \"No-\",\n\t\t\thas_hwp_epp ? \"\" : \"No-\", has_hwp_pkg ? \"\" : \"No-\", has_epb ? \"\" : \"No-\");\n\n\tif (!quiet)\n\t\tdecode_misc_enable_msr();\n\n\tif (max_level >= 0x7 && !quiet) {\n\t\tint has_sgx;\n\n\t\tecx = 0;\n\n\t\t__cpuid_count(0x7, 0, eax, ebx, ecx, edx);\n\n\t\thas_sgx = ebx & (1 << 2);\n\n\t\tis_hybrid = edx & (1 << 15);\n\n\t\tfprintf(outf, \"CPUID(7): %sSGX %sHybrid\\n\", has_sgx ? \"\" : \"No-\", is_hybrid ? \"\" : \"No-\");\n\n\t\tif (has_sgx)\n\t\t\tdecode_feature_control_msr();\n\t}\n\n\tif (max_level >= 0x15) {\n\t\tunsigned int eax_crystal;\n\t\tunsigned int ebx_tsc;\n\n\t\t \n\t\teax_crystal = ebx_tsc = crystal_hz = edx = 0;\n\t\t__cpuid(0x15, eax_crystal, ebx_tsc, crystal_hz, edx);\n\n\t\tif (ebx_tsc != 0) {\n\n\t\t\tif (!quiet && (ebx != 0))\n\t\t\t\tfprintf(outf, \"CPUID(0x15): eax_crystal: %d ebx_tsc: %d ecx_crystal_hz: %d\\n\",\n\t\t\t\t\teax_crystal, ebx_tsc, crystal_hz);\n\n\t\t\tif (crystal_hz == 0)\n\t\t\t\tswitch (model) {\n\t\t\t\tcase INTEL_FAM6_SKYLAKE_L:\t \n\t\t\t\t\tcrystal_hz = 24000000;\t \n\t\t\t\t\tbreak;\n\t\t\t\tcase INTEL_FAM6_ATOM_GOLDMONT_D:\t \n\t\t\t\t\tcrystal_hz = 25000000;\t \n\t\t\t\t\tbreak;\n\t\t\t\tcase INTEL_FAM6_ATOM_GOLDMONT:\t \n\t\t\t\tcase INTEL_FAM6_ATOM_GOLDMONT_PLUS:\n\t\t\t\t\tcrystal_hz = 19200000;\t \n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcrystal_hz = 0;\n\t\t\t\t}\n\n\t\t\tif (crystal_hz) {\n\t\t\t\ttsc_hz = (unsigned long long)crystal_hz *ebx_tsc / eax_crystal;\n\t\t\t\tif (!quiet)\n\t\t\t\t\tfprintf(outf, \"TSC: %lld MHz (%d Hz * %d / %d / 1000000)\\n\",\n\t\t\t\t\t\ttsc_hz / 1000000, crystal_hz, ebx_tsc, eax_crystal);\n\t\t\t}\n\t\t}\n\t}\n\tif (max_level >= 0x16) {\n\t\tunsigned int base_mhz, max_mhz, bus_mhz, edx;\n\n\t\t \n\t\tbase_mhz = max_mhz = bus_mhz = edx = 0;\n\n\t\t__cpuid(0x16, base_mhz, max_mhz, bus_mhz, edx);\n\t\tif (!quiet)\n\t\t\tfprintf(outf, \"CPUID(0x16): base_mhz: %d max_mhz: %d bus_mhz: %d\\n\",\n\t\t\t\tbase_mhz, max_mhz, bus_mhz);\n\t}\n\n\tif (has_aperf)\n\t\taperf_mperf_multiplier = get_aperf_mperf_multiplier(family, model);\n\n\tBIC_PRESENT(BIC_IRQ);\n\tBIC_PRESENT(BIC_TSC_MHz);\n\n\tif (probe_nhm_msrs(family, model)) {\n\t\tdo_nhm_platform_info = 1;\n\t\tBIC_PRESENT(BIC_CPU_c1);\n\t\tBIC_PRESENT(BIC_CPU_c3);\n\t\tBIC_PRESENT(BIC_CPU_c6);\n\t\tBIC_PRESENT(BIC_SMI);\n\t}\n\tdo_snb_cstates = has_snb_msrs(family, model);\n\n\tif (do_snb_cstates)\n\t\tBIC_PRESENT(BIC_CPU_c7);\n\n\tdo_irtl_snb = has_snb_msrs(family, model);\n\tif (do_snb_cstates && (pkg_cstate_limit >= PCL__2))\n\t\tBIC_PRESENT(BIC_Pkgpc2);\n\tif (pkg_cstate_limit >= PCL__3)\n\t\tBIC_PRESENT(BIC_Pkgpc3);\n\tif (pkg_cstate_limit >= PCL__6)\n\t\tBIC_PRESENT(BIC_Pkgpc6);\n\tif (do_snb_cstates && (pkg_cstate_limit >= PCL__7))\n\t\tBIC_PRESENT(BIC_Pkgpc7);\n\tif (has_slv_msrs(family, model)) {\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc2);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc3);\n\t\tBIC_PRESENT(BIC_Pkgpc6);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc7);\n\t\tBIC_PRESENT(BIC_Mod_c6);\n\t\tuse_c1_residency_msr = 1;\n\t}\n\tif (is_jvl(family, model)) {\n\t\tBIC_NOT_PRESENT(BIC_CPU_c3);\n\t\tBIC_NOT_PRESENT(BIC_CPU_c7);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc2);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc3);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc6);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc7);\n\t}\n\tif (is_dnv(family, model)) {\n\t\tBIC_PRESENT(BIC_CPU_c1);\n\t\tBIC_NOT_PRESENT(BIC_CPU_c3);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc3);\n\t\tBIC_NOT_PRESENT(BIC_CPU_c7);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc7);\n\t\tuse_c1_residency_msr = 1;\n\t}\n\tif (is_skx(family, model) || is_icx(family, model) || is_spr(family, model)) {\n\t\tBIC_NOT_PRESENT(BIC_CPU_c3);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc3);\n\t\tBIC_NOT_PRESENT(BIC_CPU_c7);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc7);\n\t}\n\tif (is_bdx(family, model)) {\n\t\tBIC_NOT_PRESENT(BIC_CPU_c7);\n\t\tBIC_NOT_PRESENT(BIC_Pkgpc7);\n\t}\n\tif (has_c8910_msrs(family, model)) {\n\t\tif (pkg_cstate_limit >= PCL__8)\n\t\t\tBIC_PRESENT(BIC_Pkgpc8);\n\t\tif (pkg_cstate_limit >= PCL__9)\n\t\t\tBIC_PRESENT(BIC_Pkgpc9);\n\t\tif (pkg_cstate_limit >= PCL_10)\n\t\t\tBIC_PRESENT(BIC_Pkgpc10);\n\t}\n\tdo_irtl_hsw = has_c8910_msrs(family, model);\n\tif (has_skl_msrs(family, model)) {\n\t\tBIC_PRESENT(BIC_Totl_c0);\n\t\tBIC_PRESENT(BIC_Any_c0);\n\t\tBIC_PRESENT(BIC_GFX_c0);\n\t\tBIC_PRESENT(BIC_CPUGFX);\n\t}\n\tdo_slm_cstates = is_slm(family, model);\n\tdo_knl_cstates = is_knl(family, model);\n\n\tif (do_slm_cstates || do_knl_cstates || is_cnl(family, model) || is_ehl(family, model))\n\t\tBIC_NOT_PRESENT(BIC_CPU_c3);\n\n\tif (!quiet)\n\t\tdecode_misc_pwr_mgmt_msr();\n\n\tif (!quiet && has_slv_msrs(family, model))\n\t\tdecode_c6_demotion_policy_msr();\n\n\trapl_probe(family, model);\n\tperf_limit_reasons_probe(family, model);\n\tautomatic_cstate_conversion_probe(family, model);\n\tprewake_cstate_probe(family, model);\n\n\tcheck_tcc_offset(model_orig);\n\n\tif (!quiet)\n\t\tdump_cstate_pstate_config_info(family, model);\n\tintel_uncore_frequency_probe();\n\n\tif (!quiet)\n\t\tprint_dev_latency();\n\tif (!quiet)\n\t\tdump_sysfs_cstate_config();\n\tif (!quiet)\n\t\tdump_sysfs_pstate_config();\n\n\tif (has_skl_msrs(family, model) || is_ehl(family, model))\n\t\tcalculate_tsc_tweak();\n\n\tif (!access(\"/sys/class/drm/card0/power/rc6_residency_ms\", R_OK))\n\t\tBIC_PRESENT(BIC_GFX_rc6);\n\n\tif (!access(\"/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz\", R_OK))\n\t\tBIC_PRESENT(BIC_GFXMHz);\n\n\tif (!access(\"/sys/class/graphics/fb0/device/drm/card0/gt_act_freq_mhz\", R_OK))\n\t\tBIC_PRESENT(BIC_GFXACTMHz);\n\n\tif (!access(\"/sys/devices/system/cpu/cpuidle/low_power_idle_cpu_residency_us\", R_OK))\n\t\tBIC_PRESENT(BIC_CPU_LPI);\n\telse\n\t\tBIC_NOT_PRESENT(BIC_CPU_LPI);\n\n\tif (!access(\"/sys/devices/system/cpu/cpu0/thermal_throttle/core_throttle_count\", R_OK))\n\t\tBIC_PRESENT(BIC_CORE_THROT_CNT);\n\telse\n\t\tBIC_NOT_PRESENT(BIC_CORE_THROT_CNT);\n\n\tif (!access(sys_lpi_file_sysfs, R_OK)) {\n\t\tsys_lpi_file = sys_lpi_file_sysfs;\n\t\tBIC_PRESENT(BIC_SYS_LPI);\n\t} else if (!access(sys_lpi_file_debugfs, R_OK)) {\n\t\tsys_lpi_file = sys_lpi_file_debugfs;\n\t\tBIC_PRESENT(BIC_SYS_LPI);\n\t} else {\n\t\tsys_lpi_file_sysfs = NULL;\n\t\tBIC_NOT_PRESENT(BIC_SYS_LPI);\n\t}\n\n\tif (!quiet)\n\t\tdecode_misc_feature_control();\n\n\treturn;\n}\n\n \nint dir_filter(const struct dirent *dirp)\n{\n\tif (isdigit(dirp->d_name[0]))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nvoid topology_probe()\n{\n\tint i;\n\tint max_core_id = 0;\n\tint max_package_id = 0;\n\tint max_die_id = 0;\n\tint max_siblings = 0;\n\n\t \n\tset_max_cpu_num();\n\ttopo.num_cpus = 0;\n\tfor_all_proc_cpus(count_cpus);\n\tif (!summary_only && topo.num_cpus > 1)\n\t\tBIC_PRESENT(BIC_CPU);\n\n\tif (debug > 1)\n\t\tfprintf(outf, \"num_cpus %d max_cpu_num %d\\n\", topo.num_cpus, topo.max_cpu_num);\n\n\tcpus = calloc(1, (topo.max_cpu_num + 1) * sizeof(struct cpu_topology));\n\tif (cpus == NULL)\n\t\terr(1, \"calloc cpus\");\n\n\t \n\tcpu_present_set = CPU_ALLOC((topo.max_cpu_num + 1));\n\tif (cpu_present_set == NULL)\n\t\terr(3, \"CPU_ALLOC\");\n\tcpu_present_setsize = CPU_ALLOC_SIZE((topo.max_cpu_num + 1));\n\tCPU_ZERO_S(cpu_present_setsize, cpu_present_set);\n\tfor_all_proc_cpus(mark_cpu_present);\n\n\t \n\tfor (i = 0; i < CPU_SUBSET_MAXCPUS; ++i) {\n\t\tif (CPU_ISSET_S(i, cpu_subset_size, cpu_subset))\n\t\t\tif (!CPU_ISSET_S(i, cpu_present_setsize, cpu_present_set))\n\t\t\t\terr(1, \"cpu%d not present\", i);\n\t}\n\n\t \n\tcpu_affinity_set = CPU_ALLOC((topo.max_cpu_num + 1));\n\tif (cpu_affinity_set == NULL)\n\t\terr(3, \"CPU_ALLOC\");\n\tcpu_affinity_setsize = CPU_ALLOC_SIZE((topo.max_cpu_num + 1));\n\tCPU_ZERO_S(cpu_affinity_setsize, cpu_affinity_set);\n\n\tfor_all_proc_cpus(init_thread_id);\n\n\t \n\tfor (i = 0; i <= topo.max_cpu_num; ++i) {\n\t\tint siblings;\n\n\t\tif (cpu_is_not_present(i)) {\n\t\t\tif (debug > 1)\n\t\t\t\tfprintf(outf, \"cpu%d NOT PRESENT\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpus[i].logical_cpu_id = i;\n\n\t\t \n\t\tcpus[i].physical_package_id = get_physical_package_id(i);\n\t\tif (cpus[i].physical_package_id > max_package_id)\n\t\t\tmax_package_id = cpus[i].physical_package_id;\n\n\t\t \n\t\tcpus[i].die_id = get_die_id(i);\n\t\tif (cpus[i].die_id > max_die_id)\n\t\t\tmax_die_id = cpus[i].die_id;\n\n\t\t \n\t\tcpus[i].physical_node_id = get_physical_node_id(&cpus[i]);\n\t\tif (cpus[i].physical_node_id > topo.max_node_num)\n\t\t\ttopo.max_node_num = cpus[i].physical_node_id;\n\n\t\t \n\t\tcpus[i].physical_core_id = get_core_id(i);\n\t\tif (cpus[i].physical_core_id > max_core_id)\n\t\t\tmax_core_id = cpus[i].physical_core_id;\n\n\t\t \n\t\tsiblings = get_thread_siblings(&cpus[i]);\n\t\tif (siblings > max_siblings)\n\t\t\tmax_siblings = siblings;\n\t\tif (cpus[i].thread_id == 0)\n\t\t\ttopo.num_cores++;\n\t}\n\n\ttopo.cores_per_node = max_core_id + 1;\n\tif (debug > 1)\n\t\tfprintf(outf, \"max_core_id %d, sizing for %d cores per package\\n\", max_core_id, topo.cores_per_node);\n\tif (!summary_only && topo.cores_per_node > 1)\n\t\tBIC_PRESENT(BIC_Core);\n\n\ttopo.num_die = max_die_id + 1;\n\tif (debug > 1)\n\t\tfprintf(outf, \"max_die_id %d, sizing for %d die\\n\", max_die_id, topo.num_die);\n\tif (!summary_only && topo.num_die > 1)\n\t\tBIC_PRESENT(BIC_Die);\n\n\ttopo.num_packages = max_package_id + 1;\n\tif (debug > 1)\n\t\tfprintf(outf, \"max_package_id %d, sizing for %d packages\\n\", max_package_id, topo.num_packages);\n\tif (!summary_only && topo.num_packages > 1)\n\t\tBIC_PRESENT(BIC_Package);\n\n\tset_node_data();\n\tif (debug > 1)\n\t\tfprintf(outf, \"nodes_per_pkg %d\\n\", topo.nodes_per_pkg);\n\tif (!summary_only && topo.nodes_per_pkg > 1)\n\t\tBIC_PRESENT(BIC_Node);\n\n\ttopo.threads_per_core = max_siblings;\n\tif (debug > 1)\n\t\tfprintf(outf, \"max_siblings %d\\n\", max_siblings);\n\n\tif (debug < 1)\n\t\treturn;\n\n\tfor (i = 0; i <= topo.max_cpu_num; ++i) {\n\t\tif (cpu_is_not_present(i))\n\t\t\tcontinue;\n\t\tfprintf(outf,\n\t\t\t\"cpu %d pkg %d die %d node %d lnode %d core %d thread %d\\n\",\n\t\t\ti, cpus[i].physical_package_id, cpus[i].die_id,\n\t\t\tcpus[i].physical_node_id, cpus[i].logical_node_id, cpus[i].physical_core_id, cpus[i].thread_id);\n\t}\n\n}\n\nvoid allocate_counters(struct thread_data **t, struct core_data **c, struct pkg_data **p)\n{\n\tint i;\n\tint num_cores = topo.cores_per_node * topo.nodes_per_pkg * topo.num_packages;\n\tint num_threads = topo.threads_per_core * num_cores;\n\n\t*t = calloc(num_threads, sizeof(struct thread_data));\n\tif (*t == NULL)\n\t\tgoto error;\n\n\tfor (i = 0; i < num_threads; i++)\n\t\t(*t)[i].cpu_id = -1;\n\n\t*c = calloc(num_cores, sizeof(struct core_data));\n\tif (*c == NULL)\n\t\tgoto error;\n\n\tfor (i = 0; i < num_cores; i++)\n\t\t(*c)[i].core_id = -1;\n\n\t*p = calloc(topo.num_packages, sizeof(struct pkg_data));\n\tif (*p == NULL)\n\t\tgoto error;\n\n\tfor (i = 0; i < topo.num_packages; i++)\n\t\t(*p)[i].package_id = i;\n\n\treturn;\nerror:\n\terr(1, \"calloc counters\");\n}\n\n \nvoid init_counter(struct thread_data *thread_base, struct core_data *core_base, struct pkg_data *pkg_base, int cpu_id)\n{\n\tint pkg_id = cpus[cpu_id].physical_package_id;\n\tint node_id = cpus[cpu_id].logical_node_id;\n\tint core_id = cpus[cpu_id].physical_core_id;\n\tint thread_id = cpus[cpu_id].thread_id;\n\tstruct thread_data *t;\n\tstruct core_data *c;\n\tstruct pkg_data *p;\n\n\t \n\tif (node_id < 0)\n\t\tnode_id = 0;\n\n\tt = GET_THREAD(thread_base, thread_id, core_id, node_id, pkg_id);\n\tc = GET_CORE(core_base, core_id, node_id, pkg_id);\n\tp = GET_PKG(pkg_base, pkg_id);\n\n\tt->cpu_id = cpu_id;\n\tif (thread_id == 0) {\n\t\tt->flags |= CPU_IS_FIRST_THREAD_IN_CORE;\n\t\tif (cpu_is_first_core_in_package(cpu_id))\n\t\t\tt->flags |= CPU_IS_FIRST_CORE_IN_PACKAGE;\n\t}\n\n\tc->core_id = core_id;\n\tp->package_id = pkg_id;\n}\n\nint initialize_counters(int cpu_id)\n{\n\tinit_counter(EVEN_COUNTERS, cpu_id);\n\tinit_counter(ODD_COUNTERS, cpu_id);\n\treturn 0;\n}\n\nvoid allocate_output_buffer()\n{\n\toutput_buffer = calloc(1, (1 + topo.num_cpus) * 2048);\n\toutp = output_buffer;\n\tif (outp == NULL)\n\t\terr(-1, \"calloc output buffer\");\n}\n\nvoid allocate_fd_percpu(void)\n{\n\tfd_percpu = calloc(topo.max_cpu_num + 1, sizeof(int));\n\tif (fd_percpu == NULL)\n\t\terr(-1, \"calloc fd_percpu\");\n}\n\nvoid allocate_irq_buffers(void)\n{\n\tirq_column_2_cpu = calloc(topo.num_cpus, sizeof(int));\n\tif (irq_column_2_cpu == NULL)\n\t\terr(-1, \"calloc %d\", topo.num_cpus);\n\n\tirqs_per_cpu = calloc(topo.max_cpu_num + 1, sizeof(int));\n\tif (irqs_per_cpu == NULL)\n\t\terr(-1, \"calloc %d\", topo.max_cpu_num + 1);\n}\n\nvoid setup_all_buffers(void)\n{\n\ttopology_probe();\n\tallocate_irq_buffers();\n\tallocate_fd_percpu();\n\tallocate_counters(&thread_even, &core_even, &package_even);\n\tallocate_counters(&thread_odd, &core_odd, &package_odd);\n\tallocate_output_buffer();\n\tfor_all_proc_cpus(initialize_counters);\n}\n\nvoid set_base_cpu(void)\n{\n\tbase_cpu = sched_getcpu();\n\tif (base_cpu < 0)\n\t\terr(-ENODEV, \"No valid cpus found\");\n\n\tif (debug > 1)\n\t\tfprintf(outf, \"base_cpu = %d\\n\", base_cpu);\n}\n\nvoid turbostat_init()\n{\n\tsetup_all_buffers();\n\tset_base_cpu();\n\tcheck_dev_msr();\n\tcheck_permissions();\n\tprocess_cpuid();\n\tlinux_perf_init();\n\n\tif (!quiet)\n\t\tfor_all_cpus(print_hwp, ODD_COUNTERS);\n\n\tif (!quiet)\n\t\tfor_all_cpus(print_epb, ODD_COUNTERS);\n\n\tif (!quiet)\n\t\tfor_all_cpus(print_perf_limit, ODD_COUNTERS);\n\n\tif (!quiet)\n\t\tfor_all_cpus(print_rapl, ODD_COUNTERS);\n\n\tfor_all_cpus(set_temperature_target, ODD_COUNTERS);\n\n\tfor_all_cpus(get_cpu_type, ODD_COUNTERS);\n\tfor_all_cpus(get_cpu_type, EVEN_COUNTERS);\n\n\tif (!quiet)\n\t\tfor_all_cpus(print_thermal, ODD_COUNTERS);\n\n\tif (!quiet && do_irtl_snb)\n\t\tprint_irtl();\n\n\tif (DO_BIC(BIC_IPC))\n\t\t(void)get_instr_count_fd(base_cpu);\n}\n\nint fork_it(char **argv)\n{\n\tpid_t child_pid;\n\tint status;\n\n\tsnapshot_proc_sysfs_files();\n\tstatus = for_all_cpus(get_counters, EVEN_COUNTERS);\n\tfirst_counter_read = 0;\n\tif (status)\n\t\texit(status);\n\t \n\tsched_setaffinity(0, cpu_present_setsize, cpu_present_set);\n\tgettimeofday(&tv_even, (struct timezone *)NULL);\n\n\tchild_pid = fork();\n\tif (!child_pid) {\n\t\t \n\t\texecvp(argv[0], argv);\n\t\terr(errno, \"exec %s\", argv[0]);\n\t} else {\n\n\t\t \n\t\tif (child_pid == -1)\n\t\t\terr(1, \"fork\");\n\n\t\tsignal(SIGINT, SIG_IGN);\n\t\tsignal(SIGQUIT, SIG_IGN);\n\t\tif (waitpid(child_pid, &status, 0) == -1)\n\t\t\terr(status, \"waitpid\");\n\n\t\tif (WIFEXITED(status))\n\t\t\tstatus = WEXITSTATUS(status);\n\t}\n\t \n\tsnapshot_proc_sysfs_files();\n\tfor_all_cpus(get_counters, ODD_COUNTERS);\n\tgettimeofday(&tv_odd, (struct timezone *)NULL);\n\ttimersub(&tv_odd, &tv_even, &tv_delta);\n\tif (for_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS))\n\t\tfprintf(outf, \"%s: Counter reset detected\\n\", progname);\n\telse {\n\t\tcompute_average(EVEN_COUNTERS);\n\t\tformat_all_counters(EVEN_COUNTERS);\n\t}\n\n\tfprintf(outf, \"%.6f sec\\n\", tv_delta.tv_sec + tv_delta.tv_usec / 1000000.0);\n\n\tflush_output_stderr();\n\n\treturn status;\n}\n\nint get_and_dump_counters(void)\n{\n\tint status;\n\n\tsnapshot_proc_sysfs_files();\n\tstatus = for_all_cpus(get_counters, ODD_COUNTERS);\n\tif (status)\n\t\treturn status;\n\n\tstatus = for_all_cpus(dump_counters, ODD_COUNTERS);\n\tif (status)\n\t\treturn status;\n\n\tflush_output_stdout();\n\n\treturn status;\n}\n\nvoid print_version()\n{\n\tfprintf(outf, \"turbostat version 2023.03.17 - Len Brown <lenb@kernel.org>\\n\");\n}\n\n#define COMMAND_LINE_SIZE 2048\n\nvoid print_bootcmd(void)\n{\n\tchar bootcmd[COMMAND_LINE_SIZE];\n\tFILE *fp;\n\tint ret;\n\n\tmemset(bootcmd, 0, COMMAND_LINE_SIZE);\n\tfp = fopen(\"/proc/cmdline\", \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tret = fread(bootcmd, sizeof(char), COMMAND_LINE_SIZE - 1, fp);\n\tif (ret) {\n\t\tbootcmd[ret] = '\\0';\n\t\t \n\t\tfprintf(outf, \"Kernel command line: %s\", bootcmd);\n\t}\n\n\tfclose(fp);\n}\n\nint add_counter(unsigned int msr_num, char *path, char *name,\n\t\tunsigned int width, enum counter_scope scope,\n\t\tenum counter_type type, enum counter_format format, int flags)\n{\n\tstruct msr_counter *msrp;\n\n\tmsrp = calloc(1, sizeof(struct msr_counter));\n\tif (msrp == NULL) {\n\t\tperror(\"calloc\");\n\t\texit(1);\n\t}\n\n\tmsrp->msr_num = msr_num;\n\tstrncpy(msrp->name, name, NAME_BYTES - 1);\n\tif (path)\n\t\tstrncpy(msrp->path, path, PATH_BYTES - 1);\n\tmsrp->width = width;\n\tmsrp->type = type;\n\tmsrp->format = format;\n\tmsrp->flags = flags;\n\n\tswitch (scope) {\n\n\tcase SCOPE_CPU:\n\t\tmsrp->next = sys.tp;\n\t\tsys.tp = msrp;\n\t\tsys.added_thread_counters++;\n\t\tif (sys.added_thread_counters > MAX_ADDED_THREAD_COUNTERS) {\n\t\t\tfprintf(stderr, \"exceeded max %d added thread counters\\n\", MAX_ADDED_COUNTERS);\n\t\t\texit(-1);\n\t\t}\n\t\tbreak;\n\n\tcase SCOPE_CORE:\n\t\tmsrp->next = sys.cp;\n\t\tsys.cp = msrp;\n\t\tsys.added_core_counters++;\n\t\tif (sys.added_core_counters > MAX_ADDED_COUNTERS) {\n\t\t\tfprintf(stderr, \"exceeded max %d added core counters\\n\", MAX_ADDED_COUNTERS);\n\t\t\texit(-1);\n\t\t}\n\t\tbreak;\n\n\tcase SCOPE_PACKAGE:\n\t\tmsrp->next = sys.pp;\n\t\tsys.pp = msrp;\n\t\tsys.added_package_counters++;\n\t\tif (sys.added_package_counters > MAX_ADDED_COUNTERS) {\n\t\t\tfprintf(stderr, \"exceeded max %d added package counters\\n\", MAX_ADDED_COUNTERS);\n\t\t\texit(-1);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid parse_add_command(char *add_command)\n{\n\tint msr_num = 0;\n\tchar *path = NULL;\n\tchar name_buffer[NAME_BYTES] = \"\";\n\tint width = 64;\n\tint fail = 0;\n\tenum counter_scope scope = SCOPE_CPU;\n\tenum counter_type type = COUNTER_CYCLES;\n\tenum counter_format format = FORMAT_DELTA;\n\n\twhile (add_command) {\n\n\t\tif (sscanf(add_command, \"msr0x%x\", &msr_num) == 1)\n\t\t\tgoto next;\n\n\t\tif (sscanf(add_command, \"msr%d\", &msr_num) == 1)\n\t\t\tgoto next;\n\n\t\tif (*add_command == '/') {\n\t\t\tpath = add_command;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (sscanf(add_command, \"u%d\", &width) == 1) {\n\t\t\tif ((width == 32) || (width == 64))\n\t\t\t\tgoto next;\n\t\t\twidth = 64;\n\t\t}\n\t\tif (!strncmp(add_command, \"cpu\", strlen(\"cpu\"))) {\n\t\t\tscope = SCOPE_CPU;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!strncmp(add_command, \"core\", strlen(\"core\"))) {\n\t\t\tscope = SCOPE_CORE;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!strncmp(add_command, \"package\", strlen(\"package\"))) {\n\t\t\tscope = SCOPE_PACKAGE;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!strncmp(add_command, \"cycles\", strlen(\"cycles\"))) {\n\t\t\ttype = COUNTER_CYCLES;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!strncmp(add_command, \"seconds\", strlen(\"seconds\"))) {\n\t\t\ttype = COUNTER_SECONDS;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!strncmp(add_command, \"usec\", strlen(\"usec\"))) {\n\t\t\ttype = COUNTER_USEC;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!strncmp(add_command, \"raw\", strlen(\"raw\"))) {\n\t\t\tformat = FORMAT_RAW;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!strncmp(add_command, \"delta\", strlen(\"delta\"))) {\n\t\t\tformat = FORMAT_DELTA;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!strncmp(add_command, \"percent\", strlen(\"percent\"))) {\n\t\t\tformat = FORMAT_PERCENT;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (sscanf(add_command, \"%18s,%*s\", name_buffer) == 1) {\t \n\t\t\tchar *eos;\n\n\t\t\teos = strchr(name_buffer, ',');\n\t\t\tif (eos)\n\t\t\t\t*eos = '\\0';\n\t\t\tgoto next;\n\t\t}\n\nnext:\n\t\tadd_command = strchr(add_command, ',');\n\t\tif (add_command) {\n\t\t\t*add_command = '\\0';\n\t\t\tadd_command++;\n\t\t}\n\n\t}\n\tif ((msr_num == 0) && (path == NULL)) {\n\t\tfprintf(stderr, \"--add: (msrDDD | msr0xXXX | /path_to_counter ) required\\n\");\n\t\tfail++;\n\t}\n\n\t \n\tif (*name_buffer == '\\0') {\n\t\tif (width == 32)\n\t\t\tsprintf(name_buffer, \"M0x%x%s\", msr_num, format == FORMAT_PERCENT ? \"%\" : \"\");\n\t\telse\n\t\t\tsprintf(name_buffer, \"M0X%x%s\", msr_num, format == FORMAT_PERCENT ? \"%\" : \"\");\n\t}\n\n\tif (add_counter(msr_num, path, name_buffer, width, scope, type, format, 0))\n\t\tfail++;\n\n\tif (fail) {\n\t\thelp();\n\t\texit(1);\n\t}\n}\n\nint is_deferred_add(char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < deferred_add_index; ++i)\n\t\tif (!strcmp(name, deferred_add_names[i]))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nint is_deferred_skip(char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < deferred_skip_index; ++i)\n\t\tif (!strcmp(name, deferred_skip_names[i]))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nvoid probe_sysfs(void)\n{\n\tchar path[64];\n\tchar name_buf[16];\n\tFILE *input;\n\tint state;\n\tchar *sp;\n\n\tfor (state = 10; state >= 0; --state) {\n\n\t\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/cpuidle/state%d/name\", base_cpu, state);\n\t\tinput = fopen(path, \"r\");\n\t\tif (input == NULL)\n\t\t\tcontinue;\n\t\tif (!fgets(name_buf, sizeof(name_buf), input))\n\t\t\terr(1, \"%s: failed to read file\", path);\n\n\t\t \n\t\tsp = strchr(name_buf, '-');\n\t\tif (!sp)\n\t\t\tsp = strchrnul(name_buf, '\\n');\n\t\t*sp = '%';\n\t\t*(sp + 1) = '\\0';\n\n\t\tremove_underbar(name_buf);\n\n\t\tfclose(input);\n\n\t\tsprintf(path, \"cpuidle/state%d/time\", state);\n\n\t\tif (!DO_BIC(BIC_sysfs) && !is_deferred_add(name_buf))\n\t\t\tcontinue;\n\n\t\tif (is_deferred_skip(name_buf))\n\t\t\tcontinue;\n\n\t\tadd_counter(0, path, name_buf, 64, SCOPE_CPU, COUNTER_USEC, FORMAT_PERCENT, SYSFS_PERCPU);\n\t}\n\n\tfor (state = 10; state >= 0; --state) {\n\n\t\tsprintf(path, \"/sys/devices/system/cpu/cpu%d/cpuidle/state%d/name\", base_cpu, state);\n\t\tinput = fopen(path, \"r\");\n\t\tif (input == NULL)\n\t\t\tcontinue;\n\t\tif (!fgets(name_buf, sizeof(name_buf), input))\n\t\t\terr(1, \"%s: failed to read file\", path);\n\t\t \n\t\tsp = strchr(name_buf, '-');\n\t\tif (!sp)\n\t\t\tsp = strchrnul(name_buf, '\\n');\n\t\t*sp = '\\0';\n\t\tfclose(input);\n\n\t\tremove_underbar(name_buf);\n\n\t\tsprintf(path, \"cpuidle/state%d/usage\", state);\n\n\t\tif (!DO_BIC(BIC_sysfs) && !is_deferred_add(name_buf))\n\t\t\tcontinue;\n\n\t\tif (is_deferred_skip(name_buf))\n\t\t\tcontinue;\n\n\t\tadd_counter(0, path, name_buf, 64, SCOPE_CPU, COUNTER_ITEMS, FORMAT_DELTA, SYSFS_PERCPU);\n\t}\n\n}\n\n \nvoid parse_cpu_command(char *optarg)\n{\n\tunsigned int start, end;\n\tchar *next;\n\n\tif (!strcmp(optarg, \"core\")) {\n\t\tif (cpu_subset)\n\t\t\tgoto error;\n\t\tshow_core_only++;\n\t\treturn;\n\t}\n\tif (!strcmp(optarg, \"package\")) {\n\t\tif (cpu_subset)\n\t\t\tgoto error;\n\t\tshow_pkg_only++;\n\t\treturn;\n\t}\n\tif (show_core_only || show_pkg_only)\n\t\tgoto error;\n\n\tcpu_subset = CPU_ALLOC(CPU_SUBSET_MAXCPUS);\n\tif (cpu_subset == NULL)\n\t\terr(3, \"CPU_ALLOC\");\n\tcpu_subset_size = CPU_ALLOC_SIZE(CPU_SUBSET_MAXCPUS);\n\n\tCPU_ZERO_S(cpu_subset_size, cpu_subset);\n\n\tnext = optarg;\n\n\twhile (next && *next) {\n\n\t\tif (*next == '-')\t \n\t\t\tgoto error;\n\n\t\tstart = strtoul(next, &next, 10);\n\n\t\tif (start >= CPU_SUBSET_MAXCPUS)\n\t\t\tgoto error;\n\t\tCPU_SET_S(start, cpu_subset_size, cpu_subset);\n\n\t\tif (*next == '\\0')\n\t\t\tbreak;\n\n\t\tif (*next == ',') {\n\t\t\tnext += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*next == '-') {\n\t\t\tnext += 1;\t \n\t\t} else if (*next == '.') {\n\t\t\tnext += 1;\n\t\t\tif (*next == '.')\n\t\t\t\tnext += 1;\t \n\t\t\telse\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tend = strtoul(next, &next, 10);\n\t\tif (end <= start)\n\t\t\tgoto error;\n\n\t\twhile (++start <= end) {\n\t\t\tif (start >= CPU_SUBSET_MAXCPUS)\n\t\t\t\tgoto error;\n\t\t\tCPU_SET_S(start, cpu_subset_size, cpu_subset);\n\t\t}\n\n\t\tif (*next == ',')\n\t\t\tnext += 1;\n\t\telse if (*next != '\\0')\n\t\t\tgoto error;\n\t}\n\n\treturn;\n\nerror:\n\tfprintf(stderr, \"\\\"--cpu %s\\\" malformed\\n\", optarg);\n\thelp();\n\texit(-1);\n}\n\nvoid cmdline(int argc, char **argv)\n{\n\tint opt;\n\tint option_index = 0;\n\tstatic struct option long_options[] = {\n\t\t{ \"add\", required_argument, 0, 'a' },\n\t\t{ \"cpu\", required_argument, 0, 'c' },\n\t\t{ \"Dump\", no_argument, 0, 'D' },\n\t\t{ \"debug\", no_argument, 0, 'd' },\t \n\t\t{ \"enable\", required_argument, 0, 'e' },\n\t\t{ \"interval\", required_argument, 0, 'i' },\n\t\t{ \"IPC\", no_argument, 0, 'I' },\n\t\t{ \"num_iterations\", required_argument, 0, 'n' },\n\t\t{ \"header_iterations\", required_argument, 0, 'N' },\n\t\t{ \"help\", no_argument, 0, 'h' },\n\t\t{ \"hide\", required_argument, 0, 'H' },\t\n\t\t{ \"Joules\", no_argument, 0, 'J' },\n\t\t{ \"list\", no_argument, 0, 'l' },\n\t\t{ \"out\", required_argument, 0, 'o' },\n\t\t{ \"quiet\", no_argument, 0, 'q' },\n\t\t{ \"show\", required_argument, 0, 's' },\n\t\t{ \"Summary\", no_argument, 0, 'S' },\n\t\t{ \"TCC\", required_argument, 0, 'T' },\n\t\t{ \"version\", no_argument, 0, 'v' },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\n\tprogname = argv[0];\n\n\twhile ((opt = getopt_long_only(argc, argv, \"+C:c:Dde:hi:Jn:o:qST:v\", long_options, &option_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\tparse_add_command(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tparse_cpu_command(optarg);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdump_only++;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\t \n\t\t\tbic_enabled = bic_enabled | bic_lookup(optarg, SHOW_LIST);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdebug++;\n\t\t\tENABLE_BIC(BIC_DISABLED_BY_DEFAULT);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\t \n\t\t\tbic_enabled &= ~bic_lookup(optarg, HIDE_LIST);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\thelp();\n\t\t\texit(1);\n\t\tcase 'i':\n\t\t\t{\n\t\t\t\tdouble interval = strtod(optarg, NULL);\n\n\t\t\t\tif (interval < 0.001) {\n\t\t\t\t\tfprintf(outf, \"interval %f seconds is too small\\n\", interval);\n\t\t\t\t\texit(2);\n\t\t\t\t}\n\n\t\t\t\tinterval_tv.tv_sec = interval_ts.tv_sec = interval;\n\t\t\t\tinterval_tv.tv_usec = (interval - interval_tv.tv_sec) * 1000000;\n\t\t\t\tinterval_ts.tv_nsec = (interval - interval_ts.tv_sec) * 1000000000;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\trapl_joules++;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tENABLE_BIC(BIC_DISABLED_BY_DEFAULT);\n\t\t\tlist_header_only++;\n\t\t\tquiet++;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutf = fopen_or_die(optarg, \"w\");\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tquiet = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnum_iterations = strtod(optarg, NULL);\n\n\t\t\tif (num_iterations <= 0) {\n\t\t\t\tfprintf(outf, \"iterations %d should be positive number\\n\", num_iterations);\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\theader_iterations = strtod(optarg, NULL);\n\n\t\t\tif (header_iterations <= 0) {\n\t\t\t\tfprintf(outf, \"iterations %d should be positive number\\n\", header_iterations);\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\t \n\t\t\tif (shown == 0)\n\t\t\t\tbic_enabled = bic_lookup(optarg, SHOW_LIST);\n\t\t\telse\n\t\t\t\tbic_enabled |= bic_lookup(optarg, SHOW_LIST);\n\t\t\tshown = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tsummary_only++;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttj_max_override = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tprint_version();\n\t\t\texit(0);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\toutf = stderr;\n\tcmdline(argc, argv);\n\n\tif (!quiet) {\n\t\tprint_version();\n\t\tprint_bootcmd();\n\t}\n\n\tprobe_sysfs();\n\n\tturbostat_init();\n\n\tmsr_sum_record();\n\n\t \n\tif (dump_only)\n\t\treturn get_and_dump_counters();\n\n\t \n\tif (list_header_only) {\n\t\tprint_header(\",\");\n\t\tflush_output_stdout();\n\t\treturn 0;\n\t}\n\n\t \n\tif (argc - optind)\n\t\treturn fork_it(argv + optind);\n\telse\n\t\tturbostat_loop();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}