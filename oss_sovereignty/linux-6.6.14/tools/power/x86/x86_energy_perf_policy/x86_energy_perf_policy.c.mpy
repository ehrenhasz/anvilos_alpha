{
  "module_name": "x86_energy_perf_policy.c",
  "hash_id": "85a7808f7a29703b1d61f1b083cb3ebdb20c4acd022adca559c076f90110e7e0",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/x86_energy_perf_policy/x86_energy_perf_policy.c",
  "human_readable_source": "\n \n \n\n#define _GNU_SOURCE\n#include MSRHEADER\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sched.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <getopt.h>\n#include <err.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/time.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <cpuid.h>\n#include <errno.h>\n\n#define\tOPTARG_NORMAL\t\t\t(INT_MAX - 1)\n#define\tOPTARG_POWER\t\t\t(INT_MAX - 2)\n#define\tOPTARG_BALANCE_POWER\t\t(INT_MAX - 3)\n#define\tOPTARG_BALANCE_PERFORMANCE\t(INT_MAX - 4)\n#define\tOPTARG_PERFORMANCE\t\t(INT_MAX - 5)\n\nstruct msr_hwp_cap {\n\tunsigned char highest;\n\tunsigned char guaranteed;\n\tunsigned char efficient;\n\tunsigned char lowest;\n};\n\nstruct msr_hwp_request {\n\tunsigned char hwp_min;\n\tunsigned char hwp_max;\n\tunsigned char hwp_desired;\n\tunsigned char hwp_epp;\n\tunsigned int hwp_window;\n\tunsigned char hwp_use_pkg;\n} req_update;\n\nunsigned int debug;\nunsigned int verbose;\nunsigned int force;\nchar *progname;\nint base_cpu;\nunsigned char update_epb;\nunsigned long long new_epb;\nunsigned char turbo_is_enabled;\nunsigned char update_turbo;\nunsigned char turbo_update_value;\nunsigned char update_hwp_epp;\nunsigned char update_hwp_min;\nunsigned char update_hwp_max;\nunsigned char update_hwp_desired;\nunsigned char update_hwp_window;\nunsigned char update_hwp_use_pkg;\nunsigned char update_hwp_enable;\n#define hwp_update_enabled() (update_hwp_enable | update_hwp_epp | update_hwp_max | update_hwp_min | update_hwp_desired | update_hwp_window | update_hwp_use_pkg)\nint max_cpu_num;\nint max_pkg_num;\n#define MAX_PACKAGES 64\nunsigned int first_cpu_in_pkg[MAX_PACKAGES];\nunsigned long long pkg_present_set;\nunsigned long long pkg_selected_set;\ncpu_set_t *cpu_present_set;\ncpu_set_t *cpu_selected_set;\nint genuine_intel;\n\nsize_t cpu_setsize;\n\nchar *proc_stat = \"/proc/stat\";\n\nunsigned int has_epb;\t \nunsigned int has_hwp;\t \n\t\t\t \nunsigned int has_hwp_notify;\t\t \nunsigned int has_hwp_activity_window;\t \nunsigned int has_hwp_epp;\t \nunsigned int has_hwp_request_pkg;\t \n\nunsigned int bdx_highest_ratio;\n\n#define PATH_TO_CPU \"/sys/devices/system/cpu/\"\n#define SYSFS_PATH_MAX 255\n\n \nvoid usage(void)\n{\n\tfprintf(stderr, \"%s [options] [scope][field value]\\n\", progname);\n\tfprintf(stderr, \"scope: --cpu cpu-list [--hwp-use-pkg #] | --pkg pkg-list\\n\");\n\tfprintf(stderr, \"field: --all | --epb | --hwp-epp | --hwp-min | --hwp-max | --hwp-desired\\n\");\n\tfprintf(stderr, \"other: --hwp-enable | --turbo-enable (0 | 1) | --help | --force\\n\");\n\tfprintf(stderr,\n\t\t\"value: ( # | \\\"normal\\\" | \\\"performance\\\" | \\\"balance-performance\\\" | \\\"balance-power\\\"| \\\"power\\\")\\n\");\n\tfprintf(stderr, \"--hwp-window usec\\n\");\n\n\tfprintf(stderr, \"Specify only Energy Performance BIAS (legacy usage):\\n\");\n\tfprintf(stderr, \"%s: [-c cpu] [-v] (-r | policy-value )\\n\", progname);\n\n\texit(1);\n}\n\n \nint ratio_2_msr_perf(int ratio)\n{\n\tint msr_perf;\n\n\tif (!bdx_highest_ratio)\n\t\treturn ratio;\n\n\tmsr_perf = ratio * 255 / bdx_highest_ratio;\n\n\tif (debug)\n\t\tfprintf(stderr, \"%d = ratio_to_msr_perf(%d)\\n\", msr_perf, ratio);\n\n\treturn msr_perf;\n}\nint msr_perf_2_ratio(int msr_perf)\n{\n\tint ratio;\n\tdouble d;\n\n\tif (!bdx_highest_ratio)\n\t\treturn msr_perf;\n\n\td = (double)msr_perf * (double) bdx_highest_ratio / 255.0;\n\td = d + 0.5;\t \n\tratio = (int)d;\n\n\tif (debug)\n\t\tfprintf(stderr, \"%d = msr_perf_ratio(%d) {%f}\\n\", ratio, msr_perf, d);\n\n\treturn ratio;\n}\nint parse_cmdline_epb(int i)\n{\n\tif (!has_epb)\n\t\terrx(1, \"EPB not enabled on this platform\");\n\n\tupdate_epb = 1;\n\n\tswitch (i) {\n\tcase OPTARG_POWER:\n\t\treturn ENERGY_PERF_BIAS_POWERSAVE;\n\tcase OPTARG_BALANCE_POWER:\n\t\treturn ENERGY_PERF_BIAS_BALANCE_POWERSAVE;\n\tcase OPTARG_NORMAL:\n\t\treturn ENERGY_PERF_BIAS_NORMAL;\n\tcase OPTARG_BALANCE_PERFORMANCE:\n\t\treturn ENERGY_PERF_BIAS_BALANCE_PERFORMANCE;\n\tcase OPTARG_PERFORMANCE:\n\t\treturn ENERGY_PERF_BIAS_PERFORMANCE;\n\t}\n\tif (i < 0 || i > ENERGY_PERF_BIAS_POWERSAVE)\n\t\terrx(1, \"--epb must be from 0 to 15\");\n\treturn i;\n}\n\n#define HWP_CAP_LOWEST 0\n#define HWP_CAP_HIGHEST 255\n\n \nint parse_cmdline_hwp_min(int i)\n{\n\tupdate_hwp_min = 1;\n\n\tswitch (i) {\n\tcase OPTARG_POWER:\n\tcase OPTARG_BALANCE_POWER:\n\tcase OPTARG_NORMAL:\n\tcase OPTARG_BALANCE_PERFORMANCE:\n\t\treturn HWP_CAP_LOWEST;\n\tcase OPTARG_PERFORMANCE:\n\t\treturn HWP_CAP_HIGHEST;\n\t}\n\treturn i;\n}\n \nint parse_cmdline_hwp_max(int i)\n{\n\tupdate_hwp_max = 1;\n\n\tswitch (i) {\n\tcase OPTARG_POWER:\n\t\treturn HWP_CAP_LOWEST;\n\tcase OPTARG_NORMAL:\n\tcase OPTARG_BALANCE_POWER:\n\tcase OPTARG_BALANCE_PERFORMANCE:\n\tcase OPTARG_PERFORMANCE:\n\t\treturn HWP_CAP_HIGHEST;\n\t}\n\treturn i;\n}\n \nint parse_cmdline_hwp_desired(int i)\n{\n\tupdate_hwp_desired = 1;\n\n\tswitch (i) {\n\tcase OPTARG_POWER:\n\tcase OPTARG_BALANCE_POWER:\n\tcase OPTARG_BALANCE_PERFORMANCE:\n\tcase OPTARG_NORMAL:\n\tcase OPTARG_PERFORMANCE:\n\t\treturn 0;\t \n\t}\n\treturn i;\n}\n\nint parse_cmdline_hwp_window(int i)\n{\n\tunsigned int exponent;\n\n\tupdate_hwp_window = 1;\n\n\tswitch (i) {\n\tcase OPTARG_POWER:\n\tcase OPTARG_BALANCE_POWER:\n\tcase OPTARG_NORMAL:\n\tcase OPTARG_BALANCE_PERFORMANCE:\n\tcase OPTARG_PERFORMANCE:\n\t\treturn 0;\n\t}\n\tif (i < 0 || i > 1270000000) {\n\t\tfprintf(stderr, \"--hwp-window: 0 for auto; 1 - 1270000000 usec for window duration\\n\");\n\t\tusage();\n\t}\n\tfor (exponent = 0; ; ++exponent) {\n\t\tif (debug)\n\t\t\tprintf(\"%d 10^%d\\n\", i, exponent);\n\n\t\tif (i <= 127)\n\t\t\tbreak;\n\n\t\ti = i / 10;\n\t}\n\tif (debug)\n\t\tfprintf(stderr, \"%d*10^%d: 0x%x\\n\", i, exponent, (exponent << 7) | i);\n\n\treturn (exponent << 7) | i;\n}\nint parse_cmdline_hwp_epp(int i)\n{\n\tupdate_hwp_epp = 1;\n\n\tswitch (i) {\n\tcase OPTARG_POWER:\n\t\treturn HWP_EPP_POWERSAVE;\n\tcase OPTARG_BALANCE_POWER:\n\t\treturn HWP_EPP_BALANCE_POWERSAVE;\n\tcase OPTARG_NORMAL:\n\tcase OPTARG_BALANCE_PERFORMANCE:\n\t\treturn HWP_EPP_BALANCE_PERFORMANCE;\n\tcase OPTARG_PERFORMANCE:\n\t\treturn HWP_EPP_PERFORMANCE;\n\t}\n\tif (i < 0 || i > 0xff) {\n\t\tfprintf(stderr, \"--hwp-epp must be from 0 to 0xff\\n\");\n\t\tusage();\n\t}\n\treturn i;\n}\nint parse_cmdline_turbo(int i)\n{\n\tupdate_turbo = 1;\n\n\tswitch (i) {\n\tcase OPTARG_POWER:\n\t\treturn 0;\n\tcase OPTARG_NORMAL:\n\tcase OPTARG_BALANCE_POWER:\n\tcase OPTARG_BALANCE_PERFORMANCE:\n\tcase OPTARG_PERFORMANCE:\n\t\treturn 1;\n\t}\n\tif (i < 0 || i > 1) {\n\t\tfprintf(stderr, \"--turbo-enable: 1 to enable, 0 to disable\\n\");\n\t\tusage();\n\t}\n\treturn i;\n}\n\nint parse_optarg_string(char *s)\n{\n\tint i;\n\tchar *endptr;\n\n\tif (!strncmp(s, \"default\", 7))\n\t\treturn OPTARG_NORMAL;\n\n\tif (!strncmp(s, \"normal\", 6))\n\t\treturn OPTARG_NORMAL;\n\n\tif (!strncmp(s, \"power\", 9))\n\t\treturn OPTARG_POWER;\n\n\tif (!strncmp(s, \"balance-power\", 17))\n\t\treturn OPTARG_BALANCE_POWER;\n\n\tif (!strncmp(s, \"balance-performance\", 19))\n\t\treturn OPTARG_BALANCE_PERFORMANCE;\n\n\tif (!strncmp(s, \"performance\", 11))\n\t\treturn OPTARG_PERFORMANCE;\n\n\ti = strtol(s, &endptr, 0);\n\tif (s == endptr) {\n\t\tfprintf(stderr, \"no digits in \\\"%s\\\"\\n\", s);\n\t\tusage();\n\t}\n\tif (i == LONG_MIN || i == LONG_MAX)\n\t\terrx(-1, \"%s\", s);\n\n\tif (i > 0xFF)\n\t\terrx(-1, \"%d (0x%x) must be < 256\", i, i);\n\n\tif (i < 0)\n\t\terrx(-1, \"%d (0x%x) must be >= 0\", i, i);\n\treturn i;\n}\n\nvoid parse_cmdline_all(char *s)\n{\n\tforce++;\n\tupdate_hwp_enable = 1;\n\treq_update.hwp_min = parse_cmdline_hwp_min(parse_optarg_string(s));\n\treq_update.hwp_max = parse_cmdline_hwp_max(parse_optarg_string(s));\n\treq_update.hwp_epp = parse_cmdline_hwp_epp(parse_optarg_string(s));\n\tif (has_epb)\n\t\tnew_epb = parse_cmdline_epb(parse_optarg_string(s));\n\tturbo_update_value = parse_cmdline_turbo(parse_optarg_string(s));\n\treq_update.hwp_desired = parse_cmdline_hwp_desired(parse_optarg_string(s));\n\treq_update.hwp_window = parse_cmdline_hwp_window(parse_optarg_string(s));\n}\n\nvoid validate_cpu_selected_set(void)\n{\n\tint cpu;\n\n\tif (CPU_COUNT_S(cpu_setsize, cpu_selected_set) == 0)\n\t\terrx(0, \"no CPUs requested\");\n\n\tfor (cpu = 0; cpu <= max_cpu_num; ++cpu) {\n\t\tif (CPU_ISSET_S(cpu, cpu_setsize, cpu_selected_set))\n\t\t\tif (!CPU_ISSET_S(cpu, cpu_setsize, cpu_present_set))\n\t\t\t\terrx(1, \"Requested cpu% is not present\", cpu);\n\t}\n}\n\nvoid parse_cmdline_cpu(char *s)\n{\n\tchar *startp, *endp;\n\tint cpu = 0;\n\n\tif (pkg_selected_set) {\n\t\tusage();\n\t\terrx(1, \"--cpu | --pkg\");\n\t}\n\tcpu_selected_set = CPU_ALLOC((max_cpu_num + 1));\n\tif (cpu_selected_set == NULL)\n\t\terr(1, \"cpu_selected_set\");\n\tCPU_ZERO_S(cpu_setsize, cpu_selected_set);\n\n\tfor (startp = s; startp && *startp;) {\n\n\t\tif (*startp == ',') {\n\t\t\tstartp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*startp == '-') {\n\t\t\tint end_cpu;\n\n\t\t\tstartp++;\n\t\t\tend_cpu = strtol(startp, &endp, 10);\n\t\t\tif (startp == endp)\n\t\t\t\tcontinue;\n\n\t\t\twhile (cpu <= end_cpu) {\n\t\t\t\tif (cpu > max_cpu_num)\n\t\t\t\t\terrx(1, \"Requested cpu%d exceeds max cpu%d\", cpu, max_cpu_num);\n\t\t\t\tCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\n\t\t\t\tcpu++;\n\t\t\t}\n\t\t\tstartp = endp;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strncmp(startp, \"all\", 3) == 0) {\n\t\t\tfor (cpu = 0; cpu <= max_cpu_num; cpu += 1) {\n\t\t\t\tif (CPU_ISSET_S(cpu, cpu_setsize, cpu_present_set))\n\t\t\t\t\tCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\n\t\t\t}\n\t\t\tstartp += 3;\n\t\t\tif (*startp == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (strncmp(startp, \"even\", 4) == 0) {\n\t\t\tfor (cpu = 0; cpu <= max_cpu_num; cpu += 2) {\n\t\t\t\tif (CPU_ISSET_S(cpu, cpu_setsize, cpu_present_set))\n\t\t\t\t\tCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\n\t\t\t}\n\t\t\tstartp += 4;\n\t\t\tif (*startp == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (strncmp(startp, \"odd\", 3) == 0) {\n\t\t\tfor (cpu = 1; cpu <= max_cpu_num; cpu += 2) {\n\t\t\t\tif (CPU_ISSET_S(cpu, cpu_setsize, cpu_present_set))\n\t\t\t\t\tCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\n\t\t\t}\n\t\t\tstartp += 3;\n\t\t\tif (*startp == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcpu = strtol(startp, &endp, 10);\n\t\tif (startp == endp)\n\t\t\terrx(1, \"--cpu cpu-set: confused by '%s'\", startp);\n\t\tif (cpu > max_cpu_num)\n\t\t\terrx(1, \"Requested cpu%d exceeds max cpu%d\", cpu, max_cpu_num);\n\t\tCPU_SET_S(cpu, cpu_setsize, cpu_selected_set);\n\t\tstartp = endp;\n\t}\n\n\tvalidate_cpu_selected_set();\n\n}\n\nvoid parse_cmdline_pkg(char *s)\n{\n\tchar *startp, *endp;\n\tint pkg = 0;\n\n\tif (cpu_selected_set) {\n\t\tusage();\n\t\terrx(1, \"--pkg | --cpu\");\n\t}\n\tpkg_selected_set = 0;\n\n\tfor (startp = s; startp && *startp;) {\n\n\t\tif (*startp == ',') {\n\t\t\tstartp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*startp == '-') {\n\t\t\tint end_pkg;\n\n\t\t\tstartp++;\n\t\t\tend_pkg = strtol(startp, &endp, 10);\n\t\t\tif (startp == endp)\n\t\t\t\tcontinue;\n\n\t\t\twhile (pkg <= end_pkg) {\n\t\t\t\tif (pkg > max_pkg_num)\n\t\t\t\t\terrx(1, \"Requested pkg%d exceeds max pkg%d\", pkg, max_pkg_num);\n\t\t\t\tpkg_selected_set |= 1 << pkg;\n\t\t\t\tpkg++;\n\t\t\t}\n\t\t\tstartp = endp;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strncmp(startp, \"all\", 3) == 0) {\n\t\t\tpkg_selected_set = pkg_present_set;\n\t\t\treturn;\n\t\t}\n\n\t\tpkg = strtol(startp, &endp, 10);\n\t\tif (pkg > max_pkg_num)\n\t\t\terrx(1, \"Requested pkg%d Exceeds max pkg%d\", pkg, max_pkg_num);\n\t\tpkg_selected_set |= 1 << pkg;\n\t\tstartp = endp;\n\t}\n}\n\nvoid for_packages(unsigned long long pkg_set, int (func)(int))\n{\n\tint pkg_num;\n\n\tfor (pkg_num = 0; pkg_num <= max_pkg_num; ++pkg_num) {\n\t\tif (pkg_set & (1UL << pkg_num))\n\t\t\tfunc(pkg_num);\n\t}\n}\n\nvoid print_version(void)\n{\n\tprintf(\"x86_energy_perf_policy 17.05.11 (C) Len Brown <len.brown@intel.com>\\n\");\n}\n\nvoid cmdline(int argc, char **argv)\n{\n\tint opt;\n\tint option_index = 0;\n\n\tstatic struct option long_options[] = {\n\t\t{\"all\",\t\trequired_argument,\t0, 'a'},\n\t\t{\"cpu\",\t\trequired_argument,\t0, 'c'},\n\t\t{\"pkg\",\t\trequired_argument,\t0, 'p'},\n\t\t{\"debug\",\tno_argument,\t\t0, 'd'},\n\t\t{\"hwp-desired\",\trequired_argument,\t0, 'D'},\n\t\t{\"epb\",\trequired_argument,\t0, 'B'},\n\t\t{\"force\",\tno_argument,\t0, 'f'},\n\t\t{\"hwp-enable\",\tno_argument,\t0, 'e'},\n\t\t{\"help\",\tno_argument,\t0, 'h'},\n\t\t{\"hwp-epp\",\trequired_argument,\t0, 'P'},\n\t\t{\"hwp-min\",\trequired_argument,\t0, 'm'},\n\t\t{\"hwp-max\",\trequired_argument,\t0, 'M'},\n\t\t{\"read\",\tno_argument,\t\t0, 'r'},\n\t\t{\"turbo-enable\",\trequired_argument,\t0, 't'},\n\t\t{\"hwp-use-pkg\",\trequired_argument,\t0, 'u'},\n\t\t{\"version\",\tno_argument,\t\t0, 'v'},\n\t\t{\"hwp-window\",\trequired_argument,\t0, 'w'},\n\t\t{0,\t\t0,\t\t\t0, 0 }\n\t};\n\n\tprogname = argv[0];\n\n\twhile ((opt = getopt_long_only(argc, argv, \"+a:c:dD:E:e:f:m:M:rt:u:vw:\",\n\t\t\t\tlong_options, &option_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\tparse_cmdline_all(optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tnew_epb = parse_cmdline_epb(parse_optarg_string(optarg));\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tparse_cmdline_cpu(optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tupdate_hwp_enable = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdebug++;\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tforce++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\treq_update.hwp_desired = parse_cmdline_hwp_desired(parse_optarg_string(optarg));\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\treq_update.hwp_min = parse_cmdline_hwp_min(parse_optarg_string(optarg));\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\treq_update.hwp_max = parse_cmdline_hwp_max(parse_optarg_string(optarg));\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparse_cmdline_pkg(optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\treq_update.hwp_epp = parse_cmdline_hwp_epp(parse_optarg_string(optarg));\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\t \n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tturbo_update_value = parse_cmdline_turbo(parse_optarg_string(optarg));\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tupdate_hwp_use_pkg++;\n\t\t\tif (atoi(optarg) == 0)\n\t\t\t\treq_update.hwp_use_pkg = 0;\n\t\t\telse\n\t\t\t\treq_update.hwp_use_pkg = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tprint_version();\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\treq_update.hwp_window = parse_cmdline_hwp_window(parse_optarg_string(optarg));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\t \n\tif (argc == optind + 1)\n\t\tnew_epb = parse_cmdline_epb(parse_optarg_string(argv[optind]));\n\n\tif (argc > optind + 1) {\n\t\tfprintf(stderr, \"stray parameter '%s'\\n\", argv[optind + 1]);\n\t\tusage();\n\t}\n}\n\n \nFILE *fopen_or_die(const char *path, const char *mode)\n{\n\tFILE *filep = fopen(path, \"r\");\n\n\tif (!filep)\n\t\terr(1, \"%s: open failed\", path);\n\treturn filep;\n}\n\nvoid err_on_hypervisor(void)\n{\n\tFILE *cpuinfo;\n\tchar *flags, *hypervisor;\n\tchar *buffer;\n\n\t \n\tcpuinfo = fopen_or_die(\"/proc/cpuinfo\", \"ro\");\n\n\tbuffer = malloc(4096);\n\tif (!buffer) {\n\t\tfclose(cpuinfo);\n\t\terr(-ENOMEM, \"buffer malloc fail\");\n\t}\n\n\tif (!fread(buffer, 1024, 1, cpuinfo)) {\n\t\tfclose(cpuinfo);\n\t\tfree(buffer);\n\t\terr(1, \"Reading /proc/cpuinfo failed\");\n\t}\n\n\tflags = strstr(buffer, \"flags\");\n\trewind(cpuinfo);\n\tfseek(cpuinfo, flags - buffer, SEEK_SET);\n\tif (!fgets(buffer, 4096, cpuinfo)) {\n\t\tfclose(cpuinfo);\n\t\tfree(buffer);\n\t\terr(1, \"Reading /proc/cpuinfo failed\");\n\t}\n\tfclose(cpuinfo);\n\n\thypervisor = strstr(buffer, \"hypervisor\");\n\n\tfree(buffer);\n\n\tif (hypervisor)\n\t\terr(-1,\n\t\t    \"not supported on this virtual machine\");\n}\n\nint get_msr(int cpu, int offset, unsigned long long *msr)\n{\n\tint retval;\n\tchar pathname[32];\n\tint fd;\n\n\tsprintf(pathname, \"/dev/cpu/%d/msr\", cpu);\n\tfd = open(pathname, O_RDONLY);\n\tif (fd < 0)\n\t\terr(-1, \"%s open failed, try chown or chmod +r /dev/cpu/*/msr, or run as root\", pathname);\n\n\tretval = pread(fd, msr, sizeof(*msr), offset);\n\tif (retval != sizeof(*msr)) {\n\t\terr_on_hypervisor();\n\t\terr(-1, \"%s offset 0x%llx read failed\", pathname, (unsigned long long)offset);\n\t}\n\n\tif (debug > 1)\n\t\tfprintf(stderr, \"get_msr(cpu%d, 0x%X, 0x%llX)\\n\", cpu, offset, *msr);\n\n\tclose(fd);\n\treturn 0;\n}\n\nint put_msr(int cpu, int offset, unsigned long long new_msr)\n{\n\tchar pathname[32];\n\tint retval;\n\tint fd;\n\n\tsprintf(pathname, \"/dev/cpu/%d/msr\", cpu);\n\tfd = open(pathname, O_RDWR);\n\tif (fd < 0)\n\t\terr(-1, \"%s open failed, try chown or chmod +r /dev/cpu/*/msr, or run as root\", pathname);\n\n\tretval = pwrite(fd, &new_msr, sizeof(new_msr), offset);\n\tif (retval != sizeof(new_msr))\n\t\terr(-2, \"pwrite(cpu%d, offset 0x%x, 0x%llx) = %d\", cpu, offset, new_msr, retval);\n\n\tclose(fd);\n\n\tif (debug > 1)\n\t\tfprintf(stderr, \"put_msr(cpu%d, 0x%X, 0x%llX)\\n\", cpu, offset, new_msr);\n\n\treturn 0;\n}\n\nstatic unsigned int read_sysfs(const char *path, char *buf, size_t buflen)\n{\n\tssize_t numread;\n\tint fd;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumread = read(fd, buf, buflen - 1);\n\tif (numread < 1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\tbuf[numread] = '\\0';\n\tclose(fd);\n\n\treturn (unsigned int) numread;\n}\n\nstatic unsigned int write_sysfs(const char *path, char *buf, size_t buflen)\n{\n\tssize_t numwritten;\n\tint fd;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd == -1)\n\t\treturn 0;\n\n\tnumwritten = write(fd, buf, buflen - 1);\n\tif (numwritten < 1) {\n\t\tperror(\"write failed\\n\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tclose(fd);\n\n\treturn (unsigned int) numwritten;\n}\n\nvoid print_hwp_cap(int cpu, struct msr_hwp_cap *cap, char *str)\n{\n\tif (cpu != -1)\n\t\tprintf(\"cpu%d: \", cpu);\n\n\tprintf(\"HWP_CAP: low %d eff %d guar %d high %d\\n\",\n\t\tcap->lowest, cap->efficient, cap->guaranteed, cap->highest);\n}\nvoid read_hwp_cap(int cpu, struct msr_hwp_cap *cap, unsigned int msr_offset)\n{\n\tunsigned long long msr;\n\n\tget_msr(cpu, msr_offset, &msr);\n\n\tcap->highest = msr_perf_2_ratio(HWP_HIGHEST_PERF(msr));\n\tcap->guaranteed = msr_perf_2_ratio(HWP_GUARANTEED_PERF(msr));\n\tcap->efficient = msr_perf_2_ratio(HWP_MOSTEFFICIENT_PERF(msr));\n\tcap->lowest = msr_perf_2_ratio(HWP_LOWEST_PERF(msr));\n}\n\nvoid print_hwp_request(int cpu, struct msr_hwp_request *h, char *str)\n{\n\tif (cpu != -1)\n\t\tprintf(\"cpu%d: \", cpu);\n\n\tif (str)\n\t\tprintf(\"%s\", str);\n\n\tprintf(\"HWP_REQ: min %d max %d des %d epp %d window 0x%x (%d*10^%dus) use_pkg %d\\n\",\n\t\th->hwp_min, h->hwp_max, h->hwp_desired, h->hwp_epp,\n\t\th->hwp_window, h->hwp_window & 0x7F, (h->hwp_window >> 7) & 0x7, h->hwp_use_pkg);\n}\nvoid print_hwp_request_pkg(int pkg, struct msr_hwp_request *h, char *str)\n{\n\tprintf(\"pkg%d: \", pkg);\n\n\tif (str)\n\t\tprintf(\"%s\", str);\n\n\tprintf(\"HWP_REQ_PKG: min %d max %d des %d epp %d window 0x%x (%d*10^%dus)\\n\",\n\t\th->hwp_min, h->hwp_max, h->hwp_desired, h->hwp_epp,\n\t\th->hwp_window, h->hwp_window & 0x7F, (h->hwp_window >> 7) & 0x7);\n}\nvoid read_hwp_request(int cpu, struct msr_hwp_request *hwp_req, unsigned int msr_offset)\n{\n\tunsigned long long msr;\n\n\tget_msr(cpu, msr_offset, &msr);\n\n\thwp_req->hwp_min = msr_perf_2_ratio((((msr) >> 0) & 0xff));\n\thwp_req->hwp_max = msr_perf_2_ratio((((msr) >> 8) & 0xff));\n\thwp_req->hwp_desired = msr_perf_2_ratio((((msr) >> 16) & 0xff));\n\thwp_req->hwp_epp = (((msr) >> 24) & 0xff);\n\thwp_req->hwp_window = (((msr) >> 32) & 0x3ff);\n\thwp_req->hwp_use_pkg = (((msr) >> 42) & 0x1);\n}\n\nvoid write_hwp_request(int cpu, struct msr_hwp_request *hwp_req, unsigned int msr_offset)\n{\n\tunsigned long long msr = 0;\n\n\tif (debug > 1)\n\t\tprintf(\"cpu%d: requesting min %d max %d des %d epp %d window 0x%0x use_pkg %d\\n\",\n\t\t\tcpu, hwp_req->hwp_min, hwp_req->hwp_max,\n\t\t\thwp_req->hwp_desired, hwp_req->hwp_epp,\n\t\t\thwp_req->hwp_window, hwp_req->hwp_use_pkg);\n\n\tmsr |= HWP_MIN_PERF(ratio_2_msr_perf(hwp_req->hwp_min));\n\tmsr |= HWP_MAX_PERF(ratio_2_msr_perf(hwp_req->hwp_max));\n\tmsr |= HWP_DESIRED_PERF(ratio_2_msr_perf(hwp_req->hwp_desired));\n\tmsr |= HWP_ENERGY_PERF_PREFERENCE(hwp_req->hwp_epp);\n\tmsr |= HWP_ACTIVITY_WINDOW(hwp_req->hwp_window);\n\tmsr |= HWP_PACKAGE_CONTROL(hwp_req->hwp_use_pkg);\n\n\tput_msr(cpu, msr_offset, msr);\n}\n\nstatic int get_epb(int cpu)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tchar linebuf[3];\n\tchar *endp;\n\tlong val;\n\n\tif (!has_epb)\n\t\treturn -1;\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/power/energy_perf_bias\", cpu);\n\n\tif (!read_sysfs(path, linebuf, 3))\n\t\treturn -1;\n\n\tval = strtol(linebuf, &endp, 0);\n\tif (endp == linebuf || errno == ERANGE)\n\t\treturn -1;\n\n\treturn (int)val;\n}\n\nstatic int set_epb(int cpu, int val)\n{\n\tchar path[SYSFS_PATH_MAX];\n\tchar linebuf[3];\n\tchar *endp;\n\tint ret;\n\n\tif (!has_epb)\n\t\treturn -1;\n\n\tsnprintf(path, sizeof(path), PATH_TO_CPU \"cpu%u/power/energy_perf_bias\", cpu);\n\tsnprintf(linebuf, sizeof(linebuf), \"%d\", val);\n\n\tret = write_sysfs(path, linebuf, 3);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tval = strtol(linebuf, &endp, 0);\n\tif (endp == linebuf || errno == ERANGE)\n\t\treturn -1;\n\n\treturn (int)val;\n}\n\nint print_cpu_msrs(int cpu)\n{\n\tstruct msr_hwp_request req;\n\tstruct msr_hwp_cap cap;\n\tint epb;\n\n\tepb = get_epb(cpu);\n\tif (epb >= 0)\n\t\tprintf(\"cpu%d: EPB %u\\n\", cpu, (unsigned int) epb);\n\n\tif (!has_hwp)\n\t\treturn 0;\n\n\tread_hwp_request(cpu, &req, MSR_HWP_REQUEST);\n\tprint_hwp_request(cpu, &req, \"\");\n\n\tread_hwp_cap(cpu, &cap, MSR_HWP_CAPABILITIES);\n\tprint_hwp_cap(cpu, &cap, \"\");\n\n\treturn 0;\n}\n\nint print_pkg_msrs(int pkg)\n{\n\tstruct msr_hwp_request req;\n\tunsigned long long msr;\n\n\tif (!has_hwp)\n\t\treturn 0;\n\n\tread_hwp_request(first_cpu_in_pkg[pkg], &req, MSR_HWP_REQUEST_PKG);\n\tprint_hwp_request_pkg(pkg, &req, \"\");\n\n\tif (has_hwp_notify) {\n\t\tget_msr(first_cpu_in_pkg[pkg], MSR_HWP_INTERRUPT, &msr);\n\t\tfprintf(stderr,\n\t\t\"pkg%d: MSR_HWP_INTERRUPT: 0x%08llx (Excursion_Min-%sabled, Guaranteed_Perf_Change-%sabled)\\n\",\n\t\tpkg, msr,\n\t\t((msr) & 0x2) ? \"EN\" : \"Dis\",\n\t\t((msr) & 0x1) ? \"EN\" : \"Dis\");\n\t}\n\tget_msr(first_cpu_in_pkg[pkg], MSR_HWP_STATUS, &msr);\n\tfprintf(stderr,\n\t\t\"pkg%d: MSR_HWP_STATUS: 0x%08llx (%sExcursion_Min, %sGuaranteed_Perf_Change)\\n\",\n\t\tpkg, msr,\n\t\t((msr) & 0x4) ? \"\" : \"No-\",\n\t\t((msr) & 0x1) ? \"\" : \"No-\");\n\n\treturn 0;\n}\n\n \nint ratio_2_sysfs_khz(int ratio)\n{\n\tint bclk_khz = 100 * 1000;\t \n\n\treturn ratio * bclk_khz;\n}\n \nvoid update_cpufreq_scaling_freq(int is_max, int cpu, unsigned int ratio)\n{\n\tchar pathname[64];\n\tFILE *fp;\n\tint retval;\n\tint khz;\n\n\tsprintf(pathname, \"/sys/devices/system/cpu/cpu%d/cpufreq/scaling_%s_freq\",\n\t\tcpu, is_max ? \"max\" : \"min\");\n\n\tfp = fopen(pathname, \"w\");\n\tif (!fp) {\n\t\tif (debug)\n\t\t\tperror(pathname);\n\t\treturn;\n\t}\n\n\tkhz = ratio_2_sysfs_khz(ratio);\n\tretval = fprintf(fp, \"%d\", khz);\n\tif (retval < 0)\n\t\tif (debug)\n\t\t\tperror(\"fprintf\");\n\tif (debug)\n\t\tprintf(\"echo %d > %s\\n\", khz, pathname);\n\n\tfclose(fp);\n}\n\n \n\nint update_sysfs(int cpu)\n{\n\tif (!has_hwp)\n\t\treturn 0;\n\n\tif (!hwp_update_enabled())\n\t\treturn 0;\n\n\tif (access(\"/sys/devices/system/cpu/cpu0/cpufreq\", F_OK))\n\t\treturn 0;\n\n\tif (update_hwp_min)\n\t\tupdate_cpufreq_scaling_freq(0, cpu, req_update.hwp_min);\n\n\tif (update_hwp_max)\n\t\tupdate_cpufreq_scaling_freq(1, cpu, req_update.hwp_max);\n\n\treturn 0;\n}\n\nint verify_hwp_req_self_consistency(int cpu, struct msr_hwp_request *req)\n{\n\t \n\tif (req->hwp_min > req->hwp_max) {\n\t\terrx(1, \"cpu%d: requested hwp-min %d > hwp_max %d\",\n\t\t\tcpu, req->hwp_min, req->hwp_max);\n\t}\n\n\t \n\tif (req->hwp_desired && (req->hwp_desired > req->hwp_max)) {\n\t\terrx(1, \"cpu%d: requested hwp-desired %d > hwp_max %d\",\n\t\t\tcpu, req->hwp_desired, req->hwp_max);\n\t}\n\t \n\tif (req->hwp_desired && (req->hwp_desired < req->hwp_min)) {\n\t\terrx(1, \"cpu%d: requested hwp-desired %d < requested hwp_min %d\",\n\t\t\tcpu, req->hwp_desired, req->hwp_min);\n\t}\n\n\treturn 0;\n}\n\nint check_hwp_request_v_hwp_capabilities(int cpu, struct msr_hwp_request *req, struct msr_hwp_cap *cap)\n{\n\tif (update_hwp_max) {\n\t\tif (req->hwp_max > cap->highest)\n\t\t\terrx(1, \"cpu%d: requested max %d > capabilities highest %d, use --force?\",\n\t\t\t\tcpu, req->hwp_max, cap->highest);\n\t\tif (req->hwp_max < cap->lowest)\n\t\t\terrx(1, \"cpu%d: requested max %d < capabilities lowest %d, use --force?\",\n\t\t\t\tcpu, req->hwp_max, cap->lowest);\n\t}\n\n\tif (update_hwp_min) {\n\t\tif (req->hwp_min > cap->highest)\n\t\t\terrx(1, \"cpu%d: requested min %d > capabilities highest %d, use --force?\",\n\t\t\t\tcpu, req->hwp_min, cap->highest);\n\t\tif (req->hwp_min < cap->lowest)\n\t\t\terrx(1, \"cpu%d: requested min %d < capabilities lowest %d, use --force?\",\n\t\t\t\tcpu, req->hwp_min, cap->lowest);\n\t}\n\n\tif (update_hwp_min && update_hwp_max && (req->hwp_min > req->hwp_max))\n\t\terrx(1, \"cpu%d: requested min %d > requested max %d\",\n\t\t\tcpu, req->hwp_min, req->hwp_max);\n\n\tif (update_hwp_desired && req->hwp_desired) {\n\t\tif (req->hwp_desired > req->hwp_max)\n\t\t\terrx(1, \"cpu%d: requested desired %d > requested max %d, use --force?\",\n\t\t\t\tcpu, req->hwp_desired, req->hwp_max);\n\t\tif (req->hwp_desired < req->hwp_min)\n\t\t\terrx(1, \"cpu%d: requested desired %d < requested min %d, use --force?\",\n\t\t\t\tcpu, req->hwp_desired, req->hwp_min);\n\t\tif (req->hwp_desired < cap->lowest)\n\t\t\terrx(1, \"cpu%d: requested desired %d < capabilities lowest %d, use --force?\",\n\t\t\t\tcpu, req->hwp_desired, cap->lowest);\n\t\tif (req->hwp_desired > cap->highest)\n\t\t\terrx(1, \"cpu%d: requested desired %d > capabilities highest %d, use --force?\",\n\t\t\t\tcpu, req->hwp_desired, cap->highest);\n\t}\n\n\treturn 0;\n}\n\nint update_hwp_request(int cpu)\n{\n\tstruct msr_hwp_request req;\n\tstruct msr_hwp_cap cap;\n\n\tint msr_offset = MSR_HWP_REQUEST;\n\n\tread_hwp_request(cpu, &req, msr_offset);\n\tif (debug)\n\t\tprint_hwp_request(cpu, &req, \"old: \");\n\n\tif (update_hwp_min)\n\t\treq.hwp_min = req_update.hwp_min;\n\n\tif (update_hwp_max)\n\t\treq.hwp_max = req_update.hwp_max;\n\n\tif (update_hwp_desired)\n\t\treq.hwp_desired = req_update.hwp_desired;\n\n\tif (update_hwp_window)\n\t\treq.hwp_window = req_update.hwp_window;\n\n\tif (update_hwp_epp)\n\t\treq.hwp_epp = req_update.hwp_epp;\n\n\treq.hwp_use_pkg = req_update.hwp_use_pkg;\n\n\tread_hwp_cap(cpu, &cap, MSR_HWP_CAPABILITIES);\n\tif (debug)\n\t\tprint_hwp_cap(cpu, &cap, \"\");\n\n\tif (!force)\n\t\tcheck_hwp_request_v_hwp_capabilities(cpu, &req, &cap);\n\n\tverify_hwp_req_self_consistency(cpu, &req);\n\n\twrite_hwp_request(cpu, &req, msr_offset);\n\n\tif (debug) {\n\t\tread_hwp_request(cpu, &req, msr_offset);\n\t\tprint_hwp_request(cpu, &req, \"new: \");\n\t}\n\treturn 0;\n}\nint update_hwp_request_pkg(int pkg)\n{\n\tstruct msr_hwp_request req;\n\tstruct msr_hwp_cap cap;\n\tint cpu = first_cpu_in_pkg[pkg];\n\n\tint msr_offset = MSR_HWP_REQUEST_PKG;\n\n\tread_hwp_request(cpu, &req, msr_offset);\n\tif (debug)\n\t\tprint_hwp_request_pkg(pkg, &req, \"old: \");\n\n\tif (update_hwp_min)\n\t\treq.hwp_min = req_update.hwp_min;\n\n\tif (update_hwp_max)\n\t\treq.hwp_max = req_update.hwp_max;\n\n\tif (update_hwp_desired)\n\t\treq.hwp_desired = req_update.hwp_desired;\n\n\tif (update_hwp_window)\n\t\treq.hwp_window = req_update.hwp_window;\n\n\tif (update_hwp_epp)\n\t\treq.hwp_epp = req_update.hwp_epp;\n\n\tread_hwp_cap(cpu, &cap, MSR_HWP_CAPABILITIES);\n\tif (debug)\n\t\tprint_hwp_cap(cpu, &cap, \"\");\n\n\tif (!force)\n\t\tcheck_hwp_request_v_hwp_capabilities(cpu, &req, &cap);\n\n\tverify_hwp_req_self_consistency(cpu, &req);\n\n\twrite_hwp_request(cpu, &req, msr_offset);\n\n\tif (debug) {\n\t\tread_hwp_request(cpu, &req, msr_offset);\n\t\tprint_hwp_request_pkg(pkg, &req, \"new: \");\n\t}\n\treturn 0;\n}\n\nint enable_hwp_on_cpu(int cpu)\n{\n\tunsigned long long msr;\n\n\tget_msr(cpu, MSR_PM_ENABLE, &msr);\n\tput_msr(cpu, MSR_PM_ENABLE, 1);\n\n\tif (verbose)\n\t\tprintf(\"cpu%d: MSR_PM_ENABLE old: %d new: %d\\n\", cpu, (unsigned int) msr, 1);\n\n\treturn 0;\n}\n\nint update_cpu_msrs(int cpu)\n{\n\tunsigned long long msr;\n\tint epb;\n\n\tif (update_epb) {\n\t\tepb = get_epb(cpu);\n\t\tset_epb(cpu, new_epb);\n\n\t\tif (verbose)\n\t\t\tprintf(\"cpu%d: ENERGY_PERF_BIAS old: %d new: %d\\n\",\n\t\t\t\tcpu, epb, (unsigned int) new_epb);\n\t}\n\n\tif (update_turbo) {\n\t\tint turbo_is_present_and_disabled;\n\n\t\tget_msr(cpu, MSR_IA32_MISC_ENABLE, &msr);\n\n\t\tturbo_is_present_and_disabled = ((msr & MSR_IA32_MISC_ENABLE_TURBO_DISABLE) != 0);\n\n\t\tif (turbo_update_value == 1)\t{\n\t\t\tif (turbo_is_present_and_disabled) {\n\t\t\t\tmsr &= ~MSR_IA32_MISC_ENABLE_TURBO_DISABLE;\n\t\t\t\tput_msr(cpu, MSR_IA32_MISC_ENABLE, msr);\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"cpu%d: turbo ENABLE\\n\", cpu);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tmsr |= MSR_IA32_MISC_ENABLE_TURBO_DISABLE;\n\t\t\tput_msr(cpu, MSR_IA32_MISC_ENABLE, msr);\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"cpu%d: turbo DISABLE\\n\", cpu);\n\t\t}\n\t}\n\n\tif (!has_hwp)\n\t\treturn 0;\n\n\tif (!hwp_update_enabled())\n\t\treturn 0;\n\n\tupdate_hwp_request(cpu);\n\treturn 0;\n}\n\nunsigned int get_pkg_num(int cpu)\n{\n\tFILE *fp;\n\tchar pathname[128];\n\tunsigned int pkg;\n\tint retval;\n\n\tsprintf(pathname, \"/sys/devices/system/cpu/cpu%d/topology/physical_package_id\", cpu);\n\n\tfp = fopen_or_die(pathname, \"r\");\n\tretval = fscanf(fp, \"%d\\n\", &pkg);\n\tif (retval != 1)\n\t\terrx(1, \"%s: failed to parse\", pathname);\n\treturn pkg;\n}\n\nint set_max_cpu_pkg_num(int cpu)\n{\n\tunsigned int pkg;\n\n\tif (max_cpu_num < cpu)\n\t\tmax_cpu_num = cpu;\n\n\tpkg = get_pkg_num(cpu);\n\n\tif (pkg >= MAX_PACKAGES)\n\t\terrx(1, \"cpu%d: %d >= MAX_PACKAGES (%d)\", cpu, pkg, MAX_PACKAGES);\n\n\tif (pkg > max_pkg_num)\n\t\tmax_pkg_num = pkg;\n\n\tif ((pkg_present_set & (1ULL << pkg)) == 0) {\n\t\tpkg_present_set |= (1ULL << pkg);\n\t\tfirst_cpu_in_pkg[pkg] = cpu;\n\t}\n\n\treturn 0;\n}\nint mark_cpu_present(int cpu)\n{\n\tCPU_SET_S(cpu, cpu_setsize, cpu_present_set);\n\treturn 0;\n}\n\n \nint for_all_proc_cpus(int (func)(int))\n{\n\tFILE *fp;\n\tint cpu_num;\n\tint retval;\n\n\tfp = fopen_or_die(proc_stat, \"r\");\n\n\tretval = fscanf(fp, \"cpu %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\\n\");\n\tif (retval != 0)\n\t\terr(1, \"%s: failed to parse format\", proc_stat);\n\n\twhile (1) {\n\t\tretval = fscanf(fp, \"cpu%u %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\\n\", &cpu_num);\n\t\tif (retval != 1)\n\t\t\tbreak;\n\n\t\tretval = func(cpu_num);\n\t\tif (retval) {\n\t\t\tfclose(fp);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tfclose(fp);\n\treturn 0;\n}\n\nvoid for_all_cpus_in_set(size_t set_size, cpu_set_t *cpu_set, int (func)(int))\n{\n\tint cpu_num;\n\n\tfor (cpu_num = 0; cpu_num <= max_cpu_num; ++cpu_num)\n\t\tif (CPU_ISSET_S(cpu_num, set_size, cpu_set))\n\t\t\tfunc(cpu_num);\n}\n\nvoid init_data_structures(void)\n{\n\tfor_all_proc_cpus(set_max_cpu_pkg_num);\n\n\tcpu_setsize = CPU_ALLOC_SIZE((max_cpu_num + 1));\n\n\tcpu_present_set = CPU_ALLOC((max_cpu_num + 1));\n\tif (cpu_present_set == NULL)\n\t\terr(3, \"CPU_ALLOC\");\n\tCPU_ZERO_S(cpu_setsize, cpu_present_set);\n\tfor_all_proc_cpus(mark_cpu_present);\n}\n\n \n\nvoid verify_hwp_is_enabled(void)\n{\n\tunsigned long long msr;\n\n\tif (!has_hwp)\t \n\t\treturn;\n\n\t \n\tget_msr(base_cpu, MSR_PM_ENABLE, &msr);\n\tif ((msr & 1) == 0) {\n\t\tfprintf(stderr, \"HWP can be enabled using '--hwp-enable'\\n\");\n\t\thas_hwp = 0;\n\t\treturn;\n\t}\n}\n\nint req_update_bounds_check(void)\n{\n\tif (!hwp_update_enabled())\n\t\treturn 0;\n\n\t \n\tif ((update_hwp_max && update_hwp_min) &&\n\t    (req_update.hwp_min > req_update.hwp_max)) {\n\t\tprintf(\"hwp-min %d > hwp_max %d\\n\", req_update.hwp_min, req_update.hwp_max);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (req_update.hwp_desired && update_hwp_max &&\n\t    (req_update.hwp_desired > req_update.hwp_max)) {\n\t\tprintf(\"hwp-desired cannot be greater than hwp_max\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (req_update.hwp_desired && update_hwp_min &&\n\t    (req_update.hwp_desired < req_update.hwp_min)) {\n\t\tprintf(\"hwp-desired cannot be less than hwp_min\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid set_base_cpu(void)\n{\n\tbase_cpu = sched_getcpu();\n\tif (base_cpu < 0)\n\t\terr(-ENODEV, \"No valid cpus found\");\n}\n\n\nvoid probe_dev_msr(void)\n{\n\tstruct stat sb;\n\tchar pathname[32];\n\n\tsprintf(pathname, \"/dev/cpu/%d/msr\", base_cpu);\n\tif (stat(pathname, &sb))\n\t\tif (system(\"/sbin/modprobe msr > /dev/null 2>&1\"))\n\t\t\terr(-5, \"no /dev/cpu/0/msr, Try \\\"# modprobe msr\\\" \");\n}\n\nstatic void get_cpuid_or_exit(unsigned int leaf,\n\t\t\t     unsigned int *eax, unsigned int *ebx,\n\t\t\t     unsigned int *ecx, unsigned int *edx)\n{\n\tif (!__get_cpuid(leaf, eax, ebx, ecx, edx))\n\t\terrx(1, \"Processor not supported\\n\");\n}\n\n \nvoid early_cpuid(void)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\tunsigned int fms, family, model;\n\n\tget_cpuid_or_exit(1, &fms, &ebx, &ecx, &edx);\n\tfamily = (fms >> 8) & 0xf;\n\tmodel = (fms >> 4) & 0xf;\n\tif (family == 6 || family == 0xf)\n\t\tmodel += ((fms >> 16) & 0xf) << 4;\n\n\tif (model == 0x4F) {\n\t\tunsigned long long msr;\n\n\t\tget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT, &msr);\n\n\t\tbdx_highest_ratio = msr & 0xFF;\n\t}\n\n\tget_cpuid_or_exit(0x6, &eax, &ebx, &ecx, &edx);\n\tturbo_is_enabled = (eax >> 1) & 1;\n\thas_hwp = (eax >> 7) & 1;\n\thas_epb = (ecx >> 3) & 1;\n}\n\n \nvoid parse_cpuid(void)\n{\n\tunsigned int eax, ebx, ecx, edx, max_level;\n\tunsigned int fms, family, model, stepping;\n\n\teax = ebx = ecx = edx = 0;\n\n\tget_cpuid_or_exit(0, &max_level, &ebx, &ecx, &edx);\n\n\tif (ebx == 0x756e6547 && edx == 0x49656e69 && ecx == 0x6c65746e)\n\t\tgenuine_intel = 1;\n\n\tif (debug)\n\t\tfprintf(stderr, \"CPUID(0): %.4s%.4s%.4s \",\n\t\t\t(char *)&ebx, (char *)&edx, (char *)&ecx);\n\n\tget_cpuid_or_exit(1, &fms, &ebx, &ecx, &edx);\n\tfamily = (fms >> 8) & 0xf;\n\tmodel = (fms >> 4) & 0xf;\n\tstepping = fms & 0xf;\n\tif (family == 6 || family == 0xf)\n\t\tmodel += ((fms >> 16) & 0xf) << 4;\n\n\tif (debug) {\n\t\tfprintf(stderr, \"%d CPUID levels; family:model:stepping 0x%x:%x:%x (%d:%d:%d)\\n\",\n\t\t\tmax_level, family, model, stepping, family, model, stepping);\n\t\tfprintf(stderr, \"CPUID(1): %s %s %s %s %s %s %s %s\\n\",\n\t\t\tecx & (1 << 0) ? \"SSE3\" : \"-\",\n\t\t\tecx & (1 << 3) ? \"MONITOR\" : \"-\",\n\t\t\tecx & (1 << 7) ? \"EIST\" : \"-\",\n\t\t\tecx & (1 << 8) ? \"TM2\" : \"-\",\n\t\t\tedx & (1 << 4) ? \"TSC\" : \"-\",\n\t\t\tedx & (1 << 5) ? \"MSR\" : \"-\",\n\t\t\tedx & (1 << 22) ? \"ACPI-TM\" : \"-\",\n\t\t\tedx & (1 << 29) ? \"TM\" : \"-\");\n\t}\n\n\tif (!(edx & (1 << 5)))\n\t\terrx(1, \"CPUID: no MSR\");\n\n\n\tget_cpuid_or_exit(0x6, &eax, &ebx, &ecx, &edx);\n\t \n\t \n\thas_hwp_notify = eax & (1 << 8);\n\thas_hwp_activity_window = eax & (1 << 9);\n\thas_hwp_epp = eax & (1 << 10);\n\thas_hwp_request_pkg = eax & (1 << 11);\n\n\tif (!has_hwp_request_pkg && update_hwp_use_pkg)\n\t\terrx(1, \"--hwp-use-pkg is not available on this hardware\");\n\n\t \n\n\tif (debug)\n\t\tfprintf(stderr,\n\t\t\t\"CPUID(6): %sTURBO, %sHWP, %sHWPnotify, %sHWPwindow, %sHWPepp, %sHWPpkg, %sEPB\\n\",\n\t\t\tturbo_is_enabled ? \"\" : \"No-\",\n\t\t\thas_hwp ? \"\" : \"No-\",\n\t\t\thas_hwp_notify ? \"\" : \"No-\",\n\t\t\thas_hwp_activity_window ? \"\" : \"No-\",\n\t\t\thas_hwp_epp ? \"\" : \"No-\",\n\t\t\thas_hwp_request_pkg ? \"\" : \"No-\",\n\t\t\thas_epb ? \"\" : \"No-\");\n\n\treturn;\t \n}\n\nint main(int argc, char **argv)\n{\n\tset_base_cpu();\n\tprobe_dev_msr();\n\tinit_data_structures();\n\n\tearly_cpuid();\t \n\n\tcmdline(argc, argv);\n\n\tif (debug)\n\t\tprint_version();\n\n\tparse_cpuid();\n\n\t  \n\tif ((cpu_selected_set == 0) && (pkg_selected_set == 0))\n\t\tcpu_selected_set = cpu_present_set;\n\n\t \n\tif (update_hwp_enable)\n\t\tfor_all_cpus_in_set(cpu_setsize, cpu_selected_set, enable_hwp_on_cpu);\n\n\t \n\tverify_hwp_is_enabled();\n\n\tif (req_update_bounds_check())\n\t\treturn -EINVAL;\n\n\t \n\tif (!update_epb && !update_turbo && !hwp_update_enabled()) {\n\t\tif (cpu_selected_set)\n\t\t\tfor_all_cpus_in_set(cpu_setsize, cpu_selected_set, print_cpu_msrs);\n\n\t\tif (has_hwp_request_pkg) {\n\t\t\tif (pkg_selected_set == 0)\n\t\t\t\tpkg_selected_set = pkg_present_set;\n\n\t\t\tfor_packages(pkg_selected_set, print_pkg_msrs);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (cpu_selected_set) {\n\t\tfor_all_cpus_in_set(cpu_setsize, cpu_selected_set, update_sysfs);\n\t\tfor_all_cpus_in_set(cpu_setsize, cpu_selected_set, update_cpu_msrs);\n\t} else if (pkg_selected_set)\n\t\tfor_packages(pkg_selected_set, update_hwp_request_pkg);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}