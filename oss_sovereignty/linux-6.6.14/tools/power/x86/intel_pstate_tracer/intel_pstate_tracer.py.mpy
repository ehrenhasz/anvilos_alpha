{
  "module_name": "intel_pstate_tracer.py",
  "hash_id": "35958f0f18ec885bda60cfbe0deac7f286eba2f500be790ca4c6a24210285213",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/x86/intel_pstate_tracer/intel_pstate_tracer.py",
  "human_readable_source": "#!/usr/bin/env python\n# SPDX-License-Identifier: GPL-2.0-only\n# -*- coding: utf-8 -*-\n#\n\"\"\" This utility can be used to debug and tune the performance of the\nintel_pstate driver. This utility can be used in two ways:\n- If there is Linux trace file with pstate_sample events enabled, then\nthis utility can parse the trace file and generate performance plots.\n- If user has not specified a trace file as input via command line parameters,\nthen this utility enables and collects trace data for a user specified interval\nand generates performance plots.\n\nPrerequisites:\n    Python version 2.7.x or higher\n    gnuplot 5.0 or higher\n    gnuplot-py 1.8 or higher\n    (Most of the distributions have these required packages. They may be called\n     gnuplot-py, phython-gnuplot or phython3-gnuplot, gnuplot-nox, ... )\n\n    HWP (Hardware P-States are disabled)\n    Kernel config for Linux trace is enabled\n\n    see print_help(): for Usage and Output details\n\n\"\"\"\nfrom __future__ import print_function\nfrom datetime import datetime\nimport subprocess\nimport os\nimport time\nimport re\nimport signal\nimport sys\nimport getopt\nimport Gnuplot\nfrom numpy import *\nfrom decimal import *\n\n__author__ = \"Srinivas Pandruvada\"\n__copyright__ = \" Copyright (c) 2017, Intel Corporation. \"\n__license__ = \"GPL version 2\"\n\n\nMAX_CPUS = 256\n\n# Define the csv file columns\nC_COMM = 18\nC_GHZ = 17\nC_ELAPSED = 16\nC_SAMPLE = 15\nC_DURATION = 14\nC_LOAD = 13\nC_BOOST = 12\nC_FREQ = 11\nC_TSC = 10\nC_APERF = 9\nC_MPERF = 8\nC_TO = 7\nC_FROM = 6\nC_SCALED = 5\nC_CORE = 4\nC_USEC = 3\nC_SEC = 2\nC_CPU = 1\n\nglobal sample_num, last_sec_cpu, last_usec_cpu, start_time, testname, trace_file\n\n# 11 digits covers uptime to 115 days\ngetcontext().prec = 11\n\nsample_num =0\nlast_sec_cpu = [0] * MAX_CPUS\nlast_usec_cpu = [0] * MAX_CPUS\n\ndef print_help(driver_name):\n    print('%s_tracer.py:'%driver_name)\n    print('  Usage:')\n    print('    If the trace file is available, then to simply parse and plot, use (sudo not required):')\n    print('      ./%s_tracer.py [-c cpus] -t <trace_file> -n <test_name>'%driver_name)\n    print('    Or')\n    print('      ./%s_tracer.py [--cpu cpus] ---trace_file <trace_file> --name <test_name>'%driver_name)\n    print('    To generate trace file, parse and plot, use (sudo required):')\n    print('      sudo ./%s_tracer.py [-c cpus] -i <interval> -n <test_name> -m <kbytes>'%driver_name)\n    print('    Or')\n    print('      sudo ./%s_tracer.py [--cpu cpus] --interval <interval> --name <test_name> --memory <kbytes>'%driver_name)\n    print('    Optional argument:')\n    print('      cpus:   comma separated list of CPUs')\n    print('      kbytes: Kilo bytes of memory per CPU to allocate to the trace buffer. Default: 10240')\n    print('  Output:')\n    print('    If not already present, creates a \"results/test_name\" folder in the current working directory with:')\n    print('      cpu.csv - comma seperated values file with trace contents and some additional calculations.')\n    print('      cpu???.csv - comma seperated values file for CPU number ???.')\n    print('      *.png - a variety of PNG format plot files created from the trace contents and the additional calculations.')\n    print('  Notes:')\n    print('    Avoid the use of _ (underscore) in test names, because in gnuplot it is a subscript directive.')\n    print('    Maximum number of CPUs is {0:d}. If there are more the script will abort with an error.'.format(MAX_CPUS))\n    print('    Off-line CPUs cause the script to list some warnings, and create some empty files. Use the CPU mask feature for a clean run.')\n    print('    Empty y range warnings for autoscaled plots can occur and can be ignored.')\n\ndef plot_perf_busy_with_sample(cpu_index):\n    \"\"\" Plot method to per cpu information \"\"\"\n\n    file_name = 'cpu{:0>3}.csv'.format(cpu_index)\n    if os.path.exists(file_name):\n        output_png = \"cpu%03d_perf_busy_vs_samples.png\" % cpu_index\n        g_plot = common_all_gnuplot_settings(output_png)\n#   autoscale this one, no set y1 range\n        g_plot('set y2range [0:200]')\n        g_plot('set y2tics 0, 10')\n        g_plot('set title \"{} : cpu perf busy vs. sample : CPU {:0>3} : {:%F %H:%M}\"'.format(testname, cpu_index, datetime.now()))\n#       Override common\n        g_plot('set xlabel \"Samples\"')\n        g_plot('set ylabel \"P-State\"')\n        g_plot('set y2label \"Scaled Busy/performance/io-busy(%)\"')\n        set_4_plot_linestyles(g_plot)\n        g_plot('plot \"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 1 axis x1y2 title \"performance\",\\\\'.format(C_SAMPLE, C_CORE))\n        g_plot('\"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 2 axis x1y2 title \"scaled-busy\",\\\\'.format(C_SAMPLE, C_SCALED))\n        g_plot('\"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 3 axis x1y2 title \"io-boost\",\\\\'.format(C_SAMPLE, C_BOOST))\n        g_plot('\"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 4 axis x1y1 title \"P-State\"'.format(C_SAMPLE, C_TO))\n\ndef plot_perf_busy(cpu_index):\n    \"\"\" Plot some per cpu information \"\"\"\n\n    file_name = 'cpu{:0>3}.csv'.format(cpu_index)\n    if os.path.exists(file_name):\n        output_png = \"cpu%03d_perf_busy.png\" % cpu_index\n        g_plot = common_all_gnuplot_settings(output_png)\n#   autoscale this one, no set y1 range\n        g_plot('set y2range [0:200]')\n        g_plot('set y2tics 0, 10')\n        g_plot('set title \"{} : perf busy : CPU {:0>3} : {:%F %H:%M}\"'.format(testname, cpu_index, datetime.now()))\n        g_plot('set ylabel \"P-State\"')\n        g_plot('set y2label \"Scaled Busy/performance/io-busy(%)\"')\n        set_4_plot_linestyles(g_plot)\n        g_plot('plot \"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 1 axis x1y2 title \"performance\",\\\\'.format(C_ELAPSED, C_CORE))\n        g_plot('\"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 2 axis x1y2 title \"scaled-busy\",\\\\'.format(C_ELAPSED, C_SCALED))\n        g_plot('\"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 3 axis x1y2 title \"io-boost\",\\\\'.format(C_ELAPSED, C_BOOST))\n        g_plot('\"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 4 axis x1y1 title \"P-State\"'.format(C_ELAPSED, C_TO))\n\ndef plot_durations(cpu_index):\n    \"\"\" Plot per cpu durations \"\"\"\n\n    file_name = 'cpu{:0>3}.csv'.format(cpu_index)\n    if os.path.exists(file_name):\n        output_png = \"cpu%03d_durations.png\" % cpu_index\n        g_plot = common_all_gnuplot_settings(output_png)\n#       autoscale this one, no set y range\n        g_plot('set title \"{} : durations : CPU {:0>3} : {:%F %H:%M}\"'.format(testname, cpu_index, datetime.now()))\n        g_plot('set ylabel \"Timer Duration (MilliSeconds)\"')\n#       override common\n        g_plot('set key off')\n        set_4_plot_linestyles(g_plot)\n        g_plot('plot \"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 1 axis x1y1'.format(C_ELAPSED, C_DURATION))\n\ndef plot_loads(cpu_index):\n    \"\"\" Plot per cpu loads \"\"\"\n\n    file_name = 'cpu{:0>3}.csv'.format(cpu_index)\n    if os.path.exists(file_name):\n        output_png = \"cpu%03d_loads.png\" % cpu_index\n        g_plot = common_all_gnuplot_settings(output_png)\n        g_plot('set yrange [0:100]')\n        g_plot('set ytics 0, 10')\n        g_plot('set title \"{} : loads : CPU {:0>3} : {:%F %H:%M}\"'.format(testname, cpu_index, datetime.now()))\n        g_plot('set ylabel \"CPU load (percent)\"')\n#       override common\n        g_plot('set key off')\n        set_4_plot_linestyles(g_plot)\n        g_plot('plot \"' + file_name + '\" using {:d}:{:d} with linespoints linestyle 1 axis x1y1'.format(C_ELAPSED, C_LOAD))\n\ndef plot_pstate_cpu_with_sample():\n    \"\"\" Plot all cpu information \"\"\"\n\n    if os.path.exists('cpu.csv'):\n        output_png = 'all_cpu_pstates_vs_samples.png'\n        g_plot = common_all_gnuplot_settings(output_png)\n#       autoscale this one, no set y range\n#       override common\n        g_plot('set xlabel \"Samples\"')\n        g_plot('set ylabel \"P-State\"')\n        g_plot('set title \"{} : cpu pstate vs. sample : {:%F %H:%M}\"'.format(testname, datetime.now()))\n        title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n        plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 7 ps 1 title i\".format(C_SAMPLE, C_TO)\n        g_plot('title_list = \"{}\"'.format(title_list))\n        g_plot(plot_str)\n\ndef plot_pstate_cpu():\n    \"\"\" Plot all cpu information from csv files \"\"\"\n\n    output_png = 'all_cpu_pstates.png'\n    g_plot = common_all_gnuplot_settings(output_png)\n#   autoscale this one, no set y range\n    g_plot('set ylabel \"P-State\"')\n    g_plot('set title \"{} : cpu pstates : {:%F %H:%M}\"'.format(testname, datetime.now()))\n\n#    the following command is really cool, but doesn't work with the CPU masking option because it aborts on the first missing file.\n#    plot_str = 'plot for [i=0:*] file=sprintf(\"cpu%03d.csv\",i) title_s=sprintf(\"cpu%03d\",i) file using 16:7 pt 7 ps 1 title title_s'\n#\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 7 ps 1 title i\".format(C_ELAPSED, C_TO)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef plot_load_cpu():\n    \"\"\" Plot all cpu loads \"\"\"\n\n    output_png = 'all_cpu_loads.png'\n    g_plot = common_all_gnuplot_settings(output_png)\n    g_plot('set yrange [0:100]')\n    g_plot('set ylabel \"CPU load (percent)\"')\n    g_plot('set title \"{} : cpu loads : {:%F %H:%M}\"'.format(testname, datetime.now()))\n\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 7 ps 1 title i\".format(C_ELAPSED, C_LOAD)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef plot_frequency_cpu():\n    \"\"\" Plot all cpu frequencies \"\"\"\n\n    output_png = 'all_cpu_frequencies.png'\n    g_plot = common_all_gnuplot_settings(output_png)\n#   autoscale this one, no set y range\n    g_plot('set ylabel \"CPU Frequency (GHz)\"')\n    g_plot('set title \"{} : cpu frequencies : {:%F %H:%M}\"'.format(testname, datetime.now()))\n\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 7 ps 1 title i\".format(C_ELAPSED, C_FREQ)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef plot_duration_cpu():\n    \"\"\" Plot all cpu durations \"\"\"\n\n    output_png = 'all_cpu_durations.png'\n    g_plot = common_all_gnuplot_settings(output_png)\n#   autoscale this one, no set y range\n    g_plot('set ylabel \"Timer Duration (MilliSeconds)\"')\n    g_plot('set title \"{} : cpu durations : {:%F %H:%M}\"'.format(testname, datetime.now()))\n\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 7 ps 1 title i\".format(C_ELAPSED, C_DURATION)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef plot_scaled_cpu():\n    \"\"\" Plot all cpu scaled busy \"\"\"\n\n    output_png = 'all_cpu_scaled.png'\n    g_plot = common_all_gnuplot_settings(output_png)\n#   autoscale this one, no set y range\n    g_plot('set ylabel \"Scaled Busy (Unitless)\"')\n    g_plot('set title \"{} : cpu scaled busy : {:%F %H:%M}\"'.format(testname, datetime.now()))\n\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 7 ps 1 title i\".format(C_ELAPSED, C_SCALED)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef plot_boost_cpu():\n    \"\"\" Plot all cpu IO Boosts \"\"\"\n\n    output_png = 'all_cpu_boost.png'\n    g_plot = common_all_gnuplot_settings(output_png)\n    g_plot('set yrange [0:100]')\n    g_plot('set ylabel \"CPU IO Boost (percent)\"')\n    g_plot('set title \"{} : cpu io boost : {:%F %H:%M}\"'.format(testname, datetime.now()))\n\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 7 ps 1 title i\".format(C_ELAPSED, C_BOOST)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef plot_ghz_cpu():\n    \"\"\" Plot all cpu tsc ghz \"\"\"\n\n    output_png = 'all_cpu_ghz.png'\n    g_plot = common_all_gnuplot_settings(output_png)\n#   autoscale this one, no set y range\n    g_plot('set ylabel \"TSC Frequency (GHz)\"')\n    g_plot('set title \"{} : cpu TSC Frequencies (Sanity check calculation) : {:%F %H:%M}\"'.format(testname, datetime.now()))\n\n    title_list = subprocess.check_output('ls cpu???.csv | sed -e \\'s/.csv//\\'',shell=True).decode('utf-8').replace('\\n', ' ')\n    plot_str = \"plot for [i in title_list] i.'.csv' using {:d}:{:d} pt 7 ps 1 title i\".format(C_ELAPSED, C_GHZ)\n    g_plot('title_list = \"{}\"'.format(title_list))\n    g_plot(plot_str)\n\ndef common_all_gnuplot_settings(output_png):\n    \"\"\" common gnuplot settings for multiple CPUs one one graph. \"\"\"\n\n    g_plot = common_gnuplot_settings()\n    g_plot('set output \"' + output_png + '\"')\n    return(g_plot)\n\ndef common_gnuplot_settings():\n    \"\"\" common gnuplot settings. \"\"\"\n\n    g_plot = Gnuplot.Gnuplot(persist=1)\n#   The following line is for rigor only. It seems to be assumed for .csv files\n    g_plot('set datafile separator \\\",\\\"')\n    g_plot('set ytics nomirror')\n    g_plot('set xtics nomirror')\n    g_plot('set xtics font \", 10\"')\n    g_plot('set ytics font \", 10\"')\n    g_plot('set tics out scale 1.0')\n    g_plot('set grid')\n    g_plot('set key out horiz')\n    g_plot('set key bot center')\n    g_plot('set key samplen 2 spacing .8 font \", 9\"')\n    g_plot('set term png size 1200, 600')\n    g_plot('set title font \", 11\"')\n    g_plot('set ylabel font \", 10\"')\n    g_plot('set xlabel font \", 10\"')\n    g_plot('set xlabel offset 0, 0.5')\n    g_plot('set xlabel \"Elapsed Time (Seconds)\"')\n    return(g_plot)\n\ndef set_4_plot_linestyles(g_plot):\n    \"\"\" set the linestyles used for 4 plots in 1 graphs. \"\"\"\n\n    g_plot('set style line 1 linetype 1 linecolor rgb \"green\" pointtype -1')\n    g_plot('set style line 2 linetype 1 linecolor rgb \"red\" pointtype -1')\n    g_plot('set style line 3 linetype 1 linecolor rgb \"purple\" pointtype -1')\n    g_plot('set style line 4 linetype 1 linecolor rgb \"blue\" pointtype -1')\n\ndef store_csv(cpu_int, time_pre_dec, time_post_dec, core_busy, scaled, _from, _to, mperf, aperf, tsc, freq_ghz, io_boost, common_comm, load, duration_ms, sample_num, elapsed_time, tsc_ghz, cpu_mask):\n    \"\"\" Store master csv file information \"\"\"\n\n    global graph_data_present\n\n    if cpu_mask[cpu_int] == 0:\n        return\n\n    try:\n        f_handle = open('cpu.csv', 'a')\n        string_buffer = \"CPU_%03u, %05u, %06u, %u, %u, %u, %u, %u, %u, %u, %.4f, %u, %.2f, %.3f, %u, %.3f, %.3f, %s\\n\" % (cpu_int, int(time_pre_dec), int(time_post_dec), int(core_busy), int(scaled), int(_from), int(_to), int(mperf), int(aperf), int(tsc), freq_ghz, int(io_boost), load, duration_ms, sample_num, elapsed_time, tsc_ghz, common_comm)\n        f_handle.write(string_buffer);\n        f_handle.close()\n    except:\n        print('IO error cpu.csv')\n        return\n\n    graph_data_present = True;\n\ndef split_csv(current_max_cpu, cpu_mask):\n    \"\"\" seperate the all csv file into per CPU csv files. \"\"\"\n\n    if os.path.exists('cpu.csv'):\n        for index in range(0, current_max_cpu + 1):\n            if cpu_mask[int(index)] != 0:\n                os.system('grep -m 1 common_cpu cpu.csv > cpu{:0>3}.csv'.format(index))\n                os.system('grep CPU_{:0>3} cpu.csv >> cpu{:0>3}.csv'.format(index, index))\n\ndef fix_ownership(path):\n    \"\"\"Change the owner of the file to SUDO_UID, if required\"\"\"\n\n    uid = os.environ.get('SUDO_UID')\n    gid = os.environ.get('SUDO_GID')\n    if uid is not None:\n        os.chown(path, int(uid), int(gid))\n\ndef cleanup_data_files():\n    \"\"\" clean up existing data files \"\"\"\n\n    if os.path.exists('cpu.csv'):\n        os.remove('cpu.csv')\n    f_handle = open('cpu.csv', 'a')\n    f_handle.write('common_cpu, common_secs, common_usecs, core_busy, scaled_busy, from, to, mperf, aperf, tsc, freq, boost, load, duration_ms, sample_num, elapsed_time, tsc_ghz, common_comm')\n    f_handle.write('\\n')\n    f_handle.close()\n\ndef clear_trace_file():\n    \"\"\" Clear trace file \"\"\"\n\n    try:\n        f_handle = open('/sys/kernel/tracing/trace', 'w')\n        f_handle.close()\n    except:\n        print('IO error clearing trace file ')\n        sys.exit(2)\n\ndef enable_trace(trace_file):\n    \"\"\" Enable trace \"\"\"\n\n    try:\n        open(trace_file,'w').write(\"1\")\n    except:\n        print('IO error enabling trace ')\n        sys.exit(2)\n\ndef disable_trace(trace_file):\n    \"\"\" Disable trace \"\"\"\n\n    try:\n       open(trace_file, 'w').write(\"0\")\n    except:\n        print('IO error disabling trace ')\n        sys.exit(2)\n\ndef set_trace_buffer_size(memory):\n    \"\"\" Set trace buffer size \"\"\"\n\n    try:\n       with open('/sys/kernel/tracing/buffer_size_kb', 'w') as fp:\n          fp.write(memory)\n    except:\n       print('IO error setting trace buffer size ')\n       sys.exit(2)\n\ndef free_trace_buffer():\n    \"\"\" Free the trace buffer memory \"\"\"\n\n    try:\n       open('/sys/kernel/tracing/buffer_size_kb'\n                 , 'w').write(\"1\")\n    except:\n        print('IO error freeing trace buffer ')\n        sys.exit(2)\n\ndef read_trace_data(filename, cpu_mask):\n    \"\"\" Read and parse trace data \"\"\"\n\n    global current_max_cpu\n    global sample_num, last_sec_cpu, last_usec_cpu, start_time\n\n    try:\n        data = open(filename, 'r').read()\n    except:\n        print('Error opening ', filename)\n        sys.exit(2)\n\n    for line in data.splitlines():\n        search_obj = \\\n            re.search(r'(^(.*?)\\[)((\\d+)[^\\]])(.*?)(\\d+)([.])(\\d+)(.*?core_busy=)(\\d+)(.*?scaled=)(\\d+)(.*?from=)(\\d+)(.*?to=)(\\d+)(.*?mperf=)(\\d+)(.*?aperf=)(\\d+)(.*?tsc=)(\\d+)(.*?freq=)(\\d+)'\n                      , line)\n\n        if search_obj:\n            cpu = search_obj.group(3)\n            cpu_int = int(cpu)\n            cpu = str(cpu_int)\n\n            time_pre_dec = search_obj.group(6)\n            time_post_dec = search_obj.group(8)\n            core_busy = search_obj.group(10)\n            scaled = search_obj.group(12)\n            _from = search_obj.group(14)\n            _to = search_obj.group(16)\n            mperf = search_obj.group(18)\n            aperf = search_obj.group(20)\n            tsc = search_obj.group(22)\n            freq = search_obj.group(24)\n            common_comm = search_obj.group(2).replace(' ', '')\n\n            # Not all kernel versions have io_boost field\n            io_boost = '0'\n            search_obj = re.search(r'.*?io_boost=(\\d+)', line)\n            if search_obj:\n                io_boost = search_obj.group(1)\n\n            if sample_num == 0 :\n                start_time = Decimal(time_pre_dec) + Decimal(time_post_dec) / Decimal(1000000)\n            sample_num += 1\n\n            if last_sec_cpu[cpu_int] == 0 :\n                last_sec_cpu[cpu_int] = time_pre_dec\n                last_usec_cpu[cpu_int] = time_post_dec\n            else :\n                duration_us = (int(time_pre_dec) - int(last_sec_cpu[cpu_int])) * 1000000 + (int(time_post_dec) - int(last_usec_cpu[cpu_int]))\n                duration_ms = Decimal(duration_us) / Decimal(1000)\n                last_sec_cpu[cpu_int] = time_pre_dec\n                last_usec_cpu[cpu_int] = time_post_dec\n                elapsed_time = Decimal(time_pre_dec) + Decimal(time_post_dec) / Decimal(1000000) - start_time\n                load = Decimal(int(mperf)*100)/ Decimal(tsc)\n                freq_ghz = Decimal(freq)/Decimal(1000000)\n#               Sanity check calculation, typically anomalies indicate missed samples\n#               However, check for 0 (should never occur)\n                tsc_ghz = Decimal(0)\n                if duration_ms != Decimal(0) :\n                    tsc_ghz = Decimal(tsc)/duration_ms/Decimal(1000000)\n                store_csv(cpu_int, time_pre_dec, time_post_dec, core_busy, scaled, _from, _to, mperf, aperf, tsc, freq_ghz, io_boost, common_comm, load, duration_ms, sample_num, elapsed_time, tsc_ghz, cpu_mask)\n\n            if cpu_int > current_max_cpu:\n                current_max_cpu = cpu_int\n# End of for each trace line loop\n# Now seperate the main overall csv file into per CPU csv files.\n    split_csv(current_max_cpu, cpu_mask)\n\ndef signal_handler(signal, frame):\n    print(' SIGINT: Forcing cleanup before exit.')\n    if interval:\n        disable_trace(trace_file)\n        clear_trace_file()\n        # Free the memory\n        free_trace_buffer()\n        sys.exit(0)\n\nif __name__ == \"__main__\":\n    trace_file = \"/sys/kernel/tracing/events/power/pstate_sample/enable\"\n    signal.signal(signal.SIGINT, signal_handler)\n\n    interval = \"\"\n    filename = \"\"\n    cpu_list = \"\"\n    testname = \"\"\n    memory = \"10240\"\n    graph_data_present = False;\n\n    valid1 = False\n    valid2 = False\n\n    cpu_mask = zeros((MAX_CPUS,), dtype=int)\n\n    try:\n        opts, args = getopt.getopt(sys.argv[1:],\"ht:i:c:n:m:\",[\"help\",\"trace_file=\",\"interval=\",\"cpu=\",\"name=\",\"memory=\"])\n    except getopt.GetoptError:\n        print_help('intel_pstate')\n        sys.exit(2)\n    for opt, arg in opts:\n        if opt == '-h':\n            print_help('intel_pstate')\n            sys.exit()\n        elif opt in (\"-t\", \"--trace_file\"):\n            valid1 = True\n            location = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))\n            filename = os.path.join(location, arg)\n        elif opt in (\"-i\", \"--interval\"):\n            valid1 = True\n            interval = arg\n        elif opt in (\"-c\", \"--cpu\"):\n            cpu_list = arg\n        elif opt in (\"-n\", \"--name\"):\n            valid2 = True\n            testname = arg\n        elif opt in (\"-m\", \"--memory\"):\n            memory = arg\n\n    if not (valid1 and valid2):\n        print_help('intel_pstate')\n        sys.exit()\n\n    if cpu_list:\n        for p in re.split(\"[,]\", cpu_list):\n            if int(p) < MAX_CPUS :\n                cpu_mask[int(p)] = 1\n    else:\n        for i in range (0, MAX_CPUS):\n            cpu_mask[i] = 1\n\n    if not os.path.exists('results'):\n        os.mkdir('results')\n        # The regular user needs to own the directory, not root.\n        fix_ownership('results')\n\n    os.chdir('results')\n    if os.path.exists(testname):\n        print('The test name directory already exists. Please provide a unique test name. Test re-run not supported, yet.')\n        sys.exit()\n    os.mkdir(testname)\n    # The regular user needs to own the directory, not root.\n    fix_ownership(testname)\n    os.chdir(testname)\n\n    # Temporary (or perhaps not)\n    cur_version = sys.version_info\n    print('python version (should be >= 2.7):')\n    print(cur_version)\n\n    # Left as \"cleanup\" for potential future re-run ability.\n    cleanup_data_files()\n\n    if interval:\n        filename = \"/sys/kernel/tracing/trace\"\n        clear_trace_file()\n        set_trace_buffer_size(memory)\n        enable_trace(trace_file)\n        print('Sleeping for ', interval, 'seconds')\n        time.sleep(int(interval))\n        disable_trace(trace_file)\n\n    current_max_cpu = 0\n\n    read_trace_data(filename, cpu_mask)\n\n    if interval:\n        clear_trace_file()\n        # Free the memory\n        free_trace_buffer()\n\n    if graph_data_present == False:\n        print('No valid data to plot')\n        sys.exit(2)\n\n    for cpu_no in range(0, current_max_cpu + 1):\n        plot_perf_busy_with_sample(cpu_no)\n        plot_perf_busy(cpu_no)\n        plot_durations(cpu_no)\n        plot_loads(cpu_no)\n\n    plot_pstate_cpu_with_sample()\n    plot_pstate_cpu()\n    plot_load_cpu()\n    plot_frequency_cpu()\n    plot_duration_cpu()\n    plot_scaled_cpu()\n    plot_boost_cpu()\n    plot_ghz_cpu()\n\n    # It is preferrable, but not necessary, that the regular user owns the files, not root.\n    for root, dirs, files in os.walk('.'):\n        for f in files:\n            fix_ownership(f)\n\n    os.chdir('../../')\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}