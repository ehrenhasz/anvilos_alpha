{
  "module_name": "bootgraph.py",
  "hash_id": "0c4fe2aa881e1e0a9ab5b40c63aaeaa450fb2826018dae0d95f4f4d8797aa48a",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/pm-graph/bootgraph.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Tool for analyzing boot timing\n# Copyright (c) 2013, Intel Corporation.\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms and conditions of the GNU General Public License,\n# version 2, as published by the Free Software Foundation.\n#\n# This program is distributed in the hope it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n# more details.\n#\n# Authors:\n#\t Todd Brandt <todd.e.brandt@linux.intel.com>\n#\n# Description:\n#\t This tool is designed to assist kernel and OS developers in optimizing\n#\t their linux stack's boot time. It creates an html representation of\n#\t the kernel boot timeline up to the start of the init process.\n#\n\n# ----------------- LIBRARIES --------------------\n\nimport sys\nimport time\nimport os\nimport string\nimport re\nimport platform\nimport shutil\nfrom datetime import datetime, timedelta\nfrom subprocess import call, Popen, PIPE\nimport sleepgraph as aslib\n\ndef pprint(msg):\n\tprint(msg)\n\tsys.stdout.flush()\n\n# ----------------- CLASSES --------------------\n\n# Class: SystemValues\n# Description:\n#\t A global, single-instance container used to\n#\t store system values and test parameters\nclass SystemValues(aslib.SystemValues):\n\ttitle = 'BootGraph'\n\tversion = '2.2'\n\thostname = 'localhost'\n\ttesttime = ''\n\tkernel = ''\n\tdmesgfile = ''\n\tftracefile = ''\n\thtmlfile = 'bootgraph.html'\n\ttestdir = ''\n\tkparams = ''\n\tresult = ''\n\tuseftrace = False\n\tusecallgraph = False\n\tsuspendmode = 'boot'\n\tmax_graph_depth = 2\n\tgraph_filter = 'do_one_initcall'\n\treboot = False\n\tmanual = False\n\tiscronjob = False\n\ttimeformat = '%.6f'\n\tbootloader = 'grub'\n\tblexec = []\n\tdef __init__(self):\n\t\tself.kernel, self.hostname = 'unknown', platform.node()\n\t\tself.testtime = datetime.now().strftime('%Y-%m-%d_%H:%M:%S')\n\t\tif os.path.exists('/proc/version'):\n\t\t\tfp = open('/proc/version', 'r')\n\t\t\tself.kernel = self.kernelVersion(fp.read().strip())\n\t\t\tfp.close()\n\t\tself.testdir = datetime.now().strftime('boot-%y%m%d-%H%M%S')\n\tdef kernelVersion(self, msg):\n\t\tm = re.match('^[Ll]inux *[Vv]ersion *(?P<v>\\S*) .*', msg)\n\t\tif m:\n\t\t\treturn m.group('v')\n\t\treturn 'unknown'\n\tdef checkFtraceKernelVersion(self):\n\t\tm = re.match('^(?P<x>[0-9]*)\\.(?P<y>[0-9]*)\\.(?P<z>[0-9]*).*', self.kernel)\n\t\tif m:\n\t\t\tval = tuple(map(int, m.groups()))\n\t\t\tif val >= (4, 10, 0):\n\t\t\t\treturn True\n\t\treturn False\n\tdef kernelParams(self):\n\t\tcmdline = 'initcall_debug log_buf_len=32M'\n\t\tif self.useftrace:\n\t\t\tif self.cpucount > 0:\n\t\t\t\tbs = min(self.memtotal // 2, 2*1024*1024) // self.cpucount\n\t\t\telse:\n\t\t\t\tbs = 131072\n\t\t\tcmdline += ' trace_buf_size=%dK trace_clock=global '\\\n\t\t\t'trace_options=nooverwrite,funcgraph-abstime,funcgraph-cpu,'\\\n\t\t\t'funcgraph-duration,funcgraph-proc,funcgraph-tail,'\\\n\t\t\t'nofuncgraph-overhead,context-info,graph-time '\\\n\t\t\t'ftrace=function_graph '\\\n\t\t\t'ftrace_graph_max_depth=%d '\\\n\t\t\t'ftrace_graph_filter=%s' % \\\n\t\t\t\t(bs, self.max_graph_depth, self.graph_filter)\n\t\treturn cmdline\n\tdef setGraphFilter(self, val):\n\t\tmaster = self.getBootFtraceFilterFunctions()\n\t\tfs = ''\n\t\tfor i in val.split(','):\n\t\t\tfunc = i.strip()\n\t\t\tif func == '':\n\t\t\t\tdoError('badly formatted filter function string')\n\t\t\tif '[' in func or ']' in func:\n\t\t\t\tdoError('loadable module functions not allowed - \"%s\"' % func)\n\t\t\tif ' ' in func:\n\t\t\t\tdoError('spaces found in filter functions - \"%s\"' % func)\n\t\t\tif func not in master:\n\t\t\t\tdoError('function \"%s\" not available for ftrace' % func)\n\t\t\tif not fs:\n\t\t\t\tfs = func\n\t\t\telse:\n\t\t\t\tfs += ','+func\n\t\tif not fs:\n\t\t\tdoError('badly formatted filter function string')\n\t\tself.graph_filter = fs\n\tdef getBootFtraceFilterFunctions(self):\n\t\tself.rootCheck(True)\n\t\tfp = open(self.tpath+'available_filter_functions')\n\t\tfulllist = fp.read().split('\\n')\n\t\tfp.close()\n\t\tlist = []\n\t\tfor i in fulllist:\n\t\t\tif not i or ' ' in i or '[' in i or ']' in i:\n\t\t\t\tcontinue\n\t\t\tlist.append(i)\n\t\treturn list\n\tdef myCronJob(self, line):\n\t\tif '@reboot' not in line:\n\t\t\treturn False\n\t\tif 'bootgraph' in line or 'analyze_boot.py' in line or '-cronjob' in line:\n\t\t\treturn True\n\t\treturn False\n\tdef cronjobCmdString(self):\n\t\tcmdline = '%s -cronjob' % os.path.abspath(sys.argv[0])\n\t\targs = iter(sys.argv[1:])\n\t\tfor arg in args:\n\t\t\tif arg in ['-h', '-v', '-cronjob', '-reboot', '-verbose']:\n\t\t\t\tcontinue\n\t\t\telif arg in ['-o', '-dmesg', '-ftrace', '-func']:\n\t\t\t\tnext(args)\n\t\t\t\tcontinue\n\t\t\telif arg == '-result':\n\t\t\t\tcmdline += ' %s \"%s\"' % (arg, os.path.abspath(next(args)))\n\t\t\t\tcontinue\n\t\t\telif arg == '-cgskip':\n\t\t\t\tfile = self.configFile(next(args))\n\t\t\t\tcmdline += ' %s \"%s\"' % (arg, os.path.abspath(file))\n\t\t\t\tcontinue\n\t\t\tcmdline += ' '+arg\n\t\tif self.graph_filter != 'do_one_initcall':\n\t\t\tcmdline += ' -func \"%s\"' % self.graph_filter\n\t\tcmdline += ' -o \"%s\"' % os.path.abspath(self.testdir)\n\t\treturn cmdline\n\tdef manualRebootRequired(self):\n\t\tcmdline = self.kernelParams()\n\t\tpprint('To generate a new timeline manually, follow these steps:\\n\\n'\\\n\t\t'1. Add the CMDLINE string to your kernel command line.\\n'\\\n\t\t'2. Reboot the system.\\n'\\\n\t\t'3. After reboot, re-run this tool with the same arguments but no command (w/o -reboot or -manual).\\n\\n'\\\n\t\t'CMDLINE=\"%s\"' % cmdline)\n\t\tsys.exit()\n\tdef blGrub(self):\n\t\tblcmd = ''\n\t\tfor cmd in ['update-grub', 'grub-mkconfig', 'grub2-mkconfig']:\n\t\t\tif blcmd:\n\t\t\t\tbreak\n\t\t\tblcmd = self.getExec(cmd)\n\t\tif not blcmd:\n\t\t\tdoError('[GRUB] missing update command')\n\t\tif not os.path.exists('/etc/default/grub'):\n\t\t\tdoError('[GRUB] missing /etc/default/grub')\n\t\tif 'grub2' in blcmd:\n\t\t\tcfg = '/boot/grub2/grub.cfg'\n\t\telse:\n\t\t\tcfg = '/boot/grub/grub.cfg'\n\t\tif not os.path.exists(cfg):\n\t\t\tdoError('[GRUB] missing %s' % cfg)\n\t\tif 'update-grub' in blcmd:\n\t\t\tself.blexec = [blcmd]\n\t\telse:\n\t\t\tself.blexec = [blcmd, '-o', cfg]\n\tdef getBootLoader(self):\n\t\tif self.bootloader == 'grub':\n\t\t\tself.blGrub()\n\t\telse:\n\t\t\tdoError('unknown boot loader: %s' % self.bootloader)\n\tdef writeDatafileHeader(self, filename):\n\t\tself.kparams = open('/proc/cmdline', 'r').read().strip()\n\t\tfp = open(filename, 'w')\n\t\tfp.write(self.teststamp+'\\n')\n\t\tfp.write(self.sysstamp+'\\n')\n\t\tfp.write('# command | %s\\n' % self.cmdline)\n\t\tfp.write('# kparams | %s\\n' % self.kparams)\n\t\tfp.close()\n\nsysvals = SystemValues()\n\n# Class: Data\n# Description:\n#\t The primary container for test data.\nclass Data(aslib.Data):\n\tdmesg = {}  # root data structure\n\tstart = 0.0 # test start\n\tend = 0.0   # test end\n\tdmesgtext = []   # dmesg text file in memory\n\ttestnumber = 0\n\tidstr = ''\n\thtml_device_id = 0\n\tvalid = False\n\ttUserMode = 0.0\n\tboottime = ''\n\tphases = ['kernel', 'user']\n\tdo_one_initcall = False\n\tdef __init__(self, num):\n\t\tself.testnumber = num\n\t\tself.idstr = 'a'\n\t\tself.dmesgtext = []\n\t\tself.dmesg = {\n\t\t\t'kernel': {'list': dict(), 'start': -1.0, 'end': -1.0, 'row': 0,\n\t\t\t\t'order': 0, 'color': 'linear-gradient(to bottom, #fff, #bcf)'},\n\t\t\t'user': {'list': dict(), 'start': -1.0, 'end': -1.0, 'row': 0,\n\t\t\t\t'order': 1, 'color': '#fff'}\n\t\t}\n\tdef deviceTopology(self):\n\t\treturn ''\n\tdef newAction(self, phase, name, pid, start, end, ret, ulen):\n\t\t# new device callback for a specific phase\n\t\tself.html_device_id += 1\n\t\tdevid = '%s%d' % (self.idstr, self.html_device_id)\n\t\tlist = self.dmesg[phase]['list']\n\t\tlength = -1.0\n\t\tif(start >= 0 and end >= 0):\n\t\t\tlength = end - start\n\t\ti = 2\n\t\torigname = name\n\t\twhile(name in list):\n\t\t\tname = '%s[%d]' % (origname, i)\n\t\t\ti += 1\n\t\tlist[name] = {'name': name, 'start': start, 'end': end,\n\t\t\t'pid': pid, 'length': length, 'row': 0, 'id': devid,\n\t\t\t'ret': ret, 'ulen': ulen }\n\t\treturn name\n\tdef deviceMatch(self, pid, cg):\n\t\tif cg.end - cg.start == 0:\n\t\t\treturn ''\n\t\tfor p in data.phases:\n\t\t\tlist = self.dmesg[p]['list']\n\t\t\tfor devname in list:\n\t\t\t\tdev = list[devname]\n\t\t\t\tif pid != dev['pid']:\n\t\t\t\t\tcontinue\n\t\t\t\tif cg.name == 'do_one_initcall':\n\t\t\t\t\tif(cg.start <= dev['start'] and cg.end >= dev['end'] and dev['length'] > 0):\n\t\t\t\t\t\tdev['ftrace'] = cg\n\t\t\t\t\t\tself.do_one_initcall = True\n\t\t\t\t\t\treturn devname\n\t\t\t\telse:\n\t\t\t\t\tif(cg.start > dev['start'] and cg.end < dev['end']):\n\t\t\t\t\t\tif 'ftraces' not in dev:\n\t\t\t\t\t\t\tdev['ftraces'] = []\n\t\t\t\t\t\tdev['ftraces'].append(cg)\n\t\t\t\t\t\treturn devname\n\t\treturn ''\n\tdef printDetails(self):\n\t\tsysvals.vprint('Timeline Details:')\n\t\tsysvals.vprint('          Host: %s' % sysvals.hostname)\n\t\tsysvals.vprint('        Kernel: %s' % sysvals.kernel)\n\t\tsysvals.vprint('     Test time: %s' % sysvals.testtime)\n\t\tsysvals.vprint('     Boot time: %s' % self.boottime)\n\t\tfor phase in self.phases:\n\t\t\tdc = len(self.dmesg[phase]['list'])\n\t\t\tsysvals.vprint('%9s mode: %.3f - %.3f (%d initcalls)' % (phase,\n\t\t\t\tself.dmesg[phase]['start']*1000,\n\t\t\t\tself.dmesg[phase]['end']*1000, dc))\n\n# ----------------- FUNCTIONS --------------------\n\n# Function: parseKernelLog\n# Description:\n#\t parse a kernel log for boot data\ndef parseKernelLog():\n\tsysvals.vprint('Analyzing the dmesg data (%s)...' % \\\n\t\tos.path.basename(sysvals.dmesgfile))\n\tphase = 'kernel'\n\tdata = Data(0)\n\tdata.dmesg['kernel']['start'] = data.start = ktime = 0.0\n\tsysvals.stamp = {\n\t\t'time': datetime.now().strftime('%B %d %Y, %I:%M:%S %p'),\n\t\t'host': sysvals.hostname,\n\t\t'mode': 'boot', 'kernel': ''}\n\n\ttp = aslib.TestProps()\n\tdevtemp = dict()\n\tif(sysvals.dmesgfile):\n\t\tlf = open(sysvals.dmesgfile, 'rb')\n\telse:\n\t\tlf = Popen('dmesg', stdout=PIPE).stdout\n\tfor line in lf:\n\t\tline = aslib.ascii(line).replace('\\r\\n', '')\n\t\t# grab the stamp and sysinfo\n\t\tif re.match(tp.stampfmt, line):\n\t\t\ttp.stamp = line\n\t\t\tcontinue\n\t\telif re.match(tp.sysinfofmt, line):\n\t\t\ttp.sysinfo = line\n\t\t\tcontinue\n\t\telif re.match(tp.cmdlinefmt, line):\n\t\t\ttp.cmdline = line\n\t\t\tcontinue\n\t\telif re.match(tp.kparamsfmt, line):\n\t\t\ttp.kparams = line\n\t\t\tcontinue\n\t\tidx = line.find('[')\n\t\tif idx > 1:\n\t\t\tline = line[idx:]\n\t\tm = re.match('[ \\t]*(\\[ *)(?P<ktime>[0-9\\.]*)(\\]) (?P<msg>.*)', line)\n\t\tif(not m):\n\t\t\tcontinue\n\t\tktime = float(m.group('ktime'))\n\t\tif(ktime > 120):\n\t\t\tbreak\n\t\tmsg = m.group('msg')\n\t\tdata.dmesgtext.append(line)\n\t\tif(ktime == 0.0 and re.match('^Linux version .*', msg)):\n\t\t\tif(not sysvals.stamp['kernel']):\n\t\t\t\tsysvals.stamp['kernel'] = sysvals.kernelVersion(msg)\n\t\t\tcontinue\n\t\tm = re.match('.* setting system clock to (?P<d>[0-9\\-]*)[ A-Z](?P<t>[0-9:]*) UTC.*', msg)\n\t\tif(m):\n\t\t\tbt = datetime.strptime(m.group('d')+' '+m.group('t'), '%Y-%m-%d %H:%M:%S')\n\t\t\tbt = bt - timedelta(seconds=int(ktime))\n\t\t\tdata.boottime = bt.strftime('%Y-%m-%d_%H:%M:%S')\n\t\t\tsysvals.stamp['time'] = bt.strftime('%B %d %Y, %I:%M:%S %p')\n\t\t\tcontinue\n\t\tm = re.match('^calling *(?P<f>.*)\\+.* @ (?P<p>[0-9]*)', msg)\n\t\tif(m):\n\t\t\tfunc = m.group('f')\n\t\t\tpid = int(m.group('p'))\n\t\t\tdevtemp[func] = (ktime, pid)\n\t\t\tcontinue\n\t\tm = re.match('^initcall *(?P<f>.*)\\+.* returned (?P<r>.*) after (?P<t>.*) usecs', msg)\n\t\tif(m):\n\t\t\tdata.valid = True\n\t\t\tdata.end = ktime\n\t\t\tf, r, t = m.group('f', 'r', 't')\n\t\t\tif(f in devtemp):\n\t\t\t\tstart, pid = devtemp[f]\n\t\t\t\tdata.newAction(phase, f, pid, start, ktime, int(r), int(t))\n\t\t\t\tdel devtemp[f]\n\t\t\tcontinue\n\t\tif(re.match('^Freeing unused kernel .*', msg)):\n\t\t\tdata.tUserMode = ktime\n\t\t\tdata.dmesg['kernel']['end'] = ktime\n\t\t\tdata.dmesg['user']['start'] = ktime\n\t\t\tphase = 'user'\n\n\tif tp.stamp:\n\t\tsysvals.stamp = 0\n\t\ttp.parseStamp(data, sysvals)\n\tdata.dmesg['user']['end'] = data.end\n\tlf.close()\n\treturn data\n\n# Function: parseTraceLog\n# Description:\n#\t Check if trace is available and copy to a temp file\ndef parseTraceLog(data):\n\tsysvals.vprint('Analyzing the ftrace data (%s)...' % \\\n\t\tos.path.basename(sysvals.ftracefile))\n\t# if available, calculate cgfilter allowable ranges\n\tcgfilter = []\n\tif len(sysvals.cgfilter) > 0:\n\t\tfor p in data.phases:\n\t\t\tlist = data.dmesg[p]['list']\n\t\t\tfor i in sysvals.cgfilter:\n\t\t\t\tif i in list:\n\t\t\t\t\tcgfilter.append([list[i]['start']-0.0001,\n\t\t\t\t\t\tlist[i]['end']+0.0001])\n\t# parse the trace log\n\tftemp = dict()\n\ttp = aslib.TestProps()\n\ttp.setTracerType('function_graph')\n\ttf = open(sysvals.ftracefile, 'r')\n\tfor line in tf:\n\t\tif line[0] == '#':\n\t\t\tcontinue\n\t\tm = re.match(tp.ftrace_line_fmt, line.strip())\n\t\tif(not m):\n\t\t\tcontinue\n\t\tm_time, m_proc, m_pid, m_msg, m_dur = \\\n\t\t\tm.group('time', 'proc', 'pid', 'msg', 'dur')\n\t\tt = float(m_time)\n\t\tif len(cgfilter) > 0:\n\t\t\tallow = False\n\t\t\tfor r in cgfilter:\n\t\t\t\tif t >= r[0] and t < r[1]:\n\t\t\t\t\tallow = True\n\t\t\t\t\tbreak\n\t\t\tif not allow:\n\t\t\t\tcontinue\n\t\tif t > data.end:\n\t\t\tbreak\n\t\tif(m_time and m_pid and m_msg):\n\t\t\tt = aslib.FTraceLine(m_time, m_msg, m_dur)\n\t\t\tpid = int(m_pid)\n\t\telse:\n\t\t\tcontinue\n\t\tif t.fevent or t.fkprobe:\n\t\t\tcontinue\n\t\tkey = (m_proc, pid)\n\t\tif(key not in ftemp):\n\t\t\tftemp[key] = []\n\t\t\tftemp[key].append(aslib.FTraceCallGraph(pid, sysvals))\n\t\tcg = ftemp[key][-1]\n\t\tres = cg.addLine(t)\n\t\tif(res != 0):\n\t\t\tftemp[key].append(aslib.FTraceCallGraph(pid, sysvals))\n\t\tif(res == -1):\n\t\t\tftemp[key][-1].addLine(t)\n\n\ttf.close()\n\n\t# add the callgraph data to the device hierarchy\n\tfor key in ftemp:\n\t\tproc, pid = key\n\t\tfor cg in ftemp[key]:\n\t\t\tif len(cg.list) < 1 or cg.invalid or (cg.end - cg.start == 0):\n\t\t\t\tcontinue\n\t\t\tif(not cg.postProcess()):\n\t\t\t\tpprint('Sanity check failed for %s-%d' % (proc, pid))\n\t\t\t\tcontinue\n\t\t\t# match cg data to devices\n\t\t\tdevname = data.deviceMatch(pid, cg)\n\t\t\tif not devname:\n\t\t\t\tkind = 'Orphan'\n\t\t\t\tif cg.partial:\n\t\t\t\t\tkind = 'Partial'\n\t\t\t\tsysvals.vprint('%s callgraph found for %s %s-%d [%f - %f]' %\\\n\t\t\t\t\t(kind, cg.name, proc, pid, cg.start, cg.end))\n\t\t\telif len(cg.list) > 1000000:\n\t\t\t\tpprint('WARNING: the callgraph found for %s is massive! (%d lines)' %\\\n\t\t\t\t\t(devname, len(cg.list)))\n\n# Function: retrieveLogs\n# Description:\n#\t Create copies of dmesg and/or ftrace for later processing\ndef retrieveLogs():\n\t# check ftrace is configured first\n\tif sysvals.useftrace:\n\t\ttracer = sysvals.fgetVal('current_tracer').strip()\n\t\tif tracer != 'function_graph':\n\t\t\tdoError('ftrace not configured for a boot callgraph')\n\t# create the folder and get dmesg\n\tsysvals.systemInfo(aslib.dmidecode(sysvals.mempath))\n\tsysvals.initTestOutput('boot')\n\tsysvals.writeDatafileHeader(sysvals.dmesgfile)\n\tcall('dmesg >> '+sysvals.dmesgfile, shell=True)\n\tif not sysvals.useftrace:\n\t\treturn\n\t# get ftrace\n\tsysvals.writeDatafileHeader(sysvals.ftracefile)\n\tcall('cat '+sysvals.tpath+'trace >> '+sysvals.ftracefile, shell=True)\n\n# Function: colorForName\n# Description:\n#\t Generate a repeatable color from a list for a given name\ndef colorForName(name):\n\tlist = [\n\t\t('c1', '#ec9999'),\n\t\t('c2', '#ffc1a6'),\n\t\t('c3', '#fff0a6'),\n\t\t('c4', '#adf199'),\n\t\t('c5', '#9fadea'),\n\t\t('c6', '#a699c1'),\n\t\t('c7', '#ad99b4'),\n\t\t('c8', '#eaffea'),\n\t\t('c9', '#dcecfb'),\n\t\t('c10', '#ffffea')\n\t]\n\ti = 0\n\ttotal = 0\n\tcount = len(list)\n\twhile i < len(name):\n\t\ttotal += ord(name[i])\n\t\ti += 1\n\treturn list[total % count]\n\ndef cgOverview(cg, minlen):\n\tstats = dict()\n\tlarge = []\n\tfor l in cg.list:\n\t\tif l.fcall and l.depth == 1:\n\t\t\tif l.length >= minlen:\n\t\t\t\tlarge.append(l)\n\t\t\tif l.name not in stats:\n\t\t\t\tstats[l.name] = [0, 0.0]\n\t\t\tstats[l.name][0] += (l.length * 1000.0)\n\t\t\tstats[l.name][1] += 1\n\treturn (large, stats)\n\n# Function: createBootGraph\n# Description:\n#\t Create the output html file from the resident test data\n# Arguments:\n#\t testruns: array of Data objects from parseKernelLog or parseTraceLog\n# Output:\n#\t True if the html file was created, false if it failed\ndef createBootGraph(data):\n\t# html function templates\n\thtml_srccall = '<div id={6} title=\"{5}\" class=\"srccall\" style=\"left:{1}%;top:{2}px;height:{3}px;width:{4}%;line-height:{3}px;\">{0}</div>\\n'\n\thtml_timetotal = '<table class=\"time1\">\\n<tr>'\\\n\t\t'<td class=\"blue\">Init process starts @ <b>{0} ms</b></td>'\\\n\t\t'<td class=\"blue\">Last initcall ends @ <b>{1} ms</b></td>'\\\n\t\t'</tr>\\n</table>\\n'\n\n\t# device timeline\n\tdevtl = aslib.Timeline(100, 20)\n\n\t# write the test title and general info header\n\tdevtl.createHeader(sysvals, sysvals.stamp)\n\n\t# Generate the header for this timeline\n\tt0 = data.start\n\ttMax = data.end\n\ttTotal = tMax - t0\n\tif(tTotal == 0):\n\t\tpprint('ERROR: No timeline data')\n\t\treturn False\n\tuser_mode = '%.0f'%(data.tUserMode*1000)\n\tlast_init = '%.0f'%(tTotal*1000)\n\tdevtl.html += html_timetotal.format(user_mode, last_init)\n\n\t# determine the maximum number of rows we need to draw\n\tdevlist = []\n\tfor p in data.phases:\n\t\tlist = data.dmesg[p]['list']\n\t\tfor devname in list:\n\t\t\td = aslib.DevItem(0, p, list[devname])\n\t\t\tdevlist.append(d)\n\t\tdevtl.getPhaseRows(devlist, 0, 'start')\n\tdevtl.calcTotalRows()\n\n\t# draw the timeline background\n\tdevtl.createZoomBox()\n\tdevtl.html += devtl.html_tblock.format('boot', '0', '100', devtl.scaleH)\n\tfor p in data.phases:\n\t\tphase = data.dmesg[p]\n\t\tlength = phase['end']-phase['start']\n\t\tleft = '%.3f' % (((phase['start']-t0)*100.0)/tTotal)\n\t\twidth = '%.3f' % ((length*100.0)/tTotal)\n\t\tdevtl.html += devtl.html_phase.format(left, width, \\\n\t\t\t'%.3f'%devtl.scaleH, '%.3f'%devtl.bodyH, \\\n\t\t\tphase['color'], '')\n\n\t# draw the device timeline\n\tnum = 0\n\tdevstats = dict()\n\tfor phase in data.phases:\n\t\tlist = data.dmesg[phase]['list']\n\t\tfor devname in sorted(list):\n\t\t\tcls, color = colorForName(devname)\n\t\t\tdev = list[devname]\n\t\t\tinfo = '@|%.3f|%.3f|%.3f|%d' % (dev['start']*1000.0, dev['end']*1000.0,\n\t\t\t\tdev['ulen']/1000.0, dev['ret'])\n\t\t\tdevstats[dev['id']] = {'info':info}\n\t\t\tdev['color'] = color\n\t\t\theight = devtl.phaseRowHeight(0, phase, dev['row'])\n\t\t\ttop = '%.6f' % ((dev['row']*height) + devtl.scaleH)\n\t\t\tleft = '%.6f' % (((dev['start']-t0)*100)/tTotal)\n\t\t\twidth = '%.6f' % (((dev['end']-dev['start'])*100)/tTotal)\n\t\t\tlength = ' (%0.3f ms) ' % ((dev['end']-dev['start'])*1000)\n\t\t\tdevtl.html += devtl.html_device.format(dev['id'],\n\t\t\t\tdevname+length+phase+'_mode', left, top, '%.3f'%height,\n\t\t\t\twidth, devname, ' '+cls, '')\n\t\t\trowtop = devtl.phaseRowTop(0, phase, dev['row'])\n\t\t\theight = '%.6f' % (devtl.rowH / 2)\n\t\t\ttop = '%.6f' % (rowtop + devtl.scaleH + (devtl.rowH / 2))\n\t\t\tif data.do_one_initcall:\n\t\t\t\tif('ftrace' not in dev):\n\t\t\t\t\tcontinue\n\t\t\t\tcg = dev['ftrace']\n\t\t\t\tlarge, stats = cgOverview(cg, 0.001)\n\t\t\t\tdevstats[dev['id']]['fstat'] = stats\n\t\t\t\tfor l in large:\n\t\t\t\t\tleft = '%f' % (((l.time-t0)*100)/tTotal)\n\t\t\t\t\twidth = '%f' % (l.length*100/tTotal)\n\t\t\t\t\ttitle = '%s (%0.3fms)' % (l.name, l.length * 1000.0)\n\t\t\t\t\tdevtl.html += html_srccall.format(l.name, left,\n\t\t\t\t\t\ttop, height, width, title, 'x%d'%num)\n\t\t\t\t\tnum += 1\n\t\t\t\tcontinue\n\t\t\tif('ftraces' not in dev):\n\t\t\t\tcontinue\n\t\t\tfor cg in dev['ftraces']:\n\t\t\t\tleft = '%f' % (((cg.start-t0)*100)/tTotal)\n\t\t\t\twidth = '%f' % ((cg.end-cg.start)*100/tTotal)\n\t\t\t\tcglen = (cg.end - cg.start) * 1000.0\n\t\t\t\ttitle = '%s (%0.3fms)' % (cg.name, cglen)\n\t\t\t\tcg.id = 'x%d' % num\n\t\t\t\tdevtl.html += html_srccall.format(cg.name, left,\n\t\t\t\t\ttop, height, width, title, dev['id']+cg.id)\n\t\t\t\tnum += 1\n\n\t# draw the time scale, try to make the number of labels readable\n\tdevtl.createTimeScale(t0, tMax, tTotal, 'boot')\n\tdevtl.html += '</div>\\n'\n\n\t# timeline is finished\n\tdevtl.html += '</div>\\n</div>\\n'\n\n\t# draw a legend which describes the phases by color\n\tdevtl.html += '<div class=\"legend\">\\n'\n\tpdelta = 20.0\n\tpmargin = 36.0\n\tfor phase in data.phases:\n\t\torder = '%.2f' % ((data.dmesg[phase]['order'] * pdelta) + pmargin)\n\t\tdevtl.html += devtl.html_legend.format(order, \\\n\t\t\tdata.dmesg[phase]['color'], phase+'_mode', phase[0])\n\tdevtl.html += '</div>\\n'\n\n\thf = open(sysvals.htmlfile, 'w')\n\n\t# add the css\n\textra = '\\\n\t\t.c1 {background:rgba(209,0,0,0.4);}\\n\\\n\t\t.c2 {background:rgba(255,102,34,0.4);}\\n\\\n\t\t.c3 {background:rgba(255,218,33,0.4);}\\n\\\n\t\t.c4 {background:rgba(51,221,0,0.4);}\\n\\\n\t\t.c5 {background:rgba(17,51,204,0.4);}\\n\\\n\t\t.c6 {background:rgba(34,0,102,0.4);}\\n\\\n\t\t.c7 {background:rgba(51,0,68,0.4);}\\n\\\n\t\t.c8 {background:rgba(204,255,204,0.4);}\\n\\\n\t\t.c9 {background:rgba(169,208,245,0.4);}\\n\\\n\t\t.c10 {background:rgba(255,255,204,0.4);}\\n\\\n\t\t.vt {transform:rotate(-60deg);transform-origin:0 0;}\\n\\\n\t\ttable.fstat {table-layout:fixed;padding:150px 15px 0 0;font-size:10px;column-width:30px;}\\n\\\n\t\t.fstat th {width:55px;}\\n\\\n\t\t.fstat td {text-align:left;width:35px;}\\n\\\n\t\t.srccall {position:absolute;font-size:10px;z-index:7;overflow:hidden;color:black;text-align:center;white-space:nowrap;border-radius:5px;border:1px solid black;background:linear-gradient(to bottom right,#CCC,#969696);}\\n\\\n\t\t.srccall:hover {color:white;font-weight:bold;border:1px solid white;}\\n'\n\taslib.addCSS(hf, sysvals, 1, False, extra)\n\n\t# write the device timeline\n\thf.write(devtl.html)\n\n\t# add boot specific html\n\tstatinfo = 'var devstats = {\\n'\n\tfor n in sorted(devstats):\n\t\tstatinfo += '\\t\"%s\": [\\n\\t\\t\"%s\",\\n' % (n, devstats[n]['info'])\n\t\tif 'fstat' in devstats[n]:\n\t\t\tfuncs = devstats[n]['fstat']\n\t\t\tfor f in sorted(funcs, key=lambda k:(funcs[k], k), reverse=True):\n\t\t\t\tif funcs[f][0] < 0.01 and len(funcs) > 10:\n\t\t\t\t\tbreak\n\t\t\t\tstatinfo += '\\t\\t\"%f|%s|%d\",\\n' % (funcs[f][0], f, funcs[f][1])\n\t\tstatinfo += '\\t],\\n'\n\tstatinfo += '};\\n'\n\thtml = \\\n\t\t'<div id=\"devicedetailtitle\"></div>\\n'\\\n\t\t'<div id=\"devicedetail\" style=\"display:none;\">\\n'\\\n\t\t'<div id=\"devicedetail0\">\\n'\n\tfor p in data.phases:\n\t\tphase = data.dmesg[p]\n\t\thtml += devtl.html_phaselet.format(p+'_mode', '0', '100', phase['color'])\n\thtml += '</div>\\n</div>\\n'\\\n\t\t'<script type=\"text/javascript\">\\n'+statinfo+\\\n\t\t'</script>\\n'\n\thf.write(html)\n\n\t# add the callgraph html\n\tif(sysvals.usecallgraph):\n\t\taslib.addCallgraphs(sysvals, hf, data)\n\n\t# add the test log as a hidden div\n\tif sysvals.testlog and sysvals.logmsg:\n\t\thf.write('<div id=\"testlog\" style=\"display:none;\">\\n'+sysvals.logmsg+'</div>\\n')\n\t# add the dmesg log as a hidden div\n\tif sysvals.dmesglog:\n\t\thf.write('<div id=\"dmesglog\" style=\"display:none;\">\\n')\n\t\tfor line in data.dmesgtext:\n\t\t\tline = line.replace('<', '&lt').replace('>', '&gt')\n\t\t\thf.write(line)\n\t\thf.write('</div>\\n')\n\n\t# write the footer and close\n\taslib.addScriptCode(hf, [data])\n\thf.write('</body>\\n</html>\\n')\n\thf.close()\n\treturn True\n\n# Function: updateCron\n# Description:\n#    (restore=False) Set the tool to run automatically on reboot\n#    (restore=True) Restore the original crontab\ndef updateCron(restore=False):\n\tif not restore:\n\t\tsysvals.rootUser(True)\n\tcrondir = '/var/spool/cron/crontabs/'\n\tif not os.path.exists(crondir):\n\t\tcrondir = '/var/spool/cron/'\n\tif not os.path.exists(crondir):\n\t\tdoError('%s not found' % crondir)\n\tcronfile = crondir+'root'\n\tbackfile = crondir+'root-analyze_boot-backup'\n\tcmd = sysvals.getExec('crontab')\n\tif not cmd:\n\t\tdoError('crontab not found')\n\t# on restore: move the backup cron back into place\n\tif restore:\n\t\tif os.path.exists(backfile):\n\t\t\tshutil.move(backfile, cronfile)\n\t\t\tcall([cmd, cronfile])\n\t\treturn\n\t# backup current cron and install new one with reboot\n\tif os.path.exists(cronfile):\n\t\tshutil.move(cronfile, backfile)\n\telse:\n\t\tfp = open(backfile, 'w')\n\t\tfp.close()\n\tres = -1\n\ttry:\n\t\tfp = open(backfile, 'r')\n\t\top = open(cronfile, 'w')\n\t\tfor line in fp:\n\t\t\tif not sysvals.myCronJob(line):\n\t\t\t\top.write(line)\n\t\t\t\tcontinue\n\t\tfp.close()\n\t\top.write('@reboot python %s\\n' % sysvals.cronjobCmdString())\n\t\top.close()\n\t\tres = call([cmd, cronfile])\n\texcept Exception as e:\n\t\tpprint('Exception: %s' % str(e))\n\t\tshutil.move(backfile, cronfile)\n\t\tres = -1\n\tif res != 0:\n\t\tdoError('crontab failed')\n\n# Function: updateGrub\n# Description:\n#\t update grub.cfg for all kernels with our parameters\ndef updateGrub(restore=False):\n\t# call update-grub on restore\n\tif restore:\n\t\ttry:\n\t\t\tcall(sysvals.blexec, stderr=PIPE, stdout=PIPE,\n\t\t\t\tenv={'PATH': '.:/sbin:/usr/sbin:/usr/bin:/sbin:/bin'})\n\t\texcept Exception as e:\n\t\t\tpprint('Exception: %s\\n' % str(e))\n\t\treturn\n\t# extract the option and create a grub config without it\n\tsysvals.rootUser(True)\n\ttgtopt = 'GRUB_CMDLINE_LINUX_DEFAULT'\n\tcmdline = ''\n\tgrubfile = '/etc/default/grub'\n\ttempfile = '/etc/default/grub.analyze_boot'\n\tshutil.move(grubfile, tempfile)\n\tres = -1\n\ttry:\n\t\tfp = open(tempfile, 'r')\n\t\top = open(grubfile, 'w')\n\t\tcont = False\n\t\tfor line in fp:\n\t\t\tline = line.strip()\n\t\t\tif len(line) == 0 or line[0] == '#':\n\t\t\t\tcontinue\n\t\t\topt = line.split('=')[0].strip()\n\t\t\tif opt == tgtopt:\n\t\t\t\tcmdline = line.split('=', 1)[1].strip('\\\\')\n\t\t\t\tif line[-1] == '\\\\':\n\t\t\t\t\tcont = True\n\t\t\telif cont:\n\t\t\t\tcmdline += line.strip('\\\\')\n\t\t\t\tif line[-1] != '\\\\':\n\t\t\t\t\tcont = False\n\t\t\telse:\n\t\t\t\top.write('%s\\n' % line)\n\t\tfp.close()\n\t\t# if the target option value is in quotes, strip them\n\t\tsp = '\"'\n\t\tval = cmdline.strip()\n\t\tif val and (val[0] == '\\'' or val[0] == '\"'):\n\t\t\tsp = val[0]\n\t\t\tval = val.strip(sp)\n\t\tcmdline = val\n\t\t# append our cmd line options\n\t\tif len(cmdline) > 0:\n\t\t\tcmdline += ' '\n\t\tcmdline += sysvals.kernelParams()\n\t\t# write out the updated target option\n\t\top.write('\\n%s=%s%s%s\\n' % (tgtopt, sp, cmdline, sp))\n\t\top.close()\n\t\tres = call(sysvals.blexec)\n\t\tos.remove(grubfile)\n\texcept Exception as e:\n\t\tpprint('Exception: %s' % str(e))\n\t\tres = -1\n\t# cleanup\n\tshutil.move(tempfile, grubfile)\n\tif res != 0:\n\t\tdoError('update grub failed')\n\n# Function: updateKernelParams\n# Description:\n#\t update boot conf for all kernels with our parameters\ndef updateKernelParams(restore=False):\n\t# find the boot loader\n\tsysvals.getBootLoader()\n\tif sysvals.bootloader == 'grub':\n\t\tupdateGrub(restore)\n\n# Function: doError Description:\n#\t generic error function for catastrphic failures\n# Arguments:\n#\t msg: the error message to print\n#\t help: True if printHelp should be called after, False otherwise\ndef doError(msg, help=False):\n\tif help == True:\n\t\tprintHelp()\n\tpprint('ERROR: %s\\n' % msg)\n\tsysvals.outputResult({'error':msg})\n\tsys.exit()\n\n# Function: printHelp\n# Description:\n#\t print out the help text\ndef printHelp():\n\tpprint('\\n%s v%s\\n'\\\n\t'Usage: bootgraph <options> <command>\\n'\\\n\t'\\n'\\\n\t'Description:\\n'\\\n\t'  This tool reads in a dmesg log of linux kernel boot and\\n'\\\n\t'  creates an html representation of the boot timeline up to\\n'\\\n\t'  the start of the init process.\\n'\\\n\t'\\n'\\\n\t'  If no specific command is given the tool reads the current dmesg\\n'\\\n\t'  and/or ftrace log and creates a timeline\\n'\\\n\t'\\n'\\\n\t'  Generates output files in subdirectory: boot-yymmdd-HHMMSS\\n'\\\n\t'   HTML output:                    <hostname>_boot.html\\n'\\\n\t'   raw dmesg output:               <hostname>_boot_dmesg.txt\\n'\\\n\t'   raw ftrace output:              <hostname>_boot_ftrace.txt\\n'\\\n\t'\\n'\\\n\t'Options:\\n'\\\n\t'  -h            Print this help text\\n'\\\n\t'  -v            Print the current tool version\\n'\\\n\t'  -verbose      Print extra information during execution and analysis\\n'\\\n\t'  -addlogs      Add the dmesg log to the html output\\n'\\\n\t'  -result fn    Export a results table to a text file for parsing.\\n'\\\n\t'  -o name       Overrides the output subdirectory name when running a new test\\n'\\\n\t'                default: boot-{date}-{time}\\n'\\\n\t' [advanced]\\n'\\\n\t'  -fstat        Use ftrace to add function detail and statistics (default: disabled)\\n'\\\n\t'  -f/-callgraph Add callgraph detail, can be very large (default: disabled)\\n'\\\n\t'  -maxdepth N   limit the callgraph data to N call levels (default: 2)\\n'\\\n\t'  -mincg ms     Discard all callgraphs shorter than ms milliseconds (e.g. 0.001 for us)\\n'\\\n\t'  -timeprec N   Number of significant digits in timestamps (0:S, 3:ms, [6:us])\\n'\\\n\t'  -expandcg     pre-expand the callgraph data in the html output (default: disabled)\\n'\\\n\t'  -func list    Limit ftrace to comma-delimited list of functions (default: do_one_initcall)\\n'\\\n\t'  -cgfilter S   Filter the callgraph output in the timeline\\n'\\\n\t'  -cgskip file  Callgraph functions to skip, off to disable (default: cgskip.txt)\\n'\\\n\t'  -bl name      Use the following boot loader for kernel params (default: grub)\\n'\\\n\t'  -reboot       Reboot the machine automatically and generate a new timeline\\n'\\\n\t'  -manual       Show the steps to generate a new timeline manually (used with -reboot)\\n'\\\n\t'\\n'\\\n\t'Other commands:\\n'\\\n\t'  -flistall     Print all functions capable of being captured in ftrace\\n'\\\n\t'  -sysinfo      Print out system info extracted from BIOS\\n'\\\n\t'  -which exec   Print an executable path, should function even without PATH\\n'\\\n\t' [redo]\\n'\\\n\t'  -dmesg file   Create HTML output using dmesg input (used with -ftrace)\\n'\\\n\t'  -ftrace file  Create HTML output using ftrace input (used with -dmesg)\\n'\\\n\t'' % (sysvals.title, sysvals.version))\n\treturn True\n\n# ----------------- MAIN --------------------\n# exec start (skipped if script is loaded as library)\nif __name__ == '__main__':\n\t# loop through the command line arguments\n\tcmd = ''\n\ttestrun = True\n\tswitchoff = ['disable', 'off', 'false', '0']\n\tsimplecmds = ['-sysinfo', '-kpupdate', '-flistall', '-checkbl']\n\tcgskip = ''\n\tif '-f' in sys.argv:\n\t\tcgskip = sysvals.configFile('cgskip.txt')\n\targs = iter(sys.argv[1:])\n\tmdset = False\n\tfor arg in args:\n\t\tif(arg == '-h'):\n\t\t\tprintHelp()\n\t\t\tsys.exit()\n\t\telif(arg == '-v'):\n\t\t\tpprint(\"Version %s\" % sysvals.version)\n\t\t\tsys.exit()\n\t\telif(arg == '-verbose'):\n\t\t\tsysvals.verbose = True\n\t\telif(arg in simplecmds):\n\t\t\tcmd = arg[1:]\n\t\telif(arg == '-fstat'):\n\t\t\tsysvals.useftrace = True\n\t\telif(arg == '-callgraph' or arg == '-f'):\n\t\t\tsysvals.useftrace = True\n\t\t\tsysvals.usecallgraph = True\n\t\telif(arg == '-cgdump'):\n\t\t\tsysvals.cgdump = True\n\t\telif(arg == '-mincg'):\n\t\t\tsysvals.mincglen = aslib.getArgFloat('-mincg', args, 0.0, 10000.0)\n\t\telif(arg == '-cgfilter'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No callgraph functions supplied', True)\n\t\t\tsysvals.setCallgraphFilter(val)\n\t\telif(arg == '-cgskip'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No file supplied', True)\n\t\t\tif val.lower() in switchoff:\n\t\t\t\tcgskip = ''\n\t\t\telse:\n\t\t\t\tcgskip = sysvals.configFile(val)\n\t\t\t\tif(not cgskip):\n\t\t\t\t\tdoError('%s does not exist' % cgskip)\n\t\telif(arg == '-bl'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No boot loader name supplied', True)\n\t\t\tif val.lower() not in ['grub']:\n\t\t\t\tdoError('Unknown boot loader: %s' % val, True)\n\t\t\tsysvals.bootloader = val.lower()\n\t\telif(arg == '-timeprec'):\n\t\t\tsysvals.setPrecision(aslib.getArgInt('-timeprec', args, 0, 6))\n\t\telif(arg == '-maxdepth'):\n\t\t\tmdset = True\n\t\t\tsysvals.max_graph_depth = aslib.getArgInt('-maxdepth', args, 0, 1000)\n\t\telif(arg == '-func'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No filter functions supplied', True)\n\t\t\tsysvals.useftrace = True\n\t\t\tsysvals.usecallgraph = True\n\t\t\tsysvals.rootCheck(True)\n\t\t\tsysvals.setGraphFilter(val)\n\t\telif(arg == '-ftrace'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No ftrace file supplied', True)\n\t\t\tif(os.path.exists(val) == False):\n\t\t\t\tdoError('%s does not exist' % val)\n\t\t\ttestrun = False\n\t\t\tsysvals.ftracefile = val\n\t\telif(arg == '-addlogs'):\n\t\t\tsysvals.dmesglog = True\n\t\telif(arg == '-expandcg'):\n\t\t\tsysvals.cgexp = True\n\t\telif(arg == '-dmesg'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No dmesg file supplied', True)\n\t\t\tif(os.path.exists(val) == False):\n\t\t\t\tdoError('%s does not exist' % val)\n\t\t\ttestrun = False\n\t\t\tsysvals.dmesgfile = val\n\t\telif(arg == '-o'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No subdirectory name supplied', True)\n\t\t\tsysvals.testdir = sysvals.setOutputFolder(val)\n\t\telif(arg == '-result'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No result file supplied', True)\n\t\t\tsysvals.result = val\n\t\telif(arg == '-reboot'):\n\t\t\tsysvals.reboot = True\n\t\telif(arg == '-manual'):\n\t\t\tsysvals.reboot = True\n\t\t\tsysvals.manual = True\n\t\t# remaining options are only for cron job use\n\t\telif(arg == '-cronjob'):\n\t\t\tsysvals.iscronjob = True\n\t\telif(arg == '-which'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No executable supplied', True)\n\t\t\tout = sysvals.getExec(val)\n\t\t\tif not out:\n\t\t\t\tprint('%s not found' % val)\n\t\t\t\tsys.exit(1)\n\t\t\tprint(out)\n\t\t\tsys.exit(0)\n\t\telse:\n\t\t\tdoError('Invalid argument: '+arg, True)\n\n\t# compatibility errors and access checks\n\tif(sysvals.iscronjob and (sysvals.reboot or \\\n\t\tsysvals.dmesgfile or sysvals.ftracefile or cmd)):\n\t\tdoError('-cronjob is meant for batch purposes only')\n\tif(sysvals.reboot and (sysvals.dmesgfile or sysvals.ftracefile)):\n\t\tdoError('-reboot and -dmesg/-ftrace are incompatible')\n\tif cmd or sysvals.reboot or sysvals.iscronjob or testrun:\n\t\tsysvals.rootCheck(True)\n\tif (testrun and sysvals.useftrace) or cmd == 'flistall':\n\t\tif not sysvals.verifyFtrace():\n\t\t\tdoError('Ftrace is not properly enabled')\n\n\t# run utility commands\n\tsysvals.cpuInfo()\n\tif cmd != '':\n\t\tif cmd == 'kpupdate':\n\t\t\tupdateKernelParams()\n\t\telif cmd == 'flistall':\n\t\t\tfor f in sysvals.getBootFtraceFilterFunctions():\n\t\t\t\tprint(f)\n\t\telif cmd == 'checkbl':\n\t\t\tsysvals.getBootLoader()\n\t\t\tpprint('Boot Loader: %s\\n%s' % (sysvals.bootloader, sysvals.blexec))\n\t\telif(cmd == 'sysinfo'):\n\t\t\tsysvals.printSystemInfo(True)\n\t\tsys.exit()\n\n\t# reboot: update grub, setup a cronjob, and reboot\n\tif sysvals.reboot:\n\t\tif (sysvals.useftrace or sysvals.usecallgraph) and \\\n\t\t\tnot sysvals.checkFtraceKernelVersion():\n\t\t\tdoError('Ftrace functionality requires kernel v4.10 or newer')\n\t\tif not sysvals.manual:\n\t\t\tupdateKernelParams()\n\t\t\tupdateCron()\n\t\t\tcall('reboot')\n\t\telse:\n\t\t\tsysvals.manualRebootRequired()\n\t\tsys.exit()\n\n\tif sysvals.usecallgraph and cgskip:\n\t\tsysvals.vprint('Using cgskip file: %s' % cgskip)\n\t\tsysvals.setCallgraphBlacklist(cgskip)\n\n\t# cronjob: remove the cronjob, grub changes, and disable ftrace\n\tif sysvals.iscronjob:\n\t\tupdateCron(True)\n\t\tupdateKernelParams(True)\n\t\ttry:\n\t\t\tsysvals.fsetVal('0', 'tracing_on')\n\t\texcept:\n\t\t\tpass\n\n\t# testrun: generate copies of the logs\n\tif testrun:\n\t\tretrieveLogs()\n\telse:\n\t\tsysvals.setOutputFile()\n\n\t# process the log data\n\tif sysvals.dmesgfile:\n\t\tif not mdset:\n\t\t\tsysvals.max_graph_depth = 0\n\t\tdata = parseKernelLog()\n\t\tif(not data.valid):\n\t\t\tdoError('No initcall data found in %s' % sysvals.dmesgfile)\n\t\tif sysvals.useftrace and sysvals.ftracefile:\n\t\t\tparseTraceLog(data)\n\t\tif sysvals.cgdump:\n\t\t\tdata.debugPrint()\n\t\t\tsys.exit()\n\telse:\n\t\tdoError('dmesg file required')\n\n\tsysvals.vprint('Creating the html timeline (%s)...' % sysvals.htmlfile)\n\tsysvals.vprint('Command:\\n    %s' % sysvals.cmdline)\n\tsysvals.vprint('Kernel parameters:\\n    %s' % sysvals.kparams)\n\tdata.printDetails()\n\tcreateBootGraph(data)\n\n\t# if running as root, change output dir owner to sudo_user\n\tif testrun and os.path.isdir(sysvals.testdir) and \\\n\t\tos.getuid() == 0 and 'SUDO_USER' in os.environ:\n\t\tcmd = 'chown -R {0}:{0} {1} > /dev/null 2>&1'\n\t\tcall(cmd.format(os.environ['SUDO_USER'], sysvals.testdir), shell=True)\n\n\tsysvals.stamp['boot'] = (data.tUserMode - data.start) * 1000\n\tsysvals.stamp['lastinit'] = data.end * 1000\n\tsysvals.outputResult(sysvals.stamp)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}