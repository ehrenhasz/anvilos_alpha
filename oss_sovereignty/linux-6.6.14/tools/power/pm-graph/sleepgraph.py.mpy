{
  "module_name": "sleepgraph.py",
  "hash_id": "4ca7d1104832640ee50e6f73b12eb0cf5d77d5e1bf5a79c19f65df61c501d22f",
  "original_prompt": "Ingested from linux-6.6.14/tools/power/pm-graph/sleepgraph.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0-only\n#\n# Tool for analyzing suspend/resume timing\n# Copyright (c) 2013, Intel Corporation.\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms and conditions of the GNU General Public License,\n# version 2, as published by the Free Software Foundation.\n#\n# This program is distributed in the hope it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n# more details.\n#\n# Authors:\n#\t Todd Brandt <todd.e.brandt@linux.intel.com>\n#\n# Links:\n#\t Home Page\n#\t   https://01.org/pm-graph\n#\t Source repo\n#\t   git@github.com:intel/pm-graph\n#\n# Description:\n#\t This tool is designed to assist kernel and OS developers in optimizing\n#\t their linux stack's suspend/resume time. Using a kernel image built\n#\t with a few extra options enabled, the tool will execute a suspend and\n#\t will capture dmesg and ftrace data until resume is complete. This data\n#\t is transformed into a device timeline and a callgraph to give a quick\n#\t and detailed view of which devices and callbacks are taking the most\n#\t time in suspend/resume. The output is a single html file which can be\n#\t viewed in firefox or chrome.\n#\n#\t The following kernel build options are required:\n#\t\t CONFIG_DEVMEM=y\n#\t\t CONFIG_PM_DEBUG=y\n#\t\t CONFIG_PM_SLEEP_DEBUG=y\n#\t\t CONFIG_FTRACE=y\n#\t\t CONFIG_FUNCTION_TRACER=y\n#\t\t CONFIG_FUNCTION_GRAPH_TRACER=y\n#\t\t CONFIG_KPROBES=y\n#\t\t CONFIG_KPROBES_ON_FTRACE=y\n#\n#\t For kernel versions older than 3.15:\n#\t The following additional kernel parameters are required:\n#\t\t (e.g. in file /etc/default/grub)\n#\t\t GRUB_CMDLINE_LINUX_DEFAULT=\"... initcall_debug log_buf_len=16M ...\"\n#\n\n# ----------------- LIBRARIES --------------------\n\nimport sys\nimport time\nimport os\nimport string\nimport re\nimport platform\nimport signal\nimport codecs\nfrom datetime import datetime, timedelta\nimport struct\nimport configparser\nimport gzip\nfrom threading import Thread\nfrom subprocess import call, Popen, PIPE\nimport base64\n\ndebugtiming = False\nmystarttime = time.time()\ndef pprint(msg):\n\tif debugtiming:\n\t\tprint('[%09.3f] %s' % (time.time()-mystarttime, msg))\n\telse:\n\t\tprint(msg)\n\tsys.stdout.flush()\n\ndef ascii(text):\n\treturn text.decode('ascii', 'ignore')\n\n# ----------------- CLASSES --------------------\n\n# Class: SystemValues\n# Description:\n#\t A global, single-instance container used to\n#\t store system values and test parameters\nclass SystemValues:\n\ttitle = 'SleepGraph'\n\tversion = '5.11'\n\tansi = False\n\trs = 0\n\tdisplay = ''\n\tgzip = False\n\tsync = False\n\twifi = False\n\tnetfix = False\n\tverbose = False\n\ttestlog = True\n\tdmesglog = True\n\tftracelog = False\n\tacpidebug = True\n\ttstat = True\n\twifitrace = False\n\tmindevlen = 0.0001\n\tmincglen = 0.0\n\tcgphase = ''\n\tcgtest = -1\n\tcgskip = ''\n\tmaxfail = 0\n\tmultitest = {'run': False, 'count': 1000000, 'delay': 0}\n\tmax_graph_depth = 0\n\tcallloopmaxgap = 0.0001\n\tcallloopmaxlen = 0.005\n\tbufsize = 0\n\tcpucount = 0\n\tmemtotal = 204800\n\tmemfree = 204800\n\tosversion = ''\n\tsrgap = 0\n\tcgexp = False\n\ttestdir = ''\n\toutdir = ''\n\ttpath = '/sys/kernel/tracing/'\n\tfpdtpath = '/sys/firmware/acpi/tables/FPDT'\n\tepath = '/sys/kernel/tracing/events/power/'\n\tpmdpath = '/sys/power/pm_debug_messages'\n\ts0ixpath = '/sys/module/intel_pmc_core/parameters/warn_on_s0ix_failures'\n\ts0ixres = '/sys/devices/system/cpu/cpuidle/low_power_idle_system_residency_us'\n\tacpipath='/sys/module/acpi/parameters/debug_level'\n\ttraceevents = [\n\t\t'suspend_resume',\n\t\t'wakeup_source_activate',\n\t\t'wakeup_source_deactivate',\n\t\t'device_pm_callback_end',\n\t\t'device_pm_callback_start'\n\t]\n\tlogmsg = ''\n\ttestcommand = ''\n\tmempath = '/dev/mem'\n\tpowerfile = '/sys/power/state'\n\tmempowerfile = '/sys/power/mem_sleep'\n\tdiskpowerfile = '/sys/power/disk'\n\tsuspendmode = 'mem'\n\tmemmode = ''\n\tdiskmode = ''\n\thostname = 'localhost'\n\tprefix = 'test'\n\tteststamp = ''\n\tsysstamp = ''\n\tdmesgstart = 0.0\n\tdmesgfile = ''\n\tftracefile = ''\n\thtmlfile = 'output.html'\n\tresult = ''\n\trtcwake = True\n\trtcwaketime = 15\n\trtcpath = ''\n\tdevicefilter = []\n\tcgfilter = []\n\tstamp = 0\n\texeccount = 1\n\tx2delay = 0\n\tskiphtml = False\n\tusecallgraph = False\n\tftopfunc = 'pm_suspend'\n\tftop = False\n\tusetraceevents = False\n\tusetracemarkers = True\n\tuseftrace = True\n\tusekprobes = True\n\tusedevsrc = False\n\tuseprocmon = False\n\tnotestrun = False\n\tcgdump = False\n\tdevdump = False\n\tmixedphaseheight = True\n\tdevprops = dict()\n\tcfgdef = dict()\n\tplatinfo = []\n\tpredelay = 0\n\tpostdelay = 0\n\ttmstart = 'SUSPEND START %Y%m%d-%H:%M:%S.%f'\n\ttmend = 'RESUME COMPLETE %Y%m%d-%H:%M:%S.%f'\n\ttracefuncs = {\n\t\t'async_synchronize_full': {},\n\t\t'sys_sync': {},\n\t\t'ksys_sync': {},\n\t\t'__pm_notifier_call_chain': {},\n\t\t'pm_prepare_console': {},\n\t\t'pm_notifier_call_chain': {},\n\t\t'freeze_processes': {},\n\t\t'freeze_kernel_threads': {},\n\t\t'pm_restrict_gfp_mask': {},\n\t\t'acpi_suspend_begin': {},\n\t\t'acpi_hibernation_begin': {},\n\t\t'acpi_hibernation_enter': {},\n\t\t'acpi_hibernation_leave': {},\n\t\t'acpi_pm_freeze': {},\n\t\t'acpi_pm_thaw': {},\n\t\t'acpi_s2idle_end': {},\n\t\t'acpi_s2idle_sync': {},\n\t\t'acpi_s2idle_begin': {},\n\t\t'acpi_s2idle_prepare': {},\n\t\t'acpi_s2idle_prepare_late': {},\n\t\t'acpi_s2idle_wake': {},\n\t\t'acpi_s2idle_wakeup': {},\n\t\t'acpi_s2idle_restore': {},\n\t\t'acpi_s2idle_restore_early': {},\n\t\t'hibernate_preallocate_memory': {},\n\t\t'create_basic_memory_bitmaps': {},\n\t\t'swsusp_write': {},\n\t\t'suspend_console': {},\n\t\t'acpi_pm_prepare': {},\n\t\t'syscore_suspend': {},\n\t\t'arch_enable_nonboot_cpus_end': {},\n\t\t'syscore_resume': {},\n\t\t'acpi_pm_finish': {},\n\t\t'resume_console': {},\n\t\t'acpi_pm_end': {},\n\t\t'pm_restore_gfp_mask': {},\n\t\t'thaw_processes': {},\n\t\t'pm_restore_console': {},\n\t\t'CPU_OFF': {\n\t\t\t'func':'_cpu_down',\n\t\t\t'args_x86_64': {'cpu':'%di:s32'},\n\t\t\t'format': 'CPU_OFF[{cpu}]'\n\t\t},\n\t\t'CPU_ON': {\n\t\t\t'func':'_cpu_up',\n\t\t\t'args_x86_64': {'cpu':'%di:s32'},\n\t\t\t'format': 'CPU_ON[{cpu}]'\n\t\t},\n\t}\n\tdev_tracefuncs = {\n\t\t# general wait/delay/sleep\n\t\t'msleep': { 'args_x86_64': {'time':'%di:s32'}, 'ub': 1 },\n\t\t'schedule_timeout': { 'args_x86_64': {'timeout':'%di:s32'}, 'ub': 1 },\n\t\t'udelay': { 'func':'__const_udelay', 'args_x86_64': {'loops':'%di:s32'}, 'ub': 1 },\n\t\t'usleep_range': { 'args_x86_64': {'min':'%di:s32', 'max':'%si:s32'}, 'ub': 1 },\n\t\t'mutex_lock_slowpath': { 'func':'__mutex_lock_slowpath', 'ub': 1 },\n\t\t'acpi_os_stall': {'ub': 1},\n\t\t'rt_mutex_slowlock': {'ub': 1},\n\t\t# ACPI\n\t\t'acpi_resume_power_resources': {},\n\t\t'acpi_ps_execute_method': { 'args_x86_64': {\n\t\t\t'fullpath':'+0(+40(%di)):string',\n\t\t}},\n\t\t# mei_me\n\t\t'mei_reset': {},\n\t\t# filesystem\n\t\t'ext4_sync_fs': {},\n\t\t# 80211\n\t\t'ath10k_bmi_read_memory': { 'args_x86_64': {'length':'%cx:s32'} },\n\t\t'ath10k_bmi_write_memory': { 'args_x86_64': {'length':'%cx:s32'} },\n\t\t'ath10k_bmi_fast_download': { 'args_x86_64': {'length':'%cx:s32'} },\n\t\t'iwlagn_mac_start': {},\n\t\t'iwlagn_alloc_bcast_station': {},\n\t\t'iwl_trans_pcie_start_hw': {},\n\t\t'iwl_trans_pcie_start_fw': {},\n\t\t'iwl_run_init_ucode': {},\n\t\t'iwl_load_ucode_wait_alive': {},\n\t\t'iwl_alive_start': {},\n\t\t'iwlagn_mac_stop': {},\n\t\t'iwlagn_mac_suspend': {},\n\t\t'iwlagn_mac_resume': {},\n\t\t'iwlagn_mac_add_interface': {},\n\t\t'iwlagn_mac_remove_interface': {},\n\t\t'iwlagn_mac_change_interface': {},\n\t\t'iwlagn_mac_config': {},\n\t\t'iwlagn_configure_filter': {},\n\t\t'iwlagn_mac_hw_scan': {},\n\t\t'iwlagn_bss_info_changed': {},\n\t\t'iwlagn_mac_channel_switch': {},\n\t\t'iwlagn_mac_flush': {},\n\t\t# ATA\n\t\t'ata_eh_recover': { 'args_x86_64': {'port':'+36(%di):s32'} },\n\t\t# i915\n\t\t'i915_gem_resume': {},\n\t\t'i915_restore_state': {},\n\t\t'intel_opregion_setup': {},\n\t\t'g4x_pre_enable_dp': {},\n\t\t'vlv_pre_enable_dp': {},\n\t\t'chv_pre_enable_dp': {},\n\t\t'g4x_enable_dp': {},\n\t\t'vlv_enable_dp': {},\n\t\t'intel_hpd_init': {},\n\t\t'intel_opregion_register': {},\n\t\t'intel_dp_detect': {},\n\t\t'intel_hdmi_detect': {},\n\t\t'intel_opregion_init': {},\n\t\t'intel_fbdev_set_suspend': {},\n\t}\n\tinfocmds = [\n\t\t[0, 'sysinfo', 'uname', '-a'],\n\t\t[0, 'cpuinfo', 'head', '-7', '/proc/cpuinfo'],\n\t\t[0, 'kparams', 'cat', '/proc/cmdline'],\n\t\t[0, 'mcelog', 'mcelog'],\n\t\t[0, 'pcidevices', 'lspci', '-tv'],\n\t\t[0, 'usbdevices', 'lsusb', '-tv'],\n\t\t[0, 'acpidevices', 'sh', '-c', 'ls -l /sys/bus/acpi/devices/*/physical_node'],\n\t\t[0, 's0ix_require', 'cat', '/sys/kernel/debug/pmc_core/substate_requirements'],\n\t\t[0, 's0ix_debug', 'cat', '/sys/kernel/debug/pmc_core/slp_s0_debug_status'],\n\t\t[0, 'ethtool', 'ethtool', '{ethdev}'],\n\t\t[1, 's0ix_residency', 'cat', '/sys/kernel/debug/pmc_core/slp_s0_residency_usec'],\n\t\t[1, 'interrupts', 'cat', '/proc/interrupts'],\n\t\t[1, 'wakeups', 'cat', '/sys/kernel/debug/wakeup_sources'],\n\t\t[2, 'gpecounts', 'sh', '-c', 'grep -v invalid /sys/firmware/acpi/interrupts/*'],\n\t\t[2, 'suspendstats', 'sh', '-c', 'grep -v invalid /sys/power/suspend_stats/*'],\n\t\t[2, 'cpuidle', 'sh', '-c', 'grep -v invalid /sys/devices/system/cpu/cpu*/cpuidle/state*/s2idle/*'],\n\t\t[2, 'battery', 'sh', '-c', 'grep -v invalid /sys/class/power_supply/*/*'],\n\t\t[2, 'thermal', 'sh', '-c', 'grep . /sys/class/thermal/thermal_zone*/temp'],\n\t]\n\tcgblacklist = []\n\tkprobes = dict()\n\ttimeformat = '%.3f'\n\tcmdline = '%s %s' % \\\n\t\t\t(os.path.basename(sys.argv[0]), ' '.join(sys.argv[1:]))\n\tsudouser = ''\n\tdef __init__(self):\n\t\tself.archargs = 'args_'+platform.machine()\n\t\tself.hostname = platform.node()\n\t\tif(self.hostname == ''):\n\t\t\tself.hostname = 'localhost'\n\t\trtc = \"rtc0\"\n\t\tif os.path.exists('/dev/rtc'):\n\t\t\trtc = os.readlink('/dev/rtc')\n\t\trtc = '/sys/class/rtc/'+rtc\n\t\tif os.path.exists(rtc) and os.path.exists(rtc+'/date') and \\\n\t\t\tos.path.exists(rtc+'/time') and os.path.exists(rtc+'/wakealarm'):\n\t\t\tself.rtcpath = rtc\n\t\tif (hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()):\n\t\t\tself.ansi = True\n\t\tself.testdir = datetime.now().strftime('suspend-%y%m%d-%H%M%S')\n\t\tif os.getuid() == 0 and 'SUDO_USER' in os.environ and \\\n\t\t\tos.environ['SUDO_USER']:\n\t\t\tself.sudouser = os.environ['SUDO_USER']\n\tdef resetlog(self):\n\t\tself.logmsg = ''\n\t\tself.platinfo = []\n\tdef vprint(self, msg):\n\t\tself.logmsg += msg+'\\n'\n\t\tif self.verbose or msg.startswith('WARNING:'):\n\t\t\tpprint(msg)\n\tdef signalHandler(self, signum, frame):\n\t\tif not self.result:\n\t\t\treturn\n\t\tsigname = self.signames[signum] if signum in self.signames else 'UNKNOWN'\n\t\tmsg = 'Signal %s caused a tool exit, line %d' % (signame, frame.f_lineno)\n\t\tself.outputResult({'error':msg})\n\t\tsys.exit(3)\n\tdef signalHandlerInit(self):\n\t\tcapture = ['BUS', 'SYS', 'XCPU', 'XFSZ', 'PWR', 'HUP', 'INT', 'QUIT',\n\t\t\t'ILL', 'ABRT', 'FPE', 'SEGV', 'TERM']\n\t\tself.signames = dict()\n\t\tfor i in capture:\n\t\t\ts = 'SIG'+i\n\t\t\ttry:\n\t\t\t\tsignum = getattr(signal, s)\n\t\t\t\tsignal.signal(signum, self.signalHandler)\n\t\t\texcept:\n\t\t\t\tcontinue\n\t\t\tself.signames[signum] = s\n\tdef rootCheck(self, fatal=True):\n\t\tif(os.access(self.powerfile, os.W_OK)):\n\t\t\treturn True\n\t\tif fatal:\n\t\t\tmsg = 'This command requires sysfs mount and root access'\n\t\t\tpprint('ERROR: %s\\n' % msg)\n\t\t\tself.outputResult({'error':msg})\n\t\t\tsys.exit(1)\n\t\treturn False\n\tdef rootUser(self, fatal=False):\n\t\tif 'USER' in os.environ and os.environ['USER'] == 'root':\n\t\t\treturn True\n\t\tif fatal:\n\t\t\tmsg = 'This command must be run as root'\n\t\t\tpprint('ERROR: %s\\n' % msg)\n\t\t\tself.outputResult({'error':msg})\n\t\t\tsys.exit(1)\n\t\treturn False\n\tdef usable(self, file, ishtml=False):\n\t\tif not os.path.exists(file) or os.path.getsize(file) < 1:\n\t\t\treturn False\n\t\tif ishtml:\n\t\t\ttry:\n\t\t\t\tfp = open(file, 'r')\n\t\t\t\tres = fp.read(1000)\n\t\t\t\tfp.close()\n\t\t\texcept:\n\t\t\t\treturn False\n\t\t\tif '<html>' not in res:\n\t\t\t\treturn False\n\t\treturn True\n\tdef getExec(self, cmd):\n\t\ttry:\n\t\t\tfp = Popen(['which', cmd], stdout=PIPE, stderr=PIPE).stdout\n\t\t\tout = ascii(fp.read()).strip()\n\t\t\tfp.close()\n\t\texcept:\n\t\t\tout = ''\n\t\tif out:\n\t\t\treturn out\n\t\tfor path in ['/sbin', '/bin', '/usr/sbin', '/usr/bin',\n\t\t\t'/usr/local/sbin', '/usr/local/bin']:\n\t\t\tcmdfull = os.path.join(path, cmd)\n\t\t\tif os.path.exists(cmdfull):\n\t\t\t\treturn cmdfull\n\t\treturn out\n\tdef setPrecision(self, num):\n\t\tif num < 0 or num > 6:\n\t\t\treturn\n\t\tself.timeformat = '%.{0}f'.format(num)\n\tdef setOutputFolder(self, value):\n\t\targs = dict()\n\t\tn = datetime.now()\n\t\targs['date'] = n.strftime('%y%m%d')\n\t\targs['time'] = n.strftime('%H%M%S')\n\t\targs['hostname'] = args['host'] = self.hostname\n\t\targs['mode'] = self.suspendmode\n\t\treturn value.format(**args)\n\tdef setOutputFile(self):\n\t\tif self.dmesgfile != '':\n\t\t\tm = re.match('(?P<name>.*)_dmesg\\.txt.*', self.dmesgfile)\n\t\t\tif(m):\n\t\t\t\tself.htmlfile = m.group('name')+'.html'\n\t\tif self.ftracefile != '':\n\t\t\tm = re.match('(?P<name>.*)_ftrace\\.txt.*', self.ftracefile)\n\t\t\tif(m):\n\t\t\t\tself.htmlfile = m.group('name')+'.html'\n\tdef systemInfo(self, info):\n\t\tp = m = ''\n\t\tif 'baseboard-manufacturer' in info:\n\t\t\tm = info['baseboard-manufacturer']\n\t\telif 'system-manufacturer' in info:\n\t\t\tm = info['system-manufacturer']\n\t\tif 'system-product-name' in info:\n\t\t\tp = info['system-product-name']\n\t\telif 'baseboard-product-name' in info:\n\t\t\tp = info['baseboard-product-name']\n\t\tif m[:5].lower() == 'intel' and 'baseboard-product-name' in info:\n\t\t\tp = info['baseboard-product-name']\n\t\tc = info['processor-version'] if 'processor-version' in info else ''\n\t\tb = info['bios-version'] if 'bios-version' in info else ''\n\t\tr = info['bios-release-date'] if 'bios-release-date' in info else ''\n\t\tself.sysstamp = '# sysinfo | man:%s | plat:%s | cpu:%s | bios:%s | biosdate:%s | numcpu:%d | memsz:%d | memfr:%d' % \\\n\t\t\t(m, p, c, b, r, self.cpucount, self.memtotal, self.memfree)\n\t\tif self.osversion:\n\t\t\tself.sysstamp += ' | os:%s' % self.osversion\n\tdef printSystemInfo(self, fatal=False):\n\t\tself.rootCheck(True)\n\t\tout = dmidecode(self.mempath, fatal)\n\t\tif len(out) < 1:\n\t\t\treturn\n\t\tfmt = '%-24s: %s'\n\t\tif self.osversion:\n\t\t\tprint(fmt % ('os-version', self.osversion))\n\t\tfor name in sorted(out):\n\t\t\tprint(fmt % (name, out[name]))\n\t\tprint(fmt % ('cpucount', ('%d' % self.cpucount)))\n\t\tprint(fmt % ('memtotal', ('%d kB' % self.memtotal)))\n\t\tprint(fmt % ('memfree', ('%d kB' % self.memfree)))\n\tdef cpuInfo(self):\n\t\tself.cpucount = 0\n\t\tif os.path.exists('/proc/cpuinfo'):\n\t\t\twith open('/proc/cpuinfo', 'r') as fp:\n\t\t\t\tfor line in fp:\n\t\t\t\t\tif re.match('^processor[ \\t]*:[ \\t]*[0-9]*', line):\n\t\t\t\t\t\tself.cpucount += 1\n\t\tif os.path.exists('/proc/meminfo'):\n\t\t\twith open('/proc/meminfo', 'r') as fp:\n\t\t\t\tfor line in fp:\n\t\t\t\t\tm = re.match('^MemTotal:[ \\t]*(?P<sz>[0-9]*) *kB', line)\n\t\t\t\t\tif m:\n\t\t\t\t\t\tself.memtotal = int(m.group('sz'))\n\t\t\t\t\tm = re.match('^MemFree:[ \\t]*(?P<sz>[0-9]*) *kB', line)\n\t\t\t\t\tif m:\n\t\t\t\t\t\tself.memfree = int(m.group('sz'))\n\t\tif os.path.exists('/etc/os-release'):\n\t\t\twith open('/etc/os-release', 'r') as fp:\n\t\t\t\tfor line in fp:\n\t\t\t\t\tif line.startswith('PRETTY_NAME='):\n\t\t\t\t\t\tself.osversion = line[12:].strip().replace('\"', '')\n\tdef initTestOutput(self, name):\n\t\tself.prefix = self.hostname\n\t\tv = open('/proc/version', 'r').read().strip()\n\t\tkver = v.split()[2]\n\t\tfmt = name+'-%m%d%y-%H%M%S'\n\t\ttesttime = datetime.now().strftime(fmt)\n\t\tself.teststamp = \\\n\t\t\t'# '+testtime+' '+self.prefix+' '+self.suspendmode+' '+kver\n\t\text = ''\n\t\tif self.gzip:\n\t\t\text = '.gz'\n\t\tself.dmesgfile = \\\n\t\t\tself.testdir+'/'+self.prefix+'_'+self.suspendmode+'_dmesg.txt'+ext\n\t\tself.ftracefile = \\\n\t\t\tself.testdir+'/'+self.prefix+'_'+self.suspendmode+'_ftrace.txt'+ext\n\t\tself.htmlfile = \\\n\t\t\tself.testdir+'/'+self.prefix+'_'+self.suspendmode+'.html'\n\t\tif not os.path.isdir(self.testdir):\n\t\t\tos.makedirs(self.testdir)\n\t\tself.sudoUserchown(self.testdir)\n\tdef getValueList(self, value):\n\t\tout = []\n\t\tfor i in value.split(','):\n\t\t\tif i.strip():\n\t\t\t\tout.append(i.strip())\n\t\treturn out\n\tdef setDeviceFilter(self, value):\n\t\tself.devicefilter = self.getValueList(value)\n\tdef setCallgraphFilter(self, value):\n\t\tself.cgfilter = self.getValueList(value)\n\tdef skipKprobes(self, value):\n\t\tfor k in self.getValueList(value):\n\t\t\tif k in self.tracefuncs:\n\t\t\t\tdel self.tracefuncs[k]\n\t\t\tif k in self.dev_tracefuncs:\n\t\t\t\tdel self.dev_tracefuncs[k]\n\tdef setCallgraphBlacklist(self, file):\n\t\tself.cgblacklist = self.listFromFile(file)\n\tdef rtcWakeAlarmOn(self):\n\t\tcall('echo 0 > '+self.rtcpath+'/wakealarm', shell=True)\n\t\tnowtime = open(self.rtcpath+'/since_epoch', 'r').read().strip()\n\t\tif nowtime:\n\t\t\tnowtime = int(nowtime)\n\t\telse:\n\t\t\t# if hardware time fails, use the software time\n\t\t\tnowtime = int(datetime.now().strftime('%s'))\n\t\talarm = nowtime + self.rtcwaketime\n\t\tcall('echo %d > %s/wakealarm' % (alarm, self.rtcpath), shell=True)\n\tdef rtcWakeAlarmOff(self):\n\t\tcall('echo 0 > %s/wakealarm' % self.rtcpath, shell=True)\n\tdef initdmesg(self):\n\t\t# get the latest time stamp from the dmesg log\n\t\tlines = Popen('dmesg', stdout=PIPE).stdout.readlines()\n\t\tktime = '0'\n\t\tfor line in reversed(lines):\n\t\t\tline = ascii(line).replace('\\r\\n', '')\n\t\t\tidx = line.find('[')\n\t\t\tif idx > 1:\n\t\t\t\tline = line[idx:]\n\t\t\tm = re.match('[ \\t]*(\\[ *)(?P<ktime>[0-9\\.]*)(\\]) (?P<msg>.*)', line)\n\t\t\tif(m):\n\t\t\t\tktime = m.group('ktime')\n\t\t\t\tbreak\n\t\tself.dmesgstart = float(ktime)\n\tdef getdmesg(self, testdata):\n\t\top = self.writeDatafileHeader(self.dmesgfile, testdata)\n\t\t# store all new dmesg lines since initdmesg was called\n\t\tfp = Popen('dmesg', stdout=PIPE).stdout\n\t\tfor line in fp:\n\t\t\tline = ascii(line).replace('\\r\\n', '')\n\t\t\tidx = line.find('[')\n\t\t\tif idx > 1:\n\t\t\t\tline = line[idx:]\n\t\t\tm = re.match('[ \\t]*(\\[ *)(?P<ktime>[0-9\\.]*)(\\]) (?P<msg>.*)', line)\n\t\t\tif(not m):\n\t\t\t\tcontinue\n\t\t\tktime = float(m.group('ktime'))\n\t\t\tif ktime > self.dmesgstart:\n\t\t\t\top.write(line)\n\t\tfp.close()\n\t\top.close()\n\tdef listFromFile(self, file):\n\t\tlist = []\n\t\tfp = open(file)\n\t\tfor i in fp.read().split('\\n'):\n\t\t\ti = i.strip()\n\t\t\tif i and i[0] != '#':\n\t\t\t\tlist.append(i)\n\t\tfp.close()\n\t\treturn list\n\tdef addFtraceFilterFunctions(self, file):\n\t\tfor i in self.listFromFile(file):\n\t\t\tif len(i) < 2:\n\t\t\t\tcontinue\n\t\t\tself.tracefuncs[i] = dict()\n\tdef getFtraceFilterFunctions(self, current):\n\t\tself.rootCheck(True)\n\t\tif not current:\n\t\t\tcall('cat '+self.tpath+'available_filter_functions', shell=True)\n\t\t\treturn\n\t\tmaster = self.listFromFile(self.tpath+'available_filter_functions')\n\t\tfor i in sorted(self.tracefuncs):\n\t\t\tif 'func' in self.tracefuncs[i]:\n\t\t\t\ti = self.tracefuncs[i]['func']\n\t\t\tif i in master:\n\t\t\t\tprint(i)\n\t\t\telse:\n\t\t\t\tprint(self.colorText(i))\n\tdef setFtraceFilterFunctions(self, list):\n\t\tmaster = self.listFromFile(self.tpath+'available_filter_functions')\n\t\tflist = ''\n\t\tfor i in list:\n\t\t\tif i not in master:\n\t\t\t\tcontinue\n\t\t\tif ' [' in i:\n\t\t\t\tflist += i.split(' ')[0]+'\\n'\n\t\t\telse:\n\t\t\t\tflist += i+'\\n'\n\t\tfp = open(self.tpath+'set_graph_function', 'w')\n\t\tfp.write(flist)\n\t\tfp.close()\n\tdef basicKprobe(self, name):\n\t\tself.kprobes[name] = {'name': name,'func': name,'args': dict(),'format': name}\n\tdef defaultKprobe(self, name, kdata):\n\t\tk = kdata\n\t\tfor field in ['name', 'format', 'func']:\n\t\t\tif field not in k:\n\t\t\t\tk[field] = name\n\t\tif self.archargs in k:\n\t\t\tk['args'] = k[self.archargs]\n\t\telse:\n\t\t\tk['args'] = dict()\n\t\t\tk['format'] = name\n\t\tself.kprobes[name] = k\n\tdef kprobeColor(self, name):\n\t\tif name not in self.kprobes or 'color' not in self.kprobes[name]:\n\t\t\treturn ''\n\t\treturn self.kprobes[name]['color']\n\tdef kprobeDisplayName(self, name, dataraw):\n\t\tif name not in self.kprobes:\n\t\t\tself.basicKprobe(name)\n\t\tdata = ''\n\t\tquote=0\n\t\t# first remvoe any spaces inside quotes, and the quotes\n\t\tfor c in dataraw:\n\t\t\tif c == '\"':\n\t\t\t\tquote = (quote + 1) % 2\n\t\t\tif quote and c == ' ':\n\t\t\t\tdata += '_'\n\t\t\telif c != '\"':\n\t\t\t\tdata += c\n\t\tfmt, args = self.kprobes[name]['format'], self.kprobes[name]['args']\n\t\targlist = dict()\n\t\t# now process the args\n\t\tfor arg in sorted(args):\n\t\t\targlist[arg] = ''\n\t\t\tm = re.match('.* '+arg+'=(?P<arg>.*) ', data);\n\t\t\tif m:\n\t\t\t\targlist[arg] = m.group('arg')\n\t\t\telse:\n\t\t\t\tm = re.match('.* '+arg+'=(?P<arg>.*)', data);\n\t\t\t\tif m:\n\t\t\t\t\targlist[arg] = m.group('arg')\n\t\tout = fmt.format(**arglist)\n\t\tout = out.replace(' ', '_').replace('\"', '')\n\t\treturn out\n\tdef kprobeText(self, kname, kprobe):\n\t\tname = fmt = func = kname\n\t\targs = dict()\n\t\tif 'name' in kprobe:\n\t\t\tname = kprobe['name']\n\t\tif 'format' in kprobe:\n\t\t\tfmt = kprobe['format']\n\t\tif 'func' in kprobe:\n\t\t\tfunc = kprobe['func']\n\t\tif self.archargs in kprobe:\n\t\t\targs = kprobe[self.archargs]\n\t\tif 'args' in kprobe:\n\t\t\targs = kprobe['args']\n\t\tif re.findall('{(?P<n>[a-z,A-Z,0-9]*)}', func):\n\t\t\tdoError('Kprobe \"%s\" has format info in the function name \"%s\"' % (name, func))\n\t\tfor arg in re.findall('{(?P<n>[a-z,A-Z,0-9]*)}', fmt):\n\t\t\tif arg not in args:\n\t\t\t\tdoError('Kprobe \"%s\" is missing argument \"%s\"' % (name, arg))\n\t\tval = 'p:%s_cal %s' % (name, func)\n\t\tfor i in sorted(args):\n\t\t\tval += ' %s=%s' % (i, args[i])\n\t\tval += '\\nr:%s_ret %s $retval\\n' % (name, func)\n\t\treturn val\n\tdef addKprobes(self, output=False):\n\t\tif len(self.kprobes) < 1:\n\t\t\treturn\n\t\tif output:\n\t\t\tpprint('    kprobe functions in this kernel:')\n\t\t# first test each kprobe\n\t\trejects = []\n\t\t# sort kprobes: trace, ub-dev, custom, dev\n\t\tkpl = [[], [], [], []]\n\t\tlinesout = len(self.kprobes)\n\t\tfor name in sorted(self.kprobes):\n\t\t\tres = self.colorText('YES', 32)\n\t\t\tif not self.testKprobe(name, self.kprobes[name]):\n\t\t\t\tres = self.colorText('NO')\n\t\t\t\trejects.append(name)\n\t\t\telse:\n\t\t\t\tif name in self.tracefuncs:\n\t\t\t\t\tkpl[0].append(name)\n\t\t\t\telif name in self.dev_tracefuncs:\n\t\t\t\t\tif 'ub' in self.dev_tracefuncs[name]:\n\t\t\t\t\t\tkpl[1].append(name)\n\t\t\t\t\telse:\n\t\t\t\t\t\tkpl[3].append(name)\n\t\t\t\telse:\n\t\t\t\t\tkpl[2].append(name)\n\t\t\tif output:\n\t\t\t\tpprint('         %s: %s' % (name, res))\n\t\tkplist = kpl[0] + kpl[1] + kpl[2] + kpl[3]\n\t\t# remove all failed ones from the list\n\t\tfor name in rejects:\n\t\t\tself.kprobes.pop(name)\n\t\t# set the kprobes all at once\n\t\tself.fsetVal('', 'kprobe_events')\n\t\tkprobeevents = ''\n\t\tfor kp in kplist:\n\t\t\tkprobeevents += self.kprobeText(kp, self.kprobes[kp])\n\t\tself.fsetVal(kprobeevents, 'kprobe_events')\n\t\tif output:\n\t\t\tcheck = self.fgetVal('kprobe_events')\n\t\t\tlinesack = (len(check.split('\\n')) - 1) // 2\n\t\t\tpprint('    kprobe functions enabled: %d/%d' % (linesack, linesout))\n\t\tself.fsetVal('1', 'events/kprobes/enable')\n\tdef testKprobe(self, kname, kprobe):\n\t\tself.fsetVal('0', 'events/kprobes/enable')\n\t\tkprobeevents = self.kprobeText(kname, kprobe)\n\t\tif not kprobeevents:\n\t\t\treturn False\n\t\ttry:\n\t\t\tself.fsetVal(kprobeevents, 'kprobe_events')\n\t\t\tcheck = self.fgetVal('kprobe_events')\n\t\texcept:\n\t\t\treturn False\n\t\tlinesout = len(kprobeevents.split('\\n'))\n\t\tlinesack = len(check.split('\\n'))\n\t\tif linesack < linesout:\n\t\t\treturn False\n\t\treturn True\n\tdef setVal(self, val, file):\n\t\tif not os.path.exists(file):\n\t\t\treturn False\n\t\ttry:\n\t\t\tfp = open(file, 'wb', 0)\n\t\t\tfp.write(val.encode())\n\t\t\tfp.flush()\n\t\t\tfp.close()\n\t\texcept:\n\t\t\treturn False\n\t\treturn True\n\tdef fsetVal(self, val, path):\n\t\tif not self.useftrace:\n\t\t\treturn False\n\t\treturn self.setVal(val, self.tpath+path)\n\tdef getVal(self, file):\n\t\tres = ''\n\t\tif not os.path.exists(file):\n\t\t\treturn res\n\t\ttry:\n\t\t\tfp = open(file, 'r')\n\t\t\tres = fp.read()\n\t\t\tfp.close()\n\t\texcept:\n\t\t\tpass\n\t\treturn res\n\tdef fgetVal(self, path):\n\t\tif not self.useftrace:\n\t\t\treturn ''\n\t\treturn self.getVal(self.tpath+path)\n\tdef cleanupFtrace(self):\n\t\tif self.useftrace:\n\t\t\tself.fsetVal('0', 'events/kprobes/enable')\n\t\t\tself.fsetVal('', 'kprobe_events')\n\t\t\tself.fsetVal('1024', 'buffer_size_kb')\n\tdef setupAllKprobes(self):\n\t\tfor name in self.tracefuncs:\n\t\t\tself.defaultKprobe(name, self.tracefuncs[name])\n\t\tfor name in self.dev_tracefuncs:\n\t\t\tself.defaultKprobe(name, self.dev_tracefuncs[name])\n\tdef isCallgraphFunc(self, name):\n\t\tif len(self.tracefuncs) < 1 and self.suspendmode == 'command':\n\t\t\treturn True\n\t\tfor i in self.tracefuncs:\n\t\t\tif 'func' in self.tracefuncs[i]:\n\t\t\t\tf = self.tracefuncs[i]['func']\n\t\t\telse:\n\t\t\t\tf = i\n\t\t\tif name == f:\n\t\t\t\treturn True\n\t\treturn False\n\tdef initFtrace(self, quiet=False):\n\t\tif not self.useftrace:\n\t\t\treturn\n\t\tif not quiet:\n\t\t\tsysvals.printSystemInfo(False)\n\t\t\tpprint('INITIALIZING FTRACE')\n\t\t# turn trace off\n\t\tself.fsetVal('0', 'tracing_on')\n\t\tself.cleanupFtrace()\n\t\t# set the trace clock to global\n\t\tself.fsetVal('global', 'trace_clock')\n\t\tself.fsetVal('nop', 'current_tracer')\n\t\t# set trace buffer to an appropriate value\n\t\tcpus = max(1, self.cpucount)\n\t\tif self.bufsize > 0:\n\t\t\ttgtsize = self.bufsize\n\t\telif self.usecallgraph or self.usedevsrc:\n\t\t\tbmax = (1*1024*1024) if self.suspendmode in ['disk', 'command'] \\\n\t\t\t\telse (3*1024*1024)\n\t\t\ttgtsize = min(self.memfree, bmax)\n\t\telse:\n\t\t\ttgtsize = 65536\n\t\twhile not self.fsetVal('%d' % (tgtsize // cpus), 'buffer_size_kb'):\n\t\t\t# if the size failed to set, lower it and keep trying\n\t\t\ttgtsize -= 65536\n\t\t\tif tgtsize < 65536:\n\t\t\t\ttgtsize = int(self.fgetVal('buffer_size_kb')) * cpus\n\t\t\t\tbreak\n\t\tself.vprint('Setting trace buffers to %d kB (%d kB per cpu)' % (tgtsize, tgtsize/cpus))\n\t\t# initialize the callgraph trace\n\t\tif(self.usecallgraph):\n\t\t\t# set trace type\n\t\t\tself.fsetVal('function_graph', 'current_tracer')\n\t\t\tself.fsetVal('', 'set_ftrace_filter')\n\t\t\t# temporary hack to fix https://bugzilla.kernel.org/show_bug.cgi?id=212761\n\t\t\tfp = open(self.tpath+'set_ftrace_notrace', 'w')\n\t\t\tfp.write('native_queued_spin_lock_slowpath\\ndev_driver_string')\n\t\t\tfp.close()\n\t\t\t# set trace format options\n\t\t\tself.fsetVal('print-parent', 'trace_options')\n\t\t\tself.fsetVal('funcgraph-abstime', 'trace_options')\n\t\t\tself.fsetVal('funcgraph-cpu', 'trace_options')\n\t\t\tself.fsetVal('funcgraph-duration', 'trace_options')\n\t\t\tself.fsetVal('funcgraph-proc', 'trace_options')\n\t\t\tself.fsetVal('funcgraph-tail', 'trace_options')\n\t\t\tself.fsetVal('nofuncgraph-overhead', 'trace_options')\n\t\t\tself.fsetVal('context-info', 'trace_options')\n\t\t\tself.fsetVal('graph-time', 'trace_options')\n\t\t\tself.fsetVal('%d' % self.max_graph_depth, 'max_graph_depth')\n\t\t\tcf = ['dpm_run_callback']\n\t\t\tif(self.usetraceevents):\n\t\t\t\tcf += ['dpm_prepare', 'dpm_complete']\n\t\t\tfor fn in self.tracefuncs:\n\t\t\t\tif 'func' in self.tracefuncs[fn]:\n\t\t\t\t\tcf.append(self.tracefuncs[fn]['func'])\n\t\t\t\telse:\n\t\t\t\t\tcf.append(fn)\n\t\t\tif self.ftop:\n\t\t\t\tself.setFtraceFilterFunctions([self.ftopfunc])\n\t\t\telse:\n\t\t\t\tself.setFtraceFilterFunctions(cf)\n\t\t# initialize the kprobe trace\n\t\telif self.usekprobes:\n\t\t\tfor name in self.tracefuncs:\n\t\t\t\tself.defaultKprobe(name, self.tracefuncs[name])\n\t\t\tif self.usedevsrc:\n\t\t\t\tfor name in self.dev_tracefuncs:\n\t\t\t\t\tself.defaultKprobe(name, self.dev_tracefuncs[name])\n\t\t\tif not quiet:\n\t\t\t\tpprint('INITIALIZING KPROBES')\n\t\t\tself.addKprobes(self.verbose)\n\t\tif(self.usetraceevents):\n\t\t\t# turn trace events on\n\t\t\tevents = iter(self.traceevents)\n\t\t\tfor e in events:\n\t\t\t\tself.fsetVal('1', 'events/power/'+e+'/enable')\n\t\t# clear the trace buffer\n\t\tself.fsetVal('', 'trace')\n\tdef verifyFtrace(self):\n\t\t# files needed for any trace data\n\t\tfiles = ['buffer_size_kb', 'current_tracer', 'trace', 'trace_clock',\n\t\t\t\t 'trace_marker', 'trace_options', 'tracing_on']\n\t\t# files needed for callgraph trace data\n\t\ttp = self.tpath\n\t\tif(self.usecallgraph):\n\t\t\tfiles += [\n\t\t\t\t'available_filter_functions',\n\t\t\t\t'set_ftrace_filter',\n\t\t\t\t'set_graph_function'\n\t\t\t]\n\t\tfor f in files:\n\t\t\tif(os.path.exists(tp+f) == False):\n\t\t\t\treturn False\n\t\treturn True\n\tdef verifyKprobes(self):\n\t\t# files needed for kprobes to work\n\t\tfiles = ['kprobe_events', 'events']\n\t\ttp = self.tpath\n\t\tfor f in files:\n\t\t\tif(os.path.exists(tp+f) == False):\n\t\t\t\treturn False\n\t\treturn True\n\tdef colorText(self, str, color=31):\n\t\tif not self.ansi:\n\t\t\treturn str\n\t\treturn '\\x1B[%d;40m%s\\x1B[m' % (color, str)\n\tdef writeDatafileHeader(self, filename, testdata):\n\t\tfp = self.openlog(filename, 'w')\n\t\tfp.write('%s\\n%s\\n# command | %s\\n' % (self.teststamp, self.sysstamp, self.cmdline))\n\t\tfor test in testdata:\n\t\t\tif 'fw' in test:\n\t\t\t\tfw = test['fw']\n\t\t\t\tif(fw):\n\t\t\t\t\tfp.write('# fwsuspend %u fwresume %u\\n' % (fw[0], fw[1]))\n\t\t\tif 'turbo' in test:\n\t\t\t\tfp.write('# turbostat %s\\n' % test['turbo'])\n\t\t\tif 'wifi' in test:\n\t\t\t\tfp.write('# wifi %s\\n' % test['wifi'])\n\t\t\tif 'netfix' in test:\n\t\t\t\tfp.write('# netfix %s\\n' % test['netfix'])\n\t\t\tif test['error'] or len(testdata) > 1:\n\t\t\t\tfp.write('# enter_sleep_error %s\\n' % test['error'])\n\t\treturn fp\n\tdef sudoUserchown(self, dir):\n\t\tif os.path.exists(dir) and self.sudouser:\n\t\t\tcmd = 'chown -R {0}:{0} {1} > /dev/null 2>&1'\n\t\t\tcall(cmd.format(self.sudouser, dir), shell=True)\n\tdef outputResult(self, testdata, num=0):\n\t\tif not self.result:\n\t\t\treturn\n\t\tn = ''\n\t\tif num > 0:\n\t\t\tn = '%d' % num\n\t\tfp = open(self.result, 'a')\n\t\tif 'error' in testdata:\n\t\t\tfp.write('result%s: fail\\n' % n)\n\t\t\tfp.write('error%s: %s\\n' % (n, testdata['error']))\n\t\telse:\n\t\t\tfp.write('result%s: pass\\n' % n)\n\t\tif 'mode' in testdata:\n\t\t\tfp.write('mode%s: %s\\n' % (n, testdata['mode']))\n\t\tfor v in ['suspend', 'resume', 'boot', 'lastinit']:\n\t\t\tif v in testdata:\n\t\t\t\tfp.write('%s%s: %.3f\\n' % (v, n, testdata[v]))\n\t\tfor v in ['fwsuspend', 'fwresume']:\n\t\t\tif v in testdata:\n\t\t\t\tfp.write('%s%s: %.3f\\n' % (v, n, testdata[v] / 1000000.0))\n\t\tif 'bugurl' in testdata:\n\t\t\tfp.write('url%s: %s\\n' % (n, testdata['bugurl']))\n\t\tfp.close()\n\t\tself.sudoUserchown(self.result)\n\tdef configFile(self, file):\n\t\tdir = os.path.dirname(os.path.realpath(__file__))\n\t\tif os.path.exists(file):\n\t\t\treturn file\n\t\telif os.path.exists(dir+'/'+file):\n\t\t\treturn dir+'/'+file\n\t\telif os.path.exists(dir+'/config/'+file):\n\t\t\treturn dir+'/config/'+file\n\t\treturn ''\n\tdef openlog(self, filename, mode):\n\t\tisgz = self.gzip\n\t\tif mode == 'r':\n\t\t\ttry:\n\t\t\t\twith gzip.open(filename, mode+'t') as fp:\n\t\t\t\t\ttest = fp.read(64)\n\t\t\t\tisgz = True\n\t\t\texcept:\n\t\t\t\tisgz = False\n\t\tif isgz:\n\t\t\treturn gzip.open(filename, mode+'t')\n\t\treturn open(filename, mode)\n\tdef putlog(self, filename, text):\n\t\twith self.openlog(filename, 'a') as fp:\n\t\t\tfp.write(text)\n\t\t\tfp.close()\n\tdef dlog(self, text):\n\t\tif not self.dmesgfile:\n\t\t\treturn\n\t\tself.putlog(self.dmesgfile, '# %s\\n' % text)\n\tdef flog(self, text):\n\t\tself.putlog(self.ftracefile, text)\n\tdef b64unzip(self, data):\n\t\ttry:\n\t\t\tout = codecs.decode(base64.b64decode(data), 'zlib').decode()\n\t\texcept:\n\t\t\tout = data\n\t\treturn out\n\tdef b64zip(self, data):\n\t\tout = base64.b64encode(codecs.encode(data.encode(), 'zlib')).decode()\n\t\treturn out\n\tdef platforminfo(self, cmdafter):\n\t\t# add platform info on to a completed ftrace file\n\t\tif not os.path.exists(self.ftracefile):\n\t\t\treturn False\n\t\tfooter = '#\\n'\n\n\t\t# add test command string line if need be\n\t\tif self.suspendmode == 'command' and self.testcommand:\n\t\t\tfooter += '# platform-testcmd: %s\\n' % (self.testcommand)\n\n\t\t# get a list of target devices from the ftrace file\n\t\tprops = dict()\n\t\ttp = TestProps()\n\t\ttf = self.openlog(self.ftracefile, 'r')\n\t\tfor line in tf:\n\t\t\tif tp.stampInfo(line, self):\n\t\t\t\tcontinue\n\t\t\t# parse only valid lines, if this is not one move on\n\t\t\tm = re.match(tp.ftrace_line_fmt, line)\n\t\t\tif(not m or 'device_pm_callback_start' not in line):\n\t\t\t\tcontinue\n\t\t\tm = re.match('.*: (?P<drv>.*) (?P<d>.*), parent: *(?P<p>.*), .*', m.group('msg'));\n\t\t\tif(not m):\n\t\t\t\tcontinue\n\t\t\tdev = m.group('d')\n\t\t\tif dev not in props:\n\t\t\t\tprops[dev] = DevProps()\n\t\ttf.close()\n\n\t\t# now get the syspath for each target device\n\t\tfor dirname, dirnames, filenames in os.walk('/sys/devices'):\n\t\t\tif(re.match('.*/power', dirname) and 'async' in filenames):\n\t\t\t\tdev = dirname.split('/')[-2]\n\t\t\t\tif dev in props and (not props[dev].syspath or len(dirname) < len(props[dev].syspath)):\n\t\t\t\t\tprops[dev].syspath = dirname[:-6]\n\n\t\t# now fill in the properties for our target devices\n\t\tfor dev in sorted(props):\n\t\t\tdirname = props[dev].syspath\n\t\t\tif not dirname or not os.path.exists(dirname):\n\t\t\t\tcontinue\n\t\t\tprops[dev].isasync = False\n\t\t\tif os.path.exists(dirname+'/power/async'):\n\t\t\t\tfp = open(dirname+'/power/async')\n\t\t\t\tif 'enabled' in fp.read():\n\t\t\t\t\tprops[dev].isasync = True\n\t\t\t\tfp.close()\n\t\t\tfields = os.listdir(dirname)\n\t\t\tfor file in ['product', 'name', 'model', 'description', 'id', 'idVendor']:\n\t\t\t\tif file not in fields:\n\t\t\t\t\tcontinue\n\t\t\t\ttry:\n\t\t\t\t\twith open(os.path.join(dirname, file), 'rb') as fp:\n\t\t\t\t\t\tprops[dev].altname = ascii(fp.read())\n\t\t\t\texcept:\n\t\t\t\t\tcontinue\n\t\t\t\tif file == 'idVendor':\n\t\t\t\t\tidv, idp = props[dev].altname.strip(), ''\n\t\t\t\t\ttry:\n\t\t\t\t\t\twith open(os.path.join(dirname, 'idProduct'), 'rb') as fp:\n\t\t\t\t\t\t\tidp = ascii(fp.read()).strip()\n\t\t\t\t\texcept:\n\t\t\t\t\t\tprops[dev].altname = ''\n\t\t\t\t\t\tbreak\n\t\t\t\t\tprops[dev].altname = '%s:%s' % (idv, idp)\n\t\t\t\tbreak\n\t\t\tif props[dev].altname:\n\t\t\t\tout = props[dev].altname.strip().replace('\\n', ' ')\\\n\t\t\t\t\t.replace(',', ' ').replace(';', ' ')\n\t\t\t\tprops[dev].altname = out\n\n\t\t# add a devinfo line to the bottom of ftrace\n\t\tout = ''\n\t\tfor dev in sorted(props):\n\t\t\tout += props[dev].out(dev)\n\t\tfooter += '# platform-devinfo: %s\\n' % self.b64zip(out)\n\n\t\t# add a line for each of these commands with their outputs\n\t\tfor name, cmdline, info in cmdafter:\n\t\t\tfooter += '# platform-%s: %s | %s\\n' % (name, cmdline, self.b64zip(info))\n\t\tself.flog(footer)\n\t\treturn True\n\tdef commonPrefix(self, list):\n\t\tif len(list) < 2:\n\t\t\treturn ''\n\t\tprefix = list[0]\n\t\tfor s in list[1:]:\n\t\t\twhile s[:len(prefix)] != prefix and prefix:\n\t\t\t\tprefix = prefix[:len(prefix)-1]\n\t\t\tif not prefix:\n\t\t\t\tbreak\n\t\tif '/' in prefix and prefix[-1] != '/':\n\t\t\tprefix = prefix[0:prefix.rfind('/')+1]\n\t\treturn prefix\n\tdef dictify(self, text, format):\n\t\tout = dict()\n\t\theader = True if format == 1 else False\n\t\tdelim = ' ' if format == 1 else ':'\n\t\tfor line in text.split('\\n'):\n\t\t\tif header:\n\t\t\t\theader, out['@'] = False, line\n\t\t\t\tcontinue\n\t\t\tline = line.strip()\n\t\t\tif delim in line:\n\t\t\t\tdata = line.split(delim, 1)\n\t\t\t\tnum = re.search(r'[\\d]+', data[1])\n\t\t\t\tif format == 2 and num:\n\t\t\t\t\tout[data[0].strip()] = num.group()\n\t\t\t\telse:\n\t\t\t\t\tout[data[0].strip()] = data[1]\n\t\treturn out\n\tdef cmdinfovar(self, arg):\n\t\tif arg == 'ethdev':\n\t\t\ttry:\n\t\t\t\tcmd = [self.getExec('ip'), '-4', '-o', '-br', 'addr']\n\t\t\t\tfp = Popen(cmd, stdout=PIPE, stderr=PIPE).stdout\n\t\t\t\tinfo = ascii(fp.read()).strip()\n\t\t\t\tfp.close()\n\t\t\texcept:\n\t\t\t\treturn 'iptoolcrash'\n\t\t\tfor line in info.split('\\n'):\n\t\t\t\tif line[0] == 'e' and 'UP' in line:\n\t\t\t\t\treturn line.split()[0]\n\t\t\treturn 'nodevicefound'\n\t\treturn 'unknown'\n\tdef cmdinfo(self, begin, debug=False):\n\t\tout = []\n\t\tif begin:\n\t\t\tself.cmd1 = dict()\n\t\tfor cargs in self.infocmds:\n\t\t\tdelta, name, args = cargs[0], cargs[1], cargs[2:]\n\t\t\tfor i in range(len(args)):\n\t\t\t\tif args[i][0] == '{' and args[i][-1] == '}':\n\t\t\t\t\targs[i] = self.cmdinfovar(args[i][1:-1])\n\t\t\tcmdline, cmdpath = ' '.join(args[0:]), self.getExec(args[0])\n\t\t\tif not cmdpath or (begin and not delta):\n\t\t\t\tcontinue\n\t\t\tself.dlog('[%s]' % cmdline)\n\t\t\ttry:\n\t\t\t\tfp = Popen([cmdpath]+args[1:], stdout=PIPE, stderr=PIPE).stdout\n\t\t\t\tinfo = ascii(fp.read()).strip()\n\t\t\t\tfp.close()\n\t\t\texcept:\n\t\t\t\tcontinue\n\t\t\tif not debug and begin:\n\t\t\t\tself.cmd1[name] = self.dictify(info, delta)\n\t\t\telif not debug and delta and name in self.cmd1:\n\t\t\t\tbefore, after = self.cmd1[name], self.dictify(info, delta)\n\t\t\t\tdinfo = ('\\t%s\\n' % before['@']) if '@' in before and len(before) > 1 else ''\n\t\t\t\tprefix = self.commonPrefix(list(before.keys()))\n\t\t\t\tfor key in sorted(before):\n\t\t\t\t\tif key in after and before[key] != after[key]:\n\t\t\t\t\t\ttitle = key.replace(prefix, '')\n\t\t\t\t\t\tif delta == 2:\n\t\t\t\t\t\t\tdinfo += '\\t%s : %s -> %s\\n' % \\\n\t\t\t\t\t\t\t\t(title, before[key].strip(), after[key].strip())\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tdinfo += '%10s (start) : %s\\n%10s (after) : %s\\n' % \\\n\t\t\t\t\t\t\t\t(title, before[key], title, after[key])\n\t\t\t\tdinfo = '\\tnothing changed' if not dinfo else dinfo.rstrip()\n\t\t\t\tout.append((name, cmdline, dinfo))\n\t\t\telse:\n\t\t\t\tout.append((name, cmdline, '\\tnothing' if not info else info))\n\t\treturn out\n\tdef testVal(self, file, fmt='basic', value=''):\n\t\tif file == 'restoreall':\n\t\t\tfor f in self.cfgdef:\n\t\t\t\tif os.path.exists(f):\n\t\t\t\t\tfp = open(f, 'w')\n\t\t\t\t\tfp.write(self.cfgdef[f])\n\t\t\t\t\tfp.close()\n\t\t\tself.cfgdef = dict()\n\t\telif value and os.path.exists(file):\n\t\t\tfp = open(file, 'r+')\n\t\t\tif fmt == 'radio':\n\t\t\t\tm = re.match('.*\\[(?P<v>.*)\\].*', fp.read())\n\t\t\t\tif m:\n\t\t\t\t\tself.cfgdef[file] = m.group('v')\n\t\t\telif fmt == 'acpi':\n\t\t\t\tline = fp.read().strip().split('\\n')[-1]\n\t\t\t\tm = re.match('.* (?P<v>[0-9A-Fx]*) .*', line)\n\t\t\t\tif m:\n\t\t\t\t\tself.cfgdef[file] = m.group('v')\n\t\t\telse:\n\t\t\t\tself.cfgdef[file] = fp.read().strip()\n\t\t\tfp.write(value)\n\t\t\tfp.close()\n\tdef s0ixSupport(self):\n\t\tif not os.path.exists(self.s0ixres) or not os.path.exists(self.mempowerfile):\n\t\t\treturn False\n\t\tfp = open(sysvals.mempowerfile, 'r')\n\t\tdata = fp.read().strip()\n\t\tfp.close()\n\t\tif '[s2idle]' in data:\n\t\t\treturn True\n\t\treturn False\n\tdef haveTurbostat(self):\n\t\tif not self.tstat:\n\t\t\treturn False\n\t\tcmd = self.getExec('turbostat')\n\t\tif not cmd:\n\t\t\treturn False\n\t\tfp = Popen([cmd, '-v'], stdout=PIPE, stderr=PIPE).stderr\n\t\tout = ascii(fp.read()).strip()\n\t\tfp.close()\n\t\tif re.match('turbostat version .*', out):\n\t\t\tself.vprint(out)\n\t\t\treturn True\n\t\treturn False\n\tdef turbostat(self, s0ixready):\n\t\tcmd = self.getExec('turbostat')\n\t\trawout = keyline = valline = ''\n\t\tfullcmd = '%s -q -S echo freeze > %s' % (cmd, self.powerfile)\n\t\tfp = Popen(['sh', '-c', fullcmd], stdout=PIPE, stderr=PIPE).stderr\n\t\tfor line in fp:\n\t\t\tline = ascii(line)\n\t\t\trawout += line\n\t\t\tif keyline and valline:\n\t\t\t\tcontinue\n\t\t\tif re.match('(?i)Avg_MHz.*', line):\n\t\t\t\tkeyline = line.strip().split()\n\t\t\telif keyline:\n\t\t\t\tvalline = line.strip().split()\n\t\tfp.close()\n\t\tif not keyline or not valline or len(keyline) != len(valline):\n\t\t\terrmsg = 'unrecognized turbostat output:\\n'+rawout.strip()\n\t\t\tself.vprint(errmsg)\n\t\t\tif not self.verbose:\n\t\t\t\tpprint(errmsg)\n\t\t\treturn ''\n\t\tif self.verbose:\n\t\t\tpprint(rawout.strip())\n\t\tout = []\n\t\tfor key in keyline:\n\t\t\tidx = keyline.index(key)\n\t\t\tval = valline[idx]\n\t\t\tif key == 'SYS%LPI' and not s0ixready and re.match('^[0\\.]*$', val):\n\t\t\t\tcontinue\n\t\t\tout.append('%s=%s' % (key, val))\n\t\treturn '|'.join(out)\n\tdef netfixon(self, net='both'):\n\t\tcmd = self.getExec('netfix')\n\t\tif not cmd:\n\t\t\treturn ''\n\t\tfp = Popen([cmd, '-s', net, 'on'], stdout=PIPE, stderr=PIPE).stdout\n\t\tout = ascii(fp.read()).strip()\n\t\tfp.close()\n\t\treturn out\n\tdef wifiDetails(self, dev):\n\t\ttry:\n\t\t\tinfo = open('/sys/class/net/%s/device/uevent' % dev, 'r').read().strip()\n\t\texcept:\n\t\t\treturn dev\n\t\tvals = [dev]\n\t\tfor prop in info.split('\\n'):\n\t\t\tif prop.startswith('DRIVER=') or prop.startswith('PCI_ID='):\n\t\t\t\tvals.append(prop.split('=')[-1])\n\t\treturn ':'.join(vals)\n\tdef checkWifi(self, dev=''):\n\t\ttry:\n\t\t\tw = open('/proc/net/wireless', 'r').read().strip()\n\t\texcept:\n\t\t\treturn ''\n\t\tfor line in reversed(w.split('\\n')):\n\t\t\tm = re.match(' *(?P<dev>.*): (?P<stat>[0-9a-f]*) .*', line)\n\t\t\tif not m or (dev and dev != m.group('dev')):\n\t\t\t\tcontinue\n\t\t\treturn m.group('dev')\n\t\treturn ''\n\tdef pollWifi(self, dev, timeout=10):\n\t\tstart = time.time()\n\t\twhile (time.time() - start) < timeout:\n\t\t\tw = self.checkWifi(dev)\n\t\t\tif w:\n\t\t\t\treturn '%s reconnected %.2f' % \\\n\t\t\t\t\t(self.wifiDetails(dev), max(0, time.time() - start))\n\t\t\ttime.sleep(0.01)\n\t\treturn '%s timeout %d' % (self.wifiDetails(dev), timeout)\n\tdef errorSummary(self, errinfo, msg):\n\t\tfound = False\n\t\tfor entry in errinfo:\n\t\t\tif re.match(entry['match'], msg):\n\t\t\t\tentry['count'] += 1\n\t\t\t\tif self.hostname not in entry['urls']:\n\t\t\t\t\tentry['urls'][self.hostname] = [self.htmlfile]\n\t\t\t\telif self.htmlfile not in entry['urls'][self.hostname]:\n\t\t\t\t\tentry['urls'][self.hostname].append(self.htmlfile)\n\t\t\t\tfound = True\n\t\t\t\tbreak\n\t\tif found:\n\t\t\treturn\n\t\tarr = msg.split()\n\t\tfor j in range(len(arr)):\n\t\t\tif re.match('^[0-9,\\-\\.]*$', arr[j]):\n\t\t\t\tarr[j] = '[0-9,\\-\\.]*'\n\t\t\telse:\n\t\t\t\tarr[j] = arr[j]\\\n\t\t\t\t\t.replace('\\\\', '\\\\\\\\').replace(']', '\\]').replace('[', '\\[')\\\n\t\t\t\t\t.replace('.', '\\.').replace('+', '\\+').replace('*', '\\*')\\\n\t\t\t\t\t.replace('(', '\\(').replace(')', '\\)').replace('}', '\\}')\\\n\t\t\t\t\t.replace('{', '\\{')\n\t\tmstr = ' *'.join(arr)\n\t\tentry = {\n\t\t\t'line': msg,\n\t\t\t'match': mstr,\n\t\t\t'count': 1,\n\t\t\t'urls': {self.hostname: [self.htmlfile]}\n\t\t}\n\t\terrinfo.append(entry)\n\tdef multistat(self, start, idx, finish):\n\t\tif 'time' in self.multitest:\n\t\t\tid = '%d Duration=%dmin' % (idx+1, self.multitest['time'])\n\t\telse:\n\t\t\tid = '%d/%d' % (idx+1, self.multitest['count'])\n\t\tt = time.time()\n\t\tif 'start' not in self.multitest:\n\t\t\tself.multitest['start'] = self.multitest['last'] = t\n\t\t\tself.multitest['total'] = 0.0\n\t\t\tpprint('TEST (%s) START' % id)\n\t\t\treturn\n\t\tdt = t - self.multitest['last']\n\t\tif not start:\n\t\t\tif idx == 0 and self.multitest['delay'] > 0:\n\t\t\t\tself.multitest['total'] += self.multitest['delay']\n\t\t\tpprint('TEST (%s) COMPLETE -- Duration %.1fs' % (id, dt))\n\t\t\treturn\n\t\tself.multitest['total'] += dt\n\t\tself.multitest['last'] = t\n\t\tavg = self.multitest['total'] / idx\n\t\tif 'time' in self.multitest:\n\t\t\tleft = finish - datetime.now()\n\t\t\tleft -= timedelta(microseconds=left.microseconds)\n\t\telse:\n\t\t\tleft = timedelta(seconds=((self.multitest['count'] - idx) * int(avg)))\n\t\tpprint('TEST (%s) START - Avg Duration %.1fs, Time left %s' % \\\n\t\t\t(id, avg, str(left)))\n\tdef multiinit(self, c, d):\n\t\tsz, unit = 'count', 'm'\n\t\tif c.endswith('d') or c.endswith('h') or c.endswith('m'):\n\t\t\tsz, unit, c = 'time', c[-1], c[:-1]\n\t\tself.multitest['run'] = True\n\t\tself.multitest[sz] = getArgInt('multi: n d (exec count)', c, 1, 1000000, False)\n\t\tself.multitest['delay'] = getArgInt('multi: n d (delay between tests)', d, 0, 3600, False)\n\t\tif unit == 'd':\n\t\t\tself.multitest[sz] *= 1440\n\t\telif unit == 'h':\n\t\t\tself.multitest[sz] *= 60\n\tdef displayControl(self, cmd):\n\t\txset, ret = 'timeout 10 xset -d :0.0 {0}', 0\n\t\tif self.sudouser:\n\t\t\txset = 'sudo -u %s %s' % (self.sudouser, xset)\n\t\tif cmd == 'init':\n\t\t\tret = call(xset.format('dpms 0 0 0'), shell=True)\n\t\t\tif not ret:\n\t\t\t\tret = call(xset.format('s off'), shell=True)\n\t\telif cmd == 'reset':\n\t\t\tret = call(xset.format('s reset'), shell=True)\n\t\telif cmd in ['on', 'off', 'standby', 'suspend']:\n\t\t\tb4 = self.displayControl('stat')\n\t\t\tret = call(xset.format('dpms force %s' % cmd), shell=True)\n\t\t\tif not ret:\n\t\t\t\tcurr = self.displayControl('stat')\n\t\t\t\tself.vprint('Display Switched: %s -> %s' % (b4, curr))\n\t\t\t\tif curr != cmd:\n\t\t\t\t\tself.vprint('WARNING: Display failed to change to %s' % cmd)\n\t\t\tif ret:\n\t\t\t\tself.vprint('WARNING: Display failed to change to %s with xset' % cmd)\n\t\t\t\treturn ret\n\t\telif cmd == 'stat':\n\t\t\tfp = Popen(xset.format('q').split(' '), stdout=PIPE).stdout\n\t\t\tret = 'unknown'\n\t\t\tfor line in fp:\n\t\t\t\tm = re.match('[\\s]*Monitor is (?P<m>.*)', ascii(line))\n\t\t\t\tif(m and len(m.group('m')) >= 2):\n\t\t\t\t\tout = m.group('m').lower()\n\t\t\t\t\tret = out[3:] if out[0:2] == 'in' else out\n\t\t\t\t\tbreak\n\t\t\tfp.close()\n\t\treturn ret\n\tdef setRuntimeSuspend(self, before=True):\n\t\tif before:\n\t\t\t# runtime suspend disable or enable\n\t\t\tif self.rs > 0:\n\t\t\t\tself.rstgt, self.rsval, self.rsdir = 'on', 'auto', 'enabled'\n\t\t\telse:\n\t\t\t\tself.rstgt, self.rsval, self.rsdir = 'auto', 'on', 'disabled'\n\t\t\tpprint('CONFIGURING RUNTIME SUSPEND...')\n\t\t\tself.rslist = deviceInfo(self.rstgt)\n\t\t\tfor i in self.rslist:\n\t\t\t\tself.setVal(self.rsval, i)\n\t\t\tpprint('runtime suspend %s on all devices (%d changed)' % (self.rsdir, len(self.rslist)))\n\t\t\tpprint('waiting 5 seconds...')\n\t\t\ttime.sleep(5)\n\t\telse:\n\t\t\t# runtime suspend re-enable or re-disable\n\t\t\tfor i in self.rslist:\n\t\t\t\tself.setVal(self.rstgt, i)\n\t\t\tpprint('runtime suspend settings restored on %d devices' % len(self.rslist))\n\tdef start(self, pm):\n\t\tif self.useftrace:\n\t\t\tself.dlog('start ftrace tracing')\n\t\t\tself.fsetVal('1', 'tracing_on')\n\t\t\tif self.useprocmon:\n\t\t\t\tself.dlog('start the process monitor')\n\t\t\t\tpm.start()\n\tdef stop(self, pm):\n\t\tif self.useftrace:\n\t\t\tif self.useprocmon:\n\t\t\t\tself.dlog('stop the process monitor')\n\t\t\t\tpm.stop()\n\t\t\tself.dlog('stop ftrace tracing')\n\t\t\tself.fsetVal('0', 'tracing_on')\n\nsysvals = SystemValues()\nswitchvalues = ['enable', 'disable', 'on', 'off', 'true', 'false', '1', '0']\nswitchoff = ['disable', 'off', 'false', '0']\nsuspendmodename = {\n\t'standby': 'standby (S1)',\n\t'freeze': 'freeze (S2idle)',\n\t'mem': 'suspend (S3)',\n\t'disk': 'hibernate (S4)'\n}\n\n# Class: DevProps\n# Description:\n#\t Simple class which holds property values collected\n#\t for all the devices used in the timeline.\nclass DevProps:\n\tdef __init__(self):\n\t\tself.syspath = ''\n\t\tself.altname = ''\n\t\tself.isasync = True\n\t\tself.xtraclass = ''\n\t\tself.xtrainfo = ''\n\tdef out(self, dev):\n\t\treturn '%s,%s,%d;' % (dev, self.altname, self.isasync)\n\tdef debug(self, dev):\n\t\tpprint('%s:\\n\\taltname = %s\\n\\t  async = %s' % (dev, self.altname, self.isasync))\n\tdef altName(self, dev):\n\t\tif not self.altname or self.altname == dev:\n\t\t\treturn dev\n\t\treturn '%s [%s]' % (self.altname, dev)\n\tdef xtraClass(self):\n\t\tif self.xtraclass:\n\t\t\treturn ' '+self.xtraclass\n\t\tif not self.isasync:\n\t\t\treturn ' sync'\n\t\treturn ''\n\tdef xtraInfo(self):\n\t\tif self.xtraclass:\n\t\t\treturn ' '+self.xtraclass\n\t\tif self.isasync:\n\t\t\treturn ' (async)'\n\t\treturn ' (sync)'\n\n# Class: DeviceNode\n# Description:\n#\t A container used to create a device hierachy, with a single root node\n#\t and a tree of child nodes. Used by Data.deviceTopology()\nclass DeviceNode:\n\tdef __init__(self, nodename, nodedepth):\n\t\tself.name = nodename\n\t\tself.children = []\n\t\tself.depth = nodedepth\n\n# Class: Data\n# Description:\n#\t The primary container for suspend/resume test data. There is one for\n#\t each test run. The data is organized into a cronological hierarchy:\n#\t Data.dmesg {\n#\t\tphases {\n#\t\t\t10 sequential, non-overlapping phases of S/R\n#\t\t\tcontents: times for phase start/end, order/color data for html\n#\t\t\tdevlist {\n#\t\t\t\tdevice callback or action list for this phase\n#\t\t\t\tdevice {\n#\t\t\t\t\ta single device callback or generic action\n#\t\t\t\t\tcontents: start/stop times, pid/cpu/driver info\n#\t\t\t\t\t\tparents/children, html id for timeline/callgraph\n#\t\t\t\t\t\toptionally includes an ftrace callgraph\n#\t\t\t\t\t\toptionally includes dev/ps data\n#\t\t\t\t}\n#\t\t\t}\n#\t\t}\n#\t}\n#\nclass Data:\n\tphasedef = {\n\t\t'suspend_prepare': {'order': 0, 'color': '#CCFFCC'},\n\t\t        'suspend': {'order': 1, 'color': '#88FF88'},\n\t\t   'suspend_late': {'order': 2, 'color': '#00AA00'},\n\t\t  'suspend_noirq': {'order': 3, 'color': '#008888'},\n\t\t'suspend_machine': {'order': 4, 'color': '#0000FF'},\n\t\t 'resume_machine': {'order': 5, 'color': '#FF0000'},\n\t\t   'resume_noirq': {'order': 6, 'color': '#FF9900'},\n\t\t   'resume_early': {'order': 7, 'color': '#FFCC00'},\n\t\t         'resume': {'order': 8, 'color': '#FFFF88'},\n\t\t'resume_complete': {'order': 9, 'color': '#FFFFCC'},\n\t}\n\terrlist = {\n\t\t'HWERROR' : r'.*\\[ *Hardware Error *\\].*',\n\t\t'FWBUG'   : r'.*\\[ *Firmware Bug *\\].*',\n\t\t'TASKFAIL': r'.*Freezing .*after *.*',\n\t\t'BUG'     : r'(?i).*\\bBUG\\b.*',\n\t\t'ERROR'   : r'(?i).*\\bERROR\\b.*',\n\t\t'WARNING' : r'(?i).*\\bWARNING\\b.*',\n\t\t'FAULT'   : r'(?i).*\\bFAULT\\b.*',\n\t\t'FAIL'    : r'(?i).*\\bFAILED\\b.*',\n\t\t'INVALID' : r'(?i).*\\bINVALID\\b.*',\n\t\t'CRASH'   : r'(?i).*\\bCRASHED\\b.*',\n\t\t'TIMEOUT' : r'(?i).*\\bTIMEOUT\\b.*',\n\t\t'ABORT'   : r'(?i).*\\bABORT\\b.*',\n\t\t'IRQ'     : r'.*\\bgenirq: .*',\n\t\t'ACPI'    : r'.*\\bACPI *(?P<b>[A-Za-z]*) *Error[: ].*',\n\t\t'DISKFULL': r'.*\\bNo space left on device.*',\n\t\t'USBERR'  : r'.*usb .*device .*, error [0-9-]*',\n\t\t'ATAERR'  : r' *ata[0-9\\.]*: .*failed.*',\n\t\t'MEIERR'  : r' *mei.*: .*failed.*',\n\t\t'TPMERR'  : r'(?i) *tpm *tpm[0-9]*: .*error.*',\n\t}\n\tdef __init__(self, num):\n\t\tidchar = 'abcdefghij'\n\t\tself.start = 0.0 # test start\n\t\tself.end = 0.0   # test end\n\t\tself.hwstart = 0 # rtc test start\n\t\tself.hwend = 0   # rtc test end\n\t\tself.tSuspended = 0.0 # low-level suspend start\n\t\tself.tResumed = 0.0   # low-level resume start\n\t\tself.tKernSus = 0.0   # kernel level suspend start\n\t\tself.tKernRes = 0.0   # kernel level resume end\n\t\tself.fwValid = False  # is firmware data available\n\t\tself.fwSuspend = 0    # time spent in firmware suspend\n\t\tself.fwResume = 0     # time spent in firmware resume\n\t\tself.html_device_id = 0\n\t\tself.stamp = 0\n\t\tself.outfile = ''\n\t\tself.kerror = False\n\t\tself.wifi = dict()\n\t\tself.turbostat = 0\n\t\tself.enterfail = ''\n\t\tself.currphase = ''\n\t\tself.pstl = dict()    # process timeline\n\t\tself.testnumber = num\n\t\tself.idstr = idchar[num]\n\t\tself.dmesgtext = []   # dmesg text file in memory\n\t\tself.dmesg = dict()   # root data structure\n\t\tself.errorinfo = {'suspend':[],'resume':[]}\n\t\tself.tLow = []        # time spent in low-level suspends (standby/freeze)\n\t\tself.devpids = []\n\t\tself.devicegroups = 0\n\tdef sortedPhases(self):\n\t\treturn sorted(self.dmesg, key=lambda k:self.dmesg[k]['order'])\n\tdef initDevicegroups(self):\n\t\t# called when phases are all finished being added\n\t\tfor phase in sorted(self.dmesg.keys()):\n\t\t\tif '*' in phase:\n\t\t\t\tp = phase.split('*')\n\t\t\t\tpnew = '%s%d' % (p[0], len(p))\n\t\t\t\tself.dmesg[pnew] = self.dmesg.pop(phase)\n\t\tself.devicegroups = []\n\t\tfor phase in self.sortedPhases():\n\t\t\tself.devicegroups.append([phase])\n\tdef nextPhase(self, phase, offset):\n\t\torder = self.dmesg[phase]['order'] + offset\n\t\tfor p in self.dmesg:\n\t\t\tif self.dmesg[p]['order'] == order:\n\t\t\t\treturn p\n\t\treturn ''\n\tdef lastPhase(self, depth=1):\n\t\tplist = self.sortedPhases()\n\t\tif len(plist) < depth:\n\t\t\treturn ''\n\t\treturn plist[-1*depth]\n\tdef turbostatInfo(self):\n\t\ttp = TestProps()\n\t\tout = {'syslpi':'N/A','pkgpc10':'N/A'}\n\t\tfor line in self.dmesgtext:\n\t\t\tm = re.match(tp.tstatfmt, line)\n\t\t\tif not m:\n\t\t\t\tcontinue\n\t\t\tfor i in m.group('t').split('|'):\n\t\t\t\tif 'SYS%LPI' in i:\n\t\t\t\t\tout['syslpi'] = i.split('=')[-1]+'%'\n\t\t\t\telif 'pc10' in i:\n\t\t\t\t\tout['pkgpc10'] = i.split('=')[-1]+'%'\n\t\t\tbreak\n\t\treturn out\n\tdef extractErrorInfo(self):\n\t\tlf = self.dmesgtext\n\t\tif len(self.dmesgtext) < 1 and sysvals.dmesgfile:\n\t\t\tlf = sysvals.openlog(sysvals.dmesgfile, 'r')\n\t\ti = 0\n\t\ttp = TestProps()\n\t\tlist = []\n\t\tfor line in lf:\n\t\t\ti += 1\n\t\t\tif tp.stampInfo(line, sysvals):\n\t\t\t\tcontinue\n\t\t\tm = re.match('[ \\t]*(\\[ *)(?P<ktime>[0-9\\.]*)(\\]) (?P<msg>.*)', line)\n\t\t\tif not m:\n\t\t\t\tcontinue\n\t\t\tt = float(m.group('ktime'))\n\t\t\tif t < self.start or t > self.end:\n\t\t\t\tcontinue\n\t\t\tdir = 'suspend' if t < self.tSuspended else 'resume'\n\t\t\tmsg = m.group('msg')\n\t\t\tif re.match('capability: warning: .*', msg):\n\t\t\t\tcontinue\n\t\t\tfor err in self.errlist:\n\t\t\t\tif re.match(self.errlist[err], msg):\n\t\t\t\t\tlist.append((msg, err, dir, t, i, i))\n\t\t\t\t\tself.kerror = True\n\t\t\t\t\tbreak\n\t\ttp.msglist = []\n\t\tfor msg, type, dir, t, idx1, idx2 in list:\n\t\t\ttp.msglist.append(msg)\n\t\t\tself.errorinfo[dir].append((type, t, idx1, idx2))\n\t\tif self.kerror:\n\t\t\tsysvals.dmesglog = True\n\t\tif len(self.dmesgtext) < 1 and sysvals.dmesgfile:\n\t\t\tlf.close()\n\t\treturn tp\n\tdef setStart(self, time, msg=''):\n\t\tself.start = time\n\t\tif msg:\n\t\t\ttry:\n\t\t\t\tself.hwstart = datetime.strptime(msg, sysvals.tmstart)\n\t\t\texcept:\n\t\t\t\tself.hwstart = 0\n\tdef setEnd(self, time, msg=''):\n\t\tself.end = time\n\t\tif msg:\n\t\t\ttry:\n\t\t\t\tself.hwend = datetime.strptime(msg, sysvals.tmend)\n\t\t\texcept:\n\t\t\t\tself.hwend = 0\n\tdef isTraceEventOutsideDeviceCalls(self, pid, time):\n\t\tfor phase in self.sortedPhases():\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\tfor dev in list:\n\t\t\t\td = list[dev]\n\t\t\t\tif(d['pid'] == pid and time >= d['start'] and\n\t\t\t\t\ttime < d['end']):\n\t\t\t\t\treturn False\n\t\treturn True\n\tdef sourcePhase(self, start):\n\t\tfor phase in self.sortedPhases():\n\t\t\tif 'machine' in phase:\n\t\t\t\tcontinue\n\t\t\tpend = self.dmesg[phase]['end']\n\t\t\tif start <= pend:\n\t\t\t\treturn phase\n\t\treturn 'resume_complete' if 'resume_complete' in self.dmesg else ''\n\tdef sourceDevice(self, phaselist, start, end, pid, type):\n\t\ttgtdev = ''\n\t\tfor phase in phaselist:\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\tfor devname in list:\n\t\t\t\tdev = list[devname]\n\t\t\t\t# pid must match\n\t\t\t\tif dev['pid'] != pid:\n\t\t\t\t\tcontinue\n\t\t\t\tdevS = dev['start']\n\t\t\t\tdevE = dev['end']\n\t\t\t\tif type == 'device':\n\t\t\t\t\t# device target event is entirely inside the source boundary\n\t\t\t\t\tif(start < devS or start >= devE or end <= devS or end > devE):\n\t\t\t\t\t\tcontinue\n\t\t\t\telif type == 'thread':\n\t\t\t\t\t# thread target event will expand the source boundary\n\t\t\t\t\tif start < devS:\n\t\t\t\t\t\tdev['start'] = start\n\t\t\t\t\tif end > devE:\n\t\t\t\t\t\tdev['end'] = end\n\t\t\t\ttgtdev = dev\n\t\t\t\tbreak\n\t\treturn tgtdev\n\tdef addDeviceFunctionCall(self, displayname, kprobename, proc, pid, start, end, cdata, rdata):\n\t\t# try to place the call in a device\n\t\tphases = self.sortedPhases()\n\t\ttgtdev = self.sourceDevice(phases, start, end, pid, 'device')\n\t\t# calls with device pids that occur outside device bounds are dropped\n\t\t# TODO: include these somehow\n\t\tif not tgtdev and pid in self.devpids:\n\t\t\treturn False\n\t\t# try to place the call in a thread\n\t\tif not tgtdev:\n\t\t\ttgtdev = self.sourceDevice(phases, start, end, pid, 'thread')\n\t\t# create new thread blocks, expand as new calls are found\n\t\tif not tgtdev:\n\t\t\tif proc == '<...>':\n\t\t\t\tthreadname = 'kthread-%d' % (pid)\n\t\t\telse:\n\t\t\t\tthreadname = '%s-%d' % (proc, pid)\n\t\t\ttgtphase = self.sourcePhase(start)\n\t\t\tif not tgtphase:\n\t\t\t\treturn False\n\t\t\tself.newAction(tgtphase, threadname, pid, '', start, end, '', ' kth', '')\n\t\t\treturn self.addDeviceFunctionCall(displayname, kprobename, proc, pid, start, end, cdata, rdata)\n\t\t# this should not happen\n\t\tif not tgtdev:\n\t\t\tsysvals.vprint('[%f - %f] %s-%d %s %s %s' % \\\n\t\t\t\t(start, end, proc, pid, kprobename, cdata, rdata))\n\t\t\treturn False\n\t\t# place the call data inside the src element of the tgtdev\n\t\tif('src' not in tgtdev):\n\t\t\ttgtdev['src'] = []\n\t\tdtf = sysvals.dev_tracefuncs\n\t\tubiquitous = False\n\t\tif kprobename in dtf and 'ub' in dtf[kprobename]:\n\t\t\tubiquitous = True\n\t\tmc = re.match('\\(.*\\) *(?P<args>.*)', cdata)\n\t\tmr = re.match('\\((?P<caller>\\S*).* arg1=(?P<ret>.*)', rdata)\n\t\tif mc and mr:\n\t\t\tc = mr.group('caller').split('+')[0]\n\t\t\ta = mc.group('args').strip()\n\t\t\tr = mr.group('ret')\n\t\t\tif len(r) > 6:\n\t\t\t\tr = ''\n\t\t\telse:\n\t\t\t\tr = 'ret=%s ' % r\n\t\t\tif ubiquitous and c in dtf and 'ub' in dtf[c]:\n\t\t\t\treturn False\n\t\telse:\n\t\t\treturn False\n\t\tcolor = sysvals.kprobeColor(kprobename)\n\t\te = DevFunction(displayname, a, c, r, start, end, ubiquitous, proc, pid, color)\n\t\ttgtdev['src'].append(e)\n\t\treturn True\n\tdef overflowDevices(self):\n\t\t# get a list of devices that extend beyond the end of this test run\n\t\tdevlist = []\n\t\tfor phase in self.sortedPhases():\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\tfor devname in list:\n\t\t\t\tdev = list[devname]\n\t\t\t\tif dev['end'] > self.end:\n\t\t\t\t\tdevlist.append(dev)\n\t\treturn devlist\n\tdef mergeOverlapDevices(self, devlist):\n\t\t# merge any devices that overlap devlist\n\t\tfor dev in devlist:\n\t\t\tdevname = dev['name']\n\t\t\tfor phase in self.sortedPhases():\n\t\t\t\tlist = self.dmesg[phase]['list']\n\t\t\t\tif devname not in list:\n\t\t\t\t\tcontinue\n\t\t\t\ttdev = list[devname]\n\t\t\t\to = min(dev['end'], tdev['end']) - max(dev['start'], tdev['start'])\n\t\t\t\tif o <= 0:\n\t\t\t\t\tcontinue\n\t\t\t\tdev['end'] = tdev['end']\n\t\t\t\tif 'src' not in dev or 'src' not in tdev:\n\t\t\t\t\tcontinue\n\t\t\t\tdev['src'] += tdev['src']\n\t\t\t\tdel list[devname]\n\tdef usurpTouchingThread(self, name, dev):\n\t\t# the caller test has priority of this thread, give it to him\n\t\tfor phase in self.sortedPhases():\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\tif name in list:\n\t\t\t\ttdev = list[name]\n\t\t\t\tif tdev['start'] - dev['end'] < 0.1:\n\t\t\t\t\tdev['end'] = tdev['end']\n\t\t\t\t\tif 'src' not in dev:\n\t\t\t\t\t\tdev['src'] = []\n\t\t\t\t\tif 'src' in tdev:\n\t\t\t\t\t\tdev['src'] += tdev['src']\n\t\t\t\t\tdel list[name]\n\t\t\t\tbreak\n\tdef stitchTouchingThreads(self, testlist):\n\t\t# merge any threads between tests that touch\n\t\tfor phase in self.sortedPhases():\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\tfor devname in list:\n\t\t\t\tdev = list[devname]\n\t\t\t\tif 'htmlclass' not in dev or 'kth' not in dev['htmlclass']:\n\t\t\t\t\tcontinue\n\t\t\t\tfor data in testlist:\n\t\t\t\t\tdata.usurpTouchingThread(devname, dev)\n\tdef optimizeDevSrc(self):\n\t\t# merge any src call loops to reduce timeline size\n\t\tfor phase in self.sortedPhases():\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\tfor dev in list:\n\t\t\t\tif 'src' not in list[dev]:\n\t\t\t\t\tcontinue\n\t\t\t\tsrc = list[dev]['src']\n\t\t\t\tp = 0\n\t\t\t\tfor e in sorted(src, key=lambda event: event.time):\n\t\t\t\t\tif not p or not e.repeat(p):\n\t\t\t\t\t\tp = e\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t# e is another iteration of p, move it into p\n\t\t\t\t\tp.end = e.end\n\t\t\t\t\tp.length = p.end - p.time\n\t\t\t\t\tp.count += 1\n\t\t\t\t\tsrc.remove(e)\n\tdef trimTimeVal(self, t, t0, dT, left):\n\t\tif left:\n\t\t\tif(t > t0):\n\t\t\t\tif(t - dT < t0):\n\t\t\t\t\treturn t0\n\t\t\t\treturn t - dT\n\t\t\telse:\n\t\t\t\treturn t\n\t\telse:\n\t\t\tif(t < t0 + dT):\n\t\t\t\tif(t > t0):\n\t\t\t\t\treturn t0 + dT\n\t\t\t\treturn t + dT\n\t\t\telse:\n\t\t\t\treturn t\n\tdef trimTime(self, t0, dT, left):\n\t\tself.tSuspended = self.trimTimeVal(self.tSuspended, t0, dT, left)\n\t\tself.tResumed = self.trimTimeVal(self.tResumed, t0, dT, left)\n\t\tself.start = self.trimTimeVal(self.start, t0, dT, left)\n\t\tself.tKernSus = self.trimTimeVal(self.tKernSus, t0, dT, left)\n\t\tself.tKernRes = self.trimTimeVal(self.tKernRes, t0, dT, left)\n\t\tself.end = self.trimTimeVal(self.end, t0, dT, left)\n\t\tfor phase in self.sortedPhases():\n\t\t\tp = self.dmesg[phase]\n\t\t\tp['start'] = self.trimTimeVal(p['start'], t0, dT, left)\n\t\t\tp['end'] = self.trimTimeVal(p['end'], t0, dT, left)\n\t\t\tlist = p['list']\n\t\t\tfor name in list:\n\t\t\t\td = list[name]\n\t\t\t\td['start'] = self.trimTimeVal(d['start'], t0, dT, left)\n\t\t\t\td['end'] = self.trimTimeVal(d['end'], t0, dT, left)\n\t\t\t\td['length'] = d['end'] - d['start']\n\t\t\t\tif('ftrace' in d):\n\t\t\t\t\tcg = d['ftrace']\n\t\t\t\t\tcg.start = self.trimTimeVal(cg.start, t0, dT, left)\n\t\t\t\t\tcg.end = self.trimTimeVal(cg.end, t0, dT, left)\n\t\t\t\t\tfor line in cg.list:\n\t\t\t\t\t\tline.time = self.trimTimeVal(line.time, t0, dT, left)\n\t\t\t\tif('src' in d):\n\t\t\t\t\tfor e in d['src']:\n\t\t\t\t\t\te.time = self.trimTimeVal(e.time, t0, dT, left)\n\t\t\t\t\t\te.end = self.trimTimeVal(e.end, t0, dT, left)\n\t\t\t\t\t\te.length = e.end - e.time\n\t\t\t\tif('cpuexec' in d):\n\t\t\t\t\tcpuexec = dict()\n\t\t\t\t\tfor e in d['cpuexec']:\n\t\t\t\t\t\tc0, cN = e\n\t\t\t\t\t\tc0 = self.trimTimeVal(c0, t0, dT, left)\n\t\t\t\t\t\tcN = self.trimTimeVal(cN, t0, dT, left)\n\t\t\t\t\t\tcpuexec[(c0, cN)] = d['cpuexec'][e]\n\t\t\t\t\td['cpuexec'] = cpuexec\n\t\tfor dir in ['suspend', 'resume']:\n\t\t\tlist = []\n\t\t\tfor e in self.errorinfo[dir]:\n\t\t\t\ttype, tm, idx1, idx2 = e\n\t\t\t\ttm = self.trimTimeVal(tm, t0, dT, left)\n\t\t\t\tlist.append((type, tm, idx1, idx2))\n\t\t\tself.errorinfo[dir] = list\n\tdef trimFreezeTime(self, tZero):\n\t\t# trim out any standby or freeze clock time\n\t\tlp = ''\n\t\tfor phase in self.sortedPhases():\n\t\t\tif 'resume_machine' in phase and 'suspend_machine' in lp:\n\t\t\t\ttS, tR = self.dmesg[lp]['end'], self.dmesg[phase]['start']\n\t\t\t\ttL = tR - tS\n\t\t\t\tif tL <= 0:\n\t\t\t\t\tcontinue\n\t\t\t\tleft = True if tR > tZero else False\n\t\t\t\tself.trimTime(tS, tL, left)\n\t\t\t\tif 'waking' in self.dmesg[lp]:\n\t\t\t\t\ttCnt = self.dmesg[lp]['waking'][0]\n\t\t\t\t\tif self.dmesg[lp]['waking'][1] >= 0.001:\n\t\t\t\t\t\ttTry = '%.0f' % (round(self.dmesg[lp]['waking'][1] * 1000))\n\t\t\t\t\telse:\n\t\t\t\t\t\ttTry = '%.3f' % (self.dmesg[lp]['waking'][1] * 1000)\n\t\t\t\t\ttext = '%.0f (%s ms waking %d times)' % (tL * 1000, tTry, tCnt)\n\t\t\t\telse:\n\t\t\t\t\ttext = '%.0f' % (tL * 1000)\n\t\t\t\tself.tLow.append(text)\n\t\t\tlp = phase\n\tdef getMemTime(self):\n\t\tif not self.hwstart or not self.hwend:\n\t\t\treturn\n\t\tstime = (self.tSuspended - self.start) * 1000000\n\t\trtime = (self.end - self.tResumed) * 1000000\n\t\thws = self.hwstart + timedelta(microseconds=stime)\n\t\thwr = self.hwend - timedelta(microseconds=rtime)\n\t\tself.tLow.append('%.0f'%((hwr - hws).total_seconds() * 1000))\n\tdef getTimeValues(self):\n\t\ts = (self.tSuspended - self.tKernSus) * 1000\n\t\tr = (self.tKernRes - self.tResumed) * 1000\n\t\treturn (max(s, 0), max(r, 0))\n\tdef setPhase(self, phase, ktime, isbegin, order=-1):\n\t\tif(isbegin):\n\t\t\t# phase start over current phase\n\t\t\tif self.currphase:\n\t\t\t\tif 'resume_machine' not in self.currphase:\n\t\t\t\t\tsysvals.vprint('WARNING: phase %s failed to end' % self.currphase)\n\t\t\t\tself.dmesg[self.currphase]['end'] = ktime\n\t\t\tphases = self.dmesg.keys()\n\t\t\tcolor = self.phasedef[phase]['color']\n\t\t\tcount = len(phases) if order < 0 else order\n\t\t\t# create unique name for every new phase\n\t\t\twhile phase in phases:\n\t\t\t\tphase += '*'\n\t\t\tself.dmesg[phase] = {'list': dict(), 'start': -1.0, 'end': -1.0,\n\t\t\t\t'row': 0, 'color': color, 'order': count}\n\t\t\tself.dmesg[phase]['start'] = ktime\n\t\t\tself.currphase = phase\n\t\telse:\n\t\t\t# phase end without a start\n\t\t\tif phase not in self.currphase:\n\t\t\t\tif self.currphase:\n\t\t\t\t\tsysvals.vprint('WARNING: %s ended instead of %s, ftrace corruption?' % (phase, self.currphase))\n\t\t\t\telse:\n\t\t\t\t\tsysvals.vprint('WARNING: %s ended without a start, ftrace corruption?' % phase)\n\t\t\t\t\treturn phase\n\t\t\tphase = self.currphase\n\t\t\tself.dmesg[phase]['end'] = ktime\n\t\t\tself.currphase = ''\n\t\treturn phase\n\tdef sortedDevices(self, phase):\n\t\tlist = self.dmesg[phase]['list']\n\t\treturn sorted(list, key=lambda k:list[k]['start'])\n\tdef fixupInitcalls(self, phase):\n\t\t# if any calls never returned, clip them at system resume end\n\t\tphaselist = self.dmesg[phase]['list']\n\t\tfor devname in phaselist:\n\t\t\tdev = phaselist[devname]\n\t\t\tif(dev['end'] < 0):\n\t\t\t\tfor p in self.sortedPhases():\n\t\t\t\t\tif self.dmesg[p]['end'] > dev['start']:\n\t\t\t\t\t\tdev['end'] = self.dmesg[p]['end']\n\t\t\t\t\t\tbreak\n\t\t\t\tsysvals.vprint('%s (%s): callback didnt return' % (devname, phase))\n\tdef deviceFilter(self, devicefilter):\n\t\tfor phase in self.sortedPhases():\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\trmlist = []\n\t\t\tfor name in list:\n\t\t\t\tkeep = False\n\t\t\t\tfor filter in devicefilter:\n\t\t\t\t\tif filter in name or \\\n\t\t\t\t\t\t('drv' in list[name] and filter in list[name]['drv']):\n\t\t\t\t\t\tkeep = True\n\t\t\t\tif not keep:\n\t\t\t\t\trmlist.append(name)\n\t\t\tfor name in rmlist:\n\t\t\t\tdel list[name]\n\tdef fixupInitcallsThatDidntReturn(self):\n\t\t# if any calls never returned, clip them at system resume end\n\t\tfor phase in self.sortedPhases():\n\t\t\tself.fixupInitcalls(phase)\n\tdef phaseOverlap(self, phases):\n\t\trmgroups = []\n\t\tnewgroup = []\n\t\tfor group in self.devicegroups:\n\t\t\tfor phase in phases:\n\t\t\t\tif phase not in group:\n\t\t\t\t\tcontinue\n\t\t\t\tfor p in group:\n\t\t\t\t\tif p not in newgroup:\n\t\t\t\t\t\tnewgroup.append(p)\n\t\t\t\tif group not in rmgroups:\n\t\t\t\t\trmgroups.append(group)\n\t\tfor group in rmgroups:\n\t\t\tself.devicegroups.remove(group)\n\t\tself.devicegroups.append(newgroup)\n\tdef newActionGlobal(self, name, start, end, pid=-1, color=''):\n\t\t# which phase is this device callback or action in\n\t\tphases = self.sortedPhases()\n\t\ttargetphase = 'none'\n\t\thtmlclass = ''\n\t\toverlap = 0.0\n\t\tmyphases = []\n\t\tfor phase in phases:\n\t\t\tpstart = self.dmesg[phase]['start']\n\t\t\tpend = self.dmesg[phase]['end']\n\t\t\t# see if the action overlaps this phase\n\t\t\to = max(0, min(end, pend) - max(start, pstart))\n\t\t\tif o > 0:\n\t\t\t\tmyphases.append(phase)\n\t\t\t# set the target phase to the one that overlaps most\n\t\t\tif o > overlap:\n\t\t\t\tif overlap > 0 and phase == 'post_resume':\n\t\t\t\t\tcontinue\n\t\t\t\ttargetphase = phase\n\t\t\t\toverlap = o\n\t\t# if no target phase was found, pin it to the edge\n\t\tif targetphase == 'none':\n\t\t\tp0start = self.dmesg[phases[0]]['start']\n\t\t\tif start <= p0start:\n\t\t\t\ttargetphase = phases[0]\n\t\t\telse:\n\t\t\t\ttargetphase = phases[-1]\n\t\tif pid == -2:\n\t\t\thtmlclass = ' bg'\n\t\telif pid == -3:\n\t\t\thtmlclass = ' ps'\n\t\tif len(myphases) > 1:\n\t\t\thtmlclass = ' bg'\n\t\t\tself.phaseOverlap(myphases)\n\t\tif targetphase in phases:\n\t\t\tnewname = self.newAction(targetphase, name, pid, '', start, end, '', htmlclass, color)\n\t\t\treturn (targetphase, newname)\n\t\treturn False\n\tdef newAction(self, phase, name, pid, parent, start, end, drv, htmlclass='', color=''):\n\t\t# new device callback for a specific phase\n\t\tself.html_device_id += 1\n\t\tdevid = '%s%d' % (self.idstr, self.html_device_id)\n\t\tlist = self.dmesg[phase]['list']\n\t\tlength = -1.0\n\t\tif(start >= 0 and end >= 0):\n\t\t\tlength = end - start\n\t\tif pid == -2 or name not in sysvals.tracefuncs.keys():\n\t\t\ti = 2\n\t\t\torigname = name\n\t\t\twhile(name in list):\n\t\t\t\tname = '%s[%d]' % (origname, i)\n\t\t\t\ti += 1\n\t\tlist[name] = {'name': name, 'start': start, 'end': end, 'pid': pid,\n\t\t\t'par': parent, 'length': length, 'row': 0, 'id': devid, 'drv': drv }\n\t\tif htmlclass:\n\t\t\tlist[name]['htmlclass'] = htmlclass\n\t\tif color:\n\t\t\tlist[name]['color'] = color\n\t\treturn name\n\tdef findDevice(self, phase, name):\n\t\tlist = self.dmesg[phase]['list']\n\t\tmydev = ''\n\t\tfor devname in sorted(list):\n\t\t\tif name == devname or re.match('^%s\\[(?P<num>[0-9]*)\\]$' % name, devname):\n\t\t\t\tmydev = devname\n\t\tif mydev:\n\t\t\treturn list[mydev]\n\t\treturn False\n\tdef deviceChildren(self, devname, phase):\n\t\tdevlist = []\n\t\tlist = self.dmesg[phase]['list']\n\t\tfor child in list:\n\t\t\tif(list[child]['par'] == devname):\n\t\t\t\tdevlist.append(child)\n\t\treturn devlist\n\tdef maxDeviceNameSize(self, phase):\n\t\tsize = 0\n\t\tfor name in self.dmesg[phase]['list']:\n\t\t\tif len(name) > size:\n\t\t\t\tsize = len(name)\n\t\treturn size\n\tdef printDetails(self):\n\t\tsysvals.vprint('Timeline Details:')\n\t\tsysvals.vprint('          test start: %f' % self.start)\n\t\tsysvals.vprint('kernel suspend start: %f' % self.tKernSus)\n\t\ttS = tR = False\n\t\tfor phase in self.sortedPhases():\n\t\t\tdevlist = self.dmesg[phase]['list']\n\t\t\tdc, ps, pe = len(devlist), self.dmesg[phase]['start'], self.dmesg[phase]['end']\n\t\t\tif not tS and ps >= self.tSuspended:\n\t\t\t\tsysvals.vprint('   machine suspended: %f' % self.tSuspended)\n\t\t\t\ttS = True\n\t\t\tif not tR and ps >= self.tResumed:\n\t\t\t\tsysvals.vprint('     machine resumed: %f' % self.tResumed)\n\t\t\t\ttR = True\n\t\t\tsysvals.vprint('%20s: %f - %f (%d devices)' % (phase, ps, pe, dc))\n\t\t\tif sysvals.devdump:\n\t\t\t\tsysvals.vprint(''.join('-' for i in range(80)))\n\t\t\t\tmaxname = '%d' % self.maxDeviceNameSize(phase)\n\t\t\t\tfmt = '%3d) %'+maxname+'s - %f - %f'\n\t\t\t\tc = 1\n\t\t\t\tfor name in sorted(devlist):\n\t\t\t\t\ts = devlist[name]['start']\n\t\t\t\t\te = devlist[name]['end']\n\t\t\t\t\tsysvals.vprint(fmt % (c, name, s, e))\n\t\t\t\t\tc += 1\n\t\t\t\tsysvals.vprint(''.join('-' for i in range(80)))\n\t\tsysvals.vprint('   kernel resume end: %f' % self.tKernRes)\n\t\tsysvals.vprint('            test end: %f' % self.end)\n\tdef deviceChildrenAllPhases(self, devname):\n\t\tdevlist = []\n\t\tfor phase in self.sortedPhases():\n\t\t\tlist = self.deviceChildren(devname, phase)\n\t\t\tfor dev in sorted(list):\n\t\t\t\tif dev not in devlist:\n\t\t\t\t\tdevlist.append(dev)\n\t\treturn devlist\n\tdef masterTopology(self, name, list, depth):\n\t\tnode = DeviceNode(name, depth)\n\t\tfor cname in list:\n\t\t\t# avoid recursions\n\t\t\tif name == cname:\n\t\t\t\tcontinue\n\t\t\tclist = self.deviceChildrenAllPhases(cname)\n\t\t\tcnode = self.masterTopology(cname, clist, depth+1)\n\t\t\tnode.children.append(cnode)\n\t\treturn node\n\tdef printTopology(self, node):\n\t\thtml = ''\n\t\tif node.name:\n\t\t\tinfo = ''\n\t\t\tdrv = ''\n\t\t\tfor phase in self.sortedPhases():\n\t\t\t\tlist = self.dmesg[phase]['list']\n\t\t\t\tif node.name in list:\n\t\t\t\t\ts = list[node.name]['start']\n\t\t\t\t\te = list[node.name]['end']\n\t\t\t\t\tif list[node.name]['drv']:\n\t\t\t\t\t\tdrv = ' {'+list[node.name]['drv']+'}'\n\t\t\t\t\tinfo += ('<li>%s: %.3fms</li>' % (phase, (e-s)*1000))\n\t\t\thtml += '<li><b>'+node.name+drv+'</b>'\n\t\t\tif info:\n\t\t\t\thtml += '<ul>'+info+'</ul>'\n\t\t\thtml += '</li>'\n\t\tif len(node.children) > 0:\n\t\t\thtml += '<ul>'\n\t\t\tfor cnode in node.children:\n\t\t\t\thtml += self.printTopology(cnode)\n\t\t\thtml += '</ul>'\n\t\treturn html\n\tdef rootDeviceList(self):\n\t\t# list of devices graphed\n\t\treal = []\n\t\tfor phase in self.sortedPhases():\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\tfor dev in sorted(list):\n\t\t\t\tif list[dev]['pid'] >= 0 and dev not in real:\n\t\t\t\t\treal.append(dev)\n\t\t# list of top-most root devices\n\t\trootlist = []\n\t\tfor phase in self.sortedPhases():\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\tfor dev in sorted(list):\n\t\t\t\tpdev = list[dev]['par']\n\t\t\t\tpid = list[dev]['pid']\n\t\t\t\tif(pid < 0 or re.match('[0-9]*-[0-9]*\\.[0-9]*[\\.0-9]*\\:[\\.0-9]*$', pdev)):\n\t\t\t\t\tcontinue\n\t\t\t\tif pdev and pdev not in real and pdev not in rootlist:\n\t\t\t\t\trootlist.append(pdev)\n\t\treturn rootlist\n\tdef deviceTopology(self):\n\t\trootlist = self.rootDeviceList()\n\t\tmaster = self.masterTopology('', rootlist, 0)\n\t\treturn self.printTopology(master)\n\tdef selectTimelineDevices(self, widfmt, tTotal, mindevlen):\n\t\t# only select devices that will actually show up in html\n\t\tself.tdevlist = dict()\n\t\tfor phase in self.dmesg:\n\t\t\tdevlist = []\n\t\t\tlist = self.dmesg[phase]['list']\n\t\t\tfor dev in list:\n\t\t\t\tlength = (list[dev]['end'] - list[dev]['start']) * 1000\n\t\t\t\twidth = widfmt % (((list[dev]['end']-list[dev]['start'])*100)/tTotal)\n\t\t\t\tif length >= mindevlen:\n\t\t\t\t\tdevlist.append(dev)\n\t\t\tself.tdevlist[phase] = devlist\n\tdef addHorizontalDivider(self, devname, devend):\n\t\tphase = 'suspend_prepare'\n\t\tself.newAction(phase, devname, -2, '', \\\n\t\t\tself.start, devend, '', ' sec', '')\n\t\tif phase not in self.tdevlist:\n\t\t\tself.tdevlist[phase] = []\n\t\tself.tdevlist[phase].append(devname)\n\t\td = DevItem(0, phase, self.dmesg[phase]['list'][devname])\n\t\treturn d\n\tdef addProcessUsageEvent(self, name, times):\n\t\t# get the start and end times for this process\n\t\tcpuexec = dict()\n\t\ttlast = start = end = -1\n\t\tfor t in sorted(times):\n\t\t\tif tlast < 0:\n\t\t\t\ttlast = t\n\t\t\t\tcontinue\n\t\t\tif name in self.pstl[t] and self.pstl[t][name] > 0:\n\t\t\t\tif start < 0:\n\t\t\t\t\tstart = tlast\n\t\t\t\tend, key = t, (tlast, t)\n\t\t\t\tmaxj = (t - tlast) * 1024.0\n\t\t\t\tcpuexec[key] = min(1.0, float(self.pstl[t][name]) / maxj)\n\t\t\ttlast = t\n\t\tif start < 0 or end < 0:\n\t\t\treturn\n\t\t# add a new action for this process and get the object\n\t\tout = self.newActionGlobal(name, start, end, -3)\n\t\tif out:\n\t\t\tphase, devname = out\n\t\t\tdev = self.dmesg[phase]['list'][devname]\n\t\t\tdev['cpuexec'] = cpuexec\n\tdef createProcessUsageEvents(self):\n\t\t# get an array of process names and times\n\t\tproclist = {'sus': dict(), 'res': dict()}\n\t\ttdata = {'sus': [], 'res': []}\n\t\tfor t in sorted(self.pstl):\n\t\t\tdir = 'sus' if t < self.tSuspended else 'res'\n\t\t\tfor ps in sorted(self.pstl[t]):\n\t\t\t\tif ps not in proclist[dir]:\n\t\t\t\t\tproclist[dir][ps] = 0\n\t\t\ttdata[dir].append(t)\n\t\t# process the events for suspend and resume\n\t\tif len(proclist['sus']) > 0 or len(proclist['res']) > 0:\n\t\t\tsysvals.vprint('Process Execution:')\n\t\tfor dir in ['sus', 'res']:\n\t\t\tfor ps in sorted(proclist[dir]):\n\t\t\t\tself.addProcessUsageEvent(ps, tdata[dir])\n\tdef handleEndMarker(self, time, msg=''):\n\t\tdm = self.dmesg\n\t\tself.setEnd(time, msg)\n\t\tself.initDevicegroups()\n\t\t# give suspend_prepare an end if needed\n\t\tif 'suspend_prepare' in dm and dm['suspend_prepare']['end'] < 0:\n\t\t\tdm['suspend_prepare']['end'] = time\n\t\t# assume resume machine ends at next phase start\n\t\tif 'resume_machine' in dm and dm['resume_machine']['end'] < 0:\n\t\t\tnp = self.nextPhase('resume_machine', 1)\n\t\t\tif np:\n\t\t\t\tdm['resume_machine']['end'] = dm[np]['start']\n\t\t# if kernel resume end not found, assume its the end marker\n\t\tif self.tKernRes == 0.0:\n\t\t\tself.tKernRes = time\n\t\t# if kernel suspend start not found, assume its the end marker\n\t\tif self.tKernSus == 0.0:\n\t\t\tself.tKernSus = time\n\t\t# set resume complete to end at end marker\n\t\tif 'resume_complete' in dm:\n\t\t\tdm['resume_complete']['end'] = time\n\tdef initcall_debug_call(self, line, quick=False):\n\t\tm = re.match('.*(\\[ *)(?P<t>[0-9\\.]*)(\\]) .* (?P<f>.*)\\: '+\\\n\t\t\t'PM: *calling .* @ (?P<n>.*), parent: (?P<p>.*)', line)\n\t\tif not m:\n\t\t\tm = re.match('.*(\\[ *)(?P<t>[0-9\\.]*)(\\]) .* (?P<f>.*)\\: '+\\\n\t\t\t\t'calling .* @ (?P<n>.*), parent: (?P<p>.*)', line)\n\t\tif not m:\n\t\t\tm = re.match('.*(\\[ *)(?P<t>[0-9\\.]*)(\\]) calling  '+\\\n\t\t\t\t'(?P<f>.*)\\+ @ (?P<n>.*), parent: (?P<p>.*)', line)\n\t\tif m:\n\t\t\treturn True if quick else m.group('t', 'f', 'n', 'p')\n\t\treturn False if quick else ('', '', '', '')\n\tdef initcall_debug_return(self, line, quick=False):\n\t\tm = re.match('.*(\\[ *)(?P<t>[0-9\\.]*)(\\]) .* (?P<f>.*)\\: PM: '+\\\n\t\t\t'.* returned (?P<r>[0-9]*) after (?P<dt>[0-9]*) usecs', line)\n\t\tif not m:\n\t\t\tm = re.match('.*(\\[ *)(?P<t>[0-9\\.]*)(\\]) .* (?P<f>.*)\\: '+\\\n\t\t\t\t'.* returned (?P<r>[0-9]*) after (?P<dt>[0-9]*) usecs', line)\n\t\tif not m:\n\t\t\tm = re.match('.*(\\[ *)(?P<t>[0-9\\.]*)(\\]) call '+\\\n\t\t\t\t'(?P<f>.*)\\+ returned .* after (?P<dt>.*) usecs', line)\n\t\tif m:\n\t\t\treturn True if quick else m.group('t', 'f', 'dt')\n\t\treturn False if quick else ('', '', '')\n\tdef debugPrint(self):\n\t\tfor p in self.sortedPhases():\n\t\t\tlist = self.dmesg[p]['list']\n\t\t\tfor devname in sorted(list):\n\t\t\t\tdev = list[devname]\n\t\t\t\tif 'ftrace' in dev:\n\t\t\t\t\tdev['ftrace'].debugPrint(' [%s]' % devname)\n\n# Class: DevFunction\n# Description:\n#\t A container for kprobe function data we want in the dev timeline\nclass DevFunction:\n\tdef __init__(self, name, args, caller, ret, start, end, u, proc, pid, color):\n\t\tself.row = 0\n\t\tself.count = 1\n\t\tself.name = name\n\t\tself.args = args\n\t\tself.caller = caller\n\t\tself.ret = ret\n\t\tself.time = start\n\t\tself.length = end - start\n\t\tself.end = end\n\t\tself.ubiquitous = u\n\t\tself.proc = proc\n\t\tself.pid = pid\n\t\tself.color = color\n\tdef title(self):\n\t\tcnt = ''\n\t\tif self.count > 1:\n\t\t\tcnt = '(x%d)' % self.count\n\t\tl = '%0.3fms' % (self.length * 1000)\n\t\tif self.ubiquitous:\n\t\t\ttitle = '%s(%s)%s <- %s, %s(%s)' % \\\n\t\t\t\t(self.name, self.args, cnt, self.caller, self.ret, l)\n\t\telse:\n\t\t\ttitle = '%s(%s) %s%s(%s)' % (self.name, self.args, self.ret, cnt, l)\n\t\treturn title.replace('\"', '')\n\tdef text(self):\n\t\tif self.count > 1:\n\t\t\ttext = '%s(x%d)' % (self.name, self.count)\n\t\telse:\n\t\t\ttext = self.name\n\t\treturn text\n\tdef repeat(self, tgt):\n\t\t# is the tgt call just a repeat of this call (e.g. are we in a loop)\n\t\tdt = self.time - tgt.end\n\t\t# only combine calls if -all- attributes are identical\n\t\tif tgt.caller == self.caller and \\\n\t\t\ttgt.name == self.name and tgt.args == self.args and \\\n\t\t\ttgt.proc == self.proc and tgt.pid == self.pid and \\\n\t\t\ttgt.ret == self.ret and dt >= 0 and \\\n\t\t\tdt <= sysvals.callloopmaxgap and \\\n\t\t\tself.length < sysvals.callloopmaxlen:\n\t\t\treturn True\n\t\treturn False\n\n# Class: FTraceLine\n# Description:\n#\t A container for a single line of ftrace data. There are six basic types:\n#\t\t callgraph line:\n#\t\t\t  call: \"  dpm_run_callback() {\"\n#\t\t\treturn: \"  }\"\n#\t\t\t  leaf: \" dpm_run_callback();\"\n#\t\t trace event:\n#\t\t\t tracing_mark_write: SUSPEND START or RESUME COMPLETE\n#\t\t\t suspend_resume: phase or custom exec block data\n#\t\t\t device_pm_callback: device callback info\nclass FTraceLine:\n\tdef __init__(self, t, m='', d=''):\n\t\tself.length = 0.0\n\t\tself.fcall = False\n\t\tself.freturn = False\n\t\tself.fevent = False\n\t\tself.fkprobe = False\n\t\tself.depth = 0\n\t\tself.name = ''\n\t\tself.type = ''\n\t\tself.time = float(t)\n\t\tif not m and not d:\n\t\t\treturn\n\t\t# is this a trace event\n\t\tif(d == 'traceevent' or re.match('^ *\\/\\* *(?P<msg>.*) \\*\\/ *$', m)):\n\t\t\tif(d == 'traceevent'):\n\t\t\t\t# nop format trace event\n\t\t\t\tmsg = m\n\t\t\telse:\n\t\t\t\t# function_graph format trace event\n\t\t\t\tem = re.match('^ *\\/\\* *(?P<msg>.*) \\*\\/ *$', m)\n\t\t\t\tmsg = em.group('msg')\n\n\t\t\temm = re.match('^(?P<call>.*?): (?P<msg>.*)', msg)\n\t\t\tif(emm):\n\t\t\t\tself.name = emm.group('msg')\n\t\t\t\tself.type = emm.group('call')\n\t\t\telse:\n\t\t\t\tself.name = msg\n\t\t\tkm = re.match('^(?P<n>.*)_cal$', self.type)\n\t\t\tif km:\n\t\t\t\tself.fcall = True\n\t\t\t\tself.fkprobe = True\n\t\t\t\tself.type = km.group('n')\n\t\t\t\treturn\n\t\t\tkm = re.match('^(?P<n>.*)_ret$', self.type)\n\t\t\tif km:\n\t\t\t\tself.freturn = True\n\t\t\t\tself.fkprobe = True\n\t\t\t\tself.type = km.group('n')\n\t\t\t\treturn\n\t\t\tself.fevent = True\n\t\t\treturn\n\t\t# convert the duration to seconds\n\t\tif(d):\n\t\t\tself.length = float(d)/1000000\n\t\t# the indentation determines the depth\n\t\tmatch = re.match('^(?P<d> *)(?P<o>.*)$', m)\n\t\tif(not match):\n\t\t\treturn\n\t\tself.depth = self.getDepth(match.group('d'))\n\t\tm = match.group('o')\n\t\t# function return\n\t\tif(m[0] == '}'):\n\t\t\tself.freturn = True\n\t\t\tif(len(m) > 1):\n\t\t\t\t# includes comment with function name\n\t\t\t\tmatch = re.match('^} *\\/\\* *(?P<n>.*) *\\*\\/$', m)\n\t\t\t\tif(match):\n\t\t\t\t\tself.name = match.group('n').strip()\n\t\t# function call\n\t\telse:\n\t\t\tself.fcall = True\n\t\t\t# function call with children\n\t\t\tif(m[-1] == '{'):\n\t\t\t\tmatch = re.match('^(?P<n>.*) *\\(.*', m)\n\t\t\t\tif(match):\n\t\t\t\t\tself.name = match.group('n').strip()\n\t\t\t# function call with no children (leaf)\n\t\t\telif(m[-1] == ';'):\n\t\t\t\tself.freturn = True\n\t\t\t\tmatch = re.match('^(?P<n>.*) *\\(.*', m)\n\t\t\t\tif(match):\n\t\t\t\t\tself.name = match.group('n').strip()\n\t\t\t# something else (possibly a trace marker)\n\t\t\telse:\n\t\t\t\tself.name = m\n\tdef isCall(self):\n\t\treturn self.fcall and not self.freturn\n\tdef isReturn(self):\n\t\treturn self.freturn and not self.fcall\n\tdef isLeaf(self):\n\t\treturn self.fcall and self.freturn\n\tdef getDepth(self, str):\n\t\treturn len(str)/2\n\tdef debugPrint(self, info=''):\n\t\tif self.isLeaf():\n\t\t\tpprint(' -- %12.6f (depth=%02d): %s(); (%.3f us) %s' % (self.time, \\\n\t\t\t\tself.depth, self.name, self.length*1000000, info))\n\t\telif self.freturn:\n\t\t\tpprint(' -- %12.6f (depth=%02d): %s} (%.3f us) %s' % (self.time, \\\n\t\t\t\tself.depth, self.name, self.length*1000000, info))\n\t\telse:\n\t\t\tpprint(' -- %12.6f (depth=%02d): %s() { (%.3f us) %s' % (self.time, \\\n\t\t\t\tself.depth, self.name, self.length*1000000, info))\n\tdef startMarker(self):\n\t\t# Is this the starting line of a suspend?\n\t\tif not self.fevent:\n\t\t\treturn False\n\t\tif sysvals.usetracemarkers:\n\t\t\tif(self.name.startswith('SUSPEND START')):\n\t\t\t\treturn True\n\t\t\treturn False\n\t\telse:\n\t\t\tif(self.type == 'suspend_resume' and\n\t\t\t\tre.match('suspend_enter\\[.*\\] begin', self.name)):\n\t\t\t\treturn True\n\t\t\treturn False\n\tdef endMarker(self):\n\t\t# Is this the ending line of a resume?\n\t\tif not self.fevent:\n\t\t\treturn False\n\t\tif sysvals.usetracemarkers:\n\t\t\tif(self.name.startswith('RESUME COMPLETE')):\n\t\t\t\treturn True\n\t\t\treturn False\n\t\telse:\n\t\t\tif(self.type == 'suspend_resume' and\n\t\t\t\tre.match('thaw_processes\\[.*\\] end', self.name)):\n\t\t\t\treturn True\n\t\t\treturn False\n\n# Class: FTraceCallGraph\n# Description:\n#\t A container for the ftrace callgraph of a single recursive function.\n#\t This can be a dpm_run_callback, dpm_prepare, or dpm_complete callgraph\n#\t Each instance is tied to a single device in a single phase, and is\n#\t comprised of an ordered list of FTraceLine objects\nclass FTraceCallGraph:\n\tvfname = 'missing_function_name'\n\tdef __init__(self, pid, sv):\n\t\tself.id = ''\n\t\tself.invalid = False\n\t\tself.name = ''\n\t\tself.partial = False\n\t\tself.ignore = False\n\t\tself.start = -1.0\n\t\tself.end = -1.0\n\t\tself.list = []\n\t\tself.depth = 0\n\t\tself.pid = pid\n\t\tself.sv = sv\n\tdef addLine(self, line):\n\t\t# if this is already invalid, just leave\n\t\tif(self.invalid):\n\t\t\tif(line.depth == 0 and line.freturn):\n\t\t\t\treturn 1\n\t\t\treturn 0\n\t\t# invalidate on bad depth\n\t\tif(self.depth < 0):\n\t\t\tself.invalidate(line)\n\t\t\treturn 0\n\t\t# ignore data til we return to the current depth\n\t\tif self.ignore:\n\t\t\tif line.depth > self.depth:\n\t\t\t\treturn 0\n\t\t\telse:\n\t\t\t\tself.list[-1].freturn = True\n\t\t\t\tself.list[-1].length = line.time - self.list[-1].time\n\t\t\t\tself.ignore = False\n\t\t\t\t# if this is a return at self.depth, no more work is needed\n\t\t\t\tif line.depth == self.depth and line.isReturn():\n\t\t\t\t\tif line.depth == 0:\n\t\t\t\t\t\tself.end = line.time\n\t\t\t\t\t\treturn 1\n\t\t\t\t\treturn 0\n\t\t# compare current depth with this lines pre-call depth\n\t\tprelinedep = line.depth\n\t\tif line.isReturn():\n\t\t\tprelinedep += 1\n\t\tlast = 0\n\t\tlasttime = line.time\n\t\tif len(self.list) > 0:\n\t\t\tlast = self.list[-1]\n\t\t\tlasttime = last.time\n\t\t\tif last.isLeaf():\n\t\t\t\tlasttime += last.length\n\t\t# handle low misalignments by inserting returns\n\t\tmismatch = prelinedep - self.depth\n\t\twarning = self.sv.verbose and abs(mismatch) > 1\n\t\tinfo = []\n\t\tif mismatch < 0:\n\t\t\tidx = 0\n\t\t\t# add return calls to get the depth down\n\t\t\twhile prelinedep < self.depth:\n\t\t\t\tself.depth -= 1\n\t\t\t\tif idx == 0 and last and last.isCall():\n\t\t\t\t\t# special case, turn last call into a leaf\n\t\t\t\t\tlast.depth = self.depth\n\t\t\t\t\tlast.freturn = True\n\t\t\t\t\tlast.length = line.time - last.time\n\t\t\t\t\tif warning:\n\t\t\t\t\t\tinfo.append(('[make leaf]', last))\n\t\t\t\telse:\n\t\t\t\t\tvline = FTraceLine(lasttime)\n\t\t\t\t\tvline.depth = self.depth\n\t\t\t\t\tvline.name = self.vfname\n\t\t\t\t\tvline.freturn = True\n\t\t\t\t\tself.list.append(vline)\n\t\t\t\t\tif warning:\n\t\t\t\t\t\tif idx == 0:\n\t\t\t\t\t\t\tinfo.append(('', last))\n\t\t\t\t\t\tinfo.append(('[add return]', vline))\n\t\t\t\tidx += 1\n\t\t\tif warning:\n\t\t\t\tinfo.append(('', line))\n\t\t# handle high misalignments by inserting calls\n\t\telif mismatch > 0:\n\t\t\tidx = 0\n\t\t\tif warning:\n\t\t\t\tinfo.append(('', last))\n\t\t\t# add calls to get the depth up\n\t\t\twhile prelinedep > self.depth:\n\t\t\t\tif idx == 0 and line.isReturn():\n\t\t\t\t\t# special case, turn this return into a leaf\n\t\t\t\t\tline.fcall = True\n\t\t\t\t\tprelinedep -= 1\n\t\t\t\t\tif warning:\n\t\t\t\t\t\tinfo.append(('[make leaf]', line))\n\t\t\t\telse:\n\t\t\t\t\tvline = FTraceLine(lasttime)\n\t\t\t\t\tvline.depth = self.depth\n\t\t\t\t\tvline.name = self.vfname\n\t\t\t\t\tvline.fcall = True\n\t\t\t\t\tself.list.append(vline)\n\t\t\t\t\tself.depth += 1\n\t\t\t\t\tif not last:\n\t\t\t\t\t\tself.start = vline.time\n\t\t\t\t\tif warning:\n\t\t\t\t\t\tinfo.append(('[add call]', vline))\n\t\t\t\tidx += 1\n\t\t\tif warning and ('[make leaf]', line) not in info:\n\t\t\t\tinfo.append(('', line))\n\t\tif warning:\n\t\t\tpprint('WARNING: ftrace data missing, corrections made:')\n\t\t\tfor i in info:\n\t\t\t\tt, obj = i\n\t\t\t\tif obj:\n\t\t\t\t\tobj.debugPrint(t)\n\t\t# process the call and set the new depth\n\t\tskipadd = False\n\t\tmd = self.sv.max_graph_depth\n\t\tif line.isCall():\n\t\t\t# ignore blacklisted/overdepth funcs\n\t\t\tif (md and self.depth >= md - 1) or (line.name in self.sv.cgblacklist):\n\t\t\t\tself.ignore = True\n\t\t\telse:\n\t\t\t\tself.depth += 1\n\t\telif line.isReturn():\n\t\t\tself.depth -= 1\n\t\t\t# remove blacklisted/overdepth/empty funcs that slipped through\n\t\t\tif (last and last.isCall() and last.depth == line.depth) or \\\n\t\t\t\t(md and last and last.depth >= md) or \\\n\t\t\t\t(line.name in self.sv.cgblacklist):\n\t\t\t\twhile len(self.list) > 0 and self.list[-1].depth > line.depth:\n\t\t\t\t\tself.list.pop(-1)\n\t\t\t\tif len(self.list) == 0:\n\t\t\t\t\tself.invalid = True\n\t\t\t\t\treturn 1\n\t\t\t\tself.list[-1].freturn = True\n\t\t\t\tself.list[-1].length = line.time - self.list[-1].time\n\t\t\t\tself.list[-1].name = line.name\n\t\t\t\tskipadd = True\n\t\tif len(self.list) < 1:\n\t\t\tself.start = line.time\n\t\t# check for a mismatch that returned all the way to callgraph end\n\t\tres = 1\n\t\tif mismatch < 0 and self.list[-1].depth == 0 and self.list[-1].freturn:\n\t\t\tline = self.list[-1]\n\t\t\tskipadd = True\n\t\t\tres = -1\n\t\tif not skipadd:\n\t\t\tself.list.append(line)\n\t\tif(line.depth == 0 and line.freturn):\n\t\t\tif(self.start < 0):\n\t\t\t\tself.start = line.time\n\t\t\tself.end = line.time\n\t\t\tif line.fcall:\n\t\t\t\tself.end += line.length\n\t\t\tif self.list[0].name == self.vfname:\n\t\t\t\tself.invalid = True\n\t\t\tif res == -1:\n\t\t\t\tself.partial = True\n\t\t\treturn res\n\t\treturn 0\n\tdef invalidate(self, line):\n\t\tif(len(self.list) > 0):\n\t\t\tfirst = self.list[0]\n\t\t\tself.list = []\n\t\t\tself.list.append(first)\n\t\tself.invalid = True\n\t\tid = 'task %s' % (self.pid)\n\t\twindow = '(%f - %f)' % (self.start, line.time)\n\t\tif(self.depth < 0):\n\t\t\tpprint('Data misalignment for '+id+\\\n\t\t\t\t' (buffer overflow), ignoring this callback')\n\t\telse:\n\t\t\tpprint('Too much data for '+id+\\\n\t\t\t\t' '+window+', ignoring this callback')\n\tdef slice(self, dev):\n\t\tminicg = FTraceCallGraph(dev['pid'], self.sv)\n\t\tminicg.name = self.name\n\t\tmydepth = -1\n\t\tgood = False\n\t\tfor l in self.list:\n\t\t\tif(l.time < dev['start'] or l.time > dev['end']):\n\t\t\t\tcontinue\n\t\t\tif mydepth < 0:\n\t\t\t\tif l.name == 'mutex_lock' and l.freturn:\n\t\t\t\t\tmydepth = l.depth\n\t\t\t\tcontinue\n\t\t\telif l.depth == mydepth and l.name == 'mutex_unlock' and l.fcall:\n\t\t\t\tgood = True\n\t\t\t\tbreak\n\t\t\tl.depth -= mydepth\n\t\t\tminicg.addLine(l)\n\t\tif not good or len(minicg.list) < 1:\n\t\t\treturn 0\n\t\treturn minicg\n\tdef repair(self, enddepth):\n\t\t# bring the depth back to 0 with additional returns\n\t\tfixed = False\n\t\tlast = self.list[-1]\n\t\tfor i in reversed(range(enddepth)):\n\t\t\tt = FTraceLine(last.time)\n\t\t\tt.depth = i\n\t\t\tt.freturn = True\n\t\t\tfixed = self.addLine(t)\n\t\t\tif fixed != 0:\n\t\t\t\tself.end = last.time\n\t\t\t\treturn True\n\t\treturn False\n\tdef postProcess(self):\n\t\tif len(self.list) > 0:\n\t\t\tself.name = self.list[0].name\n\t\tstack = dict()\n\t\tcnt = 0\n\t\tlast = 0\n\t\tfor l in self.list:\n\t\t\t# ftrace bug: reported duration is not reliable\n\t\t\t# check each leaf and clip it at max possible length\n\t\t\tif last and last.isLeaf():\n\t\t\t\tif last.length > l.time - last.time:\n\t\t\t\t\tlast.length = l.time - last.time\n\t\t\tif l.isCall():\n\t\t\t\tstack[l.depth] = l\n\t\t\t\tcnt += 1\n\t\t\telif l.isReturn():\n\t\t\t\tif(l.depth not in stack):\n\t\t\t\t\tif self.sv.verbose:\n\t\t\t\t\t\tpprint('Post Process Error: Depth missing')\n\t\t\t\t\t\tl.debugPrint()\n\t\t\t\t\treturn False\n\t\t\t\t# calculate call length from call/return lines\n\t\t\t\tcl = stack[l.depth]\n\t\t\t\tcl.length = l.time - cl.time\n\t\t\t\tif cl.name == self.vfname:\n\t\t\t\t\tcl.name = l.name\n\t\t\t\tstack.pop(l.depth)\n\t\t\t\tl.length = 0\n\t\t\t\tcnt -= 1\n\t\t\tlast = l\n\t\tif(cnt == 0):\n\t\t\t# trace caught the whole call tree\n\t\t\treturn True\n\t\telif(cnt < 0):\n\t\t\tif self.sv.verbose:\n\t\t\t\tpprint('Post Process Error: Depth is less than 0')\n\t\t\treturn False\n\t\t# trace ended before call tree finished\n\t\treturn self.repair(cnt)\n\tdef deviceMatch(self, pid, data):\n\t\tfound = ''\n\t\t# add the callgraph data to the device hierarchy\n\t\tborderphase = {\n\t\t\t'dpm_prepare': 'suspend_prepare',\n\t\t\t'dpm_complete': 'resume_complete'\n\t\t}\n\t\tif(self.name in borderphase):\n\t\t\tp = borderphase[self.name]\n\t\t\tlist = data.dmesg[p]['list']\n\t\t\tfor devname in list:\n\t\t\t\tdev = list[devname]\n\t\t\t\tif(pid == dev['pid'] and\n\t\t\t\t\tself.start <= dev['start'] and\n\t\t\t\t\tself.end >= dev['end']):\n\t\t\t\t\tcg = self.slice(dev)\n\t\t\t\t\tif cg:\n\t\t\t\t\t\tdev['ftrace'] = cg\n\t\t\t\t\tfound = devname\n\t\t\treturn found\n\t\tfor p in data.sortedPhases():\n\t\t\tif(data.dmesg[p]['start'] <= self.start and\n\t\t\t\tself.start <= data.dmesg[p]['end']):\n\t\t\t\tlist = data.dmesg[p]['list']\n\t\t\t\tfor devname in sorted(list, key=lambda k:list[k]['start']):\n\t\t\t\t\tdev = list[devname]\n\t\t\t\t\tif(pid == dev['pid'] and\n\t\t\t\t\t\tself.start <= dev['start'] and\n\t\t\t\t\t\tself.end >= dev['end']):\n\t\t\t\t\t\tdev['ftrace'] = self\n\t\t\t\t\t\tfound = devname\n\t\t\t\t\t\tbreak\n\t\t\t\tbreak\n\t\treturn found\n\tdef newActionFromFunction(self, data):\n\t\tname = self.name\n\t\tif name in ['dpm_run_callback', 'dpm_prepare', 'dpm_complete']:\n\t\t\treturn\n\t\tfs = self.start\n\t\tfe = self.end\n\t\tif fs < data.start or fe > data.end:\n\t\t\treturn\n\t\tphase = ''\n\t\tfor p in data.sortedPhases():\n\t\t\tif(data.dmesg[p]['start'] <= self.start and\n\t\t\t\tself.start < data.dmesg[p]['end']):\n\t\t\t\tphase = p\n\t\t\t\tbreak\n\t\tif not phase:\n\t\t\treturn\n\t\tout = data.newActionGlobal(name, fs, fe, -2)\n\t\tif out:\n\t\t\tphase, myname = out\n\t\t\tdata.dmesg[phase]['list'][myname]['ftrace'] = self\n\tdef debugPrint(self, info=''):\n\t\tpprint('%s pid=%d [%f - %f] %.3f us' % \\\n\t\t\t(self.name, self.pid, self.start, self.end,\n\t\t\t(self.end - self.start)*1000000))\n\t\tfor l in self.list:\n\t\t\tif l.isLeaf():\n\t\t\t\tpprint('%f (%02d): %s(); (%.3f us)%s' % (l.time, \\\n\t\t\t\t\tl.depth, l.name, l.length*1000000, info))\n\t\t\telif l.freturn:\n\t\t\t\tpprint('%f (%02d): %s} (%.3f us)%s' % (l.time, \\\n\t\t\t\t\tl.depth, l.name, l.length*1000000, info))\n\t\t\telse:\n\t\t\t\tpprint('%f (%02d): %s() { (%.3f us)%s' % (l.time, \\\n\t\t\t\t\tl.depth, l.name, l.length*1000000, info))\n\t\tpprint(' ')\n\nclass DevItem:\n\tdef __init__(self, test, phase, dev):\n\t\tself.test = test\n\t\tself.phase = phase\n\t\tself.dev = dev\n\tdef isa(self, cls):\n\t\tif 'htmlclass' in self.dev and cls in self.dev['htmlclass']:\n\t\t\treturn True\n\t\treturn False\n\n# Class: Timeline\n# Description:\n#\t A container for a device timeline which calculates\n#\t all the html properties to display it correctly\nclass Timeline:\n\thtml_tblock = '<div id=\"block{0}\" class=\"tblock\" style=\"left:{1}%;width:{2}%;\"><div class=\"tback\" style=\"height:{3}px\"></div>\\n'\n\thtml_device = '<div id=\"{0}\" title=\"{1}\" class=\"thread{7}\" style=\"left:{2}%;top:{3}px;height:{4}px;width:{5}%;{8}\">{6}</div>\\n'\n\thtml_phase = '<div class=\"phase\" style=\"left:{0}%;width:{1}%;top:{2}px;height:{3}px;background:{4}\">{5}</div>\\n'\n\thtml_phaselet = '<div id=\"{0}\" class=\"phaselet\" style=\"left:{1}%;width:{2}%;background:{3}\"></div>\\n'\n\thtml_legend = '<div id=\"p{3}\" class=\"square\" style=\"left:{0}%;background:{1}\">&nbsp;{2}</div>\\n'\n\tdef __init__(self, rowheight, scaleheight):\n\t\tself.html = ''\n\t\tself.height = 0  # total timeline height\n\t\tself.scaleH = scaleheight # timescale (top) row height\n\t\tself.rowH = rowheight     # device row height\n\t\tself.bodyH = 0   # body height\n\t\tself.rows = 0    # total timeline rows\n\t\tself.rowlines = dict()\n\t\tself.rowheight = dict()\n\tdef createHeader(self, sv, stamp):\n\t\tif(not stamp['time']):\n\t\t\treturn\n\t\tself.html += '<div class=\"version\"><a href=\"https://01.org/pm-graph\">%s v%s</a></div>' \\\n\t\t\t% (sv.title, sv.version)\n\t\tif sv.logmsg and sv.testlog:\n\t\t\tself.html += '<button id=\"showtest\" class=\"logbtn btnfmt\">log</button>'\n\t\tif sv.dmesglog:\n\t\t\tself.html += '<button id=\"showdmesg\" class=\"logbtn btnfmt\">dmesg</button>'\n\t\tif sv.ftracelog:\n\t\t\tself.html += '<button id=\"showftrace\" class=\"logbtn btnfmt\">ftrace</button>'\n\t\theadline_stamp = '<div class=\"stamp\">{0} {1} {2} {3}</div>\\n'\n\t\tself.html += headline_stamp.format(stamp['host'], stamp['kernel'],\n\t\t\tstamp['mode'], stamp['time'])\n\t\tif 'man' in stamp and 'plat' in stamp and 'cpu' in stamp and \\\n\t\t\tstamp['man'] and stamp['plat'] and stamp['cpu']:\n\t\t\theadline_sysinfo = '<div class=\"stamp sysinfo\">{0} {1} <i>with</i> {2}</div>\\n'\n\t\t\tself.html += headline_sysinfo.format(stamp['man'], stamp['plat'], stamp['cpu'])\n\n\t# Function: getDeviceRows\n\t# Description:\n\t#    determine how may rows the device funcs will take\n\t# Arguments:\n\t#\t rawlist: the list of devices/actions for a single phase\n\t# Output:\n\t#\t The total number of rows needed to display this phase of the timeline\n\tdef getDeviceRows(self, rawlist):\n\t\t# clear all rows and set them to undefined\n\t\tsortdict = dict()\n\t\tfor item in rawlist:\n\t\t\titem.row = -1\n\t\t\tsortdict[item] = item.length\n\t\tsortlist = sorted(sortdict, key=sortdict.get, reverse=True)\n\t\tremaining = len(sortlist)\n\t\trowdata = dict()\n\t\trow = 1\n\t\t# try to pack each row with as many ranges as possible\n\t\twhile(remaining > 0):\n\t\t\tif(row not in rowdata):\n\t\t\t\trowdata[row] = []\n\t\t\tfor i in sortlist:\n\t\t\t\tif(i.row >= 0):\n\t\t\t\t\tcontinue\n\t\t\t\ts = i.time\n\t\t\t\te = i.time + i.length\n\t\t\t\tvalid = True\n\t\t\t\tfor ritem in rowdata[row]:\n\t\t\t\t\trs = ritem.time\n\t\t\t\t\tre = ritem.time + ritem.length\n\t\t\t\t\tif(not (((s <= rs) and (e <= rs)) or\n\t\t\t\t\t\t((s >= re) and (e >= re)))):\n\t\t\t\t\t\tvalid = False\n\t\t\t\t\t\tbreak\n\t\t\t\tif(valid):\n\t\t\t\t\trowdata[row].append(i)\n\t\t\t\t\ti.row = row\n\t\t\t\t\tremaining -= 1\n\t\t\trow += 1\n\t\treturn row\n\t# Function: getPhaseRows\n\t# Description:\n\t#\t Organize the timeline entries into the smallest\n\t#\t number of rows possible, with no entry overlapping\n\t# Arguments:\n\t#\t devlist: the list of devices/actions in a group of contiguous phases\n\t# Output:\n\t#\t The total number of rows needed to display this phase of the timeline\n\tdef getPhaseRows(self, devlist, row=0, sortby='length'):\n\t\t# clear all rows and set them to undefined\n\t\tremaining = len(devlist)\n\t\trowdata = dict()\n\t\tsortdict = dict()\n\t\tmyphases = []\n\t\t# initialize all device rows to -1 and calculate devrows\n\t\tfor item in devlist:\n\t\t\tdev = item.dev\n\t\t\ttp = (item.test, item.phase)\n\t\t\tif tp not in myphases:\n\t\t\t\tmyphases.append(tp)\n\t\t\tdev['row'] = -1\n\t\t\tif sortby == 'start':\n\t\t\t\t# sort by start 1st, then length 2nd\n\t\t\t\tsortdict[item] = (-1*float(dev['start']), float(dev['end']) - float(dev['start']))\n\t\t\telse:\n\t\t\t\t# sort by length 1st, then name 2nd\n\t\t\t\tsortdict[item] = (float(dev['end']) - float(dev['start']), item.dev['name'])\n\t\t\tif 'src' in dev:\n\t\t\t\tdev['devrows'] = self.getDeviceRows(dev['src'])\n\t\t# sort the devlist by length so that large items graph on top\n\t\tsortlist = sorted(sortdict, key=sortdict.get, reverse=True)\n\t\torderedlist = []\n\t\tfor item in sortlist:\n\t\t\tif item.dev['pid'] == -2:\n\t\t\t\torderedlist.append(item)\n\t\tfor item in sortlist:\n\t\t\tif item not in orderedlist:\n\t\t\t\torderedlist.append(item)\n\t\t# try to pack each row with as many devices as possible\n\t\twhile(remaining > 0):\n\t\t\trowheight = 1\n\t\t\tif(row not in rowdata):\n\t\t\t\trowdata[row] = []\n\t\t\tfor item in orderedlist:\n\t\t\t\tdev = item.dev\n\t\t\t\tif(dev['row'] < 0):\n\t\t\t\t\ts = dev['start']\n\t\t\t\t\te = dev['end']\n\t\t\t\t\tvalid = True\n\t\t\t\t\tfor ritem in rowdata[row]:\n\t\t\t\t\t\trs = ritem.dev['start']\n\t\t\t\t\t\tre = ritem.dev['end']\n\t\t\t\t\t\tif(not (((s <= rs) and (e <= rs)) or\n\t\t\t\t\t\t\t((s >= re) and (e >= re)))):\n\t\t\t\t\t\t\tvalid = False\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif(valid):\n\t\t\t\t\t\trowdata[row].append(item)\n\t\t\t\t\t\tdev['row'] = row\n\t\t\t\t\t\tremaining -= 1\n\t\t\t\t\t\tif 'devrows' in dev and dev['devrows'] > rowheight:\n\t\t\t\t\t\t\trowheight = dev['devrows']\n\t\t\tfor t, p in myphases:\n\t\t\t\tif t not in self.rowlines or t not in self.rowheight:\n\t\t\t\t\tself.rowlines[t] = dict()\n\t\t\t\t\tself.rowheight[t] = dict()\n\t\t\t\tif p not in self.rowlines[t] or p not in self.rowheight[t]:\n\t\t\t\t\tself.rowlines[t][p] = dict()\n\t\t\t\t\tself.rowheight[t][p] = dict()\n\t\t\t\trh = self.rowH\n\t\t\t\t# section headers should use a different row height\n\t\t\t\tif len(rowdata[row]) == 1 and \\\n\t\t\t\t\t'htmlclass' in rowdata[row][0].dev and \\\n\t\t\t\t\t'sec' in rowdata[row][0].dev['htmlclass']:\n\t\t\t\t\trh = 15\n\t\t\t\tself.rowlines[t][p][row] = rowheight\n\t\t\t\tself.rowheight[t][p][row] = rowheight * rh\n\t\t\trow += 1\n\t\tif(row > self.rows):\n\t\t\tself.rows = int(row)\n\t\treturn row\n\tdef phaseRowHeight(self, test, phase, row):\n\t\treturn self.rowheight[test][phase][row]\n\tdef phaseRowTop(self, test, phase, row):\n\t\ttop = 0\n\t\tfor i in sorted(self.rowheight[test][phase]):\n\t\t\tif i >= row:\n\t\t\t\tbreak\n\t\t\ttop += self.rowheight[test][phase][i]\n\t\treturn top\n\tdef calcTotalRows(self):\n\t\t# Calculate the heights and offsets for the header and rows\n\t\tmaxrows = 0\n\t\tstandardphases = []\n\t\tfor t in self.rowlines:\n\t\t\tfor p in self.rowlines[t]:\n\t\t\t\ttotal = 0\n\t\t\t\tfor i in sorted(self.rowlines[t][p]):\n\t\t\t\t\ttotal += self.rowlines[t][p][i]\n\t\t\t\tif total > maxrows:\n\t\t\t\t\tmaxrows = total\n\t\t\t\tif total == len(self.rowlines[t][p]):\n\t\t\t\t\tstandardphases.append((t, p))\n\t\tself.height = self.scaleH + (maxrows*self.rowH)\n\t\tself.bodyH = self.height - self.scaleH\n\t\t# if there is 1 line per row, draw them the standard way\n\t\tfor t, p in standardphases:\n\t\t\tfor i in sorted(self.rowheight[t][p]):\n\t\t\t\tself.rowheight[t][p][i] = float(self.bodyH)/len(self.rowlines[t][p])\n\tdef createZoomBox(self, mode='command', testcount=1):\n\t\t# Create bounding box, add buttons\n\t\thtml_zoombox = '<center><button id=\"zoomin\">ZOOM IN +</button><button id=\"zoomout\">ZOOM OUT -</button><button id=\"zoomdef\">ZOOM 1:1</button></center>\\n'\n\t\thtml_timeline = '<div id=\"dmesgzoombox\" class=\"zoombox\">\\n<div id=\"{0}\" class=\"timeline\" style=\"height:{1}px\">\\n'\n\t\thtml_devlist1 = '<button id=\"devlist1\" class=\"devlist\" style=\"float:left;\">Device Detail{0}</button>'\n\t\thtml_devlist2 = '<button id=\"devlist2\" class=\"devlist\" style=\"float:right;\">Device Detail2</button>\\n'\n\t\tif mode != 'command':\n\t\t\tif testcount > 1:\n\t\t\t\tself.html += html_devlist2\n\t\t\t\tself.html += html_devlist1.format('1')\n\t\t\telse:\n\t\t\t\tself.html += html_devlist1.format('')\n\t\tself.html += html_zoombox\n\t\tself.html += html_timeline.format('dmesg', self.height)\n\t# Function: createTimeScale\n\t# Description:\n\t#\t Create the timescale for a timeline block\n\t# Arguments:\n\t#\t m0: start time (mode begin)\n\t#\t mMax: end time (mode end)\n\t#\t tTotal: total timeline time\n\t#\t mode: suspend or resume\n\t# Output:\n\t#\t The html code needed to display the time scale\n\tdef createTimeScale(self, m0, mMax, tTotal, mode):\n\t\ttimescale = '<div class=\"t\" style=\"right:{0}%\">{1}</div>\\n'\n\t\trline = '<div class=\"t\" style=\"left:0;border-left:1px solid black;border-right:0;\">{0}</div>\\n'\n\t\toutput = '<div class=\"timescale\">\\n'\n\t\t# set scale for timeline\n\t\tmTotal = mMax - m0\n\t\ttS = 0.1\n\t\tif(tTotal <= 0):\n\t\t\treturn output+'</div>\\n'\n\t\tif(tTotal > 4):\n\t\t\ttS = 1\n\t\tdivTotal = int(mTotal/tS) + 1\n\t\tdivEdge = (mTotal - tS*(divTotal-1))*100/mTotal\n\t\tfor i in range(divTotal):\n\t\t\thtmlline = ''\n\t\t\tif(mode == 'suspend'):\n\t\t\t\tpos = '%0.3f' % (100 - ((float(i)*tS*100)/mTotal) - divEdge)\n\t\t\t\tval = '%0.fms' % (float(i-divTotal+1)*tS*1000)\n\t\t\t\tif(i == divTotal - 1):\n\t\t\t\t\tval = mode\n\t\t\t\thtmlline = timescale.format(pos, val)\n\t\t\telse:\n\t\t\t\tpos = '%0.3f' % (100 - ((float(i)*tS*100)/mTotal))\n\t\t\t\tval = '%0.fms' % (float(i)*tS*1000)\n\t\t\t\thtmlline = timescale.format(pos, val)\n\t\t\t\tif(i == 0):\n\t\t\t\t\thtmlline = rline.format(mode)\n\t\t\toutput += htmlline\n\t\tself.html += output+'</div>\\n'\n\n# Class: TestProps\n# Description:\n#\t A list of values describing the properties of these test runs\nclass TestProps:\n\tstampfmt = '# [a-z]*-(?P<m>[0-9]{2})(?P<d>[0-9]{2})(?P<y>[0-9]{2})-'+\\\n\t\t\t\t'(?P<H>[0-9]{2})(?P<M>[0-9]{2})(?P<S>[0-9]{2})'+\\\n\t\t\t\t' (?P<host>.*) (?P<mode>.*) (?P<kernel>.*)$'\n\twififmt    = '^# wifi *(?P<d>\\S*) *(?P<s>\\S*) *(?P<t>[0-9\\.]+).*'\n\ttstatfmt   = '^# turbostat (?P<t>\\S*)'\n\ttesterrfmt = '^# enter_sleep_error (?P<e>.*)'\n\tsysinfofmt = '^# sysinfo .*'\n\tcmdlinefmt = '^# command \\| (?P<cmd>.*)'\n\tkparamsfmt = '^# kparams \\| (?P<kp>.*)'\n\tdevpropfmt = '# Device Properties: .*'\n\tpinfofmt   = '# platform-(?P<val>[a-z,A-Z,0-9,_]*): (?P<info>.*)'\n\ttracertypefmt = '# tracer: (?P<t>.*)'\n\tfirmwarefmt = '# fwsuspend (?P<s>[0-9]*) fwresume (?P<r>[0-9]*)$'\n\tprocexecfmt = 'ps - (?P<ps>.*)$'\n\tprocmultifmt = '@(?P<n>[0-9]*)\\|(?P<ps>.*)$'\n\tftrace_line_fmt_fg = \\\n\t\t'^ *(?P<time>[0-9\\.]*) *\\| *(?P<cpu>[0-9]*)\\)'+\\\n\t\t' *(?P<proc>.*)-(?P<pid>[0-9]*) *\\|'+\\\n\t\t'[ +!#\\*@$]*(?P<dur>[0-9\\.]*) .*\\|  (?P<msg>.*)'\n\tftrace_line_fmt_nop = \\\n\t\t' *(?P<proc>.*)-(?P<pid>[0-9]*) *\\[(?P<cpu>[0-9]*)\\] *'+\\\n\t\t'(?P<flags>\\S*) *(?P<time>[0-9\\.]*): *'+\\\n\t\t'(?P<msg>.*)'\n\tmachinesuspend = 'machine_suspend\\[.*'\n\tmultiproclist = dict()\n\tmultiproctime = 0.0\n\tmultiproccnt = 0\n\tdef __init__(self):\n\t\tself.stamp = ''\n\t\tself.sysinfo = ''\n\t\tself.cmdline = ''\n\t\tself.testerror = []\n\t\tself.turbostat = []\n\t\tself.wifi = []\n\t\tself.fwdata = []\n\t\tself.ftrace_line_fmt = self.ftrace_line_fmt_nop\n\t\tself.cgformat = False\n\t\tself.data = 0\n\t\tself.ktemp = dict()\n\tdef setTracerType(self, tracer):\n\t\tif(tracer == 'function_graph'):\n\t\t\tself.cgformat = True\n\t\t\tself.ftrace_line_fmt = self.ftrace_line_fmt_fg\n\t\telif(tracer == 'nop'):\n\t\t\tself.ftrace_line_fmt = self.ftrace_line_fmt_nop\n\t\telse:\n\t\t\tdoError('Invalid tracer format: [%s]' % tracer)\n\tdef stampInfo(self, line, sv):\n\t\tif re.match(self.stampfmt, line):\n\t\t\tself.stamp = line\n\t\t\treturn True\n\t\telif re.match(self.sysinfofmt, line):\n\t\t\tself.sysinfo = line\n\t\t\treturn True\n\t\telif re.match(self.tstatfmt, line):\n\t\t\tself.turbostat.append(line)\n\t\t\treturn True\n\t\telif re.match(self.wififmt, line):\n\t\t\tself.wifi.append(line)\n\t\t\treturn True\n\t\telif re.match(self.testerrfmt, line):\n\t\t\tself.testerror.append(line)\n\t\t\treturn True\n\t\telif re.match(self.firmwarefmt, line):\n\t\t\tself.fwdata.append(line)\n\t\t\treturn True\n\t\telif(re.match(self.devpropfmt, line)):\n\t\t\tself.parseDevprops(line, sv)\n\t\t\treturn True\n\t\telif(re.match(self.pinfofmt, line)):\n\t\t\tself.parsePlatformInfo(line, sv)\n\t\t\treturn True\n\t\tm = re.match(self.cmdlinefmt, line)\n\t\tif m:\n\t\t\tself.cmdline = m.group('cmd')\n\t\t\treturn True\n\t\tm = re.match(self.tracertypefmt, line)\n\t\tif(m):\n\t\t\tself.setTracerType(m.group('t'))\n\t\t\treturn True\n\t\treturn False\n\tdef parseStamp(self, data, sv):\n\t\t# global test data\n\t\tm = re.match(self.stampfmt, self.stamp)\n\t\tif not self.stamp or not m:\n\t\t\tdoError('data does not include the expected stamp')\n\t\tdata.stamp = {'time': '', 'host': '', 'mode': ''}\n\t\tdt = datetime(int(m.group('y'))+2000, int(m.group('m')),\n\t\t\tint(m.group('d')), int(m.group('H')), int(m.group('M')),\n\t\t\tint(m.group('S')))\n\t\tdata.stamp['time'] = dt.strftime('%B %d %Y, %I:%M:%S %p')\n\t\tdata.stamp['host'] = m.group('host')\n\t\tdata.stamp['mode'] = m.group('mode')\n\t\tdata.stamp['kernel'] = m.group('kernel')\n\t\tif re.match(self.sysinfofmt, self.sysinfo):\n\t\t\tfor f in self.sysinfo.split('|'):\n\t\t\t\tif '#' in f:\n\t\t\t\t\tcontinue\n\t\t\t\ttmp = f.strip().split(':', 1)\n\t\t\t\tkey = tmp[0]\n\t\t\t\tval = tmp[1]\n\t\t\t\tdata.stamp[key] = val\n\t\tsv.hostname = data.stamp['host']\n\t\tsv.suspendmode = data.stamp['mode']\n\t\tif sv.suspendmode == 'freeze':\n\t\t\tself.machinesuspend = 'timekeeping_freeze\\[.*'\n\t\telse:\n\t\t\tself.machinesuspend = 'machine_suspend\\[.*'\n\t\tif sv.suspendmode == 'command' and sv.ftracefile != '':\n\t\t\tmodes = ['on', 'freeze', 'standby', 'mem', 'disk']\n\t\t\tfp = sv.openlog(sv.ftracefile, 'r')\n\t\t\tfor line in fp:\n\t\t\t\tm = re.match('.* machine_suspend\\[(?P<mode>.*)\\]', line)\n\t\t\t\tif m and m.group('mode') in ['1', '2', '3', '4']:\n\t\t\t\t\tsv.suspendmode = modes[int(m.group('mode'))]\n\t\t\t\t\tdata.stamp['mode'] = sv.suspendmode\n\t\t\t\t\tbreak\n\t\t\tfp.close()\n\t\tsv.cmdline = self.cmdline\n\t\tif not sv.stamp:\n\t\t\tsv.stamp = data.stamp\n\t\t# firmware data\n\t\tif sv.suspendmode == 'mem' and len(self.fwdata) > data.testnumber:\n\t\t\tm = re.match(self.firmwarefmt, self.fwdata[data.testnumber])\n\t\t\tif m:\n\t\t\t\tdata.fwSuspend, data.fwResume = int(m.group('s')), int(m.group('r'))\n\t\t\t\tif(data.fwSuspend > 0 or data.fwResume > 0):\n\t\t\t\t\tdata.fwValid = True\n\t\t# turbostat data\n\t\tif len(self.turbostat) > data.testnumber:\n\t\t\tm = re.match(self.tstatfmt, self.turbostat[data.testnumber])\n\t\t\tif m:\n\t\t\t\tdata.turbostat = m.group('t')\n\t\t# wifi data\n\t\tif len(self.wifi) > data.testnumber:\n\t\t\tm = re.match(self.wififmt, self.wifi[data.testnumber])\n\t\t\tif m:\n\t\t\t\tdata.wifi = {'dev': m.group('d'), 'stat': m.group('s'),\n\t\t\t\t\t'time': float(m.group('t'))}\n\t\t\t\tdata.stamp['wifi'] = m.group('d')\n\t\t# sleep mode enter errors\n\t\tif len(self.testerror) > data.testnumber:\n\t\t\tm = re.match(self.testerrfmt, self.testerror[data.testnumber])\n\t\t\tif m:\n\t\t\t\tdata.enterfail = m.group('e')\n\tdef devprops(self, data):\n\t\tprops = dict()\n\t\tdevlist = data.split(';')\n\t\tfor dev in devlist:\n\t\t\tf = dev.split(',')\n\t\t\tif len(f) < 3:\n\t\t\t\tcontinue\n\t\t\tdev = f[0]\n\t\t\tprops[dev] = DevProps()\n\t\t\tprops[dev].altname = f[1]\n\t\t\tif int(f[2]):\n\t\t\t\tprops[dev].isasync = True\n\t\t\telse:\n\t\t\t\tprops[dev].isasync = False\n\t\treturn props\n\tdef parseDevprops(self, line, sv):\n\t\tidx = line.index(': ') + 2\n\t\tif idx >= len(line):\n\t\t\treturn\n\t\tprops = self.devprops(line[idx:])\n\t\tif sv.suspendmode == 'command' and 'testcommandstring' in props:\n\t\t\tsv.testcommand = props['testcommandstring'].altname\n\t\tsv.devprops = props\n\tdef parsePlatformInfo(self, line, sv):\n\t\tm = re.match(self.pinfofmt, line)\n\t\tif not m:\n\t\t\treturn\n\t\tname, info = m.group('val'), m.group('info')\n\t\tif name == 'devinfo':\n\t\t\tsv.devprops = self.devprops(sv.b64unzip(info))\n\t\t\treturn\n\t\telif name == 'testcmd':\n\t\t\tsv.testcommand = info\n\t\t\treturn\n\t\tfield = info.split('|')\n\t\tif len(field) < 2:\n\t\t\treturn\n\t\tcmdline = field[0].strip()\n\t\toutput = sv.b64unzip(field[1].strip())\n\t\tsv.platinfo.append([name, cmdline, output])\n\n# Class: TestRun\n# Description:\n#\t A container for a suspend/resume test run. This is necessary as\n#\t there could be more than one, and they need to be separate.\nclass TestRun:\n\tdef __init__(self, dataobj):\n\t\tself.data = dataobj\n\t\tself.ftemp = dict()\n\t\tself.ttemp = dict()\n\nclass ProcessMonitor:\n\tmaxchars = 512\n\tdef __init__(self):\n\t\tself.proclist = dict()\n\t\tself.running = False\n\tdef procstat(self):\n\t\tc = ['cat /proc/[1-9]*/stat 2>/dev/null']\n\t\tprocess = Popen(c, shell=True, stdout=PIPE)\n\t\trunning = dict()\n\t\tfor line in process.stdout:\n\t\t\tdata = ascii(line).split()\n\t\t\tpid = data[0]\n\t\t\tname = re.sub('[()]', '', data[1])\n\t\t\tuser = int(data[13])\n\t\t\tkern = int(data[14])\n\t\t\tkjiff = ujiff = 0\n\t\t\tif pid not in self.proclist:\n\t\t\t\tself.proclist[pid] = {'name' : name, 'user' : user, 'kern' : kern}\n\t\t\telse:\n\t\t\t\tval = self.proclist[pid]\n\t\t\t\tujiff = user - val['user']\n\t\t\t\tkjiff = kern - val['kern']\n\t\t\t\tval['user'] = user\n\t\t\t\tval['kern'] = kern\n\t\t\tif ujiff > 0 or kjiff > 0:\n\t\t\t\trunning[pid] = ujiff + kjiff\n\t\tprocess.wait()\n\t\tout = ['']\n\t\tfor pid in running:\n\t\t\tjiffies = running[pid]\n\t\t\tval = self.proclist[pid]\n\t\t\tif len(out[-1]) > self.maxchars:\n\t\t\t\tout.append('')\n\t\t\telif len(out[-1]) > 0:\n\t\t\t\tout[-1] += ','\n\t\t\tout[-1] += '%s-%s %d' % (val['name'], pid, jiffies)\n\t\tif len(out) > 1:\n\t\t\tfor line in out:\n\t\t\t\tsysvals.fsetVal('ps - @%d|%s' % (len(out), line), 'trace_marker')\n\t\telse:\n\t\t\tsysvals.fsetVal('ps - %s' % out[0], 'trace_marker')\n\tdef processMonitor(self, tid):\n\t\twhile self.running:\n\t\t\tself.procstat()\n\tdef start(self):\n\t\tself.thread = Thread(target=self.processMonitor, args=(0,))\n\t\tself.running = True\n\t\tself.thread.start()\n\tdef stop(self):\n\t\tself.running = False\n\n# ----------------- FUNCTIONS --------------------\n\n# Function: doesTraceLogHaveTraceEvents\n# Description:\n#\t Quickly determine if the ftrace log has all of the trace events,\n#\t markers, and/or kprobes required for primary parsing.\ndef doesTraceLogHaveTraceEvents():\n\tkpcheck = ['_cal: (', '_ret: (']\n\ttecheck = ['suspend_resume', 'device_pm_callback', 'tracing_mark_write']\n\ttmcheck = ['SUSPEND START', 'RESUME COMPLETE']\n\tsysvals.usekprobes = False\n\tfp = sysvals.openlog(sysvals.ftracefile, 'r')\n\tfor line in fp:\n\t\t# check for kprobes\n\t\tif not sysvals.usekprobes:\n\t\t\tfor i in kpcheck:\n\t\t\t\tif i in line:\n\t\t\t\t\tsysvals.usekprobes = True\n\t\t# check for all necessary trace events\n\t\tcheck = techeck[:]\n\t\tfor i in techeck:\n\t\t\tif i in line:\n\t\t\t\tcheck.remove(i)\n\t\ttecheck = check\n\t\t# check for all necessary trace markers\n\t\tcheck = tmcheck[:]\n\t\tfor i in tmcheck:\n\t\t\tif i in line:\n\t\t\t\tcheck.remove(i)\n\t\ttmcheck = check\n\tfp.close()\n\tsysvals.usetraceevents = True if len(techeck) < 3 else False\n\tsysvals.usetracemarkers = True if len(tmcheck) == 0 else False\n\n# Function: appendIncompleteTraceLog\n# Description:\n#\t Adds callgraph data which lacks trace event data. This is only\n#\t for timelines generated from 3.15 or older\n# Arguments:\n#\t testruns: the array of Data objects obtained from parseKernelLog\ndef appendIncompleteTraceLog(testruns):\n\t# create TestRun vessels for ftrace parsing\n\ttestcnt = len(testruns)\n\ttestidx = 0\n\ttestrun = []\n\tfor data in testruns:\n\t\ttestrun.append(TestRun(data))\n\n\t# extract the callgraph and traceevent data\n\tsysvals.vprint('Analyzing the ftrace data (%s)...' % \\\n\t\tos.path.basename(sysvals.ftracefile))\n\ttp = TestProps()\n\ttf = sysvals.openlog(sysvals.ftracefile, 'r')\n\tdata = 0\n\tfor line in tf:\n\t\t# remove any latent carriage returns\n\t\tline = line.replace('\\r\\n', '')\n\t\tif tp.stampInfo(line, sysvals):\n\t\t\tcontinue\n\t\t# parse only valid lines, if this is not one move on\n\t\tm = re.match(tp.ftrace_line_fmt, line)\n\t\tif(not m):\n\t\t\tcontinue\n\t\t# gather the basic message data from the line\n\t\tm_time = m.group('time')\n\t\tm_pid = m.group('pid')\n\t\tm_msg = m.group('msg')\n\t\tif(tp.cgformat):\n\t\t\tm_param3 = m.group('dur')\n\t\telse:\n\t\t\tm_param3 = 'traceevent'\n\t\tif(m_time and m_pid and m_msg):\n\t\t\tt = FTraceLine(m_time, m_msg, m_param3)\n\t\t\tpid = int(m_pid)\n\t\telse:\n\t\t\tcontinue\n\t\t# the line should be a call, return, or event\n\t\tif(not t.fcall and not t.freturn and not t.fevent):\n\t\t\tcontinue\n\t\t# look for the suspend start marker\n\t\tif(t.startMarker()):\n\t\t\tdata = testrun[testidx].data\n\t\t\ttp.parseStamp(data, sysvals)\n\t\t\tdata.setStart(t.time, t.name)\n\t\t\tcontinue\n\t\tif(not data):\n\t\t\tcontinue\n\t\t# find the end of resume\n\t\tif(t.endMarker()):\n\t\t\tdata.setEnd(t.time, t.name)\n\t\t\ttestidx += 1\n\t\t\tif(testidx >= testcnt):\n\t\t\t\tbreak\n\t\t\tcontinue\n\t\t# trace event processing\n\t\tif(t.fevent):\n\t\t\tcontinue\n\t\t# call/return processing\n\t\telif sysvals.usecallgraph:\n\t\t\t# create a callgraph object for the data\n\t\t\tif(pid not in testrun[testidx].ftemp):\n\t\t\t\ttestrun[testidx].ftemp[pid] = []\n\t\t\t\ttestrun[testidx].ftemp[pid].append(FTraceCallGraph(pid, sysvals))\n\t\t\t# when the call is finished, see which device matches it\n\t\t\tcg = testrun[testidx].ftemp[pid][-1]\n\t\t\tres = cg.addLine(t)\n\t\t\tif(res != 0):\n\t\t\t\ttestrun[testidx].ftemp[pid].append(FTraceCallGraph(pid, sysvals))\n\t\t\tif(res == -1):\n\t\t\t\ttestrun[testidx].ftemp[pid][-1].addLine(t)\n\ttf.close()\n\n\tfor test in testrun:\n\t\t# add the callgraph data to the device hierarchy\n\t\tfor pid in test.ftemp:\n\t\t\tfor cg in test.ftemp[pid]:\n\t\t\t\tif len(cg.list) < 1 or cg.invalid or (cg.end - cg.start == 0):\n\t\t\t\t\tcontinue\n\t\t\t\tif(not cg.postProcess()):\n\t\t\t\t\tid = 'task %s cpu %s' % (pid, m.group('cpu'))\n\t\t\t\t\tsysvals.vprint('Sanity check failed for '+\\\n\t\t\t\t\t\tid+', ignoring this callback')\n\t\t\t\t\tcontinue\n\t\t\t\tcallstart = cg.start\n\t\t\t\tcallend = cg.end\n\t\t\t\tfor p in test.data.sortedPhases():\n\t\t\t\t\tif(test.data.dmesg[p]['start'] <= callstart and\n\t\t\t\t\t\tcallstart <= test.data.dmesg[p]['end']):\n\t\t\t\t\t\tlist = test.data.dmesg[p]['list']\n\t\t\t\t\t\tfor devname in list:\n\t\t\t\t\t\t\tdev = list[devname]\n\t\t\t\t\t\t\tif(pid == dev['pid'] and\n\t\t\t\t\t\t\t\tcallstart <= dev['start'] and\n\t\t\t\t\t\t\t\tcallend >= dev['end']):\n\t\t\t\t\t\t\t\tdev['ftrace'] = cg\n\t\t\t\t\t\tbreak\n\n# Function: loadTraceLog\n# Description:\n#\t load the ftrace file into memory and fix up any ordering issues\n# Output:\n#\t TestProps instance and an array of lines in proper order\ndef loadTraceLog():\n\ttp, data, lines, trace = TestProps(), dict(), [], []\n\ttf = sysvals.openlog(sysvals.ftracefile, 'r')\n\tfor line in tf:\n\t\t# remove any latent carriage returns\n\t\tline = line.replace('\\r\\n', '')\n\t\tif tp.stampInfo(line, sysvals):\n\t\t\tcontinue\n\t\t# ignore all other commented lines\n\t\tif line[0] == '#':\n\t\t\tcontinue\n\t\t# ftrace line: parse only valid lines\n\t\tm = re.match(tp.ftrace_line_fmt, line)\n\t\tif(not m):\n\t\t\tcontinue\n\t\tdur = m.group('dur') if tp.cgformat else 'traceevent'\n\t\tinfo = (m.group('time'), m.group('proc'), m.group('pid'),\n\t\t\tm.group('msg'), dur)\n\t\t# group the data by timestamp\n\t\tt = float(info[0])\n\t\tif t in data:\n\t\t\tdata[t].append(info)\n\t\telse:\n\t\t\tdata[t] = [info]\n\t\t# we only care about trace event ordering\n\t\tif (info[3].startswith('suspend_resume:') or \\\n\t\t\tinfo[3].startswith('tracing_mark_write:')) and t not in trace:\n\t\t\t\ttrace.append(t)\n\ttf.close()\n\tfor t in sorted(data):\n\t\tfirst, last, blk = [], [], data[t]\n\t\tif len(blk) > 1 and t in trace:\n\t\t\t# move certain lines to the start or end of a timestamp block\n\t\t\tfor i in range(len(blk)):\n\t\t\t\tif 'SUSPEND START' in blk[i][3]:\n\t\t\t\t\tfirst.append(i)\n\t\t\t\telif re.match('.* timekeeping_freeze.*begin', blk[i][3]):\n\t\t\t\t\tlast.append(i)\n\t\t\t\telif re.match('.* timekeeping_freeze.*end', blk[i][3]):\n\t\t\t\t\tfirst.append(i)\n\t\t\t\telif 'RESUME COMPLETE' in blk[i][3]:\n\t\t\t\t\tlast.append(i)\n\t\t\tif len(first) == 1 and len(last) == 0:\n\t\t\t\tblk.insert(0, blk.pop(first[0]))\n\t\t\telif len(last) == 1 and len(first) == 0:\n\t\t\t\tblk.append(blk.pop(last[0]))\n\t\tfor info in blk:\n\t\t\tlines.append(info)\n\treturn (tp, lines)\n\n# Function: parseTraceLog\n# Description:\n#\t Analyze an ftrace log output file generated from this app during\n#\t the execution phase. Used when the ftrace log is the primary data source\n#\t and includes the suspend_resume and device_pm_callback trace events\n#\t The ftrace filename is taken from sysvals\n# Output:\n#\t An array of Data objects\ndef parseTraceLog(live=False):\n\tsysvals.vprint('Analyzing the ftrace data (%s)...' % \\\n\t\tos.path.basename(sysvals.ftracefile))\n\tif(os.path.exists(sysvals.ftracefile) == False):\n\t\tdoError('%s does not exist' % sysvals.ftracefile)\n\tif not live:\n\t\tsysvals.setupAllKprobes()\n\tksuscalls = ['ksys_sync', 'pm_prepare_console']\n\tkrescalls = ['pm_restore_console']\n\ttracewatch = ['irq_wakeup']\n\tif sysvals.usekprobes:\n\t\ttracewatch += ['sync_filesystems', 'freeze_processes', 'syscore_suspend',\n\t\t\t'syscore_resume', 'resume_console', 'thaw_processes', 'CPU_ON',\n\t\t\t'CPU_OFF', 'acpi_suspend']\n\n\t# extract the callgraph and traceevent data\n\ts2idle_enter = hwsus = False\n\ttestruns, testdata = [], []\n\ttestrun, data, limbo = 0, 0, True\n\tphase = 'suspend_prepare'\n\ttp, tf = loadTraceLog()\n\tfor m_time, m_proc, m_pid, m_msg, m_param3 in tf:\n\t\t# gather the basic message data from the line\n\t\tif(m_time and m_pid and m_msg):\n\t\t\tt = FTraceLine(m_time, m_msg, m_param3)\n\t\t\tpid = int(m_pid)\n\t\telse:\n\t\t\tcontinue\n\t\t# the line should be a call, return, or event\n\t\tif(not t.fcall and not t.freturn and not t.fevent):\n\t\t\tcontinue\n\t\t# find the start of suspend\n\t\tif(t.startMarker()):\n\t\t\tdata, limbo = Data(len(testdata)), False\n\t\t\ttestdata.append(data)\n\t\t\ttestrun = TestRun(data)\n\t\t\ttestruns.append(testrun)\n\t\t\ttp.parseStamp(data, sysvals)\n\t\t\tdata.setStart(t.time, t.name)\n\t\t\tdata.first_suspend_prepare = True\n\t\t\tphase = data.setPhase('suspend_prepare', t.time, True)\n\t\t\tcontinue\n\t\tif(not data or limbo):\n\t\t\tcontinue\n\t\t# process cpu exec line\n\t\tif t.type == 'tracing_mark_write':\n\t\t\tif t.name == 'CMD COMPLETE' and data.tKernRes == 0:\n\t\t\t\tdata.tKernRes = t.time\n\t\t\tm = re.match(tp.procexecfmt, t.name)\n\t\t\tif(m):\n\t\t\t\tparts, msg = 1, m.group('ps')\n\t\t\t\tm = re.match(tp.procmultifmt, msg)\n\t\t\t\tif(m):\n\t\t\t\t\tparts, msg = int(m.group('n')), m.group('ps')\n\t\t\t\t\tif tp.multiproccnt == 0:\n\t\t\t\t\t\ttp.multiproctime = t.time\n\t\t\t\t\t\ttp.multiproclist = dict()\n\t\t\t\t\tproclist = tp.multiproclist\n\t\t\t\t\ttp.multiproccnt += 1\n\t\t\t\telse:\n\t\t\t\t\tproclist = dict()\n\t\t\t\t\ttp.multiproccnt = 0\n\t\t\t\tfor ps in msg.split(','):\n\t\t\t\t\tval = ps.split()\n\t\t\t\t\tif not val or len(val) != 2:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tname = val[0].replace('--', '-')\n\t\t\t\t\tproclist[name] = int(val[1])\n\t\t\t\tif parts == 1:\n\t\t\t\t\tdata.pstl[t.time] = proclist\n\t\t\t\telif parts == tp.multiproccnt:\n\t\t\t\t\tdata.pstl[tp.multiproctime] = proclist\n\t\t\t\t\ttp.multiproccnt = 0\n\t\t\t\tcontinue\n\t\t# find the end of resume\n\t\tif(t.endMarker()):\n\t\t\tif data.tKernRes == 0:\n\t\t\t\tdata.tKernRes = t.time\n\t\t\tdata.handleEndMarker(t.time, t.name)\n\t\t\tif(not sysvals.usetracemarkers):\n\t\t\t\t# no trace markers? then quit and be sure to finish recording\n\t\t\t\t# the event we used to trigger resume end\n\t\t\t\tif('thaw_processes' in testrun.ttemp and len(testrun.ttemp['thaw_processes']) > 0):\n\t\t\t\t\t# if an entry exists, assume this is its end\n\t\t\t\t\ttestrun.ttemp['thaw_processes'][-1]['end'] = t.time\n\t\t\tlimbo = True\n\t\t\tcontinue\n\t\t# trace event processing\n\t\tif(t.fevent):\n\t\t\tif(t.type == 'suspend_resume'):\n\t\t\t\t# suspend_resume trace events have two types, begin and end\n\t\t\t\tif(re.match('(?P<name>.*) begin$', t.name)):\n\t\t\t\t\tisbegin = True\n\t\t\t\telif(re.match('(?P<name>.*) end$', t.name)):\n\t\t\t\t\tisbegin = False\n\t\t\t\telse:\n\t\t\t\t\tcontinue\n\t\t\t\tif '[' in t.name:\n\t\t\t\t\tm = re.match('(?P<name>.*)\\[.*', t.name)\n\t\t\t\telse:\n\t\t\t\t\tm = re.match('(?P<name>.*) .*', t.name)\n\t\t\t\tname = m.group('name')\n\t\t\t\t# ignore these events\n\t\t\t\tif(name.split('[')[0] in tracewatch):\n\t\t\t\t\tcontinue\n\t\t\t\t# -- phase changes --\n\t\t\t\t# start of kernel suspend\n\t\t\t\tif(re.match('suspend_enter\\[.*', t.name)):\n\t\t\t\t\tif(isbegin and data.tKernSus == 0):\n\t\t\t\t\t\tdata.tKernSus = t.time\n\t\t\t\t\tcontinue\n\t\t\t\t# suspend_prepare start\n\t\t\t\telif(re.match('dpm_prepare\\[.*', t.name)):\n\t\t\t\t\tif isbegin and data.first_suspend_prepare:\n\t\t\t\t\t\tdata.first_suspend_prepare = False\n\t\t\t\t\t\tif data.tKernSus == 0:\n\t\t\t\t\t\t\tdata.tKernSus = t.time\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tphase = data.setPhase('suspend_prepare', t.time, isbegin)\n\t\t\t\t\tcontinue\n\t\t\t\t# suspend start\n\t\t\t\telif(re.match('dpm_suspend\\[.*', t.name)):\n\t\t\t\t\tphase = data.setPhase('suspend', t.time, isbegin)\n\t\t\t\t\tcontinue\n\t\t\t\t# suspend_late start\n\t\t\t\telif(re.match('dpm_suspend_late\\[.*', t.name)):\n\t\t\t\t\tphase = data.setPhase('suspend_late', t.time, isbegin)\n\t\t\t\t\tcontinue\n\t\t\t\t# suspend_noirq start\n\t\t\t\telif(re.match('dpm_suspend_noirq\\[.*', t.name)):\n\t\t\t\t\tphase = data.setPhase('suspend_noirq', t.time, isbegin)\n\t\t\t\t\tcontinue\n\t\t\t\t# suspend_machine/resume_machine\n\t\t\t\telif(re.match(tp.machinesuspend, t.name)):\n\t\t\t\t\tlp = data.lastPhase()\n\t\t\t\t\tif(isbegin):\n\t\t\t\t\t\thwsus = True\n\t\t\t\t\t\tif lp.startswith('resume_machine'):\n\t\t\t\t\t\t\t# trim out s2idle loops, track time trying to freeze\n\t\t\t\t\t\t\tllp = data.lastPhase(2)\n\t\t\t\t\t\t\tif llp.startswith('suspend_machine'):\n\t\t\t\t\t\t\t\tif 'waking' not in data.dmesg[llp]:\n\t\t\t\t\t\t\t\t\tdata.dmesg[llp]['waking'] = [0, 0.0]\n\t\t\t\t\t\t\t\tdata.dmesg[llp]['waking'][0] += 1\n\t\t\t\t\t\t\t\tdata.dmesg[llp]['waking'][1] += \\\n\t\t\t\t\t\t\t\t\tt.time - data.dmesg[lp]['start']\n\t\t\t\t\t\t\tdata.currphase = ''\n\t\t\t\t\t\t\tdel data.dmesg[lp]\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tphase = data.setPhase('suspend_machine', data.dmesg[lp]['end'], True)\n\t\t\t\t\t\tdata.setPhase(phase, t.time, False)\n\t\t\t\t\t\tif data.tSuspended == 0:\n\t\t\t\t\t\t\tdata.tSuspended = t.time\n\t\t\t\t\telse:\n\t\t\t\t\t\tif lp.startswith('resume_machine'):\n\t\t\t\t\t\t\tdata.dmesg[lp]['end'] = t.time\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tphase = data.setPhase('resume_machine', t.time, True)\n\t\t\t\t\t\tif(sysvals.suspendmode in ['mem', 'disk']):\n\t\t\t\t\t\t\tsusp = phase.replace('resume', 'suspend')\n\t\t\t\t\t\t\tif susp in data.dmesg:\n\t\t\t\t\t\t\t\tdata.dmesg[susp]['end'] = t.time\n\t\t\t\t\t\t\tdata.tSuspended = t.time\n\t\t\t\t\t\tdata.tResumed = t.time\n\t\t\t\t\tcontinue\n\t\t\t\t# resume_noirq start\n\t\t\t\telif(re.match('dpm_resume_noirq\\[.*', t.name)):\n\t\t\t\t\tphase = data.setPhase('resume_noirq', t.time, isbegin)\n\t\t\t\t\tcontinue\n\t\t\t\t# resume_early start\n\t\t\t\telif(re.match('dpm_resume_early\\[.*', t.name)):\n\t\t\t\t\tphase = data.setPhase('resume_early', t.time, isbegin)\n\t\t\t\t\tcontinue\n\t\t\t\t# resume start\n\t\t\t\telif(re.match('dpm_resume\\[.*', t.name)):\n\t\t\t\t\tphase = data.setPhase('resume', t.time, isbegin)\n\t\t\t\t\tcontinue\n\t\t\t\t# resume complete start\n\t\t\t\telif(re.match('dpm_complete\\[.*', t.name)):\n\t\t\t\t\tphase = data.setPhase('resume_complete', t.time, isbegin)\n\t\t\t\t\tcontinue\n\t\t\t\t# skip trace events inside devices calls\n\t\t\t\tif(not data.isTraceEventOutsideDeviceCalls(pid, t.time)):\n\t\t\t\t\tcontinue\n\t\t\t\t# global events (outside device calls) are graphed\n\t\t\t\tif(name not in testrun.ttemp):\n\t\t\t\t\ttestrun.ttemp[name] = []\n\t\t\t\t# special handling for s2idle_enter\n\t\t\t\tif name == 'machine_suspend':\n\t\t\t\t\tif hwsus:\n\t\t\t\t\t\ts2idle_enter = hwsus = False\n\t\t\t\t\telif s2idle_enter and not isbegin:\n\t\t\t\t\t\tif(len(testrun.ttemp[name]) > 0):\n\t\t\t\t\t\t\ttestrun.ttemp[name][-1]['end'] = t.time\n\t\t\t\t\t\t\ttestrun.ttemp[name][-1]['loop'] += 1\n\t\t\t\t\telif not s2idle_enter and isbegin:\n\t\t\t\t\t\ts2idle_enter = True\n\t\t\t\t\t\ttestrun.ttemp[name].append({'begin': t.time,\n\t\t\t\t\t\t\t'end': t.time, 'pid': pid, 'loop': 0})\n\t\t\t\t\tcontinue\n\t\t\t\tif(isbegin):\n\t\t\t\t\t# create a new list entry\n\t\t\t\t\ttestrun.ttemp[name].append(\\\n\t\t\t\t\t\t{'begin': t.time, 'end': t.time, 'pid': pid})\n\t\t\t\telse:\n\t\t\t\t\tif(len(testrun.ttemp[name]) > 0):\n\t\t\t\t\t\t# if an entry exists, assume this is its end\n\t\t\t\t\t\ttestrun.ttemp[name][-1]['end'] = t.time\n\t\t\t# device callback start\n\t\t\telif(t.type == 'device_pm_callback_start'):\n\t\t\t\tif phase not in data.dmesg:\n\t\t\t\t\tcontinue\n\t\t\t\tm = re.match('(?P<drv>.*) (?P<d>.*), parent: *(?P<p>.*), .*',\\\n\t\t\t\t\tt.name);\n\t\t\t\tif(not m):\n\t\t\t\t\tcontinue\n\t\t\t\tdrv = m.group('drv')\n\t\t\t\tn = m.group('d')\n\t\t\t\tp = m.group('p')\n\t\t\t\tif(n and p):\n\t\t\t\t\tdata.newAction(phase, n, pid, p, t.time, -1, drv)\n\t\t\t\t\tif pid not in data.devpids:\n\t\t\t\t\t\tdata.devpids.append(pid)\n\t\t\t# device callback finish\n\t\t\telif(t.type == 'device_pm_callback_end'):\n\t\t\t\tif phase not in data.dmesg:\n\t\t\t\t\tcontinue\n\t\t\t\tm = re.match('(?P<drv>.*) (?P<d>.*), err.*', t.name);\n\t\t\t\tif(not m):\n\t\t\t\t\tcontinue\n\t\t\t\tn = m.group('d')\n\t\t\t\tdev = data.findDevice(phase, n)\n\t\t\t\tif dev:\n\t\t\t\t\tdev['length'] = t.time - dev['start']\n\t\t\t\t\tdev['end'] = t.time\n\t\t# kprobe event processing\n\t\telif(t.fkprobe):\n\t\t\tkprobename = t.type\n\t\t\tkprobedata = t.name\n\t\t\tkey = (kprobename, pid)\n\t\t\t# displayname is generated from kprobe data\n\t\t\tdisplayname = ''\n\t\t\tif(t.fcall):\n\t\t\t\tdisplayname = sysvals.kprobeDisplayName(kprobename, kprobedata)\n\t\t\t\tif not displayname:\n\t\t\t\t\tcontinue\n\t\t\t\tif(key not in tp.ktemp):\n\t\t\t\t\ttp.ktemp[key] = []\n\t\t\t\ttp.ktemp[key].append({\n\t\t\t\t\t'pid': pid,\n\t\t\t\t\t'begin': t.time,\n\t\t\t\t\t'end': -1,\n\t\t\t\t\t'name': displayname,\n\t\t\t\t\t'cdata': kprobedata,\n\t\t\t\t\t'proc': m_proc,\n\t\t\t\t})\n\t\t\t\t# start of kernel resume\n\t\t\t\tif(data.tKernSus == 0 and phase == 'suspend_prepare' \\\n\t\t\t\t\tand kprobename in ksuscalls):\n\t\t\t\t\tdata.tKernSus = t.time\n\t\t\telif(t.freturn):\n\t\t\t\tif(key not in tp.ktemp) or len(tp.ktemp[key]) < 1:\n\t\t\t\t\tcontinue\n\t\t\t\te = next((x for x in reversed(tp.ktemp[key]) if x['end'] < 0), 0)\n\t\t\t\tif not e:\n\t\t\t\t\tcontinue\n\t\t\t\tif (t.time - e['begin']) * 1000 < sysvals.mindevlen:\n\t\t\t\t\ttp.ktemp[key].pop()\n\t\t\t\t\tcontinue\n\t\t\t\te['end'] = t.time\n\t\t\t\te['rdata'] = kprobedata\n\t\t\t\t# end of kernel resume\n\t\t\t\tif(phase != 'suspend_prepare' and kprobename in krescalls):\n\t\t\t\t\tif phase in data.dmesg:\n\t\t\t\t\t\tdata.dmesg[phase]['end'] = t.time\n\t\t\t\t\tdata.tKernRes = t.time\n\n\t\t# callgraph processing\n\t\telif sysvals.usecallgraph:\n\t\t\t# create a callgraph object for the data\n\t\t\tkey = (m_proc, pid)\n\t\t\tif(key not in testrun.ftemp):\n\t\t\t\ttestrun.ftemp[key] = []\n\t\t\t\ttestrun.ftemp[key].append(FTraceCallGraph(pid, sysvals))\n\t\t\t# when the call is finished, see which device matches it\n\t\t\tcg = testrun.ftemp[key][-1]\n\t\t\tres = cg.addLine(t)\n\t\t\tif(res != 0):\n\t\t\t\ttestrun.ftemp[key].append(FTraceCallGraph(pid, sysvals))\n\t\t\tif(res == -1):\n\t\t\t\ttestrun.ftemp[key][-1].addLine(t)\n\tif len(testdata) < 1:\n\t\tsysvals.vprint('WARNING: ftrace start marker is missing')\n\tif data and not data.devicegroups:\n\t\tsysvals.vprint('WARNING: ftrace end marker is missing')\n\t\tdata.handleEndMarker(t.time, t.name)\n\n\tif sysvals.suspendmode == 'command':\n\t\tfor test in testruns:\n\t\t\tfor p in test.data.sortedPhases():\n\t\t\t\tif p == 'suspend_prepare':\n\t\t\t\t\ttest.data.dmesg[p]['start'] = test.data.start\n\t\t\t\t\ttest.data.dmesg[p]['end'] = test.data.end\n\t\t\t\telse:\n\t\t\t\t\ttest.data.dmesg[p]['start'] = test.data.end\n\t\t\t\t\ttest.data.dmesg[p]['end'] = test.data.end\n\t\t\ttest.data.tSuspended = test.data.end\n\t\t\ttest.data.tResumed = test.data.end\n\t\t\ttest.data.fwValid = False\n\n\t# dev source and procmon events can be unreadable with mixed phase height\n\tif sysvals.usedevsrc or sysvals.useprocmon:\n\t\tsysvals.mixedphaseheight = False\n\n\t# expand phase boundaries so there are no gaps\n\tfor data in testdata:\n\t\tlp = data.sortedPhases()[0]\n\t\tfor p in data.sortedPhases():\n\t\t\tif(p != lp and not ('machine' in p and 'machine' in lp)):\n\t\t\t\tdata.dmesg[lp]['end'] = data.dmesg[p]['start']\n\t\t\tlp = p\n\n\tfor i in range(len(testruns)):\n\t\ttest = testruns[i]\n\t\tdata = test.data\n\t\t# find the total time range for this test (begin, end)\n\t\ttlb, tle = data.start, data.end\n\t\tif i < len(testruns) - 1:\n\t\t\ttle = testruns[i+1].data.start\n\t\t# add the process usage data to the timeline\n\t\tif sysvals.useprocmon:\n\t\t\tdata.createProcessUsageEvents()\n\t\t# add the traceevent data to the device hierarchy\n\t\tif(sysvals.usetraceevents):\n\t\t\t# add actual trace funcs\n\t\t\tfor name in sorted(test.ttemp):\n\t\t\t\tfor event in test.ttemp[name]:\n\t\t\t\t\tif event['end'] - event['begin'] <= 0:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\ttitle = name\n\t\t\t\t\tif name == 'machine_suspend' and 'loop' in event:\n\t\t\t\t\t\ttitle = 's2idle_enter_%dx' % event['loop']\n\t\t\t\t\tdata.newActionGlobal(title, event['begin'], event['end'], event['pid'])\n\t\t\t# add the kprobe based virtual tracefuncs as actual devices\n\t\t\tfor key in sorted(tp.ktemp):\n\t\t\t\tname, pid = key\n\t\t\t\tif name not in sysvals.tracefuncs:\n\t\t\t\t\tcontinue\n\t\t\t\tif pid not in data.devpids:\n\t\t\t\t\tdata.devpids.append(pid)\n\t\t\t\tfor e in tp.ktemp[key]:\n\t\t\t\t\tkb, ke = e['begin'], e['end']\n\t\t\t\t\tif ke - kb < 0.000001 or tlb > kb or tle <= kb:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tcolor = sysvals.kprobeColor(name)\n\t\t\t\t\tdata.newActionGlobal(e['name'], kb, ke, pid, color)\n\t\t\t# add config base kprobes and dev kprobes\n\t\t\tif sysvals.usedevsrc:\n\t\t\t\tfor key in sorted(tp.ktemp):\n\t\t\t\t\tname, pid = key\n\t\t\t\t\tif name in sysvals.tracefuncs or name not in sysvals.dev_tracefuncs:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tfor e in tp.ktemp[key]:\n\t\t\t\t\t\tkb, ke = e['begin'], e['end']\n\t\t\t\t\t\tif ke - kb < 0.000001 or tlb > kb or tle <= kb:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tdata.addDeviceFunctionCall(e['name'], name, e['proc'], pid, kb,\n\t\t\t\t\t\t\tke, e['cdata'], e['rdata'])\n\t\tif sysvals.usecallgraph:\n\t\t\t# add the callgraph data to the device hierarchy\n\t\t\tsortlist = dict()\n\t\t\tfor key in sorted(test.ftemp):\n\t\t\t\tproc, pid = key\n\t\t\t\tfor cg in test.ftemp[key]:\n\t\t\t\t\tif len(cg.list) < 1 or cg.invalid or (cg.end - cg.start == 0):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif(not cg.postProcess()):\n\t\t\t\t\t\tid = 'task %s' % (pid)\n\t\t\t\t\t\tsysvals.vprint('Sanity check failed for '+\\\n\t\t\t\t\t\t\tid+', ignoring this callback')\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t# match cg data to devices\n\t\t\t\t\tdevname = ''\n\t\t\t\t\tif sysvals.suspendmode != 'command':\n\t\t\t\t\t\tdevname = cg.deviceMatch(pid, data)\n\t\t\t\t\tif not devname:\n\t\t\t\t\t\tsortkey = '%f%f%d' % (cg.start, cg.end, pid)\n\t\t\t\t\t\tsortlist[sortkey] = cg\n\t\t\t\t\telif len(cg.list) > 1000000 and cg.name != sysvals.ftopfunc:\n\t\t\t\t\t\tsysvals.vprint('WARNING: the callgraph for %s is massive (%d lines)' %\\\n\t\t\t\t\t\t\t(devname, len(cg.list)))\n\t\t\t# create blocks for orphan cg data\n\t\t\tfor sortkey in sorted(sortlist):\n\t\t\t\tcg = sortlist[sortkey]\n\t\t\t\tname = cg.name\n\t\t\t\tif sysvals.isCallgraphFunc(name):\n\t\t\t\t\tsysvals.vprint('Callgraph found for task %d: %.3fms, %s' % (cg.pid, (cg.end - cg.start)*1000, name))\n\t\t\t\t\tcg.newActionFromFunction(data)\n\tif sysvals.suspendmode == 'command':\n\t\treturn (testdata, '')\n\n\t# fill in any missing phases\n\terror = []\n\tfor data in testdata:\n\t\ttn = '' if len(testdata) == 1 else ('%d' % (data.testnumber + 1))\n\t\tterr = ''\n\t\tphasedef = data.phasedef\n\t\tlp = 'suspend_prepare'\n\t\tfor p in sorted(phasedef, key=lambda k:phasedef[k]['order']):\n\t\t\tif p not in data.dmesg:\n\t\t\t\tif not terr:\n\t\t\t\t\tph = p if 'machine' in p else lp\n\t\t\t\t\tif p == 'suspend_machine':\n\t\t\t\t\t\tsm = sysvals.suspendmode\n\t\t\t\t\t\tif sm in suspendmodename:\n\t\t\t\t\t\t\tsm = suspendmodename[sm]\n\t\t\t\t\t\tterr = 'test%s did not enter %s power mode' % (tn, sm)\n\t\t\t\t\telse:\n\t\t\t\t\t\tterr = '%s%s failed in %s phase' % (sysvals.suspendmode, tn, ph)\n\t\t\t\t\tpprint('TEST%s FAILED: %s' % (tn, terr))\n\t\t\t\t\terror.append(terr)\n\t\t\t\t\tif data.tSuspended == 0:\n\t\t\t\t\t\tdata.tSuspended = data.dmesg[lp]['end']\n\t\t\t\t\tif data.tResumed == 0:\n\t\t\t\t\t\tdata.tResumed = data.dmesg[lp]['end']\n\t\t\t\t\tdata.fwValid = False\n\t\t\t\tsysvals.vprint('WARNING: phase \"%s\" is missing!' % p)\n\t\t\tlp = p\n\t\tif not terr and 'dev' in data.wifi and data.wifi['stat'] == 'timeout':\n\t\t\tterr = '%s%s failed in wifi_resume <i>(%s %.0fs timeout)</i>' % \\\n\t\t\t\t(sysvals.suspendmode, tn, data.wifi['dev'], data.wifi['time'])\n\t\t\terror.append(terr)\n\t\tif not terr and data.enterfail:\n\t\t\tpprint('test%s FAILED: enter %s failed with %s' % (tn, sysvals.suspendmode, data.enterfail))\n\t\t\tterr = 'test%s failed to enter %s mode' % (tn, sysvals.suspendmode)\n\t\t\terror.append(terr)\n\t\tif data.tSuspended == 0:\n\t\t\tdata.tSuspended = data.tKernRes\n\t\tif data.tResumed == 0:\n\t\t\tdata.tResumed = data.tSuspended\n\n\t\tif(len(sysvals.devicefilter) > 0):\n\t\t\tdata.deviceFilter(sysvals.devicefilter)\n\t\tdata.fixupInitcallsThatDidntReturn()\n\t\tif sysvals.usedevsrc:\n\t\t\tdata.optimizeDevSrc()\n\n\t# x2: merge any overlapping devices between test runs\n\tif sysvals.usedevsrc and len(testdata) > 1:\n\t\ttc = len(testdata)\n\t\tfor i in range(tc - 1):\n\t\t\tdevlist = testdata[i].overflowDevices()\n\t\t\tfor j in range(i + 1, tc):\n\t\t\t\ttestdata[j].mergeOverlapDevices(devlist)\n\t\ttestdata[0].stitchTouchingThreads(testdata[1:])\n\treturn (testdata, ', '.join(error))\n\n# Function: loadKernelLog\n# Description:\n#\t load the dmesg file into memory and fix up any ordering issues\n# Output:\n#\t An array of empty Data objects with only their dmesgtext attributes set\ndef loadKernelLog():\n\tsysvals.vprint('Analyzing the dmesg data (%s)...' % \\\n\t\tos.path.basename(sysvals.dmesgfile))\n\tif(os.path.exists(sysvals.dmesgfile) == False):\n\t\tdoError('%s does not exist' % sysvals.dmesgfile)\n\n\t# there can be multiple test runs in a single file\n\ttp = TestProps()\n\ttp.stamp = datetime.now().strftime('# suspend-%m%d%y-%H%M%S localhost mem unknown')\n\ttestruns = []\n\tdata = 0\n\tlf = sysvals.openlog(sysvals.dmesgfile, 'r')\n\tfor line in lf:\n\t\tline = line.replace('\\r\\n', '')\n\t\tidx = line.find('[')\n\t\tif idx > 1:\n\t\t\tline = line[idx:]\n\t\tif tp.stampInfo(line, sysvals):\n\t\t\tcontinue\n\t\tm = re.match('[ \\t]*(\\[ *)(?P<ktime>[0-9\\.]*)(\\]) (?P<msg>.*)', line)\n\t\tif(not m):\n\t\t\tcontinue\n\t\tmsg = m.group(\"msg\")\n\t\tif re.match('PM: Syncing filesystems.*', msg) or \\\n\t\t\tre.match('PM: suspend entry.*', msg):\n\t\t\tif(data):\n\t\t\t\ttestruns.append(data)\n\t\t\tdata = Data(len(testruns))\n\t\t\ttp.parseStamp(data, sysvals)\n\t\tif(not data):\n\t\t\tcontinue\n\t\tm = re.match('.* *(?P<k>[0-9]\\.[0-9]{2}\\.[0-9]-.*) .*', msg)\n\t\tif(m):\n\t\t\tsysvals.stamp['kernel'] = m.group('k')\n\t\tm = re.match('PM: Preparing system for (?P<m>.*) sleep', msg)\n\t\tif not m:\n\t\t\tm = re.match('PM: Preparing system for sleep \\((?P<m>.*)\\)', msg)\n\t\tif m:\n\t\t\tsysvals.stamp['mode'] = sysvals.suspendmode = m.group('m')\n\t\tdata.dmesgtext.append(line)\n\tlf.close()\n\n\tif sysvals.suspendmode == 's2idle':\n\t\tsysvals.suspendmode = 'freeze'\n\telif sysvals.suspendmode == 'deep':\n\t\tsysvals.suspendmode = 'mem'\n\tif data:\n\t\ttestruns.append(data)\n\tif len(testruns) < 1:\n\t\tdoError('dmesg log has no suspend/resume data: %s' \\\n\t\t\t% sysvals.dmesgfile)\n\n\t# fix lines with same timestamp/function with the call and return swapped\n\tfor data in testruns:\n\t\tlast = ''\n\t\tfor line in data.dmesgtext:\n\t\t\tct, cf, n, p = data.initcall_debug_call(line)\n\t\t\trt, rf, l = data.initcall_debug_return(last)\n\t\t\tif ct and rt and ct == rt and cf == rf:\n\t\t\t\ti = data.dmesgtext.index(last)\n\t\t\t\tj = data.dmesgtext.index(line)\n\t\t\t\tdata.dmesgtext[i] = line\n\t\t\t\tdata.dmesgtext[j] = last\n\t\t\tlast = line\n\treturn testruns\n\n# Function: parseKernelLog\n# Description:\n#\t Analyse a dmesg log output file generated from this app during\n#\t the execution phase. Create a set of device structures in memory\n#\t for subsequent formatting in the html output file\n#\t This call is only for legacy support on kernels where the ftrace\n#\t data lacks the suspend_resume or device_pm_callbacks trace events.\n# Arguments:\n#\t data: an empty Data object (with dmesgtext) obtained from loadKernelLog\n# Output:\n#\t The filled Data object\ndef parseKernelLog(data):\n\tphase = 'suspend_runtime'\n\n\tif(data.fwValid):\n\t\tsysvals.vprint('Firmware Suspend = %u ns, Firmware Resume = %u ns' % \\\n\t\t\t(data.fwSuspend, data.fwResume))\n\n\t# dmesg phase match table\n\tdm = {\n\t\t'suspend_prepare': ['PM: Syncing filesystems.*', 'PM: suspend entry.*'],\n\t\t        'suspend': ['PM: Entering [a-z]* sleep.*', 'Suspending console.*',\n\t\t                    'PM: Suspending system .*'],\n\t\t   'suspend_late': ['PM: suspend of devices complete after.*',\n\t\t\t\t\t\t\t'PM: freeze of devices complete after.*'],\n\t\t  'suspend_noirq': ['PM: late suspend of devices complete after.*',\n\t\t\t\t\t\t\t'PM: late freeze of devices complete after.*'],\n\t\t'suspend_machine': ['PM: suspend-to-idle',\n\t\t\t\t\t\t\t'PM: noirq suspend of devices complete after.*',\n\t\t\t\t\t\t\t'PM: noirq freeze of devices complete after.*'],\n\t\t 'resume_machine': ['[PM: ]*Timekeeping suspended for.*',\n\t\t\t\t\t\t\t'ACPI: Low-level resume complete.*',\n\t\t\t\t\t\t\t'ACPI: resume from mwait',\n\t\t\t\t\t\t\t'Suspended for [0-9\\.]* seconds'],\n\t\t   'resume_noirq': ['PM: resume from suspend-to-idle',\n\t\t\t\t\t\t\t'ACPI: Waking up from system sleep state.*'],\n\t\t   'resume_early': ['PM: noirq resume of devices complete after.*',\n\t\t\t\t\t\t\t'PM: noirq restore of devices complete after.*'],\n\t\t         'resume': ['PM: early resume of devices complete after.*',\n\t\t\t\t\t\t\t'PM: early restore of devices complete after.*'],\n\t\t'resume_complete': ['PM: resume of devices complete after.*',\n\t\t\t\t\t\t\t'PM: restore of devices complete after.*'],\n\t\t    'post_resume': ['.*Restarting tasks \\.\\.\\..*'],\n\t}\n\n\t# action table (expected events that occur and show up in dmesg)\n\tat = {\n\t\t'sync_filesystems': {\n\t\t\t'smsg': '.*[Ff]+ilesystems.*',\n\t\t\t'emsg': 'PM: Preparing system for[a-z]* sleep.*' },\n\t\t'freeze_user_processes': {\n\t\t\t'smsg': 'Freezing user space processes.*',\n\t\t\t'emsg': 'Freezing remaining freezable tasks.*' },\n\t\t'freeze_tasks': {\n\t\t\t'smsg': 'Freezing remaining freezable tasks.*',\n\t\t\t'emsg': 'PM: Suspending system.*' },\n\t\t'ACPI prepare': {\n\t\t\t'smsg': 'ACPI: Preparing to enter system sleep state.*',\n\t\t\t'emsg': 'PM: Saving platform NVS memory.*' },\n\t\t'PM vns': {\n\t\t\t'smsg': 'PM: Saving platform NVS memory.*',\n\t\t\t'emsg': 'Disabling non-boot CPUs .*' },\n\t}\n\n\tt0 = -1.0\n\tcpu_start = -1.0\n\tprevktime = -1.0\n\tactions = dict()\n\tfor line in data.dmesgtext:\n\t\t# parse each dmesg line into the time and message\n\t\tm = re.match('[ \\t]*(\\[ *)(?P<ktime>[0-9\\.]*)(\\]) (?P<msg>.*)', line)\n\t\tif(m):\n\t\t\tval = m.group('ktime')\n\t\t\ttry:\n\t\t\t\tktime = float(val)\n\t\t\texcept:\n\t\t\t\tcontinue\n\t\t\tmsg = m.group('msg')\n\t\t\t# initialize data start to first line time\n\t\t\tif t0 < 0:\n\t\t\t\tdata.setStart(ktime)\n\t\t\t\tt0 = ktime\n\t\telse:\n\t\t\tcontinue\n\n\t\t# check for a phase change line\n\t\tphasechange = False\n\t\tfor p in dm:\n\t\t\tfor s in dm[p]:\n\t\t\t\tif(re.match(s, msg)):\n\t\t\t\t\tphasechange, phase = True, p\n\t\t\t\t\tdm[p] = [s]\n\t\t\t\t\tbreak\n\n\t\t# hack for determining resume_machine end for freeze\n\t\tif(not sysvals.usetraceevents and sysvals.suspendmode == 'freeze' \\\n\t\t\tand phase == 'resume_machine' and \\\n\t\t\tdata.initcall_debug_call(line, True)):\n\t\t\tdata.setPhase(phase, ktime, False)\n\t\t\tphase = 'resume_noirq'\n\t\t\tdata.setPhase(phase, ktime, True)\n\n\t\tif phasechange:\n\t\t\tif phase == 'suspend_prepare':\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\t\tdata.setStart(ktime)\n\t\t\t\tdata.tKernSus = ktime\n\t\t\telif phase == 'suspend':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif lp:\n\t\t\t\t\tdata.setPhase(lp, ktime, False)\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\telif phase == 'suspend_late':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif lp:\n\t\t\t\t\tdata.setPhase(lp, ktime, False)\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\telif phase == 'suspend_noirq':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif lp:\n\t\t\t\t\tdata.setPhase(lp, ktime, False)\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\telif phase == 'suspend_machine':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif lp:\n\t\t\t\t\tdata.setPhase(lp, ktime, False)\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\telif phase == 'resume_machine':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif(sysvals.suspendmode in ['freeze', 'standby']):\n\t\t\t\t\tdata.tSuspended = prevktime\n\t\t\t\t\tif lp:\n\t\t\t\t\t\tdata.setPhase(lp, prevktime, False)\n\t\t\t\telse:\n\t\t\t\t\tdata.tSuspended = ktime\n\t\t\t\t\tif lp:\n\t\t\t\t\t\tdata.setPhase(lp, prevktime, False)\n\t\t\t\tdata.tResumed = ktime\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\telif phase == 'resume_noirq':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif lp:\n\t\t\t\t\tdata.setPhase(lp, ktime, False)\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\telif phase == 'resume_early':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif lp:\n\t\t\t\t\tdata.setPhase(lp, ktime, False)\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\telif phase == 'resume':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif lp:\n\t\t\t\t\tdata.setPhase(lp, ktime, False)\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\telif phase == 'resume_complete':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif lp:\n\t\t\t\t\tdata.setPhase(lp, ktime, False)\n\t\t\t\tdata.setPhase(phase, ktime, True)\n\t\t\telif phase == 'post_resume':\n\t\t\t\tlp = data.lastPhase()\n\t\t\t\tif lp:\n\t\t\t\t\tdata.setPhase(lp, ktime, False)\n\t\t\t\tdata.setEnd(ktime)\n\t\t\t\tdata.tKernRes = ktime\n\t\t\t\tbreak\n\n\t\t# -- device callbacks --\n\t\tif(phase in data.sortedPhases()):\n\t\t\t# device init call\n\t\t\tt, f, n, p = data.initcall_debug_call(line)\n\t\t\tif t and f and n and p:\n\t\t\t\tdata.newAction(phase, f, int(n), p, ktime, -1, '')\n\t\t\telse:\n\t\t\t\t# device init return\n\t\t\t\tt, f, l = data.initcall_debug_return(line)\n\t\t\t\tif t and f and l:\n\t\t\t\t\tlist = data.dmesg[phase]['list']\n\t\t\t\t\tif(f in list):\n\t\t\t\t\t\tdev = list[f]\n\t\t\t\t\t\tdev['length'] = int(l)\n\t\t\t\t\t\tdev['end'] = ktime\n\n\t\t# if trace events are not available, these are better than nothing\n\t\tif(not sysvals.usetraceevents):\n\t\t\t# look for known actions\n\t\t\tfor a in sorted(at):\n\t\t\t\tif(re.match(at[a]['smsg'], msg)):\n\t\t\t\t\tif(a not in actions):\n\t\t\t\t\t\tactions[a] = [{'begin': ktime, 'end': ktime}]\n\t\t\t\tif(re.match(at[a]['emsg'], msg)):\n\t\t\t\t\tif(a in actions and actions[a][-1]['begin'] == actions[a][-1]['end']):\n\t\t\t\t\t\tactions[a][-1]['end'] = ktime\n\t\t\t# now look for CPU on/off events\n\t\t\tif(re.match('Disabling non-boot CPUs .*', msg)):\n\t\t\t\t# start of first cpu suspend\n\t\t\t\tcpu_start = ktime\n\t\t\telif(re.match('Enabling non-boot CPUs .*', msg)):\n\t\t\t\t# start of first cpu resume\n\t\t\t\tcpu_start = ktime\n\t\t\telif(re.match('smpboot: CPU (?P<cpu>[0-9]*) is now offline', msg) \\\n\t\t\t\tor re.match('psci: CPU(?P<cpu>[0-9]*) killed.*', msg)):\n\t\t\t\t# end of a cpu suspend, start of the next\n\t\t\t\tm = re.match('smpboot: CPU (?P<cpu>[0-9]*) is now offline', msg)\n\t\t\t\tif(not m):\n\t\t\t\t\tm = re.match('psci: CPU(?P<cpu>[0-9]*) killed.*', msg)\n\t\t\t\tcpu = 'CPU'+m.group('cpu')\n\t\t\t\tif(cpu not in actions):\n\t\t\t\t\tactions[cpu] = []\n\t\t\t\tactions[cpu].append({'begin': cpu_start, 'end': ktime})\n\t\t\t\tcpu_start = ktime\n\t\t\telif(re.match('CPU(?P<cpu>[0-9]*) is up', msg)):\n\t\t\t\t# end of a cpu resume, start of the next\n\t\t\t\tm = re.match('CPU(?P<cpu>[0-9]*) is up', msg)\n\t\t\t\tcpu = 'CPU'+m.group('cpu')\n\t\t\t\tif(cpu not in actions):\n\t\t\t\t\tactions[cpu] = []\n\t\t\t\tactions[cpu].append({'begin': cpu_start, 'end': ktime})\n\t\t\t\tcpu_start = ktime\n\t\tprevktime = ktime\n\tdata.initDevicegroups()\n\n\t# fill in any missing phases\n\tphasedef = data.phasedef\n\tterr, lp = '', 'suspend_prepare'\n\tif lp not in data.dmesg:\n\t\tdoError('dmesg log format has changed, could not find start of suspend')\n\tfor p in sorted(phasedef, key=lambda k:phasedef[k]['order']):\n\t\tif p not in data.dmesg:\n\t\t\tif not terr:\n\t\t\t\tpprint('TEST FAILED: %s failed in %s phase' % (sysvals.suspendmode, lp))\n\t\t\t\tterr = '%s failed in %s phase' % (sysvals.suspendmode, lp)\n\t\t\t\tif data.tSuspended == 0:\n\t\t\t\t\tdata.tSuspended = data.dmesg[lp]['end']\n\t\t\t\tif data.tResumed == 0:\n\t\t\t\t\tdata.tResumed = data.dmesg[lp]['end']\n\t\t\tsysvals.vprint('WARNING: phase \"%s\" is missing!' % p)\n\t\tlp = p\n\tlp = data.sortedPhases()[0]\n\tfor p in data.sortedPhases():\n\t\tif(p != lp and not ('machine' in p and 'machine' in lp)):\n\t\t\tdata.dmesg[lp]['end'] = data.dmesg[p]['start']\n\t\tlp = p\n\tif data.tSuspended == 0:\n\t\tdata.tSuspended = data.tKernRes\n\tif data.tResumed == 0:\n\t\tdata.tResumed = data.tSuspended\n\n\t# fill in any actions we've found\n\tfor name in sorted(actions):\n\t\tfor event in actions[name]:\n\t\t\tdata.newActionGlobal(name, event['begin'], event['end'])\n\n\tif(len(sysvals.devicefilter) > 0):\n\t\tdata.deviceFilter(sysvals.devicefilter)\n\tdata.fixupInitcallsThatDidntReturn()\n\treturn True\n\ndef callgraphHTML(sv, hf, num, cg, title, color, devid):\n\thtml_func_top = '<article id=\"{0}\" class=\"atop\" style=\"background:{1}\">\\n<input type=\"checkbox\" class=\"pf\" id=\"f{2}\" checked/><label for=\"f{2}\">{3} {4}</label>\\n'\n\thtml_func_start = '<article>\\n<input type=\"checkbox\" class=\"pf\" id=\"f{0}\" checked/><label for=\"f{0}\">{1} {2}</label>\\n'\n\thtml_func_end = '</article>\\n'\n\thtml_func_leaf = '<article>{0} {1}</article>\\n'\n\n\tcgid = devid\n\tif cg.id:\n\t\tcgid += cg.id\n\tcglen = (cg.end - cg.start) * 1000\n\tif cglen < sv.mincglen:\n\t\treturn num\n\n\tfmt = '<r>(%.3f ms @ '+sv.timeformat+' to '+sv.timeformat+')</r>'\n\tflen = fmt % (cglen, cg.start, cg.end)\n\thf.write(html_func_top.format(cgid, color, num, title, flen))\n\tnum += 1\n\tfor line in cg.list:\n\t\tif(line.length < 0.000000001):\n\t\t\tflen = ''\n\t\telse:\n\t\t\tfmt = '<n>(%.3f ms @ '+sv.timeformat+')</n>'\n\t\t\tflen = fmt % (line.length*1000, line.time)\n\t\tif line.isLeaf():\n\t\t\tif line.length * 1000 < sv.mincglen:\n\t\t\t\tcontinue\n\t\t\thf.write(html_func_leaf.format(line.name, flen))\n\t\telif line.freturn:\n\t\t\thf.write(html_func_end)\n\t\telse:\n\t\t\thf.write(html_func_start.format(num, line.name, flen))\n\t\t\tnum += 1\n\thf.write(html_func_end)\n\treturn num\n\ndef addCallgraphs(sv, hf, data):\n\thf.write('<section id=\"callgraphs\" class=\"callgraph\">\\n')\n\t# write out the ftrace data converted to html\n\tnum = 0\n\tfor p in data.sortedPhases():\n\t\tif sv.cgphase and p != sv.cgphase:\n\t\t\tcontinue\n\t\tlist = data.dmesg[p]['list']\n\t\tfor d in data.sortedDevices(p):\n\t\t\tif len(sv.cgfilter) > 0 and d not in sv.cgfilter:\n\t\t\t\tcontinue\n\t\t\tdev = list[d]\n\t\t\tcolor = 'white'\n\t\t\tif 'color' in data.dmesg[p]:\n\t\t\t\tcolor = data.dmesg[p]['color']\n\t\t\tif 'color' in dev:\n\t\t\t\tcolor = dev['color']\n\t\t\tname = d if '[' not in d else d.split('[')[0]\n\t\t\tif(d in sv.devprops):\n\t\t\t\tname = sv.devprops[d].altName(d)\n\t\t\tif 'drv' in dev and dev['drv']:\n\t\t\t\tname += ' {%s}' % dev['drv']\n\t\t\tif sv.suspendmode in suspendmodename:\n\t\t\t\tname += ' '+p\n\t\t\tif('ftrace' in dev):\n\t\t\t\tcg = dev['ftrace']\n\t\t\t\tif cg.name == sv.ftopfunc:\n\t\t\t\t\tname = 'top level suspend/resume call'\n\t\t\t\tnum = callgraphHTML(sv, hf, num, cg,\n\t\t\t\t\tname, color, dev['id'])\n\t\t\tif('ftraces' in dev):\n\t\t\t\tfor cg in dev['ftraces']:\n\t\t\t\t\tnum = callgraphHTML(sv, hf, num, cg,\n\t\t\t\t\t\tname+' &rarr; '+cg.name, color, dev['id'])\n\thf.write('\\n\\n    </section>\\n')\n\ndef summaryCSS(title, center=True):\n\ttdcenter = 'text-align:center;' if center else ''\n\tout = '<!DOCTYPE html>\\n<html>\\n<head>\\n\\\n\t<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\\n\\\n\t<title>'+title+'</title>\\n\\\n\t<style type=\\'text/css\\'>\\n\\\n\t\t.stamp {width: 100%;text-align:center;background:#888;line-height:30px;color:white;font: 25px Arial;}\\n\\\n\t\ttable {width:100%;border-collapse: collapse;border:1px solid;}\\n\\\n\t\tth {border: 1px solid black;background:#222;color:white;}\\n\\\n\t\ttd {font: 14px \"Times New Roman\";'+tdcenter+'}\\n\\\n\t\ttr.head td {border: 1px solid black;background:#aaa;}\\n\\\n\t\ttr.alt {background-color:#ddd;}\\n\\\n\t\ttr.notice {color:red;}\\n\\\n\t\t.minval {background-color:#BBFFBB;}\\n\\\n\t\t.medval {background-color:#BBBBFF;}\\n\\\n\t\t.maxval {background-color:#FFBBBB;}\\n\\\n\t\t.head a {color:#000;text-decoration: none;}\\n\\\n\t</style>\\n</head>\\n<body>\\n'\n\treturn out\n\n# Function: createHTMLSummarySimple\n# Description:\n#\t Create summary html file for a series of tests\n# Arguments:\n#\t testruns: array of Data objects from parseTraceLog\ndef createHTMLSummarySimple(testruns, htmlfile, title):\n\t# write the html header first (html head, css code, up to body start)\n\thtml = summaryCSS('Summary - SleepGraph')\n\n\t# extract the test data into list\n\tlist = dict()\n\ttAvg, tMin, tMax, tMed = [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [dict(), dict()]\n\tiMin, iMed, iMax = [0, 0], [0, 0], [0, 0]\n\tnum = 0\n\tuseturbo = usewifi = False\n\tlastmode = ''\n\tcnt = dict()\n\tfor data in sorted(testruns, key=lambda v:(v['mode'], v['host'], v['kernel'], v['time'])):\n\t\tmode = data['mode']\n\t\tif mode not in list:\n\t\t\tlist[mode] = {'data': [], 'avg': [0,0], 'min': [0,0], 'max': [0,0], 'med': [0,0]}\n\t\tif lastmode and lastmode != mode and num > 0:\n\t\t\tfor i in range(2):\n\t\t\t\ts = sorted(tMed[i])\n\t\t\t\tlist[lastmode]['med'][i] = s[int(len(s)//2)]\n\t\t\t\tiMed[i] = tMed[i][list[lastmode]['med'][i]]\n\t\t\tlist[lastmode]['avg'] = [tAvg[0] / num, tAvg[1] / num]\n\t\t\tlist[lastmode]['min'] = tMin\n\t\t\tlist[lastmode]['max'] = tMax\n\t\t\tlist[lastmode]['idx'] = (iMin, iMed, iMax)\n\t\t\ttAvg, tMin, tMax, tMed = [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [dict(), dict()]\n\t\t\tiMin, iMed, iMax = [0, 0], [0, 0], [0, 0]\n\t\t\tnum = 0\n\t\tpkgpc10 = syslpi = wifi = ''\n\t\tif 'pkgpc10' in data and 'syslpi' in data:\n\t\t\tpkgpc10, syslpi, useturbo = data['pkgpc10'], data['syslpi'], True\n\t\tif 'wifi' in data:\n\t\t\twifi, usewifi = data['wifi'], True\n\t\tres = data['result']\n\t\ttVal = [float(data['suspend']), float(data['resume'])]\n\t\tlist[mode]['data'].append([data['host'], data['kernel'],\n\t\t\tdata['time'], tVal[0], tVal[1], data['url'], res,\n\t\t\tdata['issues'], data['sus_worst'], data['sus_worsttime'],\n\t\t\tdata['res_worst'], data['res_worsttime'], pkgpc10, syslpi, wifi])\n\t\tidx = len(list[mode]['data']) - 1\n\t\tif res.startswith('fail in'):\n\t\t\tres = 'fail'\n\t\tif res not in cnt:\n\t\t\tcnt[res] = 1\n\t\telse:\n\t\t\tcnt[res] += 1\n\t\tif res == 'pass':\n\t\t\tfor i in range(2):\n\t\t\t\ttMed[i][tVal[i]] = idx\n\t\t\t\ttAvg[i] += tVal[i]\n\t\t\t\tif tMin[i] == 0 or tVal[i] < tMin[i]:\n\t\t\t\t\tiMin[i] = idx\n\t\t\t\t\ttMin[i] = tVal[i]\n\t\t\t\tif tMax[i] == 0 or tVal[i] > tMax[i]:\n\t\t\t\t\tiMax[i] = idx\n\t\t\t\t\ttMax[i] = tVal[i]\n\t\t\tnum += 1\n\t\tlastmode = mode\n\tif lastmode and num > 0:\n\t\tfor i in range(2):\n\t\t\ts = sorted(tMed[i])\n\t\t\tlist[lastmode]['med'][i] = s[int(len(s)//2)]\n\t\t\tiMed[i] = tMed[i][list[lastmode]['med'][i]]\n\t\tlist[lastmode]['avg'] = [tAvg[0] / num, tAvg[1] / num]\n\t\tlist[lastmode]['min'] = tMin\n\t\tlist[lastmode]['max'] = tMax\n\t\tlist[lastmode]['idx'] = (iMin, iMed, iMax)\n\n\t# group test header\n\tdesc = []\n\tfor ilk in sorted(cnt, reverse=True):\n\t\tif cnt[ilk] > 0:\n\t\t\tdesc.append('%d %s' % (cnt[ilk], ilk))\n\thtml += '<div class=\"stamp\">%s (%d tests: %s)</div>\\n' % (title, len(testruns), ', '.join(desc))\n\tth = '\\t<th>{0}</th>\\n'\n\ttd = '\\t<td>{0}</td>\\n'\n\ttdh = '\\t<td{1}>{0}</td>\\n'\n\ttdlink = '\\t<td><a href=\"{0}\">html</a></td>\\n'\n\tcols = 12\n\tif useturbo:\n\t\tcols += 2\n\tif usewifi:\n\t\tcols += 1\n\tcolspan = '%d' % cols\n\n\t# table header\n\thtml += '<table>\\n<tr>\\n' + th.format('#') +\\\n\t\tth.format('Mode') + th.format('Host') + th.format('Kernel') +\\\n\t\tth.format('Test Time') + th.format('Result') + th.format('Issues') +\\\n\t\tth.format('Suspend') + th.format('Resume') +\\\n\t\tth.format('Worst Suspend Device') + th.format('SD Time') +\\\n\t\tth.format('Worst Resume Device') + th.format('RD Time')\n\tif useturbo:\n\t\thtml += th.format('PkgPC10') + th.format('SysLPI')\n\tif usewifi:\n\t\thtml += th.format('Wifi')\n\thtml += th.format('Detail')+'</tr>\\n'\n\t# export list into html\n\thead = '<tr class=\"head\"><td>{0}</td><td>{1}</td>'+\\\n\t\t'<td colspan='+colspan+' class=\"sus\">Suspend Avg={2} '+\\\n\t\t'<span class=minval><a href=\"#s{10}min\">Min={3}</a></span> '+\\\n\t\t'<span class=medval><a href=\"#s{10}med\">Med={4}</a></span> '+\\\n\t\t'<span class=maxval><a href=\"#s{10}max\">Max={5}</a></span> '+\\\n\t\t'Resume Avg={6} '+\\\n\t\t'<span class=minval><a href=\"#r{10}min\">Min={7}</a></span> '+\\\n\t\t'<span class=medval><a href=\"#r{10}med\">Med={8}</a></span> '+\\\n\t\t'<span class=maxval><a href=\"#r{10}max\">Max={9}</a></span></td>'+\\\n\t\t'</tr>\\n'\n\theadnone = '<tr class=\"head\"><td>{0}</td><td>{1}</td><td colspan='+\\\n\t\tcolspan+'></td></tr>\\n'\n\tfor mode in sorted(list):\n\t\t# header line for each suspend mode\n\t\tnum = 0\n\t\ttAvg, tMin, tMax, tMed = list[mode]['avg'], list[mode]['min'],\\\n\t\t\tlist[mode]['max'], list[mode]['med']\n\t\tcount = len(list[mode]['data'])\n\t\tif 'idx' in list[mode]:\n\t\t\tiMin, iMed, iMax = list[mode]['idx']\n\t\t\thtml += head.format('%d' % count, mode.upper(),\n\t\t\t\t'%.3f' % tAvg[0], '%.3f' % tMin[0], '%.3f' % tMed[0], '%.3f' % tMax[0],\n\t\t\t\t'%.3f' % tAvg[1], '%.3f' % tMin[1], '%.3f' % tMed[1], '%.3f' % tMax[1],\n\t\t\t\tmode.lower()\n\t\t\t)\n\t\telse:\n\t\t\tiMin = iMed = iMax = [-1, -1, -1]\n\t\t\thtml += headnone.format('%d' % count, mode.upper())\n\t\tfor d in list[mode]['data']:\n\t\t\t# row classes - alternate row color\n\t\t\trcls = ['alt'] if num % 2 == 1 else []\n\t\t\tif d[6] != 'pass':\n\t\t\t\trcls.append('notice')\n\t\t\thtml += '<tr class=\"'+(' '.join(rcls))+'\">\\n' if len(rcls) > 0 else '<tr>\\n'\n\t\t\t# figure out if the line has sus or res highlighted\n\t\t\tidx = list[mode]['data'].index(d)\n\t\t\ttHigh = ['', '']\n\t\t\tfor i in range(2):\n\t\t\t\ttag = 's%s' % mode if i == 0 else 'r%s' % mode\n\t\t\t\tif idx == iMin[i]:\n\t\t\t\t\ttHigh[i] = ' id=\"%smin\" class=minval title=\"Minimum\"' % tag\n\t\t\t\telif idx == iMax[i]:\n\t\t\t\t\ttHigh[i] = ' id=\"%smax\" class=maxval title=\"Maximum\"' % tag\n\t\t\t\telif idx == iMed[i]:\n\t\t\t\t\ttHigh[i] = ' id=\"%smed\" class=medval title=\"Median\"' % tag\n\t\t\thtml += td.format(\"%d\" % (list[mode]['data'].index(d) + 1)) # row\n\t\t\thtml += td.format(mode)\t\t\t\t\t\t\t\t\t\t# mode\n\t\t\thtml += td.format(d[0])\t\t\t\t\t\t\t\t\t\t# host\n\t\t\thtml += td.format(d[1])\t\t\t\t\t\t\t\t\t\t# kernel\n\t\t\thtml += td.format(d[2])\t\t\t\t\t\t\t\t\t\t# time\n\t\t\thtml += td.format(d[6])\t\t\t\t\t\t\t\t\t\t# result\n\t\t\thtml += td.format(d[7])\t\t\t\t\t\t\t\t\t\t# issues\n\t\t\thtml += tdh.format('%.3f ms' % d[3], tHigh[0]) if d[3] else td.format('')\t# suspend\n\t\t\thtml += tdh.format('%.3f ms' % d[4], tHigh[1]) if d[4] else td.format('')\t# resume\n\t\t\thtml += td.format(d[8])\t\t\t\t\t\t\t\t\t\t# sus_worst\n\t\t\thtml += td.format('%.3f ms' % d[9])\tif d[9] else td.format('')\t\t# sus_worst time\n\t\t\thtml += td.format(d[10])\t\t\t\t\t\t\t\t\t# res_worst\n\t\t\thtml += td.format('%.3f ms' % d[11]) if d[11] else td.format('')\t# res_worst time\n\t\t\tif useturbo:\n\t\t\t\thtml += td.format(d[12])\t\t\t\t\t\t\t\t# pkg_pc10\n\t\t\t\thtml += td.format(d[13])\t\t\t\t\t\t\t\t# syslpi\n\t\t\tif usewifi:\n\t\t\t\thtml += td.format(d[14])\t\t\t\t\t\t\t\t# wifi\n\t\t\thtml += tdlink.format(d[5]) if d[5] else td.format('')\t\t# url\n\t\t\thtml += '</tr>\\n'\n\t\t\tnum += 1\n\n\t# flush the data to file\n\thf = open(htmlfile, 'w')\n\thf.write(html+'</table>\\n</body>\\n</html>\\n')\n\thf.close()\n\ndef createHTMLDeviceSummary(testruns, htmlfile, title):\n\thtml = summaryCSS('Device Summary - SleepGraph', False)\n\n\t# create global device list from all tests\n\tdevall = dict()\n\tfor data in testruns:\n\t\thost, url, devlist = data['host'], data['url'], data['devlist']\n\t\tfor type in devlist:\n\t\t\tif type not in devall:\n\t\t\t\tdevall[type] = dict()\n\t\t\tmdevlist, devlist = devall[type], data['devlist'][type]\n\t\t\tfor name in devlist:\n\t\t\t\tlength = devlist[name]\n\t\t\t\tif name not in mdevlist:\n\t\t\t\t\tmdevlist[name] = {'name': name, 'host': host,\n\t\t\t\t\t\t'worst': length, 'total': length, 'count': 1,\n\t\t\t\t\t\t'url': url}\n\t\t\t\telse:\n\t\t\t\t\tif length > mdevlist[name]['worst']:\n\t\t\t\t\t\tmdevlist[name]['worst'] = length\n\t\t\t\t\t\tmdevlist[name]['url'] = url\n\t\t\t\t\t\tmdevlist[name]['host'] = host\n\t\t\t\t\tmdevlist[name]['total'] += length\n\t\t\t\t\tmdevlist[name]['count'] += 1\n\n\t# generate the html\n\tth = '\\t<th>{0}</th>\\n'\n\ttd = '\\t<td align=center>{0}</td>\\n'\n\ttdr = '\\t<td align=right>{0}</td>\\n'\n\ttdlink = '\\t<td align=center><a href=\"{0}\">html</a></td>\\n'\n\tlimit = 1\n\tfor type in sorted(devall, reverse=True):\n\t\tnum = 0\n\t\tdevlist = devall[type]\n\t\t# table header\n\t\thtml += '<div class=\"stamp\">%s (%s devices > %d ms)</div><table>\\n' % \\\n\t\t\t(title, type.upper(), limit)\n\t\thtml += '<tr>\\n' + '<th align=right>Device Name</th>' +\\\n\t\t\tth.format('Average Time') + th.format('Count') +\\\n\t\t\tth.format('Worst Time') + th.format('Host (worst time)') +\\\n\t\t\tth.format('Link (worst time)') + '</tr>\\n'\n\t\tfor name in sorted(devlist, key=lambda k:(devlist[k]['worst'], \\\n\t\t\tdevlist[k]['total'], devlist[k]['name']), reverse=True):\n\t\t\tdata = devall[type][name]\n\t\t\tdata['average'] = data['total'] / data['count']\n\t\t\tif data['average'] < limit:\n\t\t\t\tcontinue\n\t\t\t# row classes - alternate row color\n\t\t\trcls = ['alt'] if num % 2 == 1 else []\n\t\t\thtml += '<tr class=\"'+(' '.join(rcls))+'\">\\n' if len(rcls) > 0 else '<tr>\\n'\n\t\t\thtml += tdr.format(data['name'])\t\t\t\t# name\n\t\t\thtml += td.format('%.3f ms' % data['average'])\t# average\n\t\t\thtml += td.format(data['count'])\t\t\t\t# count\n\t\t\thtml += td.format('%.3f ms' % data['worst'])\t# worst\n\t\t\thtml += td.format(data['host'])\t\t\t\t\t# host\n\t\t\thtml += tdlink.format(data['url'])\t\t\t\t# url\n\t\t\thtml += '</tr>\\n'\n\t\t\tnum += 1\n\t\thtml += '</table>\\n'\n\n\t# flush the data to file\n\thf = open(htmlfile, 'w')\n\thf.write(html+'</body>\\n</html>\\n')\n\thf.close()\n\treturn devall\n\ndef createHTMLIssuesSummary(testruns, issues, htmlfile, title, extra=''):\n\tmultihost = len([e for e in issues if len(e['urls']) > 1]) > 0\n\thtml = summaryCSS('Issues Summary - SleepGraph', False)\n\ttotal = len(testruns)\n\n\t# generate the html\n\tth = '\\t<th>{0}</th>\\n'\n\ttd = '\\t<td align={0}>{1}</td>\\n'\n\ttdlink = '<a href=\"{1}\">{0}</a>'\n\tsubtitle = '%d issues' % len(issues) if len(issues) > 0 else 'no issues'\n\thtml += '<div class=\"stamp\">%s (%s)</div><table>\\n' % (title, subtitle)\n\thtml += '<tr>\\n' + th.format('Issue') + th.format('Count')\n\tif multihost:\n\t\thtml += th.format('Hosts')\n\thtml += th.format('Tests') + th.format('Fail Rate') +\\\n\t\tth.format('First Instance') + '</tr>\\n'\n\n\tnum = 0\n\tfor e in sorted(issues, key=lambda v:v['count'], reverse=True):\n\t\ttesttotal = 0\n\t\tlinks = []\n\t\tfor host in sorted(e['urls']):\n\t\t\tlinks.append(tdlink.format(host, e['urls'][host][0]))\n\t\t\ttesttotal += len(e['urls'][host])\n\t\trate = '%d/%d (%.2f%%)' % (testtotal, total, 100*float(testtotal)/float(total))\n\t\t# row classes - alternate row color\n\t\trcls = ['alt'] if num % 2 == 1 else []\n\t\thtml += '<tr class=\"'+(' '.join(rcls))+'\">\\n' if len(rcls) > 0 else '<tr>\\n'\n\t\thtml += td.format('left', e['line'])\t\t# issue\n\t\thtml += td.format('center', e['count'])\t\t# count\n\t\tif multihost:\n\t\t\thtml += td.format('center', len(e['urls']))\t# hosts\n\t\thtml += td.format('center', testtotal)\t\t# test count\n\t\thtml += td.format('center', rate)\t\t\t# test rate\n\t\thtml += td.format('center nowrap', '<br>'.join(links))\t# links\n\t\thtml += '</tr>\\n'\n\t\tnum += 1\n\n\t# flush the data to file\n\thf = open(htmlfile, 'w')\n\thf.write(html+'</table>\\n'+extra+'</body>\\n</html>\\n')\n\thf.close()\n\treturn issues\n\ndef ordinal(value):\n\tsuffix = 'th'\n\tif value < 10 or value > 19:\n\t\tif value % 10 == 1:\n\t\t\tsuffix = 'st'\n\t\telif value % 10 == 2:\n\t\t\tsuffix = 'nd'\n\t\telif value % 10 == 3:\n\t\t\tsuffix = 'rd'\n\treturn '%d%s' % (value, suffix)\n\n# Function: createHTML\n# Description:\n#\t Create the output html file from the resident test data\n# Arguments:\n#\t testruns: array of Data objects from parseKernelLog or parseTraceLog\n# Output:\n#\t True if the html file was created, false if it failed\ndef createHTML(testruns, testfail):\n\tif len(testruns) < 1:\n\t\tpprint('ERROR: Not enough test data to build a timeline')\n\t\treturn\n\n\tkerror = False\n\tfor data in testruns:\n\t\tif data.kerror:\n\t\t\tkerror = True\n\t\tif(sysvals.suspendmode in ['freeze', 'standby']):\n\t\t\tdata.trimFreezeTime(testruns[-1].tSuspended)\n\t\telse:\n\t\t\tdata.getMemTime()\n\n\t# html function templates\n\thtml_error = '<div id=\"{1}\" title=\"kernel error/warning\" class=\"err\" style=\"right:{0}%\">{2}&rarr;</div>\\n'\n\thtml_traceevent = '<div title=\"{0}\" class=\"traceevent{6}\" style=\"left:{1}%;top:{2}px;height:{3}px;width:{4}%;line-height:{3}px;{7}\">{5}</div>\\n'\n\thtml_cpuexec = '<div class=\"jiffie\" style=\"left:{0}%;top:{1}px;height:{2}px;width:{3}%;background:{4};\"></div>\\n'\n\thtml_timetotal = '<table class=\"time1\">\\n<tr>'\\\n\t\t'<td class=\"green\" title=\"{3}\">{2} Suspend Time: <b>{0} ms</b></td>'\\\n\t\t'<td class=\"yellow\" title=\"{4}\">{2} Resume Time: <b>{1} ms</b></td>'\\\n\t\t'</tr>\\n</table>\\n'\n\thtml_timetotal2 = '<table class=\"time1\">\\n<tr>'\\\n\t\t'<td class=\"green\" title=\"{4}\">{3} Suspend Time: <b>{0} ms</b></td>'\\\n\t\t'<td class=\"gray\" title=\"time spent in low-power mode with clock running\">'+sysvals.suspendmode+' time: <b>{1} ms</b></td>'\\\n\t\t'<td class=\"yellow\" title=\"{5}\">{3} Resume Time: <b>{2} ms</b></td>'\\\n\t\t'</tr>\\n</table>\\n'\n\thtml_timetotal3 = '<table class=\"time1\">\\n<tr>'\\\n\t\t'<td class=\"green\">Execution Time: <b>{0} ms</b></td>'\\\n\t\t'<td class=\"yellow\">Command: <b>{1}</b></td>'\\\n\t\t'</tr>\\n</table>\\n'\n\thtml_fail = '<table class=\"testfail\"><tr><td>{0}</td></tr></table>\\n'\n\thtml_kdesc = '<td class=\"{3}\" title=\"time spent in kernel execution\">{0}Kernel {2}: {1} ms</td>'\n\thtml_fwdesc = '<td class=\"{3}\" title=\"time spent in firmware\">{0}Firmware {2}: {1} ms</td>'\n\thtml_wifdesc = '<td class=\"yellow\" title=\"time for wifi to reconnect after resume complete ({2})\">{0}Wifi Resume: {1}</td>'\n\n\t# html format variables\n\tscaleH = 20\n\tif kerror:\n\t\tscaleH = 40\n\n\t# device timeline\n\tdevtl = Timeline(30, scaleH)\n\n\t# write the test title and general info header\n\tdevtl.createHeader(sysvals, testruns[0].stamp)\n\n\t# Generate the header for this timeline\n\tfor data in testruns:\n\t\ttTotal = data.end - data.start\n\t\tif(tTotal == 0):\n\t\t\tdoError('No timeline data')\n\t\tif sysvals.suspendmode == 'command':\n\t\t\trun_time = '%.0f' % (tTotal * 1000)\n\t\t\tif sysvals.testcommand:\n\t\t\t\ttestdesc = sysvals.testcommand\n\t\t\telse:\n\t\t\t\ttestdesc = 'unknown'\n\t\t\tif(len(testruns) > 1):\n\t\t\t\ttestdesc = ordinal(data.testnumber+1)+' '+testdesc\n\t\t\tthtml = html_timetotal3.format(run_time, testdesc)\n\t\t\tdevtl.html += thtml\n\t\t\tcontinue\n\t\t# typical full suspend/resume header\n\t\tstot, rtot = sktime, rktime = data.getTimeValues()\n\t\tssrc, rsrc, testdesc, testdesc2 = ['kernel'], ['kernel'], 'Kernel', ''\n\t\tif data.fwValid:\n\t\t\tstot += (data.fwSuspend/1000000.0)\n\t\t\trtot += (data.fwResume/1000000.0)\n\t\t\tssrc.append('firmware')\n\t\t\trsrc.append('firmware')\n\t\t\ttestdesc = 'Total'\n\t\tif 'time' in data.wifi and data.wifi['stat'] != 'timeout':\n\t\t\trtot += data.end - data.tKernRes + (data.wifi['time'] * 1000.0)\n\t\t\trsrc.append('wifi')\n\t\t\ttestdesc = 'Total'\n\t\tsuspend_time, resume_time = '%.3f' % stot, '%.3f' % rtot\n\t\tstitle = 'time from kernel suspend start to %s mode [%s time]' % \\\n\t\t\t(sysvals.suspendmode, ' & '.join(ssrc))\n\t\trtitle = 'time from %s mode to kernel resume complete [%s time]' % \\\n\t\t\t(sysvals.suspendmode, ' & '.join(rsrc))\n\t\tif(len(testruns) > 1):\n\t\t\ttestdesc = testdesc2 = ordinal(data.testnumber+1)\n\t\t\ttestdesc2 += ' '\n\t\tif(len(data.tLow) == 0):\n\t\t\tthtml = html_timetotal.format(suspend_time, \\\n\t\t\t\tresume_time, testdesc, stitle, rtitle)\n\t\telse:\n\t\t\tlow_time = '+'.join(data.tLow)\n\t\t\tthtml = html_timetotal2.format(suspend_time, low_time, \\\n\t\t\t\tresume_time, testdesc, stitle, rtitle)\n\t\tdevtl.html += thtml\n\t\tif not data.fwValid and 'dev' not in data.wifi:\n\t\t\tcontinue\n\t\t# extra detail when the times come from multiple sources\n\t\tthtml = '<table class=\"time2\">\\n<tr>'\n\t\tthtml += html_kdesc.format(testdesc2, '%.3f'%sktime, 'Suspend', 'green')\n\t\tif data.fwValid:\n\t\t\tsftime = '%.3f'%(data.fwSuspend / 1000000.0)\n\t\t\trftime = '%.3f'%(data.fwResume / 1000000.0)\n\t\t\tthtml += html_fwdesc.format(testdesc2, sftime, 'Suspend', 'green')\n\t\t\tthtml += html_fwdesc.format(testdesc2, rftime, 'Resume', 'yellow')\n\t\tthtml += html_kdesc.format(testdesc2, '%.3f'%rktime, 'Resume', 'yellow')\n\t\tif 'time' in data.wifi:\n\t\t\tif data.wifi['stat'] != 'timeout':\n\t\t\t\twtime = '%.0f ms'%(data.end - data.tKernRes + (data.wifi['time'] * 1000.0))\n\t\t\telse:\n\t\t\t\twtime = 'TIMEOUT'\n\t\t\tthtml += html_wifdesc.format(testdesc2, wtime, data.wifi['dev'])\n\t\tthtml += '</tr>\\n</table>\\n'\n\t\tdevtl.html += thtml\n\tif testfail:\n\t\tdevtl.html += html_fail.format(testfail)\n\n\t# time scale for potentially multiple datasets\n\tt0 = testruns[0].start\n\ttMax = testruns[-1].end\n\ttTotal = tMax - t0\n\n\t# determine the maximum number of rows we need to draw\n\tfulllist = []\n\tthreadlist = []\n\tpscnt = 0\n\tdevcnt = 0\n\tfor data in testruns:\n\t\tdata.selectTimelineDevices('%f', tTotal, sysvals.mindevlen)\n\t\tfor group in data.devicegroups:\n\t\t\tdevlist = []\n\t\t\tfor phase in group:\n\t\t\t\tfor devname in sorted(data.tdevlist[phase]):\n\t\t\t\t\td = DevItem(data.testnumber, phase, data.dmesg[phase]['list'][devname])\n\t\t\t\t\tdevlist.append(d)\n\t\t\t\t\tif d.isa('kth'):\n\t\t\t\t\t\tthreadlist.append(d)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif d.isa('ps'):\n\t\t\t\t\t\t\tpscnt += 1\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tdevcnt += 1\n\t\t\t\t\t\tfulllist.append(d)\n\t\t\tif sysvals.mixedphaseheight:\n\t\t\t\tdevtl.getPhaseRows(devlist)\n\tif not sysvals.mixedphaseheight:\n\t\tif len(threadlist) > 0 and len(fulllist) > 0:\n\t\t\tif pscnt > 0 and devcnt > 0:\n\t\t\t\tmsg = 'user processes & device pm callbacks'\n\t\t\telif pscnt > 0:\n\t\t\t\tmsg = 'user processes'\n\t\t\telse:\n\t\t\t\tmsg = 'device pm callbacks'\n\t\t\td = testruns[0].addHorizontalDivider(msg, testruns[-1].end)\n\t\t\tfulllist.insert(0, d)\n\t\tdevtl.getPhaseRows(fulllist)\n\t\tif len(threadlist) > 0:\n\t\t\td = testruns[0].addHorizontalDivider('asynchronous kernel threads', testruns[-1].end)\n\t\t\tthreadlist.insert(0, d)\n\t\t\tdevtl.getPhaseRows(threadlist, devtl.rows)\n\tdevtl.calcTotalRows()\n\n\t# draw the full timeline\n\tdevtl.createZoomBox(sysvals.suspendmode, len(testruns))\n\tfor data in testruns:\n\t\t# draw each test run and block chronologically\n\t\tphases = {'suspend':[],'resume':[]}\n\t\tfor phase in data.sortedPhases():\n\t\t\tif data.dmesg[phase]['start'] >= data.tSuspended:\n\t\t\t\tphases['resume'].append(phase)\n\t\t\telse:\n\t\t\t\tphases['suspend'].append(phase)\n\t\t# now draw the actual timeline blocks\n\t\tfor dir in phases:\n\t\t\t# draw suspend and resume blocks separately\n\t\t\tbname = '%s%d' % (dir[0], data.testnumber)\n\t\t\tif dir == 'suspend':\n\t\t\t\tm0 = data.start\n\t\t\t\tmMax = data.tSuspended\n\t\t\t\tleft = '%f' % (((m0-t0)*100.0)/tTotal)\n\t\t\telse:\n\t\t\t\tm0 = data.tSuspended\n\t\t\t\tmMax = data.end\n\t\t\t\t# in an x2 run, remove any gap between blocks\n\t\t\t\tif len(testruns) > 1 and data.testnumber == 0:\n\t\t\t\t\tmMax = testruns[1].start\n\t\t\t\tleft = '%f' % ((((m0-t0)*100.0)+sysvals.srgap/2)/tTotal)\n\t\t\tmTotal = mMax - m0\n\t\t\t# if a timeline block is 0 length, skip altogether\n\t\t\tif mTotal == 0:\n\t\t\t\tcontinue\n\t\t\twidth = '%f' % (((mTotal*100.0)-sysvals.srgap/2)/tTotal)\n\t\t\tdevtl.html += devtl.html_tblock.format(bname, left, width, devtl.scaleH)\n\t\t\tfor b in phases[dir]:\n\t\t\t\t# draw the phase color background\n\t\t\t\tphase = data.dmesg[b]\n\t\t\t\tlength = phase['end']-phase['start']\n\t\t\t\tleft = '%f' % (((phase['start']-m0)*100.0)/mTotal)\n\t\t\t\twidth = '%f' % ((length*100.0)/mTotal)\n\t\t\t\tdevtl.html += devtl.html_phase.format(left, width, \\\n\t\t\t\t\t'%.3f'%devtl.scaleH, '%.3f'%devtl.bodyH, \\\n\t\t\t\t\tdata.dmesg[b]['color'], '')\n\t\t\tfor e in data.errorinfo[dir]:\n\t\t\t\t# draw red lines for any kernel errors found\n\t\t\t\ttype, t, idx1, idx2 = e\n\t\t\t\tid = '%d_%d' % (idx1, idx2)\n\t\t\t\tright = '%f' % (((mMax-t)*100.0)/mTotal)\n\t\t\t\tdevtl.html += html_error.format(right, id, type)\n\t\t\tfor b in phases[dir]:\n\t\t\t\t# draw the devices for this phase\n\t\t\t\tphaselist = data.dmesg[b]['list']\n\t\t\t\tfor d in sorted(data.tdevlist[b]):\n\t\t\t\t\tdname = d if ('[' not in d or 'CPU' in d) else d.split('[')[0]\n\t\t\t\t\tname, dev = dname, phaselist[d]\n\t\t\t\t\tdrv = xtraclass = xtrainfo = xtrastyle = ''\n\t\t\t\t\tif 'htmlclass' in dev:\n\t\t\t\t\t\txtraclass = dev['htmlclass']\n\t\t\t\t\tif 'color' in dev:\n\t\t\t\t\t\txtrastyle = 'background:%s;' % dev['color']\n\t\t\t\t\tif(d in sysvals.devprops):\n\t\t\t\t\t\tname = sysvals.devprops[d].altName(d)\n\t\t\t\t\t\txtraclass = sysvals.devprops[d].xtraClass()\n\t\t\t\t\t\txtrainfo = sysvals.devprops[d].xtraInfo()\n\t\t\t\t\telif xtraclass == ' kth':\n\t\t\t\t\t\txtrainfo = ' kernel_thread'\n\t\t\t\t\tif('drv' in dev and dev['drv']):\n\t\t\t\t\t\tdrv = ' {%s}' % dev['drv']\n\t\t\t\t\trowheight = devtl.phaseRowHeight(data.testnumber, b, dev['row'])\n\t\t\t\t\trowtop = devtl.phaseRowTop(data.testnumber, b, dev['row'])\n\t\t\t\t\ttop = '%.3f' % (rowtop + devtl.scaleH)\n\t\t\t\t\tleft = '%f' % (((dev['start']-m0)*100)/mTotal)\n\t\t\t\t\twidth = '%f' % (((dev['end']-dev['start'])*100)/mTotal)\n\t\t\t\t\tlength = ' (%0.3f ms) ' % ((dev['end']-dev['start'])*1000)\n\t\t\t\t\ttitle = name+drv+xtrainfo+length\n\t\t\t\t\tif sysvals.suspendmode == 'command':\n\t\t\t\t\t\ttitle += sysvals.testcommand\n\t\t\t\t\telif xtraclass == ' ps':\n\t\t\t\t\t\tif 'suspend' in b:\n\t\t\t\t\t\t\ttitle += 'pre_suspend_process'\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\ttitle += 'post_resume_process'\n\t\t\t\t\telse:\n\t\t\t\t\t\ttitle += b\n\t\t\t\t\tdevtl.html += devtl.html_device.format(dev['id'], \\\n\t\t\t\t\t\ttitle, left, top, '%.3f'%rowheight, width, \\\n\t\t\t\t\t\tdname+drv, xtraclass, xtrastyle)\n\t\t\t\t\tif('cpuexec' in dev):\n\t\t\t\t\t\tfor t in sorted(dev['cpuexec']):\n\t\t\t\t\t\t\tstart, end = t\n\t\t\t\t\t\t\theight = '%.3f' % (rowheight/3)\n\t\t\t\t\t\t\ttop = '%.3f' % (rowtop + devtl.scaleH + 2*rowheight/3)\n\t\t\t\t\t\t\tleft = '%f' % (((start-m0)*100)/mTotal)\n\t\t\t\t\t\t\twidth = '%f' % ((end-start)*100/mTotal)\n\t\t\t\t\t\t\tcolor = 'rgba(255, 0, 0, %f)' % dev['cpuexec'][t]\n\t\t\t\t\t\t\tdevtl.html += \\\n\t\t\t\t\t\t\t\thtml_cpuexec.format(left, top, height, width, color)\n\t\t\t\t\tif('src' not in dev):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t# draw any trace events for this device\n\t\t\t\t\tfor e in dev['src']:\n\t\t\t\t\t\tif e.length == 0:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\theight = '%.3f' % devtl.rowH\n\t\t\t\t\t\ttop = '%.3f' % (rowtop + devtl.scaleH + (e.row*devtl.rowH))\n\t\t\t\t\t\tleft = '%f' % (((e.time-m0)*100)/mTotal)\n\t\t\t\t\t\twidth = '%f' % (e.length*100/mTotal)\n\t\t\t\t\t\txtrastyle = ''\n\t\t\t\t\t\tif e.color:\n\t\t\t\t\t\t\txtrastyle = 'background:%s;' % e.color\n\t\t\t\t\t\tdevtl.html += \\\n\t\t\t\t\t\t\thtml_traceevent.format(e.title(), \\\n\t\t\t\t\t\t\t\tleft, top, height, width, e.text(), '', xtrastyle)\n\t\t\t# draw the time scale, try to make the number of labels readable\n\t\t\tdevtl.createTimeScale(m0, mMax, tTotal, dir)\n\t\t\tdevtl.html += '</div>\\n'\n\n\t# timeline is finished\n\tdevtl.html += '</div>\\n</div>\\n'\n\n\t# draw a legend which describes the phases by color\n\tif sysvals.suspendmode != 'command':\n\t\tphasedef = testruns[-1].phasedef\n\t\tdevtl.html += '<div class=\"legend\">\\n'\n\t\tpdelta = 100.0/len(phasedef.keys())\n\t\tpmargin = pdelta / 4.0\n\t\tfor phase in sorted(phasedef, key=lambda k:phasedef[k]['order']):\n\t\t\tid, p = '', phasedef[phase]\n\t\t\tfor word in phase.split('_'):\n\t\t\t\tid += word[0]\n\t\t\torder = '%.2f' % ((p['order'] * pdelta) + pmargin)\n\t\t\tname = phase.replace('_', ' &nbsp;')\n\t\t\tdevtl.html += devtl.html_legend.format(order, p['color'], name, id)\n\t\tdevtl.html += '</div>\\n'\n\n\thf = open(sysvals.htmlfile, 'w')\n\taddCSS(hf, sysvals, len(testruns), kerror)\n\n\t# write the device timeline\n\thf.write(devtl.html)\n\thf.write('<div id=\"devicedetailtitle\"></div>\\n')\n\thf.write('<div id=\"devicedetail\" style=\"display:none;\">\\n')\n\t# draw the colored boxes for the device detail section\n\tfor data in testruns:\n\t\thf.write('<div id=\"devicedetail%d\">\\n' % data.testnumber)\n\t\tpscolor = 'linear-gradient(to top left, #ccc, #eee)'\n\t\thf.write(devtl.html_phaselet.format('pre_suspend_process', \\\n\t\t\t'0', '0', pscolor))\n\t\tfor b in data.sortedPhases():\n\t\t\tphase = data.dmesg[b]\n\t\t\tlength = phase['end']-phase['start']\n\t\t\tleft = '%.3f' % (((phase['start']-t0)*100.0)/tTotal)\n\t\t\twidth = '%.3f' % ((length*100.0)/tTotal)\n\t\t\thf.write(devtl.html_phaselet.format(b, left, width, \\\n\t\t\t\tdata.dmesg[b]['color']))\n\t\thf.write(devtl.html_phaselet.format('post_resume_process', \\\n\t\t\t'0', '0', pscolor))\n\t\tif sysvals.suspendmode == 'command':\n\t\t\thf.write(devtl.html_phaselet.format('cmdexec', '0', '0', pscolor))\n\t\thf.write('</div>\\n')\n\thf.write('</div>\\n')\n\n\t# write the ftrace data (callgraph)\n\tif sysvals.cgtest >= 0 and len(testruns) > sysvals.cgtest:\n\t\tdata = testruns[sysvals.cgtest]\n\telse:\n\t\tdata = testruns[-1]\n\tif sysvals.usecallgraph:\n\t\taddCallgraphs(sysvals, hf, data)\n\n\t# add the test log as a hidden div\n\tif sysvals.testlog and sysvals.logmsg:\n\t\thf.write('<div id=\"testlog\" style=\"display:none;\">\\n'+sysvals.logmsg+'</div>\\n')\n\t# add the dmesg log as a hidden div\n\tif sysvals.dmesglog and sysvals.dmesgfile:\n\t\thf.write('<div id=\"dmesglog\" style=\"display:none;\">\\n')\n\t\tlf = sysvals.openlog(sysvals.dmesgfile, 'r')\n\t\tfor line in lf:\n\t\t\tline = line.replace('<', '&lt').replace('>', '&gt')\n\t\t\thf.write(line)\n\t\tlf.close()\n\t\thf.write('</div>\\n')\n\t# add the ftrace log as a hidden div\n\tif sysvals.ftracelog and sysvals.ftracefile:\n\t\thf.write('<div id=\"ftracelog\" style=\"display:none;\">\\n')\n\t\tlf = sysvals.openlog(sysvals.ftracefile, 'r')\n\t\tfor line in lf:\n\t\t\thf.write(line)\n\t\tlf.close()\n\t\thf.write('</div>\\n')\n\n\t# write the footer and close\n\taddScriptCode(hf, testruns)\n\thf.write('</body>\\n</html>\\n')\n\thf.close()\n\treturn True\n\ndef addCSS(hf, sv, testcount=1, kerror=False, extra=''):\n\tkernel = sv.stamp['kernel']\n\thost = sv.hostname[0].upper()+sv.hostname[1:]\n\tmode = sv.suspendmode\n\tif sv.suspendmode in suspendmodename:\n\t\tmode = suspendmodename[sv.suspendmode]\n\ttitle = host+' '+mode+' '+kernel\n\n\t# various format changes by flags\n\tcgchk = 'checked'\n\tcgnchk = 'not(:checked)'\n\tif sv.cgexp:\n\t\tcgchk = 'not(:checked)'\n\t\tcgnchk = 'checked'\n\n\thoverZ = 'z-index:8;'\n\tif sv.usedevsrc:\n\t\thoverZ = ''\n\n\tdevlistpos = 'absolute'\n\tif testcount > 1:\n\t\tdevlistpos = 'relative'\n\n\tscaleTH = 20\n\tif kerror:\n\t\tscaleTH = 60\n\n\t# write the html header first (html head, css code, up to body start)\n\thtml_header = '<!DOCTYPE html>\\n<html>\\n<head>\\n\\\n\t<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\\n\\\n\t<title>'+title+'</title>\\n\\\n\t<style type=\\'text/css\\'>\\n\\\n\t\tbody {overflow-y:scroll;}\\n\\\n\t\t.stamp {width:100%;text-align:center;background:gray;line-height:30px;color:white;font:25px Arial;}\\n\\\n\t\t.stamp.sysinfo {font:10px Arial;}\\n\\\n\t\t.callgraph {margin-top:30px;box-shadow:5px 5px 20px black;}\\n\\\n\t\t.callgraph article * {padding-left:28px;}\\n\\\n\t\th1 {color:black;font:bold 30px Times;}\\n\\\n\t\tt0 {color:black;font:bold 30px Times;}\\n\\\n\t\tt1 {color:black;font:30px Times;}\\n\\\n\t\tt2 {color:black;font:25px Times;}\\n\\\n\t\tt3 {color:black;font:20px Times;white-space:nowrap;}\\n\\\n\t\tt4 {color:black;font:bold 30px Times;line-height:60px;white-space:nowrap;}\\n\\\n\t\tcS {font:bold 13px Times;}\\n\\\n\t\ttable {width:100%;}\\n\\\n\t\t.gray {background:rgba(80,80,80,0.1);}\\n\\\n\t\t.green {background:rgba(204,255,204,0.4);}\\n\\\n\t\t.purple {background:rgba(128,0,128,0.2);}\\n\\\n\t\t.yellow {background:rgba(255,255,204,0.4);}\\n\\\n\t\t.blue {background:rgba(169,208,245,0.4);}\\n\\\n\t\t.time1 {font:22px Arial;border:1px solid;}\\n\\\n\t\t.time2 {font:15px Arial;border-bottom:1px solid;border-left:1px solid;border-right:1px solid;}\\n\\\n\t\t.testfail {font:bold 22px Arial;color:red;border:1px dashed;}\\n\\\n\t\ttd {text-align:center;}\\n\\\n\t\tr {color:#500000;font:15px Tahoma;}\\n\\\n\t\tn {color:#505050;font:15px Tahoma;}\\n\\\n\t\t.tdhl {color:red;}\\n\\\n\t\t.hide {display:none;}\\n\\\n\t\t.pf {display:none;}\\n\\\n\t\t.pf:'+cgchk+' + label {background:url(\\'data:image/svg+xml;utf,<?xml version=\"1.0\" standalone=\"no\"?><svg xmlns=\"http://www.w3.org/2000/svg\" height=\"18\" width=\"18\" version=\"1.1\"><circle cx=\"9\" cy=\"9\" r=\"8\" stroke=\"black\" stroke-width=\"1\" fill=\"white\"/><rect x=\"4\" y=\"8\" width=\"10\" height=\"2\" style=\"fill:black;stroke-width:0\"/><rect x=\"8\" y=\"4\" width=\"2\" height=\"10\" style=\"fill:black;stroke-width:0\"/></svg>\\') no-repeat left center;}\\n\\\n\t\t.pf:'+cgnchk+' ~ label {background:url(\\'data:image/svg+xml;utf,<?xml version=\"1.0\" standalone=\"no\"?><svg xmlns=\"http://www.w3.org/2000/svg\" height=\"18\" width=\"18\" version=\"1.1\"><circle cx=\"9\" cy=\"9\" r=\"8\" stroke=\"black\" stroke-width=\"1\" fill=\"white\"/><rect x=\"4\" y=\"8\" width=\"10\" height=\"2\" style=\"fill:black;stroke-width:0\"/></svg>\\') no-repeat left center;}\\n\\\n\t\t.pf:'+cgchk+' ~ *:not(:nth-child(2)) {display:none;}\\n\\\n\t\t.zoombox {position:relative;width:100%;overflow-x:scroll;-webkit-user-select:none;-moz-user-select:none;user-select:none;}\\n\\\n\t\t.timeline {position:relative;font-size:14px;cursor:pointer;width:100%; overflow:hidden;background:linear-gradient(#cccccc, white);}\\n\\\n\t\t.thread {position:absolute;height:0%;overflow:hidden;z-index:7;line-height:30px;font-size:14px;border:1px solid;text-align:center;white-space:nowrap;}\\n\\\n\t\t.thread.ps {border-radius:3px;background:linear-gradient(to top, #ccc, #eee);}\\n\\\n\t\t.thread:hover {background:white;border:1px solid red;'+hoverZ+'}\\n\\\n\t\t.thread.sec,.thread.sec:hover {background:black;border:0;color:white;line-height:15px;font-size:10px;}\\n\\\n\t\t.hover {background:white;border:1px solid red;'+hoverZ+'}\\n\\\n\t\t.hover.sync {background:white;}\\n\\\n\t\t.hover.bg,.hover.kth,.hover.sync,.hover.ps {background:white;}\\n\\\n\t\t.jiffie {position:absolute;pointer-events: none;z-index:8;}\\n\\\n\t\t.traceevent {position:absolute;font-size:10px;z-index:7;overflow:hidden;color:black;text-align:center;white-space:nowrap;border-radius:5px;border:1px solid black;background:linear-gradient(to bottom right,#CCC,#969696);}\\n\\\n\t\t.traceevent:hover {color:white;font-weight:bold;border:1px solid white;}\\n\\\n\t\t.phase {position:absolute;overflow:hidden;border:0px;text-align:center;}\\n\\\n\t\t.phaselet {float:left;overflow:hidden;border:0px;text-align:center;min-height:100px;font-size:24px;}\\n\\\n\t\t.t {position:absolute;line-height:'+('%d'%scaleTH)+'px;pointer-events:none;top:0;height:100%;border-right:1px solid black;z-index:6;}\\n\\\n\t\t.err {position:absolute;top:0%;height:100%;border-right:3px solid red;color:red;font:bold 14px Times;line-height:18px;}\\n\\\n\t\t.legend {position:relative; width:100%; height:40px; text-align:center;margin-bottom:20px}\\n\\\n\t\t.legend .square {position:absolute;cursor:pointer;top:10px; width:0px;height:20px;border:1px solid;padding-left:20px;}\\n\\\n\t\tbutton {height:40px;width:200px;margin-bottom:20px;margin-top:20px;font-size:24px;}\\n\\\n\t\t.btnfmt {position:relative;float:right;height:25px;width:auto;margin-top:3px;margin-bottom:0;font-size:10px;text-align:center;}\\n\\\n\t\t.devlist {position:'+devlistpos+';width:190px;}\\n\\\n\t\ta:link {color:white;text-decoration:none;}\\n\\\n\t\ta:visited {color:white;}\\n\\\n\t\ta:hover {color:white;}\\n\\\n\t\ta:active {color:white;}\\n\\\n\t\t.version {position:relative;float:left;color:white;font-size:10px;line-height:30px;margin-left:10px;}\\n\\\n\t\t#devicedetail {min-height:100px;box-shadow:5px 5px 20px black;}\\n\\\n\t\t.tblock {position:absolute;height:100%;background:#ddd;}\\n\\\n\t\t.tback {position:absolute;width:100%;background:linear-gradient(#ccc, #ddd);}\\n\\\n\t\t.bg {z-index:1;}\\n\\\n'+extra+'\\\n\t</style>\\n</head>\\n<body>\\n'\n\thf.write(html_header)\n\n# Function: addScriptCode\n# Description:\n#\t Adds the javascript code to the output html\n# Arguments:\n#\t hf: the open html file pointer\n#\t testruns: array of Data objects from parseKernelLog or parseTraceLog\ndef addScriptCode(hf, testruns):\n\tt0 = testruns[0].start * 1000\n\ttMax = testruns[-1].end * 1000\n\t# create an array in javascript memory with the device details\n\tdetail = '\tvar devtable = [];\\n'\n\tfor data in testruns:\n\t\ttopo = data.deviceTopology()\n\t\tdetail += '\tdevtable[%d] = \"%s\";\\n' % (data.testnumber, topo)\n\tdetail += '\tvar bounds = [%f,%f];\\n' % (t0, tMax)\n\t# add the code which will manipulate the data in the browser\n\tscript_code = \\\n\t'<script type=\"text/javascript\">\\n'+detail+\\\n\t'\tvar resolution = -1;\\n'\\\n\t'\tvar dragval = [0, 0];\\n'\\\n\t'\tfunction redrawTimescale(t0, tMax, tS) {\\n'\\\n\t'\t\tvar rline = \\'<div class=\"t\" style=\"left:0;border-left:1px solid black;border-right:0;\">\\';\\n'\\\n\t'\t\tvar tTotal = tMax - t0;\\n'\\\n\t'\t\tvar list = document.getElementsByClassName(\"tblock\");\\n'\\\n\t'\t\tfor (var i = 0; i < list.length; i++) {\\n'\\\n\t'\t\t\tvar timescale = list[i].getElementsByClassName(\"timescale\")[0];\\n'\\\n\t'\t\t\tvar m0 = t0 + (tTotal*parseFloat(list[i].style.left)/100);\\n'\\\n\t'\t\t\tvar mTotal = tTotal*parseFloat(list[i].style.width)/100;\\n'\\\n\t'\t\t\tvar mMax = m0 + mTotal;\\n'\\\n\t'\t\t\tvar html = \"\";\\n'\\\n\t'\t\t\tvar divTotal = Math.floor(mTotal/tS) + 1;\\n'\\\n\t'\t\t\tif(divTotal > 1000) continue;\\n'\\\n\t'\t\t\tvar divEdge = (mTotal - tS*(divTotal-1))*100/mTotal;\\n'\\\n\t'\t\t\tvar pos = 0.0, val = 0.0;\\n'\\\n\t'\t\t\tfor (var j = 0; j < divTotal; j++) {\\n'\\\n\t'\t\t\t\tvar htmlline = \"\";\\n'\\\n\t'\t\t\t\tvar mode = list[i].id[5];\\n'\\\n\t'\t\t\t\tif(mode == \"s\") {\\n'\\\n\t'\t\t\t\t\tpos = 100 - (((j)*tS*100)/mTotal) - divEdge;\\n'\\\n\t'\t\t\t\t\tval = (j-divTotal+1)*tS;\\n'\\\n\t'\t\t\t\t\tif(j == divTotal - 1)\\n'\\\n\t'\t\t\t\t\t\thtmlline = \\'<div class=\"t\" style=\"right:\\'+pos+\\'%\"><cS>S&rarr;</cS></div>\\';\\n'\\\n\t'\t\t\t\t\telse\\n'\\\n\t'\t\t\t\t\t\thtmlline = \\'<div class=\"t\" style=\"right:\\'+pos+\\'%\">\\'+val+\\'ms</div>\\';\\n'\\\n\t'\t\t\t\t} else {\\n'\\\n\t'\t\t\t\t\tpos = 100 - (((j)*tS*100)/mTotal);\\n'\\\n\t'\t\t\t\t\tval = (j)*tS;\\n'\\\n\t'\t\t\t\t\thtmlline = \\'<div class=\"t\" style=\"right:\\'+pos+\\'%\">\\'+val+\\'ms</div>\\';\\n'\\\n\t'\t\t\t\t\tif(j == 0)\\n'\\\n\t'\t\t\t\t\t\tif(mode == \"r\")\\n'\\\n\t'\t\t\t\t\t\t\thtmlline = rline+\"<cS>&larr;R</cS></div>\";\\n'\\\n\t'\t\t\t\t\t\telse\\n'\\\n\t'\t\t\t\t\t\t\thtmlline = rline+\"<cS>0ms</div>\";\\n'\\\n\t'\t\t\t\t}\\n'\\\n\t'\t\t\t\thtml += htmlline;\\n'\\\n\t'\t\t\t}\\n'\\\n\t'\t\t\ttimescale.innerHTML = html;\\n'\\\n\t'\t\t}\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction zoomTimeline() {\\n'\\\n\t'\t\tvar dmesg = document.getElementById(\"dmesg\");\\n'\\\n\t'\t\tvar zoombox = document.getElementById(\"dmesgzoombox\");\\n'\\\n\t'\t\tvar left = zoombox.scrollLeft;\\n'\\\n\t'\t\tvar val = parseFloat(dmesg.style.width);\\n'\\\n\t'\t\tvar newval = 100;\\n'\\\n\t'\t\tvar sh = window.outerWidth / 2;\\n'\\\n\t'\t\tif(this.id == \"zoomin\") {\\n'\\\n\t'\t\t\tnewval = val * 1.2;\\n'\\\n\t'\t\t\tif(newval > 910034) newval = 910034;\\n'\\\n\t'\t\t\tdmesg.style.width = newval+\"%\";\\n'\\\n\t'\t\t\tzoombox.scrollLeft = ((left + sh) * newval / val) - sh;\\n'\\\n\t'\t\t} else if (this.id == \"zoomout\") {\\n'\\\n\t'\t\t\tnewval = val / 1.2;\\n'\\\n\t'\t\t\tif(newval < 100) newval = 100;\\n'\\\n\t'\t\t\tdmesg.style.width = newval+\"%\";\\n'\\\n\t'\t\t\tzoombox.scrollLeft = ((left + sh) * newval / val) - sh;\\n'\\\n\t'\t\t} else {\\n'\\\n\t'\t\t\tzoombox.scrollLeft = 0;\\n'\\\n\t'\t\t\tdmesg.style.width = \"100%\";\\n'\\\n\t'\t\t}\\n'\\\n\t'\t\tvar tS = [10000, 5000, 2000, 1000, 500, 200, 100, 50, 20, 10, 5, 2, 1];\\n'\\\n\t'\t\tvar t0 = bounds[0];\\n'\\\n\t'\t\tvar tMax = bounds[1];\\n'\\\n\t'\t\tvar tTotal = tMax - t0;\\n'\\\n\t'\t\tvar wTotal = tTotal * 100.0 / newval;\\n'\\\n\t'\t\tvar idx = 7*window.innerWidth/1100;\\n'\\\n\t'\t\tfor(var i = 0; (i < tS.length)&&((wTotal / tS[i]) < idx); i++);\\n'\\\n\t'\t\tif(i >= tS.length) i = tS.length - 1;\\n'\\\n\t'\t\tif(tS[i] == resolution) return;\\n'\\\n\t'\t\tresolution = tS[i];\\n'\\\n\t'\t\tredrawTimescale(t0, tMax, tS[i]);\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction deviceName(title) {\\n'\\\n\t'\t\tvar name = title.slice(0, title.indexOf(\" (\"));\\n'\\\n\t'\t\treturn name;\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction deviceHover() {\\n'\\\n\t'\t\tvar name = deviceName(this.title);\\n'\\\n\t'\t\tvar dmesg = document.getElementById(\"dmesg\");\\n'\\\n\t'\t\tvar dev = dmesg.getElementsByClassName(\"thread\");\\n'\\\n\t'\t\tvar cpu = -1;\\n'\\\n\t'\t\tif(name.match(\"CPU_ON\\[[0-9]*\\]\"))\\n'\\\n\t'\t\t\tcpu = parseInt(name.slice(7));\\n'\\\n\t'\t\telse if(name.match(\"CPU_OFF\\[[0-9]*\\]\"))\\n'\\\n\t'\t\t\tcpu = parseInt(name.slice(8));\\n'\\\n\t'\t\tfor (var i = 0; i < dev.length; i++) {\\n'\\\n\t'\t\t\tdname = deviceName(dev[i].title);\\n'\\\n\t'\t\t\tvar cname = dev[i].className.slice(dev[i].className.indexOf(\"thread\"));\\n'\\\n\t'\t\t\tif((cpu >= 0 && dname.match(\"CPU_O[NF]*\\\\\\[*\"+cpu+\"\\\\\\]\")) ||\\n'\\\n\t'\t\t\t\t(name == dname))\\n'\\\n\t'\t\t\t{\\n'\\\n\t'\t\t\t\tdev[i].className = \"hover \"+cname;\\n'\\\n\t'\t\t\t} else {\\n'\\\n\t'\t\t\t\tdev[i].className = cname;\\n'\\\n\t'\t\t\t}\\n'\\\n\t'\t\t}\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction deviceUnhover() {\\n'\\\n\t'\t\tvar dmesg = document.getElementById(\"dmesg\");\\n'\\\n\t'\t\tvar dev = dmesg.getElementsByClassName(\"thread\");\\n'\\\n\t'\t\tfor (var i = 0; i < dev.length; i++) {\\n'\\\n\t'\t\t\tdev[i].className = dev[i].className.slice(dev[i].className.indexOf(\"thread\"));\\n'\\\n\t'\t\t}\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction deviceTitle(title, total, cpu) {\\n'\\\n\t'\t\tvar prefix = \"Total\";\\n'\\\n\t'\t\tif(total.length > 3) {\\n'\\\n\t'\t\t\tprefix = \"Average\";\\n'\\\n\t'\t\t\ttotal[1] = (total[1]+total[3])/2;\\n'\\\n\t'\t\t\ttotal[2] = (total[2]+total[4])/2;\\n'\\\n\t'\t\t}\\n'\\\n\t'\t\tvar devtitle = document.getElementById(\"devicedetailtitle\");\\n'\\\n\t'\t\tvar name = deviceName(title);\\n'\\\n\t'\t\tif(cpu >= 0) name = \"CPU\"+cpu;\\n'\\\n\t'\t\tvar driver = \"\";\\n'\\\n\t'\t\tvar tS = \"<t2>(</t2>\";\\n'\\\n\t'\t\tvar tR = \"<t2>)</t2>\";\\n'\\\n\t'\t\tif(total[1] > 0)\\n'\\\n\t'\t\t\ttS = \"<t2>(\"+prefix+\" Suspend:</t2><t0> \"+total[1].toFixed(3)+\" ms</t0> \";\\n'\\\n\t'\t\tif(total[2] > 0)\\n'\\\n\t'\t\t\ttR = \" <t2>\"+prefix+\" Resume:</t2><t0> \"+total[2].toFixed(3)+\" ms<t2>)</t2></t0>\";\\n'\\\n\t'\t\tvar s = title.indexOf(\"{\");\\n'\\\n\t'\t\tvar e = title.indexOf(\"}\");\\n'\\\n\t'\t\tif((s >= 0) && (e >= 0))\\n'\\\n\t'\t\t\tdriver = title.slice(s+1, e) + \" <t1>@</t1> \";\\n'\\\n\t'\t\tif(total[1] > 0 && total[2] > 0)\\n'\\\n\t'\t\t\tdevtitle.innerHTML = \"<t0>\"+driver+name+\"</t0> \"+tS+tR;\\n'\\\n\t'\t\telse\\n'\\\n\t'\t\t\tdevtitle.innerHTML = \"<t0>\"+title+\"</t0>\";\\n'\\\n\t'\t\treturn name;\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction deviceDetail() {\\n'\\\n\t'\t\tvar devinfo = document.getElementById(\"devicedetail\");\\n'\\\n\t'\t\tdevinfo.style.display = \"block\";\\n'\\\n\t'\t\tvar name = deviceName(this.title);\\n'\\\n\t'\t\tvar cpu = -1;\\n'\\\n\t'\t\tif(name.match(\"CPU_ON\\[[0-9]*\\]\"))\\n'\\\n\t'\t\t\tcpu = parseInt(name.slice(7));\\n'\\\n\t'\t\telse if(name.match(\"CPU_OFF\\[[0-9]*\\]\"))\\n'\\\n\t'\t\t\tcpu = parseInt(name.slice(8));\\n'\\\n\t'\t\tvar dmesg = document.getElementById(\"dmesg\");\\n'\\\n\t'\t\tvar dev = dmesg.getElementsByClassName(\"thread\");\\n'\\\n\t'\t\tvar idlist = [];\\n'\\\n\t'\t\tvar pdata = [[]];\\n'\\\n\t'\t\tif(document.getElementById(\"devicedetail1\"))\\n'\\\n\t'\t\t\tpdata = [[], []];\\n'\\\n\t'\t\tvar pd = pdata[0];\\n'\\\n\t'\t\tvar total = [0.0, 0.0, 0.0];\\n'\\\n\t'\t\tfor (var i = 0; i < dev.length; i++) {\\n'\\\n\t'\t\t\tdname = deviceName(dev[i].title);\\n'\\\n\t'\t\t\tif((cpu >= 0 && dname.match(\"CPU_O[NF]*\\\\\\[*\"+cpu+\"\\\\\\]\")) ||\\n'\\\n\t'\t\t\t\t(name == dname))\\n'\\\n\t'\t\t\t{\\n'\\\n\t'\t\t\t\tidlist[idlist.length] = dev[i].id;\\n'\\\n\t'\t\t\t\tvar tidx = 1;\\n'\\\n\t'\t\t\t\tif(dev[i].id[0] == \"a\") {\\n'\\\n\t'\t\t\t\t\tpd = pdata[0];\\n'\\\n\t'\t\t\t\t} else {\\n'\\\n\t'\t\t\t\t\tif(pdata.length == 1) pdata[1] = [];\\n'\\\n\t'\t\t\t\t\tif(total.length == 3) total[3]=total[4]=0.0;\\n'\\\n\t'\t\t\t\t\tpd = pdata[1];\\n'\\\n\t'\t\t\t\t\ttidx = 3;\\n'\\\n\t'\t\t\t\t}\\n'\\\n\t'\t\t\t\tvar info = dev[i].title.split(\" \");\\n'\\\n\t'\t\t\t\tvar pname = info[info.length-1];\\n'\\\n\t'\t\t\t\tpd[pname] = parseFloat(info[info.length-3].slice(1));\\n'\\\n\t'\t\t\t\ttotal[0] += pd[pname];\\n'\\\n\t'\t\t\t\tif(pname.indexOf(\"suspend\") >= 0)\\n'\\\n\t'\t\t\t\t\ttotal[tidx] += pd[pname];\\n'\\\n\t'\t\t\t\telse\\n'\\\n\t'\t\t\t\t\ttotal[tidx+1] += pd[pname];\\n'\\\n\t'\t\t\t}\\n'\\\n\t'\t\t}\\n'\\\n\t'\t\tvar devname = deviceTitle(this.title, total, cpu);\\n'\\\n\t'\t\tvar left = 0.0;\\n'\\\n\t'\t\tfor (var t = 0; t < pdata.length; t++) {\\n'\\\n\t'\t\t\tpd = pdata[t];\\n'\\\n\t'\t\t\tdevinfo = document.getElementById(\"devicedetail\"+t);\\n'\\\n\t'\t\t\tvar phases = devinfo.getElementsByClassName(\"phaselet\");\\n'\\\n\t'\t\t\tfor (var i = 0; i < phases.length; i++) {\\n'\\\n\t'\t\t\t\tif(phases[i].id in pd) {\\n'\\\n\t'\t\t\t\t\tvar w = 100.0*pd[phases[i].id]/total[0];\\n'\\\n\t'\t\t\t\t\tvar fs = 32;\\n'\\\n\t'\t\t\t\t\tif(w < 8) fs = 4*w | 0;\\n'\\\n\t'\t\t\t\t\tvar fs2 = fs*3/4;\\n'\\\n\t'\t\t\t\t\tphases[i].style.width = w+\"%\";\\n'\\\n\t'\t\t\t\t\tphases[i].style.left = left+\"%\";\\n'\\\n\t'\t\t\t\t\tphases[i].title = phases[i].id+\" \"+pd[phases[i].id]+\" ms\";\\n'\\\n\t'\t\t\t\t\tleft += w;\\n'\\\n\t'\t\t\t\t\tvar time = \"<t4 style=\\\\\"font-size:\"+fs+\"px\\\\\">\"+pd[phases[i].id]+\" ms<br></t4>\";\\n'\\\n\t'\t\t\t\t\tvar pname = \"<t3 style=\\\\\"font-size:\"+fs2+\"px\\\\\">\"+phases[i].id.replace(new RegExp(\"_\", \"g\"), \" \")+\"</t3>\";\\n'\\\n\t'\t\t\t\t\tphases[i].innerHTML = time+pname;\\n'\\\n\t'\t\t\t\t} else {\\n'\\\n\t'\t\t\t\t\tphases[i].style.width = \"0%\";\\n'\\\n\t'\t\t\t\t\tphases[i].style.left = left+\"%\";\\n'\\\n\t'\t\t\t\t}\\n'\\\n\t'\t\t\t}\\n'\\\n\t'\t\t}\\n'\\\n\t'\t\tif(typeof devstats !== \\'undefined\\')\\n'\\\n\t'\t\t\tcallDetail(this.id, this.title);\\n'\\\n\t'\t\tvar cglist = document.getElementById(\"callgraphs\");\\n'\\\n\t'\t\tif(!cglist) return;\\n'\\\n\t'\t\tvar cg = cglist.getElementsByClassName(\"atop\");\\n'\\\n\t'\t\tif(cg.length < 10) return;\\n'\\\n\t'\t\tfor (var i = 0; i < cg.length; i++) {\\n'\\\n\t'\t\t\tcgid = cg[i].id.split(\"x\")[0]\\n'\\\n\t'\t\t\tif(idlist.indexOf(cgid) >= 0) {\\n'\\\n\t'\t\t\t\tcg[i].style.display = \"block\";\\n'\\\n\t'\t\t\t} else {\\n'\\\n\t'\t\t\t\tcg[i].style.display = \"none\";\\n'\\\n\t'\t\t\t}\\n'\\\n\t'\t\t}\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction callDetail(devid, devtitle) {\\n'\\\n\t'\t\tif(!(devid in devstats) || devstats[devid].length < 1)\\n'\\\n\t'\t\t\treturn;\\n'\\\n\t'\t\tvar list = devstats[devid];\\n'\\\n\t'\t\tvar tmp = devtitle.split(\" \");\\n'\\\n\t'\t\tvar name = tmp[0], phase = tmp[tmp.length-1];\\n'\\\n\t'\t\tvar dd = document.getElementById(phase);\\n'\\\n\t'\t\tvar total = parseFloat(tmp[1].slice(1));\\n'\\\n\t'\t\tvar mlist = [];\\n'\\\n\t'\t\tvar maxlen = 0;\\n'\\\n\t'\t\tvar info = []\\n'\\\n\t'\t\tfor(var i in list) {\\n'\\\n\t'\t\t\tif(list[i][0] == \"@\") {\\n'\\\n\t'\t\t\t\tinfo = list[i].split(\"|\");\\n'\\\n\t'\t\t\t\tcontinue;\\n'\\\n\t'\t\t\t}\\n'\\\n\t'\t\t\tvar tmp = list[i].split(\"|\");\\n'\\\n\t'\t\t\tvar t = parseFloat(tmp[0]), f = tmp[1], c = parseInt(tmp[2]);\\n'\\\n\t'\t\t\tvar p = (t*100.0/total).toFixed(2);\\n'\\\n\t'\t\t\tmlist[mlist.length] = [f, c, t.toFixed(2), p+\"%\"];\\n'\\\n\t'\t\t\tif(f.length > maxlen)\\n'\\\n\t'\t\t\t\tmaxlen = f.length;\\n'\\\n\t'\t\t}\\n'\\\n\t'\t\tvar pad = 5;\\n'\\\n\t'\t\tif(mlist.length == 0) pad = 30;\\n'\\\n\t'\t\tvar html = \\'<div style=\"padding-top:\\'+pad+\\'px\"><t3> <b>\\'+name+\\':</b>\\';\\n'\\\n\t'\t\tif(info.length > 2)\\n'\\\n\t'\t\t\thtml += \" start=<b>\"+info[1]+\"</b>, end=<b>\"+info[2]+\"</b>\";\\n'\\\n\t'\t\tif(info.length > 3)\\n'\\\n\t'\t\t\thtml += \", length<i>(w/o overhead)</i>=<b>\"+info[3]+\" ms</b>\";\\n'\\\n\t'\t\tif(info.length > 4)\\n'\\\n\t'\t\t\thtml += \", return=<b>\"+info[4]+\"</b>\";\\n'\\\n\t'\t\thtml += \"</t3></div>\";\\n'\\\n\t'\t\tif(mlist.length > 0) {\\n'\\\n\t'\t\t\thtml += \\'<table class=fstat style=\"padding-top:\\'+(maxlen*5)+\\'px;\"><tr><th>Function</th>\\';\\n'\\\n\t'\t\t\tfor(var i in mlist)\\n'\\\n\t'\t\t\t\thtml += \"<td class=vt>\"+mlist[i][0]+\"</td>\";\\n'\\\n\t'\t\t\thtml += \"</tr><tr><th>Calls</th>\";\\n'\\\n\t'\t\t\tfor(var i in mlist)\\n'\\\n\t'\t\t\t\thtml += \"<td>\"+mlist[i][1]+\"</td>\";\\n'\\\n\t'\t\t\thtml += \"</tr><tr><th>Time(ms)</th>\";\\n'\\\n\t'\t\t\tfor(var i in mlist)\\n'\\\n\t'\t\t\t\thtml += \"<td>\"+mlist[i][2]+\"</td>\";\\n'\\\n\t'\t\t\thtml += \"</tr><tr><th>Percent</th>\";\\n'\\\n\t'\t\t\tfor(var i in mlist)\\n'\\\n\t'\t\t\t\thtml += \"<td>\"+mlist[i][3]+\"</td>\";\\n'\\\n\t'\t\t\thtml += \"</tr></table>\";\\n'\\\n\t'\t\t}\\n'\\\n\t'\t\tdd.innerHTML = html;\\n'\\\n\t'\t\tvar height = (maxlen*5)+100;\\n'\\\n\t'\t\tdd.style.height = height+\"px\";\\n'\\\n\t'\t\tdocument.getElementById(\"devicedetail\").style.height = height+\"px\";\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction callSelect() {\\n'\\\n\t'\t\tvar cglist = document.getElementById(\"callgraphs\");\\n'\\\n\t'\t\tif(!cglist) return;\\n'\\\n\t'\t\tvar cg = cglist.getElementsByClassName(\"atop\");\\n'\\\n\t'\t\tfor (var i = 0; i < cg.length; i++) {\\n'\\\n\t'\t\t\tif(this.id == cg[i].id) {\\n'\\\n\t'\t\t\t\tcg[i].style.display = \"block\";\\n'\\\n\t'\t\t\t} else {\\n'\\\n\t'\t\t\t\tcg[i].style.display = \"none\";\\n'\\\n\t'\t\t\t}\\n'\\\n\t'\t\t}\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction devListWindow(e) {\\n'\\\n\t'\t\tvar win = window.open();\\n'\\\n\t'\t\tvar html = \"<title>\"+e.target.innerHTML+\"</title>\"+\\n'\\\n\t'\t\t\t\"<style type=\\\\\"text/css\\\\\">\"+\\n'\\\n\t'\t\t\t\"   ul {list-style-type:circle;padding-left:10px;margin-left:10px;}\"+\\n'\\\n\t'\t\t\t\"</style>\"\\n'\\\n\t'\t\tvar dt = devtable[0];\\n'\\\n\t'\t\tif(e.target.id != \"devlist1\")\\n'\\\n\t'\t\t\tdt = devtable[1];\\n'\\\n\t'\t\twin.document.write(html+dt);\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction errWindow() {\\n'\\\n\t'\t\tvar range = this.id.split(\"_\");\\n'\\\n\t'\t\tvar idx1 = parseInt(range[0]);\\n'\\\n\t'\t\tvar idx2 = parseInt(range[1]);\\n'\\\n\t'\t\tvar win = window.open();\\n'\\\n\t'\t\tvar log = document.getElementById(\"dmesglog\");\\n'\\\n\t'\t\tvar title = \"<title>dmesg log</title>\";\\n'\\\n\t'\t\tvar text = log.innerHTML.split(\"\\\\n\");\\n'\\\n\t'\t\tvar html = \"\";\\n'\\\n\t'\t\tfor(var i = 0; i < text.length; i++) {\\n'\\\n\t'\t\t\tif(i == idx1) {\\n'\\\n\t'\t\t\t\thtml += \"<e id=target>\"+text[i]+\"</e>\\\\n\";\\n'\\\n\t'\t\t\t} else if(i > idx1 && i <= idx2) {\\n'\\\n\t'\t\t\t\thtml += \"<e>\"+text[i]+\"</e>\\\\n\";\\n'\\\n\t'\t\t\t} else {\\n'\\\n\t'\t\t\t\thtml += text[i]+\"\\\\n\";\\n'\\\n\t'\t\t\t}\\n'\\\n\t'\t\t}\\n'\\\n\t'\t\twin.document.write(\"<style>e{color:red}</style>\"+title+\"<pre>\"+html+\"</pre>\");\\n'\\\n\t'\t\twin.location.hash = \"#target\";\\n'\\\n\t'\t\twin.document.close();\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction logWindow(e) {\\n'\\\n\t'\t\tvar name = e.target.id.slice(4);\\n'\\\n\t'\t\tvar win = window.open();\\n'\\\n\t'\t\tvar log = document.getElementById(name+\"log\");\\n'\\\n\t'\t\tvar title = \"<title>\"+document.title.split(\" \")[0]+\" \"+name+\" log</title>\";\\n'\\\n\t'\t\twin.document.write(title+\"<pre>\"+log.innerHTML+\"</pre>\");\\n'\\\n\t'\t\twin.document.close();\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction onMouseDown(e) {\\n'\\\n\t'\t\tdragval[0] = e.clientX;\\n'\\\n\t'\t\tdragval[1] = document.getElementById(\"dmesgzoombox\").scrollLeft;\\n'\\\n\t'\t\tdocument.onmousemove = onMouseMove;\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction onMouseMove(e) {\\n'\\\n\t'\t\tvar zoombox = document.getElementById(\"dmesgzoombox\");\\n'\\\n\t'\t\tzoombox.scrollLeft = dragval[1] + dragval[0] - e.clientX;\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction onMouseUp(e) {\\n'\\\n\t'\t\tdocument.onmousemove = null;\\n'\\\n\t'\t}\\n'\\\n\t'\tfunction onKeyPress(e) {\\n'\\\n\t'\t\tvar c = e.charCode;\\n'\\\n\t'\t\tif(c != 42 && c != 43 && c != 45) return;\\n'\\\n\t'\t\tvar click = document.createEvent(\"Events\");\\n'\\\n\t'\t\tclick.initEvent(\"click\", true, false);\\n'\\\n\t'\t\tif(c == 43)  \\n'\\\n\t'\t\t\tdocument.getElementById(\"zoomin\").dispatchEvent(click);\\n'\\\n\t'\t\telse if(c == 45)\\n'\\\n\t'\t\t\tdocument.getElementById(\"zoomout\").dispatchEvent(click);\\n'\\\n\t'\t\telse if(c == 42)\\n'\\\n\t'\t\t\tdocument.getElementById(\"zoomdef\").dispatchEvent(click);\\n'\\\n\t'\t}\\n'\\\n\t'\twindow.addEventListener(\"resize\", function () {zoomTimeline();});\\n'\\\n\t'\twindow.addEventListener(\"load\", function () {\\n'\\\n\t'\t\tvar dmesg = document.getElementById(\"dmesg\");\\n'\\\n\t'\t\tdmesg.style.width = \"100%\"\\n'\\\n\t'\t\tdmesg.onmousedown = onMouseDown;\\n'\\\n\t'\t\tdocument.onmouseup = onMouseUp;\\n'\\\n\t'\t\tdocument.onkeypress = onKeyPress;\\n'\\\n\t'\t\tdocument.getElementById(\"zoomin\").onclick = zoomTimeline;\\n'\\\n\t'\t\tdocument.getElementById(\"zoomout\").onclick = zoomTimeline;\\n'\\\n\t'\t\tdocument.getElementById(\"zoomdef\").onclick = zoomTimeline;\\n'\\\n\t'\t\tvar list = document.getElementsByClassName(\"err\");\\n'\\\n\t'\t\tfor (var i = 0; i < list.length; i++)\\n'\\\n\t'\t\t\tlist[i].onclick = errWindow;\\n'\\\n\t'\t\tvar list = document.getElementsByClassName(\"logbtn\");\\n'\\\n\t'\t\tfor (var i = 0; i < list.length; i++)\\n'\\\n\t'\t\t\tlist[i].onclick = logWindow;\\n'\\\n\t'\t\tlist = document.getElementsByClassName(\"devlist\");\\n'\\\n\t'\t\tfor (var i = 0; i < list.length; i++)\\n'\\\n\t'\t\t\tlist[i].onclick = devListWindow;\\n'\\\n\t'\t\tvar dev = dmesg.getElementsByClassName(\"thread\");\\n'\\\n\t'\t\tfor (var i = 0; i < dev.length; i++) {\\n'\\\n\t'\t\t\tdev[i].onclick = deviceDetail;\\n'\\\n\t'\t\t\tdev[i].onmouseover = deviceHover;\\n'\\\n\t'\t\t\tdev[i].onmouseout = deviceUnhover;\\n'\\\n\t'\t\t}\\n'\\\n\t'\t\tvar dev = dmesg.getElementsByClassName(\"srccall\");\\n'\\\n\t'\t\tfor (var i = 0; i < dev.length; i++)\\n'\\\n\t'\t\t\tdev[i].onclick = callSelect;\\n'\\\n\t'\t\tzoomTimeline();\\n'\\\n\t'\t});\\n'\\\n\t'</script>\\n'\n\thf.write(script_code);\n\n# Function: executeSuspend\n# Description:\n#\t Execute system suspend through the sysfs interface, then copy the output\n#\t dmesg and ftrace files to the test output directory.\ndef executeSuspend(quiet=False):\n\tsv, tp, pm = sysvals, sysvals.tpath, ProcessMonitor()\n\tif sv.wifi:\n\t\twifi = sv.checkWifi()\n\t\tsv.dlog('wifi check, connected device is \"%s\"' % wifi)\n\ttestdata = []\n\t# run these commands to prepare the system for suspend\n\tif sv.display:\n\t\tif not quiet:\n\t\t\tpprint('SET DISPLAY TO %s' % sv.display.upper())\n\t\tret = sv.displayControl(sv.display)\n\t\tsv.dlog('xset display %s, ret = %d' % (sv.display, ret))\n\t\ttime.sleep(1)\n\tif sv.sync:\n\t\tif not quiet:\n\t\t\tpprint('SYNCING FILESYSTEMS')\n\t\tsv.dlog('syncing filesystems')\n\t\tcall('sync', shell=True)\n\tsv.dlog('read dmesg')\n\tsv.initdmesg()\n\tsv.dlog('cmdinfo before')\n\tsv.cmdinfo(True)\n\tsv.start(pm)\n\t# execute however many s/r runs requested\n\tfor count in range(1,sv.execcount+1):\n\t\t# x2delay in between test runs\n\t\tif(count > 1 and sv.x2delay > 0):\n\t\t\tsv.fsetVal('WAIT %d' % sv.x2delay, 'trace_marker')\n\t\t\ttime.sleep(sv.x2delay/1000.0)\n\t\t\tsv.fsetVal('WAIT END', 'trace_marker')\n\t\t# start message\n\t\tif sv.testcommand != '':\n\t\t\tpprint('COMMAND START')\n\t\telse:\n\t\t\tif(sv.rtcwake):\n\t\t\t\tpprint('SUSPEND START')\n\t\t\telse:\n\t\t\t\tpprint('SUSPEND START (press a key to resume)')\n\t\t# set rtcwake\n\t\tif(sv.rtcwake):\n\t\t\tif not quiet:\n\t\t\t\tpprint('will issue an rtcwake in %d seconds' % sv.rtcwaketime)\n\t\t\tsv.dlog('enable RTC wake alarm')\n\t\t\tsv.rtcWakeAlarmOn()\n\t\t# start of suspend trace marker\n\t\tsv.fsetVal(datetime.now().strftime(sv.tmstart), 'trace_marker')\n\t\t# predelay delay\n\t\tif(count == 1 and sv.predelay > 0):\n\t\t\tsv.fsetVal('WAIT %d' % sv.predelay, 'trace_marker')\n\t\t\ttime.sleep(sv.predelay/1000.0)\n\t\t\tsv.fsetVal('WAIT END', 'trace_marker')\n\t\t# initiate suspend or command\n\t\tsv.dlog('system executing a suspend')\n\t\ttdata = {'error': ''}\n\t\tif sv.testcommand != '':\n\t\t\tres = call(sv.testcommand+' 2>&1', shell=True);\n\t\t\tif res != 0:\n\t\t\t\ttdata['error'] = 'cmd returned %d' % res\n\t\telse:\n\t\t\ts0ixready = sv.s0ixSupport()\n\t\t\tmode = sv.suspendmode\n\t\t\tif sv.memmode and os.path.exists(sv.mempowerfile):\n\t\t\t\tmode = 'mem'\n\t\t\t\tsv.testVal(sv.mempowerfile, 'radio', sv.memmode)\n\t\t\tif sv.diskmode and os.path.exists(sv.diskpowerfile):\n\t\t\t\tmode = 'disk'\n\t\t\t\tsv.testVal(sv.diskpowerfile, 'radio', sv.diskmode)\n\t\t\tif sv.acpidebug:\n\t\t\t\tsv.testVal(sv.acpipath, 'acpi', '0xe')\n\t\t\tif ((mode == 'freeze') or (sv.memmode == 's2idle')) \\\n\t\t\t\tand sv.haveTurbostat():\n\t\t\t\t# execution will pause here\n\t\t\t\tturbo = sv.turbostat(s0ixready)\n\t\t\t\tif turbo:\n\t\t\t\t\ttdata['turbo'] = turbo\n\t\t\telse:\n\t\t\t\tpf = open(sv.powerfile, 'w')\n\t\t\t\tpf.write(mode)\n\t\t\t\t# execution will pause here\n\t\t\t\ttry:\n\t\t\t\t\tpf.close()\n\t\t\t\texcept Exception as e:\n\t\t\t\t\ttdata['error'] = str(e)\n\t\tsv.fsetVal('CMD COMPLETE', 'trace_marker')\n\t\tsv.dlog('system returned')\n\t\t# reset everything\n\t\tsv.testVal('restoreall')\n\t\tif(sv.rtcwake):\n\t\t\tsv.dlog('disable RTC wake alarm')\n\t\t\tsv.rtcWakeAlarmOff()\n\t\t# postdelay delay\n\t\tif(count == sv.execcount and sv.postdelay > 0):\n\t\t\tsv.fsetVal('WAIT %d' % sv.postdelay, 'trace_marker')\n\t\t\ttime.sleep(sv.postdelay/1000.0)\n\t\t\tsv.fsetVal('WAIT END', 'trace_marker')\n\t\t# return from suspend\n\t\tpprint('RESUME COMPLETE')\n\t\tif(count < sv.execcount):\n\t\t\tsv.fsetVal(datetime.now().strftime(sv.tmend), 'trace_marker')\n\t\telif(not sv.wifitrace):\n\t\t\tsv.fsetVal(datetime.now().strftime(sv.tmend), 'trace_marker')\n\t\t\tsv.stop(pm)\n\t\tif sv.wifi and wifi:\n\t\t\ttdata['wifi'] = sv.pollWifi(wifi)\n\t\t\tsv.dlog('wifi check, %s' % tdata['wifi'])\n\t\tif(count == sv.execcount and sv.wifitrace):\n\t\t\tsv.fsetVal(datetime.now().strftime(sv.tmend), 'trace_marker')\n\t\t\tsv.stop(pm)\n\t\tif sv.netfix:\n\t\t\ttdata['netfix'] = sv.netfixon()\n\t\t\tsv.dlog('netfix, %s' % tdata['netfix'])\n\t\tif(sv.suspendmode == 'mem' or sv.suspendmode == 'command'):\n\t\t\tsv.dlog('read the ACPI FPDT')\n\t\t\ttdata['fw'] = getFPDT(False)\n\t\ttestdata.append(tdata)\n\tsv.dlog('cmdinfo after')\n\tcmdafter = sv.cmdinfo(False)\n\t# grab a copy of the dmesg output\n\tif not quiet:\n\t\tpprint('CAPTURING DMESG')\n\tsv.getdmesg(testdata)\n\t# grab a copy of the ftrace output\n\tif sv.useftrace:\n\t\tif not quiet:\n\t\t\tpprint('CAPTURING TRACE')\n\t\top = sv.writeDatafileHeader(sv.ftracefile, testdata)\n\t\tfp = open(tp+'trace', 'rb')\n\t\top.write(ascii(fp.read()))\n\t\top.close()\n\t\tsv.fsetVal('', 'trace')\n\t\tsv.platforminfo(cmdafter)\n\ndef readFile(file):\n\tif os.path.islink(file):\n\t\treturn os.readlink(file).split('/')[-1]\n\telse:\n\t\treturn sysvals.getVal(file).strip()\n\n# Function: ms2nice\n# Description:\n#\t Print out a very concise time string in minutes and seconds\n# Output:\n#\t The time string, e.g. \"1901m16s\"\ndef ms2nice(val):\n\tval = int(val)\n\th = val // 3600000\n\tm = (val // 60000) % 60\n\ts = (val // 1000) % 60\n\tif h > 0:\n\t\treturn '%d:%02d:%02d' % (h, m, s)\n\tif m > 0:\n\t\treturn '%02d:%02d' % (m, s)\n\treturn '%ds' % s\n\ndef yesno(val):\n\tlist = {'enabled':'A', 'disabled':'S', 'auto':'E', 'on':'D',\n\t\t'active':'A', 'suspended':'S', 'suspending':'S'}\n\tif val not in list:\n\t\treturn ' '\n\treturn list[val]\n\n# Function: deviceInfo\n# Description:\n#\t Detect all the USB hosts and devices currently connected and add\n#\t a list of USB device names to sysvals for better timeline readability\ndef deviceInfo(output=''):\n\tif not output:\n\t\tpprint('LEGEND\\n'\\\n\t\t'---------------------------------------------------------------------------------------------\\n'\\\n\t\t'  A = async/sync PM queue (A/S)               C = runtime active children\\n'\\\n\t\t'  R = runtime suspend enabled/disabled (E/D)  rACTIVE = runtime active (min/sec)\\n'\\\n\t\t'  S = runtime status active/suspended (A/S)   rSUSPEND = runtime suspend (min/sec)\\n'\\\n\t\t'  U = runtime usage count\\n'\\\n\t\t'---------------------------------------------------------------------------------------------\\n'\\\n\t\t'DEVICE                     NAME                       A R S U C    rACTIVE   rSUSPEND\\n'\\\n\t\t'---------------------------------------------------------------------------------------------')\n\n\tres = []\n\ttgtval = 'runtime_status'\n\tlines = dict()\n\tfor dirname, dirnames, filenames in os.walk('/sys/devices'):\n\t\tif(not re.match('.*/power', dirname) or\n\t\t\t'control' not in filenames or\n\t\t\ttgtval not in filenames):\n\t\t\tcontinue\n\t\tname = ''\n\t\tdirname = dirname[:-6]\n\t\tdevice = dirname.split('/')[-1]\n\t\tpower = dict()\n\t\tpower[tgtval] = readFile('%s/power/%s' % (dirname, tgtval))\n\t\t# only list devices which support runtime suspend\n\t\tif power[tgtval] not in ['active', 'suspended', 'suspending']:\n\t\t\tcontinue\n\t\tfor i in ['product', 'driver', 'subsystem']:\n\t\t\tfile = '%s/%s' % (dirname, i)\n\t\t\tif os.path.exists(file):\n\t\t\t\tname = readFile(file)\n\t\t\t\tbreak\n\t\tfor i in ['async', 'control', 'runtime_status', 'runtime_usage',\n\t\t\t'runtime_active_kids', 'runtime_active_time',\n\t\t\t'runtime_suspended_time']:\n\t\t\tif i in filenames:\n\t\t\t\tpower[i] = readFile('%s/power/%s' % (dirname, i))\n\t\tif output:\n\t\t\tif power['control'] == output:\n\t\t\t\tres.append('%s/power/control' % dirname)\n\t\t\tcontinue\n\t\tlines[dirname] = '%-26s %-26s %1s %1s %1s %1s %1s %10s %10s' % \\\n\t\t\t(device[:26], name[:26],\n\t\t\tyesno(power['async']), \\\n\t\t\tyesno(power['control']), \\\n\t\t\tyesno(power['runtime_status']), \\\n\t\t\tpower['runtime_usage'], \\\n\t\t\tpower['runtime_active_kids'], \\\n\t\t\tms2nice(power['runtime_active_time']), \\\n\t\t\tms2nice(power['runtime_suspended_time']))\n\tfor i in sorted(lines):\n\t\tprint(lines[i])\n\treturn res\n\n# Function: getModes\n# Description:\n#\t Determine the supported power modes on this system\n# Output:\n#\t A string list of the available modes\ndef getModes():\n\tmodes = []\n\tif(os.path.exists(sysvals.powerfile)):\n\t\tfp = open(sysvals.powerfile, 'r')\n\t\tmodes = fp.read().split()\n\t\tfp.close()\n\tif(os.path.exists(sysvals.mempowerfile)):\n\t\tdeep = False\n\t\tfp = open(sysvals.mempowerfile, 'r')\n\t\tfor m in fp.read().split():\n\t\t\tmemmode = m.strip('[]')\n\t\t\tif memmode == 'deep':\n\t\t\t\tdeep = True\n\t\t\telse:\n\t\t\t\tmodes.append('mem-%s' % memmode)\n\t\tfp.close()\n\t\tif 'mem' in modes and not deep:\n\t\t\tmodes.remove('mem')\n\tif('disk' in modes and os.path.exists(sysvals.diskpowerfile)):\n\t\tfp = open(sysvals.diskpowerfile, 'r')\n\t\tfor m in fp.read().split():\n\t\t\tmodes.append('disk-%s' % m.strip('[]'))\n\t\tfp.close()\n\treturn modes\n\n# Function: dmidecode\n# Description:\n#\t Read the bios tables and pull out system info\n# Arguments:\n#\t mempath: /dev/mem or custom mem path\n#\t fatal: True to exit on error, False to return empty dict\n# Output:\n#\t A dict object with all available key/values\ndef dmidecode(mempath, fatal=False):\n\tout = dict()\n\n\t# the list of values to retrieve, with hardcoded (type, idx)\n\tinfo = {\n\t\t'bios-vendor': (0, 4),\n\t\t'bios-version': (0, 5),\n\t\t'bios-release-date': (0, 8),\n\t\t'system-manufacturer': (1, 4),\n\t\t'system-product-name': (1, 5),\n\t\t'system-version': (1, 6),\n\t\t'system-serial-number': (1, 7),\n\t\t'baseboard-manufacturer': (2, 4),\n\t\t'baseboard-product-name': (2, 5),\n\t\t'baseboard-version': (2, 6),\n\t\t'baseboard-serial-number': (2, 7),\n\t\t'chassis-manufacturer': (3, 4),\n\t\t'chassis-type': (3, 5),\n\t\t'chassis-version': (3, 6),\n\t\t'chassis-serial-number': (3, 7),\n\t\t'processor-manufacturer': (4, 7),\n\t\t'processor-version': (4, 16),\n\t}\n\tif(not os.path.exists(mempath)):\n\t\tif(fatal):\n\t\t\tdoError('file does not exist: %s' % mempath)\n\t\treturn out\n\tif(not os.access(mempath, os.R_OK)):\n\t\tif(fatal):\n\t\t\tdoError('file is not readable: %s' % mempath)\n\t\treturn out\n\n\t# by default use legacy scan, but try to use EFI first\n\tmemaddr = 0xf0000\n\tmemsize = 0x10000\n\tfor ep in ['/sys/firmware/efi/systab', '/proc/efi/systab']:\n\t\tif not os.path.exists(ep) or not os.access(ep, os.R_OK):\n\t\t\tcontinue\n\t\tfp = open(ep, 'r')\n\t\tbuf = fp.read()\n\t\tfp.close()\n\t\ti = buf.find('SMBIOS=')\n\t\tif i >= 0:\n\t\t\ttry:\n\t\t\t\tmemaddr = int(buf[i+7:], 16)\n\t\t\t\tmemsize = 0x20\n\t\t\texcept:\n\t\t\t\tcontinue\n\n\t# read in the memory for scanning\n\ttry:\n\t\tfp = open(mempath, 'rb')\n\t\tfp.seek(memaddr)\n\t\tbuf = fp.read(memsize)\n\texcept:\n\t\tif(fatal):\n\t\t\tdoError('DMI table is unreachable, sorry')\n\t\telse:\n\t\t\tpprint('WARNING: /dev/mem is not readable, ignoring DMI data')\n\t\t\treturn out\n\tfp.close()\n\n\t# search for either an SM table or DMI table\n\ti = base = length = num = 0\n\twhile(i < memsize):\n\t\tif buf[i:i+4] == b'_SM_' and i < memsize - 16:\n\t\t\tlength = struct.unpack('H', buf[i+22:i+24])[0]\n\t\t\tbase, num = struct.unpack('IH', buf[i+24:i+30])\n\t\t\tbreak\n\t\telif buf[i:i+5] == b'_DMI_':\n\t\t\tlength = struct.unpack('H', buf[i+6:i+8])[0]\n\t\t\tbase, num = struct.unpack('IH', buf[i+8:i+14])\n\t\t\tbreak\n\t\ti += 16\n\tif base == 0 and length == 0 and num == 0:\n\t\tif(fatal):\n\t\t\tdoError('Neither SMBIOS nor DMI were found')\n\t\telse:\n\t\t\treturn out\n\n\t# read in the SM or DMI table\n\ttry:\n\t\tfp = open(mempath, 'rb')\n\t\tfp.seek(base)\n\t\tbuf = fp.read(length)\n\texcept:\n\t\tif(fatal):\n\t\t\tdoError('DMI table is unreachable, sorry')\n\t\telse:\n\t\t\tpprint('WARNING: /dev/mem is not readable, ignoring DMI data')\n\t\t\treturn out\n\tfp.close()\n\n\t# scan the table for the values we want\n\tcount = i = 0\n\twhile(count < num and i <= len(buf) - 4):\n\t\ttype, size, handle = struct.unpack('BBH', buf[i:i+4])\n\t\tn = i + size\n\t\twhile n < len(buf) - 1:\n\t\t\tif 0 == struct.unpack('H', buf[n:n+2])[0]:\n\t\t\t\tbreak\n\t\t\tn += 1\n\t\tdata = buf[i+size:n+2].split(b'\\0')\n\t\tfor name in info:\n\t\t\titype, idxadr = info[name]\n\t\t\tif itype == type:\n\t\t\t\tidx = struct.unpack('B', buf[i+idxadr:i+idxadr+1])[0]\n\t\t\t\tif idx > 0 and idx < len(data) - 1:\n\t\t\t\t\ts = data[idx-1].decode('utf-8')\n\t\t\t\t\tif s.strip() and s.strip().lower() != 'to be filled by o.e.m.':\n\t\t\t\t\t\tout[name] = s\n\t\ti = n + 2\n\t\tcount += 1\n\treturn out\n\n# Function: getFPDT\n# Description:\n#\t Read the acpi bios tables and pull out FPDT, the firmware data\n# Arguments:\n#\t output: True to output the info to stdout, False otherwise\ndef getFPDT(output):\n\trectype = {}\n\trectype[0] = 'Firmware Basic Boot Performance Record'\n\trectype[1] = 'S3 Performance Table Record'\n\tprectype = {}\n\tprectype[0] = 'Basic S3 Resume Performance Record'\n\tprectype[1] = 'Basic S3 Suspend Performance Record'\n\n\tsysvals.rootCheck(True)\n\tif(not os.path.exists(sysvals.fpdtpath)):\n\t\tif(output):\n\t\t\tdoError('file does not exist: %s' % sysvals.fpdtpath)\n\t\treturn False\n\tif(not os.access(sysvals.fpdtpath, os.R_OK)):\n\t\tif(output):\n\t\t\tdoError('file is not readable: %s' % sysvals.fpdtpath)\n\t\treturn False\n\tif(not os.path.exists(sysvals.mempath)):\n\t\tif(output):\n\t\t\tdoError('file does not exist: %s' % sysvals.mempath)\n\t\treturn False\n\tif(not os.access(sysvals.mempath, os.R_OK)):\n\t\tif(output):\n\t\t\tdoError('file is not readable: %s' % sysvals.mempath)\n\t\treturn False\n\n\tfp = open(sysvals.fpdtpath, 'rb')\n\tbuf = fp.read()\n\tfp.close()\n\n\tif(len(buf) < 36):\n\t\tif(output):\n\t\t\tdoError('Invalid FPDT table data, should '+\\\n\t\t\t\t'be at least 36 bytes')\n\t\treturn False\n\n\ttable = struct.unpack('4sIBB6s8sI4sI', buf[0:36])\n\tif(output):\n\t\tpprint('\\n'\\\n\t\t'Firmware Performance Data Table (%s)\\n'\\\n\t\t'                  Signature : %s\\n'\\\n\t\t'               Table Length : %u\\n'\\\n\t\t'                   Revision : %u\\n'\\\n\t\t'                   Checksum : 0x%x\\n'\\\n\t\t'                     OEM ID : %s\\n'\\\n\t\t'               OEM Table ID : %s\\n'\\\n\t\t'               OEM Revision : %u\\n'\\\n\t\t'                 Creator ID : %s\\n'\\\n\t\t'           Creator Revision : 0x%x\\n'\\\n\t\t'' % (ascii(table[0]), ascii(table[0]), table[1], table[2],\n\t\t\ttable[3], ascii(table[4]), ascii(table[5]), table[6],\n\t\t\tascii(table[7]), table[8]))\n\n\tif(table[0] != b'FPDT'):\n\t\tif(output):\n\t\t\tdoError('Invalid FPDT table')\n\t\treturn False\n\tif(len(buf) <= 36):\n\t\treturn False\n\ti = 0\n\tfwData = [0, 0]\n\trecords = buf[36:]\n\ttry:\n\t\tfp = open(sysvals.mempath, 'rb')\n\texcept:\n\t\tpprint('WARNING: /dev/mem is not readable, ignoring the FPDT data')\n\t\treturn False\n\twhile(i < len(records)):\n\t\theader = struct.unpack('HBB', records[i:i+4])\n\t\tif(header[0] not in rectype):\n\t\t\ti += header[1]\n\t\t\tcontinue\n\t\tif(header[1] != 16):\n\t\t\ti += header[1]\n\t\t\tcontinue\n\t\taddr = struct.unpack('Q', records[i+8:i+16])[0]\n\t\ttry:\n\t\t\tfp.seek(addr)\n\t\t\tfirst = fp.read(8)\n\t\texcept:\n\t\t\tif(output):\n\t\t\t\tpprint('Bad address 0x%x in %s' % (addr, sysvals.mempath))\n\t\t\treturn [0, 0]\n\t\trechead = struct.unpack('4sI', first)\n\t\trecdata = fp.read(rechead[1]-8)\n\t\tif(rechead[0] == b'FBPT'):\n\t\t\trecord = struct.unpack('HBBIQQQQQ', recdata[:48])\n\t\t\tif(output):\n\t\t\t\tpprint('%s (%s)\\n'\\\n\t\t\t\t'                  Reset END : %u ns\\n'\\\n\t\t\t\t'  OS Loader LoadImage Start : %u ns\\n'\\\n\t\t\t\t' OS Loader StartImage Start : %u ns\\n'\\\n\t\t\t\t'     ExitBootServices Entry : %u ns\\n'\\\n\t\t\t\t'      ExitBootServices Exit : %u ns'\\\n\t\t\t\t'' % (rectype[header[0]], ascii(rechead[0]), record[4], record[5],\n\t\t\t\t\trecord[6], record[7], record[8]))\n\t\telif(rechead[0] == b'S3PT'):\n\t\t\tif(output):\n\t\t\t\tpprint('%s (%s)' % (rectype[header[0]], ascii(rechead[0])))\n\t\t\tj = 0\n\t\t\twhile(j < len(recdata)):\n\t\t\t\tprechead = struct.unpack('HBB', recdata[j:j+4])\n\t\t\t\tif(prechead[0] not in prectype):\n\t\t\t\t\tcontinue\n\t\t\t\tif(prechead[0] == 0):\n\t\t\t\t\trecord = struct.unpack('IIQQ', recdata[j:j+prechead[1]])\n\t\t\t\t\tfwData[1] = record[2]\n\t\t\t\t\tif(output):\n\t\t\t\t\t\tpprint('    %s\\n'\\\n\t\t\t\t\t\t'               Resume Count : %u\\n'\\\n\t\t\t\t\t\t'                 FullResume : %u ns\\n'\\\n\t\t\t\t\t\t'              AverageResume : %u ns'\\\n\t\t\t\t\t\t'' % (prectype[prechead[0]], record[1],\n\t\t\t\t\t\t\t\trecord[2], record[3]))\n\t\t\t\telif(prechead[0] == 1):\n\t\t\t\t\trecord = struct.unpack('QQ', recdata[j+4:j+prechead[1]])\n\t\t\t\t\tfwData[0] = record[1] - record[0]\n\t\t\t\t\tif(output):\n\t\t\t\t\t\tpprint('    %s\\n'\\\n\t\t\t\t\t\t'               SuspendStart : %u ns\\n'\\\n\t\t\t\t\t\t'                 SuspendEnd : %u ns\\n'\\\n\t\t\t\t\t\t'                SuspendTime : %u ns'\\\n\t\t\t\t\t\t'' % (prectype[prechead[0]], record[0],\n\t\t\t\t\t\t\t\trecord[1], fwData[0]))\n\n\t\t\t\tj += prechead[1]\n\t\tif(output):\n\t\t\tpprint('')\n\t\ti += header[1]\n\tfp.close()\n\treturn fwData\n\n# Function: statusCheck\n# Description:\n#\t Verify that the requested command and options will work, and\n#\t print the results to the terminal\n# Output:\n#\t True if the test will work, False if not\ndef statusCheck(probecheck=False):\n\tstatus = ''\n\n\tpprint('Checking this system (%s)...' % platform.node())\n\n\t# check we have root access\n\tres = sysvals.colorText('NO (No features of this tool will work!)')\n\tif(sysvals.rootCheck(False)):\n\t\tres = 'YES'\n\tpprint('    have root access: %s' % res)\n\tif(res != 'YES'):\n\t\tpprint('    Try running this script with sudo')\n\t\treturn 'missing root access'\n\n\t# check sysfs is mounted\n\tres = sysvals.colorText('NO (No features of this tool will work!)')\n\tif(os.path.exists(sysvals.powerfile)):\n\t\tres = 'YES'\n\tpprint('    is sysfs mounted: %s' % res)\n\tif(res != 'YES'):\n\t\treturn 'sysfs is missing'\n\n\t# check target mode is a valid mode\n\tif sysvals.suspendmode != 'command':\n\t\tres = sysvals.colorText('NO')\n\t\tmodes = getModes()\n\t\tif(sysvals.suspendmode in modes):\n\t\t\tres = 'YES'\n\t\telse:\n\t\t\tstatus = '%s mode is not supported' % sysvals.suspendmode\n\t\tpprint('    is \"%s\" a valid power mode: %s' % (sysvals.suspendmode, res))\n\t\tif(res == 'NO'):\n\t\t\tpprint('      valid power modes are: %s' % modes)\n\t\t\tpprint('      please choose one with -m')\n\n\t# check if ftrace is available\n\tif sysvals.useftrace:\n\t\tres = sysvals.colorText('NO')\n\t\tsysvals.useftrace = sysvals.verifyFtrace()\n\t\tefmt = '\"{0}\" uses ftrace, and it is not properly supported'\n\t\tif sysvals.useftrace:\n\t\t\tres = 'YES'\n\t\telif sysvals.usecallgraph:\n\t\t\tstatus = efmt.format('-f')\n\t\telif sysvals.usedevsrc:\n\t\t\tstatus = efmt.format('-dev')\n\t\telif sysvals.useprocmon:\n\t\t\tstatus = efmt.format('-proc')\n\t\tpprint('    is ftrace supported: %s' % res)\n\n\t# check if kprobes are available\n\tif sysvals.usekprobes:\n\t\tres = sysvals.colorText('NO')\n\t\tsysvals.usekprobes = sysvals.verifyKprobes()\n\t\tif(sysvals.usekprobes):\n\t\t\tres = 'YES'\n\t\telse:\n\t\t\tsysvals.usedevsrc = False\n\t\tpprint('    are kprobes supported: %s' % res)\n\n\t# what data source are we using\n\tres = 'DMESG (very limited, ftrace is preferred)'\n\tif sysvals.useftrace:\n\t\tsysvals.usetraceevents = True\n\t\tfor e in sysvals.traceevents:\n\t\t\tif not os.path.exists(sysvals.epath+e):\n\t\t\t\tsysvals.usetraceevents = False\n\t\tif(sysvals.usetraceevents):\n\t\t\tres = 'FTRACE (all trace events found)'\n\tpprint('    timeline data source: %s' % res)\n\n\t# check if rtcwake\n\tres = sysvals.colorText('NO')\n\tif(sysvals.rtcpath != ''):\n\t\tres = 'YES'\n\telif(sysvals.rtcwake):\n\t\tstatus = 'rtcwake is not properly supported'\n\tpprint('    is rtcwake supported: %s' % res)\n\n\t# check info commands\n\tpprint('    optional commands this tool may use for info:')\n\tno = sysvals.colorText('MISSING')\n\tyes = sysvals.colorText('FOUND', 32)\n\tfor c in ['turbostat', 'mcelog', 'lspci', 'lsusb', 'netfix']:\n\t\tif c == 'turbostat':\n\t\t\tres = yes if sysvals.haveTurbostat() else no\n\t\telse:\n\t\t\tres = yes if sysvals.getExec(c) else no\n\t\tpprint('        %s: %s' % (c, res))\n\n\tif not probecheck:\n\t\treturn status\n\n\t# verify kprobes\n\tif sysvals.usekprobes:\n\t\tfor name in sysvals.tracefuncs:\n\t\t\tsysvals.defaultKprobe(name, sysvals.tracefuncs[name])\n\t\tif sysvals.usedevsrc:\n\t\t\tfor name in sysvals.dev_tracefuncs:\n\t\t\t\tsysvals.defaultKprobe(name, sysvals.dev_tracefuncs[name])\n\t\tsysvals.addKprobes(True)\n\n\treturn status\n\n# Function: doError\n# Description:\n#\t generic error function for catastrphic failures\n# Arguments:\n#\t msg: the error message to print\n#\t help: True if printHelp should be called after, False otherwise\ndef doError(msg, help=False):\n\tif(help == True):\n\t\tprintHelp()\n\tpprint('ERROR: %s\\n' % msg)\n\tsysvals.outputResult({'error':msg})\n\tsys.exit(1)\n\n# Function: getArgInt\n# Description:\n#\t pull out an integer argument from the command line with checks\ndef getArgInt(name, args, min, max, main=True):\n\tif main:\n\t\ttry:\n\t\t\targ = next(args)\n\t\texcept:\n\t\t\tdoError(name+': no argument supplied', True)\n\telse:\n\t\targ = args\n\ttry:\n\t\tval = int(arg)\n\texcept:\n\t\tdoError(name+': non-integer value given', True)\n\tif(val < min or val > max):\n\t\tdoError(name+': value should be between %d and %d' % (min, max), True)\n\treturn val\n\n# Function: getArgFloat\n# Description:\n#\t pull out a float argument from the command line with checks\ndef getArgFloat(name, args, min, max, main=True):\n\tif main:\n\t\ttry:\n\t\t\targ = next(args)\n\t\texcept:\n\t\t\tdoError(name+': no argument supplied', True)\n\telse:\n\t\targ = args\n\ttry:\n\t\tval = float(arg)\n\texcept:\n\t\tdoError(name+': non-numerical value given', True)\n\tif(val < min or val > max):\n\t\tdoError(name+': value should be between %f and %f' % (min, max), True)\n\treturn val\n\ndef processData(live=False, quiet=False):\n\tif not quiet:\n\t\tpprint('PROCESSING: %s' % sysvals.htmlfile)\n\tsysvals.vprint('usetraceevents=%s, usetracemarkers=%s, usekprobes=%s' % \\\n\t\t(sysvals.usetraceevents, sysvals.usetracemarkers, sysvals.usekprobes))\n\terror = ''\n\tif(sysvals.usetraceevents):\n\t\ttestruns, error = parseTraceLog(live)\n\t\tif sysvals.dmesgfile:\n\t\t\tfor data in testruns:\n\t\t\t\tdata.extractErrorInfo()\n\telse:\n\t\ttestruns = loadKernelLog()\n\t\tfor data in testruns:\n\t\t\tparseKernelLog(data)\n\t\tif(sysvals.ftracefile and (sysvals.usecallgraph or sysvals.usetraceevents)):\n\t\t\tappendIncompleteTraceLog(testruns)\n\tif not sysvals.stamp:\n\t\tpprint('ERROR: data does not include the expected stamp')\n\t\treturn (testruns, {'error': 'timeline generation failed'})\n\tshown = ['os', 'bios', 'biosdate', 'cpu', 'host', 'kernel', 'man', 'memfr',\n\t\t\t'memsz', 'mode', 'numcpu', 'plat', 'time', 'wifi']\n\tsysvals.vprint('System Info:')\n\tfor key in sorted(sysvals.stamp):\n\t\tif key in shown:\n\t\t\tsysvals.vprint('    %-8s : %s' % (key.upper(), sysvals.stamp[key]))\n\tsysvals.vprint('Command:\\n    %s' % sysvals.cmdline)\n\tfor data in testruns:\n\t\tif data.turbostat:\n\t\t\tidx, s = 0, 'Turbostat:\\n    '\n\t\t\tfor val in data.turbostat.split('|'):\n\t\t\t\tidx += len(val) + 1\n\t\t\t\tif idx >= 80:\n\t\t\t\t\tidx = 0\n\t\t\t\t\ts += '\\n    '\n\t\t\t\ts += val + ' '\n\t\t\tsysvals.vprint(s)\n\t\tdata.printDetails()\n\tif len(sysvals.platinfo) > 0:\n\t\tsysvals.vprint('\\nPlatform Info:')\n\t\tfor info in sysvals.platinfo:\n\t\t\tsysvals.vprint('[%s - %s]' % (info[0], info[1]))\n\t\t\tsysvals.vprint(info[2])\n\t\tsysvals.vprint('')\n\tif sysvals.cgdump:\n\t\tfor data in testruns:\n\t\t\tdata.debugPrint()\n\t\tsys.exit(0)\n\tif len(testruns) < 1:\n\t\tpprint('ERROR: Not enough test data to build a timeline')\n\t\treturn (testruns, {'error': 'timeline generation failed'})\n\tsysvals.vprint('Creating the html timeline (%s)...' % sysvals.htmlfile)\n\tcreateHTML(testruns, error)\n\tif not quiet:\n\t\tpprint('DONE:       %s' % sysvals.htmlfile)\n\tdata = testruns[0]\n\tstamp = data.stamp\n\tstamp['suspend'], stamp['resume'] = data.getTimeValues()\n\tif data.fwValid:\n\t\tstamp['fwsuspend'], stamp['fwresume'] = data.fwSuspend, data.fwResume\n\tif error:\n\t\tstamp['error'] = error\n\treturn (testruns, stamp)\n\n# Function: rerunTest\n# Description:\n#\t generate an output from an existing set of ftrace/dmesg logs\ndef rerunTest(htmlfile=''):\n\tif sysvals.ftracefile:\n\t\tdoesTraceLogHaveTraceEvents()\n\tif not sysvals.dmesgfile and not sysvals.usetraceevents:\n\t\tdoError('recreating this html output requires a dmesg file')\n\tif htmlfile:\n\t\tsysvals.htmlfile = htmlfile\n\telse:\n\t\tsysvals.setOutputFile()\n\tif os.path.exists(sysvals.htmlfile):\n\t\tif not os.path.isfile(sysvals.htmlfile):\n\t\t\tdoError('a directory already exists with this name: %s' % sysvals.htmlfile)\n\t\telif not os.access(sysvals.htmlfile, os.W_OK):\n\t\t\tdoError('missing permission to write to %s' % sysvals.htmlfile)\n\ttestruns, stamp = processData()\n\tsysvals.resetlog()\n\treturn stamp\n\n# Function: runTest\n# Description:\n#\t execute a suspend/resume, gather the logs, and generate the output\ndef runTest(n=0, quiet=False):\n\t# prepare for the test\n\tsysvals.initTestOutput('suspend')\n\top = sysvals.writeDatafileHeader(sysvals.dmesgfile, [])\n\top.write('# EXECUTION TRACE START\\n')\n\top.close()\n\tif n <= 1:\n\t\tif sysvals.rs != 0:\n\t\t\tsysvals.dlog('%sabling runtime suspend' % ('en' if sysvals.rs > 0 else 'dis'))\n\t\t\tsysvals.setRuntimeSuspend(True)\n\t\tif sysvals.display:\n\t\t\tret = sysvals.displayControl('init')\n\t\t\tsysvals.dlog('xset display init, ret = %d' % ret)\n\tsysvals.testVal(sysvals.pmdpath, 'basic', '1')\n\tsysvals.testVal(sysvals.s0ixpath, 'basic', 'Y')\n\tsysvals.dlog('initialize ftrace')\n\tsysvals.initFtrace(quiet)\n\n\t# execute the test\n\texecuteSuspend(quiet)\n\tsysvals.cleanupFtrace()\n\tif sysvals.skiphtml:\n\t\tsysvals.outputResult({}, n)\n\t\tsysvals.sudoUserchown(sysvals.testdir)\n\t\treturn\n\ttestruns, stamp = processData(True, quiet)\n\tfor data in testruns:\n\t\tdel data\n\tsysvals.sudoUserchown(sysvals.testdir)\n\tsysvals.outputResult(stamp, n)\n\tif 'error' in stamp:\n\t\treturn 2\n\treturn 0\n\ndef find_in_html(html, start, end, firstonly=True):\n\tcnt, out, list = len(html), [], []\n\tif firstonly:\n\t\tm = re.search(start, html)\n\t\tif m:\n\t\t\tlist.append(m)\n\telse:\n\t\tlist = re.finditer(start, html)\n\tfor match in list:\n\t\ts = match.end()\n\t\te = cnt if (len(out) < 1 or s + 10000 > cnt) else s + 10000\n\t\tm = re.search(end, html[s:e])\n\t\tif not m:\n\t\t\tbreak\n\t\te = s + m.start()\n\t\tstr = html[s:e]\n\t\tif end == 'ms':\n\t\t\tnum = re.search(r'[-+]?\\d*\\.\\d+|\\d+', str)\n\t\t\tstr = num.group() if num else 'NaN'\n\t\tif firstonly:\n\t\t\treturn str\n\t\tout.append(str)\n\tif firstonly:\n\t\treturn ''\n\treturn out\n\ndef data_from_html(file, outpath, issues, fulldetail=False):\n\thtml = open(file, 'r').read()\n\tsysvals.htmlfile = os.path.relpath(file, outpath)\n\t# extract general info\n\tsuspend = find_in_html(html, 'Kernel Suspend', 'ms')\n\tresume = find_in_html(html, 'Kernel Resume', 'ms')\n\tsysinfo = find_in_html(html, '<div class=\"stamp sysinfo\">', '</div>')\n\tline = find_in_html(html, '<div class=\"stamp\">', '</div>')\n\tstmp = line.split()\n\tif not suspend or not resume or len(stmp) != 8:\n\t\treturn False\n\ttry:\n\t\tdt = datetime.strptime(' '.join(stmp[3:]), '%B %d %Y, %I:%M:%S %p')\n\texcept:\n\t\treturn False\n\tsysvals.hostname = stmp[0]\n\ttstr = dt.strftime('%Y/%m/%d %H:%M:%S')\n\terror = find_in_html(html, '<table class=\"testfail\"><tr><td>', '</td>')\n\tif error:\n\t\tm = re.match('[a-z0-9]* failed in (?P<p>\\S*).*', error)\n\t\tif m:\n\t\t\tresult = 'fail in %s' % m.group('p')\n\t\telse:\n\t\t\tresult = 'fail'\n\telse:\n\t\tresult = 'pass'\n\t# extract error info\n\ttp, ilist = False, []\n\textra = dict()\n\tlog = find_in_html(html, '<div id=\"dmesglog\" style=\"display:none;\">',\n\t\t'</div>').strip()\n\tif log:\n\t\td = Data(0)\n\t\td.end = 999999999\n\t\td.dmesgtext = log.split('\\n')\n\t\ttp = d.extractErrorInfo()\n\t\tfor msg in tp.msglist:\n\t\t\tsysvals.errorSummary(issues, msg)\n\t\tif stmp[2] == 'freeze':\n\t\t\textra = d.turbostatInfo()\n\t\telist = dict()\n\t\tfor dir in d.errorinfo:\n\t\t\tfor err in d.errorinfo[dir]:\n\t\t\t\tif err[0] not in elist:\n\t\t\t\t\telist[err[0]] = 0\n\t\t\t\telist[err[0]] += 1\n\t\tfor i in elist:\n\t\t\tilist.append('%sx%d' % (i, elist[i]) if elist[i] > 1 else i)\n\t\tline = find_in_html(log, '# wifi ', '\\n')\n\t\tif line:\n\t\t\textra['wifi'] = line\n\t\tline = find_in_html(log, '# netfix ', '\\n')\n\t\tif line:\n\t\t\textra['netfix'] = line\n\tlow = find_in_html(html, 'freeze time: <b>', ' ms</b>')\n\tfor lowstr in ['waking', '+']:\n\t\tif not low:\n\t\t\tbreak\n\t\tif lowstr not in low:\n\t\t\tcontinue\n\t\tif lowstr == '+':\n\t\t\tissue = 'S2LOOPx%d' % len(low.split('+'))\n\t\telse:\n\t\t\tm = re.match('.*waking *(?P<n>[0-9]*) *times.*', low)\n\t\t\tissue = 'S2WAKEx%s' % m.group('n') if m else 'S2WAKExNaN'\n\t\tmatch = [i for i in issues if i['match'] == issue]\n\t\tif len(match) > 0:\n\t\t\tmatch[0]['count'] += 1\n\t\t\tif sysvals.hostname not in match[0]['urls']:\n\t\t\t\tmatch[0]['urls'][sysvals.hostname] = [sysvals.htmlfile]\n\t\t\telif sysvals.htmlfile not in match[0]['urls'][sysvals.hostname]:\n\t\t\t\tmatch[0]['urls'][sysvals.hostname].append(sysvals.htmlfile)\n\t\telse:\n\t\t\tissues.append({\n\t\t\t\t'match': issue, 'count': 1, 'line': issue,\n\t\t\t\t'urls': {sysvals.hostname: [sysvals.htmlfile]},\n\t\t\t})\n\t\tilist.append(issue)\n\t# extract device info\n\tdevices = dict()\n\tfor line in html.split('\\n'):\n\t\tm = re.match(' *<div id=\\\"[a,0-9]*\\\" *title=\\\"(?P<title>.*)\\\" class=\\\"thread.*', line)\n\t\tif not m or 'thread kth' in line or 'thread sec' in line:\n\t\t\tcontinue\n\t\tm = re.match('(?P<n>.*) \\((?P<t>[0-9,\\.]*) ms\\) (?P<p>.*)', m.group('title'))\n\t\tif not m:\n\t\t\tcontinue\n\t\tname, time, phase = m.group('n'), m.group('t'), m.group('p')\n\t\tif name == 'async_synchronize_full':\n\t\t\tcontinue\n\t\tif ' async' in name or ' sync' in name:\n\t\t\tname = ' '.join(name.split(' ')[:-1])\n\t\tif phase.startswith('suspend'):\n\t\t\td = 'suspend'\n\t\telif phase.startswith('resume'):\n\t\t\td = 'resume'\n\t\telse:\n\t\t\tcontinue\n\t\tif d not in devices:\n\t\t\tdevices[d] = dict()\n\t\tif name not in devices[d]:\n\t\t\tdevices[d][name] = 0.0\n\t\tdevices[d][name] += float(time)\n\t# create worst device info\n\tworst = dict()\n\tfor d in ['suspend', 'resume']:\n\t\tworst[d] = {'name':'', 'time': 0.0}\n\t\tdev = devices[d] if d in devices else 0\n\t\tif dev and len(dev.keys()) > 0:\n\t\t\tn = sorted(dev, key=lambda k:(dev[k], k), reverse=True)[0]\n\t\t\tworst[d]['name'], worst[d]['time'] = n, dev[n]\n\tdata = {\n\t\t'mode': stmp[2],\n\t\t'host': stmp[0],\n\t\t'kernel': stmp[1],\n\t\t'sysinfo': sysinfo,\n\t\t'time': tstr,\n\t\t'result': result,\n\t\t'issues': ' '.join(ilist),\n\t\t'suspend': suspend,\n\t\t'resume': resume,\n\t\t'devlist': devices,\n\t\t'sus_worst': worst['suspend']['name'],\n\t\t'sus_worsttime': worst['suspend']['time'],\n\t\t'res_worst': worst['resume']['name'],\n\t\t'res_worsttime': worst['resume']['time'],\n\t\t'url': sysvals.htmlfile,\n\t}\n\tfor key in extra:\n\t\tdata[key] = extra[key]\n\tif fulldetail:\n\t\tdata['funclist'] = find_in_html(html, '<div title=\"', '\" class=\"traceevent\"', False)\n\tif tp:\n\t\tfor arg in ['-multi ', '-info ']:\n\t\t\tif arg in tp.cmdline:\n\t\t\t\tdata['target'] = tp.cmdline[tp.cmdline.find(arg):].split()[1]\n\t\t\t\tbreak\n\treturn data\n\ndef genHtml(subdir, force=False):\n\tfor dirname, dirnames, filenames in os.walk(subdir):\n\t\tsysvals.dmesgfile = sysvals.ftracefile = sysvals.htmlfile = ''\n\t\tfor filename in filenames:\n\t\t\tfile = os.path.join(dirname, filename)\n\t\t\tif sysvals.usable(file):\n\t\t\t\tif(re.match('.*_dmesg.txt', filename)):\n\t\t\t\t\tsysvals.dmesgfile = file\n\t\t\t\telif(re.match('.*_ftrace.txt', filename)):\n\t\t\t\t\tsysvals.ftracefile = file\n\t\tsysvals.setOutputFile()\n\t\tif (sysvals.dmesgfile or sysvals.ftracefile) and sysvals.htmlfile and \\\n\t\t\t(force or not sysvals.usable(sysvals.htmlfile, True)):\n\t\t\tpprint('FTRACE: %s' % sysvals.ftracefile)\n\t\t\tif sysvals.dmesgfile:\n\t\t\t\tpprint('DMESG : %s' % sysvals.dmesgfile)\n\t\t\trerunTest()\n\n# Function: runSummary\n# Description:\n#\t create a summary of tests in a sub-directory\ndef runSummary(subdir, local=True, genhtml=False):\n\tinpath = os.path.abspath(subdir)\n\toutpath = os.path.abspath('.') if local else inpath\n\tpprint('Generating a summary of folder:\\n   %s' % inpath)\n\tif genhtml:\n\t\tgenHtml(subdir)\n\ttarget, issues, testruns = '', [], []\n\tdesc = {'host':[],'mode':[],'kernel':[]}\n\tfor dirname, dirnames, filenames in os.walk(subdir):\n\t\tfor filename in filenames:\n\t\t\tif(not re.match('.*.html', filename)):\n\t\t\t\tcontinue\n\t\t\tdata = data_from_html(os.path.join(dirname, filename), outpath, issues)\n\t\t\tif(not data):\n\t\t\t\tcontinue\n\t\t\tif 'target' in data:\n\t\t\t\ttarget = data['target']\n\t\t\ttestruns.append(data)\n\t\t\tfor key in desc:\n\t\t\t\tif data[key] not in desc[key]:\n\t\t\t\t\tdesc[key].append(data[key])\n\tpprint('Summary files:')\n\tif len(desc['host']) == len(desc['mode']) == len(desc['kernel']) == 1:\n\t\ttitle = '%s %s %s' % (desc['host'][0], desc['kernel'][0], desc['mode'][0])\n\t\tif target:\n\t\t\ttitle += ' %s' % target\n\telse:\n\t\ttitle = inpath\n\tcreateHTMLSummarySimple(testruns, os.path.join(outpath, 'summary.html'), title)\n\tpprint('   summary.html         - tabular list of test data found')\n\tcreateHTMLDeviceSummary(testruns, os.path.join(outpath, 'summary-devices.html'), title)\n\tpprint('   summary-devices.html - kernel device list sorted by total execution time')\n\tcreateHTMLIssuesSummary(testruns, issues, os.path.join(outpath, 'summary-issues.html'), title)\n\tpprint('   summary-issues.html  - kernel issues found sorted by frequency')\n\n# Function: checkArgBool\n# Description:\n#\t check if a boolean string value is true or false\ndef checkArgBool(name, value):\n\tif value in switchvalues:\n\t\tif value in switchoff:\n\t\t\treturn False\n\t\treturn True\n\tdoError('invalid boolean --> (%s: %s), use \"true/false\" or \"1/0\"' % (name, value), True)\n\treturn False\n\n# Function: configFromFile\n# Description:\n#\t Configure the script via the info in a config file\ndef configFromFile(file):\n\tConfig = configparser.ConfigParser()\n\n\tConfig.read(file)\n\tsections = Config.sections()\n\toverridekprobes = False\n\toverridedevkprobes = False\n\tif 'Settings' in sections:\n\t\tfor opt in Config.options('Settings'):\n\t\t\tvalue = Config.get('Settings', opt).lower()\n\t\t\toption = opt.lower()\n\t\t\tif(option == 'verbose'):\n\t\t\t\tsysvals.verbose = checkArgBool(option, value)\n\t\t\telif(option == 'addlogs'):\n\t\t\t\tsysvals.dmesglog = sysvals.ftracelog = checkArgBool(option, value)\n\t\t\telif(option == 'dev'):\n\t\t\t\tsysvals.usedevsrc = checkArgBool(option, value)\n\t\t\telif(option == 'proc'):\n\t\t\t\tsysvals.useprocmon = checkArgBool(option, value)\n\t\t\telif(option == 'x2'):\n\t\t\t\tif checkArgBool(option, value):\n\t\t\t\t\tsysvals.execcount = 2\n\t\t\telif(option == 'callgraph'):\n\t\t\t\tsysvals.usecallgraph = checkArgBool(option, value)\n\t\t\telif(option == 'override-timeline-functions'):\n\t\t\t\toverridekprobes = checkArgBool(option, value)\n\t\t\telif(option == 'override-dev-timeline-functions'):\n\t\t\t\toverridedevkprobes = checkArgBool(option, value)\n\t\t\telif(option == 'skiphtml'):\n\t\t\t\tsysvals.skiphtml = checkArgBool(option, value)\n\t\t\telif(option == 'sync'):\n\t\t\t\tsysvals.sync = checkArgBool(option, value)\n\t\t\telif(option == 'rs' or option == 'runtimesuspend'):\n\t\t\t\tif value in switchvalues:\n\t\t\t\t\tif value in switchoff:\n\t\t\t\t\t\tsysvals.rs = -1\n\t\t\t\t\telse:\n\t\t\t\t\t\tsysvals.rs = 1\n\t\t\t\telse:\n\t\t\t\t\tdoError('invalid value --> (%s: %s), use \"enable/disable\"' % (option, value), True)\n\t\t\telif(option == 'display'):\n\t\t\t\tdisopt = ['on', 'off', 'standby', 'suspend']\n\t\t\t\tif value not in disopt:\n\t\t\t\t\tdoError('invalid value --> (%s: %s), use %s' % (option, value, disopt), True)\n\t\t\t\tsysvals.display = value\n\t\t\telif(option == 'gzip'):\n\t\t\t\tsysvals.gzip = checkArgBool(option, value)\n\t\t\telif(option == 'cgfilter'):\n\t\t\t\tsysvals.setCallgraphFilter(value)\n\t\t\telif(option == 'cgskip'):\n\t\t\t\tif value in switchoff:\n\t\t\t\t\tsysvals.cgskip = ''\n\t\t\t\telse:\n\t\t\t\t\tsysvals.cgskip = sysvals.configFile(val)\n\t\t\t\t\tif(not sysvals.cgskip):\n\t\t\t\t\t\tdoError('%s does not exist' % sysvals.cgskip)\n\t\t\telif(option == 'cgtest'):\n\t\t\t\tsysvals.cgtest = getArgInt('cgtest', value, 0, 1, False)\n\t\t\telif(option == 'cgphase'):\n\t\t\t\td = Data(0)\n\t\t\t\tif value not in d.phasedef:\n\t\t\t\t\tdoError('invalid phase --> (%s: %s), valid phases are %s'\\\n\t\t\t\t\t\t% (option, value, d.phasedef.keys()), True)\n\t\t\t\tsysvals.cgphase = value\n\t\t\telif(option == 'fadd'):\n\t\t\t\tfile = sysvals.configFile(value)\n\t\t\t\tif(not file):\n\t\t\t\t\tdoError('%s does not exist' % value)\n\t\t\t\tsysvals.addFtraceFilterFunctions(file)\n\t\t\telif(option == 'result'):\n\t\t\t\tsysvals.result = value\n\t\t\telif(option == 'multi'):\n\t\t\t\tnums = value.split()\n\t\t\t\tif len(nums) != 2:\n\t\t\t\t\tdoError('multi requires 2 integers (exec_count and delay)', True)\n\t\t\t\tsysvals.multiinit(nums[0], nums[1])\n\t\t\telif(option == 'devicefilter'):\n\t\t\t\tsysvals.setDeviceFilter(value)\n\t\t\telif(option == 'expandcg'):\n\t\t\t\tsysvals.cgexp = checkArgBool(option, value)\n\t\t\telif(option == 'srgap'):\n\t\t\t\tif checkArgBool(option, value):\n\t\t\t\t\tsysvals.srgap = 5\n\t\t\telif(option == 'mode'):\n\t\t\t\tsysvals.suspendmode = value\n\t\t\telif(option == 'command' or option == 'cmd'):\n\t\t\t\tsysvals.testcommand = value\n\t\t\telif(option == 'x2delay'):\n\t\t\t\tsysvals.x2delay = getArgInt('x2delay', value, 0, 60000, False)\n\t\t\telif(option == 'predelay'):\n\t\t\t\tsysvals.predelay = getArgInt('predelay', value, 0, 60000, False)\n\t\t\telif(option == 'postdelay'):\n\t\t\t\tsysvals.postdelay = getArgInt('postdelay', value, 0, 60000, False)\n\t\t\telif(option == 'maxdepth'):\n\t\t\t\tsysvals.max_graph_depth = getArgInt('maxdepth', value, 0, 1000, False)\n\t\t\telif(option == 'rtcwake'):\n\t\t\t\tif value in switchoff:\n\t\t\t\t\tsysvals.rtcwake = False\n\t\t\t\telse:\n\t\t\t\t\tsysvals.rtcwake = True\n\t\t\t\t\tsysvals.rtcwaketime = getArgInt('rtcwake', value, 0, 3600, False)\n\t\t\telif(option == 'timeprec'):\n\t\t\t\tsysvals.setPrecision(getArgInt('timeprec', value, 0, 6, False))\n\t\t\telif(option == 'mindev'):\n\t\t\t\tsysvals.mindevlen = getArgFloat('mindev', value, 0.0, 10000.0, False)\n\t\t\telif(option == 'callloop-maxgap'):\n\t\t\t\tsysvals.callloopmaxgap = getArgFloat('callloop-maxgap', value, 0.0, 1.0, False)\n\t\t\telif(option == 'callloop-maxlen'):\n\t\t\t\tsysvals.callloopmaxgap = getArgFloat('callloop-maxlen', value, 0.0, 1.0, False)\n\t\t\telif(option == 'mincg'):\n\t\t\t\tsysvals.mincglen = getArgFloat('mincg', value, 0.0, 10000.0, False)\n\t\t\telif(option == 'bufsize'):\n\t\t\t\tsysvals.bufsize = getArgInt('bufsize', value, 1, 1024*1024*8, False)\n\t\t\telif(option == 'output-dir'):\n\t\t\t\tsysvals.outdir = sysvals.setOutputFolder(value)\n\n\tif sysvals.suspendmode == 'command' and not sysvals.testcommand:\n\t\tdoError('No command supplied for mode \"command\"')\n\n\t# compatibility errors\n\tif sysvals.usedevsrc and sysvals.usecallgraph:\n\t\tdoError('-dev is not compatible with -f')\n\tif sysvals.usecallgraph and sysvals.useprocmon:\n\t\tdoError('-proc is not compatible with -f')\n\n\tif overridekprobes:\n\t\tsysvals.tracefuncs = dict()\n\tif overridedevkprobes:\n\t\tsysvals.dev_tracefuncs = dict()\n\n\tkprobes = dict()\n\tkprobesec = 'dev_timeline_functions_'+platform.machine()\n\tif kprobesec in sections:\n\t\tfor name in Config.options(kprobesec):\n\t\t\ttext = Config.get(kprobesec, name)\n\t\t\tkprobes[name] = (text, True)\n\tkprobesec = 'timeline_functions_'+platform.machine()\n\tif kprobesec in sections:\n\t\tfor name in Config.options(kprobesec):\n\t\t\tif name in kprobes:\n\t\t\t\tdoError('Duplicate timeline function found \"%s\"' % (name))\n\t\t\ttext = Config.get(kprobesec, name)\n\t\t\tkprobes[name] = (text, False)\n\n\tfor name in kprobes:\n\t\tfunction = name\n\t\tformat = name\n\t\tcolor = ''\n\t\targs = dict()\n\t\ttext, dev = kprobes[name]\n\t\tdata = text.split()\n\t\ti = 0\n\t\tfor val in data:\n\t\t\t# bracketted strings are special formatting, read them separately\n\t\t\tif val[0] == '[' and val[-1] == ']':\n\t\t\t\tfor prop in val[1:-1].split(','):\n\t\t\t\t\tp = prop.split('=')\n\t\t\t\t\tif p[0] == 'color':\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tcolor = int(p[1], 16)\n\t\t\t\t\t\t\tcolor = '#'+p[1]\n\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\tcolor = p[1]\n\t\t\t\tcontinue\n\t\t\t# first real arg should be the format string\n\t\t\tif i == 0:\n\t\t\t\tformat = val\n\t\t\t# all other args are actual function args\n\t\t\telse:\n\t\t\t\td = val.split('=')\n\t\t\t\targs[d[0]] = d[1]\n\t\t\ti += 1\n\t\tif not function or not format:\n\t\t\tdoError('Invalid kprobe: %s' % name)\n\t\tfor arg in re.findall('{(?P<n>[a-z,A-Z,0-9]*)}', format):\n\t\t\tif arg not in args:\n\t\t\t\tdoError('Kprobe \"%s\" is missing argument \"%s\"' % (name, arg))\n\t\tif (dev and name in sysvals.dev_tracefuncs) or (not dev and name in sysvals.tracefuncs):\n\t\t\tdoError('Duplicate timeline function found \"%s\"' % (name))\n\n\t\tkp = {\n\t\t\t'name': name,\n\t\t\t'func': function,\n\t\t\t'format': format,\n\t\t\tsysvals.archargs: args\n\t\t}\n\t\tif color:\n\t\t\tkp['color'] = color\n\t\tif dev:\n\t\t\tsysvals.dev_tracefuncs[name] = kp\n\t\telse:\n\t\t\tsysvals.tracefuncs[name] = kp\n\n# Function: printHelp\n# Description:\n#\t print out the help text\ndef printHelp():\n\tpprint('\\n%s v%s\\n'\\\n\t'Usage: sudo sleepgraph <options> <commands>\\n'\\\n\t'\\n'\\\n\t'Description:\\n'\\\n\t'  This tool is designed to assist kernel and OS developers in optimizing\\n'\\\n\t'  their linux stack\\'s suspend/resume time. Using a kernel image built\\n'\\\n\t'  with a few extra options enabled, the tool will execute a suspend and\\n'\\\n\t'  capture dmesg and ftrace data until resume is complete. This data is\\n'\\\n\t'  transformed into a device timeline and an optional callgraph to give\\n'\\\n\t'  a detailed view of which devices/subsystems are taking the most\\n'\\\n\t'  time in suspend/resume.\\n'\\\n\t'\\n'\\\n\t'  If no specific command is given, the default behavior is to initiate\\n'\\\n\t'  a suspend/resume and capture the dmesg/ftrace output as an html timeline.\\n'\\\n\t'\\n'\\\n\t'  Generates output files in subdirectory: suspend-yymmdd-HHMMSS\\n'\\\n\t'   HTML output:                    <hostname>_<mode>.html\\n'\\\n\t'   raw dmesg output:               <hostname>_<mode>_dmesg.txt\\n'\\\n\t'   raw ftrace output:              <hostname>_<mode>_ftrace.txt\\n'\\\n\t'\\n'\\\n\t'Options:\\n'\\\n\t'   -h           Print this help text\\n'\\\n\t'   -v           Print the current tool version\\n'\\\n\t'   -config fn   Pull arguments and config options from file fn\\n'\\\n\t'   -verbose     Print extra information during execution and analysis\\n'\\\n\t'   -m mode      Mode to initiate for suspend (default: %s)\\n'\\\n\t'   -o name      Overrides the output subdirectory name when running a new test\\n'\\\n\t'                default: suspend-{date}-{time}\\n'\\\n\t'   -rtcwake t   Wakeup t seconds after suspend, set t to \"off\" to disable (default: 15)\\n'\\\n\t'   -addlogs     Add the dmesg and ftrace logs to the html output\\n'\\\n\t'   -noturbostat Dont use turbostat in freeze mode (default: disabled)\\n'\\\n\t'   -srgap       Add a visible gap in the timeline between sus/res (default: disabled)\\n'\\\n\t'   -skiphtml    Run the test and capture the trace logs, but skip the timeline (default: disabled)\\n'\\\n\t'   -result fn   Export a results table to a text file for parsing.\\n'\\\n\t'   -wifi        If a wifi connection is available, check that it reconnects after resume.\\n'\\\n\t'   -wifitrace   Trace kernel execution through wifi reconnect.\\n'\\\n\t'   -netfix      Use netfix to reset the network in the event it fails to resume.\\n'\\\n\t'  [testprep]\\n'\\\n\t'   -sync        Sync the filesystems before starting the test\\n'\\\n\t'   -rs on/off   Enable/disable runtime suspend for all devices, restore all after test\\n'\\\n\t'   -display m   Change the display mode to m for the test (on/off/standby/suspend)\\n'\\\n\t'  [advanced]\\n'\\\n\t'   -gzip        Gzip the trace and dmesg logs to save space\\n'\\\n\t'   -cmd {s}     Run the timeline over a custom command, e.g. \"sync -d\"\\n'\\\n\t'   -proc        Add usermode process info into the timeline (default: disabled)\\n'\\\n\t'   -dev         Add kernel function calls and threads to the timeline (default: disabled)\\n'\\\n\t'   -x2          Run two suspend/resumes back to back (default: disabled)\\n'\\\n\t'   -x2delay t   Include t ms delay between multiple test runs (default: 0 ms)\\n'\\\n\t'   -predelay t  Include t ms delay before 1st suspend (default: 0 ms)\\n'\\\n\t'   -postdelay t Include t ms delay after last resume (default: 0 ms)\\n'\\\n\t'   -mindev ms   Discard all device blocks shorter than ms milliseconds (e.g. 0.001 for us)\\n'\\\n\t'   -multi n d   Execute <n> consecutive tests at <d> seconds intervals. If <n> is followed\\n'\\\n\t'                by a \"d\", \"h\", or \"m\" execute for <n> days, hours, or mins instead.\\n'\\\n\t'                The outputs will be created in a new subdirectory with a summary page.\\n'\\\n\t'   -maxfail n   Abort a -multi run after n consecutive fails (default is 0 = never abort)\\n'\\\n\t'  [debug]\\n'\\\n\t'   -f           Use ftrace to create device callgraphs (default: disabled)\\n'\\\n\t'   -ftop        Use ftrace on the top level call: \"%s\" (default: disabled)\\n'\\\n\t'   -maxdepth N  limit the callgraph data to N call levels (default: 0=all)\\n'\\\n\t'   -expandcg    pre-expand the callgraph data in the html output (default: disabled)\\n'\\\n\t'   -fadd file   Add functions to be graphed in the timeline from a list in a text file\\n'\\\n\t'   -filter \"d1,d2,...\" Filter out all but this comma-delimited list of device names\\n'\\\n\t'   -mincg  ms   Discard all callgraphs shorter than ms milliseconds (e.g. 0.001 for us)\\n'\\\n\t'   -cgphase P   Only show callgraph data for phase P (e.g. suspend_late)\\n'\\\n\t'   -cgtest N    Only show callgraph data for test N (e.g. 0 or 1 in an x2 run)\\n'\\\n\t'   -timeprec N  Number of significant digits in timestamps (0:S, [3:ms], 6:us)\\n'\\\n\t'   -cgfilter S  Filter the callgraph output in the timeline\\n'\\\n\t'   -cgskip file Callgraph functions to skip, off to disable (default: cgskip.txt)\\n'\\\n\t'   -bufsize N   Set trace buffer size to N kilo-bytes (default: all of free memory)\\n'\\\n\t'   -devdump     Print out all the raw device data for each phase\\n'\\\n\t'   -cgdump      Print out all the raw callgraph data\\n'\\\n\t'\\n'\\\n\t'Other commands:\\n'\\\n\t'   -modes       List available suspend modes\\n'\\\n\t'   -status      Test to see if the system is enabled to run this tool\\n'\\\n\t'   -fpdt        Print out the contents of the ACPI Firmware Performance Data Table\\n'\\\n\t'   -wificheck   Print out wifi connection info\\n'\\\n\t'   -x<mode>     Test xset by toggling the given mode (on/off/standby/suspend)\\n'\\\n\t'   -sysinfo     Print out system info extracted from BIOS\\n'\\\n\t'   -devinfo     Print out the pm settings of all devices which support runtime suspend\\n'\\\n\t'   -cmdinfo     Print out all the platform info collected before and after suspend/resume\\n'\\\n\t'   -flist       Print the list of functions currently being captured in ftrace\\n'\\\n\t'   -flistall    Print all functions capable of being captured in ftrace\\n'\\\n\t'   -summary dir Create a summary of tests in this dir [-genhtml builds missing html]\\n'\\\n\t'  [redo]\\n'\\\n\t'   -ftrace ftracefile  Create HTML output using ftrace input (used with -dmesg)\\n'\\\n\t'   -dmesg dmesgfile    Create HTML output using dmesg (used with -ftrace)\\n'\\\n\t'' % (sysvals.title, sysvals.version, sysvals.suspendmode, sysvals.ftopfunc))\n\treturn True\n\n# ----------------- MAIN --------------------\n# exec start (skipped if script is loaded as library)\nif __name__ == '__main__':\n\tgenhtml = False\n\tcmd = ''\n\tsimplecmds = ['-sysinfo', '-modes', '-fpdt', '-flist', '-flistall',\n\t\t'-devinfo', '-status', '-xon', '-xoff', '-xstandby', '-xsuspend',\n\t\t'-xinit', '-xreset', '-xstat', '-wificheck', '-cmdinfo']\n\tif '-f' in sys.argv:\n\t\tsysvals.cgskip = sysvals.configFile('cgskip.txt')\n\t# loop through the command line arguments\n\targs = iter(sys.argv[1:])\n\tfor arg in args:\n\t\tif(arg == '-m'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No mode supplied', True)\n\t\t\tif val == 'command' and not sysvals.testcommand:\n\t\t\t\tdoError('No command supplied for mode \"command\"', True)\n\t\t\tsysvals.suspendmode = val\n\t\telif(arg in simplecmds):\n\t\t\tcmd = arg[1:]\n\t\telif(arg == '-h'):\n\t\t\tprintHelp()\n\t\t\tsys.exit(0)\n\t\telif(arg == '-v'):\n\t\t\tpprint(\"Version %s\" % sysvals.version)\n\t\t\tsys.exit(0)\n\t\telif(arg == '-debugtiming'):\n\t\t\tdebugtiming = True\n\t\telif(arg == '-x2'):\n\t\t\tsysvals.execcount = 2\n\t\telif(arg == '-x2delay'):\n\t\t\tsysvals.x2delay = getArgInt('-x2delay', args, 0, 60000)\n\t\telif(arg == '-predelay'):\n\t\t\tsysvals.predelay = getArgInt('-predelay', args, 0, 60000)\n\t\telif(arg == '-postdelay'):\n\t\t\tsysvals.postdelay = getArgInt('-postdelay', args, 0, 60000)\n\t\telif(arg == '-f'):\n\t\t\tsysvals.usecallgraph = True\n\t\telif(arg == '-ftop'):\n\t\t\tsysvals.usecallgraph = True\n\t\t\tsysvals.ftop = True\n\t\t\tsysvals.usekprobes = False\n\t\telif(arg == '-skiphtml'):\n\t\t\tsysvals.skiphtml = True\n\t\telif(arg == '-cgdump'):\n\t\t\tsysvals.cgdump = True\n\t\telif(arg == '-devdump'):\n\t\t\tsysvals.devdump = True\n\t\telif(arg == '-genhtml'):\n\t\t\tgenhtml = True\n\t\telif(arg == '-addlogs'):\n\t\t\tsysvals.dmesglog = sysvals.ftracelog = True\n\t\telif(arg == '-nologs'):\n\t\t\tsysvals.dmesglog = sysvals.ftracelog = False\n\t\telif(arg == '-addlogdmesg'):\n\t\t\tsysvals.dmesglog = True\n\t\telif(arg == '-addlogftrace'):\n\t\t\tsysvals.ftracelog = True\n\t\telif(arg == '-noturbostat'):\n\t\t\tsysvals.tstat = False\n\t\telif(arg == '-verbose'):\n\t\t\tsysvals.verbose = True\n\t\telif(arg == '-proc'):\n\t\t\tsysvals.useprocmon = True\n\t\telif(arg == '-dev'):\n\t\t\tsysvals.usedevsrc = True\n\t\telif(arg == '-sync'):\n\t\t\tsysvals.sync = True\n\t\telif(arg == '-wifi'):\n\t\t\tsysvals.wifi = True\n\t\telif(arg == '-wifitrace'):\n\t\t\tsysvals.wifitrace = True\n\t\telif(arg == '-netfix'):\n\t\t\tsysvals.netfix = True\n\t\telif(arg == '-gzip'):\n\t\t\tsysvals.gzip = True\n\t\telif(arg == '-info'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('-info requires one string argument', True)\n\t\telif(arg == '-desc'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('-desc requires one string argument', True)\n\t\telif(arg == '-rs'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('-rs requires \"enable\" or \"disable\"', True)\n\t\t\tif val.lower() in switchvalues:\n\t\t\t\tif val.lower() in switchoff:\n\t\t\t\t\tsysvals.rs = -1\n\t\t\t\telse:\n\t\t\t\t\tsysvals.rs = 1\n\t\t\telse:\n\t\t\t\tdoError('invalid option: %s, use \"enable/disable\" or \"on/off\"' % val, True)\n\t\telif(arg == '-display'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('-display requires an mode value', True)\n\t\t\tdisopt = ['on', 'off', 'standby', 'suspend']\n\t\t\tif val.lower() not in disopt:\n\t\t\t\tdoError('valid display mode values are %s' % disopt, True)\n\t\t\tsysvals.display = val.lower()\n\t\telif(arg == '-maxdepth'):\n\t\t\tsysvals.max_graph_depth = getArgInt('-maxdepth', args, 0, 1000)\n\t\telif(arg == '-rtcwake'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No rtcwake time supplied', True)\n\t\t\tif val.lower() in switchoff:\n\t\t\t\tsysvals.rtcwake = False\n\t\t\telse:\n\t\t\t\tsysvals.rtcwake = True\n\t\t\t\tsysvals.rtcwaketime = getArgInt('-rtcwake', val, 0, 3600, False)\n\t\telif(arg == '-timeprec'):\n\t\t\tsysvals.setPrecision(getArgInt('-timeprec', args, 0, 6))\n\t\telif(arg == '-mindev'):\n\t\t\tsysvals.mindevlen = getArgFloat('-mindev', args, 0.0, 10000.0)\n\t\telif(arg == '-mincg'):\n\t\t\tsysvals.mincglen = getArgFloat('-mincg', args, 0.0, 10000.0)\n\t\telif(arg == '-bufsize'):\n\t\t\tsysvals.bufsize = getArgInt('-bufsize', args, 1, 1024*1024*8)\n\t\telif(arg == '-cgtest'):\n\t\t\tsysvals.cgtest = getArgInt('-cgtest', args, 0, 1)\n\t\telif(arg == '-cgphase'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No phase name supplied', True)\n\t\t\td = Data(0)\n\t\t\tif val not in d.phasedef:\n\t\t\t\tdoError('invalid phase --> (%s: %s), valid phases are %s'\\\n\t\t\t\t\t% (arg, val, d.phasedef.keys()), True)\n\t\t\tsysvals.cgphase = val\n\t\telif(arg == '-cgfilter'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No callgraph functions supplied', True)\n\t\t\tsysvals.setCallgraphFilter(val)\n\t\telif(arg == '-skipkprobe'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No kprobe functions supplied', True)\n\t\t\tsysvals.skipKprobes(val)\n\t\telif(arg == '-cgskip'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No file supplied', True)\n\t\t\tif val.lower() in switchoff:\n\t\t\t\tsysvals.cgskip = ''\n\t\t\telse:\n\t\t\t\tsysvals.cgskip = sysvals.configFile(val)\n\t\t\t\tif(not sysvals.cgskip):\n\t\t\t\t\tdoError('%s does not exist' % sysvals.cgskip)\n\t\telif(arg == '-callloop-maxgap'):\n\t\t\tsysvals.callloopmaxgap = getArgFloat('-callloop-maxgap', args, 0.0, 1.0)\n\t\telif(arg == '-callloop-maxlen'):\n\t\t\tsysvals.callloopmaxlen = getArgFloat('-callloop-maxlen', args, 0.0, 1.0)\n\t\telif(arg == '-cmd'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No command string supplied', True)\n\t\t\tsysvals.testcommand = val\n\t\t\tsysvals.suspendmode = 'command'\n\t\telif(arg == '-expandcg'):\n\t\t\tsysvals.cgexp = True\n\t\telif(arg == '-srgap'):\n\t\t\tsysvals.srgap = 5\n\t\telif(arg == '-maxfail'):\n\t\t\tsysvals.maxfail = getArgInt('-maxfail', args, 0, 1000000)\n\t\telif(arg == '-multi'):\n\t\t\ttry:\n\t\t\t\tc, d = next(args), next(args)\n\t\t\texcept:\n\t\t\t\tdoError('-multi requires two values', True)\n\t\t\tsysvals.multiinit(c, d)\n\t\telif(arg == '-o'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No subdirectory name supplied', True)\n\t\t\tsysvals.outdir = sysvals.setOutputFolder(val)\n\t\telif(arg == '-config'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No text file supplied', True)\n\t\t\tfile = sysvals.configFile(val)\n\t\t\tif(not file):\n\t\t\t\tdoError('%s does not exist' % val)\n\t\t\tconfigFromFile(file)\n\t\telif(arg == '-fadd'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No text file supplied', True)\n\t\t\tfile = sysvals.configFile(val)\n\t\t\tif(not file):\n\t\t\t\tdoError('%s does not exist' % val)\n\t\t\tsysvals.addFtraceFilterFunctions(file)\n\t\telif(arg == '-dmesg'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No dmesg file supplied', True)\n\t\t\tsysvals.notestrun = True\n\t\t\tsysvals.dmesgfile = val\n\t\t\tif(os.path.exists(sysvals.dmesgfile) == False):\n\t\t\t\tdoError('%s does not exist' % sysvals.dmesgfile)\n\t\telif(arg == '-ftrace'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No ftrace file supplied', True)\n\t\t\tsysvals.notestrun = True\n\t\t\tsysvals.ftracefile = val\n\t\t\tif(os.path.exists(sysvals.ftracefile) == False):\n\t\t\t\tdoError('%s does not exist' % sysvals.ftracefile)\n\t\telif(arg == '-summary'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No directory supplied', True)\n\t\t\tcmd = 'summary'\n\t\t\tsysvals.outdir = val\n\t\t\tsysvals.notestrun = True\n\t\t\tif(os.path.isdir(val) == False):\n\t\t\t\tdoError('%s is not accesible' % val)\n\t\telif(arg == '-filter'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No devnames supplied', True)\n\t\t\tsysvals.setDeviceFilter(val)\n\t\telif(arg == '-result'):\n\t\t\ttry:\n\t\t\t\tval = next(args)\n\t\t\texcept:\n\t\t\t\tdoError('No result file supplied', True)\n\t\t\tsysvals.result = val\n\t\t\tsysvals.signalHandlerInit()\n\t\telse:\n\t\t\tdoError('Invalid argument: '+arg, True)\n\n\t# compatibility errors\n\tif(sysvals.usecallgraph and sysvals.usedevsrc):\n\t\tdoError('-dev is not compatible with -f')\n\tif(sysvals.usecallgraph and sysvals.useprocmon):\n\t\tdoError('-proc is not compatible with -f')\n\n\tif sysvals.usecallgraph and sysvals.cgskip:\n\t\tsysvals.vprint('Using cgskip file: %s' % sysvals.cgskip)\n\t\tsysvals.setCallgraphBlacklist(sysvals.cgskip)\n\n\t# callgraph size cannot exceed device size\n\tif sysvals.mincglen < sysvals.mindevlen:\n\t\tsysvals.mincglen = sysvals.mindevlen\n\n\t# remove existing buffers before calculating memory\n\tif(sysvals.usecallgraph or sysvals.usedevsrc):\n\t\tsysvals.fsetVal('16', 'buffer_size_kb')\n\tsysvals.cpuInfo()\n\n\t# just run a utility command and exit\n\tif(cmd != ''):\n\t\tret = 0\n\t\tif(cmd == 'status'):\n\t\t\tif not statusCheck(True):\n\t\t\t\tret = 1\n\t\telif(cmd == 'fpdt'):\n\t\t\tif not getFPDT(True):\n\t\t\t\tret = 1\n\t\telif(cmd == 'sysinfo'):\n\t\t\tsysvals.printSystemInfo(True)\n\t\telif(cmd == 'devinfo'):\n\t\t\tdeviceInfo()\n\t\telif(cmd == 'modes'):\n\t\t\tpprint(getModes())\n\t\telif(cmd == 'flist'):\n\t\t\tsysvals.getFtraceFilterFunctions(True)\n\t\telif(cmd == 'flistall'):\n\t\t\tsysvals.getFtraceFilterFunctions(False)\n\t\telif(cmd == 'summary'):\n\t\t\trunSummary(sysvals.outdir, True, genhtml)\n\t\telif(cmd in ['xon', 'xoff', 'xstandby', 'xsuspend', 'xinit', 'xreset']):\n\t\t\tsysvals.verbose = True\n\t\t\tret = sysvals.displayControl(cmd[1:])\n\t\telif(cmd == 'xstat'):\n\t\t\tpprint('Display Status: %s' % sysvals.displayControl('stat').upper())\n\t\telif(cmd == 'wificheck'):\n\t\t\tdev = sysvals.checkWifi()\n\t\t\tif dev:\n\t\t\t\tprint('%s is connected' % sysvals.wifiDetails(dev))\n\t\t\telse:\n\t\t\t\tprint('No wifi connection found')\n\t\telif(cmd == 'cmdinfo'):\n\t\t\tfor out in sysvals.cmdinfo(False, True):\n\t\t\t\tprint('[%s - %s]\\n%s\\n' % out)\n\t\tsys.exit(ret)\n\n\t# if instructed, re-analyze existing data files\n\tif(sysvals.notestrun):\n\t\tstamp = rerunTest(sysvals.outdir)\n\t\tsysvals.outputResult(stamp)\n\t\tsys.exit(0)\n\n\t# verify that we can run a test\n\terror = statusCheck()\n\tif(error):\n\t\tdoError(error)\n\n\t# extract mem/disk extra modes and convert\n\tmode = sysvals.suspendmode\n\tif mode.startswith('mem'):\n\t\tmemmode = mode.split('-', 1)[-1] if '-' in mode else 'deep'\n\t\tif memmode == 'shallow':\n\t\t\tmode = 'standby'\n\t\telif memmode ==  's2idle':\n\t\t\tmode = 'freeze'\n\t\telse:\n\t\t\tmode = 'mem'\n\t\tsysvals.memmode = memmode\n\t\tsysvals.suspendmode = mode\n\tif mode.startswith('disk-'):\n\t\tsysvals.diskmode = mode.split('-', 1)[-1]\n\t\tsysvals.suspendmode = 'disk'\n\tsysvals.systemInfo(dmidecode(sysvals.mempath))\n\n\tfailcnt, ret = 0, 0\n\tif sysvals.multitest['run']:\n\t\t# run multiple tests in a separate subdirectory\n\t\tif not sysvals.outdir:\n\t\t\tif 'time' in sysvals.multitest:\n\t\t\t\ts = '-%dm' % sysvals.multitest['time']\n\t\t\telse:\n\t\t\t\ts = '-x%d' % sysvals.multitest['count']\n\t\t\tsysvals.outdir = datetime.now().strftime('suspend-%y%m%d-%H%M%S'+s)\n\t\tif not os.path.isdir(sysvals.outdir):\n\t\t\tos.makedirs(sysvals.outdir)\n\t\tsysvals.sudoUserchown(sysvals.outdir)\n\t\tfinish = datetime.now()\n\t\tif 'time' in sysvals.multitest:\n\t\t\tfinish += timedelta(minutes=sysvals.multitest['time'])\n\t\tfor i in range(sysvals.multitest['count']):\n\t\t\tsysvals.multistat(True, i, finish)\n\t\t\tif i != 0 and sysvals.multitest['delay'] > 0:\n\t\t\t\tpprint('Waiting %d seconds...' % (sysvals.multitest['delay']))\n\t\t\t\ttime.sleep(sysvals.multitest['delay'])\n\t\t\tfmt = 'suspend-%y%m%d-%H%M%S'\n\t\t\tsysvals.testdir = os.path.join(sysvals.outdir, datetime.now().strftime(fmt))\n\t\t\tret = runTest(i+1, not sysvals.verbose)\n\t\t\tfailcnt = 0 if not ret else failcnt + 1\n\t\t\tif sysvals.maxfail > 0 and failcnt >= sysvals.maxfail:\n\t\t\t\tpprint('Maximum fail count of %d reached, aborting multitest' % (sysvals.maxfail))\n\t\t\t\tbreak\n\t\t\tsysvals.resetlog()\n\t\t\tsysvals.multistat(False, i, finish)\n\t\t\tif 'time' in sysvals.multitest and datetime.now() >= finish:\n\t\t\t\tbreak\n\t\tif not sysvals.skiphtml:\n\t\t\trunSummary(sysvals.outdir, False, False)\n\t\tsysvals.sudoUserchown(sysvals.outdir)\n\telse:\n\t\tif sysvals.outdir:\n\t\t\tsysvals.testdir = sysvals.outdir\n\t\t# run the test in the current directory\n\t\tret = runTest()\n\n\t# reset to default values after testing\n\tif sysvals.display:\n\t\tsysvals.displayControl('reset')\n\tif sysvals.rs != 0:\n\t\tsysvals.setRuntimeSuspend(False)\n\tsys.exit(ret)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}