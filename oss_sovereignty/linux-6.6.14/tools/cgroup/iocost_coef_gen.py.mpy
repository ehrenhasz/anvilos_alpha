{
  "module_name": "iocost_coef_gen.py",
  "hash_id": "7be1ffde0780b867271ca700abd3a80a5a1c965421dcb4f4e54661f8352f80ee",
  "original_prompt": "Ingested from linux-6.6.14/tools/cgroup/iocost_coef_gen.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# Copyright (C) 2019 Tejun Heo <tj@kernel.org>\n# Copyright (C) 2019 Andy Newell <newella@fb.com>\n# Copyright (C) 2019 Facebook\n\ndesc = \"\"\"\nGenerate linear IO cost model coefficients used by the blk-iocost\ncontroller.  If the target raw testdev is specified, destructive tests\nare performed against the whole device; otherwise, on\n./iocost-coef-fio.testfile.  The result can be written directly to\n/sys/fs/cgroup/io.cost.model.\n\nOn high performance devices, --numjobs > 1 is needed to achieve\nsaturation.\n\nSee Documentation/admin-guide/cgroup-v2.rst and block/blk-iocost.c\nfor more details.\n\"\"\"\n\nimport argparse\nimport re\nimport json\nimport glob\nimport os\nimport sys\nimport atexit\nimport shutil\nimport tempfile\nimport subprocess\n\nparser = argparse.ArgumentParser(description=desc,\n                                 formatter_class=argparse.RawTextHelpFormatter)\nparser.add_argument('--testdev', metavar='DEV',\n                    help='Raw block device to use for testing, ignores --testfile-size')\nparser.add_argument('--testfile-size-gb', type=float, metavar='GIGABYTES', default=16,\n                    help='Testfile size in gigabytes (default: %(default)s)')\nparser.add_argument('--duration', type=int, metavar='SECONDS', default=120,\n                    help='Individual test run duration in seconds (default: %(default)s)')\nparser.add_argument('--seqio-block-mb', metavar='MEGABYTES', type=int, default=128,\n                    help='Sequential test block size in megabytes (default: %(default)s)')\nparser.add_argument('--seq-depth', type=int, metavar='DEPTH', default=64,\n                    help='Sequential test queue depth (default: %(default)s)')\nparser.add_argument('--rand-depth', type=int, metavar='DEPTH', default=64,\n                    help='Random test queue depth (default: %(default)s)')\nparser.add_argument('--numjobs', type=int, metavar='JOBS', default=1,\n                    help='Number of parallel fio jobs to run (default: %(default)s)')\nparser.add_argument('--quiet', action='store_true')\nparser.add_argument('--verbose', action='store_true')\n\ndef info(msg):\n    if not args.quiet:\n        print(msg)\n\ndef dbg(msg):\n    if args.verbose and not args.quiet:\n        print(msg)\n\n# determine ('DEVNAME', 'MAJ:MIN') for @path\ndef dir_to_dev(path):\n    # find the block device the current directory is on\n    devname = subprocess.run(f'findmnt -nvo SOURCE -T{path}',\n                             stdout=subprocess.PIPE, shell=True).stdout\n    devname = os.path.basename(devname).decode('utf-8').strip()\n\n    # partition -> whole device\n    parents = glob.glob('/sys/block/*/' + devname)\n    if len(parents):\n        devname = os.path.basename(os.path.dirname(parents[0]))\n    rdev = os.stat(f'/dev/{devname}').st_rdev\n    return (devname, f'{os.major(rdev)}:{os.minor(rdev)}')\n\ndef create_testfile(path, size):\n    global args\n\n    if os.path.isfile(path) and os.stat(path).st_size == size:\n        return\n\n    info(f'Creating testfile {path}')\n    subprocess.check_call(f'rm -f {path}', shell=True)\n    subprocess.check_call(f'touch {path}', shell=True)\n    subprocess.call(f'chattr +C {path}', shell=True)\n    subprocess.check_call(\n        f'pv -s {size} -pr /dev/urandom {\"-q\" if args.quiet else \"\"} | '\n        f'dd of={path} count={size} '\n        f'iflag=count_bytes,fullblock oflag=direct bs=16M status=none',\n        shell=True)\n\ndef run_fio(testfile, duration, iotype, iodepth, blocksize, jobs):\n    global args\n\n    eta = 'never' if args.quiet else 'always'\n    outfile = tempfile.NamedTemporaryFile()\n    cmd = (f'fio --direct=1 --ioengine=libaio --name=coef '\n           f'--filename={testfile} --runtime={round(duration)} '\n           f'--readwrite={iotype} --iodepth={iodepth} --blocksize={blocksize} '\n           f'--eta={eta} --output-format json --output={outfile.name} '\n           f'--time_based --numjobs={jobs}')\n    if args.verbose:\n        dbg(f'Running {cmd}')\n    subprocess.check_call(cmd, shell=True)\n    with open(outfile.name, 'r') as f:\n        d = json.loads(f.read())\n    return sum(j['read']['bw_bytes'] + j['write']['bw_bytes'] for j in d['jobs'])\n\ndef restore_elevator_nomerges():\n    global elevator_path, nomerges_path, elevator, nomerges\n\n    info(f'Restoring elevator to {elevator} and nomerges to {nomerges}')\n    with open(elevator_path, 'w') as f:\n        f.write(elevator)\n    with open(nomerges_path, 'w') as f:\n        f.write(nomerges)\n\n\nargs = parser.parse_args()\n\nmissing = False\nfor cmd in [ 'findmnt', 'pv', 'dd', 'fio' ]:\n    if not shutil.which(cmd):\n        print(f'Required command \"{cmd}\" is missing', file=sys.stderr)\n        missing = True\nif missing:\n    sys.exit(1)\n\nif args.testdev:\n    devname = os.path.basename(args.testdev)\n    rdev = os.stat(f'/dev/{devname}').st_rdev\n    devno = f'{os.major(rdev)}:{os.minor(rdev)}'\n    testfile = f'/dev/{devname}'\n    info(f'Test target: {devname}({devno})')\nelse:\n    devname, devno = dir_to_dev('.')\n    testfile = 'iocost-coef-fio.testfile'\n    testfile_size = int(args.testfile_size_gb * 2 ** 30)\n    create_testfile(testfile, testfile_size)\n    info(f'Test target: {testfile} on {devname}({devno})')\n\nelevator_path = f'/sys/block/{devname}/queue/scheduler'\nnomerges_path = f'/sys/block/{devname}/queue/nomerges'\n\nwith open(elevator_path, 'r') as f:\n    elevator = re.sub(r'.*\\[(.*)\\].*', r'\\1', f.read().strip())\nwith open(nomerges_path, 'r') as f:\n    nomerges = f.read().strip()\n\ninfo(f'Temporarily disabling elevator and merges')\natexit.register(restore_elevator_nomerges)\nwith open(elevator_path, 'w') as f:\n    f.write('none')\nwith open(nomerges_path, 'w') as f:\n    f.write('1')\n\ninfo('Determining rbps...')\nrbps = run_fio(testfile, args.duration, 'read',\n               1, args.seqio_block_mb * (2 ** 20), args.numjobs)\ninfo(f'\\nrbps={rbps}, determining rseqiops...')\nrseqiops = round(run_fio(testfile, args.duration, 'read',\n                         args.seq_depth, 4096, args.numjobs) / 4096)\ninfo(f'\\nrseqiops={rseqiops}, determining rrandiops...')\nrrandiops = round(run_fio(testfile, args.duration, 'randread',\n                          args.rand_depth, 4096, args.numjobs) / 4096)\ninfo(f'\\nrrandiops={rrandiops}, determining wbps...')\nwbps = run_fio(testfile, args.duration, 'write',\n               1, args.seqio_block_mb * (2 ** 20), args.numjobs)\ninfo(f'\\nwbps={wbps}, determining wseqiops...')\nwseqiops = round(run_fio(testfile, args.duration, 'write',\n                         args.seq_depth, 4096, args.numjobs) / 4096)\ninfo(f'\\nwseqiops={wseqiops}, determining wrandiops...')\nwrandiops = round(run_fio(testfile, args.duration, 'randwrite',\n                          args.rand_depth, 4096, args.numjobs) / 4096)\ninfo(f'\\nwrandiops={wrandiops}')\nrestore_elevator_nomerges()\natexit.unregister(restore_elevator_nomerges)\ninfo('')\n\nprint(f'{devno} rbps={rbps} rseqiops={rseqiops} rrandiops={rrandiops} '\n      f'wbps={wbps} wseqiops={wseqiops} wrandiops={wrandiops}')\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}