{
  "module_name": "iocost_monitor.py",
  "hash_id": "5e4cdb1f84d1f4315837bb18d11d789e08a144834e3f4756e11c0b29abb8cd46",
  "original_prompt": "Ingested from linux-6.6.14/tools/cgroup/iocost_monitor.py",
  "human_readable_source": "#!/usr/bin/env drgn\n#\n# Copyright (C) 2019 Tejun Heo <tj@kernel.org>\n# Copyright (C) 2019 Facebook\n\ndesc = \"\"\"\nThis is a drgn script to monitor the blk-iocost cgroup controller.\nSee the comment at the top of block/blk-iocost.c for more details.\nFor drgn, visit https://github.com/osandov/drgn.\n\"\"\"\n\nimport sys\nimport re\nimport time\nimport json\nimport math\n\nimport drgn\nfrom drgn import container_of\nfrom drgn.helpers.linux.list import list_for_each_entry,list_empty\nfrom drgn.helpers.linux.radixtree import radix_tree_for_each,radix_tree_lookup\n\nimport argparse\nparser = argparse.ArgumentParser(description=desc,\n                                 formatter_class=argparse.RawTextHelpFormatter)\nparser.add_argument('devname', metavar='DEV',\n                    help='Target block device name (e.g. sda)')\nparser.add_argument('--cgroup', action='append', metavar='REGEX',\n                    help='Regex for target cgroups, ')\nparser.add_argument('--interval', '-i', metavar='SECONDS', type=float, default=1,\n                    help='Monitoring interval in seconds (0 exits immediately '\n                    'after checking requirements)')\nparser.add_argument('--json', action='store_true',\n                    help='Output in json')\nargs = parser.parse_args()\n\ndef err(s):\n    print(s, file=sys.stderr, flush=True)\n    sys.exit(1)\n\ntry:\n    blkcg_root = prog['blkcg_root']\n    plid = prog['blkcg_policy_iocost'].plid.value_()\nexcept:\n    err('The kernel does not have iocost enabled')\n\nIOC_RUNNING     = prog['IOC_RUNNING'].value_()\nWEIGHT_ONE      = prog['WEIGHT_ONE'].value_()\nVTIME_PER_SEC   = prog['VTIME_PER_SEC'].value_()\nVTIME_PER_USEC  = prog['VTIME_PER_USEC'].value_()\nAUTOP_SSD_FAST  = prog['AUTOP_SSD_FAST'].value_()\nAUTOP_SSD_DFL   = prog['AUTOP_SSD_DFL'].value_()\nAUTOP_SSD_QD1   = prog['AUTOP_SSD_QD1'].value_()\nAUTOP_HDD       = prog['AUTOP_HDD'].value_()\n\nautop_names = {\n    AUTOP_SSD_FAST:        'ssd_fast',\n    AUTOP_SSD_DFL:         'ssd_dfl',\n    AUTOP_SSD_QD1:         'ssd_qd1',\n    AUTOP_HDD:             'hdd',\n}\n\nclass BlkgIterator:\n    def __init__(self, root_blkcg, q_id, include_dying=False):\n        self.include_dying = include_dying\n        self.blkgs = []\n        self.walk(root_blkcg, q_id, '')\n\n    def blkcg_name(blkcg):\n        return blkcg.css.cgroup.kn.name.string_().decode('utf-8')\n\n    def walk(self, blkcg, q_id, parent_path):\n        if not self.include_dying and \\\n           not (blkcg.css.flags.value_() & prog['CSS_ONLINE'].value_()):\n            return\n\n        name = BlkgIterator.blkcg_name(blkcg)\n        path = parent_path + '/' + name if parent_path else name\n        blkg = drgn.Object(prog, 'struct blkcg_gq',\n                           address=radix_tree_lookup(blkcg.blkg_tree.address_of_(), q_id))\n        if not blkg.address_:\n            return\n\n        self.blkgs.append((path if path else '/', blkg))\n\n        for c in list_for_each_entry('struct blkcg',\n                                     blkcg.css.children.address_of_(), 'css.sibling'):\n            self.walk(c, q_id, path)\n\n    def __iter__(self):\n        return iter(self.blkgs)\n\nclass IocStat:\n    def __init__(self, ioc):\n        global autop_names\n\n        self.enabled = ioc.enabled.value_()\n        self.running = ioc.running.value_() == IOC_RUNNING\n        self.period_ms = ioc.period_us.value_() / 1_000\n        self.period_at = ioc.period_at.value_() / 1_000_000\n        self.vperiod_at = ioc.period_at_vtime.value_() / VTIME_PER_SEC\n        self.vrate_pct = ioc.vtime_base_rate.value_() * 100 / VTIME_PER_USEC\n        self.ivrate_pct = ioc.vtime_rate.counter.value_() * 100 / VTIME_PER_USEC\n        self.busy_level = ioc.busy_level.value_()\n        self.autop_idx = ioc.autop_idx.value_()\n        self.user_cost_model = ioc.user_cost_model.value_()\n        self.user_qos_params = ioc.user_qos_params.value_()\n\n        if self.autop_idx in autop_names:\n            self.autop_name = autop_names[self.autop_idx]\n        else:\n            self.autop_name = '?'\n\n    def dict(self, now):\n        return { 'device'               : devname,\n                 'timestamp'            : now,\n                 'enabled'              : self.enabled,\n                 'running'              : self.running,\n                 'period_ms'            : self.period_ms,\n                 'period_at'            : self.period_at,\n                 'period_vtime_at'      : self.vperiod_at,\n                 'busy_level'           : self.busy_level,\n                 'vrate_pct'            : self.vrate_pct,\n                 'ivrate_pct'           : self.ivrate_pct,\n                }\n\n    def table_preamble_str(self):\n        state = ('RUN' if self.running else 'IDLE') if self.enabled else 'OFF'\n        output = f'{devname} {state:4} ' \\\n                 f'per={self.period_ms}ms ' \\\n                 f'cur_per={self.period_at:.3f}:v{self.vperiod_at:.3f} ' \\\n                 f'busy={self.busy_level:+3} ' \\\n                 f'vrate={self.vrate_pct:6.2f}%:{self.ivrate_pct:6.2f}% ' \\\n                 f'params={self.autop_name}'\n        if self.user_cost_model or self.user_qos_params:\n            output += f'({\"C\" if self.user_cost_model else \"\"}{\"Q\" if self.user_qos_params else \"\"})'\n        return output\n\n    def table_header_str(self):\n        return f'{\"\":25} active {\"weight\":>9} {\"hweight%\":>13} {\"inflt%\":>6} ' \\\n               f'{\"usage%\":>6} {\"wait\":>7} {\"debt\":>7} {\"delay\":>7}'\n\nclass IocgStat:\n    def __init__(self, iocg):\n        ioc = iocg.ioc\n        blkg = iocg.pd.blkg\n\n        self.is_active = not list_empty(iocg.active_list.address_of_())\n        self.weight = iocg.weight.value_() / WEIGHT_ONE\n        self.active = iocg.active.value_() / WEIGHT_ONE\n        self.inuse = iocg.inuse.value_() / WEIGHT_ONE\n        self.hwa_pct = iocg.hweight_active.value_() * 100 / WEIGHT_ONE\n        self.hwi_pct = iocg.hweight_inuse.value_() * 100 / WEIGHT_ONE\n        self.address = iocg.value_()\n\n        vdone = iocg.done_vtime.counter.value_()\n        vtime = iocg.vtime.counter.value_()\n        vrate = ioc.vtime_rate.counter.value_()\n        period_vtime = ioc.period_us.value_() * vrate\n        if period_vtime:\n            self.inflight_pct = (vtime - vdone) * 100 / period_vtime\n        else:\n            self.inflight_pct = 0\n\n        self.usage = (100 * iocg.usage_delta_us.value_() /\n                      ioc.period_us.value_()) if self.active else 0\n        self.wait_ms = (iocg.stat.wait_us.value_() -\n                        iocg.last_stat.wait_us.value_()) / 1000\n        self.debt_ms = iocg.abs_vdebt.value_() / VTIME_PER_USEC / 1000\n        if blkg.use_delay.counter.value_() != 0:\n            self.delay_ms = blkg.delay_nsec.counter.value_() / 1_000_000\n        else:\n            self.delay_ms = 0\n\n    def dict(self, now, path):\n        out = { 'cgroup'                : path,\n                'timestamp'             : now,\n                'is_active'             : self.is_active,\n                'weight'                : self.weight,\n                'weight_active'         : self.active,\n                'weight_inuse'          : self.inuse,\n                'hweight_active_pct'    : self.hwa_pct,\n                'hweight_inuse_pct'     : self.hwi_pct,\n                'inflight_pct'          : self.inflight_pct,\n                'usage_pct'             : self.usage,\n                'wait_ms'               : self.wait_ms,\n                'debt_ms'               : self.debt_ms,\n                'delay_ms'              : self.delay_ms,\n                'address'               : self.address }\n        return out\n\n    def table_row_str(self, path):\n        out = f'{path[-28:]:28} ' \\\n              f'{\"*\" if self.is_active else \" \"} ' \\\n              f'{round(self.inuse):5}/{round(self.active):5} ' \\\n              f'{self.hwi_pct:6.2f}/{self.hwa_pct:6.2f} ' \\\n              f'{self.inflight_pct:6.2f} ' \\\n              f'{min(self.usage, 999):6.2f} ' \\\n              f'{self.wait_ms:7.2f} ' \\\n              f'{self.debt_ms:7.2f} ' \\\n              f'{self.delay_ms:7.2f}'\n        out = out.rstrip(':')\n        return out\n\n# handle args\ntable_fmt = not args.json\ninterval = args.interval\ndevname = args.devname\n\nif args.json:\n    table_fmt = False\n\nre_str = None\nif args.cgroup:\n    for r in args.cgroup:\n        if re_str is None:\n            re_str = r\n        else:\n            re_str += '|' + r\n\nfilter_re = re.compile(re_str) if re_str else None\n\n# Locate the roots\nq_id = None\nroot_iocg = None\nioc = None\n\nfor i, ptr in radix_tree_for_each(blkcg_root.blkg_tree.address_of_()):\n    blkg = drgn.Object(prog, 'struct blkcg_gq', address=ptr)\n    try:\n        if devname == blkg.q.mq_kobj.parent.name.string_().decode('utf-8'):\n            q_id = blkg.q.id.value_()\n            if blkg.pd[plid]:\n                root_iocg = container_of(blkg.pd[plid], 'struct ioc_gq', 'pd')\n                ioc = root_iocg.ioc\n            break\n    except:\n        pass\n\nif ioc is None:\n    err(f'Could not find ioc for {devname}');\n\nif interval == 0:\n    sys.exit(0)\n\n# Keep printing\nwhile True:\n    now = time.time()\n    iocstat = IocStat(ioc)\n    output = ''\n\n    if table_fmt:\n        output += '\\n' + iocstat.table_preamble_str()\n        output += '\\n' + iocstat.table_header_str()\n    else:\n        output += json.dumps(iocstat.dict(now))\n\n    for path, blkg in BlkgIterator(blkcg_root, q_id):\n        if filter_re and not filter_re.match(path):\n            continue\n        if not blkg.pd[plid]:\n            continue\n\n        iocg = container_of(blkg.pd[plid], 'struct ioc_gq', 'pd')\n        iocg_stat = IocgStat(iocg)\n\n        if not filter_re and not iocg_stat.is_active:\n            continue\n\n        if table_fmt:\n            output += '\\n' + iocg_stat.table_row_str(path)\n        else:\n            output += '\\n' + json.dumps(iocg_stat.dict(now, path))\n\n    print(output)\n    sys.stdout.flush()\n    time.sleep(interval)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}