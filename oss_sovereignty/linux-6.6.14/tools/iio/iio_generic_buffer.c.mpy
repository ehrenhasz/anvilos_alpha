{
  "module_name": "iio_generic_buffer.c",
  "hash_id": "544179450de2fa14f0a6ad9407d8ea0c4e6f4cc1c588c6d67a45a402441e863e",
  "original_prompt": "Ingested from linux-6.6.14/tools/iio/iio_generic_buffer.c",
  "human_readable_source": "\n \n\n#include <unistd.h>\n#include <stdlib.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/dir.h>\n#include <linux/types.h>\n#include <string.h>\n#include <poll.h>\n#include <endian.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <signal.h>\n#include <sys/ioctl.h>\n#include <linux/iio/buffer.h>\n#include \"iio_utils.h\"\n\n \nenum autochan {\n\tAUTOCHANNELS_DISABLED,\n\tAUTOCHANNELS_ENABLED,\n\tAUTOCHANNELS_ACTIVE,\n};\n\n \nstatic unsigned int size_from_channelarray(struct iio_channel_info *channels, int num_channels)\n{\n\tunsigned int bytes = 0;\n\tint i = 0, max = 0;\n\tunsigned int misalignment;\n\n\twhile (i < num_channels) {\n\t\tif (channels[i].bytes > max)\n\t\t\tmax = channels[i].bytes;\n\t\tif (bytes % channels[i].bytes == 0)\n\t\t\tchannels[i].location = bytes;\n\t\telse\n\t\t\tchannels[i].location = bytes - bytes % channels[i].bytes\n\t\t\t\t\t       + channels[i].bytes;\n\n\t\tbytes = channels[i].location + channels[i].bytes;\n\t\ti++;\n\t}\n\t \n\tmisalignment = bytes % max;\n\tif (misalignment)\n\t\tbytes += max - misalignment;\n\n\treturn bytes;\n}\n\nstatic void print1byte(uint8_t input, struct iio_channel_info *info)\n{\n\t \n\tinput >>= info->shift;\n\tinput &= info->mask;\n\tif (info->is_signed) {\n\t\tint8_t val = (int8_t)(input << (8 - info->bits_used)) >>\n\t\t\t     (8 - info->bits_used);\n\t\tprintf(\"%05f \", ((float)val + info->offset) * info->scale);\n\t} else {\n\t\tprintf(\"%05f \", ((float)input + info->offset) * info->scale);\n\t}\n}\n\nstatic void print2byte(uint16_t input, struct iio_channel_info *info)\n{\n\t \n\tif (info->be)\n\t\tinput = be16toh(input);\n\telse\n\t\tinput = le16toh(input);\n\n\t \n\tinput >>= info->shift;\n\tinput &= info->mask;\n\tif (info->is_signed) {\n\t\tint16_t val = (int16_t)(input << (16 - info->bits_used)) >>\n\t\t\t      (16 - info->bits_used);\n\t\tprintf(\"%05f \", ((float)val + info->offset) * info->scale);\n\t} else {\n\t\tprintf(\"%05f \", ((float)input + info->offset) * info->scale);\n\t}\n}\n\nstatic void print4byte(uint32_t input, struct iio_channel_info *info)\n{\n\t \n\tif (info->be)\n\t\tinput = be32toh(input);\n\telse\n\t\tinput = le32toh(input);\n\n\t \n\tinput >>= info->shift;\n\tinput &= info->mask;\n\tif (info->is_signed) {\n\t\tint32_t val = (int32_t)(input << (32 - info->bits_used)) >>\n\t\t\t      (32 - info->bits_used);\n\t\tprintf(\"%05f \", ((float)val + info->offset) * info->scale);\n\t} else {\n\t\tprintf(\"%05f \", ((float)input + info->offset) * info->scale);\n\t}\n}\n\nstatic void print8byte(uint64_t input, struct iio_channel_info *info)\n{\n\t \n\tif (info->be)\n\t\tinput = be64toh(input);\n\telse\n\t\tinput = le64toh(input);\n\n\t \n\tinput >>= info->shift;\n\tinput &= info->mask;\n\tif (info->is_signed) {\n\t\tint64_t val = (int64_t)(input << (64 - info->bits_used)) >>\n\t\t\t      (64 - info->bits_used);\n\t\t \n\t\tif (info->scale == 1.0f && info->offset == 0.0f)\n\t\t\tprintf(\"%\" PRId64 \" \", val);\n\t\telse\n\t\t\tprintf(\"%05f \",\n\t\t\t       ((float)val + info->offset) * info->scale);\n\t} else {\n\t\tprintf(\"%05f \", ((float)input + info->offset) * info->scale);\n\t}\n}\n\n \nstatic void process_scan(char *data, struct iio_channel_info *channels,\n\t\t\t int num_channels)\n{\n\tint k;\n\n\tfor (k = 0; k < num_channels; k++)\n\t\tswitch (channels[k].bytes) {\n\t\t\t \n\t\tcase 1:\n\t\t\tprint1byte(*(uint8_t *)(data + channels[k].location),\n\t\t\t\t   &channels[k]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprint2byte(*(uint16_t *)(data + channels[k].location),\n\t\t\t\t   &channels[k]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprint4byte(*(uint32_t *)(data + channels[k].location),\n\t\t\t\t   &channels[k]);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tprint8byte(*(uint64_t *)(data + channels[k].location),\n\t\t\t\t   &channels[k]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\tprintf(\"\\n\");\n}\n\nstatic int enable_disable_all_channels(char *dev_dir_name, int buffer_idx, int enable)\n{\n\tconst struct dirent *ent;\n\tchar scanelemdir[256];\n\tDIR *dp;\n\tint ret;\n\n\tsnprintf(scanelemdir, sizeof(scanelemdir),\n\t\t FORMAT_SCAN_ELEMENTS_DIR, dev_dir_name, buffer_idx);\n\tscanelemdir[sizeof(scanelemdir)-1] = '\\0';\n\n\tdp = opendir(scanelemdir);\n\tif (!dp) {\n\t\tfprintf(stderr, \"Enabling/disabling channels: can't open %s\\n\",\n\t\t\tscanelemdir);\n\t\treturn -EIO;\n\t}\n\n\tret = -ENOENT;\n\twhile (ent = readdir(dp), ent) {\n\t\tif (iioutils_check_suffix(ent->d_name, \"_en\")) {\n\t\t\tprintf(\"%sabling: %s\\n\",\n\t\t\t       enable ? \"En\" : \"Dis\",\n\t\t\t       ent->d_name);\n\t\t\tret = write_sysfs_int(ent->d_name, scanelemdir,\n\t\t\t\t\t      enable);\n\t\t\tif (ret < 0)\n\t\t\t\tfprintf(stderr, \"Failed to enable/disable %s\\n\",\n\t\t\t\t\tent->d_name);\n\t\t}\n\t}\n\n\tif (closedir(dp) == -1) {\n\t\tperror(\"Enabling/disabling channels: \"\n\t\t       \"Failed to close directory\");\n\t\treturn -errno;\n\t}\n\treturn 0;\n}\n\nstatic void print_usage(void)\n{\n\tfprintf(stderr, \"Usage: generic_buffer [options]...\\n\"\n\t\t\"Capture, convert and output data from IIO device buffer\\n\"\n\t\t\"  -a         Auto-activate all available channels\\n\"\n\t\t\"  -A         Force-activate ALL channels\\n\"\n\t\t\"  -b <n>     The buffer which to open (by index), default 0\\n\"\n\t\t\"  -c <n>     Do n conversions, or loop forever if n < 0\\n\"\n\t\t\"  -e         Disable wait for event (new data)\\n\"\n\t\t\"  -g         Use trigger-less mode\\n\"\n\t\t\"  -l <n>     Set buffer length to n samples\\n\"\n\t\t\"  --device-name -n <name>\\n\"\n\t\t\"  --device-num -N <num>\\n\"\n\t\t\"        Set device by name or number (mandatory)\\n\"\n\t\t\"  --trigger-name -t <name>\\n\"\n\t\t\"  --trigger-num -T <num>\\n\"\n\t\t\"        Set trigger by name or number\\n\"\n\t\t\"  -w <n>     Set delay between reads in us (event-less mode)\\n\");\n}\n\nstatic enum autochan autochannels = AUTOCHANNELS_DISABLED;\nstatic char *dev_dir_name = NULL;\nstatic char *buf_dir_name = NULL;\nstatic int buffer_idx = 0;\nstatic bool current_trigger_set = false;\n\nstatic void cleanup(void)\n{\n\tint ret;\n\n\t \n\tif (dev_dir_name && current_trigger_set) {\n\t\t \n\t\tret = write_sysfs_string(\"trigger/current_trigger\",\n\t\t\t\t\t dev_dir_name, \"NULL\");\n\t\tif (ret < 0)\n\t\t\tfprintf(stderr, \"Failed to disable trigger: %s\\n\",\n\t\t\t\tstrerror(-ret));\n\t\tcurrent_trigger_set = false;\n\t}\n\n\t \n\tif (buf_dir_name) {\n\t\tret = write_sysfs_int(\"enable\", buf_dir_name, 0);\n\t\tif (ret < 0)\n\t\t\tfprintf(stderr, \"Failed to disable buffer: %s\\n\",\n\t\t\t\tstrerror(-ret));\n\t}\n\n\t \n\tif (dev_dir_name && autochannels == AUTOCHANNELS_ACTIVE) {\n\t\tret = enable_disable_all_channels(dev_dir_name, buffer_idx, 0);\n\t\tif (ret)\n\t\t\tfprintf(stderr, \"Failed to disable all channels\\n\");\n\t\tautochannels = AUTOCHANNELS_DISABLED;\n\t}\n}\n\nstatic void sig_handler(int signum)\n{\n\tfprintf(stderr, \"Caught signal %d\\n\", signum);\n\tcleanup();\n\texit(-signum);\n}\n\nstatic void register_cleanup(void)\n{\n\tstruct sigaction sa = { .sa_handler = sig_handler };\n\tconst int signums[] = { SIGINT, SIGTERM, SIGABRT };\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(signums); ++i) {\n\t\tret = sigaction(signums[i], &sa, NULL);\n\t\tif (ret) {\n\t\t\tperror(\"Failed to register signal handler\");\n\t\t\texit(-1);\n\t\t}\n\t}\n}\n\nstatic const struct option longopts[] = {\n\t{ \"device-name\",\t1, 0, 'n' },\n\t{ \"device-num\",\t\t1, 0, 'N' },\n\t{ \"trigger-name\",\t1, 0, 't' },\n\t{ \"trigger-num\",\t1, 0, 'T' },\n\t{ },\n};\n\nint main(int argc, char **argv)\n{\n\tlong long num_loops = 2;\n\tunsigned long timedelay = 1000000;\n\tunsigned long buf_len = 128;\n\n\tssize_t i;\n\tunsigned long long j;\n\tunsigned long toread;\n\tint ret, c;\n\tstruct stat st;\n\tint fd = -1;\n\tint buf_fd = -1;\n\n\tint num_channels = 0;\n\tchar *trigger_name = NULL, *device_name = NULL;\n\n\tchar *data = NULL;\n\tssize_t read_size;\n\tint dev_num = -1, trig_num = -1;\n\tchar *buffer_access = NULL;\n\tunsigned int scan_size;\n\tint noevents = 0;\n\tint notrigger = 0;\n\tchar *dummy;\n\tbool force_autochannels = false;\n\n\tstruct iio_channel_info *channels = NULL;\n\n\tregister_cleanup();\n\n\twhile ((c = getopt_long(argc, argv, \"aAb:c:egl:n:N:t:T:w:?\", longopts,\n\t\t\t\tNULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tautochannels = AUTOCHANNELS_ENABLED;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tautochannels = AUTOCHANNELS_ENABLED;\n\t\t\tforce_autochannels = true;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\terrno = 0;\n\t\t\tbuffer_idx = strtoll(optarg, &dummy, 10);\n\t\t\tif (errno) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (buffer_idx < 0) {\n\t\t\t\tret = -ERANGE;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\terrno = 0;\n\t\t\tnum_loops = strtoll(optarg, &dummy, 10);\n\t\t\tif (errno) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tnoevents = 1;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tnotrigger = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\terrno = 0;\n\t\t\tbuf_len = strtoul(optarg, &dummy, 10);\n\t\t\tif (errno) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdevice_name = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\terrno = 0;\n\t\t\tdev_num = strtoul(optarg, &dummy, 10);\n\t\t\tif (errno) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttrigger_name = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\terrno = 0;\n\t\t\ttrig_num = strtoul(optarg, &dummy, 10);\n\t\t\tif (errno)\n\t\t\t\treturn -errno;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\terrno = 0;\n\t\t\ttimedelay = strtoul(optarg, &dummy, 10);\n\t\t\tif (errno) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tprint_usage();\n\t\t\tret = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tif (dev_num < 0 && !device_name) {\n\t\tfprintf(stderr, \"Device not set\\n\");\n\t\tprint_usage();\n\t\tret = -1;\n\t\tgoto error;\n\t} else if (dev_num >= 0 && device_name) {\n\t\tfprintf(stderr, \"Only one of --device-num or --device-name needs to be set\\n\");\n\t\tprint_usage();\n\t\tret = -1;\n\t\tgoto error;\n\t} else if (dev_num < 0) {\n\t\tdev_num = find_type_by_name(device_name, \"iio:device\");\n\t\tif (dev_num < 0) {\n\t\t\tfprintf(stderr, \"Failed to find the %s\\n\", device_name);\n\t\t\tret = dev_num;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tprintf(\"iio device number being used is %d\\n\", dev_num);\n\n\tret = asprintf(&dev_dir_name, \"%siio:device%d\", iio_dir, dev_num);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\t \n\tif (!device_name) {\n\t\tdevice_name = malloc(IIO_MAX_NAME_LENGTH);\n\t\tif (!device_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tret = read_sysfs_string(\"name\", dev_dir_name, device_name);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Failed to read name of device %d\\n\", dev_num);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (notrigger) {\n\t\tprintf(\"trigger-less mode selected\\n\");\n\t} else if (trig_num >= 0) {\n\t\tchar *trig_dev_name;\n\t\tret = asprintf(&trig_dev_name, \"%strigger%d\", iio_dir, trig_num);\n\t\tif (ret < 0) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\ttrigger_name = malloc(IIO_MAX_NAME_LENGTH);\n\t\tret = read_sysfs_string(\"name\", trig_dev_name, trigger_name);\n\t\tfree(trig_dev_name);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Failed to read trigger%d name from\\n\", trig_num);\n\t\t\treturn ret;\n\t\t}\n\t\tprintf(\"iio trigger number being used is %d\\n\", trig_num);\n\t} else {\n\t\tif (!trigger_name) {\n\t\t\t \n\t\t\tret = asprintf(&trigger_name,\n\t\t\t\t       \"%s-dev%d\", device_name, dev_num);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttrig_num = find_type_by_name(trigger_name, \"trigger\");\n\t\tif (trig_num < 0) {\n\t\t\t \n\t\t\tfree(trigger_name);\n\t\t\tret = asprintf(&trigger_name,\n\t\t\t\t       \"%s-trigger\", device_name);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\ttrig_num = find_type_by_name(trigger_name, \"trigger\");\n\t\tif (trig_num < 0) {\n\t\t\tfprintf(stderr, \"Failed to find the trigger %s\\n\",\n\t\t\t\ttrigger_name);\n\t\t\tret = trig_num;\n\t\t\tgoto error;\n\t\t}\n\n\t\tprintf(\"iio trigger number being used is %d\\n\", trig_num);\n\t}\n\n\t \n\tret = build_channel_array(dev_dir_name, buffer_idx, &channels, &num_channels);\n\tif (ret) {\n\t\tfprintf(stderr, \"Problem reading scan element information\\n\"\n\t\t\t\"diag %s\\n\", dev_dir_name);\n\t\tgoto error;\n\t}\n\tif (num_channels && autochannels == AUTOCHANNELS_ENABLED &&\n\t    !force_autochannels) {\n\t\tfprintf(stderr, \"Auto-channels selected but some channels \"\n\t\t\t\"are already activated in sysfs\\n\");\n\t\tfprintf(stderr, \"Proceeding without activating any channels\\n\");\n\t}\n\n\tif ((!num_channels && autochannels == AUTOCHANNELS_ENABLED) ||\n\t    (autochannels == AUTOCHANNELS_ENABLED && force_autochannels)) {\n\t\tfprintf(stderr, \"Enabling all channels\\n\");\n\n\t\tret = enable_disable_all_channels(dev_dir_name, buffer_idx, 1);\n\t\tif (ret) {\n\t\t\tfprintf(stderr, \"Failed to enable all channels\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tautochannels = AUTOCHANNELS_ACTIVE;\n\n\t\tret = build_channel_array(dev_dir_name, buffer_idx, &channels,\n\t\t\t\t\t  &num_channels);\n\t\tif (ret) {\n\t\t\tfprintf(stderr, \"Problem reading scan element \"\n\t\t\t\t\"information\\n\"\n\t\t\t\t\"diag %s\\n\", dev_dir_name);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!num_channels) {\n\t\t\tfprintf(stderr, \"Still no channels after \"\n\t\t\t\t\"auto-enabling, giving up\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (!num_channels && autochannels == AUTOCHANNELS_DISABLED) {\n\t\tfprintf(stderr,\n\t\t\t\"No channels are enabled, we have nothing to scan.\\n\");\n\t\tfprintf(stderr, \"Enable channels manually in \"\n\t\t\tFORMAT_SCAN_ELEMENTS_DIR\n\t\t\t\"/*_en or pass -a to autoenable channels and \"\n\t\t\t\"try again.\\n\", dev_dir_name, buffer_idx);\n\t\tret = -ENOENT;\n\t\tgoto error;\n\t}\n\n\t \n\tret = asprintf(&buf_dir_name,\n\t\t       \"%siio:device%d/buffer%d\", iio_dir, dev_num, buffer_idx);\n\tif (ret < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (stat(buf_dir_name, &st)) {\n\t\tfprintf(stderr, \"Could not stat() '%s', got error %d: %s\\n\",\n\t\t\tbuf_dir_name, errno, strerror(errno));\n\t\tret = -errno;\n\t\tgoto error;\n\t}\n\n\tif (!S_ISDIR(st.st_mode)) {\n\t\tfprintf(stderr, \"File '%s' is not a directory\\n\", buf_dir_name);\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tif (!notrigger) {\n\t\tprintf(\"%s %s\\n\", dev_dir_name, trigger_name);\n\t\t \n\t\tret = write_sysfs_string_and_verify(\"trigger/current_trigger\",\n\t\t\t\t\t\t    dev_dir_name,\n\t\t\t\t\t\t    trigger_name);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Failed to write current_trigger file\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = asprintf(&buffer_access, \"/dev/iio:device%d\", dev_num);\n\tif (ret < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tfd = open(buffer_access, O_RDONLY | O_NONBLOCK);\n\tif (fd == -1) {  \n\t\tret = -errno;\n\t\tfprintf(stderr, \"Failed to open %s\\n\", buffer_access);\n\t\tgoto error;\n\t}\n\n\t \n\tbuf_fd = buffer_idx;\n\n\tret = ioctl(fd, IIO_BUFFER_GET_FD_IOCTL, &buf_fd);\n\tif (ret == -1 || buf_fd == -1) {\n\t\tret = -errno;\n\t\tif (ret == -ENODEV || ret == -EINVAL)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Device does not have this many buffers\\n\");\n\t\telse\n\t\t\tfprintf(stderr, \"Failed to retrieve buffer fd\\n\");\n\n\t\tgoto error;\n\t}\n\n\t \n\tret = write_sysfs_int(\"length\", buf_dir_name, buf_len);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = write_sysfs_int(\"enable\", buf_dir_name, 1);\n\tif (ret < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"Failed to enable buffer '%s': %s\\n\",\n\t\t\tbuf_dir_name, strerror(-ret));\n\t\tgoto error;\n\t}\n\n\tscan_size = size_from_channelarray(channels, num_channels);\n\n\tsize_t total_buf_len = scan_size * buf_len;\n\n\tif (scan_size > 0 && total_buf_len / scan_size != buf_len) {\n\t\tret = -EFAULT;\n\t\tperror(\"Integer overflow happened when calculate scan_size * buf_len\");\n\t\tgoto error;\n\t}\n\n\tdata = malloc(total_buf_len);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tif (buffer_idx == 0) {\n\t\terrno = 0;\n\t\tread_size = read(fd, data, 1);\n\t\tif (read_size > -1 || errno != EBUSY) {\n\t\t\tret = -EFAULT;\n\t\t\tperror(\"Reading from '%s' should not be possible after ioctl()\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tif (close(fd) == -1)\n\t\tperror(\"Failed to close character device file\");\n\tfd = -1;\n\n\tfor (j = 0; j < num_loops || num_loops < 0; j++) {\n\t\tif (!noevents) {\n\t\t\tstruct pollfd pfd = {\n\t\t\t\t.fd = buf_fd,\n\t\t\t\t.events = POLLIN,\n\t\t\t};\n\n\t\t\tret = poll(&pfd, 1, -1);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error;\n\t\t\t} else if (ret == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t} else {\n\t\t\tusleep(timedelay);\n\t\t}\n\n\t\ttoread = buf_len;\n\n\t\tread_size = read(buf_fd, data, toread * scan_size);\n\t\tif (read_size < 0) {\n\t\t\tif (errno == EAGAIN) {\n\t\t\t\tfprintf(stderr, \"nothing available\\n\");\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < read_size / scan_size; i++)\n\t\t\tprocess_scan(data + scan_size * i, channels,\n\t\t\t\t     num_channels);\n\t}\n\nerror:\n\tcleanup();\n\n\tif (fd >= 0 && close(fd) == -1)\n\t\tperror(\"Failed to close character device\");\n\tif (buf_fd >= 0 && close(buf_fd) == -1)\n\t\tperror(\"Failed to close buffer\");\n\tfree(buffer_access);\n\tfree(data);\n\tfree(buf_dir_name);\n\tfor (i = num_channels - 1; i >= 0; i--) {\n\t\tfree(channels[i].name);\n\t\tfree(channels[i].generic_name);\n\t}\n\tfree(channels);\n\tfree(trigger_name);\n\tfree(device_name);\n\tfree(dev_dir_name);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}