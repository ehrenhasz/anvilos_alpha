{
  "module_name": "iio_utils.c",
  "hash_id": "ed1ffd441150bafc50fc9c471ec22bcd1ab4cb853c67fa0d3492ece4aef8973c",
  "original_prompt": "Ingested from linux-6.6.14/tools/iio/iio_utils.c",
  "human_readable_source": "\n \n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <dirent.h>\n#include <errno.h>\n#include <ctype.h>\n#include \"iio_utils.h\"\n\nconst char *iio_dir = \"/sys/bus/iio/devices/\";\n\nstatic char * const iio_direction[] = {\n\t\"in\",\n\t\"out\",\n};\n\n \nint iioutils_break_up_name(const char *full_name, char **generic_name)\n{\n\tchar *current;\n\tchar *w, *r;\n\tchar *working, *prefix = \"\";\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(iio_direction); i++)\n\t\tif (!strncmp(full_name, iio_direction[i],\n\t\t\t     strlen(iio_direction[i]))) {\n\t\t\tprefix = iio_direction[i];\n\t\t\tbreak;\n\t\t}\n\n\tcurrent = strdup(full_name + strlen(prefix) + 1);\n\tif (!current)\n\t\treturn -ENOMEM;\n\n\tworking = strtok(current, \"_\\0\");\n\tif (!working) {\n\t\tfree(current);\n\t\treturn -EINVAL;\n\t}\n\n\tw = working;\n\tr = working;\n\n\twhile (*r != '\\0') {\n\t\tif (!isdigit(*r)) {\n\t\t\t*w = *r;\n\t\t\tw++;\n\t\t}\n\n\t\tr++;\n\t}\n\t*w = '\\0';\n\tret = asprintf(generic_name, \"%s_%s\", prefix, working);\n\tfree(current);\n\n\treturn (ret == -1) ? -ENOMEM : 0;\n}\n\n \nstatic int iioutils_get_type(unsigned int *is_signed, unsigned int *bytes,\n\t\t\t     unsigned int *bits_used, unsigned int *shift,\n\t\t\t     uint64_t *mask, unsigned int *be,\n\t\t\t     const char *device_dir, int buffer_idx,\n\t\t\t     const char *name, const char *generic_name)\n{\n\tFILE *sysfsfp;\n\tint ret;\n\tDIR *dp;\n\tchar *scan_el_dir, *builtname, *builtname_generic, *filename = 0;\n\tchar signchar, endianchar;\n\tunsigned padint;\n\tconst struct dirent *ent;\n\n\tret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir, buffer_idx);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tret = asprintf(&builtname, FORMAT_TYPE_FILE, name);\n\tif (ret < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free_scan_el_dir;\n\t}\n\tret = asprintf(&builtname_generic, FORMAT_TYPE_FILE, generic_name);\n\tif (ret < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free_builtname;\n\t}\n\n\tdp = opendir(scan_el_dir);\n\tif (!dp) {\n\t\tret = -errno;\n\t\tgoto error_free_builtname_generic;\n\t}\n\n\tret = -ENOENT;\n\twhile (ent = readdir(dp), ent)\n\t\tif ((strcmp(builtname, ent->d_name) == 0) ||\n\t\t    (strcmp(builtname_generic, ent->d_name) == 0)) {\n\t\t\tret = asprintf(&filename,\n\t\t\t\t       \"%s/%s\", scan_el_dir, ent->d_name);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error_closedir;\n\t\t\t}\n\n\t\t\tsysfsfp = fopen(filename, \"r\");\n\t\t\tif (!sysfsfp) {\n\t\t\t\tret = -errno;\n\t\t\t\tfprintf(stderr, \"failed to open %s\\n\",\n\t\t\t\t\tfilename);\n\t\t\t\tgoto error_free_filename;\n\t\t\t}\n\n\t\t\tret = fscanf(sysfsfp,\n\t\t\t\t     \"%ce:%c%u/%u>>%u\",\n\t\t\t\t     &endianchar,\n\t\t\t\t     &signchar,\n\t\t\t\t     bits_used,\n\t\t\t\t     &padint, shift);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -errno;\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"failed to pass scan type description\\n\");\n\t\t\t\tgoto error_close_sysfsfp;\n\t\t\t} else if (ret != 5) {\n\t\t\t\tret = -EIO;\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"scan type description didn't match\\n\");\n\t\t\t\tgoto error_close_sysfsfp;\n\t\t\t}\n\n\t\t\t*be = (endianchar == 'b');\n\t\t\t*bytes = padint / 8;\n\t\t\tif (*bits_used == 64)\n\t\t\t\t*mask = ~(0ULL);\n\t\t\telse\n\t\t\t\t*mask = (1ULL << *bits_used) - 1ULL;\n\n\t\t\t*is_signed = (signchar == 's');\n\t\t\tif (fclose(sysfsfp)) {\n\t\t\t\tret = -errno;\n\t\t\t\tfprintf(stderr, \"Failed to close %s\\n\",\n\t\t\t\t\tfilename);\n\t\t\t\tgoto error_free_filename;\n\t\t\t}\n\n\t\t\tsysfsfp = 0;\n\t\t\tfree(filename);\n\t\t\tfilename = 0;\n\n\t\t\t \n\t\t\tif (strcmp(builtname, ent->d_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\nerror_close_sysfsfp:\n\tif (sysfsfp)\n\t\tif (fclose(sysfsfp))\n\t\t\tperror(\"iioutils_get_type(): Failed to close file\");\n\nerror_free_filename:\n\tif (filename)\n\t\tfree(filename);\n\nerror_closedir:\n\tif (closedir(dp) == -1)\n\t\tperror(\"iioutils_get_type(): Failed to close directory\");\n\nerror_free_builtname_generic:\n\tfree(builtname_generic);\nerror_free_builtname:\n\tfree(builtname);\nerror_free_scan_el_dir:\n\tfree(scan_el_dir);\n\n\treturn ret;\n}\n\n \nint iioutils_get_param_float(float *output, const char *param_name,\n\t\t\t     const char *device_dir, const char *name,\n\t\t\t     const char *generic_name)\n{\n\tFILE *sysfsfp;\n\tint ret;\n\tDIR *dp;\n\tchar *builtname, *builtname_generic;\n\tchar *filename = NULL;\n\tconst struct dirent *ent;\n\n\tret = asprintf(&builtname, \"%s_%s\", name, param_name);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tret = asprintf(&builtname_generic,\n\t\t       \"%s_%s\", generic_name, param_name);\n\tif (ret < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free_builtname;\n\t}\n\n\tdp = opendir(device_dir);\n\tif (!dp) {\n\t\tret = -errno;\n\t\tgoto error_free_builtname_generic;\n\t}\n\n\tret = -ENOENT;\n\twhile (ent = readdir(dp), ent)\n\t\tif ((strcmp(builtname, ent->d_name) == 0) ||\n\t\t    (strcmp(builtname_generic, ent->d_name) == 0)) {\n\t\t\tret = asprintf(&filename,\n\t\t\t\t       \"%s/%s\", device_dir, ent->d_name);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error_closedir;\n\t\t\t}\n\n\t\t\tsysfsfp = fopen(filename, \"r\");\n\t\t\tif (!sysfsfp) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error_free_filename;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tif (fscanf(sysfsfp, \"%f\", output) != 1)\n\t\t\t\tret = errno ? -errno : -ENODATA;\n\n\t\t\tfclose(sysfsfp);\n\t\t\tbreak;\n\t\t}\nerror_free_filename:\n\tif (filename)\n\t\tfree(filename);\n\nerror_closedir:\n\tif (closedir(dp) == -1)\n\t\tperror(\"iioutils_get_param_float(): Failed to close directory\");\n\nerror_free_builtname_generic:\n\tfree(builtname_generic);\nerror_free_builtname:\n\tfree(builtname);\n\n\treturn ret;\n}\n\n \n\nvoid bsort_channel_array_by_index(struct iio_channel_info *ci_array, int cnt)\n{\n\tstruct iio_channel_info temp;\n\tint x, y;\n\n\tfor (x = 0; x < cnt; x++)\n\t\tfor (y = 0; y < (cnt - 1); y++)\n\t\t\tif (ci_array[y].index > ci_array[y + 1].index) {\n\t\t\t\ttemp = ci_array[y + 1];\n\t\t\t\tci_array[y + 1] = ci_array[y];\n\t\t\t\tci_array[y] = temp;\n\t\t\t}\n}\n\n \nint build_channel_array(const char *device_dir, int buffer_idx,\n\t\t\tstruct iio_channel_info **ci_array, int *counter)\n{\n\tDIR *dp;\n\tFILE *sysfsfp;\n\tint count = 0, i;\n\tstruct iio_channel_info *current;\n\tint ret;\n\tconst struct dirent *ent;\n\tchar *scan_el_dir;\n\tchar *filename;\n\n\t*counter = 0;\n\tret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir, buffer_idx);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tdp = opendir(scan_el_dir);\n\tif (!dp) {\n\t\tret = -errno;\n\t\tgoto error_free_name;\n\t}\n\n\twhile (ent = readdir(dp), ent)\n\t\tif (strcmp(ent->d_name + strlen(ent->d_name) - strlen(\"_en\"),\n\t\t\t   \"_en\") == 0) {\n\t\t\tret = asprintf(&filename,\n\t\t\t\t       \"%s/%s\", scan_el_dir, ent->d_name);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error_close_dir;\n\t\t\t}\n\n\t\t\tsysfsfp = fopen(filename, \"r\");\n\t\t\tfree(filename);\n\t\t\tif (!sysfsfp) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error_close_dir;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tif (fscanf(sysfsfp, \"%i\", &ret) != 1) {\n\t\t\t\tret = errno ? -errno : -ENODATA;\n\t\t\t\tif (fclose(sysfsfp))\n\t\t\t\t\tperror(\"build_channel_array(): Failed to close file\");\n\n\t\t\t\tgoto error_close_dir;\n\t\t\t}\n\t\t\tif (ret == 1)\n\t\t\t\t(*counter)++;\n\n\t\t\tif (fclose(sysfsfp)) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error_close_dir;\n\t\t\t}\n\n\t\t}\n\n\t*ci_array = malloc(sizeof(**ci_array) * (*counter));\n\tif (!*ci_array) {\n\t\tret = -ENOMEM;\n\t\tgoto error_close_dir;\n\t}\n\n\tseekdir(dp, 0);\n\twhile (ent = readdir(dp), ent) {\n\t\tif (strcmp(ent->d_name + strlen(ent->d_name) - strlen(\"_en\"),\n\t\t\t   \"_en\") == 0) {\n\t\t\tint current_enabled = 0;\n\n\t\t\tcurrent = &(*ci_array)[count++];\n\t\t\tret = asprintf(&filename,\n\t\t\t\t       \"%s/%s\", scan_el_dir, ent->d_name);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\t \n\t\t\t\tcount--;\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\tsysfsfp = fopen(filename, \"r\");\n\t\t\tfree(filename);\n\t\t\tif (!sysfsfp) {\n\t\t\t\tret = -errno;\n\t\t\t\tcount--;\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tif (fscanf(sysfsfp, \"%i\", &current_enabled) != 1) {\n\t\t\t\tret = errno ? -errno : -ENODATA;\n\t\t\t\tcount--;\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\tif (fclose(sysfsfp)) {\n\t\t\t\tret = -errno;\n\t\t\t\tcount--;\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\tif (!current_enabled) {\n\t\t\t\tcount--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcurrent->scale = 1.0;\n\t\t\tcurrent->offset = 0;\n\t\t\tcurrent->name = strndup(ent->d_name,\n\t\t\t\t\t\tstrlen(ent->d_name) -\n\t\t\t\t\t\tstrlen(\"_en\"));\n\t\t\tif (!current->name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tcount--;\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = iioutils_break_up_name(current->name,\n\t\t\t\t\t\t     &current->generic_name);\n\t\t\tif (ret) {\n\t\t\t\tfree(current->name);\n\t\t\t\tcount--;\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\tret = asprintf(&filename,\n\t\t\t\t       \"%s/%s_index\",\n\t\t\t\t       scan_el_dir,\n\t\t\t\t       current->name);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\tsysfsfp = fopen(filename, \"r\");\n\t\t\tfree(filename);\n\t\t\tif (!sysfsfp) {\n\t\t\t\tret = -errno;\n\t\t\t\tfprintf(stderr, \"failed to open %s/%s_index\\n\",\n\t\t\t\t\tscan_el_dir, current->name);\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tif (fscanf(sysfsfp, \"%u\", &current->index) != 1) {\n\t\t\t\tret = errno ? -errno : -ENODATA;\n\t\t\t\tif (fclose(sysfsfp))\n\t\t\t\t\tperror(\"build_channel_array(): Failed to close file\");\n\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\tif (fclose(sysfsfp)) {\n\t\t\t\tret = -errno;\n\t\t\t\tgoto error_cleanup_array;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = iioutils_get_param_float(&current->scale,\n\t\t\t\t\t\t       \"scale\",\n\t\t\t\t\t\t       device_dir,\n\t\t\t\t\t\t       current->name,\n\t\t\t\t\t\t       current->generic_name);\n\t\t\tif ((ret < 0) && (ret != -ENOENT))\n\t\t\t\tgoto error_cleanup_array;\n\n\t\t\tret = iioutils_get_param_float(&current->offset,\n\t\t\t\t\t\t       \"offset\",\n\t\t\t\t\t\t       device_dir,\n\t\t\t\t\t\t       current->name,\n\t\t\t\t\t\t       current->generic_name);\n\t\t\tif ((ret < 0) && (ret != -ENOENT))\n\t\t\t\tgoto error_cleanup_array;\n\n\t\t\tret = iioutils_get_type(&current->is_signed,\n\t\t\t\t\t\t&current->bytes,\n\t\t\t\t\t\t&current->bits_used,\n\t\t\t\t\t\t&current->shift,\n\t\t\t\t\t\t&current->mask,\n\t\t\t\t\t\t&current->be,\n\t\t\t\t\t\tdevice_dir,\n\t\t\t\t\t\tbuffer_idx,\n\t\t\t\t\t\tcurrent->name,\n\t\t\t\t\t\tcurrent->generic_name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_cleanup_array;\n\t\t}\n\t}\n\n\tif (closedir(dp) == -1) {\n\t\tret = -errno;\n\t\tgoto error_cleanup_array;\n\t}\n\n\tfree(scan_el_dir);\n\t \n\tbsort_channel_array_by_index(*ci_array, *counter);\n\n\treturn 0;\n\nerror_cleanup_array:\n\tfor (i = count - 1;  i >= 0; i--) {\n\t\tfree((*ci_array)[i].name);\n\t\tfree((*ci_array)[i].generic_name);\n\t}\n\tfree(*ci_array);\n\t*ci_array = NULL;\n\t*counter = 0;\nerror_close_dir:\n\tif (dp)\n\t\tif (closedir(dp) == -1)\n\t\t\tperror(\"build_channel_array(): Failed to close dir\");\n\nerror_free_name:\n\tfree(scan_el_dir);\n\n\treturn ret;\n}\n\nstatic int calc_digits(int num)\n{\n\tint count = 0;\n\n\t \n\tif (!num)\n\t\treturn 1;\n\n\twhile (num != 0) {\n\t\tnum /= 10;\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n \nint find_type_by_name(const char *name, const char *type)\n{\n\tconst struct dirent *ent;\n\tint number, numstrlen, ret;\n\n\tFILE *namefp;\n\tDIR *dp;\n\tchar thisname[IIO_MAX_NAME_LENGTH];\n\tchar *filename;\n\n\tdp = opendir(iio_dir);\n\tif (!dp) {\n\t\tfprintf(stderr, \"No industrialio devices available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twhile (ent = readdir(dp), ent) {\n\t\tif (strcmp(ent->d_name, \".\") != 0 &&\n\t\t    strcmp(ent->d_name, \"..\") != 0 &&\n\t\t    strlen(ent->d_name) > strlen(type) &&\n\t\t    strncmp(ent->d_name, type, strlen(type)) == 0) {\n\t\t\terrno = 0;\n\t\t\tret = sscanf(ent->d_name + strlen(type), \"%d\", &number);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = -errno;\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"failed to read element number\\n\");\n\t\t\t\tgoto error_close_dir;\n\t\t\t} else if (ret != 1) {\n\t\t\t\tret = -EIO;\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"failed to match element number\\n\");\n\t\t\t\tgoto error_close_dir;\n\t\t\t}\n\n\t\t\tnumstrlen = calc_digits(number);\n\t\t\t \n\t\t\tif (strncmp(ent->d_name + strlen(type) + numstrlen,\n\t\t\t    \":\", 1) != 0) {\n\t\t\t\tfilename = malloc(strlen(iio_dir) + strlen(type)\n\t\t\t\t\t\t  + numstrlen + 6);\n\t\t\t\tif (!filename) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto error_close_dir;\n\t\t\t\t}\n\n\t\t\t\tret = sprintf(filename, \"%s%s%d/name\", iio_dir,\n\t\t\t\t\t      type, number);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tfree(filename);\n\t\t\t\t\tgoto error_close_dir;\n\t\t\t\t}\n\n\t\t\t\tnamefp = fopen(filename, \"r\");\n\t\t\t\tif (!namefp) {\n\t\t\t\t\tfree(filename);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfree(filename);\n\t\t\t\terrno = 0;\n\t\t\t\tif (fscanf(namefp, \"%s\", thisname) != 1) {\n\t\t\t\t\tret = errno ? -errno : -ENODATA;\n\t\t\t\t\tgoto error_close_dir;\n\t\t\t\t}\n\n\t\t\t\tif (fclose(namefp)) {\n\t\t\t\t\tret = -errno;\n\t\t\t\t\tgoto error_close_dir;\n\t\t\t\t}\n\n\t\t\t\tif (strcmp(name, thisname) == 0) {\n\t\t\t\t\tif (closedir(dp) == -1)\n\t\t\t\t\t\treturn -errno;\n\n\t\t\t\t\treturn number;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (closedir(dp) == -1)\n\t\treturn -errno;\n\n\treturn -ENODEV;\n\nerror_close_dir:\n\tif (closedir(dp) == -1)\n\t\tperror(\"find_type_by_name(): Failed to close directory\");\n\n\treturn ret;\n}\n\nstatic int _write_sysfs_int(const char *filename, const char *basedir, int val,\n\t\t\t    int verify)\n{\n\tint ret = 0;\n\tFILE *sysfsfp;\n\tint test;\n\tchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\n\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\tret = sprintf(temp, \"%s/%s\", basedir, filename);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tsysfsfp = fopen(temp, \"w\");\n\tif (!sysfsfp) {\n\t\tret = -errno;\n\t\tfprintf(stderr, \"failed to open %s\\n\", temp);\n\t\tgoto error_free;\n\t}\n\n\tret = fprintf(sysfsfp, \"%d\", val);\n\tif (ret < 0) {\n\t\tif (fclose(sysfsfp))\n\t\t\tperror(\"_write_sysfs_int(): Failed to close dir\");\n\n\t\tgoto error_free;\n\t}\n\n\tif (fclose(sysfsfp)) {\n\t\tret = -errno;\n\t\tgoto error_free;\n\t}\n\n\tif (verify) {\n\t\tsysfsfp = fopen(temp, \"r\");\n\t\tif (!sysfsfp) {\n\t\t\tret = -errno;\n\t\t\tfprintf(stderr, \"failed to open %s\\n\", temp);\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tif (fscanf(sysfsfp, \"%d\", &test) != 1) {\n\t\t\tret = errno ? -errno : -ENODATA;\n\t\t\tif (fclose(sysfsfp))\n\t\t\t\tperror(\"_write_sysfs_int(): Failed to close dir\");\n\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tif (fclose(sysfsfp)) {\n\t\t\tret = -errno;\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tif (test != val) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Possible failure in int write %d to %s/%s\\n\",\n\t\t\t\tval, basedir, filename);\n\t\t\tret = -1;\n\t\t}\n\t}\n\nerror_free:\n\tfree(temp);\n\treturn ret;\n}\n\n \nint write_sysfs_int(const char *filename, const char *basedir, int val)\n{\n\treturn _write_sysfs_int(filename, basedir, val, 0);\n}\n\n \nint write_sysfs_int_and_verify(const char *filename, const char *basedir,\n\t\t\t       int val)\n{\n\treturn _write_sysfs_int(filename, basedir, val, 1);\n}\n\nstatic int _write_sysfs_string(const char *filename, const char *basedir,\n\t\t\t       const char *val, int verify)\n{\n\tint ret = 0;\n\tFILE  *sysfsfp;\n\tchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\n\n\tif (!temp) {\n\t\tfprintf(stderr, \"Memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = sprintf(temp, \"%s/%s\", basedir, filename);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tsysfsfp = fopen(temp, \"w\");\n\tif (!sysfsfp) {\n\t\tret = -errno;\n\t\tfprintf(stderr, \"Could not open %s\\n\", temp);\n\t\tgoto error_free;\n\t}\n\n\tret = fprintf(sysfsfp, \"%s\", val);\n\tif (ret < 0) {\n\t\tif (fclose(sysfsfp))\n\t\t\tperror(\"_write_sysfs_string(): Failed to close dir\");\n\n\t\tgoto error_free;\n\t}\n\n\tif (fclose(sysfsfp)) {\n\t\tret = -errno;\n\t\tgoto error_free;\n\t}\n\n\tif (verify) {\n\t\tsysfsfp = fopen(temp, \"r\");\n\t\tif (!sysfsfp) {\n\t\t\tret = -errno;\n\t\t\tfprintf(stderr, \"Could not open file to verify\\n\");\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tif (fscanf(sysfsfp, \"%s\", temp) != 1) {\n\t\t\tret = errno ? -errno : -ENODATA;\n\t\t\tif (fclose(sysfsfp))\n\t\t\t\tperror(\"_write_sysfs_string(): Failed to close dir\");\n\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tif (fclose(sysfsfp)) {\n\t\t\tret = -errno;\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tif (strcmp(temp, val) != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Possible failure in string write of %s \"\n\t\t\t\t\"Should be %s written to %s/%s\\n\", temp, val,\n\t\t\t\tbasedir, filename);\n\t\t\tret = -1;\n\t\t}\n\t}\n\nerror_free:\n\tfree(temp);\n\n\treturn ret;\n}\n\n \nint write_sysfs_string_and_verify(const char *filename, const char *basedir,\n\t\t\t\t  const char *val)\n{\n\treturn _write_sysfs_string(filename, basedir, val, 1);\n}\n\n \nint write_sysfs_string(const char *filename, const char *basedir,\n\t\t       const char *val)\n{\n\treturn _write_sysfs_string(filename, basedir, val, 0);\n}\n\n \nint read_sysfs_posint(const char *filename, const char *basedir)\n{\n\tint ret;\n\tFILE  *sysfsfp;\n\tchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\n\n\tif (!temp) {\n\t\tfprintf(stderr, \"Memory allocation failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = sprintf(temp, \"%s/%s\", basedir, filename);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tsysfsfp = fopen(temp, \"r\");\n\tif (!sysfsfp) {\n\t\tret = -errno;\n\t\tgoto error_free;\n\t}\n\n\terrno = 0;\n\tif (fscanf(sysfsfp, \"%d\\n\", &ret) != 1) {\n\t\tret = errno ? -errno : -ENODATA;\n\t\tif (fclose(sysfsfp))\n\t\t\tperror(\"read_sysfs_posint(): Failed to close dir\");\n\n\t\tgoto error_free;\n\t}\n\n\tif (fclose(sysfsfp))\n\t\tret = -errno;\n\nerror_free:\n\tfree(temp);\n\n\treturn ret;\n}\n\n \nint read_sysfs_float(const char *filename, const char *basedir, float *val)\n{\n\tint ret = 0;\n\tFILE  *sysfsfp;\n\tchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\n\n\tif (!temp) {\n\t\tfprintf(stderr, \"Memory allocation failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = sprintf(temp, \"%s/%s\", basedir, filename);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tsysfsfp = fopen(temp, \"r\");\n\tif (!sysfsfp) {\n\t\tret = -errno;\n\t\tgoto error_free;\n\t}\n\n\terrno = 0;\n\tif (fscanf(sysfsfp, \"%f\\n\", val) != 1) {\n\t\tret = errno ? -errno : -ENODATA;\n\t\tif (fclose(sysfsfp))\n\t\t\tperror(\"read_sysfs_float(): Failed to close dir\");\n\n\t\tgoto error_free;\n\t}\n\n\tif (fclose(sysfsfp))\n\t\tret = -errno;\n\nerror_free:\n\tfree(temp);\n\n\treturn ret;\n}\n\n \nint read_sysfs_string(const char *filename, const char *basedir, char *str)\n{\n\tint ret = 0;\n\tFILE  *sysfsfp;\n\tchar *temp = malloc(strlen(basedir) + strlen(filename) + 2);\n\n\tif (!temp) {\n\t\tfprintf(stderr, \"Memory allocation failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = sprintf(temp, \"%s/%s\", basedir, filename);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tsysfsfp = fopen(temp, \"r\");\n\tif (!sysfsfp) {\n\t\tret = -errno;\n\t\tgoto error_free;\n\t}\n\n\terrno = 0;\n\tif (fscanf(sysfsfp, \"%s\\n\", str) != 1) {\n\t\tret = errno ? -errno : -ENODATA;\n\t\tif (fclose(sysfsfp))\n\t\t\tperror(\"read_sysfs_string(): Failed to close dir\");\n\n\t\tgoto error_free;\n\t}\n\n\tif (fclose(sysfsfp))\n\t\tret = -errno;\n\nerror_free:\n\tfree(temp);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}