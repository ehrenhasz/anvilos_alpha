{
  "module_name": "ffs-test.c",
  "hash_id": "310c18b3b27f1eab5a58c67eb818dde4783383e609bd01c8f6cd0e3136415e57",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/ffs-test.c",
  "human_readable_source": "\n \n\n \n\n\n#define _DEFAULT_SOURCE  \n\n#include <endian.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <tools/le_byteshift.h>\n\n#include \"../../include/uapi/linux/usb/functionfs.h\"\n\n\n \n\n \n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n#define cpu_to_le16(x)  (x)\n#define cpu_to_le32(x)  (x)\n#else\n#define cpu_to_le16(x)  ((((x) >> 8) & 0xffu) | (((x) & 0xffu) << 8))\n#define cpu_to_le32(x)  \\\n\t((((x) & 0xff000000u) >> 24) | (((x) & 0x00ff0000u) >>  8) | \\\n\t(((x) & 0x0000ff00u) <<  8) | (((x) & 0x000000ffu) << 24))\n#endif\n\n#define le32_to_cpu(x)  le32toh(x)\n#define le16_to_cpu(x)  le16toh(x)\n\n \n\nstatic const char argv0[] = \"ffs-test\";\n\nstatic unsigned verbosity = 7;\n\nstatic void _msg(unsigned level, const char *fmt, ...)\n{\n\tif (level < 2)\n\t\tlevel = 2;\n\telse if (level > 7)\n\t\tlevel = 7;\n\n\tif (level <= verbosity) {\n\t\tstatic const char levels[8][6] = {\n\t\t\t[2] = \"crit:\",\n\t\t\t[3] = \"err: \",\n\t\t\t[4] = \"warn:\",\n\t\t\t[5] = \"note:\",\n\t\t\t[6] = \"info:\",\n\t\t\t[7] = \"dbg: \"\n\t\t};\n\n\t\tint _errno = errno;\n\t\tva_list ap;\n\n\t\tfprintf(stderr, \"%s: %s \", argv0, levels[level]);\n\t\tva_start(ap, fmt);\n\t\tvfprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\n\t\tif (fmt[strlen(fmt) - 1] != '\\n') {\n\t\t\tchar buffer[128];\n\t\t\tstrerror_r(_errno, buffer, sizeof buffer);\n\t\t\tfprintf(stderr, \": (-%d) %s\\n\", _errno, buffer);\n\t\t}\n\n\t\tfflush(stderr);\n\t}\n}\n\n#define die(...)  (_msg(2, __VA_ARGS__), exit(1))\n#define err(...)   _msg(3, __VA_ARGS__)\n#define warn(...)  _msg(4, __VA_ARGS__)\n#define note(...)  _msg(5, __VA_ARGS__)\n#define info(...)  _msg(6, __VA_ARGS__)\n#define debug(...) _msg(7, __VA_ARGS__)\n\n#define die_on(cond, ...) do { \\\n\tif (cond) \\\n\t\tdie(__VA_ARGS__); \\\n\t} while (0)\n\n\n \n\nstatic const struct {\n\tstruct usb_functionfs_descs_head_v2 header;\n\t__le32 fs_count;\n\t__le32 hs_count;\n\t__le32 ss_count;\n\tstruct {\n\t\tstruct usb_interface_descriptor intf;\n\t\tstruct usb_endpoint_descriptor_no_audio sink;\n\t\tstruct usb_endpoint_descriptor_no_audio source;\n\t} __attribute__((packed)) fs_descs, hs_descs;\n\tstruct {\n\t\tstruct usb_interface_descriptor intf;\n\t\tstruct usb_endpoint_descriptor_no_audio sink;\n\t\tstruct usb_ss_ep_comp_descriptor sink_comp;\n\t\tstruct usb_endpoint_descriptor_no_audio source;\n\t\tstruct usb_ss_ep_comp_descriptor source_comp;\n\t} ss_descs;\n} __attribute__((packed)) descriptors = {\n\t.header = {\n\t\t.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC_V2),\n\t\t.flags = cpu_to_le32(FUNCTIONFS_HAS_FS_DESC |\n\t\t\t\t     FUNCTIONFS_HAS_HS_DESC |\n\t\t\t\t     FUNCTIONFS_HAS_SS_DESC),\n\t\t.length = cpu_to_le32(sizeof descriptors),\n\t},\n\t.fs_count = cpu_to_le32(3),\n\t.fs_descs = {\n\t\t.intf = {\n\t\t\t.bLength = sizeof descriptors.fs_descs.intf,\n\t\t\t.bDescriptorType = USB_DT_INTERFACE,\n\t\t\t.bNumEndpoints = 2,\n\t\t\t.bInterfaceClass = USB_CLASS_VENDOR_SPEC,\n\t\t\t.iInterface = 1,\n\t\t},\n\t\t.sink = {\n\t\t\t.bLength = sizeof descriptors.fs_descs.sink,\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 1 | USB_DIR_IN,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t \n\t\t},\n\t\t.source = {\n\t\t\t.bLength = sizeof descriptors.fs_descs.source,\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 2 | USB_DIR_OUT,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t \n\t\t},\n\t},\n\t.hs_count = cpu_to_le32(3),\n\t.hs_descs = {\n\t\t.intf = {\n\t\t\t.bLength = sizeof descriptors.fs_descs.intf,\n\t\t\t.bDescriptorType = USB_DT_INTERFACE,\n\t\t\t.bNumEndpoints = 2,\n\t\t\t.bInterfaceClass = USB_CLASS_VENDOR_SPEC,\n\t\t\t.iInterface = 1,\n\t\t},\n\t\t.sink = {\n\t\t\t.bLength = sizeof descriptors.hs_descs.sink,\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 1 | USB_DIR_IN,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t.wMaxPacketSize = cpu_to_le16(512),\n\t\t},\n\t\t.source = {\n\t\t\t.bLength = sizeof descriptors.hs_descs.source,\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 2 | USB_DIR_OUT,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t.wMaxPacketSize = cpu_to_le16(512),\n\t\t\t.bInterval = 1,  \n\t\t},\n\t},\n\t.ss_count = cpu_to_le32(5),\n\t.ss_descs = {\n\t\t.intf = {\n\t\t\t.bLength = sizeof descriptors.fs_descs.intf,\n\t\t\t.bDescriptorType = USB_DT_INTERFACE,\n\t\t\t.bNumEndpoints = 2,\n\t\t\t.bInterfaceClass = USB_CLASS_VENDOR_SPEC,\n\t\t\t.iInterface = 1,\n\t\t},\n\t\t.sink = {\n\t\t\t.bLength = sizeof descriptors.hs_descs.sink,\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 1 | USB_DIR_IN,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t.wMaxPacketSize = cpu_to_le16(1024),\n\t\t},\n\t\t.sink_comp = {\n\t\t\t.bLength = USB_DT_SS_EP_COMP_SIZE,\n\t\t\t.bDescriptorType = USB_DT_SS_ENDPOINT_COMP,\n\t\t\t.bMaxBurst = 0,\n\t\t\t.bmAttributes = 0,\n\t\t\t.wBytesPerInterval = 0,\n\t\t},\n\t\t.source = {\n\t\t\t.bLength = sizeof descriptors.hs_descs.source,\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 2 | USB_DIR_OUT,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t.wMaxPacketSize = cpu_to_le16(1024),\n\t\t\t.bInterval = 1,  \n\t\t},\n\t\t.source_comp = {\n\t\t\t.bLength = USB_DT_SS_EP_COMP_SIZE,\n\t\t\t.bDescriptorType = USB_DT_SS_ENDPOINT_COMP,\n\t\t\t.bMaxBurst = 0,\n\t\t\t.bmAttributes = 0,\n\t\t\t.wBytesPerInterval = 0,\n\t\t},\n\t},\n};\n\nstatic size_t descs_to_legacy(void **legacy, const void *descriptors_v2)\n{\n\tconst unsigned char *descs_end, *descs_start;\n\t__u32 length, fs_count = 0, hs_count = 0, count;\n\n\t \n\t{\n\t\tconst struct {\n\t\t\tconst struct usb_functionfs_descs_head_v2 header;\n\t\t\tconst __le32 counts[];\n\t\t} __attribute__((packed)) *const in = descriptors_v2;\n\t\tconst __le32 *counts = in->counts;\n\t\t__u32 flags;\n\n\t\tif (le32_to_cpu(in->header.magic) !=\n\t\t    FUNCTIONFS_DESCRIPTORS_MAGIC_V2)\n\t\t\treturn 0;\n\t\tlength = le32_to_cpu(in->header.length);\n\t\tif (length <= sizeof in->header)\n\t\t\treturn 0;\n\t\tlength -= sizeof in->header;\n\t\tflags = le32_to_cpu(in->header.flags);\n\t\tif (flags & ~(FUNCTIONFS_HAS_FS_DESC | FUNCTIONFS_HAS_HS_DESC |\n\t\t\t      FUNCTIONFS_HAS_SS_DESC))\n\t\t\treturn 0;\n\n#define GET_NEXT_COUNT_IF_FLAG(ret, flg) do {\t\t\\\n\t\t\tif (!(flags & (flg)))\t\t\\\n\t\t\t\tbreak;\t\t\t\\\n\t\t\tif (length < 4)\t\t\t\\\n\t\t\t\treturn 0;\t\t\\\n\t\t\tret = le32_to_cpu(*counts);\t\\\n\t\t\tlength -= 4;\t\t\t\\\n\t\t\t++counts;\t\t\t\\\n\t\t} while (0)\n\n\t\tGET_NEXT_COUNT_IF_FLAG(fs_count, FUNCTIONFS_HAS_FS_DESC);\n\t\tGET_NEXT_COUNT_IF_FLAG(hs_count, FUNCTIONFS_HAS_HS_DESC);\n\t\tGET_NEXT_COUNT_IF_FLAG(count, FUNCTIONFS_HAS_SS_DESC);\n\n\t\tcount = fs_count + hs_count;\n\t\tif (!count)\n\t\t\treturn 0;\n\t\tdescs_start = (const void *)counts;\n\n#undef GET_NEXT_COUNT_IF_FLAG\n\t}\n\n\t \n\tdescs_end = descs_start;\n\tdo {\n\t\tif (length < *descs_end)\n\t\t\treturn 0;\n\t\tlength -= *descs_end;\n\t\tdescs_end += *descs_end;\n\t} while (--count);\n\n\t \n\t{\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n\t\tstruct {\n\t\t\tstruct usb_functionfs_descs_head header;\n\t\t\t__u8 descriptors[];\n\t\t} __attribute__((packed)) *out;\n#pragma GCC diagnostic pop\n\n\t\tlength = sizeof out->header + (descs_end - descs_start);\n\t\tout = malloc(length);\n\t\tout->header.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC);\n\t\tout->header.length = cpu_to_le32(length);\n\t\tout->header.fs_count = cpu_to_le32(fs_count);\n\t\tout->header.hs_count = cpu_to_le32(hs_count);\n\t\tmemcpy(out->descriptors, descs_start, descs_end - descs_start);\n\t\t*legacy = out;\n\t}\n\n\treturn length;\n}\n\n\n#define STR_INTERFACE_ \"Source/Sink\"\n\nstatic const struct {\n\tstruct usb_functionfs_strings_head header;\n\tstruct {\n\t\t__le16 code;\n\t\tconst char str1[sizeof STR_INTERFACE_];\n\t} __attribute__((packed)) lang0;\n} __attribute__((packed)) strings = {\n\t.header = {\n\t\t.magic = cpu_to_le32(FUNCTIONFS_STRINGS_MAGIC),\n\t\t.length = cpu_to_le32(sizeof strings),\n\t\t.str_count = cpu_to_le32(1),\n\t\t.lang_count = cpu_to_le32(1),\n\t},\n\t.lang0 = {\n\t\tcpu_to_le16(0x0409),  \n\t\tSTR_INTERFACE_,\n\t},\n};\n\n#define STR_INTERFACE strings.lang0.str1\n\n\n \n\nstruct thread;\n\nstatic ssize_t read_wrap(struct thread *t, void *buf, size_t nbytes);\nstatic ssize_t write_wrap(struct thread *t, const void *buf, size_t nbytes);\nstatic ssize_t ep0_consume(struct thread *t, const void *buf, size_t nbytes);\nstatic ssize_t fill_in_buf(struct thread *t, void *buf, size_t nbytes);\nstatic ssize_t empty_out_buf(struct thread *t, const void *buf, size_t nbytes);\n\n\nstatic struct thread {\n\tconst char *const filename;\n\tsize_t buf_size;\n\n\tssize_t (*in)(struct thread *, void *, size_t);\n\tconst char *const in_name;\n\n\tssize_t (*out)(struct thread *, const void *, size_t);\n\tconst char *const out_name;\n\n\tint fd;\n\tpthread_t id;\n\tvoid *buf;\n\tssize_t status;\n} threads[] = {\n\t{\n\t\t\"ep0\", 4 * sizeof(struct usb_functionfs_event),\n\t\tread_wrap, NULL,\n\t\tep0_consume, \"<consume>\",\n\t\t0, 0, NULL, 0\n\t},\n\t{\n\t\t\"ep1\", 8 * 1024,\n\t\tfill_in_buf, \"<in>\",\n\t\twrite_wrap, NULL,\n\t\t0, 0, NULL, 0\n\t},\n\t{\n\t\t\"ep2\", 8 * 1024,\n\t\tread_wrap, NULL,\n\t\tempty_out_buf, \"<out>\",\n\t\t0, 0, NULL, 0\n\t},\n};\n\n\nstatic void init_thread(struct thread *t)\n{\n\tt->buf = malloc(t->buf_size);\n\tdie_on(!t->buf, \"malloc\");\n\n\tt->fd = open(t->filename, O_RDWR);\n\tdie_on(t->fd < 0, \"%s\", t->filename);\n}\n\nstatic void cleanup_thread(void *arg)\n{\n\tstruct thread *t = arg;\n\tint ret, fd;\n\n\tfd = t->fd;\n\tif (t->fd < 0)\n\t\treturn;\n\tt->fd = -1;\n\n\t \n\tif (t != threads) {\n\t\tret = ioctl(fd, FUNCTIONFS_FIFO_STATUS);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tif (errno != ENODEV)\n\t\t\t\terr(\"%s: get fifo status\", t->filename);\n\t\t} else if (ret) {\n\t\t\twarn(\"%s: unclaimed = %d\\n\", t->filename, ret);\n\t\t\tif (ioctl(fd, FUNCTIONFS_FIFO_FLUSH) < 0)\n\t\t\t\terr(\"%s: fifo flush\", t->filename);\n\t\t}\n\t}\n\n\tif (close(fd) < 0)\n\t\terr(\"%s: close\", t->filename);\n\n\tfree(t->buf);\n\tt->buf = NULL;\n}\n\nstatic void *start_thread_helper(void *arg)\n{\n\tconst char *name, *op, *in_name, *out_name;\n\tstruct thread *t = arg;\n\tssize_t ret;\n\n\tinfo(\"%s: starts\\n\", t->filename);\n\tin_name = t->in_name ? t->in_name : t->filename;\n\tout_name = t->out_name ? t->out_name : t->filename;\n\n\tpthread_cleanup_push(cleanup_thread, arg);\n\n\tfor (;;) {\n\t\tpthread_testcancel();\n\n\t\tret = t->in(t, t->buf, t->buf_size);\n\t\tif (ret > 0) {\n\t\t\tret = t->out(t, t->buf, ret);\n\t\t\tname = out_name;\n\t\t\top = \"write\";\n\t\t} else {\n\t\t\tname = in_name;\n\t\t\top = \"read\";\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\t \n\t\t} else if (!ret) {\n\t\t\tdebug(\"%s: %s: EOF\", name, op);\n\t\t\tbreak;\n\t\t} else if (errno == EINTR || errno == EAGAIN) {\n\t\t\tdebug(\"%s: %s\", name, op);\n\t\t} else {\n\t\t\twarn(\"%s: %s\", name, op);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpthread_cleanup_pop(1);\n\n\tt->status = ret;\n\tinfo(\"%s: ends\\n\", t->filename);\n\treturn NULL;\n}\n\nstatic void start_thread(struct thread *t)\n{\n\tdebug(\"%s: starting\\n\", t->filename);\n\n\tdie_on(pthread_create(&t->id, NULL, start_thread_helper, t) < 0,\n\t       \"pthread_create(%s)\", t->filename);\n}\n\nstatic void join_thread(struct thread *t)\n{\n\tint ret = pthread_join(t->id, NULL);\n\n\tif (ret < 0)\n\t\terr(\"%s: joining thread\", t->filename);\n\telse\n\t\tdebug(\"%s: joined\\n\", t->filename);\n}\n\n\nstatic ssize_t read_wrap(struct thread *t, void *buf, size_t nbytes)\n{\n\treturn read(t->fd, buf, nbytes);\n}\n\nstatic ssize_t write_wrap(struct thread *t, const void *buf, size_t nbytes)\n{\n\treturn write(t->fd, buf, nbytes);\n}\n\n\n \n\n \nenum pattern { PAT_ZERO, PAT_SEQ, PAT_PIPE };\nstatic enum pattern pattern;\n\nstatic ssize_t\nfill_in_buf(struct thread *ignore, void *buf, size_t nbytes)\n{\n\tsize_t i;\n\t__u8 *p;\n\n\t(void)ignore;\n\n\tswitch (pattern) {\n\tcase PAT_ZERO:\n\t\tmemset(buf, 0, nbytes);\n\t\tbreak;\n\n\tcase PAT_SEQ:\n\t\tfor (p = buf, i = 0; i < nbytes; ++i, ++p)\n\t\t\t*p = i % 63;\n\t\tbreak;\n\n\tcase PAT_PIPE:\n\t\treturn fread(buf, 1, nbytes, stdin);\n\t}\n\n\treturn nbytes;\n}\n\nstatic ssize_t\nempty_out_buf(struct thread *ignore, const void *buf, size_t nbytes)\n{\n\tconst __u8 *p;\n\t__u8 expected;\n\tssize_t ret;\n\tsize_t len;\n\n\t(void)ignore;\n\n\tswitch (pattern) {\n\tcase PAT_ZERO:\n\t\texpected = 0;\n\t\tfor (p = buf, len = 0; len < nbytes; ++p, ++len)\n\t\t\tif (*p)\n\t\t\t\tgoto invalid;\n\t\tbreak;\n\n\tcase PAT_SEQ:\n\t\tfor (p = buf, len = 0; len < nbytes; ++p, ++len)\n\t\t\tif (*p != len % 63) {\n\t\t\t\texpected = len % 63;\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\tbreak;\n\n\tcase PAT_PIPE:\n\t\tret = fwrite(buf, nbytes, 1, stdout);\n\t\tif (ret > 0)\n\t\t\tfflush(stdout);\n\t\tbreak;\n\ninvalid:\n\t\terr(\"bad OUT byte %zd, expected %02x got %02x\\n\",\n\t\t    len, expected, *p);\n\t\tfor (p = buf, len = 0; len < nbytes; ++p, ++len) {\n\t\t\tif (0 == (len % 32))\n\t\t\t\tfprintf(stderr, \"%4zd:\", len);\n\t\t\tfprintf(stderr, \" %02x\", *p);\n\t\t\tif (31 == (len % 32))\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfflush(stderr);\n\t\terrno = EILSEQ;\n\t\treturn -1;\n\t}\n\n\treturn len;\n}\n\n\n \n\nstatic void handle_setup(const struct usb_ctrlrequest *setup)\n{\n\tprintf(\"bRequestType = %d\\n\", setup->bRequestType);\n\tprintf(\"bRequest     = %d\\n\", setup->bRequest);\n\tprintf(\"wValue       = %d\\n\", le16_to_cpu(setup->wValue));\n\tprintf(\"wIndex       = %d\\n\", le16_to_cpu(setup->wIndex));\n\tprintf(\"wLength      = %d\\n\", le16_to_cpu(setup->wLength));\n}\n\nstatic ssize_t\nep0_consume(struct thread *ignore, const void *buf, size_t nbytes)\n{\n\tstatic const char *const names[] = {\n\t\t[FUNCTIONFS_BIND] = \"BIND\",\n\t\t[FUNCTIONFS_UNBIND] = \"UNBIND\",\n\t\t[FUNCTIONFS_ENABLE] = \"ENABLE\",\n\t\t[FUNCTIONFS_DISABLE] = \"DISABLE\",\n\t\t[FUNCTIONFS_SETUP] = \"SETUP\",\n\t\t[FUNCTIONFS_SUSPEND] = \"SUSPEND\",\n\t\t[FUNCTIONFS_RESUME] = \"RESUME\",\n\t};\n\n\tconst struct usb_functionfs_event *event = buf;\n\tsize_t n;\n\n\t(void)ignore;\n\n\tfor (n = nbytes / sizeof *event; n; --n, ++event)\n\t\tswitch (event->type) {\n\t\tcase FUNCTIONFS_BIND:\n\t\tcase FUNCTIONFS_UNBIND:\n\t\tcase FUNCTIONFS_ENABLE:\n\t\tcase FUNCTIONFS_DISABLE:\n\t\tcase FUNCTIONFS_SETUP:\n\t\tcase FUNCTIONFS_SUSPEND:\n\t\tcase FUNCTIONFS_RESUME:\n\t\t\tprintf(\"Event %s\\n\", names[event->type]);\n\t\t\tif (event->type == FUNCTIONFS_SETUP)\n\t\t\t\thandle_setup(&event->u.setup);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"Event %03u (unknown)\\n\", event->type);\n\t\t}\n\n\treturn nbytes;\n}\n\nstatic void ep0_init(struct thread *t, bool legacy_descriptors)\n{\n\tvoid *legacy;\n\tssize_t ret;\n\tsize_t len;\n\n\tif (legacy_descriptors) {\n\t\tinfo(\"%s: writing descriptors\\n\", t->filename);\n\t\tgoto legacy;\n\t}\n\n\tinfo(\"%s: writing descriptors (in v2 format)\\n\", t->filename);\n\tret = write(t->fd, &descriptors, sizeof descriptors);\n\n\tif (ret < 0 && errno == EINVAL) {\n\t\twarn(\"%s: new format rejected, trying legacy\\n\", t->filename);\nlegacy:\n\t\tlen = descs_to_legacy(&legacy, &descriptors);\n\t\tif (len) {\n\t\t\tret = write(t->fd, legacy, len);\n\t\t\tfree(legacy);\n\t\t}\n\t}\n\tdie_on(ret < 0, \"%s: write: descriptors\", t->filename);\n\n\tinfo(\"%s: writing strings\\n\", t->filename);\n\tret = write(t->fd, &strings, sizeof strings);\n\tdie_on(ret < 0, \"%s: write: strings\", t->filename);\n}\n\n\n \n\nint main(int argc, char **argv)\n{\n\tbool legacy_descriptors;\n\tunsigned i;\n\n\tlegacy_descriptors = argc > 2 && !strcmp(argv[1], \"-l\");\n\n\tinit_thread(threads);\n\tep0_init(threads, legacy_descriptors);\n\n\tfor (i = 1; i < sizeof threads / sizeof *threads; ++i)\n\t\tinit_thread(threads + i);\n\n\tfor (i = 1; i < sizeof threads / sizeof *threads; ++i)\n\t\tstart_thread(threads + i);\n\n\tstart_thread_helper(threads);\n\n\tfor (i = 1; i < sizeof threads / sizeof *threads; ++i)\n\t\tjoin_thread(threads + i);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}