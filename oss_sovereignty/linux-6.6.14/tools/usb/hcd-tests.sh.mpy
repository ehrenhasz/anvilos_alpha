{
  "module_name": "hcd-tests.sh",
  "hash_id": "650fc0f9d3dc19995ed281ac39f1ba44e19d93b87cadb89d8cb0f63ffcd2b2df",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/hcd-tests.sh",
  "human_readable_source": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0\n#\n# test types can be passed on the command line:\n#\n# - control: any device can do this\n# - out, in:  out needs 'bulk sink' firmware, in needs 'bulk src'\n# - iso-out, iso-in:  out needs 'iso sink' firmware, in needs 'iso src'\n# - halt: needs bulk sink+src, tests halt set/clear from host\n# - unlink: needs bulk sink and/or src, test HCD unlink processing\n# - loop: needs firmware that will buffer N transfers\n#\n# run it for hours, days, weeks.\n#\n\n#\n# this default provides a steady test load for a bulk device\n#\nTYPES='control out in'\n#TYPES='control out in halt'\n\n#\n# to test HCD code\n#\n#  - include unlink tests\n#  - add some ${RANDOM}ness\n#  - connect several devices concurrently (same HC)\n#  - keep HC's IRQ lines busy with unrelated traffic (IDE, net, ...)\n#  - add other concurrent system loads\n#\n\ndeclare -i COUNT BUFLEN\n\nCOUNT=50000\nBUFLEN=2048\n\n# NOTE:  the 'in' and 'out' cases are usually bulk, but can be\n# set up to use interrupt transfers by 'usbtest' module options\n\n\nif [ \"$DEVICE\" = \"\" ]; then\n\techo \"testing ALL recognized usbtest devices\"\n\techo \"\"\n\tTEST_ARGS=\"-a\"\nelse\n\tTEST_ARGS=\"\"\nfi\n\ndo_test ()\n{\n    if ! ./testusb $TEST_ARGS -s $BUFLEN -c $COUNT $* 2>/dev/null\n    then\n\techo \"FAIL\"\n\texit 1\n    fi\n}\n\nARGS=\"$*\"\n\nif [ \"$ARGS\" = \"\" ];\nthen\n    ARGS=\"$TYPES\"\nfi\n\n# FIXME use /sys/bus/usb/device/$THIS/bConfigurationValue to\n# check and change configs\n\nCONFIG=''\n\ncheck_config ()\n{\n    if [ \"$CONFIG\" = \"\" ]; then\n\tCONFIG=$1\n\techo \"assuming $CONFIG configuration\"\n\treturn\n    fi\n    if [ \"$CONFIG\" = $1 ]; then\n\treturn\n    fi\n\n    echo \"** device must be in $1 config, but it's $CONFIG instead\"\n    exit 1\n}\n\n\necho \"TESTING:  $ARGS\"\n\nwhile : true\ndo\n    echo $(date)\n\n    for TYPE in $ARGS\n    do\n\t# restore defaults\n\tCOUNT=5000\n\tBUFLEN=2048\n\n\t# FIXME automatically multiply COUNT by 10 when\n\t# /sys/bus/usb/device/$THIS/speed == \"480\"\n\n#\tCOUNT=50000\n\n\tcase $TYPE in\n\tcontrol)\n\t    # any device, in any configuration, can use this.\n\t    echo '** Control test cases:'\n\n\t    echo \"test 9: ch9 postconfig\"\n\t    do_test -t 9 -c 5000\n\t    echo \"test 10: control queueing\"\n\t    do_test -t 10 -c 5000\n\n\t    # this relies on some vendor-specific commands\n\t    echo \"test 14: control writes\"\n\t    do_test -t 14 -c 15000 -s 256 -v 1\n\n\t    echo \"test 21: control writes, unaligned\"\n\t    do_test -t 21 -c 100 -s 256 -v 1\n\n\t    ;;\n\n\tout)\n\t    check_config sink-src\n\t    echo '** Host Write (OUT) test cases:'\n\n\t    echo \"test 1: $COUNT transfers, same size\"\n\t    do_test -t 1\n\t    echo \"test 3: $COUNT transfers, variable/short size\"\n\t    do_test -t 3 -v 421\n\n\t    COUNT=100\n\t    echo \"test 17: $COUNT transfers, unaligned DMA map by core\"\n\t    do_test -t 17\n\n\t    echo \"test 19: $COUNT transfers, unaligned DMA map by usb_alloc_coherent\"\n\t    do_test -t 19\n\n\t    COUNT=2000\n\t    echo \"test 5: $COUNT scatterlists, same size entries\"\n\t    do_test -t 5\n\n\t    # try to trigger short OUT processing bugs\n\t    echo \"test 7a: $COUNT scatterlists, variable size/short entries\"\n\t    do_test -t 7 -v 579\n\t    BUFLEN=4096\n\t    echo \"test 7b: $COUNT scatterlists, variable size/bigger entries\"\n\t    do_test -t 7 -v 41\n\t    BUFLEN=64\n\t    echo \"test 7c: $COUNT scatterlists, variable size/micro entries\"\n\t    do_test -t 7 -v 63\n\t    ;;\n\n\tiso-out)\n\t    check_config sink-src\n\t    echo '** Host ISOCHRONOUS Write (OUT) test cases:'\n\n\t    # at peak iso transfer rates:\n\t    # - usb 2.0 high bandwidth, this is one frame.\n\t    # - usb 1.1, it's twenty-four frames.\n\t    BUFLEN=24500\n\n\t    COUNT=1000\n\n# COUNT=10000\n\n\t    echo \"test 15: $COUNT transfers, same size\"\n\t    # do_test -t 15 -g 3 -v 0\n\t    BUFLEN=32768\n\t    do_test -t 15 -g 8 -v 0\n\n\t    # FIXME it'd make sense to have an iso OUT test issuing\n\t    # short writes on more packets than the last one\n\n\t    COUNT=100\n\t    echo \"test 22: $COUNT transfers, non aligned\"\n\t    do_test -t 22 -g 8 -v 0\n\n\t    ;;\n\n\tin)\n\t    check_config sink-src\n\t    echo '** Host Read (IN) test cases:'\n\n\t    # NOTE:  these \"variable size\" reads are just multiples\n\t    # of 512 bytes, no EOVERFLOW testing is done yet\n\n\t    echo \"test 2: $COUNT transfers, same size\"\n\t    do_test -t 2\n\t    echo \"test 4: $COUNT transfers, variable size\"\n\t    do_test -t 4\n\n\t    COUNT=100\n\t    echo \"test 18: $COUNT transfers, unaligned DMA map by core\"\n\t    do_test -t 18\n\n\t    echo \"test 20: $COUNT transfers, unaligned DMA map by usb_alloc_coherent\"\n\t    do_test -t 20\n\n\t    COUNT=2000\n\t    echo \"test 6: $COUNT scatterlists, same size entries\"\n\t    do_test -t 6\n\t    echo \"test 8: $COUNT scatterlists, variable size entries\"\n\t    do_test -t 8\n\t    ;;\n\n\tiso-in)\n\t    check_config sink-src\n\t    echo '** Host ISOCHRONOUS Read (IN) test cases:'\n\n\t    # at peak iso transfer rates:\n\t    # - usb 2.0 high bandwidth, this is one frame.\n\t    # - usb 1.1, it's twenty-four frames.\n\t    BUFLEN=24500\n\n\t    COUNT=1000\n\n# COUNT=10000\n\n\t    echo \"test 16: $COUNT transfers, same size\"\n\t    # do_test -t 16 -g 3 -v 0\n\t    BUFLEN=32768\n\t    do_test -t 16 -g 8 -v 0\n\n\t    # FIXME since iso expects faults, it'd make sense\n\t    # to have an iso IN test issuing short reads ...\n\n\t    COUNT=100\n\t    echo \"test 23: $COUNT transfers, unaligned\"\n\t    do_test -t 23 -g 8 -v 0\n\n\t    ;;\n\n\thalt)\n\t    # NOTE:  sometimes hardware doesn't cooperate well with halting\n\t    # endpoints from the host side.  so long as mass-storage class\n\t    # firmware can halt them from the device, don't worry much if\n\t    # you can't make this test work on your device.\n\t    COUNT=2000\n\t    echo \"test 13: $COUNT halt set/clear\"\n\t    do_test -t 13\n\t    ;;\n\n\tunlink)\n\t    COUNT=2000\n\t    echo \"test 11: $COUNT read unlinks\"\n\t    do_test -t 11\n\n\t    echo \"test 12: $COUNT write unlinks\"\n\t    do_test -t 12\n\t    ;;\n\n\tloop)\n\t    # defaults need too much buffering for ez-usb devices\n\t    BUFLEN=2048\n\t    COUNT=32\n\n\t    # modprobe g_zero qlen=$COUNT buflen=$BUFLEN loopdefault\n\t    check_config loopback\n\n\t    # FIXME someone needs to write and merge a version of this\n\n\t    echo \"write $COUNT buffers of $BUFLEN bytes, read them back\"\n\n\t    echo \"write $COUNT variable size buffers, read them back\"\n\n\t    ;;\n\n\t*)\n\t    echo \"Don't understand test type $TYPE\"\n\t    exit 1;\n\tesac\n\techo ''\n    done\ndone\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}