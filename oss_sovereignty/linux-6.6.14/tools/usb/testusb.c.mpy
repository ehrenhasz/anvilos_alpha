{
  "module_name": "testusb.c",
  "hash_id": "3242b33fb3b43c783656a85e41e2657087c7ba44da43b9f9c7760266dddcc815",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/testusb.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <stdio.h>\n#include <string.h>\n#include <ftw.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <errno.h>\n#include <limits.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include <sys/ioctl.h>\n#include <linux/usbdevice_fs.h>\n\n \n\n#define\tTEST_CASES\t30\n\n\n\nstruct usbtest_param {\n\t\n\tunsigned\t\ttest_num;\t \n\tunsigned\t\titerations;\n\tunsigned\t\tlength;\n\tunsigned\t\tvary;\n\tunsigned\t\tsglen;\n\n\t\n\tstruct timeval\t\tduration;\n};\n#define USBTEST_REQUEST\t_IOWR('U', 100, struct usbtest_param)\n\n \n\n \n\n#define USB_DT_DEVICE\t\t\t0x01\n#define USB_DT_INTERFACE\t\t0x04\n\n#define USB_CLASS_PER_INTERFACE\t\t0\t \n#define USB_CLASS_VENDOR_SPEC\t\t0xff\n\n\nstruct usb_device_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u16 bcdUSB;\n\t__u8  bDeviceClass;\n\t__u8  bDeviceSubClass;\n\t__u8  bDeviceProtocol;\n\t__u8  bMaxPacketSize0;\n\t__u16 idVendor;\n\t__u16 idProduct;\n\t__u16 bcdDevice;\n\t__u8  iManufacturer;\n\t__u8  iProduct;\n\t__u8  iSerialNumber;\n\t__u8  bNumConfigurations;\n} __attribute__ ((packed));\n\nstruct usb_interface_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bInterfaceNumber;\n\t__u8  bAlternateSetting;\n\t__u8  bNumEndpoints;\n\t__u8  bInterfaceClass;\n\t__u8  bInterfaceSubClass;\n\t__u8  bInterfaceProtocol;\n\t__u8  iInterface;\n} __attribute__ ((packed));\n\nenum usb_device_speed {\n\tUSB_SPEED_UNKNOWN = 0,\t\t\t \n\tUSB_SPEED_LOW, USB_SPEED_FULL,\t\t \n\tUSB_SPEED_HIGH,\t\t\t\t \n\tUSB_SPEED_WIRELESS,\t\t\t \n\tUSB_SPEED_SUPER,\t\t\t \n\tUSB_SPEED_SUPER_PLUS,\t\t\t \n};\n\n \n\nstatic char *speed (enum usb_device_speed s)\n{\n\tswitch (s) {\n\tcase USB_SPEED_UNKNOWN:\t\treturn \"unknown\";\n\tcase USB_SPEED_LOW:\t\treturn \"low\";\n\tcase USB_SPEED_FULL:\t\treturn \"full\";\n\tcase USB_SPEED_HIGH:\t\treturn \"high\";\n\tcase USB_SPEED_WIRELESS:\treturn \"wireless\";\n\tcase USB_SPEED_SUPER:\t\treturn \"super\";\n\tcase USB_SPEED_SUPER_PLUS:\treturn \"super-plus\";\n\tdefault:\t\t\treturn \"??\";\n\t}\n}\n\nstruct testdev {\n\tstruct testdev\t\t*next;\n\tchar\t\t\t*name;\n\tpthread_t\t\tthread;\n\tenum usb_device_speed\tspeed;\n\tunsigned\t\tifnum : 8;\n\tunsigned\t\tforever : 1;\n\tint\t\t\ttest;\n\n\tstruct usbtest_param\tparam;\n};\nstatic struct testdev\t\t*testdevs;\n\nstatic int testdev_ffs_ifnum(FILE *fd)\n{\n\tunion {\n\t\tchar buf[255];\n\t\tstruct usb_interface_descriptor intf;\n\t} u;\n\n\tfor (;;) {\n\t\tif (fread(u.buf, 1, 1, fd) != 1)\n\t\t\treturn -1;\n\t\tif (fread(u.buf + 1, (unsigned char)u.buf[0] - 1, 1, fd) != 1)\n\t\t\treturn -1;\n\n\t\tif (u.intf.bLength == sizeof u.intf\n\t\t && u.intf.bDescriptorType == USB_DT_INTERFACE\n\t\t && u.intf.bNumEndpoints == 2\n\t\t && u.intf.bInterfaceClass == USB_CLASS_VENDOR_SPEC\n\t\t && u.intf.bInterfaceSubClass == 0\n\t\t && u.intf.bInterfaceProtocol == 0)\n\t\t\treturn (unsigned char)u.intf.bInterfaceNumber;\n\t}\n}\n\nstatic int testdev_ifnum(FILE *fd)\n{\n\tstruct usb_device_descriptor dev;\n\n\tif (fread(&dev, sizeof dev, 1, fd) != 1)\n\t\treturn -1;\n\n\tif (dev.bLength != sizeof dev || dev.bDescriptorType != USB_DT_DEVICE)\n\t\treturn -1;\n\n\t \n\tif (dev.idVendor == 0x0547 && dev.idProduct == 0x1002)\n\t\treturn 0;\n\n\t \n\n\t \n\n\t \n\tif (dev.idVendor == 0x0547 && dev.idProduct == 0x2235)\n\t\treturn 0;\n\n\t \n\tif (dev.idVendor == 0x04b4 && dev.idProduct == 0x8613)\n\t\treturn 0;\n\n\t \n\tif (dev.idVendor == 0x0547 && dev.idProduct == 0x0080)\n\t\treturn 0;\n\n\t \n\tif (dev.idVendor == 0x06cd && dev.idProduct == 0x010b)\n\t\treturn 0;\n\n\t \n\n\t \n\tif (dev.idVendor == 0x0525 && dev.idProduct == 0xa4a0)\n\t\treturn 0;\n\n\t \n\tif (dev.idVendor == 0x0525 && dev.idProduct == 0xa4a4)\n\t\treturn testdev_ffs_ifnum(fd);\n\t\t \n\n\t \n\tif (dev.idVendor == 0x0525 && dev.idProduct == 0xa4a3)\n\t\treturn 0;\n\n\t \n\n\tif (dev.idVendor == 0xfff0 && dev.idProduct == 0xfff0)\n\t\treturn 0;\n\n\t \n\n\t \n\tif (dev.idVendor == 0x0b62 && dev.idProduct == 0x0059)\n\t\treturn 0;\n\n\t \n\n\t \n\n\tif (dev.idVendor == 0x0525 && dev.idProduct == 0xa4ac\n\t && (dev.bDeviceClass == USB_CLASS_PER_INTERFACE\n\t  || dev.bDeviceClass == USB_CLASS_VENDOR_SPEC))\n\t\treturn testdev_ffs_ifnum(fd);\n\n\treturn -1;\n}\n\nstatic int find_testdev(const char *name, const struct stat *sb, int flag)\n{\n\tFILE\t\t\t\t*fd;\n\tint\t\t\t\tifnum;\n\tstruct testdev\t\t\t*entry;\n\n\t(void)sb;  \n\n\tif (flag != FTW_F)\n\t\treturn 0;\n\n\tfd = fopen(name, \"rb\");\n\tif (!fd) {\n\t\tperror(name);\n\t\treturn 0;\n\t}\n\n\tifnum = testdev_ifnum(fd);\n\tfclose(fd);\n\tif (ifnum < 0)\n\t\treturn 0;\n\n\tentry = calloc(1, sizeof *entry);\n\tif (!entry)\n\t\tgoto nomem;\n\n\tentry->name = strdup(name);\n\tif (!entry->name) {\n\t\tfree(entry);\nnomem:\n\t\tperror(\"malloc\");\n\t\treturn 0;\n\t}\n\n\tentry->ifnum = ifnum;\n\tentry->next = testdevs;\n\ttestdevs = entry;\n\treturn 0;\n}\n\nstatic int\nusbdev_ioctl (int fd, int ifno, unsigned request, void *param)\n{\n\tstruct usbdevfs_ioctl\twrapper;\n\n\twrapper.ifno = ifno;\n\twrapper.ioctl_code = request;\n\twrapper.data = param;\n\n\treturn ioctl (fd, USBDEVFS_IOCTL, &wrapper);\n}\n\nstatic void *handle_testdev (void *arg)\n{\n\tstruct testdev\t\t*dev = arg;\n\tint\t\t\tfd, i;\n\tint\t\t\tstatus;\n\n\tif ((fd = open (dev->name, O_RDWR)) < 0) {\n\t\tperror (\"can't open dev file r/w\");\n\t\treturn 0;\n\t}\n\n\tstatus  =  ioctl(fd, USBDEVFS_GET_SPEED, NULL);\n\tif (status < 0)\n\t\tfprintf(stderr, \"USBDEVFS_GET_SPEED failed %d\\n\", status);\n\telse\n\t\tdev->speed = status;\n\tfprintf(stderr, \"%s speed\\t%s\\t%u\\n\",\n\t\t\tspeed(dev->speed), dev->name, dev->ifnum);\n\nrestart:\n\tfor (i = 0; i < TEST_CASES; i++) {\n\t\tif (dev->test != -1 && dev->test != i)\n\t\t\tcontinue;\n\t\tdev->param.test_num = i;\n\n\t\tstatus = usbdev_ioctl (fd, dev->ifnum,\n\t\t\t\tUSBTEST_REQUEST, &dev->param);\n\t\tif (status < 0 && errno == EOPNOTSUPP)\n\t\t\tcontinue;\n\n\t\t \n\n\t\t \n\t\tif (status < 0) {\n\t\t\tchar\tbuf [80];\n\t\t\tint\terr = errno;\n\n\t\t\tif (strerror_r (errno, buf, sizeof buf)) {\n\t\t\t\tsnprintf (buf, sizeof buf, \"error %d\", err);\n\t\t\t\terrno = err;\n\t\t\t}\n\t\t\tprintf (\"%s test %d --> %d (%s)\\n\",\n\t\t\t\tdev->name, i, errno, buf);\n\t\t} else\n\t\t\tprintf (\"%s test %d, %4d.%.06d secs\\n\", dev->name, i,\n\t\t\t\t(int) dev->param.duration.tv_sec,\n\t\t\t\t(int) dev->param.duration.tv_usec);\n\n\t\tfflush (stdout);\n\t}\n\tif (dev->forever)\n\t\tgoto restart;\n\n\tclose (fd);\n\treturn arg;\n}\n\nstatic const char *usb_dir_find(void)\n{\n\tstatic char udev_usb_path[] = \"/dev/bus/usb\";\n\n\tif (access(udev_usb_path, F_OK) == 0)\n\t\treturn udev_usb_path;\n\n\treturn NULL;\n}\n\nstatic int parse_num(unsigned *num, const char *str)\n{\n\tunsigned long val;\n\tchar *end;\n\n\terrno = 0;\n\tval = strtoul(str, &end, 0);\n\tif (errno || *end || val > UINT_MAX)\n\t\treturn -1;\n\t*num = val;\n\treturn 0;\n}\n\nint main (int argc, char **argv)\n{\n\n\tint\t\t\tc;\n\tstruct testdev\t\t*entry;\n\tchar\t\t\t*device;\n\tconst char\t\t*usb_dir = NULL;\n\tint\t\t\tall = 0, forever = 0, not = 0;\n\tint\t\t\ttest = -1  ;\n\tstruct usbtest_param\tparam;\n\n\t \n\tparam.iterations = 1000;\n\tparam.length = 1024;\n\tparam.vary = 1024;\n\tparam.sglen = 32;\n\n\t \n\tdevice = getenv (\"DEVICE\");\n\n\twhile ((c = getopt (argc, argv, \"D:aA:c:g:hlns:t:v:\")) != EOF)\n\tswitch (c) {\n\tcase 'D':\t \n\t\tdevice = optarg;\n\t\tcontinue;\n\tcase 'A':\t \n\t\tusb_dir = optarg;\n\t\t \n\tcase 'a':\t \n\t\tdevice = NULL;\n\t\tall = 1;\n\t\tcontinue;\n\tcase 'c':\t \n\t\tif (parse_num(&param.iterations, optarg))\n\t\t\tgoto usage;\n\t\tcontinue;\n\tcase 'g':\t \n\t\tif (parse_num(&param.sglen, optarg))\n\t\t\tgoto usage;\n\t\tcontinue;\n\tcase 'l':\t \n\t\tforever = 1;\n\t\tcontinue;\n\tcase 'n':\t \n\t\tnot = 1;\n\t\tcontinue;\n\tcase 's':\t \n\t\tif (parse_num(&param.length, optarg))\n\t\t\tgoto usage;\n\t\tcontinue;\n\tcase 't':\t \n\t\ttest = atoi (optarg);\n\t\tif (test < 0)\n\t\t\tgoto usage;\n\t\tcontinue;\n\tcase 'v':\t \n\t\tif (parse_num(&param.vary, optarg))\n\t\t\tgoto usage;\n\t\tcontinue;\n\tcase '?':\n\tcase 'h':\n\tdefault:\nusage:\n\t\tfprintf (stderr,\n\t\t\t\"usage: %s [options]\\n\"\n\t\t\t\"Options:\\n\"\n\t\t\t\"\\t-D dev\t\tonly test specific device\\n\"\n\t\t\t\"\\t-A usb-dir\\n\"\n\t\t\t\"\\t-a\t\ttest all recognized devices\\n\"\n\t\t\t\"\\t-l\t\tloop forever(for stress test)\\n\"\n\t\t\t\"\\t-t testnum\tonly run specified case\\n\"\n\t\t\t\"\\t-n\t\tno test running, show devices to be tested\\n\"\n\t\t\t\"Case arguments:\\n\"\n\t\t\t\"\\t-c iterations\t\tdefault 1000\\n\"\n\t\t\t\"\\t-s transfer length\tdefault 1024\\n\"\n\t\t\t\"\\t-g sglen\t\tdefault 32\\n\"\n\t\t\t\"\\t-v vary\t\t\tdefault 1024\\n\",\n\t\t\targv[0]);\n\t\treturn 1;\n\t}\n\tif (optind != argc)\n\t\tgoto usage;\n\tif (!all && !device) {\n\t\tfprintf (stderr, \"must specify '-a' or '-D dev', \"\n\t\t\t\"or DEVICE=/dev/bus/usb/BBB/DDD in env\\n\");\n\t\tgoto usage;\n\t}\n\n\t \n\tif (!usb_dir) {\n\t\tusb_dir = usb_dir_find();\n\t\tif (!usb_dir) {\n\t\t\tfputs (\"USB device files are missing\\n\", stderr);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif (ftw (usb_dir, find_testdev, 3) != 0) {\n\t\tfputs (\"ftw failed; are USB device files missing?\\n\", stderr);\n\t\treturn -1;\n\t}\n\n\t \n\tif (!testdevs && !device) {\n\t\tfputs (\"no test devices recognized\\n\", stderr);\n\t\treturn -1;\n\t}\n\tif (not)\n\t\treturn 0;\n\tif (testdevs && !testdevs->next && !device)\n\t\tdevice = testdevs->name;\n\tfor (entry = testdevs; entry; entry = entry->next) {\n\t\tint\tstatus;\n\n\t\tentry->param = param;\n\t\tentry->forever = forever;\n\t\tentry->test = test;\n\n\t\tif (device) {\n\t\t\tif (strcmp (entry->name, device))\n\t\t\t\tcontinue;\n\t\t\treturn handle_testdev (entry) != entry;\n\t\t}\n\t\tstatus = pthread_create (&entry->thread, 0, handle_testdev, entry);\n\t\tif (status)\n\t\t\tperror (\"pthread_create\");\n\t}\n\tif (device) {\n\t\tstruct testdev\t\tdev;\n\n\t\t \n\t\tfprintf (stderr, \"%s: %s may see only control tests\\n\",\n\t\t\t\targv [0], device);\n\n\t\tmemset (&dev, 0, sizeof dev);\n\t\tdev.name = device;\n\t\tdev.param = param;\n\t\tdev.forever = forever;\n\t\tdev.test = test;\n\t\treturn handle_testdev (&dev) != &dev;\n\t}\n\n\t \n\tfor (entry = testdevs; entry; entry = entry->next) {\n\t\tvoid\t*retval;\n\n\t\tif (pthread_join (entry->thread, &retval))\n\t\t\tperror (\"pthread_join\");\n\t\t \n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}