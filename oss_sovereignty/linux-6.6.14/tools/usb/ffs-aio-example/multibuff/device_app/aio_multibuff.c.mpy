{
  "module_name": "aio_multibuff.c",
  "hash_id": "06303839c198aa3d627f88432ee238711d8409f40fb4eb2d2c8b4bc14cb41f86",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/ffs-aio-example/multibuff/device_app/aio_multibuff.c",
  "human_readable_source": " \n\n#define _BSD_SOURCE  \n\n#include <endian.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/poll.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <sys/eventfd.h>\n\n#include \"libaio.h\"\n#define IOCB_FLAG_RESFD         (1 << 0)\n\n#include <linux/usb/functionfs.h>\n\n#define BUF_LEN\t\t8192\n#define BUFS_MAX\t128\n#define AIO_MAX\t\t(BUFS_MAX*2)\n\n \n\nstatic const struct {\n\tstruct usb_functionfs_descs_head_v2 header;\n\t__le32 fs_count;\n\t__le32 hs_count;\n\tstruct {\n\t\tstruct usb_interface_descriptor intf;\n\t\tstruct usb_endpoint_descriptor_no_audio bulk_sink;\n\t\tstruct usb_endpoint_descriptor_no_audio bulk_source;\n\t} __attribute__ ((__packed__)) fs_descs, hs_descs;\n} __attribute__ ((__packed__)) descriptors = {\n\t.header = {\n\t\t.magic = htole32(FUNCTIONFS_DESCRIPTORS_MAGIC_V2),\n\t\t.flags = htole32(FUNCTIONFS_HAS_FS_DESC |\n\t\t\t\t     FUNCTIONFS_HAS_HS_DESC),\n\t\t.length = htole32(sizeof(descriptors)),\n\t},\n\t.fs_count = htole32(3),\n\t.fs_descs = {\n\t\t.intf = {\n\t\t\t.bLength = sizeof(descriptors.fs_descs.intf),\n\t\t\t.bDescriptorType = USB_DT_INTERFACE,\n\t\t\t.bNumEndpoints = 2,\n\t\t\t.bInterfaceClass = USB_CLASS_VENDOR_SPEC,\n\t\t\t.iInterface = 1,\n\t\t},\n\t\t.bulk_sink = {\n\t\t\t.bLength = sizeof(descriptors.fs_descs.bulk_sink),\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 1 | USB_DIR_IN,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t},\n\t\t.bulk_source = {\n\t\t\t.bLength = sizeof(descriptors.fs_descs.bulk_source),\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 2 | USB_DIR_OUT,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t},\n\t},\n\t.hs_count = htole32(3),\n\t.hs_descs = {\n\t\t.intf = {\n\t\t\t.bLength = sizeof(descriptors.hs_descs.intf),\n\t\t\t.bDescriptorType = USB_DT_INTERFACE,\n\t\t\t.bNumEndpoints = 2,\n\t\t\t.bInterfaceClass = USB_CLASS_VENDOR_SPEC,\n\t\t\t.iInterface = 1,\n\t\t},\n\t\t.bulk_sink = {\n\t\t\t.bLength = sizeof(descriptors.hs_descs.bulk_sink),\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 1 | USB_DIR_IN,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t.wMaxPacketSize = htole16(512),\n\t\t},\n\t\t.bulk_source = {\n\t\t\t.bLength = sizeof(descriptors.hs_descs.bulk_source),\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 2 | USB_DIR_OUT,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t.wMaxPacketSize = htole16(512),\n\t\t},\n\t},\n};\n\n#define STR_INTERFACE \"AIO Test\"\n\nstatic const struct {\n\tstruct usb_functionfs_strings_head header;\n\tstruct {\n\t\t__le16 code;\n\t\tconst char str1[sizeof(STR_INTERFACE)];\n\t} __attribute__ ((__packed__)) lang0;\n} __attribute__ ((__packed__)) strings = {\n\t.header = {\n\t\t.magic = htole32(FUNCTIONFS_STRINGS_MAGIC),\n\t\t.length = htole32(sizeof(strings)),\n\t\t.str_count = htole32(1),\n\t\t.lang_count = htole32(1),\n\t},\n\t.lang0 = {\n\t\thtole16(0x0409),  \n\t\tSTR_INTERFACE,\n\t},\n};\n\n \n\nstruct io_buffer {\n\tstruct iocb **iocb;\n\tunsigned char **buf;\n\tunsigned cnt;\n\tunsigned len;\n\tunsigned requested;\n};\n\n \n\nstatic void display_event(struct usb_functionfs_event *event)\n{\n\tstatic const char *const names[] = {\n\t\t[FUNCTIONFS_BIND] = \"BIND\",\n\t\t[FUNCTIONFS_UNBIND] = \"UNBIND\",\n\t\t[FUNCTIONFS_ENABLE] = \"ENABLE\",\n\t\t[FUNCTIONFS_DISABLE] = \"DISABLE\",\n\t\t[FUNCTIONFS_SETUP] = \"SETUP\",\n\t\t[FUNCTIONFS_SUSPEND] = \"SUSPEND\",\n\t\t[FUNCTIONFS_RESUME] = \"RESUME\",\n\t};\n\tswitch (event->type) {\n\tcase FUNCTIONFS_BIND:\n\tcase FUNCTIONFS_UNBIND:\n\tcase FUNCTIONFS_ENABLE:\n\tcase FUNCTIONFS_DISABLE:\n\tcase FUNCTIONFS_SETUP:\n\tcase FUNCTIONFS_SUSPEND:\n\tcase FUNCTIONFS_RESUME:\n\t\tprintf(\"Event %s\\n\", names[event->type]);\n\t}\n}\n\nstatic void handle_ep0(int ep0, bool *ready)\n{\n\tint ret;\n\tstruct usb_functionfs_event event;\n\n\tret = read(ep0, &event, sizeof(event));\n\tif (!ret) {\n\t\tperror(\"unable to read event from ep0\");\n\t\treturn;\n\t}\n\tdisplay_event(&event);\n\tswitch (event.type) {\n\tcase FUNCTIONFS_SETUP:\n\t\tif (event.u.setup.bRequestType & USB_DIR_IN)\n\t\t\twrite(ep0, NULL, 0);\n\t\telse\n\t\t\tread(ep0, NULL, 0);\n\t\tbreak;\n\n\tcase FUNCTIONFS_ENABLE:\n\t\t*ready = true;\n\t\tbreak;\n\n\tcase FUNCTIONFS_DISABLE:\n\t\t*ready = false;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid init_bufs(struct io_buffer *iobuf, unsigned n, unsigned len)\n{\n\tunsigned i;\n\tiobuf->buf = malloc(n*sizeof(*iobuf->buf));\n\tiobuf->iocb = malloc(n*sizeof(*iobuf->iocb));\n\tiobuf->cnt = n;\n\tiobuf->len = len;\n\tiobuf->requested = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tiobuf->buf[i] = malloc(len*sizeof(**iobuf->buf));\n\t\tiobuf->iocb[i] = malloc(sizeof(**iobuf->iocb));\n\t}\n\tiobuf->cnt = n;\n}\n\nvoid delete_bufs(struct io_buffer *iobuf)\n{\n\tunsigned i;\n\tfor (i = 0; i < iobuf->cnt; ++i) {\n\t\tfree(iobuf->buf[i]);\n\t\tfree(iobuf->iocb[i]);\n\t}\n\tfree(iobuf->buf);\n\tfree(iobuf->iocb);\n}\n\nint main(int argc, char *argv[])\n{\n\tint ret;\n\tunsigned i, j;\n\tchar *ep_path;\n\n\tint ep0, ep1;\n\n\tio_context_t ctx;\n\n\tint evfd;\n\tfd_set rfds;\n\n\tstruct io_buffer iobuf[2];\n\tint actual = 0;\n\tbool ready;\n\n\tif (argc != 2) {\n\t\tprintf(\"ffs directory not specified!\\n\");\n\t\treturn 1;\n\t}\n\n\tep_path = malloc(strlen(argv[1]) + 4   + 1  );\n\tif (!ep_path) {\n\t\tperror(\"malloc\");\n\t\treturn 1;\n\t}\n\n\t \n\tsprintf(ep_path, \"%s/ep0\", argv[1]);\n\tep0 = open(ep_path, O_RDWR);\n\tif (ep0 < 0) {\n\t\tperror(\"unable to open ep0\");\n\t\treturn 1;\n\t}\n\tif (write(ep0, &descriptors, sizeof(descriptors)) < 0) {\n\t\tperror(\"unable do write descriptors\");\n\t\treturn 1;\n\t}\n\tif (write(ep0, &strings, sizeof(strings)) < 0) {\n\t\tperror(\"unable to write strings\");\n\t\treturn 1;\n\t}\n\tsprintf(ep_path, \"%s/ep1\", argv[1]);\n\tep1 = open(ep_path, O_RDWR);\n\tif (ep1 < 0) {\n\t\tperror(\"unable to open ep1\");\n\t\treturn 1;\n\t}\n\n\tfree(ep_path);\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\t \n\tif (io_setup(AIO_MAX, &ctx) < 0) {\n\t\tperror(\"unable to setup aio\");\n\t\treturn 1;\n\t}\n\n\tevfd = eventfd(0, 0);\n\tif (evfd < 0) {\n\t\tperror(\"unable to open eventfd\");\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < sizeof(iobuf)/sizeof(*iobuf); ++i)\n\t\tinit_bufs(&iobuf[i], BUFS_MAX, BUF_LEN);\n\n\twhile (1) {\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(ep0, &rfds);\n\t\tFD_SET(evfd, &rfds);\n\n\t\tret = select(((ep0 > evfd) ? ep0 : evfd)+1,\n\t\t\t     &rfds, NULL, NULL, NULL);\n\t\tif (ret < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tperror(\"select\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FD_ISSET(ep0, &rfds))\n\t\t\thandle_ep0(ep0, &ready);\n\n\t\t \n\t\tif (!ready)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (i = 0; i < sizeof(iobuf)/sizeof(*iobuf); ++i) {\n\t\t\tif (iobuf[i].requested)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tfor (j = 0; j < iobuf[i].cnt; ++j) {\n\t\t\t\tio_prep_pwrite(iobuf[i].iocb[j], ep1,\n\t\t\t\t\t       iobuf[i].buf[j],\n\t\t\t\t\t       iobuf[i].len, 0);\n\t\t\t\t \n\t\t\t\tiobuf[i].iocb[j]->u.c.flags |= IOCB_FLAG_RESFD;\n\t\t\t\tiobuf[i].iocb[j]->u.c.resfd = evfd;\n\t\t\t}\n\t\t\t \n\t\t\tret = io_submit(ctx, iobuf[i].cnt, iobuf[i].iocb);\n\t\t\tif (ret >= 0) {\n\t\t\t\tiobuf[i].requested = ret;\n\t\t\t\tprintf(\"submit: %d requests buf: %d\\n\", ret, i);\n\t\t\t} else\n\t\t\t\tperror(\"unable to submit requests\");\n\t\t}\n\n\t\t \n\t\tif (!FD_ISSET(evfd, &rfds))\n\t\t\tcontinue;\n\n\t\tuint64_t ev_cnt;\n\t\tret = read(evfd, &ev_cnt, sizeof(ev_cnt));\n\t\tif (ret < 0) {\n\t\t\tperror(\"unable to read eventfd\");\n\t\t\tbreak;\n\t\t}\n\n\t\tstruct io_event e[BUFS_MAX];\n\t\t \n\t\tret = io_getevents(ctx, 1, BUFS_MAX, e, NULL);\n\t\tif (ret > 0)  \n\t\t\tiobuf[actual].requested -= ret;\n\n\t\t \n\t\tif (!iobuf[actual].requested)\n\t\t\tactual = (actual + 1)%(sizeof(iobuf)/sizeof(*iobuf));\n\t}\n\n\t \n\n\tfor (i = 0; i < sizeof(iobuf)/sizeof(*iobuf); ++i)\n\t\tdelete_bufs(&iobuf[i]);\n\tio_destroy(ctx);\n\n\tclose(ep1);\n\tclose(ep0);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}