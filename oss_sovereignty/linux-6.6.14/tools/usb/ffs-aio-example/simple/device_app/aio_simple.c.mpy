{
  "module_name": "aio_simple.c",
  "hash_id": "9172ea9f37116da7c65f538bfd2b69b9f84735b2bf789fec3a9b28082f745b40",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/ffs-aio-example/simple/device_app/aio_simple.c",
  "human_readable_source": " \n\n \n\n#define _DEFAULT_SOURCE  \n\n#include <endian.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/poll.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <sys/eventfd.h>\n\n#include \"libaio.h\"\n#define IOCB_FLAG_RESFD         (1 << 0)\n\n#include <linux/usb/functionfs.h>\n\n#define BUF_LEN\t\t8192\n\n \n\n#if BYTE_ORDER == __LITTLE_ENDIAN\n#define cpu_to_le16(x)  (x)\n#define cpu_to_le32(x)  (x)\n#else\n#define cpu_to_le16(x)  ((((x) >> 8) & 0xffu) | (((x) & 0xffu) << 8))\n#define cpu_to_le32(x)  \\\n\t((((x) & 0xff000000u) >> 24) | (((x) & 0x00ff0000u) >>  8) | \\\n\t(((x) & 0x0000ff00u) <<  8) | (((x) & 0x000000ffu) << 24))\n#endif\n\n \n\nstatic const struct {\n\tstruct usb_functionfs_descs_head_v2 header;\n\t__le32 fs_count;\n\t__le32 hs_count;\n\tstruct {\n\t\tstruct usb_interface_descriptor intf;\n\t\tstruct usb_endpoint_descriptor_no_audio bulk_sink;\n\t\tstruct usb_endpoint_descriptor_no_audio bulk_source;\n\t} __attribute__ ((__packed__)) fs_descs, hs_descs;\n} __attribute__ ((__packed__)) descriptors = {\n\t.header = {\n\t\t.magic = cpu_to_le32(FUNCTIONFS_DESCRIPTORS_MAGIC_V2),\n\t\t.flags = cpu_to_le32(FUNCTIONFS_HAS_FS_DESC |\n\t\t\t\t     FUNCTIONFS_HAS_HS_DESC),\n\t\t.length = cpu_to_le32(sizeof(descriptors)),\n\t},\n\t.fs_count = cpu_to_le32(3),\n\t.fs_descs = {\n\t\t.intf = {\n\t\t\t.bLength = sizeof(descriptors.fs_descs.intf),\n\t\t\t.bDescriptorType = USB_DT_INTERFACE,\n\t\t\t.bNumEndpoints = 2,\n\t\t\t.bInterfaceClass = USB_CLASS_VENDOR_SPEC,\n\t\t\t.iInterface = 1,\n\t\t},\n\t\t.bulk_sink = {\n\t\t\t.bLength = sizeof(descriptors.fs_descs.bulk_sink),\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 1 | USB_DIR_IN,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t},\n\t\t.bulk_source = {\n\t\t\t.bLength = sizeof(descriptors.fs_descs.bulk_source),\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 2 | USB_DIR_OUT,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t},\n\t},\n\t.hs_count = cpu_to_le32(3),\n\t.hs_descs = {\n\t\t.intf = {\n\t\t\t.bLength = sizeof(descriptors.hs_descs.intf),\n\t\t\t.bDescriptorType = USB_DT_INTERFACE,\n\t\t\t.bNumEndpoints = 2,\n\t\t\t.bInterfaceClass = USB_CLASS_VENDOR_SPEC,\n\t\t\t.iInterface = 1,\n\t\t},\n\t\t.bulk_sink = {\n\t\t\t.bLength = sizeof(descriptors.hs_descs.bulk_sink),\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 1 | USB_DIR_IN,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t.wMaxPacketSize = cpu_to_le16(512),\n\t\t},\n\t\t.bulk_source = {\n\t\t\t.bLength = sizeof(descriptors.hs_descs.bulk_source),\n\t\t\t.bDescriptorType = USB_DT_ENDPOINT,\n\t\t\t.bEndpointAddress = 2 | USB_DIR_OUT,\n\t\t\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t\t\t.wMaxPacketSize = cpu_to_le16(512),\n\t\t},\n\t},\n};\n\n#define STR_INTERFACE \"AIO Test\"\n\nstatic const struct {\n\tstruct usb_functionfs_strings_head header;\n\tstruct {\n\t\t__le16 code;\n\t\tconst char str1[sizeof(STR_INTERFACE)];\n\t} __attribute__ ((__packed__)) lang0;\n} __attribute__ ((__packed__)) strings = {\n\t.header = {\n\t\t.magic = cpu_to_le32(FUNCTIONFS_STRINGS_MAGIC),\n\t\t.length = cpu_to_le32(sizeof(strings)),\n\t\t.str_count = cpu_to_le32(1),\n\t\t.lang_count = cpu_to_le32(1),\n\t},\n\t.lang0 = {\n\t\tcpu_to_le16(0x0409),  \n\t\tSTR_INTERFACE,\n\t},\n};\n\n \n\nstatic void display_event(struct usb_functionfs_event *event)\n{\n\tstatic const char *const names[] = {\n\t\t[FUNCTIONFS_BIND] = \"BIND\",\n\t\t[FUNCTIONFS_UNBIND] = \"UNBIND\",\n\t\t[FUNCTIONFS_ENABLE] = \"ENABLE\",\n\t\t[FUNCTIONFS_DISABLE] = \"DISABLE\",\n\t\t[FUNCTIONFS_SETUP] = \"SETUP\",\n\t\t[FUNCTIONFS_SUSPEND] = \"SUSPEND\",\n\t\t[FUNCTIONFS_RESUME] = \"RESUME\",\n\t};\n\tswitch (event->type) {\n\tcase FUNCTIONFS_BIND:\n\tcase FUNCTIONFS_UNBIND:\n\tcase FUNCTIONFS_ENABLE:\n\tcase FUNCTIONFS_DISABLE:\n\tcase FUNCTIONFS_SETUP:\n\tcase FUNCTIONFS_SUSPEND:\n\tcase FUNCTIONFS_RESUME:\n\t\tprintf(\"Event %s\\n\", names[event->type]);\n\t}\n}\n\nstatic void handle_ep0(int ep0, bool *ready)\n{\n\tstruct usb_functionfs_event event;\n\tint ret;\n\n\tstruct pollfd pfds[1];\n\tpfds[0].fd = ep0;\n\tpfds[0].events = POLLIN;\n\n\tret = poll(pfds, 1, 0);\n\n\tif (ret && (pfds[0].revents & POLLIN)) {\n\t\tret = read(ep0, &event, sizeof(event));\n\t\tif (!ret) {\n\t\t\tperror(\"unable to read event from ep0\");\n\t\t\treturn;\n\t\t}\n\t\tdisplay_event(&event);\n\t\tswitch (event.type) {\n\t\tcase FUNCTIONFS_SETUP:\n\t\t\tif (event.u.setup.bRequestType & USB_DIR_IN)\n\t\t\t\twrite(ep0, NULL, 0);\n\t\t\telse\n\t\t\t\tread(ep0, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase FUNCTIONFS_ENABLE:\n\t\t\t*ready = true;\n\t\t\tbreak;\n\n\t\tcase FUNCTIONFS_DISABLE:\n\t\t\t*ready = false;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint i, ret;\n\tchar *ep_path;\n\n\tint ep0;\n\tint ep[2];\n\n\tio_context_t ctx;\n\n\tint evfd;\n\tfd_set rfds;\n\n\tchar *buf_in, *buf_out;\n\tstruct iocb *iocb_in, *iocb_out;\n\tint req_in = 0, req_out = 0;\n\tbool ready;\n\n\tif (argc != 2) {\n\t\tprintf(\"ffs directory not specified!\\n\");\n\t\treturn 1;\n\t}\n\n\tep_path = malloc(strlen(argv[1]) + 4   + 1  );\n\tif (!ep_path) {\n\t\tperror(\"malloc\");\n\t\treturn 1;\n\t}\n\n\t \n\tsprintf(ep_path, \"%s/ep0\", argv[1]);\n\tep0 = open(ep_path, O_RDWR);\n\tif (ep0 < 0) {\n\t\tperror(\"unable to open ep0\");\n\t\treturn 1;\n\t}\n\tif (write(ep0, &descriptors, sizeof(descriptors)) < 0) {\n\t\tperror(\"unable do write descriptors\");\n\t\treturn 1;\n\t}\n\tif (write(ep0, &strings, sizeof(strings)) < 0) {\n\t\tperror(\"unable to write strings\");\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < 2; ++i) {\n\t\tsprintf(ep_path, \"%s/ep%d\", argv[1], i+1);\n\t\tep[i] = open(ep_path, O_RDWR);\n\t\tif (ep[i] < 0) {\n\t\t\tprintf(\"unable to open ep%d: %s\\n\", i+1,\n\t\t\t       strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(ep_path);\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\t \n\tif (io_setup(2, &ctx) < 0) {\n\t\tperror(\"unable to setup aio\");\n\t\treturn 1;\n\t}\n\n\tevfd = eventfd(0, 0);\n\tif (evfd < 0) {\n\t\tperror(\"unable to open eventfd\");\n\t\treturn 1;\n\t}\n\n\t \n\tbuf_in = malloc(BUF_LEN);\n\tbuf_out = malloc(BUF_LEN);\n\tiocb_in = malloc(sizeof(*iocb_in));\n\tiocb_out = malloc(sizeof(*iocb_out));\n\n\twhile (1) {\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(ep0, &rfds);\n\t\tFD_SET(evfd, &rfds);\n\n\t\tret = select(((ep0 > evfd) ? ep0 : evfd)+1,\n\t\t\t     &rfds, NULL, NULL, NULL);\n\t\tif (ret < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tperror(\"select\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (FD_ISSET(ep0, &rfds))\n\t\t\thandle_ep0(ep0, &ready);\n\n\t\t \n\t\tif (!ready)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (FD_ISSET(evfd, &rfds)) {\n\t\t\tuint64_t ev_cnt;\n\t\t\tret = read(evfd, &ev_cnt, sizeof(ev_cnt));\n\t\t\tif (ret < 0) {\n\t\t\t\tperror(\"unable to read eventfd\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstruct io_event e[2];\n\t\t\t \n\t\t\tret = io_getevents(ctx, 1, 2, e, NULL);\n\t\t\t \n\t\t\tfor (i = 0; i < ret; ++i) {\n\t\t\t\tif (e[i].obj->aio_fildes == ep[0]) {\n\t\t\t\t\tprintf(\"ev=in; ret=%lu\\n\", e[i].res);\n\t\t\t\t\treq_in = 0;\n\t\t\t\t} else if (e[i].obj->aio_fildes == ep[1]) {\n\t\t\t\t\tprintf(\"ev=out; ret=%lu\\n\", e[i].res);\n\t\t\t\t\treq_out = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!req_in) {  \n\t\t\t \n\t\t\tio_prep_pwrite(iocb_in, ep[0], buf_in, BUF_LEN, 0);\n\t\t\t \n\t\t\tiocb_in->u.c.flags |= IOCB_FLAG_RESFD;\n\t\t\tiocb_in->u.c.resfd = evfd;\n\t\t\t \n\t\t\tret = io_submit(ctx, 1, &iocb_in);\n\t\t\tif (ret >= 0) {  \n\t\t\t\treq_in = 1;\n\t\t\t\tprintf(\"submit: in\\n\");\n\t\t\t} else\n\t\t\t\tperror(\"unable to submit request\");\n\t\t}\n\t\tif (!req_out) {  \n\t\t\t \n\t\t\tio_prep_pread(iocb_out, ep[1], buf_out, BUF_LEN, 0);\n\t\t\t \n\t\t\tiocb_out->u.c.flags |= IOCB_FLAG_RESFD;\n\t\t\tiocb_out->u.c.resfd = evfd;\n\t\t\t \n\t\t\tret = io_submit(ctx, 1, &iocb_out);\n\t\t\tif (ret >= 0) {  \n\t\t\t\treq_out = 1;\n\t\t\t\tprintf(\"submit: out\\n\");\n\t\t\t} else\n\t\t\t\tperror(\"unable to submit request\");\n\t\t}\n\t}\n\n\t \n\n\tio_destroy(ctx);\n\n\tfree(buf_in);\n\tfree(buf_out);\n\tfree(iocb_in);\n\tfree(iocb_out);\n\n\tfor (i = 0; i < 2; ++i)\n\t\tclose(ep[i]);\n\tclose(ep0);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}