{
  "module_name": "test.c",
  "hash_id": "5b09f23fe75e80033a7d558bd5381e3378577c6fba171cedddbd6889d51c976d",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/ffs-aio-example/simple/host_app/test.c",
  "human_readable_source": " \n\n#include <libusb.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\n#define VENDOR\t0x1d6b\n#define PRODUCT\t0x0105\n\n#define BUF_LEN\t\t8192\n\n \n\nstruct test_state {\n\tlibusb_device *found;\n\tlibusb_context *ctx;\n\tlibusb_device_handle *handle;\n\tint attached;\n};\n\n \n\nint test_init(struct test_state *state)\n{\n\tint i, ret;\n\tssize_t cnt;\n\tlibusb_device **list;\n\n\tstate->found = NULL;\n\tstate->ctx = NULL;\n\tstate->handle = NULL;\n\tstate->attached = 0;\n\n\tret = libusb_init(&state->ctx);\n\tif (ret) {\n\t\tprintf(\"cannot init libusb: %s\\n\", libusb_error_name(ret));\n\t\treturn 1;\n\t}\n\n\tcnt = libusb_get_device_list(state->ctx, &list);\n\tif (cnt <= 0) {\n\t\tprintf(\"no devices found\\n\");\n\t\tgoto error1;\n\t}\n\n\tfor (i = 0; i < cnt; ++i) {\n\t\tlibusb_device *dev = list[i];\n\t\tstruct libusb_device_descriptor desc;\n\t\tret = libusb_get_device_descriptor(dev, &desc);\n\t\tif (ret) {\n\t\t\tprintf(\"unable to get device descriptor: %s\\n\",\n\t\t\t       libusb_error_name(ret));\n\t\t\tgoto error2;\n\t\t}\n\t\tif (desc.idVendor == VENDOR && desc.idProduct == PRODUCT) {\n\t\t\tstate->found = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!state->found) {\n\t\tprintf(\"no devices found\\n\");\n\t\tgoto error2;\n\t}\n\n\tret = libusb_open(state->found, &state->handle);\n\tif (ret) {\n\t\tprintf(\"cannot open device: %s\\n\", libusb_error_name(ret));\n\t\tgoto error2;\n\t}\n\n\tif (libusb_claim_interface(state->handle, 0)) {\n\t\tret = libusb_detach_kernel_driver(state->handle, 0);\n\t\tif (ret) {\n\t\t\tprintf(\"unable to detach kernel driver: %s\\n\",\n\t\t\t       libusb_error_name(ret));\n\t\t\tgoto error3;\n\t\t}\n\t\tstate->attached = 1;\n\t\tret = libusb_claim_interface(state->handle, 0);\n\t\tif (ret) {\n\t\t\tprintf(\"cannot claim interface: %s\\n\",\n\t\t\t       libusb_error_name(ret));\n\t\t\tgoto error4;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror4:\n\tif (state->attached == 1)\n\t\tlibusb_attach_kernel_driver(state->handle, 0);\n\nerror3:\n\tlibusb_close(state->handle);\n\nerror2:\n\tlibusb_free_device_list(list, 1);\n\nerror1:\n\tlibusb_exit(state->ctx);\n\treturn 1;\n}\n\n \n\nvoid test_exit(struct test_state *state)\n{\n\tlibusb_release_interface(state->handle, 0);\n\tif (state->attached == 1)\n\t\tlibusb_attach_kernel_driver(state->handle, 0);\n\tlibusb_close(state->handle);\n\tlibusb_exit(state->ctx);\n}\n\nint main(void)\n{\n\tstruct test_state state;\n\tstruct libusb_config_descriptor *conf;\n\tstruct libusb_interface_descriptor const *iface;\n\tunsigned char in_addr, out_addr;\n\n\tif (test_init(&state))\n\t\treturn 1;\n\n\tlibusb_get_config_descriptor(state.found, 0, &conf);\n\tiface = &conf->interface[0].altsetting[0];\n\tin_addr = iface->endpoint[0].bEndpointAddress;\n\tout_addr = iface->endpoint[1].bEndpointAddress;\n\n\twhile (1) {\n\t\tstatic unsigned char buffer[BUF_LEN];\n\t\tint bytes;\n\t\tlibusb_bulk_transfer(state.handle, in_addr, buffer, BUF_LEN,\n\t\t\t\t     &bytes, 500);\n\t\tlibusb_bulk_transfer(state.handle, out_addr, buffer, BUF_LEN,\n\t\t\t\t     &bytes, 500);\n\t}\n\ttest_exit(&state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}