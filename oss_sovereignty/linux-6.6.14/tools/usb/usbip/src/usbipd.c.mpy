{
  "module_name": "usbipd.c",
  "hash_id": "e62d81e07cbaaf5c77df4f6927a01374ec77807cc13a89359582b5323a07f0a8",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/src/usbipd.c",
  "human_readable_source": "\n \n\n#ifdef HAVE_CONFIG_H\n#include \"../config.h\"\n#endif\n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n#ifdef HAVE_LIBWRAP\n#include <tcpd.h>\n#endif\n\n#include <getopt.h>\n#include <signal.h>\n#include <poll.h>\n\n#include \"usbip_host_driver.h\"\n#include \"usbip_host_common.h\"\n#include \"usbip_device_driver.h\"\n#include \"usbip_common.h\"\n#include \"usbip_network.h\"\n#include \"list.h\"\n\n#undef  PROGNAME\n#define PROGNAME \"usbipd\"\n#define MAXSOCKFD 20\n\n#define MAIN_LOOP_TIMEOUT 10\n\n#define DEFAULT_PID_FILE \"/var/run/\" PROGNAME \".pid\"\n\nstatic const char usbip_version_string[] = PACKAGE_STRING;\n\nstatic const char usbipd_help_string[] =\n\t\"usage: usbipd [options]\\n\"\n\t\"\\n\"\n\t\"\t-4, --ipv4\\n\"\n\t\"\t\tBind to IPv4. Default is both.\\n\"\n\t\"\\n\"\n\t\"\t-6, --ipv6\\n\"\n\t\"\t\tBind to IPv6. Default is both.\\n\"\n\t\"\\n\"\n\t\"\t-e, --device\\n\"\n\t\"\t\tRun in device mode.\\n\"\n\t\"\t\tRather than drive an attached device, create\\n\"\n\t\"\t\ta virtual UDC to bind gadgets to.\\n\"\n\t\"\\n\"\n\t\"\t-D, --daemon\\n\"\n\t\"\t\tRun as a daemon process.\\n\"\n\t\"\\n\"\n\t\"\t-d, --debug\\n\"\n\t\"\t\tPrint debugging information.\\n\"\n\t\"\\n\"\n\t\"\t-PFILE, --pid FILE\\n\"\n\t\"\t\tWrite process id to FILE.\\n\"\n\t\"\t\tIf no FILE specified, use \" DEFAULT_PID_FILE \"\\n\"\n\t\"\\n\"\n\t\"\t-tPORT, --tcp-port PORT\\n\"\n\t\"\t\tListen on TCP/IP port PORT.\\n\"\n\t\"\\n\"\n\t\"\t-h, --help\\n\"\n\t\"\t\tPrint this help.\\n\"\n\t\"\\n\"\n\t\"\t-v, --version\\n\"\n\t\"\t\tShow version.\\n\";\n\nstatic struct usbip_host_driver *driver;\n\nstatic void usbipd_help(void)\n{\n\tprintf(\"%s\\n\", usbipd_help_string);\n}\n\nstatic int recv_request_import(int sockfd)\n{\n\tstruct op_import_request req;\n\tstruct usbip_exported_device *edev;\n\tstruct usbip_usb_device pdu_udev;\n\tstruct list_head *i;\n\tint found = 0;\n\tint status = ST_OK;\n\tint rc;\n\n\tmemset(&req, 0, sizeof(req));\n\n\trc = usbip_net_recv(sockfd, &req, sizeof(req));\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_recv failed: import request\");\n\t\treturn -1;\n\t}\n\tPACK_OP_IMPORT_REQUEST(0, &req);\n\n\tlist_for_each(i, &driver->edev_list) {\n\t\tedev = list_entry(i, struct usbip_exported_device, node);\n\t\tif (!strncmp(req.busid, edev->udev.busid, SYSFS_BUS_ID_SIZE)) {\n\t\t\tinfo(\"found requested device: %s\", req.busid);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\t \n\t\tusbip_net_set_nodelay(sockfd);\n\n\t\t \n\t\tstatus = usbip_export_device(edev, sockfd);\n\t\tif (status < 0)\n\t\t\tstatus = ST_NA;\n\t} else {\n\t\tinfo(\"requested device not found: %s\", req.busid);\n\t\tstatus = ST_NODEV;\n\t}\n\n\trc = usbip_net_send_op_common(sockfd, OP_REP_IMPORT, status);\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_send_op_common failed: %#0x\", OP_REP_IMPORT);\n\t\treturn -1;\n\t}\n\n\tif (status) {\n\t\tdbg(\"import request busid %s: failed\", req.busid);\n\t\treturn -1;\n\t}\n\n\tmemcpy(&pdu_udev, &edev->udev, sizeof(pdu_udev));\n\tusbip_net_pack_usb_device(1, &pdu_udev);\n\n\trc = usbip_net_send(sockfd, &pdu_udev, sizeof(pdu_udev));\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_send failed: devinfo\");\n\t\treturn -1;\n\t}\n\n\tdbg(\"import request busid %s: complete\", req.busid);\n\n\treturn 0;\n}\n\nstatic int send_reply_devlist(int connfd)\n{\n\tstruct usbip_exported_device *edev;\n\tstruct usbip_usb_device pdu_udev;\n\tstruct usbip_usb_interface pdu_uinf;\n\tstruct op_devlist_reply reply;\n\tstruct list_head *j;\n\tint rc, i;\n\n\t \n\n\treply.ndev = 0;\n\t \n\tlist_for_each(j, &driver->edev_list) {\n\t\tedev = list_entry(j, struct usbip_exported_device, node);\n\t\tif (edev->status != SDEV_ST_USED)\n\t\t\treply.ndev += 1;\n\t}\n\tinfo(\"exportable devices: %d\", reply.ndev);\n\n\trc = usbip_net_send_op_common(connfd, OP_REP_DEVLIST, ST_OK);\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_send_op_common failed: %#0x\", OP_REP_DEVLIST);\n\t\treturn -1;\n\t}\n\tPACK_OP_DEVLIST_REPLY(1, &reply);\n\n\trc = usbip_net_send(connfd, &reply, sizeof(reply));\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_send failed: %#0x\", OP_REP_DEVLIST);\n\t\treturn -1;\n\t}\n\n\tlist_for_each(j, &driver->edev_list) {\n\t\tedev = list_entry(j, struct usbip_exported_device, node);\n\t\tif (edev->status == SDEV_ST_USED)\n\t\t\tcontinue;\n\n\t\tdump_usb_device(&edev->udev);\n\t\tmemcpy(&pdu_udev, &edev->udev, sizeof(pdu_udev));\n\t\tusbip_net_pack_usb_device(1, &pdu_udev);\n\n\t\trc = usbip_net_send(connfd, &pdu_udev, sizeof(pdu_udev));\n\t\tif (rc < 0) {\n\t\t\tdbg(\"usbip_net_send failed: pdu_udev\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (i = 0; i < edev->udev.bNumInterfaces; i++) {\n\t\t\tdump_usb_interface(&edev->uinf[i]);\n\t\t\tmemcpy(&pdu_uinf, &edev->uinf[i], sizeof(pdu_uinf));\n\t\t\tusbip_net_pack_usb_interface(1, &pdu_uinf);\n\n\t\t\trc = usbip_net_send(connfd, &pdu_uinf,\n\t\t\t\t\tsizeof(pdu_uinf));\n\t\t\tif (rc < 0) {\n\t\t\t\terr(\"usbip_net_send failed: pdu_uinf\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int recv_request_devlist(int connfd)\n{\n\tstruct op_devlist_request req;\n\tint rc;\n\n\tmemset(&req, 0, sizeof(req));\n\n\trc = usbip_net_recv(connfd, &req, sizeof(req));\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_recv failed: devlist request\");\n\t\treturn -1;\n\t}\n\n\trc = send_reply_devlist(connfd);\n\tif (rc < 0) {\n\t\tdbg(\"send_reply_devlist failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int recv_pdu(int connfd)\n{\n\tuint16_t code = OP_UNSPEC;\n\tint ret;\n\tint status;\n\n\tret = usbip_net_recv_op_common(connfd, &code, &status);\n\tif (ret < 0) {\n\t\tdbg(\"could not receive opcode: %#0x\", code);\n\t\treturn -1;\n\t}\n\n\tret = usbip_refresh_device_list(driver);\n\tif (ret < 0) {\n\t\tdbg(\"could not refresh device list: %d\", ret);\n\t\treturn -1;\n\t}\n\n\tinfo(\"received request: %#0x(%d)\", code, connfd);\n\tswitch (code) {\n\tcase OP_REQ_DEVLIST:\n\t\tret = recv_request_devlist(connfd);\n\t\tbreak;\n\tcase OP_REQ_IMPORT:\n\t\tret = recv_request_import(connfd);\n\t\tbreak;\n\tcase OP_REQ_DEVINFO:\n\tcase OP_REQ_CRYPKEY:\n\tdefault:\n\t\terr(\"received an unknown opcode: %#0x\", code);\n\t\tret = -1;\n\t}\n\n\tif (ret == 0)\n\t\tinfo(\"request %#0x(%d): complete\", code, connfd);\n\telse\n\t\tinfo(\"request %#0x(%d): failed\", code, connfd);\n\n\treturn ret;\n}\n\n#ifdef HAVE_LIBWRAP\nstatic int tcpd_auth(int connfd)\n{\n\tstruct request_info request;\n\tint rc;\n\n\trequest_init(&request, RQ_DAEMON, PROGNAME, RQ_FILE, connfd, 0);\n\tfromhost(&request);\n\trc = hosts_access(&request);\n\tif (rc == 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n#endif\n\nstatic int do_accept(int listenfd)\n{\n\tint connfd;\n\tstruct sockaddr_storage ss;\n\tsocklen_t len = sizeof(ss);\n\tchar host[NI_MAXHOST], port[NI_MAXSERV];\n\tint rc;\n\n\tmemset(&ss, 0, sizeof(ss));\n\n\tconnfd = accept(listenfd, (struct sockaddr *)&ss, &len);\n\tif (connfd < 0) {\n\t\terr(\"failed to accept connection\");\n\t\treturn -1;\n\t}\n\n\trc = getnameinfo((struct sockaddr *)&ss, len, host, sizeof(host),\n\t\t\t port, sizeof(port), NI_NUMERICHOST | NI_NUMERICSERV);\n\tif (rc)\n\t\terr(\"getnameinfo: %s\", gai_strerror(rc));\n\n#ifdef HAVE_LIBWRAP\n\trc = tcpd_auth(connfd);\n\tif (rc < 0) {\n\t\tinfo(\"denied access from %s\", host);\n\t\tclose(connfd);\n\t\treturn -1;\n\t}\n#endif\n\tinfo(\"connection from %s:%s\", host, port);\n\n\treturn connfd;\n}\n\nint process_request(int listenfd)\n{\n\tpid_t childpid;\n\tint connfd;\n\n\tconnfd = do_accept(listenfd);\n\tif (connfd < 0)\n\t\treturn -1;\n\tchildpid = fork();\n\tif (childpid == 0) {\n\t\tclose(listenfd);\n\t\trecv_pdu(connfd);\n\t\texit(0);\n\t}\n\tclose(connfd);\n\treturn 0;\n}\n\nstatic void addrinfo_to_text(struct addrinfo *ai, char buf[],\n\t\t\t     const size_t buf_size)\n{\n\tchar hbuf[NI_MAXHOST];\n\tchar sbuf[NI_MAXSERV];\n\tint rc;\n\n\tbuf[0] = '\\0';\n\n\trc = getnameinfo(ai->ai_addr, ai->ai_addrlen, hbuf, sizeof(hbuf),\n\t\t\t sbuf, sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV);\n\tif (rc)\n\t\terr(\"getnameinfo: %s\", gai_strerror(rc));\n\n\tsnprintf(buf, buf_size, \"%s:%s\", hbuf, sbuf);\n}\n\nstatic int listen_all_addrinfo(struct addrinfo *ai_head, int sockfdlist[],\n\t\t\t     int maxsockfd)\n{\n\tstruct addrinfo *ai;\n\tint ret, nsockfd = 0;\n\tconst size_t ai_buf_size = NI_MAXHOST + NI_MAXSERV + 2;\n\tchar ai_buf[ai_buf_size];\n\n\tfor (ai = ai_head; ai && nsockfd < maxsockfd; ai = ai->ai_next) {\n\t\tint sock;\n\n\t\taddrinfo_to_text(ai, ai_buf, ai_buf_size);\n\t\tdbg(\"opening %s\", ai_buf);\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0) {\n\t\t\terr(\"socket: %s: %d (%s)\",\n\t\t\t    ai_buf, errno, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tusbip_net_set_reuseaddr(sock);\n\t\tusbip_net_set_nodelay(sock);\n\t\t \n\t\tusbip_net_set_v6only(sock);\n\n\t\tret = bind(sock, ai->ai_addr, ai->ai_addrlen);\n\t\tif (ret < 0) {\n\t\t\terr(\"bind: %s: %d (%s)\",\n\t\t\t    ai_buf, errno, strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = listen(sock, SOMAXCONN);\n\t\tif (ret < 0) {\n\t\t\terr(\"listen: %s: %d (%s)\",\n\t\t\t    ai_buf, errno, strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo(\"listening on %s\", ai_buf);\n\t\tsockfdlist[nsockfd++] = sock;\n\t}\n\n\treturn nsockfd;\n}\n\nstatic struct addrinfo *do_getaddrinfo(char *host, int ai_family)\n{\n\tstruct addrinfo hints, *ai_head;\n\tint rc;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family   = ai_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags    = AI_PASSIVE;\n\n\trc = getaddrinfo(host, usbip_port_string, &hints, &ai_head);\n\tif (rc) {\n\t\terr(\"failed to get a network address %s: %s\", usbip_port_string,\n\t\t    gai_strerror(rc));\n\t\treturn NULL;\n\t}\n\n\treturn ai_head;\n}\n\nstatic void signal_handler(int i)\n{\n\tdbg(\"received '%s' signal\", strsignal(i));\n}\n\nstatic void set_signal(void)\n{\n\tstruct sigaction act;\n\n\tmemset(&act, 0, sizeof(act));\n\tact.sa_handler = signal_handler;\n\tsigemptyset(&act.sa_mask);\n\tsigaction(SIGTERM, &act, NULL);\n\tsigaction(SIGINT, &act, NULL);\n\tact.sa_handler = SIG_IGN;\n\tsigaction(SIGCHLD, &act, NULL);\n}\n\nstatic const char *pid_file;\n\nstatic void write_pid_file(void)\n{\n\tif (pid_file) {\n\t\tdbg(\"creating pid file %s\", pid_file);\n\t\tFILE *fp;\n\n\t\tfp = fopen(pid_file, \"w\");\n\t\tif (!fp) {\n\t\t\terr(\"pid_file: %s: %d (%s)\",\n\t\t\t    pid_file, errno, strerror(errno));\n\t\t\treturn;\n\t\t}\n\t\tfprintf(fp, \"%d\\n\", getpid());\n\t\tfclose(fp);\n\t}\n}\n\nstatic void remove_pid_file(void)\n{\n\tif (pid_file) {\n\t\tdbg(\"removing pid file %s\", pid_file);\n\t\tunlink(pid_file);\n\t}\n}\n\nstatic int do_standalone_mode(int daemonize, int ipv4, int ipv6)\n{\n\tstruct addrinfo *ai_head;\n\tint sockfdlist[MAXSOCKFD];\n\tint nsockfd, family;\n\tint i, terminate;\n\tstruct pollfd *fds;\n\tstruct timespec timeout;\n\tsigset_t sigmask;\n\n\tif (usbip_driver_open(driver))\n\t\treturn -1;\n\n\tif (daemonize) {\n\t\tif (daemon(0, 0) < 0) {\n\t\t\terr(\"daemonizing failed: %s\", strerror(errno));\n\t\t\tusbip_driver_close(driver);\n\t\t\treturn -1;\n\t\t}\n\t\tumask(0);\n\t\tusbip_use_syslog = 1;\n\t}\n\tset_signal();\n\twrite_pid_file();\n\n\tinfo(\"starting \" PROGNAME \" (%s)\", usbip_version_string);\n\n\t \n\tif (ipv4 && ipv6)\n\t\tfamily = AF_UNSPEC;\n\telse if (ipv4)\n\t\tfamily = AF_INET;\n\telse\n\t\tfamily = AF_INET6;\n\n\tai_head = do_getaddrinfo(NULL, family);\n\tif (!ai_head) {\n\t\tusbip_driver_close(driver);\n\t\treturn -1;\n\t}\n\tnsockfd = listen_all_addrinfo(ai_head, sockfdlist,\n\t\tsizeof(sockfdlist) / sizeof(*sockfdlist));\n\tfreeaddrinfo(ai_head);\n\tif (nsockfd <= 0) {\n\t\terr(\"failed to open a listening socket\");\n\t\tusbip_driver_close(driver);\n\t\treturn -1;\n\t}\n\n\tdbg(\"listening on %d address%s\", nsockfd, (nsockfd == 1) ? \"\" : \"es\");\n\n\tfds = calloc(nsockfd, sizeof(struct pollfd));\n\tfor (i = 0; i < nsockfd; i++) {\n\t\tfds[i].fd = sockfdlist[i];\n\t\tfds[i].events = POLLIN;\n\t}\n\ttimeout.tv_sec = MAIN_LOOP_TIMEOUT;\n\ttimeout.tv_nsec = 0;\n\n\tsigfillset(&sigmask);\n\tsigdelset(&sigmask, SIGTERM);\n\tsigdelset(&sigmask, SIGINT);\n\n\tterminate = 0;\n\twhile (!terminate) {\n\t\tint r;\n\n\t\tr = ppoll(fds, nsockfd, &timeout, &sigmask);\n\t\tif (r < 0) {\n\t\t\tdbg(\"%s\", strerror(errno));\n\t\t\tterminate = 1;\n\t\t} else if (r) {\n\t\t\tfor (i = 0; i < nsockfd; i++) {\n\t\t\t\tif (fds[i].revents & POLLIN) {\n\t\t\t\t\tdbg(\"read event on fd[%d]=%d\",\n\t\t\t\t\t    i, sockfdlist[i]);\n\t\t\t\t\tprocess_request(sockfdlist[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdbg(\"heartbeat timeout on ppoll()\");\n\t\t}\n\t}\n\n\tinfo(\"shutting down \" PROGNAME);\n\tfree(fds);\n\tusbip_driver_close(driver);\n\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tstatic const struct option longopts[] = {\n\t\t{ \"ipv4\",     no_argument,       NULL, '4' },\n\t\t{ \"ipv6\",     no_argument,       NULL, '6' },\n\t\t{ \"daemon\",   no_argument,       NULL, 'D' },\n\t\t{ \"daemon\",   no_argument,       NULL, 'D' },\n\t\t{ \"debug\",    no_argument,       NULL, 'd' },\n\t\t{ \"device\",   no_argument,       NULL, 'e' },\n\t\t{ \"pid\",      optional_argument, NULL, 'P' },\n\t\t{ \"tcp-port\", required_argument, NULL, 't' },\n\t\t{ \"help\",     no_argument,       NULL, 'h' },\n\t\t{ \"version\",  no_argument,       NULL, 'v' },\n\t\t{ NULL,\t      0,                 NULL,  0  }\n\t};\n\n\tenum {\n\t\tcmd_standalone_mode = 1,\n\t\tcmd_help,\n\t\tcmd_version\n\t} cmd;\n\n\tint daemonize = 0;\n\tint ipv4 = 0, ipv6 = 0;\n\tint opt, rc = -1;\n\n\tpid_file = NULL;\n\n\tusbip_use_stderr = 1;\n\tusbip_use_syslog = 0;\n\n\tif (geteuid() != 0)\n\t\terr(\"not running as root?\");\n\n\tcmd = cmd_standalone_mode;\n\tdriver = &host_driver;\n\tfor (;;) {\n\t\topt = getopt_long(argc, argv, \"46DdeP::t:hv\", longopts, NULL);\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase '4':\n\t\t\tipv4 = 1;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tipv6 = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdaemonize = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tusbip_use_debug = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tcmd = cmd_help;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tpid_file = optarg ? optarg : DEFAULT_PID_FILE;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tusbip_setup_port_number(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcmd = cmd_version;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdriver = &device_driver;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusbipd_help();\n\t\tdefault:\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (!ipv4 && !ipv6)\n\t\tipv4 = ipv6 = 1;\n\n\tswitch (cmd) {\n\tcase cmd_standalone_mode:\n\t\trc = do_standalone_mode(daemonize, ipv4, ipv6);\n\t\tremove_pid_file();\n\t\tbreak;\n\tcase cmd_version:\n\t\tprintf(PROGNAME \" (%s)\\n\", usbip_version_string);\n\t\trc = 0;\n\t\tbreak;\n\tcase cmd_help:\n\t\tusbipd_help();\n\t\trc = 0;\n\t\tbreak;\n\tdefault:\n\t\tusbipd_help();\n\t\tgoto err_out;\n\t}\n\nerr_out:\n\treturn (rc > -1 ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}