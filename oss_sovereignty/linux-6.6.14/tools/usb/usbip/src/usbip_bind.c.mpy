{
  "module_name": "usbip_bind.c",
  "hash_id": "9098f2446251025d951e60ff7c189f11740f88e8d3af085ccf6987c701fa76b4",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/src/usbip_bind.c",
  "human_readable_source": "\n \n\n#include <libudev.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <getopt.h>\n\n#include \"usbip_common.h\"\n#include \"utils.h\"\n#include \"usbip.h\"\n#include \"sysfs_utils.h\"\n\nenum unbind_status {\n\tUNBIND_ST_OK,\n\tUNBIND_ST_USBIP_HOST,\n\tUNBIND_ST_FAILED\n};\n\nstatic const char usbip_bind_usage_string[] =\n\t\"usbip bind <args>\\n\"\n\t\"    -b, --busid=<busid>    Bind \" USBIP_HOST_DRV_NAME \".ko to device \"\n\t\"on <busid>\\n\";\n\nvoid usbip_bind_usage(void)\n{\n\tprintf(\"usage: %s\", usbip_bind_usage_string);\n}\n\n \nstatic int bind_usbip(char *busid)\n{\n\tchar attr_name[] = \"bind\";\n\tchar bind_attr_path[SYSFS_PATH_MAX];\n\tint rc = -1;\n\n\tsnprintf(bind_attr_path, sizeof(bind_attr_path), \"%s/%s/%s/%s/%s/%s\",\n\t\t SYSFS_MNT_PATH, SYSFS_BUS_NAME, SYSFS_BUS_TYPE,\n\t\t SYSFS_DRIVERS_NAME, USBIP_HOST_DRV_NAME, attr_name);\n\n\trc = write_sysfs_attribute(bind_attr_path, busid, strlen(busid));\n\tif (rc < 0) {\n\t\terr(\"error binding device %s to driver: %s\", busid,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int unbind_other(char *busid)\n{\n\tenum unbind_status status = UNBIND_ST_OK;\n\n\tchar attr_name[] = \"unbind\";\n\tchar unbind_attr_path[SYSFS_PATH_MAX];\n\tint rc = -1;\n\n\tstruct udev *udev;\n\tstruct udev_device *dev;\n\tconst char *driver;\n\tconst char *bDevClass;\n\n\t \n\tudev = udev_new();\n\n\t \n\tdev = udev_device_new_from_subsystem_sysname(udev, \"usb\", busid);\n\tif (!dev) {\n\t\tdbg(\"unable to find device with bus ID %s\", busid);\n\t\tgoto err_close_busid_dev;\n\t}\n\n\t \n\tbDevClass  = udev_device_get_sysattr_value(dev, \"bDeviceClass\");\n\tif (!bDevClass) {\n\t\tdbg(\"unable to get bDevClass device attribute\");\n\t\tgoto err_close_busid_dev;\n\t}\n\n\tif (!strncmp(bDevClass, \"09\", strlen(bDevClass))) {\n\t\tdbg(\"skip unbinding of hub\");\n\t\tgoto err_close_busid_dev;\n\t}\n\n\t \n\tdriver = udev_device_get_driver(dev);\n\tif (!driver) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (!strncmp(USBIP_HOST_DRV_NAME, driver,\n\t\t\t\tstrlen(USBIP_HOST_DRV_NAME))) {\n\t\t \n\t\tstatus = UNBIND_ST_USBIP_HOST;\n\t\tgoto out;\n\t}\n\n\t \n\tsnprintf(unbind_attr_path, sizeof(unbind_attr_path), \"%s/%s/%s/%s/%s/%s\",\n\t\t SYSFS_MNT_PATH, SYSFS_BUS_NAME, SYSFS_BUS_TYPE,\n\t\t SYSFS_DRIVERS_NAME, driver, attr_name);\n\n\trc = write_sysfs_attribute(unbind_attr_path, busid, strlen(busid));\n\tif (rc < 0) {\n\t\terr(\"error unbinding device %s from driver\", busid);\n\t\tgoto err_close_busid_dev;\n\t}\n\n\tgoto out;\n\nerr_close_busid_dev:\n\tstatus = UNBIND_ST_FAILED;\nout:\n\tudev_device_unref(dev);\n\tudev_unref(udev);\n\n\treturn status;\n}\n\nstatic int bind_device(char *busid)\n{\n\tint rc;\n\tstruct udev *udev;\n\tstruct udev_device *dev;\n\tconst char *devpath;\n\n\t \n\tudev = udev_new();\n\tdev = udev_device_new_from_subsystem_sysname(udev, \"usb\", busid);\n\tif (!dev) {\n\t\terr(\"device with the specified bus ID does not exist\");\n\t\treturn -1;\n\t}\n\tdevpath = udev_device_get_devpath(dev);\n\tudev_unref(udev);\n\n\t \n\tif (strstr(devpath, USBIP_VHCI_DRV_NAME)) {\n\t\terr(\"bind loop detected: device: %s is attached to %s\\n\",\n\t\t    devpath, USBIP_VHCI_DRV_NAME);\n\t\treturn -1;\n\t}\n\n\trc = unbind_other(busid);\n\tif (rc == UNBIND_ST_FAILED) {\n\t\terr(\"could not unbind driver from device on busid %s\", busid);\n\t\treturn -1;\n\t} else if (rc == UNBIND_ST_USBIP_HOST) {\n\t\terr(\"device on busid %s is already bound to %s\", busid,\n\t\t    USBIP_HOST_DRV_NAME);\n\t\treturn -1;\n\t}\n\n\trc = modify_match_busid(busid, 1);\n\tif (rc < 0) {\n\t\terr(\"unable to bind device on %s\", busid);\n\t\treturn -1;\n\t}\n\n\trc = bind_usbip(busid);\n\tif (rc < 0) {\n\t\terr(\"could not bind device to %s\", USBIP_HOST_DRV_NAME);\n\t\tmodify_match_busid(busid, 0);\n\t\treturn -1;\n\t}\n\n\tinfo(\"bind device on busid %s: complete\", busid);\n\n\treturn 0;\n}\n\nint usbip_bind(int argc, char *argv[])\n{\n\tstatic const struct option opts[] = {\n\t\t{ \"busid\", required_argument, NULL, 'b' },\n\t\t{ NULL,    0,                 NULL,  0  }\n\t};\n\n\tint opt;\n\tint ret = -1;\n\n\tfor (;;) {\n\t\topt = getopt_long(argc, argv, \"b:\", opts, NULL);\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\tret = bind_device(optarg);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\nerr_out:\n\tusbip_bind_usage();\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}