{
  "module_name": "usbip_detach.c",
  "hash_id": "7fd1c78c30641b3b28e6ba8b9725147f6ba01b205994bac111326e49705ceedb",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/src/usbip_detach.c",
  "human_readable_source": "\n \n\n#include <ctype.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <getopt.h>\n#include <unistd.h>\n\n#include \"vhci_driver.h\"\n#include \"usbip_common.h\"\n#include \"usbip_network.h\"\n#include \"usbip.h\"\n\nstatic const char usbip_detach_usage_string[] =\n\t\"usbip detach <args>\\n\"\n\t\"    -p, --port=<port>    \" USBIP_VHCI_DRV_NAME\n\t\" port the device is on\\n\";\n\nvoid usbip_detach_usage(void)\n{\n\tprintf(\"usage: %s\", usbip_detach_usage_string);\n}\n\nstatic int detach_port(char *port)\n{\n\tint ret = 0;\n\tuint8_t portnum;\n\tchar path[PATH_MAX+1];\n\tint i;\n\tstruct usbip_imported_device *idev;\n\tint found = 0;\n\n\tunsigned int port_len = strlen(port);\n\n\tfor (unsigned int i = 0; i < port_len; i++)\n\t\tif (!isdigit(port[i])) {\n\t\t\terr(\"invalid port %s\", port);\n\t\t\treturn -1;\n\t\t}\n\n\tportnum = atoi(port);\n\n\tret = usbip_vhci_driver_open();\n\tif (ret < 0) {\n\t\terr(\"open vhci_driver (is vhci_hcd loaded?)\");\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < vhci_driver->nports; i++) {\n\t\tidev = &vhci_driver->idev[i];\n\n\t\tif (idev->port == portnum) {\n\t\t\tfound = 1;\n\t\t\tif (idev->status != VDEV_ST_NULL)\n\t\t\t\tbreak;\n\t\t\tinfo(\"Port %d is already detached!\\n\", idev->port);\n\t\t\tgoto call_driver_close;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\terr(\"Invalid port %s > maxports %d\",\n\t\t\tport, vhci_driver->nports);\n\t\tgoto call_driver_close;\n\t}\n\n\t \n\tsnprintf(path, PATH_MAX, VHCI_STATE_PATH\"/port%d\", portnum);\n\n\tremove(path);\n\trmdir(VHCI_STATE_PATH);\n\n\tret = usbip_vhci_detach_device(portnum);\n\tif (ret < 0) {\n\t\tret = -1;\n\t\terr(\"Port %d detach request failed!\\n\", portnum);\n\t\tgoto call_driver_close;\n\t}\n\tinfo(\"Port %d is now detached!\\n\", portnum);\n\ncall_driver_close:\n\tusbip_vhci_driver_close();\n\n\treturn ret;\n}\n\nint usbip_detach(int argc, char *argv[])\n{\n\tstatic const struct option opts[] = {\n\t\t{ \"port\", required_argument, NULL, 'p' },\n\t\t{ NULL, 0, NULL, 0 }\n\t};\n\tint opt;\n\tint ret = -1;\n\n\tfor (;;) {\n\t\topt = getopt_long(argc, argv, \"p:\", opts, NULL);\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'p':\n\t\t\tret = detach_port(optarg);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\nerr_out:\n\tusbip_detach_usage();\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}