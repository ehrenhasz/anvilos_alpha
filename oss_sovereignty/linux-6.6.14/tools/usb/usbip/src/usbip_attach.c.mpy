{
  "module_name": "usbip_attach.c",
  "hash_id": "bf7681a5559c7bad37943837d84d2d2bde7a639b732247aca3df08db788bbf90",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/src/usbip_attach.c",
  "human_readable_source": "\n \n\n#include <sys/stat.h>\n\n#include <limits.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <fcntl.h>\n#include <getopt.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"vhci_driver.h\"\n#include \"usbip_common.h\"\n#include \"usbip_network.h\"\n#include \"usbip.h\"\n\nstatic const char usbip_attach_usage_string[] =\n\t\"usbip attach <args>\\n\"\n\t\"    -r, --remote=<host>      The machine with exported USB devices\\n\"\n\t\"    -b, --busid=<busid>    Busid of the device on <host>\\n\"\n\t\"    -d, --device=<devid>    Id of the virtual UDC on <host>\\n\";\n\nvoid usbip_attach_usage(void)\n{\n\tprintf(\"usage: %s\", usbip_attach_usage_string);\n}\n\n#define MAX_BUFF 100\nstatic int record_connection(char *host, char *port, char *busid, int rhport)\n{\n\tint fd;\n\tchar path[PATH_MAX+1];\n\tchar buff[MAX_BUFF+1];\n\tint ret;\n\n\tret = mkdir(VHCI_STATE_PATH, 0700);\n\tif (ret < 0) {\n\t\t \n\t\tif (errno == EEXIST) {\n\t\t\tstruct stat s;\n\n\t\t\tret = stat(VHCI_STATE_PATH, &s);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t\tif (!(s.st_mode & S_IFDIR))\n\t\t\t\treturn -1;\n\t\t} else\n\t\t\treturn -1;\n\t}\n\n\tsnprintf(path, PATH_MAX, VHCI_STATE_PATH\"/port%d\", rhport);\n\n\tfd = open(path, O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tsnprintf(buff, MAX_BUFF, \"%s %s %s\\n\",\n\t\t\thost, port, busid);\n\n\tret = write(fd, buff, strlen(buff));\n\tif (ret != (ssize_t) strlen(buff)) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tclose(fd);\n\n\treturn 0;\n}\n\nstatic int import_device(int sockfd, struct usbip_usb_device *udev)\n{\n\tint rc;\n\tint port;\n\tuint32_t speed = udev->speed;\n\n\trc = usbip_vhci_driver_open();\n\tif (rc < 0) {\n\t\terr(\"open vhci_driver (is vhci_hcd loaded?)\");\n\t\tgoto err_out;\n\t}\n\n\tdo {\n\t\tport = usbip_vhci_get_free_port(speed);\n\t\tif (port < 0) {\n\t\t\terr(\"no free port\");\n\t\t\tgoto err_driver_close;\n\t\t}\n\n\t\tdbg(\"got free port %d\", port);\n\n\t\trc = usbip_vhci_attach_device(port, sockfd, udev->busnum,\n\t\t\t\t\t      udev->devnum, udev->speed);\n\t\tif (rc < 0 && errno != EBUSY) {\n\t\t\terr(\"import device\");\n\t\t\tgoto err_driver_close;\n\t\t}\n\t} while (rc < 0);\n\n\tusbip_vhci_driver_close();\n\n\treturn port;\n\nerr_driver_close:\n\tusbip_vhci_driver_close();\nerr_out:\n\treturn -1;\n}\n\nstatic int query_import_device(int sockfd, char *busid)\n{\n\tint rc;\n\tstruct op_import_request request;\n\tstruct op_import_reply   reply;\n\tuint16_t code = OP_REP_IMPORT;\n\tint status;\n\n\tmemset(&request, 0, sizeof(request));\n\tmemset(&reply, 0, sizeof(reply));\n\n\t \n\trc = usbip_net_send_op_common(sockfd, OP_REQ_IMPORT, 0);\n\tif (rc < 0) {\n\t\terr(\"send op_common\");\n\t\treturn -1;\n\t}\n\n\tstrncpy(request.busid, busid, SYSFS_BUS_ID_SIZE-1);\n\n\tPACK_OP_IMPORT_REQUEST(0, &request);\n\n\trc = usbip_net_send(sockfd, (void *) &request, sizeof(request));\n\tif (rc < 0) {\n\t\terr(\"send op_import_request\");\n\t\treturn -1;\n\t}\n\n\t \n\trc = usbip_net_recv_op_common(sockfd, &code, &status);\n\tif (rc < 0) {\n\t\terr(\"Attach Request for %s failed - %s\\n\",\n\t\t    busid, usbip_op_common_status_string(status));\n\t\treturn -1;\n\t}\n\n\trc = usbip_net_recv(sockfd, (void *) &reply, sizeof(reply));\n\tif (rc < 0) {\n\t\terr(\"recv op_import_reply\");\n\t\treturn -1;\n\t}\n\n\tPACK_OP_IMPORT_REPLY(0, &reply);\n\n\t \n\tif (strncmp(reply.udev.busid, busid, SYSFS_BUS_ID_SIZE)) {\n\t\terr(\"recv different busid %s\", reply.udev.busid);\n\t\treturn -1;\n\t}\n\n\t \n\treturn import_device(sockfd, &reply.udev);\n}\n\nstatic int attach_device(char *host, char *busid)\n{\n\tint sockfd;\n\tint rc;\n\tint rhport;\n\n\tsockfd = usbip_net_tcp_connect(host, usbip_port_string);\n\tif (sockfd < 0) {\n\t\terr(\"tcp connect\");\n\t\treturn -1;\n\t}\n\n\trhport = query_import_device(sockfd, busid);\n\tif (rhport < 0)\n\t\treturn -1;\n\n\tclose(sockfd);\n\n\trc = record_connection(host, usbip_port_string, busid, rhport);\n\tif (rc < 0) {\n\t\terr(\"record connection\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint usbip_attach(int argc, char *argv[])\n{\n\tstatic const struct option opts[] = {\n\t\t{ \"remote\", required_argument, NULL, 'r' },\n\t\t{ \"busid\",  required_argument, NULL, 'b' },\n\t\t{ \"device\",  required_argument, NULL, 'd' },\n\t\t{ NULL, 0,  NULL, 0 }\n\t};\n\tchar *host = NULL;\n\tchar *busid = NULL;\n\tint opt;\n\tint ret = -1;\n\n\tfor (;;) {\n\t\topt = getopt_long(argc, argv, \"d:r:b:\", opts, NULL);\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'r':\n\t\t\thost = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'b':\n\t\t\tbusid = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (!host || !busid)\n\t\tgoto err_out;\n\n\tret = attach_device(host, busid);\n\tgoto out;\n\nerr_out:\n\tusbip_attach_usage();\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}