{
  "module_name": "usbip_unbind.c",
  "hash_id": "744bdcd8b3a9c7166b158babb8a80d57040b9ed66af2d5fea8797d9e983da58c",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/src/usbip_unbind.c",
  "human_readable_source": "\n \n\n#include <libudev.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <getopt.h>\n\n#include \"usbip_common.h\"\n#include \"utils.h\"\n#include \"usbip.h\"\n#include \"sysfs_utils.h\"\n\nstatic const char usbip_unbind_usage_string[] =\n\t\"usbip unbind <args>\\n\"\n\t\"    -b, --busid=<busid>    Unbind \" USBIP_HOST_DRV_NAME \".ko from \"\n\t\"device on <busid>\\n\";\n\nvoid usbip_unbind_usage(void)\n{\n\tprintf(\"usage: %s\", usbip_unbind_usage_string);\n}\n\nstatic int unbind_device(char *busid)\n{\n\tchar bus_type[] = \"usb\";\n\tint rc, ret = -1;\n\n\tchar unbind_attr_name[] = \"unbind\";\n\tchar unbind_attr_path[SYSFS_PATH_MAX];\n\tchar rebind_attr_name[] = \"rebind\";\n\tchar rebind_attr_path[SYSFS_PATH_MAX];\n\n\tstruct udev *udev;\n\tstruct udev_device *dev;\n\tconst char *driver;\n\n\t \n\tudev = udev_new();\n\n\t \n\tdev = udev_device_new_from_subsystem_sysname(udev, \"usb\", busid);\n\tif (!dev) {\n\t\terr(\"device with the specified bus ID does not exist\");\n\t\tgoto err_close_udev;\n\t}\n\n\t \n\tdriver = udev_device_get_driver(dev);\n\tif (!driver || strcmp(driver, \"usbip-host\")) {\n\t\terr(\"device is not bound to usbip-host driver\");\n\t\tgoto err_close_udev;\n\t}\n\n\t \n\tsnprintf(unbind_attr_path, sizeof(unbind_attr_path), \"%s/%s/%s/%s/%s/%s\",\n\t\t SYSFS_MNT_PATH, SYSFS_BUS_NAME, bus_type, SYSFS_DRIVERS_NAME,\n\t\t USBIP_HOST_DRV_NAME, unbind_attr_name);\n\n\trc = write_sysfs_attribute(unbind_attr_path, busid, strlen(busid));\n\tif (rc < 0) {\n\t\terr(\"error unbinding device %s from driver\", busid);\n\t\tgoto err_close_udev;\n\t}\n\n\t \n\trc = modify_match_busid(busid, 0);\n\tif (rc < 0) {\n\t\terr(\"unable to unbind device on %s\", busid);\n\t\tgoto err_close_udev;\n\t}\n\n\t \n\tsnprintf(rebind_attr_path, sizeof(unbind_attr_path), \"%s/%s/%s/%s/%s/%s\",\n\t\t\tSYSFS_MNT_PATH, SYSFS_BUS_NAME, bus_type, SYSFS_DRIVERS_NAME,\n\t\t\tUSBIP_HOST_DRV_NAME, rebind_attr_name);\n\n\trc = write_sysfs_attribute(rebind_attr_path, busid, strlen(busid));\n\tif (rc < 0) {\n\t\terr(\"error rebinding\");\n\t\tgoto err_close_udev;\n\t}\n\n\tret = 0;\n\tinfo(\"unbind device on busid %s: complete\", busid);\n\nerr_close_udev:\n\tudev_device_unref(dev);\n\tudev_unref(udev);\n\n\treturn ret;\n}\n\nint usbip_unbind(int argc, char *argv[])\n{\n\tstatic const struct option opts[] = {\n\t\t{ \"busid\", required_argument, NULL, 'b' },\n\t\t{ NULL,    0,                 NULL,  0  }\n\t};\n\n\tint opt;\n\tint ret = -1;\n\n\tfor (;;) {\n\t\topt = getopt_long(argc, argv, \"b:\", opts, NULL);\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\tret = unbind_device(optarg);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\nerr_out:\n\tusbip_unbind_usage();\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}