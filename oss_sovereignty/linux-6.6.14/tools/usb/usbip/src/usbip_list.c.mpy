{
  "module_name": "usbip_list.c",
  "hash_id": "bc14834c9a21a43f9c206573a614d340fc5db3dc9da6a71aa688f684c997336e",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/src/usbip_list.c",
  "human_readable_source": "\n \n\n#include <sys/types.h>\n#include <libudev.h>\n\n#include <errno.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <getopt.h>\n#include <netdb.h>\n#include <unistd.h>\n\n#include <dirent.h>\n\n#include <linux/usb/ch9.h>\n\n#include \"usbip_common.h\"\n#include \"usbip_network.h\"\n#include \"usbip.h\"\n\nstatic const char usbip_list_usage_string[] =\n\t\"usbip list [-p|--parsable] <args>\\n\"\n\t\"    -p, --parsable         Parsable list format\\n\"\n\t\"    -r, --remote=<host>    List the exportable USB devices on <host>\\n\"\n\t\"    -l, --local            List the local USB devices\\n\"\n\t\"    -d, --device           List the local USB gadgets bound to usbip-vudc\\n\";\n\nvoid usbip_list_usage(void)\n{\n\tprintf(\"usage: %s\", usbip_list_usage_string);\n}\n\nstatic int get_exported_devices(char *host, int sockfd)\n{\n\tchar product_name[100];\n\tchar class_name[100];\n\tstruct op_devlist_reply reply;\n\tuint16_t code = OP_REP_DEVLIST;\n\tstruct usbip_usb_device udev;\n\tstruct usbip_usb_interface uintf;\n\tunsigned int i;\n\tint rc, j;\n\tint status;\n\n\trc = usbip_net_send_op_common(sockfd, OP_REQ_DEVLIST, 0);\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_send_op_common failed\");\n\t\treturn -1;\n\t}\n\n\trc = usbip_net_recv_op_common(sockfd, &code, &status);\n\tif (rc < 0) {\n\t\terr(\"Exported Device List Request failed - %s\\n\",\n\t\t    usbip_op_common_status_string(status));\n\t\treturn -1;\n\t}\n\n\tmemset(&reply, 0, sizeof(reply));\n\trc = usbip_net_recv(sockfd, &reply, sizeof(reply));\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_recv_op_devlist failed\");\n\t\treturn -1;\n\t}\n\tPACK_OP_DEVLIST_REPLY(0, &reply);\n\tdbg(\"exportable devices: %d\\n\", reply.ndev);\n\n\tif (reply.ndev == 0) {\n\t\tinfo(\"no exportable devices found on %s\", host);\n\t\treturn 0;\n\t}\n\n\tprintf(\"Exportable USB devices\\n\");\n\tprintf(\"======================\\n\");\n\tprintf(\" - %s\\n\", host);\n\n\tfor (i = 0; i < reply.ndev; i++) {\n\t\tmemset(&udev, 0, sizeof(udev));\n\t\trc = usbip_net_recv(sockfd, &udev, sizeof(udev));\n\t\tif (rc < 0) {\n\t\t\tdbg(\"usbip_net_recv failed: usbip_usb_device[%d]\", i);\n\t\t\treturn -1;\n\t\t}\n\t\tusbip_net_pack_usb_device(0, &udev);\n\n\t\tusbip_names_get_product(product_name, sizeof(product_name),\n\t\t\t\t\tudev.idVendor, udev.idProduct);\n\t\tusbip_names_get_class(class_name, sizeof(class_name),\n\t\t\t\t      udev.bDeviceClass, udev.bDeviceSubClass,\n\t\t\t\t      udev.bDeviceProtocol);\n\t\tprintf(\"%11s: %s\\n\", udev.busid, product_name);\n\t\tprintf(\"%11s: %s\\n\", \"\", udev.path);\n\t\tprintf(\"%11s: %s\\n\", \"\", class_name);\n\n\t\tfor (j = 0; j < udev.bNumInterfaces; j++) {\n\t\t\trc = usbip_net_recv(sockfd, &uintf, sizeof(uintf));\n\t\t\tif (rc < 0) {\n\t\t\t\terr(\"usbip_net_recv failed: usbip_usb_intf[%d]\",\n\t\t\t\t\t\tj);\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tusbip_net_pack_usb_interface(0, &uintf);\n\n\t\t\tusbip_names_get_class(class_name, sizeof(class_name),\n\t\t\t\t\tuintf.bInterfaceClass,\n\t\t\t\t\tuintf.bInterfaceSubClass,\n\t\t\t\t\tuintf.bInterfaceProtocol);\n\t\t\tprintf(\"%11s: %2d - %s\\n\", \"\", j, class_name);\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int list_exported_devices(char *host)\n{\n\tint rc;\n\tint sockfd;\n\n\tsockfd = usbip_net_tcp_connect(host, usbip_port_string);\n\tif (sockfd < 0) {\n\t\terr(\"could not connect to %s:%s: %s\", host,\n\t\t    usbip_port_string, gai_strerror(sockfd));\n\t\treturn -1;\n\t}\n\tdbg(\"connected to %s:%s\", host, usbip_port_string);\n\n\trc = get_exported_devices(host, sockfd);\n\tif (rc < 0) {\n\t\terr(\"failed to get device list from %s\", host);\n\t\treturn -1;\n\t}\n\n\tclose(sockfd);\n\n\treturn 0;\n}\n\nstatic void print_device(const char *busid, const char *vendor,\n\t\t\t const char *product, bool parsable)\n{\n\tif (parsable)\n\t\tprintf(\"busid=%s#usbid=%.4s:%.4s#\", busid, vendor, product);\n\telse\n\t\tprintf(\" - busid %s (%.4s:%.4s)\\n\", busid, vendor, product);\n}\n\nstatic void print_product_name(char *product_name, bool parsable)\n{\n\tif (!parsable)\n\t\tprintf(\"   %s\\n\", product_name);\n}\n\nstatic int list_devices(bool parsable)\n{\n\tstruct udev *udev;\n\tstruct udev_enumerate *enumerate;\n\tstruct udev_list_entry *devices, *dev_list_entry;\n\tstruct udev_device *dev;\n\tconst char *path;\n\tconst char *idVendor;\n\tconst char *idProduct;\n\tconst char *bConfValue;\n\tconst char *bNumIntfs;\n\tconst char *busid;\n\tchar product_name[128];\n\tint ret = -1;\n\tconst char *devpath;\n\n\t \n\tudev = udev_new();\n\n\t \n\tenumerate = udev_enumerate_new(udev);\n\n\t \n\tudev_enumerate_add_match_subsystem(enumerate, \"usb\");\n\tudev_enumerate_add_nomatch_sysattr(enumerate, \"bDeviceClass\", \"09\");\n\tudev_enumerate_add_nomatch_sysattr(enumerate, \"bInterfaceNumber\", NULL);\n\tudev_enumerate_scan_devices(enumerate);\n\n\tdevices = udev_enumerate_get_list_entry(enumerate);\n\n\t \n\tudev_list_entry_foreach(dev_list_entry, devices) {\n\t\tpath = udev_list_entry_get_name(dev_list_entry);\n\t\tdev = udev_device_new_from_syspath(udev, path);\n\n\t\t \n\t\tdevpath = udev_device_get_devpath(dev);\n\t\tif (strstr(devpath, USBIP_VHCI_DRV_NAME)) {\n\t\t\tdbg(\"Skip the device %s already attached to %s\\n\",\n\t\t\t    devpath, USBIP_VHCI_DRV_NAME);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tidVendor = udev_device_get_sysattr_value(dev, \"idVendor\");\n\t\tidProduct = udev_device_get_sysattr_value(dev, \"idProduct\");\n\t\tbConfValue = udev_device_get_sysattr_value(dev,\n\t\t\t\t\"bConfigurationValue\");\n\t\tbNumIntfs = udev_device_get_sysattr_value(dev,\n\t\t\t\t\"bNumInterfaces\");\n\t\tbusid = udev_device_get_sysname(dev);\n\t\tif (!idVendor || !idProduct || !bConfValue || !bNumIntfs) {\n\t\t\terr(\"problem getting device attributes: %s\",\n\t\t\t    strerror(errno));\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\tusbip_names_get_product(product_name, sizeof(product_name),\n\t\t\t\t\tstrtol(idVendor, NULL, 16),\n\t\t\t\t\tstrtol(idProduct, NULL, 16));\n\n\t\t \n\t\tprint_device(busid, idVendor, idProduct, parsable);\n\t\tprint_product_name(product_name, parsable);\n\n\t\tprintf(\"\\n\");\n\n\t\tudev_device_unref(dev);\n\t}\n\n\tret = 0;\n\nerr_out:\n\tudev_enumerate_unref(enumerate);\n\tudev_unref(udev);\n\n\treturn ret;\n}\n\nstatic int list_gadget_devices(bool parsable)\n{\n\tint ret = -1;\n\tstruct udev *udev;\n\tstruct udev_enumerate *enumerate;\n\tstruct udev_list_entry *devices, *dev_list_entry;\n\tstruct udev_device *dev;\n\tconst char *path;\n\tconst char *driver;\n\n\tconst struct usb_device_descriptor *d_desc;\n\tconst char *descriptors;\n\tchar product_name[128];\n\n\tuint16_t idVendor;\n\tchar idVendor_buf[8];\n\tuint16_t idProduct;\n\tchar idProduct_buf[8];\n\tconst char *busid;\n\n\tudev = udev_new();\n\tenumerate = udev_enumerate_new(udev);\n\n\tudev_enumerate_add_match_subsystem(enumerate, \"platform\");\n\n\tudev_enumerate_scan_devices(enumerate);\n\tdevices = udev_enumerate_get_list_entry(enumerate);\n\n\tudev_list_entry_foreach(dev_list_entry, devices) {\n\t\tpath = udev_list_entry_get_name(dev_list_entry);\n\t\tdev = udev_device_new_from_syspath(udev, path);\n\n\t\tdriver = udev_device_get_driver(dev);\n\t\t \n\t\tif (driver == NULL || strcmp(driver, USBIP_DEVICE_DRV_NAME))\n\t\t\tcontinue;\n\n\t\t \n\t\tdescriptors = udev_device_get_sysattr_value(dev,\n\t\t\t\tVUDC_DEVICE_DESCR_FILE);\n\n\t\tif (!descriptors) {\n\t\t\terr(\"problem getting device attributes: %s\",\n\t\t\t    strerror(errno));\n\t\t\tgoto err_out;\n\t\t}\n\n\t\td_desc = (const struct usb_device_descriptor *) descriptors;\n\n\t\tidVendor = le16toh(d_desc->idVendor);\n\t\tsprintf(idVendor_buf, \"0x%4x\", idVendor);\n\t\tidProduct = le16toh(d_desc->idProduct);\n\t\tsprintf(idProduct_buf, \"0x%4x\", idVendor);\n\t\tbusid = udev_device_get_sysname(dev);\n\n\t\t \n\t\tusbip_names_get_product(product_name, sizeof(product_name),\n\t\t\t\t\tle16toh(idVendor),\n\t\t\t\t\tle16toh(idProduct));\n\n\t\t \n\t\tprint_device(busid, idVendor_buf, idProduct_buf, parsable);\n\t\tprint_product_name(product_name, parsable);\n\n\t\tprintf(\"\\n\");\n\n\t\tudev_device_unref(dev);\n\t}\n\tret = 0;\n\nerr_out:\n\tudev_enumerate_unref(enumerate);\n\tudev_unref(udev);\n\n\treturn ret;\n}\n\nint usbip_list(int argc, char *argv[])\n{\n\tstatic const struct option opts[] = {\n\t\t{ \"parsable\", no_argument,       NULL, 'p' },\n\t\t{ \"remote\",   required_argument, NULL, 'r' },\n\t\t{ \"local\",    no_argument,       NULL, 'l' },\n\t\t{ \"device\",    no_argument,       NULL, 'd' },\n\t\t{ NULL,       0,                 NULL,  0  }\n\t};\n\n\tbool parsable = false;\n\tint opt;\n\tint ret = -1;\n\n\tif (usbip_names_init(USBIDS_FILE))\n\t\terr(\"failed to open %s\", USBIDS_FILE);\n\n\tfor (;;) {\n\t\topt = getopt_long(argc, argv, \"pr:ld\", opts, NULL);\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\n\t\tswitch (opt) {\n\t\tcase 'p':\n\t\t\tparsable = true;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tret = list_exported_devices(optarg);\n\t\t\tgoto out;\n\t\tcase 'l':\n\t\t\tret = list_devices(parsable);\n\t\t\tgoto out;\n\t\tcase 'd':\n\t\t\tret = list_gadget_devices(parsable);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\nerr_out:\n\tusbip_list_usage();\nout:\n\tusbip_names_free();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}