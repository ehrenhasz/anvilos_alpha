{
  "module_name": "usbip_network.c",
  "hash_id": "66a83641b091e269937a7400dd3e0cad7669d45862924d8b7e191d8ccfd27fc3",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/src/usbip_network.c",
  "human_readable_source": "\n \n\n#include <sys/socket.h>\n\n#include <string.h>\n\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/tcp.h>\n#include <unistd.h>\n\n#ifdef HAVE_LIBWRAP\n#include <tcpd.h>\n#endif\n\n#include \"usbip_common.h\"\n#include \"usbip_network.h\"\n\nint usbip_port = 3240;\nchar *usbip_port_string = \"3240\";\n\nvoid usbip_setup_port_number(char *arg)\n{\n\tdbg(\"parsing port arg '%s'\", arg);\n\tchar *end;\n\tunsigned long int port = strtoul(arg, &end, 10);\n\n\tif (end == arg) {\n\t\terr(\"port: could not parse '%s' as a decimal integer\", arg);\n\t\treturn;\n\t}\n\n\tif (*end != '\\0') {\n\t\terr(\"port: garbage at end of '%s'\", arg);\n\t\treturn;\n\t}\n\n\tif (port > UINT16_MAX) {\n\t\terr(\"port: %s too high (max=%d)\",\n\t\t    arg, UINT16_MAX);\n\t\treturn;\n\t}\n\n\tusbip_port = port;\n\tusbip_port_string = arg;\n\tinfo(\"using port %d (\\\"%s\\\")\", usbip_port, usbip_port_string);\n}\n\nuint32_t usbip_net_pack_uint32_t(int pack, uint32_t num)\n{\n\tuint32_t i;\n\n\tif (pack)\n\t\ti = htonl(num);\n\telse\n\t\ti = ntohl(num);\n\n\treturn i;\n}\n\nuint16_t usbip_net_pack_uint16_t(int pack, uint16_t num)\n{\n\tuint16_t i;\n\n\tif (pack)\n\t\ti = htons(num);\n\telse\n\t\ti = ntohs(num);\n\n\treturn i;\n}\n\nvoid usbip_net_pack_usb_device(int pack, struct usbip_usb_device *udev)\n{\n\tudev->busnum = usbip_net_pack_uint32_t(pack, udev->busnum);\n\tudev->devnum = usbip_net_pack_uint32_t(pack, udev->devnum);\n\tudev->speed = usbip_net_pack_uint32_t(pack, udev->speed);\n\n\tudev->idVendor = usbip_net_pack_uint16_t(pack, udev->idVendor);\n\tudev->idProduct = usbip_net_pack_uint16_t(pack, udev->idProduct);\n\tudev->bcdDevice = usbip_net_pack_uint16_t(pack, udev->bcdDevice);\n}\n\nvoid usbip_net_pack_usb_interface(int pack __attribute__((unused)),\n\t\t\t\t  struct usbip_usb_interface *udev\n\t\t\t\t  __attribute__((unused)))\n{\n\t \n}\n\nstatic ssize_t usbip_net_xmit(int sockfd, void *buff, size_t bufflen,\n\t\t\t      int sending)\n{\n\tssize_t nbytes;\n\tssize_t total = 0;\n\n\tif (!bufflen)\n\t\treturn 0;\n\n\tdo {\n\t\tif (sending)\n\t\t\tnbytes = send(sockfd, buff, bufflen, 0);\n\t\telse\n\t\t\tnbytes = recv(sockfd, buff, bufflen, MSG_WAITALL);\n\n\t\tif (nbytes <= 0)\n\t\t\treturn -1;\n\n\t\tbuff\t = (void *)((intptr_t) buff + nbytes);\n\t\tbufflen\t-= nbytes;\n\t\ttotal\t+= nbytes;\n\n\t} while (bufflen > 0);\n\n\treturn total;\n}\n\nssize_t usbip_net_recv(int sockfd, void *buff, size_t bufflen)\n{\n\treturn usbip_net_xmit(sockfd, buff, bufflen, 0);\n}\n\nssize_t usbip_net_send(int sockfd, void *buff, size_t bufflen)\n{\n\treturn usbip_net_xmit(sockfd, buff, bufflen, 1);\n}\n\nstatic inline void usbip_net_pack_op_common(int pack,\n\t\t\t\t\t    struct op_common *op_common)\n{\n\top_common->version = usbip_net_pack_uint16_t(pack, op_common->version);\n\top_common->code = usbip_net_pack_uint16_t(pack, op_common->code);\n\top_common->status = usbip_net_pack_uint32_t(pack, op_common->status);\n}\n\nint usbip_net_send_op_common(int sockfd, uint32_t code, uint32_t status)\n{\n\tstruct op_common op_common;\n\tint rc;\n\n\tmemset(&op_common, 0, sizeof(op_common));\n\n\top_common.version = USBIP_VERSION;\n\top_common.code    = code;\n\top_common.status  = status;\n\n\tusbip_net_pack_op_common(1, &op_common);\n\n\trc = usbip_net_send(sockfd, &op_common, sizeof(op_common));\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_send failed: %d\", rc);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint usbip_net_recv_op_common(int sockfd, uint16_t *code, int *status)\n{\n\tstruct op_common op_common;\n\tint rc;\n\n\tmemset(&op_common, 0, sizeof(op_common));\n\n\trc = usbip_net_recv(sockfd, &op_common, sizeof(op_common));\n\tif (rc < 0) {\n\t\tdbg(\"usbip_net_recv failed: %d\", rc);\n\t\tgoto err;\n\t}\n\n\tusbip_net_pack_op_common(0, &op_common);\n\n\tif (op_common.version != USBIP_VERSION) {\n\t\terr(\"USBIP Kernel and tool version mismatch: %d %d:\",\n\t\t    op_common.version, USBIP_VERSION);\n\t\tgoto err;\n\t}\n\n\tswitch (*code) {\n\tcase OP_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\tif (op_common.code != *code) {\n\t\t\tdbg(\"unexpected pdu %#0x for %#0x\", op_common.code,\n\t\t\t    *code);\n\t\t\t \n\t\t\t*status = ST_ERROR;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t*status = op_common.status;\n\n\tif (op_common.status != ST_OK) {\n\t\tdbg(\"request failed at peer: %d\", op_common.status);\n\t\tgoto err;\n\t}\n\n\t*code = op_common.code;\n\n\treturn 0;\nerr:\n\treturn -1;\n}\n\nint usbip_net_set_reuseaddr(int sockfd)\n{\n\tconst int val = 1;\n\tint ret;\n\n\tret = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));\n\tif (ret < 0)\n\t\tdbg(\"setsockopt: SO_REUSEADDR\");\n\n\treturn ret;\n}\n\nint usbip_net_set_nodelay(int sockfd)\n{\n\tconst int val = 1;\n\tint ret;\n\n\tret = setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val));\n\tif (ret < 0)\n\t\tdbg(\"setsockopt: TCP_NODELAY\");\n\n\treturn ret;\n}\n\nint usbip_net_set_keepalive(int sockfd)\n{\n\tconst int val = 1;\n\tint ret;\n\n\tret = setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val));\n\tif (ret < 0)\n\t\tdbg(\"setsockopt: SO_KEEPALIVE\");\n\n\treturn ret;\n}\n\nint usbip_net_set_v6only(int sockfd)\n{\n\tconst int val = 1;\n\tint ret;\n\n\tret = setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &val, sizeof(val));\n\tif (ret < 0)\n\t\tdbg(\"setsockopt: IPV6_V6ONLY\");\n\n\treturn ret;\n}\n\n \nint usbip_net_tcp_connect(char *hostname, char *service)\n{\n\tstruct addrinfo hints, *res, *rp;\n\tint sockfd;\n\tint ret;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\n\t \n\tret = getaddrinfo(hostname, service, &hints, &res);\n\tif (ret < 0) {\n\t\tdbg(\"getaddrinfo: %s service %s: %s\", hostname, service,\n\t\t    gai_strerror(ret));\n\t\treturn ret;\n\t}\n\n\t \n\tfor (rp = res; rp; rp = rp->ai_next) {\n\t\tsockfd = socket(rp->ai_family, rp->ai_socktype,\n\t\t\t\trp->ai_protocol);\n\t\tif (sockfd < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tusbip_net_set_nodelay(sockfd);\n\t\t \n\t\tusbip_net_set_keepalive(sockfd);\n\n\t\tif (connect(sockfd, rp->ai_addr, rp->ai_addrlen) == 0)\n\t\t\tbreak;\n\n\t\tclose(sockfd);\n\t}\n\n\tfreeaddrinfo(res);\n\n\tif (!rp)\n\t\treturn EAI_SYSTEM;\n\n\treturn sockfd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}