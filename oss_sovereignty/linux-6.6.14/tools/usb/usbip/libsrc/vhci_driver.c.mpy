{
  "module_name": "vhci_driver.c",
  "hash_id": "ac6c227a3d115156abea25a8fc02086f61b28ab51d4faea31cfb7d9328af1e6c",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/libsrc/vhci_driver.c",
  "human_readable_source": "\n \n\n#include \"usbip_common.h\"\n#include \"vhci_driver.h\"\n#include <limits.h>\n#include <netdb.h>\n#include <libudev.h>\n#include <dirent.h>\n#include \"sysfs_utils.h\"\n\n#undef  PROGNAME\n#define PROGNAME \"libusbip\"\n\nstruct usbip_vhci_driver *vhci_driver;\nstruct udev *udev_context;\n\nstatic struct usbip_imported_device *\nimported_device_init(struct usbip_imported_device *idev, char *busid)\n{\n\tstruct udev_device *sudev;\n\n\tsudev = udev_device_new_from_subsystem_sysname(udev_context,\n\t\t\t\t\t\t       \"usb\", busid);\n\tif (!sudev) {\n\t\tdbg(\"udev_device_new_from_subsystem_sysname failed: %s\", busid);\n\t\tgoto err;\n\t}\n\tread_usb_device(sudev, &idev->udev);\n\tudev_device_unref(sudev);\n\n\treturn idev;\n\nerr:\n\treturn NULL;\n}\n\nstatic int parse_status(const char *value)\n{\n\tint ret = 0;\n\tchar *c;\n\n\t \n\tc = strchr(value, '\\n');\n\tif (!c)\n\t\treturn -1;\n\tc++;\n\n\twhile (*c != '\\0') {\n\t\tint port, status, speed, devid;\n\t\tint sockfd;\n\t\tchar lbusid[SYSFS_BUS_ID_SIZE];\n\t\tstruct usbip_imported_device *idev;\n\t\tchar hub[3];\n\n\t\tret = sscanf(c, \"%2s  %d %d %d %x %u %31s\\n\",\n\t\t\t\thub, &port, &status, &speed,\n\t\t\t\t&devid, &sockfd, lbusid);\n\n\t\tif (ret < 5) {\n\t\t\tdbg(\"sscanf failed: %d\", ret);\n\t\t\tBUG();\n\t\t}\n\n\t\tdbg(\"hub %s port %d status %d speed %d devid %x\",\n\t\t\t\thub, port, status, speed, devid);\n\t\tdbg(\"sockfd %u lbusid %s\", sockfd, lbusid);\n\n\t\t \n\t\tidev = &vhci_driver->idev[port];\n\t\tmemset(idev, 0, sizeof(*idev));\n\n\t\tif (strncmp(\"hs\", hub, 2) == 0)\n\t\t\tidev->hub = HUB_SPEED_HIGH;\n\t\telse  \n\t\t\tidev->hub = HUB_SPEED_SUPER;\n\n\t\tidev->port\t= port;\n\t\tidev->status\t= status;\n\n\t\tidev->devid\t= devid;\n\n\t\tidev->busnum\t= (devid >> 16);\n\t\tidev->devnum\t= (devid & 0x0000ffff);\n\n\t\tif (idev->status != VDEV_ST_NULL\n\t\t    && idev->status != VDEV_ST_NOTASSIGNED) {\n\t\t\tidev = imported_device_init(idev, lbusid);\n\t\t\tif (!idev) {\n\t\t\t\tdbg(\"imported_device_init failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tc = strchr(c, '\\n');\n\t\tif (!c)\n\t\t\tbreak;\n\t\tc++;\n\t}\n\n\tdbg(\"exit\");\n\n\treturn 0;\n}\n\n#define MAX_STATUS_NAME 18\n\nstatic int refresh_imported_device_list(void)\n{\n\tconst char *attr_status;\n\tchar status[MAX_STATUS_NAME+1] = \"status\";\n\tint i, ret;\n\n\tfor (i = 0; i < vhci_driver->ncontrollers; i++) {\n\t\tif (i > 0)\n\t\t\tsnprintf(status, sizeof(status), \"status.%d\", i);\n\n\t\tattr_status = udev_device_get_sysattr_value(vhci_driver->hc_device,\n\t\t\t\t\t\t\t    status);\n\t\tif (!attr_status) {\n\t\t\terr(\"udev_device_get_sysattr_value failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tdbg(\"controller %d\", i);\n\n\t\tret = parse_status(attr_status);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_nports(struct udev_device *hc_device)\n{\n\tconst char *attr_nports;\n\n\tattr_nports = udev_device_get_sysattr_value(hc_device, \"nports\");\n\tif (!attr_nports) {\n\t\terr(\"udev_device_get_sysattr_value nports failed\");\n\t\treturn -1;\n\t}\n\n\treturn (int)strtoul(attr_nports, NULL, 10);\n}\n\nstatic int vhci_hcd_filter(const struct dirent *dirent)\n{\n\treturn !strncmp(dirent->d_name, \"vhci_hcd.\", 9);\n}\n\nstatic int get_ncontrollers(void)\n{\n\tstruct dirent **namelist;\n\tstruct udev_device *platform;\n\tint n;\n\n\tplatform = udev_device_get_parent(vhci_driver->hc_device);\n\tif (platform == NULL)\n\t\treturn -1;\n\n\tn = scandir(udev_device_get_syspath(platform), &namelist, vhci_hcd_filter, NULL);\n\tif (n < 0)\n\t\terr(\"scandir failed\");\n\telse {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfree(namelist[i]);\n\t\tfree(namelist);\n\t}\n\n\treturn n;\n}\n\n \nstatic int read_record(int rhport, char *host, unsigned long host_len,\n\t\tchar *port, unsigned long port_len, char *busid)\n{\n\tint part;\n\tFILE *file;\n\tchar path[PATH_MAX+1];\n\tchar *buffer, *start, *end;\n\tchar delim[] = {' ', ' ', '\\n'};\n\tint max_len[] = {(int)host_len, (int)port_len, SYSFS_BUS_ID_SIZE};\n\tsize_t buffer_len = host_len + port_len + SYSFS_BUS_ID_SIZE + 4;\n\n\tbuffer = malloc(buffer_len);\n\tif (!buffer)\n\t\treturn -1;\n\n\tsnprintf(path, PATH_MAX, VHCI_STATE_PATH\"/port%d\", rhport);\n\n\tfile = fopen(path, \"r\");\n\tif (!file) {\n\t\terr(\"fopen\");\n\t\tfree(buffer);\n\t\treturn -1;\n\t}\n\n\tif (fgets(buffer, buffer_len, file) == NULL) {\n\t\terr(\"fgets\");\n\t\tfree(buffer);\n\t\tfclose(file);\n\t\treturn -1;\n\t}\n\tfclose(file);\n\n\t \n\tstart = buffer;\n\tfor (part = 0; part < 3; part++) {\n\t\tend = strchr(start, delim[part]);\n\t\tif (end == NULL || (end - start) > max_len[part]) {\n\t\t\tfree(buffer);\n\t\t\treturn -1;\n\t\t}\n\t\tstart = end + 1;\n\t}\n\n\tif (sscanf(buffer, \"%s %s %s\\n\", host, port, busid) != 3) {\n\t\terr(\"sscanf\");\n\t\tfree(buffer);\n\t\treturn -1;\n\t}\n\n\tfree(buffer);\n\n\treturn 0;\n}\n\n \n\nint usbip_vhci_driver_open(void)\n{\n\tint nports;\n\tstruct udev_device *hc_device;\n\n\tudev_context = udev_new();\n\tif (!udev_context) {\n\t\terr(\"udev_new failed\");\n\t\treturn -1;\n\t}\n\n\t \n\thc_device =\n\t\tudev_device_new_from_subsystem_sysname(udev_context,\n\t\t\t\t\t\t       USBIP_VHCI_BUS_TYPE,\n\t\t\t\t\t\t       USBIP_VHCI_DEVICE_NAME);\n\tif (!hc_device) {\n\t\terr(\"udev_device_new_from_subsystem_sysname failed\");\n\t\tgoto err;\n\t}\n\n\tnports = get_nports(hc_device);\n\tif (nports <= 0) {\n\t\terr(\"no available ports\");\n\t\tgoto err;\n\t}\n\tdbg(\"available ports: %d\", nports);\n\n\tvhci_driver = calloc(1, sizeof(struct usbip_vhci_driver) +\n\t\t\tnports * sizeof(struct usbip_imported_device));\n\tif (!vhci_driver) {\n\t\terr(\"vhci_driver allocation failed\");\n\t\tgoto err;\n\t}\n\n\tvhci_driver->nports = nports;\n\tvhci_driver->hc_device = hc_device;\n\tvhci_driver->ncontrollers = get_ncontrollers();\n\tdbg(\"available controllers: %d\", vhci_driver->ncontrollers);\n\n\tif (vhci_driver->ncontrollers <=0) {\n\t\terr(\"no available usb controllers\");\n\t\tgoto err;\n\t}\n\n\tif (refresh_imported_device_list())\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tudev_device_unref(hc_device);\n\n\tif (vhci_driver)\n\t\tfree(vhci_driver);\n\n\tvhci_driver = NULL;\n\n\tudev_unref(udev_context);\n\n\treturn -1;\n}\n\n\nvoid usbip_vhci_driver_close(void)\n{\n\tif (!vhci_driver)\n\t\treturn;\n\n\tudev_device_unref(vhci_driver->hc_device);\n\n\tfree(vhci_driver);\n\n\tvhci_driver = NULL;\n\n\tudev_unref(udev_context);\n}\n\n\nint usbip_vhci_refresh_device_list(void)\n{\n\n\tif (refresh_imported_device_list())\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdbg(\"failed to refresh device list\");\n\treturn -1;\n}\n\n\nint usbip_vhci_get_free_port(uint32_t speed)\n{\n\tfor (int i = 0; i < vhci_driver->nports; i++) {\n\n\t\tswitch (speed) {\n\t\tcase\tUSB_SPEED_SUPER:\n\t\t\tif (vhci_driver->idev[i].hub != HUB_SPEED_SUPER)\n\t\t\t\tcontinue;\n\t\tbreak;\n\t\tdefault:\n\t\t\tif (vhci_driver->idev[i].hub != HUB_SPEED_HIGH)\n\t\t\t\tcontinue;\n\t\tbreak;\n\t\t}\n\n\t\tif (vhci_driver->idev[i].status == VDEV_ST_NULL)\n\t\t\treturn vhci_driver->idev[i].port;\n\t}\n\n\treturn -1;\n}\n\nint usbip_vhci_attach_device2(uint8_t port, int sockfd, uint32_t devid,\n\t\tuint32_t speed) {\n\tchar buff[200];  \n\tchar attach_attr_path[SYSFS_PATH_MAX];\n\tchar attr_attach[] = \"attach\";\n\tconst char *path;\n\tint ret;\n\n\tsnprintf(buff, sizeof(buff), \"%u %d %u %u\",\n\t\t\tport, sockfd, devid, speed);\n\tdbg(\"writing: %s\", buff);\n\n\tpath = udev_device_get_syspath(vhci_driver->hc_device);\n\tsnprintf(attach_attr_path, sizeof(attach_attr_path), \"%s/%s\",\n\t\t path, attr_attach);\n\tdbg(\"attach attribute path: %s\", attach_attr_path);\n\n\tret = write_sysfs_attribute(attach_attr_path, buff, strlen(buff));\n\tif (ret < 0) {\n\t\tdbg(\"write_sysfs_attribute failed\");\n\t\treturn -1;\n\t}\n\n\tdbg(\"attached port: %d\", port);\n\n\treturn 0;\n}\n\nstatic unsigned long get_devid(uint8_t busnum, uint8_t devnum)\n{\n\treturn (busnum << 16) | devnum;\n}\n\n \nint usbip_vhci_attach_device(uint8_t port, int sockfd, uint8_t busnum,\n\t\tuint8_t devnum, uint32_t speed)\n{\n\tint devid = get_devid(busnum, devnum);\n\n\treturn usbip_vhci_attach_device2(port, sockfd, devid, speed);\n}\n\nint usbip_vhci_detach_device(uint8_t port)\n{\n\tchar detach_attr_path[SYSFS_PATH_MAX];\n\tchar attr_detach[] = \"detach\";\n\tchar buff[200];  \n\tconst char *path;\n\tint ret;\n\n\tsnprintf(buff, sizeof(buff), \"%u\", port);\n\tdbg(\"writing: %s\", buff);\n\n\tpath = udev_device_get_syspath(vhci_driver->hc_device);\n\tsnprintf(detach_attr_path, sizeof(detach_attr_path), \"%s/%s\",\n\t\t path, attr_detach);\n\tdbg(\"detach attribute path: %s\", detach_attr_path);\n\n\tret = write_sysfs_attribute(detach_attr_path, buff, strlen(buff));\n\tif (ret < 0) {\n\t\tdbg(\"write_sysfs_attribute failed\");\n\t\treturn -1;\n\t}\n\n\tdbg(\"detached port: %d\", port);\n\n\treturn 0;\n}\n\nint usbip_vhci_imported_device_dump(struct usbip_imported_device *idev)\n{\n\tchar product_name[100];\n\tchar host[NI_MAXHOST] = \"unknown host\";\n\tchar serv[NI_MAXSERV] = \"unknown port\";\n\tchar remote_busid[SYSFS_BUS_ID_SIZE];\n\tint ret;\n\tint read_record_error = 0;\n\n\tif (idev->status == VDEV_ST_NULL || idev->status == VDEV_ST_NOTASSIGNED)\n\t\treturn 0;\n\n\tret = read_record(idev->port, host, sizeof(host), serv, sizeof(serv),\n\t\t\t  remote_busid);\n\tif (ret) {\n\t\terr(\"read_record\");\n\t\tread_record_error = 1;\n\t}\n\n\tprintf(\"Port %02d: <%s> at %s\\n\", idev->port,\n\t       usbip_status_string(idev->status),\n\t       usbip_speed_string(idev->udev.speed));\n\n\tusbip_names_get_product(product_name, sizeof(product_name),\n\t\t\t\tidev->udev.idVendor, idev->udev.idProduct);\n\n\tprintf(\"       %s\\n\",  product_name);\n\n\tif (!read_record_error) {\n\t\tprintf(\"%10s -> usbip://%s:%s/%s\\n\", idev->udev.busid,\n\t\t       host, serv, remote_busid);\n\t\tprintf(\"%10s -> remote bus/dev %03d/%03d\\n\", \" \",\n\t\t       idev->busnum, idev->devnum);\n\t} else {\n\t\tprintf(\"%10s -> unknown host, remote port and remote busid\\n\",\n\t\t       idev->udev.busid);\n\t\tprintf(\"%10s -> remote bus/dev %03d/%03d\\n\", \" \",\n\t\t       idev->busnum, idev->devnum);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}