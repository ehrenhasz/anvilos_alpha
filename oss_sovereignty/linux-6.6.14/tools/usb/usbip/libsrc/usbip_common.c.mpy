{
  "module_name": "usbip_common.c",
  "hash_id": "250f17734e444036860173780564265677a9e9f1867da0d409d08a946a1464fb",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/libsrc/usbip_common.c",
  "human_readable_source": "\n \n\n#include <libudev.h>\n#include \"usbip_common.h\"\n#include \"names.h\"\n\n#undef  PROGNAME\n#define PROGNAME \"libusbip\"\n\nint usbip_use_syslog;\nint usbip_use_stderr;\nint usbip_use_debug;\n\nextern struct udev *udev_context;\n\nstruct speed_string {\n\tint num;\n\tchar *speed;\n\tchar *desc;\n};\n\nstatic const struct speed_string speed_strings[] = {\n\t{ USB_SPEED_UNKNOWN, \"unknown\", \"Unknown Speed\"},\n\t{ USB_SPEED_LOW,  \"1.5\", \"Low Speed(1.5Mbps)\"  },\n\t{ USB_SPEED_FULL, \"12\",  \"Full Speed(12Mbps)\" },\n\t{ USB_SPEED_HIGH, \"480\", \"High Speed(480Mbps)\" },\n\t{ USB_SPEED_WIRELESS, \"53.3-480\", \"Wireless\"},\n\t{ USB_SPEED_SUPER, \"5000\", \"Super Speed(5000Mbps)\" },\n\t{ 0, NULL, NULL }\n};\n\nstruct portst_string {\n\tint num;\n\tchar *desc;\n};\n\nstatic struct portst_string portst_strings[] = {\n\t{ SDEV_ST_AVAILABLE,\t\"Device Available\" },\n\t{ SDEV_ST_USED,\t\t\"Device in Use\" },\n\t{ SDEV_ST_ERROR,\t\"Device Error\"},\n\t{ VDEV_ST_NULL,\t\t\"Port Available\"},\n\t{ VDEV_ST_NOTASSIGNED,\t\"Port Initializing\"},\n\t{ VDEV_ST_USED,\t\t\"Port in Use\"},\n\t{ VDEV_ST_ERROR,\t\"Port Error\"},\n\t{ 0, NULL}\n};\n\nconst char *usbip_status_string(int32_t status)\n{\n\tfor (int i = 0; portst_strings[i].desc != NULL; i++)\n\t\tif (portst_strings[i].num == status)\n\t\t\treturn portst_strings[i].desc;\n\n\treturn \"Unknown Status\";\n}\n\nconst char *usbip_speed_string(int num)\n{\n\tfor (int i = 0; speed_strings[i].speed != NULL; i++)\n\t\tif (speed_strings[i].num == num)\n\t\t\treturn speed_strings[i].desc;\n\n\treturn \"Unknown Speed\";\n}\n\nstruct op_common_status_string {\n\tint num;\n\tchar *desc;\n};\n\nstatic struct op_common_status_string op_common_status_strings[] = {\n\t{ ST_OK,\t\"Request Completed Successfully\" },\n\t{ ST_NA,\t\"Request Failed\" },\n\t{ ST_DEV_BUSY,\t\"Device busy (exported)\" },\n\t{ ST_DEV_ERR,\t\"Device in error state\" },\n\t{ ST_NODEV,\t\"Device not found\" },\n\t{ ST_ERROR,\t\"Unexpected response\" },\n\t{ 0, NULL}\n};\n\nconst char *usbip_op_common_status_string(int status)\n{\n\tfor (int i = 0; op_common_status_strings[i].desc != NULL; i++)\n\t\tif (op_common_status_strings[i].num == status)\n\t\t\treturn op_common_status_strings[i].desc;\n\n\treturn \"Unknown Op Common Status\";\n}\n\n#define DBG_UDEV_INTEGER(name)\\\n\tdbg(\"%-20s = %x\", to_string(name), (int) udev->name)\n\n#define DBG_UINF_INTEGER(name)\\\n\tdbg(\"%-20s = %x\", to_string(name), (int) uinf->name)\n\nvoid dump_usb_interface(struct usbip_usb_interface *uinf)\n{\n\tchar buff[100];\n\n\tusbip_names_get_class(buff, sizeof(buff),\n\t\t\tuinf->bInterfaceClass,\n\t\t\tuinf->bInterfaceSubClass,\n\t\t\tuinf->bInterfaceProtocol);\n\tdbg(\"%-20s = %s\", \"Interface(C/SC/P)\", buff);\n}\n\nvoid dump_usb_device(struct usbip_usb_device *udev)\n{\n\tchar buff[100];\n\n\tdbg(\"%-20s = %s\", \"path\",  udev->path);\n\tdbg(\"%-20s = %s\", \"busid\", udev->busid);\n\n\tusbip_names_get_class(buff, sizeof(buff),\n\t\t\tudev->bDeviceClass,\n\t\t\tudev->bDeviceSubClass,\n\t\t\tudev->bDeviceProtocol);\n\tdbg(\"%-20s = %s\", \"Device(C/SC/P)\", buff);\n\n\tDBG_UDEV_INTEGER(bcdDevice);\n\n\tusbip_names_get_product(buff, sizeof(buff),\n\t\t\tudev->idVendor,\n\t\t\tudev->idProduct);\n\tdbg(\"%-20s = %s\", \"Vendor/Product\", buff);\n\n\tDBG_UDEV_INTEGER(bNumConfigurations);\n\tDBG_UDEV_INTEGER(bNumInterfaces);\n\n\tdbg(\"%-20s = %s\", \"speed\",\n\t\t\tusbip_speed_string(udev->speed));\n\n\tDBG_UDEV_INTEGER(busnum);\n\tDBG_UDEV_INTEGER(devnum);\n}\n\n\nint read_attr_value(struct udev_device *dev, const char *name,\n\t\t    const char *format)\n{\n\tconst char *attr;\n\tint num = 0;\n\tint ret;\n\n\tattr = udev_device_get_sysattr_value(dev, name);\n\tif (!attr) {\n\t\terr(\"udev_device_get_sysattr_value failed\");\n\t\tgoto err;\n\t}\n\n\t \n\n\tret = sscanf(attr, format, &num);\n\tif (ret < 1) {\n\t\tif (strcmp(name, \"bConfigurationValue\") &&\n\t\t\t\tstrcmp(name, \"bNumInterfaces\")) {\n\t\t\terr(\"sscanf failed for attribute %s\", name);\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\n\treturn num;\n}\n\n\nint read_attr_speed(struct udev_device *dev)\n{\n\tconst char *speed;\n\n\tspeed = udev_device_get_sysattr_value(dev, \"speed\");\n\tif (!speed) {\n\t\terr(\"udev_device_get_sysattr_value failed\");\n\t\tgoto err;\n\t}\n\n\tfor (int i = 0; speed_strings[i].speed != NULL; i++) {\n\t\tif (!strcmp(speed, speed_strings[i].speed))\n\t\t\treturn speed_strings[i].num;\n\t}\n\nerr:\n\n\treturn USB_SPEED_UNKNOWN;\n}\n\n#define READ_ATTR(object, type, dev, name, format)\t\t\t      \\\n\tdo {\t\t\t\t\t\t\t\t      \\\n\t\t(object)->name = (type) read_attr_value(dev, to_string(name), \\\n\t\t\t\t\t\t\tformat);\t      \\\n\t} while (0)\n\n\nint read_usb_device(struct udev_device *sdev, struct usbip_usb_device *udev)\n{\n\tuint32_t busnum, devnum;\n\tconst char *path, *name;\n\n\tREAD_ATTR(udev, uint8_t,  sdev, bDeviceClass,\t\t\"%02x\\n\");\n\tREAD_ATTR(udev, uint8_t,  sdev, bDeviceSubClass,\t\"%02x\\n\");\n\tREAD_ATTR(udev, uint8_t,  sdev, bDeviceProtocol,\t\"%02x\\n\");\n\n\tREAD_ATTR(udev, uint16_t, sdev, idVendor,\t\t\"%04x\\n\");\n\tREAD_ATTR(udev, uint16_t, sdev, idProduct,\t\t\"%04x\\n\");\n\tREAD_ATTR(udev, uint16_t, sdev, bcdDevice,\t\t\"%04x\\n\");\n\n\tREAD_ATTR(udev, uint8_t,  sdev, bConfigurationValue,\t\"%02x\\n\");\n\tREAD_ATTR(udev, uint8_t,  sdev, bNumConfigurations,\t\"%02x\\n\");\n\tREAD_ATTR(udev, uint8_t,  sdev, bNumInterfaces,\t\t\"%02x\\n\");\n\n\tREAD_ATTR(udev, uint8_t,  sdev, devnum,\t\t\t\"%d\\n\");\n\tudev->speed = read_attr_speed(sdev);\n\n\tpath = udev_device_get_syspath(sdev);\n\tname = udev_device_get_sysname(sdev);\n\n\tstrncpy(udev->path,  path,  SYSFS_PATH_MAX - 1);\n\tudev->path[SYSFS_PATH_MAX - 1] = '\\0';\n\tstrncpy(udev->busid, name, SYSFS_BUS_ID_SIZE - 1);\n\tudev->busid[SYSFS_BUS_ID_SIZE - 1] = '\\0';\n\n\tsscanf(name, \"%u-%u\", &busnum, &devnum);\n\tudev->busnum = busnum;\n\n\treturn 0;\n}\n\nint read_usb_interface(struct usbip_usb_device *udev, int i,\n\t\t       struct usbip_usb_interface *uinf)\n{\n\tchar busid[SYSFS_BUS_ID_SIZE];\n\tint size;\n\tstruct udev_device *sif;\n\n\tsize = snprintf(busid, sizeof(busid), \"%s:%d.%d\",\n\t\t\tudev->busid, udev->bConfigurationValue, i);\n\tif (size < 0 || (unsigned int)size >= sizeof(busid)) {\n\t\terr(\"busid length %i >= %lu or < 0\", size,\n\t\t    (long unsigned)sizeof(busid));\n\t\treturn -1;\n\t}\n\n\tsif = udev_device_new_from_subsystem_sysname(udev_context, \"usb\", busid);\n\tif (!sif) {\n\t\terr(\"udev_device_new_from_subsystem_sysname %s failed\", busid);\n\t\treturn -1;\n\t}\n\n\tREAD_ATTR(uinf, uint8_t,  sif, bInterfaceClass,\t\t\"%02x\\n\");\n\tREAD_ATTR(uinf, uint8_t,  sif, bInterfaceSubClass,\t\"%02x\\n\");\n\tREAD_ATTR(uinf, uint8_t,  sif, bInterfaceProtocol,\t\"%02x\\n\");\n\n\treturn 0;\n}\n\nint usbip_names_init(char *f)\n{\n\treturn names_init(f);\n}\n\nvoid usbip_names_free(void)\n{\n\tnames_free();\n}\n\nvoid usbip_names_get_product(char *buff, size_t size, uint16_t vendor,\n\t\t\t     uint16_t product)\n{\n\tconst char *prod, *vend;\n\n\tprod = names_product(vendor, product);\n\tif (!prod)\n\t\tprod = \"unknown product\";\n\n\n\tvend = names_vendor(vendor);\n\tif (!vend)\n\t\tvend = \"unknown vendor\";\n\n\tsnprintf(buff, size, \"%s : %s (%04x:%04x)\", vend, prod, vendor, product);\n}\n\nvoid usbip_names_get_class(char *buff, size_t size, uint8_t class,\n\t\t\t   uint8_t subclass, uint8_t protocol)\n{\n\tconst char *c, *s, *p;\n\n\tif (class == 0 && subclass == 0 && protocol == 0) {\n\t\tsnprintf(buff, size, \"(Defined at Interface level) (%02x/%02x/%02x)\", class, subclass, protocol);\n\t\treturn;\n\t}\n\n\tp = names_protocol(class, subclass, protocol);\n\tif (!p)\n\t\tp = \"unknown protocol\";\n\n\ts = names_subclass(class, subclass);\n\tif (!s)\n\t\ts = \"unknown subclass\";\n\n\tc = names_class(class);\n\tif (!c)\n\t\tc = \"unknown class\";\n\n\tsnprintf(buff, size, \"%s / %s / %s (%02x/%02x/%02x)\", c, s, p, class, subclass, protocol);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}