{
  "module_name": "names.c",
  "hash_id": "aaacda52786f29fd88c8fc674f8e01fccb946c9089eea5440d661617ea66afa0",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/libsrc/names.c",
  "human_readable_source": "\n \n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"names.h\"\n#include \"usbip_common.h\"\n\nstruct vendor {\n\tstruct vendor *next;\n\tu_int16_t vendorid;\n\tchar name[1];\n};\n\nstruct product {\n\tstruct product *next;\n\tu_int16_t vendorid, productid;\n\tchar name[1];\n};\n\nstruct class {\n\tstruct class *next;\n\tu_int8_t classid;\n\tchar name[1];\n};\n\nstruct subclass {\n\tstruct subclass *next;\n\tu_int8_t classid, subclassid;\n\tchar name[1];\n};\n\nstruct protocol {\n\tstruct protocol *next;\n\tu_int8_t classid, subclassid, protocolid;\n\tchar name[1];\n};\n\nstruct genericstrtable {\n\tstruct genericstrtable *next;\n\tunsigned int num;\n\tchar name[1];\n};\n\n\n#define HASH1  0x10\n#define HASH2  0x02\n#define HASHSZ 16\n\nstatic unsigned int hashnum(unsigned int num)\n{\n\tunsigned int mask1 = HASH1 << 27, mask2 = HASH2 << 27;\n\n\tfor (; mask1 >= HASH1; mask1 >>= 1, mask2 >>= 1)\n\t\tif (num & mask1)\n\t\t\tnum ^= mask2;\n\treturn num & (HASHSZ-1);\n}\n\n\nstatic struct vendor *vendors[HASHSZ] = { NULL, };\nstatic struct product *products[HASHSZ] = { NULL, };\nstatic struct class *classes[HASHSZ] = { NULL, };\nstatic struct subclass *subclasses[HASHSZ] = { NULL, };\nstatic struct protocol *protocols[HASHSZ] = { NULL, };\n\nconst char *names_vendor(u_int16_t vendorid)\n{\n\tstruct vendor *v;\n\n\tv = vendors[hashnum(vendorid)];\n\tfor (; v; v = v->next)\n\t\tif (v->vendorid == vendorid)\n\t\t\treturn v->name;\n\treturn NULL;\n}\n\nconst char *names_product(u_int16_t vendorid, u_int16_t productid)\n{\n\tstruct product *p;\n\n\tp = products[hashnum((vendorid << 16) | productid)];\n\tfor (; p; p = p->next)\n\t\tif (p->vendorid == vendorid && p->productid == productid)\n\t\t\treturn p->name;\n\treturn NULL;\n}\n\nconst char *names_class(u_int8_t classid)\n{\n\tstruct class *c;\n\n\tc = classes[hashnum(classid)];\n\tfor (; c; c = c->next)\n\t\tif (c->classid == classid)\n\t\t\treturn c->name;\n\treturn NULL;\n}\n\nconst char *names_subclass(u_int8_t classid, u_int8_t subclassid)\n{\n\tstruct subclass *s;\n\n\ts = subclasses[hashnum((classid << 8) | subclassid)];\n\tfor (; s; s = s->next)\n\t\tif (s->classid == classid && s->subclassid == subclassid)\n\t\t\treturn s->name;\n\treturn NULL;\n}\n\nconst char *names_protocol(u_int8_t classid, u_int8_t subclassid,\n\t\t\t   u_int8_t protocolid)\n{\n\tstruct protocol *p;\n\n\tp = protocols[hashnum((classid << 16) | (subclassid << 8)\n\t\t\t      | protocolid)];\n\tfor (; p; p = p->next)\n\t\tif (p->classid == classid && p->subclassid == subclassid &&\n\t\t    p->protocolid == protocolid)\n\t\t\treturn p->name;\n\treturn NULL;\n}\n\n \nstruct pool {\n\tstruct pool *next;\n\tvoid *mem;\n};\n\nstatic struct pool *pool_head;\n\nstatic void *my_malloc(size_t size)\n{\n\tstruct pool *p;\n\n\tp = calloc(1, sizeof(struct pool));\n\tif (!p)\n\t\treturn NULL;\n\n\tp->mem = calloc(1, size);\n\tif (!p->mem) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\n\tp->next = pool_head;\n\tpool_head = p;\n\n\treturn p->mem;\n}\n\nvoid names_free(void)\n{\n\tstruct pool *pool;\n\n\tif (!pool_head)\n\t\treturn;\n\n\tfor (pool = pool_head; pool != NULL; ) {\n\t\tstruct pool *tmp;\n\n\t\tif (pool->mem)\n\t\t\tfree(pool->mem);\n\n\t\ttmp = pool;\n\t\tpool = pool->next;\n\t\tfree(tmp);\n\t}\n}\n\nstatic int new_vendor(const char *name, u_int16_t vendorid)\n{\n\tstruct vendor *v;\n\tunsigned int h = hashnum(vendorid);\n\n\tv = vendors[h];\n\tfor (; v; v = v->next)\n\t\tif (v->vendorid == vendorid)\n\t\t\treturn -1;\n\tv = my_malloc(sizeof(struct vendor) + strlen(name));\n\tif (!v)\n\t\treturn -1;\n\tstrcpy(v->name, name);\n\tv->vendorid = vendorid;\n\tv->next = vendors[h];\n\tvendors[h] = v;\n\treturn 0;\n}\n\nstatic int new_product(const char *name, u_int16_t vendorid,\n\t\t       u_int16_t productid)\n{\n\tstruct product *p;\n\tunsigned int h = hashnum((vendorid << 16) | productid);\n\n\tp = products[h];\n\tfor (; p; p = p->next)\n\t\tif (p->vendorid == vendorid && p->productid == productid)\n\t\t\treturn -1;\n\tp = my_malloc(sizeof(struct product) + strlen(name));\n\tif (!p)\n\t\treturn -1;\n\tstrcpy(p->name, name);\n\tp->vendorid = vendorid;\n\tp->productid = productid;\n\tp->next = products[h];\n\tproducts[h] = p;\n\treturn 0;\n}\n\nstatic int new_class(const char *name, u_int8_t classid)\n{\n\tstruct class *c;\n\tunsigned int h = hashnum(classid);\n\n\tc = classes[h];\n\tfor (; c; c = c->next)\n\t\tif (c->classid == classid)\n\t\t\treturn -1;\n\tc = my_malloc(sizeof(struct class) + strlen(name));\n\tif (!c)\n\t\treturn -1;\n\tstrcpy(c->name, name);\n\tc->classid = classid;\n\tc->next = classes[h];\n\tclasses[h] = c;\n\treturn 0;\n}\n\nstatic int new_subclass(const char *name, u_int8_t classid, u_int8_t subclassid)\n{\n\tstruct subclass *s;\n\tunsigned int h = hashnum((classid << 8) | subclassid);\n\n\ts = subclasses[h];\n\tfor (; s; s = s->next)\n\t\tif (s->classid == classid && s->subclassid == subclassid)\n\t\t\treturn -1;\n\ts = my_malloc(sizeof(struct subclass) + strlen(name));\n\tif (!s)\n\t\treturn -1;\n\tstrcpy(s->name, name);\n\ts->classid = classid;\n\ts->subclassid = subclassid;\n\ts->next = subclasses[h];\n\tsubclasses[h] = s;\n\treturn 0;\n}\n\nstatic int new_protocol(const char *name, u_int8_t classid, u_int8_t subclassid,\n\t\t\tu_int8_t protocolid)\n{\n\tstruct protocol *p;\n\tunsigned int h = hashnum((classid << 16) | (subclassid << 8)\n\t\t\t\t | protocolid);\n\n\tp = protocols[h];\n\tfor (; p; p = p->next)\n\t\tif (p->classid == classid && p->subclassid == subclassid\n\t\t    && p->protocolid == protocolid)\n\t\t\treturn -1;\n\tp = my_malloc(sizeof(struct protocol) + strlen(name));\n\tif (!p)\n\t\treturn -1;\n\tstrcpy(p->name, name);\n\tp->classid = classid;\n\tp->subclassid = subclassid;\n\tp->protocolid = protocolid;\n\tp->next = protocols[h];\n\tprotocols[h] = p;\n\treturn 0;\n}\n\nstatic void parse(FILE *f)\n{\n\tchar buf[512], *cp;\n\tunsigned int linectr = 0;\n\tint lastvendor = -1;\n\tint lastclass = -1;\n\tint lastsubclass = -1;\n\tint lasthut = -1;\n\tint lastlang = -1;\n\tunsigned int u;\n\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\tlinectr++;\n\t\t \n\t\tcp = strchr(buf, '\\r');\n\t\tif (cp)\n\t\t\t*cp = 0;\n\t\tcp = strchr(buf, '\\n');\n\t\tif (cp)\n\t\t\t*cp = 0;\n\t\tif (buf[0] == '#' || !buf[0])\n\t\t\tcontinue;\n\t\tcp = buf;\n\t\tif (buf[0] == 'P' && buf[1] == 'H' && buf[2] == 'Y' &&\n\t\t    buf[3] == 'S' && buf[4] == 'D' &&\n\t\t    buf[5] == 'E' && buf[6] == 'S' &&  \n\t\t    buf[7] == ' ') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'P' && buf[1] == 'H' &&\n\t\t    buf[2] == 'Y' &&   buf[3] == ' ') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'B' && buf[1] == 'I' && buf[2] == 'A' &&\n\t\t    buf[3] == 'S' &&   buf[4] == ' ') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'L' &&   buf[1] == ' ') {\n\t\t\tlasthut = lastclass = lastvendor = lastsubclass = -1;\n\t\t\t \n\t\t\tlastlang = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'C' &&   buf[1] == ' ') {\n\t\t\t \n\t\t\tcp = buf+2;\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif (!isxdigit(*cp)) {\n\t\t\t\terr(\"Invalid class spec at line %u\", linectr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tu = strtoul(cp, &cp, 16);\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif (!*cp) {\n\t\t\t\terr(\"Invalid class spec at line %u\", linectr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (new_class(cp, u))\n\t\t\t\terr(\"Duplicate class spec at line %u class %04x %s\",\n\t\t\t\t    linectr, u, cp);\n\t\t\tdbg(\"line %5u class %02x %s\", linectr, u, cp);\n\t\t\tlasthut = lastlang = lastvendor = lastsubclass = -1;\n\t\t\tlastclass = u;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'A' && buf[1] == 'T' && isspace(buf[2])) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'H' && buf[1] == 'C' && buf[2] == 'C'\n\t\t    && isspace(buf[3])) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (isxdigit(*cp)) {\n\t\t\t \n\t\t\tu = strtoul(cp, &cp, 16);\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif (!*cp) {\n\t\t\t\terr(\"Invalid vendor spec at line %u\", linectr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (new_vendor(cp, u))\n\t\t\t\terr(\"Duplicate vendor spec at line %u vendor %04x %s\",\n\t\t\t\t    linectr, u, cp);\n\t\t\tdbg(\"line %5u vendor %04x %s\", linectr, u, cp);\n\t\t\tlastvendor = u;\n\t\t\tlasthut = lastlang = lastclass = lastsubclass = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == '\\t' && isxdigit(buf[1])) {\n\t\t\t \n\t\t\tu = strtoul(buf+1, &cp, 16);\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif (!*cp) {\n\t\t\t\terr(\"Invalid product/subclass spec at line %u\",\n\t\t\t\t    linectr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastvendor != -1) {\n\t\t\t\tif (new_product(cp, lastvendor, u))\n\t\t\t\t\terr(\"Duplicate product spec at line %u product %04x:%04x %s\",\n\t\t\t\t\t    linectr, lastvendor, u, cp);\n\t\t\t\tdbg(\"line %5u product %04x:%04x %s\", linectr,\n\t\t\t\t    lastvendor, u, cp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastclass != -1) {\n\t\t\t\tif (new_subclass(cp, lastclass, u))\n\t\t\t\t\terr(\"Duplicate subclass spec at line %u class %02x:%02x %s\",\n\t\t\t\t\t    linectr, lastclass, u, cp);\n\t\t\t\tdbg(\"line %5u subclass %02x:%02x %s\", linectr,\n\t\t\t\t    lastclass, u, cp);\n\t\t\t\tlastsubclass = u;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lasthut != -1) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastlang != -1) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr(\"Product/Subclass spec without prior Vendor/Class spec at line %u\",\n\t\t\t    linectr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == '\\t' && buf[1] == '\\t' && isxdigit(buf[2])) {\n\t\t\t \n\t\t\tu = strtoul(buf+2, &cp, 16);\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif (!*cp) {\n\t\t\t\terr(\"Invalid protocol spec at line %u\",\n\t\t\t\t    linectr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastclass != -1 && lastsubclass != -1) {\n\t\t\t\tif (new_protocol(cp, lastclass, lastsubclass,\n\t\t\t\t\t\t u))\n\t\t\t\t\terr(\"Duplicate protocol spec at line %u class %02x:%02x:%02x %s\",\n\t\t\t\t\t    linectr, lastclass, lastsubclass,\n\t\t\t\t\t    u, cp);\n\t\t\t\tdbg(\"line %5u protocol %02x:%02x:%02x %s\",\n\t\t\t\t    linectr, lastclass, lastsubclass, u, cp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr(\"Protocol spec without prior Class and Subclass spec at line %u\",\n\t\t\t    linectr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'H' && buf[1] == 'I' &&\n\t\t    buf[2] == 'D' &&   buf[3] == ' ') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'H' && buf[1] == 'U' &&\n\t\t    buf[2] == 'T' &&   buf[3] == ' ') {\n\t\t\tlastlang = lastclass = lastvendor = lastsubclass = -1;\n\t\t\t \n\t\t\tlasthut = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'R' && buf[1] == ' ')\n\t\t\tcontinue;\n\n\t\tif (buf[0] == 'V' && buf[1] == 'T')\n\t\t\tcontinue;\n\n\t\terr(\"Unknown line at line %u\", linectr);\n\t}\n}\n\n\nint names_init(char *n)\n{\n\tFILE *f;\n\n\tf = fopen(n, \"r\");\n\tif (!f)\n\t\treturn errno;\n\n\tparse(f);\n\tfclose(f);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}