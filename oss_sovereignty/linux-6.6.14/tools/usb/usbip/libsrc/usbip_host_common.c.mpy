{
  "module_name": "usbip_host_common.c",
  "hash_id": "5848b645b3e579dd5883a009d3548e128a409728d2cda76b545da3d64602a119",
  "original_prompt": "Ingested from linux-6.6.14/tools/usb/usbip/libsrc/usbip_host_common.c",
  "human_readable_source": "\n \n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include <errno.h>\n#include <unistd.h>\n\n#include <libudev.h>\n\n#include \"usbip_common.h\"\n#include \"usbip_host_common.h\"\n#include \"list.h\"\n#include \"sysfs_utils.h\"\n\nextern struct udev *udev_context;\n\nstatic int32_t read_attr_usbip_status(struct usbip_usb_device *udev)\n{\n\tchar status_attr_path[SYSFS_PATH_MAX];\n\tint size;\n\tint fd;\n\tint length;\n\tchar status[2] = { 0 };\n\tint value = 0;\n\n\tsize = snprintf(status_attr_path, sizeof(status_attr_path),\n\t\t\t\"%s/usbip_status\", udev->path);\n\tif (size < 0 || (unsigned int)size >= sizeof(status_attr_path)) {\n\t\terr(\"usbip_status path length %i >= %lu or < 0\", size,\n\t\t    (long unsigned)sizeof(status_attr_path));\n\t\treturn -1;\n\t}\n\n\n\tfd = open(status_attr_path, O_RDONLY);\n\tif (fd < 0) {\n\t\terr(\"error opening attribute %s\", status_attr_path);\n\t\treturn -1;\n\t}\n\n\tlength = read(fd, status, 1);\n\tif (length < 0) {\n\t\terr(\"error reading attribute %s\", status_attr_path);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tvalue = atoi(status);\n\tclose(fd);\n\treturn value;\n}\n\nstatic\nstruct usbip_exported_device *usbip_exported_device_new(\n\t\tstruct usbip_host_driver *hdriver, const char *sdevpath)\n{\n\tstruct usbip_exported_device *edev = NULL;\n\tstruct usbip_exported_device *edev_old;\n\tsize_t size;\n\tint i;\n\n\tedev = calloc(1, sizeof(struct usbip_exported_device));\n\n\tedev->sudev =\n\t\tudev_device_new_from_syspath(udev_context, sdevpath);\n\tif (!edev->sudev) {\n\t\terr(\"udev_device_new_from_syspath: %s\", sdevpath);\n\t\tgoto err;\n\t}\n\n\tif (hdriver->ops.read_device(edev->sudev, &edev->udev) < 0)\n\t\tgoto err;\n\n\tedev->status = read_attr_usbip_status(&edev->udev);\n\tif (edev->status < 0)\n\t\tgoto err;\n\n\t \n\tsize = sizeof(struct usbip_exported_device) +\n\t\tedev->udev.bNumInterfaces * sizeof(struct usbip_usb_interface);\n\n\tedev_old = edev;\n\tedev = realloc(edev, size);\n\tif (!edev) {\n\t\tedev = edev_old;\n\t\tdbg(\"realloc failed\");\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < edev->udev.bNumInterfaces; i++) {\n\t\t \n\t\tif (!hdriver->ops.read_interface)\n\t\t\tbreak;\n\t\thdriver->ops.read_interface(&edev->udev, i, &edev->uinf[i]);\n\t}\n\n\treturn edev;\nerr:\n\tif (edev->sudev)\n\t\tudev_device_unref(edev->sudev);\n\tif (edev)\n\t\tfree(edev);\n\n\treturn NULL;\n}\n\nstatic int refresh_exported_devices(struct usbip_host_driver *hdriver)\n{\n\tstruct usbip_exported_device *edev;\n\tstruct udev_enumerate *enumerate;\n\tstruct udev_list_entry *devices, *dev_list_entry;\n\tstruct udev_device *dev;\n\tconst char *path;\n\n\tenumerate = udev_enumerate_new(udev_context);\n\tudev_enumerate_add_match_subsystem(enumerate, hdriver->udev_subsystem);\n\tudev_enumerate_scan_devices(enumerate);\n\n\tdevices = udev_enumerate_get_list_entry(enumerate);\n\n\tudev_list_entry_foreach(dev_list_entry, devices) {\n\t\tpath = udev_list_entry_get_name(dev_list_entry);\n\t\tdev = udev_device_new_from_syspath(udev_context,\n\t\t\t\t\t\t   path);\n\t\tif (dev == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (hdriver->ops.is_my_device(dev)) {\n\t\t\tedev = usbip_exported_device_new(hdriver, path);\n\t\t\tif (!edev) {\n\t\t\t\tdbg(\"usbip_exported_device_new failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlist_add(&edev->node, &hdriver->edev_list);\n\t\t\thdriver->ndevs++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void usbip_exported_device_destroy(struct list_head *devs)\n{\n\tstruct list_head *i, *tmp;\n\tstruct usbip_exported_device *edev;\n\n\tlist_for_each_safe(i, tmp, devs) {\n\t\tedev = list_entry(i, struct usbip_exported_device, node);\n\t\tlist_del(i);\n\t\tfree(edev);\n\t}\n}\n\nint usbip_generic_driver_open(struct usbip_host_driver *hdriver)\n{\n\tint rc;\n\n\tudev_context = udev_new();\n\tif (!udev_context) {\n\t\terr(\"udev_new failed\");\n\t\treturn -1;\n\t}\n\n\trc = refresh_exported_devices(hdriver);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tudev_unref(udev_context);\n\treturn -1;\n}\n\nvoid usbip_generic_driver_close(struct usbip_host_driver *hdriver)\n{\n\tif (!hdriver)\n\t\treturn;\n\n\tusbip_exported_device_destroy(&hdriver->edev_list);\n\n\tudev_unref(udev_context);\n}\n\nint usbip_generic_refresh_device_list(struct usbip_host_driver *hdriver)\n{\n\tint rc;\n\n\tusbip_exported_device_destroy(&hdriver->edev_list);\n\n\thdriver->ndevs = 0;\n\tINIT_LIST_HEAD(&hdriver->edev_list);\n\n\trc = refresh_exported_devices(hdriver);\n\tif (rc < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint usbip_export_device(struct usbip_exported_device *edev, int sockfd)\n{\n\tchar attr_name[] = \"usbip_sockfd\";\n\tchar sockfd_attr_path[SYSFS_PATH_MAX];\n\tint size;\n\tchar sockfd_buff[30];\n\tint ret;\n\n\tif (edev->status != SDEV_ST_AVAILABLE) {\n\t\tdbg(\"device not available: %s\", edev->udev.busid);\n\t\tswitch (edev->status) {\n\t\tcase SDEV_ST_ERROR:\n\t\t\tdbg(\"status SDEV_ST_ERROR\");\n\t\t\tret = ST_DEV_ERR;\n\t\t\tbreak;\n\t\tcase SDEV_ST_USED:\n\t\t\tdbg(\"status SDEV_ST_USED\");\n\t\t\tret = ST_DEV_BUSY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdbg(\"status unknown: 0x%x\", edev->status);\n\t\t\tret = -1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t \n\tsize = snprintf(sockfd_attr_path, sizeof(sockfd_attr_path), \"%s/%s\",\n\t\t\tedev->udev.path, attr_name);\n\tif (size < 0 || (unsigned int)size >= sizeof(sockfd_attr_path)) {\n\t\terr(\"exported device path length %i >= %lu or < 0\", size,\n\t\t    (long unsigned)sizeof(sockfd_attr_path));\n\t\treturn -1;\n\t}\n\n\tsize = snprintf(sockfd_buff, sizeof(sockfd_buff), \"%d\\n\", sockfd);\n\tif (size < 0 || (unsigned int)size >= sizeof(sockfd_buff)) {\n\t\terr(\"socket length %i >= %lu or < 0\", size,\n\t\t    (long unsigned)sizeof(sockfd_buff));\n\t\treturn -1;\n\t}\n\n\tret = write_sysfs_attribute(sockfd_attr_path, sockfd_buff,\n\t\t\t\t    strlen(sockfd_buff));\n\tif (ret < 0) {\n\t\terr(\"write_sysfs_attribute failed: sockfd %s to %s\",\n\t\t    sockfd_buff, sockfd_attr_path);\n\t\treturn ret;\n\t}\n\n\tinfo(\"connect: %s\", edev->udev.busid);\n\n\treturn ret;\n}\n\nstruct usbip_exported_device *usbip_generic_get_device(\n\t\tstruct usbip_host_driver *hdriver, int num)\n{\n\tstruct list_head *i;\n\tstruct usbip_exported_device *edev;\n\tint cnt = 0;\n\n\tlist_for_each(i, &hdriver->edev_list) {\n\t\tedev = list_entry(i, struct usbip_exported_device, node);\n\t\tif (num == cnt)\n\t\t\treturn edev;\n\t\tcnt++;\n\t}\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}