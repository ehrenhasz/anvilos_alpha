{
  "module_name": "intel_sdsi.c",
  "hash_id": "73414fde319fe246d3681871b3eba1aa7a25428838b81fe6032fb9e9c02d1c19",
  "original_prompt": "Ingested from linux-6.6.14/tools/arch/x86/intel_sdsi/intel_sdsi.c",
  "human_readable_source": "\n \n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/types.h>\n\n#ifndef __packed\n#define __packed __attribute__((packed))\n#endif\n\n#define min(x, y) ({                            \\\n\ttypeof(x) _min1 = (x);                  \\\n\ttypeof(y) _min2 = (y);                  \\\n\t(void) (&_min1 == &_min2);              \\\n\t_min1 < _min2 ? _min1 : _min2; })\n\n#define SDSI_DEV\t\t\"intel_vsec.sdsi\"\n#define AUX_DEV_PATH\t\t\"/sys/bus/auxiliary/devices/\"\n#define SDSI_PATH\t\t(AUX_DEV_DIR SDSI_DEV)\n#define GUID_V1\t\t\t0x6dd191\n#define REGS_SIZE_GUID_V1\t72\n#define GUID_V2\t\t\t0xF210D9EF\n#define REGS_SIZE_GUID_V2\t80\n#define STATE_CERT_MAX_SIZE\t4096\n#define METER_CERT_MAX_SIZE\t4096\n#define STATE_MAX_NUM_LICENSES\t16\n#define STATE_MAX_NUM_IN_BUNDLE\t(uint32_t)8\n#define METER_MAX_NUM_BUNDLES\t8\n\n#define __round_mask(x, y) ((__typeof__(x))((y) - 1))\n#define round_up(x, y) ((((x) - 1) | __round_mask(x, y)) + 1)\n\nstruct nvram_content_auth_err_sts {\n\tuint64_t reserved:3;\n\tuint64_t sdsi_content_auth_err:1;\n\tuint64_t reserved1:1;\n\tuint64_t sdsi_metering_auth_err:1;\n\tuint64_t reserved2:58;\n};\n\nstruct enabled_features {\n\tuint64_t reserved:3;\n\tuint64_t sdsi:1;\n\tuint64_t reserved1:8;\n\tuint64_t attestation:1;\n\tuint64_t reserved2:13;\n\tuint64_t metering:1;\n\tuint64_t reserved3:37;\n};\n\nstruct key_provision_status {\n\tuint64_t reserved:1;\n\tuint64_t license_key_provisioned:1;\n\tuint64_t reserved2:62;\n};\n\nstruct auth_fail_count {\n\tuint64_t key_failure_count:3;\n\tuint64_t key_failure_threshold:3;\n\tuint64_t auth_failure_count:3;\n\tuint64_t auth_failure_threshold:3;\n\tuint64_t reserved:52;\n};\n\nstruct availability {\n\tuint64_t reserved:48;\n\tuint64_t available:3;\n\tuint64_t threshold:3;\n\tuint64_t reserved2:10;\n};\n\nstruct nvram_update_limit {\n\tuint64_t reserved:12;\n\tuint64_t sdsi_50_pct:1;\n\tuint64_t sdsi_75_pct:1;\n\tuint64_t sdsi_90_pct:1;\n\tuint64_t reserved2:49;\n};\n\nstruct sdsi_regs {\n\tuint64_t ppin;\n\tstruct nvram_content_auth_err_sts auth_err_sts;\n\tstruct enabled_features en_features;\n\tstruct key_provision_status key_prov_sts;\n\tstruct auth_fail_count auth_fail_count;\n\tstruct availability prov_avail;\n\tstruct nvram_update_limit limits;\n\tuint64_t pcu_cr3_capid_cfg;\n\tunion {\n\t\tstruct {\n\t\t\tuint64_t socket_id;\n\t\t} v1;\n\t\tstruct {\n\t\t\tuint64_t reserved;\n\t\t\tuint64_t socket_id;\n\t\t\tuint64_t reserved2;\n\t\t} v2;\n\t} extra;\n};\n#define CONTENT_TYPE_LK_ENC\t\t0xD\n#define CONTENT_TYPE_LK_BLOB_ENC\t0xE\n\nstruct state_certificate {\n\tuint32_t content_type;\n\tuint32_t region_rev_id;\n\tuint32_t header_size;\n\tuint32_t total_size;\n\tuint32_t key_size;\n\tuint32_t num_licenses;\n};\n\nstruct license_key_info {\n\tuint32_t key_rev_id;\n\tuint64_t key_image_content[6];\n} __packed;\n\n#define LICENSE_BLOB_SIZE(l)\t(((l) & 0x7fffffff) * 4)\n#define LICENSE_VALID(l)\t(!!((l) & 0x80000000))\n\n\n#define LBT_ONE_TIME_UPGRADE\t1\n#define LBT_METERED_UPGRADE\t2\n\nstruct license_blob_content {\n\tuint32_t type;\n\tuint64_t id;\n\tuint64_t ppin;\n\tuint64_t previous_ppin;\n\tuint32_t rev_id;\n\tuint32_t num_bundles;\n} __packed;\n\nstruct bundle_encoding {\n\tuint32_t encoding;\n\tuint32_t encoding_rsvd[7];\n};\n\nstruct meter_certificate {\n\tuint32_t block_signature;\n\tuint32_t counter_unit;\n\tuint64_t ppin;\n\tuint32_t bundle_length;\n\tuint32_t reserved;\n\tuint32_t mmrc_encoding;\n\tuint32_t mmrc_counter;\n};\n\nstruct bundle_encoding_counter {\n\tuint32_t encoding;\n\tuint32_t counter;\n};\n\nstruct sdsi_dev {\n\tstruct sdsi_regs regs;\n\tstruct state_certificate sc;\n\tchar *dev_name;\n\tchar *dev_path;\n\tuint32_t guid;\n};\n\nenum command {\n\tCMD_SOCKET_INFO,\n\tCMD_METER_CERT,\n\tCMD_STATE_CERT,\n\tCMD_PROV_AKC,\n\tCMD_PROV_CAP,\n};\n\nstatic void sdsi_list_devices(void)\n{\n\tstruct dirent *entry;\n\tDIR *aux_dir;\n\tbool found = false;\n\n\taux_dir = opendir(AUX_DEV_PATH);\n\tif (!aux_dir) {\n\t\tfprintf(stderr, \"Cannot open directory %s\\n\", AUX_DEV_PATH);\n\t\treturn;\n\t}\n\n\twhile ((entry = readdir(aux_dir))) {\n\t\tif (!strncmp(SDSI_DEV, entry->d_name, strlen(SDSI_DEV))) {\n\t\t\tfound = true;\n\t\t\tprintf(\"%s\\n\", entry->d_name);\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfprintf(stderr, \"No On Demand devices found.\\n\");\n}\n\nstatic int sdsi_update_registers(struct sdsi_dev *s)\n{\n\tFILE *regs_ptr;\n\tint ret;\n\n\tmemset(&s->regs, 0, sizeof(s->regs));\n\n\t \n\tret = chdir(s->dev_path);\n\tif (ret == -1) {\n\t\tperror(\"chdir\");\n\t\treturn ret;\n\t}\n\n\tregs_ptr = fopen(\"registers\", \"r\");\n\tif (!regs_ptr) {\n\t\tperror(\"Could not open 'registers' file\");\n\t\treturn -1;\n\t}\n\n\tif (s->guid != GUID_V1 && s->guid != GUID_V2) {\n\t\tfprintf(stderr, \"Unrecognized guid, 0x%x\\n\", s->guid);\n\t\tfclose(regs_ptr);\n\t\treturn -1;\n\t}\n\n\t \n\tret = fread(&s->regs, sizeof(uint8_t), sizeof(s->regs), regs_ptr);\n\tif ((s->guid == GUID_V1 && ret != REGS_SIZE_GUID_V1) ||\n\t    (s->guid == GUID_V2 && ret != REGS_SIZE_GUID_V2)) {\n\t\tfprintf(stderr, \"Could not read 'registers' file\\n\");\n\t\tfclose(regs_ptr);\n\t\treturn -1;\n\t}\n\n\tfclose(regs_ptr);\n\n\treturn 0;\n}\n\nstatic int sdsi_read_reg(struct sdsi_dev *s)\n{\n\tint ret;\n\n\tret = sdsi_update_registers(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tprintf(\"\\n\");\n\tprintf(\"Socket information for device %s\\n\", s->dev_name);\n\tprintf(\"\\n\");\n\tprintf(\"PPIN:                           0x%lx\\n\", s->regs.ppin);\n\tprintf(\"NVRAM Content Authorization Error Status\\n\");\n\tprintf(\"    SDSi Auth Err Sts:          %s\\n\", !!s->regs.auth_err_sts.sdsi_content_auth_err ? \"Error\" : \"Okay\");\n\n\tif (!!s->regs.en_features.metering)\n\t\tprintf(\"    Metering Auth Err Sts:      %s\\n\", !!s->regs.auth_err_sts.sdsi_metering_auth_err ? \"Error\" : \"Okay\");\n\n\tprintf(\"Enabled Features\\n\");\n\tprintf(\"    On Demand:                  %s\\n\", !!s->regs.en_features.sdsi ? \"Enabled\" : \"Disabled\");\n\tprintf(\"    Attestation:                %s\\n\", !!s->regs.en_features.attestation ? \"Enabled\" : \"Disabled\");\n\tprintf(\"    On Demand:                  %s\\n\", !!s->regs.en_features.sdsi ? \"Enabled\" : \"Disabled\");\n\tprintf(\"    Metering:                   %s\\n\", !!s->regs.en_features.metering ? \"Enabled\" : \"Disabled\");\n\tprintf(\"License Key (AKC) Provisioned:  %s\\n\", !!s->regs.key_prov_sts.license_key_provisioned ? \"Yes\" : \"No\");\n\tprintf(\"Authorization Failure Count\\n\");\n\tprintf(\"    AKC Failure Count:          %d\\n\", s->regs.auth_fail_count.key_failure_count);\n\tprintf(\"    AKC Failure Threshold:      %d\\n\", s->regs.auth_fail_count.key_failure_threshold);\n\tprintf(\"    CAP Failure Count:          %d\\n\", s->regs.auth_fail_count.auth_failure_count);\n\tprintf(\"    CAP Failure Threshold:      %d\\n\", s->regs.auth_fail_count.auth_failure_threshold);\n\tprintf(\"Provisioning Availability\\n\");\n\tprintf(\"    Updates Available:          %d\\n\", s->regs.prov_avail.available);\n\tprintf(\"    Updates Threshold:          %d\\n\", s->regs.prov_avail.threshold);\n\tprintf(\"NVRAM Udate Limit\\n\");\n\tprintf(\"    50%% Limit Reached:          %s\\n\", !!s->regs.limits.sdsi_50_pct ? \"Yes\" : \"No\");\n\tprintf(\"    75%% Limit Reached:          %s\\n\", !!s->regs.limits.sdsi_75_pct ? \"Yes\" : \"No\");\n\tprintf(\"    90%% Limit Reached:          %s\\n\", !!s->regs.limits.sdsi_90_pct ? \"Yes\" : \"No\");\n\tif (s->guid == GUID_V1)\n\t\tprintf(\"Socket ID:                      %ld\\n\", s->regs.extra.v1.socket_id & 0xF);\n\telse\n\t\tprintf(\"Socket ID:                      %ld\\n\", s->regs.extra.v2.socket_id & 0xF);\n\n\treturn 0;\n}\n\nstatic char *license_blob_type(uint32_t type)\n{\n\tswitch (type) {\n\tcase LBT_ONE_TIME_UPGRADE:\n\t\treturn \"One time upgrade\";\n\tcase LBT_METERED_UPGRADE:\n\t\treturn \"Metered upgrade\";\n\tdefault:\n\t\treturn \"Unknown license blob type\";\n\t}\n}\n\nstatic char *content_type(uint32_t type)\n{\n\tswitch (type) {\n\tcase  CONTENT_TYPE_LK_ENC:\n\t\treturn \"Licencse key encoding\";\n\tcase CONTENT_TYPE_LK_BLOB_ENC:\n\t\treturn \"License key + Blob encoding\";\n\tdefault:\n\t\treturn \"Unknown content type\";\n\t}\n}\n\nstatic void get_feature(uint32_t encoding, char *feature)\n{\n\tchar *name = (char *)&encoding;\n\n\tfeature[3] = name[0];\n\tfeature[2] = name[1];\n\tfeature[1] = name[2];\n\tfeature[0] = name[3];\n}\n\nstatic int sdsi_meter_cert_show(struct sdsi_dev *s)\n{\n\tchar buf[METER_CERT_MAX_SIZE] = {0};\n\tstruct bundle_encoding_counter *bec;\n\tstruct meter_certificate *mc;\n\tuint32_t count = 0;\n\tFILE *cert_ptr;\n\tint ret, size;\n\n\tret = sdsi_update_registers(s);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!s->regs.en_features.sdsi) {\n\t\tfprintf(stderr, \"SDSi feature is present but not enabled.\\n\");\n\t\tfprintf(stderr, \" Unable to read meter certificate\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!s->regs.en_features.metering) {\n\t\tfprintf(stderr, \"Metering not supporting on this socket.\\n\");\n\t\treturn -1;\n\t}\n\n\tret = chdir(s->dev_path);\n\tif (ret == -1) {\n\t\tperror(\"chdir\");\n\t\treturn ret;\n\t}\n\n\tcert_ptr = fopen(\"meter_certificate\", \"r\");\n\tif (!cert_ptr) {\n\t\tperror(\"Could not open 'meter_certificate' file\");\n\t\treturn -1;\n\t}\n\n\tsize = fread(buf, 1, sizeof(buf), cert_ptr);\n\tif (!size) {\n\t\tfprintf(stderr, \"Could not read 'meter_certificate' file\\n\");\n\t\tfclose(cert_ptr);\n\t\treturn -1;\n\t}\n\tfclose(cert_ptr);\n\n\tmc = (struct meter_certificate *)buf;\n\n\tprintf(\"\\n\");\n\tprintf(\"Meter certificate for device %s\\n\", s->dev_name);\n\tprintf(\"\\n\");\n\tprintf(\"Block Signature:       0x%x\\n\", mc->block_signature);\n\tprintf(\"Count Unit:            %dms\\n\", mc->counter_unit);\n\tprintf(\"PPIN:                  0x%lx\\n\", mc->ppin);\n\tprintf(\"Feature Bundle Length: %d\\n\", mc->bundle_length);\n\tprintf(\"MMRC encoding:         %d\\n\", mc->mmrc_encoding);\n\tprintf(\"MMRC counter:          %d\\n\", mc->mmrc_counter);\n\tif (mc->bundle_length % 8) {\n\t\tfprintf(stderr, \"Invalid bundle length\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mc->bundle_length > METER_MAX_NUM_BUNDLES * 8)  {\n\t\tfprintf(stderr, \"More than %d bundles: %d\\n\",\n\t\t\tMETER_MAX_NUM_BUNDLES, mc->bundle_length / 8);\n\t\treturn -1;\n\t}\n\n\tbec = (void *)(mc) + sizeof(mc);\n\n\tprintf(\"Number of Feature Counters:          %d\\n\", mc->bundle_length / 8);\n\twhile (count++ < mc->bundle_length / 8) {\n\t\tchar feature[5];\n\n\t\tfeature[4] = '\\0';\n\t\tget_feature(bec[count].encoding, feature);\n\t\tprintf(\"    %s:          %d\\n\", feature, bec[count].counter);\n\t}\n\n\treturn 0;\n}\n\nstatic int sdsi_state_cert_show(struct sdsi_dev *s)\n{\n\tchar buf[STATE_CERT_MAX_SIZE] = {0};\n\tstruct state_certificate *sc;\n\tstruct license_key_info *lki;\n\tuint32_t offset = 0;\n\tuint32_t count = 0;\n\tFILE *cert_ptr;\n\tint ret, size;\n\n\tret = sdsi_update_registers(s);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!s->regs.en_features.sdsi) {\n\t\tfprintf(stderr, \"On Demand feature is present but not enabled.\");\n\t\tfprintf(stderr, \" Unable to read state certificate\");\n\t\treturn -1;\n\t}\n\n\tret = chdir(s->dev_path);\n\tif (ret == -1) {\n\t\tperror(\"chdir\");\n\t\treturn ret;\n\t}\n\n\tcert_ptr = fopen(\"state_certificate\", \"r\");\n\tif (!cert_ptr) {\n\t\tperror(\"Could not open 'state_certificate' file\");\n\t\treturn -1;\n\t}\n\n\tsize = fread(buf, 1, sizeof(buf), cert_ptr);\n\tif (!size) {\n\t\tfprintf(stderr, \"Could not read 'state_certificate' file\\n\");\n\t\tfclose(cert_ptr);\n\t\treturn -1;\n\t}\n\tfclose(cert_ptr);\n\n\tsc = (struct state_certificate *)buf;\n\n\t \n\tprintf(\"\\n\");\n\tprintf(\"State certificate for device %s\\n\", s->dev_name);\n\tprintf(\"\\n\");\n\tprintf(\"Content Type:          %s\\n\", content_type(sc->content_type));\n\tprintf(\"Region Revision ID:    %d\\n\", sc->region_rev_id);\n\tprintf(\"Header Size:           %d\\n\", sc->header_size * 4);\n\tprintf(\"Total Size:            %d\\n\", sc->total_size);\n\tprintf(\"OEM Key Size:          %d\\n\", sc->key_size * 4);\n\tprintf(\"Number of Licenses:    %d\\n\", sc->num_licenses);\n\n\t \n\tlki = (void *)sc + sizeof(*sc) + (4 * sc->num_licenses);\n\n\tprintf(\"License blob Info:\\n\");\n\tprintf(\"    License Key Revision ID:    0x%x\\n\", lki->key_rev_id);\n\tprintf(\"    License Key Image Content:  0x%lx%lx%lx%lx%lx%lx\\n\",\n\t       lki->key_image_content[5], lki->key_image_content[4],\n\t       lki->key_image_content[3], lki->key_image_content[2],\n\t       lki->key_image_content[1], lki->key_image_content[0]);\n\n\twhile (count++ < sc->num_licenses) {\n\t\tuint32_t blob_size_field = *(uint32_t *)(buf + 0x14 + count * 4);\n\t\tuint32_t blob_size = LICENSE_BLOB_SIZE(blob_size_field);\n\t\tbool license_valid = LICENSE_VALID(blob_size_field);\n\t\tstruct license_blob_content *lbc =\n\t\t\t(void *)(sc) +\t\t\t\n\t\t\tsizeof(*sc) +\t\t\t\n\t\t\t(4 * sc->num_licenses) +\t\n\t\t\tsizeof(*lki) +\t\t\t\n\t\t\toffset;\t\t\t\t\n\t\tstruct bundle_encoding *bundle = (void *)(lbc) + sizeof(*lbc);\n\t\tchar feature[5];\n\t\tuint32_t i;\n\n\t\tprintf(\"     Blob %d:\\n\", count - 1);\n\t\tprintf(\"        License blob size:          %u\\n\", blob_size);\n\t\tprintf(\"        License is valid:           %s\\n\", license_valid ? \"Yes\" : \"No\");\n\t\tprintf(\"        License blob type:          %s\\n\", license_blob_type(lbc->type));\n\t\tprintf(\"        License blob ID:            0x%lx\\n\", lbc->id);\n\t\tprintf(\"        PPIN:                       0x%lx\\n\", lbc->ppin);\n\t\tprintf(\"        Previous PPIN:              0x%lx\\n\", lbc->previous_ppin);\n\t\tprintf(\"        Blob revision ID:           %u\\n\", lbc->rev_id);\n\t\tprintf(\"        Number of Features:         %u\\n\", lbc->num_bundles);\n\n\t\tfeature[4] = '\\0';\n\n\t\tfor (i = 0; i < min(lbc->num_bundles, STATE_MAX_NUM_IN_BUNDLE); i++) {\n\t\t\tget_feature(bundle[i].encoding, feature);\n\t\t\tprintf(\"                 Feature %d:         %s\\n\", i, feature);\n\t\t}\n\n\t\tif (lbc->num_bundles > STATE_MAX_NUM_IN_BUNDLE)\n\t\t\tfprintf(stderr, \"        Warning: %d > %d licenses in bundle reported.\\n\",\n\t\t\t\tlbc->num_bundles, STATE_MAX_NUM_IN_BUNDLE);\n\n\t\toffset += blob_size;\n\t};\n\n\treturn 0;\n}\n\nstatic int sdsi_provision(struct sdsi_dev *s, char *bin_file, enum command command)\n{\n\tint bin_fd, prov_fd, size, ret;\n\tchar buf[STATE_CERT_MAX_SIZE] = { 0 };\n\tchar cap[] = \"provision_cap\";\n\tchar akc[] = \"provision_akc\";\n\tchar *prov_file;\n\n\tif (!bin_file) {\n\t\tfprintf(stderr, \"No binary file provided\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tbin_fd = open(bin_file, O_RDONLY);\n\tif (bin_fd == -1) {\n\t\tfprintf(stderr, \"Could not open file %s: %s\\n\", bin_file, strerror(errno));\n\t\treturn bin_fd;\n\t}\n\n\tprov_file = (command == CMD_PROV_AKC) ? akc : cap;\n\n\tret = chdir(s->dev_path);\n\tif (ret == -1) {\n\t\tperror(\"chdir\");\n\t\tclose(bin_fd);\n\t\treturn ret;\n\t}\n\n\t \n\tprov_fd = open(prov_file, O_WRONLY);\n\tif (prov_fd == -1) {\n\t\tfprintf(stderr, \"Could not open file %s: %s\\n\", prov_file, strerror(errno));\n\t\tclose(bin_fd);\n\t\treturn prov_fd;\n\t}\n\n\t \n\tsize = read(bin_fd, buf, STATE_CERT_MAX_SIZE);\n\tif (size == -1) {\n\t\tclose(bin_fd);\n\t\tclose(prov_fd);\n\t\treturn -1;\n\t}\n\n\tret = write(prov_fd, buf, size);\n\tif (ret == -1) {\n\t\tclose(bin_fd);\n\t\tclose(prov_fd);\n\t\tperror(\"Provisioning failed\");\n\t\treturn ret;\n\t}\n\n\tprintf(\"Provisioned %s file %s successfully\\n\", prov_file, bin_file);\n\n\tclose(bin_fd);\n\tclose(prov_fd);\n\n\treturn 0;\n}\n\nstatic int sdsi_provision_akc(struct sdsi_dev *s, char *bin_file)\n{\n\tint ret;\n\n\tret = sdsi_update_registers(s);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!s->regs.en_features.sdsi) {\n\t\tfprintf(stderr, \"On Demand feature is present but not enabled. Unable to provision\");\n\t\treturn -1;\n\t}\n\n\tif (!s->regs.prov_avail.available) {\n\t\tfprintf(stderr, \"Maximum number of updates (%d) has been reached.\\n\",\n\t\t\ts->regs.prov_avail.threshold);\n\t\treturn -1;\n\t}\n\n\tif (s->regs.auth_fail_count.key_failure_count ==\n\t    s->regs.auth_fail_count.key_failure_threshold) {\n\t\tfprintf(stderr, \"Maximum number of AKC provision failures (%d) has been reached.\\n\",\n\t\t\ts->regs.auth_fail_count.key_failure_threshold);\n\t\tfprintf(stderr, \"Power cycle the system to reset the counter\\n\");\n\t\treturn -1;\n\t}\n\n\treturn sdsi_provision(s, bin_file, CMD_PROV_AKC);\n}\n\nstatic int sdsi_provision_cap(struct sdsi_dev *s, char *bin_file)\n{\n\tint ret;\n\n\tret = sdsi_update_registers(s);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!s->regs.en_features.sdsi) {\n\t\tfprintf(stderr, \"On Demand feature is present but not enabled. Unable to provision\");\n\t\treturn -1;\n\t}\n\n\tif (!s->regs.prov_avail.available) {\n\t\tfprintf(stderr, \"Maximum number of updates (%d) has been reached.\\n\",\n\t\t\ts->regs.prov_avail.threshold);\n\t\treturn -1;\n\t}\n\n\tif (s->regs.auth_fail_count.auth_failure_count ==\n\t    s->regs.auth_fail_count.auth_failure_threshold) {\n\t\tfprintf(stderr, \"Maximum number of CAP provision failures (%d) has been reached.\\n\",\n\t\t\ts->regs.auth_fail_count.auth_failure_threshold);\n\t\tfprintf(stderr, \"Power cycle the system to reset the counter\\n\");\n\t\treturn -1;\n\t}\n\n\treturn sdsi_provision(s, bin_file, CMD_PROV_CAP);\n}\n\nstatic int read_sysfs_data(const char *file, int *value)\n{\n\tchar buff[16];\n\tFILE *fp;\n\n\tfp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tperror(file);\n\t\treturn -1;\n\t}\n\n\tif (!fgets(buff, 16, fp)) {\n\t\tfprintf(stderr, \"Failed to read file '%s'\", file);\n\t\tfclose(fp);\n\t\treturn -1;\n\t}\n\n\tfclose(fp);\n\t*value = strtol(buff, NULL, 0);\n\n\treturn 0;\n}\n\nstatic struct sdsi_dev *sdsi_create_dev(char *dev_no)\n{\n\tint dev_name_len = sizeof(SDSI_DEV) + strlen(dev_no) + 1;\n\tstruct sdsi_dev *s;\n\tint guid;\n\tDIR *dir;\n\n\ts = (struct sdsi_dev *)malloc(sizeof(*s));\n\tif (!s) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n\t}\n\n\ts->dev_name = (char *)malloc(sizeof(SDSI_DEV) + strlen(dev_no) + 1);\n\tif (!s->dev_name) {\n\t\tperror(\"malloc\");\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\n\tsnprintf(s->dev_name, dev_name_len, \"%s.%s\", SDSI_DEV, dev_no);\n\n\ts->dev_path = (char *)malloc(sizeof(AUX_DEV_PATH) + dev_name_len);\n\tif (!s->dev_path) {\n\t\tperror(\"malloc\");\n\t\tfree(s->dev_name);\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\n\tsnprintf(s->dev_path, sizeof(AUX_DEV_PATH) + dev_name_len, \"%s%s\", AUX_DEV_PATH,\n\t\t s->dev_name);\n\tdir = opendir(s->dev_path);\n\tif (!dir) {\n\t\tfprintf(stderr, \"Could not open directory '%s': %s\\n\", s->dev_path,\n\t\t\tstrerror(errno));\n\t\tfree(s->dev_path);\n\t\tfree(s->dev_name);\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\n\tif (chdir(s->dev_path) == -1) {\n\t\tperror(\"chdir\");\n\t\tfree(s->dev_path);\n\t\tfree(s->dev_name);\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\n\tif (read_sysfs_data(\"guid\", &guid)) {\n\t\tfree(s->dev_path);\n\t\tfree(s->dev_name);\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\n\ts->guid = guid;\n\n\treturn s;\n}\n\nstatic void sdsi_free_dev(struct sdsi_dev *s)\n{\n\tfree(s->dev_path);\n\tfree(s->dev_name);\n\tfree(s);\n}\n\nstatic void usage(char *prog)\n{\n\tprintf(\"Usage: %s [-l] [-d DEVNO [-i] [-s] [-m] [-a FILE] [-c FILE]]\\n\", prog);\n}\n\nstatic void show_help(void)\n{\n\tprintf(\"Commands:\\n\");\n\tprintf(\"  %-18s\\t%s\\n\", \"-l, --list\",           \"list available On Demand devices\");\n\tprintf(\"  %-18s\\t%s\\n\", \"-d, --devno DEVNO\",    \"On Demand device number\");\n\tprintf(\"  %-18s\\t%s\\n\", \"-i, --info\",           \"show socket information\");\n\tprintf(\"  %-18s\\t%s\\n\", \"-s, --state\",          \"show state certificate\");\n\tprintf(\"  %-18s\\t%s\\n\", \"-m, --meter\",          \"show meter certificate\");\n\tprintf(\"  %-18s\\t%s\\n\", \"-a, --akc FILE\",       \"provision socket with AKC FILE\");\n\tprintf(\"  %-18s\\t%s\\n\", \"-c, --cap FILE>\",      \"provision socket with CAP FILE\");\n}\n\nint main(int argc, char *argv[])\n{\n\tchar bin_file[PATH_MAX], *dev_no = NULL;\n\tbool device_selected = false;\n\tchar *progname;\n\tenum command command = -1;\n\tstruct sdsi_dev *s;\n\tint ret = 0, opt;\n\tint option_index = 0;\n\n\tstatic struct option long_options[] = {\n\t\t{\"akc\",\t\trequired_argument,\t0, 'a'},\n\t\t{\"cap\",\t\trequired_argument,\t0, 'c'},\n\t\t{\"devno\",\trequired_argument,\t0, 'd'},\n\t\t{\"help\",\tno_argument,\t\t0, 'h'},\n\t\t{\"info\",\tno_argument,\t\t0, 'i'},\n\t\t{\"list\",\tno_argument,\t\t0, 'l'},\n\t\t{\"meter\",\tno_argument,\t\t0, 'm'},\n\t\t{\"state\",\tno_argument,\t\t0, 's'},\n\t\t{0,\t\t0,\t\t\t0, 0 }\n\t};\n\n\n\tprogname = argv[0];\n\n\twhile ((opt = getopt_long_only(argc, argv, \"+a:c:d:hilms\", long_options,\n\t\t\t&option_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'd':\n\t\t\tdev_no = optarg;\n\t\t\tdevice_selected = true;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tsdsi_list_devices();\n\t\t\treturn 0;\n\t\tcase 'i':\n\t\t\tcommand = CMD_SOCKET_INFO;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcommand = CMD_METER_CERT;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcommand = CMD_STATE_CERT;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'c':\n\t\t\tif (!access(optarg, F_OK) == 0) {\n\t\t\t\tfprintf(stderr, \"Could not open file '%s': %s\\n\", optarg,\n\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!realpath(optarg, bin_file)) {\n\t\t\t\tperror(\"realpath\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcommand = (opt == 'a') ? CMD_PROV_AKC : CMD_PROV_CAP;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(progname);\n\t\t\tshow_help();\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tusage(progname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (device_selected) {\n\t\ts = sdsi_create_dev(dev_no);\n\t\tif (!s)\n\t\t\treturn -1;\n\n\t\tswitch (command) {\n\t\tcase CMD_SOCKET_INFO:\n\t\t\tret = sdsi_read_reg(s);\n\t\t\tbreak;\n\t\tcase CMD_METER_CERT:\n\t\t\tret = sdsi_meter_cert_show(s);\n\t\t\tbreak;\n\t\tcase CMD_STATE_CERT:\n\t\t\tret = sdsi_state_cert_show(s);\n\t\t\tbreak;\n\t\tcase CMD_PROV_AKC:\n\t\t\tret = sdsi_provision_akc(s, bin_file);\n\t\t\tbreak;\n\t\tcase CMD_PROV_CAP:\n\t\t\tret = sdsi_provision_cap(s, bin_file);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"No command specified\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tsdsi_free_dev(s);\n\n\t} else {\n\t\tfprintf(stderr, \"No device specified\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}