{
  "module_name": "insn.c",
  "hash_id": "a515cf5bfbc4701c645413b9f1ad2c602dd7f8ad72f3e7d9d50d932300b51f93",
  "original_prompt": "Ingested from linux-6.6.14/tools/arch/x86/lib/insn.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#ifdef __KERNEL__\n#include <linux/string.h>\n#else\n#include <string.h>\n#endif\n#include \"../include/asm/inat.h\"  \n#include \"../include/asm/insn.h\"  \n#include \"../include/asm-generic/unaligned.h\"  \n\n#include <linux/errno.h>\n#include <linux/kconfig.h>\n\n#include \"../include/asm/emulate_prefix.h\"  \n\n#define leXX_to_cpu(t, r)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__typeof__(t) v;\t\t\t\t\t\t\\\n\tswitch (sizeof(t)) {\t\t\t\t\t\t\\\n\tcase 4: v = le32_to_cpu(r); break;\t\t\t\t\\\n\tcase 2: v = le16_to_cpu(r); break;\t\t\t\t\\\n\tcase 1:\tv = r; break;\t\t\t\t\t\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\tBUILD_BUG(); break;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tv;\t\t\t\t\t\t\t\t\\\n})\n\n \n#define validate_next(t, insn, n)\t\\\n\t((insn)->next_byte + sizeof(t) + n <= (insn)->end_kaddr)\n\n#define __get_next(t, insn)\t\\\n\t({ t r = get_unaligned((t *)(insn)->next_byte); (insn)->next_byte += sizeof(t); leXX_to_cpu(t, r); })\n\n#define __peek_nbyte_next(t, insn, n)\t\\\n\t({ t r = get_unaligned((t *)(insn)->next_byte + n); leXX_to_cpu(t, r); })\n\n#define get_next(t, insn)\t\\\n\t({ if (unlikely(!validate_next(t, insn, 0))) goto err_out; __get_next(t, insn); })\n\n#define peek_nbyte_next(t, insn, n)\t\\\n\t({ if (unlikely(!validate_next(t, insn, n))) goto err_out; __peek_nbyte_next(t, insn, n); })\n\n#define peek_next(t, insn)\tpeek_nbyte_next(t, insn, 0)\n\n \nvoid insn_init(struct insn *insn, const void *kaddr, int buf_len, int x86_64)\n{\n\t \n\tif (buf_len > MAX_INSN_SIZE)\n\t\tbuf_len = MAX_INSN_SIZE;\n\n\tmemset(insn, 0, sizeof(*insn));\n\tinsn->kaddr = kaddr;\n\tinsn->end_kaddr = kaddr + buf_len;\n\tinsn->next_byte = kaddr;\n\tinsn->x86_64 = x86_64 ? 1 : 0;\n\tinsn->opnd_bytes = 4;\n\tif (x86_64)\n\t\tinsn->addr_bytes = 8;\n\telse\n\t\tinsn->addr_bytes = 4;\n}\n\nstatic const insn_byte_t xen_prefix[] = { __XEN_EMULATE_PREFIX };\nstatic const insn_byte_t kvm_prefix[] = { __KVM_EMULATE_PREFIX };\n\nstatic int __insn_get_emulate_prefix(struct insn *insn,\n\t\t\t\t     const insn_byte_t *prefix, size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (peek_nbyte_next(insn_byte_t, insn, i) != prefix[i])\n\t\t\tgoto err_out;\n\t}\n\n\tinsn->emulate_prefix_size = len;\n\tinsn->next_byte += len;\n\n\treturn 1;\n\nerr_out:\n\treturn 0;\n}\n\nstatic void insn_get_emulate_prefix(struct insn *insn)\n{\n\tif (__insn_get_emulate_prefix(insn, xen_prefix, sizeof(xen_prefix)))\n\t\treturn;\n\n\t__insn_get_emulate_prefix(insn, kvm_prefix, sizeof(kvm_prefix));\n}\n\n \nint insn_get_prefixes(struct insn *insn)\n{\n\tstruct insn_field *prefixes = &insn->prefixes;\n\tinsn_attr_t attr;\n\tinsn_byte_t b, lb;\n\tint i, nb;\n\n\tif (prefixes->got)\n\t\treturn 0;\n\n\tinsn_get_emulate_prefix(insn);\n\n\tnb = 0;\n\tlb = 0;\n\tb = peek_next(insn_byte_t, insn);\n\tattr = inat_get_opcode_attribute(b);\n\twhile (inat_is_legacy_prefix(attr)) {\n\t\t \n\t\tfor (i = 0; i < nb; i++)\n\t\t\tif (prefixes->bytes[i] == b)\n\t\t\t\tgoto found;\n\t\tif (nb == 4)\n\t\t\t \n\t\t\tbreak;\n\t\tprefixes->bytes[nb++] = b;\n\t\tif (inat_is_address_size_prefix(attr)) {\n\t\t\t \n\t\t\tif (insn->x86_64)\n\t\t\t\tinsn->addr_bytes ^= 12;\n\t\t\telse\n\t\t\t\tinsn->addr_bytes ^= 6;\n\t\t} else if (inat_is_operand_size_prefix(attr)) {\n\t\t\t \n\t\t\tinsn->opnd_bytes ^= 6;\n\t\t}\nfound:\n\t\tprefixes->nbytes++;\n\t\tinsn->next_byte++;\n\t\tlb = b;\n\t\tb = peek_next(insn_byte_t, insn);\n\t\tattr = inat_get_opcode_attribute(b);\n\t}\n\t \n\tif (lb && lb != insn->prefixes.bytes[3]) {\n\t\tif (unlikely(insn->prefixes.bytes[3])) {\n\t\t\t \n\t\t\tb = insn->prefixes.bytes[3];\n\t\t\tfor (i = 0; i < nb; i++)\n\t\t\t\tif (prefixes->bytes[i] == lb)\n\t\t\t\t\tinsn_set_byte(prefixes, i, b);\n\t\t}\n\t\tinsn_set_byte(&insn->prefixes, 3, lb);\n\t}\n\n\t \n\tif (insn->x86_64) {\n\t\tb = peek_next(insn_byte_t, insn);\n\t\tattr = inat_get_opcode_attribute(b);\n\t\tif (inat_is_rex_prefix(attr)) {\n\t\t\tinsn_field_set(&insn->rex_prefix, b, 1);\n\t\t\tinsn->next_byte++;\n\t\t\tif (X86_REX_W(b))\n\t\t\t\t \n\t\t\t\tinsn->opnd_bytes = 8;\n\t\t}\n\t}\n\tinsn->rex_prefix.got = 1;\n\n\t \n\tb = peek_next(insn_byte_t, insn);\n\tattr = inat_get_opcode_attribute(b);\n\tif (inat_is_vex_prefix(attr)) {\n\t\tinsn_byte_t b2 = peek_nbyte_next(insn_byte_t, insn, 1);\n\t\tif (!insn->x86_64) {\n\t\t\t \n\t\t\tif (X86_MODRM_MOD(b2) != 3)\n\t\t\t\tgoto vex_end;\n\t\t}\n\t\tinsn_set_byte(&insn->vex_prefix, 0, b);\n\t\tinsn_set_byte(&insn->vex_prefix, 1, b2);\n\t\tif (inat_is_evex_prefix(attr)) {\n\t\t\tb2 = peek_nbyte_next(insn_byte_t, insn, 2);\n\t\t\tinsn_set_byte(&insn->vex_prefix, 2, b2);\n\t\t\tb2 = peek_nbyte_next(insn_byte_t, insn, 3);\n\t\t\tinsn_set_byte(&insn->vex_prefix, 3, b2);\n\t\t\tinsn->vex_prefix.nbytes = 4;\n\t\t\tinsn->next_byte += 4;\n\t\t\tif (insn->x86_64 && X86_VEX_W(b2))\n\t\t\t\t \n\t\t\t\tinsn->opnd_bytes = 8;\n\t\t} else if (inat_is_vex3_prefix(attr)) {\n\t\t\tb2 = peek_nbyte_next(insn_byte_t, insn, 2);\n\t\t\tinsn_set_byte(&insn->vex_prefix, 2, b2);\n\t\t\tinsn->vex_prefix.nbytes = 3;\n\t\t\tinsn->next_byte += 3;\n\t\t\tif (insn->x86_64 && X86_VEX_W(b2))\n\t\t\t\t \n\t\t\t\tinsn->opnd_bytes = 8;\n\t\t} else {\n\t\t\t \n\t\t\tinsn_set_byte(&insn->vex_prefix, 2, b2 & 0x7f);\n\t\t\tinsn->vex_prefix.nbytes = 2;\n\t\t\tinsn->next_byte += 2;\n\t\t}\n\t}\nvex_end:\n\tinsn->vex_prefix.got = 1;\n\n\tprefixes->got = 1;\n\n\treturn 0;\n\nerr_out:\n\treturn -ENODATA;\n}\n\n \nint insn_get_opcode(struct insn *insn)\n{\n\tstruct insn_field *opcode = &insn->opcode;\n\tint pfx_id, ret;\n\tinsn_byte_t op;\n\n\tif (opcode->got)\n\t\treturn 0;\n\n\tif (!insn->prefixes.got) {\n\t\tret = insn_get_prefixes(insn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\top = get_next(insn_byte_t, insn);\n\tinsn_set_byte(opcode, 0, op);\n\topcode->nbytes = 1;\n\n\t \n\tif (insn_is_avx(insn)) {\n\t\tinsn_byte_t m, p;\n\t\tm = insn_vex_m_bits(insn);\n\t\tp = insn_vex_p_bits(insn);\n\t\tinsn->attr = inat_get_avx_attribute(op, m, p);\n\t\tif ((inat_must_evex(insn->attr) && !insn_is_evex(insn)) ||\n\t\t    (!inat_accept_vex(insn->attr) &&\n\t\t     !inat_is_group(insn->attr))) {\n\t\t\t \n\t\t\tinsn->attr = 0;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tgoto end;\n\t}\n\n\tinsn->attr = inat_get_opcode_attribute(op);\n\twhile (inat_is_escape(insn->attr)) {\n\t\t \n\t\top = get_next(insn_byte_t, insn);\n\t\topcode->bytes[opcode->nbytes++] = op;\n\t\tpfx_id = insn_last_prefix_id(insn);\n\t\tinsn->attr = inat_get_escape_attribute(op, pfx_id, insn->attr);\n\t}\n\n\tif (inat_must_vex(insn->attr)) {\n\t\t \n\t\tinsn->attr = 0;\n\t\treturn -EINVAL;\n\t}\nend:\n\topcode->got = 1;\n\treturn 0;\n\nerr_out:\n\treturn -ENODATA;\n}\n\n \nint insn_get_modrm(struct insn *insn)\n{\n\tstruct insn_field *modrm = &insn->modrm;\n\tinsn_byte_t pfx_id, mod;\n\tint ret;\n\n\tif (modrm->got)\n\t\treturn 0;\n\n\tif (!insn->opcode.got) {\n\t\tret = insn_get_opcode(insn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (inat_has_modrm(insn->attr)) {\n\t\tmod = get_next(insn_byte_t, insn);\n\t\tinsn_field_set(modrm, mod, 1);\n\t\tif (inat_is_group(insn->attr)) {\n\t\t\tpfx_id = insn_last_prefix_id(insn);\n\t\t\tinsn->attr = inat_get_group_attribute(mod, pfx_id,\n\t\t\t\t\t\t\t      insn->attr);\n\t\t\tif (insn_is_avx(insn) && !inat_accept_vex(insn->attr)) {\n\t\t\t\t \n\t\t\t\tinsn->attr = 0;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (insn->x86_64 && inat_is_force64(insn->attr))\n\t\tinsn->opnd_bytes = 8;\n\n\tmodrm->got = 1;\n\treturn 0;\n\nerr_out:\n\treturn -ENODATA;\n}\n\n\n \nint insn_rip_relative(struct insn *insn)\n{\n\tstruct insn_field *modrm = &insn->modrm;\n\tint ret;\n\n\tif (!insn->x86_64)\n\t\treturn 0;\n\n\tif (!modrm->got) {\n\t\tret = insn_get_modrm(insn);\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\t \n\treturn (modrm->nbytes && (modrm->bytes[0] & 0xc7) == 0x5);\n}\n\n \nint insn_get_sib(struct insn *insn)\n{\n\tinsn_byte_t modrm;\n\tint ret;\n\n\tif (insn->sib.got)\n\t\treturn 0;\n\n\tif (!insn->modrm.got) {\n\t\tret = insn_get_modrm(insn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (insn->modrm.nbytes) {\n\t\tmodrm = insn->modrm.bytes[0];\n\t\tif (insn->addr_bytes != 2 &&\n\t\t    X86_MODRM_MOD(modrm) != 3 && X86_MODRM_RM(modrm) == 4) {\n\t\t\tinsn_field_set(&insn->sib,\n\t\t\t\t       get_next(insn_byte_t, insn), 1);\n\t\t}\n\t}\n\tinsn->sib.got = 1;\n\n\treturn 0;\n\nerr_out:\n\treturn -ENODATA;\n}\n\n\n \nint insn_get_displacement(struct insn *insn)\n{\n\tinsn_byte_t mod, rm, base;\n\tint ret;\n\n\tif (insn->displacement.got)\n\t\treturn 0;\n\n\tif (!insn->sib.got) {\n\t\tret = insn_get_sib(insn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (insn->modrm.nbytes) {\n\t\t \n\t\tmod = X86_MODRM_MOD(insn->modrm.value);\n\t\trm = X86_MODRM_RM(insn->modrm.value);\n\t\tbase = X86_SIB_BASE(insn->sib.value);\n\t\tif (mod == 3)\n\t\t\tgoto out;\n\t\tif (mod == 1) {\n\t\t\tinsn_field_set(&insn->displacement,\n\t\t\t\t       get_next(signed char, insn), 1);\n\t\t} else if (insn->addr_bytes == 2) {\n\t\t\tif ((mod == 0 && rm == 6) || mod == 2) {\n\t\t\t\tinsn_field_set(&insn->displacement,\n\t\t\t\t\t       get_next(short, insn), 2);\n\t\t\t}\n\t\t} else {\n\t\t\tif ((mod == 0 && rm == 5) || mod == 2 ||\n\t\t\t    (mod == 0 && base == 5)) {\n\t\t\t\tinsn_field_set(&insn->displacement,\n\t\t\t\t\t       get_next(int, insn), 4);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tinsn->displacement.got = 1;\n\treturn 0;\n\nerr_out:\n\treturn -ENODATA;\n}\n\n \nstatic int __get_moffset(struct insn *insn)\n{\n\tswitch (insn->addr_bytes) {\n\tcase 2:\n\t\tinsn_field_set(&insn->moffset1, get_next(short, insn), 2);\n\t\tbreak;\n\tcase 4:\n\t\tinsn_field_set(&insn->moffset1, get_next(int, insn), 4);\n\t\tbreak;\n\tcase 8:\n\t\tinsn_field_set(&insn->moffset1, get_next(int, insn), 4);\n\t\tinsn_field_set(&insn->moffset2, get_next(int, insn), 4);\n\t\tbreak;\n\tdefault:\t \n\t\tgoto err_out;\n\t}\n\tinsn->moffset1.got = insn->moffset2.got = 1;\n\n\treturn 1;\n\nerr_out:\n\treturn 0;\n}\n\n \nstatic int __get_immv32(struct insn *insn)\n{\n\tswitch (insn->opnd_bytes) {\n\tcase 2:\n\t\tinsn_field_set(&insn->immediate, get_next(short, insn), 2);\n\t\tbreak;\n\tcase 4:\n\tcase 8:\n\t\tinsn_field_set(&insn->immediate, get_next(int, insn), 4);\n\t\tbreak;\n\tdefault:\t \n\t\tgoto err_out;\n\t}\n\n\treturn 1;\n\nerr_out:\n\treturn 0;\n}\n\n \nstatic int __get_immv(struct insn *insn)\n{\n\tswitch (insn->opnd_bytes) {\n\tcase 2:\n\t\tinsn_field_set(&insn->immediate1, get_next(short, insn), 2);\n\t\tbreak;\n\tcase 4:\n\t\tinsn_field_set(&insn->immediate1, get_next(int, insn), 4);\n\t\tinsn->immediate1.nbytes = 4;\n\t\tbreak;\n\tcase 8:\n\t\tinsn_field_set(&insn->immediate1, get_next(int, insn), 4);\n\t\tinsn_field_set(&insn->immediate2, get_next(int, insn), 4);\n\t\tbreak;\n\tdefault:\t \n\t\tgoto err_out;\n\t}\n\tinsn->immediate1.got = insn->immediate2.got = 1;\n\n\treturn 1;\nerr_out:\n\treturn 0;\n}\n\n \nstatic int __get_immptr(struct insn *insn)\n{\n\tswitch (insn->opnd_bytes) {\n\tcase 2:\n\t\tinsn_field_set(&insn->immediate1, get_next(short, insn), 2);\n\t\tbreak;\n\tcase 4:\n\t\tinsn_field_set(&insn->immediate1, get_next(int, insn), 4);\n\t\tbreak;\n\tcase 8:\n\t\t \n\t\treturn 0;\n\tdefault:\t \n\t\tgoto err_out;\n\t}\n\tinsn_field_set(&insn->immediate2, get_next(unsigned short, insn), 2);\n\tinsn->immediate1.got = insn->immediate2.got = 1;\n\n\treturn 1;\nerr_out:\n\treturn 0;\n}\n\n \nint insn_get_immediate(struct insn *insn)\n{\n\tint ret;\n\n\tif (insn->immediate.got)\n\t\treturn 0;\n\n\tif (!insn->displacement.got) {\n\t\tret = insn_get_displacement(insn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (inat_has_moffset(insn->attr)) {\n\t\tif (!__get_moffset(insn))\n\t\t\tgoto err_out;\n\t\tgoto done;\n\t}\n\n\tif (!inat_has_immediate(insn->attr))\n\t\t \n\t\tgoto done;\n\n\tswitch (inat_immediate_size(insn->attr)) {\n\tcase INAT_IMM_BYTE:\n\t\tinsn_field_set(&insn->immediate, get_next(signed char, insn), 1);\n\t\tbreak;\n\tcase INAT_IMM_WORD:\n\t\tinsn_field_set(&insn->immediate, get_next(short, insn), 2);\n\t\tbreak;\n\tcase INAT_IMM_DWORD:\n\t\tinsn_field_set(&insn->immediate, get_next(int, insn), 4);\n\t\tbreak;\n\tcase INAT_IMM_QWORD:\n\t\tinsn_field_set(&insn->immediate1, get_next(int, insn), 4);\n\t\tinsn_field_set(&insn->immediate2, get_next(int, insn), 4);\n\t\tbreak;\n\tcase INAT_IMM_PTR:\n\t\tif (!__get_immptr(insn))\n\t\t\tgoto err_out;\n\t\tbreak;\n\tcase INAT_IMM_VWORD32:\n\t\tif (!__get_immv32(insn))\n\t\t\tgoto err_out;\n\t\tbreak;\n\tcase INAT_IMM_VWORD:\n\t\tif (!__get_immv(insn))\n\t\t\tgoto err_out;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tgoto err_out;\n\t}\n\tif (inat_has_second_immediate(insn->attr)) {\n\t\tinsn_field_set(&insn->immediate2, get_next(signed char, insn), 1);\n\t}\ndone:\n\tinsn->immediate.got = 1;\n\treturn 0;\n\nerr_out:\n\treturn -ENODATA;\n}\n\n \nint insn_get_length(struct insn *insn)\n{\n\tint ret;\n\n\tif (insn->length)\n\t\treturn 0;\n\n\tif (!insn->immediate.got) {\n\t\tret = insn_get_immediate(insn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tinsn->length = (unsigned char)((unsigned long)insn->next_byte\n\t\t\t\t     - (unsigned long)insn->kaddr);\n\n\treturn 0;\n}\n\n \nstatic inline int insn_complete(struct insn *insn)\n{\n\treturn insn->opcode.got && insn->modrm.got && insn->sib.got &&\n\t\tinsn->displacement.got && insn->immediate.got;\n}\n\n \nint insn_decode(struct insn *insn, const void *kaddr, int buf_len, enum insn_mode m)\n{\n\tint ret;\n\n#define INSN_MODE_KERN (enum insn_mode)-1  \n\n\tif (m == INSN_MODE_KERN)\n\t\tinsn_init(insn, kaddr, buf_len, IS_ENABLED(CONFIG_X86_64));\n\telse\n\t\tinsn_init(insn, kaddr, buf_len, m == INSN_MODE_64);\n\n\tret = insn_get_length(insn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (insn_complete(insn))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}