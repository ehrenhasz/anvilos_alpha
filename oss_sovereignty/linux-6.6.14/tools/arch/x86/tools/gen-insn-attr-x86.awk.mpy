{
  "module_name": "gen-insn-attr-x86.awk",
  "hash_id": "6fed8f97a6e1395a377ffae9ded78b4acda718522c294f1f9dff0bf30a790f40",
  "original_prompt": "Ingested from linux-6.6.14/tools/arch/x86/tools/gen-insn-attr-x86.awk",
  "human_readable_source": "#!/bin/awk -f\n# SPDX-License-Identifier: GPL-2.0\n# gen-insn-attr-x86.awk: Instruction attribute table generator\n# Written by Masami Hiramatsu <mhiramat@redhat.com>\n#\n# Usage: awk -f gen-insn-attr-x86.awk x86-opcode-map.txt > inat-tables.c\n\n# Awk implementation sanity check\nfunction check_awk_implement() {\n\tif (sprintf(\"%x\", 0) != \"0\")\n\t\treturn \"Your awk has a printf-format problem.\"\n\treturn \"\"\n}\n\n# Clear working vars\nfunction clear_vars() {\n\tdelete table\n\tdelete lptable2\n\tdelete lptable1\n\tdelete lptable3\n\teid = -1 # escape id\n\tgid = -1 # group id\n\taid = -1 # AVX id\n\ttname = \"\"\n}\n\nBEGIN {\n\t# Implementation error checking\n\tawkchecked = check_awk_implement()\n\tif (awkchecked != \"\") {\n\t\tprint \"Error: \" awkchecked > \"/dev/stderr\"\n\t\tprint \"Please try to use gawk.\" > \"/dev/stderr\"\n\t\texit 1\n\t}\n\n\t# Setup generating tables\n\tprint \"/* x86 opcode map generated from x86-opcode-map.txt */\"\n\tprint \"/* Do not change this code. */\\n\"\n\tggid = 1\n\tgeid = 1\n\tgaid = 0\n\tdelete etable\n\tdelete gtable\n\tdelete atable\n\n\topnd_expr = \"^[A-Za-z/]\"\n\text_expr = \"^\\\\(\"\n\tsep_expr = \"^\\\\|$\"\n\tgroup_expr = \"^Grp[0-9A-Za-z]+\"\n\n\timm_expr = \"^[IJAOL][a-z]\"\n\timm_flag[\"Ib\"] = \"INAT_MAKE_IMM(INAT_IMM_BYTE)\"\n\timm_flag[\"Jb\"] = \"INAT_MAKE_IMM(INAT_IMM_BYTE)\"\n\timm_flag[\"Iw\"] = \"INAT_MAKE_IMM(INAT_IMM_WORD)\"\n\timm_flag[\"Id\"] = \"INAT_MAKE_IMM(INAT_IMM_DWORD)\"\n\timm_flag[\"Iq\"] = \"INAT_MAKE_IMM(INAT_IMM_QWORD)\"\n\timm_flag[\"Ap\"] = \"INAT_MAKE_IMM(INAT_IMM_PTR)\"\n\timm_flag[\"Iz\"] = \"INAT_MAKE_IMM(INAT_IMM_VWORD32)\"\n\timm_flag[\"Jz\"] = \"INAT_MAKE_IMM(INAT_IMM_VWORD32)\"\n\timm_flag[\"Iv\"] = \"INAT_MAKE_IMM(INAT_IMM_VWORD)\"\n\timm_flag[\"Ob\"] = \"INAT_MOFFSET\"\n\timm_flag[\"Ov\"] = \"INAT_MOFFSET\"\n\timm_flag[\"Lx\"] = \"INAT_MAKE_IMM(INAT_IMM_BYTE)\"\n\n\tmodrm_expr = \"^([CDEGMNPQRSUVW/][a-z]+|NTA|T[012])\"\n\tforce64_expr = \"\\\\([df]64\\\\)\"\n\trex_expr = \"^REX(\\\\.[XRWB]+)*\"\n\tfpu_expr = \"^ESC\" # TODO\n\n\tlprefix1_expr = \"\\\\((66|!F3)\\\\)\"\n\tlprefix2_expr = \"\\\\(F3\\\\)\"\n\tlprefix3_expr = \"\\\\((F2|!F3|66&F2)\\\\)\"\n\tlprefix_expr = \"\\\\((66|F2|F3)\\\\)\"\n\tmax_lprefix = 4\n\n\t# All opcodes starting with lower-case 'v', 'k' or with (v1) superscript\n\t# accepts VEX prefix\n\tvexok_opcode_expr = \"^[vk].*\"\n\tvexok_expr = \"\\\\(v1\\\\)\"\n\t# All opcodes with (v) superscript supports *only* VEX prefix\n\tvexonly_expr = \"\\\\(v\\\\)\"\n\t# All opcodes with (ev) superscript supports *only* EVEX prefix\n\tevexonly_expr = \"\\\\(ev\\\\)\"\n\n\tprefix_expr = \"\\\\(Prefix\\\\)\"\n\tprefix_num[\"Operand-Size\"] = \"INAT_PFX_OPNDSZ\"\n\tprefix_num[\"REPNE\"] = \"INAT_PFX_REPNE\"\n\tprefix_num[\"REP/REPE\"] = \"INAT_PFX_REPE\"\n\tprefix_num[\"XACQUIRE\"] = \"INAT_PFX_REPNE\"\n\tprefix_num[\"XRELEASE\"] = \"INAT_PFX_REPE\"\n\tprefix_num[\"LOCK\"] = \"INAT_PFX_LOCK\"\n\tprefix_num[\"SEG=CS\"] = \"INAT_PFX_CS\"\n\tprefix_num[\"SEG=DS\"] = \"INAT_PFX_DS\"\n\tprefix_num[\"SEG=ES\"] = \"INAT_PFX_ES\"\n\tprefix_num[\"SEG=FS\"] = \"INAT_PFX_FS\"\n\tprefix_num[\"SEG=GS\"] = \"INAT_PFX_GS\"\n\tprefix_num[\"SEG=SS\"] = \"INAT_PFX_SS\"\n\tprefix_num[\"Address-Size\"] = \"INAT_PFX_ADDRSZ\"\n\tprefix_num[\"VEX+1byte\"] = \"INAT_PFX_VEX2\"\n\tprefix_num[\"VEX+2byte\"] = \"INAT_PFX_VEX3\"\n\tprefix_num[\"EVEX\"] = \"INAT_PFX_EVEX\"\n\n\tclear_vars()\n}\n\nfunction semantic_error(msg) {\n\tprint \"Semantic error at \" NR \": \" msg > \"/dev/stderr\"\n\texit 1\n}\n\nfunction debug(msg) {\n\tprint \"DEBUG: \" msg\n}\n\nfunction array_size(arr,   i,c) {\n\tc = 0\n\tfor (i in arr)\n\t\tc++\n\treturn c\n}\n\n/^Table:/ {\n\tprint \"/* \" $0 \" */\"\n\tif (tname != \"\")\n\t\tsemantic_error(\"Hit Table: before EndTable:.\");\n}\n\n/^Referrer:/ {\n\tif (NF != 1) {\n\t\t# escape opcode table\n\t\tref = \"\"\n\t\tfor (i = 2; i <= NF; i++)\n\t\t\tref = ref $i\n\t\teid = escape[ref]\n\t\ttname = sprintf(\"inat_escape_table_%d\", eid)\n\t}\n}\n\n/^AVXcode:/ {\n\tif (NF != 1) {\n\t\t# AVX/escape opcode table\n\t\taid = $2\n\t\tif (gaid <= aid)\n\t\t\tgaid = aid + 1\n\t\tif (tname == \"\")\t# AVX only opcode table\n\t\t\ttname = sprintf(\"inat_avx_table_%d\", $2)\n\t}\n\tif (aid == -1 && eid == -1)\t# primary opcode table\n\t\ttname = \"inat_primary_table\"\n}\n\n/^GrpTable:/ {\n\tprint \"/* \" $0 \" */\"\n\tif (!($2 in group))\n\t\tsemantic_error(\"No group: \" $2 )\n\tgid = group[$2]\n\ttname = \"inat_group_table_\" gid\n}\n\nfunction print_table(tbl,name,fmt,n)\n{\n\tprint \"const insn_attr_t \" name \" = {\"\n\tfor (i = 0; i < n; i++) {\n\t\tid = sprintf(fmt, i)\n\t\tif (tbl[id])\n\t\t\tprint \"\t[\" id \"] = \" tbl[id] \",\"\n\t}\n\tprint \"};\"\n}\n\n/^EndTable/ {\n\tif (gid != -1) {\n\t\t# print group tables\n\t\tif (array_size(table) != 0) {\n\t\t\tprint_table(table, tname \"[INAT_GROUP_TABLE_SIZE]\",\n\t\t\t\t    \"0x%x\", 8)\n\t\t\tgtable[gid,0] = tname\n\t\t}\n\t\tif (array_size(lptable1) != 0) {\n\t\t\tprint_table(lptable1, tname \"_1[INAT_GROUP_TABLE_SIZE]\",\n\t\t\t\t    \"0x%x\", 8)\n\t\t\tgtable[gid,1] = tname \"_1\"\n\t\t}\n\t\tif (array_size(lptable2) != 0) {\n\t\t\tprint_table(lptable2, tname \"_2[INAT_GROUP_TABLE_SIZE]\",\n\t\t\t\t    \"0x%x\", 8)\n\t\t\tgtable[gid,2] = tname \"_2\"\n\t\t}\n\t\tif (array_size(lptable3) != 0) {\n\t\t\tprint_table(lptable3, tname \"_3[INAT_GROUP_TABLE_SIZE]\",\n\t\t\t\t    \"0x%x\", 8)\n\t\t\tgtable[gid,3] = tname \"_3\"\n\t\t}\n\t} else {\n\t\t# print primary/escaped tables\n\t\tif (array_size(table) != 0) {\n\t\t\tprint_table(table, tname \"[INAT_OPCODE_TABLE_SIZE]\",\n\t\t\t\t    \"0x%02x\", 256)\n\t\t\tetable[eid,0] = tname\n\t\t\tif (aid >= 0)\n\t\t\t\tatable[aid,0] = tname\n\t\t}\n\t\tif (array_size(lptable1) != 0) {\n\t\t\tprint_table(lptable1,tname \"_1[INAT_OPCODE_TABLE_SIZE]\",\n\t\t\t\t    \"0x%02x\", 256)\n\t\t\tetable[eid,1] = tname \"_1\"\n\t\t\tif (aid >= 0)\n\t\t\t\tatable[aid,1] = tname \"_1\"\n\t\t}\n\t\tif (array_size(lptable2) != 0) {\n\t\t\tprint_table(lptable2,tname \"_2[INAT_OPCODE_TABLE_SIZE]\",\n\t\t\t\t    \"0x%02x\", 256)\n\t\t\tetable[eid,2] = tname \"_2\"\n\t\t\tif (aid >= 0)\n\t\t\t\tatable[aid,2] = tname \"_2\"\n\t\t}\n\t\tif (array_size(lptable3) != 0) {\n\t\t\tprint_table(lptable3,tname \"_3[INAT_OPCODE_TABLE_SIZE]\",\n\t\t\t\t    \"0x%02x\", 256)\n\t\t\tetable[eid,3] = tname \"_3\"\n\t\t\tif (aid >= 0)\n\t\t\t\tatable[aid,3] = tname \"_3\"\n\t\t}\n\t}\n\tprint \"\"\n\tclear_vars()\n}\n\nfunction add_flags(old,new) {\n\tif (old && new)\n\t\treturn old \" | \" new\n\telse if (old)\n\t\treturn old\n\telse\n\t\treturn new\n}\n\n# convert operands to flags.\nfunction convert_operands(count,opnd,       i,j,imm,mod)\n{\n\timm = null\n\tmod = null\n\tfor (j = 1; j <= count; j++) {\n\t\ti = opnd[j]\n\t\tif (match(i, imm_expr) == 1) {\n\t\t\tif (!imm_flag[i])\n\t\t\t\tsemantic_error(\"Unknown imm opnd: \" i)\n\t\t\tif (imm) {\n\t\t\t\tif (i != \"Ib\")\n\t\t\t\t\tsemantic_error(\"Second IMM error\")\n\t\t\t\timm = add_flags(imm, \"INAT_SCNDIMM\")\n\t\t\t} else\n\t\t\t\timm = imm_flag[i]\n\t\t} else if (match(i, modrm_expr))\n\t\t\tmod = \"INAT_MODRM\"\n\t}\n\treturn add_flags(imm, mod)\n}\n\n/^[0-9a-f]+:/ {\n\tif (NR == 1)\n\t\tnext\n\t# get index\n\tidx = \"0x\" substr($1, 1, index($1,\":\") - 1)\n\tif (idx in table)\n\t\tsemantic_error(\"Redefine \" idx \" in \" tname)\n\n\t# check if escaped opcode\n\tif (\"escape\" == $2) {\n\t\tif ($3 != \"#\")\n\t\t\tsemantic_error(\"No escaped name\")\n\t\tref = \"\"\n\t\tfor (i = 4; i <= NF; i++)\n\t\t\tref = ref $i\n\t\tif (ref in escape)\n\t\t\tsemantic_error(\"Redefine escape (\" ref \")\")\n\t\tescape[ref] = geid\n\t\tgeid++\n\t\ttable[idx] = \"INAT_MAKE_ESCAPE(\" escape[ref] \")\"\n\t\tnext\n\t}\n\n\tvariant = null\n\t# converts\n\ti = 2\n\twhile (i <= NF) {\n\t\topcode = $(i++)\n\t\tdelete opnds\n\t\text = null\n\t\tflags = null\n\t\topnd = null\n\t\t# parse one opcode\n\t\tif (match($i, opnd_expr)) {\n\t\t\topnd = $i\n\t\t\tcount = split($(i++), opnds, \",\")\n\t\t\tflags = convert_operands(count, opnds)\n\t\t}\n\t\tif (match($i, ext_expr))\n\t\t\text = $(i++)\n\t\tif (match($i, sep_expr))\n\t\t\ti++\n\t\telse if (i < NF)\n\t\t\tsemantic_error($i \" is not a separator\")\n\n\t\t# check if group opcode\n\t\tif (match(opcode, group_expr)) {\n\t\t\tif (!(opcode in group)) {\n\t\t\t\tgroup[opcode] = ggid\n\t\t\t\tggid++\n\t\t\t}\n\t\t\tflags = add_flags(flags, \"INAT_MAKE_GROUP(\" group[opcode] \")\")\n\t\t}\n\t\t# check force(or default) 64bit\n\t\tif (match(ext, force64_expr))\n\t\t\tflags = add_flags(flags, \"INAT_FORCE64\")\n\n\t\t# check REX prefix\n\t\tif (match(opcode, rex_expr))\n\t\t\tflags = add_flags(flags, \"INAT_MAKE_PREFIX(INAT_PFX_REX)\")\n\n\t\t# check coprocessor escape : TODO\n\t\tif (match(opcode, fpu_expr))\n\t\t\tflags = add_flags(flags, \"INAT_MODRM\")\n\n\t\t# check VEX codes\n\t\tif (match(ext, evexonly_expr))\n\t\t\tflags = add_flags(flags, \"INAT_VEXOK | INAT_EVEXONLY\")\n\t\telse if (match(ext, vexonly_expr))\n\t\t\tflags = add_flags(flags, \"INAT_VEXOK | INAT_VEXONLY\")\n\t\telse if (match(ext, vexok_expr) || match(opcode, vexok_opcode_expr))\n\t\t\tflags = add_flags(flags, \"INAT_VEXOK\")\n\n\t\t# check prefixes\n\t\tif (match(ext, prefix_expr)) {\n\t\t\tif (!prefix_num[opcode])\n\t\t\t\tsemantic_error(\"Unknown prefix: \" opcode)\n\t\t\tflags = add_flags(flags, \"INAT_MAKE_PREFIX(\" prefix_num[opcode] \")\")\n\t\t}\n\t\tif (length(flags) == 0)\n\t\t\tcontinue\n\t\t# check if last prefix\n\t\tif (match(ext, lprefix1_expr)) {\n\t\t\tlptable1[idx] = add_flags(lptable1[idx],flags)\n\t\t\tvariant = \"INAT_VARIANT\"\n\t\t}\n\t\tif (match(ext, lprefix2_expr)) {\n\t\t\tlptable2[idx] = add_flags(lptable2[idx],flags)\n\t\t\tvariant = \"INAT_VARIANT\"\n\t\t}\n\t\tif (match(ext, lprefix3_expr)) {\n\t\t\tlptable3[idx] = add_flags(lptable3[idx],flags)\n\t\t\tvariant = \"INAT_VARIANT\"\n\t\t}\n\t\tif (!match(ext, lprefix_expr)){\n\t\t\ttable[idx] = add_flags(table[idx],flags)\n\t\t}\n\t}\n\tif (variant)\n\t\ttable[idx] = add_flags(table[idx],variant)\n}\n\nEND {\n\tif (awkchecked != \"\")\n\t\texit 1\n\n\tprint \"#ifndef __BOOT_COMPRESSED\\n\"\n\n\t# print escape opcode map's array\n\tprint \"/* Escape opcode map array */\"\n\tprint \"const insn_attr_t * const inat_escape_tables[INAT_ESC_MAX + 1]\" \\\n\t      \"[INAT_LSTPFX_MAX + 1] = {\"\n\tfor (i = 0; i < geid; i++)\n\t\tfor (j = 0; j < max_lprefix; j++)\n\t\t\tif (etable[i,j])\n\t\t\t\tprint \"\t[\"i\"][\"j\"] = \"etable[i,j]\",\"\n\tprint \"};\\n\"\n\t# print group opcode map's array\n\tprint \"/* Group opcode map array */\"\n\tprint \"const insn_attr_t * const inat_group_tables[INAT_GRP_MAX + 1]\"\\\n\t      \"[INAT_LSTPFX_MAX + 1] = {\"\n\tfor (i = 0; i < ggid; i++)\n\t\tfor (j = 0; j < max_lprefix; j++)\n\t\t\tif (gtable[i,j])\n\t\t\t\tprint \"\t[\"i\"][\"j\"] = \"gtable[i,j]\",\"\n\tprint \"};\\n\"\n\t# print AVX opcode map's array\n\tprint \"/* AVX opcode map array */\"\n\tprint \"const insn_attr_t * const inat_avx_tables[X86_VEX_M_MAX + 1]\"\\\n\t      \"[INAT_LSTPFX_MAX + 1] = {\"\n\tfor (i = 0; i < gaid; i++)\n\t\tfor (j = 0; j < max_lprefix; j++)\n\t\t\tif (atable[i,j])\n\t\t\t\tprint \"\t[\"i\"][\"j\"] = \"atable[i,j]\",\"\n\tprint \"};\\n\"\n\n\tprint \"#else /* !__BOOT_COMPRESSED */\\n\"\n\n\tprint \"/* Escape opcode map array */\"\n\tprint \"static const insn_attr_t *inat_escape_tables[INAT_ESC_MAX + 1]\" \\\n\t      \"[INAT_LSTPFX_MAX + 1];\"\n\tprint \"\"\n\n\tprint \"/* Group opcode map array */\"\n\tprint \"static const insn_attr_t *inat_group_tables[INAT_GRP_MAX + 1]\"\\\n\t      \"[INAT_LSTPFX_MAX + 1];\"\n\tprint \"\"\n\n\tprint \"/* AVX opcode map array */\"\n\tprint \"static const insn_attr_t *inat_avx_tables[X86_VEX_M_MAX + 1]\"\\\n\t      \"[INAT_LSTPFX_MAX + 1];\"\n\tprint \"\"\n\n\tprint \"static void inat_init_tables(void)\"\n\tprint \"{\"\n\n\t# print escape opcode map's array\n\tprint \"\\t/* Print Escape opcode map array */\"\n\tfor (i = 0; i < geid; i++)\n\t\tfor (j = 0; j < max_lprefix; j++)\n\t\t\tif (etable[i,j])\n\t\t\t\tprint \"\\tinat_escape_tables[\"i\"][\"j\"] = \"etable[i,j]\";\"\n\tprint \"\"\n\n\t# print group opcode map's array\n\tprint \"\\t/* Print Group opcode map array */\"\n\tfor (i = 0; i < ggid; i++)\n\t\tfor (j = 0; j < max_lprefix; j++)\n\t\t\tif (gtable[i,j])\n\t\t\t\tprint \"\\tinat_group_tables[\"i\"][\"j\"] = \"gtable[i,j]\";\"\n\tprint \"\"\n\t# print AVX opcode map's array\n\tprint \"\\t/* Print AVX opcode map array */\"\n\tfor (i = 0; i < gaid; i++)\n\t\tfor (j = 0; j < max_lprefix; j++)\n\t\t\tif (atable[i,j])\n\t\t\t\tprint \"\\tinat_avx_tables[\"i\"][\"j\"] = \"atable[i,j]\";\"\n\n\tprint \"}\"\n\tprint \"#endif\"\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}