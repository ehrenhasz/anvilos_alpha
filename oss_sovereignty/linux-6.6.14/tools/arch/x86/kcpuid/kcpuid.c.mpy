{
  "module_name": "kcpuid.c",
  "hash_id": "faf782b1b9b0a806a28def4ff290fe23efb0e14500f0fda0897ea69e184e7b93",
  "original_prompt": "Ingested from linux-6.6.14/tools/arch/x86/kcpuid/kcpuid.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\nchar *def_csv = \"/usr/share/misc/cpuid.csv\";\nchar *user_csv;\n\n\n \nstruct bits_desc {\n\t \n\tint start, end;\n\t \n\tint value;\n\tchar simp[32];\n\tchar detail[256];\n};\n\n \nstruct reg_desc {\n\t \n\tint nr;\n\tstruct bits_desc descs[32];\n};\n\nenum cpuid_reg {\n\tR_EAX = 0,\n\tR_EBX,\n\tR_ECX,\n\tR_EDX,\n\tNR_REGS\n};\n\nstatic const char * const reg_names[] = {\n\t\"EAX\", \"EBX\", \"ECX\", \"EDX\",\n};\n\nstruct subleaf {\n\tu32 index;\n\tu32 sub;\n\tu32 eax, ebx, ecx, edx;\n\tstruct reg_desc info[NR_REGS];\n};\n\n \nstruct cpuid_func {\n\t \n\tstruct subleaf *leafs;\n\tint nr;\n};\n\nstruct cpuid_range {\n\t \n\tstruct cpuid_func *funcs;\n\t \n\tint nr;\n\tbool is_ext;\n};\n\n \nstruct cpuid_range *leafs_basic, *leafs_ext;\n\nstatic int num_leafs;\nstatic bool is_amd;\nstatic bool show_details;\nstatic bool show_raw;\nstatic bool show_flags_only = true;\nstatic u32 user_index = 0xFFFFFFFF;\nstatic u32 user_sub = 0xFFFFFFFF;\nstatic int flines;\n\nstatic inline void cpuid(u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\t \n\tasm volatile(\"cpuid\"\n\t    : \"=a\" (*eax),\n\t      \"=b\" (*ebx),\n\t      \"=c\" (*ecx),\n\t      \"=d\" (*edx)\n\t    : \"0\" (*eax), \"2\" (*ecx));\n}\n\nstatic inline bool has_subleafs(u32 f)\n{\n\tif (f == 0x7 || f == 0xd)\n\t\treturn true;\n\n\tif (is_amd) {\n\t\tif (f == 0x8000001d)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tswitch (f) {\n\tcase 0x4:\n\tcase 0xb:\n\tcase 0xf:\n\tcase 0x10:\n\tcase 0x14:\n\tcase 0x18:\n\tcase 0x1f:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void leaf_print_raw(struct subleaf *leaf)\n{\n\tif (has_subleafs(leaf->index)) {\n\t\tif (leaf->sub == 0)\n\t\t\tprintf(\"0x%08x: subleafs:\\n\", leaf->index);\n\n\t\tprintf(\" %2d: EAX=0x%08x, EBX=0x%08x, ECX=0x%08x, EDX=0x%08x\\n\",\n\t\t\tleaf->sub, leaf->eax, leaf->ebx, leaf->ecx, leaf->edx);\n\t} else {\n\t\tprintf(\"0x%08x: EAX=0x%08x, EBX=0x%08x, ECX=0x%08x, EDX=0x%08x\\n\",\n\t\t\tleaf->index, leaf->eax, leaf->ebx, leaf->ecx, leaf->edx);\n\t}\n}\n\n \nstatic bool cpuid_store(struct cpuid_range *range, u32 f, int subleaf,\n\t\t\tu32 a, u32 b, u32 c, u32 d)\n{\n\tstruct cpuid_func *func;\n\tstruct subleaf *leaf;\n\tint s = 0;\n\n\tif (a == 0 && b == 0 && c == 0 && d == 0)\n\t\treturn true;\n\n\t \n\tfunc = &range->funcs[f & 0xffff];\n\n\tif (!func->leafs) {\n\t\tfunc->leafs = malloc(sizeof(struct subleaf));\n\t\tif (!func->leafs)\n\t\t\tperror(\"malloc func leaf\");\n\n\t\tfunc->nr = 1;\n\t} else {\n\t\ts = func->nr;\n\t\tfunc->leafs = realloc(func->leafs, (s + 1) * sizeof(*leaf));\n\t\tif (!func->leafs)\n\t\t\tperror(\"realloc f->leafs\");\n\n\t\tfunc->nr++;\n\t}\n\n\tleaf = &func->leafs[s];\n\n\tleaf->index = f;\n\tleaf->sub = subleaf;\n\tleaf->eax = a;\n\tleaf->ebx = b;\n\tleaf->ecx = c;\n\tleaf->edx = d;\n\n\treturn false;\n}\n\nstatic void raw_dump_range(struct cpuid_range *range)\n{\n\tu32 f;\n\tint i;\n\n\tprintf(\"%s Leafs :\\n\", range->is_ext ? \"Extended\" : \"Basic\");\n\tprintf(\"================\\n\");\n\n\tfor (f = 0; (int)f < range->nr; f++) {\n\t\tstruct cpuid_func *func = &range->funcs[f];\n\t\tu32 index = f;\n\n\t\tif (range->is_ext)\n\t\t\tindex += 0x80000000;\n\n\t\t \n\t\tif (!func->nr)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (i = 0; i < func->nr; i++)\n\t\t\tleaf_print_raw(&func->leafs[i]);\n\t}\n}\n\n#define MAX_SUBLEAF_NUM\t\t32\nstruct cpuid_range *setup_cpuid_range(u32 input_eax)\n{\n\tu32 max_func, idx_func;\n\tint subleaf;\n\tstruct cpuid_range *range;\n\tu32 eax, ebx, ecx, edx;\n\tu32 f = input_eax;\n\tint max_subleaf;\n\tbool allzero;\n\n\teax = input_eax;\n\tebx = ecx = edx = 0;\n\n\tcpuid(&eax, &ebx, &ecx, &edx);\n\tmax_func = eax;\n\tidx_func = (max_func & 0xffff) + 1;\n\n\trange = malloc(sizeof(struct cpuid_range));\n\tif (!range)\n\t\tperror(\"malloc range\");\n\n\tif (input_eax & 0x80000000)\n\t\trange->is_ext = true;\n\telse\n\t\trange->is_ext = false;\n\n\trange->funcs = malloc(sizeof(struct cpuid_func) * idx_func);\n\tif (!range->funcs)\n\t\tperror(\"malloc range->funcs\");\n\n\trange->nr = idx_func;\n\tmemset(range->funcs, 0, sizeof(struct cpuid_func) * idx_func);\n\n\tfor (; f <= max_func; f++) {\n\t\teax = f;\n\t\tsubleaf = ecx = 0;\n\n\t\tcpuid(&eax, &ebx, &ecx, &edx);\n\t\tallzero = cpuid_store(range, f, subleaf, eax, ebx, ecx, edx);\n\t\tif (allzero)\n\t\t\tcontinue;\n\t\tnum_leafs++;\n\n\t\tif (!has_subleafs(f))\n\t\t\tcontinue;\n\n\t\tmax_subleaf = MAX_SUBLEAF_NUM;\n\n\t\t \n\t\tif (f == 0x7 || f == 0x14 || f == 0x17 || f == 0x18)\n\t\t\tmax_subleaf = (eax & 0xff) + 1;\n\n\t\tif (f == 0xb)\n\t\t\tmax_subleaf = 2;\n\n\t\tfor (subleaf = 1; subleaf < max_subleaf; subleaf++) {\n\t\t\teax = f;\n\t\t\tecx = subleaf;\n\n\t\t\tcpuid(&eax, &ebx, &ecx, &edx);\n\t\t\tallzero = cpuid_store(range, f, subleaf,\n\t\t\t\t\t\teax, ebx, ecx, edx);\n\t\t\tif (allzero)\n\t\t\t\tcontinue;\n\t\t\tnum_leafs++;\n\t\t}\n\n\t}\n\n\treturn range;\n}\n\n \nstatic int parse_line(char *line)\n{\n\tchar *str;\n\tint i;\n\tstruct cpuid_range *range;\n\tstruct cpuid_func *func;\n\tstruct subleaf *leaf;\n\tu32 index;\n\tu32 sub;\n\tchar buffer[512];\n\tchar *buf;\n\t \n\tchar *tokens[6];\n\tstruct reg_desc *reg;\n\tstruct bits_desc *bdesc;\n\tint reg_index;\n\tchar *start, *end;\n\n\t \n\tif (line[0] == '#' || line[0] == '\\n')\n\t\treturn 0;\n\n\tstrncpy(buffer, line, 511);\n\tbuffer[511] = 0;\n\tstr = buffer;\n\tfor (i = 0; i < 5; i++) {\n\t\ttokens[i] = strtok(str, \",\");\n\t\tif (!tokens[i])\n\t\t\tgoto err_exit;\n\t\tstr = NULL;\n\t}\n\ttokens[5] = strtok(str, \"\\n\");\n\tif (!tokens[5])\n\t\tgoto err_exit;\n\n\t \n\tindex = strtoull(tokens[0], NULL, 0);\n\n\tif (index & 0x80000000)\n\t\trange = leafs_ext;\n\telse\n\t\trange = leafs_basic;\n\n\tindex &= 0x7FFFFFFF;\n\t \n\tif ((int)index >= range->nr)\n\t\treturn -1;\n\n\tfunc = &range->funcs[index];\n\n\t \n\tif (!func->nr)\n\t\treturn 0;\n\n\t \n\tsub = strtoul(tokens[1], NULL, 0);\n\tif ((int)sub > func->nr)\n\t\treturn -1;\n\n\tleaf = &func->leafs[sub];\n\tbuf = tokens[2];\n\n\tif (strcasestr(buf, \"EAX\"))\n\t\treg_index = R_EAX;\n\telse if (strcasestr(buf, \"EBX\"))\n\t\treg_index = R_EBX;\n\telse if (strcasestr(buf, \"ECX\"))\n\t\treg_index = R_ECX;\n\telse if (strcasestr(buf, \"EDX\"))\n\t\treg_index = R_EDX;\n\telse\n\t\tgoto err_exit;\n\n\treg = &leaf->info[reg_index];\n\tbdesc = &reg->descs[reg->nr++];\n\n\t \n\tbuf = tokens[3];\n\n\tend = strtok(buf, \":\");\n\tbdesc->end = strtoul(end, NULL, 0);\n\tbdesc->start = bdesc->end;\n\n\t \n\tstart = strtok(NULL, \":\");\n\tif (start)\n\t\tbdesc->start = strtoul(start, NULL, 0);\n\n\tstrcpy(bdesc->simp, tokens[4]);\n\tstrcpy(bdesc->detail, tokens[5]);\n\treturn 0;\n\nerr_exit:\n\tprintf(\"Warning: wrong line format:\\n\");\n\tprintf(\"\\tline[%d]: %s\\n\", flines, line);\n\treturn -1;\n}\n\n \nstatic void parse_text(void)\n{\n\tFILE *file;\n\tchar *filename, *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\n\tif (show_raw)\n\t\treturn;\n\n\tfilename = user_csv ? user_csv : def_csv;\n\tfile = fopen(filename, \"r\");\n\tif (!file) {\n\t\t \n\t\tfile = fopen(\"./cpuid.csv\", \"r\");\n\t}\n\n\tif (!file) {\n\t\tprintf(\"Fail to open '%s'\\n\", filename);\n\t\treturn;\n\t}\n\n\twhile (1) {\n\t\tret = getline(&line, &len, file);\n\t\tflines++;\n\t\tif (ret > 0)\n\t\t\tparse_line(line);\n\n\t\tif (feof(file))\n\t\t\tbreak;\n\t}\n\n\tfclose(file);\n}\n\n\n \nstatic void decode_bits(u32 value, struct reg_desc *rdesc, enum cpuid_reg reg)\n{\n\tstruct bits_desc *bdesc;\n\tint start, end, i;\n\tu32 mask;\n\n\tif (!rdesc->nr) {\n\t\tif (show_details)\n\t\t\tprintf(\"\\t %s: 0x%08x\\n\", reg_names[reg], value);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < rdesc->nr; i++) {\n\t\tbdesc = &rdesc->descs[i];\n\n\t\tstart = bdesc->start;\n\t\tend = bdesc->end;\n\t\tif (start == end) {\n\t\t\t \n\t\t\tif (value & (1 << start))\n\t\t\t\tprintf(\"\\t%-20s %s%s\\n\",\n\t\t\t\t\tbdesc->simp,\n\t\t\t\t\tshow_details ? \"-\" : \"\",\n\t\t\t\t\tshow_details ? bdesc->detail : \"\"\n\t\t\t\t\t);\n\t\t} else {\n\t\t\t \n\t\t\tif (show_flags_only)\n\t\t\t\tcontinue;\n\n\t\t\tmask = ((u64)1 << (end - start + 1)) - 1;\n\t\t\tprintf(\"\\t%-20s\\t: 0x%-8x\\t%s%s\\n\",\n\t\t\t\t\tbdesc->simp,\n\t\t\t\t\t(value >> start) & mask,\n\t\t\t\t\tshow_details ? \"-\" : \"\",\n\t\t\t\t\tshow_details ? bdesc->detail : \"\"\n\t\t\t\t\t);\n\t\t}\n\t}\n}\n\nstatic void show_leaf(struct subleaf *leaf)\n{\n\tif (!leaf)\n\t\treturn;\n\n\tif (show_raw) {\n\t\tleaf_print_raw(leaf);\n\t} else {\n\t\tif (show_details)\n\t\t\tprintf(\"CPUID_0x%x_ECX[0x%x]:\\n\",\n\t\t\t\tleaf->index, leaf->sub);\n\t}\n\n\tdecode_bits(leaf->eax, &leaf->info[R_EAX], R_EAX);\n\tdecode_bits(leaf->ebx, &leaf->info[R_EBX], R_EBX);\n\tdecode_bits(leaf->ecx, &leaf->info[R_ECX], R_ECX);\n\tdecode_bits(leaf->edx, &leaf->info[R_EDX], R_EDX);\n\n\tif (!show_raw && show_details)\n\t\tprintf(\"\\n\");\n}\n\nstatic void show_func(struct cpuid_func *func)\n{\n\tint i;\n\n\tif (!func)\n\t\treturn;\n\n\tfor (i = 0; i < func->nr; i++)\n\t\tshow_leaf(&func->leafs[i]);\n}\n\nstatic void show_range(struct cpuid_range *range)\n{\n\tint i;\n\n\tfor (i = 0; i < range->nr; i++)\n\t\tshow_func(&range->funcs[i]);\n}\n\nstatic inline struct cpuid_func *index_to_func(u32 index)\n{\n\tstruct cpuid_range *range;\n\tu32 func_idx;\n\n\trange = (index & 0x80000000) ? leafs_ext : leafs_basic;\n\tfunc_idx = index & 0xffff;\n\n\tif ((func_idx + 1) > (u32)range->nr) {\n\t\tprintf(\"ERR: invalid input index (0x%x)\\n\", index);\n\t\treturn NULL;\n\t}\n\treturn &range->funcs[func_idx];\n}\n\nstatic void show_info(void)\n{\n\tstruct cpuid_func *func;\n\n\tif (show_raw) {\n\t\t \n\t\traw_dump_range(leafs_basic);\n\t\traw_dump_range(leafs_ext);\n\t\treturn;\n\t}\n\n\tif (user_index != 0xFFFFFFFF) {\n\t\t \n\t\tfunc = index_to_func(user_index);\n\t\tif (!func)\n\t\t\treturn;\n\n\t\t \n\t\tshow_raw = true;\n\n\t\tif (user_sub != 0xFFFFFFFF) {\n\t\t\tif (user_sub + 1 <= (u32)func->nr) {\n\t\t\t\tshow_leaf(&func->leafs[user_sub]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprintf(\"ERR: invalid input subleaf (0x%x)\\n\", user_sub);\n\t\t}\n\n\t\tshow_func(func);\n\t\treturn;\n\t}\n\n\tprintf(\"CPU features:\\n=============\\n\\n\");\n\tshow_range(leafs_basic);\n\tshow_range(leafs_ext);\n}\n\nstatic void setup_platform_cpuid(void)\n{\n\t u32 eax, ebx, ecx, edx;\n\n\t \n\teax = ebx = ecx = edx = 0;\n\tcpuid(&eax, &ebx, &ecx, &edx);\n\n\t \n\tif (ebx == 0x68747541)\n\t\tis_amd = true;\n\n\t \n\tleafs_basic = setup_cpuid_range(0x0);\n\tleafs_ext = setup_cpuid_range(0x80000000);\n}\n\nstatic void usage(void)\n{\n\tprintf(\"kcpuid [-abdfhr] [-l leaf] [-s subleaf]\\n\"\n\t\t\"\\t-a|--all             Show both bit flags and complex bit fields info\\n\"\n\t\t\"\\t-b|--bitflags        Show boolean flags only\\n\"\n\t\t\"\\t-d|--detail          Show details of the flag/fields (default)\\n\"\n\t\t\"\\t-f|--flags           Specify the cpuid csv file\\n\"\n\t\t\"\\t-h|--help            Show usage info\\n\"\n\t\t\"\\t-l|--leaf=index      Specify the leaf you want to check\\n\"\n\t\t\"\\t-r|--raw             Show raw cpuid data\\n\"\n\t\t\"\\t-s|--subleaf=sub     Specify the subleaf you want to check\\n\"\n\t);\n}\n\nstatic struct option opts[] = {\n\t{ \"all\", no_argument, NULL, 'a' },\t\t \n\t{ \"bitflags\", no_argument, NULL, 'b' },\t\t \n\t{ \"detail\", no_argument, NULL, 'd' },\t\t \n\t{ \"file\", required_argument, NULL, 'f' },\t \n\t{ \"help\", no_argument, NULL, 'h'},\t\t \n\t{ \"leaf\", required_argument, NULL, 'l'},\t \n\t{ \"raw\", no_argument, NULL, 'r'},\t\t \n\t{ \"subleaf\", required_argument, NULL, 's'},\t \n\t{ NULL, 0, NULL, 0 }\n};\n\nstatic int parse_options(int argc, char *argv[])\n{\n\tint c;\n\n\twhile ((c = getopt_long(argc, argv, \"abdf:hl:rs:\",\n\t\t\t\t\topts, NULL)) != -1)\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tshow_flags_only = false;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tshow_flags_only = true;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tshow_details = true;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tuser_csv = optarg;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\texit(1);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t \n\t\t\tuser_index = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tshow_raw = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\t \n\t\t\tuser_sub = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"%s: Invalid option '%c'\\n\", argv[0], optopt);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nint main(int argc, char *argv[])\n{\n\tif (parse_options(argc, argv))\n\t\treturn -1;\n\n\t \n\tsetup_platform_cpuid();\n\n\t \n\tparse_text();\n\n\tshow_info();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}