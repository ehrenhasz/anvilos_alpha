{
  "module_name": "insn.h",
  "hash_id": "7f311b888c1c16816dfb23e7c82625f445cf4873523fbe0e3f82cae01cbb461b",
  "original_prompt": "Ingested from linux-6.6.14/tools/arch/x86/include/asm/insn.h",
  "human_readable_source": " \n#ifndef _ASM_X86_INSN_H\n#define _ASM_X86_INSN_H\n \n\n#include <asm/byteorder.h>\n \n#include \"inat.h\"  \n\n#if defined(__BYTE_ORDER) ? __BYTE_ORDER == __LITTLE_ENDIAN : defined(__LITTLE_ENDIAN)\n\nstruct insn_field {\n\tunion {\n\t\tinsn_value_t value;\n\t\tinsn_byte_t bytes[4];\n\t};\n\t \n\tunsigned char got;\n\tunsigned char nbytes;\n};\n\nstatic inline void insn_field_set(struct insn_field *p, insn_value_t v,\n\t\t\t\t  unsigned char n)\n{\n\tp->value = v;\n\tp->nbytes = n;\n}\n\nstatic inline void insn_set_byte(struct insn_field *p, unsigned char n,\n\t\t\t\t insn_byte_t v)\n{\n\tp->bytes[n] = v;\n}\n\n#else\n\nstruct insn_field {\n\tinsn_value_t value;\n\tunion {\n\t\tinsn_value_t little;\n\t\tinsn_byte_t bytes[4];\n\t};\n\t \n\tunsigned char got;\n\tunsigned char nbytes;\n};\n\nstatic inline void insn_field_set(struct insn_field *p, insn_value_t v,\n\t\t\t\t  unsigned char n)\n{\n\tp->value = v;\n\tp->little = __cpu_to_le32(v);\n\tp->nbytes = n;\n}\n\nstatic inline void insn_set_byte(struct insn_field *p, unsigned char n,\n\t\t\t\t insn_byte_t v)\n{\n\tp->bytes[n] = v;\n\tp->value = __le32_to_cpu(p->little);\n}\n#endif\n\nstruct insn {\n\tstruct insn_field prefixes;\t \n\tstruct insn_field rex_prefix;\t \n\tstruct insn_field vex_prefix;\t \n\tstruct insn_field opcode;\t \n\tstruct insn_field modrm;\n\tstruct insn_field sib;\n\tstruct insn_field displacement;\n\tunion {\n\t\tstruct insn_field immediate;\n\t\tstruct insn_field moffset1;\t \n\t\tstruct insn_field immediate1;\t \n\t};\n\tunion {\n\t\tstruct insn_field moffset2;\t \n\t\tstruct insn_field immediate2;\t \n\t};\n\n\tint\temulate_prefix_size;\n\tinsn_attr_t attr;\n\tunsigned char opnd_bytes;\n\tunsigned char addr_bytes;\n\tunsigned char length;\n\tunsigned char x86_64;\n\n\tconst insn_byte_t *kaddr;\t \n\tconst insn_byte_t *end_kaddr;\t \n\tconst insn_byte_t *next_byte;\n};\n\n#define MAX_INSN_SIZE\t15\n\n#define X86_MODRM_MOD(modrm) (((modrm) & 0xc0) >> 6)\n#define X86_MODRM_REG(modrm) (((modrm) & 0x38) >> 3)\n#define X86_MODRM_RM(modrm) ((modrm) & 0x07)\n\n#define X86_SIB_SCALE(sib) (((sib) & 0xc0) >> 6)\n#define X86_SIB_INDEX(sib) (((sib) & 0x38) >> 3)\n#define X86_SIB_BASE(sib) ((sib) & 0x07)\n\n#define X86_REX_W(rex) ((rex) & 8)\n#define X86_REX_R(rex) ((rex) & 4)\n#define X86_REX_X(rex) ((rex) & 2)\n#define X86_REX_B(rex) ((rex) & 1)\n\n \n#define X86_VEX_W(vex)\t((vex) & 0x80)\t \n#define X86_VEX_R(vex)\t((vex) & 0x80)\t \n#define X86_VEX_X(vex)\t((vex) & 0x40)\t \n#define X86_VEX_B(vex)\t((vex) & 0x20)\t \n#define X86_VEX_L(vex)\t((vex) & 0x04)\t \n \n#define X86_EVEX_M(vex)\t((vex) & 0x07)\t\t \n#define X86_VEX3_M(vex)\t((vex) & 0x1f)\t\t \n#define X86_VEX2_M\t1\t\t\t \n#define X86_VEX_V(vex)\t(((vex) & 0x78) >> 3)\t \n#define X86_VEX_P(vex)\t((vex) & 0x03)\t\t \n#define X86_VEX_M_MAX\t0x1f\t\t\t \n\nextern void insn_init(struct insn *insn, const void *kaddr, int buf_len, int x86_64);\nextern int insn_get_prefixes(struct insn *insn);\nextern int insn_get_opcode(struct insn *insn);\nextern int insn_get_modrm(struct insn *insn);\nextern int insn_get_sib(struct insn *insn);\nextern int insn_get_displacement(struct insn *insn);\nextern int insn_get_immediate(struct insn *insn);\nextern int insn_get_length(struct insn *insn);\n\nenum insn_mode {\n\tINSN_MODE_32,\n\tINSN_MODE_64,\n\t \n\tINSN_MODE_KERN,\n\tINSN_NUM_MODES,\n};\n\nextern int insn_decode(struct insn *insn, const void *kaddr, int buf_len, enum insn_mode m);\n\n#define insn_decode_kernel(_insn, _ptr) insn_decode((_insn), (_ptr), MAX_INSN_SIZE, INSN_MODE_KERN)\n\n \nstatic inline void insn_get_attribute(struct insn *insn)\n{\n\tinsn_get_modrm(insn);\n}\n\n \nextern int insn_rip_relative(struct insn *insn);\n\nstatic inline int insn_is_avx(struct insn *insn)\n{\n\tif (!insn->prefixes.got)\n\t\tinsn_get_prefixes(insn);\n\treturn (insn->vex_prefix.value != 0);\n}\n\nstatic inline int insn_is_evex(struct insn *insn)\n{\n\tif (!insn->prefixes.got)\n\t\tinsn_get_prefixes(insn);\n\treturn (insn->vex_prefix.nbytes == 4);\n}\n\nstatic inline int insn_has_emulate_prefix(struct insn *insn)\n{\n\treturn !!insn->emulate_prefix_size;\n}\n\nstatic inline insn_byte_t insn_vex_m_bits(struct insn *insn)\n{\n\tif (insn->vex_prefix.nbytes == 2)\t \n\t\treturn X86_VEX2_M;\n\telse if (insn->vex_prefix.nbytes == 3)\t \n\t\treturn X86_VEX3_M(insn->vex_prefix.bytes[1]);\n\telse\t\t\t\t\t \n\t\treturn X86_EVEX_M(insn->vex_prefix.bytes[1]);\n}\n\nstatic inline insn_byte_t insn_vex_p_bits(struct insn *insn)\n{\n\tif (insn->vex_prefix.nbytes == 2)\t \n\t\treturn X86_VEX_P(insn->vex_prefix.bytes[1]);\n\telse\n\t\treturn X86_VEX_P(insn->vex_prefix.bytes[2]);\n}\n\n \nstatic inline int insn_last_prefix_id(struct insn *insn)\n{\n\tif (insn_is_avx(insn))\n\t\treturn insn_vex_p_bits(insn);\t \n\n\tif (insn->prefixes.bytes[3])\n\t\treturn inat_get_last_prefix_id(insn->prefixes.bytes[3]);\n\n\treturn 0;\n}\n\n \nstatic inline int insn_offset_rex_prefix(struct insn *insn)\n{\n\treturn insn->prefixes.nbytes;\n}\nstatic inline int insn_offset_vex_prefix(struct insn *insn)\n{\n\treturn insn_offset_rex_prefix(insn) + insn->rex_prefix.nbytes;\n}\nstatic inline int insn_offset_opcode(struct insn *insn)\n{\n\treturn insn_offset_vex_prefix(insn) + insn->vex_prefix.nbytes;\n}\nstatic inline int insn_offset_modrm(struct insn *insn)\n{\n\treturn insn_offset_opcode(insn) + insn->opcode.nbytes;\n}\nstatic inline int insn_offset_sib(struct insn *insn)\n{\n\treturn insn_offset_modrm(insn) + insn->modrm.nbytes;\n}\nstatic inline int insn_offset_displacement(struct insn *insn)\n{\n\treturn insn_offset_sib(insn) + insn->sib.nbytes;\n}\nstatic inline int insn_offset_immediate(struct insn *insn)\n{\n\treturn insn_offset_displacement(insn) + insn->displacement.nbytes;\n}\n\n \n#define for_each_insn_prefix(insn, idx, prefix)\t\\\n\tfor (idx = 0; idx < ARRAY_SIZE(insn->prefixes.bytes) && (prefix = insn->prefixes.bytes[idx]) != 0; idx++)\n\n#define POP_SS_OPCODE 0x1f\n#define MOV_SREG_OPCODE 0x8e\n\n \nstatic inline int insn_masking_exception(struct insn *insn)\n{\n\treturn insn->opcode.bytes[0] == POP_SS_OPCODE ||\n\t\t(insn->opcode.bytes[0] == MOV_SREG_OPCODE &&\n\t\t X86_MODRM_REG(insn->modrm.bytes[0]) == 2);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}