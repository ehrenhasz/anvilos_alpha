{
  "module_name": "lock.cat",
  "hash_id": "d5b6984e9753bf9ae01718731579980b2a328f6ee9224991290daa39d6f7fbc2",
  "original_prompt": "Ingested from linux-6.6.14/tools/memory-model/lock.cat",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0+\n(*\n * Copyright (C) 2016 Luc Maranget <luc.maranget@inria.fr> for Inria\n * Copyright (C) 2017 Alan Stern <stern@rowland.harvard.edu>\n *)\n\n(*\n * Generate coherence orders and handle lock operations\n *)\n\ninclude \"cross.cat\"\n\n(*\n * The lock-related events generated by herd7 are as follows:\n *\n * LKR\t\tLock-Read: the read part of a spin_lock() or successful\n *\t\t\tspin_trylock() read-modify-write event pair\n * LKW\t\tLock-Write: the write part of a spin_lock() or successful\n *\t\t\tspin_trylock() RMW event pair\n * UL\t\tUnlock: a spin_unlock() event\n * LF\t\tLock-Fail: a failed spin_trylock() event\n * RL\t\tRead-Locked: a spin_is_locked() event which returns True\n * RU\t\tRead-Unlocked: a spin_is_locked() event which returns False\n *\n * LKR and LKW events always come paired, like all RMW event sequences.\n *\n * LKR, LF, RL, and RU are read events; LKR has Acquire ordering.\n * LKW and UL are write events; UL has Release ordering.\n * LKW, LF, RL, and RU have no ordering properties.\n *)\n\n(* Backward compatibility *)\nlet RL = try RL with emptyset\nlet RU = try RU with emptyset\n\n(* Treat RL as a kind of LF: a read with no ordering properties *)\nlet LF = LF | RL\n\n(* There should be no ordinary R or W accesses to spinlocks or SRCU structs *)\nlet ALL-LOCKS = LKR | LKW | UL | LF | RU | Srcu-lock | Srcu-unlock | Sync-srcu\nflag ~empty [M \\ IW \\ ALL-LOCKS] ; loc ; [ALL-LOCKS] as mixed-lock-accesses\n\n(* Link Lock-Reads to their RMW-partner Lock-Writes *)\nlet lk-rmw = ([LKR] ; po-loc ; [LKW]) \\ (po ; po)\nlet rmw = rmw | lk-rmw\n\n(* The litmus test is invalid if an LKR/LKW event is not part of an RMW pair *)\nflag ~empty LKW \\ range(lk-rmw) as unpaired-LKW\nflag ~empty LKR \\ domain(lk-rmw) as unpaired-LKR\n\n(*\n * An LKR must always see an unlocked value; spin_lock() calls nested\n * inside a critical section (for the same lock) always deadlock.\n *)\nempty ([LKW] ; po-loc ; [LKR]) \\ (po-loc ; [UL] ; po-loc) as lock-nest\n\n(* The final value of a spinlock should not be tested *)\nflag ~empty [FW] ; loc ; [ALL-LOCKS] as lock-final\n\n(*\n * Put lock operations in their appropriate classes, but leave UL out of W\n * until after the co relation has been generated.\n *)\nlet R = R | LKR | LF | RU\nlet W = W | LKW\n\nlet Release = Release | UL\nlet Acquire = Acquire | LKR\n\n(* Match LKW events to their corresponding UL events *)\nlet critical = ([LKW] ; po-loc ; [UL]) \\ (po-loc ; [LKW | UL] ; po-loc)\n\nflag ~empty UL \\ range(critical) as unmatched-unlock\n\n(* Allow up to one unmatched LKW per location; more must deadlock *)\nlet UNMATCHED-LKW = LKW \\ domain(critical)\nempty ([UNMATCHED-LKW] ; loc ; [UNMATCHED-LKW]) \\ id as unmatched-locks\n\n(* rfi for LF events: link each LKW to the LF events in its critical section *)\nlet rfi-lf = ([LKW] ; po-loc ; [LF]) \\ ([LKW] ; po-loc ; [UL] ; po-loc)\n\n(* rfe for LF events *)\nlet all-possible-rfe-lf =\n\t(*\n\t * Given an LF event r, compute the possible rfe edges for that event\n\t * (all those starting from LKW events in other threads),\n\t * and then convert that relation to a set of single-edge relations.\n\t *)\n\tlet possible-rfe-lf r =\n\t\tlet pair-to-relation p = p ++ 0\n\t\tin map pair-to-relation ((LKW * {r}) & loc & ext)\n\t(* Do this for each LF event r that isn't in rfi-lf *)\n\tin map possible-rfe-lf (LF \\ range(rfi-lf))\n\n(* Generate all rf relations for LF events *)\nwith rfe-lf from cross(all-possible-rfe-lf)\nlet rf-lf = rfe-lf | rfi-lf\n\n(*\n * RU, i.e., spin_is_locked() returning False, is slightly different.\n * We rely on the memory model to rule out cases where spin_is_locked()\n * within one of the lock's critical sections returns False.\n *)\n\n(* rfi for RU events: an RU may read from the last po-previous UL *)\nlet rfi-ru = ([UL] ; po-loc ; [RU]) \\ ([UL] ; po-loc ; [LKW] ; po-loc)\n\n(* rfe for RU events: an RU may read from an external UL or the initial write *)\nlet all-possible-rfe-ru =\n\tlet possible-rfe-ru r =\n\t\tlet pair-to-relation p = p ++ 0\n\t\tin map pair-to-relation (((UL | IW) * {r}) & loc & ext)\n\tin map possible-rfe-ru RU\n\n(* Generate all rf relations for RU events *)\nwith rfe-ru from cross(all-possible-rfe-ru)\nlet rf-ru = rfe-ru | rfi-ru\n\n(* Final rf relation *)\nlet rf = rf | rf-lf | rf-ru\n\n(* Generate all co relations, including LKW events but not UL *)\nlet co0 = co0 | ([IW] ; loc ; [LKW]) |\n\t(([LKW] ; loc ; [UNMATCHED-LKW]) \\ [UNMATCHED-LKW])\ninclude \"cos-opt.cat\"\nlet W = W | UL\nlet M = R | W\n\n(* Merge UL events into co *)\nlet co = (co | critical | (critical^-1 ; co))+\nlet coe = co & ext\nlet coi = co & int\n\n(* Merge LKR events into rf *)\nlet rf = rf | ([IW | UL] ; singlestep(co) ; lk-rmw^-1)\nlet rfe = rf & ext\nlet rfi = rf & int\n\nlet fr = rf^-1 ; co\nlet fre = fr & ext\nlet fri = fr & int\n\nshow co,rf,fr\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}