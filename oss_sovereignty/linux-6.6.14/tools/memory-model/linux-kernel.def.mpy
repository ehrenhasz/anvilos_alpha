{
  "module_name": "linux-kernel.def",
  "hash_id": "d8c0fba0d5e9b8098ffc7633c091d34265965fa03e5091db422201f552aa52c4",
  "original_prompt": "Ingested from linux-6.6.14/tools/memory-model/linux-kernel.def",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0+\n//\n// An earlier version of this file appeared in the companion webpage for\n// \"Frightening small children and disconcerting grown-ups: Concurrency\n// in the Linux kernel\" by Alglave, Maranget, McKenney, Parri, and Stern,\n// which appeared in ASPLOS 2018.\n\n// ONCE\nREAD_ONCE(X) __load{once}(X)\nWRITE_ONCE(X,V) { __store{once}(X,V); }\n\n// Release Acquire and friends\nsmp_store_release(X,V) { __store{release}(*X,V); }\nsmp_load_acquire(X) __load{acquire}(*X)\nrcu_assign_pointer(X,V) { __store{release}(X,V); }\nrcu_dereference(X) __load{once}(X)\nsmp_store_mb(X,V) { __store{once}(X,V); __fence{mb}; }\n\n// Fences\nsmp_mb() { __fence{mb}; }\nsmp_rmb() { __fence{rmb}; }\nsmp_wmb() { __fence{wmb}; }\nsmp_mb__before_atomic() { __fence{before-atomic}; }\nsmp_mb__after_atomic() { __fence{after-atomic}; }\nsmp_mb__after_spinlock() { __fence{after-spinlock}; }\nsmp_mb__after_unlock_lock() { __fence{after-unlock-lock}; }\nsmp_mb__after_srcu_read_unlock() { __fence{after-srcu-read-unlock}; }\nbarrier() { __fence{barrier}; }\n\n// Exchange\nxchg(X,V)  __xchg{mb}(X,V)\nxchg_relaxed(X,V) __xchg{once}(X,V)\nxchg_release(X,V) __xchg{release}(X,V)\nxchg_acquire(X,V) __xchg{acquire}(X,V)\ncmpxchg(X,V,W) __cmpxchg{mb}(X,V,W)\ncmpxchg_relaxed(X,V,W) __cmpxchg{once}(X,V,W)\ncmpxchg_acquire(X,V,W) __cmpxchg{acquire}(X,V,W)\ncmpxchg_release(X,V,W) __cmpxchg{release}(X,V,W)\n\n// Spinlocks\nspin_lock(X) { __lock(X); }\nspin_unlock(X) { __unlock(X); }\nspin_trylock(X) __trylock(X)\nspin_is_locked(X) __islocked(X)\n\n// RCU\nrcu_read_lock() { __fence{rcu-lock}; }\nrcu_read_unlock() { __fence{rcu-unlock}; }\nsynchronize_rcu() { __fence{sync-rcu}; }\nsynchronize_rcu_expedited() { __fence{sync-rcu}; }\n\n// SRCU\nsrcu_read_lock(X) __load{srcu-lock}(*X)\nsrcu_read_unlock(X,Y) { __store{srcu-unlock}(*X,Y); }\nsrcu_down_read(X) __load{srcu-lock}(*X)\nsrcu_up_read(X,Y) { __store{srcu-unlock}(*X,Y); }\nsynchronize_srcu(X)  { __srcu{sync-srcu}(X); }\nsynchronize_srcu_expedited(X)  { __srcu{sync-srcu}(X); }\n\n// Atomic\natomic_read(X) READ_ONCE(*X)\natomic_set(X,V) { WRITE_ONCE(*X,V); }\natomic_read_acquire(X) smp_load_acquire(X)\natomic_set_release(X,V) { smp_store_release(X,V); }\n\natomic_add(V,X) { __atomic_op(X,+,V); }\natomic_sub(V,X) { __atomic_op(X,-,V); }\natomic_inc(X)   { __atomic_op(X,+,1); }\natomic_dec(X)   { __atomic_op(X,-,1); }\n\natomic_add_return(V,X) __atomic_op_return{mb}(X,+,V)\natomic_add_return_relaxed(V,X) __atomic_op_return{once}(X,+,V)\natomic_add_return_acquire(V,X) __atomic_op_return{acquire}(X,+,V)\natomic_add_return_release(V,X) __atomic_op_return{release}(X,+,V)\natomic_fetch_add(V,X) __atomic_fetch_op{mb}(X,+,V)\natomic_fetch_add_relaxed(V,X) __atomic_fetch_op{once}(X,+,V)\natomic_fetch_add_acquire(V,X) __atomic_fetch_op{acquire}(X,+,V)\natomic_fetch_add_release(V,X) __atomic_fetch_op{release}(X,+,V)\n\natomic_inc_return(X) __atomic_op_return{mb}(X,+,1)\natomic_inc_return_relaxed(X) __atomic_op_return{once}(X,+,1)\natomic_inc_return_acquire(X) __atomic_op_return{acquire}(X,+,1)\natomic_inc_return_release(X) __atomic_op_return{release}(X,+,1)\natomic_fetch_inc(X) __atomic_fetch_op{mb}(X,+,1)\natomic_fetch_inc_relaxed(X) __atomic_fetch_op{once}(X,+,1)\natomic_fetch_inc_acquire(X) __atomic_fetch_op{acquire}(X,+,1)\natomic_fetch_inc_release(X) __atomic_fetch_op{release}(X,+,1)\n\natomic_sub_return(V,X) __atomic_op_return{mb}(X,-,V)\natomic_sub_return_relaxed(V,X) __atomic_op_return{once}(X,-,V)\natomic_sub_return_acquire(V,X) __atomic_op_return{acquire}(X,-,V)\natomic_sub_return_release(V,X) __atomic_op_return{release}(X,-,V)\natomic_fetch_sub(V,X) __atomic_fetch_op{mb}(X,-,V)\natomic_fetch_sub_relaxed(V,X) __atomic_fetch_op{once}(X,-,V)\natomic_fetch_sub_acquire(V,X) __atomic_fetch_op{acquire}(X,-,V)\natomic_fetch_sub_release(V,X) __atomic_fetch_op{release}(X,-,V)\n\natomic_dec_return(X) __atomic_op_return{mb}(X,-,1)\natomic_dec_return_relaxed(X) __atomic_op_return{once}(X,-,1)\natomic_dec_return_acquire(X) __atomic_op_return{acquire}(X,-,1)\natomic_dec_return_release(X) __atomic_op_return{release}(X,-,1)\natomic_fetch_dec(X) __atomic_fetch_op{mb}(X,-,1)\natomic_fetch_dec_relaxed(X) __atomic_fetch_op{once}(X,-,1)\natomic_fetch_dec_acquire(X) __atomic_fetch_op{acquire}(X,-,1)\natomic_fetch_dec_release(X) __atomic_fetch_op{release}(X,-,1)\n\natomic_xchg(X,V) __xchg{mb}(X,V)\natomic_xchg_relaxed(X,V) __xchg{once}(X,V)\natomic_xchg_release(X,V) __xchg{release}(X,V)\natomic_xchg_acquire(X,V) __xchg{acquire}(X,V)\natomic_cmpxchg(X,V,W) __cmpxchg{mb}(X,V,W)\natomic_cmpxchg_relaxed(X,V,W) __cmpxchg{once}(X,V,W)\natomic_cmpxchg_acquire(X,V,W) __cmpxchg{acquire}(X,V,W)\natomic_cmpxchg_release(X,V,W) __cmpxchg{release}(X,V,W)\n\natomic_sub_and_test(V,X) __atomic_op_return{mb}(X,-,V) == 0\natomic_dec_and_test(X)  __atomic_op_return{mb}(X,-,1) == 0\natomic_inc_and_test(X)  __atomic_op_return{mb}(X,+,1) == 0\natomic_add_negative(V,X) __atomic_op_return{mb}(X,+,V) < 0\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}