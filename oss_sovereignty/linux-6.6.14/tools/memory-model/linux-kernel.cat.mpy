{
  "module_name": "linux-kernel.cat",
  "hash_id": "7a4dd2a8646d7ede296d9e6ef156a5b99e9d1176f35bddafa822086eb5be68e8",
  "original_prompt": "Ingested from linux-6.6.14/tools/memory-model/linux-kernel.cat",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0+\n(*\n * Copyright (C) 2015 Jade Alglave <j.alglave@ucl.ac.uk>,\n * Copyright (C) 2016 Luc Maranget <luc.maranget@inria.fr> for Inria\n * Copyright (C) 2017 Alan Stern <stern@rowland.harvard.edu>,\n *                    Andrea Parri <parri.andrea@gmail.com>\n *\n * An earlier version of this file appeared in the companion webpage for\n * \"Frightening small children and disconcerting grown-ups: Concurrency\n * in the Linux kernel\" by Alglave, Maranget, McKenney, Parri, and Stern,\n * which appeared in ASPLOS 2018.\n *)\n\n\"Linux-kernel memory consistency model\"\n\n(*\n * File \"lock.cat\" handles locks and is experimental.\n * It can be replaced by include \"cos.cat\" for tests that do not use locks.\n *)\n\ninclude \"lock.cat\"\n\n(*******************)\n(* Basic relations *)\n(*******************)\n\n(* Release Acquire *)\nlet acq-po = [Acquire] ; po ; [M]\nlet po-rel = [M] ; po ; [Release]\nlet po-unlock-lock-po = po ; [UL] ; (po|rf) ; [LKR] ; po\n\n(* Fences *)\nlet R4rmb = R \\ Noreturn\t(* Reads for which rmb works *)\nlet rmb = [R4rmb] ; fencerel(Rmb) ; [R4rmb]\nlet wmb = [W] ; fencerel(Wmb) ; [W]\nlet mb = ([M] ; fencerel(Mb) ; [M]) |\n\t([M] ; fencerel(Before-atomic) ; [RMW] ; po? ; [M]) |\n\t([M] ; po? ; [RMW] ; fencerel(After-atomic) ; [M]) |\n\t([M] ; po? ; [LKW] ; fencerel(After-spinlock) ; [M]) |\n(*\n * Note: The po-unlock-lock-po relation only passes the lock to the direct\n * successor, perhaps giving the impression that the ordering of the\n * smp_mb__after_unlock_lock() fence only affects a single lock handover.\n * However, in a longer sequence of lock handovers, the implicit\n * A-cumulative release fences of lock-release ensure that any stores that\n * propagate to one of the involved CPUs before it hands over the lock to\n * the next CPU will also propagate to the final CPU handing over the lock\n * to the CPU that executes the fence.  Therefore, all those stores are\n * also affected by the fence.\n *)\n\t([M] ; po-unlock-lock-po ;\n\t\t[After-unlock-lock] ; po ; [M]) |\n\t([M] ; po? ; [Srcu-unlock] ; fencerel(After-srcu-read-unlock) ; [M])\nlet gp = po ; [Sync-rcu | Sync-srcu] ; po?\nlet strong-fence = mb | gp\n\nlet nonrw-fence = strong-fence | po-rel | acq-po\nlet fence = nonrw-fence | wmb | rmb\nlet barrier = fencerel(Barrier | Rmb | Wmb | Mb | Sync-rcu | Sync-srcu |\n\t\tBefore-atomic | After-atomic | Acquire | Release |\n\t\tRcu-lock | Rcu-unlock | Srcu-lock | Srcu-unlock) |\n\t(po ; [Release]) | ([Acquire] ; po)\n\n(**********************************)\n(* Fundamental coherence ordering *)\n(**********************************)\n\n(* Sequential Consistency Per Variable *)\nlet com = rf | co | fr\nacyclic po-loc | com as coherence\n\n(* Atomic Read-Modify-Write *)\nempty rmw & (fre ; coe) as atomic\n\n(**********************************)\n(* Instruction execution ordering *)\n(**********************************)\n\n(* Preserved Program Order *)\nlet dep = addr | data\nlet rwdep = (dep | ctrl) ; [W]\nlet overwrite = co | fr\nlet to-w = rwdep | (overwrite & int) | (addr ; [Plain] ; wmb)\nlet to-r = (addr ; [R]) | (dep ; [Marked] ; rfi)\nlet ppo = to-r | to-w | (fence & int) | (po-unlock-lock-po & int)\n\n(* Propagation: Ordering from release operations and strong fences. *)\nlet A-cumul(r) = (rfe ; [Marked])? ; r\nlet rmw-sequence = (rf ; rmw)*\nlet cumul-fence = [Marked] ; (A-cumul(strong-fence | po-rel) | wmb |\n\tpo-unlock-lock-po) ; [Marked] ; rmw-sequence\nlet prop = [Marked] ; (overwrite & ext)? ; cumul-fence* ;\n\t[Marked] ; rfe? ; [Marked]\n\n(*\n * Happens Before: Ordering from the passage of time.\n * No fences needed here for prop because relation confined to one process.\n *)\nlet hb = [Marked] ; (ppo | rfe | ((prop \\ id) & int)) ; [Marked]\nacyclic hb as happens-before\n\n(****************************************)\n(* Write and fence propagation ordering *)\n(****************************************)\n\n(* Propagation: Each non-rf link needs a strong fence. *)\nlet pb = prop ; strong-fence ; hb* ; [Marked]\nacyclic pb as propagation\n\n(*******)\n(* RCU *)\n(*******)\n\n(*\n * Effects of read-side critical sections proceed from the rcu_read_unlock()\n * or srcu_read_unlock() backwards on the one hand, and from the\n * rcu_read_lock() or srcu_read_lock() forwards on the other hand.\n *\n * In the definition of rcu-fence below, the po term at the left-hand side\n * of each disjunct and the po? term at the right-hand end have been factored\n * out.  They have been moved into the definitions of rcu-link and rb.\n * This was necessary in order to apply the \"& loc\" tests correctly.\n *)\nlet rcu-gp = [Sync-rcu]\t\t(* Compare with gp *)\nlet srcu-gp = [Sync-srcu]\nlet rcu-rscsi = rcu-rscs^-1\nlet srcu-rscsi = srcu-rscs^-1\n\n(*\n * The synchronize_rcu() strong fence is special in that it can order not\n * one but two non-rf relations, but only in conjunction with an RCU\n * read-side critical section.\n *)\nlet rcu-link = po? ; hb* ; pb* ; prop ; po\n\n(*\n * Any sequence containing at least as many grace periods as RCU read-side\n * critical sections (joined by rcu-link) induces order like a generalized\n * inter-CPU strong fence.\n * Likewise for SRCU grace periods and read-side critical sections, provided\n * the synchronize_srcu() and srcu_read_[un]lock() calls refer to the same\n * struct srcu_struct location.\n *)\nlet rec rcu-order = rcu-gp | srcu-gp |\n\t(rcu-gp ; rcu-link ; rcu-rscsi) |\n\t((srcu-gp ; rcu-link ; srcu-rscsi) & loc) |\n\t(rcu-rscsi ; rcu-link ; rcu-gp) |\n\t((srcu-rscsi ; rcu-link ; srcu-gp) & loc) |\n\t(rcu-gp ; rcu-link ; rcu-order ; rcu-link ; rcu-rscsi) |\n\t((srcu-gp ; rcu-link ; rcu-order ; rcu-link ; srcu-rscsi) & loc) |\n\t(rcu-rscsi ; rcu-link ; rcu-order ; rcu-link ; rcu-gp) |\n\t((srcu-rscsi ; rcu-link ; rcu-order ; rcu-link ; srcu-gp) & loc) |\n\t(rcu-order ; rcu-link ; rcu-order)\nlet rcu-fence = po ; rcu-order ; po?\nlet fence = fence | rcu-fence\nlet strong-fence = strong-fence | rcu-fence\n\n(* rb orders instructions just as pb does *)\nlet rb = prop ; rcu-fence ; hb* ; pb* ; [Marked]\n\nirreflexive rb as rcu\n\n(*\n * The happens-before, propagation, and rcu constraints are all\n * expressions of temporal ordering.  They could be replaced by\n * a single constraint on an \"executes-before\" relation, xb:\n *\n * let xb = hb | pb | rb\n * acyclic xb as executes-before\n *)\n\n(*********************************)\n(* Plain accesses and data races *)\n(*********************************)\n\n(* Warn about plain writes and marked accesses in the same region *)\nlet mixed-accesses = ([Plain & W] ; (po-loc \\ barrier) ; [Marked]) |\n\t([Marked] ; (po-loc \\ barrier) ; [Plain & W])\nflag ~empty mixed-accesses as mixed-accesses\n\n(* Executes-before and visibility *)\nlet xbstar = (hb | pb | rb)*\nlet vis = cumul-fence* ; rfe? ; [Marked] ;\n\t((strong-fence ; [Marked] ; xbstar) | (xbstar & int))\n\n(* Boundaries for lifetimes of plain accesses *)\nlet w-pre-bounded = [Marked] ; (addr | fence)?\nlet r-pre-bounded = [Marked] ; (addr | nonrw-fence |\n\t([R4rmb] ; fencerel(Rmb) ; [~Noreturn]))?\nlet w-post-bounded = fence? ; [Marked] ; rmw-sequence\nlet r-post-bounded = (nonrw-fence | ([~Noreturn] ; fencerel(Rmb) ; [R4rmb]))? ;\n\t[Marked]\n\n(* Visibility and executes-before for plain accesses *)\nlet ww-vis = fence | (strong-fence ; xbstar ; w-pre-bounded) |\n\t(w-post-bounded ; vis ; w-pre-bounded)\nlet wr-vis = fence | (strong-fence ; xbstar ; r-pre-bounded) |\n\t(w-post-bounded ; vis ; r-pre-bounded)\nlet rw-xbstar = fence | (r-post-bounded ; xbstar ; w-pre-bounded)\n\n(* Potential races *)\nlet pre-race = ext & ((Plain * M) | ((M \\ IW) * Plain))\n\n(* Coherence requirements for plain accesses *)\nlet wr-incoh = pre-race & rf & rw-xbstar^-1\nlet rw-incoh = pre-race & fr & wr-vis^-1\nlet ww-incoh = pre-race & co & ww-vis^-1\nempty (wr-incoh | rw-incoh | ww-incoh) as plain-coherence\n\n(* Actual races *)\nlet ww-nonrace = ww-vis & ((Marked * W) | rw-xbstar) & ((W * Marked) | wr-vis)\nlet ww-race = (pre-race & co) \\ ww-nonrace\nlet wr-race = (pre-race & (co? ; rf)) \\ wr-vis \\ rw-xbstar^-1\nlet rw-race = (pre-race & fr) \\ rw-xbstar\n\nflag ~empty (ww-race | wr-race | rw-race) as data-race\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}