{
  "module_name": "linux-kernel.bell",
  "hash_id": "3a882ae3b3af95537f15ba0ca8f2572f3a16d16a349268b2117f0e1fc98794de",
  "original_prompt": "Ingested from linux-6.6.14/tools/memory-model/linux-kernel.bell",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0+\n(*\n * Copyright (C) 2015 Jade Alglave <j.alglave@ucl.ac.uk>,\n * Copyright (C) 2016 Luc Maranget <luc.maranget@inria.fr> for Inria\n * Copyright (C) 2017 Alan Stern <stern@rowland.harvard.edu>,\n *                    Andrea Parri <parri.andrea@gmail.com>\n *\n * An earlier version of this file appeared in the companion webpage for\n * \"Frightening small children and disconcerting grown-ups: Concurrency\n * in the Linux kernel\" by Alglave, Maranget, McKenney, Parri, and Stern,\n * which appeared in ASPLOS 2018.\n *)\n\n\"Linux-kernel memory consistency model\"\n\nenum Accesses = 'once (*READ_ONCE,WRITE_ONCE*) ||\n\t\t'release (*smp_store_release*) ||\n\t\t'acquire (*smp_load_acquire*) ||\n\t\t'noreturn (* R of non-return RMW *)\ninstructions R[{'once,'acquire,'noreturn}]\ninstructions W[{'once,'release}]\ninstructions RMW[{'once,'acquire,'release}]\n\nenum Barriers = 'wmb (*smp_wmb*) ||\n\t\t'rmb (*smp_rmb*) ||\n\t\t'mb (*smp_mb*) ||\n\t\t'barrier (*barrier*) ||\n\t\t'rcu-lock (*rcu_read_lock*)  ||\n\t\t'rcu-unlock (*rcu_read_unlock*) ||\n\t\t'sync-rcu (*synchronize_rcu*) ||\n\t\t'before-atomic (*smp_mb__before_atomic*) ||\n\t\t'after-atomic (*smp_mb__after_atomic*) ||\n\t\t'after-spinlock (*smp_mb__after_spinlock*) ||\n\t\t'after-unlock-lock (*smp_mb__after_unlock_lock*) ||\n\t\t'after-srcu-read-unlock (*smp_mb__after_srcu_read_unlock*)\ninstructions F[Barriers]\n\n(* SRCU *)\nenum SRCU = 'srcu-lock || 'srcu-unlock || 'sync-srcu\ninstructions SRCU[SRCU]\n(* All srcu events *)\nlet Srcu = Srcu-lock | Srcu-unlock | Sync-srcu\n\n(* Compute matching pairs of nested Rcu-lock and Rcu-unlock *)\nlet rcu-rscs = let rec\n\t    unmatched-locks = Rcu-lock \\ domain(matched)\n\tand unmatched-unlocks = Rcu-unlock \\ range(matched)\n\tand unmatched = unmatched-locks | unmatched-unlocks\n\tand unmatched-po = [unmatched] ; po ; [unmatched]\n\tand unmatched-locks-to-unlocks =\n\t\t[unmatched-locks] ; po ; [unmatched-unlocks]\n\tand matched = matched | (unmatched-locks-to-unlocks \\\n\t\t(unmatched-po ; unmatched-po))\n\tin matched\n\n(* Validate nesting *)\nflag ~empty Rcu-lock \\ domain(rcu-rscs) as unmatched-rcu-lock\nflag ~empty Rcu-unlock \\ range(rcu-rscs) as unmatched-rcu-unlock\n\n(* Compute matching pairs of nested Srcu-lock and Srcu-unlock *)\nlet carry-srcu-data = (data ; [~ Srcu-unlock] ; rf)*\nlet srcu-rscs = ([Srcu-lock] ; carry-srcu-data ; data ; [Srcu-unlock]) & loc\n\n(* Validate nesting *)\nflag ~empty Srcu-lock \\ domain(srcu-rscs) as unmatched-srcu-lock\nflag ~empty Srcu-unlock \\ range(srcu-rscs) as unmatched-srcu-unlock\nflag ~empty (srcu-rscs^-1 ; srcu-rscs) \\ id as multiple-srcu-matches\n\n(* Check for use of synchronize_srcu() inside an RCU critical section *)\nflag ~empty rcu-rscs & (po ; [Sync-srcu] ; po) as invalid-sleep\n\n(* Validate SRCU dynamic match *)\nflag ~empty different-values(srcu-rscs) as srcu-bad-value-match\n\n(* Compute marked and plain memory accesses *)\nlet Marked = (~M) | IW | Once | Release | Acquire | domain(rmw) | range(rmw) |\n\t\tLKR | LKW | UL | LF | RL | RU | Srcu-lock | Srcu-unlock\nlet Plain = M \\ Marked\n\n(* Redefine dependencies to include those carried through plain accesses *)\nlet carry-dep = (data ; [~ Srcu-unlock] ; rfi)*\nlet addr = carry-dep ; addr\nlet ctrl = carry-dep ; ctrl\nlet data = carry-dep ; data\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}