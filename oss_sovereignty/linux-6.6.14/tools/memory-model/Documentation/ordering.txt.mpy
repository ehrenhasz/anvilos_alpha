{
  "module_name": "ordering.txt",
  "hash_id": "8e3ad169278fa6134de3fa839a06facb7ce5e1eb6a6d8ddfee08dd1ee586f298",
  "original_prompt": "Ingested from linux-6.6.14/tools/memory-model/Documentation/ordering.txt",
  "human_readable_source": "This document gives an overview of the categories of memory-ordering\noperations provided by the Linux-kernel memory model (LKMM).\n\n\nCategories of Ordering\n======================\n\nThis section lists LKMM's three top-level categories of memory-ordering\noperations in decreasing order of strength:\n\n1.\tBarriers (also known as \"fences\").  A barrier orders some or\n\tall of the CPU's prior operations against some or all of its\n\tsubsequent operations.\n\n2.\tOrdered memory accesses.  These operations order themselves\n\tagainst some or all of the CPU's prior accesses or some or all\n\tof the CPU's subsequent accesses, depending on the subcategory\n\tof the operation.\n\n3.\tUnordered accesses, as the name indicates, have no ordering\n\tproperties except to the extent that they interact with an\n\toperation in the previous categories.  This being the real world,\n\tsome of these \"unordered\" operations provide limited ordering\n\tin some special situations.\n\nEach of the above categories is described in more detail by one of the\nfollowing sections.\n\n\nBarriers\n========\n\nEach of the following categories of barriers is described in its own\nsubsection below:\n\na.\tFull memory barriers.\n\nb.\tRead-modify-write (RMW) ordering augmentation barriers.\n\nc.\tWrite memory barrier.\n\nd.\tRead memory barrier.\n\ne.\tCompiler barrier.\n\nNote well that many of these primitives generate absolutely no code\nin kernels built with CONFIG_SMP=n.  Therefore, if you are writing\na device driver, which must correctly order accesses to a physical\ndevice even in kernels built with CONFIG_SMP=n, please use the\nordering primitives provided for that purpose.  For example, instead of\nsmp_mb(), use mb().  See the \"Linux Kernel Device Drivers\" book or the\nhttps://lwn.net/Articles/698014/ article for more information.\n\n\nFull Memory Barriers\n--------------------\n\nThe Linux-kernel primitives that provide full ordering include:\n\no\tThe smp_mb() full memory barrier.\n\no\tValue-returning RMW atomic operations whose names do not end in\n\t_acquire, _release, or _relaxed.\n\no\tRCU's grace-period primitives.\n\nFirst, the smp_mb() full memory barrier orders all of the CPU's prior\naccesses against all subsequent accesses from the viewpoint of all CPUs.\nIn other words, all CPUs will agree that any earlier action taken\nby that CPU happened before any later action taken by that same CPU.\nFor example, consider the following:\n\n\tWRITE_ONCE(x, 1);\n\tsmp_mb(); // Order store to x before load from y.\n\tr1 = READ_ONCE(y);\n\nAll CPUs will agree that the store to \"x\" happened before the load\nfrom \"y\", as indicated by the comment.  And yes, please comment your\nmemory-ordering primitives.  It is surprisingly hard to remember their\npurpose after even a few months.\n\nSecond, some RMW atomic operations provide full ordering.  These\noperations include value-returning RMW atomic operations (that is, those\nwith non-void return types) whose names do not end in _acquire, _release,\nor _relaxed.  Examples include atomic_add_return(), atomic_dec_and_test(),\ncmpxchg(), and xchg().  Note that conditional RMW atomic operations such\nas cmpxchg() are only guaranteed to provide ordering when they succeed.\nWhen RMW atomic operations provide full ordering, they partition the\nCPU's accesses into three groups:\n\n1.\tAll code that executed prior to the RMW atomic operation.\n\n2.\tThe RMW atomic operation itself.\n\n3.\tAll code that executed after the RMW atomic operation.\n\nAll CPUs will agree that any operation in a given partition happened\nbefore any operation in a higher-numbered partition.\n\nIn contrast, non-value-returning RMW atomic operations (that is, those\nwith void return types) do not guarantee any ordering whatsoever.  Nor do\nvalue-returning RMW atomic operations whose names end in _relaxed.\nExamples of the former include atomic_inc() and atomic_dec(),\nwhile examples of the latter include atomic_cmpxchg_relaxed() and\natomic_xchg_relaxed().  Similarly, value-returning non-RMW atomic\noperations such as atomic_read() do not guarantee full ordering, and\nare covered in the later section on unordered operations.\n\nValue-returning RMW atomic operations whose names end in _acquire or\n_release provide limited ordering, and will be described later in this\ndocument.\n\nFinally, RCU's grace-period primitives provide full ordering.  These\nprimitives include synchronize_rcu(), synchronize_rcu_expedited(),\nsynchronize_srcu() and so on.  However, these primitives have orders\nof magnitude greater overhead than smp_mb(), atomic_xchg(), and so on.\nFurthermore, RCU's grace-period primitives can only be invoked in\nsleepable contexts.  Therefore, RCU's grace-period primitives are\ntypically instead used to provide ordering against RCU read-side critical\nsections, as documented in their comment headers.  But of course if you\nneed a synchronize_rcu() to interact with readers, it costs you nothing\nto also rely on its additional full-memory-barrier semantics.  Just please\ncarefully comment this, otherwise your future self will hate you.\n\n\nRMW Ordering Augmentation Barriers\n----------------------------------\n\nAs noted in the previous section, non-value-returning RMW operations\nsuch as atomic_inc() and atomic_dec() guarantee no ordering whatsoever.\nNevertheless, a number of popular CPU families, including x86, provide\nfull ordering for these primitives.  One way to obtain full ordering on\nall architectures is to add a call to smp_mb():\n\n\tWRITE_ONCE(x, 1);\n\tatomic_inc(&my_counter);\n\tsmp_mb(); // Inefficient on x86!!!\n\tr1 = READ_ONCE(y);\n\nThis works, but the added smp_mb() adds needless overhead for\nx86, on which atomic_inc() provides full ordering all by itself.\nThe smp_mb__after_atomic() primitive can be used instead:\n\n\tWRITE_ONCE(x, 1);\n\tatomic_inc(&my_counter);\n\tsmp_mb__after_atomic(); // Order store to x before load from y.\n\tr1 = READ_ONCE(y);\n\nThe smp_mb__after_atomic() primitive emits code only on CPUs whose\natomic_inc() implementations do not guarantee full ordering, thus\nincurring no unnecessary overhead on x86.  There are a number of\nvariations on the smp_mb__*() theme:\n\no\tsmp_mb__before_atomic(), which provides full ordering prior\n\tto an unordered RMW atomic operation.\n\no\tsmp_mb__after_atomic(), which, as shown above, provides full\n\tordering subsequent to an unordered RMW atomic operation.\n\no\tsmp_mb__after_spinlock(), which provides full ordering subsequent\n\tto a successful spinlock acquisition.  Note that spin_lock() is\n\talways successful but spin_trylock() might not be.\n\no\tsmp_mb__after_srcu_read_unlock(), which provides full ordering\n\tsubsequent to an srcu_read_unlock().\n\nIt is bad practice to place code between the smp__*() primitive and the\noperation whose ordering that it is augmenting.  The reason is that the\nordering of this intervening code will differ from one CPU architecture\nto another.\n\n\nWrite Memory Barrier\n--------------------\n\nThe Linux kernel's write memory barrier is smp_wmb().  If a CPU executes\nthe following code:\n\n\tWRITE_ONCE(x, 1);\n\tsmp_wmb();\n\tWRITE_ONCE(y, 1);\n\nThen any given CPU will see the write to \"x\" has having happened before\nthe write to \"y\".  However, you are usually better off using a release\nstore, as described in the \"Release Operations\" section below.\n\nNote that smp_wmb() might fail to provide ordering for unmarked C-language\nstores because profile-driven optimization could determine that the\nvalue being overwritten is almost always equal to the new value.  Such a\ncompiler might then reasonably decide to transform \"x = 1\" and \"y = 1\"\nas follows:\n\n\tif (x != 1)\n\t\tx = 1;\n\tsmp_wmb(); // BUG: does not order the reads!!!\n\tif (y != 1)\n\t\ty = 1;\n\nTherefore, if you need to use smp_wmb() with unmarked C-language writes,\nyou will need to make sure that none of the compilers used to build\nthe Linux kernel carry out this sort of transformation, both now and in\nthe future.\n\n\nRead Memory Barrier\n-------------------\n\nThe Linux kernel's read memory barrier is smp_rmb().  If a CPU executes\nthe following code:\n\n\tr0 = READ_ONCE(y);\n\tsmp_rmb();\n\tr1 = READ_ONCE(x);\n\nThen any given CPU will see the read from \"y\" as having preceded the read from\n\"x\".  However, you are usually better off using an acquire load, as described\nin the \"Acquire Operations\" section below.\n\nCompiler Barrier\n----------------\n\nThe Linux kernel's compiler barrier is barrier().  This primitive\nprohibits compiler code-motion optimizations that might move memory\nreferences across the point in the code containing the barrier(), but\ndoes not constrain hardware memory ordering.  For example, this can be\nused to prevent to compiler from moving code across an infinite loop:\n\n\tWRITE_ONCE(x, 1);\n\twhile (dontstop)\n\t\tbarrier();\n\tr1 = READ_ONCE(y);\n\nWithout the barrier(), the compiler would be within its rights to move the\nWRITE_ONCE() to follow the loop.  This code motion could be problematic\nin the case where an interrupt handler terminates the loop.  Another way\nto handle this is to use READ_ONCE() for the load of \"dontstop\".\n\nNote that the barriers discussed previously use barrier() or its low-level\nequivalent in their implementations.\n\n\nOrdered Memory Accesses\n=======================\n\nThe Linux kernel provides a wide variety of ordered memory accesses:\n\na.\tRelease operations.\n\nb.\tAcquire operations.\n\nc.\tRCU read-side ordering.\n\nd.\tControl dependencies.\n\nEach of the above categories has its own section below.\n\n\nRelease Operations\n------------------\n\nRelease operations include smp_store_release(), atomic_set_release(),\nrcu_assign_pointer(), and value-returning RMW operations whose names\nend in _release.  These operations order their own store against all\nof the CPU's prior memory accesses.  Release operations often provide\nimproved readability and performance compared to explicit barriers.\nFor example, use of smp_store_release() saves a line compared to the\nsmp_wmb() example above:\n\n\tWRITE_ONCE(x, 1);\n\tsmp_store_release(&y, 1);\n\nMore important, smp_store_release() makes it easier to connect up the\ndifferent pieces of the concurrent algorithm.  The variable stored to\nby the smp_store_release(), in this case \"y\", will normally be used in\nan acquire operation in other parts of the concurrent algorithm.\n\nTo see the performance advantages, suppose that the above example read\nfrom \"x\" instead of writing to it.  Then an smp_wmb() could not guarantee\nordering, and an smp_mb() would be needed instead:\n\n\tr1 = READ_ONCE(x);\n\tsmp_mb();\n\tWRITE_ONCE(y, 1);\n\nBut smp_mb() often incurs much higher overhead than does\nsmp_store_release(), which still provides the needed ordering of \"x\"\nagainst \"y\".  On x86, the version using smp_store_release() might compile\nto a simple load instruction followed by a simple store instruction.\nIn contrast, the smp_mb() compiles to an expensive instruction that\nprovides the needed ordering.\n\nThere is a wide variety of release operations:\n\no\tStore operations, including not only the aforementioned\n\tsmp_store_release(), but also atomic_set_release(), and\n\tatomic_long_set_release().\n\no\tRCU's rcu_assign_pointer() operation.  This is the same as\n\tsmp_store_release() except that: (1) It takes the pointer to\n\tbe assigned to instead of a pointer to that pointer, (2) It\n\tis intended to be used in conjunction with rcu_dereference()\n\tand similar rather than smp_load_acquire(), and (3) It checks\n\tfor an RCU-protected pointer in \"sparse\" runs.\n\no\tValue-returning RMW operations whose names end in _release,\n\tsuch as atomic_fetch_add_release() and cmpxchg_release().\n\tNote that release ordering is guaranteed only against the\n\tmemory-store portion of the RMW operation, and not against the\n\tmemory-load portion.  Note also that conditional operations such\n\tas cmpxchg_release() are only guaranteed to provide ordering\n\twhen they succeed.\n\nAs mentioned earlier, release operations are often paired with acquire\noperations, which are the subject of the next section.\n\n\nAcquire Operations\n------------------\n\nAcquire operations include smp_load_acquire(), atomic_read_acquire(),\nand value-returning RMW operations whose names end in _acquire.   These\noperations order their own load against all of the CPU's subsequent\nmemory accesses.  Acquire operations often provide improved performance\nand readability compared to explicit barriers.  For example, use of\nsmp_load_acquire() saves a line compared to the smp_rmb() example above:\n\n\tr0 = smp_load_acquire(&y);\n\tr1 = READ_ONCE(x);\n\nAs with smp_store_release(), this also makes it easier to connect\nthe different pieces of the concurrent algorithm by looking for the\nsmp_store_release() that stores to \"y\".  In addition, smp_load_acquire()\nimproves upon smp_rmb() by ordering against subsequent stores as well\nas against subsequent loads.\n\nThere are a couple of categories of acquire operations:\n\no\tLoad operations, including not only the aforementioned\n\tsmp_load_acquire(), but also atomic_read_acquire(), and\n\tatomic64_read_acquire().\n\no\tValue-returning RMW operations whose names end in _acquire,\n\tsuch as atomic_xchg_acquire() and atomic_cmpxchg_acquire().\n\tNote that acquire ordering is guaranteed only against the\n\tmemory-load portion of the RMW operation, and not against the\n\tmemory-store portion.  Note also that conditional operations\n\tsuch as atomic_cmpxchg_acquire() are only guaranteed to provide\n\tordering when they succeed.\n\nSymmetry being what it is, acquire operations are often paired with the\nrelease operations covered earlier.  For example, consider the following\nexample, where task0() and task1() execute concurrently:\n\n\tvoid task0(void)\n\t{\n\t\tWRITE_ONCE(x, 1);\n\t\tsmp_store_release(&y, 1);\n\t}\n\n\tvoid task1(void)\n\t{\n\t\tr0 = smp_load_acquire(&y);\n\t\tr1 = READ_ONCE(x);\n\t}\n\nIf \"x\" and \"y\" are both initially zero, then either r0's final value\nwill be zero or r1's final value will be one, thus providing the required\nordering.\n\n\nRCU Read-Side Ordering\n----------------------\n\nThis category includes read-side markers such as rcu_read_lock()\nand rcu_read_unlock() as well as pointer-traversal primitives such as\nrcu_dereference() and srcu_dereference().\n\nCompared to locking primitives and RMW atomic operations, markers\nfor RCU read-side critical sections incur very low overhead because\nthey interact only with the corresponding grace-period primitives.\nFor example, the rcu_read_lock() and rcu_read_unlock() markers interact\nwith synchronize_rcu(), synchronize_rcu_expedited(), and call_rcu().\nThe way this works is that if a given call to synchronize_rcu() cannot\nprove that it started before a given call to rcu_read_lock(), then\nthat synchronize_rcu() must block until the matching rcu_read_unlock()\nis reached.  For more information, please see the synchronize_rcu()\ndocbook header comment and the material in Documentation/RCU.\n\nRCU's pointer-traversal primitives, including rcu_dereference() and\nsrcu_dereference(), order their load (which must be a pointer) against any\nof the CPU's subsequent memory accesses whose address has been calculated\nfrom the value loaded.  There is said to be an *address dependency*\nfrom the value returned by the rcu_dereference() or srcu_dereference()\nto that subsequent memory access.\n\nA call to rcu_dereference() for a given RCU-protected pointer is\nusually paired with a call to a call to rcu_assign_pointer() for that\nsame pointer in much the same way that a call to smp_load_acquire() is\npaired with a call to smp_store_release().  Calls to rcu_dereference()\nand rcu_assign_pointer are often buried in other APIs, for example,\nthe RCU list API members defined in include/linux/rculist.h.  For more\ninformation, please see the docbook headers in that file, the most\nrecent LWN article on the RCU API (https://lwn.net/Articles/777036/),\nand of course the material in Documentation/RCU.\n\nIf the pointer value is manipulated between the rcu_dereference()\nthat returned it and a later dereference(), please read\nDocumentation/RCU/rcu_dereference.rst.  It can also be quite helpful to\nreview uses in the Linux kernel.\n\n\nControl Dependencies\n--------------------\n\nA control dependency extends from a marked load (READ_ONCE() or stronger)\nthrough an \"if\" condition to a marked store (WRITE_ONCE() or stronger)\nthat is executed only by one of the legs of that \"if\" statement.\nControl dependencies are so named because they are mediated by\ncontrol-flow instructions such as comparisons and conditional branches.\n\nIn short, you can use a control dependency to enforce ordering between\nan READ_ONCE() and a WRITE_ONCE() when there is an \"if\" condition\nbetween them.  The canonical example is as follows:\n\n\tq = READ_ONCE(a);\n\tif (q)\n\t\tWRITE_ONCE(b, 1);\n\nIn this case, all CPUs would see the read from \"a\" as happening before\nthe write to \"b\".\n\nHowever, control dependencies are easily destroyed by compiler\noptimizations, so any use of control dependencies must take into account\nall of the compilers used to build the Linux kernel.  Please see the\n\"control-dependencies.txt\" file for more information.\n\n\nUnordered Accesses\n==================\n\nEach of these two categories of unordered accesses has a section below:\n\na.\tUnordered marked operations.\n\nb.\tUnmarked C-language accesses.\n\n\nUnordered Marked Operations\n---------------------------\n\nUnordered operations to different variables are just that, unordered.\nHowever, if a group of CPUs apply these operations to a single variable,\nall the CPUs will agree on the operation order.  Of course, the ordering\nof unordered marked accesses can also be constrained using the mechanisms\ndescribed earlier in this document.\n\nThese operations come in three categories:\n\no\tMarked writes, such as WRITE_ONCE() and atomic_set().  These\n\tprimitives required the compiler to emit the corresponding store\n\tinstructions in the expected execution order, thus suppressing\n\ta number of destructive optimizations.\tHowever, they provide no\n\thardware ordering guarantees, and in fact many CPUs will happily\n\treorder marked writes with each other or with other unordered\n\toperations, unless these operations are to the same variable.\n\no\tMarked reads, such as READ_ONCE() and atomic_read().  These\n\tprimitives required the compiler to emit the corresponding load\n\tinstructions in the expected execution order, thus suppressing\n\ta number of destructive optimizations.\tHowever, they provide no\n\thardware ordering guarantees, and in fact many CPUs will happily\n\treorder marked reads with each other or with other unordered\n\toperations, unless these operations are to the same variable.\n\no\tUnordered RMW atomic operations.  These are non-value-returning\n\tRMW atomic operations whose names do not end in _acquire or\n\t_release, and also value-returning RMW operations whose names\n\tend in _relaxed.  Examples include atomic_add(), atomic_or(),\n\tand atomic64_fetch_xor_relaxed().  These operations do carry\n\tout the specified RMW operation atomically, for example, five\n\tconcurrent atomic_inc() operations applied to a given variable\n\twill reliably increase the value of that variable by five.\n\tHowever, many CPUs will happily reorder these operations with\n\teach other or with other unordered operations.\n\n\tThis category of operations can be efficiently ordered using\n\tsmp_mb__before_atomic() and smp_mb__after_atomic(), as was\n\tdiscussed in the \"RMW Ordering Augmentation Barriers\" section.\n\nIn short, these operations can be freely reordered unless they are all\noperating on a single variable or unless they are constrained by one of\nthe operations called out earlier in this document.\n\n\nUnmarked C-Language Accesses\n----------------------------\n\nUnmarked C-language accesses are normal variable accesses to normal\nvariables, that is, to variables that are not \"volatile\" and are not\nC11 atomic variables.  These operations provide no ordering guarantees,\nand further do not guarantee \"atomic\" access.  For example, the compiler\nmight (and sometimes does) split a plain C-language store into multiple\nsmaller stores.  A load from that same variable running on some other\nCPU while such a store is executing might see a value that is a mashup\nof the old value and the new value.\n\nUnmarked C-language accesses are unordered, and are also subject to\nany number of compiler optimizations, many of which can break your\nconcurrent code.  It is possible to used unmarked C-language accesses for\nshared variables that are subject to concurrent access, but great care\nis required on an ongoing basis.  The compiler-constraining barrier()\nprimitive can be helpful, as can the various ordering primitives discussed\nin this document.  It nevertheless bears repeating that use of unmarked\nC-language accesses requires careful attention to not just your code,\nbut to all the compilers that might be used to build it.  Such compilers\nmight replace a series of loads with a single load, and might replace\na series of stores with a single store.  Some compilers will even split\na single store into multiple smaller stores.\n\nBut there are some ways of using unmarked C-language accesses for shared\nvariables without such worries:\n\no\tGuard all accesses to a given variable by a particular lock,\n\tso that there are never concurrent conflicting accesses to\n\tthat variable.\t(There are \"conflicting accesses\" when\n\t(1) at least one of the concurrent accesses to a variable is an\n\tunmarked C-language access and (2) when at least one of those\n\taccesses is a write, whether marked or not.)\n\no\tAs above, but using other synchronization primitives such\n\tas reader-writer locks or sequence locks.\n\no\tUse locking or other means to ensure that all concurrent accesses\n\tto a given variable are reads.\n\no\tRestrict use of a given variable to statistics or heuristics\n\twhere the occasional bogus value can be tolerated.\n\no\tDeclare the accessed variables as C11 atomics.\n\thttps://lwn.net/Articles/691128/\n\no\tDeclare the accessed variables as \"volatile\".\n\nIf you need to live more dangerously, please do take the time to\nunderstand the compilers.  One place to start is these two LWN\narticles:\n\nWho's afraid of a big bad optimizing compiler?\n\thttps://lwn.net/Articles/793253\nCalibrating your fear of big bad optimizing compilers\n\thttps://lwn.net/Articles/799218\n\nUsed properly, unmarked C-language accesses can reduce overhead on\nfastpaths.  However, the price is great care and continual attention\nto your compiler as new versions come out and as new optimizations\nare enabled.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}