{
  "module_name": "control-dependencies.txt",
  "hash_id": "7602e0efd3e0ab585addb4ca8fca51897cd6ca331539dbe302b4fd0b23ad7fb2",
  "original_prompt": "Ingested from linux-6.6.14/tools/memory-model/Documentation/control-dependencies.txt",
  "human_readable_source": "CONTROL DEPENDENCIES\n====================\n\nA major difficulty with control dependencies is that current compilers\ndo not support them.  One purpose of this document is therefore to\nhelp you prevent your compiler from breaking your code.  However,\ncontrol dependencies also pose other challenges, which leads to the\nsecond purpose of this document, namely to help you to avoid breaking\nyour own code, even in the absence of help from your compiler.\n\nOne such challenge is that control dependencies order only later stores.\nTherefore, a load-load control dependency will not preserve ordering\nunless a read memory barrier is provided.  Consider the following code:\n\n\tq = READ_ONCE(a);\n\tif (q)\n\t\tp = READ_ONCE(b);\n\nThis is not guaranteed to provide any ordering because some types of CPUs\nare permitted to predict the result of the load from \"b\".  This prediction\ncan cause other CPUs to see this load as having happened before the load\nfrom \"a\".  This means that an explicit read barrier is required, for example\nas follows:\n\n\tq = READ_ONCE(a);\n\tif (q) {\n\t\tsmp_rmb();\n\t\tp = READ_ONCE(b);\n\t}\n\nHowever, stores are not speculated.  This means that ordering is\n(usually) guaranteed for load-store control dependencies, as in the\nfollowing example:\n\n\tq = READ_ONCE(a);\n\tif (q)\n\t\tWRITE_ONCE(b, 1);\n\nControl dependencies can pair with each other and with other types\nof ordering.  But please note that neither the READ_ONCE() nor the\nWRITE_ONCE() are optional.  Without the READ_ONCE(), the compiler might\nfuse the load from \"a\" with other loads.  Without the WRITE_ONCE(),\nthe compiler might fuse the store to \"b\" with other stores.  Worse yet,\nthe compiler might convert the store into a load and a check followed\nby a store, and this compiler-generated load would not be ordered by\nthe control dependency.\n\nFurthermore, if the compiler is able to prove that the value of variable\n\"a\" is always non-zero, it would be well within its rights to optimize\nthe original example by eliminating the \"if\" statement as follows:\n\n\tq = a;\n\tb = 1;  /* BUG: Compiler and CPU can both reorder!!! */\n\nSo don't leave out either the READ_ONCE() or the WRITE_ONCE().\nIn particular, although READ_ONCE() does force the compiler to emit a\nload, it does *not* force the compiler to actually use the loaded value.\n\nIt is tempting to try use control dependencies to enforce ordering on\nidentical stores on both branches of the \"if\" statement as follows:\n\n\tq = READ_ONCE(a);\n\tif (q) {\n\t\tbarrier();\n\t\tWRITE_ONCE(b, 1);\n\t\tdo_something();\n\t} else {\n\t\tbarrier();\n\t\tWRITE_ONCE(b, 1);\n\t\tdo_something_else();\n\t}\n\nUnfortunately, current compilers will transform this as follows at high\noptimization levels:\n\n\tq = READ_ONCE(a);\n\tbarrier();\n\tWRITE_ONCE(b, 1);  /* BUG: No ordering vs. load from a!!! */\n\tif (q) {\n\t\t/* WRITE_ONCE(b, 1); -- moved up, BUG!!! */\n\t\tdo_something();\n\t} else {\n\t\t/* WRITE_ONCE(b, 1); -- moved up, BUG!!! */\n\t\tdo_something_else();\n\t}\n\nNow there is no conditional between the load from \"a\" and the store to\n\"b\", which means that the CPU is within its rights to reorder them:  The\nconditional is absolutely required, and must be present in the final\nassembly code, after all of the compiler and link-time optimizations\nhave been applied.  Therefore, if you need ordering in this example,\nyou must use explicit memory ordering, for example, smp_store_release():\n\n\tq = READ_ONCE(a);\n\tif (q) {\n\t\tsmp_store_release(&b, 1);\n\t\tdo_something();\n\t} else {\n\t\tsmp_store_release(&b, 1);\n\t\tdo_something_else();\n\t}\n\nWithout explicit memory ordering, control-dependency-based ordering is\nguaranteed only when the stores differ, for example:\n\n\tq = READ_ONCE(a);\n\tif (q) {\n\t\tWRITE_ONCE(b, 1);\n\t\tdo_something();\n\t} else {\n\t\tWRITE_ONCE(b, 2);\n\t\tdo_something_else();\n\t}\n\nThe initial READ_ONCE() is still required to prevent the compiler from\nknowing too much about the value of \"a\".\n\nBut please note that you need to be careful what you do with the local\nvariable \"q\", otherwise the compiler might be able to guess the value\nand again remove the conditional branch that is absolutely required to\npreserve ordering.  For example:\n\n\tq = READ_ONCE(a);\n\tif (q % MAX) {\n\t\tWRITE_ONCE(b, 1);\n\t\tdo_something();\n\t} else {\n\t\tWRITE_ONCE(b, 2);\n\t\tdo_something_else();\n\t}\n\nIf MAX is compile-time defined to be 1, then the compiler knows that\n(q % MAX) must be equal to zero, regardless of the value of \"q\".\nThe compiler is therefore within its rights to transform the above code\ninto the following:\n\n\tq = READ_ONCE(a);\n\tWRITE_ONCE(b, 2);\n\tdo_something_else();\n\nGiven this transformation, the CPU is not required to respect the ordering\nbetween the load from variable \"a\" and the store to variable \"b\".  It is\ntempting to add a barrier(), but this does not help.  The conditional\nis gone, and the barrier won't bring it back.  Therefore, if you need\nto relying on control dependencies to produce this ordering, you should\nmake sure that MAX is greater than one, perhaps as follows:\n\n\tq = READ_ONCE(a);\n\tBUILD_BUG_ON(MAX <= 1); /* Order load from a with store to b. */\n\tif (q % MAX) {\n\t\tWRITE_ONCE(b, 1);\n\t\tdo_something();\n\t} else {\n\t\tWRITE_ONCE(b, 2);\n\t\tdo_something_else();\n\t}\n\nPlease note once again that each leg of the \"if\" statement absolutely\nmust store different values to \"b\".  As in previous examples, if the two\nvalues were identical, the compiler could pull this store outside of the\n\"if\" statement, destroying the control dependency's ordering properties.\n\nYou must also be careful avoid relying too much on boolean short-circuit\nevaluation.  Consider this example:\n\n\tq = READ_ONCE(a);\n\tif (q || 1 > 0)\n\t\tWRITE_ONCE(b, 1);\n\nBecause the first condition cannot fault and the second condition is\nalways true, the compiler can transform this example as follows, again\ndestroying the control dependency's ordering:\n\n\tq = READ_ONCE(a);\n\tWRITE_ONCE(b, 1);\n\nThis is yet another example showing the importance of preventing the\ncompiler from out-guessing your code.  Again, although READ_ONCE() really\ndoes force the compiler to emit code for a given load, the compiler is\nwithin its rights to discard the loaded value.\n\nIn addition, control dependencies apply only to the then-clause and\nelse-clause of the \"if\" statement in question.  In particular, they do\nnot necessarily order the code following the entire \"if\" statement:\n\n\tq = READ_ONCE(a);\n\tif (q) {\n\t\tWRITE_ONCE(b, 1);\n\t} else {\n\t\tWRITE_ONCE(b, 2);\n\t}\n\tWRITE_ONCE(c, 1);  /* BUG: No ordering against the read from \"a\". */\n\nIt is tempting to argue that there in fact is ordering because the\ncompiler cannot reorder volatile accesses and also cannot reorder\nthe writes to \"b\" with the condition.  Unfortunately for this line\nof reasoning, the compiler might compile the two writes to \"b\" as\nconditional-move instructions, as in this fanciful pseudo-assembly\nlanguage:\n\n\tld r1,a\n\tcmp r1,$0\n\tcmov,ne r4,$1\n\tcmov,eq r4,$2\n\tst r4,b\n\tst $1,c\n\nThe control dependencies would then extend only to the pair of cmov\ninstructions and the store depending on them.  This means that a weakly\nordered CPU would have no dependency of any sort between the load from\n\"a\" and the store to \"c\".  In short, control dependencies provide ordering\nonly to the stores in the then-clause and else-clause of the \"if\" statement\nin question (including functions invoked by those two clauses), and not\nto code following that \"if\" statement.\n\n\nIn summary:\n\n  (*) Control dependencies can order prior loads against later stores.\n      However, they do *not* guarantee any other sort of ordering:\n      Not prior loads against later loads, nor prior stores against\n      later anything.  If you need these other forms of ordering, use\n      smp_load_acquire(), smp_store_release(), or, in the case of prior\n      stores and later loads, smp_mb().\n\n  (*) If both legs of the \"if\" statement contain identical stores to\n      the same variable, then you must explicitly order those stores,\n      either by preceding both of them with smp_mb() or by using\n      smp_store_release().  Please note that it is *not* sufficient to use\n      barrier() at beginning and end of each leg of the \"if\" statement\n      because, as shown by the example above, optimizing compilers can\n      destroy the control dependency while respecting the letter of the\n      barrier() law.\n\n  (*) Control dependencies require at least one run-time conditional\n      between the prior load and the subsequent store, and this\n      conditional must involve the prior load.  If the compiler is able\n      to optimize the conditional away, it will have also optimized\n      away the ordering.  Careful use of READ_ONCE() and WRITE_ONCE()\n      can help to preserve the needed conditional.\n\n  (*) Control dependencies require that the compiler avoid reordering the\n      dependency into nonexistence.  Careful use of READ_ONCE() or\n      atomic{,64}_read() can help to preserve your control dependency.\n\n  (*) Control dependencies apply only to the then-clause and else-clause\n      of the \"if\" statement containing the control dependency, including\n      any functions that these two clauses call.  Control dependencies\n      do *not* apply to code beyond the end of that \"if\" statement.\n\n  (*) Control dependencies pair normally with other types of barriers.\n\n  (*) Control dependencies do *not* provide multicopy atomicity.  If you\n      need all the CPUs to agree on the ordering of a given store against\n      all other accesses, use smp_mb().\n\n  (*) Compilers do not understand control dependencies.  It is therefore\n      your job to ensure that they do not break your code.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}