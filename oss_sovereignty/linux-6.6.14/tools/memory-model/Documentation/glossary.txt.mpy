{
  "module_name": "glossary.txt",
  "hash_id": "79d53bb61c0f0bf1f69f47dfc32002b8fd5d53f3882819a09739e8739a82dfd2",
  "original_prompt": "Ingested from linux-6.6.14/tools/memory-model/Documentation/glossary.txt",
  "human_readable_source": "This document contains brief definitions of LKMM-related terms.  Like most\nglossaries, it is not intended to be read front to back (except perhaps\nas a way of confirming a diagnosis of OCD), but rather to be searched\nfor specific terms.\n\n\nAddress Dependency:  When the address of a later memory access is computed\n\tbased on the value returned by an earlier load, an \"address\n\tdependency\" extends from that load extending to the later access.\n\tAddress dependencies are quite common in RCU read-side critical\n\tsections:\n\n\t 1 rcu_read_lock();\n\t 2 p = rcu_dereference(gp);\n\t 3 do_something(p->a);\n\t 4 rcu_read_unlock();\n\n\t In this case, because the address of \"p->a\" on line 3 is computed\n\t from the value returned by the rcu_dereference() on line 2, the\n\t address dependency extends from that rcu_dereference() to that\n\t \"p->a\".  In rare cases, optimizing compilers can destroy address\n\t dependencies.\tPlease see Documentation/RCU/rcu_dereference.rst\n\t for more information.\n\n\t See also \"Control Dependency\" and \"Data Dependency\".\n\nAcquire:  With respect to a lock, acquiring that lock, for example,\n\tusing spin_lock().  With respect to a non-lock shared variable,\n\ta special operation that includes a load and which orders that\n\tload before later memory references running on that same CPU.\n\tAn example special acquire operation is smp_load_acquire(),\n\tbut atomic_read_acquire() and atomic_xchg_acquire() also include\n\tacquire loads.\n\n\tWhen an acquire load returns the value stored by a release store\n\tto that same variable, (in other words, the acquire load \"reads\n\tfrom\" the release store), then all operations preceding that\n\tstore \"happen before\" any operations following that load acquire.\n\n\tSee also \"Happens-Before\", \"Reads-From\", \"Relaxed\", and \"Release\".\n\nCoherence (co):  When one CPU's store to a given variable overwrites\n\teither the value from another CPU's store or some later value,\n\tthere is said to be a coherence link from the second CPU to\n\tthe first.\n\n\tIt is also possible to have a coherence link within a CPU, which\n\tis a \"coherence internal\" (coi) link.  The term \"coherence\n\texternal\" (coe) link is used when it is necessary to exclude\n\tthe coi case.\n\n\tSee also \"From-reads\" and \"Reads-from\".\n\nControl Dependency:  When a later store's execution depends on a test\n\tof a value computed from a value returned by an earlier load,\n\ta \"control dependency\" extends from that load to that store.\n\tFor example:\n\n\t 1 if (READ_ONCE(x))\n\t 2   WRITE_ONCE(y, 1);\n\n\t Here, the control dependency extends from the READ_ONCE() on\n\t line 1 to the WRITE_ONCE() on line 2.\tControl dependencies are\n\t fragile, and can be easily destroyed by optimizing compilers.\n\t Please see control-dependencies.txt for more information.\n\n\t See also \"Address Dependency\" and \"Data Dependency\".\n\nCycle:\tMemory-barrier pairing is restricted to a pair of CPUs, as the\n\tname suggests.\tAnd in a great many cases, a pair of CPUs is all\n\tthat is required.  In other cases, the notion of pairing must be\n\textended to additional CPUs, and the result is called a \"cycle\".\n\tIn a cycle, each CPU's ordering interacts with that of the next:\n\n\tCPU 0                CPU 1                CPU 2\n\tWRITE_ONCE(x, 1);    WRITE_ONCE(y, 1);    WRITE_ONCE(z, 1);\n\tsmp_mb();            smp_mb();            smp_mb();\n\tr0 = READ_ONCE(y);   r1 = READ_ONCE(z);   r2 = READ_ONCE(x);\n\n\tCPU 0's smp_mb() interacts with that of CPU 1, which interacts\n\twith that of CPU 2, which in turn interacts with that of CPU 0\n\tto complete the cycle.\tBecause of the smp_mb() calls between\n\teach pair of memory accesses, the outcome where r0, r1, and r2\n\tare all equal to zero is forbidden by LKMM.\n\n\tSee also \"Pairing\".\n\nData Dependency:  When the data written by a later store is computed based\n\ton the value returned by an earlier load, a \"data dependency\"\n\textends from that load to that later store.  For example:\n\n\t 1 r1 = READ_ONCE(x);\n\t 2 WRITE_ONCE(y, r1 + 1);\n\n\tIn this case, the data dependency extends from the READ_ONCE()\n\ton line 1 to the WRITE_ONCE() on line 2.  Data dependencies are\n\tfragile and can be easily destroyed by optimizing compilers.\n\tBecause optimizing compilers put a great deal of effort into\n\tworking out what values integer variables might have, this is\n\tespecially true in cases where the dependency is carried through\n\tan integer.\n\n\tSee also \"Address Dependency\" and \"Control Dependency\".\n\nFrom-Reads (fr):  When one CPU's store to a given variable happened\n\ttoo late to affect the value returned by another CPU's\n\tload from that same variable, there is said to be a from-reads\n\tlink from the load to the store.\n\n\tIt is also possible to have a from-reads link within a CPU, which\n\tis a \"from-reads internal\" (fri) link.  The term \"from-reads\n\texternal\" (fre) link is used when it is necessary to exclude\n\tthe fri case.\n\n\tSee also \"Coherence\" and \"Reads-from\".\n\nFully Ordered:  An operation such as smp_mb() that orders all of\n\tits CPU's prior accesses with all of that CPU's subsequent\n\taccesses, or a marked access such as atomic_add_return()\n\tthat orders all of its CPU's prior accesses, itself, and\n\tall of its CPU's subsequent accesses.\n\nHappens-Before (hb): A relation between two accesses in which LKMM\n\tguarantees the first access precedes the second.  For more\n\tdetail, please see the \"THE HAPPENS-BEFORE RELATION: hb\"\n\tsection of explanation.txt.\n\nMarked Access:  An access to a variable that uses an special function or\n\tmacro such as \"r1 = READ_ONCE(x)\" or \"smp_store_release(&a, 1)\".\n\n\tSee also \"Unmarked Access\".\n\nPairing: \"Memory-barrier pairing\" reflects the fact that synchronizing\n\tdata between two CPUs requires that both CPUs their accesses.\n\tMemory barriers thus tend to come in pairs, one executed by\n\tone of the CPUs and the other by the other CPU.  Of course,\n\tpairing also occurs with other types of operations, so that a\n\tsmp_store_release() pairs with an smp_load_acquire() that reads\n\tthe value stored.\n\n\tSee also \"Cycle\".\n\nReads-From (rf):  When one CPU's load returns the value stored by some other\n\tCPU, there is said to be a reads-from link from the second\n\tCPU's store to the first CPU's load.  Reads-from links have the\n\tnice property that time must advance from the store to the load,\n\twhich means that algorithms using reads-from links can use lighter\n\tweight ordering and synchronization compared to algorithms using\n\tcoherence and from-reads links.\n\n\tIt is also possible to have a reads-from link within a CPU, which\n\tis a \"reads-from internal\" (rfi) link.\tThe term \"reads-from\n\texternal\" (rfe) link is used when it is necessary to exclude\n\tthe rfi case.\n\n\tSee also Coherence\" and \"From-reads\".\n\nRelaxed:  A marked access that does not imply ordering, for example, a\n\tREAD_ONCE(), WRITE_ONCE(), a non-value-returning read-modify-write\n\toperation, or a value-returning read-modify-write operation whose\n\tname ends in \"_relaxed\".\n\n\tSee also \"Acquire\" and \"Release\".\n\nRelease:  With respect to a lock, releasing that lock, for example,\n\tusing spin_unlock().  With respect to a non-lock shared variable,\n\ta special operation that includes a store and which orders that\n\tstore after earlier memory references that ran on that same CPU.\n\tAn example special release store is smp_store_release(), but\n\tatomic_set_release() and atomic_cmpxchg_release() also include\n\trelease stores.\n\n\tSee also \"Acquire\" and \"Relaxed\".\n\nUnmarked Access:  An access to a variable that uses normal C-language\n\tsyntax, for example, \"a = b[2]\";\n\n\tSee also \"Marked Access\".\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}