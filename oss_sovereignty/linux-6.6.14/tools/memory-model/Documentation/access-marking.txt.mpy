{
  "module_name": "access-marking.txt",
  "hash_id": "fd946fb87e2daf44c4c7dde870c246f15fe689aab368171d017e3f4e8c4d5985",
  "original_prompt": "Ingested from linux-6.6.14/tools/memory-model/Documentation/access-marking.txt",
  "human_readable_source": "MARKING SHARED-MEMORY ACCESSES\n==============================\n\nThis document provides guidelines for marking intentionally concurrent\nnormal accesses to shared memory, that is \"normal\" as in accesses that do\nnot use read-modify-write atomic operations.  It also describes how to\ndocument these accesses, both with comments and with special assertions\nprocessed by the Kernel Concurrency Sanitizer (KCSAN).  This discussion\nbuilds on an earlier LWN article [1].\n\n\nACCESS-MARKING OPTIONS\n======================\n\nThe Linux kernel provides the following access-marking options:\n\n1.\tPlain C-language accesses (unmarked), for example, \"a = b;\"\n\n2.\tData-race marking, for example, \"data_race(a = b);\"\n\n3.\tREAD_ONCE(), for example, \"a = READ_ONCE(b);\"\n\tThe various forms of atomic_read() also fit in here.\n\n4.\tWRITE_ONCE(), for example, \"WRITE_ONCE(a, b);\"\n\tThe various forms of atomic_set() also fit in here.\n\n\nThese may be used in combination, as shown in this admittedly improbable\nexample:\n\n\tWRITE_ONCE(a, b + data_race(c + d) + READ_ONCE(e));\n\nNeither plain C-language accesses nor data_race() (#1 and #2 above) place\nany sort of constraint on the compiler's choice of optimizations [2].\nIn contrast, READ_ONCE() and WRITE_ONCE() (#3 and #4 above) restrict the\ncompiler's use of code-motion and common-subexpression optimizations.\nTherefore, if a given access is involved in an intentional data race,\nusing READ_ONCE() for loads and WRITE_ONCE() for stores is usually\npreferable to data_race(), which in turn is usually preferable to plain\nC-language accesses.  It is permissible to combine #2 and #3, for example,\ndata_race(READ_ONCE(a)), which will both restrict compiler optimizations\nand disable KCSAN diagnostics.\n\nKCSAN will complain about many types of data races involving plain\nC-language accesses, but marking all accesses involved in a given data\nrace with one of data_race(), READ_ONCE(), or WRITE_ONCE(), will prevent\nKCSAN from complaining.  Of course, lack of KCSAN complaints does not\nimply correct code.  Therefore, please take a thoughtful approach\nwhen responding to KCSAN complaints.  Churning the code base with\nill-considered additions of data_race(), READ_ONCE(), and WRITE_ONCE()\nis unhelpful.\n\nIn fact, the following sections describe situations where use of\ndata_race() and even plain C-language accesses is preferable to\nREAD_ONCE() and WRITE_ONCE().\n\n\nUse of the data_race() Macro\n----------------------------\n\nHere are some situations where data_race() should be used instead of\nREAD_ONCE() and WRITE_ONCE():\n\n1.\tData-racy loads from shared variables whose values are used only\n\tfor diagnostic purposes.\n\n2.\tData-racy reads whose values are checked against marked reload.\n\n3.\tReads whose values feed into error-tolerant heuristics.\n\n4.\tWrites setting values that feed into error-tolerant heuristics.\n\n\nData-Racy Reads for Approximate Diagnostics\n\nApproximate diagnostics include lockdep reports, monitoring/statistics\n(including /proc and /sys output), WARN*()/BUG*() checks whose return\nvalues are ignored, and other situations where reads from shared variables\nare not an integral part of the core concurrency design.\n\nIn fact, use of data_race() instead READ_ONCE() for these diagnostic\nreads can enable better checking of the remaining accesses implementing\nthe core concurrency design.  For example, suppose that the core design\nprevents any non-diagnostic reads from shared variable x from running\nconcurrently with updates to x.  Then using plain C-language writes\nto x allows KCSAN to detect reads from x from within regions of code\nthat fail to exclude the updates.  In this case, it is important to use\ndata_race() for the diagnostic reads because otherwise KCSAN would give\nfalse-positive warnings about these diagnostic reads.\n\nIf it is necessary to both restrict compiler optimizations and disable\nKCSAN diagnostics, use both data_race() and READ_ONCE(), for example,\ndata_race(READ_ONCE(a)).\n\nIn theory, plain C-language loads can also be used for this use case.\nHowever, in practice this will have the disadvantage of causing KCSAN\nto generate false positives because KCSAN will have no way of knowing\nthat the resulting data race was intentional.\n\n\nData-Racy Reads That Are Checked Against Marked Reload\n\nThe values from some reads are not implicitly trusted.  They are instead\nfed into some operation that checks the full value against a later marked\nload from memory, which means that the occasional arbitrarily bogus value\nis not a problem.  For example, if a bogus value is fed into cmpxchg(),\nall that happens is that this cmpxchg() fails, which normally results\nin a retry.  Unless the race condition that resulted in the bogus value\nrecurs, this retry will with high probability succeed, so no harm done.\n\nHowever, please keep in mind that a data_race() load feeding into\na cmpxchg_relaxed() might still be subject to load fusing on some\narchitectures.  Therefore, it is best to capture the return value from\nthe failing cmpxchg() for the next iteration of the loop, an approach\nthat provides the compiler much less scope for mischievous optimizations.\nCapturing the return value from cmpxchg() also saves a memory reference\nin many cases.\n\nIn theory, plain C-language loads can also be used for this use case.\nHowever, in practice this will have the disadvantage of causing KCSAN\nto generate false positives because KCSAN will have no way of knowing\nthat the resulting data race was intentional.\n\n\nReads Feeding Into Error-Tolerant Heuristics\n\nValues from some reads feed into heuristics that can tolerate occasional\nerrors.  Such reads can use data_race(), thus allowing KCSAN to focus on\nthe other accesses to the relevant shared variables.  But please note\nthat data_race() loads are subject to load fusing, which can result in\nconsistent errors, which in turn are quite capable of breaking heuristics.\nTherefore use of data_race() should be limited to cases where some other\ncode (such as a barrier() call) will force the occasional reload.\n\nNote that this use case requires that the heuristic be able to handle\nany possible error.  In contrast, if the heuristics might be fatally\nconfused by one or more of the possible erroneous values, use READ_ONCE()\ninstead of data_race().\n\nIn theory, plain C-language loads can also be used for this use case.\nHowever, in practice this will have the disadvantage of causing KCSAN\nto generate false positives because KCSAN will have no way of knowing\nthat the resulting data race was intentional.\n\n\nWrites Setting Values Feeding Into Error-Tolerant Heuristics\n\nThe values read into error-tolerant heuristics come from somewhere,\nfor example, from sysfs.  This means that some code in sysfs writes\nto this same variable, and these writes can also use data_race().\nAfter all, if the heuristic can tolerate the occasional bogus value\ndue to compiler-mangled reads, it can also tolerate the occasional\ncompiler-mangled write, at least assuming that the proper value is in\nplace once the write completes.\n\nPlain C-language stores can also be used for this use case.  However,\nin kernels built with CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=n, this\nwill have the disadvantage of causing KCSAN to generate false positives\nbecause KCSAN will have no way of knowing that the resulting data race\nwas intentional.\n\n\nUse of Plain C-Language Accesses\n--------------------------------\n\nHere are some example situations where plain C-language accesses should\nused instead of READ_ONCE(), WRITE_ONCE(), and data_race():\n\n1.\tAccesses protected by mutual exclusion, including strict locking\n\tand sequence locking.\n\n2.\tInitialization-time and cleanup-time accesses.\tThis covers a\n\twide variety of situations, including the uniprocessor phase of\n\tsystem boot, variables to be used by not-yet-spawned kthreads,\n\tstructures not yet published to reference-counted or RCU-protected\n\tdata structures, and the cleanup side of any of these situations.\n\n3.\tPer-CPU variables that are not accessed from other CPUs.\n\n4.\tPrivate per-task variables, including on-stack variables, some\n\tfields in the task_struct structure, and task-private heap data.\n\n5.\tAny other loads for which there is not supposed to be a concurrent\n\tstore to that same variable.\n\n6.\tAny other stores for which there should be neither concurrent\n\tloads nor concurrent stores to that same variable.\n\n\tBut note that KCSAN makes two explicit exceptions to this rule\n\tby default, refraining from flagging plain C-language stores:\n\n\ta.\tNo matter what.  You can override this default by building\n\t\twith CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=n.\n\n\tb.\tWhen the store writes the value already contained in\n\t\tthat variable.\tYou can override this default by building\n\t\twith CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY=n.\n\n\tc.\tWhen one of the stores is in an interrupt handler and\n\t\tthe other in the interrupted code.  You can override this\n\t\tdefault by building with CONFIG_KCSAN_INTERRUPT_WATCHER=y.\n\nNote that it is important to use plain C-language accesses in these cases,\nbecause doing otherwise prevents KCSAN from detecting violations of your\ncode's synchronization rules.\n\n\nACCESS-DOCUMENTATION OPTIONS\n============================\n\nIt is important to comment marked accesses so that people reading your\ncode, yourself included, are reminded of the synchronization design.\nHowever, it is even more important to comment plain C-language accesses\nthat are intentionally involved in data races.  Such comments are\nneeded to remind people reading your code, again, yourself included,\nof how the compiler has been prevented from optimizing those accesses\ninto concurrency bugs.\n\nIt is also possible to tell KCSAN about your synchronization design.\nFor example, ASSERT_EXCLUSIVE_ACCESS(foo) tells KCSAN that any\nconcurrent access to variable foo by any other CPU is an error, even\nif that concurrent access is marked with READ_ONCE().  In addition,\nASSERT_EXCLUSIVE_WRITER(foo) tells KCSAN that although it is OK for there\nto be concurrent reads from foo from other CPUs, it is an error for some\nother CPU to be concurrently writing to foo, even if that concurrent\nwrite is marked with data_race() or WRITE_ONCE().\n\nNote that although KCSAN will call out data races involving either\nASSERT_EXCLUSIVE_ACCESS() or ASSERT_EXCLUSIVE_WRITER() on the one hand\nand data_race() writes on the other, KCSAN will not report the location\nof these data_race() writes.\n\n\nEXAMPLES\n========\n\nAs noted earlier, the goal is to prevent the compiler from destroying\nyour concurrent algorithm, to help the human reader, and to inform\nKCSAN of aspects of your concurrency design.  This section looks at a\nfew examples showing how this can be done.\n\n\nLock Protection With Lockless Diagnostic Access\n-----------------------------------------------\n\nFor example, suppose a shared variable \"foo\" is read only while a\nreader-writer spinlock is read-held, written only while that same\nspinlock is write-held, except that it is also read locklessly for\ndiagnostic purposes.  The code might look as follows:\n\n\tint foo;\n\tDEFINE_RWLOCK(foo_rwlock);\n\n\tvoid update_foo(int newval)\n\t{\n\t\twrite_lock(&foo_rwlock);\n\t\tfoo = newval;\n\t\tdo_something(newval);\n\t\twrite_unlock(&foo_rwlock);\n\t}\n\n\tint read_foo(void)\n\t{\n\t\tint ret;\n\n\t\tread_lock(&foo_rwlock);\n\t\tdo_something_else();\n\t\tret = foo;\n\t\tread_unlock(&foo_rwlock);\n\t\treturn ret;\n\t}\n\n\tvoid read_foo_diagnostic(void)\n\t{\n\t\tpr_info(\"Current value of foo: %d\\n\", data_race(foo));\n\t}\n\nThe reader-writer lock prevents the compiler from introducing concurrency\nbugs into any part of the main algorithm using foo, which means that\nthe accesses to foo within both update_foo() and read_foo() can (and\nshould) be plain C-language accesses.  One benefit of making them be\nplain C-language accesses is that KCSAN can detect any erroneous lockless\nreads from or updates to foo.  The data_race() in read_foo_diagnostic()\ntells KCSAN that data races are expected, and should be silently\nignored.  This data_race() also tells the human reading the code that\nread_foo_diagnostic() might sometimes return a bogus value.\n\nIf it is necessary to suppress compiler optimization and also detect\nbuggy lockless writes, read_foo_diagnostic() can be updated as follows:\n\n\tvoid read_foo_diagnostic(void)\n\t{\n\t\tpr_info(\"Current value of foo: %d\\n\", data_race(READ_ONCE(foo)));\n\t}\n\nAlternatively, given that KCSAN is to ignore all accesses in this function,\nthis function can be marked __no_kcsan and the data_race() can be dropped:\n\n\tvoid __no_kcsan read_foo_diagnostic(void)\n\t{\n\t\tpr_info(\"Current value of foo: %d\\n\", READ_ONCE(foo));\n\t}\n\nHowever, in order for KCSAN to detect buggy lockless writes, your kernel\nmust be built with CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=n.  If you\nneed KCSAN to detect such a write even if that write did not change\nthe value of foo, you also need CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY=n.\nIf you need KCSAN to detect such a write happening in an interrupt handler\nrunning on the same CPU doing the legitimate lock-protected write, you\nalso need CONFIG_KCSAN_INTERRUPT_WATCHER=y.  With some or all of these\nKconfig options set properly, KCSAN can be quite helpful, although\nit is not necessarily a full replacement for hardware watchpoints.\nOn the other hand, neither are hardware watchpoints a full replacement\nfor KCSAN because it is not always easy to tell hardware watchpoint to\nconditionally trap on accesses.\n\n\nLock-Protected Writes With Lockless Reads\n-----------------------------------------\n\nFor another example, suppose a shared variable \"foo\" is updated only\nwhile holding a spinlock, but is read locklessly.  The code might look\nas follows:\n\n\tint foo;\n\tDEFINE_SPINLOCK(foo_lock);\n\n\tvoid update_foo(int newval)\n\t{\n\t\tspin_lock(&foo_lock);\n\t\tWRITE_ONCE(foo, newval);\n\t\tASSERT_EXCLUSIVE_WRITER(foo);\n\t\tdo_something(newval);\n\t\tspin_unlock(&foo_wlock);\n\t}\n\n\tint read_foo(void)\n\t{\n\t\tdo_something_else();\n\t\treturn READ_ONCE(foo);\n\t}\n\nBecause foo is read locklessly, all accesses are marked.  The purpose\nof the ASSERT_EXCLUSIVE_WRITER() is to allow KCSAN to check for a buggy\nconcurrent lockless write.\n\n\nLock-Protected Writes With Heuristic Lockless Reads\n---------------------------------------------------\n\nFor another example, suppose that the code can normally make use of\na per-data-structure lock, but there are times when a global lock\nis required.  These times are indicated via a global flag.  The code\nmight look as follows, and is based loosely on nf_conntrack_lock(),\nnf_conntrack_all_lock(), and nf_conntrack_all_unlock():\n\n\tbool global_flag;\n\tDEFINE_SPINLOCK(global_lock);\n\tstruct foo {\n\t\tspinlock_t f_lock;\n\t\tint f_data;\n\t};\n\n\t/* All foo structures are in the following array. */\n\tint nfoo;\n\tstruct foo *foo_array;\n\n\tvoid do_something_locked(struct foo *fp)\n\t{\n\t\t/* This works even if data_race() returns nonsense. */\n\t\tif (!data_race(global_flag)) {\n\t\t\tspin_lock(&fp->f_lock);\n\t\t\tif (!smp_load_acquire(&global_flag)) {\n\t\t\t\tdo_something(fp);\n\t\t\t\tspin_unlock(&fp->f_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tspin_unlock(&fp->f_lock);\n\t\t}\n\t\tspin_lock(&global_lock);\n\t\t/* global_lock held, thus global flag cannot be set. */\n\t\tspin_lock(&fp->f_lock);\n\t\tspin_unlock(&global_lock);\n\t\t/*\n\t\t * global_flag might be set here, but begin_global()\n\t\t * will wait for ->f_lock to be released.\n\t\t */\n\t\tdo_something(fp);\n\t\tspin_unlock(&fp->f_lock);\n\t}\n\n\tvoid begin_global(void)\n\t{\n\t\tint i;\n\n\t\tspin_lock(&global_lock);\n\t\tWRITE_ONCE(global_flag, true);\n\t\tfor (i = 0; i < nfoo; i++) {\n\t\t\t/*\n\t\t\t * Wait for pre-existing local locks.  One at\n\t\t\t * a time to avoid lockdep limitations.\n\t\t\t */\n\t\t\tspin_lock(&fp->f_lock);\n\t\t\tspin_unlock(&fp->f_lock);\n\t\t}\n\t}\n\n\tvoid end_global(void)\n\t{\n\t\tsmp_store_release(&global_flag, false);\n\t\tspin_unlock(&global_lock);\n\t}\n\nAll code paths leading from the do_something_locked() function's first\nread from global_flag acquire a lock, so endless load fusing cannot\nhappen.\n\nIf the value read from global_flag is true, then global_flag is\nrechecked while holding ->f_lock, which, if global_flag is now false,\nprevents begin_global() from completing.  It is therefore safe to invoke\ndo_something().\n\nOtherwise, if either value read from global_flag is true, then after\nglobal_lock is acquired global_flag must be false.  The acquisition of\n->f_lock will prevent any call to begin_global() from returning, which\nmeans that it is safe to release global_lock and invoke do_something().\n\nFor this to work, only those foo structures in foo_array[] may be passed\nto do_something_locked().  The reason for this is that the synchronization\nwith begin_global() relies on momentarily holding the lock of each and\nevery foo structure.\n\nThe smp_load_acquire() and smp_store_release() are required because\nchanges to a foo structure between calls to begin_global() and\nend_global() are carried out without holding that structure's ->f_lock.\nThe smp_load_acquire() and smp_store_release() ensure that the next\ninvocation of do_something() from do_something_locked() will see those\nchanges.\n\n\nLockless Reads and Writes\n-------------------------\n\nFor another example, suppose a shared variable \"foo\" is both read and\nupdated locklessly.  The code might look as follows:\n\n\tint foo;\n\n\tint update_foo(int newval)\n\t{\n\t\tint ret;\n\n\t\tret = xchg(&foo, newval);\n\t\tdo_something(newval);\n\t\treturn ret;\n\t}\n\n\tint read_foo(void)\n\t{\n\t\tdo_something_else();\n\t\treturn READ_ONCE(foo);\n\t}\n\nBecause foo is accessed locklessly, all accesses are marked.  It does\nnot make sense to use ASSERT_EXCLUSIVE_WRITER() in this case because\nthere really can be concurrent lockless writers.  KCSAN would\nflag any concurrent plain C-language reads from foo, and given\nCONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=n, also any concurrent plain\nC-language writes to foo.\n\n\nLockless Reads and Writes, But With Single-Threaded Initialization\n------------------------------------------------------------------\n\nFor yet another example, suppose that foo is initialized in a\nsingle-threaded manner, but that a number of kthreads are then created\nthat locklessly and concurrently access foo.  Some snippets of this code\nmight look as follows:\n\n\tint foo;\n\n\tvoid initialize_foo(int initval, int nkthreads)\n\t{\n\t\tint i;\n\n\t\tfoo = initval;\n\t\tASSERT_EXCLUSIVE_ACCESS(foo);\n\t\tfor (i = 0; i < nkthreads; i++)\n\t\t\tkthread_run(access_foo_concurrently, ...);\n\t}\n\n\t/* Called from access_foo_concurrently(). */\n\tint update_foo(int newval)\n\t{\n\t\tint ret;\n\n\t\tret = xchg(&foo, newval);\n\t\tdo_something(newval);\n\t\treturn ret;\n\t}\n\n\t/* Also called from access_foo_concurrently(). */\n\tint read_foo(void)\n\t{\n\t\tdo_something_else();\n\t\treturn READ_ONCE(foo);\n\t}\n\nThe initialize_foo() uses a plain C-language write to foo because there\nare not supposed to be concurrent accesses during initialization.  The\nASSERT_EXCLUSIVE_ACCESS() allows KCSAN to flag buggy concurrent unmarked\nreads, and the ASSERT_EXCLUSIVE_ACCESS() call further allows KCSAN to\nflag buggy concurrent writes, even if:  (1) Those writes are marked or\n(2) The kernel was built with CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=y.\n\n\nChecking Stress-Test Race Coverage\n----------------------------------\n\nWhen designing stress tests it is important to ensure that race conditions\nof interest really do occur.  For example, consider the following code\nfragment:\n\n\tint foo;\n\n\tint update_foo(int newval)\n\t{\n\t\treturn xchg(&foo, newval);\n\t}\n\n\tint xor_shift_foo(int shift, int mask)\n\t{\n\t\tint old, new, newold;\n\n\t\tnewold = data_race(foo); /* Checked by cmpxchg(). */\n\t\tdo {\n\t\t\told = newold;\n\t\t\tnew = (old << shift) ^ mask;\n\t\t\tnewold = cmpxchg(&foo, old, new);\n\t\t} while (newold != old);\n\t\treturn old;\n\t}\n\n\tint read_foo(void)\n\t{\n\t\treturn READ_ONCE(foo);\n\t}\n\nIf it is possible for update_foo(), xor_shift_foo(), and read_foo() to be\ninvoked concurrently, the stress test should force this concurrency to\nactually happen.  KCSAN can evaluate the stress test when the above code\nis modified to read as follows:\n\n\tint foo;\n\n\tint update_foo(int newval)\n\t{\n\t\tASSERT_EXCLUSIVE_ACCESS(foo);\n\t\treturn xchg(&foo, newval);\n\t}\n\n\tint xor_shift_foo(int shift, int mask)\n\t{\n\t\tint old, new, newold;\n\n\t\tnewold = data_race(foo); /* Checked by cmpxchg(). */\n\t\tdo {\n\t\t\told = newold;\n\t\t\tnew = (old << shift) ^ mask;\n\t\t\tASSERT_EXCLUSIVE_ACCESS(foo);\n\t\t\tnewold = cmpxchg(&foo, old, new);\n\t\t} while (newold != old);\n\t\treturn old;\n\t}\n\n\n\tint read_foo(void)\n\t{\n\t\tASSERT_EXCLUSIVE_ACCESS(foo);\n\t\treturn READ_ONCE(foo);\n\t}\n\nIf a given stress-test run does not result in KCSAN complaints from\neach possible pair of ASSERT_EXCLUSIVE_ACCESS() invocations, the\nstress test needs improvement.  If the stress test was to be evaluated\non a regular basis, it would be wise to place the above instances of\nASSERT_EXCLUSIVE_ACCESS() under #ifdef so that they did not result in\nfalse positives when not evaluating the stress test.\n\n\nREFERENCES\n==========\n\n[1] \"Concurrency bugs should fear the big bad data-race detector (part 2)\"\n    https://lwn.net/Articles/816854/\n\n[2] \"Who's afraid of a big bad optimizing compiler?\"\n    https://lwn.net/Articles/793253/\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}