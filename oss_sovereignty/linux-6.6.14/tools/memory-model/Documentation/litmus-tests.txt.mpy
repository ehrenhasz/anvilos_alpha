{
  "module_name": "litmus-tests.txt",
  "hash_id": "f7a5804c230527695aa4fe6ed62135a7f64d7485bf933a0a8b4a465e68fbfa76",
  "original_prompt": "Ingested from linux-6.6.14/tools/memory-model/Documentation/litmus-tests.txt",
  "human_readable_source": "Linux-Kernel Memory Model Litmus Tests\n======================================\n\nThis file describes the LKMM litmus-test format by example, describes\nsome tricks and traps, and finally outlines LKMM's limitations.  Earlier\nversions of this material appeared in a number of LWN articles, including:\n\nhttps://lwn.net/Articles/720550/\n\tA formal kernel memory-ordering model (part 2)\nhttps://lwn.net/Articles/608550/\n\tAxiomatic validation of memory barriers and atomic instructions\nhttps://lwn.net/Articles/470681/\n\tValidating Memory Barriers and Atomic Instructions\n\nThis document presents information in decreasing order of applicability,\nso that, where possible, the information that has proven more commonly\nuseful is shown near the beginning.\n\nFor information on installing LKMM, including the underlying \"herd7\"\ntool, please see tools/memory-model/README.\n\n\nCopy-Pasta\n==========\n\nAs with other software, it is often better (if less macho) to adapt an\nexisting litmus test than it is to create one from scratch.  A number\nof litmus tests may be found in the kernel source tree:\n\n\ttools/memory-model/litmus-tests/\n\tDocumentation/litmus-tests/\n\nSeveral thousand more example litmus tests are available on github\nand kernel.org:\n\n\thttps://github.com/paulmckrcu/litmus\n\thttps://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git/tree/CodeSamples/formal/herd\n\thttps://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git/tree/CodeSamples/formal/litmus\n\nThe -l and -L arguments to \"git grep\" can be quite helpful in identifying\nexisting litmus tests that are similar to the one you need.  But even if\nyou start with an existing litmus test, it is still helpful to have a\ngood understanding of the litmus-test format.\n\n\nExamples and Format\n===================\n\nThis section describes the overall format of litmus tests, starting\nwith a small example of the message-passing pattern and moving on to\nmore complex examples that illustrate explicit initialization and LKMM's\nminimalistic set of flow-control statements.\n\n\nMessage-Passing Example\n-----------------------\n\nThis section gives an overview of the format of a litmus test using an\nexample based on the common message-passing use case.  This use case\nappears often in the Linux kernel.  For example, a flag (modeled by \"y\"\nbelow) indicates that a buffer (modeled by \"x\" below) is now completely\nfilled in and ready for use.  It would be very bad if the consumer saw the\nflag set, but, due to memory misordering, saw old values in the buffer.\n\nThis example asks whether smp_store_release() and smp_load_acquire()\nsuffices to avoid this bad outcome:\n\n 1 C MP+pooncerelease+poacquireonce\n 2\n 3 {}\n 4\n 5 P0(int *x, int *y)\n 6 {\n 7   WRITE_ONCE(*x, 1);\n 8   smp_store_release(y, 1);\n 9 }\n10\n11 P1(int *x, int *y)\n12 {\n13   int r0;\n14   int r1;\n15\n16   r0 = smp_load_acquire(y);\n17   r1 = READ_ONCE(*x);\n18 }\n19\n20 exists (1:r0=1 /\\ 1:r1=0)\n\nLine 1 starts with \"C\", which identifies this file as being in the\nLKMM C-language format (which, as we will see, is a small fragment\nof the full C language).  The remainder of line 1 is the name of\nthe test, which by convention is the filename with the \".litmus\"\nsuffix stripped.  In this case, the actual test may be found in\ntools/memory-model/litmus-tests/MP+pooncerelease+poacquireonce.litmus\nin the Linux-kernel source tree.\n\nMechanically generated litmus tests will often have an optional\ndouble-quoted comment string on the second line.  Such strings are ignored\nwhen running the test.  Yes, you can add your own comments to litmus\ntests, but this is a bit involved due to the use of multiple parsers.\nFor now, you can use C-language comments in the C code, and these comments\nmay be in either the \"/* */\" or the \"//\" style.  A later section will\ncover the full litmus-test commenting story.\n\nLine 3 is the initialization section.  Because the default initialization\nto zero suffices for this test, the \"{}\" syntax is used, which mean the\ninitialization section is empty.  Litmus tests requiring non-default\ninitialization must have non-empty initialization sections, as in the\nexample that will be presented later in this document.\n\nLines 5-9 show the first process and lines 11-18 the second process.  Each\nprocess corresponds to a Linux-kernel task (or kthread, workqueue, thread,\nand so on; LKMM discussions often use these terms interchangeably).\nThe name of the first process is \"P0\" and that of the second \"P1\".\nYou can name your processes anything you like as long as the names consist\nof a single \"P\" followed by a number, and as long as the numbers are\nconsecutive starting with zero.  This can actually be quite helpful,\nfor example, a .litmus file matching \"^P1(\" but not matching \"^P2(\"\nmust contain a two-process litmus test.\n\nThe argument list for each function are pointers to the global variables\nused by that function.  Unlike normal C-language function parameters, the\nnames are significant.  The fact that both P0() and P1() have a formal\nparameter named \"x\" means that these two processes are working with the\nsame global variable, also named \"x\".  So the \"int *x, int *y\" on P0()\nand P1() mean that both processes are working with two shared global\nvariables, \"x\" and \"y\".  Global variables are always passed to processes\nby reference, hence \"P0(int *x, int *y)\", but *never* \"P0(int x, int y)\".\n\nP0() has no local variables, but P1() has two of them named \"r0\" and \"r1\".\nThese names may be freely chosen, but for historical reasons stemming from\nother litmus-test formats, it is conventional to use names consisting of\n\"r\" followed by a number as shown here.  A common bug in litmus tests\nis forgetting to add a global variable to a process's parameter list.\nThis will sometimes result in an error message, but can also cause the\nintended global to instead be silently treated as an undeclared local\nvariable.\n\nEach process's code is similar to Linux-kernel C, as can be seen on lines\n7-8 and 13-17.  This code may use many of the Linux kernel's atomic\noperations, some of its exclusive-lock functions, and some of its RCU\nand SRCU functions.  An approximate list of the currently supported\nfunctions may be found in the linux-kernel.def file.\n\nThe P0() process does \"WRITE_ONCE(*x, 1)\" on line 7.  Because \"x\" is a\npointer in P0()'s parameter list, this does an unordered store to global\nvariable \"x\".  Line 8 does \"smp_store_release(y, 1)\", and because \"y\"\nis also in P0()'s parameter list, this does a release store to global\nvariable \"y\".\n\nThe P1() process declares two local variables on lines 13 and 14.\nLine 16 does \"r0 = smp_load_acquire(y)\" which does an acquire load\nfrom global variable \"y\" into local variable \"r0\".  Line 17 does a\n\"r1 = READ_ONCE(*x)\", which does an unordered load from \"*x\" into local\nvariable \"r1\".  Both \"x\" and \"y\" are in P1()'s parameter list, so both\nreference the same global variables that are used by P0().\n\nLine 20 is the \"exists\" assertion expression to evaluate the final state.\nThis final state is evaluated after the dust has settled: both processes\nhave completed and all of their memory references and memory barriers\nhave propagated to all parts of the system.  The references to the local\nvariables \"r0\" and \"r1\" in line 24 must be prefixed with \"1:\" to specify\nwhich process they are local to.\n\nNote that the assertion expression is written in the litmus-test\nlanguage rather than in C.  For example, single \"=\" is an equality\noperator rather than an assignment.  The \"/\\\" character combination means\n\"and\".  Similarly, \"\\/\" stands for \"or\".  Both of these are ASCII-art\nrepresentations of the corresponding mathematical symbols.  Finally,\n\"~\" stands for \"logical not\", which is \"!\" in C, and not to be confused\nwith the C-language \"~\" operator which instead stands for \"bitwise not\".\nParentheses may be used to override precedence.\n\nThe \"exists\" assertion on line 20 is satisfied if the consumer sees the\nflag (\"y\") set but the buffer (\"x\") as not yet filled in, that is, if P1()\nloaded a value from \"x\" that was equal to 1 but loaded a value from \"y\"\nthat was still equal to zero.\n\nThis example can be checked by running the following command, which\nabsolutely must be run from the tools/memory-model directory and from\nthis directory only:\n\nherd7 -conf linux-kernel.cfg litmus-tests/MP+pooncerelease+poacquireonce.litmus\n\nThe output is the result of something similar to a full state-space\nsearch, and is as follows:\n\n 1 Test MP+pooncerelease+poacquireonce Allowed\n 2 States 3\n 3 1:r0=0; 1:r1=0;\n 4 1:r0=0; 1:r1=1;\n 5 1:r0=1; 1:r1=1;\n 6 No\n 7 Witnesses\n 8 Positive: 0 Negative: 3\n 9 Condition exists (1:r0=1 /\\ 1:r1=0)\n10 Observation MP+pooncerelease+poacquireonce Never 0 3\n11 Time MP+pooncerelease+poacquireonce 0.00\n12 Hash=579aaa14d8c35a39429b02e698241d09\n\nThe most pertinent line is line 10, which contains \"Never 0 3\", which\nindicates that the bad result flagged by the \"exists\" clause never\nhappens.  This line might instead say \"Sometimes\" to indicate that the\nbad result happened in some but not all executions, or it might say\n\"Always\" to indicate that the bad result happened in all executions.\n(The herd7 tool doesn't judge, so it is only an LKMM convention that the\n\"exists\" clause indicates a bad result.  To see this, invert the \"exists\"\nclause's condition and run the test.)  The numbers (\"0 3\") at the end\nof this line indicate the number of end states satisfying the \"exists\"\nclause (0) and the number not not satisfying that clause (3).\n\nAnother important part of this output is shown in lines 2-5, repeated here:\n\n 2 States 3\n 3 1:r0=0; 1:r1=0;\n 4 1:r0=0; 1:r1=1;\n 5 1:r0=1; 1:r1=1;\n\nLine 2 gives the total number of end states, and each of lines 3-5 list\none of these states, with the first (\"1:r0=0; 1:r1=0;\") indicating that\nboth of P1()'s loads returned the value \"0\".  As expected, given the\n\"Never\" on line 10, the state flagged by the \"exists\" clause is not\nlisted.  This full list of states can be helpful when debugging a new\nlitmus test.\n\nThe rest of the output is not normally needed, either due to irrelevance\nor due to being redundant with the lines discussed above.  However, the\nfollowing paragraph lists them for the benefit of readers possessed of\nan insatiable curiosity.  Other readers should feel free to skip ahead.\n\nLine 1 echos the test name, along with the \"Test\" and \"Allowed\".  Line 6's\n\"No\" says that the \"exists\" clause was not satisfied by any execution,\nand as such it has the same meaning as line 10's \"Never\".  Line 7 is a\nlead-in to line 8's \"Positive: 0 Negative: 3\", which lists the number\nof end states satisfying and not satisfying the \"exists\" clause, just\nlike the two numbers at the end of line 10.  Line 9 repeats the \"exists\"\nclause so that you don't have to look it up in the litmus-test file.\nThe number at the end of line 11 (which begins with \"Time\") gives the\ntime in seconds required to analyze the litmus test.  Small tests such\nas this one complete in a few milliseconds, so \"0.00\" is quite common.\nLine 12 gives a hash of the contents for the litmus-test file, and is used\nby tooling that manages litmus tests and their output.  This tooling is\nused by people modifying LKMM itself, and among other things lets such\npeople know which of the several thousand relevant litmus tests were\naffected by a given change to LKMM.\n\n\nInitialization\n--------------\n\nThe previous example relied on the default zero initialization for\n\"x\" and \"y\", but a similar litmus test could instead initialize them\nto some other value:\n\n 1 C MP+pooncerelease+poacquireonce\n 2\n 3 {\n 4   x=42;\n 5   y=42;\n 6 }\n 7\n 8 P0(int *x, int *y)\n 9 {\n10   WRITE_ONCE(*x, 1);\n11   smp_store_release(y, 1);\n12 }\n13\n14 P1(int *x, int *y)\n15 {\n16   int r0;\n17   int r1;\n18\n19   r0 = smp_load_acquire(y);\n20   r1 = READ_ONCE(*x);\n21 }\n22\n23 exists (1:r0=1 /\\ 1:r1=42)\n\nLines 3-6 now initialize both \"x\" and \"y\" to the value 42.  This also\nmeans that the \"exists\" clause on line 23 must change \"1:r1=0\" to\n\"1:r1=42\".\n\nRunning the test gives the same overall result as before, but with the\nvalue 42 appearing in place of the value zero:\n\n 1 Test MP+pooncerelease+poacquireonce Allowed\n 2 States 3\n 3 1:r0=1; 1:r1=1;\n 4 1:r0=42; 1:r1=1;\n 5 1:r0=42; 1:r1=42;\n 6 No\n 7 Witnesses\n 8 Positive: 0 Negative: 3\n 9 Condition exists (1:r0=1 /\\ 1:r1=42)\n10 Observation MP+pooncerelease+poacquireonce Never 0 3\n11 Time MP+pooncerelease+poacquireonce 0.02\n12 Hash=ab9a9b7940a75a792266be279a980156\n\nIt is tempting to avoid the open-coded repetitions of the value \"42\"\nby defining another global variable \"initval=42\" and replacing all\noccurrences of \"42\" with \"initval\".  This will not, repeat *not*,\ninitialize \"x\" and \"y\" to 42, but instead to the address of \"initval\"\n(try it!).  See the section below on linked lists to learn more about\nwhy this approach to initialization can be useful.\n\n\nControl Structures\n------------------\n\nLKMM supports the C-language \"if\" statement, which allows modeling of\nconditional branches.  In LKMM, conditional branches can affect ordering,\nbut only if you are *very* careful (compilers are surprisingly able\nto optimize away conditional branches).  The following example shows\nthe \"load buffering\" (LB) use case that is used in the Linux kernel to\nsynchronize between ring-buffer producers and consumers.  In the example\nbelow, P0() is one side checking to see if an operation may proceed and\nP1() is the other side completing its update.\n\n 1 C LB+fencembonceonce+ctrlonceonce\n 2\n 3 {}\n 4\n 5 P0(int *x, int *y)\n 6 {\n 7   int r0;\n 8\n 9   r0 = READ_ONCE(*x);\n10   if (r0)\n11     WRITE_ONCE(*y, 1);\n12 }\n13\n14 P1(int *x, int *y)\n15 {\n16   int r0;\n17\n18   r0 = READ_ONCE(*y);\n19   smp_mb();\n20   WRITE_ONCE(*x, 1);\n21 }\n22\n23 exists (0:r0=1 /\\ 1:r0=1)\n\nP1()'s \"if\" statement on line 10 works as expected, so that line 11 is\nexecuted only if line 9 loads a non-zero value from \"x\".  Because P1()'s\nwrite of \"1\" to \"x\" happens only after P1()'s read from \"y\", one would\nhope that the \"exists\" clause cannot be satisfied.  LKMM agrees:\n\n 1 Test LB+fencembonceonce+ctrlonceonce Allowed\n 2 States 2\n 3 0:r0=0; 1:r0=0;\n 4 0:r0=1; 1:r0=0;\n 5 No\n 6 Witnesses\n 7 Positive: 0 Negative: 2\n 8 Condition exists (0:r0=1 /\\ 1:r0=1)\n 9 Observation LB+fencembonceonce+ctrlonceonce Never 0 2\n10 Time LB+fencembonceonce+ctrlonceonce 0.00\n11 Hash=e5260556f6de495fd39b556d1b831c3b\n\nHowever, there is no \"while\" statement due to the fact that full\nstate-space search has some difficulty with iteration.  However, there\nare tricks that may be used to handle some special cases, which are\ndiscussed below.  In addition, loop-unrolling tricks may be applied,\nalbeit sparingly.\n\n\nTricks and Traps\n================\n\nThis section covers extracting debug output from herd7, emulating\nspin loops, handling trivial linked lists, adding comments to litmus tests,\nemulating call_rcu(), and finally tricks to improve herd7 performance\nin order to better handle large litmus tests.\n\n\nDebug Output\n------------\n\nBy default, the herd7 state output includes all variables mentioned\nin the \"exists\" clause.  But sometimes debugging efforts are greatly\naided by the values of other variables.  Consider this litmus test\n(tools/memory-order/litmus-tests/SB+rfionceonce-poonceonces.litmus but\nslightly modified), which probes an obscure corner of hardware memory\nordering:\n\n 1 C SB+rfionceonce-poonceonces\n 2\n 3 {}\n 4\n 5 P0(int *x, int *y)\n 6 {\n 7   int r1;\n 8   int r2;\n 9\n10   WRITE_ONCE(*x, 1);\n11   r1 = READ_ONCE(*x);\n12   r2 = READ_ONCE(*y);\n13 }\n14\n15 P1(int *x, int *y)\n16 {\n17   int r3;\n18   int r4;\n19\n20   WRITE_ONCE(*y, 1);\n21   r3 = READ_ONCE(*y);\n22   r4 = READ_ONCE(*x);\n23 }\n24\n25 exists (0:r2=0 /\\ 1:r4=0)\n\nThe herd7 output is as follows:\n\n 1 Test SB+rfionceonce-poonceonces Allowed\n 2 States 4\n 3 0:r2=0; 1:r4=0;\n 4 0:r2=0; 1:r4=1;\n 5 0:r2=1; 1:r4=0;\n 6 0:r2=1; 1:r4=1;\n 7 Ok\n 8 Witnesses\n 9 Positive: 1 Negative: 3\n10 Condition exists (0:r2=0 /\\ 1:r4=0)\n11 Observation SB+rfionceonce-poonceonces Sometimes 1 3\n12 Time SB+rfionceonce-poonceonces 0.01\n13 Hash=c7f30fe0faebb7d565405d55b7318ada\n\n(This output indicates that CPUs are permitted to \"snoop their own\nstore buffers\", which all of Linux's CPU families other than s390 will\nhappily do.  Such snooping results in disagreement among CPUs on the\norder of stores from different CPUs, which is rarely an issue.)\n\nBut the herd7 output shows only the two variables mentioned in the\n\"exists\" clause.  Someone modifying this test might wish to know the\nvalues of \"x\", \"y\", \"0:r1\", and \"0:r3\" as well.  The \"locations\"\nstatement on line 25 shows how to cause herd7 to display additional\nvariables:\n\n 1 C SB+rfionceonce-poonceonces\n 2\n 3 {}\n 4\n 5 P0(int *x, int *y)\n 6 {\n 7   int r1;\n 8   int r2;\n 9\n10   WRITE_ONCE(*x, 1);\n11   r1 = READ_ONCE(*x);\n12   r2 = READ_ONCE(*y);\n13 }\n14\n15 P1(int *x, int *y)\n16 {\n17   int r3;\n18   int r4;\n19\n20   WRITE_ONCE(*y, 1);\n21   r3 = READ_ONCE(*y);\n22   r4 = READ_ONCE(*x);\n23 }\n24\n25 locations [0:r1; 1:r3; x; y]\n26 exists (0:r2=0 /\\ 1:r4=0)\n\nThe herd7 output then displays the values of all the variables:\n\n 1 Test SB+rfionceonce-poonceonces Allowed\n 2 States 4\n 3 0:r1=1; 0:r2=0; 1:r3=1; 1:r4=0; x=1; y=1;\n 4 0:r1=1; 0:r2=0; 1:r3=1; 1:r4=1; x=1; y=1;\n 5 0:r1=1; 0:r2=1; 1:r3=1; 1:r4=0; x=1; y=1;\n 6 0:r1=1; 0:r2=1; 1:r3=1; 1:r4=1; x=1; y=1;\n 7 Ok\n 8 Witnesses\n 9 Positive: 1 Negative: 3\n10 Condition exists (0:r2=0 /\\ 1:r4=0)\n11 Observation SB+rfionceonce-poonceonces Sometimes 1 3\n12 Time SB+rfionceonce-poonceonces 0.01\n13 Hash=40de8418c4b395388f6501cafd1ed38d\n\nWhat if you would like to know the value of a particular global variable\nat some particular point in a given process's execution?  One approach\nis to use a READ_ONCE() to load that global variable into a new local\nvariable, then add that local variable to the \"locations\" clause.\nBut be careful:  In some litmus tests, adding a READ_ONCE() will change\nthe outcome!  For one example, please see the C-READ_ONCE.litmus and\nC-READ_ONCE-omitted.litmus tests located here:\n\n\thttps://github.com/paulmckrcu/litmus/blob/master/manual/kernel/\n\n\nSpin Loops\n----------\n\nThe analysis carried out by herd7 explores full state space, which is\nat best of exponential time complexity.  Adding processes and increasing\nthe amount of code in a give process can greatly increase execution time.\nPotentially infinite loops, such as those used to wait for locks to\nbecome available, are clearly problematic.\n\nFortunately, it is possible to avoid state-space explosion by specially\nmodeling such loops.  For example, the following litmus tests emulates\nlocking using xchg_acquire(), but instead of enclosing xchg_acquire()\nin a spin loop, it instead excludes executions that fail to acquire the\nlock using a herd7 \"filter\" clause.  Note that for exclusive locking, you\nare better off using the spin_lock() and spin_unlock() that LKMM directly\nmodels, if for no other reason that these are much faster.  However, the\ntechniques illustrated in this section can be used for other purposes,\nsuch as emulating reader-writer locking, which LKMM does not yet model.\n\n 1 C C-SB+l-o-o-u+l-o-o-u-X\n 2\n 3 {\n 4 }\n 5\n 6 P0(int *sl, int *x0, int *x1)\n 7 {\n 8   int r2;\n 9   int r1;\n10\n11   r2 = xchg_acquire(sl, 1);\n12   WRITE_ONCE(*x0, 1);\n13   r1 = READ_ONCE(*x1);\n14   smp_store_release(sl, 0);\n15 }\n16\n17 P1(int *sl, int *x0, int *x1)\n18 {\n19   int r2;\n20   int r1;\n21\n22   r2 = xchg_acquire(sl, 1);\n23   WRITE_ONCE(*x1, 1);\n24   r1 = READ_ONCE(*x0);\n25   smp_store_release(sl, 0);\n26 }\n27\n28 filter (0:r2=0 /\\ 1:r2=0)\n29 exists (0:r1=0 /\\ 1:r1=0)\n\nThis litmus test may be found here:\n\nhttps://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git/tree/CodeSamples/formal/herd/C-SB+l-o-o-u+l-o-o-u-X.litmus\n\nThis test uses two global variables, \"x1\" and \"x2\", and also emulates a\nsingle global spinlock named \"sl\".  This spinlock is held by whichever\nprocess changes the value of \"sl\" from \"0\" to \"1\", and is released when\nthat process sets \"sl\" back to \"0\".  P0()'s lock acquisition is emulated\non line 11 using xchg_acquire(), which unconditionally stores the value\n\"1\" to \"sl\" and stores either \"0\" or \"1\" to \"r2\", depending on whether\nthe lock acquisition was successful or unsuccessful (due to \"sl\" already\nhaving the value \"1\"), respectively.  P1() operates in a similar manner.\n\nRather unconventionally, execution appears to proceed to the critical\nsection on lines 12 and 13 in either case.  Line 14 then uses an\nsmp_store_release() to store zero to \"sl\", thus emulating lock release.\n\nThe case where xchg_acquire() fails to acquire the lock is handled by\nthe \"filter\" clause on line 28, which tells herd7 to keep only those\nexecutions in which both \"0:r2\" and \"1:r2\" are zero, that is to pay\nattention only to those executions in which both locks are actually\nacquired.  Thus, the bogus executions that would execute the critical\nsections are discarded and any effects that they might have had are\nignored.  Note well that the \"filter\" clause keeps those executions\nfor which its expression is satisfied, that is, for which the expression\nevaluates to true.  In other words, the \"filter\" clause says what to\nkeep, not what to discard.\n\nThe result of running this test is as follows:\n\n 1 Test C-SB+l-o-o-u+l-o-o-u-X Allowed\n 2 States 2\n 3 0:r1=0; 1:r1=1;\n 4 0:r1=1; 1:r1=0;\n 5 No\n 6 Witnesses\n 7 Positive: 0 Negative: 2\n 8 Condition exists (0:r1=0 /\\ 1:r1=0)\n 9 Observation C-SB+l-o-o-u+l-o-o-u-X Never 0 2\n10 Time C-SB+l-o-o-u+l-o-o-u-X 0.03\n\nThe \"Never\" on line 9 indicates that this use of xchg_acquire() and\nsmp_store_release() really does correctly emulate locking.\n\nWhy doesn't the litmus test take the simpler approach of using a spin loop\nto handle failed spinlock acquisitions, like the kernel does?  The key\ninsight behind this litmus test is that spin loops have no effect on the\npossible \"exists\"-clause outcomes of program execution in the absence\nof deadlock.  In other words, given a high-quality lock-acquisition\nprimitive in a deadlock-free program running on high-quality hardware,\neach lock acquisition will eventually succeed.  Because herd7 already\nexplores the full state space, the length of time required to actually\nacquire the lock does not matter.  After all, herd7 already models all\npossible durations of the xchg_acquire() statements.\n\nWhy not just add the \"filter\" clause to the \"exists\" clause, thus\navoiding the \"filter\" clause entirely?  This does work, but is slower.\nThe reason that the \"filter\" clause is faster is that (in the common case)\nherd7 knows to abandon an execution as soon as the \"filter\" expression\nfails to be satisfied.  In contrast, the \"exists\" clause is evaluated\nonly at the end of time, thus requiring herd7 to waste time on bogus\nexecutions in which both critical sections proceed concurrently.  In\naddition, some LKMM users like the separation of concerns provided by\nusing the both the \"filter\" and \"exists\" clauses.\n\nReaders lacking a pathological interest in odd corner cases should feel\nfree to skip the remainder of this section.\n\nBut what if the litmus test were to temporarily set \"0:r2\" to a non-zero\nvalue?  Wouldn't that cause herd7 to abandon the execution prematurely\ndue to an early mismatch of the \"filter\" clause?\n\nWhy not just try it?  Line 4 of the following modified litmus test\nintroduces a new global variable \"x2\" that is initialized to \"1\".  Line 23\nof P1() reads that variable into \"1:r2\" to force an early mismatch with\nthe \"filter\" clause.  Line 24 does a known-true \"if\" condition to avoid\nand static analysis that herd7 might do.  Finally the \"exists\" clause\non line 32 is updated to a condition that is alway satisfied at the end\nof the test.\n\n 1 C C-SB+l-o-o-u+l-o-o-u-X\n 2\n 3 {\n 4   x2=1;\n 5 }\n 6\n 7 P0(int *sl, int *x0, int *x1)\n 8 {\n 9   int r2;\n10   int r1;\n11\n12   r2 = xchg_acquire(sl, 1);\n13   WRITE_ONCE(*x0, 1);\n14   r1 = READ_ONCE(*x1);\n15   smp_store_release(sl, 0);\n16 }\n17\n18 P1(int *sl, int *x0, int *x1, int *x2)\n19 {\n20   int r2;\n21   int r1;\n22\n23   r2 = READ_ONCE(*x2);\n24   if (r2)\n25     r2 = xchg_acquire(sl, 1);\n26   WRITE_ONCE(*x1, 1);\n27   r1 = READ_ONCE(*x0);\n28   smp_store_release(sl, 0);\n29 }\n30\n31 filter (0:r2=0 /\\ 1:r2=0)\n32 exists (x1=1)\n\nIf the \"filter\" clause were to check each variable at each point in the\nexecution, running this litmus test would display no executions because\nall executions would be filtered out at line 23.  However, the output\nis instead as follows:\n\n 1 Test C-SB+l-o-o-u+l-o-o-u-X Allowed\n 2 States 1\n 3 x1=1;\n 4 Ok\n 5 Witnesses\n 6 Positive: 2 Negative: 0\n 7 Condition exists (x1=1)\n 8 Observation C-SB+l-o-o-u+l-o-o-u-X Always 2 0\n 9 Time C-SB+l-o-o-u+l-o-o-u-X 0.04\n10 Hash=080bc508da7f291e122c6de76c0088e3\n\nLine 3 shows that there is one execution that did not get filtered out,\nso the \"filter\" clause is evaluated only on the last assignment to\nthe variables that it checks.  In this case, the \"filter\" clause is a\ndisjunction, so it might be evaluated twice, once at the final (and only)\nassignment to \"0:r2\" and once at the final assignment to \"1:r2\".\n\n\nLinked Lists\n------------\n\nLKMM can handle linked lists, but only linked lists in which each node\ncontains nothing except a pointer to the next node in the list.  This is\nof course quite restrictive, but there is nevertheless quite a bit that\ncan be done within these confines, as can be seen in the litmus test\nat tools/memory-model/litmus-tests/MP+onceassign+derefonce.litmus:\n\n 1 C MP+onceassign+derefonce\n 2\n 3 {\n 4 y=z;\n 5 z=0;\n 6 }\n 7\n 8 P0(int *x, int **y)\n 9 {\n10   WRITE_ONCE(*x, 1);\n11   rcu_assign_pointer(*y, x);\n12 }\n13\n14 P1(int *x, int **y)\n15 {\n16   int *r0;\n17   int r1;\n18\n19   rcu_read_lock();\n20   r0 = rcu_dereference(*y);\n21   r1 = READ_ONCE(*r0);\n22   rcu_read_unlock();\n23 }\n24\n25 exists (1:r0=x /\\ 1:r1=0)\n\nLine 4's \"y=z\" may seem odd, given that \"z\" has not yet been initialized.\nBut \"y=z\" does not set the value of \"y\" to that of \"z\", but instead\nsets the value of \"y\" to the *address* of \"z\".  Lines 4 and 5 therefore\ncreate a simple linked list, with \"y\" pointing to \"z\" and \"z\" having a\nNULL pointer.  A much longer linked list could be created if desired,\nand circular singly linked lists can also be created and manipulated.\n\nThe \"exists\" clause works the same way, with the \"1:r0=x\" comparing P1()'s\n\"r0\" not to the value of \"x\", but again to its address.  This term of the\n\"exists\" clause therefore tests whether line 20's load from \"y\" saw the\nvalue stored by line 11, which is in fact what is required in this case.\n\nP0()'s line 10 initializes \"x\" to the value 1 then line 11 links to \"x\"\nfrom \"y\", replacing \"z\".\n\nP1()'s line 20 loads a pointer from \"y\", and line 21 dereferences that\npointer.  The RCU read-side critical section spanning lines 19-22 is just\nfor show in this example.  Note that the address used for line 21's load\ndepends on (in this case, \"is exactly the same as\") the value loaded by\nline 20.  This is an example of what is called an \"address dependency\".\nThis particular address dependency extends from the load on line 20 to the\nload on line 21.  Address dependencies provide a weak form of ordering.\n\nRunning this test results in the following:\n\n 1 Test MP+onceassign+derefonce Allowed\n 2 States 2\n 3 1:r0=x; 1:r1=1;\n 4 1:r0=z; 1:r1=0;\n 5 No\n 6 Witnesses\n 7 Positive: 0 Negative: 2\n 8 Condition exists (1:r0=x /\\ 1:r1=0)\n 9 Observation MP+onceassign+derefonce Never 0 2\n10 Time MP+onceassign+derefonce 0.00\n11 Hash=49ef7a741563570102448a256a0c8568\n\nThe only possible outcomes feature P1() loading a pointer to \"z\"\n(which contains zero) on the one hand and P1() loading a pointer to \"x\"\n(which contains the value one) on the other.  This should be reassuring\nbecause it says that RCU readers cannot see the old preinitialization\nvalues when accessing a newly inserted list node.  This undesirable\nscenario is flagged by the \"exists\" clause, and would occur if P1()\nloaded a pointer to \"x\", but obtained the pre-initialization value of\nzero after dereferencing that pointer.\n\n\nComments\n--------\n\nDifferent portions of a litmus test are processed by different parsers,\nwhich has the charming effect of requiring different comment syntax in\ndifferent portions of the litmus test.  The C-syntax portions use\nC-language comments (either \"/* */\" or \"//\"), while the other portions\nuse Ocaml comments \"(* *)\".\n\nThe following litmus test illustrates the comment style corresponding\nto each syntactic unit of the test:\n\n 1 C MP+onceassign+derefonce (* A *)\n 2\n 3 (* B *)\n 4\n 5 {\n 6 y=z; (* C *)\n 7 z=0;\n 8 } // D\n 9\n10 // E\n11\n12 P0(int *x, int **y) // F\n13 {\n14   WRITE_ONCE(*x, 1);  // G\n15   rcu_assign_pointer(*y, x);\n16 }\n17\n18 // H\n19\n20 P1(int *x, int **y)\n21 {\n22   int *r0;\n23   int r1;\n24\n25   rcu_read_lock();\n26   r0 = rcu_dereference(*y);\n27   r1 = READ_ONCE(*r0);\n28   rcu_read_unlock();\n29 }\n30\n31 // I\n32\n33 exists (* J *) (1:r0=x /\\ (* K *) 1:r1=0) (* L *)\n\nIn short, use C-language comments in the C code and Ocaml comments in\nthe rest of the litmus test.\n\nOn the other hand, if you prefer C-style comments everywhere, the\nC preprocessor is your friend.\n\n\nAsynchronous RCU Grace Periods\n------------------------------\n\nThe following litmus test is derived from the example show in\nDocumentation/litmus-tests/rcu/RCU+sync+free.litmus, but converted to\nemulate call_rcu():\n\n 1 C RCU+sync+free\n 2\n 3 {\n 4 int x = 1;\n 5 int *y = &x;\n 6 int z = 1;\n 7 }\n 8\n 9 P0(int *x, int *z, int **y)\n10 {\n11   int *r0;\n12   int r1;\n13\n14   rcu_read_lock();\n15   r0 = rcu_dereference(*y);\n16   r1 = READ_ONCE(*r0);\n17   rcu_read_unlock();\n18 }\n19\n20 P1(int *z, int **y, int *c)\n21 {\n22   rcu_assign_pointer(*y, z);\n23   smp_store_release(*c, 1); // Emulate call_rcu().\n24 }\n25\n26 P2(int *x, int *z, int **y, int *c)\n27 {\n28   int r0;\n29\n30   r0 = smp_load_acquire(*c); // Note call_rcu() request.\n31   synchronize_rcu(); // Wait one grace period.\n32   WRITE_ONCE(*x, 0); // Emulate the RCU callback.\n33 }\n34\n35 filter (2:r0=1) (* Reject too-early starts. *)\n36 exists (0:r0=x /\\ 0:r1=0)\n\nLines 4-6 initialize a linked list headed by \"y\" that initially contains\n\"x\".  In addition, \"z\" is pre-initialized to prepare for P1(), which\nwill replace \"x\" with \"z\" in this list.\n\nP0() on lines 9-18 enters an RCU read-side critical section, loads the\nlist header \"y\" and dereferences it, leaving the node in \"0:r0\" and\nthe node's value in \"0:r1\".\n\nP1() on lines 20-24 updates the list header to instead reference \"z\",\nthen emulates call_rcu() by doing a release store into \"c\".\n\nP2() on lines 27-33 emulates the behind-the-scenes effect of doing a\ncall_rcu().  Line 30 first does an acquire load from \"c\", then line 31\nwaits for an RCU grace period to elapse, and finally line 32 emulates\nthe RCU callback, which in turn emulates a call to kfree().\n\nOf course, it is possible for P2() to start too soon, so that the\nvalue of \"2:r0\" is zero rather than the required value of \"1\".\nThe \"filter\" clause on line 35 handles this possibility, rejecting\nall executions in which \"2:r0\" is not equal to the value \"1\".\n\n\nPerformance\n-----------\n\nLKMM's exploration of the full state-space can be extremely helpful,\nbut it does not come for free.  The price is exponential computational\ncomplexity in terms of the number of processes, the average number\nof statements in each process, and the total number of stores in the\nlitmus test.\n\nSo it is best to start small and then work up.  Where possible, break\nyour code down into small pieces each representing a core concurrency\nrequirement.\n\nThat said, herd7 is quite fast.  On an unprepossessing x86 laptop, it\nwas able to analyze the following 10-process RCU litmus test in about\nsix seconds.\n\nhttps://github.com/paulmckrcu/litmus/blob/master/auto/C-RW-R+RW-R+RW-G+RW-G+RW-G+RW-G+RW-R+RW-R+RW-R+RW-R.litmus\n\nOne way to make herd7 run faster is to use the \"-speedcheck true\" option.\nThis option prevents herd7 from generating all possible end states,\ninstead causing it to focus solely on whether or not the \"exists\"\nclause can be satisfied.  With this option, herd7 evaluates the above\nlitmus test in about 300 milliseconds, for more than an order of magnitude\nimprovement in performance.\n\nLarger 16-process litmus tests that would normally consume 15 minutes\nof time complete in about 40 seconds with this option.  To be fair,\nyou do get an extra 65,535 states when you leave off the \"-speedcheck\ntrue\" option.\n\nhttps://github.com/paulmckrcu/litmus/blob/master/auto/C-RW-R+RW-R+RW-G+RW-G+RW-G+RW-G+RW-R+RW-R+RW-R+RW-R+RW-G+RW-G+RW-G+RW-G+RW-R+RW-R.litmus\n\nNevertheless, litmus-test analysis really is of exponential complexity,\nwhether with or without \"-speedcheck true\".  Increasing by just three\nprocesses to a 19-process litmus test requires 2 hours and 40 minutes\nwithout, and about 8 minutes with \"-speedcheck true\".  Each of these\nresults represent roughly an order of magnitude slowdown compared to the\n16-process litmus test.  Again, to be fair, the multi-hour run explores\nno fewer than 524,287 additional states compared to the shorter one.\n\nhttps://github.com/paulmckrcu/litmus/blob/master/auto/C-RW-R+RW-R+RW-G+RW-G+RW-G+RW-G+RW-R+RW-R+RW-R+RW-R+RW-R+RW-R+RW-G+RW-G+RW-G+RW-G+RW-R+RW-R+RW-R.litmus\n\nIf you don't like command-line arguments, you can obtain a similar speedup\nby adding a \"filter\" clause with exactly the same expression as your\n\"exists\" clause.\n\nHowever, please note that seeing the full set of states can be extremely\nhelpful when developing and debugging litmus tests.\n\n\nLIMITATIONS\n===========\n\nLimitations of the Linux-kernel memory model (LKMM) include:\n\n1.\tCompiler optimizations are not accurately modeled.  Of course,\n\tthe use of READ_ONCE() and WRITE_ONCE() limits the compiler's\n\tability to optimize, but under some circumstances it is possible\n\tfor the compiler to undermine the memory model.  For more\n\tinformation, see Documentation/explanation.txt (in particular,\n\tthe \"THE PROGRAM ORDER RELATION: po AND po-loc\" and \"A WARNING\"\n\tsections).\n\n\tNote that this limitation in turn limits LKMM's ability to\n\taccurately model address, control, and data dependencies.\n\tFor example, if the compiler can deduce the value of some variable\n\tcarrying a dependency, then the compiler can break that dependency\n\tby substituting a constant of that value.\n\n\tConversely, LKMM will sometimes overestimate the amount of\n\treordering compilers and CPUs can carry out, leading it to miss\n\tsome pretty obvious cases of ordering.  A simple example is:\n\n\t\tr1 = READ_ONCE(x);\n\t\tif (r1 == 0)\n\t\t\tsmp_mb();\n\t\tWRITE_ONCE(y, 1);\n\n\tThe WRITE_ONCE() does not depend on the READ_ONCE(), and as a\n\tresult, LKMM does not claim ordering.  However, even though no\n\tdependency is present, the WRITE_ONCE() will not be executed before\n\tthe READ_ONCE().  There are two reasons for this:\n\n                The presence of the smp_mb() in one of the branches\n                prevents the compiler from moving the WRITE_ONCE()\n                up before the \"if\" statement, since the compiler has\n                to assume that r1 will sometimes be 0 (but see the\n                comment below);\n\n                CPUs do not execute stores before po-earlier conditional\n                branches, even in cases where the store occurs after the\n                two arms of the branch have recombined.\n\n\tIt is clear that it is not dangerous in the slightest for LKMM to\n\tmake weaker guarantees than architectures.  In fact, it is\n\tdesirable, as it gives compilers room for making optimizations.\n\tFor instance, suppose that a 0 value in r1 would trigger undefined\n\tbehavior elsewhere.  Then a clever compiler might deduce that r1\n\tcan never be 0 in the if condition.  As a result, said clever\n\tcompiler might deem it safe to optimize away the smp_mb(),\n\teliminating the branch and any ordering an architecture would\n\tguarantee otherwise.\n\n2.\tMultiple access sizes for a single variable are not supported,\n\tand neither are misaligned or partially overlapping accesses.\n\n3.\tExceptions and interrupts are not modeled.  In some cases,\n\tthis limitation can be overcome by modeling the interrupt or\n\texception with an additional process.\n\n4.\tI/O such as MMIO or DMA is not supported.\n\n5.\tSelf-modifying code (such as that found in the kernel's\n\talternatives mechanism, function tracer, Berkeley Packet Filter\n\tJIT compiler, and module loader) is not supported.\n\n6.\tComplete modeling of all variants of atomic read-modify-write\n\toperations, locking primitives, and RCU is not provided.\n\tFor example, call_rcu() and rcu_barrier() are not supported.\n\tHowever, a substantial amount of support is provided for these\n\toperations, as shown in the linux-kernel.def file.\n\n\tHere are specific limitations:\n\n\ta.\tWhen rcu_assign_pointer() is passed NULL, the Linux\n\t\tkernel provides no ordering, but LKMM models this\n\t\tcase as a store release.\n\n\tb.\tThe \"unless\" RMW operations are not currently modeled:\n\t\tatomic_long_add_unless(), atomic_inc_unless_negative(),\n\t\tand atomic_dec_unless_positive().  These can be emulated\n\t\tin litmus tests, for example, by using atomic_cmpxchg().\n\n\t\tOne exception of this limitation is atomic_add_unless(),\n\t\twhich is provided directly by herd7 (so no corresponding\n\t\tdefinition in linux-kernel.def).  atomic_add_unless() is\n\t\tmodeled by herd7 therefore it can be used in litmus tests.\n\n\tc.\tThe call_rcu() function is not modeled.  As was shown above,\n\t\tit can be emulated in litmus tests by adding another\n\t\tprocess that invokes synchronize_rcu() and the body of the\n\t\tcallback function, with (for example) a release-acquire\n\t\tfrom the site of the emulated call_rcu() to the beginning\n\t\tof the additional process.\n\n\td.\tThe rcu_barrier() function is not modeled.  It can be\n\t\temulated in litmus tests emulating call_rcu() via\n\t\t(for example) a release-acquire from the end of each\n\t\tadditional call_rcu() process to the site of the\n\t\temulated rcu-barrier().\n\n\te.\tReader-writer locking is not modeled.  It can be\n\t\temulated in litmus tests using atomic read-modify-write\n\t\toperations.\n\nThe fragment of the C language supported by these litmus tests is quite\nlimited and in some ways non-standard:\n\n1.\tThere is no automatic C-preprocessor pass.  You can of course\n\trun it manually, if you choose.\n\n2.\tThere is no way to create functions other than the Pn() functions\n\tthat model the concurrent processes.\n\n3.\tThe Pn() functions' formal parameters must be pointers to the\n\tglobal shared variables.  Nothing can be passed by value into\n\tthese functions.\n\n4.\tThe only functions that can be invoked are those built directly\n\tinto herd7 or that are defined in the linux-kernel.def file.\n\n5.\tThe \"switch\", \"do\", \"for\", \"while\", and \"goto\" C statements are\n\tnot supported.\tThe \"switch\" statement can be emulated by the\n\t\"if\" statement.  The \"do\", \"for\", and \"while\" statements can\n\toften be emulated by manually unrolling the loop, or perhaps by\n\tenlisting the aid of the C preprocessor to minimize the resulting\n\tcode duplication.  Some uses of \"goto\" can be emulated by \"if\",\n\tand some others by unrolling.\n\n6.\tAlthough you can use a wide variety of types in litmus-test\n\tvariable declarations, and especially in global-variable\n\tdeclarations, the \"herd7\" tool understands only int and\n\tpointer types.\tThere is no support for floating-point types,\n\tenumerations, characters, strings, arrays, or structures.\n\n7.\tParsing of variable declarations is very loose, with almost no\n\ttype checking.\n\n8.\tInitializers differ from their C-language counterparts.\n\tFor example, when an initializer contains the name of a shared\n\tvariable, that name denotes a pointer to that variable, not\n\tthe current value of that variable.  For example, \"int x = y\"\n\tis interpreted the way \"int x = &y\" would be in C.\n\n9.\tDynamic memory allocation is not supported, although this can\n\tbe worked around in some cases by supplying multiple statically\n\tallocated variables.\n\nSome of these limitations may be overcome in the future, but others are\nmore likely to be addressed by incorporating the Linux-kernel memory model\ninto other tools.\n\nFinally, please note that LKMM is subject to change as hardware, use cases,\nand compilers evolve.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}