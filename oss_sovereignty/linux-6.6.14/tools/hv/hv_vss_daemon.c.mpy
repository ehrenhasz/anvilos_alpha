{
  "module_name": "hv_vss_daemon.c",
  "hash_id": "08198aa8f996bac44514c5af43700849e8792b621b7e4b25e5364b55199f107c",
  "original_prompt": "Ingested from linux-6.6.14/tools/hv/hv_vss_daemon.c",
  "human_readable_source": "\n \n\n\n#include <sys/types.h>\n#include <sys/poll.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/sysmacros.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <mntent.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <linux/fs.h>\n#include <linux/major.h>\n#include <linux/hyperv.h>\n#include <syslog.h>\n#include <getopt.h>\n#include <stdbool.h>\n#include <dirent.h>\n\nstatic bool fs_frozen;\n\n \nstatic int vss_do_freeze(char *dir, unsigned int cmd)\n{\n\tint ret, fd = open(dir, O_RDONLY);\n\n\tif (fd < 0)\n\t\treturn 1;\n\n\tret = ioctl(fd, cmd, 0);\n\n\t \n\tif (ret) {\n\t\tif ((cmd == FIFREEZE && errno == EBUSY) ||\n\t\t    (cmd == FITHAW && errno == EINVAL)) {\n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tclose(fd);\n\treturn !!ret;\n}\n\nstatic bool is_dev_loop(const char *blkname)\n{\n\tchar *buffer;\n\tDIR *dir;\n\tstruct dirent *entry;\n\tbool ret = false;\n\n\tbuffer = malloc(PATH_MAX);\n\tif (!buffer) {\n\t\tsyslog(LOG_ERR, \"Can't allocate memory!\");\n\t\texit(1);\n\t}\n\n\tsnprintf(buffer, PATH_MAX, \"%s/loop\", blkname);\n\tif (!access(buffer, R_OK | X_OK)) {\n\t\tret = true;\n\t\tgoto free_buffer;\n\t} else if (errno != ENOENT) {\n\t\tsyslog(LOG_ERR, \"Can't access: %s; error:%d %s!\",\n\t\t       buffer, errno, strerror(errno));\n\t}\n\n\tsnprintf(buffer, PATH_MAX, \"%s/slaves\", blkname);\n\tdir = opendir(buffer);\n\tif (!dir) {\n\t\tif (errno != ENOENT)\n\t\t\tsyslog(LOG_ERR, \"Can't opendir: %s; error:%d %s!\",\n\t\t\t       buffer, errno, strerror(errno));\n\t\tgoto free_buffer;\n\t}\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 ||\n\t\t    strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(buffer, PATH_MAX, \"%s/slaves/%s\", blkname,\n\t\t\t entry->d_name);\n\t\tif (is_dev_loop(buffer)) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclosedir(dir);\nfree_buffer:\n\tfree(buffer);\n\treturn ret;\n}\n\nstatic int vss_operate(int operation)\n{\n\tchar match[] = \"/dev/\";\n\tFILE *mounts;\n\tstruct mntent *ent;\n\tstruct stat sb;\n\tchar errdir[1024] = {0};\n\tchar blkdir[23];  \n\tunsigned int cmd;\n\tint error = 0, root_seen = 0, save_errno = 0;\n\n\tswitch (operation) {\n\tcase VSS_OP_FREEZE:\n\t\tcmd = FIFREEZE;\n\t\tbreak;\n\tcase VSS_OP_THAW:\n\t\tcmd = FITHAW;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tmounts = setmntent(\"/proc/mounts\", \"r\");\n\tif (mounts == NULL)\n\t\treturn -1;\n\n\twhile ((ent = getmntent(mounts))) {\n\t\tif (strncmp(ent->mnt_fsname, match, strlen(match)))\n\t\t\tcontinue;\n\t\tif (stat(ent->mnt_fsname, &sb)) {\n\t\t\tsyslog(LOG_ERR, \"Can't stat: %s; error:%d %s!\",\n\t\t\t       ent->mnt_fsname, errno, strerror(errno));\n\t\t} else {\n\t\t\tsprintf(blkdir, \"/sys/dev/block/%d:%d\",\n\t\t\t\tmajor(sb.st_rdev), minor(sb.st_rdev));\n\t\t\tif (is_dev_loop(blkdir))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (hasmntopt(ent, MNTOPT_RO) != NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(ent->mnt_type, \"vfat\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(ent->mnt_dir, \"/\") == 0) {\n\t\t\troot_seen = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terror |= vss_do_freeze(ent->mnt_dir, cmd);\n\t\tif (operation == VSS_OP_FREEZE) {\n\t\t\tif (error)\n\t\t\t\tgoto err;\n\t\t\tfs_frozen = true;\n\t\t}\n\t}\n\n\tendmntent(mounts);\n\n\tif (root_seen) {\n\t\terror |= vss_do_freeze(\"/\", cmd);\n\t\tif (operation == VSS_OP_FREEZE) {\n\t\t\tif (error)\n\t\t\t\tgoto err;\n\t\t\tfs_frozen = true;\n\t\t}\n\t}\n\n\tif (operation == VSS_OP_THAW && !error)\n\t\tfs_frozen = false;\n\n\tgoto out;\nerr:\n\tsave_errno = errno;\n\tif (ent) {\n\t\tstrncpy(errdir, ent->mnt_dir, sizeof(errdir)-1);\n\t\tendmntent(mounts);\n\t}\n\tvss_operate(VSS_OP_THAW);\n\tfs_frozen = false;\n\t \n\tif (ent)\n\t\tsyslog(LOG_ERR, \"FREEZE of %s failed; error:%d %s\",\n\t\t       errdir, save_errno, strerror(save_errno));\n\telse\n\t\tsyslog(LOG_ERR, \"FREEZE of / failed; error:%d %s\", save_errno,\n\t\t       strerror(save_errno));\nout:\n\treturn error;\n}\n\nvoid print_usage(char *argv[])\n{\n\tfprintf(stderr, \"Usage: %s [options]\\n\"\n\t\t\"Options are:\\n\"\n\t\t\"  -n, --no-daemon        stay in foreground, don't daemonize\\n\"\n\t\t\"  -h, --help             print this help\\n\", argv[0]);\n}\n\nint main(int argc, char *argv[])\n{\n\tint vss_fd = -1, len;\n\tint error;\n\tstruct pollfd pfd;\n\tint\top;\n\tstruct hv_vss_msg vss_msg[1];\n\tint daemonize = 1, long_index = 0, opt;\n\tint in_handshake;\n\t__u32 kernel_modver;\n\n\tstatic struct option long_options[] = {\n\t\t{\"help\",\tno_argument,\t   0,  'h' },\n\t\t{\"no-daemon\",\tno_argument,\t   0,  'n' },\n\t\t{0,\t\t0,\t\t   0,  0   }\n\t};\n\n\twhile ((opt = getopt_long(argc, argv, \"hn\", long_options,\n\t\t\t\t  &long_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'n':\n\t\t\tdaemonize = 0;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tprint_usage(argv);\n\t\t\texit(0);\n\t\tdefault:\n\t\t\tprint_usage(argv);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (daemonize && daemon(1, 0))\n\t\treturn 1;\n\n\topenlog(\"Hyper-V VSS\", 0, LOG_USER);\n\tsyslog(LOG_INFO, \"VSS starting; pid is:%d\", getpid());\n\nreopen_vss_fd:\n\tif (vss_fd != -1)\n\t\tclose(vss_fd);\n\tif (fs_frozen) {\n\t\tif (vss_operate(VSS_OP_THAW) || fs_frozen) {\n\t\t\tsyslog(LOG_ERR, \"failed to thaw file system: err=%d\",\n\t\t\t       errno);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tin_handshake = 1;\n\tvss_fd = open(\"/dev/vmbus/hv_vss\", O_RDWR);\n\tif (vss_fd < 0) {\n\t\tsyslog(LOG_ERR, \"open /dev/vmbus/hv_vss failed; error: %d %s\",\n\t\t       errno, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\t \n\tvss_msg->vss_hdr.operation = VSS_OP_REGISTER1;\n\n\tlen = write(vss_fd, vss_msg, sizeof(struct hv_vss_msg));\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"registration to kernel failed; error: %d %s\",\n\t\t       errno, strerror(errno));\n\t\tclose(vss_fd);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpfd.fd = vss_fd;\n\n\twhile (1) {\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\n\t\tif (poll(&pfd, 1, -1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"poll failed; error:%d %s\", errno, strerror(errno));\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tclose(vss_fd);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlen = read(vss_fd, vss_msg, sizeof(struct hv_vss_msg));\n\n\t\tif (in_handshake) {\n\t\t\tif (len != sizeof(kernel_modver)) {\n\t\t\t\tsyslog(LOG_ERR, \"invalid version negotiation\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tkernel_modver = *(__u32 *)vss_msg;\n\t\t\tin_handshake = 0;\n\t\t\tsyslog(LOG_INFO, \"VSS: kernel module version: %d\",\n\t\t\t       kernel_modver);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (len != sizeof(struct hv_vss_msg)) {\n\t\t\tsyslog(LOG_ERR, \"read failed; error:%d %s\",\n\t\t\t       errno, strerror(errno));\n\t\t\tgoto reopen_vss_fd;\n\t\t}\n\n\t\top = vss_msg->vss_hdr.operation;\n\t\terror =  HV_S_OK;\n\n\t\tswitch (op) {\n\t\tcase VSS_OP_FREEZE:\n\t\tcase VSS_OP_THAW:\n\t\t\terror = vss_operate(op);\n\t\t\tsyslog(LOG_INFO, \"VSS: op=%s: %s\\n\",\n\t\t\t\top == VSS_OP_FREEZE ? \"FREEZE\" : \"THAW\",\n\t\t\t\terror ? \"failed\" : \"succeeded\");\n\n\t\t\tif (error) {\n\t\t\t\terror = HV_E_FAIL;\n\t\t\t\tsyslog(LOG_ERR, \"op=%d failed!\", op);\n\t\t\t\tsyslog(LOG_ERR, \"report it with these files:\");\n\t\t\t\tsyslog(LOG_ERR, \"/etc/fstab and /proc/mounts\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VSS_OP_HOT_BACKUP:\n\t\t\tsyslog(LOG_INFO, \"VSS: op=CHECK HOT BACKUP\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsyslog(LOG_ERR, \"Illegal op:%d\\n\", op);\n\t\t}\n\n\t\t \n\t\tvss_msg->error = error;\n\t\tlen = write(vss_fd, vss_msg, sizeof(struct hv_vss_msg));\n\t\tif (len != sizeof(struct hv_vss_msg)) {\n\t\t\tsyslog(LOG_ERR, \"write failed; error: %d %s\", errno,\n\t\t\t       strerror(errno));\n\t\t\tgoto reopen_vss_fd;\n\t\t}\n\t}\n\n\tclose(vss_fd);\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}