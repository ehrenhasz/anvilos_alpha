{
  "module_name": "vmbus_testing",
  "hash_id": "28dc85a7bf171279ece333e07656caa3519baf74b7c09b0355f45e3e5b7fe139",
  "original_prompt": "Ingested from linux-6.6.14/tools/hv/vmbus_testing",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0\n#\n# Program to allow users to fuzz test Hyper-V drivers\n# by interfacing with Hyper-V debugfs attributes.\n# Current test methods available:\n#       1. delay testing\n#\n# Current file/directory structure of hyper-V debugfs:\n#       /sys/kernel/debug/hyperv/UUID\n#       /sys/kernel/debug/hyperv/UUID/<test-state filename>\n#       /sys/kernel/debug/hyperv/UUID/<test-method sub-directory>\n#\n# author: Branden Bonaby <brandonbonaby94@gmail.com>\n\nimport os\nimport cmd\nimport argparse\nimport glob\nfrom argparse import RawDescriptionHelpFormatter\nfrom argparse import RawTextHelpFormatter\nfrom enum import Enum\n\n# Do not change unless, you change the debugfs attributes\n# in /drivers/hv/debugfs.c. All fuzz testing\n# attributes will start with \"fuzz_test\".\n\n# debugfs path for hyperv must exist before proceeding\ndebugfs_hyperv_path = \"/sys/kernel/debug/hyperv\"\nif not os.path.isdir(debugfs_hyperv_path):\n        print(\"{} doesn't exist/check permissions\".format(debugfs_hyperv_path))\n        exit(-1)\n\nclass dev_state(Enum):\n        off = 0\n        on = 1\n\n# File names, that correspond to the files created in\n# /drivers/hv/debugfs.c\nclass f_names(Enum):\n        state_f = \"fuzz_test_state\"\n        buff_f =  \"fuzz_test_buffer_interrupt_delay\"\n        mess_f =  \"fuzz_test_message_delay\"\n\n# Both single_actions and all_actions are used\n# for error checking and to allow for some subparser\n# names to be abbreviated. Do not abbreviate the\n# test method names, as it will become less intuitive\n# as to what the user can do. If you do decide to\n# abbreviate the test method name, make sure the main\n# function reflects this change.\n\nall_actions = [\n        \"disable_all\",\n        \"D\",\n        \"enable_all\",\n        \"view_all\",\n        \"V\"\n]\n\nsingle_actions = [\n        \"disable_single\",\n        \"d\",\n        \"enable_single\",\n        \"view_single\",\n        \"v\"\n]\n\ndef main():\n\n        file_map = recursive_file_lookup(debugfs_hyperv_path, dict())\n        args = parse_args()\n        if (not args.action):\n                print (\"Error, no options selected...exiting\")\n                exit(-1)\n        arg_set = { k for (k,v) in vars(args).items() if v and k != \"action\" }\n        arg_set.add(args.action)\n        path = args.path if \"path\" in arg_set else None\n        if (path and path[-1] == \"/\"):\n                path = path[:-1]\n        validate_args_path(path, arg_set, file_map)\n        if (path and \"enable_single\" in arg_set):\n            state_path = locate_state(path, file_map)\n            set_test_state(state_path, dev_state.on.value, args.quiet)\n\n        # Use subparsers as the key for different actions\n        if (\"delay\" in arg_set):\n                validate_delay_values(args.delay_time)\n                if (args.enable_all):\n                        set_delay_all_devices(file_map, args.delay_time,\n                                              args.quiet)\n                else:\n                        set_delay_values(path, file_map, args.delay_time,\n                                         args.quiet)\n        elif (\"disable_all\" in arg_set or \"D\" in arg_set):\n                disable_all_testing(file_map)\n        elif (\"disable_single\" in arg_set or \"d\" in arg_set):\n                disable_testing_single_device(path, file_map)\n        elif (\"view_all\" in arg_set or \"V\" in arg_set):\n                get_all_devices_test_status(file_map)\n        elif (\"view_single\" in arg_set or  \"v\" in arg_set):\n                get_device_test_values(path, file_map)\n\n# Get the state location\ndef locate_state(device, file_map):\n        return file_map[device][f_names.state_f.value]\n\n# Validate delay values to make sure they are acceptable to\n# enable delays on a device\ndef validate_delay_values(delay):\n\n        if (delay[0]  == -1 and delay[1] == -1):\n                print(\"\\nError, At least 1 value must be greater than 0\")\n                exit(-1)\n        for i in delay:\n                if (i < -1 or i == 0 or i > 1000):\n                        print(\"\\nError, Values must be  equal to -1 \"\n                              \"or be > 0 and <= 1000\")\n                        exit(-1)\n\n# Validate argument path\ndef validate_args_path(path, arg_set, file_map):\n\n        if (not path and any(element in arg_set for element in single_actions)):\n                print(\"Error, path (-p) REQUIRED for the specified option. \"\n                      \"Use (-h) to check usage.\")\n                exit(-1)\n        elif (path and any(item in arg_set for item in all_actions)):\n                print(\"Error, path (-p) NOT REQUIRED for the specified option. \"\n                      \"Use (-h) to check usage.\" )\n                exit(-1)\n        elif (path not in file_map and any(item in arg_set\n                                           for item in single_actions)):\n                print(\"Error, path '{}' not a valid vmbus device\".format(path))\n                exit(-1)\n\n# display Testing status of single device\ndef get_device_test_values(path, file_map):\n\n        for name in file_map[path]:\n                file_location = file_map[path][name]\n                print( name + \" = \" + str(read_test_files(file_location)))\n\n# Create a map of the vmbus devices and their associated files\n# [key=device, value = [key = filename, value = file path]]\ndef recursive_file_lookup(path, file_map):\n\n        for f_path in glob.iglob(path + '**/*'):\n                if (os.path.isfile(f_path)):\n                        if (f_path.rsplit(\"/\",2)[0] == debugfs_hyperv_path):\n                                directory = f_path.rsplit(\"/\",1)[0]\n                        else:\n                                directory = f_path.rsplit(\"/\",2)[0]\n                        f_name = f_path.split(\"/\")[-1]\n                        if (file_map.get(directory)):\n                                file_map[directory].update({f_name:f_path})\n                        else:\n                                file_map[directory] = {f_name:f_path}\n                elif (os.path.isdir(f_path)):\n                        recursive_file_lookup(f_path,file_map)\n        return file_map\n\n# display Testing state of devices\ndef get_all_devices_test_status(file_map):\n\n        for device in file_map:\n                if (get_test_state(locate_state(device, file_map)) == 1):\n                        print(\"Testing = ON for: {}\"\n                              .format(device.split(\"/\")[5]))\n                else:\n                        print(\"Testing = OFF for: {}\"\n                              .format(device.split(\"/\")[5]))\n\n# read the vmbus device files, path must be absolute path before calling\ndef read_test_files(path):\n        try:\n                with open(path,\"r\") as f:\n                        file_value = f.readline().strip()\n                return int(file_value)\n\n        except IOError as e:\n                errno, strerror = e.args\n                print(\"I/O error({0}): {1} on file {2}\"\n                      .format(errno, strerror, path))\n                exit(-1)\n        except ValueError:\n                print (\"Element to int conversion error in: \\n{}\".format(path))\n                exit(-1)\n\n# writing to vmbus device files, path must be absolute path before calling\ndef write_test_files(path, value):\n\n        try:\n                with open(path,\"w\") as f:\n                        f.write(\"{}\".format(value))\n        except IOError as e:\n                errno, strerror = e.args\n                print(\"I/O error({0}): {1} on file {2}\"\n                      .format(errno, strerror, path))\n                exit(-1)\n\n# set testing state of device\ndef set_test_state(state_path, state_value, quiet):\n\n        write_test_files(state_path, state_value)\n        if (get_test_state(state_path) == 1):\n                if (not quiet):\n                        print(\"Testing = ON for device: {}\"\n                              .format(state_path.split(\"/\")[5]))\n        else:\n                if (not quiet):\n                        print(\"Testing = OFF for device: {}\"\n                              .format(state_path.split(\"/\")[5]))\n\n# get testing state of device\ndef get_test_state(state_path):\n        #state == 1 - test = ON\n        #state == 0 - test = OFF\n        return  read_test_files(state_path)\n\n# write 1 - 1000 microseconds, into a single device using the\n# fuzz_test_buffer_interrupt_delay and fuzz_test_message_delay\n# debugfs attributes\ndef set_delay_values(device, file_map, delay_length, quiet):\n\n        try:\n                interrupt = file_map[device][f_names.buff_f.value]\n                message = file_map[device][f_names.mess_f.value]\n\n                # delay[0]- buffer interrupt delay, delay[1]- message delay\n                if (delay_length[0] >= 0 and delay_length[0] <= 1000):\n                        write_test_files(interrupt, delay_length[0])\n                if (delay_length[1] >= 0 and delay_length[1] <= 1000):\n                        write_test_files(message, delay_length[1])\n                if (not quiet):\n                        print(\"Buffer delay testing = {} for: {}\"\n                              .format(read_test_files(interrupt),\n                                      interrupt.split(\"/\")[5]))\n                        print(\"Message delay testing = {} for: {}\"\n                              .format(read_test_files(message),\n                                      message.split(\"/\")[5]))\n        except IOError as e:\n                errno, strerror = e.args\n                print(\"I/O error({0}): {1} on files {2}{3}\"\n                      .format(errno, strerror, interrupt, message))\n                exit(-1)\n\n# enabling delay testing on all devices\ndef set_delay_all_devices(file_map, delay, quiet):\n\n        for device in (file_map):\n                set_test_state(locate_state(device, file_map),\n                               dev_state.on.value,\n                               quiet)\n                set_delay_values(device, file_map, delay, quiet)\n\n# disable all testing on a SINGLE device.\ndef disable_testing_single_device(device, file_map):\n\n        for name in file_map[device]:\n                file_location = file_map[device][name]\n                write_test_files(file_location, dev_state.off.value)\n        print(\"ALL testing now OFF for {}\".format(device.split(\"/\")[-1]))\n\n# disable all testing on ALL devices\ndef disable_all_testing(file_map):\n\n        for device in file_map:\n                disable_testing_single_device(device, file_map)\n\ndef parse_args():\n        parser = argparse.ArgumentParser(prog = \"vmbus_testing\",usage =\"\\n\"\n                \"%(prog)s [delay]   [-h] [-e|-E] -t [-p]\\n\"\n                \"%(prog)s [view_all       | V]      [-h]\\n\"\n                \"%(prog)s [disable_all    | D]      [-h]\\n\"\n                \"%(prog)s [disable_single | d]      [-h|-p]\\n\"\n                \"%(prog)s [view_single    | v]      [-h|-p]\\n\"\n                \"%(prog)s --version\\n\",\n                description = \"\\nUse lsvmbus to get vmbus device type \"\n                \"information.\\n\" \"\\nThe debugfs root path is \"\n                \"/sys/kernel/debug/hyperv\",\n                formatter_class = RawDescriptionHelpFormatter)\n        subparsers = parser.add_subparsers(dest = \"action\")\n        parser.add_argument(\"--version\", action = \"version\",\n                version = '%(prog)s 0.1.0')\n        parser.add_argument(\"-q\",\"--quiet\", action = \"store_true\",\n                help = \"silence none important test messages.\"\n                       \" This will only work when enabling testing\"\n                       \" on a device.\")\n        # Use the path parser to hold the --path attribute so it can\n        # be shared between subparsers. Also do the same for the state\n        # parser, as all testing methods will use --enable_all and\n        # enable_single.\n        path_parser = argparse.ArgumentParser(add_help=False)\n        path_parser.add_argument(\"-p\",\"--path\", metavar = \"\",\n                help = \"Debugfs path to a vmbus device. The path \"\n                \"must be the absolute path to the device.\")\n        state_parser = argparse.ArgumentParser(add_help=False)\n        state_group = state_parser.add_mutually_exclusive_group(required = True)\n        state_group.add_argument(\"-E\", \"--enable_all\", action = \"store_const\",\n                                 const = \"enable_all\",\n                                 help = \"Enable the specified test type \"\n                                 \"on ALL vmbus devices.\")\n        state_group.add_argument(\"-e\", \"--enable_single\",\n                                 action = \"store_const\",\n                                 const = \"enable_single\",\n                                 help = \"Enable the specified test type on a \"\n                                 \"SINGLE vmbus device.\")\n        parser_delay = subparsers.add_parser(\"delay\",\n                        parents = [state_parser, path_parser],\n                        help = \"Delay the ring buffer interrupt or the \"\n                        \"ring buffer message reads in microseconds.\",\n                        prog = \"vmbus_testing\",\n                        usage = \"%(prog)s [-h]\\n\"\n                        \"%(prog)s -E -t [value] [value]\\n\"\n                        \"%(prog)s -e -t [value] [value] -p\",\n                        description = \"Delay the ring buffer interrupt for \"\n                        \"vmbus devices, or delay the ring buffer message \"\n                        \"reads for vmbus devices (both in microseconds). This \"\n                        \"is only on the host to guest channel.\")\n        parser_delay.add_argument(\"-t\", \"--delay_time\", metavar = \"\", nargs = 2,\n                        type = check_range, default =[0,0], required = (True),\n                        help = \"Set [buffer] & [message] delay time. \"\n                        \"Value constraints: -1 == value \"\n                        \"or 0 < value <= 1000.\\n\"\n                        \"Use -1 to keep the previous value for that delay \"\n                        \"type, or a value > 0 <= 1000 to change the delay \"\n                        \"time.\")\n        parser_dis_all = subparsers.add_parser(\"disable_all\",\n                        aliases = ['D'], prog = \"vmbus_testing\",\n                        usage = \"%(prog)s [disable_all | D] -h\\n\"\n                        \"%(prog)s [disable_all | D]\\n\",\n                        help = \"Disable ALL testing on ALL vmbus devices.\",\n                        description = \"Disable ALL testing on ALL vmbus \"\n                        \"devices.\")\n        parser_dis_single = subparsers.add_parser(\"disable_single\",\n                        aliases = ['d'],\n                        parents = [path_parser], prog = \"vmbus_testing\",\n                        usage = \"%(prog)s [disable_single | d] -h\\n\"\n                        \"%(prog)s [disable_single | d] -p\\n\",\n                        help = \"Disable ALL testing on a SINGLE vmbus device.\",\n                        description = \"Disable ALL testing on a SINGLE vmbus \"\n                        \"device.\")\n        parser_view_all = subparsers.add_parser(\"view_all\", aliases = ['V'],\n                        help = \"View the test state for ALL vmbus devices.\",\n                        prog = \"vmbus_testing\",\n                        usage = \"%(prog)s [view_all | V] -h\\n\"\n                        \"%(prog)s [view_all | V]\\n\",\n                        description = \"This shows the test state for ALL the \"\n                        \"vmbus devices.\")\n        parser_view_single = subparsers.add_parser(\"view_single\",\n                        aliases = ['v'],parents = [path_parser],\n                        help = \"View the test values for a SINGLE vmbus \"\n                        \"device.\",\n                        description = \"This shows the test values for a SINGLE \"\n                        \"vmbus device.\", prog = \"vmbus_testing\",\n                        usage = \"%(prog)s [view_single | v] -h\\n\"\n                        \"%(prog)s [view_single | v] -p\")\n\n        return  parser.parse_args()\n\n# value checking for range checking input in parser\ndef check_range(arg1):\n\n        try:\n                val = int(arg1)\n        except ValueError as err:\n                raise argparse.ArgumentTypeError(str(err))\n        if val < -1 or val > 1000:\n                message = (\"\\n\\nvalue must be -1 or  0 < value <= 1000. \"\n                           \"Value program received: {}\\n\").format(val)\n                raise argparse.ArgumentTypeError(message)\n        return val\n\nif __name__ == \"__main__\":\n        main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}