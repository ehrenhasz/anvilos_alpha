{
  "module_name": "hv_fcopy_daemon.c",
  "hash_id": "fa62b68568929c00c8215dfcd8bcadfa4e912b353753fb0788b575c3c5a91850",
  "original_prompt": "Ingested from linux-6.6.14/tools/hv/hv_fcopy_daemon.c",
  "human_readable_source": "\n \n\n\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <linux/hyperv.h>\n#include <linux/limits.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <getopt.h>\n\nstatic int target_fd;\nstatic char target_fname[PATH_MAX];\nstatic unsigned long long filesize;\n\nstatic int hv_start_fcopy(struct hv_start_fcopy *smsg)\n{\n\tint error = HV_E_FAIL;\n\tchar *q, *p;\n\n\tfilesize = 0;\n\tp = (char *)smsg->path_name;\n\tsnprintf(target_fname, sizeof(target_fname), \"%s/%s\",\n\t\t (char *)smsg->path_name, (char *)smsg->file_name);\n\n\tsyslog(LOG_INFO, \"Target file name: %s\", target_fname);\n\t \n\twhile ((q = strchr(p, '/')) != NULL) {\n\t\tif (q == p) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\t*q = '\\0';\n\t\tif (access((char *)smsg->path_name, F_OK)) {\n\t\t\tif (smsg->copy_flags & CREATE_PATH) {\n\t\t\t\tif (mkdir((char *)smsg->path_name, 0755)) {\n\t\t\t\t\tsyslog(LOG_ERR, \"Failed to create %s\",\n\t\t\t\t\t\t(char *)smsg->path_name);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"Invalid path: %s\",\n\t\t\t\t\t(char *)smsg->path_name);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tp = q + 1;\n\t\t*q = '/';\n\t}\n\n\tif (!access(target_fname, F_OK)) {\n\t\tsyslog(LOG_INFO, \"File: %s exists\", target_fname);\n\t\tif (!(smsg->copy_flags & OVER_WRITE)) {\n\t\t\terror = HV_ERROR_ALREADY_EXISTS;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\ttarget_fd = open(target_fname,\n\t\t\t O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, 0744);\n\tif (target_fd == -1) {\n\t\tsyslog(LOG_INFO, \"Open Failed: %s\", strerror(errno));\n\t\tgoto done;\n\t}\n\n\terror = 0;\ndone:\n\tif (error)\n\t\ttarget_fname[0] = '\\0';\n\treturn error;\n}\n\nstatic int hv_copy_data(struct hv_do_fcopy *cpmsg)\n{\n\tssize_t bytes_written;\n\tint ret = 0;\n\n\tbytes_written = pwrite(target_fd, cpmsg->data, cpmsg->size,\n\t\t\t\tcpmsg->offset);\n\n\tfilesize += cpmsg->size;\n\tif (bytes_written != cpmsg->size) {\n\t\tswitch (errno) {\n\t\tcase ENOSPC:\n\t\t\tret = HV_ERROR_DISK_FULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = HV_E_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tsyslog(LOG_ERR, \"pwrite failed to write %llu bytes: %ld (%s)\",\n\t\t       filesize, (long)bytes_written, strerror(errno));\n\t}\n\n\treturn ret;\n}\n\n \nstatic int hv_copy_finished(void)\n{\n\tclose(target_fd);\n\ttarget_fname[0] = '\\0';\n\treturn 0;\n}\nstatic int hv_copy_cancel(void)\n{\n\tclose(target_fd);\n\tif (strlen(target_fname) > 0) {\n\t\tunlink(target_fname);\n\t\ttarget_fname[0] = '\\0';\n\t}\n\treturn 0;\n\n}\n\nvoid print_usage(char *argv[])\n{\n\tfprintf(stderr, \"Usage: %s [options]\\n\"\n\t\t\"Options are:\\n\"\n\t\t\"  -n, --no-daemon        stay in foreground, don't daemonize\\n\"\n\t\t\"  -h, --help             print this help\\n\", argv[0]);\n}\n\nint main(int argc, char *argv[])\n{\n\tint fcopy_fd = -1;\n\tint error;\n\tint daemonize = 1, long_index = 0, opt;\n\tint version = FCOPY_CURRENT_VERSION;\n\tunion {\n\t\tstruct hv_fcopy_hdr hdr;\n\t\tstruct hv_start_fcopy start;\n\t\tstruct hv_do_fcopy copy;\n\t\t__u32 kernel_modver;\n\t} buffer = { };\n\tint in_handshake;\n\n\tstatic struct option long_options[] = {\n\t\t{\"help\",\tno_argument,\t   0,  'h' },\n\t\t{\"no-daemon\",\tno_argument,\t   0,  'n' },\n\t\t{0,\t\t0,\t\t   0,  0   }\n\t};\n\n\twhile ((opt = getopt_long(argc, argv, \"hn\", long_options,\n\t\t\t\t  &long_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'n':\n\t\t\tdaemonize = 0;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tprint_usage(argv);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (daemonize && daemon(1, 0)) {\n\t\tsyslog(LOG_ERR, \"daemon() failed; error: %s\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\topenlog(\"HV_FCOPY\", 0, LOG_USER);\n\tsyslog(LOG_INFO, \"starting; pid is:%d\", getpid());\n\nreopen_fcopy_fd:\n\tif (fcopy_fd != -1)\n\t\tclose(fcopy_fd);\n\t \n\thv_copy_cancel();\n\tin_handshake = 1;\n\tfcopy_fd = open(\"/dev/vmbus/hv_fcopy\", O_RDWR);\n\n\tif (fcopy_fd < 0) {\n\t\tsyslog(LOG_ERR, \"open /dev/vmbus/hv_fcopy failed; error: %d %s\",\n\t\t\terrno, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tif ((write(fcopy_fd, &version, sizeof(int))) != sizeof(int)) {\n\t\tsyslog(LOG_ERR, \"Registration failed: %s\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\twhile (1) {\n\t\t \n\t\tssize_t len;\n\n\t\tlen = pread(fcopy_fd, &buffer, sizeof(buffer), 0);\n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"pread failed: %s\", strerror(errno));\n\t\t\tgoto reopen_fcopy_fd;\n\t\t}\n\n\t\tif (in_handshake) {\n\t\t\tif (len != sizeof(buffer.kernel_modver)) {\n\t\t\t\tsyslog(LOG_ERR, \"invalid version negotiation\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tin_handshake = 0;\n\t\t\tsyslog(LOG_INFO, \"kernel module version: %u\",\n\t\t\t       buffer.kernel_modver);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (buffer.hdr.operation) {\n\t\tcase START_FILE_COPY:\n\t\t\terror = hv_start_fcopy(&buffer.start);\n\t\t\tbreak;\n\t\tcase WRITE_TO_FILE:\n\t\t\terror = hv_copy_data(&buffer.copy);\n\t\t\tbreak;\n\t\tcase COMPLETE_FCOPY:\n\t\t\terror = hv_copy_finished();\n\t\t\tbreak;\n\t\tcase CANCEL_FCOPY:\n\t\t\terror = hv_copy_cancel();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terror = HV_E_FAIL;\n\t\t\tsyslog(LOG_ERR, \"Unknown operation: %d\",\n\t\t\t\tbuffer.hdr.operation);\n\n\t\t}\n\n\t\t \n\t\tif (pwrite(fcopy_fd, &error, sizeof(int), 0) != sizeof(int)) {\n\t\t\tsyslog(LOG_ERR, \"pwrite failed: %s\", strerror(errno));\n\t\t\tgoto reopen_fcopy_fd;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}