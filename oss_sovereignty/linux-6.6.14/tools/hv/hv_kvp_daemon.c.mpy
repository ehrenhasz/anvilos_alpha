{
  "module_name": "hv_kvp_daemon.c",
  "hash_id": "06244a884e8e38aa0fcfe1770d3f617fdbf15d7244bbb6c24aeb6939c8186484",
  "original_prompt": "Ingested from linux-6.6.14/tools/hv/hv_kvp_daemon.c",
  "human_readable_source": " \n\n\n#include <sys/poll.h>\n#include <sys/utsname.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <linux/hyperv.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <syslog.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <net/if.h>\n#include <limits.h>\n#include <getopt.h>\n\n \n\n\nenum key_index {\n\tFullyQualifiedDomainName = 0,\n\tIntegrationServicesVersion,  \n\tNetworkAddressIPv4,\n\tNetworkAddressIPv6,\n\tOSBuildNumber,\n\tOSName,\n\tOSMajorVersion,\n\tOSMinorVersion,\n\tOSVersion,\n\tProcessorArchitecture\n};\n\n\nenum {\n\tIPADDR = 0,\n\tNETMASK,\n\tGATEWAY,\n\tDNS\n};\n\nstatic int in_hand_shake;\n\nstatic char *os_name = \"\";\nstatic char *os_major = \"\";\nstatic char *os_minor = \"\";\nstatic char *processor_arch;\nstatic char *os_build;\nstatic char *os_version;\nstatic char *lic_version = \"Unknown version\";\nstatic char full_domain_name[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];\nstatic struct utsname uts_buf;\n\n \n\n#define KVP_CONFIG_LOC\t\"/var/lib/hyperv\"\n\n#ifndef KVP_SCRIPTS_PATH\n#define KVP_SCRIPTS_PATH \"/usr/libexec/hypervkvpd/\"\n#endif\n\n#define KVP_NET_DIR \"/sys/class/net/\"\n\n#define MAX_FILE_NAME 100\n#define ENTRIES_PER_BLOCK 50\n\nstruct kvp_record {\n\tchar key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];\n\tchar value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];\n};\n\nstruct kvp_file_state {\n\tint fd;\n\tint num_blocks;\n\tstruct kvp_record *records;\n\tint num_records;\n\tchar fname[MAX_FILE_NAME];\n};\n\nstatic struct kvp_file_state kvp_file_info[KVP_POOL_COUNT];\n\nstatic void kvp_acquire_lock(int pool)\n{\n\tstruct flock fl = {F_WRLCK, SEEK_SET, 0, 0, 0};\n\tfl.l_pid = getpid();\n\n\tif (fcntl(kvp_file_info[pool].fd, F_SETLKW, &fl) == -1) {\n\t\tsyslog(LOG_ERR, \"Failed to acquire the lock pool: %d; error: %d %s\", pool,\n\t\t\t\terrno, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nstatic void kvp_release_lock(int pool)\n{\n\tstruct flock fl = {F_UNLCK, SEEK_SET, 0, 0, 0};\n\tfl.l_pid = getpid();\n\n\tif (fcntl(kvp_file_info[pool].fd, F_SETLK, &fl) == -1) {\n\t\tsyslog(LOG_ERR, \"Failed to release the lock pool: %d; error: %d %s\", pool,\n\t\t\t\terrno, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nstatic void kvp_update_file(int pool)\n{\n\tFILE *filep;\n\n\t \n\tkvp_acquire_lock(pool);\n\n\tfilep = fopen(kvp_file_info[pool].fname, \"we\");\n\tif (!filep) {\n\t\tsyslog(LOG_ERR, \"Failed to open file, pool: %d; error: %d %s\", pool,\n\t\t\t\terrno, strerror(errno));\n\t\tkvp_release_lock(pool);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfwrite(kvp_file_info[pool].records, sizeof(struct kvp_record),\n\t\t\t\tkvp_file_info[pool].num_records, filep);\n\n\tif (ferror(filep) || fclose(filep)) {\n\t\tkvp_release_lock(pool);\n\t\tsyslog(LOG_ERR, \"Failed to write file, pool: %d\", pool);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tkvp_release_lock(pool);\n}\n\nstatic void kvp_update_mem_state(int pool)\n{\n\tFILE *filep;\n\tsize_t records_read = 0;\n\tstruct kvp_record *record = kvp_file_info[pool].records;\n\tstruct kvp_record *readp;\n\tint num_blocks = kvp_file_info[pool].num_blocks;\n\tint alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;\n\n\tkvp_acquire_lock(pool);\n\n\tfilep = fopen(kvp_file_info[pool].fname, \"re\");\n\tif (!filep) {\n\t\tsyslog(LOG_ERR, \"Failed to open file, pool: %d; error: %d %s\", pool,\n\t\t\t\terrno, strerror(errno));\n\t\tkvp_release_lock(pool);\n\t\texit(EXIT_FAILURE);\n\t}\n\tfor (;;) {\n\t\treadp = &record[records_read];\n\t\trecords_read += fread(readp, sizeof(struct kvp_record),\n\t\t\t\tENTRIES_PER_BLOCK * num_blocks - records_read,\n\t\t\t\tfilep);\n\n\t\tif (ferror(filep)) {\n\t\t\tsyslog(LOG_ERR,\n\t\t\t\t\"Failed to read file, pool: %d; error: %d %s\",\n\t\t\t\t pool, errno, strerror(errno));\n\t\t\tkvp_release_lock(pool);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (!feof(filep)) {\n\t\t\t \n\t\t\tnum_blocks++;\n\t\t\trecord = realloc(record, alloc_unit * num_blocks);\n\n\t\t\tif (record == NULL) {\n\t\t\t\tsyslog(LOG_ERR, \"malloc failed\");\n\t\t\t\tkvp_release_lock(pool);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tkvp_file_info[pool].num_blocks = num_blocks;\n\tkvp_file_info[pool].records = record;\n\tkvp_file_info[pool].num_records = records_read;\n\n\tfclose(filep);\n\tkvp_release_lock(pool);\n}\n\nstatic int kvp_file_init(void)\n{\n\tint  fd;\n\tchar *fname;\n\tint i;\n\tint alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;\n\n\tif (access(KVP_CONFIG_LOC, F_OK)) {\n\t\tif (mkdir(KVP_CONFIG_LOC, 0755  )) {\n\t\t\tsyslog(LOG_ERR, \"Failed to create '%s'; error: %d %s\", KVP_CONFIG_LOC,\n\t\t\t\t\terrno, strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tfor (i = 0; i < KVP_POOL_COUNT; i++) {\n\t\tfname = kvp_file_info[i].fname;\n\t\tsprintf(fname, \"%s/.kvp_pool_%d\", KVP_CONFIG_LOC, i);\n\t\tfd = open(fname, O_RDWR | O_CREAT | O_CLOEXEC, 0644  );\n\n\t\tif (fd == -1)\n\t\t\treturn 1;\n\n\t\tkvp_file_info[i].fd = fd;\n\t\tkvp_file_info[i].num_blocks = 1;\n\t\tkvp_file_info[i].records = malloc(alloc_unit);\n\t\tif (kvp_file_info[i].records == NULL)\n\t\t\treturn 1;\n\t\tkvp_file_info[i].num_records = 0;\n\t\tkvp_update_mem_state(i);\n\t}\n\n\treturn 0;\n}\n\nstatic int kvp_key_delete(int pool, const __u8 *key, int key_size)\n{\n\tint i;\n\tint j, k;\n\tint num_records;\n\tstruct kvp_record *record;\n\n\t \n\tkvp_update_mem_state(pool);\n\n\tnum_records = kvp_file_info[pool].num_records;\n\trecord = kvp_file_info[pool].records;\n\n\tfor (i = 0; i < num_records; i++) {\n\t\tif (memcmp(key, record[i].key, key_size))\n\t\t\tcontinue;\n\t\t \n\t\tif (i == (num_records - 1)) {\n\t\t\tkvp_file_info[pool].num_records--;\n\t\t\tkvp_update_file(pool);\n\t\t\treturn 0;\n\t\t}\n\n\t\tj = i;\n\t\tk = j + 1;\n\t\tfor (; k < num_records; k++) {\n\t\t\tstrcpy(record[j].key, record[k].key);\n\t\t\tstrcpy(record[j].value, record[k].value);\n\t\t\tj++;\n\t\t}\n\n\t\tkvp_file_info[pool].num_records--;\n\t\tkvp_update_file(pool);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int kvp_key_add_or_modify(int pool, const __u8 *key, int key_size,\n\t\t\t\t const __u8 *value, int value_size)\n{\n\tint i;\n\tint num_records;\n\tstruct kvp_record *record;\n\tint num_blocks;\n\n\tif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\n\t\t(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\n\t\treturn 1;\n\n\t \n\tkvp_update_mem_state(pool);\n\n\tnum_records = kvp_file_info[pool].num_records;\n\trecord = kvp_file_info[pool].records;\n\tnum_blocks = kvp_file_info[pool].num_blocks;\n\n\tfor (i = 0; i < num_records; i++) {\n\t\tif (memcmp(key, record[i].key, key_size))\n\t\t\tcontinue;\n\t\t \n\t\tmemcpy(record[i].value, value, value_size);\n\t\tkvp_update_file(pool);\n\t\treturn 0;\n\t}\n\n\t \n\tif (num_records == (ENTRIES_PER_BLOCK * num_blocks)) {\n\t\t \n\t\trecord = realloc(record, sizeof(struct kvp_record) *\n\t\t\t ENTRIES_PER_BLOCK * (num_blocks + 1));\n\n\t\tif (record == NULL)\n\t\t\treturn 1;\n\t\tkvp_file_info[pool].num_blocks++;\n\n\t}\n\tmemcpy(record[i].value, value, value_size);\n\tmemcpy(record[i].key, key, key_size);\n\tkvp_file_info[pool].records = record;\n\tkvp_file_info[pool].num_records++;\n\tkvp_update_file(pool);\n\treturn 0;\n}\n\nstatic int kvp_get_value(int pool, const __u8 *key, int key_size, __u8 *value,\n\t\t\tint value_size)\n{\n\tint i;\n\tint num_records;\n\tstruct kvp_record *record;\n\n\tif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\n\t\t(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\n\t\treturn 1;\n\n\t \n\tkvp_update_mem_state(pool);\n\n\tnum_records = kvp_file_info[pool].num_records;\n\trecord = kvp_file_info[pool].records;\n\n\tfor (i = 0; i < num_records; i++) {\n\t\tif (memcmp(key, record[i].key, key_size))\n\t\t\tcontinue;\n\t\t \n\t\tmemcpy(value, record[i].value, value_size);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int kvp_pool_enumerate(int pool, int index, __u8 *key, int key_size,\n\t\t\t\t__u8 *value, int value_size)\n{\n\tstruct kvp_record *record;\n\n\t \n\tkvp_update_mem_state(pool);\n\trecord = kvp_file_info[pool].records;\n\n\tif (index >= kvp_file_info[pool].num_records) {\n\t\treturn 1;\n\t}\n\n\tmemcpy(key, record[index].key, key_size);\n\tmemcpy(value, record[index].value, value_size);\n\treturn 0;\n}\n\n\nvoid kvp_get_os_info(void)\n{\n\tFILE\t*file;\n\tchar\t*p, buf[512];\n\n\tuname(&uts_buf);\n\tos_version = uts_buf.release;\n\tos_build = strdup(uts_buf.release);\n\n\tos_name = uts_buf.sysname;\n\tprocessor_arch = uts_buf.machine;\n\n\t \n\tp = strchr(os_version, '-');\n\tif (p)\n\t\t*p = '\\0';\n\n\t \n\tfile = fopen(\"/etc/os-release\", \"r\");\n\tif (file != NULL) {\n\t\twhile (fgets(buf, sizeof(buf), file)) {\n\t\t\tchar *value, *q;\n\n\t\t\t \n\t\t\tif (buf[0] == '#')\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tp = strchr(buf, '=');\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\t*p++ = 0;\n\n\t\t\t \n\t\t\tvalue = p;\n\t\t\tq = p;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == '\\\\') {\n\t\t\t\t\t++p;\n\t\t\t\t\tif (!*p)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*q++ = *p++;\n\t\t\t\t} else if (*p == '\\'' || *p == '\"' ||\n\t\t\t\t\t   *p == '\\n') {\n\t\t\t\t\t++p;\n\t\t\t\t} else {\n\t\t\t\t\t*q++ = *p++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*q = 0;\n\n\t\t\tif (!strcmp(buf, \"NAME\")) {\n\t\t\t\tp = strdup(value);\n\t\t\t\tif (!p)\n\t\t\t\t\tbreak;\n\t\t\t\tos_name = p;\n\t\t\t} else if (!strcmp(buf, \"VERSION_ID\")) {\n\t\t\t\tp = strdup(value);\n\t\t\t\tif (!p)\n\t\t\t\t\tbreak;\n\t\t\t\tos_major = p;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t\treturn;\n\t}\n\n\t \n\tfile = fopen(\"/etc/SuSE-release\", \"r\");\n\tif (file != NULL)\n\t\tgoto kvp_osinfo_found;\n\tfile  = fopen(\"/etc/redhat-release\", \"r\");\n\tif (file != NULL)\n\t\tgoto kvp_osinfo_found;\n\n\t \n\treturn;\n\nkvp_osinfo_found:\n\t \n\tp = fgets(buf, sizeof(buf), file);\n\tif (p) {\n\t\tp = strchr(buf, '\\n');\n\t\tif (p)\n\t\t\t*p = '\\0';\n\t\tp = strdup(buf);\n\t\tif (!p)\n\t\t\tgoto done;\n\t\tos_name = p;\n\n\t\t \n\t\tp = fgets(buf, sizeof(buf), file);\n\t\tif (p) {\n\t\t\tp = strchr(buf, '\\n');\n\t\t\tif (p)\n\t\t\t\t*p = '\\0';\n\t\t\tp = strdup(buf);\n\t\t\tif (!p)\n\t\t\t\tgoto done;\n\t\t\tos_major = p;\n\n\t\t\t \n\t\t\tp = fgets(buf, sizeof(buf), file);\n\t\t\tif (p)  {\n\t\t\t\tp = strchr(buf, '\\n');\n\t\t\t\tif (p)\n\t\t\t\t\t*p = '\\0';\n\t\t\t\tp = strdup(buf);\n\t\t\t\tif (p)\n\t\t\t\t\tos_minor = p;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tfclose(file);\n\treturn;\n}\n\n\n\n \n\nstatic char *kvp_get_if_name(char *guid)\n{\n\tDIR *dir;\n\tstruct dirent *entry;\n\tFILE    *file;\n\tchar    *p, *x;\n\tchar    *if_name = NULL;\n\tchar    buf[256];\n\tchar dev_id[PATH_MAX];\n\n\tdir = opendir(KVP_NET_DIR);\n\tif (dir == NULL)\n\t\treturn NULL;\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\t \n\t\tsnprintf(dev_id, sizeof(dev_id), \"%s%s/device/device_id\",\n\t\t\t KVP_NET_DIR, entry->d_name);\n\n\t\tfile = fopen(dev_id, \"r\");\n\t\tif (file == NULL)\n\t\t\tcontinue;\n\n\t\tp = fgets(buf, sizeof(buf), file);\n\t\tif (p) {\n\t\t\tx = strchr(p, '\\n');\n\t\t\tif (x)\n\t\t\t\t*x = '\\0';\n\n\t\t\tif (!strcmp(p, guid)) {\n\t\t\t\t \n\t\t\t\tif_name = strdup(entry->d_name);\n\t\t\t\tfclose(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t}\n\n\tclosedir(dir);\n\treturn if_name;\n}\n\n \n\nstatic char *kvp_if_name_to_mac(char *if_name)\n{\n\tFILE    *file;\n\tchar    *p, *x;\n\tchar    buf[256];\n\tchar addr_file[PATH_MAX];\n\tunsigned int i;\n\tchar *mac_addr = NULL;\n\n\tsnprintf(addr_file, sizeof(addr_file), \"%s%s%s\", KVP_NET_DIR,\n\t\t if_name, \"/address\");\n\n\tfile = fopen(addr_file, \"r\");\n\tif (file == NULL)\n\t\treturn NULL;\n\n\tp = fgets(buf, sizeof(buf), file);\n\tif (p) {\n\t\tx = strchr(p, '\\n');\n\t\tif (x)\n\t\t\t*x = '\\0';\n\t\tfor (i = 0; i < strlen(p); i++)\n\t\t\tp[i] = toupper(p[i]);\n\t\tmac_addr = strdup(p);\n\t}\n\n\tfclose(file);\n\treturn mac_addr;\n}\n\nstatic void kvp_process_ipconfig_file(char *cmd,\n\t\t\t\t\tchar *config_buf, unsigned int len,\n\t\t\t\t\tint element_size, int offset)\n{\n\tchar buf[256];\n\tchar *p;\n\tchar *x;\n\tFILE *file;\n\n\t \n\tfile = popen(cmd, \"r\");\n\tif (file == NULL)\n\t\treturn;\n\n\tif (offset == 0)\n\t\tmemset(config_buf, 0, len);\n\twhile ((p = fgets(buf, sizeof(buf), file)) != NULL) {\n\t\tif (len < strlen(config_buf) + element_size + 1)\n\t\t\tbreak;\n\n\t\tx = strchr(p, '\\n');\n\t\tif (x)\n\t\t\t*x = '\\0';\n\n\t\tstrcat(config_buf, p);\n\t\tstrcat(config_buf, \";\");\n\t}\n\tpclose(file);\n}\n\nstatic void kvp_get_ipconfig_info(char *if_name,\n\t\t\t\t struct hv_kvp_ipaddr_value *buffer)\n{\n\tchar cmd[512];\n\tchar dhcp_info[128];\n\tchar *p;\n\tFILE *file;\n\n\t \n\tsprintf(cmd, \"%s %s\", \"ip route show dev\", if_name);\n\tstrcat(cmd, \" | awk '/default/ {print $3 }'\");\n\n\t \n\tkvp_process_ipconfig_file(cmd, (char *)buffer->gate_way,\n\t\t\t\t(MAX_GATEWAY_SIZE * 2), INET_ADDRSTRLEN, 0);\n\n\t \n\tsprintf(cmd, \"%s %s\", \"ip -f inet6  route show dev\", if_name);\n\tstrcat(cmd, \" | awk '/default/ {print $3 }'\");\n\n\t \n\tkvp_process_ipconfig_file(cmd, (char *)buffer->gate_way,\n\t\t\t\t(MAX_GATEWAY_SIZE * 2), INET6_ADDRSTRLEN, 1);\n\n\n\t \n\n\tsprintf(cmd, KVP_SCRIPTS_PATH \"%s\",  \"hv_get_dns_info\");\n\n\t \n\tkvp_process_ipconfig_file(cmd, (char *)buffer->dns_addr,\n\t\t\t\t(MAX_IP_ADDR_SIZE * 2), INET_ADDRSTRLEN, 0);\n\n\t \n\n\tsprintf(cmd, KVP_SCRIPTS_PATH \"%s %s\", \"hv_get_dhcp_info\", if_name);\n\n\tfile = popen(cmd, \"r\");\n\tif (file == NULL)\n\t\treturn;\n\n\tp = fgets(dhcp_info, sizeof(dhcp_info), file);\n\tif (p == NULL) {\n\t\tpclose(file);\n\t\treturn;\n\t}\n\n\tif (!strncmp(p, \"Enabled\", 7))\n\t\tbuffer->dhcp_enabled = 1;\n\telse\n\t\tbuffer->dhcp_enabled = 0;\n\n\tpclose(file);\n}\n\n\nstatic unsigned int hweight32(unsigned int *w)\n{\n\tunsigned int res = *w - ((*w >> 1) & 0x55555555);\n\tres = (res & 0x33333333) + ((res >> 2) & 0x33333333);\n\tres = (res + (res >> 4)) & 0x0F0F0F0F;\n\tres = res + (res >> 8);\n\treturn (res + (res >> 16)) & 0x000000FF;\n}\n\nstatic int kvp_process_ip_address(void *addrp,\n\t\t\t\tint family, char *buffer,\n\t\t\t\tint length,  int *offset)\n{\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tint addr_length;\n\tchar tmp[50];\n\tconst char *str;\n\n\tif (family == AF_INET) {\n\t\taddr = addrp;\n\t\tstr = inet_ntop(family, &addr->sin_addr, tmp, 50);\n\t\taddr_length = INET_ADDRSTRLEN;\n\t} else {\n\t\taddr6 = addrp;\n\t\tstr = inet_ntop(family, &addr6->sin6_addr.s6_addr, tmp, 50);\n\t\taddr_length = INET6_ADDRSTRLEN;\n\t}\n\n\tif ((length - *offset) < addr_length + 2)\n\t\treturn HV_E_FAIL;\n\tif (str == NULL) {\n\t\tstrcpy(buffer, \"inet_ntop failed\\n\");\n\t\treturn HV_E_FAIL;\n\t}\n\tif (*offset == 0)\n\t\tstrcpy(buffer, tmp);\n\telse {\n\t\tstrcat(buffer, \";\");\n\t\tstrcat(buffer, tmp);\n\t}\n\n\t*offset += strlen(str) + 1;\n\n\treturn 0;\n}\n\nstatic int\nkvp_get_ip_info(int family, char *if_name, int op,\n\t\t void  *out_buffer, unsigned int length)\n{\n\tstruct ifaddrs *ifap;\n\tstruct ifaddrs *curp;\n\tint offset = 0;\n\tint sn_offset = 0;\n\tint error = 0;\n\tchar *buffer;\n\tstruct hv_kvp_ipaddr_value *ip_buffer = NULL;\n\tchar cidr_mask[5];  \n\tint weight;\n\tint i;\n\tunsigned int *w;\n\tchar *sn_str;\n\tstruct sockaddr_in6 *addr6;\n\n\tif (op == KVP_OP_ENUMERATE) {\n\t\tbuffer = out_buffer;\n\t} else {\n\t\tip_buffer = out_buffer;\n\t\tbuffer = (char *)ip_buffer->ip_addr;\n\t\tip_buffer->addr_family = 0;\n\t}\n\t \n\n\tif (getifaddrs(&ifap)) {\n\t\tstrcpy(buffer, \"getifaddrs failed\\n\");\n\t\treturn HV_E_FAIL;\n\t}\n\n\tcurp = ifap;\n\twhile (curp != NULL) {\n\t\tif (curp->ifa_addr == NULL) {\n\t\t\tcurp = curp->ifa_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((if_name != NULL) &&\n\t\t\t(strncmp(curp->ifa_name, if_name, strlen(if_name)))) {\n\t\t\t \n\t\t\tcurp = curp->ifa_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((((family != 0) &&\n\t\t\t (curp->ifa_addr->sa_family != family))) ||\n\t\t\t (curp->ifa_flags & IFF_LOOPBACK)) {\n\t\t\tcurp = curp->ifa_next;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((curp->ifa_addr->sa_family != AF_INET) &&\n\t\t\t(curp->ifa_addr->sa_family != AF_INET6)) {\n\t\t\tcurp = curp->ifa_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (op == KVP_OP_GET_IP_INFO) {\n\t\t\t \n\t\t\tif (curp->ifa_addr->sa_family == AF_INET) {\n\t\t\t\tip_buffer->addr_family |= ADDR_FAMILY_IPV4;\n\t\t\t\t \n\t\t\t\terror = kvp_process_ip_address(\n\t\t\t\t\t\t\t     curp->ifa_netmask,\n\t\t\t\t\t\t\t     AF_INET,\n\t\t\t\t\t\t\t     (char *)\n\t\t\t\t\t\t\t     ip_buffer->sub_net,\n\t\t\t\t\t\t\t     length,\n\t\t\t\t\t\t\t     &sn_offset);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto gather_ipaddr;\n\t\t\t} else {\n\t\t\t\tip_buffer->addr_family |= ADDR_FAMILY_IPV6;\n\n\t\t\t\t \n\t\t\t\tweight = 0;\n\t\t\t\tsn_str = (char *)ip_buffer->sub_net;\n\t\t\t\taddr6 = (struct sockaddr_in6 *)\n\t\t\t\t\tcurp->ifa_netmask;\n\t\t\t\tw = addr6->sin6_addr.s6_addr32;\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\tweight += hweight32(&w[i]);\n\n\t\t\t\tsprintf(cidr_mask, \"/%d\", weight);\n\t\t\t\tif (length < sn_offset + strlen(cidr_mask) + 1)\n\t\t\t\t\tgoto gather_ipaddr;\n\n\t\t\t\tif (sn_offset == 0)\n\t\t\t\t\tstrcpy(sn_str, cidr_mask);\n\t\t\t\telse {\n\t\t\t\t\tstrcat((char *)ip_buffer->sub_net, \";\");\n\t\t\t\t\tstrcat(sn_str, cidr_mask);\n\t\t\t\t}\n\t\t\t\tsn_offset += strlen(sn_str) + 1;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tkvp_get_ipconfig_info(if_name, ip_buffer);\n\t\t}\n\ngather_ipaddr:\n\t\terror = kvp_process_ip_address(curp->ifa_addr,\n\t\t\t\t\t\tcurp->ifa_addr->sa_family,\n\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\tlength, &offset);\n\t\tif (error)\n\t\t\tgoto getaddr_done;\n\n\t\tcurp = curp->ifa_next;\n\t}\n\ngetaddr_done:\n\tfreeifaddrs(ifap);\n\treturn error;\n}\n\n \nstatic int kvp_mac_to_ip(struct hv_kvp_ipaddr_value *kvp_ip_val)\n{\n\tchar *mac = (char *)kvp_ip_val->adapter_id;\n\tDIR *dir;\n\tstruct dirent *entry;\n\tFILE    *file;\n\tchar    *p, *x;\n\tchar    *if_name = NULL;\n\tchar    buf[256];\n\tchar dev_id[PATH_MAX];\n\tunsigned int i;\n\tint error = HV_E_FAIL;\n\n\tdir = opendir(KVP_NET_DIR);\n\tif (dir == NULL)\n\t\treturn HV_E_FAIL;\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\t \n\t\tsnprintf(dev_id, sizeof(dev_id), \"%s%s/address\", KVP_NET_DIR,\n\t\t\t entry->d_name);\n\n\t\tfile = fopen(dev_id, \"r\");\n\t\tif (file == NULL)\n\t\t\tcontinue;\n\n\t\tp = fgets(buf, sizeof(buf), file);\n\t\tfclose(file);\n\t\tif (!p)\n\t\t\tcontinue;\n\n\t\tx = strchr(p, '\\n');\n\t\tif (x)\n\t\t\t*x = '\\0';\n\n\t\tfor (i = 0; i < strlen(p); i++)\n\t\t\tp[i] = toupper(p[i]);\n\n\t\tif (strcmp(p, mac))\n\t\t\tcontinue;\n\n\t\t \n\t\tif_name = entry->d_name;\n\t\tif (!if_name)\n\t\t\tcontinue;\n\n\t\terror = kvp_get_ip_info(0, if_name, KVP_OP_GET_IP_INFO,\n\t\t\t\t\tkvp_ip_val, MAX_IP_ADDR_SIZE * 2);\n\n\t\tif (!error && strlen((char *)kvp_ip_val->ip_addr))\n\t\t\tbreak;\n\t}\n\n\tclosedir(dir);\n\treturn error;\n}\n\nstatic int expand_ipv6(char *addr, int type)\n{\n\tint ret;\n\tstruct in6_addr v6_addr;\n\n\tret = inet_pton(AF_INET6, addr, &v6_addr);\n\n\tif (ret != 1) {\n\t\tif (type == NETMASK)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tsprintf(addr, \"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:\"\n\t\t\"%02x%02x:%02x%02x:%02x%02x\",\n\t\t(int)v6_addr.s6_addr[0], (int)v6_addr.s6_addr[1],\n\t\t(int)v6_addr.s6_addr[2], (int)v6_addr.s6_addr[3],\n\t\t(int)v6_addr.s6_addr[4], (int)v6_addr.s6_addr[5],\n\t\t(int)v6_addr.s6_addr[6], (int)v6_addr.s6_addr[7],\n\t\t(int)v6_addr.s6_addr[8], (int)v6_addr.s6_addr[9],\n\t\t(int)v6_addr.s6_addr[10], (int)v6_addr.s6_addr[11],\n\t\t(int)v6_addr.s6_addr[12], (int)v6_addr.s6_addr[13],\n\t\t(int)v6_addr.s6_addr[14], (int)v6_addr.s6_addr[15]);\n\n\treturn 1;\n\n}\n\nstatic int is_ipv4(char *addr)\n{\n\tint ret;\n\tstruct in_addr ipv4_addr;\n\n\tret = inet_pton(AF_INET, addr, &ipv4_addr);\n\n\tif (ret == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int parse_ip_val_buffer(char *in_buf, int *offset,\n\t\t\t\tchar *out_buf, int out_len)\n{\n\tchar *x;\n\tchar *start;\n\n\t \n\tstart = in_buf + *offset;\n\n\tx = strchr(start, ';');\n\tif (x)\n\t\t*x = 0;\n\telse\n\t\tx = start + strlen(start);\n\n\tif (strlen(start) != 0) {\n\t\tint i = 0;\n\t\t \n\t\twhile (start[i] == ' ')\n\t\t\ti++;\n\n\t\tif ((x - start) <= out_len) {\n\t\t\tstrcpy(out_buf, (start + i));\n\t\t\t*offset += (x - start) + 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int kvp_write_file(FILE *f, char *s1, char *s2, char *s3)\n{\n\tint ret;\n\n\tret = fprintf(f, \"%s%s%s%s\\n\", s1, s2, \"=\", s3);\n\n\tif (ret < 0)\n\t\treturn HV_E_FAIL;\n\n\treturn 0;\n}\n\n\nstatic int process_ip_string(FILE *f, char *ip_string, int type)\n{\n\tint error = 0;\n\tchar addr[INET6_ADDRSTRLEN];\n\tint i = 0;\n\tint j = 0;\n\tchar str[256];\n\tchar sub_str[13];\n\tint offset = 0;\n\n\tmemset(addr, 0, sizeof(addr));\n\n\twhile (parse_ip_val_buffer(ip_string, &offset, addr,\n\t\t\t\t\t(MAX_IP_ADDR_SIZE * 2))) {\n\n\t\tsub_str[0] = 0;\n\t\tif (is_ipv4(addr)) {\n\t\t\tswitch (type) {\n\t\t\tcase IPADDR:\n\t\t\t\tsnprintf(str, sizeof(str), \"%s\", \"IPADDR\");\n\t\t\t\tbreak;\n\t\t\tcase NETMASK:\n\t\t\t\tsnprintf(str, sizeof(str), \"%s\", \"NETMASK\");\n\t\t\t\tbreak;\n\t\t\tcase GATEWAY:\n\t\t\t\tsnprintf(str, sizeof(str), \"%s\", \"GATEWAY\");\n\t\t\t\tbreak;\n\t\t\tcase DNS:\n\t\t\t\tsnprintf(str, sizeof(str), \"%s\", \"DNS\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type == DNS) {\n\t\t\t\tsnprintf(sub_str, sizeof(sub_str), \"%d\", ++i);\n\t\t\t} else if (type == GATEWAY && i == 0) {\n\t\t\t\t++i;\n\t\t\t} else {\n\t\t\t\tsnprintf(sub_str, sizeof(sub_str), \"%d\", i++);\n\t\t\t}\n\n\n\t\t} else if (expand_ipv6(addr, type)) {\n\t\t\tswitch (type) {\n\t\t\tcase IPADDR:\n\t\t\t\tsnprintf(str, sizeof(str), \"%s\", \"IPV6ADDR\");\n\t\t\t\tbreak;\n\t\t\tcase NETMASK:\n\t\t\t\tsnprintf(str, sizeof(str), \"%s\", \"IPV6NETMASK\");\n\t\t\t\tbreak;\n\t\t\tcase GATEWAY:\n\t\t\t\tsnprintf(str, sizeof(str), \"%s\",\n\t\t\t\t\t\"IPV6_DEFAULTGW\");\n\t\t\t\tbreak;\n\t\t\tcase DNS:\n\t\t\t\tsnprintf(str, sizeof(str), \"%s\",  \"DNS\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type == DNS) {\n\t\t\t\tsnprintf(sub_str, sizeof(sub_str), \"%d\", ++i);\n\t\t\t} else if (j == 0) {\n\t\t\t\t++j;\n\t\t\t} else {\n\t\t\t\tsnprintf(sub_str, sizeof(sub_str), \"_%d\", j++);\n\t\t\t}\n\t\t} else {\n\t\t\treturn  HV_INVALIDARG;\n\t\t}\n\n\t\terror = kvp_write_file(f, str, sub_str, addr);\n\t\tif (error)\n\t\t\treturn error;\n\t\tmemset(addr, 0, sizeof(addr));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int kvp_subnet_to_plen(char *subnet_addr_str)\n{\n\tint plen = 0;\n\tstruct in_addr subnet_addr4;\n\n\t \n\tif (inet_pton(AF_INET, subnet_addr_str, &subnet_addr4) == 1) {\n\t\tuint32_t subnet_mask = ntohl(subnet_addr4.s_addr);\n\n\t\twhile (subnet_mask & 0x80000000) {\n\t\t\tplen++;\n\t\t\tsubnet_mask <<= 1;\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\n\treturn plen;\n}\n\nstatic int process_ip_string_nm(FILE *f, char *ip_string, char *subnet,\n\t\t\t\tint is_ipv6)\n{\n\tchar addr[INET6_ADDRSTRLEN];\n\tchar subnet_addr[INET6_ADDRSTRLEN];\n\tint error, i = 0;\n\tint ip_offset = 0, subnet_offset = 0;\n\tint plen;\n\n\tmemset(addr, 0, sizeof(addr));\n\tmemset(subnet_addr, 0, sizeof(subnet_addr));\n\n\twhile (parse_ip_val_buffer(ip_string, &ip_offset, addr,\n\t\t\t\t   (MAX_IP_ADDR_SIZE * 2)) &&\n\t\t\t\t   parse_ip_val_buffer(subnet,\n\t\t\t\t\t\t       &subnet_offset,\n\t\t\t\t\t\t       subnet_addr,\n\t\t\t\t\t\t       (MAX_IP_ADDR_SIZE *\n\t\t\t\t\t\t\t2))) {\n\t\tif (!is_ipv6)\n\t\t\tplen = kvp_subnet_to_plen((char *)subnet_addr);\n\t\telse\n\t\t\tplen = atoi(subnet_addr);\n\n\t\tif (plen < 0)\n\t\t\treturn plen;\n\n\t\terror = fprintf(f, \"address%d=%s/%d\\n\", ++i, (char *)addr,\n\t\t\t\tplen);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tmemset(addr, 0, sizeof(addr));\n\t\tmemset(subnet_addr, 0, sizeof(subnet_addr));\n\t}\n\n\treturn 0;\n}\n\nstatic int kvp_set_ip_info(char *if_name, struct hv_kvp_ipaddr_value *new_val)\n{\n\tint error = 0;\n\tchar if_filename[PATH_MAX];\n\tchar nm_filename[PATH_MAX];\n\tFILE *ifcfg_file, *nmfile;\n\tchar cmd[PATH_MAX];\n\tint is_ipv6 = 0;\n\tchar *mac_addr;\n\tint str_len;\n\n\t \n\n\t \n\tsnprintf(if_filename, sizeof(if_filename), \"%s%s%s\", KVP_CONFIG_LOC,\n\t\t \"/ifcfg-\", if_name);\n\n\tifcfg_file = fopen(if_filename, \"w\");\n\n\tif (!ifcfg_file) {\n\t\tsyslog(LOG_ERR, \"Failed to open config file; error: %d %s\",\n\t\t       errno, strerror(errno));\n\t\treturn HV_E_FAIL;\n\t}\n\n\tsnprintf(nm_filename, sizeof(nm_filename), \"%s%s%s%s\", KVP_CONFIG_LOC,\n\t\t \"/\", if_name, \".nmconnection\");\n\n\tnmfile = fopen(nm_filename, \"w\");\n\n\tif (!nmfile) {\n\t\tsyslog(LOG_ERR, \"Failed to open config file; error: %d %s\",\n\t\t       errno, strerror(errno));\n\t\tfclose(ifcfg_file);\n\t\treturn HV_E_FAIL;\n\t}\n\n\t \n\n\tmac_addr = kvp_if_name_to_mac(if_name);\n\tif (mac_addr == NULL) {\n\t\terror = HV_E_FAIL;\n\t\tgoto setval_error;\n\t}\n\n\terror = kvp_write_file(ifcfg_file, \"HWADDR\", \"\", mac_addr);\n\tif (error < 0)\n\t\tgoto setmac_error;\n\n\terror = kvp_write_file(ifcfg_file, \"DEVICE\", \"\", if_name);\n\tif (error < 0)\n\t\tgoto setmac_error;\n\n\terror = fprintf(nmfile, \"\\n[connection]\\n\");\n\tif (error < 0)\n\t\tgoto setmac_error;\n\n\terror = kvp_write_file(nmfile, \"interface-name\", \"\", if_name);\n\tif (error)\n\t\tgoto setmac_error;\n\n\terror = fprintf(nmfile, \"\\n[ethernet]\\n\");\n\tif (error < 0)\n\t\tgoto setmac_error;\n\n\terror = kvp_write_file(nmfile, \"mac-address\", \"\", mac_addr);\n\tif (error)\n\t\tgoto setmac_error;\n\n\tfree(mac_addr);\n\n\t \n\n\t \n\tif (new_val->dhcp_enabled) {\n\t\terror = kvp_write_file(ifcfg_file, \"BOOTPROTO\", \"\", \"dhcp\");\n\t\tif (error)\n\t\t\tgoto setval_error;\n\t} else {\n\t\terror = kvp_write_file(ifcfg_file, \"BOOTPROTO\", \"\", \"none\");\n\t\tif (error)\n\t\t\tgoto setval_error;\n\t}\n\n\terror = process_ip_string(ifcfg_file, (char *)new_val->ip_addr,\n\t\t\t\t  IPADDR);\n\tif (error)\n\t\tgoto setval_error;\n\n\terror = process_ip_string(ifcfg_file, (char *)new_val->sub_net,\n\t\t\t\t  NETMASK);\n\tif (error)\n\t\tgoto setval_error;\n\n\terror = process_ip_string(ifcfg_file, (char *)new_val->gate_way,\n\t\t\t\t  GATEWAY);\n\tif (error)\n\t\tgoto setval_error;\n\n\terror = process_ip_string(ifcfg_file, (char *)new_val->dns_addr, DNS);\n\tif (error)\n\t\tgoto setval_error;\n\n\tif (new_val->addr_family & ADDR_FAMILY_IPV6) {\n\t\terror = fprintf(nmfile, \"\\n[ipv6]\\n\");\n\t\tif (error < 0)\n\t\t\tgoto setval_error;\n\t\tis_ipv6 = 1;\n\t} else {\n\t\terror = fprintf(nmfile, \"\\n[ipv4]\\n\");\n\t\tif (error < 0)\n\t\t\tgoto setval_error;\n\t}\n\n\t \n\n\tif (new_val->dhcp_enabled) {\n\t\terror = kvp_write_file(nmfile, \"method\", \"\", \"auto\");\n\t\tif (error < 0)\n\t\t\tgoto setval_error;\n\t} else {\n\t\terror = kvp_write_file(nmfile, \"method\", \"\", \"manual\");\n\t\tif (error < 0)\n\t\t\tgoto setval_error;\n\t}\n\n\t \n\terror = process_ip_string_nm(nmfile, (char *)new_val->ip_addr,\n\t\t\t\t     (char *)new_val->sub_net, is_ipv6);\n\tif (error < 0)\n\t\tgoto setval_error;\n\n\t \n\tif (is_ipv6 != is_ipv4((char *)new_val->gate_way)) {\n\t\terror = fprintf(nmfile, \"gateway=%s\\n\", (char *)new_val->gate_way);\n\t\tif (error < 0)\n\t\t\tgoto setval_error;\n\t}\n\n\tif (is_ipv6 != is_ipv4((char *)new_val->dns_addr)) {\n\t\terror = fprintf(nmfile, \"dns=%s\\n\", (char *)new_val->dns_addr);\n\t\tif (error < 0)\n\t\t\tgoto setval_error;\n\t}\n\tfclose(nmfile);\n\tfclose(ifcfg_file);\n\n\t \n\n\tstr_len = snprintf(cmd, sizeof(cmd), KVP_SCRIPTS_PATH \"%s %s %s\",\n\t\t\t   \"hv_set_ifconfig\", if_filename, nm_filename);\n\t \n\tif (str_len <= 0 || (unsigned int)str_len >= sizeof(cmd)) {\n\t\tsyslog(LOG_ERR, \"Cmd '%s' (len=%d) may be too long\",\n\t\t       cmd, str_len);\n\t\treturn HV_E_FAIL;\n\t}\n\n\tif (system(cmd)) {\n\t\tsyslog(LOG_ERR, \"Failed to execute cmd '%s'; error: %d %s\",\n\t\t       cmd, errno, strerror(errno));\n\t\treturn HV_E_FAIL;\n\t}\n\treturn 0;\nsetmac_error:\n\tfree(mac_addr);\nsetval_error:\n\tsyslog(LOG_ERR, \"Failed to write config file\");\n\tfclose(ifcfg_file);\n\tfclose(nmfile);\n\treturn error;\n}\n\n\nstatic void\nkvp_get_domain_name(char *buffer, int length)\n{\n\tstruct addrinfo\thints, *info ;\n\tint error = 0;\n\n\tgethostname(buffer, length);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_INET;  \n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_CANONNAME;\n\n\terror = getaddrinfo(buffer, NULL, &hints, &info);\n\tif (error != 0) {\n\t\tsnprintf(buffer, length, \"getaddrinfo failed: 0x%x %s\",\n\t\t\terror, gai_strerror(error));\n\t\treturn;\n\t}\n\tsnprintf(buffer, length, \"%s\", info->ai_canonname);\n\tfreeaddrinfo(info);\n}\n\nvoid print_usage(char *argv[])\n{\n\tfprintf(stderr, \"Usage: %s [options]\\n\"\n\t\t\"Options are:\\n\"\n\t\t\"  -n, --no-daemon        stay in foreground, don't daemonize\\n\"\n\t\t\"  -h, --help             print this help\\n\", argv[0]);\n}\n\nint main(int argc, char *argv[])\n{\n\tint kvp_fd = -1, len;\n\tint error;\n\tstruct pollfd pfd;\n\tchar    *p;\n\tstruct hv_kvp_msg hv_msg[1];\n\tchar\t*key_value;\n\tchar\t*key_name;\n\tint\top;\n\tint\tpool;\n\tchar\t*if_name;\n\tstruct hv_kvp_ipaddr_value *kvp_ip_val;\n\tint daemonize = 1, long_index = 0, opt;\n\n\tstatic struct option long_options[] = {\n\t\t{\"help\",\tno_argument,\t   0,  'h' },\n\t\t{\"no-daemon\",\tno_argument,\t   0,  'n' },\n\t\t{0,\t\t0,\t\t   0,  0   }\n\t};\n\n\twhile ((opt = getopt_long(argc, argv, \"hn\", long_options,\n\t\t\t\t  &long_index)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'n':\n\t\t\tdaemonize = 0;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tprint_usage(argv);\n\t\t\texit(0);\n\t\tdefault:\n\t\t\tprint_usage(argv);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (daemonize && daemon(1, 0))\n\t\treturn 1;\n\n\topenlog(\"KVP\", 0, LOG_USER);\n\tsyslog(LOG_INFO, \"KVP starting; pid is:%d\", getpid());\n\n\t \n\tkvp_get_os_info();\n\t \n\tkvp_get_domain_name(full_domain_name, sizeof(full_domain_name));\n\n\tif (kvp_file_init()) {\n\t\tsyslog(LOG_ERR, \"Failed to initialize the pools\");\n\t\texit(EXIT_FAILURE);\n\t}\n\nreopen_kvp_fd:\n\tif (kvp_fd != -1)\n\t\tclose(kvp_fd);\n\tin_hand_shake = 1;\n\tkvp_fd = open(\"/dev/vmbus/hv_kvp\", O_RDWR | O_CLOEXEC);\n\n\tif (kvp_fd < 0) {\n\t\tsyslog(LOG_ERR, \"open /dev/vmbus/hv_kvp failed; error: %d %s\",\n\t\t       errno, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\thv_msg->kvp_hdr.operation = KVP_OP_REGISTER1;\n\tlen = write(kvp_fd, hv_msg, sizeof(struct hv_kvp_msg));\n\tif (len != sizeof(struct hv_kvp_msg)) {\n\t\tsyslog(LOG_ERR, \"registration to kernel failed; error: %d %s\",\n\t\t       errno, strerror(errno));\n\t\tclose(kvp_fd);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tpfd.fd = kvp_fd;\n\n\twhile (1) {\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\n\t\tif (poll(&pfd, 1, -1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"poll failed; error: %d %s\", errno, strerror(errno));\n\t\t\tif (errno == EINVAL) {\n\t\t\t\tclose(kvp_fd);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlen = read(kvp_fd, hv_msg, sizeof(struct hv_kvp_msg));\n\n\t\tif (len != sizeof(struct hv_kvp_msg)) {\n\t\t\tsyslog(LOG_ERR, \"read failed; error:%d %s\",\n\t\t\t       errno, strerror(errno));\n\t\t\tgoto reopen_kvp_fd;\n\t\t}\n\n\t\t \n\t\top = hv_msg->kvp_hdr.operation;\n\t\tpool = hv_msg->kvp_hdr.pool;\n\t\thv_msg->error = HV_S_OK;\n\n\t\tif ((in_hand_shake) && (op == KVP_OP_REGISTER1)) {\n\t\t\t \n\t\t\tin_hand_shake = 0;\n\t\t\tp = (char *)hv_msg->body.kvp_register.version;\n\t\t\tlic_version = malloc(strlen(p) + 1);\n\t\t\tif (lic_version) {\n\t\t\t\tstrcpy(lic_version, p);\n\t\t\t\tsyslog(LOG_INFO, \"KVP LIC Version: %s\",\n\t\t\t\t       lic_version);\n\t\t\t} else {\n\t\t\t\tsyslog(LOG_ERR, \"malloc failed\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (op) {\n\t\tcase KVP_OP_GET_IP_INFO:\n\t\t\tkvp_ip_val = &hv_msg->body.kvp_ip_val;\n\n\t\t\terror = kvp_mac_to_ip(kvp_ip_val);\n\n\t\t\tif (error)\n\t\t\t\thv_msg->error = error;\n\n\t\t\tbreak;\n\n\t\tcase KVP_OP_SET_IP_INFO:\n\t\t\tkvp_ip_val = &hv_msg->body.kvp_ip_val;\n\t\t\tif_name = kvp_get_if_name(\n\t\t\t\t\t(char *)kvp_ip_val->adapter_id);\n\t\t\tif (if_name == NULL) {\n\t\t\t\t \n\t\t\t\thv_msg->error = HV_GUID_NOTFOUND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terror = kvp_set_ip_info(if_name, kvp_ip_val);\n\t\t\tif (error)\n\t\t\t\thv_msg->error = error;\n\n\t\t\tfree(if_name);\n\t\t\tbreak;\n\n\t\tcase KVP_OP_SET:\n\t\t\tif (kvp_key_add_or_modify(pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tbreak;\n\n\t\tcase KVP_OP_GET:\n\t\t\tif (kvp_get_value(pool,\n\t\t\t\t\thv_msg->body.kvp_set.data.key,\n\t\t\t\t\thv_msg->body.kvp_set.data.key_size,\n\t\t\t\t\thv_msg->body.kvp_set.data.value,\n\t\t\t\t\thv_msg->body.kvp_set.data.value_size))\n\t\t\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tbreak;\n\n\t\tcase KVP_OP_DELETE:\n\t\t\tif (kvp_key_delete(pool,\n\t\t\t\t\thv_msg->body.kvp_delete.key,\n\t\t\t\t\thv_msg->body.kvp_delete.key_size))\n\t\t\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (op != KVP_OP_ENUMERATE)\n\t\t\tgoto kvp_done;\n\n\t\t \n\t\tif (pool != KVP_POOL_AUTO) {\n\t\t\tif (kvp_pool_enumerate(pool,\n\t\t\t\t\thv_msg->body.kvp_enum_data.index,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.key,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE,\n\t\t\t\t\thv_msg->body.kvp_enum_data.data.value,\n\t\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE))\n\t\t\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tgoto kvp_done;\n\t\t}\n\n\t\tkey_name = (char *)hv_msg->body.kvp_enum_data.data.key;\n\t\tkey_value = (char *)hv_msg->body.kvp_enum_data.data.value;\n\n\t\tswitch (hv_msg->body.kvp_enum_data.index) {\n\t\tcase FullyQualifiedDomainName:\n\t\t\tstrcpy(key_value, full_domain_name);\n\t\t\tstrcpy(key_name, \"FullyQualifiedDomainName\");\n\t\t\tbreak;\n\t\tcase IntegrationServicesVersion:\n\t\t\tstrcpy(key_name, \"IntegrationServicesVersion\");\n\t\t\tstrcpy(key_value, lic_version);\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv4:\n\t\t\tkvp_get_ip_info(AF_INET, NULL, KVP_OP_ENUMERATE,\n\t\t\t\tkey_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv4\");\n\t\t\tbreak;\n\t\tcase NetworkAddressIPv6:\n\t\t\tkvp_get_ip_info(AF_INET6, NULL, KVP_OP_ENUMERATE,\n\t\t\t\tkey_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);\n\t\t\tstrcpy(key_name, \"NetworkAddressIPv6\");\n\t\t\tbreak;\n\t\tcase OSBuildNumber:\n\t\t\tstrcpy(key_value, os_build);\n\t\t\tstrcpy(key_name, \"OSBuildNumber\");\n\t\t\tbreak;\n\t\tcase OSName:\n\t\t\tstrcpy(key_value, os_name);\n\t\t\tstrcpy(key_name, \"OSName\");\n\t\t\tbreak;\n\t\tcase OSMajorVersion:\n\t\t\tstrcpy(key_value, os_major);\n\t\t\tstrcpy(key_name, \"OSMajorVersion\");\n\t\t\tbreak;\n\t\tcase OSMinorVersion:\n\t\t\tstrcpy(key_value, os_minor);\n\t\t\tstrcpy(key_name, \"OSMinorVersion\");\n\t\t\tbreak;\n\t\tcase OSVersion:\n\t\t\tstrcpy(key_value, os_version);\n\t\t\tstrcpy(key_name, \"OSVersion\");\n\t\t\tbreak;\n\t\tcase ProcessorArchitecture:\n\t\t\tstrcpy(key_value, processor_arch);\n\t\t\tstrcpy(key_name, \"ProcessorArchitecture\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thv_msg->error = HV_S_CONT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \nkvp_done:\n\t\tlen = write(kvp_fd, hv_msg, sizeof(struct hv_kvp_msg));\n\t\tif (len != sizeof(struct hv_kvp_msg)) {\n\t\t\tsyslog(LOG_ERR, \"write failed; error: %d %s\", errno,\n\t\t\t       strerror(errno));\n\t\t\tgoto reopen_kvp_fd;\n\t\t}\n\t}\n\n\tclose(kvp_fd);\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}