{
  "module_name": "socket.h",
  "hash_id": "e43b3f2b8940ea9c5cac80b99f2d80e005e676efb14c13a4666b2140893afd82",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/trace/beauty/include/linux/socket.h",
  "human_readable_source": " \n#ifndef _LINUX_SOCKET_H\n#define _LINUX_SOCKET_H\n\n\n#include <asm/socket.h>\t\t\t \n#include <linux/sockios.h>\t\t \n#include <linux/uio.h>\t\t\t \n#include <linux/types.h>\t\t \n#include <linux/compiler.h>\t\t \n#include <uapi/linux/socket.h>\n\nstruct file;\nstruct pid;\nstruct cred;\nstruct socket;\nstruct sock;\nstruct sk_buff;\n\n#define __sockaddr_check_size(size)\t\\\n\tBUILD_BUG_ON(((size) > sizeof(struct __kernel_sockaddr_storage)))\n\n#ifdef CONFIG_PROC_FS\nstruct seq_file;\nextern void socket_seq_show(struct seq_file *seq);\n#endif\n\ntypedef __kernel_sa_family_t\tsa_family_t;\n\n \n\nstruct sockaddr {\n\tsa_family_t\tsa_family;\t \n\tunion {\n\t\tchar sa_data_min[14];\t\t \n\t\tDECLARE_FLEX_ARRAY(char, sa_data);\n\t};\n};\n\nstruct linger {\n\tint\t\tl_onoff;\t \n\tint\t\tl_linger;\t \n};\n\n#define sockaddr_storage __kernel_sockaddr_storage\n\n \n\nstruct msghdr {\n\tvoid\t\t*msg_name;\t \n\tint\t\tmsg_namelen;\t \n\n\tint\t\tmsg_inq;\t \n\n\tstruct iov_iter\tmsg_iter;\t \n\n\t \n\tunion {\n\t\tvoid\t\t*msg_control;\n\t\tvoid __user\t*msg_control_user;\n\t};\n\tbool\t\tmsg_control_is_user : 1;\n\tbool\t\tmsg_get_inq : 1; \n\tunsigned int\tmsg_flags;\t \n\t__kernel_size_t\tmsg_controllen;\t \n\tstruct kiocb\t*msg_iocb;\t \n\tstruct ubuf_info *msg_ubuf;\n\tint (*sg_from_iter)(struct sock *sk, struct sk_buff *skb,\n\t\t\t    struct iov_iter *from, size_t length);\n};\n\nstruct user_msghdr {\n\tvoid\t\t__user *msg_name;\t \n\tint\t\tmsg_namelen;\t\t \n\tstruct iovec\t__user *msg_iov;\t \n\t__kernel_size_t\tmsg_iovlen;\t\t \n\tvoid\t\t__user *msg_control;\t \n\t__kernel_size_t\tmsg_controllen;\t\t \n\tunsigned int\tmsg_flags;\t\t \n};\n\n \nstruct mmsghdr {\n\tstruct user_msghdr  msg_hdr;\n\tunsigned int        msg_len;\n};\n\n \n\nstruct cmsghdr {\n\t__kernel_size_t\tcmsg_len;\t \n        int\t\tcmsg_level;\t \n        int\t\tcmsg_type;\t \n};\n\n \n\n#define __CMSG_NXTHDR(ctl, len, cmsg) __cmsg_nxthdr((ctl),(len),(cmsg))\n#define CMSG_NXTHDR(mhdr, cmsg) cmsg_nxthdr((mhdr), (cmsg))\n\n#define CMSG_ALIGN(len) ( ((len)+sizeof(long)-1) & ~(sizeof(long)-1) )\n\n#define CMSG_DATA(cmsg) \\\n\t((void *)(cmsg) + sizeof(struct cmsghdr))\n#define CMSG_USER_DATA(cmsg) \\\n\t((void __user *)(cmsg) + sizeof(struct cmsghdr))\n#define CMSG_SPACE(len) (sizeof(struct cmsghdr) + CMSG_ALIGN(len))\n#define CMSG_LEN(len) (sizeof(struct cmsghdr) + (len))\n\n#define __CMSG_FIRSTHDR(ctl,len) ((len) >= sizeof(struct cmsghdr) ? \\\n\t\t\t\t  (struct cmsghdr *)(ctl) : \\\n\t\t\t\t  (struct cmsghdr *)NULL)\n#define CMSG_FIRSTHDR(msg)\t__CMSG_FIRSTHDR((msg)->msg_control, (msg)->msg_controllen)\n#define CMSG_OK(mhdr, cmsg) ((cmsg)->cmsg_len >= sizeof(struct cmsghdr) && \\\n\t\t\t     (cmsg)->cmsg_len <= (unsigned long) \\\n\t\t\t     ((mhdr)->msg_controllen - \\\n\t\t\t      ((char *)(cmsg) - (char *)(mhdr)->msg_control)))\n#define for_each_cmsghdr(cmsg, msg) \\\n\tfor (cmsg = CMSG_FIRSTHDR(msg); \\\n\t     cmsg; \\\n\t     cmsg = CMSG_NXTHDR(msg, cmsg))\n\n \n\nstatic inline struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size,\n\t\t\t\t\t       struct cmsghdr *__cmsg)\n{\n\tstruct cmsghdr * __ptr;\n\n\t__ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) +  CMSG_ALIGN(__cmsg->cmsg_len));\n\tif ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)\n\t\treturn (struct cmsghdr *)0;\n\n\treturn __ptr;\n}\n\nstatic inline struct cmsghdr * cmsg_nxthdr (struct msghdr *__msg, struct cmsghdr *__cmsg)\n{\n\treturn __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);\n}\n\nstatic inline size_t msg_data_left(struct msghdr *msg)\n{\n\treturn iov_iter_count(&msg->msg_iter);\n}\n\n \n\n#define\tSCM_RIGHTS\t0x01\t\t \n#define SCM_CREDENTIALS 0x02\t\t \n#define SCM_SECURITY\t0x03\t\t \n#define SCM_PIDFD\t0x04\t\t \n\nstruct ucred {\n\t__u32\tpid;\n\t__u32\tuid;\n\t__u32\tgid;\n};\n\n \n#define AF_UNSPEC\t0\n#define AF_UNIX\t\t1\t \n#define AF_LOCAL\t1\t \n#define AF_INET\t\t2\t \n#define AF_AX25\t\t3\t \n#define AF_IPX\t\t4\t \n#define AF_APPLETALK\t5\t \n#define AF_NETROM\t6\t \n#define AF_BRIDGE\t7\t \n#define AF_ATMPVC\t8\t \n#define AF_X25\t\t9\t \n#define AF_INET6\t10\t \n#define AF_ROSE\t\t11\t \n#define AF_DECnet\t12\t \n#define AF_NETBEUI\t13\t \n#define AF_SECURITY\t14\t \n#define AF_KEY\t\t15       \n#define AF_NETLINK\t16\n#define AF_ROUTE\tAF_NETLINK  \n#define AF_PACKET\t17\t \n#define AF_ASH\t\t18\t \n#define AF_ECONET\t19\t \n#define AF_ATMSVC\t20\t \n#define AF_RDS\t\t21\t \n#define AF_SNA\t\t22\t \n#define AF_IRDA\t\t23\t \n#define AF_PPPOX\t24\t \n#define AF_WANPIPE\t25\t \n#define AF_LLC\t\t26\t \n#define AF_IB\t\t27\t \n#define AF_MPLS\t\t28\t \n#define AF_CAN\t\t29\t \n#define AF_TIPC\t\t30\t \n#define AF_BLUETOOTH\t31\t \n#define AF_IUCV\t\t32\t \n#define AF_RXRPC\t33\t \n#define AF_ISDN\t\t34\t \n#define AF_PHONET\t35\t \n#define AF_IEEE802154\t36\t \n#define AF_CAIF\t\t37\t \n#define AF_ALG\t\t38\t \n#define AF_NFC\t\t39\t \n#define AF_VSOCK\t40\t \n#define AF_KCM\t\t41\t \n#define AF_QIPCRTR\t42\t \n#define AF_SMC\t\t43\t \n#define AF_XDP\t\t44\t \n#define AF_MCTP\t\t45\t \n\n#define AF_MAX\t\t46\t \n\n \n#define PF_UNSPEC\tAF_UNSPEC\n#define PF_UNIX\t\tAF_UNIX\n#define PF_LOCAL\tAF_LOCAL\n#define PF_INET\t\tAF_INET\n#define PF_AX25\t\tAF_AX25\n#define PF_IPX\t\tAF_IPX\n#define PF_APPLETALK\tAF_APPLETALK\n#define\tPF_NETROM\tAF_NETROM\n#define PF_BRIDGE\tAF_BRIDGE\n#define PF_ATMPVC\tAF_ATMPVC\n#define PF_X25\t\tAF_X25\n#define PF_INET6\tAF_INET6\n#define PF_ROSE\t\tAF_ROSE\n#define PF_DECnet\tAF_DECnet\n#define PF_NETBEUI\tAF_NETBEUI\n#define PF_SECURITY\tAF_SECURITY\n#define PF_KEY\t\tAF_KEY\n#define PF_NETLINK\tAF_NETLINK\n#define PF_ROUTE\tAF_ROUTE\n#define PF_PACKET\tAF_PACKET\n#define PF_ASH\t\tAF_ASH\n#define PF_ECONET\tAF_ECONET\n#define PF_ATMSVC\tAF_ATMSVC\n#define PF_RDS\t\tAF_RDS\n#define PF_SNA\t\tAF_SNA\n#define PF_IRDA\t\tAF_IRDA\n#define PF_PPPOX\tAF_PPPOX\n#define PF_WANPIPE\tAF_WANPIPE\n#define PF_LLC\t\tAF_LLC\n#define PF_IB\t\tAF_IB\n#define PF_MPLS\t\tAF_MPLS\n#define PF_CAN\t\tAF_CAN\n#define PF_TIPC\t\tAF_TIPC\n#define PF_BLUETOOTH\tAF_BLUETOOTH\n#define PF_IUCV\t\tAF_IUCV\n#define PF_RXRPC\tAF_RXRPC\n#define PF_ISDN\t\tAF_ISDN\n#define PF_PHONET\tAF_PHONET\n#define PF_IEEE802154\tAF_IEEE802154\n#define PF_CAIF\t\tAF_CAIF\n#define PF_ALG\t\tAF_ALG\n#define PF_NFC\t\tAF_NFC\n#define PF_VSOCK\tAF_VSOCK\n#define PF_KCM\t\tAF_KCM\n#define PF_QIPCRTR\tAF_QIPCRTR\n#define PF_SMC\t\tAF_SMC\n#define PF_XDP\t\tAF_XDP\n#define PF_MCTP\t\tAF_MCTP\n#define PF_MAX\t\tAF_MAX\n\n \n#define SOMAXCONN\t4096\n\n \n\n#define MSG_OOB\t\t1\n#define MSG_PEEK\t2\n#define MSG_DONTROUTE\t4\n#define MSG_TRYHARD     4        \n#define MSG_CTRUNC\t8\n#define MSG_PROBE\t0x10\t \n#define MSG_TRUNC\t0x20\n#define MSG_DONTWAIT\t0x40\t \n#define MSG_EOR         0x80\t \n#define MSG_WAITALL\t0x100\t \n#define MSG_FIN         0x200\n#define MSG_SYN\t\t0x400\n#define MSG_CONFIRM\t0x800\t \n#define MSG_RST\t\t0x1000\n#define MSG_ERRQUEUE\t0x2000\t \n#define MSG_NOSIGNAL\t0x4000\t \n#define MSG_MORE\t0x8000\t \n#define MSG_WAITFORONE\t0x10000\t \n#define MSG_SENDPAGE_NOPOLICY 0x10000  \n#define MSG_BATCH\t0x40000  \n#define MSG_EOF         MSG_FIN\n#define MSG_NO_SHARED_FRAGS 0x80000  \n#define MSG_SENDPAGE_DECRYPTED\t0x100000  \n\n#define MSG_ZEROCOPY\t0x4000000\t \n#define MSG_SPLICE_PAGES 0x8000000\t \n#define MSG_FASTOPEN\t0x20000000\t \n#define MSG_CMSG_CLOEXEC 0x40000000\t \n#if defined(CONFIG_COMPAT)\n#define MSG_CMSG_COMPAT\t0x80000000\t \n#else\n#define MSG_CMSG_COMPAT\t0\t\t \n#endif\n\n \n#define MSG_INTERNAL_SENDMSG_FLAGS \\\n\t(MSG_SPLICE_PAGES | MSG_SENDPAGE_NOPOLICY | MSG_SENDPAGE_DECRYPTED)\n\n \n#define SOL_IP\t\t0\n \n#define SOL_TCP\t\t6\n#define SOL_UDP\t\t17\n#define SOL_IPV6\t41\n#define SOL_ICMPV6\t58\n#define SOL_SCTP\t132\n#define SOL_UDPLITE\t136      \n#define SOL_RAW\t\t255\n#define SOL_IPX\t\t256\n#define SOL_AX25\t257\n#define SOL_ATALK\t258\n#define SOL_NETROM\t259\n#define SOL_ROSE\t260\n#define SOL_DECNET\t261\n#define\tSOL_X25\t\t262\n#define SOL_PACKET\t263\n#define SOL_ATM\t\t264\t \n#define SOL_AAL\t\t265\t \n#define SOL_IRDA        266\n#define SOL_NETBEUI\t267\n#define SOL_LLC\t\t268\n#define SOL_DCCP\t269\n#define SOL_NETLINK\t270\n#define SOL_TIPC\t271\n#define SOL_RXRPC\t272\n#define SOL_PPPOL2TP\t273\n#define SOL_BLUETOOTH\t274\n#define SOL_PNPIPE\t275\n#define SOL_RDS\t\t276\n#define SOL_IUCV\t277\n#define SOL_CAIF\t278\n#define SOL_ALG\t\t279\n#define SOL_NFC\t\t280\n#define SOL_KCM\t\t281\n#define SOL_TLS\t\t282\n#define SOL_XDP\t\t283\n#define SOL_MPTCP\t284\n#define SOL_MCTP\t285\n#define SOL_SMC\t\t286\n\n \n#define IPX_TYPE\t1\n\nextern int move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr_storage *kaddr);\nextern int put_cmsg(struct msghdr*, int level, int type, int len, void *data);\n\nstruct timespec64;\nstruct __kernel_timespec;\nstruct old_timespec32;\n\nstruct scm_timestamping_internal {\n\tstruct timespec64 ts[3];\n};\n\nextern void put_cmsg_scm_timestamping64(struct msghdr *msg, struct scm_timestamping_internal *tss);\nextern void put_cmsg_scm_timestamping(struct msghdr *msg, struct scm_timestamping_internal *tss);\n\n \nextern long __sys_recvmsg(int fd, struct user_msghdr __user *msg,\n\t\t\t  unsigned int flags, bool forbid_cmsg_compat);\nextern long __sys_sendmsg(int fd, struct user_msghdr __user *msg,\n\t\t\t  unsigned int flags, bool forbid_cmsg_compat);\nextern int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg,\n\t\t\t  unsigned int vlen, unsigned int flags,\n\t\t\t  struct __kernel_timespec __user *timeout,\n\t\t\t  struct old_timespec32 __user *timeout32);\nextern int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg,\n\t\t\t  unsigned int vlen, unsigned int flags,\n\t\t\t  bool forbid_cmsg_compat);\nextern long __sys_sendmsg_sock(struct socket *sock, struct msghdr *msg,\n\t\t\t       unsigned int flags);\nextern long __sys_recvmsg_sock(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct user_msghdr __user *umsg,\n\t\t\t       struct sockaddr __user *uaddr,\n\t\t\t       unsigned int flags);\nextern int sendmsg_copy_msghdr(struct msghdr *msg,\n\t\t\t       struct user_msghdr __user *umsg, unsigned flags,\n\t\t\t       struct iovec **iov);\nextern int recvmsg_copy_msghdr(struct msghdr *msg,\n\t\t\t       struct user_msghdr __user *umsg, unsigned flags,\n\t\t\t       struct sockaddr __user **uaddr,\n\t\t\t       struct iovec **iov);\nextern int __copy_msghdr(struct msghdr *kmsg,\n\t\t\t struct user_msghdr *umsg,\n\t\t\t struct sockaddr __user **save_addr);\n\n \nextern int __sys_recvfrom(int fd, void __user *ubuf, size_t size,\n\t\t\t  unsigned int flags, struct sockaddr __user *addr,\n\t\t\t  int __user *addr_len);\nextern int __sys_sendto(int fd, void __user *buff, size_t len,\n\t\t\tunsigned int flags, struct sockaddr __user *addr,\n\t\t\tint addr_len);\nextern struct file *do_accept(struct file *file, unsigned file_flags,\n\t\t\t      struct sockaddr __user *upeer_sockaddr,\n\t\t\t      int __user *upeer_addrlen, int flags);\nextern int __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr,\n\t\t\t int __user *upeer_addrlen, int flags);\nextern int __sys_socket(int family, int type, int protocol);\nextern struct file *__sys_socket_file(int family, int type, int protocol);\nextern int __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen);\nextern int __sys_connect_file(struct file *file, struct sockaddr_storage *addr,\n\t\t\t      int addrlen, int file_flags);\nextern int __sys_connect(int fd, struct sockaddr __user *uservaddr,\n\t\t\t int addrlen);\nextern int __sys_listen(int fd, int backlog);\nextern int __sys_getsockname(int fd, struct sockaddr __user *usockaddr,\n\t\t\t     int __user *usockaddr_len);\nextern int __sys_getpeername(int fd, struct sockaddr __user *usockaddr,\n\t\t\t     int __user *usockaddr_len);\nextern int __sys_socketpair(int family, int type, int protocol,\n\t\t\t    int __user *usockvec);\nextern int __sys_shutdown_sock(struct socket *sock, int how);\nextern int __sys_shutdown(int fd, int how);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}