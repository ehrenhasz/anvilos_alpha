{
  "module_name": "dlfilter-show-cycles.c",
  "hash_id": "ba88ae847cac96b0950ac92c3af1e5f39b95db00eb0223596d1a2de41dfaf764",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/dlfilters/dlfilter-show-cycles.c",
  "human_readable_source": "\n \n#include <perf/perf_dlfilter.h>\n#include <string.h>\n#include <stdio.h>\n\n#define MAX_CPU 4096\n\nenum {\n\tINSTR_CYC,\n\tBRNCH_CYC,\n\tOTHER_CYC,\n\tMAX_ENTRY\n};\n\nstatic __u64 cycles[MAX_CPU][MAX_ENTRY];\nstatic __u64 cycles_rpt[MAX_CPU][MAX_ENTRY];\n\n#define BITS\t\t16\n#define TABLESZ\t\t(1 << BITS)\n#define TABLEMAX\t(TABLESZ / 2)\n#define MASK\t\t(TABLESZ - 1)\n\nstatic struct entry {\n\t__u32 used;\n\t__s32 tid;\n\t__u64 cycles[MAX_ENTRY];\n\t__u64 cycles_rpt[MAX_ENTRY];\n} table[TABLESZ];\n\nstatic int tid_cnt;\n\nstatic int event_entry(const char *event)\n{\n\tif (!event)\n\t\treturn OTHER_CYC;\n\tif (!strncmp(event, \"instructions\", 12))\n\t\treturn INSTR_CYC;\n\tif (!strncmp(event, \"branches\", 8))\n\t\treturn BRNCH_CYC;\n\treturn OTHER_CYC;\n}\n\nstatic struct entry *find_entry(__s32 tid)\n{\n\t__u32 pos = tid & MASK;\n\tstruct entry *e;\n\n\te = &table[pos];\n\twhile (e->used) {\n\t\tif (e->tid == tid)\n\t\t\treturn e;\n\t\tif (++pos == TABLESZ)\n\t\t\tpos = 0;\n\t\te = &table[pos];\n\t}\n\n\tif (tid_cnt >= TABLEMAX) {\n\t\tfprintf(stderr, \"Too many threads\\n\");\n\t\treturn NULL;\n\t}\n\n\ttid_cnt += 1;\n\te->used = 1;\n\te->tid = tid;\n\treturn e;\n}\n\nstatic void add_entry(__s32 tid, int pos, __u64 cnt)\n{\n\tstruct entry *e = find_entry(tid);\n\n\tif (e)\n\t\te->cycles[pos] += cnt;\n}\n\nint filter_event_early(void *data, const struct perf_dlfilter_sample *sample, void *ctx)\n{\n\t__s32 cpu = sample->cpu;\n\t__s32 tid = sample->tid;\n\tint pos;\n\n\tif (!sample->cyc_cnt)\n\t\treturn 0;\n\n\tpos = event_entry(sample->event);\n\n\tif (cpu >= 0 && cpu < MAX_CPU)\n\t\tcycles[cpu][pos] += sample->cyc_cnt;\n\telse if (tid != -1)\n\t\tadd_entry(tid, pos, sample->cyc_cnt);\n\treturn 0;\n}\n\nstatic void print_vals(__u64 cycles, __u64 delta)\n{\n\tif (delta)\n\t\tprintf(\"%10llu %10llu \", (unsigned long long)cycles, (unsigned long long)delta);\n\telse\n\t\tprintf(\"%10llu %10s \", (unsigned long long)cycles, \"\");\n}\n\nint filter_event(void *data, const struct perf_dlfilter_sample *sample, void *ctx)\n{\n\t__s32 cpu = sample->cpu;\n\t__s32 tid = sample->tid;\n\tint pos;\n\n\tpos = event_entry(sample->event);\n\n\tif (cpu >= 0 && cpu < MAX_CPU) {\n\t\tprint_vals(cycles[cpu][pos], cycles[cpu][pos] - cycles_rpt[cpu][pos]);\n\t\tcycles_rpt[cpu][pos] = cycles[cpu][pos];\n\t\treturn 0;\n\t}\n\n\tif (tid != -1) {\n\t\tstruct entry *e = find_entry(tid);\n\n\t\tif (e) {\n\t\t\tprint_vals(e->cycles[pos], e->cycles[pos] - e->cycles_rpt[pos]);\n\t\t\te->cycles_rpt[pos] = e->cycles[pos];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprintf(\"%22s\", \"\");\n\treturn 0;\n}\n\nconst char *filter_description(const char **long_description)\n{\n\tstatic char *long_desc = \"Cycle counts are accumulated per CPU (or \"\n\t\t\"per thread if CPU is not recorded) from IPC information, and \"\n\t\t\"printed together with the change since the last print, at the \"\n\t\t\"start of each line. Separate counts are kept for branches, \"\n\t\t\"instructions or other events.\";\n\n\t*long_description = long_desc;\n\treturn \"Print the number of cycles at the start of each line\";\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}