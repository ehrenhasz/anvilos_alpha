{
  "module_name": "dlfilter-test-api-v0.c",
  "hash_id": "33214623e2d59603193d1ab3618743631ed1ba65609bf8ed38c4ed0c33d8d371",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/dlfilters/dlfilter-test-api-v0.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n \n#include <linux/perf_event.h>\n#include <linux/types.h>\n\n \nenum {\n\tPERF_DLFILTER_FLAG_BRANCH\t= 1ULL << 0,\n\tPERF_DLFILTER_FLAG_CALL\t\t= 1ULL << 1,\n\tPERF_DLFILTER_FLAG_RETURN\t= 1ULL << 2,\n\tPERF_DLFILTER_FLAG_CONDITIONAL\t= 1ULL << 3,\n\tPERF_DLFILTER_FLAG_SYSCALLRET\t= 1ULL << 4,\n\tPERF_DLFILTER_FLAG_ASYNC\t= 1ULL << 5,\n\tPERF_DLFILTER_FLAG_INTERRUPT\t= 1ULL << 6,\n\tPERF_DLFILTER_FLAG_TX_ABORT\t= 1ULL << 7,\n\tPERF_DLFILTER_FLAG_TRACE_BEGIN\t= 1ULL << 8,\n\tPERF_DLFILTER_FLAG_TRACE_END\t= 1ULL << 9,\n\tPERF_DLFILTER_FLAG_IN_TX\t= 1ULL << 10,\n\tPERF_DLFILTER_FLAG_VMENTRY\t= 1ULL << 11,\n\tPERF_DLFILTER_FLAG_VMEXIT\t= 1ULL << 12,\n};\n\n \nstruct perf_dlfilter_sample {\n\t__u32 size;  \n\t__u16 ins_lat;\t\t \n\t__u16 p_stage_cyc;\t \n\t__u64 ip;\n\t__s32 pid;\n\t__s32 tid;\n\t__u64 time;\n\t__u64 addr;\n\t__u64 id;\n\t__u64 stream_id;\n\t__u64 period;\n\t__u64 weight;\t\t \n\t__u64 transaction;\t \n\t__u64 insn_cnt;\t \n\t__u64 cyc_cnt;\t\t \n\t__s32 cpu;\n\t__u32 flags;\t\t \n\t__u64 data_src;\t\t \n\t__u64 phys_addr;\t \n\t__u64 data_page_size;\t \n\t__u64 code_page_size;\t \n\t__u64 cgroup;\t\t \n\t__u8  cpumode;\t\t \n\t__u8  addr_correlates_sym;  \n\t__u16 misc;\t\t \n\t__u32 raw_size;\t\t \n\tconst void *raw_data;\t \n\t__u64 brstack_nr;\t \n\tconst struct perf_branch_entry *brstack;  \n\t__u64 raw_callchain_nr;\t \n\tconst __u64 *raw_callchain;  \n\tconst char *event;\n};\n\n \nstruct perf_dlfilter_al {\n\t__u32 size;  \n\t__u32 symoff;\n\tconst char *sym;\n\t__u64 addr;  \n\t__u64 sym_start;\n\t__u64 sym_end;\n\tconst char *dso;\n\t__u8  sym_binding;  \n\t__u8  is_64_bit;  \n\t__u8  is_kernel_ip;  \n\t__u32 buildid_size;\n\t__u8 *buildid;\n\t \n\t__u8 filtered;  \n\tconst char *comm;\n};\n\nstruct perf_dlfilter_fns {\n\t \n\tconst struct perf_dlfilter_al *(*resolve_ip)(void *ctx);\n\t \n\tconst struct perf_dlfilter_al *(*resolve_addr)(void *ctx);\n\t \n\tchar **(*args)(void *ctx, int *dlargc);\n\t \n\t__s32 (*resolve_address)(void *ctx, __u64 address, struct perf_dlfilter_al *al);\n\t \n\tconst __u8 *(*insn)(void *ctx, __u32 *length);\n\t \n\tconst char *(*srcline)(void *ctx, __u32 *line_number);\n\t \n\tstruct perf_event_attr *(*attr)(void *ctx);\n\t \n\t__s32 (*object_code)(void *ctx, __u64 ip, void *buf, __u32 len);\n\t \n\tvoid *(*reserved[120])(void *);\n};\n\nstruct perf_dlfilter_fns perf_dlfilter_fns;\n\nstatic int verbose;\n\n#define pr_debug(fmt, ...) do { \\\n\t\tif (verbose > 0) \\\n\t\t\tfprintf(stderr, fmt, ##__VA_ARGS__); \\\n\t} while (0)\n\nstatic int test_fail(const char *msg)\n{\n\tpr_debug(\"%s\\n\", msg);\n\treturn -1;\n}\n\n#define CHECK(x) do { \\\n\t\tif (!(x)) \\\n\t\t\treturn test_fail(\"Check '\" #x \"' failed\\n\"); \\\n\t} while (0)\n\nstruct filter_data {\n\t__u64 ip;\n\t__u64 addr;\n\tint do_early;\n\tint early_filter_cnt;\n\tint filter_cnt;\n};\n\nstatic struct filter_data *filt_dat;\n\nint start(void **data, void *ctx)\n{\n\tint dlargc;\n\tchar **dlargv;\n\tstruct filter_data *d;\n\tstatic bool called;\n\n\tverbose = 1;\n\n\tCHECK(!filt_dat && !called);\n\tcalled = true;\n\n\td = calloc(1, sizeof(*d));\n\tif (!d)\n\t\ttest_fail(\"Failed to allocate memory\");\n\tfilt_dat = d;\n\t*data = d;\n\n\tdlargv = perf_dlfilter_fns.args(ctx, &dlargc);\n\n\tCHECK(dlargc == 6);\n\tCHECK(!strcmp(dlargv[0], \"first\"));\n\tverbose = strtol(dlargv[1], NULL, 0);\n\td->ip = strtoull(dlargv[2], NULL, 0);\n\td->addr = strtoull(dlargv[3], NULL, 0);\n\td->do_early = strtol(dlargv[4], NULL, 0);\n\tCHECK(!strcmp(dlargv[5], \"last\"));\n\n\tpr_debug(\"%s API\\n\", __func__);\n\n\treturn 0;\n}\n\n#define CHECK_SAMPLE(x) do { \\\n\t\tif (sample->x != expected.x) \\\n\t\t\treturn test_fail(\"'\" #x \"' not expected value\\n\"); \\\n\t} while (0)\n\nstatic int check_sample(struct filter_data *d, const struct perf_dlfilter_sample *sample)\n{\n\tstruct perf_dlfilter_sample expected = {\n\t\t.ip\t\t= d->ip,\n\t\t.pid\t\t= 12345,\n\t\t.tid\t\t= 12346,\n\t\t.time\t\t= 1234567890,\n\t\t.addr\t\t= d->addr,\n\t\t.id\t\t= 99,\n\t\t.stream_id\t= 101,\n\t\t.period\t\t= 543212345,\n\t\t.cpu\t\t= 31,\n\t\t.cpumode\t= PERF_RECORD_MISC_USER,\n\t\t.addr_correlates_sym = 1,\n\t\t.misc\t\t= PERF_RECORD_MISC_USER,\n\t};\n\n\tCHECK(sample->size >= sizeof(struct perf_dlfilter_sample));\n\n\tCHECK_SAMPLE(ip);\n\tCHECK_SAMPLE(pid);\n\tCHECK_SAMPLE(tid);\n\tCHECK_SAMPLE(time);\n\tCHECK_SAMPLE(addr);\n\tCHECK_SAMPLE(id);\n\tCHECK_SAMPLE(stream_id);\n\tCHECK_SAMPLE(period);\n\tCHECK_SAMPLE(cpu);\n\tCHECK_SAMPLE(cpumode);\n\tCHECK_SAMPLE(addr_correlates_sym);\n\tCHECK_SAMPLE(misc);\n\n\tCHECK(!sample->raw_data);\n\tCHECK_SAMPLE(brstack_nr);\n\tCHECK(!sample->brstack);\n\tCHECK_SAMPLE(raw_callchain_nr);\n\tCHECK(!sample->raw_callchain);\n\n#define EVENT_NAME \"branches:\"\n\tCHECK(!strncmp(sample->event, EVENT_NAME, strlen(EVENT_NAME)));\n\n\treturn 0;\n}\n\nstatic int check_al(void *ctx)\n{\n\tconst struct perf_dlfilter_al *al;\n\n\tal = perf_dlfilter_fns.resolve_ip(ctx);\n\tif (!al)\n\t\treturn test_fail(\"resolve_ip() failed\");\n\n\tCHECK(al->sym && !strcmp(\"foo\", al->sym));\n\tCHECK(!al->symoff);\n\n\treturn 0;\n}\n\nstatic int check_addr_al(void *ctx)\n{\n\tconst struct perf_dlfilter_al *addr_al;\n\n\taddr_al = perf_dlfilter_fns.resolve_addr(ctx);\n\tif (!addr_al)\n\t\treturn test_fail(\"resolve_addr() failed\");\n\n\tCHECK(addr_al->sym && !strcmp(\"bar\", addr_al->sym));\n\tCHECK(!addr_al->symoff);\n\n\treturn 0;\n}\n\nstatic int check_address_al(void *ctx, const struct perf_dlfilter_sample *sample)\n{\n\tstruct perf_dlfilter_al address_al;\n\tconst struct perf_dlfilter_al *al;\n\n\tal = perf_dlfilter_fns.resolve_ip(ctx);\n\tif (!al)\n\t\treturn test_fail(\"resolve_ip() failed\");\n\n\taddress_al.size = sizeof(address_al);\n\tif (perf_dlfilter_fns.resolve_address(ctx, sample->ip, &address_al))\n\t\treturn test_fail(\"resolve_address() failed\");\n\n\tCHECK(address_al.sym && al->sym);\n\tCHECK(!strcmp(address_al.sym, al->sym));\n\tCHECK(address_al.addr == al->addr);\n\tCHECK(address_al.sym_start == al->sym_start);\n\tCHECK(address_al.sym_end == al->sym_end);\n\tCHECK(address_al.dso && al->dso);\n\tCHECK(!strcmp(address_al.dso, al->dso));\n\n\treturn 0;\n}\n\nstatic int check_attr(void *ctx)\n{\n\tstruct perf_event_attr *attr = perf_dlfilter_fns.attr(ctx);\n\n\tCHECK(attr);\n\tCHECK(attr->type == PERF_TYPE_HARDWARE);\n\tCHECK(attr->config == PERF_COUNT_HW_BRANCH_INSTRUCTIONS);\n\n\treturn 0;\n}\n\nstatic int check_object_code(void *ctx, const struct perf_dlfilter_sample *sample)\n{\n\t__u8 buf[15];\n\n\tCHECK(perf_dlfilter_fns.object_code(ctx, sample->ip, buf, sizeof(buf)) > 0);\n\n\treturn 0;\n}\n\nstatic int do_checks(void *data, const struct perf_dlfilter_sample *sample, void *ctx, bool early)\n{\n\tstruct filter_data *d = data;\n\n\tCHECK(data && filt_dat == data);\n\n\tif (early) {\n\t\tCHECK(!d->early_filter_cnt);\n\t\td->early_filter_cnt += 1;\n\t} else {\n\t\tCHECK(!d->filter_cnt);\n\t\tCHECK(d->early_filter_cnt);\n\t\tCHECK(d->do_early != 2);\n\t\td->filter_cnt += 1;\n\t}\n\n\tif (check_sample(data, sample))\n\t\treturn -1;\n\n\tif (check_attr(ctx))\n\t\treturn -1;\n\n\tif (early && !d->do_early)\n\t\treturn 0;\n\n\tif (check_al(ctx) || check_addr_al(ctx) || check_address_al(ctx, sample) ||\n\t    check_object_code(ctx, sample))\n\t\treturn -1;\n\n\tif (early)\n\t\treturn d->do_early == 2;\n\n\treturn 1;\n}\n\nint filter_event_early(void *data, const struct perf_dlfilter_sample *sample, void *ctx)\n{\n\tpr_debug(\"%s API\\n\", __func__);\n\n\treturn do_checks(data, sample, ctx, true);\n}\n\nint filter_event(void *data, const struct perf_dlfilter_sample *sample, void *ctx)\n{\n\tpr_debug(\"%s API\\n\", __func__);\n\n\treturn do_checks(data, sample, ctx, false);\n}\n\nint stop(void *data, void *ctx)\n{\n\tstatic bool called;\n\n\tpr_debug(\"%s API\\n\", __func__);\n\n\tCHECK(data && filt_dat == data && !called);\n\tcalled = true;\n\n\tfree(data);\n\tfilt_dat = NULL;\n\treturn 0;\n}\n\nconst char *filter_description(const char **long_description)\n{\n\t*long_description = \"Filter used by the 'dlfilter C API' perf test\";\n\treturn \"dlfilter to test v0 C API\";\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}