{
  "module_name": "builtin-probe.c",
  "hash_id": "ab23395b9b1ac9ef9ac10145e1a4cae7669b8bc6deafd54876511e002054b7cb",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-probe.c",
  "human_readable_source": "\n \n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"builtin.h\"\n#include \"namespaces.h\"\n#include \"util/build-id.h\"\n#include \"util/strlist.h\"\n#include \"util/strfilter.h\"\n#include \"util/symbol.h\"\n#include \"util/symbol_conf.h\"\n#include \"util/debug.h\"\n#include <subcmd/parse-options.h>\n#include \"util/probe-finder.h\"\n#include \"util/probe-event.h\"\n#include \"util/probe-file.h\"\n#include <linux/string.h>\n#include <linux/zalloc.h>\n\n#define DEFAULT_VAR_FILTER \"!__k???tab_* & !__crc_*\"\n#define DEFAULT_FUNC_FILTER \"!_* & !*@plt\"\n#define DEFAULT_LIST_FILTER \"*\"\n\n \nstatic struct {\n\tint command;\t \n\tbool list_events;\n\tbool uprobes;\n\tbool target_used;\n\tint nevents;\n\tstruct perf_probe_event events[MAX_PROBES];\n\tstruct line_range line_range;\n\tchar *target;\n\tstruct strfilter *filter;\n\tstruct nsinfo *nsi;\n} *params;\n\n \nstatic int parse_probe_event(const char *str)\n{\n\tstruct perf_probe_event *pev = &params->events[params->nevents];\n\tint ret;\n\n\tpr_debug(\"probe-definition(%d): %s\\n\", params->nevents, str);\n\tif (++params->nevents == MAX_PROBES) {\n\t\tpr_err(\"Too many probes (> %d) were specified.\", MAX_PROBES);\n\t\treturn -1;\n\t}\n\n\tpev->uprobes = params->uprobes;\n\tif (params->target) {\n\t\tpev->target = strdup(params->target);\n\t\tif (!pev->target)\n\t\t\treturn -ENOMEM;\n\t\tparams->target_used = true;\n\t}\n\n\tpev->nsi = nsinfo__get(params->nsi);\n\n\t \n\tret = parse_perf_probe_command(str, pev);\n\tpr_debug(\"%d arguments\\n\", pev->nargs);\n\n\treturn ret;\n}\n\nstatic int params_add_filter(const char *str)\n{\n\tconst char *err = NULL;\n\tint ret = 0;\n\n\tpr_debug2(\"Add filter: %s\\n\", str);\n\tif (!params->filter) {\n\t\tparams->filter = strfilter__new(str, &err);\n\t\tif (!params->filter)\n\t\t\tret = err ? -EINVAL : -ENOMEM;\n\t} else\n\t\tret = strfilter__or(params->filter, str, &err);\n\n\tif (ret == -EINVAL) {\n\t\tpr_err(\"Filter parse error at %td.\\n\", err - str + 1);\n\t\tpr_err(\"Source: \\\"%s\\\"\\n\", str);\n\t\tpr_err(\"         %*c\\n\", (int)(err - str + 1), '^');\n\t}\n\n\treturn ret;\n}\n\nstatic int set_target(const char *ptr)\n{\n\tint found = 0;\n\tconst char *buf;\n\n\t \n\tif (!params->target && ptr && *ptr == '/') {\n\t\tparams->target = strdup(ptr);\n\t\tif (!params->target)\n\t\t\treturn -ENOMEM;\n\t\tparams->target_used = false;\n\n\t\tfound = 1;\n\t\tbuf = ptr + (strlen(ptr) - 3);\n\n\t\tif (strcmp(buf, \".ko\"))\n\t\t\tparams->uprobes = true;\n\n\t}\n\n\treturn found;\n}\n\nstatic int parse_probe_event_argv(int argc, const char **argv)\n{\n\tint i, len, ret, found_target;\n\tchar *buf;\n\n\tfound_target = set_target(argv[0]);\n\tif (found_target < 0)\n\t\treturn found_target;\n\n\tif (found_target && argc == 1)\n\t\treturn 0;\n\n\t \n\tlen = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i == 0 && found_target)\n\t\t\tcontinue;\n\n\t\tlen += strlen(argv[i]) + 1;\n\t}\n\tbuf = zalloc(len + 1);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\tlen = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i == 0 && found_target)\n\t\t\tcontinue;\n\n\t\tlen += sprintf(&buf[len], \"%s \", argv[i]);\n\t}\n\tret = parse_probe_event(buf);\n\tfree(buf);\n\treturn ret;\n}\n\nstatic int opt_set_target(const struct option *opt, const char *str,\n\t\t\tint unset __maybe_unused)\n{\n\tint ret = -ENOENT;\n\tchar *tmp;\n\n\tif  (str) {\n\t\tif (!strcmp(opt->long_name, \"exec\"))\n\t\t\tparams->uprobes = true;\n\t\telse if (!strcmp(opt->long_name, \"module\"))\n\t\t\tparams->uprobes = false;\n\t\telse\n\t\t\treturn ret;\n\n\t\t \n\t\tif (params->uprobes || strchr(str, '/')) {\n\t\t\ttmp = nsinfo__realpath(str, params->nsi);\n\t\t\tif (!tmp) {\n\t\t\t\tpr_warning(\"Failed to get the absolute path of %s: %m\\n\", str);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\ttmp = strdup(str);\n\t\t\tif (!tmp)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfree(params->target);\n\t\tparams->target = tmp;\n\t\tparams->target_used = false;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int opt_set_target_ns(const struct option *opt __maybe_unused,\n\t\t\t     const char *str, int unset __maybe_unused)\n{\n\tint ret = -ENOENT;\n\tpid_t ns_pid;\n\tstruct nsinfo *nsip;\n\n\tif (str) {\n\t\terrno = 0;\n\t\tns_pid = (pid_t)strtol(str, NULL, 10);\n\t\tif (errno != 0) {\n\t\t\tret = -errno;\n\t\t\tpr_warning(\"Failed to parse %s as a pid: %s\\n\", str,\n\t\t\t\t   strerror(errno));\n\t\t\treturn ret;\n\t\t}\n\t\tnsip = nsinfo__new(ns_pid);\n\t\tif (nsip && nsinfo__need_setns(nsip))\n\t\t\tparams->nsi = nsinfo__get(nsip);\n\t\tnsinfo__put(nsip);\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n\n \n\n#ifdef HAVE_DWARF_SUPPORT\nstatic int opt_show_lines(const struct option *opt,\n\t\t\t  const char *str, int unset __maybe_unused)\n{\n\tint ret = 0;\n\n\tif (!str)\n\t\treturn 0;\n\n\tif (params->command == 'L') {\n\t\tpr_warning(\"Warning: more than one --line options are\"\n\t\t\t   \" detected. Only the first one is valid.\\n\");\n\t\treturn 0;\n\t}\n\n\tparams->command = opt->short_name;\n\tret = parse_line_range_desc(str, &params->line_range);\n\n\treturn ret;\n}\n\nstatic int opt_show_vars(const struct option *opt,\n\t\t\t const char *str, int unset __maybe_unused)\n{\n\tstruct perf_probe_event *pev = &params->events[params->nevents];\n\tint ret;\n\n\tif (!str)\n\t\treturn 0;\n\n\tret = parse_probe_event(str);\n\tif (!ret && pev->nargs != 0) {\n\t\tpr_err(\"  Error: '--vars' doesn't accept arguments.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tparams->command = opt->short_name;\n\n\treturn ret;\n}\n#else\n# define opt_show_lines NULL\n# define opt_show_vars NULL\n#endif\nstatic int opt_add_probe_event(const struct option *opt,\n\t\t\t      const char *str, int unset __maybe_unused)\n{\n\tif (str) {\n\t\tparams->command = opt->short_name;\n\t\treturn parse_probe_event(str);\n\t}\n\n\treturn 0;\n}\n\nstatic int opt_set_filter_with_command(const struct option *opt,\n\t\t\t\t       const char *str, int unset)\n{\n\tif (!unset)\n\t\tparams->command = opt->short_name;\n\n\tif (str)\n\t\treturn params_add_filter(str);\n\n\treturn 0;\n}\n\nstatic int opt_set_filter(const struct option *opt __maybe_unused,\n\t\t\t  const char *str, int unset __maybe_unused)\n{\n\tif (str)\n\t\treturn params_add_filter(str);\n\n\treturn 0;\n}\n\nstatic int init_params(void)\n{\n\tint ret;\n\n\tparams = calloc(1, sizeof(*params));\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tret = line_range__init(&params->line_range);\n\tif (ret)\n\t\tzfree(&params);\n\treturn ret;\n}\n\nstatic void cleanup_params(void)\n{\n\tint i;\n\n\tfor (i = 0; i < params->nevents; i++)\n\t\tclear_perf_probe_event(params->events + i);\n\tline_range__clear(&params->line_range);\n\tfree(params->target);\n\tstrfilter__delete(params->filter);\n\tnsinfo__put(params->nsi);\n\tzfree(&params);\n}\n\nstatic void pr_err_with_code(const char *msg, int err)\n{\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tpr_err(\"%s\", msg);\n\tpr_debug(\" Reason: %s (Code: %d)\",\n\t\t str_error_r(-err, sbuf, sizeof(sbuf)), err);\n\tpr_err(\"\\n\");\n}\n\nstatic int perf_add_probe_events(struct perf_probe_event *pevs, int npevs)\n{\n\tint ret;\n\tint i, k;\n\tconst char *event = NULL, *group = NULL;\n\n\tret = init_probe_symbol_maps(pevs->uprobes);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = convert_perf_probe_events(pevs, npevs);\n\tif (ret < 0)\n\t\tgoto out_cleanup;\n\n\tif (params->command == 'D') {\t \n\t\tif (probe_conf.bootconfig)\n\t\t\tret = show_bootconfig_events(pevs, npevs);\n\t\telse\n\t\t\tret = show_probe_trace_events(pevs, npevs);\n\t\tgoto out_cleanup;\n\t}\n\n\tret = apply_perf_probe_events(pevs, npevs);\n\tif (ret < 0)\n\t\tgoto out_cleanup;\n\n\tfor (i = k = 0; i < npevs; i++)\n\t\tk += pevs[i].ntevs;\n\n\tpr_info(\"Added new event%s\\n\", (k > 1) ? \"s:\" : \":\");\n\tfor (i = 0; i < npevs; i++) {\n\t\tstruct perf_probe_event *pev = &pevs[i];\n\n\t\tfor (k = 0; k < pev->ntevs; k++) {\n\t\t\tstruct probe_trace_event *tev = &pev->tevs[k];\n\t\t\t \n\t\t\tif (!tev->event)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tshow_perf_probe_event(tev->group, tev->event, pev,\n\t\t\t\t\t      tev->point.module, false);\n\n\t\t\t \n\t\t\tevent = tev->event;\n\t\t\tgroup = tev->group;\n\t\t}\n\t}\n\n\t \n\tif (event) {\n#ifndef HAVE_LIBTRACEEVENT\n\t\tpr_info(\"\\nperf is not linked with libtraceevent, to use the new probe you can use tracefs:\\n\\n\");\n\t\tpr_info(\"\\tcd /sys/kernel/tracing/\\n\");\n\t\tpr_info(\"\\techo 1 > events/%s/%s/enable\\n\", group, event);\n\t\tpr_info(\"\\techo 1 > tracing_on\\n\");\n\t\tpr_info(\"\\tcat trace_pipe\\n\");\n\t\tpr_info(\"\\tBefore removing the probe, echo 0 > events/%s/%s/enable\\n\", group, event);\n#else\n\t\t \n\t\tpr_info(\"\\nYou can now use it in all perf tools, such as:\\n\\n\");\n\t\tpr_info(\"\\tperf record -e %s:%s -aR sleep 1\\n\\n\", group, event);\n#endif\n\t}\n\nout_cleanup:\n\tcleanup_perf_probe_events(pevs, npevs);\n\texit_probe_symbol_maps();\n\treturn ret;\n}\n\nstatic int del_perf_probe_caches(struct strfilter *filter)\n{\n\tstruct probe_cache *cache;\n\tstruct strlist *bidlist;\n\tstruct str_node *nd;\n\tint ret;\n\n\tbidlist = build_id_cache__list_all(false);\n\tif (!bidlist) {\n\t\tret = -errno;\n\t\tpr_debug(\"Failed to get buildids: %d\\n\", ret);\n\t\treturn ret ?: -ENOMEM;\n\t}\n\n\tstrlist__for_each_entry(nd, bidlist) {\n\t\tcache = probe_cache__new(nd->s, NULL);\n\t\tif (!cache)\n\t\t\tcontinue;\n\t\tif (probe_cache__filter_purge(cache, filter) < 0 ||\n\t\t    probe_cache__commit(cache) < 0)\n\t\t\tpr_warning(\"Failed to remove entries for %s\\n\", nd->s);\n\t\tprobe_cache__delete(cache);\n\t}\n\treturn 0;\n}\n\nstatic int perf_del_probe_events(struct strfilter *filter)\n{\n\tint ret, ret2, ufd = -1, kfd = -1;\n\tchar *str = strfilter__string(filter);\n\tstruct strlist *klist = NULL, *ulist = NULL;\n\tstruct str_node *ent;\n\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Delete filter: \\'%s\\'\\n\", str);\n\n\tif (probe_conf.cache)\n\t\treturn del_perf_probe_caches(filter);\n\n\t \n\tret = probe_file__open_both(&kfd, &ufd, PF_FL_RW);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tklist = strlist__new(NULL, NULL);\n\tulist = strlist__new(NULL, NULL);\n\tif (!klist || !ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = probe_file__get_events(kfd, filter, klist);\n\tif (ret == 0) {\n\t\tstrlist__for_each_entry(ent, klist)\n\t\t\tpr_info(\"Removed event: %s\\n\", ent->s);\n\n\t\tret = probe_file__del_strlist(kfd, klist);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t} else if (ret == -ENOMEM)\n\t\tgoto error;\n\n\tret2 = probe_file__get_events(ufd, filter, ulist);\n\tif (ret2 == 0) {\n\t\tstrlist__for_each_entry(ent, ulist)\n\t\t\tpr_info(\"Removed event: %s\\n\", ent->s);\n\n\t\tret2 = probe_file__del_strlist(ufd, ulist);\n\t\tif (ret2 < 0)\n\t\t\tgoto error;\n\t} else if (ret2 == -ENOMEM)\n\t\tgoto error;\n\n\tif (ret == -ENOENT && ret2 == -ENOENT)\n\t\tpr_warning(\"\\\"%s\\\" does not hit any event.\\n\", str);\n\telse\n\t\tret = 0;\n\nerror:\n\tif (kfd >= 0)\n\t\tclose(kfd);\n\tif (ufd >= 0)\n\t\tclose(ufd);\nout:\n\tstrlist__delete(klist);\n\tstrlist__delete(ulist);\n\tfree(str);\n\n\treturn ret;\n}\n\n#ifdef HAVE_DWARF_SUPPORT\n#define PROBEDEF_STR\t\\\n\t\"[EVENT=]FUNC[@SRC][+OFF|%return|:RL|;PT]|SRC:AL|SRC;PT [[NAME=]ARG ...]\"\n#else\n#define PROBEDEF_STR\t\"[EVENT=]FUNC[+OFF|%return] [[NAME=]ARG ...]\"\n#endif\n\n\nstatic int\n__cmd_probe(int argc, const char **argv)\n{\n\tconst char * const probe_usage[] = {\n\t\t\"perf probe [<options>] 'PROBEDEF' ['PROBEDEF' ...]\",\n\t\t\"perf probe [<options>] --add 'PROBEDEF' [--add 'PROBEDEF' ...]\",\n\t\t\"perf probe [<options>] --del '[GROUP:]EVENT' ...\",\n\t\t\"perf probe --list [GROUP:]EVENT ...\",\n#ifdef HAVE_DWARF_SUPPORT\n\t\t\"perf probe [<options>] --line 'LINEDESC'\",\n\t\t\"perf probe [<options>] --vars 'PROBEPOINT'\",\n#endif\n\t\t\"perf probe [<options>] --funcs\",\n\t\tNULL\n\t};\n\tstruct option options[] = {\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t    \"be more verbose (show parsed arguments, etc)\"),\n\tOPT_BOOLEAN('q', \"quiet\", &quiet,\n\t\t    \"be quiet (do not show any warnings or messages)\"),\n\tOPT_CALLBACK_DEFAULT('l', \"list\", NULL, \"[GROUP:]EVENT\",\n\t\t\t     \"list up probe events\",\n\t\t\t     opt_set_filter_with_command, DEFAULT_LIST_FILTER),\n\tOPT_CALLBACK('d', \"del\", NULL, \"[GROUP:]EVENT\", \"delete a probe event.\",\n\t\t     opt_set_filter_with_command),\n\tOPT_CALLBACK('a', \"add\", NULL, PROBEDEF_STR,\n\t\t\"probe point definition, where\\n\"\n\t\t\"\\t\\tGROUP:\\tGroup name (optional)\\n\"\n\t\t\"\\t\\tEVENT:\\tEvent name\\n\"\n\t\t\"\\t\\tFUNC:\\tFunction name\\n\"\n\t\t\"\\t\\tOFF:\\tOffset from function entry (in byte)\\n\"\n\t\t\"\\t\\t%return:\\tPut the probe at function return\\n\"\n#ifdef HAVE_DWARF_SUPPORT\n\t\t\"\\t\\tSRC:\\tSource code path\\n\"\n\t\t\"\\t\\tRL:\\tRelative line number from function entry.\\n\"\n\t\t\"\\t\\tAL:\\tAbsolute line number in file.\\n\"\n\t\t\"\\t\\tPT:\\tLazy expression of line code.\\n\"\n\t\t\"\\t\\tARG:\\tProbe argument (local variable name or\\n\"\n\t\t\"\\t\\t\\tkprobe-tracer argument format.)\\n\",\n#else\n\t\t\"\\t\\tARG:\\tProbe argument (kprobe-tracer argument format.)\\n\",\n#endif\n\t\topt_add_probe_event),\n\tOPT_CALLBACK('D', \"definition\", NULL, PROBEDEF_STR,\n\t\t\"Show trace event definition of given traceevent for k/uprobe_events.\",\n\t\topt_add_probe_event),\n\tOPT_BOOLEAN('f', \"force\", &probe_conf.force_add, \"forcibly add events\"\n\t\t    \" with existing name\"),\n\tOPT_CALLBACK('L', \"line\", NULL,\n\t\t     \"FUNC[:RLN[+NUM|-RLN2]]|SRC:ALN[+NUM|-ALN2]\",\n\t\t     \"Show source code lines.\", opt_show_lines),\n\tOPT_CALLBACK('V', \"vars\", NULL,\n\t\t     \"FUNC[@SRC][+OFF|%return|:RL|;PT]|SRC:AL|SRC;PT\",\n\t\t     \"Show accessible variables on PROBEDEF\", opt_show_vars),\n\tOPT_BOOLEAN('\\0', \"externs\", &probe_conf.show_ext_vars,\n\t\t    \"Show external variables too (with --vars only)\"),\n\tOPT_BOOLEAN('\\0', \"range\", &probe_conf.show_location_range,\n\t\t\"Show variables location range in scope (with --vars only)\"),\n\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_STRING('s', \"source\", &symbol_conf.source_prefix,\n\t\t   \"directory\", \"path to kernel source\"),\n\tOPT_BOOLEAN('\\0', \"no-inlines\", &probe_conf.no_inlines,\n\t\t\"Don't search inlined functions\"),\n\tOPT__DRY_RUN(&probe_event_dry_run),\n\tOPT_INTEGER('\\0', \"max-probes\", &probe_conf.max_probes,\n\t\t \"Set how many probe points can be found for a probe.\"),\n\tOPT_CALLBACK_DEFAULT('F', \"funcs\", NULL, \"[FILTER]\",\n\t\t\t     \"Show potential probe-able functions.\",\n\t\t\t     opt_set_filter_with_command, DEFAULT_FUNC_FILTER),\n\tOPT_CALLBACK('\\0', \"filter\", NULL,\n\t\t     \"[!]FILTER\", \"Set a filter (with --vars/funcs only)\\n\"\n\t\t     \"\\t\\t\\t(default: \\\"\" DEFAULT_VAR_FILTER \"\\\" for --vars,\\n\"\n\t\t     \"\\t\\t\\t \\\"\" DEFAULT_FUNC_FILTER \"\\\" for --funcs)\",\n\t\t     opt_set_filter),\n\tOPT_CALLBACK('x', \"exec\", NULL, \"executable|path\",\n\t\t\t\"target executable name or path\", opt_set_target),\n\tOPT_CALLBACK('m', \"module\", NULL, \"modname|path\",\n\t\t\"target module name (for online) or path (for offline)\",\n\t\topt_set_target),\n\tOPT_BOOLEAN(0, \"demangle\", &symbol_conf.demangle,\n\t\t    \"Enable symbol demangling\"),\n\tOPT_BOOLEAN(0, \"demangle-kernel\", &symbol_conf.demangle_kernel,\n\t\t    \"Enable kernel symbol demangling\"),\n\tOPT_BOOLEAN(0, \"cache\", &probe_conf.cache, \"Manipulate probe cache\"),\n\tOPT_STRING(0, \"symfs\", &symbol_conf.symfs, \"directory\",\n\t\t   \"Look for files with symbols relative to this directory\"),\n\tOPT_CALLBACK(0, \"target-ns\", NULL, \"pid\",\n\t\t     \"target pid for namespace contexts\", opt_set_target_ns),\n\tOPT_BOOLEAN(0, \"bootconfig\", &probe_conf.bootconfig,\n\t\t    \"Output probe definition with bootconfig format\"),\n\tOPT_END()\n\t};\n\tint ret;\n\n\tset_option_flag(options, 'a', \"add\", PARSE_OPT_EXCLUSIVE);\n\tset_option_flag(options, 'd', \"del\", PARSE_OPT_EXCLUSIVE);\n\tset_option_flag(options, 'D', \"definition\", PARSE_OPT_EXCLUSIVE);\n\tset_option_flag(options, 'l', \"list\", PARSE_OPT_EXCLUSIVE);\n#ifdef HAVE_DWARF_SUPPORT\n\tset_option_flag(options, 'L', \"line\", PARSE_OPT_EXCLUSIVE);\n\tset_option_flag(options, 'V', \"vars\", PARSE_OPT_EXCLUSIVE);\n#else\n# define set_nobuild(s, l, c) set_option_nobuild(options, s, l, \"NO_DWARF=1\", c)\n\tset_nobuild('L', \"line\", false);\n\tset_nobuild('V', \"vars\", false);\n\tset_nobuild('\\0', \"externs\", false);\n\tset_nobuild('\\0', \"range\", false);\n\tset_nobuild('k', \"vmlinux\", true);\n\tset_nobuild('s', \"source\", true);\n\tset_nobuild('\\0', \"no-inlines\", true);\n# undef set_nobuild\n#endif\n\tset_option_flag(options, 'F', \"funcs\", PARSE_OPT_EXCLUSIVE);\n\n\targc = parse_options(argc, argv, options, probe_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tif (quiet) {\n\t\tif (verbose != 0) {\n\t\t\tpr_err(\"  Error: -v and -q are exclusive.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tverbose = -1;\n\t}\n\n\tif (argc > 0) {\n\t\tif (strcmp(argv[0], \"-\") == 0) {\n\t\t\tusage_with_options_msg(probe_usage, options,\n\t\t\t\t\"'-' is not supported.\\n\");\n\t\t}\n\t\tif (params->command && params->command != 'a') {\n\t\t\tusage_with_options_msg(probe_usage, options,\n\t\t\t\t\"another command except --add is set.\\n\");\n\t\t}\n\t\tret = parse_probe_event_argv(argc, argv);\n\t\tif (ret < 0) {\n\t\t\tpr_err_with_code(\"  Error: Command Parse Error.\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tparams->command = 'a';\n\t}\n\n\tret = symbol__validate_sym_arguments();\n\tif (ret)\n\t\treturn ret;\n\n\tif (probe_conf.max_probes == 0)\n\t\tprobe_conf.max_probes = MAX_PROBES;\n\n\t \n\tsymbol_conf.try_vmlinux_path = (symbol_conf.vmlinux_name == NULL);\n\n\t \n\tif (!strchr(\"lda\", params->command) && symbol_conf.vmlinux_name)\n\t\tsymbol_conf.ignore_vmlinux_buildid = true;\n\n\tswitch (params->command) {\n\tcase 'l':\n\t\tif (params->uprobes) {\n\t\t\tpr_err(\"  Error: Don't use --list with --exec.\\n\");\n\t\t\tparse_options_usage(probe_usage, options, \"l\", true);\n\t\t\tparse_options_usage(NULL, options, \"x\", true);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = show_perf_probe_events(params->filter);\n\t\tif (ret < 0)\n\t\t\tpr_err_with_code(\"  Error: Failed to show event list.\", ret);\n\t\treturn ret;\n\tcase 'F':\n\t\tret = show_available_funcs(params->target, params->nsi,\n\t\t\t\t\t   params->filter, params->uprobes);\n\t\tif (ret < 0)\n\t\t\tpr_err_with_code(\"  Error: Failed to show functions.\", ret);\n\t\treturn ret;\n#ifdef HAVE_DWARF_SUPPORT\n\tcase 'L':\n\t\tret = show_line_range(&params->line_range, params->target,\n\t\t\t\t      params->nsi, params->uprobes);\n\t\tif (ret < 0)\n\t\t\tpr_err_with_code(\"  Error: Failed to show lines.\", ret);\n\t\treturn ret;\n\tcase 'V':\n\t\tif (!params->filter)\n\t\t\tparams->filter = strfilter__new(DEFAULT_VAR_FILTER,\n\t\t\t\t\t\t       NULL);\n\n\t\tret = show_available_vars(params->events, params->nevents,\n\t\t\t\t\t  params->filter);\n\t\tif (ret < 0)\n\t\t\tpr_err_with_code(\"  Error: Failed to show vars.\", ret);\n\t\treturn ret;\n#endif\n\tcase 'd':\n\t\tret = perf_del_probe_events(params->filter);\n\t\tif (ret < 0) {\n\t\t\tpr_err_with_code(\"  Error: Failed to delete events.\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase 'D':\n\t\tif (probe_conf.bootconfig && params->uprobes) {\n\t\t\tpr_err(\"  Error: --bootconfig doesn't support uprobes.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase 'a':\n\n\t\t \n\t\tif (params->target && !params->target_used) {\n\t\t\tpr_err(\"  Error: -x/-m must follow the probe definitions.\\n\");\n\t\t\tparse_options_usage(probe_usage, options, \"m\", true);\n\t\t\tparse_options_usage(NULL, options, \"x\", true);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = perf_add_probe_events(params->events, params->nevents);\n\t\tif (ret < 0) {\n\n\t\t\t \n\t\t\tparams->nevents = 0;\n\t\t\tpr_err_with_code(\"  Error: Failed to add events.\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tusage_with_options(probe_usage, options);\n\t}\n\treturn 0;\n}\n\nint cmd_probe(int argc, const char **argv)\n{\n\tint ret;\n\n\tret = init_params();\n\tif (!ret) {\n\t\tret = __cmd_probe(argc, argv);\n\t\tcleanup_params();\n\t}\n\n\treturn ret < 0 ? ret : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}