{
  "module_name": "uncore-interconnect.json",
  "hash_id": "fc4db1282970175edb8036c126a7c3b4ab0850669fc190afe0c212a85b0cc923",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/pmu-events/arch/x86/jaketown/uncore-interconnect.json",
  "human_readable_source": "[\n    {\n        \"BriefDescription\": \"Address Match (Conflict) Count; Conflict Merges\",\n        \"EventCode\": \"0x17\",\n        \"EventName\": \"UNC_I_ADDRESS_MATCH.MERGE_COUNT\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times when an inbound write (from a device to memory or another device) had an address match with another request in the write cache.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Address Match (Conflict) Count; Conflict Stalls\",\n        \"EventCode\": \"0x17\",\n        \"EventName\": \"UNC_I_ADDRESS_MATCH.STALL_COUNT\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times when an inbound write (from a device to memory or another device) had an address match with another request in the write cache.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Write Ack Pending Occupancy; Any Source\",\n        \"EventCode\": \"0x14\",\n        \"EventName\": \"UNC_I_CACHE_ACK_PENDING_OCCUPANCY.ANY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of writes that have acquired ownership but have not yet returned their data to the uncore.  These writes are generally queued up in the switch trying to get to the head of their queues so that they can post their data.  The queue occuapancy increments when the ACK is received, and decrements when either the data is returned OR a tickle is received and ownership is released.  Note that a single tickle can result in multiple decrements.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Write Ack Pending Occupancy; Select Source\",\n        \"EventCode\": \"0x14\",\n        \"EventName\": \"UNC_I_CACHE_ACK_PENDING_OCCUPANCY.SOURCE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of writes that have acquired ownership but have not yet returned their data to the uncore.  These writes are generally queued up in the switch trying to get to the head of their queues so that they can post their data.  The queue occuapancy increments when the ACK is received, and decrements when either the data is returned OR a tickle is received and ownership is released.  Note that a single tickle can result in multiple decrements.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Outstanding Write Ownership Occupancy; Any Source\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_I_CACHE_OWN_OCCUPANCY.ANY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of writes (and write prefetches) that are outstanding in the uncore trying to acquire ownership in each cycle.  This can be used with the write transaction count to calculate the average write latency in the uncore.  The occupancy increments when a write request is issued, and decrements when the data is returned.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Outstanding Write Ownership Occupancy; Select Source\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_I_CACHE_OWN_OCCUPANCY.SOURCE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of writes (and write prefetches) that are outstanding in the uncore trying to acquire ownership in each cycle.  This can be used with the write transaction count to calculate the average write latency in the uncore.  The occupancy increments when a write request is issued, and decrements when the data is returned.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Outstanding Read Occupancy; Any Source\",\n        \"EventCode\": \"0x10\",\n        \"EventName\": \"UNC_I_CACHE_READ_OCCUPANCY.ANY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of reads that are outstanding in the uncore in each cycle.  This can be used with the read transaction count to calculate the average read latency in the uncore.  The occupancy increments when a read request is issued, and decrements when the data is returned.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Outstanding Read Occupancy; Select Source\",\n        \"EventCode\": \"0x10\",\n        \"EventName\": \"UNC_I_CACHE_READ_OCCUPANCY.SOURCE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of reads that are outstanding in the uncore in each cycle.  This can be used with the read transaction count to calculate the average read latency in the uncore.  The occupancy increments when a read request is issued, and decrements when the data is returned.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Total Write Cache Occupancy; Any Source\",\n        \"EventCode\": \"0x12\",\n        \"EventName\": \"UNC_I_CACHE_TOTAL_OCCUPANCY.ANY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of reads and writes that are outstanding in the uncore in each cycle.  This is effectively the sum of the READ_OCCUPANCY and WRITE_OCCUPANCY events.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Total Write Cache Occupancy; Select Source\",\n        \"EventCode\": \"0x12\",\n        \"EventName\": \"UNC_I_CACHE_TOTAL_OCCUPANCY.SOURCE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of reads and writes that are outstanding in the uncore in each cycle.  This is effectively the sum of the READ_OCCUPANCY and WRITE_OCCUPANCY events.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Outstanding Write Occupancy; Any Source\",\n        \"EventCode\": \"0x11\",\n        \"EventName\": \"UNC_I_CACHE_WRITE_OCCUPANCY.ANY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of writes (and write prefetches)  that are outstanding in the uncore in each cycle.  This can be used with the transaction count event to calculate the average latency in the uncore.  The occupancy increments when the ownership fetch/prefetch is issued, and decrements the data is returned to the uncore.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Outstanding Write Occupancy; Select Source\",\n        \"EventCode\": \"0x11\",\n        \"EventName\": \"UNC_I_CACHE_WRITE_OCCUPANCY.SOURCE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of writes (and write prefetches)  that are outstanding in the uncore in each cycle.  This can be used with the transaction count event to calculate the average latency in the uncore.  The occupancy increments when the ownership fetch/prefetch is issued, and decrements the data is returned to the uncore.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Clocks in the IRP\",\n        \"EventName\": \"UNC_I_CLOCKTICKS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of clocks in the IRP.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"EventCode\": \"0xB\",\n        \"EventName\": \"UNC_I_RxR_AK_CYCLES_FULL\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the AK Ingress is full.  This queue is where the IRP receives responses from R2PCIe (the ring).\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"AK Ingress Occupancy\",\n        \"EventCode\": \"0xA\",\n        \"EventName\": \"UNC_I_RxR_AK_INSERTS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the AK Ingress.  This queue is where the IRP receives responses from R2PCIe (the ring).\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"EventCode\": \"0xC\",\n        \"EventName\": \"UNC_I_RxR_AK_OCCUPANCY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of the AK Ingress in each cycles.  This queue is where the IRP receives responses from R2PCIe (the ring).\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"EventCode\": \"0x4\",\n        \"EventName\": \"UNC_I_RxR_BL_DRS_CYCLES_FULL\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the BL Ingress is full.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"BL Ingress Occupancy - DRS\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_I_RxR_BL_DRS_INSERTS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the BL Ingress.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"EventCode\": \"0x7\",\n        \"EventName\": \"UNC_I_RxR_BL_DRS_OCCUPANCY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of the BL Ingress in each cycles.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"EventCode\": \"0x5\",\n        \"EventName\": \"UNC_I_RxR_BL_NCB_CYCLES_FULL\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the BL Ingress is full.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"BL Ingress Occupancy - NCB\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_I_RxR_BL_NCB_INSERTS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the BL Ingress.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"EventCode\": \"0x8\",\n        \"EventName\": \"UNC_I_RxR_BL_NCB_OCCUPANCY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of the BL Ingress in each cycles.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"EventCode\": \"0x6\",\n        \"EventName\": \"UNC_I_RxR_BL_NCS_CYCLES_FULL\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the BL Ingress is full.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"BL Ingress Occupancy - NCS\",\n        \"EventCode\": \"0x3\",\n        \"EventName\": \"UNC_I_RxR_BL_NCS_INSERTS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the BL Ingress.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"EventCode\": \"0x9\",\n        \"EventName\": \"UNC_I_RxR_BL_NCS_OCCUPANCY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of the BL Ingress in each cycles.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Tickle Count; Ownership Lost\",\n        \"EventCode\": \"0x16\",\n        \"EventName\": \"UNC_I_TICKLES.LOST_OWNERSHIP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of tickles that are received.  This is for both explicit (from Cbo) and implicit (internal conflict) tickles.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Tickle Count; Data Returned\",\n        \"EventCode\": \"0x16\",\n        \"EventName\": \"UNC_I_TICKLES.TOP_OF_QUEUE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of tickles that are received.  This is for both explicit (from Cbo) and implicit (internal conflict) tickles.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Inbound Transaction Count; Read Prefetches\",\n        \"EventCode\": \"0x15\",\n        \"EventName\": \"UNC_I_TRANSACTIONS.PD_PREFETCHES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of 'Inbound' transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Inbound Transaction Count; Reads\",\n        \"EventCode\": \"0x15\",\n        \"EventName\": \"UNC_I_TRANSACTIONS.READS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of 'Inbound' transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Inbound Transaction Count; Writes\",\n        \"EventCode\": \"0x15\",\n        \"EventName\": \"UNC_I_TRANSACTIONS.WRITES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of 'Inbound' transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"No AD Egress Credit Stalls\",\n        \"EventCode\": \"0x18\",\n        \"EventName\": \"UNC_I_TxR_AD_STALL_CREDIT_CYCLES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number times when it is not possible to issue a request to the R2PCIe because there are no AD Egress Credits available.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"No BL Egress Credit Stalls\",\n        \"EventCode\": \"0x19\",\n        \"EventName\": \"UNC_I_TxR_BL_STALL_CREDIT_CYCLES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number times when it is not possible to issue data to the R2PCIe because there are no BL Egress Credits available.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Outbound Read Requests\",\n        \"EventCode\": \"0xE\",\n        \"EventName\": \"UNC_I_TxR_DATA_INSERTS_NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of requests issued to the switch (towards the devices).\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Outbound Read Requests\",\n        \"EventCode\": \"0xF\",\n        \"EventName\": \"UNC_I_TxR_DATA_INSERTS_NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of requests issued to the switch (towards the devices).\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Outbound Request Queue Occupancy\",\n        \"EventCode\": \"0xD\",\n        \"EventName\": \"UNC_I_TxR_REQUEST_OCCUPANCY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of outstanding outbound requests from the IRP to the switch (towards the devices).  This can be used in conjunction with the allocations event in order to calculate average latency of outbound requests.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Write Ordering Stalls\",\n        \"EventCode\": \"0x1A\",\n        \"EventName\": \"UNC_I_WRITE_ORDERING_STALL_CYCLES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when there are pending write ACK's in the switch but the switch->IRP pipeline is not utilized.\",\n        \"Unit\": \"IRP\"\n    },\n    {\n        \"BriefDescription\": \"Number of qfclks\",\n        \"EventCode\": \"0x14\",\n        \"EventName\": \"UNC_Q_CLOCKTICKS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of clocks in the QPI LL.  This clock runs at 1/8th the 'GT/s' speed of the QPI link.  For example, a 8GT/s link will have qfclk or 1GHz.  JKT does not support dynamic link speeds, so this frequency is fixed.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Count of CTO Events\",\n        \"EventCode\": \"0x38\",\n        \"EventName\": \"UNC_Q_CTO_COUNT\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of CTO (cluster trigger outs) events that were asserted across the two slots.  If both slots trigger in a given cycle, the event will increment by 2.  You can use edge detect to count the number of cases when both events triggered.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Direct 2 Core Spawning; Spawn Failure - Egress Credits\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_Q_DIRECT2CORE.FAILURE_CREDITS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Direct 2 Core Spawning; Spawn Failure - Egress and RBT\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_Q_DIRECT2CORE.FAILURE_CREDITS_RBT\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Direct 2 Core Spawning; Spawn Failure - RBT Not Set\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_Q_DIRECT2CORE.FAILURE_RBT\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Direct 2 Core Spawning; Spawn Success\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_Q_DIRECT2CORE.SUCCESS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Cycles in L1\",\n        \"EventCode\": \"0x12\",\n        \"EventName\": \"UNC_Q_L1_POWER_CYCLES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of QPI qfclk cycles spent in L1 power mode.  L1 is a mode that totally shuts down a QPI link.  Use edge detect to count the number of instances when the QPI link entered L1.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another. Because L1 totally shuts down the link, it takes a good amount of time to exit this mode.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Cycles in L0p\",\n        \"EventCode\": \"0x10\",\n        \"EventName\": \"UNC_Q_RxL0P_POWER_CYCLES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of QPI qfclk cycles spent in L0p power mode.  L0p is a mode where we disable 1/2 of the QPI lanes, decreasing our bandwidth in order to save power.  It increases snoop and data transfer latencies and decreases overall bandwidth.  This mode can be very useful in NUMA optimized workloads that largely only utilize QPI for snoops and their responses.  Use edge detect to count the number of instances when the QPI link entered L0p.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Cycles in L0\",\n        \"EventCode\": \"0xf\",\n        \"EventName\": \"UNC_Q_RxL0_POWER_CYCLES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of QPI qfclk cycles spent in L0 power mode in the Link Layer.  L0 is the default mode which provides the highest performance with the most power.  Use edge detect to count the number of instances that the link entered L0.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.  The phy layer  sometimes leaves L0 for training, which will not be captured by this event.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Rx Flit Buffer Bypassed\",\n        \"EventCode\": \"0x9\",\n        \"EventName\": \"UNC_Q_RxL_BYPASSED\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that an incoming flit was able to bypass the flit buffer and pass directly across the BGF and into the Egress.  This is a latency optimization, and should generally be the common case.  If this value is less than the number of flits transferred, it implies that there was queueing getting onto the ring, and thus the transactions saw higher latency.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"CRC Errors Detected; LinkInit\",\n        \"EventCode\": \"0x3\",\n        \"EventName\": \"UNC_Q_RxL_CRC_ERRORS.LINK_INIT\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of CRC errors detected in the QPI Agent.  Each QPI flit incorporates 8 bits of CRC for error detection.  This counts the number of flits where the CRC was able to detect an error.  After an error has been detected, the QPI agent will send a request to the transmitting socket to resend the flit (as well as any flits that came after it).\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"CRC Errors Detected; Normal Operations\",\n        \"EventCode\": \"0x3\",\n        \"EventName\": \"UNC_Q_RxL_CRC_ERRORS.NORMAL_OP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of CRC errors detected in the QPI Agent.  Each QPI flit incorporates 8 bits of CRC for error detection.  This counts the number of flits where the CRC was able to detect an error.  After an error has been detected, the QPI agent will send a request to the transmitting socket to resend the flit (as well as any flits that came after it).\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Consumed; DRS\",\n        \"EventCode\": \"0x1e\",\n        \"EventName\": \"UNC_Q_RxL_CREDITS_CONSUMED_VN0.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Consumed; HOM\",\n        \"EventCode\": \"0x1e\",\n        \"EventName\": \"UNC_Q_RxL_CREDITS_CONSUMED_VN0.HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Consumed; NCB\",\n        \"EventCode\": \"0x1e\",\n        \"EventName\": \"UNC_Q_RxL_CREDITS_CONSUMED_VN0.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Consumed; NCS\",\n        \"EventCode\": \"0x1e\",\n        \"EventName\": \"UNC_Q_RxL_CREDITS_CONSUMED_VN0.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Consumed; NDR\",\n        \"EventCode\": \"0x1e\",\n        \"EventName\": \"UNC_Q_RxL_CREDITS_CONSUMED_VN0.NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Consumed; SNP\",\n        \"EventCode\": \"0x1e\",\n        \"EventName\": \"UNC_Q_RxL_CREDITS_CONSUMED_VN0.SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA Credit Consumed\",\n        \"EventCode\": \"0x1d\",\n        \"EventName\": \"UNC_Q_RxL_CREDITS_CONSUMED_VNA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that an RxQ VNA credit was consumed (i.e. message uses a VNA credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"RxQ Cycles Not Empty\",\n        \"EventCode\": \"0xa\",\n        \"EventName\": \"UNC_Q_RxL_CYCLES_NE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 0; Data Tx Flits\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G0.DATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 0; Idle and Null Flits\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G0.IDLE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 0; Non-Data protocol Tx Flits\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G0.NON_DATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 1; DRS Flits (both Header and Data)\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G1.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x18\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 1; DRS Data Flits\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G1.DRS_DATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 1; DRS Header Flits\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G1.DRS_NONDATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 1; HOM Flits\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G1.HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x6\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 1; HOM Non-Request Flits\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G1.HOM_NONREQ\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 1; HOM Request Flits\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G1.HOM_REQ\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 1; SNP Flits\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G1.SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 2; Non-Coherent Rx Flits\",\n        \"EventCode\": \"0x3\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G2.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0xc\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 2; Non-Coherent data Rx Flits\",\n        \"EventCode\": \"0x3\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G2.NCB_DATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 2; Non-Coherent non-data Rx Flits\",\n        \"EventCode\": \"0x3\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G2.NCB_NONDATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 2; Non-Coherent standard Rx Flits\",\n        \"EventCode\": \"0x3\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G2.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 2; Non-Data Response Rx Flits - AD\",\n        \"EventCode\": \"0x3\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G2.NDR_AD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Received - Group 2; Non-Data Response Rx Flits - AK\",\n        \"EventCode\": \"0x3\",\n        \"EventName\": \"UNC_Q_RxL_FLITS_G2.NDR_AK\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits received from the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Rx Flit Buffer Allocations\",\n        \"EventCode\": \"0x8\",\n        \"EventName\": \"UNC_Q_RxL_INSERTS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Rx Flit Buffer Allocations - DRS\",\n        \"EventCode\": \"0x9\",\n        \"EventName\": \"UNC_Q_RxL_INSERTS_DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only DRS flits.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Rx Flit Buffer Allocations - HOM\",\n        \"EventCode\": \"0xc\",\n        \"EventName\": \"UNC_Q_RxL_INSERTS_HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only HOM flits.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Rx Flit Buffer Allocations - NCB\",\n        \"EventCode\": \"0xa\",\n        \"EventName\": \"UNC_Q_RxL_INSERTS_NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NCB flits.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Rx Flit Buffer Allocations - NCS\",\n        \"EventCode\": \"0xb\",\n        \"EventName\": \"UNC_Q_RxL_INSERTS_NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NCS flits.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Rx Flit Buffer Allocations - NDR\",\n        \"EventCode\": \"0xe\",\n        \"EventName\": \"UNC_Q_RxL_INSERTS_NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NDR flits.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Rx Flit Buffer Allocations - SNP\",\n        \"EventCode\": \"0xd\",\n        \"EventName\": \"UNC_Q_RxL_INSERTS_SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only SNP flits.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"RxQ Occupancy - All Packets\",\n        \"EventCode\": \"0xb\",\n        \"EventName\": \"UNC_Q_RxL_OCCUPANCY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"RxQ Occupancy - DRS\",\n        \"EventCode\": \"0x15\",\n        \"EventName\": \"UNC_Q_RxL_OCCUPANCY_DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors DRS flits only.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"RxQ Occupancy - HOM\",\n        \"EventCode\": \"0x18\",\n        \"EventName\": \"UNC_Q_RxL_OCCUPANCY_HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors HOM flits only.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"RxQ Occupancy - NCB\",\n        \"EventCode\": \"0x16\",\n        \"EventName\": \"UNC_Q_RxL_OCCUPANCY_NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NCB flits only.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"RxQ Occupancy - NCS\",\n        \"EventCode\": \"0x17\",\n        \"EventName\": \"UNC_Q_RxL_OCCUPANCY_NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NCS flits only.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"RxQ Occupancy - NDR\",\n        \"EventCode\": \"0x1a\",\n        \"EventName\": \"UNC_Q_RxL_OCCUPANCY_NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NDR flits only.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"RxQ Occupancy - SNP\",\n        \"EventCode\": \"0x19\",\n        \"EventName\": \"UNC_Q_RxL_OCCUPANCY_SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors SNP flits only.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Stalls Sending to R3QPI; BGF Stall - HOM\",\n        \"EventCode\": \"0x35\",\n        \"EventName\": \"UNC_Q_RxL_STALLS.BGF_DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of stalls trying to send to R3QPI.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Stalls Sending to R3QPI; BGF Stall - DRS\",\n        \"EventCode\": \"0x35\",\n        \"EventName\": \"UNC_Q_RxL_STALLS.BGF_HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of stalls trying to send to R3QPI.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Stalls Sending to R3QPI; BGF Stall - SNP\",\n        \"EventCode\": \"0x35\",\n        \"EventName\": \"UNC_Q_RxL_STALLS.BGF_NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of stalls trying to send to R3QPI.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Stalls Sending to R3QPI; BGF Stall - NDR\",\n        \"EventCode\": \"0x35\",\n        \"EventName\": \"UNC_Q_RxL_STALLS.BGF_NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of stalls trying to send to R3QPI.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Stalls Sending to R3QPI; BGF Stall - NCS\",\n        \"EventCode\": \"0x35\",\n        \"EventName\": \"UNC_Q_RxL_STALLS.BGF_NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of stalls trying to send to R3QPI.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Stalls Sending to R3QPI; BGF Stall - NCB\",\n        \"EventCode\": \"0x35\",\n        \"EventName\": \"UNC_Q_RxL_STALLS.BGF_SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of stalls trying to send to R3QPI.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Stalls Sending to R3QPI; Egress Credits\",\n        \"EventCode\": \"0x35\",\n        \"EventName\": \"UNC_Q_RxL_STALLS.EGRESS_CREDITS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of stalls trying to send to R3QPI.\",\n        \"UMask\": \"0x40\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Stalls Sending to R3QPI; GV\",\n        \"EventCode\": \"0x35\",\n        \"EventName\": \"UNC_Q_RxL_STALLS.GV\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of stalls trying to send to R3QPI.\",\n        \"UMask\": \"0x80\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Cycles in L0p\",\n        \"EventCode\": \"0xd\",\n        \"EventName\": \"UNC_Q_TxL0P_POWER_CYCLES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of QPI qfclk cycles spent in L0p power mode.  L0p is a mode where we disable 1/2 of the QPI lanes, decreasing our bandwidth in order to save power.  It increases snoop and data transfer latencies and decreases overall bandwidth.  This mode can be very useful in NUMA optimized workloads that largely only utilize QPI for snoops and their responses.  Use edge detect to count the number of instances when the QPI link entered L0p.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Cycles in L0\",\n        \"EventCode\": \"0xc\",\n        \"EventName\": \"UNC_Q_TxL0_POWER_CYCLES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of QPI qfclk cycles spent in L0 power mode in the Link Layer.  L0 is the default mode which provides the highest performance with the most power.  Use edge detect to count the number of instances that the link entered L0.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.  The phy layer  sometimes leaves L0 for training, which will not be captured by this event.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Tx Flit Buffer Bypassed\",\n        \"EventCode\": \"0x5\",\n        \"EventName\": \"UNC_Q_TxL_BYPASSED\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that an incoming flit was able to bypass the Tx flit buffer and pass directly out the QPI Link. Generally, when data is transmitted across QPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Cycles Stalled with no LLR Credits; LLR is almost full\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_Q_TxL_CRC_NO_CREDITS.ALMOST_FULL\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of cycles when the Tx side ran out of Link Layer Retry credits, causing the Tx to stall.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Cycles Stalled with no LLR Credits; LLR is full\",\n        \"EventCode\": \"0x2\",\n        \"EventName\": \"UNC_Q_TxL_CRC_NO_CREDITS.FULL\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of cycles when the Tx side ran out of Link Layer Retry credits, causing the Tx to stall.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Tx Flit Buffer Cycles not Empty\",\n        \"EventCode\": \"0x6\",\n        \"EventName\": \"UNC_Q_TxL_CYCLES_NE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the TxQ is not empty. Generally, when data is transmitted across QPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 0; Data Tx Flits\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G0.DATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 0; Idle and Null Flits\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G0.IDLE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 0; Non-Data protocol Tx Flits\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G0.NON_DATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 1; DRS Flits (both Header and Data)\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G1.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x18\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 1; DRS Data Flits\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G1.DRS_DATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 1; DRS Header Flits\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G1.DRS_NONDATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 1; HOM Flits\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G1.HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x6\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 1; HOM Non-Request Flits\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G1.HOM_NONREQ\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 1; HOM Request Flits\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G1.HOM_REQ\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 1; SNP Flits\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G1.SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 2; Non-Coherent Bypass Tx Flits\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G2.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0xc\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 2; Non-Coherent data Tx Flits\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G2.NCB_DATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 2; Non-Coherent non-data Tx Flits\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G2.NCB_NONDATA\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 2; Non-Coherent standard Tx Flits\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G2.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 2; Non-Data Response Tx Flits - AD\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G2.NDR_AD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Flits Transferred - Group 2; Non-Data Response Tx Flits - AK\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_Q_TxL_FLITS_G2.NDR_AK\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of flits transmitted across the QPI Link.  This is one of three 'groups' that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each 'flit' is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four 'fits', each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI 'speed' (for example, 8.0 GT/s), the 'transfers' here refer to 'fits'.  Therefore, in L0, the system will transfer 1 'flit' at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as 'data' bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual 'data' and an additional 16 bits of other information.  To calculate 'data' bandwidth, one should therefore do: data flits * 8B / time.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Tx Flit Buffer Allocations\",\n        \"EventCode\": \"0x4\",\n        \"EventName\": \"UNC_Q_TxL_INSERTS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of allocations into the QPI Tx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Tx Flit Buffer Occupancy\",\n        \"EventCode\": \"0x7\",\n        \"EventName\": \"UNC_Q_TxL_OCCUPANCY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the number of flits in the TxQ.  Generally, when data is transmitted across QPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link. This can be used with the cycles not empty event to track average occupancy, or the allocations event to track average lifetime in the TxQ.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA Credits Returned\",\n        \"EventCode\": \"0x1c\",\n        \"EventName\": \"UNC_Q_VNA_CREDIT_RETURNS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of VNA credits returned.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA Credits Pending Return - Occupancy\",\n        \"EventCode\": \"0x1b\",\n        \"EventName\": \"UNC_Q_VNA_CREDIT_RETURN_OCCUPANCY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of VNA credits in the Rx side that are waitng to be returned back across the link.\",\n        \"Unit\": \"QPI\"\n    },\n    {\n        \"BriefDescription\": \"Number of uclks in domain\",\n        \"EventCode\": \"0x1\",\n        \"EventName\": \"UNC_R3_CLOCKTICKS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of uclks in the QPI uclk domain.  This could be slightly different than the count in the Ubox because of enable/freeze delays.  However, because the QPI Agent is close to the Ubox, they generally should not diverge by more than a handful of cycles.\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"to IIO BL Credit Acquired\",\n        \"EventCode\": \"0x20\",\n        \"EventName\": \"UNC_R3_IIO_CREDITS_ACQUIRED.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times the NCS/NCB/DRS credit is acquired in the QPI for sending messages on BL to the IIO.  There is one credit for each of these three message classes (three credits total).  NCS is used for reads to PCIe space, NCB is used for transferring data without coherency, and DRS is used for transferring data with coherency (cacheable PCI transactions).  This event can only track one message class at a time.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"to IIO BL Credit Acquired\",\n        \"EventCode\": \"0x20\",\n        \"EventName\": \"UNC_R3_IIO_CREDITS_ACQUIRED.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times the NCS/NCB/DRS credit is acquired in the QPI for sending messages on BL to the IIO.  There is one credit for each of these three message classes (three credits total).  NCS is used for reads to PCIe space, NCB is used for transferring data without coherency, and DRS is used for transferring data with coherency (cacheable PCI transactions).  This event can only track one message class at a time.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"to IIO BL Credit Acquired\",\n        \"EventCode\": \"0x20\",\n        \"EventName\": \"UNC_R3_IIO_CREDITS_ACQUIRED.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times the NCS/NCB/DRS credit is acquired in the QPI for sending messages on BL to the IIO.  There is one credit for each of these three message classes (three credits total).  NCS is used for reads to PCIe space, NCB is used for transferring data without coherency, and DRS is used for transferring data with coherency (cacheable PCI transactions).  This event can only track one message class at a time.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"to IIO BL Credit Rejected\",\n        \"EventCode\": \"0x21\",\n        \"EventName\": \"UNC_R3_IIO_CREDITS_REJECT.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that a request attempted to acquire an NCS/NCB/DRS credit in the QPI for sending messages on BL to the IIO but was rejected because no credit was available.  There is one credit for each of these three message classes (three credits total).  NCS is used for reads to PCIe space, NCB is used for transferring data without coherency, and DRS is used for transferring data with coherency (cacheable PCI transactions).  This event can only track one message class at a time.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"to IIO BL Credit Rejected\",\n        \"EventCode\": \"0x21\",\n        \"EventName\": \"UNC_R3_IIO_CREDITS_REJECT.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that a request attempted to acquire an NCS/NCB/DRS credit in the QPI for sending messages on BL to the IIO but was rejected because no credit was available.  There is one credit for each of these three message classes (three credits total).  NCS is used for reads to PCIe space, NCB is used for transferring data without coherency, and DRS is used for transferring data with coherency (cacheable PCI transactions).  This event can only track one message class at a time.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"to IIO BL Credit Rejected\",\n        \"EventCode\": \"0x21\",\n        \"EventName\": \"UNC_R3_IIO_CREDITS_REJECT.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times that a request attempted to acquire an NCS/NCB/DRS credit in the QPI for sending messages on BL to the IIO but was rejected because no credit was available.  There is one credit for each of these three message classes (three credits total).  NCS is used for reads to PCIe space, NCB is used for transferring data without coherency, and DRS is used for transferring data with coherency (cacheable PCI transactions).  This event can only track one message class at a time.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"to IIO BL Credit In Use\",\n        \"EventCode\": \"0x22\",\n        \"EventName\": \"UNC_R3_IIO_CREDITS_USED.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the NCS/NCB/DRS credit is in use in the QPI for sending messages on BL to the IIO.  There is one credit for each of these three message classes (three credits total).  NCS is used for reads to PCIe space, NCB is used for transferring data without coherency, and DRS is used for transferring data with coherency (cacheable PCI transactions).  This event can only track one message class at a time.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"to IIO BL Credit In Use\",\n        \"EventCode\": \"0x22\",\n        \"EventName\": \"UNC_R3_IIO_CREDITS_USED.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the NCS/NCB/DRS credit is in use in the QPI for sending messages on BL to the IIO.  There is one credit for each of these three message classes (three credits total).  NCS is used for reads to PCIe space, NCB is used for transferring data without coherency, and DRS is used for transferring data with coherency (cacheable PCI transactions).  This event can only track one message class at a time.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"to IIO BL Credit In Use\",\n        \"EventCode\": \"0x22\",\n        \"EventName\": \"UNC_R3_IIO_CREDITS_USED.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the NCS/NCB/DRS credit is in use in the QPI for sending messages on BL to the IIO.  There is one credit for each of these three message classes (three credits total).  NCS is used for reads to PCIe space, NCB is used for transferring data without coherency, and DRS is used for transferring data with coherency (cacheable PCI transactions).  This event can only track one message class at a time.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 AD Ring in Use; Counterclockwise and Even\",\n        \"EventCode\": \"0x7\",\n        \"EventName\": \"UNC_R3_RING_AD_USED.CCW_EVEN\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 AD Ring in Use; Counterclockwise and Odd\",\n        \"EventCode\": \"0x7\",\n        \"EventName\": \"UNC_R3_RING_AD_USED.CCW_ODD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 AD Ring in Use; Clockwise and Even\",\n        \"EventCode\": \"0x7\",\n        \"EventName\": \"UNC_R3_RING_AD_USED.CW_EVEN\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 AD Ring in Use; Clockwise and Odd\",\n        \"EventCode\": \"0x7\",\n        \"EventName\": \"UNC_R3_RING_AD_USED.CW_ODD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 AK Ring in Use; Counterclockwise and Even\",\n        \"EventCode\": \"0x8\",\n        \"EventName\": \"UNC_R3_RING_AK_USED.CCW_EVEN\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sent, but does not include when packets are being sunk into the ring stop.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 AK Ring in Use; Counterclockwise and Odd\",\n        \"EventCode\": \"0x8\",\n        \"EventName\": \"UNC_R3_RING_AK_USED.CCW_ODD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sent, but does not include when packets are being sunk into the ring stop.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 AK Ring in Use; Clockwise and Even\",\n        \"EventCode\": \"0x8\",\n        \"EventName\": \"UNC_R3_RING_AK_USED.CW_EVEN\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sent, but does not include when packets are being sunk into the ring stop.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 AK Ring in Use; Clockwise and Odd\",\n        \"EventCode\": \"0x8\",\n        \"EventName\": \"UNC_R3_RING_AK_USED.CW_ODD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sent, but does not include when packets are being sunk into the ring stop.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 BL Ring in Use; Counterclockwise and Even\",\n        \"EventCode\": \"0x9\",\n        \"EventName\": \"UNC_R3_RING_BL_USED.CCW_EVEN\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 BL Ring in Use; Counterclockwise and Odd\",\n        \"EventCode\": \"0x9\",\n        \"EventName\": \"UNC_R3_RING_BL_USED.CCW_ODD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 BL Ring in Use; Clockwise and Even\",\n        \"EventCode\": \"0x9\",\n        \"EventName\": \"UNC_R3_RING_BL_USED.CW_EVEN\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 BL Ring in Use; Clockwise and Odd\",\n        \"EventCode\": \"0x9\",\n        \"EventName\": \"UNC_R3_RING_BL_USED.CW_ODD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"R3 IV Ring in Use; Any\",\n        \"EventCode\": \"0xa\",\n        \"EventName\": \"UNC_R3_RING_IV_USED.ANY\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles that the IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sent, but does not include when packets are being sunk into the ring stop.  The IV ring is unidirectional.  Whether UP or DN is used is dependent on the system programming.  Thereofore, one should generally set both the UP and DN bits for a given polarity (or both) at a given time.\",\n        \"UMask\": \"0xf\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Bypassed\",\n        \"EventCode\": \"0x12\",\n        \"EventName\": \"UNC_R3_RxR_BYPASSED.AD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of times when the Ingress was bypassed and an incoming transaction was bypassed directly across the BGF and into the qfclk domain.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Cycles Not Empty; DRS\",\n        \"EventCode\": \"0x10\",\n        \"EventName\": \"UNC_R3_RxR_CYCLES_NE.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the QPI Ingress is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Cycles Not Empty; HOM\",\n        \"EventCode\": \"0x10\",\n        \"EventName\": \"UNC_R3_RxR_CYCLES_NE.HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the QPI Ingress is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Cycles Not Empty; NCB\",\n        \"EventCode\": \"0x10\",\n        \"EventName\": \"UNC_R3_RxR_CYCLES_NE.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the QPI Ingress is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Cycles Not Empty; NCS\",\n        \"EventCode\": \"0x10\",\n        \"EventName\": \"UNC_R3_RxR_CYCLES_NE.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the QPI Ingress is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Cycles Not Empty; NDR\",\n        \"EventCode\": \"0x10\",\n        \"EventName\": \"UNC_R3_RxR_CYCLES_NE.NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the QPI Ingress is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Cycles Not Empty; SNP\",\n        \"EventCode\": \"0x10\",\n        \"EventName\": \"UNC_R3_RxR_CYCLES_NE.SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of cycles when the QPI Ingress is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Allocations; DRS\",\n        \"EventCode\": \"0x11\",\n        \"EventName\": \"UNC_R3_RxR_INSERTS.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the QPI Ingress.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Allocations; HOM\",\n        \"EventCode\": \"0x11\",\n        \"EventName\": \"UNC_R3_RxR_INSERTS.HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the QPI Ingress.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Allocations; NCB\",\n        \"EventCode\": \"0x11\",\n        \"EventName\": \"UNC_R3_RxR_INSERTS.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the QPI Ingress.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Allocations; NCS\",\n        \"EventCode\": \"0x11\",\n        \"EventName\": \"UNC_R3_RxR_INSERTS.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the QPI Ingress.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Allocations; NDR\",\n        \"EventCode\": \"0x11\",\n        \"EventName\": \"UNC_R3_RxR_INSERTS.NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the QPI Ingress.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Allocations; SNP\",\n        \"EventCode\": \"0x11\",\n        \"EventName\": \"UNC_R3_RxR_INSERTS.SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Counts the number of allocations into the QPI Ingress.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Occupancy Accumulator; DRS\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_R3_RxR_OCCUPANCY.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of a given QPI Ingress queue in each cycles.  This tracks one of the three ring Ingress buffers.  This can be used with the QPI Ingress Not Empty event to calculate average occupancy or the QPI Ingress Allocations event in order to calculate average queuing latency.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Occupancy Accumulator; HOM\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_R3_RxR_OCCUPANCY.HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of a given QPI Ingress queue in each cycles.  This tracks one of the three ring Ingress buffers.  This can be used with the QPI Ingress Not Empty event to calculate average occupancy or the QPI Ingress Allocations event in order to calculate average queuing latency.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Occupancy Accumulator; NCB\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_R3_RxR_OCCUPANCY.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of a given QPI Ingress queue in each cycles.  This tracks one of the three ring Ingress buffers.  This can be used with the QPI Ingress Not Empty event to calculate average occupancy or the QPI Ingress Allocations event in order to calculate average queuing latency.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Occupancy Accumulator; NCS\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_R3_RxR_OCCUPANCY.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of a given QPI Ingress queue in each cycles.  This tracks one of the three ring Ingress buffers.  This can be used with the QPI Ingress Not Empty event to calculate average occupancy or the QPI Ingress Allocations event in order to calculate average queuing latency.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Occupancy Accumulator; NDR\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_R3_RxR_OCCUPANCY.NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of a given QPI Ingress queue in each cycles.  This tracks one of the three ring Ingress buffers.  This can be used with the QPI Ingress Not Empty event to calculate average occupancy or the QPI Ingress Allocations event in order to calculate average queuing latency.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Ingress Occupancy Accumulator; SNP\",\n        \"EventCode\": \"0x13\",\n        \"EventName\": \"UNC_R3_RxR_OCCUPANCY.SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Accumulates the occupancy of a given QPI Ingress queue in each cycles.  This tracks one of the three ring Ingress buffers.  This can be used with the QPI Ingress Not Empty event to calculate average occupancy or the QPI Ingress Allocations event in order to calculate average queuing latency.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Acquisition Failed on DRS; DRS Message Class\",\n        \"EventCode\": \"0x37\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_REJECT.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a request failed to acquire a DRS VN0 credit.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This therefore counts the number of times when a request failed to acquire either a VNA or VN0 credit and is delayed.  This should generally be a rare situation.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Acquisition Failed on DRS; HOM Message Class\",\n        \"EventCode\": \"0x37\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_REJECT.HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a request failed to acquire a DRS VN0 credit.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This therefore counts the number of times when a request failed to acquire either a VNA or VN0 credit and is delayed.  This should generally be a rare situation.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Acquisition Failed on DRS; NCB Message Class\",\n        \"EventCode\": \"0x37\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_REJECT.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a request failed to acquire a DRS VN0 credit.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This therefore counts the number of times when a request failed to acquire either a VNA or VN0 credit and is delayed.  This should generally be a rare situation.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Acquisition Failed on DRS; NCS Message Class\",\n        \"EventCode\": \"0x37\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_REJECT.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a request failed to acquire a DRS VN0 credit.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This therefore counts the number of times when a request failed to acquire either a VNA or VN0 credit and is delayed.  This should generally be a rare situation.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Acquisition Failed on DRS; NDR Message Class\",\n        \"EventCode\": \"0x37\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_REJECT.NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a request failed to acquire a DRS VN0 credit.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This therefore counts the number of times when a request failed to acquire either a VNA or VN0 credit and is delayed.  This should generally be a rare situation.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Acquisition Failed on DRS; SNP Message Class\",\n        \"EventCode\": \"0x37\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_REJECT.SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a request failed to acquire a DRS VN0 credit.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This therefore counts the number of times when a request failed to acquire either a VNA or VN0 credit and is delayed.  This should generally be a rare situation.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Used; DRS Message Class\",\n        \"EventCode\": \"0x36\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_USED.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Used; HOM Message Class\",\n        \"EventCode\": \"0x36\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_USED.HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Used; NCB Message Class\",\n        \"EventCode\": \"0x36\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_USED.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Used; NCS Message Class\",\n        \"EventCode\": \"0x36\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_USED.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Used; NDR Message Class\",\n        \"EventCode\": \"0x36\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_USED.NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VN0 Credit Used; SNP Message Class\",\n        \"EventCode\": \"0x36\",\n        \"EventName\": \"UNC_R3_VN0_CREDITS_USED.SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA credit Acquisitions\",\n        \"EventCode\": \"0x33\",\n        \"EventName\": \"UNC_R3_VNA_CREDITS_ACQUIRED\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of QPI VNA Credit acquisitions.  This event can be used in conjunction with the VNA In-Use Accumulator to calculate the average lifetime of a credit holder.  VNA credits are used by all message classes in order to communicate across QPI.  If a packet is unable to acquire credits, it will then attempt to use credits from the VN0 pool.  Note that a single packet may require multiple flit buffers (i.e. when data is being transferred).  Therefore, this event will increment by the number of credits acquired in each cycle.  Filtering based on message class is not provided.  One can count the number of packets transferred in a given message class using an qfclk event.\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA Credit Reject; DRS Message Class\",\n        \"EventCode\": \"0x34\",\n        \"EventName\": \"UNC_R3_VNA_CREDITS_REJECT.DRS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of attempted VNA credit acquisitions that were rejected because the VNA credit pool was full (or almost full).  It is possible to filter this event by message class.  Some packets use more than one flit buffer, and therefore must acquire multiple credits.  Therefore, one could get a reject even if the VNA credits were not fully used up.  The VNA pool is generally used to provide the bulk of the QPI bandwidth (as opposed to the VN0 pool which is used to guarantee forward progress).  VNA credits can run out if the flit buffer on the receiving side starts to queue up substantially.  This can happen if the rest of the uncore is unable to drain the requests fast enough.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA Credit Reject; HOM Message Class\",\n        \"EventCode\": \"0x34\",\n        \"EventName\": \"UNC_R3_VNA_CREDITS_REJECT.HOM\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of attempted VNA credit acquisitions that were rejected because the VNA credit pool was full (or almost full).  It is possible to filter this event by message class.  Some packets use more than one flit buffer, and therefore must acquire multiple credits.  Therefore, one could get a reject even if the VNA credits were not fully used up.  The VNA pool is generally used to provide the bulk of the QPI bandwidth (as opposed to the VN0 pool which is used to guarantee forward progress).  VNA credits can run out if the flit buffer on the receiving side starts to queue up substantially.  This can happen if the rest of the uncore is unable to drain the requests fast enough.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA Credit Reject; NCB Message Class\",\n        \"EventCode\": \"0x34\",\n        \"EventName\": \"UNC_R3_VNA_CREDITS_REJECT.NCB\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of attempted VNA credit acquisitions that were rejected because the VNA credit pool was full (or almost full).  It is possible to filter this event by message class.  Some packets use more than one flit buffer, and therefore must acquire multiple credits.  Therefore, one could get a reject even if the VNA credits were not fully used up.  The VNA pool is generally used to provide the bulk of the QPI bandwidth (as opposed to the VN0 pool which is used to guarantee forward progress).  VNA credits can run out if the flit buffer on the receiving side starts to queue up substantially.  This can happen if the rest of the uncore is unable to drain the requests fast enough.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA Credit Reject; NCS Message Class\",\n        \"EventCode\": \"0x34\",\n        \"EventName\": \"UNC_R3_VNA_CREDITS_REJECT.NCS\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of attempted VNA credit acquisitions that were rejected because the VNA credit pool was full (or almost full).  It is possible to filter this event by message class.  Some packets use more than one flit buffer, and therefore must acquire multiple credits.  Therefore, one could get a reject even if the VNA credits were not fully used up.  The VNA pool is generally used to provide the bulk of the QPI bandwidth (as opposed to the VN0 pool which is used to guarantee forward progress).  VNA credits can run out if the flit buffer on the receiving side starts to queue up substantially.  This can happen if the rest of the uncore is unable to drain the requests fast enough.\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA Credit Reject; NDR Message Class\",\n        \"EventCode\": \"0x34\",\n        \"EventName\": \"UNC_R3_VNA_CREDITS_REJECT.NDR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of attempted VNA credit acquisitions that were rejected because the VNA credit pool was full (or almost full).  It is possible to filter this event by message class.  Some packets use more than one flit buffer, and therefore must acquire multiple credits.  Therefore, one could get a reject even if the VNA credits were not fully used up.  The VNA pool is generally used to provide the bulk of the QPI bandwidth (as opposed to the VN0 pool which is used to guarantee forward progress).  VNA credits can run out if the flit buffer on the receiving side starts to queue up substantially.  This can happen if the rest of the uncore is unable to drain the requests fast enough.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"VNA Credit Reject; SNP Message Class\",\n        \"EventCode\": \"0x34\",\n        \"EventName\": \"UNC_R3_VNA_CREDITS_REJECT.SNP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of attempted VNA credit acquisitions that were rejected because the VNA credit pool was full (or almost full).  It is possible to filter this event by message class.  Some packets use more than one flit buffer, and therefore must acquire multiple credits.  Therefore, one could get a reject even if the VNA credits were not fully used up.  The VNA pool is generally used to provide the bulk of the QPI bandwidth (as opposed to the VN0 pool which is used to guarantee forward progress).  VNA credits can run out if the flit buffer on the receiving side starts to queue up substantially.  This can happen if the rest of the uncore is unable to drain the requests fast enough.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Cycles with no VNA credits available\",\n        \"EventCode\": \"0x31\",\n        \"EventName\": \"UNC_R3_VNA_CREDIT_CYCLES_OUT\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of QPI uclk cycles when the transmitted has no VNA credits available and therefore cannot send any requests on this channel.  Note that this does not mean that no flits can be transmitted, as those holding VN0 credits will still (potentially) be able to transmit.  Generally it is the goal of the uncore that VNA credits should not run out, as this can substantially throttle back useful QPI bandwidth.\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"BriefDescription\": \"Cycles with 1 or more VNA credits in use\",\n        \"EventCode\": \"0x32\",\n        \"EventName\": \"UNC_R3_VNA_CREDIT_CYCLES_USED\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of QPI uclk cycles with one or more VNA credits in use.  This event can be used in conjunction with the VNA In-Use Accumulator to calculate the average number of used VNA credits.\",\n        \"Unit\": \"R3QPI\"\n    },\n    {\n        \"EventName\": \"UNC_U_CLOCKTICKS\",\n        \"PerPkg\": \"1\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"VLW Received\",\n        \"EventCode\": \"0x42\",\n        \"EventName\": \"UNC_U_EVENT_MSG.DOORBELL_RCVD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Virtual Logical Wire (legacy) message were received from Uncore.   Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"VLW Received\",\n        \"EventCode\": \"0x42\",\n        \"EventName\": \"UNC_U_EVENT_MSG.INT_PRIO\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Virtual Logical Wire (legacy) message were received from Uncore.   Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"VLW Received\",\n        \"EventCode\": \"0x42\",\n        \"EventName\": \"UNC_U_EVENT_MSG.IPI_RCVD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Virtual Logical Wire (legacy) message were received from Uncore.   Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"VLW Received\",\n        \"EventCode\": \"0x42\",\n        \"EventName\": \"UNC_U_EVENT_MSG.MSI_RCVD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Virtual Logical Wire (legacy) message were received from Uncore.   Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"VLW Received\",\n        \"EventCode\": \"0x42\",\n        \"EventName\": \"UNC_U_EVENT_MSG.VLW_RCVD\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Virtual Logical Wire (legacy) message were received from Uncore.   Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Filter Match\",\n        \"EventCode\": \"0x41\",\n        \"EventName\": \"UNC_U_FILTER_MATCH.DISABLE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Filter match per thread (w/ or w/o Filter Enable).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Filter Match\",\n        \"EventCode\": \"0x41\",\n        \"EventName\": \"UNC_U_FILTER_MATCH.ENABLE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Filter match per thread (w/ or w/o Filter Enable).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Filter Match\",\n        \"EventCode\": \"0x41\",\n        \"EventName\": \"UNC_U_FILTER_MATCH.U2C_DISABLE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Filter match per thread (w/ or w/o Filter Enable).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Filter Match\",\n        \"EventCode\": \"0x41\",\n        \"EventName\": \"UNC_U_FILTER_MATCH.U2C_ENABLE\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Filter match per thread (w/ or w/o Filter Enable).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"IDI Lock/SplitLock Cycles\",\n        \"EventCode\": \"0x44\",\n        \"EventName\": \"UNC_U_LOCK_CYCLES\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of times an IDI Lock/SplitLock sequence was started\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"MsgCh Requests by Size; 4B Requests\",\n        \"EventCode\": \"0x47\",\n        \"EventName\": \"UNC_U_MSG_CHNL_SIZE_COUNT.4B\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of transactions on the message channel filtered by request size.  This includes both reads and writes.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"MsgCh Requests by Size; 8B Requests\",\n        \"EventCode\": \"0x47\",\n        \"EventName\": \"UNC_U_MSG_CHNL_SIZE_COUNT.8B\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Number of transactions on the message channel filtered by request size.  This includes both reads and writes.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Cycles PHOLD Assert to Ack; ACK to Deassert\",\n        \"EventCode\": \"0x45\",\n        \"EventName\": \"UNC_U_PHOLD_CYCLES.ACK_TO_DEASSERT\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"PHOLD cycles.  Filter from source CoreID.\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Cycles PHOLD Assert to Ack; Assert to ACK\",\n        \"EventCode\": \"0x45\",\n        \"EventName\": \"UNC_U_PHOLD_CYCLES.ASSERT_TO_ACK\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"PHOLD cycles.  Filter from source CoreID.\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"RACU Request\",\n        \"EventCode\": \"0x46\",\n        \"EventName\": \"UNC_U_RACU_REQUESTS.COUNT\",\n        \"PerPkg\": \"1\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Monitor Sent to T0; Correctable Machine Check\",\n        \"EventCode\": \"0x43\",\n        \"EventName\": \"UNC_U_U2C_EVENTS.CMC\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Events coming from Uncore can be sent to one or all cores\",\n        \"UMask\": \"0x10\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Monitor Sent to T0; Livelock\",\n        \"EventCode\": \"0x43\",\n        \"EventName\": \"UNC_U_U2C_EVENTS.LIVELOCK\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Events coming from Uncore can be sent to one or all cores\",\n        \"UMask\": \"0x4\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Monitor Sent to T0; LTError\",\n        \"EventCode\": \"0x43\",\n        \"EventName\": \"UNC_U_U2C_EVENTS.LTERROR\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Events coming from Uncore can be sent to one or all cores\",\n        \"UMask\": \"0x8\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Monitor Sent to T0; Monitor T0\",\n        \"EventCode\": \"0x43\",\n        \"EventName\": \"UNC_U_U2C_EVENTS.MONITOR_T0\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Events coming from Uncore can be sent to one or all cores\",\n        \"UMask\": \"0x1\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Monitor Sent to T0; Monitor T1\",\n        \"EventCode\": \"0x43\",\n        \"EventName\": \"UNC_U_U2C_EVENTS.MONITOR_T1\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Events coming from Uncore can be sent to one or all cores\",\n        \"UMask\": \"0x2\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Monitor Sent to T0; Other\",\n        \"EventCode\": \"0x43\",\n        \"EventName\": \"UNC_U_U2C_EVENTS.OTHER\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Events coming from Uncore can be sent to one or all cores\",\n        \"UMask\": \"0x80\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Monitor Sent to T0; Trap\",\n        \"EventCode\": \"0x43\",\n        \"EventName\": \"UNC_U_U2C_EVENTS.TRAP\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Events coming from Uncore can be sent to one or all cores\",\n        \"UMask\": \"0x40\",\n        \"Unit\": \"UBOX\"\n    },\n    {\n        \"BriefDescription\": \"Monitor Sent to T0; Uncorrectable Machine Check\",\n        \"EventCode\": \"0x43\",\n        \"EventName\": \"UNC_U_U2C_EVENTS.UMC\",\n        \"PerPkg\": \"1\",\n        \"PublicDescription\": \"Events coming from Uncore can be sent to one or all cores\",\n        \"UMask\": \"0x20\",\n        \"Unit\": \"UBOX\"\n    }\n]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}