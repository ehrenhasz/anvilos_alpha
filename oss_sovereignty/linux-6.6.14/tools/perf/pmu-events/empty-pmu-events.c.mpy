{
  "module_name": "empty-pmu-events.c",
  "hash_id": "c734d0d713882ce64daed78e95ef147e7619eaa643073757de5e45adb8180b12",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/pmu-events/empty-pmu-events.c",
  "human_readable_source": "\n \n#include \"pmu-events/pmu-events.h\"\n#include \"util/header.h\"\n#include \"util/pmu.h\"\n#include <string.h>\n#include <stddef.h>\n\nstatic const struct pmu_event pmu_events__test_soc_cpu[] = {\n\t{\n\t\t.name = \"l3_cache_rd\",\n\t\t.event = \"event=0x40\",\n\t\t.desc = \"L3 cache access, read\",\n\t\t.topic = \"cache\",\n\t\t.long_desc = \"Attributable Level 3 cache access, read\",\n\t},\n\t{\n\t\t.name = \"segment_reg_loads.any\",\n\t\t.event = \"event=0x6,period=200000,umask=0x80\",\n\t\t.desc = \"Number of segment register loads\",\n\t\t.topic = \"other\",\n\t},\n\t{\n\t\t.name = \"dispatch_blocked.any\",\n\t\t.event = \"event=0x9,period=200000,umask=0x20\",\n\t\t.desc = \"Memory cluster signals to block micro-op dispatch for any reason\",\n\t\t.topic = \"other\",\n\t},\n\t{\n\t\t.name = \"eist_trans\",\n\t\t.event = \"event=0x3a,period=200000,umask=0x0\",\n\t\t.desc = \"Number of Enhanced Intel SpeedStep(R) Technology (EIST) transitions\",\n\t\t.topic = \"other\",\n\t},\n\t{\n\t\t.name = \"uncore_hisi_ddrc.flux_wcmd\",\n\t\t.event = \"event=0x2\",\n\t\t.desc = \"DDRC write commands. Unit: hisi_sccl,ddrc \",\n\t\t.topic = \"uncore\",\n\t\t.long_desc = \"DDRC write commands\",\n\t\t.pmu = \"hisi_sccl,ddrc\",\n\t},\n\t{\n\t\t.name = \"unc_cbo_xsnp_response.miss_eviction\",\n\t\t.event = \"event=0x22,umask=0x81\",\n\t\t.desc = \"A cross-core snoop resulted from L3 Eviction which misses in some processor core. Unit: uncore_cbox \",\n\t\t.topic = \"uncore\",\n\t\t.long_desc = \"A cross-core snoop resulted from L3 Eviction which misses in some processor core\",\n\t\t.pmu = \"uncore_cbox\",\n\t},\n\t{\n\t\t.name = \"event-hyphen\",\n\t\t.event = \"event=0xe0,umask=0x00\",\n\t\t.desc = \"UNC_CBO_HYPHEN. Unit: uncore_cbox \",\n\t\t.topic = \"uncore\",\n\t\t.long_desc = \"UNC_CBO_HYPHEN\",\n\t\t.pmu = \"uncore_cbox\",\n\t},\n\t{\n\t\t.name = \"event-two-hyph\",\n\t\t.event = \"event=0xc0,umask=0x00\",\n\t\t.desc = \"UNC_CBO_TWO_HYPH. Unit: uncore_cbox \",\n\t\t.topic = \"uncore\",\n\t\t.long_desc = \"UNC_CBO_TWO_HYPH\",\n\t\t.pmu = \"uncore_cbox\",\n\t},\n\t{\n\t\t.name = \"uncore_hisi_l3c.rd_hit_cpipe\",\n\t\t.event = \"event=0x7\",\n\t\t.desc = \"Total read hits. Unit: hisi_sccl,l3c \",\n\t\t.topic = \"uncore\",\n\t\t.long_desc = \"Total read hits\",\n\t\t.pmu = \"hisi_sccl,l3c\",\n\t},\n\t{\n\t\t.name = \"uncore_imc_free_running.cache_miss\",\n\t\t.event = \"event=0x12\",\n\t\t.desc = \"Total cache misses. Unit: uncore_imc_free_running \",\n\t\t.topic = \"uncore\",\n\t\t.long_desc = \"Total cache misses\",\n\t\t.pmu = \"uncore_imc_free_running\",\n\t},\n\t{\n\t\t.name = \"uncore_imc.cache_hits\",\n\t\t.event = \"event=0x34\",\n\t\t.desc = \"Total cache hits. Unit: uncore_imc \",\n\t\t.topic = \"uncore\",\n\t\t.long_desc = \"Total cache hits\",\n\t\t.pmu = \"uncore_imc\",\n\t},\n\t{\n\t\t.name = \"bp_l1_btb_correct\",\n\t\t.event = \"event=0x8a\",\n\t\t.desc = \"L1 BTB Correction\",\n\t\t.topic = \"branch\",\n\t},\n\t{\n\t\t.name = \"bp_l2_btb_correct\",\n\t\t.event = \"event=0x8b\",\n\t\t.desc = \"L2 BTB Correction\",\n\t\t.topic = \"branch\",\n\t},\n\t{\n\t\t.name = 0,\n\t\t.event = 0,\n\t\t.desc = 0,\n\t},\n};\n\nstatic const struct pmu_metric pmu_metrics__test_soc_cpu[] = {\n\t{\n\t\t.metric_expr\t= \"1 / IPC\",\n\t\t.metric_name\t= \"CPI\",\n\t},\n\t{\n\t\t.metric_expr\t= \"inst_retired.any / cpu_clk_unhalted.thread\",\n\t\t.metric_name\t= \"IPC\",\n\t\t.metric_group\t= \"group1\",\n\t},\n\t{\n\t\t.metric_expr\t= \"idq_uops_not_delivered.core / (4 * (( ( cpu_clk_unhalted.thread / 2 ) * \"\n\t\t\"( 1 + cpu_clk_unhalted.one_thread_active / cpu_clk_unhalted.ref_xclk ) )))\",\n\t\t.metric_name\t= \"Frontend_Bound_SMT\",\n\t},\n\t{\n\t\t.metric_expr\t= \"l1d\\\\-loads\\\\-misses / inst_retired.any\",\n\t\t.metric_name\t= \"dcache_miss_cpi\",\n\t},\n\t{\n\t\t.metric_expr\t= \"l1i\\\\-loads\\\\-misses / inst_retired.any\",\n\t\t.metric_name\t= \"icache_miss_cycles\",\n\t},\n\t{\n\t\t.metric_expr\t= \"(dcache_miss_cpi + icache_miss_cycles)\",\n\t\t.metric_name\t= \"cache_miss_cycles\",\n\t\t.metric_group\t= \"group1\",\n\t},\n\t{\n\t\t.metric_expr\t= \"l2_rqsts.demand_data_rd_hit + l2_rqsts.pf_hit + l2_rqsts.rfo_hit\",\n\t\t.metric_name\t= \"DCache_L2_All_Hits\",\n\t},\n\t{\n\t\t.metric_expr\t= \"max(l2_rqsts.all_demand_data_rd - l2_rqsts.demand_data_rd_hit, 0) + \"\n\t\t\"l2_rqsts.pf_miss + l2_rqsts.rfo_miss\",\n\t\t.metric_name\t= \"DCache_L2_All_Miss\",\n\t},\n\t{\n\t\t.metric_expr\t= \"DCache_L2_All_Hits + DCache_L2_All_Miss\",\n\t\t.metric_name\t= \"DCache_L2_All\",\n\t},\n\t{\n\t\t.metric_expr\t= \"d_ratio(DCache_L2_All_Hits, DCache_L2_All)\",\n\t\t.metric_name\t= \"DCache_L2_Hits\",\n\t},\n\t{\n\t\t.metric_expr\t= \"d_ratio(DCache_L2_All_Miss, DCache_L2_All)\",\n\t\t.metric_name\t= \"DCache_L2_Misses\",\n\t},\n\t{\n\t\t.metric_expr\t= \"ipc + M2\",\n\t\t.metric_name\t= \"M1\",\n\t},\n\t{\n\t\t.metric_expr\t= \"ipc + M1\",\n\t\t.metric_name\t= \"M2\",\n\t},\n\t{\n\t\t.metric_expr\t= \"1/M3\",\n\t\t.metric_name\t= \"M3\",\n\t},\n\t{\n\t\t.metric_expr\t= \"64 * l1d.replacement / 1000000000 / duration_time\",\n\t\t.metric_name\t= \"L1D_Cache_Fill_BW\",\n\t},\n\t{\n\t\t.metric_expr = 0,\n\t\t.metric_name = 0,\n\t},\n};\n\n \nstruct pmu_events_table {\n\tconst struct pmu_event *entries;\n};\n\n \nstruct pmu_metrics_table {\n\tconst struct pmu_metric *entries;\n};\n\n \nstruct pmu_events_map {\n\tconst char *arch;\n\tconst char *cpuid;\n\tconst struct pmu_events_table event_table;\n\tconst struct pmu_metrics_table metric_table;\n};\n\n \nstatic const struct pmu_events_map pmu_events_map[] = {\n\t{\n\t\t.arch = \"testarch\",\n\t\t.cpuid = \"testcpu\",\n\t\t.event_table = { pmu_events__test_soc_cpu },\n\t\t.metric_table = { pmu_metrics__test_soc_cpu },\n\t},\n\t{\n\t\t.arch = 0,\n\t\t.cpuid = 0,\n\t\t.event_table = { 0 },\n\t\t.metric_table = { 0 },\n\t},\n};\n\nstatic const struct pmu_event pmu_events__test_soc_sys[] = {\n\t{\n\t\t.name = \"sys_ddr_pmu.write_cycles\",\n\t\t.event = \"event=0x2b\",\n\t\t.desc = \"ddr write-cycles event. Unit: uncore_sys_ddr_pmu \",\n\t\t.compat = \"v8\",\n\t\t.topic = \"uncore\",\n\t\t.pmu = \"uncore_sys_ddr_pmu\",\n\t},\n\t{\n\t\t.name = \"sys_ccn_pmu.read_cycles\",\n\t\t.event = \"config=0x2c\",\n\t\t.desc = \"ccn read-cycles event. Unit: uncore_sys_ccn_pmu \",\n\t\t.compat = \"0x01\",\n\t\t.topic = \"uncore\",\n\t\t.pmu = \"uncore_sys_ccn_pmu\",\n\t},\n\t{\n\t\t.name = 0,\n\t\t.event = 0,\n\t\t.desc = 0,\n\t},\n};\n\nstruct pmu_sys_events {\n\tconst char *name;\n\tconst struct pmu_events_table table;\n};\n\nstatic const struct pmu_sys_events pmu_sys_event_tables[] = {\n\t{\n\t\t.table = { pmu_events__test_soc_sys },\n\t\t.name = \"pmu_events__test_soc_sys\",\n\t},\n\t{\n\t\t.table = { 0 }\n\t},\n};\n\nint pmu_events_table__for_each_event(const struct pmu_events_table *table, struct perf_pmu *pmu,\n\t\t\t\t     pmu_event_iter_fn fn, void *data)\n{\n\tfor (const struct pmu_event *pe = &table->entries[0]; pe->name; pe++) {\n\t\tint ret;\n\n                if (pmu && !pmu__name_match(pmu, pe->pmu))\n                        continue;\n\n\t\tret = fn(pe, table, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint pmu_events_table__find_event(const struct pmu_events_table *table,\n                                 struct perf_pmu *pmu,\n                                 const char *name,\n                                 pmu_event_iter_fn fn,\n                                 void *data)\n{\n\tfor (const struct pmu_event *pe = &table->entries[0]; pe->name; pe++) {\n                if (pmu && !pmu__name_match(pmu, pe->pmu))\n                        continue;\n\n\t\tif (!strcasecmp(pe->name, name))\n\t\t\treturn fn(pe, table, data);\n\t}\n        return -1000;\n}\n\nsize_t pmu_events_table__num_events(const struct pmu_events_table *table,\n                                    struct perf_pmu *pmu)\n{\n        size_t count = 0;\n\n\tfor (const struct pmu_event *pe = &table->entries[0]; pe->name; pe++) {\n                if (pmu && !pmu__name_match(pmu, pe->pmu))\n                        continue;\n\n\t\tcount++;\n\t}\n        return count;\n}\n\nint pmu_metrics_table__for_each_metric(const struct pmu_metrics_table *table, pmu_metric_iter_fn fn,\n\t\t\t\t      void *data)\n{\n\tfor (const struct pmu_metric *pm = &table->entries[0]; pm->metric_expr; pm++) {\n\t\tint ret = fn(pm, table, data);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nconst struct pmu_events_table *perf_pmu__find_events_table(struct perf_pmu *pmu)\n{\n\tconst struct pmu_events_table *table = NULL;\n\tchar *cpuid = perf_pmu__getcpuid(pmu);\n\tint i;\n\n\t \n\tif (!cpuid)\n\t\treturn NULL;\n\n\ti = 0;\n\tfor (;;) {\n\t\tconst struct pmu_events_map *map = &pmu_events_map[i++];\n\n\t\tif (!map->cpuid)\n\t\t\tbreak;\n\n\t\tif (!strcmp_cpuid_str(map->cpuid, cpuid)) {\n\t\t\ttable = &map->event_table;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(cpuid);\n\treturn table;\n}\n\nconst struct pmu_metrics_table *perf_pmu__find_metrics_table(struct perf_pmu *pmu)\n{\n\tconst struct pmu_metrics_table *table = NULL;\n\tchar *cpuid = perf_pmu__getcpuid(pmu);\n\tint i;\n\n\t \n\tif (!cpuid)\n\t\treturn NULL;\n\n\ti = 0;\n\tfor (;;) {\n\t\tconst struct pmu_events_map *map = &pmu_events_map[i++];\n\n\t\tif (!map->cpuid)\n\t\t\tbreak;\n\n\t\tif (!strcmp_cpuid_str(map->cpuid, cpuid)) {\n\t\t\ttable = &map->metric_table;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(cpuid);\n\treturn table;\n}\n\nconst struct pmu_events_table *find_core_events_table(const char *arch, const char *cpuid)\n{\n\tfor (const struct pmu_events_map *tables = &pmu_events_map[0];\n\t     tables->arch;\n\t     tables++) {\n\t\tif (!strcmp(tables->arch, arch) && !strcmp_cpuid_str(tables->cpuid, cpuid))\n\t\t\treturn &tables->event_table;\n\t}\n\treturn NULL;\n}\n\nconst struct pmu_metrics_table *find_core_metrics_table(const char *arch, const char *cpuid)\n{\n\tfor (const struct pmu_events_map *tables = &pmu_events_map[0];\n\t     tables->arch;\n\t     tables++) {\n\t\tif (!strcmp(tables->arch, arch) && !strcmp_cpuid_str(tables->cpuid, cpuid))\n\t\t\treturn &tables->metric_table;\n\t}\n\treturn NULL;\n}\n\nint pmu_for_each_core_event(pmu_event_iter_fn fn, void *data)\n{\n\tfor (const struct pmu_events_map *tables = &pmu_events_map[0]; tables->arch; tables++) {\n\t\tint ret = pmu_events_table__for_each_event(&tables->event_table,\n\t\t\t\t\t\t\t     NULL, fn, data);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint pmu_for_each_core_metric(pmu_metric_iter_fn fn, void *data)\n{\n\tfor (const struct pmu_events_map *tables = &pmu_events_map[0];\n\t     tables->arch;\n\t     tables++) {\n\t\tint ret = pmu_metrics_table__for_each_metric(&tables->metric_table, fn, data);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nconst struct pmu_events_table *find_sys_events_table(const char *name)\n{\n\tfor (const struct pmu_sys_events *tables = &pmu_sys_event_tables[0];\n\t     tables->name;\n\t     tables++) {\n\t\tif (!strcmp(tables->name, name))\n\t\t\treturn &tables->table;\n\t}\n\treturn NULL;\n}\n\nint pmu_for_each_sys_event(pmu_event_iter_fn fn, void *data)\n{\n\tfor (const struct pmu_sys_events *tables = &pmu_sys_event_tables[0];\n\t     tables->name;\n\t     tables++) {\n\t\tint ret = pmu_events_table__for_each_event(&tables->table,   NULL, fn, data);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint pmu_for_each_sys_metric(pmu_metric_iter_fn fn __maybe_unused, void *data __maybe_unused)\n{\n\treturn 0;\n}\n\nconst char *describe_metricgroup(const char *group __maybe_unused)\n{\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}