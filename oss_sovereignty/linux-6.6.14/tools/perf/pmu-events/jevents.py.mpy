{
  "module_name": "jevents.py",
  "hash_id": "3fbb8d957ec67828f8797d1dceb130194f75f165111a68f7ff93f0298a66fdc3",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/pmu-events/jevents.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)\n\"\"\"Convert directories of JSON events to C code.\"\"\"\nimport argparse\nimport csv\nfrom functools import lru_cache\nimport json\nimport metric\nimport os\nimport sys\nfrom typing import (Callable, Dict, Optional, Sequence, Set, Tuple)\nimport collections\n\n# Global command line arguments.\n_args = None\n# List of regular event tables.\n_event_tables = []\n# List of event tables generated from \"/sys\" directories.\n_sys_event_tables = []\n# List of regular metric tables.\n_metric_tables = []\n# List of metric tables generated from \"/sys\" directories.\n_sys_metric_tables = []\n# Mapping between sys event table names and sys metric table names.\n_sys_event_table_to_metric_table_mapping = {}\n# Map from an event name to an architecture standard\n# JsonEvent. Architecture standard events are in json files in the top\n# f'{_args.starting_dir}/{_args.arch}' directory.\n_arch_std_events = {}\n# Events to write out when the table is closed\n_pending_events = []\n# Name of events table to be written out\n_pending_events_tblname = None\n# Metrics to write out when the table is closed\n_pending_metrics = []\n# Name of metrics table to be written out\n_pending_metrics_tblname = None\n# Global BigCString shared by all structures.\n_bcs = None\n# Map from the name of a metric group to a description of the group.\n_metricgroups = {}\n# Order specific JsonEvent attributes will be visited.\n_json_event_attributes = [\n    # cmp_sevent related attributes.\n    'name', 'topic', 'desc',\n    # Seems useful, put it early.\n    'event',\n    # Short things in alphabetical order.\n    'compat', 'deprecated', 'perpkg', 'unit',\n    # Longer things (the last won't be iterated over during decompress).\n    'long_desc'\n]\n\n# Attributes that are in pmu_metric rather than pmu_event.\n_json_metric_attributes = [\n    'metric_name', 'metric_group', 'metric_expr', 'metric_threshold',\n    'desc', 'long_desc', 'unit', 'compat', 'metricgroup_no_group',\n    'default_metricgroup_name', 'aggr_mode', 'event_grouping'\n]\n# Attributes that are bools or enum int values, encoded as '0', '1',...\n_json_enum_attributes = ['aggr_mode', 'deprecated', 'event_grouping', 'perpkg']\n\ndef removesuffix(s: str, suffix: str) -> str:\n  \"\"\"Remove the suffix from a string\n\n  The removesuffix function is added to str in Python 3.9. We aim for 3.6\n  compatibility and so provide our own function here.\n  \"\"\"\n  return s[0:-len(suffix)] if s.endswith(suffix) else s\n\n\ndef file_name_to_table_name(prefix: str, parents: Sequence[str],\n                            dirname: str) -> str:\n  \"\"\"Generate a C table name from directory names.\"\"\"\n  tblname = prefix\n  for p in parents:\n    tblname += '_' + p\n  tblname += '_' + dirname\n  return tblname.replace('-', '_')\n\n\ndef c_len(s: str) -> int:\n  \"\"\"Return the length of s a C string\n\n  This doesn't handle all escape characters properly. It first assumes\n  all \\ are for escaping, it then adjusts as it will have over counted\n  \\\\. The code uses \\000 rather than \\0 as a terminator as an adjacent\n  number would be folded into a string of \\0 (ie. \"\\0\" + \"5\" doesn't\n  equal a terminator followed by the number 5 but the escape of\n  \\05). The code adjusts for \\000 but not properly for all octal, hex\n  or unicode values.\n  \"\"\"\n  try:\n    utf = s.encode(encoding='utf-8',errors='strict')\n  except:\n    print(f'broken string {s}')\n    raise\n  return len(utf) - utf.count(b'\\\\') + utf.count(b'\\\\\\\\') - (utf.count(b'\\\\000') * 2)\n\nclass BigCString:\n  \"\"\"A class to hold many strings concatenated together.\n\n  Generating a large number of stand-alone C strings creates a large\n  number of relocations in position independent code. The BigCString\n  is a helper for this case. It builds a single string which within it\n  are all the other C strings (to avoid memory issues the string\n  itself is held as a list of strings). The offsets within the big\n  string are recorded and when stored to disk these don't need\n  relocation. To reduce the size of the string further, identical\n  strings are merged. If a longer string ends-with the same value as a\n  shorter string, these entries are also merged.\n  \"\"\"\n  strings: Set[str]\n  big_string: Sequence[str]\n  offsets: Dict[str, int]\n  insert_number: int\n  insert_point: Dict[str, int]\n  metrics: Set[str]\n\n  def __init__(self):\n    self.strings = set()\n    self.insert_number = 0;\n    self.insert_point = {}\n    self.metrics = set()\n\n  def add(self, s: str, metric: bool) -> None:\n    \"\"\"Called to add to the big string.\"\"\"\n    if s not in self.strings:\n      self.strings.add(s)\n      self.insert_point[s] = self.insert_number\n      self.insert_number += 1\n      if metric:\n        self.metrics.add(s)\n\n  def compute(self) -> None:\n    \"\"\"Called once all strings are added to compute the string and offsets.\"\"\"\n\n    folded_strings = {}\n    # Determine if two strings can be folded, ie. let 1 string use the\n    # end of another. First reverse all strings and sort them.\n    sorted_reversed_strings = sorted([x[::-1] for x in self.strings])\n\n    # Strings 'xyz' and 'yz' will now be [ 'zy', 'zyx' ]. Scan forward\n    # for each string to see if there is a better candidate to fold it\n    # into, in the example rather than using 'yz' we can use'xyz' at\n    # an offset of 1. We record which string can be folded into which\n    # in folded_strings, we don't need to record the offset as it is\n    # trivially computed from the string lengths.\n    for pos,s in enumerate(sorted_reversed_strings):\n      best_pos = pos\n      for check_pos in range(pos + 1, len(sorted_reversed_strings)):\n        if sorted_reversed_strings[check_pos].startswith(s):\n          best_pos = check_pos\n        else:\n          break\n      if pos != best_pos:\n        folded_strings[s[::-1]] = sorted_reversed_strings[best_pos][::-1]\n\n    # Compute reverse mappings for debugging.\n    fold_into_strings = collections.defaultdict(set)\n    for key, val in folded_strings.items():\n      if key != val:\n        fold_into_strings[val].add(key)\n\n    # big_string_offset is the current location within the C string\n    # being appended to - comments, etc. don't count. big_string is\n    # the string contents represented as a list. Strings are immutable\n    # in Python and so appending to one causes memory issues, while\n    # lists are mutable.\n    big_string_offset = 0\n    self.big_string = []\n    self.offsets = {}\n\n    def string_cmp_key(s: str) -> Tuple[bool, int, str]:\n      return (s in self.metrics, self.insert_point[s], s)\n\n    # Emit all strings that aren't folded in a sorted manner.\n    for s in sorted(self.strings, key=string_cmp_key):\n      if s not in folded_strings:\n        self.offsets[s] = big_string_offset\n        self.big_string.append(f'/* offset={big_string_offset} */ \"')\n        self.big_string.append(s)\n        self.big_string.append('\"')\n        if s in fold_into_strings:\n          self.big_string.append(' /* also: ' + ', '.join(fold_into_strings[s]) + ' */')\n        self.big_string.append('\\n')\n        big_string_offset += c_len(s)\n        continue\n\n    # Compute the offsets of the folded strings.\n    for s in folded_strings.keys():\n      assert s not in self.offsets\n      folded_s = folded_strings[s]\n      self.offsets[s] = self.offsets[folded_s] + c_len(folded_s) - c_len(s)\n\n_bcs = BigCString()\n\nclass JsonEvent:\n  \"\"\"Representation of an event loaded from a json file dictionary.\"\"\"\n\n  def __init__(self, jd: dict):\n    \"\"\"Constructor passed the dictionary of parsed json values.\"\"\"\n\n    def llx(x: int) -> str:\n      \"\"\"Convert an int to a string similar to a printf modifier of %#llx.\"\"\"\n      return '0' if x == 0 else hex(x)\n\n    def fixdesc(s: str) -> str:\n      \"\"\"Fix formatting issue for the desc string.\"\"\"\n      if s is None:\n        return None\n      return removesuffix(removesuffix(removesuffix(s, '.  '),\n                                       '. '), '.').replace('\\n', '\\\\n').replace(\n                                           '\\\"', '\\\\\"').replace('\\r', '\\\\r')\n\n    def convert_aggr_mode(aggr_mode: str) -> Optional[str]:\n      \"\"\"Returns the aggr_mode_class enum value associated with the JSON string.\"\"\"\n      if not aggr_mode:\n        return None\n      aggr_mode_to_enum = {\n          'PerChip': '1',\n          'PerCore': '2',\n      }\n      return aggr_mode_to_enum[aggr_mode]\n\n    def convert_metric_constraint(metric_constraint: str) -> Optional[str]:\n      \"\"\"Returns the metric_event_groups enum value associated with the JSON string.\"\"\"\n      if not metric_constraint:\n        return None\n      metric_constraint_to_enum = {\n          'NO_GROUP_EVENTS': '1',\n          'NO_GROUP_EVENTS_NMI': '2',\n          'NO_NMI_WATCHDOG': '2',\n          'NO_GROUP_EVENTS_SMT': '3',\n      }\n      return metric_constraint_to_enum[metric_constraint]\n\n    def lookup_msr(num: str) -> Optional[str]:\n      \"\"\"Converts the msr number, or first in a list to the appropriate event field.\"\"\"\n      if not num:\n        return None\n      msrmap = {\n          0x3F6: 'ldlat=',\n          0x1A6: 'offcore_rsp=',\n          0x1A7: 'offcore_rsp=',\n          0x3F7: 'frontend=',\n      }\n      return msrmap[int(num.split(',', 1)[0], 0)]\n\n    def real_event(name: str, event: str) -> Optional[str]:\n      \"\"\"Convert well known event names to an event string otherwise use the event argument.\"\"\"\n      fixed = {\n          'inst_retired.any': 'event=0xc0,period=2000003',\n          'inst_retired.any_p': 'event=0xc0,period=2000003',\n          'cpu_clk_unhalted.ref': 'event=0x0,umask=0x03,period=2000003',\n          'cpu_clk_unhalted.thread': 'event=0x3c,period=2000003',\n          'cpu_clk_unhalted.core': 'event=0x3c,period=2000003',\n          'cpu_clk_unhalted.thread_any': 'event=0x3c,any=1,period=2000003',\n      }\n      if not name:\n        return None\n      if name.lower() in fixed:\n        return fixed[name.lower()]\n      return event\n\n    def unit_to_pmu(unit: str) -> Optional[str]:\n      \"\"\"Convert a JSON Unit to Linux PMU name.\"\"\"\n      if not unit:\n        return 'default_core'\n      # Comment brought over from jevents.c:\n      # it's not realistic to keep adding these, we need something more scalable ...\n      table = {\n          'CBO': 'uncore_cbox',\n          'QPI LL': 'uncore_qpi',\n          'SBO': 'uncore_sbox',\n          'iMPH-U': 'uncore_arb',\n          'CPU-M-CF': 'cpum_cf',\n          'CPU-M-SF': 'cpum_sf',\n          'PAI-CRYPTO' : 'pai_crypto',\n          'PAI-EXT' : 'pai_ext',\n          'UPI LL': 'uncore_upi',\n          'hisi_sicl,cpa': 'hisi_sicl,cpa',\n          'hisi_sccl,ddrc': 'hisi_sccl,ddrc',\n          'hisi_sccl,hha': 'hisi_sccl,hha',\n          'hisi_sccl,l3c': 'hisi_sccl,l3c',\n          'imx8_ddr': 'imx8_ddr',\n          'L3PMC': 'amd_l3',\n          'DFPMC': 'amd_df',\n          'cpu_core': 'cpu_core',\n          'cpu_atom': 'cpu_atom',\n          'ali_drw': 'ali_drw',\n      }\n      return table[unit] if unit in table else f'uncore_{unit.lower()}'\n\n    eventcode = 0\n    if 'EventCode' in jd:\n      eventcode = int(jd['EventCode'].split(',', 1)[0], 0)\n    if 'ExtSel' in jd:\n      eventcode |= int(jd['ExtSel']) << 8\n    configcode = int(jd['ConfigCode'], 0) if 'ConfigCode' in jd else None\n    self.name = jd['EventName'].lower() if 'EventName' in jd else None\n    self.topic = ''\n    self.compat = jd.get('Compat')\n    self.desc = fixdesc(jd.get('BriefDescription'))\n    self.long_desc = fixdesc(jd.get('PublicDescription'))\n    precise = jd.get('PEBS')\n    msr = lookup_msr(jd.get('MSRIndex'))\n    msrval = jd.get('MSRValue')\n    extra_desc = ''\n    if 'Data_LA' in jd:\n      extra_desc += '  Supports address when precise'\n      if 'Errata' in jd:\n        extra_desc += '.'\n    if 'Errata' in jd:\n      extra_desc += '  Spec update: ' + jd['Errata']\n    self.pmu = unit_to_pmu(jd.get('Unit'))\n    filter = jd.get('Filter')\n    self.unit = jd.get('ScaleUnit')\n    self.perpkg = jd.get('PerPkg')\n    self.aggr_mode = convert_aggr_mode(jd.get('AggregationMode'))\n    self.deprecated = jd.get('Deprecated')\n    self.metric_name = jd.get('MetricName')\n    self.metric_group = jd.get('MetricGroup')\n    self.metricgroup_no_group = jd.get('MetricgroupNoGroup')\n    self.default_metricgroup_name = jd.get('DefaultMetricgroupName')\n    self.event_grouping = convert_metric_constraint(jd.get('MetricConstraint'))\n    self.metric_expr = None\n    if 'MetricExpr' in jd:\n      self.metric_expr = metric.ParsePerfJson(jd['MetricExpr']).Simplify()\n    # Note, the metric formula for the threshold isn't parsed as the &\n    # and > have incorrect precedence.\n    self.metric_threshold = jd.get('MetricThreshold')\n\n    arch_std = jd.get('ArchStdEvent')\n    if precise and self.desc and '(Precise Event)' not in self.desc:\n      extra_desc += ' (Must be precise)' if precise == '2' else (' (Precise '\n                                                                 'event)')\n    event = f'config={llx(configcode)}' if configcode is not None else f'event={llx(eventcode)}'\n    event_fields = [\n        ('AnyThread', 'any='),\n        ('PortMask', 'ch_mask='),\n        ('CounterMask', 'cmask='),\n        ('EdgeDetect', 'edge='),\n        ('FCMask', 'fc_mask='),\n        ('Invert', 'inv='),\n        ('SampleAfterValue', 'period='),\n        ('UMask', 'umask='),\n    ]\n    for key, value in event_fields:\n      if key in jd and jd[key] != '0':\n        event += ',' + value + jd[key]\n    if filter:\n      event += f',{filter}'\n    if msr:\n      event += f',{msr}{msrval}'\n    if self.desc and extra_desc:\n      self.desc += extra_desc\n    if self.long_desc and extra_desc:\n      self.long_desc += extra_desc\n    if arch_std:\n      if arch_std.lower() in _arch_std_events:\n        event = _arch_std_events[arch_std.lower()].event\n        # Copy from the architecture standard event to self for undefined fields.\n        for attr, value in _arch_std_events[arch_std.lower()].__dict__.items():\n          if hasattr(self, attr) and not getattr(self, attr):\n            setattr(self, attr, value)\n      else:\n        raise argparse.ArgumentTypeError('Cannot find arch std event:', arch_std)\n\n    self.event = real_event(self.name, event)\n\n  def __repr__(self) -> str:\n    \"\"\"String representation primarily for debugging.\"\"\"\n    s = '{\\n'\n    for attr, value in self.__dict__.items():\n      if value:\n        s += f'\\t{attr} = {value},\\n'\n    return s + '}'\n\n  def build_c_string(self, metric: bool) -> str:\n    s = ''\n    for attr in _json_metric_attributes if metric else _json_event_attributes:\n      x = getattr(self, attr)\n      if metric and x and attr == 'metric_expr':\n        # Convert parsed metric expressions into a string. Slashes\n        # must be doubled in the file.\n        x = x.ToPerfJson().replace('\\\\', '\\\\\\\\')\n      if metric and x and attr == 'metric_threshold':\n        x = x.replace('\\\\', '\\\\\\\\')\n      if attr in _json_enum_attributes:\n        s += x if x else '0'\n      else:\n        s += f'{x}\\\\000' if x else '\\\\000'\n    return s\n\n  def to_c_string(self, metric: bool) -> str:\n    \"\"\"Representation of the event as a C struct initializer.\"\"\"\n\n    s = self.build_c_string(metric)\n    return f'{{ { _bcs.offsets[s] } }}, /* {s} */\\n'\n\n\n@lru_cache(maxsize=None)\ndef read_json_events(path: str, topic: str) -> Sequence[JsonEvent]:\n  \"\"\"Read json events from the specified file.\"\"\"\n  try:\n    events = json.load(open(path), object_hook=JsonEvent)\n  except BaseException as err:\n    print(f\"Exception processing {path}\")\n    raise\n  metrics: list[Tuple[str, str, metric.Expression]] = []\n  for event in events:\n    event.topic = topic\n    if event.metric_name and '-' not in event.metric_name:\n      metrics.append((event.pmu, event.metric_name, event.metric_expr))\n  updates = metric.RewriteMetricsInTermsOfOthers(metrics)\n  if updates:\n    for event in events:\n      if event.metric_name in updates:\n        # print(f'Updated {event.metric_name} from\\n\"{event.metric_expr}\"\\n'\n        #       f'to\\n\"{updates[event.metric_name]}\"')\n        event.metric_expr = updates[event.metric_name]\n\n  return events\n\ndef preprocess_arch_std_files(archpath: str) -> None:\n  \"\"\"Read in all architecture standard events.\"\"\"\n  global _arch_std_events\n  for item in os.scandir(archpath):\n    if item.is_file() and item.name.endswith('.json'):\n      for event in read_json_events(item.path, topic=''):\n        if event.name:\n          _arch_std_events[event.name.lower()] = event\n        if event.metric_name:\n          _arch_std_events[event.metric_name.lower()] = event\n\n\ndef add_events_table_entries(item: os.DirEntry, topic: str) -> None:\n  \"\"\"Add contents of file to _pending_events table.\"\"\"\n  for e in read_json_events(item.path, topic):\n    if e.name:\n      _pending_events.append(e)\n    if e.metric_name:\n      _pending_metrics.append(e)\n\n\ndef print_pending_events() -> None:\n  \"\"\"Optionally close events table.\"\"\"\n\n  def event_cmp_key(j: JsonEvent) -> Tuple[str, str, bool, str, str]:\n    def fix_none(s: Optional[str]) -> str:\n      if s is None:\n        return ''\n      return s\n\n    return (fix_none(j.pmu).replace(',','_'), fix_none(j.name), j.desc is not None, fix_none(j.topic),\n            fix_none(j.metric_name))\n\n  global _pending_events\n  if not _pending_events:\n    return\n\n  global _pending_events_tblname\n  if _pending_events_tblname.endswith('_sys'):\n    global _sys_event_tables\n    _sys_event_tables.append(_pending_events_tblname)\n  else:\n    global event_tables\n    _event_tables.append(_pending_events_tblname)\n\n  first = True\n  last_pmu = None\n  pmus = set()\n  for event in sorted(_pending_events, key=event_cmp_key):\n    if event.pmu != last_pmu:\n      if not first:\n        _args.output_file.write('};\\n')\n      pmu_name = event.pmu.replace(',', '_')\n      _args.output_file.write(\n          f'static const struct compact_pmu_event {_pending_events_tblname}_{pmu_name}[] = {{\\n')\n      first = False\n      last_pmu = event.pmu\n      pmus.add((event.pmu, pmu_name))\n\n    _args.output_file.write(event.to_c_string(metric=False))\n  _pending_events = []\n\n  _args.output_file.write(f\"\"\"\n}};\n\nconst struct pmu_table_entry {_pending_events_tblname}[] = {{\n\"\"\")\n  for (pmu, tbl_pmu) in sorted(pmus):\n    pmu_name = f\"{pmu}\\\\000\"\n    _args.output_file.write(f\"\"\"{{\n     .entries = {_pending_events_tblname}_{tbl_pmu},\n     .num_entries = ARRAY_SIZE({_pending_events_tblname}_{tbl_pmu}),\n     .pmu_name = {{ {_bcs.offsets[pmu_name]} /* {pmu_name} */ }},\n}},\n\"\"\")\n  _args.output_file.write('};\\n\\n')\n\ndef print_pending_metrics() -> None:\n  \"\"\"Optionally close metrics table.\"\"\"\n\n  def metric_cmp_key(j: JsonEvent) -> Tuple[bool, str, str]:\n    def fix_none(s: Optional[str]) -> str:\n      if s is None:\n        return ''\n      return s\n\n    return (j.desc is not None, fix_none(j.pmu), fix_none(j.metric_name))\n\n  global _pending_metrics\n  if not _pending_metrics:\n    return\n\n  global _pending_metrics_tblname\n  if _pending_metrics_tblname.endswith('_sys'):\n    global _sys_metric_tables\n    _sys_metric_tables.append(_pending_metrics_tblname)\n  else:\n    global metric_tables\n    _metric_tables.append(_pending_metrics_tblname)\n\n  first = True\n  last_pmu = None\n  pmus = set()\n  for metric in sorted(_pending_metrics, key=metric_cmp_key):\n    if metric.pmu != last_pmu:\n      if not first:\n        _args.output_file.write('};\\n')\n      pmu_name = metric.pmu.replace(',', '_')\n      _args.output_file.write(\n          f'static const struct compact_pmu_event {_pending_metrics_tblname}_{pmu_name}[] = {{\\n')\n      first = False\n      last_pmu = metric.pmu\n      pmus.add((metric.pmu, pmu_name))\n\n    _args.output_file.write(metric.to_c_string(metric=True))\n  _pending_metrics = []\n\n  _args.output_file.write(f\"\"\"\n}};\n\nconst struct pmu_table_entry {_pending_metrics_tblname}[] = {{\n\"\"\")\n  for (pmu, tbl_pmu) in sorted(pmus):\n    pmu_name = f\"{pmu}\\\\000\"\n    _args.output_file.write(f\"\"\"{{\n     .entries = {_pending_metrics_tblname}_{tbl_pmu},\n     .num_entries = ARRAY_SIZE({_pending_metrics_tblname}_{tbl_pmu}),\n     .pmu_name = {{ {_bcs.offsets[pmu_name]} /* {pmu_name} */ }},\n}},\n\"\"\")\n  _args.output_file.write('};\\n\\n')\n\ndef get_topic(topic: str) -> str:\n  if topic.endswith('metrics.json'):\n    return 'metrics'\n  return removesuffix(topic, '.json').replace('-', ' ')\n\ndef preprocess_one_file(parents: Sequence[str], item: os.DirEntry) -> None:\n\n  if item.is_dir():\n    return\n\n  # base dir or too deep\n  level = len(parents)\n  if level == 0 or level > 4:\n    return\n\n  # Ignore other directories. If the file name does not have a .json\n  # extension, ignore it. It could be a readme.txt for instance.\n  if not item.is_file() or not item.name.endswith('.json'):\n    return\n\n  if item.name == 'metricgroups.json':\n    metricgroup_descriptions = json.load(open(item.path))\n    for mgroup in metricgroup_descriptions:\n      assert len(mgroup) > 1, parents\n      description = f\"{metricgroup_descriptions[mgroup]}\\\\000\"\n      mgroup = f\"{mgroup}\\\\000\"\n      _bcs.add(mgroup, metric=True)\n      _bcs.add(description, metric=True)\n      _metricgroups[mgroup] = description\n    return\n\n  topic = get_topic(item.name)\n  for event in read_json_events(item.path, topic):\n    pmu_name = f\"{event.pmu}\\\\000\"\n    if event.name:\n      _bcs.add(pmu_name, metric=False)\n      _bcs.add(event.build_c_string(metric=False), metric=False)\n    if event.metric_name:\n      _bcs.add(pmu_name, metric=True)\n      _bcs.add(event.build_c_string(metric=True), metric=True)\n\ndef process_one_file(parents: Sequence[str], item: os.DirEntry) -> None:\n  \"\"\"Process a JSON file during the main walk.\"\"\"\n  def is_leaf_dir(path: str) -> bool:\n    for item in os.scandir(path):\n      if item.is_dir():\n        return False\n    return True\n\n  # model directory, reset topic\n  if item.is_dir() and is_leaf_dir(item.path):\n    print_pending_events()\n    print_pending_metrics()\n\n    global _pending_events_tblname\n    _pending_events_tblname = file_name_to_table_name('pmu_events_', parents, item.name)\n    global _pending_metrics_tblname\n    _pending_metrics_tblname = file_name_to_table_name('pmu_metrics_', parents, item.name)\n\n    if item.name == 'sys':\n      _sys_event_table_to_metric_table_mapping[_pending_events_tblname] = _pending_metrics_tblname\n    return\n\n  # base dir or too deep\n  level = len(parents)\n  if level == 0 or level > 4:\n    return\n\n  # Ignore other directories. If the file name does not have a .json\n  # extension, ignore it. It could be a readme.txt for instance.\n  if not item.is_file() or not item.name.endswith('.json') or item.name == 'metricgroups.json':\n    return\n\n  add_events_table_entries(item, get_topic(item.name))\n\n\ndef print_mapping_table(archs: Sequence[str]) -> None:\n  \"\"\"Read the mapfile and generate the struct from cpuid string to event table.\"\"\"\n  _args.output_file.write(\"\"\"\n/* Struct used to make the PMU event table implementation opaque to callers. */\nstruct pmu_events_table {\n        const struct pmu_table_entry *pmus;\n        uint32_t num_pmus;\n};\n\n/* Struct used to make the PMU metric table implementation opaque to callers. */\nstruct pmu_metrics_table {\n        const struct pmu_table_entry *pmus;\n        uint32_t num_pmus;\n};\n\n/*\n * Map a CPU to its table of PMU events. The CPU is identified by the\n * cpuid field, which is an arch-specific identifier for the CPU.\n * The identifier specified in tools/perf/pmu-events/arch/xxx/mapfile\n * must match the get_cpuid_str() in tools/perf/arch/xxx/util/header.c)\n *\n * The  cpuid can contain any character other than the comma.\n */\nstruct pmu_events_map {\n        const char *arch;\n        const char *cpuid;\n        struct pmu_events_table event_table;\n        struct pmu_metrics_table metric_table;\n};\n\n/*\n * Global table mapping each known CPU for the architecture to its\n * table of PMU events.\n */\nconst struct pmu_events_map pmu_events_map[] = {\n\"\"\")\n  for arch in archs:\n    if arch == 'test':\n      _args.output_file.write(\"\"\"{\n\\t.arch = \"testarch\",\n\\t.cpuid = \"testcpu\",\n\\t.event_table = {\n\\t\\t.pmus = pmu_events__test_soc_cpu,\n\\t\\t.num_pmus = ARRAY_SIZE(pmu_events__test_soc_cpu),\n\\t},\n\\t.metric_table = {\n\\t\\t.pmus = pmu_metrics__test_soc_cpu,\n\\t\\t.num_pmus = ARRAY_SIZE(pmu_metrics__test_soc_cpu),\n\\t}\n},\n\"\"\")\n    else:\n      with open(f'{_args.starting_dir}/{arch}/mapfile.csv') as csvfile:\n        table = csv.reader(csvfile)\n        first = True\n        for row in table:\n          # Skip the first row or any row beginning with #.\n          if not first and len(row) > 0 and not row[0].startswith('#'):\n            event_tblname = file_name_to_table_name('pmu_events_', [], row[2].replace('/', '_'))\n            if event_tblname in _event_tables:\n              event_size = f'ARRAY_SIZE({event_tblname})'\n            else:\n              event_tblname = 'NULL'\n              event_size = '0'\n            metric_tblname = file_name_to_table_name('pmu_metrics_', [], row[2].replace('/', '_'))\n            if metric_tblname in _metric_tables:\n              metric_size = f'ARRAY_SIZE({metric_tblname})'\n            else:\n              metric_tblname = 'NULL'\n              metric_size = '0'\n            if event_size == '0' and metric_size == '0':\n              continue\n            cpuid = row[0].replace('\\\\', '\\\\\\\\')\n            _args.output_file.write(f\"\"\"{{\n\\t.arch = \"{arch}\",\n\\t.cpuid = \"{cpuid}\",\n\\t.event_table = {{\n\\t\\t.pmus = {event_tblname},\n\\t\\t.num_pmus = {event_size}\n\\t}},\n\\t.metric_table = {{\n\\t\\t.pmus = {metric_tblname},\n\\t\\t.num_pmus = {metric_size}\n\\t}}\n}},\n\"\"\")\n          first = False\n\n  _args.output_file.write(\"\"\"{\n\\t.arch = 0,\n\\t.cpuid = 0,\n\\t.event_table = { 0, 0 },\n\\t.metric_table = { 0, 0 },\n}\n};\n\"\"\")\n\n\ndef print_system_mapping_table() -> None:\n  \"\"\"C struct mapping table array for tables from /sys directories.\"\"\"\n  _args.output_file.write(\"\"\"\nstruct pmu_sys_events {\n\\tconst char *name;\n\\tstruct pmu_events_table event_table;\n\\tstruct pmu_metrics_table metric_table;\n};\n\nstatic const struct pmu_sys_events pmu_sys_event_tables[] = {\n\"\"\")\n  printed_metric_tables = []\n  for tblname in _sys_event_tables:\n    _args.output_file.write(f\"\"\"\\t{{\n\\t\\t.event_table = {{\n\\t\\t\\t.pmus = {tblname},\n\\t\\t\\t.num_pmus = ARRAY_SIZE({tblname})\n\\t\\t}},\"\"\")\n    metric_tblname = _sys_event_table_to_metric_table_mapping[tblname]\n    if metric_tblname in _sys_metric_tables:\n      _args.output_file.write(f\"\"\"\n\\t\\t.metric_table = {{\n\\t\\t\\t.pmus = {metric_tblname},\n\\t\\t\\t.num_pmus = ARRAY_SIZE({metric_tblname})\n\\t\\t}},\"\"\")\n      printed_metric_tables.append(metric_tblname)\n    _args.output_file.write(f\"\"\"\n\\t\\t.name = \\\"{tblname}\\\",\n\\t}},\n\"\"\")\n  for tblname in _sys_metric_tables:\n    if tblname in printed_metric_tables:\n      continue\n    _args.output_file.write(f\"\"\"\\t{{\n\\t\\t.metric_table = {{\n\\t\\t\\t.entries = {tblname},\n\\t\\t\\t.length = ARRAY_SIZE({tblname})\n\\t\\t}},\n\\t\\t.name = \\\"{tblname}\\\",\n\\t}},\n\"\"\")\n  _args.output_file.write(\"\"\"\\t{\n\\t\\t.event_table = { 0, 0 },\n\\t\\t.metric_table = { 0, 0 },\n\\t},\n};\n\nstatic void decompress_event(int offset, struct pmu_event *pe)\n{\n\\tconst char *p = &big_c_string[offset];\n\"\"\")\n  for attr in _json_event_attributes:\n    _args.output_file.write(f'\\n\\tpe->{attr} = ')\n    if attr in _json_enum_attributes:\n      _args.output_file.write(\"*p - '0';\\n\")\n    else:\n      _args.output_file.write(\"(*p == '\\\\0' ? NULL : p);\\n\")\n    if attr == _json_event_attributes[-1]:\n      continue\n    if attr in _json_enum_attributes:\n      _args.output_file.write('\\tp++;')\n    else:\n      _args.output_file.write('\\twhile (*p++);')\n  _args.output_file.write(\"\"\"}\n\nstatic void decompress_metric(int offset, struct pmu_metric *pm)\n{\n\\tconst char *p = &big_c_string[offset];\n\"\"\")\n  for attr in _json_metric_attributes:\n    _args.output_file.write(f'\\n\\tpm->{attr} = ')\n    if attr in _json_enum_attributes:\n      _args.output_file.write(\"*p - '0';\\n\")\n    else:\n      _args.output_file.write(\"(*p == '\\\\0' ? NULL : p);\\n\")\n    if attr == _json_metric_attributes[-1]:\n      continue\n    if attr in _json_enum_attributes:\n      _args.output_file.write('\\tp++;')\n    else:\n      _args.output_file.write('\\twhile (*p++);')\n  _args.output_file.write(\"\"\"}\n\nstatic int pmu_events_table__for_each_event_pmu(const struct pmu_events_table *table,\n                                                const struct pmu_table_entry *pmu,\n                                                pmu_event_iter_fn fn,\n                                                void *data)\n{\n        int ret;\n        struct pmu_event pe = {\n                .pmu = &big_c_string[pmu->pmu_name.offset],\n        };\n\n        for (uint32_t i = 0; i < pmu->num_entries; i++) {\n                decompress_event(pmu->entries[i].offset, &pe);\n                if (!pe.name)\n                        continue;\n                ret = fn(&pe, table, data);\n                if (ret)\n                        return ret;\n        }\n        return 0;\n }\n\nstatic int pmu_events_table__find_event_pmu(const struct pmu_events_table *table,\n                                            const struct pmu_table_entry *pmu,\n                                            const char *name,\n                                            pmu_event_iter_fn fn,\n                                            void *data)\n{\n        struct pmu_event pe = {\n                .pmu = &big_c_string[pmu->pmu_name.offset],\n        };\n        int low = 0, high = pmu->num_entries - 1;\n\n        while (low <= high) {\n                int cmp, mid = (low + high) / 2;\n\n                decompress_event(pmu->entries[mid].offset, &pe);\n\n                if (!pe.name && !name)\n                        goto do_call;\n\n                if (!pe.name && name) {\n                        low = mid + 1;\n                        continue;\n                }\n                if (pe.name && !name) {\n                        high = mid - 1;\n                        continue;\n                }\n\n                cmp = strcasecmp(pe.name, name);\n                if (cmp < 0) {\n                        low = mid + 1;\n                        continue;\n                }\n                if (cmp > 0) {\n                        high = mid - 1;\n                        continue;\n                }\n  do_call:\n                return fn ? fn(&pe, table, data) : 0;\n        }\n        return -1000;\n}\n\nint pmu_events_table__for_each_event(const struct pmu_events_table *table,\n                                    struct perf_pmu *pmu,\n                                    pmu_event_iter_fn fn,\n                                    void *data)\n{\n        for (size_t i = 0; i < table->num_pmus; i++) {\n                const struct pmu_table_entry *table_pmu = &table->pmus[i];\n                const char *pmu_name = &big_c_string[table_pmu->pmu_name.offset];\n                int ret;\n\n                if (pmu && !pmu__name_match(pmu, pmu_name))\n                        continue;\n\n                ret = pmu_events_table__for_each_event_pmu(table, table_pmu, fn, data);\n                if (pmu || ret)\n                        return ret;\n        }\n        return 0;\n}\n\nint pmu_events_table__find_event(const struct pmu_events_table *table,\n                                 struct perf_pmu *pmu,\n                                 const char *name,\n                                 pmu_event_iter_fn fn,\n                                 void *data)\n{\n        for (size_t i = 0; i < table->num_pmus; i++) {\n                const struct pmu_table_entry *table_pmu = &table->pmus[i];\n                const char *pmu_name = &big_c_string[table_pmu->pmu_name.offset];\n                int ret;\n\n                if (!pmu__name_match(pmu, pmu_name))\n                        continue;\n\n                ret = pmu_events_table__find_event_pmu(table, table_pmu, name, fn, data);\n                if (ret != -1000)\n                        return ret;\n        }\n        return -1000;\n}\n\nsize_t pmu_events_table__num_events(const struct pmu_events_table *table,\n                                    struct perf_pmu *pmu)\n{\n        size_t count = 0;\n\n        for (size_t i = 0; i < table->num_pmus; i++) {\n                const struct pmu_table_entry *table_pmu = &table->pmus[i];\n                const char *pmu_name = &big_c_string[table_pmu->pmu_name.offset];\n\n                if (pmu__name_match(pmu, pmu_name))\n                        count += table_pmu->num_entries;\n        }\n        return count;\n}\n\nstatic int pmu_metrics_table__for_each_metric_pmu(const struct pmu_metrics_table *table,\n                                                const struct pmu_table_entry *pmu,\n                                                pmu_metric_iter_fn fn,\n                                                void *data)\n{\n        int ret;\n        struct pmu_metric pm = {\n                .pmu = &big_c_string[pmu->pmu_name.offset],\n        };\n\n        for (uint32_t i = 0; i < pmu->num_entries; i++) {\n                decompress_metric(pmu->entries[i].offset, &pm);\n                if (!pm.metric_expr)\n                        continue;\n                ret = fn(&pm, table, data);\n                if (ret)\n                        return ret;\n        }\n        return 0;\n}\n\nint pmu_metrics_table__for_each_metric(const struct pmu_metrics_table *table,\n                                     pmu_metric_iter_fn fn,\n                                     void *data)\n{\n        for (size_t i = 0; i < table->num_pmus; i++) {\n                int ret = pmu_metrics_table__for_each_metric_pmu(table, &table->pmus[i],\n                                                                 fn, data);\n\n                if (ret)\n                        return ret;\n        }\n        return 0;\n}\n\nconst struct pmu_events_table *perf_pmu__find_events_table(struct perf_pmu *pmu)\n{\n        const struct pmu_events_table *table = NULL;\n        char *cpuid = perf_pmu__getcpuid(pmu);\n        size_t i;\n\n        /* on some platforms which uses cpus map, cpuid can be NULL for\n         * PMUs other than CORE PMUs.\n         */\n        if (!cpuid)\n                return NULL;\n\n        i = 0;\n        for (;;) {\n                const struct pmu_events_map *map = &pmu_events_map[i++];\n                if (!map->arch)\n                        break;\n\n                if (!strcmp_cpuid_str(map->cpuid, cpuid)) {\n                        table = &map->event_table;\n                        break;\n                }\n        }\n        free(cpuid);\n        if (!pmu || !table)\n                return table;\n\n        for (i = 0; i < table->num_pmus; i++) {\n                const struct pmu_table_entry *table_pmu = &table->pmus[i];\n                const char *pmu_name = &big_c_string[table_pmu->pmu_name.offset];\n\n                if (pmu__name_match(pmu, pmu_name))\n                        return table;\n        }\n        return NULL;\n}\n\nconst struct pmu_metrics_table *perf_pmu__find_metrics_table(struct perf_pmu *pmu)\n{\n        const struct pmu_metrics_table *table = NULL;\n        char *cpuid = perf_pmu__getcpuid(pmu);\n        int i;\n\n        /* on some platforms which uses cpus map, cpuid can be NULL for\n         * PMUs other than CORE PMUs.\n         */\n        if (!cpuid)\n                return NULL;\n\n        i = 0;\n        for (;;) {\n                const struct pmu_events_map *map = &pmu_events_map[i++];\n                if (!map->arch)\n                        break;\n\n                if (!strcmp_cpuid_str(map->cpuid, cpuid)) {\n                        table = &map->metric_table;\n                        break;\n                }\n        }\n        free(cpuid);\n        return table;\n}\n\nconst struct pmu_events_table *find_core_events_table(const char *arch, const char *cpuid)\n{\n        for (const struct pmu_events_map *tables = &pmu_events_map[0];\n             tables->arch;\n             tables++) {\n                if (!strcmp(tables->arch, arch) && !strcmp_cpuid_str(tables->cpuid, cpuid))\n                        return &tables->event_table;\n        }\n        return NULL;\n}\n\nconst struct pmu_metrics_table *find_core_metrics_table(const char *arch, const char *cpuid)\n{\n        for (const struct pmu_events_map *tables = &pmu_events_map[0];\n             tables->arch;\n             tables++) {\n                if (!strcmp(tables->arch, arch) && !strcmp_cpuid_str(tables->cpuid, cpuid))\n                        return &tables->metric_table;\n        }\n        return NULL;\n}\n\nint pmu_for_each_core_event(pmu_event_iter_fn fn, void *data)\n{\n        for (const struct pmu_events_map *tables = &pmu_events_map[0];\n             tables->arch;\n             tables++) {\n                int ret = pmu_events_table__for_each_event(&tables->event_table,\n                                                           /*pmu=*/ NULL, fn, data);\n\n                if (ret)\n                        return ret;\n        }\n        return 0;\n}\n\nint pmu_for_each_core_metric(pmu_metric_iter_fn fn, void *data)\n{\n        for (const struct pmu_events_map *tables = &pmu_events_map[0];\n             tables->arch;\n             tables++) {\n                int ret = pmu_metrics_table__for_each_metric(&tables->metric_table, fn, data);\n\n                if (ret)\n                        return ret;\n        }\n        return 0;\n}\n\nconst struct pmu_events_table *find_sys_events_table(const char *name)\n{\n        for (const struct pmu_sys_events *tables = &pmu_sys_event_tables[0];\n             tables->name;\n             tables++) {\n                if (!strcmp(tables->name, name))\n                        return &tables->event_table;\n        }\n        return NULL;\n}\n\nint pmu_for_each_sys_event(pmu_event_iter_fn fn, void *data)\n{\n        for (const struct pmu_sys_events *tables = &pmu_sys_event_tables[0];\n             tables->name;\n             tables++) {\n                int ret = pmu_events_table__for_each_event(&tables->event_table,\n                                                           /*pmu=*/ NULL, fn, data);\n\n                if (ret)\n                        return ret;\n        }\n        return 0;\n}\n\nint pmu_for_each_sys_metric(pmu_metric_iter_fn fn, void *data)\n{\n        for (const struct pmu_sys_events *tables = &pmu_sys_event_tables[0];\n             tables->name;\n             tables++) {\n                int ret = pmu_metrics_table__for_each_metric(&tables->metric_table, fn, data);\n\n                if (ret)\n                        return ret;\n        }\n        return 0;\n}\n\"\"\")\n\ndef print_metricgroups() -> None:\n  _args.output_file.write(\"\"\"\nstatic const int metricgroups[][2] = {\n\"\"\")\n  for mgroup in sorted(_metricgroups):\n    description = _metricgroups[mgroup]\n    _args.output_file.write(\n        f'\\t{{ {_bcs.offsets[mgroup]}, {_bcs.offsets[description]} }}, /* {mgroup} => {description} */\\n'\n    )\n  _args.output_file.write(\"\"\"\n};\n\nconst char *describe_metricgroup(const char *group)\n{\n        int low = 0, high = (int)ARRAY_SIZE(metricgroups) - 1;\n\n        while (low <= high) {\n                int mid = (low + high) / 2;\n                const char *mgroup = &big_c_string[metricgroups[mid][0]];\n                int cmp = strcmp(mgroup, group);\n\n                if (cmp == 0) {\n                        return &big_c_string[metricgroups[mid][1]];\n                } else if (cmp < 0) {\n                        low = mid + 1;\n                } else {\n                        high = mid - 1;\n                }\n        }\n        return NULL;\n}\n\"\"\")\n\ndef main() -> None:\n  global _args\n\n  def dir_path(path: str) -> str:\n    \"\"\"Validate path is a directory for argparse.\"\"\"\n    if os.path.isdir(path):\n      return path\n    raise argparse.ArgumentTypeError(f'\\'{path}\\' is not a valid directory')\n\n  def ftw(path: str, parents: Sequence[str],\n          action: Callable[[Sequence[str], os.DirEntry], None]) -> None:\n    \"\"\"Replicate the directory/file walking behavior of C's file tree walk.\"\"\"\n    for item in sorted(os.scandir(path), key=lambda e: e.name):\n      if _args.model != 'all' and item.is_dir():\n        # Check if the model matches one in _args.model.\n        if len(parents) == _args.model.split(',')[0].count('/'):\n          # We're testing the correct directory.\n          item_path = '/'.join(parents) + ('/' if len(parents) > 0 else '') + item.name\n          if 'test' not in item_path and item_path not in _args.model.split(','):\n            continue\n      action(parents, item)\n      if item.is_dir():\n        ftw(item.path, parents + [item.name], action)\n\n  ap = argparse.ArgumentParser()\n  ap.add_argument('arch', help='Architecture name like x86')\n  ap.add_argument('model', help='''Select a model such as skylake to\nreduce the code size.  Normally set to \"all\". For architectures like\nARM64 with an implementor/model, the model must include the implementor\nsuch as \"arm/cortex-a34\".''',\n                  default='all')\n  ap.add_argument(\n      'starting_dir',\n      type=dir_path,\n      help='Root of tree containing architecture directories containing json files'\n  )\n  ap.add_argument(\n      'output_file', type=argparse.FileType('w', encoding='utf-8'), nargs='?', default=sys.stdout)\n  _args = ap.parse_args()\n\n  _args.output_file.write(\"\"\"\n#include <pmu-events/pmu-events.h>\n#include \"util/header.h\"\n#include \"util/pmu.h\"\n#include <string.h>\n#include <stddef.h>\n\nstruct compact_pmu_event {\n        int offset;\n};\n\nstruct pmu_table_entry {\n        const struct compact_pmu_event *entries;\n        uint32_t num_entries;\n        struct compact_pmu_event pmu_name;\n};\n\n\"\"\")\n  archs = []\n  for item in os.scandir(_args.starting_dir):\n    if not item.is_dir():\n      continue\n    if item.name == _args.arch or _args.arch == 'all' or item.name == 'test':\n      archs.append(item.name)\n\n  if len(archs) < 2:\n    raise IOError(f'Missing architecture directory \\'{_args.arch}\\'')\n\n  archs.sort()\n  for arch in archs:\n    arch_path = f'{_args.starting_dir}/{arch}'\n    preprocess_arch_std_files(arch_path)\n    ftw(arch_path, [], preprocess_one_file)\n\n  _bcs.compute()\n  _args.output_file.write('static const char *const big_c_string =\\n')\n  for s in _bcs.big_string:\n    _args.output_file.write(s)\n  _args.output_file.write(';\\n\\n')\n  for arch in archs:\n    arch_path = f'{_args.starting_dir}/{arch}'\n    ftw(arch_path, [], process_one_file)\n    print_pending_events()\n    print_pending_metrics()\n\n  print_mapping_table(archs)\n  print_system_mapping_table()\n  print_metricgroups()\n\nif __name__ == '__main__':\n  main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}