{
  "module_name": "metric.py",
  "hash_id": "04acd6337a535e309a21d5fbe7777f7d2bed07ad3b168b03b94463ef0cdebfb0",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/pmu-events/metric.py",
  "human_readable_source": "# SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)\n\"\"\"Parse or generate representations of perf metrics.\"\"\"\nimport ast\nimport decimal\nimport json\nimport re\nfrom typing import Dict, List, Optional, Set, Tuple, Union\n\n\nclass Expression:\n  \"\"\"Abstract base class of elements in a metric expression.\"\"\"\n\n  def ToPerfJson(self) -> str:\n    \"\"\"Returns a perf json file encoded representation.\"\"\"\n    raise NotImplementedError()\n\n  def ToPython(self) -> str:\n    \"\"\"Returns a python expr parseable representation.\"\"\"\n    raise NotImplementedError()\n\n  def Simplify(self):\n    \"\"\"Returns a simplified version of self.\"\"\"\n    raise NotImplementedError()\n\n  def Equals(self, other) -> bool:\n    \"\"\"Returns true when two expressions are the same.\"\"\"\n    raise NotImplementedError()\n\n  def Substitute(self, name: str, expression: 'Expression') -> 'Expression':\n    raise NotImplementedError()\n\n  def __str__(self) -> str:\n    return self.ToPerfJson()\n\n  def __or__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('|', self, other)\n\n  def __ror__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('|', other, self)\n\n  def __xor__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('^', self, other)\n\n  def __and__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('&', self, other)\n\n  def __rand__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('&', other, self)\n\n  def __lt__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('<', self, other)\n\n  def __gt__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('>', self, other)\n\n  def __add__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('+', self, other)\n\n  def __radd__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('+', other, self)\n\n  def __sub__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('-', self, other)\n\n  def __rsub__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('-', other, self)\n\n  def __mul__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('*', self, other)\n\n  def __rmul__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('*', other, self)\n\n  def __truediv__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('/', self, other)\n\n  def __rtruediv__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('/', other, self)\n\n  def __mod__(self, other: Union[int, float, 'Expression']) -> 'Operator':\n    return Operator('%', self, other)\n\n\ndef _Constify(val: Union[bool, int, float, Expression]) -> Expression:\n  \"\"\"Used to ensure that the nodes in the expression tree are all Expression.\"\"\"\n  if isinstance(val, bool):\n    return Constant(1 if val else 0)\n  if isinstance(val, (int, float)):\n    return Constant(val)\n  return val\n\n\n# Simple lookup for operator precedence, used to avoid unnecessary\n# brackets. Precedence matches that of the simple expression parser\n# but differs from python where comparisons are lower precedence than\n# the bitwise &, ^, | but not the logical versions that the expression\n# parser doesn't have.\n_PRECEDENCE = {\n    '|': 0,\n    '^': 1,\n    '&': 2,\n    '<': 3,\n    '>': 3,\n    '+': 4,\n    '-': 4,\n    '*': 5,\n    '/': 5,\n    '%': 5,\n}\n\n\nclass Operator(Expression):\n  \"\"\"Represents a binary operator in the parse tree.\"\"\"\n\n  def __init__(self, operator: str, lhs: Union[int, float, Expression],\n               rhs: Union[int, float, Expression]):\n    self.operator = operator\n    self.lhs = _Constify(lhs)\n    self.rhs = _Constify(rhs)\n\n  def Bracket(self,\n              other: Expression,\n              other_str: str,\n              rhs: bool = False) -> str:\n    \"\"\"If necessary brackets the given other value.\n\n    If ``other`` is an operator then a bracket is necessary when\n    this/self operator has higher precedence. Consider: '(a + b) * c',\n    ``other_str`` will be 'a + b'. A bracket is necessary as without\n    the bracket 'a + b * c' will evaluate 'b * c' first. However, '(a\n    * b) + c' doesn't need a bracket as 'a * b' will always be\n    evaluated first. For 'a / (b * c)' (ie the same precedence level\n    operations) then we add the bracket to best match the original\n    input, but not for '(a / b) * c' where the bracket is unnecessary.\n\n    Args:\n      other (Expression): is a lhs or rhs operator\n      other_str (str): ``other`` in the appropriate string form\n      rhs (bool):  is ``other`` on the RHS\n\n    Returns:\n      str: possibly bracketed other_str\n    \"\"\"\n    if isinstance(other, Operator):\n      if _PRECEDENCE.get(self.operator, -1) > _PRECEDENCE.get(\n          other.operator, -1):\n        return f'({other_str})'\n      if rhs and _PRECEDENCE.get(self.operator, -1) == _PRECEDENCE.get(\n          other.operator, -1):\n        return f'({other_str})'\n    return other_str\n\n  def ToPerfJson(self):\n    return (f'{self.Bracket(self.lhs, self.lhs.ToPerfJson())} {self.operator} '\n            f'{self.Bracket(self.rhs, self.rhs.ToPerfJson(), True)}')\n\n  def ToPython(self):\n    return (f'{self.Bracket(self.lhs, self.lhs.ToPython())} {self.operator} '\n            f'{self.Bracket(self.rhs, self.rhs.ToPython(), True)}')\n\n  def Simplify(self) -> Expression:\n    lhs = self.lhs.Simplify()\n    rhs = self.rhs.Simplify()\n    if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n      return Constant(ast.literal_eval(lhs + self.operator + rhs))\n\n    if isinstance(self.lhs, Constant):\n      if self.operator in ('+', '|') and lhs.value == '0':\n        return rhs\n\n      # Simplify multiplication by 0 except for the slot event which\n      # is deliberately introduced using this pattern.\n      if self.operator == '*' and lhs.value == '0' and (\n          not isinstance(rhs, Event) or 'slots' not in rhs.name.lower()):\n        return Constant(0)\n\n      if self.operator == '*' and lhs.value == '1':\n        return rhs\n\n    if isinstance(rhs, Constant):\n      if self.operator in ('+', '|') and rhs.value == '0':\n        return lhs\n\n      if self.operator == '*' and rhs.value == '0':\n        return Constant(0)\n\n      if self.operator == '*' and self.rhs.value == '1':\n        return lhs\n\n    return Operator(self.operator, lhs, rhs)\n\n  def Equals(self, other: Expression) -> bool:\n    if isinstance(other, Operator):\n      return self.operator == other.operator and self.lhs.Equals(\n          other.lhs) and self.rhs.Equals(other.rhs)\n    return False\n\n  def Substitute(self, name: str, expression: Expression) -> Expression:\n    if self.Equals(expression):\n      return Event(name)\n    lhs = self.lhs.Substitute(name, expression)\n    rhs = None\n    if self.rhs:\n      rhs = self.rhs.Substitute(name, expression)\n    return Operator(self.operator, lhs, rhs)\n\n\nclass Select(Expression):\n  \"\"\"Represents a select ternary in the parse tree.\"\"\"\n\n  def __init__(self, true_val: Union[int, float, Expression],\n               cond: Union[int, float, Expression],\n               false_val: Union[int, float, Expression]):\n    self.true_val = _Constify(true_val)\n    self.cond = _Constify(cond)\n    self.false_val = _Constify(false_val)\n\n  def ToPerfJson(self):\n    true_str = self.true_val.ToPerfJson()\n    cond_str = self.cond.ToPerfJson()\n    false_str = self.false_val.ToPerfJson()\n    return f'({true_str} if {cond_str} else {false_str})'\n\n  def ToPython(self):\n    return (f'Select({self.true_val.ToPython()}, {self.cond.ToPython()}, '\n            f'{self.false_val.ToPython()})')\n\n  def Simplify(self) -> Expression:\n    cond = self.cond.Simplify()\n    true_val = self.true_val.Simplify()\n    false_val = self.false_val.Simplify()\n    if isinstance(cond, Constant):\n      return false_val if cond.value == '0' else true_val\n\n    if true_val.Equals(false_val):\n      return true_val\n\n    return Select(true_val, cond, false_val)\n\n  def Equals(self, other: Expression) -> bool:\n    if isinstance(other, Select):\n      return self.cond.Equals(other.cond) and self.false_val.Equals(\n          other.false_val) and self.true_val.Equals(other.true_val)\n    return False\n\n  def Substitute(self, name: str, expression: Expression) -> Expression:\n    if self.Equals(expression):\n      return Event(name)\n    true_val = self.true_val.Substitute(name, expression)\n    cond = self.cond.Substitute(name, expression)\n    false_val = self.false_val.Substitute(name, expression)\n    return Select(true_val, cond, false_val)\n\n\nclass Function(Expression):\n  \"\"\"A function in an expression like min, max, d_ratio.\"\"\"\n\n  def __init__(self,\n               fn: str,\n               lhs: Union[int, float, Expression],\n               rhs: Optional[Union[int, float, Expression]] = None):\n    self.fn = fn\n    self.lhs = _Constify(lhs)\n    self.rhs = _Constify(rhs)\n\n  def ToPerfJson(self):\n    if self.rhs:\n      return f'{self.fn}({self.lhs.ToPerfJson()}, {self.rhs.ToPerfJson()})'\n    return f'{self.fn}({self.lhs.ToPerfJson()})'\n\n  def ToPython(self):\n    if self.rhs:\n      return f'{self.fn}({self.lhs.ToPython()}, {self.rhs.ToPython()})'\n    return f'{self.fn}({self.lhs.ToPython()})'\n\n  def Simplify(self) -> Expression:\n    lhs = self.lhs.Simplify()\n    rhs = self.rhs.Simplify() if self.rhs else None\n    if isinstance(lhs, Constant) and isinstance(rhs, Constant):\n      if self.fn == 'd_ratio':\n        if rhs.value == '0':\n          return Constant(0)\n        Constant(ast.literal_eval(f'{lhs} / {rhs}'))\n      return Constant(ast.literal_eval(f'{self.fn}({lhs}, {rhs})'))\n\n    return Function(self.fn, lhs, rhs)\n\n  def Equals(self, other: Expression) -> bool:\n    if isinstance(other, Function):\n      result = self.fn == other.fn and self.lhs.Equals(other.lhs)\n      if self.rhs:\n        result = result and self.rhs.Equals(other.rhs)\n      return result\n    return False\n\n  def Substitute(self, name: str, expression: Expression) -> Expression:\n    if self.Equals(expression):\n      return Event(name)\n    lhs = self.lhs.Substitute(name, expression)\n    rhs = None\n    if self.rhs:\n      rhs = self.rhs.Substitute(name, expression)\n    return Function(self.fn, lhs, rhs)\n\n\ndef _FixEscapes(s: str) -> str:\n  s = re.sub(r'([^\\\\]),', r'\\1\\\\,', s)\n  return re.sub(r'([^\\\\])=', r'\\1\\\\=', s)\n\n\nclass Event(Expression):\n  \"\"\"An event in an expression.\"\"\"\n\n  def __init__(self, name: str, legacy_name: str = ''):\n    self.name = _FixEscapes(name)\n    self.legacy_name = _FixEscapes(legacy_name)\n\n  def ToPerfJson(self):\n    result = re.sub('/', '@', self.name)\n    return result\n\n  def ToPython(self):\n    return f'Event(r\"{self.name}\")'\n\n  def Simplify(self) -> Expression:\n    return self\n\n  def Equals(self, other: Expression) -> bool:\n    return isinstance(other, Event) and self.name == other.name\n\n  def Substitute(self, name: str, expression: Expression) -> Expression:\n    return self\n\n\nclass Constant(Expression):\n  \"\"\"A constant within the expression tree.\"\"\"\n\n  def __init__(self, value: Union[float, str]):\n    ctx = decimal.Context()\n    ctx.prec = 20\n    dec = ctx.create_decimal(repr(value) if isinstance(value, float) else value)\n    self.value = dec.normalize().to_eng_string()\n    self.value = self.value.replace('+', '')\n    self.value = self.value.replace('E', 'e')\n\n  def ToPerfJson(self):\n    return self.value\n\n  def ToPython(self):\n    return f'Constant({self.value})'\n\n  def Simplify(self) -> Expression:\n    return self\n\n  def Equals(self, other: Expression) -> bool:\n    return isinstance(other, Constant) and self.value == other.value\n\n  def Substitute(self, name: str, expression: Expression) -> Expression:\n    return self\n\n\nclass Literal(Expression):\n  \"\"\"A runtime literal within the expression tree.\"\"\"\n\n  def __init__(self, value: str):\n    self.value = value\n\n  def ToPerfJson(self):\n    return self.value\n\n  def ToPython(self):\n    return f'Literal({self.value})'\n\n  def Simplify(self) -> Expression:\n    return self\n\n  def Equals(self, other: Expression) -> bool:\n    return isinstance(other, Literal) and self.value == other.value\n\n  def Substitute(self, name: str, expression: Expression) -> Expression:\n    return self\n\n\ndef min(lhs: Union[int, float, Expression], rhs: Union[int, float,\n                                                       Expression]) -> Function:\n  # pylint: disable=redefined-builtin\n  # pylint: disable=invalid-name\n  return Function('min', lhs, rhs)\n\n\ndef max(lhs: Union[int, float, Expression], rhs: Union[int, float,\n                                                       Expression]) -> Function:\n  # pylint: disable=redefined-builtin\n  # pylint: disable=invalid-name\n  return Function('max', lhs, rhs)\n\n\ndef d_ratio(lhs: Union[int, float, Expression],\n            rhs: Union[int, float, Expression]) -> Function:\n  # pylint: disable=redefined-builtin\n  # pylint: disable=invalid-name\n  return Function('d_ratio', lhs, rhs)\n\n\ndef source_count(event: Event) -> Function:\n  # pylint: disable=redefined-builtin\n  # pylint: disable=invalid-name\n  return Function('source_count', event)\n\n\ndef has_event(event: Event) -> Function:\n  # pylint: disable=redefined-builtin\n  # pylint: disable=invalid-name\n  return Function('has_event', event)\n\ndef strcmp_cpuid_str(cpuid: Event) -> Function:\n  # pylint: disable=redefined-builtin\n  # pylint: disable=invalid-name\n  return Function('strcmp_cpuid_str', cpuid)\n\nclass Metric:\n  \"\"\"An individual metric that will specifiable on the perf command line.\"\"\"\n  groups: Set[str]\n  expr: Expression\n  scale_unit: str\n  constraint: bool\n\n  def __init__(self,\n               name: str,\n               description: str,\n               expr: Expression,\n               scale_unit: str,\n               constraint: bool = False):\n    self.name = name\n    self.description = description\n    self.expr = expr.Simplify()\n    # Workraound valid_only_metric hiding certain metrics based on unit.\n    scale_unit = scale_unit.replace('/sec', ' per sec')\n    if scale_unit[0].isdigit():\n      self.scale_unit = scale_unit\n    else:\n      self.scale_unit = f'1{scale_unit}'\n    self.constraint = constraint\n    self.groups = set()\n\n  def __lt__(self, other):\n    \"\"\"Sort order.\"\"\"\n    return self.name < other.name\n\n  def AddToMetricGroup(self, group):\n    \"\"\"Callback used when being added to a MetricGroup.\"\"\"\n    self.groups.add(group.name)\n\n  def Flatten(self) -> Set['Metric']:\n    \"\"\"Return a leaf metric.\"\"\"\n    return set([self])\n\n  def ToPerfJson(self) -> Dict[str, str]:\n    \"\"\"Return as dictionary for Json generation.\"\"\"\n    result = {\n        'MetricName': self.name,\n        'MetricGroup': ';'.join(sorted(self.groups)),\n        'BriefDescription': self.description,\n        'MetricExpr': self.expr.ToPerfJson(),\n        'ScaleUnit': self.scale_unit\n    }\n    if self.constraint:\n      result['MetricConstraint'] = 'NO_NMI_WATCHDOG'\n\n    return result\n\n\nclass _MetricJsonEncoder(json.JSONEncoder):\n  \"\"\"Special handling for Metric objects.\"\"\"\n\n  def default(self, o):\n    if isinstance(o, Metric):\n      return o.ToPerfJson()\n    return json.JSONEncoder.default(self, o)\n\n\nclass MetricGroup:\n  \"\"\"A group of metrics.\n\n  Metric groups may be specificd on the perf command line, but within\n  the json they aren't encoded. Metrics may be in multiple groups\n  which can facilitate arrangements similar to trees.\n  \"\"\"\n\n  def __init__(self, name: str, metric_list: List[Union[Metric,\n                                                        'MetricGroup']]):\n    self.name = name\n    self.metric_list = metric_list\n    for metric in metric_list:\n      metric.AddToMetricGroup(self)\n\n  def AddToMetricGroup(self, group):\n    \"\"\"Callback used when a MetricGroup is added into another.\"\"\"\n    for metric in self.metric_list:\n      metric.AddToMetricGroup(group)\n\n  def Flatten(self) -> Set[Metric]:\n    \"\"\"Returns a set of all leaf metrics.\"\"\"\n    result = set()\n    for x in self.metric_list:\n      result = result.union(x.Flatten())\n\n    return result\n\n  def ToPerfJson(self) -> str:\n    return json.dumps(sorted(self.Flatten()), indent=2, cls=_MetricJsonEncoder)\n\n  def __str__(self) -> str:\n    return self.ToPerfJson()\n\n\nclass _RewriteIfExpToSelect(ast.NodeTransformer):\n  \"\"\"Transformer to convert if-else nodes to Select expressions.\"\"\"\n\n  def visit_IfExp(self, node):\n    # pylint: disable=invalid-name\n    self.generic_visit(node)\n    call = ast.Call(\n        func=ast.Name(id='Select', ctx=ast.Load()),\n        args=[node.body, node.test, node.orelse],\n        keywords=[])\n    ast.copy_location(call, node.test)\n    return call\n\n\ndef ParsePerfJson(orig: str) -> Expression:\n  \"\"\"A simple json metric expression decoder.\n\n  Converts a json encoded metric expression by way of python's ast and\n  eval routine. First tokens are mapped to Event calls, then\n  accidentally converted keywords or literals are mapped to their\n  appropriate calls. Python's ast is used to match if-else that can't\n  be handled via operator overloading. Finally the ast is evaluated.\n\n  Args:\n    orig (str): String to parse.\n\n  Returns:\n    Expression: The parsed string.\n  \"\"\"\n  # pylint: disable=eval-used\n  py = orig.strip()\n  # First try to convert everything that looks like a string (event name) into Event(r\"EVENT_NAME\").\n  # This isn't very selective so is followed up by converting some unwanted conversions back again\n  py = re.sub(r'([a-zA-Z][^-+/\\* \\\\\\(\\),]*(?:\\\\.[^-+/\\* \\\\\\(\\),]*)*)',\n              r'Event(r\"\\1\")', py)\n  # If it started with a # it should have been a literal, rather than an event name\n  py = re.sub(r'#Event\\(r\"([^\"]*)\"\\)', r'Literal(\"#\\1\")', py)\n  # Convert accidentally converted hex constants (\"0Event(r\"xDEADBEEF)\"\") back to a constant,\n  # but keep it wrapped in Event(), otherwise Python drops the 0x prefix and it gets interpreted as\n  # a double by the Bison parser\n  py = re.sub(r'0Event\\(r\"[xX]([0-9a-fA-F]*)\"\\)', r'Event(\"0x\\1\")', py)\n  # Convert accidentally converted scientific notation constants back\n  py = re.sub(r'([0-9]+)Event\\(r\"(e[0-9]+)\"\\)', r'\\1\\2', py)\n  # Convert all the known keywords back from events to just the keyword\n  keywords = ['if', 'else', 'min', 'max', 'd_ratio', 'source_count', 'has_event', 'strcmp_cpuid_str',\n              'cpuid_not_more_than']\n  for kw in keywords:\n    py = re.sub(rf'Event\\(r\"{kw}\"\\)', kw, py)\n  try:\n    parsed = ast.parse(py, mode='eval')\n  except SyntaxError as e:\n    raise SyntaxError(f'Parsing expression:\\n{orig}') from e\n  _RewriteIfExpToSelect().visit(parsed)\n  parsed = ast.fix_missing_locations(parsed)\n  return _Constify(eval(compile(parsed, orig, 'eval')))\n\n\ndef RewriteMetricsInTermsOfOthers(metrics: List[Tuple[str, str, Expression]]\n                                  )-> Dict[Tuple[str, str], Expression]:\n  \"\"\"Shorten metrics by rewriting in terms of others.\n\n  Args:\n    metrics (list): pmus, metric names and their expressions.\n  Returns:\n    Dict: mapping from a pmu, metric name pair to a shortened expression.\n  \"\"\"\n  updates: Dict[Tuple[str, str], Expression] = dict()\n  for outer_pmu, outer_name, outer_expression in metrics:\n    if outer_pmu is None:\n      outer_pmu = 'cpu'\n    updated = outer_expression\n    while True:\n      for inner_pmu, inner_name, inner_expression in metrics:\n        if inner_pmu is None:\n          inner_pmu = 'cpu'\n        if inner_pmu.lower() != outer_pmu.lower():\n          continue\n        if inner_name.lower() == outer_name.lower():\n          continue\n        if (inner_pmu, inner_name) in updates:\n          inner_expression = updates[(inner_pmu, inner_name)]\n        updated = updated.Substitute(inner_name, inner_expression)\n      if updated.Equals(outer_expression):\n        break\n      if (outer_pmu, outer_name) in updates and updated.Equals(updates[(outer_pmu, outer_name)]):\n        break\n      updates[(outer_pmu, outer_name)] = updated\n  return updates\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}