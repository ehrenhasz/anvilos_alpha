{
  "module_name": "mem-functions.c",
  "hash_id": "c12661f13d2f79d2cc932922f9435f75486d1c49e071bc7e05a22e99c8d2262a",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/mem-functions.c",
  "human_readable_source": "\n \n\n#include \"debug.h\"\n#include \"../perf-sys.h\"\n#include <subcmd/parse-options.h>\n#include \"../util/header.h\"\n#include \"../util/cloexec.h\"\n#include \"../util/string2.h\"\n#include \"bench.h\"\n#include \"mem-memcpy-arch.h\"\n#include \"mem-memset-arch.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <linux/time64.h>\n#include <linux/zalloc.h>\n\n#define K 1024\n\nstatic const char\t*size_str\t= \"1MB\";\nstatic const char\t*function_str\t= \"all\";\nstatic int\t\tnr_loops\t= 1;\nstatic bool\t\tuse_cycles;\nstatic int\t\tcycles_fd;\n\nstatic const struct option options[] = {\n\tOPT_STRING('s', \"size\", &size_str, \"1MB\",\n\t\t    \"Specify the size of the memory buffers. \"\n\t\t    \"Available units: B, KB, MB, GB and TB (case insensitive)\"),\n\n\tOPT_STRING('f', \"function\", &function_str, \"all\",\n\t\t    \"Specify the function to run, \\\"all\\\" runs all available functions, \\\"help\\\" lists them\"),\n\n\tOPT_INTEGER('l', \"nr_loops\", &nr_loops,\n\t\t    \"Specify the number of loops to run. (default: 1)\"),\n\n\tOPT_BOOLEAN('c', \"cycles\", &use_cycles,\n\t\t    \"Use a cycles event instead of gettimeofday() to measure performance\"),\n\n\tOPT_END()\n};\n\ntypedef void *(*memcpy_t)(void *, const void *, size_t);\ntypedef void *(*memset_t)(void *, int, size_t);\n\nstruct function {\n\tconst char *name;\n\tconst char *desc;\n\tunion {\n\t\tmemcpy_t memcpy;\n\t\tmemset_t memset;\n\t} fn;\n};\n\nstatic struct perf_event_attr cycle_attr = {\n\t.type\t\t= PERF_TYPE_HARDWARE,\n\t.config\t\t= PERF_COUNT_HW_CPU_CYCLES\n};\n\nstatic int init_cycles(void)\n{\n\tcycles_fd = sys_perf_event_open(&cycle_attr, getpid(), -1, -1, perf_event_open_cloexec_flag());\n\n\tif (cycles_fd < 0 && errno == ENOSYS) {\n\t\tpr_debug(\"No CONFIG_PERF_EVENTS=y kernel support configured?\\n\");\n\t\treturn -1;\n\t}\n\n\treturn cycles_fd;\n}\n\nstatic u64 get_cycles(void)\n{\n\tint ret;\n\tu64 clk;\n\n\tret = read(cycles_fd, &clk, sizeof(u64));\n\tBUG_ON(ret != sizeof(u64));\n\n\treturn clk;\n}\n\nstatic double timeval2double(struct timeval *ts)\n{\n\treturn (double)ts->tv_sec + (double)ts->tv_usec / (double)USEC_PER_SEC;\n}\n\n#define print_bps(x) do {\t\t\t\t\t\t\\\n\t\tif (x < K)\t\t\t\t\t\t\\\n\t\t\tprintf(\" %14lf bytes/sec\\n\", x);\t\t\\\n\t\telse if (x < K * K)\t\t\t\t\t\\\n\t\t\tprintf(\" %14lfd KB/sec\\n\", x / K);\t\t\\\n\t\telse if (x < K * K * K)\t\t\t\t\t\\\n\t\t\tprintf(\" %14lf MB/sec\\n\", x / K / K);\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tprintf(\" %14lf GB/sec\\n\", x / K / K / K);\t\\\n\t} while (0)\n\nstruct bench_mem_info {\n\tconst struct function *functions;\n\tu64 (*do_cycles)(const struct function *r, size_t size, void *src, void *dst);\n\tdouble (*do_gettimeofday)(const struct function *r, size_t size, void *src, void *dst);\n\tconst char *const *usage;\n\tbool alloc_src;\n};\n\nstatic void __bench_mem_function(struct bench_mem_info *info, int r_idx, size_t size, double size_total)\n{\n\tconst struct function *r = &info->functions[r_idx];\n\tdouble result_bps = 0.0;\n\tu64 result_cycles = 0;\n\tvoid *src = NULL, *dst = zalloc(size);\n\n\tprintf(\"# function '%s' (%s)\\n\", r->name, r->desc);\n\n\tif (dst == NULL)\n\t\tgoto out_alloc_failed;\n\n\tif (info->alloc_src) {\n\t\tsrc = zalloc(size);\n\t\tif (src == NULL)\n\t\t\tgoto out_alloc_failed;\n\t}\n\n\tif (bench_format == BENCH_FORMAT_DEFAULT)\n\t\tprintf(\"# Copying %s bytes ...\\n\\n\", size_str);\n\n\tif (use_cycles) {\n\t\tresult_cycles = info->do_cycles(r, size, src, dst);\n\t} else {\n\t\tresult_bps = info->do_gettimeofday(r, size, src, dst);\n\t}\n\n\tswitch (bench_format) {\n\tcase BENCH_FORMAT_DEFAULT:\n\t\tif (use_cycles) {\n\t\t\tprintf(\" %14lf cycles/byte\\n\", (double)result_cycles/size_total);\n\t\t} else {\n\t\t\tprint_bps(result_bps);\n\t\t}\n\t\tbreak;\n\n\tcase BENCH_FORMAT_SIMPLE:\n\t\tif (use_cycles) {\n\t\t\tprintf(\"%lf\\n\", (double)result_cycles/size_total);\n\t\t} else {\n\t\t\tprintf(\"%lf\\n\", result_bps);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\nout_free:\n\tfree(src);\n\tfree(dst);\n\treturn;\nout_alloc_failed:\n\tprintf(\"# Memory allocation failed - maybe size (%s) is too large?\\n\", size_str);\n\tgoto out_free;\n}\n\nstatic int bench_mem_common(int argc, const char **argv, struct bench_mem_info *info)\n{\n\tint i;\n\tsize_t size;\n\tdouble size_total;\n\n\targc = parse_options(argc, argv, options, info->usage, 0);\n\n\tif (use_cycles) {\n\t\ti = init_cycles();\n\t\tif (i < 0) {\n\t\t\tfprintf(stderr, \"Failed to open cycles counter\\n\");\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tsize = (size_t)perf_atoll((char *)size_str);\n\tsize_total = (double)size * nr_loops;\n\n\tif ((s64)size <= 0) {\n\t\tfprintf(stderr, \"Invalid size:%s\\n\", size_str);\n\t\treturn 1;\n\t}\n\n\tif (!strncmp(function_str, \"all\", 3)) {\n\t\tfor (i = 0; info->functions[i].name; i++)\n\t\t\t__bench_mem_function(info, i, size, size_total);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; info->functions[i].name; i++) {\n\t\tif (!strcmp(info->functions[i].name, function_str))\n\t\t\tbreak;\n\t}\n\tif (!info->functions[i].name) {\n\t\tif (strcmp(function_str, \"help\") && strcmp(function_str, \"h\"))\n\t\t\tprintf(\"Unknown function: %s\\n\", function_str);\n\t\tprintf(\"Available functions:\\n\");\n\t\tfor (i = 0; info->functions[i].name; i++) {\n\t\t\tprintf(\"\\t%s ... %s\\n\",\n\t\t\t       info->functions[i].name, info->functions[i].desc);\n\t\t}\n\t\treturn 1;\n\t}\n\n\t__bench_mem_function(info, i, size, size_total);\n\n\treturn 0;\n}\n\nstatic void memcpy_prefault(memcpy_t fn, size_t size, void *src, void *dst)\n{\n\t \n\tmemset(src, 0, size);\n\n\t \n\tfn(dst, src, size);\n}\n\nstatic u64 do_memcpy_cycles(const struct function *r, size_t size, void *src, void *dst)\n{\n\tu64 cycle_start = 0ULL, cycle_end = 0ULL;\n\tmemcpy_t fn = r->fn.memcpy;\n\tint i;\n\n\tmemcpy_prefault(fn, size, src, dst);\n\n\tcycle_start = get_cycles();\n\tfor (i = 0; i < nr_loops; ++i)\n\t\tfn(dst, src, size);\n\tcycle_end = get_cycles();\n\n\treturn cycle_end - cycle_start;\n}\n\nstatic double do_memcpy_gettimeofday(const struct function *r, size_t size, void *src, void *dst)\n{\n\tstruct timeval tv_start, tv_end, tv_diff;\n\tmemcpy_t fn = r->fn.memcpy;\n\tint i;\n\n\tmemcpy_prefault(fn, size, src, dst);\n\n\tBUG_ON(gettimeofday(&tv_start, NULL));\n\tfor (i = 0; i < nr_loops; ++i)\n\t\tfn(dst, src, size);\n\tBUG_ON(gettimeofday(&tv_end, NULL));\n\n\ttimersub(&tv_end, &tv_start, &tv_diff);\n\n\treturn (double)(((double)size * nr_loops) / timeval2double(&tv_diff));\n}\n\nstruct function memcpy_functions[] = {\n\t{ .name\t\t= \"default\",\n\t  .desc\t\t= \"Default memcpy() provided by glibc\",\n\t  .fn.memcpy\t= memcpy },\n\n#ifdef HAVE_ARCH_X86_64_SUPPORT\n# define MEMCPY_FN(_fn, _name, _desc) {.name = _name, .desc = _desc, .fn.memcpy = _fn},\n# include \"mem-memcpy-x86-64-asm-def.h\"\n# undef MEMCPY_FN\n#endif\n\n\t{ .name = NULL, }\n};\n\nstatic const char * const bench_mem_memcpy_usage[] = {\n\t\"perf bench mem memcpy <options>\",\n\tNULL\n};\n\nint bench_mem_memcpy(int argc, const char **argv)\n{\n\tstruct bench_mem_info info = {\n\t\t.functions\t\t= memcpy_functions,\n\t\t.do_cycles\t\t= do_memcpy_cycles,\n\t\t.do_gettimeofday\t= do_memcpy_gettimeofday,\n\t\t.usage\t\t\t= bench_mem_memcpy_usage,\n\t\t.alloc_src              = true,\n\t};\n\n\treturn bench_mem_common(argc, argv, &info);\n}\n\nstatic u64 do_memset_cycles(const struct function *r, size_t size, void *src __maybe_unused, void *dst)\n{\n\tu64 cycle_start = 0ULL, cycle_end = 0ULL;\n\tmemset_t fn = r->fn.memset;\n\tint i;\n\n\t \n\tfn(dst, -1, size);\n\n\tcycle_start = get_cycles();\n\tfor (i = 0; i < nr_loops; ++i)\n\t\tfn(dst, i, size);\n\tcycle_end = get_cycles();\n\n\treturn cycle_end - cycle_start;\n}\n\nstatic double do_memset_gettimeofday(const struct function *r, size_t size, void *src __maybe_unused, void *dst)\n{\n\tstruct timeval tv_start, tv_end, tv_diff;\n\tmemset_t fn = r->fn.memset;\n\tint i;\n\n\t \n\tfn(dst, -1, size);\n\n\tBUG_ON(gettimeofday(&tv_start, NULL));\n\tfor (i = 0; i < nr_loops; ++i)\n\t\tfn(dst, i, size);\n\tBUG_ON(gettimeofday(&tv_end, NULL));\n\n\ttimersub(&tv_end, &tv_start, &tv_diff);\n\n\treturn (double)(((double)size * nr_loops) / timeval2double(&tv_diff));\n}\n\nstatic const char * const bench_mem_memset_usage[] = {\n\t\"perf bench mem memset <options>\",\n\tNULL\n};\n\nstatic const struct function memset_functions[] = {\n\t{ .name\t\t= \"default\",\n\t  .desc\t\t= \"Default memset() provided by glibc\",\n\t  .fn.memset\t= memset },\n\n#ifdef HAVE_ARCH_X86_64_SUPPORT\n# define MEMSET_FN(_fn, _name, _desc) { .name = _name, .desc = _desc, .fn.memset = _fn },\n# include \"mem-memset-x86-64-asm-def.h\"\n# undef MEMSET_FN\n#endif\n\n\t{ .name = NULL, }\n};\n\nint bench_mem_memset(int argc, const char **argv)\n{\n\tstruct bench_mem_info info = {\n\t\t.functions\t\t= memset_functions,\n\t\t.do_cycles\t\t= do_memset_cycles,\n\t\t.do_gettimeofday\t= do_memset_gettimeofday,\n\t\t.usage\t\t\t= bench_mem_memset_usage,\n\t};\n\n\treturn bench_mem_common(argc, argv, &info);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}