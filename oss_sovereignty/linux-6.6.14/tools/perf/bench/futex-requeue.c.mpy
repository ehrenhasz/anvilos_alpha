{
  "module_name": "futex-requeue.c",
  "hash_id": "27903a68127bf3a4e5d80fd38021211e32f85c171cb9861d6a592fc934d4f352",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/futex-requeue.c",
  "human_readable_source": "\n \n\n \n#include <string.h>\n#include <pthread.h>\n\n#include <signal.h>\n#include \"../util/mutex.h\"\n#include \"../util/stat.h\"\n#include <subcmd/parse-options.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/time64.h>\n#include <errno.h>\n#include <perf/cpumap.h>\n#include \"bench.h\"\n#include \"futex.h\"\n\n#include <err.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/mman.h>\n\nstatic u_int32_t futex1 = 0, futex2 = 0;\n\nstatic pthread_t *worker;\nstatic bool done = false;\nstatic struct mutex thread_lock;\nstatic struct cond thread_parent, thread_worker;\nstatic struct stats requeuetime_stats, requeued_stats;\nstatic unsigned int threads_starting;\nstatic int futex_flag = 0;\n\nstatic struct bench_futex_parameters params = {\n\t \n\t.nrequeue = 1,\n};\n\nstatic const struct option options[] = {\n\tOPT_UINTEGER('t', \"threads\",  &params.nthreads, \"Specify amount of threads\"),\n\tOPT_UINTEGER('q', \"nrequeue\", &params.nrequeue, \"Specify amount of threads to requeue at once\"),\n\tOPT_BOOLEAN( 's', \"silent\",   &params.silent, \"Silent mode: do not display data/details\"),\n\tOPT_BOOLEAN( 'S', \"shared\",   &params.fshared, \"Use shared futexes instead of private ones\"),\n\tOPT_BOOLEAN( 'm', \"mlockall\", &params.mlockall, \"Lock all current and future memory\"),\n\tOPT_BOOLEAN( 'B', \"broadcast\", &params.broadcast, \"Requeue all threads at once\"),\n\tOPT_BOOLEAN( 'p', \"pi\", &params.pi, \"Use PI-aware variants of FUTEX_CMP_REQUEUE\"),\n\n\tOPT_END()\n};\n\nstatic const char * const bench_futex_requeue_usage[] = {\n\t\"perf bench futex requeue <options>\",\n\tNULL\n};\n\nstatic void print_summary(void)\n{\n\tdouble requeuetime_avg = avg_stats(&requeuetime_stats);\n\tdouble requeuetime_stddev = stddev_stats(&requeuetime_stats);\n\tunsigned int requeued_avg = avg_stats(&requeued_stats);\n\n\tprintf(\"Requeued %d of %d threads in %.4f ms (+-%.2f%%)\\n\",\n\t       requeued_avg,\n\t       params.nthreads,\n\t       requeuetime_avg / USEC_PER_MSEC,\n\t       rel_stddev_stats(requeuetime_stddev, requeuetime_avg));\n}\n\nstatic void *workerfn(void *arg __maybe_unused)\n{\n\tint ret;\n\n\tmutex_lock(&thread_lock);\n\tthreads_starting--;\n\tif (!threads_starting)\n\t\tcond_signal(&thread_parent);\n\tcond_wait(&thread_worker, &thread_lock);\n\tmutex_unlock(&thread_lock);\n\n\twhile (1) {\n\t\tif (!params.pi) {\n\t\t\tret = futex_wait(&futex1, 0, NULL, futex_flag);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\n\t\t\tif (ret && errno != EAGAIN) {\n\t\t\t\tif (!params.silent)\n\t\t\t\t\twarnx(\"futex_wait\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = futex_wait_requeue_pi(&futex1, 0, &futex2,\n\t\t\t\t\t\t    NULL, futex_flag);\n\t\t\tif (!ret) {\n\t\t\t\t \n\t\t\t\tfutex_unlock_pi(&futex2, futex_flag);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ret && errno != EAGAIN) {\n\t\t\t\tif (!params.silent)\n\t\t\t\t\twarnx(\"futex_wait_requeue_pi\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void block_threads(pthread_t *w, struct perf_cpu_map *cpu)\n{\n\tcpu_set_t *cpuset;\n\tunsigned int i;\n\tint nrcpus = perf_cpu_map__nr(cpu);\n\tsize_t size;\n\n\tthreads_starting = params.nthreads;\n\n\tcpuset = CPU_ALLOC(nrcpus);\n\tBUG_ON(!cpuset);\n\tsize = CPU_ALLOC_SIZE(nrcpus);\n\n\t \n\tfor (i = 0; i < params.nthreads; i++) {\n\t\tpthread_attr_t thread_attr;\n\n\t\tpthread_attr_init(&thread_attr);\n\t\tCPU_ZERO_S(size, cpuset);\n\t\tCPU_SET_S(perf_cpu_map__cpu(cpu, i % perf_cpu_map__nr(cpu)).cpu, size, cpuset);\n\n\t\tif (pthread_attr_setaffinity_np(&thread_attr, size, cpuset)) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_attr_setaffinity_np\");\n\t\t}\n\n\t\tif (pthread_create(&w[i], &thread_attr, workerfn, NULL)) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_create\");\n\t\t}\n\t\tpthread_attr_destroy(&thread_attr);\n\t}\n\tCPU_FREE(cpuset);\n}\n\nstatic void toggle_done(int sig __maybe_unused,\n\t\t\tsiginfo_t *info __maybe_unused,\n\t\t\tvoid *uc __maybe_unused)\n{\n\tdone = true;\n}\n\nint bench_futex_requeue(int argc, const char **argv)\n{\n\tint ret = 0;\n\tunsigned int i, j;\n\tstruct sigaction act;\n\tstruct perf_cpu_map *cpu;\n\n\targc = parse_options(argc, argv, options, bench_futex_requeue_usage, 0);\n\tif (argc)\n\t\tgoto err;\n\n\tcpu = perf_cpu_map__new(NULL);\n\tif (!cpu)\n\t\terr(EXIT_FAILURE, \"cpu_map__new\");\n\n\tmemset(&act, 0, sizeof(act));\n\tsigfillset(&act.sa_mask);\n\tact.sa_sigaction = toggle_done;\n\tsigaction(SIGINT, &act, NULL);\n\n\tif (params.mlockall) {\n\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE))\n\t\t\terr(EXIT_FAILURE, \"mlockall\");\n\t}\n\n\tif (!params.nthreads)\n\t\tparams.nthreads = perf_cpu_map__nr(cpu);\n\n\tworker = calloc(params.nthreads, sizeof(*worker));\n\tif (!worker)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tif (!params.fshared)\n\t\tfutex_flag = FUTEX_PRIVATE_FLAG;\n\n\tif (params.nrequeue > params.nthreads)\n\t\tparams.nrequeue = params.nthreads;\n\n\tif (params.broadcast)\n\t\tparams.nrequeue = params.nthreads;\n\n\tprintf(\"Run summary [PID %d]: Requeuing %d threads (from [%s] %p to %s%p), \"\n\t       \"%d at a time.\\n\\n\",  getpid(), params.nthreads,\n\t       params.fshared ? \"shared\":\"private\", &futex1,\n\t       params.pi ? \"PI \": \"\", &futex2, params.nrequeue);\n\n\tinit_stats(&requeued_stats);\n\tinit_stats(&requeuetime_stats);\n\tmutex_init(&thread_lock);\n\tcond_init(&thread_parent);\n\tcond_init(&thread_worker);\n\n\tfor (j = 0; j < bench_repeat && !done; j++) {\n\t\tunsigned int nrequeued = 0, wakeups = 0;\n\t\tstruct timeval start, end, runtime;\n\n\t\t \n\t\tblock_threads(worker, cpu);\n\n\t\t \n\t\tmutex_lock(&thread_lock);\n\t\twhile (threads_starting)\n\t\t\tcond_wait(&thread_parent, &thread_lock);\n\t\tcond_broadcast(&thread_worker);\n\t\tmutex_unlock(&thread_lock);\n\n\t\tusleep(100000);\n\n\t\t \n\t\tgettimeofday(&start, NULL);\n\t\twhile (nrequeued < params.nthreads) {\n\t\t\tint r;\n\n\t\t\t \n\t\t\tif (!params.pi) {\n\t\t\t\tr = futex_cmp_requeue(&futex1, 0, &futex2, 0,\n\t\t\t\t\t\t      params.nrequeue,\n\t\t\t\t\t\t      futex_flag);\n\t\t\t} else {\n\t\t\t\tr = futex_cmp_requeue_pi(&futex1, 0, &futex2,\n\t\t\t\t\t\t\t params.nrequeue,\n\t\t\t\t\t\t\t futex_flag);\n\t\t\t\twakeups++;  \n\t\t\t}\n\n\t\t\tif (r < 0)\n\t\t\t\terr(EXIT_FAILURE, \"couldn't requeue from %p to %p\",\n\t\t\t\t    &futex1, &futex2);\n\n\t\t\tnrequeued += r;\n\t\t}\n\n\t\tgettimeofday(&end, NULL);\n\t\ttimersub(&end, &start, &runtime);\n\n\t\tupdate_stats(&requeued_stats, nrequeued);\n\t\tupdate_stats(&requeuetime_stats, runtime.tv_usec);\n\n\t\tif (!params.silent) {\n\t\t\tif (!params.pi)\n\t\t\t\tprintf(\"[Run %d]: Requeued %d of %d threads in \"\n\t\t\t\t       \"%.4f ms\\n\", j + 1, nrequeued,\n\t\t\t\t       params.nthreads,\n\t\t\t\t       runtime.tv_usec / (double)USEC_PER_MSEC);\n\t\t\telse {\n\t\t\t\tnrequeued -= wakeups;\n\t\t\t\tprintf(\"[Run %d]: Awoke and Requeued (%d+%d) of \"\n\t\t\t\t       \"%d threads in %.4f ms\\n\",\n\t\t\t\t       j + 1, wakeups, nrequeued,\n\t\t\t\t       params.nthreads,\n\t\t\t\t       runtime.tv_usec / (double)USEC_PER_MSEC);\n\t\t\t}\n\n\t\t}\n\n\t\tif (!params.pi) {\n\t\t\t \n\t\t\tnrequeued = futex_wake(&futex2, nrequeued, futex_flag);\n\t\t\tif (params.nthreads != nrequeued)\n\t\t\t\twarnx(\"couldn't wakeup all tasks (%d/%d)\",\n\t\t\t\t      nrequeued, params.nthreads);\n\t\t}\n\n\t\tfor (i = 0; i < params.nthreads; i++) {\n\t\t\tret = pthread_join(worker[i], NULL);\n\t\t\tif (ret)\n\t\t\t\terr(EXIT_FAILURE, \"pthread_join\");\n\t\t}\n\t}\n\n\t \n\tcond_destroy(&thread_parent);\n\tcond_destroy(&thread_worker);\n\tmutex_destroy(&thread_lock);\n\n\tprint_summary();\n\n\tfree(worker);\n\tperf_cpu_map__put(cpu);\n\treturn ret;\nerr:\n\tusage_with_options(bench_futex_requeue_usage, options);\n\texit(EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}