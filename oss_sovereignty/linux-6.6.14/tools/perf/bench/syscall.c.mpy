{
  "module_name": "syscall.c",
  "hash_id": "3bd0dd38afb74c9b5f6be26db3635d2d116792d35dbf37b034a5908c8067176f",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/syscall.c",
  "human_readable_source": " \n#include \"../perf.h\"\n#include \"../util/util.h\"\n#include <subcmd/parse-options.h>\n#include \"../builtin.h\"\n#include \"bench.h\"\n\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n#ifndef __NR_fork\n#define __NR_fork -1\n#endif\n\n#define LOOPS_DEFAULT 10000000\nstatic\tint loops = LOOPS_DEFAULT;\n\nstatic const struct option options[] = {\n\tOPT_INTEGER('l', \"loop\",\t&loops,\t\t\"Specify number of loops\"),\n\tOPT_END()\n};\n\nstatic const char * const bench_syscall_usage[] = {\n\t\"perf bench syscall <options>\",\n\tNULL\n};\n\nstatic void test_fork(void)\n{\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tfprintf(stderr, \"fork failed\\n\");\n\t\texit(1);\n\t} else if (pid == 0) {\n\t\texit(0);\n\t} else {\n\t\tif (waitpid(pid, NULL, 0) < 0) {\n\t\t\tfprintf(stderr, \"waitpid failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n}\n\nstatic void test_execve(void)\n{\n\tconst char *pathname = \"/bin/true\";\n\tchar *const argv[] = { (char *)pathname, NULL };\n\tpid_t pid = fork();\n\n\tif (pid < 0) {\n\t\tfprintf(stderr, \"fork failed\\n\");\n\t\texit(1);\n\t} else if (pid == 0) {\n\t\texecve(pathname, argv, NULL);\n\t\tfprintf(stderr, \"execve /bin/true failed\\n\");\n\t\texit(1);\n\t} else {\n\t\tif (waitpid(pid, NULL, 0) < 0) {\n\t\t\tfprintf(stderr, \"waitpid failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n}\n\nstatic int bench_syscall_common(int argc, const char **argv, int syscall)\n{\n\tstruct timeval start, stop, diff;\n\tunsigned long long result_usec = 0;\n\tconst char *name = NULL;\n\tint i;\n\n\targc = parse_options(argc, argv, options, bench_syscall_usage, 0);\n\n\tgettimeofday(&start, NULL);\n\n\tfor (i = 0; i < loops; i++) {\n\t\tswitch (syscall) {\n\t\tcase __NR_getppid:\n\t\t\tgetppid();\n\t\t\tbreak;\n\t\tcase __NR_getpgid:\n\t\t\tgetpgid(0);\n\t\t\tbreak;\n\t\tcase __NR_fork:\n\t\t\ttest_fork();\n\t\t\t \n\t\t\tif (i == 10000)\n\t\t\t\tloops = 10000;\n\t\t\tbreak;\n\t\tcase __NR_execve:\n\t\t\ttest_execve();\n\t\t\t \n\t\t\tif (i == 10000)\n\t\t\t\tloops = 10000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgettimeofday(&stop, NULL);\n\ttimersub(&stop, &start, &diff);\n\n\tswitch (syscall) {\n\tcase __NR_getppid:\n\t\tname = \"getppid()\";\n\t\tbreak;\n\tcase __NR_getpgid:\n\t\tname = \"getpgid()\";\n\t\tbreak;\n\tcase __NR_fork:\n\t\tname = \"fork()\";\n\t\tbreak;\n\tcase __NR_execve:\n\t\tname = \"execve()\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (bench_format) {\n\tcase BENCH_FORMAT_DEFAULT:\n\t\tprintf(\"# Executed %'d %s calls\\n\", loops, name);\n\n\t\tresult_usec = diff.tv_sec * 1000000;\n\t\tresult_usec += diff.tv_usec;\n\n\t\tprintf(\" %14s: %lu.%03lu [sec]\\n\\n\", \"Total time\",\n\t\t       (unsigned long) diff.tv_sec,\n\t\t       (unsigned long) (diff.tv_usec/1000));\n\n\t\tprintf(\" %14lf usecs/op\\n\",\n\t\t       (double)result_usec / (double)loops);\n\t\tprintf(\" %'14d ops/sec\\n\",\n\t\t       (int)((double)loops /\n\t\t\t     ((double)result_usec / (double)1000000)));\n\t\tbreak;\n\n\tcase BENCH_FORMAT_SIMPLE:\n\t\tprintf(\"%lu.%03lu\\n\",\n\t\t       (unsigned long) diff.tv_sec,\n\t\t       (unsigned long) (diff.tv_usec / 1000));\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tfprintf(stderr, \"Unknown format:%d\\n\", bench_format);\n\t\texit(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint bench_syscall_basic(int argc, const char **argv)\n{\n\treturn bench_syscall_common(argc, argv, __NR_getppid);\n}\n\nint bench_syscall_getpgid(int argc, const char **argv)\n{\n\treturn bench_syscall_common(argc, argv, __NR_getpgid);\n}\n\nint bench_syscall_fork(int argc, const char **argv)\n{\n\treturn bench_syscall_common(argc, argv, __NR_fork);\n}\n\nint bench_syscall_execve(int argc, const char **argv)\n{\n\treturn bench_syscall_common(argc, argv, __NR_execve);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}