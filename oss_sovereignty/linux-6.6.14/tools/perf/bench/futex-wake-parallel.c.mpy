{
  "module_name": "futex-wake-parallel.c",
  "hash_id": "e38e740562e14ac4e57ef96fe4f7454994d16f459dd5b62607a335933c7f5f65",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/futex-wake-parallel.c",
  "human_readable_source": "\n \n#include \"bench.h\"\n#include <linux/compiler.h>\n#include \"../util/debug.h\"\n#include \"../util/mutex.h\"\n\n#ifndef HAVE_PTHREAD_BARRIER\nint bench_futex_wake_parallel(int argc __maybe_unused, const char **argv __maybe_unused)\n{\n\tpr_err(\"%s: pthread_barrier_t unavailable, disabling this test...\\n\", __func__);\n\treturn 0;\n}\n#else  \n \n#include <string.h>\n#include <pthread.h>\n\n#include <signal.h>\n#include \"../util/stat.h\"\n#include <subcmd/parse-options.h>\n#include <linux/kernel.h>\n#include <linux/time64.h>\n#include <errno.h>\n#include \"futex.h\"\n#include <perf/cpumap.h>\n\n#include <err.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/mman.h>\n\nstruct thread_data {\n\tpthread_t worker;\n\tunsigned int nwoken;\n\tstruct timeval runtime;\n};\n\nstatic unsigned int nwakes = 1;\n\n \nstatic u_int32_t futex = 0;\n\nstatic pthread_t *blocked_worker;\nstatic bool done = false;\nstatic struct mutex thread_lock;\nstatic struct cond thread_parent, thread_worker;\nstatic pthread_barrier_t barrier;\nstatic struct stats waketime_stats, wakeup_stats;\nstatic unsigned int threads_starting;\nstatic int futex_flag = 0;\n\nstatic struct bench_futex_parameters params;\n\nstatic const struct option options[] = {\n\tOPT_UINTEGER('t', \"threads\", &params.nthreads, \"Specify amount of threads\"),\n\tOPT_UINTEGER('w', \"nwakers\", &params.nwakes, \"Specify amount of waking threads\"),\n\tOPT_BOOLEAN( 's', \"silent\",  &params.silent, \"Silent mode: do not display data/details\"),\n\tOPT_BOOLEAN( 'S', \"shared\",  &params.fshared, \"Use shared futexes instead of private ones\"),\n\tOPT_BOOLEAN( 'm', \"mlockall\", &params.mlockall, \"Lock all current and future memory\"),\n\n\tOPT_END()\n};\n\nstatic const char * const bench_futex_wake_parallel_usage[] = {\n\t\"perf bench futex wake-parallel <options>\",\n\tNULL\n};\n\nstatic void *waking_workerfn(void *arg)\n{\n\tstruct thread_data *waker = (struct thread_data *) arg;\n\tstruct timeval start, end;\n\n\tpthread_barrier_wait(&barrier);\n\n\tgettimeofday(&start, NULL);\n\n\twaker->nwoken = futex_wake(&futex, nwakes, futex_flag);\n\tif (waker->nwoken != nwakes)\n\t\twarnx(\"couldn't wakeup all tasks (%d/%d)\",\n\t\t      waker->nwoken, nwakes);\n\n\tgettimeofday(&end, NULL);\n\ttimersub(&end, &start, &waker->runtime);\n\n\tpthread_exit(NULL);\n\treturn NULL;\n}\n\nstatic void wakeup_threads(struct thread_data *td)\n{\n\tunsigned int i;\n\tpthread_attr_t thread_attr;\n\n\tpthread_attr_init(&thread_attr);\n\tpthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_JOINABLE);\n\n\tpthread_barrier_init(&barrier, NULL, params.nwakes + 1);\n\n\t \n\tfor (i = 0; i < params.nwakes; i++) {\n\t\t \n\t\tif (pthread_create(&td[i].worker, &thread_attr,\n\t\t\t\t   waking_workerfn, (void *)&td[i]))\n\t\t\terr(EXIT_FAILURE, \"pthread_create\");\n\t}\n\n\tpthread_barrier_wait(&barrier);\n\n\tfor (i = 0; i < params.nwakes; i++)\n\t\tif (pthread_join(td[i].worker, NULL))\n\t\t\terr(EXIT_FAILURE, \"pthread_join\");\n\n\tpthread_barrier_destroy(&barrier);\n\tpthread_attr_destroy(&thread_attr);\n}\n\nstatic void *blocked_workerfn(void *arg __maybe_unused)\n{\n\tmutex_lock(&thread_lock);\n\tthreads_starting--;\n\tif (!threads_starting)\n\t\tcond_signal(&thread_parent);\n\tcond_wait(&thread_worker, &thread_lock);\n\tmutex_unlock(&thread_lock);\n\n\twhile (1) {  \n\t\tif (futex_wait(&futex, 0, NULL, futex_flag) != EINTR)\n\t\t\tbreak;\n\t}\n\n\tpthread_exit(NULL);\n\treturn NULL;\n}\n\nstatic void block_threads(pthread_t *w, struct perf_cpu_map *cpu)\n{\n\tcpu_set_t *cpuset;\n\tunsigned int i;\n\tint nrcpus = perf_cpu_map__nr(cpu);\n\tsize_t size;\n\n\tthreads_starting = params.nthreads;\n\n\tcpuset = CPU_ALLOC(nrcpus);\n\tBUG_ON(!cpuset);\n\tsize = CPU_ALLOC_SIZE(nrcpus);\n\n\t \n\tfor (i = 0; i < params.nthreads; i++) {\n\t\tpthread_attr_t thread_attr;\n\n\t\tpthread_attr_init(&thread_attr);\n\t\tCPU_ZERO_S(size, cpuset);\n\t\tCPU_SET_S(perf_cpu_map__cpu(cpu, i % perf_cpu_map__nr(cpu)).cpu, size, cpuset);\n\n\t\tif (pthread_attr_setaffinity_np(&thread_attr, size, cpuset)) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_attr_setaffinity_np\");\n\t\t}\n\n\t\tif (pthread_create(&w[i], &thread_attr, blocked_workerfn, NULL)) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_create\");\n\t\t}\n\t\tpthread_attr_destroy(&thread_attr);\n\t}\n\tCPU_FREE(cpuset);\n}\n\nstatic void print_run(struct thread_data *waking_worker, unsigned int run_num)\n{\n\tunsigned int i, wakeup_avg;\n\tdouble waketime_avg, waketime_stddev;\n\tstruct stats __waketime_stats, __wakeup_stats;\n\n\tinit_stats(&__wakeup_stats);\n\tinit_stats(&__waketime_stats);\n\n\tfor (i = 0; i < params.nwakes; i++) {\n\t\tupdate_stats(&__waketime_stats, waking_worker[i].runtime.tv_usec);\n\t\tupdate_stats(&__wakeup_stats, waking_worker[i].nwoken);\n\t}\n\n\twaketime_avg = avg_stats(&__waketime_stats);\n\twaketime_stddev = stddev_stats(&__waketime_stats);\n\twakeup_avg = avg_stats(&__wakeup_stats);\n\n\tprintf(\"[Run %d]: Avg per-thread latency (waking %d/%d threads) \"\n\t       \"in %.4f ms (+-%.2f%%)\\n\", run_num + 1, wakeup_avg,\n\t       params.nthreads, waketime_avg / USEC_PER_MSEC,\n\t       rel_stddev_stats(waketime_stddev, waketime_avg));\n}\n\nstatic void print_summary(void)\n{\n\tunsigned int wakeup_avg;\n\tdouble waketime_avg, waketime_stddev;\n\n\twaketime_avg = avg_stats(&waketime_stats);\n\twaketime_stddev = stddev_stats(&waketime_stats);\n\twakeup_avg = avg_stats(&wakeup_stats);\n\n\tprintf(\"Avg per-thread latency (waking %d/%d threads) in %.4f ms (+-%.2f%%)\\n\",\n\t       wakeup_avg,\n\t       params.nthreads,\n\t       waketime_avg / USEC_PER_MSEC,\n\t       rel_stddev_stats(waketime_stddev, waketime_avg));\n}\n\n\nstatic void do_run_stats(struct thread_data *waking_worker)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < params.nwakes; i++) {\n\t\tupdate_stats(&waketime_stats, waking_worker[i].runtime.tv_usec);\n\t\tupdate_stats(&wakeup_stats, waking_worker[i].nwoken);\n\t}\n\n}\n\nstatic void toggle_done(int sig __maybe_unused,\n\t\t\tsiginfo_t *info __maybe_unused,\n\t\t\tvoid *uc __maybe_unused)\n{\n\tdone = true;\n}\n\nint bench_futex_wake_parallel(int argc, const char **argv)\n{\n\tint ret = 0;\n\tunsigned int i, j;\n\tstruct sigaction act;\n\tstruct thread_data *waking_worker;\n\tstruct perf_cpu_map *cpu;\n\n\targc = parse_options(argc, argv, options,\n\t\t\t     bench_futex_wake_parallel_usage, 0);\n\tif (argc) {\n\t\tusage_with_options(bench_futex_wake_parallel_usage, options);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemset(&act, 0, sizeof(act));\n\tsigfillset(&act.sa_mask);\n\tact.sa_sigaction = toggle_done;\n\tsigaction(SIGINT, &act, NULL);\n\n\tif (params.mlockall) {\n\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE))\n\t\t\terr(EXIT_FAILURE, \"mlockall\");\n\t}\n\n\tcpu = perf_cpu_map__new(NULL);\n\tif (!cpu)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tif (!params.nthreads)\n\t\tparams.nthreads = perf_cpu_map__nr(cpu);\n\n\t \n\tif (params.nwakes > params.nthreads ||\n\t    !params.nwakes)\n\t\tparams.nwakes = params.nthreads;\n\n\tif (params.nthreads % params.nwakes)\n\t\terrx(EXIT_FAILURE, \"Must be perfectly divisible\");\n\t \n\tnwakes = params.nthreads/params.nwakes;\n\n\tblocked_worker = calloc(params.nthreads, sizeof(*blocked_worker));\n\tif (!blocked_worker)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tif (!params.fshared)\n\t\tfutex_flag = FUTEX_PRIVATE_FLAG;\n\n\tprintf(\"Run summary [PID %d]: blocking on %d threads (at [%s] \"\n\t       \"futex %p), %d threads waking up %d at a time.\\n\\n\",\n\t       getpid(), params.nthreads, params.fshared ? \"shared\":\"private\",\n\t       &futex, params.nwakes, nwakes);\n\n\tinit_stats(&wakeup_stats);\n\tinit_stats(&waketime_stats);\n\n\tmutex_init(&thread_lock);\n\tcond_init(&thread_parent);\n\tcond_init(&thread_worker);\n\n\tfor (j = 0; j < bench_repeat && !done; j++) {\n\t\twaking_worker = calloc(params.nwakes, sizeof(*waking_worker));\n\t\tif (!waking_worker)\n\t\t\terr(EXIT_FAILURE, \"calloc\");\n\n\t\t \n\t\tblock_threads(blocked_worker, cpu);\n\n\t\t \n\t\tmutex_lock(&thread_lock);\n\t\twhile (threads_starting)\n\t\t\tcond_wait(&thread_parent, &thread_lock);\n\t\tcond_broadcast(&thread_worker);\n\t\tmutex_unlock(&thread_lock);\n\n\t\tusleep(100000);\n\n\t\t \n\t\twakeup_threads(waking_worker);\n\n\t\tfor (i = 0; i < params.nthreads; i++) {\n\t\t\tret = pthread_join(blocked_worker[i], NULL);\n\t\t\tif (ret)\n\t\t\t\terr(EXIT_FAILURE, \"pthread_join\");\n\t\t}\n\n\t\tdo_run_stats(waking_worker);\n\t\tif (!params.silent)\n\t\t\tprint_run(waking_worker, j);\n\n\t\tfree(waking_worker);\n\t}\n\n\t \n\tcond_destroy(&thread_parent);\n\tcond_destroy(&thread_worker);\n\tmutex_destroy(&thread_lock);\n\n\tprint_summary();\n\n\tfree(blocked_worker);\n\tperf_cpu_map__put(cpu);\n\treturn ret;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}