{
  "module_name": "inject-buildid.c",
  "hash_id": "d91efe4341f0ce8692a23f0163cd2ccfe02961c6e412d593de33351684f622f0",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/inject-buildid.c",
  "human_readable_source": "\n#include <stdlib.h>\n#include <stddef.h>\n#include <ftw.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <linux/kernel.h>\n#include <linux/time64.h>\n#include <linux/list.h>\n#include <linux/err.h>\n#include <linux/zalloc.h>\n#include <internal/lib.h>\n#include <subcmd/parse-options.h>\n\n#include \"bench.h\"\n#include \"util/data.h\"\n#include \"util/stat.h\"\n#include \"util/debug.h\"\n#include \"util/symbol.h\"\n#include \"util/session.h\"\n#include \"util/build-id.h\"\n#include \"util/sample.h\"\n#include \"util/synthetic-events.h\"\n\n#define MMAP_DEV_MAJOR  8\n#define DSO_MMAP_RATIO  4\n\nstatic unsigned int iterations = 100;\nstatic unsigned int nr_mmaps   = 100;\nstatic unsigned int nr_samples = 100;   \n\nstatic u64 bench_sample_type;\nstatic u16 bench_id_hdr_size;\n\nstruct bench_data {\n\tint\t\t\tpid;\n\tint\t\t\tinput_pipe[2];\n\tint\t\t\toutput_pipe[2];\n\tpthread_t\t\tth;\n};\n\nstruct bench_dso {\n\tstruct list_head\tlist;\n\tchar\t\t\t*name;\n\tint\t\t\tino;\n};\n\nstatic int nr_dsos;\nstatic struct bench_dso *dsos;\n\nextern int cmd_inject(int argc, const char *argv[]);\n\nstatic const struct option options[] = {\n\tOPT_UINTEGER('i', \"iterations\", &iterations,\n\t\t     \"Number of iterations used to compute average (default: 100)\"),\n\tOPT_UINTEGER('m', \"nr-mmaps\", &nr_mmaps,\n\t\t     \"Number of mmap events for each iteration (default: 100)\"),\n\tOPT_UINTEGER('n', \"nr-samples\", &nr_samples,\n\t\t     \"Number of sample events per mmap event (default: 100)\"),\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t \"be more verbose (show iteration count, DSO name, etc)\"),\n\tOPT_END()\n};\n\nstatic const char *const bench_usage[] = {\n\t\"perf bench internals inject-build-id <options>\",\n\tNULL\n};\n\n \nstatic int add_dso(const char *fpath, const struct stat *sb __maybe_unused,\n\t\t   int typeflag, struct FTW *ftwbuf __maybe_unused)\n{\n\tstruct bench_dso *dso = &dsos[nr_dsos];\n\tstruct build_id bid;\n\n\tif (typeflag == FTW_D || typeflag == FTW_SL)\n\t\treturn 0;\n\n\tif (filename__read_build_id(fpath, &bid) < 0)\n\t\treturn 0;\n\n\tdso->name = realpath(fpath, NULL);\n\tif (dso->name == NULL)\n\t\treturn -1;\n\n\tdso->ino = nr_dsos++;\n\tpr_debug2(\"  Adding DSO: %s\\n\", fpath);\n\n\t \n\tif ((unsigned int)nr_dsos == DSO_MMAP_RATIO * nr_mmaps)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void collect_dso(void)\n{\n\tdsos = calloc(nr_mmaps * DSO_MMAP_RATIO, sizeof(*dsos));\n\tif (dsos == NULL) {\n\t\tprintf(\"  Memory allocation failed\\n\");\n\t\texit(1);\n\t}\n\n\tif (nftw(\"/usr/lib/\", add_dso, 10, FTW_PHYS) < 0)\n\t\treturn;\n\n\tpr_debug(\"  Collected %d DSOs\\n\", nr_dsos);\n}\n\nstatic void release_dso(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_dsos; i++) {\n\t\tstruct bench_dso *dso = &dsos[i];\n\n\t\tzfree(&dso->name);\n\t}\n\tfree(dsos);\n}\n\n \nstatic u64 dso_map_addr(struct bench_dso *dso)\n{\n\treturn 0x400000ULL + dso->ino * 8192ULL;\n}\n\nstatic ssize_t synthesize_attr(struct bench_data *data)\n{\n\tunion perf_event event;\n\n\tmemset(&event, 0, sizeof(event.attr) + sizeof(u64));\n\n\tevent.header.type = PERF_RECORD_HEADER_ATTR;\n\tevent.header.size = sizeof(event.attr) + sizeof(u64);\n\n\tevent.attr.attr.type = PERF_TYPE_SOFTWARE;\n\tevent.attr.attr.config = PERF_COUNT_SW_TASK_CLOCK;\n\tevent.attr.attr.exclude_kernel = 1;\n\tevent.attr.attr.sample_id_all = 1;\n\tevent.attr.attr.sample_type = bench_sample_type;\n\n\treturn writen(data->input_pipe[1], &event, event.header.size);\n}\n\nstatic ssize_t synthesize_fork(struct bench_data *data)\n{\n\tunion perf_event event;\n\n\tmemset(&event, 0, sizeof(event.fork) + bench_id_hdr_size);\n\n\tevent.header.type = PERF_RECORD_FORK;\n\tevent.header.misc = PERF_RECORD_MISC_FORK_EXEC;\n\tevent.header.size = sizeof(event.fork) + bench_id_hdr_size;\n\n\tevent.fork.ppid = 1;\n\tevent.fork.ptid = 1;\n\tevent.fork.pid = data->pid;\n\tevent.fork.tid = data->pid;\n\n\treturn writen(data->input_pipe[1], &event, event.header.size);\n}\n\nstatic ssize_t synthesize_mmap(struct bench_data *data, struct bench_dso *dso, u64 timestamp)\n{\n\tunion perf_event event;\n\tsize_t len = offsetof(struct perf_record_mmap2, filename);\n\tu64 *id_hdr_ptr = (void *)&event;\n\tint ts_idx;\n\n\tlen += roundup(strlen(dso->name) + 1, 8) + bench_id_hdr_size;\n\n\tmemset(&event, 0, min(len, sizeof(event.mmap2)));\n\n\tevent.header.type = PERF_RECORD_MMAP2;\n\tevent.header.misc = PERF_RECORD_MISC_USER;\n\tevent.header.size = len;\n\n\tevent.mmap2.pid = data->pid;\n\tevent.mmap2.tid = data->pid;\n\tevent.mmap2.maj = MMAP_DEV_MAJOR;\n\tevent.mmap2.ino = dso->ino;\n\n\tstrcpy(event.mmap2.filename, dso->name);\n\n\tevent.mmap2.start = dso_map_addr(dso);\n\tevent.mmap2.len = 4096;\n\tevent.mmap2.prot = PROT_EXEC;\n\n\tif (len > sizeof(event.mmap2)) {\n\t\t \n\t\tif (writen(data->input_pipe[1], &event, len - bench_id_hdr_size) < 0)\n\t\t\treturn -1;\n\t\t \n\t\tmemset(id_hdr_ptr, 0, bench_id_hdr_size);\n\t\t \n\t\tts_idx = (bench_id_hdr_size / sizeof(u64)) - 2;\n\t\tid_hdr_ptr[ts_idx] = timestamp;\n\t\tif (writen(data->input_pipe[1], id_hdr_ptr, bench_id_hdr_size) < 0)\n\t\t\treturn -1;\n\n\t\treturn len;\n\t}\n\n\tts_idx = (len / sizeof(u64)) - 2;\n\tid_hdr_ptr[ts_idx] = timestamp;\n\treturn writen(data->input_pipe[1], &event, len);\n}\n\nstatic ssize_t synthesize_sample(struct bench_data *data, struct bench_dso *dso, u64 timestamp)\n{\n\tunion perf_event event;\n\tstruct perf_sample sample = {\n\t\t.tid = data->pid,\n\t\t.pid = data->pid,\n\t\t.ip = dso_map_addr(dso),\n\t\t.time = timestamp,\n\t};\n\n\tevent.header.type = PERF_RECORD_SAMPLE;\n\tevent.header.misc = PERF_RECORD_MISC_USER;\n\tevent.header.size = perf_event__sample_event_size(&sample, bench_sample_type, 0);\n\n\tperf_event__synthesize_sample(&event, bench_sample_type, 0, &sample);\n\n\treturn writen(data->input_pipe[1], &event, event.header.size);\n}\n\nstatic ssize_t synthesize_flush(struct bench_data *data)\n{\n\tstruct perf_event_header header = {\n\t\t.size = sizeof(header),\n\t\t.type = PERF_RECORD_FINISHED_ROUND,\n\t};\n\n\treturn writen(data->input_pipe[1], &header, header.size);\n}\n\nstatic void *data_reader(void *arg)\n{\n\tstruct bench_data *data = arg;\n\tchar buf[8192];\n\tint flag;\n\tint n;\n\n\tflag = fcntl(data->output_pipe[0], F_GETFL);\n\tfcntl(data->output_pipe[0], F_SETFL, flag | O_NONBLOCK);\n\n\t \n\twhile (true) {\n\t\tn = read(data->output_pipe[0], buf, sizeof(buf));\n\t\tif (n > 0)\n\t\t\tcontinue;\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tif (errno != EINTR && errno != EAGAIN)\n\t\t\tbreak;\n\n\t\tusleep(100);\n\t}\n\n\tclose(data->output_pipe[0]);\n\treturn NULL;\n}\n\nstatic int setup_injection(struct bench_data *data, bool build_id_all)\n{\n\tint ready_pipe[2];\n\tint dev_null_fd;\n\tchar buf;\n\n\tif (pipe(ready_pipe) < 0)\n\t\treturn -1;\n\n\tif (pipe(data->input_pipe) < 0)\n\t\treturn -1;\n\n\tif (pipe(data->output_pipe) < 0)\n\t\treturn -1;\n\n\tdata->pid = fork();\n\tif (data->pid < 0)\n\t\treturn -1;\n\n\tif (data->pid == 0) {\n\t\tconst char **inject_argv;\n\t\tint inject_argc = 2;\n\n\t\tclose(data->input_pipe[1]);\n\t\tclose(data->output_pipe[0]);\n\t\tclose(ready_pipe[0]);\n\n\t\tdup2(data->input_pipe[0], STDIN_FILENO);\n\t\tclose(data->input_pipe[0]);\n\t\tdup2(data->output_pipe[1], STDOUT_FILENO);\n\t\tclose(data->output_pipe[1]);\n\n\t\tdev_null_fd = open(\"/dev/null\", O_WRONLY);\n\t\tif (dev_null_fd < 0)\n\t\t\texit(1);\n\n\t\tdup2(dev_null_fd, STDERR_FILENO);\n\n\t\tif (build_id_all)\n\t\t\tinject_argc++;\n\n\t\tinject_argv = calloc(inject_argc + 1, sizeof(*inject_argv));\n\t\tif (inject_argv == NULL)\n\t\t\texit(1);\n\n\t\tinject_argv[0] = strdup(\"inject\");\n\t\tinject_argv[1] = strdup(\"-b\");\n\t\tif (build_id_all)\n\t\t\tinject_argv[2] = strdup(\"--buildid-all\");\n\n\t\t \n\t\tclose(ready_pipe[1]);\n\n\t\tcmd_inject(inject_argc, inject_argv);\n\n\t\texit(0);\n\t}\n\n\tpthread_create(&data->th, NULL, data_reader, data);\n\n\tclose(ready_pipe[1]);\n\tclose(data->input_pipe[0]);\n\tclose(data->output_pipe[1]);\n\n\t \n\tif (read(ready_pipe[0], &buf, 1) < 0)\n\t\treturn -1;\n\tclose(ready_pipe[0]);\n\n\treturn 0;\n}\n\nstatic int inject_build_id(struct bench_data *data, u64 *max_rss)\n{\n\tint status;\n\tunsigned int i, k;\n\tstruct rusage rusage;\n\n\t \n\tif (perf_header__write_pipe(data->input_pipe[1]) < 0)\n\t\treturn -1;\n\n\tif (synthesize_attr(data) < 0)\n\t\treturn -1;\n\n\tif (synthesize_fork(data) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < nr_mmaps; i++) {\n\t\tint idx = rand() % (nr_dsos - 1);\n\t\tstruct bench_dso *dso = &dsos[idx];\n\t\tu64 timestamp = rand() % 1000000;\n\n\t\tpr_debug2(\"   [%d] injecting: %s\\n\", i+1, dso->name);\n\t\tif (synthesize_mmap(data, dso, timestamp) < 0)\n\t\t\treturn -1;\n\n\t\tfor (k = 0; k < nr_samples; k++) {\n\t\t\tif (synthesize_sample(data, dso, timestamp + k * 1000) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif ((i + 1) % 10 == 0) {\n\t\t\tif (synthesize_flush(data) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tclose(data->input_pipe[1]);\n\n\twait4(data->pid, &status, 0, &rusage);\n\t*max_rss = rusage.ru_maxrss;\n\n\tpr_debug(\"   Child %d exited with %d\\n\", data->pid, status);\n\n\treturn 0;\n}\n\nstatic void do_inject_loop(struct bench_data *data, bool build_id_all)\n{\n\tunsigned int i;\n\tstruct stats time_stats, mem_stats;\n\tdouble time_average, time_stddev;\n\tdouble mem_average, mem_stddev;\n\n\tinit_stats(&time_stats);\n\tinit_stats(&mem_stats);\n\n\tpr_debug(\"  Build-id%s injection benchmark\\n\", build_id_all ? \"-all\" : \"\");\n\n\tfor (i = 0; i < iterations; i++) {\n\t\tstruct timeval start, end, diff;\n\t\tu64 runtime_us, max_rss;\n\n\t\tpr_debug(\"  Iteration #%d\\n\", i+1);\n\n\t\tif (setup_injection(data, build_id_all) < 0) {\n\t\t\tprintf(\"  Build-id injection setup failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tgettimeofday(&start, NULL);\n\t\tif (inject_build_id(data, &max_rss) < 0) {\n\t\t\tprintf(\"  Build-id injection failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tgettimeofday(&end, NULL);\n\t\ttimersub(&end, &start, &diff);\n\t\truntime_us = diff.tv_sec * USEC_PER_SEC + diff.tv_usec;\n\t\tupdate_stats(&time_stats, runtime_us);\n\t\tupdate_stats(&mem_stats, max_rss);\n\n\t\tpthread_join(data->th, NULL);\n\t}\n\n\ttime_average = avg_stats(&time_stats) / USEC_PER_MSEC;\n\ttime_stddev = stddev_stats(&time_stats) / USEC_PER_MSEC;\n\tprintf(\"  Average build-id%s injection took: %.3f msec (+- %.3f msec)\\n\",\n\t       build_id_all ? \"-all\" : \"\", time_average, time_stddev);\n\n\t \n\ttime_average = avg_stats(&time_stats) / (nr_mmaps * (nr_samples + 2));\n\ttime_stddev = stddev_stats(&time_stats) / (nr_mmaps * (nr_samples + 2));\n\tprintf(\"  Average time per event: %.3f usec (+- %.3f usec)\\n\",\n\t\ttime_average, time_stddev);\n\n\tmem_average = avg_stats(&mem_stats);\n\tmem_stddev = stddev_stats(&mem_stats);\n\tprintf(\"  Average memory usage: %.0f KB (+- %.0f KB)\\n\",\n\t\tmem_average, mem_stddev);\n}\n\nstatic int do_inject_loops(struct bench_data *data)\n{\n\n\tsrand(time(NULL));\n\tsymbol__init(NULL);\n\n\tbench_sample_type  = PERF_SAMPLE_IDENTIFIER | PERF_SAMPLE_IP;\n\tbench_sample_type |= PERF_SAMPLE_TID | PERF_SAMPLE_TIME;\n\tbench_id_hdr_size  = 32;\n\n\tcollect_dso();\n\tif (nr_dsos == 0) {\n\t\tprintf(\"  Cannot collect DSOs for injection\\n\");\n\t\treturn -1;\n\t}\n\n\tdo_inject_loop(data, false);\n\tdo_inject_loop(data, true);\n\n\trelease_dso();\n\treturn 0;\n}\n\nint bench_inject_build_id(int argc, const char **argv)\n{\n\tstruct bench_data data;\n\n\targc = parse_options(argc, argv, options, bench_usage, 0);\n\tif (argc) {\n\t\tusage_with_options(bench_usage, options);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn do_inject_loops(&data);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}