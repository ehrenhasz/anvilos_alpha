{
  "module_name": "breakpoint.c",
  "hash_id": "ed73deb494290d3cfcf256e28dcb68d3326acd369a198386fc811850e8c7c2a5",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/breakpoint.c",
  "human_readable_source": "\n\n#include <subcmd/parse-options.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/perf_event.h>\n#include <linux/time64.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <pthread.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include \"bench.h\"\n#include \"futex.h\"\n\nstruct {\n\tunsigned int nbreakpoints;\n\tunsigned int nparallel;\n\tunsigned int nthreads;\n} thread_params = {\n\t.nbreakpoints = 1,\n\t.nparallel = 1,\n\t.nthreads = 1,\n};\n\nstatic const struct option thread_options[] = {\n\tOPT_UINTEGER('b', \"breakpoints\", &thread_params.nbreakpoints,\n\t\t\"Specify amount of breakpoints\"),\n\tOPT_UINTEGER('p', \"parallelism\", &thread_params.nparallel, \"Specify amount of parallelism\"),\n\tOPT_UINTEGER('t', \"threads\", &thread_params.nthreads, \"Specify amount of threads\"),\n\tOPT_END()\n};\n\nstatic const char * const thread_usage[] = {\n\t\"perf bench breakpoint thread <options>\",\n\tNULL\n};\n\nstruct breakpoint {\n\tint fd;\n\tchar watched;\n};\n\nstatic int breakpoint_setup(void *addr)\n{\n\tstruct perf_event_attr attr = { .size = 0, };\n\tint fd;\n\n\tattr.type = PERF_TYPE_BREAKPOINT;\n\tattr.size = sizeof(attr);\n\tattr.inherit = 1;\n\tattr.exclude_kernel = 1;\n\tattr.exclude_hv = 1;\n\tattr.bp_addr = (unsigned long)addr;\n\tattr.bp_type = HW_BREAKPOINT_RW;\n\tattr.bp_len = HW_BREAKPOINT_LEN_1;\n\tfd = syscall(SYS_perf_event_open, &attr, 0, -1, -1, 0);\n\n\tif (fd < 0)\n\t\tfd = -errno;\n\n\treturn fd;\n}\n\nstatic void *passive_thread(void *arg)\n{\n\tunsigned int *done = (unsigned int *)arg;\n\n\twhile (!__atomic_load_n(done, __ATOMIC_RELAXED))\n\t\tfutex_wait(done, 0, NULL, 0);\n\treturn NULL;\n}\n\nstatic void *active_thread(void *arg)\n{\n\tunsigned int *done = (unsigned int *)arg;\n\n\twhile (!__atomic_load_n(done, __ATOMIC_RELAXED));\n\treturn NULL;\n}\n\nstatic void *breakpoint_thread(void *arg)\n{\n\tunsigned int i, done;\n\tint *repeat = (int *)arg;\n\tpthread_t *threads;\n\n\tthreads = calloc(thread_params.nthreads, sizeof(threads[0]));\n\tif (!threads)\n\t\texit((perror(\"calloc\"), EXIT_FAILURE));\n\n\twhile (__atomic_fetch_sub(repeat, 1, __ATOMIC_RELAXED) > 0) {\n\t\tdone = 0;\n\t\tfor (i = 0; i < thread_params.nthreads; i++) {\n\t\t\tif (pthread_create(&threads[i], NULL, passive_thread, &done))\n\t\t\t\texit((perror(\"pthread_create\"), EXIT_FAILURE));\n\t\t}\n\t\t__atomic_store_n(&done, 1, __ATOMIC_RELAXED);\n\t\tfutex_wake(&done, thread_params.nthreads, 0);\n\t\tfor (i = 0; i < thread_params.nthreads; i++)\n\t\t\tpthread_join(threads[i], NULL);\n\t}\n\tfree(threads);\n\treturn NULL;\n}\n\n\n\nint bench_breakpoint_thread(int argc, const char **argv)\n{\n\tunsigned int i, result_usec;\n\tint repeat = bench_repeat;\n\tstruct breakpoint *breakpoints;\n\tpthread_t *parallel;\n\tstruct timeval start, stop, diff;\n\n\tif (parse_options(argc, argv, thread_options, thread_usage, 0)) {\n\t\tusage_with_options(thread_usage, thread_options);\n\t\texit(EXIT_FAILURE);\n\t}\n\tbreakpoints = calloc(thread_params.nbreakpoints, sizeof(breakpoints[0]));\n\tparallel = calloc(thread_params.nparallel, sizeof(parallel[0]));\n\tif (!breakpoints || !parallel)\n\t\texit((perror(\"calloc\"), EXIT_FAILURE));\n\n\tfor (i = 0; i < thread_params.nbreakpoints; i++) {\n\t\tbreakpoints[i].fd = breakpoint_setup(&breakpoints[i].watched);\n\n\t\tif (breakpoints[i].fd < 0) {\n\t\t\tif (breakpoints[i].fd == -ENODEV) {\n\t\t\t\tprintf(\"Skipping perf bench breakpoint thread: No hardware support\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\texit((perror(\"perf_event_open\"), EXIT_FAILURE));\n\t\t}\n\t}\n\tgettimeofday(&start, NULL);\n\tfor (i = 0; i < thread_params.nparallel; i++) {\n\t\tif (pthread_create(&parallel[i], NULL, breakpoint_thread, &repeat))\n\t\t\texit((perror(\"pthread_create\"), EXIT_FAILURE));\n\t}\n\tfor (i = 0; i < thread_params.nparallel; i++)\n\t\tpthread_join(parallel[i], NULL);\n\tgettimeofday(&stop, NULL);\n\ttimersub(&stop, &start, &diff);\n\tfor (i = 0; i < thread_params.nbreakpoints; i++)\n\t\tclose(breakpoints[i].fd);\n\tfree(parallel);\n\tfree(breakpoints);\n\tswitch (bench_format) {\n\tcase BENCH_FORMAT_DEFAULT:\n\t\tprintf(\"# Created/joined %d threads with %d breakpoints and %d parallelism\\n\",\n\t\t\tbench_repeat, thread_params.nbreakpoints, thread_params.nparallel);\n\t\tprintf(\" %14s: %lu.%03lu [sec]\\n\\n\", \"Total time\",\n\t\t\t(long)diff.tv_sec, (long)(diff.tv_usec / USEC_PER_MSEC));\n\t\tresult_usec = diff.tv_sec * USEC_PER_SEC + diff.tv_usec;\n\t\tprintf(\" %14lf usecs/op\\n\",\n\t\t\t(double)result_usec / bench_repeat / thread_params.nthreads);\n\t\tprintf(\" %14lf usecs/op/cpu\\n\",\n\t\t\t(double)result_usec / bench_repeat /\n\t\t\tthread_params.nthreads * thread_params.nparallel);\n\t\tbreak;\n\tcase BENCH_FORMAT_SIMPLE:\n\t\tprintf(\"%lu.%03lu\\n\", (long)diff.tv_sec, (long)(diff.tv_usec / USEC_PER_MSEC));\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"Unknown format: %d\\n\", bench_format);\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn 0;\n}\n\nstruct {\n\tunsigned int npassive;\n\tunsigned int nactive;\n} enable_params = {\n\t.nactive = 0,\n\t.npassive = 0,\n};\n\nstatic const struct option enable_options[] = {\n\tOPT_UINTEGER('p', \"passive\", &enable_params.npassive, \"Specify amount of passive threads\"),\n\tOPT_UINTEGER('a', \"active\", &enable_params.nactive, \"Specify amount of active threads\"),\n\tOPT_END()\n};\n\nstatic const char * const enable_usage[] = {\n\t\"perf bench breakpoint enable <options>\",\n\tNULL\n};\n\n\n\n\nint bench_breakpoint_enable(int argc, const char **argv)\n{\n\tunsigned int i, nthreads, result_usec, done = 0;\n\tchar watched;\n\tint fd;\n\tpthread_t *threads;\n\tstruct timeval start, stop, diff;\n\n\tif (parse_options(argc, argv, enable_options, enable_usage, 0)) {\n\t\tusage_with_options(enable_usage, enable_options);\n\t\texit(EXIT_FAILURE);\n\t}\n\tfd = breakpoint_setup(&watched);\n\n\tif (fd < 0) {\n\t\tif (fd == -ENODEV) {\n\t\t\tprintf(\"Skipping perf bench breakpoint enable: No hardware support\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\texit((perror(\"perf_event_open\"), EXIT_FAILURE));\n\t}\n\tnthreads = enable_params.npassive + enable_params.nactive;\n\tthreads = calloc(nthreads, sizeof(threads[0]));\n\tif (!threads)\n\t\texit((perror(\"calloc\"), EXIT_FAILURE));\n\n\tfor (i = 0; i < nthreads; i++) {\n\t\tif (pthread_create(&threads[i], NULL,\n\t\t\ti < enable_params.npassive ? passive_thread : active_thread, &done))\n\t\t\texit((perror(\"pthread_create\"), EXIT_FAILURE));\n\t}\n\tusleep(10000);  \n\tgettimeofday(&start, NULL);\n\tfor (i = 0; i < bench_repeat; i++) {\n\t\tif (ioctl(fd, PERF_EVENT_IOC_DISABLE, 0))\n\t\t\texit((perror(\"ioctl(PERF_EVENT_IOC_DISABLE)\"), EXIT_FAILURE));\n\t\tif (ioctl(fd, PERF_EVENT_IOC_ENABLE, 0))\n\t\t\texit((perror(\"ioctl(PERF_EVENT_IOC_ENABLE)\"), EXIT_FAILURE));\n\t}\n\tgettimeofday(&stop, NULL);\n\ttimersub(&stop, &start, &diff);\n\t__atomic_store_n(&done, 1, __ATOMIC_RELAXED);\n\tfutex_wake(&done, enable_params.npassive, 0);\n\tfor (i = 0; i < nthreads; i++)\n\t\tpthread_join(threads[i], NULL);\n\tfree(threads);\n\tclose(fd);\n\tswitch (bench_format) {\n\tcase BENCH_FORMAT_DEFAULT:\n\t\tprintf(\"# Enabled/disabled breakpoint %d time with %d passive and %d active threads\\n\",\n\t\t\tbench_repeat, enable_params.npassive, enable_params.nactive);\n\t\tprintf(\" %14s: %lu.%03lu [sec]\\n\\n\", \"Total time\",\n\t\t\t(long)diff.tv_sec, (long)(diff.tv_usec / USEC_PER_MSEC));\n\t\tresult_usec = diff.tv_sec * USEC_PER_SEC + diff.tv_usec;\n\t\tprintf(\" %14lf usecs/op\\n\", (double)result_usec / bench_repeat);\n\t\tbreak;\n\tcase BENCH_FORMAT_SIMPLE:\n\t\tprintf(\"%lu.%03lu\\n\", (long)diff.tv_sec, (long)(diff.tv_usec / USEC_PER_MSEC));\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"Unknown format: %d\\n\", bench_format);\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}