{
  "module_name": "sched-pipe.c",
  "hash_id": "5ce500b48b6186b347ae6b2d16642cc86668d351d1ef0fc6f6f39586d1bc1b22",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/sched-pipe.c",
  "human_readable_source": "\n \n#include <subcmd/parse-options.h>\n#include \"bench.h\"\n\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <string.h>\n#include <errno.h>\n#include <assert.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <linux/time64.h>\n\n#include <pthread.h>\n\nstruct thread_data {\n\tint\t\t\tnr;\n\tint\t\t\tpipe_read;\n\tint\t\t\tpipe_write;\n\tpthread_t\t\tpthread;\n};\n\n#define LOOPS_DEFAULT 1000000\nstatic\tint\t\t\tloops = LOOPS_DEFAULT;\n\n \nstatic bool\t\t\tthreaded;\n\nstatic const struct option options[] = {\n\tOPT_INTEGER('l', \"loop\",\t&loops,\t\t\"Specify number of loops\"),\n\tOPT_BOOLEAN('T', \"threaded\",\t&threaded,\t\"Specify threads/process based task setup\"),\n\tOPT_END()\n};\n\nstatic const char * const bench_sched_pipe_usage[] = {\n\t\"perf bench sched pipe <options>\",\n\tNULL\n};\n\nstatic void *worker_thread(void *__tdata)\n{\n\tstruct thread_data *td = __tdata;\n\tint m = 0, i;\n\tint ret;\n\n\tfor (i = 0; i < loops; i++) {\n\t\tif (!td->nr) {\n\t\t\tret = read(td->pipe_read, &m, sizeof(int));\n\t\t\tBUG_ON(ret != sizeof(int));\n\t\t\tret = write(td->pipe_write, &m, sizeof(int));\n\t\t\tBUG_ON(ret != sizeof(int));\n\t\t} else {\n\t\t\tret = write(td->pipe_write, &m, sizeof(int));\n\t\t\tBUG_ON(ret != sizeof(int));\n\t\t\tret = read(td->pipe_read, &m, sizeof(int));\n\t\t\tBUG_ON(ret != sizeof(int));\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint bench_sched_pipe(int argc, const char **argv)\n{\n\tstruct thread_data threads[2], *td;\n\tint pipe_1[2], pipe_2[2];\n\tstruct timeval start, stop, diff;\n\tunsigned long long result_usec = 0;\n\tint nr_threads = 2;\n\tint t;\n\n\t \n\tint __maybe_unused ret, wait_stat;\n\tpid_t pid, retpid __maybe_unused;\n\n\targc = parse_options(argc, argv, options, bench_sched_pipe_usage, 0);\n\n\tBUG_ON(pipe(pipe_1));\n\tBUG_ON(pipe(pipe_2));\n\n\tgettimeofday(&start, NULL);\n\n\tfor (t = 0; t < nr_threads; t++) {\n\t\ttd = threads + t;\n\n\t\ttd->nr = t;\n\n\t\tif (t == 0) {\n\t\t\ttd->pipe_read = pipe_1[0];\n\t\t\ttd->pipe_write = pipe_2[1];\n\t\t} else {\n\t\t\ttd->pipe_write = pipe_1[1];\n\t\t\ttd->pipe_read = pipe_2[0];\n\t\t}\n\t}\n\n\n\tif (threaded) {\n\n\t\tfor (t = 0; t < nr_threads; t++) {\n\t\t\ttd = threads + t;\n\n\t\t\tret = pthread_create(&td->pthread, NULL, worker_thread, td);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tfor (t = 0; t < nr_threads; t++) {\n\t\t\ttd = threads + t;\n\n\t\t\tret = pthread_join(td->pthread, NULL);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t} else {\n\t\tpid = fork();\n\t\tassert(pid >= 0);\n\n\t\tif (!pid) {\n\t\t\tworker_thread(threads + 0);\n\t\t\texit(0);\n\t\t} else {\n\t\t\tworker_thread(threads + 1);\n\t\t}\n\n\t\tretpid = waitpid(pid, &wait_stat, 0);\n\t\tassert((retpid == pid) && WIFEXITED(wait_stat));\n\t}\n\n\tgettimeofday(&stop, NULL);\n\ttimersub(&stop, &start, &diff);\n\n\tswitch (bench_format) {\n\tcase BENCH_FORMAT_DEFAULT:\n\t\tprintf(\"# Executed %d pipe operations between two %s\\n\\n\",\n\t\t\tloops, threaded ? \"threads\" : \"processes\");\n\n\t\tresult_usec = diff.tv_sec * USEC_PER_SEC;\n\t\tresult_usec += diff.tv_usec;\n\n\t\tprintf(\" %14s: %lu.%03lu [sec]\\n\\n\", \"Total time\",\n\t\t       (unsigned long) diff.tv_sec,\n\t\t       (unsigned long) (diff.tv_usec / USEC_PER_MSEC));\n\n\t\tprintf(\" %14lf usecs/op\\n\",\n\t\t       (double)result_usec / (double)loops);\n\t\tprintf(\" %14d ops/sec\\n\",\n\t\t       (int)((double)loops /\n\t\t\t     ((double)result_usec / (double)USEC_PER_SEC)));\n\t\tbreak;\n\n\tcase BENCH_FORMAT_SIMPLE:\n\t\tprintf(\"%lu.%03lu\\n\",\n\t\t       (unsigned long) diff.tv_sec,\n\t\t       (unsigned long) (diff.tv_usec / USEC_PER_MSEC));\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tfprintf(stderr, \"Unknown format:%d\\n\", bench_format);\n\t\texit(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}