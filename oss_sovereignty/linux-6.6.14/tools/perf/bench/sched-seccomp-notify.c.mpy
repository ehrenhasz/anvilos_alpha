{
  "module_name": "sched-seccomp-notify.c",
  "hash_id": "fa65dbf65d0be19c0d226242524badf3f9fbbc12fb54958981787742e2683149",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/sched-seccomp-notify.c",
  "human_readable_source": "\n#include <subcmd/parse-options.h>\n#include \"bench.h\"\n\n#include <uapi/linux/filter.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <linux/unistd.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <linux/time64.h>\n#include <uapi/linux/seccomp.h>\n#include <sys/prctl.h>\n\n#include <unistd.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <string.h>\n#include <errno.h>\n#include <err.h>\n#include <inttypes.h>\n\n#define LOOPS_DEFAULT 1000000UL\nstatic uint64_t loops = LOOPS_DEFAULT;\nstatic bool sync_mode;\n\nstatic const struct option options[] = {\n\tOPT_U64('l', \"loop\",\t&loops,\t\t\"Specify number of loops\"),\n\tOPT_BOOLEAN('s', \"sync-mode\", &sync_mode,\n\t\t    \"Enable the synchronious mode for seccomp notifications\"),\n\tOPT_END()\n};\n\nstatic const char * const bench_seccomp_usage[] = {\n\t\"perf bench sched secccomp-notify <options>\",\n\tNULL\n};\n\nstatic int seccomp(unsigned int op, unsigned int flags, void *args)\n{\n\treturn syscall(__NR_seccomp, op, flags, args);\n}\n\nstatic int user_notif_syscall(int nr, unsigned int flags)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD|BPF_W|BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, nr, 0, 1),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_USER_NOTIF),\n\t\tBPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\n\treturn seccomp(SECCOMP_SET_MODE_FILTER, flags, &prog);\n}\n\n#define USER_NOTIF_MAGIC INT_MAX\nstatic void user_notification_sync_loop(int listener)\n{\n\tstruct seccomp_notif_resp resp;\n\tstruct seccomp_notif req;\n\tuint64_t nr;\n\n\tfor (nr = 0; nr < loops; nr++) {\n\t\tmemset(&req, 0, sizeof(req));\n\t\tif (ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req))\n\t\t\terr(EXIT_FAILURE, \"SECCOMP_IOCTL_NOTIF_RECV failed\");\n\n\t\tif (req.data.nr != __NR_gettid)\n\t\t\terrx(EXIT_FAILURE, \"unexpected syscall: %d\", req.data.nr);\n\n\t\tresp.id = req.id;\n\t\tresp.error = 0;\n\t\tresp.val = USER_NOTIF_MAGIC;\n\t\tresp.flags = 0;\n\t\tif (ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp))\n\t\t\terr(EXIT_FAILURE, \"SECCOMP_IOCTL_NOTIF_SEND failed\");\n\t}\n}\n\n#ifndef SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP\n#define SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP (1UL << 0)\n#define SECCOMP_IOCTL_NOTIF_SET_FLAGS  SECCOMP_IOW(4, __u64)\n#endif\nint bench_sched_seccomp_notify(int argc, const char **argv)\n{\n\tstruct timeval start, stop, diff;\n\tunsigned long long result_usec = 0;\n\tint status, listener;\n\tpid_t pid;\n\tlong ret;\n\n\targc = parse_options(argc, argv, options, bench_seccomp_usage, 0);\n\n\tgettimeofday(&start, NULL);\n\n\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\tlistener = user_notif_syscall(__NR_gettid,\n\t\t\t\t      SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\tif (listener < 0)\n\t\terr(EXIT_FAILURE, \"can't create a notification descriptor\");\n\n\tpid = fork();\n\tif (pid < 0)\n\t\terr(EXIT_FAILURE, \"fork\");\n\tif (pid == 0) {\n\t\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0))\n\t\t\terr(EXIT_FAILURE, \"can't set the parent death signal\");\n\t\twhile (1) {\n\t\t\tret = syscall(__NR_gettid);\n\t\t\tif (ret == USER_NOTIF_MAGIC)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\t_exit(1);\n\t}\n\n\tif (sync_mode) {\n\t\tif (ioctl(listener, SECCOMP_IOCTL_NOTIF_SET_FLAGS,\n\t\t\t     SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP, 0))\n\t\t\terr(EXIT_FAILURE,\n\t\t\t    \"can't set SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP\");\n\t}\n\tuser_notification_sync_loop(listener);\n\n\tkill(pid, SIGKILL);\n\tif (waitpid(pid, &status, 0) != pid)\n\t\terr(EXIT_FAILURE, \"waitpid(%d) failed\", pid);\n\tif (!WIFSIGNALED(status) || WTERMSIG(status) != SIGKILL)\n\t\terrx(EXIT_FAILURE, \"unexpected exit code: %d\", status);\n\n\tgettimeofday(&stop, NULL);\n\ttimersub(&stop, &start, &diff);\n\n\tswitch (bench_format) {\n\tcase BENCH_FORMAT_DEFAULT:\n\t\tprintf(\"# Executed %\" PRIu64 \" system calls\\n\\n\",\n\t\t\tloops);\n\n\t\tresult_usec = diff.tv_sec * USEC_PER_SEC;\n\t\tresult_usec += diff.tv_usec;\n\n\t\tprintf(\" %14s: %lu.%03lu [sec]\\n\\n\", \"Total time\",\n\t\t       (unsigned long) diff.tv_sec,\n\t\t       (unsigned long) (diff.tv_usec / USEC_PER_MSEC));\n\n\t\tprintf(\" %14lf usecs/op\\n\",\n\t\t       (double)result_usec / (double)loops);\n\t\tprintf(\" %14d ops/sec\\n\",\n\t\t       (int)((double)loops /\n\t\t\t     ((double)result_usec / (double)USEC_PER_SEC)));\n\t\tbreak;\n\n\tcase BENCH_FORMAT_SIMPLE:\n\t\tprintf(\"%lu.%03lu\\n\",\n\t\t       (unsigned long) diff.tv_sec,\n\t\t       (unsigned long) (diff.tv_usec / USEC_PER_MSEC));\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tfprintf(stderr, \"Unknown format:%d\\n\", bench_format);\n\t\texit(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}