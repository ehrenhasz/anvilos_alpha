{
  "module_name": "epoll-ctl.c",
  "hash_id": "4e0eb904f5de707008698d434803ab2d446eb897afecedbaccfe9ac11cfe7d0b",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/epoll-ctl.c",
  "human_readable_source": "\n \n#ifdef HAVE_EVENTFD_SUPPORT\n \n#include <string.h>\n#include <pthread.h>\n\n#include <errno.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/epoll.h>\n#include <sys/eventfd.h>\n#include <perf/cpumap.h>\n\n#include \"../util/mutex.h\"\n#include \"../util/stat.h\"\n#include <subcmd/parse-options.h>\n#include \"bench.h\"\n\n#include <err.h>\n\n#define printinfo(fmt, arg...) \\\n\tdo { if (__verbose) printf(fmt, ## arg); } while (0)\n\nstatic unsigned int nthreads = 0;\nstatic unsigned int nsecs    = 8;\nstatic bool done, __verbose, randomize;\n\n \n\n \n#define EPOLL_MAXNESTS 4\n\nenum {\n\tOP_EPOLL_ADD,\n\tOP_EPOLL_MOD,\n\tOP_EPOLL_DEL,\n\tEPOLL_NR_OPS,\n};\n\nstatic int epollfd;\nstatic int *epollfdp;\nstatic bool noaffinity;\nstatic unsigned int nested = 0;\n\n \nstatic unsigned int nfds = 64;\n\nstatic struct mutex thread_lock;\nstatic unsigned int threads_starting;\nstatic struct stats all_stats[EPOLL_NR_OPS];\nstatic struct cond thread_parent, thread_worker;\n\nstruct worker {\n\tint tid;\n\tpthread_t thread;\n\tunsigned long ops[EPOLL_NR_OPS];\n\tint *fdmap;\n};\n\nstatic const struct option options[] = {\n\tOPT_UINTEGER('t', \"threads\", &nthreads, \"Specify amount of threads\"),\n\tOPT_UINTEGER('r', \"runtime\", &nsecs,    \"Specify runtime (in seconds)\"),\n\tOPT_UINTEGER('f', \"nfds\", &nfds, \"Specify amount of file descriptors to monitor for each thread\"),\n\tOPT_BOOLEAN( 'n', \"noaffinity\",  &noaffinity,   \"Disables CPU affinity\"),\n\tOPT_UINTEGER( 'N', \"nested\",  &nested,   \"Nesting level epoll hierarchy (default is 0, no nesting)\"),\n\tOPT_BOOLEAN( 'R', \"randomize\", &randomize,   \"Perform random operations on random fds\"),\n\tOPT_BOOLEAN( 'v', \"verbose\",  &__verbose,   \"Verbose mode\"),\n\tOPT_END()\n};\n\nstatic const char * const bench_epoll_ctl_usage[] = {\n\t\"perf bench epoll ctl <options>\",\n\tNULL\n};\n\nstatic void toggle_done(int sig __maybe_unused,\n\t\t\tsiginfo_t *info __maybe_unused,\n\t\t\tvoid *uc __maybe_unused)\n{\n\t \n\tdone = true;\n\tgettimeofday(&bench__end, NULL);\n\ttimersub(&bench__end, &bench__start, &bench__runtime);\n}\n\nstatic void nest_epollfd(void)\n{\n\tunsigned int i;\n\tstruct epoll_event ev;\n\n\tif (nested > EPOLL_MAXNESTS)\n\t\tnested = EPOLL_MAXNESTS;\n\tprintinfo(\"Nesting level(s): %d\\n\", nested);\n\n\tepollfdp = calloc(nested, sizeof(int));\n\tif (!epollfdp)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tfor (i = 0; i < nested; i++) {\n\t\tepollfdp[i] = epoll_create(1);\n\t\tif (epollfd < 0)\n\t\t\terr(EXIT_FAILURE, \"epoll_create\");\n\t}\n\n\tev.events = EPOLLHUP;  \n\tev.data.u64 = i;  \n\n\tfor (i = nested - 1; i; i--) {\n\t\tif (epoll_ctl(epollfdp[i - 1], EPOLL_CTL_ADD,\n\t\t\t      epollfdp[i], &ev) < 0)\n\t\t\terr(EXIT_FAILURE, \"epoll_ctl\");\n\t}\n\n\tif (epoll_ctl(epollfd, EPOLL_CTL_ADD, *epollfdp, &ev) < 0)\n\t\terr(EXIT_FAILURE, \"epoll_ctl\");\n}\n\nstatic inline void do_epoll_op(struct worker *w, int op, int fd)\n{\n\tint error;\n\tstruct epoll_event ev;\n\n\tev.events = EPOLLIN;\n\tev.data.u64 = fd;\n\n\tswitch (op) {\n\tcase OP_EPOLL_ADD:\n\t\terror = epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &ev);\n\t\tbreak;\n\tcase OP_EPOLL_MOD:\n\t\tev.events = EPOLLOUT;\n\t\terror = epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &ev);\n\t\tbreak;\n\tcase OP_EPOLL_DEL:\n\t\terror = epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL);\n\t\tbreak;\n\tdefault:\n\t\terror = 1;\n\t\tbreak;\n\t}\n\n\tif (!error)\n\t\tw->ops[op]++;\n}\n\nstatic inline void do_random_epoll_op(struct worker *w)\n{\n\tunsigned long rnd1 = random(), rnd2 = random();\n\tint op, fd;\n\n\tfd = w->fdmap[rnd1 % nfds];\n\top = rnd2 % EPOLL_NR_OPS;\n\n\tdo_epoll_op(w, op, fd);\n}\n\nstatic void *workerfn(void *arg)\n{\n\tunsigned int i;\n\tstruct worker *w = (struct worker *) arg;\n\tstruct timespec ts = { .tv_sec = 0,\n\t\t\t       .tv_nsec = 250 };\n\n\tmutex_lock(&thread_lock);\n\tthreads_starting--;\n\tif (!threads_starting)\n\t\tcond_signal(&thread_parent);\n\tcond_wait(&thread_worker, &thread_lock);\n\tmutex_unlock(&thread_lock);\n\n\t \n\tdo {\n\t\t \n\t\tif (randomize) {\n\t\t\tdo_random_epoll_op(w);\n\t\t} else {\n\t\t\tfor (i = 0; i < nfds; i++) {\n\t\t\t\tdo_epoll_op(w, OP_EPOLL_ADD, w->fdmap[i]);\n\t\t\t\tdo_epoll_op(w, OP_EPOLL_MOD, w->fdmap[i]);\n\t\t\t\tdo_epoll_op(w, OP_EPOLL_DEL, w->fdmap[i]);\n\t\t\t}\n\t\t}\n\n\t\tnanosleep(&ts, NULL);\n\t}  while (!done);\n\n\treturn NULL;\n}\n\nstatic void init_fdmaps(struct worker *w, int pct)\n{\n\tunsigned int i;\n\tint inc;\n\tstruct epoll_event ev;\n\n\tif (!pct)\n\t\treturn;\n\n\tinc = 100/pct;\n\tfor (i = 0; i < nfds; i+=inc) {\n\t\tev.data.fd = w->fdmap[i];\n\t\tev.events = EPOLLIN;\n\n\t\tif (epoll_ctl(epollfd, EPOLL_CTL_ADD, w->fdmap[i], &ev) < 0)\n\t\t\terr(EXIT_FAILURE, \"epoll_ct\");\n\t}\n}\n\nstatic int do_threads(struct worker *worker, struct perf_cpu_map *cpu)\n{\n\tpthread_attr_t thread_attr, *attrp = NULL;\n\tcpu_set_t *cpuset;\n\tunsigned int i, j;\n\tint ret = 0;\n\tint nrcpus;\n\tsize_t size;\n\n\tif (!noaffinity)\n\t\tpthread_attr_init(&thread_attr);\n\n\tnrcpus = perf_cpu_map__nr(cpu);\n\tcpuset = CPU_ALLOC(nrcpus);\n\tBUG_ON(!cpuset);\n\tsize = CPU_ALLOC_SIZE(nrcpus);\n\n\tfor (i = 0; i < nthreads; i++) {\n\t\tstruct worker *w = &worker[i];\n\n\t\tw->tid = i;\n\t\tw->fdmap = calloc(nfds, sizeof(int));\n\t\tif (!w->fdmap)\n\t\t\treturn 1;\n\n\t\tfor (j = 0; j < nfds; j++) {\n\t\t\tw->fdmap[j] = eventfd(0, EFD_NONBLOCK);\n\t\t\tif (w->fdmap[j] < 0)\n\t\t\t\terr(EXIT_FAILURE, \"eventfd\");\n\t\t}\n\n\t\t \n\t\tif (randomize)\n\t\t\tinit_fdmaps(w, 50);\n\n\t\tif (!noaffinity) {\n\t\t\tCPU_ZERO_S(size, cpuset);\n\t\t\tCPU_SET_S(perf_cpu_map__cpu(cpu, i % perf_cpu_map__nr(cpu)).cpu,\n\t\t\t\t\tsize, cpuset);\n\n\t\t\tret = pthread_attr_setaffinity_np(&thread_attr, size, cpuset);\n\t\t\tif (ret) {\n\t\t\t\tCPU_FREE(cpuset);\n\t\t\t\terr(EXIT_FAILURE, \"pthread_attr_setaffinity_np\");\n\t\t\t}\n\n\t\t\tattrp = &thread_attr;\n\t\t}\n\n\t\tret = pthread_create(&w->thread, attrp, workerfn,\n\t\t\t\t     (void *)(struct worker *) w);\n\t\tif (ret) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_create\");\n\t\t}\n\t}\n\n\tCPU_FREE(cpuset);\n\tif (!noaffinity)\n\t\tpthread_attr_destroy(&thread_attr);\n\n\treturn ret;\n}\n\nstatic void print_summary(void)\n{\n\tint i;\n\tunsigned long avg[EPOLL_NR_OPS];\n\tdouble stddev[EPOLL_NR_OPS];\n\n\tfor (i = 0; i < EPOLL_NR_OPS; i++) {\n\t\tavg[i] = avg_stats(&all_stats[i]);\n\t\tstddev[i] = stddev_stats(&all_stats[i]);\n\t}\n\n\tprintf(\"\\nAveraged %ld ADD operations (+- %.2f%%)\\n\",\n\t       avg[OP_EPOLL_ADD], rel_stddev_stats(stddev[OP_EPOLL_ADD],\n\t\t\t\t\t\t   avg[OP_EPOLL_ADD]));\n\tprintf(\"Averaged %ld MOD operations (+- %.2f%%)\\n\",\n\t       avg[OP_EPOLL_MOD], rel_stddev_stats(stddev[OP_EPOLL_MOD],\n\t\t\t\t\t\t   avg[OP_EPOLL_MOD]));\n\tprintf(\"Averaged %ld DEL operations (+- %.2f%%)\\n\",\n\t       avg[OP_EPOLL_DEL], rel_stddev_stats(stddev[OP_EPOLL_DEL],\n\t\t\t\t\t\t   avg[OP_EPOLL_DEL]));\n}\n\nint bench_epoll_ctl(int argc, const char **argv)\n{\n\tint j, ret = 0;\n\tstruct sigaction act;\n\tstruct worker *worker = NULL;\n\tstruct perf_cpu_map *cpu;\n\tstruct rlimit rl, prevrl;\n\tunsigned int i;\n\n\targc = parse_options(argc, argv, options, bench_epoll_ctl_usage, 0);\n\tif (argc) {\n\t\tusage_with_options(bench_epoll_ctl_usage, options);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemset(&act, 0, sizeof(act));\n\tsigfillset(&act.sa_mask);\n\tact.sa_sigaction = toggle_done;\n\tsigaction(SIGINT, &act, NULL);\n\n\tcpu = perf_cpu_map__new(NULL);\n\tif (!cpu)\n\t\tgoto errmem;\n\n\t \n\tepollfd = epoll_create(1);\n\tif (epollfd < 0)\n\t\terr(EXIT_FAILURE, \"epoll_create\");\n\n\t \n\tif (nested)\n\t\tnest_epollfd();\n\n\t \n\tif (!nthreads)\n\t\tnthreads = perf_cpu_map__nr(cpu);\n\n\tworker = calloc(nthreads, sizeof(*worker));\n\tif (!worker)\n\t\tgoto errmem;\n\n\tif (getrlimit(RLIMIT_NOFILE, &prevrl))\n\t    err(EXIT_FAILURE, \"getrlimit\");\n\trl.rlim_cur = rl.rlim_max = nfds * nthreads * 2 + 50;\n\tprintinfo(\"Setting RLIMIT_NOFILE rlimit from %\" PRIu64 \" to: %\" PRIu64 \"\\n\",\n\t\t  (uint64_t)prevrl.rlim_max, (uint64_t)rl.rlim_max);\n\tif (setrlimit(RLIMIT_NOFILE, &rl) < 0)\n\t\terr(EXIT_FAILURE, \"setrlimit\");\n\n\tprintf(\"Run summary [PID %d]: %d threads doing epoll_ctl ops \"\n\t       \"%d file-descriptors for %d secs.\\n\\n\",\n\t       getpid(), nthreads, nfds, nsecs);\n\n\tfor (i = 0; i < EPOLL_NR_OPS; i++)\n\t\tinit_stats(&all_stats[i]);\n\n\tmutex_init(&thread_lock);\n\tcond_init(&thread_parent);\n\tcond_init(&thread_worker);\n\n\tthreads_starting = nthreads;\n\n\tgettimeofday(&bench__start, NULL);\n\n\tdo_threads(worker, cpu);\n\n\tmutex_lock(&thread_lock);\n\twhile (threads_starting)\n\t\tcond_wait(&thread_parent, &thread_lock);\n\tcond_broadcast(&thread_worker);\n\tmutex_unlock(&thread_lock);\n\n\tsleep(nsecs);\n\ttoggle_done(0, NULL, NULL);\n\tprintinfo(\"main thread: toggling done\\n\");\n\n\tfor (i = 0; i < nthreads; i++) {\n\t\tret = pthread_join(worker[i].thread, NULL);\n\t\tif (ret)\n\t\t\terr(EXIT_FAILURE, \"pthread_join\");\n\t}\n\n\t \n\tcond_destroy(&thread_parent);\n\tcond_destroy(&thread_worker);\n\tmutex_destroy(&thread_lock);\n\n\tfor (i = 0; i < nthreads; i++) {\n\t\tunsigned long t[EPOLL_NR_OPS];\n\n\t\tfor (j = 0; j < EPOLL_NR_OPS; j++) {\n\t\t\tt[j] = worker[i].ops[j];\n\t\t\tupdate_stats(&all_stats[j], t[j]);\n\t\t}\n\n\t\tif (nfds == 1)\n\t\t\tprintf(\"[thread %2d] fdmap: %p [ add: %04ld; mod: %04ld; del: %04lds ops ]\\n\",\n\t\t\t       worker[i].tid, &worker[i].fdmap[0],\n\t\t\t       t[OP_EPOLL_ADD], t[OP_EPOLL_MOD], t[OP_EPOLL_DEL]);\n\t\telse\n\t\t\tprintf(\"[thread %2d] fdmap: %p ... %p [ add: %04ld ops; mod: %04ld ops; del: %04ld ops ]\\n\",\n\t\t\t       worker[i].tid, &worker[i].fdmap[0],\n\t\t\t       &worker[i].fdmap[nfds-1],\n\t\t\t       t[OP_EPOLL_ADD], t[OP_EPOLL_MOD], t[OP_EPOLL_DEL]);\n\t}\n\n\tprint_summary();\n\n\tclose(epollfd);\n\tperf_cpu_map__put(cpu);\n\tfor (i = 0; i < nthreads; i++)\n\t\tfree(worker[i].fdmap);\n\n\tfree(worker);\n\treturn ret;\nerrmem:\n\terr(EXIT_FAILURE, \"calloc\");\n}\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}