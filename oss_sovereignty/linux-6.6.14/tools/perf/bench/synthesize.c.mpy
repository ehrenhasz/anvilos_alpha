{
  "module_name": "synthesize.c",
  "hash_id": "059af677f0ce2fd1df6b5c88d5bb1b207a96fc0766c2db8c5528eb36796dc1e6",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/synthesize.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include \"bench.h\"\n#include \"../util/debug.h\"\n#include \"../util/session.h\"\n#include \"../util/stat.h\"\n#include \"../util/synthetic-events.h\"\n#include \"../util/target.h\"\n#include \"../util/thread_map.h\"\n#include \"../util/tool.h\"\n#include \"../util/util.h\"\n#include <linux/atomic.h>\n#include <linux/err.h>\n#include <linux/time64.h>\n#include <subcmd/parse-options.h>\n\nstatic unsigned int min_threads = 1;\nstatic unsigned int max_threads = UINT_MAX;\nstatic unsigned int single_iterations = 10000;\nstatic unsigned int multi_iterations = 10;\nstatic bool run_st;\nstatic bool run_mt;\n\nstatic const struct option options[] = {\n\tOPT_BOOLEAN('s', \"st\", &run_st, \"Run single threaded benchmark\"),\n\tOPT_BOOLEAN('t', \"mt\", &run_mt, \"Run multi-threaded benchmark\"),\n\tOPT_UINTEGER('m', \"min-threads\", &min_threads,\n\t\t\"Minimum number of threads in multithreaded bench\"),\n\tOPT_UINTEGER('M', \"max-threads\", &max_threads,\n\t\t\"Maximum number of threads in multithreaded bench\"),\n\tOPT_UINTEGER('i', \"single-iterations\", &single_iterations,\n\t\t\"Number of iterations used to compute single-threaded average\"),\n\tOPT_UINTEGER('I', \"multi-iterations\", &multi_iterations,\n\t\t\"Number of iterations used to compute multi-threaded average\"),\n\tOPT_END()\n};\n\nstatic const char *const bench_usage[] = {\n\t\"perf bench internals synthesize <options>\",\n\tNULL\n};\n\nstatic atomic_t event_count;\n\nstatic int process_synthesized_event(struct perf_tool *tool __maybe_unused,\n\t\t\t\t     union perf_event *event __maybe_unused,\n\t\t\t\t     struct perf_sample *sample __maybe_unused,\n\t\t\t\t     struct machine *machine __maybe_unused)\n{\n\tatomic_inc(&event_count);\n\treturn 0;\n}\n\nstatic int do_run_single_threaded(struct perf_session *session,\n\t\t\t\tstruct perf_thread_map *threads,\n\t\t\t\tstruct target *target, bool data_mmap)\n{\n\tconst unsigned int nr_threads_synthesize = 1;\n\tstruct timeval start, end, diff;\n\tu64 runtime_us;\n\tunsigned int i;\n\tdouble time_average, time_stddev, event_average, event_stddev;\n\tint err;\n\tstruct stats time_stats, event_stats;\n\n\tinit_stats(&time_stats);\n\tinit_stats(&event_stats);\n\n\tfor (i = 0; i < single_iterations; i++) {\n\t\tatomic_set(&event_count, 0);\n\t\tgettimeofday(&start, NULL);\n\t\terr = __machine__synthesize_threads(&session->machines.host,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\ttarget, threads,\n\t\t\t\t\t\tprocess_synthesized_event,\n\t\t\t\t\t\ttrue, data_mmap,\n\t\t\t\t\t\tnr_threads_synthesize);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tgettimeofday(&end, NULL);\n\t\ttimersub(&end, &start, &diff);\n\t\truntime_us = diff.tv_sec * USEC_PER_SEC + diff.tv_usec;\n\t\tupdate_stats(&time_stats, runtime_us);\n\t\tupdate_stats(&event_stats, atomic_read(&event_count));\n\t}\n\n\ttime_average = avg_stats(&time_stats);\n\ttime_stddev = stddev_stats(&time_stats);\n\tprintf(\"  Average %ssynthesis took: %.3f usec (+- %.3f usec)\\n\",\n\t\tdata_mmap ? \"data \" : \"\", time_average, time_stddev);\n\n\tevent_average = avg_stats(&event_stats);\n\tevent_stddev = stddev_stats(&event_stats);\n\tprintf(\"  Average num. events: %.3f (+- %.3f)\\n\",\n\t\tevent_average, event_stddev);\n\n\tprintf(\"  Average time per event %.3f usec\\n\",\n\t\ttime_average / event_average);\n\treturn 0;\n}\n\nstatic int run_single_threaded(void)\n{\n\tstruct perf_session *session;\n\tstruct target target = {\n\t\t.pid = \"self\",\n\t};\n\tstruct perf_thread_map *threads;\n\tint err;\n\n\tperf_set_singlethreaded();\n\tsession = perf_session__new(NULL, NULL);\n\tif (IS_ERR(session)) {\n\t\tpr_err(\"Session creation failed.\\n\");\n\t\treturn PTR_ERR(session);\n\t}\n\tthreads = thread_map__new_by_pid(getpid());\n\tif (!threads) {\n\t\tpr_err(\"Thread map creation failed.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tputs(\n\"Computing performance of single threaded perf event synthesis by\\n\"\n\"synthesizing events on the perf process itself:\");\n\n\terr = do_run_single_threaded(session, threads, &target, false);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = do_run_single_threaded(session, threads, &target, true);\n\nerr_out:\n\tif (threads)\n\t\tperf_thread_map__put(threads);\n\n\tperf_session__delete(session);\n\treturn err;\n}\n\nstatic int do_run_multi_threaded(struct target *target,\n\t\t\t\tunsigned int nr_threads_synthesize)\n{\n\tstruct timeval start, end, diff;\n\tu64 runtime_us;\n\tunsigned int i;\n\tdouble time_average, time_stddev, event_average, event_stddev;\n\tint err;\n\tstruct stats time_stats, event_stats;\n\tstruct perf_session *session;\n\n\tinit_stats(&time_stats);\n\tinit_stats(&event_stats);\n\tfor (i = 0; i < multi_iterations; i++) {\n\t\tsession = perf_session__new(NULL, NULL);\n\t\tif (IS_ERR(session))\n\t\t\treturn PTR_ERR(session);\n\n\t\tatomic_set(&event_count, 0);\n\t\tgettimeofday(&start, NULL);\n\t\terr = __machine__synthesize_threads(&session->machines.host,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\ttarget, NULL,\n\t\t\t\t\t\tprocess_synthesized_event,\n\t\t\t\t\t\ttrue, false,\n\t\t\t\t\t\tnr_threads_synthesize);\n\t\tif (err) {\n\t\t\tperf_session__delete(session);\n\t\t\treturn err;\n\t\t}\n\n\t\tgettimeofday(&end, NULL);\n\t\ttimersub(&end, &start, &diff);\n\t\truntime_us = diff.tv_sec * USEC_PER_SEC + diff.tv_usec;\n\t\tupdate_stats(&time_stats, runtime_us);\n\t\tupdate_stats(&event_stats, atomic_read(&event_count));\n\t\tperf_session__delete(session);\n\t}\n\n\ttime_average = avg_stats(&time_stats);\n\ttime_stddev = stddev_stats(&time_stats);\n\tprintf(\"    Average synthesis took: %.3f usec (+- %.3f usec)\\n\",\n\t\ttime_average, time_stddev);\n\n\tevent_average = avg_stats(&event_stats);\n\tevent_stddev = stddev_stats(&event_stats);\n\tprintf(\"    Average num. events: %.3f (+- %.3f)\\n\",\n\t\tevent_average, event_stddev);\n\n\tprintf(\"    Average time per event %.3f usec\\n\",\n\t\ttime_average / event_average);\n\treturn 0;\n}\n\nstatic int run_multi_threaded(void)\n{\n\tstruct target target = {\n\t\t.cpu_list = \"0\"\n\t};\n\tunsigned int nr_threads_synthesize;\n\tint err;\n\n\tif (max_threads == UINT_MAX)\n\t\tmax_threads = sysconf(_SC_NPROCESSORS_ONLN);\n\n\tputs(\n\"Computing performance of multi threaded perf event synthesis by\\n\"\n\"synthesizing events on CPU 0:\");\n\n\tfor (nr_threads_synthesize = min_threads;\n\t     nr_threads_synthesize <= max_threads;\n\t     nr_threads_synthesize++) {\n\t\tif (nr_threads_synthesize == 1)\n\t\t\tperf_set_singlethreaded();\n\t\telse\n\t\t\tperf_set_multithreaded();\n\n\t\tprintf(\"  Number of synthesis threads: %u\\n\",\n\t\t\tnr_threads_synthesize);\n\n\t\terr = do_run_multi_threaded(&target, nr_threads_synthesize);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tperf_set_singlethreaded();\n\treturn 0;\n}\n\nint bench_synthesize(int argc, const char **argv)\n{\n\tint err = 0;\n\n\targc = parse_options(argc, argv, options, bench_usage, 0);\n\tif (argc) {\n\t\tusage_with_options(bench_usage, options);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tif (!run_st && !run_mt)\n\t\trun_st = true;\n\n\tif (run_st)\n\t\terr = run_single_threaded();\n\n\tif (!err && run_mt)\n\t\terr = run_multi_threaded();\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}