{
  "module_name": "uprobe.c",
  "hash_id": "14c2f16ac10f7870d18faeb6a49efdafff91b8926d9e3c2e9accd94293601e03",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/uprobe.c",
  "human_readable_source": "\n \n#include \"../perf.h\"\n#include \"../util/util.h\"\n#include <subcmd/parse-options.h>\n#include \"../builtin.h\"\n#include \"bench.h\"\n#include <linux/compiler.h>\n#include <linux/time64.h>\n\n#include <inttypes.h>\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n\n#define LOOPS_DEFAULT 1000\nstatic int loops = LOOPS_DEFAULT;\n\nenum bench_uprobe {\n        BENCH_UPROBE__BASELINE,\n        BENCH_UPROBE__EMPTY,\n        BENCH_UPROBE__TRACE_PRINTK,\n};\n\nstatic const struct option options[] = {\n\tOPT_INTEGER('l', \"loop\",\t&loops,\t\t\"Specify number of loops\"),\n\tOPT_END()\n};\n\nstatic const char * const bench_uprobe_usage[] = {\n\t\"perf bench uprobe <options>\",\n\tNULL\n};\n\n#ifdef HAVE_BPF_SKEL\n#include \"bpf_skel/bench_uprobe.skel.h\"\n\n#define bench_uprobe__attach_uprobe(prog) \\\n\tskel->links.prog = bpf_program__attach_uprobe_opts( skel->progs.prog, \\\n\t\t\t\t\t\t\t    -1, \\\n\t\t\t\t\t\t\t    \"/lib64/libc.so.6\", \\\n\t\t\t\t\t\t\t    0, \\\n\t\t\t\t\t\t\t    &uprobe_opts); \\\n\tif (!skel->links.prog) { \\\n\t\terr = -errno; \\\n\t\tfprintf(stderr, \"Failed to attach bench uprobe \\\"%s\\\": %s\\n\", #prog, strerror(errno)); \\\n\t\tgoto cleanup; \\\n\t}\n\nstruct bench_uprobe_bpf *skel;\n\nstatic int bench_uprobe__setup_bpf_skel(enum bench_uprobe bench)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_uprobe_opts, uprobe_opts);\n\tint err;\n\n\t \n\tskel = bench_uprobe_bpf__open();\n\tif (!skel) {\n\t\tfprintf(stderr, \"Failed to open and load uprobes bench BPF skeleton\\n\");\n\t\treturn -1;\n\t}\n\n\terr = bench_uprobe_bpf__load(skel);\n\tif (err) {\n\t\tfprintf(stderr, \"Failed to load and verify BPF skeleton\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tuprobe_opts.func_name = \"usleep\";\n\tswitch (bench) {\n\tcase BENCH_UPROBE__BASELINE:\t\t\t\t\t\t\tbreak;\n\tcase BENCH_UPROBE__EMPTY:\t bench_uprobe__attach_uprobe(empty);\t\tbreak;\n\tcase BENCH_UPROBE__TRACE_PRINTK: bench_uprobe__attach_uprobe(trace_printk);\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"Invalid bench: %d\\n\", bench);\n\t\tgoto cleanup;\n\t}\n\n\treturn err;\ncleanup:\n\tbench_uprobe_bpf__destroy(skel);\n\treturn err;\n}\n\nstatic void bench_uprobe__teardown_bpf_skel(void)\n{\n\tif (skel) {\n\t\tbench_uprobe_bpf__destroy(skel);\n\t\tskel = NULL;\n\t}\n}\n#else\nstatic int bench_uprobe__setup_bpf_skel(enum bench_uprobe bench __maybe_unused) { return 0; }\nstatic void bench_uprobe__teardown_bpf_skel(void) {};\n#endif\n\nstatic int bench_uprobe_format__default_fprintf(const char *name, const char *unit, u64 diff, FILE *fp)\n{\n\tstatic u64 baseline, previous;\n\ts64 diff_to_baseline = diff - baseline,\n\t    diff_to_previous = diff - previous;\n\tint printed = fprintf(fp, \"# Executed %'d %s calls\\n\", loops, name);\n\n\tprinted += fprintf(fp, \" %14s: %'\" PRIu64 \" %ss\", \"Total time\", diff, unit);\n\n\tif (baseline) {\n\t\tprinted += fprintf(fp, \" %s%'\" PRId64 \" to baseline\", diff_to_baseline > 0 ? \"+\" : \"\", diff_to_baseline);\n\n\t\tif (previous != baseline)\n\t\t\tfprintf(stdout, \" %s%'\" PRId64 \" to previous\", diff_to_previous > 0 ? \"+\" : \"\", diff_to_previous);\n\t}\n\n\tprinted += fprintf(fp, \"\\n\\n %'.3f %ss/op\", (double)diff / (double)loops, unit);\n\n\tif (baseline) {\n\t\tprinted += fprintf(fp, \" %'.3f %ss/op to baseline\", (double)diff_to_baseline / (double)loops, unit);\n\n\t\tif (previous != baseline)\n\t\t\tprinted += fprintf(fp, \" %'.3f %ss/op to previous\", (double)diff_to_previous / (double)loops, unit);\n\t} else {\n\t\tbaseline = diff;\n\t}\n\n\tfputc('\\n', fp);\n\n\tprevious = diff;\n\n\treturn printed + 1;\n}\n\nstatic int bench_uprobe(int argc, const char **argv, enum bench_uprobe bench)\n{\n\tconst char *name = \"usleep(1000)\", *unit = \"usec\";\n\tstruct timespec start, end;\n\tu64 diff;\n\tint i;\n\n\targc = parse_options(argc, argv, options, bench_uprobe_usage, 0);\n\n\tif (bench != BENCH_UPROBE__BASELINE && bench_uprobe__setup_bpf_skel(bench) < 0)\n\t\treturn 0;\n\n        clock_gettime(CLOCK_REALTIME, &start);\n\n\tfor (i = 0; i < loops; i++) {\n\t\tusleep(USEC_PER_MSEC);\n\t}\n\n\tclock_gettime(CLOCK_REALTIME, &end);\n\n\tdiff = end.tv_sec * NSEC_PER_SEC + end.tv_nsec - (start.tv_sec * NSEC_PER_SEC + start.tv_nsec);\n\tdiff /= NSEC_PER_USEC;\n\n\tswitch (bench_format) {\n\tcase BENCH_FORMAT_DEFAULT:\n\t\tbench_uprobe_format__default_fprintf(name, unit, diff, stdout);\n\t\tbreak;\n\n\tcase BENCH_FORMAT_SIMPLE:\n\t\tprintf(\"%\" PRIu64 \"\\n\", diff);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tfprintf(stderr, \"Unknown format:%d\\n\", bench_format);\n\t\texit(1);\n\t}\n\n\tif (bench != BENCH_UPROBE__BASELINE)\n\t\tbench_uprobe__teardown_bpf_skel();\n\n\treturn 0;\n}\n\nint bench_uprobe_baseline(int argc, const char **argv)\n{\n\treturn bench_uprobe(argc, argv, BENCH_UPROBE__BASELINE);\n}\n\nint bench_uprobe_empty(int argc, const char **argv)\n{\n\treturn bench_uprobe(argc, argv, BENCH_UPROBE__EMPTY);\n}\n\nint bench_uprobe_trace_printk(int argc, const char **argv)\n{\n\treturn bench_uprobe(argc, argv, BENCH_UPROBE__TRACE_PRINTK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}