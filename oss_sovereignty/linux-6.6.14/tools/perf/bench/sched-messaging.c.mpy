{
  "module_name": "sched-messaging.c",
  "hash_id": "15b11dfbeeb4da53199e58d2868158fb4e13ff25498bb192ab26a604306318ec",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/sched-messaging.c",
  "human_readable_source": "\n \n\n#include <subcmd/parse-options.h>\n#include \"bench.h\"\n\n \n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <poll.h>\n#include <limits.h>\n#include <err.h>\n#include <linux/list.h>\n#include <linux/time64.h>\n\n#define DATASIZE 100\n\nstatic bool use_pipes = false;\nstatic unsigned int nr_loops = 100;\nstatic bool thread_mode = false;\nstatic unsigned int num_groups = 10;\nstatic struct list_head sender_contexts = LIST_HEAD_INIT(sender_contexts);\nstatic struct list_head receiver_contexts = LIST_HEAD_INIT(receiver_contexts);\n\nstruct sender_context {\n\tstruct list_head list;\n\tunsigned int num_fds;\n\tint ready_out;\n\tint wakefd;\n\tint out_fds[];\n};\n\nstruct receiver_context {\n\tstruct list_head list;\n\tunsigned int num_packets;\n\tint in_fds[2];\n\tint ready_out;\n\tint wakefd;\n};\n\nstatic void fdpair(int fds[2])\n{\n\tif (use_pipes) {\n\t\tif (pipe(fds) == 0)\n\t\t\treturn;\n\t} else {\n\t\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) == 0)\n\t\t\treturn;\n\t}\n\n\terr(EXIT_FAILURE, use_pipes ? \"pipe()\" : \"socketpair()\");\n}\n\n \nstatic void ready(int ready_out, int wakefd)\n{\n\tstruct pollfd pollfd = { .fd = wakefd, .events = POLLIN };\n\n\t \n\tif (write(ready_out, \"R\", 1) != 1)\n\t\terr(EXIT_FAILURE, \"CLIENT: ready write\");\n\n\t \n\tif (poll(&pollfd, 1, -1) != 1)\n\t\terr(EXIT_FAILURE, \"poll\");\n}\n\n \nstatic void *sender(struct sender_context *ctx)\n{\n\tchar data[DATASIZE];\n\tunsigned int i, j;\n\n\tready(ctx->ready_out, ctx->wakefd);\n\tmemset(data, 'S', sizeof(data));\n\n\t \n\tfor (i = 0; i < nr_loops; i++) {\n\t\tfor (j = 0; j < ctx->num_fds; j++) {\n\t\t\tint ret, done = 0;\n\nagain:\n\t\t\tret = write(ctx->out_fds[j], data + done,\n\t\t\t\t    sizeof(data)-done);\n\t\t\tif (ret < 0)\n\t\t\t\terr(EXIT_FAILURE, \"SENDER: write\");\n\t\t\tdone += ret;\n\t\t\tif (done < DATASIZE)\n\t\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n \nstatic void *receiver(struct receiver_context* ctx)\n{\n\tunsigned int i;\n\n\tif (!thread_mode)\n\t\tclose(ctx->in_fds[1]);\n\n\t \n\tready(ctx->ready_out, ctx->wakefd);\n\n\t \n\tfor (i = 0; i < ctx->num_packets; i++) {\n\t\tchar data[DATASIZE];\n\t\tint ret, done = 0;\n\nagain:\n\t\tret = read(ctx->in_fds[0], data + done, DATASIZE - done);\n\t\tif (ret < 0)\n\t\t\terr(EXIT_FAILURE, \"SERVER: read\");\n\t\tdone += ret;\n\t\tif (done < DATASIZE)\n\t\t\tgoto again;\n\t}\n\n\treturn NULL;\n}\n\nstatic pthread_t create_worker(void *ctx, void *(*func)(void *))\n{\n\tpthread_attr_t attr;\n\tpthread_t childid;\n\tint ret;\n\n\tif (!thread_mode) {\n\t\t \n\t\t \n\t\tswitch (fork()) {\n\t\tcase -1:\n\t\t\terr(EXIT_FAILURE, \"fork()\");\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t(*func) (ctx);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn (pthread_t)0;\n\t}\n\n\tif (pthread_attr_init(&attr) != 0)\n\t\terr(EXIT_FAILURE, \"pthread_attr_init:\");\n\n#ifndef __ia64__\n\tif (pthread_attr_setstacksize(&attr, PTHREAD_STACK_MIN) != 0)\n\t\terr(EXIT_FAILURE, \"pthread_attr_setstacksize\");\n#endif\n\n\tret = pthread_create(&childid, &attr, func, ctx);\n\tif (ret != 0)\n\t\terr(EXIT_FAILURE, \"pthread_create failed\");\n\n\tpthread_attr_destroy(&attr);\n\treturn childid;\n}\n\nstatic void reap_worker(pthread_t id)\n{\n\tint proc_status;\n\tvoid *thread_status;\n\n\tif (!thread_mode) {\n\t\t \n\t\twait(&proc_status);\n\t\tif (!WIFEXITED(proc_status))\n\t\t\texit(1);\n\t} else {\n\t\tpthread_join(id, &thread_status);\n\t}\n}\n\n \nstatic unsigned int group(pthread_t *pth,\n\t\tunsigned int num_fds,\n\t\tint ready_out,\n\t\tint wakefd)\n{\n\tunsigned int i;\n\tstruct sender_context *snd_ctx = malloc(sizeof(struct sender_context)\n\t\t\t+ num_fds * sizeof(int));\n\n\tif (!snd_ctx)\n\t\terr(EXIT_FAILURE, \"malloc()\");\n\n\tlist_add(&snd_ctx->list, &sender_contexts);\n\tfor (i = 0; i < num_fds; i++) {\n\t\tint fds[2];\n\t\tstruct receiver_context *ctx = malloc(sizeof(*ctx));\n\n\t\tif (!ctx)\n\t\t\terr(EXIT_FAILURE, \"malloc()\");\n\n\t\tlist_add(&ctx->list, &receiver_contexts);\n\n\t\t \n\t\tfdpair(fds);\n\n\t\tctx->num_packets = num_fds * nr_loops;\n\t\tctx->in_fds[0] = fds[0];\n\t\tctx->in_fds[1] = fds[1];\n\t\tctx->ready_out = ready_out;\n\t\tctx->wakefd = wakefd;\n\n\t\tpth[i] = create_worker(ctx, (void *)receiver);\n\n\t\tsnd_ctx->out_fds[i] = fds[1];\n\t\tif (!thread_mode)\n\t\t\tclose(fds[0]);\n\t}\n\n\t \n\tfor (i = 0; i < num_fds; i++) {\n\t\tsnd_ctx->ready_out = ready_out;\n\t\tsnd_ctx->wakefd = wakefd;\n\t\tsnd_ctx->num_fds = num_fds;\n\n\t\tpth[num_fds+i] = create_worker(snd_ctx, (void *)sender);\n\t}\n\n\t \n\tif (!thread_mode)\n\t\tfor (i = 0; i < num_fds; i++)\n\t\t\tclose(snd_ctx->out_fds[i]);\n\n\t \n\treturn num_fds * 2;\n}\n\nstatic const struct option options[] = {\n\tOPT_BOOLEAN('p', \"pipe\", &use_pipes,\n\t\t    \"Use pipe() instead of socketpair()\"),\n\tOPT_BOOLEAN('t', \"thread\", &thread_mode,\n\t\t    \"Be multi thread instead of multi process\"),\n\tOPT_UINTEGER('g', \"group\", &num_groups, \"Specify number of groups\"),\n\tOPT_UINTEGER('l', \"nr_loops\", &nr_loops, \"Specify the number of loops to run (default: 100)\"),\n\tOPT_END()\n};\n\nstatic const char * const bench_sched_message_usage[] = {\n\t\"perf bench sched messaging <options>\",\n\tNULL\n};\n\nint bench_sched_messaging(int argc, const char **argv)\n{\n\tunsigned int i, total_children;\n\tstruct timeval start, stop, diff;\n\tunsigned int num_fds = 20;\n\tint readyfds[2], wakefds[2];\n\tchar dummy;\n\tpthread_t *pth_tab;\n\tstruct sender_context *pos, *n;\n\n\targc = parse_options(argc, argv, options,\n\t\t\t     bench_sched_message_usage, 0);\n\n\tpth_tab = malloc(num_fds * 2 * num_groups * sizeof(pthread_t));\n\tif (!pth_tab)\n\t\terr(EXIT_FAILURE, \"main:malloc()\");\n\n\tfdpair(readyfds);\n\tfdpair(wakefds);\n\n\ttotal_children = 0;\n\tfor (i = 0; i < num_groups; i++)\n\t\ttotal_children += group(pth_tab+total_children, num_fds,\n\t\t\t\t\treadyfds[1], wakefds[0]);\n\n\t \n\tfor (i = 0; i < total_children; i++)\n\t\tif (read(readyfds[0], &dummy, 1) != 1)\n\t\t\terr(EXIT_FAILURE, \"Reading for readyfds\");\n\n\tgettimeofday(&start, NULL);\n\n\t \n\tif (write(wakefds[1], &dummy, 1) != 1)\n\t\terr(EXIT_FAILURE, \"Writing to start them\");\n\n\t \n\tfor (i = 0; i < total_children; i++)\n\t\treap_worker(pth_tab[i]);\n\n\tgettimeofday(&stop, NULL);\n\n\ttimersub(&stop, &start, &diff);\n\n\tswitch (bench_format) {\n\tcase BENCH_FORMAT_DEFAULT:\n\t\tprintf(\"# %d sender and receiver %s per group\\n\",\n\t\t       num_fds, thread_mode ? \"threads\" : \"processes\");\n\t\tprintf(\"# %d groups == %d %s run\\n\\n\",\n\t\t       num_groups, num_groups * 2 * num_fds,\n\t\t       thread_mode ? \"threads\" : \"processes\");\n\t\tprintf(\" %14s: %lu.%03lu [sec]\\n\", \"Total time\",\n\t\t       (unsigned long) diff.tv_sec,\n\t\t       (unsigned long) (diff.tv_usec / USEC_PER_MSEC));\n\t\tbreak;\n\tcase BENCH_FORMAT_SIMPLE:\n\t\tprintf(\"%lu.%03lu\\n\", (unsigned long) diff.tv_sec,\n\t\t       (unsigned long) (diff.tv_usec / USEC_PER_MSEC));\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfprintf(stderr, \"Unknown format:%d\\n\", bench_format);\n\t\texit(1);\n\t\tbreak;\n\t}\n\n\tfree(pth_tab);\n\tlist_for_each_entry_safe(pos, n, &sender_contexts, list) {\n\t\tlist_del_init(&pos->list);\n\t\tfree(pos);\n\t}\n\tlist_for_each_entry_safe(pos, n, &receiver_contexts, list) {\n\t\tlist_del_init(&pos->list);\n\t\tfree(pos);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}