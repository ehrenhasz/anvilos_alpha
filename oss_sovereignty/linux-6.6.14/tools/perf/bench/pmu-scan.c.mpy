{
  "module_name": "pmu-scan.c",
  "hash_id": "ebf43594a86fcd1439c670b19d68ca5c74b333e32e29453848359c19498d96be",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/pmu-scan.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include \"bench.h\"\n#include \"util/debug.h\"\n#include \"util/pmu.h\"\n#include \"util/pmus.h\"\n#include \"util/stat.h\"\n#include <linux/atomic.h>\n#include <linux/err.h>\n#include <linux/time64.h>\n#include <subcmd/parse-options.h>\n\nstatic unsigned int iterations = 100;\n\nstruct pmu_scan_result {\n\tchar *name;\n\tint nr_aliases;\n\tint nr_formats;\n\tint nr_caps;\n\tbool is_core;\n};\n\nstatic const struct option options[] = {\n\tOPT_UINTEGER('i', \"iterations\", &iterations,\n\t\t\"Number of iterations used to compute average\"),\n\tOPT_END()\n};\n\nstatic const char *const bench_usage[] = {\n\t\"perf bench internals pmu-scan <options>\",\n\tNULL\n};\n\nstatic int nr_pmus;\nstatic struct pmu_scan_result *results;\n\nstatic int save_result(void)\n{\n\tstruct perf_pmu *pmu = NULL;\n\tstruct list_head *list;\n\tstruct pmu_scan_result *r;\n\n\twhile ((pmu = perf_pmus__scan(pmu)) != NULL) {\n\t\tr = realloc(results, (nr_pmus + 1) * sizeof(*r));\n\t\tif (r == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tresults = r;\n\t\tr = results + nr_pmus;\n\n\t\tr->name = strdup(pmu->name);\n\t\tr->is_core = pmu->is_core;\n\t\tr->nr_caps = pmu->nr_caps;\n\n\t\tr->nr_aliases = perf_pmu__num_events(pmu);\n\n\t\tr->nr_formats = 0;\n\t\tlist_for_each(list, &pmu->format)\n\t\t\tr->nr_formats++;\n\n\t\tpr_debug(\"pmu[%d] name=%s, nr_caps=%d, nr_aliases=%d, nr_formats=%d\\n\",\n\t\t\tnr_pmus, r->name, r->nr_caps, r->nr_aliases, r->nr_formats);\n\t\tnr_pmus++;\n\t}\n\n\tperf_pmus__destroy();\n\treturn 0;\n}\n\nstatic int check_result(bool core_only)\n{\n\tstruct pmu_scan_result *r;\n\tstruct perf_pmu *pmu;\n\tstruct list_head *list;\n\tint nr;\n\n\tfor (int i = 0; i < nr_pmus; i++) {\n\t\tr = &results[i];\n\t\tif (core_only && !r->is_core)\n\t\t\tcontinue;\n\n\t\tpmu = perf_pmus__find(r->name);\n\t\tif (pmu == NULL) {\n\t\t\tpr_err(\"Cannot find PMU %s\\n\", r->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pmu->nr_caps != (u32)r->nr_caps) {\n\t\t\tpr_err(\"Unmatched number of event caps in %s: expect %d vs got %d\\n\",\n\t\t\t\tpmu->name, r->nr_caps, pmu->nr_caps);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnr = perf_pmu__num_events(pmu);\n\t\tif (nr != r->nr_aliases) {\n\t\t\tpr_err(\"Unmatched number of event aliases in %s: expect %d vs got %d\\n\",\n\t\t\t\tpmu->name, r->nr_aliases, nr);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnr = 0;\n\t\tlist_for_each(list, &pmu->format)\n\t\t\tnr++;\n\t\tif (nr != r->nr_formats) {\n\t\t\tpr_err(\"Unmatched number of event formats in %s: expect %d vs got %d\\n\",\n\t\t\t\tpmu->name, r->nr_formats, nr);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void delete_result(void)\n{\n\tfor (int i = 0; i < nr_pmus; i++)\n\t\tfree(results[i].name);\n\tfree(results);\n\n\tresults = NULL;\n\tnr_pmus = 0;\n}\n\nstatic int run_pmu_scan(void)\n{\n\tstruct stats stats;\n\tstruct timeval start, end, diff;\n\tdouble time_average, time_stddev;\n\tu64 runtime_us;\n\tint ret;\n\n\tinit_stats(&stats);\n\tpr_info(\"Computing performance of sysfs PMU event scan for %u times\\n\",\n\t\titerations);\n\n\tif (save_result() < 0) {\n\t\tpr_err(\"Failed to initialize PMU scan result\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (int j = 0; j < 2; j++) {\n\t\tbool core_only = (j == 0);\n\n\t\tfor (unsigned int i = 0; i < iterations; i++) {\n\t\t\tgettimeofday(&start, NULL);\n\t\t\tif (core_only)\n\t\t\t\tperf_pmus__scan_core(NULL);\n\t\t\telse\n\t\t\t\tperf_pmus__scan(NULL);\n\t\t\tgettimeofday(&end, NULL);\n\t\t\ttimersub(&end, &start, &diff);\n\t\t\truntime_us = diff.tv_sec * USEC_PER_SEC + diff.tv_usec;\n\t\t\tupdate_stats(&stats, runtime_us);\n\n\t\t\tret = check_result(core_only);\n\t\t\tperf_pmus__destroy();\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ttime_average = avg_stats(&stats);\n\t\ttime_stddev = stddev_stats(&stats);\n\t\tpr_info(\"  Average%s PMU scanning took: %.3f usec (+- %.3f usec)\\n\",\n\t\t\tcore_only ? \" core\" : \"\", time_average, time_stddev);\n\t}\n\tdelete_result();\n\treturn 0;\n}\n\nint bench_pmu_scan(int argc, const char **argv)\n{\n\tint err = 0;\n\n\targc = parse_options(argc, argv, options, bench_usage, 0);\n\tif (argc) {\n\t\tusage_with_options(bench_usage, options);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\terr = run_pmu_scan();\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}