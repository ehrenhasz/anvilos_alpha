{
  "module_name": "futex-wake.c",
  "hash_id": "59b596af1fb4b20dcdea9d78c0b2e43228f8a866bd0aab8f70aa6d1fa302a244",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/futex-wake.c",
  "human_readable_source": "\n \n\n \n#include <string.h>\n#include <pthread.h>\n\n#include <signal.h>\n#include \"../util/mutex.h\"\n#include \"../util/stat.h\"\n#include <subcmd/parse-options.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/time64.h>\n#include <errno.h>\n#include <perf/cpumap.h>\n#include \"bench.h\"\n#include \"futex.h\"\n\n#include <err.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/mman.h>\n\n \nstatic u_int32_t futex1 = 0;\n\nstatic pthread_t *worker;\nstatic bool done = false;\nstatic struct mutex thread_lock;\nstatic struct cond thread_parent, thread_worker;\nstatic struct stats waketime_stats, wakeup_stats;\nstatic unsigned int threads_starting;\nstatic int futex_flag = 0;\n\nstatic struct bench_futex_parameters params = {\n\t \n\t.nwakes  = 1,\n};\n\nstatic const struct option options[] = {\n\tOPT_UINTEGER('t', \"threads\", &params.nthreads, \"Specify amount of threads\"),\n\tOPT_UINTEGER('w', \"nwakes\",  &params.nwakes, \"Specify amount of threads to wake at once\"),\n\tOPT_BOOLEAN( 's', \"silent\",  &params.silent, \"Silent mode: do not display data/details\"),\n\tOPT_BOOLEAN( 'S', \"shared\",  &params.fshared, \"Use shared futexes instead of private ones\"),\n\tOPT_BOOLEAN( 'm', \"mlockall\", &params.mlockall, \"Lock all current and future memory\"),\n\n\tOPT_END()\n};\n\nstatic const char * const bench_futex_wake_usage[] = {\n\t\"perf bench futex wake <options>\",\n\tNULL\n};\n\nstatic void *workerfn(void *arg __maybe_unused)\n{\n\tmutex_lock(&thread_lock);\n\tthreads_starting--;\n\tif (!threads_starting)\n\t\tcond_signal(&thread_parent);\n\tcond_wait(&thread_worker, &thread_lock);\n\tmutex_unlock(&thread_lock);\n\n\twhile (1) {\n\t\tif (futex_wait(&futex1, 0, NULL, futex_flag) != EINTR)\n\t\t\tbreak;\n\t}\n\n\tpthread_exit(NULL);\n\treturn NULL;\n}\n\nstatic void print_summary(void)\n{\n\tdouble waketime_avg = avg_stats(&waketime_stats);\n\tdouble waketime_stddev = stddev_stats(&waketime_stats);\n\tunsigned int wakeup_avg = avg_stats(&wakeup_stats);\n\n\tprintf(\"Wokeup %d of %d threads in %.4f ms (+-%.2f%%)\\n\",\n\t       wakeup_avg,\n\t       params.nthreads,\n\t       waketime_avg / USEC_PER_MSEC,\n\t       rel_stddev_stats(waketime_stddev, waketime_avg));\n}\n\nstatic void block_threads(pthread_t *w, struct perf_cpu_map *cpu)\n{\n\tcpu_set_t *cpuset;\n\tunsigned int i;\n\tsize_t size;\n\tint nrcpus = perf_cpu_map__nr(cpu);\n\tthreads_starting = params.nthreads;\n\n\tcpuset = CPU_ALLOC(nrcpus);\n\tBUG_ON(!cpuset);\n\tsize = CPU_ALLOC_SIZE(nrcpus);\n\n\t \n\tfor (i = 0; i < params.nthreads; i++) {\n\t\tpthread_attr_t thread_attr;\n\n\t\tpthread_attr_init(&thread_attr);\n\t\tCPU_ZERO_S(size, cpuset);\n\t\tCPU_SET_S(perf_cpu_map__cpu(cpu, i % perf_cpu_map__nr(cpu)).cpu, size, cpuset);\n\n\t\tif (pthread_attr_setaffinity_np(&thread_attr, size, cpuset)) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_attr_setaffinity_np\");\n\t\t}\n\n\t\tif (pthread_create(&w[i], &thread_attr, workerfn, NULL)) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_create\");\n\t\t}\n\t\tpthread_attr_destroy(&thread_attr);\n\t}\n\tCPU_FREE(cpuset);\n}\n\nstatic void toggle_done(int sig __maybe_unused,\n\t\t\tsiginfo_t *info __maybe_unused,\n\t\t\tvoid *uc __maybe_unused)\n{\n\tdone = true;\n}\n\nint bench_futex_wake(int argc, const char **argv)\n{\n\tint ret = 0;\n\tunsigned int i, j;\n\tstruct sigaction act;\n\tstruct perf_cpu_map *cpu;\n\n\targc = parse_options(argc, argv, options, bench_futex_wake_usage, 0);\n\tif (argc) {\n\t\tusage_with_options(bench_futex_wake_usage, options);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcpu = perf_cpu_map__new(NULL);\n\tif (!cpu)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tmemset(&act, 0, sizeof(act));\n\tsigfillset(&act.sa_mask);\n\tact.sa_sigaction = toggle_done;\n\tsigaction(SIGINT, &act, NULL);\n\n\tif (params.mlockall) {\n\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE))\n\t\t\terr(EXIT_FAILURE, \"mlockall\");\n\t}\n\n\tif (!params.nthreads)\n\t\tparams.nthreads = perf_cpu_map__nr(cpu);\n\n\tworker = calloc(params.nthreads, sizeof(*worker));\n\tif (!worker)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tif (!params.fshared)\n\t\tfutex_flag = FUTEX_PRIVATE_FLAG;\n\n\tprintf(\"Run summary [PID %d]: blocking on %d threads (at [%s] futex %p), \"\n\t       \"waking up %d at a time.\\n\\n\",\n\t       getpid(), params.nthreads, params.fshared ? \"shared\":\"private\",\n\t       &futex1, params.nwakes);\n\n\tinit_stats(&wakeup_stats);\n\tinit_stats(&waketime_stats);\n\tmutex_init(&thread_lock);\n\tcond_init(&thread_parent);\n\tcond_init(&thread_worker);\n\n\tfor (j = 0; j < bench_repeat && !done; j++) {\n\t\tunsigned int nwoken = 0;\n\t\tstruct timeval start, end, runtime;\n\n\t\t \n\t\tblock_threads(worker, cpu);\n\n\t\t \n\t\tmutex_lock(&thread_lock);\n\t\twhile (threads_starting)\n\t\t\tcond_wait(&thread_parent, &thread_lock);\n\t\tcond_broadcast(&thread_worker);\n\t\tmutex_unlock(&thread_lock);\n\n\t\tusleep(100000);\n\n\t\t \n\t\tgettimeofday(&start, NULL);\n\t\twhile (nwoken != params.nthreads)\n\t\t\tnwoken += futex_wake(&futex1,\n\t\t\t\t\t     params.nwakes, futex_flag);\n\t\tgettimeofday(&end, NULL);\n\t\ttimersub(&end, &start, &runtime);\n\n\t\tupdate_stats(&wakeup_stats, nwoken);\n\t\tupdate_stats(&waketime_stats, runtime.tv_usec);\n\n\t\tif (!params.silent) {\n\t\t\tprintf(\"[Run %d]: Wokeup %d of %d threads in %.4f ms\\n\",\n\t\t\t       j + 1, nwoken, params.nthreads,\n\t\t\t       runtime.tv_usec / (double)USEC_PER_MSEC);\n\t\t}\n\n\t\tfor (i = 0; i < params.nthreads; i++) {\n\t\t\tret = pthread_join(worker[i], NULL);\n\t\t\tif (ret)\n\t\t\t\terr(EXIT_FAILURE, \"pthread_join\");\n\t\t}\n\n\t}\n\n\t \n\tcond_destroy(&thread_parent);\n\tcond_destroy(&thread_worker);\n\tmutex_destroy(&thread_lock);\n\n\tprint_summary();\n\n\tfree(worker);\n\tperf_cpu_map__put(cpu);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}