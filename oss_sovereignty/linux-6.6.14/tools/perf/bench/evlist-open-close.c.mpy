{
  "module_name": "evlist-open-close.c",
  "hash_id": "02b39d05bb77d5e0eb3d24451b11a36f26ed9422e4edc2a7bc3c0885d22ba1e5",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/evlist-open-close.c",
  "human_readable_source": "\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include \"bench.h\"\n#include \"../util/debug.h\"\n#include \"../util/stat.h\"\n#include \"../util/evlist.h\"\n#include \"../util/evsel.h\"\n#include \"../util/strbuf.h\"\n#include \"../util/record.h\"\n#include \"../util/parse-events.h\"\n#include \"internal/threadmap.h\"\n#include \"internal/cpumap.h\"\n#include <linux/perf_event.h>\n#include <linux/kernel.h>\n#include <linux/time64.h>\n#include <linux/string.h>\n#include <subcmd/parse-options.h>\n\n#define MMAP_FLUSH_DEFAULT 1\n\nstatic int iterations = 100;\nstatic int nr_events = 1;\nstatic const char *event_string = \"dummy\";\n\nstatic inline u64 timeval2usec(struct timeval *tv)\n{\n\treturn tv->tv_sec * USEC_PER_SEC + tv->tv_usec;\n}\n\nstatic struct record_opts opts = {\n\t.sample_time\t     = true,\n\t.mmap_pages\t     = UINT_MAX,\n\t.user_freq\t     = UINT_MAX,\n\t.user_interval\t     = ULLONG_MAX,\n\t.freq\t\t     = 4000,\n\t.target\t\t     = {\n\t\t.uses_mmap   = true,\n\t\t.default_per_cpu = true,\n\t},\n\t.mmap_flush          = MMAP_FLUSH_DEFAULT,\n\t.nr_threads_synthesize = 1,\n\t.ctl_fd              = -1,\n\t.ctl_fd_ack          = -1,\n};\n\nstatic const struct option options[] = {\n\tOPT_STRING('e', \"event\", &event_string, \"event\", \"event selector. use 'perf list' to list available events\"),\n\tOPT_INTEGER('n', \"nr-events\", &nr_events,\n\t\t     \"number of dummy events to create (default 1). If used with -e, it clones those events n times (1 = no change)\"),\n\tOPT_INTEGER('i', \"iterations\", &iterations, \"Number of iterations used to compute average (default=100)\"),\n\tOPT_BOOLEAN('a', \"all-cpus\", &opts.target.system_wide, \"system-wide collection from all CPUs\"),\n\tOPT_STRING('C', \"cpu\", &opts.target.cpu_list, \"cpu\", \"list of cpus where to open events\"),\n\tOPT_STRING('p', \"pid\", &opts.target.pid, \"pid\", \"record events on existing process id\"),\n\tOPT_STRING('t', \"tid\", &opts.target.tid, \"tid\", \"record events on existing thread id\"),\n\tOPT_STRING('u', \"uid\", &opts.target.uid_str, \"user\", \"user to profile\"),\n\tOPT_BOOLEAN(0, \"per-thread\", &opts.target.per_thread, \"use per-thread mmaps\"),\n\tOPT_END()\n};\n\nstatic const char *const bench_usage[] = {\n\t\"perf bench internals evlist-open-close <options>\",\n\tNULL\n};\n\nstatic int evlist__count_evsel_fds(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\tint cnt = 0;\n\n\tevlist__for_each_entry(evlist, evsel)\n\t\tcnt += evsel->core.threads->nr * perf_cpu_map__nr(evsel->core.cpus);\n\n\treturn cnt;\n}\n\nstatic struct evlist *bench__create_evlist(char *evstr)\n{\n\tstruct parse_events_error err;\n\tstruct evlist *evlist = evlist__new();\n\tint ret;\n\n\tif (!evlist) {\n\t\tpr_err(\"Not enough memory to create evlist\\n\");\n\t\treturn NULL;\n\t}\n\n\tparse_events_error__init(&err);\n\tret = parse_events(evlist, evstr, &err);\n\tif (ret) {\n\t\tparse_events_error__print(&err, evstr);\n\t\tparse_events_error__exit(&err);\n\t\tpr_err(\"Run 'perf list' for a list of valid events\\n\");\n\t\tret = 1;\n\t\tgoto out_delete_evlist;\n\t}\n\tparse_events_error__exit(&err);\n\tret = evlist__create_maps(evlist, &opts.target);\n\tif (ret < 0) {\n\t\tpr_err(\"Not enough memory to create thread/cpu maps\\n\");\n\t\tgoto out_delete_evlist;\n\t}\n\n\tevlist__config(evlist, &opts, NULL);\n\n\treturn evlist;\n\nout_delete_evlist:\n\tevlist__delete(evlist);\n\treturn NULL;\n}\n\nstatic int bench__do_evlist_open_close(struct evlist *evlist)\n{\n\tchar sbuf[STRERR_BUFSIZE];\n\tint err = evlist__open(evlist);\n\n\tif (err < 0) {\n\t\tpr_err(\"evlist__open: %s\\n\", str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\treturn err;\n\t}\n\n\terr = evlist__mmap(evlist, opts.mmap_pages);\n\tif (err < 0) {\n\t\tpr_err(\"evlist__mmap: %s\\n\", str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\treturn err;\n\t}\n\n\tevlist__enable(evlist);\n\tevlist__disable(evlist);\n\tevlist__munmap(evlist);\n\tevlist__close(evlist);\n\n\treturn 0;\n}\n\nstatic int bench_evlist_open_close__run(char *evstr)\n{\n\t\n\tstruct evlist *evlist = bench__create_evlist(evstr);\n\tdouble time_average, time_stddev;\n\tstruct timeval start, end, diff;\n\tstruct stats time_stats;\n\tu64 runtime_us;\n\tint i, err;\n\n\tif (!evlist)\n\t\treturn -ENOMEM;\n\n\tinit_stats(&time_stats);\n\n\tprintf(\"  Number of cpus:\\t%d\\n\", perf_cpu_map__nr(evlist->core.user_requested_cpus));\n\tprintf(\"  Number of threads:\\t%d\\n\", evlist->core.threads->nr);\n\tprintf(\"  Number of events:\\t%d (%d fds)\\n\",\n\t\tevlist->core.nr_entries, evlist__count_evsel_fds(evlist));\n\tprintf(\"  Number of iterations:\\t%d\\n\", iterations);\n\n\tevlist__delete(evlist);\n\n\tfor (i = 0; i < iterations; i++) {\n\t\tpr_debug(\"Started iteration %d\\n\", i);\n\t\tevlist = bench__create_evlist(evstr);\n\t\tif (!evlist)\n\t\t\treturn -ENOMEM;\n\n\t\tgettimeofday(&start, NULL);\n\t\terr = bench__do_evlist_open_close(evlist);\n\t\tif (err) {\n\t\t\tevlist__delete(evlist);\n\t\t\treturn err;\n\t\t}\n\n\t\tgettimeofday(&end, NULL);\n\t\ttimersub(&end, &start, &diff);\n\t\truntime_us = timeval2usec(&diff);\n\t\tupdate_stats(&time_stats, runtime_us);\n\n\t\tevlist__delete(evlist);\n\t\tpr_debug(\"Iteration %d took:\\t%\" PRIu64 \"us\\n\", i, runtime_us);\n\t}\n\n\ttime_average = avg_stats(&time_stats);\n\ttime_stddev = stddev_stats(&time_stats);\n\tprintf(\"  Average open-close took: %.3f usec (+- %.3f usec)\\n\", time_average, time_stddev);\n\n\treturn 0;\n}\n\nstatic char *bench__repeat_event_string(const char *evstr, int n)\n{\n\tchar sbuf[STRERR_BUFSIZE];\n\tstruct strbuf buf;\n\tint i, str_size = strlen(evstr),\n\t    final_size = str_size * n + n,\n\t    err = strbuf_init(&buf, final_size);\n\n\tif (err) {\n\t\tpr_err(\"strbuf_init: %s\\n\", str_error_r(err, sbuf, sizeof(sbuf)));\n\t\tgoto out_error;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\terr = strbuf_add(&buf, evstr, str_size);\n\t\tif (err) {\n\t\t\tpr_err(\"strbuf_add: %s\\n\", str_error_r(err, sbuf, sizeof(sbuf)));\n\t\t\tgoto out_error;\n\t\t}\n\n\t\terr = strbuf_addch(&buf, i == n-1 ? '\\0' : ',');\n\t\tif (err) {\n\t\t\tpr_err(\"strbuf_addch: %s\\n\", str_error_r(err, sbuf, sizeof(sbuf)));\n\t\t\tgoto out_error;\n\t\t}\n\t}\n\n\treturn strbuf_detach(&buf, NULL);\n\nout_error:\n\tstrbuf_release(&buf);\n\treturn NULL;\n}\n\n\nint bench_evlist_open_close(int argc, const char **argv)\n{\n\tchar *evstr, errbuf[BUFSIZ];\n\tint err;\n\n\targc = parse_options(argc, argv, options, bench_usage, 0);\n\tif (argc) {\n\t\tusage_with_options(bench_usage, options);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\terr = target__validate(&opts.target);\n\tif (err) {\n\t\ttarget__strerror(&opts.target, err, errbuf, sizeof(errbuf));\n\t\tpr_err(\"%s\\n\", errbuf);\n\t\tgoto out;\n\t}\n\n\terr = target__parse_uid(&opts.target);\n\tif (err) {\n\t\ttarget__strerror(&opts.target, err, errbuf, sizeof(errbuf));\n\t\tpr_err(\"%s\", errbuf);\n\t\tgoto out;\n\t}\n\n\t \n\topts.ignore_missing_thread = opts.target.uid != UINT_MAX || opts.target.pid;\n\n\tevstr = bench__repeat_event_string(event_string, nr_events);\n\tif (!evstr) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = bench_evlist_open_close__run(evstr);\n\n\tfree(evstr);\nout:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}