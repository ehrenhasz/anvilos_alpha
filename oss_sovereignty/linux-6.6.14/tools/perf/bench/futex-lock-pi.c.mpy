{
  "module_name": "futex-lock-pi.c",
  "hash_id": "a898c5e3425761fce87acd3fbe844e0e05276f60c874e7f75d8d0d1739426a6c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/futex-lock-pi.c",
  "human_readable_source": "\n \n\n \n#include <string.h>\n#include <pthread.h>\n\n#include <signal.h>\n#include \"../util/mutex.h\"\n#include \"../util/stat.h\"\n#include <subcmd/parse-options.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include <errno.h>\n#include <perf/cpumap.h>\n#include \"bench.h\"\n#include \"futex.h\"\n\n#include <err.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/mman.h>\n\nstruct worker {\n\tint tid;\n\tu_int32_t *futex;\n\tpthread_t thread;\n\tunsigned long ops;\n};\n\nstatic u_int32_t global_futex = 0;\nstatic struct worker *worker;\nstatic bool done = false;\nstatic int futex_flag = 0;\nstatic struct mutex thread_lock;\nstatic unsigned int threads_starting;\nstatic struct stats throughput_stats;\nstatic struct cond thread_parent, thread_worker;\n\nstatic struct bench_futex_parameters params = {\n\t.runtime  = 10,\n};\n\nstatic const struct option options[] = {\n\tOPT_UINTEGER('t', \"threads\", &params.nthreads, \"Specify amount of threads\"),\n\tOPT_UINTEGER('r', \"runtime\", &params.runtime, \"Specify runtime (in seconds)\"),\n\tOPT_BOOLEAN( 'M', \"multi\",   &params.multi, \"Use multiple futexes\"),\n\tOPT_BOOLEAN( 's', \"silent\",  &params.silent, \"Silent mode: do not display data/details\"),\n\tOPT_BOOLEAN( 'S', \"shared\",  &params.fshared, \"Use shared futexes instead of private ones\"),\n\tOPT_BOOLEAN( 'm', \"mlockall\", &params.mlockall, \"Lock all current and future memory\"),\n\tOPT_END()\n};\n\nstatic const char * const bench_futex_lock_pi_usage[] = {\n\t\"perf bench futex lock-pi <options>\",\n\tNULL\n};\n\nstatic void print_summary(void)\n{\n\tunsigned long avg = avg_stats(&throughput_stats);\n\tdouble stddev = stddev_stats(&throughput_stats);\n\n\tprintf(\"%sAveraged %ld operations/sec (+- %.2f%%), total secs = %d\\n\",\n\t       !params.silent ? \"\\n\" : \"\", avg, rel_stddev_stats(stddev, avg),\n\t       (int)bench__runtime.tv_sec);\n}\n\nstatic void toggle_done(int sig __maybe_unused,\n\t\t\tsiginfo_t *info __maybe_unused,\n\t\t\tvoid *uc __maybe_unused)\n{\n\t \n\tdone = true;\n\tgettimeofday(&bench__end, NULL);\n\ttimersub(&bench__end, &bench__start, &bench__runtime);\n}\n\nstatic void *workerfn(void *arg)\n{\n\tstruct worker *w = (struct worker *) arg;\n\tunsigned long ops = w->ops;\n\n\tmutex_lock(&thread_lock);\n\tthreads_starting--;\n\tif (!threads_starting)\n\t\tcond_signal(&thread_parent);\n\tcond_wait(&thread_worker, &thread_lock);\n\tmutex_unlock(&thread_lock);\n\n\tdo {\n\t\tint ret;\n\tagain:\n\t\tret = futex_lock_pi(w->futex, NULL, futex_flag);\n\n\t\tif (ret) {  \n\t\t\tif (!params.silent)\n\t\t\t\twarn(\"thread %d: Could not lock pi-lock for %p (%d)\",\n\t\t\t\t     w->tid, w->futex, ret);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\n\t\t\tgoto again;\n\t\t}\n\n\t\tusleep(1);\n\t\tret = futex_unlock_pi(w->futex, futex_flag);\n\t\tif (ret && !params.silent)\n\t\t\twarn(\"thread %d: Could not unlock pi-lock for %p (%d)\",\n\t\t\t     w->tid, w->futex, ret);\n\t\tops++;  \n\t}  while (!done);\n\n\tw->ops = ops;\n\treturn NULL;\n}\n\nstatic void create_threads(struct worker *w, struct perf_cpu_map *cpu)\n{\n\tcpu_set_t *cpuset;\n\tunsigned int i;\n\tint nrcpus =  perf_cpu_map__nr(cpu);\n\tsize_t size;\n\n\tthreads_starting = params.nthreads;\n\n\tcpuset = CPU_ALLOC(nrcpus);\n\tBUG_ON(!cpuset);\n\tsize = CPU_ALLOC_SIZE(nrcpus);\n\n\tfor (i = 0; i < params.nthreads; i++) {\n\t\tpthread_attr_t thread_attr;\n\n\t\tpthread_attr_init(&thread_attr);\n\t\tworker[i].tid = i;\n\n\t\tif (params.multi) {\n\t\t\tworker[i].futex = calloc(1, sizeof(u_int32_t));\n\t\t\tif (!worker[i].futex)\n\t\t\t\terr(EXIT_FAILURE, \"calloc\");\n\t\t} else\n\t\t\tworker[i].futex = &global_futex;\n\n\t\tCPU_ZERO_S(size, cpuset);\n\t\tCPU_SET_S(perf_cpu_map__cpu(cpu, i % perf_cpu_map__nr(cpu)).cpu, size, cpuset);\n\n\t\tif (pthread_attr_setaffinity_np(&thread_attr, size, cpuset)) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_attr_setaffinity_np\");\n\t\t}\n\n\t\tif (pthread_create(&w[i].thread, &thread_attr, workerfn, &worker[i])) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_create\");\n\t\t}\n\t\tpthread_attr_destroy(&thread_attr);\n\t}\n\tCPU_FREE(cpuset);\n}\n\nint bench_futex_lock_pi(int argc, const char **argv)\n{\n\tint ret = 0;\n\tunsigned int i;\n\tstruct sigaction act;\n\tstruct perf_cpu_map *cpu;\n\n\targc = parse_options(argc, argv, options, bench_futex_lock_pi_usage, 0);\n\tif (argc)\n\t\tgoto err;\n\n\tcpu = perf_cpu_map__new(NULL);\n\tif (!cpu)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tmemset(&act, 0, sizeof(act));\n\tsigfillset(&act.sa_mask);\n\tact.sa_sigaction = toggle_done;\n\tsigaction(SIGINT, &act, NULL);\n\n\tif (params.mlockall) {\n\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE))\n\t\t\terr(EXIT_FAILURE, \"mlockall\");\n\t}\n\n\tif (!params.nthreads)\n\t\tparams.nthreads = perf_cpu_map__nr(cpu);\n\n\tworker = calloc(params.nthreads, sizeof(*worker));\n\tif (!worker)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tif (!params.fshared)\n\t\tfutex_flag = FUTEX_PRIVATE_FLAG;\n\n\tprintf(\"Run summary [PID %d]: %d threads doing pi lock/unlock pairing for %d secs.\\n\\n\",\n\t       getpid(), params.nthreads, params.runtime);\n\n\tinit_stats(&throughput_stats);\n\tmutex_init(&thread_lock);\n\tcond_init(&thread_parent);\n\tcond_init(&thread_worker);\n\n\tthreads_starting = params.nthreads;\n\tgettimeofday(&bench__start, NULL);\n\n\tcreate_threads(worker, cpu);\n\n\tmutex_lock(&thread_lock);\n\twhile (threads_starting)\n\t\tcond_wait(&thread_parent, &thread_lock);\n\tcond_broadcast(&thread_worker);\n\tmutex_unlock(&thread_lock);\n\n\tsleep(params.runtime);\n\ttoggle_done(0, NULL, NULL);\n\n\tfor (i = 0; i < params.nthreads; i++) {\n\t\tret = pthread_join(worker[i].thread, NULL);\n\t\tif (ret)\n\t\t\terr(EXIT_FAILURE, \"pthread_join\");\n\t}\n\n\t \n\tcond_destroy(&thread_parent);\n\tcond_destroy(&thread_worker);\n\tmutex_destroy(&thread_lock);\n\n\tfor (i = 0; i < params.nthreads; i++) {\n\t\tunsigned long t = bench__runtime.tv_sec > 0 ?\n\t\t\tworker[i].ops / bench__runtime.tv_sec : 0;\n\n\t\tupdate_stats(&throughput_stats, t);\n\t\tif (!params.silent)\n\t\t\tprintf(\"[thread %3d] futex: %p [ %ld ops/sec ]\\n\",\n\t\t\t       worker[i].tid, worker[i].futex, t);\n\n\t\tif (params.multi)\n\t\t\tzfree(&worker[i].futex);\n\t}\n\n\tprint_summary();\n\n\tfree(worker);\n\tperf_cpu_map__put(cpu);\n\treturn ret;\nerr:\n\tusage_with_options(bench_futex_lock_pi_usage, options);\n\texit(EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}