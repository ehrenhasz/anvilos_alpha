{
  "module_name": "epoll-wait.c",
  "hash_id": "97af7f458f63dd60dd5fe3cea74bd3816d02c11af7925a2257b588bb0ae13d35",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/bench/epoll-wait.c",
  "human_readable_source": "\n#ifdef HAVE_EVENTFD_SUPPORT\n \n\n \n#include <string.h>\n#include <pthread.h>\n#include <unistd.h>\n\n#include <errno.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/epoll.h>\n#include <sys/eventfd.h>\n#include <sys/types.h>\n#include <perf/cpumap.h>\n\n#include \"../util/stat.h\"\n#include \"../util/mutex.h\"\n#include <subcmd/parse-options.h>\n#include \"bench.h\"\n\n#include <err.h>\n\n#define printinfo(fmt, arg...) \\\n\tdo { if (__verbose) { printf(fmt, ## arg); fflush(stdout); } } while (0)\n\nstatic unsigned int nthreads = 0;\nstatic unsigned int nsecs    = 8;\nstatic bool wdone, done, __verbose, randomize, nonblocking;\n\n \n\n \n#define EPOLL_MAXNESTS 4\n\nstatic int epollfd;\nstatic int *epollfdp;\nstatic bool noaffinity;\nstatic unsigned int nested = 0;\nstatic bool et;  \nstatic bool oneshot;\nstatic bool multiq;  \n\n \nstatic unsigned int nfds = 64;\n\nstatic struct mutex thread_lock;\nstatic unsigned int threads_starting;\nstatic struct stats throughput_stats;\nstatic struct cond thread_parent, thread_worker;\n\nstruct worker {\n\tint tid;\n\tint epollfd;  \n\tpthread_t thread;\n\tunsigned long ops;\n\tint *fdmap;\n};\n\nstatic const struct option options[] = {\n\t \n\tOPT_UINTEGER('t', \"threads\", &nthreads, \"Specify amount of threads\"),\n\tOPT_UINTEGER('r', \"runtime\", &nsecs, \"Specify runtime (in seconds)\"),\n\tOPT_UINTEGER('f', \"nfds\",    &nfds,  \"Specify amount of file descriptors to monitor for each thread\"),\n\tOPT_BOOLEAN( 'n', \"noaffinity\",  &noaffinity,   \"Disables CPU affinity\"),\n\tOPT_BOOLEAN('R', \"randomize\", &randomize,   \"Enable random write behaviour (default is lineal)\"),\n\tOPT_BOOLEAN( 'v', \"verbose\", &__verbose, \"Verbose mode\"),\n\n\t \n\tOPT_BOOLEAN( 'm', \"multiq\",  &multiq,   \"Use multiple epoll instances (one per thread)\"),\n\tOPT_BOOLEAN( 'B', \"nonblocking\", &nonblocking, \"Nonblocking epoll_wait(2) behaviour\"),\n\tOPT_UINTEGER( 'N', \"nested\",  &nested,   \"Nesting level epoll hierarchy (default is 0, no nesting)\"),\n\tOPT_BOOLEAN( 'S', \"oneshot\",  &oneshot,   \"Use EPOLLONESHOT semantics\"),\n\tOPT_BOOLEAN( 'E', \"edge\",  &et,   \"Use Edge-triggered interface (default is LT)\"),\n\n\tOPT_END()\n};\n\nstatic const char * const bench_epoll_wait_usage[] = {\n\t\"perf bench epoll wait <options>\",\n\tNULL\n};\n\n\n \nstatic void shuffle(void *array, size_t n, size_t size)\n{\n\tchar *carray = array;\n\tvoid *aux;\n\tsize_t i;\n\n\tif (n <= 1)\n\t\treturn;\n\n\taux = calloc(1, size);\n\tif (!aux)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tfor (i = 1; i < n; ++i) {\n\t\tsize_t j =   i + rand() / (RAND_MAX / (n - i) + 1);\n\t\tj *= size;\n\n\t\tmemcpy(aux, &carray[j], size);\n\t\tmemcpy(&carray[j], &carray[i*size], size);\n\t\tmemcpy(&carray[i*size], aux, size);\n\t}\n\n\tfree(aux);\n}\n\n\nstatic void *workerfn(void *arg)\n{\n\tint fd, ret, r;\n\tstruct worker *w = (struct worker *) arg;\n\tunsigned long ops = w->ops;\n\tstruct epoll_event ev;\n\tuint64_t val;\n\tint to = nonblocking? 0 : -1;\n\tint efd = multiq ? w->epollfd : epollfd;\n\n\tmutex_lock(&thread_lock);\n\tthreads_starting--;\n\tif (!threads_starting)\n\t\tcond_signal(&thread_parent);\n\tcond_wait(&thread_worker, &thread_lock);\n\tmutex_unlock(&thread_lock);\n\n\tdo {\n\t\t \n\t\tdo {\n\t\t\tret = epoll_wait(efd, &ev, 1, to);\n\t\t} while (ret < 0 && errno == EINTR);\n\t\tif (ret < 0)\n\t\t\terr(EXIT_FAILURE, \"epoll_wait\");\n\n\t\tfd = ev.data.fd;\n\n\t\tdo {\n\t\t\tr = read(fd, &val, sizeof(val));\n\t\t} while (!done && (r < 0 && errno == EAGAIN));\n\n\t\tif (et) {\n\t\t\tev.events = EPOLLIN | EPOLLET;\n\t\t\tret = epoll_ctl(efd, EPOLL_CTL_ADD, fd, &ev);\n\t\t}\n\n\t\tif (oneshot) {\n\t\t\t \n\t\t\tev.events |= EPOLLIN | EPOLLONESHOT;\n\t\t\tret = epoll_ctl(efd, EPOLL_CTL_MOD, fd, &ev);\n\t\t}\n\n\t\tops++;\n\t}  while (!done);\n\n\tif (multiq)\n\t\tclose(w->epollfd);\n\n\tw->ops = ops;\n\treturn NULL;\n}\n\nstatic void nest_epollfd(struct worker *w)\n{\n\tunsigned int i;\n\tstruct epoll_event ev;\n\tint efd = multiq ? w->epollfd : epollfd;\n\n\tif (nested > EPOLL_MAXNESTS)\n\t\tnested = EPOLL_MAXNESTS;\n\n\tepollfdp = calloc(nested, sizeof(*epollfdp));\n\tif (!epollfdp)\n\t\terr(EXIT_FAILURE, \"calloc\");\n\n\tfor (i = 0; i < nested; i++) {\n\t\tepollfdp[i] = epoll_create(1);\n\t\tif (epollfdp[i] < 0)\n\t\t\terr(EXIT_FAILURE, \"epoll_create\");\n\t}\n\n\tev.events = EPOLLHUP;  \n\tev.data.u64 = i;  \n\n\tfor (i = nested - 1; i; i--) {\n\t\tif (epoll_ctl(epollfdp[i - 1], EPOLL_CTL_ADD,\n\t\t\t      epollfdp[i], &ev) < 0)\n\t\t\terr(EXIT_FAILURE, \"epoll_ctl\");\n\t}\n\n\tif (epoll_ctl(efd, EPOLL_CTL_ADD, *epollfdp, &ev) < 0)\n\t\terr(EXIT_FAILURE, \"epoll_ctl\");\n}\n\nstatic void toggle_done(int sig __maybe_unused,\n\t\t\tsiginfo_t *info __maybe_unused,\n\t\t\tvoid *uc __maybe_unused)\n{\n\t \n\tdone = true;\n\tgettimeofday(&bench__end, NULL);\n\ttimersub(&bench__end, &bench__start, &bench__runtime);\n}\n\nstatic void print_summary(void)\n{\n\tunsigned long avg = avg_stats(&throughput_stats);\n\tdouble stddev = stddev_stats(&throughput_stats);\n\n\tprintf(\"\\nAveraged %ld operations/sec (+- %.2f%%), total secs = %d\\n\",\n\t       avg, rel_stddev_stats(stddev, avg),\n\t       (int)bench__runtime.tv_sec);\n}\n\nstatic int do_threads(struct worker *worker, struct perf_cpu_map *cpu)\n{\n\tpthread_attr_t thread_attr, *attrp = NULL;\n\tcpu_set_t *cpuset;\n\tunsigned int i, j;\n\tint ret = 0, events = EPOLLIN;\n\tint nrcpus;\n\tsize_t size;\n\n\tif (oneshot)\n\t\tevents |= EPOLLONESHOT;\n\tif (et)\n\t\tevents |= EPOLLET;\n\n\tprintinfo(\"starting worker/consumer %sthreads%s\\n\",\n\t\t  noaffinity ?  \"\":\"CPU affinity \",\n\t\t  nonblocking ? \" (nonblocking)\":\"\");\n\tif (!noaffinity)\n\t\tpthread_attr_init(&thread_attr);\n\n\tnrcpus = perf_cpu_map__nr(cpu);\n\tcpuset = CPU_ALLOC(nrcpus);\n\tBUG_ON(!cpuset);\n\tsize = CPU_ALLOC_SIZE(nrcpus);\n\n\tfor (i = 0; i < nthreads; i++) {\n\t\tstruct worker *w = &worker[i];\n\n\t\tif (multiq) {\n\t\t\tw->epollfd = epoll_create(1);\n\t\t\tif (w->epollfd < 0)\n\t\t\t\terr(EXIT_FAILURE, \"epoll_create\");\n\n\t\t\tif (nested)\n\t\t\t\tnest_epollfd(w);\n\t\t}\n\n\t\tw->tid = i;\n\t\tw->fdmap = calloc(nfds, sizeof(int));\n\t\tif (!w->fdmap)\n\t\t\treturn 1;\n\n\t\tfor (j = 0; j < nfds; j++) {\n\t\t\tint efd = multiq ? w->epollfd : epollfd;\n\t\t\tstruct epoll_event ev;\n\n\t\t\tw->fdmap[j] = eventfd(0, EFD_NONBLOCK);\n\t\t\tif (w->fdmap[j] < 0)\n\t\t\t\terr(EXIT_FAILURE, \"eventfd\");\n\n\t\t\tev.data.fd = w->fdmap[j];\n\t\t\tev.events = events;\n\n\t\t\tret = epoll_ctl(efd, EPOLL_CTL_ADD,\n\t\t\t\t\tw->fdmap[j], &ev);\n\t\t\tif (ret < 0)\n\t\t\t\terr(EXIT_FAILURE, \"epoll_ctl\");\n\t\t}\n\n\t\tif (!noaffinity) {\n\t\t\tCPU_ZERO_S(size, cpuset);\n\t\t\tCPU_SET_S(perf_cpu_map__cpu(cpu, i % perf_cpu_map__nr(cpu)).cpu,\n\t\t\t\t\tsize, cpuset);\n\n\t\t\tret = pthread_attr_setaffinity_np(&thread_attr, size, cpuset);\n\t\t\tif (ret) {\n\t\t\t\tCPU_FREE(cpuset);\n\t\t\t\terr(EXIT_FAILURE, \"pthread_attr_setaffinity_np\");\n\t\t\t}\n\n\t\t\tattrp = &thread_attr;\n\t\t}\n\n\t\tret = pthread_create(&w->thread, attrp, workerfn,\n\t\t\t\t     (void *)(struct worker *) w);\n\t\tif (ret) {\n\t\t\tCPU_FREE(cpuset);\n\t\t\terr(EXIT_FAILURE, \"pthread_create\");\n\t\t}\n\t}\n\n\tCPU_FREE(cpuset);\n\tif (!noaffinity)\n\t\tpthread_attr_destroy(&thread_attr);\n\n\treturn ret;\n}\n\nstatic void *writerfn(void *p)\n{\n\tstruct worker *worker = p;\n\tsize_t i, j, iter;\n\tconst uint64_t val = 1;\n\tssize_t sz;\n\tstruct timespec ts = { .tv_sec = 0,\n\t\t\t       .tv_nsec = 500 };\n\n\tprintinfo(\"starting writer-thread: doing %s writes ...\\n\",\n\t\t  randomize? \"random\":\"lineal\");\n\n\tfor (iter = 0; !wdone; iter++) {\n\t\tif (randomize) {\n\t\t\tshuffle((void *)worker, nthreads, sizeof(*worker));\n\t\t}\n\n\t\tfor (i = 0; i < nthreads; i++) {\n\t\t\tstruct worker *w = &worker[i];\n\n\t\t\tif (randomize) {\n\t\t\t\tshuffle((void *)w->fdmap, nfds, sizeof(int));\n\t\t\t}\n\n\t\t\tfor (j = 0; j < nfds; j++) {\n\t\t\t\tdo {\n\t\t\t\t\tsz = write(w->fdmap[j], &val, sizeof(val));\n\t\t\t\t} while (!wdone && (sz < 0 && errno == EAGAIN));\n\t\t\t}\n\t\t}\n\n\t\tnanosleep(&ts, NULL);\n\t}\n\n\tprintinfo(\"exiting writer-thread (total full-loops: %zd)\\n\", iter);\n\treturn NULL;\n}\n\nstatic int cmpworker(const void *p1, const void *p2)\n{\n\n\tstruct worker *w1 = (struct worker *) p1;\n\tstruct worker *w2 = (struct worker *) p2;\n\treturn w1->tid > w2->tid;\n}\n\nint bench_epoll_wait(int argc, const char **argv)\n{\n\tint ret = 0;\n\tstruct sigaction act;\n\tunsigned int i;\n\tstruct worker *worker = NULL;\n\tstruct perf_cpu_map *cpu;\n\tpthread_t wthread;\n\tstruct rlimit rl, prevrl;\n\n\targc = parse_options(argc, argv, options, bench_epoll_wait_usage, 0);\n\tif (argc) {\n\t\tusage_with_options(bench_epoll_wait_usage, options);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemset(&act, 0, sizeof(act));\n\tsigfillset(&act.sa_mask);\n\tact.sa_sigaction = toggle_done;\n\tsigaction(SIGINT, &act, NULL);\n\n\tcpu = perf_cpu_map__new(NULL);\n\tif (!cpu)\n\t\tgoto errmem;\n\n\t \n\tif (!multiq) {\n\t\tepollfd = epoll_create(1);\n\t\tif (epollfd < 0)\n\t\t\terr(EXIT_FAILURE, \"epoll_create\");\n\n\t\t \n\t\tif (nested)\n\t\t\tnest_epollfd(NULL);\n\t}\n\n\tprintinfo(\"Using %s queue model\\n\", multiq ? \"multi\" : \"single\");\n\tprintinfo(\"Nesting level(s): %d\\n\", nested);\n\n\t \n\tif (!nthreads)\n\t\tnthreads = perf_cpu_map__nr(cpu) - 1;\n\n\tworker = calloc(nthreads, sizeof(*worker));\n\tif (!worker) {\n\t\tgoto errmem;\n\t}\n\n\tif (getrlimit(RLIMIT_NOFILE, &prevrl))\n\t\terr(EXIT_FAILURE, \"getrlimit\");\n\trl.rlim_cur = rl.rlim_max = nfds * nthreads * 2 + 50;\n\tprintinfo(\"Setting RLIMIT_NOFILE rlimit from %\" PRIu64 \" to: %\" PRIu64 \"\\n\",\n\t\t  (uint64_t)prevrl.rlim_max, (uint64_t)rl.rlim_max);\n\tif (setrlimit(RLIMIT_NOFILE, &rl) < 0)\n\t\terr(EXIT_FAILURE, \"setrlimit\");\n\n\tprintf(\"Run summary [PID %d]: %d threads monitoring%s on \"\n\t       \"%d file-descriptors for %d secs.\\n\\n\",\n\t       getpid(), nthreads, oneshot ? \" (EPOLLONESHOT semantics)\": \"\", nfds, nsecs);\n\n\tinit_stats(&throughput_stats);\n\tmutex_init(&thread_lock);\n\tcond_init(&thread_parent);\n\tcond_init(&thread_worker);\n\n\tthreads_starting = nthreads;\n\n\tgettimeofday(&bench__start, NULL);\n\n\tdo_threads(worker, cpu);\n\n\tmutex_lock(&thread_lock);\n\twhile (threads_starting)\n\t\tcond_wait(&thread_parent, &thread_lock);\n\tcond_broadcast(&thread_worker);\n\tmutex_unlock(&thread_lock);\n\n\t \n\tret = pthread_create(&wthread, NULL, writerfn,\n\t\t\t     (void *)(struct worker *) worker);\n\tif (ret)\n\t\terr(EXIT_FAILURE, \"pthread_create\");\n\n\tsleep(nsecs);\n\ttoggle_done(0, NULL, NULL);\n\tprintinfo(\"main thread: toggling done\\n\");\n\n\tsleep(1);  \n\twdone = true;\n\tret = pthread_join(wthread, NULL);\n\tif (ret)\n\t\terr(EXIT_FAILURE, \"pthread_join\");\n\n\t \n\tcond_destroy(&thread_parent);\n\tcond_destroy(&thread_worker);\n\tmutex_destroy(&thread_lock);\n\n\t \n\tif (randomize)\n\t\tqsort(worker, nthreads, sizeof(struct worker), cmpworker);\n\n\tfor (i = 0; i < nthreads; i++) {\n\t\tunsigned long t = bench__runtime.tv_sec > 0 ?\n\t\t\tworker[i].ops / bench__runtime.tv_sec : 0;\n\n\t\tupdate_stats(&throughput_stats, t);\n\n\t\tif (nfds == 1)\n\t\t\tprintf(\"[thread %2d] fdmap: %p [ %04ld ops/sec ]\\n\",\n\t\t\t       worker[i].tid, &worker[i].fdmap[0], t);\n\t\telse\n\t\t\tprintf(\"[thread %2d] fdmap: %p ... %p [ %04ld ops/sec ]\\n\",\n\t\t\t       worker[i].tid, &worker[i].fdmap[0],\n\t\t\t       &worker[i].fdmap[nfds-1], t);\n\t}\n\n\tprint_summary();\n\n\tclose(epollfd);\n\tperf_cpu_map__put(cpu);\n\tfor (i = 0; i < nthreads; i++)\n\t\tfree(worker[i].fdmap);\n\n\tfree(worker);\n\treturn ret;\nerrmem:\n\terr(EXIT_FAILURE, \"calloc\");\n}\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}