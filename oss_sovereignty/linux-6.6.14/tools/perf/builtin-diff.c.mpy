{
  "module_name": "builtin-diff.c",
  "hash_id": "0cc43c5c9cb39e84fafe26f34b70969776f4ebcab60df55181e63c0fbdc289a3",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-diff.c",
  "human_readable_source": "\n \n#include \"builtin.h\"\n\n#include \"util/debug.h\"\n#include \"util/event.h\"\n#include \"util/hist.h\"\n#include \"util/evsel.h\"\n#include \"util/evlist.h\"\n#include \"util/session.h\"\n#include \"util/tool.h\"\n#include \"util/sort.h\"\n#include \"util/srcline.h\"\n#include \"util/symbol.h\"\n#include \"util/data.h\"\n#include \"util/config.h\"\n#include \"util/time-utils.h\"\n#include \"util/annotate.h\"\n#include \"util/map.h\"\n#include \"util/spark.h\"\n#include \"util/block-info.h\"\n#include \"util/stream.h\"\n#include \"util/util.h\"\n#include <linux/err.h>\n#include <linux/zalloc.h>\n#include <subcmd/pager.h>\n#include <subcmd/parse-options.h>\n\n#include <errno.h>\n#include <inttypes.h>\n#include <stdlib.h>\n#include <math.h>\n\nstruct perf_diff {\n\tstruct perf_tool\t\t tool;\n\tconst char\t\t\t*time_str;\n\tstruct perf_time_interval\t*ptime_range;\n\tint\t\t\t\t range_size;\n\tint\t\t\t\t range_num;\n\tbool\t\t\t\t has_br_stack;\n\tbool\t\t\t\t stream;\n};\n\n \nenum {\n\tPERF_HPP_DIFF__BASELINE,\n\tPERF_HPP_DIFF__PERIOD,\n\tPERF_HPP_DIFF__PERIOD_BASELINE,\n\tPERF_HPP_DIFF__DELTA,\n\tPERF_HPP_DIFF__RATIO,\n\tPERF_HPP_DIFF__WEIGHTED_DIFF,\n\tPERF_HPP_DIFF__FORMULA,\n\tPERF_HPP_DIFF__DELTA_ABS,\n\tPERF_HPP_DIFF__CYCLES,\n\tPERF_HPP_DIFF__CYCLES_HIST,\n\n\tPERF_HPP_DIFF__MAX_INDEX\n};\n\nstruct diff_hpp_fmt {\n\tstruct perf_hpp_fmt\t fmt;\n\tint\t\t\t idx;\n\tchar\t\t\t*header;\n\tint\t\t\t header_width;\n};\n\nstruct data__file {\n\tstruct perf_session\t*session;\n\tstruct perf_data\t data;\n\tint\t\t\t idx;\n\tstruct hists\t\t*hists;\n\tstruct evlist_streams\t*evlist_streams;\n\tstruct diff_hpp_fmt\t fmt[PERF_HPP_DIFF__MAX_INDEX];\n};\n\nstatic struct data__file *data__files;\nstatic int data__files_cnt;\n\n#define data__for_each_file_start(i, d, s)\t\\\n\tfor (i = s, d = &data__files[s];\t\\\n\t     i < data__files_cnt;\t\t\\\n\t     i++, d = &data__files[i])\n\n#define data__for_each_file(i, d) data__for_each_file_start(i, d, 0)\n#define data__for_each_file_new(i, d) data__for_each_file_start(i, d, 1)\n\nstatic bool force;\nstatic bool show_period;\nstatic bool show_formula;\nstatic bool show_baseline_only;\nstatic bool cycles_hist;\nstatic unsigned int sort_compute = 1;\n\nstatic s64 compute_wdiff_w1;\nstatic s64 compute_wdiff_w2;\n\nstatic const char\t\t*cpu_list;\nstatic DECLARE_BITMAP(cpu_bitmap, MAX_NR_CPUS);\n\nenum {\n\tCOMPUTE_DELTA,\n\tCOMPUTE_RATIO,\n\tCOMPUTE_WEIGHTED_DIFF,\n\tCOMPUTE_DELTA_ABS,\n\tCOMPUTE_CYCLES,\n\tCOMPUTE_MAX,\n\tCOMPUTE_STREAM,\t \n};\n\nconst char *compute_names[COMPUTE_MAX] = {\n\t[COMPUTE_DELTA] = \"delta\",\n\t[COMPUTE_DELTA_ABS] = \"delta-abs\",\n\t[COMPUTE_RATIO] = \"ratio\",\n\t[COMPUTE_WEIGHTED_DIFF] = \"wdiff\",\n\t[COMPUTE_CYCLES] = \"cycles\",\n};\n\nstatic int compute = COMPUTE_DELTA_ABS;\n\nstatic int compute_2_hpp[COMPUTE_MAX] = {\n\t[COMPUTE_DELTA]\t\t= PERF_HPP_DIFF__DELTA,\n\t[COMPUTE_DELTA_ABS]\t= PERF_HPP_DIFF__DELTA_ABS,\n\t[COMPUTE_RATIO]\t\t= PERF_HPP_DIFF__RATIO,\n\t[COMPUTE_WEIGHTED_DIFF]\t= PERF_HPP_DIFF__WEIGHTED_DIFF,\n\t[COMPUTE_CYCLES]\t= PERF_HPP_DIFF__CYCLES,\n};\n\n#define MAX_COL_WIDTH 70\n\nstatic struct header_column {\n\tconst char *name;\n\tint width;\n} columns[PERF_HPP_DIFF__MAX_INDEX] = {\n\t[PERF_HPP_DIFF__BASELINE] = {\n\t\t.name  = \"Baseline\",\n\t},\n\t[PERF_HPP_DIFF__PERIOD] = {\n\t\t.name  = \"Period\",\n\t\t.width = 14,\n\t},\n\t[PERF_HPP_DIFF__PERIOD_BASELINE] = {\n\t\t.name  = \"Base period\",\n\t\t.width = 14,\n\t},\n\t[PERF_HPP_DIFF__DELTA] = {\n\t\t.name  = \"Delta\",\n\t\t.width = 7,\n\t},\n\t[PERF_HPP_DIFF__DELTA_ABS] = {\n\t\t.name  = \"Delta Abs\",\n\t\t.width = 7,\n\t},\n\t[PERF_HPP_DIFF__RATIO] = {\n\t\t.name  = \"Ratio\",\n\t\t.width = 14,\n\t},\n\t[PERF_HPP_DIFF__WEIGHTED_DIFF] = {\n\t\t.name  = \"Weighted diff\",\n\t\t.width = 14,\n\t},\n\t[PERF_HPP_DIFF__FORMULA] = {\n\t\t.name  = \"Formula\",\n\t\t.width = MAX_COL_WIDTH,\n\t},\n\t[PERF_HPP_DIFF__CYCLES] = {\n\t\t.name  = \"[Program Block Range] Cycles Diff\",\n\t\t.width = 70,\n\t},\n\t[PERF_HPP_DIFF__CYCLES_HIST] = {\n\t\t.name  = \"stddev/Hist\",\n\t\t.width = NUM_SPARKS + 9,\n\t}\n};\n\nstatic int setup_compute_opt_wdiff(char *opt)\n{\n\tchar *w1_str = opt;\n\tchar *w2_str;\n\n\tint ret = -EINVAL;\n\n\tif (!opt)\n\t\tgoto out;\n\n\tw2_str = strchr(opt, ',');\n\tif (!w2_str)\n\t\tgoto out;\n\n\t*w2_str++ = 0x0;\n\tif (!*w2_str)\n\t\tgoto out;\n\n\tcompute_wdiff_w1 = strtol(w1_str, NULL, 10);\n\tcompute_wdiff_w2 = strtol(w2_str, NULL, 10);\n\n\tif (!compute_wdiff_w1 || !compute_wdiff_w2)\n\t\tgoto out;\n\n\tpr_debug(\"compute wdiff w1(%\" PRId64 \") w2(%\" PRId64 \")\\n\",\n\t\t  compute_wdiff_w1, compute_wdiff_w2);\n\n\tret = 0;\n\n out:\n\tif (ret)\n\t\tpr_err(\"Failed: wrong weight data, use 'wdiff:w1,w2'\\n\");\n\n\treturn ret;\n}\n\nstatic int setup_compute_opt(char *opt)\n{\n\tif (compute == COMPUTE_WEIGHTED_DIFF)\n\t\treturn setup_compute_opt_wdiff(opt);\n\n\tif (opt) {\n\t\tpr_err(\"Failed: extra option specified '%s'\", opt);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_compute(const struct option *opt, const char *str,\n\t\t\t int unset __maybe_unused)\n{\n\tint *cp = (int *) opt->value;\n\tchar *cstr = (char *) str;\n\tchar buf[50];\n\tunsigned i;\n\tchar *option;\n\n\tif (!str) {\n\t\t*cp = COMPUTE_DELTA;\n\t\treturn 0;\n\t}\n\n\toption = strchr(str, ':');\n\tif (option) {\n\t\tunsigned len = option++ - str;\n\n\t\t \n\n\t\t \n\t\tif (len >= sizeof(buf))\n\t\t\treturn -EINVAL;\n\n\t\tstrncpy(buf, str, len);\n\t\tbuf[len] = 0x0;\n\t\tcstr = buf;\n\t}\n\n\tfor (i = 0; i < COMPUTE_MAX; i++)\n\t\tif (!strcmp(cstr, compute_names[i])) {\n\t\t\t*cp = i;\n\t\t\treturn setup_compute_opt(option);\n\t\t}\n\n\tpr_err(\"Failed: '%s' is not computation method \"\n\t       \"(use 'delta','ratio' or 'wdiff')\\n\", str);\n\treturn -EINVAL;\n}\n\nstatic double period_percent(struct hist_entry *he, u64 period)\n{\n\tu64 total = hists__total_period(he->hists);\n\n\treturn (period * 100.0) / total;\n}\n\nstatic double compute_delta(struct hist_entry *he, struct hist_entry *pair)\n{\n\tdouble old_percent = period_percent(he, he->stat.period);\n\tdouble new_percent = period_percent(pair, pair->stat.period);\n\n\tpair->diff.period_ratio_delta = new_percent - old_percent;\n\tpair->diff.computed = true;\n\treturn pair->diff.period_ratio_delta;\n}\n\nstatic double compute_ratio(struct hist_entry *he, struct hist_entry *pair)\n{\n\tdouble old_period = he->stat.period ?: 1;\n\tdouble new_period = pair->stat.period;\n\n\tpair->diff.computed = true;\n\tpair->diff.period_ratio = new_period / old_period;\n\treturn pair->diff.period_ratio;\n}\n\nstatic s64 compute_wdiff(struct hist_entry *he, struct hist_entry *pair)\n{\n\tu64 old_period = he->stat.period;\n\tu64 new_period = pair->stat.period;\n\n\tpair->diff.computed = true;\n\tpair->diff.wdiff = new_period * compute_wdiff_w2 -\n\t\t\t   old_period * compute_wdiff_w1;\n\n\treturn pair->diff.wdiff;\n}\n\nstatic int formula_delta(struct hist_entry *he, struct hist_entry *pair,\n\t\t\t char *buf, size_t size)\n{\n\tu64 he_total = he->hists->stats.total_period;\n\tu64 pair_total = pair->hists->stats.total_period;\n\n\tif (symbol_conf.filter_relative) {\n\t\the_total = he->hists->stats.total_non_filtered_period;\n\t\tpair_total = pair->hists->stats.total_non_filtered_period;\n\t}\n\treturn scnprintf(buf, size,\n\t\t\t \"(%\" PRIu64 \" * 100 / %\" PRIu64 \") - \"\n\t\t\t \"(%\" PRIu64 \" * 100 / %\" PRIu64 \")\",\n\t\t\t pair->stat.period, pair_total,\n\t\t\t he->stat.period, he_total);\n}\n\nstatic int formula_ratio(struct hist_entry *he, struct hist_entry *pair,\n\t\t\t char *buf, size_t size)\n{\n\tdouble old_period = he->stat.period;\n\tdouble new_period = pair->stat.period;\n\n\treturn scnprintf(buf, size, \"%.0F / %.0F\", new_period, old_period);\n}\n\nstatic int formula_wdiff(struct hist_entry *he, struct hist_entry *pair,\n\t\t\t char *buf, size_t size)\n{\n\tu64 old_period = he->stat.period;\n\tu64 new_period = pair->stat.period;\n\n\treturn scnprintf(buf, size,\n\t\t  \"(%\" PRIu64 \" * \" \"%\" PRId64 \") - (%\" PRIu64 \" * \" \"%\" PRId64 \")\",\n\t\t  new_period, compute_wdiff_w2, old_period, compute_wdiff_w1);\n}\n\nstatic int formula_fprintf(struct hist_entry *he, struct hist_entry *pair,\n\t\t\t   char *buf, size_t size)\n{\n\tswitch (compute) {\n\tcase COMPUTE_DELTA:\n\tcase COMPUTE_DELTA_ABS:\n\t\treturn formula_delta(he, pair, buf, size);\n\tcase COMPUTE_RATIO:\n\t\treturn formula_ratio(he, pair, buf, size);\n\tcase COMPUTE_WEIGHTED_DIFF:\n\t\treturn formula_wdiff(he, pair, buf, size);\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n\n\treturn -1;\n}\n\nstatic void *block_hist_zalloc(size_t size)\n{\n\tstruct block_hist *bh;\n\n\tbh = zalloc(size + sizeof(*bh));\n\tif (!bh)\n\t\treturn NULL;\n\n\treturn &bh->he;\n}\n\nstatic void block_hist_free(void *he)\n{\n\tstruct block_hist *bh;\n\n\tbh = container_of(he, struct block_hist, he);\n\thists__delete_entries(&bh->block_hists);\n\tfree(bh);\n}\n\nstruct hist_entry_ops block_hist_ops = {\n\t.new    = block_hist_zalloc,\n\t.free   = block_hist_free,\n};\n\nstatic int diff__process_sample_event(struct perf_tool *tool,\n\t\t\t\t      union perf_event *event,\n\t\t\t\t      struct perf_sample *sample,\n\t\t\t\t      struct evsel *evsel,\n\t\t\t\t      struct machine *machine)\n{\n\tstruct perf_diff *pdiff = container_of(tool, struct perf_diff, tool);\n\tstruct addr_location al;\n\tstruct hists *hists = evsel__hists(evsel);\n\tstruct hist_entry_iter iter = {\n\t\t.evsel\t= evsel,\n\t\t.sample\t= sample,\n\t\t.ops\t= &hist_iter_normal,\n\t};\n\tint ret = -1;\n\n\tif (perf_time__ranges_skip_sample(pdiff->ptime_range, pdiff->range_num,\n\t\t\t\t\t  sample->time)) {\n\t\treturn 0;\n\t}\n\n\taddr_location__init(&al);\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tpr_warning(\"problem processing %d event, skipping it.\\n\",\n\t\t\t   event->header.type);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (cpu_list && !test_bit(sample->cpu, cpu_bitmap)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tswitch (compute) {\n\tcase COMPUTE_CYCLES:\n\t\tif (!hists__add_entry_ops(hists, &block_hist_ops, &al, NULL,\n\t\t\t\t\t  NULL, NULL, NULL, sample, true)) {\n\t\t\tpr_warning(\"problem incrementing symbol period, \"\n\t\t\t\t   \"skipping event\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\thist__account_cycles(sample->branch_stack, &al, sample, false,\n\t\t\t\t     NULL);\n\t\tbreak;\n\n\tcase COMPUTE_STREAM:\n\t\tif (hist_entry_iter__add(&iter, &al, PERF_MAX_STACK_DEPTH,\n\t\t\t\t\t NULL)) {\n\t\t\tpr_debug(\"problem adding hist entry, skipping event\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (!hists__add_entry(hists, &al, NULL, NULL, NULL, NULL, sample,\n\t\t\t\t      true)) {\n\t\t\tpr_warning(\"problem incrementing symbol period, \"\n\t\t\t\t   \"skipping event\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\thists->stats.total_period += sample->period;\n\tif (!al.filtered)\n\t\thists->stats.total_non_filtered_period += sample->period;\n\tret = 0;\nout:\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic struct perf_diff pdiff = {\n\t.tool = {\n\t\t.sample\t= diff__process_sample_event,\n\t\t.mmap\t= perf_event__process_mmap,\n\t\t.mmap2\t= perf_event__process_mmap2,\n\t\t.comm\t= perf_event__process_comm,\n\t\t.exit\t= perf_event__process_exit,\n\t\t.fork\t= perf_event__process_fork,\n\t\t.lost\t= perf_event__process_lost,\n\t\t.namespaces = perf_event__process_namespaces,\n\t\t.cgroup = perf_event__process_cgroup,\n\t\t.ordered_events = true,\n\t\t.ordering_requires_timestamps = true,\n\t},\n};\n\nstatic struct evsel *evsel_match(struct evsel *evsel,\n\t\t\t\t      struct evlist *evlist)\n{\n\tstruct evsel *e;\n\n\tevlist__for_each_entry(evlist, e) {\n\t\tif (evsel__match2(evsel, e))\n\t\t\treturn e;\n\t}\n\n\treturn NULL;\n}\n\nstatic void evlist__collapse_resort(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tstruct hists *hists = evsel__hists(evsel);\n\n\t\thists__collapse_resort(hists, NULL);\n\t}\n}\n\nstatic struct data__file *fmt_to_data_file(struct perf_hpp_fmt *fmt)\n{\n\tstruct diff_hpp_fmt *dfmt = container_of(fmt, struct diff_hpp_fmt, fmt);\n\tvoid *ptr = dfmt - dfmt->idx;\n\tstruct data__file *d = container_of(ptr, struct data__file, fmt);\n\n\treturn d;\n}\n\nstatic struct hist_entry*\nget_pair_data(struct hist_entry *he, struct data__file *d)\n{\n\tif (hist_entry__has_pairs(he)) {\n\t\tstruct hist_entry *pair;\n\n\t\tlist_for_each_entry(pair, &he->pairs.head, pairs.node)\n\t\t\tif (pair->hists == d->hists)\n\t\t\t\treturn pair;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct hist_entry*\nget_pair_fmt(struct hist_entry *he, struct diff_hpp_fmt *dfmt)\n{\n\tstruct data__file *d = fmt_to_data_file(&dfmt->fmt);\n\n\treturn get_pair_data(he, d);\n}\n\nstatic void hists__baseline_only(struct hists *hists)\n{\n\tstruct rb_root_cached *root;\n\tstruct rb_node *next;\n\n\tif (hists__has(hists, need_collapse))\n\t\troot = &hists->entries_collapsed;\n\telse\n\t\troot = hists->entries_in;\n\n\tnext = rb_first_cached(root);\n\twhile (next != NULL) {\n\t\tstruct hist_entry *he = rb_entry(next, struct hist_entry, rb_node_in);\n\n\t\tnext = rb_next(&he->rb_node_in);\n\t\tif (!hist_entry__next_pair(he)) {\n\t\t\trb_erase_cached(&he->rb_node_in, root);\n\t\t\thist_entry__delete(he);\n\t\t}\n\t}\n}\n\nstatic int64_t block_cycles_diff_cmp(struct hist_entry *left,\n\t\t\t\t     struct hist_entry *right)\n{\n\tbool pairs_left  = hist_entry__has_pairs(left);\n\tbool pairs_right = hist_entry__has_pairs(right);\n\ts64 l, r;\n\n\tif (!pairs_left && !pairs_right)\n\t\treturn 0;\n\n\tl = llabs(left->diff.cycles);\n\tr = llabs(right->diff.cycles);\n\treturn r - l;\n}\n\nstatic int64_t block_sort(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t  struct hist_entry *left, struct hist_entry *right)\n{\n\treturn block_cycles_diff_cmp(right, left);\n}\n\nstatic void init_block_hist(struct block_hist *bh)\n{\n\t__hists__init(&bh->block_hists, &bh->block_list);\n\tperf_hpp_list__init(&bh->block_list);\n\n\tINIT_LIST_HEAD(&bh->block_fmt.list);\n\tINIT_LIST_HEAD(&bh->block_fmt.sort_list);\n\tbh->block_fmt.cmp = block_info__cmp;\n\tbh->block_fmt.sort = block_sort;\n\tperf_hpp_list__register_sort_field(&bh->block_list,\n\t\t\t\t\t   &bh->block_fmt);\n\tbh->valid = true;\n}\n\nstatic struct hist_entry *get_block_pair(struct hist_entry *he,\n\t\t\t\t\t struct hists *hists_pair)\n{\n\tstruct rb_root_cached *root = hists_pair->entries_in;\n\tstruct rb_node *next = rb_first_cached(root);\n\tint64_t cmp;\n\n\twhile (next != NULL) {\n\t\tstruct hist_entry *he_pair = rb_entry(next, struct hist_entry,\n\t\t\t\t\t\t      rb_node_in);\n\n\t\tnext = rb_next(&he_pair->rb_node_in);\n\n\t\tcmp = __block_info__cmp(he_pair, he);\n\t\tif (!cmp)\n\t\t\treturn he_pair;\n\t}\n\n\treturn NULL;\n}\n\nstatic void init_spark_values(unsigned long *svals, int num)\n{\n\tfor (int i = 0; i < num; i++)\n\t\tsvals[i] = 0;\n}\n\nstatic void update_spark_value(unsigned long *svals, int num,\n\t\t\t       struct stats *stats, u64 val)\n{\n\tint n = stats->n;\n\n\tif (n < num)\n\t\tsvals[n] = val;\n}\n\nstatic void compute_cycles_diff(struct hist_entry *he,\n\t\t\t\tstruct hist_entry *pair)\n{\n\tpair->diff.computed = true;\n\tif (pair->block_info->num && he->block_info->num) {\n\t\tpair->diff.cycles =\n\t\t\tpair->block_info->cycles_aggr / pair->block_info->num_aggr -\n\t\t\the->block_info->cycles_aggr / he->block_info->num_aggr;\n\n\t\tif (!cycles_hist)\n\t\t\treturn;\n\n\t\tinit_stats(&pair->diff.stats);\n\t\tinit_spark_values(pair->diff.svals, NUM_SPARKS);\n\n\t\tfor (int i = 0; i < pair->block_info->num; i++) {\n\t\t\tu64 val;\n\n\t\t\tif (i >= he->block_info->num || i >= NUM_SPARKS)\n\t\t\t\tbreak;\n\n\t\t\tval = llabs(pair->block_info->cycles_spark[i] -\n\t\t\t\t     he->block_info->cycles_spark[i]);\n\n\t\t\tupdate_spark_value(pair->diff.svals, NUM_SPARKS,\n\t\t\t\t\t   &pair->diff.stats, val);\n\t\t\tupdate_stats(&pair->diff.stats, val);\n\t\t}\n\t}\n}\n\nstatic void block_hists_match(struct hists *hists_base,\n\t\t\t      struct hists *hists_pair)\n{\n\tstruct rb_root_cached *root = hists_base->entries_in;\n\tstruct rb_node *next = rb_first_cached(root);\n\n\twhile (next != NULL) {\n\t\tstruct hist_entry *he = rb_entry(next, struct hist_entry,\n\t\t\t\t\t\t rb_node_in);\n\t\tstruct hist_entry *pair = get_block_pair(he, hists_pair);\n\n\t\tnext = rb_next(&he->rb_node_in);\n\n\t\tif (pair) {\n\t\t\thist_entry__add_pair(pair, he);\n\t\t\tcompute_cycles_diff(he, pair);\n\t\t}\n\t}\n}\n\nstatic void hists__precompute(struct hists *hists)\n{\n\tstruct rb_root_cached *root;\n\tstruct rb_node *next;\n\n\tif (hists__has(hists, need_collapse))\n\t\troot = &hists->entries_collapsed;\n\telse\n\t\troot = hists->entries_in;\n\n\tnext = rb_first_cached(root);\n\twhile (next != NULL) {\n\t\tstruct block_hist *bh, *pair_bh;\n\t\tstruct hist_entry *he, *pair;\n\t\tstruct data__file *d;\n\t\tint i;\n\n\t\the   = rb_entry(next, struct hist_entry, rb_node_in);\n\t\tnext = rb_next(&he->rb_node_in);\n\n\t\tif (compute == COMPUTE_CYCLES) {\n\t\t\tbh = container_of(he, struct block_hist, he);\n\t\t\tinit_block_hist(bh);\n\t\t\tblock_info__process_sym(he, bh, NULL, 0);\n\t\t}\n\n\t\tdata__for_each_file_new(i, d) {\n\t\t\tpair = get_pair_data(he, d);\n\t\t\tif (!pair)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (compute) {\n\t\t\tcase COMPUTE_DELTA:\n\t\t\tcase COMPUTE_DELTA_ABS:\n\t\t\t\tcompute_delta(he, pair);\n\t\t\t\tbreak;\n\t\t\tcase COMPUTE_RATIO:\n\t\t\t\tcompute_ratio(he, pair);\n\t\t\t\tbreak;\n\t\t\tcase COMPUTE_WEIGHTED_DIFF:\n\t\t\t\tcompute_wdiff(he, pair);\n\t\t\t\tbreak;\n\t\t\tcase COMPUTE_CYCLES:\n\t\t\t\tpair_bh = container_of(pair, struct block_hist,\n\t\t\t\t\t\t       he);\n\t\t\t\tinit_block_hist(pair_bh);\n\t\t\t\tblock_info__process_sym(pair, pair_bh, NULL, 0);\n\n\t\t\t\tbh = container_of(he, struct block_hist, he);\n\n\t\t\t\tif (bh->valid && pair_bh->valid) {\n\t\t\t\t\tblock_hists_match(&bh->block_hists,\n\t\t\t\t\t\t\t  &pair_bh->block_hists);\n\t\t\t\t\thists__output_resort(&pair_bh->block_hists,\n\t\t\t\t\t\t\t     NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int64_t cmp_doubles(double l, double r)\n{\n\tif (l > r)\n\t\treturn -1;\n\telse if (l < r)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int64_t\n__hist_entry__cmp_compute(struct hist_entry *left, struct hist_entry *right,\n\t\t\tint c)\n{\n\tswitch (c) {\n\tcase COMPUTE_DELTA:\n\t{\n\t\tdouble l = left->diff.period_ratio_delta;\n\t\tdouble r = right->diff.period_ratio_delta;\n\n\t\treturn cmp_doubles(l, r);\n\t}\n\tcase COMPUTE_DELTA_ABS:\n\t{\n\t\tdouble l = fabs(left->diff.period_ratio_delta);\n\t\tdouble r = fabs(right->diff.period_ratio_delta);\n\n\t\treturn cmp_doubles(l, r);\n\t}\n\tcase COMPUTE_RATIO:\n\t{\n\t\tdouble l = left->diff.period_ratio;\n\t\tdouble r = right->diff.period_ratio;\n\n\t\treturn cmp_doubles(l, r);\n\t}\n\tcase COMPUTE_WEIGHTED_DIFF:\n\t{\n\t\ts64 l = left->diff.wdiff;\n\t\ts64 r = right->diff.wdiff;\n\n\t\treturn r - l;\n\t}\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int64_t\nhist_entry__cmp_compute(struct hist_entry *left, struct hist_entry *right,\n\t\t\tint c, int sort_idx)\n{\n\tbool pairs_left  = hist_entry__has_pairs(left);\n\tbool pairs_right = hist_entry__has_pairs(right);\n\tstruct hist_entry *p_right, *p_left;\n\n\tif (!pairs_left && !pairs_right)\n\t\treturn 0;\n\n\tif (!pairs_left || !pairs_right)\n\t\treturn pairs_left ? -1 : 1;\n\n\tp_left  = get_pair_data(left,  &data__files[sort_idx]);\n\tp_right = get_pair_data(right, &data__files[sort_idx]);\n\n\tif (!p_left && !p_right)\n\t\treturn 0;\n\n\tif (!p_left || !p_right)\n\t\treturn p_left ? -1 : 1;\n\n\t \n\treturn __hist_entry__cmp_compute(p_left, p_right, c);\n}\n\nstatic int64_t\nhist_entry__cmp_compute_idx(struct hist_entry *left, struct hist_entry *right,\n\t\t\t    int c, int sort_idx)\n{\n\tstruct hist_entry *p_right, *p_left;\n\n\tp_left  = get_pair_data(left,  &data__files[sort_idx]);\n\tp_right = get_pair_data(right, &data__files[sort_idx]);\n\n\tif (!p_left && !p_right)\n\t\treturn 0;\n\n\tif (!p_left || !p_right)\n\t\treturn p_left ? -1 : 1;\n\n\tif (c != COMPUTE_DELTA && c != COMPUTE_DELTA_ABS) {\n\t\t \n\t\tif (left->dummy && right->dummy)\n\t\t\treturn 0;\n\n\t\tif (left->dummy || right->dummy)\n\t\t\treturn left->dummy ? 1 : -1;\n\t}\n\n\treturn __hist_entry__cmp_compute(p_left, p_right, c);\n}\n\nstatic int64_t\nhist_entry__cmp_nop(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t    struct hist_entry *left __maybe_unused,\n\t\t    struct hist_entry *right __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int64_t\nhist_entry__cmp_baseline(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t struct hist_entry *left, struct hist_entry *right)\n{\n\tif (left->stat.period == right->stat.period)\n\t\treturn 0;\n\treturn left->stat.period > right->stat.period ? 1 : -1;\n}\n\nstatic int64_t\nhist_entry__cmp_delta(struct perf_hpp_fmt *fmt,\n\t\t      struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct data__file *d = fmt_to_data_file(fmt);\n\n\treturn hist_entry__cmp_compute(right, left, COMPUTE_DELTA, d->idx);\n}\n\nstatic int64_t\nhist_entry__cmp_delta_abs(struct perf_hpp_fmt *fmt,\n\t\t      struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct data__file *d = fmt_to_data_file(fmt);\n\n\treturn hist_entry__cmp_compute(right, left, COMPUTE_DELTA_ABS, d->idx);\n}\n\nstatic int64_t\nhist_entry__cmp_ratio(struct perf_hpp_fmt *fmt,\n\t\t      struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct data__file *d = fmt_to_data_file(fmt);\n\n\treturn hist_entry__cmp_compute(right, left, COMPUTE_RATIO, d->idx);\n}\n\nstatic int64_t\nhist_entry__cmp_wdiff(struct perf_hpp_fmt *fmt,\n\t\t      struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct data__file *d = fmt_to_data_file(fmt);\n\n\treturn hist_entry__cmp_compute(right, left, COMPUTE_WEIGHTED_DIFF, d->idx);\n}\n\nstatic int64_t\nhist_entry__cmp_delta_idx(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t  struct hist_entry *left, struct hist_entry *right)\n{\n\treturn hist_entry__cmp_compute_idx(right, left, COMPUTE_DELTA,\n\t\t\t\t\t   sort_compute);\n}\n\nstatic int64_t\nhist_entry__cmp_delta_abs_idx(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t      struct hist_entry *left, struct hist_entry *right)\n{\n\treturn hist_entry__cmp_compute_idx(right, left, COMPUTE_DELTA_ABS,\n\t\t\t\t\t   sort_compute);\n}\n\nstatic int64_t\nhist_entry__cmp_ratio_idx(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t  struct hist_entry *left, struct hist_entry *right)\n{\n\treturn hist_entry__cmp_compute_idx(right, left, COMPUTE_RATIO,\n\t\t\t\t\t   sort_compute);\n}\n\nstatic int64_t\nhist_entry__cmp_wdiff_idx(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t  struct hist_entry *left, struct hist_entry *right)\n{\n\treturn hist_entry__cmp_compute_idx(right, left, COMPUTE_WEIGHTED_DIFF,\n\t\t\t\t\t   sort_compute);\n}\n\nstatic void hists__process(struct hists *hists)\n{\n\tif (show_baseline_only)\n\t\thists__baseline_only(hists);\n\n\thists__precompute(hists);\n\thists__output_resort(hists, NULL);\n\n\tif (compute == COMPUTE_CYCLES)\n\t\tsymbol_conf.report_block = true;\n\n\thists__fprintf(hists, !quiet, 0, 0, 0, stdout,\n\t\t       !symbol_conf.use_callchain);\n}\n\nstatic void data__fprintf(void)\n{\n\tstruct data__file *d;\n\tint i;\n\n\tfprintf(stdout, \"# Data files:\\n\");\n\n\tdata__for_each_file(i, d)\n\t\tfprintf(stdout, \"#  [%d] %s %s\\n\",\n\t\t\td->idx, d->data.path,\n\t\t\t!d->idx ? \"(Baseline)\" : \"\");\n\n\tfprintf(stdout, \"#\\n\");\n}\n\nstatic void data_process(void)\n{\n\tstruct evlist *evlist_base = data__files[0].session->evlist;\n\tstruct evsel *evsel_base;\n\tbool first = true;\n\n\tevlist__for_each_entry(evlist_base, evsel_base) {\n\t\tstruct hists *hists_base = evsel__hists(evsel_base);\n\t\tstruct data__file *d;\n\t\tint i;\n\n\t\tdata__for_each_file_new(i, d) {\n\t\t\tstruct evlist *evlist = d->session->evlist;\n\t\t\tstruct evsel *evsel;\n\t\t\tstruct hists *hists;\n\n\t\t\tevsel = evsel_match(evsel_base, evlist);\n\t\t\tif (!evsel)\n\t\t\t\tcontinue;\n\n\t\t\thists = evsel__hists(evsel);\n\t\t\td->hists = hists;\n\n\t\t\thists__match(hists_base, hists);\n\n\t\t\tif (!show_baseline_only)\n\t\t\t\thists__link(hists_base, hists);\n\t\t}\n\n\t\tif (!quiet) {\n\t\t\tfprintf(stdout, \"%s# Event '%s'\\n#\\n\", first ? \"\" : \"\\n\",\n\t\t\t\tevsel__name(evsel_base));\n\t\t}\n\n\t\tfirst = false;\n\n\t\tif (verbose > 0 || ((data__files_cnt > 2) && !quiet))\n\t\t\tdata__fprintf();\n\n\t\t \n\t\tevsel__reset_sample_bit(evsel_base, CALLCHAIN);\n\n\t\thists__process(hists_base);\n\t}\n}\n\nstatic int process_base_stream(struct data__file *data_base,\n\t\t\t       struct data__file *data_pair,\n\t\t\t       const char *title __maybe_unused)\n{\n\tstruct evlist *evlist_base = data_base->session->evlist;\n\tstruct evlist *evlist_pair = data_pair->session->evlist;\n\tstruct evsel *evsel_base, *evsel_pair;\n\tstruct evsel_streams *es_base, *es_pair;\n\n\tevlist__for_each_entry(evlist_base, evsel_base) {\n\t\tevsel_pair = evsel_match(evsel_base, evlist_pair);\n\t\tif (!evsel_pair)\n\t\t\tcontinue;\n\n\t\tes_base = evsel_streams__entry(data_base->evlist_streams,\n\t\t\t\t\t       evsel_base->core.idx);\n\t\tif (!es_base)\n\t\t\treturn -1;\n\n\t\tes_pair = evsel_streams__entry(data_pair->evlist_streams,\n\t\t\t\t\t       evsel_pair->core.idx);\n\t\tif (!es_pair)\n\t\t\treturn -1;\n\n\t\tevsel_streams__match(es_base, es_pair);\n\t\tevsel_streams__report(es_base, es_pair);\n\t}\n\n\treturn 0;\n}\n\nstatic void stream_process(void)\n{\n\t \n\tprocess_base_stream(&data__files[0], &data__files[1],\n\t\t\t    \"# Output based on old perf data:\\n#\\n\");\n}\n\nstatic void data__free(struct data__file *d)\n{\n\tint col;\n\n\tif (d->evlist_streams)\n\t\tevlist_streams__delete(d->evlist_streams);\n\n\tfor (col = 0; col < PERF_HPP_DIFF__MAX_INDEX; col++) {\n\t\tstruct diff_hpp_fmt *fmt = &d->fmt[col];\n\n\t\tzfree(&fmt->header);\n\t}\n}\n\nstatic int abstime_str_dup(char **pstr)\n{\n\tchar *str = NULL;\n\n\tif (pdiff.time_str && strchr(pdiff.time_str, ':')) {\n\t\tstr = strdup(pdiff.time_str);\n\t\tif (!str)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*pstr = str;\n\treturn 0;\n}\n\nstatic int parse_absolute_time(struct data__file *d, char **pstr)\n{\n\tchar *p = *pstr;\n\tint ret;\n\n\t \n\tp = strchr(*pstr, ':');\n\tif (p) {\n\t\tif (p == *pstr) {\n\t\t\tpr_err(\"Invalid time string\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*p = 0;\n\t\tp++;\n\t\tif (*p == 0) {\n\t\t\tpr_err(\"Invalid time string\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = perf_time__parse_for_ranges(*pstr, d->session,\n\t\t\t\t\t  &pdiff.ptime_range,\n\t\t\t\t\t  &pdiff.range_size,\n\t\t\t\t\t  &pdiff.range_num);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!p || *p == 0)\n\t\t*pstr = NULL;\n\telse\n\t\t*pstr = p;\n\n\treturn ret;\n}\n\nstatic int parse_percent_time(struct data__file *d)\n{\n\tint ret;\n\n\tret = perf_time__parse_for_ranges(pdiff.time_str, d->session,\n\t\t\t\t\t  &pdiff.ptime_range,\n\t\t\t\t\t  &pdiff.range_size,\n\t\t\t\t\t  &pdiff.range_num);\n\treturn ret;\n}\n\nstatic int parse_time_str(struct data__file *d, char *abstime_ostr,\n\t\t\t   char **pabstime_tmp)\n{\n\tint ret = 0;\n\n\tif (abstime_ostr)\n\t\tret = parse_absolute_time(d, pabstime_tmp);\n\telse if (pdiff.time_str)\n\t\tret = parse_percent_time(d);\n\n\treturn ret;\n}\n\nstatic int check_file_brstack(void)\n{\n\tstruct data__file *d;\n\tbool has_br_stack;\n\tint i;\n\n\tdata__for_each_file(i, d) {\n\t\td->session = perf_session__new(&d->data, &pdiff.tool);\n\t\tif (IS_ERR(d->session)) {\n\t\t\tpr_err(\"Failed to open %s\\n\", d->data.path);\n\t\t\treturn PTR_ERR(d->session);\n\t\t}\n\n\t\thas_br_stack = perf_header__has_feat(&d->session->header,\n\t\t\t\t\t\t     HEADER_BRANCH_STACK);\n\t\tperf_session__delete(d->session);\n\t\tif (!has_br_stack)\n\t\t\treturn 0;\n\t}\n\n\t \n\tpdiff.has_br_stack = true;\n\treturn 0;\n}\n\nstatic int __cmd_diff(void)\n{\n\tstruct data__file *d;\n\tint ret, i;\n\tchar *abstime_ostr, *abstime_tmp;\n\n\tret = abstime_str_dup(&abstime_ostr);\n\tif (ret)\n\t\treturn ret;\n\n\tabstime_tmp = abstime_ostr;\n\tret = -EINVAL;\n\n\tdata__for_each_file(i, d) {\n\t\td->session = perf_session__new(&d->data, &pdiff.tool);\n\t\tif (IS_ERR(d->session)) {\n\t\t\tret = PTR_ERR(d->session);\n\t\t\tpr_err(\"Failed to open %s\\n\", d->data.path);\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\tif (pdiff.time_str) {\n\t\t\tret = parse_time_str(d, abstime_ostr, &abstime_tmp);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_delete;\n\t\t}\n\n\t\tif (cpu_list) {\n\t\t\tret = perf_session__cpu_bitmap(d->session, cpu_list,\n\t\t\t\t\t\t       cpu_bitmap);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_delete;\n\t\t}\n\n\t\tret = perf_session__process_events(d->session);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to process %s\\n\", d->data.path);\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\tevlist__collapse_resort(d->session->evlist);\n\n\t\tif (pdiff.ptime_range)\n\t\t\tzfree(&pdiff.ptime_range);\n\n\t\tif (compute == COMPUTE_STREAM) {\n\t\t\td->evlist_streams = evlist__create_streams(\n\t\t\t\t\t\td->session->evlist, 5);\n\t\t\tif (!d->evlist_streams) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_delete;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (compute == COMPUTE_STREAM)\n\t\tstream_process();\n\telse\n\t\tdata_process();\n\n out_delete:\n\tdata__for_each_file(i, d) {\n\t\tif (!IS_ERR(d->session))\n\t\t\tperf_session__delete(d->session);\n\t\tdata__free(d);\n\t}\n\n\tfree(data__files);\n\n\tif (pdiff.ptime_range)\n\t\tzfree(&pdiff.ptime_range);\n\n\tif (abstime_ostr)\n\t\tfree(abstime_ostr);\n\n\treturn ret;\n}\n\nstatic const char * const diff_usage[] = {\n\t\"perf diff [<options>] [old_file] [new_file]\",\n\tNULL,\n};\n\nstatic const struct option options[] = {\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t    \"be more verbose (show symbol address, etc)\"),\n\tOPT_BOOLEAN('q', \"quiet\", &quiet, \"Do not show any warnings or messages\"),\n\tOPT_BOOLEAN('b', \"baseline-only\", &show_baseline_only,\n\t\t    \"Show only items with match in baseline\"),\n\tOPT_CALLBACK('c', \"compute\", &compute,\n\t\t     \"delta,delta-abs,ratio,wdiff:w1,w2 (default delta-abs),cycles\",\n\t\t     \"Entries differential computation selection\",\n\t\t     setup_compute),\n\tOPT_BOOLEAN('p', \"period\", &show_period,\n\t\t    \"Show period values.\"),\n\tOPT_BOOLEAN('F', \"formula\", &show_formula,\n\t\t    \"Show formula.\"),\n\tOPT_BOOLEAN(0, \"cycles-hist\", &cycles_hist,\n\t\t    \"Show cycles histogram and standard deviation \"\n\t\t    \"- WARNING: use only with -c cycles.\"),\n\tOPT_BOOLEAN('D', \"dump-raw-trace\", &dump_trace,\n\t\t    \"dump raw trace in ASCII\"),\n\tOPT_BOOLEAN('f', \"force\", &force, \"don't complain, do it\"),\n\tOPT_STRING(0, \"kallsyms\", &symbol_conf.kallsyms_name,\n\t\t   \"file\", \"kallsyms pathname\"),\n\tOPT_BOOLEAN('m', \"modules\", &symbol_conf.use_modules,\n\t\t    \"load module symbols - WARNING: use only with -k and LIVE kernel\"),\n\tOPT_STRING('d', \"dsos\", &symbol_conf.dso_list_str, \"dso[,dso...]\",\n\t\t   \"only consider symbols in these dsos\"),\n\tOPT_STRING('C', \"comms\", &symbol_conf.comm_list_str, \"comm[,comm...]\",\n\t\t   \"only consider symbols in these comms\"),\n\tOPT_STRING('S', \"symbols\", &symbol_conf.sym_list_str, \"symbol[,symbol...]\",\n\t\t   \"only consider these symbols\"),\n\tOPT_STRING('s', \"sort\", &sort_order, \"key[,key2...]\",\n\t\t   \"sort by key(s): pid, comm, dso, symbol, parent, cpu, srcline, ...\"\n\t\t   \" Please refer the man page for the complete list.\"),\n\tOPT_STRING_NOEMPTY('t', \"field-separator\", &symbol_conf.field_sep, \"separator\",\n\t\t   \"separator for columns, no spaces will be added between \"\n\t\t   \"columns '.' is reserved.\"),\n\tOPT_CALLBACK(0, \"symfs\", NULL, \"directory\",\n\t\t     \"Look for files with symbols relative to this directory\",\n\t\t     symbol__config_symfs),\n\tOPT_UINTEGER('o', \"order\", &sort_compute, \"Specify compute sorting.\"),\n\tOPT_CALLBACK(0, \"percentage\", NULL, \"relative|absolute\",\n\t\t     \"How to display percentage of filtered entries\", parse_filter_percentage),\n\tOPT_STRING(0, \"time\", &pdiff.time_str, \"str\",\n\t\t   \"Time span (time percent or absolute timestamp)\"),\n\tOPT_STRING(0, \"cpu\", &cpu_list, \"cpu\", \"list of cpus to profile\"),\n\tOPT_STRING(0, \"pid\", &symbol_conf.pid_list_str, \"pid[,pid...]\",\n\t\t   \"only consider symbols in these pids\"),\n\tOPT_STRING(0, \"tid\", &symbol_conf.tid_list_str, \"tid[,tid...]\",\n\t\t   \"only consider symbols in these tids\"),\n\tOPT_BOOLEAN(0, \"stream\", &pdiff.stream,\n\t\t    \"Enable hot streams comparison.\"),\n\tOPT_END()\n};\n\nstatic double baseline_percent(struct hist_entry *he)\n{\n\tu64 total = hists__total_period(he->hists);\n\n\treturn 100.0 * he->stat.period / total;\n}\n\nstatic int hpp__color_baseline(struct perf_hpp_fmt *fmt,\n\t\t\t       struct perf_hpp *hpp, struct hist_entry *he)\n{\n\tstruct diff_hpp_fmt *dfmt =\n\t\tcontainer_of(fmt, struct diff_hpp_fmt, fmt);\n\tdouble percent = baseline_percent(he);\n\tchar pfmt[20] = \" \";\n\n\tif (!he->dummy) {\n\t\tscnprintf(pfmt, 20, \"%%%d.2f%%%%\", dfmt->header_width - 1);\n\t\treturn percent_color_snprintf(hpp->buf, hpp->size,\n\t\t\t\t\t      pfmt, percent);\n\t} else\n\t\treturn scnprintf(hpp->buf, hpp->size, \"%*s\",\n\t\t\t\t dfmt->header_width, pfmt);\n}\n\nstatic int hpp__entry_baseline(struct hist_entry *he, char *buf, size_t size)\n{\n\tdouble percent = baseline_percent(he);\n\tconst char *fmt = symbol_conf.field_sep ? \"%.2f\" : \"%6.2f%%\";\n\tint ret = 0;\n\n\tif (!he->dummy)\n\t\tret = scnprintf(buf, size, fmt, percent);\n\n\treturn ret;\n}\n\nstatic int cycles_printf(struct hist_entry *he, struct hist_entry *pair,\n\t\t\t struct perf_hpp *hpp, int width)\n{\n\tstruct block_hist *bh = container_of(he, struct block_hist, he);\n\tstruct block_hist *bh_pair = container_of(pair, struct block_hist, he);\n\tstruct hist_entry *block_he;\n\tstruct block_info *bi;\n\tchar buf[128];\n\tchar *start_line, *end_line;\n\n\tblock_he = hists__get_entry(&bh_pair->block_hists, bh->block_idx);\n\tif (!block_he) {\n\t\thpp->skip = true;\n\t\treturn 0;\n\t}\n\n\t \n\tsymbol_conf.disable_add2line_warn = true;\n\n\tbi = block_he->block_info;\n\n\tstart_line = map__srcline(he->ms.map, bi->sym->start + bi->start,\n\t\t\t\t  he->ms.sym);\n\n\tend_line = map__srcline(he->ms.map, bi->sym->start + bi->end,\n\t\t\t\the->ms.sym);\n\n\tif (start_line != SRCLINE_UNKNOWN &&\n\t    end_line != SRCLINE_UNKNOWN) {\n\t\tscnprintf(buf, sizeof(buf), \"[%s -> %s] %4ld\",\n\t\t\t  start_line, end_line, block_he->diff.cycles);\n\t} else {\n\t\tscnprintf(buf, sizeof(buf), \"[%7lx -> %7lx] %4ld\",\n\t\t\t  bi->start, bi->end, block_he->diff.cycles);\n\t}\n\n\tzfree_srcline(&start_line);\n\tzfree_srcline(&end_line);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, buf);\n}\n\nstatic int __hpp__color_compare(struct perf_hpp_fmt *fmt,\n\t\t\t\tstruct perf_hpp *hpp, struct hist_entry *he,\n\t\t\t\tint comparison_method)\n{\n\tstruct diff_hpp_fmt *dfmt =\n\t\tcontainer_of(fmt, struct diff_hpp_fmt, fmt);\n\tstruct hist_entry *pair = get_pair_fmt(he, dfmt);\n\tdouble diff;\n\ts64 wdiff;\n\tchar pfmt[20] = \" \";\n\n\tif (!pair) {\n\t\tif (comparison_method == COMPUTE_CYCLES) {\n\t\t\tstruct block_hist *bh;\n\n\t\t\tbh = container_of(he, struct block_hist, he);\n\t\t\tif (bh->block_idx)\n\t\t\t\thpp->skip = true;\n\t\t}\n\n\t\tgoto no_print;\n\t}\n\n\tswitch (comparison_method) {\n\tcase COMPUTE_DELTA:\n\t\tif (pair->diff.computed)\n\t\t\tdiff = pair->diff.period_ratio_delta;\n\t\telse\n\t\t\tdiff = compute_delta(he, pair);\n\n\t\tscnprintf(pfmt, 20, \"%%%+d.2f%%%%\", dfmt->header_width - 1);\n\t\treturn percent_color_snprintf(hpp->buf, hpp->size,\n\t\t\t\t\tpfmt, diff);\n\tcase COMPUTE_RATIO:\n\t\tif (he->dummy)\n\t\t\tgoto dummy_print;\n\t\tif (pair->diff.computed)\n\t\t\tdiff = pair->diff.period_ratio;\n\t\telse\n\t\t\tdiff = compute_ratio(he, pair);\n\n\t\tscnprintf(pfmt, 20, \"%%%d.6f\", dfmt->header_width);\n\t\treturn value_color_snprintf(hpp->buf, hpp->size,\n\t\t\t\t\tpfmt, diff);\n\tcase COMPUTE_WEIGHTED_DIFF:\n\t\tif (he->dummy)\n\t\t\tgoto dummy_print;\n\t\tif (pair->diff.computed)\n\t\t\twdiff = pair->diff.wdiff;\n\t\telse\n\t\t\twdiff = compute_wdiff(he, pair);\n\n\t\tscnprintf(pfmt, 20, \"%%14ld\", dfmt->header_width);\n\t\treturn color_snprintf(hpp->buf, hpp->size,\n\t\t\t\tget_percent_color(wdiff),\n\t\t\t\tpfmt, wdiff);\n\tcase COMPUTE_CYCLES:\n\t\treturn cycles_printf(he, pair, hpp, dfmt->header_width);\n\tdefault:\n\t\tBUG_ON(1);\n\t}\ndummy_print:\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\",\n\t\t\tdfmt->header_width, \"N/A\");\nno_print:\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\",\n\t\t\tdfmt->header_width, pfmt);\n}\n\nstatic int hpp__color_delta(struct perf_hpp_fmt *fmt,\n\t\t\tstruct perf_hpp *hpp, struct hist_entry *he)\n{\n\treturn __hpp__color_compare(fmt, hpp, he, COMPUTE_DELTA);\n}\n\nstatic int hpp__color_ratio(struct perf_hpp_fmt *fmt,\n\t\t\tstruct perf_hpp *hpp, struct hist_entry *he)\n{\n\treturn __hpp__color_compare(fmt, hpp, he, COMPUTE_RATIO);\n}\n\nstatic int hpp__color_wdiff(struct perf_hpp_fmt *fmt,\n\t\t\tstruct perf_hpp *hpp, struct hist_entry *he)\n{\n\treturn __hpp__color_compare(fmt, hpp, he, COMPUTE_WEIGHTED_DIFF);\n}\n\nstatic int hpp__color_cycles(struct perf_hpp_fmt *fmt,\n\t\t\t     struct perf_hpp *hpp, struct hist_entry *he)\n{\n\treturn __hpp__color_compare(fmt, hpp, he, COMPUTE_CYCLES);\n}\n\nstatic int all_zero(unsigned long *vals, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (vals[i] != 0)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int print_cycles_spark(char *bf, int size, unsigned long *svals, u64 n)\n{\n\tint printed;\n\n\tif (n <= 1)\n\t\treturn 0;\n\n\tif (n > NUM_SPARKS)\n\t\tn = NUM_SPARKS;\n\tif (all_zero(svals, n))\n\t\treturn 0;\n\n\tprinted = print_spark(bf, size, svals, n);\n\tprinted += scnprintf(bf + printed, size - printed, \" \");\n\treturn printed;\n}\n\nstatic int hpp__color_cycles_hist(struct perf_hpp_fmt *fmt,\n\t\t\t    struct perf_hpp *hpp, struct hist_entry *he)\n{\n\tstruct diff_hpp_fmt *dfmt =\n\t\tcontainer_of(fmt, struct diff_hpp_fmt, fmt);\n\tstruct hist_entry *pair = get_pair_fmt(he, dfmt);\n\tstruct block_hist *bh = container_of(he, struct block_hist, he);\n\tstruct block_hist *bh_pair;\n\tstruct hist_entry *block_he;\n\tchar spark[32], buf[128];\n\tdouble r;\n\tint ret, pad;\n\n\tif (!pair) {\n\t\tif (bh->block_idx)\n\t\t\thpp->skip = true;\n\n\t\tgoto no_print;\n\t}\n\n\tbh_pair = container_of(pair, struct block_hist, he);\n\n\tblock_he = hists__get_entry(&bh_pair->block_hists, bh->block_idx);\n\tif (!block_he) {\n\t\thpp->skip = true;\n\t\tgoto no_print;\n\t}\n\n\tret = print_cycles_spark(spark, sizeof(spark), block_he->diff.svals,\n\t\t\t\t block_he->diff.stats.n);\n\n\tr = rel_stddev_stats(stddev_stats(&block_he->diff.stats),\n\t\t\t     avg_stats(&block_he->diff.stats));\n\n\tif (ret) {\n\t\t \n\t\tpad = NUM_SPARKS - ((ret - 1) / 3);\n\t\tscnprintf(buf, sizeof(buf), \"%s%5.1f%% %s\", \"\\u00B1\", r, spark);\n\t\tret = scnprintf(hpp->buf, hpp->size, \"%*s\",\n\t\t\t\tdfmt->header_width, buf);\n\n\t\tif (pad) {\n\t\t\tret += scnprintf(hpp->buf + ret, hpp->size - ret,\n\t\t\t\t\t \"%-*s\", pad, \" \");\n\t\t}\n\n\t\treturn ret;\n\t}\n\nno_print:\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\",\n\t\t\tdfmt->header_width, \" \");\n}\n\nstatic void\nhpp__entry_unpair(struct hist_entry *he, int idx, char *buf, size_t size)\n{\n\tswitch (idx) {\n\tcase PERF_HPP_DIFF__PERIOD_BASELINE:\n\t\tscnprintf(buf, size, \"%\" PRIu64, he->stat.period);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nhpp__entry_pair(struct hist_entry *he, struct hist_entry *pair,\n\t\tint idx, char *buf, size_t size)\n{\n\tdouble diff;\n\tdouble ratio;\n\ts64 wdiff;\n\n\tswitch (idx) {\n\tcase PERF_HPP_DIFF__DELTA:\n\tcase PERF_HPP_DIFF__DELTA_ABS:\n\t\tif (pair->diff.computed)\n\t\t\tdiff = pair->diff.period_ratio_delta;\n\t\telse\n\t\t\tdiff = compute_delta(he, pair);\n\n\t\tscnprintf(buf, size, \"%+4.2F%%\", diff);\n\t\tbreak;\n\n\tcase PERF_HPP_DIFF__RATIO:\n\t\t \n\t\tif (he->dummy) {\n\t\t\tscnprintf(buf, size, \"N/A\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pair->diff.computed)\n\t\t\tratio = pair->diff.period_ratio;\n\t\telse\n\t\t\tratio = compute_ratio(he, pair);\n\n\t\tif (ratio > 0.0)\n\t\t\tscnprintf(buf, size, \"%14.6F\", ratio);\n\t\tbreak;\n\n\tcase PERF_HPP_DIFF__WEIGHTED_DIFF:\n\t\t \n\t\tif (he->dummy) {\n\t\t\tscnprintf(buf, size, \"N/A\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pair->diff.computed)\n\t\t\twdiff = pair->diff.wdiff;\n\t\telse\n\t\t\twdiff = compute_wdiff(he, pair);\n\n\t\tif (wdiff != 0)\n\t\t\tscnprintf(buf, size, \"%14ld\", wdiff);\n\t\tbreak;\n\n\tcase PERF_HPP_DIFF__FORMULA:\n\t\tformula_fprintf(he, pair, buf, size);\n\t\tbreak;\n\n\tcase PERF_HPP_DIFF__PERIOD:\n\t\tscnprintf(buf, size, \"%\" PRIu64, pair->stat.period);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n}\n\nstatic void\n__hpp__entry_global(struct hist_entry *he, struct diff_hpp_fmt *dfmt,\n\t\t    char *buf, size_t size)\n{\n\tstruct hist_entry *pair = get_pair_fmt(he, dfmt);\n\tint idx = dfmt->idx;\n\n\t \n\tif (idx == PERF_HPP_DIFF__BASELINE)\n\t\thpp__entry_baseline(he, buf, size);\n\telse {\n\t\tif (pair)\n\t\t\thpp__entry_pair(he, pair, idx, buf, size);\n\t\telse\n\t\t\thpp__entry_unpair(he, idx, buf, size);\n\t}\n}\n\nstatic int hpp__entry_global(struct perf_hpp_fmt *_fmt, struct perf_hpp *hpp,\n\t\t\t     struct hist_entry *he)\n{\n\tstruct diff_hpp_fmt *dfmt =\n\t\tcontainer_of(_fmt, struct diff_hpp_fmt, fmt);\n\tchar buf[MAX_COL_WIDTH] = \" \";\n\n\t__hpp__entry_global(he, dfmt, buf, MAX_COL_WIDTH);\n\n\tif (symbol_conf.field_sep)\n\t\treturn scnprintf(hpp->buf, hpp->size, \"%s\", buf);\n\telse\n\t\treturn scnprintf(hpp->buf, hpp->size, \"%*s\",\n\t\t\t\t dfmt->header_width, buf);\n}\n\nstatic int hpp__header(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hists *hists __maybe_unused,\n\t\t       int line __maybe_unused,\n\t\t       int *span __maybe_unused)\n{\n\tstruct diff_hpp_fmt *dfmt =\n\t\tcontainer_of(fmt, struct diff_hpp_fmt, fmt);\n\n\tBUG_ON(!dfmt->header);\n\treturn scnprintf(hpp->buf, hpp->size, dfmt->header);\n}\n\nstatic int hpp__width(struct perf_hpp_fmt *fmt,\n\t\t      struct perf_hpp *hpp __maybe_unused,\n\t\t      struct hists *hists __maybe_unused)\n{\n\tstruct diff_hpp_fmt *dfmt =\n\t\tcontainer_of(fmt, struct diff_hpp_fmt, fmt);\n\n\tBUG_ON(dfmt->header_width <= 0);\n\treturn dfmt->header_width;\n}\n\nstatic void init_header(struct data__file *d, struct diff_hpp_fmt *dfmt)\n{\n#define MAX_HEADER_NAME 100\n\tchar buf_indent[MAX_HEADER_NAME];\n\tchar buf[MAX_HEADER_NAME];\n\tconst char *header = NULL;\n\tint width = 0;\n\n\tBUG_ON(dfmt->idx >= PERF_HPP_DIFF__MAX_INDEX);\n\theader = columns[dfmt->idx].name;\n\twidth  = columns[dfmt->idx].width;\n\n\t \n\tBUG_ON(!header);\n\n\tif (data__files_cnt > 2)\n\t\tscnprintf(buf, MAX_HEADER_NAME, \"%s/%d\", header, d->idx);\n\n#define NAME (data__files_cnt > 2 ? buf : header)\n\tdfmt->header_width = width;\n\twidth = (int) strlen(NAME);\n\tif (dfmt->header_width < width)\n\t\tdfmt->header_width = width;\n\n\tscnprintf(buf_indent, MAX_HEADER_NAME, \"%*s\",\n\t\t  dfmt->header_width, NAME);\n\n\tdfmt->header = strdup(buf_indent);\n#undef MAX_HEADER_NAME\n#undef NAME\n}\n\nstatic void data__hpp_register(struct data__file *d, int idx)\n{\n\tstruct diff_hpp_fmt *dfmt = &d->fmt[idx];\n\tstruct perf_hpp_fmt *fmt = &dfmt->fmt;\n\n\tdfmt->idx = idx;\n\n\tfmt->header = hpp__header;\n\tfmt->width  = hpp__width;\n\tfmt->entry  = hpp__entry_global;\n\tfmt->cmp    = hist_entry__cmp_nop;\n\tfmt->collapse = hist_entry__cmp_nop;\n\n\t \n\tswitch (idx) {\n\tcase PERF_HPP_DIFF__BASELINE:\n\t\tfmt->color = hpp__color_baseline;\n\t\tfmt->sort  = hist_entry__cmp_baseline;\n\t\tbreak;\n\tcase PERF_HPP_DIFF__DELTA:\n\t\tfmt->color = hpp__color_delta;\n\t\tfmt->sort  = hist_entry__cmp_delta;\n\t\tbreak;\n\tcase PERF_HPP_DIFF__RATIO:\n\t\tfmt->color = hpp__color_ratio;\n\t\tfmt->sort  = hist_entry__cmp_ratio;\n\t\tbreak;\n\tcase PERF_HPP_DIFF__WEIGHTED_DIFF:\n\t\tfmt->color = hpp__color_wdiff;\n\t\tfmt->sort  = hist_entry__cmp_wdiff;\n\t\tbreak;\n\tcase PERF_HPP_DIFF__DELTA_ABS:\n\t\tfmt->color = hpp__color_delta;\n\t\tfmt->sort  = hist_entry__cmp_delta_abs;\n\t\tbreak;\n\tcase PERF_HPP_DIFF__CYCLES:\n\t\tfmt->color = hpp__color_cycles;\n\t\tfmt->sort  = hist_entry__cmp_nop;\n\t\tbreak;\n\tcase PERF_HPP_DIFF__CYCLES_HIST:\n\t\tfmt->color = hpp__color_cycles_hist;\n\t\tfmt->sort  = hist_entry__cmp_nop;\n\t\tbreak;\n\tdefault:\n\t\tfmt->sort  = hist_entry__cmp_nop;\n\t\tbreak;\n\t}\n\n\tinit_header(d, dfmt);\n\tperf_hpp__column_register(fmt);\n\tperf_hpp__register_sort_field(fmt);\n}\n\nstatic int ui_init(void)\n{\n\tstruct data__file *d;\n\tstruct perf_hpp_fmt *fmt;\n\tint i;\n\n\tdata__for_each_file(i, d) {\n\n\t\t \n\t\tdata__hpp_register(d, i ? compute_2_hpp[compute] :\n\t\t\t\t\t  PERF_HPP_DIFF__BASELINE);\n\n\t\tif (cycles_hist && i)\n\t\t\tdata__hpp_register(d, PERF_HPP_DIFF__CYCLES_HIST);\n\n\t\t \n\t\tif (show_formula && i)\n\t\t\tdata__hpp_register(d, PERF_HPP_DIFF__FORMULA);\n\n\t\tif (show_period)\n\t\t\tdata__hpp_register(d, i ? PERF_HPP_DIFF__PERIOD :\n\t\t\t\t\t\t  PERF_HPP_DIFF__PERIOD_BASELINE);\n\t}\n\n\tif (!sort_compute)\n\t\treturn 0;\n\n\t \n\tfmt = zalloc(sizeof(*fmt));\n\tif (fmt == NULL) {\n\t\tpr_err(\"Memory allocation failed\\n\");\n\t\treturn -1;\n\t}\n\n\tfmt->cmp      = hist_entry__cmp_nop;\n\tfmt->collapse = hist_entry__cmp_nop;\n\n\tswitch (compute) {\n\tcase COMPUTE_DELTA:\n\t\tfmt->sort = hist_entry__cmp_delta_idx;\n\t\tbreak;\n\tcase COMPUTE_RATIO:\n\t\tfmt->sort = hist_entry__cmp_ratio_idx;\n\t\tbreak;\n\tcase COMPUTE_WEIGHTED_DIFF:\n\t\tfmt->sort = hist_entry__cmp_wdiff_idx;\n\t\tbreak;\n\tcase COMPUTE_DELTA_ABS:\n\t\tfmt->sort = hist_entry__cmp_delta_abs_idx;\n\t\tbreak;\n\tcase COMPUTE_CYCLES:\n\t\t \n\t\tfmt->sort = hist_entry__cmp_nop;\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n\n\tperf_hpp__prepend_sort_field(fmt);\n\treturn 0;\n}\n\nstatic int data_init(int argc, const char **argv)\n{\n\tstruct data__file *d;\n\tstatic const char *defaults[] = {\n\t\t\"perf.data.old\",\n\t\t\"perf.data\",\n\t};\n\tbool use_default = true;\n\tint i;\n\n\tdata__files_cnt = 2;\n\n\tif (argc) {\n\t\tif (argc == 1)\n\t\t\tdefaults[1] = argv[0];\n\t\telse {\n\t\t\tdata__files_cnt = argc;\n\t\t\tuse_default = false;\n\t\t}\n\t} else if (perf_guest) {\n\t\tdefaults[0] = \"perf.data.host\";\n\t\tdefaults[1] = \"perf.data.guest\";\n\t}\n\n\tif (sort_compute >= (unsigned int) data__files_cnt) {\n\t\tpr_err(\"Order option out of limit.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata__files = zalloc(sizeof(*data__files) * data__files_cnt);\n\tif (!data__files)\n\t\treturn -ENOMEM;\n\n\tdata__for_each_file(i, d) {\n\t\tstruct perf_data *data = &d->data;\n\n\t\tdata->path  = use_default ? defaults[i] : argv[i];\n\t\tdata->mode  = PERF_DATA_MODE_READ;\n\t\tdata->force = force;\n\n\t\td->idx  = i;\n\t}\n\n\treturn 0;\n}\n\nstatic int diff__config(const char *var, const char *value,\n\t\t\tvoid *cb __maybe_unused)\n{\n\tif (!strcmp(var, \"diff.order\")) {\n\t\tint ret;\n\t\tif (perf_config_int(&ret, var, value) < 0)\n\t\t\treturn -1;\n\t\tsort_compute = ret;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"diff.compute\")) {\n\t\tif (!strcmp(value, \"delta\")) {\n\t\t\tcompute = COMPUTE_DELTA;\n\t\t} else if (!strcmp(value, \"delta-abs\")) {\n\t\t\tcompute = COMPUTE_DELTA_ABS;\n\t\t} else if (!strcmp(value, \"ratio\")) {\n\t\t\tcompute = COMPUTE_RATIO;\n\t\t} else if (!strcmp(value, \"wdiff\")) {\n\t\t\tcompute = COMPUTE_WEIGHTED_DIFF;\n\t\t} else {\n\t\t\tpr_err(\"Invalid compute method: %s\\n\", value);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint cmd_diff(int argc, const char **argv)\n{\n\tint ret = hists__init();\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tperf_config(diff__config, NULL);\n\n\targc = parse_options(argc, argv, options, diff_usage, 0);\n\n\tif (quiet)\n\t\tperf_quiet_option();\n\n\tif (cycles_hist && (compute != COMPUTE_CYCLES))\n\t\tusage_with_options(diff_usage, options);\n\n\tif (pdiff.stream)\n\t\tcompute = COMPUTE_STREAM;\n\n\tsymbol__annotation_init();\n\n\tif (symbol__init(NULL) < 0)\n\t\treturn -1;\n\n\tif (data_init(argc, argv) < 0)\n\t\treturn -1;\n\n\tif (check_file_brstack() < 0)\n\t\treturn -1;\n\n\tif ((compute == COMPUTE_CYCLES || compute == COMPUTE_STREAM)\n\t    && !pdiff.has_br_stack) {\n\t\treturn -1;\n\t}\n\n\tif (compute == COMPUTE_STREAM) {\n\t\tsymbol_conf.show_branchflag_count = true;\n\t\tsymbol_conf.disable_add2line_warn = true;\n\t\tcallchain_param.mode = CHAIN_FLAT;\n\t\tcallchain_param.key = CCKEY_SRCLINE;\n\t\tcallchain_param.branch_callstack = 1;\n\t\tsymbol_conf.use_callchain = true;\n\t\tcallchain_register_param(&callchain_param);\n\t\tsort_order = \"srcline,symbol,dso\";\n\t} else {\n\t\tif (ui_init() < 0)\n\t\t\treturn -1;\n\n\t\tsort__mode = SORT_MODE__DIFF;\n\t}\n\n\tif (setup_sorting(NULL) < 0)\n\t\tusage_with_options(diff_usage, options);\n\n\tsetup_pager();\n\n\tsort__setup_elide(NULL);\n\n\treturn __cmd_diff();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}