{
  "module_name": "perf.data-file-format.txt",
  "hash_id": "55d41d061579c055797d6b4401ad5b68111d3e05519688a80f2dba8a7e1f7187",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf.data-file-format.txt",
  "human_readable_source": "perf.data format\n\nUptodate as of v4.7\n\nThis document describes the on-disk perf.data format, generated by perf record\nor perf inject and consumed by the other perf tools.\n\nOn a high level perf.data contains the events generated by the PMUs, plus metadata.\n\nAll fields are in native-endian of the machine that generated the perf.data.\n\nWhen perf is writing to a pipe it uses a special version of the file\nformat that does not rely on seeking to adjust data offsets.  This\nformat is described in \"Pipe-mode data\" section. The pipe data version can be\naugmented with additional events using perf inject.\n\nThe file starts with a perf_header:\n\nstruct perf_header {\n\tchar magic[8];\t\t/* PERFILE2 */\n\tuint64_t size;\t\t/* size of the header */\n\tuint64_t attr_size;\t/* size of an attribute in attrs */\n\tstruct perf_file_section attrs;\n\tstruct perf_file_section data;\n\tstruct perf_file_section event_types;\n\tuint64_t flags;\n\tuint64_t flags1[3];\n};\n\nThe magic number identifies the perf file and the version. Current perf versions\nuse PERFILE2. Old perf versions generated a version 1 format (PERFFILE). Version 1\nis not described here. The magic number also identifies the endian. When the\nmagic value is 64bit byte swapped compared the file is in non-native\nendian.\n\nA perf_file_section contains a pointer to another section of the perf file.\nThe header contains three such pointers: for attributes, data and event types.\n\nstruct perf_file_section {\n\tuint64_t offset;\t/* offset from start of file */\n\tuint64_t size;\t\t/* size of the section */\n};\n\nFlags section:\n\nFor each of the optional features a perf_file_section is placed after the data\nsection if the feature bit is set in the perf_header flags bitset. The\nrespective perf_file_section points to the data of the additional header and\ndefines its size.\n\nSome headers consist of strings, which are defined like this:\n\nstruct perf_header_string {\n       uint32_t len;\n       char string[len]; /* zero terminated */\n};\n\nSome headers consist of a sequence of strings, which start with a\n\nstruct perf_header_string_list {\n     uint32_t nr;\n     struct perf_header_string strings[nr]; /* variable length records */\n};\n\nThe bits are the flags bits in a 256 bit bitmap starting with\nflags. These define the valid bits:\n\n\tHEADER_RESERVED\t\t= 0,\t/* always cleared */\n\tHEADER_FIRST_FEATURE\t= 1,\n\tHEADER_TRACING_DATA\t= 1,\n\nDescribe me.\n\n\tHEADER_BUILD_ID = 2,\n\nThe header consists of an sequence of build_id_event. The size of each record\nis defined by header.size (see perf_event.h). Each event defines a ELF build id\nfor a executable file name for a pid. An ELF build id is a unique identifier\nassigned by the linker to an executable.\n\nstruct build_id_event {\n\tstruct perf_event_header header;\n\tpid_t\t\t\t pid;\n\tuint8_t\t\t\t build_id[24];\n\tchar\t\t\t filename[header.size - offsetof(struct build_id_event, filename)];\n};\n\n\tHEADER_HOSTNAME = 3,\n\nA perf_header_string with the hostname where the data was collected\n(uname -n)\n\n\tHEADER_OSRELEASE = 4,\n\nA perf_header_string with the os release where the data was collected\n(uname -r)\n\n\tHEADER_VERSION = 5,\n\nA perf_header_string with the perf user tool version where the\ndata was collected. This is the same as the version of the source tree\nthe perf tool was built from.\n\n\tHEADER_ARCH = 6,\n\nA perf_header_string with the CPU architecture (uname -m)\n\n\tHEADER_NRCPUS = 7,\n\nA structure defining the number of CPUs.\n\nstruct nr_cpus {\n       uint32_t nr_cpus_available; /* CPUs not yet onlined */\n       uint32_t nr_cpus_online;\n};\n\n\tHEADER_CPUDESC = 8,\n\nA perf_header_string with description of the CPU. On x86 this is the model name\nin /proc/cpuinfo\n\n\tHEADER_CPUID = 9,\n\nA perf_header_string with the exact CPU type. On x86 this is\nvendor,family,model,stepping. For example: GenuineIntel,6,69,1\n\n\tHEADER_TOTAL_MEM = 10,\n\nAn uint64_t with the total memory in kilobytes.\n\n\tHEADER_CMDLINE = 11,\n\nA perf_header_string_list with the perf arg-vector used to collect the data.\n\n\tHEADER_EVENT_DESC = 12,\n\nAnother description of the perf_event_attrs, more detailed than header.attrs\nincluding IDs and names. See perf_event.h or the man page for a description\nof a struct perf_event_attr.\n\nstruct {\n       uint32_t nr; /* number of events */\n       uint32_t attr_size; /* size of each perf_event_attr */\n       struct {\n\t      struct perf_event_attr attr;  /* size of attr_size */\n\t      uint32_t nr_ids;\n\t      struct perf_header_string event_string;\n\t      uint64_t ids[nr_ids];\n       } events[nr]; /* Variable length records */\n};\n\n\tHEADER_CPU_TOPOLOGY = 13,\n\nstruct {\n\t/*\n\t * First revision of HEADER_CPU_TOPOLOGY\n\t *\n\t * See 'struct perf_header_string_list' definition earlier\n\t * in this file.\n\t */\n\n       struct perf_header_string_list cores; /* Variable length */\n       struct perf_header_string_list threads; /* Variable length */\n\n       /*\n        * Second revision of HEADER_CPU_TOPOLOGY, older tools\n        * will not consider what comes next\n        */\n\n       struct {\n\t      uint32_t core_id;\n\t      uint32_t socket_id;\n       } cpus[nr]; /* Variable length records */\n       /* 'nr' comes from previously processed HEADER_NRCPUS's nr_cpu_avail */\n\n        /*\n\t * Third revision of HEADER_CPU_TOPOLOGY, older tools\n\t * will not consider what comes next\n\t */\n\n\tstruct perf_header_string_list dies; /* Variable length */\n\tuint32_t die_id[nr_cpus_avail]; /* from previously processed HEADER_NR_CPUS, VLA */\n};\n\nExample:\n\tsibling sockets : 0-8\n\tsibling dies\t: 0-3\n\tsibling dies\t: 4-7\n\tsibling threads : 0-1\n\tsibling threads : 2-3\n\tsibling threads : 4-5\n\tsibling threads : 6-7\n\n\tHEADER_NUMA_TOPOLOGY = 14,\n\n\tA list of NUMA node descriptions\n\nstruct {\n       uint32_t nr;\n       struct {\n\t      uint32_t nodenr;\n\t      uint64_t mem_total;\n\t      uint64_t mem_free;\n\t      struct perf_header_string cpus;\n       } nodes[nr]; /* Variable length records */\n};\n\n\tHEADER_BRANCH_STACK = 15,\n\nNot implemented in perf.\n\n\tHEADER_PMU_MAPPINGS = 16,\n\n\tA list of PMU structures, defining the different PMUs supported by perf.\n\nstruct {\n       uint32_t nr;\n       struct pmu {\n\t      uint32_t pmu_type;\n\t      struct perf_header_string pmu_name;\n       } [nr]; /* Variable length records */\n};\n\n\tHEADER_GROUP_DESC = 17,\n\n\tDescription of counter groups ({...} in perf syntax)\n\nstruct {\n         uint32_t nr;\n         struct {\n\t\tstruct perf_header_string string;\n\t\tuint32_t leader_idx;\n\t\tuint32_t nr_members;\n\t } [nr]; /* Variable length records */\n};\n\n\tHEADER_AUXTRACE = 18,\n\nDefine additional auxtrace areas in the perf.data. auxtrace is used to store\nundecoded hardware tracing information, such as Intel Processor Trace data.\n\n/**\n * struct auxtrace_index_entry - indexes a AUX area tracing event within a\n *                               perf.data file.\n * @file_offset: offset within the perf.data file\n * @sz: size of the event\n */\nstruct auxtrace_index_entry {\n\tu64\t\t\tfile_offset;\n\tu64\t\t\tsz;\n};\n\n#define PERF_AUXTRACE_INDEX_ENTRY_COUNT 256\n\n/**\n * struct auxtrace_index - index of AUX area tracing events within a perf.data\n *                         file.\n * @list: linking a number of arrays of entries\n * @nr: number of entries\n * @entries: array of entries\n */\nstruct auxtrace_index {\n\tstruct list_head\tlist;\n\tsize_t\t\t\tnr;\n\tstruct auxtrace_index_entry entries[PERF_AUXTRACE_INDEX_ENTRY_COUNT];\n};\n\n\tHEADER_STAT = 19,\n\nThis is merely a flag signifying that the data section contains data\nrecorded from perf stat record.\n\n\tHEADER_CACHE = 20,\n\nDescription of the cache hierarchy. Based on the Linux sysfs format\nin /sys/devices/system/cpu/cpu*/cache/\n\n\tu32 version\tCurrently always 1\n\tu32 number_of_cache_levels\n\nstruct {\n\tu32\tlevel;\n\tu32\tline_size;\n\tu32\tsets;\n\tu32\tways;\n\tstruct perf_header_string type;\n\tstruct perf_header_string size;\n\tstruct perf_header_string map;\n}[number_of_cache_levels];\n\n\tHEADER_SAMPLE_TIME = 21,\n\nTwo uint64_t for the time of first sample and the time of last sample.\n\n\tHEADER_SAMPLE_TOPOLOGY = 22,\n\nPhysical memory map and its node assignments.\n\nThe format of data in MEM_TOPOLOGY is as follows:\n\n\tu64 version;            // Currently 1\n\tu64 block_size_bytes;   // /sys/devices/system/memory/block_size_bytes\n\tu64 count;              // number of nodes\n\nstruct memory_node {\n        u64 node_id;            // node index\n        u64 size;               // size of bitmap\n        struct bitmap {\n\t\t/* size of bitmap again */\n                u64 bitmapsize;\n\t\t/* bitmap of memory indexes that belongs to node     */\n\t\t/* /sys/devices/system/node/node<NODE>/memory<INDEX> */\n                u64 entries[(bitmapsize/64)+1];\n        }\n}[count];\n\nThe MEM_TOPOLOGY can be displayed with following command:\n\n$ perf report --header-only -I\n...\n# memory nodes (nr 1, block size 0x8000000):\n#    0 [7G]: 0-23,32-69\n\n\tHEADER_CLOCKID = 23,\n\nOne uint64_t for the clockid frequency, specified, for instance, via 'perf\nrecord -k' (see clock_gettime()), to enable timestamps derived metrics\nconversion into wall clock time on the reporting stage.\n\n\tHEADER_DIR_FORMAT = 24,\n\nThe data files layout is described by HEADER_DIR_FORMAT feature.  Currently it\nholds only version number (1):\n\n  uint64_t version;\n\nThe current version holds only version value (1) means that data files:\n\n- Follow the 'data.*' name format.\n\n- Contain raw events data in standard perf format as read from kernel (and need\n  to be sorted)\n\nFuture versions are expected to describe different data files layout according\nto special needs.\n\n        HEADER_BPF_PROG_INFO = 25,\n\nstruct perf_bpil, which contains detailed information about\na BPF program, including type, id, tag, jited/xlated instructions, etc.\n\n        HEADER_BPF_BTF = 26,\n\nContains BPF Type Format (BTF). For more information about BTF, please\nrefer to Documentation/bpf/btf.rst.\n\nstruct {\n\tu32\tid;\n\tu32\tdata_size;\n\tchar\tdata[];\n};\n\n        HEADER_COMPRESSED = 27,\n\nstruct {\n\tu32\tversion;\n\tu32\ttype;\n\tu32\tlevel;\n\tu32\tratio;\n\tu32\tmmap_len;\n};\n\nIndicates that trace contains records of PERF_RECORD_COMPRESSED type\nthat have perf_events records in compressed form.\n\n\tHEADER_CPU_PMU_CAPS = 28,\n\n\tA list of cpu PMU capabilities. The format of data is as below.\n\nstruct {\n\tu32 nr_cpu_pmu_caps;\n\t{\n\t\tchar\tname[];\n\t\tchar\tvalue[];\n\t} [nr_cpu_pmu_caps]\n};\n\n\nExample:\n cpu pmu capabilities: branches=32, max_precise=3, pmu_name=icelake\n\n\tHEADER_CLOCK_DATA = 29,\n\n\tContains clock id and its reference time together with wall clock\n\ttime taken at the 'same time', both values are in nanoseconds.\n\tThe format of data is as below.\n\nstruct {\n\tu32 version;  /* version = 1 */\n\tu32 clockid;\n\tu64 wall_clock_ns;\n\tu64 clockid_time_ns;\n};\n\n\tHEADER_HYBRID_TOPOLOGY = 30,\n\nIndicate the hybrid CPUs. The format of data is as below.\n\nstruct {\n\tu32 nr;\n\tstruct {\n\t\tchar pmu_name[];\n\t\tchar cpus[];\n\t} [nr]; /* Variable length records */\n};\n\nExample:\n  hybrid cpu system:\n  cpu_core cpu list : 0-15\n  cpu_atom cpu list : 16-23\n\n\tHEADER_PMU_CAPS = 31,\n\n\tList of pmu capabilities (except cpu pmu which is already\n\tcovered by HEADER_CPU_PMU_CAPS). Note that hybrid cpu pmu\n\tcapabilities are also stored here.\n\nstruct {\n\tu32 nr_pmu;\n\tstruct {\n\t\tu32 nr_caps;\n\t\t{\n\t\t\tchar\tname[];\n\t\t\tchar\tvalue[];\n\t\t} [nr_caps];\n\t\tchar pmu_name[];\n\t} [nr_pmu];\n};\n\n\tother bits are reserved and should ignored for now\n\tHEADER_FEAT_BITS\t= 256,\n\nAttributes\n\nThis is an array of perf_event_attrs, each attr_size bytes long, which defines\neach event collected. See perf_event.h or the man page for a detailed\ndescription.\n\nData\n\nThis section is the bulk of the file. It consist of a stream of perf_events\ndescribing events. This matches the format generated by the kernel.\nSee perf_event.h or the manpage for a detailed description.\n\nSome notes on parsing:\n\nOrdering\n\nThe events are not necessarily in time stamp order, as they can be\ncollected in parallel on different CPUs. If the events should be\nprocessed in time order they need to be sorted first. It is possible\nto only do a partial sort using the FINISHED_ROUND event header (see\nbelow). perf record guarantees that there is no reordering over a\nFINISHED_ROUND.\n\nID vs IDENTIFIER\n\nWhen the event stream contains multiple events each event is identified\nby an ID. This can be either through the PERF_SAMPLE_ID or the\nPERF_SAMPLE_IDENTIFIER header. The PERF_SAMPLE_IDENTIFIER header is\nat a fixed offset from the event header, which allows reliable\nparsing of the header. Relying on ID may be ambiguous.\nIDENTIFIER is only supported by newer Linux kernels.\n\nPerf record specific events:\n\nIn addition to the kernel generated event types perf record adds its\nown event types (in addition it also synthesizes some kernel events,\nfor example MMAP events)\n\n\tPERF_RECORD_USER_TYPE_START\t\t= 64,\n\tPERF_RECORD_HEADER_ATTR\t\t\t= 64,\n\nstruct attr_event {\n\tstruct perf_event_header header;\n\tstruct perf_event_attr attr;\n\tuint64_t id[];\n};\n\n\tPERF_RECORD_HEADER_EVENT_TYPE\t\t= 65, /* deprecated */\n\n#define MAX_EVENT_NAME 64\n\nstruct perf_trace_event_type {\n\tuint64_t\tevent_id;\n\tchar\tname[MAX_EVENT_NAME];\n};\n\nstruct event_type_event {\n\tstruct perf_event_header header;\n\tstruct perf_trace_event_type event_type;\n};\n\n\n\tPERF_RECORD_HEADER_TRACING_DATA\t\t= 66,\n\nDescribe me\n\nstruct tracing_data_event {\n\tstruct perf_event_header header;\n\tuint32_t size;\n};\n\n\tPERF_RECORD_HEADER_BUILD_ID\t\t= 67,\n\nDefine a ELF build ID for a referenced executable.\n\n       struct build_id_event;   /* See above */\n\n\tPERF_RECORD_FINISHED_ROUND\t\t= 68,\n\nNo event reordering over this header. No payload.\n\n\tPERF_RECORD_ID_INDEX\t\t\t= 69,\n\nMap event ids to CPUs and TIDs.\n\nstruct id_index_entry {\n\tuint64_t id;\n\tuint64_t idx;\n\tuint64_t cpu;\n\tuint64_t tid;\n};\n\nstruct id_index_event {\n\tstruct perf_event_header header;\n\tuint64_t nr;\n\tstruct id_index_entry entries[nr];\n};\n\n\tPERF_RECORD_AUXTRACE_INFO\t\t= 70,\n\nAuxtrace type specific information. Describe me\n\nstruct auxtrace_info_event {\n\tstruct perf_event_header header;\n\tuint32_t type;\n\tuint32_t reserved__; /* For alignment */\n\tuint64_t priv[];\n};\n\n\tPERF_RECORD_AUXTRACE\t\t\t= 71,\n\nDefines auxtrace data. Followed by the actual data. The contents of\nthe auxtrace data is dependent on the event and the CPU. For example\nfor Intel Processor Trace it contains Processor Trace data generated\nby the CPU.\n\nstruct auxtrace_event {\n\tstruct perf_event_header header;\n\tuint64_t size;\n\tuint64_t offset;\n\tuint64_t reference;\n\tuint32_t idx;\n\tuint32_t tid;\n\tuint32_t cpu;\n\tuint32_t reserved__; /* For alignment */\n};\n\nstruct aux_event {\n\tstruct perf_event_header header;\n\tuint64_t\taux_offset;\n\tuint64_t\taux_size;\n\tuint64_t\tflags;\n};\n\n\tPERF_RECORD_AUXTRACE_ERROR\t\t= 72,\n\nDescribes an error in hardware tracing\n\nenum auxtrace_error_type {\n\tPERF_AUXTRACE_ERROR_ITRACE  = 1,\n\tPERF_AUXTRACE_ERROR_MAX\n};\n\n#define MAX_AUXTRACE_ERROR_MSG 64\n\nstruct auxtrace_error_event {\n\tstruct perf_event_header header;\n\tuint32_t type;\n\tuint32_t code;\n\tuint32_t cpu;\n\tuint32_t pid;\n\tuint32_t tid;\n\tuint32_t reserved__; /* For alignment */\n\tuint64_t ip;\n\tchar msg[MAX_AUXTRACE_ERROR_MSG];\n};\n\n\tPERF_RECORD_HEADER_FEATURE\t\t= 80,\n\nDescribes a header feature. These are records used in pipe-mode that\ncontain information that otherwise would be in perf.data file's header.\n\n\tPERF_RECORD_COMPRESSED \t\t\t= 81,\n\nstruct compressed_event {\n\tstruct perf_event_header\theader;\n\tchar\t\t\t\tdata[];\n};\n\n\tPERF_RECORD_FINISHED_INIT\t\t\t= 82,\n\nMarks the end of records for the system, pre-existing threads in system wide\nsessions, etc. Those are the ones prefixed PERF_RECORD_USER_*.\n\nThis is used, for instance, to 'perf inject' events after init and before\nregular events, those emitted by the kernel, to support combining guest and\nhost records.\n\n\nThe header is followed by compressed data frame that can be decompressed\ninto array of perf trace records. The size of the entire compressed event\nrecord including the header is limited by the max value of header.size.\n\nEvent types\n\nDefine the event attributes with their IDs.\n\nAn array bound by the perf_file_section size.\n\n\tstruct {\n\t\tstruct perf_event_attr attr;   /* Size defined by header.attr_size */\n\t\tstruct perf_file_section ids;\n\t}\n\nids points to a array of uint64_t defining the ids for event attr attr.\n\nPipe-mode data\n\nPipe-mode avoid seeks in the file by removing the perf_file_section and flags\nfrom the struct perf_header. The trimmed header is:\n\nstruct perf_pipe_file_header {\n\tu64\t\t\t\tmagic;\n\tu64\t\t\t\tsize;\n};\n\nThe information about attrs, data, and event_types is instead in the\nsynthesized events PERF_RECORD_ATTR, PERF_RECORD_HEADER_TRACING_DATA,\nPERF_RECORD_HEADER_EVENT_TYPE, and PERF_RECORD_HEADER_FEATURE\nthat are generated by perf record in pipe-mode.\n\n\nReferences:\n\ninclude/uapi/linux/perf_event.h\n\nThis is the canonical description of the kernel generated perf_events\nand the perf_event_attrs.\n\nperf_events manpage\n\nA manpage describing perf_event and perf_event_attr is here:\nhttp://web.eece.maine.edu/~vweaver/projects/perf_events/programming.html\nThis tends to be slightly behind the kernel include, but has better\ndescriptions.  An (typically older) version of the man page may be\nincluded with the standard Linux man pages, available with \"man\nperf_events\"\n\npmu-tools\n\nhttps://github.com/andikleen/pmu-tools/tree/master/parser\n\nA definition of the perf.data format in python \"construct\" format is available\nin pmu-tools parser. This allows to read perf.data from python and dump it.\n\nquipper\n\nThe quipper C++ parser is available at\nhttp://github.com/google/perf_data_converter/tree/master/src/quipper\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}