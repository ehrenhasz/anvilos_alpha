{
  "module_name": "perf-trace.txt",
  "hash_id": "40172eebdc39644fa285f02594db0488e2ac93a2edb999537767abbd3f7a0886",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-trace.txt",
  "human_readable_source": "perf-trace(1)\n=============\n\nNAME\n----\nperf-trace - strace inspired tool\n\nSYNOPSIS\n--------\n[verse]\n'perf trace'\n'perf trace record'\n\nDESCRIPTION\n-----------\nThis command will show the events associated with the target, initially\nsyscalls, but other system events like pagefaults, task lifetime events,\nscheduling events, etc.\n\nThis is a live mode tool in addition to working with perf.data files like\nthe other perf tools. Files can be generated using the 'perf record' command\nbut the session needs to include the raw_syscalls events (-e 'raw_syscalls:*').\nAlternatively, 'perf trace record' can be used as a shortcut to\nautomatically include the raw_syscalls events when writing events to a file.\n\nThe following options apply to perf trace; options to perf trace record are\nfound in the perf record man page.\n\nOPTIONS\n-------\n\n-a::\n--all-cpus::\n        System-wide collection from all CPUs.\n\n-e::\n--expr::\n--event::\n\tList of syscalls and other perf events (tracepoints, HW cache events,\n\tetc) to show. Globbing is supported, e.g.: \"epoll_*\", \"*msg*\", etc.\n\tSee 'perf list' for a complete list of events.\n\tPrefixing with ! shows all syscalls but the ones specified.  You may\n\tneed to escape it.\n\n--filter=<filter>::\n        Event filter. This option should follow an event selector (-e) which\n\tselects tracepoint event(s).\n\n\n-D msecs::\n--delay msecs::\nAfter starting the program, wait msecs before measuring. This is useful to\nfilter out the startup phase of the program, which is often very different.\n\n-o::\n--output=::\n\tOutput file name.\n\n-p::\n--pid=::\n\tRecord events on existing process ID (comma separated list).\n\n-t::\n--tid=::\n        Record events on existing thread ID (comma separated list).\n\n-u::\n--uid=::\n        Record events in threads owned by uid. Name or number.\n\n-G::\n--cgroup::\n\tRecord events in threads in a cgroup.\n\n\tLook for cgroups to set at the /sys/fs/cgroup/perf_event directory, then\n\tremove the /sys/fs/cgroup/perf_event/ part and try:\n\n\t\tperf trace -G A -e sched:*switch\n\n\tWill set all raw_syscalls:sys_{enter,exit}, pgfault, vfs_getname, etc\n\t_and_ sched:sched_switch to the 'A' cgroup, while:\n\n\t\tperf trace -e sched:*switch -G A\n\n\twill only set the sched:sched_switch event to the 'A' cgroup, all the\n\tother events (raw_syscalls:sys_{enter,exit}, etc are left \"without\"\n\ta cgroup (on the root cgroup, sys wide, etc).\n\n\tMultiple cgroups:\n\n\t\tperf trace -G A -e sched:*switch -G B\n\n\tthe syscall ones go to the 'A' cgroup, the sched:sched_switch goes\n\tto the 'B' cgroup.\n\n--filter-pids=::\n\tFilter out events for these pids and for 'trace' itself (comma separated list).\n\n-v::\n--verbose::\n        Increase the verbosity level.\n\n--no-inherit::\n\tChild tasks do not inherit counters.\n\n-m::\n--mmap-pages=::\n\tNumber of mmap data pages (must be a power of two) or size\n\tspecification with appended unit character - B/K/M/G. The\n\tsize is rounded up to have nearest pages power of two value.\n\n-C::\n--cpu::\nCollect samples only on the list of CPUs provided. Multiple CPUs can be provided as a\ncomma-separated list with no space: 0,1. Ranges of CPUs are specified with -: 0-2.\nIn per-thread mode with inheritance mode on (default), Events are captured only when\nthe thread executes on the designated CPUs. Default is to monitor all CPUs.\n\n--duration::\n\tShow only events that had a duration greater than N.M ms.\n\n--sched::\n\tAccrue thread runtime and provide a summary at the end of the session.\n\n--failure::\n\tShow only syscalls that failed, i.e. that returned < 0.\n\n-i::\n--input::\n\tProcess events from a given perf data file.\n\n-T::\n--time::\n\tPrint full timestamp rather time relative to first sample.\n\n--comm::\n        Show process COMM right beside its ID, on by default, disable with --no-comm.\n\n-s::\n--summary::\n\tShow only a summary of syscalls by thread with min, max, and average times\n    (in msec) and relative stddev.\n\n-S::\n--with-summary::\n\tShow all syscalls followed by a summary by thread with min, max, and\n    average times (in msec) and relative stddev.\n\n--errno-summary::\n\tTo be used with -s or -S, to show stats for the errnos experienced by\n\tsyscalls, using only this option will trigger --summary.\n\n--tool_stats::\n\tShow tool stats such as number of times fd->pathname was discovered thru\n\thooking the open syscall return + vfs_getname or via reading /proc/pid/fd, etc.\n\n-f::\n--force::\n\tDon't complain, do it.\n\n-F=[all|min|maj]::\n--pf=[all|min|maj]::\n\tTrace pagefaults. Optionally, you can specify whether you want minor,\n\tmajor or all pagefaults. Default value is maj.\n\n--syscalls::\n\tTrace system calls. This options is enabled by default, disable with\n\t--no-syscalls.\n\n--call-graph [mode,type,min[,limit],order[,key][,branch]]::\n        Setup and enable call-graph (stack chain/backtrace) recording.\n        See `--call-graph` section in perf-record and perf-report\n        man pages for details. The ones that are most useful in 'perf trace'\n        are 'dwarf' and 'lbr', where available, try: 'perf trace --call-graph dwarf'.\n\n        Using this will, for the root user, bump the value of --mmap-pages to 4\n        times the maximum for non-root users, based on the kernel.perf_event_mlock_kb\n        sysctl. This is done only if the user doesn't specify a --mmap-pages value.\n\n--kernel-syscall-graph::\n\t Show the kernel callchains on the syscall exit path.\n\n--max-events=N::\n\tStop after processing N events. Note that strace-like events are considered\n\tonly at exit time or when a syscall is interrupted, i.e. in those cases this\n\toption is equivalent to the number of lines printed.\n\n--switch-on EVENT_NAME::\n\tOnly consider events after this event is found.\n\n--switch-off EVENT_NAME::\n\tStop considering events after this event is found.\n\n--show-on-off-events::\n\tShow the --switch-on/off events too.\n\n--max-stack::\n        Set the stack depth limit when parsing the callchain, anything\n        beyond the specified depth will be ignored. Note that at this point\n        this is just about the presentation part, i.e. the kernel is still\n        not limiting, the overhead of callchains needs to be set via the\n        knobs in --call-graph dwarf.\n\n        Implies '--call-graph dwarf' when --call-graph not present on the\n        command line, on systems where DWARF unwinding was built in.\n\n        Default: /proc/sys/kernel/perf_event_max_stack when present for\n                 live sessions (without --input/-i), 127 otherwise.\n\n--min-stack::\n        Set the stack depth limit when parsing the callchain, anything\n        below the specified depth will be ignored. Disabled by default.\n\n        Implies '--call-graph dwarf' when --call-graph not present on the\n        command line, on systems where DWARF unwinding was built in.\n\n--print-sample::\n\tPrint the PERF_RECORD_SAMPLE PERF_SAMPLE_ info for the\n\traw_syscalls:sys_{enter,exit} tracepoints, for debugging.\n\n--proc-map-timeout::\n\tWhen processing pre-existing threads /proc/XXX/mmap, it may take a long time,\n\tbecause the file may be huge. A time out is needed in such cases.\n\tThis option sets the time out limit. The default value is 500 ms.\n\n--sort-events::\n\tDo sorting on batches of events, use when noticing out of order events that\n\tmay happen, for instance, when a thread gets migrated to a different CPU\n\twhile processing a syscall.\n\n--libtraceevent_print::\n\tUse libtraceevent to print tracepoint arguments. By default 'perf trace' uses\n\tthe same beautifiers used in the strace-like enter+exit lines to augment the\n\ttracepoint arguments.\n\n--map-dump::\n\tDump BPF maps setup by events passed via -e, for instance the augmented_raw_syscalls\n\tliving in tools/perf/examples/bpf/augmented_raw_syscalls.c. For now this\n\tdumps just boolean map values and integer keys, in time this will print in hex\n\tby default and use BTF when available, as well as use functions to do pretty\n\tprinting using the existing 'perf trace' syscall arg beautifiers to map integer\n\targuments to strings (pid to comm, syscall id to syscall name, etc).\n\n\nPAGEFAULTS\n----------\n\nWhen tracing pagefaults, the format of the trace is as follows:\n\n<min|maj>fault [<ip.symbol>+<ip.offset>] => <addr.dso@addr.offset> (<map type><addr level>).\n\n- min/maj indicates whether fault event is minor or major;\n- ip.symbol shows symbol for instruction pointer (the code that generated the\n  fault); if no debug symbols available, perf trace will print raw IP;\n- addr.dso shows DSO for the faulted address;\n- map type is either 'd' for non-executable maps or 'x' for executable maps;\n- addr level is either 'k' for kernel dso or '.' for user dso.\n\nFor symbols resolution you may need to install debugging symbols.\n\nPlease be aware that duration is currently always 0 and doesn't reflect actual\ntime it took for fault to be handled!\n\nWhen --verbose specified, perf trace tries to print all available information\nfor both IP and fault address in the form of dso@symbol+offset.\n\nEXAMPLES\n--------\n\nTrace only major pagefaults:\n\n $ perf trace --no-syscalls -F\n\nTrace syscalls, major and minor pagefaults:\n\n $ perf trace -F all\n\n  1416.547 ( 0.000 ms): python/20235 majfault [CRYPTO_push_info_+0x0] => /lib/x86_64-linux-gnu/libcrypto.so.1.0.0@0x61be0 (x.)\n\n  As you can see, there was major pagefault in python process, from\n  CRYPTO_push_info_ routine which faulted somewhere in libcrypto.so.\n\nTrace the first 4 open, openat or open_by_handle_at syscalls (in the future more syscalls may match here):\n\n  $ perf trace -e open* --max-events 4\n  [root@jouet perf]# trace -e open* --max-events 4\n  2272.992 ( 0.037 ms): gnome-shell/1370 openat(dfd: CWD, filename: /proc/self/stat) = 31\n  2277.481 ( 0.139 ms): gnome-shell/3039 openat(dfd: CWD, filename: /proc/self/stat) = 65\n  3026.398 ( 0.076 ms): gnome-shell/3039 openat(dfd: CWD, filename: /proc/self/stat) = 65\n  4294.665 ( 0.015 ms): sed/15879 openat(dfd: CWD, filename: /etc/ld.so.cache, flags: CLOEXEC) = 3\n  $\n\nTrace the first minor page fault when running a workload:\n\n  # perf trace -F min --max-stack=7 --max-events 1 sleep 1\n     0.000 ( 0.000 ms): sleep/18006 minfault [__clear_user+0x1a] => 0x5626efa56080 (?k)\n                                       __clear_user ([kernel.kallsyms])\n                                       load_elf_binary ([kernel.kallsyms])\n                                       search_binary_handler ([kernel.kallsyms])\n                                       __do_execve_file.isra.33 ([kernel.kallsyms])\n                                       __x64_sys_execve ([kernel.kallsyms])\n                                       do_syscall_64 ([kernel.kallsyms])\n                                       entry_SYSCALL_64 ([kernel.kallsyms])\n  #\n\nTrace the next min page page fault to take place on the first CPU:\n\n  # perf trace -F min --call-graph=dwarf --max-events 1 --cpu 0\n     0.000 ( 0.000 ms): Web Content/17136 minfault [js::gc::Chunk::fetchNextDecommittedArena+0x4b] => 0x7fbe6181b000 (?.)\n                                       js::gc::FreeSpan::initAsEmpty (inlined)\n                                       js::gc::Arena::setAsNotAllocated (inlined)\n                                       js::gc::Chunk::fetchNextDecommittedArena (/usr/lib64/firefox/libxul.so)\n                                       js::gc::Chunk::allocateArena (/usr/lib64/firefox/libxul.so)\n                                       js::gc::GCRuntime::allocateArena (/usr/lib64/firefox/libxul.so)\n                                       js::gc::ArenaLists::allocateFromArena (/usr/lib64/firefox/libxul.so)\n                                       js::gc::GCRuntime::tryNewTenuredThing<JSString, (js::AllowGC)1> (inlined)\n                                       js::AllocateString<JSString, (js::AllowGC)1> (/usr/lib64/firefox/libxul.so)\n                                       js::Allocate<JSThinInlineString, (js::AllowGC)1> (inlined)\n                                       JSThinInlineString::new_<(js::AllowGC)1> (inlined)\n                                       AllocateInlineString<(js::AllowGC)1, unsigned char> (inlined)\n                                       js::ConcatStrings<(js::AllowGC)1> (/usr/lib64/firefox/libxul.so)\n                                       [0x18b26e6bc2bd] (/tmp/perf-17136.map)\n  #\n\nTrace the next two sched:sched_switch events, four block:*_plug events, the\nnext block:*_unplug and the next three net:*dev_queue events, this last one\nwith a backtrace of at most 16 entries, system wide:\n\n  # perf trace -e sched:*switch/nr=2/,block:*_plug/nr=4/,block:*_unplug/nr=1/,net:*dev_queue/nr=3,max-stack=16/\n     0.000 :0/0 sched:sched_switch:swapper/2:0 [120] S ==> rcu_sched:10 [120]\n     0.015 rcu_sched/10 sched:sched_switch:rcu_sched:10 [120] R ==> swapper/2:0 [120]\n   254.198 irq/50-iwlwifi/680 net:net_dev_queue:dev=wlp3s0 skbaddr=0xffff93498051f600 len=66\n                                       __dev_queue_xmit ([kernel.kallsyms])\n   273.977 :0/0 net:net_dev_queue:dev=wlp3s0 skbaddr=0xffff93498051f600 len=78\n                                       __dev_queue_xmit ([kernel.kallsyms])\n   274.007 :0/0 net:net_dev_queue:dev=wlp3s0 skbaddr=0xffff93498051ff00 len=78\n                                       __dev_queue_xmit ([kernel.kallsyms])\n  2930.140 kworker/u16:58/2722 block:block_plug:[kworker/u16:58]\n  2930.162 kworker/u16:58/2722 block:block_unplug:[kworker/u16:58] 1\n  4466.094 jbd2/dm-2-8/748 block:block_plug:[jbd2/dm-2-8]\n  8050.123 kworker/u16:30/2694 block:block_plug:[kworker/u16:30]\n  8050.271 kworker/u16:30/2694 block:block_plug:[kworker/u16:30]\n  #\n\nSEE ALSO\n--------\nlinkperf:perf-record[1], linkperf:perf-script[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}