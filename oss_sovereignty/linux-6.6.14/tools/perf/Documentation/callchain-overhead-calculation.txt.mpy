{
  "module_name": "callchain-overhead-calculation.txt",
  "hash_id": "0357d09071251bd358ee1becd506cd0c62b6c1893d9fc0ca270c20d53e4bf890",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/callchain-overhead-calculation.txt",
  "human_readable_source": "Overhead calculation\n--------------------\nThe overhead can be shown in two columns as 'Children' and 'Self' when\nperf collects callchains.  The 'self' overhead is simply calculated by\nadding all period values of the entry - usually a function (symbol).\nThis is the value that perf shows traditionally and sum of all the\n'self' overhead values should be 100%.\n\nThe 'children' overhead is calculated by adding all period values of\nthe child functions so that it can show the total overhead of the\nhigher level functions even if they don't directly execute much.\n'Children' here means functions that are called from another (parent)\nfunction.\n\nIt might be confusing that the sum of all the 'children' overhead\nvalues exceeds 100% since each of them is already an accumulation of\n'self' overhead of its child functions.  But with this enabled, users\ncan find which function has the most overhead even if samples are\nspread over the children.\n\nConsider the following example; there are three functions like below.\n\n-----------------------\nvoid foo(void) {\n    /* do something */\n}\n\nvoid bar(void) {\n    /* do something */\n    foo();\n}\n\nint main(void) {\n    bar()\n    return 0;\n}\n-----------------------\n\nIn this case 'foo' is a child of 'bar', and 'bar' is an immediate\nchild of 'main' so 'foo' also is a child of 'main'.  In other words,\n'main' is a parent of 'foo' and 'bar', and 'bar' is a parent of 'foo'.\n\nSuppose all samples are recorded in 'foo' and 'bar' only.  When it's\nrecorded with callchains the output will show something like below\nin the usual (self-overhead-only) output of perf report:\n\n----------------------------------\nOverhead  Symbol\n........  .....................\n  60.00%  foo\n          |\n          --- foo\n              bar\n              main\n              __libc_start_main\n\n  40.00%  bar\n          |\n          --- bar\n              main\n              __libc_start_main\n----------------------------------\n\nWhen the --children option is enabled, the 'self' overhead values of\nchild functions (i.e. 'foo' and 'bar') are added to the parents to\ncalculate the 'children' overhead.  In this case the report could be\ndisplayed as:\n\n-------------------------------------------\nChildren      Self  Symbol\n........  ........  ....................\n 100.00%     0.00%  __libc_start_main\n          |\n          --- __libc_start_main\n\n 100.00%     0.00%  main\n          |\n          --- main\n              __libc_start_main\n\n 100.00%    40.00%  bar\n          |\n          --- bar\n              main\n              __libc_start_main\n\n  60.00%    60.00%  foo\n          |\n          --- foo\n              bar\n              main\n              __libc_start_main\n-------------------------------------------\n\nIn the above output, the 'self' overhead of 'foo' (60%) was add to the\n'children' overhead of 'bar', 'main' and '\\_\\_libc_start_main'.\nLikewise, the 'self' overhead of 'bar' (40%) was added to the\n'children' overhead of 'main' and '\\_\\_libc_start_main'.\n\nSo '\\_\\_libc_start_main' and 'main' are shown first since they have\nsame (100%) 'children' overhead (even though they have zero 'self'\noverhead) and they are the parents of 'foo' and 'bar'.\n\nSince v3.16 the 'children' overhead is shown by default and the output\nis sorted by its values. The 'children' overhead is disabled by\nspecifying --no-children option on the command line or by adding\n'report.children = false' or 'top.children = false' in the perf config\nfile.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}