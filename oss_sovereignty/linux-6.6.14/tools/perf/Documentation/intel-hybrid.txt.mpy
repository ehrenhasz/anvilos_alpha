{
  "module_name": "intel-hybrid.txt",
  "hash_id": "3cfafa0ad615a04d7dabcd07909a739b4e119e6be79899a6da59b8ed0174f1cc",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/intel-hybrid.txt",
  "human_readable_source": "Intel hybrid support\n--------------------\nSupport for Intel hybrid events within perf tools.\n\nFor some Intel platforms, such as AlderLake, which is hybrid platform and\nit consists of atom cpu and core cpu. Each cpu has dedicated event list.\nPart of events are available on core cpu, part of events are available\non atom cpu and even part of events are available on both.\n\nKernel exports two new cpu pmus via sysfs:\n/sys/devices/cpu_core\n/sys/devices/cpu_atom\n\nThe 'cpus' files are created under the directories. For example,\n\ncat /sys/devices/cpu_core/cpus\n0-15\n\ncat /sys/devices/cpu_atom/cpus\n16-23\n\nIt indicates cpu0-cpu15 are core cpus and cpu16-cpu23 are atom cpus.\n\nAs before, use perf-list to list the symbolic event.\n\nperf list\n\ninst_retired.any\n\t[Fixed Counter: Counts the number of instructions retired. Unit: cpu_atom]\ninst_retired.any\n\t[Number of instructions retired. Fixed Counter - architectural event. Unit: cpu_core]\n\nThe 'Unit: xxx' is added to brief description to indicate which pmu\nthe event is belong to. Same event name but with different pmu can\nbe supported.\n\nEnable hybrid event with a specific pmu\n\nTo enable a core only event or atom only event, following syntax is supported:\n\n\tcpu_core/<event name>/\nor\n\tcpu_atom/<event name>/\n\nFor example, count the 'cycles' event on core cpus.\n\n\tperf stat -e cpu_core/cycles/\n\nCreate two events for one hardware event automatically\n\nWhen creating one event and the event is available on both atom and core,\ntwo events are created automatically. One is for atom, the other is for\ncore. Most of hardware events and cache events are available on both\ncpu_core and cpu_atom.\n\nFor hardware events, they have pre-defined configs (e.g. 0 for cycles).\nBut on hybrid platform, kernel needs to know where the event comes from\n(from atom or from core). The original perf event type PERF_TYPE_HARDWARE\ncan't carry pmu information. So now this type is extended to be PMU aware\ntype. The PMU type ID is stored at attr.config[63:32].\n\nPMU type ID is retrieved from sysfs.\n/sys/devices/cpu_atom/type\n/sys/devices/cpu_core/type\n\nThe new attr.config layout for PERF_TYPE_HARDWARE:\n\nPERF_TYPE_HARDWARE:                 0xEEEEEEEE000000AA\n                                    AA: hardware event ID\n                                    EEEEEEEE: PMU type ID\n\nCache event is similar. The type PERF_TYPE_HW_CACHE is extended to be\nPMU aware type. The PMU type ID is stored at attr.config[63:32].\n\nThe new attr.config layout for PERF_TYPE_HW_CACHE:\n\nPERF_TYPE_HW_CACHE:                 0xEEEEEEEE00DDCCBB\n                                    BB: hardware cache ID\n                                    CC: hardware cache op ID\n                                    DD: hardware cache op result ID\n                                    EEEEEEEE: PMU type ID\n\nWhen enabling a hardware event without specified pmu, such as,\nperf stat -e cycles -a (use system-wide in this example), two events\nare created automatically.\n\n  ------------------------------------------------------------\n  perf_event_attr:\n    size                             120\n    config                           0x400000000\n    sample_type                      IDENTIFIER\n    read_format                      TOTAL_TIME_ENABLED|TOTAL_TIME_RUNNING\n    disabled                         1\n    inherit                          1\n    exclude_guest                    1\n  ------------------------------------------------------------\n\nand\n\n  ------------------------------------------------------------\n  perf_event_attr:\n    size                             120\n    config                           0x800000000\n    sample_type                      IDENTIFIER\n    read_format                      TOTAL_TIME_ENABLED|TOTAL_TIME_RUNNING\n    disabled                         1\n    inherit                          1\n    exclude_guest                    1\n  ------------------------------------------------------------\n\ntype 0 is PERF_TYPE_HARDWARE.\n0x4 in 0x400000000 indicates it's cpu_core pmu.\n0x8 in 0x800000000 indicates it's cpu_atom pmu (atom pmu type id is random).\n\nThe kernel creates 'cycles' (0x400000000) on cpu0-cpu15 (core cpus),\nand create 'cycles' (0x800000000) on cpu16-cpu23 (atom cpus).\n\nFor perf-stat result, it displays two events:\n\n Performance counter stats for 'system wide':\n\n           6,744,979      cpu_core/cycles/\n           1,965,552      cpu_atom/cycles/\n\nThe first 'cycles' is core event, the second 'cycles' is atom event.\n\nThread mode example:\n\nperf-stat reports the scaled counts for hybrid event and with a percentage\ndisplayed. The percentage is the event's running time/enabling time.\n\nOne example, 'triad_loop' runs on cpu16 (atom core), while we can see the\nscaled value for core cycles is 160,444,092 and the percentage is 0.47%.\n\nperf stat -e cycles \\-- taskset -c 16 ./triad_loop\n\nAs previous, two events are created.\n\n------------------------------------------------------------\nperf_event_attr:\n  size                             120\n  config                           0x400000000\n  sample_type                      IDENTIFIER\n  read_format                      TOTAL_TIME_ENABLED|TOTAL_TIME_RUNNING\n  disabled                         1\n  inherit                          1\n  enable_on_exec                   1\n  exclude_guest                    1\n------------------------------------------------------------\n\nand\n\n------------------------------------------------------------\nperf_event_attr:\n  size                             120\n  config                           0x800000000\n  sample_type                      IDENTIFIER\n  read_format                      TOTAL_TIME_ENABLED|TOTAL_TIME_RUNNING\n  disabled                         1\n  inherit                          1\n  enable_on_exec                   1\n  exclude_guest                    1\n------------------------------------------------------------\n\n Performance counter stats for 'taskset -c 16 ./triad_loop':\n\n       233,066,666      cpu_core/cycles/                                              (0.43%)\n       604,097,080      cpu_atom/cycles/                                              (99.57%)\n\nperf-record:\n\nIf there is no '-e' specified in perf record, on hybrid platform,\nit creates two default 'cycles' and adds them to event list. One\nis for core, the other is for atom.\n\nperf-stat:\n\nIf there is no '-e' specified in perf stat, on hybrid platform,\nbesides of software events, following events are created and\nadded to event list in order.\n\ncpu_core/cycles/,\ncpu_atom/cycles/,\ncpu_core/instructions/,\ncpu_atom/instructions/,\ncpu_core/branches/,\ncpu_atom/branches/,\ncpu_core/branch-misses/,\ncpu_atom/branch-misses/\n\nOf course, both perf-stat and perf-record support to enable\nhybrid event with a specific pmu.\n\ne.g.\nperf stat -e cpu_core/cycles/\nperf stat -e cpu_atom/cycles/\nperf stat -e cpu_core/r1a/\nperf stat -e cpu_atom/L1-icache-loads/\nperf stat -e cpu_core/cycles/,cpu_atom/instructions/\nperf stat -e '{cpu_core/cycles/,cpu_core/instructions/}'\n\nBut '{cpu_core/cycles/,cpu_atom/instructions/}' will return\nwarning and disable grouping, because the pmus in group are\nnot matched (cpu_core vs. cpu_atom).\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}