{
  "module_name": "perf-intel-pt.txt",
  "hash_id": "9a50e414e1342109ea110a3eac83c2ec22c12098536502ae515398aa8a1561d0",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-intel-pt.txt",
  "human_readable_source": "perf-intel-pt(1)\n================\n\nNAME\n----\nperf-intel-pt - Support for Intel Processor Trace within perf tools\n\nSYNOPSIS\n--------\n[verse]\n'perf record' -e intel_pt//\n\nDESCRIPTION\n-----------\n\nIntel Processor Trace (Intel PT) is an extension of Intel Architecture that\ncollects information about software execution such as control flow, execution\nmodes and timings and formats it into highly compressed binary packets.\nTechnical details are documented in the Intel 64 and IA-32 Architectures\nSoftware Developer Manuals, Chapter 36 Intel Processor Trace.\n\nIntel PT is first supported in Intel Core M and 5th generation Intel Core\nprocessors that are based on the Intel micro-architecture code name Broadwell.\n\nTrace data is collected by 'perf record' and stored within the perf.data file.\nSee below for options to 'perf record'.\n\nTrace data must be 'decoded' which involves walking the object code and matching\nthe trace data packets. For example a TNT packet only tells whether a\nconditional branch was taken or not taken, so to make use of that packet the\ndecoder must know precisely which instruction was being executed.\n\nDecoding is done on-the-fly.  The decoder outputs samples in the same format as\nsamples output by perf hardware events, for example as though the \"instructions\"\nor \"branches\" events had been recorded.  Presently 3 tools support this:\n'perf script', 'perf report' and 'perf inject'.  See below for more information\non using those tools.\n\nThe main distinguishing feature of Intel PT is that the decoder can determine\nthe exact flow of software execution.  Intel PT can be used to understand why\nand how did software get to a certain point, or behave a certain way.  The\nsoftware does not have to be recompiled, so Intel PT works with debug or release\nbuilds, however the executed images are needed - which makes use in JIT-compiled\nenvironments, or with self-modified code, a challenge.  Also symbols need to be\nprovided to make sense of addresses.\n\nA limitation of Intel PT is that it produces huge amounts of trace data\n(hundreds of megabytes per second per core) which takes a long time to decode,\nfor example two or three orders of magnitude longer than it took to collect.\nAnother limitation is the performance impact of tracing, something that will\nvary depending on the use-case and architecture.\n\n\nQuickstart\n----------\n\nIt is important to start small.  That is because it is easy to capture vastly\nmore data than can possibly be processed.\n\nThe simplest thing to do with Intel PT is userspace profiling of small programs.\nData is captured with 'perf record' e.g. to trace 'ls' userspace-only:\n\n\tperf record -e intel_pt//u ls\n\nAnd profiled with 'perf report' e.g.\n\n\tperf report\n\nTo also trace kernel space presents a problem, namely kernel self-modifying\ncode.  A fairly good kernel image is available in /proc/kcore but to get an\naccurate image a copy of /proc/kcore needs to be made under the same conditions\nas the data capture. 'perf record' can make a copy of /proc/kcore if the option\n--kcore is used, but access to /proc/kcore is restricted e.g.\n\n\tsudo perf record -o pt_ls --kcore -e intel_pt// -- ls\n\nwhich will create a directory named 'pt_ls' and put the perf.data file (named\nsimply 'data') and copies of /proc/kcore, /proc/kallsyms and /proc/modules into\nit.  The other tools understand the directory format, so to use 'perf report'\nbecomes:\n\n\tsudo perf report -i pt_ls\n\nBecause samples are synthesized after-the-fact, the sampling period can be\nselected for reporting. e.g. sample every microsecond\n\n\tsudo perf report pt_ls --itrace=i1usge\n\nSee the sections below for more information about the --itrace option.\n\nBeware the smaller the period, the more samples that are produced, and the\nlonger it takes to process them.\n\nAlso note that the coarseness of Intel PT timing information will start to\ndistort the statistical value of the sampling as the sampling period becomes\nsmaller.\n\nTo represent software control flow, \"branches\" samples are produced.  By default\na branch sample is synthesized for every single branch.  To get an idea what\ndata is available you can use the 'perf script' tool with all itrace sampling\noptions, which will list all the samples.\n\n\tperf record -e intel_pt//u ls\n\tperf script --itrace=iybxwpe\n\nAn interesting field that is not printed by default is 'flags' which can be\ndisplayed as follows:\n\n\tperf script --itrace=iybxwpe -F+flags\n\nThe flags are \"bcrosyiABExghDt\" which stand for branch, call, return, conditional,\nsystem, asynchronous, interrupt, transaction abort, trace begin, trace end,\nin transaction, VM-entry, VM-exit, interrupt disabled, and interrupt disable\ntoggle respectively.\n\nperf script also supports higher level ways to dump instruction traces:\n\n\tperf script --insn-trace --xed\n\nDump all instructions. This requires installing the xed tool (see XED below)\nDumping all instructions in a long trace can be fairly slow. It is usually better\nto start with higher level decoding, like\n\n\tperf script --call-trace\n\nor\n\n\tperf script --call-ret-trace\n\nand then select a time range of interest. The time range can then be examined\nin detail with\n\n\tperf script --time starttime,stoptime --insn-trace --xed\n\nWhile examining the trace it's also useful to filter on specific CPUs using\nthe -C option\n\n\tperf script --time starttime,stoptime --insn-trace --xed -C 1\n\nDump all instructions in time range on CPU 1.\n\nAnother interesting field that is not printed by default is 'ipc' which can be\ndisplayed as follows:\n\n\tperf script --itrace=be -F+ipc\n\nThere are two ways that instructions-per-cycle (IPC) can be calculated depending\non the recording.\n\nIf the 'cyc' config term (see config terms section below) was used, then IPC\nand cycle events are calculated using the cycle count from CYC packets, otherwise\nMTC packets are used - refer to the 'mtc' config term.  When MTC is used, however,\nthe values are less accurate because the timing is less accurate.\n\nBecause Intel PT does not update the cycle count on every branch or instruction,\nthe values will often be zero.  When there are values, they will be the number\nof instructions and number of cycles since the last update, and thus represent\nthe average IPC cycle count since the last IPC for that event type.\nNote IPC for \"branches\" events is calculated separately from IPC for \"instructions\"\nevents.\n\nEven with the 'cyc' config term, it is possible to produce IPC information for\nevery change of timestamp, but at the expense of accuracy.  That is selected by\nspecifying the itrace 'A' option.  Due to the granularity of timestamps, the\nactual number of cycles increases even though the cycles reported does not.\nThe number of instructions is known, but if IPC is reported, cycles can be too\nlow and so IPC is too high.  Note that inaccuracy decreases as the period of\nsampling increases i.e. if the number of cycles is too low by a small amount,\nthat becomes less significant if the number of cycles is large.  It may also be\nuseful to use the 'A' option in conjunction with dlfilter-show-cycles.so to\nprovide higher granularity cycle information.\n\nAlso note that the IPC instruction count may or may not include the current\ninstruction.  If the cycle count is associated with an asynchronous branch\n(e.g. page fault or interrupt), then the instruction count does not include the\ncurrent instruction, otherwise it does.  That is consistent with whether or not\nthat instruction has retired when the cycle count is updated.\n\nAnother note, in the case of \"branches\" events, non-taken branches are not\npresently sampled, so IPC values for them do not appear e.g. a CYC packet with a\nTNT packet that starts with a non-taken branch.  To see every possible IPC\nvalue, \"instructions\" events can be used e.g. --itrace=i0ns\n\nWhile it is possible to create scripts to analyze the data, an alternative\napproach is available to export the data to a sqlite or postgresql database.\nRefer to script export-to-sqlite.py or export-to-postgresql.py for more details,\nand to script exported-sql-viewer.py for an example of using the database.\n\nThere is also script intel-pt-events.py which provides an example of how to\nunpack the raw data for power events and PTWRITE. The script also displays\nbranches, and supports 2 additional modes selected by option:\n\n - --insn-trace - instruction trace\n - --src-trace - source trace\n\nThe intel-pt-events.py script also has options:\n\n - --all-switch-events - display all switch events, not only the last consecutive.\n - --interleave [<n>] - interleave sample output for the same timestamp so that\n no more than n samples for a CPU are displayed in a row. 'n' defaults to 4.\n Note this only affects the order of output, and only when the timestamp is the\n same.\n\nAs mentioned above, it is easy to capture too much data.  One way to limit the\ndata captured is to use 'snapshot' mode which is explained further below.\nRefer to 'new snapshot option' and 'Intel PT modes of operation' further below.\n\nAnother problem that will be experienced is decoder errors.  They can be caused\nby inability to access the executed image, self-modified or JIT-ed code, or the\ninability to match side-band information (such as context switches and mmaps)\nwhich results in the decoder not knowing what code was executed.\n\nThere is also the problem of perf not being able to copy the data fast enough,\nresulting in data lost because the buffer was full.  See 'Buffer handling' below\nfor more details.\n\n\nperf record\n-----------\n\nnew event\n~~~~~~~~~\n\nThe Intel PT kernel driver creates a new PMU for Intel PT.  PMU events are\nselected by providing the PMU name followed by the \"config\" separated by slashes.\nAn enhancement has been made to allow default \"config\" e.g. the option\n\n\t-e intel_pt//\n\nwill use a default config value.  Currently that is the same as\n\n\t-e intel_pt/tsc,noretcomp=0/\n\nwhich is the same as\n\n\t-e intel_pt/tsc=1,noretcomp=0/\n\nNote there are now new config terms - see section 'config terms' further below.\n\nThe config terms are listed in /sys/devices/intel_pt/format.  They are bit\nfields within the config member of the struct perf_event_attr which is\npassed to the kernel by the perf_event_open system call.  They correspond to bit\nfields in the IA32_RTIT_CTL MSR.  Here is a list of them and their definitions:\n\n\t$ grep -H . /sys/bus/event_source/devices/intel_pt/format/*\n\t/sys/bus/event_source/devices/intel_pt/format/cyc:config:1\n\t/sys/bus/event_source/devices/intel_pt/format/cyc_thresh:config:19-22\n\t/sys/bus/event_source/devices/intel_pt/format/mtc:config:9\n\t/sys/bus/event_source/devices/intel_pt/format/mtc_period:config:14-17\n\t/sys/bus/event_source/devices/intel_pt/format/noretcomp:config:11\n\t/sys/bus/event_source/devices/intel_pt/format/psb_period:config:24-27\n\t/sys/bus/event_source/devices/intel_pt/format/tsc:config:10\n\nNote that the default config must be overridden for each term i.e.\n\n\t-e intel_pt/noretcomp=0/\n\nis the same as:\n\n\t-e intel_pt/tsc=1,noretcomp=0/\n\nSo, to disable TSC packets use:\n\n\t-e intel_pt/tsc=0/\n\nIt is also possible to specify the config value explicitly:\n\n\t-e intel_pt/config=0x400/\n\nNote that, as with all events, the event is suffixed with event modifiers:\n\n\tu\tuserspace\n\tk\tkernel\n\th\thypervisor\n\tG\tguest\n\tH\thost\n\tp\tprecise ip\n\n'h', 'G' and 'H' are for virtualization which are not used by Intel PT.\n'p' is also not relevant to Intel PT.  So only options 'u' and 'k' are\nmeaningful for Intel PT.\n\nperf_event_attr is displayed if the -vv option is used e.g.\n\n\t------------------------------------------------------------\n\tperf_event_attr:\n\ttype                             6\n\tsize                             112\n\tconfig                           0x400\n\t{ sample_period, sample_freq }   1\n\tsample_type                      IP|TID|TIME|CPU|IDENTIFIER\n\tread_format                      ID\n\tdisabled                         1\n\tinherit                          1\n\texclude_kernel                   1\n\texclude_hv                       1\n\tenable_on_exec                   1\n\tsample_id_all                    1\n\t------------------------------------------------------------\n\tsys_perf_event_open: pid 31104  cpu 0  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid 31104  cpu 1  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid 31104  cpu 2  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid 31104  cpu 3  group_fd -1  flags 0x8\n\t------------------------------------------------------------\n\n\nconfig terms\n~~~~~~~~~~~~\n\nThe June 2015 version of Intel 64 and IA-32 Architectures Software Developer\nManuals, Chapter 36 Intel Processor Trace, defined new Intel PT features.\nSome of the features are reflect in new config terms.  All the config terms are\ndescribed below.\n\ntsc\t\tAlways supported.  Produces TSC timestamp packets to provide\n\t\ttiming information.  In some cases it is possible to decode\n\t\twithout timing information, for example a per-thread context\n\t\tthat does not overlap executable memory maps.\n\n\t\tThe default config selects tsc (i.e. tsc=1).\n\nnoretcomp\tAlways supported.  Disables \"return compression\" so a TIP packet\n\t\tis produced when a function returns.  Causes more packets to be\n\t\tproduced but might make decoding more reliable.\n\n\t\tThe default config does not select noretcomp (i.e. noretcomp=0).\n\npsb_period\tAllows the frequency of PSB packets to be specified.\n\n\t\tThe PSB packet is a synchronization packet that provides a\n\t\tstarting point for decoding or recovery from errors.\n\n\t\tSupport for psb_period is indicated by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/psb_cyc\n\n\t\twhich contains \"1\" if the feature is supported and \"0\"\n\t\totherwise.\n\n\t\tValid values are given by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/psb_periods\n\n\t\twhich contains a hexadecimal value, the bits of which represent\n\t\tvalid values e.g. bit 2 set means value 2 is valid.\n\n\t\tThe psb_period value is converted to the approximate number of\n\t\ttrace bytes between PSB packets as:\n\n\t\t\t2 ^ (value + 11)\n\n\t\te.g. value 3 means 16KiB bytes between PSBs\n\n\t\tIf an invalid value is entered, the error message\n\t\twill give a list of valid values e.g.\n\n\t\t\t$ perf record -e intel_pt/psb_period=15/u uname\n\t\t\tInvalid psb_period for intel_pt. Valid values are: 0-5\n\n\t\tIf MTC packets are selected, the default config selects a value\n\t\tof 3 (i.e. psb_period=3) or the nearest lower value that is\n\t\tsupported (0 is always supported).  Otherwise the default is 0.\n\n\t\tIf decoding is expected to be reliable and the buffer is large\n\t\tthen a large PSB period can be used.\n\n\t\tBecause a TSC packet is produced with PSB, the PSB period can\n\t\talso affect the granularity to timing information in the absence\n\t\tof MTC or CYC.\n\nmtc\t\tProduces MTC timing packets.\n\n\t\tMTC packets provide finer grain timestamp information than TSC\n\t\tpackets.  MTC packets record time using the hardware crystal\n\t\tclock (CTC) which is related to TSC packets using a TMA packet.\n\n\t\tSupport for this feature is indicated by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/mtc\n\n\t\twhich contains \"1\" if the feature is supported and\n\t\t\"0\" otherwise.\n\n\t\tThe frequency of MTC packets can also be specified - see\n\t\tmtc_period below.\n\nmtc_period\tSpecifies how frequently MTC packets are produced - see mtc\n\t\tabove for how to determine if MTC packets are supported.\n\n\t\tValid values are given by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/mtc_periods\n\n\t\twhich contains a hexadecimal value, the bits of which represent\n\t\tvalid values e.g. bit 2 set means value 2 is valid.\n\n\t\tThe mtc_period value is converted to the MTC frequency as:\n\n\t\t\tCTC-frequency / (2 ^ value)\n\n\t\te.g. value 3 means one eighth of CTC-frequency\n\n\t\tWhere CTC is the hardware crystal clock, the frequency of which\n\t\tcan be related to TSC via values provided in cpuid leaf 0x15.\n\n\t\tIf an invalid value is entered, the error message\n\t\twill give a list of valid values e.g.\n\n\t\t\t$ perf record -e intel_pt/mtc_period=15/u uname\n\t\t\tInvalid mtc_period for intel_pt. Valid values are: 0,3,6,9\n\n\t\tThe default value is 3 or the nearest lower value\n\t\tthat is supported (0 is always supported).\n\ncyc\t\tProduces CYC timing packets.\n\n\t\tCYC packets provide even finer grain timestamp information than\n\t\tMTC and TSC packets.  A CYC packet contains the number of CPU\n\t\tcycles since the last CYC packet. Unlike MTC and TSC packets,\n\t\tCYC packets are only sent when another packet is also sent.\n\n\t\tSupport for this feature is indicated by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/psb_cyc\n\n\t\twhich contains \"1\" if the feature is supported and\n\t\t\"0\" otherwise.\n\n\t\tThe number of CYC packets produced can be reduced by specifying\n\t\ta threshold - see cyc_thresh below.\n\ncyc_thresh\tSpecifies how frequently CYC packets are produced - see cyc\n\t\tabove for how to determine if CYC packets are supported.\n\n\t\tValid cyc_thresh values are given by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds\n\n\t\twhich contains a hexadecimal value, the bits of which represent\n\t\tvalid values e.g. bit 2 set means value 2 is valid.\n\n\t\tThe cyc_thresh value represents the minimum number of CPU cycles\n\t\tthat must have passed before a CYC packet can be sent.  The\n\t\tnumber of CPU cycles is:\n\n\t\t\t2 ^ (value - 1)\n\n\t\te.g. value 4 means 8 CPU cycles must pass before a CYC packet\n\t\tcan be sent.  Note a CYC packet is still only sent when another\n\t\tpacket is sent, not at, e.g. every 8 CPU cycles.\n\n\t\tIf an invalid value is entered, the error message\n\t\twill give a list of valid values e.g.\n\n\t\t\t$ perf record -e intel_pt/cyc,cyc_thresh=15/u uname\n\t\t\tInvalid cyc_thresh for intel_pt. Valid values are: 0-12\n\n\t\tCYC packets are not requested by default.\n\npt\t\tSpecifies pass-through which enables the 'branch' config term.\n\n\t\tThe default config selects 'pt' if it is available, so a user will\n\t\tnever need to specify this term.\n\nbranch\t\tEnable branch tracing.  Branch tracing is enabled by default so to\n\t\tdisable branch tracing use 'branch=0'.\n\n\t\tThe default config selects 'branch' if it is available.\n\nptw\t\tEnable PTWRITE packets which are produced when a ptwrite instruction\n\t\tis executed.\n\n\t\tSupport for this feature is indicated by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/ptwrite\n\n\t\twhich contains \"1\" if the feature is supported and\n\t\t\"0\" otherwise.\n\n\t\tAs an alternative, refer to \"Emulated PTWRITE\" further below.\n\nfup_on_ptw\tEnable a FUP packet to follow the PTWRITE packet.  The FUP packet\n\t\tprovides the address of the ptwrite instruction.  In the absence of\n\t\tfup_on_ptw, the decoder will use the address of the previous branch\n\t\tif branch tracing is enabled, otherwise the address will be zero.\n\t\tNote that fup_on_ptw will work even when branch tracing is disabled.\n\npwr_evt\t\tEnable power events.  The power events provide information about\n\t\tchanges to the CPU C-state.\n\n\t\tSupport for this feature is indicated by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/power_event_trace\n\n\t\twhich contains \"1\" if the feature is supported and\n\t\t\"0\" otherwise.\n\nevent\t\tEnable Event Trace.  The events provide information about asynchronous\n\t\tevents.\n\n\t\tSupport for this feature is indicated by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/event_trace\n\n\t\twhich contains \"1\" if the feature is supported and\n\t\t\"0\" otherwise.\n\nnotnt\t\tDisable TNT packets.  Without TNT packets, it is not possible to walk\n\t\texecutable code to reconstruct control flow, however FUP, TIP, TIP.PGE\n\t\tand TIP.PGD packets still indicate asynchronous control flow, and (if\n\t\treturn compression is disabled - see noretcomp) return statements.\n\t\tThe advantage of eliminating TNT packets is reducing the size of the\n\t\ttrace and corresponding tracing overhead.\n\n\t\tSupport for this feature is indicated by:\n\n\t\t\t/sys/bus/event_source/devices/intel_pt/caps/tnt_disable\n\n\t\twhich contains \"1\" if the feature is supported and\n\t\t\"0\" otherwise.\n\n\nAUX area sampling option\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nTo select Intel PT \"sampling\" the AUX area sampling option can be used:\n\n\t--aux-sample\n\nOptionally it can be followed by the sample size in bytes e.g.\n\n\t--aux-sample=8192\n\nIn addition, the Intel PT event to sample must be defined e.g.\n\n\t-e intel_pt//u\n\nSamples on other events will be created containing Intel PT data e.g. the\nfollowing will create Intel PT samples on the branch-misses event, note the\nevents must be grouped using {}:\n\n\tperf record --aux-sample -e '{intel_pt//u,branch-misses:u}'\n\nAn alternative to '--aux-sample' is to add the config term 'aux-sample-size' to\nevents.  In this case, the grouping is implied e.g.\n\n\tperf record -e intel_pt//u -e branch-misses/aux-sample-size=8192/u\n\nis the same as:\n\n\tperf record -e '{intel_pt//u,branch-misses/aux-sample-size=8192/u}'\n\nbut allows for also using an address filter e.g.:\n\n\tperf record -e intel_pt//u --filter 'filter * @/bin/ls' -e branch-misses/aux-sample-size=8192/u -- ls\n\nIt is important to select a sample size that is big enough to contain at least\none PSB packet.  If not a warning will be displayed:\n\n\tIntel PT sample size (%zu) may be too small for PSB period (%zu)\n\nThe calculation used for that is: if sample_size <= psb_period + 256 display the\nwarning.  When sampling is used, psb_period defaults to 0 (2KiB).\n\nThe default sample size is 4KiB.\n\nThe sample size is passed in aux_sample_size in struct perf_event_attr.  The\nsample size is limited by the maximum event size which is 64KiB.  It is\ndifficult to know how big the event might be without the trace sample attached,\nbut the tool validates that the sample size is not greater than 60KiB.\n\n\nnew snapshot option\n~~~~~~~~~~~~~~~~~~~\n\nThe difference between full trace and snapshot from the kernel's perspective is\nthat in full trace we don't overwrite trace data that the user hasn't collected\nyet (and indicated that by advancing aux_tail), whereas in snapshot mode we let\nthe trace run and overwrite older data in the buffer so that whenever something\ninteresting happens, we can stop it and grab a snapshot of what was going on\naround that interesting moment.\n\nTo select snapshot mode a new option has been added:\n\n\t-S\n\nOptionally it can be followed by the snapshot size e.g.\n\n\t-S0x100000\n\nThe default snapshot size is the auxtrace mmap size.  If neither auxtrace mmap size\nnor snapshot size is specified, then the default is 4MiB for privileged users\n(or if /proc/sys/kernel/perf_event_paranoid < 0), 128KiB for unprivileged users.\nIf an unprivileged user does not specify mmap pages, the mmap pages will be\nreduced as described in the 'new auxtrace mmap size option' section below.\n\nThe snapshot size is displayed if the option -vv is used e.g.\n\n\tIntel PT snapshot size: %zu\n\n\nnew auxtrace mmap size option\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIntel PT buffer size is specified by an addition to the -m option e.g.\n\n\t-m,16\n\nselects a buffer size of 16 pages i.e. 64KiB.\n\nNote that the existing functionality of -m is unchanged.  The auxtrace mmap size\nis specified by the optional addition of a comma and the value.\n\nThe default auxtrace mmap size for Intel PT is 4MiB/page_size for privileged users\n(or if /proc/sys/kernel/perf_event_paranoid < 0), 128KiB for unprivileged users.\nIf an unprivileged user does not specify mmap pages, the mmap pages will be\nreduced from the default 512KiB/page_size to 256KiB/page_size, otherwise the\nuser is likely to get an error as they exceed their mlock limit (Max locked\nmemory as shown in /proc/self/limits).  Note that perf does not count the first\n512KiB (actually /proc/sys/kernel/perf_event_mlock_kb minus 1 page) per cpu\nagainst the mlock limit so an unprivileged user is allowed 512KiB per cpu plus\ntheir mlock limit (which defaults to 64KiB but is not multiplied by the number\nof cpus).\n\nIn full-trace mode, powers of two are allowed for buffer size, with a minimum\nsize of 2 pages.  In snapshot mode or sampling mode, it is the same but the\nminimum size is 1 page.\n\nThe mmap size and auxtrace mmap size are displayed if the -vv option is used e.g.\n\n\tmmap length 528384\n\tauxtrace mmap length 4198400\n\n\nIntel PT modes of operation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIntel PT can be used in 3 modes:\n\tfull-trace mode\n\tsample mode\n\tsnapshot mode\n\nFull-trace mode traces continuously e.g.\n\n\tperf record -e intel_pt//u uname\n\nSample mode attaches a Intel PT sample to other events e.g.\n\n\tperf record --aux-sample -e intel_pt//u -e branch-misses:u\n\nSnapshot mode captures the available data when a signal is sent or \"snapshot\"\ncontrol command is issued. e.g. using a signal\n\n\tperf record -v -e intel_pt//u -S ./loopy 1000000000 &\n\t[1] 11435\n\tkill -USR2 11435\n\tRecording AUX area tracing snapshot\n\nNote that the signal sent is SIGUSR2.\nNote that \"Recording AUX area tracing snapshot\" is displayed because the -v\noption is used.\n\nThe advantage of using \"snapshot\" control command is that the access is\ncontrolled by access to a FIFO e.g.\n\n\t$ mkfifo perf.control\n\t$ mkfifo perf.ack\n\t$ cat perf.ack &\n\t[1] 15235\n\t$ sudo ~/bin/perf record --control fifo:perf.control,perf.ack -S -e intel_pt//u -- sleep 60 &\n\t[2] 15243\n\t$ ps -e | grep perf\n\t15244 pts/1    00:00:00 perf\n\t$ kill -USR2 15244\n\tbash: kill: (15244) - Operation not permitted\n\t$ echo snapshot > perf.control\n\tack\n\nThe 3 Intel PT modes of operation cannot be used together.\n\n\nBuffer handling\n~~~~~~~~~~~~~~~\n\nThere may be buffer limitations (i.e. single ToPa entry) which means that actual\nbuffer sizes are limited to powers of 2 up to 4MiB (MAX_ORDER).  In order to\nprovide other sizes, and in particular an arbitrarily large size, multiple\nbuffers are logically concatenated.  However an interrupt must be used to switch\nbetween buffers.  That has two potential problems:\n\ta) the interrupt may not be handled in time so that the current buffer\n\tbecomes full and some trace data is lost.\n\tb) the interrupts may slow the system and affect the performance\n\tresults.\n\nIf trace data is lost, the driver sets 'truncated' in the PERF_RECORD_AUX event\nwhich the tools report as an error.\n\nIn full-trace mode, the driver waits for data to be copied out before allowing\nthe (logical) buffer to wrap-around.  If data is not copied out quickly enough,\nagain 'truncated' is set in the PERF_RECORD_AUX event.  If the driver has to\nwait, the intel_pt event gets disabled.  Because it is difficult to know when\nthat happens, perf tools always re-enable the intel_pt event after copying out\ndata.\n\n\nIntel PT and build ids\n~~~~~~~~~~~~~~~~~~~~~~\n\nBy default \"perf record\" post-processes the event stream to find all build ids\nfor executables for all addresses sampled.  Deliberately, Intel PT is not\ndecoded for that purpose (it would take too long).  Instead the build ids for\nall executables encountered (due to mmap, comm or task events) are included\nin the perf.data file.\n\nTo see buildids included in the perf.data file use the command:\n\n\tperf buildid-list\n\nIf the perf.data file contains Intel PT data, that is the same as:\n\n\tperf buildid-list --with-hits\n\n\nSnapshot mode and event disabling\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn order to make a snapshot, the intel_pt event is disabled using an IOCTL,\nnamely PERF_EVENT_IOC_DISABLE.  However doing that can also disable the\ncollection of side-band information.  In order to prevent that,  a dummy\nsoftware event has been introduced that permits tracking events (like mmaps) to\ncontinue to be recorded while intel_pt is disabled.  That is important to ensure\nthere is complete side-band information to allow the decoding of subsequent\nsnapshots.\n\nA test has been created for that.  To find the test:\n\n\tperf test list\n\t...\n\t23: Test using a dummy software event to keep tracking\n\nTo run the test:\n\n\tperf test 23\n\t23: Test using a dummy software event to keep tracking     : Ok\n\n\nperf record modes (nothing new here)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nperf record essentially operates in one of three modes:\n\tper thread\n\tper cpu\n\tworkload only\n\n\"per thread\" mode is selected by -t or by --per-thread (with -p or -u or just a\nworkload).\n\"per cpu\" is selected by -C or -a.\n\"workload only\" mode is selected by not using the other options but providing a\ncommand to run (i.e. the workload).\n\nIn per-thread mode an exact list of threads is traced.  There is no inheritance.\nEach thread has its own event buffer.\n\nIn per-cpu mode all processes (or processes from the selected cgroup i.e. -G\noption, or processes selected with -p or -u) are traced.  Each cpu has its own\nbuffer. Inheritance is allowed.\n\nIn workload-only mode, the workload is traced but with per-cpu buffers.\nInheritance is allowed.  Note that you can now trace a workload in per-thread\nmode by using the --per-thread option.\n\n\nPrivileged vs non-privileged users\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nUnless /proc/sys/kernel/perf_event_paranoid is set to -1, unprivileged users\nhave memory limits imposed upon them.  That affects what buffer sizes they can\nhave as outlined above.\n\nThe v4.2 kernel introduced support for a context switch metadata event,\nPERF_RECORD_SWITCH, which allows unprivileged users to see when their processes\nare scheduled out and in, just not by whom, which is left for the\nPERF_RECORD_SWITCH_CPU_WIDE, that is only accessible in system wide context,\nwhich in turn requires CAP_PERFMON or CAP_SYS_ADMIN.\n\nPlease see the 45ac1403f564 (\"perf: Add PERF_RECORD_SWITCH to indicate context\nswitches\") commit, that introduces these metadata events for further info.\n\nWhen working with kernels < v4.2, the following considerations must be taken,\nas the sched:sched_switch tracepoints will be used to receive such information:\n\nUnless /proc/sys/kernel/perf_event_paranoid is set to -1, unprivileged users are\nnot permitted to use tracepoints which means there is insufficient side-band\ninformation to decode Intel PT in per-cpu mode, and potentially workload-only\nmode too if the workload creates new processes.\n\nNote also, that to use tracepoints, read-access to debugfs is required.  So if\ndebugfs is not mounted or the user does not have read-access, it will again not\nbe possible to decode Intel PT in per-cpu mode.\n\n\nsched_switch tracepoint\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThe sched_switch tracepoint is used to provide side-band data for Intel PT\ndecoding in kernels where the PERF_RECORD_SWITCH metadata event isn't\navailable.\n\nThe sched_switch events are automatically added. e.g. the second event shown\nbelow:\n\n\t$ perf record -vv -e intel_pt//u uname\n\t------------------------------------------------------------\n\tperf_event_attr:\n\ttype                             6\n\tsize                             112\n\tconfig                           0x400\n\t{ sample_period, sample_freq }   1\n\tsample_type                      IP|TID|TIME|CPU|IDENTIFIER\n\tread_format                      ID\n\tdisabled                         1\n\tinherit                          1\n\texclude_kernel                   1\n\texclude_hv                       1\n\tenable_on_exec                   1\n\tsample_id_all                    1\n\t------------------------------------------------------------\n\tsys_perf_event_open: pid 31104  cpu 0  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid 31104  cpu 1  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid 31104  cpu 2  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid 31104  cpu 3  group_fd -1  flags 0x8\n\t------------------------------------------------------------\n\tperf_event_attr:\n\ttype                             2\n\tsize                             112\n\tconfig                           0x108\n\t{ sample_period, sample_freq }   1\n\tsample_type                      IP|TID|TIME|CPU|PERIOD|RAW|IDENTIFIER\n\tread_format                      ID\n\tinherit                          1\n\tsample_id_all                    1\n\texclude_guest                    1\n\t------------------------------------------------------------\n\tsys_perf_event_open: pid -1  cpu 0  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid -1  cpu 1  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid -1  cpu 2  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid -1  cpu 3  group_fd -1  flags 0x8\n\t------------------------------------------------------------\n\tperf_event_attr:\n\ttype                             1\n\tsize                             112\n\tconfig                           0x9\n\t{ sample_period, sample_freq }   1\n\tsample_type                      IP|TID|TIME|IDENTIFIER\n\tread_format                      ID\n\tdisabled                         1\n\tinherit                          1\n\texclude_kernel                   1\n\texclude_hv                       1\n\tmmap                             1\n\tcomm                             1\n\tenable_on_exec                   1\n\ttask                             1\n\tsample_id_all                    1\n\tmmap2                            1\n\tcomm_exec                        1\n\t------------------------------------------------------------\n\tsys_perf_event_open: pid 31104  cpu 0  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid 31104  cpu 1  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid 31104  cpu 2  group_fd -1  flags 0x8\n\tsys_perf_event_open: pid 31104  cpu 3  group_fd -1  flags 0x8\n\tmmap size 528384B\n\tAUX area mmap length 4194304\n\tperf event ring buffer mmapped per cpu\n\tSynthesizing auxtrace information\n\tLinux\n\t[ perf record: Woken up 1 times to write data ]\n\t[ perf record: Captured and wrote 0.042 MB perf.data ]\n\nNote, the sched_switch event is only added if the user is permitted to use it\nand only in per-cpu mode.\n\nNote also, the sched_switch event is only added if TSC packets are requested.\nThat is because, in the absence of timing information, the sched_switch events\ncannot be matched against the Intel PT trace.\n\n\nperf script\n-----------\n\nBy default, perf script will decode trace data found in the perf.data file.\nThis can be further controlled by new option --itrace.\n\n\nNew --itrace option\n~~~~~~~~~~~~~~~~~~~\n\nHaving no option is the same as\n\n\t--itrace\n\nwhich, in turn, is the same as\n\n\t--itrace=cepwxy\n\nThe letters are:\n\n\ti\tsynthesize \"instructions\" events\n\ty\tsynthesize \"cycles\" events\n\tb\tsynthesize \"branches\" events\n\tx\tsynthesize \"transactions\" events\n\tw\tsynthesize \"ptwrite\" events\n\tp\tsynthesize \"power\" events (incl. PSB events)\n\tc\tsynthesize branches events (calls only)\n\tr\tsynthesize branches events (returns only)\n\to\tsynthesize PEBS-via-PT events\n\tI\tsynthesize Event Trace events\n\te\tsynthesize tracing error events\n\td\tcreate a debug log\n\tg\tsynthesize a call chain (use with i or x)\n\tG\tsynthesize a call chain on existing event records\n\tl\tsynthesize last branch entries (use with i or x)\n\tL\tsynthesize last branch entries on existing event records\n\ts\tskip initial number of events\n\tq\tquicker (less detailed) decoding\n\tA\tapproximate IPC\n\tZ\tprefer to ignore timestamps (so-called \"timeless\" decoding)\n\n\"Instructions\" events look like they were recorded by \"perf record -e\ninstructions\".\n\n\"Cycles\" events look like they were recorded by \"perf record -e cycles\"\n(ie., the default). Note that even with CYC packets enabled and no sampling,\nthese are not fully accurate, since CYC packets are not emitted for each\ninstruction, only when some other event (like an indirect branch, or a\nTNT packet representing multiple branches) happens causes a packet to\nbe emitted. Thus, it is more effective for attributing cycles to functions\n(and possibly basic blocks) than to individual instructions, although it\nis not even perfect for functions (although it becomes better if the noretcomp\noption is active).\n\n\"Branches\" events look like they were recorded by \"perf record -e branches\". \"c\"\nand \"r\" can be combined to get calls and returns.\n\n\"Transactions\" events correspond to the start or end of transactions. The\n'flags' field can be used in perf script to determine whether the event is a\ntransaction start, commit or abort.\n\nNote that \"instructions\", \"cycles\", \"branches\" and \"transactions\" events\ndepend on code flow packets which can be disabled by using the config term\n\"branch=0\".  Refer to the config terms section above.\n\n\"ptwrite\" events record the payload of the ptwrite instruction and whether\n\"fup_on_ptw\" was used.  \"ptwrite\" events depend on PTWRITE packets which are\nrecorded only if the \"ptw\" config term was used.  Refer to the config terms\nsection above.  perf script \"synth\" field displays \"ptwrite\" information like\nthis: \"ip: 0 payload: 0x123456789abcdef0\"  where \"ip\" is 1 if \"fup_on_ptw\" was\nused.\n\n\"Power\" events correspond to power event packets and CBR (core-to-bus ratio)\npackets.  While CBR packets are always recorded when tracing is enabled, power\nevent packets are recorded only if the \"pwr_evt\" config term was used.  Refer to\nthe config terms section above.  The power events record information about\nC-state changes, whereas CBR is indicative of CPU frequency.  perf script\n\"event,synth\" fields display information like this:\n\n\tcbr:  cbr: 22 freq: 2189 MHz (200%)\n\tmwait:  hints: 0x60 extensions: 0x1\n\tpwre:  hw: 0 cstate: 2 sub-cstate: 0\n\texstop:  ip: 1\n\tpwrx:  deepest cstate: 2 last cstate: 2 wake reason: 0x4\n\nWhere:\n\n\t\"cbr\" includes the frequency and the percentage of maximum non-turbo\n\t\"mwait\" shows mwait hints and extensions\n\t\"pwre\" shows C-state transitions (to a C-state deeper than C0) and\n\twhether\tinitiated by hardware\n\t\"exstop\" indicates execution stopped and whether the IP was recorded\n\texactly,\n\t\"pwrx\" indicates return to C0\n\nFor more details refer to the Intel 64 and IA-32 Architectures Software\nDeveloper Manuals.\n\nPSB events show when a PSB+ occurred and also the byte-offset in the trace.\nEmitting a PSB+ can cause a CPU a slight delay. When doing timing analysis\nof code with Intel PT, it is useful to know if a timing bubble was caused\nby Intel PT or not.\n\nError events show where the decoder lost the trace.  Error events\nare quite important.  Users must know if what they are seeing is a complete\npicture or not. The \"e\" option may be followed by flags which affect what errors\nwill or will not be reported.  Each flag must be preceded by either '+' or '-'.\nThe flags supported by Intel PT are:\n\n\t\t-o\tSuppress overflow errors\n\t\t-l\tSuppress trace data lost errors\n\nFor example, for errors but not overflow or data lost errors:\n\n\t--itrace=e-o-l\n\nThe \"d\" option will cause the creation of a file \"intel_pt.log\" containing all\ndecoded packets and instructions.  Note that this option slows down the decoder\nand that the resulting file may be very large.  The \"d\" option may be followed\nby flags which affect what debug messages will or will not be logged. Each flag\nmust be preceded by either '+' or '-'. The flags support by Intel PT are:\n\n\t\t-a\tSuppress logging of perf events\n\t\t+a\tLog all perf events\n\t\t+e\tOutput only on decoding errors (size configurable)\n\t\t+o\tOutput to stdout instead of \"intel_pt.log\"\n\nBy default, logged perf events are filtered by any specified time ranges, but\nflag +a overrides that.  The +e flag can be useful for analyzing errors.  By\ndefault, the log size in that case is 16384 bytes, but can be altered by\nlinkperf:perf-config[1] e.g. perf config itrace.debug-log-buffer-size=30000\n\nIn addition, the period of the \"instructions\" event can be specified. e.g.\n\n\t--itrace=i10us\n\nsets the period to 10us i.e. one  instruction sample is synthesized for each 10\nmicroseconds of trace.  Alternatives to \"us\" are \"ms\" (milliseconds),\n\"ns\" (nanoseconds), \"t\" (TSC ticks) or \"i\" (instructions).\n\n\"ms\", \"us\" and \"ns\" are converted to TSC ticks.\n\nThe timing information included with Intel PT does not give the time of every\ninstruction.  Consequently, for the purpose of sampling, the decoder estimates\nthe time since the last timing packet based on 1 tick per instruction.  The time\non the sample is *not* adjusted and reflects the last known value of TSC.\n\nFor Intel PT, the default period is 100us.\n\nSetting it to a zero period means \"as often as possible\".\n\nIn the case of Intel PT that is the same as a period of 1 and a unit of\n'instructions' (i.e. --itrace=i1i).\n\nAlso the call chain size (default 16, max. 1024) for instructions or\ntransactions events can be specified. e.g.\n\n\t--itrace=ig32\n\t--itrace=xg32\n\nAlso the number of last branch entries (default 64, max. 1024) for instructions or\ntransactions events can be specified. e.g.\n\n       --itrace=il10\n       --itrace=xl10\n\nNote that last branch entries are cleared for each sample, so there is no overlap\nfrom one sample to the next.\n\nThe G and L options are designed in particular for sample mode, and work much\nlike g and l but add call chain and branch stack to the other selected events\ninstead of synthesized events. For example, to record branch-misses events for\n'ls' and then add a call chain derived from the Intel PT trace:\n\n\tperf record --aux-sample -e '{intel_pt//u,branch-misses:u}' -- ls\n\tperf report --itrace=Ge\n\nAlthough in fact G is a default for perf report, so that is the same as just:\n\n\tperf report\n\nOne caveat with the G and L options is that they work poorly with \"Large PEBS\".\nLarge PEBS means PEBS records will be accumulated by hardware and the written\ninto the event buffer in one go.  That reduces interrupts, but can give very\nlate timestamps.  Because the Intel PT trace is synchronized by timestamps,\nthe PEBS events do not match the trace.  Currently, Large PEBS is used only in\ncertain circumstances:\n\t- hardware supports it\n\t- PEBS is used\n\t- event period is specified, instead of frequency\n\t- the sample type is limited to the following flags:\n\t\tPERF_SAMPLE_IP | PERF_SAMPLE_TID | PERF_SAMPLE_ADDR |\n\t\tPERF_SAMPLE_ID | PERF_SAMPLE_CPU | PERF_SAMPLE_STREAM_ID |\n\t\tPERF_SAMPLE_DATA_SRC | PERF_SAMPLE_IDENTIFIER |\n\t\tPERF_SAMPLE_TRANSACTION | PERF_SAMPLE_PHYS_ADDR |\n\t\tPERF_SAMPLE_REGS_INTR | PERF_SAMPLE_REGS_USER |\n\t\tPERF_SAMPLE_PERIOD (and sometimes) | PERF_SAMPLE_TIME\nBecause Intel PT sample mode uses a different sample type to the list above,\nLarge PEBS is not used with Intel PT sample mode. To avoid Large PEBS in other\ncases, avoid specifying the event period i.e. avoid the 'perf record' -c option,\n--count option, or 'period' config term.\n\nTo disable trace decoding entirely, use the option --no-itrace.\n\nIt is also possible to skip events generated (instructions, branches, transactions)\nat the beginning. This is useful to ignore initialization code.\n\n\t--itrace=i0nss1000000\n\nskips the first million instructions.\n\nThe q option changes the way the trace is decoded.  The decoding is much faster\nbut much less detailed.  Specifically, with the q option, the decoder does not\ndecode TNT packets, and does not walk object code, but gets the ip from FUP and\nTIP packets.  The q option can be used with the b and i options but the period\nis not used.  The q option decodes more quickly, but is useful only if the\ncontrol flow of interest is represented or indicated by FUP, TIP, TIP.PGE, or\nTIP.PGD packets (refer below).  However the q option could be used to find time\nranges that could then be decoded fully using the --time option.\n\nWhat will *not* be decoded with the (single) q option:\n\n\t- direct calls and jmps\n\t- conditional branches\n\t- non-branch instructions\n\nWhat *will* be decoded with the (single) q option:\n\n\t- asynchronous branches such as interrupts\n\t- indirect branches\n\t- function return target address *if* the noretcomp config term (refer\n\tconfig terms section) was used\n\t- start of (control-flow) tracing\n\t- end of (control-flow) tracing, if it is not out of context\n\t- power events, ptwrite, transaction start and abort\n\t- instruction pointer associated with PSB packets\n\nNote the q option does not specify what events will be synthesized e.g. the p\noption must be used also to show power events.\n\nRepeating the q option (double-q i.e. qq) results in even faster decoding and even\nless detail.  The decoder decodes only extended PSB (PSB+) packets, getting the\ninstruction pointer if there is a FUP packet within PSB+ (i.e. between PSB and\nPSBEND).  Note PSB packets occur regularly in the trace based on the psb_period\nconfig term (refer config terms section).  There will be a FUP packet if the\nPSB+ occurs while control flow is being traced.\n\nWhat will *not* be decoded with the qq option:\n\n\t- everything except instruction pointer associated with PSB packets\n\nWhat *will* be decoded with the qq option:\n\n\t- instruction pointer associated with PSB packets\n\nThe Z option is equivalent to having recorded a trace without TSC\n(i.e. config term tsc=0). It can be useful to avoid timestamp issues when\ndecoding a trace of a virtual machine.\n\n\ndlfilter-show-cycles.so\n~~~~~~~~~~~~~~~~~~~~~~~\n\nCycles can be displayed using dlfilter-show-cycles.so in which case the itrace A\noption can be useful to provide higher granularity cycle information:\n\n\tperf script --itrace=A --call-trace --dlfilter dlfilter-show-cycles.so\n\nTo see a list of dlfilters:\n\n\tperf script -v --list-dlfilters\n\nSee also linkperf:perf-dlfilters[1]\n\n\ndump option\n~~~~~~~~~~~\n\nperf script has an option (-D) to \"dump\" the events i.e. display the binary\ndata.\n\nWhen -D is used, Intel PT packets are displayed.  The packet decoder does not\npay attention to PSB packets, but just decodes the bytes - so the packets seen\nby the actual decoder may not be identical in places where the data is corrupt.\nOne example of that would be when the buffer-switching interrupt has been too\nslow, and the buffer has been filled completely.  In that case, the last packet\nin the buffer might be truncated and immediately followed by a PSB as the trace\ncontinues in the next buffer.\n\nTo disable the display of Intel PT packets, combine the -D option with\n--no-itrace.\n\n\nperf report\n-----------\n\nBy default, perf report will decode trace data found in the perf.data file.\nThis can be further controlled by new option --itrace exactly the same as\nperf script, with the exception that the default is --itrace=igxe.\n\n\nperf inject\n-----------\n\nperf inject also accepts the --itrace option in which case tracing data is\nremoved and replaced with the synthesized events. e.g.\n\n\tperf inject --itrace -i perf.data -o perf.data.new\n\nBelow is an example of using Intel PT with autofdo.  It requires autofdo\n(https://github.com/google/autofdo) and gcc version 5.  The bubble\nsort example is from the AutoFDO tutorial (https://gcc.gnu.org/wiki/AutoFDO/Tutorial)\namended to take the number of elements as a parameter.\n\n\t$ gcc-5 -O3 sort.c -o sort_optimized\n\t$ ./sort_optimized 30000\n\tBubble sorting array of 30000 elements\n\t2254 ms\n\n\t$ cat ~/.perfconfig\n\t[intel-pt]\n\t\tmispred-all = on\n\n\t$ perf record -e intel_pt//u ./sort 3000\n\tBubble sorting array of 3000 elements\n\t58 ms\n\t[ perf record: Woken up 2 times to write data ]\n\t[ perf record: Captured and wrote 3.939 MB perf.data ]\n\t$ perf inject -i perf.data -o inj --itrace=i100usle --strip\n\t$ ./create_gcov --binary=./sort --profile=inj --gcov=sort.gcov -gcov_version=1\n\t$ gcc-5 -O3 -fauto-profile=sort.gcov sort.c -o sort_autofdo\n\t$ ./sort_autofdo 30000\n\tBubble sorting array of 30000 elements\n\t2155 ms\n\nNote there is currently no advantage to using Intel PT instead of LBR, but\nthat may change in the future if greater use is made of the data.\n\n\nPEBS via Intel PT\n-----------------\n\nSome hardware has the feature to redirect PEBS records to the Intel PT trace.\nRecording is selected by using the aux-output config term e.g.\n\n\tperf record -c 10000 -e '{intel_pt/branch=0/,cycles/aux-output/ppp}' uname\n\nOriginally, software only supported redirecting at most one PEBS event because it\nwas not able to differentiate one event from another. To overcome that, more recent\nkernels and perf tools add support for the PERF_RECORD_AUX_OUTPUT_HW_ID side-band event.\nTo check for the presence of that event in a PEBS-via-PT trace:\n\n\tperf script -D --no-itrace | grep PERF_RECORD_AUX_OUTPUT_HW_ID\n\nTo display PEBS events from the Intel PT trace, use the itrace 'o' option e.g.\n\n\tperf script --itrace=oe\n\nXED\n---\n\ninclude::build-xed.txt[]\n\n\nTracing Virtual Machines (kernel only)\n--------------------------------------\n\nCurrently, kernel tracing is supported with either \"timeless\" decoding\n(i.e. no TSC timestamps) or VM Time Correlation. VM Time Correlation is an extra step\nusing 'perf inject' and requires unchanging VMX TSC Offset and no VMX TSC Scaling.\n\nOther limitations and caveats\n\n VMX controls may suppress packets needed for decoding resulting in decoding errors\n VMX controls may block the perf NMI to the host potentially resulting in lost trace data\n Guest kernel self-modifying code (e.g. jump labels or JIT-compiled eBPF) will result in decoding errors\n Guest thread information is unknown\n Guest VCPU is unknown but may be able to be inferred from the host thread\n Callchains are not supported\n\nExample using \"timeless\" decoding\n\nStart VM\n\n $ sudo virsh start kubuntu20.04\n Domain kubuntu20.04 started\n\nMount the guest file system.  Note sshfs needs -o direct_io to enable reading of proc files.  root access is needed to read /proc/kcore.\n\n $ mkdir vm0\n $ sshfs -o direct_io root@vm0:/ vm0\n\nCopy the guest /proc/kallsyms, /proc/modules and /proc/kcore\n\n $ perf buildid-cache -v --kcore vm0/proc/kcore\n kcore added to build-id cache directory /home/user/.debug/[kernel.kcore]/9600f316a53a0f54278885e8d9710538ec5f6a08/2021021807494306\n $ KALLSYMS=/home/user/.debug/[kernel.kcore]/9600f316a53a0f54278885e8d9710538ec5f6a08/2021021807494306/kallsyms\n\nFind the VM process\n\n $ ps -eLl | grep 'KVM\\|PID'\n F S   UID     PID    PPID     LWP  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n 3 S 64055    1430       1    1440  1  80   0 - 1921718 -    ?        00:02:47 CPU 0/KVM\n 3 S 64055    1430       1    1441  1  80   0 - 1921718 -    ?        00:02:41 CPU 1/KVM\n 3 S 64055    1430       1    1442  1  80   0 - 1921718 -    ?        00:02:38 CPU 2/KVM\n 3 S 64055    1430       1    1443  2  80   0 - 1921718 -    ?        00:03:18 CPU 3/KVM\n\nStart an open-ended perf record, tracing the VM process, do something on the VM, and then ctrl-C to stop.\nTSC is not supported and tsc=0 must be specified.  That means mtc is useless, so add mtc=0.\nHowever, IPC can still be determined, hence cyc=1 can be added.\nOnly kernel decoding is supported, so 'k' must be specified.\nIntel PT traces both the host and the guest so --guest and --host need to be specified.\nWithout timestamps, --per-thread must be specified to distinguish threads.\n\n $ sudo perf kvm --guest --host --guestkallsyms $KALLSYMS record --kcore -e intel_pt/tsc=0,mtc=0,cyc=1/k -p 1430 --per-thread\n ^C\n [ perf record: Woken up 1 times to write data ]\n [ perf record: Captured and wrote 5.829 MB ]\n\nperf script can be used to provide an instruction trace\n\n $ perf script --guestkallsyms $KALLSYMS --insn-trace --xed -F+ipc | grep -C10 vmresume | head -21\n       CPU 0/KVM  1440  ffffffff82133cdd __vmx_vcpu_run+0x3d ([kernel.kallsyms])                movq  0x48(%rax), %r9\n       CPU 0/KVM  1440  ffffffff82133ce1 __vmx_vcpu_run+0x41 ([kernel.kallsyms])                movq  0x50(%rax), %r10\n       CPU 0/KVM  1440  ffffffff82133ce5 __vmx_vcpu_run+0x45 ([kernel.kallsyms])                movq  0x58(%rax), %r11\n       CPU 0/KVM  1440  ffffffff82133ce9 __vmx_vcpu_run+0x49 ([kernel.kallsyms])                movq  0x60(%rax), %r12\n       CPU 0/KVM  1440  ffffffff82133ced __vmx_vcpu_run+0x4d ([kernel.kallsyms])                movq  0x68(%rax), %r13\n       CPU 0/KVM  1440  ffffffff82133cf1 __vmx_vcpu_run+0x51 ([kernel.kallsyms])                movq  0x70(%rax), %r14\n       CPU 0/KVM  1440  ffffffff82133cf5 __vmx_vcpu_run+0x55 ([kernel.kallsyms])                movq  0x78(%rax), %r15\n       CPU 0/KVM  1440  ffffffff82133cf9 __vmx_vcpu_run+0x59 ([kernel.kallsyms])                movq  (%rax), %rax\n       CPU 0/KVM  1440  ffffffff82133cfc __vmx_vcpu_run+0x5c ([kernel.kallsyms])                callq  0xffffffff82133c40\n       CPU 0/KVM  1440  ffffffff82133c40 vmx_vmenter+0x0 ([kernel.kallsyms])            jz 0xffffffff82133c46\n       CPU 0/KVM  1440  ffffffff82133c42 vmx_vmenter+0x2 ([kernel.kallsyms])            vmresume         IPC: 0.11 (50/445)\n           :1440  1440  ffffffffbb678b06 native_write_msr+0x6 ([guest.kernel.kallsyms])                 nopl  %eax, (%rax,%rax,1)\n           :1440  1440  ffffffffbb678b0b native_write_msr+0xb ([guest.kernel.kallsyms])                 retq     IPC: 0.04 (2/41)\n           :1440  1440  ffffffffbb666646 lapic_next_deadline+0x26 ([guest.kernel.kallsyms])             data16 nop\n           :1440  1440  ffffffffbb666648 lapic_next_deadline+0x28 ([guest.kernel.kallsyms])             xor %eax, %eax\n           :1440  1440  ffffffffbb66664a lapic_next_deadline+0x2a ([guest.kernel.kallsyms])             popq  %rbp\n           :1440  1440  ffffffffbb66664b lapic_next_deadline+0x2b ([guest.kernel.kallsyms])             retq     IPC: 0.16 (4/25)\n           :1440  1440  ffffffffbb74607f clockevents_program_event+0x8f ([guest.kernel.kallsyms])               test %eax, %eax\n           :1440  1440  ffffffffbb746081 clockevents_program_event+0x91 ([guest.kernel.kallsyms])               jz 0xffffffffbb74603c    IPC: 0.06 (2/30)\n           :1440  1440  ffffffffbb74603c clockevents_program_event+0x4c ([guest.kernel.kallsyms])               popq  %rbx\n           :1440  1440  ffffffffbb74603d clockevents_program_event+0x4d ([guest.kernel.kallsyms])               popq  %r12\n\nExample using VM Time Correlation\n\nStart VM\n\n $ sudo virsh start kubuntu20.04\n Domain kubuntu20.04 started\n\nMount the guest file system.  Note sshfs needs -o direct_io to enable reading of proc files.  root access is needed to read /proc/kcore.\n\n $ mkdir -p vm0\n $ sshfs -o direct_io root@vm0:/ vm0\n\nCopy the guest /proc/kallsyms, /proc/modules and /proc/kcore\n\n $ perf buildid-cache -v --kcore vm0/proc/kcore\n same kcore found in /home/user/.debug/[kernel.kcore]/cc9c55a98c5e4ec0aeda69302554aabed5cd6491/2021021312450777\n $ KALLSYMS=/home/user/.debug/\\[kernel.kcore\\]/cc9c55a98c5e4ec0aeda69302554aabed5cd6491/2021021312450777/kallsyms\n\nFind the VM process\n\n $ ps -eLl | grep 'KVM\\|PID'\n F S   UID     PID    PPID     LWP  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n 3 S 64055   16998       1   17005 13  80   0 - 1818189 -    ?        00:00:16 CPU 0/KVM\n 3 S 64055   16998       1   17006  4  80   0 - 1818189 -    ?        00:00:05 CPU 1/KVM\n 3 S 64055   16998       1   17007  3  80   0 - 1818189 -    ?        00:00:04 CPU 2/KVM\n 3 S 64055   16998       1   17008  4  80   0 - 1818189 -    ?        00:00:05 CPU 3/KVM\n\nStart an open-ended perf record, tracing the VM process, do something on the VM, and then ctrl-C to stop.\nIPC can be determined, hence cyc=1 can be added.\nOnly kernel decoding is supported, so 'k' must be specified.\nIntel PT traces both the host and the guest so --guest and --host need to be specified.\n\n $ sudo perf kvm --guest --host --guestkallsyms $KALLSYMS record --kcore -e intel_pt/cyc=1/k -p 16998\n ^C[ perf record: Woken up 1 times to write data ]\n [ perf record: Captured and wrote 9.041 MB perf.data.kvm ]\n\nNow 'perf inject' can be used to determine the VMX TCS Offset. Note, Intel PT TSC packets are\nonly 7-bytes, so the TSC Offset might differ from the actual value in the 8th byte. That will\nhave no effect i.e. the resulting timestamps will be correct anyway.\n\n $ perf inject -i perf.data.kvm --vm-time-correlation=dry-run\n ERROR: Unknown TSC Offset for VMCS 0x1bff6a\n VMCS: 0x1bff6a  TSC Offset 0xffffe42722c64c41\n ERROR: Unknown TSC Offset for VMCS 0x1cbc08\n VMCS: 0x1cbc08  TSC Offset 0xffffe42722c64c41\n ERROR: Unknown TSC Offset for VMCS 0x1c3ce8\n VMCS: 0x1c3ce8  TSC Offset 0xffffe42722c64c41\n ERROR: Unknown TSC Offset for VMCS 0x1cbce9\n VMCS: 0x1cbce9  TSC Offset 0xffffe42722c64c41\n\nEach virtual CPU has a different Virtual Machine Control Structure (VMCS)\nshown above with the calculated TSC Offset. For an unchanging TSC Offset\nthey should all be the same for the same virtual machine.\n\nNow that the TSC Offset is known, it can be provided to 'perf inject'\n\n $ perf inject -i perf.data.kvm --vm-time-correlation=\"dry-run 0xffffe42722c64c41\"\n\nNote the options for 'perf inject' --vm-time-correlation are:\n\n [ dry-run ] [ <TSC Offset> [ : <VMCS> [ , <VMCS> ]... ]  ]...\n\nSo it is possible to specify different TSC Offsets for different VMCS.\nThe option \"dry-run\" will cause the file to be processed but without updating it.\nNote it is also possible to get a intel_pt.log file by adding option --itrace=d\n\nThere were no errors so, do it for real\n\n $ perf inject -i perf.data.kvm --vm-time-correlation=0xffffe42722c64c41 --force\n\n'perf script' can be used to see if there are any decoder errors\n\n $ perf script -i perf.data.kvm --guestkallsyms $KALLSYMS --itrace=e-o\n\nThere were none.\n\n'perf script' can be used to provide an instruction trace showing timestamps\n\n $ perf script -i perf.data.kvm --guestkallsyms $KALLSYMS --insn-trace --xed -F+ipc | grep -C10 vmresume | head -21\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cdd __vmx_vcpu_run+0x3d ([kernel.kallsyms])                 movq  0x48(%rax), %r9\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133ce1 __vmx_vcpu_run+0x41 ([kernel.kallsyms])                 movq  0x50(%rax), %r10\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133ce5 __vmx_vcpu_run+0x45 ([kernel.kallsyms])                 movq  0x58(%rax), %r11\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133ce9 __vmx_vcpu_run+0x49 ([kernel.kallsyms])                 movq  0x60(%rax), %r12\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133ced __vmx_vcpu_run+0x4d ([kernel.kallsyms])                 movq  0x68(%rax), %r13\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cf1 __vmx_vcpu_run+0x51 ([kernel.kallsyms])                 movq  0x70(%rax), %r14\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cf5 __vmx_vcpu_run+0x55 ([kernel.kallsyms])                 movq  0x78(%rax), %r15\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cf9 __vmx_vcpu_run+0x59 ([kernel.kallsyms])                 movq  (%rax), %rax\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133cfc __vmx_vcpu_run+0x5c ([kernel.kallsyms])                 callq  0xffffffff82133c40\n       CPU 1/KVM 17006 [001] 11500.262865593:  ffffffff82133c40 vmx_vmenter+0x0 ([kernel.kallsyms])             jz 0xffffffff82133c46\n       CPU 1/KVM 17006 [001] 11500.262866075:  ffffffff82133c42 vmx_vmenter+0x2 ([kernel.kallsyms])             vmresume         IPC: 0.05 (40/769)\n          :17006 17006 [001] 11500.262869216:  ffffffff82200cb0 asm_sysvec_apic_timer_interrupt+0x0 ([guest.kernel.kallsyms])           clac\n          :17006 17006 [001] 11500.262869216:  ffffffff82200cb3 asm_sysvec_apic_timer_interrupt+0x3 ([guest.kernel.kallsyms])           pushq  $0xffffffffffffffff\n          :17006 17006 [001] 11500.262869216:  ffffffff82200cb5 asm_sysvec_apic_timer_interrupt+0x5 ([guest.kernel.kallsyms])           callq  0xffffffff82201160\n          :17006 17006 [001] 11500.262869216:  ffffffff82201160 error_entry+0x0 ([guest.kernel.kallsyms])               cld\n          :17006 17006 [001] 11500.262869216:  ffffffff82201161 error_entry+0x1 ([guest.kernel.kallsyms])               pushq  %rsi\n          :17006 17006 [001] 11500.262869216:  ffffffff82201162 error_entry+0x2 ([guest.kernel.kallsyms])               movq  0x8(%rsp), %rsi\n          :17006 17006 [001] 11500.262869216:  ffffffff82201167 error_entry+0x7 ([guest.kernel.kallsyms])               movq  %rdi, 0x8(%rsp)\n          :17006 17006 [001] 11500.262869216:  ffffffff8220116c error_entry+0xc ([guest.kernel.kallsyms])               pushq  %rdx\n          :17006 17006 [001] 11500.262869216:  ffffffff8220116d error_entry+0xd ([guest.kernel.kallsyms])               pushq  %rcx\n          :17006 17006 [001] 11500.262869216:  ffffffff8220116e error_entry+0xe ([guest.kernel.kallsyms])               pushq  %rax\n\n\nTracing Virtual Machines (including user space)\n-----------------------------------------------\n\nIt is possible to use perf record to record sideband events within a virtual machine, so that an Intel PT trace on the host can be decoded.\nSideband events from the guest perf.data file can be injected into the host perf.data file using perf inject.\n\nHere is an example of the steps needed:\n\nOn the guest machine:\n\nCheck that no-kvmclock kernel command line option was used to boot:\n\nNote, this is essential to enable time correlation between host and guest machines.\n\n $ cat /proc/cmdline\n BOOT_IMAGE=/boot/vmlinuz-5.10.0-16-amd64 root=UUID=cb49c910-e573-47e0-bce7-79e293df8e1d ro no-kvmclock\n\nThere is no BPF support at present so, if possible, disable JIT compiling:\n\n $ echo 0 | sudo tee /proc/sys/net/core/bpf_jit_enable\n 0\n\nStart perf record to collect sideband events:\n\n $ sudo perf record -o guest-sideband-testing-guest-perf.data --sample-identifier --buildid-all --switch-events --kcore -a -e dummy\n\nOn the host machine:\n\nStart perf record to collect Intel PT trace:\n\nNote, the host trace will get very big, very fast, so the steps from starting to stopping the host trace really need to be done so that they happen in the shortest time possible.\n\n $ sudo perf record -o guest-sideband-testing-host-perf.data -m,64M --kcore -a -e intel_pt/cyc/\n\nOn the guest machine:\n\nRun a small test case, just 'uname' in this example:\n\n $ uname\n Linux\n\nOn the host machine:\n\nStop the Intel PT trace:\n\n ^C\n [ perf record: Woken up 1 times to write data ]\n [ perf record: Captured and wrote 76.122 MB guest-sideband-testing-host-perf.data ]\n\nOn the guest machine:\n\nStop the Intel PT trace:\n\n ^C\n [ perf record: Woken up 1 times to write data ]\n [ perf record: Captured and wrote 1.247 MB guest-sideband-testing-guest-perf.data ]\n\nAnd then copy guest-sideband-testing-guest-perf.data to the host (not shown here).\n\nOn the host machine:\n\nWith the 2 perf.data recordings, and with their ownership changed to the user.\n\nIdentify the TSC Offset:\n\n $ perf inject -i guest-sideband-testing-host-perf.data --vm-time-correlation=dry-run\n VMCS: 0x103fc6  TSC Offset 0xfffffa6ae070cb20\n VMCS: 0x103ff2  TSC Offset 0xfffffa6ae070cb20\n VMCS: 0x10fdaa  TSC Offset 0xfffffa6ae070cb20\n VMCS: 0x24d57c  TSC Offset 0xfffffa6ae070cb20\n\nCorrect Intel PT TSC timestamps for the guest machine:\n\n $ perf inject -i guest-sideband-testing-host-perf.data --vm-time-correlation=0xfffffa6ae070cb20 --force\n\nIdentify the guest machine PID:\n\n $ perf script -i guest-sideband-testing-host-perf.data --no-itrace --show-task-events | grep KVM\n       CPU 0/KVM     0 [000]     0.000000: PERF_RECORD_COMM: CPU 0/KVM:13376/13381\n       CPU 1/KVM     0 [000]     0.000000: PERF_RECORD_COMM: CPU 1/KVM:13376/13382\n       CPU 2/KVM     0 [000]     0.000000: PERF_RECORD_COMM: CPU 2/KVM:13376/13383\n       CPU 3/KVM     0 [000]     0.000000: PERF_RECORD_COMM: CPU 3/KVM:13376/13384\n\nNote, the QEMU option -name debug-threads=on is needed so that thread names\ncan be used to determine which thread is running which VCPU as above. libvirt seems to use this by default.\n\nCreate a guestmount, assuming the guest machine is 'vm_to_test':\n\n $ mkdir -p ~/guestmount/13376\n $ sshfs -o direct_io vm_to_test:/ ~/guestmount/13376\n\nInject the guest perf.data file into the host perf.data file:\n\nNote, due to the guestmount option, guest object files and debug files will be copied into the build ID cache from the guest machine, with the notable exception of VDSO.\nIf needed, VDSO can be copied manually in a fashion similar to that used by the perf-archive script.\n\n $ perf inject -i guest-sideband-testing-host-perf.data -o inj --guestmount ~/guestmount --guest-data=guest-sideband-testing-guest-perf.data,13376,0xfffffa6ae070cb20\n\nShow an excerpt from the result.  In this case the CPU and time range have been to chosen to show interaction between guest and host when 'uname' is starting to run on the guest machine:\n\nNotes:\n\n\t- the CPU displayed, [002] in this case, is always the host CPU\n\t- events happening in the virtual machine start with VM:13376 VCPU:003, which shows the hypervisor PID 13376 and the VCPU number\n\t- only calls and errors are displayed i.e. --itrace=ce\n\t- branches entering and exiting the virtual machine are split, and show as 2 branches to/from \"0 [unknown] ([unknown])\"\n\n $ perf script -i inj --itrace=ce -F+machine_pid,+vcpu,+addr,+pid,+tid,-period --ns --time 7919.408803365,7919.408804631 -C 2\n       CPU 3/KVM 13376/13384 [002]  7919.408803365:      branches:  ffffffffc0f8ebe0 vmx_vcpu_enter_exit+0xc0 ([kernel.kallsyms]) => ffffffffc0f8edc0 __vmx_vcpu_run+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803365:      branches:  ffffffffc0f8edd5 __vmx_vcpu_run+0x15 ([kernel.kallsyms]) => ffffffffc0f8eca0 vmx_update_host_rsp+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803365:      branches:  ffffffffc0f8ee1b __vmx_vcpu_run+0x5b ([kernel.kallsyms]) => ffffffffc0f8ed60 vmx_vmenter+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803461:      branches:  ffffffffc0f8ed62 vmx_vmenter+0x2 ([kernel.kallsyms]) =>                0 [unknown] ([unknown])\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408803461:      branches:                 0 [unknown] ([unknown]) =>     7f851c9b5a5c init_cacheinfo+0x3ac (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408803567:      branches:      7f851c9b5a5a init_cacheinfo+0x3aa (/usr/lib/x86_64-linux-gnu/libc-2.31.so) =>                0 [unknown] ([unknown])\n       CPU 3/KVM 13376/13384 [002]  7919.408803567:      branches:                 0 [unknown] ([unknown]) => ffffffffc0f8ed80 vmx_vmexit+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803596:      branches:  ffffffffc0f6619a vmx_vcpu_run+0x26a ([kernel.kallsyms]) => ffffffffb2255c60 x86_virt_spec_ctrl+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803801:      branches:  ffffffffc0f66445 vmx_vcpu_run+0x515 ([kernel.kallsyms]) => ffffffffb2290b30 native_write_msr+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803850:      branches:  ffffffffc0f661f8 vmx_vcpu_run+0x2c8 ([kernel.kallsyms]) => ffffffffc1092300 kvm_load_host_xsave_state+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803850:      branches:  ffffffffc1092327 kvm_load_host_xsave_state+0x27 ([kernel.kallsyms]) => ffffffffc1092220 kvm_load_host_xsave_state.part.0+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803862:      branches:  ffffffffc0f662cf vmx_vcpu_run+0x39f ([kernel.kallsyms]) => ffffffffc0f63f90 vmx_recover_nmi_blocking+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803862:      branches:  ffffffffc0f662e9 vmx_vcpu_run+0x3b9 ([kernel.kallsyms]) => ffffffffc0f619a0 __vmx_complete_interrupts+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803872:      branches:  ffffffffc109cfb2 vcpu_enter_guest+0x752 ([kernel.kallsyms]) => ffffffffc0f5f570 vmx_handle_exit_irqoff+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803881:      branches:  ffffffffc109d028 vcpu_enter_guest+0x7c8 ([kernel.kallsyms]) => ffffffffb234f900 __srcu_read_lock+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803897:      branches:  ffffffffc109d06f vcpu_enter_guest+0x80f ([kernel.kallsyms]) => ffffffffc0f72e30 vmx_handle_exit+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803897:      branches:  ffffffffc0f72e3d vmx_handle_exit+0xd ([kernel.kallsyms]) => ffffffffc0f727c0 __vmx_handle_exit+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803897:      branches:  ffffffffc0f72b15 __vmx_handle_exit+0x355 ([kernel.kallsyms]) => ffffffffc0f60ae0 vmx_flush_pml_buffer+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803903:      branches:  ffffffffc0f72994 __vmx_handle_exit+0x1d4 ([kernel.kallsyms]) => ffffffffc10b7090 kvm_emulate_cpuid+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803903:      branches:  ffffffffc10b70f1 kvm_emulate_cpuid+0x61 ([kernel.kallsyms]) => ffffffffc10b6e10 kvm_cpuid+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803941:      branches:  ffffffffc10b7125 kvm_emulate_cpuid+0x95 ([kernel.kallsyms]) => ffffffffc1093110 kvm_skip_emulated_instruction+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803941:      branches:  ffffffffc109311f kvm_skip_emulated_instruction+0xf ([kernel.kallsyms]) => ffffffffc0f5e180 vmx_get_rflags+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803951:      branches:  ffffffffc109312a kvm_skip_emulated_instruction+0x1a ([kernel.kallsyms]) => ffffffffc0f5fd30 vmx_skip_emulated_instruction+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803951:      branches:  ffffffffc0f5fd79 vmx_skip_emulated_instruction+0x49 ([kernel.kallsyms]) => ffffffffc0f5fb50 skip_emulated_instruction+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803956:      branches:  ffffffffc0f5fc68 skip_emulated_instruction+0x118 ([kernel.kallsyms]) => ffffffffc0f6a940 vmx_cache_reg+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803964:      branches:  ffffffffc0f5fc11 skip_emulated_instruction+0xc1 ([kernel.kallsyms]) => ffffffffc0f5f9e0 vmx_set_interrupt_shadow+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803980:      branches:  ffffffffc109f8b1 vcpu_run+0x71 ([kernel.kallsyms]) => ffffffffc10ad2f0 kvm_cpu_has_pending_timer+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803980:      branches:  ffffffffc10ad2fb kvm_cpu_has_pending_timer+0xb ([kernel.kallsyms]) => ffffffffc10b0490 apic_has_pending_timer+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803991:      branches:  ffffffffc109f899 vcpu_run+0x59 ([kernel.kallsyms]) => ffffffffc109c860 vcpu_enter_guest+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803993:      branches:  ffffffffc109cd4c vcpu_enter_guest+0x4ec ([kernel.kallsyms]) => ffffffffc0f69140 vmx_prepare_switch_to_guest+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803996:      branches:  ffffffffc109cd7d vcpu_enter_guest+0x51d ([kernel.kallsyms]) => ffffffffb234f930 __srcu_read_unlock+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803996:      branches:  ffffffffc109cd9c vcpu_enter_guest+0x53c ([kernel.kallsyms]) => ffffffffc0f609b0 vmx_sync_pir_to_irr+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408803996:      branches:  ffffffffc0f60a6d vmx_sync_pir_to_irr+0xbd ([kernel.kallsyms]) => ffffffffc10adc20 kvm_lapic_find_highest_irr+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804010:      branches:  ffffffffc0f60abd vmx_sync_pir_to_irr+0x10d ([kernel.kallsyms]) => ffffffffc0f60820 vmx_set_rvi+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804019:      branches:  ffffffffc109ceca vcpu_enter_guest+0x66a ([kernel.kallsyms]) => ffffffffb2249840 fpregs_assert_state_consistent+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804021:      branches:  ffffffffc109cf10 vcpu_enter_guest+0x6b0 ([kernel.kallsyms]) => ffffffffc0f65f30 vmx_vcpu_run+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804024:      branches:  ffffffffc0f6603b vmx_vcpu_run+0x10b ([kernel.kallsyms]) => ffffffffb229bed0 __get_current_cr3_fast+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804024:      branches:  ffffffffc0f66055 vmx_vcpu_run+0x125 ([kernel.kallsyms]) => ffffffffb2253050 cr4_read_shadow+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804030:      branches:  ffffffffc0f6608d vmx_vcpu_run+0x15d ([kernel.kallsyms]) => ffffffffc10921e0 kvm_load_guest_xsave_state+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804030:      branches:  ffffffffc1092207 kvm_load_guest_xsave_state+0x27 ([kernel.kallsyms]) => ffffffffc1092110 kvm_load_guest_xsave_state.part.0+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804032:      branches:  ffffffffc0f660c6 vmx_vcpu_run+0x196 ([kernel.kallsyms]) => ffffffffb22061a0 perf_guest_get_msrs+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804032:      branches:  ffffffffb22061a9 perf_guest_get_msrs+0x9 ([kernel.kallsyms]) => ffffffffb220cda0 intel_guest_get_msrs+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804039:      branches:  ffffffffc0f66109 vmx_vcpu_run+0x1d9 ([kernel.kallsyms]) => ffffffffc0f652c0 clear_atomic_switch_msr+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804040:      branches:  ffffffffc0f66119 vmx_vcpu_run+0x1e9 ([kernel.kallsyms]) => ffffffffc0f73f60 intel_pmu_lbr_is_enabled+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804042:      branches:  ffffffffc0f73f81 intel_pmu_lbr_is_enabled+0x21 ([kernel.kallsyms]) => ffffffffc10b68e0 kvm_find_cpuid_entry+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804045:      branches:  ffffffffc0f66454 vmx_vcpu_run+0x524 ([kernel.kallsyms]) => ffffffffc0f61ff0 vmx_update_hv_timer+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804057:      branches:  ffffffffc0f66142 vmx_vcpu_run+0x212 ([kernel.kallsyms]) => ffffffffc10af100 kvm_wait_lapic_expire+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804057:      branches:  ffffffffc0f66156 vmx_vcpu_run+0x226 ([kernel.kallsyms]) => ffffffffb2255c60 x86_virt_spec_ctrl+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804057:      branches:  ffffffffc0f66161 vmx_vcpu_run+0x231 ([kernel.kallsyms]) => ffffffffc0f8eb20 vmx_vcpu_enter_exit+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804057:      branches:  ffffffffc0f8eb44 vmx_vcpu_enter_exit+0x24 ([kernel.kallsyms]) => ffffffffb2353e10 rcu_note_context_switch+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804057:      branches:  ffffffffb2353e1c rcu_note_context_switch+0xc ([kernel.kallsyms]) => ffffffffb2353db0 rcu_qs+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804066:      branches:  ffffffffc0f8ebe0 vmx_vcpu_enter_exit+0xc0 ([kernel.kallsyms]) => ffffffffc0f8edc0 __vmx_vcpu_run+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804066:      branches:  ffffffffc0f8edd5 __vmx_vcpu_run+0x15 ([kernel.kallsyms]) => ffffffffc0f8eca0 vmx_update_host_rsp+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804066:      branches:  ffffffffc0f8ee1b __vmx_vcpu_run+0x5b ([kernel.kallsyms]) => ffffffffc0f8ed60 vmx_vmenter+0x0 ([kernel.kallsyms])\n       CPU 3/KVM 13376/13384 [002]  7919.408804162:      branches:  ffffffffc0f8ed62 vmx_vmenter+0x2 ([kernel.kallsyms]) =>                0 [unknown] ([unknown])\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408804162:      branches:                 0 [unknown] ([unknown]) =>     7f851c9b5a5c init_cacheinfo+0x3ac (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408804273:      branches:      7f851cb7c0e4 _dl_init+0x74 (/usr/lib/x86_64-linux-gnu/ld-2.31.so) =>     7f851cb7bf50 call_init.part.0+0x0 (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408804526:      branches:      55e0c00136f0 _start+0x0 (/usr/bin/uname) => ffffffff83200ac0 asm_exc_page_fault+0x0 ([kernel.kallsyms])\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408804526:      branches:  ffffffff83200ac3 asm_exc_page_fault+0x3 ([kernel.kallsyms]) => ffffffff83201290 error_entry+0x0 ([kernel.kallsyms])\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408804534:      branches:  ffffffff832012fa error_entry+0x6a ([kernel.kallsyms]) => ffffffff830b59a0 sync_regs+0x0 ([kernel.kallsyms])\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408804631:      branches:  ffffffff83200ad9 asm_exc_page_fault+0x19 ([kernel.kallsyms]) => ffffffff830b8210 exc_page_fault+0x0 ([kernel.kallsyms])\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408804631:      branches:  ffffffff830b82a4 exc_page_fault+0x94 ([kernel.kallsyms]) => ffffffff830b80e0 __kvm_handle_async_pf+0x0 ([kernel.kallsyms])\n VM:13376 VCPU:003            uname  3404/3404  [002]  7919.408804631:      branches:  ffffffff830b80ed __kvm_handle_async_pf+0xd ([kernel.kallsyms]) => ffffffff830b80c0 kvm_read_and_reset_apf_flags+0x0 ([kernel.kallsyms])\n\n\nTracing Virtual Machines - Guest Code\n-------------------------------------\n\nA common case for KVM test programs is that the test program acts as the\nhypervisor, creating, running and destroying the virtual machine, and\nproviding the guest object code from its own object code. In this case,\nthe VM is not running an OS, but only the functions loaded into it by the\nhypervisor test program, and conveniently, loaded at the same virtual\naddresses. To support that, option \"--guest-code\" has been added to perf script\nand perf kvm report.\n\nHere is an example tracing a test program from the kernel's KVM selftests:\n\n # perf record --kcore -e intel_pt/cyc/ -- tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test\n [ perf record: Woken up 1 times to write data ]\n [ perf record: Captured and wrote 0.280 MB perf.data ]\n # perf script --guest-code --itrace=bep --ns -F-period,+addr,+flags\n [SNIP]\n   tsc_msrs_test 18436 [007] 10897.962087733:      branches:   call                   ffffffffc13b2ff5 __vmx_vcpu_run+0x15 (vmlinux) => ffffffffc13b2f50 vmx_update_host_rsp+0x0 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962087733:      branches:   return                 ffffffffc13b2f5d vmx_update_host_rsp+0xd (vmlinux) => ffffffffc13b2ffa __vmx_vcpu_run+0x1a (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962087733:      branches:   call                   ffffffffc13b303b __vmx_vcpu_run+0x5b (vmlinux) => ffffffffc13b2f80 vmx_vmenter+0x0 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962087836:      branches:   vmentry                ffffffffc13b2f82 vmx_vmenter+0x2 (vmlinux) =>                0 [unknown] ([unknown])\n   [guest/18436] 18436 [007] 10897.962087836:      branches:   vmentry                               0 [unknown] ([unknown]) =>           402c81 guest_code+0x131 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test)\n   [guest/18436] 18436 [007] 10897.962087836:      branches:   call                             402c81 guest_code+0x131 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test) =>           40dba0 ucall+0x0 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test)\n   [guest/18436] 18436 [007] 10897.962088248:      branches:   vmexit                           40dba0 ucall+0x0 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test) =>                0 [unknown] ([unknown])\n   tsc_msrs_test 18436 [007] 10897.962088248:      branches:   vmexit                                0 [unknown] ([unknown]) => ffffffffc13b2fa0 vmx_vmexit+0x0 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962088248:      branches:   jmp                    ffffffffc13b2fa0 vmx_vmexit+0x0 (vmlinux) => ffffffffc13b2fd2 vmx_vmexit+0x32 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962088256:      branches:   return                 ffffffffc13b2fd2 vmx_vmexit+0x32 (vmlinux) => ffffffffc13b3040 __vmx_vcpu_run+0x60 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962088270:      branches:   return                 ffffffffc13b30b6 __vmx_vcpu_run+0xd6 (vmlinux) => ffffffffc13b2f2e vmx_vcpu_enter_exit+0x4e (vmlinux)\n [SNIP]\n   tsc_msrs_test 18436 [007] 10897.962089321:      branches:   call                   ffffffffc13b2ff5 __vmx_vcpu_run+0x15 (vmlinux) => ffffffffc13b2f50 vmx_update_host_rsp+0x0 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962089321:      branches:   return                 ffffffffc13b2f5d vmx_update_host_rsp+0xd (vmlinux) => ffffffffc13b2ffa __vmx_vcpu_run+0x1a (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962089321:      branches:   call                   ffffffffc13b303b __vmx_vcpu_run+0x5b (vmlinux) => ffffffffc13b2f80 vmx_vmenter+0x0 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962089424:      branches:   vmentry                ffffffffc13b2f82 vmx_vmenter+0x2 (vmlinux) =>                0 [unknown] ([unknown])\n   [guest/18436] 18436 [007] 10897.962089424:      branches:   vmentry                               0 [unknown] ([unknown]) =>           40dba0 ucall+0x0 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test)\n   [guest/18436] 18436 [007] 10897.962089701:      branches:   jmp                              40dc1b ucall+0x7b (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test) =>           40dc39 ucall+0x99 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test)\n   [guest/18436] 18436 [007] 10897.962089701:      branches:   jcc                              40dc3c ucall+0x9c (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test) =>           40dc20 ucall+0x80 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test)\n   [guest/18436] 18436 [007] 10897.962089701:      branches:   jcc                              40dc3c ucall+0x9c (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test) =>           40dc20 ucall+0x80 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test)\n   [guest/18436] 18436 [007] 10897.962089701:      branches:   jcc                              40dc37 ucall+0x97 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test) =>           40dc50 ucall+0xb0 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test)\n   [guest/18436] 18436 [007] 10897.962089878:      branches:   vmexit                           40dc55 ucall+0xb5 (/home/user/git/work/tools/testing/selftests/kselftest_install/kvm/tsc_msrs_test) =>                0 [unknown] ([unknown])\n   tsc_msrs_test 18436 [007] 10897.962089878:      branches:   vmexit                                0 [unknown] ([unknown]) => ffffffffc13b2fa0 vmx_vmexit+0x0 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962089878:      branches:   jmp                    ffffffffc13b2fa0 vmx_vmexit+0x0 (vmlinux) => ffffffffc13b2fd2 vmx_vmexit+0x32 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962089887:      branches:   return                 ffffffffc13b2fd2 vmx_vmexit+0x32 (vmlinux) => ffffffffc13b3040 __vmx_vcpu_run+0x60 (vmlinux)\n   tsc_msrs_test 18436 [007] 10897.962089901:      branches:   return                 ffffffffc13b30b6 __vmx_vcpu_run+0xd6 (vmlinux) => ffffffffc13b2f2e vmx_vcpu_enter_exit+0x4e (vmlinux)\n [SNIP]\n\n # perf kvm --guest-code --guest --host report -i perf.data --stdio | head -20\n\n # To display the perf.data header info, please use --header/--header-only options.\n #\n #\n # Total Lost Samples: 0\n #\n # Samples: 12  of event 'instructions'\n # Event count (approx.): 2274583\n #\n # Children      Self  Command        Shared Object         Symbol\n # ........  ........  .............  ....................  ...........................................\n #\n    54.70%     0.00%  tsc_msrs_test  [kernel.vmlinux]      [k] entry_SYSCALL_64_after_hwframe\n            |\n            ---entry_SYSCALL_64_after_hwframe\n               do_syscall_64\n               |\n               |--29.44%--syscall_exit_to_user_mode\n               |          exit_to_user_mode_prepare\n               |          task_work_run\n               |          __fput\n\n\nEvent Trace\n-----------\n\nEvent Trace records information about asynchronous events, for example interrupts,\nfaults, VM exits and entries.  The information is recorded in CFE and EVD packets,\nand also the Interrupt Flag is recorded on the MODE.Exec packet.  The CFE packet\ncontains a type field to identify one of the following:\n\n\t 1\tINTR\t\tinterrupt, fault, exception, NMI\n\t 2\tIRET\t\tinterrupt return\n\t 3\tSMI\t\tsystem management interrupt\n\t 4\tRSM\t\tresume from system management mode\n\t 5\tSIPI\t\tstartup interprocessor interrupt\n\t 6\tINIT\t\tINIT signal\n\t 7\tVMENTRY\t\tVM-Entry\n\t 8\tVMEXIT\t\tVM-Entry\n\t 9\tVMEXIT_INTR\tVM-Exit due to interrupt\n\t10\tSHUTDOWN\tShutdown\n\nFor more details, refer to the Intel 64 and IA-32 Architectures Software\nDeveloper Manuals (version 076 or later).\n\nThe capability to do Event Trace is indicated by the\n/sys/bus/event_source/devices/intel_pt/caps/event_trace file.\n\nEvent trace is selected for recording using the \"event\" config term. e.g.\n\n\tperf record -e intel_pt/event/u uname\n\nEvent trace events are output using the --itrace I option. e.g.\n\n\tperf script --itrace=Ie\n\nperf script displays events containing CFE type, vector and event data,\nin the form:\n\n\t  evt:   hw int            (t)  cfe: INTR IP: 1 vector: 3 PFA: 0x8877665544332211\n\nThe IP flag indicates if the event binds to an IP, which includes any case where\nflow control packet generation is enabled, as well as when CFE packet IP bit is\nset.\n\nperf script displays events containing changes to the Interrupt Flag in the form:\n\n\tiflag:   t                      IFLAG: 1->0 via branch\n\nwhere \"via branch\" indicates a branch (interrupt or return from interrupt) and\n\"non branch\" indicates an instruction such as CFI, STI or POPF).\n\nIn addition, the current state of the interrupt flag is indicated by the presence\nor absence of the \"D\" (interrupt disabled) perf script flag.  If the interrupt\nflag is changed, then the \"t\" flag is also included i.e.\n\n\t\tno flag, interrupts enabled IF=1\n\tt\tinterrupts become disabled IF=1 -> IF=0\n\tD\tinterrupts are disabled IF=0\n\tDt\tinterrupts become enabled  IF=0 -> IF=1\n\nThe intel-pt-events.py script illustrates how to access Event Trace information\nusing a Python script.\n\n\nTNT Disable\n-----------\n\nTNT packets are disabled using the \"notnt\" config term. e.g.\n\n\tperf record -e intel_pt/notnt/u uname\n\nIn that case the --itrace q option is forced because walking executable code\nto reconstruct the control flow is not possible.\n\n\nEmulated PTWRITE\n----------------\n\nLater perf tools support a method to emulate the ptwrite instruction, which\ncan be useful if hardware does not support the ptwrite instruction.\n\nInstead of using the ptwrite instruction, a function is used which produces\na trace that encodes the payload data into TNT packets.  Here is an example\nof the function:\n\n #include <stdint.h>\n\n void perf_emulate_ptwrite(uint64_t x)\n __attribute__((externally_visible, noipa, no_instrument_function, naked));\n\n #define PERF_EMULATE_PTWRITE_8_BITS \\\n                 \"1: shl %rax\\n\"     \\\n                 \"   jc 1f\\n\"        \\\n                 \"1: shl %rax\\n\"     \\\n                 \"   jc 1f\\n\"        \\\n                 \"1: shl %rax\\n\"     \\\n                 \"   jc 1f\\n\"        \\\n                 \"1: shl %rax\\n\"     \\\n                 \"   jc 1f\\n\"        \\\n                 \"1: shl %rax\\n\"     \\\n                 \"   jc 1f\\n\"        \\\n                 \"1: shl %rax\\n\"     \\\n                 \"   jc 1f\\n\"        \\\n                 \"1: shl %rax\\n\"     \\\n                 \"   jc 1f\\n\"        \\\n                 \"1: shl %rax\\n\"     \\\n                 \"   jc 1f\\n\"\n\n /* Undefined instruction */\n #define PERF_EMULATE_PTWRITE_UD2        \".byte 0x0f, 0x0b\\n\"\n\n #define PERF_EMULATE_PTWRITE_MAGIC        PERF_EMULATE_PTWRITE_UD2 \".ascii \\\"perf,ptwrite  \\\"\\n\"\n\n void perf_emulate_ptwrite(uint64_t x __attribute__ ((__unused__)))\n {\n          /* Assumes SysV ABI : x passed in rdi */\n         __asm__ volatile (\n                 \"jmp 1f\\n\"\n                 PERF_EMULATE_PTWRITE_MAGIC\n                 \"1: mov %rdi, %rax\\n\"\n                 PERF_EMULATE_PTWRITE_8_BITS\n                 PERF_EMULATE_PTWRITE_8_BITS\n                 PERF_EMULATE_PTWRITE_8_BITS\n                 PERF_EMULATE_PTWRITE_8_BITS\n                 PERF_EMULATE_PTWRITE_8_BITS\n                 PERF_EMULATE_PTWRITE_8_BITS\n                 PERF_EMULATE_PTWRITE_8_BITS\n                 PERF_EMULATE_PTWRITE_8_BITS\n                 \"1: ret\\n\"\n         );\n }\n\nFor example, a test program with the function above:\n\n #include <stdio.h>\n #include <stdint.h>\n #include <stdlib.h>\n\n #include \"perf_emulate_ptwrite.h\"\n\n int main(int argc, char *argv[])\n {\n         uint64_t x = 0;\n\n         if (argc > 1)\n                 x = strtoull(argv[1], NULL, 0);\n         perf_emulate_ptwrite(x);\n         return 0;\n }\n\nCan be compiled and traced:\n\n $ gcc -Wall -Wextra -O3 -g -o eg_ptw eg_ptw.c\n $ perf record -e intel_pt//u ./eg_ptw 0x1234567890abcdef\n [ perf record: Woken up 1 times to write data ]\n [ perf record: Captured and wrote 0.017 MB perf.data ]\n $ perf script --itrace=ew\n           eg_ptw 19875 [007]  8061.235912:     ptwrite:  IP: 0 payload: 0x1234567890abcdef      55701249a196 perf_emulate_ptwrite+0x16 (/home/user/eg_ptw)\n $\n\n\nPipe mode\n---------\nPipe mode is a problem for Intel PT and possibly other auxtrace users.\nIt's not recommended to use a pipe as data output with Intel PT because\nof the following reason.\n\nEssentially the auxtrace buffers do not behave like the regular perf\nevent buffers.  That is because the head and tail are updated by\nsoftware, but in the auxtrace case the data is written by hardware.\nSo the head and tail do not get updated as data is written.\n\nIn the Intel PT case, the head and tail are updated only when the trace\nis disabled by software, for example:\n    - full-trace, system wide : when buffer passes watermark\n    - full-trace, not system-wide : when buffer passes watermark or\n                                    context switches\n    - snapshot mode : as above but also when a snapshot is made\n    - sample mode : as above but also when a sample is made\n\nThat means finished-round ordering doesn't work.  An auxtrace buffer\ncan turn up that has data that extends back in time, possibly to the\nvery beginning of tracing.\n\nFor a perf.data file, that problem is solved by going through the trace\nand queuing up the auxtrace buffers in advance.\n\nFor pipe mode, the order of events and timestamps can presumably\nbe messed up.\n\n\nEXAMPLE\n-------\n\nExamples can be found on perf wiki page \"Perf tools support for Intel\u00ae Processor Trace\":\n\nhttps://perf.wiki.kernel.org/index.php/Perf_tools_support_for_Intel%C2%AE_Processor_Trace\n\n\nSEE ALSO\n--------\n\nlinkperf:perf-record[1], linkperf:perf-script[1], linkperf:perf-report[1],\nlinkperf:perf-inject[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}