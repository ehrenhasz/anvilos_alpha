{
  "module_name": "perf-dlfilter.txt",
  "hash_id": "fd7af28347461f51e93a25f27572c4fe97f2ff242e623f3c06b463f28e90c890",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-dlfilter.txt",
  "human_readable_source": "perf-dlfilter(1)\n================\n\nNAME\n----\nperf-dlfilter - Filter sample events using a dynamically loaded shared\nobject file\n\nSYNOPSIS\n--------\n[verse]\n'perf script' [--dlfilter file.so ] [ --dlarg arg ]...\n\nDESCRIPTION\n-----------\n\nThis option is used to process data through a custom filter provided by a\ndynamically loaded shared object file. Arguments can be passed using --dlarg\nand retrieved using perf_dlfilter_fns.args().\n\nIf 'file.so' does not contain \"/\", then it will be found either in the current\ndirectory, or perf tools exec path which is ~/libexec/perf-core/dlfilters for\na local build and install (refer perf --exec-path), or the dynamic linker\npaths.\n\nAPI\n---\n\nThe API for filtering consists of the following:\n\n[source,c]\n----\n#include <perf/perf_dlfilter.h>\n\nstruct perf_dlfilter_fns perf_dlfilter_fns;\n\nint start(void **data, void *ctx);\nint stop(void *data, void *ctx);\nint filter_event(void *data, const struct perf_dlfilter_sample *sample, void *ctx);\nint filter_event_early(void *data, const struct perf_dlfilter_sample *sample, void *ctx);\nconst char *filter_description(const char **long_description);\n----\n\nIf implemented, 'start' will be called at the beginning, before any\ncalls to 'filter_event' or 'filter_event_early'. Return 0 to indicate success,\nor return a negative error code. '*data' can be assigned for use by other\nfunctions. 'ctx' is needed for calls to perf_dlfilter_fns, but most\nperf_dlfilter_fns are not valid when called from 'start'.\n\nIf implemented, 'stop' will be called at the end, after any calls to\n'filter_event' or 'filter_event_early'. Return 0 to indicate success, or\nreturn a negative error code. 'data' is set by 'start'. 'ctx' is needed\nfor calls to perf_dlfilter_fns, but most perf_dlfilter_fns are not valid\nwhen called from 'stop'.\n\nIf implemented, 'filter_event' will be called for each sample event.\nReturn 0 to keep the sample event, 1 to filter it out, or return a negative\nerror code. 'data' is set by 'start'. 'ctx' is needed for calls to\n'perf_dlfilter_fns'.\n\n'filter_event_early' is the same as 'filter_event' except it is called before\ninternal filtering.\n\nIf implemented, 'filter_description' should return a one-line description\nof the filter, and optionally a longer description.\n\nDo not assume the 'sample' argument is valid (dereferenceable)\nafter 'filter_event' and 'filter_event_early' return.\n\nDo not assume data referenced by pointers in struct perf_dlfilter_sample\nis valid (dereferenceable) after 'filter_event' and 'filter_event_early' return.\n\nThe perf_dlfilter_sample structure\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n'filter_event' and 'filter_event_early' are passed a perf_dlfilter_sample\nstructure, which contains the following fields:\n[source,c]\n----\n/*\n * perf sample event information (as per perf script and <linux/perf_event.h>)\n */\nstruct perf_dlfilter_sample {\n\t__u32 size; /* Size of this structure (for compatibility checking) */\n\t__u16 ins_lat;\t\t/* Refer PERF_SAMPLE_WEIGHT_TYPE in <linux/perf_event.h> */\n\t__u16 p_stage_cyc;\t/* Refer PERF_SAMPLE_WEIGHT_TYPE in <linux/perf_event.h> */\n\t__u64 ip;\n\t__s32 pid;\n\t__s32 tid;\n\t__u64 time;\n\t__u64 addr;\n\t__u64 id;\n\t__u64 stream_id;\n\t__u64 period;\n\t__u64 weight;\t\t/* Refer PERF_SAMPLE_WEIGHT_TYPE in <linux/perf_event.h> */\n\t__u64 transaction;\t/* Refer PERF_SAMPLE_TRANSACTION in <linux/perf_event.h> */\n\t__u64 insn_cnt;\t/* For instructions-per-cycle (IPC) */\n\t__u64 cyc_cnt;\t\t/* For instructions-per-cycle (IPC) */\n\t__s32 cpu;\n\t__u32 flags;\t\t/* Refer PERF_DLFILTER_FLAG_* above */\n\t__u64 data_src;\t\t/* Refer PERF_SAMPLE_DATA_SRC in <linux/perf_event.h> */\n\t__u64 phys_addr;\t/* Refer PERF_SAMPLE_PHYS_ADDR in <linux/perf_event.h> */\n\t__u64 data_page_size;\t/* Refer PERF_SAMPLE_DATA_PAGE_SIZE in <linux/perf_event.h> */\n\t__u64 code_page_size;\t/* Refer PERF_SAMPLE_CODE_PAGE_SIZE in <linux/perf_event.h> */\n\t__u64 cgroup;\t\t/* Refer PERF_SAMPLE_CGROUP in <linux/perf_event.h> */\n\t__u8  cpumode;\t\t/* Refer CPUMODE_MASK etc in <linux/perf_event.h> */\n\t__u8  addr_correlates_sym; /* True => resolve_addr() can be called */\n\t__u16 misc;\t\t/* Refer perf_event_header in <linux/perf_event.h> */\n\t__u32 raw_size;\t\t/* Refer PERF_SAMPLE_RAW in <linux/perf_event.h> */\n\tconst void *raw_data;\t/* Refer PERF_SAMPLE_RAW in <linux/perf_event.h> */\n\t__u64 brstack_nr;\t/* Number of brstack entries */\n\tconst struct perf_branch_entry *brstack; /* Refer <linux/perf_event.h> */\n\t__u64 raw_callchain_nr;\t/* Number of raw_callchain entries */\n\tconst __u64 *raw_callchain; /* Refer <linux/perf_event.h> */\n\tconst char *event;\n\t__s32 machine_pid;\n\t__s32 vcpu;\n};\n----\n\nNote: 'machine_pid' and 'vcpu' are not original members, but were added together later.\n'size' can be used to determine their presence at run time.\nPERF_DLFILTER_HAS_MACHINE_PID will be defined if they are present at compile time.\nFor example:\n[source,c]\n----\n#include <perf/perf_dlfilter.h>\n#include <stddef.h>\n#include <stdbool.h>\n\nstatic inline bool have_machine_pid(const struct perf_dlfilter_sample *sample)\n{\n#ifdef PERF_DLFILTER_HAS_MACHINE_PID\n\treturn sample->size >= offsetof(struct perf_dlfilter_sample, vcpu) + sizeof(sample->vcpu);\n#else\n\treturn false;\n#endif\n}\n----\n\nThe perf_dlfilter_fns structure\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe 'perf_dlfilter_fns' structure is populated with function pointers when the\nfile is loaded. The functions can be called by 'filter_event' or\n'filter_event_early'.\n\n[source,c]\n----\nstruct perf_dlfilter_fns {\n\tconst struct perf_dlfilter_al *(*resolve_ip)(void *ctx);\n\tconst struct perf_dlfilter_al *(*resolve_addr)(void *ctx);\n\tchar **(*args)(void *ctx, int *dlargc);\n\t__s32 (*resolve_address)(void *ctx, __u64 address, struct perf_dlfilter_al *al);\n\tconst __u8 *(*insn)(void *ctx, __u32 *length);\n\tconst char *(*srcline)(void *ctx, __u32 *line_number);\n\tstruct perf_event_attr *(*attr)(void *ctx);\n\t__s32 (*object_code)(void *ctx, __u64 ip, void *buf, __u32 len);\n\tvoid (*al_cleanup)(void *ctx, struct perf_dlfilter_al *al);\n\tvoid *(*reserved[119])(void *);\n};\n----\n\n'resolve_ip' returns information about ip.\n\n'resolve_addr' returns information about addr (if addr_correlates_sym).\n\n'args' returns arguments from --dlarg options.\n\n'resolve_address' provides information about 'address'. al->size must be set\nbefore calling. Returns 0 on success, -1 otherwise. Call al_cleanup() (if present,\nsee below) when 'al' data is no longer needed.\n\n'insn' returns instruction bytes and length.\n\n'srcline' return source file name and line number.\n\n'attr' returns perf_event_attr, refer <linux/perf_event.h>.\n\n'object_code' reads object code and returns the number of bytes read.\n\n'al_cleanup' must be called (if present, so check perf_dlfilter_fns.al_cleanup != NULL)\nafter resolve_address() to free any associated resources.\n\nDo not assume pointers obtained via perf_dlfilter_fns are valid (dereferenceable)\nafter 'filter_event' and 'filter_event_early' return.\n\nThe perf_dlfilter_al structure\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe 'perf_dlfilter_al' structure contains information about an address.\n\n[source,c]\n----\n/*\n * Address location (as per perf script)\n */\nstruct perf_dlfilter_al {\n\t__u32 size; /* Size of this structure (for compatibility checking) */\n\t__u32 symoff;\n\tconst char *sym;\n\t__u64 addr; /* Mapped address (from dso) */\n\t__u64 sym_start;\n\t__u64 sym_end;\n\tconst char *dso;\n\t__u8  sym_binding; /* STB_LOCAL, STB_GLOBAL or STB_WEAK, refer <elf.h> */\n\t__u8  is_64_bit; /* Only valid if dso is not NULL */\n\t__u8  is_kernel_ip; /* True if in kernel space */\n\t__u32 buildid_size;\n\t__u8 *buildid;\n\t/* Below members are only populated by resolve_ip() */\n\t__u8 filtered; /* true if this sample event will be filtered out */\n\tconst char *comm;\n\tvoid *priv; /* Private data. Do not change */\n};\n----\n\nDo not assume data referenced by pointers in struct perf_dlfilter_al\nis valid (dereferenceable) after 'filter_event' and 'filter_event_early' return.\n\nperf_dlfilter_sample flags\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe 'flags' member of 'perf_dlfilter_sample' corresponds with the flags field\nof perf script. The bits of the flags are as follows:\n\n[source,c]\n----\n/* Definitions for perf_dlfilter_sample flags */\nenum {\n\tPERF_DLFILTER_FLAG_BRANCH\t= 1ULL << 0,\n\tPERF_DLFILTER_FLAG_CALL\t\t= 1ULL << 1,\n\tPERF_DLFILTER_FLAG_RETURN\t= 1ULL << 2,\n\tPERF_DLFILTER_FLAG_CONDITIONAL\t= 1ULL << 3,\n\tPERF_DLFILTER_FLAG_SYSCALLRET\t= 1ULL << 4,\n\tPERF_DLFILTER_FLAG_ASYNC\t= 1ULL << 5,\n\tPERF_DLFILTER_FLAG_INTERRUPT\t= 1ULL << 6,\n\tPERF_DLFILTER_FLAG_TX_ABORT\t= 1ULL << 7,\n\tPERF_DLFILTER_FLAG_TRACE_BEGIN\t= 1ULL << 8,\n\tPERF_DLFILTER_FLAG_TRACE_END\t= 1ULL << 9,\n\tPERF_DLFILTER_FLAG_IN_TX\t= 1ULL << 10,\n\tPERF_DLFILTER_FLAG_VMENTRY\t= 1ULL << 11,\n\tPERF_DLFILTER_FLAG_VMEXIT\t= 1ULL << 12,\n};\n----\n\nEXAMPLE\n-------\n\nFilter out everything except branches from \"foo\" to \"bar\":\n\n[source,c]\n----\n#include <perf/perf_dlfilter.h>\n#include <string.h>\n\nstruct perf_dlfilter_fns perf_dlfilter_fns;\n\nint filter_event(void *data, const struct perf_dlfilter_sample *sample, void *ctx)\n{\n\tconst struct perf_dlfilter_al *al;\n\tconst struct perf_dlfilter_al *addr_al;\n\n\tif (!sample->ip || !sample->addr_correlates_sym)\n\t\treturn 1;\n\n\tal = perf_dlfilter_fns.resolve_ip(ctx);\n\tif (!al || !al->sym || strcmp(al->sym, \"foo\"))\n\t\treturn 1;\n\n\taddr_al = perf_dlfilter_fns.resolve_addr(ctx);\n\tif (!addr_al || !addr_al->sym || strcmp(addr_al->sym, \"bar\"))\n\t\treturn 1;\n\n\treturn 0;\n}\n----\n\nTo build the shared object, assuming perf has been installed for the local user\ni.e. perf_dlfilter.h is in ~/include/perf :\n\n\tgcc -c -I ~/include -fpic dlfilter-example.c\n\tgcc -shared -o dlfilter-example.so dlfilter-example.o\n\nTo use the filter with perf script:\n\n\tperf script --dlfilter dlfilter-example.so\n\nNOTES\n-----\n\nThe dlfilter .so file will be dependent on shared libraries. If those change,\nit may be necessary to rebuild the .so. Also there may be unexpected results\nif the .so uses different versions of the shared libraries that perf uses.\nVersions can be checked using the ldd command.\n\nSEE ALSO\n--------\nlinkperf:perf-script[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}