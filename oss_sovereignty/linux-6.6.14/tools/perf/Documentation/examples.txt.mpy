{
  "module_name": "examples.txt",
  "hash_id": "527e3a80fff10080dfd2ef582f07b0accda1abaebc937b92edd5bc50e78b1428",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/examples.txt",
  "human_readable_source": "\n\t\t------------------------------\n\t\t****** perf by examples ******\n\t\t------------------------------\n\n[ From an e-mail by Ingo Molnar, https://lore.kernel.org/lkml/20090804195717.GA5998@elte.hu ]\n\n\nFirst, discovery/enumeration of available counters can be done via\n'perf list':\n\ntitan:~> perf list\n  [...]\n  kmem:kmalloc                             [Tracepoint event]\n  kmem:kmem_cache_alloc                    [Tracepoint event]\n  kmem:kmalloc_node                        [Tracepoint event]\n  kmem:kmem_cache_alloc_node               [Tracepoint event]\n  kmem:kfree                               [Tracepoint event]\n  kmem:kmem_cache_free                     [Tracepoint event]\n  kmem:mm_page_free                        [Tracepoint event]\n  kmem:mm_page_free_batched                [Tracepoint event]\n  kmem:mm_page_alloc                       [Tracepoint event]\n  kmem:mm_page_alloc_zone_locked           [Tracepoint event]\n  kmem:mm_page_pcpu_drain                  [Tracepoint event]\n  kmem:mm_page_alloc_extfrag               [Tracepoint event]\n\nThen any (or all) of the above event sources can be activated and\nmeasured. For example the page alloc/free properties of a 'hackbench\nrun' are:\n\n titan:~> perf stat -e kmem:mm_page_pcpu_drain -e kmem:mm_page_alloc\n -e kmem:mm_page_free_batched -e kmem:mm_page_free ./hackbench 10\n Time: 0.575\n\n Performance counter stats for './hackbench 10':\n\n          13857  kmem:mm_page_pcpu_drain\n          27576  kmem:mm_page_alloc\n           6025  kmem:mm_page_free_batched\n          20934  kmem:mm_page_free\n\n    0.613972165  seconds time elapsed\n\nYou can observe the statistical properties as well, by using the\n'repeat the workload N times' feature of perf stat:\n\n titan:~> perf stat --repeat 5 -e kmem:mm_page_pcpu_drain -e\n   kmem:mm_page_alloc -e kmem:mm_page_free_batched -e\n   kmem:mm_page_free ./hackbench 10\n Time: 0.627\n Time: 0.644\n Time: 0.564\n Time: 0.559\n Time: 0.626\n\n Performance counter stats for './hackbench 10' (5 runs):\n\n          12920  kmem:mm_page_pcpu_drain    ( +-   3.359% )\n          25035  kmem:mm_page_alloc         ( +-   3.783% )\n           6104  kmem:mm_page_free_batched  ( +-   0.934% )\n          18376  kmem:mm_page_free\t    ( +-   4.941% )\n\n    0.643954516  seconds time elapsed   ( +-   2.363% )\n\nFurthermore, these tracepoints can be used to sample the workload as\nwell. For example the page allocations done by a 'git gc' can be\ncaptured the following way:\n\n titan:~/git> perf record -e kmem:mm_page_alloc -c 1 ./git gc\n Counting objects: 1148, done.\n Delta compression using up to 2 threads.\n Compressing objects: 100% (450/450), done.\n Writing objects: 100% (1148/1148), done.\n Total 1148 (delta 690), reused 1148 (delta 690)\n [ perf record: Captured and wrote 0.267 MB perf.data (~11679 samples) ]\n\nTo check which functions generated page allocations:\n\n titan:~/git> perf report\n # Samples: 10646\n #\n # Overhead          Command               Shared Object\n # ........  ...............  ..........................\n #\n    23.57%       git-repack  /lib64/libc-2.5.so\n    21.81%              git  /lib64/libc-2.5.so\n    14.59%              git  ./git\n    11.79%       git-repack  ./git\n     7.12%              git  /lib64/ld-2.5.so\n     3.16%       git-repack  /lib64/libpthread-2.5.so\n     2.09%       git-repack  /bin/bash\n     1.97%               rm  /lib64/libc-2.5.so\n     1.39%               mv  /lib64/ld-2.5.so\n     1.37%               mv  /lib64/libc-2.5.so\n     1.12%       git-repack  /lib64/ld-2.5.so\n     0.95%               rm  /lib64/ld-2.5.so\n     0.90%  git-update-serv  /lib64/libc-2.5.so\n     0.73%  git-update-serv  /lib64/ld-2.5.so\n     0.68%             perf  /lib64/libpthread-2.5.so\n     0.64%       git-repack  /usr/lib64/libz.so.1.2.3\n\nOr to see it on a more finegrained level:\n\ntitan:~/git> perf report --sort comm,dso,symbol\n# Samples: 10646\n#\n# Overhead          Command               Shared Object  Symbol\n# ........  ...............  ..........................  ......\n#\n     9.35%       git-repack  ./git                       [.] insert_obj_hash\n     9.12%              git  ./git                       [.] insert_obj_hash\n     7.31%              git  /lib64/libc-2.5.so          [.] memcpy\n     6.34%       git-repack  /lib64/libc-2.5.so          [.] _int_malloc\n     6.24%       git-repack  /lib64/libc-2.5.so          [.] memcpy\n     5.82%       git-repack  /lib64/libc-2.5.so          [.] __GI___fork\n     5.47%              git  /lib64/libc-2.5.so          [.] _int_malloc\n     2.99%              git  /lib64/libc-2.5.so          [.] memset\n\nFurthermore, call-graph sampling can be done too, of page\nallocations - to see precisely what kind of page allocations there\nare:\n\n titan:~/git> perf record -g -e kmem:mm_page_alloc -c 1 ./git gc\n Counting objects: 1148, done.\n Delta compression using up to 2 threads.\n Compressing objects: 100% (450/450), done.\n Writing objects: 100% (1148/1148), done.\n Total 1148 (delta 690), reused 1148 (delta 690)\n [ perf record: Captured and wrote 0.963 MB perf.data (~42069 samples) ]\n\n titan:~/git> perf report -g\n # Samples: 10686\n #\n # Overhead          Command               Shared Object\n # ........  ...............  ..........................\n #\n    23.25%       git-repack  /lib64/libc-2.5.so\n                |\n                |--50.00%-- _int_free\n                |\n                |--37.50%-- __GI___fork\n                |          make_child\n                |\n                |--12.50%-- ptmalloc_unlock_all2\n                |          make_child\n                |\n                 --6.25%-- __GI_strcpy\n    21.61%              git  /lib64/libc-2.5.so\n                |\n                |--30.00%-- __GI_read\n                |          |\n                |           --83.33%-- git_config_from_file\n                |                     git_config\n                |                     |\n   [...]\n\nOr you can observe the whole system's page allocations for 10\nseconds:\n\ntitan:~/git> perf stat -a -e kmem:mm_page_pcpu_drain -e\nkmem:mm_page_alloc -e kmem:mm_page_free_batched -e\nkmem:mm_page_free sleep 10\n\n Performance counter stats for 'sleep 10':\n\n         171585  kmem:mm_page_pcpu_drain\n         322114  kmem:mm_page_alloc\n          73623  kmem:mm_page_free_batched\n         254115  kmem:mm_page_free\n\n   10.000591410  seconds time elapsed\n\nOr observe how fluctuating the page allocations are, via statistical\nanalysis done over ten 1-second intervals:\n\n titan:~/git> perf stat --repeat 10 -a -e kmem:mm_page_pcpu_drain -e\n   kmem:mm_page_alloc -e kmem:mm_page_free_batched -e\n   kmem:mm_page_free sleep 1\n\n Performance counter stats for 'sleep 1' (10 runs):\n\n          17254  kmem:mm_page_pcpu_drain    ( +-   3.709% )\n          34394  kmem:mm_page_alloc         ( +-   4.617% )\n           7509  kmem:mm_page_free_batched  ( +-   4.820% )\n          25653  kmem:mm_page_free\t    ( +-   3.672% )\n\n    1.058135029  seconds time elapsed   ( +-   3.089% )\n\nOr you can annotate the recorded 'git gc' run on a per symbol basis\nand check which instructions/source-code generated page allocations:\n\n titan:~/git> perf annotate __GI___fork\n ------------------------------------------------\n  Percent |      Source code & Disassembly of libc-2.5.so\n ------------------------------------------------\n          :\n          :\n          :      Disassembly of section .plt:\n          :      Disassembly of section .text:\n          :\n          :      00000031a2e95560 <__fork>:\n [...]\n     0.00 :        31a2e95602:   b8 38 00 00 00          mov    $0x38,%eax\n     0.00 :        31a2e95607:   0f 05                   syscall\n    83.42 :        31a2e95609:   48 3d 00 f0 ff ff       cmp    $0xfffffffffffff000,%rax\n     0.00 :        31a2e9560f:   0f 87 4d 01 00 00       ja     31a2e95762 <__fork+0x202>\n     0.00 :        31a2e95615:   85 c0                   test   %eax,%eax\n\n( this shows that 83.42% of __GI___fork's page allocations come from\n  the 0x38 system call it performs. )\n\netc. etc. - a lot more is possible. I could list a dozen of\nother different usecases straight away - neither of which is\npossible via /proc/vmstat.\n\n/proc/vmstat is not in the same league really, in terms of\nexpressive power of system analysis and performance\nanalysis.\n\nAll that the above results needed were those new tracepoints\nin include/tracing/events/kmem.h.\n\n\tIngo\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}