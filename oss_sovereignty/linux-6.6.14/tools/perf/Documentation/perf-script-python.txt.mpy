{
  "module_name": "perf-script-python.txt",
  "hash_id": "1ca45652aa913f42c5ee6789147f9f94d290d1b452f1c87fe3087dcdeb28c686",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-script-python.txt",
  "human_readable_source": "perf-script-python(1)\n====================\n\nNAME\n----\nperf-script-python - Process trace data with a Python script\n\nSYNOPSIS\n--------\n[verse]\n'perf script' [-s [Python]:script[.py] ]\n\nDESCRIPTION\n-----------\n\nThis perf script option is used to process perf script data using perf's\nbuilt-in Python interpreter.  It reads and processes the input file and\ndisplays the results of the trace analysis implemented in the given\nPython script, if any.\n\nA QUICK EXAMPLE\n---------------\n\nThis section shows the process, start to finish, of creating a working\nPython script that aggregates and extracts useful information from a\nraw perf script stream.  You can avoid reading the rest of this\ndocument if an example is enough for you; the rest of the document\nprovides more details on each step and lists the library functions\navailable to script writers.\n\nThis example actually details the steps that were used to create the\n'syscall-counts' script you see when you list the available perf script\nscripts via 'perf script -l'.  As such, this script also shows how to\nintegrate your script into the list of general-purpose 'perf script'\nscripts listed by that command.\n\nThe syscall-counts script is a simple script, but demonstrates all the\nbasic ideas necessary to create a useful script.  Here's an example\nof its output (syscall names are not yet supported, they will appear\nas numbers):\n\n----\nsyscall events:\n\nevent                                          count\n----------------------------------------  -----------\nsys_write                                     455067\nsys_getdents                                    4072\nsys_close                                       3037\nsys_swapoff                                     1769\nsys_read                                         923\nsys_sched_setparam                               826\nsys_open                                         331\nsys_newfstat                                     326\nsys_mmap                                         217\nsys_munmap                                       216\nsys_futex                                        141\nsys_select                                       102\nsys_poll                                          84\nsys_setitimer                                     12\nsys_writev                                         8\n15                                                 8\nsys_lseek                                          7\nsys_rt_sigprocmask                                 6\nsys_wait4                                          3\nsys_ioctl                                          3\nsys_set_robust_list                                1\nsys_exit                                           1\n56                                                 1\nsys_access                                         1\n----\n\nBasically our task is to keep a per-syscall tally that gets updated\nevery time a system call occurs in the system.  Our script will do\nthat, but first we need to record the data that will be processed by\nthat script.  Theoretically, there are a couple of ways we could do\nthat:\n\n- we could enable every event under the tracing/events/syscalls\n  directory, but this is over 600 syscalls, well beyond the number\n  allowable by perf.  These individual syscall events will however be\n  useful if we want to later use the guidance we get from the\n  general-purpose scripts to drill down and get more detail about\n  individual syscalls of interest.\n\n- we can enable the sys_enter and/or sys_exit syscalls found under\n  tracing/events/raw_syscalls.  These are called for all syscalls; the\n  'id' field can be used to distinguish between individual syscall\n  numbers.\n\nFor this script, we only need to know that a syscall was entered; we\ndon't care how it exited, so we'll use 'perf record' to record only\nthe sys_enter events:\n\n----\n# perf record -a -e raw_syscalls:sys_enter\n\n^C[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 56.545 MB perf.data (~2470503 samples) ]\n----\n\nThe options basically say to collect data for every syscall event\nsystem-wide and multiplex the per-cpu output into a single stream.\nThat single stream will be recorded in a file in the current directory\ncalled perf.data.\n\nOnce we have a perf.data file containing our data, we can use the -g\n'perf script' option to generate a Python script that will contain a\ncallback handler for each event type found in the perf.data trace\nstream (for more details, see the STARTER SCRIPTS section).\n\n----\n# perf script -g python\ngenerated Python script: perf-script.py\n\nThe output file created also in the current directory is named\nperf-script.py.  Here's the file in its entirety:\n\n# perf script event handlers, generated by perf script -g python\n# Licensed under the terms of the GNU GPL License version 2\n\n# The common_* event handler fields are the most useful fields common to\n# all events.  They don't necessarily correspond to the 'common_*' fields\n# in the format files.  Those fields not available as handler params can\n# be retrieved using Python functions of the form common_*(context).\n# See the perf-script-python Documentation for the list of available functions.\n\nimport os\nimport sys\n\nsys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n\t'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\nfrom perf_trace_context import *\nfrom Core import *\n\ndef trace_begin():\n\tprint \"in trace_begin\"\n\ndef trace_end():\n\tprint \"in trace_end\"\n\ndef raw_syscalls__sys_enter(event_name, context, common_cpu,\n\tcommon_secs, common_nsecs, common_pid, common_comm,\n\tid, args):\n\t\tprint_header(event_name, common_cpu, common_secs, common_nsecs,\n\t\t\tcommon_pid, common_comm)\n\n\t\tprint \"id=%d, args=%s\\n\" % \\\n\t\t(id, args),\n\ndef trace_unhandled(event_name, context, event_fields_dict):\n\t\tprint ' '.join(['%s=%s'%(k,str(v))for k,v in sorted(event_fields_dict.items())])\n\ndef print_header(event_name, cpu, secs, nsecs, pid, comm):\n\tprint \"%-20s %5u %05u.%09u %8u %-20s \" % \\\n\t(event_name, cpu, secs, nsecs, pid, comm),\n----\n\nAt the top is a comment block followed by some import statements and a\npath append which every perf script script should include.\n\nFollowing that are a couple generated functions, trace_begin() and\ntrace_end(), which are called at the beginning and the end of the\nscript respectively (for more details, see the SCRIPT_LAYOUT section\nbelow).\n\nFollowing those are the 'event handler' functions generated one for\nevery event in the 'perf record' output.  The handler functions take\nthe form subsystem\\__event_name, and contain named parameters, one for\neach field in the event; in this case, there's only one event,\nraw_syscalls__sys_enter().  (see the EVENT HANDLERS section below for\nmore info on event handlers).\n\nThe final couple of functions are, like the begin and end functions,\ngenerated for every script.  The first, trace_unhandled(), is called\nevery time the script finds an event in the perf.data file that\ndoesn't correspond to any event handler in the script.  This could\nmean either that the record step recorded event types that it wasn't\nreally interested in, or the script was run against a trace file that\ndoesn't correspond to the script.\n\nThe script generated by -g option simply prints a line for each\nevent found in the trace stream i.e. it basically just dumps the event\nand its parameter values to stdout.  The print_header() function is\nsimply a utility function used for that purpose.  Let's rename the\nscript and run it to see the default output:\n\n----\n# mv perf-script.py syscall-counts.py\n# perf script -s syscall-counts.py\n\nraw_syscalls__sys_enter     1 00840.847582083     7506 perf                  id=1, args=\nraw_syscalls__sys_enter     1 00840.847595764     7506 perf                  id=1, args=\nraw_syscalls__sys_enter     1 00840.847620860     7506 perf                  id=1, args=\nraw_syscalls__sys_enter     1 00840.847710478     6533 npviewer.bin          id=78, args=\nraw_syscalls__sys_enter     1 00840.847719204     6533 npviewer.bin          id=142, args=\nraw_syscalls__sys_enter     1 00840.847755445     6533 npviewer.bin          id=3, args=\nraw_syscalls__sys_enter     1 00840.847775601     6533 npviewer.bin          id=3, args=\nraw_syscalls__sys_enter     1 00840.847781820     6533 npviewer.bin          id=3, args=\n.\n.\n.\n----\n\nOf course, for this script, we're not interested in printing every\ntrace event, but rather aggregating it in a useful way.  So we'll get\nrid of everything to do with printing as well as the trace_begin() and\ntrace_unhandled() functions, which we won't be using.  That leaves us\nwith this minimalistic skeleton:\n\n----\nimport os\nimport sys\n\nsys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n\t'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\nfrom perf_trace_context import *\nfrom Core import *\n\ndef trace_end():\n\tprint \"in trace_end\"\n\ndef raw_syscalls__sys_enter(event_name, context, common_cpu,\n\tcommon_secs, common_nsecs, common_pid, common_comm,\n\tid, args):\n----\n\nIn trace_end(), we'll simply print the results, but first we need to\ngenerate some results to print.  To do that we need to have our\nsys_enter() handler do the necessary tallying until all events have\nbeen counted.  A hash table indexed by syscall id is a good way to\nstore that information; every time the sys_enter() handler is called,\nwe simply increment a count associated with that hash entry indexed by\nthat syscall id:\n\n----\n  syscalls = autodict()\n\n  try:\n    syscalls[id] += 1\n  except TypeError:\n    syscalls[id] = 1\n----\n\nThe syscalls 'autodict' object is a special kind of Python dictionary\n(implemented in Core.py) that implements Perl's 'autovivifying' hashes\nin Python i.e. with autovivifying hashes, you can assign nested hash\nvalues without having to go to the trouble of creating intermediate\nlevels if they don't exist e.g syscalls[comm][pid][id] = 1 will create\nthe intermediate hash levels and finally assign the value 1 to the\nhash entry for 'id' (because the value being assigned isn't a hash\nobject itself, the initial value is assigned in the TypeError\nexception.  Well, there may be a better way to do this in Python but\nthat's what works for now).\n\nPutting that code into the raw_syscalls__sys_enter() handler, we\neffectively end up with a single-level dictionary keyed on syscall id\nand having the counts we've tallied as values.\n\nThe print_syscall_totals() function iterates over the entries in the\ndictionary and displays a line for each entry containing the syscall\nname (the dictionary keys contain the syscall ids, which are passed to\nthe Util function syscall_name(), which translates the raw syscall\nnumbers to the corresponding syscall name strings).  The output is\ndisplayed after all the events in the trace have been processed, by\ncalling the print_syscall_totals() function from the trace_end()\nhandler called at the end of script processing.\n\nThe final script producing the output shown above is shown in its\nentirety below (syscall_name() helper is not yet available, you can\nonly deal with id's for now):\n\n----\nimport os\nimport sys\n\nsys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n\t'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\nfrom perf_trace_context import *\nfrom Core import *\nfrom Util import *\n\nsyscalls = autodict()\n\ndef trace_end():\n\tprint_syscall_totals()\n\ndef raw_syscalls__sys_enter(event_name, context, common_cpu,\n\tcommon_secs, common_nsecs, common_pid, common_comm,\n\tid, args):\n\ttry:\n\t\tsyscalls[id] += 1\n\texcept TypeError:\n\t\tsyscalls[id] = 1\n\ndef print_syscall_totals():\n    if for_comm is not None:\n\t    print \"\\nsyscall events for %s:\\n\\n\" % (for_comm),\n    else:\n\t    print \"\\nsyscall events:\\n\\n\",\n\n    print \"%-40s  %10s\\n\" % (\"event\", \"count\"),\n    print \"%-40s  %10s\\n\" % (\"----------------------------------------\", \\\n                                 \"-----------\"),\n\n    for id, val in sorted(syscalls.iteritems(), key = lambda(k, v): (v, k), \\\n\t\t\t\t  reverse = True):\n\t    print \"%-40s  %10d\\n\" % (syscall_name(id), val),\n----\n\nThe script can be run just as before:\n\n  # perf script -s syscall-counts.py\n\nSo those are the essential steps in writing and running a script.  The\nprocess can be generalized to any tracepoint or set of tracepoints\nyou're interested in - basically find the tracepoint(s) you're\ninterested in by looking at the list of available events shown by\n'perf list' and/or look in /sys/kernel/tracing/events/ for\ndetailed event and field info, record the corresponding trace data\nusing 'perf record', passing it the list of interesting events,\ngenerate a skeleton script using 'perf script -g python' and modify the\ncode to aggregate and display it for your particular needs.\n\nAfter you've done that you may end up with a general-purpose script\nthat you want to keep around and have available for future use.  By\nwriting a couple of very simple shell scripts and putting them in the\nright place, you can have your script listed alongside the other\nscripts listed by the 'perf script -l' command e.g.:\n\n----\n# perf script -l\nList of available trace scripts:\n  wakeup-latency                       system-wide min/max/avg wakeup latency\n  rw-by-file <comm>                    r/w activity for a program, by file\n  rw-by-pid                            system-wide r/w activity\n----\n\nA nice side effect of doing this is that you also then capture the\nprobably lengthy 'perf record' command needed to record the events for\nthe script.\n\nTo have the script appear as a 'built-in' script, you write two simple\nscripts, one for recording and one for 'reporting'.\n\nThe 'record' script is a shell script with the same base name as your\nscript, but with -record appended.  The shell script should be put\ninto the perf/scripts/python/bin directory in the kernel source tree.\nIn that script, you write the 'perf record' command-line needed for\nyour script:\n\n----\n# cat kernel-source/tools/perf/scripts/python/bin/syscall-counts-record\n\n#!/bin/bash\nperf record -a -e raw_syscalls:sys_enter\n----\n\nThe 'report' script is also a shell script with the same base name as\nyour script, but with -report appended.  It should also be located in\nthe perf/scripts/python/bin directory.  In that script, you write the\n'perf script -s' command-line needed for running your script:\n\n----\n# cat kernel-source/tools/perf/scripts/python/bin/syscall-counts-report\n\n#!/bin/bash\n# description: system-wide syscall counts\nperf script -s ~/libexec/perf-core/scripts/python/syscall-counts.py\n----\n\nNote that the location of the Python script given in the shell script\nis in the libexec/perf-core/scripts/python directory - this is where\nthe script will be copied by 'make install' when you install perf.\nFor the installation to install your script there, your script needs\nto be located in the perf/scripts/python directory in the kernel\nsource tree:\n\n----\n# ls -al kernel-source/tools/perf/scripts/python\ntotal 32\ndrwxr-xr-x 4 trz trz 4096 2010-01-26 22:30 .\ndrwxr-xr-x 4 trz trz 4096 2010-01-26 22:29 ..\ndrwxr-xr-x 2 trz trz 4096 2010-01-26 22:29 bin\n-rw-r--r-- 1 trz trz 2548 2010-01-26 22:29 check-perf-script.py\ndrwxr-xr-x 3 trz trz 4096 2010-01-26 22:49 Perf-Trace-Util\n-rw-r--r-- 1 trz trz 1462 2010-01-26 22:30 syscall-counts.py\n----\n\nOnce you've done that (don't forget to do a new 'make install',\notherwise your script won't show up at run-time), 'perf script -l'\nshould show a new entry for your script:\n\n----\n# perf script -l\nList of available trace scripts:\n  wakeup-latency                       system-wide min/max/avg wakeup latency\n  rw-by-file <comm>                    r/w activity for a program, by file\n  rw-by-pid                            system-wide r/w activity\n  syscall-counts                       system-wide syscall counts\n----\n\nYou can now perform the record step via 'perf script record':\n\n  # perf script record syscall-counts\n\nand display the output using 'perf script report':\n\n  # perf script report syscall-counts\n\nSTARTER SCRIPTS\n---------------\n\nYou can quickly get started writing a script for a particular set of\ntrace data by generating a skeleton script using 'perf script -g\npython' in the same directory as an existing perf.data trace file.\nThat will generate a starter script containing a handler for each of\nthe event types in the trace file; it simply prints every available\nfield for each event in the trace file.\n\nYou can also look at the existing scripts in\n~/libexec/perf-core/scripts/python for typical examples showing how to\ndo basic things like aggregate event data, print results, etc.  Also,\nthe check-perf-script.py script, while not interesting for its results,\nattempts to exercise all of the main scripting features.\n\nEVENT HANDLERS\n--------------\n\nWhen perf script is invoked using a trace script, a user-defined\n'handler function' is called for each event in the trace.  If there's\nno handler function defined for a given event type, the event is\nignored (or passed to a 'trace_unhandled' function, see below) and the\nnext event is processed.\n\nMost of the event's field values are passed as arguments to the\nhandler function; some of the less common ones aren't - those are\navailable as calls back into the perf executable (see below).\n\nAs an example, the following perf record command can be used to record\nall sched_wakeup events in the system:\n\n # perf record -a -e sched:sched_wakeup\n\nTraces meant to be processed using a script should be recorded with\nthe above option: -a to enable system-wide collection.\n\nThe format file for the sched_wakeup event defines the following fields\n(see /sys/kernel/tracing/events/sched/sched_wakeup/format):\n\n----\n format:\n        field:unsigned short common_type;\n        field:unsigned char common_flags;\n        field:unsigned char common_preempt_count;\n        field:int common_pid;\n\n        field:char comm[TASK_COMM_LEN];\n        field:pid_t pid;\n        field:int prio;\n        field:int success;\n        field:int target_cpu;\n----\n\nThe handler function for this event would be defined as:\n\n----\ndef sched__sched_wakeup(event_name, context, common_cpu, common_secs,\n       common_nsecs, common_pid, common_comm,\n       comm, pid, prio, success, target_cpu):\n       pass\n----\n\nThe handler function takes the form subsystem__event_name.\n\nThe common_* arguments in the handler's argument list are the set of\narguments passed to all event handlers; some of the fields correspond\nto the common_* fields in the format file, but some are synthesized,\nand some of the common_* fields aren't common enough to to be passed\nto every event as arguments but are available as library functions.\n\nHere's a brief description of each of the invariant event args:\n\n event_name \t  \t    the name of the event as text\n context\t\t    an opaque 'cookie' used in calls back into perf\n common_cpu\t\t    the cpu the event occurred on\n common_secs\t\t    the secs portion of the event timestamp\n common_nsecs\t\t    the nsecs portion of the event timestamp\n common_pid\t\t    the pid of the current task\n common_comm\t\t    the name of the current process\n\nAll of the remaining fields in the event's format file have\ncounterparts as handler function arguments of the same name, as can be\nseen in the example above.\n\nThe above provides the basics needed to directly access every field of\nevery event in a trace, which covers 90% of what you need to know to\nwrite a useful trace script.  The sections below cover the rest.\n\nSCRIPT LAYOUT\n-------------\n\nEvery perf script Python script should start by setting up a Python\nmodule search path and 'import'ing a few support modules (see module\ndescriptions below):\n\n----\n import os\n import sys\n\n sys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n\t      '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\n from perf_trace_context import *\n from Core import *\n----\n\nThe rest of the script can contain handler functions and support\nfunctions in any order.\n\nAside from the event handler functions discussed above, every script\ncan implement a set of optional functions:\n\n*trace_begin*, if defined, is called before any event is processed and\ngives scripts a chance to do setup tasks:\n\n----\ndef trace_begin():\n    pass\n----\n\n*trace_end*, if defined, is called after all events have been\n processed and gives scripts a chance to do end-of-script tasks, such\n as display results:\n\n----\ndef trace_end():\n    pass\n----\n\n*trace_unhandled*, if defined, is called after for any event that\n doesn't have a handler explicitly defined for it.  The standard set\n of common arguments are passed into it:\n\n----\ndef trace_unhandled(event_name, context, event_fields_dict):\n    pass\n----\n\n*process_event*, if defined, is called for any non-tracepoint event\n\n----\ndef process_event(param_dict):\n    pass\n----\n\n*context_switch*, if defined, is called for any context switch\n\n----\ndef context_switch(ts, cpu, pid, tid, np_pid, np_tid, machine_pid, out, out_preempt, *x):\n    pass\n----\n\n*auxtrace_error*, if defined, is called for any AUX area tracing error\n\n----\ndef auxtrace_error(typ, code, cpu, pid, tid, ip, ts, msg, cpumode, *x):\n    pass\n----\n\nThe remaining sections provide descriptions of each of the available\nbuilt-in perf script Python modules and their associated functions.\n\nAVAILABLE MODULES AND FUNCTIONS\n-------------------------------\n\nThe following sections describe the functions and variables available\nvia the various perf script Python modules.  To use the functions and\nvariables from the given module, add the corresponding 'from XXXX\nimport' line to your perf script script.\n\nCore.py Module\n~~~~~~~~~~~~~~\n\nThese functions provide some essential functions to user scripts.\n\nThe *flag_str* and *symbol_str* functions provide human-readable\nstrings for flag and symbolic fields.  These correspond to the strings\nand values parsed from the 'print fmt' fields of the event format\nfiles:\n\n  flag_str(event_name, field_name, field_value) - returns the string representation corresponding to field_value for the flag field field_name of event event_name\n  symbol_str(event_name, field_name, field_value) - returns the string representation corresponding to field_value for the symbolic field field_name of event event_name\n\nThe *autodict* function returns a special kind of Python\ndictionary that implements Perl's 'autovivifying' hashes in Python\ni.e. with autovivifying hashes, you can assign nested hash values\nwithout having to go to the trouble of creating intermediate levels if\nthey don't exist.\n\n  autodict() - returns an autovivifying dictionary instance\n\n\nperf_trace_context Module\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome of the 'common' fields in the event format file aren't all that\ncommon, but need to be made accessible to user scripts nonetheless.\n\nperf_trace_context defines a set of functions that can be used to\naccess this data in the context of the current event.  Each of these\nfunctions expects a context variable, which is the same as the\ncontext variable passed into every tracepoint event handler as the second\nargument. For non-tracepoint events, the context variable is also present\nas perf_trace_context.perf_script_context .\n\n common_pc(context) - returns common_preempt count for the current event\n common_flags(context) - returns common_flags for the current event\n common_lock_depth(context) - returns common_lock_depth for the current event\n perf_sample_insn(context) - returns the machine code instruction\n perf_set_itrace_options(context, itrace_options) - set --itrace options if they have not been set already\n perf_sample_srcline(context) - returns source_file_name, line_number\n perf_sample_srccode(context) - returns source_file_name, line_number, source_line\n\n\nUtil.py Module\n~~~~~~~~~~~~~~\n\nVarious utility functions for use with perf script:\n\n  nsecs(secs, nsecs) - returns total nsecs given secs/nsecs pair\n  nsecs_secs(nsecs) - returns whole secs portion given nsecs\n  nsecs_nsecs(nsecs) - returns nsecs remainder given nsecs\n  nsecs_str(nsecs) - returns printable string in the form secs.nsecs\n  avg(total, n) - returns average given a sum and a total number of values\n\nSUPPORTED FIELDS\n----------------\n\nCurrently supported fields:\n\nev_name, comm, pid, tid, cpu, ip, time, period, phys_addr, addr,\nsymbol, symoff, dso, time_enabled, time_running, values, callchain,\nbrstack, brstacksym, datasrc, datasrc_decode, iregs, uregs,\nweight, transaction, raw_buf, attr, cpumode.\n\nFields that may also be present:\n\n flags - sample flags\n flags_disp - sample flags display\n insn_cnt - instruction count for determining instructions-per-cycle (IPC)\n cyc_cnt - cycle count for determining IPC\n addr_correlates_sym - addr can correlate to a symbol\n addr_dso - addr dso\n addr_symbol - addr symbol\n addr_symoff - addr symbol offset\n\nSome fields have sub items:\n\nbrstack:\n    from, to, from_dsoname, to_dsoname, mispred,\n    predicted, in_tx, abort, cycles.\n\nbrstacksym:\n    items: from, to, pred, in_tx, abort (converted string)\n\nFor example,\nWe can use this code to print brstack \"from\", \"to\", \"cycles\".\n\nif 'brstack' in dict:\n\tfor entry in dict['brstack']:\n\t\tprint \"from %s, to %s, cycles %s\" % (entry[\"from\"], entry[\"to\"], entry[\"cycles\"])\n\nSEE ALSO\n--------\nlinkperf:perf-script[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}