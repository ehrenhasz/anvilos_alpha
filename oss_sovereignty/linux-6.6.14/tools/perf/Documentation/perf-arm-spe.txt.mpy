{
  "module_name": "perf-arm-spe.txt",
  "hash_id": "754354677e33ec59889e523e7009997f9b9aee7afaefef4900100dd7ba56a94e",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-arm-spe.txt",
  "human_readable_source": "perf-arm-spe(1)\n================\n\nNAME\n----\nperf-arm-spe - Support for Arm Statistical Profiling Extension within Perf tools\n\nSYNOPSIS\n--------\n[verse]\n'perf record' -e arm_spe//\n\nDESCRIPTION\n-----------\n\nThe SPE (Statistical Profiling Extension) feature provides accurate attribution of latencies and\n events down to individual instructions. Rather than being interrupt-driven, it picks an\ninstruction to sample and then captures data for it during execution. Data includes execution time\nin cycles. For loads and stores it also includes data address, cache miss events, and data origin.\n\nThe sampling has 5 stages:\n\n  1. Choose an operation\n  2. Collect data about the operation\n  3. Optionally discard the record based on a filter\n  4. Write the record to memory\n  5. Interrupt when the buffer is full\n\nChoose an operation\n~~~~~~~~~~~~~~~~~~~\n\nThis is chosen from a sample population, for SPE this is an IMPLEMENTATION DEFINED choice of all\narchitectural instructions or all micro-ops. Sampling happens at a programmable interval. The\narchitecture provides a mechanism for the SPE driver to infer the minimum interval at which it should\nsample. This minimum interval is used by the driver if no interval is specified. A pseudo-random\nperturbation is also added to the sampling interval by default.\n\nCollect data about the operation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nProgram counter, PMU events, timings and data addresses related to the operation are recorded.\nSampling ensures there is only one sampled operation is in flight.\n\nOptionally discard the record based on a filter\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBased on programmable criteria, choose whether to keep the record or discard it. If the record is\ndiscarded then the flow stops here for this sample.\n\nWrite the record to memory\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe record is appended to a memory buffer\n\nInterrupt when the buffer is full\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen the buffer fills, an interrupt is sent and the driver signals Perf to collect the records.\nPerf saves the raw data in the perf.data file.\n\nOpening the file\n----------------\n\nUp until this point no decoding of the SPE data was done by either the kernel or Perf. Only when the\nrecorded file is opened with 'perf report' or 'perf script' does the decoding happen. When decoding\nthe data, Perf generates \"synthetic samples\" as if these were generated at the time of the\nrecording. These samples are the same as if normal sampling was done by Perf without using SPE,\nalthough they may have more attributes associated with them. For example a normal sample may have\njust the instruction pointer, but an SPE sample can have data addresses and latency attributes.\n\nWhy Sampling?\n-------------\n\n - Sampling, rather than tracing, cuts down the profiling problem to something more manageable for\n hardware. Only one sampled operation is in flight at a time.\n\n - Allows precise attribution data, including: Full PC of instruction, data virtual and physical\n addresses.\n\n - Allows correlation between an instruction and events, such as TLB and cache miss. (Data source\n indicates which particular cache was hit, but the meaning is implementation defined because\n different implementations can have different cache configurations.)\n\nHowever, SPE does not provide any call-graph information, and relies on statistical methods.\n\nCollisions\n----------\n\nWhen an operation is sampled while a previous sampled operation has not finished, a collision\noccurs. The new sample is dropped. Collisions affect the integrity of the data, so the sample rate\nshould be set to avoid collisions.\n\nThe 'sample_collision' PMU event can be used to determine the number of lost samples. Although this\ncount is based on collisions _before_ filtering occurs. Therefore this can not be used as an exact\nnumber for samples dropped that would have made it through the filter, but can be a rough\nguide.\n\nThe effect of microarchitectural sampling\n-----------------------------------------\n\nIf an implementation samples micro-operations instead of instructions, the results of sampling must\nbe weighted accordingly.\n\nFor example, if a given instruction A is always converted into two micro-operations, A0 and A1, it\nbecomes twice as likely to appear in the sample population.\n\nThe coarse effect of conversions, and, if applicable, sampling of speculative operations, can be\nestimated from the 'sample_pop' and 'inst_retired' PMU events.\n\nKernel Requirements\n-------------------\n\nThe ARM_SPE_PMU config must be set to build as either a module or statically.\n\nDepending on CPU model, the kernel may need to be booted with page table isolation disabled\n(kpti=off). If KPTI needs to be disabled, this will fail with a console message \"profiling buffer\ninaccessible. Try passing 'kpti=off' on the kernel command line\".\n\nCapturing SPE with perf command-line tools\n------------------------------------------\n\nYou can record a session with SPE samples:\n\n  perf record -e arm_spe// -- ./mybench\n\nThe sample period is set from the -c option, and because the minimum interval is used by default\nit's recommended to set this to a higher value. The value is written to PMSIRR.INTERVAL.\n\nConfig parameters\n~~~~~~~~~~~~~~~~~\n\nThese are placed between the // in the event and comma separated. For example '-e\narm_spe/load_filter=1,min_latency=10/'\n\n  branch_filter=1     - collect branches only (PMSFCR.B)\n  event_filter=<mask> - filter on specific events (PMSEVFR) - see bitfield description below\n  jitter=1            - use jitter to avoid resonance when sampling (PMSIRR.RND)\n  load_filter=1       - collect loads only (PMSFCR.LD)\n  min_latency=<n>     - collect only samples with this latency or higher* (PMSLATFR)\n  pa_enable=1         - collect physical address (as well as VA) of loads/stores (PMSCR.PA) - requires privilege\n  pct_enable=1        - collect physical timestamp instead of virtual timestamp (PMSCR.PCT) - requires privilege\n  store_filter=1      - collect stores only (PMSFCR.ST)\n  ts_enable=1         - enable timestamping with value of generic timer (PMSCR.TS)\n\n+++*+++ Latency is the total latency from the point at which sampling started on that instruction, rather\nthan only the execution latency.\n\nOnly some events can be filtered on; these include:\n\n  bit 1     - instruction retired (i.e. omit speculative instructions)\n  bit 3     - L1D refill\n  bit 5     - TLB refill\n  bit 7     - mispredict\n  bit 11    - misaligned access\n\nSo to sample just retired instructions:\n\n  perf record -e arm_spe/event_filter=2/ -- ./mybench\n\nor just mispredicted branches:\n\n  perf record -e arm_spe/event_filter=0x80/ -- ./mybench\n\nViewing the data\n~~~~~~~~~~~~~~~~~\n\nBy default perf report and perf script will assign samples to separate groups depending on the\nattributes/events of the SPE record. Because instructions can have multiple events associated with\nthem, the samples in these groups are not necessarily unique. For example perf report shows these\ngroups:\n\n  Available samples\n  0 arm_spe//\n  0 dummy:u\n  21 l1d-miss\n  897 l1d-access\n  5 llc-miss\n  7 llc-access\n  2 tlb-miss\n  1K tlb-access\n  36 branch-miss\n  0 remote-access\n  900 memory\n\nThe arm_spe// and dummy:u events are implementation details and are expected to be empty.\n\nTo get a full list of unique samples that are not sorted into groups, set the itrace option to\ngenerate 'instruction' samples. The period option is also taken into account, so set it to 1\ninstruction unless you want to further downsample the already sampled SPE data:\n\n  perf report --itrace=i1i\n\nMemory access details are also stored on the samples and this can be viewed with:\n\n  perf report --mem-mode\n\nCommon errors\n~~~~~~~~~~~~~\n\n - \"Cannot find PMU `arm_spe'. Missing kernel support?\"\n\n   Module not built or loaded, KPTI not disabled (see above), or running on a VM\n\n - \"Arm SPE CONTEXT packets not found in the traces.\"\n\n   Root privilege is required to collect context packets. But these only increase the accuracy of\n   assigning PIDs to kernel samples. For userspace sampling this can be ignored.\n\n - Excessively large perf.data file size\n\n   Increase sampling interval (see above)\n\n\nSEE ALSO\n--------\n\nlinkperf:perf-record[1], linkperf:perf-script[1], linkperf:perf-report[1],\nlinkperf:perf-inject[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}