{
  "module_name": "perf-top.txt",
  "hash_id": "39ae283016c3f5c7724a9d3d113b8aee74aa09ca5f0b1e9a56b4855e840a05f8",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-top.txt",
  "human_readable_source": "perf-top(1)\n===========\n\nNAME\n----\nperf-top - System profiling tool.\n\nSYNOPSIS\n--------\n[verse]\n'perf top' [-e <EVENT> | --event=EVENT] [<options>]\n\nDESCRIPTION\n-----------\nThis command generates and displays a performance counter profile in real time.\n\n\nOPTIONS\n-------\n-a::\n--all-cpus::\n        System-wide collection.  (default)\n\n-c <count>::\n--count=<count>::\n\tEvent period to sample.\n\n-C <cpu-list>::\n--cpu=<cpu>::\nMonitor only on the list of CPUs provided. Multiple CPUs can be provided as a\ncomma-separated list with no space: 0,1. Ranges of CPUs are specified with -: 0-2.\nDefault is to monitor all CPUS.\n\n-d <seconds>::\n--delay=<seconds>::\n\tNumber of seconds to delay between refreshes.\n\n-e <event>::\n--event=<event>::\n\tSelect the PMU event. Selection can be a symbolic event name\n\t(use 'perf list' to list all events) or a raw PMU event in the form\n\tof rN where N is a hexadecimal value that represents the raw register\n\tencoding with the layout of the event control registers as described\n\tby entries in /sys/bus/event_source/devices/cpu/format/*.\n\n-E <entries>::\n--entries=<entries>::\n\tDisplay this many functions.\n\n-f <count>::\n--count-filter=<count>::\n\tOnly display functions with more events than this.\n\n--group-sort-idx::\n\tSort the output by the event at the index n in group. If n is invalid,\n\tsort by the first event. It can support multiple groups with different\n\tamount of events. WARNING: This should be used on grouped events.\n\n-F <freq>::\n--freq=<freq>::\n\tProfile at this frequency. Use 'max' to use the currently maximum\n\tallowed frequency, i.e. the value in the kernel.perf_event_max_sample_rate\n\tsysctl.\n\n-i::\n--inherit::\n\tChild tasks do not inherit counters.\n\n-k <path>::\n--vmlinux=<path>::\n\tPath to vmlinux.  Required for annotation functionality.\n\n--ignore-vmlinux::\n\tIgnore vmlinux files.\n\n--kallsyms=<file>::\n\tkallsyms pathname\n\n-m <pages>::\n--mmap-pages=<pages>::\n\tNumber of mmap data pages (must be a power of two) or size\n\tspecification with appended unit character - B/K/M/G. The\n\tsize is rounded up to have nearest pages power of two value.\n\n-p <pid>::\n--pid=<pid>::\n\tProfile events on existing Process ID (comma separated list).\n\n-t <tid>::\n--tid=<tid>::\n        Profile events on existing thread ID (comma separated list).\n\n-u::\n--uid=::\n        Record events in threads owned by uid. Name or number.\n\n-r <priority>::\n--realtime=<priority>::\n\tCollect data with this RT SCHED_FIFO priority.\n\n--sym-annotate=<symbol>::\n        Annotate this symbol.\n\n-K::\n--hide_kernel_symbols::\n        Hide kernel symbols.\n\n-U::\n--hide_user_symbols::\n        Hide user symbols.\n\n--demangle-kernel::\n        Demangle kernel symbols.\n\n-D::\n--dump-symtab::\n        Dump the symbol table used for profiling.\n\n-v::\n--verbose::\n\tBe more verbose (show counter open errors, etc).\n\n-z::\n--zero::\n\tZero history across display updates.\n\n-s::\n--sort::\n\tSort by key(s): pid, comm, dso, symbol, parent, srcline, weight,\n\tlocal_weight, abort, in_tx, transaction, overhead, sample, period.\n\tPlease see description of --sort in the perf-report man page.\n\n--fields=::\n\tSpecify output field - multiple keys can be specified in CSV format.\n\tFollowing fields are available:\n\toverhead, overhead_sys, overhead_us, overhead_children, sample and period.\n\tAlso it can contain any sort key(s).\n\n\tBy default, every sort keys not specified in --field will be appended\n\tautomatically.\n\n-n::\n--show-nr-samples::\n\tShow a column with the number of samples.\n\n--show-total-period::\n\tShow a column with the sum of periods.\n\n--dsos::\n\tOnly consider symbols in these dsos.  This option will affect the\n\tpercentage of the overhead column.  See --percentage for more info.\n\n--comms::\n\tOnly consider symbols in these comms.  This option will affect the\n\tpercentage of the overhead column.  See --percentage for more info.\n\n--symbols::\n\tOnly consider these symbols.  This option will affect the\n\tpercentage of the overhead column.  See --percentage for more info.\n\n-M::\n--disassembler-style=:: Set disassembler style for objdump.\n\n--addr2line=<path>::\n        Path to addr2line binary.\n\n--objdump=<path>::\n        Path to objdump binary.\n\n--prefix=PREFIX::\n--prefix-strip=N::\n        Remove first N entries from source file path names in executables\n        and add PREFIX. This allows to display source code compiled on systems\n        with different file system layout.\n\n--source::\n\tInterleave source code with assembly code. Enabled by default,\n\tdisable with --no-source.\n\n--asm-raw::\n\tShow raw instruction encoding of assembly instructions.\n\n-g::\n\tEnables call-graph (stack chain/backtrace) recording.\n\n--call-graph [mode,type,min[,limit],order[,key][,branch]]::\n\tSetup and enable call-graph (stack chain/backtrace) recording,\n\timplies -g.  See `--call-graph` section in perf-record and\n\tperf-report man pages for details.\n\n--children::\n\tAccumulate callchain of children to parent entry so that then can\n\tshow up in the output.  The output will have a new \"Children\" column\n\tand will be sorted on the data.  It requires -g/--call-graph option\n\tenabled.  See the `overhead calculation' section for more details.\n\tEnabled by default, disable with --no-children.\n\n--max-stack::\n\tSet the stack depth limit when parsing the callchain, anything\n\tbeyond the specified depth will be ignored. This is a trade-off\n\tbetween information loss and faster processing especially for\n\tworkloads that can have a very long callchain stack.\n\n\tDefault: /proc/sys/kernel/perf_event_max_stack when present, 127 otherwise.\n\n--ignore-callees=<regex>::\n        Ignore callees of the function(s) matching the given regex.\n        This has the effect of collecting the callers of each such\n        function into one place in the call-graph tree.\n\n--percent-limit::\n\tDo not show entries which have an overhead under that percent.\n\t(Default: 0).\n\n--percentage::\n\tDetermine how to display the overhead percentage of filtered entries.\n\tFilters can be applied by --comms, --dsos and/or --symbols options and\n\tZoom operations on the TUI (thread, dso, etc).\n\n\t\"relative\" means it's relative to filtered entries only so that the\n\tsum of shown entries will be always 100%. \"absolute\" means it retains\n\tthe original value before and after the filter is applied.\n\n-w::\n--column-widths=<width[,width...]>::\n\tForce each column width to the provided list, for large terminal\n\treadability.  0 means no limit (default behavior).\n\n--proc-map-timeout::\n\tWhen processing pre-existing threads /proc/XXX/mmap, it may take\n\ta long time, because the file may be huge. A time out is needed\n\tin such cases.\n\tThis option sets the time out limit. The default value is 500 ms.\n\n\n-b::\n--branch-any::\n\tEnable taken branch stack sampling. Any type of taken branch may be sampled.\n\tThis is a shortcut for --branch-filter any. See --branch-filter for more infos.\n\n-j::\n--branch-filter::\n\tEnable taken branch stack sampling. Each sample captures a series of consecutive\n\ttaken branches. The number of branches captured with each sample depends on the\n\tunderlying hardware, the type of branches of interest, and the executed code.\n\tIt is possible to select the types of branches captured by enabling filters.\n\tFor a full list of modifiers please see the perf record manpage.\n\n\tThe option requires at least one branch type among any, any_call, any_ret, ind_call, cond.\n\tThe privilege levels may be omitted, in which case, the privilege levels of the associated\n\tevent are applied to the branch filter. Both kernel (k) and hypervisor (hv) privilege\n\tlevels are subject to permissions.  When sampling on multiple events, branch stack sampling\n\tis enabled for all the sampling events. The sampled branch type is the same for all events.\n\tThe various filters must be specified as a comma separated list: --branch-filter any_ret,u,k\n\tNote that this feature may not be available on all processors.\n\n--branch-history::\n\tAdd the addresses of sampled taken branches to the callstack.\n\tThis allows to examine the path the program took to each sample.\n\n--raw-trace::\n\tWhen displaying traceevent output, do not use print fmt or plugins.\n\n--hierarchy::\n\tEnable hierarchy output.\n\n--overwrite::\n\tEnable this to use just the most recent records, which helps in high core count\n\tmachines such as Knights Landing/Mill, but right now is disabled by default as\n\tthe pausing used in this technique is leading to loss of metadata events such\n\tas PERF_RECORD_MMAP which makes 'perf top' unable to resolve samples, leading\n\tto lots of unknown samples appearing on the UI. Enable this if you are in such\n\tmachines and profiling a workload that doesn't creates short lived threads and/or\n\tdoesn't uses many executable mmap operations. Work is being planed to solve\n\tthis situation, till then, this will remain disabled by default.\n\n--force::\n\tDon't do ownership validation.\n\n--num-thread-synthesize::\n\tThe number of threads to run when synthesizing events for existing processes.\n\tBy default, the number of threads equals to the number of online CPUs.\n\n--namespaces::\n\tRecord events of type PERF_RECORD_NAMESPACES and display it with the\n\t'cgroup_id' sort key.\n\n-G name::\n--cgroup name::\nmonitor only in the container (cgroup) called \"name\". This option is available only\nin per-cpu mode. The cgroup filesystem must be mounted. All threads belonging to\ncontainer \"name\" are monitored when they run on the monitored CPUs. Multiple cgroups\ncan be provided. Each cgroup is applied to the corresponding event, i.e., first cgroup\nto first event, second cgroup to second event and so on. It is possible to provide\nan empty cgroup (monitor all the time) using, e.g., -G foo,,bar. Cgroups must have\ncorresponding events, i.e., they always refer to events defined earlier on the command\nline. If the user wants to track multiple events for a specific cgroup, the user can\nuse '-e e1 -e e2 -G foo,foo' or just use '-e e1 -e e2 -G foo'.\n\n--all-cgroups::\n\tRecord events of type PERF_RECORD_CGROUP and display it with the\n\t'cgroup' sort key.\n\n--switch-on EVENT_NAME::\n\tOnly consider events after this event is found.\n\n\tE.g.:\n\n           Find out where broadcast packets are handled\n\n\t\tperf probe -L icmp_rcv\n\n\t   Insert a probe there:\n\n\t\tperf probe icmp_rcv:59\n\n\t   Start perf top and ask it to only consider the cycles events when a\n           broadcast packet arrives This will show a menu with two entries and\n           will start counting when a broadcast packet arrives:\n\n\t\tperf top -e cycles,probe:icmp_rcv --switch-on=probe:icmp_rcv\n\n\t   Alternatively one can ask for a group and then two overhead columns\n           will appear, the first for cycles and the second for the switch-on event.\n\n\t\tperf top -e '{cycles,probe:icmp_rcv}' --switch-on=probe:icmp_rcv\n\n\tThis may be interesting to measure a workload only after some initialization\n\tphase is over, i.e. insert a perf probe at that point and use the above\n\texamples replacing probe:icmp_rcv with the just-after-init probe.\n\n--switch-off EVENT_NAME::\n\tStop considering events after this event is found.\n\n--show-on-off-events::\n\tShow the --switch-on/off events too. This has no effect in 'perf top' now\n\tbut probably we'll make the default not to show the switch-on/off events\n        on the --group mode and if there is only one event besides the off/on ones,\n\tgo straight to the histogram browser, just like 'perf top' with no events\n\texplicitly specified does.\n\n--stitch-lbr::\n\tShow callgraph with stitched LBRs, which may have more complete\n\tcallgraph. The option must be used with --call-graph lbr recording.\n\tDisabled by default. In common cases with call stack overflows,\n\tit can recreate better call stacks than the default lbr call stack\n\toutput. But this approach is not foolproof. There can be cases\n\twhere it creates incorrect call stacks from incorrect matches.\n\tThe known limitations include exception handing such as\n\tsetjmp/longjmp will have calls/returns not match.\n\nifdef::HAVE_LIBPFM[]\n--pfm-events events::\nSelect a PMU event using libpfm4 syntax (see http://perfmon2.sf.net)\nincluding support for event filters. For example '--pfm-events\ninst_retired:any_p:u:c=1:i'. More than one event can be passed to the\noption using the comma separator. Hardware events and generic hardware\nevents cannot be mixed together. The latter must be used with the -e\noption. The -e option and this one can be mixed and matched.  Events\ncan be grouped using the {} notation.\nendif::HAVE_LIBPFM[]\n\nINTERACTIVE PROMPTING KEYS\n--------------------------\n\n[d]::\n\tDisplay refresh delay.\n\n[e]::\n\tNumber of entries to display.\n\n[E]::\n\tEvent to display when multiple counters are active.\n\n[f]::\n\tProfile display filter (>= hit count).\n\n[F]::\n\tAnnotation display filter (>= % of total).\n\n[s]::\n\tAnnotate symbol.\n\n[S]::\n\tStop annotation, return to full profile display.\n\n[K]::\n\tHide kernel symbols.\n\n[U]::\n\tHide user symbols.\n\n[z]::\n\tToggle event count zeroing across display updates.\n\n[qQ]::\n\tQuit.\n\nPressing any unmapped key displays a menu, and prompts for input.\n\ninclude::callchain-overhead-calculation.txt[]\n\nSEE ALSO\n--------\nlinkperf:perf-stat[1], linkperf:perf-list[1], linkperf:perf-report[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}