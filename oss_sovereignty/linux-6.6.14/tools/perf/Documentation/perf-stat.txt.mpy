{
  "module_name": "perf-stat.txt",
  "hash_id": "fc98c5dee48f1806497c3c8c42daa768055a2c556aa4ebf87d939183bbea04ac",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-stat.txt",
  "human_readable_source": "perf-stat(1)\n============\n\nNAME\n----\nperf-stat - Run a command and gather performance counter statistics\n\nSYNOPSIS\n--------\n[verse]\n'perf stat' [-e <EVENT> | --event=EVENT] [-a] <command>\n'perf stat' [-e <EVENT> | --event=EVENT] [-a] \\-- <command> [<options>]\n'perf stat' [-e <EVENT> | --event=EVENT] [-a] record [-o file] \\-- <command> [<options>]\n'perf stat' report [-i file]\n\nDESCRIPTION\n-----------\nThis command runs a command and gathers performance counter statistics\nfrom it.\n\n\nOPTIONS\n-------\n<command>...::\n\tAny command you can specify in a shell.\n\nrecord::\n\tSee STAT RECORD.\n\nreport::\n\tSee STAT REPORT.\n\n-e::\n--event=::\n\tSelect the PMU event. Selection can be:\n\n\t- a symbolic event name (use 'perf list' to list all events)\n\n\t- a raw PMU event in the form of rN where N is a hexadecimal value\n\t  that represents the raw register encoding with the layout of the\n\t  event control registers as described by entries in\n\t  /sys/bus/event_source/devices/cpu/format/*.\n\n        - a symbolic or raw PMU event followed by an optional colon\n\t  and a list of event modifiers, e.g., cpu-cycles:p.  See the\n\t  linkperf:perf-list[1] man page for details on event modifiers.\n\n\t- a symbolically formed event like 'pmu/param1=0x3,param2/' where\n\t  param1 and param2 are defined as formats for the PMU in\n\t  /sys/bus/event_source/devices/<pmu>/format/*\n\n\t  'percore' is a event qualifier that sums up the event counts for both\n\t  hardware threads in a core. For example:\n\t  perf stat -A -a -e cpu/event,percore=1/,otherevent ...\n\n\t- a symbolically formed event like 'pmu/config=M,config1=N,config2=K/'\n\t  where M, N, K are numbers (in decimal, hex, octal format).\n\t  Acceptable values for each of 'config', 'config1' and 'config2'\n\t  parameters are defined by corresponding entries in\n\t  /sys/bus/event_source/devices/<pmu>/format/*\n\n\tNote that the last two syntaxes support prefix and glob matching in\n\tthe PMU name to simplify creation of events across multiple instances\n\tof the same type of PMU in large systems (e.g. memory controller PMUs).\n\tMultiple PMU instances are typical for uncore PMUs, so the prefix\n\t'uncore_' is also ignored when performing this match.\n\n\n-i::\n--no-inherit::\n        child tasks do not inherit counters\n-p::\n--pid=<pid>::\n        stat events on existing process id (comma separated list)\n\n-t::\n--tid=<tid>::\n        stat events on existing thread id (comma separated list)\n\n-b::\n--bpf-prog::\n        stat events on existing bpf program id (comma separated list),\n        requiring root rights. bpftool-prog could be used to find program\n        id all bpf programs in the system. For example:\n\n  # bpftool prog | head -n 1\n  17247: tracepoint  name sys_enter  tag 192d548b9d754067  gpl\n\n  # perf stat -e cycles,instructions --bpf-prog 17247 --timeout 1000\n\n   Performance counter stats for 'BPF program(s) 17247':\n\n             85,967      cycles\n             28,982      instructions              #    0.34  insn per cycle\n\n        1.102235068 seconds time elapsed\n\n--bpf-counters::\n\tUse BPF programs to aggregate readings from perf_events.  This\n\tallows multiple perf-stat sessions that are counting the same metric (cycles,\n\tinstructions, etc.) to share hardware counters.\n\tTo use BPF programs on common events by default, use\n\t\"perf config stat.bpf-counter-events=<list_of_events>\".\n\n--bpf-attr-map::\n\tWith option \"--bpf-counters\", different perf-stat sessions share\n\tinformation about shared BPF programs and maps via a pinned hashmap.\n\tUse \"--bpf-attr-map\" to specify the path of this pinned hashmap.\n\tThe default path is /sys/fs/bpf/perf_attr_map.\n\nifdef::HAVE_LIBPFM[]\n--pfm-events events::\nSelect a PMU event using libpfm4 syntax (see http://perfmon2.sf.net)\nincluding support for event filters. For example '--pfm-events\ninst_retired:any_p:u:c=1:i'. More than one event can be passed to the\noption using the comma separator. Hardware events and generic hardware\nevents cannot be mixed together. The latter must be used with the -e\noption. The -e option and this one can be mixed and matched.  Events\ncan be grouped using the {} notation.\nendif::HAVE_LIBPFM[]\n\n-a::\n--all-cpus::\n        system-wide collection from all CPUs (default if no target is specified)\n\n--no-scale::\n\tDon't scale/normalize counter values\n\n-d::\n--detailed::\n\tprint more detailed statistics, can be specified up to 3 times\n\n\t   -d:          detailed events, L1 and LLC data cache\n        -d -d:     more detailed events, dTLB and iTLB events\n     -d -d -d:     very detailed events, adding prefetch events\n\n-r::\n--repeat=<n>::\n\trepeat command and print average + stddev (max: 100). 0 means forever.\n\n-B::\n--big-num::\n        print large numbers with thousands' separators according to locale.\n\tEnabled by default. Use \"--no-big-num\" to disable.\n\tDefault setting can be changed with \"perf config stat.big-num=false\".\n\n-C::\n--cpu=::\nCount only on the list of CPUs provided. Multiple CPUs can be provided as a\ncomma-separated list with no space: 0,1. Ranges of CPUs are specified with -: 0-2.\nIn per-thread mode, this option is ignored. The -a option is still necessary\nto activate system-wide monitoring. Default is to count on all CPUs.\n\n-A::\n--no-aggr::\nDo not aggregate counts across all monitored CPUs.\n\n-n::\n--null::\nnull run - Don't start any counters.\n\nThis can be useful to measure just elapsed wall-clock time - or to assess the\nraw overhead of perf stat itself, without running any counters.\n\n-v::\n--verbose::\n        be more verbose (show counter open errors, etc)\n\n-x SEP::\n--field-separator SEP::\nprint counts using a CSV-style output to make it easy to import directly into\nspreadsheets. Columns are separated by the string specified in SEP.\n\n--table:: Display time for each run (-r option), in a table format, e.g.:\n\n  $ perf stat --null -r 5 --table perf bench sched pipe\n\n   Performance counter stats for 'perf bench sched pipe' (5 runs):\n\n             # Table of individual measurements:\n             5.189 (-0.293) #\n             5.189 (-0.294) #\n             5.186 (-0.296) #\n             5.663 (+0.181) ##\n             6.186 (+0.703) ####\n\n             # Final result:\n             5.483 +- 0.198 seconds time elapsed  ( +-  3.62% )\n\n-G name::\n--cgroup name::\nmonitor only in the container (cgroup) called \"name\". This option is available only\nin per-cpu mode. The cgroup filesystem must be mounted. All threads belonging to\ncontainer \"name\" are monitored when they run on the monitored CPUs. Multiple cgroups\ncan be provided. Each cgroup is applied to the corresponding event, i.e., first cgroup\nto first event, second cgroup to second event and so on. It is possible to provide\nan empty cgroup (monitor all the time) using, e.g., -G foo,,bar. Cgroups must have\ncorresponding events, i.e., they always refer to events defined earlier on the command\nline. If the user wants to track multiple events for a specific cgroup, the user can\nuse '-e e1 -e e2 -G foo,foo' or just use '-e e1 -e e2 -G foo'.\n\nIf wanting to monitor, say, 'cycles' for a cgroup and also for system wide, this\ncommand line can be used: 'perf stat -e cycles -G cgroup_name -a -e cycles'.\n\n--for-each-cgroup name::\nExpand event list for each cgroup in \"name\" (allow multiple cgroups separated\nby comma).  It also support regex patterns to match multiple groups.  This has same\neffect that repeating -e option and -G option for each event x name.  This option\ncannot be used with -G/--cgroup option.\n\n-o file::\n--output file::\nPrint the output into the designated file.\n\n--append::\nAppend to the output file designated with the -o option. Ignored if -o is not specified.\n\n--log-fd::\n\nLog output to fd, instead of stderr.  Complementary to --output, and mutually exclusive\nwith it.  --append may be used here.  Examples:\n     3>results  perf stat --log-fd 3          \\-- $cmd\n     3>>results perf stat --log-fd 3 --append \\-- $cmd\n\n--control=fifo:ctl-fifo[,ack-fifo]::\n--control=fd:ctl-fd[,ack-fd]::\nctl-fifo / ack-fifo are opened and used as ctl-fd / ack-fd as follows.\nListen on ctl-fd descriptor for command to control measurement ('enable': enable events,\n'disable': disable events). Measurements can be started with events disabled using\n--delay=-1 option. Optionally send control command completion ('ack\\n') to ack-fd descriptor\nto synchronize with the controlling process. Example of bash shell script to enable and\ndisable events during measurements:\n\n #!/bin/bash\n\n ctl_dir=/tmp/\n\n ctl_fifo=${ctl_dir}perf_ctl.fifo\n test -p ${ctl_fifo} && unlink ${ctl_fifo}\n mkfifo ${ctl_fifo}\n exec {ctl_fd}<>${ctl_fifo}\n\n ctl_ack_fifo=${ctl_dir}perf_ctl_ack.fifo\n test -p ${ctl_ack_fifo} && unlink ${ctl_ack_fifo}\n mkfifo ${ctl_ack_fifo}\n exec {ctl_fd_ack}<>${ctl_ack_fifo}\n\n perf stat -D -1 -e cpu-cycles -a -I 1000       \\\n           --control fd:${ctl_fd},${ctl_fd_ack} \\\n           \\-- sleep 30 &\n perf_pid=$!\n\n sleep 5  && echo 'enable' >&${ctl_fd} && read -u ${ctl_fd_ack} e1 && echo \"enabled(${e1})\"\n sleep 10 && echo 'disable' >&${ctl_fd} && read -u ${ctl_fd_ack} d1 && echo \"disabled(${d1})\"\n\n exec {ctl_fd_ack}>&-\n unlink ${ctl_ack_fifo}\n\n exec {ctl_fd}>&-\n unlink ${ctl_fifo}\n\n wait -n ${perf_pid}\n exit $?\n\n\n--pre::\n--post::\n\tPre and post measurement hooks, e.g.:\n\nperf stat --repeat 10 --null --sync --pre 'make -s O=defconfig-build/clean' \\-- make -s -j64 O=defconfig-build/ bzImage\n\n-I msecs::\n--interval-print msecs::\nPrint count deltas every N milliseconds (minimum: 1ms)\nThe overhead percentage could be high in some cases, for instance with small, sub 100ms intervals.  Use with caution.\n\texample: 'perf stat -I 1000 -e cycles -a sleep 5'\n\nIf the metric exists, it is calculated by the counts generated in this interval and the metric is printed after #.\n\n--interval-count times::\nPrint count deltas for fixed number of times.\nThis option should be used together with \"-I\" option.\n\texample: 'perf stat -I 1000 --interval-count 2 -e cycles -a'\n\n--interval-clear::\nClear the screen before next interval.\n\n--timeout msecs::\nStop the 'perf stat' session and print count deltas after N milliseconds (minimum: 10 ms).\nThis option is not supported with the \"-I\" option.\n\texample: 'perf stat --time 2000 -e cycles -a'\n\n--metric-only::\nOnly print computed metrics. Print them in a single line.\nDon't show any raw values. Not supported with --per-thread.\n\n--per-socket::\nAggregate counts per processor socket for system-wide mode measurements.  This\nis a useful mode to detect imbalance between sockets.  To enable this mode,\nuse --per-socket in addition to -a. (system-wide).  The output includes the\nsocket number and the number of online processors on that socket. This is\nuseful to gauge the amount of aggregation.\n\n--per-die::\nAggregate counts per processor die for system-wide mode measurements.  This\nis a useful mode to detect imbalance between dies.  To enable this mode,\nuse --per-die in addition to -a. (system-wide).  The output includes the\ndie number and the number of online processors on that die. This is\nuseful to gauge the amount of aggregation.\n\n--per-cache::\nAggregate counts per cache instance for system-wide mode measurements.  By\ndefault, the aggregation happens for the cache level at the highest index\nin the system. To specify a particular level, mention the cache level\nalongside the option in the format [Ll][1-9][0-9]*. For example:\nUsing option \"--per-cache=l3\" or \"--per-cache=L3\" will aggregate the\ninformation at the boundary of the level 3 cache in the system.\n\n--per-core::\nAggregate counts per physical processor for system-wide mode measurements.  This\nis a useful mode to detect imbalance between physical cores.  To enable this mode,\nuse --per-core in addition to -a. (system-wide).  The output includes the\ncore number and the number of online logical processors on that physical processor.\n\n--per-thread::\nAggregate counts per monitored threads, when monitoring threads (-t option)\nor processes (-p option).\n\n--per-node::\nAggregate counts per NUMA nodes for system-wide mode measurements. This\nis a useful mode to detect imbalance between NUMA nodes. To enable this\nmode, use --per-node in addition to -a. (system-wide).\n\n-D msecs::\n--delay msecs::\nAfter starting the program, wait msecs before measuring (-1: start with events\ndisabled). This is useful to filter out the startup phase of the program,\nwhich is often very different.\n\n-T::\n--transaction::\n\nPrint statistics of transactional execution if supported.\n\n--metric-no-group::\nBy default, events to compute a metric are placed in weak groups. The\ngroup tries to enforce scheduling all or none of the events. The\n--metric-no-group option places events outside of groups and may\nincrease the chance of the event being scheduled - leading to more\naccuracy. However, as events may not be scheduled together accuracy\nfor metrics like instructions per cycle can be lower - as both metrics\nmay no longer be being measured at the same time.\n\n--metric-no-merge::\nBy default metric events in different weak groups can be shared if one\ngroup contains all the events needed by another. In such cases one\ngroup will be eliminated reducing event multiplexing and making it so\nthat certain groups of metrics sum to 100%. A downside to sharing a\ngroup is that the group may require multiplexing and so accuracy for a\nsmall group that need not have multiplexing is lowered. This option\nforbids the event merging logic from sharing events between groups and\nmay be used to increase accuracy in this case.\n\n--metric-no-threshold::\nMetric thresholds may increase the number of events necessary to\ncompute whether a metric has exceeded its threshold expression. This\nmay not be desirable, for example, as the events can introduce\nmultiplexing. This option disables the adding of threshold expression\nevents for a metric. However, if there are sufficient events to\ncompute the threshold then the threshold is still computed and used to\ncolor the metric's computed value.\n\n--quiet::\nDon't print output, warnings or messages. This is useful with perf stat\nrecord below to only write data to the perf.data file.\n\nSTAT RECORD\n-----------\nStores stat data into perf data file.\n\n-o file::\n--output file::\nOutput file name.\n\nSTAT REPORT\n-----------\nReads and reports stat data from perf data file.\n\n-i file::\n--input file::\nInput file name.\n\n--per-socket::\nAggregate counts per processor socket for system-wide mode measurements.\n\n--per-die::\nAggregate counts per processor die for system-wide mode measurements.\n\n--per-cache::\nAggregate counts per cache instance for system-wide mode measurements.  By\ndefault, the aggregation happens for the cache level at the highest index\nin the system. To specify a particular level, mention the cache level\nalongside the option in the format [Ll][1-9][0-9]*. For example: Using\noption \"--per-cache=l3\" or \"--per-cache=L3\" will aggregate the\ninformation at the boundary of the level 3 cache in the system.\n\n--per-core::\nAggregate counts per physical processor for system-wide mode measurements.\n\n-M::\n--metrics::\nPrint metrics or metricgroups specified in a comma separated list.\nFor a group all metrics from the group are added.\nThe events from the metrics are automatically measured.\nSee perf list output for the possible metrics and metricgroups.\n\n\tWhen threshold information is available for a metric, the\n\tcolor red is used to signify a metric has exceeded a threshold\n\twhile green shows it hasn't. The default color means that\n\tno threshold information was available or the threshold\n\tcouldn't be computed.\n\n-A::\n--no-aggr::\nDo not aggregate counts across all monitored CPUs.\n\n--topdown::\nPrint top-down metrics supported by the CPU. This allows to determine\nbottle necks in the CPU pipeline for CPU bound workloads, by breaking\nthe cycles consumed down into frontend bound, backend bound, bad\nspeculation and retiring.\n\nFrontend bound means that the CPU cannot fetch and decode instructions fast\nenough. Backend bound means that computation or memory access is the bottle\nneck. Bad Speculation means that the CPU wasted cycles due to branch\nmispredictions and similar issues. Retiring means that the CPU computed without\nan apparently bottleneck. The bottleneck is only the real bottleneck\nif the workload is actually bound by the CPU and not by something else.\n\nFor best results it is usually a good idea to use it with interval\nmode like -I 1000, as the bottleneck of workloads can change often.\n\nThis enables --metric-only, unless overridden with --no-metric-only.\n\nThe following restrictions only apply to older Intel CPUs and Atom,\non newer CPUs (IceLake and later) TopDown can be collected for any thread:\n\nThe top down metrics are collected per core instead of per\nCPU thread. Per core mode is automatically enabled\nand -a (global monitoring) is needed, requiring root rights or\nperf.perf_event_paranoid=-1.\n\nTopdown uses the full Performance Monitoring Unit, and needs\ndisabling of the NMI watchdog (as root):\necho 0 > /proc/sys/kernel/nmi_watchdog\nfor best results. Otherwise the bottlenecks may be inconsistent\non workload with changing phases.\n\nTo interpret the results it is usually needed to know on which\nCPUs the workload runs on. If needed the CPUs can be forced using\ntaskset.\n\n--td-level::\nPrint the top-down statistics that equal the input level. It allows\nusers to print the interested top-down metrics level instead of the\nlevel 1 top-down metrics.\n\nAs the higher levels gather more metrics and use more counters they\nwill be less accurate. By convention a metric can be examined by\nappending '_group' to it and this will increase accuracy compared to\ngathering all metrics for a level. For example, level 1 analysis may\nhighlight 'tma_frontend_bound'. This metric may be drilled into with\n'tma_frontend_bound_group' with\n'perf stat -M tma_frontend_bound_group...'.\n\nError out if the input is higher than the supported max level.\n\n--no-merge::\nDo not merge results from same PMUs.\n\nWhen multiple events are created from a single event specification,\nstat will, by default, aggregate the event counts and show the result\nin a single row. This option disables that behavior and shows\nthe individual events and counts.\n\nMultiple events are created from a single event specification when:\n1. Prefix or glob matching is used for the PMU name.\n2. Aliases, which are listed immediately after the Kernel PMU events\n   by perf list, are used.\n\n--hybrid-merge::\nMerge the hybrid event counts from all PMUs.\n\nFor hybrid events, by default, the stat aggregates and reports the event\ncounts per PMU. But sometimes, it's also useful to aggregate event counts\nfrom all PMUs. This option enables that behavior and reports the counts\nwithout PMUs.\n\nFor non-hybrid events, it should be no effect.\n\n--smi-cost::\nMeasure SMI cost if msr/aperf/ and msr/smi/ events are supported.\n\nDuring the measurement, the /sys/device/cpu/freeze_on_smi will be set to\nfreeze core counters on SMI.\nThe aperf counter will not be effected by the setting.\nThe cost of SMI can be measured by (aperf - unhalted core cycles).\n\nIn practice, the percentages of SMI cycles is very useful for performance\noriented analysis. --metric_only will be applied by default.\nThe output is SMI cycles%, equals to (aperf - unhalted core cycles) / aperf\n\nUsers who wants to get the actual value can apply --no-metric-only.\n\n--all-kernel::\nConfigure all used events to run in kernel space.\n\n--all-user::\nConfigure all used events to run in user space.\n\n--percore-show-thread::\nThe event modifier \"percore\" has supported to sum up the event counts\nfor all hardware threads in a core and show the counts per core.\n\nThis option with event modifier \"percore\" enabled also sums up the event\ncounts for all hardware threads in a core but show the sum counts per\nhardware thread. This is essentially a replacement for the any bit and\nconvenient for post processing.\n\n--summary::\nPrint summary for interval mode (-I).\n\n--no-csv-summary::\nDon't print 'summary' at the first column for CVS summary output.\nThis option must be used with -x and --summary.\n\nThis option can be enabled in perf config by setting the variable\n'stat.no-csv-summary'.\n\n$ perf config stat.no-csv-summary=true\n\n--cputype::\nOnly enable events on applying cpu with this type for hybrid platform\n(e.g. core or atom)\"\n\nEXAMPLES\n--------\n\n$ perf stat \\-- make\n\n   Performance counter stats for 'make':\n\n        83723.452481      task-clock:u (msec)       #    1.004 CPUs utilized\n                   0      context-switches:u        #    0.000 K/sec\n                   0      cpu-migrations:u          #    0.000 K/sec\n           3,228,188      page-faults:u             #    0.039 M/sec\n     229,570,665,834      cycles:u                  #    2.742 GHz\n     313,163,853,778      instructions:u            #    1.36  insn per cycle\n      69,704,684,856      branches:u                #  832.559 M/sec\n       2,078,861,393      branch-misses:u           #    2.98% of all branches\n\n        83.409183620 seconds time elapsed\n\n        74.684747000 seconds user\n         8.739217000 seconds sys\n\nTIMINGS\n-------\nAs displayed in the example above we can display 3 types of timings.\nWe always display the time the counters were enabled/alive:\n\n        83.409183620 seconds time elapsed\n\nFor workload sessions we also display time the workloads spent in\nuser/system lands:\n\n        74.684747000 seconds user\n         8.739217000 seconds sys\n\nThose times are the very same as displayed by the 'time' tool.\n\nCSV FORMAT\n----------\n\nWith -x, perf stat is able to output a not-quite-CSV format output\nCommas in the output are not put into \"\". To make it easy to parse\nit is recommended to use a different character like -x \\;\n\nThe fields are in this order:\n\n\t- optional usec time stamp in fractions of second (with -I xxx)\n\t- optional CPU, core, or socket identifier\n\t- optional number of logical CPUs aggregated\n\t- counter value\n\t- unit of the counter value or empty\n\t- event name\n\t- run time of counter\n\t- percentage of measurement time the counter was running\n\t- optional variance if multiple values are collected with -r\n\t- optional metric value\n\t- optional unit of metric\n\nAdditional metrics may be printed with all earlier fields being empty.\n\ninclude::intel-hybrid.txt[]\n\nJSON FORMAT\n-----------\n\nWith -j, perf stat is able to print out a JSON format output\nthat can be used for parsing.\n\n- timestamp : optional usec time stamp in fractions of second (with -I)\n- optional aggregate options:\n\t\t- core : core identifier (with --per-core)\n\t\t- die : die identifier (with --per-die)\n\t\t- socket : socket identifier (with --per-socket)\n\t\t- node : node identifier (with --per-node)\n\t\t- thread : thread identifier (with --per-thread)\n- counter-value : counter value\n- unit : unit of the counter value or empty\n- event : event name\n- variance : optional variance if multiple values are collected (with -r)\n- runtime : run time of counter\n- metric-value : optional metric value\n- metric-unit : optional unit of metric\n\nSEE ALSO\n--------\nlinkperf:perf-top[1], linkperf:perf-list[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}