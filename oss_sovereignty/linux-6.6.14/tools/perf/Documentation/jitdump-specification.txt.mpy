{
  "module_name": "jitdump-specification.txt",
  "hash_id": "476fbe21b1ac0c984a3bd277649160d81e78c10b2d57c4a8f796ad3ffae9a4f0",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/jitdump-specification.txt",
  "human_readable_source": "JITDUMP specification version 2\nLast Revised: 09/15/2016\nAuthor: Stephane Eranian <eranian@gmail.com>\n\n--------------------------------------------------------\n| Revision  |    Date    | Description                 |\n--------------------------------------------------------\n|   1       | 09/07/2016 | Initial revision            |\n--------------------------------------------------------\n|   2       | 09/15/2016 | Add JIT_CODE_UNWINDING_INFO |\n--------------------------------------------------------\n\n\nI/ Introduction\n\n\nThis document describes the jitdump file format. The file is generated by Just-In-time compiler runtimes to save meta-data information about the generated code, such as address, size, and name of generated functions, the native code generated, the source line information. The data may then be used by performance tools, such as Linux perf to generate function and assembly level profiles.\n\nThe format is not specific to any particular programming language. It can be extended as need be.\n\nThe format of the file is binary. It is self-describing in terms of endianness and is portable across multiple processor architectures.\n\n\nII/ Overview of the format\n\n\nThe format requires only sequential accesses, i.e., append only mode. The file starts with a fixed size file header describing the version of the specification, the endianness.\n\nThe header is followed by a series of records, each starting with a fixed size header describing the type of record and its size. It is, itself, followed by the payload for the record. Records can have a variable size even for a given type.\n\nEach entry in the file is timestamped. All timestamps must use the same clock source. The CLOCK_MONOTONIC clock source is recommended.\n\n\nIII/ Jitdump file header format\n\nEach jitdump file starts with a fixed size header containing the following fields in order:\n\n\n* uint32_t magic     : a magic number tagging the file type. The value is 4-byte long and represents the string \"JiTD\" in ASCII form. It written is as 0x4A695444. The reader will detect an endian mismatch when it reads 0x4454694a.\n* uint32_t version   : a 4-byte value representing the format version. It is currently set to 1\n* uint32_t total_size: size in bytes of file header\n* uint32_t elf_mach  : ELF architecture encoding (ELF e_machine value as specified in /usr/include/elf.h)\n* uint32_t pad1      : padding. Reserved for future use\n* uint32_t pid       : JIT runtime process identification (OS specific)\n* uint64_t timestamp : timestamp of when the file was created\n* uint64_t flags     : a bitmask of flags\n\nThe flags currently defined are as follows:\n * bit 0: JITDUMP_FLAGS_ARCH_TIMESTAMP : set if the jitdump file is using an architecture-specific timestamp clock source. For instance, on x86, one could use TSC directly\n\nIV/ Record header\n\nThe file header is immediately followed by records. Each record starts with a fixed size header describing the record that follows.\n\nThe record header is specified in order as follows:\n* uint32_t id        : a value identifying the record type (see below)\n* uint32_t total_size: the size in bytes of the record including the header.\n* uint64_t timestamp : a timestamp of when the record was created.\n\nThe following record types are defined:\n * Value 0 : JIT_CODE_LOAD      : record describing a jitted function\n * Value 1 : JIT_CODE_MOVE      : record describing an already jitted function which is moved\n * Value 2 : JIT_CODE_DEBUG_INFO: record describing the debug information for a jitted function\n * Value 3 : JIT_CODE_CLOSE     : record marking the end of the jit runtime (optional)\n * Value 4 : JIT_CODE_UNWINDING_INFO: record describing a function unwinding information\n\n The payload of the record must immediately follow the record header without padding.\n\nV/ JIT_CODE_LOAD record\n\n\n  The record has the following fields following the fixed-size record header in order:\n  * uint32_t pid: OS process id of the runtime generating the jitted code\n  * uint32_t tid: OS thread identification of the runtime thread generating the jitted code\n  * uint64_t vma: virtual address of jitted code start\n  * uint64_t code_addr: code start address for the jitted code. By default vma = code_addr\n  * uint64_t code_size: size in bytes of the generated jitted code\n  * uint64_t code_index: unique identifier for the jitted code (see below)\n  * char[n]: function name in ASCII including the null termination\n  * native code: raw byte encoding of the jitted code\n\n  The record header total_size field is inclusive of all components:\n  * record header\n  * fixed-sized fields\n  * function name string, including termination\n  * native code length\n  * record specific variable data (e.g., array of data entries)\n\nThe code_index is used to uniquely identify each jitted function. The index can be a monotonically increasing 64-bit value. Each time a function is jitted it gets a new number. This value is used in case the code for a function is moved and avoids having to issue another JIT_CODE_LOAD record.\n\nThe format supports empty functions with no native code.\n\n\nVI/ JIT_CODE_MOVE record\n\n  The record type is optional.\n\n  The record has the following fields following the fixed-size record header in order:\n  * uint32_t pid          : OS process id of the runtime generating the jitted code\n  * uint32_t tid          : OS thread identification of the runtime thread generating the jitted code\n  * uint64_t vma          : new virtual address of jitted code start\n  * uint64_t old_code_addr: previous code address for the same function\n  * uint64_t new_code_addr: alternate new code started address for the jitted code. By default it should be equal to the vma address.\n  * uint64_t code_size    : size in bytes of the jitted code\n  * uint64_t code_index   : index referring to the JIT_CODE_LOAD code_index record of when the function was initially jitted\n\n\nThe MOVE record can be used in case an already jitted function is simply moved by the runtime inside the code cache.\n\nThe JIT_CODE_MOVE record cannot come before the JIT_CODE_LOAD record for the same function name. The function cannot have changed name, otherwise a new JIT_CODE_LOAD record must be emitted.\n\nThe code size of the function cannot change.\n\n\nVII/ JIT_DEBUG_INFO record\n\nThe record type is optional.\n\nThe record contains source lines debug information, i.e., a way to map a code address back to a source line. This information may be used by the performance tool.\n\nThe record has the following fields following the fixed-size record header in order:\n  * uint64_t code_addr: address of function for which the debug information is generated\n  * uint64_t nr_entry : number of debug entries for the function\n  * debug_entry[n]: array of nr_entry debug entries for the function\n\nThe debug_entry describes the source line information. It is defined as follows in order:\n* uint64_t code_addr: address of function for which the debug information is generated\n* uint32_t line     : source file line number (starting at 1)\n* uint32_t discrim  : column discriminator, 0 is default\n* char name[n]      : source file name in ASCII, including null termination\n\nThe debug_entry entries are saved in sequence but given that they have variable sizes due to the file name string, they cannot be indexed directly.\nThey need to be walked sequentially. The next debug_entry is found at sizeof(debug_entry) + strlen(name) + 1.\n\nIMPORTANT:\n  The JIT_CODE_DEBUG for a given function must always be generated BEFORE the JIT_CODE_LOAD for the function. This facilitates greatly the parser for the jitdump file.\n\n\nVIII/ JIT_CODE_CLOSE record\n\n\nThe record type is optional.\n\nThe record is used as a marker for the end of the jitted runtime. It can be replaced by the end of the file.\n\nThe JIT_CODE_CLOSE record does not have any specific fields, the record header contains all the information needed.\n\n\nIX/ JIT_CODE_UNWINDING_INFO\n\n\nThe record type is optional.\n\nThe record is used to describe the unwinding information for a jitted function.\n\nThe record has the following fields following the fixed-size record header in order:\n\nuint64_t unwind_data_size   : the size in bytes of the unwinding data table at the end of the record\nuint64_t eh_frame_hdr_size  : the size in bytes of the DWARF EH Frame Header at the start of the unwinding data table at the end of the record\nuint64_t mapped_size        : the size of the unwinding data mapped in memory\nconst char unwinding_data[n]: an array of unwinding data, consisting of the EH Frame Header, followed by the actual EH Frame\n\n\nThe EH Frame header follows the Linux Standard Base (LSB) specification as described in the document at https://refspecs.linuxfoundation.org/LSB_1.3.0/gLSB/gLSB/ehframehdr.html\n\n\nThe EH Frame follows the LSB specification as described in the document at https://refspecs.linuxbase.org/LSB_3.0.0/LSB-PDA/LSB-PDA/ehframechpt.html\n\n\nNOTE: The mapped_size is generally either the same as unwind_data_size (if the unwinding data was mapped in memory by the running process) or zero (if the unwinding data is not mapped by the process). If the unwinding data was not mapped, then only the EH Frame Header will be read, which can be used to specify FP based unwinding for a function which does not have unwinding information.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}