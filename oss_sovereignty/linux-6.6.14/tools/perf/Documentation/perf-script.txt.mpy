{
  "module_name": "perf-script.txt",
  "hash_id": "f4a86a12ad2390ac1a00bcc0c1c700c1244b2755f3c409638cecfedf262973c3",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-script.txt",
  "human_readable_source": "perf-script(1)\n=============\n\nNAME\n----\nperf-script - Read perf.data (created by perf record) and display trace output\n\nSYNOPSIS\n--------\n[verse]\n'perf script' [<options>]\n'perf script' [<options>] record <script> [<record-options>] <command>\n'perf script' [<options>] report <script> [script-args]\n'perf script' [<options>] <script> <required-script-args> [<record-options>] <command>\n'perf script' [<options>] <top-script> [script-args]\n\nDESCRIPTION\n-----------\nThis command reads the input file and displays the trace recorded.\n\nThere are several variants of perf script:\n\n  'perf script' to see a detailed trace of the workload that was\n  recorded.\n\n  You can also run a set of pre-canned scripts that aggregate and\n  summarize the raw trace data in various ways (the list of scripts is\n  available via 'perf script -l').  The following variants allow you to\n  record and run those scripts:\n\n  'perf script record <script> <command>' to record the events required\n  for 'perf script report'.  <script> is the name displayed in the\n  output of 'perf script --list' i.e. the actual script name minus any\n  language extension.  If <command> is not specified, the events are\n  recorded using the -a (system-wide) 'perf record' option.\n\n  'perf script report <script> [args]' to run and display the results\n  of <script>.  <script> is the name displayed in the output of 'perf\n  script --list' i.e. the actual script name minus any language\n  extension.  The perf.data output from a previous run of 'perf script\n  record <script>' is used and should be present for this command to\n  succeed.  [args] refers to the (mainly optional) args expected by\n  the script.\n\n  'perf script <script> <required-script-args> <command>' to both\n  record the events required for <script> and to run the <script>\n  using 'live-mode' i.e. without writing anything to disk.  <script>\n  is the name displayed in the output of 'perf script --list' i.e. the\n  actual script name minus any language extension.  If <command> is\n  not specified, the events are recorded using the -a (system-wide)\n  'perf record' option.  If <script> has any required args, they\n  should be specified before <command>.  This mode doesn't allow for\n  optional script args to be specified; if optional script args are\n  desired, they can be specified using separate 'perf script record'\n  and 'perf script report' commands, with the stdout of the record step\n  piped to the stdin of the report script, using the '-o -' and '-i -'\n  options of the corresponding commands.\n\n  'perf script <top-script>' to both record the events required for\n  <top-script> and to run the <top-script> using 'live-mode'\n  i.e. without writing anything to disk.  <top-script> is the name\n  displayed in the output of 'perf script --list' i.e. the actual\n  script name minus any language extension; a <top-script> is defined\n  as any script name ending with the string 'top'.\n\n  [<record-options>] can be passed to the record steps of 'perf script\n  record' and 'live-mode' variants; this isn't possible however for\n  <top-script> 'live-mode' or 'perf script report' variants.\n\n  See the 'SEE ALSO' section for links to language-specific\n  information on how to write and run your own trace scripts.\n\nOPTIONS\n-------\n<command>...::\n\tAny command you can specify in a shell.\n\n-D::\n--dump-raw-trace=::\n        Display verbose dump of the trace data.\n\n--dump-unsorted-raw-trace=::\n        Same as --dump-raw-trace but not sorted in time order.\n\n-L::\n--Latency=::\n        Show latency attributes (irqs/preemption disabled, etc).\n\n-l::\n--list=::\n        Display a list of available trace scripts.\n\n-s ['lang']::\n--script=::\n        Process trace data with the given script ([lang]:script[.ext]).\n\tIf the string 'lang' is specified in place of a script name, a\n        list of supported languages will be displayed instead.\n\n-g::\n--gen-script=::\n        Generate perf-script.[ext] starter script for given language,\n        using current perf.data.\n\n--dlfilter=<file>::\n\tFilter sample events using the given shared object file.\n\tRefer linkperf:perf-dlfilter[1]\n\n--dlarg=<arg>::\n\tPass 'arg' as an argument to the dlfilter. --dlarg may be repeated\n\tto add more arguments.\n\n--list-dlfilters::\n        Display a list of available dlfilters. Use with option -v (must come\n        before option --list-dlfilters) to show long descriptions.\n\n-a::\n        Force system-wide collection.  Scripts run without a <command>\n        normally use -a by default, while scripts run with a <command>\n        normally don't - this option allows the latter to be run in\n        system-wide mode.\n\n-i::\n--input=::\n        Input file name. (default: perf.data unless stdin is a fifo)\n\n-d::\n--debug-mode::\n        Do various checks like samples ordering and lost events.\n\n-F::\n--fields::\n        Comma separated list of fields to print. Options are:\n        comm, tid, pid, time, cpu, event, trace, ip, sym, dso, dsoff, addr, symoff,\n        srcline, period, iregs, uregs, brstack, brstacksym, flags, bpf-output,\n        brstackinsn, brstackinsnlen, brstackoff, callindent, insn, insnlen, synth,\n        phys_addr, metric, misc, srccode, ipc, data_page_size, code_page_size, ins_lat,\n        machine_pid, vcpu, cgroup, retire_lat.\n        Field list can be prepended with the type, trace, sw or hw,\n        to indicate to which event type the field list applies.\n        e.g., -F sw:comm,tid,time,ip,sym  and -F trace:time,cpu,trace\n\n\t\tperf script -F <fields>\n\n\tis equivalent to:\n\n\t\tperf script -F trace:<fields> -F sw:<fields> -F hw:<fields>\n\n\ti.e., the specified fields apply to all event types if the type string\n\tis not given.\n\n\tIn addition to overriding fields, it is also possible to add or remove\n\tfields from the defaults. For example\n\n\t\t-F -cpu,+insn\n\n\tremoves the cpu field and adds the insn field. Adding/removing fields\n\tcannot be mixed with normal overriding.\n\n\tThe arguments are processed in the order received. A later usage can\n\treset a prior request. e.g.:\n\n\t\t-F trace: -F comm,tid,time,ip,sym\n\n\tThe first -F suppresses trace events (field list is \"\"), but then the\n\tsecond invocation sets the fields to comm,tid,time,ip,sym. In this case a\n\twarning is given to the user:\n\n\t\t\"Overriding previous field request for all events.\"\n\n\tAlternatively, consider the order:\n\n\t\t-F comm,tid,time,ip,sym -F trace:\n\n\tThe first -F sets the fields for all events and the second -F\n\tsuppresses trace events. The user is given a warning message about\n\tthe override, and the result of the above is that only S/W and H/W\n\tevents are displayed with the given fields.\n\n\tIt's possible tp add/remove fields only for specific event type:\n\n\t\t-Fsw:-cpu,-period\n\n\tremoves cpu and period from software events.\n\n\tFor the 'wildcard' option if a user selected field is invalid for an\n\tevent type, a message is displayed to the user that the option is\n\tignored for that type. For example:\n\n\t\t$ perf script -F comm,tid,trace\n\t\t'trace' not valid for hardware events. Ignoring.\n\t\t'trace' not valid for software events. Ignoring.\n\n\tAlternatively, if the type is given an invalid field is specified it\n\tis an error. For example:\n\n        perf script -v -F sw:comm,tid,trace\n        'trace' not valid for software events.\n\n\tAt this point usage is displayed, and perf-script exits.\n\n\tThe flags field is synthesized and may have a value when Instruction\n\tTrace decoding. The flags are \"bcrosyiABExghDt\" which stand for branch,\n\tcall, return, conditional, system, asynchronous, interrupt,\n\ttransaction abort, trace begin, trace end, in transaction, VM-Entry,\n\tVM-Exit, interrupt disabled and interrupt disable toggle respectively.\n\tKnown combinations of flags are printed more nicely e.g.\n\t\"call\" for \"bc\", \"return\" for \"br\", \"jcc\" for \"bo\", \"jmp\" for \"b\",\n\t\"int\" for \"bci\", \"iret\" for \"bri\", \"syscall\" for \"bcs\", \"sysret\" for \"brs\",\n\t\"async\" for \"by\", \"hw int\" for \"bcyi\", \"tx abrt\" for \"bA\", \"tr strt\" for \"bB\",\n\t\"tr end\" for \"bE\", \"vmentry\" for \"bcg\", \"vmexit\" for \"bch\".\n\tHowever the \"x\", \"D\" and \"t\" flags will be displayed separately in those\n\tcases e.g. \"jcc     (xD)\" for a condition branch within a transaction\n\twith interrupts disabled. Note, interrupts becoming disabled is \"t\",\n\twhereas interrupts becoming enabled is \"Dt\".\n\n\tThe callindent field is synthesized and may have a value when\n\tInstruction Trace decoding. For calls and returns, it will display the\n\tname of the symbol indented with spaces to reflect the stack depth.\n\n\tWhen doing instruction trace decoding insn and insnlen give the\n\tinstruction bytes and the instruction length of the current\n\tinstruction.\n\n\tThe synth field is used by synthesized events which may be created when\n\tInstruction Trace decoding.\n\n\tThe ipc (instructions per cycle) field is synthesized and may have a value when\n\tInstruction Trace decoding.\n\n\tThe machine_pid and vcpu fields are derived from data resulting from using\n\tperf inject to insert a perf.data file recorded inside a virtual machine into\n\ta perf.data file recorded on the host at the same time.\n\n\tThe cgroup fields requires sample having the cgroup id which is saved\n\twhen \"--all-cgroups\" option is passed to 'perf record'.\n\n\tFinally, a user may not set fields to none for all event types.\n\ti.e., -F \"\" is not allowed.\n\n\tThe brstack output includes branch related information with raw addresses using the\n\t/v/v/v/v/cycles syntax in the following order:\n\tFROM: branch source instruction\n\tTO  : branch target instruction\n        M/P/-: M=branch target mispredicted or branch direction was mispredicted, P=target predicted or direction predicted, -=not supported\n\tX/- : X=branch inside a transactional region, -=not in transaction region or not supported\n\tA/- : A=TSX abort entry, -=not aborted region or not supported\n\tcycles\n\n\tThe brstacksym is identical to brstack, except that the FROM and TO addresses are printed in a symbolic form if possible.\n\n\tWhen brstackinsn is specified the full assembler sequences of branch sequences for each sample\n\tis printed. This is the full execution path leading to the sample. This is only supported when the\n\tsample was recorded with perf record -b or -j any.\n\n\tUse brstackinsnlen to print the brstackinsn lenght. For example, you\n\tcan\u2019t know the next sequential instruction after an unconditional branch unless\n\tyou calculate that based on its length.\n\n\tThe brstackoff field will print an offset into a specific dso/binary.\n\n\tWith the metric option perf script can compute metrics for\n\tsampling periods, similar to perf stat. This requires\n\tspecifying a group with multiple events defining metrics with the :S option\n\tfor perf record. perf will sample on the first event, and\n\tprint computed metrics for all the events in the group. Please note\n\tthat the metric computed is averaged over the whole sampling\n\tperiod (since the last sample), not just for the sample point.\n\n\tFor sample events it's possible to display misc field with -F +misc option,\n\tfollowing letters are displayed for each bit:\n\n\t  PERF_RECORD_MISC_KERNEL               K\n\t  PERF_RECORD_MISC_USER                 U\n\t  PERF_RECORD_MISC_HYPERVISOR           H\n\t  PERF_RECORD_MISC_GUEST_KERNEL         G\n\t  PERF_RECORD_MISC_GUEST_USER           g\n\t  PERF_RECORD_MISC_MMAP_DATA*           M\n\t  PERF_RECORD_MISC_COMM_EXEC            E\n\t  PERF_RECORD_MISC_SWITCH_OUT           S\n\t  PERF_RECORD_MISC_SWITCH_OUT_PREEMPT   Sp\n\n\t  $ perf script -F +misc ...\n\t   sched-messaging  1414 K     28690.636582:       4590 cycles ...\n\t   sched-messaging  1407 U     28690.636600:     325620 cycles ...\n\t   sched-messaging  1414 K     28690.636608:      19473 cycles ...\n\t  misc field ___________/\n\n-k::\n--vmlinux=<file>::\n        vmlinux pathname\n\n--kallsyms=<file>::\n        kallsyms pathname\n\n--symfs=<directory>::\n        Look for files with symbols relative to this directory.\n\n-G::\n--hide-call-graph::\n        When printing symbols do not display call chain.\n\n--stop-bt::\n        Stop display of callgraph at these symbols\n\n-C::\n--cpu:: Only report samples for the list of CPUs provided. Multiple CPUs can\n\tbe provided as a comma-separated list with no space: 0,1. Ranges of\n\tCPUs are specified with -: 0-2. Default is to report samples on all\n\tCPUs.\n\n-c::\n--comms=::\n\tOnly display events for these comms. CSV that understands\n\tfile://filename entries.\n\n--pid=::\n\tOnly show events for given process ID (comma separated list).\n\n--tid=::\n\tOnly show events for given thread ID (comma separated list).\n\n-I::\n--show-info::\n\tDisplay extended information about the perf.data file. This adds\n\tinformation which may be very large and thus may clutter the display.\n\tIt currently includes: cpu and numa topology of the host system.\n\tIt can only be used with the perf script report mode.\n\n--show-kernel-path::\n\tTry to resolve the path of [kernel.kallsyms]\n\n--show-task-events\n\tDisplay task related events (e.g. FORK, COMM, EXIT).\n\n--show-mmap-events\n\tDisplay mmap related events (e.g. MMAP, MMAP2).\n\n--show-namespace-events\n\tDisplay namespace events i.e. events of type PERF_RECORD_NAMESPACES.\n\n--show-switch-events\n\tDisplay context switch events i.e. events of type PERF_RECORD_SWITCH or\n\tPERF_RECORD_SWITCH_CPU_WIDE.\n\n--show-lost-events\n\tDisplay lost events i.e. events of type PERF_RECORD_LOST.\n\n--show-round-events\n\tDisplay finished round events i.e. events of type PERF_RECORD_FINISHED_ROUND.\n\n--show-bpf-events\n\tDisplay bpf events i.e. events of type PERF_RECORD_KSYMBOL and PERF_RECORD_BPF_EVENT.\n\n--show-cgroup-events\n\tDisplay cgroup events i.e. events of type PERF_RECORD_CGROUP.\n\n--show-text-poke-events\n\tDisplay text poke events i.e. events of type PERF_RECORD_TEXT_POKE and\n\tPERF_RECORD_KSYMBOL.\n\n--demangle::\n\tDemangle symbol names to human readable form. It's enabled by default,\n\tdisable with --no-demangle.\n\n--demangle-kernel::\n\tDemangle kernel symbol names to human readable form (for C++ kernels).\n\n--header\n\tShow perf.data header.\n\n--header-only\n\tShow only perf.data header.\n\n--itrace::\n\tOptions for decoding instruction tracing data. The options are:\n\ninclude::itrace.txt[]\n\n\tTo disable decoding entirely, use --no-itrace.\n\n--full-source-path::\n\tShow the full path for source files for srcline output.\n\n--max-stack::\n        Set the stack depth limit when parsing the callchain, anything\n        beyond the specified depth will be ignored. This is a trade-off\n        between information loss and faster processing especially for\n        workloads that can have a very long callchain stack.\n        Note that when using the --itrace option the synthesized callchain size\n        will override this value if the synthesized callchain size is bigger.\n\n        Default: 127\n\n--ns::\n\tUse 9 decimal places when displaying time (i.e. show the nanoseconds)\n\n-f::\n--force::\n\tDon't do ownership validation.\n\n--time::\n\tOnly analyze samples within given time window: <start>,<stop>. Times\n\thave the format seconds.nanoseconds. If start is not given (i.e. time\n\tstring is ',x.y') then analysis starts at the beginning of the file. If\n\tstop time is not given (i.e. time string is 'x.y,') then analysis goes\n\tto end of file. Multiple ranges can be separated by spaces, which\n\trequires the argument to be quoted e.g. --time \"1234.567,1234.789 1235,\"\n\n\tAlso support time percent with multiple time ranges. Time string is\n\t'a%/n,b%/m,...' or 'a%-b%,c%-%d,...'.\n\n\tFor example:\n\tSelect the second 10% time slice:\n\tperf script --time 10%/2\n\n\tSelect from 0% to 10% time slice:\n\tperf script --time 0%-10%\n\n\tSelect the first and second 10% time slices:\n\tperf script --time 10%/1,10%/2\n\n\tSelect from 0% to 10% and 30% to 40% slices:\n\tperf script --time 0%-10%,30%-40%\n\n--max-blocks::\n\tSet the maximum number of program blocks to print with brstackinsn for\n\teach sample.\n\n--reltime::\n\tPrint time stamps relative to trace start.\n\n--deltatime::\n\tPrint time stamps relative to previous event.\n\n--per-event-dump::\n\tCreate per event files with a \"perf.data.EVENT.dump\" name instead of\n        printing to stdout, useful, for instance, for generating flamegraphs.\n\n--inline::\n\tIf a callgraph address belongs to an inlined function, the inline stack\n\twill be printed. Each entry has function name and file/line. Enabled by\n\tdefault, disable with --no-inline.\n\n--insn-trace::\n\tShow instruction stream for intel_pt traces. Combine with --xed to\n\tshow disassembly.\n\n--xed::\n\tRun xed disassembler on output. Requires installing the xed disassembler.\n\n-S::\n--symbols=symbol[,symbol...]::\n\tOnly consider the listed symbols. Symbols are typically a name\n\tbut they may also be hexadecimal address.\n\n\tThe hexadecimal address may be the start address of a symbol or\n\tany other address to filter the trace records\n\n\tFor example, to select the symbol noploop or the address 0x4007a0:\n\tperf script --symbols=noploop,0x4007a0\n\n\tSupport filtering trace records by symbol name, start address of\n\tsymbol, any hexadecimal address and address range.\n\n\tThe comparison order is:\n\n\t1. symbol name comparison\n\t2. symbol start address comparison.\n\t3. any hexadecimal address comparison.\n\t4. address range comparison (see --addr-range).\n\n--addr-range::\n       Use with -S or --symbols to list traced records within address range.\n\n       For example, to list the traced records within the address range\n       [0x4007a0, 0x0x4007a9]:\n       perf script -S 0x4007a0 --addr-range 10\n\n--dsos=::\n\tOnly consider symbols in these DSOs.\n\n--call-trace::\n\tShow call stream for intel_pt traces. The CPUs are interleaved, but\n\tcan be filtered with -C.\n\n--call-ret-trace::\n\tShow call and return stream for intel_pt traces.\n\n--graph-function::\n\tFor itrace only show specified functions and their callees for\n\titrace. Multiple functions can be separated by comma.\n\n--switch-on EVENT_NAME::\n\tOnly consider events after this event is found.\n\n--switch-off EVENT_NAME::\n\tStop considering events after this event is found.\n\n--show-on-off-events::\n\tShow the --switch-on/off events too.\n\n--stitch-lbr::\n\tShow callgraph with stitched LBRs, which may have more complete\n\tcallgraph. The perf.data file must have been obtained using\n\tperf record --call-graph lbr.\n\tDisabled by default. In common cases with call stack overflows,\n\tit can recreate better call stacks than the default lbr call stack\n\toutput. But this approach is not foolproof. There can be cases\n\twhere it creates incorrect call stacks from incorrect matches.\n\tThe known limitations include exception handing such as\n\tsetjmp/longjmp will have calls/returns not match.\n\n:GMEXAMPLECMD: script\n:GMEXAMPLESUBCMD:\ninclude::guest-files.txt[]\n\nSEE ALSO\n--------\nlinkperf:perf-record[1], linkperf:perf-script-perl[1],\nlinkperf:perf-script-python[1], linkperf:perf-intel-pt[1],\nlinkperf:perf-dlfilter[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}