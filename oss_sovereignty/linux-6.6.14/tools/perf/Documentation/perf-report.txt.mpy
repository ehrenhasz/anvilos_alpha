{
  "module_name": "perf-report.txt",
  "hash_id": "472f9393d78013ed74bbafcf825fec6ca477ffdc45ceb2a634046e401a0f7b2a",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-report.txt",
  "human_readable_source": "perf-report(1)\n==============\n\nNAME\n----\nperf-report - Read perf.data (created by perf record) and display the profile\n\nSYNOPSIS\n--------\n[verse]\n'perf report' [-i <file> | --input=file]\n\nDESCRIPTION\n-----------\nThis command displays the performance counter profile information recorded\nvia perf record.\n\nOPTIONS\n-------\n-i::\n--input=::\n        Input file name. (default: perf.data unless stdin is a fifo)\n\n-v::\n--verbose::\n        Be more verbose. (show symbol address, etc)\n\n-q::\n--quiet::\n\tDo not show any warnings or messages.  (Suppress -v)\n\n-n::\n--show-nr-samples::\n\tShow the number of samples for each symbol\n\n--show-cpu-utilization::\n        Show sample percentage for different cpu modes.\n\n-T::\n--threads::\n\tShow per-thread event counters.  The input data file should be recorded\n\twith -s option.\n-c::\n--comms=::\n\tOnly consider symbols in these comms. CSV that understands\n\tfile://filename entries.  This option will affect the percentage of\n\tthe overhead column.  See --percentage for more info.\n--pid=::\n        Only show events for given process ID (comma separated list).\n\n--tid=::\n        Only show events for given thread ID (comma separated list).\n-d::\n--dsos=::\n\tOnly consider symbols in these dsos. CSV that understands\n\tfile://filename entries.  This option will affect the percentage of\n\tthe overhead column.  See --percentage for more info.\n-S::\n--symbols=::\n\tOnly consider these symbols. CSV that understands\n\tfile://filename entries.  This option will affect the percentage of\n\tthe overhead column.  See --percentage for more info.\n\n--symbol-filter=::\n\tOnly show symbols that match (partially) with this filter.\n\n-U::\n--hide-unresolved::\n        Only display entries resolved to a symbol.\n\n-s::\n--sort=::\n\tSort histogram entries by given key(s) - multiple keys can be specified\n\tin CSV format.  Following sort keys are available:\n\tpid, comm, dso, symbol, parent, cpu, socket, srcline, weight,\n\tlocal_weight, cgroup_id, addr.\n\n\tEach key has following meaning:\n\n\t- comm: command (name) of the task which can be read via /proc/<pid>/comm\n\t- pid: command and tid of the task\n\t- dso: name of library or module executed at the time of sample\n\t- dso_size: size of library or module executed at the time of sample\n\t- symbol: name of function executed at the time of sample\n\t- symbol_size: size of function executed at the time of sample\n\t- parent: name of function matched to the parent regex filter. Unmatched\n\tentries are displayed as \"[other]\".\n\t- cpu: cpu number the task ran at the time of sample\n\t- socket: processor socket number the task ran at the time of sample\n\t- srcline: filename and line number executed at the time of sample.  The\n\tDWARF debugging info must be provided.\n\t- srcfile: file name of the source file of the samples. Requires dwarf\n\tinformation.\n\t- weight: Event specific weight, e.g. memory latency or transaction\n\tabort cost. This is the global weight.\n\t- local_weight: Local weight version of the weight above.\n\t- cgroup_id: ID derived from cgroup namespace device and inode numbers.\n\t- cgroup: cgroup pathname in the cgroupfs.\n\t- transaction: Transaction abort flags.\n\t- overhead: Overhead percentage of sample\n\t- overhead_sys: Overhead percentage of sample running in system mode\n\t- overhead_us: Overhead percentage of sample running in user mode\n\t- overhead_guest_sys: Overhead percentage of sample running in system mode\n\ton guest machine\n\t- overhead_guest_us: Overhead percentage of sample running in user mode on\n\tguest machine\n\t- sample: Number of sample\n\t- period: Raw number of event count of sample\n\t- time: Separate the samples by time stamp with the resolution specified by\n\t--time-quantum (default 100ms). Specify with overhead and before it.\n\t- code_page_size: the code page size of sampled code address (ip)\n\t- ins_lat: Instruction latency in core cycles. This is the global instruction\n\t  latency\n\t- local_ins_lat: Local instruction latency version\n\t- p_stage_cyc: On powerpc, this presents the number of cycles spent in a\n\t  pipeline stage. And currently supported only on powerpc.\n\t- addr: (Full) virtual address of the sampled instruction\n\t- retire_lat: On X86, this reports pipeline stall of this instruction compared\n\t  to the previous instruction in cycles. And currently supported only on X86\n\t- simd: Flags describing a SIMD operation. \"e\" for empty Arm SVE predicate. \"p\" for partial Arm SVE predicate\n\n\tBy default, comm, dso and symbol keys are used.\n\t(i.e. --sort comm,dso,symbol)\n\n\tIf --branch-stack option is used, following sort keys are also\n\tavailable:\n\n\t- dso_from: name of library or module branched from\n\t- dso_to: name of library or module branched to\n\t- symbol_from: name of function branched from\n\t- symbol_to: name of function branched to\n\t- srcline_from: source file and line branched from\n\t- srcline_to: source file and line branched to\n\t- mispredict: \"N\" for predicted branch, \"Y\" for mispredicted branch\n\t- in_tx: branch in TSX transaction\n\t- abort: TSX transaction abort.\n\t- cycles: Cycles in basic block\n\n\tAnd default sort keys are changed to comm, dso_from, symbol_from, dso_to\n\tand symbol_to, see '--branch-stack'.\n\n\tWhen the sort key symbol is specified, columns \"IPC\" and \"IPC Coverage\"\n\tare enabled automatically. Column \"IPC\" reports the average IPC per function\n\tand column \"IPC coverage\" reports the percentage of instructions with\n\tsampled IPC in this function. IPC means Instruction Per Cycle. If it's low,\n\tit indicates there may be a performance bottleneck when the function is\n\texecuted, such as a memory access bottleneck. If a function has high overhead\n\tand low IPC, it's worth further analyzing it to optimize its performance.\n\n\tIf the --mem-mode option is used, the following sort keys are also available\n\t(incompatible with --branch-stack):\n\tsymbol_daddr, dso_daddr, locked, tlb, mem, snoop, dcacheline, blocked.\n\n\t- symbol_daddr: name of data symbol being executed on at the time of sample\n\t- dso_daddr: name of library or module containing the data being executed\n\ton at the time of the sample\n\t- locked: whether the bus was locked at the time of the sample\n\t- tlb: type of tlb access for the data at the time of the sample\n\t- mem: type of memory access for the data at the time of the sample\n\t- snoop: type of snoop (if any) for the data at the time of the sample\n\t- dcacheline: the cacheline the data address is on at the time of the sample\n\t- phys_daddr: physical address of data being executed on at the time of sample\n\t- data_page_size: the data page size of data being executed on at the time of sample\n\t- blocked: reason of blocked load access for the data at the time of the sample\n\n\tAnd the default sort keys are changed to local_weight, mem, sym, dso,\n\tsymbol_daddr, dso_daddr, snoop, tlb, locked, blocked, local_ins_lat,\n\tsee '--mem-mode'.\n\n\tIf the data file has tracepoint event(s), following (dynamic) sort keys\n\tare also available:\n\ttrace, trace_fields, [<event>.]<field>[/raw]\n\n\t- trace: pretty printed trace output in a single column\n\t- trace_fields: fields in tracepoints in separate columns\n\t- <field name>: optional event and field name for a specific field\n\n\tThe last form consists of event and field names.  If event name is\n\tomitted, it searches all events for matching field name.  The matched\n\tfield will be shown only for the event has the field.  The event name\n\tsupports substring match so user doesn't need to specify full subsystem\n\tand event name everytime.  For example, 'sched:sched_switch' event can\n\tbe shortened to 'switch' as long as it's not ambiguous.  Also event can\n\tbe specified by its index (starting from 1) preceded by the '%'.\n\tSo '%1' is the first event, '%2' is the second, and so on.\n\n\tThe field name can have '/raw' suffix which disables pretty printing\n\tand shows raw field value like hex numbers.  The --raw-trace option\n\thas the same effect for all dynamic sort keys.\n\n\tThe default sort keys are changed to 'trace' if all events in the data\n\tfile are tracepoint.\n\n-F::\n--fields=::\n\tSpecify output field - multiple keys can be specified in CSV format.\n\tFollowing fields are available:\n\toverhead, overhead_sys, overhead_us, overhead_children, sample and period.\n\tAlso it can contain any sort key(s).\n\n\tBy default, every sort keys not specified in -F will be appended\n\tautomatically.\n\n\tIf the keys starts with a prefix '+', then it will append the specified\n        field(s) to the default field order. For example: perf report -F +period,sample.\n\n-p::\n--parent=<regex>::\n        A regex filter to identify parent. The parent is a caller of this\n\tfunction and searched through the callchain, thus it requires callchain\n\tinformation recorded. The pattern is in the extended regex format and\n\tdefaults to \"\\^sys_|^do_page_fault\", see '--sort parent'.\n\n-x::\n--exclude-other::\n        Only display entries with parent-match.\n\n-w::\n--column-widths=<width[,width...]>::\n\tForce each column width to the provided list, for large terminal\n\treadability.  0 means no limit (default behavior).\n\n-t::\n--field-separator=::\n\tUse a special separator character and don't pad with spaces, replacing\n\tall occurrences of this separator in symbol names (and other output)\n\twith a '.' character, that thus it's the only non valid separator.\n\n-D::\n--dump-raw-trace::\n        Dump raw trace in ASCII.\n\n--disable-order::\n\tDisable raw trace ordering.\n\n-g::\n--call-graph=<print_type,threshold[,print_limit],order,sort_key[,branch],value>::\n        Display call chains using type, min percent threshold, print limit,\n\tcall order, sort key, optional branch and value.  Note that ordering\n\tis not fixed so any parameter can be given in an arbitrary order.\n\tOne exception is the print_limit which should be preceded by threshold.\n\n\tprint_type can be either:\n\t- flat: single column, linear exposure of call chains.\n\t- graph: use a graph tree, displaying absolute overhead rates. (default)\n\t- fractal: like graph, but displays relative rates. Each branch of\n\t\t the tree is considered as a new profiled object.\n\t- folded: call chains are displayed in a line, separated by semicolons\n\t- none: disable call chain display.\n\n\tthreshold is a percentage value which specifies a minimum percent to be\n\tincluded in the output call graph.  Default is 0.5 (%).\n\n\tprint_limit is only applied when stdio interface is used.  It's to limit\n\tnumber of call graph entries in a single hist entry.  Note that it needs\n\tto be given after threshold (but not necessarily consecutive).\n\tDefault is 0 (unlimited).\n\n\torder can be either:\n\t- callee: callee based call graph.\n\t- caller: inverted caller based call graph.\n\tDefault is 'caller' when --children is used, otherwise 'callee'.\n\n\tsort_key can be:\n\t- function: compare on functions (default)\n\t- address: compare on individual code addresses\n\t- srcline: compare on source filename and line number\n\n\tbranch can be:\n\t- branch: include last branch information in callgraph when available.\n\t          Usually more convenient to use --branch-history for this.\n\n\tvalue can be:\n\t- percent: display overhead percent (default)\n\t- period: display event period\n\t- count: display event count\n\n--children::\n\tAccumulate callchain of children to parent entry so that then can\n\tshow up in the output.  The output will have a new \"Children\" column\n\tand will be sorted on the data.  It requires callchains are recorded.\n\tSee the `overhead calculation' section for more details. Enabled by\n\tdefault, disable with --no-children.\n\n--max-stack::\n\tSet the stack depth limit when parsing the callchain, anything\n\tbeyond the specified depth will be ignored. This is a trade-off\n\tbetween information loss and faster processing especially for\n\tworkloads that can have a very long callchain stack.\n\tNote that when using the --itrace option the synthesized callchain size\n\twill override this value if the synthesized callchain size is bigger.\n\n\tDefault: 127\n\n-G::\n--inverted::\n        alias for inverted caller based call graph.\n\n--ignore-callees=<regex>::\n        Ignore callees of the function(s) matching the given regex.\n        This has the effect of collecting the callers of each such\n        function into one place in the call-graph tree.\n\n--pretty=<key>::\n        Pretty printing style.  key: normal, raw\n\n--stdio:: Use the stdio interface.\n\n--stdio-color::\n\t'always', 'never' or 'auto', allowing configuring color output\n\tvia the command line, in addition to via \"color.ui\" .perfconfig.\n\tUse '--stdio-color always' to generate color even when redirecting\n\tto a pipe or file. Using just '--stdio-color' is equivalent to\n\tusing 'always'.\n\n--tui:: Use the TUI interface, that is integrated with annotate and allows\n        zooming into DSOs or threads, among other features. Use of --tui\n\trequires a tty, if one is not present, as when piping to other\n\tcommands, the stdio interface is used.\n\n--gtk:: Use the GTK2 interface.\n\n-k::\n--vmlinux=<file>::\n        vmlinux pathname\n\n--ignore-vmlinux::\n\tIgnore vmlinux files.\n\n--kallsyms=<file>::\n        kallsyms pathname\n\n-m::\n--modules::\n        Load module symbols. WARNING: This should only be used with -k and\n        a LIVE kernel.\n\n-f::\n--force::\n        Don't do ownership validation.\n\n--symfs=<directory>::\n        Look for files with symbols relative to this directory.\n\n-C::\n--cpu:: Only report samples for the list of CPUs provided. Multiple CPUs can\n\tbe provided as a comma-separated list with no space: 0,1. Ranges of\n\tCPUs are specified with -: 0-2. Default is to report samples on all\n\tCPUs.\n\n-M::\n--disassembler-style=:: Set disassembler style for objdump.\n\n--source::\n\tInterleave source code with assembly code. Enabled by default,\n\tdisable with --no-source.\n\n--asm-raw::\n\tShow raw instruction encoding of assembly instructions.\n\n--show-total-period:: Show a column with the sum of periods.\n\n-I::\n--show-info::\n\tDisplay extended information about the perf.data file. This adds\n\tinformation which may be very large and thus may clutter the display.\n\tIt currently includes: cpu and numa topology of the host system.\n\n-b::\n--branch-stack::\n\tUse the addresses of sampled taken branches instead of the instruction\n\taddress to build the histograms. To generate meaningful output, the\n\tperf.data file must have been obtained using perf record -b or\n\tperf record --branch-filter xxx where xxx is a branch filter option.\n\tperf report is able to auto-detect whether a perf.data file contains\n\tbranch stacks and it will automatically switch to the branch view mode,\n\tunless --no-branch-stack is used.\n\n--branch-history::\n\tAdd the addresses of sampled taken branches to the callstack.\n\tThis allows to examine the path the program took to each sample.\n\tThe data collection must have used -b (or -j) and -g.\n\n--addr2line=<path>::\n        Path to addr2line binary.\n\n--objdump=<path>::\n        Path to objdump binary.\n\n--prefix=PREFIX::\n--prefix-strip=N::\n\tRemove first N entries from source file path names in executables\n\tand add PREFIX. This allows to display source code compiled on systems\n\twith different file system layout.\n\n--group::\n\tShow event group information together. It forces group output also\n\tif there are no groups defined in data file.\n\n--group-sort-idx::\n\tSort the output by the event at the index n in group. If n is invalid,\n\tsort by the first event. It can support multiple groups with different\n\tamount of events. WARNING: This should be used on grouped events.\n\n--demangle::\n\tDemangle symbol names to human readable form. It's enabled by default,\n\tdisable with --no-demangle.\n\n--demangle-kernel::\n\tDemangle kernel symbol names to human readable form (for C++ kernels).\n\n--mem-mode::\n\tUse the data addresses of samples in addition to instruction addresses\n\tto build the histograms.  To generate meaningful output, the perf.data\n\tfile must have been obtained using perf record -d -W and using a\n\tspecial event -e cpu/mem-loads/p or -e cpu/mem-stores/p. See\n\t'perf mem' for simpler access.\n\n--percent-limit::\n\tDo not show entries which have an overhead under that percent.\n\t(Default: 0).  Note that this option also sets the percent limit (threshold)\n\tof callchains.  However the default value of callchain threshold is\n\tdifferent than the default value of hist entries.  Please see the\n\t--call-graph option for details.\n\n--percentage::\n\tDetermine how to display the overhead percentage of filtered entries.\n\tFilters can be applied by --comms, --dsos and/or --symbols options and\n\tZoom operations on the TUI (thread, dso, etc).\n\n\t\"relative\" means it's relative to filtered entries only so that the\n\tsum of shown entries will be always 100%.  \"absolute\" means it retains\n\tthe original value before and after the filter is applied.\n\n--header::\n\tShow header information in the perf.data file.  This includes\n\tvarious information like hostname, OS and perf version, cpu/mem\n\tinfo, perf command line, event list and so on.  Currently only\n\t--stdio output supports this feature.\n\n--header-only::\n\tShow only perf.data header (forces --stdio).\n\n--time::\n\tOnly analyze samples within given time window: <start>,<stop>. Times\n\thave the format seconds.nanoseconds. If start is not given (i.e. time\n\tstring is ',x.y') then analysis starts at the beginning of the file. If\n\tstop time is not given (i.e. time string is 'x.y,') then analysis goes\n\tto end of file. Multiple ranges can be separated by spaces, which\n\trequires the argument to be quoted e.g. --time \"1234.567,1234.789 1235,\"\n\n\tAlso support time percent with multiple time ranges. Time string is\n\t'a%/n,b%/m,...' or 'a%-b%,c%-%d,...'.\n\n\tFor example:\n\tSelect the second 10% time slice:\n\n\t  perf report --time 10%/2\n\n\tSelect from 0% to 10% time slice:\n\n\t  perf report --time 0%-10%\n\n\tSelect the first and second 10% time slices:\n\n\t  perf report --time 10%/1,10%/2\n\n\tSelect from 0% to 10% and 30% to 40% slices:\n\n\t  perf report --time 0%-10%,30%-40%\n\n--switch-on EVENT_NAME::\n\tOnly consider events after this event is found.\n\n\tThis may be interesting to measure a workload only after some initialization\n\tphase is over, i.e. insert a perf probe at that point and then using this\n\toption with that probe.\n\n--switch-off EVENT_NAME::\n\tStop considering events after this event is found.\n\n--show-on-off-events::\n\tShow the --switch-on/off events too. This has no effect in 'perf report' now\n\tbut probably we'll make the default not to show the switch-on/off events\n        on the --group mode and if there is only one event besides the off/on ones,\n\tgo straight to the histogram browser, just like 'perf report' with no events\n\texplicitly specified does.\n\n--itrace::\n\tOptions for decoding instruction tracing data. The options are:\n\ninclude::itrace.txt[]\n\n\tTo disable decoding entirely, use --no-itrace.\n\n--full-source-path::\n\tShow the full path for source files for srcline output.\n\n--show-ref-call-graph::\n\tWhen multiple events are sampled, it may not be needed to collect\n\tcallgraphs for all of them. The sample sites are usually nearby,\n\tand it's enough to collect the callgraphs on a reference event.\n\tSo user can use \"call-graph=no\" event modifier to disable callgraph\n\tfor other events to reduce the overhead.\n\tHowever, perf report cannot show callgraphs for the event which\n\tdisable the callgraph.\n\tThis option extends the perf report to show reference callgraphs,\n\twhich collected by reference event, in no callgraph event.\n\n--stitch-lbr::\n\tShow callgraph with stitched LBRs, which may have more complete\n\tcallgraph. The perf.data file must have been obtained using\n\tperf record --call-graph lbr.\n\tDisabled by default. In common cases with call stack overflows,\n\tit can recreate better call stacks than the default lbr call stack\n\toutput. But this approach is not foolproof. There can be cases\n\twhere it creates incorrect call stacks from incorrect matches.\n\tThe known limitations include exception handing such as\n\tsetjmp/longjmp will have calls/returns not match.\n\n--socket-filter::\n\tOnly report the samples on the processor socket that match with this filter\n\n--samples=N::\n\tSave N individual samples for each histogram entry to show context in perf\n\treport tui browser.\n\n--raw-trace::\n\tWhen displaying traceevent output, do not use print fmt or plugins.\n\n--hierarchy::\n\tEnable hierarchical output.\n\n--inline::\n\tIf a callgraph address belongs to an inlined function, the inline stack\n\twill be printed. Each entry is function name or file/line. Enabled by\n\tdefault, disable with --no-inline.\n\n--mmaps::\n\tShow --tasks output plus mmap information in a format similar to\n\t/proc/<PID>/maps.\n\n\tPlease note that not all mmaps are stored, options affecting which ones\n\tare include 'perf record --data', for instance.\n\n--ns::\n\tShow time stamps in nanoseconds.\n\n--stats::\n\tDisplay overall events statistics without any further processing.\n\t(like the one at the end of the perf report -D command)\n\n--tasks::\n\tDisplay monitored tasks stored in perf data. Displaying pid/tid/ppid\n\tplus the command string aligned to distinguish parent and child tasks.\n\n--percent-type::\n\tSet annotation percent type from following choices:\n\t  global-period, local-period, global-hits, local-hits\n\n\tThe local/global keywords set if the percentage is computed\n\tin the scope of the function (local) or the whole data (global).\n\tThe period/hits keywords set the base the percentage is computed\n\ton - the samples period or the number of samples (hits).\n\n--time-quantum::\n\tConfigure time quantum for time sort key. Default 100ms.\n\tAccepts s, us, ms, ns units.\n\n--total-cycles::\n\tWhen --total-cycles is specified, it supports sorting for all blocks by\n\t'Sampled Cycles%'. This is useful to concentrate on the globally hottest\n\tblocks. In output, there are some new columns:\n\n\t'Sampled Cycles%' - block sampled cycles aggregation / total sampled cycles\n\t'Sampled Cycles'  - block sampled cycles aggregation\n\t'Avg Cycles%'     - block average sampled cycles / sum of total block average\n\t\t\t    sampled cycles\n\t'Avg Cycles'      - block average sampled cycles\n\n--skip-empty::\n\tDo not print 0 results in the --stat output.\n\ninclude::callchain-overhead-calculation.txt[]\n\nSEE ALSO\n--------\nlinkperf:perf-stat[1], linkperf:perf-annotate[1], linkperf:perf-record[1],\nlinkperf:perf-intel-pt[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}