{
  "module_name": "perf-record.txt",
  "hash_id": "9556048ec6e144c112b212a8d7f100980b32480d4df131011c22d344fe5c23ec",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/perf-record.txt",
  "human_readable_source": "perf-record(1)\n==============\n\nNAME\n----\nperf-record - Run a command and record its profile into perf.data\n\nSYNOPSIS\n--------\n[verse]\n'perf record' [-e <EVENT> | --event=EVENT] [-a] <command>\n'perf record' [-e <EVENT> | --event=EVENT] [-a] \\-- <command> [<options>]\n\nDESCRIPTION\n-----------\nThis command runs a command and gathers a performance counter profile\nfrom it, into perf.data - without displaying anything.\n\nThis file can then be inspected later on, using 'perf report'.\n\n\nOPTIONS\n-------\n<command>...::\n\tAny command you can specify in a shell.\n\n-e::\n--event=::\n\tSelect the PMU event. Selection can be:\n\n        - a symbolic event name\t(use 'perf list' to list all events)\n\n        - a raw PMU event in the form of rN where N is a hexadecimal value\n          that represents the raw register encoding with the layout of the\n          event control registers as described by entries in\n          /sys/bus/event_source/devices/cpu/format/*.\n\n        - a symbolic or raw PMU event followed by an optional colon\n\t  and a list of event modifiers, e.g., cpu-cycles:p.  See the\n\t  linkperf:perf-list[1] man page for details on event modifiers.\n\n\t- a symbolically formed PMU event like 'pmu/param1=0x3,param2/' where\n\t  'param1', 'param2', etc are defined as formats for the PMU in\n\t  /sys/bus/event_source/devices/<pmu>/format/*.\n\n\t- a symbolically formed event like 'pmu/config=M,config1=N,config3=K/'\n\n          where M, N, K are numbers (in decimal, hex, octal format). Acceptable\n          values for each of 'config', 'config1' and 'config2' are defined by\n          corresponding entries in /sys/bus/event_source/devices/<pmu>/format/*\n          param1 and param2 are defined as formats for the PMU in:\n          /sys/bus/event_source/devices/<pmu>/format/*\n\n\t  There are also some parameters which are not defined in .../<pmu>/format/*.\n\t  These params can be used to overload default config values per event.\n\t  Here are some common parameters:\n\t  - 'period': Set event sampling period\n\t  - 'freq': Set event sampling frequency\n\t  - 'time': Disable/enable time stamping. Acceptable values are 1 for\n\t\t    enabling time stamping. 0 for disabling time stamping.\n\t\t    The default is 1.\n\t  - 'call-graph': Disable/enable callgraph. Acceptable str are \"fp\" for\n\t\t\t FP mode, \"dwarf\" for DWARF mode, \"lbr\" for LBR mode and\n\t\t\t \"no\" for disable callgraph.\n\t  - 'stack-size': user stack size for dwarf mode\n\t  - 'name' : User defined event name. Single quotes (') may be used to\n\t\t    escape symbols in the name from parsing by shell and tool\n\t\t    like this: name=\\'CPU_CLK_UNHALTED.THREAD:cmask=0x1\\'.\n\t  - 'aux-output': Generate AUX records instead of events. This requires\n\t\t\t  that an AUX area event is also provided.\n\t  - 'aux-sample-size': Set sample size for AUX area sampling. If the\n\t  '--aux-sample' option has been used, set aux-sample-size=0 to disable\n\t  AUX area sampling for the event.\n\n          See the linkperf:perf-list[1] man page for more parameters.\n\n\t  Note: If user explicitly sets options which conflict with the params,\n\t  the value set by the parameters will be overridden.\n\n\t  Also not defined in .../<pmu>/format/* are PMU driver specific\n\t  configuration parameters.  Any configuration parameter preceded by\n\t  the letter '@' is not interpreted in user space and sent down directly\n\t  to the PMU driver.  For example:\n\n\t  perf record -e some_event/@cfg1,@cfg2=config/ ...\n\n\t  will see 'cfg1' and 'cfg2=config' pushed to the PMU driver associated\n\t  with the event for further processing.  There is no restriction on\n\t  what the configuration parameters are, as long as their semantic is\n\t  understood and supported by the PMU driver.\n\n        - a hardware breakpoint event in the form of '\\mem:addr[/len][:access]'\n          where addr is the address in memory you want to break in.\n          Access is the memory access type (read, write, execute) it can\n          be passed as follows: '\\mem:addr[:[r][w][x]]'. len is the range,\n          number of bytes from specified addr, which the breakpoint will cover.\n          If you want to profile read-write accesses in 0x1000, just set\n          'mem:0x1000:rw'.\n          If you want to profile write accesses in [0x1000~1008), just set\n          'mem:0x1000/8:w'.\n\n\t- a group of events surrounded by a pair of brace (\"{event1,event2,...}\").\n\t  Each event is separated by commas and the group should be quoted to\n\t  prevent the shell interpretation.  You also need to use --group on\n\t  \"perf report\" to view group events together.\n\n--filter=<filter>::\n\tEvent filter.  This option should follow an event selector (-e).\n\tIf the event is a tracepoint, the filter string will be parsed by\n\tthe kernel.  If the event is a hardware trace PMU (e.g. Intel PT\n\tor CoreSight), it'll be processed as an address filter.  Otherwise\n\tit means a general filter using BPF which can be applied for any\n\tkind of event.\n\n\t- tracepoint filters\n\n\tIn the case of tracepoints, multiple '--filter' options are combined\n\tusing '&&'.\n\n\t- address filters\n\n\tA hardware trace PMU advertises its ability to accept a number of\n\taddress filters\tby specifying a non-zero value in\n\t/sys/bus/event_source/devices/<pmu>/nr_addr_filters.\n\n\tAddress filters have the format:\n\n\tfilter|start|stop|tracestop <start> [/ <size>] [@<file name>]\n\n\tWhere:\n\t- 'filter': defines a region that will be traced.\n\t- 'start': defines an address at which tracing will begin.\n\t- 'stop': defines an address at which tracing will stop.\n\t- 'tracestop': defines a region in which tracing will stop.\n\n\t<file name> is the name of the object file, <start> is the offset to the\n\tcode to trace in that file, and <size> is the size of the region to\n\ttrace. 'start' and 'stop' filters need not specify a <size>.\n\n\tIf no object file is specified then the kernel is assumed, in which case\n\tthe start address must be a current kernel memory address.\n\n\t<start> can also be specified by providing the name of a symbol. If the\n\tsymbol name is not unique, it can be disambiguated by inserting #n where\n\t'n' selects the n'th symbol in address order. Alternately #0, #g or #G\n\tselect only a global symbol. <size> can also be specified by providing\n\tthe name of a symbol, in which case the size is calculated to the end\n\tof that symbol. For 'filter' and 'tracestop' filters, if <size> is\n\tomitted and <start> is a symbol, then the size is calculated to the end\n\tof that symbol.\n\n\tIf <size> is omitted and <start> is '*', then the start and size will\n\tbe calculated from the first and last symbols, i.e. to trace the whole\n\tfile.\n\n\tIf symbol names (or '*') are provided, they must be surrounded by white\n\tspace.\n\n\tThe filter passed to the kernel is not necessarily the same as entered.\n\tTo see the filter that is passed, use the -v option.\n\n\tThe kernel may not be able to configure a trace region if it is not\n\twithin a single mapping.  MMAP events (or /proc/<pid>/maps) can be\n\texamined to determine if that is a possibility.\n\n\tMultiple filters can be separated with space or comma.\n\n\t- bpf filters\n\n\tA BPF filter can access the sample data and make a decision based on the\n\tdata.  Users need to set an appropriate sample type to use the BPF\n\tfilter.  BPF filters need root privilege.\n\n\tThe sample data field can be specified in lower case letter.  Multiple\n\tfilters can be separated with comma.  For example,\n\n\t  --filter 'period > 1000, cpu == 1'\n\tor\n\t  --filter 'mem_op == load || mem_op == store, mem_lvl > l1'\n\n\tThe former filter only accept samples with period greater than 1000 AND\n\tCPU number is 1.  The latter one accepts either load and store memory\n\toperations but it should have memory level above the L1.  Since the\n\tmem_op and mem_lvl fields come from the (memory) data_source, it'd only\n\twork with some events which set the data_source field.\n\n\tAlso user should request to collect that information (with -d option in\n\tthe above case).  Otherwise, the following message will be shown.\n\n\t  $ sudo perf record -e cycles --filter 'mem_op == load'\n\t  Error: cycles event does not have PERF_SAMPLE_DATA_SRC\n\t   Hint: please add -d option to perf record.\n\t  failed to set filter \"BPF\" on event cycles with 22 (Invalid argument)\n\n\tEssentially the BPF filter expression is:\n\n\t  <term> <operator> <value> ((\",\" | \"||\") <term> <operator> <value>)*\n\n\tThe <term> can be one of:\n\t  ip, id, tid, pid, cpu, time, addr, period, txn, weight, phys_addr,\n\t  code_pgsz, data_pgsz, weight1, weight2, weight3, ins_lat, retire_lat,\n\t  p_stage_cyc, mem_op, mem_lvl, mem_snoop, mem_remote, mem_lock,\n\t  mem_dtlb, mem_blk, mem_hops\n\n\tThe <operator> can be one of:\n\t  ==, !=, >, >=, <, <=, &\n\n\tThe <value> can be one of:\n\t  <number> (for any term)\n\t  na, load, store, pfetch, exec (for mem_op)\n\t  l1, l2, l3, l4, cxl, io, any_cache, lfb, ram, pmem (for mem_lvl)\n\t  na, none, hit, miss, hitm, fwd, peer (for mem_snoop)\n\t  remote (for mem_remote)\n\t  na, locked (for mem_locked)\n\t  na, l1_hit, l1_miss, l2_hit, l2_miss, any_hit, any_miss, walk, fault (for mem_dtlb)\n\t  na, by_data, by_addr (for mem_blk)\n\t  hops0, hops1, hops2, hops3 (for mem_hops)\n\n--exclude-perf::\n\tDon't record events issued by perf itself. This option should follow\n\tan event selector (-e) which selects tracepoint event(s). It adds a\n\tfilter expression 'common_pid != $PERFPID' to filters. If other\n\t'--filter' exists, the new filter expression will be combined with\n\tthem by '&&'.\n\n-a::\n--all-cpus::\n        System-wide collection from all CPUs (default if no target is specified).\n\n-p::\n--pid=::\n\tRecord events on existing process ID (comma separated list).\n\n-t::\n--tid=::\n        Record events on existing thread ID (comma separated list).\n        This option also disables inheritance by default.  Enable it by adding\n        --inherit.\n\n-u::\n--uid=::\n        Record events in threads owned by uid. Name or number.\n\n-r::\n--realtime=::\n\tCollect data with this RT SCHED_FIFO priority.\n\n--no-buffering::\n\tCollect data without buffering.\n\n-c::\n--count=::\n\tEvent period to sample.\n\n-o::\n--output=::\n\tOutput file name.\n\n-i::\n--no-inherit::\n\tChild tasks do not inherit counters.\n\n-F::\n--freq=::\n\tProfile at this frequency. Use 'max' to use the currently maximum\n\tallowed frequency, i.e. the value in the kernel.perf_event_max_sample_rate\n\tsysctl. Will throttle down to the currently maximum allowed frequency.\n\tSee --strict-freq.\n\n--strict-freq::\n\tFail if the specified frequency can't be used.\n\n-m::\n--mmap-pages=::\n\tNumber of mmap data pages (must be a power of two) or size\n\tspecification with appended unit character - B/K/M/G. The\n\tsize is rounded up to have nearest pages power of two value.\n\tAlso, by adding a comma, the number of mmap pages for AUX\n\tarea tracing can be specified.\n\n-g::\n\tEnables call-graph (stack chain/backtrace) recording for both\n\tkernel space and user space.\n\n--call-graph::\n\tSetup and enable call-graph (stack chain/backtrace) recording,\n\timplies -g.  Default is \"fp\" (for user space).\n\n\tThe unwinding method used for kernel space is dependent on the\n\tunwinder used by the active kernel configuration, i.e\n\tCONFIG_UNWINDER_FRAME_POINTER (fp) or CONFIG_UNWINDER_ORC (orc)\n\n\tAny option specified here controls the method used for user space.\n\n\tValid options are \"fp\" (frame pointer), \"dwarf\" (DWARF's CFI -\n\tCall Frame Information) or \"lbr\" (Hardware Last Branch Record\n\tfacility).\n\n\tIn some systems, where binaries are build with gcc\n\t--fomit-frame-pointer, using the \"fp\" method will produce bogus\n\tcall graphs, using \"dwarf\", if available (perf tools linked to\n\tthe libunwind or libdw library) should be used instead.\n\tUsing the \"lbr\" method doesn't require any compiler options. It\n\twill produce call graphs from the hardware LBR registers. The\n\tmain limitation is that it is only available on new Intel\n\tplatforms, such as Haswell. It can only get user call chain. It\n\tdoesn't work with branch stack sampling at the same time.\n\n\tWhen \"dwarf\" recording is used, perf also records (user) stack dump\n\twhen sampled.  Default size of the stack dump is 8192 (bytes).\n\tUser can change the size by passing the size after comma like\n\t\"--call-graph dwarf,4096\".\n\n\tWhen \"fp\" recording is used, perf tries to save stack enties\n\tup to the number specified in sysctl.kernel.perf_event_max_stack\n\tby default.  User can change the number by passing it after comma\n\tlike \"--call-graph fp,32\".\n\n-q::\n--quiet::\n\tDon't print any warnings or messages, useful for scripting.\n\n-v::\n--verbose::\n\tBe more verbose (show counter open errors, etc).\n\n-s::\n--stat::\n\tRecord per-thread event counts.  Use it with 'perf report -T' to see\n\tthe values.\n\n-d::\n--data::\n\tRecord the sample virtual addresses.\n\n--phys-data::\n\tRecord the sample physical addresses.\n\n--data-page-size::\n\tRecord the sampled data address data page size.\n\n--code-page-size::\n\tRecord the sampled code address (ip) page size\n\n-T::\n--timestamp::\n\tRecord the sample timestamps. Use it with 'perf report -D' to see the\n\ttimestamps, for instance.\n\n-P::\n--period::\n\tRecord the sample period.\n\n--sample-cpu::\n\tRecord the sample cpu.\n\n--sample-identifier::\n\tRecord the sample identifier i.e. PERF_SAMPLE_IDENTIFIER bit set in\n\tthe sample_type member of the struct perf_event_attr argument to the\n\tperf_event_open system call.\n\n-n::\n--no-samples::\n\tDon't sample.\n\n-R::\n--raw-samples::\nCollect raw sample records from all opened counters (default for tracepoint counters).\n\n-C::\n--cpu::\nCollect samples only on the list of CPUs provided. Multiple CPUs can be provided as a\ncomma-separated list with no space: 0,1. Ranges of CPUs are specified with -: 0-2.\nIn per-thread mode with inheritance mode on (default), samples are captured only when\nthe thread executes on the designated CPUs. Default is to monitor all CPUs.\n\n-B::\n--no-buildid::\nDo not save the build ids of binaries in the perf.data files. This skips\npost processing after recording, which sometimes makes the final step in\nthe recording process to take a long time, as it needs to process all\nevents looking for mmap records. The downside is that it can misresolve\nsymbols if the workload binaries used when recording get locally rebuilt\nor upgraded, because the only key available in this case is the\npathname. You can also set the \"record.build-id\" config variable to\n'skip to have this behaviour permanently.\n\n-N::\n--no-buildid-cache::\nDo not update the buildid cache. This saves some overhead in situations\nwhere the information in the perf.data file (which includes buildids)\nis sufficient.  You can also set the \"record.build-id\" config variable to\n'no-cache' to have the same effect.\n\n-G name,...::\n--cgroup name,...::\nmonitor only in the container (cgroup) called \"name\". This option is available only\nin per-cpu mode. The cgroup filesystem must be mounted. All threads belonging to\ncontainer \"name\" are monitored when they run on the monitored CPUs. Multiple cgroups\ncan be provided. Each cgroup is applied to the corresponding event, i.e., first cgroup\nto first event, second cgroup to second event and so on. It is possible to provide\nan empty cgroup (monitor all the time) using, e.g., -G foo,,bar. Cgroups must have\ncorresponding events, i.e., they always refer to events defined earlier on the command\nline. If the user wants to track multiple events for a specific cgroup, the user can\nuse '-e e1 -e e2 -G foo,foo' or just use '-e e1 -e e2 -G foo'.\n\nIf wanting to monitor, say, 'cycles' for a cgroup and also for system wide, this\ncommand line can be used: 'perf stat -e cycles -G cgroup_name -a -e cycles'.\n\n-b::\n--branch-any::\nEnable taken branch stack sampling. Any type of taken branch may be sampled.\nThis is a shortcut for --branch-filter any. See --branch-filter for more infos.\n\n-j::\n--branch-filter::\nEnable taken branch stack sampling. Each sample captures a series of consecutive\ntaken branches. The number of branches captured with each sample depends on the\nunderlying hardware, the type of branches of interest, and the executed code.\nIt is possible to select the types of branches captured by enabling filters. The\nfollowing filters are defined:\n\n        - any:  any type of branches\n        - any_call: any function call or system call\n        - any_ret: any function return or system call return\n        - ind_call: any indirect branch\n        - ind_jmp: any indirect jump\n        - call: direct calls, including far (to/from kernel) calls\n        - u:  only when the branch target is at the user level\n        - k: only when the branch target is in the kernel\n        - hv: only when the target is at the hypervisor level\n\t- in_tx: only when the target is in a hardware transaction\n\t- no_tx: only when the target is not in a hardware transaction\n\t- abort_tx: only when the target is a hardware transaction abort\n\t- cond: conditional branches\n\t- call_stack: save call stack\n\t- no_flags: don't save branch flags e.g prediction, misprediction etc\n\t- no_cycles: don't save branch cycles\n\t- hw_index: save branch hardware index\n\t- save_type: save branch type during sampling in case binary is not available later\n\t\t     For the platforms with Intel Arch LBR support (12th-Gen+ client or\n\t\t     4th-Gen Xeon+ server), the save branch type is unconditionally enabled\n\t\t     when the taken branch stack sampling is enabled.\n\t- priv: save privilege state during sampling in case binary is not available later\n\n+\nThe option requires at least one branch type among any, any_call, any_ret, ind_call, cond.\nThe privilege levels may be omitted, in which case, the privilege levels of the associated\nevent are applied to the branch filter. Both kernel (k) and hypervisor (hv) privilege\nlevels are subject to permissions.  When sampling on multiple events, branch stack sampling\nis enabled for all the sampling events. The sampled branch type is the same for all events.\nThe various filters must be specified as a comma separated list: --branch-filter any_ret,u,k\nNote that this feature may not be available on all processors.\n\n-W::\n--weight::\nEnable weightened sampling. An additional weight is recorded per sample and can be\ndisplayed with the weight and local_weight sort keys.  This currently works for TSX\nabort events and some memory events in precise mode on modern Intel CPUs.\n\n--namespaces::\nRecord events of type PERF_RECORD_NAMESPACES.  This enables 'cgroup_id' sort key.\n\n--all-cgroups::\nRecord events of type PERF_RECORD_CGROUP.  This enables 'cgroup' sort key.\n\n--transaction::\nRecord transaction flags for transaction related events.\n\n--per-thread::\nUse per-thread mmaps.  By default per-cpu mmaps are created.  This option\noverrides that and uses per-thread mmaps.  A side-effect of that is that\ninheritance is automatically disabled.  --per-thread is ignored with a warning\nif combined with -a or -C options.\n\n-D::\n--delay=::\nAfter starting the program, wait msecs before measuring (-1: start with events\ndisabled), or enable events only for specified ranges of msecs (e.g.\n-D 10-20,30-40 means wait 10 msecs, enable for 10 msecs, wait 10 msecs, enable\nfor 10 msecs, then stop). Note, delaying enabling of events is useful to filter\nout the startup phase of the program, which is often very different.\n\n-I::\n--intr-regs::\nCapture machine state (registers) at interrupt, i.e., on counter overflows for\neach sample. List of captured registers depends on the architecture. This option\nis off by default. It is possible to select the registers to sample using their\nsymbolic names, e.g. on x86, ax, si. To list the available registers use\n--intr-regs=\\?. To name registers, pass a comma separated list such as\n--intr-regs=ax,bx. The list of register is architecture dependent.\n\n--user-regs::\nSimilar to -I, but capture user registers at sample time. To list the available\nuser registers use --user-regs=\\?.\n\n--running-time::\nRecord running and enabled time for read events (:S)\n\n-k::\n--clockid::\nSets the clock id to use for the various time fields in the perf_event_type\nrecords. See clock_gettime(). In particular CLOCK_MONOTONIC and\nCLOCK_MONOTONIC_RAW are supported, some events might also allow\nCLOCK_BOOTTIME, CLOCK_REALTIME and CLOCK_TAI.\n\n-S::\n--snapshot::\nSelect AUX area tracing Snapshot Mode. This option is valid only with an\nAUX area tracing event. Optionally, certain snapshot capturing parameters\ncan be specified in a string that follows this option:\n\n  - 'e': take one last snapshot on exit; guarantees that there is at least one\n       snapshot in the output file;\n  - <size>: if the PMU supports this, specify the desired snapshot size.\n\nIn Snapshot Mode trace data is captured only when signal SIGUSR2 is received\nand on exit if the above 'e' option is given.\n\n--aux-sample[=OPTIONS]::\nSelect AUX area sampling. At least one of the events selected by the -e option\nmust be an AUX area event. Samples on other events will be created containing\ndata from the AUX area. Optionally sample size may be specified, otherwise it\ndefaults to 4KiB.\n\n--proc-map-timeout::\nWhen processing pre-existing threads /proc/XXX/mmap, it may take a long time,\nbecause the file may be huge. A time out is needed in such cases.\nThis option sets the time out limit. The default value is 500 ms.\n\n--switch-events::\nRecord context switch events i.e. events of type PERF_RECORD_SWITCH or\nPERF_RECORD_SWITCH_CPU_WIDE. In some cases (e.g. Intel PT, CoreSight or Arm SPE)\nswitch events will be enabled automatically, which can be suppressed by\nby the option --no-switch-events.\n\n--vmlinux=PATH::\nSpecify vmlinux path which has debuginfo.\n(enabled when BPF prologue is on)\n\n--buildid-all::\nRecord build-id of all DSOs regardless whether it's actually hit or not.\n\n--buildid-mmap::\nRecord build ids in mmap2 events, disables build id cache (implies --no-buildid).\n\n--aio[=n]::\nUse <n> control blocks in asynchronous (Posix AIO) trace writing mode (default: 1, max: 4).\nAsynchronous mode is supported only when linking Perf tool with libc library\nproviding implementation for Posix AIO API.\n\n--affinity=mode::\nSet affinity mask of trace reading thread according to the policy defined by 'mode' value:\n\n  - node - thread affinity mask is set to NUMA node cpu mask of the processed mmap buffer\n  - cpu  - thread affinity mask is set to cpu of the processed mmap buffer\n\n--mmap-flush=number::\n\nSpecify minimal number of bytes that is extracted from mmap data pages and\nprocessed for output. One can specify the number using B/K/M/G suffixes.\n\nThe maximal allowed value is a quarter of the size of mmaped data pages.\n\nThe default option value is 1 byte which means that every time that the output\nwriting thread finds some new data in the mmaped buffer the data is extracted,\npossibly compressed (-z) and written to the output, perf.data or pipe.\n\nLarger data chunks are compressed more effectively in comparison to smaller\nchunks so extraction of larger chunks from the mmap data pages is preferable\nfrom the perspective of output size reduction.\n\nAlso at some cases executing less output write syscalls with bigger data size\ncan take less time than executing more output write syscalls with smaller data\nsize thus lowering runtime profiling overhead.\n\n-z::\n--compression-level[=n]::\nProduce compressed trace using specified level n (default: 1 - fastest compression,\n22 - smallest trace)\n\n--all-kernel::\nConfigure all used events to run in kernel space.\n\n--all-user::\nConfigure all used events to run in user space.\n\n--kernel-callchains::\nCollect callchains only from kernel space. I.e. this option sets\nperf_event_attr.exclude_callchain_user to 1.\n\n--user-callchains::\nCollect callchains only from user space. I.e. this option sets\nperf_event_attr.exclude_callchain_kernel to 1.\n\nDon't use both --kernel-callchains and --user-callchains at the same time or no\ncallchains will be collected.\n\n--timestamp-filename\nAppend timestamp to output file name.\n\n--timestamp-boundary::\nRecord timestamp boundary (time of first/last samples).\n\n--switch-output[=mode]::\nGenerate multiple perf.data files, timestamp prefixed, switching to a new one\nbased on 'mode' value:\n\n  - \"signal\" - when receiving a SIGUSR2 (default value) or\n  - <size>   - when reaching the size threshold, size is expected to\n               be a number with appended unit character - B/K/M/G\n  - <time>   - when reaching the time threshold, size is expected to\n               be a number with appended unit character - s/m/h/d\n\n               Note: the precision of  the size  threshold  hugely depends\n               on your configuration  - the number and size of  your  ring\n               buffers (-m). It is generally more precise for higher sizes\n               (like >5M), for lower values expect different sizes.\n\nA possible use case is to, given an external event, slice the perf.data file\nthat gets then processed, possibly via a perf script, to decide if that\nparticular perf.data snapshot should be kept or not.\n\nImplies --timestamp-filename, --no-buildid and --no-buildid-cache.\nThe reason for the latter two is to reduce the data file switching\noverhead. You can still switch them on with:\n\n  --switch-output --no-no-buildid  --no-no-buildid-cache\n\n--switch-output-event::\nEvents that will cause the switch of the perf.data file, auto-selecting\n--switch-output=signal, the results are similar as internally the side band\nthread will also send a SIGUSR2 to the main one.\n\nUses the same syntax as --event, it will just not be recorded, serving only to\nswitch the perf.data file as soon as the --switch-output event is processed by\na separate sideband thread.\n\nThis sideband thread is also used to other purposes, like processing the\nPERF_RECORD_BPF_EVENT records as they happen, asking the kernel for extra BPF\ninformation, etc.\n\n--switch-max-files=N::\n\nWhen rotating perf.data with --switch-output, only keep N files.\n\n--dry-run::\nParse options then exit. --dry-run can be used to detect errors in cmdline\noptions.\n\n'perf record --dry-run -e' can act as a BPF script compiler if llvm.dump-obj\nin config file is set to true.\n\n--synth=TYPE::\nCollect and synthesize given type of events (comma separated).  Note that\nthis option controls the synthesis from the /proc filesystem which represent\ntask status for pre-existing threads.\n\nKernel (and some other) events are recorded regardless of the\nchoice in this option.  For example, --synth=no would have MMAP events for\nkernel and modules.\n\nAvailable types are:\n\n  - 'task'    - synthesize FORK and COMM events for each task\n  - 'mmap'    - synthesize MMAP events for each process (implies 'task')\n  - 'cgroup'  - synthesize CGROUP events for each cgroup\n  - 'all'     - synthesize all events (default)\n  - 'no'      - do not synthesize any of the above events\n\n--tail-synthesize::\nInstead of collecting non-sample events (for example, fork, comm, mmap) at\nthe beginning of record, collect them during finalizing an output file.\nThe collected non-sample events reflects the status of the system when\nrecord is finished.\n\n--overwrite::\nMakes all events use an overwritable ring buffer. An overwritable ring\nbuffer works like a flight recorder: when it gets full, the kernel will\noverwrite the oldest records, that thus will never make it to the\nperf.data file.\n\nWhen '--overwrite' and '--switch-output' are used perf records and drops\nevents until it receives a signal, meaning that something unusual was\ndetected that warrants taking a snapshot of the most current events,\nthose fitting in the ring buffer at that moment.\n\n'overwrite' attribute can also be set or canceled for an event using\nconfig terms. For example: 'cycles/overwrite/' and 'instructions/no-overwrite/'.\n\nImplies --tail-synthesize.\n\n--kcore::\nMake a copy of /proc/kcore and place it into a directory with the perf data file.\n\n--max-size=<size>::\nLimit the sample data max size, <size> is expected to be a number with\nappended unit character - B/K/M/G\n\n--num-thread-synthesize::\n\tThe number of threads to run when synthesizing events for existing processes.\n\tBy default, the number of threads equals 1.\n\nifdef::HAVE_LIBPFM[]\n--pfm-events events::\nSelect a PMU event using libpfm4 syntax (see http://perfmon2.sf.net)\nincluding support for event filters. For example '--pfm-events\ninst_retired:any_p:u:c=1:i'. More than one event can be passed to the\noption using the comma separator. Hardware events and generic hardware\nevents cannot be mixed together. The latter must be used with the -e\noption. The -e option and this one can be mixed and matched.  Events\ncan be grouped using the {} notation.\nendif::HAVE_LIBPFM[]\n\n--control=fifo:ctl-fifo[,ack-fifo]::\n--control=fd:ctl-fd[,ack-fd]::\nctl-fifo / ack-fifo are opened and used as ctl-fd / ack-fd as follows.\nListen on ctl-fd descriptor for command to control measurement.\n\nAvailable commands:\n\n  - 'enable'           : enable events\n  - 'disable'          : disable events\n  - 'enable name'      : enable event 'name'\n  - 'disable name'     : disable event 'name'\n  - 'snapshot'         : AUX area tracing snapshot).\n  - 'stop'             : stop perf record\n  - 'ping'             : ping\n  - 'evlist [-v|-g|-F] : display all events\n\n                         -F  Show just the sample frequency used for each event.\n                         -v  Show all fields.\n                         -g  Show event group information.\n\nMeasurements can be started with events disabled using --delay=-1 option. Optionally\nsend control command completion ('ack\\n') to ack-fd descriptor to synchronize with the\ncontrolling process.  Example of bash shell script to enable and disable events during\nmeasurements:\n\n #!/bin/bash\n\n ctl_dir=/tmp/\n\n ctl_fifo=${ctl_dir}perf_ctl.fifo\n test -p ${ctl_fifo} && unlink ${ctl_fifo}\n mkfifo ${ctl_fifo}\n exec {ctl_fd}<>${ctl_fifo}\n\n ctl_ack_fifo=${ctl_dir}perf_ctl_ack.fifo\n test -p ${ctl_ack_fifo} && unlink ${ctl_ack_fifo}\n mkfifo ${ctl_ack_fifo}\n exec {ctl_fd_ack}<>${ctl_ack_fifo}\n\n perf record -D -1 -e cpu-cycles -a               \\\n             --control fd:${ctl_fd},${ctl_fd_ack} \\\n             -- sleep 30 &\n perf_pid=$!\n\n sleep 5  && echo 'enable' >&${ctl_fd} && read -u ${ctl_fd_ack} e1 && echo \"enabled(${e1})\"\n sleep 10 && echo 'disable' >&${ctl_fd} && read -u ${ctl_fd_ack} d1 && echo \"disabled(${d1})\"\n\n exec {ctl_fd_ack}>&-\n unlink ${ctl_ack_fifo}\n\n exec {ctl_fd}>&-\n unlink ${ctl_fifo}\n\n wait -n ${perf_pid}\n exit $?\n\n--threads=<spec>::\nWrite collected trace data into several data files using parallel threads.\n<spec> value can be user defined list of masks. Masks separated by colon\ndefine CPUs to be monitored by a thread and affinity mask of that thread\nis separated by slash:\n\n    <cpus mask 1>/<affinity mask 1>:<cpus mask 2>/<affinity mask 2>:...\n\nCPUs or affinity masks must not overlap with other corresponding masks.\nInvalid CPUs are ignored, but masks containing only invalid CPUs are not\nallowed.\n\nFor example user specification like the following:\n\n    0,2-4/2-4:1,5-7/5-7\n\nspecifies parallel threads layout that consists of two threads,\nthe first thread monitors CPUs 0 and 2-4 with the affinity mask 2-4,\nthe second monitors CPUs 1 and 5-7 with the affinity mask 5-7.\n\n<spec> value can also be a string meaning predefined parallel threads\nlayout:\n\n    - cpu    - create new data streaming thread for every monitored cpu\n    - core   - create new thread to monitor CPUs grouped by a core\n    - package - create new thread to monitor CPUs grouped by a package\n    - numa   - create new threed to monitor CPUs grouped by a NUMA domain\n\nPredefined layouts can be used on systems with large number of CPUs in\norder not to spawn multiple per-cpu streaming threads but still avoid LOST\nevents in data directory files. Option specified with no or empty value\ndefaults to CPU layout. Masks defined or provided by the option value are\nfiltered through the mask provided by -C option.\n\n--debuginfod[=URLs]::\n\tSpecify debuginfod URL to be used when cacheing perf.data binaries,\n\tit follows the same syntax as the DEBUGINFOD_URLS variable, like:\n\n\t  http://192.168.122.174:8002\n\n\tIf the URLs is not specified, the value of DEBUGINFOD_URLS\n\tsystem environment variable is used.\n\n--off-cpu::\n\tEnable off-cpu profiling with BPF.  The BPF program will collect\n\ttask scheduling information with (user) stacktrace and save them\n\tas sample data of a software event named \"offcpu-time\".  The\n\tsample period will have the time the task slept in nanoseconds.\n\n\tNote that BPF can collect stack traces using frame pointer (\"fp\")\n\tonly, as of now.  So the applications built without the frame\n\tpointer might see bogus addresses.\n\ninclude::intel-hybrid.txt[]\n\nSEE ALSO\n--------\nlinkperf:perf-stat[1], linkperf:perf-list[1], linkperf:perf-intel-pt[1]\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}