{
  "module_name": "db-export.txt",
  "hash_id": "0e619b973bf18b36edf9b14ab10ff4408998ef5953a7e482ff9e13fb36056172",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Documentation/db-export.txt",
  "human_readable_source": "Database Export\n===============\n\nperf tool's python scripting engine:\n\n\ttools/perf/util/scripting-engines/trace-event-python.c\n\nsupports scripts:\n\n\ttools/perf/scripts/python/export-to-sqlite.py\n\ttools/perf/scripts/python/export-to-postgresql.py\n\nwhich export data to a SQLite3 or PostgreSQL database.\n\nThe export process provides records with unique sequential ids which allows the\ndata to be imported directly to a database and provides the relationships\nbetween tables.\n\nOver time it is possible to continue to expand the export while maintaining\nbackward and forward compatibility, by following some simple rules:\n\n1. Because of the nature of SQL, existing tables and columns can continue to be\nused so long as the names and meanings (and to some extent data types) remain\nthe same.\n\n2. New tables and columns can be added, without affecting existing SQL queries,\nso long as the new names are unique.\n\n3. Scripts that use a database (e.g. exported-sql-viewer.py) can maintain\nbackward compatibility by testing for the presence of new tables and columns\nbefore using them. e.g. function IsSelectable() in exported-sql-viewer.py\n\n4. The export scripts themselves maintain forward compatibility (i.e. an existing\nscript will continue to work with new versions of perf) by accepting a variable\nnumber of arguments (e.g. def call_return_table(*x)) i.e. perf can pass more\narguments which old scripts will ignore.\n\n5. The scripting engine tests for the existence of script handler functions\nbefore calling them.  The scripting engine can also test for the support of new\nor optional features by checking for the existence and value of script global\nvariables.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}