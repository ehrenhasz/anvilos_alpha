{
  "module_name": "perf-completion.sh",
  "hash_id": "aca7c36fc7e56fa7835aa03e376874915a183f9d7bb804ab42fc645ad9ede4e7",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/perf-completion.sh",
  "human_readable_source": "# perf bash and zsh completion\n# SPDX-License-Identifier: GPL-2.0\n\n# Taken from git.git's completion script.\n__my_reassemble_comp_words_by_ref()\n{\n\tlocal exclude i j first\n\t# Which word separators to exclude?\n\texclude=\"${1//[^$COMP_WORDBREAKS]}\"\n\tcword_=$COMP_CWORD\n\tif [ -z \"$exclude\" ]; then\n\t\twords_=(\"${COMP_WORDS[@]}\")\n\t\treturn\n\tfi\n\t# List of word completion separators has shrunk;\n\t# re-assemble words to complete.\n\tfor ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++)); do\n\t\t# Append each nonempty word consisting of just\n\t\t# word separator characters to the current word.\n\t\tfirst=t\n\t\twhile\n\t\t\t[ $i -gt 0 ] &&\n\t\t\t[ -n \"${COMP_WORDS[$i]}\" ] &&\n\t\t\t# word consists of excluded word separators\n\t\t\t[ \"${COMP_WORDS[$i]//[^$exclude]}\" = \"${COMP_WORDS[$i]}\" ]\n\t\tdo\n\t\t\t# Attach to the previous token,\n\t\t\t# unless the previous token is the command name.\n\t\t\tif [ $j -ge 2 ] && [ -n \"$first\" ]; then\n\t\t\t\t((j--))\n\t\t\tfi\n\t\t\tfirst=\n\t\t\twords_[$j]=${words_[j]}${COMP_WORDS[i]}\n\t\t\tif [ $i = $COMP_CWORD ]; then\n\t\t\t\tcword_=$j\n\t\t\tfi\n\t\t\tif (($i < ${#COMP_WORDS[@]} - 1)); then\n\t\t\t\t((i++))\n\t\t\telse\n\t\t\t\t# Done.\n\t\t\t\treturn\n\t\t\tfi\n\t\tdone\n\t\twords_[$j]=${words_[j]}${COMP_WORDS[i]}\n\t\tif [ $i = $COMP_CWORD ]; then\n\t\t\tcword_=$j\n\t\tfi\n\tdone\n}\n\n# Define preload_get_comp_words_by_ref=\"false\", if the function\n# __perf_get_comp_words_by_ref() is required instead.\npreload_get_comp_words_by_ref=\"true\"\n\nif [ $preload_get_comp_words_by_ref = \"true\" ]; then\n\ttype _get_comp_words_by_ref &>/dev/null ||\n\tpreload_get_comp_words_by_ref=\"false\"\nfi\n[ $preload_get_comp_words_by_ref = \"true\" ] ||\n__perf_get_comp_words_by_ref()\n{\n\tlocal exclude cur_ words_ cword_\n\tif [ \"$1\" = \"-n\" ]; then\n\t\texclude=$2\n\t\tshift 2\n\tfi\n\t__my_reassemble_comp_words_by_ref \"$exclude\"\n\tcur_=${words_[cword_]}\n\twhile [ $# -gt 0 ]; do\n\t\tcase \"$1\" in\n\t\tcur)\n\t\t\tcur=$cur_\n\t\t\t;;\n\t\tprev)\n\t\t\tprev=${words_[$cword_-1]}\n\t\t\t;;\n\t\twords)\n\t\t\twords=(\"${words_[@]}\")\n\t\t\t;;\n\t\tcword)\n\t\t\tcword=$cword_\n\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n}\n\n# Define preload__ltrim_colon_completions=\"false\", if the function\n# __perf__ltrim_colon_completions() is required instead.\npreload__ltrim_colon_completions=\"true\"\n\nif [ $preload__ltrim_colon_completions = \"true\" ]; then\n\ttype __ltrim_colon_completions &>/dev/null ||\n\tpreload__ltrim_colon_completions=\"false\"\nfi\n[ $preload__ltrim_colon_completions = \"true\" ] ||\n__perf__ltrim_colon_completions()\n{\n\tif [[ \"$1\" == *:* && \"$COMP_WORDBREAKS\" == *:* ]]; then\n\t\t# Remove colon-word prefix from COMPREPLY items\n\t\tlocal colon_word=${1%\"${1##*:}\"}\n\t\tlocal i=${#COMPREPLY[*]}\n\t\twhile [[ $((--i)) -ge 0 ]]; do\n\t\t\tCOMPREPLY[$i]=${COMPREPLY[$i]#\"$colon_word\"}\n\t\tdone\n\tfi\n}\n\n__perfcomp ()\n{\n\tCOMPREPLY=( $( compgen -W \"$1\" -- \"$2\" ) )\n}\n\n__perfcomp_colon ()\n{\n\t__perfcomp \"$1\" \"$2\"\n\tif [ $preload__ltrim_colon_completions = \"true\" ]; then\n\t\t__ltrim_colon_completions $cur\n\telse\n\t\t__perf__ltrim_colon_completions $cur\n\tfi\n}\n\n__perf_prev_skip_opts ()\n{\n\tlocal i cmd_ cmds_\n\n\tlet i=cword-1\n\tcmds_=$($cmd $1 --list-cmds)\n\tprev_skip_opts=()\n\twhile [ $i -ge 0 ]; do\n\t\tif [[ ${words[i]} == $1 ]]; then\n\t\t\treturn\n\t\tfi\n\t\tfor cmd_ in $cmds_; do\n\t\t\tif [[ ${words[i]} == $cmd_ ]]; then\n\t\t\t\tprev_skip_opts=${words[i]}\n\t\t\t\treturn\n\t\t\tfi\n\t\tdone\n\t\t((i--))\n\tdone\n}\n\n__perf_main ()\n{\n\tlocal cmd\n\n\tcmd=${words[0]}\n\tCOMPREPLY=()\n\n\t# Skip options backward and find the last perf command\n\t__perf_prev_skip_opts\n\t# List perf subcommands or long options\n\tif [ -z $prev_skip_opts ]; then\n\t\tif [[ $cur == --* ]]; then\n\t\t\tcmds=$($cmd --list-opts)\n\t\telse\n\t\t\tcmds=$($cmd --list-cmds)\n\t\tfi\n\t\t__perfcomp \"$cmds\" \"$cur\"\n\t# List possible events for -e option\n\telif [[ $prev == @(\"-e\"|\"--event\") &&\n\t\t$prev_skip_opts == @(record|stat|top) ]]; then\n\n\t\tlocal cur1=${COMP_WORDS[COMP_CWORD]}\n\t\tlocal raw_evts=$($cmd list --raw-dump)\n\t\tlocal arr s tmp result cpu_evts\n\n\t\t# aarch64 doesn't have /sys/bus/event_source/devices/cpu/events\n\t\tif [[ `uname -m` != aarch64 ]]; then\n\t\t\tcpu_evts=$(ls /sys/bus/event_source/devices/cpu/events)\n\t\tfi\n\n\t\tif [[ \"$cur1\" == */* && ${cur1#*/} =~ ^[A-Z] ]]; then\n\t\t\tOLD_IFS=\"$IFS\"\n\t\t\tIFS=\" \"\n\t\t\tarr=($raw_evts)\n\t\t\tIFS=\"$OLD_IFS\"\n\n\t\t\tfor s in ${arr[@]}\n\t\t\tdo\n\t\t\t\tif [[ \"$s\" == *cpu/* ]]; then\n\t\t\t\t\ttmp=${s#*cpu/}\n\t\t\t\t\tresult=$result\" \"\"cpu/\"${tmp^^}\n\t\t\t\telse\n\t\t\t\t\tresult=$result\" \"$s\n\t\t\t\tfi\n\t\t\tdone\n\n\t\t\tevts=${result}\" \"${cpu_evts}\n\t\telse\n\t\t\tevts=${raw_evts}\" \"${cpu_evts}\n\t\tfi\n\n\t\tif [[ \"$cur1\" == , ]]; then\n\t\t\t__perfcomp_colon \"$evts\" \"\"\n\t\telse\n\t\t\t__perfcomp_colon \"$evts\" \"$cur1\"\n\t\tfi\n\telse\n\t\t# List subcommands for perf commands\n\t\tif [[ $prev_skip_opts == @(kvm|kmem|mem|lock|sched|\n\t\t\t|data|help|script|test|timechart|trace) ]]; then\n\t\t\tsubcmds=$($cmd $prev_skip_opts --list-cmds)\n\t\t\t__perfcomp_colon \"$subcmds\" \"$cur\"\n\t\tfi\n\t\t# List long option names\n\t\tif [[ $cur == --* ]];  then\n\t\t\tsubcmd=$prev_skip_opts\n\t\t\t__perf_prev_skip_opts $subcmd\n\t\t\tsubcmd=$subcmd\" \"$prev_skip_opts\n\t\t\topts=$($cmd $subcmd --list-opts)\n\t\t\t__perfcomp \"$opts\" \"$cur\"\n\t\tfi\n\tfi\n}\n\nif [[ -n ${ZSH_VERSION-} ]]; then\n\tautoload -U +X compinit && compinit\n\n\t__perfcomp ()\n\t{\n\t\temulate -L zsh\n\n\t\tlocal c IFS=$' \\t\\n'\n\t\tlocal -a array\n\n\t\tfor c in ${=1}; do\n\t\t\tcase $c in\n\t\t\t--*=*|*.) ;;\n\t\t\t*) c=\"$c \" ;;\n\t\t\tesac\n\t\t\tarray[${#array[@]}+1]=\"$c\"\n\t\tdone\n\n\t\tcompset -P '*[=:]'\n\t\tcompadd -Q -S '' -a -- array && _ret=0\n\t}\n\n\t__perfcomp_colon ()\n\t{\n\t\temulate -L zsh\n\n\t\tlocal cur_=\"${2-$cur}\"\n\t\tlocal c IFS=$' \\t\\n'\n\t\tlocal -a array\n\n\t\tif [[ \"$cur_\" == *:* ]]; then\n\t\t\tlocal colon_word=${cur_%\"${cur_##*:}\"}\n\t\tfi\n\n\t\tfor c in ${=1}; do\n\t\t\tcase $c in\n\t\t\t--*=*|*.) ;;\n\t\t\t*) c=\"$c \" ;;\n\t\t\tesac\n\t\t\tarray[$#array+1]=${c#\"$colon_word\"}\n\t\tdone\n\n\t\tcompset -P '*[=:]'\n\t\tcompadd -Q -S '' -a -- array && _ret=0\n\t}\n\n\t_perf ()\n\t{\n\t\tlocal _ret=1 cur cword prev\n\t\tcur=${words[CURRENT]}\n\t\tprev=${words[CURRENT-1]}\n\t\tlet cword=CURRENT-1\n\t\temulate ksh -c __perf_main\n\t\tlet _ret && _default && _ret=0\n\t\treturn _ret\n\t}\n\n\tcompdef _perf perf\n\treturn\nfi\n\ntype perf &>/dev/null &&\n_perf()\n{\n\tif [[ \"$COMP_WORDBREAKS\" != *,* ]]; then\n\t\tCOMP_WORDBREAKS=\"${COMP_WORDBREAKS},\"\n\t\texport COMP_WORDBREAKS\n\tfi\n\n\tif [[ \"$COMP_WORDBREAKS\" == *:* ]]; then\n\t\tCOMP_WORDBREAKS=\"${COMP_WORDBREAKS/:/}\"\n\t\texport COMP_WORDBREAKS\n\tfi\n\n\tlocal cur words cword prev\n\tif [ $preload_get_comp_words_by_ref = \"true\" ]; then\n\t\t_get_comp_words_by_ref -n =:, cur words cword prev\n\telse\n\t\t__perf_get_comp_words_by_ref -n =:, cur words cword prev\n\tfi\n\t__perf_main\n} &&\n\ncomplete -o bashdefault -o default -o nospace -F _perf perf 2>/dev/null \\\n\t|| complete -o default -o nospace -F _perf perf\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}