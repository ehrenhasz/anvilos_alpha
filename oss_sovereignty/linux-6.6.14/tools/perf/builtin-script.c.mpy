{
  "module_name": "builtin-script.c",
  "hash_id": "f3cbcbdc07c2b5e37d76042a0f42e07d4b4f2a8f6671b359be33000a513f6cf2",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-script.c",
  "human_readable_source": "\n#include \"builtin.h\"\n\n#include \"util/counts.h\"\n#include \"util/debug.h\"\n#include \"util/dso.h\"\n#include <subcmd/exec-cmd.h>\n#include \"util/header.h\"\n#include <subcmd/parse-options.h>\n#include \"util/perf_regs.h\"\n#include \"util/session.h\"\n#include \"util/tool.h\"\n#include \"util/map.h\"\n#include \"util/srcline.h\"\n#include \"util/symbol.h\"\n#include \"util/thread.h\"\n#include \"util/trace-event.h\"\n#include \"util/env.h\"\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/evsel_fprintf.h\"\n#include \"util/evswitch.h\"\n#include \"util/sort.h\"\n#include \"util/data.h\"\n#include \"util/auxtrace.h\"\n#include \"util/cpumap.h\"\n#include \"util/thread_map.h\"\n#include \"util/stat.h\"\n#include \"util/color.h\"\n#include \"util/string2.h\"\n#include \"util/thread-stack.h\"\n#include \"util/time-utils.h\"\n#include \"util/path.h\"\n#include \"util/event.h\"\n#include \"ui/ui.h\"\n#include \"print_binary.h\"\n#include \"archinsn.h\"\n#include <linux/bitmap.h>\n#include <linux/kernel.h>\n#include <linux/stringify.h>\n#include <linux/time64.h>\n#include <linux/zalloc.h>\n#include <sys/utsname.h>\n#include \"asm/bug.h\"\n#include \"util/mem-events.h\"\n#include \"util/dump-insn.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <subcmd/pager.h>\n#include <perf/evlist.h>\n#include <linux/err.h>\n#include \"util/dlfilter.h\"\n#include \"util/record.h\"\n#include \"util/util.h\"\n#include \"util/cgroup.h\"\n#include \"perf.h\"\n\n#include <linux/ctype.h>\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#endif\n\nstatic char const\t\t*script_name;\nstatic char const\t\t*generate_script_lang;\nstatic bool\t\t\treltime;\nstatic bool\t\t\tdeltatime;\nstatic u64\t\t\tinitial_time;\nstatic u64\t\t\tprevious_time;\nstatic bool\t\t\tdebug_mode;\nstatic u64\t\t\tlast_timestamp;\nstatic u64\t\t\tnr_unordered;\nstatic bool\t\t\tno_callchain;\nstatic bool\t\t\tlatency_format;\nstatic bool\t\t\tsystem_wide;\nstatic bool\t\t\tprint_flags;\nstatic const char\t\t*cpu_list;\nstatic DECLARE_BITMAP(cpu_bitmap, MAX_NR_CPUS);\nstatic struct perf_stat_config\tstat_config;\nstatic int\t\t\tmax_blocks;\nstatic bool\t\t\tnative_arch;\nstatic struct dlfilter\t\t*dlfilter;\nstatic int\t\t\tdlargc;\nstatic char\t\t\t**dlargv;\n\nunsigned int scripting_max_stack = PERF_MAX_STACK_DEPTH;\n\nenum perf_output_field {\n\tPERF_OUTPUT_COMM            = 1ULL << 0,\n\tPERF_OUTPUT_TID             = 1ULL << 1,\n\tPERF_OUTPUT_PID             = 1ULL << 2,\n\tPERF_OUTPUT_TIME            = 1ULL << 3,\n\tPERF_OUTPUT_CPU             = 1ULL << 4,\n\tPERF_OUTPUT_EVNAME          = 1ULL << 5,\n\tPERF_OUTPUT_TRACE           = 1ULL << 6,\n\tPERF_OUTPUT_IP              = 1ULL << 7,\n\tPERF_OUTPUT_SYM             = 1ULL << 8,\n\tPERF_OUTPUT_DSO             = 1ULL << 9,\n\tPERF_OUTPUT_ADDR            = 1ULL << 10,\n\tPERF_OUTPUT_SYMOFFSET       = 1ULL << 11,\n\tPERF_OUTPUT_SRCLINE         = 1ULL << 12,\n\tPERF_OUTPUT_PERIOD          = 1ULL << 13,\n\tPERF_OUTPUT_IREGS\t    = 1ULL << 14,\n\tPERF_OUTPUT_BRSTACK\t    = 1ULL << 15,\n\tPERF_OUTPUT_BRSTACKSYM\t    = 1ULL << 16,\n\tPERF_OUTPUT_DATA_SRC\t    = 1ULL << 17,\n\tPERF_OUTPUT_WEIGHT\t    = 1ULL << 18,\n\tPERF_OUTPUT_BPF_OUTPUT\t    = 1ULL << 19,\n\tPERF_OUTPUT_CALLINDENT\t    = 1ULL << 20,\n\tPERF_OUTPUT_INSN\t    = 1ULL << 21,\n\tPERF_OUTPUT_INSNLEN\t    = 1ULL << 22,\n\tPERF_OUTPUT_BRSTACKINSN\t    = 1ULL << 23,\n\tPERF_OUTPUT_BRSTACKOFF\t    = 1ULL << 24,\n\tPERF_OUTPUT_SYNTH           = 1ULL << 25,\n\tPERF_OUTPUT_PHYS_ADDR       = 1ULL << 26,\n\tPERF_OUTPUT_UREGS\t    = 1ULL << 27,\n\tPERF_OUTPUT_METRIC\t    = 1ULL << 28,\n\tPERF_OUTPUT_MISC            = 1ULL << 29,\n\tPERF_OUTPUT_SRCCODE\t    = 1ULL << 30,\n\tPERF_OUTPUT_IPC             = 1ULL << 31,\n\tPERF_OUTPUT_TOD             = 1ULL << 32,\n\tPERF_OUTPUT_DATA_PAGE_SIZE  = 1ULL << 33,\n\tPERF_OUTPUT_CODE_PAGE_SIZE  = 1ULL << 34,\n\tPERF_OUTPUT_INS_LAT         = 1ULL << 35,\n\tPERF_OUTPUT_BRSTACKINSNLEN  = 1ULL << 36,\n\tPERF_OUTPUT_MACHINE_PID     = 1ULL << 37,\n\tPERF_OUTPUT_VCPU            = 1ULL << 38,\n\tPERF_OUTPUT_CGROUP          = 1ULL << 39,\n\tPERF_OUTPUT_RETIRE_LAT      = 1ULL << 40,\n\tPERF_OUTPUT_DSOFF           = 1ULL << 41,\n};\n\nstruct perf_script {\n\tstruct perf_tool\ttool;\n\tstruct perf_session\t*session;\n\tbool\t\t\tshow_task_events;\n\tbool\t\t\tshow_mmap_events;\n\tbool\t\t\tshow_switch_events;\n\tbool\t\t\tshow_namespace_events;\n\tbool\t\t\tshow_lost_events;\n\tbool\t\t\tshow_round_events;\n\tbool\t\t\tshow_bpf_events;\n\tbool\t\t\tshow_cgroup_events;\n\tbool\t\t\tshow_text_poke_events;\n\tbool\t\t\tallocated;\n\tbool\t\t\tper_event_dump;\n\tbool\t\t\tstitch_lbr;\n\tstruct evswitch\t\tevswitch;\n\tstruct perf_cpu_map\t*cpus;\n\tstruct perf_thread_map *threads;\n\tint\t\t\tname_width;\n\tconst char              *time_str;\n\tstruct perf_time_interval *ptime_range;\n\tint\t\t\trange_size;\n\tint\t\t\trange_num;\n};\n\nstruct output_option {\n\tconst char *str;\n\tenum perf_output_field field;\n} all_output_options[] = {\n\t{.str = \"comm\",  .field = PERF_OUTPUT_COMM},\n\t{.str = \"tid\",   .field = PERF_OUTPUT_TID},\n\t{.str = \"pid\",   .field = PERF_OUTPUT_PID},\n\t{.str = \"time\",  .field = PERF_OUTPUT_TIME},\n\t{.str = \"cpu\",   .field = PERF_OUTPUT_CPU},\n\t{.str = \"event\", .field = PERF_OUTPUT_EVNAME},\n\t{.str = \"trace\", .field = PERF_OUTPUT_TRACE},\n\t{.str = \"ip\",    .field = PERF_OUTPUT_IP},\n\t{.str = \"sym\",   .field = PERF_OUTPUT_SYM},\n\t{.str = \"dso\",   .field = PERF_OUTPUT_DSO},\n\t{.str = \"dsoff\", .field = PERF_OUTPUT_DSOFF},\n\t{.str = \"addr\",  .field = PERF_OUTPUT_ADDR},\n\t{.str = \"symoff\", .field = PERF_OUTPUT_SYMOFFSET},\n\t{.str = \"srcline\", .field = PERF_OUTPUT_SRCLINE},\n\t{.str = \"period\", .field = PERF_OUTPUT_PERIOD},\n\t{.str = \"iregs\", .field = PERF_OUTPUT_IREGS},\n\t{.str = \"uregs\", .field = PERF_OUTPUT_UREGS},\n\t{.str = \"brstack\", .field = PERF_OUTPUT_BRSTACK},\n\t{.str = \"brstacksym\", .field = PERF_OUTPUT_BRSTACKSYM},\n\t{.str = \"data_src\", .field = PERF_OUTPUT_DATA_SRC},\n\t{.str = \"weight\",   .field = PERF_OUTPUT_WEIGHT},\n\t{.str = \"bpf-output\",   .field = PERF_OUTPUT_BPF_OUTPUT},\n\t{.str = \"callindent\", .field = PERF_OUTPUT_CALLINDENT},\n\t{.str = \"insn\", .field = PERF_OUTPUT_INSN},\n\t{.str = \"insnlen\", .field = PERF_OUTPUT_INSNLEN},\n\t{.str = \"brstackinsn\", .field = PERF_OUTPUT_BRSTACKINSN},\n\t{.str = \"brstackoff\", .field = PERF_OUTPUT_BRSTACKOFF},\n\t{.str = \"synth\", .field = PERF_OUTPUT_SYNTH},\n\t{.str = \"phys_addr\", .field = PERF_OUTPUT_PHYS_ADDR},\n\t{.str = \"metric\", .field = PERF_OUTPUT_METRIC},\n\t{.str = \"misc\", .field = PERF_OUTPUT_MISC},\n\t{.str = \"srccode\", .field = PERF_OUTPUT_SRCCODE},\n\t{.str = \"ipc\", .field = PERF_OUTPUT_IPC},\n\t{.str = \"tod\", .field = PERF_OUTPUT_TOD},\n\t{.str = \"data_page_size\", .field = PERF_OUTPUT_DATA_PAGE_SIZE},\n\t{.str = \"code_page_size\", .field = PERF_OUTPUT_CODE_PAGE_SIZE},\n\t{.str = \"ins_lat\", .field = PERF_OUTPUT_INS_LAT},\n\t{.str = \"brstackinsnlen\", .field = PERF_OUTPUT_BRSTACKINSNLEN},\n\t{.str = \"machine_pid\", .field = PERF_OUTPUT_MACHINE_PID},\n\t{.str = \"vcpu\", .field = PERF_OUTPUT_VCPU},\n\t{.str = \"cgroup\", .field = PERF_OUTPUT_CGROUP},\n\t{.str = \"retire_lat\", .field = PERF_OUTPUT_RETIRE_LAT},\n};\n\nenum {\n\tOUTPUT_TYPE_SYNTH = PERF_TYPE_MAX,\n\tOUTPUT_TYPE_OTHER,\n\tOUTPUT_TYPE_MAX\n};\n\n \nstatic struct {\n\tbool user_set;\n\tbool wildcard_set;\n\tunsigned int print_ip_opts;\n\tu64 fields;\n\tu64 invalid_fields;\n\tu64 user_set_fields;\n\tu64 user_unset_fields;\n} output[OUTPUT_TYPE_MAX] = {\n\n\t[PERF_TYPE_HARDWARE] = {\n\t\t.user_set = false,\n\n\t\t.fields = PERF_OUTPUT_COMM | PERF_OUTPUT_TID |\n\t\t\t      PERF_OUTPUT_CPU | PERF_OUTPUT_TIME |\n\t\t\t      PERF_OUTPUT_EVNAME | PERF_OUTPUT_IP |\n\t\t\t      PERF_OUTPUT_SYM | PERF_OUTPUT_SYMOFFSET |\n\t\t\t      PERF_OUTPUT_DSO | PERF_OUTPUT_PERIOD,\n\n\t\t.invalid_fields = PERF_OUTPUT_TRACE | PERF_OUTPUT_BPF_OUTPUT,\n\t},\n\n\t[PERF_TYPE_SOFTWARE] = {\n\t\t.user_set = false,\n\n\t\t.fields = PERF_OUTPUT_COMM | PERF_OUTPUT_TID |\n\t\t\t      PERF_OUTPUT_CPU | PERF_OUTPUT_TIME |\n\t\t\t      PERF_OUTPUT_EVNAME | PERF_OUTPUT_IP |\n\t\t\t      PERF_OUTPUT_SYM | PERF_OUTPUT_SYMOFFSET |\n\t\t\t      PERF_OUTPUT_DSO | PERF_OUTPUT_PERIOD |\n\t\t\t      PERF_OUTPUT_BPF_OUTPUT,\n\n\t\t.invalid_fields = PERF_OUTPUT_TRACE,\n\t},\n\n\t[PERF_TYPE_TRACEPOINT] = {\n\t\t.user_set = false,\n\n\t\t.fields = PERF_OUTPUT_COMM | PERF_OUTPUT_TID |\n\t\t\t\t  PERF_OUTPUT_CPU | PERF_OUTPUT_TIME |\n\t\t\t\t  PERF_OUTPUT_EVNAME | PERF_OUTPUT_TRACE\n\t},\n\n\t[PERF_TYPE_HW_CACHE] = {\n\t\t.user_set = false,\n\n\t\t.fields = PERF_OUTPUT_COMM | PERF_OUTPUT_TID |\n\t\t\t      PERF_OUTPUT_CPU | PERF_OUTPUT_TIME |\n\t\t\t      PERF_OUTPUT_EVNAME | PERF_OUTPUT_IP |\n\t\t\t      PERF_OUTPUT_SYM | PERF_OUTPUT_SYMOFFSET |\n\t\t\t      PERF_OUTPUT_DSO | PERF_OUTPUT_PERIOD,\n\n\t\t.invalid_fields = PERF_OUTPUT_TRACE | PERF_OUTPUT_BPF_OUTPUT,\n\t},\n\n\t[PERF_TYPE_RAW] = {\n\t\t.user_set = false,\n\n\t\t.fields = PERF_OUTPUT_COMM | PERF_OUTPUT_TID |\n\t\t\t      PERF_OUTPUT_CPU | PERF_OUTPUT_TIME |\n\t\t\t      PERF_OUTPUT_EVNAME | PERF_OUTPUT_IP |\n\t\t\t      PERF_OUTPUT_SYM | PERF_OUTPUT_SYMOFFSET |\n\t\t\t      PERF_OUTPUT_DSO | PERF_OUTPUT_PERIOD |\n\t\t\t      PERF_OUTPUT_ADDR | PERF_OUTPUT_DATA_SRC |\n\t\t\t      PERF_OUTPUT_WEIGHT | PERF_OUTPUT_PHYS_ADDR |\n\t\t\t      PERF_OUTPUT_DATA_PAGE_SIZE | PERF_OUTPUT_CODE_PAGE_SIZE |\n\t\t\t      PERF_OUTPUT_INS_LAT | PERF_OUTPUT_RETIRE_LAT,\n\n\t\t.invalid_fields = PERF_OUTPUT_TRACE | PERF_OUTPUT_BPF_OUTPUT,\n\t},\n\n\t[PERF_TYPE_BREAKPOINT] = {\n\t\t.user_set = false,\n\n\t\t.fields = PERF_OUTPUT_COMM | PERF_OUTPUT_TID |\n\t\t\t      PERF_OUTPUT_CPU | PERF_OUTPUT_TIME |\n\t\t\t      PERF_OUTPUT_EVNAME | PERF_OUTPUT_IP |\n\t\t\t      PERF_OUTPUT_SYM | PERF_OUTPUT_SYMOFFSET |\n\t\t\t      PERF_OUTPUT_DSO | PERF_OUTPUT_PERIOD,\n\n\t\t.invalid_fields = PERF_OUTPUT_TRACE | PERF_OUTPUT_BPF_OUTPUT,\n\t},\n\n\t[OUTPUT_TYPE_SYNTH] = {\n\t\t.user_set = false,\n\n\t\t.fields = PERF_OUTPUT_COMM | PERF_OUTPUT_TID |\n\t\t\t      PERF_OUTPUT_CPU | PERF_OUTPUT_TIME |\n\t\t\t      PERF_OUTPUT_EVNAME | PERF_OUTPUT_IP |\n\t\t\t      PERF_OUTPUT_SYM | PERF_OUTPUT_SYMOFFSET |\n\t\t\t      PERF_OUTPUT_DSO | PERF_OUTPUT_SYNTH,\n\n\t\t.invalid_fields = PERF_OUTPUT_TRACE | PERF_OUTPUT_BPF_OUTPUT,\n\t},\n\n\t[OUTPUT_TYPE_OTHER] = {\n\t\t.user_set = false,\n\n\t\t.fields = PERF_OUTPUT_COMM | PERF_OUTPUT_TID |\n\t\t\t      PERF_OUTPUT_CPU | PERF_OUTPUT_TIME |\n\t\t\t      PERF_OUTPUT_EVNAME | PERF_OUTPUT_IP |\n\t\t\t      PERF_OUTPUT_SYM | PERF_OUTPUT_SYMOFFSET |\n\t\t\t      PERF_OUTPUT_DSO | PERF_OUTPUT_PERIOD,\n\n\t\t.invalid_fields = PERF_OUTPUT_TRACE | PERF_OUTPUT_BPF_OUTPUT,\n\t},\n};\n\nstruct evsel_script {\n       char *filename;\n       FILE *fp;\n       u64  samples;\n        \n       u64  val;\n       int  gnum;\n};\n\nstatic inline struct evsel_script *evsel_script(struct evsel *evsel)\n{\n\treturn (struct evsel_script *)evsel->priv;\n}\n\nstatic struct evsel_script *evsel_script__new(struct evsel *evsel, struct perf_data *data)\n{\n\tstruct evsel_script *es = zalloc(sizeof(*es));\n\n\tif (es != NULL) {\n\t\tif (asprintf(&es->filename, \"%s.%s.dump\", data->file.path, evsel__name(evsel)) < 0)\n\t\t\tgoto out_free;\n\t\tes->fp = fopen(es->filename, \"w\");\n\t\tif (es->fp == NULL)\n\t\t\tgoto out_free_filename;\n\t}\n\n\treturn es;\nout_free_filename:\n\tzfree(&es->filename);\nout_free:\n\tfree(es);\n\treturn NULL;\n}\n\nstatic void evsel_script__delete(struct evsel_script *es)\n{\n\tzfree(&es->filename);\n\tfclose(es->fp);\n\tes->fp = NULL;\n\tfree(es);\n}\n\nstatic int evsel_script__fprintf(struct evsel_script *es, FILE *fp)\n{\n\tstruct stat st;\n\n\tfstat(fileno(es->fp), &st);\n\treturn fprintf(fp, \"[ perf script: Wrote %.3f MB %s (%\" PRIu64 \" samples) ]\\n\",\n\t\t       st.st_size / 1024.0 / 1024.0, es->filename, es->samples);\n}\n\nstatic inline int output_type(unsigned int type)\n{\n\tswitch (type) {\n\tcase PERF_TYPE_SYNTH:\n\t\treturn OUTPUT_TYPE_SYNTH;\n\tdefault:\n\t\tif (type < PERF_TYPE_MAX)\n\t\t\treturn type;\n\t}\n\n\treturn OUTPUT_TYPE_OTHER;\n}\n\nstatic bool output_set_by_user(void)\n{\n\tint j;\n\tfor (j = 0; j < OUTPUT_TYPE_MAX; ++j) {\n\t\tif (output[j].user_set)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const char *output_field2str(enum perf_output_field field)\n{\n\tint i, imax = ARRAY_SIZE(all_output_options);\n\tconst char *str = \"\";\n\n\tfor (i = 0; i < imax; ++i) {\n\t\tif (all_output_options[i].field == field) {\n\t\t\tstr = all_output_options[i].str;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\n#define PRINT_FIELD(x)  (output[output_type(attr->type)].fields & PERF_OUTPUT_##x)\n\nstatic int evsel__do_check_stype(struct evsel *evsel, u64 sample_type, const char *sample_msg,\n\t\t\t\t enum perf_output_field field, bool allow_user_set)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tint type = output_type(attr->type);\n\tconst char *evname;\n\n\tif (attr->sample_type & sample_type)\n\t\treturn 0;\n\n\tif (output[type].user_set_fields & field) {\n\t\tif (allow_user_set)\n\t\t\treturn 0;\n\t\tevname = evsel__name(evsel);\n\t\tpr_err(\"Samples for '%s' event do not have %s attribute set. \"\n\t\t       \"Cannot print '%s' field.\\n\",\n\t\t       evname, sample_msg, output_field2str(field));\n\t\treturn -1;\n\t}\n\n\t \n\toutput[type].fields &= ~field;\n\tevname = evsel__name(evsel);\n\tpr_debug(\"Samples for '%s' event do not have %s attribute set. \"\n\t\t \"Skipping '%s' field.\\n\",\n\t\t evname, sample_msg, output_field2str(field));\n\n\treturn 0;\n}\n\nstatic int evsel__check_stype(struct evsel *evsel, u64 sample_type, const char *sample_msg,\n\t\t\t      enum perf_output_field field)\n{\n\treturn evsel__do_check_stype(evsel, sample_type, sample_msg, field, false);\n}\n\nstatic int evsel__check_attr(struct evsel *evsel, struct perf_session *session)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tbool allow_user_set;\n\n\tif (evsel__is_dummy_event(evsel))\n\t\treturn 0;\n\n\tif (perf_header__has_feat(&session->header, HEADER_STAT))\n\t\treturn 0;\n\n\tallow_user_set = perf_header__has_feat(&session->header,\n\t\t\t\t\t       HEADER_AUXTRACE);\n\n\tif (PRINT_FIELD(TRACE) &&\n\t    !perf_session__has_traces(session, \"record -R\"))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(IP)) {\n\t\tif (evsel__check_stype(evsel, PERF_SAMPLE_IP, \"IP\", PERF_OUTPUT_IP))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (PRINT_FIELD(ADDR) &&\n\t    evsel__do_check_stype(evsel, PERF_SAMPLE_ADDR, \"ADDR\", PERF_OUTPUT_ADDR, allow_user_set))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(DATA_SRC) &&\n\t    evsel__do_check_stype(evsel, PERF_SAMPLE_DATA_SRC, \"DATA_SRC\", PERF_OUTPUT_DATA_SRC, allow_user_set))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(WEIGHT) &&\n\t    evsel__do_check_stype(evsel, PERF_SAMPLE_WEIGHT_TYPE, \"WEIGHT\", PERF_OUTPUT_WEIGHT, allow_user_set))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(SYM) &&\n\t    !(evsel->core.attr.sample_type & (PERF_SAMPLE_IP|PERF_SAMPLE_ADDR))) {\n\t\tpr_err(\"Display of symbols requested but neither sample IP nor \"\n\t\t\t   \"sample address\\navailable. Hence, no addresses to convert \"\n\t\t       \"to symbols.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (PRINT_FIELD(SYMOFFSET) && !PRINT_FIELD(SYM)) {\n\t\tpr_err(\"Display of offsets requested but symbol is not\"\n\t\t       \"selected.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (PRINT_FIELD(DSO) &&\n\t    !(evsel->core.attr.sample_type & (PERF_SAMPLE_IP|PERF_SAMPLE_ADDR))) {\n\t\tpr_err(\"Display of DSO requested but no address to convert.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((PRINT_FIELD(SRCLINE) || PRINT_FIELD(SRCCODE)) && !PRINT_FIELD(IP)) {\n\t\tpr_err(\"Display of source line number requested but sample IP is not\\n\"\n\t\t       \"selected. Hence, no address to lookup the source line number.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((PRINT_FIELD(BRSTACKINSN) || PRINT_FIELD(BRSTACKINSNLEN)) && !allow_user_set &&\n\t    !(evlist__combined_branch_type(session->evlist) & PERF_SAMPLE_BRANCH_ANY)) {\n\t\tpr_err(\"Display of branch stack assembler requested, but non all-branch filter set\\n\"\n\t\t       \"Hint: run 'perf record -b ...'\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((PRINT_FIELD(PID) || PRINT_FIELD(TID)) &&\n\t    evsel__check_stype(evsel, PERF_SAMPLE_TID, \"TID\", PERF_OUTPUT_TID|PERF_OUTPUT_PID))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(TIME) &&\n\t    evsel__check_stype(evsel, PERF_SAMPLE_TIME, \"TIME\", PERF_OUTPUT_TIME))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(CPU) &&\n\t    evsel__do_check_stype(evsel, PERF_SAMPLE_CPU, \"CPU\", PERF_OUTPUT_CPU, allow_user_set))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(IREGS) &&\n\t    evsel__do_check_stype(evsel, PERF_SAMPLE_REGS_INTR, \"IREGS\", PERF_OUTPUT_IREGS, allow_user_set))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(UREGS) &&\n\t    evsel__check_stype(evsel, PERF_SAMPLE_REGS_USER, \"UREGS\", PERF_OUTPUT_UREGS))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(PHYS_ADDR) &&\n\t    evsel__do_check_stype(evsel, PERF_SAMPLE_PHYS_ADDR, \"PHYS_ADDR\", PERF_OUTPUT_PHYS_ADDR, allow_user_set))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(DATA_PAGE_SIZE) &&\n\t    evsel__check_stype(evsel, PERF_SAMPLE_DATA_PAGE_SIZE, \"DATA_PAGE_SIZE\", PERF_OUTPUT_DATA_PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(CODE_PAGE_SIZE) &&\n\t    evsel__check_stype(evsel, PERF_SAMPLE_CODE_PAGE_SIZE, \"CODE_PAGE_SIZE\", PERF_OUTPUT_CODE_PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(INS_LAT) &&\n\t    evsel__check_stype(evsel, PERF_SAMPLE_WEIGHT_STRUCT, \"WEIGHT_STRUCT\", PERF_OUTPUT_INS_LAT))\n\t\treturn -EINVAL;\n\n\tif (PRINT_FIELD(CGROUP) &&\n\t    evsel__check_stype(evsel, PERF_SAMPLE_CGROUP, \"CGROUP\", PERF_OUTPUT_CGROUP)) {\n\t\tpr_err(\"Hint: run 'perf record --all-cgroups ...'\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (PRINT_FIELD(RETIRE_LAT) &&\n\t    evsel__check_stype(evsel, PERF_SAMPLE_WEIGHT_STRUCT, \"WEIGHT_STRUCT\", PERF_OUTPUT_RETIRE_LAT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void set_print_ip_opts(struct perf_event_attr *attr)\n{\n\tunsigned int type = output_type(attr->type);\n\n\toutput[type].print_ip_opts = 0;\n\tif (PRINT_FIELD(IP))\n\t\toutput[type].print_ip_opts |= EVSEL__PRINT_IP;\n\n\tif (PRINT_FIELD(SYM))\n\t\toutput[type].print_ip_opts |= EVSEL__PRINT_SYM;\n\n\tif (PRINT_FIELD(DSO))\n\t\toutput[type].print_ip_opts |= EVSEL__PRINT_DSO;\n\n\tif (PRINT_FIELD(DSOFF))\n\t\toutput[type].print_ip_opts |= EVSEL__PRINT_DSOFF;\n\n\tif (PRINT_FIELD(SYMOFFSET))\n\t\toutput[type].print_ip_opts |= EVSEL__PRINT_SYMOFFSET;\n\n\tif (PRINT_FIELD(SRCLINE))\n\t\toutput[type].print_ip_opts |= EVSEL__PRINT_SRCLINE;\n}\n\nstatic struct evsel *find_first_output_type(struct evlist *evlist,\n\t\t\t\t\t    unsigned int type)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel__is_dummy_event(evsel))\n\t\t\tcontinue;\n\t\tif (output_type(evsel->core.attr.type) == (int)type)\n\t\t\treturn evsel;\n\t}\n\treturn NULL;\n}\n\n \nstatic int perf_session__check_output_opt(struct perf_session *session)\n{\n\tbool tod = false;\n\tunsigned int j;\n\tstruct evsel *evsel;\n\n\tfor (j = 0; j < OUTPUT_TYPE_MAX; ++j) {\n\t\tevsel = find_first_output_type(session->evlist, j);\n\n\t\t \n\t\tif (!evsel && output[j].user_set && !output[j].wildcard_set &&\n\t\t    j != OUTPUT_TYPE_SYNTH) {\n\t\t\tpr_err(\"%s events do not exist. \"\n\t\t\t       \"Remove corresponding -F option to proceed.\\n\",\n\t\t\t       event_type(j));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (evsel && output[j].fields &&\n\t\t\tevsel__check_attr(evsel, session))\n\t\t\treturn -1;\n\n\t\tif (evsel == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (output[j].fields & PERF_OUTPUT_DSOFF)\n\t\t\toutput[j].fields |= PERF_OUTPUT_DSO;\n\n\t\tset_print_ip_opts(&evsel->core.attr);\n\t\ttod |= output[j].fields & PERF_OUTPUT_TOD;\n\t}\n\n\tif (!no_callchain) {\n\t\tbool use_callchain = false;\n\t\tbool not_pipe = false;\n\n\t\tevlist__for_each_entry(session->evlist, evsel) {\n\t\t\tnot_pipe = true;\n\t\t\tif (evsel__has_callchain(evsel)) {\n\t\t\t\tuse_callchain = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (not_pipe && !use_callchain)\n\t\t\tsymbol_conf.use_callchain = false;\n\t}\n\n\t \n\tif (symbol_conf.use_callchain &&\n\t    !output[PERF_TYPE_TRACEPOINT].user_set) {\n\t\tj = PERF_TYPE_TRACEPOINT;\n\n\t\tevlist__for_each_entry(session->evlist, evsel) {\n\t\t\tif (evsel->core.attr.type != j)\n\t\t\t\tcontinue;\n\n\t\t\tif (evsel__has_callchain(evsel)) {\n\t\t\t\toutput[j].fields |= PERF_OUTPUT_IP;\n\t\t\t\toutput[j].fields |= PERF_OUTPUT_SYM;\n\t\t\t\toutput[j].fields |= PERF_OUTPUT_SYMOFFSET;\n\t\t\t\toutput[j].fields |= PERF_OUTPUT_DSO;\n\t\t\t\tset_print_ip_opts(&evsel->core.attr);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tod && !session->header.env.clock.enabled) {\n\t\tpr_err(\"Can't provide 'tod' time, missing clock data. \"\n\t\t       \"Please record with -k/--clockid option.\\n\");\n\t\treturn -1;\n\t}\nout:\n\treturn 0;\n}\n\nstatic int perf_sample__fprintf_regs(struct regs_dump *regs, uint64_t mask, const char *arch,\n\t\t\t\t     FILE *fp)\n{\n\tunsigned i = 0, r;\n\tint printed = 0;\n\n\tif (!regs || !regs->regs)\n\t\treturn 0;\n\n\tprinted += fprintf(fp, \" ABI:%\" PRIu64 \" \", regs->abi);\n\n\tfor_each_set_bit(r, (unsigned long *) &mask, sizeof(mask) * 8) {\n\t\tu64 val = regs->regs[i++];\n\t\tprinted += fprintf(fp, \"%5s:0x%\"PRIx64\" \", perf_reg_name(r, arch), val);\n\t}\n\n\treturn printed;\n}\n\n#define DEFAULT_TOD_FMT \"%F %H:%M:%S\"\n\nstatic char*\ntod_scnprintf(struct perf_script *script, char *buf, int buflen,\n\t     u64 timestamp)\n{\n\tu64 tod_ns, clockid_ns;\n\tstruct perf_env *env;\n\tunsigned long nsec;\n\tstruct tm ltime;\n\tchar date[64];\n\ttime_t sec;\n\n\tbuf[0] = '\\0';\n\tif (buflen < 64 || !script)\n\t\treturn buf;\n\n\tenv = &script->session->header.env;\n\tif (!env->clock.enabled) {\n\t\tscnprintf(buf, buflen, \"disabled\");\n\t\treturn buf;\n\t}\n\n\tclockid_ns = env->clock.clockid_ns;\n\ttod_ns     = env->clock.tod_ns;\n\n\tif (timestamp > clockid_ns)\n\t\ttod_ns += timestamp - clockid_ns;\n\telse\n\t\ttod_ns -= clockid_ns - timestamp;\n\n\tsec  = (time_t) (tod_ns / NSEC_PER_SEC);\n\tnsec = tod_ns - sec * NSEC_PER_SEC;\n\n\tif (localtime_r(&sec, &ltime) == NULL) {\n\t\tscnprintf(buf, buflen, \"failed\");\n\t} else {\n\t\tstrftime(date, sizeof(date), DEFAULT_TOD_FMT, &ltime);\n\n\t\tif (symbol_conf.nanosecs) {\n\t\t\tsnprintf(buf, buflen, \"%s.%09lu\", date, nsec);\n\t\t} else {\n\t\t\tsnprintf(buf, buflen, \"%s.%06lu\",\n\t\t\t\t date, nsec / NSEC_PER_USEC);\n\t\t}\n\t}\n\n\treturn buf;\n}\n\nstatic int perf_sample__fprintf_iregs(struct perf_sample *sample,\n\t\t\t\t      struct perf_event_attr *attr, const char *arch, FILE *fp)\n{\n\treturn perf_sample__fprintf_regs(&sample->intr_regs,\n\t\t\t\t\t attr->sample_regs_intr, arch, fp);\n}\n\nstatic int perf_sample__fprintf_uregs(struct perf_sample *sample,\n\t\t\t\t      struct perf_event_attr *attr, const char *arch, FILE *fp)\n{\n\treturn perf_sample__fprintf_regs(&sample->user_regs,\n\t\t\t\t\t attr->sample_regs_user, arch, fp);\n}\n\nstatic int perf_sample__fprintf_start(struct perf_script *script,\n\t\t\t\t      struct perf_sample *sample,\n\t\t\t\t      struct thread *thread,\n\t\t\t\t      struct evsel *evsel,\n\t\t\t\t      u32 type, FILE *fp)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tunsigned long secs;\n\tunsigned long long nsecs;\n\tint printed = 0;\n\tchar tstr[128];\n\n\tif (PRINT_FIELD(MACHINE_PID) && sample->machine_pid)\n\t\tprinted += fprintf(fp, \"VM:%5d \", sample->machine_pid);\n\n\t \n\tif (PRINT_FIELD(VCPU) && sample->machine_pid)\n\t\tprinted += fprintf(fp, \"VCPU:%03d \", sample->vcpu);\n\n\tif (PRINT_FIELD(COMM)) {\n\t\tconst char *comm = thread ? thread__comm_str(thread) : \":-1\";\n\n\t\tif (latency_format)\n\t\t\tprinted += fprintf(fp, \"%8.8s \", comm);\n\t\telse if (PRINT_FIELD(IP) && evsel__has_callchain(evsel) && symbol_conf.use_callchain)\n\t\t\tprinted += fprintf(fp, \"%s \", comm);\n\t\telse\n\t\t\tprinted += fprintf(fp, \"%16s \", comm);\n\t}\n\n\tif (PRINT_FIELD(PID) && PRINT_FIELD(TID))\n\t\tprinted += fprintf(fp, \"%7d/%-7d \", sample->pid, sample->tid);\n\telse if (PRINT_FIELD(PID))\n\t\tprinted += fprintf(fp, \"%7d \", sample->pid);\n\telse if (PRINT_FIELD(TID))\n\t\tprinted += fprintf(fp, \"%7d \", sample->tid);\n\n\tif (PRINT_FIELD(CPU)) {\n\t\tif (latency_format)\n\t\t\tprinted += fprintf(fp, \"%3d \", sample->cpu);\n\t\telse\n\t\t\tprinted += fprintf(fp, \"[%03d] \", sample->cpu);\n\t}\n\n\tif (PRINT_FIELD(MISC)) {\n\t\tint ret = 0;\n\n\t\t#define has(m) \\\n\t\t\t(sample->misc & PERF_RECORD_MISC_##m) == PERF_RECORD_MISC_##m\n\n\t\tif (has(KERNEL))\n\t\t\tret += fprintf(fp, \"K\");\n\t\tif (has(USER))\n\t\t\tret += fprintf(fp, \"U\");\n\t\tif (has(HYPERVISOR))\n\t\t\tret += fprintf(fp, \"H\");\n\t\tif (has(GUEST_KERNEL))\n\t\t\tret += fprintf(fp, \"G\");\n\t\tif (has(GUEST_USER))\n\t\t\tret += fprintf(fp, \"g\");\n\n\t\tswitch (type) {\n\t\tcase PERF_RECORD_MMAP:\n\t\tcase PERF_RECORD_MMAP2:\n\t\t\tif (has(MMAP_DATA))\n\t\t\t\tret += fprintf(fp, \"M\");\n\t\t\tbreak;\n\t\tcase PERF_RECORD_COMM:\n\t\t\tif (has(COMM_EXEC))\n\t\t\t\tret += fprintf(fp, \"E\");\n\t\t\tbreak;\n\t\tcase PERF_RECORD_SWITCH:\n\t\tcase PERF_RECORD_SWITCH_CPU_WIDE:\n\t\t\tif (has(SWITCH_OUT)) {\n\t\t\t\tret += fprintf(fp, \"S\");\n\t\t\t\tif (sample->misc & PERF_RECORD_MISC_SWITCH_OUT_PREEMPT)\n\t\t\t\t\tret += fprintf(fp, \"p\");\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t#undef has\n\n\t\tret += fprintf(fp, \"%*s\", 6 - ret, \" \");\n\t\tprinted += ret;\n\t}\n\n\tif (PRINT_FIELD(TOD)) {\n\t\ttod_scnprintf(script, tstr, sizeof(tstr), sample->time);\n\t\tprinted += fprintf(fp, \"%s \", tstr);\n\t}\n\n\tif (PRINT_FIELD(TIME)) {\n\t\tu64 t = sample->time;\n\t\tif (reltime) {\n\t\t\tif (!initial_time)\n\t\t\t\tinitial_time = sample->time;\n\t\t\tt = sample->time - initial_time;\n\t\t} else if (deltatime) {\n\t\t\tif (previous_time)\n\t\t\t\tt = sample->time - previous_time;\n\t\t\telse {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tprevious_time = sample->time;\n\t\t}\n\t\tnsecs = t;\n\t\tsecs = nsecs / NSEC_PER_SEC;\n\t\tnsecs -= secs * NSEC_PER_SEC;\n\n\t\tif (symbol_conf.nanosecs)\n\t\t\tprinted += fprintf(fp, \"%5lu.%09llu: \", secs, nsecs);\n\t\telse {\n\t\t\tchar sample_time[32];\n\t\t\ttimestamp__scnprintf_usec(t, sample_time, sizeof(sample_time));\n\t\t\tprinted += fprintf(fp, \"%12s: \", sample_time);\n\t\t}\n\t}\n\n\treturn printed;\n}\n\nstatic inline char\nmispred_str(struct branch_entry *br)\n{\n\tif (!(br->flags.mispred  || br->flags.predicted))\n\t\treturn '-';\n\n\treturn br->flags.predicted ? 'P' : 'M';\n}\n\nstatic int print_bstack_flags(FILE *fp, struct branch_entry *br)\n{\n\treturn fprintf(fp, \"/%c/%c/%c/%d/%s/%s \",\n\t\t       mispred_str(br),\n\t\t       br->flags.in_tx ? 'X' : '-',\n\t\t       br->flags.abort ? 'A' : '-',\n\t\t       br->flags.cycles,\n\t\t       get_branch_type(br),\n\t\t       br->flags.spec ? branch_spec_desc(br->flags.spec) : \"-\");\n}\n\nstatic int perf_sample__fprintf_brstack(struct perf_sample *sample,\n\t\t\t\t\tstruct thread *thread,\n\t\t\t\t\tstruct perf_event_attr *attr, FILE *fp)\n{\n\tstruct branch_stack *br = sample->branch_stack;\n\tstruct branch_entry *entries = perf_sample__branch_entries(sample);\n\tu64 i, from, to;\n\tint printed = 0;\n\n\tif (!(br && br->nr))\n\t\treturn 0;\n\n\tfor (i = 0; i < br->nr; i++) {\n\t\tfrom = entries[i].from;\n\t\tto   = entries[i].to;\n\n\t\tprinted += fprintf(fp, \" 0x%\"PRIx64, from);\n\t\tif (PRINT_FIELD(DSO)) {\n\t\t\tstruct addr_location alf, alt;\n\n\t\t\taddr_location__init(&alf);\n\t\t\taddr_location__init(&alt);\n\t\t\tthread__find_map_fb(thread, sample->cpumode, from, &alf);\n\t\t\tthread__find_map_fb(thread, sample->cpumode, to, &alt);\n\n\t\t\tprinted += map__fprintf_dsoname_dsoff(alf.map, PRINT_FIELD(DSOFF), alf.addr, fp);\n\t\t\tprinted += fprintf(fp, \"/0x%\"PRIx64, to);\n\t\t\tprinted += map__fprintf_dsoname_dsoff(alt.map, PRINT_FIELD(DSOFF), alt.addr, fp);\n\t\t\taddr_location__exit(&alt);\n\t\t\taddr_location__exit(&alf);\n\t\t} else\n\t\t\tprinted += fprintf(fp, \"/0x%\"PRIx64, to);\n\n\t\tprinted += print_bstack_flags(fp, entries + i);\n\t}\n\n\treturn printed;\n}\n\nstatic int perf_sample__fprintf_brstacksym(struct perf_sample *sample,\n\t\t\t\t\t   struct thread *thread,\n\t\t\t\t\t   struct perf_event_attr *attr, FILE *fp)\n{\n\tstruct branch_stack *br = sample->branch_stack;\n\tstruct branch_entry *entries = perf_sample__branch_entries(sample);\n\tu64 i, from, to;\n\tint printed = 0;\n\n\tif (!(br && br->nr))\n\t\treturn 0;\n\n\tfor (i = 0; i < br->nr; i++) {\n\t\tstruct addr_location alf, alt;\n\n\t\taddr_location__init(&alf);\n\t\taddr_location__init(&alt);\n\t\tfrom = entries[i].from;\n\t\tto   = entries[i].to;\n\n\t\tthread__find_symbol_fb(thread, sample->cpumode, from, &alf);\n\t\tthread__find_symbol_fb(thread, sample->cpumode, to, &alt);\n\n\t\tprinted += symbol__fprintf_symname_offs(alf.sym, &alf, fp);\n\t\tif (PRINT_FIELD(DSO))\n\t\t\tprinted += map__fprintf_dsoname_dsoff(alf.map, PRINT_FIELD(DSOFF), alf.addr, fp);\n\t\tprinted += fprintf(fp, \"%c\", '/');\n\t\tprinted += symbol__fprintf_symname_offs(alt.sym, &alt, fp);\n\t\tif (PRINT_FIELD(DSO))\n\t\t\tprinted += map__fprintf_dsoname_dsoff(alt.map, PRINT_FIELD(DSOFF), alt.addr, fp);\n\t\tprinted += print_bstack_flags(fp, entries + i);\n\t\taddr_location__exit(&alt);\n\t\taddr_location__exit(&alf);\n\t}\n\n\treturn printed;\n}\n\nstatic int perf_sample__fprintf_brstackoff(struct perf_sample *sample,\n\t\t\t\t\t   struct thread *thread,\n\t\t\t\t\t   struct perf_event_attr *attr, FILE *fp)\n{\n\tstruct branch_stack *br = sample->branch_stack;\n\tstruct branch_entry *entries = perf_sample__branch_entries(sample);\n\tu64 i, from, to;\n\tint printed = 0;\n\n\tif (!(br && br->nr))\n\t\treturn 0;\n\n\tfor (i = 0; i < br->nr; i++) {\n\t\tstruct addr_location alf, alt;\n\n\t\taddr_location__init(&alf);\n\t\taddr_location__init(&alt);\n\t\tfrom = entries[i].from;\n\t\tto   = entries[i].to;\n\n\t\tif (thread__find_map_fb(thread, sample->cpumode, from, &alf) &&\n\t\t    !map__dso(alf.map)->adjust_symbols)\n\t\t\tfrom = map__dso_map_ip(alf.map, from);\n\n\t\tif (thread__find_map_fb(thread, sample->cpumode, to, &alt) &&\n\t\t    !map__dso(alt.map)->adjust_symbols)\n\t\t\tto = map__dso_map_ip(alt.map, to);\n\n\t\tprinted += fprintf(fp, \" 0x%\"PRIx64, from);\n\t\tif (PRINT_FIELD(DSO))\n\t\t\tprinted += map__fprintf_dsoname_dsoff(alf.map, PRINT_FIELD(DSOFF), alf.addr, fp);\n\t\tprinted += fprintf(fp, \"/0x%\"PRIx64, to);\n\t\tif (PRINT_FIELD(DSO))\n\t\t\tprinted += map__fprintf_dsoname_dsoff(alt.map, PRINT_FIELD(DSOFF), alt.addr, fp);\n\t\tprinted += print_bstack_flags(fp, entries + i);\n\t\taddr_location__exit(&alt);\n\t\taddr_location__exit(&alf);\n\t}\n\n\treturn printed;\n}\n#define MAXBB 16384UL\n\nstatic int grab_bb(u8 *buffer, u64 start, u64 end,\n\t\t    struct machine *machine, struct thread *thread,\n\t\t    bool *is64bit, u8 *cpumode, bool last)\n{\n\tlong offset, len;\n\tstruct addr_location al;\n\tbool kernel;\n\tstruct dso *dso;\n\tint ret = 0;\n\n\tif (!start || !end)\n\t\treturn 0;\n\n\tkernel = machine__kernel_ip(machine, start);\n\tif (kernel)\n\t\t*cpumode = PERF_RECORD_MISC_KERNEL;\n\telse\n\t\t*cpumode = PERF_RECORD_MISC_USER;\n\n\t \n\tif (kernel != machine__kernel_ip(machine, end)) {\n\t\tpr_debug(\"\\tblock %\" PRIx64 \"-%\" PRIx64 \" transfers between kernel and user\\n\", start, end);\n\t\treturn -ENXIO;\n\t}\n\n\tif (end - start > MAXBB - MAXINSN) {\n\t\tif (last)\n\t\t\tpr_debug(\"\\tbrstack does not reach to final jump (%\" PRIx64 \"-%\" PRIx64 \")\\n\", start, end);\n\t\telse\n\t\t\tpr_debug(\"\\tblock %\" PRIx64 \"-%\" PRIx64 \" (%\" PRIu64 \") too long to dump\\n\", start, end, end - start);\n\t\treturn 0;\n\t}\n\n\taddr_location__init(&al);\n\tif (!thread__find_map(thread, *cpumode, start, &al) || (dso = map__dso(al.map)) == NULL) {\n\t\tpr_debug(\"\\tcannot resolve %\" PRIx64 \"-%\" PRIx64 \"\\n\", start, end);\n\t\tgoto out;\n\t}\n\tif (dso->data.status == DSO_DATA_STATUS_ERROR) {\n\t\tpr_debug(\"\\tcannot resolve %\" PRIx64 \"-%\" PRIx64 \"\\n\", start, end);\n\t\tgoto out;\n\t}\n\n\t \n\tmap__load(al.map);\n\n\toffset = map__map_ip(al.map, start);\n\tlen = dso__data_read_offset(dso, machine, offset, (u8 *)buffer,\n\t\t\t\t    end - start + MAXINSN);\n\n\t*is64bit = dso->is_64_bit;\n\tif (len <= 0)\n\t\tpr_debug(\"\\tcannot fetch code for block at %\" PRIx64 \"-%\" PRIx64 \"\\n\",\n\t\t\tstart, end);\n\tret = len;\nout:\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic int map__fprintf_srccode(struct map *map, u64 addr, FILE *fp, struct srccode_state *state)\n{\n\tchar *srcfile;\n\tint ret = 0;\n\tunsigned line;\n\tint len;\n\tchar *srccode;\n\tstruct dso *dso;\n\n\tif (!map || (dso = map__dso(map)) == NULL)\n\t\treturn 0;\n\tsrcfile = get_srcline_split(dso,\n\t\t\t\t    map__rip_2objdump(map, addr),\n\t\t\t\t    &line);\n\tif (!srcfile)\n\t\treturn 0;\n\n\t \n\tif (state &&\n\t    state->srcfile &&\n\t    !strcmp(state->srcfile, srcfile) &&\n\t    state->line == line) {\n\t\tfree(srcfile);\n\t\treturn 0;\n\t}\n\n\tsrccode = find_sourceline(srcfile, line, &len);\n\tif (!srccode)\n\t\tgoto out_free_line;\n\n\tret = fprintf(fp, \"|%-8d %.*s\", line, len, srccode);\n\n\tif (state) {\n\t\tstate->srcfile = srcfile;\n\t\tstate->line = line;\n\t}\n\treturn ret;\n\nout_free_line:\n\tfree(srcfile);\n\treturn ret;\n}\n\nstatic int print_srccode(struct thread *thread, u8 cpumode, uint64_t addr)\n{\n\tstruct addr_location al;\n\tint ret = 0;\n\n\taddr_location__init(&al);\n\tthread__find_map(thread, cpumode, addr, &al);\n\tif (!al.map)\n\t\tgoto out;\n\tret = map__fprintf_srccode(al.map, al.addr, stdout,\n\t\t\t\t   thread__srccode_state(thread));\n\tif (ret)\n\t\tret += printf(\"\\n\");\nout:\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic int ip__fprintf_jump(uint64_t ip, struct branch_entry *en,\n\t\t\t    struct perf_insn *x, u8 *inbuf, int len,\n\t\t\t    int insn, FILE *fp, int *total_cycles,\n\t\t\t    struct perf_event_attr *attr)\n{\n\tint ilen = 0;\n\tint printed = fprintf(fp, \"\\t%016\" PRIx64 \"\\t%-30s\\t\", ip,\n\t\t\t      dump_insn(x, ip, inbuf, len, &ilen));\n\n\tif (PRINT_FIELD(BRSTACKINSNLEN))\n\t\tprinted += fprintf(fp, \"ilen: %d\\t\", ilen);\n\n\tprinted += fprintf(fp, \"#%s%s%s%s\",\n\t\t\t      en->flags.predicted ? \" PRED\" : \"\",\n\t\t\t      en->flags.mispred ? \" MISPRED\" : \"\",\n\t\t\t      en->flags.in_tx ? \" INTX\" : \"\",\n\t\t\t      en->flags.abort ? \" ABORT\" : \"\");\n\tif (en->flags.cycles) {\n\t\t*total_cycles += en->flags.cycles;\n\t\tprinted += fprintf(fp, \" %d cycles [%d]\", en->flags.cycles, *total_cycles);\n\t\tif (insn)\n\t\t\tprinted += fprintf(fp, \" %.2f IPC\", (float)insn / en->flags.cycles);\n\t}\n\treturn printed + fprintf(fp, \"\\n\");\n}\n\nstatic int ip__fprintf_sym(uint64_t addr, struct thread *thread,\n\t\t\t   u8 cpumode, int cpu, struct symbol **lastsym,\n\t\t\t   struct perf_event_attr *attr, FILE *fp)\n{\n\tstruct addr_location al;\n\tint off, printed = 0, ret = 0;\n\n\taddr_location__init(&al);\n\tthread__find_map(thread, cpumode, addr, &al);\n\n\tif ((*lastsym) && al.addr >= (*lastsym)->start && al.addr < (*lastsym)->end)\n\t\tgoto out;\n\n\tal.cpu = cpu;\n\tal.sym = NULL;\n\tif (al.map)\n\t\tal.sym = map__find_symbol(al.map, al.addr);\n\n\tif (!al.sym)\n\t\tgoto out;\n\n\tif (al.addr < al.sym->end)\n\t\toff = al.addr - al.sym->start;\n\telse\n\t\toff = al.addr - map__start(al.map) - al.sym->start;\n\tprinted += fprintf(fp, \"\\t%s\", al.sym->name);\n\tif (off)\n\t\tprinted += fprintf(fp, \"%+d\", off);\n\tprinted += fprintf(fp, \":\");\n\tif (PRINT_FIELD(SRCLINE))\n\t\tprinted += map__fprintf_srcline(al.map, al.addr, \"\\t\", fp);\n\tprinted += fprintf(fp, \"\\n\");\n\t*lastsym = al.sym;\n\n\tret = printed;\nout:\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic int perf_sample__fprintf_brstackinsn(struct perf_sample *sample,\n\t\t\t\t\t    struct thread *thread,\n\t\t\t\t\t    struct perf_event_attr *attr,\n\t\t\t\t\t    struct machine *machine, FILE *fp)\n{\n\tstruct branch_stack *br = sample->branch_stack;\n\tstruct branch_entry *entries = perf_sample__branch_entries(sample);\n\tu64 start, end;\n\tint i, insn, len, nr, ilen, printed = 0;\n\tstruct perf_insn x;\n\tu8 buffer[MAXBB];\n\tunsigned off;\n\tstruct symbol *lastsym = NULL;\n\tint total_cycles = 0;\n\n\tif (!(br && br->nr))\n\t\treturn 0;\n\tnr = br->nr;\n\tif (max_blocks && nr > max_blocks + 1)\n\t\tnr = max_blocks + 1;\n\n\tx.thread = thread;\n\tx.cpu = sample->cpu;\n\n\tprinted += fprintf(fp, \"%c\", '\\n');\n\n\t \n\tlen = grab_bb(buffer, entries[nr-1].from,\n\t\t\tentries[nr-1].from,\n\t\t\tmachine, thread, &x.is64bit, &x.cpumode, false);\n\tif (len > 0) {\n\t\tprinted += ip__fprintf_sym(entries[nr - 1].from, thread,\n\t\t\t\t\t   x.cpumode, x.cpu, &lastsym, attr, fp);\n\t\tprinted += ip__fprintf_jump(entries[nr - 1].from, &entries[nr - 1],\n\t\t\t\t\t    &x, buffer, len, 0, fp, &total_cycles,\n\t\t\t\t\t    attr);\n\t\tif (PRINT_FIELD(SRCCODE))\n\t\t\tprinted += print_srccode(thread, x.cpumode, entries[nr - 1].from);\n\t}\n\n\t \n\tfor (i = nr - 2; i >= 0; i--) {\n\t\tif (entries[i].from || entries[i].to)\n\t\t\tpr_debug(\"%d: %\" PRIx64 \"-%\" PRIx64 \"\\n\", i,\n\t\t\t\t entries[i].from,\n\t\t\t\t entries[i].to);\n\t\tstart = entries[i + 1].to;\n\t\tend   = entries[i].from;\n\n\t\tlen = grab_bb(buffer, start, end, machine, thread, &x.is64bit, &x.cpumode, false);\n\t\t \n\t\tif (len == -ENXIO && i > 0) {\n\t\t\tend = entries[--i].from;\n\t\t\tpr_debug(\"\\tpatching up to %\" PRIx64 \"-%\" PRIx64 \"\\n\", start, end);\n\t\t\tlen = grab_bb(buffer, start, end, machine, thread, &x.is64bit, &x.cpumode, false);\n\t\t}\n\t\tif (len <= 0)\n\t\t\tcontinue;\n\n\t\tinsn = 0;\n\t\tfor (off = 0; off < (unsigned)len; off += ilen) {\n\t\t\tuint64_t ip = start + off;\n\n\t\t\tprinted += ip__fprintf_sym(ip, thread, x.cpumode, x.cpu, &lastsym, attr, fp);\n\t\t\tif (ip == end) {\n\t\t\t\tprinted += ip__fprintf_jump(ip, &entries[i], &x, buffer + off, len - off, ++insn, fp,\n\t\t\t\t\t\t\t    &total_cycles, attr);\n\t\t\t\tif (PRINT_FIELD(SRCCODE))\n\t\t\t\t\tprinted += print_srccode(thread, x.cpumode, ip);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tilen = 0;\n\t\t\t\tprinted += fprintf(fp, \"\\t%016\" PRIx64 \"\\t%s\", ip,\n\t\t\t\t\t\t   dump_insn(&x, ip, buffer + off, len - off, &ilen));\n\t\t\t\tif (PRINT_FIELD(BRSTACKINSNLEN))\n\t\t\t\t\tprinted += fprintf(fp, \"\\tilen: %d\", ilen);\n\t\t\t\tprinted += fprintf(fp, \"\\n\");\n\t\t\t\tif (ilen == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (PRINT_FIELD(SRCCODE))\n\t\t\t\t\tprint_srccode(thread, x.cpumode, ip);\n\t\t\t\tinsn++;\n\t\t\t}\n\t\t}\n\t\tif (off != end - start)\n\t\t\tprinted += fprintf(fp, \"\\tmismatch of LBR data and executable\\n\");\n\t}\n\n\t \n\tif (entries[0].from == sample->ip)\n\t\tgoto out;\n\tif (entries[0].flags.abort)\n\t\tgoto out;\n\n\t \n\tstart = entries[0].to;\n\tend = sample->ip;\n\tif (end < start) {\n\t\t \n\t\tend = start + 128;\n\t}\n\tlen = grab_bb(buffer, start, end, machine, thread, &x.is64bit, &x.cpumode, true);\n\tprinted += ip__fprintf_sym(start, thread, x.cpumode, x.cpu, &lastsym, attr, fp);\n\tif (len <= 0) {\n\t\t \n\t\tlen = grab_bb(buffer, sample->ip, sample->ip,\n\t\t\t      machine, thread, &x.is64bit, &x.cpumode, false);\n\t\tif (len <= 0)\n\t\t\tgoto out;\n\t\tilen = 0;\n\t\tprinted += fprintf(fp, \"\\t%016\" PRIx64 \"\\t%s\", sample->ip,\n\t\t\tdump_insn(&x, sample->ip, buffer, len, &ilen));\n\t\tif (PRINT_FIELD(BRSTACKINSNLEN))\n\t\t\tprinted += fprintf(fp, \"\\tilen: %d\", ilen);\n\t\tprinted += fprintf(fp, \"\\n\");\n\t\tif (PRINT_FIELD(SRCCODE))\n\t\t\tprint_srccode(thread, x.cpumode, sample->ip);\n\t\tgoto out;\n\t}\n\tfor (off = 0; off <= end - start; off += ilen) {\n\t\tilen = 0;\n\t\tprinted += fprintf(fp, \"\\t%016\" PRIx64 \"\\t%s\", start + off,\n\t\t\t\t   dump_insn(&x, start + off, buffer + off, len - off, &ilen));\n\t\tif (PRINT_FIELD(BRSTACKINSNLEN))\n\t\t\tprinted += fprintf(fp, \"\\tilen: %d\", ilen);\n\t\tprinted += fprintf(fp, \"\\n\");\n\t\tif (ilen == 0)\n\t\t\tbreak;\n\t\tif (arch_is_branch(buffer + off, len - off, x.is64bit) && start + off != sample->ip) {\n\t\t\t \n\t\t\tprinted += fprintf(fp, \"\\t... not reaching sample ...\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (PRINT_FIELD(SRCCODE))\n\t\t\tprint_srccode(thread, x.cpumode, start + off);\n\t}\nout:\n\treturn printed;\n}\n\nstatic int perf_sample__fprintf_addr(struct perf_sample *sample,\n\t\t\t\t     struct thread *thread,\n\t\t\t\t     struct perf_event_attr *attr, FILE *fp)\n{\n\tstruct addr_location al;\n\tint printed = fprintf(fp, \"%16\" PRIx64, sample->addr);\n\n\taddr_location__init(&al);\n\tif (!sample_addr_correlates_sym(attr))\n\t\tgoto out;\n\n\tthread__resolve(thread, &al, sample);\n\n\tif (PRINT_FIELD(SYM)) {\n\t\tprinted += fprintf(fp, \" \");\n\t\tif (PRINT_FIELD(SYMOFFSET))\n\t\t\tprinted += symbol__fprintf_symname_offs(al.sym, &al, fp);\n\t\telse\n\t\t\tprinted += symbol__fprintf_symname(al.sym, fp);\n\t}\n\n\tif (PRINT_FIELD(DSO))\n\t\tprinted += map__fprintf_dsoname_dsoff(al.map, PRINT_FIELD(DSOFF), al.addr, fp);\nout:\n\taddr_location__exit(&al);\n\treturn printed;\n}\n\nstatic const char *resolve_branch_sym(struct perf_sample *sample,\n\t\t\t\t      struct evsel *evsel,\n\t\t\t\t      struct thread *thread,\n\t\t\t\t      struct addr_location *al,\n\t\t\t\t      struct addr_location *addr_al,\n\t\t\t\t      u64 *ip)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tconst char *name = NULL;\n\n\tif (sample->flags & (PERF_IP_FLAG_CALL | PERF_IP_FLAG_TRACE_BEGIN)) {\n\t\tif (sample_addr_correlates_sym(attr)) {\n\t\t\tif (!addr_al->thread)\n\t\t\t\tthread__resolve(thread, addr_al, sample);\n\t\t\tif (addr_al->sym)\n\t\t\t\tname = addr_al->sym->name;\n\t\t\telse\n\t\t\t\t*ip = sample->addr;\n\t\t} else {\n\t\t\t*ip = sample->addr;\n\t\t}\n\t} else if (sample->flags & (PERF_IP_FLAG_RETURN | PERF_IP_FLAG_TRACE_END)) {\n\t\tif (al->sym)\n\t\t\tname = al->sym->name;\n\t\telse\n\t\t\t*ip = sample->ip;\n\t}\n\treturn name;\n}\n\nstatic int perf_sample__fprintf_callindent(struct perf_sample *sample,\n\t\t\t\t\t   struct evsel *evsel,\n\t\t\t\t\t   struct thread *thread,\n\t\t\t\t\t   struct addr_location *al,\n\t\t\t\t\t   struct addr_location *addr_al,\n\t\t\t\t\t   FILE *fp)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tsize_t depth = thread_stack__depth(thread, sample->cpu);\n\tconst char *name = NULL;\n\tstatic int spacing;\n\tint len = 0;\n\tint dlen = 0;\n\tu64 ip = 0;\n\n\t \n\tif (thread__ts(thread) && sample->flags & PERF_IP_FLAG_RETURN)\n\t\tdepth += 1;\n\n\tname = resolve_branch_sym(sample, evsel, thread, al, addr_al, &ip);\n\n\tif (PRINT_FIELD(DSO) && !(PRINT_FIELD(IP) || PRINT_FIELD(ADDR))) {\n\t\tdlen += fprintf(fp, \"(\");\n\t\tdlen += map__fprintf_dsoname(al->map, fp);\n\t\tdlen += fprintf(fp, \")\\t\");\n\t}\n\n\tif (name)\n\t\tlen = fprintf(fp, \"%*s%s\", (int)depth * 4, \"\", name);\n\telse if (ip)\n\t\tlen = fprintf(fp, \"%*s%16\" PRIx64, (int)depth * 4, \"\", ip);\n\n\tif (len < 0)\n\t\treturn len;\n\n\t \n\tif (len > spacing || (len && len < spacing - 52))\n\t\tspacing = round_up(len + 4, 32);\n\n\tif (len < spacing)\n\t\tlen += fprintf(fp, \"%*s\", spacing - len, \"\");\n\n\treturn len + dlen;\n}\n\n__weak void arch_fetch_insn(struct perf_sample *sample __maybe_unused,\n\t\t\t    struct thread *thread __maybe_unused,\n\t\t\t    struct machine *machine __maybe_unused)\n{\n}\n\nvoid script_fetch_insn(struct perf_sample *sample, struct thread *thread,\n\t\t       struct machine *machine)\n{\n\tif (sample->insn_len == 0 && native_arch)\n\t\tarch_fetch_insn(sample, thread, machine);\n}\n\nstatic int perf_sample__fprintf_insn(struct perf_sample *sample,\n\t\t\t\t     struct perf_event_attr *attr,\n\t\t\t\t     struct thread *thread,\n\t\t\t\t     struct machine *machine, FILE *fp)\n{\n\tint printed = 0;\n\n\tscript_fetch_insn(sample, thread, machine);\n\n\tif (PRINT_FIELD(INSNLEN))\n\t\tprinted += fprintf(fp, \" ilen: %d\", sample->insn_len);\n\tif (PRINT_FIELD(INSN) && sample->insn_len) {\n\t\tint i;\n\n\t\tprinted += fprintf(fp, \" insn:\");\n\t\tfor (i = 0; i < sample->insn_len; i++)\n\t\t\tprinted += fprintf(fp, \" %02x\", (unsigned char)sample->insn[i]);\n\t}\n\tif (PRINT_FIELD(BRSTACKINSN) || PRINT_FIELD(BRSTACKINSNLEN))\n\t\tprinted += perf_sample__fprintf_brstackinsn(sample, thread, attr, machine, fp);\n\n\treturn printed;\n}\n\nstatic int perf_sample__fprintf_ipc(struct perf_sample *sample,\n\t\t\t\t    struct perf_event_attr *attr, FILE *fp)\n{\n\tunsigned int ipc;\n\n\tif (!PRINT_FIELD(IPC) || !sample->cyc_cnt || !sample->insn_cnt)\n\t\treturn 0;\n\n\tipc = (sample->insn_cnt * 100) / sample->cyc_cnt;\n\n\treturn fprintf(fp, \" \\t IPC: %u.%02u (%\" PRIu64 \"/%\" PRIu64 \") \",\n\t\t       ipc / 100, ipc % 100, sample->insn_cnt, sample->cyc_cnt);\n}\n\nstatic int perf_sample__fprintf_bts(struct perf_sample *sample,\n\t\t\t\t    struct evsel *evsel,\n\t\t\t\t    struct thread *thread,\n\t\t\t\t    struct addr_location *al,\n\t\t\t\t    struct addr_location *addr_al,\n\t\t\t\t    struct machine *machine, FILE *fp)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tunsigned int type = output_type(attr->type);\n\tbool print_srcline_last = false;\n\tint printed = 0;\n\n\tif (PRINT_FIELD(CALLINDENT))\n\t\tprinted += perf_sample__fprintf_callindent(sample, evsel, thread, al, addr_al, fp);\n\n\t \n\tif (PRINT_FIELD(IP)) {\n\t\tunsigned int print_opts = output[type].print_ip_opts;\n\t\tstruct callchain_cursor *cursor = NULL;\n\n\t\tif (symbol_conf.use_callchain && sample->callchain) {\n\t\t\tcursor = get_tls_callchain_cursor();\n\t\t\tif (thread__resolve_callchain(al->thread, cursor, evsel,\n\t\t\t\t\t\t      sample, NULL, NULL,\n\t\t\t\t\t\t      scripting_max_stack))\n\t\t\t\tcursor = NULL;\n\t\t}\n\t\tif (cursor == NULL) {\n\t\t\tprinted += fprintf(fp, \" \");\n\t\t\tif (print_opts & EVSEL__PRINT_SRCLINE) {\n\t\t\t\tprint_srcline_last = true;\n\t\t\t\tprint_opts &= ~EVSEL__PRINT_SRCLINE;\n\t\t\t}\n\t\t} else\n\t\t\tprinted += fprintf(fp, \"\\n\");\n\n\t\tprinted += sample__fprintf_sym(sample, al, 0, print_opts, cursor,\n\t\t\t\t\t       symbol_conf.bt_stop_list, fp);\n\t}\n\n\t \n\tif (PRINT_FIELD(ADDR) ||\n\t    ((evsel->core.attr.sample_type & PERF_SAMPLE_ADDR) &&\n\t     !output[type].user_set)) {\n\t\tprinted += fprintf(fp, \" => \");\n\t\tprinted += perf_sample__fprintf_addr(sample, thread, attr, fp);\n\t}\n\n\tprinted += perf_sample__fprintf_ipc(sample, attr, fp);\n\n\tif (print_srcline_last)\n\t\tprinted += map__fprintf_srcline(al->map, al->addr, \"\\n  \", fp);\n\n\tprinted += perf_sample__fprintf_insn(sample, attr, thread, machine, fp);\n\tprinted += fprintf(fp, \"\\n\");\n\tif (PRINT_FIELD(SRCCODE)) {\n\t\tint ret = map__fprintf_srccode(al->map, al->addr, stdout,\n\t\t\t\t\t       thread__srccode_state(thread));\n\t\tif (ret) {\n\t\t\tprinted += ret;\n\t\t\tprinted += printf(\"\\n\");\n\t\t}\n\t}\n\treturn printed;\n}\n\nstatic struct {\n\tu32 flags;\n\tconst char *name;\n} sample_flags[] = {\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL, \"call\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_RETURN, \"return\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CONDITIONAL, \"jcc\"},\n\t{PERF_IP_FLAG_BRANCH, \"jmp\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_INTERRUPT, \"int\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_RETURN | PERF_IP_FLAG_INTERRUPT, \"iret\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_SYSCALLRET, \"syscall\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_RETURN | PERF_IP_FLAG_SYSCALLRET, \"sysret\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_ASYNC, \"async\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_ASYNC |\tPERF_IP_FLAG_INTERRUPT, \"hw int\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_TX_ABORT, \"tx abrt\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_TRACE_BEGIN, \"tr strt\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_TRACE_END, \"tr end\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_VMENTRY, \"vmentry\"},\n\t{PERF_IP_FLAG_BRANCH | PERF_IP_FLAG_CALL | PERF_IP_FLAG_VMEXIT, \"vmexit\"},\n\t{0, NULL}\n};\n\nstatic const char *sample_flags_to_name(u32 flags)\n{\n\tint i;\n\n\tfor (i = 0; sample_flags[i].name ; i++) {\n\t\tif (sample_flags[i].flags == flags)\n\t\t\treturn sample_flags[i].name;\n\t}\n\n\treturn NULL;\n}\n\nint perf_sample__sprintf_flags(u32 flags, char *str, size_t sz)\n{\n\tu32 xf = PERF_IP_FLAG_IN_TX | PERF_IP_FLAG_INTR_DISABLE |\n\t\t PERF_IP_FLAG_INTR_TOGGLE;\n\tconst char *chars = PERF_IP_FLAG_CHARS;\n\tconst size_t n = strlen(PERF_IP_FLAG_CHARS);\n\tconst char *name = NULL;\n\tsize_t i, pos = 0;\n\tchar xs[16] = {0};\n\n\tif (flags & xf)\n\t\tsnprintf(xs, sizeof(xs), \"(%s%s%s)\",\n\t\t\t flags & PERF_IP_FLAG_IN_TX ? \"x\" : \"\",\n\t\t\t flags & PERF_IP_FLAG_INTR_DISABLE ? \"D\" : \"\",\n\t\t\t flags & PERF_IP_FLAG_INTR_TOGGLE ? \"t\" : \"\");\n\n\tname = sample_flags_to_name(flags & ~xf);\n\tif (name)\n\t\treturn snprintf(str, sz, \"%-15s%6s\", name, xs);\n\n\tif (flags & PERF_IP_FLAG_TRACE_BEGIN) {\n\t\tname = sample_flags_to_name(flags & ~(xf | PERF_IP_FLAG_TRACE_BEGIN));\n\t\tif (name)\n\t\t\treturn snprintf(str, sz, \"tr strt %-7s%6s\", name, xs);\n\t}\n\n\tif (flags & PERF_IP_FLAG_TRACE_END) {\n\t\tname = sample_flags_to_name(flags & ~(xf | PERF_IP_FLAG_TRACE_END));\n\t\tif (name)\n\t\t\treturn snprintf(str, sz, \"tr end  %-7s%6s\", name, xs);\n\t}\n\n\tfor (i = 0; i < n; i++, flags >>= 1) {\n\t\tif ((flags & 1) && pos < sz)\n\t\t\tstr[pos++] = chars[i];\n\t}\n\tfor (; i < 32; i++, flags >>= 1) {\n\t\tif ((flags & 1) && pos < sz)\n\t\t\tstr[pos++] = '?';\n\t}\n\tif (pos < sz)\n\t\tstr[pos] = 0;\n\n\treturn pos;\n}\n\nstatic int perf_sample__fprintf_flags(u32 flags, FILE *fp)\n{\n\tchar str[SAMPLE_FLAGS_BUF_SIZE];\n\n\tperf_sample__sprintf_flags(flags, str, sizeof(str));\n\treturn fprintf(fp, \"  %-21s \", str);\n}\n\nstruct printer_data {\n\tint line_no;\n\tbool hit_nul;\n\tbool is_printable;\n};\n\nstatic int sample__fprintf_bpf_output(enum binary_printer_ops op,\n\t\t\t\t      unsigned int val,\n\t\t\t\t      void *extra, FILE *fp)\n{\n\tunsigned char ch = (unsigned char)val;\n\tstruct printer_data *printer_data = extra;\n\tint printed = 0;\n\n\tswitch (op) {\n\tcase BINARY_PRINT_DATA_BEGIN:\n\t\tprinted += fprintf(fp, \"\\n\");\n\t\tbreak;\n\tcase BINARY_PRINT_LINE_BEGIN:\n\t\tprinted += fprintf(fp, \"%17s\", !printer_data->line_no ? \"BPF output:\" :\n\t\t\t\t\t\t        \"           \");\n\t\tbreak;\n\tcase BINARY_PRINT_ADDR:\n\t\tprinted += fprintf(fp, \" %04x:\", val);\n\t\tbreak;\n\tcase BINARY_PRINT_NUM_DATA:\n\t\tprinted += fprintf(fp, \" %02x\", val);\n\t\tbreak;\n\tcase BINARY_PRINT_NUM_PAD:\n\t\tprinted += fprintf(fp, \"   \");\n\t\tbreak;\n\tcase BINARY_PRINT_SEP:\n\t\tprinted += fprintf(fp, \"  \");\n\t\tbreak;\n\tcase BINARY_PRINT_CHAR_DATA:\n\t\tif (printer_data->hit_nul && ch)\n\t\t\tprinter_data->is_printable = false;\n\n\t\tif (!isprint(ch)) {\n\t\t\tprinted += fprintf(fp, \"%c\", '.');\n\n\t\t\tif (!printer_data->is_printable)\n\t\t\t\tbreak;\n\n\t\t\tif (ch == '\\0')\n\t\t\t\tprinter_data->hit_nul = true;\n\t\t\telse\n\t\t\t\tprinter_data->is_printable = false;\n\t\t} else {\n\t\t\tprinted += fprintf(fp, \"%c\", ch);\n\t\t}\n\t\tbreak;\n\tcase BINARY_PRINT_CHAR_PAD:\n\t\tprinted += fprintf(fp, \" \");\n\t\tbreak;\n\tcase BINARY_PRINT_LINE_END:\n\t\tprinted += fprintf(fp, \"\\n\");\n\t\tprinter_data->line_no++;\n\t\tbreak;\n\tcase BINARY_PRINT_DATA_END:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn printed;\n}\n\nstatic int perf_sample__fprintf_bpf_output(struct perf_sample *sample, FILE *fp)\n{\n\tunsigned int nr_bytes = sample->raw_size;\n\tstruct printer_data printer_data = {0, false, true};\n\tint printed = binary__fprintf(sample->raw_data, nr_bytes, 8,\n\t\t\t\t      sample__fprintf_bpf_output, &printer_data, fp);\n\n\tif (printer_data.is_printable && printer_data.hit_nul)\n\t\tprinted += fprintf(fp, \"%17s \\\"%s\\\"\\n\", \"BPF string:\", (char *)(sample->raw_data));\n\n\treturn printed;\n}\n\nstatic int perf_sample__fprintf_spacing(int len, int spacing, FILE *fp)\n{\n\tif (len > 0 && len < spacing)\n\t\treturn fprintf(fp, \"%*s\", spacing - len, \"\");\n\n\treturn 0;\n}\n\nstatic int perf_sample__fprintf_pt_spacing(int len, FILE *fp)\n{\n\treturn perf_sample__fprintf_spacing(len, 34, fp);\n}\n\n \nstatic bool ptw_is_prt(u64 val)\n{\n\tchar c;\n\tu32 i;\n\n\tfor (i = 0; i < sizeof(val); i++) {\n\t\tc = ((char *)&val)[i];\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (!isprint(c) || !isascii(c))\n\t\t\treturn false;\n\t}\n\tfor (; i < sizeof(val); i++) {\n\t\tc = ((char *)&val)[i];\n\t\tif (c)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int perf_sample__fprintf_synth_ptwrite(struct perf_sample *sample, FILE *fp)\n{\n\tstruct perf_synth_intel_ptwrite *data = perf_sample__synth_ptr(sample);\n\tchar str[sizeof(u64) + 1] = \"\";\n\tint len;\n\tu64 val;\n\n\tif (perf_sample__bad_synth_size(sample, *data))\n\t\treturn 0;\n\n\tval = le64_to_cpu(data->payload);\n\tif (ptw_is_prt(val)) {\n\t\tmemcpy(str, &val, sizeof(val));\n\t\tstr[sizeof(val)] = 0;\n\t}\n\tlen = fprintf(fp, \" IP: %u payload: %#\" PRIx64 \" %s \",\n\t\t      data->ip, val, str);\n\treturn len + perf_sample__fprintf_pt_spacing(len, fp);\n}\n\nstatic int perf_sample__fprintf_synth_mwait(struct perf_sample *sample, FILE *fp)\n{\n\tstruct perf_synth_intel_mwait *data = perf_sample__synth_ptr(sample);\n\tint len;\n\n\tif (perf_sample__bad_synth_size(sample, *data))\n\t\treturn 0;\n\n\tlen = fprintf(fp, \" hints: %#x extensions: %#x \",\n\t\t      data->hints, data->extensions);\n\treturn len + perf_sample__fprintf_pt_spacing(len, fp);\n}\n\nstatic int perf_sample__fprintf_synth_pwre(struct perf_sample *sample, FILE *fp)\n{\n\tstruct perf_synth_intel_pwre *data = perf_sample__synth_ptr(sample);\n\tint len;\n\n\tif (perf_sample__bad_synth_size(sample, *data))\n\t\treturn 0;\n\n\tlen = fprintf(fp, \" hw: %u cstate: %u sub-cstate: %u \",\n\t\t      data->hw, data->cstate, data->subcstate);\n\treturn len + perf_sample__fprintf_pt_spacing(len, fp);\n}\n\nstatic int perf_sample__fprintf_synth_exstop(struct perf_sample *sample, FILE *fp)\n{\n\tstruct perf_synth_intel_exstop *data = perf_sample__synth_ptr(sample);\n\tint len;\n\n\tif (perf_sample__bad_synth_size(sample, *data))\n\t\treturn 0;\n\n\tlen = fprintf(fp, \" IP: %u \", data->ip);\n\treturn len + perf_sample__fprintf_pt_spacing(len, fp);\n}\n\nstatic int perf_sample__fprintf_synth_pwrx(struct perf_sample *sample, FILE *fp)\n{\n\tstruct perf_synth_intel_pwrx *data = perf_sample__synth_ptr(sample);\n\tint len;\n\n\tif (perf_sample__bad_synth_size(sample, *data))\n\t\treturn 0;\n\n\tlen = fprintf(fp, \" deepest cstate: %u last cstate: %u wake reason: %#x \",\n\t\t     data->deepest_cstate, data->last_cstate,\n\t\t     data->wake_reason);\n\treturn len + perf_sample__fprintf_pt_spacing(len, fp);\n}\n\nstatic int perf_sample__fprintf_synth_cbr(struct perf_sample *sample, FILE *fp)\n{\n\tstruct perf_synth_intel_cbr *data = perf_sample__synth_ptr(sample);\n\tunsigned int percent, freq;\n\tint len;\n\n\tif (perf_sample__bad_synth_size(sample, *data))\n\t\treturn 0;\n\n\tfreq = (le32_to_cpu(data->freq) + 500) / 1000;\n\tlen = fprintf(fp, \" cbr: %2u freq: %4u MHz \", data->cbr, freq);\n\tif (data->max_nonturbo) {\n\t\tpercent = (5 + (1000 * data->cbr) / data->max_nonturbo) / 10;\n\t\tlen += fprintf(fp, \"(%3u%%) \", percent);\n\t}\n\treturn len + perf_sample__fprintf_pt_spacing(len, fp);\n}\n\nstatic int perf_sample__fprintf_synth_psb(struct perf_sample *sample, FILE *fp)\n{\n\tstruct perf_synth_intel_psb *data = perf_sample__synth_ptr(sample);\n\tint len;\n\n\tif (perf_sample__bad_synth_size(sample, *data))\n\t\treturn 0;\n\n\tlen = fprintf(fp, \" psb offs: %#\" PRIx64, data->offset);\n\treturn len + perf_sample__fprintf_pt_spacing(len, fp);\n}\n\n \nstatic int perf_sample__fprintf_synth_evt(struct perf_sample *sample, FILE *fp)\n{\n\tstruct perf_synth_intel_evt *data = perf_sample__synth_ptr(sample);\n\tconst char *cfe[32] = {NULL, \"INTR\", \"IRET\", \"SMI\", \"RSM\", \"SIPI\",\n\t\t\t       \"INIT\", \"VMENTRY\", \"VMEXIT\", \"VMEXIT_INTR\",\n\t\t\t       \"SHUTDOWN\", NULL, \"UINTR\", \"UIRET\"};\n\tconst char *evd[64] = {\"PFA\", \"VMXQ\", \"VMXR\"};\n\tconst char *s;\n\tint len, i;\n\n\tif (perf_sample__bad_synth_size(sample, *data))\n\t\treturn 0;\n\n\ts = cfe[data->type];\n\tif (s) {\n\t\tlen = fprintf(fp, \" cfe: %s IP: %d vector: %u\",\n\t\t\t      s, data->ip, data->vector);\n\t} else {\n\t\tlen = fprintf(fp, \" cfe: %u IP: %d vector: %u\",\n\t\t\t      data->type, data->ip, data->vector);\n\t}\n\tfor (i = 0; i < data->evd_cnt; i++) {\n\t\tunsigned int et = data->evd[i].evd_type & 0x3f;\n\n\t\ts = evd[et];\n\t\tif (s) {\n\t\t\tlen += fprintf(fp, \" %s: %#\" PRIx64,\n\t\t\t\t       s, data->evd[i].payload);\n\t\t} else {\n\t\t\tlen += fprintf(fp, \" EVD_%u: %#\" PRIx64,\n\t\t\t\t       et, data->evd[i].payload);\n\t\t}\n\t}\n\treturn len + perf_sample__fprintf_pt_spacing(len, fp);\n}\n\nstatic int perf_sample__fprintf_synth_iflag_chg(struct perf_sample *sample, FILE *fp)\n{\n\tstruct perf_synth_intel_iflag_chg *data = perf_sample__synth_ptr(sample);\n\tint len;\n\n\tif (perf_sample__bad_synth_size(sample, *data))\n\t\treturn 0;\n\n\tlen = fprintf(fp, \" IFLAG: %d->%d %s branch\", !data->iflag, data->iflag,\n\t\t      data->via_branch ? \"via\" : \"non\");\n\treturn len + perf_sample__fprintf_pt_spacing(len, fp);\n}\n\nstatic int perf_sample__fprintf_synth(struct perf_sample *sample,\n\t\t\t\t      struct evsel *evsel, FILE *fp)\n{\n\tswitch (evsel->core.attr.config) {\n\tcase PERF_SYNTH_INTEL_PTWRITE:\n\t\treturn perf_sample__fprintf_synth_ptwrite(sample, fp);\n\tcase PERF_SYNTH_INTEL_MWAIT:\n\t\treturn perf_sample__fprintf_synth_mwait(sample, fp);\n\tcase PERF_SYNTH_INTEL_PWRE:\n\t\treturn perf_sample__fprintf_synth_pwre(sample, fp);\n\tcase PERF_SYNTH_INTEL_EXSTOP:\n\t\treturn perf_sample__fprintf_synth_exstop(sample, fp);\n\tcase PERF_SYNTH_INTEL_PWRX:\n\t\treturn perf_sample__fprintf_synth_pwrx(sample, fp);\n\tcase PERF_SYNTH_INTEL_CBR:\n\t\treturn perf_sample__fprintf_synth_cbr(sample, fp);\n\tcase PERF_SYNTH_INTEL_PSB:\n\t\treturn perf_sample__fprintf_synth_psb(sample, fp);\n\tcase PERF_SYNTH_INTEL_EVT:\n\t\treturn perf_sample__fprintf_synth_evt(sample, fp);\n\tcase PERF_SYNTH_INTEL_IFLAG_CHG:\n\t\treturn perf_sample__fprintf_synth_iflag_chg(sample, fp);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int evlist__max_name_len(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\tint max = 0;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tint len = strlen(evsel__name(evsel));\n\n\t\tmax = MAX(len, max);\n\t}\n\n\treturn max;\n}\n\nstatic int data_src__fprintf(u64 data_src, FILE *fp)\n{\n\tstruct mem_info mi = { .data_src.val = data_src };\n\tchar decode[100];\n\tchar out[100];\n\tstatic int maxlen;\n\tint len;\n\n\tperf_script__meminfo_scnprintf(decode, 100, &mi);\n\n\tlen = scnprintf(out, 100, \"%16\" PRIx64 \" %s\", data_src, decode);\n\tif (maxlen < len)\n\t\tmaxlen = len;\n\n\treturn fprintf(fp, \"%-*s\", maxlen, out);\n}\n\nstruct metric_ctx {\n\tstruct perf_sample\t*sample;\n\tstruct thread\t\t*thread;\n\tstruct evsel\t*evsel;\n\tFILE \t\t\t*fp;\n};\n\nstatic void script_print_metric(struct perf_stat_config *config __maybe_unused,\n\t\t\t\tvoid *ctx, const char *color,\n\t\t\t        const char *fmt,\n\t\t\t        const char *unit, double val)\n{\n\tstruct metric_ctx *mctx = ctx;\n\n\tif (!fmt)\n\t\treturn;\n\tperf_sample__fprintf_start(NULL, mctx->sample, mctx->thread, mctx->evsel,\n\t\t\t\t   PERF_RECORD_SAMPLE, mctx->fp);\n\tfputs(\"\\tmetric: \", mctx->fp);\n\tif (color)\n\t\tcolor_fprintf(mctx->fp, color, fmt, val);\n\telse\n\t\tprintf(fmt, val);\n\tfprintf(mctx->fp, \" %s\\n\", unit);\n}\n\nstatic void script_new_line(struct perf_stat_config *config __maybe_unused,\n\t\t\t    void *ctx)\n{\n\tstruct metric_ctx *mctx = ctx;\n\n\tperf_sample__fprintf_start(NULL, mctx->sample, mctx->thread, mctx->evsel,\n\t\t\t\t   PERF_RECORD_SAMPLE, mctx->fp);\n\tfputs(\"\\tmetric: \", mctx->fp);\n}\n\nstatic void perf_sample__fprint_metric(struct perf_script *script,\n\t\t\t\t       struct thread *thread,\n\t\t\t\t       struct evsel *evsel,\n\t\t\t\t       struct perf_sample *sample,\n\t\t\t\t       FILE *fp)\n{\n\tstruct evsel *leader = evsel__leader(evsel);\n\tstruct perf_stat_output_ctx ctx = {\n\t\t.print_metric = script_print_metric,\n\t\t.new_line = script_new_line,\n\t\t.ctx = &(struct metric_ctx) {\n\t\t\t\t.sample = sample,\n\t\t\t\t.thread = thread,\n\t\t\t\t.evsel  = evsel,\n\t\t\t\t.fp     = fp,\n\t\t\t },\n\t\t.force_header = false,\n\t};\n\tstruct evsel *ev2;\n\tu64 val;\n\n\tif (!evsel->stats)\n\t\tevlist__alloc_stats(&stat_config, script->session->evlist,  false);\n\tif (evsel_script(leader)->gnum++ == 0)\n\t\tperf_stat__reset_shadow_stats();\n\tval = sample->period * evsel->scale;\n\tevsel_script(evsel)->val = val;\n\tif (evsel_script(leader)->gnum == leader->core.nr_members) {\n\t\tfor_each_group_member (ev2, leader) {\n\t\t\tperf_stat__print_shadow_stats(&stat_config, ev2,\n\t\t\t\t\t\t      evsel_script(ev2)->val,\n\t\t\t\t\t\t      sample->cpu,\n\t\t\t\t\t\t      &ctx,\n\t\t\t\t\t\t      NULL);\n\t\t}\n\t\tevsel_script(leader)->gnum = 0;\n\t}\n}\n\nstatic bool show_event(struct perf_sample *sample,\n\t\t       struct evsel *evsel,\n\t\t       struct thread *thread,\n\t\t       struct addr_location *al,\n\t\t       struct addr_location *addr_al)\n{\n\tint depth = thread_stack__depth(thread, sample->cpu);\n\n\tif (!symbol_conf.graph_function)\n\t\treturn true;\n\n\tif (thread__filter(thread)) {\n\t\tif (depth <= thread__filter_entry_depth(thread)) {\n\t\t\tthread__set_filter(thread, false);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t} else {\n\t\tconst char *s = symbol_conf.graph_function;\n\t\tu64 ip;\n\t\tconst char *name = resolve_branch_sym(sample, evsel, thread, al, addr_al,\n\t\t\t\t&ip);\n\t\tunsigned nlen;\n\n\t\tif (!name)\n\t\t\treturn false;\n\t\tnlen = strlen(name);\n\t\twhile (*s) {\n\t\t\tunsigned len = strcspn(s, \",\");\n\t\t\tif (nlen == len && !strncmp(name, s, len)) {\n\t\t\t\tthread__set_filter(thread, true);\n\t\t\t\tthread__set_filter_entry_depth(thread, depth);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ts += len;\n\t\t\tif (*s == ',')\n\t\t\t\ts++;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nstatic void process_event(struct perf_script *script,\n\t\t\t  struct perf_sample *sample, struct evsel *evsel,\n\t\t\t  struct addr_location *al,\n\t\t\t  struct addr_location *addr_al,\n\t\t\t  struct machine *machine)\n{\n\tstruct thread *thread = al->thread;\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tunsigned int type = output_type(attr->type);\n\tstruct evsel_script *es = evsel->priv;\n\tFILE *fp = es->fp;\n\tchar str[PAGE_SIZE_NAME_LEN];\n\tconst char *arch = perf_env__arch(machine->env);\n\n\tif (output[type].fields == 0)\n\t\treturn;\n\n\t++es->samples;\n\n\tperf_sample__fprintf_start(script, sample, thread, evsel,\n\t\t\t\t   PERF_RECORD_SAMPLE, fp);\n\n\tif (PRINT_FIELD(PERIOD))\n\t\tfprintf(fp, \"%10\" PRIu64 \" \", sample->period);\n\n\tif (PRINT_FIELD(EVNAME)) {\n\t\tconst char *evname = evsel__name(evsel);\n\n\t\tif (!script->name_width)\n\t\t\tscript->name_width = evlist__max_name_len(script->session->evlist);\n\n\t\tfprintf(fp, \"%*s: \", script->name_width, evname ?: \"[unknown]\");\n\t}\n\n\tif (print_flags)\n\t\tperf_sample__fprintf_flags(sample->flags, fp);\n\n\tif (is_bts_event(attr)) {\n\t\tperf_sample__fprintf_bts(sample, evsel, thread, al, addr_al, machine, fp);\n\t\treturn;\n\t}\n#ifdef HAVE_LIBTRACEEVENT\n\tif (PRINT_FIELD(TRACE) && sample->raw_data) {\n\t\tevent_format__fprintf(evsel->tp_format, sample->cpu,\n\t\t\t\t      sample->raw_data, sample->raw_size, fp);\n\t}\n#endif\n\tif (attr->type == PERF_TYPE_SYNTH && PRINT_FIELD(SYNTH))\n\t\tperf_sample__fprintf_synth(sample, evsel, fp);\n\n\tif (PRINT_FIELD(ADDR))\n\t\tperf_sample__fprintf_addr(sample, thread, attr, fp);\n\n\tif (PRINT_FIELD(DATA_SRC))\n\t\tdata_src__fprintf(sample->data_src, fp);\n\n\tif (PRINT_FIELD(WEIGHT))\n\t\tfprintf(fp, \"%16\" PRIu64, sample->weight);\n\n\tif (PRINT_FIELD(INS_LAT))\n\t\tfprintf(fp, \"%16\" PRIu16, sample->ins_lat);\n\n\tif (PRINT_FIELD(RETIRE_LAT))\n\t\tfprintf(fp, \"%16\" PRIu16, sample->retire_lat);\n\n\tif (PRINT_FIELD(CGROUP)) {\n\t\tconst char *cgrp_name;\n\t\tstruct cgroup *cgrp = cgroup__find(machine->env,\n\t\t\t\t\t\t   sample->cgroup);\n\t\tif (cgrp != NULL)\n\t\t\tcgrp_name = cgrp->name;\n\t\telse\n\t\t\tcgrp_name = \"unknown\";\n\t\tfprintf(fp, \" %s\", cgrp_name);\n\t}\n\n\tif (PRINT_FIELD(IP)) {\n\t\tstruct callchain_cursor *cursor = NULL;\n\n\t\tif (script->stitch_lbr)\n\t\t\tthread__set_lbr_stitch_enable(al->thread, true);\n\n\t\tif (symbol_conf.use_callchain && sample->callchain) {\n\t\t\tcursor = get_tls_callchain_cursor();\n\t\t\tif (thread__resolve_callchain(al->thread, cursor, evsel,\n\t\t\t\t\t\t      sample, NULL, NULL,\n\t\t\t\t\t\t      scripting_max_stack))\n\t\t\t\tcursor = NULL;\n\t\t}\n\t\tfputc(cursor ? '\\n' : ' ', fp);\n\t\tsample__fprintf_sym(sample, al, 0, output[type].print_ip_opts, cursor,\n\t\t\t\t    symbol_conf.bt_stop_list, fp);\n\t}\n\n\tif (PRINT_FIELD(IREGS))\n\t\tperf_sample__fprintf_iregs(sample, attr, arch, fp);\n\n\tif (PRINT_FIELD(UREGS))\n\t\tperf_sample__fprintf_uregs(sample, attr, arch, fp);\n\n\tif (PRINT_FIELD(BRSTACK))\n\t\tperf_sample__fprintf_brstack(sample, thread, attr, fp);\n\telse if (PRINT_FIELD(BRSTACKSYM))\n\t\tperf_sample__fprintf_brstacksym(sample, thread, attr, fp);\n\telse if (PRINT_FIELD(BRSTACKOFF))\n\t\tperf_sample__fprintf_brstackoff(sample, thread, attr, fp);\n\n\tif (evsel__is_bpf_output(evsel) && PRINT_FIELD(BPF_OUTPUT))\n\t\tperf_sample__fprintf_bpf_output(sample, fp);\n\tperf_sample__fprintf_insn(sample, attr, thread, machine, fp);\n\n\tif (PRINT_FIELD(PHYS_ADDR))\n\t\tfprintf(fp, \"%16\" PRIx64, sample->phys_addr);\n\n\tif (PRINT_FIELD(DATA_PAGE_SIZE))\n\t\tfprintf(fp, \" %s\", get_page_size_name(sample->data_page_size, str));\n\n\tif (PRINT_FIELD(CODE_PAGE_SIZE))\n\t\tfprintf(fp, \" %s\", get_page_size_name(sample->code_page_size, str));\n\n\tperf_sample__fprintf_ipc(sample, attr, fp);\n\n\tfprintf(fp, \"\\n\");\n\n\tif (PRINT_FIELD(SRCCODE)) {\n\t\tif (map__fprintf_srccode(al->map, al->addr, stdout,\n\t\t\t\t\t thread__srccode_state(thread)))\n\t\t\tprintf(\"\\n\");\n\t}\n\n\tif (PRINT_FIELD(METRIC))\n\t\tperf_sample__fprint_metric(script, thread, evsel, sample, fp);\n\n\tif (verbose > 0)\n\t\tfflush(fp);\n}\n\nstatic struct scripting_ops\t*scripting_ops;\n\nstatic void __process_stat(struct evsel *counter, u64 tstamp)\n{\n\tint nthreads = perf_thread_map__nr(counter->core.threads);\n\tint idx, thread;\n\tstruct perf_cpu cpu;\n\tstatic int header_printed;\n\n\tif (!header_printed) {\n\t\tprintf(\"%3s %8s %15s %15s %15s %15s %s\\n\",\n\t\t       \"CPU\", \"THREAD\", \"VAL\", \"ENA\", \"RUN\", \"TIME\", \"EVENT\");\n\t\theader_printed = 1;\n\t}\n\n\tfor (thread = 0; thread < nthreads; thread++) {\n\t\tperf_cpu_map__for_each_cpu(cpu, idx, evsel__cpus(counter)) {\n\t\t\tstruct perf_counts_values *counts;\n\n\t\t\tcounts = perf_counts(counter->counts, idx, thread);\n\n\t\t\tprintf(\"%3d %8d %15\" PRIu64 \" %15\" PRIu64 \" %15\" PRIu64 \" %15\" PRIu64 \" %s\\n\",\n\t\t\t\tcpu.cpu,\n\t\t\t\tperf_thread_map__pid(counter->core.threads, thread),\n\t\t\t\tcounts->val,\n\t\t\t\tcounts->ena,\n\t\t\t\tcounts->run,\n\t\t\t\ttstamp,\n\t\t\t\tevsel__name(counter));\n\t\t}\n\t}\n}\n\nstatic void process_stat(struct evsel *counter, u64 tstamp)\n{\n\tif (scripting_ops && scripting_ops->process_stat)\n\t\tscripting_ops->process_stat(&stat_config, counter, tstamp);\n\telse\n\t\t__process_stat(counter, tstamp);\n}\n\nstatic void process_stat_interval(u64 tstamp)\n{\n\tif (scripting_ops && scripting_ops->process_stat_interval)\n\t\tscripting_ops->process_stat_interval(tstamp);\n}\n\nstatic void setup_scripting(void)\n{\n#ifdef HAVE_LIBTRACEEVENT\n\tsetup_perl_scripting();\n#endif\n\tsetup_python_scripting();\n}\n\nstatic int flush_scripting(void)\n{\n\treturn scripting_ops ? scripting_ops->flush_script() : 0;\n}\n\nstatic int cleanup_scripting(void)\n{\n\tpr_debug(\"\\nperf script stopped\\n\");\n\n\treturn scripting_ops ? scripting_ops->stop_script() : 0;\n}\n\nstatic bool filter_cpu(struct perf_sample *sample)\n{\n\tif (cpu_list && sample->cpu != (u32)-1)\n\t\treturn !test_bit(sample->cpu, cpu_bitmap);\n\treturn false;\n}\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct perf_script *scr = container_of(tool, struct perf_script, tool);\n\tstruct addr_location al;\n\tstruct addr_location addr_al;\n\tint ret = 0;\n\n\t \n\taddr_location__init(&al);\n\taddr_location__init(&addr_al);\n\n\tret = dlfilter__filter_event_early(dlfilter, event, sample, evsel, machine, &al, &addr_al);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tgoto out_put;\n\t}\n\n\tif (perf_time__ranges_skip_sample(scr->ptime_range, scr->range_num,\n\t\t\t\t\t  sample->time)) {\n\t\tgoto out_put;\n\t}\n\n\tif (debug_mode) {\n\t\tif (sample->time < last_timestamp) {\n\t\t\tpr_err(\"Samples misordered, previous: %\" PRIu64\n\t\t\t\t\" this: %\" PRIu64 \"\\n\", last_timestamp,\n\t\t\t\tsample->time);\n\t\t\tnr_unordered++;\n\t\t}\n\t\tlast_timestamp = sample->time;\n\t\tgoto out_put;\n\t}\n\n\tif (filter_cpu(sample))\n\t\tgoto out_put;\n\n\tif (!al.thread && machine__resolve(machine, &al, sample) < 0) {\n\t\tpr_err(\"problem processing %d event, skipping it.\\n\",\n\t\t       event->header.type);\n\t\tret = -1;\n\t\tgoto out_put;\n\t}\n\n\tif (al.filtered)\n\t\tgoto out_put;\n\n\tif (!show_event(sample, evsel, al.thread, &al, &addr_al))\n\t\tgoto out_put;\n\n\tif (evswitch__discard(&scr->evswitch, evsel))\n\t\tgoto out_put;\n\n\tret = dlfilter__filter_event(dlfilter, event, sample, evsel, machine, &al, &addr_al);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tgoto out_put;\n\t}\n\n\tif (scripting_ops) {\n\t\tstruct addr_location *addr_al_ptr = NULL;\n\n\t\tif ((evsel->core.attr.sample_type & PERF_SAMPLE_ADDR) &&\n\t\t    sample_addr_correlates_sym(&evsel->core.attr)) {\n\t\t\tif (!addr_al.thread)\n\t\t\t\tthread__resolve(al.thread, &addr_al, sample);\n\t\t\taddr_al_ptr = &addr_al;\n\t\t}\n\t\tscripting_ops->process_event(event, sample, evsel, &al, addr_al_ptr);\n\t} else {\n\t\tprocess_event(scr, sample, evsel, &al, &addr_al, machine);\n\t}\n\nout_put:\n\taddr_location__exit(&addr_al);\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\n \nstatic struct evsel_script es_stdout;\n\nstatic int process_attr(struct perf_tool *tool, union perf_event *event,\n\t\t\tstruct evlist **pevlist)\n{\n\tstruct perf_script *scr = container_of(tool, struct perf_script, tool);\n\tstruct evlist *evlist;\n\tstruct evsel *evsel, *pos;\n\tu64 sample_type;\n\tint err;\n\n\terr = perf_event__process_attr(tool, event, pevlist);\n\tif (err)\n\t\treturn err;\n\n\tevlist = *pevlist;\n\tevsel = evlist__last(*pevlist);\n\n\tif (!evsel->priv) {\n\t\tif (scr->per_event_dump) { \n\t\t\tevsel->priv = evsel_script__new(evsel, scr->session->data);\n\t\t\tif (!evsel->priv)\n\t\t\t\treturn -ENOMEM;\n\t\t} else {  \n\t\t\tes_stdout.fp = stdout;\n\t\t\tevsel->priv = &es_stdout;\n\t\t}\n\t}\n\n\tif (evsel->core.attr.type >= PERF_TYPE_MAX &&\n\t    evsel->core.attr.type != PERF_TYPE_SYNTH)\n\t\treturn 0;\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tif (pos->core.attr.type == evsel->core.attr.type && pos != evsel)\n\t\t\treturn 0;\n\t}\n\n\tif (evsel->core.attr.sample_type) {\n\t\terr = evsel__check_attr(evsel, scr->session);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tsample_type = evlist__combined_sample_type(evlist);\n\tcallchain_param_setup(sample_type, perf_env__arch((*pevlist)->env));\n\n\t \n\tif (symbol_conf.use_callchain &&\n\t    (sample_type & PERF_SAMPLE_CALLCHAIN ||\n\t     sample_type & PERF_SAMPLE_BRANCH_STACK ||\n\t     (sample_type & PERF_SAMPLE_REGS_USER &&\n\t      sample_type & PERF_SAMPLE_STACK_USER))) {\n\t\tint type = output_type(evsel->core.attr.type);\n\n\t\tif (!(output[type].user_unset_fields & PERF_OUTPUT_IP))\n\t\t\toutput[type].fields |= PERF_OUTPUT_IP;\n\t\tif (!(output[type].user_unset_fields & PERF_OUTPUT_SYM))\n\t\t\toutput[type].fields |= PERF_OUTPUT_SYM;\n\t}\n\tset_print_ip_opts(&evsel->core.attr);\n\treturn 0;\n}\n\nstatic int print_event_with_time(struct perf_tool *tool,\n\t\t\t\t union perf_event *event,\n\t\t\t\t struct perf_sample *sample,\n\t\t\t\t struct machine *machine,\n\t\t\t\t pid_t pid, pid_t tid, u64 timestamp)\n{\n\tstruct perf_script *script = container_of(tool, struct perf_script, tool);\n\tstruct perf_session *session = script->session;\n\tstruct evsel *evsel = evlist__id2evsel(session->evlist, sample->id);\n\tstruct thread *thread = NULL;\n\n\tif (evsel && !evsel->core.attr.sample_id_all) {\n\t\tsample->cpu = 0;\n\t\tsample->time = timestamp;\n\t\tsample->pid = pid;\n\t\tsample->tid = tid;\n\t}\n\n\tif (filter_cpu(sample))\n\t\treturn 0;\n\n\tif (tid != -1)\n\t\tthread = machine__findnew_thread(machine, pid, tid);\n\n\tif (evsel) {\n\t\tperf_sample__fprintf_start(script, sample, thread, evsel,\n\t\t\t\t\t   event->header.type, stdout);\n\t}\n\n\tperf_event__fprintf(event, machine, stdout);\n\n\tthread__put(thread);\n\n\treturn 0;\n}\n\nstatic int print_event(struct perf_tool *tool, union perf_event *event,\n\t\t       struct perf_sample *sample, struct machine *machine,\n\t\t       pid_t pid, pid_t tid)\n{\n\treturn print_event_with_time(tool, event, sample, machine, pid, tid, 0);\n}\n\nstatic int process_comm_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct machine *machine)\n{\n\tif (perf_event__process_comm(tool, event, sample, machine) < 0)\n\t\treturn -1;\n\n\treturn print_event(tool, event, sample, machine, event->comm.pid,\n\t\t\t   event->comm.tid);\n}\n\nstatic int process_namespaces_event(struct perf_tool *tool,\n\t\t\t\t    union perf_event *event,\n\t\t\t\t    struct perf_sample *sample,\n\t\t\t\t    struct machine *machine)\n{\n\tif (perf_event__process_namespaces(tool, event, sample, machine) < 0)\n\t\treturn -1;\n\n\treturn print_event(tool, event, sample, machine, event->namespaces.pid,\n\t\t\t   event->namespaces.tid);\n}\n\nstatic int process_cgroup_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct machine *machine)\n{\n\tif (perf_event__process_cgroup(tool, event, sample, machine) < 0)\n\t\treturn -1;\n\n\treturn print_event(tool, event, sample, machine, sample->pid,\n\t\t\t    sample->tid);\n}\n\nstatic int process_fork_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct machine *machine)\n{\n\tif (perf_event__process_fork(tool, event, sample, machine) < 0)\n\t\treturn -1;\n\n\treturn print_event_with_time(tool, event, sample, machine,\n\t\t\t\t     event->fork.pid, event->fork.tid,\n\t\t\t\t     event->fork.time);\n}\nstatic int process_exit_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct machine *machine)\n{\n\t \n\tif (print_event_with_time(tool, event, sample, machine, event->fork.pid,\n\t\t\t\t  event->fork.tid, event->fork.time))\n\t\treturn -1;\n\n\treturn perf_event__process_exit(tool, event, sample, machine);\n}\n\nstatic int process_mmap_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct machine *machine)\n{\n\tif (perf_event__process_mmap(tool, event, sample, machine) < 0)\n\t\treturn -1;\n\n\treturn print_event(tool, event, sample, machine, event->mmap.pid,\n\t\t\t   event->mmap.tid);\n}\n\nstatic int process_mmap2_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct machine *machine)\n{\n\tif (perf_event__process_mmap2(tool, event, sample, machine) < 0)\n\t\treturn -1;\n\n\treturn print_event(tool, event, sample, machine, event->mmap2.pid,\n\t\t\t   event->mmap2.tid);\n}\n\nstatic int process_switch_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct perf_script *script = container_of(tool, struct perf_script, tool);\n\n\tif (perf_event__process_switch(tool, event, sample, machine) < 0)\n\t\treturn -1;\n\n\tif (scripting_ops && scripting_ops->process_switch && !filter_cpu(sample))\n\t\tscripting_ops->process_switch(event, sample, machine);\n\n\tif (!script->show_switch_events)\n\t\treturn 0;\n\n\treturn print_event(tool, event, sample, machine, sample->pid,\n\t\t\t   sample->tid);\n}\n\nstatic int process_auxtrace_error(struct perf_session *session,\n\t\t\t\t  union perf_event *event)\n{\n\tif (scripting_ops && scripting_ops->process_auxtrace_error) {\n\t\tscripting_ops->process_auxtrace_error(session, event);\n\t\treturn 0;\n\t}\n\n\treturn perf_event__process_auxtrace_error(session, event);\n}\n\nstatic int\nprocess_lost_event(struct perf_tool *tool,\n\t\t   union perf_event *event,\n\t\t   struct perf_sample *sample,\n\t\t   struct machine *machine)\n{\n\treturn print_event(tool, event, sample, machine, sample->pid,\n\t\t\t   sample->tid);\n}\n\nstatic int\nprocess_throttle_event(struct perf_tool *tool __maybe_unused,\n\t\t       union perf_event *event,\n\t\t       struct perf_sample *sample,\n\t\t       struct machine *machine)\n{\n\tif (scripting_ops && scripting_ops->process_throttle)\n\t\tscripting_ops->process_throttle(event, sample, machine);\n\treturn 0;\n}\n\nstatic int\nprocess_finished_round_event(struct perf_tool *tool __maybe_unused,\n\t\t\t     union perf_event *event,\n\t\t\t     struct ordered_events *oe __maybe_unused)\n\n{\n\tperf_event__fprintf(event, NULL, stdout);\n\treturn 0;\n}\n\nstatic int\nprocess_bpf_events(struct perf_tool *tool __maybe_unused,\n\t\t   union perf_event *event,\n\t\t   struct perf_sample *sample,\n\t\t   struct machine *machine)\n{\n\tif (machine__process_ksymbol(machine, event, sample) < 0)\n\t\treturn -1;\n\n\treturn print_event(tool, event, sample, machine, sample->pid,\n\t\t\t   sample->tid);\n}\n\nstatic int process_text_poke_events(struct perf_tool *tool,\n\t\t\t\t    union perf_event *event,\n\t\t\t\t    struct perf_sample *sample,\n\t\t\t\t    struct machine *machine)\n{\n\tif (perf_event__process_text_poke(tool, event, sample, machine) < 0)\n\t\treturn -1;\n\n\treturn print_event(tool, event, sample, machine, sample->pid,\n\t\t\t   sample->tid);\n}\n\nstatic void sig_handler(int sig __maybe_unused)\n{\n\tsession_done = 1;\n}\n\nstatic void perf_script__fclose_per_event_dump(struct perf_script *script)\n{\n\tstruct evlist *evlist = script->session->evlist;\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (!evsel->priv)\n\t\t\tbreak;\n\t\tevsel_script__delete(evsel->priv);\n\t\tevsel->priv = NULL;\n\t}\n}\n\nstatic int perf_script__fopen_per_event_dump(struct perf_script *script)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(script->session->evlist, evsel) {\n\t\t \n\t\tif (evsel->priv != NULL)\n\t\t\tcontinue;\n\n\t\tevsel->priv = evsel_script__new(evsel, script->session->data);\n\t\tif (evsel->priv == NULL)\n\t\t\tgoto out_err_fclose;\n\t}\n\n\treturn 0;\n\nout_err_fclose:\n\tperf_script__fclose_per_event_dump(script);\n\treturn -1;\n}\n\nstatic int perf_script__setup_per_event_dump(struct perf_script *script)\n{\n\tstruct evsel *evsel;\n\n\tif (script->per_event_dump)\n\t\treturn perf_script__fopen_per_event_dump(script);\n\n\tes_stdout.fp = stdout;\n\n\tevlist__for_each_entry(script->session->evlist, evsel)\n\t\tevsel->priv = &es_stdout;\n\n\treturn 0;\n}\n\nstatic void perf_script__exit_per_event_dump_stats(struct perf_script *script)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(script->session->evlist, evsel) {\n\t\tstruct evsel_script *es = evsel->priv;\n\n\t\tevsel_script__fprintf(es, stdout);\n\t\tevsel_script__delete(es);\n\t\tevsel->priv = NULL;\n\t}\n}\n\nstatic void perf_script__exit(struct perf_script *script)\n{\n\tperf_thread_map__put(script->threads);\n\tperf_cpu_map__put(script->cpus);\n}\n\nstatic int __cmd_script(struct perf_script *script)\n{\n\tint ret;\n\n\tsignal(SIGINT, sig_handler);\n\n\t \n\tif (script->show_task_events) {\n\t\tscript->tool.comm = process_comm_event;\n\t\tscript->tool.fork = process_fork_event;\n\t\tscript->tool.exit = process_exit_event;\n\t}\n\tif (script->show_mmap_events) {\n\t\tscript->tool.mmap = process_mmap_event;\n\t\tscript->tool.mmap2 = process_mmap2_event;\n\t}\n\tif (script->show_switch_events || (scripting_ops && scripting_ops->process_switch))\n\t\tscript->tool.context_switch = process_switch_event;\n\tif (scripting_ops && scripting_ops->process_auxtrace_error)\n\t\tscript->tool.auxtrace_error = process_auxtrace_error;\n\tif (script->show_namespace_events)\n\t\tscript->tool.namespaces = process_namespaces_event;\n\tif (script->show_cgroup_events)\n\t\tscript->tool.cgroup = process_cgroup_event;\n\tif (script->show_lost_events)\n\t\tscript->tool.lost = process_lost_event;\n\tif (script->show_round_events) {\n\t\tscript->tool.ordered_events = false;\n\t\tscript->tool.finished_round = process_finished_round_event;\n\t}\n\tif (script->show_bpf_events) {\n\t\tscript->tool.ksymbol = process_bpf_events;\n\t\tscript->tool.bpf     = process_bpf_events;\n\t}\n\tif (script->show_text_poke_events) {\n\t\tscript->tool.ksymbol   = process_bpf_events;\n\t\tscript->tool.text_poke = process_text_poke_events;\n\t}\n\n\tif (perf_script__setup_per_event_dump(script)) {\n\t\tpr_err(\"Couldn't create the per event dump files\\n\");\n\t\treturn -1;\n\t}\n\n\tret = perf_session__process_events(script->session);\n\n\tif (script->per_event_dump)\n\t\tperf_script__exit_per_event_dump_stats(script);\n\n\tif (debug_mode)\n\t\tpr_err(\"Misordered timestamps: %\" PRIu64 \"\\n\", nr_unordered);\n\n\treturn ret;\n}\n\nstruct script_spec {\n\tstruct list_head\tnode;\n\tstruct scripting_ops\t*ops;\n\tchar\t\t\tspec[];\n};\n\nstatic LIST_HEAD(script_specs);\n\nstatic struct script_spec *script_spec__new(const char *spec,\n\t\t\t\t\t    struct scripting_ops *ops)\n{\n\tstruct script_spec *s = malloc(sizeof(*s) + strlen(spec) + 1);\n\n\tif (s != NULL) {\n\t\tstrcpy(s->spec, spec);\n\t\ts->ops = ops;\n\t}\n\n\treturn s;\n}\n\nstatic void script_spec__add(struct script_spec *s)\n{\n\tlist_add_tail(&s->node, &script_specs);\n}\n\nstatic struct script_spec *script_spec__find(const char *spec)\n{\n\tstruct script_spec *s;\n\n\tlist_for_each_entry(s, &script_specs, node)\n\t\tif (strcasecmp(s->spec, spec) == 0)\n\t\t\treturn s;\n\treturn NULL;\n}\n\nint script_spec_register(const char *spec, struct scripting_ops *ops)\n{\n\tstruct script_spec *s;\n\n\ts = script_spec__find(spec);\n\tif (s)\n\t\treturn -1;\n\n\ts = script_spec__new(spec, ops);\n\tif (!s)\n\t\treturn -1;\n\telse\n\t\tscript_spec__add(s);\n\n\treturn 0;\n}\n\nstatic struct scripting_ops *script_spec__lookup(const char *spec)\n{\n\tstruct script_spec *s = script_spec__find(spec);\n\tif (!s)\n\t\treturn NULL;\n\n\treturn s->ops;\n}\n\nstatic void list_available_languages(void)\n{\n\tstruct script_spec *s;\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Scripting language extensions (used in \"\n\t\t\"perf script -s [spec:]script.[spec]):\\n\\n\");\n\n\tlist_for_each_entry(s, &script_specs, node)\n\t\tfprintf(stderr, \"  %-42s [%s]\\n\", s->spec, s->ops->name);\n\n\tfprintf(stderr, \"\\n\");\n}\n\n \nstatic char *find_script(const char *script)\n{\n\tchar path[PATH_MAX];\n\n\tif (!scripting_ops) {\n\t\tconst char *ext = strrchr(script, '.');\n\n\t\tif (!ext)\n\t\t\treturn NULL;\n\n\t\tscripting_ops = script_spec__lookup(++ext);\n\t\tif (!scripting_ops)\n\t\t\treturn NULL;\n\t}\n\n\tif (access(script, R_OK)) {\n\t\tchar *exec_path = get_argv_exec_path();\n\n\t\tif (!exec_path)\n\t\t\treturn NULL;\n\t\tsnprintf(path, sizeof(path), \"%s/scripts/%s/%s\",\n\t\t\t exec_path, scripting_ops->dirname, script);\n\t\tfree(exec_path);\n\t\tscript = path;\n\t\tif (access(script, R_OK))\n\t\t\treturn NULL;\n\t}\n\treturn strdup(script);\n}\n\nstatic int parse_scriptname(const struct option *opt __maybe_unused,\n\t\t\t    const char *str, int unset __maybe_unused)\n{\n\tchar spec[PATH_MAX];\n\tconst char *script, *ext;\n\tint len;\n\n\tif (strcmp(str, \"lang\") == 0) {\n\t\tlist_available_languages();\n\t\texit(0);\n\t}\n\n\tscript = strchr(str, ':');\n\tif (script) {\n\t\tlen = script - str;\n\t\tif (len >= PATH_MAX) {\n\t\t\tfprintf(stderr, \"invalid language specifier\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrncpy(spec, str, len);\n\t\tspec[len] = '\\0';\n\t\tscripting_ops = script_spec__lookup(spec);\n\t\tif (!scripting_ops) {\n\t\t\tfprintf(stderr, \"invalid language specifier\");\n\t\t\treturn -1;\n\t\t}\n\t\tscript++;\n\t} else {\n\t\tscript = str;\n\t\text = strrchr(script, '.');\n\t\tif (!ext) {\n\t\t\tfprintf(stderr, \"invalid script extension\");\n\t\t\treturn -1;\n\t\t}\n\t\tscripting_ops = script_spec__lookup(++ext);\n\t\tif (!scripting_ops) {\n\t\t\tfprintf(stderr, \"invalid script extension\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tscript_name = find_script(script);\n\tif (!script_name)\n\t\tscript_name = strdup(script);\n\n\treturn 0;\n}\n\nstatic int parse_output_fields(const struct option *opt __maybe_unused,\n\t\t\t    const char *arg, int unset __maybe_unused)\n{\n\tchar *tok, *strtok_saveptr = NULL;\n\tint i, imax = ARRAY_SIZE(all_output_options);\n\tint j;\n\tint rc = 0;\n\tchar *str = strdup(arg);\n\tint type = -1;\n\tenum { DEFAULT, SET, ADD, REMOVE } change = DEFAULT;\n\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t \n\ttok = strchr(str, ':');\n\tif (tok) {\n\t\t*tok = '\\0';\n\t\ttok++;\n\t\tif (!strcmp(str, \"hw\"))\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t\telse if (!strcmp(str, \"sw\"))\n\t\t\ttype = PERF_TYPE_SOFTWARE;\n\t\telse if (!strcmp(str, \"trace\"))\n\t\t\ttype = PERF_TYPE_TRACEPOINT;\n\t\telse if (!strcmp(str, \"raw\"))\n\t\t\ttype = PERF_TYPE_RAW;\n\t\telse if (!strcmp(str, \"break\"))\n\t\t\ttype = PERF_TYPE_BREAKPOINT;\n\t\telse if (!strcmp(str, \"synth\"))\n\t\t\ttype = OUTPUT_TYPE_SYNTH;\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid event type in field string.\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (output[type].user_set)\n\t\t\tpr_warning(\"Overriding previous field request for %s events.\\n\",\n\t\t\t\t   event_type(type));\n\n\t\t \n\t\tif (strchr(tok, '+') || strchr(tok, '-'))\n\t\t\tgoto parse;\n\n\t\toutput[type].fields = 0;\n\t\toutput[type].user_set = true;\n\t\toutput[type].wildcard_set = false;\n\n\t} else {\n\t\ttok = str;\n\t\tif (strlen(str) == 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Cannot set fields to 'none' for all event types.\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (strchr(str, '+') || strchr(str, '-'))\n\t\t\tgoto parse;\n\n\t\tif (output_set_by_user())\n\t\t\tpr_warning(\"Overriding previous field request for all events.\\n\");\n\n\t\tfor (j = 0; j < OUTPUT_TYPE_MAX; ++j) {\n\t\t\toutput[j].fields = 0;\n\t\t\toutput[j].user_set = true;\n\t\t\toutput[j].wildcard_set = true;\n\t\t}\n\t}\n\nparse:\n\tfor (tok = strtok_r(tok, \",\", &strtok_saveptr); tok; tok = strtok_r(NULL, \",\", &strtok_saveptr)) {\n\t\tif (*tok == '+') {\n\t\t\tif (change == SET)\n\t\t\t\tgoto out_badmix;\n\t\t\tchange = ADD;\n\t\t\ttok++;\n\t\t} else if (*tok == '-') {\n\t\t\tif (change == SET)\n\t\t\t\tgoto out_badmix;\n\t\t\tchange = REMOVE;\n\t\t\ttok++;\n\t\t} else {\n\t\t\tif (change != SET && change != DEFAULT)\n\t\t\t\tgoto out_badmix;\n\t\t\tchange = SET;\n\t\t}\n\n\t\tfor (i = 0; i < imax; ++i) {\n\t\t\tif (strcmp(tok, all_output_options[i].str) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == imax && strcmp(tok, \"flags\") == 0) {\n\t\t\tprint_flags = change != REMOVE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == imax) {\n\t\t\tfprintf(stderr, \"Invalid field requested.\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (type == -1) {\n\t\t\t \n\t\t\tfor (j = 0; j < OUTPUT_TYPE_MAX; ++j) {\n\t\t\t\tif (output[j].invalid_fields & all_output_options[i].field) {\n\t\t\t\t\tpr_warning(\"\\'%s\\' not valid for %s events. Ignoring.\\n\",\n\t\t\t\t\t\t   all_output_options[i].str, event_type(j));\n\t\t\t\t} else {\n\t\t\t\t\tif (change == REMOVE) {\n\t\t\t\t\t\toutput[j].fields &= ~all_output_options[i].field;\n\t\t\t\t\t\toutput[j].user_set_fields &= ~all_output_options[i].field;\n\t\t\t\t\t\toutput[j].user_unset_fields |= all_output_options[i].field;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput[j].fields |= all_output_options[i].field;\n\t\t\t\t\t\toutput[j].user_set_fields |= all_output_options[i].field;\n\t\t\t\t\t\toutput[j].user_unset_fields &= ~all_output_options[i].field;\n\t\t\t\t\t}\n\t\t\t\t\toutput[j].user_set = true;\n\t\t\t\t\toutput[j].wildcard_set = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (output[type].invalid_fields & all_output_options[i].field) {\n\t\t\t\tfprintf(stderr, \"\\'%s\\' not valid for %s events.\\n\",\n\t\t\t\t\t all_output_options[i].str, event_type(type));\n\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (change == REMOVE)\n\t\t\t\toutput[type].fields &= ~all_output_options[i].field;\n\t\t\telse\n\t\t\t\toutput[type].fields |= all_output_options[i].field;\n\t\t\toutput[type].user_set = true;\n\t\t\toutput[type].wildcard_set = true;\n\t\t}\n\t}\n\n\tif (type >= 0) {\n\t\tif (output[type].fields == 0) {\n\t\t\tpr_debug(\"No fields requested for %s type. \"\n\t\t\t\t \"Events will not be displayed.\\n\", event_type(type));\n\t\t}\n\t}\n\tgoto out;\n\nout_badmix:\n\tfprintf(stderr, \"Cannot mix +-field with overridden fields\\n\");\n\trc = -EINVAL;\nout:\n\tfree(str);\n\treturn rc;\n}\n\n#define for_each_lang(scripts_path, scripts_dir, lang_dirent)\t\t\\\n\twhile ((lang_dirent = readdir(scripts_dir)) != NULL)\t\t\\\n\t\tif ((lang_dirent->d_type == DT_DIR ||\t\t\t\\\n\t\t     (lang_dirent->d_type == DT_UNKNOWN &&\t\t\\\n\t\t      is_directory(scripts_path, lang_dirent))) &&\t\\\n\t\t    (strcmp(lang_dirent->d_name, \".\")) &&\t\t\\\n\t\t    (strcmp(lang_dirent->d_name, \"..\")))\n\n#define for_each_script(lang_path, lang_dir, script_dirent)\t\t\\\n\twhile ((script_dirent = readdir(lang_dir)) != NULL)\t\t\\\n\t\tif (script_dirent->d_type != DT_DIR &&\t\t\t\\\n\t\t    (script_dirent->d_type != DT_UNKNOWN ||\t\t\\\n\t\t     !is_directory(lang_path, script_dirent)))\n\n\n#define RECORD_SUFFIX\t\t\t\"-record\"\n#define REPORT_SUFFIX\t\t\t\"-report\"\n\nstruct script_desc {\n\tstruct list_head\tnode;\n\tchar\t\t\t*name;\n\tchar\t\t\t*half_liner;\n\tchar\t\t\t*args;\n};\n\nstatic LIST_HEAD(script_descs);\n\nstatic struct script_desc *script_desc__new(const char *name)\n{\n\tstruct script_desc *s = zalloc(sizeof(*s));\n\n\tif (s != NULL && name)\n\t\ts->name = strdup(name);\n\n\treturn s;\n}\n\nstatic void script_desc__delete(struct script_desc *s)\n{\n\tzfree(&s->name);\n\tzfree(&s->half_liner);\n\tzfree(&s->args);\n\tfree(s);\n}\n\nstatic void script_desc__add(struct script_desc *s)\n{\n\tlist_add_tail(&s->node, &script_descs);\n}\n\nstatic struct script_desc *script_desc__find(const char *name)\n{\n\tstruct script_desc *s;\n\n\tlist_for_each_entry(s, &script_descs, node)\n\t\tif (strcasecmp(s->name, name) == 0)\n\t\t\treturn s;\n\treturn NULL;\n}\n\nstatic struct script_desc *script_desc__findnew(const char *name)\n{\n\tstruct script_desc *s = script_desc__find(name);\n\n\tif (s)\n\t\treturn s;\n\n\ts = script_desc__new(name);\n\tif (!s)\n\t\treturn NULL;\n\n\tscript_desc__add(s);\n\n\treturn s;\n}\n\nstatic const char *ends_with(const char *str, const char *suffix)\n{\n\tsize_t suffix_len = strlen(suffix);\n\tconst char *p = str;\n\n\tif (strlen(str) > suffix_len) {\n\t\tp = str + strlen(str) - suffix_len;\n\t\tif (!strncmp(p, suffix, suffix_len))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\nstatic int read_script_info(struct script_desc *desc, const char *filename)\n{\n\tchar line[BUFSIZ], *p;\n\tFILE *fp;\n\n\tfp = fopen(filename, \"r\");\n\tif (!fp)\n\t\treturn -1;\n\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tp = skip_spaces(line);\n\t\tif (strlen(p) == 0)\n\t\t\tcontinue;\n\t\tif (*p != '#')\n\t\t\tcontinue;\n\t\tp++;\n\t\tif (strlen(p) && *p == '!')\n\t\t\tcontinue;\n\n\t\tp = skip_spaces(p);\n\t\tif (strlen(p) && p[strlen(p) - 1] == '\\n')\n\t\t\tp[strlen(p) - 1] = '\\0';\n\n\t\tif (!strncmp(p, \"description:\", strlen(\"description:\"))) {\n\t\t\tp += strlen(\"description:\");\n\t\t\tdesc->half_liner = strdup(skip_spaces(p));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(p, \"args:\", strlen(\"args:\"))) {\n\t\t\tp += strlen(\"args:\");\n\t\t\tdesc->args = strdup(skip_spaces(p));\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\treturn 0;\n}\n\nstatic char *get_script_root(struct dirent *script_dirent, const char *suffix)\n{\n\tchar *script_root, *str;\n\n\tscript_root = strdup(script_dirent->d_name);\n\tif (!script_root)\n\t\treturn NULL;\n\n\tstr = (char *)ends_with(script_root, suffix);\n\tif (!str) {\n\t\tfree(script_root);\n\t\treturn NULL;\n\t}\n\n\t*str = '\\0';\n\treturn script_root;\n}\n\nstatic int list_available_scripts(const struct option *opt __maybe_unused,\n\t\t\t\t  const char *s __maybe_unused,\n\t\t\t\t  int unset __maybe_unused)\n{\n\tstruct dirent *script_dirent, *lang_dirent;\n\tchar *buf, *scripts_path, *script_path, *lang_path, *first_half;\n\tDIR *scripts_dir, *lang_dir;\n\tstruct script_desc *desc;\n\tchar *script_root;\n\n\tbuf = malloc(3 * MAXPATHLEN + BUFSIZ);\n\tif (!buf) {\n\t\tpr_err(\"malloc failed\\n\");\n\t\texit(-1);\n\t}\n\tscripts_path = buf;\n\tscript_path = buf + MAXPATHLEN;\n\tlang_path = buf + 2 * MAXPATHLEN;\n\tfirst_half = buf + 3 * MAXPATHLEN;\n\n\tsnprintf(scripts_path, MAXPATHLEN, \"%s/scripts\", get_argv_exec_path());\n\n\tscripts_dir = opendir(scripts_path);\n\tif (!scripts_dir) {\n\t\tfprintf(stdout,\n\t\t\t\"open(%s) failed.\\n\"\n\t\t\t\"Check \\\"PERF_EXEC_PATH\\\" env to set scripts dir.\\n\",\n\t\t\tscripts_path);\n\t\tfree(buf);\n\t\texit(-1);\n\t}\n\n\tfor_each_lang(scripts_path, scripts_dir, lang_dirent) {\n\t\tscnprintf(lang_path, MAXPATHLEN, \"%s/%s/bin\", scripts_path,\n\t\t\t  lang_dirent->d_name);\n\t\tlang_dir = opendir(lang_path);\n\t\tif (!lang_dir)\n\t\t\tcontinue;\n\n\t\tfor_each_script(lang_path, lang_dir, script_dirent) {\n\t\t\tscript_root = get_script_root(script_dirent, REPORT_SUFFIX);\n\t\t\tif (script_root) {\n\t\t\t\tdesc = script_desc__findnew(script_root);\n\t\t\t\tscnprintf(script_path, MAXPATHLEN, \"%s/%s\",\n\t\t\t\t\t  lang_path, script_dirent->d_name);\n\t\t\t\tread_script_info(desc, script_path);\n\t\t\t\tfree(script_root);\n\t\t\t}\n\t\t}\n\t}\n\n\tfprintf(stdout, \"List of available trace scripts:\\n\");\n\tlist_for_each_entry(desc, &script_descs, node) {\n\t\tsprintf(first_half, \"%s %s\", desc->name,\n\t\t\tdesc->args ? desc->args : \"\");\n\t\tfprintf(stdout, \"  %-36s %s\\n\", first_half,\n\t\t\tdesc->half_liner ? desc->half_liner : \"\");\n\t}\n\n\tfree(buf);\n\texit(0);\n}\n\nstatic int add_dlarg(const struct option *opt __maybe_unused,\n\t\t     const char *s, int unset __maybe_unused)\n{\n\tchar *arg = strdup(s);\n\tvoid *a;\n\n\tif (!arg)\n\t\treturn -1;\n\n\ta = realloc(dlargv, sizeof(dlargv[0]) * (dlargc + 1));\n\tif (!a) {\n\t\tfree(arg);\n\t\treturn -1;\n\t}\n\n\tdlargv = a;\n\tdlargv[dlargc++] = arg;\n\n\treturn 0;\n}\n\nstatic void free_dlarg(void)\n{\n\twhile (dlargc--)\n\t\tfree(dlargv[dlargc]);\n\tfree(dlargv);\n}\n\n \nstatic int check_ev_match(char *dir_name, char *scriptname,\n\t\t\tstruct perf_session *session)\n{\n\tchar filename[MAXPATHLEN], evname[128];\n\tchar line[BUFSIZ], *p;\n\tstruct evsel *pos;\n\tint match, len;\n\tFILE *fp;\n\n\tscnprintf(filename, MAXPATHLEN, \"%s/bin/%s-record\", dir_name, scriptname);\n\n\tfp = fopen(filename, \"r\");\n\tif (!fp)\n\t\treturn -1;\n\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tp = skip_spaces(line);\n\t\tif (*p == '#')\n\t\t\tcontinue;\n\n\t\twhile (strlen(p)) {\n\t\t\tp = strstr(p, \"-e\");\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tp += 2;\n\t\t\tp = skip_spaces(p);\n\t\t\tlen = strcspn(p, \" \\t\");\n\t\t\tif (!len)\n\t\t\t\tbreak;\n\n\t\t\tsnprintf(evname, len + 1, \"%s\", p);\n\n\t\t\tmatch = 0;\n\t\t\tevlist__for_each_entry(session->evlist, pos) {\n\t\t\t\tif (!strcmp(evsel__name(pos), evname)) {\n\t\t\t\t\tmatch = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!match) {\n\t\t\t\tfclose(fp);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn 0;\n}\n\n \nint find_scripts(char **scripts_array, char **scripts_path_array, int num,\n\t\t int pathlen)\n{\n\tstruct dirent *script_dirent, *lang_dirent;\n\tchar scripts_path[MAXPATHLEN], lang_path[MAXPATHLEN];\n\tDIR *scripts_dir, *lang_dir;\n\tstruct perf_session *session;\n\tstruct perf_data data = {\n\t\t.path = input_name,\n\t\t.mode = PERF_DATA_MODE_READ,\n\t};\n\tchar *temp;\n\tint i = 0;\n\n\tsession = perf_session__new(&data, NULL);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tsnprintf(scripts_path, MAXPATHLEN, \"%s/scripts\", get_argv_exec_path());\n\n\tscripts_dir = opendir(scripts_path);\n\tif (!scripts_dir) {\n\t\tperf_session__delete(session);\n\t\treturn -1;\n\t}\n\n\tfor_each_lang(scripts_path, scripts_dir, lang_dirent) {\n\t\tscnprintf(lang_path, MAXPATHLEN, \"%s/%s\", scripts_path,\n\t\t\t  lang_dirent->d_name);\n#ifndef HAVE_LIBPERL_SUPPORT\n\t\tif (strstr(lang_path, \"perl\"))\n\t\t\tcontinue;\n#endif\n#ifndef HAVE_LIBPYTHON_SUPPORT\n\t\tif (strstr(lang_path, \"python\"))\n\t\t\tcontinue;\n#endif\n\n\t\tlang_dir = opendir(lang_path);\n\t\tif (!lang_dir)\n\t\t\tcontinue;\n\n\t\tfor_each_script(lang_path, lang_dir, script_dirent) {\n\t\t\t \n\t\t\tif (strstr(script_dirent->d_name, \"top.\"))\n\t\t\t\tcontinue;\n\t\t\tif (i >= num)\n\t\t\t\tbreak;\n\t\t\tsnprintf(scripts_path_array[i], pathlen, \"%s/%s\",\n\t\t\t\tlang_path,\n\t\t\t\tscript_dirent->d_name);\n\t\t\ttemp = strchr(script_dirent->d_name, '.');\n\t\t\tsnprintf(scripts_array[i],\n\t\t\t\t(temp - script_dirent->d_name) + 1,\n\t\t\t\t\"%s\", script_dirent->d_name);\n\n\t\t\tif (check_ev_match(lang_path,\n\t\t\t\t\tscripts_array[i], session))\n\t\t\t\tcontinue;\n\n\t\t\ti++;\n\t\t}\n\t\tclosedir(lang_dir);\n\t}\n\n\tclosedir(scripts_dir);\n\tperf_session__delete(session);\n\treturn i;\n}\n\nstatic char *get_script_path(const char *script_root, const char *suffix)\n{\n\tstruct dirent *script_dirent, *lang_dirent;\n\tchar scripts_path[MAXPATHLEN];\n\tchar script_path[MAXPATHLEN];\n\tDIR *scripts_dir, *lang_dir;\n\tchar lang_path[MAXPATHLEN];\n\tchar *__script_root;\n\n\tsnprintf(scripts_path, MAXPATHLEN, \"%s/scripts\", get_argv_exec_path());\n\n\tscripts_dir = opendir(scripts_path);\n\tif (!scripts_dir)\n\t\treturn NULL;\n\n\tfor_each_lang(scripts_path, scripts_dir, lang_dirent) {\n\t\tscnprintf(lang_path, MAXPATHLEN, \"%s/%s/bin\", scripts_path,\n\t\t\t  lang_dirent->d_name);\n\t\tlang_dir = opendir(lang_path);\n\t\tif (!lang_dir)\n\t\t\tcontinue;\n\n\t\tfor_each_script(lang_path, lang_dir, script_dirent) {\n\t\t\t__script_root = get_script_root(script_dirent, suffix);\n\t\t\tif (__script_root && !strcmp(script_root, __script_root)) {\n\t\t\t\tfree(__script_root);\n\t\t\t\tclosedir(scripts_dir);\n\t\t\t\tscnprintf(script_path, MAXPATHLEN, \"%s/%s\",\n\t\t\t\t\t  lang_path, script_dirent->d_name);\n\t\t\t\tclosedir(lang_dir);\n\t\t\t\treturn strdup(script_path);\n\t\t\t}\n\t\t\tfree(__script_root);\n\t\t}\n\t\tclosedir(lang_dir);\n\t}\n\tclosedir(scripts_dir);\n\n\treturn NULL;\n}\n\nstatic bool is_top_script(const char *script_path)\n{\n\treturn ends_with(script_path, \"top\") != NULL;\n}\n\nstatic int has_required_arg(char *script_path)\n{\n\tstruct script_desc *desc;\n\tint n_args = 0;\n\tchar *p;\n\n\tdesc = script_desc__new(NULL);\n\n\tif (read_script_info(desc, script_path))\n\t\tgoto out;\n\n\tif (!desc->args)\n\t\tgoto out;\n\n\tfor (p = desc->args; *p; p++)\n\t\tif (*p == '<')\n\t\t\tn_args++;\nout:\n\tscript_desc__delete(desc);\n\n\treturn n_args;\n}\n\nstatic int have_cmd(int argc, const char **argv)\n{\n\tchar **__argv = malloc(sizeof(const char *) * argc);\n\n\tif (!__argv) {\n\t\tpr_err(\"malloc failed\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(__argv, argv, sizeof(const char *) * argc);\n\targc = parse_options(argc, (const char **)__argv, record_options,\n\t\t\t     NULL, PARSE_OPT_STOP_AT_NON_OPTION);\n\tfree(__argv);\n\n\tsystem_wide = (argc == 0);\n\n\treturn 0;\n}\n\nstatic void script__setup_sample_type(struct perf_script *script)\n{\n\tstruct perf_session *session = script->session;\n\tu64 sample_type = evlist__combined_sample_type(session->evlist);\n\n\tcallchain_param_setup(sample_type, perf_env__arch(session->machines.host.env));\n\n\tif (script->stitch_lbr && (callchain_param.record_mode != CALLCHAIN_LBR)) {\n\t\tpr_warning(\"Can't find LBR callchain. Switch off --stitch-lbr.\\n\"\n\t\t\t   \"Please apply --call-graph lbr when recording.\\n\");\n\t\tscript->stitch_lbr = false;\n\t}\n}\n\nstatic int process_stat_round_event(struct perf_session *session,\n\t\t\t\t    union perf_event *event)\n{\n\tstruct perf_record_stat_round *round = &event->stat_round;\n\tstruct evsel *counter;\n\n\tevlist__for_each_entry(session->evlist, counter) {\n\t\tperf_stat_process_counter(&stat_config, counter);\n\t\tprocess_stat(counter, round->time);\n\t}\n\n\tprocess_stat_interval(round->time);\n\treturn 0;\n}\n\nstatic int process_stat_config_event(struct perf_session *session __maybe_unused,\n\t\t\t\t     union perf_event *event)\n{\n\tperf_event__read_stat_config(&stat_config, &event->stat_config);\n\n\t \n\tstat_config.aggr_mode = AGGR_NONE;\n\n\treturn 0;\n}\n\nstatic int set_maps(struct perf_script *script)\n{\n\tstruct evlist *evlist = script->session->evlist;\n\n\tif (!script->cpus || !script->threads)\n\t\treturn 0;\n\n\tif (WARN_ONCE(script->allocated, \"stats double allocation\\n\"))\n\t\treturn -EINVAL;\n\n\tperf_evlist__set_maps(&evlist->core, script->cpus, script->threads);\n\n\tif (evlist__alloc_stats(&stat_config, evlist,  true))\n\t\treturn -ENOMEM;\n\n\tscript->allocated = true;\n\treturn 0;\n}\n\nstatic\nint process_thread_map_event(struct perf_session *session,\n\t\t\t     union perf_event *event)\n{\n\tstruct perf_tool *tool = session->tool;\n\tstruct perf_script *script = container_of(tool, struct perf_script, tool);\n\n\tif (dump_trace)\n\t\tperf_event__fprintf_thread_map(event, stdout);\n\n\tif (script->threads) {\n\t\tpr_warning(\"Extra thread map event, ignoring.\\n\");\n\t\treturn 0;\n\t}\n\n\tscript->threads = thread_map__new_event(&event->thread_map);\n\tif (!script->threads)\n\t\treturn -ENOMEM;\n\n\treturn set_maps(script);\n}\n\nstatic\nint process_cpu_map_event(struct perf_session *session,\n\t\t\t  union perf_event *event)\n{\n\tstruct perf_tool *tool = session->tool;\n\tstruct perf_script *script = container_of(tool, struct perf_script, tool);\n\n\tif (dump_trace)\n\t\tperf_event__fprintf_cpu_map(event, stdout);\n\n\tif (script->cpus) {\n\t\tpr_warning(\"Extra cpu map event, ignoring.\\n\");\n\t\treturn 0;\n\t}\n\n\tscript->cpus = cpu_map__new_data(&event->cpu_map.data);\n\tif (!script->cpus)\n\t\treturn -ENOMEM;\n\n\treturn set_maps(script);\n}\n\nstatic int process_feature_event(struct perf_session *session,\n\t\t\t\t union perf_event *event)\n{\n\tif (event->feat.feat_id < HEADER_LAST_FEATURE)\n\t\treturn perf_event__process_feature(session, event);\n\treturn 0;\n}\n\n#ifdef HAVE_AUXTRACE_SUPPORT\nstatic int perf_script__process_auxtrace_info(struct perf_session *session,\n\t\t\t\t\t      union perf_event *event)\n{\n\tstruct perf_tool *tool = session->tool;\n\n\tint ret = perf_event__process_auxtrace_info(session, event);\n\n\tif (ret == 0) {\n\t\tstruct perf_script *script = container_of(tool, struct perf_script, tool);\n\n\t\tret = perf_script__setup_per_event_dump(script);\n\t}\n\n\treturn ret;\n}\n#else\n#define perf_script__process_auxtrace_info 0\n#endif\n\nstatic int parse_insn_trace(const struct option *opt __maybe_unused,\n\t\t\t    const char *str __maybe_unused,\n\t\t\t    int unset __maybe_unused)\n{\n\tparse_output_fields(NULL, \"+insn,-event,-period\", 0);\n\titrace_parse_synth_opts(opt, \"i0ns\", 0);\n\tsymbol_conf.nanosecs = true;\n\treturn 0;\n}\n\nstatic int parse_xed(const struct option *opt __maybe_unused,\n\t\t     const char *str __maybe_unused,\n\t\t     int unset __maybe_unused)\n{\n\tif (isatty(1))\n\t\tforce_pager(\"xed -F insn: -A -64 | less\");\n\telse\n\t\tforce_pager(\"xed -F insn: -A -64\");\n\treturn 0;\n}\n\nstatic int parse_call_trace(const struct option *opt __maybe_unused,\n\t\t\t    const char *str __maybe_unused,\n\t\t\t    int unset __maybe_unused)\n{\n\tparse_output_fields(NULL, \"-ip,-addr,-event,-period,+callindent\", 0);\n\titrace_parse_synth_opts(opt, \"cewp\", 0);\n\tsymbol_conf.nanosecs = true;\n\tsymbol_conf.pad_output_len_dso = 50;\n\treturn 0;\n}\n\nstatic int parse_callret_trace(const struct option *opt __maybe_unused,\n\t\t\t    const char *str __maybe_unused,\n\t\t\t    int unset __maybe_unused)\n{\n\tparse_output_fields(NULL, \"-ip,-addr,-event,-period,+callindent,+flags\", 0);\n\titrace_parse_synth_opts(opt, \"crewp\", 0);\n\tsymbol_conf.nanosecs = true;\n\treturn 0;\n}\n\nint cmd_script(int argc, const char **argv)\n{\n\tbool show_full_info = false;\n\tbool header = false;\n\tbool header_only = false;\n\tbool script_started = false;\n\tbool unsorted_dump = false;\n\tchar *rec_script_path = NULL;\n\tchar *rep_script_path = NULL;\n\tstruct perf_session *session;\n\tstruct itrace_synth_opts itrace_synth_opts = {\n\t\t.set = false,\n\t\t.default_no_sample = true,\n\t};\n\tstruct utsname uts;\n\tchar *script_path = NULL;\n\tconst char *dlfilter_file = NULL;\n\tconst char **__argv;\n\tint i, j, err = 0;\n\tstruct perf_script script = {\n\t\t.tool = {\n\t\t\t.sample\t\t = process_sample_event,\n\t\t\t.mmap\t\t = perf_event__process_mmap,\n\t\t\t.mmap2\t\t = perf_event__process_mmap2,\n\t\t\t.comm\t\t = perf_event__process_comm,\n\t\t\t.namespaces\t = perf_event__process_namespaces,\n\t\t\t.cgroup\t\t = perf_event__process_cgroup,\n\t\t\t.exit\t\t = perf_event__process_exit,\n\t\t\t.fork\t\t = perf_event__process_fork,\n\t\t\t.attr\t\t = process_attr,\n\t\t\t.event_update   = perf_event__process_event_update,\n#ifdef HAVE_LIBTRACEEVENT\n\t\t\t.tracing_data\t = perf_event__process_tracing_data,\n#endif\n\t\t\t.feature\t = process_feature_event,\n\t\t\t.build_id\t = perf_event__process_build_id,\n\t\t\t.id_index\t = perf_event__process_id_index,\n\t\t\t.auxtrace_info\t = perf_script__process_auxtrace_info,\n\t\t\t.auxtrace\t = perf_event__process_auxtrace,\n\t\t\t.auxtrace_error\t = perf_event__process_auxtrace_error,\n\t\t\t.stat\t\t = perf_event__process_stat_event,\n\t\t\t.stat_round\t = process_stat_round_event,\n\t\t\t.stat_config\t = process_stat_config_event,\n\t\t\t.thread_map\t = process_thread_map_event,\n\t\t\t.cpu_map\t = process_cpu_map_event,\n\t\t\t.throttle\t = process_throttle_event,\n\t\t\t.unthrottle\t = process_throttle_event,\n\t\t\t.ordered_events\t = true,\n\t\t\t.ordering_requires_timestamps = true,\n\t\t},\n\t};\n\tstruct perf_data data = {\n\t\t.mode = PERF_DATA_MODE_READ,\n\t};\n\tconst struct option options[] = {\n\tOPT_BOOLEAN('D', \"dump-raw-trace\", &dump_trace,\n\t\t    \"dump raw trace in ASCII\"),\n\tOPT_BOOLEAN(0, \"dump-unsorted-raw-trace\", &unsorted_dump,\n\t\t    \"dump unsorted raw trace in ASCII\"),\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t \"be more verbose (show symbol address, etc)\"),\n\tOPT_BOOLEAN('L', \"Latency\", &latency_format,\n\t\t    \"show latency attributes (irqs/preemption disabled, etc)\"),\n\tOPT_CALLBACK_NOOPT('l', \"list\", NULL, NULL, \"list available scripts\",\n\t\t\t   list_available_scripts),\n\tOPT_CALLBACK_NOOPT(0, \"list-dlfilters\", NULL, NULL, \"list available dlfilters\",\n\t\t\t   list_available_dlfilters),\n\tOPT_CALLBACK('s', \"script\", NULL, \"name\",\n\t\t     \"script file name (lang:script name, script name, or *)\",\n\t\t     parse_scriptname),\n\tOPT_STRING('g', \"gen-script\", &generate_script_lang, \"lang\",\n\t\t   \"generate perf-script.xx script in specified language\"),\n\tOPT_STRING(0, \"dlfilter\", &dlfilter_file, \"file\", \"filter .so file name\"),\n\tOPT_CALLBACK(0, \"dlarg\", NULL, \"argument\", \"filter argument\",\n\t\t     add_dlarg),\n\tOPT_STRING('i', \"input\", &input_name, \"file\", \"input file name\"),\n\tOPT_BOOLEAN('d', \"debug-mode\", &debug_mode,\n\t\t   \"do various checks like samples ordering and lost events\"),\n\tOPT_BOOLEAN(0, \"header\", &header, \"Show data header.\"),\n\tOPT_BOOLEAN(0, \"header-only\", &header_only, \"Show only data header.\"),\n\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_STRING(0, \"kallsyms\", &symbol_conf.kallsyms_name,\n\t\t   \"file\", \"kallsyms pathname\"),\n\tOPT_BOOLEAN('G', \"hide-call-graph\", &no_callchain,\n\t\t    \"When printing symbols do not display call chain\"),\n\tOPT_CALLBACK(0, \"symfs\", NULL, \"directory\",\n\t\t     \"Look for files with symbols relative to this directory\",\n\t\t     symbol__config_symfs),\n\tOPT_CALLBACK('F', \"fields\", NULL, \"str\",\n\t\t     \"comma separated output fields prepend with 'type:'. \"\n\t\t     \"+field to add and -field to remove.\"\n\t\t     \"Valid types: hw,sw,trace,raw,synth. \"\n\t\t     \"Fields: comm,tid,pid,time,cpu,event,trace,ip,sym,dso,dsoff\"\n\t\t     \"addr,symoff,srcline,period,iregs,uregs,brstack,\"\n\t\t     \"brstacksym,flags,data_src,weight,bpf-output,brstackinsn,\"\n\t\t     \"brstackinsnlen,brstackoff,callindent,insn,insnlen,synth,\"\n\t\t     \"phys_addr,metric,misc,srccode,ipc,tod,data_page_size,\"\n\t\t     \"code_page_size,ins_lat,machine_pid,vcpu,cgroup,retire_lat\",\n\t\t     parse_output_fields),\n\tOPT_BOOLEAN('a', \"all-cpus\", &system_wide,\n\t\t    \"system-wide collection from all CPUs\"),\n\tOPT_STRING(0, \"dsos\", &symbol_conf.dso_list_str, \"dso[,dso...]\",\n\t\t   \"only consider symbols in these DSOs\"),\n\tOPT_STRING('S', \"symbols\", &symbol_conf.sym_list_str, \"symbol[,symbol...]\",\n\t\t   \"only consider these symbols\"),\n\tOPT_INTEGER(0, \"addr-range\", &symbol_conf.addr_range,\n\t\t    \"Use with -S to list traced records within address range\"),\n\tOPT_CALLBACK_OPTARG(0, \"insn-trace\", &itrace_synth_opts, NULL, NULL,\n\t\t\t\"Decode instructions from itrace\", parse_insn_trace),\n\tOPT_CALLBACK_OPTARG(0, \"xed\", NULL, NULL, NULL,\n\t\t\t\"Run xed disassembler on output\", parse_xed),\n\tOPT_CALLBACK_OPTARG(0, \"call-trace\", &itrace_synth_opts, NULL, NULL,\n\t\t\t\"Decode calls from itrace\", parse_call_trace),\n\tOPT_CALLBACK_OPTARG(0, \"call-ret-trace\", &itrace_synth_opts, NULL, NULL,\n\t\t\t\"Decode calls and returns from itrace\", parse_callret_trace),\n\tOPT_STRING(0, \"graph-function\", &symbol_conf.graph_function, \"symbol[,symbol...]\",\n\t\t\t\"Only print symbols and callees with --call-trace/--call-ret-trace\"),\n\tOPT_STRING(0, \"stop-bt\", &symbol_conf.bt_stop_list_str, \"symbol[,symbol...]\",\n\t\t   \"Stop display of callgraph at these symbols\"),\n\tOPT_STRING('C', \"cpu\", &cpu_list, \"cpu\", \"list of cpus to profile\"),\n\tOPT_STRING('c', \"comms\", &symbol_conf.comm_list_str, \"comm[,comm...]\",\n\t\t   \"only display events for these comms\"),\n\tOPT_STRING(0, \"pid\", &symbol_conf.pid_list_str, \"pid[,pid...]\",\n\t\t   \"only consider symbols in these pids\"),\n\tOPT_STRING(0, \"tid\", &symbol_conf.tid_list_str, \"tid[,tid...]\",\n\t\t   \"only consider symbols in these tids\"),\n\tOPT_UINTEGER(0, \"max-stack\", &scripting_max_stack,\n\t\t     \"Set the maximum stack depth when parsing the callchain, \"\n\t\t     \"anything beyond the specified depth will be ignored. \"\n\t\t     \"Default: kernel.perf_event_max_stack or \" __stringify(PERF_MAX_STACK_DEPTH)),\n\tOPT_BOOLEAN(0, \"reltime\", &reltime, \"Show time stamps relative to start\"),\n\tOPT_BOOLEAN(0, \"deltatime\", &deltatime, \"Show time stamps relative to previous event\"),\n\tOPT_BOOLEAN('I', \"show-info\", &show_full_info,\n\t\t    \"display extended information from perf.data file\"),\n\tOPT_BOOLEAN('\\0', \"show-kernel-path\", &symbol_conf.show_kernel_path,\n\t\t    \"Show the path of [kernel.kallsyms]\"),\n\tOPT_BOOLEAN('\\0', \"show-task-events\", &script.show_task_events,\n\t\t    \"Show the fork/comm/exit events\"),\n\tOPT_BOOLEAN('\\0', \"show-mmap-events\", &script.show_mmap_events,\n\t\t    \"Show the mmap events\"),\n\tOPT_BOOLEAN('\\0', \"show-switch-events\", &script.show_switch_events,\n\t\t    \"Show context switch events (if recorded)\"),\n\tOPT_BOOLEAN('\\0', \"show-namespace-events\", &script.show_namespace_events,\n\t\t    \"Show namespace events (if recorded)\"),\n\tOPT_BOOLEAN('\\0', \"show-cgroup-events\", &script.show_cgroup_events,\n\t\t    \"Show cgroup events (if recorded)\"),\n\tOPT_BOOLEAN('\\0', \"show-lost-events\", &script.show_lost_events,\n\t\t    \"Show lost events (if recorded)\"),\n\tOPT_BOOLEAN('\\0', \"show-round-events\", &script.show_round_events,\n\t\t    \"Show round events (if recorded)\"),\n\tOPT_BOOLEAN('\\0', \"show-bpf-events\", &script.show_bpf_events,\n\t\t    \"Show bpf related events (if recorded)\"),\n\tOPT_BOOLEAN('\\0', \"show-text-poke-events\", &script.show_text_poke_events,\n\t\t    \"Show text poke related events (if recorded)\"),\n\tOPT_BOOLEAN('\\0', \"per-event-dump\", &script.per_event_dump,\n\t\t    \"Dump trace output to files named by the monitored events\"),\n\tOPT_BOOLEAN('f', \"force\", &symbol_conf.force, \"don't complain, do it\"),\n\tOPT_INTEGER(0, \"max-blocks\", &max_blocks,\n\t\t    \"Maximum number of code blocks to dump with brstackinsn\"),\n\tOPT_BOOLEAN(0, \"ns\", &symbol_conf.nanosecs,\n\t\t    \"Use 9 decimal places when displaying time\"),\n\tOPT_CALLBACK_OPTARG(0, \"itrace\", &itrace_synth_opts, NULL, \"opts\",\n\t\t\t    \"Instruction Tracing options\\n\" ITRACE_HELP,\n\t\t\t    itrace_parse_synth_opts),\n\tOPT_BOOLEAN(0, \"full-source-path\", &srcline_full_filename,\n\t\t\t\"Show full source file name path for source lines\"),\n\tOPT_BOOLEAN(0, \"demangle\", &symbol_conf.demangle,\n\t\t\t\"Enable symbol demangling\"),\n\tOPT_BOOLEAN(0, \"demangle-kernel\", &symbol_conf.demangle_kernel,\n\t\t\t\"Enable kernel symbol demangling\"),\n\tOPT_STRING(0, \"time\", &script.time_str, \"str\",\n\t\t   \"Time span of interest (start,stop)\"),\n\tOPT_BOOLEAN(0, \"inline\", &symbol_conf.inline_name,\n\t\t    \"Show inline function\"),\n\tOPT_STRING(0, \"guestmount\", &symbol_conf.guestmount, \"directory\",\n\t\t   \"guest mount directory under which every guest os\"\n\t\t   \" instance has a subdir\"),\n\tOPT_STRING(0, \"guestvmlinux\", &symbol_conf.default_guest_vmlinux_name,\n\t\t   \"file\", \"file saving guest os vmlinux\"),\n\tOPT_STRING(0, \"guestkallsyms\", &symbol_conf.default_guest_kallsyms,\n\t\t   \"file\", \"file saving guest os /proc/kallsyms\"),\n\tOPT_STRING(0, \"guestmodules\", &symbol_conf.default_guest_modules,\n\t\t   \"file\", \"file saving guest os /proc/modules\"),\n\tOPT_BOOLEAN(0, \"guest-code\", &symbol_conf.guest_code,\n\t\t    \"Guest code can be found in hypervisor process\"),\n\tOPT_BOOLEAN('\\0', \"stitch-lbr\", &script.stitch_lbr,\n\t\t    \"Enable LBR callgraph stitching approach\"),\n\tOPTS_EVSWITCH(&script.evswitch),\n\tOPT_END()\n\t};\n\tconst char * const script_subcommands[] = { \"record\", \"report\", NULL };\n\tconst char *script_usage[] = {\n\t\t\"perf script [<options>]\",\n\t\t\"perf script [<options>] record <script> [<record-options>] <command>\",\n\t\t\"perf script [<options>] report <script> [script-args]\",\n\t\t\"perf script [<options>] <script> [<record-options>] <command>\",\n\t\t\"perf script [<options>] <top-script> [script-args]\",\n\t\tNULL\n\t};\n\n\tperf_set_singlethreaded();\n\n\tsetup_scripting();\n\n\targc = parse_options_subcommand(argc, argv, options, script_subcommands, script_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tif (symbol_conf.guestmount ||\n\t    symbol_conf.default_guest_vmlinux_name ||\n\t    symbol_conf.default_guest_kallsyms ||\n\t    symbol_conf.default_guest_modules ||\n\t    symbol_conf.guest_code) {\n\t\t \n\t\tperf_guest = true;\n\t}\n\n\tdata.path  = input_name;\n\tdata.force = symbol_conf.force;\n\n\tif (unsorted_dump) {\n\t\tdump_trace = true;\n\t\tscript.tool.ordered_events = false;\n\t}\n\n\tif (symbol__validate_sym_arguments())\n\t\treturn -1;\n\n\tif (argc > 1 && strlen(argv[0]) > 2 && strstarts(\"record\", argv[0])) {\n\t\trec_script_path = get_script_path(argv[1], RECORD_SUFFIX);\n\t\tif (!rec_script_path)\n\t\t\treturn cmd_record(argc, argv);\n\t}\n\n\tif (argc > 1 && strlen(argv[0]) > 2 && strstarts(\"report\", argv[0])) {\n\t\trep_script_path = get_script_path(argv[1], REPORT_SUFFIX);\n\t\tif (!rep_script_path) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Please specify a valid report script\"\n\t\t\t\t\"(see 'perf script -l' for listing)\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (reltime && deltatime) {\n\t\tfprintf(stderr,\n\t\t\t\"reltime and deltatime - the two don't get along well. \"\n\t\t\t\"Please limit to --reltime or --deltatime.\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((itrace_synth_opts.callchain || itrace_synth_opts.add_callchain) &&\n\t    itrace_synth_opts.callchain_sz > scripting_max_stack)\n\t\tscripting_max_stack = itrace_synth_opts.callchain_sz;\n\n\t \n\tset_argv_exec_path(get_argv_exec_path());\n\n\tif (argc && !script_name && !rec_script_path && !rep_script_path) {\n\t\tint live_pipe[2];\n\t\tint rep_args;\n\t\tpid_t pid;\n\n\t\trec_script_path = get_script_path(argv[0], RECORD_SUFFIX);\n\t\trep_script_path = get_script_path(argv[0], REPORT_SUFFIX);\n\n\t\tif (!rec_script_path && !rep_script_path) {\n\t\t\tscript_name = find_script(argv[0]);\n\t\t\tif (script_name) {\n\t\t\t\targc -= 1;\n\t\t\t\targv += 1;\n\t\t\t\tgoto script_found;\n\t\t\t}\n\t\t\tusage_with_options_msg(script_usage, options,\n\t\t\t\t\"Couldn't find script `%s'\\n\\n See perf\"\n\t\t\t\t\" script -l for available scripts.\\n\", argv[0]);\n\t\t}\n\n\t\tif (is_top_script(argv[0])) {\n\t\t\trep_args = argc - 1;\n\t\t} else {\n\t\t\tint rec_args;\n\n\t\t\trep_args = has_required_arg(rep_script_path);\n\t\t\trec_args = (argc - 1) - rep_args;\n\t\t\tif (rec_args < 0) {\n\t\t\t\tusage_with_options_msg(script_usage, options,\n\t\t\t\t\t\"`%s' script requires options.\"\n\t\t\t\t\t\"\\n\\n See perf script -l for available \"\n\t\t\t\t\t\"scripts and options.\\n\", argv[0]);\n\t\t\t}\n\t\t}\n\n\t\tif (pipe(live_pipe) < 0) {\n\t\t\tperror(\"failed to create pipe\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tpid = fork();\n\t\tif (pid < 0) {\n\t\t\tperror(\"failed to fork\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!pid) {\n\t\t\tj = 0;\n\n\t\t\tdup2(live_pipe[1], 1);\n\t\t\tclose(live_pipe[0]);\n\n\t\t\tif (is_top_script(argv[0])) {\n\t\t\t\tsystem_wide = true;\n\t\t\t} else if (!system_wide) {\n\t\t\t\tif (have_cmd(argc - rep_args, &argv[rep_args]) != 0) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t__argv = malloc((argc + 6) * sizeof(const char *));\n\t\t\tif (!__argv) {\n\t\t\t\tpr_err(\"malloc failed\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t__argv[j++] = \"/bin/sh\";\n\t\t\t__argv[j++] = rec_script_path;\n\t\t\tif (system_wide)\n\t\t\t\t__argv[j++] = \"-a\";\n\t\t\t__argv[j++] = \"-q\";\n\t\t\t__argv[j++] = \"-o\";\n\t\t\t__argv[j++] = \"-\";\n\t\t\tfor (i = rep_args + 1; i < argc; i++)\n\t\t\t\t__argv[j++] = argv[i];\n\t\t\t__argv[j++] = NULL;\n\n\t\t\texecvp(\"/bin/sh\", (char **)__argv);\n\t\t\tfree(__argv);\n\t\t\texit(-1);\n\t\t}\n\n\t\tdup2(live_pipe[0], 0);\n\t\tclose(live_pipe[1]);\n\n\t\t__argv = malloc((argc + 4) * sizeof(const char *));\n\t\tif (!__argv) {\n\t\t\tpr_err(\"malloc failed\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tj = 0;\n\t\t__argv[j++] = \"/bin/sh\";\n\t\t__argv[j++] = rep_script_path;\n\t\tfor (i = 1; i < rep_args + 1; i++)\n\t\t\t__argv[j++] = argv[i];\n\t\t__argv[j++] = \"-i\";\n\t\t__argv[j++] = \"-\";\n\t\t__argv[j++] = NULL;\n\n\t\texecvp(\"/bin/sh\", (char **)__argv);\n\t\tfree(__argv);\n\t\texit(-1);\n\t}\nscript_found:\n\tif (rec_script_path)\n\t\tscript_path = rec_script_path;\n\tif (rep_script_path)\n\t\tscript_path = rep_script_path;\n\n\tif (script_path) {\n\t\tj = 0;\n\n\t\tif (!rec_script_path)\n\t\t\tsystem_wide = false;\n\t\telse if (!system_wide) {\n\t\t\tif (have_cmd(argc - 1, &argv[1]) != 0) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t__argv = malloc((argc + 2) * sizeof(const char *));\n\t\tif (!__argv) {\n\t\t\tpr_err(\"malloc failed\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t__argv[j++] = \"/bin/sh\";\n\t\t__argv[j++] = script_path;\n\t\tif (system_wide)\n\t\t\t__argv[j++] = \"-a\";\n\t\tfor (i = 2; i < argc; i++)\n\t\t\t__argv[j++] = argv[i];\n\t\t__argv[j++] = NULL;\n\n\t\texecvp(\"/bin/sh\", (char **)__argv);\n\t\tfree(__argv);\n\t\texit(-1);\n\t}\n\n\tif (dlfilter_file) {\n\t\tdlfilter = dlfilter__new(dlfilter_file, dlargc, dlargv);\n\t\tif (!dlfilter)\n\t\t\treturn -1;\n\t}\n\n\tif (!script_name) {\n\t\tsetup_pager();\n\t\tuse_browser = 0;\n\t}\n\n\tsession = perf_session__new(&data, &script.tool);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tif (header || header_only) {\n\t\tscript.tool.show_feat_hdr = SHOW_FEAT_HEADER;\n\t\tperf_session__fprintf_info(session, stdout, show_full_info);\n\t\tif (header_only)\n\t\t\tgoto out_delete;\n\t}\n\tif (show_full_info)\n\t\tscript.tool.show_feat_hdr = SHOW_FEAT_HEADER_FULL_INFO;\n\n\tif (symbol__init(&session->header.env) < 0)\n\t\tgoto out_delete;\n\n\tuname(&uts);\n\tif (data.is_pipe) {  \n\t\tnative_arch = true;\n\t} else if (session->header.env.arch) {\n\t\tif (!strcmp(uts.machine, session->header.env.arch))\n\t\t\tnative_arch = true;\n\t\telse if (!strcmp(uts.machine, \"x86_64\") &&\n\t\t\t !strcmp(session->header.env.arch, \"i386\"))\n\t\t\tnative_arch = true;\n\t}\n\n\tscript.session = session;\n\tscript__setup_sample_type(&script);\n\n\tif ((output[PERF_TYPE_HARDWARE].fields & PERF_OUTPUT_CALLINDENT) ||\n\t    symbol_conf.graph_function)\n\t\titrace_synth_opts.thread_stack = true;\n\n\tsession->itrace_synth_opts = &itrace_synth_opts;\n\n\tif (cpu_list) {\n\t\terr = perf_session__cpu_bitmap(session, cpu_list, cpu_bitmap);\n\t\tif (err < 0)\n\t\t\tgoto out_delete;\n\t\titrace_synth_opts.cpu_bitmap = cpu_bitmap;\n\t}\n\n\tif (!no_callchain)\n\t\tsymbol_conf.use_callchain = true;\n\telse\n\t\tsymbol_conf.use_callchain = false;\n\n#ifdef HAVE_LIBTRACEEVENT\n\tif (session->tevent.pevent &&\n\t    tep_set_function_resolver(session->tevent.pevent,\n\t\t\t\t      machine__resolve_kernel_addr,\n\t\t\t\t      &session->machines.host) < 0) {\n\t\tpr_err(\"%s: failed to set libtraceevent function resolver\\n\", __func__);\n\t\terr = -1;\n\t\tgoto out_delete;\n\t}\n#endif\n\tif (generate_script_lang) {\n\t\tstruct stat perf_stat;\n\t\tint input;\n\n\t\tif (output_set_by_user()) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"custom fields not supported for generated scripts\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\tinput = open(data.path, O_RDONLY);\t \n\t\tif (input < 0) {\n\t\t\terr = -errno;\n\t\t\tperror(\"failed to open file\");\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\terr = fstat(input, &perf_stat);\n\t\tif (err < 0) {\n\t\t\tperror(\"failed to stat file\");\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\tif (!perf_stat.st_size) {\n\t\t\tfprintf(stderr, \"zero-sized file, nothing to do!\\n\");\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\tscripting_ops = script_spec__lookup(generate_script_lang);\n\t\tif (!scripting_ops) {\n\t\t\tfprintf(stderr, \"invalid language specifier\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_delete;\n\t\t}\n#ifdef HAVE_LIBTRACEEVENT\n\t\terr = scripting_ops->generate_script(session->tevent.pevent,\n\t\t\t\t\t\t     \"perf-script\");\n#else\n\t\terr = scripting_ops->generate_script(NULL, \"perf-script\");\n#endif\n\t\tgoto out_delete;\n\t}\n\n\terr = dlfilter__start(dlfilter, session);\n\tif (err)\n\t\tgoto out_delete;\n\n\tif (script_name) {\n\t\terr = scripting_ops->start_script(script_name, argc, argv, session);\n\t\tif (err)\n\t\t\tgoto out_delete;\n\t\tpr_debug(\"perf script started with script %s\\n\\n\", script_name);\n\t\tscript_started = true;\n\t}\n\n\n\terr = perf_session__check_output_opt(session);\n\tif (err < 0)\n\t\tgoto out_delete;\n\n\tif (script.time_str) {\n\t\terr = perf_time__parse_for_ranges_reltime(script.time_str, session,\n\t\t\t\t\t\t  &script.ptime_range,\n\t\t\t\t\t\t  &script.range_size,\n\t\t\t\t\t\t  &script.range_num,\n\t\t\t\t\t\t  reltime);\n\t\tif (err < 0)\n\t\t\tgoto out_delete;\n\n\t\titrace_synth_opts__set_time_range(&itrace_synth_opts,\n\t\t\t\t\t\t  script.ptime_range,\n\t\t\t\t\t\t  script.range_num);\n\t}\n\n\terr = evswitch__init(&script.evswitch, session->evlist, stderr);\n\tif (err)\n\t\tgoto out_delete;\n\n\tif (zstd_init(&(session->zstd_data), 0) < 0)\n\t\tpr_warning(\"Decompression initialization failed. Reported data may be incomplete.\\n\");\n\n\terr = __cmd_script(&script);\n\n\tflush_scripting();\n\nout_delete:\n\tif (script.ptime_range) {\n\t\titrace_synth_opts__clear_time_range(&itrace_synth_opts);\n\t\tzfree(&script.ptime_range);\n\t}\n\n\tzstd_fini(&(session->zstd_data));\n\tevlist__free_stats(session->evlist);\n\tperf_session__delete(session);\n\tperf_script__exit(&script);\n\n\tif (script_started)\n\t\tcleanup_scripting();\n\tdlfilter__cleanup(dlfilter);\n\tfree_dlarg();\nout:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}