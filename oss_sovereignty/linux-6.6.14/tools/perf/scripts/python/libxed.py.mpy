{
  "module_name": "libxed.py",
  "hash_id": "ad388b6a4fdbc15f411cc82284f436de1506ad24caf7d6d96c2c29981977f97d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/libxed.py",
  "human_readable_source": "#!/usr/bin/env python\n# SPDX-License-Identifier: GPL-2.0\n# libxed.py: Python wrapper for libxed.so\n# Copyright (c) 2014-2021, Intel Corporation.\n\n# To use Intel XED, libxed.so must be present. To build and install\n# libxed.so:\n#            git clone https://github.com/intelxed/mbuild.git mbuild\n#            git clone https://github.com/intelxed/xed\n#            cd xed\n#            ./mfile.py --share\n#            sudo ./mfile.py --prefix=/usr/local install\n#            sudo ldconfig\n#\n\nimport sys\n\nfrom ctypes import CDLL, Structure, create_string_buffer, addressof, sizeof, \\\n\t\t   c_void_p, c_bool, c_byte, c_char, c_int, c_uint, c_longlong, c_ulonglong\n\n# XED Disassembler\n\nclass xed_state_t(Structure):\n\n\t_fields_ = [\n\t\t(\"mode\", c_int),\n\t\t(\"width\", c_int)\n\t]\n\nclass XEDInstruction():\n\n\tdef __init__(self, libxed):\n\t\t# Current xed_decoded_inst_t structure is 192 bytes. Use 512 to allow for future expansion\n\t\txedd_t = c_byte * 512\n\t\tself.xedd = xedd_t()\n\t\tself.xedp = addressof(self.xedd)\n\t\tlibxed.xed_decoded_inst_zero(self.xedp)\n\t\tself.state = xed_state_t()\n\t\tself.statep = addressof(self.state)\n\t\t# Buffer for disassembled instruction text\n\t\tself.buffer = create_string_buffer(256)\n\t\tself.bufferp = addressof(self.buffer)\n\nclass LibXED():\n\n\tdef __init__(self):\n\t\ttry:\n\t\t\tself.libxed = CDLL(\"libxed.so\")\n\t\texcept:\n\t\t\tself.libxed = None\n\t\tif not self.libxed:\n\t\t\tself.libxed = CDLL(\"/usr/local/lib/libxed.so\")\n\n\t\tself.xed_tables_init = self.libxed.xed_tables_init\n\t\tself.xed_tables_init.restype = None\n\t\tself.xed_tables_init.argtypes = []\n\n\t\tself.xed_decoded_inst_zero = self.libxed.xed_decoded_inst_zero\n\t\tself.xed_decoded_inst_zero.restype = None\n\t\tself.xed_decoded_inst_zero.argtypes = [ c_void_p ]\n\n\t\tself.xed_operand_values_set_mode = self.libxed.xed_operand_values_set_mode\n\t\tself.xed_operand_values_set_mode.restype = None\n\t\tself.xed_operand_values_set_mode.argtypes = [ c_void_p, c_void_p ]\n\n\t\tself.xed_decoded_inst_zero_keep_mode = self.libxed.xed_decoded_inst_zero_keep_mode\n\t\tself.xed_decoded_inst_zero_keep_mode.restype = None\n\t\tself.xed_decoded_inst_zero_keep_mode.argtypes = [ c_void_p ]\n\n\t\tself.xed_decode = self.libxed.xed_decode\n\t\tself.xed_decode.restype = c_int\n\t\tself.xed_decode.argtypes = [ c_void_p, c_void_p, c_uint ]\n\n\t\tself.xed_format_context = self.libxed.xed_format_context\n\t\tself.xed_format_context.restype = c_uint\n\t\tself.xed_format_context.argtypes = [ c_int, c_void_p, c_void_p, c_int, c_ulonglong, c_void_p, c_void_p ]\n\n\t\tself.xed_tables_init()\n\n\tdef Instruction(self):\n\t\treturn XEDInstruction(self)\n\n\tdef SetMode(self, inst, mode):\n\t\tif mode:\n\t\t\tinst.state.mode = 4 # 32-bit\n\t\t\tinst.state.width = 4 # 4 bytes\n\t\telse:\n\t\t\tinst.state.mode = 1 # 64-bit\n\t\t\tinst.state.width = 8 # 8 bytes\n\t\tself.xed_operand_values_set_mode(inst.xedp, inst.statep)\n\n\tdef DisassembleOne(self, inst, bytes_ptr, bytes_cnt, ip):\n\t\tself.xed_decoded_inst_zero_keep_mode(inst.xedp)\n\t\terr = self.xed_decode(inst.xedp, bytes_ptr, bytes_cnt)\n\t\tif err:\n\t\t\treturn 0, \"\"\n\t\t# Use AT&T mode (2), alternative is Intel (3)\n\t\tok = self.xed_format_context(2, inst.xedp, inst.bufferp, sizeof(inst.buffer), ip, 0, 0)\n\t\tif not ok:\n\t\t\treturn 0, \"\"\n\t\tif sys.version_info[0] == 2:\n\t\t\tresult = inst.buffer.value\n\t\telse:\n\t\t\tresult = inst.buffer.value.decode()\n\t\t# Return instruction length and the disassembled instruction text\n\t\t# For now, assume the length is in byte 166\n\t\treturn inst.xedd[166], result\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}