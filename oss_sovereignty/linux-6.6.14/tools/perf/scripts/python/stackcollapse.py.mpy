{
  "module_name": "stackcollapse.py",
  "hash_id": "1eea2a665571ad4c47da45120f4f42968ae2a8fd2358dc586a15a7b70719699d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/stackcollapse.py",
  "human_readable_source": "# stackcollapse.py - format perf samples with one line per distinct call stack\n# SPDX-License-Identifier: GPL-2.0\n#\n# This script's output has two space-separated fields.  The first is a semicolon\n# separated stack including the program name (from the \"comm\" field) and the\n# function names from the call stack.  The second is a count:\n#\n#  swapper;start_kernel;rest_init;cpu_idle;default_idle;native_safe_halt 2\n#\n# The file is sorted according to the first field.\n#\n# Input may be created and processed using:\n#\n#  perf record -a -g -F 99 sleep 60\n#  perf script report stackcollapse > out.stacks-folded\n#\n# (perf script record stackcollapse works too).\n#\n# Written by Paolo Bonzini <pbonzini@redhat.com>\n# Based on Brendan Gregg's stackcollapse-perf.pl script.\n\nfrom __future__ import print_function\n\nimport os\nimport sys\nfrom collections import defaultdict\nfrom optparse import OptionParser, make_option\n\nsys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n    '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\nfrom perf_trace_context import *\nfrom Core import *\nfrom EventClass import *\n\n# command line parsing\n\noption_list = [\n    # formatting options for the bottom entry of the stack\n    make_option(\"--include-tid\", dest=\"include_tid\",\n                 action=\"store_true\", default=False,\n                 help=\"include thread id in stack\"),\n    make_option(\"--include-pid\", dest=\"include_pid\",\n                 action=\"store_true\", default=False,\n                 help=\"include process id in stack\"),\n    make_option(\"--no-comm\", dest=\"include_comm\",\n                 action=\"store_false\", default=True,\n                 help=\"do not separate stacks according to comm\"),\n    make_option(\"--tidy-java\", dest=\"tidy_java\",\n                 action=\"store_true\", default=False,\n                 help=\"beautify Java signatures\"),\n    make_option(\"--kernel\", dest=\"annotate_kernel\",\n                 action=\"store_true\", default=False,\n                 help=\"annotate kernel functions with _[k]\")\n]\n\nparser = OptionParser(option_list=option_list)\n(opts, args) = parser.parse_args()\n\nif len(args) != 0:\n    parser.error(\"unexpected command line argument\")\nif opts.include_tid and not opts.include_comm:\n    parser.error(\"requesting tid but not comm is invalid\")\nif opts.include_pid and not opts.include_comm:\n    parser.error(\"requesting pid but not comm is invalid\")\n\n# event handlers\n\nlines = defaultdict(lambda: 0)\n\ndef process_event(param_dict):\n    def tidy_function_name(sym, dso):\n        if sym is None:\n            sym = '[unknown]'\n\n        sym = sym.replace(';', ':')\n        if opts.tidy_java:\n            # the original stackcollapse-perf.pl script gives the\n            # example of converting this:\n            #    Lorg/mozilla/javascript/MemberBox;.<init>(Ljava/lang/reflect/Method;)V\n            # to this:\n            #    org/mozilla/javascript/MemberBox:.init\n            sym = sym.replace('<', '')\n            sym = sym.replace('>', '')\n            if sym[0] == 'L' and sym.find('/'):\n                sym = sym[1:]\n            try:\n                sym = sym[:sym.index('(')]\n            except ValueError:\n                pass\n\n        if opts.annotate_kernel and dso == '[kernel.kallsyms]':\n            return sym + '_[k]'\n        else:\n            return sym\n\n    stack = list()\n    if 'callchain' in param_dict:\n        for entry in param_dict['callchain']:\n            entry.setdefault('sym', dict())\n            entry['sym'].setdefault('name', None)\n            entry.setdefault('dso', None)\n            stack.append(tidy_function_name(entry['sym']['name'],\n                                            entry['dso']))\n    else:\n        param_dict.setdefault('symbol', None)\n        param_dict.setdefault('dso', None)\n        stack.append(tidy_function_name(param_dict['symbol'],\n                                        param_dict['dso']))\n\n    if opts.include_comm:\n        comm = param_dict[\"comm\"].replace(' ', '_')\n        sep = \"-\"\n        if opts.include_pid:\n            comm = comm + sep + str(param_dict['sample']['pid'])\n            sep = \"/\"\n        if opts.include_tid:\n            comm = comm + sep + str(param_dict['sample']['tid'])\n        stack.append(comm)\n\n    stack_string = ';'.join(reversed(stack))\n    lines[stack_string] = lines[stack_string] + 1\n\ndef trace_end():\n    list = sorted(lines)\n    for stack in list:\n        print(\"%s %d\" % (stack, lines[stack]))\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}