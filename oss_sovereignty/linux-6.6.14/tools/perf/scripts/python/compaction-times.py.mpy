{
  "module_name": "compaction-times.py",
  "hash_id": "3a67cb8ac53a8cac63c698e4acb96c81d44edaafc16454cf969f2a688c398914",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/compaction-times.py",
  "human_readable_source": "# report time spent in compaction\n# Licensed under the terms of the GNU GPL License version 2\n\n# testing:\n# 'echo 1 > /proc/sys/vm/compact_memory' to force compaction of all zones\n\nimport os\nimport sys\nimport re\n\nimport signal\nsignal.signal(signal.SIGPIPE, signal.SIG_DFL)\n\nusage = \"usage: perf script report compaction-times.py -- [-h] [-u] [-p|-pv] [-t | [-m] [-fs] [-ms]] [pid|pid-range|comm-regex]\\n\"\n\nclass popt:\n\tDISP_DFL = 0\n\tDISP_PROC = 1\n\tDISP_PROC_VERBOSE=2\n\nclass topt:\n\tDISP_TIME = 0\n\tDISP_MIG = 1\n\tDISP_ISOLFREE = 2\n\tDISP_ISOLMIG = 4\n\tDISP_ALL = 7\n\nclass comm_filter:\n\tdef __init__(self, re):\n\t\tself.re = re\n\n\tdef filter(self, pid, comm):\n\t\tm = self.re.search(comm)\n\t\treturn m == None or m.group() == \"\"\n\nclass pid_filter:\n\tdef __init__(self, low, high):\n\t\tself.low = (0 if low == \"\" else int(low))\n\t\tself.high = (0 if high == \"\" else int(high))\n\n\tdef filter(self, pid, comm):\n\t\treturn not (pid >= self.low and (self.high == 0 or pid <= self.high))\n\ndef set_type(t):\n\tglobal opt_disp\n\topt_disp = (t if opt_disp == topt.DISP_ALL else opt_disp|t)\n\ndef ns(sec, nsec):\n\treturn (sec * 1000000000) + nsec\n\ndef time(ns):\n\treturn \"%dns\" % ns if opt_ns else \"%dus\" % (round(ns, -3) / 1000)\n\nclass pair:\n\tdef __init__(self, aval, bval, alabel = None, blabel = None):\n\t\tself.alabel = alabel\n\t\tself.blabel = blabel\n\t\tself.aval = aval\n\t\tself.bval = bval\n\n\tdef __add__(self, rhs):\n\t\tself.aval += rhs.aval\n\t\tself.bval += rhs.bval\n\t\treturn self\n\n\tdef __str__(self):\n\t\treturn \"%s=%d %s=%d\" % (self.alabel, self.aval, self.blabel, self.bval)\n\nclass cnode:\n\tdef __init__(self, ns):\n\t\tself.ns = ns\n\t\tself.migrated = pair(0, 0, \"moved\", \"failed\")\n\t\tself.fscan = pair(0,0, \"scanned\", \"isolated\")\n\t\tself.mscan = pair(0,0, \"scanned\", \"isolated\")\n\n\tdef __add__(self, rhs):\n\t\tself.ns += rhs.ns\n\t\tself.migrated += rhs.migrated\n\t\tself.fscan += rhs.fscan\n\t\tself.mscan += rhs.mscan\n\t\treturn self\n\n\tdef __str__(self):\n\t\tprev = 0\n\t\ts = \"%s \" % time(self.ns)\n\t\tif (opt_disp & topt.DISP_MIG):\n\t\t\ts += \"migration: %s\" % self.migrated\n\t\t\tprev = 1\n\t\tif (opt_disp & topt.DISP_ISOLFREE):\n\t\t\ts += \"%sfree_scanner: %s\" % (\" \" if prev else \"\", self.fscan)\n\t\t\tprev = 1\n\t\tif (opt_disp & topt.DISP_ISOLMIG):\n\t\t\ts += \"%smigration_scanner: %s\" % (\" \" if prev else \"\", self.mscan)\n\t\treturn s\n\n\tdef complete(self, secs, nsecs):\n\t\tself.ns = ns(secs, nsecs) - self.ns\n\n\tdef increment(self, migrated, fscan, mscan):\n\t\tif (migrated != None):\n\t\t\tself.migrated += migrated\n\t\tif (fscan != None):\n\t\t\tself.fscan += fscan\n\t\tif (mscan != None):\n\t\t\tself.mscan += mscan\n\n\nclass chead:\n\theads = {}\n\tval = cnode(0);\n\tfobj = None\n\n\t@classmethod\n\tdef add_filter(cls, filter):\n\t\tcls.fobj = filter\n\n\t@classmethod\n\tdef create_pending(cls, pid, comm, start_secs, start_nsecs):\n\t\tfiltered = 0\n\t\ttry:\n\t\t\thead = cls.heads[pid]\n\t\t\tfiltered = head.is_filtered()\n\t\texcept KeyError:\n\t\t\tif cls.fobj != None:\n\t\t\t\tfiltered = cls.fobj.filter(pid, comm)\n\t\t\thead = cls.heads[pid] = chead(comm, pid, filtered)\n\n\t\tif not filtered:\n\t\t\thead.mark_pending(start_secs, start_nsecs)\n\n\t@classmethod\n\tdef increment_pending(cls, pid, migrated, fscan, mscan):\n\t\thead = cls.heads[pid]\n\t\tif not head.is_filtered():\n\t\t\tif head.is_pending():\n\t\t\t\thead.do_increment(migrated, fscan, mscan)\n\t\t\telse:\n\t\t\t\tsys.stderr.write(\"missing start compaction event for pid %d\\n\" % pid)\n\n\t@classmethod\n\tdef complete_pending(cls, pid, secs, nsecs):\n\t\thead = cls.heads[pid]\n\t\tif not head.is_filtered():\n\t\t\tif head.is_pending():\n\t\t\t\thead.make_complete(secs, nsecs)\n\t\t\telse:\n\t\t\t\tsys.stderr.write(\"missing start compaction event for pid %d\\n\" % pid)\n\n\t@classmethod\n\tdef gen(cls):\n\t\tif opt_proc != popt.DISP_DFL:\n\t\t\tfor i in cls.heads:\n\t\t\t\tyield cls.heads[i]\n\n\t@classmethod\n\tdef str(cls):\n\t\treturn cls.val\n\n\tdef __init__(self, comm, pid, filtered):\n\t\tself.comm = comm\n\t\tself.pid = pid\n\t\tself.val = cnode(0)\n\t\tself.pending = None\n\t\tself.filtered = filtered\n\t\tself.list = []\n\n\tdef __add__(self, rhs):\n\t\tself.ns += rhs.ns\n\t\tself.val += rhs.val\n\t\treturn self\n\n\tdef mark_pending(self, secs, nsecs):\n\t\tself.pending = cnode(ns(secs, nsecs))\n\n\tdef do_increment(self, migrated, fscan, mscan):\n\t\tself.pending.increment(migrated, fscan, mscan)\n\n\tdef make_complete(self, secs, nsecs):\n\t\tself.pending.complete(secs, nsecs)\n\t\tchead.val += self.pending\n\n\t\tif opt_proc != popt.DISP_DFL:\n\t\t\tself.val += self.pending\n\n\t\t\tif opt_proc == popt.DISP_PROC_VERBOSE:\n\t\t\t\tself.list.append(self.pending)\n\t\tself.pending = None\n\n\tdef enumerate(self):\n\t\tif opt_proc == popt.DISP_PROC_VERBOSE and not self.is_filtered():\n\t\t\tfor i, pelem in enumerate(self.list):\n\t\t\t\tsys.stdout.write(\"%d[%s].%d: %s\\n\" % (self.pid, self.comm, i+1, pelem))\n\n\tdef is_pending(self):\n\t\treturn self.pending != None\n\n\tdef is_filtered(self):\n\t\treturn self.filtered\n\n\tdef display(self):\n\t\tif not self.is_filtered():\n\t\t\tsys.stdout.write(\"%d[%s]: %s\\n\" % (self.pid, self.comm, self.val))\n\n\ndef trace_end():\n\tsys.stdout.write(\"total: %s\\n\" % chead.str())\n\tfor i in chead.gen():\n\t\ti.display(),\n\t\ti.enumerate()\n\ndef compaction__mm_compaction_migratepages(event_name, context, common_cpu,\n\tcommon_secs, common_nsecs, common_pid, common_comm,\n\tcommon_callchain, nr_migrated, nr_failed):\n\n\tchead.increment_pending(common_pid,\n\t\tpair(nr_migrated, nr_failed), None, None)\n\ndef compaction__mm_compaction_isolate_freepages(event_name, context, common_cpu,\n\tcommon_secs, common_nsecs, common_pid, common_comm,\n\tcommon_callchain, start_pfn, end_pfn, nr_scanned, nr_taken):\n\n\tchead.increment_pending(common_pid,\n\t\tNone, pair(nr_scanned, nr_taken), None)\n\ndef compaction__mm_compaction_isolate_migratepages(event_name, context, common_cpu,\n\tcommon_secs, common_nsecs, common_pid, common_comm,\n\tcommon_callchain, start_pfn, end_pfn, nr_scanned, nr_taken):\n\n\tchead.increment_pending(common_pid,\n\t\tNone, None, pair(nr_scanned, nr_taken))\n\ndef compaction__mm_compaction_end(event_name, context, common_cpu,\n\tcommon_secs, common_nsecs, common_pid, common_comm,\n\tcommon_callchain, zone_start, migrate_start, free_start, zone_end,\n\tsync, status):\n\n\tchead.complete_pending(common_pid, common_secs, common_nsecs)\n\ndef compaction__mm_compaction_begin(event_name, context, common_cpu,\n\tcommon_secs, common_nsecs, common_pid, common_comm,\n\tcommon_callchain, zone_start, migrate_start, free_start, zone_end,\n\tsync):\n\n\tchead.create_pending(common_pid, common_comm, common_secs, common_nsecs)\n\ndef pr_help():\n\tglobal usage\n\n\tsys.stdout.write(usage)\n\tsys.stdout.write(\"\\n\")\n\tsys.stdout.write(\"-h\tdisplay this help\\n\")\n\tsys.stdout.write(\"-p\tdisplay by process\\n\")\n\tsys.stdout.write(\"-pv\tdisplay by process (verbose)\\n\")\n\tsys.stdout.write(\"-t\tdisplay stall times only\\n\")\n\tsys.stdout.write(\"-m\tdisplay stats for migration\\n\")\n\tsys.stdout.write(\"-fs\tdisplay stats for free scanner\\n\")\n\tsys.stdout.write(\"-ms\tdisplay stats for migration scanner\\n\")\n\tsys.stdout.write(\"-u\tdisplay results in microseconds (default nanoseconds)\\n\")\n\n\ncomm_re = None\npid_re = None\npid_regex = \"^(\\d*)-(\\d*)$|^(\\d*)$\"\n\nopt_proc = popt.DISP_DFL\nopt_disp = topt.DISP_ALL\n\nopt_ns = True\n\nargc = len(sys.argv) - 1\nif argc >= 1:\n\tpid_re = re.compile(pid_regex)\n\n\tfor i, opt in enumerate(sys.argv[1:]):\n\t\tif opt[0] == \"-\":\n\t\t\tif opt == \"-h\":\n\t\t\t\tpr_help()\n\t\t\t\texit(0);\n\t\t\telif opt == \"-p\":\n\t\t\t\topt_proc = popt.DISP_PROC\n\t\t\telif opt == \"-pv\":\n\t\t\t\topt_proc = popt.DISP_PROC_VERBOSE\n\t\t\telif opt == '-u':\n\t\t\t\topt_ns = False\n\t\t\telif opt == \"-t\":\n\t\t\t\tset_type(topt.DISP_TIME)\n\t\t\telif opt == \"-m\":\n\t\t\t\tset_type(topt.DISP_MIG)\n\t\t\telif opt == \"-fs\":\n\t\t\t\tset_type(topt.DISP_ISOLFREE)\n\t\t\telif opt == \"-ms\":\n\t\t\t\tset_type(topt.DISP_ISOLMIG)\n\t\t\telse:\n\t\t\t\tsys.exit(usage)\n\n\t\telif i == argc - 1:\n\t\t\tm = pid_re.search(opt)\n\t\t\tif m != None and m.group() != \"\":\n\t\t\t\tif m.group(3) != None:\n\t\t\t\t\tf = pid_filter(m.group(3), m.group(3))\n\t\t\t\telse:\n\t\t\t\t\tf = pid_filter(m.group(1), m.group(2))\n\t\t\telse:\n\t\t\t\ttry:\n\t\t\t\t\tcomm_re=re.compile(opt)\n\t\t\t\texcept:\n\t\t\t\t\tsys.stderr.write(\"invalid regex '%s'\" % opt)\n\t\t\t\t\tsys.exit(usage)\n\t\t\t\tf = comm_filter(comm_re)\n\n\t\t\tchead.add_filter(f)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}