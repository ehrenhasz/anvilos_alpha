{
  "module_name": "task-analyzer.py",
  "hash_id": "dc6975d3f773a4237fdafac7915bfda48eff87f5a5a2d6cb0bee3e253e61e6de",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/task-analyzer.py",
  "human_readable_source": "# task-analyzer.py - comprehensive perf tasks analysis\n# SPDX-License-Identifier: GPL-2.0\n# Copyright (c) 2022, Hagen Paul Pfeifer <hagen@jauu.net>\n# Licensed under the terms of the GNU GPL License version 2\n#\n# Usage:\n#\n#     perf record -e sched:sched_switch -a -- sleep 10\n#     perf script report task-analyzer\n#\n\nfrom __future__ import print_function\nimport sys\nimport os\nimport string\nimport argparse\nimport decimal\n\n\nsys.path.append(\n    os.environ[\"PERF_EXEC_PATH\"] + \"/scripts/python/Perf-Trace-Util/lib/Perf/Trace\"\n)\nfrom perf_trace_context import *\nfrom Core import *\n\n# Definition of possible ASCII color codes\n_COLORS = {\n    \"grey\": \"\\033[90m\",\n    \"red\": \"\\033[91m\",\n    \"green\": \"\\033[92m\",\n    \"yellow\": \"\\033[93m\",\n    \"blue\": \"\\033[94m\",\n    \"violet\": \"\\033[95m\",\n    \"reset\": \"\\033[0m\",\n}\n\n# Columns will have a static size to align everything properly\n# Support of 116 days of active update with nano precision\nLEN_SWITCHED_IN = len(\"9999999.999999999\")  # 17\nLEN_SWITCHED_OUT = len(\"9999999.999999999\")  # 17\nLEN_CPU = len(\"000\")\nLEN_PID = len(\"maxvalue\")  # 8\nLEN_TID = len(\"maxvalue\")  # 8\nLEN_COMM = len(\"max-comms-length\")  # 16\nLEN_RUNTIME = len(\"999999.999\")  # 10\n# Support of 3.45 hours of timespans\nLEN_OUT_IN = len(\"99999999999.999\")  # 15\nLEN_OUT_OUT = len(\"99999999999.999\")  # 15\nLEN_IN_IN = len(\"99999999999.999\")  # 15\nLEN_IN_OUT = len(\"99999999999.999\")  # 15\n\n\n# py2/py3 compatibility layer, see PEP469\ntry:\n    dict.iteritems\nexcept AttributeError:\n    # py3\n    def itervalues(d):\n        return iter(d.values())\n\n    def iteritems(d):\n        return iter(d.items())\n\nelse:\n    # py2\n    def itervalues(d):\n        return d.itervalues()\n\n    def iteritems(d):\n        return d.iteritems()\n\n\ndef _check_color():\n    global _COLORS\n    \"\"\"user enforced no-color or if stdout is no tty we disable colors\"\"\"\n    if sys.stdout.isatty() and args.stdio_color != \"never\":\n        return\n    _COLORS = {\n        \"grey\": \"\",\n        \"red\": \"\",\n        \"green\": \"\",\n        \"yellow\": \"\",\n        \"blue\": \"\",\n        \"violet\": \"\",\n        \"reset\": \"\",\n    }\n\n\ndef _parse_args():\n    global args\n    parser = argparse.ArgumentParser(description=\"Analyze tasks behavior\")\n    parser.add_argument(\n        \"--time-limit\",\n        default=[],\n        help=\n            \"print tasks only in time[s] window e.g\"\n        \" --time-limit 123.111:789.222(print all between 123.111 and 789.222)\"\n        \" --time-limit 123: (print all from 123)\"\n        \" --time-limit :456 (print all until incl. 456)\",\n    )\n    parser.add_argument(\n        \"--summary\", action=\"store_true\", help=\"print addtional runtime information\"\n    )\n    parser.add_argument(\n        \"--summary-only\", action=\"store_true\", help=\"print only summary without traces\"\n    )\n    parser.add_argument(\n        \"--summary-extended\",\n        action=\"store_true\",\n        help=\"print the summary with additional information of max inter task times\"\n            \" relative to the prev task\",\n    )\n    parser.add_argument(\n        \"--ns\", action=\"store_true\", help=\"show timestamps in nanoseconds\"\n    )\n    parser.add_argument(\n        \"--ms\", action=\"store_true\", help=\"show timestamps in milliseconds\"\n    )\n    parser.add_argument(\n        \"--extended-times\",\n        action=\"store_true\",\n        help=\"Show the elapsed times between schedule in/schedule out\"\n            \" of this task and the schedule in/schedule out of previous occurrence\"\n            \" of the same task\",\n    )\n    parser.add_argument(\n        \"--filter-tasks\",\n        default=[],\n        help=\"filter out unneeded tasks by tid, pid or processname.\"\n        \" E.g --filter-task 1337,/sbin/init \",\n    )\n    parser.add_argument(\n        \"--limit-to-tasks\",\n        default=[],\n        help=\"limit output to selected task by tid, pid, processname.\"\n        \" E.g --limit-to-tasks 1337,/sbin/init\",\n    )\n    parser.add_argument(\n        \"--highlight-tasks\",\n        default=\"\",\n        help=\"colorize special tasks by their pid/tid/comm.\"\n        \" E.g. --highlight-tasks 1:red,mutt:yellow\"\n        \" Colors available: red,grey,yellow,blue,violet,green\",\n    )\n    parser.add_argument(\n        \"--rename-comms-by-tids\",\n        default=\"\",\n        help=\"rename task names by using tid (<tid>:<newname>,<tid>:<newname>)\"\n            \" This option is handy for inexpressive processnames like python interpreted\"\n            \" process. E.g --rename 1337:my-python-app\",\n    )\n    parser.add_argument(\n        \"--stdio-color\",\n        default=\"auto\",\n        choices=[\"always\", \"never\", \"auto\"],\n        help=\"always, never or auto, allowing configuring color output\"\n            \" via the command line\",\n    )\n    parser.add_argument(\n        \"--csv\",\n        default=\"\",\n        help=\"Write trace to file selected by user. Options, like --ns or --extended\"\n            \"-times are used.\",\n    )\n    parser.add_argument(\n        \"--csv-summary\",\n        default=\"\",\n        help=\"Write summary to file selected by user. Options, like --ns or\"\n            \" --summary-extended are used.\",\n    )\n    args = parser.parse_args()\n    args.tid_renames = dict()\n\n    _argument_filter_sanity_check()\n    _argument_prepare_check()\n\n\ndef time_uniter(unit):\n    picker = {\n        \"s\": 1,\n        \"ms\": 1e3,\n        \"us\": 1e6,\n        \"ns\": 1e9,\n    }\n    return picker[unit]\n\n\ndef _init_db():\n    global db\n    db = dict()\n    db[\"running\"] = dict()\n    db[\"cpu\"] = dict()\n    db[\"tid\"] = dict()\n    db[\"global\"] = []\n    if args.summary or args.summary_extended or args.summary_only:\n        db[\"task_info\"] = dict()\n        db[\"runtime_info\"] = dict()\n        # min values for summary depending on the header\n        db[\"task_info\"][\"pid\"] = len(\"PID\")\n        db[\"task_info\"][\"tid\"] = len(\"TID\")\n        db[\"task_info\"][\"comm\"] = len(\"Comm\")\n        db[\"runtime_info\"][\"runs\"] = len(\"Runs\")\n        db[\"runtime_info\"][\"acc\"] = len(\"Accumulated\")\n        db[\"runtime_info\"][\"max\"] = len(\"Max\")\n        db[\"runtime_info\"][\"max_at\"] = len(\"Max At\")\n        db[\"runtime_info\"][\"min\"] = len(\"Min\")\n        db[\"runtime_info\"][\"mean\"] = len(\"Mean\")\n        db[\"runtime_info\"][\"median\"] = len(\"Median\")\n        if args.summary_extended:\n            db[\"inter_times\"] = dict()\n            db[\"inter_times\"][\"out_in\"] = len(\"Out-In\")\n            db[\"inter_times\"][\"inter_at\"] = len(\"At\")\n            db[\"inter_times\"][\"out_out\"] = len(\"Out-Out\")\n            db[\"inter_times\"][\"in_in\"] = len(\"In-In\")\n            db[\"inter_times\"][\"in_out\"] = len(\"In-Out\")\n\n\ndef _median(numbers):\n    \"\"\"phython3 hat statistics module - we have nothing\"\"\"\n    n = len(numbers)\n    index = n // 2\n    if n % 2:\n        return sorted(numbers)[index]\n    return sum(sorted(numbers)[index - 1 : index + 1]) / 2\n\n\ndef _mean(numbers):\n    return sum(numbers) / len(numbers)\n\n\nclass Timespans(object):\n    \"\"\"\n    The elapsed time between two occurrences of the same task is being tracked with the\n    help of this class. There are 4 of those Timespans Out-Out, In-Out, Out-In and\n    In-In.\n    The first half of the name signals the first time point of the\n    first task. The second half of the name represents the second\n    timepoint of the second task.\n    \"\"\"\n\n    def __init__(self):\n        self._last_start = None\n        self._last_finish = None\n        self.out_out = -1\n        self.in_out = -1\n        self.out_in = -1\n        self.in_in = -1\n        if args.summary_extended:\n            self._time_in = -1\n            self.max_out_in = -1\n            self.max_at = -1\n            self.max_in_out = -1\n            self.max_in_in = -1\n            self.max_out_out = -1\n\n    def feed(self, task):\n        \"\"\"\n        Called for every recorded trace event to find process pair and calculate the\n        task timespans. Chronological ordering, feed does not do reordering\n        \"\"\"\n        if not self._last_finish:\n            self._last_start = task.time_in(time_unit)\n            self._last_finish = task.time_out(time_unit)\n            return\n        self._time_in = task.time_in()\n        time_in = task.time_in(time_unit)\n        time_out = task.time_out(time_unit)\n        self.in_in = time_in - self._last_start\n        self.out_in = time_in - self._last_finish\n        self.in_out = time_out - self._last_start\n        self.out_out = time_out - self._last_finish\n        if args.summary_extended:\n            self._update_max_entries()\n        self._last_finish = task.time_out(time_unit)\n        self._last_start = task.time_in(time_unit)\n\n    def _update_max_entries(self):\n        if self.in_in > self.max_in_in:\n            self.max_in_in = self.in_in\n        if self.out_out > self.max_out_out:\n            self.max_out_out = self.out_out\n        if self.in_out > self.max_in_out:\n            self.max_in_out = self.in_out\n        if self.out_in > self.max_out_in:\n            self.max_out_in = self.out_in\n            self.max_at = self._time_in\n\n\n\nclass Summary(object):\n    \"\"\"\n    Primary instance for calculating the summary output. Processes the whole trace to\n    find and memorize relevant data such as mean, max et cetera. This instance handles\n    dynamic alignment aspects for summary output.\n    \"\"\"\n\n    def __init__(self):\n        self._body = []\n\n    class AlignmentHelper:\n        \"\"\"\n        Used to calculated the alignment for the output of the summary.\n        \"\"\"\n        def __init__(self, pid, tid, comm, runs, acc, mean,\n                    median, min, max, max_at):\n            self.pid = pid\n            self.tid = tid\n            self.comm = comm\n            self.runs = runs\n            self.acc = acc\n            self.mean = mean\n            self.median = median\n            self.min = min\n            self.max = max\n            self.max_at = max_at\n            if args.summary_extended:\n                self.out_in = None\n                self.inter_at = None\n                self.out_out = None\n                self.in_in = None\n                self.in_out = None\n\n    def _print_header(self):\n        '''\n        Output is trimmed in _format_stats thus additional adjustment in the header\n        is needed, depending on the choice of timeunit. The adjustment corresponds\n        to the amount of column titles being adjusted in _column_titles.\n        '''\n        decimal_precision = 6 if not args.ns else 9\n        fmt = \" {{:^{}}}\".format(sum(db[\"task_info\"].values()))\n        fmt += \" {{:^{}}}\".format(\n            sum(db[\"runtime_info\"].values()) - 2 * decimal_precision\n            )\n        _header = (\"Task Information\", \"Runtime Information\")\n\n        if args.summary_extended:\n            fmt += \" {{:^{}}}\".format(\n                sum(db[\"inter_times\"].values()) - 4 * decimal_precision\n                )\n            _header += (\"Max Inter Task Times\",)\n        fd_sum.write(fmt.format(*_header) +  \"\\n\")\n\n    def _column_titles(self):\n        \"\"\"\n        Cells are being processed and displayed in different way so an alignment adjust\n        is implemented depeding on the choice of the timeunit. The positions of the max\n        values are being displayed in grey. Thus in their format two additional {},\n        are placed for color set and reset.\n        \"\"\"\n        separator, fix_csv_align = _prepare_fmt_sep()\n        decimal_precision, time_precision = _prepare_fmt_precision()\n        fmt = \"{{:>{}}}\".format(db[\"task_info\"][\"pid\"] * fix_csv_align)\n        fmt += \"{}{{:>{}}}\".format(separator, db[\"task_info\"][\"tid\"] * fix_csv_align)\n        fmt += \"{}{{:>{}}}\".format(separator, db[\"task_info\"][\"comm\"] * fix_csv_align)\n        fmt += \"{}{{:>{}}}\".format(separator, db[\"runtime_info\"][\"runs\"] * fix_csv_align)\n        fmt += \"{}{{:>{}}}\".format(separator, db[\"runtime_info\"][\"acc\"] * fix_csv_align)\n        fmt += \"{}{{:>{}}}\".format(separator, db[\"runtime_info\"][\"mean\"] * fix_csv_align)\n        fmt += \"{}{{:>{}}}\".format(\n            separator, db[\"runtime_info\"][\"median\"] * fix_csv_align\n        )\n        fmt += \"{}{{:>{}}}\".format(\n            separator, (db[\"runtime_info\"][\"min\"] - decimal_precision) * fix_csv_align\n        )\n        fmt += \"{}{{:>{}}}\".format(\n            separator, (db[\"runtime_info\"][\"max\"] - decimal_precision) * fix_csv_align\n        )\n        fmt += \"{}{{}}{{:>{}}}{{}}\".format(\n            separator, (db[\"runtime_info\"][\"max_at\"] - time_precision) * fix_csv_align\n        )\n\n        column_titles = (\"PID\", \"TID\", \"Comm\")\n        column_titles += (\"Runs\", \"Accumulated\", \"Mean\", \"Median\", \"Min\", \"Max\")\n        column_titles += (_COLORS[\"grey\"], \"Max At\", _COLORS[\"reset\"])\n\n        if args.summary_extended:\n            fmt += \"{}{{:>{}}}\".format(\n                separator,\n                (db[\"inter_times\"][\"out_in\"] - decimal_precision) * fix_csv_align\n            )\n            fmt += \"{}{{}}{{:>{}}}{{}}\".format(\n                separator,\n                (db[\"inter_times\"][\"inter_at\"] - time_precision) * fix_csv_align\n            )\n            fmt += \"{}{{:>{}}}\".format(\n                separator,\n                (db[\"inter_times\"][\"out_out\"] - decimal_precision) * fix_csv_align\n            )\n            fmt += \"{}{{:>{}}}\".format(\n                separator,\n                (db[\"inter_times\"][\"in_in\"] - decimal_precision) * fix_csv_align\n            )\n            fmt += \"{}{{:>{}}}\".format(\n                separator,\n                (db[\"inter_times\"][\"in_out\"] - decimal_precision) * fix_csv_align\n            )\n\n            column_titles += (\"Out-In\", _COLORS[\"grey\"], \"Max At\", _COLORS[\"reset\"],\n                        \"Out-Out\", \"In-In\", \"In-Out\")\n\n        fd_sum.write(fmt.format(*column_titles) + \"\\n\")\n\n\n    def _task_stats(self):\n        \"\"\"calculates the stats of every task and constructs the printable summary\"\"\"\n        for tid in sorted(db[\"tid\"]):\n            color_one_sample = _COLORS[\"grey\"]\n            color_reset = _COLORS[\"reset\"]\n            no_executed = 0\n            runtimes = []\n            time_in = []\n            timespans = Timespans()\n            for task in db[\"tid\"][tid]:\n                pid = task.pid\n                comm = task.comm\n                no_executed += 1\n                runtimes.append(task.runtime(time_unit))\n                time_in.append(task.time_in())\n                timespans.feed(task)\n            if len(runtimes) > 1:\n                color_one_sample = \"\"\n                color_reset = \"\"\n            time_max = max(runtimes)\n            time_min = min(runtimes)\n            max_at = time_in[runtimes.index(max(runtimes))]\n\n            # The size of the decimal after sum,mean and median varies, thus we cut\n            # the decimal number, by rounding it. It has no impact on the output,\n            # because we have a precision of the decimal points at the output.\n            time_sum = round(sum(runtimes), 3)\n            time_mean = round(_mean(runtimes), 3)\n            time_median = round(_median(runtimes), 3)\n\n            align_helper = self.AlignmentHelper(pid, tid, comm, no_executed, time_sum,\n                                    time_mean, time_median, time_min, time_max, max_at)\n            self._body.append([pid, tid, comm, no_executed, time_sum, color_one_sample,\n                                time_mean, time_median, time_min, time_max,\n                                _COLORS[\"grey\"], max_at, _COLORS[\"reset\"], color_reset])\n            if args.summary_extended:\n                self._body[-1].extend([timespans.max_out_in,\n                                _COLORS[\"grey\"], timespans.max_at,\n                                _COLORS[\"reset\"], timespans.max_out_out,\n                                timespans.max_in_in,\n                                timespans.max_in_out])\n                align_helper.out_in = timespans.max_out_in\n                align_helper.inter_at = timespans.max_at\n                align_helper.out_out = timespans.max_out_out\n                align_helper.in_in = timespans.max_in_in\n                align_helper.in_out = timespans.max_in_out\n            self._calc_alignments_summary(align_helper)\n\n    def _format_stats(self):\n        separator, fix_csv_align = _prepare_fmt_sep()\n        decimal_precision, time_precision = _prepare_fmt_precision()\n        len_pid = db[\"task_info\"][\"pid\"] * fix_csv_align\n        len_tid = db[\"task_info\"][\"tid\"] * fix_csv_align\n        len_comm = db[\"task_info\"][\"comm\"] * fix_csv_align\n        len_runs = db[\"runtime_info\"][\"runs\"] * fix_csv_align\n        len_acc = db[\"runtime_info\"][\"acc\"] * fix_csv_align\n        len_mean = db[\"runtime_info\"][\"mean\"] * fix_csv_align\n        len_median = db[\"runtime_info\"][\"median\"] * fix_csv_align\n        len_min = (db[\"runtime_info\"][\"min\"] - decimal_precision) * fix_csv_align\n        len_max = (db[\"runtime_info\"][\"max\"] - decimal_precision) * fix_csv_align\n        len_max_at = (db[\"runtime_info\"][\"max_at\"] - time_precision) * fix_csv_align\n        if args.summary_extended:\n            len_out_in = (\n                db[\"inter_times\"][\"out_in\"] - decimal_precision\n            ) * fix_csv_align\n            len_inter_at = (\n                db[\"inter_times\"][\"inter_at\"] - time_precision\n            ) * fix_csv_align\n            len_out_out = (\n                db[\"inter_times\"][\"out_out\"] - decimal_precision\n            ) * fix_csv_align\n            len_in_in = (db[\"inter_times\"][\"in_in\"] - decimal_precision) * fix_csv_align\n            len_in_out = (\n                db[\"inter_times\"][\"in_out\"] - decimal_precision\n            ) * fix_csv_align\n\n        fmt = \"{{:{}d}}\".format(len_pid)\n        fmt += \"{}{{:{}d}}\".format(separator, len_tid)\n        fmt += \"{}{{:>{}}}\".format(separator, len_comm)\n        fmt += \"{}{{:{}d}}\".format(separator, len_runs)\n        fmt += \"{}{{:{}.{}f}}\".format(separator, len_acc, time_precision)\n        fmt += \"{}{{}}{{:{}.{}f}}\".format(separator, len_mean, time_precision)\n        fmt += \"{}{{:{}.{}f}}\".format(separator, len_median, time_precision)\n        fmt += \"{}{{:{}.{}f}}\".format(separator, len_min, time_precision)\n        fmt += \"{}{{:{}.{}f}}\".format(separator, len_max, time_precision)\n        fmt += \"{}{{}}{{:{}.{}f}}{{}}{{}}\".format(\n            separator, len_max_at, decimal_precision\n        )\n        if args.summary_extended:\n            fmt += \"{}{{:{}.{}f}}\".format(separator, len_out_in, time_precision)\n            fmt += \"{}{{}}{{:{}.{}f}}{{}}\".format(\n                separator, len_inter_at, decimal_precision\n            )\n            fmt += \"{}{{:{}.{}f}}\".format(separator, len_out_out, time_precision)\n            fmt += \"{}{{:{}.{}f}}\".format(separator, len_in_in, time_precision)\n            fmt += \"{}{{:{}.{}f}}\".format(separator, len_in_out, time_precision)\n        return fmt\n\n\n    def _calc_alignments_summary(self, align_helper):\n        # Length is being cut in 3 groups so that further addition is easier to handle.\n        # The length of every argument from the alignment helper is being checked if it\n        # is longer than the longest until now. In that case the length is being saved.\n        for key in db[\"task_info\"]:\n            if len(str(getattr(align_helper, key))) > db[\"task_info\"][key]:\n                db[\"task_info\"][key] = len(str(getattr(align_helper, key)))\n        for key in db[\"runtime_info\"]:\n            if len(str(getattr(align_helper, key))) > db[\"runtime_info\"][key]:\n                db[\"runtime_info\"][key] = len(str(getattr(align_helper, key)))\n        if args.summary_extended:\n            for key in db[\"inter_times\"]:\n                if len(str(getattr(align_helper, key))) > db[\"inter_times\"][key]:\n                    db[\"inter_times\"][key] = len(str(getattr(align_helper, key)))\n\n\n    def print(self):\n        self._task_stats()\n        fmt = self._format_stats()\n\n        if not args.csv_summary:\n            print(\"\\nSummary\")\n            self._print_header()\n        self._column_titles()\n        for i in range(len(self._body)):\n            fd_sum.write(fmt.format(*tuple(self._body[i])) + \"\\n\")\n\n\n\nclass Task(object):\n    \"\"\" The class is used to handle the information of a given task.\"\"\"\n\n    def __init__(self, id, tid, cpu, comm):\n        self.id = id\n        self.tid = tid\n        self.cpu = cpu\n        self.comm = comm\n        self.pid = None\n        self._time_in = None\n        self._time_out = None\n\n    def schedule_in_at(self, time):\n        \"\"\"set the time where the task was scheduled in\"\"\"\n        self._time_in = time\n\n    def schedule_out_at(self, time):\n        \"\"\"set the time where the task was scheduled out\"\"\"\n        self._time_out = time\n\n    def time_out(self, unit=\"s\"):\n        \"\"\"return time where a given task was scheduled out\"\"\"\n        factor = time_uniter(unit)\n        return self._time_out * decimal.Decimal(factor)\n\n    def time_in(self, unit=\"s\"):\n        \"\"\"return time where a given task was scheduled in\"\"\"\n        factor = time_uniter(unit)\n        return self._time_in * decimal.Decimal(factor)\n\n    def runtime(self, unit=\"us\"):\n        factor = time_uniter(unit)\n        return (self._time_out - self._time_in) * decimal.Decimal(factor)\n\n    def update_pid(self, pid):\n        self.pid = pid\n\n\ndef _task_id(pid, cpu):\n    \"\"\"returns a \"unique-enough\" identifier, please do not change\"\"\"\n    return \"{}-{}\".format(pid, cpu)\n\n\ndef _filter_non_printable(unfiltered):\n    \"\"\"comm names may contain loony chars like '\\x00000'\"\"\"\n    filtered = \"\"\n    for char in unfiltered:\n        if char not in string.printable:\n            continue\n        filtered += char\n    return filtered\n\n\ndef _fmt_header():\n    separator, fix_csv_align = _prepare_fmt_sep()\n    fmt = \"{{:>{}}}\".format(LEN_SWITCHED_IN*fix_csv_align)\n    fmt += \"{}{{:>{}}}\".format(separator, LEN_SWITCHED_OUT*fix_csv_align)\n    fmt += \"{}{{:>{}}}\".format(separator, LEN_CPU*fix_csv_align)\n    fmt += \"{}{{:>{}}}\".format(separator, LEN_PID*fix_csv_align)\n    fmt += \"{}{{:>{}}}\".format(separator, LEN_TID*fix_csv_align)\n    fmt += \"{}{{:>{}}}\".format(separator, LEN_COMM*fix_csv_align)\n    fmt += \"{}{{:>{}}}\".format(separator, LEN_RUNTIME*fix_csv_align)\n    fmt += \"{}{{:>{}}}\".format(separator, LEN_OUT_IN*fix_csv_align)\n    if args.extended_times:\n        fmt += \"{}{{:>{}}}\".format(separator, LEN_OUT_OUT*fix_csv_align)\n        fmt += \"{}{{:>{}}}\".format(separator, LEN_IN_IN*fix_csv_align)\n        fmt += \"{}{{:>{}}}\".format(separator, LEN_IN_OUT*fix_csv_align)\n    return fmt\n\n\ndef _fmt_body():\n    separator, fix_csv_align = _prepare_fmt_sep()\n    decimal_precision, time_precision = _prepare_fmt_precision()\n    fmt = \"{{}}{{:{}.{}f}}\".format(LEN_SWITCHED_IN*fix_csv_align, decimal_precision)\n    fmt += \"{}{{:{}.{}f}}\".format(\n        separator, LEN_SWITCHED_OUT*fix_csv_align, decimal_precision\n    )\n    fmt += \"{}{{:{}d}}\".format(separator, LEN_CPU*fix_csv_align)\n    fmt += \"{}{{:{}d}}\".format(separator, LEN_PID*fix_csv_align)\n    fmt += \"{}{{}}{{:{}d}}{{}}\".format(separator, LEN_TID*fix_csv_align)\n    fmt += \"{}{{}}{{:>{}}}\".format(separator, LEN_COMM*fix_csv_align)\n    fmt += \"{}{{:{}.{}f}}\".format(separator, LEN_RUNTIME*fix_csv_align, time_precision)\n    if args.extended_times:\n        fmt += \"{}{{:{}.{}f}}\".format(separator, LEN_OUT_IN*fix_csv_align, time_precision)\n        fmt += \"{}{{:{}.{}f}}\".format(separator, LEN_OUT_OUT*fix_csv_align, time_precision)\n        fmt += \"{}{{:{}.{}f}}\".format(separator, LEN_IN_IN*fix_csv_align, time_precision)\n        fmt += \"{}{{:{}.{}f}}{{}}\".format(\n            separator, LEN_IN_OUT*fix_csv_align, time_precision\n        )\n    else:\n        fmt += \"{}{{:{}.{}f}}{{}}\".format(\n            separator, LEN_OUT_IN*fix_csv_align, time_precision\n        )\n    return fmt\n\n\ndef _print_header():\n    fmt = _fmt_header()\n    header = (\"Switched-In\", \"Switched-Out\", \"CPU\", \"PID\", \"TID\", \"Comm\", \"Runtime\",\n            \"Time Out-In\")\n    if args.extended_times:\n        header += (\"Time Out-Out\", \"Time In-In\", \"Time In-Out\")\n    fd_task.write(fmt.format(*header) + \"\\n\")\n\n\n\ndef _print_task_finish(task):\n    \"\"\"calculating every entry of a row and printing it immediately\"\"\"\n    c_row_set = \"\"\n    c_row_reset = \"\"\n    out_in = -1\n    out_out = -1\n    in_in = -1\n    in_out = -1\n    fmt = _fmt_body()\n    # depending on user provided highlight option we change the color\n    # for particular tasks\n    if str(task.tid) in args.highlight_tasks_map:\n        c_row_set = _COLORS[args.highlight_tasks_map[str(task.tid)]]\n        c_row_reset = _COLORS[\"reset\"]\n    if task.comm in args.highlight_tasks_map:\n        c_row_set = _COLORS[args.highlight_tasks_map[task.comm]]\n        c_row_reset = _COLORS[\"reset\"]\n    # grey-out entries if PID == TID, they\n    # are identical, no threaded model so the\n    # thread id (tid) do not matter\n    c_tid_set = \"\"\n    c_tid_reset = \"\"\n    if task.pid == task.tid:\n        c_tid_set = _COLORS[\"grey\"]\n        c_tid_reset = _COLORS[\"reset\"]\n    if task.tid in db[\"tid\"]:\n        # get last task of tid\n        last_tid_task = db[\"tid\"][task.tid][-1]\n        # feed the timespan calculate, last in tid db\n        # and second the current one\n        timespan_gap_tid = Timespans()\n        timespan_gap_tid.feed(last_tid_task)\n        timespan_gap_tid.feed(task)\n        out_in = timespan_gap_tid.out_in\n        out_out = timespan_gap_tid.out_out\n        in_in = timespan_gap_tid.in_in\n        in_out = timespan_gap_tid.in_out\n\n\n    if args.extended_times:\n        line_out = fmt.format(c_row_set, task.time_in(), task.time_out(), task.cpu,\n                        task.pid, c_tid_set, task.tid, c_tid_reset, c_row_set, task.comm,\n                        task.runtime(time_unit), out_in, out_out, in_in, in_out,\n                        c_row_reset) + \"\\n\"\n    else:\n        line_out = fmt.format(c_row_set, task.time_in(), task.time_out(), task.cpu,\n                        task.pid, c_tid_set, task.tid, c_tid_reset, c_row_set, task.comm,\n                        task.runtime(time_unit), out_in, c_row_reset) + \"\\n\"\n    try:\n        fd_task.write(line_out)\n    except(IOError):\n        # don't mangle the output if user SIGINT this script\n        sys.exit()\n\ndef _record_cleanup(_list):\n    \"\"\"\n    no need to store more then one element if --summarize\n    is not enabled\n    \"\"\"\n    if not args.summary and len(_list) > 1:\n        _list = _list[len(_list) - 1 :]\n\n\ndef _record_by_tid(task):\n    tid = task.tid\n    if tid not in db[\"tid\"]:\n        db[\"tid\"][tid] = []\n    db[\"tid\"][tid].append(task)\n    _record_cleanup(db[\"tid\"][tid])\n\n\ndef _record_by_cpu(task):\n    cpu = task.cpu\n    if cpu not in db[\"cpu\"]:\n        db[\"cpu\"][cpu] = []\n    db[\"cpu\"][cpu].append(task)\n    _record_cleanup(db[\"cpu\"][cpu])\n\n\ndef _record_global(task):\n    \"\"\"record all executed task, ordered by finish chronological\"\"\"\n    db[\"global\"].append(task)\n    _record_cleanup(db[\"global\"])\n\n\ndef _handle_task_finish(tid, cpu, time, perf_sample_dict):\n    if tid == 0:\n        return\n    _id = _task_id(tid, cpu)\n    if _id not in db[\"running\"]:\n        # may happen, if we missed the switch to\n        # event. Seen in combination with --exclude-perf\n        # where the start is filtered out, but not the\n        # switched in. Probably a bug in exclude-perf\n        # option.\n        return\n    task = db[\"running\"][_id]\n    task.schedule_out_at(time)\n\n    # record tid, during schedule in the tid\n    # is not available, update now\n    pid = int(perf_sample_dict[\"sample\"][\"pid\"])\n\n    task.update_pid(pid)\n    del db[\"running\"][_id]\n\n    # print only tasks which are not being filtered and no print of trace\n    # for summary only, but record every task.\n    if not _limit_filtered(tid, pid, task.comm) and not args.summary_only:\n        _print_task_finish(task)\n    _record_by_tid(task)\n    _record_by_cpu(task)\n    _record_global(task)\n\n\ndef _handle_task_start(tid, cpu, comm, time):\n    if tid == 0:\n        return\n    if tid in args.tid_renames:\n        comm = args.tid_renames[tid]\n    _id = _task_id(tid, cpu)\n    if _id in db[\"running\"]:\n        # handle corner cases where already running tasks\n        # are switched-to again - saw this via --exclude-perf\n        # recorded traces. We simple ignore this \"second start\"\n        # event.\n        return\n    assert _id not in db[\"running\"]\n    task = Task(_id, tid, cpu, comm)\n    task.schedule_in_at(time)\n    db[\"running\"][_id] = task\n\n\ndef _time_to_internal(time_ns):\n    \"\"\"\n    To prevent float rounding errors we use Decimal internally\n    \"\"\"\n    return decimal.Decimal(time_ns) / decimal.Decimal(1e9)\n\n\ndef _limit_filtered(tid, pid, comm):\n    if args.filter_tasks:\n        if str(tid) in args.filter_tasks or comm in args.filter_tasks:\n            return True\n        else:\n            return False\n    if args.limit_to_tasks:\n        if str(tid) in args.limit_to_tasks or comm in args.limit_to_tasks:\n            return False\n        else:\n            return True\n\n\ndef _argument_filter_sanity_check():\n    if args.limit_to_tasks and args.filter_tasks:\n        sys.exit(\"Error: Filter and Limit at the same time active.\")\n    if args.extended_times and args.summary_only:\n        sys.exit(\"Error: Summary only and extended times active.\")\n    if args.time_limit and \":\" not in args.time_limit:\n        sys.exit(\n            \"Error: No bound set for time limit. Please set bound by ':' e.g :123.\"\n        )\n    if args.time_limit and (args.summary or args.summary_only or args.summary_extended):\n        sys.exit(\"Error: Cannot set time limit and print summary\")\n    if args.csv_summary:\n        args.summary = True\n        if args.csv == args.csv_summary:\n            sys.exit(\"Error: Chosen files for csv and csv summary are the same\")\n    if args.csv and (args.summary_extended or args.summary) and not args.csv_summary:\n        sys.exit(\"Error: No file chosen to write summary to. Choose with --csv-summary \"\n        \"<file>\")\n    if args.csv and args.summary_only:\n        sys.exit(\"Error: --csv chosen and --summary-only. Standard task would not be\"\n            \"written to csv file.\")\n\ndef _argument_prepare_check():\n    global time_unit, fd_task, fd_sum\n    if args.filter_tasks:\n        args.filter_tasks = args.filter_tasks.split(\",\")\n    if args.limit_to_tasks:\n        args.limit_to_tasks = args.limit_to_tasks.split(\",\")\n    if args.time_limit:\n        args.time_limit = args.time_limit.split(\":\")\n    for rename_tuple in args.rename_comms_by_tids.split(\",\"):\n        tid_name = rename_tuple.split(\":\")\n        if len(tid_name) != 2:\n            continue\n        args.tid_renames[int(tid_name[0])] = tid_name[1]\n    args.highlight_tasks_map = dict()\n    for highlight_tasks_tuple in args.highlight_tasks.split(\",\"):\n        tasks_color_map = highlight_tasks_tuple.split(\":\")\n        # default highlight color to red if no color set by user\n        if len(tasks_color_map) == 1:\n            tasks_color_map.append(\"red\")\n        if args.highlight_tasks and tasks_color_map[1].lower() not in _COLORS:\n            sys.exit(\n                \"Error: Color not defined, please choose from grey,red,green,yellow,blue,\"\n                \"violet\"\n            )\n        if len(tasks_color_map) != 2:\n            continue\n        args.highlight_tasks_map[tasks_color_map[0]] = tasks_color_map[1]\n    time_unit = \"us\"\n    if args.ns:\n        time_unit = \"ns\"\n    elif args.ms:\n        time_unit = \"ms\"\n\n\n    fd_task = sys.stdout\n    if args.csv:\n        args.stdio_color = \"never\"\n        fd_task = open(args.csv, \"w\")\n        print(\"generating csv at\",args.csv,)\n\n    fd_sum = sys.stdout\n    if args.csv_summary:\n        args.stdio_color = \"never\"\n        fd_sum = open(args.csv_summary, \"w\")\n        print(\"generating csv summary at\",args.csv_summary)\n        if not args.csv:\n            args.summary_only = True\n\n\ndef _is_within_timelimit(time):\n    \"\"\"\n    Check if a time limit was given by parameter, if so ignore the rest. If not,\n    process the recorded trace in its entirety.\n    \"\"\"\n    if not args.time_limit:\n        return True\n    lower_time_limit = args.time_limit[0]\n    upper_time_limit = args.time_limit[1]\n    # check for upper limit\n    if upper_time_limit == \"\":\n        if time >= decimal.Decimal(lower_time_limit):\n            return True\n    # check for lower limit\n    if lower_time_limit == \"\":\n        if time <= decimal.Decimal(upper_time_limit):\n            return True\n        # quit if time exceeds upper limit. Good for big datasets\n        else:\n            quit()\n    if lower_time_limit != \"\" and upper_time_limit != \"\":\n        if (time >= decimal.Decimal(lower_time_limit) and\n            time <= decimal.Decimal(upper_time_limit)):\n            return True\n        # quit if time exceeds upper limit. Good for big datasets\n        elif time > decimal.Decimal(upper_time_limit):\n            quit()\n\ndef _prepare_fmt_precision():\n    decimal_precision = 6\n    time_precision = 3\n    if args.ns:\n     decimal_precision = 9\n     time_precision = 0\n    return decimal_precision, time_precision\n\ndef _prepare_fmt_sep():\n    separator = \" \"\n    fix_csv_align = 1\n    if args.csv or args.csv_summary:\n        separator = \";\"\n        fix_csv_align = 0\n    return separator, fix_csv_align\n\ndef trace_unhandled(event_name, context, event_fields_dict, perf_sample_dict):\n    pass\n\n\ndef trace_begin():\n    _parse_args()\n    _check_color()\n    _init_db()\n    if not args.summary_only:\n        _print_header()\n\ndef trace_end():\n    if args.summary or args.summary_extended or args.summary_only:\n        Summary().print()\n\ndef sched__sched_switch(event_name, context, common_cpu, common_secs, common_nsecs,\n                        common_pid, common_comm, common_callchain, prev_comm,\n                        prev_pid, prev_prio, prev_state, next_comm, next_pid,\n                        next_prio, perf_sample_dict):\n    # ignore common_secs & common_nsecs cause we need\n    # high res timestamp anyway, using the raw value is\n    # faster\n    time = _time_to_internal(perf_sample_dict[\"sample\"][\"time\"])\n    if not _is_within_timelimit(time):\n        # user specific --time-limit a:b set\n        return\n\n    next_comm = _filter_non_printable(next_comm)\n    _handle_task_finish(prev_pid, common_cpu, time, perf_sample_dict)\n    _handle_task_start(next_pid, common_cpu, next_comm, time)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}