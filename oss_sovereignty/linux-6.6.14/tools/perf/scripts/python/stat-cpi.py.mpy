{
  "module_name": "stat-cpi.py",
  "hash_id": "4d9099fe6279b2ee2102dd778a698c73b96a1acade3f61b225f8b45ad25110fb",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/stat-cpi.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n\nfrom __future__ import print_function\n\ndata    = {}\ntimes   = []\nthreads = []\ncpus    = []\n\ndef get_key(time, event, cpu, thread):\n    return \"%d-%s-%d-%d\" % (time, event, cpu, thread)\n\ndef store_key(time, cpu, thread):\n    if (time not in times):\n        times.append(time)\n\n    if (cpu not in cpus):\n        cpus.append(cpu)\n\n    if (thread not in threads):\n        threads.append(thread)\n\ndef store(time, event, cpu, thread, val, ena, run):\n    #print(\"event %s cpu %d, thread %d, time %d, val %d, ena %d, run %d\" %\n    #      (event, cpu, thread, time, val, ena, run))\n\n    store_key(time, cpu, thread)\n    key = get_key(time, event, cpu, thread)\n    data[key] = [ val, ena, run]\n\ndef get(time, event, cpu, thread):\n    key = get_key(time, event, cpu, thread)\n    return data[key][0]\n\ndef stat__cycles_k(cpu, thread, time, val, ena, run):\n    store(time, \"cycles\", cpu, thread, val, ena, run);\n\ndef stat__instructions_k(cpu, thread, time, val, ena, run):\n    store(time, \"instructions\", cpu, thread, val, ena, run);\n\ndef stat__cycles_u(cpu, thread, time, val, ena, run):\n    store(time, \"cycles\", cpu, thread, val, ena, run);\n\ndef stat__instructions_u(cpu, thread, time, val, ena, run):\n    store(time, \"instructions\", cpu, thread, val, ena, run);\n\ndef stat__cycles(cpu, thread, time, val, ena, run):\n    store(time, \"cycles\", cpu, thread, val, ena, run);\n\ndef stat__instructions(cpu, thread, time, val, ena, run):\n    store(time, \"instructions\", cpu, thread, val, ena, run);\n\ndef stat__interval(time):\n    for cpu in cpus:\n        for thread in threads:\n            cyc = get(time, \"cycles\", cpu, thread)\n            ins = get(time, \"instructions\", cpu, thread)\n            cpi = 0\n\n            if ins != 0:\n                cpi = cyc/float(ins)\n\n            print(\"%15f: cpu %d, thread %d -> cpi %f (%d/%d)\" % (time/(float(1000000000)), cpu, thread, cpi, cyc, ins))\n\ndef trace_end():\n    pass\n# XXX trace_end callback could be used as an alternative place\n#     to compute same values as in the script above:\n#\n#    for time in times:\n#        for cpu in cpus:\n#            for thread in threads:\n#                cyc = get(time, \"cycles\", cpu, thread)\n#                ins = get(time, \"instructions\", cpu, thread)\n#\n#                if ins != 0:\n#                    cpi = cyc/float(ins)\n#\n#                print(\"time %.9f, cpu %d, thread %d -> cpi %f\" % (time/(float(1000000000)), cpu, thread, cpi))\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}