{
  "module_name": "arm-cs-trace-disasm.py",
  "hash_id": "a06b0c244124183f6a832db800980aa9be0335f4c1d7c298fbe860986017f7e5",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/arm-cs-trace-disasm.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n# arm-cs-trace-disasm.py: ARM CoreSight Trace Dump With Disassember\n#\n# Author: Tor Jeremiassen <tor@ti.com>\n#         Mathieu Poirier <mathieu.poirier@linaro.org>\n#         Leo Yan <leo.yan@linaro.org>\n#         Al Grant <Al.Grant@arm.com>\n\nfrom __future__ import print_function\nimport os\nfrom os import path\nimport re\nfrom subprocess import *\nfrom optparse import OptionParser, make_option\n\nfrom perf_trace_context import perf_set_itrace_options, \\\n\tperf_sample_insn, perf_sample_srccode\n\n# Below are some example commands for using this script.\n#\n# Output disassembly with objdump:\n#  perf script -s scripts/python/arm-cs-trace-disasm.py \\\n#\t\t-- -d objdump -k path/to/vmlinux\n# Output disassembly with llvm-objdump:\n#  perf script -s scripts/python/arm-cs-trace-disasm.py \\\n#\t\t-- -d llvm-objdump-11 -k path/to/vmlinux\n# Output only source line and symbols:\n#  perf script -s scripts/python/arm-cs-trace-disasm.py\n\n# Command line parsing.\noption_list = [\n\t# formatting options for the bottom entry of the stack\n\tmake_option(\"-k\", \"--vmlinux\", dest=\"vmlinux_name\",\n\t\t    help=\"Set path to vmlinux file\"),\n\tmake_option(\"-d\", \"--objdump\", dest=\"objdump_name\",\n\t\t    help=\"Set path to objdump executable file\"),\n\tmake_option(\"-v\", \"--verbose\", dest=\"verbose\",\n\t\t    action=\"store_true\", default=False,\n\t\t    help=\"Enable debugging log\")\n]\n\nparser = OptionParser(option_list=option_list)\n(options, args) = parser.parse_args()\n\n# Initialize global dicts and regular expression\ndisasm_cache = dict()\ncpu_data = dict()\ndisasm_re = re.compile(\"^\\s*([0-9a-fA-F]+):\")\ndisasm_func_re = re.compile(\"^\\s*([0-9a-fA-F]+)\\s.*:\")\ncache_size = 64*1024\n\nglb_source_file_name\t= None\nglb_line_number\t\t= None\nglb_dso\t\t\t= None\n\ndef get_optional(perf_dict, field):\n       if field in perf_dict:\n               return perf_dict[field]\n       return \"[unknown]\"\n\ndef get_offset(perf_dict, field):\n\tif field in perf_dict:\n\t\treturn \"+%#x\" % perf_dict[field]\n\treturn \"\"\n\ndef get_dso_file_path(dso_name, dso_build_id):\n\tif (dso_name == \"[kernel.kallsyms]\" or dso_name == \"vmlinux\"):\n\t\tif (options.vmlinux_name):\n\t\t\treturn options.vmlinux_name;\n\t\telse:\n\t\t\treturn dso_name\n\n\tif (dso_name == \"[vdso]\") :\n\t\tappend = \"/vdso\"\n\telse:\n\t\tappend = \"/elf\"\n\n\tdso_path = os.environ['PERF_BUILDID_DIR'] + \"/\" + dso_name + \"/\" + dso_build_id + append;\n\t# Replace duplicate slash chars to single slash char\n\tdso_path = dso_path.replace('//', '/', 1)\n\treturn dso_path\n\ndef read_disam(dso_fname, dso_start, start_addr, stop_addr):\n\taddr_range = str(start_addr) + \":\" + str(stop_addr) + \":\" + dso_fname\n\n\t# Don't let the cache get too big, clear it when it hits max size\n\tif (len(disasm_cache) > cache_size):\n\t\tdisasm_cache.clear();\n\n\tif addr_range in disasm_cache:\n\t\tdisasm_output = disasm_cache[addr_range];\n\telse:\n\t\tstart_addr = start_addr - dso_start;\n\t\tstop_addr = stop_addr - dso_start;\n\t\tdisasm = [ options.objdump_name, \"-d\", \"-z\",\n\t\t\t   \"--start-address=\"+format(start_addr,\"#x\"),\n\t\t\t   \"--stop-address=\"+format(stop_addr,\"#x\") ]\n\t\tdisasm += [ dso_fname ]\n\t\tdisasm_output = check_output(disasm).decode('utf-8').split('\\n')\n\t\tdisasm_cache[addr_range] = disasm_output\n\n\treturn disasm_output\n\ndef print_disam(dso_fname, dso_start, start_addr, stop_addr):\n\tfor line in read_disam(dso_fname, dso_start, start_addr, stop_addr):\n\t\tm = disasm_func_re.search(line)\n\t\tif m is None:\n\t\t\tm = disasm_re.search(line)\n\t\t\tif m is None:\n\t\t\t\tcontinue\n\t\tprint(\"\\t\" + line)\n\ndef print_sample(sample):\n\tprint(\"Sample = { cpu: %04d addr: 0x%016x phys_addr: 0x%016x ip: 0x%016x \" \\\n\t      \"pid: %d tid: %d period: %d time: %d }\" % \\\n\t      (sample['cpu'], sample['addr'], sample['phys_addr'], \\\n\t       sample['ip'], sample['pid'], sample['tid'], \\\n\t       sample['period'], sample['time']))\n\ndef trace_begin():\n\tprint('ARM CoreSight Trace Data Assembler Dump')\n\ndef trace_end():\n\tprint('End')\n\ndef trace_unhandled(event_name, context, event_fields_dict):\n\tprint(' '.join(['%s=%s'%(k,str(v))for k,v in sorted(event_fields_dict.items())]))\n\ndef common_start_str(comm, sample):\n\tsec = int(sample[\"time\"] / 1000000000)\n\tns = sample[\"time\"] % 1000000000\n\tcpu = sample[\"cpu\"]\n\tpid = sample[\"pid\"]\n\ttid = sample[\"tid\"]\n\treturn \"%16s %5u/%-5u [%04u] %9u.%09u  \" % (comm, pid, tid, cpu, sec, ns)\n\n# This code is copied from intel-pt-events.py for printing source code\n# line and symbols.\ndef print_srccode(comm, param_dict, sample, symbol, dso):\n\tip = sample[\"ip\"]\n\tif symbol == \"[unknown]\":\n\t\tstart_str = common_start_str(comm, sample) + (\"%x\" % ip).rjust(16).ljust(40)\n\telse:\n\t\toffs = get_offset(param_dict, \"symoff\")\n\t\tstart_str = common_start_str(comm, sample) + (symbol + offs).ljust(40)\n\n\tglobal glb_source_file_name\n\tglobal glb_line_number\n\tglobal glb_dso\n\n\tsource_file_name, line_number, source_line = perf_sample_srccode(perf_script_context)\n\tif source_file_name:\n\t\tif glb_line_number == line_number and glb_source_file_name == source_file_name:\n\t\t\tsrc_str = \"\"\n\t\telse:\n\t\t\tif len(source_file_name) > 40:\n\t\t\t\tsrc_file = (\"...\" + source_file_name[-37:]) + \" \"\n\t\t\telse:\n\t\t\t\tsrc_file = source_file_name.ljust(41)\n\n\t\t\tif source_line is None:\n\t\t\t\tsrc_str = src_file + str(line_number).rjust(4) + \" <source not found>\"\n\t\t\telse:\n\t\t\t\tsrc_str = src_file + str(line_number).rjust(4) + \" \" + source_line\n\t\tglb_dso = None\n\telif dso == glb_dso:\n\t\tsrc_str = \"\"\n\telse:\n\t\tsrc_str = dso\n\t\tglb_dso = dso\n\n\tglb_line_number = line_number\n\tglb_source_file_name = source_file_name\n\n\tprint(start_str, src_str)\n\ndef process_event(param_dict):\n\tglobal cache_size\n\tglobal options\n\n\tsample = param_dict[\"sample\"]\n\tcomm = param_dict[\"comm\"]\n\n\tname = param_dict[\"ev_name\"]\n\tdso = get_optional(param_dict, \"dso\")\n\tdso_bid = get_optional(param_dict, \"dso_bid\")\n\tdso_start = get_optional(param_dict, \"dso_map_start\")\n\tdso_end = get_optional(param_dict, \"dso_map_end\")\n\tsymbol = get_optional(param_dict, \"symbol\")\n\n\tif (options.verbose == True):\n\t\tprint(\"Event type: %s\" % name)\n\t\tprint_sample(sample)\n\n\t# If cannot find dso so cannot dump assembler, bail out\n\tif (dso == '[unknown]'):\n\t\treturn\n\n\t# Validate dso start and end addresses\n\tif ((dso_start == '[unknown]') or (dso_end == '[unknown]')):\n\t\tprint(\"Failed to find valid dso map for dso %s\" % dso)\n\t\treturn\n\n\tif (name[0:12] == \"instructions\"):\n\t\tprint_srccode(comm, param_dict, sample, symbol, dso)\n\t\treturn\n\n\t# Don't proceed if this event is not a branch sample, .\n\tif (name[0:8] != \"branches\"):\n\t\treturn\n\n\tcpu = sample[\"cpu\"]\n\tip = sample[\"ip\"]\n\taddr = sample[\"addr\"]\n\n\t# Initialize CPU data if it's empty, and directly return back\n\t# if this is the first tracing event for this CPU.\n\tif (cpu_data.get(str(cpu) + 'addr') == None):\n\t\tcpu_data[str(cpu) + 'addr'] = addr\n\t\treturn\n\n\t# The format for packet is:\n\t#\n\t#\t\t  +------------+------------+------------+\n\t#  sample_prev:   |    addr    |    ip\t    |\t cpu\t |\n\t#\t\t  +------------+------------+------------+\n\t#  sample_next:   |    addr    |    ip\t    |\t cpu\t |\n\t#\t\t  +------------+------------+------------+\n\t#\n\t# We need to combine the two continuous packets to get the instruction\n\t# range for sample_prev::cpu:\n\t#\n\t#     [ sample_prev::addr .. sample_next::ip ]\n\t#\n\t# For this purose, sample_prev::addr is stored into cpu_data structure\n\t# and read back for 'start_addr' when the new packet comes, and we need\n\t# to use sample_next::ip to calculate 'stop_addr', plusing extra 4 for\n\t# 'stop_addr' is for the sake of objdump so the final assembler dump can\n\t# include last instruction for sample_next::ip.\n\tstart_addr = cpu_data[str(cpu) + 'addr']\n\tstop_addr  = ip + 4\n\n\t# Record for previous sample packet\n\tcpu_data[str(cpu) + 'addr'] = addr\n\n\t# Handle CS_ETM_TRACE_ON packet if start_addr=0 and stop_addr=4\n\tif (start_addr == 0 and stop_addr == 4):\n\t\tprint(\"CPU%d: CS_ETM_TRACE_ON packet is inserted\" % cpu)\n\t\treturn\n\n\tif (start_addr < int(dso_start) or start_addr > int(dso_end)):\n\t\tprint(\"Start address 0x%x is out of range [ 0x%x .. 0x%x ] for dso %s\" % (start_addr, int(dso_start), int(dso_end), dso))\n\t\treturn\n\n\tif (stop_addr < int(dso_start) or stop_addr > int(dso_end)):\n\t\tprint(\"Stop address 0x%x is out of range [ 0x%x .. 0x%x ] for dso %s\" % (stop_addr, int(dso_start), int(dso_end), dso))\n\t\treturn\n\n\tif (options.objdump_name != None):\n\t\t# It doesn't need to decrease virtual memory offset for disassembly\n\t\t# for kernel dso, so in this case we set vm_start to zero.\n\t\tif (dso == \"[kernel.kallsyms]\"):\n\t\t\tdso_vm_start = 0\n\t\telse:\n\t\t\tdso_vm_start = int(dso_start)\n\n\t\tdso_fname = get_dso_file_path(dso, dso_bid)\n\t\tif path.exists(dso_fname):\n\t\t\tprint_disam(dso_fname, dso_vm_start, start_addr, stop_addr)\n\t\telse:\n\t\t\tprint(\"Failed to find dso %s for address range [ 0x%x .. 0x%x ]\" % (dso, start_addr, stop_addr))\n\n\tprint_srccode(comm, param_dict, sample, symbol, dso)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}