{
  "module_name": "export-to-postgresql.py",
  "hash_id": "dd81188736cd86d04124b61138f496254a565853077272675742e497c9923d5c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/export-to-postgresql.py",
  "human_readable_source": "# export-to-postgresql.py: export perf data to a postgresql database\n# Copyright (c) 2014, Intel Corporation.\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms and conditions of the GNU General Public License,\n# version 2, as published by the Free Software Foundation.\n#\n# This program is distributed in the hope it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n# more details.\n\nfrom __future__ import print_function\n\nimport os\nimport sys\nimport struct\nimport datetime\n\n# To use this script you will need to have installed package python-pyside which\n# provides LGPL-licensed Python bindings for Qt.  You will also need the package\n# libqt4-sql-psql for Qt postgresql support.\n#\n# The script assumes postgresql is running on the local machine and that the\n# user has postgresql permissions to create databases. Examples of installing\n# postgresql and adding such a user are:\n#\n# fedora:\n#\n#\t$ sudo yum install postgresql postgresql-server qt-postgresql\n#\t$ sudo su - postgres -c initdb\n#\t$ sudo service postgresql start\n#\t$ sudo su - postgres\n#\t$ createuser -s <your user id here>    # Older versions may not support -s, in which case answer the prompt below:\n#\tShall the new role be a superuser? (y/n) y\n#\t$ sudo yum install python-pyside\n#\n#\tAlternately, to use Python3 and/or pyside 2, one of the following:\n#\t\t$ sudo yum install python3-pyside\n#\t\t$ pip install --user PySide2\n#\t\t$ pip3 install --user PySide2\n#\n# ubuntu:\n#\n#\t$ sudo apt-get install postgresql\n#\t$ sudo su - postgres\n#\t$ createuser -s <your user id here>\n#\t$ sudo apt-get install python-pyside.qtsql libqt4-sql-psql\n#\n#\tAlternately, to use Python3 and/or pyside 2, one of the following:\n#\n#\t\t$ sudo apt-get install python3-pyside.qtsql libqt4-sql-psql\n#\t\t$ sudo apt-get install python-pyside2.qtsql libqt5sql5-psql\n#\t\t$ sudo apt-get install python3-pyside2.qtsql libqt5sql5-psql\n#\n# An example of using this script with Intel PT:\n#\n#\t$ perf record -e intel_pt//u ls\n#\t$ perf script -s ~/libexec/perf-core/scripts/python/export-to-postgresql.py pt_example branches calls\n#\t2015-05-29 12:49:23.464364 Creating database...\n#\t2015-05-29 12:49:26.281717 Writing to intermediate files...\n#\t2015-05-29 12:49:27.190383 Copying to database...\n#\t2015-05-29 12:49:28.140451 Removing intermediate files...\n#\t2015-05-29 12:49:28.147451 Adding primary keys\n#\t2015-05-29 12:49:28.655683 Adding foreign keys\n#\t2015-05-29 12:49:29.365350 Done\n#\n# To browse the database, psql can be used e.g.\n#\n#\t$ psql pt_example\n#\tpt_example=# select * from samples_view where id < 100;\n#\tpt_example=# \\d+\n#\tpt_example=# \\d+ samples_view\n#\tpt_example=# \\q\n#\n# An example of using the database is provided by the script\n# exported-sql-viewer.py.  Refer to that script for details.\n#\n# Tables:\n#\n#\tThe tables largely correspond to perf tools' data structures.  They are largely self-explanatory.\n#\n#\tsamples\n#\n#\t\t'samples' is the main table. It represents what instruction was executing at a point in time\n#\t\twhen something (a selected event) happened.  The memory address is the instruction pointer or 'ip'.\n#\n#\tcalls\n#\n#\t\t'calls' represents function calls and is related to 'samples' by 'call_id' and 'return_id'.\n#\t\t'calls' is only created when the 'calls' option to this script is specified.\n#\n#\tcall_paths\n#\n#\t\t'call_paths' represents all the call stacks.  Each 'call' has an associated record in 'call_paths'.\n#\t\t'calls_paths' is only created when the 'calls' option to this script is specified.\n#\n#\tbranch_types\n#\n#\t\t'branch_types' provides descriptions for each type of branch.\n#\n#\tcomm_threads\n#\n#\t\t'comm_threads' shows how 'comms' relates to 'threads'.\n#\n#\tcomms\n#\n#\t\t'comms' contains a record for each 'comm' - the name given to the executable that is running.\n#\n#\tdsos\n#\n#\t\t'dsos' contains a record for each executable file or library.\n#\n#\tmachines\n#\n#\t\t'machines' can be used to distinguish virtual machines if virtualization is supported.\n#\n#\tselected_events\n#\n#\t\t'selected_events' contains a record for each kind of event that has been sampled.\n#\n#\tsymbols\n#\n#\t\t'symbols' contains a record for each symbol.  Only symbols that have samples are present.\n#\n#\tthreads\n#\n#\t\t'threads' contains a record for each thread.\n#\n# Views:\n#\n#\tMost of the tables have views for more friendly display.  The views are:\n#\n#\t\tcalls_view\n#\t\tcall_paths_view\n#\t\tcomm_threads_view\n#\t\tdsos_view\n#\t\tmachines_view\n#\t\tsamples_view\n#\t\tsymbols_view\n#\t\tthreads_view\n#\n# More examples of browsing the database with psql:\n#   Note that some of the examples are not the most optimal SQL query.\n#   Note that call information is only available if the script's 'calls' option has been used.\n#\n#\tTop 10 function calls (not aggregated by symbol):\n#\n#\t\tSELECT * FROM calls_view ORDER BY elapsed_time DESC LIMIT 10;\n#\n#\tTop 10 function calls (aggregated by symbol):\n#\n#\t\tSELECT symbol_id,(SELECT name FROM symbols WHERE id = symbol_id) AS symbol,\n#\t\t\tSUM(elapsed_time) AS tot_elapsed_time,SUM(branch_count) AS tot_branch_count\n#\t\t\tFROM calls_view GROUP BY symbol_id ORDER BY tot_elapsed_time DESC LIMIT 10;\n#\n#\t\tNote that the branch count gives a rough estimation of cpu usage, so functions\n#\t\tthat took a long time but have a relatively low branch count must have spent time\n#\t\twaiting.\n#\n#\tFind symbols by pattern matching on part of the name (e.g. names containing 'alloc'):\n#\n#\t\tSELECT * FROM symbols_view WHERE name LIKE '%alloc%';\n#\n#\tTop 10 function calls for a specific symbol (e.g. whose symbol_id is 187):\n#\n#\t\tSELECT * FROM calls_view WHERE symbol_id = 187 ORDER BY elapsed_time DESC LIMIT 10;\n#\n#\tShow function calls made by function in the same context (i.e. same call path) (e.g. one with call_path_id 254):\n#\n#\t\tSELECT * FROM calls_view WHERE parent_call_path_id = 254;\n#\n#\tShow branches made during a function call (e.g. where call_id is 29357 and return_id is 29370 and tid is 29670)\n#\n#\t\tSELECT * FROM samples_view WHERE id >= 29357 AND id <= 29370 AND tid = 29670 AND event LIKE 'branches%';\n#\n#\tShow transactions:\n#\n#\t\tSELECT * FROM samples_view WHERE event = 'transactions';\n#\n#\t\tNote transaction start has 'in_tx' true whereas, transaction end has 'in_tx' false.\n#\t\tTransaction aborts have branch_type_name 'transaction abort'\n#\n#\tShow transaction aborts:\n#\n#\t\tSELECT * FROM samples_view WHERE event = 'transactions' AND branch_type_name = 'transaction abort';\n#\n# To print a call stack requires walking the call_paths table.  For example this python script:\n#   #!/usr/bin/python2\n#\n#   import sys\n#   from PySide.QtSql import *\n#\n#   if __name__ == '__main__':\n#           if (len(sys.argv) < 3):\n#                   print >> sys.stderr, \"Usage is: printcallstack.py <database name> <call_path_id>\"\n#                   raise Exception(\"Too few arguments\")\n#           dbname = sys.argv[1]\n#           call_path_id = sys.argv[2]\n#           db = QSqlDatabase.addDatabase('QPSQL')\n#           db.setDatabaseName(dbname)\n#           if not db.open():\n#                   raise Exception(\"Failed to open database \" + dbname + \" error: \" + db.lastError().text())\n#           query = QSqlQuery(db)\n#           print \"    id          ip  symbol_id  symbol                          dso_id  dso_short_name\"\n#           while call_path_id != 0 and call_path_id != 1:\n#                   ret = query.exec_('SELECT * FROM call_paths_view WHERE id = ' + str(call_path_id))\n#                   if not ret:\n#                           raise Exception(\"Query failed: \" + query.lastError().text())\n#                   if not query.next():\n#                           raise Exception(\"Query failed\")\n#                   print \"{0:>6}  {1:>10}  {2:>9}  {3:<30}  {4:>6}  {5:<30}\".format(query.value(0), query.value(1), query.value(2), query.value(3), query.value(4), query.value(5))\n#                   call_path_id = query.value(6)\n\npyside_version_1 = True\nif not \"pyside-version-1\" in sys.argv:\n\ttry:\n\t\tfrom PySide2.QtSql import *\n\t\tpyside_version_1 = False\n\texcept:\n\t\tpass\n\nif pyside_version_1:\n\tfrom PySide.QtSql import *\n\nif sys.version_info < (3, 0):\n\tdef toserverstr(str):\n\t\treturn str\n\tdef toclientstr(str):\n\t\treturn str\nelse:\n\t# Assume UTF-8 server_encoding and client_encoding\n\tdef toserverstr(str):\n\t\treturn bytes(str, \"UTF_8\")\n\tdef toclientstr(str):\n\t\treturn bytes(str, \"UTF_8\")\n\n# Need to access PostgreSQL C library directly to use COPY FROM STDIN\nfrom ctypes import *\nlibpq = CDLL(\"libpq.so.5\")\nPQconnectdb = libpq.PQconnectdb\nPQconnectdb.restype = c_void_p\nPQconnectdb.argtypes = [ c_char_p ]\nPQfinish = libpq.PQfinish\nPQfinish.argtypes = [ c_void_p ]\nPQstatus = libpq.PQstatus\nPQstatus.restype = c_int\nPQstatus.argtypes = [ c_void_p ]\nPQexec = libpq.PQexec\nPQexec.restype = c_void_p\nPQexec.argtypes = [ c_void_p, c_char_p ]\nPQresultStatus = libpq.PQresultStatus\nPQresultStatus.restype = c_int\nPQresultStatus.argtypes = [ c_void_p ]\nPQputCopyData = libpq.PQputCopyData\nPQputCopyData.restype = c_int\nPQputCopyData.argtypes = [ c_void_p, c_void_p, c_int ]\nPQputCopyEnd = libpq.PQputCopyEnd\nPQputCopyEnd.restype = c_int\nPQputCopyEnd.argtypes = [ c_void_p, c_void_p ]\n\nsys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n\t'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\n# These perf imports are not used at present\n#from perf_trace_context import *\n#from Core import *\n\nperf_db_export_mode = True\nperf_db_export_calls = False\nperf_db_export_callchains = False\n\ndef printerr(*args, **kw_args):\n\tprint(*args, file=sys.stderr, **kw_args)\n\ndef printdate(*args, **kw_args):\n        print(datetime.datetime.today(), *args, sep=' ', **kw_args)\n\ndef usage():\n\tprinterr(\"Usage is: export-to-postgresql.py <database name> [<columns>] [<calls>] [<callchains>] [<pyside-version-1>]\");\n\tprinterr(\"where:  columns            'all' or 'branches'\");\n\tprinterr(\"        calls              'calls' => create calls and call_paths table\");\n\tprinterr(\"        callchains         'callchains' => create call_paths table\");\n\tprinterr(\"        pyside-version-1   'pyside-version-1' => use pyside version 1\");\n\traise Exception(\"Too few or bad arguments\")\n\nif (len(sys.argv) < 2):\n\tusage()\n\ndbname = sys.argv[1]\n\nif (len(sys.argv) >= 3):\n\tcolumns = sys.argv[2]\nelse:\n\tcolumns = \"all\"\n\nif columns not in (\"all\", \"branches\"):\n\tusage()\n\nbranches = (columns == \"branches\")\n\nfor i in range(3,len(sys.argv)):\n\tif (sys.argv[i] == \"calls\"):\n\t\tperf_db_export_calls = True\n\telif (sys.argv[i] == \"callchains\"):\n\t\tperf_db_export_callchains = True\n\telif (sys.argv[i] == \"pyside-version-1\"):\n\t\tpass\n\telse:\n\t\tusage()\n\noutput_dir_name = os.getcwd() + \"/\" + dbname + \"-perf-data\"\nos.mkdir(output_dir_name)\n\ndef do_query(q, s):\n\tif (q.exec_(s)):\n\t\treturn\n\traise Exception(\"Query failed: \" + q.lastError().text())\n\nprintdate(\"Creating database...\")\n\ndb = QSqlDatabase.addDatabase('QPSQL')\nquery = QSqlQuery(db)\ndb.setDatabaseName('postgres')\ndb.open()\ntry:\n\tdo_query(query, 'CREATE DATABASE ' + dbname)\nexcept:\n\tos.rmdir(output_dir_name)\n\traise\nquery.finish()\nquery.clear()\ndb.close()\n\ndb.setDatabaseName(dbname)\ndb.open()\n\nquery = QSqlQuery(db)\ndo_query(query, 'SET client_min_messages TO WARNING')\n\ndo_query(query, 'CREATE TABLE selected_events ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'name\t\tvarchar(80))')\ndo_query(query, 'CREATE TABLE machines ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'pid\t\tinteger,'\n\t\t'root_dir \tvarchar(4096))')\ndo_query(query, 'CREATE TABLE threads ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'machine_id\tbigint,'\n\t\t'process_id\tbigint,'\n\t\t'pid\t\tinteger,'\n\t\t'tid\t\tinteger)')\ndo_query(query, 'CREATE TABLE comms ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'comm\t\tvarchar(16),'\n\t\t'c_thread_id\tbigint,'\n\t\t'c_time\t\tbigint,'\n\t\t'exec_flag\tboolean)')\ndo_query(query, 'CREATE TABLE comm_threads ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'comm_id\tbigint,'\n\t\t'thread_id\tbigint)')\ndo_query(query, 'CREATE TABLE dsos ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'machine_id\tbigint,'\n\t\t'short_name\tvarchar(256),'\n\t\t'long_name\tvarchar(4096),'\n\t\t'build_id\tvarchar(64))')\ndo_query(query, 'CREATE TABLE symbols ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'dso_id\t\tbigint,'\n\t\t'sym_start\tbigint,'\n\t\t'sym_end\tbigint,'\n\t\t'binding\tinteger,'\n\t\t'name\t\tvarchar(2048))')\ndo_query(query, 'CREATE TABLE branch_types ('\n\t\t'id\t\tinteger\t\tNOT NULL,'\n\t\t'name\t\tvarchar(80))')\n\nif branches:\n\tdo_query(query, 'CREATE TABLE samples ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'evsel_id\tbigint,'\n\t\t'machine_id\tbigint,'\n\t\t'thread_id\tbigint,'\n\t\t'comm_id\tbigint,'\n\t\t'dso_id\t\tbigint,'\n\t\t'symbol_id\tbigint,'\n\t\t'sym_offset\tbigint,'\n\t\t'ip\t\tbigint,'\n\t\t'time\t\tbigint,'\n\t\t'cpu\t\tinteger,'\n\t\t'to_dso_id\tbigint,'\n\t\t'to_symbol_id\tbigint,'\n\t\t'to_sym_offset\tbigint,'\n\t\t'to_ip\t\tbigint,'\n\t\t'branch_type\tinteger,'\n\t\t'in_tx\t\tboolean,'\n\t\t'call_path_id\tbigint,'\n\t\t'insn_count\tbigint,'\n\t\t'cyc_count\tbigint,'\n\t\t'flags\t\tinteger)')\nelse:\n\tdo_query(query, 'CREATE TABLE samples ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'evsel_id\tbigint,'\n\t\t'machine_id\tbigint,'\n\t\t'thread_id\tbigint,'\n\t\t'comm_id\tbigint,'\n\t\t'dso_id\t\tbigint,'\n\t\t'symbol_id\tbigint,'\n\t\t'sym_offset\tbigint,'\n\t\t'ip\t\tbigint,'\n\t\t'time\t\tbigint,'\n\t\t'cpu\t\tinteger,'\n\t\t'to_dso_id\tbigint,'\n\t\t'to_symbol_id\tbigint,'\n\t\t'to_sym_offset\tbigint,'\n\t\t'to_ip\t\tbigint,'\n\t\t'period\t\tbigint,'\n\t\t'weight\t\tbigint,'\n\t\t'transaction\tbigint,'\n\t\t'data_src\tbigint,'\n\t\t'branch_type\tinteger,'\n\t\t'in_tx\t\tboolean,'\n\t\t'call_path_id\tbigint,'\n\t\t'insn_count\tbigint,'\n\t\t'cyc_count\tbigint,'\n\t\t'flags\t\tinteger)')\n\nif perf_db_export_calls or perf_db_export_callchains:\n\tdo_query(query, 'CREATE TABLE call_paths ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'parent_id\tbigint,'\n\t\t'symbol_id\tbigint,'\n\t\t'ip\t\tbigint)')\nif perf_db_export_calls:\n\tdo_query(query, 'CREATE TABLE calls ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'thread_id\tbigint,'\n\t\t'comm_id\tbigint,'\n\t\t'call_path_id\tbigint,'\n\t\t'call_time\tbigint,'\n\t\t'return_time\tbigint,'\n\t\t'branch_count\tbigint,'\n\t\t'call_id\tbigint,'\n\t\t'return_id\tbigint,'\n\t\t'parent_call_path_id\tbigint,'\n\t\t'flags\t\tinteger,'\n\t\t'parent_id\tbigint,'\n\t\t'insn_count\tbigint,'\n\t\t'cyc_count\tbigint)')\n\ndo_query(query, 'CREATE TABLE ptwrite ('\n\t'id\t\tbigint\t\tNOT NULL,'\n\t'payload\tbigint,'\n\t'exact_ip\tboolean)')\n\ndo_query(query, 'CREATE TABLE cbr ('\n\t'id\t\tbigint\t\tNOT NULL,'\n\t'cbr\t\tinteger,'\n\t'mhz\t\tinteger,'\n\t'percent\tinteger)')\n\ndo_query(query, 'CREATE TABLE mwait ('\n\t'id\t\tbigint\t\tNOT NULL,'\n\t'hints\t\tinteger,'\n\t'extensions\tinteger)')\n\ndo_query(query, 'CREATE TABLE pwre ('\n\t'id\t\tbigint\t\tNOT NULL,'\n\t'cstate\t\tinteger,'\n\t'subcstate\tinteger,'\n\t'hw\t\tboolean)')\n\ndo_query(query, 'CREATE TABLE exstop ('\n\t'id\t\tbigint\t\tNOT NULL,'\n\t'exact_ip\tboolean)')\n\ndo_query(query, 'CREATE TABLE pwrx ('\n\t'id\t\tbigint\t\tNOT NULL,'\n\t'deepest_cstate\tinteger,'\n\t'last_cstate\tinteger,'\n\t'wake_reason\tinteger)')\n\ndo_query(query, 'CREATE TABLE context_switches ('\n\t\t'id\t\tbigint\t\tNOT NULL,'\n\t\t'machine_id\tbigint,'\n\t\t'time\t\tbigint,'\n\t\t'cpu\t\tinteger,'\n\t\t'thread_out_id\tbigint,'\n\t\t'comm_out_id\tbigint,'\n\t\t'thread_in_id\tbigint,'\n\t\t'comm_in_id\tbigint,'\n\t\t'flags\t\tinteger)')\n\ndo_query(query, 'CREATE VIEW machines_view AS '\n\t'SELECT '\n\t\t'id,'\n\t\t'pid,'\n\t\t'root_dir,'\n\t\t'CASE WHEN id=0 THEN \\'unknown\\' WHEN pid=-1 THEN \\'host\\' ELSE \\'guest\\' END AS host_or_guest'\n\t' FROM machines')\n\ndo_query(query, 'CREATE VIEW dsos_view AS '\n\t'SELECT '\n\t\t'id,'\n\t\t'machine_id,'\n\t\t'(SELECT host_or_guest FROM machines_view WHERE id = machine_id) AS host_or_guest,'\n\t\t'short_name,'\n\t\t'long_name,'\n\t\t'build_id'\n\t' FROM dsos')\n\ndo_query(query, 'CREATE VIEW symbols_view AS '\n\t'SELECT '\n\t\t'id,'\n\t\t'name,'\n\t\t'(SELECT short_name FROM dsos WHERE id=dso_id) AS dso,'\n\t\t'dso_id,'\n\t\t'sym_start,'\n\t\t'sym_end,'\n\t\t'CASE WHEN binding=0 THEN \\'local\\' WHEN binding=1 THEN \\'global\\' ELSE \\'weak\\' END AS binding'\n\t' FROM symbols')\n\ndo_query(query, 'CREATE VIEW threads_view AS '\n\t'SELECT '\n\t\t'id,'\n\t\t'machine_id,'\n\t\t'(SELECT host_or_guest FROM machines_view WHERE id = machine_id) AS host_or_guest,'\n\t\t'process_id,'\n\t\t'pid,'\n\t\t'tid'\n\t' FROM threads')\n\ndo_query(query, 'CREATE VIEW comm_threads_view AS '\n\t'SELECT '\n\t\t'comm_id,'\n\t\t'(SELECT comm FROM comms WHERE id = comm_id) AS command,'\n\t\t'thread_id,'\n\t\t'(SELECT pid FROM threads WHERE id = thread_id) AS pid,'\n\t\t'(SELECT tid FROM threads WHERE id = thread_id) AS tid'\n\t' FROM comm_threads')\n\nif perf_db_export_calls or perf_db_export_callchains:\n\tdo_query(query, 'CREATE VIEW call_paths_view AS '\n\t\t'SELECT '\n\t\t\t'c.id,'\n\t\t\t'to_hex(c.ip) AS ip,'\n\t\t\t'c.symbol_id,'\n\t\t\t'(SELECT name FROM symbols WHERE id = c.symbol_id) AS symbol,'\n\t\t\t'(SELECT dso_id FROM symbols WHERE id = c.symbol_id) AS dso_id,'\n\t\t\t'(SELECT dso FROM symbols_view  WHERE id = c.symbol_id) AS dso_short_name,'\n\t\t\t'c.parent_id,'\n\t\t\t'to_hex(p.ip) AS parent_ip,'\n\t\t\t'p.symbol_id AS parent_symbol_id,'\n\t\t\t'(SELECT name FROM symbols WHERE id = p.symbol_id) AS parent_symbol,'\n\t\t\t'(SELECT dso_id FROM symbols WHERE id = p.symbol_id) AS parent_dso_id,'\n\t\t\t'(SELECT dso FROM symbols_view  WHERE id = p.symbol_id) AS parent_dso_short_name'\n\t\t' FROM call_paths c INNER JOIN call_paths p ON p.id = c.parent_id')\nif perf_db_export_calls:\n\tdo_query(query, 'CREATE VIEW calls_view AS '\n\t\t'SELECT '\n\t\t\t'calls.id,'\n\t\t\t'thread_id,'\n\t\t\t'(SELECT pid FROM threads WHERE id = thread_id) AS pid,'\n\t\t\t'(SELECT tid FROM threads WHERE id = thread_id) AS tid,'\n\t\t\t'(SELECT comm FROM comms WHERE id = comm_id) AS command,'\n\t\t\t'call_path_id,'\n\t\t\t'to_hex(ip) AS ip,'\n\t\t\t'symbol_id,'\n\t\t\t'(SELECT name FROM symbols WHERE id = symbol_id) AS symbol,'\n\t\t\t'call_time,'\n\t\t\t'return_time,'\n\t\t\t'return_time - call_time AS elapsed_time,'\n\t\t\t'branch_count,'\n\t\t\t'insn_count,'\n\t\t\t'cyc_count,'\n\t\t\t'CASE WHEN cyc_count=0 THEN CAST(0 AS NUMERIC(20, 2)) ELSE CAST((CAST(insn_count AS FLOAT) / cyc_count) AS NUMERIC(20, 2)) END AS IPC,'\n\t\t\t'call_id,'\n\t\t\t'return_id,'\n\t\t\t'CASE WHEN flags=0 THEN \\'\\' WHEN flags=1 THEN \\'no call\\' WHEN flags=2 THEN \\'no return\\' WHEN flags=3 THEN \\'no call/return\\' WHEN flags=6 THEN \\'jump\\' ELSE CAST ( flags AS VARCHAR(6) ) END AS flags,'\n\t\t\t'parent_call_path_id,'\n\t\t\t'calls.parent_id'\n\t\t' FROM calls INNER JOIN call_paths ON call_paths.id = call_path_id')\n\ndo_query(query, 'CREATE VIEW samples_view AS '\n\t'SELECT '\n\t\t'id,'\n\t\t'time,'\n\t\t'cpu,'\n\t\t'(SELECT pid FROM threads WHERE id = thread_id) AS pid,'\n\t\t'(SELECT tid FROM threads WHERE id = thread_id) AS tid,'\n\t\t'(SELECT comm FROM comms WHERE id = comm_id) AS command,'\n\t\t'(SELECT name FROM selected_events WHERE id = evsel_id) AS event,'\n\t\t'to_hex(ip) AS ip_hex,'\n\t\t'(SELECT name FROM symbols WHERE id = symbol_id) AS symbol,'\n\t\t'sym_offset,'\n\t\t'(SELECT short_name FROM dsos WHERE id = dso_id) AS dso_short_name,'\n\t\t'to_hex(to_ip) AS to_ip_hex,'\n\t\t'(SELECT name FROM symbols WHERE id = to_symbol_id) AS to_symbol,'\n\t\t'to_sym_offset,'\n\t\t'(SELECT short_name FROM dsos WHERE id = to_dso_id) AS to_dso_short_name,'\n\t\t'(SELECT name FROM branch_types WHERE id = branch_type) AS branch_type_name,'\n\t\t'in_tx,'\n\t\t'insn_count,'\n\t\t'cyc_count,'\n\t\t'CASE WHEN cyc_count=0 THEN CAST(0 AS NUMERIC(20, 2)) ELSE CAST((CAST(insn_count AS FLOAT) / cyc_count) AS NUMERIC(20, 2)) END AS IPC,'\n\t\t'flags'\n\t' FROM samples')\n\ndo_query(query, 'CREATE VIEW ptwrite_view AS '\n\t'SELECT '\n\t\t'ptwrite.id,'\n\t\t'time,'\n\t\t'cpu,'\n\t\t'to_hex(payload) AS payload_hex,'\n\t\t'CASE WHEN exact_ip=FALSE THEN \\'False\\' ELSE \\'True\\' END AS exact_ip'\n\t' FROM ptwrite'\n\t' INNER JOIN samples ON samples.id = ptwrite.id')\n\ndo_query(query, 'CREATE VIEW cbr_view AS '\n\t'SELECT '\n\t\t'cbr.id,'\n\t\t'time,'\n\t\t'cpu,'\n\t\t'cbr,'\n\t\t'mhz,'\n\t\t'percent'\n\t' FROM cbr'\n\t' INNER JOIN samples ON samples.id = cbr.id')\n\ndo_query(query, 'CREATE VIEW mwait_view AS '\n\t'SELECT '\n\t\t'mwait.id,'\n\t\t'time,'\n\t\t'cpu,'\n\t\t'to_hex(hints) AS hints_hex,'\n\t\t'to_hex(extensions) AS extensions_hex'\n\t' FROM mwait'\n\t' INNER JOIN samples ON samples.id = mwait.id')\n\ndo_query(query, 'CREATE VIEW pwre_view AS '\n\t'SELECT '\n\t\t'pwre.id,'\n\t\t'time,'\n\t\t'cpu,'\n\t\t'cstate,'\n\t\t'subcstate,'\n\t\t'CASE WHEN hw=FALSE THEN \\'False\\' ELSE \\'True\\' END AS hw'\n\t' FROM pwre'\n\t' INNER JOIN samples ON samples.id = pwre.id')\n\ndo_query(query, 'CREATE VIEW exstop_view AS '\n\t'SELECT '\n\t\t'exstop.id,'\n\t\t'time,'\n\t\t'cpu,'\n\t\t'CASE WHEN exact_ip=FALSE THEN \\'False\\' ELSE \\'True\\' END AS exact_ip'\n\t' FROM exstop'\n\t' INNER JOIN samples ON samples.id = exstop.id')\n\ndo_query(query, 'CREATE VIEW pwrx_view AS '\n\t'SELECT '\n\t\t'pwrx.id,'\n\t\t'time,'\n\t\t'cpu,'\n\t\t'deepest_cstate,'\n\t\t'last_cstate,'\n\t\t'CASE     WHEN wake_reason=1 THEN \\'Interrupt\\''\n\t\t\t' WHEN wake_reason=2 THEN \\'Timer Deadline\\''\n\t\t\t' WHEN wake_reason=4 THEN \\'Monitored Address\\''\n\t\t\t' WHEN wake_reason=8 THEN \\'HW\\''\n\t\t\t' ELSE CAST ( wake_reason AS VARCHAR(2) )'\n\t\t'END AS wake_reason'\n\t' FROM pwrx'\n\t' INNER JOIN samples ON samples.id = pwrx.id')\n\ndo_query(query, 'CREATE VIEW power_events_view AS '\n\t'SELECT '\n\t\t'samples.id,'\n\t\t'samples.time,'\n\t\t'samples.cpu,'\n\t\t'selected_events.name AS event,'\n\t\t'FORMAT(\\'%6s\\', cbr.cbr) AS cbr,'\n\t\t'FORMAT(\\'%6s\\', cbr.mhz) AS MHz,'\n\t\t'FORMAT(\\'%5s\\', cbr.percent) AS percent,'\n\t\t'to_hex(mwait.hints) AS hints_hex,'\n\t\t'to_hex(mwait.extensions) AS extensions_hex,'\n\t\t'FORMAT(\\'%3s\\', pwre.cstate) AS cstate,'\n\t\t'FORMAT(\\'%3s\\', pwre.subcstate) AS subcstate,'\n\t\t'CASE WHEN pwre.hw=FALSE THEN \\'False\\' WHEN pwre.hw=TRUE THEN \\'True\\' ELSE NULL END AS hw,'\n\t\t'CASE WHEN exstop.exact_ip=FALSE THEN \\'False\\' WHEN exstop.exact_ip=TRUE THEN \\'True\\' ELSE NULL END AS exact_ip,'\n\t\t'FORMAT(\\'%3s\\', pwrx.deepest_cstate) AS deepest_cstate,'\n\t\t'FORMAT(\\'%3s\\', pwrx.last_cstate) AS last_cstate,'\n\t\t'CASE     WHEN pwrx.wake_reason=1 THEN \\'Interrupt\\''\n\t\t\t' WHEN pwrx.wake_reason=2 THEN \\'Timer Deadline\\''\n\t\t\t' WHEN pwrx.wake_reason=4 THEN \\'Monitored Address\\''\n\t\t\t' WHEN pwrx.wake_reason=8 THEN \\'HW\\''\n\t\t\t' ELSE FORMAT(\\'%2s\\', pwrx.wake_reason)'\n\t\t'END AS wake_reason'\n\t' FROM cbr'\n\t' FULL JOIN mwait ON mwait.id = cbr.id'\n\t' FULL JOIN pwre ON pwre.id = cbr.id'\n\t' FULL JOIN exstop ON exstop.id = cbr.id'\n\t' FULL JOIN pwrx ON pwrx.id = cbr.id'\n\t' INNER JOIN samples ON samples.id = coalesce(cbr.id, mwait.id, pwre.id, exstop.id, pwrx.id)'\n\t' INNER JOIN selected_events ON selected_events.id = samples.evsel_id'\n\t' ORDER BY samples.id')\n\ndo_query(query, 'CREATE VIEW context_switches_view AS '\n\t'SELECT '\n\t\t'context_switches.id,'\n\t\t'context_switches.machine_id,'\n\t\t'context_switches.time,'\n\t\t'context_switches.cpu,'\n\t\t'th_out.pid AS pid_out,'\n\t\t'th_out.tid AS tid_out,'\n\t\t'comm_out.comm AS comm_out,'\n\t\t'th_in.pid AS pid_in,'\n\t\t'th_in.tid AS tid_in,'\n\t\t'comm_in.comm AS comm_in,'\n\t\t'CASE\t  WHEN context_switches.flags = 0 THEN \\'in\\''\n\t\t\t' WHEN context_switches.flags = 1 THEN \\'out\\''\n\t\t\t' WHEN context_switches.flags = 3 THEN \\'out preempt\\''\n\t\t\t' ELSE CAST ( context_switches.flags AS VARCHAR(11) )'\n\t\t'END AS flags'\n\t' FROM context_switches'\n\t' INNER JOIN threads AS th_out ON th_out.id   = context_switches.thread_out_id'\n\t' INNER JOIN threads AS th_in  ON th_in.id    = context_switches.thread_in_id'\n\t' INNER JOIN comms AS comm_out ON comm_out.id = context_switches.comm_out_id'\n\t' INNER JOIN comms AS comm_in  ON comm_in.id  = context_switches.comm_in_id')\n\nfile_header = struct.pack(\"!11sii\", b\"PGCOPY\\n\\377\\r\\n\\0\", 0, 0)\nfile_trailer = b\"\\377\\377\"\n\ndef open_output_file(file_name):\n\tpath_name = output_dir_name + \"/\" + file_name\n\tfile = open(path_name, \"wb+\")\n\tfile.write(file_header)\n\treturn file\n\ndef close_output_file(file):\n\tfile.write(file_trailer)\n\tfile.close()\n\ndef copy_output_file_direct(file, table_name):\n\tclose_output_file(file)\n\tsql = \"COPY \" + table_name + \" FROM '\" + file.name + \"' (FORMAT 'binary')\"\n\tdo_query(query, sql)\n\n# Use COPY FROM STDIN because security may prevent postgres from accessing the files directly\ndef copy_output_file(file, table_name):\n\tconn = PQconnectdb(toclientstr(\"dbname = \" + dbname))\n\tif (PQstatus(conn)):\n\t\traise Exception(\"COPY FROM STDIN PQconnectdb failed\")\n\tfile.write(file_trailer)\n\tfile.seek(0)\n\tsql = \"COPY \" + table_name + \" FROM STDIN (FORMAT 'binary')\"\n\tres = PQexec(conn, toclientstr(sql))\n\tif (PQresultStatus(res) != 4):\n\t\traise Exception(\"COPY FROM STDIN PQexec failed\")\n\tdata = file.read(65536)\n\twhile (len(data)):\n\t\tret = PQputCopyData(conn, data, len(data))\n\t\tif (ret != 1):\n\t\t\traise Exception(\"COPY FROM STDIN PQputCopyData failed, error \" + str(ret))\n\t\tdata = file.read(65536)\n\tret = PQputCopyEnd(conn, None)\n\tif (ret != 1):\n\t\traise Exception(\"COPY FROM STDIN PQputCopyEnd failed, error \" + str(ret))\n\tPQfinish(conn)\n\ndef remove_output_file(file):\n\tname = file.name\n\tfile.close()\n\tos.unlink(name)\n\nevsel_file\t\t= open_output_file(\"evsel_table.bin\")\nmachine_file\t\t= open_output_file(\"machine_table.bin\")\nthread_file\t\t= open_output_file(\"thread_table.bin\")\ncomm_file\t\t= open_output_file(\"comm_table.bin\")\ncomm_thread_file\t= open_output_file(\"comm_thread_table.bin\")\ndso_file\t\t= open_output_file(\"dso_table.bin\")\nsymbol_file\t\t= open_output_file(\"symbol_table.bin\")\nbranch_type_file\t= open_output_file(\"branch_type_table.bin\")\nsample_file\t\t= open_output_file(\"sample_table.bin\")\nif perf_db_export_calls or perf_db_export_callchains:\n\tcall_path_file\t\t= open_output_file(\"call_path_table.bin\")\nif perf_db_export_calls:\n\tcall_file\t\t= open_output_file(\"call_table.bin\")\nptwrite_file\t\t= open_output_file(\"ptwrite_table.bin\")\ncbr_file\t\t= open_output_file(\"cbr_table.bin\")\nmwait_file\t\t= open_output_file(\"mwait_table.bin\")\npwre_file\t\t= open_output_file(\"pwre_table.bin\")\nexstop_file\t\t= open_output_file(\"exstop_table.bin\")\npwrx_file\t\t= open_output_file(\"pwrx_table.bin\")\ncontext_switches_file\t= open_output_file(\"context_switches_table.bin\")\n\ndef trace_begin():\n\tprintdate(\"Writing to intermediate files...\")\n\t# id == 0 means unknown.  It is easier to create records for them than replace the zeroes with NULLs\n\tevsel_table(0, \"unknown\")\n\tmachine_table(0, 0, \"unknown\")\n\tthread_table(0, 0, 0, -1, -1)\n\tcomm_table(0, \"unknown\", 0, 0, 0)\n\tdso_table(0, 0, \"unknown\", \"unknown\", \"\")\n\tsymbol_table(0, 0, 0, 0, 0, \"unknown\")\n\tsample_table(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n\tif perf_db_export_calls or perf_db_export_callchains:\n\t\tcall_path_table(0, 0, 0, 0)\n\t\tcall_return_table(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n\nunhandled_count = 0\n\ndef is_table_empty(table_name):\n\tdo_query(query, 'SELECT * FROM ' + table_name + ' LIMIT 1');\n\tif query.next():\n\t\treturn False\n\treturn True\n\ndef drop(table_name):\n\tdo_query(query, 'DROP VIEW ' + table_name + '_view');\n\tdo_query(query, 'DROP TABLE ' + table_name);\n\ndef trace_end():\n\tprintdate(\"Copying to database...\")\n\tcopy_output_file(evsel_file,\t\t\"selected_events\")\n\tcopy_output_file(machine_file,\t\t\"machines\")\n\tcopy_output_file(thread_file,\t\t\"threads\")\n\tcopy_output_file(comm_file,\t\t\"comms\")\n\tcopy_output_file(comm_thread_file,\t\"comm_threads\")\n\tcopy_output_file(dso_file,\t\t\"dsos\")\n\tcopy_output_file(symbol_file,\t\t\"symbols\")\n\tcopy_output_file(branch_type_file,\t\"branch_types\")\n\tcopy_output_file(sample_file,\t\t\"samples\")\n\tif perf_db_export_calls or perf_db_export_callchains:\n\t\tcopy_output_file(call_path_file,\t\"call_paths\")\n\tif perf_db_export_calls:\n\t\tcopy_output_file(call_file,\t\t\"calls\")\n\tcopy_output_file(ptwrite_file,\t\t\"ptwrite\")\n\tcopy_output_file(cbr_file,\t\t\"cbr\")\n\tcopy_output_file(mwait_file,\t\t\"mwait\")\n\tcopy_output_file(pwre_file,\t\t\"pwre\")\n\tcopy_output_file(exstop_file,\t\t\"exstop\")\n\tcopy_output_file(pwrx_file,\t\t\"pwrx\")\n\tcopy_output_file(context_switches_file,\t\"context_switches\")\n\n\tprintdate(\"Removing intermediate files...\")\n\tremove_output_file(evsel_file)\n\tremove_output_file(machine_file)\n\tremove_output_file(thread_file)\n\tremove_output_file(comm_file)\n\tremove_output_file(comm_thread_file)\n\tremove_output_file(dso_file)\n\tremove_output_file(symbol_file)\n\tremove_output_file(branch_type_file)\n\tremove_output_file(sample_file)\n\tif perf_db_export_calls or perf_db_export_callchains:\n\t\tremove_output_file(call_path_file)\n\tif perf_db_export_calls:\n\t\tremove_output_file(call_file)\n\tremove_output_file(ptwrite_file)\n\tremove_output_file(cbr_file)\n\tremove_output_file(mwait_file)\n\tremove_output_file(pwre_file)\n\tremove_output_file(exstop_file)\n\tremove_output_file(pwrx_file)\n\tremove_output_file(context_switches_file)\n\tos.rmdir(output_dir_name)\n\tprintdate(\"Adding primary keys\")\n\tdo_query(query, 'ALTER TABLE selected_events ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE machines        ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE threads         ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE comms           ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE comm_threads    ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE dsos            ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE symbols         ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE branch_types    ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE samples         ADD PRIMARY KEY (id)')\n\tif perf_db_export_calls or perf_db_export_callchains:\n\t\tdo_query(query, 'ALTER TABLE call_paths      ADD PRIMARY KEY (id)')\n\tif perf_db_export_calls:\n\t\tdo_query(query, 'ALTER TABLE calls           ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE ptwrite         ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE cbr             ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE mwait           ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE pwre            ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE exstop          ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE pwrx            ADD PRIMARY KEY (id)')\n\tdo_query(query, 'ALTER TABLE context_switches ADD PRIMARY KEY (id)')\n\n\tprintdate(\"Adding foreign keys\")\n\tdo_query(query, 'ALTER TABLE threads '\n\t\t\t\t\t'ADD CONSTRAINT machinefk  FOREIGN KEY (machine_id)   REFERENCES machines   (id),'\n\t\t\t\t\t'ADD CONSTRAINT processfk  FOREIGN KEY (process_id)   REFERENCES threads    (id)')\n\tdo_query(query, 'ALTER TABLE comms '\n\t\t\t\t\t'ADD CONSTRAINT threadfk   FOREIGN KEY (c_thread_id)  REFERENCES threads    (id)')\n\tdo_query(query, 'ALTER TABLE comm_threads '\n\t\t\t\t\t'ADD CONSTRAINT commfk     FOREIGN KEY (comm_id)      REFERENCES comms      (id),'\n\t\t\t\t\t'ADD CONSTRAINT threadfk   FOREIGN KEY (thread_id)    REFERENCES threads    (id)')\n\tdo_query(query, 'ALTER TABLE dsos '\n\t\t\t\t\t'ADD CONSTRAINT machinefk  FOREIGN KEY (machine_id)   REFERENCES machines   (id)')\n\tdo_query(query, 'ALTER TABLE symbols '\n\t\t\t\t\t'ADD CONSTRAINT dsofk      FOREIGN KEY (dso_id)       REFERENCES dsos       (id)')\n\tdo_query(query, 'ALTER TABLE samples '\n\t\t\t\t\t'ADD CONSTRAINT evselfk    FOREIGN KEY (evsel_id)     REFERENCES selected_events (id),'\n\t\t\t\t\t'ADD CONSTRAINT machinefk  FOREIGN KEY (machine_id)   REFERENCES machines   (id),'\n\t\t\t\t\t'ADD CONSTRAINT threadfk   FOREIGN KEY (thread_id)    REFERENCES threads    (id),'\n\t\t\t\t\t'ADD CONSTRAINT commfk     FOREIGN KEY (comm_id)      REFERENCES comms      (id),'\n\t\t\t\t\t'ADD CONSTRAINT dsofk      FOREIGN KEY (dso_id)       REFERENCES dsos       (id),'\n\t\t\t\t\t'ADD CONSTRAINT symbolfk   FOREIGN KEY (symbol_id)    REFERENCES symbols    (id),'\n\t\t\t\t\t'ADD CONSTRAINT todsofk    FOREIGN KEY (to_dso_id)    REFERENCES dsos       (id),'\n\t\t\t\t\t'ADD CONSTRAINT tosymbolfk FOREIGN KEY (to_symbol_id) REFERENCES symbols    (id)')\n\tif perf_db_export_calls or perf_db_export_callchains:\n\t\tdo_query(query, 'ALTER TABLE call_paths '\n\t\t\t\t\t'ADD CONSTRAINT parentfk    FOREIGN KEY (parent_id)    REFERENCES call_paths (id),'\n\t\t\t\t\t'ADD CONSTRAINT symbolfk    FOREIGN KEY (symbol_id)    REFERENCES symbols    (id)')\n\tif perf_db_export_calls:\n\t\tdo_query(query, 'ALTER TABLE calls '\n\t\t\t\t\t'ADD CONSTRAINT threadfk    FOREIGN KEY (thread_id)    REFERENCES threads    (id),'\n\t\t\t\t\t'ADD CONSTRAINT commfk      FOREIGN KEY (comm_id)      REFERENCES comms      (id),'\n\t\t\t\t\t'ADD CONSTRAINT call_pathfk FOREIGN KEY (call_path_id) REFERENCES call_paths (id),'\n\t\t\t\t\t'ADD CONSTRAINT callfk      FOREIGN KEY (call_id)      REFERENCES samples    (id),'\n\t\t\t\t\t'ADD CONSTRAINT returnfk    FOREIGN KEY (return_id)    REFERENCES samples    (id),'\n\t\t\t\t\t'ADD CONSTRAINT parent_call_pathfk FOREIGN KEY (parent_call_path_id) REFERENCES call_paths (id)')\n\t\tdo_query(query, 'CREATE INDEX pcpid_idx ON calls (parent_call_path_id)')\n\t\tdo_query(query, 'CREATE INDEX pid_idx ON calls (parent_id)')\n\t\tdo_query(query, 'ALTER TABLE comms ADD has_calls boolean')\n\t\tdo_query(query, 'UPDATE comms SET has_calls = TRUE WHERE comms.id IN (SELECT DISTINCT comm_id FROM calls)')\n\tdo_query(query, 'ALTER TABLE ptwrite '\n\t\t\t\t\t'ADD CONSTRAINT idfk        FOREIGN KEY (id)           REFERENCES samples   (id)')\n\tdo_query(query, 'ALTER TABLE  cbr '\n\t\t\t\t\t'ADD CONSTRAINT idfk        FOREIGN KEY (id)           REFERENCES samples   (id)')\n\tdo_query(query, 'ALTER TABLE  mwait '\n\t\t\t\t\t'ADD CONSTRAINT idfk        FOREIGN KEY (id)           REFERENCES samples   (id)')\n\tdo_query(query, 'ALTER TABLE  pwre '\n\t\t\t\t\t'ADD CONSTRAINT idfk        FOREIGN KEY (id)           REFERENCES samples   (id)')\n\tdo_query(query, 'ALTER TABLE  exstop '\n\t\t\t\t\t'ADD CONSTRAINT idfk        FOREIGN KEY (id)           REFERENCES samples   (id)')\n\tdo_query(query, 'ALTER TABLE  pwrx '\n\t\t\t\t\t'ADD CONSTRAINT idfk        FOREIGN KEY (id)           REFERENCES samples   (id)')\n\tdo_query(query, 'ALTER TABLE  context_switches '\n\t\t\t\t\t'ADD CONSTRAINT machinefk   FOREIGN KEY (machine_id)    REFERENCES machines (id),'\n\t\t\t\t\t'ADD CONSTRAINT toutfk      FOREIGN KEY (thread_out_id) REFERENCES threads  (id),'\n\t\t\t\t\t'ADD CONSTRAINT tinfk       FOREIGN KEY (thread_in_id)  REFERENCES threads  (id),'\n\t\t\t\t\t'ADD CONSTRAINT coutfk      FOREIGN KEY (comm_out_id)   REFERENCES comms    (id),'\n\t\t\t\t\t'ADD CONSTRAINT cinfk       FOREIGN KEY (comm_in_id)    REFERENCES comms    (id)')\n\n\tprintdate(\"Dropping unused tables\")\n\tif is_table_empty(\"ptwrite\"):\n\t\tdrop(\"ptwrite\")\n\tif is_table_empty(\"mwait\") and is_table_empty(\"pwre\") and is_table_empty(\"exstop\") and is_table_empty(\"pwrx\"):\n\t\tdo_query(query, 'DROP VIEW power_events_view');\n\t\tdrop(\"mwait\")\n\t\tdrop(\"pwre\")\n\t\tdrop(\"exstop\")\n\t\tdrop(\"pwrx\")\n\t\tif is_table_empty(\"cbr\"):\n\t\t\tdrop(\"cbr\")\n\tif is_table_empty(\"context_switches\"):\n\t\tdrop(\"context_switches\")\n\n\tif (unhandled_count):\n\t\tprintdate(\"Warning: \", unhandled_count, \" unhandled events\")\n\tprintdate(\"Done\")\n\ndef trace_unhandled(event_name, context, event_fields_dict):\n\tglobal unhandled_count\n\tunhandled_count += 1\n\ndef sched__sched_switch(*x):\n\tpass\n\ndef evsel_table(evsel_id, evsel_name, *x):\n\tevsel_name = toserverstr(evsel_name)\n\tn = len(evsel_name)\n\tfmt = \"!hiqi\" + str(n) + \"s\"\n\tvalue = struct.pack(fmt, 2, 8, evsel_id, n, evsel_name)\n\tevsel_file.write(value)\n\ndef machine_table(machine_id, pid, root_dir, *x):\n\troot_dir = toserverstr(root_dir)\n\tn = len(root_dir)\n\tfmt = \"!hiqiii\" + str(n) + \"s\"\n\tvalue = struct.pack(fmt, 3, 8, machine_id, 4, pid, n, root_dir)\n\tmachine_file.write(value)\n\ndef thread_table(thread_id, machine_id, process_id, pid, tid, *x):\n\tvalue = struct.pack(\"!hiqiqiqiiii\", 5, 8, thread_id, 8, machine_id, 8, process_id, 4, pid, 4, tid)\n\tthread_file.write(value)\n\ndef comm_table(comm_id, comm_str, thread_id, time, exec_flag, *x):\n\tcomm_str = toserverstr(comm_str)\n\tn = len(comm_str)\n\tfmt = \"!hiqi\" + str(n) + \"s\" + \"iqiqiB\"\n\tvalue = struct.pack(fmt, 5, 8, comm_id, n, comm_str, 8, thread_id, 8, time, 1, exec_flag)\n\tcomm_file.write(value)\n\ndef comm_thread_table(comm_thread_id, comm_id, thread_id, *x):\n\tfmt = \"!hiqiqiq\"\n\tvalue = struct.pack(fmt, 3, 8, comm_thread_id, 8, comm_id, 8, thread_id)\n\tcomm_thread_file.write(value)\n\ndef dso_table(dso_id, machine_id, short_name, long_name, build_id, *x):\n\tshort_name = toserverstr(short_name)\n\tlong_name = toserverstr(long_name)\n\tbuild_id = toserverstr(build_id)\n\tn1 = len(short_name)\n\tn2 = len(long_name)\n\tn3 = len(build_id)\n\tfmt = \"!hiqiqi\" + str(n1) + \"si\"  + str(n2) + \"si\" + str(n3) + \"s\"\n\tvalue = struct.pack(fmt, 5, 8, dso_id, 8, machine_id, n1, short_name, n2, long_name, n3, build_id)\n\tdso_file.write(value)\n\ndef symbol_table(symbol_id, dso_id, sym_start, sym_end, binding, symbol_name, *x):\n\tsymbol_name = toserverstr(symbol_name)\n\tn = len(symbol_name)\n\tfmt = \"!hiqiqiqiqiii\" + str(n) + \"s\"\n\tvalue = struct.pack(fmt, 6, 8, symbol_id, 8, dso_id, 8, sym_start, 8, sym_end, 4, binding, n, symbol_name)\n\tsymbol_file.write(value)\n\ndef branch_type_table(branch_type, name, *x):\n\tname = toserverstr(name)\n\tn = len(name)\n\tfmt = \"!hiii\" + str(n) + \"s\"\n\tvalue = struct.pack(fmt, 2, 4, branch_type, n, name)\n\tbranch_type_file.write(value)\n\ndef sample_table(sample_id, evsel_id, machine_id, thread_id, comm_id, dso_id, symbol_id, sym_offset, ip, time, cpu, to_dso_id, to_symbol_id, to_sym_offset, to_ip, period, weight, transaction, data_src, branch_type, in_tx, call_path_id, insn_cnt, cyc_cnt, flags, *x):\n\tif branches:\n\t\tvalue = struct.pack(\"!hiqiqiqiqiqiqiqiqiqiqiiiqiqiqiqiiiBiqiqiqii\", 21, 8, sample_id, 8, evsel_id, 8, machine_id, 8, thread_id, 8, comm_id, 8, dso_id, 8, symbol_id, 8, sym_offset, 8, ip, 8, time, 4, cpu, 8, to_dso_id, 8, to_symbol_id, 8, to_sym_offset, 8, to_ip, 4, branch_type, 1, in_tx, 8, call_path_id, 8, insn_cnt, 8, cyc_cnt, 4, flags)\n\telse:\n\t\tvalue = struct.pack(\"!hiqiqiqiqiqiqiqiqiqiqiiiqiqiqiqiqiqiqiqiiiBiqiqiqii\", 25, 8, sample_id, 8, evsel_id, 8, machine_id, 8, thread_id, 8, comm_id, 8, dso_id, 8, symbol_id, 8, sym_offset, 8, ip, 8, time, 4, cpu, 8, to_dso_id, 8, to_symbol_id, 8, to_sym_offset, 8, to_ip, 8, period, 8, weight, 8, transaction, 8, data_src, 4, branch_type, 1, in_tx, 8, call_path_id, 8, insn_cnt, 8, cyc_cnt, 4, flags)\n\tsample_file.write(value)\n\ndef call_path_table(cp_id, parent_id, symbol_id, ip, *x):\n\tfmt = \"!hiqiqiqiq\"\n\tvalue = struct.pack(fmt, 4, 8, cp_id, 8, parent_id, 8, symbol_id, 8, ip)\n\tcall_path_file.write(value)\n\ndef call_return_table(cr_id, thread_id, comm_id, call_path_id, call_time, return_time, branch_count, call_id, return_id, parent_call_path_id, flags, parent_id, insn_cnt, cyc_cnt, *x):\n\tfmt = \"!hiqiqiqiqiqiqiqiqiqiqiiiqiqiq\"\n\tvalue = struct.pack(fmt, 14, 8, cr_id, 8, thread_id, 8, comm_id, 8, call_path_id, 8, call_time, 8, return_time, 8, branch_count, 8, call_id, 8, return_id, 8, parent_call_path_id, 4, flags, 8, parent_id, 8, insn_cnt, 8, cyc_cnt)\n\tcall_file.write(value)\n\ndef ptwrite(id, raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\tflags = data[0]\n\tpayload = data[1]\n\texact_ip = flags & 1\n\tvalue = struct.pack(\"!hiqiqiB\", 3, 8, id, 8, payload, 1, exact_ip)\n\tptwrite_file.write(value)\n\ndef cbr(id, raw_buf):\n\tdata = struct.unpack_from(\"<BBBBII\", raw_buf)\n\tcbr = data[0]\n\tMHz = (data[4] + 500) / 1000\n\tpercent = ((cbr * 1000 / data[2]) + 5) / 10\n\tvalue = struct.pack(\"!hiqiiiiii\", 4, 8, id, 4, cbr, 4, int(MHz), 4, int(percent))\n\tcbr_file.write(value)\n\ndef mwait(id, raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\tpayload = data[1]\n\thints = payload & 0xff\n\textensions = (payload >> 32) & 0x3\n\tvalue = struct.pack(\"!hiqiiii\", 3, 8, id, 4, hints, 4, extensions)\n\tmwait_file.write(value)\n\ndef pwre(id, raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\tpayload = data[1]\n\thw = (payload >> 7) & 1\n\tcstate = (payload >> 12) & 0xf\n\tsubcstate = (payload >> 8) & 0xf\n\tvalue = struct.pack(\"!hiqiiiiiB\", 4, 8, id, 4, cstate, 4, subcstate, 1, hw)\n\tpwre_file.write(value)\n\ndef exstop(id, raw_buf):\n\tdata = struct.unpack_from(\"<I\", raw_buf)\n\tflags = data[0]\n\texact_ip = flags & 1\n\tvalue = struct.pack(\"!hiqiB\", 2, 8, id, 1, exact_ip)\n\texstop_file.write(value)\n\ndef pwrx(id, raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\tpayload = data[1]\n\tdeepest_cstate = payload & 0xf\n\tlast_cstate = (payload >> 4) & 0xf\n\twake_reason = (payload >> 8) & 0xf\n\tvalue = struct.pack(\"!hiqiiiiii\", 4, 8, id, 4, deepest_cstate, 4, last_cstate, 4, wake_reason)\n\tpwrx_file.write(value)\n\ndef synth_data(id, config, raw_buf, *x):\n\tif config == 0:\n\t\tptwrite(id, raw_buf)\n\telif config == 1:\n\t\tmwait(id, raw_buf)\n\telif config == 2:\n\t\tpwre(id, raw_buf)\n\telif config == 3:\n\t\texstop(id, raw_buf)\n\telif config == 4:\n\t\tpwrx(id, raw_buf)\n\telif config == 5:\n\t\tcbr(id, raw_buf)\n\ndef context_switch_table(id, machine_id, time, cpu, thread_out_id, comm_out_id, thread_in_id, comm_in_id, flags, *x):\n\tfmt = \"!hiqiqiqiiiqiqiqiqii\"\n\tvalue = struct.pack(fmt, 9, 8, id, 8, machine_id, 8, time, 4, cpu, 8, thread_out_id, 8, comm_out_id, 8, thread_in_id, 8, comm_in_id, 4, flags)\n\tcontext_switches_file.write(value)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}