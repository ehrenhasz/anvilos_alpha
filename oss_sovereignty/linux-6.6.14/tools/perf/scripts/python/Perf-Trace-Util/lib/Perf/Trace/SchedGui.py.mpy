{
  "module_name": "SchedGui.py",
  "hash_id": "9464635385bd72a80bcd543e61a29dfe19f0cc50a197574eee92302fe49533e1",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/Perf-Trace-Util/lib/Perf/Trace/SchedGui.py",
  "human_readable_source": "# SchedGui.py - Python extension for perf script, basic GUI code for\n#\t\ttraces drawing and overview.\n#\n# Copyright (C) 2010 by Frederic Weisbecker <fweisbec@gmail.com>\n#\n# This software is distributed under the terms of the GNU General\n# Public License (\"GPL\") version 2 as published by the Free Software\n# Foundation.\n\n\ntry:\n\timport wx\nexcept ImportError:\n\traise ImportError(\"You need to install the wxpython lib for this script\")\n\n\nclass RootFrame(wx.Frame):\n\tY_OFFSET = 100\n\tRECT_HEIGHT = 100\n\tRECT_SPACE = 50\n\tEVENT_MARKING_WIDTH = 5\n\n\tdef __init__(self, sched_tracer, title, parent = None, id = -1):\n\t\twx.Frame.__init__(self, parent, id, title)\n\n\t\t(self.screen_width, self.screen_height) = wx.GetDisplaySize()\n\t\tself.screen_width -= 10\n\t\tself.screen_height -= 10\n\t\tself.zoom = 0.5\n\t\tself.scroll_scale = 20\n\t\tself.sched_tracer = sched_tracer\n\t\tself.sched_tracer.set_root_win(self)\n\t\t(self.ts_start, self.ts_end) = sched_tracer.interval()\n\t\tself.update_width_virtual()\n\t\tself.nr_rects = sched_tracer.nr_rectangles() + 1\n\t\tself.height_virtual = RootFrame.Y_OFFSET + (self.nr_rects * (RootFrame.RECT_HEIGHT + RootFrame.RECT_SPACE))\n\n\t\t# whole window panel\n\t\tself.panel = wx.Panel(self, size=(self.screen_width, self.screen_height))\n\n\t\t# scrollable container\n\t\tself.scroll = wx.ScrolledWindow(self.panel)\n\t\tself.scroll.SetScrollbars(self.scroll_scale, self.scroll_scale, self.width_virtual / self.scroll_scale, self.height_virtual / self.scroll_scale)\n\t\tself.scroll.EnableScrolling(True, True)\n\t\tself.scroll.SetFocus()\n\n\t\t# scrollable drawing area\n\t\tself.scroll_panel = wx.Panel(self.scroll, size=(self.screen_width - 15, self.screen_height / 2))\n\t\tself.scroll_panel.Bind(wx.EVT_PAINT, self.on_paint)\n\t\tself.scroll_panel.Bind(wx.EVT_KEY_DOWN, self.on_key_press)\n\t\tself.scroll_panel.Bind(wx.EVT_LEFT_DOWN, self.on_mouse_down)\n\t\tself.scroll.Bind(wx.EVT_PAINT, self.on_paint)\n\t\tself.scroll.Bind(wx.EVT_KEY_DOWN, self.on_key_press)\n\t\tself.scroll.Bind(wx.EVT_LEFT_DOWN, self.on_mouse_down)\n\n\t\tself.scroll.Fit()\n\t\tself.Fit()\n\n\t\tself.scroll_panel.SetDimensions(-1, -1, self.width_virtual, self.height_virtual, wx.SIZE_USE_EXISTING)\n\n\t\tself.txt = None\n\n\t\tself.Show(True)\n\n\tdef us_to_px(self, val):\n\t\treturn val / (10 ** 3) * self.zoom\n\n\tdef px_to_us(self, val):\n\t\treturn (val / self.zoom) * (10 ** 3)\n\n\tdef scroll_start(self):\n\t\t(x, y) = self.scroll.GetViewStart()\n\t\treturn (x * self.scroll_scale, y * self.scroll_scale)\n\n\tdef scroll_start_us(self):\n\t\t(x, y) = self.scroll_start()\n\t\treturn self.px_to_us(x)\n\n\tdef paint_rectangle_zone(self, nr, color, top_color, start, end):\n\t\toffset_px = self.us_to_px(start - self.ts_start)\n\t\twidth_px = self.us_to_px(end - self.ts_start)\n\n\t\toffset_py = RootFrame.Y_OFFSET + (nr * (RootFrame.RECT_HEIGHT + RootFrame.RECT_SPACE))\n\t\twidth_py = RootFrame.RECT_HEIGHT\n\n\t\tdc = self.dc\n\n\t\tif top_color is not None:\n\t\t\t(r, g, b) = top_color\n\t\t\ttop_color = wx.Colour(r, g, b)\n\t\t\tbrush = wx.Brush(top_color, wx.SOLID)\n\t\t\tdc.SetBrush(brush)\n\t\t\tdc.DrawRectangle(offset_px, offset_py, width_px, RootFrame.EVENT_MARKING_WIDTH)\n\t\t\twidth_py -= RootFrame.EVENT_MARKING_WIDTH\n\t\t\toffset_py += RootFrame.EVENT_MARKING_WIDTH\n\n\t\t(r ,g, b) = color\n\t\tcolor = wx.Colour(r, g, b)\n\t\tbrush = wx.Brush(color, wx.SOLID)\n\t\tdc.SetBrush(brush)\n\t\tdc.DrawRectangle(offset_px, offset_py, width_px, width_py)\n\n\tdef update_rectangles(self, dc, start, end):\n\t\tstart += self.ts_start\n\t\tend += self.ts_start\n\t\tself.sched_tracer.fill_zone(start, end)\n\n\tdef on_paint(self, event):\n\t\tdc = wx.PaintDC(self.scroll_panel)\n\t\tself.dc = dc\n\n\t\twidth = min(self.width_virtual, self.screen_width)\n\t\t(x, y) = self.scroll_start()\n\t\tstart = self.px_to_us(x)\n\t\tend = self.px_to_us(x + width)\n\t\tself.update_rectangles(dc, start, end)\n\n\tdef rect_from_ypixel(self, y):\n\t\ty -= RootFrame.Y_OFFSET\n\t\trect = y / (RootFrame.RECT_HEIGHT + RootFrame.RECT_SPACE)\n\t\theight = y % (RootFrame.RECT_HEIGHT + RootFrame.RECT_SPACE)\n\n\t\tif rect < 0 or rect > self.nr_rects - 1 or height > RootFrame.RECT_HEIGHT:\n\t\t\treturn -1\n\n\t\treturn rect\n\n\tdef update_summary(self, txt):\n\t\tif self.txt:\n\t\t\tself.txt.Destroy()\n\t\tself.txt = wx.StaticText(self.panel, -1, txt, (0, (self.screen_height / 2) + 50))\n\n\n\tdef on_mouse_down(self, event):\n\t\t(x, y) = event.GetPositionTuple()\n\t\trect = self.rect_from_ypixel(y)\n\t\tif rect == -1:\n\t\t\treturn\n\n\t\tt = self.px_to_us(x) + self.ts_start\n\n\t\tself.sched_tracer.mouse_down(rect, t)\n\n\n\tdef update_width_virtual(self):\n\t\tself.width_virtual = self.us_to_px(self.ts_end - self.ts_start)\n\n\tdef __zoom(self, x):\n\t\tself.update_width_virtual()\n\t\t(xpos, ypos) = self.scroll.GetViewStart()\n\t\txpos = self.us_to_px(x) / self.scroll_scale\n\t\tself.scroll.SetScrollbars(self.scroll_scale, self.scroll_scale, self.width_virtual / self.scroll_scale, self.height_virtual / self.scroll_scale, xpos, ypos)\n\t\tself.Refresh()\n\n\tdef zoom_in(self):\n\t\tx = self.scroll_start_us()\n\t\tself.zoom *= 2\n\t\tself.__zoom(x)\n\n\tdef zoom_out(self):\n\t\tx = self.scroll_start_us()\n\t\tself.zoom /= 2\n\t\tself.__zoom(x)\n\n\n\tdef on_key_press(self, event):\n\t\tkey = event.GetRawKeyCode()\n\t\tif key == ord(\"+\"):\n\t\t\tself.zoom_in()\n\t\t\treturn\n\t\tif key == ord(\"-\"):\n\t\t\tself.zoom_out()\n\t\t\treturn\n\n\t\tkey = event.GetKeyCode()\n\t\t(x, y) = self.scroll.GetViewStart()\n\t\tif key == wx.WXK_RIGHT:\n\t\t\tself.scroll.Scroll(x + 1, y)\n\t\telif key == wx.WXK_LEFT:\n\t\t\tself.scroll.Scroll(x - 1, y)\n\t\telif key == wx.WXK_DOWN:\n\t\t\tself.scroll.Scroll(x, y + 1)\n\t\telif key == wx.WXK_UP:\n\t\t\tself.scroll.Scroll(x, y - 1)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}