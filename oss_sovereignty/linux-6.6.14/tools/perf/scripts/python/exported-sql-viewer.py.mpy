{
  "module_name": "exported-sql-viewer.py",
  "hash_id": "7fc08a7efdaad94cbf32d6c16a1ffbaa9359b4711a4185e329b92fd9396bd0e2",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/exported-sql-viewer.py",
  "human_readable_source": "#!/usr/bin/env python\n# SPDX-License-Identifier: GPL-2.0\n# exported-sql-viewer.py: view data from sql database\n# Copyright (c) 2014-2018, Intel Corporation.\n\n# To use this script you will need to have exported data using either the\n# export-to-sqlite.py or the export-to-postgresql.py script.  Refer to those\n# scripts for details.\n#\n# Following on from the example in the export scripts, a\n# call-graph can be displayed for the pt_example database like this:\n#\n#\tpython tools/perf/scripts/python/exported-sql-viewer.py pt_example\n#\n# Note that for PostgreSQL, this script supports connecting to remote databases\n# by setting hostname, port, username, password, and dbname e.g.\n#\n#\tpython tools/perf/scripts/python/exported-sql-viewer.py \"hostname=myhost username=myuser password=mypassword dbname=pt_example\"\n#\n# The result is a GUI window with a tree representing a context-sensitive\n# call-graph.  Expanding a couple of levels of the tree and adjusting column\n# widths to suit will display something like:\n#\n#                                         Call Graph: pt_example\n# Call Path                          Object      Count   Time(ns)  Time(%)  Branch Count   Branch Count(%)\n# v- ls\n#     v- 2638:2638\n#         v- _start                  ld-2.19.so    1     10074071   100.0         211135            100.0\n#           |- unknown               unknown       1        13198     0.1              1              0.0\n#           >- _dl_start             ld-2.19.so    1      1400980    13.9          19637              9.3\n#           >- _d_linit_internal     ld-2.19.so    1       448152     4.4          11094              5.3\n#           v-__libc_start_main@plt  ls            1      8211741    81.5         180397             85.4\n#              >- _dl_fixup          ld-2.19.so    1         7607     0.1            108              0.1\n#              >- __cxa_atexit       libc-2.19.so  1        11737     0.1             10              0.0\n#              >- __libc_csu_init    ls            1        10354     0.1             10              0.0\n#              |- _setjmp            libc-2.19.so  1            0     0.0              4              0.0\n#              v- main               ls            1      8182043    99.6         180254             99.9\n#\n# Points to note:\n#\tThe top level is a command name (comm)\n#\tThe next level is a thread (pid:tid)\n#\tSubsequent levels are functions\n#\t'Count' is the number of calls\n#\t'Time' is the elapsed time until the function returns\n#\tPercentages are relative to the level above\n#\t'Branch Count' is the total number of branches for that function and all\n#       functions that it calls\n\n# There is also a \"All branches\" report, which displays branches and\n# possibly disassembly.  However, presently, the only supported disassembler is\n# Intel XED, and additionally the object code must be present in perf build ID\n# cache. To use Intel XED, libxed.so must be present. To build and install\n# libxed.so:\n#            git clone https://github.com/intelxed/mbuild.git mbuild\n#            git clone https://github.com/intelxed/xed\n#            cd xed\n#            ./mfile.py --share\n#            sudo ./mfile.py --prefix=/usr/local install\n#            sudo ldconfig\n#\n# Example report:\n#\n# Time           CPU  Command  PID    TID    Branch Type            In Tx  Branch\n# 8107675239590  2    ls       22011  22011  return from interrupt  No     ffffffff86a00a67 native_irq_return_iret ([kernel]) -> 7fab593ea260 _start (ld-2.19.so)\n#                                                                              7fab593ea260 48 89 e7                                        mov %rsp, %rdi\n# 8107675239899  2    ls       22011  22011  hardware interrupt     No         7fab593ea260 _start (ld-2.19.so) -> ffffffff86a012e0 page_fault ([kernel])\n# 8107675241900  2    ls       22011  22011  return from interrupt  No     ffffffff86a00a67 native_irq_return_iret ([kernel]) -> 7fab593ea260 _start (ld-2.19.so)\n#                                                                              7fab593ea260 48 89 e7                                        mov %rsp, %rdi\n#                                                                              7fab593ea263 e8 c8 06 00 00                                  callq  0x7fab593ea930\n# 8107675241900  2    ls       22011  22011  call                   No         7fab593ea263 _start+0x3 (ld-2.19.so) -> 7fab593ea930 _dl_start (ld-2.19.so)\n#                                                                              7fab593ea930 55                                              pushq  %rbp\n#                                                                              7fab593ea931 48 89 e5                                        mov %rsp, %rbp\n#                                                                              7fab593ea934 41 57                                           pushq  %r15\n#                                                                              7fab593ea936 41 56                                           pushq  %r14\n#                                                                              7fab593ea938 41 55                                           pushq  %r13\n#                                                                              7fab593ea93a 41 54                                           pushq  %r12\n#                                                                              7fab593ea93c 53                                              pushq  %rbx\n#                                                                              7fab593ea93d 48 89 fb                                        mov %rdi, %rbx\n#                                                                              7fab593ea940 48 83 ec 68                                     sub $0x68, %rsp\n#                                                                              7fab593ea944 0f 31                                           rdtsc\n#                                                                              7fab593ea946 48 c1 e2 20                                     shl $0x20, %rdx\n#                                                                              7fab593ea94a 89 c0                                           mov %eax, %eax\n#                                                                              7fab593ea94c 48 09 c2                                        or %rax, %rdx\n#                                                                              7fab593ea94f 48 8b 05 1a 15 22 00                            movq  0x22151a(%rip), %rax\n# 8107675242232  2    ls       22011  22011  hardware interrupt     No         7fab593ea94f _dl_start+0x1f (ld-2.19.so) -> ffffffff86a012e0 page_fault ([kernel])\n# 8107675242900  2    ls       22011  22011  return from interrupt  No     ffffffff86a00a67 native_irq_return_iret ([kernel]) -> 7fab593ea94f _dl_start+0x1f (ld-2.19.so)\n#                                                                              7fab593ea94f 48 8b 05 1a 15 22 00                            movq  0x22151a(%rip), %rax\n#                                                                              7fab593ea956 48 89 15 3b 13 22 00                            movq  %rdx, 0x22133b(%rip)\n# 8107675243232  2    ls       22011  22011  hardware interrupt     No         7fab593ea956 _dl_start+0x26 (ld-2.19.so) -> ffffffff86a012e0 page_fault ([kernel])\n\nfrom __future__ import print_function\n\nimport sys\n# Only change warnings if the python -W option was not used\nif not sys.warnoptions:\n\timport warnings\n\t# PySide2 causes deprecation warnings, ignore them.\n\twarnings.filterwarnings(\"ignore\", category=DeprecationWarning)\nimport argparse\nimport weakref\nimport threading\nimport string\ntry:\n\t# Python2\n\timport cPickle as pickle\n\t# size of pickled integer big enough for record size\n\tglb_nsz = 8\nexcept ImportError:\n\timport pickle\n\tglb_nsz = 16\nimport re\nimport os\nimport random\nimport copy\nimport math\nfrom libxed import LibXED\n\npyside_version_1 = True\nif not \"--pyside-version-1\" in sys.argv:\n\ttry:\n\t\tfrom PySide2.QtCore import *\n\t\tfrom PySide2.QtGui import *\n\t\tfrom PySide2.QtSql import *\n\t\tfrom PySide2.QtWidgets import *\n\t\tpyside_version_1 = False\n\texcept:\n\t\tpass\n\nif pyside_version_1:\n\tfrom PySide.QtCore import *\n\tfrom PySide.QtGui import *\n\tfrom PySide.QtSql import *\n\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom ctypes import CDLL, Structure, create_string_buffer, addressof, sizeof, \\\n\t\t   c_void_p, c_bool, c_byte, c_char, c_int, c_uint, c_longlong, c_ulonglong\nfrom multiprocessing import Process, Array, Value, Event\n\n# xrange is range in Python3\ntry:\n\txrange\nexcept NameError:\n\txrange = range\n\ndef printerr(*args, **keyword_args):\n\tprint(*args, file=sys.stderr, **keyword_args)\n\n# Data formatting helpers\n\ndef tohex(ip):\n\tif ip < 0:\n\t\tip += 1 << 64\n\treturn \"%x\" % ip\n\ndef offstr(offset):\n\tif offset:\n\t\treturn \"+0x%x\" % offset\n\treturn \"\"\n\ndef dsoname(name):\n\tif name == \"[kernel.kallsyms]\":\n\t\treturn \"[kernel]\"\n\treturn name\n\ndef findnth(s, sub, n, offs=0):\n\tpos = s.find(sub)\n\tif pos < 0:\n\t\treturn pos\n\tif n <= 1:\n\t\treturn offs + pos\n\treturn findnth(s[pos + 1:], sub, n - 1, offs + pos + 1)\n\n# Percent to one decimal place\n\ndef PercentToOneDP(n, d):\n\tif not d:\n\t\treturn \"0.0\"\n\tx = (n * Decimal(100)) / d\n\treturn str(x.quantize(Decimal(\".1\"), rounding=ROUND_HALF_UP))\n\n# Helper for queries that must not fail\n\ndef QueryExec(query, stmt):\n\tret = query.exec_(stmt)\n\tif not ret:\n\t\traise Exception(\"Query failed: \" + query.lastError().text())\n\n# Background thread\n\nclass Thread(QThread):\n\n\tdone = Signal(object)\n\n\tdef __init__(self, task, param=None, parent=None):\n\t\tsuper(Thread, self).__init__(parent)\n\t\tself.task = task\n\t\tself.param = param\n\n\tdef run(self):\n\t\twhile True:\n\t\t\tif self.param is None:\n\t\t\t\tdone, result = self.task()\n\t\t\telse:\n\t\t\t\tdone, result = self.task(self.param)\n\t\t\tself.done.emit(result)\n\t\t\tif done:\n\t\t\t\tbreak\n\n# Tree data model\n\nclass TreeModel(QAbstractItemModel):\n\n\tdef __init__(self, glb, params, parent=None):\n\t\tsuper(TreeModel, self).__init__(parent)\n\t\tself.glb = glb\n\t\tself.params = params\n\t\tself.root = self.GetRoot()\n\t\tself.last_row_read = 0\n\n\tdef Item(self, parent):\n\t\tif parent.isValid():\n\t\t\treturn parent.internalPointer()\n\t\telse:\n\t\t\treturn self.root\n\n\tdef rowCount(self, parent):\n\t\tresult = self.Item(parent).childCount()\n\t\tif result < 0:\n\t\t\tresult = 0\n\t\t\tself.dataChanged.emit(parent, parent)\n\t\treturn result\n\n\tdef hasChildren(self, parent):\n\t\treturn self.Item(parent).hasChildren()\n\n\tdef headerData(self, section, orientation, role):\n\t\tif role == Qt.TextAlignmentRole:\n\t\t\treturn self.columnAlignment(section)\n\t\tif role != Qt.DisplayRole:\n\t\t\treturn None\n\t\tif orientation != Qt.Horizontal:\n\t\t\treturn None\n\t\treturn self.columnHeader(section)\n\n\tdef parent(self, child):\n\t\tchild_item = child.internalPointer()\n\t\tif child_item is self.root:\n\t\t\treturn QModelIndex()\n\t\tparent_item = child_item.getParentItem()\n\t\treturn self.createIndex(parent_item.getRow(), 0, parent_item)\n\n\tdef index(self, row, column, parent):\n\t\tchild_item = self.Item(parent).getChildItem(row)\n\t\treturn self.createIndex(row, column, child_item)\n\n\tdef DisplayData(self, item, index):\n\t\treturn item.getData(index.column())\n\n\tdef FetchIfNeeded(self, row):\n\t\tif row > self.last_row_read:\n\t\t\tself.last_row_read = row\n\t\t\tif row + 10 >= self.root.child_count:\n\t\t\t\tself.fetcher.Fetch(glb_chunk_sz)\n\n\tdef columnAlignment(self, column):\n\t\treturn Qt.AlignLeft\n\n\tdef columnFont(self, column):\n\t\treturn None\n\n\tdef data(self, index, role):\n\t\tif role == Qt.TextAlignmentRole:\n\t\t\treturn self.columnAlignment(index.column())\n\t\tif role == Qt.FontRole:\n\t\t\treturn self.columnFont(index.column())\n\t\tif role != Qt.DisplayRole:\n\t\t\treturn None\n\t\titem = index.internalPointer()\n\t\treturn self.DisplayData(item, index)\n\n# Table data model\n\nclass TableModel(QAbstractTableModel):\n\n\tdef __init__(self, parent=None):\n\t\tsuper(TableModel, self).__init__(parent)\n\t\tself.child_count = 0\n\t\tself.child_items = []\n\t\tself.last_row_read = 0\n\n\tdef Item(self, parent):\n\t\tif parent.isValid():\n\t\t\treturn parent.internalPointer()\n\t\telse:\n\t\t\treturn self\n\n\tdef rowCount(self, parent):\n\t\treturn self.child_count\n\n\tdef headerData(self, section, orientation, role):\n\t\tif role == Qt.TextAlignmentRole:\n\t\t\treturn self.columnAlignment(section)\n\t\tif role != Qt.DisplayRole:\n\t\t\treturn None\n\t\tif orientation != Qt.Horizontal:\n\t\t\treturn None\n\t\treturn self.columnHeader(section)\n\n\tdef index(self, row, column, parent):\n\t\treturn self.createIndex(row, column, self.child_items[row])\n\n\tdef DisplayData(self, item, index):\n\t\treturn item.getData(index.column())\n\n\tdef FetchIfNeeded(self, row):\n\t\tif row > self.last_row_read:\n\t\t\tself.last_row_read = row\n\t\t\tif row + 10 >= self.child_count:\n\t\t\t\tself.fetcher.Fetch(glb_chunk_sz)\n\n\tdef columnAlignment(self, column):\n\t\treturn Qt.AlignLeft\n\n\tdef columnFont(self, column):\n\t\treturn None\n\n\tdef data(self, index, role):\n\t\tif role == Qt.TextAlignmentRole:\n\t\t\treturn self.columnAlignment(index.column())\n\t\tif role == Qt.FontRole:\n\t\t\treturn self.columnFont(index.column())\n\t\tif role != Qt.DisplayRole:\n\t\t\treturn None\n\t\titem = index.internalPointer()\n\t\treturn self.DisplayData(item, index)\n\n# Model cache\n\nmodel_cache = weakref.WeakValueDictionary()\nmodel_cache_lock = threading.Lock()\n\ndef LookupCreateModel(model_name, create_fn):\n\tmodel_cache_lock.acquire()\n\ttry:\n\t\tmodel = model_cache[model_name]\n\texcept:\n\t\tmodel = None\n\tif model is None:\n\t\tmodel = create_fn()\n\t\tmodel_cache[model_name] = model\n\tmodel_cache_lock.release()\n\treturn model\n\ndef LookupModel(model_name):\n\tmodel_cache_lock.acquire()\n\ttry:\n\t\tmodel = model_cache[model_name]\n\texcept:\n\t\tmodel = None\n\tmodel_cache_lock.release()\n\treturn model\n\n# Find bar\n\nclass FindBar():\n\n\tdef __init__(self, parent, finder, is_reg_expr=False):\n\t\tself.finder = finder\n\t\tself.context = []\n\t\tself.last_value = None\n\t\tself.last_pattern = None\n\n\t\tlabel = QLabel(\"Find:\")\n\t\tlabel.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n\t\tself.textbox = QComboBox()\n\t\tself.textbox.setEditable(True)\n\t\tself.textbox.currentIndexChanged.connect(self.ValueChanged)\n\n\t\tself.progress = QProgressBar()\n\t\tself.progress.setRange(0, 0)\n\t\tself.progress.hide()\n\n\t\tif is_reg_expr:\n\t\t\tself.pattern = QCheckBox(\"Regular Expression\")\n\t\telse:\n\t\t\tself.pattern = QCheckBox(\"Pattern\")\n\t\tself.pattern.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n\t\tself.next_button = QToolButton()\n\t\tself.next_button.setIcon(parent.style().standardIcon(QStyle.SP_ArrowDown))\n\t\tself.next_button.released.connect(lambda: self.NextPrev(1))\n\n\t\tself.prev_button = QToolButton()\n\t\tself.prev_button.setIcon(parent.style().standardIcon(QStyle.SP_ArrowUp))\n\t\tself.prev_button.released.connect(lambda: self.NextPrev(-1))\n\n\t\tself.close_button = QToolButton()\n\t\tself.close_button.setIcon(parent.style().standardIcon(QStyle.SP_DockWidgetCloseButton))\n\t\tself.close_button.released.connect(self.Deactivate)\n\n\t\tself.hbox = QHBoxLayout()\n\t\tself.hbox.setContentsMargins(0, 0, 0, 0)\n\n\t\tself.hbox.addWidget(label)\n\t\tself.hbox.addWidget(self.textbox)\n\t\tself.hbox.addWidget(self.progress)\n\t\tself.hbox.addWidget(self.pattern)\n\t\tself.hbox.addWidget(self.next_button)\n\t\tself.hbox.addWidget(self.prev_button)\n\t\tself.hbox.addWidget(self.close_button)\n\n\t\tself.bar = QWidget()\n\t\tself.bar.setLayout(self.hbox)\n\t\tself.bar.hide()\n\n\tdef Widget(self):\n\t\treturn self.bar\n\n\tdef Activate(self):\n\t\tself.bar.show()\n\t\tself.textbox.lineEdit().selectAll()\n\t\tself.textbox.setFocus()\n\n\tdef Deactivate(self):\n\t\tself.bar.hide()\n\n\tdef Busy(self):\n\t\tself.textbox.setEnabled(False)\n\t\tself.pattern.hide()\n\t\tself.next_button.hide()\n\t\tself.prev_button.hide()\n\t\tself.progress.show()\n\n\tdef Idle(self):\n\t\tself.textbox.setEnabled(True)\n\t\tself.progress.hide()\n\t\tself.pattern.show()\n\t\tself.next_button.show()\n\t\tself.prev_button.show()\n\n\tdef Find(self, direction):\n\t\tvalue = self.textbox.currentText()\n\t\tpattern = self.pattern.isChecked()\n\t\tself.last_value = value\n\t\tself.last_pattern = pattern\n\t\tself.finder.Find(value, direction, pattern, self.context)\n\n\tdef ValueChanged(self):\n\t\tvalue = self.textbox.currentText()\n\t\tpattern = self.pattern.isChecked()\n\t\tindex = self.textbox.currentIndex()\n\t\tdata = self.textbox.itemData(index)\n\t\t# Store the pattern in the combo box to keep it with the text value\n\t\tif data == None:\n\t\t\tself.textbox.setItemData(index, pattern)\n\t\telse:\n\t\t\tself.pattern.setChecked(data)\n\t\tself.Find(0)\n\n\tdef NextPrev(self, direction):\n\t\tvalue = self.textbox.currentText()\n\t\tpattern = self.pattern.isChecked()\n\t\tif value != self.last_value:\n\t\t\tindex = self.textbox.findText(value)\n\t\t\t# Allow for a button press before the value has been added to the combo box\n\t\t\tif index < 0:\n\t\t\t\tindex = self.textbox.count()\n\t\t\t\tself.textbox.addItem(value, pattern)\n\t\t\t\tself.textbox.setCurrentIndex(index)\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tself.textbox.setItemData(index, pattern)\n\t\telif pattern != self.last_pattern:\n\t\t\t# Keep the pattern recorded in the combo box up to date\n\t\t\tindex = self.textbox.currentIndex()\n\t\t\tself.textbox.setItemData(index, pattern)\n\t\tself.Find(direction)\n\n\tdef NotFound(self):\n\t\tQMessageBox.information(self.bar, \"Find\", \"'\" + self.textbox.currentText() + \"' not found\")\n\n# Context-sensitive call graph data model item base\n\nclass CallGraphLevelItemBase(object):\n\n\tdef __init__(self, glb, params, row, parent_item):\n\t\tself.glb = glb\n\t\tself.params = params\n\t\tself.row = row\n\t\tself.parent_item = parent_item\n\t\tself.query_done = False\n\t\tself.child_count = 0\n\t\tself.child_items = []\n\t\tif parent_item:\n\t\t\tself.level = parent_item.level + 1\n\t\telse:\n\t\t\tself.level = 0\n\n\tdef getChildItem(self, row):\n\t\treturn self.child_items[row]\n\n\tdef getParentItem(self):\n\t\treturn self.parent_item\n\n\tdef getRow(self):\n\t\treturn self.row\n\n\tdef childCount(self):\n\t\tif not self.query_done:\n\t\t\tself.Select()\n\t\t\tif not self.child_count:\n\t\t\t\treturn -1\n\t\treturn self.child_count\n\n\tdef hasChildren(self):\n\t\tif not self.query_done:\n\t\t\treturn True\n\t\treturn self.child_count > 0\n\n\tdef getData(self, column):\n\t\treturn self.data[column]\n\n# Context-sensitive call graph data model level 2+ item base\n\nclass CallGraphLevelTwoPlusItemBase(CallGraphLevelItemBase):\n\n\tdef __init__(self, glb, params, row, comm_id, thread_id, call_path_id, time, insn_cnt, cyc_cnt, branch_count, parent_item):\n\t\tsuper(CallGraphLevelTwoPlusItemBase, self).__init__(glb, params, row, parent_item)\n\t\tself.comm_id = comm_id\n\t\tself.thread_id = thread_id\n\t\tself.call_path_id = call_path_id\n\t\tself.insn_cnt = insn_cnt\n\t\tself.cyc_cnt = cyc_cnt\n\t\tself.branch_count = branch_count\n\t\tself.time = time\n\n\tdef Select(self):\n\t\tself.query_done = True\n\t\tquery = QSqlQuery(self.glb.db)\n\t\tif self.params.have_ipc:\n\t\t\tipc_str = \", SUM(insn_count), SUM(cyc_count)\"\n\t\telse:\n\t\t\tipc_str = \"\"\n\t\tQueryExec(query, \"SELECT call_path_id, name, short_name, COUNT(calls.id), SUM(return_time - call_time)\" + ipc_str + \", SUM(branch_count)\"\n\t\t\t\t\t\" FROM calls\"\n\t\t\t\t\t\" INNER JOIN call_paths ON calls.call_path_id = call_paths.id\"\n\t\t\t\t\t\" INNER JOIN symbols ON call_paths.symbol_id = symbols.id\"\n\t\t\t\t\t\" INNER JOIN dsos ON symbols.dso_id = dsos.id\"\n\t\t\t\t\t\" WHERE parent_call_path_id = \" + str(self.call_path_id) +\n\t\t\t\t\t\" AND comm_id = \" + str(self.comm_id) +\n\t\t\t\t\t\" AND thread_id = \" + str(self.thread_id) +\n\t\t\t\t\t\" GROUP BY call_path_id, name, short_name\"\n\t\t\t\t\t\" ORDER BY call_path_id\")\n\t\twhile query.next():\n\t\t\tif self.params.have_ipc:\n\t\t\t\tinsn_cnt = int(query.value(5))\n\t\t\t\tcyc_cnt = int(query.value(6))\n\t\t\t\tbranch_count = int(query.value(7))\n\t\t\telse:\n\t\t\t\tinsn_cnt = 0\n\t\t\t\tcyc_cnt = 0\n\t\t\t\tbranch_count = int(query.value(5))\n\t\t\tchild_item = CallGraphLevelThreeItem(self.glb, self.params, self.child_count, self.comm_id, self.thread_id, query.value(0), query.value(1), query.value(2), query.value(3), int(query.value(4)), insn_cnt, cyc_cnt, branch_count, self)\n\t\t\tself.child_items.append(child_item)\n\t\t\tself.child_count += 1\n\n# Context-sensitive call graph data model level three item\n\nclass CallGraphLevelThreeItem(CallGraphLevelTwoPlusItemBase):\n\n\tdef __init__(self, glb, params, row, comm_id, thread_id, call_path_id, name, dso, count, time, insn_cnt, cyc_cnt, branch_count, parent_item):\n\t\tsuper(CallGraphLevelThreeItem, self).__init__(glb, params, row, comm_id, thread_id, call_path_id, time, insn_cnt, cyc_cnt, branch_count, parent_item)\n\t\tdso = dsoname(dso)\n\t\tif self.params.have_ipc:\n\t\t\tinsn_pcnt = PercentToOneDP(insn_cnt, parent_item.insn_cnt)\n\t\t\tcyc_pcnt = PercentToOneDP(cyc_cnt, parent_item.cyc_cnt)\n\t\t\tbr_pcnt = PercentToOneDP(branch_count, parent_item.branch_count)\n\t\t\tipc = CalcIPC(cyc_cnt, insn_cnt)\n\t\t\tself.data = [ name, dso, str(count), str(time), PercentToOneDP(time, parent_item.time), str(insn_cnt), insn_pcnt, str(cyc_cnt), cyc_pcnt, ipc, str(branch_count), br_pcnt ]\n\t\telse:\n\t\t\tself.data = [ name, dso, str(count), str(time), PercentToOneDP(time, parent_item.time), str(branch_count), PercentToOneDP(branch_count, parent_item.branch_count) ]\n\t\tself.dbid = call_path_id\n\n# Context-sensitive call graph data model level two item\n\nclass CallGraphLevelTwoItem(CallGraphLevelTwoPlusItemBase):\n\n\tdef __init__(self, glb, params, row, comm_id, thread_id, pid, tid, parent_item):\n\t\tsuper(CallGraphLevelTwoItem, self).__init__(glb, params, row, comm_id, thread_id, 1, 0, 0, 0, 0, parent_item)\n\t\tif self.params.have_ipc:\n\t\t\tself.data = [str(pid) + \":\" + str(tid), \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n\t\telse:\n\t\t\tself.data = [str(pid) + \":\" + str(tid), \"\", \"\", \"\", \"\", \"\", \"\"]\n\t\tself.dbid = thread_id\n\n\tdef Select(self):\n\t\tsuper(CallGraphLevelTwoItem, self).Select()\n\t\tfor child_item in self.child_items:\n\t\t\tself.time += child_item.time\n\t\t\tself.insn_cnt += child_item.insn_cnt\n\t\t\tself.cyc_cnt += child_item.cyc_cnt\n\t\t\tself.branch_count += child_item.branch_count\n\t\tfor child_item in self.child_items:\n\t\t\tchild_item.data[4] = PercentToOneDP(child_item.time, self.time)\n\t\t\tif self.params.have_ipc:\n\t\t\t\tchild_item.data[6] = PercentToOneDP(child_item.insn_cnt, self.insn_cnt)\n\t\t\t\tchild_item.data[8] = PercentToOneDP(child_item.cyc_cnt, self.cyc_cnt)\n\t\t\t\tchild_item.data[11] = PercentToOneDP(child_item.branch_count, self.branch_count)\n\t\t\telse:\n\t\t\t\tchild_item.data[6] = PercentToOneDP(child_item.branch_count, self.branch_count)\n\n# Context-sensitive call graph data model level one item\n\nclass CallGraphLevelOneItem(CallGraphLevelItemBase):\n\n\tdef __init__(self, glb, params, row, comm_id, comm, parent_item):\n\t\tsuper(CallGraphLevelOneItem, self).__init__(glb, params, row, parent_item)\n\t\tif self.params.have_ipc:\n\t\t\tself.data = [comm, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n\t\telse:\n\t\t\tself.data = [comm, \"\", \"\", \"\", \"\", \"\", \"\"]\n\t\tself.dbid = comm_id\n\n\tdef Select(self):\n\t\tself.query_done = True\n\t\tquery = QSqlQuery(self.glb.db)\n\t\tQueryExec(query, \"SELECT thread_id, pid, tid\"\n\t\t\t\t\t\" FROM comm_threads\"\n\t\t\t\t\t\" INNER JOIN threads ON thread_id = threads.id\"\n\t\t\t\t\t\" WHERE comm_id = \" + str(self.dbid))\n\t\twhile query.next():\n\t\t\tchild_item = CallGraphLevelTwoItem(self.glb, self.params, self.child_count, self.dbid, query.value(0), query.value(1), query.value(2), self)\n\t\t\tself.child_items.append(child_item)\n\t\t\tself.child_count += 1\n\n# Context-sensitive call graph data model root item\n\nclass CallGraphRootItem(CallGraphLevelItemBase):\n\n\tdef __init__(self, glb, params):\n\t\tsuper(CallGraphRootItem, self).__init__(glb, params, 0, None)\n\t\tself.dbid = 0\n\t\tself.query_done = True\n\t\tif_has_calls = \"\"\n\t\tif IsSelectable(glb.db, \"comms\", columns = \"has_calls\"):\n\t\t\tif_has_calls = \" WHERE has_calls = \" + glb.dbref.TRUE\n\t\tquery = QSqlQuery(glb.db)\n\t\tQueryExec(query, \"SELECT id, comm FROM comms\" + if_has_calls)\n\t\twhile query.next():\n\t\t\tif not query.value(0):\n\t\t\t\tcontinue\n\t\t\tchild_item = CallGraphLevelOneItem(glb, params, self.child_count, query.value(0), query.value(1), self)\n\t\t\tself.child_items.append(child_item)\n\t\t\tself.child_count += 1\n\n# Call graph model parameters\n\nclass CallGraphModelParams():\n\n\tdef __init__(self, glb, parent=None):\n\t\tself.have_ipc = IsSelectable(glb.db, \"calls\", columns = \"insn_count, cyc_count\")\n\n# Context-sensitive call graph data model base\n\nclass CallGraphModelBase(TreeModel):\n\n\tdef __init__(self, glb, parent=None):\n\t\tsuper(CallGraphModelBase, self).__init__(glb, CallGraphModelParams(glb), parent)\n\n\tdef FindSelect(self, value, pattern, query):\n\t\tif pattern:\n\t\t\t# postgresql and sqlite pattern patching differences:\n\t\t\t#   postgresql LIKE is case sensitive but sqlite LIKE is not\n\t\t\t#   postgresql LIKE allows % and _ to be escaped with \\ but sqlite LIKE does not\n\t\t\t#   postgresql supports ILIKE which is case insensitive\n\t\t\t#   sqlite supports GLOB (text only) which uses * and ? and is case sensitive\n\t\t\tif not self.glb.dbref.is_sqlite3:\n\t\t\t\t# Escape % and _\n\t\t\t\ts = value.replace(\"%\", \"\\%\")\n\t\t\t\ts = s.replace(\"_\", \"\\_\")\n\t\t\t\t# Translate * and ? into SQL LIKE pattern characters % and _\n\t\t\t\ttrans = string.maketrans(\"*?\", \"%_\")\n\t\t\t\tmatch = \" LIKE '\" + str(s).translate(trans) + \"'\"\n\t\t\telse:\n\t\t\t\tmatch = \" GLOB '\" + str(value) + \"'\"\n\t\telse:\n\t\t\tmatch = \" = '\" + str(value) + \"'\"\n\t\tself.DoFindSelect(query, match)\n\n\tdef Found(self, query, found):\n\t\tif found:\n\t\t\treturn self.FindPath(query)\n\t\treturn []\n\n\tdef FindValue(self, value, pattern, query, last_value, last_pattern):\n\t\tif last_value == value and pattern == last_pattern:\n\t\t\tfound = query.first()\n\t\telse:\n\t\t\tself.FindSelect(value, pattern, query)\n\t\t\tfound = query.next()\n\t\treturn self.Found(query, found)\n\n\tdef FindNext(self, query):\n\t\tfound = query.next()\n\t\tif not found:\n\t\t\tfound = query.first()\n\t\treturn self.Found(query, found)\n\n\tdef FindPrev(self, query):\n\t\tfound = query.previous()\n\t\tif not found:\n\t\t\tfound = query.last()\n\t\treturn self.Found(query, found)\n\n\tdef FindThread(self, c):\n\t\tif c.direction == 0 or c.value != c.last_value or c.pattern != c.last_pattern:\n\t\t\tids = self.FindValue(c.value, c.pattern, c.query, c.last_value, c.last_pattern)\n\t\telif c.direction > 0:\n\t\t\tids = self.FindNext(c.query)\n\t\telse:\n\t\t\tids = self.FindPrev(c.query)\n\t\treturn (True, ids)\n\n\tdef Find(self, value, direction, pattern, context, callback):\n\t\tclass Context():\n\t\t\tdef __init__(self, *x):\n\t\t\t\tself.value, self.direction, self.pattern, self.query, self.last_value, self.last_pattern = x\n\t\t\tdef Update(self, *x):\n\t\t\t\tself.value, self.direction, self.pattern, self.last_value, self.last_pattern = x + (self.value, self.pattern)\n\t\tif len(context):\n\t\t\tcontext[0].Update(value, direction, pattern)\n\t\telse:\n\t\t\tcontext.append(Context(value, direction, pattern, QSqlQuery(self.glb.db), None, None))\n\t\t# Use a thread so the UI is not blocked during the SELECT\n\t\tthread = Thread(self.FindThread, context[0])\n\t\tthread.done.connect(lambda ids, t=thread, c=callback: self.FindDone(t, c, ids), Qt.QueuedConnection)\n\t\tthread.start()\n\n\tdef FindDone(self, thread, callback, ids):\n\t\tcallback(ids)\n\n# Context-sensitive call graph data model\n\nclass CallGraphModel(CallGraphModelBase):\n\n\tdef __init__(self, glb, parent=None):\n\t\tsuper(CallGraphModel, self).__init__(glb, parent)\n\n\tdef GetRoot(self):\n\t\treturn CallGraphRootItem(self.glb, self.params)\n\n\tdef columnCount(self, parent=None):\n\t\tif self.params.have_ipc:\n\t\t\treturn 12\n\t\telse:\n\t\t\treturn 7\n\n\tdef columnHeader(self, column):\n\t\tif self.params.have_ipc:\n\t\t\theaders = [\"Call Path\", \"Object\", \"Count \", \"Time (ns) \", \"Time (%) \", \"Insn Cnt\", \"Insn Cnt (%)\", \"Cyc Cnt\", \"Cyc Cnt (%)\", \"IPC\", \"Branch Count \", \"Branch Count (%) \"]\n\t\telse:\n\t\t\theaders = [\"Call Path\", \"Object\", \"Count \", \"Time (ns) \", \"Time (%) \", \"Branch Count \", \"Branch Count (%) \"]\n\t\treturn headers[column]\n\n\tdef columnAlignment(self, column):\n\t\tif self.params.have_ipc:\n\t\t\talignment = [ Qt.AlignLeft, Qt.AlignLeft, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight ]\n\t\telse:\n\t\t\talignment = [ Qt.AlignLeft, Qt.AlignLeft, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight ]\n\t\treturn alignment[column]\n\n\tdef DoFindSelect(self, query, match):\n\t\tQueryExec(query, \"SELECT call_path_id, comm_id, thread_id\"\n\t\t\t\t\t\t\" FROM calls\"\n\t\t\t\t\t\t\" INNER JOIN call_paths ON calls.call_path_id = call_paths.id\"\n\t\t\t\t\t\t\" INNER JOIN symbols ON call_paths.symbol_id = symbols.id\"\n\t\t\t\t\t\t\" WHERE calls.id <> 0\"\n\t\t\t\t\t\t\" AND symbols.name\" + match +\n\t\t\t\t\t\t\" GROUP BY comm_id, thread_id, call_path_id\"\n\t\t\t\t\t\t\" ORDER BY comm_id, thread_id, call_path_id\")\n\n\tdef FindPath(self, query):\n\t\t# Turn the query result into a list of ids that the tree view can walk\n\t\t# to open the tree at the right place.\n\t\tids = []\n\t\tparent_id = query.value(0)\n\t\twhile parent_id:\n\t\t\tids.insert(0, parent_id)\n\t\t\tq2 = QSqlQuery(self.glb.db)\n\t\t\tQueryExec(q2, \"SELECT parent_id\"\n\t\t\t\t\t\" FROM call_paths\"\n\t\t\t\t\t\" WHERE id = \" + str(parent_id))\n\t\t\tif not q2.next():\n\t\t\t\tbreak\n\t\t\tparent_id = q2.value(0)\n\t\t# The call path root is not used\n\t\tif ids[0] == 1:\n\t\t\tdel ids[0]\n\t\tids.insert(0, query.value(2))\n\t\tids.insert(0, query.value(1))\n\t\treturn ids\n\n# Call tree data model level 2+ item base\n\nclass CallTreeLevelTwoPlusItemBase(CallGraphLevelItemBase):\n\n\tdef __init__(self, glb, params, row, comm_id, thread_id, calls_id, call_time, time, insn_cnt, cyc_cnt, branch_count, parent_item):\n\t\tsuper(CallTreeLevelTwoPlusItemBase, self).__init__(glb, params, row, parent_item)\n\t\tself.comm_id = comm_id\n\t\tself.thread_id = thread_id\n\t\tself.calls_id = calls_id\n\t\tself.call_time = call_time\n\t\tself.time = time\n\t\tself.insn_cnt = insn_cnt\n\t\tself.cyc_cnt = cyc_cnt\n\t\tself.branch_count = branch_count\n\n\tdef Select(self):\n\t\tself.query_done = True\n\t\tif self.calls_id == 0:\n\t\t\tcomm_thread = \" AND comm_id = \" + str(self.comm_id) + \" AND thread_id = \" + str(self.thread_id)\n\t\telse:\n\t\t\tcomm_thread = \"\"\n\t\tif self.params.have_ipc:\n\t\t\tipc_str = \", insn_count, cyc_count\"\n\t\telse:\n\t\t\tipc_str = \"\"\n\t\tquery = QSqlQuery(self.glb.db)\n\t\tQueryExec(query, \"SELECT calls.id, name, short_name, call_time, return_time - call_time\" + ipc_str + \", branch_count\"\n\t\t\t\t\t\" FROM calls\"\n\t\t\t\t\t\" INNER JOIN call_paths ON calls.call_path_id = call_paths.id\"\n\t\t\t\t\t\" INNER JOIN symbols ON call_paths.symbol_id = symbols.id\"\n\t\t\t\t\t\" INNER JOIN dsos ON symbols.dso_id = dsos.id\"\n\t\t\t\t\t\" WHERE calls.parent_id = \" + str(self.calls_id) + comm_thread +\n\t\t\t\t\t\" ORDER BY call_time, calls.id\")\n\t\twhile query.next():\n\t\t\tif self.params.have_ipc:\n\t\t\t\tinsn_cnt = int(query.value(5))\n\t\t\t\tcyc_cnt = int(query.value(6))\n\t\t\t\tbranch_count = int(query.value(7))\n\t\t\telse:\n\t\t\t\tinsn_cnt = 0\n\t\t\t\tcyc_cnt = 0\n\t\t\t\tbranch_count = int(query.value(5))\n\t\t\tchild_item = CallTreeLevelThreeItem(self.glb, self.params, self.child_count, self.comm_id, self.thread_id, query.value(0), query.value(1), query.value(2), query.value(3), int(query.value(4)), insn_cnt, cyc_cnt, branch_count, self)\n\t\t\tself.child_items.append(child_item)\n\t\t\tself.child_count += 1\n\n# Call tree data model level three item\n\nclass CallTreeLevelThreeItem(CallTreeLevelTwoPlusItemBase):\n\n\tdef __init__(self, glb, params, row, comm_id, thread_id, calls_id, name, dso, call_time, time, insn_cnt, cyc_cnt, branch_count, parent_item):\n\t\tsuper(CallTreeLevelThreeItem, self).__init__(glb, params, row, comm_id, thread_id, calls_id, call_time, time, insn_cnt, cyc_cnt, branch_count, parent_item)\n\t\tdso = dsoname(dso)\n\t\tif self.params.have_ipc:\n\t\t\tinsn_pcnt = PercentToOneDP(insn_cnt, parent_item.insn_cnt)\n\t\t\tcyc_pcnt = PercentToOneDP(cyc_cnt, parent_item.cyc_cnt)\n\t\t\tbr_pcnt = PercentToOneDP(branch_count, parent_item.branch_count)\n\t\t\tipc = CalcIPC(cyc_cnt, insn_cnt)\n\t\t\tself.data = [ name, dso, str(call_time), str(time), PercentToOneDP(time, parent_item.time), str(insn_cnt), insn_pcnt, str(cyc_cnt), cyc_pcnt, ipc, str(branch_count), br_pcnt ]\n\t\telse:\n\t\t\tself.data = [ name, dso, str(call_time), str(time), PercentToOneDP(time, parent_item.time), str(branch_count), PercentToOneDP(branch_count, parent_item.branch_count) ]\n\t\tself.dbid = calls_id\n\n# Call tree data model level two item\n\nclass CallTreeLevelTwoItem(CallTreeLevelTwoPlusItemBase):\n\n\tdef __init__(self, glb, params, row, comm_id, thread_id, pid, tid, parent_item):\n\t\tsuper(CallTreeLevelTwoItem, self).__init__(glb, params, row, comm_id, thread_id, 0, 0, 0, 0, 0, 0, parent_item)\n\t\tif self.params.have_ipc:\n\t\t\tself.data = [str(pid) + \":\" + str(tid), \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n\t\telse:\n\t\t\tself.data = [str(pid) + \":\" + str(tid), \"\", \"\", \"\", \"\", \"\", \"\"]\n\t\tself.dbid = thread_id\n\n\tdef Select(self):\n\t\tsuper(CallTreeLevelTwoItem, self).Select()\n\t\tfor child_item in self.child_items:\n\t\t\tself.time += child_item.time\n\t\t\tself.insn_cnt += child_item.insn_cnt\n\t\t\tself.cyc_cnt += child_item.cyc_cnt\n\t\t\tself.branch_count += child_item.branch_count\n\t\tfor child_item in self.child_items:\n\t\t\tchild_item.data[4] = PercentToOneDP(child_item.time, self.time)\n\t\t\tif self.params.have_ipc:\n\t\t\t\tchild_item.data[6] = PercentToOneDP(child_item.insn_cnt, self.insn_cnt)\n\t\t\t\tchild_item.data[8] = PercentToOneDP(child_item.cyc_cnt, self.cyc_cnt)\n\t\t\t\tchild_item.data[11] = PercentToOneDP(child_item.branch_count, self.branch_count)\n\t\t\telse:\n\t\t\t\tchild_item.data[6] = PercentToOneDP(child_item.branch_count, self.branch_count)\n\n# Call tree data model level one item\n\nclass CallTreeLevelOneItem(CallGraphLevelItemBase):\n\n\tdef __init__(self, glb, params, row, comm_id, comm, parent_item):\n\t\tsuper(CallTreeLevelOneItem, self).__init__(glb, params, row, parent_item)\n\t\tif self.params.have_ipc:\n\t\t\tself.data = [comm, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n\t\telse:\n\t\t\tself.data = [comm, \"\", \"\", \"\", \"\", \"\", \"\"]\n\t\tself.dbid = comm_id\n\n\tdef Select(self):\n\t\tself.query_done = True\n\t\tquery = QSqlQuery(self.glb.db)\n\t\tQueryExec(query, \"SELECT thread_id, pid, tid\"\n\t\t\t\t\t\" FROM comm_threads\"\n\t\t\t\t\t\" INNER JOIN threads ON thread_id = threads.id\"\n\t\t\t\t\t\" WHERE comm_id = \" + str(self.dbid))\n\t\twhile query.next():\n\t\t\tchild_item = CallTreeLevelTwoItem(self.glb, self.params, self.child_count, self.dbid, query.value(0), query.value(1), query.value(2), self)\n\t\t\tself.child_items.append(child_item)\n\t\t\tself.child_count += 1\n\n# Call tree data model root item\n\nclass CallTreeRootItem(CallGraphLevelItemBase):\n\n\tdef __init__(self, glb, params):\n\t\tsuper(CallTreeRootItem, self).__init__(glb, params, 0, None)\n\t\tself.dbid = 0\n\t\tself.query_done = True\n\t\tif_has_calls = \"\"\n\t\tif IsSelectable(glb.db, \"comms\", columns = \"has_calls\"):\n\t\t\tif_has_calls = \" WHERE has_calls = \" + glb.dbref.TRUE\n\t\tquery = QSqlQuery(glb.db)\n\t\tQueryExec(query, \"SELECT id, comm FROM comms\" + if_has_calls)\n\t\twhile query.next():\n\t\t\tif not query.value(0):\n\t\t\t\tcontinue\n\t\t\tchild_item = CallTreeLevelOneItem(glb, params, self.child_count, query.value(0), query.value(1), self)\n\t\t\tself.child_items.append(child_item)\n\t\t\tself.child_count += 1\n\n# Call Tree data model\n\nclass CallTreeModel(CallGraphModelBase):\n\n\tdef __init__(self, glb, parent=None):\n\t\tsuper(CallTreeModel, self).__init__(glb, parent)\n\n\tdef GetRoot(self):\n\t\treturn CallTreeRootItem(self.glb, self.params)\n\n\tdef columnCount(self, parent=None):\n\t\tif self.params.have_ipc:\n\t\t\treturn 12\n\t\telse:\n\t\t\treturn 7\n\n\tdef columnHeader(self, column):\n\t\tif self.params.have_ipc:\n\t\t\theaders = [\"Call Path\", \"Object\", \"Call Time\", \"Time (ns) \", \"Time (%) \", \"Insn Cnt\", \"Insn Cnt (%)\", \"Cyc Cnt\", \"Cyc Cnt (%)\", \"IPC\", \"Branch Count \", \"Branch Count (%) \"]\n\t\telse:\n\t\t\theaders = [\"Call Path\", \"Object\", \"Call Time\", \"Time (ns) \", \"Time (%) \", \"Branch Count \", \"Branch Count (%) \"]\n\t\treturn headers[column]\n\n\tdef columnAlignment(self, column):\n\t\tif self.params.have_ipc:\n\t\t\talignment = [ Qt.AlignLeft, Qt.AlignLeft, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight ]\n\t\telse:\n\t\t\talignment = [ Qt.AlignLeft, Qt.AlignLeft, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight, Qt.AlignRight ]\n\t\treturn alignment[column]\n\n\tdef DoFindSelect(self, query, match):\n\t\tQueryExec(query, \"SELECT calls.id, comm_id, thread_id\"\n\t\t\t\t\t\t\" FROM calls\"\n\t\t\t\t\t\t\" INNER JOIN call_paths ON calls.call_path_id = call_paths.id\"\n\t\t\t\t\t\t\" INNER JOIN symbols ON call_paths.symbol_id = symbols.id\"\n\t\t\t\t\t\t\" WHERE calls.id <> 0\"\n\t\t\t\t\t\t\" AND symbols.name\" + match +\n\t\t\t\t\t\t\" ORDER BY comm_id, thread_id, call_time, calls.id\")\n\n\tdef FindPath(self, query):\n\t\t# Turn the query result into a list of ids that the tree view can walk\n\t\t# to open the tree at the right place.\n\t\tids = []\n\t\tparent_id = query.value(0)\n\t\twhile parent_id:\n\t\t\tids.insert(0, parent_id)\n\t\t\tq2 = QSqlQuery(self.glb.db)\n\t\t\tQueryExec(q2, \"SELECT parent_id\"\n\t\t\t\t\t\" FROM calls\"\n\t\t\t\t\t\" WHERE id = \" + str(parent_id))\n\t\t\tif not q2.next():\n\t\t\t\tbreak\n\t\t\tparent_id = q2.value(0)\n\t\tids.insert(0, query.value(2))\n\t\tids.insert(0, query.value(1))\n\t\treturn ids\n\n# Vertical layout\n\nclass HBoxLayout(QHBoxLayout):\n\n\tdef __init__(self, *children):\n\t\tsuper(HBoxLayout, self).__init__()\n\n\t\tself.layout().setContentsMargins(0, 0, 0, 0)\n\t\tfor child in children:\n\t\t\tif child.isWidgetType():\n\t\t\t\tself.layout().addWidget(child)\n\t\t\telse:\n\t\t\t\tself.layout().addLayout(child)\n\n# Horizontal layout\n\nclass VBoxLayout(QVBoxLayout):\n\n\tdef __init__(self, *children):\n\t\tsuper(VBoxLayout, self).__init__()\n\n\t\tself.layout().setContentsMargins(0, 0, 0, 0)\n\t\tfor child in children:\n\t\t\tif child.isWidgetType():\n\t\t\t\tself.layout().addWidget(child)\n\t\t\telse:\n\t\t\t\tself.layout().addLayout(child)\n\n# Vertical layout widget\n\nclass VBox():\n\n\tdef __init__(self, *children):\n\t\tself.vbox = QWidget()\n\t\tself.vbox.setLayout(VBoxLayout(*children))\n\n\tdef Widget(self):\n\t\treturn self.vbox\n\n# Tree window base\n\nclass TreeWindowBase(QMdiSubWindow):\n\n\tdef __init__(self, parent=None):\n\t\tsuper(TreeWindowBase, self).__init__(parent)\n\n\t\tself.model = None\n\t\tself.find_bar = None\n\n\t\tself.view = QTreeView()\n\t\tself.view.setSelectionMode(QAbstractItemView.ContiguousSelection)\n\t\tself.view.CopyCellsToClipboard = CopyTreeCellsToClipboard\n\n\t\tself.context_menu = TreeContextMenu(self.view)\n\n\tdef DisplayFound(self, ids):\n\t\tif not len(ids):\n\t\t\treturn False\n\t\tparent = QModelIndex()\n\t\tfor dbid in ids:\n\t\t\tfound = False\n\t\t\tn = self.model.rowCount(parent)\n\t\t\tfor row in xrange(n):\n\t\t\t\tchild = self.model.index(row, 0, parent)\n\t\t\t\tif child.internalPointer().dbid == dbid:\n\t\t\t\t\tfound = True\n\t\t\t\t\tself.view.setExpanded(parent, True)\n\t\t\t\t\tself.view.setCurrentIndex(child)\n\t\t\t\t\tparent = child\n\t\t\t\t\tbreak\n\t\t\tif not found:\n\t\t\t\tbreak\n\t\treturn found\n\n\tdef Find(self, value, direction, pattern, context):\n\t\tself.view.setFocus()\n\t\tself.find_bar.Busy()\n\t\tself.model.Find(value, direction, pattern, context, self.FindDone)\n\n\tdef FindDone(self, ids):\n\t\tfound = True\n\t\tif not self.DisplayFound(ids):\n\t\t\tfound = False\n\t\tself.find_bar.Idle()\n\t\tif not found:\n\t\t\tself.find_bar.NotFound()\n\n\n# Context-sensitive call graph window\n\nclass CallGraphWindow(TreeWindowBase):\n\n\tdef __init__(self, glb, parent=None):\n\t\tsuper(CallGraphWindow, self).__init__(parent)\n\n\t\tself.model = LookupCreateModel(\"Context-Sensitive Call Graph\", lambda x=glb: CallGraphModel(x))\n\n\t\tself.view.setModel(self.model)\n\n\t\tfor c, w in ((0, 250), (1, 100), (2, 60), (3, 70), (4, 70), (5, 100)):\n\t\t\tself.view.setColumnWidth(c, w)\n\n\t\tself.find_bar = FindBar(self, self)\n\n\t\tself.vbox = VBox(self.view, self.find_bar.Widget())\n\n\t\tself.setWidget(self.vbox.Widget())\n\n\t\tAddSubWindow(glb.mainwindow.mdi_area, self, \"Context-Sensitive Call Graph\")\n\n# Call tree window\n\nclass CallTreeWindow(TreeWindowBase):\n\n\tdef __init__(self, glb, parent=None, thread_at_time=None):\n\t\tsuper(CallTreeWindow, self).__init__(parent)\n\n\t\tself.model = LookupCreateModel(\"Call Tree\", lambda x=glb: CallTreeModel(x))\n\n\t\tself.view.setModel(self.model)\n\n\t\tfor c, w in ((0, 230), (1, 100), (2, 100), (3, 70), (4, 70), (5, 100)):\n\t\t\tself.view.setColumnWidth(c, w)\n\n\t\tself.find_bar = FindBar(self, self)\n\n\t\tself.vbox = VBox(self.view, self.find_bar.Widget())\n\n\t\tself.setWidget(self.vbox.Widget())\n\n\t\tAddSubWindow(glb.mainwindow.mdi_area, self, \"Call Tree\")\n\n\t\tif thread_at_time:\n\t\t\tself.DisplayThreadAtTime(*thread_at_time)\n\n\tdef DisplayThreadAtTime(self, comm_id, thread_id, time):\n\t\tparent = QModelIndex()\n\t\tfor dbid in (comm_id, thread_id):\n\t\t\tfound = False\n\t\t\tn = self.model.rowCount(parent)\n\t\t\tfor row in xrange(n):\n\t\t\t\tchild = self.model.index(row, 0, parent)\n\t\t\t\tif child.internalPointer().dbid == dbid:\n\t\t\t\t\tfound = True\n\t\t\t\t\tself.view.setExpanded(parent, True)\n\t\t\t\t\tself.view.setCurrentIndex(child)\n\t\t\t\t\tparent = child\n\t\t\t\t\tbreak\n\t\t\tif not found:\n\t\t\t\treturn\n\t\tfound = False\n\t\twhile True:\n\t\t\tn = self.model.rowCount(parent)\n\t\t\tif not n:\n\t\t\t\treturn\n\t\t\tlast_child = None\n\t\t\tfor row in xrange(n):\n\t\t\t\tself.view.setExpanded(parent, True)\n\t\t\t\tchild = self.model.index(row, 0, parent)\n\t\t\t\tchild_call_time = child.internalPointer().call_time\n\t\t\t\tif child_call_time < time:\n\t\t\t\t\tlast_child = child\n\t\t\t\telif child_call_time == time:\n\t\t\t\t\tself.view.setCurrentIndex(child)\n\t\t\t\t\treturn\n\t\t\t\telif child_call_time > time:\n\t\t\t\t\tbreak\n\t\t\tif not last_child:\n\t\t\t\tif not found:\n\t\t\t\t\tchild = self.model.index(0, 0, parent)\n\t\t\t\t\tself.view.setExpanded(parent, True)\n\t\t\t\t\tself.view.setCurrentIndex(child)\n\t\t\t\treturn\n\t\t\tfound = True\n\t\t\tself.view.setExpanded(parent, True)\n\t\t\tself.view.setCurrentIndex(last_child)\n\t\t\tparent = last_child\n\n# ExecComm() gets the comm_id of the command string that was set when the process exec'd i.e. the program name\n\ndef ExecComm(db, thread_id, time):\n\tquery = QSqlQuery(db)\n\tQueryExec(query, \"SELECT comm_threads.comm_id, comms.c_time, comms.exec_flag\"\n\t\t\t\t\" FROM comm_threads\"\n\t\t\t\t\" INNER JOIN comms ON comms.id = comm_threads.comm_id\"\n\t\t\t\t\" WHERE comm_threads.thread_id = \" + str(thread_id) +\n\t\t\t\t\" ORDER BY comms.c_time, comms.id\")\n\tfirst = None\n\tlast = None\n\twhile query.next():\n\t\tif first is None:\n\t\t\tfirst = query.value(0)\n\t\tif query.value(2) and Decimal(query.value(1)) <= Decimal(time):\n\t\t\tlast = query.value(0)\n\tif not(last is None):\n\t\treturn last\n\treturn first\n\n# Container for (x, y) data\n\nclass XY():\n\tdef __init__(self, x=0, y=0):\n\t\tself.x = x\n\t\tself.y = y\n\n\tdef __str__(self):\n\t\treturn \"XY({}, {})\".format(str(self.x), str(self.y))\n\n# Container for sub-range data\n\nclass Subrange():\n\tdef __init__(self, lo=0, hi=0):\n\t\tself.lo = lo\n\t\tself.hi = hi\n\n\tdef __str__(self):\n\t\treturn \"Subrange({}, {})\".format(str(self.lo), str(self.hi))\n\n# Graph data region base class\n\nclass GraphDataRegion(object):\n\n\tdef __init__(self, key, title = \"\", ordinal = \"\"):\n\t\tself.key = key\n\t\tself.title = title\n\t\tself.ordinal = ordinal\n\n# Function to sort GraphDataRegion\n\ndef GraphDataRegionOrdinal(data_region):\n\treturn data_region.ordinal\n\n# Attributes for a graph region\n\nclass GraphRegionAttribute():\n\n\tdef __init__(self, colour):\n\t\tself.colour = colour\n\n# Switch graph data region represents a task\n\nclass SwitchGraphDataRegion(GraphDataRegion):\n\n\tdef __init__(self, key, exec_comm_id, pid, tid, comm, thread_id, comm_id):\n\t\tsuper(SwitchGraphDataRegion, self).__init__(key)\n\n\t\tself.title = str(pid) + \" / \" + str(tid) + \" \" + comm\n\t\t# Order graph legend within exec comm by pid / tid / time\n\t\tself.ordinal = str(pid).rjust(16) + str(exec_comm_id).rjust(8) + str(tid).rjust(16)\n\t\tself.exec_comm_id = exec_comm_id\n\t\tself.pid = pid\n\t\tself.tid = tid\n\t\tself.comm = comm\n\t\tself.thread_id = thread_id\n\t\tself.comm_id = comm_id\n\n# Graph data point\n\nclass GraphDataPoint():\n\n\tdef __init__(self, data, index, x, y, altx=None, alty=None, hregion=None, vregion=None):\n\t\tself.data = data\n\t\tself.index = index\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.altx = altx\n\t\tself.alty = alty\n\t\tself.hregion = hregion\n\t\tself.vregion = vregion\n\n# Graph data (single graph) base class\n\nclass GraphData(object):\n\n\tdef __init__(self, collection, xbase=Decimal(0), ybase=Decimal(0)):\n\t\tself.collection = collection\n\t\tself.points = []\n\t\tself.xbase = xbase\n\t\tself.ybase = ybase\n\t\tself.title = \"\"\n\n\tdef AddPoint(self, x, y, altx=None, alty=None, hregion=None, vregion=None):\n\t\tindex = len(self.points)\n\n\t\tx = float(Decimal(x) - self.xbase)\n\t\ty = float(Decimal(y) - self.ybase)\n\n\t\tself.points.append(GraphDataPoint(self, index, x, y, altx, alty, hregion, vregion))\n\n\tdef XToData(self, x):\n\t\treturn Decimal(x) + self.xbase\n\n\tdef YToData(self, y):\n\t\treturn Decimal(y) + self.ybase\n\n# Switch graph data (for one CPU)\n\nclass SwitchGraphData(GraphData):\n\n\tdef __init__(self, db, collection, cpu, xbase):\n\t\tsuper(SwitchGraphData, self).__init__(collection, xbase)\n\n\t\tself.cpu = cpu\n\t\tself.title = \"CPU \" + str(cpu)\n\t\tself.SelectSwitches(db)\n\n\tdef SelectComms(self, db, thread_id, last_comm_id, start_time, end_time):\n\t\tquery = QSqlQuery(db)\n\t\tQueryExec(query, \"SELECT id, c_time\"\n\t\t\t\t\t\" FROM comms\"\n\t\t\t\t\t\" WHERE c_thread_id = \" + str(thread_id) +\n\t\t\t\t\t\"   AND exec_flag = \" + self.collection.glb.dbref.TRUE +\n\t\t\t\t\t\"   AND c_time >= \" + str(start_time) +\n\t\t\t\t\t\"   AND c_time <= \" + str(end_time) +\n\t\t\t\t\t\" ORDER BY c_time, id\")\n\t\twhile query.next():\n\t\t\tcomm_id = query.value(0)\n\t\t\tif comm_id == last_comm_id:\n\t\t\t\tcontinue\n\t\t\ttime = query.value(1)\n\t\t\thregion = self.HRegion(db, thread_id, comm_id, time)\n\t\t\tself.AddPoint(time, 1000, None, None, hregion)\n\n\tdef SelectSwitches(self, db):\n\t\tlast_time = None\n\t\tlast_comm_id = None\n\t\tlast_thread_id = None\n\t\tquery = QSqlQuery(db)\n\t\tQueryExec(query, \"SELECT time, thread_out_id, thread_in_id, comm_out_id, comm_in_id, flags\"\n\t\t\t\t\t\" FROM context_switches\"\n\t\t\t\t\t\" WHERE machine_id = \" + str(self.collection.machine_id) +\n\t\t\t\t\t\"   AND cpu = \" + str(self.cpu) +\n\t\t\t\t\t\" ORDER BY time, id\")\n\t\twhile query.next():\n\t\t\tflags = int(query.value(5))\n\t\t\tif flags & 1:\n\t\t\t\t# Schedule-out: detect and add exec's\n\t\t\t\tif last_thread_id == query.value(1) and last_comm_id is not None and last_comm_id != query.value(3):\n\t\t\t\t\tself.SelectComms(db, last_thread_id, last_comm_id, last_time, query.value(0))\n\t\t\t\tcontinue\n\t\t\t# Schedule-in: add data point\n\t\t\tif len(self.points) == 0:\n\t\t\t\tstart_time = self.collection.glb.StartTime(self.collection.machine_id)\n\t\t\t\thregion = self.HRegion(db, query.value(1), query.value(3), start_time)\n\t\t\t\tself.AddPoint(start_time, 1000, None, None, hregion)\n\t\t\ttime = query.value(0)\n\t\t\tcomm_id = query.value(4)\n\t\t\tthread_id = query.value(2)\n\t\t\thregion = self.HRegion(db, thread_id, comm_id, time)\n\t\t\tself.AddPoint(time, 1000, None, None, hregion)\n\t\t\tlast_time = time\n\t\t\tlast_comm_id = comm_id\n\t\t\tlast_thread_id = thread_id\n\n\tdef NewHRegion(self, db, key, thread_id, comm_id, time):\n\t\texec_comm_id = ExecComm(db, thread_id, time)\n\t\tquery = QSqlQuery(db)\n\t\tQueryExec(query, \"SELECT pid, tid FROM threads WHERE id = \" + str(thread_id))\n\t\tif query.next():\n\t\t\tpid = query.value(0)\n\t\t\ttid = query.value(1)\n\t\telse:\n\t\t\tpid = -1\n\t\t\ttid = -1\n\t\tquery = QSqlQuery(db)\n\t\tQueryExec(query, \"SELECT comm FROM comms WHERE id = \" + str(comm_id))\n\t\tif query.next():\n\t\t\tcomm = query.value(0)\n\t\telse:\n\t\t\tcomm = \"\"\n\t\treturn SwitchGraphDataRegion(key, exec_comm_id, pid, tid, comm, thread_id, comm_id)\n\n\tdef HRegion(self, db, thread_id, comm_id, time):\n\t\tkey = str(thread_id) + \":\" + str(comm_id)\n\t\thregion = self.collection.LookupHRegion(key)\n\t\tif hregion is None:\n\t\t\thregion = self.NewHRegion(db, key, thread_id, comm_id, time)\n\t\t\tself.collection.AddHRegion(key, hregion)\n\t\treturn hregion\n\n# Graph data collection (multiple related graphs) base class\n\nclass GraphDataCollection(object):\n\n\tdef __init__(self, glb):\n\t\tself.glb = glb\n\t\tself.data = []\n\t\tself.hregions = {}\n\t\tself.xrangelo = None\n\t\tself.xrangehi = None\n\t\tself.yrangelo = None\n\t\tself.yrangehi = None\n\t\tself.dp = XY(0, 0)\n\n\tdef AddGraphData(self, data):\n\t\tself.data.append(data)\n\n\tdef LookupHRegion(self, key):\n\t\tif key in self.hregions:\n\t\t\treturn self.hregions[key]\n\t\treturn None\n\n\tdef AddHRegion(self, key, hregion):\n\t\tself.hregions[key] = hregion\n\n# Switch graph data collection (SwitchGraphData for each CPU)\n\nclass SwitchGraphDataCollection(GraphDataCollection):\n\n\tdef __init__(self, glb, db, machine_id):\n\t\tsuper(SwitchGraphDataCollection, self).__init__(glb)\n\n\t\tself.machine_id = machine_id\n\t\tself.cpus = self.SelectCPUs(db)\n\n\t\tself.xrangelo = glb.StartTime(machine_id)\n\t\tself.xrangehi = glb.FinishTime(machine_id)\n\n\t\tself.yrangelo = Decimal(0)\n\t\tself.yrangehi = Decimal(1000)\n\n\t\tfor cpu in self.cpus:\n\t\t\tself.AddGraphData(SwitchGraphData(db, self, cpu, self.xrangelo))\n\n\tdef SelectCPUs(self, db):\n\t\tcpus = []\n\t\tquery = QSqlQuery(db)\n\t\tQueryExec(query, \"SELECT DISTINCT cpu\"\n\t\t\t\t\t\" FROM context_switches\"\n\t\t\t\t\t\" WHERE machine_id = \" + str(self.machine_id))\n\t\twhile query.next():\n\t\t\tcpus.append(int(query.value(0)))\n\t\treturn sorted(cpus)\n\n# Switch graph data graphics item displays the graphed data\n\nclass SwitchGraphDataGraphicsItem(QGraphicsItem):\n\n\tdef __init__(self, data, graph_width, graph_height, attrs, event_handler, parent=None):\n\t\tsuper(SwitchGraphDataGraphicsItem, self).__init__(parent)\n\n\t\tself.data = data\n\t\tself.graph_width = graph_width\n\t\tself.graph_height = graph_height\n\t\tself.attrs = attrs\n\t\tself.event_handler = event_handler\n\t\tself.setAcceptHoverEvents(True)\n\n\tdef boundingRect(self):\n\t\treturn QRectF(0, 0, self.graph_width, self.graph_height)\n\n\tdef PaintPoint(self, painter, last, x):\n\t\tif not(last is None or last.hregion.pid == 0 or x < self.attrs.subrange.x.lo):\n\t\t\tif last.x < self.attrs.subrange.x.lo:\n\t\t\t\tx0 = self.attrs.subrange.x.lo\n\t\t\telse:\n\t\t\t\tx0 = last.x\n\t\t\tif x > self.attrs.subrange.x.hi:\n\t\t\t\tx1 = self.attrs.subrange.x.hi\n\t\t\telse:\n\t\t\t\tx1 = x - 1\n\t\t\tx0 = self.attrs.XToPixel(x0)\n\t\t\tx1 = self.attrs.XToPixel(x1)\n\n\t\t\ty0 = self.attrs.YToPixel(last.y)\n\n\t\t\tcolour = self.attrs.region_attributes[last.hregion.key].colour\n\n\t\t\twidth = x1 - x0 + 1\n\t\t\tif width < 2:\n\t\t\t\tpainter.setPen(colour)\n\t\t\t\tpainter.drawLine(x0, self.graph_height - y0, x0, self.graph_height)\n\t\t\telse:\n\t\t\t\tpainter.fillRect(x0, self.graph_height - y0, width, self.graph_height - 1, colour)\n\n\tdef paint(self, painter, option, widget):\n\t\tlast = None\n\t\tfor point in self.data.points:\n\t\t\tself.PaintPoint(painter, last, point.x)\n\t\t\tif point.x > self.attrs.subrange.x.hi:\n\t\t\t\tbreak;\n\t\t\tlast = point\n\t\tself.PaintPoint(painter, last, self.attrs.subrange.x.hi + 1)\n\n\tdef BinarySearchPoint(self, target):\n\t\tlower_pos = 0\n\t\thigher_pos = len(self.data.points)\n\t\twhile True:\n\t\t\tpos = int((lower_pos + higher_pos) / 2)\n\t\t\tval = self.data.points[pos].x\n\t\t\tif target >= val:\n\t\t\t\tlower_pos = pos\n\t\t\telse:\n\t\t\t\thigher_pos = pos\n\t\t\tif higher_pos <= lower_pos + 1:\n\t\t\t\treturn lower_pos\n\n\tdef XPixelToData(self, x):\n\t\tx = self.attrs.PixelToX(x)\n\t\tif x < self.data.points[0].x:\n\t\t\tx = 0\n\t\t\tpos = 0\n\t\t\tlow = True\n\t\telse:\n\t\t\tpos = self.BinarySearchPoint(x)\n\t\t\tlow = False\n\t\treturn (low, pos, self.data.XToData(x))\n\n\tdef EventToData(self, event):\n\t\tno_data = (None,) * 4\n\t\tif len(self.data.points) < 1:\n\t\t\treturn no_data\n\t\tx = event.pos().x()\n\t\tif x < 0:\n\t\t\treturn no_data\n\t\tlow0, pos0, time_from = self.XPixelToData(x)\n\t\tlow1, pos1, time_to = self.XPixelToData(x + 1)\n\t\thregions = set()\n\t\thregion_times = []\n\t\tif not low1:\n\t\t\tfor i in xrange(pos0, pos1 + 1):\n\t\t\t\thregion = self.data.points[i].hregion\n\t\t\t\thregions.add(hregion)\n\t\t\t\tif i == pos0:\n\t\t\t\t\ttime = time_from\n\t\t\t\telse:\n\t\t\t\t\ttime = self.data.XToData(self.data.points[i].x)\n\t\t\t\thregion_times.append((hregion, time))\n\t\treturn (time_from, time_to, hregions, hregion_times)\n\n\tdef hoverMoveEvent(self, event):\n\t\ttime_from, time_to, hregions, hregion_times = self.EventToData(event)\n\t\tif time_from is not None:\n\t\t\tself.event_handler.PointEvent(self.data.cpu, time_from, time_to, hregions)\n\n\tdef hoverLeaveEvent(self, event):\n\t\tself.event_handler.NoPointEvent()\n\n\tdef mousePressEvent(self, event):\n\t\tif event.button() != Qt.RightButton:\n\t\t\tsuper(SwitchGraphDataGraphicsItem, self).mousePressEvent(event)\n\t\t\treturn\n\t\ttime_from, time_to, hregions, hregion_times = self.EventToData(event)\n\t\tif hregion_times:\n\t\t\tself.event_handler.RightClickEvent(self.data.cpu, hregion_times, event.screenPos())\n\n# X-axis graphics item\n\nclass XAxisGraphicsItem(QGraphicsItem):\n\n\tdef __init__(self, width, parent=None):\n\t\tsuper(XAxisGraphicsItem, self).__init__(parent)\n\n\t\tself.width = width\n\t\tself.max_mark_sz = 4\n\t\tself.height = self.max_mark_sz + 1\n\n\tdef boundingRect(self):\n\t\treturn QRectF(0, 0, self.width, self.height)\n\n\tdef Step(self):\n\t\tattrs = self.parentItem().attrs\n\t\tsubrange = attrs.subrange.x\n\t\tt = subrange.hi - subrange.lo\n\t\ts = (3.0 * t) / self.width\n\t\tn = 1.0\n\t\twhile s > n:\n\t\t\tn = n * 10.0\n\t\treturn n\n\n\tdef PaintMarks(self, painter, at_y, lo, hi, step, i):\n\t\tattrs = self.parentItem().attrs\n\t\tx = lo\n\t\twhile x <= hi:\n\t\t\txp = attrs.XToPixel(x)\n\t\t\tif i % 10:\n\t\t\t\tif i % 5:\n\t\t\t\t\tsz = 1\n\t\t\t\telse:\n\t\t\t\t\tsz = 2\n\t\t\telse:\n\t\t\t\tsz = self.max_mark_sz\n\t\t\t\ti = 0\n\t\t\tpainter.drawLine(xp, at_y, xp, at_y + sz)\n\t\t\tx += step\n\t\t\ti += 1\n\n\tdef paint(self, painter, option, widget):\n\t\t# Using QPainter::drawLine(int x1, int y1, int x2, int y2) so x2 = width -1\n\t\tpainter.drawLine(0, 0, self.width - 1, 0)\n\t\tn = self.Step()\n\t\tattrs = self.parentItem().attrs\n\t\tsubrange = attrs.subrange.x\n\t\tif subrange.lo:\n\t\t\tx_offset = n - (subrange.lo % n)\n\t\telse:\n\t\t\tx_offset = 0.0\n\t\tx = subrange.lo + x_offset\n\t\ti = (x / n) % 10\n\t\tself.PaintMarks(painter, 0, x, subrange.hi, n, i)\n\n\tdef ScaleDimensions(self):\n\t\tn = self.Step()\n\t\tattrs = self.parentItem().attrs\n\t\tlo = attrs.subrange.x.lo\n\t\thi = (n * 10.0) + lo\n\t\twidth = attrs.XToPixel(hi)\n\t\tif width > 500:\n\t\t\twidth = 0\n\t\treturn (n, lo, hi, width)\n\n\tdef PaintScale(self, painter, at_x, at_y):\n\t\tn, lo, hi, width = self.ScaleDimensions()\n\t\tif not width:\n\t\t\treturn\n\t\tpainter.drawLine(at_x, at_y, at_x + width, at_y)\n\t\tself.PaintMarks(painter, at_y, lo, hi, n, 0)\n\n\tdef ScaleWidth(self):\n\t\tn, lo, hi, width = self.ScaleDimensions()\n\t\treturn width\n\n\tdef ScaleHeight(self):\n\t\treturn self.height\n\n\tdef ScaleUnit(self):\n\t\treturn self.Step() * 10\n\n# Scale graphics item base class\n\nclass ScaleGraphicsItem(QGraphicsItem):\n\n\tdef __init__(self, axis, parent=None):\n\t\tsuper(ScaleGraphicsItem, self).__init__(parent)\n\t\tself.axis = axis\n\n\tdef boundingRect(self):\n\t\tscale_width = self.axis.ScaleWidth()\n\t\tif not scale_width:\n\t\t\treturn QRectF()\n\t\treturn QRectF(0, 0, self.axis.ScaleWidth() + 100, self.axis.ScaleHeight())\n\n\tdef paint(self, painter, option, widget):\n\t\tscale_width = self.axis.ScaleWidth()\n\t\tif not scale_width:\n\t\t\treturn\n\t\tself.axis.PaintScale(painter, 0, 5)\n\t\tx = scale_width + 4\n\t\tpainter.drawText(QPointF(x, 10), self.Text())\n\n\tdef Unit(self):\n\t\treturn self.axis.ScaleUnit()\n\n\tdef Text(self):\n\t\treturn \"\"\n\n# Switch graph scale graphics item\n\nclass SwitchScaleGraphicsItem(ScaleGraphicsItem):\n\n\tdef __init__(self, axis, parent=None):\n\t\tsuper(SwitchScaleGraphicsItem, self).__init__(axis, parent)\n\n\tdef Text(self):\n\t\tunit = self.Unit()\n\t\tif unit >= 1000000000:\n\t\t\tunit = int(unit / 1000000000)\n\t\t\tus = \"s\"\n\t\telif unit >= 1000000:\n\t\t\tunit = int(unit / 1000000)\n\t\t\tus = \"ms\"\n\t\telif unit >= 1000:\n\t\t\tunit = int(unit / 1000)\n\t\t\tus = \"us\"\n\t\telse:\n\t\t\tunit = int(unit)\n\t\t\tus = \"ns\"\n\t\treturn \" = \" + str(unit) + \" \" + us\n\n# Switch graph graphics item contains graph title, scale, x/y-axis, and the graphed data\n\nclass SwitchGraphGraphicsItem(QGraphicsItem):\n\n\tdef __init__(self, collection, data, attrs, event_handler, first, parent=None):\n\t\tsuper(SwitchGraphGraphicsItem, self).__init__(parent)\n\t\tself.collection = collection\n\t\tself.data = data\n\t\tself.attrs = attrs\n\t\tself.event_handler = event_handler\n\n\t\tmargin = 20\n\t\ttitle_width = 50\n\n\t\tself.title_graphics = QGraphicsSimpleTextItem(data.title, self)\n\n\t\tself.title_graphics.setPos(margin, margin)\n\t\tgraph_width = attrs.XToPixel(attrs.subrange.x.hi) + 1\n\t\tgraph_height = attrs.YToPixel(attrs.subrange.y.hi) + 1\n\n\t\tself.graph_origin_x = margin + title_width + margin\n\t\tself.graph_origin_y = graph_height + margin\n\n\t\tx_axis_size = 1\n\t\ty_axis_size = 1\n\t\tself.yline = QGraphicsLineItem(0, 0, 0, graph_height, self)\n\n\t\tself.x_axis = XAxisGraphicsItem(graph_width, self)\n\t\tself.x_axis.setPos(self.graph_origin_x, self.graph_origin_y + 1)\n\n\t\tif first:\n\t\t\tself.scale_item = SwitchScaleGraphicsItem(self.x_axis, self)\n\t\t\tself.scale_item.setPos(self.graph_origin_x, self.graph_origin_y + 10)\n\n\t\tself.yline.setPos(self.graph_origin_x - y_axis_size, self.graph_origin_y - graph_height)\n\n\t\tself.axis_point = QGraphicsLineItem(0, 0, 0, 0, self)\n\t\tself.axis_point.setPos(self.graph_origin_x - 1, self.graph_origin_y +1)\n\n\t\tself.width = self.graph_origin_x + graph_width + margin\n\t\tself.height = self.graph_origin_y + margin\n\n\t\tself.graph = SwitchGraphDataGraphicsItem(data, graph_width, graph_height, attrs, event_handler, self)\n\t\tself.graph.setPos(self.graph_origin_x, self.graph_origin_y - graph_height)\n\n\t\tif parent and 'EnableRubberBand' in dir(parent):\n\t\t\tparent.EnableRubberBand(self.graph_origin_x, self.graph_origin_x + graph_width - 1, self)\n\n\tdef boundingRect(self):\n\t\treturn QRectF(0, 0, self.width, self.height)\n\n\tdef paint(self, painter, option, widget):\n\t\tpass\n\n\tdef RBXToPixel(self, x):\n\t\treturn self.attrs.PixelToX(x - self.graph_origin_x)\n\n\tdef RBXRangeToPixel(self, x0, x1):\n\t\treturn (self.RBXToPixel(x0), self.RBXToPixel(x1 + 1))\n\n\tdef RBPixelToTime(self, x):\n\t\tif x < self.data.points[0].x:\n\t\t\treturn self.data.XToData(0)\n\t\treturn self.data.XToData(x)\n\n\tdef RBEventTimes(self, x0, x1):\n\t\tx0, x1 = self.RBXRangeToPixel(x0, x1)\n\t\ttime_from = self.RBPixelToTime(x0)\n\t\ttime_to = self.RBPixelToTime(x1)\n\t\treturn (time_from, time_to)\n\n\tdef RBEvent(self, x0, x1):\n\t\ttime_from, time_to = self.RBEventTimes(x0, x1)\n\t\tself.event_handler.RangeEvent(time_from, time_to)\n\n\tdef RBMoveEvent(self, x0, x1):\n\t\tif x1 < x0:\n\t\t\tx0, x1 = x1, x0\n\t\tself.RBEvent(x0, x1)\n\n\tdef RBReleaseEvent(self, x0, x1, selection_state):\n\t\tif x1 < x0:\n\t\t\tx0, x1 = x1, x0\n\t\tx0, x1 = self.RBXRangeToPixel(x0, x1)\n\t\tself.event_handler.SelectEvent(x0, x1, selection_state)\n\n# Graphics item to draw a vertical bracket (used to highlight \"forward\" sub-range)\n\nclass VerticalBracketGraphicsItem(QGraphicsItem):\n\n\tdef __init__(self, parent=None):\n\t\tsuper(VerticalBracketGraphicsItem, self).__init__(parent)\n\n\t\tself.width = 0\n\t\tself.height = 0\n\t\tself.hide()\n\n\tdef SetSize(self, width, height):\n\t\tself.width = width + 1\n\t\tself.height = height + 1\n\n\tdef boundingRect(self):\n\t\treturn QRectF(0, 0, self.width, self.height)\n\n\tdef paint(self, painter, option, widget):\n\t\tcolour = QColor(255, 255, 0, 32)\n\t\tpainter.fillRect(0, 0, self.width, self.height, colour)\n\t\tx1 = self.width - 1\n\t\ty1 = self.height - 1\n\t\tpainter.drawLine(0, 0, x1, 0)\n\t\tpainter.drawLine(0, 0, 0, 3)\n\t\tpainter.drawLine(x1, 0, x1, 3)\n\t\tpainter.drawLine(0, y1, x1, y1)\n\t\tpainter.drawLine(0, y1, 0, y1 - 3)\n\t\tpainter.drawLine(x1, y1, x1, y1 - 3)\n\n# Graphics item to contain graphs arranged vertically\n\nclass VertcalGraphSetGraphicsItem(QGraphicsItem):\n\n\tdef __init__(self, collection, attrs, event_handler, child_class, parent=None):\n\t\tsuper(VertcalGraphSetGraphicsItem, self).__init__(parent)\n\n\t\tself.collection = collection\n\n\t\tself.top = 10\n\n\t\tself.width = 0\n\t\tself.height = self.top\n\n\t\tself.rubber_band = None\n\t\tself.rb_enabled = False\n\n\t\tfirst = True\n\t\tfor data in collection.data:\n\t\t\tchild = child_class(collection, data, attrs, event_handler, first, self)\n\t\t\tchild.setPos(0, self.height + 1)\n\t\t\trect = child.boundingRect()\n\t\t\tif rect.right() > self.width:\n\t\t\t\tself.width = rect.right()\n\t\t\tself.height = self.height + rect.bottom() + 1\n\t\t\tfirst = False\n\n\t\tself.bracket = VerticalBracketGraphicsItem(self)\n\n\tdef EnableRubberBand(self, xlo, xhi, rb_event_handler):\n\t\tif self.rb_enabled:\n\t\t\treturn\n\t\tself.rb_enabled = True\n\t\tself.rb_in_view = False\n\t\tself.setAcceptedMouseButtons(Qt.LeftButton)\n\t\tself.rb_xlo = xlo\n\t\tself.rb_xhi = xhi\n\t\tself.rb_event_handler = rb_event_handler\n\t\tself.mousePressEvent = self.MousePressEvent\n\t\tself.mouseMoveEvent = self.MouseMoveEvent\n\t\tself.mouseReleaseEvent = self.MouseReleaseEvent\n\n\tdef boundingRect(self):\n\t\treturn QRectF(0, 0, self.width, self.height)\n\n\tdef paint(self, painter, option, widget):\n\t\tpass\n\n\tdef RubberBandParent(self):\n\t\tscene = self.scene()\n\t\tview = scene.views()[0]\n\t\tviewport = view.viewport()\n\t\treturn viewport\n\n\tdef RubberBandSetGeometry(self, rect):\n\t\tscene_rectf = self.mapRectToScene(QRectF(rect))\n\t\tscene = self.scene()\n\t\tview = scene.views()[0]\n\t\tpoly = view.mapFromScene(scene_rectf)\n\t\tself.rubber_band.setGeometry(poly.boundingRect())\n\n\tdef SetSelection(self, selection_state):\n\t\tif self.rubber_band:\n\t\t\tif selection_state:\n\t\t\t\tself.RubberBandSetGeometry(selection_state)\n\t\t\t\tself.rubber_band.show()\n\t\t\telse:\n\t\t\t\tself.rubber_band.hide()\n\n\tdef SetBracket(self, rect):\n\t\tif rect:\n\t\t\tx, y, width, height = rect.x(), rect.y(), rect.width(), rect.height()\n\t\t\tself.bracket.setPos(x, y)\n\t\t\tself.bracket.SetSize(width, height)\n\t\t\tself.bracket.show()\n\t\telse:\n\t\t\tself.bracket.hide()\n\n\tdef RubberBandX(self, event):\n\t\tx = event.pos().toPoint().x()\n\t\tif x < self.rb_xlo:\n\t\t\tx = self.rb_xlo\n\t\telif x > self.rb_xhi:\n\t\t\tx = self.rb_xhi\n\t\telse:\n\t\t\tself.rb_in_view = True\n\t\treturn x\n\n\tdef RubberBandRect(self, x):\n\t\tif self.rb_origin.x() <= x:\n\t\t\twidth = x - self.rb_origin.x()\n\t\t\trect = QRect(self.rb_origin, QSize(width, self.height))\n\t\telse:\n\t\t\twidth = self.rb_origin.x() - x\n\t\t\ttop_left = QPoint(self.rb_origin.x() - width, self.rb_origin.y())\n\t\t\trect = QRect(top_left, QSize(width, self.height))\n\t\treturn rect\n\n\tdef MousePressEvent(self, event):\n\t\tself.rb_in_view = False\n\t\tx = self.RubberBandX(event)\n\t\tself.rb_origin = QPoint(x, self.top)\n\t\tif self.rubber_band is None:\n\t\t\tself.rubber_band = QRubberBand(QRubberBand.Rectangle, self.RubberBandParent())\n\t\tself.RubberBandSetGeometry(QRect(self.rb_origin, QSize(0, self.height)))\n\t\tif self.rb_in_view:\n\t\t\tself.rubber_band.show()\n\t\t\tself.rb_event_handler.RBMoveEvent(x, x)\n\t\telse:\n\t\t\tself.rubber_band.hide()\n\n\tdef MouseMoveEvent(self, event):\n\t\tx = self.RubberBandX(event)\n\t\trect = self.RubberBandRect(x)\n\t\tself.RubberBandSetGeometry(rect)\n\t\tif self.rb_in_view:\n\t\t\tself.rubber_band.show()\n\t\t\tself.rb_event_handler.RBMoveEvent(self.rb_origin.x(), x)\n\n\tdef MouseReleaseEvent(self, event):\n\t\tx = self.RubberBandX(event)\n\t\tif self.rb_in_view:\n\t\t\tselection_state = self.RubberBandRect(x)\n\t\telse:\n\t\t\tselection_state = None\n\t\tself.rb_event_handler.RBReleaseEvent(self.rb_origin.x(), x, selection_state)\n\n# Switch graph legend data model\n\nclass SwitchGraphLegendModel(QAbstractTableModel):\n\n\tdef __init__(self, collection, region_attributes, parent=None):\n\t\tsuper(SwitchGraphLegendModel, self).__init__(parent)\n\n\t\tself.region_attributes = region_attributes\n\n\t\tself.child_items = sorted(collection.hregions.values(), key=GraphDataRegionOrdinal)\n\t\tself.child_count = len(self.child_items)\n\n\t\tself.highlight_set = set()\n\n\t\tself.column_headers = (\"pid\", \"tid\", \"comm\")\n\n\tdef rowCount(self, parent):\n\t\treturn self.child_count\n\n\tdef headerData(self, section, orientation, role):\n\t\tif role != Qt.DisplayRole:\n\t\t\treturn None\n\t\tif orientation != Qt.Horizontal:\n\t\t\treturn None\n\t\treturn self.columnHeader(section)\n\n\tdef index(self, row, column, parent):\n\t\treturn self.createIndex(row, column, self.child_items[row])\n\n\tdef columnCount(self, parent=None):\n\t\treturn len(self.column_headers)\n\n\tdef columnHeader(self, column):\n\t\treturn self.column_headers[column]\n\n\tdef data(self, index, role):\n\t\tif role == Qt.BackgroundRole:\n\t\t\tchild = self.child_items[index.row()]\n\t\t\tif child in self.highlight_set:\n\t\t\t\treturn self.region_attributes[child.key].colour\n\t\t\treturn None\n\t\tif role == Qt.ForegroundRole:\n\t\t\tchild = self.child_items[index.row()]\n\t\t\tif child in self.highlight_set:\n\t\t\t\treturn QColor(255, 255, 255)\n\t\t\treturn self.region_attributes[child.key].colour\n\t\tif role != Qt.DisplayRole:\n\t\t\treturn None\n\t\thregion = self.child_items[index.row()]\n\t\tcol = index.column()\n\t\tif col == 0:\n\t\t\treturn hregion.pid\n\t\tif col == 1:\n\t\t\treturn hregion.tid\n\t\tif col == 2:\n\t\t\treturn hregion.comm\n\t\treturn None\n\n\tdef SetHighlight(self, row, set_highlight):\n\t\tchild = self.child_items[row]\n\t\ttop_left = self.createIndex(row, 0, child)\n\t\tbottom_right = self.createIndex(row, len(self.column_headers) - 1, child)\n\t\tself.dataChanged.emit(top_left, bottom_right)\n\n\tdef Highlight(self, highlight_set):\n\t\tfor row in xrange(self.child_count):\n\t\t\tchild = self.child_items[row]\n\t\t\tif child in self.highlight_set:\n\t\t\t\tif child not in highlight_set:\n\t\t\t\t\tself.SetHighlight(row, False)\n\t\t\telif child in highlight_set:\n\t\t\t\tself.SetHighlight(row, True)\n\t\tself.highlight_set = highlight_set\n\n# Switch graph legend is a table\n\nclass SwitchGraphLegend(QWidget):\n\n\tdef __init__(self, collection, region_attributes, parent=None):\n\t\tsuper(SwitchGraphLegend, self).__init__(parent)\n\n\t\tself.data_model = SwitchGraphLegendModel(collection, region_attributes)\n\n\t\tself.model = QSortFilterProxyModel()\n\t\tself.model.setSourceModel(self.data_model)\n\n\t\tself.view = QTableView()\n\t\tself.view.setModel(self.model)\n\t\tself.view.setEditTriggers(QAbstractItemView.NoEditTriggers)\n\t\tself.view.verticalHeader().setVisible(False)\n\t\tself.view.sortByColumn(-1, Qt.AscendingOrder)\n\t\tself.view.setSortingEnabled(True)\n\t\tself.view.resizeColumnsToContents()\n\t\tself.view.resizeRowsToContents()\n\n\t\tself.vbox = VBoxLayout(self.view)\n\t\tself.setLayout(self.vbox)\n\n\t\tsz1 = self.view.columnWidth(0) + self.view.columnWidth(1) + self.view.columnWidth(2) + 2\n\t\tsz1 = sz1 + self.view.verticalScrollBar().sizeHint().width()\n\t\tself.saved_size = sz1\n\n\tdef resizeEvent(self, event):\n\t\tself.saved_size = self.size().width()\n\t\tsuper(SwitchGraphLegend, self).resizeEvent(event)\n\n\tdef Highlight(self, highlight_set):\n\t\tself.data_model.Highlight(highlight_set)\n\t\tself.update()\n\n\tdef changeEvent(self, event):\n\t\tif event.type() == QEvent.FontChange:\n\t\t\tself.view.resizeRowsToContents()\n\t\t\tself.view.resizeColumnsToContents()\n\t\t\t# Need to resize rows again after column resize\n\t\t\tself.view.resizeRowsToContents()\n\t\tsuper(SwitchGraphLegend, self).changeEvent(event)\n\n# Random colour generation\n\ndef RGBColourTooLight(r, g, b):\n\tif g > 230:\n\t\treturn True\n\tif g <= 160:\n\t\treturn False\n\tif r <= 180 and g <= 180:\n\t\treturn False\n\tif r < 60:\n\t\treturn False\n\treturn True\n\ndef GenerateColours(x):\n\tcs = [0]\n\tfor i in xrange(1, x):\n\t\tcs.append(int((255.0 / i) + 0.5))\n\tcolours = []\n\tfor r in cs:\n\t\tfor g in cs:\n\t\t\tfor b in cs:\n\t\t\t\t# Exclude black and colours that look too light against a white background\n\t\t\t\tif (r, g, b) == (0, 0, 0) or RGBColourTooLight(r, g, b):\n\t\t\t\t\tcontinue\n\t\t\t\tcolours.append(QColor(r, g, b))\n\treturn colours\n\ndef GenerateNColours(n):\n\tfor x in xrange(2, n + 2):\n\t\tcolours = GenerateColours(x)\n\t\tif len(colours) >= n:\n\t\t\treturn colours\n\treturn []\n\ndef GenerateNRandomColours(n, seed):\n\tcolours = GenerateNColours(n)\n\trandom.seed(seed)\n\trandom.shuffle(colours)\n\treturn colours\n\n# Graph attributes, in particular the scale and subrange that change when zooming\n\nclass GraphAttributes():\n\n\tdef __init__(self, scale, subrange, region_attributes, dp):\n\t\tself.scale = scale\n\t\tself.subrange = subrange\n\t\tself.region_attributes = region_attributes\n\t\t# Rounding avoids errors due to finite floating point precision\n\t\tself.dp = dp\t# data decimal places\n\t\tself.Update()\n\n\tdef XToPixel(self, x):\n\t\treturn int(round((x - self.subrange.x.lo) * self.scale.x, self.pdp.x))\n\n\tdef YToPixel(self, y):\n\t\treturn int(round((y - self.subrange.y.lo) * self.scale.y, self.pdp.y))\n\n\tdef PixelToXRounded(self, px):\n\t\treturn round((round(px, 0) / self.scale.x), self.dp.x) + self.subrange.x.lo\n\n\tdef PixelToYRounded(self, py):\n\t\treturn round((round(py, 0) / self.scale.y), self.dp.y) + self.subrange.y.lo\n\n\tdef PixelToX(self, px):\n\t\tx = self.PixelToXRounded(px)\n\t\tif self.pdp.x == 0:\n\t\t\trt = self.XToPixel(x)\n\t\t\tif rt > px:\n\t\t\t\treturn x - 1\n\t\treturn x\n\n\tdef PixelToY(self, py):\n\t\ty = self.PixelToYRounded(py)\n\t\tif self.pdp.y == 0:\n\t\t\trt = self.YToPixel(y)\n\t\t\tif rt > py:\n\t\t\t\treturn y - 1\n\t\treturn y\n\n\tdef ToPDP(self, dp, scale):\n\t\t# Calculate pixel decimal places:\n\t\t#    (10 ** dp) is the minimum delta in the data\n\t\t#    scale it to get the minimum delta in pixels\n\t\t#    log10 gives the number of decimals places negatively\n\t\t#    subtrace 1 to divide by 10\n\t\t#    round to the lower negative number\n\t\t#    change the sign to get the number of decimals positively\n\t\tx = math.log10((10 ** dp) * scale)\n\t\tif x < 0:\n\t\t\tx -= 1\n\t\t\tx = -int(math.floor(x) - 0.1)\n\t\telse:\n\t\t\tx = 0\n\t\treturn x\n\n\tdef Update(self):\n\t\tx = self.ToPDP(self.dp.x, self.scale.x)\n\t\ty = self.ToPDP(self.dp.y, self.scale.y)\n\t\tself.pdp = XY(x, y) # pixel decimal places\n\n# Switch graph splitter which divides the CPU graphs from the legend\n\nclass SwitchGraphSplitter(QSplitter):\n\n\tdef __init__(self, parent=None):\n\t\tsuper(SwitchGraphSplitter, self).__init__(parent)\n\n\t\tself.first_time = False\n\n\tdef resizeEvent(self, ev):\n\t\tif self.first_time:\n\t\t\tself.first_time = False\n\t\t\tsz1 = self.widget(1).view.columnWidth(0) + self.widget(1).view.columnWidth(1) + self.widget(1).view.columnWidth(2) + 2\n\t\t\tsz1 = sz1 + self.widget(1).view.verticalScrollBar().sizeHint().width()\n\t\t\tsz0 = self.size().width() - self.handleWidth() - sz1\n\t\t\tself.setSizes([sz0, sz1])\n\t\telif not(self.widget(1).saved_size is None):\n\t\t\tsz1 = self.widget(1).saved_size\n\t\t\tsz0 = self.size().width() - self.handleWidth() - sz1\n\t\t\tself.setSizes([sz0, sz1])\n\t\tsuper(SwitchGraphSplitter, self).resizeEvent(ev)\n\n# Graph widget base class\n\nclass GraphWidget(QWidget):\n\n\tgraph_title_changed = Signal(object)\n\n\tdef __init__(self, parent=None):\n\t\tsuper(GraphWidget, self).__init__(parent)\n\n\tdef GraphTitleChanged(self, title):\n\t\tself.graph_title_changed.emit(title)\n\n\tdef Title(self):\n\t\treturn \"\"\n\n# Display time in s, ms, us or ns\n\ndef ToTimeStr(val):\n\tval = Decimal(val)\n\tif val >= 1000000000:\n\t\treturn \"{} s\".format((val / 1000000000).quantize(Decimal(\"0.000000001\")))\n\tif val >= 1000000:\n\t\treturn \"{} ms\".format((val / 1000000).quantize(Decimal(\"0.000001\")))\n\tif val >= 1000:\n\t\treturn \"{} us\".format((val / 1000).quantize(Decimal(\"0.001\")))\n\treturn \"{} ns\".format(val.quantize(Decimal(\"1\")))\n\n# Switch (i.e. context switch i.e. Time Chart by CPU) graph widget which contains the CPU graphs and the legend and control buttons\n\nclass SwitchGraphWidget(GraphWidget):\n\n\tdef __init__(self, glb, collection, parent=None):\n\t\tsuper(SwitchGraphWidget, self).__init__(parent)\n\n\t\tself.glb = glb\n\t\tself.collection = collection\n\n\t\tself.back_state = []\n\t\tself.forward_state = []\n\t\tself.selection_state = (None, None)\n\t\tself.fwd_rect = None\n\t\tself.start_time = self.glb.StartTime(collection.machine_id)\n\n\t\ti = 0\n\t\thregions = collection.hregions.values()\n\t\tcolours = GenerateNRandomColours(len(hregions), 1013)\n\t\tregion_attributes = {}\n\t\tfor hregion in hregions:\n\t\t\tif hregion.pid == 0 and hregion.tid == 0:\n\t\t\t\tregion_attributes[hregion.key] = GraphRegionAttribute(QColor(0, 0, 0))\n\t\t\telse:\n\t\t\t\tregion_attributes[hregion.key] = GraphRegionAttribute(colours[i])\n\t\t\t\ti = i + 1\n\n\t\t# Default to entire range\n\t\txsubrange = Subrange(0.0, float(collection.xrangehi - collection.xrangelo) + 1.0)\n\t\tysubrange = Subrange(0.0, float(collection.yrangehi - collection.yrangelo) + 1.0)\n\t\tsubrange = XY(xsubrange, ysubrange)\n\n\t\tscale = self.GetScaleForRange(subrange)\n\n\t\tself.attrs = GraphAttributes(scale, subrange, region_attributes, collection.dp)\n\n\t\tself.item = VertcalGraphSetGraphicsItem(collection, self.attrs, self, SwitchGraphGraphicsItem)\n\n\t\tself.scene = QGraphicsScene()\n\t\tself.scene.addItem(self.item)\n\n\t\tself.view = QGraphicsView(self.scene)\n\t\tself.view.centerOn(0, 0)\n\t\tself.view.setAlignment(Qt.AlignLeft | Qt.AlignTop)\n\n\t\tself.legend = SwitchGraphLegend(collection, region_attributes)\n\n\t\tself.splitter = SwitchGraphSplitter()\n\t\tself.splitter.addWidget(self.view)\n\t\tself.splitter.addWidget(self.legend)\n\n\t\tself.point_label = QLabel(\"\")\n\t\tself.point_label.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)\n\n\t\tself.back_button = QToolButton()\n\t\tself.back_button.setIcon(self.style().standardIcon(QStyle.SP_ArrowLeft))\n\t\tself.back_button.setDisabled(True)\n\t\tself.back_button.released.connect(lambda: self.Back())\n\n\t\tself.forward_button = QToolButton()\n\t\tself.forward_button.setIcon(self.style().standardIcon(QStyle.SP_ArrowRight))\n\t\tself.forward_button.setDisabled(True)\n\t\tself.forward_button.released.connect(lambda: self.Forward())\n\n\t\tself.zoom_button = QToolButton()\n\t\tself.zoom_button.setText(\"Zoom\")\n\t\tself.zoom_button.setDisabled(True)\n\t\tself.zoom_button.released.connect(lambda: self.Zoom())\n\n\t\tself.hbox = HBoxLayout(self.back_button, self.forward_button, self.zoom_button, self.point_label)\n\n\t\tself.vbox = VBoxLayout(self.splitter, self.hbox)\n\n\t\tself.setLayout(self.vbox)\n\n\tdef GetScaleForRangeX(self, xsubrange):\n\t\t# Default graph 1000 pixels wide\n\t\tdflt = 1000.0\n\t\tr = xsubrange.hi - xsubrange.lo\n\t\treturn dflt / r\n\n\tdef GetScaleForRangeY(self, ysubrange):\n\t\t# Default graph 50 pixels high\n\t\tdflt = 50.0\n\t\tr = ysubrange.hi - ysubrange.lo\n\t\treturn dflt / r\n\n\tdef GetScaleForRange(self, subrange):\n\t\t# Default graph 1000 pixels wide, 50 pixels high\n\t\txscale = self.GetScaleForRangeX(subrange.x)\n\t\tyscale = self.GetScaleForRangeY(subrange.y)\n\t\treturn XY(xscale, yscale)\n\n\tdef PointEvent(self, cpu, time_from, time_to, hregions):\n\t\ttext = \"CPU: \" + str(cpu)\n\t\ttime_from = time_from.quantize(Decimal(1))\n\t\trel_time_from = time_from - self.glb.StartTime(self.collection.machine_id)\n\t\ttext = text + \" Time: \" + str(time_from) + \" (+\" + ToTimeStr(rel_time_from) + \")\"\n\t\tself.point_label.setText(text)\n\t\tself.legend.Highlight(hregions)\n\n\tdef RightClickEvent(self, cpu, hregion_times, pos):\n\t\tif not IsSelectable(self.glb.db, \"calls\", \"WHERE parent_id >= 0\"):\n\t\t\treturn\n\t\tmenu = QMenu(self.view)\n\t\tfor hregion, time in hregion_times:\n\t\t\tthread_at_time = (hregion.exec_comm_id, hregion.thread_id, time)\n\t\t\tmenu_text = \"Show Call Tree for {} {}:{} at {}\".format(hregion.comm, hregion.pid, hregion.tid, time)\n\t\t\tmenu.addAction(CreateAction(menu_text, \"Show Call Tree\", lambda a=None, args=thread_at_time: self.RightClickSelect(args), self.view))\n\t\tmenu.exec_(pos)\n\n\tdef RightClickSelect(self, args):\n\t\tCallTreeWindow(self.glb, self.glb.mainwindow, thread_at_time=args)\n\n\tdef NoPointEvent(self):\n\t\tself.point_label.setText(\"\")\n\t\tself.legend.Highlight({})\n\n\tdef RangeEvent(self, time_from, time_to):\n\t\ttime_from = time_from.quantize(Decimal(1))\n\t\ttime_to = time_to.quantize(Decimal(1))\n\t\tif time_to <= time_from:\n\t\t\tself.point_label.setText(\"\")\n\t\t\treturn\n\t\trel_time_from = time_from - self.start_time\n\t\trel_time_to = time_to - self.start_time\n\t\ttext = \" Time: \" + str(time_from) + \" (+\" + ToTimeStr(rel_time_from) + \") to: \" + str(time_to) + \" (+\" + ToTimeStr(rel_time_to) + \")\"\n\t\ttext = text + \" duration: \" + ToTimeStr(time_to - time_from)\n\t\tself.point_label.setText(text)\n\n\tdef BackState(self):\n\t\treturn (self.attrs.subrange, self.attrs.scale, self.selection_state, self.fwd_rect)\n\n\tdef PushBackState(self):\n\t\tstate = copy.deepcopy(self.BackState())\n\t\tself.back_state.append(state)\n\t\tself.back_button.setEnabled(True)\n\n\tdef PopBackState(self):\n\t\tself.attrs.subrange, self.attrs.scale, self.selection_state, self.fwd_rect = self.back_state.pop()\n\t\tself.attrs.Update()\n\t\tif not self.back_state:\n\t\t\tself.back_button.setDisabled(True)\n\n\tdef PushForwardState(self):\n\t\tstate = copy.deepcopy(self.BackState())\n\t\tself.forward_state.append(state)\n\t\tself.forward_button.setEnabled(True)\n\n\tdef PopForwardState(self):\n\t\tself.attrs.subrange, self.attrs.scale, self.selection_state, self.fwd_rect = self.forward_state.pop()\n\t\tself.attrs.Update()\n\t\tif not self.forward_state:\n\t\t\tself.forward_button.setDisabled(True)\n\n\tdef Title(self):\n\t\ttime_from = self.collection.xrangelo + Decimal(self.attrs.subrange.x.lo)\n\t\ttime_to = self.collection.xrangelo + Decimal(self.attrs.subrange.x.hi)\n\t\trel_time_from = time_from - self.start_time\n\t\trel_time_to = time_to - self.start_time\n\t\ttitle = \"+\" + ToTimeStr(rel_time_from) + \" to +\" + ToTimeStr(rel_time_to)\n\t\ttitle = title + \" (\" + ToTimeStr(time_to - time_from) + \")\"\n\t\treturn title\n\n\tdef Update(self):\n\t\tselected_subrange, selection_state = self.selection_state\n\t\tself.item.SetSelection(selection_state)\n\t\tself.item.SetBracket(self.fwd_rect)\n\t\tself.zoom_button.setDisabled(selected_subrange is None)\n\t\tself.GraphTitleChanged(self.Title())\n\t\tself.item.update(self.item.boundingRect())\n\n\tdef Back(self):\n\t\tif not self.back_state:\n\t\t\treturn\n\t\tself.PushForwardState()\n\t\tself.PopBackState()\n\t\tself.Update()\n\n\tdef Forward(self):\n\t\tif not self.forward_state:\n\t\t\treturn\n\t\tself.PushBackState()\n\t\tself.PopForwardState()\n\t\tself.Update()\n\n\tdef SelectEvent(self, x0, x1, selection_state):\n\t\tif selection_state is None:\n\t\t\tselected_subrange = None\n\t\telse:\n\t\t\tif x1 - x0 < 1.0:\n\t\t\t\tx1 += 1.0\n\t\t\tselected_subrange = Subrange(x0, x1)\n\t\tself.selection_state = (selected_subrange, selection_state)\n\t\tself.zoom_button.setDisabled(selected_subrange is None)\n\n\tdef Zoom(self):\n\t\tselected_subrange, selection_state = self.selection_state\n\t\tif selected_subrange is None:\n\t\t\treturn\n\t\tself.fwd_rect = selection_state\n\t\tself.item.SetSelection(None)\n\t\tself.PushBackState()\n\t\tself.attrs.subrange.x = selected_subrange\n\t\tself.forward_state = []\n\t\tself.forward_button.setDisabled(True)\n\t\tself.selection_state = (None, None)\n\t\tself.fwd_rect = None\n\t\tself.attrs.scale.x = self.GetScaleForRangeX(self.attrs.subrange.x)\n\t\tself.attrs.Update()\n\t\tself.Update()\n\n# Slow initialization - perform non-GUI initialization in a separate thread and put up a modal message box while waiting\n\nclass SlowInitClass():\n\n\tdef __init__(self, glb, title, init_fn):\n\t\tself.init_fn = init_fn\n\t\tself.done = False\n\t\tself.result = None\n\n\t\tself.msg_box = QMessageBox(glb.mainwindow)\n\t\tself.msg_box.setText(\"Initializing \" + title + \". Please wait.\")\n\t\tself.msg_box.setWindowTitle(\"Initializing \" + title)\n\t\tself.msg_box.setWindowIcon(glb.mainwindow.style().standardIcon(QStyle.SP_MessageBoxInformation))\n\n\t\tself.init_thread = Thread(self.ThreadFn, glb)\n\t\tself.init_thread.done.connect(lambda: self.Done(), Qt.QueuedConnection)\n\n\t\tself.init_thread.start()\n\n\tdef Done(self):\n\t\tself.msg_box.done(0)\n\n\tdef ThreadFn(self, glb):\n\t\tconn_name = \"SlowInitClass\" + str(os.getpid())\n\t\tdb, dbname = glb.dbref.Open(conn_name)\n\t\tself.result = self.init_fn(db)\n\t\tself.done = True\n\t\treturn (True, 0)\n\n\tdef Result(self):\n\t\twhile not self.done:\n\t\t\tself.msg_box.exec_()\n\t\tself.init_thread.wait()\n\t\treturn self.result\n\ndef SlowInit(glb, title, init_fn):\n\tinit = SlowInitClass(glb, title, init_fn)\n\treturn init.Result()\n\n# Time chart by CPU window\n\nclass TimeChartByCPUWindow(QMdiSubWindow):\n\n\tdef __init__(self, glb, parent=None):\n\t\tsuper(TimeChartByCPUWindow, self).__init__(parent)\n\n\t\tself.glb = glb\n\t\tself.machine_id = glb.HostMachineId()\n\t\tself.collection_name = \"SwitchGraphDataCollection \" + str(self.machine_id)\n\n\t\tcollection = LookupModel(self.collection_name)\n\t\tif collection is None:\n\t\t\tcollection = SlowInit(glb, \"Time Chart\", self.Init)\n\n\t\tself.widget = SwitchGraphWidget(glb, collection, self)\n\t\tself.view = self.widget\n\n\t\tself.base_title = \"Time Chart by CPU\"\n\t\tself.setWindowTitle(self.base_title + self.widget.Title())\n\t\tself.widget.graph_title_changed.connect(self.GraphTitleChanged)\n\n\t\tself.setWidget(self.widget)\n\n\t\tAddSubWindow(glb.mainwindow.mdi_area, self, self.windowTitle())\n\n\tdef Init(self, db):\n\t\treturn LookupCreateModel(self.collection_name, lambda : SwitchGraphDataCollection(self.glb, db, self.machine_id))\n\n\tdef GraphTitleChanged(self, title):\n\t\tself.setWindowTitle(self.base_title + \" : \" + title)\n\n# Child data item  finder\n\nclass ChildDataItemFinder():\n\n\tdef __init__(self, root):\n\t\tself.root = root\n\t\tself.value, self.direction, self.pattern, self.last_value, self.last_pattern = (None,) * 5\n\t\tself.rows = []\n\t\tself.pos = 0\n\n\tdef FindSelect(self):\n\t\tself.rows = []\n\t\tif self.pattern:\n\t\t\tpattern = re.compile(self.value)\n\t\t\tfor child in self.root.child_items:\n\t\t\t\tfor column_data in child.data:\n\t\t\t\t\tif re.search(pattern, str(column_data)) is not None:\n\t\t\t\t\t\tself.rows.append(child.row)\n\t\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor child in self.root.child_items:\n\t\t\t\tfor column_data in child.data:\n\t\t\t\t\tif self.value in str(column_data):\n\t\t\t\t\t\tself.rows.append(child.row)\n\t\t\t\t\t\tbreak\n\n\tdef FindValue(self):\n\t\tself.pos = 0\n\t\tif self.last_value != self.value or self.pattern != self.last_pattern:\n\t\t\tself.FindSelect()\n\t\tif not len(self.rows):\n\t\t\treturn -1\n\t\treturn self.rows[self.pos]\n\n\tdef FindThread(self):\n\t\tif self.direction == 0 or self.value != self.last_value or self.pattern != self.last_pattern:\n\t\t\trow = self.FindValue()\n\t\telif len(self.rows):\n\t\t\tif self.direction > 0:\n\t\t\t\tself.pos += 1\n\t\t\t\tif self.pos >= len(self.rows):\n\t\t\t\t\tself.pos = 0\n\t\t\telse:\n\t\t\t\tself.pos -= 1\n\t\t\t\tif self.pos < 0:\n\t\t\t\t\tself.pos = len(self.rows) - 1\n\t\t\trow = self.rows[self.pos]\n\t\telse:\n\t\t\trow = -1\n\t\treturn (True, row)\n\n\tdef Find(self, value, direction, pattern, context, callback):\n\t\tself.value, self.direction, self.pattern, self.last_value, self.last_pattern = (value, direction,pattern, self.value, self.pattern)\n\t\t# Use a thread so the UI is not blocked\n\t\tthread = Thread(self.FindThread)\n\t\tthread.done.connect(lambda row, t=thread, c=callback: self.FindDone(t, c, row), Qt.QueuedConnection)\n\t\tthread.start()\n\n\tdef FindDone(self, thread, callback, row):\n\t\tcallback(row)\n\n# Number of database records to fetch in one go\n\nglb_chunk_sz = 10000\n\n# Background process for SQL data fetcher\n\nclass SQLFetcherProcess():\n\n\tdef __init__(self, dbref, sql, buffer, head, tail, fetch_count, fetching_done, process_target, wait_event, fetched_event, prep):\n\t\t# Need a unique connection name\n\t\tconn_name = \"SQLFetcher\" + str(os.getpid())\n\t\tself.db, dbname = dbref.Open(conn_name)\n\t\tself.sql = sql\n\t\tself.buffer = buffer\n\t\tself.head = head\n\t\tself.tail = tail\n\t\tself.fetch_count = fetch_count\n\t\tself.fetching_done = fetching_done\n\t\tself.process_target = process_target\n\t\tself.wait_event = wait_event\n\t\tself.fetched_event = fetched_event\n\t\tself.prep = prep\n\t\tself.query = QSqlQuery(self.db)\n\t\tself.query_limit = 0 if \"$$last_id$$\" in sql else 2\n\t\tself.last_id = -1\n\t\tself.fetched = 0\n\t\tself.more = True\n\t\tself.local_head = self.head.value\n\t\tself.local_tail = self.tail.value\n\n\tdef Select(self):\n\t\tif self.query_limit:\n\t\t\tif self.query_limit == 1:\n\t\t\t\treturn\n\t\t\tself.query_limit -= 1\n\t\tstmt = self.sql.replace(\"$$last_id$$\", str(self.last_id))\n\t\tQueryExec(self.query, stmt)\n\n\tdef Next(self):\n\t\tif not self.query.next():\n\t\t\tself.Select()\n\t\t\tif not self.query.next():\n\t\t\t\treturn None\n\t\tself.last_id = self.query.value(0)\n\t\treturn self.prep(self.query)\n\n\tdef WaitForTarget(self):\n\t\twhile True:\n\t\t\tself.wait_event.clear()\n\t\t\ttarget = self.process_target.value\n\t\t\tif target > self.fetched or target < 0:\n\t\t\t\tbreak\n\t\t\tself.wait_event.wait()\n\t\treturn target\n\n\tdef HasSpace(self, sz):\n\t\tif self.local_tail <= self.local_head:\n\t\t\tspace = len(self.buffer) - self.local_head\n\t\t\tif space > sz:\n\t\t\t\treturn True\n\t\t\tif space >= glb_nsz:\n\t\t\t\t# Use 0 (or space < glb_nsz) to mean there is no more at the top of the buffer\n\t\t\t\tnd = pickle.dumps(0, pickle.HIGHEST_PROTOCOL)\n\t\t\t\tself.buffer[self.local_head : self.local_head + len(nd)] = nd\n\t\t\tself.local_head = 0\n\t\tif self.local_tail - self.local_head > sz:\n\t\t\treturn True\n\t\treturn False\n\n\tdef WaitForSpace(self, sz):\n\t\tif self.HasSpace(sz):\n\t\t\treturn\n\t\twhile True:\n\t\t\tself.wait_event.clear()\n\t\t\tself.local_tail = self.tail.value\n\t\t\tif self.HasSpace(sz):\n\t\t\t\treturn\n\t\t\tself.wait_event.wait()\n\n\tdef AddToBuffer(self, obj):\n\t\td = pickle.dumps(obj, pickle.HIGHEST_PROTOCOL)\n\t\tn = len(d)\n\t\tnd = pickle.dumps(n, pickle.HIGHEST_PROTOCOL)\n\t\tsz = n + glb_nsz\n\t\tself.WaitForSpace(sz)\n\t\tpos = self.local_head\n\t\tself.buffer[pos : pos + len(nd)] = nd\n\t\tself.buffer[pos + glb_nsz : pos + sz] = d\n\t\tself.local_head += sz\n\n\tdef FetchBatch(self, batch_size):\n\t\tfetched = 0\n\t\twhile batch_size > fetched:\n\t\t\tobj = self.Next()\n\t\t\tif obj is None:\n\t\t\t\tself.more = False\n\t\t\t\tbreak\n\t\t\tself.AddToBuffer(obj)\n\t\t\tfetched += 1\n\t\tif fetched:\n\t\t\tself.fetched += fetched\n\t\t\twith self.fetch_count.get_lock():\n\t\t\t\tself.fetch_count.value += fetched\n\t\t\tself.head.value = self.local_head\n\t\t\tself.fetched_event.set()\n\n\tdef Run(self):\n\t\twhile self.more:\n\t\t\ttarget = self.WaitForTarget()\n\t\t\tif target < 0:\n\t\t\t\tbreak\n\t\t\tbatch_size = min(glb_chunk_sz, target - self.fetched)\n\t\t\tself.FetchBatch(batch_size)\n\t\tself.fetching_done.value = True\n\t\tself.fetched_event.set()\n\ndef SQLFetcherFn(*x):\n\tprocess = SQLFetcherProcess(*x)\n\tprocess.Run()\n\n# SQL data fetcher\n\nclass SQLFetcher(QObject):\n\n\tdone = Signal(object)\n\n\tdef __init__(self, glb, sql, prep, process_data, parent=None):\n\t\tsuper(SQLFetcher, self).__init__(parent)\n\t\tself.process_data = process_data\n\t\tself.more = True\n\t\tself.target = 0\n\t\tself.last_target = 0\n\t\tself.fetched = 0\n\t\tself.buffer_size = 16 * 1024 * 1024\n\t\tself.buffer = Array(c_char, self.buffer_size, lock=False)\n\t\tself.head = Value(c_longlong)\n\t\tself.tail = Value(c_longlong)\n\t\tself.local_tail = 0\n\t\tself.fetch_count = Value(c_longlong)\n\t\tself.fetching_done = Value(c_bool)\n\t\tself.last_count = 0\n\t\tself.process_target = Value(c_longlong)\n\t\tself.wait_event = Event()\n\t\tself.fetched_event = Event()\n\t\tglb.AddInstanceToShutdownOnExit(self)\n\t\tself.process = Process(target=SQLFetcherFn, args=(glb.dbref, sql, self.buffer, self.head, self.tail, self.fetch_count, self.fetching_done, self.process_target, self.wait_event, self.fetched_event, prep))\n\t\tself.process.start()\n\t\tself.thread = Thread(self.Thread)\n\t\tself.thread.done.connect(self.ProcessData, Qt.QueuedConnection)\n\t\tself.thread.start()\n\n\tdef Shutdown(self):\n\t\t# Tell the thread and process to exit\n\t\tself.process_target.value = -1\n\t\tself.wait_event.set()\n\t\tself.more = False\n\t\tself.fetching_done.value = True\n\t\tself.fetched_event.set()\n\n\tdef Thread(self):\n\t\tif not self.more:\n\t\t\treturn True, 0\n\t\twhile True:\n\t\t\tself.fetched_event.clear()\n\t\t\tfetch_count = self.fetch_count.value\n\t\t\tif fetch_count != self.last_count:\n\t\t\t\tbreak\n\t\t\tif self.fetching_done.value:\n\t\t\t\tself.more = False\n\t\t\t\treturn True, 0\n\t\t\tself.fetched_event.wait()\n\t\tcount = fetch_count - self.last_count\n\t\tself.last_count = fetch_count\n\t\tself.fetched += count\n\t\treturn False, count\n\n\tdef Fetch(self, nr):\n\t\tif not self.more:\n\t\t\t# -1 inidcates there are no more\n\t\t\treturn -1\n\t\tresult = self.fetched\n\t\textra = result + nr - self.target\n\t\tif extra > 0:\n\t\t\tself.target += extra\n\t\t\t# process_target < 0 indicates shutting down\n\t\t\tif self.process_target.value >= 0:\n\t\t\t\tself.process_target.value = self.target\n\t\t\tself.wait_event.set()\n\t\treturn result\n\n\tdef RemoveFromBuffer(self):\n\t\tpos = self.local_tail\n\t\tif len(self.buffer) - pos < glb_nsz:\n\t\t\tpos = 0\n\t\tn = pickle.loads(self.buffer[pos : pos + glb_nsz])\n\t\tif n == 0:\n\t\t\tpos = 0\n\t\t\tn = pickle.loads(self.buffer[0 : glb_nsz])\n\t\tpos += glb_nsz\n\t\tobj = pickle.loads(self.buffer[pos : pos + n])\n\t\tself.local_tail = pos + n\n\t\treturn obj\n\n\tdef ProcessData(self, count):\n\t\tfor i in xrange(count):\n\t\t\tobj = self.RemoveFromBuffer()\n\t\t\tself.process_data(obj)\n\t\tself.tail.value = self.local_tail\n\t\tself.wait_event.set()\n\t\tself.done.emit(count)\n\n# Fetch more records bar\n\nclass FetchMoreRecordsBar():\n\n\tdef __init__(self, model, parent):\n\t\tself.model = model\n\n\t\tself.label = QLabel(\"Number of records (x \" + \"{:,}\".format(glb_chunk_sz) + \") to fetch:\")\n\t\tself.label.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n\t\tself.fetch_count = QSpinBox()\n\t\tself.fetch_count.setRange(1, 1000000)\n\t\tself.fetch_count.setValue(10)\n\t\tself.fetch_count.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n\t\tself.fetch = QPushButton(\"Go!\")\n\t\tself.fetch.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\t\tself.fetch.released.connect(self.FetchMoreRecords)\n\n\t\tself.progress = QProgressBar()\n\t\tself.progress.setRange(0, 100)\n\t\tself.progress.hide()\n\n\t\tself.done_label = QLabel(\"All records fetched\")\n\t\tself.done_label.hide()\n\n\t\tself.spacer = QLabel(\"\")\n\n\t\tself.close_button = QToolButton()\n\t\tself.close_button.setIcon(parent.style().standardIcon(QStyle.SP_DockWidgetCloseButton))\n\t\tself.close_button.released.connect(self.Deactivate)\n\n\t\tself.hbox = QHBoxLayout()\n\t\tself.hbox.setContentsMargins(0, 0, 0, 0)\n\n\t\tself.hbox.addWidget(self.label)\n\t\tself.hbox.addWidget(self.fetch_count)\n\t\tself.hbox.addWidget(self.fetch)\n\t\tself.hbox.addWidget(self.spacer)\n\t\tself.hbox.addWidget(self.progress)\n\t\tself.hbox.addWidget(self.done_label)\n\t\tself.hbox.addWidget(self.close_button)\n\n\t\tself.bar = QWidget()\n\t\tself.bar.setLayout(self.hbox)\n\t\tself.bar.show()\n\n\t\tself.in_progress = False\n\t\tself.model.progress.connect(self.Progress)\n\n\t\tself.done = False\n\n\t\tif not model.HasMoreRecords():\n\t\t\tself.Done()\n\n\tdef Widget(self):\n\t\treturn self.bar\n\n\tdef Activate(self):\n\t\tself.bar.show()\n\t\tself.fetch.setFocus()\n\n\tdef Deactivate(self):\n\t\tself.bar.hide()\n\n\tdef Enable(self, enable):\n\t\tself.fetch.setEnabled(enable)\n\t\tself.fetch_count.setEnabled(enable)\n\n\tdef Busy(self):\n\t\tself.Enable(False)\n\t\tself.fetch.hide()\n\t\tself.spacer.hide()\n\t\tself.progress.show()\n\n\tdef Idle(self):\n\t\tself.in_progress = False\n\t\tself.Enable(True)\n\t\tself.progress.hide()\n\t\tself.fetch.show()\n\t\tself.spacer.show()\n\n\tdef Target(self):\n\t\treturn self.fetch_count.value() * glb_chunk_sz\n\n\tdef Done(self):\n\t\tself.done = True\n\t\tself.Idle()\n\t\tself.label.hide()\n\t\tself.fetch_count.hide()\n\t\tself.fetch.hide()\n\t\tself.spacer.hide()\n\t\tself.done_label.show()\n\n\tdef Progress(self, count):\n\t\tif self.in_progress:\n\t\t\tif count:\n\t\t\t\tpercent = ((count - self.start) * 100) / self.Target()\n\t\t\t\tif percent >= 100:\n\t\t\t\t\tself.Idle()\n\t\t\t\telse:\n\t\t\t\t\tself.progress.setValue(percent)\n\t\tif not count:\n\t\t\t# Count value of zero means no more records\n\t\t\tself.Done()\n\n\tdef FetchMoreRecords(self):\n\t\tif self.done:\n\t\t\treturn\n\t\tself.progress.setValue(0)\n\t\tself.Busy()\n\t\tself.in_progress = True\n\t\tself.start = self.model.FetchMoreRecords(self.Target())\n\n# Brance data model level two item\n\nclass BranchLevelTwoItem():\n\n\tdef __init__(self, row, col, text, parent_item):\n\t\tself.row = row\n\t\tself.parent_item = parent_item\n\t\tself.data = [\"\"] * (col + 1)\n\t\tself.data[col] = text\n\t\tself.level = 2\n\n\tdef getParentItem(self):\n\t\treturn self.parent_item\n\n\tdef getRow(self):\n\t\treturn self.row\n\n\tdef childCount(self):\n\t\treturn 0\n\n\tdef hasChildren(self):\n\t\treturn False\n\n\tdef getData(self, column):\n\t\treturn self.data[column]\n\n# Brance data model level one item\n\nclass BranchLevelOneItem():\n\n\tdef __init__(self, glb, row, data, parent_item):\n\t\tself.glb = glb\n\t\tself.row = row\n\t\tself.parent_item = parent_item\n\t\tself.child_count = 0\n\t\tself.child_items = []\n\t\tself.data = data[1:]\n\t\tself.dbid = data[0]\n\t\tself.level = 1\n\t\tself.query_done = False\n\t\tself.br_col = len(self.data) - 1\n\n\tdef getChildItem(self, row):\n\t\treturn self.child_items[row]\n\n\tdef getParentItem(self):\n\t\treturn self.parent_item\n\n\tdef getRow(self):\n\t\treturn self.row\n\n\tdef Select(self):\n\t\tself.query_done = True\n\n\t\tif not self.glb.have_disassembler:\n\t\t\treturn\n\n\t\tquery = QSqlQuery(self.glb.db)\n\n\t\tQueryExec(query, \"SELECT cpu, to_dso_id, to_symbol_id, to_sym_offset, short_name, long_name, build_id, sym_start, to_ip\"\n\t\t\t\t  \" FROM samples\"\n\t\t\t\t  \" INNER JOIN dsos ON samples.to_dso_id = dsos.id\"\n\t\t\t\t  \" INNER JOIN symbols ON samples.to_symbol_id = symbols.id\"\n\t\t\t\t  \" WHERE samples.id = \" + str(self.dbid))\n\t\tif not query.next():\n\t\t\treturn\n\t\tcpu = query.value(0)\n\t\tdso = query.value(1)\n\t\tsym = query.value(2)\n\t\tif dso == 0 or sym == 0:\n\t\t\treturn\n\t\toff = query.value(3)\n\t\tshort_name = query.value(4)\n\t\tlong_name = query.value(5)\n\t\tbuild_id = query.value(6)\n\t\tsym_start = query.value(7)\n\t\tip = query.value(8)\n\n\t\tQueryExec(query, \"SELECT samples.dso_id, symbol_id, sym_offset, sym_start\"\n\t\t\t\t  \" FROM samples\"\n\t\t\t\t  \" INNER JOIN symbols ON samples.symbol_id = symbols.id\"\n\t\t\t\t  \" WHERE samples.id > \" + str(self.dbid) + \" AND cpu = \" + str(cpu) +\n\t\t\t\t  \" ORDER BY samples.id\"\n\t\t\t\t  \" LIMIT 1\")\n\t\tif not query.next():\n\t\t\treturn\n\t\tif query.value(0) != dso:\n\t\t\t# Cannot disassemble from one dso to another\n\t\t\treturn\n\t\tbsym = query.value(1)\n\t\tboff = query.value(2)\n\t\tbsym_start = query.value(3)\n\t\tif bsym == 0:\n\t\t\treturn\n\t\ttot = bsym_start + boff + 1 - sym_start - off\n\t\tif tot <= 0 or tot > 16384:\n\t\t\treturn\n\n\t\tinst = self.glb.disassembler.Instruction()\n\t\tf = self.glb.FileFromNamesAndBuildId(short_name, long_name, build_id)\n\t\tif not f:\n\t\t\treturn\n\t\tmode = 0 if Is64Bit(f) else 1\n\t\tself.glb.disassembler.SetMode(inst, mode)\n\n\t\tbuf_sz = tot + 16\n\t\tbuf = create_string_buffer(tot + 16)\n\t\tf.seek(sym_start + off)\n\t\tbuf.value = f.read(buf_sz)\n\t\tbuf_ptr = addressof(buf)\n\t\ti = 0\n\t\twhile tot > 0:\n\t\t\tcnt, text = self.glb.disassembler.DisassembleOne(inst, buf_ptr, buf_sz, ip)\n\t\t\tif cnt:\n\t\t\t\tbyte_str = tohex(ip).rjust(16)\n\t\t\t\tfor k in xrange(cnt):\n\t\t\t\t\tbyte_str += \" %02x\" % ord(buf[i])\n\t\t\t\t\ti += 1\n\t\t\t\twhile k < 15:\n\t\t\t\t\tbyte_str += \"   \"\n\t\t\t\t\tk += 1\n\t\t\t\tself.child_items.append(BranchLevelTwoItem(0, self.br_col, byte_str + \" \" + text, self))\n\t\t\t\tself.child_count += 1\n\t\t\telse:\n\t\t\t\treturn\n\t\t\tbuf_ptr += cnt\n\t\t\ttot -= cnt\n\t\t\tbuf_sz -= cnt\n\t\t\tip += cnt\n\n\tdef childCount(self):\n\t\tif not self.query_done:\n\t\t\tself.Select()\n\t\t\tif not self.child_count:\n\t\t\t\treturn -1\n\t\treturn self.child_count\n\n\tdef hasChildren(self):\n\t\tif not self.query_done:\n\t\t\treturn True\n\t\treturn self.child_count > 0\n\n\tdef getData(self, column):\n\t\treturn self.data[column]\n\n# Brance data model root item\n\nclass BranchRootItem():\n\n\tdef __init__(self):\n\t\tself.child_count = 0\n\t\tself.child_items = []\n\t\tself.level = 0\n\n\tdef getChildItem(self, row):\n\t\treturn self.child_items[row]\n\n\tdef getParentItem(self):\n\t\treturn None\n\n\tdef getRow(self):\n\t\treturn 0\n\n\tdef childCount(self):\n\t\treturn self.child_count\n\n\tdef hasChildren(self):\n\t\treturn self.child_count > 0\n\n\tdef getData(self, column):\n\t\treturn \"\"\n\n# Calculate instructions per cycle\n\ndef CalcIPC(cyc_cnt, insn_cnt):\n\tif cyc_cnt and insn_cnt:\n\t\tipc = Decimal(float(insn_cnt) / cyc_cnt)\n\t\tipc = str(ipc.quantize(Decimal(\".01\"), rounding=ROUND_HALF_UP))\n\telse:\n\t\tipc = \"0\"\n\treturn ipc\n\n# Branch data preparation\n\ndef BranchDataPrepBr(query, data):\n\tdata.append(tohex(query.value(8)).rjust(16) + \" \" + query.value(9) + offstr(query.value(10)) +\n\t\t\t\" (\" + dsoname(query.value(11)) + \")\" + \" -> \" +\n\t\t\ttohex(query.value(12)) + \" \" + query.value(13) + offstr(query.value(14)) +\n\t\t\t\" (\" + dsoname(query.value(15)) + \")\")\n\ndef BranchDataPrepIPC(query, data):\n\tinsn_cnt = query.value(16)\n\tcyc_cnt = query.value(17)\n\tipc = CalcIPC(cyc_cnt, insn_cnt)\n\tdata.append(insn_cnt)\n\tdata.append(cyc_cnt)\n\tdata.append(ipc)\n\ndef BranchDataPrep(query):\n\tdata = []\n\tfor i in xrange(0, 8):\n\t\tdata.append(query.value(i))\n\tBranchDataPrepBr(query, data)\n\treturn data\n\ndef BranchDataPrepWA(query):\n\tdata = []\n\tdata.append(query.value(0))\n\t# Workaround pyside failing to handle large integers (i.e. time) in python3 by converting to a string\n\tdata.append(\"{:>19}\".format(query.value(1)))\n\tfor i in xrange(2, 8):\n\t\tdata.append(query.value(i))\n\tBranchDataPrepBr(query, data)\n\treturn data\n\ndef BranchDataWithIPCPrep(query):\n\tdata = []\n\tfor i in xrange(0, 8):\n\t\tdata.append(query.value(i))\n\tBranchDataPrepIPC(query, data)\n\tBranchDataPrepBr(query, data)\n\treturn data\n\ndef BranchDataWithIPCPrepWA(query):\n\tdata = []\n\tdata.append(query.value(0))\n\t# Workaround pyside failing to handle large integers (i.e. time) in python3 by converting to a string\n\tdata.append(\"{:>19}\".format(query.value(1)))\n\tfor i in xrange(2, 8):\n\t\tdata.append(query.value(i))\n\tBranchDataPrepIPC(query, data)\n\tBranchDataPrepBr(query, data)\n\treturn data\n\n# Branch data model\n\nclass BranchModel(TreeModel):\n\n\tprogress = Signal(object)\n\n\tdef __init__(self, glb, event_id, where_clause, parent=None):\n\t\tsuper(BranchModel, self).__init__(glb, None, parent)\n\t\tself.event_id = event_id\n\t\tself.more = True\n\t\tself.populated = 0\n\t\tself.have_ipc = IsSelectable(glb.db, \"samples\", columns = \"insn_count, cyc_count\")\n\t\tif self.have_ipc:\n\t\t\tselect_ipc = \", insn_count, cyc_count\"\n\t\t\tprep_fn = BranchDataWithIPCPrep\n\t\t\tprep_wa_fn = BranchDataWithIPCPrepWA\n\t\telse:\n\t\t\tselect_ipc = \"\"\n\t\t\tprep_fn = BranchDataPrep\n\t\t\tprep_wa_fn = BranchDataPrepWA\n\t\tsql = (\"SELECT samples.id, time, cpu, comm, pid, tid, branch_types.name,\"\n\t\t\t\" CASE WHEN in_tx = '0' THEN 'No' ELSE 'Yes' END,\"\n\t\t\t\" ip, symbols.name, sym_offset, dsos.short_name,\"\n\t\t\t\" to_ip, to_symbols.name, to_sym_offset, to_dsos.short_name\"\n\t\t\t+ select_ipc +\n\t\t\t\" FROM samples\"\n\t\t\t\" INNER JOIN comms ON comm_id = comms.id\"\n\t\t\t\" INNER JOIN threads ON thread_id = threads.id\"\n\t\t\t\" INNER JOIN branch_types ON branch_type = branch_types.id\"\n\t\t\t\" INNER JOIN symbols ON symbol_id = symbols.id\"\n\t\t\t\" INNER JOIN symbols to_symbols ON to_symbol_id = to_symbols.id\"\n\t\t\t\" INNER JOIN dsos ON samples.dso_id = dsos.id\"\n\t\t\t\" INNER JOIN dsos AS to_dsos ON samples.to_dso_id = to_dsos.id\"\n\t\t\t\" WHERE samples.id > $$last_id$$\" + where_clause +\n\t\t\t\" AND evsel_id = \" + str(self.event_id) +\n\t\t\t\" ORDER BY samples.id\"\n\t\t\t\" LIMIT \" + str(glb_chunk_sz))\n\t\tif pyside_version_1 and sys.version_info[0] == 3:\n\t\t\tprep = prep_fn\n\t\telse:\n\t\t\tprep = prep_wa_fn\n\t\tself.fetcher = SQLFetcher(glb, sql, prep, self.AddSample)\n\t\tself.fetcher.done.connect(self.Update)\n\t\tself.fetcher.Fetch(glb_chunk_sz)\n\n\tdef GetRoot(self):\n\t\treturn BranchRootItem()\n\n\tdef columnCount(self, parent=None):\n\t\tif self.have_ipc:\n\t\t\treturn 11\n\t\telse:\n\t\t\treturn 8\n\n\tdef columnHeader(self, column):\n\t\tif self.have_ipc:\n\t\t\treturn (\"Time\", \"CPU\", \"Command\", \"PID\", \"TID\", \"Branch Type\", \"In Tx\", \"Insn Cnt\", \"Cyc Cnt\", \"IPC\", \"Branch\")[column]\n\t\telse:\n\t\t\treturn (\"Time\", \"CPU\", \"Command\", \"PID\", \"TID\", \"Branch Type\", \"In Tx\", \"Branch\")[column]\n\n\tdef columnFont(self, column):\n\t\tif self.have_ipc:\n\t\t\tbr_col = 10\n\t\telse:\n\t\t\tbr_col = 7\n\t\tif column != br_col:\n\t\t\treturn None\n\t\treturn QFont(\"Monospace\")\n\n\tdef DisplayData(self, item, index):\n\t\tif item.level == 1:\n\t\t\tself.FetchIfNeeded(item.row)\n\t\treturn item.getData(index.column())\n\n\tdef AddSample(self, data):\n\t\tchild = BranchLevelOneItem(self.glb, self.populated, data, self.root)\n\t\tself.root.child_items.append(child)\n\t\tself.populated += 1\n\n\tdef Update(self, fetched):\n\t\tif not fetched:\n\t\t\tself.more = False\n\t\t\tself.progress.emit(0)\n\t\tchild_count = self.root.child_count\n\t\tcount = self.populated - child_count\n\t\tif count > 0:\n\t\t\tparent = QModelIndex()\n\t\t\tself.beginInsertRows(parent, child_count, child_count + count - 1)\n\t\t\tself.insertRows(child_count, count, parent)\n\t\t\tself.root.child_count += count\n\t\t\tself.endInsertRows()\n\t\t\tself.progress.emit(self.root.child_count)\n\n\tdef FetchMoreRecords(self, count):\n\t\tcurrent = self.root.child_count\n\t\tif self.more:\n\t\t\tself.fetcher.Fetch(count)\n\t\telse:\n\t\t\tself.progress.emit(0)\n\t\treturn current\n\n\tdef HasMoreRecords(self):\n\t\treturn self.more\n\n# Report Variables\n\nclass ReportVars():\n\n\tdef __init__(self, name = \"\", where_clause = \"\", limit = \"\"):\n\t\tself.name = name\n\t\tself.where_clause = where_clause\n\t\tself.limit = limit\n\n\tdef UniqueId(self):\n\t\treturn str(self.where_clause + \";\" + self.limit)\n\n# Branch window\n\nclass BranchWindow(QMdiSubWindow):\n\n\tdef __init__(self, glb, event_id, report_vars, parent=None):\n\t\tsuper(BranchWindow, self).__init__(parent)\n\n\t\tmodel_name = \"Branch Events \" + str(event_id) +  \" \" + report_vars.UniqueId()\n\n\t\tself.model = LookupCreateModel(model_name, lambda: BranchModel(glb, event_id, report_vars.where_clause))\n\n\t\tself.view = QTreeView()\n\t\tself.view.setUniformRowHeights(True)\n\t\tself.view.setSelectionMode(QAbstractItemView.ContiguousSelection)\n\t\tself.view.CopyCellsToClipboard = CopyTreeCellsToClipboard\n\t\tself.view.setModel(self.model)\n\n\t\tself.ResizeColumnsToContents()\n\n\t\tself.context_menu = TreeContextMenu(self.view)\n\n\t\tself.find_bar = FindBar(self, self, True)\n\n\t\tself.finder = ChildDataItemFinder(self.model.root)\n\n\t\tself.fetch_bar = FetchMoreRecordsBar(self.model, self)\n\n\t\tself.vbox = VBox(self.view, self.find_bar.Widget(), self.fetch_bar.Widget())\n\n\t\tself.setWidget(self.vbox.Widget())\n\n\t\tAddSubWindow(glb.mainwindow.mdi_area, self, report_vars.name + \" Branch Events\")\n\n\tdef ResizeColumnToContents(self, column, n):\n\t\t# Using the view's resizeColumnToContents() here is extrememly slow\n\t\t# so implement a crude alternative\n\t\tmm = \"MM\" if column else \"MMMM\"\n\t\tfont = self.view.font()\n\t\tmetrics = QFontMetrics(font)\n\t\tmax = 0\n\t\tfor row in xrange(n):\n\t\t\tval = self.model.root.child_items[row].data[column]\n\t\t\tlen = metrics.width(str(val) + mm)\n\t\t\tmax = len if len > max else max\n\t\tval = self.model.columnHeader(column)\n\t\tlen = metrics.width(str(val) + mm)\n\t\tmax = len if len > max else max\n\t\tself.view.setColumnWidth(column, max)\n\n\tdef ResizeColumnsToContents(self):\n\t\tn = min(self.model.root.child_count, 100)\n\t\tif n < 1:\n\t\t\t# No data yet, so connect a signal to notify when there is\n\t\t\tself.model.rowsInserted.connect(self.UpdateColumnWidths)\n\t\t\treturn\n\t\tcolumns = self.model.columnCount()\n\t\tfor i in xrange(columns):\n\t\t\tself.ResizeColumnToContents(i, n)\n\n\tdef UpdateColumnWidths(self, *x):\n\t\t# This only needs to be done once, so disconnect the signal now\n\t\tself.model.rowsInserted.disconnect(self.UpdateColumnWidths)\n\t\tself.ResizeColumnsToContents()\n\n\tdef Find(self, value, direction, pattern, context):\n\t\tself.view.setFocus()\n\t\tself.find_bar.Busy()\n\t\tself.finder.Find(value, direction, pattern, context, self.FindDone)\n\n\tdef FindDone(self, row):\n\t\tself.find_bar.Idle()\n\t\tif row >= 0:\n\t\t\tself.view.setCurrentIndex(self.model.index(row, 0, QModelIndex()))\n\t\telse:\n\t\t\tself.find_bar.NotFound()\n\n# Line edit data item\n\nclass LineEditDataItem(object):\n\n\tdef __init__(self, glb, label, placeholder_text, parent, id = \"\", default = \"\"):\n\t\tself.glb = glb\n\t\tself.label = label\n\t\tself.placeholder_text = placeholder_text\n\t\tself.parent = parent\n\t\tself.id = id\n\n\t\tself.value = default\n\n\t\tself.widget = QLineEdit(default)\n\t\tself.widget.editingFinished.connect(self.Validate)\n\t\tself.widget.textChanged.connect(self.Invalidate)\n\t\tself.red = False\n\t\tself.error = \"\"\n\t\tself.validated = True\n\n\t\tif placeholder_text:\n\t\t\tself.widget.setPlaceholderText(placeholder_text)\n\n\tdef TurnTextRed(self):\n\t\tif not self.red:\n\t\t\tpalette = QPalette()\n\t\t\tpalette.setColor(QPalette.Text,Qt.red)\n\t\t\tself.widget.setPalette(palette)\n\t\t\tself.red = True\n\n\tdef TurnTextNormal(self):\n\t\tif self.red:\n\t\t\tpalette = QPalette()\n\t\t\tself.widget.setPalette(palette)\n\t\t\tself.red = False\n\n\tdef InvalidValue(self, value):\n\t\tself.value = \"\"\n\t\tself.TurnTextRed()\n\t\tself.error = self.label + \" invalid value '\" + value + \"'\"\n\t\tself.parent.ShowMessage(self.error)\n\n\tdef Invalidate(self):\n\t\tself.validated = False\n\n\tdef DoValidate(self, input_string):\n\t\tself.value = input_string.strip()\n\n\tdef Validate(self):\n\t\tself.validated = True\n\t\tself.error = \"\"\n\t\tself.TurnTextNormal()\n\t\tself.parent.ClearMessage()\n\t\tinput_string = self.widget.text()\n\t\tif not len(input_string.strip()):\n\t\t\tself.value = \"\"\n\t\t\treturn\n\t\tself.DoValidate(input_string)\n\n\tdef IsValid(self):\n\t\tif not self.validated:\n\t\t\tself.Validate()\n\t\tif len(self.error):\n\t\t\tself.parent.ShowMessage(self.error)\n\t\t\treturn False\n\t\treturn True\n\n\tdef IsNumber(self, value):\n\t\ttry:\n\t\t\tx = int(value)\n\t\texcept:\n\t\t\tx = 0\n\t\treturn str(x) == value\n\n# Non-negative integer ranges dialog data item\n\nclass NonNegativeIntegerRangesDataItem(LineEditDataItem):\n\n\tdef __init__(self, glb, label, placeholder_text, column_name, parent):\n\t\tsuper(NonNegativeIntegerRangesDataItem, self).__init__(glb, label, placeholder_text, parent)\n\n\t\tself.column_name = column_name\n\n\tdef DoValidate(self, input_string):\n\t\tsingles = []\n\t\tranges = []\n\t\tfor value in [x.strip() for x in input_string.split(\",\")]:\n\t\t\tif \"-\" in value:\n\t\t\t\tvrange = value.split(\"-\")\n\t\t\t\tif len(vrange) != 2 or not self.IsNumber(vrange[0]) or not self.IsNumber(vrange[1]):\n\t\t\t\t\treturn self.InvalidValue(value)\n\t\t\t\tranges.append(vrange)\n\t\t\telse:\n\t\t\t\tif not self.IsNumber(value):\n\t\t\t\t\treturn self.InvalidValue(value)\n\t\t\t\tsingles.append(value)\n\t\tranges = [(\"(\" + self.column_name + \" >= \" + r[0] + \" AND \" + self.column_name + \" <= \" + r[1] + \")\") for r in ranges]\n\t\tif len(singles):\n\t\t\tranges.append(self.column_name + \" IN (\" + \",\".join(singles) + \")\")\n\t\tself.value = \" OR \".join(ranges)\n\n# Positive integer dialog data item\n\nclass PositiveIntegerDataItem(LineEditDataItem):\n\n\tdef __init__(self, glb, label, placeholder_text, parent, id = \"\", default = \"\"):\n\t\tsuper(PositiveIntegerDataItem, self).__init__(glb, label, placeholder_text, parent, id, default)\n\n\tdef DoValidate(self, input_string):\n\t\tif not self.IsNumber(input_string.strip()):\n\t\t\treturn self.InvalidValue(input_string)\n\t\tvalue = int(input_string.strip())\n\t\tif value <= 0:\n\t\t\treturn self.InvalidValue(input_string)\n\t\tself.value = str(value)\n\n# Dialog data item converted and validated using a SQL table\n\nclass SQLTableDataItem(LineEditDataItem):\n\n\tdef __init__(self, glb, label, placeholder_text, table_name, match_column, column_name1, column_name2, parent):\n\t\tsuper(SQLTableDataItem, self).__init__(glb, label, placeholder_text, parent)\n\n\t\tself.table_name = table_name\n\t\tself.match_column = match_column\n\t\tself.column_name1 = column_name1\n\t\tself.column_name2 = column_name2\n\n\tdef ValueToIds(self, value):\n\t\tids = []\n\t\tquery = QSqlQuery(self.glb.db)\n\t\tstmt = \"SELECT id FROM \" + self.table_name + \" WHERE \" + self.match_column + \" = '\" + value + \"'\"\n\t\tret = query.exec_(stmt)\n\t\tif ret:\n\t\t\twhile query.next():\n\t\t\t\tids.append(str(query.value(0)))\n\t\treturn ids\n\n\tdef DoValidate(self, input_string):\n\t\tall_ids = []\n\t\tfor value in [x.strip() for x in input_string.split(\",\")]:\n\t\t\tids = self.ValueToIds(value)\n\t\t\tif len(ids):\n\t\t\t\tall_ids.extend(ids)\n\t\t\telse:\n\t\t\t\treturn self.InvalidValue(value)\n\t\tself.value = self.column_name1 + \" IN (\" + \",\".join(all_ids) + \")\"\n\t\tif self.column_name2:\n\t\t\tself.value = \"( \" + self.value + \" OR \" + self.column_name2 + \" IN (\" + \",\".join(all_ids) + \") )\"\n\n# Sample time ranges dialog data item converted and validated using 'samples' SQL table\n\nclass SampleTimeRangesDataItem(LineEditDataItem):\n\n\tdef __init__(self, glb, label, placeholder_text, column_name, parent):\n\t\tself.column_name = column_name\n\n\t\tself.last_id = 0\n\t\tself.first_time = 0\n\t\tself.last_time = 2 ** 64\n\n\t\tquery = QSqlQuery(glb.db)\n\t\tQueryExec(query, \"SELECT id, time FROM samples ORDER BY id DESC LIMIT 1\")\n\t\tif query.next():\n\t\t\tself.last_id = int(query.value(0))\n\t\tself.first_time = int(glb.HostStartTime())\n\t\tself.last_time = int(glb.HostFinishTime())\n\t\tif placeholder_text:\n\t\t\tplaceholder_text += \", between \" + str(self.first_time) + \" and \" + str(self.last_time)\n\n\t\tsuper(SampleTimeRangesDataItem, self).__init__(glb, label, placeholder_text, parent)\n\n\tdef IdBetween(self, query, lower_id, higher_id, order):\n\t\tQueryExec(query, \"SELECT id FROM samples WHERE id > \" + str(lower_id) + \" AND id < \" + str(higher_id) + \" ORDER BY id \" + order + \" LIMIT 1\")\n\t\tif query.next():\n\t\t\treturn True, int(query.value(0))\n\t\telse:\n\t\t\treturn False, 0\n\n\tdef BinarySearchTime(self, lower_id, higher_id, target_time, get_floor):\n\t\tquery = QSqlQuery(self.glb.db)\n\t\twhile True:\n\t\t\tnext_id = int((lower_id + higher_id) / 2)\n\t\t\tQueryExec(query, \"SELECT time FROM samples WHERE id = \" + str(next_id))\n\t\t\tif not query.next():\n\t\t\t\tok, dbid = self.IdBetween(query, lower_id, next_id, \"DESC\")\n\t\t\t\tif not ok:\n\t\t\t\t\tok, dbid = self.IdBetween(query, next_id, higher_id, \"\")\n\t\t\t\t\tif not ok:\n\t\t\t\t\t\treturn str(higher_id)\n\t\t\t\tnext_id = dbid\n\t\t\t\tQueryExec(query, \"SELECT time FROM samples WHERE id = \" + str(next_id))\n\t\t\tnext_time = int(query.value(0))\n\t\t\tif get_floor:\n\t\t\t\tif target_time > next_time:\n\t\t\t\t\tlower_id = next_id\n\t\t\t\telse:\n\t\t\t\t\thigher_id = next_id\n\t\t\t\tif higher_id <= lower_id + 1:\n\t\t\t\t\treturn str(higher_id)\n\t\t\telse:\n\t\t\t\tif target_time >= next_time:\n\t\t\t\t\tlower_id = next_id\n\t\t\t\telse:\n\t\t\t\t\thigher_id = next_id\n\t\t\t\tif higher_id <= lower_id + 1:\n\t\t\t\t\treturn str(lower_id)\n\n\tdef ConvertRelativeTime(self, val):\n\t\tmult = 1\n\t\tsuffix = val[-2:]\n\t\tif suffix == \"ms\":\n\t\t\tmult = 1000000\n\t\telif suffix == \"us\":\n\t\t\tmult = 1000\n\t\telif suffix == \"ns\":\n\t\t\tmult = 1\n\t\telse:\n\t\t\treturn val\n\t\tval = val[:-2].strip()\n\t\tif not self.IsNumber(val):\n\t\t\treturn val\n\t\tval = int(val) * mult\n\t\tif val >= 0:\n\t\t\tval += self.first_time\n\t\telse:\n\t\t\tval += self.last_time\n\t\treturn str(val)\n\n\tdef ConvertTimeRange(self, vrange):\n\t\tif vrange[0] == \"\":\n\t\t\tvrange[0] = str(self.first_time)\n\t\tif vrange[1] == \"\":\n\t\t\tvrange[1] = str(self.last_time)\n\t\tvrange[0] = self.ConvertRelativeTime(vrange[0])\n\t\tvrange[1] = self.ConvertRelativeTime(vrange[1])\n\t\tif not self.IsNumber(vrange[0]) or not self.IsNumber(vrange[1]):\n\t\t\treturn False\n\t\tbeg_range = max(int(vrange[0]), self.first_time)\n\t\tend_range = min(int(vrange[1]), self.last_time)\n\t\tif beg_range > self.last_time or end_range < self.first_time:\n\t\t\treturn False\n\t\tvrange[0] = self.BinarySearchTime(0, self.last_id, beg_range, True)\n\t\tvrange[1] = self.BinarySearchTime(1, self.last_id + 1, end_range, False)\n\t\treturn True\n\n\tdef AddTimeRange(self, value, ranges):\n\t\tn = value.count(\"-\")\n\t\tif n == 1:\n\t\t\tpass\n\t\telif n == 2:\n\t\t\tif value.split(\"-\")[1].strip() == \"\":\n\t\t\t\tn = 1\n\t\telif n == 3:\n\t\t\tn = 2\n\t\telse:\n\t\t\treturn False\n\t\tpos = findnth(value, \"-\", n)\n\t\tvrange = [value[:pos].strip() ,value[pos+1:].strip()]\n\t\tif self.ConvertTimeRange(vrange):\n\t\t\tranges.append(vrange)\n\t\t\treturn True\n\t\treturn False\n\n\tdef DoValidate(self, input_string):\n\t\tranges = []\n\t\tfor value in [x.strip() for x in input_string.split(\",\")]:\n\t\t\tif not self.AddTimeRange(value, ranges):\n\t\t\t\treturn self.InvalidValue(value)\n\t\tranges = [(\"(\" + self.column_name + \" >= \" + r[0] + \" AND \" + self.column_name + \" <= \" + r[1] + \")\") for r in ranges]\n\t\tself.value = \" OR \".join(ranges)\n\n# Report Dialog Base\n\nclass ReportDialogBase(QDialog):\n\n\tdef __init__(self, glb, title, items, partial, parent=None):\n\t\tsuper(ReportDialogBase, self).__init__(parent)\n\n\t\tself.glb = glb\n\n\t\tself.report_vars = ReportVars()\n\n\t\tself.setWindowTitle(title)\n\t\tself.setMinimumWidth(600)\n\n\t\tself.data_items = [x(glb, self) for x in items]\n\n\t\tself.partial = partial\n\n\t\tself.grid = QGridLayout()\n\n\t\tfor row in xrange(len(self.data_items)):\n\t\t\tself.grid.addWidget(QLabel(self.data_items[row].label), row, 0)\n\t\t\tself.grid.addWidget(self.data_items[row].widget, row, 1)\n\n\t\tself.status = QLabel()\n\n\t\tself.ok_button = QPushButton(\"Ok\", self)\n\t\tself.ok_button.setDefault(True)\n\t\tself.ok_button.released.connect(self.Ok)\n\t\tself.ok_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n\t\tself.cancel_button = QPushButton(\"Cancel\", self)\n\t\tself.cancel_button.released.connect(self.reject)\n\t\tself.cancel_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n\t\tself.hbox = QHBoxLayout()\n\t\t#self.hbox.addStretch()\n\t\tself.hbox.addWidget(self.status)\n\t\tself.hbox.addWidget(self.ok_button)\n\t\tself.hbox.addWidget(self.cancel_button)\n\n\t\tself.vbox = QVBoxLayout()\n\t\tself.vbox.addLayout(self.grid)\n\t\tself.vbox.addLayout(self.hbox)\n\n\t\tself.setLayout(self.vbox)\n\n\tdef Ok(self):\n\t\tvars = self.report_vars\n\t\tfor d in self.data_items:\n\t\t\tif d.id == \"REPORTNAME\":\n\t\t\t\tvars.name = d.value\n\t\tif not vars.name:\n\t\t\tself.ShowMessage(\"Report name is required\")\n\t\t\treturn\n\t\tfor d in self.data_items:\n\t\t\tif not d.IsValid():\n\t\t\t\treturn\n\t\tfor d in self.data_items[1:]:\n\t\t\tif d.id == \"LIMIT\":\n\t\t\t\tvars.limit = d.value\n\t\t\telif len(d.value):\n\t\t\t\tif len(vars.where_clause):\n\t\t\t\t\tvars.where_clause += \" AND \"\n\t\t\t\tvars.where_clause += d.value\n\t\tif len(vars.where_clause):\n\t\t\tif self.partial:\n\t\t\t\tvars.where_clause = \" AND ( \" + vars.where_clause + \" ) \"\n\t\t\telse:\n\t\t\t\tvars.where_clause = \" WHERE \" + vars.where_clause + \" \"\n\t\tself.accept()\n\n\tdef ShowMessage(self, msg):\n\t\tself.status.setText(\"<font color=#FF0000>\" + msg)\n\n\tdef ClearMessage(self):\n\t\tself.status.setText(\"\")\n\n# Selected branch report creation dialog\n\nclass SelectedBranchDialog(ReportDialogBase):\n\n\tdef __init__(self, glb, parent=None):\n\t\ttitle = \"Selected Branches\"\n\t\titems = (lambda g, p: LineEditDataItem(g, \"Report name:\", \"Enter a name to appear in the window title bar\", p, \"REPORTNAME\"),\n\t\t\t lambda g, p: SampleTimeRangesDataItem(g, \"Time ranges:\", \"Enter time ranges\", \"samples.id\", p),\n\t\t\t lambda g, p: NonNegativeIntegerRangesDataItem(g, \"CPUs:\", \"Enter CPUs or ranges e.g. 0,5-6\", \"cpu\", p),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"Commands:\", \"Only branches with these commands will be included\", \"comms\", \"comm\", \"comm_id\", \"\", p),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"PIDs:\", \"Only branches with these process IDs will be included\", \"threads\", \"pid\", \"thread_id\", \"\", p),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"TIDs:\", \"Only branches with these thread IDs will be included\", \"threads\", \"tid\", \"thread_id\", \"\", p),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"DSOs:\", \"Only branches with these DSOs will be included\", \"dsos\", \"short_name\", \"samples.dso_id\", \"to_dso_id\", p),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"Symbols:\", \"Only branches with these symbols will be included\", \"symbols\", \"name\", \"symbol_id\", \"to_symbol_id\", p),\n\t\t\t lambda g, p: LineEditDataItem(g, \"Raw SQL clause: \", \"Enter a raw SQL WHERE clause\", p))\n\t\tsuper(SelectedBranchDialog, self).__init__(glb, title, items, True, parent)\n\n# Event list\n\ndef GetEventList(db):\n\tevents = []\n\tquery = QSqlQuery(db)\n\tQueryExec(query, \"SELECT name FROM selected_events WHERE id > 0 ORDER BY id\")\n\twhile query.next():\n\t\tevents.append(query.value(0))\n\treturn events\n\n# Is a table selectable\n\ndef IsSelectable(db, table, sql = \"\", columns = \"*\"):\n\tquery = QSqlQuery(db)\n\ttry:\n\t\tQueryExec(query, \"SELECT \" + columns + \" FROM \" + table + \" \" + sql + \" LIMIT 1\")\n\texcept:\n\t\treturn False\n\treturn True\n\n# SQL table data model item\n\nclass SQLTableItem():\n\n\tdef __init__(self, row, data):\n\t\tself.row = row\n\t\tself.data = data\n\n\tdef getData(self, column):\n\t\treturn self.data[column]\n\n# SQL table data model\n\nclass SQLTableModel(TableModel):\n\n\tprogress = Signal(object)\n\n\tdef __init__(self, glb, sql, column_headers, parent=None):\n\t\tsuper(SQLTableModel, self).__init__(parent)\n\t\tself.glb = glb\n\t\tself.more = True\n\t\tself.populated = 0\n\t\tself.column_headers = column_headers\n\t\tself.fetcher = SQLFetcher(glb, sql, lambda x, y=len(column_headers): self.SQLTableDataPrep(x, y), self.AddSample)\n\t\tself.fetcher.done.connect(self.Update)\n\t\tself.fetcher.Fetch(glb_chunk_sz)\n\n\tdef DisplayData(self, item, index):\n\t\tself.FetchIfNeeded(item.row)\n\t\treturn item.getData(index.column())\n\n\tdef AddSample(self, data):\n\t\tchild = SQLTableItem(self.populated, data)\n\t\tself.child_items.append(child)\n\t\tself.populated += 1\n\n\tdef Update(self, fetched):\n\t\tif not fetched:\n\t\t\tself.more = False\n\t\t\tself.progress.emit(0)\n\t\tchild_count = self.child_count\n\t\tcount = self.populated - child_count\n\t\tif count > 0:\n\t\t\tparent = QModelIndex()\n\t\t\tself.beginInsertRows(parent, child_count, child_count + count - 1)\n\t\t\tself.insertRows(child_count, count, parent)\n\t\t\tself.child_count += count\n\t\t\tself.endInsertRows()\n\t\t\tself.progress.emit(self.child_count)\n\n\tdef FetchMoreRecords(self, count):\n\t\tcurrent = self.child_count\n\t\tif self.more:\n\t\t\tself.fetcher.Fetch(count)\n\t\telse:\n\t\t\tself.progress.emit(0)\n\t\treturn current\n\n\tdef HasMoreRecords(self):\n\t\treturn self.more\n\n\tdef columnCount(self, parent=None):\n\t\treturn len(self.column_headers)\n\n\tdef columnHeader(self, column):\n\t\treturn self.column_headers[column]\n\n\tdef SQLTableDataPrep(self, query, count):\n\t\tdata = []\n\t\tfor i in xrange(count):\n\t\t\tdata.append(query.value(i))\n\t\treturn data\n\n# SQL automatic table data model\n\nclass SQLAutoTableModel(SQLTableModel):\n\n\tdef __init__(self, glb, table_name, parent=None):\n\t\tsql = \"SELECT * FROM \" + table_name + \" WHERE id > $$last_id$$ ORDER BY id LIMIT \" + str(glb_chunk_sz)\n\t\tif table_name == \"comm_threads_view\":\n\t\t\t# For now, comm_threads_view has no id column\n\t\t\tsql = \"SELECT * FROM \" + table_name + \" WHERE comm_id > $$last_id$$ ORDER BY comm_id LIMIT \" + str(glb_chunk_sz)\n\t\tcolumn_headers = []\n\t\tquery = QSqlQuery(glb.db)\n\t\tif glb.dbref.is_sqlite3:\n\t\t\tQueryExec(query, \"PRAGMA table_info(\" + table_name + \")\")\n\t\t\twhile query.next():\n\t\t\t\tcolumn_headers.append(query.value(1))\n\t\t\tif table_name == \"sqlite_master\":\n\t\t\t\tsql = \"SELECT * FROM \" + table_name\n\t\telse:\n\t\t\tif table_name[:19] == \"information_schema.\":\n\t\t\t\tsql = \"SELECT * FROM \" + table_name\n\t\t\t\tselect_table_name = table_name[19:]\n\t\t\t\tschema = \"information_schema\"\n\t\t\telse:\n\t\t\t\tselect_table_name = table_name\n\t\t\t\tschema = \"public\"\n\t\t\tQueryExec(query, \"SELECT column_name FROM information_schema.columns WHERE table_schema = '\" + schema + \"' and table_name = '\" + select_table_name + \"'\")\n\t\t\twhile query.next():\n\t\t\t\tcolumn_headers.append(query.value(0))\n\t\tif pyside_version_1 and sys.version_info[0] == 3:\n\t\t\tif table_name == \"samples_view\":\n\t\t\t\tself.SQLTableDataPrep = self.samples_view_DataPrep\n\t\t\tif table_name == \"samples\":\n\t\t\t\tself.SQLTableDataPrep = self.samples_DataPrep\n\t\tsuper(SQLAutoTableModel, self).__init__(glb, sql, column_headers, parent)\n\n\tdef samples_view_DataPrep(self, query, count):\n\t\tdata = []\n\t\tdata.append(query.value(0))\n\t\t# Workaround pyside failing to handle large integers (i.e. time) in python3 by converting to a string\n\t\tdata.append(\"{:>19}\".format(query.value(1)))\n\t\tfor i in xrange(2, count):\n\t\t\tdata.append(query.value(i))\n\t\treturn data\n\n\tdef samples_DataPrep(self, query, count):\n\t\tdata = []\n\t\tfor i in xrange(9):\n\t\t\tdata.append(query.value(i))\n\t\t# Workaround pyside failing to handle large integers (i.e. time) in python3 by converting to a string\n\t\tdata.append(\"{:>19}\".format(query.value(9)))\n\t\tfor i in xrange(10, count):\n\t\t\tdata.append(query.value(i))\n\t\treturn data\n\n# Base class for custom ResizeColumnsToContents\n\nclass ResizeColumnsToContentsBase(QObject):\n\n\tdef __init__(self, parent=None):\n\t\tsuper(ResizeColumnsToContentsBase, self).__init__(parent)\n\n\tdef ResizeColumnToContents(self, column, n):\n\t\t# Using the view's resizeColumnToContents() here is extrememly slow\n\t\t# so implement a crude alternative\n\t\tfont = self.view.font()\n\t\tmetrics = QFontMetrics(font)\n\t\tmax = 0\n\t\tfor row in xrange(n):\n\t\t\tval = self.data_model.child_items[row].data[column]\n\t\t\tlen = metrics.width(str(val) + \"MM\")\n\t\t\tmax = len if len > max else max\n\t\tval = self.data_model.columnHeader(column)\n\t\tlen = metrics.width(str(val) + \"MM\")\n\t\tmax = len if len > max else max\n\t\tself.view.setColumnWidth(column, max)\n\n\tdef ResizeColumnsToContents(self):\n\t\tn = min(self.data_model.child_count, 100)\n\t\tif n < 1:\n\t\t\t# No data yet, so connect a signal to notify when there is\n\t\t\tself.data_model.rowsInserted.connect(self.UpdateColumnWidths)\n\t\t\treturn\n\t\tcolumns = self.data_model.columnCount()\n\t\tfor i in xrange(columns):\n\t\t\tself.ResizeColumnToContents(i, n)\n\n\tdef UpdateColumnWidths(self, *x):\n\t\t# This only needs to be done once, so disconnect the signal now\n\t\tself.data_model.rowsInserted.disconnect(self.UpdateColumnWidths)\n\t\tself.ResizeColumnsToContents()\n\n# Convert value to CSV\n\ndef ToCSValue(val):\n\tif '\"' in val:\n\t\tval = val.replace('\"', '\"\"')\n\tif \",\" in val or '\"' in val:\n\t\tval = '\"' + val + '\"'\n\treturn val\n\n# Key to sort table model indexes by row / column, assuming fewer than 1000 columns\n\nglb_max_cols = 1000\n\ndef RowColumnKey(a):\n\treturn a.row() * glb_max_cols + a.column()\n\n# Copy selected table cells to clipboard\n\ndef CopyTableCellsToClipboard(view, as_csv=False, with_hdr=False):\n\tindexes = sorted(view.selectedIndexes(), key=RowColumnKey)\n\tidx_cnt = len(indexes)\n\tif not idx_cnt:\n\t\treturn\n\tif idx_cnt == 1:\n\t\twith_hdr=False\n\tmin_row = indexes[0].row()\n\tmax_row = indexes[0].row()\n\tmin_col = indexes[0].column()\n\tmax_col = indexes[0].column()\n\tfor i in indexes:\n\t\tmin_row = min(min_row, i.row())\n\t\tmax_row = max(max_row, i.row())\n\t\tmin_col = min(min_col, i.column())\n\t\tmax_col = max(max_col, i.column())\n\tif max_col > glb_max_cols:\n\t\traise RuntimeError(\"glb_max_cols is too low\")\n\tmax_width = [0] * (1 + max_col - min_col)\n\tfor i in indexes:\n\t\tc = i.column() - min_col\n\t\tmax_width[c] = max(max_width[c], len(str(i.data())))\n\ttext = \"\"\n\tpad = \"\"\n\tsep = \"\"\n\tif with_hdr:\n\t\tmodel = indexes[0].model()\n\t\tfor col in range(min_col, max_col + 1):\n\t\t\tval = model.headerData(col, Qt.Horizontal, Qt.DisplayRole)\n\t\t\tif as_csv:\n\t\t\t\ttext += sep + ToCSValue(val)\n\t\t\t\tsep = \",\"\n\t\t\telse:\n\t\t\t\tc = col - min_col\n\t\t\t\tmax_width[c] = max(max_width[c], len(val))\n\t\t\t\twidth = max_width[c]\n\t\t\t\talign = model.headerData(col, Qt.Horizontal, Qt.TextAlignmentRole)\n\t\t\t\tif align & Qt.AlignRight:\n\t\t\t\t\tval = val.rjust(width)\n\t\t\t\ttext += pad + sep + val\n\t\t\t\tpad = \" \" * (width - len(val))\n\t\t\t\tsep = \"  \"\n\t\ttext += \"\\n\"\n\t\tpad = \"\"\n\t\tsep = \"\"\n\tlast_row = min_row\n\tfor i in indexes:\n\t\tif i.row() > last_row:\n\t\t\tlast_row = i.row()\n\t\t\ttext += \"\\n\"\n\t\t\tpad = \"\"\n\t\t\tsep = \"\"\n\t\tif as_csv:\n\t\t\ttext += sep + ToCSValue(str(i.data()))\n\t\t\tsep = \",\"\n\t\telse:\n\t\t\twidth = max_width[i.column() - min_col]\n\t\t\tif i.data(Qt.TextAlignmentRole) & Qt.AlignRight:\n\t\t\t\tval = str(i.data()).rjust(width)\n\t\t\telse:\n\t\t\t\tval = str(i.data())\n\t\t\ttext += pad + sep + val\n\t\t\tpad = \" \" * (width - len(val))\n\t\t\tsep = \"  \"\n\tQApplication.clipboard().setText(text)\n\ndef CopyTreeCellsToClipboard(view, as_csv=False, with_hdr=False):\n\tindexes = view.selectedIndexes()\n\tif not len(indexes):\n\t\treturn\n\n\tselection = view.selectionModel()\n\n\tfirst = None\n\tfor i in indexes:\n\t\tabove = view.indexAbove(i)\n\t\tif not selection.isSelected(above):\n\t\t\tfirst = i\n\t\t\tbreak\n\n\tif first is None:\n\t\traise RuntimeError(\"CopyTreeCellsToClipboard internal error\")\n\n\tmodel = first.model()\n\trow_cnt = 0\n\tcol_cnt = model.columnCount(first)\n\tmax_width = [0] * col_cnt\n\n\tindent_sz = 2\n\tindent_str = \" \" * indent_sz\n\n\texpanded_mark_sz = 2\n\tif sys.version_info[0] == 3:\n\t\texpanded_mark = \"\\u25BC \"\n\t\tnot_expanded_mark = \"\\u25B6 \"\n\telse:\n\t\texpanded_mark = unicode(chr(0xE2) + chr(0x96) + chr(0xBC) + \" \", \"utf-8\")\n\t\tnot_expanded_mark =  unicode(chr(0xE2) + chr(0x96) + chr(0xB6) + \" \", \"utf-8\")\n\tleaf_mark = \"  \"\n\n\tif not as_csv:\n\t\tpos = first\n\t\twhile True:\n\t\t\trow_cnt += 1\n\t\t\trow = pos.row()\n\t\t\tfor c in range(col_cnt):\n\t\t\t\ti = pos.sibling(row, c)\n\t\t\t\tif c:\n\t\t\t\t\tn = len(str(i.data()))\n\t\t\t\telse:\n\t\t\t\t\tn = len(str(i.data()).strip())\n\t\t\t\t\tn += (i.internalPointer().level - 1) * indent_sz\n\t\t\t\t\tn += expanded_mark_sz\n\t\t\t\tmax_width[c] = max(max_width[c], n)\n\t\t\tpos = view.indexBelow(pos)\n\t\t\tif not selection.isSelected(pos):\n\t\t\t\tbreak\n\n\ttext = \"\"\n\tpad = \"\"\n\tsep = \"\"\n\tif with_hdr:\n\t\tfor c in range(col_cnt):\n\t\t\tval = model.headerData(c, Qt.Horizontal, Qt.DisplayRole).strip()\n\t\t\tif as_csv:\n\t\t\t\ttext += sep + ToCSValue(val)\n\t\t\t\tsep = \",\"\n\t\t\telse:\n\t\t\t\tmax_width[c] = max(max_width[c], len(val))\n\t\t\t\twidth = max_width[c]\n\t\t\t\talign = model.headerData(c, Qt.Horizontal, Qt.TextAlignmentRole)\n\t\t\t\tif align & Qt.AlignRight:\n\t\t\t\t\tval = val.rjust(width)\n\t\t\t\ttext += pad + sep + val\n\t\t\t\tpad = \" \" * (width - len(val))\n\t\t\t\tsep = \"   \"\n\t\ttext += \"\\n\"\n\t\tpad = \"\"\n\t\tsep = \"\"\n\n\tpos = first\n\twhile True:\n\t\trow = pos.row()\n\t\tfor c in range(col_cnt):\n\t\t\ti = pos.sibling(row, c)\n\t\t\tval = str(i.data())\n\t\t\tif not c:\n\t\t\t\tif model.hasChildren(i):\n\t\t\t\t\tif view.isExpanded(i):\n\t\t\t\t\t\tmark = expanded_mark\n\t\t\t\t\telse:\n\t\t\t\t\t\tmark = not_expanded_mark\n\t\t\t\telse:\n\t\t\t\t\tmark = leaf_mark\n\t\t\t\tval = indent_str * (i.internalPointer().level - 1) + mark + val.strip()\n\t\t\tif as_csv:\n\t\t\t\ttext += sep + ToCSValue(val)\n\t\t\t\tsep = \",\"\n\t\t\telse:\n\t\t\t\twidth = max_width[c]\n\t\t\t\tif c and i.data(Qt.TextAlignmentRole) & Qt.AlignRight:\n\t\t\t\t\tval = val.rjust(width)\n\t\t\t\ttext += pad + sep + val\n\t\t\t\tpad = \" \" * (width - len(val))\n\t\t\t\tsep = \"   \"\n\t\tpos = view.indexBelow(pos)\n\t\tif not selection.isSelected(pos):\n\t\t\tbreak\n\t\ttext = text.rstrip() + \"\\n\"\n\t\tpad = \"\"\n\t\tsep = \"\"\n\n\tQApplication.clipboard().setText(text)\n\ndef CopyCellsToClipboard(view, as_csv=False, with_hdr=False):\n\tview.CopyCellsToClipboard(view, as_csv, with_hdr)\n\ndef CopyCellsToClipboardHdr(view):\n\tCopyCellsToClipboard(view, False, True)\n\ndef CopyCellsToClipboardCSV(view):\n\tCopyCellsToClipboard(view, True, True)\n\n# Context menu\n\nclass ContextMenu(object):\n\n\tdef __init__(self, view):\n\t\tself.view = view\n\t\tself.view.setContextMenuPolicy(Qt.CustomContextMenu)\n\t\tself.view.customContextMenuRequested.connect(self.ShowContextMenu)\n\n\tdef ShowContextMenu(self, pos):\n\t\tmenu = QMenu(self.view)\n\t\tself.AddActions(menu)\n\t\tmenu.exec_(self.view.mapToGlobal(pos))\n\n\tdef AddCopy(self, menu):\n\t\tmenu.addAction(CreateAction(\"&Copy selection\", \"Copy to clipboard\", lambda: CopyCellsToClipboardHdr(self.view), self.view))\n\t\tmenu.addAction(CreateAction(\"Copy selection as CS&V\", \"Copy to clipboard as CSV\", lambda: CopyCellsToClipboardCSV(self.view), self.view))\n\n\tdef AddActions(self, menu):\n\t\tself.AddCopy(menu)\n\nclass TreeContextMenu(ContextMenu):\n\n\tdef __init__(self, view):\n\t\tsuper(TreeContextMenu, self).__init__(view)\n\n\tdef AddActions(self, menu):\n\t\ti = self.view.currentIndex()\n\t\ttext = str(i.data()).strip()\n\t\tif len(text):\n\t\t\tmenu.addAction(CreateAction('Copy \"' + text + '\"', \"Copy to clipboard\", lambda: QApplication.clipboard().setText(text), self.view))\n\t\tself.AddCopy(menu)\n\n# Table window\n\nclass TableWindow(QMdiSubWindow, ResizeColumnsToContentsBase):\n\n\tdef __init__(self, glb, table_name, parent=None):\n\t\tsuper(TableWindow, self).__init__(parent)\n\n\t\tself.data_model = LookupCreateModel(table_name + \" Table\", lambda: SQLAutoTableModel(glb, table_name))\n\n\t\tself.model = QSortFilterProxyModel()\n\t\tself.model.setSourceModel(self.data_model)\n\n\t\tself.view = QTableView()\n\t\tself.view.setModel(self.model)\n\t\tself.view.setEditTriggers(QAbstractItemView.NoEditTriggers)\n\t\tself.view.verticalHeader().setVisible(False)\n\t\tself.view.sortByColumn(-1, Qt.AscendingOrder)\n\t\tself.view.setSortingEnabled(True)\n\t\tself.view.setSelectionMode(QAbstractItemView.ContiguousSelection)\n\t\tself.view.CopyCellsToClipboard = CopyTableCellsToClipboard\n\n\t\tself.ResizeColumnsToContents()\n\n\t\tself.context_menu = ContextMenu(self.view)\n\n\t\tself.find_bar = FindBar(self, self, True)\n\n\t\tself.finder = ChildDataItemFinder(self.data_model)\n\n\t\tself.fetch_bar = FetchMoreRecordsBar(self.data_model, self)\n\n\t\tself.vbox = VBox(self.view, self.find_bar.Widget(), self.fetch_bar.Widget())\n\n\t\tself.setWidget(self.vbox.Widget())\n\n\t\tAddSubWindow(glb.mainwindow.mdi_area, self, table_name + \" Table\")\n\n\tdef Find(self, value, direction, pattern, context):\n\t\tself.view.setFocus()\n\t\tself.find_bar.Busy()\n\t\tself.finder.Find(value, direction, pattern, context, self.FindDone)\n\n\tdef FindDone(self, row):\n\t\tself.find_bar.Idle()\n\t\tif row >= 0:\n\t\t\tself.view.setCurrentIndex(self.model.mapFromSource(self.data_model.index(row, 0, QModelIndex())))\n\t\telse:\n\t\t\tself.find_bar.NotFound()\n\n# Table list\n\ndef GetTableList(glb):\n\ttables = []\n\tquery = QSqlQuery(glb.db)\n\tif glb.dbref.is_sqlite3:\n\t\tQueryExec(query, \"SELECT name FROM sqlite_master WHERE type IN ( 'table' , 'view' ) ORDER BY name\")\n\telse:\n\t\tQueryExec(query, \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type IN ( 'BASE TABLE' , 'VIEW' ) ORDER BY table_name\")\n\twhile query.next():\n\t\ttables.append(query.value(0))\n\tif glb.dbref.is_sqlite3:\n\t\ttables.append(\"sqlite_master\")\n\telse:\n\t\ttables.append(\"information_schema.tables\")\n\t\ttables.append(\"information_schema.views\")\n\t\ttables.append(\"information_schema.columns\")\n\treturn tables\n\n# Top Calls data model\n\nclass TopCallsModel(SQLTableModel):\n\n\tdef __init__(self, glb, report_vars, parent=None):\n\t\ttext = \"\"\n\t\tif not glb.dbref.is_sqlite3:\n\t\t\ttext = \"::text\"\n\t\tlimit = \"\"\n\t\tif len(report_vars.limit):\n\t\t\tlimit = \" LIMIT \" + report_vars.limit\n\t\tsql = (\"SELECT comm, pid, tid, name,\"\n\t\t\t\" CASE\"\n\t\t\t\" WHEN (short_name = '[kernel.kallsyms]') THEN '[kernel]'\" + text +\n\t\t\t\" ELSE short_name\"\n\t\t\t\" END AS dso,\"\n\t\t\t\" call_time, return_time, (return_time - call_time) AS elapsed_time, branch_count, \"\n\t\t\t\" CASE\"\n\t\t\t\" WHEN (calls.flags = 1) THEN 'no call'\" + text +\n\t\t\t\" WHEN (calls.flags = 2) THEN 'no return'\" + text +\n\t\t\t\" WHEN (calls.flags = 3) THEN 'no call/return'\" + text +\n\t\t\t\" ELSE ''\" + text +\n\t\t\t\" END AS flags\"\n\t\t\t\" FROM calls\"\n\t\t\t\" INNER JOIN call_paths ON calls.call_path_id = call_paths.id\"\n\t\t\t\" INNER JOIN symbols ON call_paths.symbol_id = symbols.id\"\n\t\t\t\" INNER JOIN dsos ON symbols.dso_id = dsos.id\"\n\t\t\t\" INNER JOIN comms ON calls.comm_id = comms.id\"\n\t\t\t\" INNER JOIN threads ON calls.thread_id = threads.id\" +\n\t\t\treport_vars.where_clause +\n\t\t\t\" ORDER BY elapsed_time DESC\" +\n\t\t\tlimit\n\t\t\t)\n\t\tcolumn_headers = (\"Command\", \"PID\", \"TID\", \"Symbol\", \"Object\", \"Call Time\", \"Return Time\", \"Elapsed Time (ns)\", \"Branch Count\", \"Flags\")\n\t\tself.alignment = (Qt.AlignLeft, Qt.AlignLeft, Qt.AlignLeft, Qt.AlignLeft, Qt.AlignLeft, Qt.AlignLeft, Qt.AlignLeft, Qt.AlignRight, Qt.AlignRight, Qt.AlignLeft)\n\t\tsuper(TopCallsModel, self).__init__(glb, sql, column_headers, parent)\n\n\tdef columnAlignment(self, column):\n\t\treturn self.alignment[column]\n\n# Top Calls report creation dialog\n\nclass TopCallsDialog(ReportDialogBase):\n\n\tdef __init__(self, glb, parent=None):\n\t\ttitle = \"Top Calls by Elapsed Time\"\n\t\titems = (lambda g, p: LineEditDataItem(g, \"Report name:\", \"Enter a name to appear in the window title bar\", p, \"REPORTNAME\"),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"Commands:\", \"Only calls with these commands will be included\", \"comms\", \"comm\", \"comm_id\", \"\", p),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"PIDs:\", \"Only calls with these process IDs will be included\", \"threads\", \"pid\", \"thread_id\", \"\", p),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"TIDs:\", \"Only calls with these thread IDs will be included\", \"threads\", \"tid\", \"thread_id\", \"\", p),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"DSOs:\", \"Only calls with these DSOs will be included\", \"dsos\", \"short_name\", \"dso_id\", \"\", p),\n\t\t\t lambda g, p: SQLTableDataItem(g, \"Symbols:\", \"Only calls with these symbols will be included\", \"symbols\", \"name\", \"symbol_id\", \"\", p),\n\t\t\t lambda g, p: LineEditDataItem(g, \"Raw SQL clause: \", \"Enter a raw SQL WHERE clause\", p),\n\t\t\t lambda g, p: PositiveIntegerDataItem(g, \"Record limit:\", \"Limit selection to this number of records\", p, \"LIMIT\", \"100\"))\n\t\tsuper(TopCallsDialog, self).__init__(glb, title, items, False, parent)\n\n# Top Calls window\n\nclass TopCallsWindow(QMdiSubWindow, ResizeColumnsToContentsBase):\n\n\tdef __init__(self, glb, report_vars, parent=None):\n\t\tsuper(TopCallsWindow, self).__init__(parent)\n\n\t\tself.data_model = LookupCreateModel(\"Top Calls \" + report_vars.UniqueId(), lambda: TopCallsModel(glb, report_vars))\n\t\tself.model = self.data_model\n\n\t\tself.view = QTableView()\n\t\tself.view.setModel(self.model)\n\t\tself.view.setEditTriggers(QAbstractItemView.NoEditTriggers)\n\t\tself.view.verticalHeader().setVisible(False)\n\t\tself.view.setSelectionMode(QAbstractItemView.ContiguousSelection)\n\t\tself.view.CopyCellsToClipboard = CopyTableCellsToClipboard\n\n\t\tself.context_menu = ContextMenu(self.view)\n\n\t\tself.ResizeColumnsToContents()\n\n\t\tself.find_bar = FindBar(self, self, True)\n\n\t\tself.finder = ChildDataItemFinder(self.model)\n\n\t\tself.fetch_bar = FetchMoreRecordsBar(self.data_model, self)\n\n\t\tself.vbox = VBox(self.view, self.find_bar.Widget(), self.fetch_bar.Widget())\n\n\t\tself.setWidget(self.vbox.Widget())\n\n\t\tAddSubWindow(glb.mainwindow.mdi_area, self, report_vars.name)\n\n\tdef Find(self, value, direction, pattern, context):\n\t\tself.view.setFocus()\n\t\tself.find_bar.Busy()\n\t\tself.finder.Find(value, direction, pattern, context, self.FindDone)\n\n\tdef FindDone(self, row):\n\t\tself.find_bar.Idle()\n\t\tif row >= 0:\n\t\t\tself.view.setCurrentIndex(self.model.index(row, 0, QModelIndex()))\n\t\telse:\n\t\t\tself.find_bar.NotFound()\n\n# Action Definition\n\ndef CreateAction(label, tip, callback, parent=None, shortcut=None):\n\taction = QAction(label, parent)\n\tif shortcut != None:\n\t\taction.setShortcuts(shortcut)\n\taction.setStatusTip(tip)\n\taction.triggered.connect(callback)\n\treturn action\n\n# Typical application actions\n\ndef CreateExitAction(app, parent=None):\n\treturn CreateAction(\"&Quit\", \"Exit the application\", app.closeAllWindows, parent, QKeySequence.Quit)\n\n# Typical MDI actions\n\ndef CreateCloseActiveWindowAction(mdi_area):\n\treturn CreateAction(\"Cl&ose\", \"Close the active window\", mdi_area.closeActiveSubWindow, mdi_area)\n\ndef CreateCloseAllWindowsAction(mdi_area):\n\treturn CreateAction(\"Close &All\", \"Close all the windows\", mdi_area.closeAllSubWindows, mdi_area)\n\ndef CreateTileWindowsAction(mdi_area):\n\treturn CreateAction(\"&Tile\", \"Tile the windows\", mdi_area.tileSubWindows, mdi_area)\n\ndef CreateCascadeWindowsAction(mdi_area):\n\treturn CreateAction(\"&Cascade\", \"Cascade the windows\", mdi_area.cascadeSubWindows, mdi_area)\n\ndef CreateNextWindowAction(mdi_area):\n\treturn CreateAction(\"Ne&xt\", \"Move the focus to the next window\", mdi_area.activateNextSubWindow, mdi_area, QKeySequence.NextChild)\n\ndef CreatePreviousWindowAction(mdi_area):\n\treturn CreateAction(\"Pre&vious\", \"Move the focus to the previous window\", mdi_area.activatePreviousSubWindow, mdi_area, QKeySequence.PreviousChild)\n\n# Typical MDI window menu\n\nclass WindowMenu():\n\n\tdef __init__(self, mdi_area, menu):\n\t\tself.mdi_area = mdi_area\n\t\tself.window_menu = menu.addMenu(\"&Windows\")\n\t\tself.close_active_window = CreateCloseActiveWindowAction(mdi_area)\n\t\tself.close_all_windows = CreateCloseAllWindowsAction(mdi_area)\n\t\tself.tile_windows = CreateTileWindowsAction(mdi_area)\n\t\tself.cascade_windows = CreateCascadeWindowsAction(mdi_area)\n\t\tself.next_window = CreateNextWindowAction(mdi_area)\n\t\tself.previous_window = CreatePreviousWindowAction(mdi_area)\n\t\tself.window_menu.aboutToShow.connect(self.Update)\n\n\tdef Update(self):\n\t\tself.window_menu.clear()\n\t\tsub_window_count = len(self.mdi_area.subWindowList())\n\t\thave_sub_windows = sub_window_count != 0\n\t\tself.close_active_window.setEnabled(have_sub_windows)\n\t\tself.close_all_windows.setEnabled(have_sub_windows)\n\t\tself.tile_windows.setEnabled(have_sub_windows)\n\t\tself.cascade_windows.setEnabled(have_sub_windows)\n\t\tself.next_window.setEnabled(have_sub_windows)\n\t\tself.previous_window.setEnabled(have_sub_windows)\n\t\tself.window_menu.addAction(self.close_active_window)\n\t\tself.window_menu.addAction(self.close_all_windows)\n\t\tself.window_menu.addSeparator()\n\t\tself.window_menu.addAction(self.tile_windows)\n\t\tself.window_menu.addAction(self.cascade_windows)\n\t\tself.window_menu.addSeparator()\n\t\tself.window_menu.addAction(self.next_window)\n\t\tself.window_menu.addAction(self.previous_window)\n\t\tif sub_window_count == 0:\n\t\t\treturn\n\t\tself.window_menu.addSeparator()\n\t\tnr = 1\n\t\tfor sub_window in self.mdi_area.subWindowList():\n\t\t\tlabel = str(nr) + \" \" + sub_window.name\n\t\t\tif nr < 10:\n\t\t\t\tlabel = \"&\" + label\n\t\t\taction = self.window_menu.addAction(label)\n\t\t\taction.setCheckable(True)\n\t\t\taction.setChecked(sub_window == self.mdi_area.activeSubWindow())\n\t\t\taction.triggered.connect(lambda a=None,x=nr: self.setActiveSubWindow(x))\n\t\t\tself.window_menu.addAction(action)\n\t\t\tnr += 1\n\n\tdef setActiveSubWindow(self, nr):\n\t\tself.mdi_area.setActiveSubWindow(self.mdi_area.subWindowList()[nr - 1])\n\n# Help text\n\nglb_help_text = \"\"\"\n<h1>Contents</h1>\n<style>\np.c1 {\n    text-indent: 40px;\n}\np.c2 {\n    text-indent: 80px;\n}\n}\n</style>\n<p class=c1><a href=#reports>1. Reports</a></p>\n<p class=c2><a href=#callgraph>1.1 Context-Sensitive Call Graph</a></p>\n<p class=c2><a href=#calltree>1.2 Call Tree</a></p>\n<p class=c2><a href=#allbranches>1.3 All branches</a></p>\n<p class=c2><a href=#selectedbranches>1.4 Selected branches</a></p>\n<p class=c2><a href=#topcallsbyelapsedtime>1.5 Top calls by elapsed time</a></p>\n<p class=c1><a href=#charts>2. Charts</a></p>\n<p class=c2><a href=#timechartbycpu>2.1 Time chart by CPU</a></p>\n<p class=c1><a href=#tables>3. Tables</a></p>\n<h1 id=reports>1. Reports</h1>\n<h2 id=callgraph>1.1 Context-Sensitive Call Graph</h2>\nThe result is a GUI window with a tree representing a context-sensitive\ncall-graph. Expanding a couple of levels of the tree and adjusting column\nwidths to suit will display something like:\n<pre>\n                                         Call Graph: pt_example\nCall Path                          Object      Count   Time(ns)  Time(%)  Branch Count   Branch Count(%)\nv- ls\n    v- 2638:2638\n        v- _start                  ld-2.19.so    1     10074071   100.0         211135            100.0\n          |- unknown               unknown       1        13198     0.1              1              0.0\n          >- _dl_start             ld-2.19.so    1      1400980    13.9          19637              9.3\n          >- _d_linit_internal     ld-2.19.so    1       448152     4.4          11094              5.3\n          v-__libc_start_main@plt  ls            1      8211741    81.5         180397             85.4\n             >- _dl_fixup          ld-2.19.so    1         7607     0.1            108              0.1\n             >- __cxa_atexit       libc-2.19.so  1        11737     0.1             10              0.0\n             >- __libc_csu_init    ls            1        10354     0.1             10              0.0\n             |- _setjmp            libc-2.19.so  1            0     0.0              4              0.0\n             v- main               ls            1      8182043    99.6         180254             99.9\n</pre>\n<h3>Points to note:</h3>\n<ul>\n<li>The top level is a command name (comm)</li>\n<li>The next level is a thread (pid:tid)</li>\n<li>Subsequent levels are functions</li>\n<li>'Count' is the number of calls</li>\n<li>'Time' is the elapsed time until the function returns</li>\n<li>Percentages are relative to the level above</li>\n<li>'Branch Count' is the total number of branches for that function and all functions that it calls\n</ul>\n<h3>Find</h3>\nCtrl-F displays a Find bar which finds function names by either an exact match or a pattern match.\nThe pattern matching symbols are ? for any character and * for zero or more characters.\n<h2 id=calltree>1.2 Call Tree</h2>\nThe Call Tree report is very similar to the Context-Sensitive Call Graph, but the data is not aggregated.\nAlso the 'Count' column, which would be always 1, is replaced by the 'Call Time'.\n<h2 id=allbranches>1.3 All branches</h2>\nThe All branches report displays all branches in chronological order.\nNot all data is fetched immediately. More records can be fetched using the Fetch bar provided.\n<h3>Disassembly</h3>\nOpen a branch to display disassembly. This only works if:\n<ol>\n<li>The disassembler is available. Currently, only Intel XED is supported - see <a href=#xed>Intel XED Setup</a></li>\n<li>The object code is available. Currently, only the perf build ID cache is searched for object code.\nThe default directory ~/.debug can be overridden by setting environment variable PERF_BUILDID_DIR.\nOne exception is kcore where the DSO long name is used (refer dsos_view on the Tables menu),\nor alternatively, set environment variable PERF_KCORE to the kcore file name.</li>\n</ol>\n<h4 id=xed>Intel XED Setup</h4>\nTo use Intel XED, libxed.so must be present.  To build and install libxed.so:\n<pre>\ngit clone https://github.com/intelxed/mbuild.git mbuild\ngit clone https://github.com/intelxed/xed\ncd xed\n./mfile.py --share\nsudo ./mfile.py --prefix=/usr/local install\nsudo ldconfig\n</pre>\n<h3>Instructions per Cycle (IPC)</h3>\nIf available, IPC information is displayed in columns 'insn_cnt', 'cyc_cnt' and 'IPC'.\n<p><b>Intel PT note:</b> The information applies to the blocks of code ending with, and including, that branch.\nDue to the granularity of timing information, the number of cycles for some code blocks will not be known.\nIn that case, 'insn_cnt', 'cyc_cnt' and 'IPC' are zero, but when 'IPC' is displayed it covers the period\nsince the previous displayed 'IPC'.\n<h3>Find</h3>\nCtrl-F displays a Find bar which finds substrings by either an exact match or a regular expression match.\nRefer to Python documentation for the regular expression syntax.\nAll columns are searched, but only currently fetched rows are searched.\n<h2 id=selectedbranches>1.4 Selected branches</h2>\nThis is the same as the <a href=#allbranches>All branches</a> report but with the data reduced\nby various selection criteria. A dialog box displays available criteria which are AND'ed together.\n<h3>1.4.1 Time ranges</h3>\nThe time ranges hint text shows the total time range. Relative time ranges can also be entered in\nms, us or ns. Also, negative values are relative to the end of trace.  Examples:\n<pre>\n\t81073085947329-81073085958238\tFrom 81073085947329 to 81073085958238\n\t100us-200us\t\tFrom 100us to 200us\n\t10ms-\t\t\tFrom 10ms to the end\n\t-100ns\t\t\tThe first 100ns\n\t-10ms-\t\t\tThe last 10ms\n</pre>\nN.B. Due to the granularity of timestamps, there could be no branches in any given time range.\n<h2 id=topcallsbyelapsedtime>1.5 Top calls by elapsed time</h2>\nThe Top calls by elapsed time report displays calls in descending order of time elapsed between when the function was called and when it returned.\nThe data is reduced by various selection criteria. A dialog box displays available criteria which are AND'ed together.\nIf not all data is fetched, a Fetch bar is provided. Ctrl-F displays a Find bar.\n<h1 id=charts>2. Charts</h1>\n<h2 id=timechartbycpu>2.1 Time chart by CPU</h2>\nThis chart displays context switch information when that data is available. Refer to context_switches_view on the Tables menu.\n<h3>Features</h3>\n<ol>\n<li>Mouse over to highight the task and show the time</li>\n<li>Drag the mouse to select a region and zoom by pushing the Zoom button</li>\n<li>Go back and forward by pressing the arrow buttons</li>\n<li>If call information is available, right-click to show a call tree opened to that task and time.\nNote, the call tree may take some time to appear, and there may not be call information for the task or time selected.\n</li>\n</ol>\n<h3>Important</h3>\nThe graph can be misleading in the following respects:\n<ol>\n<li>The graph shows the first task on each CPU as running from the beginning of the time range.\nBecause tracing might start on different CPUs at different times, that is not necessarily the case.\nRefer to context_switches_view on the Tables menu to understand what data the graph is based upon.</li>\n<li>Similarly, the last task on each CPU can be showing running longer than it really was.\nAgain, refer to context_switches_view on the Tables menu to understand what data the graph is based upon.</li>\n<li>When the mouse is over a task, the highlighted task might not be visible on the legend without scrolling if the legend does not fit fully in the window</li>\n</ol>\n<h1 id=tables>3. Tables</h1>\nThe Tables menu shows all tables and views in the database. Most tables have an associated view\nwhich displays the information in a more friendly way. Not all data for large tables is fetched\nimmediately. More records can be fetched using the Fetch bar provided. Columns can be sorted,\nbut that can be slow for large tables.\n<p>There are also tables of database meta-information.\nFor SQLite3 databases, the sqlite_master table is included.\nFor PostgreSQL databases, information_schema.tables/views/columns are included.\n<h3>Find</h3>\nCtrl-F displays a Find bar which finds substrings by either an exact match or a regular expression match.\nRefer to Python documentation for the regular expression syntax.\nAll columns are searched, but only currently fetched rows are searched.\n<p>N.B. Results are found in id order, so if the table is re-ordered, find-next and find-previous\nwill go to the next/previous result in id order, instead of display order.\n\"\"\"\n\n# Help window\n\nclass HelpWindow(QMdiSubWindow):\n\n\tdef __init__(self, glb, parent=None):\n\t\tsuper(HelpWindow, self).__init__(parent)\n\n\t\tself.text = QTextBrowser()\n\t\tself.text.setHtml(glb_help_text)\n\t\tself.text.setReadOnly(True)\n\t\tself.text.setOpenExternalLinks(True)\n\n\t\tself.setWidget(self.text)\n\n\t\tAddSubWindow(glb.mainwindow.mdi_area, self, \"Exported SQL Viewer Help\")\n\n# Main window that only displays the help text\n\nclass HelpOnlyWindow(QMainWindow):\n\n\tdef __init__(self, parent=None):\n\t\tsuper(HelpOnlyWindow, self).__init__(parent)\n\n\t\tself.setMinimumSize(200, 100)\n\t\tself.resize(800, 600)\n\t\tself.setWindowTitle(\"Exported SQL Viewer Help\")\n\t\tself.setWindowIcon(self.style().standardIcon(QStyle.SP_MessageBoxInformation))\n\n\t\tself.text = QTextBrowser()\n\t\tself.text.setHtml(glb_help_text)\n\t\tself.text.setReadOnly(True)\n\t\tself.text.setOpenExternalLinks(True)\n\n\t\tself.setCentralWidget(self.text)\n\n# PostqreSQL server version\n\ndef PostqreSQLServerVersion(db):\n\tquery = QSqlQuery(db)\n\tQueryExec(query, \"SELECT VERSION()\")\n\tif query.next():\n\t\tv_str = query.value(0)\n\t\tv_list = v_str.strip().split(\" \")\n\t\tif v_list[0] == \"PostgreSQL\" and v_list[2] == \"on\":\n\t\t\treturn v_list[1]\n\t\treturn v_str\n\treturn \"Unknown\"\n\n# SQLite version\n\ndef SQLiteVersion(db):\n\tquery = QSqlQuery(db)\n\tQueryExec(query, \"SELECT sqlite_version()\")\n\tif query.next():\n\t\treturn query.value(0)\n\treturn \"Unknown\"\n\n# About dialog\n\nclass AboutDialog(QDialog):\n\n\tdef __init__(self, glb, parent=None):\n\t\tsuper(AboutDialog, self).__init__(parent)\n\n\t\tself.setWindowTitle(\"About Exported SQL Viewer\")\n\t\tself.setMinimumWidth(300)\n\n\t\tpyside_version = \"1\" if pyside_version_1 else \"2\"\n\n\t\ttext = \"<pre>\"\n\t\ttext += \"Python version:     \" + sys.version.split(\" \")[0] + \"\\n\"\n\t\ttext += \"PySide version:     \" + pyside_version + \"\\n\"\n\t\ttext += \"Qt version:         \" + qVersion() + \"\\n\"\n\t\tif glb.dbref.is_sqlite3:\n\t\t\ttext += \"SQLite version:     \" + SQLiteVersion(glb.db) + \"\\n\"\n\t\telse:\n\t\t\ttext += \"PostqreSQL version: \" + PostqreSQLServerVersion(glb.db) + \"\\n\"\n\t\ttext += \"</pre>\"\n\n\t\tself.text = QTextBrowser()\n\t\tself.text.setHtml(text)\n\t\tself.text.setReadOnly(True)\n\t\tself.text.setOpenExternalLinks(True)\n\n\t\tself.vbox = QVBoxLayout()\n\t\tself.vbox.addWidget(self.text)\n\n\t\tself.setLayout(self.vbox)\n\n# Font resize\n\ndef ResizeFont(widget, diff):\n\tfont = widget.font()\n\tsz = font.pointSize()\n\tfont.setPointSize(sz + diff)\n\twidget.setFont(font)\n\ndef ShrinkFont(widget):\n\tResizeFont(widget, -1)\n\ndef EnlargeFont(widget):\n\tResizeFont(widget, 1)\n\n# Unique name for sub-windows\n\ndef NumberedWindowName(name, nr):\n\tif nr > 1:\n\t\tname += \" <\" + str(nr) + \">\"\n\treturn name\n\ndef UniqueSubWindowName(mdi_area, name):\n\tnr = 1\n\twhile True:\n\t\tunique_name = NumberedWindowName(name, nr)\n\t\tok = True\n\t\tfor sub_window in mdi_area.subWindowList():\n\t\t\tif sub_window.name == unique_name:\n\t\t\t\tok = False\n\t\t\t\tbreak\n\t\tif ok:\n\t\t\treturn unique_name\n\t\tnr += 1\n\n# Add a sub-window\n\ndef AddSubWindow(mdi_area, sub_window, name):\n\tunique_name = UniqueSubWindowName(mdi_area, name)\n\tsub_window.setMinimumSize(200, 100)\n\tsub_window.resize(800, 600)\n\tsub_window.setWindowTitle(unique_name)\n\tsub_window.setAttribute(Qt.WA_DeleteOnClose)\n\tsub_window.setWindowIcon(sub_window.style().standardIcon(QStyle.SP_FileIcon))\n\tsub_window.name = unique_name\n\tmdi_area.addSubWindow(sub_window)\n\tsub_window.show()\n\n# Main window\n\nclass MainWindow(QMainWindow):\n\n\tdef __init__(self, glb, parent=None):\n\t\tsuper(MainWindow, self).__init__(parent)\n\n\t\tself.glb = glb\n\n\t\tself.setWindowTitle(\"Exported SQL Viewer: \" + glb.dbname)\n\t\tself.setWindowIcon(self.style().standardIcon(QStyle.SP_ComputerIcon))\n\t\tself.setMinimumSize(200, 100)\n\n\t\tself.mdi_area = QMdiArea()\n\t\tself.mdi_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n\t\tself.mdi_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\n\n\t\tself.setCentralWidget(self.mdi_area)\n\n\t\tmenu = self.menuBar()\n\n\t\tfile_menu = menu.addMenu(\"&File\")\n\t\tfile_menu.addAction(CreateExitAction(glb.app, self))\n\n\t\tedit_menu = menu.addMenu(\"&Edit\")\n\t\tedit_menu.addAction(CreateAction(\"&Copy\", \"Copy to clipboard\", self.CopyToClipboard, self, QKeySequence.Copy))\n\t\tedit_menu.addAction(CreateAction(\"Copy as CS&V\", \"Copy to clipboard as CSV\", self.CopyToClipboardCSV, self))\n\t\tedit_menu.addAction(CreateAction(\"&Find...\", \"Find items\", self.Find, self, QKeySequence.Find))\n\t\tedit_menu.addAction(CreateAction(\"Fetch &more records...\", \"Fetch more records\", self.FetchMoreRecords, self, [QKeySequence(Qt.Key_F8)]))\n\t\tedit_menu.addAction(CreateAction(\"&Shrink Font\", \"Make text smaller\", self.ShrinkFont, self, [QKeySequence(\"Ctrl+-\")]))\n\t\tedit_menu.addAction(CreateAction(\"&Enlarge Font\", \"Make text bigger\", self.EnlargeFont, self, [QKeySequence(\"Ctrl++\")]))\n\n\t\treports_menu = menu.addMenu(\"&Reports\")\n\t\tif IsSelectable(glb.db, \"calls\"):\n\t\t\treports_menu.addAction(CreateAction(\"Context-Sensitive Call &Graph\", \"Create a new window containing a context-sensitive call graph\", self.NewCallGraph, self))\n\n\t\tif IsSelectable(glb.db, \"calls\", \"WHERE parent_id >= 0\"):\n\t\t\treports_menu.addAction(CreateAction(\"Call &Tree\", \"Create a new window containing a call tree\", self.NewCallTree, self))\n\n\t\tself.EventMenu(GetEventList(glb.db), reports_menu)\n\n\t\tif IsSelectable(glb.db, \"calls\"):\n\t\t\treports_menu.addAction(CreateAction(\"&Top calls by elapsed time\", \"Create a new window displaying top calls by elapsed time\", self.NewTopCalls, self))\n\n\t\tif IsSelectable(glb.db, \"context_switches\"):\n\t\t\tcharts_menu = menu.addMenu(\"&Charts\")\n\t\t\tcharts_menu.addAction(CreateAction(\"&Time chart by CPU\", \"Create a new window displaying time charts by CPU\", self.TimeChartByCPU, self))\n\n\t\tself.TableMenu(GetTableList(glb), menu)\n\n\t\tself.window_menu = WindowMenu(self.mdi_area, menu)\n\n\t\thelp_menu = menu.addMenu(\"&Help\")\n\t\thelp_menu.addAction(CreateAction(\"&Exported SQL Viewer Help\", \"Helpful information\", self.Help, self, QKeySequence.HelpContents))\n\t\thelp_menu.addAction(CreateAction(\"&About Exported SQL Viewer\", \"About this application\", self.About, self))\n\n\tdef Try(self, fn):\n\t\twin = self.mdi_area.activeSubWindow()\n\t\tif win:\n\t\t\ttry:\n\t\t\t\tfn(win.view)\n\t\t\texcept:\n\t\t\t\tpass\n\n\tdef CopyToClipboard(self):\n\t\tself.Try(CopyCellsToClipboardHdr)\n\n\tdef CopyToClipboardCSV(self):\n\t\tself.Try(CopyCellsToClipboardCSV)\n\n\tdef Find(self):\n\t\twin = self.mdi_area.activeSubWindow()\n\t\tif win:\n\t\t\ttry:\n\t\t\t\twin.find_bar.Activate()\n\t\t\texcept:\n\t\t\t\tpass\n\n\tdef FetchMoreRecords(self):\n\t\twin = self.mdi_area.activeSubWindow()\n\t\tif win:\n\t\t\ttry:\n\t\t\t\twin.fetch_bar.Activate()\n\t\t\texcept:\n\t\t\t\tpass\n\n\tdef ShrinkFont(self):\n\t\tself.Try(ShrinkFont)\n\n\tdef EnlargeFont(self):\n\t\tself.Try(EnlargeFont)\n\n\tdef EventMenu(self, events, reports_menu):\n\t\tbranches_events = 0\n\t\tfor event in events:\n\t\t\tevent = event.split(\":\")[0]\n\t\t\tif event == \"branches\":\n\t\t\t\tbranches_events += 1\n\t\tdbid = 0\n\t\tfor event in events:\n\t\t\tdbid += 1\n\t\t\tevent = event.split(\":\")[0]\n\t\t\tif event == \"branches\":\n\t\t\t\tlabel = \"All branches\" if branches_events == 1 else \"All branches \" + \"(id=\" + dbid + \")\"\n\t\t\t\treports_menu.addAction(CreateAction(label, \"Create a new window displaying branch events\", lambda a=None,x=dbid: self.NewBranchView(x), self))\n\t\t\t\tlabel = \"Selected branches\" if branches_events == 1 else \"Selected branches \" + \"(id=\" + dbid + \")\"\n\t\t\t\treports_menu.addAction(CreateAction(label, \"Create a new window displaying branch events\", lambda a=None,x=dbid: self.NewSelectedBranchView(x), self))\n\n\tdef TimeChartByCPU(self):\n\t\tTimeChartByCPUWindow(self.glb, self)\n\n\tdef TableMenu(self, tables, menu):\n\t\ttable_menu = menu.addMenu(\"&Tables\")\n\t\tfor table in tables:\n\t\t\ttable_menu.addAction(CreateAction(table, \"Create a new window containing a table view\", lambda a=None,t=table: self.NewTableView(t), self))\n\n\tdef NewCallGraph(self):\n\t\tCallGraphWindow(self.glb, self)\n\n\tdef NewCallTree(self):\n\t\tCallTreeWindow(self.glb, self)\n\n\tdef NewTopCalls(self):\n\t\tdialog = TopCallsDialog(self.glb, self)\n\t\tret = dialog.exec_()\n\t\tif ret:\n\t\t\tTopCallsWindow(self.glb, dialog.report_vars, self)\n\n\tdef NewBranchView(self, event_id):\n\t\tBranchWindow(self.glb, event_id, ReportVars(), self)\n\n\tdef NewSelectedBranchView(self, event_id):\n\t\tdialog = SelectedBranchDialog(self.glb, self)\n\t\tret = dialog.exec_()\n\t\tif ret:\n\t\t\tBranchWindow(self.glb, event_id, dialog.report_vars, self)\n\n\tdef NewTableView(self, table_name):\n\t\tTableWindow(self.glb, table_name, self)\n\n\tdef Help(self):\n\t\tHelpWindow(self.glb, self)\n\n\tdef About(self):\n\t\tdialog = AboutDialog(self.glb, self)\n\t\tdialog.exec_()\n\ndef TryOpen(file_name):\n\ttry:\n\t\treturn open(file_name, \"rb\")\n\texcept:\n\t\treturn None\n\ndef Is64Bit(f):\n\tresult = sizeof(c_void_p)\n\t# ELF support only\n\tpos = f.tell()\n\tf.seek(0)\n\theader = f.read(7)\n\tf.seek(pos)\n\tmagic = header[0:4]\n\tif sys.version_info[0] == 2:\n\t\teclass = ord(header[4])\n\t\tencoding = ord(header[5])\n\t\tversion = ord(header[6])\n\telse:\n\t\teclass = header[4]\n\t\tencoding = header[5]\n\t\tversion = header[6]\n\tif magic == chr(127) + \"ELF\" and eclass > 0 and eclass < 3 and encoding > 0 and encoding < 3 and version == 1:\n\t\tresult = True if eclass == 2 else False\n\treturn result\n\n# Global data\n\nclass Glb():\n\n\tdef __init__(self, dbref, db, dbname):\n\t\tself.dbref = dbref\n\t\tself.db = db\n\t\tself.dbname = dbname\n\t\tself.home_dir = os.path.expanduser(\"~\")\n\t\tself.buildid_dir = os.getenv(\"PERF_BUILDID_DIR\")\n\t\tif self.buildid_dir:\n\t\t\tself.buildid_dir += \"/.build-id/\"\n\t\telse:\n\t\t\tself.buildid_dir = self.home_dir + \"/.debug/.build-id/\"\n\t\tself.app = None\n\t\tself.mainwindow = None\n\t\tself.instances_to_shutdown_on_exit = weakref.WeakSet()\n\t\ttry:\n\t\t\tself.disassembler = LibXED()\n\t\t\tself.have_disassembler = True\n\t\texcept:\n\t\t\tself.have_disassembler = False\n\t\tself.host_machine_id = 0\n\t\tself.host_start_time = 0\n\t\tself.host_finish_time = 0\n\n\tdef FileFromBuildId(self, build_id):\n\t\tfile_name = self.buildid_dir + build_id[0:2] + \"/\" + build_id[2:] + \"/elf\"\n\t\treturn TryOpen(file_name)\n\n\tdef FileFromNamesAndBuildId(self, short_name, long_name, build_id):\n\t\t# Assume current machine i.e. no support for virtualization\n\t\tif short_name[0:7] == \"[kernel\" and os.path.basename(long_name) == \"kcore\":\n\t\t\tfile_name = os.getenv(\"PERF_KCORE\")\n\t\t\tf = TryOpen(file_name) if file_name else None\n\t\t\tif f:\n\t\t\t\treturn f\n\t\t\t# For now, no special handling if long_name is /proc/kcore\n\t\t\tf = TryOpen(long_name)\n\t\t\tif f:\n\t\t\t\treturn f\n\t\tf = self.FileFromBuildId(build_id)\n\t\tif f:\n\t\t\treturn f\n\t\treturn None\n\n\tdef AddInstanceToShutdownOnExit(self, instance):\n\t\tself.instances_to_shutdown_on_exit.add(instance)\n\n\t# Shutdown any background processes or threads\n\tdef ShutdownInstances(self):\n\t\tfor x in self.instances_to_shutdown_on_exit:\n\t\t\ttry:\n\t\t\t\tx.Shutdown()\n\t\t\texcept:\n\t\t\t\tpass\n\n\tdef GetHostMachineId(self):\n\t\tquery = QSqlQuery(self.db)\n\t\tQueryExec(query, \"SELECT id FROM machines WHERE pid = -1\")\n\t\tif query.next():\n\t\t\tself.host_machine_id = query.value(0)\n\t\telse:\n\t\t\tself.host_machine_id = 0\n\t\treturn self.host_machine_id\n\n\tdef HostMachineId(self):\n\t\tif self.host_machine_id:\n\t\t\treturn self.host_machine_id\n\t\treturn self.GetHostMachineId()\n\n\tdef SelectValue(self, sql):\n\t\tquery = QSqlQuery(self.db)\n\t\ttry:\n\t\t\tQueryExec(query, sql)\n\t\texcept:\n\t\t\treturn None\n\t\tif query.next():\n\t\t\treturn Decimal(query.value(0))\n\t\treturn None\n\n\tdef SwitchesMinTime(self, machine_id):\n\t\treturn self.SelectValue(\"SELECT time\"\n\t\t\t\t\t\" FROM context_switches\"\n\t\t\t\t\t\" WHERE time != 0 AND machine_id = \" + str(machine_id) +\n\t\t\t\t\t\" ORDER BY id LIMIT 1\")\n\n\tdef SwitchesMaxTime(self, machine_id):\n\t\treturn self.SelectValue(\"SELECT time\"\n\t\t\t\t\t\" FROM context_switches\"\n\t\t\t\t\t\" WHERE time != 0 AND machine_id = \" + str(machine_id) +\n\t\t\t\t\t\" ORDER BY id DESC LIMIT 1\")\n\n\tdef SamplesMinTime(self, machine_id):\n\t\treturn self.SelectValue(\"SELECT time\"\n\t\t\t\t\t\" FROM samples\"\n\t\t\t\t\t\" WHERE time != 0 AND machine_id = \" + str(machine_id) +\n\t\t\t\t\t\" ORDER BY id LIMIT 1\")\n\n\tdef SamplesMaxTime(self, machine_id):\n\t\treturn self.SelectValue(\"SELECT time\"\n\t\t\t\t\t\" FROM samples\"\n\t\t\t\t\t\" WHERE time != 0 AND machine_id = \" + str(machine_id) +\n\t\t\t\t\t\" ORDER BY id DESC LIMIT 1\")\n\n\tdef CallsMinTime(self, machine_id):\n\t\treturn self.SelectValue(\"SELECT calls.call_time\"\n\t\t\t\t\t\" FROM calls\"\n\t\t\t\t\t\" INNER JOIN threads ON threads.thread_id = calls.thread_id\"\n\t\t\t\t\t\" WHERE calls.call_time != 0 AND threads.machine_id = \" + str(machine_id) +\n\t\t\t\t\t\" ORDER BY calls.id LIMIT 1\")\n\n\tdef CallsMaxTime(self, machine_id):\n\t\treturn self.SelectValue(\"SELECT calls.return_time\"\n\t\t\t\t\t\" FROM calls\"\n\t\t\t\t\t\" INNER JOIN threads ON threads.thread_id = calls.thread_id\"\n\t\t\t\t\t\" WHERE calls.return_time != 0 AND threads.machine_id = \" + str(machine_id) +\n\t\t\t\t\t\" ORDER BY calls.return_time DESC LIMIT 1\")\n\n\tdef GetStartTime(self, machine_id):\n\t\tt0 = self.SwitchesMinTime(machine_id)\n\t\tt1 = self.SamplesMinTime(machine_id)\n\t\tt2 = self.CallsMinTime(machine_id)\n\t\tif t0 is None or (not(t1 is None) and t1 < t0):\n\t\t\tt0 = t1\n\t\tif t0 is None or (not(t2 is None) and t2 < t0):\n\t\t\tt0 = t2\n\t\treturn t0\n\n\tdef GetFinishTime(self, machine_id):\n\t\tt0 = self.SwitchesMaxTime(machine_id)\n\t\tt1 = self.SamplesMaxTime(machine_id)\n\t\tt2 = self.CallsMaxTime(machine_id)\n\t\tif t0 is None or (not(t1 is None) and t1 > t0):\n\t\t\tt0 = t1\n\t\tif t0 is None or (not(t2 is None) and t2 > t0):\n\t\t\tt0 = t2\n\t\treturn t0\n\n\tdef HostStartTime(self):\n\t\tif self.host_start_time:\n\t\t\treturn self.host_start_time\n\t\tself.host_start_time = self.GetStartTime(self.HostMachineId())\n\t\treturn self.host_start_time\n\n\tdef HostFinishTime(self):\n\t\tif self.host_finish_time:\n\t\t\treturn self.host_finish_time\n\t\tself.host_finish_time = self.GetFinishTime(self.HostMachineId())\n\t\treturn self.host_finish_time\n\n\tdef StartTime(self, machine_id):\n\t\tif machine_id == self.HostMachineId():\n\t\t\treturn self.HostStartTime()\n\t\treturn self.GetStartTime(machine_id)\n\n\tdef FinishTime(self, machine_id):\n\t\tif machine_id == self.HostMachineId():\n\t\t\treturn self.HostFinishTime()\n\t\treturn self.GetFinishTime(machine_id)\n\n# Database reference\n\nclass DBRef():\n\n\tdef __init__(self, is_sqlite3, dbname):\n\t\tself.is_sqlite3 = is_sqlite3\n\t\tself.dbname = dbname\n\t\tself.TRUE = \"TRUE\"\n\t\tself.FALSE = \"FALSE\"\n\t\t# SQLite prior to version 3.23 does not support TRUE and FALSE\n\t\tif self.is_sqlite3:\n\t\t\tself.TRUE = \"1\"\n\t\t\tself.FALSE = \"0\"\n\n\tdef Open(self, connection_name):\n\t\tdbname = self.dbname\n\t\tif self.is_sqlite3:\n\t\t\tdb = QSqlDatabase.addDatabase(\"QSQLITE\", connection_name)\n\t\telse:\n\t\t\tdb = QSqlDatabase.addDatabase(\"QPSQL\", connection_name)\n\t\t\topts = dbname.split()\n\t\t\tfor opt in opts:\n\t\t\t\tif \"=\" in opt:\n\t\t\t\t\topt = opt.split(\"=\")\n\t\t\t\t\tif opt[0] == \"hostname\":\n\t\t\t\t\t\tdb.setHostName(opt[1])\n\t\t\t\t\telif opt[0] == \"port\":\n\t\t\t\t\t\tdb.setPort(int(opt[1]))\n\t\t\t\t\telif opt[0] == \"username\":\n\t\t\t\t\t\tdb.setUserName(opt[1])\n\t\t\t\t\telif opt[0] == \"password\":\n\t\t\t\t\t\tdb.setPassword(opt[1])\n\t\t\t\t\telif opt[0] == \"dbname\":\n\t\t\t\t\t\tdbname = opt[1]\n\t\t\t\telse:\n\t\t\t\t\tdbname = opt\n\n\t\tdb.setDatabaseName(dbname)\n\t\tif not db.open():\n\t\t\traise Exception(\"Failed to open database \" + dbname + \" error: \" + db.lastError().text())\n\t\treturn db, dbname\n\n# Main\n\ndef Main():\n\tusage_str =\t\"exported-sql-viewer.py [--pyside-version-1] <database name>\\n\" \\\n\t\t\t\"   or: exported-sql-viewer.py --help-only\"\n\tap = argparse.ArgumentParser(usage = usage_str, add_help = False)\n\tap.add_argument(\"--pyside-version-1\", action='store_true')\n\tap.add_argument(\"dbname\", nargs=\"?\")\n\tap.add_argument(\"--help-only\", action='store_true')\n\targs = ap.parse_args()\n\n\tif args.help_only:\n\t\tapp = QApplication(sys.argv)\n\t\tmainwindow = HelpOnlyWindow()\n\t\tmainwindow.show()\n\t\terr = app.exec_()\n\t\tsys.exit(err)\n\n\tdbname = args.dbname\n\tif dbname is None:\n\t\tap.print_usage()\n\t\tprint(\"Too few arguments\")\n\t\tsys.exit(1)\n\n\tis_sqlite3 = False\n\ttry:\n\t\tf = open(dbname, \"rb\")\n\t\tif f.read(15) == b'SQLite format 3':\n\t\t\tis_sqlite3 = True\n\t\tf.close()\n\texcept:\n\t\tpass\n\n\tdbref = DBRef(is_sqlite3, dbname)\n\tdb, dbname = dbref.Open(\"main\")\n\tglb = Glb(dbref, db, dbname)\n\tapp = QApplication(sys.argv)\n\tglb.app = app\n\tmainwindow = MainWindow(glb)\n\tglb.mainwindow = mainwindow\n\tmainwindow.show()\n\terr = app.exec_()\n\tglb.ShutdownInstances()\n\tdb.close()\n\tsys.exit(err)\n\nif __name__ == \"__main__\":\n\tMain()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}