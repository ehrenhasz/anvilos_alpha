{
  "module_name": "netdev-times.py",
  "hash_id": "a4148c37d7675cf78d8f8e4ed4389bc511138e8780c544c74aa46abc71ea89f8",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/netdev-times.py",
  "human_readable_source": "# Display a process of packets and processed time.\n# SPDX-License-Identifier: GPL-2.0\n# It helps us to investigate networking or network device.\n#\n# options\n# tx: show only tx chart\n# rx: show only rx chart\n# dev=: show only thing related to specified device\n# debug: work with debug mode. It shows buffer status.\n\nfrom __future__ import print_function\n\nimport os\nimport sys\n\nsys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n\t'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\nfrom perf_trace_context import *\nfrom Core import *\nfrom Util import *\nfrom functools import cmp_to_key\n\nall_event_list = []; # insert all tracepoint event related with this script\nirq_dic = {}; # key is cpu and value is a list which stacks irqs\n              # which raise NET_RX softirq\nnet_rx_dic = {}; # key is cpu and value include time of NET_RX softirq-entry\n\t\t # and a list which stacks receive\nreceive_hunk_list = []; # a list which include a sequence of receive events\nrx_skb_list = []; # received packet list for matching\n\t\t       # skb_copy_datagram_iovec\n\nbuffer_budget = 65536; # the budget of rx_skb_list, tx_queue_list and\n\t\t       # tx_xmit_list\nof_count_rx_skb_list = 0; # overflow count\n\ntx_queue_list = []; # list of packets which pass through dev_queue_xmit\nof_count_tx_queue_list = 0; # overflow count\n\ntx_xmit_list = [];  # list of packets which pass through dev_hard_start_xmit\nof_count_tx_xmit_list = 0; # overflow count\n\ntx_free_list = [];  # list of packets which is freed\n\n# options\nshow_tx = 0;\nshow_rx = 0;\ndev = 0; # store a name of device specified by option \"dev=\"\ndebug = 0;\n\n# indices of event_info tuple\nEINFO_IDX_NAME=   0\nEINFO_IDX_CONTEXT=1\nEINFO_IDX_CPU=    2\nEINFO_IDX_TIME=   3\nEINFO_IDX_PID=    4\nEINFO_IDX_COMM=   5\n\n# Calculate a time interval(msec) from src(nsec) to dst(nsec)\ndef diff_msec(src, dst):\n\treturn (dst - src) / 1000000.0\n\n# Display a process of transmitting a packet\ndef print_transmit(hunk):\n\tif dev != 0 and hunk['dev'].find(dev) < 0:\n\t\treturn\n\tprint(\"%7s %5d %6d.%06dsec %12.3fmsec      %12.3fmsec\" %\n\t\t(hunk['dev'], hunk['len'],\n\t\tnsecs_secs(hunk['queue_t']),\n\t\tnsecs_nsecs(hunk['queue_t'])/1000,\n\t\tdiff_msec(hunk['queue_t'], hunk['xmit_t']),\n\t\tdiff_msec(hunk['xmit_t'], hunk['free_t'])))\n\n# Format for displaying rx packet processing\nPF_IRQ_ENTRY= \"  irq_entry(+%.3fmsec irq=%d:%s)\"\nPF_SOFT_ENTRY=\"  softirq_entry(+%.3fmsec)\"\nPF_NAPI_POLL= \"  napi_poll_exit(+%.3fmsec %s)\"\nPF_JOINT=     \"         |\"\nPF_WJOINT=    \"         |            |\"\nPF_NET_RECV=  \"         |---netif_receive_skb(+%.3fmsec skb=%x len=%d)\"\nPF_NET_RX=    \"         |---netif_rx(+%.3fmsec skb=%x)\"\nPF_CPY_DGRAM= \"         |      skb_copy_datagram_iovec(+%.3fmsec %d:%s)\"\nPF_KFREE_SKB= \"         |      kfree_skb(+%.3fmsec location=%x)\"\nPF_CONS_SKB=  \"         |      consume_skb(+%.3fmsec)\"\n\n# Display a process of received packets and interrputs associated with\n# a NET_RX softirq\ndef print_receive(hunk):\n\tshow_hunk = 0\n\tirq_list = hunk['irq_list']\n\tcpu = irq_list[0]['cpu']\n\tbase_t = irq_list[0]['irq_ent_t']\n\t# check if this hunk should be showed\n\tif dev != 0:\n\t\tfor i in range(len(irq_list)):\n\t\t\tif irq_list[i]['name'].find(dev) >= 0:\n\t\t\t\tshow_hunk = 1\n\t\t\t\tbreak\n\telse:\n\t\tshow_hunk = 1\n\tif show_hunk == 0:\n\t\treturn\n\n\tprint(\"%d.%06dsec cpu=%d\" %\n\t\t(nsecs_secs(base_t), nsecs_nsecs(base_t)/1000, cpu))\n\tfor i in range(len(irq_list)):\n\t\tprint(PF_IRQ_ENTRY %\n\t\t\t(diff_msec(base_t, irq_list[i]['irq_ent_t']),\n\t\t\tirq_list[i]['irq'], irq_list[i]['name']))\n\t\tprint(PF_JOINT)\n\t\tirq_event_list = irq_list[i]['event_list']\n\t\tfor j in range(len(irq_event_list)):\n\t\t\tirq_event = irq_event_list[j]\n\t\t\tif irq_event['event'] == 'netif_rx':\n\t\t\t\tprint(PF_NET_RX %\n\t\t\t\t\t(diff_msec(base_t, irq_event['time']),\n\t\t\t\t\tirq_event['skbaddr']))\n\t\t\t\tprint(PF_JOINT)\n\tprint(PF_SOFT_ENTRY %\n\t\tdiff_msec(base_t, hunk['sirq_ent_t']))\n\tprint(PF_JOINT)\n\tevent_list = hunk['event_list']\n\tfor i in range(len(event_list)):\n\t\tevent = event_list[i]\n\t\tif event['event_name'] == 'napi_poll':\n\t\t\tprint(PF_NAPI_POLL %\n\t\t\t\t(diff_msec(base_t, event['event_t']),\n\t\t\t\tevent['dev']))\n\t\t\tif i == len(event_list) - 1:\n\t\t\t\tprint(\"\")\n\t\t\telse:\n\t\t\t\tprint(PF_JOINT)\n\t\telse:\n\t\t\tprint(PF_NET_RECV %\n\t\t\t\t(diff_msec(base_t, event['event_t']),\n\t\t\t\tevent['skbaddr'],\n\t\t\t\tevent['len']))\n\t\t\tif 'comm' in event.keys():\n\t\t\t\tprint(PF_WJOINT)\n\t\t\t\tprint(PF_CPY_DGRAM %\n\t\t\t\t\t(diff_msec(base_t, event['comm_t']),\n\t\t\t\t\tevent['pid'], event['comm']))\n\t\t\telif 'handle' in event.keys():\n\t\t\t\tprint(PF_WJOINT)\n\t\t\t\tif event['handle'] == \"kfree_skb\":\n\t\t\t\t\tprint(PF_KFREE_SKB %\n\t\t\t\t\t\t(diff_msec(base_t,\n\t\t\t\t\t\tevent['comm_t']),\n\t\t\t\t\t\tevent['location']))\n\t\t\t\telif event['handle'] == \"consume_skb\":\n\t\t\t\t\tprint(PF_CONS_SKB %\n\t\t\t\t\t\tdiff_msec(base_t,\n\t\t\t\t\t\t\tevent['comm_t']))\n\t\t\tprint(PF_JOINT)\n\ndef trace_begin():\n\tglobal show_tx\n\tglobal show_rx\n\tglobal dev\n\tglobal debug\n\n\tfor i in range(len(sys.argv)):\n\t\tif i == 0:\n\t\t\tcontinue\n\t\targ = sys.argv[i]\n\t\tif arg == 'tx':\n\t\t\tshow_tx = 1\n\t\telif arg =='rx':\n\t\t\tshow_rx = 1\n\t\telif arg.find('dev=',0, 4) >= 0:\n\t\t\tdev = arg[4:]\n\t\telif arg == 'debug':\n\t\t\tdebug = 1\n\tif show_tx == 0  and show_rx == 0:\n\t\tshow_tx = 1\n\t\tshow_rx = 1\n\ndef trace_end():\n\t# order all events in time\n\tall_event_list.sort(key=cmp_to_key(lambda a,b :a[EINFO_IDX_TIME] < b[EINFO_IDX_TIME]))\n\t# process all events\n\tfor i in range(len(all_event_list)):\n\t\tevent_info = all_event_list[i]\n\t\tname = event_info[EINFO_IDX_NAME]\n\t\tif name == 'irq__softirq_exit':\n\t\t\thandle_irq_softirq_exit(event_info)\n\t\telif name == 'irq__softirq_entry':\n\t\t\thandle_irq_softirq_entry(event_info)\n\t\telif name == 'irq__softirq_raise':\n\t\t\thandle_irq_softirq_raise(event_info)\n\t\telif name == 'irq__irq_handler_entry':\n\t\t\thandle_irq_handler_entry(event_info)\n\t\telif name == 'irq__irq_handler_exit':\n\t\t\thandle_irq_handler_exit(event_info)\n\t\telif name == 'napi__napi_poll':\n\t\t\thandle_napi_poll(event_info)\n\t\telif name == 'net__netif_receive_skb':\n\t\t\thandle_netif_receive_skb(event_info)\n\t\telif name == 'net__netif_rx':\n\t\t\thandle_netif_rx(event_info)\n\t\telif name == 'skb__skb_copy_datagram_iovec':\n\t\t\thandle_skb_copy_datagram_iovec(event_info)\n\t\telif name == 'net__net_dev_queue':\n\t\t\thandle_net_dev_queue(event_info)\n\t\telif name == 'net__net_dev_xmit':\n\t\t\thandle_net_dev_xmit(event_info)\n\t\telif name == 'skb__kfree_skb':\n\t\t\thandle_kfree_skb(event_info)\n\t\telif name == 'skb__consume_skb':\n\t\t\thandle_consume_skb(event_info)\n\t# display receive hunks\n\tif show_rx:\n\t\tfor i in range(len(receive_hunk_list)):\n\t\t\tprint_receive(receive_hunk_list[i])\n\t# display transmit hunks\n\tif show_tx:\n\t\tprint(\"   dev    len      Qdisc        \"\n\t\t\t\"       netdevice             free\")\n\t\tfor i in range(len(tx_free_list)):\n\t\t\tprint_transmit(tx_free_list[i])\n\tif debug:\n\t\tprint(\"debug buffer status\")\n\t\tprint(\"----------------------------\")\n\t\tprint(\"xmit Qdisc:remain:%d overflow:%d\" %\n\t\t\t(len(tx_queue_list), of_count_tx_queue_list))\n\t\tprint(\"xmit netdevice:remain:%d overflow:%d\" %\n\t\t\t(len(tx_xmit_list), of_count_tx_xmit_list))\n\t\tprint(\"receive:remain:%d overflow:%d\" %\n\t\t\t(len(rx_skb_list), of_count_rx_skb_list))\n\n# called from perf, when it finds a correspoinding event\ndef irq__softirq_entry(name, context, cpu, sec, nsec, pid, comm, callchain, vec):\n\tif symbol_str(\"irq__softirq_entry\", \"vec\", vec) != \"NET_RX\":\n\t\treturn\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm, vec)\n\tall_event_list.append(event_info)\n\ndef irq__softirq_exit(name, context, cpu, sec, nsec, pid, comm, callchain, vec):\n\tif symbol_str(\"irq__softirq_entry\", \"vec\", vec) != \"NET_RX\":\n\t\treturn\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm, vec)\n\tall_event_list.append(event_info)\n\ndef irq__softirq_raise(name, context, cpu, sec, nsec, pid, comm, callchain, vec):\n\tif symbol_str(\"irq__softirq_entry\", \"vec\", vec) != \"NET_RX\":\n\t\treturn\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm, vec)\n\tall_event_list.append(event_info)\n\ndef irq__irq_handler_entry(name, context, cpu, sec, nsec, pid, comm,\n\t\t\tcallchain, irq, irq_name):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm,\n\t\t\tirq, irq_name)\n\tall_event_list.append(event_info)\n\ndef irq__irq_handler_exit(name, context, cpu, sec, nsec, pid, comm, callchain, irq, ret):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm, irq, ret)\n\tall_event_list.append(event_info)\n\ndef napi__napi_poll(name, context, cpu, sec, nsec, pid, comm, callchain, napi,\n\t\tdev_name, work=None, budget=None):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm,\n\t\t\tnapi, dev_name, work, budget)\n\tall_event_list.append(event_info)\n\ndef net__netif_receive_skb(name, context, cpu, sec, nsec, pid, comm, callchain, skbaddr,\n\t\t\tskblen, dev_name):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm,\n\t\t\tskbaddr, skblen, dev_name)\n\tall_event_list.append(event_info)\n\ndef net__netif_rx(name, context, cpu, sec, nsec, pid, comm, callchain, skbaddr,\n\t\t\tskblen, dev_name):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm,\n\t\t\tskbaddr, skblen, dev_name)\n\tall_event_list.append(event_info)\n\ndef net__net_dev_queue(name, context, cpu, sec, nsec, pid, comm, callchain,\n\t\t\tskbaddr, skblen, dev_name):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm,\n\t\t\tskbaddr, skblen, dev_name)\n\tall_event_list.append(event_info)\n\ndef net__net_dev_xmit(name, context, cpu, sec, nsec, pid, comm, callchain,\n\t\t\tskbaddr, skblen, rc, dev_name):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm,\n\t\t\tskbaddr, skblen, rc ,dev_name)\n\tall_event_list.append(event_info)\n\ndef skb__kfree_skb(name, context, cpu, sec, nsec, pid, comm, callchain,\n\t\t\tskbaddr, location, protocol, reason):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm,\n\t\t\tskbaddr, location, protocol, reason)\n\tall_event_list.append(event_info)\n\ndef skb__consume_skb(name, context, cpu, sec, nsec, pid, comm, callchain, skbaddr):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm,\n\t\t\tskbaddr)\n\tall_event_list.append(event_info)\n\ndef skb__skb_copy_datagram_iovec(name, context, cpu, sec, nsec, pid, comm, callchain,\n\tskbaddr, skblen):\n\tevent_info = (name, context, cpu, nsecs(sec, nsec), pid, comm,\n\t\t\tskbaddr, skblen)\n\tall_event_list.append(event_info)\n\ndef handle_irq_handler_entry(event_info):\n\t(name, context, cpu, time, pid, comm, irq, irq_name) = event_info\n\tif cpu not in irq_dic.keys():\n\t\tirq_dic[cpu] = []\n\tirq_record = {'irq':irq, 'name':irq_name, 'cpu':cpu, 'irq_ent_t':time}\n\tirq_dic[cpu].append(irq_record)\n\ndef handle_irq_handler_exit(event_info):\n\t(name, context, cpu, time, pid, comm, irq, ret) = event_info\n\tif cpu not in irq_dic.keys():\n\t\treturn\n\tirq_record = irq_dic[cpu].pop()\n\tif irq != irq_record['irq']:\n\t\treturn\n\tirq_record.update({'irq_ext_t':time})\n\t# if an irq doesn't include NET_RX softirq, drop.\n\tif 'event_list' in irq_record.keys():\n\t\tirq_dic[cpu].append(irq_record)\n\ndef handle_irq_softirq_raise(event_info):\n\t(name, context, cpu, time, pid, comm, vec) = event_info\n\tif cpu not in irq_dic.keys() \\\n\tor len(irq_dic[cpu]) == 0:\n\t\treturn\n\tirq_record = irq_dic[cpu].pop()\n\tif 'event_list' in irq_record.keys():\n\t\tirq_event_list = irq_record['event_list']\n\telse:\n\t\tirq_event_list = []\n\tirq_event_list.append({'time':time, 'event':'sirq_raise'})\n\tirq_record.update({'event_list':irq_event_list})\n\tirq_dic[cpu].append(irq_record)\n\ndef handle_irq_softirq_entry(event_info):\n\t(name, context, cpu, time, pid, comm, vec) = event_info\n\tnet_rx_dic[cpu] = {'sirq_ent_t':time, 'event_list':[]}\n\ndef handle_irq_softirq_exit(event_info):\n\t(name, context, cpu, time, pid, comm, vec) = event_info\n\tirq_list = []\n\tevent_list = 0\n\tif cpu in irq_dic.keys():\n\t\tirq_list = irq_dic[cpu]\n\t\tdel irq_dic[cpu]\n\tif cpu in net_rx_dic.keys():\n\t\tsirq_ent_t = net_rx_dic[cpu]['sirq_ent_t']\n\t\tevent_list = net_rx_dic[cpu]['event_list']\n\t\tdel net_rx_dic[cpu]\n\tif irq_list == [] or event_list == 0:\n\t\treturn\n\trec_data = {'sirq_ent_t':sirq_ent_t, 'sirq_ext_t':time,\n\t\t\t'irq_list':irq_list, 'event_list':event_list}\n\t# merge information related to a NET_RX softirq\n\treceive_hunk_list.append(rec_data)\n\ndef handle_napi_poll(event_info):\n\t(name, context, cpu, time, pid, comm, napi, dev_name,\n\t\twork, budget) = event_info\n\tif cpu in net_rx_dic.keys():\n\t\tevent_list = net_rx_dic[cpu]['event_list']\n\t\trec_data = {'event_name':'napi_poll',\n\t\t\t\t'dev':dev_name, 'event_t':time,\n\t\t\t\t'work':work, 'budget':budget}\n\t\tevent_list.append(rec_data)\n\ndef handle_netif_rx(event_info):\n\t(name, context, cpu, time, pid, comm,\n\t\tskbaddr, skblen, dev_name) = event_info\n\tif cpu not in irq_dic.keys() \\\n\tor len(irq_dic[cpu]) == 0:\n\t\treturn\n\tirq_record = irq_dic[cpu].pop()\n\tif 'event_list' in irq_record.keys():\n\t\tirq_event_list = irq_record['event_list']\n\telse:\n\t\tirq_event_list = []\n\tirq_event_list.append({'time':time, 'event':'netif_rx',\n\t\t'skbaddr':skbaddr, 'skblen':skblen, 'dev_name':dev_name})\n\tirq_record.update({'event_list':irq_event_list})\n\tirq_dic[cpu].append(irq_record)\n\ndef handle_netif_receive_skb(event_info):\n\tglobal of_count_rx_skb_list\n\n\t(name, context, cpu, time, pid, comm,\n\t\tskbaddr, skblen, dev_name) = event_info\n\tif cpu in net_rx_dic.keys():\n\t\trec_data = {'event_name':'netif_receive_skb',\n\t\t\t\t'event_t':time, 'skbaddr':skbaddr, 'len':skblen}\n\t\tevent_list = net_rx_dic[cpu]['event_list']\n\t\tevent_list.append(rec_data)\n\t\trx_skb_list.insert(0, rec_data)\n\t\tif len(rx_skb_list) > buffer_budget:\n\t\t\trx_skb_list.pop()\n\t\t\tof_count_rx_skb_list += 1\n\ndef handle_net_dev_queue(event_info):\n\tglobal of_count_tx_queue_list\n\n\t(name, context, cpu, time, pid, comm,\n\t\tskbaddr, skblen, dev_name) = event_info\n\tskb = {'dev':dev_name, 'skbaddr':skbaddr, 'len':skblen, 'queue_t':time}\n\ttx_queue_list.insert(0, skb)\n\tif len(tx_queue_list) > buffer_budget:\n\t\ttx_queue_list.pop()\n\t\tof_count_tx_queue_list += 1\n\ndef handle_net_dev_xmit(event_info):\n\tglobal of_count_tx_xmit_list\n\n\t(name, context, cpu, time, pid, comm,\n\t\tskbaddr, skblen, rc, dev_name) = event_info\n\tif rc == 0: # NETDEV_TX_OK\n\t\tfor i in range(len(tx_queue_list)):\n\t\t\tskb = tx_queue_list[i]\n\t\t\tif skb['skbaddr'] == skbaddr:\n\t\t\t\tskb['xmit_t'] = time\n\t\t\t\ttx_xmit_list.insert(0, skb)\n\t\t\t\tdel tx_queue_list[i]\n\t\t\t\tif len(tx_xmit_list) > buffer_budget:\n\t\t\t\t\ttx_xmit_list.pop()\n\t\t\t\t\tof_count_tx_xmit_list += 1\n\t\t\t\treturn\n\ndef handle_kfree_skb(event_info):\n\t(name, context, cpu, time, pid, comm,\n\t\tskbaddr, location, protocol, reason) = event_info\n\tfor i in range(len(tx_queue_list)):\n\t\tskb = tx_queue_list[i]\n\t\tif skb['skbaddr'] == skbaddr:\n\t\t\tdel tx_queue_list[i]\n\t\t\treturn\n\tfor i in range(len(tx_xmit_list)):\n\t\tskb = tx_xmit_list[i]\n\t\tif skb['skbaddr'] == skbaddr:\n\t\t\tskb['free_t'] = time\n\t\t\ttx_free_list.append(skb)\n\t\t\tdel tx_xmit_list[i]\n\t\t\treturn\n\tfor i in range(len(rx_skb_list)):\n\t\trec_data = rx_skb_list[i]\n\t\tif rec_data['skbaddr'] == skbaddr:\n\t\t\trec_data.update({'handle':\"kfree_skb\",\n\t\t\t\t\t'comm':comm, 'pid':pid, 'comm_t':time})\n\t\t\tdel rx_skb_list[i]\n\t\t\treturn\n\ndef handle_consume_skb(event_info):\n\t(name, context, cpu, time, pid, comm, skbaddr) = event_info\n\tfor i in range(len(tx_xmit_list)):\n\t\tskb = tx_xmit_list[i]\n\t\tif skb['skbaddr'] == skbaddr:\n\t\t\tskb['free_t'] = time\n\t\t\ttx_free_list.append(skb)\n\t\t\tdel tx_xmit_list[i]\n\t\t\treturn\n\ndef handle_skb_copy_datagram_iovec(event_info):\n\t(name, context, cpu, time, pid, comm, skbaddr, skblen) = event_info\n\tfor i in range(len(rx_skb_list)):\n\t\trec_data = rx_skb_list[i]\n\t\tif skbaddr == rec_data['skbaddr']:\n\t\t\trec_data.update({'handle':\"skb_copy_datagram_iovec\",\n\t\t\t\t\t'comm':comm, 'pid':pid, 'comm_t':time})\n\t\t\tdel rx_skb_list[i]\n\t\t\treturn\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}