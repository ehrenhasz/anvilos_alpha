{
  "module_name": "event_analyzing_sample.py",
  "hash_id": "61d3b5b901d300c8b00913b5ed4f7b839efe07e57c99cac7840e9bad926f99ad",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/event_analyzing_sample.py",
  "human_readable_source": "# event_analyzing_sample.py: general event handler in python\n# SPDX-License-Identifier: GPL-2.0\n#\n# Current perf report is already very powerful with the annotation integrated,\n# and this script is not trying to be as powerful as perf report, but\n# providing end user/developer a flexible way to analyze the events other\n# than trace points.\n#\n# The 2 database related functions in this script just show how to gather\n# the basic information, and users can modify and write their own functions\n# according to their specific requirement.\n#\n# The first function \"show_general_events\" just does a basic grouping for all\n# generic events with the help of sqlite, and the 2nd one \"show_pebs_ll\" is\n# for a x86 HW PMU event: PEBS with load latency data.\n#\n\nfrom __future__ import print_function\n\nimport os\nimport sys\nimport math\nimport struct\nimport sqlite3\n\nsys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n        '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\nfrom perf_trace_context import *\nfrom EventClass import *\n\n#\n# If the perf.data has a big number of samples, then the insert operation\n# will be very time consuming (about 10+ minutes for 10000 samples) if the\n# .db database is on disk. Move the .db file to RAM based FS to speedup\n# the handling, which will cut the time down to several seconds.\n#\ncon = sqlite3.connect(\"/dev/shm/perf.db\")\ncon.isolation_level = None\n\ndef trace_begin():\n        print(\"In trace_begin:\\n\")\n\n        #\n        # Will create several tables at the start, pebs_ll is for PEBS data with\n        # load latency info, while gen_events is for general event.\n        #\n        con.execute(\"\"\"\n                create table if not exists gen_events (\n                        name text,\n                        symbol text,\n                        comm text,\n                        dso text\n                );\"\"\")\n        con.execute(\"\"\"\n                create table if not exists pebs_ll (\n                        name text,\n                        symbol text,\n                        comm text,\n                        dso text,\n                        flags integer,\n                        ip integer,\n                        status integer,\n                        dse integer,\n                        dla integer,\n                        lat integer\n                );\"\"\")\n\n#\n# Create and insert event object to a database so that user could\n# do more analysis with simple database commands.\n#\ndef process_event(param_dict):\n        event_attr = param_dict[\"attr\"]\n        sample     = param_dict[\"sample\"]\n        raw_buf    = param_dict[\"raw_buf\"]\n        comm       = param_dict[\"comm\"]\n        name       = param_dict[\"ev_name\"]\n\n        # Symbol and dso info are not always resolved\n        if (\"dso\" in param_dict):\n                dso = param_dict[\"dso\"]\n        else:\n                dso = \"Unknown_dso\"\n\n        if (\"symbol\" in param_dict):\n                symbol = param_dict[\"symbol\"]\n        else:\n                symbol = \"Unknown_symbol\"\n\n        # Create the event object and insert it to the right table in database\n        event = create_event(name, comm, dso, symbol, raw_buf)\n        insert_db(event)\n\ndef insert_db(event):\n        if event.ev_type == EVTYPE_GENERIC:\n                con.execute(\"insert into gen_events values(?, ?, ?, ?)\",\n                                (event.name, event.symbol, event.comm, event.dso))\n        elif event.ev_type == EVTYPE_PEBS_LL:\n                event.ip &= 0x7fffffffffffffff\n                event.dla &= 0x7fffffffffffffff\n                con.execute(\"insert into pebs_ll values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n                        (event.name, event.symbol, event.comm, event.dso, event.flags,\n                                event.ip, event.status, event.dse, event.dla, event.lat))\n\ndef trace_end():\n        print(\"In trace_end:\\n\")\n        # We show the basic info for the 2 type of event classes\n        show_general_events()\n        show_pebs_ll()\n        con.close()\n\n#\n# As the event number may be very big, so we can't use linear way\n# to show the histogram in real number, but use a log2 algorithm.\n#\n\ndef num2sym(num):\n        # Each number will have at least one '#'\n        snum = '#' * (int)(math.log(num, 2) + 1)\n        return snum\n\ndef show_general_events():\n\n        # Check the total record number in the table\n        count = con.execute(\"select count(*) from gen_events\")\n        for t in count:\n                print(\"There is %d records in gen_events table\" % t[0])\n                if t[0] == 0:\n                        return\n\n        print(\"Statistics about the general events grouped by thread/symbol/dso: \\n\")\n\n         # Group by thread\n        commq = con.execute(\"select comm, count(comm) from gen_events group by comm order by -count(comm)\")\n        print(\"\\n%16s %8s %16s\\n%s\" % (\"comm\", \"number\", \"histogram\", \"=\"*42))\n        for row in commq:\n             print(\"%16s %8d     %s\" % (row[0], row[1], num2sym(row[1])))\n\n        # Group by symbol\n        print(\"\\n%32s %8s %16s\\n%s\" % (\"symbol\", \"number\", \"histogram\", \"=\"*58))\n        symbolq = con.execute(\"select symbol, count(symbol) from gen_events group by symbol order by -count(symbol)\")\n        for row in symbolq:\n             print(\"%32s %8d     %s\" % (row[0], row[1], num2sym(row[1])))\n\n        # Group by dso\n        print(\"\\n%40s %8s %16s\\n%s\" % (\"dso\", \"number\", \"histogram\", \"=\"*74))\n        dsoq = con.execute(\"select dso, count(dso) from gen_events group by dso order by -count(dso)\")\n        for row in dsoq:\n             print(\"%40s %8d     %s\" % (row[0], row[1], num2sym(row[1])))\n\n#\n# This function just shows the basic info, and we could do more with the\n# data in the tables, like checking the function parameters when some\n# big latency events happen.\n#\ndef show_pebs_ll():\n\n        count = con.execute(\"select count(*) from pebs_ll\")\n        for t in count:\n                print(\"There is %d records in pebs_ll table\" % t[0])\n                if t[0] == 0:\n                        return\n\n        print(\"Statistics about the PEBS Load Latency events grouped by thread/symbol/dse/latency: \\n\")\n\n        # Group by thread\n        commq = con.execute(\"select comm, count(comm) from pebs_ll group by comm order by -count(comm)\")\n        print(\"\\n%16s %8s %16s\\n%s\" % (\"comm\", \"number\", \"histogram\", \"=\"*42))\n        for row in commq:\n             print(\"%16s %8d     %s\" % (row[0], row[1], num2sym(row[1])))\n\n        # Group by symbol\n        print(\"\\n%32s %8s %16s\\n%s\" % (\"symbol\", \"number\", \"histogram\", \"=\"*58))\n        symbolq = con.execute(\"select symbol, count(symbol) from pebs_ll group by symbol order by -count(symbol)\")\n        for row in symbolq:\n             print(\"%32s %8d     %s\" % (row[0], row[1], num2sym(row[1])))\n\n        # Group by dse\n        dseq = con.execute(\"select dse, count(dse) from pebs_ll group by dse order by -count(dse)\")\n        print(\"\\n%32s %8s %16s\\n%s\" % (\"dse\", \"number\", \"histogram\", \"=\"*58))\n        for row in dseq:\n             print(\"%32s %8d     %s\" % (row[0], row[1], num2sym(row[1])))\n\n        # Group by latency\n        latq = con.execute(\"select lat, count(lat) from pebs_ll group by lat order by lat\")\n        print(\"\\n%32s %8s %16s\\n%s\" % (\"latency\", \"number\", \"histogram\", \"=\"*58))\n        for row in latq:\n             print(\"%32s %8d     %s\" % (row[0], row[1], num2sym(row[1])))\n\ndef trace_unhandled(event_name, context, event_fields_dict):\n        print (' '.join(['%s=%s'%(k,str(v))for k,v in sorted(event_fields_dict.items())]))\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}