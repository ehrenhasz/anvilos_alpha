{
  "module_name": "intel-pt-events.py",
  "hash_id": "18efeee0f750e544fca661f761521a31204b732f4ee7d89e7612dc77fc47b734",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/intel-pt-events.py",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n# intel-pt-events.py: Print Intel PT Events including Power Events and PTWRITE\n# Copyright (c) 2017-2021, Intel Corporation.\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms and conditions of the GNU General Public License,\n# version 2, as published by the Free Software Foundation.\n#\n# This program is distributed in the hope it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n# more details.\n\nfrom __future__ import division, print_function\n\nimport io\nimport os\nimport sys\nimport struct\nimport argparse\nimport contextlib\n\nfrom libxed import LibXED\nfrom ctypes import create_string_buffer, addressof\n\nsys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n\t'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\nfrom perf_trace_context import perf_set_itrace_options, \\\n\tperf_sample_insn, perf_sample_srccode\n\ntry:\n\tbroken_pipe_exception = BrokenPipeError\nexcept:\n\tbroken_pipe_exception = IOError\n\nglb_switch_str\t\t= {}\nglb_insn\t\t= False\nglb_disassembler\t= None\nglb_src\t\t\t= False\nglb_source_file_name\t= None\nglb_line_number\t\t= None\nglb_dso\t\t\t= None\nglb_stash_dict\t\t= {}\nglb_output\t\t= None\nglb_output_pos\t\t= 0\nglb_cpu\t\t\t= -1\nglb_time\t\t= 0\n\ndef get_optional_null(perf_dict, field):\n\tif field in perf_dict:\n\t\treturn perf_dict[field]\n\treturn \"\"\n\ndef get_optional_zero(perf_dict, field):\n\tif field in perf_dict:\n\t\treturn perf_dict[field]\n\treturn 0\n\ndef get_optional_bytes(perf_dict, field):\n\tif field in perf_dict:\n\t\treturn perf_dict[field]\n\treturn bytes()\n\ndef get_optional(perf_dict, field):\n\tif field in perf_dict:\n\t\treturn perf_dict[field]\n\treturn \"[unknown]\"\n\ndef get_offset(perf_dict, field):\n\tif field in perf_dict:\n\t\treturn \"+%#x\" % perf_dict[field]\n\treturn \"\"\n\ndef trace_begin():\n\tap = argparse.ArgumentParser(usage = \"\", add_help = False)\n\tap.add_argument(\"--insn-trace\", action='store_true')\n\tap.add_argument(\"--src-trace\", action='store_true')\n\tap.add_argument(\"--all-switch-events\", action='store_true')\n\tap.add_argument(\"--interleave\", type=int, nargs='?', const=4, default=0)\n\tglobal glb_args\n\tglobal glb_insn\n\tglobal glb_src\n\tglb_args = ap.parse_args()\n\tif glb_args.insn_trace:\n\t\tprint(\"Intel PT Instruction Trace\")\n\t\titrace = \"i0nsepwxI\"\n\t\tglb_insn = True\n\telif glb_args.src_trace:\n\t\tprint(\"Intel PT Source Trace\")\n\t\titrace = \"i0nsepwxI\"\n\t\tglb_insn = True\n\t\tglb_src = True\n\telse:\n\t\tprint(\"Intel PT Branch Trace, Power Events, Event Trace and PTWRITE\")\n\t\titrace = \"bepwxI\"\n\tglobal glb_disassembler\n\ttry:\n\t\tglb_disassembler = LibXED()\n\texcept:\n\t\tglb_disassembler = None\n\tperf_set_itrace_options(perf_script_context, itrace)\n\ndef trace_end():\n\tif glb_args.interleave:\n\t\tflush_stashed_output()\n\tprint(\"End\")\n\ndef trace_unhandled(event_name, context, event_fields_dict):\n\t\tprint(' '.join(['%s=%s'%(k,str(v))for k,v in sorted(event_fields_dict.items())]))\n\ndef stash_output():\n\tglobal glb_stash_dict\n\tglobal glb_output_pos\n\toutput_str = glb_output.getvalue()[glb_output_pos:]\n\tn = len(output_str)\n\tif n:\n\t\tglb_output_pos += n\n\t\tif glb_cpu not in glb_stash_dict:\n\t\t\tglb_stash_dict[glb_cpu] = []\n\t\tglb_stash_dict[glb_cpu].append(output_str)\n\ndef flush_stashed_output():\n\tglobal glb_stash_dict\n\twhile glb_stash_dict:\n\t\tcpus = list(glb_stash_dict.keys())\n\t\t# Output at most glb_args.interleave output strings per cpu\n\t\tfor cpu in cpus:\n\t\t\titems = glb_stash_dict[cpu]\n\t\t\tcountdown = glb_args.interleave\n\t\t\twhile len(items) and countdown:\n\t\t\t\tsys.stdout.write(items[0])\n\t\t\t\tdel items[0]\n\t\t\t\tcountdown -= 1\n\t\t\tif not items:\n\t\t\t\tdel glb_stash_dict[cpu]\n\ndef print_ptwrite(raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\tflags = data[0]\n\tpayload = data[1]\n\texact_ip = flags & 1\n\ttry:\n\t\ts = payload.to_bytes(8, \"little\").decode(\"ascii\").rstrip(\"\\x00\")\n\t\tif not s.isprintable():\n\t\t\ts = \"\"\n\texcept:\n\t\ts = \"\"\n\tprint(\"IP: %u payload: %#x\" % (exact_ip, payload), s, end=' ')\n\ndef print_cbr(raw_buf):\n\tdata = struct.unpack_from(\"<BBBBII\", raw_buf)\n\tcbr = data[0]\n\tf = (data[4] + 500) / 1000\n\tp = ((cbr * 1000 / data[2]) + 5) / 10\n\tprint(\"%3u  freq: %4u MHz  (%3u%%)\" % (cbr, f, p), end=' ')\n\ndef print_mwait(raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\tpayload = data[1]\n\thints = payload & 0xff\n\textensions = (payload >> 32) & 0x3\n\tprint(\"hints: %#x extensions: %#x\" % (hints, extensions), end=' ')\n\ndef print_pwre(raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\tpayload = data[1]\n\thw = (payload >> 7) & 1\n\tcstate = (payload >> 12) & 0xf\n\tsubcstate = (payload >> 8) & 0xf\n\tprint(\"hw: %u cstate: %u sub-cstate: %u\" % (hw, cstate, subcstate),\n\t\tend=' ')\n\ndef print_exstop(raw_buf):\n\tdata = struct.unpack_from(\"<I\", raw_buf)\n\tflags = data[0]\n\texact_ip = flags & 1\n\tprint(\"IP: %u\" % (exact_ip), end=' ')\n\ndef print_pwrx(raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\tpayload = data[1]\n\tdeepest_cstate = payload & 0xf\n\tlast_cstate = (payload >> 4) & 0xf\n\twake_reason = (payload >> 8) & 0xf\n\tprint(\"deepest cstate: %u last cstate: %u wake reason: %#x\" %\n\t\t(deepest_cstate, last_cstate, wake_reason), end=' ')\n\ndef print_psb(raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\toffset = data[1]\n\tprint(\"offset: %#x\" % (offset), end=' ')\n\nglb_cfe = [\"\", \"INTR\", \"IRET\", \"SMI\", \"RSM\", \"SIPI\", \"INIT\", \"VMENTRY\", \"VMEXIT\",\n\t\t\"VMEXIT_INTR\", \"SHUTDOWN\", \"\", \"UINT\", \"UIRET\"] + [\"\"] * 18\nglb_evd = [\"\", \"PFA\", \"VMXQ\", \"VMXR\"] + [\"\"] * 60\n\ndef print_evt(raw_buf):\n\tdata = struct.unpack_from(\"<BBH\", raw_buf)\n\ttyp = data[0] & 0x1f\n\tip_flag = (data[0] & 0x80) >> 7\n\tvector = data[1]\n\tevd_cnt = data[2]\n\ts = glb_cfe[typ]\n\tif s:\n\t\tprint(\" cfe: %s IP: %u vector: %u\" % (s, ip_flag, vector), end=' ')\n\telse:\n\t\tprint(\" cfe: %u IP: %u vector: %u\" % (typ, ip_flag, vector), end=' ')\n\tpos = 4\n\tfor i in range(evd_cnt):\n\t\tdata = struct.unpack_from(\"<QQ\", raw_buf)\n\t\tet = data[0] & 0x3f\n\t\ts = glb_evd[et]\n\t\tif s:\n\t\t\tprint(\"%s: %#x\" % (s, data[1]), end=' ')\n\t\telse:\n\t\t\tprint(\"EVD_%u: %#x\" % (et, data[1]), end=' ')\n\ndef print_iflag(raw_buf):\n\tdata = struct.unpack_from(\"<IQ\", raw_buf)\n\tiflag = data[0] & 1\n\told_iflag = iflag ^ 1\n\tvia_branch = data[0] & 2\n\tbranch_ip = data[1]\n\tif via_branch:\n\t\ts = \"via\"\n\telse:\n\t\ts = \"non\"\n\tprint(\"IFLAG: %u->%u %s branch\" % (old_iflag, iflag, s), end=' ')\n\ndef common_start_str(comm, sample):\n\tts = sample[\"time\"]\n\tcpu = sample[\"cpu\"]\n\tpid = sample[\"pid\"]\n\ttid = sample[\"tid\"]\n\tif \"machine_pid\" in sample:\n\t\tmachine_pid = sample[\"machine_pid\"]\n\t\tvcpu = sample[\"vcpu\"]\n\t\treturn \"VM:%5d VCPU:%03d %16s %5u/%-5u [%03u] %9u.%09u  \" % (machine_pid, vcpu, comm, pid, tid, cpu, ts / 1000000000, ts %1000000000)\n\telse:\n\t\treturn \"%16s %5u/%-5u [%03u] %9u.%09u  \" % (comm, pid, tid, cpu, ts / 1000000000, ts %1000000000)\n\ndef print_common_start(comm, sample, name):\n\tflags_disp = get_optional_null(sample, \"flags_disp\")\n\t# Unused fields:\n\t# period      = sample[\"period\"]\n\t# phys_addr   = sample[\"phys_addr\"]\n\t# weight      = sample[\"weight\"]\n\t# transaction = sample[\"transaction\"]\n\t# cpumode     = get_optional_zero(sample, \"cpumode\")\n\tprint(common_start_str(comm, sample) + \"%8s  %21s\" % (name, flags_disp), end=' ')\n\ndef print_instructions_start(comm, sample):\n\tif \"x\" in get_optional_null(sample, \"flags\"):\n\t\tprint(common_start_str(comm, sample) + \"x\", end=' ')\n\telse:\n\t\tprint(common_start_str(comm, sample), end='  ')\n\ndef disassem(insn, ip):\n\tinst = glb_disassembler.Instruction()\n\tglb_disassembler.SetMode(inst, 0) # Assume 64-bit\n\tbuf = create_string_buffer(64)\n\tbuf.value = insn\n\treturn glb_disassembler.DisassembleOne(inst, addressof(buf), len(insn), ip)\n\ndef print_common_ip(param_dict, sample, symbol, dso):\n\tip   = sample[\"ip\"]\n\toffs = get_offset(param_dict, \"symoff\")\n\tif \"cyc_cnt\" in sample:\n\t\tcyc_cnt = sample[\"cyc_cnt\"]\n\t\tinsn_cnt = get_optional_zero(sample, \"insn_cnt\")\n\t\tipc_str = \"  IPC: %#.2f (%u/%u)\" % (insn_cnt / cyc_cnt, insn_cnt, cyc_cnt)\n\telse:\n\t\tipc_str = \"\"\n\tif glb_insn and glb_disassembler is not None:\n\t\tinsn = perf_sample_insn(perf_script_context)\n\t\tif insn and len(insn):\n\t\t\tcnt, text = disassem(insn, ip)\n\t\t\tbyte_str = (\"%x\" % ip).rjust(16)\n\t\t\tif sys.version_info.major >= 3:\n\t\t\t\tfor k in range(cnt):\n\t\t\t\t\tbyte_str += \" %02x\" % insn[k]\n\t\t\telse:\n\t\t\t\tfor k in xrange(cnt):\n\t\t\t\t\tbyte_str += \" %02x\" % ord(insn[k])\n\t\t\tprint(\"%-40s  %-30s\" % (byte_str, text), end=' ')\n\t\tprint(\"%s%s (%s)\" % (symbol, offs, dso), end=' ')\n\telse:\n\t\tprint(\"%16x %s%s (%s)\" % (ip, symbol, offs, dso), end=' ')\n\tif \"addr_correlates_sym\" in sample:\n\t\taddr   = sample[\"addr\"]\n\t\tdso    = get_optional(sample, \"addr_dso\")\n\t\tsymbol = get_optional(sample, \"addr_symbol\")\n\t\toffs   = get_offset(sample, \"addr_symoff\")\n\t\tprint(\"=> %x %s%s (%s)%s\" % (addr, symbol, offs, dso, ipc_str))\n\telse:\n\t\tprint(ipc_str)\n\ndef print_srccode(comm, param_dict, sample, symbol, dso, with_insn):\n\tip = sample[\"ip\"]\n\tif symbol == \"[unknown]\":\n\t\tstart_str = common_start_str(comm, sample) + (\"%x\" % ip).rjust(16).ljust(40)\n\telse:\n\t\toffs = get_offset(param_dict, \"symoff\")\n\t\tstart_str = common_start_str(comm, sample) + (symbol + offs).ljust(40)\n\n\tif with_insn and glb_insn and glb_disassembler is not None:\n\t\tinsn = perf_sample_insn(perf_script_context)\n\t\tif insn and len(insn):\n\t\t\tcnt, text = disassem(insn, ip)\n\t\tstart_str += text.ljust(30)\n\n\tglobal glb_source_file_name\n\tglobal glb_line_number\n\tglobal glb_dso\n\n\tsource_file_name, line_number, source_line = perf_sample_srccode(perf_script_context)\n\tif source_file_name:\n\t\tif glb_line_number == line_number and glb_source_file_name == source_file_name:\n\t\t\tsrc_str = \"\"\n\t\telse:\n\t\t\tif len(source_file_name) > 40:\n\t\t\t\tsrc_file = (\"...\" + source_file_name[-37:]) + \" \"\n\t\t\telse:\n\t\t\t\tsrc_file = source_file_name.ljust(41)\n\t\t\tif source_line is None:\n\t\t\t\tsrc_str = src_file + str(line_number).rjust(4) + \" <source not found>\"\n\t\t\telse:\n\t\t\t\tsrc_str = src_file + str(line_number).rjust(4) + \" \" + source_line\n\t\tglb_dso = None\n\telif dso == glb_dso:\n\t\tsrc_str = \"\"\n\telse:\n\t\tsrc_str = dso\n\t\tglb_dso = dso\n\n\tglb_line_number = line_number\n\tglb_source_file_name = source_file_name\n\n\tprint(start_str, src_str)\n\ndef do_process_event(param_dict):\n\tsample\t   = param_dict[\"sample\"]\n\traw_buf\t   = param_dict[\"raw_buf\"]\n\tcomm\t   = param_dict[\"comm\"]\n\tname\t   = param_dict[\"ev_name\"]\n\t# Unused fields:\n\t# callchain  = param_dict[\"callchain\"]\n\t# brstack    = param_dict[\"brstack\"]\n\t# brstacksym = param_dict[\"brstacksym\"]\n\t# event_attr = param_dict[\"attr\"]\n\n\t# Symbol and dso info are not always resolved\n\tdso    = get_optional(param_dict, \"dso\")\n\tsymbol = get_optional(param_dict, \"symbol\")\n\n\tcpu = sample[\"cpu\"]\n\tif cpu in glb_switch_str:\n\t\tprint(glb_switch_str[cpu])\n\t\tdel glb_switch_str[cpu]\n\n\tif name.startswith(\"instructions\"):\n\t\tif glb_src:\n\t\t\tprint_srccode(comm, param_dict, sample, symbol, dso, True)\n\t\telse:\n\t\t\tprint_instructions_start(comm, sample)\n\t\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name.startswith(\"branches\"):\n\t\tif glb_src:\n\t\t\tprint_srccode(comm, param_dict, sample, symbol, dso, False)\n\t\telse:\n\t\t\tprint_common_start(comm, sample, name)\n\t\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name == \"ptwrite\":\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_ptwrite(raw_buf)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name == \"cbr\":\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_cbr(raw_buf)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name == \"mwait\":\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_mwait(raw_buf)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name == \"pwre\":\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_pwre(raw_buf)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name == \"exstop\":\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_exstop(raw_buf)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name == \"pwrx\":\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_pwrx(raw_buf)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name == \"psb\":\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_psb(raw_buf)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name == \"evt\":\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_evt(raw_buf)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telif name == \"iflag\":\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_iflag(raw_buf)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\telse:\n\t\tprint_common_start(comm, sample, name)\n\t\tprint_common_ip(param_dict, sample, symbol, dso)\n\ndef interleave_events(param_dict):\n\tglobal glb_cpu\n\tglobal glb_time\n\tglobal glb_output\n\tglobal glb_output_pos\n\n\tsample  = param_dict[\"sample\"]\n\tglb_cpu = sample[\"cpu\"]\n\tts      = sample[\"time\"]\n\n\tif glb_time != ts:\n\t\tglb_time = ts\n\t\tflush_stashed_output()\n\n\tglb_output_pos = 0\n\twith contextlib.redirect_stdout(io.StringIO()) as glb_output:\n\t\tdo_process_event(param_dict)\n\n\tstash_output()\n\ndef process_event(param_dict):\n\ttry:\n\t\tif glb_args.interleave:\n\t\t\tinterleave_events(param_dict)\n\t\telse:\n\t\t\tdo_process_event(param_dict)\n\texcept broken_pipe_exception:\n\t\t# Stop python printing broken pipe errors and traceback\n\t\tsys.stdout = open(os.devnull, 'w')\n\t\tsys.exit(1)\n\ndef auxtrace_error(typ, code, cpu, pid, tid, ip, ts, msg, cpumode, *x):\n\tif glb_args.interleave:\n\t\tflush_stashed_output()\n\tif len(x) >= 2 and x[0]:\n\t\tmachine_pid = x[0]\n\t\tvcpu = x[1]\n\telse:\n\t\tmachine_pid = 0\n\t\tvcpu = -1\n\ttry:\n\t\tif machine_pid:\n\t\t\tprint(\"VM:%5d VCPU:%03d %16s %5u/%-5u [%03u] %9u.%09u  error type %u code %u: %s ip 0x%16x\" %\n\t\t\t\t(machine_pid, vcpu, \"Trace error\", pid, tid, cpu, ts / 1000000000, ts %1000000000, typ, code, msg, ip))\n\t\telse:\n\t\t\tprint(\"%16s %5u/%-5u [%03u] %9u.%09u  error type %u code %u: %s ip 0x%16x\" %\n\t\t\t\t(\"Trace error\", pid, tid, cpu, ts / 1000000000, ts %1000000000, typ, code, msg, ip))\n\texcept broken_pipe_exception:\n\t\t# Stop python printing broken pipe errors and traceback\n\t\tsys.stdout = open(os.devnull, 'w')\n\t\tsys.exit(1)\n\ndef context_switch(ts, cpu, pid, tid, np_pid, np_tid, machine_pid, out, out_preempt, *x):\n\tif glb_args.interleave:\n\t\tflush_stashed_output()\n\tif out:\n\t\tout_str = \"Switch out \"\n\telse:\n\t\tout_str = \"Switch In  \"\n\tif out_preempt:\n\t\tpreempt_str = \"preempt\"\n\telse:\n\t\tpreempt_str = \"\"\n\tif len(x) >= 2 and x[0]:\n\t\tmachine_pid = x[0]\n\t\tvcpu = x[1]\n\telse:\n\t\tvcpu = None;\n\tif machine_pid == -1:\n\t\tmachine_str = \"\"\n\telif vcpu is None:\n\t\tmachine_str = \"machine PID %d\" % machine_pid\n\telse:\n\t\tmachine_str = \"machine PID %d VCPU %d\" % (machine_pid, vcpu)\n\tswitch_str = \"%16s %5d/%-5d [%03u] %9u.%09u %5d/%-5d %s %s\" % \\\n\t\t(out_str, pid, tid, cpu, ts / 1000000000, ts %1000000000, np_pid, np_tid, machine_str, preempt_str)\n\tif glb_args.all_switch_events:\n\t\tprint(switch_str)\n\telse:\n\t\tglobal glb_switch_str\n\t\tglb_switch_str[cpu] = switch_str\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}