{
  "module_name": "mem-phys-addr.py",
  "hash_id": "9bdfe79f4468cc2b860dbb680ad9eb703d14dbd036a15ad17e8e125809d687ca",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/python/mem-phys-addr.py",
  "human_readable_source": "# mem-phys-addr.py: Resolve physical address samples\n# SPDX-License-Identifier: GPL-2.0\n#\n# Copyright (c) 2018, Intel Corporation.\n\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport os\nimport sys\nimport struct\nimport re\nimport bisect\nimport collections\n\nsys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n\t'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n\n#physical address ranges for System RAM\nsystem_ram = []\n#physical address ranges for Persistent Memory\npmem = []\n#file object for proc iomem\nf = None\n#Count for each type of memory\nload_mem_type_cnt = collections.Counter()\n#perf event name\nevent_name = None\n\ndef parse_iomem():\n\tglobal f\n\tf = open('/proc/iomem', 'r')\n\tfor i, j in enumerate(f):\n\t\tm = re.split('-|:',j,2)\n\t\tif m[2].strip() == 'System RAM':\n\t\t\tsystem_ram.append(int(m[0], 16))\n\t\t\tsystem_ram.append(int(m[1], 16))\n\t\tif m[2].strip() == 'Persistent Memory':\n\t\t\tpmem.append(int(m[0], 16))\n\t\t\tpmem.append(int(m[1], 16))\n\ndef print_memory_type():\n\tprint(\"Event: %s\" % (event_name))\n\tprint(\"%-40s  %10s  %10s\\n\" % (\"Memory type\", \"count\", \"percentage\"), end='')\n\tprint(\"%-40s  %10s  %10s\\n\" % (\"----------------------------------------\",\n\t\t\t\t\t\"-----------\", \"-----------\"),\n\t\t\t\t\tend='');\n\ttotal = sum(load_mem_type_cnt.values())\n\tfor mem_type, count in sorted(load_mem_type_cnt.most_common(), \\\n\t\t\t\t\tkey = lambda kv: (kv[1], kv[0]), reverse = True):\n\t\tprint(\"%-40s  %10d  %10.1f%%\\n\" %\n\t\t\t(mem_type, count, 100 * count / total),\n\t\t\tend='')\n\ndef trace_begin():\n\tparse_iomem()\n\ndef trace_end():\n\tprint_memory_type()\n\tf.close()\n\ndef is_system_ram(phys_addr):\n\t#/proc/iomem is sorted\n\tposition = bisect.bisect(system_ram, phys_addr)\n\tif position % 2 == 0:\n\t\treturn False\n\treturn True\n\ndef is_persistent_mem(phys_addr):\n\tposition = bisect.bisect(pmem, phys_addr)\n\tif position % 2 == 0:\n\t\treturn False\n\treturn True\n\ndef find_memory_type(phys_addr):\n\tif phys_addr == 0:\n\t\treturn \"N/A\"\n\tif is_system_ram(phys_addr):\n\t\treturn \"System RAM\"\n\n\tif is_persistent_mem(phys_addr):\n\t\treturn \"Persistent Memory\"\n\n\t#slow path, search all\n\tf.seek(0, 0)\n\tfor j in f:\n\t\tm = re.split('-|:',j,2)\n\t\tif int(m[0], 16) <= phys_addr <= int(m[1], 16):\n\t\t\treturn m[2]\n\treturn \"N/A\"\n\ndef process_event(param_dict):\n\tname       = param_dict[\"ev_name\"]\n\tsample     = param_dict[\"sample\"]\n\tphys_addr  = sample[\"phys_addr\"]\n\n\tglobal event_name\n\tif event_name == None:\n\t\tevent_name = name\n\tload_mem_type_cnt[find_memory_type(phys_addr)] += 1\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}