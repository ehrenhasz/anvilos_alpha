{
  "module_name": "rw-by-file.pl",
  "hash_id": "d8c52b30842786b65a95a694091637879afd86e7c18ff154705ebb437c910ab1",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/perl/rw-by-file.pl",
  "human_readable_source": "#!/usr/bin/perl -w\n# SPDX-License-Identifier: GPL-2.0-only\n# (c) 2009, Tom Zanussi <tzanussi@gmail.com>\n\n# Display r/w activity for files read/written to for a given program\n\n# The common_* event handler fields are the most useful fields common to\n# all events.  They don't necessarily correspond to the 'common_*' fields\n# in the status files.  Those fields not available as handler params can\n# be retrieved via script functions of the form get_common_*().\n\nuse 5.010000;\nuse strict;\nuse warnings;\n\nuse lib \"$ENV{'PERF_EXEC_PATH'}/scripts/perl/Perf-Trace-Util/lib\";\nuse lib \"./Perf-Trace-Util/lib\";\nuse Perf::Trace::Core;\nuse Perf::Trace::Util;\n\nmy $usage = \"perf script -s rw-by-file.pl <comm>\\n\";\n\nmy $for_comm = shift or die $usage;\n\nmy %reads;\nmy %writes;\n\nsub syscalls::sys_enter_read\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain, $nr, $fd, $buf, $count) = @_;\n\n    if ($common_comm eq $for_comm) {\n\t$reads{$fd}{bytes_requested} += $count;\n\t$reads{$fd}{total_reads}++;\n    }\n}\n\nsub syscalls::sys_enter_write\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain, $nr, $fd, $buf, $count) = @_;\n\n    if ($common_comm eq $for_comm) {\n\t$writes{$fd}{bytes_written} += $count;\n\t$writes{$fd}{total_writes}++;\n    }\n}\n\nsub trace_end\n{\n    printf(\"file read counts for $for_comm:\\n\\n\");\n\n    printf(\"%6s  %10s  %10s\\n\", \"fd\", \"# reads\", \"bytes_requested\");\n    printf(\"%6s  %10s  %10s\\n\", \"------\", \"----------\", \"-----------\");\n\n    foreach my $fd (sort {$reads{$b}{bytes_requested} <=>\n\t\t\t      $reads{$a}{bytes_requested}} keys %reads) {\n\tmy $total_reads = $reads{$fd}{total_reads};\n\tmy $bytes_requested = $reads{$fd}{bytes_requested};\n\tprintf(\"%6u  %10u  %10u\\n\", $fd, $total_reads, $bytes_requested);\n    }\n\n    printf(\"\\nfile write counts for $for_comm:\\n\\n\");\n\n    printf(\"%6s  %10s  %10s\\n\", \"fd\", \"# writes\", \"bytes_written\");\n    printf(\"%6s  %10s  %10s\\n\", \"------\", \"----------\", \"-----------\");\n\n    foreach my $fd (sort {$writes{$b}{bytes_written} <=>\n\t\t\t      $writes{$a}{bytes_written}} keys %writes) {\n\tmy $total_writes = $writes{$fd}{total_writes};\n\tmy $bytes_written = $writes{$fd}{bytes_written};\n\tprintf(\"%6u  %10u  %10u\\n\", $fd, $total_writes, $bytes_written);\n    }\n\n    print_unhandled();\n}\n\nmy %unhandled;\n\nsub print_unhandled\n{\n    if ((scalar keys %unhandled) == 0) {\n\treturn;\n    }\n\n    print \"\\nunhandled events:\\n\\n\";\n\n    printf(\"%-40s  %10s\\n\", \"event\", \"count\");\n    printf(\"%-40s  %10s\\n\", \"----------------------------------------\",\n\t   \"-----------\");\n\n    foreach my $event_name (keys %unhandled) {\n\tprintf(\"%-40s  %10d\\n\", $event_name, $unhandled{$event_name});\n    }\n}\n\nsub trace_unhandled\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain) = @_;\n\n    $unhandled{$event_name}++;\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}