{
  "module_name": "check-perf-trace.pl",
  "hash_id": "2e0756fe097478a3d0dd62ef3916e1db7272805409f5064c154228ace6407cc3",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/perl/check-perf-trace.pl",
  "human_readable_source": "# perf script event handlers, generated by perf script -g perl\n# (c) 2009, Tom Zanussi <tzanussi@gmail.com>\n# Licensed under the terms of the GNU GPL License version 2\n\n# This script tests basic functionality such as flag and symbol\n# strings, common_xxx() calls back into perf, begin, end, unhandled\n# events, etc.  Basically, if this script runs successfully and\n# displays expected results, perl scripting support should be ok.\n\nuse lib \"$ENV{'PERF_EXEC_PATH'}/scripts/perl/Perf-Trace-Util/lib\";\nuse lib \"./Perf-Trace-Util/lib\";\nuse Perf::Trace::Core;\nuse Perf::Trace::Context;\nuse Perf::Trace::Util;\n\nsub trace_begin\n{\n    print \"trace_begin\\n\";\n}\n\nsub trace_end\n{\n    print \"trace_end\\n\";\n\n    print_unhandled();\n}\n\nsub irq::softirq_entry\n{\n\tmy ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t    $common_pid, $common_comm, $common_callchain,\n\t    $vec) = @_;\n\n\tprint_header($event_name, $common_cpu, $common_secs, $common_nsecs,\n\t\t     $common_pid, $common_comm);\n\n\tprint_uncommon($context);\n\n\tprintf(\"vec=%s\\n\",\n\t       symbol_str(\"irq::softirq_entry\", \"vec\", $vec));\n}\n\nsub kmem::kmalloc\n{\n\tmy ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t    $common_pid, $common_comm, $common_callchain,\n\t    $call_site, $ptr, $bytes_req, $bytes_alloc,\n\t    $gfp_flags) = @_;\n\n\tprint_header($event_name, $common_cpu, $common_secs, $common_nsecs,\n\t\t     $common_pid, $common_comm);\n\n\tprint_uncommon($context);\n\n\tprintf(\"call_site=%p, ptr=%p, bytes_req=%u, bytes_alloc=%u, \".\n\t       \"gfp_flags=%s\\n\",\n\t       $call_site, $ptr, $bytes_req, $bytes_alloc,\n\n\t       flag_str(\"kmem::kmalloc\", \"gfp_flags\", $gfp_flags));\n}\n\n# print trace fields not included in handler args\nsub print_uncommon\n{\n    my ($context) = @_;\n\n    printf(\"common_preempt_count=%d, common_flags=%s, common_lock_depth=%d, \",\n\t   common_pc($context), trace_flag_str(common_flags($context)),\n\t   common_lock_depth($context));\n\n}\n\nmy %unhandled;\n\nsub print_unhandled\n{\n    if ((scalar keys %unhandled) == 0) {\n\treturn;\n    }\n\n    print \"\\nunhandled events:\\n\\n\";\n\n    printf(\"%-40s  %10s\\n\", \"event\", \"count\");\n    printf(\"%-40s  %10s\\n\", \"----------------------------------------\",\n\t   \"-----------\");\n\n    foreach my $event_name (keys %unhandled) {\n\tprintf(\"%-40s  %10d\\n\", $event_name, $unhandled{$event_name});\n    }\n}\n\nsub trace_unhandled\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain) = @_;\n\n    $unhandled{$event_name}++;\n}\n\nsub print_header\n{\n\tmy ($event_name, $cpu, $secs, $nsecs, $pid, $comm) = @_;\n\n\tprintf(\"%-20s %5u %05u.%09u %8u %-20s \",\n\t       $event_name, $cpu, $secs, $nsecs, $pid, $comm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}