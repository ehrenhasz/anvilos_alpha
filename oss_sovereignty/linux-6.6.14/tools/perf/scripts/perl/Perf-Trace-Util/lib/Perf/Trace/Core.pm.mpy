{
  "module_name": "Core.pm",
  "hash_id": "34bad7b0145a9bb73fafaaf1462f746ea731fba3ce7a60980595db9d646bbe63",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/perl/Perf-Trace-Util/lib/Perf/Trace/Core.pm",
  "human_readable_source": "package Perf::Trace::Core;\n\nuse 5.010000;\nuse strict;\nuse warnings;\n\nrequire Exporter;\n\nour @ISA = qw(Exporter);\n\nour %EXPORT_TAGS = ( 'all' => [ qw(\n) ] );\n\nour @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );\n\nour @EXPORT = qw(\ndefine_flag_field define_flag_value flag_str dump_flag_fields\ndefine_symbolic_field define_symbolic_value symbol_str dump_symbolic_fields\ntrace_flag_str\n);\n\nour $VERSION = '0.01';\n\nmy %trace_flags = (0x00 => \"NONE\",\n\t\t   0x01 => \"IRQS_OFF\",\n\t\t   0x02 => \"IRQS_NOSUPPORT\",\n\t\t   0x04 => \"NEED_RESCHED\",\n\t\t   0x08 => \"HARDIRQ\",\n\t\t   0x10 => \"SOFTIRQ\");\n\nsub trace_flag_str\n{\n    my ($value) = @_;\n\n    my $string;\n\n    my $print_delim = 0;\n\n    foreach my $idx (sort {$a <=> $b} keys %trace_flags) {\n\tif (!$value && !$idx) {\n\t    $string .= \"NONE\";\n\t    last;\n\t}\n\n\tif ($idx && ($value & $idx) == $idx) {\n\t    if ($print_delim) {\n\t\t$string .= \" | \";\n\t    }\n\t    $string .= \"$trace_flags{$idx}\";\n\t    $print_delim = 1;\n\t    $value &= ~$idx;\n\t}\n    }\n\n    return $string;\n}\n\nmy %flag_fields;\nmy %symbolic_fields;\n\nsub flag_str\n{\n    my ($event_name, $field_name, $value) = @_;\n\n    my $string;\n\n    if ($flag_fields{$event_name}{$field_name}) {\n\tmy $print_delim = 0;\n\tforeach my $idx (sort {$a <=> $b} keys %{$flag_fields{$event_name}{$field_name}{\"values\"}}) {\n\t    if (!$value && !$idx) {\n\t\t$string .= \"$flag_fields{$event_name}{$field_name}{'values'}{$idx}\";\n\t\tlast;\n\t    }\n\t    if ($idx && ($value & $idx) == $idx) {\n\t\tif ($print_delim && $flag_fields{$event_name}{$field_name}{'delim'}) {\n\t\t    $string .= \" $flag_fields{$event_name}{$field_name}{'delim'} \";\n\t\t}\n\t\t$string .= \"$flag_fields{$event_name}{$field_name}{'values'}{$idx}\";\n\t\t$print_delim = 1;\n\t\t$value &= ~$idx;\n\t    }\n\t}\n    }\n\n    return $string;\n}\n\nsub define_flag_field\n{\n    my ($event_name, $field_name, $delim) = @_;\n\n    $flag_fields{$event_name}{$field_name}{\"delim\"} = $delim;\n}\n\nsub define_flag_value\n{\n    my ($event_name, $field_name, $value, $field_str) = @_;\n\n    $flag_fields{$event_name}{$field_name}{\"values\"}{$value} = $field_str;\n}\n\nsub dump_flag_fields\n{\n    for my $event (keys %flag_fields) {\n\tprint \"event $event:\\n\";\n\tfor my $field (keys %{$flag_fields{$event}}) {\n\t    print \"    field: $field:\\n\";\n\t    print \"        delim: $flag_fields{$event}{$field}{'delim'}\\n\";\n\t    foreach my $idx (sort {$a <=> $b} keys %{$flag_fields{$event}{$field}{\"values\"}}) {\n\t\tprint \"        value $idx: $flag_fields{$event}{$field}{'values'}{$idx}\\n\";\n\t    }\n\t}\n    }\n}\n\nsub symbol_str\n{\n    my ($event_name, $field_name, $value) = @_;\n\n    if ($symbolic_fields{$event_name}{$field_name}) {\n\tforeach my $idx (sort {$a <=> $b} keys %{$symbolic_fields{$event_name}{$field_name}{\"values\"}}) {\n\t    if (!$value && !$idx) {\n\t\treturn \"$symbolic_fields{$event_name}{$field_name}{'values'}{$idx}\";\n\t\tlast;\n\t    }\n\t    if ($value == $idx) {\n\t\treturn \"$symbolic_fields{$event_name}{$field_name}{'values'}{$idx}\";\n\t    }\n\t}\n    }\n\n    return undef;\n}\n\nsub define_symbolic_field\n{\n    my ($event_name, $field_name) = @_;\n\n    # nothing to do, really\n}\n\nsub define_symbolic_value\n{\n    my ($event_name, $field_name, $value, $field_str) = @_;\n\n    $symbolic_fields{$event_name}{$field_name}{\"values\"}{$value} = $field_str;\n}\n\nsub dump_symbolic_fields\n{\n    for my $event (keys %symbolic_fields) {\n\tprint \"event $event:\\n\";\n\tfor my $field (keys %{$symbolic_fields{$event}}) {\n\t    print \"    field: $field:\\n\";\n\t    foreach my $idx (sort {$a <=> $b} keys %{$symbolic_fields{$event}{$field}{\"values\"}}) {\n\t\tprint \"        value $idx: $symbolic_fields{$event}{$field}{'values'}{$idx}\\n\";\n\t    }\n\t}\n    }\n}\n\n1;\n__END__\n=head1 NAME\n\nPerf::Trace::Core - Perl extension for perf script\n\n=head1 SYNOPSIS\n\n  use Perf::Trace::Core\n\n=head1 SEE ALSO\n\nPerf (script) documentation\n\n=head1 AUTHOR\n\nTom Zanussi, E<lt>tzanussi@gmail.com<gt>\n\n=head1 COPYRIGHT AND LICENSE\n\nCopyright (C) 2009 by Tom Zanussi\n\nThis library is free software; you can redistribute it and/or modify\nit under the same terms as Perl itself, either Perl version 5.10.0 or,\nat your option, any later version of Perl 5 you may have available.\n\nAlternatively, this software may be distributed under the terms of the\nGNU General Public License (\"GPL\") version 2 as published by the Free\nSoftware Foundation.\n\n=cut\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}