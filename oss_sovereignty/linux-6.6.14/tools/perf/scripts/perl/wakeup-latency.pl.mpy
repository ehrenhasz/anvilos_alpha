{
  "module_name": "wakeup-latency.pl",
  "hash_id": "89810efab70537d4906d9439aa84ba0e3e33c8410623cdbf25b46e015386e4b4",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/perl/wakeup-latency.pl",
  "human_readable_source": "#!/usr/bin/perl -w\n# SPDX-License-Identifier: GPL-2.0-only\n# (c) 2009, Tom Zanussi <tzanussi@gmail.com>\n\n# Display avg/min/max wakeup latency\n\n# The common_* event handler fields are the most useful fields common to\n# all events.  They don't necessarily correspond to the 'common_*' fields\n# in the status files.  Those fields not available as handler params can\n# be retrieved via script functions of the form get_common_*().\n\nuse 5.010000;\nuse strict;\nuse warnings;\n\nuse lib \"$ENV{'PERF_EXEC_PATH'}/scripts/perl/Perf-Trace-Util/lib\";\nuse lib \"./Perf-Trace-Util/lib\";\nuse Perf::Trace::Core;\nuse Perf::Trace::Util;\n\nmy %last_wakeup;\n\nmy $max_wakeup_latency;\nmy $min_wakeup_latency;\nmy $total_wakeup_latency = 0;\nmy $total_wakeups = 0;\n\nsub sched::sched_switch\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain,\n\t$prev_comm, $prev_pid, $prev_prio, $prev_state, $next_comm, $next_pid,\n\t$next_prio) = @_;\n\n    my $wakeup_ts = $last_wakeup{$common_cpu}{ts};\n    if ($wakeup_ts) {\n\tmy $switch_ts = nsecs($common_secs, $common_nsecs);\n\tmy $wakeup_latency = $switch_ts - $wakeup_ts;\n\tif ($wakeup_latency > $max_wakeup_latency) {\n\t    $max_wakeup_latency = $wakeup_latency;\n\t}\n\tif ($wakeup_latency < $min_wakeup_latency) {\n\t    $min_wakeup_latency = $wakeup_latency;\n\t}\n\t$total_wakeup_latency += $wakeup_latency;\n\t$total_wakeups++;\n    }\n    $last_wakeup{$common_cpu}{ts} = 0;\n}\n\nsub sched::sched_wakeup\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain,\n\t$comm, $pid, $prio, $success, $target_cpu) = @_;\n\n    $last_wakeup{$target_cpu}{ts} = nsecs($common_secs, $common_nsecs);\n}\n\nsub trace_begin\n{\n    $min_wakeup_latency = 1000000000;\n    $max_wakeup_latency = 0;\n}\n\nsub trace_end\n{\n    printf(\"wakeup_latency stats:\\n\\n\");\n    print \"total_wakeups: $total_wakeups\\n\";\n    if ($total_wakeups) {\n\tprintf(\"avg_wakeup_latency (ns): %u\\n\",\n\t       avg($total_wakeup_latency, $total_wakeups));\n    } else {\n\tprintf(\"avg_wakeup_latency (ns): N/A\\n\");\n    }\n    printf(\"min_wakeup_latency (ns): %u\\n\", $min_wakeup_latency);\n    printf(\"max_wakeup_latency (ns): %u\\n\", $max_wakeup_latency);\n\n    print_unhandled();\n}\n\nmy %unhandled;\n\nsub print_unhandled\n{\n    if ((scalar keys %unhandled) == 0) {\n\treturn;\n    }\n\n    print \"\\nunhandled events:\\n\\n\";\n\n    printf(\"%-40s  %10s\\n\", \"event\", \"count\");\n    printf(\"%-40s  %10s\\n\", \"----------------------------------------\",\n\t   \"-----------\");\n\n    foreach my $event_name (keys %unhandled) {\n\tprintf(\"%-40s  %10d\\n\", $event_name, $unhandled{$event_name});\n    }\n}\n\nsub trace_unhandled\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain) = @_;\n\n    $unhandled{$event_name}++;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}