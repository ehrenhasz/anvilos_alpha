{
  "module_name": "rwtop.pl",
  "hash_id": "7bccae9ec6f014351cab0f04a0e41ead0240f99fa0c17b941b5bb71a56eb5bcb",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/scripts/perl/rwtop.pl",
  "human_readable_source": "#!/usr/bin/perl -w\n# SPDX-License-Identifier: GPL-2.0-only\n# (c) 2010, Tom Zanussi <tzanussi@gmail.com>\n\n# read/write top\n#\n# Periodically displays system-wide r/w call activity, broken down by\n# pid.  If an [interval] arg is specified, the display will be\n# refreshed every [interval] seconds.  The default interval is 3\n# seconds.\n\nuse 5.010000;\nuse strict;\nuse warnings;\n\nuse lib \"$ENV{'PERF_EXEC_PATH'}/scripts/perl/Perf-Trace-Util/lib\";\nuse lib \"./Perf-Trace-Util/lib\";\nuse Perf::Trace::Core;\nuse Perf::Trace::Util;\nuse POSIX qw/SIGALRM SA_RESTART/;\n\nmy $default_interval = 3;\nmy $nlines = 20;\nmy $print_thread;\nmy $print_pending = 0;\n\nmy %reads;\nmy %writes;\n\nmy $interval = shift;\nif (!$interval) {\n    $interval = $default_interval;\n}\n\nsub syscalls::sys_exit_read\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain,\n\t$nr, $ret) = @_;\n\n    print_check();\n\n    if ($ret > 0) {\n\t$reads{$common_pid}{bytes_read} += $ret;\n    } else {\n\tif (!defined ($reads{$common_pid}{bytes_read})) {\n\t    $reads{$common_pid}{bytes_read} = 0;\n\t}\n\t$reads{$common_pid}{errors}{$ret}++;\n    }\n}\n\nsub syscalls::sys_enter_read\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain,\n\t$nr, $fd, $buf, $count) = @_;\n\n    print_check();\n\n    $reads{$common_pid}{bytes_requested} += $count;\n    $reads{$common_pid}{total_reads}++;\n    $reads{$common_pid}{comm} = $common_comm;\n}\n\nsub syscalls::sys_exit_write\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain,\n\t$nr, $ret) = @_;\n\n    print_check();\n\n    if ($ret <= 0) {\n\t$writes{$common_pid}{errors}{$ret}++;\n    }\n}\n\nsub syscalls::sys_enter_write\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain,\n\t$nr, $fd, $buf, $count) = @_;\n\n    print_check();\n\n    $writes{$common_pid}{bytes_written} += $count;\n    $writes{$common_pid}{total_writes}++;\n    $writes{$common_pid}{comm} = $common_comm;\n}\n\nsub trace_begin\n{\n    my $sa = POSIX::SigAction->new(\\&set_print_pending);\n    $sa->flags(SA_RESTART);\n    $sa->safe(1);\n    POSIX::sigaction(SIGALRM, $sa) or die \"Can't set SIGALRM handler: $!\\n\";\n    alarm 1;\n}\n\nsub trace_end\n{\n    print_unhandled();\n    print_totals();\n}\n\nsub print_check()\n{\n    if ($print_pending == 1) {\n\t$print_pending = 0;\n\tprint_totals();\n    }\n}\n\nsub set_print_pending()\n{\n    $print_pending = 1;\n    alarm $interval;\n}\n\nsub print_totals\n{\n    my $count;\n\n    $count = 0;\n\n    clear_term();\n\n    printf(\"\\nread counts by pid:\\n\\n\");\n\n    printf(\"%6s  %20s  %10s  %10s  %10s\\n\", \"pid\", \"comm\",\n\t   \"# reads\", \"bytes_req\", \"bytes_read\");\n    printf(\"%6s  %-20s  %10s  %10s  %10s\\n\", \"------\", \"--------------------\",\n\t   \"----------\", \"----------\", \"----------\");\n\n    foreach my $pid (sort { ($reads{$b}{bytes_read} || 0) <=>\n\t\t\t       ($reads{$a}{bytes_read} || 0) } keys %reads) {\n\tmy $comm = $reads{$pid}{comm} || \"\";\n\tmy $total_reads = $reads{$pid}{total_reads} || 0;\n\tmy $bytes_requested = $reads{$pid}{bytes_requested} || 0;\n\tmy $bytes_read = $reads{$pid}{bytes_read} || 0;\n\n\tprintf(\"%6s  %-20s  %10s  %10s  %10s\\n\", $pid, $comm,\n\t       $total_reads, $bytes_requested, $bytes_read);\n\n\tif (++$count == $nlines) {\n\t    last;\n\t}\n    }\n\n    $count = 0;\n\n    printf(\"\\nwrite counts by pid:\\n\\n\");\n\n    printf(\"%6s  %20s  %10s  %13s\\n\", \"pid\", \"comm\",\n\t   \"# writes\", \"bytes_written\");\n    printf(\"%6s  %-20s  %10s  %13s\\n\", \"------\", \"--------------------\",\n\t   \"----------\", \"-------------\");\n\n    foreach my $pid (sort { ($writes{$b}{bytes_written} || 0) <=>\n\t\t\t($writes{$a}{bytes_written} || 0)} keys %writes) {\n\tmy $comm = $writes{$pid}{comm} || \"\";\n\tmy $total_writes = $writes{$pid}{total_writes} || 0;\n\tmy $bytes_written = $writes{$pid}{bytes_written} || 0;\n\n\tprintf(\"%6s  %-20s  %10s  %13s\\n\", $pid, $comm,\n\t       $total_writes, $bytes_written);\n\n\tif (++$count == $nlines) {\n\t    last;\n\t}\n    }\n\n    %reads = ();\n    %writes = ();\n}\n\nmy %unhandled;\n\nsub print_unhandled\n{\n    if ((scalar keys %unhandled) == 0) {\n\treturn;\n    }\n\n    print \"\\nunhandled events:\\n\\n\";\n\n    printf(\"%-40s  %10s\\n\", \"event\", \"count\");\n    printf(\"%-40s  %10s\\n\", \"----------------------------------------\",\n\t   \"-----------\");\n\n    foreach my $event_name (keys %unhandled) {\n\tprintf(\"%-40s  %10d\\n\", $event_name, $unhandled{$event_name});\n    }\n}\n\nsub trace_unhandled\n{\n    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,\n\t$common_pid, $common_comm, $common_callchain) = @_;\n\n    $unhandled{$event_name}++;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}