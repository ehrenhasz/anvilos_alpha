{
  "module_name": "Makefile",
  "hash_id": "29f65b5cf4562bfec0066fe7f79127a902c673b6969c3dd69cdcb787a4a74870",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/Makefile",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# This is a simple wrapper Makefile that calls the main Makefile.perf\n# with a -j option to do parallel builds\n#\n# If you want to invoke the perf build in some non-standard way then\n# you can use the 'make -f Makefile.perf' method to invoke it.\n#\n\n#\n# Clear out the built-in rules GNU make defines by default (such as .o targets),\n# so that we pass through all targets to Makefile.perf:\n#\n.SUFFIXES:\n\n#\n# We don't want to pass along options like -j:\n#\nunexport MAKEFLAGS\n\n#\n# Do a parallel build with multiple jobs, based on the number of CPUs online\n# in this system: 'make -j8' on a 8-CPU system, etc.\n#\n# (To override it, run 'make JOBS=1' and similar.)\n#\nifeq ($(JOBS),)\n  JOBS := $(shell (getconf _NPROCESSORS_ONLN || grep -E -c '^processor|^CPU[0-9]' /proc/cpuinfo) 2>/dev/null)\n  ifeq ($(JOBS),0)\n    JOBS := 1\n  endif\nendif\n\n#\n# Only pass canonical directory names as the output directory:\n#\nifneq ($(O),)\n  FULL_O := $(shell cd $(PWD); readlink -f $(O) || echo $(O))\nendif\n\n#\n# Only accept the 'DEBUG' variable from the command line:\n#\nifeq (\"$(origin DEBUG)\", \"command line\")\n  ifeq ($(DEBUG),)\n    override DEBUG = 0\n  else\n    SET_DEBUG = \"DEBUG=$(DEBUG)\"\n  endif\nelse\n  override DEBUG = 0\nendif\n\ndefine print_msg\n  @printf '  BUILD:   Doing '\\''make \\033[33m-j'$(JOBS)'\\033[m'\\'' parallel build\\n'\nendef\n\ndefine make\n  @$(MAKE) -f Makefile.perf --no-print-directory -j$(JOBS) O=$(FULL_O) $(SET_DEBUG) $@\nendef\n\n#\n# Needed if no target specified:\n# (Except for tags and TAGS targets. The reason is that the\n# Makefile does not treat tags/TAGS as targets but as files\n# and thus won't rebuilt them once they are in place.)\n#\nall tags TAGS:\n\t$(print_msg)\n\t$(make)\n\nifdef MAKECMDGOALS\nhas_clean := 0\nifneq ($(filter clean,$(MAKECMDGOALS)),)\n  has_clean := 1\nendif # clean\n\nifeq ($(has_clean),1)\n  rest := $(filter-out clean,$(MAKECMDGOALS))\n  ifneq ($(rest),)\n$(rest): clean\n  endif # rest\nendif # has_clean\nendif # MAKECMDGOALS\n\n#\n# Explicitly disable parallelism for the clean target.\n#\nclean:\n\t$(make) -j1\n\n#\n# The build-test target is not really parallel, don't print the jobs info,\n# it also uses only the tests/make targets that don't pollute the source\n# repository, i.e. that uses O= or builds the tarpkg outside the source\n# repo directories.\n#\n# For a full test, use:\n#\n# make -C tools/perf -f tests/make\n#\nbuild-test:\n\t@$(MAKE) SHUF=1 -f tests/make REUSE_FEATURES_DUMP=1 MK=Makefile SET_PARALLEL=1 --no-print-directory tarpkg make_static make_with_gtk2 out\n\nbuild-test-tarball:\n\t@$(MAKE) -f tests/make REUSE_FEATURES_DUMP=1 MK=Makefile SET_PARALLEL=1 --no-print-directory out\n\n#\n# All other targets get passed through:\n#\n%: FORCE\n\t$(print_msg)\n\t$(make)\n\n.PHONY: tags TAGS FORCE Makefile\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}