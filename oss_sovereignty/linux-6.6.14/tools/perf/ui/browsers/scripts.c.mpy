{
  "module_name": "scripts.c",
  "hash_id": "9bb8830880c57e6442ab783429528fd0cf4266f76e040f25aba887c88be009c6",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/ui/browsers/scripts.c",
  "human_readable_source": "\n#include \"../../builtin.h\"\n#include \"../../perf.h\"\n#include \"../../util/util.h\" \n#include \"../util.h\"\n#include \"../../util/hist.h\"\n#include \"../../util/debug.h\"\n#include \"../../util/symbol.h\"\n#include \"../browser.h\"\n#include \"../libslang.h\"\n#include \"config.h\"\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <stdlib.h>\n\n#define SCRIPT_NAMELEN\t128\n#define SCRIPT_MAX_NO\t64\n \n#define SCRIPT_FULLPATH_LEN\t256\n\nstruct script_config {\n\tconst char **names;\n\tchar **paths;\n\tint index;\n\tconst char *perf;\n\tchar extra_format[256];\n};\n\nvoid attr_to_script(char *extra_format, struct perf_event_attr *attr)\n{\n\textra_format[0] = 0;\n\tif (attr->read_format & PERF_FORMAT_GROUP)\n\t\tstrcat(extra_format, \" -F +metric\");\n\tif (attr->sample_type & PERF_SAMPLE_BRANCH_STACK)\n\t\tstrcat(extra_format, \" -F +brstackinsn --xed\");\n\tif (attr->sample_type & PERF_SAMPLE_REGS_INTR)\n\t\tstrcat(extra_format, \" -F +iregs\");\n\tif (attr->sample_type & PERF_SAMPLE_REGS_USER)\n\t\tstrcat(extra_format, \" -F +uregs\");\n\tif (attr->sample_type & PERF_SAMPLE_PHYS_ADDR)\n\t\tstrcat(extra_format, \" -F +phys_addr\");\n}\n\nstatic int add_script_option(const char *name, const char *opt,\n\t\t\t     struct script_config *c)\n{\n\tc->names[c->index] = name;\n\tif (asprintf(&c->paths[c->index],\n\t\t     \"%s script %s -F +metric %s %s\",\n\t\t     c->perf, opt, symbol_conf.inline_name ? \" --inline\" : \"\",\n\t\t     c->extra_format) < 0)\n\t\treturn -1;\n\tc->index++;\n\treturn 0;\n}\n\nstatic int scripts_config(const char *var, const char *value, void *data)\n{\n\tstruct script_config *c = data;\n\n\tif (!strstarts(var, \"scripts.\"))\n\t\treturn -1;\n\tif (c->index >= SCRIPT_MAX_NO)\n\t\treturn -1;\n\tc->names[c->index] = strdup(var + 7);\n\tif (!c->names[c->index])\n\t\treturn -1;\n\tif (asprintf(&c->paths[c->index], \"%s %s\", value,\n\t\t     c->extra_format) < 0)\n\t\treturn -1;\n\tc->index++;\n\treturn 0;\n}\n\n \nstatic int list_scripts(char *script_name, bool *custom,\n\t\t\tstruct evsel *evsel)\n{\n\tchar *buf, *paths[SCRIPT_MAX_NO], *names[SCRIPT_MAX_NO];\n\tint i, num, choice;\n\tint ret = 0;\n\tint max_std, custom_perf;\n\tchar pbuf[256];\n\tconst char *perf = perf_exe(pbuf, sizeof pbuf);\n\tstruct script_config scriptc = {\n\t\t.names = (const char **)names,\n\t\t.paths = paths,\n\t\t.perf = perf\n\t};\n\n\tscript_name[0] = 0;\n\n\t \n\tbuf = malloc(SCRIPT_MAX_NO * (SCRIPT_NAMELEN + SCRIPT_FULLPATH_LEN));\n\tif (!buf)\n\t\treturn -1;\n\n\tif (evsel)\n\t\tattr_to_script(scriptc.extra_format, &evsel->core.attr);\n\tadd_script_option(\"Show individual samples\", \"\", &scriptc);\n\tadd_script_option(\"Show individual samples with assembler\", \"-F +insn --xed\",\n\t\t\t  &scriptc);\n\tadd_script_option(\"Show individual samples with source\", \"-F +srcline,+srccode\",\n\t\t\t  &scriptc);\n\tperf_config(scripts_config, &scriptc);\n\tcustom_perf = scriptc.index;\n\tadd_script_option(\"Show samples with custom perf script arguments\", \"\", &scriptc);\n\ti = scriptc.index;\n\tmax_std = i;\n\n\tfor (; i < SCRIPT_MAX_NO; i++) {\n\t\tnames[i] = buf + (i - max_std) * (SCRIPT_NAMELEN + SCRIPT_FULLPATH_LEN);\n\t\tpaths[i] = names[i] + SCRIPT_NAMELEN;\n\t}\n\n\tnum = find_scripts(names + max_std, paths + max_std, SCRIPT_MAX_NO - max_std,\n\t\t\tSCRIPT_FULLPATH_LEN);\n\tif (num < 0)\n\t\tnum = 0;\n\tchoice = ui__popup_menu(num + max_std, (char * const *)names, NULL);\n\tif (choice < 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (choice == custom_perf) {\n\t\tchar script_args[50];\n\t\tint key = ui_browser__input_window(\"perf script command\",\n\t\t\t\t\"Enter perf script command line (without perf script prefix)\",\n\t\t\t\tscript_args, \"\", 0);\n\t\tif (key != K_ENTER) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tsprintf(script_name, \"%s script %s\", perf, script_args);\n\t} else if (choice < num + max_std) {\n\t\tstrcpy(script_name, paths[choice]);\n\t}\n\t*custom = choice >= max_std;\n\nout:\n\tfree(buf);\n\tfor (i = 0; i < max_std; i++)\n\t\tzfree(&paths[i]);\n\treturn ret;\n}\n\nvoid run_script(char *cmd)\n{\n\tpr_debug(\"Running %s\\n\", cmd);\n\tSLang_reset_tty();\n\tif (system(cmd) < 0)\n\t\tpr_warning(\"Cannot run %s\\n\", cmd);\n\t \n\tprintf(\"\\033[c\\033[H\\033[J\");\n\tfflush(stdout);\n\tSLang_init_tty(0, 0, 0);\n\tSLsmg_refresh();\n}\n\nint script_browse(const char *script_opt, struct evsel *evsel)\n{\n\tchar *cmd, script_name[SCRIPT_FULLPATH_LEN];\n\tbool custom = false;\n\n\tmemset(script_name, 0, SCRIPT_FULLPATH_LEN);\n\tif (list_scripts(script_name, &custom, evsel))\n\t\treturn -1;\n\n\tif (asprintf(&cmd, \"%s%s %s %s%s 2>&1 | less\",\n\t\t\tcustom ? \"perf script -s \" : \"\",\n\t\t\tscript_name,\n\t\t\tscript_opt ? script_opt : \"\",\n\t\t\tinput_name ? \"-i \" : \"\",\n\t\t\tinput_name ? input_name : \"\") < 0)\n\t\treturn -1;\n\n\trun_script(cmd);\n\tfree(cmd);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}