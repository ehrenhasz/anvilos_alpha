{
  "module_name": "hists.c",
  "hash_id": "950e3ec99110b8a1a02c3cb55cbfce81a5349064ebf2a8e4a29a91100cc81c89",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/ui/browsers/hists.c",
  "human_readable_source": "\n#include <dirent.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <linux/rbtree.h>\n#include <linux/string.h>\n#include <sys/ttydefaults.h>\n#include <linux/time64.h>\n#include <linux/zalloc.h>\n\n#include \"../../util/debug.h\"\n#include \"../../util/dso.h\"\n#include \"../../util/callchain.h\"\n#include \"../../util/evsel.h\"\n#include \"../../util/evlist.h\"\n#include \"../../util/header.h\"\n#include \"../../util/hist.h\"\n#include \"../../util/machine.h\"\n#include \"../../util/map.h\"\n#include \"../../util/maps.h\"\n#include \"../../util/symbol.h\"\n#include \"../../util/map_symbol.h\"\n#include \"../../util/branch.h\"\n#include \"../../util/pstack.h\"\n#include \"../../util/sort.h\"\n#include \"../../util/top.h\"\n#include \"../../util/thread.h\"\n#include \"../../util/block-info.h\"\n#include \"../../util/util.h\"\n#include \"../../arch/common.h\"\n\n#include \"../browsers/hists.h\"\n#include \"../helpline.h\"\n#include \"../util.h\"\n#include \"../ui.h\"\n#include \"map.h\"\n#include \"annotate.h\"\n#include \"srcline.h\"\n#include \"string2.h\"\n#include \"units.h\"\n#include \"time-utils.h\"\n\n#include <linux/ctype.h>\n\nextern void hist_browser__init_hpp(void);\n\nstatic int hists_browser__scnprintf_title(struct hist_browser *browser, char *bf, size_t size);\nstatic void hist_browser__update_nr_entries(struct hist_browser *hb);\n\nstatic struct rb_node *hists__filter_entries(struct rb_node *nd,\n\t\t\t\t\t     float min_pcnt);\n\nstatic bool hist_browser__has_filter(struct hist_browser *hb)\n{\n\treturn hists__has_filter(hb->hists) || hb->min_pcnt || symbol_conf.has_filter || hb->c2c_filter;\n}\n\nstatic int hist_browser__get_folding(struct hist_browser *browser)\n{\n\tstruct rb_node *nd;\n\tstruct hists *hists = browser->hists;\n\tint unfolded_rows = 0;\n\n\tfor (nd = rb_first_cached(&hists->entries);\n\t     (nd = hists__filter_entries(nd, browser->min_pcnt)) != NULL;\n\t     nd = rb_hierarchy_next(nd)) {\n\t\tstruct hist_entry *he =\n\t\t\trb_entry(nd, struct hist_entry, rb_node);\n\n\t\tif (he->leaf && he->unfolded)\n\t\t\tunfolded_rows += he->nr_rows;\n\t}\n\treturn unfolded_rows;\n}\n\nstatic void hist_browser__set_title_space(struct hist_browser *hb)\n{\n\tstruct ui_browser *browser = &hb->b;\n\tstruct hists *hists = hb->hists;\n\tstruct perf_hpp_list *hpp_list = hists->hpp_list;\n\n\tbrowser->extra_title_lines = hb->show_headers ? hpp_list->nr_header_lines : 0;\n}\n\nstatic u32 hist_browser__nr_entries(struct hist_browser *hb)\n{\n\tu32 nr_entries;\n\n\tif (symbol_conf.report_hierarchy)\n\t\tnr_entries = hb->nr_hierarchy_entries;\n\telse if (hist_browser__has_filter(hb))\n\t\tnr_entries = hb->nr_non_filtered_entries;\n\telse\n\t\tnr_entries = hb->hists->nr_entries;\n\n\thb->nr_callchain_rows = hist_browser__get_folding(hb);\n\treturn nr_entries + hb->nr_callchain_rows;\n}\n\nstatic void hist_browser__update_rows(struct hist_browser *hb)\n{\n\tstruct ui_browser *browser = &hb->b;\n\tstruct hists *hists = hb->hists;\n\tstruct perf_hpp_list *hpp_list = hists->hpp_list;\n\tu16 index_row;\n\n\tif (!hb->show_headers) {\n\t\tbrowser->rows += browser->extra_title_lines;\n\t\tbrowser->extra_title_lines = 0;\n\t\treturn;\n\t}\n\n\tbrowser->extra_title_lines = hpp_list->nr_header_lines;\n\tbrowser->rows -= browser->extra_title_lines;\n\t \n\tindex_row = browser->index - browser->top_idx;\n\tif (index_row >= browser->rows)\n\t\tbrowser->index -= index_row - browser->rows + 1;\n}\n\nstatic void hist_browser__refresh_dimensions(struct ui_browser *browser)\n{\n\tstruct hist_browser *hb = container_of(browser, struct hist_browser, b);\n\n\t \n\tbrowser->width = 3 + (hists__sort_list_width(hb->hists) + sizeof(\"[k]\"));\n\t \n\tui_browser__refresh_dimensions(browser);\n}\n\nstatic void hist_browser__reset(struct hist_browser *browser)\n{\n\t \n\tbrowser->nr_callchain_rows = 0;\n\n\thist_browser__update_nr_entries(browser);\n\tbrowser->b.nr_entries = hist_browser__nr_entries(browser);\n\thist_browser__refresh_dimensions(&browser->b);\n\tui_browser__reset_index(&browser->b);\n}\n\nstatic char tree__folded_sign(bool unfolded)\n{\n\treturn unfolded ? '-' : '+';\n}\n\nstatic char hist_entry__folded(const struct hist_entry *he)\n{\n\treturn he->has_children ? tree__folded_sign(he->unfolded) : ' ';\n}\n\nstatic char callchain_list__folded(const struct callchain_list *cl)\n{\n\treturn cl->has_children ? tree__folded_sign(cl->unfolded) : ' ';\n}\n\nstatic void callchain_list__set_folding(struct callchain_list *cl, bool unfold)\n{\n\tcl->unfolded = unfold ? cl->has_children : false;\n}\n\nstatic int callchain_node__count_rows_rb_tree(struct callchain_node *node)\n{\n\tint n = 0;\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(&node->rb_root); nd; nd = rb_next(nd)) {\n\t\tstruct callchain_node *child = rb_entry(nd, struct callchain_node, rb_node);\n\t\tstruct callchain_list *chain;\n\t\tchar folded_sign = ' ';  \n\n\t\tlist_for_each_entry(chain, &child->val, list) {\n\t\t\t++n;\n\n\t\t\t \n\t\t\tfolded_sign = callchain_list__folded(chain);\n\t\t\tif (folded_sign == '+')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (folded_sign == '-')  \n\t\t\tn += callchain_node__count_rows_rb_tree(child);\n\t}\n\n\treturn n;\n}\n\nstatic int callchain_node__count_flat_rows(struct callchain_node *node)\n{\n\tstruct callchain_list *chain;\n\tchar folded_sign = 0;\n\tint n = 0;\n\n\tlist_for_each_entry(chain, &node->parent_val, list) {\n\t\tif (!folded_sign) {\n\t\t\t \n\t\t\tfolded_sign = callchain_list__folded(chain);\n\t\t\tif (folded_sign == '+')\n\t\t\t\treturn 1;\n\t\t}\n\t\tn++;\n\t}\n\n\tlist_for_each_entry(chain, &node->val, list) {\n\t\tif (!folded_sign) {\n\t\t\t \n\t\t\tfolded_sign = callchain_list__folded(chain);\n\t\t\tif (folded_sign == '+')\n\t\t\t\treturn 1;\n\t\t}\n\t\tn++;\n\t}\n\n\treturn n;\n}\n\nstatic int callchain_node__count_folded_rows(struct callchain_node *node __maybe_unused)\n{\n\treturn 1;\n}\n\nstatic int callchain_node__count_rows(struct callchain_node *node)\n{\n\tstruct callchain_list *chain;\n\tbool unfolded = false;\n\tint n = 0;\n\n\tif (callchain_param.mode == CHAIN_FLAT)\n\t\treturn callchain_node__count_flat_rows(node);\n\telse if (callchain_param.mode == CHAIN_FOLDED)\n\t\treturn callchain_node__count_folded_rows(node);\n\n\tlist_for_each_entry(chain, &node->val, list) {\n\t\t++n;\n\n\t\tunfolded = chain->unfolded;\n\t}\n\n\tif (unfolded)\n\t\tn += callchain_node__count_rows_rb_tree(node);\n\n\treturn n;\n}\n\nstatic int callchain__count_rows(struct rb_root *chain)\n{\n\tstruct rb_node *nd;\n\tint n = 0;\n\n\tfor (nd = rb_first(chain); nd; nd = rb_next(nd)) {\n\t\tstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\n\t\tn += callchain_node__count_rows(node);\n\t}\n\n\treturn n;\n}\n\nstatic int hierarchy_count_rows(struct hist_browser *hb, struct hist_entry *he,\n\t\t\t\tbool include_children)\n{\n\tint count = 0;\n\tstruct rb_node *node;\n\tstruct hist_entry *child;\n\n\tif (he->leaf)\n\t\treturn callchain__count_rows(&he->sorted_chain);\n\n\tif (he->has_no_entry)\n\t\treturn 1;\n\n\tnode = rb_first_cached(&he->hroot_out);\n\twhile (node) {\n\t\tfloat percent;\n\n\t\tchild = rb_entry(node, struct hist_entry, rb_node);\n\t\tpercent = hist_entry__get_percent_limit(child);\n\n\t\tif (!child->filtered && percent >= hb->min_pcnt) {\n\t\t\tcount++;\n\n\t\t\tif (include_children && child->unfolded)\n\t\t\t\tcount += hierarchy_count_rows(hb, child, true);\n\t\t}\n\n\t\tnode = rb_next(node);\n\t}\n\treturn count;\n}\n\nstatic bool hist_entry__toggle_fold(struct hist_entry *he)\n{\n\tif (!he)\n\t\treturn false;\n\n\tif (!he->has_children)\n\t\treturn false;\n\n\the->unfolded = !he->unfolded;\n\treturn true;\n}\n\nstatic bool callchain_list__toggle_fold(struct callchain_list *cl)\n{\n\tif (!cl)\n\t\treturn false;\n\n\tif (!cl->has_children)\n\t\treturn false;\n\n\tcl->unfolded = !cl->unfolded;\n\treturn true;\n}\n\nstatic void callchain_node__init_have_children_rb_tree(struct callchain_node *node)\n{\n\tstruct rb_node *nd = rb_first(&node->rb_root);\n\n\tfor (nd = rb_first(&node->rb_root); nd; nd = rb_next(nd)) {\n\t\tstruct callchain_node *child = rb_entry(nd, struct callchain_node, rb_node);\n\t\tstruct callchain_list *chain;\n\t\tbool first = true;\n\n\t\tlist_for_each_entry(chain, &child->val, list) {\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tchain->has_children = chain->list.next != &child->val ||\n\t\t\t\t\t\t\t !RB_EMPTY_ROOT(&child->rb_root);\n\t\t\t} else\n\t\t\t\tchain->has_children = chain->list.next == &child->val &&\n\t\t\t\t\t\t\t !RB_EMPTY_ROOT(&child->rb_root);\n\t\t}\n\n\t\tcallchain_node__init_have_children_rb_tree(child);\n\t}\n}\n\nstatic void callchain_node__init_have_children(struct callchain_node *node,\n\t\t\t\t\t       bool has_sibling)\n{\n\tstruct callchain_list *chain;\n\n\tchain = list_entry(node->val.next, struct callchain_list, list);\n\tchain->has_children = has_sibling;\n\n\tif (!list_empty(&node->val)) {\n\t\tchain = list_entry(node->val.prev, struct callchain_list, list);\n\t\tchain->has_children = !RB_EMPTY_ROOT(&node->rb_root);\n\t}\n\n\tcallchain_node__init_have_children_rb_tree(node);\n}\n\nstatic void callchain__init_have_children(struct rb_root *root)\n{\n\tstruct rb_node *nd = rb_first(root);\n\tbool has_sibling = nd && rb_next(nd);\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\n\t\tcallchain_node__init_have_children(node, has_sibling);\n\t\tif (callchain_param.mode == CHAIN_FLAT ||\n\t\t    callchain_param.mode == CHAIN_FOLDED)\n\t\t\tcallchain_node__make_parent_list(node);\n\t}\n}\n\nstatic void hist_entry__init_have_children(struct hist_entry *he)\n{\n\tif (he->init_have_children)\n\t\treturn;\n\n\tif (he->leaf) {\n\t\the->has_children = !RB_EMPTY_ROOT(&he->sorted_chain);\n\t\tcallchain__init_have_children(&he->sorted_chain);\n\t} else {\n\t\the->has_children = !RB_EMPTY_ROOT(&he->hroot_out.rb_root);\n\t}\n\n\the->init_have_children = true;\n}\n\nstatic bool hist_browser__selection_has_children(struct hist_browser *browser)\n{\n\tstruct hist_entry *he = browser->he_selection;\n\tstruct map_symbol *ms = browser->selection;\n\n\tif (!he || !ms)\n\t\treturn false;\n\n\tif (ms == &he->ms)\n\t       return he->has_children;\n\n\treturn container_of(ms, struct callchain_list, ms)->has_children;\n}\n\nstatic bool hist_browser__selection_unfolded(struct hist_browser *browser)\n{\n\tstruct hist_entry *he = browser->he_selection;\n\tstruct map_symbol *ms = browser->selection;\n\n\tif (!he || !ms)\n\t\treturn false;\n\n\tif (ms == &he->ms)\n\t       return he->unfolded;\n\n\treturn container_of(ms, struct callchain_list, ms)->unfolded;\n}\n\nstatic char *hist_browser__selection_sym_name(struct hist_browser *browser, char *bf, size_t size)\n{\n\tstruct hist_entry *he = browser->he_selection;\n\tstruct map_symbol *ms = browser->selection;\n\tstruct callchain_list *callchain_entry;\n\n\tif (!he || !ms)\n\t\treturn NULL;\n\n\tif (ms == &he->ms) {\n\t       hist_entry__sym_snprintf(he, bf, size, 0);\n\t       return bf + 4; \n\t}\n\n\tcallchain_entry = container_of(ms, struct callchain_list, ms);\n\treturn callchain_list__sym_name(callchain_entry, bf, size, browser->show_dso);\n}\n\nstatic bool hist_browser__toggle_fold(struct hist_browser *browser)\n{\n\tstruct hist_entry *he = browser->he_selection;\n\tstruct map_symbol *ms = browser->selection;\n\tstruct callchain_list *cl = container_of(ms, struct callchain_list, ms);\n\tbool has_children;\n\n\tif (!he || !ms)\n\t\treturn false;\n\n\tif (ms == &he->ms)\n\t\thas_children = hist_entry__toggle_fold(he);\n\telse\n\t\thas_children = callchain_list__toggle_fold(cl);\n\n\tif (has_children) {\n\t\tint child_rows = 0;\n\n\t\thist_entry__init_have_children(he);\n\t\tbrowser->b.nr_entries -= he->nr_rows;\n\n\t\tif (he->leaf)\n\t\t\tbrowser->nr_callchain_rows -= he->nr_rows;\n\t\telse\n\t\t\tbrowser->nr_hierarchy_entries -= he->nr_rows;\n\n\t\tif (symbol_conf.report_hierarchy)\n\t\t\tchild_rows = hierarchy_count_rows(browser, he, true);\n\n\t\tif (he->unfolded) {\n\t\t\tif (he->leaf)\n\t\t\t\the->nr_rows = callchain__count_rows(\n\t\t\t\t\t\t&he->sorted_chain);\n\t\t\telse\n\t\t\t\the->nr_rows = hierarchy_count_rows(browser, he, false);\n\n\t\t\t \n\t\t\tif (symbol_conf.report_hierarchy)\n\t\t\t\tbrowser->b.nr_entries += child_rows - he->nr_rows;\n\n\t\t\tif (!he->leaf && he->nr_rows == 0) {\n\t\t\t\the->has_no_entry = true;\n\t\t\t\the->nr_rows = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (symbol_conf.report_hierarchy)\n\t\t\t\tbrowser->b.nr_entries -= child_rows - he->nr_rows;\n\n\t\t\tif (he->has_no_entry)\n\t\t\t\the->has_no_entry = false;\n\n\t\t\the->nr_rows = 0;\n\t\t}\n\n\t\tbrowser->b.nr_entries += he->nr_rows;\n\n\t\tif (he->leaf)\n\t\t\tbrowser->nr_callchain_rows += he->nr_rows;\n\t\telse\n\t\t\tbrowser->nr_hierarchy_entries += he->nr_rows;\n\n\t\treturn true;\n\t}\n\n\t \n\treturn false;\n}\n\nstatic int callchain_node__set_folding_rb_tree(struct callchain_node *node, bool unfold)\n{\n\tint n = 0;\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(&node->rb_root); nd; nd = rb_next(nd)) {\n\t\tstruct callchain_node *child = rb_entry(nd, struct callchain_node, rb_node);\n\t\tstruct callchain_list *chain;\n\t\tbool has_children = false;\n\n\t\tlist_for_each_entry(chain, &child->val, list) {\n\t\t\t++n;\n\t\t\tcallchain_list__set_folding(chain, unfold);\n\t\t\thas_children = chain->has_children;\n\t\t}\n\n\t\tif (has_children)\n\t\t\tn += callchain_node__set_folding_rb_tree(child, unfold);\n\t}\n\n\treturn n;\n}\n\nstatic int callchain_node__set_folding(struct callchain_node *node, bool unfold)\n{\n\tstruct callchain_list *chain;\n\tbool has_children = false;\n\tint n = 0;\n\n\tlist_for_each_entry(chain, &node->val, list) {\n\t\t++n;\n\t\tcallchain_list__set_folding(chain, unfold);\n\t\thas_children = chain->has_children;\n\t}\n\n\tif (has_children)\n\t\tn += callchain_node__set_folding_rb_tree(node, unfold);\n\n\treturn n;\n}\n\nstatic int callchain__set_folding(struct rb_root *chain, bool unfold)\n{\n\tstruct rb_node *nd;\n\tint n = 0;\n\n\tfor (nd = rb_first(chain); nd; nd = rb_next(nd)) {\n\t\tstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\n\t\tn += callchain_node__set_folding(node, unfold);\n\t}\n\n\treturn n;\n}\n\nstatic int hierarchy_set_folding(struct hist_browser *hb, struct hist_entry *he,\n\t\t\t\t bool unfold __maybe_unused)\n{\n\tfloat percent;\n\tstruct rb_node *nd;\n\tstruct hist_entry *child;\n\tint n = 0;\n\n\tfor (nd = rb_first_cached(&he->hroot_out); nd; nd = rb_next(nd)) {\n\t\tchild = rb_entry(nd, struct hist_entry, rb_node);\n\t\tpercent = hist_entry__get_percent_limit(child);\n\t\tif (!child->filtered && percent >= hb->min_pcnt)\n\t\t\tn++;\n\t}\n\n\treturn n;\n}\n\nstatic void hist_entry__set_folding(struct hist_entry *he,\n\t\t\t\t    struct hist_browser *hb, bool unfold)\n{\n\thist_entry__init_have_children(he);\n\the->unfolded = unfold ? he->has_children : false;\n\n\tif (he->has_children) {\n\t\tint n;\n\n\t\tif (he->leaf)\n\t\t\tn = callchain__set_folding(&he->sorted_chain, unfold);\n\t\telse\n\t\t\tn = hierarchy_set_folding(hb, he, unfold);\n\n\t\the->nr_rows = unfold ? n : 0;\n\t} else\n\t\the->nr_rows = 0;\n}\n\nstatic void\n__hist_browser__set_folding(struct hist_browser *browser, bool unfold)\n{\n\tstruct rb_node *nd;\n\tstruct hist_entry *he;\n\tdouble percent;\n\n\tnd = rb_first_cached(&browser->hists->entries);\n\twhile (nd) {\n\t\the = rb_entry(nd, struct hist_entry, rb_node);\n\n\t\t \n\t\tnd = __rb_hierarchy_next(nd, HMD_FORCE_CHILD);\n\n\t\thist_entry__set_folding(he, browser, unfold);\n\n\t\tpercent = hist_entry__get_percent_limit(he);\n\t\tif (he->filtered || percent < browser->min_pcnt)\n\t\t\tcontinue;\n\n\t\tif (!he->depth || unfold)\n\t\t\tbrowser->nr_hierarchy_entries++;\n\t\tif (he->leaf)\n\t\t\tbrowser->nr_callchain_rows += he->nr_rows;\n\t\telse if (unfold && !hist_entry__has_hierarchy_children(he, browser->min_pcnt)) {\n\t\t\tbrowser->nr_hierarchy_entries++;\n\t\t\the->has_no_entry = true;\n\t\t\the->nr_rows = 1;\n\t\t} else\n\t\t\the->has_no_entry = false;\n\t}\n}\n\nstatic void hist_browser__set_folding(struct hist_browser *browser, bool unfold)\n{\n\tbrowser->nr_hierarchy_entries = 0;\n\tbrowser->nr_callchain_rows = 0;\n\t__hist_browser__set_folding(browser, unfold);\n\n\tbrowser->b.nr_entries = hist_browser__nr_entries(browser);\n\t \n\tui_browser__reset_index(&browser->b);\n}\n\nstatic void hist_browser__set_folding_selected(struct hist_browser *browser, bool unfold)\n{\n\tif (!browser->he_selection)\n\t\treturn;\n\n\tif (unfold == browser->he_selection->unfolded)\n\t\treturn;\n\n\thist_browser__toggle_fold(browser);\n}\n\nstatic void ui_browser__warn_lost_events(struct ui_browser *browser)\n{\n\tui_browser__warning(browser, 4,\n\t\t\"Events are being lost, check IO/CPU overload!\\n\\n\"\n\t\t\"You may want to run 'perf' using a RT scheduler policy:\\n\\n\"\n\t\t\" perf top -r 80\\n\\n\"\n\t\t\"Or reduce the sampling frequency.\");\n}\n\nstatic int hist_browser__title(struct hist_browser *browser, char *bf, size_t size)\n{\n\treturn browser->title ? browser->title(browser, bf, size) : 0;\n}\n\nstatic int hist_browser__handle_hotkey(struct hist_browser *browser, bool warn_lost_event, char *title, size_t size, int key)\n{\n\tswitch (key) {\n\tcase K_TIMER: {\n\t\tstruct hist_browser_timer *hbt = browser->hbt;\n\t\tstruct evsel *evsel = hists_to_evsel(browser->hists);\n\t\tu64 nr_entries;\n\n\t\tWARN_ON_ONCE(!hbt);\n\n\t\tif (hbt)\n\t\t\thbt->timer(hbt->arg);\n\n\t\tif (hist_browser__has_filter(browser) || symbol_conf.report_hierarchy)\n\t\t\thist_browser__update_nr_entries(browser);\n\n\t\tnr_entries = hist_browser__nr_entries(browser);\n\t\tui_browser__update_nr_entries(&browser->b, nr_entries);\n\n\t\tif (warn_lost_event &&\n\t\t    (evsel->evlist->stats.nr_lost_warned !=\n\t\t     evsel->evlist->stats.nr_events[PERF_RECORD_LOST])) {\n\t\t\tevsel->evlist->stats.nr_lost_warned =\n\t\t\t\tevsel->evlist->stats.nr_events[PERF_RECORD_LOST];\n\t\t\tui_browser__warn_lost_events(&browser->b);\n\t\t}\n\n\t\thist_browser__title(browser, title, size);\n\t\tui_browser__show_title(&browser->b, title);\n\t\tbreak;\n\t}\n\tcase 'D': {  \n\t\tstruct hist_entry *h = rb_entry(browser->b.top, struct hist_entry, rb_node);\n\t\tstatic int seq;\n\n\t\tui_helpline__pop();\n\t\tui_helpline__fpush(\"%d: nr_ent=(%d,%d), etl: %d, rows=%d, idx=%d, fve: idx=%d, row_off=%d, nrows=%d\",\n\t\t\t\t   seq++, browser->b.nr_entries, browser->hists->nr_entries,\n\t\t\t\t   browser->b.extra_title_lines, browser->b.rows,\n\t\t\t\t   browser->b.index, browser->b.top_idx, h->row_offset, h->nr_rows);\n\t}\n\t\tbreak;\n\tcase 'C':\n\t\t \n\t\thist_browser__set_folding(browser, false);\n\t\tbreak;\n\tcase 'c':\n\t\t \n\t\thist_browser__set_folding_selected(browser, false);\n\t\tbreak;\n\tcase 'E':\n\t\t \n\t\thist_browser__set_folding(browser, true);\n\t\tbreak;\n\tcase 'e':\n\t\t \n\t\thist_browser__toggle_fold(browser);\n\t\tbreak;\n\tcase 'H':\n\t\tbrowser->show_headers = !browser->show_headers;\n\t\thist_browser__update_rows(browser);\n\t\tbreak;\n\tcase '+':\n\t\tif (hist_browser__toggle_fold(browser))\n\t\t\tbreak;\n\t\t \n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint hist_browser__run(struct hist_browser *browser, const char *help,\n\t\t      bool warn_lost_event, int key)\n{\n\tchar title[160];\n\tstruct hist_browser_timer *hbt = browser->hbt;\n\tint delay_secs = hbt ? hbt->refresh : 0;\n\n\tbrowser->b.entries = &browser->hists->entries;\n\tbrowser->b.nr_entries = hist_browser__nr_entries(browser);\n\n\thist_browser__title(browser, title, sizeof(title));\n\n\tif (ui_browser__show(&browser->b, title, \"%s\", help) < 0)\n\t\treturn -1;\n\n\tif (key && hist_browser__handle_hotkey(browser, warn_lost_event, title, sizeof(title), key))\n\t\tgoto out;\n\n\twhile (1) {\n\t\tkey = ui_browser__run(&browser->b, delay_secs);\n\n\t\tif (hist_browser__handle_hotkey(browser, warn_lost_event, title, sizeof(title), key))\n\t\t\tbreak;\n\t}\nout:\n\tui_browser__hide(&browser->b);\n\treturn key;\n}\n\nstruct callchain_print_arg {\n\t \n\toff_t\trow_offset;\n\tbool\tis_current_entry;\n\n\t \n\tFILE\t*fp;\n\tint\tprinted;\n};\n\ntypedef void (*print_callchain_entry_fn)(struct hist_browser *browser,\n\t\t\t\t\t struct callchain_list *chain,\n\t\t\t\t\t const char *str, int offset,\n\t\t\t\t\t unsigned short row,\n\t\t\t\t\t struct callchain_print_arg *arg);\n\nstatic void hist_browser__show_callchain_entry(struct hist_browser *browser,\n\t\t\t\t\t       struct callchain_list *chain,\n\t\t\t\t\t       const char *str, int offset,\n\t\t\t\t\t       unsigned short row,\n\t\t\t\t\t       struct callchain_print_arg *arg)\n{\n\tint color, width;\n\tchar folded_sign = callchain_list__folded(chain);\n\tbool show_annotated = browser->show_dso && chain->ms.sym && symbol__annotation(chain->ms.sym)->src;\n\n\tcolor = HE_COLORSET_NORMAL;\n\twidth = browser->b.width - (offset + 2);\n\tif (ui_browser__is_current_entry(&browser->b, row)) {\n\t\tbrowser->selection = &chain->ms;\n\t\tcolor = HE_COLORSET_SELECTED;\n\t\targ->is_current_entry = true;\n\t}\n\n\tui_browser__set_color(&browser->b, color);\n\tui_browser__gotorc(&browser->b, row, 0);\n\tui_browser__write_nstring(&browser->b, \" \", offset);\n\tui_browser__printf(&browser->b, \"%c\", folded_sign);\n\tui_browser__write_graph(&browser->b, show_annotated ? SLSMG_RARROW_CHAR : ' ');\n\tui_browser__write_nstring(&browser->b, str, width);\n}\n\nstatic void hist_browser__fprintf_callchain_entry(struct hist_browser *b __maybe_unused,\n\t\t\t\t\t\t  struct callchain_list *chain,\n\t\t\t\t\t\t  const char *str, int offset,\n\t\t\t\t\t\t  unsigned short row __maybe_unused,\n\t\t\t\t\t\t  struct callchain_print_arg *arg)\n{\n\tchar folded_sign = callchain_list__folded(chain);\n\n\targ->printed += fprintf(arg->fp, \"%*s%c %s\\n\", offset, \" \",\n\t\t\t\tfolded_sign, str);\n}\n\ntypedef bool (*check_output_full_fn)(struct hist_browser *browser,\n\t\t\t\t     unsigned short row);\n\nstatic bool hist_browser__check_output_full(struct hist_browser *browser,\n\t\t\t\t\t    unsigned short row)\n{\n\treturn browser->b.rows == row;\n}\n\nstatic bool hist_browser__check_dump_full(struct hist_browser *browser __maybe_unused,\n\t\t\t\t\t  unsigned short row __maybe_unused)\n{\n\treturn false;\n}\n\n#define LEVEL_OFFSET_STEP 3\n\nstatic int hist_browser__show_callchain_list(struct hist_browser *browser,\n\t\t\t\t\t     struct callchain_node *node,\n\t\t\t\t\t     struct callchain_list *chain,\n\t\t\t\t\t     unsigned short row, u64 total,\n\t\t\t\t\t     bool need_percent, int offset,\n\t\t\t\t\t     print_callchain_entry_fn print,\n\t\t\t\t\t     struct callchain_print_arg *arg)\n{\n\tchar bf[1024], *alloc_str;\n\tchar buf[64], *alloc_str2;\n\tconst char *str;\n\tint ret = 1;\n\n\tif (arg->row_offset != 0) {\n\t\targ->row_offset--;\n\t\treturn 0;\n\t}\n\n\talloc_str = NULL;\n\talloc_str2 = NULL;\n\n\tstr = callchain_list__sym_name(chain, bf, sizeof(bf),\n\t\t\t\t       browser->show_dso);\n\n\tif (symbol_conf.show_branchflag_count) {\n\t\tcallchain_list_counts__printf_value(chain, NULL,\n\t\t\t\t\t\t    buf, sizeof(buf));\n\n\t\tif (asprintf(&alloc_str2, \"%s%s\", str, buf) < 0)\n\t\t\tstr = \"Not enough memory!\";\n\t\telse\n\t\t\tstr = alloc_str2;\n\t}\n\n\tif (need_percent) {\n\t\tcallchain_node__scnprintf_value(node, buf, sizeof(buf),\n\t\t\t\t\t\ttotal);\n\n\t\tif (asprintf(&alloc_str, \"%s %s\", buf, str) < 0)\n\t\t\tstr = \"Not enough memory!\";\n\t\telse\n\t\t\tstr = alloc_str;\n\t}\n\n\tprint(browser, chain, str, offset, row, arg);\n\tfree(alloc_str);\n\tfree(alloc_str2);\n\n\treturn ret;\n}\n\nstatic bool check_percent_display(struct rb_node *node, u64 parent_total)\n{\n\tstruct callchain_node *child;\n\n\tif (node == NULL)\n\t\treturn false;\n\n\tif (rb_next(node))\n\t\treturn true;\n\n\tchild = rb_entry(node, struct callchain_node, rb_node);\n\treturn callchain_cumul_hits(child) != parent_total;\n}\n\nstatic int hist_browser__show_callchain_flat(struct hist_browser *browser,\n\t\t\t\t\t     struct rb_root *root,\n\t\t\t\t\t     unsigned short row, u64 total,\n\t\t\t\t\t     u64 parent_total,\n\t\t\t\t\t     print_callchain_entry_fn print,\n\t\t\t\t\t     struct callchain_print_arg *arg,\n\t\t\t\t\t     check_output_full_fn is_output_full)\n{\n\tstruct rb_node *node;\n\tint first_row = row, offset = LEVEL_OFFSET_STEP;\n\tbool need_percent;\n\n\tnode = rb_first(root);\n\tneed_percent = check_percent_display(node, parent_total);\n\n\twhile (node) {\n\t\tstruct callchain_node *child = rb_entry(node, struct callchain_node, rb_node);\n\t\tstruct rb_node *next = rb_next(node);\n\t\tstruct callchain_list *chain;\n\t\tchar folded_sign = ' ';\n\t\tint first = true;\n\t\tint extra_offset = 0;\n\n\t\tlist_for_each_entry(chain, &child->parent_val, list) {\n\t\t\tbool was_first = first;\n\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse if (need_percent)\n\t\t\t\textra_offset = LEVEL_OFFSET_STEP;\n\n\t\t\tfolded_sign = callchain_list__folded(chain);\n\n\t\t\trow += hist_browser__show_callchain_list(browser, child,\n\t\t\t\t\t\t\tchain, row, total,\n\t\t\t\t\t\t\twas_first && need_percent,\n\t\t\t\t\t\t\toffset + extra_offset,\n\t\t\t\t\t\t\tprint, arg);\n\n\t\t\tif (is_output_full(browser, row))\n\t\t\t\tgoto out;\n\n\t\t\tif (folded_sign == '+')\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tlist_for_each_entry(chain, &child->val, list) {\n\t\t\tbool was_first = first;\n\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse if (need_percent)\n\t\t\t\textra_offset = LEVEL_OFFSET_STEP;\n\n\t\t\tfolded_sign = callchain_list__folded(chain);\n\n\t\t\trow += hist_browser__show_callchain_list(browser, child,\n\t\t\t\t\t\t\tchain, row, total,\n\t\t\t\t\t\t\twas_first && need_percent,\n\t\t\t\t\t\t\toffset + extra_offset,\n\t\t\t\t\t\t\tprint, arg);\n\n\t\t\tif (is_output_full(browser, row))\n\t\t\t\tgoto out;\n\n\t\t\tif (folded_sign == '+')\n\t\t\t\tbreak;\n\t\t}\n\nnext:\n\t\tif (is_output_full(browser, row))\n\t\t\tbreak;\n\t\tnode = next;\n\t}\nout:\n\treturn row - first_row;\n}\n\nstatic char *hist_browser__folded_callchain_str(struct hist_browser *browser,\n\t\t\t\t\t\tstruct callchain_list *chain,\n\t\t\t\t\t\tchar *value_str, char *old_str)\n{\n\tchar bf[1024];\n\tconst char *str;\n\tchar *new;\n\n\tstr = callchain_list__sym_name(chain, bf, sizeof(bf),\n\t\t\t\t       browser->show_dso);\n\tif (old_str) {\n\t\tif (asprintf(&new, \"%s%s%s\", old_str,\n\t\t\t     symbol_conf.field_sep ?: \";\", str) < 0)\n\t\t\tnew = NULL;\n\t} else {\n\t\tif (value_str) {\n\t\t\tif (asprintf(&new, \"%s %s\", value_str, str) < 0)\n\t\t\t\tnew = NULL;\n\t\t} else {\n\t\t\tif (asprintf(&new, \"%s\", str) < 0)\n\t\t\t\tnew = NULL;\n\t\t}\n\t}\n\treturn new;\n}\n\nstatic int hist_browser__show_callchain_folded(struct hist_browser *browser,\n\t\t\t\t\t       struct rb_root *root,\n\t\t\t\t\t       unsigned short row, u64 total,\n\t\t\t\t\t       u64 parent_total,\n\t\t\t\t\t       print_callchain_entry_fn print,\n\t\t\t\t\t       struct callchain_print_arg *arg,\n\t\t\t\t\t       check_output_full_fn is_output_full)\n{\n\tstruct rb_node *node;\n\tint first_row = row, offset = LEVEL_OFFSET_STEP;\n\tbool need_percent;\n\n\tnode = rb_first(root);\n\tneed_percent = check_percent_display(node, parent_total);\n\n\twhile (node) {\n\t\tstruct callchain_node *child = rb_entry(node, struct callchain_node, rb_node);\n\t\tstruct rb_node *next = rb_next(node);\n\t\tstruct callchain_list *chain, *first_chain = NULL;\n\t\tint first = true;\n\t\tchar *value_str = NULL, *value_str_alloc = NULL;\n\t\tchar *chain_str = NULL, *chain_str_alloc = NULL;\n\n\t\tif (arg->row_offset != 0) {\n\t\t\targ->row_offset--;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (need_percent) {\n\t\t\tchar buf[64];\n\n\t\t\tcallchain_node__scnprintf_value(child, buf, sizeof(buf), total);\n\t\t\tif (asprintf(&value_str, \"%s\", buf) < 0) {\n\t\t\t\tvalue_str = (char *)\"<...>\";\n\t\t\t\tgoto do_print;\n\t\t\t}\n\t\t\tvalue_str_alloc = value_str;\n\t\t}\n\n\t\tlist_for_each_entry(chain, &child->parent_val, list) {\n\t\t\tchain_str = hist_browser__folded_callchain_str(browser,\n\t\t\t\t\t\tchain, value_str, chain_str);\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tfirst_chain = chain;\n\t\t\t}\n\n\t\t\tif (chain_str == NULL) {\n\t\t\t\tchain_str = (char *)\"Not enough memory!\";\n\t\t\t\tgoto do_print;\n\t\t\t}\n\n\t\t\tchain_str_alloc = chain_str;\n\t\t}\n\n\t\tlist_for_each_entry(chain, &child->val, list) {\n\t\t\tchain_str = hist_browser__folded_callchain_str(browser,\n\t\t\t\t\t\tchain, value_str, chain_str);\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tfirst_chain = chain;\n\t\t\t}\n\n\t\t\tif (chain_str == NULL) {\n\t\t\t\tchain_str = (char *)\"Not enough memory!\";\n\t\t\t\tgoto do_print;\n\t\t\t}\n\n\t\t\tchain_str_alloc = chain_str;\n\t\t}\n\ndo_print:\n\t\tprint(browser, first_chain, chain_str, offset, row++, arg);\n\t\tfree(value_str_alloc);\n\t\tfree(chain_str_alloc);\n\nnext:\n\t\tif (is_output_full(browser, row))\n\t\t\tbreak;\n\t\tnode = next;\n\t}\n\n\treturn row - first_row;\n}\n\nstatic int hist_browser__show_callchain_graph(struct hist_browser *browser,\n\t\t\t\t\tstruct rb_root *root, int level,\n\t\t\t\t\tunsigned short row, u64 total,\n\t\t\t\t\tu64 parent_total,\n\t\t\t\t\tprint_callchain_entry_fn print,\n\t\t\t\t\tstruct callchain_print_arg *arg,\n\t\t\t\t\tcheck_output_full_fn is_output_full)\n{\n\tstruct rb_node *node;\n\tint first_row = row, offset = level * LEVEL_OFFSET_STEP;\n\tbool need_percent;\n\tu64 percent_total = total;\n\n\tif (callchain_param.mode == CHAIN_GRAPH_REL)\n\t\tpercent_total = parent_total;\n\n\tnode = rb_first(root);\n\tneed_percent = check_percent_display(node, parent_total);\n\n\twhile (node) {\n\t\tstruct callchain_node *child = rb_entry(node, struct callchain_node, rb_node);\n\t\tstruct rb_node *next = rb_next(node);\n\t\tstruct callchain_list *chain;\n\t\tchar folded_sign = ' ';\n\t\tint first = true;\n\t\tint extra_offset = 0;\n\n\t\tlist_for_each_entry(chain, &child->val, list) {\n\t\t\tbool was_first = first;\n\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse if (need_percent)\n\t\t\t\textra_offset = LEVEL_OFFSET_STEP;\n\n\t\t\tfolded_sign = callchain_list__folded(chain);\n\n\t\t\trow += hist_browser__show_callchain_list(browser, child,\n\t\t\t\t\t\t\tchain, row, percent_total,\n\t\t\t\t\t\t\twas_first && need_percent,\n\t\t\t\t\t\t\toffset + extra_offset,\n\t\t\t\t\t\t\tprint, arg);\n\n\t\t\tif (is_output_full(browser, row))\n\t\t\t\tgoto out;\n\n\t\t\tif (folded_sign == '+')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (folded_sign == '-') {\n\t\t\tconst int new_level = level + (extra_offset ? 2 : 1);\n\n\t\t\trow += hist_browser__show_callchain_graph(browser, &child->rb_root,\n\t\t\t\t\t\t\t    new_level, row, total,\n\t\t\t\t\t\t\t    child->children_hit,\n\t\t\t\t\t\t\t    print, arg, is_output_full);\n\t\t}\n\t\tif (is_output_full(browser, row))\n\t\t\tbreak;\n\t\tnode = next;\n\t}\nout:\n\treturn row - first_row;\n}\n\nstatic int hist_browser__show_callchain(struct hist_browser *browser,\n\t\t\t\t\tstruct hist_entry *entry, int level,\n\t\t\t\t\tunsigned short row,\n\t\t\t\t\tprint_callchain_entry_fn print,\n\t\t\t\t\tstruct callchain_print_arg *arg,\n\t\t\t\t\tcheck_output_full_fn is_output_full)\n{\n\tu64 total = hists__total_period(entry->hists);\n\tu64 parent_total;\n\tint printed;\n\n\tif (symbol_conf.cumulate_callchain)\n\t\tparent_total = entry->stat_acc->period;\n\telse\n\t\tparent_total = entry->stat.period;\n\n\tif (callchain_param.mode == CHAIN_FLAT) {\n\t\tprinted = hist_browser__show_callchain_flat(browser,\n\t\t\t\t\t\t&entry->sorted_chain, row,\n\t\t\t\t\t\ttotal, parent_total, print, arg,\n\t\t\t\t\t\tis_output_full);\n\t} else if (callchain_param.mode == CHAIN_FOLDED) {\n\t\tprinted = hist_browser__show_callchain_folded(browser,\n\t\t\t\t\t\t&entry->sorted_chain, row,\n\t\t\t\t\t\ttotal, parent_total, print, arg,\n\t\t\t\t\t\tis_output_full);\n\t} else {\n\t\tprinted = hist_browser__show_callchain_graph(browser,\n\t\t\t\t\t\t&entry->sorted_chain, level, row,\n\t\t\t\t\t\ttotal, parent_total, print, arg,\n\t\t\t\t\t\tis_output_full);\n\t}\n\n\tif (arg->is_current_entry)\n\t\tbrowser->he_selection = entry;\n\n\treturn printed;\n}\n\nstruct hpp_arg {\n\tstruct ui_browser *b;\n\tchar folded_sign;\n\tbool current_entry;\n};\n\nint __hpp__slsmg_color_printf(struct perf_hpp *hpp, const char *fmt, ...)\n{\n\tstruct hpp_arg *arg = hpp->ptr;\n\tint ret, len;\n\tva_list args;\n\tdouble percent;\n\n\tva_start(args, fmt);\n\tlen = va_arg(args, int);\n\tpercent = va_arg(args, double);\n\tva_end(args);\n\n\tui_browser__set_percent_color(arg->b, percent, arg->current_entry);\n\n\tret = scnprintf(hpp->buf, hpp->size, fmt, len, percent);\n\tui_browser__printf(arg->b, \"%s\", hpp->buf);\n\n\treturn ret;\n}\n\n#define __HPP_COLOR_PERCENT_FN(_type, _field)\t\t\t\t\\\nstatic u64 __hpp_get_##_field(struct hist_entry *he)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn he->stat._field;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nhist_browser__hpp_color_##_type(struct perf_hpp_fmt *fmt,\t\t\\\n\t\t\t\tstruct perf_hpp *hpp,\t\t\t\\\n\t\t\t\tstruct hist_entry *he)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn hpp__fmt(fmt, hpp, he, __hpp_get_##_field, \" %*.2f%%\",\t\\\n\t\t\t__hpp__slsmg_color_printf, true);\t\t\\\n}\n\n#define __HPP_COLOR_ACC_PERCENT_FN(_type, _field)\t\t\t\\\nstatic u64 __hpp_get_acc_##_field(struct hist_entry *he)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn he->stat_acc->_field;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nhist_browser__hpp_color_##_type(struct perf_hpp_fmt *fmt,\t\t\\\n\t\t\t\tstruct perf_hpp *hpp,\t\t\t\\\n\t\t\t\tstruct hist_entry *he)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (!symbol_conf.cumulate_callchain) {\t\t\t\t\\\n\t\tstruct hpp_arg *arg = hpp->ptr;\t\t\t\t\\\n\t\tint len = fmt->user_len ?: fmt->len;\t\t\t\\\n\t\tint ret = scnprintf(hpp->buf, hpp->size,\t\t\\\n\t\t\t\t    \"%*s\", len, \"N/A\");\t\t\t\\\n\t\tui_browser__printf(arg->b, \"%s\", hpp->buf);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn hpp__fmt(fmt, hpp, he, __hpp_get_acc_##_field,\t\t\\\n\t\t\t\" %*.2f%%\", __hpp__slsmg_color_printf, true);\t\\\n}\n\n__HPP_COLOR_PERCENT_FN(overhead, period)\n__HPP_COLOR_PERCENT_FN(overhead_sys, period_sys)\n__HPP_COLOR_PERCENT_FN(overhead_us, period_us)\n__HPP_COLOR_PERCENT_FN(overhead_guest_sys, period_guest_sys)\n__HPP_COLOR_PERCENT_FN(overhead_guest_us, period_guest_us)\n__HPP_COLOR_ACC_PERCENT_FN(overhead_acc, period)\n\n#undef __HPP_COLOR_PERCENT_FN\n#undef __HPP_COLOR_ACC_PERCENT_FN\n\nvoid hist_browser__init_hpp(void)\n{\n\tperf_hpp__format[PERF_HPP__OVERHEAD].color =\n\t\t\t\thist_browser__hpp_color_overhead;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_SYS].color =\n\t\t\t\thist_browser__hpp_color_overhead_sys;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_US].color =\n\t\t\t\thist_browser__hpp_color_overhead_us;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_GUEST_SYS].color =\n\t\t\t\thist_browser__hpp_color_overhead_guest_sys;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_GUEST_US].color =\n\t\t\t\thist_browser__hpp_color_overhead_guest_us;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_ACC].color =\n\t\t\t\thist_browser__hpp_color_overhead_acc;\n\n\tres_sample_init();\n}\n\nstatic int hist_browser__show_entry(struct hist_browser *browser,\n\t\t\t\t    struct hist_entry *entry,\n\t\t\t\t    unsigned short row)\n{\n\tint printed = 0;\n\tint width = browser->b.width;\n\tchar folded_sign = ' ';\n\tbool current_entry = ui_browser__is_current_entry(&browser->b, row);\n\tbool use_callchain = hist_entry__has_callchains(entry) && symbol_conf.use_callchain;\n\toff_t row_offset = entry->row_offset;\n\tbool first = true;\n\tstruct perf_hpp_fmt *fmt;\n\n\tif (current_entry) {\n\t\tbrowser->he_selection = entry;\n\t\tbrowser->selection = &entry->ms;\n\t}\n\n\tif (use_callchain) {\n\t\thist_entry__init_have_children(entry);\n\t\tfolded_sign = hist_entry__folded(entry);\n\t}\n\n\tif (row_offset == 0) {\n\t\tstruct hpp_arg arg = {\n\t\t\t.b\t\t= &browser->b,\n\t\t\t.folded_sign\t= folded_sign,\n\t\t\t.current_entry\t= current_entry,\n\t\t};\n\t\tint column = 0;\n\n\t\tui_browser__gotorc(&browser->b, row, 0);\n\n\t\thists__for_each_format(browser->hists, fmt) {\n\t\t\tchar s[2048];\n\t\t\tstruct perf_hpp hpp = {\n\t\t\t\t.buf\t= s,\n\t\t\t\t.size\t= sizeof(s),\n\t\t\t\t.ptr\t= &arg,\n\t\t\t};\n\n\t\t\tif (perf_hpp__should_skip(fmt, entry->hists) ||\n\t\t\t    column++ < browser->b.horiz_scroll)\n\t\t\t\tcontinue;\n\n\t\t\tif (current_entry && browser->b.navkeypressed) {\n\t\t\t\tui_browser__set_color(&browser->b,\n\t\t\t\t\t\t      HE_COLORSET_SELECTED);\n\t\t\t} else {\n\t\t\t\tui_browser__set_color(&browser->b,\n\t\t\t\t\t\t      HE_COLORSET_NORMAL);\n\t\t\t}\n\n\t\t\tif (first) {\n\t\t\t\tif (use_callchain) {\n\t\t\t\t\tui_browser__printf(&browser->b, \"%c \", folded_sign);\n\t\t\t\t\twidth -= 2;\n\t\t\t\t}\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tui_browser__printf(&browser->b, \"  \");\n\t\t\t\twidth -= 2;\n\t\t\t}\n\n\t\t\tif (fmt->color) {\n\t\t\t\tint ret = fmt->color(fmt, &hpp, entry);\n\t\t\t\thist_entry__snprintf_alignment(entry, &hpp, fmt, ret);\n\t\t\t\t \n\t\t\t\tui_browser__printf(&browser->b, \"%s\", s + ret);\n\t\t\t} else {\n\t\t\t\thist_entry__snprintf_alignment(entry, &hpp, fmt, fmt->entry(fmt, &hpp, entry));\n\t\t\t\tui_browser__printf(&browser->b, \"%s\", s);\n\t\t\t}\n\t\t\twidth -= hpp.buf - s;\n\t\t}\n\n\t\t \n\t\tif (!browser->b.navkeypressed)\n\t\t\twidth += 1;\n\n\t\tui_browser__write_nstring(&browser->b, \"\", width);\n\n\t\t++row;\n\t\t++printed;\n\t} else\n\t\t--row_offset;\n\n\tif (folded_sign == '-' && row != browser->b.rows) {\n\t\tstruct callchain_print_arg arg = {\n\t\t\t.row_offset = row_offset,\n\t\t\t.is_current_entry = current_entry,\n\t\t};\n\n\t\tprinted += hist_browser__show_callchain(browser,\n\t\t\t\tentry, 1, row,\n\t\t\t\thist_browser__show_callchain_entry,\n\t\t\t\t&arg,\n\t\t\t\thist_browser__check_output_full);\n\t}\n\n\treturn printed;\n}\n\nstatic int hist_browser__show_hierarchy_entry(struct hist_browser *browser,\n\t\t\t\t\t      struct hist_entry *entry,\n\t\t\t\t\t      unsigned short row,\n\t\t\t\t\t      int level)\n{\n\tint printed = 0;\n\tint width = browser->b.width;\n\tchar folded_sign = ' ';\n\tbool current_entry = ui_browser__is_current_entry(&browser->b, row);\n\toff_t row_offset = entry->row_offset;\n\tbool first = true;\n\tstruct perf_hpp_fmt *fmt;\n\tstruct perf_hpp_list_node *fmt_node;\n\tstruct hpp_arg arg = {\n\t\t.b\t\t= &browser->b,\n\t\t.current_entry\t= current_entry,\n\t};\n\tint column = 0;\n\tint hierarchy_indent = (entry->hists->nr_hpp_node - 2) * HIERARCHY_INDENT;\n\n\tif (current_entry) {\n\t\tbrowser->he_selection = entry;\n\t\tbrowser->selection = &entry->ms;\n\t}\n\n\thist_entry__init_have_children(entry);\n\tfolded_sign = hist_entry__folded(entry);\n\targ.folded_sign = folded_sign;\n\n\tif (entry->leaf && row_offset) {\n\t\trow_offset--;\n\t\tgoto show_callchain;\n\t}\n\n\tui_browser__gotorc(&browser->b, row, 0);\n\n\tif (current_entry && browser->b.navkeypressed)\n\t\tui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);\n\telse\n\t\tui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);\n\n\tui_browser__write_nstring(&browser->b, \"\", level * HIERARCHY_INDENT);\n\twidth -= level * HIERARCHY_INDENT;\n\n\t \n\tfmt_node = list_first_entry(&entry->hists->hpp_formats,\n\t\t\t\t    struct perf_hpp_list_node, list);\n\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\tchar s[2048];\n\t\tstruct perf_hpp hpp = {\n\t\t\t.buf\t\t= s,\n\t\t\t.size\t\t= sizeof(s),\n\t\t\t.ptr\t\t= &arg,\n\t\t};\n\n\t\tif (perf_hpp__should_skip(fmt, entry->hists) ||\n\t\t    column++ < browser->b.horiz_scroll)\n\t\t\tcontinue;\n\n\t\tif (current_entry && browser->b.navkeypressed) {\n\t\t\tui_browser__set_color(&browser->b,\n\t\t\t\t\t      HE_COLORSET_SELECTED);\n\t\t} else {\n\t\t\tui_browser__set_color(&browser->b,\n\t\t\t\t\t      HE_COLORSET_NORMAL);\n\t\t}\n\n\t\tif (first) {\n\t\t\tui_browser__printf(&browser->b, \"%c \", folded_sign);\n\t\t\twidth -= 2;\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tui_browser__printf(&browser->b, \"  \");\n\t\t\twidth -= 2;\n\t\t}\n\n\t\tif (fmt->color) {\n\t\t\tint ret = fmt->color(fmt, &hpp, entry);\n\t\t\thist_entry__snprintf_alignment(entry, &hpp, fmt, ret);\n\t\t\t \n\t\t\tui_browser__printf(&browser->b, \"%s\", s + ret);\n\t\t} else {\n\t\t\tint ret = fmt->entry(fmt, &hpp, entry);\n\t\t\thist_entry__snprintf_alignment(entry, &hpp, fmt, ret);\n\t\t\tui_browser__printf(&browser->b, \"%s\", s);\n\t\t}\n\t\twidth -= hpp.buf - s;\n\t}\n\n\tif (!first) {\n\t\tui_browser__write_nstring(&browser->b, \"\", hierarchy_indent);\n\t\twidth -= hierarchy_indent;\n\t}\n\n\tif (column >= browser->b.horiz_scroll) {\n\t\tchar s[2048];\n\t\tstruct perf_hpp hpp = {\n\t\t\t.buf\t\t= s,\n\t\t\t.size\t\t= sizeof(s),\n\t\t\t.ptr\t\t= &arg,\n\t\t};\n\n\t\tif (current_entry && browser->b.navkeypressed) {\n\t\t\tui_browser__set_color(&browser->b,\n\t\t\t\t\t      HE_COLORSET_SELECTED);\n\t\t} else {\n\t\t\tui_browser__set_color(&browser->b,\n\t\t\t\t\t      HE_COLORSET_NORMAL);\n\t\t}\n\n\t\tperf_hpp_list__for_each_format(entry->hpp_list, fmt) {\n\t\t\tif (first) {\n\t\t\t\tui_browser__printf(&browser->b, \"%c \", folded_sign);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tui_browser__write_nstring(&browser->b, \"\", 2);\n\t\t\t}\n\n\t\t\twidth -= 2;\n\n\t\t\t \n\t\t\tif (fmt->color) {\n\t\t\t\twidth -= fmt->color(fmt, &hpp, entry);\n\t\t\t} else {\n\t\t\t\tint i = 0;\n\n\t\t\t\twidth -= fmt->entry(fmt, &hpp, entry);\n\t\t\t\tui_browser__printf(&browser->b, \"%s\", skip_spaces(s));\n\n\t\t\t\twhile (isspace(s[i++]))\n\t\t\t\t\twidth++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!browser->b.navkeypressed)\n\t\twidth += 1;\n\n\tui_browser__write_nstring(&browser->b, \"\", width);\n\n\t++row;\n\t++printed;\n\nshow_callchain:\n\tif (entry->leaf && folded_sign == '-' && row != browser->b.rows) {\n\t\tstruct callchain_print_arg carg = {\n\t\t\t.row_offset = row_offset,\n\t\t};\n\n\t\tprinted += hist_browser__show_callchain(browser, entry,\n\t\t\t\t\tlevel + 1, row,\n\t\t\t\t\thist_browser__show_callchain_entry, &carg,\n\t\t\t\t\thist_browser__check_output_full);\n\t}\n\n\treturn printed;\n}\n\nstatic int hist_browser__show_no_entry(struct hist_browser *browser,\n\t\t\t\t       unsigned short row, int level)\n{\n\tint width = browser->b.width;\n\tbool current_entry = ui_browser__is_current_entry(&browser->b, row);\n\tbool first = true;\n\tint column = 0;\n\tint ret;\n\tstruct perf_hpp_fmt *fmt;\n\tstruct perf_hpp_list_node *fmt_node;\n\tint indent = browser->hists->nr_hpp_node - 2;\n\n\tif (current_entry) {\n\t\tbrowser->he_selection = NULL;\n\t\tbrowser->selection = NULL;\n\t}\n\n\tui_browser__gotorc(&browser->b, row, 0);\n\n\tif (current_entry && browser->b.navkeypressed)\n\t\tui_browser__set_color(&browser->b, HE_COLORSET_SELECTED);\n\telse\n\t\tui_browser__set_color(&browser->b, HE_COLORSET_NORMAL);\n\n\tui_browser__write_nstring(&browser->b, \"\", level * HIERARCHY_INDENT);\n\twidth -= level * HIERARCHY_INDENT;\n\n\t \n\tfmt_node = list_first_entry(&browser->hists->hpp_formats,\n\t\t\t\t    struct perf_hpp_list_node, list);\n\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\tif (perf_hpp__should_skip(fmt, browser->hists) ||\n\t\t    column++ < browser->b.horiz_scroll)\n\t\t\tcontinue;\n\n\t\tret = fmt->width(fmt, NULL, browser->hists);\n\n\t\tif (first) {\n\t\t\t \n\t\t\tfirst = false;\n\t\t\tret++;\n\t\t} else {\n\t\t\t \n\t\t\tret += 2;\n\t\t}\n\n\t\tui_browser__write_nstring(&browser->b, \"\", ret);\n\t\twidth -= ret;\n\t}\n\n\tui_browser__write_nstring(&browser->b, \"\", indent * HIERARCHY_INDENT);\n\twidth -= indent * HIERARCHY_INDENT;\n\n\tif (column >= browser->b.horiz_scroll) {\n\t\tchar buf[32];\n\n\t\tret = snprintf(buf, sizeof(buf), \"no entry >= %.2f%%\", browser->min_pcnt);\n\t\tui_browser__printf(&browser->b, \"  %s\", buf);\n\t\twidth -= ret + 2;\n\t}\n\n\t \n\tif (!browser->b.navkeypressed)\n\t\twidth += 1;\n\n\tui_browser__write_nstring(&browser->b, \"\", width);\n\treturn 1;\n}\n\nstatic int advance_hpp_check(struct perf_hpp *hpp, int inc)\n{\n\tadvance_hpp(hpp, inc);\n\treturn hpp->size <= 0;\n}\n\nstatic int\nhists_browser__scnprintf_headers(struct hist_browser *browser, char *buf,\n\t\t\t\t size_t size, int line)\n{\n\tstruct hists *hists = browser->hists;\n\tstruct perf_hpp dummy_hpp = {\n\t\t.buf    = buf,\n\t\t.size   = size,\n\t};\n\tstruct perf_hpp_fmt *fmt;\n\tsize_t ret = 0;\n\tint column = 0;\n\tint span = 0;\n\n\tif (hists__has_callchains(hists) && symbol_conf.use_callchain) {\n\t\tret = scnprintf(buf, size, \"  \");\n\t\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\t\treturn ret;\n\t}\n\n\thists__for_each_format(browser->hists, fmt) {\n\t\tif (perf_hpp__should_skip(fmt, hists)  || column++ < browser->b.horiz_scroll)\n\t\t\tcontinue;\n\n\t\tret = fmt->header(fmt, &dummy_hpp, hists, line, &span);\n\t\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\t\tbreak;\n\n\t\tif (span)\n\t\t\tcontinue;\n\n\t\tret = scnprintf(dummy_hpp.buf, dummy_hpp.size, \"  \");\n\t\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int hists_browser__scnprintf_hierarchy_headers(struct hist_browser *browser, char *buf, size_t size)\n{\n\tstruct hists *hists = browser->hists;\n\tstruct perf_hpp dummy_hpp = {\n\t\t.buf    = buf,\n\t\t.size   = size,\n\t};\n\tstruct perf_hpp_fmt *fmt;\n\tstruct perf_hpp_list_node *fmt_node;\n\tsize_t ret = 0;\n\tint column = 0;\n\tint indent = hists->nr_hpp_node - 2;\n\tbool first_node, first_col;\n\n\tret = scnprintf(buf, size, \"  \");\n\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\treturn ret;\n\n\tfirst_node = true;\n\t \n\tfmt_node = list_first_entry(&hists->hpp_formats,\n\t\t\t\t    struct perf_hpp_list_node, list);\n\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\tif (column++ < browser->b.horiz_scroll)\n\t\t\tcontinue;\n\n\t\tret = fmt->header(fmt, &dummy_hpp, hists, 0, NULL);\n\t\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\t\tbreak;\n\n\t\tret = scnprintf(dummy_hpp.buf, dummy_hpp.size, \"  \");\n\t\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\t\tbreak;\n\n\t\tfirst_node = false;\n\t}\n\n\tif (!first_node) {\n\t\tret = scnprintf(dummy_hpp.buf, dummy_hpp.size, \"%*s\",\n\t\t\t\tindent * HIERARCHY_INDENT, \"\");\n\t\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\t\treturn ret;\n\t}\n\n\tfirst_node = true;\n\tlist_for_each_entry_continue(fmt_node, &hists->hpp_formats, list) {\n\t\tif (!first_node) {\n\t\t\tret = scnprintf(dummy_hpp.buf, dummy_hpp.size, \" / \");\n\t\t\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\t\t\tbreak;\n\t\t}\n\t\tfirst_node = false;\n\n\t\tfirst_col = true;\n\t\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\t\tchar *start;\n\n\t\t\tif (perf_hpp__should_skip(fmt, hists))\n\t\t\t\tcontinue;\n\n\t\t\tif (!first_col) {\n\t\t\t\tret = scnprintf(dummy_hpp.buf, dummy_hpp.size, \"+\");\n\t\t\t\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirst_col = false;\n\n\t\t\tret = fmt->header(fmt, &dummy_hpp, hists, 0, NULL);\n\t\t\tdummy_hpp.buf[ret] = '\\0';\n\n\t\t\tstart = strim(dummy_hpp.buf);\n\t\t\tret = strlen(start);\n\n\t\t\tif (start != dummy_hpp.buf)\n\t\t\t\tmemmove(dummy_hpp.buf, start, ret + 1);\n\n\t\t\tif (advance_hpp_check(&dummy_hpp, ret))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void hists_browser__hierarchy_headers(struct hist_browser *browser)\n{\n\tchar headers[1024];\n\n\thists_browser__scnprintf_hierarchy_headers(browser, headers,\n\t\t\t\t\t\t   sizeof(headers));\n\n\tui_browser__gotorc_title(&browser->b, 0, 0);\n\tui_browser__set_color(&browser->b, HE_COLORSET_ROOT);\n\tui_browser__write_nstring(&browser->b, headers, browser->b.width + 1);\n}\n\nstatic void hists_browser__headers(struct hist_browser *browser)\n{\n\tstruct hists *hists = browser->hists;\n\tstruct perf_hpp_list *hpp_list = hists->hpp_list;\n\n\tint line;\n\n\tfor (line = 0; line < hpp_list->nr_header_lines; line++) {\n\t\tchar headers[1024];\n\n\t\thists_browser__scnprintf_headers(browser, headers,\n\t\t\t\t\t\t sizeof(headers), line);\n\n\t\tui_browser__gotorc_title(&browser->b, line, 0);\n\t\tui_browser__set_color(&browser->b, HE_COLORSET_ROOT);\n\t\tui_browser__write_nstring(&browser->b, headers, browser->b.width + 1);\n\t}\n}\n\nstatic void hist_browser__show_headers(struct hist_browser *browser)\n{\n\tif (symbol_conf.report_hierarchy)\n\t\thists_browser__hierarchy_headers(browser);\n\telse\n\t\thists_browser__headers(browser);\n}\n\nstatic void ui_browser__hists_init_top(struct ui_browser *browser)\n{\n\tif (browser->top == NULL) {\n\t\tstruct hist_browser *hb;\n\n\t\thb = container_of(browser, struct hist_browser, b);\n\t\tbrowser->top = rb_first_cached(&hb->hists->entries);\n\t}\n}\n\nstatic unsigned int hist_browser__refresh(struct ui_browser *browser)\n{\n\tunsigned row = 0;\n\tstruct rb_node *nd;\n\tstruct hist_browser *hb = container_of(browser, struct hist_browser, b);\n\n\tif (hb->show_headers)\n\t\thist_browser__show_headers(hb);\n\n\tui_browser__hists_init_top(browser);\n\thb->he_selection = NULL;\n\thb->selection = NULL;\n\n\tfor (nd = browser->top; nd; nd = rb_hierarchy_next(nd)) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\t\tfloat percent;\n\n\t\tif (h->filtered) {\n\t\t\t \n\t\t\th->unfolded = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (symbol_conf.report_individual_block)\n\t\t\tpercent = block_info__total_cycles_percent(h);\n\t\telse\n\t\t\tpercent = hist_entry__get_percent_limit(h);\n\n\t\tif (percent < hb->min_pcnt)\n\t\t\tcontinue;\n\n\t\tif (symbol_conf.report_hierarchy) {\n\t\t\trow += hist_browser__show_hierarchy_entry(hb, h, row,\n\t\t\t\t\t\t\t\t  h->depth);\n\t\t\tif (row == browser->rows)\n\t\t\t\tbreak;\n\n\t\t\tif (h->has_no_entry) {\n\t\t\t\thist_browser__show_no_entry(hb, row, h->depth + 1);\n\t\t\t\trow++;\n\t\t\t}\n\t\t} else {\n\t\t\trow += hist_browser__show_entry(hb, h, row);\n\t\t}\n\n\t\tif (row == browser->rows)\n\t\t\tbreak;\n\t}\n\n\treturn row;\n}\n\nstatic struct rb_node *hists__filter_entries(struct rb_node *nd,\n\t\t\t\t\t     float min_pcnt)\n{\n\twhile (nd != NULL) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\t\tfloat percent = hist_entry__get_percent_limit(h);\n\n\t\tif (!h->filtered && percent >= min_pcnt)\n\t\t\treturn nd;\n\n\t\t \n\t\tif (rb_next(nd))\n\t\t\tnd = rb_next(nd);\n\t\telse\n\t\t\tnd = rb_hierarchy_next(nd);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct rb_node *hists__filter_prev_entries(struct rb_node *nd,\n\t\t\t\t\t\t  float min_pcnt)\n{\n\twhile (nd != NULL) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\t\tfloat percent = hist_entry__get_percent_limit(h);\n\n\t\tif (!h->filtered && percent >= min_pcnt)\n\t\t\treturn nd;\n\n\t\tnd = rb_hierarchy_prev(nd);\n\t}\n\n\treturn NULL;\n}\n\nstatic void ui_browser__hists_seek(struct ui_browser *browser,\n\t\t\t\t   off_t offset, int whence)\n{\n\tstruct hist_entry *h;\n\tstruct rb_node *nd;\n\tbool first = true;\n\tstruct hist_browser *hb;\n\n\thb = container_of(browser, struct hist_browser, b);\n\n\tif (browser->nr_entries == 0)\n\t\treturn;\n\n\tui_browser__hists_init_top(browser);\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\tnd = hists__filter_entries(rb_first(browser->entries),\n\t\t\t\t\t   hb->min_pcnt);\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnd = browser->top;\n\t\tgoto do_offset;\n\tcase SEEK_END:\n\t\tnd = rb_hierarchy_last(rb_last(browser->entries));\n\t\tnd = hists__filter_prev_entries(nd, hb->min_pcnt);\n\t\tfirst = false;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\th = rb_entry(browser->top, struct hist_entry, rb_node);\n\th->row_offset = 0;\n\n\t \ndo_offset:\n\tif (!nd)\n\t\treturn;\n\n\tif (offset > 0) {\n\t\tdo {\n\t\t\th = rb_entry(nd, struct hist_entry, rb_node);\n\t\t\tif (h->unfolded && h->leaf) {\n\t\t\t\tu16 remaining = h->nr_rows - h->row_offset;\n\t\t\t\tif (offset > remaining) {\n\t\t\t\t\toffset -= remaining;\n\t\t\t\t\th->row_offset = 0;\n\t\t\t\t} else {\n\t\t\t\t\th->row_offset += offset;\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tbrowser->top = nd;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnd = hists__filter_entries(rb_hierarchy_next(nd),\n\t\t\t\t\t\t   hb->min_pcnt);\n\t\t\tif (nd == NULL)\n\t\t\t\tbreak;\n\t\t\t--offset;\n\t\t\tbrowser->top = nd;\n\t\t} while (offset != 0);\n\t} else if (offset < 0) {\n\t\twhile (1) {\n\t\t\th = rb_entry(nd, struct hist_entry, rb_node);\n\t\t\tif (h->unfolded && h->leaf) {\n\t\t\t\tif (first) {\n\t\t\t\t\tif (-offset > h->row_offset) {\n\t\t\t\t\t\toffset += h->row_offset;\n\t\t\t\t\t\th->row_offset = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\th->row_offset += offset;\n\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\tbrowser->top = nd;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (-offset > h->nr_rows) {\n\t\t\t\t\t\toffset += h->nr_rows;\n\t\t\t\t\t\th->row_offset = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\th->row_offset = h->nr_rows + offset;\n\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\tbrowser->top = nd;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnd = hists__filter_prev_entries(rb_hierarchy_prev(nd),\n\t\t\t\t\t\t\thb->min_pcnt);\n\t\t\tif (nd == NULL)\n\t\t\t\tbreak;\n\t\t\t++offset;\n\t\t\tbrowser->top = nd;\n\t\t\tif (offset == 0) {\n\t\t\t\t \n\t\t\t\th = rb_entry(nd, struct hist_entry, rb_node);\n\t\t\t\tif (h->unfolded && h->leaf)\n\t\t\t\t\th->row_offset = h->nr_rows;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\t} else {\n\t\tbrowser->top = nd;\n\t\th = rb_entry(nd, struct hist_entry, rb_node);\n\t\th->row_offset = 0;\n\t}\n}\n\nstatic int hist_browser__fprintf_callchain(struct hist_browser *browser,\n\t\t\t\t\t   struct hist_entry *he, FILE *fp,\n\t\t\t\t\t   int level)\n{\n\tstruct callchain_print_arg arg  = {\n\t\t.fp = fp,\n\t};\n\n\thist_browser__show_callchain(browser, he, level, 0,\n\t\t\t\t     hist_browser__fprintf_callchain_entry, &arg,\n\t\t\t\t     hist_browser__check_dump_full);\n\treturn arg.printed;\n}\n\nstatic int hist_browser__fprintf_entry(struct hist_browser *browser,\n\t\t\t\t       struct hist_entry *he, FILE *fp)\n{\n\tchar s[8192];\n\tint printed = 0;\n\tchar folded_sign = ' ';\n\tstruct perf_hpp hpp = {\n\t\t.buf = s,\n\t\t.size = sizeof(s),\n\t};\n\tstruct perf_hpp_fmt *fmt;\n\tbool first = true;\n\tint ret;\n\n\tif (hist_entry__has_callchains(he) && symbol_conf.use_callchain) {\n\t\tfolded_sign = hist_entry__folded(he);\n\t\tprinted += fprintf(fp, \"%c \", folded_sign);\n\t}\n\n\thists__for_each_format(browser->hists, fmt) {\n\t\tif (perf_hpp__should_skip(fmt, he->hists))\n\t\t\tcontinue;\n\n\t\tif (!first) {\n\t\t\tret = scnprintf(hpp.buf, hpp.size, \"  \");\n\t\t\tadvance_hpp(&hpp, ret);\n\t\t} else\n\t\t\tfirst = false;\n\n\t\tret = fmt->entry(fmt, &hpp, he);\n\t\tret = hist_entry__snprintf_alignment(he, &hpp, fmt, ret);\n\t\tadvance_hpp(&hpp, ret);\n\t}\n\tprinted += fprintf(fp, \"%s\\n\", s);\n\n\tif (folded_sign == '-')\n\t\tprinted += hist_browser__fprintf_callchain(browser, he, fp, 1);\n\n\treturn printed;\n}\n\n\nstatic int hist_browser__fprintf_hierarchy_entry(struct hist_browser *browser,\n\t\t\t\t\t\t struct hist_entry *he,\n\t\t\t\t\t\t FILE *fp, int level)\n{\n\tchar s[8192];\n\tint printed = 0;\n\tchar folded_sign = ' ';\n\tstruct perf_hpp hpp = {\n\t\t.buf = s,\n\t\t.size = sizeof(s),\n\t};\n\tstruct perf_hpp_fmt *fmt;\n\tstruct perf_hpp_list_node *fmt_node;\n\tbool first = true;\n\tint ret;\n\tint hierarchy_indent = (he->hists->nr_hpp_node - 2) * HIERARCHY_INDENT;\n\n\tprinted = fprintf(fp, \"%*s\", level * HIERARCHY_INDENT, \"\");\n\n\tfolded_sign = hist_entry__folded(he);\n\tprinted += fprintf(fp, \"%c\", folded_sign);\n\n\t \n\tfmt_node = list_first_entry(&he->hists->hpp_formats,\n\t\t\t\t    struct perf_hpp_list_node, list);\n\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\tif (!first) {\n\t\t\tret = scnprintf(hpp.buf, hpp.size, \"  \");\n\t\t\tadvance_hpp(&hpp, ret);\n\t\t} else\n\t\t\tfirst = false;\n\n\t\tret = fmt->entry(fmt, &hpp, he);\n\t\tadvance_hpp(&hpp, ret);\n\t}\n\n\tret = scnprintf(hpp.buf, hpp.size, \"%*s\", hierarchy_indent, \"\");\n\tadvance_hpp(&hpp, ret);\n\n\tperf_hpp_list__for_each_format(he->hpp_list, fmt) {\n\t\tret = scnprintf(hpp.buf, hpp.size, \"  \");\n\t\tadvance_hpp(&hpp, ret);\n\n\t\tret = fmt->entry(fmt, &hpp, he);\n\t\tadvance_hpp(&hpp, ret);\n\t}\n\n\tstrim(s);\n\tprinted += fprintf(fp, \"%s\\n\", s);\n\n\tif (he->leaf && folded_sign == '-') {\n\t\tprinted += hist_browser__fprintf_callchain(browser, he, fp,\n\t\t\t\t\t\t\t   he->depth + 1);\n\t}\n\n\treturn printed;\n}\n\nstatic int hist_browser__fprintf(struct hist_browser *browser, FILE *fp)\n{\n\tstruct rb_node *nd = hists__filter_entries(rb_first(browser->b.entries),\n\t\t\t\t\t\t   browser->min_pcnt);\n\tint printed = 0;\n\n\twhile (nd) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\n\t\tif (symbol_conf.report_hierarchy) {\n\t\t\tprinted += hist_browser__fprintf_hierarchy_entry(browser,\n\t\t\t\t\t\t\t\t\t h, fp,\n\t\t\t\t\t\t\t\t\t h->depth);\n\t\t} else {\n\t\t\tprinted += hist_browser__fprintf_entry(browser, h, fp);\n\t\t}\n\n\t\tnd = hists__filter_entries(rb_hierarchy_next(nd),\n\t\t\t\t\t   browser->min_pcnt);\n\t}\n\n\treturn printed;\n}\n\nstatic int hist_browser__dump(struct hist_browser *browser)\n{\n\tchar filename[64];\n\tFILE *fp;\n\n\twhile (1) {\n\t\tscnprintf(filename, sizeof(filename), \"perf.hist.%d\", browser->print_seq);\n\t\tif (access(filename, F_OK))\n\t\t\tbreak;\n\t\t \n\t\tif (++browser->print_seq == 8192) {\n\t\t\tui_helpline__fpush(\"Too many perf.hist.N files, nothing written!\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfp = fopen(filename, \"w\");\n\tif (fp == NULL) {\n\t\tchar bf[64];\n\t\tconst char *err = str_error_r(errno, bf, sizeof(bf));\n\t\tui_helpline__fpush(\"Couldn't write to %s: %s\", filename, err);\n\t\treturn -1;\n\t}\n\n\t++browser->print_seq;\n\thist_browser__fprintf(browser, fp);\n\tfclose(fp);\n\tui_helpline__fpush(\"%s written!\", filename);\n\n\treturn 0;\n}\n\nvoid hist_browser__init(struct hist_browser *browser,\n\t\t\tstruct hists *hists)\n{\n\tstruct perf_hpp_fmt *fmt;\n\n\tbrowser->hists\t\t\t= hists;\n\tbrowser->b.refresh\t\t= hist_browser__refresh;\n\tbrowser->b.refresh_dimensions\t= hist_browser__refresh_dimensions;\n\tbrowser->b.seek\t\t\t= ui_browser__hists_seek;\n\tbrowser->b.use_navkeypressed\t= true;\n\tbrowser->show_headers\t\t= symbol_conf.show_hist_headers;\n\thist_browser__set_title_space(browser);\n\n\tif (symbol_conf.report_hierarchy) {\n\t\tstruct perf_hpp_list_node *fmt_node;\n\n\t\t \n\t\tfmt_node = list_first_entry(&hists->hpp_formats,\n\t\t\t\t\t    struct perf_hpp_list_node, list);\n\t\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt)\n\t\t\t++browser->b.columns;\n\n\t\t \n\t\t++browser->b.columns;\n\t} else {\n\t\thists__for_each_format(hists, fmt)\n\t\t\t++browser->b.columns;\n\t}\n\n\thists__reset_column_width(hists);\n}\n\nstruct hist_browser *hist_browser__new(struct hists *hists)\n{\n\tstruct hist_browser *browser = zalloc(sizeof(*browser));\n\n\tif (browser)\n\t\thist_browser__init(browser, hists);\n\n\treturn browser;\n}\n\nstatic struct hist_browser *\nperf_evsel_browser__new(struct evsel *evsel,\n\t\t\tstruct hist_browser_timer *hbt,\n\t\t\tstruct perf_env *env,\n\t\t\tstruct annotation_options *annotation_opts)\n{\n\tstruct hist_browser *browser = hist_browser__new(evsel__hists(evsel));\n\n\tif (browser) {\n\t\tbrowser->hbt   = hbt;\n\t\tbrowser->env   = env;\n\t\tbrowser->title = hists_browser__scnprintf_title;\n\t\tbrowser->annotation_opts = annotation_opts;\n\t}\n\treturn browser;\n}\n\nvoid hist_browser__delete(struct hist_browser *browser)\n{\n\tfree(browser);\n}\n\nstatic struct hist_entry *hist_browser__selected_entry(struct hist_browser *browser)\n{\n\treturn browser->he_selection;\n}\n\nstatic struct thread *hist_browser__selected_thread(struct hist_browser *browser)\n{\n\treturn browser->he_selection->thread;\n}\n\nstatic struct res_sample *hist_browser__selected_res_sample(struct hist_browser *browser)\n{\n\treturn browser->he_selection ? browser->he_selection->res_samples : NULL;\n}\n\n \nstatic inline bool is_report_browser(void *timer)\n{\n\treturn timer == NULL;\n}\n\nstatic int hists_browser__scnprintf_title(struct hist_browser *browser, char *bf, size_t size)\n{\n\tstruct hist_browser_timer *hbt = browser->hbt;\n\tint printed = __hists__scnprintf_title(browser->hists, bf, size, !is_report_browser(hbt));\n\n\tif (!is_report_browser(hbt)) {\n\t\tstruct perf_top *top = hbt->arg;\n\n\t\tprinted += scnprintf(bf + printed, size - printed,\n\t\t\t\t     \" lost: %\" PRIu64 \"/%\" PRIu64,\n\t\t\t\t     top->lost, top->lost_total);\n\n\t\tprinted += scnprintf(bf + printed, size - printed,\n\t\t\t\t     \" drop: %\" PRIu64 \"/%\" PRIu64,\n\t\t\t\t     top->drop, top->drop_total);\n\n\t\tif (top->zero)\n\t\t\tprinted += scnprintf(bf + printed, size - printed, \" [z]\");\n\n\t\tperf_top__reset_sample_counters(top);\n\t}\n\n\n\treturn printed;\n}\n\nstatic inline void free_popup_options(char **options, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; ++i)\n\t\tzfree(&options[i]);\n}\n\n \nstatic bool is_input_name_malloced = false;\n\nstatic int switch_data_file(void)\n{\n\tchar *pwd, *options[32], *abs_path[32], *tmp;\n\tDIR *pwd_dir;\n\tint nr_options = 0, choice = -1, ret = -1;\n\tstruct dirent *dent;\n\n\tpwd = getenv(\"PWD\");\n\tif (!pwd)\n\t\treturn ret;\n\n\tpwd_dir = opendir(pwd);\n\tif (!pwd_dir)\n\t\treturn ret;\n\n\tmemset(options, 0, sizeof(options));\n\tmemset(abs_path, 0, sizeof(abs_path));\n\n\twhile ((dent = readdir(pwd_dir))) {\n\t\tchar path[PATH_MAX];\n\t\tu64 magic;\n\t\tchar *name = dent->d_name;\n\t\tFILE *file;\n\n\t\tif (!(dent->d_type == DT_REG))\n\t\t\tcontinue;\n\n\t\tsnprintf(path, sizeof(path), \"%s/%s\", pwd, name);\n\n\t\tfile = fopen(path, \"r\");\n\t\tif (!file)\n\t\t\tcontinue;\n\n\t\tif (fread(&magic, 1, 8, file) < 8)\n\t\t\tgoto close_file_and_continue;\n\n\t\tif (is_perf_magic(magic)) {\n\t\t\toptions[nr_options] = strdup(name);\n\t\t\tif (!options[nr_options])\n\t\t\t\tgoto close_file_and_continue;\n\n\t\t\tabs_path[nr_options] = strdup(path);\n\t\t\tif (!abs_path[nr_options]) {\n\t\t\t\tzfree(&options[nr_options]);\n\t\t\t\tui__warning(\"Can't search all data files due to memory shortage.\\n\");\n\t\t\t\tfclose(file);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnr_options++;\n\t\t}\n\nclose_file_and_continue:\n\t\tfclose(file);\n\t\tif (nr_options >= 32) {\n\t\t\tui__warning(\"Too many perf data files in PWD!\\n\"\n\t\t\t\t    \"Only the first 32 files will be listed.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tclosedir(pwd_dir);\n\n\tif (nr_options) {\n\t\tchoice = ui__popup_menu(nr_options, options, NULL);\n\t\tif (choice < nr_options && choice >= 0) {\n\t\t\ttmp = strdup(abs_path[choice]);\n\t\t\tif (tmp) {\n\t\t\t\tif (is_input_name_malloced)\n\t\t\t\t\tfree((void *)input_name);\n\t\t\t\tinput_name = tmp;\n\t\t\t\tis_input_name_malloced = true;\n\t\t\t\tret = 0;\n\t\t\t} else\n\t\t\t\tui__warning(\"Data switch failed due to memory shortage!\\n\");\n\t\t}\n\t}\n\n\tfree_popup_options(options, nr_options);\n\tfree_popup_options(abs_path, nr_options);\n\treturn ret;\n}\n\nstruct popup_action {\n\tunsigned long\t\ttime;\n\tstruct thread \t\t*thread;\n\tstruct map_symbol \tms;\n\tint\t\t\tsocket;\n\tstruct evsel\t*evsel;\n\tenum rstype\t\trstype;\n\n\tint (*fn)(struct hist_browser *browser, struct popup_action *act);\n};\n\nstatic int\ndo_annotate(struct hist_browser *browser, struct popup_action *act)\n{\n\tstruct evsel *evsel;\n\tstruct annotation *notes;\n\tstruct hist_entry *he;\n\tint err;\n\n\tif (!browser->annotation_opts->objdump_path &&\n\t    perf_env__lookup_objdump(browser->env, &browser->annotation_opts->objdump_path))\n\t\treturn 0;\n\n\tnotes = symbol__annotation(act->ms.sym);\n\tif (!notes->src)\n\t\treturn 0;\n\n\tif (browser->block_evsel)\n\t\tevsel = browser->block_evsel;\n\telse\n\t\tevsel = hists_to_evsel(browser->hists);\n\n\terr = map_symbol__tui_annotate(&act->ms, evsel, browser->hbt,\n\t\t\t\t       browser->annotation_opts);\n\the = hist_browser__selected_entry(browser);\n\t \n\tif ((err == 'q' || err == CTRL('c')) && he->branch_info)\n\t\treturn 1;\n\n\tui_browser__update_nr_entries(&browser->b, browser->hists->nr_entries);\n\tif (err)\n\t\tui_browser__handle_resize(&browser->b);\n\treturn 0;\n}\n\nstatic struct symbol *symbol__new_unresolved(u64 addr, struct map *map)\n{\n\tstruct annotated_source *src;\n\tstruct symbol *sym;\n\tchar name[64];\n\n\tsnprintf(name, sizeof(name), \"%.*\" PRIx64, BITS_PER_LONG / 4, addr);\n\n\tsym = symbol__new(addr, ANNOTATION_DUMMY_LEN, 0, 0, name);\n\tif (sym) {\n\t\tsrc = symbol__hists(sym, 1);\n\t\tif (!src) {\n\t\t\tsymbol__delete(sym);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdso__insert_symbol(map__dso(map), sym);\n\t}\n\n\treturn sym;\n}\n\nstatic int\nadd_annotate_opt(struct hist_browser *browser __maybe_unused,\n\t\t struct popup_action *act, char **optstr,\n\t\t struct map_symbol *ms,\n\t\t u64 addr)\n{\n\tstruct dso *dso;\n\n\tif (!ms->map || (dso = map__dso(ms->map)) == NULL || dso->annotate_warned)\n\t\treturn 0;\n\n\tif (!ms->sym)\n\t\tms->sym = symbol__new_unresolved(addr, ms->map);\n\n\tif (ms->sym == NULL || symbol__annotation(ms->sym)->src == NULL)\n\t\treturn 0;\n\n\tif (asprintf(optstr, \"Annotate %s\", ms->sym->name) < 0)\n\t\treturn 0;\n\n\tact->ms = *ms;\n\tact->fn = do_annotate;\n\treturn 1;\n}\n\nstatic int\ndo_zoom_thread(struct hist_browser *browser, struct popup_action *act)\n{\n\tstruct thread *thread = act->thread;\n\n\tif ((!hists__has(browser->hists, thread) &&\n\t     !hists__has(browser->hists, comm)) || thread == NULL)\n\t\treturn 0;\n\n\tif (browser->hists->thread_filter) {\n\t\tpstack__remove(browser->pstack, &browser->hists->thread_filter);\n\t\tperf_hpp__set_elide(HISTC_THREAD, false);\n\t\tthread__zput(browser->hists->thread_filter);\n\t\tui_helpline__pop();\n\t} else {\n\t\tconst char *comm_set_str =\n\t\t\tthread__comm_set(thread) ? thread__comm_str(thread) : \"\";\n\n\t\tif (hists__has(browser->hists, thread)) {\n\t\t\tui_helpline__fpush(\"To zoom out press ESC or ENTER + \\\"Zoom out of %s(%d) thread\\\"\",\n\t\t\t\t\t   comm_set_str, thread__tid(thread));\n\t\t} else {\n\t\t\tui_helpline__fpush(\"To zoom out press ESC or ENTER + \\\"Zoom out of %s thread\\\"\",\n\t\t\t\t\t   comm_set_str);\n\t\t}\n\n\t\tbrowser->hists->thread_filter = thread__get(thread);\n\t\tperf_hpp__set_elide(HISTC_THREAD, false);\n\t\tpstack__push(browser->pstack, &browser->hists->thread_filter);\n\t}\n\n\thists__filter_by_thread(browser->hists);\n\thist_browser__reset(browser);\n\treturn 0;\n}\n\nstatic int\nadd_thread_opt(struct hist_browser *browser, struct popup_action *act,\n\t       char **optstr, struct thread *thread)\n{\n\tint ret;\n\tconst char *comm_set_str, *in_out;\n\n\tif ((!hists__has(browser->hists, thread) &&\n\t     !hists__has(browser->hists, comm)) || thread == NULL)\n\t\treturn 0;\n\n\tin_out = browser->hists->thread_filter ? \"out of\" : \"into\";\n\tcomm_set_str = thread__comm_set(thread) ? thread__comm_str(thread) : \"\";\n\tif (hists__has(browser->hists, thread)) {\n\t\tret = asprintf(optstr, \"Zoom %s %s(%d) thread\",\n\t\t\t       in_out, comm_set_str, thread__tid(thread));\n\t} else {\n\t\tret = asprintf(optstr, \"Zoom %s %s thread\", in_out, comm_set_str);\n\t}\n\tif (ret < 0)\n\t\treturn 0;\n\n\tact->thread = thread;\n\tact->fn = do_zoom_thread;\n\treturn 1;\n}\n\nstatic int hists_browser__zoom_map(struct hist_browser *browser, struct map *map)\n{\n\tif (!hists__has(browser->hists, dso) || map == NULL)\n\t\treturn 0;\n\n\tif (browser->hists->dso_filter) {\n\t\tpstack__remove(browser->pstack, &browser->hists->dso_filter);\n\t\tperf_hpp__set_elide(HISTC_DSO, false);\n\t\tbrowser->hists->dso_filter = NULL;\n\t\tui_helpline__pop();\n\t} else {\n\t\tstruct dso *dso = map__dso(map);\n\t\tui_helpline__fpush(\"To zoom out press ESC or ENTER + \\\"Zoom out of %s DSO\\\"\",\n\t\t\t\t   __map__is_kernel(map) ? \"the Kernel\" : dso->short_name);\n\t\tbrowser->hists->dso_filter = dso;\n\t\tperf_hpp__set_elide(HISTC_DSO, true);\n\t\tpstack__push(browser->pstack, &browser->hists->dso_filter);\n\t}\n\n\thists__filter_by_dso(browser->hists);\n\thist_browser__reset(browser);\n\treturn 0;\n}\n\nstatic int\ndo_zoom_dso(struct hist_browser *browser, struct popup_action *act)\n{\n\treturn hists_browser__zoom_map(browser, act->ms.map);\n}\n\nstatic int\nadd_dso_opt(struct hist_browser *browser, struct popup_action *act,\n\t    char **optstr, struct map *map)\n{\n\tif (!hists__has(browser->hists, dso) || map == NULL)\n\t\treturn 0;\n\n\tif (asprintf(optstr, \"Zoom %s %s DSO (use the 'k' hotkey to zoom directly into the kernel)\",\n\t\t     browser->hists->dso_filter ? \"out of\" : \"into\",\n\t\t     __map__is_kernel(map) ? \"the Kernel\" : map__dso(map)->short_name) < 0)\n\t\treturn 0;\n\n\tact->ms.map = map;\n\tact->fn = do_zoom_dso;\n\treturn 1;\n}\n\nstatic int do_toggle_callchain(struct hist_browser *browser, struct popup_action *act __maybe_unused)\n{\n\thist_browser__toggle_fold(browser);\n\treturn 0;\n}\n\nstatic int add_callchain_toggle_opt(struct hist_browser *browser, struct popup_action *act, char **optstr)\n{\n\tchar sym_name[512];\n\n        if (!hist_browser__selection_has_children(browser))\n                return 0;\n\n\tif (asprintf(optstr, \"%s [%s] callchain (one level, same as '+' hotkey, use 'e'/'c' for the whole main level entry)\",\n\t\t     hist_browser__selection_unfolded(browser) ? \"Collapse\" : \"Expand\",\n\t\t     hist_browser__selection_sym_name(browser, sym_name, sizeof(sym_name))) < 0)\n\t\treturn 0;\n\n\tact->fn = do_toggle_callchain;\n\treturn 1;\n}\n\nstatic int\ndo_browse_map(struct hist_browser *browser __maybe_unused,\n\t      struct popup_action *act)\n{\n\tmap__browse(act->ms.map);\n\treturn 0;\n}\n\nstatic int\nadd_map_opt(struct hist_browser *browser,\n\t    struct popup_action *act, char **optstr, struct map *map)\n{\n\tif (!hists__has(browser->hists, dso) || map == NULL)\n\t\treturn 0;\n\n\tif (asprintf(optstr, \"Browse map details\") < 0)\n\t\treturn 0;\n\n\tact->ms.map = map;\n\tact->fn = do_browse_map;\n\treturn 1;\n}\n\nstatic int\ndo_run_script(struct hist_browser *browser __maybe_unused,\n\t      struct popup_action *act)\n{\n\tchar *script_opt;\n\tint len;\n\tint n = 0;\n\n\tlen = 100;\n\tif (act->thread)\n\t\tlen += strlen(thread__comm_str(act->thread));\n\telse if (act->ms.sym)\n\t\tlen += strlen(act->ms.sym->name);\n\tscript_opt = malloc(len);\n\tif (!script_opt)\n\t\treturn -1;\n\n\tscript_opt[0] = 0;\n\tif (act->thread) {\n\t\tn = scnprintf(script_opt, len, \" -c %s \",\n\t\t\t  thread__comm_str(act->thread));\n\t} else if (act->ms.sym) {\n\t\tn = scnprintf(script_opt, len, \" -S %s \",\n\t\t\t  act->ms.sym->name);\n\t}\n\n\tif (act->time) {\n\t\tchar start[32], end[32];\n\t\tunsigned long starttime = act->time;\n\t\tunsigned long endtime = act->time + symbol_conf.time_quantum;\n\n\t\tif (starttime == endtime) {  \n\t\t\tstarttime -= 1*NSEC_PER_MSEC;\n\t\t\tendtime += 1*NSEC_PER_MSEC;\n\t\t}\n\t\ttimestamp__scnprintf_usec(starttime, start, sizeof start);\n\t\ttimestamp__scnprintf_usec(endtime, end, sizeof end);\n\t\tn += snprintf(script_opt + n, len - n, \" --time %s,%s\", start, end);\n\t}\n\n\tscript_browse(script_opt, act->evsel);\n\tfree(script_opt);\n\treturn 0;\n}\n\nstatic int\ndo_res_sample_script(struct hist_browser *browser __maybe_unused,\n\t\t     struct popup_action *act)\n{\n\tstruct hist_entry *he;\n\n\the = hist_browser__selected_entry(browser);\n\tres_sample_browse(he->res_samples, he->num_res, act->evsel, act->rstype);\n\treturn 0;\n}\n\nstatic int\nadd_script_opt_2(struct hist_browser *browser __maybe_unused,\n\t       struct popup_action *act, char **optstr,\n\t       struct thread *thread, struct symbol *sym,\n\t       struct evsel *evsel, const char *tstr)\n{\n\n\tif (thread) {\n\t\tif (asprintf(optstr, \"Run scripts for samples of thread [%s]%s\",\n\t\t\t     thread__comm_str(thread), tstr) < 0)\n\t\t\treturn 0;\n\t} else if (sym) {\n\t\tif (asprintf(optstr, \"Run scripts for samples of symbol [%s]%s\",\n\t\t\t     sym->name, tstr) < 0)\n\t\t\treturn 0;\n\t} else {\n\t\tif (asprintf(optstr, \"Run scripts for all samples%s\", tstr) < 0)\n\t\t\treturn 0;\n\t}\n\n\tact->thread = thread;\n\tact->ms.sym = sym;\n\tact->evsel = evsel;\n\tact->fn = do_run_script;\n\treturn 1;\n}\n\nstatic int\nadd_script_opt(struct hist_browser *browser,\n\t       struct popup_action *act, char **optstr,\n\t       struct thread *thread, struct symbol *sym,\n\t       struct evsel *evsel)\n{\n\tint n, j;\n\tstruct hist_entry *he;\n\n\tn = add_script_opt_2(browser, act, optstr, thread, sym, evsel, \"\");\n\n\the = hist_browser__selected_entry(browser);\n\tif (sort_order && strstr(sort_order, \"time\")) {\n\t\tchar tstr[128];\n\n\t\toptstr++;\n\t\tact++;\n\t\tj = sprintf(tstr, \" in \");\n\t\tj += timestamp__scnprintf_usec(he->time, tstr + j,\n\t\t\t\t\t       sizeof tstr - j);\n\t\tj += sprintf(tstr + j, \"-\");\n\t\ttimestamp__scnprintf_usec(he->time + symbol_conf.time_quantum,\n\t\t\t\t          tstr + j, sizeof tstr - j);\n\t\tn += add_script_opt_2(browser, act, optstr, thread, sym,\n\t\t\t\t\t  evsel, tstr);\n\t\tact->time = he->time;\n\t}\n\treturn n;\n}\n\nstatic int\nadd_res_sample_opt(struct hist_browser *browser __maybe_unused,\n\t\t   struct popup_action *act, char **optstr,\n\t\t   struct res_sample *res_sample,\n\t\t   struct evsel *evsel,\n\t\t   enum rstype type)\n{\n\tif (!res_sample)\n\t\treturn 0;\n\n\tif (asprintf(optstr, \"Show context for individual samples %s\",\n\t\ttype == A_ASM ? \"with assembler\" :\n\t\ttype == A_SOURCE ? \"with source\" : \"\") < 0)\n\t\treturn 0;\n\n\tact->fn = do_res_sample_script;\n\tact->evsel = evsel;\n\tact->rstype = type;\n\treturn 1;\n}\n\nstatic int\ndo_switch_data(struct hist_browser *browser __maybe_unused,\n\t       struct popup_action *act __maybe_unused)\n{\n\tif (switch_data_file()) {\n\t\tui__warning(\"Won't switch the data files due to\\n\"\n\t\t\t    \"no valid data file get selected!\\n\");\n\t\treturn 0;\n\t}\n\n\treturn K_SWITCH_INPUT_DATA;\n}\n\nstatic int\nadd_switch_opt(struct hist_browser *browser,\n\t       struct popup_action *act, char **optstr)\n{\n\tif (!is_report_browser(browser->hbt))\n\t\treturn 0;\n\n\tif (asprintf(optstr, \"Switch to another data file in PWD\") < 0)\n\t\treturn 0;\n\n\tact->fn = do_switch_data;\n\treturn 1;\n}\n\nstatic int\ndo_exit_browser(struct hist_browser *browser __maybe_unused,\n\t\tstruct popup_action *act __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int\nadd_exit_opt(struct hist_browser *browser __maybe_unused,\n\t     struct popup_action *act, char **optstr)\n{\n\tif (asprintf(optstr, \"Exit\") < 0)\n\t\treturn 0;\n\n\tact->fn = do_exit_browser;\n\treturn 1;\n}\n\nstatic int\ndo_zoom_socket(struct hist_browser *browser, struct popup_action *act)\n{\n\tif (!hists__has(browser->hists, socket) || act->socket < 0)\n\t\treturn 0;\n\n\tif (browser->hists->socket_filter > -1) {\n\t\tpstack__remove(browser->pstack, &browser->hists->socket_filter);\n\t\tbrowser->hists->socket_filter = -1;\n\t\tperf_hpp__set_elide(HISTC_SOCKET, false);\n\t} else {\n\t\tbrowser->hists->socket_filter = act->socket;\n\t\tperf_hpp__set_elide(HISTC_SOCKET, true);\n\t\tpstack__push(browser->pstack, &browser->hists->socket_filter);\n\t}\n\n\thists__filter_by_socket(browser->hists);\n\thist_browser__reset(browser);\n\treturn 0;\n}\n\nstatic int\nadd_socket_opt(struct hist_browser *browser, struct popup_action *act,\n\t       char **optstr, int socket_id)\n{\n\tif (!hists__has(browser->hists, socket) || socket_id < 0)\n\t\treturn 0;\n\n\tif (asprintf(optstr, \"Zoom %s Processor Socket %d\",\n\t\t     (browser->hists->socket_filter > -1) ? \"out of\" : \"into\",\n\t\t     socket_id) < 0)\n\t\treturn 0;\n\n\tact->socket = socket_id;\n\tact->fn = do_zoom_socket;\n\treturn 1;\n}\n\nstatic void hist_browser__update_nr_entries(struct hist_browser *hb)\n{\n\tu64 nr_entries = 0;\n\tstruct rb_node *nd = rb_first_cached(&hb->hists->entries);\n\n\tif (hb->min_pcnt == 0 && !symbol_conf.report_hierarchy) {\n\t\thb->nr_non_filtered_entries = hb->hists->nr_non_filtered_entries;\n\t\treturn;\n\t}\n\n\twhile ((nd = hists__filter_entries(nd, hb->min_pcnt)) != NULL) {\n\t\tnr_entries++;\n\t\tnd = rb_hierarchy_next(nd);\n\t}\n\n\thb->nr_non_filtered_entries = nr_entries;\n\thb->nr_hierarchy_entries = nr_entries;\n}\n\nstatic void hist_browser__update_percent_limit(struct hist_browser *hb,\n\t\t\t\t\t       double percent)\n{\n\tstruct hist_entry *he;\n\tstruct rb_node *nd = rb_first_cached(&hb->hists->entries);\n\tu64 total = hists__total_period(hb->hists);\n\tu64 min_callchain_hits = total * (percent / 100);\n\n\thb->min_pcnt = callchain_param.min_percent = percent;\n\n\twhile ((nd = hists__filter_entries(nd, hb->min_pcnt)) != NULL) {\n\t\the = rb_entry(nd, struct hist_entry, rb_node);\n\n\t\tif (he->has_no_entry) {\n\t\t\the->has_no_entry = false;\n\t\t\the->nr_rows = 0;\n\t\t}\n\n\t\tif (!he->leaf || !hist_entry__has_callchains(he) || !symbol_conf.use_callchain)\n\t\t\tgoto next;\n\n\t\tif (callchain_param.mode == CHAIN_GRAPH_REL) {\n\t\t\ttotal = he->stat.period;\n\n\t\t\tif (symbol_conf.cumulate_callchain)\n\t\t\t\ttotal = he->stat_acc->period;\n\n\t\t\tmin_callchain_hits = total * (percent / 100);\n\t\t}\n\n\t\tcallchain_param.sort(&he->sorted_chain, he->callchain,\n\t\t\t\t     min_callchain_hits, &callchain_param);\n\nnext:\n\t\tnd = __rb_hierarchy_next(nd, HMD_FORCE_CHILD);\n\n\t\t \n\t\the->init_have_children = false;\n\t\thist_entry__set_folding(he, hb, false);\n\t}\n}\n\nstatic int evsel__hists_browse(struct evsel *evsel, int nr_events, const char *helpline,\n\t\t\t       bool left_exits, struct hist_browser_timer *hbt, float min_pcnt,\n\t\t\t       struct perf_env *env, bool warn_lost_event,\n\t\t\t       struct annotation_options *annotation_opts)\n{\n\tstruct hists *hists = evsel__hists(evsel);\n\tstruct hist_browser *browser = perf_evsel_browser__new(evsel, hbt, env, annotation_opts);\n\tstruct branch_info *bi = NULL;\n#define MAX_OPTIONS  16\n\tchar *options[MAX_OPTIONS];\n\tstruct popup_action actions[MAX_OPTIONS];\n\tint nr_options = 0;\n\tint key = -1;\n\tchar buf[128];\n\tint delay_secs = hbt ? hbt->refresh : 0;\n\n#define HIST_BROWSER_HELP_COMMON\t\t\t\t\t\\\n\t\"h/?/F1        Show this window\\n\"\t\t\t\t\\\n\t\"UP/DOWN/PGUP\\n\"\t\t\t\t\t\t\\\n\t\"PGDN/SPACE    Navigate\\n\"\t\t\t\t\t\\\n\t\"q/ESC/CTRL+C  Exit browser or go back to previous screen\\n\\n\"\t\\\n\t\"For multiple event sessions:\\n\\n\"\t\t\t\t\\\n\t\"TAB/UNTAB     Switch events\\n\\n\"\t\t\t\t\\\n\t\"For symbolic views (--sort has sym):\\n\\n\"\t\t\t\\\n\t\"ENTER         Zoom into DSO/Threads & Annotate current symbol\\n\" \\\n\t\"ESC           Zoom out\\n\"\t\t\t\t\t\\\n\t\"+             Expand/Collapse one callchain level\\n\"\t\t\\\n\t\"a             Annotate current symbol\\n\"\t\t\t\\\n\t\"C             Collapse all callchains\\n\"\t\t\t\\\n\t\"d             Zoom into current DSO\\n\"\t\t\t\t\\\n\t\"e             Expand/Collapse main entry callchains\\n\"\t\\\n\t\"E             Expand all callchains\\n\"\t\t\t\t\\\n\t\"F             Toggle percentage of filtered entries\\n\"\t\t\\\n\t\"H             Display column headers\\n\"\t\t\t\\\n\t\"k             Zoom into the kernel map\\n\"\t\t\t\\\n\t\"L             Change percent limit\\n\"\t\t\t\t\\\n\t\"m             Display context menu\\n\"\t\t\t\t\\\n\t\"S             Zoom into current Processor Socket\\n\"\t\t\\\n\n\t \n\tstatic const char report_help[] = HIST_BROWSER_HELP_COMMON\n\t\"i             Show header information\\n\"\n\t\"P             Print histograms to perf.hist.N\\n\"\n\t\"r             Run available scripts\\n\"\n\t\"s             Switch to another data file in PWD\\n\"\n\t\"t             Zoom into current Thread\\n\"\n\t\"V             Verbose (DSO names in callchains, etc)\\n\"\n\t\"/             Filter symbol by name\\n\"\n\t\"0-9           Sort by event n in group\";\n\tstatic const char top_help[] = HIST_BROWSER_HELP_COMMON\n\t\"P             Print histograms to perf.hist.N\\n\"\n\t\"t             Zoom into current Thread\\n\"\n\t\"V             Verbose (DSO names in callchains, etc)\\n\"\n\t\"z             Toggle zeroing of samples\\n\"\n\t\"f             Enable/Disable events\\n\"\n\t\"/             Filter symbol by name\";\n\n\tif (browser == NULL)\n\t\treturn -1;\n\n\t \n\tSLang_reset_tty();\n\tSLang_init_tty(0, 0, 0);\n\n\tif (min_pcnt)\n\t\tbrowser->min_pcnt = min_pcnt;\n\thist_browser__update_nr_entries(browser);\n\n\tbrowser->pstack = pstack__new(3);\n\tif (browser->pstack == NULL)\n\t\tgoto out;\n\n\tui_helpline__push(helpline);\n\n\tmemset(options, 0, sizeof(options));\n\tmemset(actions, 0, sizeof(actions));\n\n\tif (symbol_conf.col_width_list_str)\n\t\tperf_hpp__set_user_width(symbol_conf.col_width_list_str);\n\n\tif (!is_report_browser(hbt))\n\t\tbrowser->b.no_samples_msg = \"Collecting samples...\";\n\n\twhile (1) {\n\t\tstruct thread *thread = NULL;\n\t\tstruct map *map = NULL;\n\t\tint choice;\n\t\tint socked_id = -1;\n\n\t\tkey = 0; \ndo_hotkey:\t\t \n\t\tchoice = nr_options = 0;\n\t\tkey = hist_browser__run(browser, helpline, warn_lost_event, key);\n\n\t\tif (browser->he_selection != NULL) {\n\t\t\tthread = hist_browser__selected_thread(browser);\n\t\t\tmap = browser->selection->map;\n\t\t\tsocked_id = browser->he_selection->socket;\n\t\t}\n\t\tswitch (key) {\n\t\tcase K_TAB:\n\t\tcase K_UNTAB:\n\t\t\tif (nr_events == 1)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tgoto out_free_stack;\n\t\tcase '0' ... '9':\n\t\t\tif (!symbol_conf.event_group ||\n\t\t\t    evsel->core.nr_members < 2) {\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"Sort by index only available with group events!\");\n\t\t\t\thelpline = buf;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (key - '0' == symbol_conf.group_sort_idx)\n\t\t\t\tcontinue;\n\n\t\t\tsymbol_conf.group_sort_idx = key - '0';\n\n\t\t\tif (symbol_conf.group_sort_idx >= evsel->core.nr_members) {\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"Max event group index to sort is %d (index from 0 to %d)\",\n\t\t\t\t\t evsel->core.nr_members - 1,\n\t\t\t\t\t evsel->core.nr_members - 1);\n\t\t\t\thelpline = buf;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkey = K_RELOAD;\n\t\t\tgoto out_free_stack;\n\t\tcase 'a':\n\t\t\tif (!hists__has(hists, sym)) {\n\t\t\t\tui_browser__warning(&browser->b, delay_secs * 2,\n\t\t\t\"Annotation is only available for symbolic views, \"\n\t\t\t\"include \\\"sym*\\\" in --sort to use it.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!browser->selection ||\n\t\t\t    !browser->selection->map ||\n\t\t\t    !map__dso(browser->selection->map) ||\n\t\t\t    map__dso(browser->selection->map)->annotate_warned) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!browser->selection->sym) {\n\t\t\t\tif (!browser->he_selection)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\t\t\t\tbi = browser->he_selection->branch_info;\n\t\t\t\t\tif (!bi || !bi->to.ms.map)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tactions->ms.sym = symbol__new_unresolved(bi->to.al_addr, bi->to.ms.map);\n\t\t\t\t\tactions->ms.map = bi->to.ms.map;\n\t\t\t\t} else {\n\t\t\t\t\tactions->ms.sym = symbol__new_unresolved(browser->he_selection->ip,\n\t\t\t\t\t\t\t\t\t\t browser->selection->map);\n\t\t\t\t\tactions->ms.map = browser->selection->map;\n\t\t\t\t}\n\n\t\t\t\tif (!actions->ms.sym)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (symbol__annotation(browser->selection->sym)->src == NULL) {\n\t\t\t\t\tui_browser__warning(&browser->b, delay_secs * 2,\n\t\t\t\t\t\t\"No samples for the \\\"%s\\\" symbol.\\n\\n\"\n\t\t\t\t\t\t\"Probably appeared just in a callchain\",\n\t\t\t\t\t\tbrowser->selection->sym->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tactions->ms.map = browser->selection->map;\n\t\t\t\tactions->ms.sym = browser->selection->sym;\n\t\t\t}\n\n\t\t\tdo_annotate(browser, actions);\n\t\t\tcontinue;\n\t\tcase 'P':\n\t\t\thist_browser__dump(browser);\n\t\t\tcontinue;\n\t\tcase 'd':\n\t\t\tactions->ms.map = map;\n\t\t\tdo_zoom_dso(browser, actions);\n\t\t\tcontinue;\n\t\tcase 'k':\n\t\t\tif (browser->selection != NULL)\n\t\t\t\thists_browser__zoom_map(browser,\n\t\t\t\t\t      maps__machine(browser->selection->maps)->vmlinux_map);\n\t\t\tcontinue;\n\t\tcase 'V':\n\t\t\tverbose = (verbose + 1) % 4;\n\t\t\tbrowser->show_dso = verbose > 0;\n\t\t\tui_helpline__fpush(\"Verbosity level set to %d\\n\",\n\t\t\t\t\t   verbose);\n\t\t\tcontinue;\n\t\tcase 't':\n\t\t\tactions->thread = thread;\n\t\t\tdo_zoom_thread(browser, actions);\n\t\t\tcontinue;\n\t\tcase 'S':\n\t\t\tactions->socket = socked_id;\n\t\t\tdo_zoom_socket(browser, actions);\n\t\t\tcontinue;\n\t\tcase '/':\n\t\t\tif (ui_browser__input_window(\"Symbol to show\",\n\t\t\t\t\t\"Please enter the name of symbol you want to see.\\n\"\n\t\t\t\t\t\"To remove the filter later, press / + ENTER.\",\n\t\t\t\t\tbuf, \"ENTER: OK, ESC: Cancel\",\n\t\t\t\t\tdelay_secs * 2) == K_ENTER) {\n\t\t\t\thists->symbol_filter_str = *buf ? buf : NULL;\n\t\t\t\thists__filter_by_symbol(hists);\n\t\t\t\thist_browser__reset(browser);\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'r':\n\t\t\tif (is_report_browser(hbt)) {\n\t\t\t\tactions->thread = NULL;\n\t\t\t\tactions->ms.sym = NULL;\n\t\t\t\tdo_run_script(browser, actions);\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 's':\n\t\t\tif (is_report_browser(hbt)) {\n\t\t\t\tkey = do_switch_data(browser, actions);\n\t\t\t\tif (key == K_SWITCH_INPUT_DATA)\n\t\t\t\t\tgoto out_free_stack;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'i':\n\t\t\t \n\t\t\tif (env->arch)\n\t\t\t\ttui__header_window(env);\n\t\t\tcontinue;\n\t\tcase 'F':\n\t\t\tsymbol_conf.filter_relative ^= 1;\n\t\t\tcontinue;\n\t\tcase 'z':\n\t\t\tif (!is_report_browser(hbt)) {\n\t\t\t\tstruct perf_top *top = hbt->arg;\n\n\t\t\t\ttop->zero = !top->zero;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'L':\n\t\t\tif (ui_browser__input_window(\"Percent Limit\",\n\t\t\t\t\t\"Please enter the value you want to hide entries under that percent.\",\n\t\t\t\t\tbuf, \"ENTER: OK, ESC: Cancel\",\n\t\t\t\t\tdelay_secs * 2) == K_ENTER) {\n\t\t\t\tchar *end;\n\t\t\t\tdouble new_percent = strtod(buf, &end);\n\n\t\t\t\tif (new_percent < 0 || new_percent > 100) {\n\t\t\t\t\tui_browser__warning(&browser->b, delay_secs * 2,\n\t\t\t\t\t\t\"Invalid percent: %.2f\", new_percent);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\thist_browser__update_percent_limit(browser, new_percent);\n\t\t\t\thist_browser__reset(browser);\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase K_F1:\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tui_browser__help_window(&browser->b,\n\t\t\t\tis_report_browser(hbt) ? report_help : top_help);\n\t\t\tcontinue;\n\t\tcase K_ENTER:\n\t\tcase K_RIGHT:\n\t\tcase 'm':\n\t\t\t \n\t\t\tbreak;\n\t\tcase K_ESC:\n\t\tcase K_LEFT: {\n\t\t\tconst void *top;\n\n\t\t\tif (pstack__empty(browser->pstack)) {\n\t\t\t\t \n\t\t\t\tif (left_exits)\n\t\t\t\t\tgoto out_free_stack;\n\n\t\t\t\tif (key == K_ESC &&\n\t\t\t\t    ui_browser__dialog_yesno(&browser->b,\n\t\t\t\t\t\t\t     \"Do you really want to exit?\"))\n\t\t\t\t\tgoto out_free_stack;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tactions->ms.map = map;\n\t\t\ttop = pstack__peek(browser->pstack);\n\t\t\tif (top == &browser->hists->dso_filter) {\n\t\t\t\t \n\t\t\t\tdo_zoom_dso(browser, actions);\n\t\t\t} else if (top == &browser->hists->thread_filter) {\n\t\t\t\tdo_zoom_thread(browser, actions);\n\t\t\t} else if (top == &browser->hists->socket_filter) {\n\t\t\t\tdo_zoom_socket(browser, actions);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tcase 'q':\n\t\tcase CTRL('c'):\n\t\t\tgoto out_free_stack;\n\t\tcase 'f':\n\t\t\tif (!is_report_browser(hbt)) {\n\t\t\t\tstruct perf_top *top = hbt->arg;\n\n\t\t\t\tevlist__toggle_enable(top->evlist);\n\t\t\t\t \n\t\t\t\tif (top->evlist->enabled) {\n\t\t\t\t\thelpline = \"Press 'f' to disable the events or 'h' to see other hotkeys\";\n\t\t\t\t\thbt->refresh = delay_secs;\n\t\t\t\t} else {\n\t\t\t\t\thelpline = \"Press 'f' again to re-enable the events\";\n\t\t\t\t\thbt->refresh = 0;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\tdefault:\n\t\t\thelpline = \"Press '?' for help on key bindings\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!hists__has(hists, sym) || browser->selection == NULL)\n\t\t\tgoto skip_annotation;\n\n\t\tif (sort__mode == SORT_MODE__BRANCH) {\n\n\t\t\tif (browser->he_selection)\n\t\t\t\tbi = browser->he_selection->branch_info;\n\n\t\t\tif (bi == NULL)\n\t\t\t\tgoto skip_annotation;\n\n\t\t\tnr_options += add_annotate_opt(browser,\n\t\t\t\t\t\t       &actions[nr_options],\n\t\t\t\t\t\t       &options[nr_options],\n\t\t\t\t\t\t       &bi->from.ms,\n\t\t\t\t\t\t       bi->from.al_addr);\n\t\t\tif (bi->to.ms.sym != bi->from.ms.sym)\n\t\t\t\tnr_options += add_annotate_opt(browser,\n\t\t\t\t\t\t\t&actions[nr_options],\n\t\t\t\t\t\t\t&options[nr_options],\n\t\t\t\t\t\t\t&bi->to.ms,\n\t\t\t\t\t\t\tbi->to.al_addr);\n\t\t} else {\n\t\t\tnr_options += add_annotate_opt(browser,\n\t\t\t\t\t\t       &actions[nr_options],\n\t\t\t\t\t\t       &options[nr_options],\n\t\t\t\t\t\t       browser->selection,\n\t\t\t\t\t\t       browser->he_selection->ip);\n\t\t}\nskip_annotation:\n\t\tnr_options += add_thread_opt(browser, &actions[nr_options],\n\t\t\t\t\t     &options[nr_options], thread);\n\t\tnr_options += add_dso_opt(browser, &actions[nr_options],\n\t\t\t\t\t  &options[nr_options], map);\n\t\tnr_options += add_callchain_toggle_opt(browser, &actions[nr_options], &options[nr_options]);\n\t\tnr_options += add_map_opt(browser, &actions[nr_options],\n\t\t\t\t\t  &options[nr_options],\n\t\t\t\t\t  browser->selection ?\n\t\t\t\t\t\tbrowser->selection->map : NULL);\n\t\tnr_options += add_socket_opt(browser, &actions[nr_options],\n\t\t\t\t\t     &options[nr_options],\n\t\t\t\t\t     socked_id);\n\t\t \n\t\tif (!is_report_browser(hbt))\n\t\t\tgoto skip_scripting;\n\n\t\tif (browser->he_selection) {\n\t\t\tif (hists__has(hists, thread) && thread) {\n\t\t\t\tnr_options += add_script_opt(browser,\n\t\t\t\t\t\t\t     &actions[nr_options],\n\t\t\t\t\t\t\t     &options[nr_options],\n\t\t\t\t\t\t\t     thread, NULL, evsel);\n\t\t\t}\n\t\t\t \n\t\t\tif (hists__has(hists, sym) && browser->selection->sym) {\n\t\t\t\tnr_options += add_script_opt(browser,\n\t\t\t\t\t\t\t     &actions[nr_options],\n\t\t\t\t\t\t\t     &options[nr_options],\n\t\t\t\t\t\t\t     NULL, browser->selection->sym,\n\t\t\t\t\t\t\t     evsel);\n\t\t\t}\n\t\t}\n\t\tnr_options += add_script_opt(browser, &actions[nr_options],\n\t\t\t\t\t     &options[nr_options], NULL, NULL, evsel);\n\t\tnr_options += add_res_sample_opt(browser, &actions[nr_options],\n\t\t\t\t\t\t &options[nr_options],\n\t\t\t\t\t\t hist_browser__selected_res_sample(browser),\n\t\t\t\t\t\t evsel, A_NORMAL);\n\t\tnr_options += add_res_sample_opt(browser, &actions[nr_options],\n\t\t\t\t\t\t &options[nr_options],\n\t\t\t\t\t\t hist_browser__selected_res_sample(browser),\n\t\t\t\t\t\t evsel, A_ASM);\n\t\tnr_options += add_res_sample_opt(browser, &actions[nr_options],\n\t\t\t\t\t\t &options[nr_options],\n\t\t\t\t\t\t hist_browser__selected_res_sample(browser),\n\t\t\t\t\t\t evsel, A_SOURCE);\n\t\tnr_options += add_switch_opt(browser, &actions[nr_options],\n\t\t\t\t\t     &options[nr_options]);\nskip_scripting:\n\t\tnr_options += add_exit_opt(browser, &actions[nr_options],\n\t\t\t\t\t   &options[nr_options]);\n\n\t\tdo {\n\t\t\tstruct popup_action *act;\n\n\t\t\tchoice = ui__popup_menu(nr_options, options, &key);\n\t\t\tif (choice == -1)\n\t\t\t\tbreak;\n\n\t\t\tif (choice == nr_options)\n\t\t\t\tgoto do_hotkey;\n\n\t\t\tact = &actions[choice];\n\t\t\tkey = act->fn(browser, act);\n\t\t} while (key == 1);\n\n\t\tif (key == K_SWITCH_INPUT_DATA)\n\t\t\tbreak;\n\t}\nout_free_stack:\n\tpstack__delete(browser->pstack);\nout:\n\thist_browser__delete(browser);\n\tfree_popup_options(options, MAX_OPTIONS);\n\treturn key;\n}\n\nstruct evsel_menu {\n\tstruct ui_browser b;\n\tstruct evsel *selection;\n\tstruct annotation_options *annotation_opts;\n\tbool lost_events, lost_events_warned;\n\tfloat min_pcnt;\n\tstruct perf_env *env;\n};\n\nstatic void perf_evsel_menu__write(struct ui_browser *browser,\n\t\t\t\t   void *entry, int row)\n{\n\tstruct evsel_menu *menu = container_of(browser,\n\t\t\t\t\t\t    struct evsel_menu, b);\n\tstruct evsel *evsel = list_entry(entry, struct evsel, core.node);\n\tstruct hists *hists = evsel__hists(evsel);\n\tbool current_entry = ui_browser__is_current_entry(browser, row);\n\tunsigned long nr_events = hists->stats.nr_samples;\n\tconst char *ev_name = evsel__name(evsel);\n\tchar bf[256], unit;\n\tconst char *warn = \" \";\n\tsize_t printed;\n\n\tui_browser__set_color(browser, current_entry ? HE_COLORSET_SELECTED :\n\t\t\t\t\t\t       HE_COLORSET_NORMAL);\n\n\tif (evsel__is_group_event(evsel)) {\n\t\tstruct evsel *pos;\n\n\t\tev_name = evsel__group_name(evsel);\n\n\t\tfor_each_group_member(pos, evsel) {\n\t\t\tstruct hists *pos_hists = evsel__hists(pos);\n\t\t\tnr_events += pos_hists->stats.nr_samples;\n\t\t}\n\t}\n\n\tnr_events = convert_unit(nr_events, &unit);\n\tprinted = scnprintf(bf, sizeof(bf), \"%lu%c%s%s\", nr_events,\n\t\t\t   unit, unit == ' ' ? \"\" : \" \", ev_name);\n\tui_browser__printf(browser, \"%s\", bf);\n\n\tnr_events = evsel->evlist->stats.nr_events[PERF_RECORD_LOST];\n\tif (nr_events != 0) {\n\t\tmenu->lost_events = true;\n\t\tif (!current_entry)\n\t\t\tui_browser__set_color(browser, HE_COLORSET_TOP);\n\t\tnr_events = convert_unit(nr_events, &unit);\n\t\tprinted += scnprintf(bf, sizeof(bf), \": %ld%c%schunks LOST!\",\n\t\t\t\t     nr_events, unit, unit == ' ' ? \"\" : \" \");\n\t\twarn = bf;\n\t}\n\n\tui_browser__write_nstring(browser, warn, browser->width - printed);\n\n\tif (current_entry)\n\t\tmenu->selection = evsel;\n}\n\nstatic int perf_evsel_menu__run(struct evsel_menu *menu,\n\t\t\t\tint nr_events, const char *help,\n\t\t\t\tstruct hist_browser_timer *hbt,\n\t\t\t\tbool warn_lost_event)\n{\n\tstruct evlist *evlist = menu->b.priv;\n\tstruct evsel *pos;\n\tconst char *title = \"Available samples\";\n\tint delay_secs = hbt ? hbt->refresh : 0;\n\tint key;\n\n\tif (ui_browser__show(&menu->b, title,\n\t\t\t     \"ESC: exit, ENTER|->: Browse histograms\") < 0)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tkey = ui_browser__run(&menu->b, delay_secs);\n\n\t\tswitch (key) {\n\t\tcase K_TIMER:\n\t\t\tif (hbt)\n\t\t\t\thbt->timer(hbt->arg);\n\n\t\t\tif (!menu->lost_events_warned &&\n\t\t\t    menu->lost_events &&\n\t\t\t    warn_lost_event) {\n\t\t\t\tui_browser__warn_lost_events(&menu->b);\n\t\t\t\tmenu->lost_events_warned = true;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase K_RIGHT:\n\t\tcase K_ENTER:\n\t\t\tif (!menu->selection)\n\t\t\t\tcontinue;\n\t\t\tpos = menu->selection;\nbrowse_hists:\n\t\t\tevlist__set_selected(evlist, pos);\n\t\t\t \n\t\t\tif (hbt)\n\t\t\t\thbt->timer(hbt->arg);\n\t\t\tkey = evsel__hists_browse(pos, nr_events, help, true, hbt,\n\t\t\t\t\t\t  menu->min_pcnt, menu->env,\n\t\t\t\t\t\t  warn_lost_event,\n\t\t\t\t\t\t  menu->annotation_opts);\n\t\t\tui_browser__show_title(&menu->b, title);\n\t\t\tswitch (key) {\n\t\t\tcase K_TAB:\n\t\t\t\tif (pos->core.node.next == &evlist->core.entries)\n\t\t\t\t\tpos = evlist__first(evlist);\n\t\t\t\telse\n\t\t\t\t\tpos = evsel__next(pos);\n\t\t\t\tgoto browse_hists;\n\t\t\tcase K_UNTAB:\n\t\t\t\tif (pos->core.node.prev == &evlist->core.entries)\n\t\t\t\t\tpos = evlist__last(evlist);\n\t\t\t\telse\n\t\t\t\t\tpos = evsel__prev(pos);\n\t\t\t\tgoto browse_hists;\n\t\t\tcase K_SWITCH_INPUT_DATA:\n\t\t\tcase K_RELOAD:\n\t\t\tcase 'q':\n\t\t\tcase CTRL('c'):\n\t\t\t\tgoto out;\n\t\t\tcase K_ESC:\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tcase K_LEFT:\n\t\t\tcontinue;\n\t\tcase K_ESC:\n\t\t\tif (!ui_browser__dialog_yesno(&menu->b,\n\t\t\t\t\t       \"Do you really want to exit?\"))\n\t\t\t\tcontinue;\n\t\t\t \n\t\tcase 'q':\n\t\tcase CTRL('c'):\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\nout:\n\tui_browser__hide(&menu->b);\n\treturn key;\n}\n\nstatic bool filter_group_entries(struct ui_browser *browser __maybe_unused,\n\t\t\t\t void *entry)\n{\n\tstruct evsel *evsel = list_entry(entry, struct evsel, core.node);\n\n\tif (symbol_conf.event_group && !evsel__is_group_leader(evsel))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int __evlist__tui_browse_hists(struct evlist *evlist, int nr_entries, const char *help,\n\t\t\t\t      struct hist_browser_timer *hbt, float min_pcnt, struct perf_env *env,\n\t\t\t\t      bool warn_lost_event, struct annotation_options *annotation_opts)\n{\n\tstruct evsel *pos;\n\tstruct evsel_menu menu = {\n\t\t.b = {\n\t\t\t.entries    = &evlist->core.entries,\n\t\t\t.refresh    = ui_browser__list_head_refresh,\n\t\t\t.seek\t    = ui_browser__list_head_seek,\n\t\t\t.write\t    = perf_evsel_menu__write,\n\t\t\t.filter\t    = filter_group_entries,\n\t\t\t.nr_entries = nr_entries,\n\t\t\t.priv\t    = evlist,\n\t\t},\n\t\t.min_pcnt = min_pcnt,\n\t\t.env = env,\n\t\t.annotation_opts = annotation_opts,\n\t};\n\n\tui_helpline__push(\"Press ESC to exit\");\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tconst char *ev_name = evsel__name(pos);\n\t\tsize_t line_len = strlen(ev_name) + 7;\n\n\t\tif (menu.b.width < line_len)\n\t\t\tmenu.b.width = line_len;\n\t}\n\n\treturn perf_evsel_menu__run(&menu, nr_entries, help,\n\t\t\t\t    hbt, warn_lost_event);\n}\n\nstatic bool evlist__single_entry(struct evlist *evlist)\n{\n\tint nr_entries = evlist->core.nr_entries;\n\n\tif (nr_entries == 1)\n\t       return true;\n\n\tif (nr_entries == 2) {\n\t\tstruct evsel *last = evlist__last(evlist);\n\n\t\tif (evsel__is_dummy_event(last))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint evlist__tui_browse_hists(struct evlist *evlist, const char *help, struct hist_browser_timer *hbt,\n\t\t\t     float min_pcnt, struct perf_env *env, bool warn_lost_event,\n\t\t\t     struct annotation_options *annotation_opts)\n{\n\tint nr_entries = evlist->core.nr_entries;\n\n\tif (evlist__single_entry(evlist)) {\nsingle_entry: {\n\t\tstruct evsel *first = evlist__first(evlist);\n\n\t\treturn evsel__hists_browse(first, nr_entries, help, false, hbt, min_pcnt,\n\t\t\t\t\t   env, warn_lost_event, annotation_opts);\n\t}\n\t}\n\n\tif (symbol_conf.event_group) {\n\t\tstruct evsel *pos;\n\n\t\tnr_entries = 0;\n\t\tevlist__for_each_entry(evlist, pos) {\n\t\t\tif (evsel__is_group_leader(pos))\n\t\t\t\tnr_entries++;\n\t\t}\n\n\t\tif (nr_entries == 1)\n\t\t\tgoto single_entry;\n\t}\n\n\treturn __evlist__tui_browse_hists(evlist, nr_entries, help, hbt, min_pcnt, env,\n\t\t\t\t\t  warn_lost_event, annotation_opts);\n}\n\nstatic int block_hists_browser__title(struct hist_browser *browser, char *bf,\n\t\t\t\t      size_t size)\n{\n\tstruct hists *hists = evsel__hists(browser->block_evsel);\n\tconst char *evname = evsel__name(browser->block_evsel);\n\tunsigned long nr_samples = hists->stats.nr_samples;\n\tint ret;\n\n\tret = scnprintf(bf, size, \"# Samples: %lu\", nr_samples);\n\tif (evname)\n\t\tscnprintf(bf + ret, size -  ret, \" of event '%s'\", evname);\n\n\treturn 0;\n}\n\nint block_hists_tui_browse(struct block_hist *bh, struct evsel *evsel,\n\t\t\t   float min_percent, struct perf_env *env,\n\t\t\t   struct annotation_options *annotation_opts)\n{\n\tstruct hists *hists = &bh->block_hists;\n\tstruct hist_browser *browser;\n\tint key = -1;\n\tstruct popup_action action;\n\tstatic const char help[] =\n\t\" q             Quit \\n\";\n\n\tbrowser = hist_browser__new(hists);\n\tif (!browser)\n\t\treturn -1;\n\n\tbrowser->block_evsel = evsel;\n\tbrowser->title = block_hists_browser__title;\n\tbrowser->min_pcnt = min_percent;\n\tbrowser->env = env;\n\tbrowser->annotation_opts = annotation_opts;\n\n\t \n\tSLang_reset_tty();\n\tSLang_init_tty(0, 0, 0);\n\n\tmemset(&action, 0, sizeof(action));\n\n\twhile (1) {\n\t\tkey = hist_browser__run(browser, \"? - help\", true, 0);\n\n\t\tswitch (key) {\n\t\tcase 'q':\n\t\t\tgoto out;\n\t\tcase '?':\n\t\t\tui_browser__help_window(&browser->b, help);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase K_ENTER:\n\t\t\tif (!browser->selection ||\n\t\t\t    !browser->selection->sym) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taction.ms.map = browser->selection->map;\n\t\t\taction.ms.sym = browser->selection->sym;\n\t\t\tdo_annotate(browser, &action);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\thist_browser__delete(browser);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}