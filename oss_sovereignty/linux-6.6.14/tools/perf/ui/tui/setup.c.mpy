{
  "module_name": "setup.c",
  "hash_id": "8a08d91aaeda701b385c56663a690402faab05f5da2ce9fa1421cb9482d90561",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/ui/tui/setup.c",
  "human_readable_source": "#include <errno.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <linux/kernel.h>\n#ifdef HAVE_BACKTRACE_SUPPORT\n#include <execinfo.h>\n#endif\n\n#include \"../../util/debug.h\"\n#include \"../browser.h\"\n#include \"../helpline.h\"\n#include \"../ui.h\"\n#include \"../util.h\"\n#include \"../libslang.h\"\n#include \"../keysyms.h\"\n#include \"tui.h\"\n\nstatic volatile int ui__need_resize;\n\nextern struct perf_error_ops perf_tui_eops;\nextern bool tui_helpline__set;\n\nextern void hist_browser__init_hpp(void);\n\nvoid ui__refresh_dimensions(bool force)\n{\n\tif (force || ui__need_resize) {\n\t\tui__need_resize = 0;\n\t\tmutex_lock(&ui__lock);\n\t\tSLtt_get_screen_size();\n\t\tSLsmg_reinit_smg();\n\t\tmutex_unlock(&ui__lock);\n\t}\n}\n\nstatic void ui__sigwinch(int sig __maybe_unused)\n{\n\tui__need_resize = 1;\n}\n\nstatic void ui__setup_sigwinch(void)\n{\n\tstatic bool done;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\tpthread__unblock_sigwinch();\n\tsignal(SIGWINCH, ui__sigwinch);\n}\n\nint ui__getch(int delay_secs)\n{\n\tstruct timeval timeout, *ptimeout = delay_secs ? &timeout : NULL;\n\tfd_set read_set;\n\tint err, key;\n\n\tui__setup_sigwinch();\n\n\tFD_ZERO(&read_set);\n\tFD_SET(0, &read_set);\n\n\tif (delay_secs) {\n\t\ttimeout.tv_sec = delay_secs;\n\t\ttimeout.tv_usec = 0;\n\t}\n\n        err = select(1, &read_set, NULL, NULL, ptimeout);\n\n\tif (err == 0)\n\t\treturn K_TIMER;\n\n\tif (err == -1) {\n\t\tif (errno == EINTR)\n\t\t\treturn K_RESIZE;\n\t\treturn K_ERROR;\n\t}\n\n\tkey = SLang_getkey();\n\tif (key != K_ESC)\n\t\treturn key;\n\n\tFD_ZERO(&read_set);\n\tFD_SET(0, &read_set);\n\ttimeout.tv_sec = 0;\n\ttimeout.tv_usec = 20;\n        err = select(1, &read_set, NULL, NULL, &timeout);\n\tif (err == 0)\n\t\treturn K_ESC;\n\n\tSLang_ungetkey(key);\n\treturn SLkp_getkey();\n}\n\n#ifdef HAVE_BACKTRACE_SUPPORT\nstatic void ui__signal_backtrace(int sig)\n{\n\tvoid *stackdump[32];\n\tsize_t size;\n\n\tui__exit(false);\n\tpsignal(sig, \"perf\");\n\n\tprintf(\"-------- backtrace --------\\n\");\n\tsize = backtrace(stackdump, ARRAY_SIZE(stackdump));\n\tbacktrace_symbols_fd(stackdump, size, STDOUT_FILENO);\n\n\texit(0);\n}\n#else\n# define ui__signal_backtrace  ui__signal\n#endif\n\nstatic void ui__signal(int sig)\n{\n\tui__exit(false);\n\tpsignal(sig, \"perf\");\n\texit(0);\n}\n\nint ui__init(void)\n{\n\tint err;\n\n\tSLutf8_enable(-1);\n\tSLtt_get_terminfo();\n\tSLtt_get_screen_size();\n\n\terr = SLsmg_init_smg();\n\tif (err < 0)\n\t\tgoto out;\n\terr = SLang_init_tty(-1, 0, 0);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = SLkp_init();\n\tif (err < 0) {\n\t\tpr_err(\"TUI initialization failed.\\n\");\n\t\tgoto out;\n\t}\n\n\tSLkp_define_keysym(\"^(kB)\", SL_KEY_UNTAB);\n\n\tsignal(SIGSEGV, ui__signal_backtrace);\n\tsignal(SIGFPE, ui__signal_backtrace);\n\tsignal(SIGINT, ui__signal);\n\tsignal(SIGQUIT, ui__signal);\n\tsignal(SIGTERM, ui__signal);\n\n\tperf_error__register(&perf_tui_eops);\n\n\tui_helpline__init();\n\tui_browser__init();\n\ttui_progress__init();\n\n\thist_browser__init_hpp();\nout:\n\treturn err;\n}\n\nvoid ui__exit(bool wait_for_ok)\n{\n\tif (wait_for_ok && tui_helpline__set)\n\t\tui__question_window(\"Fatal Error\",\n\t\t\t\t    ui_helpline__last_msg,\n\t\t\t\t    \"Press any key...\", 0);\n\n\tSLtt_set_cursor_visibility(1);\n\tif (mutex_trylock(&ui__lock)) {\n\t\tSLsmg_refresh();\n\t\tSLsmg_reset_smg();\n\t\tmutex_unlock(&ui__lock);\n\t}\n\tSLang_reset_tty();\n\tperf_error__unregister(&perf_tui_eops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}