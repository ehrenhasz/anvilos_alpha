{
  "module_name": "util.c",
  "hash_id": "80725022327e6242b7b67075cc8d7a58d78182b5fe27292f6e5791b0a1df45f5",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/ui/tui/util.c",
  "human_readable_source": "\n#include <signal.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/ttydefaults.h>\n\n#include \"../browser.h\"\n#include \"../keysyms.h\"\n#include \"../helpline.h\"\n#include \"../ui.h\"\n#include \"../util.h\"\n#include \"../libslang.h\"\n\nstatic void ui_browser__argv_write(struct ui_browser *browser,\n\t\t\t\t   void *entry, int row)\n{\n\tchar **arg = entry;\n\tbool current_entry = ui_browser__is_current_entry(browser, row);\n\n\tui_browser__set_color(browser, current_entry ? HE_COLORSET_SELECTED :\n\t\t\t\t\t\t       HE_COLORSET_NORMAL);\n\tui_browser__write_nstring(browser, *arg, browser->width);\n}\n\nstatic int popup_menu__run(struct ui_browser *menu, int *keyp)\n{\n\tint key;\n\n\tif (ui_browser__show(menu, \" \", \"ESC: exit, ENTER|->: Select option\") < 0)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tkey = ui_browser__run(menu, 0);\n\n\t\tswitch (key) {\n\t\tcase K_RIGHT:\n\t\tcase K_ENTER:\n\t\t\tkey = menu->index;\n\t\t\tbreak;\n\t\tcase K_LEFT:\n\t\tcase K_ESC:\n\t\tcase 'q':\n\t\tcase CTRL('c'):\n\t\t\tkey = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (keyp) {\n\t\t\t\t*keyp = key;\n\t\t\t\tkey = menu->nr_entries;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tui_browser__hide(menu);\n\treturn key;\n}\n\nint ui__popup_menu(int argc, char * const argv[], int *keyp)\n{\n\tstruct ui_browser menu = {\n\t\t.entries    = (void *)argv,\n\t\t.refresh    = ui_browser__argv_refresh,\n\t\t.seek\t    = ui_browser__argv_seek,\n\t\t.write\t    = ui_browser__argv_write,\n\t\t.nr_entries = argc,\n\t};\n\treturn popup_menu__run(&menu, keyp);\n}\n\nint ui_browser__input_window(const char *title, const char *text, char *input,\n\t\t\t     const char *exit_msg, int delay_secs)\n{\n\tint x, y, len, key;\n\tint max_len = 60, nr_lines = 0;\n\tstatic char buf[50];\n\tconst char *t;\n\n\tt = text;\n\twhile (1) {\n\t\tconst char *sep = strchr(t, '\\n');\n\n\t\tif (sep == NULL)\n\t\t\tsep = strchr(t, '\\0');\n\t\tlen = sep - t;\n\t\tif (max_len < len)\n\t\t\tmax_len = len;\n\t\t++nr_lines;\n\t\tif (*sep == '\\0')\n\t\t\tbreak;\n\t\tt = sep + 1;\n\t}\n\n\tmutex_lock(&ui__lock);\n\n\tmax_len += 2;\n\tnr_lines += 8;\n\ty = SLtt_Screen_Rows / 2 - nr_lines / 2;\n\tx = SLtt_Screen_Cols / 2 - max_len / 2;\n\n\tSLsmg_set_color(0);\n\tSLsmg_draw_box(y, x++, nr_lines, max_len);\n\tif (title) {\n\t\tSLsmg_gotorc(y, x + 1);\n\t\tSLsmg_write_string(title);\n\t}\n\tSLsmg_gotorc(++y, x);\n\tnr_lines -= 7;\n\tmax_len -= 2;\n\tSLsmg_write_wrapped_string((unsigned char *)text, y, x,\n\t\t\t\t   nr_lines, max_len, 1);\n\ty += nr_lines;\n\tlen = 5;\n\twhile (len--) {\n\t\tSLsmg_gotorc(y + len - 1, x);\n\t\tSLsmg_write_nstring(\" \", max_len);\n\t}\n\tSLsmg_draw_box(y++, x + 1, 3, max_len - 2);\n\n\tSLsmg_gotorc(y + 3, x);\n\tSLsmg_write_nstring(exit_msg, max_len);\n\tSLsmg_refresh();\n\n\tmutex_unlock(&ui__lock);\n\n\tx += 2;\n\tlen = 0;\n\tkey = ui__getch(delay_secs);\n\twhile (key != K_TIMER && key != K_ENTER && key != K_ESC) {\n\t\tmutex_lock(&ui__lock);\n\n\t\tif (key == K_BKSPC) {\n\t\t\tif (len == 0) {\n\t\t\t\tmutex_unlock(&ui__lock);\n\t\t\t\tgoto next_key;\n\t\t\t}\n\t\t\tSLsmg_gotorc(y, x + --len);\n\t\t\tSLsmg_write_char(' ');\n\t\t} else {\n\t\t\tbuf[len] = key;\n\t\t\tSLsmg_gotorc(y, x + len++);\n\t\t\tSLsmg_write_char(key);\n\t\t}\n\t\tSLsmg_refresh();\n\n\t\tmutex_unlock(&ui__lock);\n\n\t\t \n\t\tif (len == sizeof(buf) - 1) {\n\t\t\tui_helpline__push(\"maximum size of symbol name reached!\");\n\t\t\tkey = K_ENTER;\n\t\t\tbreak;\n\t\t}\nnext_key:\n\t\tkey = ui__getch(delay_secs);\n\t}\n\n\tbuf[len] = '\\0';\n\tstrncpy(input, buf, len+1);\n\treturn key;\n}\n\nvoid __ui__info_window(const char *title, const char *text, const char *exit_msg)\n{\n\tint x, y;\n\tint max_len = 0, nr_lines = 0;\n\tconst char *t;\n\n\tt = text;\n\twhile (1) {\n\t\tconst char *sep = strchr(t, '\\n');\n\t\tint len;\n\n\t\tif (sep == NULL)\n\t\t\tsep = strchr(t, '\\0');\n\t\tlen = sep - t;\n\t\tif (max_len < len)\n\t\t\tmax_len = len;\n\t\t++nr_lines;\n\t\tif (*sep == '\\0')\n\t\t\tbreak;\n\t\tt = sep + 1;\n\t}\n\n\tmax_len += 2;\n\tnr_lines += 2;\n\tif (exit_msg)\n\t\tnr_lines += 2;\n\ty = SLtt_Screen_Rows / 2 - nr_lines / 2,\n\tx = SLtt_Screen_Cols / 2 - max_len / 2;\n\n\tSLsmg_set_color(0);\n\tSLsmg_draw_box(y, x++, nr_lines, max_len);\n\tif (title) {\n\t\tSLsmg_gotorc(y, x + 1);\n\t\tSLsmg_write_string(title);\n\t}\n\tSLsmg_gotorc(++y, x);\n\tif (exit_msg)\n\t\tnr_lines -= 2;\n\tmax_len -= 2;\n\tSLsmg_write_wrapped_string((unsigned char *)text, y, x,\n\t\t\t\t   nr_lines, max_len, 1);\n\tif (exit_msg) {\n\t\tSLsmg_gotorc(y + nr_lines - 2, x);\n\t\tSLsmg_write_nstring(\" \", max_len);\n\t\tSLsmg_gotorc(y + nr_lines - 1, x);\n\t\tSLsmg_write_nstring(exit_msg, max_len);\n\t}\n}\n\nvoid ui__info_window(const char *title, const char *text)\n{\n\tmutex_lock(&ui__lock);\n\t__ui__info_window(title, text, NULL);\n\tSLsmg_refresh();\n\tmutex_unlock(&ui__lock);\n}\n\nint ui__question_window(const char *title, const char *text,\n\t\t\tconst char *exit_msg, int delay_secs)\n{\n\tmutex_lock(&ui__lock);\n\t__ui__info_window(title, text, exit_msg);\n\tSLsmg_refresh();\n\tmutex_unlock(&ui__lock);\n\treturn ui__getch(delay_secs);\n}\n\nint ui__help_window(const char *text)\n{\n\treturn ui__question_window(\"Help\", text, \"Press any key...\", 0);\n}\n\nint ui__dialog_yesno(const char *msg)\n{\n\treturn ui__question_window(NULL, msg, \"Enter: Yes, ESC: No\", 0);\n}\n\nstatic int __ui__warning(const char *title, const char *format, va_list args)\n{\n\tchar *s;\n\n\tif (vasprintf(&s, format, args) > 0) {\n\t\tint key;\n\n\t\tkey = ui__question_window(title, s, \"Press any key...\", 0);\n\t\tfree(s);\n\t\treturn key;\n\t}\n\n\tfprintf(stderr, \"%s\\n\", title);\n\tvfprintf(stderr, format, args);\n\treturn K_ESC;\n}\n\nstatic int perf_tui__error(const char *format, va_list args)\n{\n\treturn __ui__warning(\"Error:\", format, args);\n}\n\nstatic int perf_tui__warning(const char *format, va_list args)\n{\n\treturn __ui__warning(\"Warning:\", format, args);\n}\n\nstruct perf_error_ops perf_tui_eops = {\n\t.error\t\t= perf_tui__error,\n\t.warning\t= perf_tui__warning,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}