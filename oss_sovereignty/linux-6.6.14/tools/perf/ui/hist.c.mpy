{
  "module_name": "hist.c",
  "hash_id": "a842b21f73390c362d25b10c5308cbcf364d1717fa45d3804f6c27b6db0a8ae6",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/ui/hist.c",
  "human_readable_source": "\n#include <inttypes.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n#include <linux/compiler.h>\n\n#include \"../util/callchain.h\"\n#include \"../util/debug.h\"\n#include \"../util/hist.h\"\n#include \"../util/sort.h\"\n#include \"../util/evsel.h\"\n#include \"../util/evlist.h\"\n#include \"../util/thread.h\"\n#include \"../util/util.h\"\n\n \n\n#define hpp__call_print_fn(hpp, fn, fmt, ...)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tint __ret = fn(hpp, fmt, ##__VA_ARGS__);\t\t\\\n\tadvance_hpp(hpp, __ret);\t\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\\\n})\n\nstatic int __hpp__fmt(struct perf_hpp *hpp, struct hist_entry *he,\n\t\t      hpp_field_fn get_field, const char *fmt, int len,\n\t\t      hpp_snprint_fn print_fn, bool fmt_percent)\n{\n\tint ret;\n\tstruct hists *hists = he->hists;\n\tstruct evsel *evsel = hists_to_evsel(hists);\n\tchar *buf = hpp->buf;\n\tsize_t size = hpp->size;\n\n\tif (fmt_percent) {\n\t\tdouble percent = 0.0;\n\t\tu64 total = hists__total_period(hists);\n\n\t\tif (total)\n\t\t\tpercent = 100.0 * get_field(he) / total;\n\n\t\tret = hpp__call_print_fn(hpp, print_fn, fmt, len, percent);\n\t} else\n\t\tret = hpp__call_print_fn(hpp, print_fn, fmt, len, get_field(he));\n\n\tif (evsel__is_group_event(evsel)) {\n\t\tint prev_idx, idx_delta;\n\t\tstruct hist_entry *pair;\n\t\tint nr_members = evsel->core.nr_members;\n\n\t\tprev_idx = evsel__group_idx(evsel);\n\n\t\tlist_for_each_entry(pair, &he->pairs.head, pairs.node) {\n\t\t\tu64 period = get_field(pair);\n\t\t\tu64 total = hists__total_period(pair->hists);\n\n\t\t\tif (!total)\n\t\t\t\tcontinue;\n\n\t\t\tevsel = hists_to_evsel(pair->hists);\n\t\t\tidx_delta = evsel__group_idx(evsel) - prev_idx - 1;\n\n\t\t\twhile (idx_delta--) {\n\t\t\t\t \n\t\t\t\tif (fmt_percent) {\n\t\t\t\t\tret += hpp__call_print_fn(hpp, print_fn,\n\t\t\t\t\t\t\t\t  fmt, len, 0.0);\n\t\t\t\t} else {\n\t\t\t\t\tret += hpp__call_print_fn(hpp, print_fn,\n\t\t\t\t\t\t\t\t  fmt, len, 0ULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fmt_percent) {\n\t\t\t\tret += hpp__call_print_fn(hpp, print_fn, fmt, len,\n\t\t\t\t\t\t\t  100.0 * period / total);\n\t\t\t} else {\n\t\t\t\tret += hpp__call_print_fn(hpp, print_fn, fmt,\n\t\t\t\t\t\t\t  len, period);\n\t\t\t}\n\n\t\t\tprev_idx = evsel__group_idx(evsel);\n\t\t}\n\n\t\tidx_delta = nr_members - prev_idx - 1;\n\n\t\twhile (idx_delta--) {\n\t\t\t \n\t\t\tif (fmt_percent) {\n\t\t\t\tret += hpp__call_print_fn(hpp, print_fn,\n\t\t\t\t\t\t\t  fmt, len, 0.0);\n\t\t\t} else {\n\t\t\t\tret += hpp__call_print_fn(hpp, print_fn,\n\t\t\t\t\t\t\t  fmt, len, 0ULL);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\thpp->buf = buf;\n\thpp->size = size;\n\n\treturn ret;\n}\n\nint hpp__fmt(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t     struct hist_entry *he, hpp_field_fn get_field,\n\t     const char *fmtstr, hpp_snprint_fn print_fn, bool fmt_percent)\n{\n\tint len = fmt->user_len ?: fmt->len;\n\n\tif (symbol_conf.field_sep) {\n\t\treturn __hpp__fmt(hpp, he, get_field, fmtstr, 1,\n\t\t\t\t  print_fn, fmt_percent);\n\t}\n\n\tif (fmt_percent)\n\t\tlen -= 2;  \n\telse\n\t\tlen -= 1;\n\n\treturn  __hpp__fmt(hpp, he, get_field, fmtstr, len, print_fn, fmt_percent);\n}\n\nint hpp__fmt_acc(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t struct hist_entry *he, hpp_field_fn get_field,\n\t\t const char *fmtstr, hpp_snprint_fn print_fn, bool fmt_percent)\n{\n\tif (!symbol_conf.cumulate_callchain) {\n\t\tint len = fmt->user_len ?: fmt->len;\n\t\treturn snprintf(hpp->buf, hpp->size, \" %*s\", len - 1, \"N/A\");\n\t}\n\n\treturn hpp__fmt(fmt, hpp, he, get_field, fmtstr, print_fn, fmt_percent);\n}\n\nstatic int field_cmp(u64 field_a, u64 field_b)\n{\n\tif (field_a > field_b)\n\t\treturn 1;\n\tif (field_a < field_b)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int hist_entry__new_pair(struct hist_entry *a, struct hist_entry *b,\n\t\t\t\thpp_field_fn get_field, int nr_members,\n\t\t\t\tu64 **fields_a, u64 **fields_b)\n{\n\tu64 *fa = calloc(nr_members, sizeof(*fa)),\n\t    *fb = calloc(nr_members, sizeof(*fb));\n\tstruct hist_entry *pair;\n\n\tif (!fa || !fb)\n\t\tgoto out_free;\n\n\tlist_for_each_entry(pair, &a->pairs.head, pairs.node) {\n\t\tstruct evsel *evsel = hists_to_evsel(pair->hists);\n\t\tfa[evsel__group_idx(evsel)] = get_field(pair);\n\t}\n\n\tlist_for_each_entry(pair, &b->pairs.head, pairs.node) {\n\t\tstruct evsel *evsel = hists_to_evsel(pair->hists);\n\t\tfb[evsel__group_idx(evsel)] = get_field(pair);\n\t}\n\n\t*fields_a = fa;\n\t*fields_b = fb;\n\treturn 0;\nout_free:\n\tfree(fa);\n\tfree(fb);\n\t*fields_a = *fields_b = NULL;\n\treturn -1;\n}\n\nstatic int __hpp__group_sort_idx(struct hist_entry *a, struct hist_entry *b,\n\t\t\t\t hpp_field_fn get_field, int idx)\n{\n\tstruct evsel *evsel = hists_to_evsel(a->hists);\n\tu64 *fields_a, *fields_b;\n\tint cmp, nr_members, ret, i;\n\n\tcmp = field_cmp(get_field(a), get_field(b));\n\tif (!evsel__is_group_event(evsel))\n\t\treturn cmp;\n\n\tnr_members = evsel->core.nr_members;\n\tif (idx < 1 || idx >= nr_members)\n\t\treturn cmp;\n\n\tret = hist_entry__new_pair(a, b, get_field, nr_members, &fields_a, &fields_b);\n\tif (ret) {\n\t\tret = cmp;\n\t\tgoto out;\n\t}\n\n\tret = field_cmp(fields_a[idx], fields_b[idx]);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 1; i < nr_members; i++) {\n\t\tif (i != idx) {\n\t\t\tret = field_cmp(fields_a[i], fields_b[i]);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(fields_a);\n\tfree(fields_b);\n\n\treturn ret;\n}\n\nstatic int __hpp__sort(struct hist_entry *a, struct hist_entry *b,\n\t\t       hpp_field_fn get_field)\n{\n\ts64 ret;\n\tint i, nr_members;\n\tstruct evsel *evsel;\n\tu64 *fields_a, *fields_b;\n\n\tif (symbol_conf.group_sort_idx && symbol_conf.event_group) {\n\t\treturn __hpp__group_sort_idx(a, b, get_field,\n\t\t\t\t\t     symbol_conf.group_sort_idx);\n\t}\n\n\tret = field_cmp(get_field(a), get_field(b));\n\tif (ret || !symbol_conf.event_group)\n\t\treturn ret;\n\n\tevsel = hists_to_evsel(a->hists);\n\tif (!evsel__is_group_event(evsel))\n\t\treturn ret;\n\n\tnr_members = evsel->core.nr_members;\n\ti = hist_entry__new_pair(a, b, get_field, nr_members, &fields_a, &fields_b);\n\tif (i)\n\t\tgoto out;\n\n\tfor (i = 1; i < nr_members; i++) {\n\t\tret = field_cmp(fields_a[i], fields_b[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout:\n\tfree(fields_a);\n\tfree(fields_b);\n\n\treturn ret;\n}\n\nstatic int __hpp__sort_acc(struct hist_entry *a, struct hist_entry *b,\n\t\t\t   hpp_field_fn get_field)\n{\n\ts64 ret = 0;\n\n\tif (symbol_conf.cumulate_callchain) {\n\t\t \n\t\tret = field_cmp(get_field(a), get_field(b));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((a->thread == NULL ? NULL : RC_CHK_ACCESS(a->thread)) !=\n\t\t    (b->thread == NULL ? NULL : RC_CHK_ACCESS(b->thread)) ||\n\t\t    !hist_entry__has_callchains(a) || !symbol_conf.use_callchain)\n\t\t\treturn 0;\n\n\t\tret = b->callchain->max_depth - a->callchain->max_depth;\n\t\tif (callchain_param.order == ORDER_CALLER)\n\t\t\tret = -ret;\n\t}\n\treturn ret;\n}\n\nstatic int hpp__width_fn(struct perf_hpp_fmt *fmt,\n\t\t\t struct perf_hpp *hpp __maybe_unused,\n\t\t\t struct hists *hists)\n{\n\tint len = fmt->user_len ?: fmt->len;\n\tstruct evsel *evsel = hists_to_evsel(hists);\n\n\tif (symbol_conf.event_group)\n\t\tlen = max(len, evsel->core.nr_members * fmt->len);\n\n\tif (len < (int)strlen(fmt->name))\n\t\tlen = strlen(fmt->name);\n\n\treturn len;\n}\n\nstatic int hpp__header_fn(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t  struct hists *hists, int line __maybe_unused,\n\t\t\t  int *span __maybe_unused)\n{\n\tint len = hpp__width_fn(fmt, hpp, hists);\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", len, fmt->name);\n}\n\nint hpp_color_scnprintf(struct perf_hpp *hpp, const char *fmt, ...)\n{\n\tva_list args;\n\tssize_t ssize = hpp->size;\n\tdouble percent;\n\tint ret, len;\n\n\tva_start(args, fmt);\n\tlen = va_arg(args, int);\n\tpercent = va_arg(args, double);\n\tret = percent_color_len_snprintf(hpp->buf, hpp->size, fmt, len, percent);\n\tva_end(args);\n\n\treturn (ret >= ssize) ? (ssize - 1) : ret;\n}\n\nstatic int hpp_entry_scnprintf(struct perf_hpp *hpp, const char *fmt, ...)\n{\n\tva_list args;\n\tssize_t ssize = hpp->size;\n\tint ret;\n\n\tva_start(args, fmt);\n\tret = vsnprintf(hpp->buf, hpp->size, fmt, args);\n\tva_end(args);\n\n\treturn (ret >= ssize) ? (ssize - 1) : ret;\n}\n\n#define __HPP_COLOR_PERCENT_FN(_type, _field)\t\t\t\t\t\\\nstatic u64 he_get_##_field(struct hist_entry *he)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn he->stat._field;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nstatic int hpp__color_##_type(struct perf_hpp_fmt *fmt,\t\t\t\t\\\n\t\t\t      struct perf_hpp *hpp, struct hist_entry *he) \t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn hpp__fmt(fmt, hpp, he, he_get_##_field, \" %*.2f%%\",\t\t\\\n\t\t\thpp_color_scnprintf, true);\t\t\t\t\\\n}\n\n#define __HPP_ENTRY_PERCENT_FN(_type, _field)\t\t\t\t\t\\\nstatic int hpp__entry_##_type(struct perf_hpp_fmt *fmt,\t\t\t\t\\\n\t\t\t      struct perf_hpp *hpp, struct hist_entry *he) \t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn hpp__fmt(fmt, hpp, he, he_get_##_field, \" %*.2f%%\",\t\t\\\n\t\t\thpp_entry_scnprintf, true);\t\t\t\t\\\n}\n\n#define __HPP_SORT_FN(_type, _field)\t\t\t\t\t\t\\\nstatic int64_t hpp__sort_##_type(struct perf_hpp_fmt *fmt __maybe_unused, \t\\\n\t\t\t\t struct hist_entry *a, struct hist_entry *b) \t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn __hpp__sort(a, b, he_get_##_field);\t\t\t\t\\\n}\n\n#define __HPP_COLOR_ACC_PERCENT_FN(_type, _field)\t\t\t\t\\\nstatic u64 he_get_acc_##_field(struct hist_entry *he)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn he->stat_acc->_field;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nstatic int hpp__color_##_type(struct perf_hpp_fmt *fmt,\t\t\t\t\\\n\t\t\t      struct perf_hpp *hpp, struct hist_entry *he) \t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn hpp__fmt_acc(fmt, hpp, he, he_get_acc_##_field, \" %*.2f%%\", \t\\\n\t\t\t    hpp_color_scnprintf, true);\t\t\t\t\\\n}\n\n#define __HPP_ENTRY_ACC_PERCENT_FN(_type, _field)\t\t\t\t\\\nstatic int hpp__entry_##_type(struct perf_hpp_fmt *fmt,\t\t\t\t\\\n\t\t\t      struct perf_hpp *hpp, struct hist_entry *he) \t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn hpp__fmt_acc(fmt, hpp, he, he_get_acc_##_field, \" %*.2f%%\",\t\\\n\t\t\t    hpp_entry_scnprintf, true);\t\t\t\t\\\n}\n\n#define __HPP_SORT_ACC_FN(_type, _field)\t\t\t\t\t\\\nstatic int64_t hpp__sort_##_type(struct perf_hpp_fmt *fmt __maybe_unused, \t\\\n\t\t\t\t struct hist_entry *a, struct hist_entry *b) \t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn __hpp__sort_acc(a, b, he_get_acc_##_field);\t\t\t\\\n}\n\n#define __HPP_ENTRY_RAW_FN(_type, _field)\t\t\t\t\t\\\nstatic u64 he_get_raw_##_field(struct hist_entry *he)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn he->stat._field;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nstatic int hpp__entry_##_type(struct perf_hpp_fmt *fmt,\t\t\t\t\\\n\t\t\t      struct perf_hpp *hpp, struct hist_entry *he) \t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn hpp__fmt(fmt, hpp, he, he_get_raw_##_field, \" %*\"PRIu64, \t\\\n\t\t\thpp_entry_scnprintf, false);\t\t\t\t\\\n}\n\n#define __HPP_SORT_RAW_FN(_type, _field)\t\t\t\t\t\\\nstatic int64_t hpp__sort_##_type(struct perf_hpp_fmt *fmt __maybe_unused, \t\\\n\t\t\t\t struct hist_entry *a, struct hist_entry *b) \t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn __hpp__sort(a, b, he_get_raw_##_field);\t\t\t\t\\\n}\n\n\n#define HPP_PERCENT_FNS(_type, _field)\t\t\t\t\t\\\n__HPP_COLOR_PERCENT_FN(_type, _field)\t\t\t\t\t\\\n__HPP_ENTRY_PERCENT_FN(_type, _field)\t\t\t\t\t\\\n__HPP_SORT_FN(_type, _field)\n\n#define HPP_PERCENT_ACC_FNS(_type, _field)\t\t\t\t\\\n__HPP_COLOR_ACC_PERCENT_FN(_type, _field)\t\t\t\t\\\n__HPP_ENTRY_ACC_PERCENT_FN(_type, _field)\t\t\t\t\\\n__HPP_SORT_ACC_FN(_type, _field)\n\n#define HPP_RAW_FNS(_type, _field)\t\t\t\t\t\\\n__HPP_ENTRY_RAW_FN(_type, _field)\t\t\t\t\t\\\n__HPP_SORT_RAW_FN(_type, _field)\n\nHPP_PERCENT_FNS(overhead, period)\nHPP_PERCENT_FNS(overhead_sys, period_sys)\nHPP_PERCENT_FNS(overhead_us, period_us)\nHPP_PERCENT_FNS(overhead_guest_sys, period_guest_sys)\nHPP_PERCENT_FNS(overhead_guest_us, period_guest_us)\nHPP_PERCENT_ACC_FNS(overhead_acc, period)\n\nHPP_RAW_FNS(samples, nr_events)\nHPP_RAW_FNS(period, period)\n\nstatic int64_t hpp__nop_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t    struct hist_entry *a __maybe_unused,\n\t\t\t    struct hist_entry *b __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic bool perf_hpp__is_hpp_entry(struct perf_hpp_fmt *a)\n{\n\treturn a->header == hpp__header_fn;\n}\n\nstatic bool hpp__equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)\n{\n\tif (!perf_hpp__is_hpp_entry(a) || !perf_hpp__is_hpp_entry(b))\n\t\treturn false;\n\n\treturn a->idx == b->idx;\n}\n\n#define HPP__COLOR_PRINT_FNS(_name, _fn, _idx)\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name   = _name,\t\t\t\\\n\t\t.header\t= hpp__header_fn,\t\t\\\n\t\t.width\t= hpp__width_fn,\t\t\\\n\t\t.color\t= hpp__color_ ## _fn,\t\t\\\n\t\t.entry\t= hpp__entry_ ## _fn,\t\t\\\n\t\t.cmp\t= hpp__nop_cmp,\t\t\t\\\n\t\t.collapse = hpp__nop_cmp,\t\t\\\n\t\t.sort\t= hpp__sort_ ## _fn,\t\t\\\n\t\t.idx\t= PERF_HPP__ ## _idx,\t\t\\\n\t\t.equal\t= hpp__equal,\t\t\t\\\n\t}\n\n#define HPP__COLOR_ACC_PRINT_FNS(_name, _fn, _idx)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name   = _name,\t\t\t\\\n\t\t.header\t= hpp__header_fn,\t\t\\\n\t\t.width\t= hpp__width_fn,\t\t\\\n\t\t.color\t= hpp__color_ ## _fn,\t\t\\\n\t\t.entry\t= hpp__entry_ ## _fn,\t\t\\\n\t\t.cmp\t= hpp__nop_cmp,\t\t\t\\\n\t\t.collapse = hpp__nop_cmp,\t\t\\\n\t\t.sort\t= hpp__sort_ ## _fn,\t\t\\\n\t\t.idx\t= PERF_HPP__ ## _idx,\t\t\\\n\t\t.equal\t= hpp__equal,\t\t\t\\\n\t}\n\n#define HPP__PRINT_FNS(_name, _fn, _idx)\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name   = _name,\t\t\t\\\n\t\t.header\t= hpp__header_fn,\t\t\\\n\t\t.width\t= hpp__width_fn,\t\t\\\n\t\t.entry\t= hpp__entry_ ## _fn,\t\t\\\n\t\t.cmp\t= hpp__nop_cmp,\t\t\t\\\n\t\t.collapse = hpp__nop_cmp,\t\t\\\n\t\t.sort\t= hpp__sort_ ## _fn,\t\t\\\n\t\t.idx\t= PERF_HPP__ ## _idx,\t\t\\\n\t\t.equal\t= hpp__equal,\t\t\t\\\n\t}\n\nstruct perf_hpp_fmt perf_hpp__format[] = {\n\tHPP__COLOR_PRINT_FNS(\"Overhead\", overhead, OVERHEAD),\n\tHPP__COLOR_PRINT_FNS(\"sys\", overhead_sys, OVERHEAD_SYS),\n\tHPP__COLOR_PRINT_FNS(\"usr\", overhead_us, OVERHEAD_US),\n\tHPP__COLOR_PRINT_FNS(\"guest sys\", overhead_guest_sys, OVERHEAD_GUEST_SYS),\n\tHPP__COLOR_PRINT_FNS(\"guest usr\", overhead_guest_us, OVERHEAD_GUEST_US),\n\tHPP__COLOR_ACC_PRINT_FNS(\"Children\", overhead_acc, OVERHEAD_ACC),\n\tHPP__PRINT_FNS(\"Samples\", samples, SAMPLES),\n\tHPP__PRINT_FNS(\"Period\", period, PERIOD)\n};\n\nstruct perf_hpp_list perf_hpp_list = {\n\t.fields\t= LIST_HEAD_INIT(perf_hpp_list.fields),\n\t.sorts\t= LIST_HEAD_INIT(perf_hpp_list.sorts),\n\t.nr_header_lines = 1,\n};\n\n#undef HPP__COLOR_PRINT_FNS\n#undef HPP__COLOR_ACC_PRINT_FNS\n#undef HPP__PRINT_FNS\n\n#undef HPP_PERCENT_FNS\n#undef HPP_PERCENT_ACC_FNS\n#undef HPP_RAW_FNS\n\n#undef __HPP_HEADER_FN\n#undef __HPP_WIDTH_FN\n#undef __HPP_COLOR_PERCENT_FN\n#undef __HPP_ENTRY_PERCENT_FN\n#undef __HPP_COLOR_ACC_PERCENT_FN\n#undef __HPP_ENTRY_ACC_PERCENT_FN\n#undef __HPP_ENTRY_RAW_FN\n#undef __HPP_SORT_FN\n#undef __HPP_SORT_ACC_FN\n#undef __HPP_SORT_RAW_FN\n\nstatic void fmt_free(struct perf_hpp_fmt *fmt)\n{\n\t \n\tBUG_ON(!list_empty(&fmt->list));\n\tBUG_ON(!list_empty(&fmt->sort_list));\n\n\tif (fmt->free)\n\t\tfmt->free(fmt);\n}\n\nvoid perf_hpp__init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PERF_HPP__MAX_INDEX; i++) {\n\t\tstruct perf_hpp_fmt *fmt = &perf_hpp__format[i];\n\n\t\tINIT_LIST_HEAD(&fmt->list);\n\n\t\t \n\t\tif (fmt->sort_list.next == NULL)\n\t\t\tINIT_LIST_HEAD(&fmt->sort_list);\n\t}\n\n\t \n\tif (is_strict_order(field_order))\n\t\treturn;\n\n\tif (symbol_conf.cumulate_callchain) {\n\t\thpp_dimension__add_output(PERF_HPP__OVERHEAD_ACC);\n\t\tperf_hpp__format[PERF_HPP__OVERHEAD].name = \"Self\";\n\t}\n\n\thpp_dimension__add_output(PERF_HPP__OVERHEAD);\n\n\tif (symbol_conf.show_cpu_utilization) {\n\t\thpp_dimension__add_output(PERF_HPP__OVERHEAD_SYS);\n\t\thpp_dimension__add_output(PERF_HPP__OVERHEAD_US);\n\n\t\tif (perf_guest) {\n\t\t\thpp_dimension__add_output(PERF_HPP__OVERHEAD_GUEST_SYS);\n\t\t\thpp_dimension__add_output(PERF_HPP__OVERHEAD_GUEST_US);\n\t\t}\n\t}\n\n\tif (symbol_conf.show_nr_samples)\n\t\thpp_dimension__add_output(PERF_HPP__SAMPLES);\n\n\tif (symbol_conf.show_total_period)\n\t\thpp_dimension__add_output(PERF_HPP__PERIOD);\n}\n\nvoid perf_hpp_list__column_register(struct perf_hpp_list *list,\n\t\t\t\t    struct perf_hpp_fmt *format)\n{\n\tlist_add_tail(&format->list, &list->fields);\n}\n\nvoid perf_hpp_list__register_sort_field(struct perf_hpp_list *list,\n\t\t\t\t\tstruct perf_hpp_fmt *format)\n{\n\tlist_add_tail(&format->sort_list, &list->sorts);\n}\n\nvoid perf_hpp_list__prepend_sort_field(struct perf_hpp_list *list,\n\t\t\t\t       struct perf_hpp_fmt *format)\n{\n\tlist_add(&format->sort_list, &list->sorts);\n}\n\nstatic void perf_hpp__column_unregister(struct perf_hpp_fmt *format)\n{\n\tlist_del_init(&format->list);\n\tfmt_free(format);\n}\n\nvoid perf_hpp__cancel_cumulate(void)\n{\n\tstruct perf_hpp_fmt *fmt, *acc, *ovh, *tmp;\n\n\tif (is_strict_order(field_order))\n\t\treturn;\n\n\tovh = &perf_hpp__format[PERF_HPP__OVERHEAD];\n\tacc = &perf_hpp__format[PERF_HPP__OVERHEAD_ACC];\n\n\tperf_hpp_list__for_each_format_safe(&perf_hpp_list, fmt, tmp) {\n\t\tif (acc->equal(acc, fmt)) {\n\t\t\tperf_hpp__column_unregister(fmt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ovh->equal(ovh, fmt))\n\t\t\tfmt->name = \"Overhead\";\n\t}\n}\n\nstatic bool fmt_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)\n{\n\treturn a->equal && a->equal(a, b);\n}\n\nvoid perf_hpp__setup_output_field(struct perf_hpp_list *list)\n{\n\tstruct perf_hpp_fmt *fmt;\n\n\t \n\tperf_hpp_list__for_each_sort_list(list, fmt) {\n\t\tstruct perf_hpp_fmt *pos;\n\n\t\t \n\t\tif (!fmt->entry && !fmt->color)\n\t\t\tcontinue;\n\n\t\tperf_hpp_list__for_each_format(list, pos) {\n\t\t\tif (fmt_equal(fmt, pos))\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tperf_hpp__column_register(fmt);\nnext:\n\t\tcontinue;\n\t}\n}\n\nvoid perf_hpp__append_sort_keys(struct perf_hpp_list *list)\n{\n\tstruct perf_hpp_fmt *fmt;\n\n\t \n\tperf_hpp_list__for_each_format(list, fmt) {\n\t\tstruct perf_hpp_fmt *pos;\n\n\t\tperf_hpp_list__for_each_sort_list(list, pos) {\n\t\t\tif (fmt_equal(fmt, pos))\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tperf_hpp__register_sort_field(fmt);\nnext:\n\t\tcontinue;\n\t}\n}\n\n\nvoid perf_hpp__reset_output_field(struct perf_hpp_list *list)\n{\n\tstruct perf_hpp_fmt *fmt, *tmp;\n\n\t \n\tperf_hpp_list__for_each_format_safe(list, fmt, tmp) {\n\t\tlist_del_init(&fmt->list);\n\t\tlist_del_init(&fmt->sort_list);\n\t\tfmt_free(fmt);\n\t}\n\n\t \n\tperf_hpp_list__for_each_sort_list_safe(list, fmt, tmp) {\n\t\tlist_del_init(&fmt->list);\n\t\tlist_del_init(&fmt->sort_list);\n\t\tfmt_free(fmt);\n\t}\n}\n\n \nunsigned int hists__sort_list_width(struct hists *hists)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tint ret = 0;\n\tbool first = true;\n\tstruct perf_hpp dummy_hpp;\n\n\thists__for_each_format(hists, fmt) {\n\t\tif (perf_hpp__should_skip(fmt, hists))\n\t\t\tcontinue;\n\n\t\tif (first)\n\t\t\tfirst = false;\n\t\telse\n\t\t\tret += 2;\n\n\t\tret += fmt->width(fmt, &dummy_hpp, hists);\n\t}\n\n\tif (verbose > 0 && hists__has(hists, sym))  \n\t\tret += 3 + BITS_PER_LONG / 4;\n\n\treturn ret;\n}\n\nunsigned int hists__overhead_width(struct hists *hists)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tint ret = 0;\n\tbool first = true;\n\tstruct perf_hpp dummy_hpp;\n\n\thists__for_each_format(hists, fmt) {\n\t\tif (perf_hpp__is_sort_entry(fmt) || perf_hpp__is_dynamic_entry(fmt))\n\t\t\tbreak;\n\n\t\tif (first)\n\t\t\tfirst = false;\n\t\telse\n\t\t\tret += 2;\n\n\t\tret += fmt->width(fmt, &dummy_hpp, hists);\n\t}\n\n\treturn ret;\n}\n\nvoid perf_hpp__reset_width(struct perf_hpp_fmt *fmt, struct hists *hists)\n{\n\tif (perf_hpp__is_sort_entry(fmt))\n\t\treturn perf_hpp__reset_sort_width(fmt, hists);\n\n\tif (perf_hpp__is_dynamic_entry(fmt))\n\t\treturn;\n\n\tBUG_ON(fmt->idx >= PERF_HPP__MAX_INDEX);\n\n\tswitch (fmt->idx) {\n\tcase PERF_HPP__OVERHEAD:\n\tcase PERF_HPP__OVERHEAD_SYS:\n\tcase PERF_HPP__OVERHEAD_US:\n\tcase PERF_HPP__OVERHEAD_ACC:\n\t\tfmt->len = 8;\n\t\tbreak;\n\n\tcase PERF_HPP__OVERHEAD_GUEST_SYS:\n\tcase PERF_HPP__OVERHEAD_GUEST_US:\n\t\tfmt->len = 9;\n\t\tbreak;\n\n\tcase PERF_HPP__SAMPLES:\n\tcase PERF_HPP__PERIOD:\n\t\tfmt->len = 12;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid hists__reset_column_width(struct hists *hists)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tstruct perf_hpp_list_node *node;\n\n\thists__for_each_format(hists, fmt)\n\t\tperf_hpp__reset_width(fmt, hists);\n\n\t \n\tlist_for_each_entry(node, &hists->hpp_formats, list) {\n\t\tperf_hpp_list__for_each_format(&node->hpp, fmt)\n\t\t\tperf_hpp__reset_width(fmt, hists);\n\t}\n}\n\nvoid perf_hpp__set_user_width(const char *width_list_str)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tconst char *ptr = width_list_str;\n\n\tperf_hpp_list__for_each_format(&perf_hpp_list, fmt) {\n\t\tchar *p;\n\n\t\tint len = strtol(ptr, &p, 10);\n\t\tfmt->user_len = len;\n\n\t\tif (*p == ',')\n\t\t\tptr = p + 1;\n\t\telse\n\t\t\tbreak;\n\t}\n}\n\nstatic int add_hierarchy_fmt(struct hists *hists, struct perf_hpp_fmt *fmt)\n{\n\tstruct perf_hpp_list_node *node = NULL;\n\tstruct perf_hpp_fmt *fmt_copy;\n\tbool found = false;\n\tbool skip = perf_hpp__should_skip(fmt, hists);\n\n\tlist_for_each_entry(node, &hists->hpp_formats, list) {\n\t\tif (node->level == fmt->level) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tnode = malloc(sizeof(*node));\n\t\tif (node == NULL)\n\t\t\treturn -1;\n\n\t\tnode->skip = skip;\n\t\tnode->level = fmt->level;\n\t\tperf_hpp_list__init(&node->hpp);\n\n\t\thists->nr_hpp_node++;\n\t\tlist_add_tail(&node->list, &hists->hpp_formats);\n\t}\n\n\tfmt_copy = perf_hpp_fmt__dup(fmt);\n\tif (fmt_copy == NULL)\n\t\treturn -1;\n\n\tif (!skip)\n\t\tnode->skip = false;\n\n\tlist_add_tail(&fmt_copy->list, &node->hpp.fields);\n\tlist_add_tail(&fmt_copy->sort_list, &node->hpp.sorts);\n\n\treturn 0;\n}\n\nint perf_hpp__setup_hists_formats(struct perf_hpp_list *list,\n\t\t\t\t  struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\tstruct perf_hpp_fmt *fmt;\n\tstruct hists *hists;\n\tint ret;\n\n\tif (!symbol_conf.report_hierarchy)\n\t\treturn 0;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\thists = evsel__hists(evsel);\n\n\t\tperf_hpp_list__for_each_sort_list(list, fmt) {\n\t\t\tif (perf_hpp__is_dynamic_entry(fmt) &&\n\t\t\t    !perf_hpp__defined_dynamic_entry(fmt, hists))\n\t\t\t\tcontinue;\n\n\t\t\tret = add_hierarchy_fmt(hists, fmt);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}