{
  "module_name": "annotate.c",
  "hash_id": "7a3ef7f3c2611b858a12e8ea0170f52c51cdc3287826a09769d261cdb0e44528",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/ui/gtk/annotate.c",
  "human_readable_source": "\n#include \"gtk.h\"\n#include \"util/sort.h\"\n#include \"util/debug.h\"\n#include \"util/annotate.h\"\n#include \"util/evsel.h\"\n#include \"util/map.h\"\n#include \"util/dso.h\"\n#include \"util/symbol.h\"\n#include \"ui/helpline.h\"\n#include <inttypes.h>\n#include <signal.h>\n\nenum {\n\tANN_COL__PERCENT,\n\tANN_COL__OFFSET,\n\tANN_COL__LINE,\n\n\tMAX_ANN_COLS\n};\n\nstatic const char *const col_names[] = {\n\t\"Overhead\",\n\t\"Offset\",\n\t\"Line\"\n};\n\nstatic int perf_gtk__get_percent(char *buf, size_t size, struct symbol *sym,\n\t\t\t\t struct disasm_line *dl, int evidx)\n{\n\tstruct sym_hist *symhist;\n\tdouble percent = 0.0;\n\tconst char *markup;\n\tint ret = 0;\n\n\tstrcpy(buf, \"\");\n\n\tif (dl->al.offset == (s64) -1)\n\t\treturn 0;\n\n\tsymhist = annotation__histogram(symbol__annotation(sym), evidx);\n\tif (!symbol_conf.event_group && !symhist->addr[dl->al.offset].nr_samples)\n\t\treturn 0;\n\n\tpercent = 100.0 * symhist->addr[dl->al.offset].nr_samples / symhist->nr_samples;\n\n\tmarkup = perf_gtk__get_percent_color(percent);\n\tif (markup)\n\t\tret += scnprintf(buf, size, \"%s\", markup);\n\tret += scnprintf(buf + ret, size - ret, \"%6.2f%%\", percent);\n\tif (markup)\n\t\tret += scnprintf(buf + ret, size - ret, \"</span>\");\n\n\treturn ret;\n}\n\nstatic int perf_gtk__get_offset(char *buf, size_t size, struct map_symbol *ms,\n\t\t\t\tstruct disasm_line *dl)\n{\n\tu64 start = map__rip_2objdump(ms->map, ms->sym->start);\n\n\tstrcpy(buf, \"\");\n\n\tif (dl->al.offset == (s64) -1)\n\t\treturn 0;\n\n\treturn scnprintf(buf, size, \"%\"PRIx64, start + dl->al.offset);\n}\n\nstatic int perf_gtk__get_line(char *buf, size_t size, struct disasm_line *dl)\n{\n\tint ret = 0;\n\tchar *line = g_markup_escape_text(dl->al.line, -1);\n\tconst char *markup = \"<span fgcolor='gray'>\";\n\n\tstrcpy(buf, \"\");\n\n\tif (!line)\n\t\treturn 0;\n\n\tif (dl->al.offset != (s64) -1)\n\t\tmarkup = NULL;\n\n\tif (markup)\n\t\tret += scnprintf(buf, size, \"%s\", markup);\n\tret += scnprintf(buf + ret, size - ret, \"%s\", line);\n\tif (markup)\n\t\tret += scnprintf(buf + ret, size - ret, \"</span>\");\n\n\tg_free(line);\n\treturn ret;\n}\n\nstatic int perf_gtk__annotate_symbol(GtkWidget *window, struct map_symbol *ms,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct hist_browser_timer *hbt __maybe_unused)\n{\n\tstruct symbol *sym = ms->sym;\n\tstruct disasm_line *pos, *n;\n\tstruct annotation *notes;\n\tGType col_types[MAX_ANN_COLS];\n\tGtkCellRenderer *renderer;\n\tGtkListStore *store;\n\tGtkWidget *view;\n\tint i;\n\tchar s[512];\n\n\tnotes = symbol__annotation(sym);\n\n\tfor (i = 0; i < MAX_ANN_COLS; i++) {\n\t\tcol_types[i] = G_TYPE_STRING;\n\t}\n\tstore = gtk_list_store_newv(MAX_ANN_COLS, col_types);\n\n\tview = gtk_tree_view_new();\n\trenderer = gtk_cell_renderer_text_new();\n\n\tfor (i = 0; i < MAX_ANN_COLS; i++) {\n\t\tgtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(view),\n\t\t\t\t\t-1, col_names[i], renderer, \"markup\",\n\t\t\t\t\ti, NULL);\n\t}\n\n\tgtk_tree_view_set_model(GTK_TREE_VIEW(view), GTK_TREE_MODEL(store));\n\tg_object_unref(GTK_TREE_MODEL(store));\n\n\tlist_for_each_entry(pos, &notes->src->source, al.node) {\n\t\tGtkTreeIter iter;\n\t\tint ret = 0;\n\n\t\tgtk_list_store_append(store, &iter);\n\n\t\tif (evsel__is_group_event(evsel)) {\n\t\t\tfor (i = 0; i < evsel->core.nr_members; i++) {\n\t\t\t\tret += perf_gtk__get_percent(s + ret,\n\t\t\t\t\t\t\t     sizeof(s) - ret,\n\t\t\t\t\t\t\t     sym, pos,\n\t\t\t\t\t\t\t     evsel->core.idx + i);\n\t\t\t\tret += scnprintf(s + ret, sizeof(s) - ret, \" \");\n\t\t\t}\n\t\t} else {\n\t\t\tret = perf_gtk__get_percent(s, sizeof(s), sym, pos,\n\t\t\t\t\t\t    evsel->core.idx);\n\t\t}\n\n\t\tif (ret)\n\t\t\tgtk_list_store_set(store, &iter, ANN_COL__PERCENT, s, -1);\n\t\tif (perf_gtk__get_offset(s, sizeof(s), ms, pos))\n\t\t\tgtk_list_store_set(store, &iter, ANN_COL__OFFSET, s, -1);\n\t\tif (perf_gtk__get_line(s, sizeof(s), pos))\n\t\t\tgtk_list_store_set(store, &iter, ANN_COL__LINE, s, -1);\n\t}\n\n\tgtk_container_add(GTK_CONTAINER(window), view);\n\n\tlist_for_each_entry_safe(pos, n, &notes->src->source, al.node) {\n\t\tlist_del_init(&pos->al.node);\n\t\tdisasm_line__free(pos);\n\t}\n\n\treturn 0;\n}\n\nstatic int symbol__gtk_annotate(struct map_symbol *ms, struct evsel *evsel,\n\t\t\t\tstruct annotation_options *options,\n\t\t\t\tstruct hist_browser_timer *hbt)\n{\n\tstruct dso *dso = map__dso(ms->map);\n\tstruct symbol *sym = ms->sym;\n\tGtkWidget *window;\n\tGtkWidget *notebook;\n\tGtkWidget *scrolled_window;\n\tGtkWidget *tab_label;\n\tint err;\n\n\tif (dso->annotate_warned)\n\t\treturn -1;\n\n\terr = symbol__annotate(ms, evsel, options, NULL);\n\tif (err) {\n\t\tchar msg[BUFSIZ];\n\t\tdso->annotate_warned = true;\n\t\tsymbol__strerror_disassemble(ms, err, msg, sizeof(msg));\n\t\tui__error(\"Couldn't annotate %s: %s\\n\", sym->name, msg);\n\t\treturn -1;\n\t}\n\n\tsymbol__calc_percent(sym, evsel);\n\n\tif (perf_gtk__is_active_context(pgctx)) {\n\t\twindow = pgctx->main_window;\n\t\tnotebook = pgctx->notebook;\n\t} else {\n\t\tGtkWidget *vbox;\n\t\tGtkWidget *infobar;\n\t\tGtkWidget *statbar;\n\n\t\tsignal(SIGSEGV, perf_gtk__signal);\n\t\tsignal(SIGFPE,  perf_gtk__signal);\n\t\tsignal(SIGINT,  perf_gtk__signal);\n\t\tsignal(SIGQUIT, perf_gtk__signal);\n\t\tsignal(SIGTERM, perf_gtk__signal);\n\n\t\twindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n\t\tgtk_window_set_title(GTK_WINDOW(window), \"perf annotate\");\n\n\t\tg_signal_connect(window, \"delete_event\", gtk_main_quit, NULL);\n\n\t\tpgctx = perf_gtk__activate_context(window);\n\t\tif (!pgctx)\n\t\t\treturn -1;\n\n\t\tvbox = gtk_vbox_new(FALSE, 0);\n\t\tnotebook = gtk_notebook_new();\n\t\tpgctx->notebook = notebook;\n\n\t\tgtk_box_pack_start(GTK_BOX(vbox), notebook, TRUE, TRUE, 0);\n\n\t\tinfobar = perf_gtk__setup_info_bar();\n\t\tif (infobar) {\n\t\t\tgtk_box_pack_start(GTK_BOX(vbox), infobar,\n\t\t\t\t\t   FALSE, FALSE, 0);\n\t\t}\n\n\t\tstatbar = perf_gtk__setup_statusbar();\n\t\tgtk_box_pack_start(GTK_BOX(vbox), statbar, FALSE, FALSE, 0);\n\n\t\tgtk_container_add(GTK_CONTAINER(window), vbox);\n\t}\n\n\tscrolled_window = gtk_scrolled_window_new(NULL, NULL);\n\ttab_label = gtk_label_new(sym->name);\n\n\tgtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window),\n\t\t\t\t       GTK_POLICY_AUTOMATIC,\n\t\t\t\t       GTK_POLICY_AUTOMATIC);\n\n\tgtk_notebook_append_page(GTK_NOTEBOOK(notebook), scrolled_window,\n\t\t\t\t tab_label);\n\n\tperf_gtk__annotate_symbol(scrolled_window, ms, evsel, hbt);\n\treturn 0;\n}\n\nint hist_entry__gtk_annotate(struct hist_entry *he,\n\t\t\t     struct evsel *evsel,\n\t\t\t     struct annotation_options *options,\n\t\t\t     struct hist_browser_timer *hbt)\n{\n\treturn symbol__gtk_annotate(&he->ms, evsel, options, hbt);\n}\n\nvoid perf_gtk__show_annotations(void)\n{\n\tGtkWidget *window;\n\n\tif (!perf_gtk__is_active_context(pgctx))\n\t\treturn;\n\n\twindow = pgctx->main_window;\n\tgtk_widget_show_all(window);\n\n\tperf_gtk__resize_window(window);\n\tgtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);\n\n\tgtk_main();\n\n\tperf_gtk__deactivate_context(&pgctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}