{
  "module_name": "hists.c",
  "hash_id": "b322f43e061deca669ee8e4875b7767afa23106d9e1adaff95b15ca08745420e",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/ui/gtk/hists.c",
  "human_readable_source": "\n#include \"gtk.h\"\n#include \"../evlist.h\"\n#include \"../callchain.h\"\n#include \"../evsel.h\"\n#include \"../sort.h\"\n#include \"../hist.h\"\n#include \"../helpline.h\"\n#include \"../string2.h\"\n#include <signal.h>\n#include <stdlib.h>\n#include <linux/string.h>\n\n#define MAX_COLUMNS\t\t\t32\n\nstatic int __percent_color_snprintf(struct perf_hpp *hpp, const char *fmt, ...)\n{\n\tint ret = 0;\n\tint len;\n\tva_list args;\n\tdouble percent;\n\tconst char *markup;\n\tchar *buf = hpp->buf;\n\tsize_t size = hpp->size;\n\n\tva_start(args, fmt);\n\tlen = va_arg(args, int);\n\tpercent = va_arg(args, double);\n\tva_end(args);\n\n\tmarkup = perf_gtk__get_percent_color(percent);\n\tif (markup)\n\t\tret += scnprintf(buf, size, markup);\n\n\tret += scnprintf(buf + ret, size - ret, fmt, len, percent);\n\n\tif (markup)\n\t\tret += scnprintf(buf + ret, size - ret, \"</span>\");\n\n\treturn ret;\n}\n\n#define __HPP_COLOR_PERCENT_FN(_type, _field)\t\t\t\t\t\\\nstatic u64 he_get_##_field(struct hist_entry *he)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn he->stat._field;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nstatic int perf_gtk__hpp_color_##_type(struct perf_hpp_fmt *fmt,\t\t\\\n\t\t\t\t       struct perf_hpp *hpp,\t\t\t\\\n\t\t\t\t       struct hist_entry *he)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn hpp__fmt(fmt, hpp, he, he_get_##_field, \" %*.2f%%\",\t\t\\\n\t\t\t__percent_color_snprintf, true);\t\t\t\\\n}\n\n#define __HPP_COLOR_ACC_PERCENT_FN(_type, _field)\t\t\t\t\\\nstatic u64 he_get_acc_##_field(struct hist_entry *he)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn he->stat_acc->_field;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nstatic int perf_gtk__hpp_color_##_type(struct perf_hpp_fmt *fmt,\t\t\\\n\t\t\t\t       struct perf_hpp *hpp,\t\t\t\\\n\t\t\t\t       struct hist_entry *he)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn hpp__fmt_acc(fmt, hpp, he, he_get_acc_##_field, \" %*.2f%%\", \t\\\n\t\t\t    __percent_color_snprintf, true);\t\t\t\\\n}\n\n__HPP_COLOR_PERCENT_FN(overhead, period)\n__HPP_COLOR_PERCENT_FN(overhead_sys, period_sys)\n__HPP_COLOR_PERCENT_FN(overhead_us, period_us)\n__HPP_COLOR_PERCENT_FN(overhead_guest_sys, period_guest_sys)\n__HPP_COLOR_PERCENT_FN(overhead_guest_us, period_guest_us)\n__HPP_COLOR_ACC_PERCENT_FN(overhead_acc, period)\n\n#undef __HPP_COLOR_PERCENT_FN\n\n\nvoid perf_gtk__init_hpp(void)\n{\n\tperf_hpp__format[PERF_HPP__OVERHEAD].color =\n\t\t\t\tperf_gtk__hpp_color_overhead;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_SYS].color =\n\t\t\t\tperf_gtk__hpp_color_overhead_sys;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_US].color =\n\t\t\t\tperf_gtk__hpp_color_overhead_us;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_GUEST_SYS].color =\n\t\t\t\tperf_gtk__hpp_color_overhead_guest_sys;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_GUEST_US].color =\n\t\t\t\tperf_gtk__hpp_color_overhead_guest_us;\n\tperf_hpp__format[PERF_HPP__OVERHEAD_ACC].color =\n\t\t\t\tperf_gtk__hpp_color_overhead_acc;\n}\n\nstatic void perf_gtk__add_callchain_flat(struct rb_root *root, GtkTreeStore *store,\n\t\t\t\t\t GtkTreeIter *parent, int col, u64 total)\n{\n\tstruct rb_node *nd;\n\tbool has_single_node = (rb_first(root) == rb_last(root));\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct callchain_node *node;\n\t\tstruct callchain_list *chain;\n\t\tGtkTreeIter iter, new_parent;\n\t\tbool need_new_parent;\n\n\t\tnode = rb_entry(nd, struct callchain_node, rb_node);\n\n\t\tnew_parent = *parent;\n\t\tneed_new_parent = !has_single_node;\n\n\t\tcallchain_node__make_parent_list(node);\n\n\t\tlist_for_each_entry(chain, &node->parent_val, list) {\n\t\t\tchar buf[128];\n\n\t\t\tgtk_tree_store_append(store, &iter, &new_parent);\n\n\t\t\tcallchain_node__scnprintf_value(node, buf, sizeof(buf), total);\n\t\t\tgtk_tree_store_set(store, &iter, 0, buf, -1);\n\n\t\t\tcallchain_list__sym_name(chain, buf, sizeof(buf), false);\n\t\t\tgtk_tree_store_set(store, &iter, col, buf, -1);\n\n\t\t\tif (need_new_parent) {\n\t\t\t\t \n\t\t\t\tnew_parent = iter;\n\t\t\t\tneed_new_parent = false;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(chain, &node->val, list) {\n\t\t\tchar buf[128];\n\n\t\t\tgtk_tree_store_append(store, &iter, &new_parent);\n\n\t\t\tcallchain_node__scnprintf_value(node, buf, sizeof(buf), total);\n\t\t\tgtk_tree_store_set(store, &iter, 0, buf, -1);\n\n\t\t\tcallchain_list__sym_name(chain, buf, sizeof(buf), false);\n\t\t\tgtk_tree_store_set(store, &iter, col, buf, -1);\n\n\t\t\tif (need_new_parent) {\n\t\t\t\t \n\t\t\t\tnew_parent = iter;\n\t\t\t\tneed_new_parent = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void perf_gtk__add_callchain_folded(struct rb_root *root, GtkTreeStore *store,\n\t\t\t\t\t   GtkTreeIter *parent, int col, u64 total)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct callchain_node *node;\n\t\tstruct callchain_list *chain;\n\t\tGtkTreeIter iter;\n\t\tchar buf[64];\n\t\tchar *str, *str_alloc = NULL;\n\t\tbool first = true;\n\n\t\tnode = rb_entry(nd, struct callchain_node, rb_node);\n\n\t\tcallchain_node__make_parent_list(node);\n\n\t\tlist_for_each_entry(chain, &node->parent_val, list) {\n\t\t\tchar name[1024];\n\n\t\t\tcallchain_list__sym_name(chain, name, sizeof(name), false);\n\n\t\t\tif (asprintf(&str, \"%s%s%s\",\n\t\t\t\t     first ? \"\" : str_alloc,\n\t\t\t\t     first ? \"\" : symbol_conf.field_sep ?: \"; \",\n\t\t\t\t     name) < 0)\n\t\t\t\treturn;\n\n\t\t\tfirst = false;\n\t\t\tfree(str_alloc);\n\t\t\tstr_alloc = str;\n\t\t}\n\n\t\tlist_for_each_entry(chain, &node->val, list) {\n\t\t\tchar name[1024];\n\n\t\t\tcallchain_list__sym_name(chain, name, sizeof(name), false);\n\n\t\t\tif (asprintf(&str, \"%s%s%s\",\n\t\t\t\t     first ? \"\" : str_alloc,\n\t\t\t\t     first ? \"\" : symbol_conf.field_sep ?: \"; \",\n\t\t\t\t     name) < 0)\n\t\t\t\treturn;\n\n\t\t\tfirst = false;\n\t\t\tfree(str_alloc);\n\t\t\tstr_alloc = str;\n\t\t}\n\n\t\tgtk_tree_store_append(store, &iter, parent);\n\n\t\tcallchain_node__scnprintf_value(node, buf, sizeof(buf), total);\n\t\tgtk_tree_store_set(store, &iter, 0, buf, -1);\n\n\t\tgtk_tree_store_set(store, &iter, col, str, -1);\n\n\t\tfree(str_alloc);\n\t}\n}\n\nstatic void perf_gtk__add_callchain_graph(struct rb_root *root, GtkTreeStore *store,\n\t\t\t\t\t  GtkTreeIter *parent, int col, u64 total)\n{\n\tstruct rb_node *nd;\n\tbool has_single_node = (rb_first(root) == rb_last(root));\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct callchain_node *node;\n\t\tstruct callchain_list *chain;\n\t\tGtkTreeIter iter, new_parent;\n\t\tbool need_new_parent;\n\t\tu64 child_total;\n\n\t\tnode = rb_entry(nd, struct callchain_node, rb_node);\n\n\t\tnew_parent = *parent;\n\t\tneed_new_parent = !has_single_node && (node->val_nr > 1);\n\n\t\tlist_for_each_entry(chain, &node->val, list) {\n\t\t\tchar buf[128];\n\n\t\t\tgtk_tree_store_append(store, &iter, &new_parent);\n\n\t\t\tcallchain_node__scnprintf_value(node, buf, sizeof(buf), total);\n\t\t\tgtk_tree_store_set(store, &iter, 0, buf, -1);\n\n\t\t\tcallchain_list__sym_name(chain, buf, sizeof(buf), false);\n\t\t\tgtk_tree_store_set(store, &iter, col, buf, -1);\n\n\t\t\tif (need_new_parent) {\n\t\t\t\t \n\t\t\t\tnew_parent = iter;\n\t\t\t\tneed_new_parent = false;\n\t\t\t}\n\t\t}\n\n\t\tif (callchain_param.mode == CHAIN_GRAPH_REL)\n\t\t\tchild_total = node->children_hit;\n\t\telse\n\t\t\tchild_total = total;\n\n\t\t \n\t\tperf_gtk__add_callchain_graph(&node->rb_root, store, &iter, col,\n\t\t\t\t\t      child_total);\n\t}\n}\n\nstatic void perf_gtk__add_callchain(struct rb_root *root, GtkTreeStore *store,\n\t\t\t\t    GtkTreeIter *parent, int col, u64 total)\n{\n\tif (callchain_param.mode == CHAIN_FLAT)\n\t\tperf_gtk__add_callchain_flat(root, store, parent, col, total);\n\telse if (callchain_param.mode == CHAIN_FOLDED)\n\t\tperf_gtk__add_callchain_folded(root, store, parent, col, total);\n\telse\n\t\tperf_gtk__add_callchain_graph(root, store, parent, col, total);\n}\n\nstatic void on_row_activated(GtkTreeView *view, GtkTreePath *path,\n\t\t\t     GtkTreeViewColumn *col __maybe_unused,\n\t\t\t     gpointer user_data __maybe_unused)\n{\n\tbool expanded = gtk_tree_view_row_expanded(view, path);\n\n\tif (expanded)\n\t\tgtk_tree_view_collapse_row(view, path);\n\telse\n\t\tgtk_tree_view_expand_row(view, path, FALSE);\n}\n\nstatic void perf_gtk__show_hists(GtkWidget *window, struct hists *hists,\n\t\t\t\t float min_pcnt)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tGType col_types[MAX_COLUMNS];\n\tGtkCellRenderer *renderer;\n\tGtkTreeStore *store;\n\tstruct rb_node *nd;\n\tGtkWidget *view;\n\tint col_idx;\n\tint sym_col = -1;\n\tint nr_cols;\n\tchar s[512];\n\n\tstruct perf_hpp hpp = {\n\t\t.buf\t\t= s,\n\t\t.size\t\t= sizeof(s),\n\t};\n\n\tnr_cols = 0;\n\n\thists__for_each_format(hists, fmt)\n\t\tcol_types[nr_cols++] = G_TYPE_STRING;\n\n\tstore = gtk_tree_store_newv(nr_cols, col_types);\n\n\tview = gtk_tree_view_new();\n\n\trenderer = gtk_cell_renderer_text_new();\n\n\tcol_idx = 0;\n\n\thists__for_each_format(hists, fmt) {\n\t\tif (perf_hpp__should_skip(fmt, hists))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (perf_hpp__is_sort_entry(fmt))\n\t\t\tsym_col = col_idx;\n\n\t\tgtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(view),\n\t\t\t\t\t\t\t    -1, fmt->name,\n\t\t\t\t\t\t\t    renderer, \"markup\",\n\t\t\t\t\t\t\t    col_idx++, NULL);\n\t}\n\n\tfor (col_idx = 0; col_idx < nr_cols; col_idx++) {\n\t\tGtkTreeViewColumn *column;\n\n\t\tcolumn = gtk_tree_view_get_column(GTK_TREE_VIEW(view), col_idx);\n\t\tgtk_tree_view_column_set_resizable(column, TRUE);\n\n\t\tif (col_idx == sym_col) {\n\t\t\tgtk_tree_view_set_expander_column(GTK_TREE_VIEW(view),\n\t\t\t\t\t\t\t  column);\n\t\t}\n\t}\n\n\tgtk_tree_view_set_model(GTK_TREE_VIEW(view), GTK_TREE_MODEL(store));\n\n\tg_object_unref(GTK_TREE_MODEL(store));\n\n\tfor (nd = rb_first_cached(&hists->entries); nd; nd = rb_next(nd)) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\t\tGtkTreeIter iter;\n\t\tu64 total = hists__total_period(h->hists);\n\t\tfloat percent;\n\n\t\tif (h->filtered)\n\t\t\tcontinue;\n\n\t\tpercent = hist_entry__get_percent_limit(h);\n\t\tif (percent < min_pcnt)\n\t\t\tcontinue;\n\n\t\tgtk_tree_store_append(store, &iter, NULL);\n\n\t\tcol_idx = 0;\n\n\t\thists__for_each_format(hists, fmt) {\n\t\t\tif (perf_hpp__should_skip(fmt, h->hists))\n\t\t\t\tcontinue;\n\n\t\t\tif (fmt->color)\n\t\t\t\tfmt->color(fmt, &hpp, h);\n\t\t\telse\n\t\t\t\tfmt->entry(fmt, &hpp, h);\n\n\t\t\tgtk_tree_store_set(store, &iter, col_idx++, s, -1);\n\t\t}\n\n\t\tif (hist_entry__has_callchains(h) &&\n\t\t    symbol_conf.use_callchain && hists__has(hists, sym)) {\n\t\t\tif (callchain_param.mode == CHAIN_GRAPH_REL)\n\t\t\t\ttotal = symbol_conf.cumulate_callchain ?\n\t\t\t\t\th->stat_acc->period : h->stat.period;\n\n\t\t\tperf_gtk__add_callchain(&h->sorted_chain, store, &iter,\n\t\t\t\t\t\tsym_col, total);\n\t\t}\n\t}\n\n\tgtk_tree_view_set_rules_hint(GTK_TREE_VIEW(view), TRUE);\n\n\tg_signal_connect(view, \"row-activated\",\n\t\t\t G_CALLBACK(on_row_activated), NULL);\n\tgtk_container_add(GTK_CONTAINER(window), view);\n}\n\nstatic void perf_gtk__add_hierarchy_entries(struct hists *hists,\n\t\t\t\t\t    struct rb_root_cached *root,\n\t\t\t\t\t    GtkTreeStore *store,\n\t\t\t\t\t    GtkTreeIter *parent,\n\t\t\t\t\t    struct perf_hpp *hpp,\n\t\t\t\t\t    float min_pcnt)\n{\n\tint col_idx = 0;\n\tstruct rb_node *node;\n\tstruct hist_entry *he;\n\tstruct perf_hpp_fmt *fmt;\n\tstruct perf_hpp_list_node *fmt_node;\n\tu64 total = hists__total_period(hists);\n\tint size;\n\n\tfor (node = rb_first_cached(root); node; node = rb_next(node)) {\n\t\tGtkTreeIter iter;\n\t\tfloat percent;\n\t\tchar *bf;\n\n\t\the = rb_entry(node, struct hist_entry, rb_node);\n\t\tif (he->filtered)\n\t\t\tcontinue;\n\n\t\tpercent = hist_entry__get_percent_limit(he);\n\t\tif (percent < min_pcnt)\n\t\t\tcontinue;\n\n\t\tgtk_tree_store_append(store, &iter, parent);\n\n\t\tcol_idx = 0;\n\n\t\t \n\t\tfmt_node = list_first_entry(&hists->hpp_formats,\n\t\t\t\t\t    struct perf_hpp_list_node, list);\n\t\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\t\tif (fmt->color)\n\t\t\t\tfmt->color(fmt, hpp, he);\n\t\t\telse\n\t\t\t\tfmt->entry(fmt, hpp, he);\n\n\t\t\tgtk_tree_store_set(store, &iter, col_idx++, hpp->buf, -1);\n\t\t}\n\n\t\tbf = hpp->buf;\n\t\tsize = hpp->size;\n\t\tperf_hpp_list__for_each_format(he->hpp_list, fmt) {\n\t\t\tint ret;\n\n\t\t\tif (fmt->color)\n\t\t\t\tret = fmt->color(fmt, hpp, he);\n\t\t\telse\n\t\t\t\tret = fmt->entry(fmt, hpp, he);\n\n\t\t\tsnprintf(hpp->buf + ret, hpp->size - ret, \"  \");\n\t\t\tadvance_hpp(hpp, ret + 2);\n\t\t}\n\n\t\tgtk_tree_store_set(store, &iter, col_idx, strim(bf), -1);\n\n\t\tif (!he->leaf) {\n\t\t\thpp->buf = bf;\n\t\t\thpp->size = size;\n\n\t\t\tperf_gtk__add_hierarchy_entries(hists, &he->hroot_out,\n\t\t\t\t\t\t\tstore, &iter, hpp,\n\t\t\t\t\t\t\tmin_pcnt);\n\n\t\t\tif (!hist_entry__has_hierarchy_children(he, min_pcnt)) {\n\t\t\t\tchar buf[32];\n\t\t\t\tGtkTreeIter child;\n\n\t\t\t\tsnprintf(buf, sizeof(buf), \"no entry >= %.2f%%\",\n\t\t\t\t\t min_pcnt);\n\n\t\t\t\tgtk_tree_store_append(store, &child, &iter);\n\t\t\t\tgtk_tree_store_set(store, &child, col_idx, buf, -1);\n\t\t\t}\n\t\t}\n\n\t\tif (he->leaf && hist_entry__has_callchains(he) && symbol_conf.use_callchain) {\n\t\t\tif (callchain_param.mode == CHAIN_GRAPH_REL)\n\t\t\t\ttotal = symbol_conf.cumulate_callchain ?\n\t\t\t\t\the->stat_acc->period : he->stat.period;\n\n\t\t\tperf_gtk__add_callchain(&he->sorted_chain, store, &iter,\n\t\t\t\t\t\tcol_idx, total);\n\t\t}\n\t}\n\n}\n\nstatic void perf_gtk__show_hierarchy(GtkWidget *window, struct hists *hists,\n\t\t\t\t     float min_pcnt)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tstruct perf_hpp_list_node *fmt_node;\n\tGType col_types[MAX_COLUMNS];\n\tGtkCellRenderer *renderer;\n\tGtkTreeStore *store;\n\tGtkWidget *view;\n\tint col_idx;\n\tint nr_cols = 0;\n\tchar s[512];\n\tchar buf[512];\n\tbool first_node, first_col;\n\tstruct perf_hpp hpp = {\n\t\t.buf\t\t= s,\n\t\t.size\t\t= sizeof(s),\n\t};\n\n\thists__for_each_format(hists, fmt) {\n\t\tif (perf_hpp__is_sort_entry(fmt) ||\n\t\t    perf_hpp__is_dynamic_entry(fmt))\n\t\t\tbreak;\n\n\t\tcol_types[nr_cols++] = G_TYPE_STRING;\n\t}\n\tcol_types[nr_cols++] = G_TYPE_STRING;\n\n\tstore = gtk_tree_store_newv(nr_cols, col_types);\n\tview = gtk_tree_view_new();\n\trenderer = gtk_cell_renderer_text_new();\n\n\tcol_idx = 0;\n\n\t \n\tfmt_node = list_first_entry(&hists->hpp_formats,\n\t\t\t\t    struct perf_hpp_list_node, list);\n\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\tgtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(view),\n\t\t\t\t\t\t\t    -1, fmt->name,\n\t\t\t\t\t\t\t    renderer, \"markup\",\n\t\t\t\t\t\t\t    col_idx++, NULL);\n\t}\n\n\t \n\tbuf[0] = '\\0';\n\tfirst_node = true;\n\tlist_for_each_entry_continue(fmt_node, &hists->hpp_formats, list) {\n\t\tif (!first_node)\n\t\t\tstrcat(buf, \" / \");\n\t\tfirst_node = false;\n\n\t\tfirst_col = true;\n\t\tperf_hpp_list__for_each_format(&fmt_node->hpp ,fmt) {\n\t\t\tif (perf_hpp__should_skip(fmt, hists))\n\t\t\t\tcontinue;\n\n\t\t\tif (!first_col)\n\t\t\t\tstrcat(buf, \"+\");\n\t\t\tfirst_col = false;\n\n\t\t\tfmt->header(fmt, &hpp, hists, 0, NULL);\n\t\t\tstrcat(buf, strim(hpp.buf));\n\t\t}\n\t}\n\n\tgtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(view),\n\t\t\t\t\t\t    -1, buf,\n\t\t\t\t\t\t    renderer, \"markup\",\n\t\t\t\t\t\t    col_idx++, NULL);\n\n\tfor (col_idx = 0; col_idx < nr_cols; col_idx++) {\n\t\tGtkTreeViewColumn *column;\n\n\t\tcolumn = gtk_tree_view_get_column(GTK_TREE_VIEW(view), col_idx);\n\t\tgtk_tree_view_column_set_resizable(column, TRUE);\n\n\t\tif (col_idx == 0) {\n\t\t\tgtk_tree_view_set_expander_column(GTK_TREE_VIEW(view),\n\t\t\t\t\t\t\t  column);\n\t\t}\n\t}\n\n\tgtk_tree_view_set_model(GTK_TREE_VIEW(view), GTK_TREE_MODEL(store));\n\tg_object_unref(GTK_TREE_MODEL(store));\n\n\tperf_gtk__add_hierarchy_entries(hists, &hists->entries, store,\n\t\t\t\t\tNULL, &hpp, min_pcnt);\n\n\tgtk_tree_view_set_rules_hint(GTK_TREE_VIEW(view), TRUE);\n\n\tg_signal_connect(view, \"row-activated\",\n\t\t\t G_CALLBACK(on_row_activated), NULL);\n\tgtk_container_add(GTK_CONTAINER(window), view);\n}\n\nint evlist__gtk_browse_hists(struct evlist *evlist, const char *help,\n\t\t\t     struct hist_browser_timer *hbt __maybe_unused, float min_pcnt)\n{\n\tstruct evsel *pos;\n\tGtkWidget *vbox;\n\tGtkWidget *notebook;\n\tGtkWidget *info_bar;\n\tGtkWidget *statbar;\n\tGtkWidget *window;\n\n\tsignal(SIGSEGV, perf_gtk__signal);\n\tsignal(SIGFPE,  perf_gtk__signal);\n\tsignal(SIGINT,  perf_gtk__signal);\n\tsignal(SIGQUIT, perf_gtk__signal);\n\tsignal(SIGTERM, perf_gtk__signal);\n\n\twindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n\n\tgtk_window_set_title(GTK_WINDOW(window), \"perf report\");\n\n\tg_signal_connect(window, \"delete_event\", gtk_main_quit, NULL);\n\n\tpgctx = perf_gtk__activate_context(window);\n\tif (!pgctx)\n\t\treturn -1;\n\n\tvbox = gtk_vbox_new(FALSE, 0);\n\n\tnotebook = gtk_notebook_new();\n\n\tgtk_box_pack_start(GTK_BOX(vbox), notebook, TRUE, TRUE, 0);\n\n\tinfo_bar = perf_gtk__setup_info_bar();\n\tif (info_bar)\n\t\tgtk_box_pack_start(GTK_BOX(vbox), info_bar, FALSE, FALSE, 0);\n\n\tstatbar = perf_gtk__setup_statusbar();\n\tgtk_box_pack_start(GTK_BOX(vbox), statbar, FALSE, FALSE, 0);\n\n\tgtk_container_add(GTK_CONTAINER(window), vbox);\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\t\tconst char *evname = evsel__name(pos);\n\t\tGtkWidget *scrolled_window;\n\t\tGtkWidget *tab_label;\n\t\tchar buf[512];\n\t\tsize_t size = sizeof(buf);\n\n\t\tif (symbol_conf.event_group) {\n\t\t\tif (!evsel__is_group_leader(pos))\n\t\t\t\tcontinue;\n\n\t\t\tif (pos->core.nr_members > 1) {\n\t\t\t\tevsel__group_desc(pos, buf, size);\n\t\t\t\tevname = buf;\n\t\t\t}\n\t\t}\n\n\t\tscrolled_window = gtk_scrolled_window_new(NULL, NULL);\n\n\t\tgtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window),\n\t\t\t\t\t\t\tGTK_POLICY_AUTOMATIC,\n\t\t\t\t\t\t\tGTK_POLICY_AUTOMATIC);\n\n\t\tif (symbol_conf.report_hierarchy)\n\t\t\tperf_gtk__show_hierarchy(scrolled_window, hists, min_pcnt);\n\t\telse\n\t\t\tperf_gtk__show_hists(scrolled_window, hists, min_pcnt);\n\n\t\ttab_label = gtk_label_new(evname);\n\n\t\tgtk_notebook_append_page(GTK_NOTEBOOK(notebook), scrolled_window, tab_label);\n\t}\n\n\tgtk_widget_show_all(window);\n\n\tperf_gtk__resize_window(window);\n\n\tgtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);\n\n\tui_helpline__push(help);\n\n\tgtk_main();\n\n\tperf_gtk__deactivate_context(&pgctx);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}