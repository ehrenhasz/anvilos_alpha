{
  "module_name": "hist.c",
  "hash_id": "a0784c70a593f0ccdc93b954ca623cb06dfd716d6af2d2bb8a9970f252d83026",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/ui/stdio/hist.c",
  "human_readable_source": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <linux/string.h>\n\n#include \"../../util/callchain.h\"\n#include \"../../util/debug.h\"\n#include \"../../util/event.h\"\n#include \"../../util/hist.h\"\n#include \"../../util/map.h\"\n#include \"../../util/maps.h\"\n#include \"../../util/symbol.h\"\n#include \"../../util/sort.h\"\n#include \"../../util/evsel.h\"\n#include \"../../util/srcline.h\"\n#include \"../../util/string2.h\"\n#include \"../../util/thread.h\"\n#include \"../../util/block-info.h\"\n#include <linux/ctype.h>\n#include <linux/zalloc.h>\n\nstatic size_t callchain__fprintf_left_margin(FILE *fp, int left_margin)\n{\n\tint i;\n\tint ret = fprintf(fp, \"            \");\n\n\tfor (i = 0; i < left_margin; i++)\n\t\tret += fprintf(fp, \" \");\n\n\treturn ret;\n}\n\nstatic size_t ipchain__fprintf_graph_line(FILE *fp, int depth, int depth_mask,\n\t\t\t\t\t  int left_margin)\n{\n\tint i;\n\tsize_t ret = callchain__fprintf_left_margin(fp, left_margin);\n\n\tfor (i = 0; i < depth; i++)\n\t\tif (depth_mask & (1 << i))\n\t\t\tret += fprintf(fp, \"|          \");\n\t\telse\n\t\t\tret += fprintf(fp, \"           \");\n\n\tret += fprintf(fp, \"\\n\");\n\n\treturn ret;\n}\n\nstatic size_t ipchain__fprintf_graph(FILE *fp, struct callchain_node *node,\n\t\t\t\t     struct callchain_list *chain,\n\t\t\t\t     int depth, int depth_mask, int period,\n\t\t\t\t     u64 total_samples, int left_margin)\n{\n\tint i;\n\tsize_t ret = 0;\n\tchar bf[1024], *alloc_str = NULL;\n\tchar buf[64];\n\tconst char *str;\n\n\tret += callchain__fprintf_left_margin(fp, left_margin);\n\tfor (i = 0; i < depth; i++) {\n\t\tif (depth_mask & (1 << i))\n\t\t\tret += fprintf(fp, \"|\");\n\t\telse\n\t\t\tret += fprintf(fp, \" \");\n\t\tif (!period && i == depth - 1) {\n\t\t\tret += fprintf(fp, \"--\");\n\t\t\tret += callchain_node__fprintf_value(node, fp, total_samples);\n\t\t\tret += fprintf(fp, \"--\");\n\t\t} else\n\t\t\tret += fprintf(fp, \"%s\", \"          \");\n\t}\n\n\tstr = callchain_list__sym_name(chain, bf, sizeof(bf), false);\n\n\tif (symbol_conf.show_branchflag_count) {\n\t\tcallchain_list_counts__printf_value(chain, NULL,\n\t\t\t\t\t\t    buf, sizeof(buf));\n\n\t\tif (asprintf(&alloc_str, \"%s%s\", str, buf) < 0)\n\t\t\tstr = \"Not enough memory!\";\n\t\telse\n\t\t\tstr = alloc_str;\n\t}\n\n\tfputs(str, fp);\n\tfputc('\\n', fp);\n\tfree(alloc_str);\n\n\treturn ret;\n}\n\nstatic struct symbol *rem_sq_bracket;\nstatic struct callchain_list rem_hits;\n\nstatic void init_rem_hits(void)\n{\n\trem_sq_bracket = malloc(sizeof(*rem_sq_bracket) + 6);\n\tif (!rem_sq_bracket) {\n\t\tfprintf(stderr, \"Not enough memory to display remaining hits\\n\");\n\t\treturn;\n\t}\n\n\tstrcpy(rem_sq_bracket->name, \"[...]\");\n\trem_hits.ms.sym = rem_sq_bracket;\n}\n\nstatic size_t __callchain__fprintf_graph(FILE *fp, struct rb_root *root,\n\t\t\t\t\t u64 total_samples, int depth,\n\t\t\t\t\t int depth_mask, int left_margin)\n{\n\tstruct rb_node *node, *next;\n\tstruct callchain_node *child = NULL;\n\tstruct callchain_list *chain;\n\tint new_depth_mask = depth_mask;\n\tu64 remaining;\n\tsize_t ret = 0;\n\tint i;\n\tuint entries_printed = 0;\n\tint cumul_count = 0;\n\n\tremaining = total_samples;\n\n\tnode = rb_first(root);\n\twhile (node) {\n\t\tu64 new_total;\n\t\tu64 cumul;\n\n\t\tchild = rb_entry(node, struct callchain_node, rb_node);\n\t\tcumul = callchain_cumul_hits(child);\n\t\tremaining -= cumul;\n\t\tcumul_count += callchain_cumul_counts(child);\n\n\t\t \n\t\tnext = rb_next(node);\n\t\tif (!next && (callchain_param.mode != CHAIN_GRAPH_REL || !remaining))\n\t\t\tnew_depth_mask &= ~(1 << (depth - 1));\n\n\t\t \n\t\tret += ipchain__fprintf_graph_line(fp, depth, depth_mask,\n\t\t\t\t\t\t   left_margin);\n\t\ti = 0;\n\t\tlist_for_each_entry(chain, &child->val, list) {\n\t\t\tret += ipchain__fprintf_graph(fp, child, chain, depth,\n\t\t\t\t\t\t      new_depth_mask, i++,\n\t\t\t\t\t\t      total_samples,\n\t\t\t\t\t\t      left_margin);\n\t\t}\n\n\t\tif (callchain_param.mode == CHAIN_GRAPH_REL)\n\t\t\tnew_total = child->children_hit;\n\t\telse\n\t\t\tnew_total = total_samples;\n\n\t\tret += __callchain__fprintf_graph(fp, &child->rb_root, new_total,\n\t\t\t\t\t\t  depth + 1,\n\t\t\t\t\t\t  new_depth_mask | (1 << depth),\n\t\t\t\t\t\t  left_margin);\n\t\tnode = next;\n\t\tif (++entries_printed == callchain_param.print_limit)\n\t\t\tbreak;\n\t}\n\n\tif (callchain_param.mode == CHAIN_GRAPH_REL &&\n\t\tremaining && remaining != total_samples) {\n\t\tstruct callchain_node rem_node = {\n\t\t\t.hit = remaining,\n\t\t};\n\n\t\tif (!rem_sq_bracket)\n\t\t\treturn ret;\n\n\t\tif (callchain_param.value == CCVAL_COUNT && child && child->parent) {\n\t\t\trem_node.count = child->parent->children_count - cumul_count;\n\t\t\tif (rem_node.count <= 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tnew_depth_mask &= ~(1 << (depth - 1));\n\t\tret += ipchain__fprintf_graph(fp, &rem_node, &rem_hits, depth,\n\t\t\t\t\t      new_depth_mask, 0, total_samples,\n\t\t\t\t\t      left_margin);\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool need_percent_display(struct rb_node *node, u64 parent_samples)\n{\n\tstruct callchain_node *cnode;\n\n\tif (rb_next(node))\n\t\treturn true;\n\n\tcnode = rb_entry(node, struct callchain_node, rb_node);\n\treturn callchain_cumul_hits(cnode) != parent_samples;\n}\n\nstatic size_t callchain__fprintf_graph(FILE *fp, struct rb_root *root,\n\t\t\t\t       u64 total_samples, u64 parent_samples,\n\t\t\t\t       int left_margin)\n{\n\tstruct callchain_node *cnode;\n\tstruct callchain_list *chain;\n\tu32 entries_printed = 0;\n\tbool printed = false;\n\tstruct rb_node *node;\n\tint i = 0;\n\tint ret = 0;\n\tchar bf[1024];\n\n\tnode = rb_first(root);\n\tif (node && !need_percent_display(node, parent_samples)) {\n\t\tcnode = rb_entry(node, struct callchain_node, rb_node);\n\t\tlist_for_each_entry(chain, &cnode->val, list) {\n\t\t\t \n\t\t\tif (!i++ && field_order == NULL &&\n\t\t\t    sort_order && strstarts(sort_order, \"sym\"))\n\t\t\t\tcontinue;\n\n\t\t\tif (!printed) {\n\t\t\t\tret += callchain__fprintf_left_margin(fp, left_margin);\n\t\t\t\tret += fprintf(fp, \"|\\n\");\n\t\t\t\tret += callchain__fprintf_left_margin(fp, left_margin);\n\t\t\t\tret += fprintf(fp, \"---\");\n\t\t\t\tleft_margin += 3;\n\t\t\t\tprinted = true;\n\t\t\t} else\n\t\t\t\tret += callchain__fprintf_left_margin(fp, left_margin);\n\n\t\t\tret += fprintf(fp, \"%s\",\n\t\t\t\t       callchain_list__sym_name(chain, bf,\n\t\t\t\t\t\t\t\tsizeof(bf),\n\t\t\t\t\t\t\t\tfalse));\n\n\t\t\tif (symbol_conf.show_branchflag_count)\n\t\t\t\tret += callchain_list_counts__printf_value(\n\t\t\t\t\t\tchain, fp, NULL, 0);\n\t\t\tret += fprintf(fp, \"\\n\");\n\n\t\t\tif (++entries_printed == callchain_param.print_limit)\n\t\t\t\tbreak;\n\t\t}\n\t\troot = &cnode->rb_root;\n\t}\n\n\tif (callchain_param.mode == CHAIN_GRAPH_REL)\n\t\ttotal_samples = parent_samples;\n\n\tret += __callchain__fprintf_graph(fp, root, total_samples,\n\t\t\t\t\t  1, 1, left_margin);\n\tif (ret) {\n\t\t \n\t\tret += fprintf(fp, \"\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic size_t __callchain__fprintf_flat(FILE *fp, struct callchain_node *node,\n\t\t\t\t\tu64 total_samples)\n{\n\tstruct callchain_list *chain;\n\tsize_t ret = 0;\n\tchar bf[1024];\n\n\tif (!node)\n\t\treturn 0;\n\n\tret += __callchain__fprintf_flat(fp, node->parent, total_samples);\n\n\n\tlist_for_each_entry(chain, &node->val, list) {\n\t\tif (chain->ip >= PERF_CONTEXT_MAX)\n\t\t\tcontinue;\n\t\tret += fprintf(fp, \"                %s\\n\", callchain_list__sym_name(chain,\n\t\t\t\t\tbf, sizeof(bf), false));\n\t}\n\n\treturn ret;\n}\n\nstatic size_t callchain__fprintf_flat(FILE *fp, struct rb_root *tree,\n\t\t\t\t      u64 total_samples)\n{\n\tsize_t ret = 0;\n\tu32 entries_printed = 0;\n\tstruct callchain_node *chain;\n\tstruct rb_node *rb_node = rb_first(tree);\n\n\twhile (rb_node) {\n\t\tchain = rb_entry(rb_node, struct callchain_node, rb_node);\n\n\t\tret += fprintf(fp, \"           \");\n\t\tret += callchain_node__fprintf_value(chain, fp, total_samples);\n\t\tret += fprintf(fp, \"\\n\");\n\t\tret += __callchain__fprintf_flat(fp, chain, total_samples);\n\t\tret += fprintf(fp, \"\\n\");\n\t\tif (++entries_printed == callchain_param.print_limit)\n\t\t\tbreak;\n\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\treturn ret;\n}\n\nstatic size_t __callchain__fprintf_folded(FILE *fp, struct callchain_node *node)\n{\n\tconst char *sep = symbol_conf.field_sep ?: \";\";\n\tstruct callchain_list *chain;\n\tsize_t ret = 0;\n\tchar bf[1024];\n\tbool first;\n\n\tif (!node)\n\t\treturn 0;\n\n\tret += __callchain__fprintf_folded(fp, node->parent);\n\n\tfirst = (ret == 0);\n\tlist_for_each_entry(chain, &node->val, list) {\n\t\tif (chain->ip >= PERF_CONTEXT_MAX)\n\t\t\tcontinue;\n\t\tret += fprintf(fp, \"%s%s\", first ? \"\" : sep,\n\t\t\t       callchain_list__sym_name(chain,\n\t\t\t\t\t\tbf, sizeof(bf), false));\n\t\tfirst = false;\n\t}\n\n\treturn ret;\n}\n\nstatic size_t callchain__fprintf_folded(FILE *fp, struct rb_root *tree,\n\t\t\t\t\tu64 total_samples)\n{\n\tsize_t ret = 0;\n\tu32 entries_printed = 0;\n\tstruct callchain_node *chain;\n\tstruct rb_node *rb_node = rb_first(tree);\n\n\twhile (rb_node) {\n\n\t\tchain = rb_entry(rb_node, struct callchain_node, rb_node);\n\n\t\tret += callchain_node__fprintf_value(chain, fp, total_samples);\n\t\tret += fprintf(fp, \" \");\n\t\tret += __callchain__fprintf_folded(fp, chain);\n\t\tret += fprintf(fp, \"\\n\");\n\t\tif (++entries_printed == callchain_param.print_limit)\n\t\t\tbreak;\n\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\treturn ret;\n}\n\nstatic size_t hist_entry_callchain__fprintf(struct hist_entry *he,\n\t\t\t\t\t    u64 total_samples, int left_margin,\n\t\t\t\t\t    FILE *fp)\n{\n\tu64 parent_samples = he->stat.period;\n\n\tif (symbol_conf.cumulate_callchain)\n\t\tparent_samples = he->stat_acc->period;\n\n\tswitch (callchain_param.mode) {\n\tcase CHAIN_GRAPH_REL:\n\t\treturn callchain__fprintf_graph(fp, &he->sorted_chain, total_samples,\n\t\t\t\t\t\tparent_samples, left_margin);\n\t\tbreak;\n\tcase CHAIN_GRAPH_ABS:\n\t\treturn callchain__fprintf_graph(fp, &he->sorted_chain, total_samples,\n\t\t\t\t\t\tparent_samples, left_margin);\n\t\tbreak;\n\tcase CHAIN_FLAT:\n\t\treturn callchain__fprintf_flat(fp, &he->sorted_chain, total_samples);\n\t\tbreak;\n\tcase CHAIN_FOLDED:\n\t\treturn callchain__fprintf_folded(fp, &he->sorted_chain, total_samples);\n\t\tbreak;\n\tcase CHAIN_NONE:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Bad callchain mode\\n\");\n\t}\n\n\treturn 0;\n}\n\nint __hist_entry__snprintf(struct hist_entry *he, struct perf_hpp *hpp,\n\t\t\t   struct perf_hpp_list *hpp_list)\n{\n\tconst char *sep = symbol_conf.field_sep;\n\tstruct perf_hpp_fmt *fmt;\n\tchar *start = hpp->buf;\n\tint ret;\n\tbool first = true;\n\n\tif (symbol_conf.exclude_other && !he->parent)\n\t\treturn 0;\n\n\tperf_hpp_list__for_each_format(hpp_list, fmt) {\n\t\tif (perf_hpp__should_skip(fmt, he->hists))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!sep || !first) {\n\t\t\tret = scnprintf(hpp->buf, hpp->size, \"%s\", sep ?: \"  \");\n\t\t\tadvance_hpp(hpp, ret);\n\t\t} else\n\t\t\tfirst = false;\n\n\t\tif (perf_hpp__use_color() && fmt->color)\n\t\t\tret = fmt->color(fmt, hpp, he);\n\t\telse\n\t\t\tret = fmt->entry(fmt, hpp, he);\n\n\t\tret = hist_entry__snprintf_alignment(he, hpp, fmt, ret);\n\t\tadvance_hpp(hpp, ret);\n\t}\n\n\treturn hpp->buf - start;\n}\n\nstatic int hist_entry__snprintf(struct hist_entry *he, struct perf_hpp *hpp)\n{\n\treturn __hist_entry__snprintf(he, hpp, he->hists->hpp_list);\n}\n\nstatic int hist_entry__hierarchy_fprintf(struct hist_entry *he,\n\t\t\t\t\t struct perf_hpp *hpp,\n\t\t\t\t\t struct hists *hists,\n\t\t\t\t\t FILE *fp)\n{\n\tconst char *sep = symbol_conf.field_sep;\n\tstruct perf_hpp_fmt *fmt;\n\tstruct perf_hpp_list_node *fmt_node;\n\tchar *buf = hpp->buf;\n\tsize_t size = hpp->size;\n\tint ret, printed = 0;\n\tbool first = true;\n\n\tif (symbol_conf.exclude_other && !he->parent)\n\t\treturn 0;\n\n\tret = scnprintf(hpp->buf, hpp->size, \"%*s\", he->depth * HIERARCHY_INDENT, \"\");\n\tadvance_hpp(hpp, ret);\n\n\t \n\tfmt_node = list_first_entry(&hists->hpp_formats,\n\t\t\t\t    struct perf_hpp_list_node, list);\n\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\t \n\t\tif (!sep || !first) {\n\t\t\tret = scnprintf(hpp->buf, hpp->size, \"%s\", sep ?: \"  \");\n\t\t\tadvance_hpp(hpp, ret);\n\t\t} else\n\t\t\tfirst = false;\n\n\t\tif (perf_hpp__use_color() && fmt->color)\n\t\t\tret = fmt->color(fmt, hpp, he);\n\t\telse\n\t\t\tret = fmt->entry(fmt, hpp, he);\n\n\t\tret = hist_entry__snprintf_alignment(he, hpp, fmt, ret);\n\t\tadvance_hpp(hpp, ret);\n\t}\n\n\tif (!sep)\n\t\tret = scnprintf(hpp->buf, hpp->size, \"%*s\",\n\t\t\t\t(hists->nr_hpp_node - 2) * HIERARCHY_INDENT, \"\");\n\tadvance_hpp(hpp, ret);\n\n\tprinted += fprintf(fp, \"%s\", buf);\n\n\tperf_hpp_list__for_each_format(he->hpp_list, fmt) {\n\t\thpp->buf  = buf;\n\t\thpp->size = size;\n\n\t\t \n\t\tif (perf_hpp__use_color() && fmt->color)\n\t\t\tfmt->color(fmt, hpp, he);\n\t\telse\n\t\t\tfmt->entry(fmt, hpp, he);\n\n\t\t \n\t\tprinted += fprintf(fp, \"%s%s\", sep ?: \"  \", skip_spaces(buf));\n\t}\n\tprinted += putc('\\n', fp);\n\n\tif (he->leaf && hist_entry__has_callchains(he) && symbol_conf.use_callchain) {\n\t\tu64 total = hists__total_period(hists);\n\n\t\tprinted += hist_entry_callchain__fprintf(he, total, 0, fp);\n\t\tgoto out;\n\t}\n\nout:\n\treturn printed;\n}\n\nstatic int hist_entry__block_fprintf(struct hist_entry *he,\n\t\t\t\t     char *bf, size_t size,\n\t\t\t\t     FILE *fp)\n{\n\tstruct block_hist *bh = container_of(he, struct block_hist, he);\n\tint ret = 0;\n\n\tfor (unsigned int i = 0; i < bh->block_hists.nr_entries; i++) {\n\t\tstruct perf_hpp hpp = {\n\t\t\t.buf\t\t= bf,\n\t\t\t.size\t\t= size,\n\t\t\t.skip\t\t= false,\n\t\t};\n\n\t\tbh->block_idx = i;\n\t\thist_entry__snprintf(he, &hpp);\n\n\t\tif (!hpp.skip)\n\t\t\tret += fprintf(fp, \"%s\\n\", bf);\n\t}\n\n\treturn ret;\n}\n\nstatic int hist_entry__individual_block_fprintf(struct hist_entry *he,\n\t\t\t\t\t\tchar *bf, size_t size,\n\t\t\t\t\t\tFILE *fp)\n{\n\tint ret = 0;\n\n\tstruct perf_hpp hpp = {\n\t\t.buf\t\t= bf,\n\t\t.size\t\t= size,\n\t\t.skip\t\t= false,\n\t};\n\n\thist_entry__snprintf(he, &hpp);\n\tif (!hpp.skip)\n\t\tret += fprintf(fp, \"%s\\n\", bf);\n\n\treturn ret;\n}\n\nstatic int hist_entry__fprintf(struct hist_entry *he, size_t size,\n\t\t\t       char *bf, size_t bfsz, FILE *fp,\n\t\t\t       bool ignore_callchains)\n{\n\tint ret;\n\tint callchain_ret = 0;\n\tstruct perf_hpp hpp = {\n\t\t.buf\t\t= bf,\n\t\t.size\t\t= size,\n\t};\n\tstruct hists *hists = he->hists;\n\tu64 total_period = hists->stats.total_period;\n\n\tif (size == 0 || size > bfsz)\n\t\tsize = hpp.size = bfsz;\n\n\tif (symbol_conf.report_hierarchy)\n\t\treturn hist_entry__hierarchy_fprintf(he, &hpp, hists, fp);\n\n\tif (symbol_conf.report_block)\n\t\treturn hist_entry__block_fprintf(he, bf, size, fp);\n\n\tif (symbol_conf.report_individual_block)\n\t\treturn hist_entry__individual_block_fprintf(he, bf, size, fp);\n\n\thist_entry__snprintf(he, &hpp);\n\n\tret = fprintf(fp, \"%s\\n\", bf);\n\n\tif (hist_entry__has_callchains(he) && !ignore_callchains)\n\t\tcallchain_ret = hist_entry_callchain__fprintf(he, total_period,\n\t\t\t\t\t\t\t      0, fp);\n\n\tret += callchain_ret;\n\n\treturn ret;\n}\n\nstatic int print_hierarchy_indent(const char *sep, int indent,\n\t\t\t\t  const char *line, FILE *fp)\n{\n\tint width;\n\n\tif (sep != NULL || indent < 2)\n\t\treturn 0;\n\n\twidth = (indent - 2) * HIERARCHY_INDENT;\n\n\treturn fprintf(fp, \"%-*.*s\", width, width, line);\n}\n\nstatic int hists__fprintf_hierarchy_headers(struct hists *hists,\n\t\t\t\t\t    struct perf_hpp *hpp, FILE *fp)\n{\n\tbool first_node, first_col;\n\tint indent;\n\tint depth;\n\tunsigned width = 0;\n\tunsigned header_width = 0;\n\tstruct perf_hpp_fmt *fmt;\n\tstruct perf_hpp_list_node *fmt_node;\n\tconst char *sep = symbol_conf.field_sep;\n\n\tindent = hists->nr_hpp_node;\n\n\t \n\tprint_hierarchy_indent(sep, indent, \" \", fp);\n\n\t \n\tfmt_node = list_first_entry(&hists->hpp_formats,\n\t\t\t\t    struct perf_hpp_list_node, list);\n\n\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\tfmt->header(fmt, hpp, hists, 0, NULL);\n\t\tfprintf(fp, \"%s%s\", hpp->buf, sep ?: \"  \");\n\t}\n\n\t \n\tfirst_node = true;\n\tlist_for_each_entry_continue(fmt_node, &hists->hpp_formats, list) {\n\t\tif (!first_node)\n\t\t\theader_width += fprintf(fp, \" / \");\n\t\tfirst_node = false;\n\n\t\tfirst_col = true;\n\t\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\t\tif (perf_hpp__should_skip(fmt, hists))\n\t\t\t\tcontinue;\n\n\t\t\tif (!first_col)\n\t\t\t\theader_width += fprintf(fp, \"+\");\n\t\t\tfirst_col = false;\n\n\t\t\tfmt->header(fmt, hpp, hists, 0, NULL);\n\n\t\t\theader_width += fprintf(fp, \"%s\", strim(hpp->buf));\n\t\t}\n\t}\n\n\tfprintf(fp, \"\\n# \");\n\n\t \n\tprint_hierarchy_indent(sep, indent, dots, fp);\n\n\t \n\tfmt_node = list_first_entry(&hists->hpp_formats,\n\t\t\t\t    struct perf_hpp_list_node, list);\n\n\tfirst_col = true;\n\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\tif (!first_col)\n\t\t\tfprintf(fp, \"%s\", sep ?: \"..\");\n\t\tfirst_col = false;\n\n\t\twidth = fmt->width(fmt, hpp, hists);\n\t\tfprintf(fp, \"%.*s\", width, dots);\n\t}\n\n\tdepth = 0;\n\tlist_for_each_entry_continue(fmt_node, &hists->hpp_formats, list) {\n\t\tfirst_col = true;\n\t\twidth = depth * HIERARCHY_INDENT;\n\n\t\tperf_hpp_list__for_each_format(&fmt_node->hpp, fmt) {\n\t\t\tif (perf_hpp__should_skip(fmt, hists))\n\t\t\t\tcontinue;\n\n\t\t\tif (!first_col)\n\t\t\t\twidth++;   \n\t\t\tfirst_col = false;\n\n\t\t\twidth += fmt->width(fmt, hpp, hists);\n\t\t}\n\n\t\tif (width > header_width)\n\t\t\theader_width = width;\n\n\t\tdepth++;\n\t}\n\n\tfprintf(fp, \"%s%-.*s\", sep ?: \"  \", header_width, dots);\n\n\tfprintf(fp, \"\\n#\\n\");\n\n\treturn 2;\n}\n\nstatic void fprintf_line(struct hists *hists, struct perf_hpp *hpp,\n\t\t\t int line, FILE *fp)\n{\n\tstruct perf_hpp_fmt *fmt;\n\tconst char *sep = symbol_conf.field_sep;\n\tbool first = true;\n\tint span = 0;\n\n\thists__for_each_format(hists, fmt) {\n\t\tif (perf_hpp__should_skip(fmt, hists))\n\t\t\tcontinue;\n\n\t\tif (!first && !span)\n\t\t\tfprintf(fp, \"%s\", sep ?: \"  \");\n\t\telse\n\t\t\tfirst = false;\n\n\t\tfmt->header(fmt, hpp, hists, line, &span);\n\n\t\tif (!span)\n\t\t\tfprintf(fp, \"%s\", hpp->buf);\n\t}\n}\n\nstatic int\nhists__fprintf_standard_headers(struct hists *hists,\n\t\t\t\tstruct perf_hpp *hpp,\n\t\t\t\tFILE *fp)\n{\n\tstruct perf_hpp_list *hpp_list = hists->hpp_list;\n\tstruct perf_hpp_fmt *fmt;\n\tunsigned int width;\n\tconst char *sep = symbol_conf.field_sep;\n\tbool first = true;\n\tint line;\n\n\tfor (line = 0; line < hpp_list->nr_header_lines; line++) {\n\t\t \n\t\tif (line)\n\t\t\tfprintf(fp, \"# \");\n\t\tfprintf_line(hists, hpp, line, fp);\n\t\tfprintf(fp, \"\\n\");\n\t}\n\n\tif (sep)\n\t\treturn hpp_list->nr_header_lines;\n\n\tfirst = true;\n\n\tfprintf(fp, \"# \");\n\n\thists__for_each_format(hists, fmt) {\n\t\tunsigned int i;\n\n\t\tif (perf_hpp__should_skip(fmt, hists))\n\t\t\tcontinue;\n\n\t\tif (!first)\n\t\t\tfprintf(fp, \"%s\", sep ?: \"  \");\n\t\telse\n\t\t\tfirst = false;\n\n\t\twidth = fmt->width(fmt, hpp, hists);\n\t\tfor (i = 0; i < width; i++)\n\t\t\tfprintf(fp, \".\");\n\t}\n\n\tfprintf(fp, \"\\n\");\n\tfprintf(fp, \"#\\n\");\n\treturn hpp_list->nr_header_lines + 2;\n}\n\nint hists__fprintf_headers(struct hists *hists, FILE *fp)\n{\n\tchar bf[1024];\n\tstruct perf_hpp dummy_hpp = {\n\t\t.buf\t= bf,\n\t\t.size\t= sizeof(bf),\n\t};\n\n\tfprintf(fp, \"# \");\n\n\tif (symbol_conf.report_hierarchy)\n\t\treturn hists__fprintf_hierarchy_headers(hists, &dummy_hpp, fp);\n\telse\n\t\treturn hists__fprintf_standard_headers(hists, &dummy_hpp, fp);\n\n}\n\nsize_t hists__fprintf(struct hists *hists, bool show_header, int max_rows,\n\t\t      int max_cols, float min_pcnt, FILE *fp,\n\t\t      bool ignore_callchains)\n{\n\tstruct rb_node *nd;\n\tsize_t ret = 0;\n\tconst char *sep = symbol_conf.field_sep;\n\tint nr_rows = 0;\n\tsize_t linesz;\n\tchar *line = NULL;\n\tunsigned indent;\n\n\tinit_rem_hits();\n\n\thists__reset_column_width(hists);\n\n\tif (symbol_conf.col_width_list_str)\n\t\tperf_hpp__set_user_width(symbol_conf.col_width_list_str);\n\n\tif (show_header)\n\t\tnr_rows += hists__fprintf_headers(hists, fp);\n\n\tif (max_rows && nr_rows >= max_rows)\n\t\tgoto out;\n\n\tlinesz = hists__sort_list_width(hists) + 3 + 1;\n\tlinesz += perf_hpp__color_overhead();\n\tline = malloc(linesz);\n\tif (line == NULL) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tindent = hists__overhead_width(hists) + 4;\n\n\tfor (nd = rb_first_cached(&hists->entries); nd;\n\t     nd = __rb_hierarchy_next(nd, HMD_FORCE_CHILD)) {\n\t\tstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\n\t\tfloat percent;\n\n\t\tif (h->filtered)\n\t\t\tcontinue;\n\n\t\tif (symbol_conf.report_individual_block)\n\t\t\tpercent = block_info__total_cycles_percent(h);\n\t\telse\n\t\t\tpercent = hist_entry__get_percent_limit(h);\n\n\t\tif (percent < min_pcnt)\n\t\t\tcontinue;\n\n\t\tret += hist_entry__fprintf(h, max_cols, line, linesz, fp, ignore_callchains);\n\n\t\tif (max_rows && ++nr_rows >= max_rows)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!h->leaf && !hist_entry__has_hierarchy_children(h, min_pcnt)) {\n\t\t\tint depth = hists->nr_hpp_node + h->depth + 1;\n\n\t\t\tprint_hierarchy_indent(sep, depth, \" \", fp);\n\t\t\tfprintf(fp, \"%*sno entry >= %.2f%%\\n\", indent, \"\", min_pcnt);\n\n\t\t\tif (max_rows && ++nr_rows >= max_rows)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (h->ms.map == NULL && verbose > 1) {\n\t\t\tmaps__fprintf(thread__maps(h->thread), fp);\n\t\t\tfprintf(fp, \"%.10s end\\n\", graph_dotted_line);\n\t\t}\n\t}\n\n\tfree(line);\nout:\n\tzfree(&rem_sq_bracket);\n\n\treturn ret;\n}\n\nsize_t events_stats__fprintf(struct events_stats *stats, FILE *fp,\n\t\t\t     bool skip_empty)\n{\n\tint i;\n\tsize_t ret = 0;\n\tu32 total = stats->nr_events[0];\n\n\tfor (i = 0; i < PERF_RECORD_HEADER_MAX; ++i) {\n\t\tconst char *name;\n\n\t\tname = perf_event__name(i);\n\t\tif (!strcmp(name, \"UNKNOWN\"))\n\t\t\tcontinue;\n\t\tif (skip_empty && !stats->nr_events[i])\n\t\t\tcontinue;\n\n\t\tif (i && total) {\n\t\t\tret += fprintf(fp, \"%16s events: %10d  (%4.1f%%)\\n\",\n\t\t\t\t       name, stats->nr_events[i],\n\t\t\t\t       100.0 * stats->nr_events[i] / total);\n\t\t} else {\n\t\t\tret += fprintf(fp, \"%16s events: %10d\\n\",\n\t\t\t\t       name, stats->nr_events[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}