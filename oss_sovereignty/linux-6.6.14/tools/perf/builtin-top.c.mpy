{
  "module_name": "builtin-top.c",
  "hash_id": "b3a01d6397df1065c315b725f310d5e1113f158b1b290f4e2dbb0e2b411b9761",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-top.c",
  "human_readable_source": "\n \n#include \"builtin.h\"\n\n#include \"perf.h\"\n\n#include \"util/annotate.h\"\n#include \"util/bpf-event.h\"\n#include \"util/cgroup.h\"\n#include \"util/config.h\"\n#include \"util/color.h\"\n#include \"util/dso.h\"\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/evsel_config.h\"\n#include \"util/event.h\"\n#include \"util/machine.h\"\n#include \"util/map.h\"\n#include \"util/mmap.h\"\n#include \"util/session.h\"\n#include \"util/thread.h\"\n#include \"util/symbol.h\"\n#include \"util/synthetic-events.h\"\n#include \"util/top.h\"\n#include \"util/util.h\"\n#include <linux/rbtree.h>\n#include <subcmd/parse-options.h>\n#include \"util/parse-events.h\"\n#include \"util/callchain.h\"\n#include \"util/cpumap.h\"\n#include \"util/sort.h\"\n#include \"util/string2.h\"\n#include \"util/term.h\"\n#include \"util/intlist.h\"\n#include \"util/parse-branch-options.h\"\n#include \"arch/common.h\"\n#include \"ui/ui.h\"\n\n#include \"util/debug.h\"\n#include \"util/ordered-events.h\"\n#include \"util/pfm.h\"\n\n#include <assert.h>\n#include <elf.h>\n#include <fcntl.h>\n\n#include <stdio.h>\n#include <termios.h>\n#include <unistd.h>\n#include <inttypes.h>\n\n#include <errno.h>\n#include <time.h>\n#include <sched.h>\n#include <signal.h>\n\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <poll.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <sys/uio.h>\n#include <sys/utsname.h>\n#include <sys/mman.h>\n\n#include <linux/stringify.h>\n#include <linux/time64.h>\n#include <linux/types.h>\n#include <linux/err.h>\n\n#include <linux/ctype.h>\n#include <perf/mmap.h>\n\nstatic volatile sig_atomic_t done;\nstatic volatile sig_atomic_t resize;\n\n#define HEADER_LINE_NR  5\n\nstatic void perf_top__update_print_entries(struct perf_top *top)\n{\n\ttop->print_entries = top->winsize.ws_row - HEADER_LINE_NR;\n}\n\nstatic void winch_sig(int sig __maybe_unused)\n{\n\tresize = 1;\n}\n\nstatic void perf_top__resize(struct perf_top *top)\n{\n\tget_term_dimensions(&top->winsize);\n\tperf_top__update_print_entries(top);\n}\n\nstatic int perf_top__parse_source(struct perf_top *top, struct hist_entry *he)\n{\n\tstruct evsel *evsel;\n\tstruct symbol *sym;\n\tstruct annotation *notes;\n\tstruct map *map;\n\tstruct dso *dso;\n\tint err = -1;\n\n\tif (!he || !he->ms.sym)\n\t\treturn -1;\n\n\tevsel = hists_to_evsel(he->hists);\n\n\tsym = he->ms.sym;\n\tmap = he->ms.map;\n\tdso = map__dso(map);\n\n\t \n\tif (dso->symtab_type == DSO_BINARY_TYPE__KALLSYMS && !dso__is_kcore(dso)) {\n\t\tpr_err(\"Can't annotate %s: No vmlinux file was found in the \"\n\t\t       \"path\\n\", sym->name);\n\t\tsleep(1);\n\t\treturn -1;\n\t}\n\n\tnotes = symbol__annotation(sym);\n\tannotation__lock(notes);\n\n\tif (!symbol__hists(sym, top->evlist->core.nr_entries)) {\n\t\tannotation__unlock(notes);\n\t\tpr_err(\"Not enough memory for annotating '%s' symbol!\\n\",\n\t\t       sym->name);\n\t\tsleep(1);\n\t\treturn err;\n\t}\n\n\terr = symbol__annotate(&he->ms, evsel, &top->annotation_opts, NULL);\n\tif (err == 0) {\n\t\ttop->sym_filter_entry = he;\n\t} else {\n\t\tchar msg[BUFSIZ];\n\t\tsymbol__strerror_disassemble(&he->ms, err, msg, sizeof(msg));\n\t\tpr_err(\"Couldn't annotate %s: %s\\n\", sym->name, msg);\n\t}\n\n\tannotation__unlock(notes);\n\treturn err;\n}\n\nstatic void __zero_source_counters(struct hist_entry *he)\n{\n\tstruct symbol *sym = he->ms.sym;\n\tsymbol__annotate_zero_histograms(sym);\n}\n\nstatic void ui__warn_map_erange(struct map *map, struct symbol *sym, u64 ip)\n{\n\tstruct utsname uts;\n\tint err = uname(&uts);\n\tstruct dso *dso = map__dso(map);\n\n\tui__warning(\"Out of bounds address found:\\n\\n\"\n\t\t    \"Addr:   %\" PRIx64 \"\\n\"\n\t\t    \"DSO:    %s %c\\n\"\n\t\t    \"Map:    %\" PRIx64 \"-%\" PRIx64 \"\\n\"\n\t\t    \"Symbol: %\" PRIx64 \"-%\" PRIx64 \" %c %s\\n\"\n\t\t    \"Arch:   %s\\n\"\n\t\t    \"Kernel: %s\\n\"\n\t\t    \"Tools:  %s\\n\\n\"\n\t\t    \"Not all samples will be on the annotation output.\\n\\n\"\n\t\t    \"Please report to linux-kernel@vger.kernel.org\\n\",\n\t\t    ip, dso->long_name, dso__symtab_origin(dso),\n\t\t    map__start(map), map__end(map), sym->start, sym->end,\n\t\t    sym->binding == STB_GLOBAL ? 'g' :\n\t\t    sym->binding == STB_LOCAL  ? 'l' : 'w', sym->name,\n\t\t    err ? \"[unknown]\" : uts.machine,\n\t\t    err ? \"[unknown]\" : uts.release, perf_version_string);\n\tif (use_browser <= 0)\n\t\tsleep(5);\n\n\tmap__set_erange_warned(map, true);\n}\n\nstatic void perf_top__record_precise_ip(struct perf_top *top,\n\t\t\t\t\tstruct hist_entry *he,\n\t\t\t\t\tstruct perf_sample *sample,\n\t\t\t\t\tstruct evsel *evsel, u64 ip)\n\tEXCLUSIVE_LOCKS_REQUIRED(he->hists->lock)\n{\n\tstruct annotation *notes;\n\tstruct symbol *sym = he->ms.sym;\n\tint err = 0;\n\n\tif (sym == NULL || (use_browser == 0 &&\n\t\t\t    (top->sym_filter_entry == NULL ||\n\t\t\t     top->sym_filter_entry->ms.sym != sym)))\n\t\treturn;\n\n\tnotes = symbol__annotation(sym);\n\n\tif (!annotation__trylock(notes))\n\t\treturn;\n\n\terr = hist_entry__inc_addr_samples(he, sample, evsel, ip);\n\n\tannotation__unlock(notes);\n\n\tif (unlikely(err)) {\n\t\t \n\t\tmutex_unlock(&he->hists->lock);\n\n\t\tif (err == -ERANGE && !map__erange_warned(he->ms.map))\n\t\t\tui__warn_map_erange(he->ms.map, sym, ip);\n\t\telse if (err == -ENOMEM) {\n\t\t\tpr_err(\"Not enough memory for annotating '%s' symbol!\\n\",\n\t\t\t       sym->name);\n\t\t\tsleep(1);\n\t\t}\n\n\t\tmutex_lock(&he->hists->lock);\n\t}\n}\n\nstatic void perf_top__show_details(struct perf_top *top)\n{\n\tstruct hist_entry *he = top->sym_filter_entry;\n\tstruct evsel *evsel;\n\tstruct annotation *notes;\n\tstruct symbol *symbol;\n\tint more;\n\n\tif (!he)\n\t\treturn;\n\n\tevsel = hists_to_evsel(he->hists);\n\n\tsymbol = he->ms.sym;\n\tnotes = symbol__annotation(symbol);\n\n\tannotation__lock(notes);\n\n\tsymbol__calc_percent(symbol, evsel);\n\n\tif (notes->src == NULL)\n\t\tgoto out_unlock;\n\n\tprintf(\"Showing %s for %s\\n\", evsel__name(top->sym_evsel), symbol->name);\n\tprintf(\"  Events  Pcnt (>=%d%%)\\n\", top->annotation_opts.min_pcnt);\n\n\tmore = symbol__annotate_printf(&he->ms, top->sym_evsel, &top->annotation_opts);\n\n\tif (top->evlist->enabled) {\n\t\tif (top->zero)\n\t\t\tsymbol__annotate_zero_histogram(symbol, top->sym_evsel->core.idx);\n\t\telse\n\t\t\tsymbol__annotate_decay_histogram(symbol, top->sym_evsel->core.idx);\n\t}\n\tif (more != 0)\n\t\tprintf(\"%d lines not displayed, maybe increase display entries [e]\\n\", more);\nout_unlock:\n\tannotation__unlock(notes);\n}\n\nstatic void perf_top__resort_hists(struct perf_top *t)\n{\n\tstruct evlist *evlist = t->evlist;\n\tstruct evsel *pos;\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\n\t\t \n\t\thists__unlink(hists);\n\n\t\tif (evlist->enabled) {\n\t\t\tif (t->zero) {\n\t\t\t\thists__delete_entries(hists);\n\t\t\t} else {\n\t\t\t\thists__decay_entries(hists, t->hide_user_symbols,\n\t\t\t\t\t\t     t->hide_kernel_symbols);\n\t\t\t}\n\t\t}\n\n\t\thists__collapse_resort(hists, NULL);\n\n\t\t \n\t\tif (symbol_conf.event_group && !evsel__is_group_leader(pos)) {\n\t\t\tstruct hists *leader_hists = evsel__hists(evsel__leader(pos));\n\n\t\t\thists__match(leader_hists, hists);\n\t\t\thists__link(leader_hists, hists);\n\t\t}\n\t}\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tevsel__output_resort(pos, NULL);\n\t}\n}\n\nstatic void perf_top__print_sym_table(struct perf_top *top)\n{\n\tchar bf[160];\n\tint printed = 0;\n\tconst int win_width = top->winsize.ws_col - 1;\n\tstruct evsel *evsel = top->sym_evsel;\n\tstruct hists *hists = evsel__hists(evsel);\n\n\tputs(CONSOLE_CLEAR);\n\n\tperf_top__header_snprintf(top, bf, sizeof(bf));\n\tprintf(\"%s\\n\", bf);\n\n\tprintf(\"%-*.*s\\n\", win_width, win_width, graph_dotted_line);\n\n\tif (!top->record_opts.overwrite &&\n\t    (top->evlist->stats.nr_lost_warned !=\n\t     top->evlist->stats.nr_events[PERF_RECORD_LOST])) {\n\t\ttop->evlist->stats.nr_lost_warned =\n\t\t\t      top->evlist->stats.nr_events[PERF_RECORD_LOST];\n\t\tcolor_fprintf(stdout, PERF_COLOR_RED,\n\t\t\t      \"WARNING: LOST %d chunks, Check IO/CPU overload\",\n\t\t\t      top->evlist->stats.nr_lost_warned);\n\t\t++printed;\n\t}\n\n\tif (top->sym_filter_entry) {\n\t\tperf_top__show_details(top);\n\t\treturn;\n\t}\n\n\tperf_top__resort_hists(top);\n\n\thists__output_recalc_col_len(hists, top->print_entries - printed);\n\tputchar('\\n');\n\thists__fprintf(hists, false, top->print_entries - printed, win_width,\n\t\t       top->min_percent, stdout, !symbol_conf.use_callchain);\n}\n\nstatic void prompt_integer(int *target, const char *msg)\n{\n\tchar *buf = malloc(0), *p;\n\tsize_t dummy = 0;\n\tint tmp;\n\n\tfprintf(stdout, \"\\n%s: \", msg);\n\tif (getline(&buf, &dummy, stdin) < 0)\n\t\treturn;\n\n\tp = strchr(buf, '\\n');\n\tif (p)\n\t\t*p = 0;\n\n\tp = buf;\n\twhile(*p) {\n\t\tif (!isdigit(*p))\n\t\t\tgoto out_free;\n\t\tp++;\n\t}\n\ttmp = strtoul(buf, NULL, 10);\n\t*target = tmp;\nout_free:\n\tfree(buf);\n}\n\nstatic void prompt_percent(int *target, const char *msg)\n{\n\tint tmp = 0;\n\n\tprompt_integer(&tmp, msg);\n\tif (tmp >= 0 && tmp <= 100)\n\t\t*target = tmp;\n}\n\nstatic void perf_top__prompt_symbol(struct perf_top *top, const char *msg)\n{\n\tchar *buf = NULL, *p;\n\tstruct hist_entry *syme = top->sym_filter_entry, *n, *found = NULL;\n\tstruct hists *hists = evsel__hists(top->sym_evsel);\n\tstruct rb_node *next;\n\tsize_t dummy = 0;\n\n\t \n\tif (syme) {\n\t\t__zero_source_counters(syme);\n\t\ttop->sym_filter_entry = NULL;\n\t}\n\n\tfprintf(stdout, \"\\n%s: \", msg);\n\tif (getline(&buf, &dummy, stdin) < 0)\n\t\tgoto out_free;\n\n\tp = strchr(buf, '\\n');\n\tif (p)\n\t\t*p = 0;\n\n\tnext = rb_first_cached(&hists->entries);\n\twhile (next) {\n\t\tn = rb_entry(next, struct hist_entry, rb_node);\n\t\tif (n->ms.sym && !strcmp(buf, n->ms.sym->name)) {\n\t\t\tfound = n;\n\t\t\tbreak;\n\t\t}\n\t\tnext = rb_next(&n->rb_node);\n\t}\n\n\tif (!found) {\n\t\tfprintf(stderr, \"Sorry, %s is not active.\\n\", buf);\n\t\tsleep(1);\n\t} else\n\t\tperf_top__parse_source(top, found);\n\nout_free:\n\tfree(buf);\n}\n\nstatic void perf_top__print_mapped_keys(struct perf_top *top)\n{\n\tchar *name = NULL;\n\n\tif (top->sym_filter_entry) {\n\t\tstruct symbol *sym = top->sym_filter_entry->ms.sym;\n\t\tname = sym->name;\n\t}\n\n\tfprintf(stdout, \"\\nMapped keys:\\n\");\n\tfprintf(stdout, \"\\t[d]     display refresh delay.             \\t(%d)\\n\", top->delay_secs);\n\tfprintf(stdout, \"\\t[e]     display entries (lines).           \\t(%d)\\n\", top->print_entries);\n\n\tif (top->evlist->core.nr_entries > 1)\n\t\tfprintf(stdout, \"\\t[E]     active event counter.              \\t(%s)\\n\", evsel__name(top->sym_evsel));\n\n\tfprintf(stdout, \"\\t[f]     profile display filter (count).    \\t(%d)\\n\", top->count_filter);\n\n\tfprintf(stdout, \"\\t[F]     annotate display filter (percent). \\t(%d%%)\\n\", top->annotation_opts.min_pcnt);\n\tfprintf(stdout, \"\\t[s]     annotate symbol.                   \\t(%s)\\n\", name?: \"NULL\");\n\tfprintf(stdout, \"\\t[S]     stop annotation.\\n\");\n\n\tfprintf(stdout,\n\t\t\"\\t[K]     hide kernel symbols.             \\t(%s)\\n\",\n\t\ttop->hide_kernel_symbols ? \"yes\" : \"no\");\n\tfprintf(stdout,\n\t\t\"\\t[U]     hide user symbols.               \\t(%s)\\n\",\n\t\ttop->hide_user_symbols ? \"yes\" : \"no\");\n\tfprintf(stdout, \"\\t[z]     toggle sample zeroing.             \\t(%d)\\n\", top->zero ? 1 : 0);\n\tfprintf(stdout, \"\\t[qQ]    quit.\\n\");\n}\n\nstatic int perf_top__key_mapped(struct perf_top *top, int c)\n{\n\tswitch (c) {\n\t\tcase 'd':\n\t\tcase 'e':\n\t\tcase 'f':\n\t\tcase 'z':\n\t\tcase 'q':\n\t\tcase 'Q':\n\t\tcase 'K':\n\t\tcase 'U':\n\t\tcase 'F':\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\treturn 1;\n\t\tcase 'E':\n\t\t\treturn top->evlist->core.nr_entries > 1 ? 1 : 0;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic bool perf_top__handle_keypress(struct perf_top *top, int c)\n{\n\tbool ret = true;\n\n\tif (!perf_top__key_mapped(top, c)) {\n\t\tstruct pollfd stdin_poll = { .fd = 0, .events = POLLIN };\n\t\tstruct termios save;\n\n\t\tperf_top__print_mapped_keys(top);\n\t\tfprintf(stdout, \"\\nEnter selection, or unmapped key to continue: \");\n\t\tfflush(stdout);\n\n\t\tset_term_quiet_input(&save);\n\n\t\tpoll(&stdin_poll, 1, -1);\n\t\tc = getc(stdin);\n\n\t\ttcsetattr(0, TCSAFLUSH, &save);\n\t\tif (!perf_top__key_mapped(top, c))\n\t\t\treturn ret;\n\t}\n\n\tswitch (c) {\n\t\tcase 'd':\n\t\t\tprompt_integer(&top->delay_secs, \"Enter display delay\");\n\t\t\tif (top->delay_secs < 1)\n\t\t\t\ttop->delay_secs = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tprompt_integer(&top->print_entries, \"Enter display entries (lines)\");\n\t\t\tif (top->print_entries == 0) {\n\t\t\t\tperf_top__resize(top);\n\t\t\t\tsignal(SIGWINCH, winch_sig);\n\t\t\t} else {\n\t\t\t\tsignal(SIGWINCH, SIG_DFL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tif (top->evlist->core.nr_entries > 1) {\n\t\t\t\t \n\t\t\t\tint counter = 0;\n\n\t\t\t\tfprintf(stderr, \"\\nAvailable events:\");\n\n\t\t\t\tevlist__for_each_entry(top->evlist, top->sym_evsel)\n\t\t\t\t\tfprintf(stderr, \"\\n\\t%d %s\", top->sym_evsel->core.idx, evsel__name(top->sym_evsel));\n\n\t\t\t\tprompt_integer(&counter, \"Enter details event counter\");\n\n\t\t\t\tif (counter >= top->evlist->core.nr_entries) {\n\t\t\t\t\ttop->sym_evsel = evlist__first(top->evlist);\n\t\t\t\t\tfprintf(stderr, \"Sorry, no such event, using %s.\\n\", evsel__name(top->sym_evsel));\n\t\t\t\t\tsleep(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tevlist__for_each_entry(top->evlist, top->sym_evsel)\n\t\t\t\t\tif (top->sym_evsel->core.idx == counter)\n\t\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\ttop->sym_evsel = evlist__first(top->evlist);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tprompt_integer(&top->count_filter, \"Enter display event count filter\");\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tprompt_percent(&top->annotation_opts.min_pcnt,\n\t\t\t\t       \"Enter details display event filter (percent)\");\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\ttop->hide_kernel_symbols = !top->hide_kernel_symbols;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\tcase 'Q':\n\t\t\tprintf(\"exiting.\\n\");\n\t\t\tif (top->dump_symtab)\n\t\t\t\tperf_session__fprintf_dsos(top->session, stderr);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tperf_top__prompt_symbol(top, \"Enter details symbol\");\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (!top->sym_filter_entry)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tstruct hist_entry *syme = top->sym_filter_entry;\n\n\t\t\t\ttop->sym_filter_entry = NULL;\n\t\t\t\t__zero_source_counters(syme);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\ttop->hide_user_symbols = !top->hide_user_symbols;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttop->zero = !top->zero;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void perf_top__sort_new_samples(void *arg)\n{\n\tstruct perf_top *t = arg;\n\n\tif (t->evlist->selected != NULL)\n\t\tt->sym_evsel = t->evlist->selected;\n\n\tperf_top__resort_hists(t);\n\n\tif (t->lost || t->drop)\n\t\tpr_warning(\"Too slow to read ring buffer (change period (-c/-F) or limit CPUs (-C)\\n\");\n}\n\nstatic void stop_top(void)\n{\n\tsession_done = 1;\n\tdone = 1;\n}\n\nstatic void *display_thread_tui(void *arg)\n{\n\tstruct evsel *pos;\n\tstruct perf_top *top = arg;\n\tconst char *help = \"For a higher level overview, try: perf top --sort comm,dso\";\n\tstruct hist_browser_timer hbt = {\n\t\t.timer\t\t= perf_top__sort_new_samples,\n\t\t.arg\t\t= top,\n\t\t.refresh\t= top->delay_secs,\n\t};\n\tint ret;\n\n\t \n\tunshare(CLONE_FS);\n\n\tprctl(PR_SET_NAME, \"perf-top-UI\", 0, 0, 0);\n\nrepeat:\n\tperf_top__sort_new_samples(top);\n\n\t \n\tevlist__for_each_entry(top->evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\t\thists->uid_filter_str = top->record_opts.target.uid_str;\n\t}\n\n\tret = evlist__tui_browse_hists(top->evlist, help, &hbt, top->min_percent,\n\t\t\t\t       &top->session->header.env, !top->record_opts.overwrite,\n\t\t\t\t       &top->annotation_opts);\n\tif (ret == K_RELOAD) {\n\t\ttop->zero = true;\n\t\tgoto repeat;\n\t} else\n\t\tstop_top();\n\n\treturn NULL;\n}\n\nstatic void display_sig(int sig __maybe_unused)\n{\n\tstop_top();\n}\n\nstatic void display_setup_sig(void)\n{\n\tsignal(SIGSEGV, sighandler_dump_stack);\n\tsignal(SIGFPE, sighandler_dump_stack);\n\tsignal(SIGINT,  display_sig);\n\tsignal(SIGQUIT, display_sig);\n\tsignal(SIGTERM, display_sig);\n}\n\nstatic void *display_thread(void *arg)\n{\n\tstruct pollfd stdin_poll = { .fd = 0, .events = POLLIN };\n\tstruct termios save;\n\tstruct perf_top *top = arg;\n\tint delay_msecs, c;\n\n\t \n\tunshare(CLONE_FS);\n\n\tprctl(PR_SET_NAME, \"perf-top-UI\", 0, 0, 0);\n\n\tdisplay_setup_sig();\n\tpthread__unblock_sigwinch();\nrepeat:\n\tdelay_msecs = top->delay_secs * MSEC_PER_SEC;\n\tset_term_quiet_input(&save);\n\t \n\tclearerr(stdin);\n\tif (poll(&stdin_poll, 1, 0) > 0)\n\t\tgetc(stdin);\n\n\twhile (!done) {\n\t\tperf_top__print_sym_table(top);\n\t\t \n\t\tswitch (poll(&stdin_poll, 1, delay_msecs)) {\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tc = getc(stdin);\n\t\t\ttcsetattr(0, TCSAFLUSH, &save);\n\n\t\t\tif (perf_top__handle_keypress(top, c))\n\t\t\t\tgoto repeat;\n\t\t\tstop_top();\n\t\t}\n\t}\n\n\ttcsetattr(0, TCSAFLUSH, &save);\n\treturn NULL;\n}\n\nstatic int hist_iter__top_callback(struct hist_entry_iter *iter,\n\t\t\t\t   struct addr_location *al, bool single,\n\t\t\t\t   void *arg)\n\tEXCLUSIVE_LOCKS_REQUIRED(iter->he->hists->lock)\n{\n\tstruct perf_top *top = arg;\n\tstruct evsel *evsel = iter->evsel;\n\n\tif (perf_hpp_list.sym && single)\n\t\tperf_top__record_precise_ip(top, iter->he, iter->sample, evsel, al->addr);\n\n\thist__account_cycles(iter->sample->branch_stack, al, iter->sample,\n\t\t     !(top->record_opts.branch_stack & PERF_SAMPLE_BRANCH_ANY),\n\t\t     NULL);\n\treturn 0;\n}\n\nstatic void perf_event__process_sample(struct perf_tool *tool,\n\t\t\t\t       const union perf_event *event,\n\t\t\t\t       struct evsel *evsel,\n\t\t\t\t       struct perf_sample *sample,\n\t\t\t\t       struct machine *machine)\n{\n\tstruct perf_top *top = container_of(tool, struct perf_top, tool);\n\tstruct addr_location al;\n\n\tif (!machine && perf_guest) {\n\t\tstatic struct intlist *seen;\n\n\t\tif (!seen)\n\t\t\tseen = intlist__new(NULL);\n\n\t\tif (!intlist__has_entry(seen, sample->pid)) {\n\t\t\tpr_err(\"Can't find guest [%d]'s kernel information\\n\",\n\t\t\t\tsample->pid);\n\t\t\tintlist__add(seen, sample->pid);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!machine) {\n\t\tpr_err(\"%u unprocessable samples recorded.\\r\",\n\t\t       top->session->evlist->stats.nr_unprocessable_samples++);\n\t\treturn;\n\t}\n\n\tif (event->header.misc & PERF_RECORD_MISC_EXACT_IP)\n\t\ttop->exact_samples++;\n\n\taddr_location__init(&al);\n\tif (machine__resolve(machine, &al, sample) < 0)\n\t\tgoto out;\n\n\tif (top->stitch_lbr)\n\t\tthread__set_lbr_stitch_enable(al.thread, true);\n\n\tif (!machine->kptr_restrict_warned &&\n\t    symbol_conf.kptr_restrict &&\n\t    al.cpumode == PERF_RECORD_MISC_KERNEL) {\n\t\tif (!evlist__exclude_kernel(top->session->evlist)) {\n\t\t\tui__warning(\n\"Kernel address maps (/proc/{kallsyms,modules}) are restricted.\\n\\n\"\n\"Check /proc/sys/kernel/kptr_restrict and /proc/sys/kernel/perf_event_paranoid.\\n\\n\"\n\"Kernel%s samples will not be resolved.\\n\",\n\t\t\t  al.map && map__has_symbols(al.map) ?\n\t\t\t  \" modules\" : \"\");\n\t\t\tif (use_browser <= 0)\n\t\t\t\tsleep(5);\n\t\t}\n\t\tmachine->kptr_restrict_warned = true;\n\t}\n\n\tif (al.sym == NULL && al.map != NULL) {\n\t\tconst char *msg = \"Kernel samples will not be resolved.\\n\";\n\t\t \n\t\tif (!machine->kptr_restrict_warned && !top->vmlinux_warned &&\n\t\t    __map__is_kernel(al.map) && map__has_symbols(al.map)) {\n\t\t\tif (symbol_conf.vmlinux_name) {\n\t\t\t\tchar serr[256];\n\n\t\t\t\tdso__strerror_load(map__dso(al.map), serr, sizeof(serr));\n\t\t\t\tui__warning(\"The %s file can't be used: %s\\n%s\",\n\t\t\t\t\t    symbol_conf.vmlinux_name, serr, msg);\n\t\t\t} else {\n\t\t\t\tui__warning(\"A vmlinux file was not found.\\n%s\",\n\t\t\t\t\t    msg);\n\t\t\t}\n\n\t\t\tif (use_browser <= 0)\n\t\t\t\tsleep(5);\n\t\t\ttop->vmlinux_warned = true;\n\t\t}\n\t}\n\n\tif (al.sym == NULL || !al.sym->idle) {\n\t\tstruct hists *hists = evsel__hists(evsel);\n\t\tstruct hist_entry_iter iter = {\n\t\t\t.evsel\t\t= evsel,\n\t\t\t.sample \t= sample,\n\t\t\t.add_entry_cb \t= hist_iter__top_callback,\n\t\t};\n\n\t\tif (symbol_conf.cumulate_callchain)\n\t\t\titer.ops = &hist_iter_cumulative;\n\t\telse\n\t\t\titer.ops = &hist_iter_normal;\n\n\t\tmutex_lock(&hists->lock);\n\n\t\tif (hist_entry_iter__add(&iter, &al, top->max_stack, top) < 0)\n\t\t\tpr_err(\"Problem incrementing symbol period, skipping event\\n\");\n\n\t\tmutex_unlock(&hists->lock);\n\t}\n\nout:\n\taddr_location__exit(&al);\n}\n\nstatic void\nperf_top__process_lost(struct perf_top *top, union perf_event *event,\n\t\t       struct evsel *evsel)\n{\n\ttop->lost += event->lost.lost;\n\ttop->lost_total += event->lost.lost;\n\tevsel->evlist->stats.total_lost += event->lost.lost;\n}\n\nstatic void\nperf_top__process_lost_samples(struct perf_top *top,\n\t\t\t       union perf_event *event,\n\t\t\t       struct evsel *evsel)\n{\n\ttop->lost += event->lost_samples.lost;\n\ttop->lost_total += event->lost_samples.lost;\n\tevsel->evlist->stats.total_lost_samples += event->lost_samples.lost;\n}\n\nstatic u64 last_timestamp;\n\nstatic void perf_top__mmap_read_idx(struct perf_top *top, int idx)\n{\n\tstruct record_opts *opts = &top->record_opts;\n\tstruct evlist *evlist = top->evlist;\n\tstruct mmap *md;\n\tunion perf_event *event;\n\n\tmd = opts->overwrite ? &evlist->overwrite_mmap[idx] : &evlist->mmap[idx];\n\tif (perf_mmap__read_init(&md->core) < 0)\n\t\treturn;\n\n\twhile ((event = perf_mmap__read_event(&md->core)) != NULL) {\n\t\tint ret;\n\n\t\tret = evlist__parse_sample_timestamp(evlist, event, &last_timestamp);\n\t\tif (ret && ret != -1)\n\t\t\tbreak;\n\n\t\tret = ordered_events__queue(top->qe.in, event, last_timestamp, 0, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tperf_mmap__consume(&md->core);\n\n\t\tif (top->qe.rotate) {\n\t\t\tmutex_lock(&top->qe.mutex);\n\t\t\ttop->qe.rotate = false;\n\t\t\tcond_signal(&top->qe.cond);\n\t\t\tmutex_unlock(&top->qe.mutex);\n\t\t}\n\t}\n\n\tperf_mmap__read_done(&md->core);\n}\n\nstatic void perf_top__mmap_read(struct perf_top *top)\n{\n\tbool overwrite = top->record_opts.overwrite;\n\tstruct evlist *evlist = top->evlist;\n\tint i;\n\n\tif (overwrite)\n\t\tevlist__toggle_bkw_mmap(evlist, BKW_MMAP_DATA_PENDING);\n\n\tfor (i = 0; i < top->evlist->core.nr_mmaps; i++)\n\t\tperf_top__mmap_read_idx(top, i);\n\n\tif (overwrite) {\n\t\tevlist__toggle_bkw_mmap(evlist, BKW_MMAP_EMPTY);\n\t\tevlist__toggle_bkw_mmap(evlist, BKW_MMAP_RUNNING);\n\t}\n}\n\n \nstatic int perf_top__overwrite_check(struct perf_top *top)\n{\n\tstruct record_opts *opts = &top->record_opts;\n\tstruct evlist *evlist = top->evlist;\n\tstruct evsel_config_term *term;\n\tstruct list_head *config_terms;\n\tstruct evsel *evsel;\n\tint set, overwrite = -1;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tset = -1;\n\t\tconfig_terms = &evsel->config_terms;\n\t\tlist_for_each_entry(term, config_terms, list) {\n\t\t\tif (term->type == EVSEL__CONFIG_TERM_OVERWRITE)\n\t\t\t\tset = term->val.overwrite ? 1 : 0;\n\t\t}\n\n\t\t \n\t\tif ((overwrite < 0) && (set < 0))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((overwrite >= 0) && (set >= 0) && (overwrite != set))\n\t\t\treturn -1;\n\n\t\t \n\t\tif ((overwrite >= 0) && (set < 0))\n\t\t\treturn -1;\n\n\t\t \n\t\tif ((overwrite < 0) && (set >= 0)) {\n\t\t\t \n\t\t\tif (evsel == evlist__first(evlist))\n\t\t\t\toverwrite = set;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((overwrite >= 0) && (opts->overwrite != overwrite))\n\t\topts->overwrite = overwrite;\n\n\treturn 0;\n}\n\nstatic int perf_top_overwrite_fallback(struct perf_top *top,\n\t\t\t\t       struct evsel *evsel)\n{\n\tstruct record_opts *opts = &top->record_opts;\n\tstruct evlist *evlist = top->evlist;\n\tstruct evsel *counter;\n\n\tif (!opts->overwrite)\n\t\treturn 0;\n\n\t \n\tif (evsel != evlist__first(evlist))\n\t\treturn 0;\n\n\tevlist__for_each_entry(evlist, counter)\n\t\tcounter->core.attr.write_backward = false;\n\topts->overwrite = false;\n\tpr_debug2(\"fall back to non-overwrite mode\\n\");\n\treturn 1;\n}\n\nstatic int perf_top__start_counters(struct perf_top *top)\n{\n\tchar msg[BUFSIZ];\n\tstruct evsel *counter;\n\tstruct evlist *evlist = top->evlist;\n\tstruct record_opts *opts = &top->record_opts;\n\n\tif (perf_top__overwrite_check(top)) {\n\t\tui__error(\"perf top only support consistent per-event \"\n\t\t\t  \"overwrite setting for all events\\n\");\n\t\tgoto out_err;\n\t}\n\n\tevlist__config(evlist, opts, &callchain_param);\n\n\tevlist__for_each_entry(evlist, counter) {\ntry_again:\n\t\tif (evsel__open(counter, top->evlist->core.user_requested_cpus,\n\t\t\t\t     top->evlist->core.threads) < 0) {\n\n\t\t\t \n\t\t\tif (perf_missing_features.write_backward &&\n\t\t\t    perf_top_overwrite_fallback(top, counter))\n\t\t\t\tgoto try_again;\n\n\t\t\tif (evsel__fallback(counter, errno, msg, sizeof(msg))) {\n\t\t\t\tif (verbose > 0)\n\t\t\t\t\tui__warning(\"%s\\n\", msg);\n\t\t\t\tgoto try_again;\n\t\t\t}\n\n\t\t\tevsel__open_strerror(counter, &opts->target, errno, msg, sizeof(msg));\n\t\t\tui__error(\"%s\\n\", msg);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (evlist__mmap(evlist, opts->mmap_pages) < 0) {\n\t\tui__error(\"Failed to mmap with %d (%s)\\n\",\n\t\t\t    errno, str_error_r(errno, msg, sizeof(msg)));\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\treturn -1;\n}\n\nstatic int callchain_param__setup_sample_type(struct callchain_param *callchain)\n{\n\tif (callchain->mode != CHAIN_NONE) {\n\t\tif (callchain_register_param(callchain) < 0) {\n\t\t\tui__error(\"Can't register callchain params.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct ordered_events *rotate_queues(struct perf_top *top)\n{\n\tstruct ordered_events *in = top->qe.in;\n\n\tif (top->qe.in == &top->qe.data[1])\n\t\ttop->qe.in = &top->qe.data[0];\n\telse\n\t\ttop->qe.in = &top->qe.data[1];\n\n\treturn in;\n}\n\nstatic void *process_thread(void *arg)\n{\n\tstruct perf_top *top = arg;\n\n\twhile (!done) {\n\t\tstruct ordered_events *out, *in = top->qe.in;\n\n\t\tif (!in->nr_events) {\n\t\t\tusleep(100);\n\t\t\tcontinue;\n\t\t}\n\n\t\tout = rotate_queues(top);\n\n\t\tmutex_lock(&top->qe.mutex);\n\t\ttop->qe.rotate = true;\n\t\tcond_wait(&top->qe.cond, &top->qe.mutex);\n\t\tmutex_unlock(&top->qe.mutex);\n\n\t\tif (ordered_events__flush(out, OE_FLUSH__TOP))\n\t\t\tpr_err(\"failed to process events\\n\");\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int should_drop(struct ordered_event *qevent, struct perf_top *top)\n{\n\tunion perf_event *event = qevent->event;\n\tu64 delay_timestamp;\n\n\tif (event->header.type != PERF_RECORD_SAMPLE)\n\t\treturn false;\n\n\tdelay_timestamp = qevent->timestamp + top->delay_secs * NSEC_PER_SEC;\n\treturn delay_timestamp < last_timestamp;\n}\n\nstatic int deliver_event(struct ordered_events *qe,\n\t\t\t struct ordered_event *qevent)\n{\n\tstruct perf_top *top = qe->data;\n\tstruct evlist *evlist = top->evlist;\n\tstruct perf_session *session = top->session;\n\tunion perf_event *event = qevent->event;\n\tstruct perf_sample sample;\n\tstruct evsel *evsel;\n\tstruct machine *machine;\n\tint ret = -1;\n\n\tif (should_drop(qevent, top)) {\n\t\ttop->drop++;\n\t\ttop->drop_total++;\n\t\treturn 0;\n\t}\n\n\tret = evlist__parse_sample(evlist, event, &sample);\n\tif (ret) {\n\t\tpr_err(\"Can't parse sample, err = %d\\n\", ret);\n\t\tgoto next_event;\n\t}\n\n\tevsel = evlist__id2evsel(session->evlist, sample.id);\n\tassert(evsel != NULL);\n\n\tif (event->header.type == PERF_RECORD_SAMPLE) {\n\t\tif (evswitch__discard(&top->evswitch, evsel))\n\t\t\treturn 0;\n\t\t++top->samples;\n\t}\n\n\tswitch (sample.cpumode) {\n\tcase PERF_RECORD_MISC_USER:\n\t\t++top->us_samples;\n\t\tif (top->hide_user_symbols)\n\t\t\tgoto next_event;\n\t\tmachine = &session->machines.host;\n\t\tbreak;\n\tcase PERF_RECORD_MISC_KERNEL:\n\t\t++top->kernel_samples;\n\t\tif (top->hide_kernel_symbols)\n\t\t\tgoto next_event;\n\t\tmachine = &session->machines.host;\n\t\tbreak;\n\tcase PERF_RECORD_MISC_GUEST_KERNEL:\n\t\t++top->guest_kernel_samples;\n\t\tmachine = perf_session__find_machine(session,\n\t\t\t\t\t\t     sample.pid);\n\t\tbreak;\n\tcase PERF_RECORD_MISC_GUEST_USER:\n\t\t++top->guest_us_samples;\n\t\t \n\t\tgoto next_event;\n\tdefault:\n\t\tif (event->header.type == PERF_RECORD_SAMPLE)\n\t\t\tgoto next_event;\n\t\tmachine = &session->machines.host;\n\t\tbreak;\n\t}\n\n\tif (event->header.type == PERF_RECORD_SAMPLE) {\n\t\tperf_event__process_sample(&top->tool, event, evsel,\n\t\t\t\t\t   &sample, machine);\n\t} else if (event->header.type == PERF_RECORD_LOST) {\n\t\tperf_top__process_lost(top, event, evsel);\n\t} else if (event->header.type == PERF_RECORD_LOST_SAMPLES) {\n\t\tperf_top__process_lost_samples(top, event, evsel);\n\t} else if (event->header.type < PERF_RECORD_MAX) {\n\t\tevents_stats__inc(&session->evlist->stats, event->header.type);\n\t\tmachine__process_event(machine, event, &sample);\n\t} else\n\t\t++session->evlist->stats.nr_unknown_events;\n\n\tret = 0;\nnext_event:\n\treturn ret;\n}\n\nstatic void init_process_thread(struct perf_top *top)\n{\n\tordered_events__init(&top->qe.data[0], deliver_event, top);\n\tordered_events__init(&top->qe.data[1], deliver_event, top);\n\tordered_events__set_copy_on_queue(&top->qe.data[0], true);\n\tordered_events__set_copy_on_queue(&top->qe.data[1], true);\n\ttop->qe.in = &top->qe.data[0];\n\tmutex_init(&top->qe.mutex);\n\tcond_init(&top->qe.cond);\n}\n\nstatic void exit_process_thread(struct perf_top *top)\n{\n\tordered_events__free(&top->qe.data[0]);\n\tordered_events__free(&top->qe.data[1]);\n\tmutex_destroy(&top->qe.mutex);\n\tcond_destroy(&top->qe.cond);\n}\n\nstatic int __cmd_top(struct perf_top *top)\n{\n\tstruct record_opts *opts = &top->record_opts;\n\tpthread_t thread, thread_process;\n\tint ret;\n\n\tif (!top->annotation_opts.objdump_path) {\n\t\tret = perf_env__lookup_objdump(&top->session->header.env,\n\t\t\t\t\t       &top->annotation_opts.objdump_path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = callchain_param__setup_sample_type(&callchain_param);\n\tif (ret)\n\t\treturn ret;\n\n\tif (perf_session__register_idle_thread(top->session) < 0)\n\t\treturn ret;\n\n\tif (top->nr_threads_synthesize > 1)\n\t\tperf_set_multithreaded();\n\n\tinit_process_thread(top);\n\n\tif (opts->record_namespaces)\n\t\ttop->tool.namespace_events = true;\n\tif (opts->record_cgroup) {\n#ifdef HAVE_FILE_HANDLE\n\t\ttop->tool.cgroup_events = true;\n#else\n\t\tpr_err(\"cgroup tracking is not supported.\\n\");\n\t\treturn -1;\n#endif\n\t}\n\n\tret = perf_event__synthesize_bpf_events(top->session, perf_event__process,\n\t\t\t\t\t\t&top->session->machines.host,\n\t\t\t\t\t\t&top->record_opts);\n\tif (ret < 0)\n\t\tpr_debug(\"Couldn't synthesize BPF events: Pre-existing BPF programs won't have symbols resolved.\\n\");\n\n\tret = perf_event__synthesize_cgroups(&top->tool, perf_event__process,\n\t\t\t\t\t     &top->session->machines.host);\n\tif (ret < 0)\n\t\tpr_debug(\"Couldn't synthesize cgroup events.\\n\");\n\n\tmachine__synthesize_threads(&top->session->machines.host, &opts->target,\n\t\t\t\t    top->evlist->core.threads, true, false,\n\t\t\t\t    top->nr_threads_synthesize);\n\n\tperf_set_multithreaded();\n\n\tif (perf_hpp_list.socket) {\n\t\tret = perf_env__read_cpu_topology_map(&perf_env);\n\t\tif (ret < 0) {\n\t\t\tchar errbuf[BUFSIZ];\n\t\t\tconst char *err = str_error_r(-ret, errbuf, sizeof(errbuf));\n\n\t\t\tui__error(\"Could not read the CPU topology map: %s\\n\", err);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = perf_top__start_counters(top);\n\tif (ret)\n\t\treturn ret;\n\n\ttop->session->evlist = top->evlist;\n\tperf_session__set_id_hdr_size(top->session);\n\n\t \n        if (!target__none(&opts->target))\n\t\tevlist__enable(top->evlist);\n\n\tret = -1;\n\tif (pthread_create(&thread_process, NULL, process_thread, top)) {\n\t\tui__error(\"Could not create process thread.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (pthread_create(&thread, NULL, (use_browser > 0 ? display_thread_tui :\n\t\t\t\t\t\t\t    display_thread), top)) {\n\t\tui__error(\"Could not create display thread.\\n\");\n\t\tgoto out_join_thread;\n\t}\n\n\tif (top->realtime_prio) {\n\t\tstruct sched_param param;\n\n\t\tparam.sched_priority = top->realtime_prio;\n\t\tif (sched_setscheduler(0, SCHED_FIFO, &param)) {\n\t\t\tui__error(\"Could not set realtime priority.\\n\");\n\t\t\tgoto out_join;\n\t\t}\n\t}\n\n\t \n\tevlist__poll(top->evlist, 100);\n\n\tperf_top__mmap_read(top);\n\n\twhile (!done) {\n\t\tu64 hits = top->samples;\n\n\t\tperf_top__mmap_read(top);\n\n\t\tif (opts->overwrite || (hits == top->samples))\n\t\t\tret = evlist__poll(top->evlist, 100);\n\n\t\tif (resize) {\n\t\t\tperf_top__resize(top);\n\t\t\tresize = 0;\n\t\t}\n\t}\n\n\tret = 0;\nout_join:\n\tpthread_join(thread, NULL);\nout_join_thread:\n\tcond_signal(&top->qe.cond);\n\tpthread_join(thread_process, NULL);\n\tperf_set_singlethreaded();\n\texit_process_thread(top);\n\treturn ret;\n}\n\nstatic int\ncallchain_opt(const struct option *opt, const char *arg, int unset)\n{\n\tsymbol_conf.use_callchain = true;\n\treturn record_callchain_opt(opt, arg, unset);\n}\n\nstatic int\nparse_callchain_opt(const struct option *opt, const char *arg, int unset)\n{\n\tstruct callchain_param *callchain = opt->value;\n\n\tcallchain->enabled = !unset;\n\tcallchain->record_mode = CALLCHAIN_FP;\n\n\t \n\tif (unset) {\n\t\tsymbol_conf.use_callchain = false;\n\t\tcallchain->record_mode = CALLCHAIN_NONE;\n\t\treturn 0;\n\t}\n\n\treturn parse_callchain_top_opt(arg);\n}\n\nstatic int perf_top_config(const char *var, const char *value, void *cb __maybe_unused)\n{\n\tif (!strcmp(var, \"top.call-graph\")) {\n\t\tvar = \"call-graph.record-mode\";\n\t\treturn perf_default_config(var, value, cb);\n\t}\n\tif (!strcmp(var, \"top.children\")) {\n\t\tsymbol_conf.cumulate_callchain = perf_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nparse_percent_limit(const struct option *opt, const char *arg,\n\t\t    int unset __maybe_unused)\n{\n\tstruct perf_top *top = opt->value;\n\n\ttop->min_percent = strtof(arg, NULL);\n\treturn 0;\n}\n\nconst char top_callchain_help[] = CALLCHAIN_RECORD_HELP CALLCHAIN_REPORT_HELP\n\t\"\\n\\t\\t\\t\\tDefault: fp,graph,0.5,caller,function\";\n\nint cmd_top(int argc, const char **argv)\n{\n\tchar errbuf[BUFSIZ];\n\tstruct perf_top top = {\n\t\t.count_filter\t     = 5,\n\t\t.delay_secs\t     = 2,\n\t\t.record_opts = {\n\t\t\t.mmap_pages\t= UINT_MAX,\n\t\t\t.user_freq\t= UINT_MAX,\n\t\t\t.user_interval\t= ULLONG_MAX,\n\t\t\t.freq\t\t= 4000,  \n\t\t\t.target\t\t= {\n\t\t\t\t.uses_mmap   = true,\n\t\t\t},\n\t\t\t \n\t\t\t.overwrite\t= 0,\n\t\t\t.sample_time\t= true,\n\t\t\t.sample_time_set = true,\n\t\t},\n\t\t.max_stack\t     = sysctl__max_stack(),\n\t\t.nr_threads_synthesize = UINT_MAX,\n\t};\n\tstruct parse_events_option_args parse_events_option_args = {\n\t\t.evlistp = &top.evlist,\n\t};\n\tbool branch_call_mode = false;\n\tstruct record_opts *opts = &top.record_opts;\n\tstruct target *target = &opts->target;\n\tconst char *disassembler_style = NULL, *objdump_path = NULL, *addr2line_path = NULL;\n\tconst struct option options[] = {\n\tOPT_CALLBACK('e', \"event\", &parse_events_option_args, \"event\",\n\t\t     \"event selector. use 'perf list' to list available events\",\n\t\t     parse_events_option),\n\tOPT_U64('c', \"count\", &opts->user_interval, \"event period to sample\"),\n\tOPT_STRING('p', \"pid\", &target->pid, \"pid\",\n\t\t    \"profile events on existing process id\"),\n\tOPT_STRING('t', \"tid\", &target->tid, \"tid\",\n\t\t    \"profile events on existing thread id\"),\n\tOPT_BOOLEAN('a', \"all-cpus\", &target->system_wide,\n\t\t\t    \"system-wide collection from all CPUs\"),\n\tOPT_STRING('C', \"cpu\", &target->cpu_list, \"cpu\",\n\t\t    \"list of cpus to monitor\"),\n\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_BOOLEAN(0, \"ignore-vmlinux\", &symbol_conf.ignore_vmlinux,\n\t\t    \"don't load vmlinux even if found\"),\n\tOPT_STRING(0, \"kallsyms\", &symbol_conf.kallsyms_name,\n\t\t   \"file\", \"kallsyms pathname\"),\n\tOPT_BOOLEAN('K', \"hide_kernel_symbols\", &top.hide_kernel_symbols,\n\t\t    \"hide kernel symbols\"),\n\tOPT_CALLBACK('m', \"mmap-pages\", &opts->mmap_pages, \"pages\",\n\t\t     \"number of mmap data pages\", evlist__parse_mmap_pages),\n\tOPT_INTEGER('r', \"realtime\", &top.realtime_prio,\n\t\t    \"collect data with this RT SCHED_FIFO priority\"),\n\tOPT_INTEGER('d', \"delay\", &top.delay_secs,\n\t\t    \"number of seconds to delay between refreshes\"),\n\tOPT_BOOLEAN('D', \"dump-symtab\", &top.dump_symtab,\n\t\t\t    \"dump the symbol table used for profiling\"),\n\tOPT_INTEGER('f', \"count-filter\", &top.count_filter,\n\t\t    \"only display functions with more events than this\"),\n\tOPT_BOOLEAN('i', \"no-inherit\", &opts->no_inherit,\n\t\t    \"child tasks do not inherit counters\"),\n\tOPT_STRING(0, \"sym-annotate\", &top.sym_filter, \"symbol name\",\n\t\t    \"symbol to annotate\"),\n\tOPT_BOOLEAN('z', \"zero\", &top.zero, \"zero history across updates\"),\n\tOPT_CALLBACK('F', \"freq\", &top.record_opts, \"freq or 'max'\",\n\t\t     \"profile at this frequency\",\n\t\t      record__parse_freq),\n\tOPT_INTEGER('E', \"entries\", &top.print_entries,\n\t\t    \"display this many functions\"),\n\tOPT_BOOLEAN('U', \"hide_user_symbols\", &top.hide_user_symbols,\n\t\t    \"hide user symbols\"),\n#ifdef HAVE_SLANG_SUPPORT\n\tOPT_BOOLEAN(0, \"tui\", &top.use_tui, \"Use the TUI interface\"),\n#endif\n\tOPT_BOOLEAN(0, \"stdio\", &top.use_stdio, \"Use the stdio interface\"),\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t    \"be more verbose (show counter open errors, etc)\"),\n\tOPT_STRING('s', \"sort\", &sort_order, \"key[,key2...]\",\n\t\t   \"sort by key(s): pid, comm, dso, symbol, parent, cpu, srcline, ...\"\n\t\t   \" Please refer the man page for the complete list.\"),\n\tOPT_STRING(0, \"fields\", &field_order, \"key[,keys...]\",\n\t\t   \"output field(s): overhead, period, sample plus all of sort keys\"),\n\tOPT_BOOLEAN('n', \"show-nr-samples\", &symbol_conf.show_nr_samples,\n\t\t    \"Show a column with the number of samples\"),\n\tOPT_CALLBACK_NOOPT('g', NULL, &callchain_param,\n\t\t\t   NULL, \"enables call-graph recording and display\",\n\t\t\t   &callchain_opt),\n\tOPT_CALLBACK(0, \"call-graph\", &callchain_param,\n\t\t     \"record_mode[,record_size],print_type,threshold[,print_limit],order,sort_key[,branch]\",\n\t\t     top_callchain_help, &parse_callchain_opt),\n\tOPT_BOOLEAN(0, \"children\", &symbol_conf.cumulate_callchain,\n\t\t    \"Accumulate callchains of children and show total overhead as well\"),\n\tOPT_INTEGER(0, \"max-stack\", &top.max_stack,\n\t\t    \"Set the maximum stack depth when parsing the callchain. \"\n\t\t    \"Default: kernel.perf_event_max_stack or \" __stringify(PERF_MAX_STACK_DEPTH)),\n\tOPT_CALLBACK(0, \"ignore-callees\", NULL, \"regex\",\n\t\t   \"ignore callees of these functions in call graphs\",\n\t\t   report_parse_ignore_callees_opt),\n\tOPT_BOOLEAN(0, \"show-total-period\", &symbol_conf.show_total_period,\n\t\t    \"Show a column with the sum of periods\"),\n\tOPT_STRING(0, \"dsos\", &symbol_conf.dso_list_str, \"dso[,dso...]\",\n\t\t   \"only consider symbols in these dsos\"),\n\tOPT_STRING(0, \"comms\", &symbol_conf.comm_list_str, \"comm[,comm...]\",\n\t\t   \"only consider symbols in these comms\"),\n\tOPT_STRING(0, \"symbols\", &symbol_conf.sym_list_str, \"symbol[,symbol...]\",\n\t\t   \"only consider these symbols\"),\n\tOPT_BOOLEAN(0, \"source\", &top.annotation_opts.annotate_src,\n\t\t    \"Interleave source code with assembly code (default)\"),\n\tOPT_BOOLEAN(0, \"asm-raw\", &top.annotation_opts.show_asm_raw,\n\t\t    \"Display raw encoding of assembly instructions (default)\"),\n\tOPT_BOOLEAN(0, \"demangle-kernel\", &symbol_conf.demangle_kernel,\n\t\t    \"Enable kernel symbol demangling\"),\n\tOPT_BOOLEAN(0, \"no-bpf-event\", &top.record_opts.no_bpf_event, \"do not record bpf events\"),\n\tOPT_STRING(0, \"objdump\", &objdump_path, \"path\",\n\t\t    \"objdump binary to use for disassembly and annotations\"),\n\tOPT_STRING(0, \"addr2line\", &addr2line_path, \"path\",\n\t\t   \"addr2line binary to use for line numbers\"),\n\tOPT_STRING('M', \"disassembler-style\", &disassembler_style, \"disassembler style\",\n\t\t   \"Specify disassembler style (e.g. -M intel for intel syntax)\"),\n\tOPT_STRING(0, \"prefix\", &top.annotation_opts.prefix, \"prefix\",\n\t\t    \"Add prefix to source file path names in programs (with --prefix-strip)\"),\n\tOPT_STRING(0, \"prefix-strip\", &top.annotation_opts.prefix_strip, \"N\",\n\t\t    \"Strip first N entries of source file path name in programs (with --prefix)\"),\n\tOPT_STRING('u', \"uid\", &target->uid_str, \"user\", \"user to profile\"),\n\tOPT_CALLBACK(0, \"percent-limit\", &top, \"percent\",\n\t\t     \"Don't show entries under that percent\", parse_percent_limit),\n\tOPT_CALLBACK(0, \"percentage\", NULL, \"relative|absolute\",\n\t\t     \"How to display percentage of filtered entries\", parse_filter_percentage),\n\tOPT_STRING('w', \"column-widths\", &symbol_conf.col_width_list_str,\n\t\t   \"width[,width...]\",\n\t\t   \"don't try to adjust column width, use these fixed values\"),\n\tOPT_UINTEGER(0, \"proc-map-timeout\", &proc_map_timeout,\n\t\t\t\"per thread proc mmap processing timeout in ms\"),\n\tOPT_CALLBACK_NOOPT('b', \"branch-any\", &opts->branch_stack,\n\t\t     \"branch any\", \"sample any taken branches\",\n\t\t     parse_branch_stack),\n\tOPT_CALLBACK('j', \"branch-filter\", &opts->branch_stack,\n\t\t     \"branch filter mask\", \"branch stack filter modes\",\n\t\t     parse_branch_stack),\n\tOPT_BOOLEAN(0, \"branch-history\", &branch_call_mode,\n\t\t    \"add last branch records to call history\"),\n\tOPT_BOOLEAN(0, \"raw-trace\", &symbol_conf.raw_trace,\n\t\t    \"Show raw trace event output (do not use print fmt or plugins)\"),\n\tOPT_BOOLEAN(0, \"hierarchy\", &symbol_conf.report_hierarchy,\n\t\t    \"Show entries in a hierarchy\"),\n\tOPT_BOOLEAN(0, \"overwrite\", &top.record_opts.overwrite,\n\t\t    \"Use a backward ring buffer, default: no\"),\n\tOPT_BOOLEAN(0, \"force\", &symbol_conf.force, \"don't complain, do it\"),\n\tOPT_UINTEGER(0, \"num-thread-synthesize\", &top.nr_threads_synthesize,\n\t\t\t\"number of thread to run event synthesize\"),\n\tOPT_CALLBACK('G', \"cgroup\", &top.evlist, \"name\",\n\t\t     \"monitor event in cgroup name only\", parse_cgroups),\n\tOPT_BOOLEAN(0, \"namespaces\", &opts->record_namespaces,\n\t\t    \"Record namespaces events\"),\n\tOPT_BOOLEAN(0, \"all-cgroups\", &opts->record_cgroup,\n\t\t    \"Record cgroup events\"),\n\tOPT_INTEGER(0, \"group-sort-idx\", &symbol_conf.group_sort_idx,\n\t\t    \"Sort the output by the event at the index n in group. \"\n\t\t    \"If n is invalid, sort by the first event. \"\n\t\t    \"WARNING: should be used on grouped events.\"),\n\tOPT_BOOLEAN(0, \"stitch-lbr\", &top.stitch_lbr,\n\t\t    \"Enable LBR callgraph stitching approach\"),\n#ifdef HAVE_LIBPFM\n\tOPT_CALLBACK(0, \"pfm-events\", &top.evlist, \"event\",\n\t\t\"libpfm4 event selector. use 'perf list' to list available events\",\n\t\tparse_libpfm_events_option),\n#endif\n\tOPTS_EVSWITCH(&top.evswitch),\n\tOPT_END()\n\t};\n\tconst char * const top_usage[] = {\n\t\t\"perf top [<options>]\",\n\t\tNULL\n\t};\n\tint status = hists__init();\n\n\tif (status < 0)\n\t\treturn status;\n\n\tannotation_options__init(&top.annotation_opts);\n\n\ttop.annotation_opts.min_pcnt = 5;\n\ttop.annotation_opts.context  = 4;\n\n\ttop.evlist = evlist__new();\n\tif (top.evlist == NULL)\n\t\treturn -ENOMEM;\n\n\tstatus = perf_config(perf_top_config, &top);\n\tif (status)\n\t\treturn status;\n\t \n\tstatus = perf_env__read_cpuid(&perf_env);\n\tif (status) {\n\t\t \n\t\teprintf(status == ENOSYS ? 1 : 0, verbose,\n\t\t\t\"Couldn't read the cpuid for this machine: %s\\n\",\n\t\t\tstr_error_r(errno, errbuf, sizeof(errbuf)));\n\t}\n\ttop.evlist->env = &perf_env;\n\n\targc = parse_options(argc, argv, options, top_usage, 0);\n\tif (argc)\n\t\tusage_with_options(top_usage, options);\n\n\tif (disassembler_style) {\n\t\ttop.annotation_opts.disassembler_style = strdup(disassembler_style);\n\t\tif (!top.annotation_opts.disassembler_style)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (objdump_path) {\n\t\ttop.annotation_opts.objdump_path = strdup(objdump_path);\n\t\tif (!top.annotation_opts.objdump_path)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (addr2line_path) {\n\t\tsymbol_conf.addr2line_path = strdup(addr2line_path);\n\t\tif (!symbol_conf.addr2line_path)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tstatus = symbol__validate_sym_arguments();\n\tif (status)\n\t\tgoto out_delete_evlist;\n\n\tif (annotate_check_args(&top.annotation_opts) < 0)\n\t\tgoto out_delete_evlist;\n\n\tif (!top.evlist->core.nr_entries) {\n\t\tbool can_profile_kernel = perf_event_paranoid_check(1);\n\t\tint err = parse_event(top.evlist, can_profile_kernel ? \"cycles:P\" : \"cycles:Pu\");\n\n\t\tif (err)\n\t\t\tgoto out_delete_evlist;\n\t}\n\n\tstatus = evswitch__init(&top.evswitch, top.evlist, stderr);\n\tif (status)\n\t\tgoto out_delete_evlist;\n\n\tif (symbol_conf.report_hierarchy) {\n\t\t \n\t\tsymbol_conf.event_group = false;\n\t\tsymbol_conf.cumulate_callchain = false;\n\n\t\tif (field_order) {\n\t\t\tpr_err(\"Error: --hierarchy and --fields options cannot be used together\\n\");\n\t\t\tparse_options_usage(top_usage, options, \"fields\", 0);\n\t\t\tparse_options_usage(NULL, options, \"hierarchy\", 0);\n\t\t\tgoto out_delete_evlist;\n\t\t}\n\t}\n\n\tif (top.stitch_lbr && !(callchain_param.record_mode == CALLCHAIN_LBR)) {\n\t\tpr_err(\"Error: --stitch-lbr must be used with --call-graph lbr\\n\");\n\t\tgoto out_delete_evlist;\n\t}\n\n\tif (nr_cgroups > 0 && opts->record_cgroup) {\n\t\tpr_err(\"--cgroup and --all-cgroups cannot be used together\\n\");\n\t\tgoto out_delete_evlist;\n\t}\n\n\tif (branch_call_mode) {\n\t\tif (!opts->branch_stack)\n\t\t\topts->branch_stack = PERF_SAMPLE_BRANCH_ANY;\n\t\tsymbol_conf.use_callchain = true;\n\t\tcallchain_param.key = CCKEY_ADDRESS;\n\t\tcallchain_param.branch_callstack = true;\n\t\tcallchain_param.enabled = true;\n\t\tif (callchain_param.record_mode == CALLCHAIN_NONE)\n\t\t\tcallchain_param.record_mode = CALLCHAIN_FP;\n\t\tcallchain_register_param(&callchain_param);\n\t\tif (!sort_order)\n\t\t\tsort_order = \"srcline,symbol,dso\";\n\t}\n\n\tif (opts->branch_stack && callchain_param.enabled)\n\t\tsymbol_conf.show_branchflag_count = true;\n\n\tsort__mode = SORT_MODE__TOP;\n\t \n\tperf_hpp_list.need_collapse = 1;\n\n\tif (top.use_stdio)\n\t\tuse_browser = 0;\n#ifdef HAVE_SLANG_SUPPORT\n\telse if (top.use_tui)\n\t\tuse_browser = 1;\n#endif\n\n\tsetup_browser(false);\n\n\tif (setup_sorting(top.evlist) < 0) {\n\t\tif (sort_order)\n\t\t\tparse_options_usage(top_usage, options, \"s\", 1);\n\t\tif (field_order)\n\t\t\tparse_options_usage(sort_order ? NULL : top_usage,\n\t\t\t\t\t    options, \"fields\", 0);\n\t\tgoto out_delete_evlist;\n\t}\n\n\tstatus = target__validate(target);\n\tif (status) {\n\t\ttarget__strerror(target, status, errbuf, BUFSIZ);\n\t\tui__warning(\"%s\\n\", errbuf);\n\t}\n\n\tstatus = target__parse_uid(target);\n\tif (status) {\n\t\tint saved_errno = errno;\n\n\t\ttarget__strerror(target, status, errbuf, BUFSIZ);\n\t\tui__error(\"%s\\n\", errbuf);\n\n\t\tstatus = -saved_errno;\n\t\tgoto out_delete_evlist;\n\t}\n\n\tif (target__none(target))\n\t\ttarget->system_wide = true;\n\n\tif (evlist__create_maps(top.evlist, target) < 0) {\n\t\tui__error(\"Couldn't create thread/CPU maps: %s\\n\",\n\t\t\t  errno == ENOENT ? \"No such process\" : str_error_r(errno, errbuf, sizeof(errbuf)));\n\t\tstatus = -errno;\n\t\tgoto out_delete_evlist;\n\t}\n\n\tif (top.delay_secs < 1)\n\t\ttop.delay_secs = 1;\n\n\tif (record_opts__config(opts)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_delete_evlist;\n\t}\n\n\ttop.sym_evsel = evlist__first(top.evlist);\n\n\tif (!callchain_param.enabled) {\n\t\tsymbol_conf.cumulate_callchain = false;\n\t\tperf_hpp__cancel_cumulate();\n\t}\n\n\tif (symbol_conf.cumulate_callchain && !callchain_param.order_set)\n\t\tcallchain_param.order = ORDER_CALLER;\n\n\tstatus = symbol__annotation_init();\n\tif (status < 0)\n\t\tgoto out_delete_evlist;\n\n\tannotation_config__init(&top.annotation_opts);\n\n\tsymbol_conf.try_vmlinux_path = (symbol_conf.vmlinux_name == NULL);\n\tstatus = symbol__init(NULL);\n\tif (status < 0)\n\t\tgoto out_delete_evlist;\n\n\tsort__setup_elide(stdout);\n\n\tget_term_dimensions(&top.winsize);\n\tif (top.print_entries == 0) {\n\t\tperf_top__update_print_entries(&top);\n\t\tsignal(SIGWINCH, winch_sig);\n\t}\n\n\ttop.session = perf_session__new(NULL, NULL);\n\tif (IS_ERR(top.session)) {\n\t\tstatus = PTR_ERR(top.session);\n\t\ttop.session = NULL;\n\t\tgoto out_delete_evlist;\n\t}\n\n#ifdef HAVE_LIBBPF_SUPPORT\n\tif (!top.record_opts.no_bpf_event) {\n\t\ttop.sb_evlist = evlist__new();\n\n\t\tif (top.sb_evlist == NULL) {\n\t\t\tpr_err(\"Couldn't create side band evlist.\\n.\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto out_delete_evlist;\n\t\t}\n\n\t\tif (evlist__add_bpf_sb_event(top.sb_evlist, &perf_env)) {\n\t\t\tpr_err(\"Couldn't ask for PERF_RECORD_BPF_EVENT side band events.\\n.\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto out_delete_evlist;\n\t\t}\n\t}\n#endif\n\n\tif (evlist__start_sb_thread(top.sb_evlist, target)) {\n\t\tpr_debug(\"Couldn't start the BPF side band thread:\\nBPF programs starting from now on won't be annotatable\\n\");\n\t\topts->no_bpf_event = true;\n\t}\n\n\tstatus = __cmd_top(&top);\n\n\tif (!opts->no_bpf_event)\n\t\tevlist__stop_sb_thread(top.sb_evlist);\n\nout_delete_evlist:\n\tevlist__delete(top.evlist);\n\tperf_session__delete(top.session);\n\tannotation_options__exit(&top.annotation_opts);\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}