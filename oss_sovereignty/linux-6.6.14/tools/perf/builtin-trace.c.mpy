{
  "module_name": "builtin-trace.c",
  "hash_id": "459044ad7b641d1dcaa83807d425493b92cee446c1df050c01cfd0311fd488ac",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-trace.c",
  "human_readable_source": " \n\n#include \"util/record.h\"\n#include <api/fs/tracing_path.h>\n#ifdef HAVE_LIBBPF_SUPPORT\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#ifdef HAVE_BPF_SKEL\n#include \"bpf_skel/augmented_raw_syscalls.skel.h\"\n#endif\n#endif\n#include \"util/bpf_map.h\"\n#include \"util/rlimit.h\"\n#include \"builtin.h\"\n#include \"util/cgroup.h\"\n#include \"util/color.h\"\n#include \"util/config.h\"\n#include \"util/debug.h\"\n#include \"util/dso.h\"\n#include \"util/env.h\"\n#include \"util/event.h\"\n#include \"util/evsel.h\"\n#include \"util/evsel_fprintf.h\"\n#include \"util/synthetic-events.h\"\n#include \"util/evlist.h\"\n#include \"util/evswitch.h\"\n#include \"util/mmap.h\"\n#include <subcmd/pager.h>\n#include <subcmd/exec-cmd.h>\n#include \"util/machine.h\"\n#include \"util/map.h\"\n#include \"util/symbol.h\"\n#include \"util/path.h\"\n#include \"util/session.h\"\n#include \"util/thread.h\"\n#include <subcmd/parse-options.h>\n#include \"util/strlist.h\"\n#include \"util/intlist.h\"\n#include \"util/thread_map.h\"\n#include \"util/stat.h\"\n#include \"util/tool.h\"\n#include \"util/util.h\"\n#include \"trace/beauty/beauty.h\"\n#include \"trace-event.h\"\n#include \"util/parse-events.h\"\n#include \"util/tracepoint.h\"\n#include \"callchain.h\"\n#include \"print_binary.h\"\n#include \"string2.h\"\n#include \"syscalltbl.h\"\n#include \"rb_resort.h\"\n#include \"../perf.h\"\n\n#include <errno.h>\n#include <inttypes.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <linux/err.h>\n#include <linux/filter.h>\n#include <linux/kernel.h>\n#include <linux/random.h>\n#include <linux/stringify.h>\n#include <linux/time64.h>\n#include <linux/zalloc.h>\n#include <fcntl.h>\n#include <sys/sysmacros.h>\n\n#include <linux/ctype.h>\n#include <perf/mmap.h>\n\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#endif\n\n#ifndef O_CLOEXEC\n# define O_CLOEXEC\t\t02000000\n#endif\n\n#ifndef F_LINUX_SPECIFIC_BASE\n# define F_LINUX_SPECIFIC_BASE\t1024\n#endif\n\n#define RAW_SYSCALL_ARGS_NUM\t6\n\n \nstruct syscall_arg_fmt {\n\tsize_t\t   (*scnprintf)(char *bf, size_t size, struct syscall_arg *arg);\n\tbool\t   (*strtoul)(char *bf, size_t size, struct syscall_arg *arg, u64 *val);\n\tunsigned long (*mask_val)(struct syscall_arg *arg, unsigned long val);\n\tvoid\t   *parm;\n\tconst char *name;\n\tu16\t   nr_entries; \n\tbool\t   show_zero;\n};\n\nstruct syscall_fmt {\n\tconst char *name;\n\tconst char *alias;\n\tstruct {\n\t\tconst char *sys_enter,\n\t\t\t   *sys_exit;\n\t}\t   bpf_prog_name;\n\tstruct syscall_arg_fmt arg[RAW_SYSCALL_ARGS_NUM];\n\tu8\t   nr_args;\n\tbool\t   errpid;\n\tbool\t   timeout;\n\tbool\t   hexret;\n};\n\nstruct trace {\n\tstruct perf_tool\ttool;\n\tstruct syscalltbl\t*sctbl;\n\tstruct {\n\t\tstruct syscall  *table;\n\t\tstruct {\n\t\t\tstruct evsel *sys_enter,\n\t\t\t\t*sys_exit,\n\t\t\t\t*bpf_output;\n\t\t}\t\tevents;\n\t} syscalls;\n#ifdef HAVE_BPF_SKEL\n\tstruct augmented_raw_syscalls_bpf *skel;\n#endif\n\tstruct record_opts\topts;\n\tstruct evlist\t*evlist;\n\tstruct machine\t\t*host;\n\tstruct thread\t\t*current;\n\tstruct cgroup\t\t*cgroup;\n\tu64\t\t\tbase_time;\n\tFILE\t\t\t*output;\n\tunsigned long\t\tnr_events;\n\tunsigned long\t\tnr_events_printed;\n\tunsigned long\t\tmax_events;\n\tstruct evswitch\t\tevswitch;\n\tstruct strlist\t\t*ev_qualifier;\n\tstruct {\n\t\tsize_t\t\tnr;\n\t\tint\t\t*entries;\n\t}\t\t\tev_qualifier_ids;\n\tstruct {\n\t\tsize_t\t\tnr;\n\t\tpid_t\t\t*entries;\n\t\tstruct bpf_map  *map;\n\t}\t\t\tfilter_pids;\n\tdouble\t\t\tduration_filter;\n\tdouble\t\t\truntime_ms;\n\tstruct {\n\t\tu64\t\tvfs_getname,\n\t\t\t\tproc_getname;\n\t} stats;\n\tunsigned int\t\tmax_stack;\n\tunsigned int\t\tmin_stack;\n\tint\t\t\traw_augmented_syscalls_args_size;\n\tbool\t\t\traw_augmented_syscalls;\n\tbool\t\t\tfd_path_disabled;\n\tbool\t\t\tsort_events;\n\tbool\t\t\tnot_ev_qualifier;\n\tbool\t\t\tlive;\n\tbool\t\t\tfull_time;\n\tbool\t\t\tsched;\n\tbool\t\t\tmultiple_threads;\n\tbool\t\t\tsummary;\n\tbool\t\t\tsummary_only;\n\tbool\t\t\terrno_summary;\n\tbool\t\t\tfailure_only;\n\tbool\t\t\tshow_comm;\n\tbool\t\t\tprint_sample;\n\tbool\t\t\tshow_tool_stats;\n\tbool\t\t\ttrace_syscalls;\n\tbool\t\t\tlibtraceevent_print;\n\tbool\t\t\tkernel_syscallchains;\n\ts16\t\t\targs_alignment;\n\tbool\t\t\tshow_tstamp;\n\tbool\t\t\tshow_duration;\n\tbool\t\t\tshow_zeros;\n\tbool\t\t\tshow_arg_names;\n\tbool\t\t\tshow_string_prefix;\n\tbool\t\t\tforce;\n\tbool\t\t\tvfs_getname;\n\tint\t\t\ttrace_pgfaults;\n\tchar\t\t\t*perfconfig_events;\n\tstruct {\n\t\tstruct ordered_events\tdata;\n\t\tu64\t\t\tlast;\n\t} oe;\n};\n\nstruct tp_field {\n\tint offset;\n\tunion {\n\t\tu64 (*integer)(struct tp_field *field, struct perf_sample *sample);\n\t\tvoid *(*pointer)(struct tp_field *field, struct perf_sample *sample);\n\t};\n};\n\n#define TP_UINT_FIELD(bits) \\\nstatic u64 tp_field__u##bits(struct tp_field *field, struct perf_sample *sample) \\\n{ \\\n\tu##bits value; \\\n\tmemcpy(&value, sample->raw_data + field->offset, sizeof(value)); \\\n\treturn value;  \\\n}\n\nTP_UINT_FIELD(8);\nTP_UINT_FIELD(16);\nTP_UINT_FIELD(32);\nTP_UINT_FIELD(64);\n\n#define TP_UINT_FIELD__SWAPPED(bits) \\\nstatic u64 tp_field__swapped_u##bits(struct tp_field *field, struct perf_sample *sample) \\\n{ \\\n\tu##bits value; \\\n\tmemcpy(&value, sample->raw_data + field->offset, sizeof(value)); \\\n\treturn bswap_##bits(value);\\\n}\n\nTP_UINT_FIELD__SWAPPED(16);\nTP_UINT_FIELD__SWAPPED(32);\nTP_UINT_FIELD__SWAPPED(64);\n\nstatic int __tp_field__init_uint(struct tp_field *field, int size, int offset, bool needs_swap)\n{\n\tfield->offset = offset;\n\n\tswitch (size) {\n\tcase 1:\n\t\tfield->integer = tp_field__u8;\n\t\tbreak;\n\tcase 2:\n\t\tfield->integer = needs_swap ? tp_field__swapped_u16 : tp_field__u16;\n\t\tbreak;\n\tcase 4:\n\t\tfield->integer = needs_swap ? tp_field__swapped_u32 : tp_field__u32;\n\t\tbreak;\n\tcase 8:\n\t\tfield->integer = needs_swap ? tp_field__swapped_u64 : tp_field__u64;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int tp_field__init_uint(struct tp_field *field, struct tep_format_field *format_field, bool needs_swap)\n{\n\treturn __tp_field__init_uint(field, format_field->size, format_field->offset, needs_swap);\n}\n\nstatic void *tp_field__ptr(struct tp_field *field, struct perf_sample *sample)\n{\n\treturn sample->raw_data + field->offset;\n}\n\nstatic int __tp_field__init_ptr(struct tp_field *field, int offset)\n{\n\tfield->offset = offset;\n\tfield->pointer = tp_field__ptr;\n\treturn 0;\n}\n\nstatic int tp_field__init_ptr(struct tp_field *field, struct tep_format_field *format_field)\n{\n\treturn __tp_field__init_ptr(field, format_field->offset);\n}\n\nstruct syscall_tp {\n\tstruct tp_field id;\n\tunion {\n\t\tstruct tp_field args, ret;\n\t};\n};\n\n \nstruct evsel_trace {\n\tstruct syscall_tp\tsc;\n\tstruct syscall_arg_fmt  *fmt;\n};\n\nstatic struct evsel_trace *evsel_trace__new(void)\n{\n\treturn zalloc(sizeof(struct evsel_trace));\n}\n\nstatic void evsel_trace__delete(struct evsel_trace *et)\n{\n\tif (et == NULL)\n\t\treturn;\n\n\tzfree(&et->fmt);\n\tfree(et);\n}\n\n \nstatic inline struct syscall_tp *__evsel__syscall_tp(struct evsel *evsel)\n{\n\tstruct evsel_trace *et = evsel->priv;\n\n\treturn &et->sc;\n}\n\nstatic struct syscall_tp *evsel__syscall_tp(struct evsel *evsel)\n{\n\tif (evsel->priv == NULL) {\n\t\tevsel->priv = evsel_trace__new();\n\t\tif (evsel->priv == NULL)\n\t\t\treturn NULL;\n\t}\n\n\treturn __evsel__syscall_tp(evsel);\n}\n\n \nstatic inline struct syscall_arg_fmt *__evsel__syscall_arg_fmt(struct evsel *evsel)\n{\n\tstruct evsel_trace *et = evsel->priv;\n\n\treturn et->fmt;\n}\n\nstatic struct syscall_arg_fmt *evsel__syscall_arg_fmt(struct evsel *evsel)\n{\n\tstruct evsel_trace *et = evsel->priv;\n\n\tif (evsel->priv == NULL) {\n\t\tet = evsel->priv = evsel_trace__new();\n\n\t\tif (et == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tif (et->fmt == NULL) {\n\t\tet->fmt = calloc(evsel->tp_format->format.nr_fields, sizeof(struct syscall_arg_fmt));\n\t\tif (et->fmt == NULL)\n\t\t\tgoto out_delete;\n\t}\n\n\treturn __evsel__syscall_arg_fmt(evsel);\n\nout_delete:\n\tevsel_trace__delete(evsel->priv);\n\tevsel->priv = NULL;\n\treturn NULL;\n}\n\nstatic int evsel__init_tp_uint_field(struct evsel *evsel, struct tp_field *field, const char *name)\n{\n\tstruct tep_format_field *format_field = evsel__field(evsel, name);\n\n\tif (format_field == NULL)\n\t\treturn -1;\n\n\treturn tp_field__init_uint(field, format_field, evsel->needs_swap);\n}\n\n#define perf_evsel__init_sc_tp_uint_field(evsel, name) \\\n\t({ struct syscall_tp *sc = __evsel__syscall_tp(evsel);\\\n\t   evsel__init_tp_uint_field(evsel, &sc->name, #name); })\n\nstatic int evsel__init_tp_ptr_field(struct evsel *evsel, struct tp_field *field, const char *name)\n{\n\tstruct tep_format_field *format_field = evsel__field(evsel, name);\n\n\tif (format_field == NULL)\n\t\treturn -1;\n\n\treturn tp_field__init_ptr(field, format_field);\n}\n\n#define perf_evsel__init_sc_tp_ptr_field(evsel, name) \\\n\t({ struct syscall_tp *sc = __evsel__syscall_tp(evsel);\\\n\t   evsel__init_tp_ptr_field(evsel, &sc->name, #name); })\n\nstatic void evsel__delete_priv(struct evsel *evsel)\n{\n\tzfree(&evsel->priv);\n\tevsel__delete(evsel);\n}\n\nstatic int evsel__init_syscall_tp(struct evsel *evsel)\n{\n\tstruct syscall_tp *sc = evsel__syscall_tp(evsel);\n\n\tif (sc != NULL) {\n\t\tif (evsel__init_tp_uint_field(evsel, &sc->id, \"__syscall_nr\") &&\n\t\t    evsel__init_tp_uint_field(evsel, &sc->id, \"nr\"))\n\t\t\treturn -ENOENT;\n\n\t\treturn 0;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int evsel__init_augmented_syscall_tp(struct evsel *evsel, struct evsel *tp)\n{\n\tstruct syscall_tp *sc = evsel__syscall_tp(evsel);\n\n\tif (sc != NULL) {\n\t\tstruct tep_format_field *syscall_id = evsel__field(tp, \"id\");\n\t\tif (syscall_id == NULL)\n\t\t\tsyscall_id = evsel__field(tp, \"__syscall_nr\");\n\t\tif (syscall_id == NULL ||\n\t\t    __tp_field__init_uint(&sc->id, syscall_id->size, syscall_id->offset, evsel->needs_swap))\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int evsel__init_augmented_syscall_tp_args(struct evsel *evsel)\n{\n\tstruct syscall_tp *sc = __evsel__syscall_tp(evsel);\n\n\treturn __tp_field__init_ptr(&sc->args, sc->id.offset + sizeof(u64));\n}\n\nstatic int evsel__init_augmented_syscall_tp_ret(struct evsel *evsel)\n{\n\tstruct syscall_tp *sc = __evsel__syscall_tp(evsel);\n\n\treturn __tp_field__init_uint(&sc->ret, sizeof(u64), sc->id.offset + sizeof(u64), evsel->needs_swap);\n}\n\nstatic int evsel__init_raw_syscall_tp(struct evsel *evsel, void *handler)\n{\n\tif (evsel__syscall_tp(evsel) != NULL) {\n\t\tif (perf_evsel__init_sc_tp_uint_field(evsel, id))\n\t\t\treturn -ENOENT;\n\n\t\tevsel->handler = handler;\n\t\treturn 0;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic struct evsel *perf_evsel__raw_syscall_newtp(const char *direction, void *handler)\n{\n\tstruct evsel *evsel = evsel__newtp(\"raw_syscalls\", direction);\n\n\t \n\tif (IS_ERR(evsel))\n\t\tevsel = evsel__newtp(\"syscalls\", direction);\n\n\tif (IS_ERR(evsel))\n\t\treturn NULL;\n\n\tif (evsel__init_raw_syscall_tp(evsel, handler))\n\t\tgoto out_delete;\n\n\treturn evsel;\n\nout_delete:\n\tevsel__delete_priv(evsel);\n\treturn NULL;\n}\n\n#define perf_evsel__sc_tp_uint(evsel, name, sample) \\\n\t({ struct syscall_tp *fields = __evsel__syscall_tp(evsel); \\\n\t   fields->name.integer(&fields->name, sample); })\n\n#define perf_evsel__sc_tp_ptr(evsel, name, sample) \\\n\t({ struct syscall_tp *fields = __evsel__syscall_tp(evsel); \\\n\t   fields->name.pointer(&fields->name, sample); })\n\nsize_t strarray__scnprintf_suffix(struct strarray *sa, char *bf, size_t size, const char *intfmt, bool show_suffix, int val)\n{\n\tint idx = val - sa->offset;\n\n\tif (idx < 0 || idx >= sa->nr_entries || sa->entries[idx] == NULL) {\n\t\tsize_t printed = scnprintf(bf, size, intfmt, val);\n\t\tif (show_suffix)\n\t\t\tprinted += scnprintf(bf + printed, size - printed, \" /* %s??? */\", sa->prefix);\n\t\treturn printed;\n\t}\n\n\treturn scnprintf(bf, size, \"%s%s\", sa->entries[idx], show_suffix ? sa->prefix : \"\");\n}\n\nsize_t strarray__scnprintf(struct strarray *sa, char *bf, size_t size, const char *intfmt, bool show_prefix, int val)\n{\n\tint idx = val - sa->offset;\n\n\tif (idx < 0 || idx >= sa->nr_entries || sa->entries[idx] == NULL) {\n\t\tsize_t printed = scnprintf(bf, size, intfmt, val);\n\t\tif (show_prefix)\n\t\t\tprinted += scnprintf(bf + printed, size - printed, \" /* %s??? */\", sa->prefix);\n\t\treturn printed;\n\t}\n\n\treturn scnprintf(bf, size, \"%s%s\", show_prefix ? sa->prefix : \"\", sa->entries[idx]);\n}\n\nstatic size_t __syscall_arg__scnprintf_strarray(char *bf, size_t size,\n\t\t\t\t\t\tconst char *intfmt,\n\t\t\t\t\t        struct syscall_arg *arg)\n{\n\treturn strarray__scnprintf(arg->parm, bf, size, intfmt, arg->show_string_prefix, arg->val);\n}\n\nstatic size_t syscall_arg__scnprintf_strarray(char *bf, size_t size,\n\t\t\t\t\t      struct syscall_arg *arg)\n{\n\treturn __syscall_arg__scnprintf_strarray(bf, size, \"%d\", arg);\n}\n\n#define SCA_STRARRAY syscall_arg__scnprintf_strarray\n\nbool syscall_arg__strtoul_strarray(char *bf, size_t size, struct syscall_arg *arg, u64 *ret)\n{\n\treturn strarray__strtoul(arg->parm, bf, size, ret);\n}\n\nbool syscall_arg__strtoul_strarray_flags(char *bf, size_t size, struct syscall_arg *arg, u64 *ret)\n{\n\treturn strarray__strtoul_flags(arg->parm, bf, size, ret);\n}\n\nbool syscall_arg__strtoul_strarrays(char *bf, size_t size, struct syscall_arg *arg, u64 *ret)\n{\n\treturn strarrays__strtoul(arg->parm, bf, size, ret);\n}\n\nsize_t syscall_arg__scnprintf_strarray_flags(char *bf, size_t size, struct syscall_arg *arg)\n{\n\treturn strarray__scnprintf_flags(arg->parm, bf, size, arg->show_string_prefix, arg->val);\n}\n\nsize_t strarrays__scnprintf(struct strarrays *sas, char *bf, size_t size, const char *intfmt, bool show_prefix, int val)\n{\n\tsize_t printed;\n\tint i;\n\n\tfor (i = 0; i < sas->nr_entries; ++i) {\n\t\tstruct strarray *sa = sas->entries[i];\n\t\tint idx = val - sa->offset;\n\n\t\tif (idx >= 0 && idx < sa->nr_entries) {\n\t\t\tif (sa->entries[idx] == NULL)\n\t\t\t\tbreak;\n\t\t\treturn scnprintf(bf, size, \"%s%s\", show_prefix ? sa->prefix : \"\", sa->entries[idx]);\n\t\t}\n\t}\n\n\tprinted = scnprintf(bf, size, intfmt, val);\n\tif (show_prefix)\n\t\tprinted += scnprintf(bf + printed, size - printed, \" /* %s??? */\", sas->entries[0]->prefix);\n\treturn printed;\n}\n\nbool strarray__strtoul(struct strarray *sa, char *bf, size_t size, u64 *ret)\n{\n\tint i;\n\n\tfor (i = 0; i < sa->nr_entries; ++i) {\n\t\tif (sa->entries[i] && strncmp(sa->entries[i], bf, size) == 0 && sa->entries[i][size] == '\\0') {\n\t\t\t*ret = sa->offset + i;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool strarray__strtoul_flags(struct strarray *sa, char *bf, size_t size, u64 *ret)\n{\n\tu64 val = 0;\n\tchar *tok = bf, *sep, *end;\n\n\t*ret = 0;\n\n\twhile (size != 0) {\n\t\tint toklen = size;\n\n\t\tsep = memchr(tok, '|', size);\n\t\tif (sep != NULL) {\n\t\t\tsize -= sep - tok + 1;\n\n\t\t\tend = sep - 1;\n\t\t\twhile (end > tok && isspace(*end))\n\t\t\t\t--end;\n\n\t\t\ttoklen = end - tok + 1;\n\t\t}\n\n\t\twhile (isspace(*tok))\n\t\t\t++tok;\n\n\t\tif (isalpha(*tok) || *tok == '_') {\n\t\t\tif (!strarray__strtoul(sa, tok, toklen, &val))\n\t\t\t\treturn false;\n\t\t} else\n\t\t\tval = strtoul(tok, NULL, 0);\n\n\t\t*ret |= (1 << (val - 1));\n\n\t\tif (sep == NULL)\n\t\t\tbreak;\n\t\ttok = sep + 1;\n\t}\n\n\treturn true;\n}\n\nbool strarrays__strtoul(struct strarrays *sas, char *bf, size_t size, u64 *ret)\n{\n\tint i;\n\n\tfor (i = 0; i < sas->nr_entries; ++i) {\n\t\tstruct strarray *sa = sas->entries[i];\n\n\t\tif (strarray__strtoul(sa, bf, size, ret))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nsize_t syscall_arg__scnprintf_strarrays(char *bf, size_t size,\n\t\t\t\t\tstruct syscall_arg *arg)\n{\n\treturn strarrays__scnprintf(arg->parm, bf, size, \"%d\", arg->show_string_prefix, arg->val);\n}\n\n#ifndef AT_FDCWD\n#define AT_FDCWD\t-100\n#endif\n\nstatic size_t syscall_arg__scnprintf_fd_at(char *bf, size_t size,\n\t\t\t\t\t   struct syscall_arg *arg)\n{\n\tint fd = arg->val;\n\tconst char *prefix = \"AT_FD\";\n\n\tif (fd == AT_FDCWD)\n\t\treturn scnprintf(bf, size, \"%s%s\", arg->show_string_prefix ? prefix : \"\", \"CWD\");\n\n\treturn syscall_arg__scnprintf_fd(bf, size, arg);\n}\n\n#define SCA_FDAT syscall_arg__scnprintf_fd_at\n\nstatic size_t syscall_arg__scnprintf_close_fd(char *bf, size_t size,\n\t\t\t\t\t      struct syscall_arg *arg);\n\n#define SCA_CLOSE_FD syscall_arg__scnprintf_close_fd\n\nsize_t syscall_arg__scnprintf_hex(char *bf, size_t size, struct syscall_arg *arg)\n{\n\treturn scnprintf(bf, size, \"%#lx\", arg->val);\n}\n\nsize_t syscall_arg__scnprintf_ptr(char *bf, size_t size, struct syscall_arg *arg)\n{\n\tif (arg->val == 0)\n\t\treturn scnprintf(bf, size, \"NULL\");\n\treturn syscall_arg__scnprintf_hex(bf, size, arg);\n}\n\nsize_t syscall_arg__scnprintf_int(char *bf, size_t size, struct syscall_arg *arg)\n{\n\treturn scnprintf(bf, size, \"%d\", arg->val);\n}\n\nsize_t syscall_arg__scnprintf_long(char *bf, size_t size, struct syscall_arg *arg)\n{\n\treturn scnprintf(bf, size, \"%ld\", arg->val);\n}\n\nstatic size_t syscall_arg__scnprintf_char_array(char *bf, size_t size, struct syscall_arg *arg)\n{\n\t\n\t\n\t\n\treturn scnprintf(bf, size, \"\\\"%-.*s\\\"\", arg->fmt->nr_entries ?: arg->len, arg->val);\n}\n\n#define SCA_CHAR_ARRAY syscall_arg__scnprintf_char_array\n\nstatic const char *bpf_cmd[] = {\n\t\"MAP_CREATE\", \"MAP_LOOKUP_ELEM\", \"MAP_UPDATE_ELEM\", \"MAP_DELETE_ELEM\",\n\t\"MAP_GET_NEXT_KEY\", \"PROG_LOAD\", \"OBJ_PIN\", \"OBJ_GET\", \"PROG_ATTACH\",\n\t\"PROG_DETACH\", \"PROG_TEST_RUN\", \"PROG_GET_NEXT_ID\", \"MAP_GET_NEXT_ID\",\n\t\"PROG_GET_FD_BY_ID\", \"MAP_GET_FD_BY_ID\", \"OBJ_GET_INFO_BY_FD\",\n\t\"PROG_QUERY\", \"RAW_TRACEPOINT_OPEN\", \"BTF_LOAD\", \"BTF_GET_FD_BY_ID\",\n\t\"TASK_FD_QUERY\", \"MAP_LOOKUP_AND_DELETE_ELEM\", \"MAP_FREEZE\",\n\t\"BTF_GET_NEXT_ID\", \"MAP_LOOKUP_BATCH\", \"MAP_LOOKUP_AND_DELETE_BATCH\",\n\t\"MAP_UPDATE_BATCH\", \"MAP_DELETE_BATCH\", \"LINK_CREATE\", \"LINK_UPDATE\",\n\t\"LINK_GET_FD_BY_ID\", \"LINK_GET_NEXT_ID\", \"ENABLE_STATS\", \"ITER_CREATE\",\n\t\"LINK_DETACH\", \"PROG_BIND_MAP\",\n};\nstatic DEFINE_STRARRAY(bpf_cmd, \"BPF_\");\n\nstatic const char *fsmount_flags[] = {\n\t[1] = \"CLOEXEC\",\n};\nstatic DEFINE_STRARRAY(fsmount_flags, \"FSMOUNT_\");\n\n#include \"trace/beauty/generated/fsconfig_arrays.c\"\n\nstatic DEFINE_STRARRAY(fsconfig_cmds, \"FSCONFIG_\");\n\nstatic const char *epoll_ctl_ops[] = { \"ADD\", \"DEL\", \"MOD\", };\nstatic DEFINE_STRARRAY_OFFSET(epoll_ctl_ops, \"EPOLL_CTL_\", 1);\n\nstatic const char *itimers[] = { \"REAL\", \"VIRTUAL\", \"PROF\", };\nstatic DEFINE_STRARRAY(itimers, \"ITIMER_\");\n\nstatic const char *keyctl_options[] = {\n\t\"GET_KEYRING_ID\", \"JOIN_SESSION_KEYRING\", \"UPDATE\", \"REVOKE\", \"CHOWN\",\n\t\"SETPERM\", \"DESCRIBE\", \"CLEAR\", \"LINK\", \"UNLINK\", \"SEARCH\", \"READ\",\n\t\"INSTANTIATE\", \"NEGATE\", \"SET_REQKEY_KEYRING\", \"SET_TIMEOUT\",\n\t\"ASSUME_AUTHORITY\", \"GET_SECURITY\", \"SESSION_TO_PARENT\", \"REJECT\",\n\t\"INSTANTIATE_IOV\", \"INVALIDATE\", \"GET_PERSISTENT\",\n};\nstatic DEFINE_STRARRAY(keyctl_options, \"KEYCTL_\");\n\nstatic const char *whences[] = { \"SET\", \"CUR\", \"END\",\n#ifdef SEEK_DATA\n\"DATA\",\n#endif\n#ifdef SEEK_HOLE\n\"HOLE\",\n#endif\n};\nstatic DEFINE_STRARRAY(whences, \"SEEK_\");\n\nstatic const char *fcntl_cmds[] = {\n\t\"DUPFD\", \"GETFD\", \"SETFD\", \"GETFL\", \"SETFL\", \"GETLK\", \"SETLK\",\n\t\"SETLKW\", \"SETOWN\", \"GETOWN\", \"SETSIG\", \"GETSIG\", \"GETLK64\",\n\t\"SETLK64\", \"SETLKW64\", \"SETOWN_EX\", \"GETOWN_EX\",\n\t\"GETOWNER_UIDS\",\n};\nstatic DEFINE_STRARRAY(fcntl_cmds, \"F_\");\n\nstatic const char *fcntl_linux_specific_cmds[] = {\n\t\"SETLEASE\", \"GETLEASE\", \"NOTIFY\", [5] =\t\"CANCELLK\", \"DUPFD_CLOEXEC\",\n\t\"SETPIPE_SZ\", \"GETPIPE_SZ\", \"ADD_SEALS\", \"GET_SEALS\",\n\t\"GET_RW_HINT\", \"SET_RW_HINT\", \"GET_FILE_RW_HINT\", \"SET_FILE_RW_HINT\",\n};\n\nstatic DEFINE_STRARRAY_OFFSET(fcntl_linux_specific_cmds, \"F_\", F_LINUX_SPECIFIC_BASE);\n\nstatic struct strarray *fcntl_cmds_arrays[] = {\n\t&strarray__fcntl_cmds,\n\t&strarray__fcntl_linux_specific_cmds,\n};\n\nstatic DEFINE_STRARRAYS(fcntl_cmds_arrays);\n\nstatic const char *rlimit_resources[] = {\n\t\"CPU\", \"FSIZE\", \"DATA\", \"STACK\", \"CORE\", \"RSS\", \"NPROC\", \"NOFILE\",\n\t\"MEMLOCK\", \"AS\", \"LOCKS\", \"SIGPENDING\", \"MSGQUEUE\", \"NICE\", \"RTPRIO\",\n\t\"RTTIME\",\n};\nstatic DEFINE_STRARRAY(rlimit_resources, \"RLIMIT_\");\n\nstatic const char *sighow[] = { \"BLOCK\", \"UNBLOCK\", \"SETMASK\", };\nstatic DEFINE_STRARRAY(sighow, \"SIG_\");\n\nstatic const char *clockid[] = {\n\t\"REALTIME\", \"MONOTONIC\", \"PROCESS_CPUTIME_ID\", \"THREAD_CPUTIME_ID\",\n\t\"MONOTONIC_RAW\", \"REALTIME_COARSE\", \"MONOTONIC_COARSE\", \"BOOTTIME\",\n\t\"REALTIME_ALARM\", \"BOOTTIME_ALARM\", \"SGI_CYCLE\", \"TAI\"\n};\nstatic DEFINE_STRARRAY(clockid, \"CLOCK_\");\n\nstatic size_t syscall_arg__scnprintf_access_mode(char *bf, size_t size,\n\t\t\t\t\t\t struct syscall_arg *arg)\n{\n\tbool show_prefix = arg->show_string_prefix;\n\tconst char *suffix = \"_OK\";\n\tsize_t printed = 0;\n\tint mode = arg->val;\n\n\tif (mode == F_OK)  \n\t\treturn scnprintf(bf, size, \"F%s\", show_prefix ? suffix : \"\");\n#define\tP_MODE(n) \\\n\tif (mode & n##_OK) { \\\n\t\tprinted += scnprintf(bf + printed, size - printed, \"%s%s\", #n, show_prefix ? suffix : \"\"); \\\n\t\tmode &= ~n##_OK; \\\n\t}\n\n\tP_MODE(R);\n\tP_MODE(W);\n\tP_MODE(X);\n#undef P_MODE\n\n\tif (mode)\n\t\tprinted += scnprintf(bf + printed, size - printed, \"|%#x\", mode);\n\n\treturn printed;\n}\n\n#define SCA_ACCMODE syscall_arg__scnprintf_access_mode\n\nstatic size_t syscall_arg__scnprintf_filename(char *bf, size_t size,\n\t\t\t\t\t      struct syscall_arg *arg);\n\n#define SCA_FILENAME syscall_arg__scnprintf_filename\n\nstatic size_t syscall_arg__scnprintf_pipe_flags(char *bf, size_t size,\n\t\t\t\t\t\tstruct syscall_arg *arg)\n{\n\tbool show_prefix = arg->show_string_prefix;\n\tconst char *prefix = \"O_\";\n\tint printed = 0, flags = arg->val;\n\n#define\tP_FLAG(n) \\\n\tif (flags & O_##n) { \\\n\t\tprinted += scnprintf(bf + printed, size - printed, \"%s%s%s\", printed ? \"|\" : \"\", show_prefix ? prefix : \"\", #n); \\\n\t\tflags &= ~O_##n; \\\n\t}\n\n\tP_FLAG(CLOEXEC);\n\tP_FLAG(NONBLOCK);\n#undef P_FLAG\n\n\tif (flags)\n\t\tprinted += scnprintf(bf + printed, size - printed, \"%s%#x\", printed ? \"|\" : \"\", flags);\n\n\treturn printed;\n}\n\n#define SCA_PIPE_FLAGS syscall_arg__scnprintf_pipe_flags\n\n#ifndef GRND_NONBLOCK\n#define GRND_NONBLOCK\t0x0001\n#endif\n#ifndef GRND_RANDOM\n#define GRND_RANDOM\t0x0002\n#endif\n\nstatic size_t syscall_arg__scnprintf_getrandom_flags(char *bf, size_t size,\n\t\t\t\t\t\t   struct syscall_arg *arg)\n{\n\tbool show_prefix = arg->show_string_prefix;\n\tconst char *prefix = \"GRND_\";\n\tint printed = 0, flags = arg->val;\n\n#define\tP_FLAG(n) \\\n\tif (flags & GRND_##n) { \\\n\t\tprinted += scnprintf(bf + printed, size - printed, \"%s%s%s\", printed ? \"|\" : \"\", show_prefix ? prefix : \"\", #n); \\\n\t\tflags &= ~GRND_##n; \\\n\t}\n\n\tP_FLAG(RANDOM);\n\tP_FLAG(NONBLOCK);\n#undef P_FLAG\n\n\tif (flags)\n\t\tprinted += scnprintf(bf + printed, size - printed, \"%s%#x\", printed ? \"|\" : \"\", flags);\n\n\treturn printed;\n}\n\n#define SCA_GETRANDOM_FLAGS syscall_arg__scnprintf_getrandom_flags\n\n#define STRARRAY(name, array) \\\n\t  { .scnprintf\t= SCA_STRARRAY, \\\n\t    .strtoul\t= STUL_STRARRAY, \\\n\t    .parm\t= &strarray__##array, }\n\n#define STRARRAY_FLAGS(name, array) \\\n\t  { .scnprintf\t= SCA_STRARRAY_FLAGS, \\\n\t    .strtoul\t= STUL_STRARRAY_FLAGS, \\\n\t    .parm\t= &strarray__##array, }\n\n#include \"trace/beauty/arch_errno_names.c\"\n#include \"trace/beauty/eventfd.c\"\n#include \"trace/beauty/futex_op.c\"\n#include \"trace/beauty/futex_val3.c\"\n#include \"trace/beauty/mmap.c\"\n#include \"trace/beauty/mode_t.c\"\n#include \"trace/beauty/msg_flags.c\"\n#include \"trace/beauty/open_flags.c\"\n#include \"trace/beauty/perf_event_open.c\"\n#include \"trace/beauty/pid.c\"\n#include \"trace/beauty/sched_policy.c\"\n#include \"trace/beauty/seccomp.c\"\n#include \"trace/beauty/signum.c\"\n#include \"trace/beauty/socket_type.c\"\n#include \"trace/beauty/waitid_options.c\"\n\nstatic const struct syscall_fmt syscall_fmts[] = {\n\t{ .name\t    = \"access\",\n\t  .arg = { [1] = { .scnprintf = SCA_ACCMODE,    }, }, },\n\t{ .name\t    = \"arch_prctl\",\n\t  .arg = { [0] = { .scnprintf = SCA_X86_ARCH_PRCTL_CODE,   },\n\t\t   [1] = { .scnprintf = SCA_PTR,   }, }, },\n\t{ .name\t    = \"bind\",\n\t  .arg = { [0] = { .scnprintf = SCA_INT,   },\n\t\t   [1] = { .scnprintf = SCA_SOCKADDR,   },\n\t\t   [2] = { .scnprintf = SCA_INT,   }, }, },\n\t{ .name\t    = \"bpf\",\n\t  .arg = { [0] = STRARRAY(cmd, bpf_cmd), }, },\n\t{ .name\t    = \"brk\",\t    .hexret = true,\n\t  .arg = { [0] = { .scnprintf = SCA_PTR,   }, }, },\n\t{ .name     = \"clock_gettime\",\n\t  .arg = { [0] = STRARRAY(clk_id, clockid), }, },\n\t{ .name\t    = \"clock_nanosleep\",\n\t  .arg = { [2] = { .scnprintf = SCA_TIMESPEC,    }, }, },\n\t{ .name\t    = \"clone\",\t    .errpid = true, .nr_args = 5,\n\t  .arg = { [0] = { .name = \"flags\",\t    .scnprintf = SCA_CLONE_FLAGS, },\n\t\t   [1] = { .name = \"child_stack\",   .scnprintf = SCA_HEX, },\n\t\t   [2] = { .name = \"parent_tidptr\", .scnprintf = SCA_HEX, },\n\t\t   [3] = { .name = \"child_tidptr\",  .scnprintf = SCA_HEX, },\n\t\t   [4] = { .name = \"tls\",\t    .scnprintf = SCA_HEX, }, }, },\n\t{ .name\t    = \"close\",\n\t  .arg = { [0] = { .scnprintf = SCA_CLOSE_FD,   }, }, },\n\t{ .name\t    = \"connect\",\n\t  .arg = { [0] = { .scnprintf = SCA_INT,   },\n\t\t   [1] = { .scnprintf = SCA_SOCKADDR,   },\n\t\t   [2] = { .scnprintf = SCA_INT,   }, }, },\n\t{ .name\t    = \"epoll_ctl\",\n\t  .arg = { [1] = STRARRAY(op, epoll_ctl_ops), }, },\n\t{ .name\t    = \"eventfd2\",\n\t  .arg = { [1] = { .scnprintf = SCA_EFD_FLAGS,   }, }, },\n\t{ .name\t    = \"fchmodat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"fchownat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"fcntl\",\n\t  .arg = { [1] = { .scnprintf = SCA_FCNTL_CMD,   \n\t\t\t   .strtoul   = STUL_STRARRAYS,\n\t\t\t   .parm      = &strarrays__fcntl_cmds_arrays,\n\t\t\t   .show_zero = true, },\n\t\t   [2] = { .scnprintf =  SCA_FCNTL_ARG,   }, }, },\n\t{ .name\t    = \"flock\",\n\t  .arg = { [1] = { .scnprintf = SCA_FLOCK,   }, }, },\n\t{ .name     = \"fsconfig\",\n\t  .arg = { [1] = STRARRAY(cmd, fsconfig_cmds), }, },\n\t{ .name     = \"fsmount\",\n\t  .arg = { [1] = STRARRAY_FLAGS(flags, fsmount_flags),\n\t\t   [2] = { .scnprintf = SCA_FSMOUNT_ATTR_FLAGS,   }, }, },\n\t{ .name     = \"fspick\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,\t    },\n\t\t   [1] = { .scnprintf = SCA_FILENAME,\t    },\n\t\t   [2] = { .scnprintf = SCA_FSPICK_FLAGS,   }, }, },\n\t{ .name\t    = \"fstat\", .alias = \"newfstat\", },\n\t{ .name\t    = \"fstatat\", .alias = \"newfstatat\", },\n\t{ .name\t    = \"futex\",\n\t  .arg = { [1] = { .scnprintf = SCA_FUTEX_OP,   },\n\t\t   [5] = { .scnprintf = SCA_FUTEX_VAL3,   }, }, },\n\t{ .name\t    = \"futimesat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"getitimer\",\n\t  .arg = { [0] = STRARRAY(which, itimers), }, },\n\t{ .name\t    = \"getpid\",\t    .errpid = true, },\n\t{ .name\t    = \"getpgid\",    .errpid = true, },\n\t{ .name\t    = \"getppid\",    .errpid = true, },\n\t{ .name\t    = \"getrandom\",\n\t  .arg = { [2] = { .scnprintf = SCA_GETRANDOM_FLAGS,   }, }, },\n\t{ .name\t    = \"getrlimit\",\n\t  .arg = { [0] = STRARRAY(resource, rlimit_resources), }, },\n\t{ .name\t    = \"getsockopt\",\n\t  .arg = { [1] = STRARRAY(level, socket_level), }, },\n\t{ .name\t    = \"gettid\",\t    .errpid = true, },\n\t{ .name\t    = \"ioctl\",\n\t  .arg = {\n#if defined(__i386__) || defined(__x86_64__)\n \n\t\t   [1] = { .scnprintf = SCA_IOCTL_CMD,   },\n\t\t   [2] = { .scnprintf = SCA_HEX,   }, }, },\n#else\n\t\t   [2] = { .scnprintf = SCA_HEX,   }, }, },\n#endif\n\t{ .name\t    = \"kcmp\",\t    .nr_args = 5,\n\t  .arg = { [0] = { .name = \"pid1\",\t.scnprintf = SCA_PID, },\n\t\t   [1] = { .name = \"pid2\",\t.scnprintf = SCA_PID, },\n\t\t   [2] = { .name = \"type\",\t.scnprintf = SCA_KCMP_TYPE, },\n\t\t   [3] = { .name = \"idx1\",\t.scnprintf = SCA_KCMP_IDX, },\n\t\t   [4] = { .name = \"idx2\",\t.scnprintf = SCA_KCMP_IDX, }, }, },\n\t{ .name\t    = \"keyctl\",\n\t  .arg = { [0] = STRARRAY(option, keyctl_options), }, },\n\t{ .name\t    = \"kill\",\n\t  .arg = { [1] = { .scnprintf = SCA_SIGNUM,   }, }, },\n\t{ .name\t    = \"linkat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"lseek\",\n\t  .arg = { [2] = STRARRAY(whence, whences), }, },\n\t{ .name\t    = \"lstat\", .alias = \"newlstat\", },\n\t{ .name     = \"madvise\",\n\t  .arg = { [0] = { .scnprintf = SCA_HEX,        },\n\t\t   [2] = { .scnprintf = SCA_MADV_BHV,   }, }, },\n\t{ .name\t    = \"mkdirat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"mknodat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"mmap\",\t    .hexret = true,\n \n#if defined(__s390x__)\n\t.alias = \"old_mmap\",\n#endif\n\t  .arg = { [2] = { .scnprintf = SCA_MMAP_PROT,\t  },\n\t\t   [3] = { .scnprintf = SCA_MMAP_FLAGS,\t \n\t\t\t   .strtoul   = STUL_STRARRAY_FLAGS,\n\t\t\t   .parm      = &strarray__mmap_flags, },\n\t\t   [5] = { .scnprintf = SCA_HEX,\t  }, }, },\n\t{ .name\t    = \"mount\",\n\t  .arg = { [0] = { .scnprintf = SCA_FILENAME,   },\n\t\t   [3] = { .scnprintf = SCA_MOUNT_FLAGS,  \n\t\t\t   .mask_val  = SCAMV_MOUNT_FLAGS,   }, }, },\n\t{ .name\t    = \"move_mount\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,\t  },\n\t\t   [1] = { .scnprintf = SCA_FILENAME,   },\n\t\t   [2] = { .scnprintf = SCA_FDAT,\t  },\n\t\t   [3] = { .scnprintf = SCA_FILENAME,   },\n\t\t   [4] = { .scnprintf = SCA_MOVE_MOUNT_FLAGS,   }, }, },\n\t{ .name\t    = \"mprotect\",\n\t  .arg = { [0] = { .scnprintf = SCA_HEX,\t  },\n\t\t   [2] = { .scnprintf = SCA_MMAP_PROT,\t  }, }, },\n\t{ .name\t    = \"mq_unlink\",\n\t  .arg = { [0] = { .scnprintf = SCA_FILENAME,   }, }, },\n\t{ .name\t    = \"mremap\",\t    .hexret = true,\n\t  .arg = { [3] = { .scnprintf = SCA_MREMAP_FLAGS,   }, }, },\n\t{ .name\t    = \"name_to_handle_at\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"newfstatat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"open\",\n\t  .arg = { [1] = { .scnprintf = SCA_OPEN_FLAGS,   }, }, },\n\t{ .name\t    = \"open_by_handle_at\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,\t  },\n\t\t   [2] = { .scnprintf = SCA_OPEN_FLAGS,   }, }, },\n\t{ .name\t    = \"openat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,\t  },\n\t\t   [2] = { .scnprintf = SCA_OPEN_FLAGS,   }, }, },\n\t{ .name\t    = \"perf_event_open\",\n\t  .arg = { [0] = { .scnprintf = SCA_PERF_ATTR,    },\n\t\t   [2] = { .scnprintf = SCA_INT,\t  },\n\t\t   [3] = { .scnprintf = SCA_FD,\t\t  },\n\t\t   [4] = { .scnprintf = SCA_PERF_FLAGS,   }, }, },\n\t{ .name\t    = \"pipe2\",\n\t  .arg = { [1] = { .scnprintf = SCA_PIPE_FLAGS,   }, }, },\n\t{ .name\t    = \"pkey_alloc\",\n\t  .arg = { [1] = { .scnprintf = SCA_PKEY_ALLOC_ACCESS_RIGHTS,\t  }, }, },\n\t{ .name\t    = \"pkey_free\",\n\t  .arg = { [0] = { .scnprintf = SCA_INT,\t  }, }, },\n\t{ .name\t    = \"pkey_mprotect\",\n\t  .arg = { [0] = { .scnprintf = SCA_HEX,\t  },\n\t\t   [2] = { .scnprintf = SCA_MMAP_PROT,\t  },\n\t\t   [3] = { .scnprintf = SCA_INT,\t  }, }, },\n\t{ .name\t    = \"poll\", .timeout = true, },\n\t{ .name\t    = \"ppoll\", .timeout = true, },\n\t{ .name\t    = \"prctl\",\n\t  .arg = { [0] = { .scnprintf = SCA_PRCTL_OPTION,  \n\t\t\t   .strtoul   = STUL_STRARRAY,\n\t\t\t   .parm      = &strarray__prctl_options, },\n\t\t   [1] = { .scnprintf = SCA_PRCTL_ARG2,   },\n\t\t   [2] = { .scnprintf = SCA_PRCTL_ARG3,   }, }, },\n\t{ .name\t    = \"pread\", .alias = \"pread64\", },\n\t{ .name\t    = \"preadv\", .alias = \"pread\", },\n\t{ .name\t    = \"prlimit64\",\n\t  .arg = { [1] = STRARRAY(resource, rlimit_resources), }, },\n\t{ .name\t    = \"pwrite\", .alias = \"pwrite64\", },\n\t{ .name\t    = \"readlinkat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"recvfrom\",\n\t  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS,   }, }, },\n\t{ .name\t    = \"recvmmsg\",\n\t  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS,   }, }, },\n\t{ .name\t    = \"recvmsg\",\n\t  .arg = { [2] = { .scnprintf = SCA_MSG_FLAGS,   }, }, },\n\t{ .name\t    = \"renameat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   },\n\t\t   [2] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"renameat2\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   },\n\t\t   [2] = { .scnprintf = SCA_FDAT,   },\n\t\t   [4] = { .scnprintf = SCA_RENAMEAT2_FLAGS,   }, }, },\n\t{ .name\t    = \"rt_sigaction\",\n\t  .arg = { [0] = { .scnprintf = SCA_SIGNUM,   }, }, },\n\t{ .name\t    = \"rt_sigprocmask\",\n\t  .arg = { [0] = STRARRAY(how, sighow), }, },\n\t{ .name\t    = \"rt_sigqueueinfo\",\n\t  .arg = { [1] = { .scnprintf = SCA_SIGNUM,   }, }, },\n\t{ .name\t    = \"rt_tgsigqueueinfo\",\n\t  .arg = { [2] = { .scnprintf = SCA_SIGNUM,   }, }, },\n\t{ .name\t    = \"sched_setscheduler\",\n\t  .arg = { [1] = { .scnprintf = SCA_SCHED_POLICY,   }, }, },\n\t{ .name\t    = \"seccomp\",\n\t  .arg = { [0] = { .scnprintf = SCA_SECCOMP_OP,\t     },\n\t\t   [1] = { .scnprintf = SCA_SECCOMP_FLAGS,   }, }, },\n\t{ .name\t    = \"select\", .timeout = true, },\n\t{ .name\t    = \"sendfile\", .alias = \"sendfile64\", },\n\t{ .name\t    = \"sendmmsg\",\n\t  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS,   }, }, },\n\t{ .name\t    = \"sendmsg\",\n\t  .arg = { [2] = { .scnprintf = SCA_MSG_FLAGS,   }, }, },\n\t{ .name\t    = \"sendto\",\n\t  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS,   },\n\t\t   [4] = { .scnprintf = SCA_SOCKADDR,   }, }, },\n\t{ .name\t    = \"set_tid_address\", .errpid = true, },\n\t{ .name\t    = \"setitimer\",\n\t  .arg = { [0] = STRARRAY(which, itimers), }, },\n\t{ .name\t    = \"setrlimit\",\n\t  .arg = { [0] = STRARRAY(resource, rlimit_resources), }, },\n\t{ .name\t    = \"setsockopt\",\n\t  .arg = { [1] = STRARRAY(level, socket_level), }, },\n\t{ .name\t    = \"socket\",\n\t  .arg = { [0] = STRARRAY(family, socket_families),\n\t\t   [1] = { .scnprintf = SCA_SK_TYPE,   },\n\t\t   [2] = { .scnprintf = SCA_SK_PROTO,   }, }, },\n\t{ .name\t    = \"socketpair\",\n\t  .arg = { [0] = STRARRAY(family, socket_families),\n\t\t   [1] = { .scnprintf = SCA_SK_TYPE,   },\n\t\t   [2] = { .scnprintf = SCA_SK_PROTO,   }, }, },\n\t{ .name\t    = \"stat\", .alias = \"newstat\", },\n\t{ .name\t    = \"statx\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,\t   },\n\t\t   [2] = { .scnprintf = SCA_STATX_FLAGS,   } ,\n\t\t   [3] = { .scnprintf = SCA_STATX_MASK,\t   }, }, },\n\t{ .name\t    = \"swapoff\",\n\t  .arg = { [0] = { .scnprintf = SCA_FILENAME,   }, }, },\n\t{ .name\t    = \"swapon\",\n\t  .arg = { [0] = { .scnprintf = SCA_FILENAME,   }, }, },\n\t{ .name\t    = \"symlinkat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"sync_file_range\",\n\t  .arg = { [3] = { .scnprintf = SCA_SYNC_FILE_RANGE_FLAGS,   }, }, },\n\t{ .name\t    = \"tgkill\",\n\t  .arg = { [2] = { .scnprintf = SCA_SIGNUM,   }, }, },\n\t{ .name\t    = \"tkill\",\n\t  .arg = { [1] = { .scnprintf = SCA_SIGNUM,   }, }, },\n\t{ .name     = \"umount2\", .alias = \"umount\",\n\t  .arg = { [0] = { .scnprintf = SCA_FILENAME,   }, }, },\n\t{ .name\t    = \"uname\", .alias = \"newuname\", },\n\t{ .name\t    = \"unlinkat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"utimensat\",\n\t  .arg = { [0] = { .scnprintf = SCA_FDAT,   }, }, },\n\t{ .name\t    = \"wait4\",\t    .errpid = true,\n\t  .arg = { [2] = { .scnprintf = SCA_WAITID_OPTIONS,   }, }, },\n\t{ .name\t    = \"waitid\",\t    .errpid = true,\n\t  .arg = { [3] = { .scnprintf = SCA_WAITID_OPTIONS,   }, }, },\n};\n\nstatic int syscall_fmt__cmp(const void *name, const void *fmtp)\n{\n\tconst struct syscall_fmt *fmt = fmtp;\n\treturn strcmp(name, fmt->name);\n}\n\nstatic const struct syscall_fmt *__syscall_fmt__find(const struct syscall_fmt *fmts,\n\t\t\t\t\t\t     const int nmemb,\n\t\t\t\t\t\t     const char *name)\n{\n\treturn bsearch(name, fmts, nmemb, sizeof(struct syscall_fmt), syscall_fmt__cmp);\n}\n\nstatic const struct syscall_fmt *syscall_fmt__find(const char *name)\n{\n\tconst int nmemb = ARRAY_SIZE(syscall_fmts);\n\treturn __syscall_fmt__find(syscall_fmts, nmemb, name);\n}\n\nstatic const struct syscall_fmt *__syscall_fmt__find_by_alias(const struct syscall_fmt *fmts,\n\t\t\t\t\t\t\t      const int nmemb, const char *alias)\n{\n\tint i;\n\n\tfor (i = 0; i < nmemb; ++i) {\n\t\tif (fmts[i].alias && strcmp(fmts[i].alias, alias) == 0)\n\t\t\treturn &fmts[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct syscall_fmt *syscall_fmt__find_by_alias(const char *alias)\n{\n\tconst int nmemb = ARRAY_SIZE(syscall_fmts);\n\treturn __syscall_fmt__find_by_alias(syscall_fmts, nmemb, alias);\n}\n\n \nstruct syscall {\n\tstruct tep_event    *tp_format;\n\tint\t\t    nr_args;\n\tint\t\t    args_size;\n\tstruct {\n\t\tstruct bpf_program *sys_enter,\n\t\t\t\t   *sys_exit;\n\t}\t\t    bpf_prog;\n\tbool\t\t    is_exit;\n\tbool\t\t    is_open;\n\tbool\t\t    nonexistent;\n\tstruct tep_format_field *args;\n\tconst char\t    *name;\n\tconst struct syscall_fmt  *fmt;\n\tstruct syscall_arg_fmt *arg_fmt;\n};\n\n \nstatic size_t fprintf_duration(unsigned long t, bool calculated, FILE *fp)\n{\n\tdouble duration = (double)t / NSEC_PER_MSEC;\n\tsize_t printed = fprintf(fp, \"(\");\n\n\tif (!calculated)\n\t\tprinted += fprintf(fp, \"         \");\n\telse if (duration >= 1.0)\n\t\tprinted += color_fprintf(fp, PERF_COLOR_RED, \"%6.3f ms\", duration);\n\telse if (duration >= 0.01)\n\t\tprinted += color_fprintf(fp, PERF_COLOR_YELLOW, \"%6.3f ms\", duration);\n\telse\n\t\tprinted += color_fprintf(fp, PERF_COLOR_NORMAL, \"%6.3f ms\", duration);\n\treturn printed + fprintf(fp, \"): \");\n}\n\n \nstruct thread_trace {\n\tu64\t\t  entry_time;\n\tbool\t\t  entry_pending;\n\tunsigned long\t  nr_events;\n\tunsigned long\t  pfmaj, pfmin;\n\tchar\t\t  *entry_str;\n\tdouble\t\t  runtime_ms;\n\tsize_t\t\t  (*ret_scnprintf)(char *bf, size_t size, struct syscall_arg *arg);\n        struct {\n\t\tunsigned long ptr;\n\t\tshort int     entry_str_pos;\n\t\tbool\t      pending_open;\n\t\tunsigned int  namelen;\n\t\tchar\t      *name;\n\t} filename;\n\tstruct {\n\t\tint\t      max;\n\t\tstruct file   *table;\n\t} files;\n\n\tstruct intlist *syscall_stats;\n};\n\nstatic struct thread_trace *thread_trace__new(void)\n{\n\tstruct thread_trace *ttrace =  zalloc(sizeof(struct thread_trace));\n\n\tif (ttrace) {\n\t\tttrace->files.max = -1;\n\t\tttrace->syscall_stats = intlist__new(NULL);\n\t}\n\n\treturn ttrace;\n}\n\nstatic void thread_trace__free_files(struct thread_trace *ttrace);\n\nstatic void thread_trace__delete(void *pttrace)\n{\n\tstruct thread_trace *ttrace = pttrace;\n\n\tif (!ttrace)\n\t\treturn;\n\n\tintlist__delete(ttrace->syscall_stats);\n\tttrace->syscall_stats = NULL;\n\tthread_trace__free_files(ttrace);\n\tzfree(&ttrace->entry_str);\n\tfree(ttrace);\n}\n\nstatic struct thread_trace *thread__trace(struct thread *thread, FILE *fp)\n{\n\tstruct thread_trace *ttrace;\n\n\tif (thread == NULL)\n\t\tgoto fail;\n\n\tif (thread__priv(thread) == NULL)\n\t\tthread__set_priv(thread, thread_trace__new());\n\n\tif (thread__priv(thread) == NULL)\n\t\tgoto fail;\n\n\tttrace = thread__priv(thread);\n\t++ttrace->nr_events;\n\n\treturn ttrace;\nfail:\n\tcolor_fprintf(fp, PERF_COLOR_RED,\n\t\t      \"WARNING: not enough memory, dropping samples!\\n\");\n\treturn NULL;\n}\n\n\nvoid syscall_arg__set_ret_scnprintf(struct syscall_arg *arg,\n\t\t\t\t    size_t (*ret_scnprintf)(char *bf, size_t size, struct syscall_arg *arg))\n{\n\tstruct thread_trace *ttrace = thread__priv(arg->thread);\n\n\tttrace->ret_scnprintf = ret_scnprintf;\n}\n\n#define TRACE_PFMAJ\t\t(1 << 0)\n#define TRACE_PFMIN\t\t(1 << 1)\n\nstatic const size_t trace__entry_str_size = 2048;\n\nstatic void thread_trace__free_files(struct thread_trace *ttrace)\n{\n\tfor (int i = 0; i < ttrace->files.max; ++i) {\n\t\tstruct file *file = ttrace->files.table + i;\n\t\tzfree(&file->pathname);\n\t}\n\n\tzfree(&ttrace->files.table);\n\tttrace->files.max  = -1;\n}\n\nstatic struct file *thread_trace__files_entry(struct thread_trace *ttrace, int fd)\n{\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tif (fd > ttrace->files.max) {\n\t\tstruct file *nfiles = realloc(ttrace->files.table, (fd + 1) * sizeof(struct file));\n\n\t\tif (nfiles == NULL)\n\t\t\treturn NULL;\n\n\t\tif (ttrace->files.max != -1) {\n\t\t\tmemset(nfiles + ttrace->files.max + 1, 0,\n\t\t\t       (fd - ttrace->files.max) * sizeof(struct file));\n\t\t} else {\n\t\t\tmemset(nfiles, 0, (fd + 1) * sizeof(struct file));\n\t\t}\n\n\t\tttrace->files.table = nfiles;\n\t\tttrace->files.max   = fd;\n\t}\n\n\treturn ttrace->files.table + fd;\n}\n\nstruct file *thread__files_entry(struct thread *thread, int fd)\n{\n\treturn thread_trace__files_entry(thread__priv(thread), fd);\n}\n\nstatic int trace__set_fd_pathname(struct thread *thread, int fd, const char *pathname)\n{\n\tstruct thread_trace *ttrace = thread__priv(thread);\n\tstruct file *file = thread_trace__files_entry(ttrace, fd);\n\n\tif (file != NULL) {\n\t\tstruct stat st;\n\t\tif (stat(pathname, &st) == 0)\n\t\t\tfile->dev_maj = major(st.st_rdev);\n\t\tfile->pathname = strdup(pathname);\n\t\tif (file->pathname)\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int thread__read_fd_path(struct thread *thread, int fd)\n{\n\tchar linkname[PATH_MAX], pathname[PATH_MAX];\n\tstruct stat st;\n\tint ret;\n\n\tif (thread__pid(thread) == thread__tid(thread)) {\n\t\tscnprintf(linkname, sizeof(linkname),\n\t\t\t  \"/proc/%d/fd/%d\", thread__pid(thread), fd);\n\t} else {\n\t\tscnprintf(linkname, sizeof(linkname),\n\t\t\t  \"/proc/%d/task/%d/fd/%d\",\n\t\t\t  thread__pid(thread), thread__tid(thread), fd);\n\t}\n\n\tif (lstat(linkname, &st) < 0 || st.st_size + 1 > (off_t)sizeof(pathname))\n\t\treturn -1;\n\n\tret = readlink(linkname, pathname, sizeof(pathname));\n\n\tif (ret < 0 || ret > st.st_size)\n\t\treturn -1;\n\n\tpathname[ret] = '\\0';\n\treturn trace__set_fd_pathname(thread, fd, pathname);\n}\n\nstatic const char *thread__fd_path(struct thread *thread, int fd,\n\t\t\t\t   struct trace *trace)\n{\n\tstruct thread_trace *ttrace = thread__priv(thread);\n\n\tif (ttrace == NULL || trace->fd_path_disabled)\n\t\treturn NULL;\n\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tif ((fd > ttrace->files.max || ttrace->files.table[fd].pathname == NULL)) {\n\t\tif (!trace->live)\n\t\t\treturn NULL;\n\t\t++trace->stats.proc_getname;\n\t\tif (thread__read_fd_path(thread, fd))\n\t\t\treturn NULL;\n\t}\n\n\treturn ttrace->files.table[fd].pathname;\n}\n\nsize_t syscall_arg__scnprintf_fd(char *bf, size_t size, struct syscall_arg *arg)\n{\n\tint fd = arg->val;\n\tsize_t printed = scnprintf(bf, size, \"%d\", fd);\n\tconst char *path = thread__fd_path(arg->thread, fd, arg->trace);\n\n\tif (path)\n\t\tprinted += scnprintf(bf + printed, size - printed, \"<%s>\", path);\n\n\treturn printed;\n}\n\nsize_t pid__scnprintf_fd(struct trace *trace, pid_t pid, int fd, char *bf, size_t size)\n{\n        size_t printed = scnprintf(bf, size, \"%d\", fd);\n\tstruct thread *thread = machine__find_thread(trace->host, pid, pid);\n\n\tif (thread) {\n\t\tconst char *path = thread__fd_path(thread, fd, trace);\n\n\t\tif (path)\n\t\t\tprinted += scnprintf(bf + printed, size - printed, \"<%s>\", path);\n\n\t\tthread__put(thread);\n\t}\n\n        return printed;\n}\n\nstatic size_t syscall_arg__scnprintf_close_fd(char *bf, size_t size,\n\t\t\t\t\t      struct syscall_arg *arg)\n{\n\tint fd = arg->val;\n\tsize_t printed = syscall_arg__scnprintf_fd(bf, size, arg);\n\tstruct thread_trace *ttrace = thread__priv(arg->thread);\n\n\tif (ttrace && fd >= 0 && fd <= ttrace->files.max)\n\t\tzfree(&ttrace->files.table[fd].pathname);\n\n\treturn printed;\n}\n\nstatic void thread__set_filename_pos(struct thread *thread, const char *bf,\n\t\t\t\t     unsigned long ptr)\n{\n\tstruct thread_trace *ttrace = thread__priv(thread);\n\n\tttrace->filename.ptr = ptr;\n\tttrace->filename.entry_str_pos = bf - ttrace->entry_str;\n}\n\nstatic size_t syscall_arg__scnprintf_augmented_string(struct syscall_arg *arg, char *bf, size_t size)\n{\n\tstruct augmented_arg *augmented_arg = arg->augmented.args;\n\tsize_t printed = scnprintf(bf, size, \"\\\"%.*s\\\"\", augmented_arg->size, augmented_arg->value);\n\t \n\tint consumed = sizeof(*augmented_arg) + augmented_arg->size;\n\n\targ->augmented.args = ((void *)arg->augmented.args) + consumed;\n\targ->augmented.size -= consumed;\n\n\treturn printed;\n}\n\nstatic size_t syscall_arg__scnprintf_filename(char *bf, size_t size,\n\t\t\t\t\t      struct syscall_arg *arg)\n{\n\tunsigned long ptr = arg->val;\n\n\tif (arg->augmented.args)\n\t\treturn syscall_arg__scnprintf_augmented_string(arg, bf, size);\n\n\tif (!arg->trace->vfs_getname)\n\t\treturn scnprintf(bf, size, \"%#x\", ptr);\n\n\tthread__set_filename_pos(arg->thread, bf, ptr);\n\treturn 0;\n}\n\nstatic bool trace__filter_duration(struct trace *trace, double t)\n{\n\treturn t < (trace->duration_filter * NSEC_PER_MSEC);\n}\n\nstatic size_t __trace__fprintf_tstamp(struct trace *trace, u64 tstamp, FILE *fp)\n{\n\tdouble ts = (double)(tstamp - trace->base_time) / NSEC_PER_MSEC;\n\n\treturn fprintf(fp, \"%10.3f \", ts);\n}\n\n \nstatic size_t trace__fprintf_tstamp(struct trace *trace, u64 tstamp, FILE *fp)\n{\n\tif (tstamp > 0)\n\t\treturn __trace__fprintf_tstamp(trace, tstamp, fp);\n\n\treturn fprintf(fp, \"         ? \");\n}\n\nstatic pid_t workload_pid = -1;\nstatic volatile sig_atomic_t done = false;\nstatic volatile sig_atomic_t interrupted = false;\n\nstatic void sighandler_interrupt(int sig __maybe_unused)\n{\n\tdone = interrupted = true;\n}\n\nstatic void sighandler_chld(int sig __maybe_unused, siginfo_t *info,\n\t\t\t    void *context __maybe_unused)\n{\n\tif (info->si_pid == workload_pid)\n\t\tdone = true;\n}\n\nstatic size_t trace__fprintf_comm_tid(struct trace *trace, struct thread *thread, FILE *fp)\n{\n\tsize_t printed = 0;\n\n\tif (trace->multiple_threads) {\n\t\tif (trace->show_comm)\n\t\t\tprinted += fprintf(fp, \"%.14s/\", thread__comm_str(thread));\n\t\tprinted += fprintf(fp, \"%d \", thread__tid(thread));\n\t}\n\n\treturn printed;\n}\n\nstatic size_t trace__fprintf_entry_head(struct trace *trace, struct thread *thread,\n\t\t\t\t\tu64 duration, bool duration_calculated, u64 tstamp, FILE *fp)\n{\n\tsize_t printed = 0;\n\n\tif (trace->show_tstamp)\n\t\tprinted = trace__fprintf_tstamp(trace, tstamp, fp);\n\tif (trace->show_duration)\n\t\tprinted += fprintf_duration(duration, duration_calculated, fp);\n\treturn printed + trace__fprintf_comm_tid(trace, thread, fp);\n}\n\nstatic int trace__process_event(struct trace *trace, struct machine *machine,\n\t\t\t\tunion perf_event *event, struct perf_sample *sample)\n{\n\tint ret = 0;\n\n\tswitch (event->header.type) {\n\tcase PERF_RECORD_LOST:\n\t\tcolor_fprintf(trace->output, PERF_COLOR_RED,\n\t\t\t      \"LOST %\" PRIu64 \" events!\\n\", event->lost.lost);\n\t\tret = machine__process_lost_event(machine, event, sample);\n\t\tbreak;\n\tdefault:\n\t\tret = machine__process_event(machine, event, sample);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int trace__tool_process(struct perf_tool *tool,\n\t\t\t       union perf_event *event,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       struct machine *machine)\n{\n\tstruct trace *trace = container_of(tool, struct trace, tool);\n\treturn trace__process_event(trace, machine, event, sample);\n}\n\nstatic char *trace__machine__resolve_kernel_addr(void *vmachine, unsigned long long *addrp, char **modp)\n{\n\tstruct machine *machine = vmachine;\n\n\tif (machine->kptr_restrict_warned)\n\t\treturn NULL;\n\n\tif (symbol_conf.kptr_restrict) {\n\t\tpr_warning(\"Kernel address maps (/proc/{kallsyms,modules}) are restricted.\\n\\n\"\n\t\t\t   \"Check /proc/sys/kernel/kptr_restrict and /proc/sys/kernel/perf_event_paranoid.\\n\\n\"\n\t\t\t   \"Kernel samples will not be resolved.\\n\");\n\t\tmachine->kptr_restrict_warned = true;\n\t\treturn NULL;\n\t}\n\n\treturn machine__resolve_kernel_addr(vmachine, addrp, modp);\n}\n\nstatic int trace__symbols_init(struct trace *trace, struct evlist *evlist)\n{\n\tint err = symbol__init(NULL);\n\n\tif (err)\n\t\treturn err;\n\n\ttrace->host = machine__new_host();\n\tif (trace->host == NULL)\n\t\treturn -ENOMEM;\n\n\tthread__set_priv_destructor(thread_trace__delete);\n\n\terr = trace_event__register_resolver(trace->host, trace__machine__resolve_kernel_addr);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = __machine__synthesize_threads(trace->host, &trace->tool, &trace->opts.target,\n\t\t\t\t\t    evlist->core.threads, trace__tool_process,\n\t\t\t\t\t    true, false, 1);\nout:\n\tif (err)\n\t\tsymbol__exit();\n\n\treturn err;\n}\n\nstatic void trace__symbols__exit(struct trace *trace)\n{\n\tmachine__exit(trace->host);\n\ttrace->host = NULL;\n\n\tsymbol__exit();\n}\n\nstatic int syscall__alloc_arg_fmts(struct syscall *sc, int nr_args)\n{\n\tint idx;\n\n\tif (nr_args == RAW_SYSCALL_ARGS_NUM && sc->fmt && sc->fmt->nr_args != 0)\n\t\tnr_args = sc->fmt->nr_args;\n\n\tsc->arg_fmt = calloc(nr_args, sizeof(*sc->arg_fmt));\n\tif (sc->arg_fmt == NULL)\n\t\treturn -1;\n\n\tfor (idx = 0; idx < nr_args; ++idx) {\n\t\tif (sc->fmt)\n\t\t\tsc->arg_fmt[idx] = sc->fmt->arg[idx];\n\t}\n\n\tsc->nr_args = nr_args;\n\treturn 0;\n}\n\nstatic const struct syscall_arg_fmt syscall_arg_fmts__by_name[] = {\n\t{ .name = \"msr\",\t.scnprintf = SCA_X86_MSR,\t  .strtoul = STUL_X86_MSR,\t   },\n\t{ .name = \"vector\",\t.scnprintf = SCA_X86_IRQ_VECTORS, .strtoul = STUL_X86_IRQ_VECTORS, },\n};\n\nstatic int syscall_arg_fmt__cmp(const void *name, const void *fmtp)\n{\n       const struct syscall_arg_fmt *fmt = fmtp;\n       return strcmp(name, fmt->name);\n}\n\nstatic const struct syscall_arg_fmt *\n__syscall_arg_fmt__find_by_name(const struct syscall_arg_fmt *fmts, const int nmemb,\n\t\t\t\tconst char *name)\n{\n       return bsearch(name, fmts, nmemb, sizeof(struct syscall_arg_fmt), syscall_arg_fmt__cmp);\n}\n\nstatic const struct syscall_arg_fmt *syscall_arg_fmt__find_by_name(const char *name)\n{\n       const int nmemb = ARRAY_SIZE(syscall_arg_fmts__by_name);\n       return __syscall_arg_fmt__find_by_name(syscall_arg_fmts__by_name, nmemb, name);\n}\n\nstatic struct tep_format_field *\nsyscall_arg_fmt__init_array(struct syscall_arg_fmt *arg, struct tep_format_field *field)\n{\n\tstruct tep_format_field *last_field = NULL;\n\tint len;\n\n\tfor (; field; field = field->next, ++arg) {\n\t\tlast_field = field;\n\n\t\tif (arg->scnprintf)\n\t\t\tcontinue;\n\n\t\tlen = strlen(field->name);\n\n\t\tif (strcmp(field->type, \"const char *\") == 0 &&\n\t\t    ((len >= 4 && strcmp(field->name + len - 4, \"name\") == 0) ||\n\t\t     strstr(field->name, \"path\") != NULL))\n\t\t\targ->scnprintf = SCA_FILENAME;\n\t\telse if ((field->flags & TEP_FIELD_IS_POINTER) || strstr(field->name, \"addr\"))\n\t\t\targ->scnprintf = SCA_PTR;\n\t\telse if (strcmp(field->type, \"pid_t\") == 0)\n\t\t\targ->scnprintf = SCA_PID;\n\t\telse if (strcmp(field->type, \"umode_t\") == 0)\n\t\t\targ->scnprintf = SCA_MODE_T;\n\t\telse if ((field->flags & TEP_FIELD_IS_ARRAY) && strstr(field->type, \"char\")) {\n\t\t\targ->scnprintf = SCA_CHAR_ARRAY;\n\t\t\targ->nr_entries = field->arraylen;\n\t\t} else if ((strcmp(field->type, \"int\") == 0 ||\n\t\t\t  strcmp(field->type, \"unsigned int\") == 0 ||\n\t\t\t  strcmp(field->type, \"long\") == 0) &&\n\t\t\t len >= 2 && strcmp(field->name + len - 2, \"fd\") == 0) {\n\t\t\t \n\t\t\targ->scnprintf = SCA_FD;\n\t\t} else {\n\t\t\tconst struct syscall_arg_fmt *fmt =\n\t\t\t\tsyscall_arg_fmt__find_by_name(field->name);\n\n\t\t\tif (fmt) {\n\t\t\t\targ->scnprintf = fmt->scnprintf;\n\t\t\t\targ->strtoul   = fmt->strtoul;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn last_field;\n}\n\nstatic int syscall__set_arg_fmts(struct syscall *sc)\n{\n\tstruct tep_format_field *last_field = syscall_arg_fmt__init_array(sc->arg_fmt, sc->args);\n\n\tif (last_field)\n\t\tsc->args_size = last_field->offset + last_field->size;\n\n\treturn 0;\n}\n\nstatic int trace__read_syscall_info(struct trace *trace, int id)\n{\n\tchar tp_name[128];\n\tstruct syscall *sc;\n\tconst char *name = syscalltbl__name(trace->sctbl, id);\n\n#ifdef HAVE_SYSCALL_TABLE_SUPPORT\n\tif (trace->syscalls.table == NULL) {\n\t\ttrace->syscalls.table = calloc(trace->sctbl->syscalls.max_id + 1, sizeof(*sc));\n\t\tif (trace->syscalls.table == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n#else\n\tif (id > trace->sctbl->syscalls.max_id || (id == 0 && trace->syscalls.table == NULL)) {\n\t\t \n\t\tstruct syscall *table = realloc(trace->syscalls.table, (id + 1) * sizeof(*sc));\n\n\t\tif (table == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t\n\t\tif (trace->syscalls.table == NULL)\n\t\t\tmemset(table, 0, (id + 1) * sizeof(*sc));\n\t\telse\n\t\t\tmemset(table + trace->sctbl->syscalls.max_id + 1, 0, (id - trace->sctbl->syscalls.max_id) * sizeof(*sc));\n\n\t\ttrace->syscalls.table\t      = table;\n\t\ttrace->sctbl->syscalls.max_id = id;\n\t}\n#endif\n\tsc = trace->syscalls.table + id;\n\tif (sc->nonexistent)\n\t\treturn -EEXIST;\n\n\tif (name == NULL) {\n\t\tsc->nonexistent = true;\n\t\treturn -EEXIST;\n\t}\n\n\tsc->name = name;\n\tsc->fmt  = syscall_fmt__find(sc->name);\n\n\tsnprintf(tp_name, sizeof(tp_name), \"sys_enter_%s\", sc->name);\n\tsc->tp_format = trace_event__tp_format(\"syscalls\", tp_name);\n\n\tif (IS_ERR(sc->tp_format) && sc->fmt && sc->fmt->alias) {\n\t\tsnprintf(tp_name, sizeof(tp_name), \"sys_enter_%s\", sc->fmt->alias);\n\t\tsc->tp_format = trace_event__tp_format(\"syscalls\", tp_name);\n\t}\n\n\t \n\tif (IS_ERR(sc->tp_format)) {\n\t\tsc->nonexistent = true;\n\t\treturn PTR_ERR(sc->tp_format);\n\t}\n\n\tif (syscall__alloc_arg_fmts(sc, IS_ERR(sc->tp_format) ?\n\t\t\t\t\tRAW_SYSCALL_ARGS_NUM : sc->tp_format->format.nr_fields))\n\t\treturn -ENOMEM;\n\n\tsc->args = sc->tp_format->format.fields;\n\t \n\tif (sc->args && (!strcmp(sc->args->name, \"__syscall_nr\") || !strcmp(sc->args->name, \"nr\"))) {\n\t\tsc->args = sc->args->next;\n\t\t--sc->nr_args;\n\t}\n\n\tsc->is_exit = !strcmp(name, \"exit_group\") || !strcmp(name, \"exit\");\n\tsc->is_open = !strcmp(name, \"open\") || !strcmp(name, \"openat\");\n\n\treturn syscall__set_arg_fmts(sc);\n}\n\nstatic int evsel__init_tp_arg_scnprintf(struct evsel *evsel)\n{\n\tstruct syscall_arg_fmt *fmt = evsel__syscall_arg_fmt(evsel);\n\n\tif (fmt != NULL) {\n\t\tsyscall_arg_fmt__init_array(fmt, evsel->tp_format->format.fields);\n\t\treturn 0;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int intcmp(const void *a, const void *b)\n{\n\tconst int *one = a, *another = b;\n\n\treturn *one - *another;\n}\n\nstatic int trace__validate_ev_qualifier(struct trace *trace)\n{\n\tint err = 0;\n\tbool printed_invalid_prefix = false;\n\tstruct str_node *pos;\n\tsize_t nr_used = 0, nr_allocated = strlist__nr_entries(trace->ev_qualifier);\n\n\ttrace->ev_qualifier_ids.entries = malloc(nr_allocated *\n\t\t\t\t\t\t sizeof(trace->ev_qualifier_ids.entries[0]));\n\n\tif (trace->ev_qualifier_ids.entries == NULL) {\n\t\tfputs(\"Error:\\tNot enough memory for allocating events qualifier ids\\n\",\n\t\t       trace->output);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstrlist__for_each_entry(pos, trace->ev_qualifier) {\n\t\tconst char *sc = pos->s;\n\t\tint id = syscalltbl__id(trace->sctbl, sc), match_next = -1;\n\n\t\tif (id < 0) {\n\t\t\tid = syscalltbl__strglobmatch_first(trace->sctbl, sc, &match_next);\n\t\t\tif (id >= 0)\n\t\t\t\tgoto matches;\n\n\t\t\tif (!printed_invalid_prefix) {\n\t\t\t\tpr_debug(\"Skipping unknown syscalls: \");\n\t\t\t\tprinted_invalid_prefix = true;\n\t\t\t} else {\n\t\t\t\tpr_debug(\", \");\n\t\t\t}\n\n\t\t\tpr_debug(\"%s\", sc);\n\t\t\tcontinue;\n\t\t}\nmatches:\n\t\ttrace->ev_qualifier_ids.entries[nr_used++] = id;\n\t\tif (match_next == -1)\n\t\t\tcontinue;\n\n\t\twhile (1) {\n\t\t\tid = syscalltbl__strglobmatch_next(trace->sctbl, sc, &match_next);\n\t\t\tif (id < 0)\n\t\t\t\tbreak;\n\t\t\tif (nr_allocated == nr_used) {\n\t\t\t\tvoid *entries;\n\n\t\t\t\tnr_allocated += 8;\n\t\t\t\tentries = realloc(trace->ev_qualifier_ids.entries,\n\t\t\t\t\t\t  nr_allocated * sizeof(trace->ev_qualifier_ids.entries[0]));\n\t\t\t\tif (entries == NULL) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tfputs(\"\\nError:\\t Not enough memory for parsing\\n\", trace->output);\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t\ttrace->ev_qualifier_ids.entries = entries;\n\t\t\t}\n\t\t\ttrace->ev_qualifier_ids.entries[nr_used++] = id;\n\t\t}\n\t}\n\n\ttrace->ev_qualifier_ids.nr = nr_used;\n\tqsort(trace->ev_qualifier_ids.entries, nr_used, sizeof(int), intcmp);\nout:\n\tif (printed_invalid_prefix)\n\t\tpr_debug(\"\\n\");\n\treturn err;\nout_free:\n\tzfree(&trace->ev_qualifier_ids.entries);\n\ttrace->ev_qualifier_ids.nr = 0;\n\tgoto out;\n}\n\nstatic __maybe_unused bool trace__syscall_enabled(struct trace *trace, int id)\n{\n\tbool in_ev_qualifier;\n\n\tif (trace->ev_qualifier_ids.nr == 0)\n\t\treturn true;\n\n\tin_ev_qualifier = bsearch(&id, trace->ev_qualifier_ids.entries,\n\t\t\t\t  trace->ev_qualifier_ids.nr, sizeof(int), intcmp) != NULL;\n\n\tif (in_ev_qualifier)\n\t       return !trace->not_ev_qualifier;\n\n\treturn trace->not_ev_qualifier;\n}\n\n \nunsigned long syscall_arg__val(struct syscall_arg *arg, u8 idx)\n{\n\tunsigned long val;\n\tunsigned char *p = arg->args + sizeof(unsigned long) * idx;\n\n\tmemcpy(&val, p, sizeof(val));\n\treturn val;\n}\n\nstatic size_t syscall__scnprintf_name(struct syscall *sc, char *bf, size_t size,\n\t\t\t\t      struct syscall_arg *arg)\n{\n\tif (sc->arg_fmt && sc->arg_fmt[arg->idx].name)\n\t\treturn scnprintf(bf, size, \"%s: \", sc->arg_fmt[arg->idx].name);\n\n\treturn scnprintf(bf, size, \"arg%d: \", arg->idx);\n}\n\n \nstatic unsigned long syscall_arg_fmt__mask_val(struct syscall_arg_fmt *fmt, struct syscall_arg *arg, unsigned long val)\n{\n\tif (fmt && fmt->mask_val)\n\t\treturn fmt->mask_val(arg, val);\n\n\treturn val;\n}\n\nstatic size_t syscall_arg_fmt__scnprintf_val(struct syscall_arg_fmt *fmt, char *bf, size_t size,\n\t\t\t\t\t     struct syscall_arg *arg, unsigned long val)\n{\n\tif (fmt && fmt->scnprintf) {\n\t\targ->val = val;\n\t\tif (fmt->parm)\n\t\t\targ->parm = fmt->parm;\n\t\treturn fmt->scnprintf(bf, size, arg);\n\t}\n\treturn scnprintf(bf, size, \"%ld\", val);\n}\n\nstatic size_t syscall__scnprintf_args(struct syscall *sc, char *bf, size_t size,\n\t\t\t\t      unsigned char *args, void *augmented_args, int augmented_args_size,\n\t\t\t\t      struct trace *trace, struct thread *thread)\n{\n\tsize_t printed = 0;\n\tunsigned long val;\n\tu8 bit = 1;\n\tstruct syscall_arg arg = {\n\t\t.args\t= args,\n\t\t.augmented = {\n\t\t\t.size = augmented_args_size,\n\t\t\t.args = augmented_args,\n\t\t},\n\t\t.idx\t= 0,\n\t\t.mask\t= 0,\n\t\t.trace  = trace,\n\t\t.thread = thread,\n\t\t.show_string_prefix = trace->show_string_prefix,\n\t};\n\tstruct thread_trace *ttrace = thread__priv(thread);\n\n\t \n\tttrace->ret_scnprintf = NULL;\n\n\tif (sc->args != NULL) {\n\t\tstruct tep_format_field *field;\n\n\t\tfor (field = sc->args; field;\n\t\t     field = field->next, ++arg.idx, bit <<= 1) {\n\t\t\tif (arg.mask & bit)\n\t\t\t\tcontinue;\n\n\t\t\targ.fmt = &sc->arg_fmt[arg.idx];\n\t\t\tval = syscall_arg__val(&arg, arg.idx);\n\t\t\t \n\t\t\tval = syscall_arg_fmt__mask_val(&sc->arg_fmt[arg.idx], &arg, val);\n\n\t\t\t \n\t\t\tif (val == 0 &&\n\t\t\t    !trace->show_zeros &&\n\t\t\t    !(sc->arg_fmt &&\n\t\t\t      (sc->arg_fmt[arg.idx].show_zero ||\n\t\t\t       sc->arg_fmt[arg.idx].scnprintf == SCA_STRARRAY ||\n\t\t\t       sc->arg_fmt[arg.idx].scnprintf == SCA_STRARRAYS) &&\n\t\t\t      sc->arg_fmt[arg.idx].parm))\n\t\t\t\tcontinue;\n\n\t\t\tprinted += scnprintf(bf + printed, size - printed, \"%s\", printed ? \", \" : \"\");\n\n\t\t\tif (trace->show_arg_names)\n\t\t\t\tprinted += scnprintf(bf + printed, size - printed, \"%s: \", field->name);\n\n\t\t\tprinted += syscall_arg_fmt__scnprintf_val(&sc->arg_fmt[arg.idx],\n\t\t\t\t\t\t\t\t  bf + printed, size - printed, &arg, val);\n\t\t}\n\t} else if (IS_ERR(sc->tp_format)) {\n\t\t \n\t\twhile (arg.idx < sc->nr_args) {\n\t\t\tif (arg.mask & bit)\n\t\t\t\tgoto next_arg;\n\t\t\tval = syscall_arg__val(&arg, arg.idx);\n\t\t\tif (printed)\n\t\t\t\tprinted += scnprintf(bf + printed, size - printed, \", \");\n\t\t\tprinted += syscall__scnprintf_name(sc, bf + printed, size - printed, &arg);\n\t\t\tprinted += syscall_arg_fmt__scnprintf_val(&sc->arg_fmt[arg.idx], bf + printed, size - printed, &arg, val);\nnext_arg:\n\t\t\t++arg.idx;\n\t\t\tbit <<= 1;\n\t\t}\n\t}\n\n\treturn printed;\n}\n\ntypedef int (*tracepoint_handler)(struct trace *trace, struct evsel *evsel,\n\t\t\t\t  union perf_event *event,\n\t\t\t\t  struct perf_sample *sample);\n\nstatic struct syscall *trace__syscall_info(struct trace *trace,\n\t\t\t\t\t   struct evsel *evsel, int id)\n{\n\tint err = 0;\n\n\tif (id < 0) {\n\n\t\t \n\t\tif (verbose > 1) {\n\t\t\tstatic u64 n;\n\t\t\tfprintf(trace->output, \"Invalid syscall %d id, skipping (%s, %\" PRIu64 \") ...\\n\",\n\t\t\t\tid, evsel__name(evsel), ++n);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\terr = -EINVAL;\n\n#ifdef HAVE_SYSCALL_TABLE_SUPPORT\n\tif (id > trace->sctbl->syscalls.max_id) {\n#else\n\tif (id >= trace->sctbl->syscalls.max_id) {\n\t\t \n\t\terr = trace__read_syscall_info(trace, id);\n\t\tif (err)\n#endif\n\t\tgoto out_cant_read;\n\t}\n\n\tif ((trace->syscalls.table == NULL || trace->syscalls.table[id].name == NULL) &&\n\t    (err = trace__read_syscall_info(trace, id)) != 0)\n\t\tgoto out_cant_read;\n\n\tif (trace->syscalls.table && trace->syscalls.table[id].nonexistent)\n\t\tgoto out_cant_read;\n\n\treturn &trace->syscalls.table[id];\n\nout_cant_read:\n\tif (verbose > 0) {\n\t\tchar sbuf[STRERR_BUFSIZE];\n\t\tfprintf(trace->output, \"Problems reading syscall %d: %d (%s)\", id, -err, str_error_r(-err, sbuf, sizeof(sbuf)));\n\t\tif (id <= trace->sctbl->syscalls.max_id && trace->syscalls.table[id].name != NULL)\n\t\t\tfprintf(trace->output, \"(%s)\", trace->syscalls.table[id].name);\n\t\tfputs(\" information\\n\", trace->output);\n\t}\n\treturn NULL;\n}\n\nstruct syscall_stats {\n\tstruct stats stats;\n\tu64\t     nr_failures;\n\tint\t     max_errno;\n\tu32\t     *errnos;\n};\n\nstatic void thread__update_stats(struct thread *thread, struct thread_trace *ttrace,\n\t\t\t\t int id, struct perf_sample *sample, long err, bool errno_summary)\n{\n\tstruct int_node *inode;\n\tstruct syscall_stats *stats;\n\tu64 duration = 0;\n\n\tinode = intlist__findnew(ttrace->syscall_stats, id);\n\tif (inode == NULL)\n\t\treturn;\n\n\tstats = inode->priv;\n\tif (stats == NULL) {\n\t\tstats = zalloc(sizeof(*stats));\n\t\tif (stats == NULL)\n\t\t\treturn;\n\n\t\tinit_stats(&stats->stats);\n\t\tinode->priv = stats;\n\t}\n\n\tif (ttrace->entry_time && sample->time > ttrace->entry_time)\n\t\tduration = sample->time - ttrace->entry_time;\n\n\tupdate_stats(&stats->stats, duration);\n\n\tif (err < 0) {\n\t\t++stats->nr_failures;\n\n\t\tif (!errno_summary)\n\t\t\treturn;\n\n\t\terr = -err;\n\t\tif (err > stats->max_errno) {\n\t\t\tu32 *new_errnos = realloc(stats->errnos, err * sizeof(u32));\n\n\t\t\tif (new_errnos) {\n\t\t\t\tmemset(new_errnos + stats->max_errno, 0, (err - stats->max_errno) * sizeof(u32));\n\t\t\t} else {\n\t\t\t\tpr_debug(\"Not enough memory for errno stats for thread \\\"%s\\\"(%d/%d), results will be incomplete\\n\",\n\t\t\t\t\t thread__comm_str(thread), thread__pid(thread),\n\t\t\t\t\t thread__tid(thread));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstats->errnos = new_errnos;\n\t\t\tstats->max_errno = err;\n\t\t}\n\n\t\t++stats->errnos[err - 1];\n\t}\n}\n\nstatic int trace__printf_interrupted_entry(struct trace *trace)\n{\n\tstruct thread_trace *ttrace;\n\tsize_t printed;\n\tint len;\n\n\tif (trace->failure_only || trace->current == NULL)\n\t\treturn 0;\n\n\tttrace = thread__priv(trace->current);\n\n\tif (!ttrace->entry_pending)\n\t\treturn 0;\n\n\tprinted  = trace__fprintf_entry_head(trace, trace->current, 0, false, ttrace->entry_time, trace->output);\n\tprinted += len = fprintf(trace->output, \"%s)\", ttrace->entry_str);\n\n\tif (len < trace->args_alignment - 4)\n\t\tprinted += fprintf(trace->output, \"%-*s\", trace->args_alignment - 4 - len, \" \");\n\n\tprinted += fprintf(trace->output, \" ...\\n\");\n\n\tttrace->entry_pending = false;\n\t++trace->nr_events_printed;\n\n\treturn printed;\n}\n\nstatic int trace__fprintf_sample(struct trace *trace, struct evsel *evsel,\n\t\t\t\t struct perf_sample *sample, struct thread *thread)\n{\n\tint printed = 0;\n\n\tif (trace->print_sample) {\n\t\tdouble ts = (double)sample->time / NSEC_PER_MSEC;\n\n\t\tprinted += fprintf(trace->output, \"%22s %10.3f %s %d/%d [%d]\\n\",\n\t\t\t\t   evsel__name(evsel), ts,\n\t\t\t\t   thread__comm_str(thread),\n\t\t\t\t   sample->pid, sample->tid, sample->cpu);\n\t}\n\n\treturn printed;\n}\n\nstatic void *syscall__augmented_args(struct syscall *sc, struct perf_sample *sample, int *augmented_args_size, int raw_augmented_args_size)\n{\n\tvoid *augmented_args = NULL;\n\t \n\tint args_size = raw_augmented_args_size ?: sc->args_size;\n\n\t*augmented_args_size = sample->raw_size - args_size;\n\tif (*augmented_args_size > 0)\n\t\taugmented_args = sample->raw_data + args_size;\n\n\treturn augmented_args;\n}\n\nstatic void syscall__exit(struct syscall *sc)\n{\n\tif (!sc)\n\t\treturn;\n\n\tzfree(&sc->arg_fmt);\n}\n\nstatic int trace__sys_enter(struct trace *trace, struct evsel *evsel,\n\t\t\t    union perf_event *event __maybe_unused,\n\t\t\t    struct perf_sample *sample)\n{\n\tchar *msg;\n\tvoid *args;\n\tint printed = 0;\n\tstruct thread *thread;\n\tint id = perf_evsel__sc_tp_uint(evsel, id, sample), err = -1;\n\tint augmented_args_size = 0;\n\tvoid *augmented_args = NULL;\n\tstruct syscall *sc = trace__syscall_info(trace, evsel, id);\n\tstruct thread_trace *ttrace;\n\n\tif (sc == NULL)\n\t\treturn -1;\n\n\tthread = machine__findnew_thread(trace->host, sample->pid, sample->tid);\n\tttrace = thread__trace(thread, trace->output);\n\tif (ttrace == NULL)\n\t\tgoto out_put;\n\n\ttrace__fprintf_sample(trace, evsel, sample, thread);\n\n\targs = perf_evsel__sc_tp_ptr(evsel, args, sample);\n\n\tif (ttrace->entry_str == NULL) {\n\t\tttrace->entry_str = malloc(trace__entry_str_size);\n\t\tif (!ttrace->entry_str)\n\t\t\tgoto out_put;\n\t}\n\n\tif (!(trace->duration_filter || trace->summary_only || trace->min_stack))\n\t\ttrace__printf_interrupted_entry(trace);\n\t \n\tif (evsel != trace->syscalls.events.sys_enter)\n\t\taugmented_args = syscall__augmented_args(sc, sample, &augmented_args_size, trace->raw_augmented_syscalls_args_size);\n\tttrace->entry_time = sample->time;\n\tmsg = ttrace->entry_str;\n\tprinted += scnprintf(msg + printed, trace__entry_str_size - printed, \"%s(\", sc->name);\n\n\tprinted += syscall__scnprintf_args(sc, msg + printed, trace__entry_str_size - printed,\n\t\t\t\t\t   args, augmented_args, augmented_args_size, trace, thread);\n\n\tif (sc->is_exit) {\n\t\tif (!(trace->duration_filter || trace->summary_only || trace->failure_only || trace->min_stack)) {\n\t\t\tint alignment = 0;\n\n\t\t\ttrace__fprintf_entry_head(trace, thread, 0, false, ttrace->entry_time, trace->output);\n\t\t\tprinted = fprintf(trace->output, \"%s)\", ttrace->entry_str);\n\t\t\tif (trace->args_alignment > printed)\n\t\t\t\talignment = trace->args_alignment - printed;\n\t\t\tfprintf(trace->output, \"%*s= ?\\n\", alignment, \" \");\n\t\t}\n\t} else {\n\t\tttrace->entry_pending = true;\n\t\t \n\t\tttrace->filename.pending_open = false;\n\t}\n\n\tif (trace->current != thread) {\n\t\tthread__put(trace->current);\n\t\ttrace->current = thread__get(thread);\n\t}\n\terr = 0;\nout_put:\n\tthread__put(thread);\n\treturn err;\n}\n\nstatic int trace__fprintf_sys_enter(struct trace *trace, struct evsel *evsel,\n\t\t\t\t    struct perf_sample *sample)\n{\n\tstruct thread_trace *ttrace;\n\tstruct thread *thread;\n\tint id = perf_evsel__sc_tp_uint(evsel, id, sample), err = -1;\n\tstruct syscall *sc = trace__syscall_info(trace, evsel, id);\n\tchar msg[1024];\n\tvoid *args, *augmented_args = NULL;\n\tint augmented_args_size;\n\n\tif (sc == NULL)\n\t\treturn -1;\n\n\tthread = machine__findnew_thread(trace->host, sample->pid, sample->tid);\n\tttrace = thread__trace(thread, trace->output);\n\t \n\tif (ttrace == NULL)\n\t\tgoto out_put;\n\n\targs = perf_evsel__sc_tp_ptr(evsel, args, sample);\n\taugmented_args = syscall__augmented_args(sc, sample, &augmented_args_size, trace->raw_augmented_syscalls_args_size);\n\tsyscall__scnprintf_args(sc, msg, sizeof(msg), args, augmented_args, augmented_args_size, trace, thread);\n\tfprintf(trace->output, \"%s\", msg);\n\terr = 0;\nout_put:\n\tthread__put(thread);\n\treturn err;\n}\n\nstatic int trace__resolve_callchain(struct trace *trace, struct evsel *evsel,\n\t\t\t\t    struct perf_sample *sample,\n\t\t\t\t    struct callchain_cursor *cursor)\n{\n\tstruct addr_location al;\n\tint max_stack = evsel->core.attr.sample_max_stack ?\n\t\t\tevsel->core.attr.sample_max_stack :\n\t\t\ttrace->max_stack;\n\tint err = -1;\n\n\taddr_location__init(&al);\n\tif (machine__resolve(trace->host, &al, sample) < 0)\n\t\tgoto out;\n\n\terr = thread__resolve_callchain(al.thread, cursor, evsel, sample, NULL, NULL, max_stack);\nout:\n\taddr_location__exit(&al);\n\treturn err;\n}\n\nstatic int trace__fprintf_callchain(struct trace *trace, struct perf_sample *sample)\n{\n\t \n\tconst unsigned int print_opts = EVSEL__PRINT_SYM |\n\t\t\t\t        EVSEL__PRINT_DSO |\n\t\t\t\t        EVSEL__PRINT_UNKNOWN_AS_ADDR;\n\n\treturn sample__fprintf_callchain(sample, 38, print_opts, get_tls_callchain_cursor(), symbol_conf.bt_stop_list, trace->output);\n}\n\nstatic const char *errno_to_name(struct evsel *evsel, int err)\n{\n\tstruct perf_env *env = evsel__env(evsel);\n\tconst char *arch_name = perf_env__arch(env);\n\n\treturn arch_syscalls__strerrno(arch_name, err);\n}\n\nstatic int trace__sys_exit(struct trace *trace, struct evsel *evsel,\n\t\t\t   union perf_event *event __maybe_unused,\n\t\t\t   struct perf_sample *sample)\n{\n\tlong ret;\n\tu64 duration = 0;\n\tbool duration_calculated = false;\n\tstruct thread *thread;\n\tint id = perf_evsel__sc_tp_uint(evsel, id, sample), err = -1, callchain_ret = 0, printed = 0;\n\tint alignment = trace->args_alignment;\n\tstruct syscall *sc = trace__syscall_info(trace, evsel, id);\n\tstruct thread_trace *ttrace;\n\n\tif (sc == NULL)\n\t\treturn -1;\n\n\tthread = machine__findnew_thread(trace->host, sample->pid, sample->tid);\n\tttrace = thread__trace(thread, trace->output);\n\tif (ttrace == NULL)\n\t\tgoto out_put;\n\n\ttrace__fprintf_sample(trace, evsel, sample, thread);\n\n\tret = perf_evsel__sc_tp_uint(evsel, ret, sample);\n\n\tif (trace->summary)\n\t\tthread__update_stats(thread, ttrace, id, sample, ret, trace->errno_summary);\n\n\tif (!trace->fd_path_disabled && sc->is_open && ret >= 0 && ttrace->filename.pending_open) {\n\t\ttrace__set_fd_pathname(thread, ret, ttrace->filename.name);\n\t\tttrace->filename.pending_open = false;\n\t\t++trace->stats.vfs_getname;\n\t}\n\n\tif (ttrace->entry_time) {\n\t\tduration = sample->time - ttrace->entry_time;\n\t\tif (trace__filter_duration(trace, duration))\n\t\t\tgoto out;\n\t\tduration_calculated = true;\n\t} else if (trace->duration_filter)\n\t\tgoto out;\n\n\tif (sample->callchain) {\n\t\tstruct callchain_cursor *cursor = get_tls_callchain_cursor();\n\n\t\tcallchain_ret = trace__resolve_callchain(trace, evsel, sample, cursor);\n\t\tif (callchain_ret == 0) {\n\t\t\tif (cursor->nr < trace->min_stack)\n\t\t\t\tgoto out;\n\t\t\tcallchain_ret = 1;\n\t\t}\n\t}\n\n\tif (trace->summary_only || (ret >= 0 && trace->failure_only))\n\t\tgoto out;\n\n\ttrace__fprintf_entry_head(trace, thread, duration, duration_calculated, ttrace->entry_time, trace->output);\n\n\tif (ttrace->entry_pending) {\n\t\tprinted = fprintf(trace->output, \"%s\", ttrace->entry_str);\n\t} else {\n\t\tprinted += fprintf(trace->output, \" ... [\");\n\t\tcolor_fprintf(trace->output, PERF_COLOR_YELLOW, \"continued\");\n\t\tprinted += 9;\n\t\tprinted += fprintf(trace->output, \"]: %s()\", sc->name);\n\t}\n\n\tprinted++;  \n\n\tif (alignment > printed)\n\t\talignment -= printed;\n\telse\n\t\talignment = 0;\n\n\tfprintf(trace->output, \")%*s= \", alignment, \" \");\n\n\tif (sc->fmt == NULL) {\n\t\tif (ret < 0)\n\t\t\tgoto errno_print;\nsigned_print:\n\t\tfprintf(trace->output, \"%ld\", ret);\n\t} else if (ret < 0) {\nerrno_print: {\n\t\tchar bf[STRERR_BUFSIZE];\n\t\tconst char *emsg = str_error_r(-ret, bf, sizeof(bf)),\n\t\t\t   *e = errno_to_name(evsel, -ret);\n\n\t\tfprintf(trace->output, \"-1 %s (%s)\", e, emsg);\n\t}\n\t} else if (ret == 0 && sc->fmt->timeout)\n\t\tfprintf(trace->output, \"0 (Timeout)\");\n\telse if (ttrace->ret_scnprintf) {\n\t\tchar bf[1024];\n\t\tstruct syscall_arg arg = {\n\t\t\t.val\t= ret,\n\t\t\t.thread\t= thread,\n\t\t\t.trace\t= trace,\n\t\t};\n\t\tttrace->ret_scnprintf(bf, sizeof(bf), &arg);\n\t\tttrace->ret_scnprintf = NULL;\n\t\tfprintf(trace->output, \"%s\", bf);\n\t} else if (sc->fmt->hexret)\n\t\tfprintf(trace->output, \"%#lx\", ret);\n\telse if (sc->fmt->errpid) {\n\t\tstruct thread *child = machine__find_thread(trace->host, ret, ret);\n\n\t\tif (child != NULL) {\n\t\t\tfprintf(trace->output, \"%ld\", ret);\n\t\t\tif (thread__comm_set(child))\n\t\t\t\tfprintf(trace->output, \" (%s)\", thread__comm_str(child));\n\t\t\tthread__put(child);\n\t\t}\n\t} else\n\t\tgoto signed_print;\n\n\tfputc('\\n', trace->output);\n\n\t \n\tif (++trace->nr_events_printed == trace->max_events && trace->max_events != ULONG_MAX)\n\t\tinterrupted = true;\n\n\tif (callchain_ret > 0)\n\t\ttrace__fprintf_callchain(trace, sample);\n\telse if (callchain_ret < 0)\n\t\tpr_err(\"Problem processing %s callchain, skipping...\\n\", evsel__name(evsel));\nout:\n\tttrace->entry_pending = false;\n\terr = 0;\nout_put:\n\tthread__put(thread);\n\treturn err;\n}\n\nstatic int trace__vfs_getname(struct trace *trace, struct evsel *evsel,\n\t\t\t      union perf_event *event __maybe_unused,\n\t\t\t      struct perf_sample *sample)\n{\n\tstruct thread *thread = machine__findnew_thread(trace->host, sample->pid, sample->tid);\n\tstruct thread_trace *ttrace;\n\tsize_t filename_len, entry_str_len, to_move;\n\tssize_t remaining_space;\n\tchar *pos;\n\tconst char *filename = evsel__rawptr(evsel, sample, \"pathname\");\n\n\tif (!thread)\n\t\tgoto out;\n\n\tttrace = thread__priv(thread);\n\tif (!ttrace)\n\t\tgoto out_put;\n\n\tfilename_len = strlen(filename);\n\tif (filename_len == 0)\n\t\tgoto out_put;\n\n\tif (ttrace->filename.namelen < filename_len) {\n\t\tchar *f = realloc(ttrace->filename.name, filename_len + 1);\n\n\t\tif (f == NULL)\n\t\t\tgoto out_put;\n\n\t\tttrace->filename.namelen = filename_len;\n\t\tttrace->filename.name = f;\n\t}\n\n\tstrcpy(ttrace->filename.name, filename);\n\tttrace->filename.pending_open = true;\n\n\tif (!ttrace->filename.ptr)\n\t\tgoto out_put;\n\n\tentry_str_len = strlen(ttrace->entry_str);\n\tremaining_space = trace__entry_str_size - entry_str_len - 1;  \n\tif (remaining_space <= 0)\n\t\tgoto out_put;\n\n\tif (filename_len > (size_t)remaining_space) {\n\t\tfilename += filename_len - remaining_space;\n\t\tfilename_len = remaining_space;\n\t}\n\n\tto_move = entry_str_len - ttrace->filename.entry_str_pos + 1;  \n\tpos = ttrace->entry_str + ttrace->filename.entry_str_pos;\n\tmemmove(pos + filename_len, pos, to_move);\n\tmemcpy(pos, filename, filename_len);\n\n\tttrace->filename.ptr = 0;\n\tttrace->filename.entry_str_pos = 0;\nout_put:\n\tthread__put(thread);\nout:\n\treturn 0;\n}\n\nstatic int trace__sched_stat_runtime(struct trace *trace, struct evsel *evsel,\n\t\t\t\t     union perf_event *event __maybe_unused,\n\t\t\t\t     struct perf_sample *sample)\n{\n        u64 runtime = evsel__intval(evsel, sample, \"runtime\");\n\tdouble runtime_ms = (double)runtime / NSEC_PER_MSEC;\n\tstruct thread *thread = machine__findnew_thread(trace->host,\n\t\t\t\t\t\t\tsample->pid,\n\t\t\t\t\t\t\tsample->tid);\n\tstruct thread_trace *ttrace = thread__trace(thread, trace->output);\n\n\tif (ttrace == NULL)\n\t\tgoto out_dump;\n\n\tttrace->runtime_ms += runtime_ms;\n\ttrace->runtime_ms += runtime_ms;\nout_put:\n\tthread__put(thread);\n\treturn 0;\n\nout_dump:\n\tfprintf(trace->output, \"%s: comm=%s,pid=%u,runtime=%\" PRIu64 \",vruntime=%\" PRIu64 \")\\n\",\n\t       evsel->name,\n\t       evsel__strval(evsel, sample, \"comm\"),\n\t       (pid_t)evsel__intval(evsel, sample, \"pid\"),\n\t       runtime,\n\t       evsel__intval(evsel, sample, \"vruntime\"));\n\tgoto out_put;\n}\n\nstatic int bpf_output__printer(enum binary_printer_ops op,\n\t\t\t       unsigned int val, void *extra __maybe_unused, FILE *fp)\n{\n\tunsigned char ch = (unsigned char)val;\n\n\tswitch (op) {\n\tcase BINARY_PRINT_CHAR_DATA:\n\t\treturn fprintf(fp, \"%c\", isprint(ch) ? ch : '.');\n\tcase BINARY_PRINT_DATA_BEGIN:\n\tcase BINARY_PRINT_LINE_BEGIN:\n\tcase BINARY_PRINT_ADDR:\n\tcase BINARY_PRINT_NUM_DATA:\n\tcase BINARY_PRINT_NUM_PAD:\n\tcase BINARY_PRINT_SEP:\n\tcase BINARY_PRINT_CHAR_PAD:\n\tcase BINARY_PRINT_LINE_END:\n\tcase BINARY_PRINT_DATA_END:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void bpf_output__fprintf(struct trace *trace,\n\t\t\t\tstruct perf_sample *sample)\n{\n\tbinary__fprintf(sample->raw_data, sample->raw_size, 8,\n\t\t\tbpf_output__printer, NULL, trace->output);\n\t++trace->nr_events_printed;\n}\n\nstatic size_t trace__fprintf_tp_fields(struct trace *trace, struct evsel *evsel, struct perf_sample *sample,\n\t\t\t\t       struct thread *thread, void *augmented_args, int augmented_args_size)\n{\n\tchar bf[2048];\n\tsize_t size = sizeof(bf);\n\tstruct tep_format_field *field = evsel->tp_format->format.fields;\n\tstruct syscall_arg_fmt *arg = __evsel__syscall_arg_fmt(evsel);\n\tsize_t printed = 0;\n\tunsigned long val;\n\tu8 bit = 1;\n\tstruct syscall_arg syscall_arg = {\n\t\t.augmented = {\n\t\t\t.size = augmented_args_size,\n\t\t\t.args = augmented_args,\n\t\t},\n\t\t.idx\t= 0,\n\t\t.mask\t= 0,\n\t\t.trace  = trace,\n\t\t.thread = thread,\n\t\t.show_string_prefix = trace->show_string_prefix,\n\t};\n\n\tfor (; field && arg; field = field->next, ++syscall_arg.idx, bit <<= 1, ++arg) {\n\t\tif (syscall_arg.mask & bit)\n\t\t\tcontinue;\n\n\t\tsyscall_arg.len = 0;\n\t\tsyscall_arg.fmt = arg;\n\t\tif (field->flags & TEP_FIELD_IS_ARRAY) {\n\t\t\tint offset = field->offset;\n\n\t\t\tif (field->flags & TEP_FIELD_IS_DYNAMIC) {\n\t\t\t\toffset = format_field__intval(field, sample, evsel->needs_swap);\n\t\t\t\tsyscall_arg.len = offset >> 16;\n\t\t\t\toffset &= 0xffff;\n\t\t\t\tif (tep_field_is_relative(field->flags))\n\t\t\t\t\toffset += field->offset + field->size;\n\t\t\t}\n\n\t\t\tval = (uintptr_t)(sample->raw_data + offset);\n\t\t} else\n\t\t\tval = format_field__intval(field, sample, evsel->needs_swap);\n\t\t \n\t\tval = syscall_arg_fmt__mask_val(arg, &syscall_arg, val);\n\n\t\t \n\t\tif (val == 0 &&\n\t\t    !trace->show_zeros &&\n\t\t    !((arg->show_zero ||\n\t\t       arg->scnprintf == SCA_STRARRAY ||\n\t\t       arg->scnprintf == SCA_STRARRAYS) &&\n\t\t      arg->parm))\n\t\t\tcontinue;\n\n\t\tprinted += scnprintf(bf + printed, size - printed, \"%s\", printed ? \", \" : \"\");\n\n\t\tif (trace->show_arg_names)\n\t\t\tprinted += scnprintf(bf + printed, size - printed, \"%s: \", field->name);\n\n\t\tprinted += syscall_arg_fmt__scnprintf_val(arg, bf + printed, size - printed, &syscall_arg, val);\n\t}\n\n\treturn printed + fprintf(trace->output, \"%s\", bf);\n}\n\nstatic int trace__event_handler(struct trace *trace, struct evsel *evsel,\n\t\t\t\tunion perf_event *event __maybe_unused,\n\t\t\t\tstruct perf_sample *sample)\n{\n\tstruct thread *thread;\n\tint callchain_ret = 0;\n\t \n\tif (evsel->disabled)\n\t\treturn 0;\n\n\tthread = machine__findnew_thread(trace->host, sample->pid, sample->tid);\n\n\tif (sample->callchain) {\n\t\tstruct callchain_cursor *cursor = get_tls_callchain_cursor();\n\n\t\tcallchain_ret = trace__resolve_callchain(trace, evsel, sample, cursor);\n\t\tif (callchain_ret == 0) {\n\t\t\tif (cursor->nr < trace->min_stack)\n\t\t\t\tgoto out;\n\t\t\tcallchain_ret = 1;\n\t\t}\n\t}\n\n\ttrace__printf_interrupted_entry(trace);\n\ttrace__fprintf_tstamp(trace, sample->time, trace->output);\n\n\tif (trace->trace_syscalls && trace->show_duration)\n\t\tfprintf(trace->output, \"(         ): \");\n\n\tif (thread)\n\t\ttrace__fprintf_comm_tid(trace, thread, trace->output);\n\n\tif (evsel == trace->syscalls.events.bpf_output) {\n\t\tint id = perf_evsel__sc_tp_uint(evsel, id, sample);\n\t\tstruct syscall *sc = trace__syscall_info(trace, evsel, id);\n\n\t\tif (sc) {\n\t\t\tfprintf(trace->output, \"%s(\", sc->name);\n\t\t\ttrace__fprintf_sys_enter(trace, evsel, sample);\n\t\t\tfputc(')', trace->output);\n\t\t\tgoto newline;\n\t\t}\n\n\t\t \n\t}\n\n\tfprintf(trace->output, \"%s(\", evsel->name);\n\n\tif (evsel__is_bpf_output(evsel)) {\n\t\tbpf_output__fprintf(trace, sample);\n\t} else if (evsel->tp_format) {\n\t\tif (strncmp(evsel->tp_format->name, \"sys_enter_\", 10) ||\n\t\t    trace__fprintf_sys_enter(trace, evsel, sample)) {\n\t\t\tif (trace->libtraceevent_print) {\n\t\t\t\tevent_format__fprintf(evsel->tp_format, sample->cpu,\n\t\t\t\t\t\t      sample->raw_data, sample->raw_size,\n\t\t\t\t\t\t      trace->output);\n\t\t\t} else {\n\t\t\t\ttrace__fprintf_tp_fields(trace, evsel, sample, thread, NULL, 0);\n\t\t\t}\n\t\t}\n\t}\n\nnewline:\n\tfprintf(trace->output, \")\\n\");\n\n\tif (callchain_ret > 0)\n\t\ttrace__fprintf_callchain(trace, sample);\n\telse if (callchain_ret < 0)\n\t\tpr_err(\"Problem processing %s callchain, skipping...\\n\", evsel__name(evsel));\n\n\t++trace->nr_events_printed;\n\n\tif (evsel->max_events != ULONG_MAX && ++evsel->nr_events_printed == evsel->max_events) {\n\t\tevsel__disable(evsel);\n\t\tevsel__close(evsel);\n\t}\nout:\n\tthread__put(thread);\n\treturn 0;\n}\n\nstatic void print_location(FILE *f, struct perf_sample *sample,\n\t\t\t   struct addr_location *al,\n\t\t\t   bool print_dso, bool print_sym)\n{\n\n\tif ((verbose > 0 || print_dso) && al->map)\n\t\tfprintf(f, \"%s@\", map__dso(al->map)->long_name);\n\n\tif ((verbose > 0 || print_sym) && al->sym)\n\t\tfprintf(f, \"%s+0x%\" PRIx64, al->sym->name,\n\t\t\tal->addr - al->sym->start);\n\telse if (al->map)\n\t\tfprintf(f, \"0x%\" PRIx64, al->addr);\n\telse\n\t\tfprintf(f, \"0x%\" PRIx64, sample->addr);\n}\n\nstatic int trace__pgfault(struct trace *trace,\n\t\t\t  struct evsel *evsel,\n\t\t\t  union perf_event *event __maybe_unused,\n\t\t\t  struct perf_sample *sample)\n{\n\tstruct thread *thread;\n\tstruct addr_location al;\n\tchar map_type = 'd';\n\tstruct thread_trace *ttrace;\n\tint err = -1;\n\tint callchain_ret = 0;\n\n\taddr_location__init(&al);\n\tthread = machine__findnew_thread(trace->host, sample->pid, sample->tid);\n\n\tif (sample->callchain) {\n\t\tstruct callchain_cursor *cursor = get_tls_callchain_cursor();\n\n\t\tcallchain_ret = trace__resolve_callchain(trace, evsel, sample, cursor);\n\t\tif (callchain_ret == 0) {\n\t\t\tif (cursor->nr < trace->min_stack)\n\t\t\t\tgoto out_put;\n\t\t\tcallchain_ret = 1;\n\t\t}\n\t}\n\n\tttrace = thread__trace(thread, trace->output);\n\tif (ttrace == NULL)\n\t\tgoto out_put;\n\n\tif (evsel->core.attr.config == PERF_COUNT_SW_PAGE_FAULTS_MAJ)\n\t\tttrace->pfmaj++;\n\telse\n\t\tttrace->pfmin++;\n\n\tif (trace->summary_only)\n\t\tgoto out;\n\n\tthread__find_symbol(thread, sample->cpumode, sample->ip, &al);\n\n\ttrace__fprintf_entry_head(trace, thread, 0, true, sample->time, trace->output);\n\n\tfprintf(trace->output, \"%sfault [\",\n\t\tevsel->core.attr.config == PERF_COUNT_SW_PAGE_FAULTS_MAJ ?\n\t\t\"maj\" : \"min\");\n\n\tprint_location(trace->output, sample, &al, false, true);\n\n\tfprintf(trace->output, \"] => \");\n\n\tthread__find_symbol(thread, sample->cpumode, sample->addr, &al);\n\n\tif (!al.map) {\n\t\tthread__find_symbol(thread, sample->cpumode, sample->addr, &al);\n\n\t\tif (al.map)\n\t\t\tmap_type = 'x';\n\t\telse\n\t\t\tmap_type = '?';\n\t}\n\n\tprint_location(trace->output, sample, &al, true, false);\n\n\tfprintf(trace->output, \" (%c%c)\\n\", map_type, al.level);\n\n\tif (callchain_ret > 0)\n\t\ttrace__fprintf_callchain(trace, sample);\n\telse if (callchain_ret < 0)\n\t\tpr_err(\"Problem processing %s callchain, skipping...\\n\", evsel__name(evsel));\n\n\t++trace->nr_events_printed;\nout:\n\terr = 0;\nout_put:\n\tthread__put(thread);\n\taddr_location__exit(&al);\n\treturn err;\n}\n\nstatic void trace__set_base_time(struct trace *trace,\n\t\t\t\t struct evsel *evsel,\n\t\t\t\t struct perf_sample *sample)\n{\n\t \n\tif (trace->base_time == 0 && !trace->full_time &&\n\t    (evsel->core.attr.sample_type & PERF_SAMPLE_TIME))\n\t\ttrace->base_time = sample->time;\n}\n\nstatic int trace__process_sample(struct perf_tool *tool,\n\t\t\t\t union perf_event *event,\n\t\t\t\t struct perf_sample *sample,\n\t\t\t\t struct evsel *evsel,\n\t\t\t\t struct machine *machine __maybe_unused)\n{\n\tstruct trace *trace = container_of(tool, struct trace, tool);\n\tstruct thread *thread;\n\tint err = 0;\n\n\ttracepoint_handler handler = evsel->handler;\n\n\tthread = machine__findnew_thread(trace->host, sample->pid, sample->tid);\n\tif (thread && thread__is_filtered(thread))\n\t\tgoto out;\n\n\ttrace__set_base_time(trace, evsel, sample);\n\n\tif (handler) {\n\t\t++trace->nr_events;\n\t\thandler(trace, evsel, event, sample);\n\t}\nout:\n\tthread__put(thread);\n\treturn err;\n}\n\nstatic int trace__record(struct trace *trace, int argc, const char **argv)\n{\n\tunsigned int rec_argc, i, j;\n\tconst char **rec_argv;\n\tconst char * const record_args[] = {\n\t\t\"record\",\n\t\t\"-R\",\n\t\t\"-m\", \"1024\",\n\t\t\"-c\", \"1\",\n\t};\n\tpid_t pid = getpid();\n\tchar *filter = asprintf__tp_filter_pids(1, &pid);\n\tconst char * const sc_args[] = { \"-e\", };\n\tunsigned int sc_args_nr = ARRAY_SIZE(sc_args);\n\tconst char * const majpf_args[] = { \"-e\", \"major-faults\" };\n\tunsigned int majpf_args_nr = ARRAY_SIZE(majpf_args);\n\tconst char * const minpf_args[] = { \"-e\", \"minor-faults\" };\n\tunsigned int minpf_args_nr = ARRAY_SIZE(minpf_args);\n\tint err = -1;\n\n\t \n\trec_argc = ARRAY_SIZE(record_args) + sc_args_nr + 3 +\n\t\tmajpf_args_nr + minpf_args_nr + argc;\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\n\tif (rec_argv == NULL || filter == NULL)\n\t\tgoto out_free;\n\n\tj = 0;\n\tfor (i = 0; i < ARRAY_SIZE(record_args); i++)\n\t\trec_argv[j++] = record_args[i];\n\n\tif (trace->trace_syscalls) {\n\t\tfor (i = 0; i < sc_args_nr; i++)\n\t\t\trec_argv[j++] = sc_args[i];\n\n\t\t \n\t\tif (is_valid_tracepoint(\"raw_syscalls:sys_enter\"))\n\t\t\trec_argv[j++] = \"raw_syscalls:sys_enter,raw_syscalls:sys_exit\";\n\t\telse if (is_valid_tracepoint(\"syscalls:sys_enter\"))\n\t\t\trec_argv[j++] = \"syscalls:sys_enter,syscalls:sys_exit\";\n\t\telse {\n\t\t\tpr_err(\"Neither raw_syscalls nor syscalls events exist.\\n\");\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\trec_argv[j++] = \"--filter\";\n\trec_argv[j++] = filter;\n\n\tif (trace->trace_pgfaults & TRACE_PFMAJ)\n\t\tfor (i = 0; i < majpf_args_nr; i++)\n\t\t\trec_argv[j++] = majpf_args[i];\n\n\tif (trace->trace_pgfaults & TRACE_PFMIN)\n\t\tfor (i = 0; i < minpf_args_nr; i++)\n\t\t\trec_argv[j++] = minpf_args[i];\n\n\tfor (i = 0; i < (unsigned int)argc; i++)\n\t\trec_argv[j++] = argv[i];\n\n\terr = cmd_record(j, rec_argv);\nout_free:\n\tfree(filter);\n\tfree(rec_argv);\n\treturn err;\n}\n\nstatic size_t trace__fprintf_thread_summary(struct trace *trace, FILE *fp);\n\nstatic bool evlist__add_vfs_getname(struct evlist *evlist)\n{\n\tbool found = false;\n\tstruct evsel *evsel, *tmp;\n\tstruct parse_events_error err;\n\tint ret;\n\n\tparse_events_error__init(&err);\n\tret = parse_events(evlist, \"probe:vfs_getname*\", &err);\n\tparse_events_error__exit(&err);\n\tif (ret)\n\t\treturn false;\n\n\tevlist__for_each_entry_safe(evlist, evsel, tmp) {\n\t\tif (!strstarts(evsel__name(evsel), \"probe:vfs_getname\"))\n\t\t\tcontinue;\n\n\t\tif (evsel__field(evsel, \"pathname\")) {\n\t\t\tevsel->handler = trace__vfs_getname;\n\t\t\tfound = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del_init(&evsel->core.node);\n\t\tevsel->evlist = NULL;\n\t\tevsel__delete(evsel);\n\t}\n\n\treturn found;\n}\n\nstatic struct evsel *evsel__new_pgfault(u64 config)\n{\n\tstruct evsel *evsel;\n\tstruct perf_event_attr attr = {\n\t\t.type = PERF_TYPE_SOFTWARE,\n\t\t.mmap_data = 1,\n\t};\n\n\tattr.config = config;\n\tattr.sample_period = 1;\n\n\tevent_attr_init(&attr);\n\n\tevsel = evsel__new(&attr);\n\tif (evsel)\n\t\tevsel->handler = trace__pgfault;\n\n\treturn evsel;\n}\n\nstatic void evlist__free_syscall_tp_fields(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tevsel_trace__delete(evsel->priv);\n\t\tevsel->priv = NULL;\n\t}\n}\n\nstatic void trace__handle_event(struct trace *trace, union perf_event *event, struct perf_sample *sample)\n{\n\tconst u32 type = event->header.type;\n\tstruct evsel *evsel;\n\n\tif (type != PERF_RECORD_SAMPLE) {\n\t\ttrace__process_event(trace, trace->host, event, sample);\n\t\treturn;\n\t}\n\n\tevsel = evlist__id2evsel(trace->evlist, sample->id);\n\tif (evsel == NULL) {\n\t\tfprintf(trace->output, \"Unknown tp ID %\" PRIu64 \", skipping...\\n\", sample->id);\n\t\treturn;\n\t}\n\n\tif (evswitch__discard(&trace->evswitch, evsel))\n\t\treturn;\n\n\ttrace__set_base_time(trace, evsel, sample);\n\n\tif (evsel->core.attr.type == PERF_TYPE_TRACEPOINT &&\n\t    sample->raw_data == NULL) {\n\t\tfprintf(trace->output, \"%s sample with no payload for tid: %d, cpu %d, raw_size=%d, skipping...\\n\",\n\t\t       evsel__name(evsel), sample->tid,\n\t\t       sample->cpu, sample->raw_size);\n\t} else {\n\t\ttracepoint_handler handler = evsel->handler;\n\t\thandler(trace, evsel, event, sample);\n\t}\n\n\tif (trace->nr_events_printed >= trace->max_events && trace->max_events != ULONG_MAX)\n\t\tinterrupted = true;\n}\n\nstatic int trace__add_syscall_newtp(struct trace *trace)\n{\n\tint ret = -1;\n\tstruct evlist *evlist = trace->evlist;\n\tstruct evsel *sys_enter, *sys_exit;\n\n\tsys_enter = perf_evsel__raw_syscall_newtp(\"sys_enter\", trace__sys_enter);\n\tif (sys_enter == NULL)\n\t\tgoto out;\n\n\tif (perf_evsel__init_sc_tp_ptr_field(sys_enter, args))\n\t\tgoto out_delete_sys_enter;\n\n\tsys_exit = perf_evsel__raw_syscall_newtp(\"sys_exit\", trace__sys_exit);\n\tif (sys_exit == NULL)\n\t\tgoto out_delete_sys_enter;\n\n\tif (perf_evsel__init_sc_tp_uint_field(sys_exit, ret))\n\t\tgoto out_delete_sys_exit;\n\n\tevsel__config_callchain(sys_enter, &trace->opts, &callchain_param);\n\tevsel__config_callchain(sys_exit, &trace->opts, &callchain_param);\n\n\tevlist__add(evlist, sys_enter);\n\tevlist__add(evlist, sys_exit);\n\n\tif (callchain_param.enabled && !trace->kernel_syscallchains) {\n\t\t \n\t\tsys_exit->core.attr.exclude_callchain_kernel = 1;\n\t}\n\n\ttrace->syscalls.events.sys_enter = sys_enter;\n\ttrace->syscalls.events.sys_exit  = sys_exit;\n\n\tret = 0;\nout:\n\treturn ret;\n\nout_delete_sys_exit:\n\tevsel__delete_priv(sys_exit);\nout_delete_sys_enter:\n\tevsel__delete_priv(sys_enter);\n\tgoto out;\n}\n\nstatic int trace__set_ev_qualifier_tp_filter(struct trace *trace)\n{\n\tint err = -1;\n\tstruct evsel *sys_exit;\n\tchar *filter = asprintf_expr_inout_ints(\"id\", !trace->not_ev_qualifier,\n\t\t\t\t\t\ttrace->ev_qualifier_ids.nr,\n\t\t\t\t\t\ttrace->ev_qualifier_ids.entries);\n\n\tif (filter == NULL)\n\t\tgoto out_enomem;\n\n\tif (!evsel__append_tp_filter(trace->syscalls.events.sys_enter, filter)) {\n\t\tsys_exit = trace->syscalls.events.sys_exit;\n\t\terr = evsel__append_tp_filter(sys_exit, filter);\n\t}\n\n\tfree(filter);\nout:\n\treturn err;\nout_enomem:\n\terrno = ENOMEM;\n\tgoto out;\n}\n\n#ifdef HAVE_BPF_SKEL\nstatic struct bpf_program *trace__find_bpf_program_by_title(struct trace *trace, const char *name)\n{\n\tstruct bpf_program *pos, *prog = NULL;\n\tconst char *sec_name;\n\n\tif (trace->skel->obj == NULL)\n\t\treturn NULL;\n\n\tbpf_object__for_each_program(pos, trace->skel->obj) {\n\t\tsec_name = bpf_program__section_name(pos);\n\t\tif (sec_name && !strcmp(sec_name, name)) {\n\t\t\tprog = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn prog;\n}\n\nstatic struct bpf_program *trace__find_syscall_bpf_prog(struct trace *trace, struct syscall *sc,\n\t\t\t\t\t\t\tconst char *prog_name, const char *type)\n{\n\tstruct bpf_program *prog;\n\n\tif (prog_name == NULL) {\n\t\tchar default_prog_name[256];\n\t\tscnprintf(default_prog_name, sizeof(default_prog_name), \"tp/syscalls/sys_%s_%s\", type, sc->name);\n\t\tprog = trace__find_bpf_program_by_title(trace, default_prog_name);\n\t\tif (prog != NULL)\n\t\t\tgoto out_found;\n\t\tif (sc->fmt && sc->fmt->alias) {\n\t\t\tscnprintf(default_prog_name, sizeof(default_prog_name), \"tp/syscalls/sys_%s_%s\", type, sc->fmt->alias);\n\t\t\tprog = trace__find_bpf_program_by_title(trace, default_prog_name);\n\t\t\tif (prog != NULL)\n\t\t\t\tgoto out_found;\n\t\t}\n\t\tgoto out_unaugmented;\n\t}\n\n\tprog = trace__find_bpf_program_by_title(trace, prog_name);\n\n\tif (prog != NULL) {\nout_found:\n\t\treturn prog;\n\t}\n\n\tpr_debug(\"Couldn't find BPF prog \\\"%s\\\" to associate with syscalls:sys_%s_%s, not augmenting it\\n\",\n\t\t prog_name, type, sc->name);\nout_unaugmented:\n\treturn trace->skel->progs.syscall_unaugmented;\n}\n\nstatic void trace__init_syscall_bpf_progs(struct trace *trace, int id)\n{\n\tstruct syscall *sc = trace__syscall_info(trace, NULL, id);\n\n\tif (sc == NULL)\n\t\treturn;\n\n\tsc->bpf_prog.sys_enter = trace__find_syscall_bpf_prog(trace, sc, sc->fmt ? sc->fmt->bpf_prog_name.sys_enter : NULL, \"enter\");\n\tsc->bpf_prog.sys_exit  = trace__find_syscall_bpf_prog(trace, sc, sc->fmt ? sc->fmt->bpf_prog_name.sys_exit  : NULL,  \"exit\");\n}\n\nstatic int trace__bpf_prog_sys_enter_fd(struct trace *trace, int id)\n{\n\tstruct syscall *sc = trace__syscall_info(trace, NULL, id);\n\treturn sc ? bpf_program__fd(sc->bpf_prog.sys_enter) : bpf_program__fd(trace->skel->progs.syscall_unaugmented);\n}\n\nstatic int trace__bpf_prog_sys_exit_fd(struct trace *trace, int id)\n{\n\tstruct syscall *sc = trace__syscall_info(trace, NULL, id);\n\treturn sc ? bpf_program__fd(sc->bpf_prog.sys_exit) : bpf_program__fd(trace->skel->progs.syscall_unaugmented);\n}\n\nstatic struct bpf_program *trace__find_usable_bpf_prog_entry(struct trace *trace, struct syscall *sc)\n{\n\tstruct tep_format_field *field, *candidate_field;\n\tint id;\n\n\t \n\tfor (field = sc->args; field; field = field->next) {\n\t\tif (field->flags & TEP_FIELD_IS_POINTER)\n\t\t\tgoto try_to_find_pair;\n\t}\n\n\treturn NULL;\n\ntry_to_find_pair:\n\tfor (id = 0; id < trace->sctbl->syscalls.nr_entries; ++id) {\n\t\tstruct syscall *pair = trace__syscall_info(trace, NULL, id);\n\t\tstruct bpf_program *pair_prog;\n\t\tbool is_candidate = false;\n\n\t\tif (pair == NULL || pair == sc ||\n\t\t    pair->bpf_prog.sys_enter == trace->skel->progs.syscall_unaugmented)\n\t\t\tcontinue;\n\n\t\tfor (field = sc->args, candidate_field = pair->args;\n\t\t     field && candidate_field; field = field->next, candidate_field = candidate_field->next) {\n\t\t\tbool is_pointer = field->flags & TEP_FIELD_IS_POINTER,\n\t\t\t     candidate_is_pointer = candidate_field->flags & TEP_FIELD_IS_POINTER;\n\n\t\t\tif (is_pointer) {\n\t\t\t       if (!candidate_is_pointer) {\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t       }\n\t\t\t} else {\n\t\t\t\tif (candidate_is_pointer) {\n\t\t\t\t\t\n\t\t\t\t\tgoto next_candidate;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(field->type, candidate_field->type))\n\t\t\t\tgoto next_candidate;\n\n\t\t\t \n\t\t\tif (strcmp(field->type, \"const char *\") == 0 &&\n\t\t\t    !(strstr(field->name, \"name\") ||\n\t\t\t      strstr(field->name, \"path\") ||\n\t\t\t      strstr(field->name, \"file\") ||\n\t\t\t      strstr(field->name, \"root\") ||\n\t\t\t      strstr(field->name, \"description\")))\n\t\t\t\tgoto next_candidate;\n\n\t\t\tis_candidate = true;\n\t\t}\n\n\t\tif (!is_candidate)\n\t\t\tgoto next_candidate;\n\n\t\t \n\t\tif (candidate_field) {\n\t\t\tfor (candidate_field = candidate_field->next; candidate_field; candidate_field = candidate_field->next)\n\t\t\t\tif (candidate_field->flags & TEP_FIELD_IS_POINTER)\n\t\t\t\t\tgoto next_candidate;\n\t\t}\n\n\t\tpair_prog = pair->bpf_prog.sys_enter;\n\t\t \n\t\tif (pair_prog == NULL) {\n\t\t\tpair_prog = trace__find_syscall_bpf_prog(trace, pair, pair->fmt ? pair->fmt->bpf_prog_name.sys_enter : NULL, \"enter\");\n\t\t\tif (pair_prog == trace->skel->progs.syscall_unaugmented)\n\t\t\t\tgoto next_candidate;\n\t\t}\n\n\t\tpr_debug(\"Reusing \\\"%s\\\" BPF sys_enter augmenter for \\\"%s\\\"\\n\", pair->name, sc->name);\n\t\treturn pair_prog;\n\tnext_candidate:\n\t\tcontinue;\n\t}\n\n\treturn NULL;\n}\n\nstatic int trace__init_syscalls_bpf_prog_array_maps(struct trace *trace)\n{\n\tint map_enter_fd = bpf_map__fd(trace->skel->maps.syscalls_sys_enter);\n\tint map_exit_fd  = bpf_map__fd(trace->skel->maps.syscalls_sys_exit);\n\tint err = 0, key;\n\n\tfor (key = 0; key < trace->sctbl->syscalls.nr_entries; ++key) {\n\t\tint prog_fd;\n\n\t\tif (!trace__syscall_enabled(trace, key))\n\t\t\tcontinue;\n\n\t\ttrace__init_syscall_bpf_progs(trace, key);\n\n\t\t \n\t\tprog_fd = trace__bpf_prog_sys_enter_fd(trace, key);\n\t\terr = bpf_map_update_elem(map_enter_fd, &key, &prog_fd, BPF_ANY);\n\t\tif (err)\n\t\t\tbreak;\n\t\tprog_fd = trace__bpf_prog_sys_exit_fd(trace, key);\n\t\terr = bpf_map_update_elem(map_exit_fd, &key, &prog_fd, BPF_ANY);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t \n\tfor (key = 0; key < trace->sctbl->syscalls.nr_entries; ++key) {\n\t\tstruct syscall *sc = trace__syscall_info(trace, NULL, key);\n\t\tstruct bpf_program *pair_prog;\n\t\tint prog_fd;\n\n\t\tif (sc == NULL || sc->bpf_prog.sys_enter == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sc->bpf_prog.sys_enter != trace->skel->progs.syscall_unaugmented)\n\t\t\tcontinue;\n\n\t\t \n\t\tpair_prog = trace__find_usable_bpf_prog_entry(trace, sc);\n\t\tif (pair_prog == NULL)\n\t\t\tcontinue;\n\n\t\tsc->bpf_prog.sys_enter = pair_prog;\n\n\t\t \n\t\tprog_fd = bpf_program__fd(sc->bpf_prog.sys_enter);\n\t\terr = bpf_map_update_elem(map_enter_fd, &key, &prog_fd, BPF_ANY);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n#endif \n\nstatic int trace__set_ev_qualifier_filter(struct trace *trace)\n{\n\tif (trace->syscalls.events.sys_enter)\n\t\treturn trace__set_ev_qualifier_tp_filter(trace);\n\treturn 0;\n}\n\nstatic int bpf_map__set_filter_pids(struct bpf_map *map __maybe_unused,\n\t\t\t\t    size_t npids __maybe_unused, pid_t *pids __maybe_unused)\n{\n\tint err = 0;\n#ifdef HAVE_LIBBPF_SUPPORT\n\tbool value = true;\n\tint map_fd = bpf_map__fd(map);\n\tsize_t i;\n\n\tfor (i = 0; i < npids; ++i) {\n\t\terr = bpf_map_update_elem(map_fd, &pids[i], &value, BPF_ANY);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n#endif\n\treturn err;\n}\n\nstatic int trace__set_filter_loop_pids(struct trace *trace)\n{\n\tunsigned int nr = 1, err;\n\tpid_t pids[32] = {\n\t\tgetpid(),\n\t};\n\tstruct thread *thread = machine__find_thread(trace->host, pids[0], pids[0]);\n\n\twhile (thread && nr < ARRAY_SIZE(pids)) {\n\t\tstruct thread *parent = machine__find_thread(trace->host,\n\t\t\t\t\t\t\t     thread__ppid(thread),\n\t\t\t\t\t\t\t     thread__ppid(thread));\n\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\n\t\tif (!strcmp(thread__comm_str(parent), \"sshd\") ||\n\t\t    strstarts(thread__comm_str(parent), \"gnome-terminal\")) {\n\t\t\tpids[nr++] = thread__tid(parent);\n\t\t\tbreak;\n\t\t}\n\t\tthread = parent;\n\t}\n\n\terr = evlist__append_tp_filter_pids(trace->evlist, nr, pids);\n\tif (!err && trace->filter_pids.map)\n\t\terr = bpf_map__set_filter_pids(trace->filter_pids.map, nr, pids);\n\n\treturn err;\n}\n\nstatic int trace__set_filter_pids(struct trace *trace)\n{\n\tint err = 0;\n\t \n\tif (trace->filter_pids.nr > 0) {\n\t\terr = evlist__append_tp_filter_pids(trace->evlist, trace->filter_pids.nr,\n\t\t\t\t\t\t    trace->filter_pids.entries);\n\t\tif (!err && trace->filter_pids.map) {\n\t\t\terr = bpf_map__set_filter_pids(trace->filter_pids.map, trace->filter_pids.nr,\n\t\t\t\t\t\t       trace->filter_pids.entries);\n\t\t}\n\t} else if (perf_thread_map__pid(trace->evlist->core.threads, 0) == -1) {\n\t\terr = trace__set_filter_loop_pids(trace);\n\t}\n\n\treturn err;\n}\n\nstatic int __trace__deliver_event(struct trace *trace, union perf_event *event)\n{\n\tstruct evlist *evlist = trace->evlist;\n\tstruct perf_sample sample;\n\tint err = evlist__parse_sample(evlist, event, &sample);\n\n\tif (err)\n\t\tfprintf(trace->output, \"Can't parse sample, err = %d, skipping...\\n\", err);\n\telse\n\t\ttrace__handle_event(trace, event, &sample);\n\n\treturn 0;\n}\n\nstatic int __trace__flush_events(struct trace *trace)\n{\n\tu64 first = ordered_events__first_time(&trace->oe.data);\n\tu64 flush = trace->oe.last - NSEC_PER_SEC;\n\n\t \n\tif (first && first < flush)\n\t\treturn ordered_events__flush_time(&trace->oe.data, flush);\n\n\treturn 0;\n}\n\nstatic int trace__flush_events(struct trace *trace)\n{\n\treturn !trace->sort_events ? 0 : __trace__flush_events(trace);\n}\n\nstatic int trace__deliver_event(struct trace *trace, union perf_event *event)\n{\n\tint err;\n\n\tif (!trace->sort_events)\n\t\treturn __trace__deliver_event(trace, event);\n\n\terr = evlist__parse_sample_timestamp(trace->evlist, event, &trace->oe.last);\n\tif (err && err != -1)\n\t\treturn err;\n\n\terr = ordered_events__queue(&trace->oe.data, event, trace->oe.last, 0, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn trace__flush_events(trace);\n}\n\nstatic int ordered_events__deliver_event(struct ordered_events *oe,\n\t\t\t\t\t struct ordered_event *event)\n{\n\tstruct trace *trace = container_of(oe, struct trace, oe.data);\n\n\treturn __trace__deliver_event(trace, event->event);\n}\n\nstatic struct syscall_arg_fmt *evsel__find_syscall_arg_fmt_by_name(struct evsel *evsel, char *arg)\n{\n\tstruct tep_format_field *field;\n\tstruct syscall_arg_fmt *fmt = __evsel__syscall_arg_fmt(evsel);\n\n\tif (evsel->tp_format == NULL || fmt == NULL)\n\t\treturn NULL;\n\n\tfor (field = evsel->tp_format->format.fields; field; field = field->next, ++fmt)\n\t\tif (strcmp(field->name, arg) == 0)\n\t\t\treturn fmt;\n\n\treturn NULL;\n}\n\nstatic int trace__expand_filter(struct trace *trace __maybe_unused, struct evsel *evsel)\n{\n\tchar *tok, *left = evsel->filter, *new_filter = evsel->filter;\n\n\twhile ((tok = strpbrk(left, \"=<>!\")) != NULL) {\n\t\tchar *right = tok + 1, *right_end;\n\n\t\tif (*right == '=')\n\t\t\t++right;\n\n\t\twhile (isspace(*right))\n\t\t\t++right;\n\n\t\tif (*right == '\\0')\n\t\t\tbreak;\n\n\t\twhile (!isalpha(*left))\n\t\t\tif (++left == tok) {\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\tright_end = right + 1;\n\t\twhile (isalnum(*right_end) || *right_end == '_' || *right_end == '|')\n\t\t\t++right_end;\n\n\t\tif (isalpha(*right)) {\n\t\t\tstruct syscall_arg_fmt *fmt;\n\t\t\tint left_size = tok - left,\n\t\t\t    right_size = right_end - right;\n\t\t\tchar arg[128];\n\n\t\t\twhile (isspace(left[left_size - 1]))\n\t\t\t\t--left_size;\n\n\t\t\tscnprintf(arg, sizeof(arg), \"%.*s\", left_size, left);\n\n\t\t\tfmt = evsel__find_syscall_arg_fmt_by_name(evsel, arg);\n\t\t\tif (fmt == NULL) {\n\t\t\t\tpr_err(\"\\\"%s\\\" not found in \\\"%s\\\", can't set filter \\\"%s\\\"\\n\",\n\t\t\t\t       arg, evsel->name, evsel->filter);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tpr_debug2(\"trying to expand \\\"%s\\\" \\\"%.*s\\\" \\\"%.*s\\\" -> \",\n\t\t\t\t arg, (int)(right - tok), tok, right_size, right);\n\n\t\t\tif (fmt->strtoul) {\n\t\t\t\tu64 val;\n\t\t\t\tstruct syscall_arg syscall_arg = {\n\t\t\t\t\t.parm = fmt->parm,\n\t\t\t\t};\n\n\t\t\t\tif (fmt->strtoul(right, right_size, &syscall_arg, &val)) {\n\t\t\t\t\tchar *n, expansion[19];\n\t\t\t\t\tint expansion_lenght = scnprintf(expansion, sizeof(expansion), \"%#\" PRIx64, val);\n\t\t\t\t\tint expansion_offset = right - new_filter;\n\n\t\t\t\t\tpr_debug(\"%s\", expansion);\n\n\t\t\t\t\tif (asprintf(&n, \"%.*s%s%s\", expansion_offset, new_filter, expansion, right_end) < 0) {\n\t\t\t\t\t\tpr_debug(\" out of memory!\\n\");\n\t\t\t\t\t\tfree(new_filter);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (new_filter != evsel->filter)\n\t\t\t\t\t\tfree(new_filter);\n\t\t\t\t\tleft = n + expansion_offset + expansion_lenght;\n\t\t\t\t\tnew_filter = n;\n\t\t\t\t} else {\n\t\t\t\t\tpr_err(\"\\\"%.*s\\\" not found for \\\"%s\\\" in \\\"%s\\\", can't set filter \\\"%s\\\"\\n\",\n\t\t\t\t\t       right_size, right, arg, evsel->name, evsel->filter);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpr_err(\"No resolver (strtoul) for \\\"%s\\\" in \\\"%s\\\", can't set filter \\\"%s\\\"\\n\",\n\t\t\t\t       arg, evsel->name, evsel->filter);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tpr_debug(\"\\n\");\n\t\t} else {\n\t\t\tleft = right_end;\n\t\t}\n\t}\n\n\tif (new_filter != evsel->filter) {\n\t\tpr_debug(\"New filter for %s: %s\\n\", evsel->name, new_filter);\n\t\tevsel__set_filter(evsel, new_filter);\n\t\tfree(new_filter);\n\t}\n\n\treturn 0;\n}\n\nstatic int trace__expand_filters(struct trace *trace, struct evsel **err_evsel)\n{\n\tstruct evlist *evlist = trace->evlist;\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->filter == NULL)\n\t\t\tcontinue;\n\n\t\tif (trace__expand_filter(trace, evsel)) {\n\t\t\t*err_evsel = evsel;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int trace__run(struct trace *trace, int argc, const char **argv)\n{\n\tstruct evlist *evlist = trace->evlist;\n\tstruct evsel *evsel, *pgfault_maj = NULL, *pgfault_min = NULL;\n\tint err = -1, i;\n\tunsigned long before;\n\tconst bool forks = argc > 0;\n\tbool draining = false;\n\n\ttrace->live = true;\n\n\tif (!trace->raw_augmented_syscalls) {\n\t\tif (trace->trace_syscalls && trace__add_syscall_newtp(trace))\n\t\t\tgoto out_error_raw_syscalls;\n\n\t\tif (trace->trace_syscalls)\n\t\t\ttrace->vfs_getname = evlist__add_vfs_getname(evlist);\n\t}\n\n\tif ((trace->trace_pgfaults & TRACE_PFMAJ)) {\n\t\tpgfault_maj = evsel__new_pgfault(PERF_COUNT_SW_PAGE_FAULTS_MAJ);\n\t\tif (pgfault_maj == NULL)\n\t\t\tgoto out_error_mem;\n\t\tevsel__config_callchain(pgfault_maj, &trace->opts, &callchain_param);\n\t\tevlist__add(evlist, pgfault_maj);\n\t}\n\n\tif ((trace->trace_pgfaults & TRACE_PFMIN)) {\n\t\tpgfault_min = evsel__new_pgfault(PERF_COUNT_SW_PAGE_FAULTS_MIN);\n\t\tif (pgfault_min == NULL)\n\t\t\tgoto out_error_mem;\n\t\tevsel__config_callchain(pgfault_min, &trace->opts, &callchain_param);\n\t\tevlist__add(evlist, pgfault_min);\n\t}\n\n\t \n\ttrace->opts.ignore_missing_thread = trace->opts.target.uid != UINT_MAX || trace->opts.target.pid;\n\n\tif (trace->sched &&\n\t    evlist__add_newtp(evlist, \"sched\", \"sched_stat_runtime\", trace__sched_stat_runtime))\n\t\tgoto out_error_sched_stat_runtime;\n\t \n\tif (trace->cgroup)\n\t\tevlist__set_default_cgroup(trace->evlist, trace->cgroup);\n\n\terr = evlist__create_maps(evlist, &trace->opts.target);\n\tif (err < 0) {\n\t\tfprintf(trace->output, \"Problems parsing the target to trace, check your options!\\n\");\n\t\tgoto out_delete_evlist;\n\t}\n\n\terr = trace__symbols_init(trace, evlist);\n\tif (err < 0) {\n\t\tfprintf(trace->output, \"Problems initializing symbol libraries!\\n\");\n\t\tgoto out_delete_evlist;\n\t}\n\n\tevlist__config(evlist, &trace->opts, &callchain_param);\n\n\tif (forks) {\n\t\terr = evlist__prepare_workload(evlist, &trace->opts.target, argv, false, NULL);\n\t\tif (err < 0) {\n\t\t\tfprintf(trace->output, \"Couldn't run the workload!\\n\");\n\t\t\tgoto out_delete_evlist;\n\t\t}\n\t\tworkload_pid = evlist->workload.pid;\n\t}\n\n\terr = evlist__open(evlist);\n\tif (err < 0)\n\t\tgoto out_error_open;\n#ifdef HAVE_BPF_SKEL\n\tif (trace->syscalls.events.bpf_output) {\n\t\tstruct perf_cpu cpu;\n\n\t\t \n\t\tperf_cpu_map__for_each_cpu(cpu, i, trace->syscalls.events.bpf_output->core.cpus) {\n\t\t\tbpf_map__update_elem(trace->skel->maps.__augmented_syscalls__,\n\t\t\t\t\t&cpu.cpu, sizeof(int),\n\t\t\t\t\txyarray__entry(trace->syscalls.events.bpf_output->core.fd,\n\t\t\t\t\t\t       cpu.cpu, 0),\n\t\t\t\t\tsizeof(__u32), BPF_ANY);\n\t\t}\n\t}\n#endif\n\terr = trace__set_filter_pids(trace);\n\tif (err < 0)\n\t\tgoto out_error_mem;\n\n#ifdef HAVE_BPF_SKEL\n\tif (trace->skel && trace->skel->progs.sys_enter)\n\t\ttrace__init_syscalls_bpf_prog_array_maps(trace);\n#endif\n\n\tif (trace->ev_qualifier_ids.nr > 0) {\n\t\terr = trace__set_ev_qualifier_filter(trace);\n\t\tif (err < 0)\n\t\t\tgoto out_errno;\n\n\t\tif (trace->syscalls.events.sys_exit) {\n\t\t\tpr_debug(\"event qualifier tracepoint filter: %s\\n\",\n\t\t\t\t trace->syscalls.events.sys_exit->filter);\n\t\t}\n\t}\n\n\t \n\ttrace->fd_path_disabled = !trace__syscall_enabled(trace, syscalltbl__id(trace->sctbl, \"close\"));\n\n\terr = trace__expand_filters(trace, &evsel);\n\tif (err)\n\t\tgoto out_delete_evlist;\n\terr = evlist__apply_filters(evlist, &evsel);\n\tif (err < 0)\n\t\tgoto out_error_apply_filters;\n\n\terr = evlist__mmap(evlist, trace->opts.mmap_pages);\n\tif (err < 0)\n\t\tgoto out_error_mmap;\n\n\tif (!target__none(&trace->opts.target) && !trace->opts.target.initial_delay)\n\t\tevlist__enable(evlist);\n\n\tif (forks)\n\t\tevlist__start_workload(evlist);\n\n\tif (trace->opts.target.initial_delay) {\n\t\tusleep(trace->opts.target.initial_delay * 1000);\n\t\tevlist__enable(evlist);\n\t}\n\n\ttrace->multiple_threads = perf_thread_map__pid(evlist->core.threads, 0) == -1 ||\n\t\tperf_thread_map__nr(evlist->core.threads) > 1 ||\n\t\tevlist__first(evlist)->core.attr.inherit;\n\n\t \n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel__has_callchain(evsel) &&\n\t\t    evsel->core.attr.sample_max_stack == 0)\n\t\t\tevsel->core.attr.sample_max_stack = trace->max_stack;\n\t}\nagain:\n\tbefore = trace->nr_events;\n\n\tfor (i = 0; i < evlist->core.nr_mmaps; i++) {\n\t\tunion perf_event *event;\n\t\tstruct mmap *md;\n\n\t\tmd = &evlist->mmap[i];\n\t\tif (perf_mmap__read_init(&md->core) < 0)\n\t\t\tcontinue;\n\n\t\twhile ((event = perf_mmap__read_event(&md->core)) != NULL) {\n\t\t\t++trace->nr_events;\n\n\t\t\terr = trace__deliver_event(trace, event);\n\t\t\tif (err)\n\t\t\t\tgoto out_disable;\n\n\t\t\tperf_mmap__consume(&md->core);\n\n\t\t\tif (interrupted)\n\t\t\t\tgoto out_disable;\n\n\t\t\tif (done && !draining) {\n\t\t\t\tevlist__disable(evlist);\n\t\t\t\tdraining = true;\n\t\t\t}\n\t\t}\n\t\tperf_mmap__read_done(&md->core);\n\t}\n\n\tif (trace->nr_events == before) {\n\t\tint timeout = done ? 100 : -1;\n\n\t\tif (!draining && evlist__poll(evlist, timeout) > 0) {\n\t\t\tif (evlist__filter_pollfd(evlist, POLLERR | POLLHUP | POLLNVAL) == 0)\n\t\t\t\tdraining = true;\n\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tif (trace__flush_events(trace))\n\t\t\t\tgoto out_disable;\n\t\t}\n\t} else {\n\t\tgoto again;\n\t}\n\nout_disable:\n\tthread__zput(trace->current);\n\n\tevlist__disable(evlist);\n\n\tif (trace->sort_events)\n\t\tordered_events__flush(&trace->oe.data, OE_FLUSH__FINAL);\n\n\tif (!err) {\n\t\tif (trace->summary)\n\t\t\ttrace__fprintf_thread_summary(trace, trace->output);\n\n\t\tif (trace->show_tool_stats) {\n\t\t\tfprintf(trace->output, \"Stats:\\n \"\n\t\t\t\t\t       \" vfs_getname : %\" PRIu64 \"\\n\"\n\t\t\t\t\t       \" proc_getname: %\" PRIu64 \"\\n\",\n\t\t\t\ttrace->stats.vfs_getname,\n\t\t\t\ttrace->stats.proc_getname);\n\t\t}\n\t}\n\nout_delete_evlist:\n\ttrace__symbols__exit(trace);\n\tevlist__free_syscall_tp_fields(evlist);\n\tevlist__delete(evlist);\n\tcgroup__put(trace->cgroup);\n\ttrace->evlist = NULL;\n\ttrace->live = false;\n\treturn err;\n{\n\tchar errbuf[BUFSIZ];\n\nout_error_sched_stat_runtime:\n\ttracing_path__strerror_open_tp(errno, errbuf, sizeof(errbuf), \"sched\", \"sched_stat_runtime\");\n\tgoto out_error;\n\nout_error_raw_syscalls:\n\ttracing_path__strerror_open_tp(errno, errbuf, sizeof(errbuf), \"raw_syscalls\", \"sys_(enter|exit)\");\n\tgoto out_error;\n\nout_error_mmap:\n\tevlist__strerror_mmap(evlist, errno, errbuf, sizeof(errbuf));\n\tgoto out_error;\n\nout_error_open:\n\tevlist__strerror_open(evlist, errno, errbuf, sizeof(errbuf));\n\nout_error:\n\tfprintf(trace->output, \"%s\\n\", errbuf);\n\tgoto out_delete_evlist;\n\nout_error_apply_filters:\n\tfprintf(trace->output,\n\t\t\"Failed to set filter \\\"%s\\\" on event %s with %d (%s)\\n\",\n\t\tevsel->filter, evsel__name(evsel), errno,\n\t\tstr_error_r(errno, errbuf, sizeof(errbuf)));\n\tgoto out_delete_evlist;\n}\nout_error_mem:\n\tfprintf(trace->output, \"Not enough memory to run!\\n\");\n\tgoto out_delete_evlist;\n\nout_errno:\n\tfprintf(trace->output, \"errno=%d,%s\\n\", errno, strerror(errno));\n\tgoto out_delete_evlist;\n}\n\nstatic int trace__replay(struct trace *trace)\n{\n\tconst struct evsel_str_handler handlers[] = {\n\t\t{ \"probe:vfs_getname\",\t     trace__vfs_getname, },\n\t};\n\tstruct perf_data data = {\n\t\t.path  = input_name,\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t\t.force = trace->force,\n\t};\n\tstruct perf_session *session;\n\tstruct evsel *evsel;\n\tint err = -1;\n\n\ttrace->tool.sample\t  = trace__process_sample;\n\ttrace->tool.mmap\t  = perf_event__process_mmap;\n\ttrace->tool.mmap2\t  = perf_event__process_mmap2;\n\ttrace->tool.comm\t  = perf_event__process_comm;\n\ttrace->tool.exit\t  = perf_event__process_exit;\n\ttrace->tool.fork\t  = perf_event__process_fork;\n\ttrace->tool.attr\t  = perf_event__process_attr;\n\ttrace->tool.tracing_data  = perf_event__process_tracing_data;\n\ttrace->tool.build_id\t  = perf_event__process_build_id;\n\ttrace->tool.namespaces\t  = perf_event__process_namespaces;\n\n\ttrace->tool.ordered_events = true;\n\ttrace->tool.ordering_requires_timestamps = true;\n\n\t \n\ttrace->multiple_threads = true;\n\n\tsession = perf_session__new(&data, &trace->tool);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tif (trace->opts.target.pid)\n\t\tsymbol_conf.pid_list_str = strdup(trace->opts.target.pid);\n\n\tif (trace->opts.target.tid)\n\t\tsymbol_conf.tid_list_str = strdup(trace->opts.target.tid);\n\n\tif (symbol__init(&session->header.env) < 0)\n\t\tgoto out;\n\n\ttrace->host = &session->machines.host;\n\n\terr = perf_session__set_tracepoints_handlers(session, handlers);\n\tif (err)\n\t\tgoto out;\n\n\tevsel = evlist__find_tracepoint_by_name(session->evlist, \"raw_syscalls:sys_enter\");\n\ttrace->syscalls.events.sys_enter = evsel;\n\t \n\tif (evsel == NULL)\n\t\tevsel = evlist__find_tracepoint_by_name(session->evlist, \"syscalls:sys_enter\");\n\n\tif (evsel &&\n\t    (evsel__init_raw_syscall_tp(evsel, trace__sys_enter) < 0 ||\n\t    perf_evsel__init_sc_tp_ptr_field(evsel, args))) {\n\t\tpr_err(\"Error during initialize raw_syscalls:sys_enter event\\n\");\n\t\tgoto out;\n\t}\n\n\tevsel = evlist__find_tracepoint_by_name(session->evlist, \"raw_syscalls:sys_exit\");\n\ttrace->syscalls.events.sys_exit = evsel;\n\tif (evsel == NULL)\n\t\tevsel = evlist__find_tracepoint_by_name(session->evlist, \"syscalls:sys_exit\");\n\tif (evsel &&\n\t    (evsel__init_raw_syscall_tp(evsel, trace__sys_exit) < 0 ||\n\t    perf_evsel__init_sc_tp_uint_field(evsel, ret))) {\n\t\tpr_err(\"Error during initialize raw_syscalls:sys_exit event\\n\");\n\t\tgoto out;\n\t}\n\n\tevlist__for_each_entry(session->evlist, evsel) {\n\t\tif (evsel->core.attr.type == PERF_TYPE_SOFTWARE &&\n\t\t    (evsel->core.attr.config == PERF_COUNT_SW_PAGE_FAULTS_MAJ ||\n\t\t     evsel->core.attr.config == PERF_COUNT_SW_PAGE_FAULTS_MIN ||\n\t\t     evsel->core.attr.config == PERF_COUNT_SW_PAGE_FAULTS))\n\t\t\tevsel->handler = trace__pgfault;\n\t}\n\n\tsetup_pager();\n\n\terr = perf_session__process_events(session);\n\tif (err)\n\t\tpr_err(\"Failed to process events, error %d\", err);\n\n\telse if (trace->summary)\n\t\ttrace__fprintf_thread_summary(trace, trace->output);\n\nout:\n\tperf_session__delete(session);\n\n\treturn err;\n}\n\nstatic size_t trace__fprintf_threads_header(FILE *fp)\n{\n\tsize_t printed;\n\n\tprinted  = fprintf(fp, \"\\n Summary of events:\\n\\n\");\n\n\treturn printed;\n}\n\nDEFINE_RESORT_RB(syscall_stats, a->msecs > b->msecs,\n\tstruct syscall_stats *stats;\n\tdouble\t\t     msecs;\n\tint\t\t     syscall;\n)\n{\n\tstruct int_node *source = rb_entry(nd, struct int_node, rb_node);\n\tstruct syscall_stats *stats = source->priv;\n\n\tentry->syscall = source->i;\n\tentry->stats   = stats;\n\tentry->msecs   = stats ? (u64)stats->stats.n * (avg_stats(&stats->stats) / NSEC_PER_MSEC) : 0;\n}\n\nstatic size_t thread__dump_stats(struct thread_trace *ttrace,\n\t\t\t\t struct trace *trace, FILE *fp)\n{\n\tsize_t printed = 0;\n\tstruct syscall *sc;\n\tstruct rb_node *nd;\n\tDECLARE_RESORT_RB_INTLIST(syscall_stats, ttrace->syscall_stats);\n\n\tif (syscall_stats == NULL)\n\t\treturn 0;\n\n\tprinted += fprintf(fp, \"\\n\");\n\n\tprinted += fprintf(fp, \"   syscall            calls  errors  total       min       avg       max       stddev\\n\");\n\tprinted += fprintf(fp, \"                                     (msec)    (msec)    (msec)    (msec)        (%%)\\n\");\n\tprinted += fprintf(fp, \"   --------------- --------  ------ -------- --------- --------- ---------     ------\\n\");\n\n\tresort_rb__for_each_entry(nd, syscall_stats) {\n\t\tstruct syscall_stats *stats = syscall_stats_entry->stats;\n\t\tif (stats) {\n\t\t\tdouble min = (double)(stats->stats.min) / NSEC_PER_MSEC;\n\t\t\tdouble max = (double)(stats->stats.max) / NSEC_PER_MSEC;\n\t\t\tdouble avg = avg_stats(&stats->stats);\n\t\t\tdouble pct;\n\t\t\tu64 n = (u64)stats->stats.n;\n\n\t\t\tpct = avg ? 100.0 * stddev_stats(&stats->stats) / avg : 0.0;\n\t\t\tavg /= NSEC_PER_MSEC;\n\n\t\t\tsc = &trace->syscalls.table[syscall_stats_entry->syscall];\n\t\t\tprinted += fprintf(fp, \"   %-15s\", sc->name);\n\t\t\tprinted += fprintf(fp, \" %8\" PRIu64 \" %6\" PRIu64 \" %9.3f %9.3f %9.3f\",\n\t\t\t\t\t   n, stats->nr_failures, syscall_stats_entry->msecs, min, avg);\n\t\t\tprinted += fprintf(fp, \" %9.3f %9.2f%%\\n\", max, pct);\n\n\t\t\tif (trace->errno_summary && stats->nr_failures) {\n\t\t\t\tconst char *arch_name = perf_env__arch(trace->host->env);\n\t\t\t\tint e;\n\n\t\t\t\tfor (e = 0; e < stats->max_errno; ++e) {\n\t\t\t\t\tif (stats->errnos[e] != 0)\n\t\t\t\t\t\tfprintf(fp, \"\\t\\t\\t\\t%s: %d\\n\", arch_syscalls__strerrno(arch_name, e + 1), stats->errnos[e]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tresort_rb__delete(syscall_stats);\n\tprinted += fprintf(fp, \"\\n\\n\");\n\n\treturn printed;\n}\n\nstatic size_t trace__fprintf_thread(FILE *fp, struct thread *thread, struct trace *trace)\n{\n\tsize_t printed = 0;\n\tstruct thread_trace *ttrace = thread__priv(thread);\n\tdouble ratio;\n\n\tif (ttrace == NULL)\n\t\treturn 0;\n\n\tratio = (double)ttrace->nr_events / trace->nr_events * 100.0;\n\n\tprinted += fprintf(fp, \" %s (%d), \", thread__comm_str(thread), thread__tid(thread));\n\tprinted += fprintf(fp, \"%lu events, \", ttrace->nr_events);\n\tprinted += fprintf(fp, \"%.1f%%\", ratio);\n\tif (ttrace->pfmaj)\n\t\tprinted += fprintf(fp, \", %lu majfaults\", ttrace->pfmaj);\n\tif (ttrace->pfmin)\n\t\tprinted += fprintf(fp, \", %lu minfaults\", ttrace->pfmin);\n\tif (trace->sched)\n\t\tprinted += fprintf(fp, \", %.3f msec\\n\", ttrace->runtime_ms);\n\telse if (fputc('\\n', fp) != EOF)\n\t\t++printed;\n\n\tprinted += thread__dump_stats(ttrace, trace, fp);\n\n\treturn printed;\n}\n\nstatic unsigned long thread__nr_events(struct thread_trace *ttrace)\n{\n\treturn ttrace ? ttrace->nr_events : 0;\n}\n\nDEFINE_RESORT_RB(threads,\n\t\t(thread__nr_events(thread__priv(a->thread)) <\n\t\t thread__nr_events(thread__priv(b->thread))),\n\tstruct thread *thread;\n)\n{\n\tentry->thread = rb_entry(nd, struct thread_rb_node, rb_node)->thread;\n}\n\nstatic size_t trace__fprintf_thread_summary(struct trace *trace, FILE *fp)\n{\n\tsize_t printed = trace__fprintf_threads_header(fp);\n\tstruct rb_node *nd;\n\tint i;\n\n\tfor (i = 0; i < THREADS__TABLE_SIZE; i++) {\n\t\tDECLARE_RESORT_RB_MACHINE_THREADS(threads, trace->host, i);\n\n\t\tif (threads == NULL) {\n\t\t\tfprintf(fp, \"%s\", \"Error sorting output by nr_events!\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tresort_rb__for_each_entry(nd, threads)\n\t\t\tprinted += trace__fprintf_thread(fp, threads_entry->thread, trace);\n\n\t\tresort_rb__delete(threads);\n\t}\n\treturn printed;\n}\n\nstatic int trace__set_duration(const struct option *opt, const char *str,\n\t\t\t       int unset __maybe_unused)\n{\n\tstruct trace *trace = opt->value;\n\n\ttrace->duration_filter = atof(str);\n\treturn 0;\n}\n\nstatic int trace__set_filter_pids_from_option(const struct option *opt, const char *str,\n\t\t\t\t\t      int unset __maybe_unused)\n{\n\tint ret = -1;\n\tsize_t i;\n\tstruct trace *trace = opt->value;\n\t \n\tstruct intlist *list = intlist__new(str);\n\n\tif (list == NULL)\n\t\treturn -1;\n\n\ti = trace->filter_pids.nr = intlist__nr_entries(list) + 1;\n\ttrace->filter_pids.entries = calloc(i, sizeof(pid_t));\n\n\tif (trace->filter_pids.entries == NULL)\n\t\tgoto out;\n\n\ttrace->filter_pids.entries[0] = getpid();\n\n\tfor (i = 1; i < trace->filter_pids.nr; ++i)\n\t\ttrace->filter_pids.entries[i] = intlist__entry(list, i - 1)->i;\n\n\tintlist__delete(list);\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int trace__open_output(struct trace *trace, const char *filename)\n{\n\tstruct stat st;\n\n\tif (!stat(filename, &st) && st.st_size) {\n\t\tchar oldname[PATH_MAX];\n\n\t\tscnprintf(oldname, sizeof(oldname), \"%s.old\", filename);\n\t\tunlink(oldname);\n\t\trename(filename, oldname);\n\t}\n\n\ttrace->output = fopen(filename, \"w\");\n\n\treturn trace->output == NULL ? -errno : 0;\n}\n\nstatic int parse_pagefaults(const struct option *opt, const char *str,\n\t\t\t    int unset __maybe_unused)\n{\n\tint *trace_pgfaults = opt->value;\n\n\tif (strcmp(str, \"all\") == 0)\n\t\t*trace_pgfaults |= TRACE_PFMAJ | TRACE_PFMIN;\n\telse if (strcmp(str, \"maj\") == 0)\n\t\t*trace_pgfaults |= TRACE_PFMAJ;\n\telse if (strcmp(str, \"min\") == 0)\n\t\t*trace_pgfaults |= TRACE_PFMIN;\n\telse\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic void evlist__set_default_evsel_handler(struct evlist *evlist, void *handler)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->handler == NULL)\n\t\t\tevsel->handler = handler;\n\t}\n}\n\nstatic void evsel__set_syscall_arg_fmt(struct evsel *evsel, const char *name)\n{\n\tstruct syscall_arg_fmt *fmt = evsel__syscall_arg_fmt(evsel);\n\n\tif (fmt) {\n\t\tconst struct syscall_fmt *scfmt = syscall_fmt__find(name);\n\n\t\tif (scfmt) {\n\t\t\tint skip = 0;\n\n\t\t\tif (strcmp(evsel->tp_format->format.fields->name, \"__syscall_nr\") == 0 ||\n\t\t\t    strcmp(evsel->tp_format->format.fields->name, \"nr\") == 0)\n\t\t\t\t++skip;\n\n\t\t\tmemcpy(fmt + skip, scfmt->arg, (evsel->tp_format->format.nr_fields - skip) * sizeof(*fmt));\n\t\t}\n\t}\n}\n\nstatic int evlist__set_syscall_tp_fields(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->priv || !evsel->tp_format)\n\t\t\tcontinue;\n\n\t\tif (strcmp(evsel->tp_format->system, \"syscalls\")) {\n\t\t\tevsel__init_tp_arg_scnprintf(evsel);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (evsel__init_syscall_tp(evsel))\n\t\t\treturn -1;\n\n\t\tif (!strncmp(evsel->tp_format->name, \"sys_enter_\", 10)) {\n\t\t\tstruct syscall_tp *sc = __evsel__syscall_tp(evsel);\n\n\t\t\tif (__tp_field__init_ptr(&sc->args, sc->id.offset + sizeof(u64)))\n\t\t\t\treturn -1;\n\n\t\t\tevsel__set_syscall_arg_fmt(evsel, evsel->tp_format->name + sizeof(\"sys_enter_\") - 1);\n\t\t} else if (!strncmp(evsel->tp_format->name, \"sys_exit_\", 9)) {\n\t\t\tstruct syscall_tp *sc = __evsel__syscall_tp(evsel);\n\n\t\t\tif (__tp_field__init_uint(&sc->ret, sizeof(u64), sc->id.offset + sizeof(u64), evsel->needs_swap))\n\t\t\t\treturn -1;\n\n\t\t\tevsel__set_syscall_arg_fmt(evsel, evsel->tp_format->name + sizeof(\"sys_exit_\") - 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int trace__parse_events_option(const struct option *opt, const char *str,\n\t\t\t\t      int unset __maybe_unused)\n{\n\tstruct trace *trace = (struct trace *)opt->value;\n\tconst char *s = str;\n\tchar *sep = NULL, *lists[2] = { NULL, NULL, };\n\tint len = strlen(str) + 1, err = -1, list, idx;\n\tchar *strace_groups_dir = system_path(STRACE_GROUPS_DIR);\n\tchar group_name[PATH_MAX];\n\tconst struct syscall_fmt *fmt;\n\n\tif (strace_groups_dir == NULL)\n\t\treturn -1;\n\n\tif (*s == '!') {\n\t\t++s;\n\t\ttrace->not_ev_qualifier = true;\n\t}\n\n\twhile (1) {\n\t\tif ((sep = strchr(s, ',')) != NULL)\n\t\t\t*sep = '\\0';\n\n\t\tlist = 0;\n\t\tif (syscalltbl__id(trace->sctbl, s) >= 0 ||\n\t\t    syscalltbl__strglobmatch_first(trace->sctbl, s, &idx) >= 0) {\n\t\t\tlist = 1;\n\t\t\tgoto do_concat;\n\t\t}\n\n\t\tfmt = syscall_fmt__find_by_alias(s);\n\t\tif (fmt != NULL) {\n\t\t\tlist = 1;\n\t\t\ts = fmt->name;\n\t\t} else {\n\t\t\tpath__join(group_name, sizeof(group_name), strace_groups_dir, s);\n\t\t\tif (access(group_name, R_OK) == 0)\n\t\t\t\tlist = 1;\n\t\t}\ndo_concat:\n\t\tif (lists[list]) {\n\t\t\tsprintf(lists[list] + strlen(lists[list]), \",%s\", s);\n\t\t} else {\n\t\t\tlists[list] = malloc(len);\n\t\t\tif (lists[list] == NULL)\n\t\t\t\tgoto out;\n\t\t\tstrcpy(lists[list], s);\n\t\t}\n\n\t\tif (!sep)\n\t\t\tbreak;\n\n\t\t*sep = ',';\n\t\ts = sep + 1;\n\t}\n\n\tif (lists[1] != NULL) {\n\t\tstruct strlist_config slist_config = {\n\t\t\t.dirname = strace_groups_dir,\n\t\t};\n\n\t\ttrace->ev_qualifier = strlist__new(lists[1], &slist_config);\n\t\tif (trace->ev_qualifier == NULL) {\n\t\t\tfputs(\"Not enough memory to parse event qualifier\", trace->output);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (trace__validate_ev_qualifier(trace))\n\t\t\tgoto out;\n\t\ttrace->trace_syscalls = true;\n\t}\n\n\terr = 0;\n\n\tif (lists[0]) {\n\t\tstruct parse_events_option_args parse_events_option_args = {\n\t\t\t.evlistp = &trace->evlist,\n\t\t};\n\t\tstruct option o = {\n\t\t\t.value = &parse_events_option_args,\n\t\t};\n\t\terr = parse_events_option(&o, lists[0], 0);\n\t}\nout:\n\tfree(strace_groups_dir);\n\tfree(lists[0]);\n\tfree(lists[1]);\n\tif (sep)\n\t\t*sep = ',';\n\n\treturn err;\n}\n\nstatic int trace__parse_cgroups(const struct option *opt, const char *str, int unset)\n{\n\tstruct trace *trace = opt->value;\n\n\tif (!list_empty(&trace->evlist->core.entries)) {\n\t\tstruct option o = {\n\t\t\t.value = &trace->evlist,\n\t\t};\n\t\treturn parse_cgroups(&o, str, unset);\n\t}\n\ttrace->cgroup = evlist__findnew_cgroup(trace->evlist, str);\n\n\treturn 0;\n}\n\nstatic int trace__config(const char *var, const char *value, void *arg)\n{\n\tstruct trace *trace = arg;\n\tint err = 0;\n\n\tif (!strcmp(var, \"trace.add_events\")) {\n\t\ttrace->perfconfig_events = strdup(value);\n\t\tif (trace->perfconfig_events == NULL) {\n\t\t\tpr_err(\"Not enough memory for %s\\n\", \"trace.add_events\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (!strcmp(var, \"trace.show_timestamp\")) {\n\t\ttrace->show_tstamp = perf_config_bool(var, value);\n\t} else if (!strcmp(var, \"trace.show_duration\")) {\n\t\ttrace->show_duration = perf_config_bool(var, value);\n\t} else if (!strcmp(var, \"trace.show_arg_names\")) {\n\t\ttrace->show_arg_names = perf_config_bool(var, value);\n\t\tif (!trace->show_arg_names)\n\t\t\ttrace->show_zeros = true;\n\t} else if (!strcmp(var, \"trace.show_zeros\")) {\n\t\tbool new_show_zeros = perf_config_bool(var, value);\n\t\tif (!trace->show_arg_names && !new_show_zeros) {\n\t\t\tpr_warning(\"trace.show_zeros has to be set when trace.show_arg_names=no\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\ttrace->show_zeros = new_show_zeros;\n\t} else if (!strcmp(var, \"trace.show_prefix\")) {\n\t\ttrace->show_string_prefix = perf_config_bool(var, value);\n\t} else if (!strcmp(var, \"trace.no_inherit\")) {\n\t\ttrace->opts.no_inherit = perf_config_bool(var, value);\n\t} else if (!strcmp(var, \"trace.args_alignment\")) {\n\t\tint args_alignment = 0;\n\t\tif (perf_config_int(&args_alignment, var, value) == 0)\n\t\t\ttrace->args_alignment = args_alignment;\n\t} else if (!strcmp(var, \"trace.tracepoint_beautifiers\")) {\n\t\tif (strcasecmp(value, \"libtraceevent\") == 0)\n\t\t\ttrace->libtraceevent_print = true;\n\t\telse if (strcasecmp(value, \"libbeauty\") == 0)\n\t\t\ttrace->libtraceevent_print = false;\n\t}\nout:\n\treturn err;\n}\n\nstatic void trace__exit(struct trace *trace)\n{\n\tint i;\n\n\tstrlist__delete(trace->ev_qualifier);\n\tzfree(&trace->ev_qualifier_ids.entries);\n\tif (trace->syscalls.table) {\n\t\tfor (i = 0; i <= trace->sctbl->syscalls.max_id; i++)\n\t\t\tsyscall__exit(&trace->syscalls.table[i]);\n\t\tzfree(&trace->syscalls.table);\n\t}\n\tsyscalltbl__delete(trace->sctbl);\n\tzfree(&trace->perfconfig_events);\n}\n\n#ifdef HAVE_BPF_SKEL\nstatic int bpf__setup_bpf_output(struct evlist *evlist)\n{\n\tint err = parse_event(evlist, \"bpf-output/no-inherit=1,name=__augmented_syscalls__/\");\n\n\tif (err)\n\t\tpr_debug(\"ERROR: failed to create the \\\"__augmented_syscalls__\\\" bpf-output event\\n\");\n\n\treturn err;\n}\n#endif\n\nint cmd_trace(int argc, const char **argv)\n{\n\tconst char *trace_usage[] = {\n\t\t\"perf trace [<options>] [<command>]\",\n\t\t\"perf trace [<options>] -- <command> [<options>]\",\n\t\t\"perf trace record [<options>] [<command>]\",\n\t\t\"perf trace record [<options>] -- <command> [<options>]\",\n\t\tNULL\n\t};\n\tstruct trace trace = {\n\t\t.opts = {\n\t\t\t.target = {\n\t\t\t\t.uid\t   = UINT_MAX,\n\t\t\t\t.uses_mmap = true,\n\t\t\t},\n\t\t\t.user_freq     = UINT_MAX,\n\t\t\t.user_interval = ULLONG_MAX,\n\t\t\t.no_buffering  = true,\n\t\t\t.mmap_pages    = UINT_MAX,\n\t\t},\n\t\t.output = stderr,\n\t\t.show_comm = true,\n\t\t.show_tstamp = true,\n\t\t.show_duration = true,\n\t\t.show_arg_names = true,\n\t\t.args_alignment = 70,\n\t\t.trace_syscalls = false,\n\t\t.kernel_syscallchains = false,\n\t\t.max_stack = UINT_MAX,\n\t\t.max_events = ULONG_MAX,\n\t};\n\tconst char *output_name = NULL;\n\tconst struct option trace_options[] = {\n\tOPT_CALLBACK('e', \"event\", &trace, \"event\",\n\t\t     \"event/syscall selector. use 'perf list' to list available events\",\n\t\t     trace__parse_events_option),\n\tOPT_CALLBACK(0, \"filter\", &trace.evlist, \"filter\",\n\t\t     \"event filter\", parse_filter),\n\tOPT_BOOLEAN(0, \"comm\", &trace.show_comm,\n\t\t    \"show the thread COMM next to its id\"),\n\tOPT_BOOLEAN(0, \"tool_stats\", &trace.show_tool_stats, \"show tool stats\"),\n\tOPT_CALLBACK(0, \"expr\", &trace, \"expr\", \"list of syscalls/events to trace\",\n\t\t     trace__parse_events_option),\n\tOPT_STRING('o', \"output\", &output_name, \"file\", \"output file name\"),\n\tOPT_STRING('i', \"input\", &input_name, \"file\", \"Analyze events in file\"),\n\tOPT_STRING('p', \"pid\", &trace.opts.target.pid, \"pid\",\n\t\t    \"trace events on existing process id\"),\n\tOPT_STRING('t', \"tid\", &trace.opts.target.tid, \"tid\",\n\t\t    \"trace events on existing thread id\"),\n\tOPT_CALLBACK(0, \"filter-pids\", &trace, \"CSV list of pids\",\n\t\t     \"pids to filter (by the kernel)\", trace__set_filter_pids_from_option),\n\tOPT_BOOLEAN('a', \"all-cpus\", &trace.opts.target.system_wide,\n\t\t    \"system-wide collection from all CPUs\"),\n\tOPT_STRING('C', \"cpu\", &trace.opts.target.cpu_list, \"cpu\",\n\t\t    \"list of cpus to monitor\"),\n\tOPT_BOOLEAN(0, \"no-inherit\", &trace.opts.no_inherit,\n\t\t    \"child tasks do not inherit counters\"),\n\tOPT_CALLBACK('m', \"mmap-pages\", &trace.opts.mmap_pages, \"pages\",\n\t\t     \"number of mmap data pages\", evlist__parse_mmap_pages),\n\tOPT_STRING('u', \"uid\", &trace.opts.target.uid_str, \"user\",\n\t\t   \"user to profile\"),\n\tOPT_CALLBACK(0, \"duration\", &trace, \"float\",\n\t\t     \"show only events with duration > N.M ms\",\n\t\t     trace__set_duration),\n\tOPT_BOOLEAN(0, \"sched\", &trace.sched, \"show blocking scheduler events\"),\n\tOPT_INCR('v', \"verbose\", &verbose, \"be more verbose\"),\n\tOPT_BOOLEAN('T', \"time\", &trace.full_time,\n\t\t    \"Show full timestamp, not time relative to first start\"),\n\tOPT_BOOLEAN(0, \"failure\", &trace.failure_only,\n\t\t    \"Show only syscalls that failed\"),\n\tOPT_BOOLEAN('s', \"summary\", &trace.summary_only,\n\t\t    \"Show only syscall summary with statistics\"),\n\tOPT_BOOLEAN('S', \"with-summary\", &trace.summary,\n\t\t    \"Show all syscalls and summary with statistics\"),\n\tOPT_BOOLEAN(0, \"errno-summary\", &trace.errno_summary,\n\t\t    \"Show errno stats per syscall, use with -s or -S\"),\n\tOPT_CALLBACK_DEFAULT('F', \"pf\", &trace.trace_pgfaults, \"all|maj|min\",\n\t\t     \"Trace pagefaults\", parse_pagefaults, \"maj\"),\n\tOPT_BOOLEAN(0, \"syscalls\", &trace.trace_syscalls, \"Trace syscalls\"),\n\tOPT_BOOLEAN('f', \"force\", &trace.force, \"don't complain, do it\"),\n\tOPT_CALLBACK(0, \"call-graph\", &trace.opts,\n\t\t     \"record_mode[,record_size]\", record_callchain_help,\n\t\t     &record_parse_callchain_opt),\n\tOPT_BOOLEAN(0, \"libtraceevent_print\", &trace.libtraceevent_print,\n\t\t    \"Use libtraceevent to print the tracepoint arguments.\"),\n\tOPT_BOOLEAN(0, \"kernel-syscall-graph\", &trace.kernel_syscallchains,\n\t\t    \"Show the kernel callchains on the syscall exit path\"),\n\tOPT_ULONG(0, \"max-events\", &trace.max_events,\n\t\t\"Set the maximum number of events to print, exit after that is reached. \"),\n\tOPT_UINTEGER(0, \"min-stack\", &trace.min_stack,\n\t\t     \"Set the minimum stack depth when parsing the callchain, \"\n\t\t     \"anything below the specified depth will be ignored.\"),\n\tOPT_UINTEGER(0, \"max-stack\", &trace.max_stack,\n\t\t     \"Set the maximum stack depth when parsing the callchain, \"\n\t\t     \"anything beyond the specified depth will be ignored. \"\n\t\t     \"Default: kernel.perf_event_max_stack or \" __stringify(PERF_MAX_STACK_DEPTH)),\n\tOPT_BOOLEAN(0, \"sort-events\", &trace.sort_events,\n\t\t\t\"Sort batch of events before processing, use if getting out of order events\"),\n\tOPT_BOOLEAN(0, \"print-sample\", &trace.print_sample,\n\t\t\t\"print the PERF_RECORD_SAMPLE PERF_SAMPLE_ info, for debugging\"),\n\tOPT_UINTEGER(0, \"proc-map-timeout\", &proc_map_timeout,\n\t\t\t\"per thread proc mmap processing timeout in ms\"),\n\tOPT_CALLBACK('G', \"cgroup\", &trace, \"name\", \"monitor event in cgroup name only\",\n\t\t     trace__parse_cgroups),\n\tOPT_INTEGER('D', \"delay\", &trace.opts.target.initial_delay,\n\t\t     \"ms to wait before starting measurement after program \"\n\t\t     \"start\"),\n\tOPTS_EVSWITCH(&trace.evswitch),\n\tOPT_END()\n\t};\n\tbool __maybe_unused max_stack_user_set = true;\n\tbool mmap_pages_user_set = true;\n\tstruct evsel *evsel;\n\tconst char * const trace_subcommands[] = { \"record\", NULL };\n\tint err = -1;\n\tchar bf[BUFSIZ];\n\tstruct sigaction sigchld_act;\n\n\tsignal(SIGSEGV, sighandler_dump_stack);\n\tsignal(SIGFPE, sighandler_dump_stack);\n\tsignal(SIGINT, sighandler_interrupt);\n\n\tmemset(&sigchld_act, 0, sizeof(sigchld_act));\n\tsigchld_act.sa_flags = SA_SIGINFO;\n\tsigchld_act.sa_sigaction = sighandler_chld;\n\tsigaction(SIGCHLD, &sigchld_act, NULL);\n\n\ttrace.evlist = evlist__new();\n\ttrace.sctbl = syscalltbl__new();\n\n\tif (trace.evlist == NULL || trace.sctbl == NULL) {\n\t\tpr_err(\"Not enough memory to run!\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\trlimit__bump_memlock();\n\n\terr = perf_config(trace__config, &trace);\n\tif (err)\n\t\tgoto out;\n\n\targc = parse_options_subcommand(argc, argv, trace_options, trace_subcommands,\n\t\t\t\t trace_usage, PARSE_OPT_STOP_AT_NON_OPTION);\n\n\t \n\tif (!trace.trace_syscalls && !trace.trace_pgfaults &&\n\t    trace.evlist->core.nr_entries == 0  ) {\n\t\ttrace.trace_syscalls = true;\n\t}\n\t \n\tif (trace.perfconfig_events != NULL) {\n\t\tstruct parse_events_error parse_err;\n\n\t\tparse_events_error__init(&parse_err);\n\t\terr = parse_events(trace.evlist, trace.perfconfig_events, &parse_err);\n\t\tif (err)\n\t\t\tparse_events_error__print(&parse_err, trace.perfconfig_events);\n\t\tparse_events_error__exit(&parse_err);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif ((nr_cgroups || trace.cgroup) && !trace.opts.target.system_wide) {\n\t\tusage_with_options_msg(trace_usage, trace_options,\n\t\t\t\t       \"cgroup monitoring only available in system-wide mode\");\n\t}\n\n#ifdef HAVE_BPF_SKEL\n\tif (!trace.trace_syscalls)\n\t\tgoto skip_augmentation;\n\n\ttrace.skel = augmented_raw_syscalls_bpf__open();\n\tif (!trace.skel) {\n\t\tpr_debug(\"Failed to open augmented syscalls BPF skeleton\");\n\t} else {\n\t\t \n\t\tstruct bpf_program *prog;\n\n\t\tbpf_object__for_each_program(prog, trace.skel->obj) {\n\t\t\tif (prog != trace.skel->progs.sys_enter && prog != trace.skel->progs.sys_exit)\n\t\t\t\tbpf_program__set_autoattach(prog,  false);\n\t\t}\n\n\t\terr = augmented_raw_syscalls_bpf__load(trace.skel);\n\n\t\tif (err < 0) {\n\t\t\tlibbpf_strerror(err, bf, sizeof(bf));\n\t\t\tpr_debug(\"Failed to load augmented syscalls BPF skeleton: %s\\n\", bf);\n\t\t} else {\n\t\t\taugmented_raw_syscalls_bpf__attach(trace.skel);\n\t\t\ttrace__add_syscall_newtp(&trace);\n\t\t}\n\t}\n\n\terr = bpf__setup_bpf_output(trace.evlist);\n\tif (err) {\n\t\tlibbpf_strerror(err, bf, sizeof(bf));\n\t\tpr_err(\"ERROR: Setup BPF output event failed: %s\\n\", bf);\n\t\tgoto out;\n\t}\n\ttrace.syscalls.events.bpf_output = evlist__last(trace.evlist);\n\tassert(!strcmp(evsel__name(trace.syscalls.events.bpf_output), \"__augmented_syscalls__\"));\nskip_augmentation:\n#endif\n\terr = -1;\n\n\tif (trace.trace_pgfaults) {\n\t\ttrace.opts.sample_address = true;\n\t\ttrace.opts.sample_time = true;\n\t}\n\n\tif (trace.opts.mmap_pages == UINT_MAX)\n\t\tmmap_pages_user_set = false;\n\n\tif (trace.max_stack == UINT_MAX) {\n\t\ttrace.max_stack = input_name ? PERF_MAX_STACK_DEPTH : sysctl__max_stack();\n\t\tmax_stack_user_set = false;\n\t}\n\n#ifdef HAVE_DWARF_UNWIND_SUPPORT\n\tif ((trace.min_stack || max_stack_user_set) && !callchain_param.enabled) {\n\t\trecord_opts__parse_callchain(&trace.opts, &callchain_param, \"dwarf\", false);\n\t}\n#endif\n\n\tif (callchain_param.enabled) {\n\t\tif (!mmap_pages_user_set && geteuid() == 0)\n\t\t\ttrace.opts.mmap_pages = perf_event_mlock_kb_in_pages() * 4;\n\n\t\tsymbol_conf.use_callchain = true;\n\t}\n\n\tif (trace.evlist->core.nr_entries > 0) {\n\t\tevlist__set_default_evsel_handler(trace.evlist, trace__event_handler);\n\t\tif (evlist__set_syscall_tp_fields(trace.evlist)) {\n\t\t\tperror(\"failed to set syscalls:* tracepoint fields\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (trace.sort_events) {\n\t\tordered_events__init(&trace.oe.data, ordered_events__deliver_event, &trace);\n\t\tordered_events__set_copy_on_queue(&trace.oe.data, true);\n\t}\n\n\t \n\tif (trace.syscalls.events.bpf_output) {\n\t\tevlist__for_each_entry(trace.evlist, evsel) {\n\t\t\tbool raw_syscalls_sys_exit = strcmp(evsel__name(evsel), \"raw_syscalls:sys_exit\") == 0;\n\n\t\t\tif (raw_syscalls_sys_exit) {\n\t\t\t\ttrace.raw_augmented_syscalls = true;\n\t\t\t\tgoto init_augmented_syscall_tp;\n\t\t\t}\n\n\t\t\tif (trace.syscalls.events.bpf_output->priv == NULL &&\n\t\t\t    strstr(evsel__name(evsel), \"syscalls:sys_enter\")) {\n\t\t\t\tstruct evsel *augmented = trace.syscalls.events.bpf_output;\n\t\t\t\tif (evsel__init_augmented_syscall_tp(augmented, evsel) ||\n\t\t\t\t    evsel__init_augmented_syscall_tp_args(augmented))\n\t\t\t\t\tgoto out;\n\t\t\t\t \n\t\t\t\taugmented->handler = trace__sys_enter;\n\t\t\t\t \n\t\t\t\tif (evsel__init_augmented_syscall_tp(evsel, evsel) ||\n\t\t\t\t    evsel__init_augmented_syscall_tp_args(evsel))\n\t\t\t\t\tgoto out;\n\t\t\t\tevsel->handler = trace__sys_enter;\n\t\t\t}\n\n\t\t\tif (strstarts(evsel__name(evsel), \"syscalls:sys_exit_\")) {\n\t\t\t\tstruct syscall_tp *sc;\ninit_augmented_syscall_tp:\n\t\t\t\tif (evsel__init_augmented_syscall_tp(evsel, evsel))\n\t\t\t\t\tgoto out;\n\t\t\t\tsc = __evsel__syscall_tp(evsel);\n\t\t\t\t \n\t\t\t\tif (trace.raw_augmented_syscalls)\n\t\t\t\t\ttrace.raw_augmented_syscalls_args_size = (6 + 1) * sizeof(long) + sc->id.offset;\n\t\t\t\tevsel__init_augmented_syscall_tp_ret(evsel);\n\t\t\t\tevsel->handler = trace__sys_exit;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((argc >= 1) && (strcmp(argv[0], \"record\") == 0))\n\t\treturn trace__record(&trace, argc-1, &argv[1]);\n\n\t \n\tif (trace.errno_summary && !trace.summary && !trace.summary_only)\n\t\ttrace.summary_only = true;\n\n\t \n\tif (trace.summary_only)\n\t\ttrace.summary = trace.summary_only;\n\n\tif (output_name != NULL) {\n\t\terr = trace__open_output(&trace, output_name);\n\t\tif (err < 0) {\n\t\t\tperror(\"failed to create output file\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = evswitch__init(&trace.evswitch, trace.evlist, stderr);\n\tif (err)\n\t\tgoto out_close;\n\n\terr = target__validate(&trace.opts.target);\n\tif (err) {\n\t\ttarget__strerror(&trace.opts.target, err, bf, sizeof(bf));\n\t\tfprintf(trace.output, \"%s\", bf);\n\t\tgoto out_close;\n\t}\n\n\terr = target__parse_uid(&trace.opts.target);\n\tif (err) {\n\t\ttarget__strerror(&trace.opts.target, err, bf, sizeof(bf));\n\t\tfprintf(trace.output, \"%s\", bf);\n\t\tgoto out_close;\n\t}\n\n\tif (!argc && target__none(&trace.opts.target))\n\t\ttrace.opts.target.system_wide = true;\n\n\tif (input_name)\n\t\terr = trace__replay(&trace);\n\telse\n\t\terr = trace__run(&trace, argc, argv);\n\nout_close:\n\tif (output_name != NULL)\n\t\tfclose(trace.output);\nout:\n\ttrace__exit(&trace);\n#ifdef HAVE_BPF_SKEL\n\taugmented_raw_syscalls_bpf__destroy(trace.skel);\n#endif\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}