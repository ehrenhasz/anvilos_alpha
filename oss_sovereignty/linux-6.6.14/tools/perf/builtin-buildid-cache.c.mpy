{
  "module_name": "builtin-buildid-cache.c",
  "hash_id": "ccbda87b2a534606badbca6f0139df847656bc6cef5556c4cccbc100f6e65b4c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-buildid-cache.c",
  "human_readable_source": "\n \n#include <sys/types.h>\n#include <sys/time.h>\n#include <time.h>\n#include <dirent.h>\n#include <errno.h>\n#include <unistd.h>\n#include \"builtin.h\"\n#include \"namespaces.h\"\n#include \"util/debug.h\"\n#include \"util/header.h\"\n#include <subcmd/pager.h>\n#include <subcmd/parse-options.h>\n#include \"util/strlist.h\"\n#include \"util/build-id.h\"\n#include \"util/session.h\"\n#include \"util/dso.h\"\n#include \"util/symbol.h\"\n#include \"util/time-utils.h\"\n#include \"util/util.h\"\n#include \"util/probe-file.h\"\n#include \"util/config.h\"\n#include <linux/string.h>\n#include <linux/err.h>\n\nstatic int build_id_cache__kcore_buildid(const char *proc_dir, char *sbuildid)\n{\n\tchar root_dir[PATH_MAX];\n\tchar *p;\n\n\tstrlcpy(root_dir, proc_dir, sizeof(root_dir));\n\n\tp = strrchr(root_dir, '/');\n\tif (!p)\n\t\treturn -1;\n\t*p = '\\0';\n\treturn sysfs__sprintf_build_id(root_dir, sbuildid);\n}\n\nstatic int build_id_cache__kcore_dir(char *dir, size_t sz)\n{\n\treturn fetch_current_timestamp(dir, sz);\n}\n\nstatic bool same_kallsyms_reloc(const char *from_dir, char *to_dir)\n{\n\tchar from[PATH_MAX];\n\tchar to[PATH_MAX];\n\tconst char *name;\n\tu64 addr1 = 0, addr2 = 0;\n\tint i, err = -1;\n\n\tscnprintf(from, sizeof(from), \"%s/kallsyms\", from_dir);\n\tscnprintf(to, sizeof(to), \"%s/kallsyms\", to_dir);\n\n\tfor (i = 0; (name = ref_reloc_sym_names[i]) != NULL; i++) {\n\t\terr = kallsyms__get_function_start(from, name, &addr1);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn false;\n\n\tif (kallsyms__get_function_start(to, name, &addr2))\n\t\treturn false;\n\n\treturn addr1 == addr2;\n}\n\nstatic int build_id_cache__kcore_existing(const char *from_dir, char *to_dir,\n\t\t\t\t\t  size_t to_dir_sz)\n{\n\tchar from[PATH_MAX];\n\tchar to[PATH_MAX];\n\tchar to_subdir[PATH_MAX];\n\tstruct dirent *dent;\n\tint ret = -1;\n\tDIR *d;\n\n\td = opendir(to_dir);\n\tif (!d)\n\t\treturn -1;\n\n\tscnprintf(from, sizeof(from), \"%s/modules\", from_dir);\n\n\twhile (1) {\n\t\tdent = readdir(d);\n\t\tif (!dent)\n\t\t\tbreak;\n\t\tif (dent->d_type != DT_DIR)\n\t\t\tcontinue;\n\t\tscnprintf(to, sizeof(to), \"%s/%s/modules\", to_dir,\n\t\t\t  dent->d_name);\n\t\tscnprintf(to_subdir, sizeof(to_subdir), \"%s/%s\",\n\t\t\t  to_dir, dent->d_name);\n\t\tif (!compare_proc_modules(from, to) &&\n\t\t    same_kallsyms_reloc(from_dir, to_subdir)) {\n\t\t\tstrlcpy(to_dir, to_subdir, to_dir_sz);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(d);\n\n\treturn ret;\n}\n\nstatic int build_id_cache__add_kcore(const char *filename, bool force)\n{\n\tchar dir[32], sbuildid[SBUILD_ID_SIZE];\n\tchar from_dir[PATH_MAX], to_dir[PATH_MAX];\n\tchar *p;\n\n\tstrlcpy(from_dir, filename, sizeof(from_dir));\n\n\tp = strrchr(from_dir, '/');\n\tif (!p || strcmp(p + 1, \"kcore\"))\n\t\treturn -1;\n\t*p = '\\0';\n\n\tif (build_id_cache__kcore_buildid(from_dir, sbuildid) < 0)\n\t\treturn -1;\n\n\tscnprintf(to_dir, sizeof(to_dir), \"%s/%s/%s\",\n\t\t  buildid_dir, DSO__NAME_KCORE, sbuildid);\n\n\tif (!force &&\n\t    !build_id_cache__kcore_existing(from_dir, to_dir, sizeof(to_dir))) {\n\t\tpr_debug(\"same kcore found in %s\\n\", to_dir);\n\t\treturn 0;\n\t}\n\n\tif (build_id_cache__kcore_dir(dir, sizeof(dir)))\n\t\treturn -1;\n\n\tscnprintf(to_dir, sizeof(to_dir), \"%s/%s/%s/%s\",\n\t\t  buildid_dir, DSO__NAME_KCORE, sbuildid, dir);\n\n\tif (mkdir_p(to_dir, 0755))\n\t\treturn -1;\n\n\tif (kcore_copy(from_dir, to_dir)) {\n\t\t \n\t\tif (!rmdir(to_dir)) {\n\t\t\tp = strrchr(to_dir, '/');\n\t\t\tif (p)\n\t\t\t\t*p = '\\0';\n\t\t\t \n\t\t\tif (!rmdir(to_dir)) {\n\t\t\t\tp = strrchr(to_dir, '/');\n\t\t\t\tif (p)\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t \n\t\t\t\trmdir(to_dir);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpr_debug(\"kcore added to build-id cache directory %s\\n\", to_dir);\n\n\treturn 0;\n}\n\nstatic int build_id_cache__add_file(const char *filename, struct nsinfo *nsi)\n{\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\tstruct build_id bid;\n\tint err;\n\tstruct nscookie nsc;\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\terr = filename__read_build_id(filename, &bid);\n\tnsinfo__mountns_exit(&nsc);\n\tif (err < 0) {\n\t\tpr_debug(\"Couldn't read a build-id in %s\\n\", filename);\n\t\treturn -1;\n\t}\n\n\tbuild_id__sprintf(&bid, sbuild_id);\n\terr = build_id_cache__add_s(sbuild_id, filename, nsi,\n\t\t\t\t    false, false);\n\tpr_debug(\"Adding %s %s: %s\\n\", sbuild_id, filename,\n\t\t err ? \"FAIL\" : \"Ok\");\n\treturn err;\n}\n\nstatic int build_id_cache__remove_file(const char *filename, struct nsinfo *nsi)\n{\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\tstruct build_id bid;\n\tstruct nscookie nsc;\n\n\tint err;\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\terr = filename__read_build_id(filename, &bid);\n\tnsinfo__mountns_exit(&nsc);\n\tif (err < 0) {\n\t\tpr_debug(\"Couldn't read a build-id in %s\\n\", filename);\n\t\treturn -1;\n\t}\n\n\tbuild_id__sprintf(&bid, sbuild_id);\n\terr = build_id_cache__remove_s(sbuild_id);\n\tpr_debug(\"Removing %s %s: %s\\n\", sbuild_id, filename,\n\t\t err ? \"FAIL\" : \"Ok\");\n\n\treturn err;\n}\n\nstatic int build_id_cache__purge_path(const char *pathname, struct nsinfo *nsi)\n{\n\tstruct strlist *list;\n\tstruct str_node *pos;\n\tint err;\n\n\terr = build_id_cache__list_build_ids(pathname, nsi, &list);\n\tif (err)\n\t\tgoto out;\n\n\tstrlist__for_each_entry(pos, list) {\n\t\terr = build_id_cache__remove_s(pos->s);\n\t\tpr_debug(\"Removing %s %s: %s\\n\", pos->s, pathname,\n\t\t\t err ? \"FAIL\" : \"Ok\");\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tstrlist__delete(list);\n\nout:\n\tpr_debug(\"Purging %s: %s\\n\", pathname, err ? \"FAIL\" : \"Ok\");\n\n\treturn err;\n}\n\nstatic int build_id_cache__purge_all(void)\n{\n\tstruct strlist *list;\n\tstruct str_node *pos;\n\tint err = 0;\n\tchar *buf;\n\n\tlist = build_id_cache__list_all(false);\n\tif (!list) {\n\t\tpr_debug(\"Failed to get buildids: -%d\\n\", errno);\n\t\treturn -EINVAL;\n\t}\n\n\tstrlist__for_each_entry(pos, list) {\n\t\tbuf = build_id_cache__origname(pos->s);\n\t\terr = build_id_cache__remove_s(pos->s);\n\t\tpr_debug(\"Removing %s (%s): %s\\n\", buf, pos->s,\n\t\t\t err ? \"FAIL\" : \"Ok\");\n\t\tfree(buf);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tstrlist__delete(list);\n\n\tpr_debug(\"Purged all: %s\\n\", err ? \"FAIL\" : \"Ok\");\n\treturn err;\n}\n\nstatic bool dso__missing_buildid_cache(struct dso *dso, int parm __maybe_unused)\n{\n\tchar filename[PATH_MAX];\n\tstruct build_id bid;\n\n\tif (dso__build_id_filename(dso, filename, sizeof(filename), false) &&\n\t    filename__read_build_id(filename, &bid) == -1) {\n\t\tif (errno == ENOENT)\n\t\t\treturn false;\n\n\t\tpr_warning(\"Problems with %s file, consider removing it from the cache\\n\",\n\t\t\t   filename);\n\t} else if (memcmp(dso->bid.data, bid.data, bid.size)) {\n\t\tpr_warning(\"Problems with %s file, consider removing it from the cache\\n\",\n\t\t\t   filename);\n\t}\n\n\treturn true;\n}\n\nstatic int build_id_cache__fprintf_missing(struct perf_session *session, FILE *fp)\n{\n\tperf_session__fprintf_dsos_buildid(session, fp, dso__missing_buildid_cache, 0);\n\treturn 0;\n}\n\nstatic int build_id_cache__update_file(const char *filename, struct nsinfo *nsi)\n{\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\tstruct build_id bid;\n\tstruct nscookie nsc;\n\n\tint err;\n\n\tnsinfo__mountns_enter(nsi, &nsc);\n\terr = filename__read_build_id(filename, &bid);\n\tnsinfo__mountns_exit(&nsc);\n\tif (err < 0) {\n\t\tpr_debug(\"Couldn't read a build-id in %s\\n\", filename);\n\t\treturn -1;\n\t}\n\terr = 0;\n\n\tbuild_id__sprintf(&bid, sbuild_id);\n\tif (build_id_cache__cached(sbuild_id))\n\t\terr = build_id_cache__remove_s(sbuild_id);\n\n\tif (!err)\n\t\terr = build_id_cache__add_s(sbuild_id, filename, nsi, false,\n\t\t\t\t\t    false);\n\n\tpr_debug(\"Updating %s %s: %s\\n\", sbuild_id, filename,\n\t\t err ? \"FAIL\" : \"Ok\");\n\n\treturn err;\n}\n\nstatic int build_id_cache__show_all(void)\n{\n\tstruct strlist *bidlist;\n\tstruct str_node *nd;\n\tchar *buf;\n\n\tbidlist = build_id_cache__list_all(true);\n\tif (!bidlist) {\n\t\tpr_debug(\"Failed to get buildids: -%d\\n\", errno);\n\t\treturn -1;\n\t}\n\tstrlist__for_each_entry(nd, bidlist) {\n\t\tbuf = build_id_cache__origname(nd->s);\n\t\tfprintf(stdout, \"%s %s\\n\", nd->s, buf);\n\t\tfree(buf);\n\t}\n\tstrlist__delete(bidlist);\n\treturn 0;\n}\n\nstatic int perf_buildid_cache_config(const char *var, const char *value, void *cb)\n{\n\tstruct perf_debuginfod *di = cb;\n\n\tif (!strcmp(var, \"buildid-cache.debuginfod\")) {\n\t\tdi->urls = strdup(value);\n\t\tif (!di->urls)\n\t\t\treturn -ENOMEM;\n\t\tdi->set = true;\n\t}\n\n\treturn 0;\n}\n\nint cmd_buildid_cache(int argc, const char **argv)\n{\n\tstruct strlist *list;\n\tstruct str_node *pos;\n\tint ret, ns_id = -1;\n\tbool force = false;\n\tbool list_files = false;\n\tbool opts_flag = false;\n\tbool purge_all = false;\n\tchar const *add_name_list_str = NULL,\n\t\t   *remove_name_list_str = NULL,\n\t\t   *purge_name_list_str = NULL,\n\t\t   *missing_filename = NULL,\n\t\t   *update_name_list_str = NULL,\n\t\t   *kcore_filename = NULL;\n\tstruct perf_debuginfod debuginfod = { };\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tstruct perf_data data = {\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t};\n\tstruct perf_session *session = NULL;\n\tstruct nsinfo *nsi = NULL;\n\n\tconst struct option buildid_cache_options[] = {\n\tOPT_STRING('a', \"add\", &add_name_list_str,\n\t\t   \"file list\", \"file(s) to add\"),\n\tOPT_STRING('k', \"kcore\", &kcore_filename,\n\t\t   \"file\", \"kcore file to add\"),\n\tOPT_STRING('r', \"remove\", &remove_name_list_str, \"file list\",\n\t\t    \"file(s) to remove\"),\n\tOPT_STRING('p', \"purge\", &purge_name_list_str, \"file list\",\n\t\t    \"file(s) to remove (remove old caches too)\"),\n\tOPT_BOOLEAN('P', \"purge-all\", &purge_all, \"purge all cached files\"),\n\tOPT_BOOLEAN('l', \"list\", &list_files, \"list all cached files\"),\n\tOPT_STRING('M', \"missing\", &missing_filename, \"file\",\n\t\t   \"to find missing build ids in the cache\"),\n\tOPT_BOOLEAN('f', \"force\", &force, \"don't complain, do it\"),\n\tOPT_STRING('u', \"update\", &update_name_list_str, \"file list\",\n\t\t    \"file(s) to update\"),\n\tOPT_STRING_OPTARG_SET(0, \"debuginfod\", &debuginfod.urls,\n\t\t\t&debuginfod.set, \"debuginfod urls\",\n\t\t\t\"Enable debuginfod data retrieval from DEBUGINFOD_URLS or specified urls\",\n\t\t\t\"system\"),\n\tOPT_INCR('v', \"verbose\", &verbose, \"be more verbose\"),\n\tOPT_INTEGER(0, \"target-ns\", &ns_id, \"target pid for namespace context\"),\n\tOPT_END()\n\t};\n\tconst char * const buildid_cache_usage[] = {\n\t\t\"perf buildid-cache [<options>]\",\n\t\tNULL\n\t};\n\n\tret = perf_config(perf_buildid_cache_config, &debuginfod);\n\tif (ret)\n\t\treturn ret;\n\n\targc = parse_options(argc, argv, buildid_cache_options,\n\t\t\t     buildid_cache_usage, 0);\n\n\topts_flag = add_name_list_str || kcore_filename ||\n\t\tremove_name_list_str || purge_name_list_str ||\n\t\tmissing_filename || update_name_list_str ||\n\t\tpurge_all;\n\n\tif (argc || !(list_files || opts_flag))\n\t\tusage_with_options(buildid_cache_usage, buildid_cache_options);\n\n\tperf_debuginfod_setup(&debuginfod);\n\n\t \n\tif (list_files && opts_flag) {\n\t\tusage_with_options_msg(buildid_cache_usage,\n\t\t\tbuildid_cache_options, \"-l is exclusive.\\n\");\n\t}\n\n\tif (ns_id > 0)\n\t\tnsi = nsinfo__new(ns_id);\n\n\tif (missing_filename) {\n\t\tdata.path  = missing_filename;\n\t\tdata.force = force;\n\n\t\tsession = perf_session__new(&data, NULL);\n\t\tif (IS_ERR(session))\n\t\t\treturn PTR_ERR(session);\n\t}\n\n\tif (symbol__init(session ? &session->header.env : NULL) < 0)\n\t\tgoto out;\n\n\tsetup_pager();\n\n\tif (list_files) {\n\t\tret = build_id_cache__show_all();\n\t\tgoto out;\n\t}\n\n\tif (add_name_list_str) {\n\t\tlist = strlist__new(add_name_list_str, NULL);\n\t\tif (list) {\n\t\t\tstrlist__for_each_entry(pos, list)\n\t\t\t\tif (build_id_cache__add_file(pos->s, nsi)) {\n\t\t\t\t\tif (errno == EEXIST) {\n\t\t\t\t\t\tpr_debug(\"%s already in the cache\\n\",\n\t\t\t\t\t\t\t pos->s);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpr_warning(\"Couldn't add %s: %s\\n\",\n\t\t\t\t\t\t   pos->s, str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\t\t\t}\n\n\t\t\tstrlist__delete(list);\n\t\t}\n\t}\n\n\tif (remove_name_list_str) {\n\t\tlist = strlist__new(remove_name_list_str, NULL);\n\t\tif (list) {\n\t\t\tstrlist__for_each_entry(pos, list)\n\t\t\t\tif (build_id_cache__remove_file(pos->s, nsi)) {\n\t\t\t\t\tif (errno == ENOENT) {\n\t\t\t\t\t\tpr_debug(\"%s wasn't in the cache\\n\",\n\t\t\t\t\t\t\t pos->s);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpr_warning(\"Couldn't remove %s: %s\\n\",\n\t\t\t\t\t\t   pos->s, str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\t\t\t}\n\n\t\t\tstrlist__delete(list);\n\t\t}\n\t}\n\n\tif (purge_name_list_str) {\n\t\tlist = strlist__new(purge_name_list_str, NULL);\n\t\tif (list) {\n\t\t\tstrlist__for_each_entry(pos, list)\n\t\t\t\tif (build_id_cache__purge_path(pos->s, nsi)) {\n\t\t\t\t\tif (errno == ENOENT) {\n\t\t\t\t\t\tpr_debug(\"%s wasn't in the cache\\n\",\n\t\t\t\t\t\t\t pos->s);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpr_warning(\"Couldn't remove %s: %s\\n\",\n\t\t\t\t\t\t   pos->s, str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\t\t\t}\n\n\t\t\tstrlist__delete(list);\n\t\t}\n\t}\n\n\tif (purge_all) {\n\t\tif (build_id_cache__purge_all()) {\n\t\t\tpr_warning(\"Couldn't remove some caches. Error: %s.\\n\",\n\t\t\t\tstr_error_r(errno, sbuf, sizeof(sbuf)));\n\t\t}\n\t}\n\n\tif (missing_filename)\n\t\tret = build_id_cache__fprintf_missing(session, stdout);\n\n\tif (update_name_list_str) {\n\t\tlist = strlist__new(update_name_list_str, NULL);\n\t\tif (list) {\n\t\t\tstrlist__for_each_entry(pos, list)\n\t\t\t\tif (build_id_cache__update_file(pos->s, nsi)) {\n\t\t\t\t\tif (errno == ENOENT) {\n\t\t\t\t\t\tpr_debug(\"%s wasn't in the cache\\n\",\n\t\t\t\t\t\t\t pos->s);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpr_warning(\"Couldn't update %s: %s\\n\",\n\t\t\t\t\t\t   pos->s, str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\t\t\t}\n\n\t\t\tstrlist__delete(list);\n\t\t}\n\t}\n\n\tif (kcore_filename && build_id_cache__add_kcore(kcore_filename, force))\n\t\tpr_warning(\"Couldn't add %s\\n\", kcore_filename);\n\nout:\n\tperf_session__delete(session);\n\tnsinfo__zput(nsi);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}