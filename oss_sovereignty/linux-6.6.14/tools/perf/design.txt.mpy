{
  "module_name": "design.txt",
  "hash_id": "8ce27811557b0aea1624377745c725d174a1e6821bdc29973f06b8b3052af33a",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/design.txt",
  "human_readable_source": "\nPerformance Counters for Linux\n------------------------------\n\nPerformance counters are special hardware registers available on most modern\nCPUs. These registers count the number of certain types of hw events: such\nas instructions executed, cachemisses suffered, or branches mis-predicted -\nwithout slowing down the kernel or applications. These registers can also\ntrigger interrupts when a threshold number of events have passed - and can\nthus be used to profile the code that runs on that CPU.\n\nThe Linux Performance Counter subsystem provides an abstraction of these\nhardware capabilities. It provides per task and per CPU counters, counter\ngroups, and it provides event capabilities on top of those.  It\nprovides \"virtual\" 64-bit counters, regardless of the width of the\nunderlying hardware counters.\n\nPerformance counters are accessed via special file descriptors.\nThere's one file descriptor per virtual counter used.\n\nThe special file descriptor is opened via the sys_perf_event_open()\nsystem call:\n\n   int sys_perf_event_open(struct perf_event_attr *hw_event_uptr,\n\t\t\t     pid_t pid, int cpu, int group_fd,\n\t\t\t     unsigned long flags);\n\nThe syscall returns the new fd. The fd can be used via the normal\nVFS system calls: read() can be used to read the counter, fcntl()\ncan be used to set the blocking mode, etc.\n\nMultiple counters can be kept open at a time, and the counters\ncan be poll()ed.\n\nWhen creating a new counter fd, 'perf_event_attr' is:\n\nstruct perf_event_attr {\n        /*\n         * The MSB of the config word signifies if the rest contains cpu\n         * specific (raw) counter configuration data, if unset, the next\n         * 7 bits are an event type and the rest of the bits are the event\n         * identifier.\n         */\n        __u64                   config;\n\n        __u64                   irq_period;\n        __u32                   record_type;\n        __u32                   read_format;\n\n        __u64                   disabled       :  1, /* off by default        */\n                                inherit        :  1, /* children inherit it   */\n                                pinned         :  1, /* must always be on PMU */\n                                exclusive      :  1, /* only group on PMU     */\n                                exclude_user   :  1, /* don't count user      */\n                                exclude_kernel :  1, /* ditto kernel          */\n                                exclude_hv     :  1, /* ditto hypervisor      */\n                                exclude_idle   :  1, /* don't count when idle */\n                                mmap           :  1, /* include mmap data     */\n                                munmap         :  1, /* include munmap data   */\n                                comm           :  1, /* include comm data     */\n\n                                __reserved_1   : 52;\n\n        __u32                   extra_config_len;\n        __u32                   wakeup_events;  /* wakeup every n events */\n\n        __u64                   __reserved_2;\n        __u64                   __reserved_3;\n};\n\nThe 'config' field specifies what the counter should count.  It\nis divided into 3 bit-fields:\n\nraw_type: 1 bit   (most significant bit)\t0x8000_0000_0000_0000\ntype:\t  7 bits  (next most significant)\t0x7f00_0000_0000_0000\nevent_id: 56 bits (least significant)\t\t0x00ff_ffff_ffff_ffff\n\nIf 'raw_type' is 1, then the counter will count a hardware event\nspecified by the remaining 63 bits of event_config.  The encoding is\nmachine-specific.\n\nIf 'raw_type' is 0, then the 'type' field says what kind of counter\nthis is, with the following encoding:\n\nenum perf_type_id {\n\tPERF_TYPE_HARDWARE\t\t= 0,\n\tPERF_TYPE_SOFTWARE\t\t= 1,\n\tPERF_TYPE_TRACEPOINT\t\t= 2,\n};\n\nA counter of PERF_TYPE_HARDWARE will count the hardware event\nspecified by 'event_id':\n\n/*\n * Generalized performance counter event types, used by the hw_event.event_id\n * parameter of the sys_perf_event_open() syscall:\n */\nenum perf_hw_id {\n\t/*\n\t * Common hardware events, generalized by the kernel:\n\t */\n\tPERF_COUNT_HW_CPU_CYCLES\t\t= 0,\n\tPERF_COUNT_HW_INSTRUCTIONS\t\t= 1,\n\tPERF_COUNT_HW_CACHE_REFERENCES\t\t= 2,\n\tPERF_COUNT_HW_CACHE_MISSES\t\t= 3,\n\tPERF_COUNT_HW_BRANCH_INSTRUCTIONS\t= 4,\n\tPERF_COUNT_HW_BRANCH_MISSES\t\t= 5,\n\tPERF_COUNT_HW_BUS_CYCLES\t\t= 6,\n\tPERF_COUNT_HW_STALLED_CYCLES_FRONTEND\t= 7,\n\tPERF_COUNT_HW_STALLED_CYCLES_BACKEND\t= 8,\n\tPERF_COUNT_HW_REF_CPU_CYCLES\t\t= 9,\n};\n\nThese are standardized types of events that work relatively uniformly\non all CPUs that implement Performance Counters support under Linux,\nalthough there may be variations (e.g., different CPUs might count\ncache references and misses at different levels of the cache hierarchy).\nIf a CPU is not able to count the selected event, then the system call\nwill return -EINVAL.\n\nMore hw_event_types are supported as well, but they are CPU-specific\nand accessed as raw events.  For example, to count \"External bus\ncycles while bus lock signal asserted\" events on Intel Core CPUs, pass\nin a 0x4064 event_id value and set hw_event.raw_type to 1.\n\nA counter of type PERF_TYPE_SOFTWARE will count one of the available\nsoftware events, selected by 'event_id':\n\n/*\n * Special \"software\" counters provided by the kernel, even if the hardware\n * does not support performance counters. These counters measure various\n * physical and sw events of the kernel (and allow the profiling of them as\n * well):\n */\nenum perf_sw_ids {\n\tPERF_COUNT_SW_CPU_CLOCK\t\t= 0,\n\tPERF_COUNT_SW_TASK_CLOCK\t= 1,\n\tPERF_COUNT_SW_PAGE_FAULTS\t= 2,\n\tPERF_COUNT_SW_CONTEXT_SWITCHES\t= 3,\n\tPERF_COUNT_SW_CPU_MIGRATIONS\t= 4,\n\tPERF_COUNT_SW_PAGE_FAULTS_MIN\t= 5,\n\tPERF_COUNT_SW_PAGE_FAULTS_MAJ\t= 6,\n\tPERF_COUNT_SW_ALIGNMENT_FAULTS\t= 7,\n\tPERF_COUNT_SW_EMULATION_FAULTS\t= 8,\n};\n\nCounters of the type PERF_TYPE_TRACEPOINT are available when the ftrace event\ntracer is available, and event_id values can be obtained from\n/debug/tracing/events/*/*/id\n\n\nCounters come in two flavours: counting counters and sampling\ncounters.  A \"counting\" counter is one that is used for counting the\nnumber of events that occur, and is characterised by having\nirq_period = 0.\n\n\nA read() on a counter returns the current value of the counter and possible\nadditional values as specified by 'read_format', each value is a u64 (8 bytes)\nin size.\n\n/*\n * Bits that can be set in hw_event.read_format to request that\n * reads on the counter should return the indicated quantities,\n * in increasing order of bit value, after the counter value.\n */\nenum perf_event_read_format {\n        PERF_FORMAT_TOTAL_TIME_ENABLED  =  1,\n        PERF_FORMAT_TOTAL_TIME_RUNNING  =  2,\n};\n\nUsing these additional values one can establish the overcommit ratio for a\nparticular counter allowing one to take the round-robin scheduling effect\ninto account.\n\n\nA \"sampling\" counter is one that is set up to generate an interrupt\nevery N events, where N is given by 'irq_period'.  A sampling counter\nhas irq_period > 0. The record_type controls what data is recorded on each\ninterrupt:\n\n/*\n * Bits that can be set in hw_event.record_type to request information\n * in the overflow packets.\n */\nenum perf_event_record_format {\n        PERF_RECORD_IP          = 1U << 0,\n        PERF_RECORD_TID         = 1U << 1,\n        PERF_RECORD_TIME        = 1U << 2,\n        PERF_RECORD_ADDR        = 1U << 3,\n        PERF_RECORD_GROUP       = 1U << 4,\n        PERF_RECORD_CALLCHAIN   = 1U << 5,\n};\n\nSuch (and other) events will be recorded in a ring-buffer, which is\navailable to user-space using mmap() (see below).\n\nThe 'disabled' bit specifies whether the counter starts out disabled\nor enabled.  If it is initially disabled, it can be enabled by ioctl\nor prctl (see below).\n\nThe 'inherit' bit, if set, specifies that this counter should count\nevents on descendant tasks as well as the task specified.  This only\napplies to new descendents, not to any existing descendents at the\ntime the counter is created (nor to any new descendents of existing\ndescendents).\n\nThe 'pinned' bit, if set, specifies that the counter should always be\non the CPU if at all possible.  It only applies to hardware counters\nand only to group leaders.  If a pinned counter cannot be put onto the\nCPU (e.g. because there are not enough hardware counters or because of\na conflict with some other event), then the counter goes into an\n'error' state, where reads return end-of-file (i.e. read() returns 0)\nuntil the counter is subsequently enabled or disabled.\n\nThe 'exclusive' bit, if set, specifies that when this counter's group\nis on the CPU, it should be the only group using the CPU's counters.\nIn future, this will allow sophisticated monitoring programs to supply\nextra configuration information via 'extra_config_len' to exploit\nadvanced features of the CPU's Performance Monitor Unit (PMU) that are\nnot otherwise accessible and that might disrupt other hardware\ncounters.\n\nThe 'exclude_user', 'exclude_kernel' and 'exclude_hv' bits provide a\nway to request that counting of events be restricted to times when the\nCPU is in user, kernel and/or hypervisor mode.\n\nFurthermore the 'exclude_host' and 'exclude_guest' bits provide a way\nto request counting of events restricted to guest and host contexts when\nusing Linux as the hypervisor.\n\nThe 'mmap' and 'munmap' bits allow recording of PROT_EXEC mmap/munmap\noperations, these can be used to relate userspace IP addresses to actual\ncode, even after the mapping (or even the whole process) is gone,\nthese events are recorded in the ring-buffer (see below).\n\nThe 'comm' bit allows tracking of process comm data on process creation.\nThis too is recorded in the ring-buffer (see below).\n\nThe 'pid' parameter to the sys_perf_event_open() system call allows the\ncounter to be specific to a task:\n\n pid == 0: if the pid parameter is zero, the counter is attached to the\n current task.\n\n pid > 0: the counter is attached to a specific task (if the current task\n has sufficient privilege to do so)\n\n pid < 0: all tasks are counted (per cpu counters)\n\nThe 'cpu' parameter allows a counter to be made specific to a CPU:\n\n cpu >= 0: the counter is restricted to a specific CPU\n cpu == -1: the counter counts on all CPUs\n\n(Note: the combination of 'pid == -1' and 'cpu == -1' is not valid.)\n\nA 'pid > 0' and 'cpu == -1' counter is a per task counter that counts\nevents of that task and 'follows' that task to whatever CPU the task\ngets schedule to. Per task counters can be created by any user, for\ntheir own tasks.\n\nA 'pid == -1' and 'cpu == x' counter is a per CPU counter that counts\nall events on CPU-x. Per CPU counters need CAP_PERFMON or CAP_SYS_ADMIN\nprivilege.\n\nThe 'flags' parameter is currently unused and must be zero.\n\nThe 'group_fd' parameter allows counter \"groups\" to be set up.  A\ncounter group has one counter which is the group \"leader\".  The leader\nis created first, with group_fd = -1 in the sys_perf_event_open call\nthat creates it.  The rest of the group members are created\nsubsequently, with group_fd giving the fd of the group leader.\n(A single counter on its own is created with group_fd = -1 and is\nconsidered to be a group with only 1 member.)\n\nA counter group is scheduled onto the CPU as a unit, that is, it will\nonly be put onto the CPU if all of the counters in the group can be\nput onto the CPU.  This means that the values of the member counters\ncan be meaningfully compared, added, divided (to get ratios), etc.,\nwith each other, since they have counted events for the same set of\nexecuted instructions.\n\n\nLike stated, asynchronous events, like counter overflow or PROT_EXEC mmap\ntracking are logged into a ring-buffer. This ring-buffer is created and\naccessed through mmap().\n\nThe mmap size should be 1+2^n pages, where the first page is a meta-data page\n(struct perf_event_mmap_page) that contains various bits of information such\nas where the ring-buffer head is.\n\n/*\n * Structure of the page that can be mapped via mmap\n */\nstruct perf_event_mmap_page {\n        __u32   version;                /* version number of this structure */\n        __u32   compat_version;         /* lowest version this is compat with */\n\n        /*\n         * Bits needed to read the hw counters in user-space.\n         *\n         *   u32 seq;\n         *   s64 count;\n         *\n         *   do {\n         *     seq = pc->lock;\n         *\n         *     barrier()\n         *     if (pc->index) {\n         *       count = pmc_read(pc->index - 1);\n         *       count += pc->offset;\n         *     } else\n         *       goto regular_read;\n         *\n         *     barrier();\n         *   } while (pc->lock != seq);\n         *\n         * NOTE: for obvious reason this only works on self-monitoring\n         *       processes.\n         */\n        __u32   lock;                   /* seqlock for synchronization */\n        __u32   index;                  /* hardware counter identifier */\n        __s64   offset;                 /* add to hardware counter value */\n\n        /*\n         * Control data for the mmap() data buffer.\n         *\n         * User-space reading this value should issue an rmb(), on SMP capable\n         * platforms, after reading this value -- see perf_event_wakeup().\n         */\n        __u32   data_head;              /* head in the data section */\n};\n\nNOTE: the hw-counter userspace bits are arch specific and are currently only\n      implemented on powerpc.\n\nThe following 2^n pages are the ring-buffer which contains events of the form:\n\n#define PERF_RECORD_MISC_KERNEL          (1 << 0)\n#define PERF_RECORD_MISC_USER            (1 << 1)\n#define PERF_RECORD_MISC_OVERFLOW        (1 << 2)\n\nstruct perf_event_header {\n        __u32   type;\n        __u16   misc;\n        __u16   size;\n};\n\nenum perf_event_type {\n\n        /*\n         * The MMAP events record the PROT_EXEC mappings so that we can\n         * correlate userspace IPs to code. They have the following structure:\n         *\n         * struct {\n         *      struct perf_event_header        header;\n         *\n         *      u32                             pid, tid;\n         *      u64                             addr;\n         *      u64                             len;\n         *      u64                             pgoff;\n         *      char                            filename[];\n         * };\n         */\n        PERF_RECORD_MMAP                 = 1,\n        PERF_RECORD_MUNMAP               = 2,\n\n        /*\n         * struct {\n         *      struct perf_event_header        header;\n         *\n         *      u32                             pid, tid;\n         *      char                            comm[];\n         * };\n         */\n        PERF_RECORD_COMM                 = 3,\n\n        /*\n         * When header.misc & PERF_RECORD_MISC_OVERFLOW the event_type field\n         * will be PERF_RECORD_*\n         *\n         * struct {\n         *      struct perf_event_header        header;\n         *\n         *      { u64                   ip;       } && PERF_RECORD_IP\n         *      { u32                   pid, tid; } && PERF_RECORD_TID\n         *      { u64                   time;     } && PERF_RECORD_TIME\n         *      { u64                   addr;     } && PERF_RECORD_ADDR\n         *\n         *      { u64                   nr;\n         *        { u64 event, val; }   cnt[nr];  } && PERF_RECORD_GROUP\n         *\n         *      { u16                   nr,\n         *                              hv,\n         *                              kernel,\n         *                              user;\n         *        u64                   ips[nr];  } && PERF_RECORD_CALLCHAIN\n         * };\n         */\n};\n\nNOTE: PERF_RECORD_CALLCHAIN is arch specific and currently only implemented\n      on x86.\n\nNotification of new events is possible through poll()/select()/epoll() and\nfcntl() managing signals.\n\nNormally a notification is generated for every page filled, however one can\nadditionally set perf_event_attr.wakeup_events to generate one every\nso many counter overflow events.\n\nFuture work will include a splice() interface to the ring-buffer.\n\n\nCounters can be enabled and disabled in two ways: via ioctl and via\nprctl.  When a counter is disabled, it doesn't count or generate\nevents but does continue to exist and maintain its count value.\n\nAn individual counter can be enabled with\n\n\tioctl(fd, PERF_EVENT_IOC_ENABLE, 0);\n\nor disabled with\n\n\tioctl(fd, PERF_EVENT_IOC_DISABLE, 0);\n\nFor a counter group, pass PERF_IOC_FLAG_GROUP as the third argument.\nEnabling or disabling the leader of a group enables or disables the\nwhole group; that is, while the group leader is disabled, none of the\ncounters in the group will count.  Enabling or disabling a member of a\ngroup other than the leader only affects that counter - disabling an\nnon-leader stops that counter from counting but doesn't affect any\nother counter.\n\nAdditionally, non-inherited overflow counters can use\n\n\tioctl(fd, PERF_EVENT_IOC_REFRESH, nr);\n\nto enable a counter for 'nr' events, after which it gets disabled again.\n\nA process can enable or disable all the counter groups that are\nattached to it, using prctl:\n\n\tprctl(PR_TASK_PERF_EVENTS_ENABLE);\n\n\tprctl(PR_TASK_PERF_EVENTS_DISABLE);\n\nThis applies to all counters on the current process, whether created\nby this process or by another, and doesn't affect any counters that\nthis process has created on other processes.  It only enables or\ndisables the group leaders, not any other members in the groups.\n\n\nArch requirements\n-----------------\n\nIf your architecture does not have hardware performance metrics, you can\nstill use the generic software counters based on hrtimers for sampling.\n\nSo to start with, in order to add HAVE_PERF_EVENTS to your Kconfig, you\nwill need at least this:\n\t- asm/perf_event.h - a basic stub will suffice at first\n\t- support for atomic64 types (and associated helper functions)\n\nIf your architecture does have hardware capabilities, you can override the\nweak stub hw_perf_event_init() to register hardware counters.\n\nArchitectures that have d-cache aliassing issues, such as Sparc and ARM,\nshould select PERF_USE_VMALLOC in order to avoid these for perf mmap().\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}