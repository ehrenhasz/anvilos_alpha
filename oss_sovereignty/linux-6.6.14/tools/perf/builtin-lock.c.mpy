{
  "module_name": "builtin-lock.c",
  "hash_id": "9b8587cc6125a83d83a8efc66464f4a87595529cdf31819bf08ef6d86a43327b",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-lock.c",
  "human_readable_source": "\n#include <errno.h>\n#include <inttypes.h>\n#include \"builtin.h\"\n#include \"perf.h\"\n\n#include \"util/evlist.h\" \n#include \"util/evsel.h\"\n#include \"util/symbol.h\"\n#include \"util/thread.h\"\n#include \"util/header.h\"\n#include \"util/target.h\"\n#include \"util/callchain.h\"\n#include \"util/lock-contention.h\"\n#include \"util/bpf_skel/lock_data.h\"\n\n#include <subcmd/pager.h>\n#include <subcmd/parse-options.h>\n#include \"util/trace-event.h\"\n#include \"util/tracepoint.h\"\n\n#include \"util/debug.h\"\n#include \"util/session.h\"\n#include \"util/tool.h\"\n#include \"util/data.h\"\n#include \"util/string2.h\"\n#include \"util/map.h\"\n#include \"util/util.h\"\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <semaphore.h>\n#include <math.h>\n#include <limits.h>\n#include <ctype.h>\n\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include <linux/err.h>\n#include <linux/stringify.h>\n\nstatic struct perf_session *session;\nstatic struct target target;\n\n \n#define LOCKHASH_BITS\t\t12\n#define LOCKHASH_SIZE\t\t(1UL << LOCKHASH_BITS)\n\nstatic struct hlist_head *lockhash_table;\n\n#define __lockhashfn(key)\thash_long((unsigned long)key, LOCKHASH_BITS)\n#define lockhashentry(key)\t(lockhash_table + __lockhashfn((key)))\n\nstatic struct rb_root\t\tthread_stats;\n\nstatic bool combine_locks;\nstatic bool show_thread_stats;\nstatic bool show_lock_addrs;\nstatic bool show_lock_owner;\nstatic bool use_bpf;\nstatic unsigned long bpf_map_entries = MAX_ENTRIES;\nstatic int max_stack_depth = CONTENTION_STACK_DEPTH;\nstatic int stack_skip = CONTENTION_STACK_SKIP;\nstatic int print_nr_entries = INT_MAX / 2;\nstatic LIST_HEAD(callstack_filters);\nstatic const char *output_name = NULL;\nstatic FILE *lock_output;\n\nstruct callstack_filter {\n\tstruct list_head list;\n\tchar name[];\n};\n\nstatic struct lock_filter filters;\n\nstatic enum lock_aggr_mode aggr_mode = LOCK_AGGR_ADDR;\n\nstatic bool needs_callstack(void)\n{\n\treturn !list_empty(&callstack_filters);\n}\n\nstatic struct thread_stat *thread_stat_find(u32 tid)\n{\n\tstruct rb_node *node;\n\tstruct thread_stat *st;\n\n\tnode = thread_stats.rb_node;\n\twhile (node) {\n\t\tst = container_of(node, struct thread_stat, rb);\n\t\tif (st->tid == tid)\n\t\t\treturn st;\n\t\telse if (tid < st->tid)\n\t\t\tnode = node->rb_left;\n\t\telse\n\t\t\tnode = node->rb_right;\n\t}\n\n\treturn NULL;\n}\n\nstatic void thread_stat_insert(struct thread_stat *new)\n{\n\tstruct rb_node **rb = &thread_stats.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct thread_stat *p;\n\n\twhile (*rb) {\n\t\tp = container_of(*rb, struct thread_stat, rb);\n\t\tparent = *rb;\n\n\t\tif (new->tid < p->tid)\n\t\t\trb = &(*rb)->rb_left;\n\t\telse if (new->tid > p->tid)\n\t\t\trb = &(*rb)->rb_right;\n\t\telse\n\t\t\tBUG_ON(\"inserting invalid thread_stat\\n\");\n\t}\n\n\trb_link_node(&new->rb, parent, rb);\n\trb_insert_color(&new->rb, &thread_stats);\n}\n\nstatic struct thread_stat *thread_stat_findnew_after_first(u32 tid)\n{\n\tstruct thread_stat *st;\n\n\tst = thread_stat_find(tid);\n\tif (st)\n\t\treturn st;\n\n\tst = zalloc(sizeof(struct thread_stat));\n\tif (!st) {\n\t\tpr_err(\"memory allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tst->tid = tid;\n\tINIT_LIST_HEAD(&st->seq_list);\n\n\tthread_stat_insert(st);\n\n\treturn st;\n}\n\nstatic struct thread_stat *thread_stat_findnew_first(u32 tid);\nstatic struct thread_stat *(*thread_stat_findnew)(u32 tid) =\n\tthread_stat_findnew_first;\n\nstatic struct thread_stat *thread_stat_findnew_first(u32 tid)\n{\n\tstruct thread_stat *st;\n\n\tst = zalloc(sizeof(struct thread_stat));\n\tif (!st) {\n\t\tpr_err(\"memory allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\tst->tid = tid;\n\tINIT_LIST_HEAD(&st->seq_list);\n\n\trb_link_node(&st->rb, NULL, &thread_stats.rb_node);\n\trb_insert_color(&st->rb, &thread_stats);\n\n\tthread_stat_findnew = thread_stat_findnew_after_first;\n\treturn st;\n}\n\n \n#define SINGLE_KEY(member)\t\t\t\t\t\t\\\n\tstatic int lock_stat_key_ ## member(struct lock_stat *one,\t\\\n\t\t\t\t\t struct lock_stat *two)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn one->member > two->member;\t\t\t\\\n\t}\n\nSINGLE_KEY(nr_acquired)\nSINGLE_KEY(nr_contended)\nSINGLE_KEY(avg_wait_time)\nSINGLE_KEY(wait_time_total)\nSINGLE_KEY(wait_time_max)\n\nstatic int lock_stat_key_wait_time_min(struct lock_stat *one,\n\t\t\t\t\tstruct lock_stat *two)\n{\n\tu64 s1 = one->wait_time_min;\n\tu64 s2 = two->wait_time_min;\n\tif (s1 == ULLONG_MAX)\n\t\ts1 = 0;\n\tif (s2 == ULLONG_MAX)\n\t\ts2 = 0;\n\treturn s1 > s2;\n}\n\nstruct lock_key {\n\t \n\tconst char\t\t*name;\n\t \n\tconst char\t\t*header;\n\t \n\tint\t\t\tlen;\n\t \n\tint\t\t\t(*key)(struct lock_stat*, struct lock_stat*);\n\t \n\tvoid\t\t\t(*print)(struct lock_key*, struct lock_stat*);\n\t \n\tstruct list_head\tlist;\n};\n\nstatic void lock_stat_key_print_time(unsigned long long nsec, int len)\n{\n\tstatic const struct {\n\t\tfloat base;\n\t\tconst char *unit;\n\t} table[] = {\n\t\t{ 1e9 * 3600, \"h \" },\n\t\t{ 1e9 * 60, \"m \" },\n\t\t{ 1e9, \"s \" },\n\t\t{ 1e6, \"ms\" },\n\t\t{ 1e3, \"us\" },\n\t\t{ 0, NULL },\n\t};\n\n\t \n\tif (len == 0) {\n\t\tfprintf(lock_output, \"%llu\", nsec);\n\t\treturn;\n\t}\n\n\tfor (int i = 0; table[i].unit; i++) {\n\t\tif (nsec < table[i].base)\n\t\t\tcontinue;\n\n\t\tfprintf(lock_output, \"%*.2f %s\", len - 3, nsec / table[i].base, table[i].unit);\n\t\treturn;\n\t}\n\n\tfprintf(lock_output, \"%*llu %s\", len - 3, nsec, \"ns\");\n}\n\n#define PRINT_KEY(member)\t\t\t\t\t\t\\\nstatic void lock_stat_key_print_ ## member(struct lock_key *key,\t\\\n\t\t\t\t\t   struct lock_stat *ls)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tfprintf(lock_output, \"%*llu\", key->len, (unsigned long long)ls->member);\\\n}\n\n#define PRINT_TIME(member)\t\t\t\t\t\t\\\nstatic void lock_stat_key_print_ ## member(struct lock_key *key,\t\\\n\t\t\t\t\t   struct lock_stat *ls)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tlock_stat_key_print_time((unsigned long long)ls->member, key->len);\t\\\n}\n\nPRINT_KEY(nr_acquired)\nPRINT_KEY(nr_contended)\nPRINT_TIME(avg_wait_time)\nPRINT_TIME(wait_time_total)\nPRINT_TIME(wait_time_max)\n\nstatic void lock_stat_key_print_wait_time_min(struct lock_key *key,\n\t\t\t\t\t      struct lock_stat *ls)\n{\n\tu64 wait_time = ls->wait_time_min;\n\n\tif (wait_time == ULLONG_MAX)\n\t\twait_time = 0;\n\n\tlock_stat_key_print_time(wait_time, key->len);\n}\n\n\nstatic const char\t\t*sort_key = \"acquired\";\n\nstatic int\t\t\t(*compare)(struct lock_stat *, struct lock_stat *);\n\nstatic struct rb_root\t\tsorted;  \nstatic struct rb_root\t\tresult;\t \n\nstatic LIST_HEAD(lock_keys);\nstatic const char\t\t*output_fields;\n\n#define DEF_KEY_LOCK(name, header, fn_suffix, len)\t\t\t\\\n\t{ #name, header, len, lock_stat_key_ ## fn_suffix, lock_stat_key_print_ ## fn_suffix, {} }\nstatic struct lock_key report_keys[] = {\n\tDEF_KEY_LOCK(acquired, \"acquired\", nr_acquired, 10),\n\tDEF_KEY_LOCK(contended, \"contended\", nr_contended, 10),\n\tDEF_KEY_LOCK(avg_wait, \"avg wait\", avg_wait_time, 12),\n\tDEF_KEY_LOCK(wait_total, \"total wait\", wait_time_total, 12),\n\tDEF_KEY_LOCK(wait_max, \"max wait\", wait_time_max, 12),\n\tDEF_KEY_LOCK(wait_min, \"min wait\", wait_time_min, 12),\n\n\t \n\t{ }\n};\n\nstatic struct lock_key contention_keys[] = {\n\tDEF_KEY_LOCK(contended, \"contended\", nr_contended, 10),\n\tDEF_KEY_LOCK(wait_total, \"total wait\", wait_time_total, 12),\n\tDEF_KEY_LOCK(wait_max, \"max wait\", wait_time_max, 12),\n\tDEF_KEY_LOCK(wait_min, \"min wait\", wait_time_min, 12),\n\tDEF_KEY_LOCK(avg_wait, \"avg wait\", avg_wait_time, 12),\n\n\t \n\t{ }\n};\n\nstatic int select_key(bool contention)\n{\n\tint i;\n\tstruct lock_key *keys = report_keys;\n\n\tif (contention)\n\t\tkeys = contention_keys;\n\n\tfor (i = 0; keys[i].name; i++) {\n\t\tif (!strcmp(keys[i].name, sort_key)) {\n\t\t\tcompare = keys[i].key;\n\n\t\t\t \n\t\t\tif (list_empty(&keys[i].list))\n\t\t\t\tlist_add_tail(&keys[i].list, &lock_keys);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpr_err(\"Unknown compare key: %s\\n\", sort_key);\n\treturn -1;\n}\n\nstatic int add_output_field(bool contention, char *name)\n{\n\tint i;\n\tstruct lock_key *keys = report_keys;\n\n\tif (contention)\n\t\tkeys = contention_keys;\n\n\tfor (i = 0; keys[i].name; i++) {\n\t\tif (strcmp(keys[i].name, name))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (list_empty(&keys[i].list))\n\t\t\tlist_add_tail(&keys[i].list, &lock_keys);\n\n\t\treturn 0;\n\t}\n\n\tpr_err(\"Unknown output field: %s\\n\", name);\n\treturn -1;\n}\n\nstatic int setup_output_field(bool contention, const char *str)\n{\n\tchar *tok, *tmp, *orig;\n\tint i, ret = 0;\n\tstruct lock_key *keys = report_keys;\n\n\tif (contention)\n\t\tkeys = contention_keys;\n\n\t \n\tif (str == NULL) {\n\t\tfor (i = 0; keys[i].name; i++)\n\t\t\tlist_add_tail(&keys[i].list, &lock_keys);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; keys[i].name; i++)\n\t\tINIT_LIST_HEAD(&keys[i].list);\n\n\torig = tmp = strdup(str);\n\tif (orig == NULL)\n\t\treturn -ENOMEM;\n\n\twhile ((tok = strsep(&tmp, \",\")) != NULL){\n\t\tret = add_output_field(contention, tok);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tfree(orig);\n\n\treturn ret;\n}\n\nstatic void combine_lock_stats(struct lock_stat *st)\n{\n\tstruct rb_node **rb = &sorted.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct lock_stat *p;\n\tint ret;\n\n\twhile (*rb) {\n\t\tp = container_of(*rb, struct lock_stat, rb);\n\t\tparent = *rb;\n\n\t\tif (st->name && p->name)\n\t\t\tret = strcmp(st->name, p->name);\n\t\telse\n\t\t\tret = !!st->name - !!p->name;\n\n\t\tif (ret == 0) {\n\t\t\tp->nr_acquired += st->nr_acquired;\n\t\t\tp->nr_contended += st->nr_contended;\n\t\t\tp->wait_time_total += st->wait_time_total;\n\n\t\t\tif (p->nr_contended)\n\t\t\t\tp->avg_wait_time = p->wait_time_total / p->nr_contended;\n\n\t\t\tif (p->wait_time_min > st->wait_time_min)\n\t\t\t\tp->wait_time_min = st->wait_time_min;\n\t\t\tif (p->wait_time_max < st->wait_time_max)\n\t\t\t\tp->wait_time_max = st->wait_time_max;\n\n\t\t\tp->broken |= st->broken;\n\t\t\tst->combined = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\trb = &(*rb)->rb_left;\n\t\telse\n\t\t\trb = &(*rb)->rb_right;\n\t}\n\n\trb_link_node(&st->rb, parent, rb);\n\trb_insert_color(&st->rb, &sorted);\n}\n\nstatic void insert_to_result(struct lock_stat *st,\n\t\t\t     int (*bigger)(struct lock_stat *, struct lock_stat *))\n{\n\tstruct rb_node **rb = &result.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct lock_stat *p;\n\n\tif (combine_locks && st->combined)\n\t\treturn;\n\n\twhile (*rb) {\n\t\tp = container_of(*rb, struct lock_stat, rb);\n\t\tparent = *rb;\n\n\t\tif (bigger(st, p))\n\t\t\trb = &(*rb)->rb_left;\n\t\telse\n\t\t\trb = &(*rb)->rb_right;\n\t}\n\n\trb_link_node(&st->rb, parent, rb);\n\trb_insert_color(&st->rb, &result);\n}\n\n \nstatic struct lock_stat *pop_from_result(void)\n{\n\tstruct rb_node *node = result.rb_node;\n\n\tif (!node)\n\t\treturn NULL;\n\n\twhile (node->rb_left)\n\t\tnode = node->rb_left;\n\n\trb_erase(node, &result);\n\treturn container_of(node, struct lock_stat, rb);\n}\n\nstruct lock_stat *lock_stat_find(u64 addr)\n{\n\tstruct hlist_head *entry = lockhashentry(addr);\n\tstruct lock_stat *ret;\n\n\thlist_for_each_entry(ret, entry, hash_entry) {\n\t\tif (ret->addr == addr)\n\t\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstruct lock_stat *lock_stat_findnew(u64 addr, const char *name, int flags)\n{\n\tstruct hlist_head *entry = lockhashentry(addr);\n\tstruct lock_stat *ret, *new;\n\n\thlist_for_each_entry(ret, entry, hash_entry) {\n\t\tif (ret->addr == addr)\n\t\t\treturn ret;\n\t}\n\n\tnew = zalloc(sizeof(struct lock_stat));\n\tif (!new)\n\t\tgoto alloc_failed;\n\n\tnew->addr = addr;\n\tnew->name = strdup(name);\n\tif (!new->name) {\n\t\tfree(new);\n\t\tgoto alloc_failed;\n\t}\n\n\tnew->flags = flags;\n\tnew->wait_time_min = ULLONG_MAX;\n\n\thlist_add_head(&new->hash_entry, entry);\n\treturn new;\n\nalloc_failed:\n\tpr_err(\"memory allocation failed\\n\");\n\treturn NULL;\n}\n\nbool match_callstack_filter(struct machine *machine, u64 *callstack)\n{\n\tstruct map *kmap;\n\tstruct symbol *sym;\n\tu64 ip;\n\tconst char *arch = perf_env__arch(machine->env);\n\n\tif (list_empty(&callstack_filters))\n\t\treturn true;\n\n\tfor (int i = 0; i < max_stack_depth; i++) {\n\t\tstruct callstack_filter *filter;\n\n\t\t \n\t\tif (!callstack || (!callstack[i] && (strcmp(arch, \"powerpc\") ||\n\t\t\t\t\t\t(i != 1 && i != 2))))\n\t\t\tbreak;\n\n\t\tip = callstack[i];\n\t\tsym = machine__find_kernel_symbol(machine, ip, &kmap);\n\t\tif (sym == NULL)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(filter, &callstack_filters, list) {\n\t\t\tif (strstr(sym->name, filter->name))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstruct trace_lock_handler {\n\t \n\tint (*acquire_event)(struct evsel *evsel,\n\t\t\t     struct perf_sample *sample);\n\n\t \n\tint (*acquired_event)(struct evsel *evsel,\n\t\t\t      struct perf_sample *sample);\n\n\t \n\tint (*contended_event)(struct evsel *evsel,\n\t\t\t       struct perf_sample *sample);\n\n\t \n\tint (*release_event)(struct evsel *evsel,\n\t\t\t     struct perf_sample *sample);\n\n\t \n\tint (*contention_begin_event)(struct evsel *evsel,\n\t\t\t\t      struct perf_sample *sample);\n\n\t \n\tint (*contention_end_event)(struct evsel *evsel,\n\t\t\t\t    struct perf_sample *sample);\n};\n\nstatic struct lock_seq_stat *get_seq(struct thread_stat *ts, u64 addr)\n{\n\tstruct lock_seq_stat *seq;\n\n\tlist_for_each_entry(seq, &ts->seq_list, list) {\n\t\tif (seq->addr == addr)\n\t\t\treturn seq;\n\t}\n\n\tseq = zalloc(sizeof(struct lock_seq_stat));\n\tif (!seq) {\n\t\tpr_err(\"memory allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\tseq->state = SEQ_STATE_UNINITIALIZED;\n\tseq->addr = addr;\n\n\tlist_add(&seq->list, &ts->seq_list);\n\treturn seq;\n}\n\nenum broken_state {\n\tBROKEN_ACQUIRE,\n\tBROKEN_ACQUIRED,\n\tBROKEN_CONTENDED,\n\tBROKEN_RELEASE,\n\tBROKEN_MAX,\n};\n\nstatic int bad_hist[BROKEN_MAX];\n\nenum acquire_flags {\n\tTRY_LOCK = 1,\n\tREAD_LOCK = 2,\n};\n\nstatic int get_key_by_aggr_mode_simple(u64 *key, u64 addr, u32 tid)\n{\n\tswitch (aggr_mode) {\n\tcase LOCK_AGGR_ADDR:\n\t\t*key = addr;\n\t\tbreak;\n\tcase LOCK_AGGR_TASK:\n\t\t*key = tid;\n\t\tbreak;\n\tcase LOCK_AGGR_CALLER:\n\tdefault:\n\t\tpr_err(\"Invalid aggregation mode: %d\\n\", aggr_mode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic u64 callchain_id(struct evsel *evsel, struct perf_sample *sample);\n\nstatic int get_key_by_aggr_mode(u64 *key, u64 addr, struct evsel *evsel,\n\t\t\t\t struct perf_sample *sample)\n{\n\tif (aggr_mode == LOCK_AGGR_CALLER) {\n\t\t*key = callchain_id(evsel, sample);\n\t\treturn 0;\n\t}\n\treturn get_key_by_aggr_mode_simple(key, addr, sample->tid);\n}\n\nstatic int report_lock_acquire_event(struct evsel *evsel,\n\t\t\t\t     struct perf_sample *sample)\n{\n\tstruct lock_stat *ls;\n\tstruct thread_stat *ts;\n\tstruct lock_seq_stat *seq;\n\tconst char *name = evsel__strval(evsel, sample, \"name\");\n\tu64 addr = evsel__intval(evsel, sample, \"lockdep_addr\");\n\tint flag = evsel__intval(evsel, sample, \"flags\");\n\tu64 key;\n\tint ret;\n\n\tret = get_key_by_aggr_mode_simple(&key, addr, sample->tid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tls = lock_stat_findnew(key, name, 0);\n\tif (!ls)\n\t\treturn -ENOMEM;\n\n\tts = thread_stat_findnew(sample->tid);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tseq = get_seq(ts, addr);\n\tif (!seq)\n\t\treturn -ENOMEM;\n\n\tswitch (seq->state) {\n\tcase SEQ_STATE_UNINITIALIZED:\n\tcase SEQ_STATE_RELEASED:\n\t\tif (!flag) {\n\t\t\tseq->state = SEQ_STATE_ACQUIRING;\n\t\t} else {\n\t\t\tif (flag & TRY_LOCK)\n\t\t\t\tls->nr_trylock++;\n\t\t\tif (flag & READ_LOCK)\n\t\t\t\tls->nr_readlock++;\n\t\t\tseq->state = SEQ_STATE_READ_ACQUIRED;\n\t\t\tseq->read_count = 1;\n\t\t\tls->nr_acquired++;\n\t\t}\n\t\tbreak;\n\tcase SEQ_STATE_READ_ACQUIRED:\n\t\tif (flag & READ_LOCK) {\n\t\t\tseq->read_count++;\n\t\t\tls->nr_acquired++;\n\t\t\tgoto end;\n\t\t} else {\n\t\t\tgoto broken;\n\t\t}\n\t\tbreak;\n\tcase SEQ_STATE_ACQUIRED:\n\tcase SEQ_STATE_ACQUIRING:\n\tcase SEQ_STATE_CONTENDED:\nbroken:\n\t\t \n\t\tif (!ls->broken) {\n\t\t\tls->broken = 1;\n\t\t\tbad_hist[BROKEN_ACQUIRE]++;\n\t\t}\n\t\tlist_del_init(&seq->list);\n\t\tfree(seq);\n\t\tgoto end;\n\tdefault:\n\t\tBUG_ON(\"Unknown state of lock sequence found!\\n\");\n\t\tbreak;\n\t}\n\n\tls->nr_acquire++;\n\tseq->prev_event_time = sample->time;\nend:\n\treturn 0;\n}\n\nstatic int report_lock_acquired_event(struct evsel *evsel,\n\t\t\t\t      struct perf_sample *sample)\n{\n\tstruct lock_stat *ls;\n\tstruct thread_stat *ts;\n\tstruct lock_seq_stat *seq;\n\tu64 contended_term;\n\tconst char *name = evsel__strval(evsel, sample, \"name\");\n\tu64 addr = evsel__intval(evsel, sample, \"lockdep_addr\");\n\tu64 key;\n\tint ret;\n\n\tret = get_key_by_aggr_mode_simple(&key, addr, sample->tid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tls = lock_stat_findnew(key, name, 0);\n\tif (!ls)\n\t\treturn -ENOMEM;\n\n\tts = thread_stat_findnew(sample->tid);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tseq = get_seq(ts, addr);\n\tif (!seq)\n\t\treturn -ENOMEM;\n\n\tswitch (seq->state) {\n\tcase SEQ_STATE_UNINITIALIZED:\n\t\t \n\t\treturn 0;\n\tcase SEQ_STATE_ACQUIRING:\n\t\tbreak;\n\tcase SEQ_STATE_CONTENDED:\n\t\tcontended_term = sample->time - seq->prev_event_time;\n\t\tls->wait_time_total += contended_term;\n\t\tif (contended_term < ls->wait_time_min)\n\t\t\tls->wait_time_min = contended_term;\n\t\tif (ls->wait_time_max < contended_term)\n\t\t\tls->wait_time_max = contended_term;\n\t\tbreak;\n\tcase SEQ_STATE_RELEASED:\n\tcase SEQ_STATE_ACQUIRED:\n\tcase SEQ_STATE_READ_ACQUIRED:\n\t\t \n\t\tif (!ls->broken) {\n\t\t\tls->broken = 1;\n\t\t\tbad_hist[BROKEN_ACQUIRED]++;\n\t\t}\n\t\tlist_del_init(&seq->list);\n\t\tfree(seq);\n\t\tgoto end;\n\tdefault:\n\t\tBUG_ON(\"Unknown state of lock sequence found!\\n\");\n\t\tbreak;\n\t}\n\n\tseq->state = SEQ_STATE_ACQUIRED;\n\tls->nr_acquired++;\n\tls->avg_wait_time = ls->nr_contended ? ls->wait_time_total/ls->nr_contended : 0;\n\tseq->prev_event_time = sample->time;\nend:\n\treturn 0;\n}\n\nstatic int report_lock_contended_event(struct evsel *evsel,\n\t\t\t\t       struct perf_sample *sample)\n{\n\tstruct lock_stat *ls;\n\tstruct thread_stat *ts;\n\tstruct lock_seq_stat *seq;\n\tconst char *name = evsel__strval(evsel, sample, \"name\");\n\tu64 addr = evsel__intval(evsel, sample, \"lockdep_addr\");\n\tu64 key;\n\tint ret;\n\n\tret = get_key_by_aggr_mode_simple(&key, addr, sample->tid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tls = lock_stat_findnew(key, name, 0);\n\tif (!ls)\n\t\treturn -ENOMEM;\n\n\tts = thread_stat_findnew(sample->tid);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tseq = get_seq(ts, addr);\n\tif (!seq)\n\t\treturn -ENOMEM;\n\n\tswitch (seq->state) {\n\tcase SEQ_STATE_UNINITIALIZED:\n\t\t \n\t\treturn 0;\n\tcase SEQ_STATE_ACQUIRING:\n\t\tbreak;\n\tcase SEQ_STATE_RELEASED:\n\tcase SEQ_STATE_ACQUIRED:\n\tcase SEQ_STATE_READ_ACQUIRED:\n\tcase SEQ_STATE_CONTENDED:\n\t\t \n\t\tif (!ls->broken) {\n\t\t\tls->broken = 1;\n\t\t\tbad_hist[BROKEN_CONTENDED]++;\n\t\t}\n\t\tlist_del_init(&seq->list);\n\t\tfree(seq);\n\t\tgoto end;\n\tdefault:\n\t\tBUG_ON(\"Unknown state of lock sequence found!\\n\");\n\t\tbreak;\n\t}\n\n\tseq->state = SEQ_STATE_CONTENDED;\n\tls->nr_contended++;\n\tls->avg_wait_time = ls->wait_time_total/ls->nr_contended;\n\tseq->prev_event_time = sample->time;\nend:\n\treturn 0;\n}\n\nstatic int report_lock_release_event(struct evsel *evsel,\n\t\t\t\t     struct perf_sample *sample)\n{\n\tstruct lock_stat *ls;\n\tstruct thread_stat *ts;\n\tstruct lock_seq_stat *seq;\n\tconst char *name = evsel__strval(evsel, sample, \"name\");\n\tu64 addr = evsel__intval(evsel, sample, \"lockdep_addr\");\n\tu64 key;\n\tint ret;\n\n\tret = get_key_by_aggr_mode_simple(&key, addr, sample->tid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tls = lock_stat_findnew(key, name, 0);\n\tif (!ls)\n\t\treturn -ENOMEM;\n\n\tts = thread_stat_findnew(sample->tid);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tseq = get_seq(ts, addr);\n\tif (!seq)\n\t\treturn -ENOMEM;\n\n\tswitch (seq->state) {\n\tcase SEQ_STATE_UNINITIALIZED:\n\t\tgoto end;\n\tcase SEQ_STATE_ACQUIRED:\n\t\tbreak;\n\tcase SEQ_STATE_READ_ACQUIRED:\n\t\tseq->read_count--;\n\t\tBUG_ON(seq->read_count < 0);\n\t\tif (seq->read_count) {\n\t\t\tls->nr_release++;\n\t\t\tgoto end;\n\t\t}\n\t\tbreak;\n\tcase SEQ_STATE_ACQUIRING:\n\tcase SEQ_STATE_CONTENDED:\n\tcase SEQ_STATE_RELEASED:\n\t\t \n\t\tif (!ls->broken) {\n\t\t\tls->broken = 1;\n\t\t\tbad_hist[BROKEN_RELEASE]++;\n\t\t}\n\t\tgoto free_seq;\n\tdefault:\n\t\tBUG_ON(\"Unknown state of lock sequence found!\\n\");\n\t\tbreak;\n\t}\n\n\tls->nr_release++;\nfree_seq:\n\tlist_del_init(&seq->list);\n\tfree(seq);\nend:\n\treturn 0;\n}\n\nstatic int get_symbol_name_offset(struct map *map, struct symbol *sym, u64 ip,\n\t\t\t\t  char *buf, int size)\n{\n\tu64 offset;\n\n\tif (map == NULL || sym == NULL) {\n\t\tbuf[0] = '\\0';\n\t\treturn 0;\n\t}\n\n\toffset = map__map_ip(map, ip) - sym->start;\n\n\tif (offset)\n\t\treturn scnprintf(buf, size, \"%s+%#lx\", sym->name, offset);\n\telse\n\t\treturn strlcpy(buf, sym->name, size);\n}\nstatic int lock_contention_caller(struct evsel *evsel, struct perf_sample *sample,\n\t\t\t\t  char *buf, int size)\n{\n\tstruct thread *thread;\n\tstruct callchain_cursor *cursor;\n\tstruct machine *machine = &session->machines.host;\n\tstruct symbol *sym;\n\tint skip = 0;\n\tint ret;\n\n\t \n\tif (show_thread_stats)\n\t\treturn -1;\n\n\tthread = machine__findnew_thread(machine, -1, sample->pid);\n\tif (thread == NULL)\n\t\treturn -1;\n\n\tcursor = get_tls_callchain_cursor();\n\n\t \n\tret = thread__resolve_callchain(thread, cursor, evsel, sample,\n\t\t\t\t\tNULL, NULL, max_stack_depth);\n\tif (ret != 0) {\n\t\tthread__put(thread);\n\t\treturn -1;\n\t}\n\n\tcallchain_cursor_commit(cursor);\n\tthread__put(thread);\n\n\twhile (true) {\n\t\tstruct callchain_cursor_node *node;\n\n\t\tnode = callchain_cursor_current(cursor);\n\t\tif (node == NULL)\n\t\t\tbreak;\n\n\t\t \n\t\tif (++skip <= stack_skip)\n\t\t\tgoto next;\n\n\t\tsym = node->ms.sym;\n\t\tif (sym && !machine__is_lock_function(machine, node->ip)) {\n\t\t\tget_symbol_name_offset(node->ms.map, sym, node->ip,\n\t\t\t\t\t       buf, size);\n\t\t\treturn 0;\n\t\t}\n\nnext:\n\t\tcallchain_cursor_advance(cursor);\n\t}\n\treturn -1;\n}\n\nstatic u64 callchain_id(struct evsel *evsel, struct perf_sample *sample)\n{\n\tstruct callchain_cursor *cursor;\n\tstruct machine *machine = &session->machines.host;\n\tstruct thread *thread;\n\tu64 hash = 0;\n\tint skip = 0;\n\tint ret;\n\n\tthread = machine__findnew_thread(machine, -1, sample->pid);\n\tif (thread == NULL)\n\t\treturn -1;\n\n\tcursor = get_tls_callchain_cursor();\n\t \n\tret = thread__resolve_callchain(thread, cursor, evsel, sample,\n\t\t\t\t\tNULL, NULL, max_stack_depth);\n\tthread__put(thread);\n\n\tif (ret != 0)\n\t\treturn -1;\n\n\tcallchain_cursor_commit(cursor);\n\n\twhile (true) {\n\t\tstruct callchain_cursor_node *node;\n\n\t\tnode = callchain_cursor_current(cursor);\n\t\tif (node == NULL)\n\t\t\tbreak;\n\n\t\t \n\t\tif (++skip <= stack_skip)\n\t\t\tgoto next;\n\n\t\tif (node->ms.sym && machine__is_lock_function(machine, node->ip))\n\t\t\tgoto next;\n\n\t\thash ^= hash_long((unsigned long)node->ip, 64);\n\nnext:\n\t\tcallchain_cursor_advance(cursor);\n\t}\n\treturn hash;\n}\n\nstatic u64 *get_callstack(struct perf_sample *sample, int max_stack)\n{\n\tu64 *callstack;\n\tu64 i;\n\tint c;\n\n\tcallstack = calloc(max_stack, sizeof(*callstack));\n\tif (callstack == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0, c = 0; i < sample->callchain->nr && c < max_stack; i++) {\n\t\tu64 ip = sample->callchain->ips[i];\n\n\t\tif (ip >= PERF_CONTEXT_MAX)\n\t\t\tcontinue;\n\n\t\tcallstack[c++] = ip;\n\t}\n\treturn callstack;\n}\n\nstatic int report_lock_contention_begin_event(struct evsel *evsel,\n\t\t\t\t\t      struct perf_sample *sample)\n{\n\tstruct lock_stat *ls;\n\tstruct thread_stat *ts;\n\tstruct lock_seq_stat *seq;\n\tu64 addr = evsel__intval(evsel, sample, \"lock_addr\");\n\tunsigned int flags = evsel__intval(evsel, sample, \"flags\");\n\tu64 key;\n\tint i, ret;\n\tstatic bool kmap_loaded;\n\tstruct machine *machine = &session->machines.host;\n\tstruct map *kmap;\n\tstruct symbol *sym;\n\n\tret = get_key_by_aggr_mode(&key, addr, evsel, sample);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!kmap_loaded) {\n\t\tunsigned long *addrs;\n\n\t\t \n\t\tmap__load(machine__kernel_map(machine));\n\t\tkmap_loaded = true;\n\n\t\t \n\t\tfor (i = 0; i < filters.nr_syms; i++) {\n\t\t\tsym = machine__find_kernel_symbol_by_name(machine,\n\t\t\t\t\t\t\t\t  filters.syms[i],\n\t\t\t\t\t\t\t\t  &kmap);\n\t\t\tif (sym == NULL) {\n\t\t\t\tpr_warning(\"ignore unknown symbol: %s\\n\",\n\t\t\t\t\t   filters.syms[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taddrs = realloc(filters.addrs,\n\t\t\t\t\t(filters.nr_addrs + 1) * sizeof(*addrs));\n\t\t\tif (addrs == NULL) {\n\t\t\t\tpr_warning(\"memory allocation failure\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\taddrs[filters.nr_addrs++] = map__unmap_ip(kmap, sym->start);\n\t\t\tfilters.addrs = addrs;\n\t\t}\n\t}\n\n\tls = lock_stat_find(key);\n\tif (!ls) {\n\t\tchar buf[128];\n\t\tconst char *name = \"\";\n\n\t\tswitch (aggr_mode) {\n\t\tcase LOCK_AGGR_ADDR:\n\t\t\tsym = machine__find_kernel_symbol(machine, key, &kmap);\n\t\t\tif (sym)\n\t\t\t\tname = sym->name;\n\t\t\tbreak;\n\t\tcase LOCK_AGGR_CALLER:\n\t\t\tname = buf;\n\t\t\tif (lock_contention_caller(evsel, sample, buf, sizeof(buf)) < 0)\n\t\t\t\tname = \"Unknown\";\n\t\t\tbreak;\n\t\tcase LOCK_AGGR_TASK:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tls = lock_stat_findnew(key, name, flags);\n\t\tif (!ls)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (filters.nr_types) {\n\t\tbool found = false;\n\n\t\tfor (i = 0; i < filters.nr_types; i++) {\n\t\t\tif (flags == filters.types[i]) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn 0;\n\t}\n\n\tif (filters.nr_addrs) {\n\t\tbool found = false;\n\n\t\tfor (i = 0; i < filters.nr_addrs; i++) {\n\t\t\tif (addr == filters.addrs[i]) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn 0;\n\t}\n\n\tif (needs_callstack()) {\n\t\tu64 *callstack = get_callstack(sample, max_stack_depth);\n\t\tif (callstack == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (!match_callstack_filter(machine, callstack)) {\n\t\t\tfree(callstack);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ls->callstack == NULL)\n\t\t\tls->callstack = callstack;\n\t\telse\n\t\t\tfree(callstack);\n\t}\n\n\tts = thread_stat_findnew(sample->tid);\n\tif (!ts)\n\t\treturn -ENOMEM;\n\n\tseq = get_seq(ts, addr);\n\tif (!seq)\n\t\treturn -ENOMEM;\n\n\tswitch (seq->state) {\n\tcase SEQ_STATE_UNINITIALIZED:\n\tcase SEQ_STATE_ACQUIRED:\n\t\tbreak;\n\tcase SEQ_STATE_CONTENDED:\n\t\t \n\t\tgoto end;\n\tcase SEQ_STATE_ACQUIRING:\n\tcase SEQ_STATE_READ_ACQUIRED:\n\tcase SEQ_STATE_RELEASED:\n\t\t \n\t\tif (!ls->broken) {\n\t\t\tls->broken = 1;\n\t\t\tbad_hist[BROKEN_CONTENDED]++;\n\t\t}\n\t\tlist_del_init(&seq->list);\n\t\tfree(seq);\n\t\tgoto end;\n\tdefault:\n\t\tBUG_ON(\"Unknown state of lock sequence found!\\n\");\n\t\tbreak;\n\t}\n\n\tif (seq->state != SEQ_STATE_CONTENDED) {\n\t\tseq->state = SEQ_STATE_CONTENDED;\n\t\tseq->prev_event_time = sample->time;\n\t\tls->nr_contended++;\n\t}\nend:\n\treturn 0;\n}\n\nstatic int report_lock_contention_end_event(struct evsel *evsel,\n\t\t\t\t\t    struct perf_sample *sample)\n{\n\tstruct lock_stat *ls;\n\tstruct thread_stat *ts;\n\tstruct lock_seq_stat *seq;\n\tu64 contended_term;\n\tu64 addr = evsel__intval(evsel, sample, \"lock_addr\");\n\tu64 key;\n\tint ret;\n\n\tret = get_key_by_aggr_mode(&key, addr, evsel, sample);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tls = lock_stat_find(key);\n\tif (!ls)\n\t\treturn 0;\n\n\tts = thread_stat_find(sample->tid);\n\tif (!ts)\n\t\treturn 0;\n\n\tseq = get_seq(ts, addr);\n\tif (!seq)\n\t\treturn -ENOMEM;\n\n\tswitch (seq->state) {\n\tcase SEQ_STATE_UNINITIALIZED:\n\t\tgoto end;\n\tcase SEQ_STATE_CONTENDED:\n\t\tcontended_term = sample->time - seq->prev_event_time;\n\t\tls->wait_time_total += contended_term;\n\t\tif (contended_term < ls->wait_time_min)\n\t\t\tls->wait_time_min = contended_term;\n\t\tif (ls->wait_time_max < contended_term)\n\t\t\tls->wait_time_max = contended_term;\n\t\tbreak;\n\tcase SEQ_STATE_ACQUIRING:\n\tcase SEQ_STATE_ACQUIRED:\n\tcase SEQ_STATE_READ_ACQUIRED:\n\tcase SEQ_STATE_RELEASED:\n\t\t \n\t\tif (!ls->broken) {\n\t\t\tls->broken = 1;\n\t\t\tbad_hist[BROKEN_ACQUIRED]++;\n\t\t}\n\t\tlist_del_init(&seq->list);\n\t\tfree(seq);\n\t\tgoto end;\n\tdefault:\n\t\tBUG_ON(\"Unknown state of lock sequence found!\\n\");\n\t\tbreak;\n\t}\n\n\tseq->state = SEQ_STATE_ACQUIRED;\n\tls->nr_acquired++;\n\tls->avg_wait_time = ls->wait_time_total/ls->nr_acquired;\nend:\n\treturn 0;\n}\n\n \n \nstatic struct trace_lock_handler report_lock_ops  = {\n\t.acquire_event\t\t= report_lock_acquire_event,\n\t.acquired_event\t\t= report_lock_acquired_event,\n\t.contended_event\t= report_lock_contended_event,\n\t.release_event\t\t= report_lock_release_event,\n\t.contention_begin_event\t= report_lock_contention_begin_event,\n\t.contention_end_event\t= report_lock_contention_end_event,\n};\n\nstatic struct trace_lock_handler contention_lock_ops  = {\n\t.contention_begin_event\t= report_lock_contention_begin_event,\n\t.contention_end_event\t= report_lock_contention_end_event,\n};\n\n\nstatic struct trace_lock_handler *trace_handler;\n\nstatic int evsel__process_lock_acquire(struct evsel *evsel, struct perf_sample *sample)\n{\n\tif (trace_handler->acquire_event)\n\t\treturn trace_handler->acquire_event(evsel, sample);\n\treturn 0;\n}\n\nstatic int evsel__process_lock_acquired(struct evsel *evsel, struct perf_sample *sample)\n{\n\tif (trace_handler->acquired_event)\n\t\treturn trace_handler->acquired_event(evsel, sample);\n\treturn 0;\n}\n\nstatic int evsel__process_lock_contended(struct evsel *evsel, struct perf_sample *sample)\n{\n\tif (trace_handler->contended_event)\n\t\treturn trace_handler->contended_event(evsel, sample);\n\treturn 0;\n}\n\nstatic int evsel__process_lock_release(struct evsel *evsel, struct perf_sample *sample)\n{\n\tif (trace_handler->release_event)\n\t\treturn trace_handler->release_event(evsel, sample);\n\treturn 0;\n}\n\nstatic int evsel__process_contention_begin(struct evsel *evsel, struct perf_sample *sample)\n{\n\tif (trace_handler->contention_begin_event)\n\t\treturn trace_handler->contention_begin_event(evsel, sample);\n\treturn 0;\n}\n\nstatic int evsel__process_contention_end(struct evsel *evsel, struct perf_sample *sample)\n{\n\tif (trace_handler->contention_end_event)\n\t\treturn trace_handler->contention_end_event(evsel, sample);\n\treturn 0;\n}\n\nstatic void print_bad_events(int bad, int total)\n{\n\t \n\tint i;\n\tint broken = 0;\n\tconst char *name[4] =\n\t\t{ \"acquire\", \"acquired\", \"contended\", \"release\" };\n\n\tfor (i = 0; i < BROKEN_MAX; i++)\n\t\tbroken += bad_hist[i];\n\n\tif (quiet || total == 0 || (broken == 0 && verbose <= 0))\n\t\treturn;\n\n\tfprintf(lock_output, \"\\n=== output for debug ===\\n\\n\");\n\tfprintf(lock_output, \"bad: %d, total: %d\\n\", bad, total);\n\tfprintf(lock_output, \"bad rate: %.2f %%\\n\", (double)bad / (double)total * 100);\n\tfprintf(lock_output, \"histogram of events caused bad sequence\\n\");\n\tfor (i = 0; i < BROKEN_MAX; i++)\n\t\tfprintf(lock_output, \" %10s: %d\\n\", name[i], bad_hist[i]);\n}\n\n \nstatic void print_result(void)\n{\n\tstruct lock_stat *st;\n\tstruct lock_key *key;\n\tchar cut_name[20];\n\tint bad, total, printed;\n\n\tif (!quiet) {\n\t\tfprintf(lock_output, \"%20s \", \"Name\");\n\t\tlist_for_each_entry(key, &lock_keys, list)\n\t\t\tfprintf(lock_output, \"%*s \", key->len, key->header);\n\t\tfprintf(lock_output, \"\\n\\n\");\n\t}\n\n\tbad = total = printed = 0;\n\twhile ((st = pop_from_result())) {\n\t\ttotal++;\n\t\tif (st->broken)\n\t\t\tbad++;\n\t\tif (!st->nr_acquired)\n\t\t\tcontinue;\n\n\t\tbzero(cut_name, 20);\n\n\t\tif (strlen(st->name) < 20) {\n\t\t\t \n\t\t\tconst char *name = st->name;\n\n\t\t\tif (show_thread_stats) {\n\t\t\t\tstruct thread *t;\n\n\t\t\t\t \n\t\t\t\tt = perf_session__findnew(session, st->addr);\n\t\t\t\tname = thread__comm_str(t);\n\t\t\t}\n\n\t\t\tfprintf(lock_output, \"%20s \", name);\n\t\t} else {\n\t\t\tstrncpy(cut_name, st->name, 16);\n\t\t\tcut_name[16] = '.';\n\t\t\tcut_name[17] = '.';\n\t\t\tcut_name[18] = '.';\n\t\t\tcut_name[19] = '\\0';\n\t\t\t \n\t\t\tfprintf(lock_output, \"%20s \", cut_name);\n\t\t}\n\n\t\tlist_for_each_entry(key, &lock_keys, list) {\n\t\t\tkey->print(key, st);\n\t\t\tfprintf(lock_output, \" \");\n\t\t}\n\t\tfprintf(lock_output, \"\\n\");\n\n\t\tif (++printed >= print_nr_entries)\n\t\t\tbreak;\n\t}\n\n\tprint_bad_events(bad, total);\n}\n\nstatic bool info_threads, info_map;\n\nstatic void dump_threads(void)\n{\n\tstruct thread_stat *st;\n\tstruct rb_node *node;\n\tstruct thread *t;\n\n\tfprintf(lock_output, \"%10s: comm\\n\", \"Thread ID\");\n\n\tnode = rb_first(&thread_stats);\n\twhile (node) {\n\t\tst = container_of(node, struct thread_stat, rb);\n\t\tt = perf_session__findnew(session, st->tid);\n\t\tfprintf(lock_output, \"%10d: %s\\n\", st->tid, thread__comm_str(t));\n\t\tnode = rb_next(node);\n\t\tthread__put(t);\n\t}\n}\n\nstatic int compare_maps(struct lock_stat *a, struct lock_stat *b)\n{\n\tint ret;\n\n\tif (a->name && b->name)\n\t\tret = strcmp(a->name, b->name);\n\telse\n\t\tret = !!a->name - !!b->name;\n\n\tif (!ret)\n\t\treturn a->addr < b->addr;\n\telse\n\t\treturn ret < 0;\n}\n\nstatic void dump_map(void)\n{\n\tunsigned int i;\n\tstruct lock_stat *st;\n\n\tfprintf(lock_output, \"Address of instance: name of class\\n\");\n\tfor (i = 0; i < LOCKHASH_SIZE; i++) {\n\t\thlist_for_each_entry(st, &lockhash_table[i], hash_entry) {\n\t\t\tinsert_to_result(st, compare_maps);\n\t\t}\n\t}\n\n\twhile ((st = pop_from_result()))\n\t\tfprintf(lock_output, \" %#llx: %s\\n\", (unsigned long long)st->addr, st->name);\n}\n\nstatic int dump_info(void)\n{\n\tint rc = 0;\n\n\tif (info_threads)\n\t\tdump_threads();\n\telse if (info_map)\n\t\tdump_map();\n\telse {\n\t\trc = -1;\n\t\tpr_err(\"Unknown type of information\\n\");\n\t}\n\n\treturn rc;\n}\n\nstatic const struct evsel_str_handler lock_tracepoints[] = {\n\t{ \"lock:lock_acquire\",\t evsel__process_lock_acquire,   },  \n\t{ \"lock:lock_acquired\",\t evsel__process_lock_acquired,  },  \n\t{ \"lock:lock_contended\", evsel__process_lock_contended, },  \n\t{ \"lock:lock_release\",\t evsel__process_lock_release,   },  \n};\n\nstatic const struct evsel_str_handler contention_tracepoints[] = {\n\t{ \"lock:contention_begin\", evsel__process_contention_begin, },\n\t{ \"lock:contention_end\",   evsel__process_contention_end,   },\n};\n\nstatic int process_event_update(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct evlist **pevlist)\n{\n\tint ret;\n\n\tret = perf_event__process_event_update(tool, event, pevlist);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tperf_session__set_tracepoints_handlers(session, lock_tracepoints);\n\tperf_session__set_tracepoints_handlers(session, contention_tracepoints);\n\treturn 0;\n}\n\ntypedef int (*tracepoint_handler)(struct evsel *evsel,\n\t\t\t\t  struct perf_sample *sample);\n\nstatic int process_sample_event(struct perf_tool *tool __maybe_unused,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct machine *machine)\n{\n\tint err = 0;\n\tstruct thread *thread = machine__findnew_thread(machine, sample->pid,\n\t\t\t\t\t\t\tsample->tid);\n\n\tif (thread == NULL) {\n\t\tpr_debug(\"problem processing %d event, skipping it.\\n\",\n\t\t\tevent->header.type);\n\t\treturn -1;\n\t}\n\n\tif (evsel->handler != NULL) {\n\t\ttracepoint_handler f = evsel->handler;\n\t\terr = f(evsel, sample);\n\t}\n\n\tthread__put(thread);\n\n\treturn err;\n}\n\nstatic void combine_result(void)\n{\n\tunsigned int i;\n\tstruct lock_stat *st;\n\n\tif (!combine_locks)\n\t\treturn;\n\n\tfor (i = 0; i < LOCKHASH_SIZE; i++) {\n\t\thlist_for_each_entry(st, &lockhash_table[i], hash_entry) {\n\t\t\tcombine_lock_stats(st);\n\t\t}\n\t}\n}\n\nstatic void sort_result(void)\n{\n\tunsigned int i;\n\tstruct lock_stat *st;\n\n\tfor (i = 0; i < LOCKHASH_SIZE; i++) {\n\t\thlist_for_each_entry(st, &lockhash_table[i], hash_entry) {\n\t\t\tinsert_to_result(st, compare);\n\t\t}\n\t}\n}\n\nstatic const struct {\n\tunsigned int flags;\n\tconst char *str;\n\tconst char *name;\n} lock_type_table[] = {\n\t{ 0,\t\t\t\t\"semaphore\",\t\"semaphore\" },\n\t{ LCB_F_SPIN,\t\t\t\"spinlock\",\t\"spinlock\" },\n\t{ LCB_F_SPIN | LCB_F_READ,\t\"rwlock:R\",\t\"rwlock\" },\n\t{ LCB_F_SPIN | LCB_F_WRITE,\t\"rwlock:W\",\t\"rwlock\" },\n\t{ LCB_F_READ,\t\t\t\"rwsem:R\",\t\"rwsem\" },\n\t{ LCB_F_WRITE,\t\t\t\"rwsem:W\",\t\"rwsem\" },\n\t{ LCB_F_RT,\t\t\t\"rt-mutex\",\t\"rt-mutex\" },\n\t{ LCB_F_RT | LCB_F_READ,\t\"rwlock-rt:R\",\t\"rwlock-rt\" },\n\t{ LCB_F_RT | LCB_F_WRITE,\t\"rwlock-rt:W\",\t\"rwlock-rt\" },\n\t{ LCB_F_PERCPU | LCB_F_READ,\t\"pcpu-sem:R\",\t\"percpu-rwsem\" },\n\t{ LCB_F_PERCPU | LCB_F_WRITE,\t\"pcpu-sem:W\",\t\"percpu-rwsem\" },\n\t{ LCB_F_MUTEX,\t\t\t\"mutex\",\t\"mutex\" },\n\t{ LCB_F_MUTEX | LCB_F_SPIN,\t\"mutex\",\t\"mutex\" },\n\t \n\t{ LCB_F_MUTEX | LCB_F_SPIN,\t\"mutex-spin\",\t\"mutex\" },\n};\n\nstatic const char *get_type_str(unsigned int flags)\n{\n\tflags &= LCB_F_MAX_FLAGS - 1;\n\n\tfor (unsigned int i = 0; i < ARRAY_SIZE(lock_type_table); i++) {\n\t\tif (lock_type_table[i].flags == flags)\n\t\t\treturn lock_type_table[i].str;\n\t}\n\treturn \"unknown\";\n}\n\nstatic const char *get_type_name(unsigned int flags)\n{\n\tflags &= LCB_F_MAX_FLAGS - 1;\n\n\tfor (unsigned int i = 0; i < ARRAY_SIZE(lock_type_table); i++) {\n\t\tif (lock_type_table[i].flags == flags)\n\t\t\treturn lock_type_table[i].name;\n\t}\n\treturn \"unknown\";\n}\n\nstatic unsigned int get_type_flag(const char *str)\n{\n\tfor (unsigned int i = 0; i < ARRAY_SIZE(lock_type_table); i++) {\n\t\tif (!strcmp(lock_type_table[i].name, str))\n\t\t\treturn lock_type_table[i].flags;\n\t}\n\tfor (unsigned int i = 0; i < ARRAY_SIZE(lock_type_table); i++) {\n\t\tif (!strcmp(lock_type_table[i].str, str))\n\t\t\treturn lock_type_table[i].flags;\n\t}\n\treturn UINT_MAX;\n}\n\nstatic void lock_filter_finish(void)\n{\n\tzfree(&filters.types);\n\tfilters.nr_types = 0;\n\n\tzfree(&filters.addrs);\n\tfilters.nr_addrs = 0;\n\n\tfor (int i = 0; i < filters.nr_syms; i++)\n\t\tfree(filters.syms[i]);\n\n\tzfree(&filters.syms);\n\tfilters.nr_syms = 0;\n}\n\nstatic void sort_contention_result(void)\n{\n\tsort_result();\n}\n\nstatic void print_header_stdio(void)\n{\n\tstruct lock_key *key;\n\n\tlist_for_each_entry(key, &lock_keys, list)\n\t\tfprintf(lock_output, \"%*s \", key->len, key->header);\n\n\tswitch (aggr_mode) {\n\tcase LOCK_AGGR_TASK:\n\t\tfprintf(lock_output, \"  %10s   %s\\n\\n\", \"pid\",\n\t\t\tshow_lock_owner ? \"owner\" : \"comm\");\n\t\tbreak;\n\tcase LOCK_AGGR_CALLER:\n\t\tfprintf(lock_output, \"  %10s   %s\\n\\n\", \"type\", \"caller\");\n\t\tbreak;\n\tcase LOCK_AGGR_ADDR:\n\t\tfprintf(lock_output, \"  %16s   %s\\n\\n\", \"address\", \"symbol\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void print_header_csv(const char *sep)\n{\n\tstruct lock_key *key;\n\n\tfprintf(lock_output, \"# output: \");\n\tlist_for_each_entry(key, &lock_keys, list)\n\t\tfprintf(lock_output, \"%s%s \", key->header, sep);\n\n\tswitch (aggr_mode) {\n\tcase LOCK_AGGR_TASK:\n\t\tfprintf(lock_output, \"%s%s %s\\n\", \"pid\", sep,\n\t\t\tshow_lock_owner ? \"owner\" : \"comm\");\n\t\tbreak;\n\tcase LOCK_AGGR_CALLER:\n\t\tfprintf(lock_output, \"%s%s %s\", \"type\", sep, \"caller\");\n\t\tif (verbose > 0)\n\t\t\tfprintf(lock_output, \"%s %s\", sep, \"stacktrace\");\n\t\tfprintf(lock_output, \"\\n\");\n\t\tbreak;\n\tcase LOCK_AGGR_ADDR:\n\t\tfprintf(lock_output, \"%s%s %s%s %s\\n\", \"address\", sep, \"symbol\", sep, \"type\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void print_header(void)\n{\n\tif (!quiet) {\n\t\tif (symbol_conf.field_sep)\n\t\t\tprint_header_csv(symbol_conf.field_sep);\n\t\telse\n\t\t\tprint_header_stdio();\n\t}\n}\n\nstatic void print_lock_stat_stdio(struct lock_contention *con, struct lock_stat *st)\n{\n\tstruct lock_key *key;\n\tstruct thread *t;\n\tint pid;\n\n\tlist_for_each_entry(key, &lock_keys, list) {\n\t\tkey->print(key, st);\n\t\tfprintf(lock_output, \" \");\n\t}\n\n\tswitch (aggr_mode) {\n\tcase LOCK_AGGR_CALLER:\n\t\tfprintf(lock_output, \"  %10s   %s\\n\", get_type_str(st->flags), st->name);\n\t\tbreak;\n\tcase LOCK_AGGR_TASK:\n\t\tpid = st->addr;\n\t\tt = perf_session__findnew(session, pid);\n\t\tfprintf(lock_output, \"  %10d   %s\\n\",\n\t\t\tpid, pid == -1 ? \"Unknown\" : thread__comm_str(t));\n\t\tbreak;\n\tcase LOCK_AGGR_ADDR:\n\t\tfprintf(lock_output, \"  %016llx   %s (%s)\\n\", (unsigned long long)st->addr,\n\t\t\tst->name, get_type_name(st->flags));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (aggr_mode == LOCK_AGGR_CALLER && verbose > 0) {\n\t\tstruct map *kmap;\n\t\tstruct symbol *sym;\n\t\tchar buf[128];\n\t\tu64 ip;\n\n\t\tfor (int i = 0; i < max_stack_depth; i++) {\n\t\t\tif (!st->callstack || !st->callstack[i])\n\t\t\t\tbreak;\n\n\t\t\tip = st->callstack[i];\n\t\t\tsym = machine__find_kernel_symbol(con->machine, ip, &kmap);\n\t\t\tget_symbol_name_offset(kmap, sym, ip, buf, sizeof(buf));\n\t\t\tfprintf(lock_output, \"\\t\\t\\t%#lx  %s\\n\", (unsigned long)ip, buf);\n\t\t}\n\t}\n}\n\nstatic void print_lock_stat_csv(struct lock_contention *con, struct lock_stat *st,\n\t\t\t\tconst char *sep)\n{\n\tstruct lock_key *key;\n\tstruct thread *t;\n\tint pid;\n\n\tlist_for_each_entry(key, &lock_keys, list) {\n\t\tkey->print(key, st);\n\t\tfprintf(lock_output, \"%s \", sep);\n\t}\n\n\tswitch (aggr_mode) {\n\tcase LOCK_AGGR_CALLER:\n\t\tfprintf(lock_output, \"%s%s %s\", get_type_str(st->flags), sep, st->name);\n\t\tif (verbose <= 0)\n\t\t\tfprintf(lock_output, \"\\n\");\n\t\tbreak;\n\tcase LOCK_AGGR_TASK:\n\t\tpid = st->addr;\n\t\tt = perf_session__findnew(session, pid);\n\t\tfprintf(lock_output, \"%d%s %s\\n\", pid, sep,\n\t\t\tpid == -1 ? \"Unknown\" : thread__comm_str(t));\n\t\tbreak;\n\tcase LOCK_AGGR_ADDR:\n\t\tfprintf(lock_output, \"%llx%s %s%s %s\\n\", (unsigned long long)st->addr, sep,\n\t\t\tst->name, sep, get_type_name(st->flags));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (aggr_mode == LOCK_AGGR_CALLER && verbose > 0) {\n\t\tstruct map *kmap;\n\t\tstruct symbol *sym;\n\t\tchar buf[128];\n\t\tu64 ip;\n\n\t\tfor (int i = 0; i < max_stack_depth; i++) {\n\t\t\tif (!st->callstack || !st->callstack[i])\n\t\t\t\tbreak;\n\n\t\t\tip = st->callstack[i];\n\t\t\tsym = machine__find_kernel_symbol(con->machine, ip, &kmap);\n\t\t\tget_symbol_name_offset(kmap, sym, ip, buf, sizeof(buf));\n\t\t\tfprintf(lock_output, \"%s %#lx %s\", i ? \":\" : sep, (unsigned long) ip, buf);\n\t\t}\n\t\tfprintf(lock_output, \"\\n\");\n\t}\n}\n\nstatic void print_lock_stat(struct lock_contention *con, struct lock_stat *st)\n{\n\tif (symbol_conf.field_sep)\n\t\tprint_lock_stat_csv(con, st, symbol_conf.field_sep);\n\telse\n\t\tprint_lock_stat_stdio(con, st);\n}\n\nstatic void print_footer_stdio(int total, int bad, struct lock_contention_fails *fails)\n{\n\t \n\tint broken = fails->task + fails->stack + fails->time + fails->data;\n\n\tif (!use_bpf)\n\t\tprint_bad_events(bad, total);\n\n\tif (quiet || total == 0 || (broken == 0 && verbose <= 0))\n\t\treturn;\n\n\ttotal += broken;\n\tfprintf(lock_output, \"\\n=== output for debug ===\\n\\n\");\n\tfprintf(lock_output, \"bad: %d, total: %d\\n\", broken, total);\n\tfprintf(lock_output, \"bad rate: %.2f %%\\n\", 100.0 * broken / total);\n\n\tfprintf(lock_output, \"histogram of failure reasons\\n\");\n\tfprintf(lock_output, \" %10s: %d\\n\", \"task\", fails->task);\n\tfprintf(lock_output, \" %10s: %d\\n\", \"stack\", fails->stack);\n\tfprintf(lock_output, \" %10s: %d\\n\", \"time\", fails->time);\n\tfprintf(lock_output, \" %10s: %d\\n\", \"data\", fails->data);\n}\n\nstatic void print_footer_csv(int total, int bad, struct lock_contention_fails *fails,\n\t\t\t     const char *sep)\n{\n\t \n\tif (use_bpf)\n\t\tbad = fails->task + fails->stack + fails->time + fails->data;\n\n\tif (quiet || total == 0 || (bad == 0 && verbose <= 0))\n\t\treturn;\n\n\ttotal += bad;\n\tfprintf(lock_output, \"# debug: total=%d%s bad=%d\", total, sep, bad);\n\n\tif (use_bpf) {\n\t\tfprintf(lock_output, \"%s bad_%s=%d\", sep, \"task\", fails->task);\n\t\tfprintf(lock_output, \"%s bad_%s=%d\", sep, \"stack\", fails->stack);\n\t\tfprintf(lock_output, \"%s bad_%s=%d\", sep, \"time\", fails->time);\n\t\tfprintf(lock_output, \"%s bad_%s=%d\", sep, \"data\", fails->data);\n\t} else {\n\t\tint i;\n\t\tconst char *name[4] = { \"acquire\", \"acquired\", \"contended\", \"release\" };\n\n\t\tfor (i = 0; i < BROKEN_MAX; i++)\n\t\t\tfprintf(lock_output, \"%s bad_%s=%d\", sep, name[i], bad_hist[i]);\n\t}\n\tfprintf(lock_output, \"\\n\");\n}\n\nstatic void print_footer(int total, int bad, struct lock_contention_fails *fails)\n{\n\tif (symbol_conf.field_sep)\n\t\tprint_footer_csv(total, bad, fails, symbol_conf.field_sep);\n\telse\n\t\tprint_footer_stdio(total, bad, fails);\n}\n\nstatic void print_contention_result(struct lock_contention *con)\n{\n\tstruct lock_stat *st;\n\tint bad, total, printed;\n\n\tif (!quiet)\n\t\tprint_header();\n\n\tbad = total = printed = 0;\n\n\twhile ((st = pop_from_result())) {\n\t\ttotal += use_bpf ? st->nr_contended : 1;\n\t\tif (st->broken)\n\t\t\tbad++;\n\n\t\tif (!st->wait_time_total)\n\t\t\tcontinue;\n\n\t\tprint_lock_stat(con, st);\n\n\t\tif (++printed >= print_nr_entries)\n\t\t\tbreak;\n\t}\n\n\tif (print_nr_entries) {\n\t\t \n\t\twhile ((st = pop_from_result())) {\n\t\t\ttotal += use_bpf ? st->nr_contended : 1;\n\t\t\tif (st->broken)\n\t\t\t\tbad++;\n\t\t}\n\t}\n\t \n\ttotal += con->nr_filtered;\n\n\tprint_footer(total, bad, &con->fails);\n}\n\nstatic bool force;\n\nstatic int __cmd_report(bool display_info)\n{\n\tint err = -EINVAL;\n\tstruct perf_tool eops = {\n\t\t.attr\t\t = perf_event__process_attr,\n\t\t.event_update\t = process_event_update,\n\t\t.sample\t\t = process_sample_event,\n\t\t.comm\t\t = perf_event__process_comm,\n\t\t.mmap\t\t = perf_event__process_mmap,\n\t\t.namespaces\t = perf_event__process_namespaces,\n\t\t.tracing_data\t = perf_event__process_tracing_data,\n\t\t.ordered_events\t = true,\n\t};\n\tstruct perf_data data = {\n\t\t.path  = input_name,\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t\t.force = force,\n\t};\n\n\tsession = perf_session__new(&data, &eops);\n\tif (IS_ERR(session)) {\n\t\tpr_err(\"Initializing perf session failed\\n\");\n\t\treturn PTR_ERR(session);\n\t}\n\n\tsymbol_conf.allow_aliases = true;\n\tsymbol__init(&session->header.env);\n\n\tif (!data.is_pipe) {\n\t\tif (!perf_session__has_traces(session, \"lock record\"))\n\t\t\tgoto out_delete;\n\n\t\tif (perf_session__set_tracepoints_handlers(session, lock_tracepoints)) {\n\t\t\tpr_err(\"Initializing perf session tracepoint handlers failed\\n\");\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\tif (perf_session__set_tracepoints_handlers(session, contention_tracepoints)) {\n\t\t\tpr_err(\"Initializing perf session tracepoint handlers failed\\n\");\n\t\t\tgoto out_delete;\n\t\t}\n\t}\n\n\tif (setup_output_field(false, output_fields))\n\t\tgoto out_delete;\n\n\tif (select_key(false))\n\t\tgoto out_delete;\n\n\tif (show_thread_stats)\n\t\taggr_mode = LOCK_AGGR_TASK;\n\n\terr = perf_session__process_events(session);\n\tif (err)\n\t\tgoto out_delete;\n\n\tsetup_pager();\n\tif (display_info)  \n\t\terr = dump_info();\n\telse {\n\t\tcombine_result();\n\t\tsort_result();\n\t\tprint_result();\n\t}\n\nout_delete:\n\tperf_session__delete(session);\n\treturn err;\n}\n\nstatic void sighandler(int sig __maybe_unused)\n{\n}\n\nstatic int check_lock_contention_options(const struct option *options,\n\t\t\t\t\t const char * const *usage)\n\n{\n\tif (show_thread_stats && show_lock_addrs) {\n\t\tpr_err(\"Cannot use thread and addr mode together\\n\");\n\t\tparse_options_usage(usage, options, \"threads\", 0);\n\t\tparse_options_usage(NULL, options, \"lock-addr\", 0);\n\t\treturn -1;\n\t}\n\n\tif (show_lock_owner && !use_bpf) {\n\t\tpr_err(\"Lock owners are available only with BPF\\n\");\n\t\tparse_options_usage(usage, options, \"lock-owner\", 0);\n\t\tparse_options_usage(NULL, options, \"use-bpf\", 0);\n\t\treturn -1;\n\t}\n\n\tif (show_lock_owner && show_lock_addrs) {\n\t\tpr_err(\"Cannot use owner and addr mode together\\n\");\n\t\tparse_options_usage(usage, options, \"lock-owner\", 0);\n\t\tparse_options_usage(NULL, options, \"lock-addr\", 0);\n\t\treturn -1;\n\t}\n\n\tif (symbol_conf.field_sep) {\n\t\tif (strstr(symbol_conf.field_sep, \":\") ||  \n\t\t    strstr(symbol_conf.field_sep, \"+\") ||  \n\t\t    strstr(symbol_conf.field_sep, \".\")) {  \n\t\t\tpr_err(\"Cannot use the separator that is already used\\n\");\n\t\t\tparse_options_usage(usage, options, \"x\", 1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (show_lock_owner)\n\t\tshow_thread_stats = true;\n\n\treturn 0;\n}\n\nstatic int __cmd_contention(int argc, const char **argv)\n{\n\tint err = -EINVAL;\n\tstruct perf_tool eops = {\n\t\t.attr\t\t = perf_event__process_attr,\n\t\t.event_update\t = process_event_update,\n\t\t.sample\t\t = process_sample_event,\n\t\t.comm\t\t = perf_event__process_comm,\n\t\t.mmap\t\t = perf_event__process_mmap,\n\t\t.tracing_data\t = perf_event__process_tracing_data,\n\t\t.ordered_events\t = true,\n\t};\n\tstruct perf_data data = {\n\t\t.path  = input_name,\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t\t.force = force,\n\t};\n\tstruct lock_contention con = {\n\t\t.target = &target,\n\t\t.map_nr_entries = bpf_map_entries,\n\t\t.max_stack = max_stack_depth,\n\t\t.stack_skip = stack_skip,\n\t\t.filters = &filters,\n\t\t.save_callstack = needs_callstack(),\n\t\t.owner = show_lock_owner,\n\t};\n\n\tlockhash_table = calloc(LOCKHASH_SIZE, sizeof(*lockhash_table));\n\tif (!lockhash_table)\n\t\treturn -ENOMEM;\n\n\tcon.result = &lockhash_table[0];\n\n\tsession = perf_session__new(use_bpf ? NULL : &data, &eops);\n\tif (IS_ERR(session)) {\n\t\tpr_err(\"Initializing perf session failed\\n\");\n\t\terr = PTR_ERR(session);\n\t\tsession = NULL;\n\t\tgoto out_delete;\n\t}\n\n\tcon.machine = &session->machines.host;\n\n\tcon.aggr_mode = aggr_mode = show_thread_stats ? LOCK_AGGR_TASK :\n\t\tshow_lock_addrs ? LOCK_AGGR_ADDR : LOCK_AGGR_CALLER;\n\n\tif (con.aggr_mode == LOCK_AGGR_CALLER)\n\t\tcon.save_callstack = true;\n\n\tsymbol_conf.allow_aliases = true;\n\tsymbol__init(&session->header.env);\n\n\tif (use_bpf) {\n\t\terr = target__validate(&target);\n\t\tif (err) {\n\t\t\tchar errbuf[512];\n\n\t\t\ttarget__strerror(&target, err, errbuf, 512);\n\t\t\tpr_err(\"%s\\n\", errbuf);\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\tsignal(SIGINT, sighandler);\n\t\tsignal(SIGCHLD, sighandler);\n\t\tsignal(SIGTERM, sighandler);\n\n\t\tcon.evlist = evlist__new();\n\t\tif (con.evlist == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\terr = evlist__create_maps(con.evlist, &target);\n\t\tif (err < 0)\n\t\t\tgoto out_delete;\n\n\t\tif (argc) {\n\t\t\terr = evlist__prepare_workload(con.evlist, &target,\n\t\t\t\t\t\t       argv, false, NULL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_delete;\n\t\t}\n\n\t\tif (lock_contention_prepare(&con) < 0) {\n\t\t\tpr_err(\"lock contention BPF setup failed\\n\");\n\t\t\tgoto out_delete;\n\t\t}\n\t} else if (!data.is_pipe) {\n\t\tif (!perf_session__has_traces(session, \"lock record\"))\n\t\t\tgoto out_delete;\n\n\t\tif (!evlist__find_evsel_by_str(session->evlist,\n\t\t\t\t\t       \"lock:contention_begin\")) {\n\t\t\tpr_err(\"lock contention evsel not found\\n\");\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\tif (perf_session__set_tracepoints_handlers(session,\n\t\t\t\t\t\tcontention_tracepoints)) {\n\t\t\tpr_err(\"Initializing perf session tracepoint handlers failed\\n\");\n\t\t\tgoto out_delete;\n\t\t}\n\t}\n\n\tif (setup_output_field(true, output_fields))\n\t\tgoto out_delete;\n\n\tif (select_key(true))\n\t\tgoto out_delete;\n\n\tif (symbol_conf.field_sep) {\n\t\tint i;\n\t\tstruct lock_key *keys = contention_keys;\n\n\t\t \n\t\tfor (i = 0; keys[i].name; i++)\n\t\t\tkeys[i].len = 0;\n\t}\n\n\tif (use_bpf) {\n\t\tlock_contention_start();\n\t\tif (argc)\n\t\t\tevlist__start_workload(con.evlist);\n\n\t\t \n\t\tpause();\n\n\t\tlock_contention_stop();\n\t\tlock_contention_read(&con);\n\t} else {\n\t\terr = perf_session__process_events(session);\n\t\tif (err)\n\t\t\tgoto out_delete;\n\t}\n\n\tsetup_pager();\n\n\tsort_contention_result();\n\tprint_contention_result(&con);\n\nout_delete:\n\tlock_filter_finish();\n\tevlist__delete(con.evlist);\n\tlock_contention_finish();\n\tperf_session__delete(session);\n\tzfree(&lockhash_table);\n\treturn err;\n}\n\n\nstatic int __cmd_record(int argc, const char **argv)\n{\n\tconst char *record_args[] = {\n\t\t\"record\", \"-R\", \"-m\", \"1024\", \"-c\", \"1\", \"--synth\", \"task\",\n\t};\n\tconst char *callgraph_args[] = {\n\t\t\"--call-graph\", \"fp,\" __stringify(CONTENTION_STACK_DEPTH),\n\t};\n\tunsigned int rec_argc, i, j, ret;\n\tunsigned int nr_tracepoints;\n\tunsigned int nr_callgraph_args = 0;\n\tconst char **rec_argv;\n\tbool has_lock_stat = true;\n\n\tfor (i = 0; i < ARRAY_SIZE(lock_tracepoints); i++) {\n\t\tif (!is_valid_tracepoint(lock_tracepoints[i].name)) {\n\t\t\tpr_debug(\"tracepoint %s is not enabled. \"\n\t\t\t\t \"Are CONFIG_LOCKDEP and CONFIG_LOCK_STAT enabled?\\n\",\n\t\t\t\t lock_tracepoints[i].name);\n\t\t\thas_lock_stat = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_lock_stat)\n\t\tgoto setup_args;\n\n\tfor (i = 0; i < ARRAY_SIZE(contention_tracepoints); i++) {\n\t\tif (!is_valid_tracepoint(contention_tracepoints[i].name)) {\n\t\t\tpr_err(\"tracepoint %s is not enabled.\\n\",\n\t\t\t       contention_tracepoints[i].name);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tnr_callgraph_args = ARRAY_SIZE(callgraph_args);\n\nsetup_args:\n\trec_argc = ARRAY_SIZE(record_args) + nr_callgraph_args + argc - 1;\n\n\tif (has_lock_stat)\n\t\tnr_tracepoints = ARRAY_SIZE(lock_tracepoints);\n\telse\n\t\tnr_tracepoints = ARRAY_SIZE(contention_tracepoints);\n\n\t \n\trec_argc += 2 * nr_tracepoints;\n\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\tif (!rec_argv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(record_args); i++)\n\t\trec_argv[i] = strdup(record_args[i]);\n\n\tfor (j = 0; j < nr_tracepoints; j++) {\n\t\tconst char *ev_name;\n\n\t\tif (has_lock_stat)\n\t\t\tev_name = strdup(lock_tracepoints[j].name);\n\t\telse\n\t\t\tev_name = strdup(contention_tracepoints[j].name);\n\n\t\tif (!ev_name)\n\t\t\treturn -ENOMEM;\n\n\t\trec_argv[i++] = \"-e\";\n\t\trec_argv[i++] = ev_name;\n\t}\n\n\tfor (j = 0; j < nr_callgraph_args; j++, i++)\n\t\trec_argv[i] = callgraph_args[j];\n\n\tfor (j = 1; j < (unsigned int)argc; j++, i++)\n\t\trec_argv[i] = argv[j];\n\n\tBUG_ON(i != rec_argc);\n\n\tret = cmd_record(i, rec_argv);\n\tfree(rec_argv);\n\treturn ret;\n}\n\nstatic int parse_map_entry(const struct option *opt, const char *str,\n\t\t\t    int unset __maybe_unused)\n{\n\tunsigned long *len = (unsigned long *)opt->value;\n\tunsigned long val;\n\tchar *endptr;\n\n\terrno = 0;\n\tval = strtoul(str, &endptr, 0);\n\tif (*endptr != '\\0' || errno != 0) {\n\t\tpr_err(\"invalid BPF map length: %s\\n\", str);\n\t\treturn -1;\n\t}\n\n\t*len = val;\n\treturn 0;\n}\n\nstatic int parse_max_stack(const struct option *opt, const char *str,\n\t\t\t   int unset __maybe_unused)\n{\n\tunsigned long *len = (unsigned long *)opt->value;\n\tlong val;\n\tchar *endptr;\n\n\terrno = 0;\n\tval = strtol(str, &endptr, 0);\n\tif (*endptr != '\\0' || errno != 0) {\n\t\tpr_err(\"invalid max stack depth: %s\\n\", str);\n\t\treturn -1;\n\t}\n\n\tif (val < 0 || val > sysctl__max_stack()) {\n\t\tpr_err(\"invalid max stack depth: %ld\\n\", val);\n\t\treturn -1;\n\t}\n\n\t*len = val;\n\treturn 0;\n}\n\nstatic bool add_lock_type(unsigned int flags)\n{\n\tunsigned int *tmp;\n\n\ttmp = realloc(filters.types, (filters.nr_types + 1) * sizeof(*filters.types));\n\tif (tmp == NULL)\n\t\treturn false;\n\n\ttmp[filters.nr_types++] = flags;\n\tfilters.types = tmp;\n\treturn true;\n}\n\nstatic int parse_lock_type(const struct option *opt __maybe_unused, const char *str,\n\t\t\t   int unset __maybe_unused)\n{\n\tchar *s, *tmp, *tok;\n\tint ret = 0;\n\n\ts = strdup(str);\n\tif (s == NULL)\n\t\treturn -1;\n\n\tfor (tok = strtok_r(s, \", \", &tmp); tok; tok = strtok_r(NULL, \", \", &tmp)) {\n\t\tunsigned int flags = get_type_flag(tok);\n\n\t\tif (flags == -1U) {\n\t\t\tpr_err(\"Unknown lock flags: %s\\n\", tok);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!add_lock_type(flags)) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(s);\n\treturn ret;\n}\n\nstatic bool add_lock_addr(unsigned long addr)\n{\n\tunsigned long *tmp;\n\n\ttmp = realloc(filters.addrs, (filters.nr_addrs + 1) * sizeof(*filters.addrs));\n\tif (tmp == NULL) {\n\t\tpr_err(\"Memory allocation failure\\n\");\n\t\treturn false;\n\t}\n\n\ttmp[filters.nr_addrs++] = addr;\n\tfilters.addrs = tmp;\n\treturn true;\n}\n\nstatic bool add_lock_sym(char *name)\n{\n\tchar **tmp;\n\tchar *sym = strdup(name);\n\n\tif (sym == NULL) {\n\t\tpr_err(\"Memory allocation failure\\n\");\n\t\treturn false;\n\t}\n\n\ttmp = realloc(filters.syms, (filters.nr_syms + 1) * sizeof(*filters.syms));\n\tif (tmp == NULL) {\n\t\tpr_err(\"Memory allocation failure\\n\");\n\t\tfree(sym);\n\t\treturn false;\n\t}\n\n\ttmp[filters.nr_syms++] = sym;\n\tfilters.syms = tmp;\n\treturn true;\n}\n\nstatic int parse_lock_addr(const struct option *opt __maybe_unused, const char *str,\n\t\t\t   int unset __maybe_unused)\n{\n\tchar *s, *tmp, *tok;\n\tint ret = 0;\n\tu64 addr;\n\n\ts = strdup(str);\n\tif (s == NULL)\n\t\treturn -1;\n\n\tfor (tok = strtok_r(s, \", \", &tmp); tok; tok = strtok_r(NULL, \", \", &tmp)) {\n\t\tchar *end;\n\n\t\taddr = strtoul(tok, &end, 16);\n\t\tif (*end == '\\0') {\n\t\t\tif (!add_lock_addr(addr)) {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!add_lock_sym(tok)) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(s);\n\treturn ret;\n}\n\nstatic int parse_call_stack(const struct option *opt __maybe_unused, const char *str,\n\t\t\t   int unset __maybe_unused)\n{\n\tchar *s, *tmp, *tok;\n\tint ret = 0;\n\n\ts = strdup(str);\n\tif (s == NULL)\n\t\treturn -1;\n\n\tfor (tok = strtok_r(s, \", \", &tmp); tok; tok = strtok_r(NULL, \", \", &tmp)) {\n\t\tstruct callstack_filter *entry;\n\n\t\tentry = malloc(sizeof(*entry) + strlen(tok) + 1);\n\t\tif (entry == NULL) {\n\t\t\tpr_err(\"Memory allocation failure\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tstrcpy(entry->name, tok);\n\t\tlist_add_tail(&entry->list, &callstack_filters);\n\t}\n\n\tfree(s);\n\treturn ret;\n}\n\nstatic int parse_output(const struct option *opt __maybe_unused, const char *str,\n\t\t\tint unset __maybe_unused)\n{\n\tconst char **name = (const char **)opt->value;\n\n\tif (str == NULL)\n\t\treturn -1;\n\n\tlock_output = fopen(str, \"w\");\n\tif (lock_output == NULL) {\n\t\tpr_err(\"Cannot open %s\\n\", str);\n\t\treturn -1;\n\t}\n\n\t*name = str;\n\treturn 0;\n}\n\nint cmd_lock(int argc, const char **argv)\n{\n\tconst struct option lock_options[] = {\n\tOPT_STRING('i', \"input\", &input_name, \"file\", \"input file name\"),\n\tOPT_CALLBACK(0, \"output\", &output_name, \"file\", \"output file name\", parse_output),\n\tOPT_INCR('v', \"verbose\", &verbose, \"be more verbose (show symbol address, etc)\"),\n\tOPT_BOOLEAN('D', \"dump-raw-trace\", &dump_trace, \"dump raw trace in ASCII\"),\n\tOPT_BOOLEAN('f', \"force\", &force, \"don't complain, do it\"),\n\tOPT_STRING(0, \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_STRING(0, \"kallsyms\", &symbol_conf.kallsyms_name,\n\t\t   \"file\", \"kallsyms pathname\"),\n\tOPT_BOOLEAN('q', \"quiet\", &quiet, \"Do not show any warnings or messages\"),\n\tOPT_END()\n\t};\n\n\tconst struct option info_options[] = {\n\tOPT_BOOLEAN('t', \"threads\", &info_threads,\n\t\t    \"dump thread list in perf.data\"),\n\tOPT_BOOLEAN('m', \"map\", &info_map,\n\t\t    \"map of lock instances (address:name table)\"),\n\tOPT_PARENT(lock_options)\n\t};\n\n\tconst struct option report_options[] = {\n\tOPT_STRING('k', \"key\", &sort_key, \"acquired\",\n\t\t    \"key for sorting (acquired / contended / avg_wait / wait_total / wait_max / wait_min)\"),\n\tOPT_STRING('F', \"field\", &output_fields, NULL,\n\t\t    \"output fields (acquired / contended / avg_wait / wait_total / wait_max / wait_min)\"),\n\t \n\tOPT_BOOLEAN('c', \"combine-locks\", &combine_locks,\n\t\t    \"combine locks in the same class\"),\n\tOPT_BOOLEAN('t', \"threads\", &show_thread_stats,\n\t\t    \"show per-thread lock stats\"),\n\tOPT_INTEGER('E', \"entries\", &print_nr_entries, \"display this many functions\"),\n\tOPT_PARENT(lock_options)\n\t};\n\n\tstruct option contention_options[] = {\n\tOPT_STRING('k', \"key\", &sort_key, \"wait_total\",\n\t\t    \"key for sorting (contended / wait_total / wait_max / wait_min / avg_wait)\"),\n\tOPT_STRING('F', \"field\", &output_fields, \"contended,wait_total,wait_max,avg_wait\",\n\t\t    \"output fields (contended / wait_total / wait_max / wait_min / avg_wait)\"),\n\tOPT_BOOLEAN('t', \"threads\", &show_thread_stats,\n\t\t    \"show per-thread lock stats\"),\n\tOPT_BOOLEAN('b', \"use-bpf\", &use_bpf, \"use BPF program to collect lock contention stats\"),\n\tOPT_BOOLEAN('a', \"all-cpus\", &target.system_wide,\n\t\t    \"System-wide collection from all CPUs\"),\n\tOPT_STRING('C', \"cpu\", &target.cpu_list, \"cpu\",\n\t\t    \"List of cpus to monitor\"),\n\tOPT_STRING('p', \"pid\", &target.pid, \"pid\",\n\t\t   \"Trace on existing process id\"),\n\tOPT_STRING(0, \"tid\", &target.tid, \"tid\",\n\t\t   \"Trace on existing thread id (exclusive to --pid)\"),\n\tOPT_CALLBACK('M', \"map-nr-entries\", &bpf_map_entries, \"num\",\n\t\t     \"Max number of BPF map entries\", parse_map_entry),\n\tOPT_CALLBACK(0, \"max-stack\", &max_stack_depth, \"num\",\n\t\t     \"Set the maximum stack depth when collecting lock contention, \"\n\t\t     \"Default: \" __stringify(CONTENTION_STACK_DEPTH), parse_max_stack),\n\tOPT_INTEGER(0, \"stack-skip\", &stack_skip,\n\t\t    \"Set the number of stack depth to skip when finding a lock caller, \"\n\t\t    \"Default: \" __stringify(CONTENTION_STACK_SKIP)),\n\tOPT_INTEGER('E', \"entries\", &print_nr_entries, \"display this many functions\"),\n\tOPT_BOOLEAN('l', \"lock-addr\", &show_lock_addrs, \"show lock stats by address\"),\n\tOPT_CALLBACK('Y', \"type-filter\", NULL, \"FLAGS\",\n\t\t     \"Filter specific type of locks\", parse_lock_type),\n\tOPT_CALLBACK('L', \"lock-filter\", NULL, \"ADDRS/NAMES\",\n\t\t     \"Filter specific address/symbol of locks\", parse_lock_addr),\n\tOPT_CALLBACK('S', \"callstack-filter\", NULL, \"NAMES\",\n\t\t     \"Filter specific function in the callstack\", parse_call_stack),\n\tOPT_BOOLEAN('o', \"lock-owner\", &show_lock_owner, \"show lock owners instead of waiters\"),\n\tOPT_STRING_NOEMPTY('x', \"field-separator\", &symbol_conf.field_sep, \"separator\",\n\t\t   \"print result in CSV format with custom separator\"),\n\tOPT_PARENT(lock_options)\n\t};\n\n\tconst char * const info_usage[] = {\n\t\t\"perf lock info [<options>]\",\n\t\tNULL\n\t};\n\tconst char *const lock_subcommands[] = { \"record\", \"report\", \"script\",\n\t\t\t\t\t\t \"info\", \"contention\", NULL };\n\tconst char *lock_usage[] = {\n\t\tNULL,\n\t\tNULL\n\t};\n\tconst char * const report_usage[] = {\n\t\t\"perf lock report [<options>]\",\n\t\tNULL\n\t};\n\tconst char * const contention_usage[] = {\n\t\t\"perf lock contention [<options>]\",\n\t\tNULL\n\t};\n\tunsigned int i;\n\tint rc = 0;\n\n\tlockhash_table = calloc(LOCKHASH_SIZE, sizeof(*lockhash_table));\n\tif (!lockhash_table)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < LOCKHASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(lockhash_table + i);\n\n\tlock_output = stderr;\n\targc = parse_options_subcommand(argc, argv, lock_options, lock_subcommands,\n\t\t\t\t\tlock_usage, PARSE_OPT_STOP_AT_NON_OPTION);\n\tif (!argc)\n\t\tusage_with_options(lock_usage, lock_options);\n\n\tif (strlen(argv[0]) > 2 && strstarts(\"record\", argv[0])) {\n\t\treturn __cmd_record(argc, argv);\n\t} else if (strlen(argv[0]) > 2 && strstarts(\"report\", argv[0])) {\n\t\ttrace_handler = &report_lock_ops;\n\t\tif (argc) {\n\t\t\targc = parse_options(argc, argv,\n\t\t\t\t\t     report_options, report_usage, 0);\n\t\t\tif (argc)\n\t\t\t\tusage_with_options(report_usage, report_options);\n\t\t}\n\t\trc = __cmd_report(false);\n\t} else if (!strcmp(argv[0], \"script\")) {\n\t\t \n\t\trc = cmd_script(argc, argv);\n\t} else if (!strcmp(argv[0], \"info\")) {\n\t\tif (argc) {\n\t\t\targc = parse_options(argc, argv,\n\t\t\t\t\t     info_options, info_usage, 0);\n\t\t\tif (argc)\n\t\t\t\tusage_with_options(info_usage, info_options);\n\t\t}\n\t\t \n\t\ttrace_handler = &report_lock_ops;\n\t\trc = __cmd_report(true);\n\t} else if (strlen(argv[0]) > 2 && strstarts(\"contention\", argv[0])) {\n\t\ttrace_handler = &contention_lock_ops;\n\t\tsort_key = \"wait_total\";\n\t\toutput_fields = \"contended,wait_total,wait_max,avg_wait\";\n\n#ifndef HAVE_BPF_SKEL\n\t\tset_option_nobuild(contention_options, 'b', \"use-bpf\",\n\t\t\t\t   \"no BUILD_BPF_SKEL=1\", false);\n#endif\n\t\tif (argc) {\n\t\t\targc = parse_options(argc, argv, contention_options,\n\t\t\t\t\t     contention_usage, 0);\n\t\t}\n\n\t\tif (check_lock_contention_options(contention_options,\n\t\t\t\t\t\t  contention_usage) < 0)\n\t\t\treturn -1;\n\n\t\trc = __cmd_contention(argc, argv);\n\t} else {\n\t\tusage_with_options(lock_usage, lock_options);\n\t}\n\n\tzfree(&lockhash_table);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}