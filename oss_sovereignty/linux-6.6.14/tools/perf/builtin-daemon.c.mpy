{
  "module_name": "builtin-daemon.c",
  "hash_id": "bb6c2eb7ac1b423a7b904b678dac1aaaadf2e64de43440f914a2dc08dac595ff",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-daemon.c",
  "human_readable_source": "\n#include <internal/lib.h>\n#include <subcmd/parse-options.h>\n#include <api/fd/array.h>\n#include <api/fs/fs.h>\n#include <linux/zalloc.h>\n#include <linux/string.h>\n#include <linux/limits.h>\n#include <string.h>\n#include <sys/file.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <time.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/inotify.h>\n#include <libgen.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <sys/signalfd.h>\n#include <sys/wait.h>\n#include <poll.h>\n#include \"builtin.h\"\n#include \"perf.h\"\n#include \"debug.h\"\n#include \"config.h\"\n#include \"util.h\"\n\n#define SESSION_OUTPUT  \"output\"\n#define SESSION_CONTROL \"control\"\n#define SESSION_ACK     \"ack\"\n\n \nenum daemon_session_state {\n\tOK,\n\tRECONFIG,\n\tKILL,\n};\n\nstruct daemon_session {\n\tchar\t\t\t\t*base;\n\tchar\t\t\t\t*name;\n\tchar\t\t\t\t*run;\n\tchar\t\t\t\t*control;\n\tint\t\t\t\t pid;\n\tstruct list_head\t\t list;\n\tenum daemon_session_state\t state;\n\ttime_t\t\t\t\t start;\n};\n\nstruct daemon {\n\tconst char\t\t*config;\n\tchar\t\t\t*config_real;\n\tchar\t\t\t*config_base;\n\tconst char\t\t*csv_sep;\n\tconst char\t\t*base_user;\n\tchar\t\t\t*base;\n\tstruct list_head\t sessions;\n\tFILE\t\t\t*out;\n\tchar\t\t\t*perf;\n\tint\t\t\t signal_fd;\n\ttime_t\t\t\t start;\n};\n\nstatic struct daemon __daemon = {\n\t.sessions = LIST_HEAD_INIT(__daemon.sessions),\n};\n\nstatic const char * const daemon_usage[] = {\n\t\"perf daemon {start|signal|stop|ping} [<options>]\",\n\t\"perf daemon [<options>]\",\n\tNULL\n};\n\nstatic volatile sig_atomic_t done;\n\nstatic void sig_handler(int sig __maybe_unused)\n{\n\tdone = true;\n}\n\nstatic struct daemon_session *daemon__add_session(struct daemon *config, char *name)\n{\n\tstruct daemon_session *session = zalloc(sizeof(*session));\n\n\tif (!session)\n\t\treturn NULL;\n\n\tsession->name = strdup(name);\n\tif (!session->name) {\n\t\tfree(session);\n\t\treturn NULL;\n\t}\n\n\tsession->pid = -1;\n\tlist_add_tail(&session->list, &config->sessions);\n\treturn session;\n}\n\nstatic struct daemon_session *daemon__find_session(struct daemon *daemon, char *name)\n{\n\tstruct daemon_session *session;\n\n\tlist_for_each_entry(session, &daemon->sessions, list) {\n\t\tif (!strcmp(session->name, name))\n\t\t\treturn session;\n\t}\n\n\treturn NULL;\n}\n\nstatic int get_session_name(const char *var, char *session, int len)\n{\n\tconst char *p = var + sizeof(\"session-\") - 1;\n\n\twhile (*p != '.' && *p != 0x0 && len--)\n\t\t*session++ = *p++;\n\n\t*session = 0;\n\treturn *p == '.' ? 0 : -EINVAL;\n}\n\nstatic int session_config(struct daemon *daemon, const char *var, const char *value)\n{\n\tstruct daemon_session *session;\n\tchar name[100];\n\n\tif (get_session_name(var, name, sizeof(name) - 1))\n\t\treturn -EINVAL;\n\n\tvar = strchr(var, '.');\n\tif (!var)\n\t\treturn -EINVAL;\n\n\tvar++;\n\n\tsession = daemon__find_session(daemon, name);\n\n\tif (!session) {\n\t\t \n\t\tsession = daemon__add_session(daemon, name);\n\t\tif (!session)\n\t\t\treturn -ENOMEM;\n\n\t\tpr_debug(\"reconfig: found new session %s\\n\", name);\n\n\t\t \n\t\tsession->state = RECONFIG;\n\t} else if (session->state == KILL) {\n\t\t \n\t\tpr_debug(\"reconfig: found current session %s\\n\", name);\n\t\tsession->state = OK;\n\t}\n\n\tif (!strcmp(var, \"run\")) {\n\t\tbool same = false;\n\n\t\tif (session->run)\n\t\t\tsame = !strcmp(session->run, value);\n\n\t\tif (!same) {\n\t\t\tif (session->run) {\n\t\t\t\tzfree(&session->run);\n\t\t\t\tpr_debug(\"reconfig: session %s is changed\\n\", name);\n\t\t\t}\n\n\t\t\tsession->run = strdup(value);\n\t\t\tif (!session->run)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t \n\t\t\tsession->state = RECONFIG;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int server_config(const char *var, const char *value, void *cb)\n{\n\tstruct daemon *daemon = cb;\n\n\tif (strstarts(var, \"session-\")) {\n\t\treturn session_config(daemon, var, value);\n\t} else if (!strcmp(var, \"daemon.base\") && !daemon->base_user) {\n\t\tif (daemon->base && strcmp(daemon->base, value)) {\n\t\t\tpr_err(\"failed: can't redefine base, bailing out\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdaemon->base = strdup(value);\n\t\tif (!daemon->base)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int client_config(const char *var, const char *value, void *cb)\n{\n\tstruct daemon *daemon = cb;\n\n\tif (!strcmp(var, \"daemon.base\") && !daemon->base_user) {\n\t\tdaemon->base = strdup(value);\n\t\tif (!daemon->base)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_base(struct daemon *daemon)\n{\n\tstruct stat st;\n\n\tif (!daemon->base) {\n\t\tpr_err(\"failed: base not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (stat(daemon->base, &st)) {\n\t\tswitch (errno) {\n\t\tcase EACCES:\n\t\t\tpr_err(\"failed: permission denied for '%s' base\\n\",\n\t\t\t       daemon->base);\n\t\t\treturn -EACCES;\n\t\tcase ENOENT:\n\t\t\tpr_err(\"failed: base '%s' does not exists\\n\",\n\t\t\t       daemon->base);\n\t\t\treturn -EACCES;\n\t\tdefault:\n\t\t\tpr_err(\"failed: can't access base '%s': %s\\n\",\n\t\t\t       daemon->base, strerror(errno));\n\t\t\treturn -errno;\n\t\t}\n\t}\n\n\tif ((st.st_mode & S_IFMT) != S_IFDIR) {\n\t\tpr_err(\"failed: base '%s' is not directory\\n\",\n\t\t       daemon->base);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_client_config(struct daemon *daemon)\n{\n\tstruct perf_config_set *set = perf_config_set__load_file(daemon->config_real);\n\tint err = -ENOMEM;\n\n\tif (set) {\n\t\terr = perf_config_set(set, client_config, daemon);\n\t\tperf_config_set__delete(set);\n\t}\n\n\treturn err ?: check_base(daemon);\n}\n\nstatic int setup_server_config(struct daemon *daemon)\n{\n\tstruct perf_config_set *set;\n\tstruct daemon_session *session;\n\tint err = -ENOMEM;\n\n\tpr_debug(\"reconfig: started\\n\");\n\n\t \n\tlist_for_each_entry(session, &daemon->sessions, list)\n\t\tsession->state = KILL;\n\n\tset = perf_config_set__load_file(daemon->config_real);\n\tif (set) {\n\t\terr = perf_config_set(set, server_config, daemon);\n\t\tperf_config_set__delete(set);\n\t}\n\n\treturn err ?: check_base(daemon);\n}\n\nstatic int daemon_session__run(struct daemon_session *session,\n\t\t\t       struct daemon *daemon)\n{\n\tchar buf[PATH_MAX];\n\tchar **argv;\n\tint argc, fd;\n\n\tif (asprintf(&session->base, \"%s/session-%s\",\n\t\t     daemon->base, session->name) < 0) {\n\t\tperror(\"failed: asprintf\");\n\t\treturn -1;\n\t}\n\n\tif (mkdir(session->base, 0755) && errno != EEXIST) {\n\t\tperror(\"failed: mkdir\");\n\t\treturn -1;\n\t}\n\n\tsession->start = time(NULL);\n\n\tsession->pid = fork();\n\tif (session->pid < 0)\n\t\treturn -1;\n\tif (session->pid > 0) {\n\t\tpr_info(\"reconfig: ruining session [%s:%d]: %s\\n\",\n\t\t\tsession->name, session->pid, session->run);\n\t\treturn 0;\n\t}\n\n\tif (chdir(session->base)) {\n\t\tperror(\"failed: chdir\");\n\t\treturn -1;\n\t}\n\n\tfd = open(\"/dev/null\", O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(\"failed: open /dev/null\");\n\t\treturn -1;\n\t}\n\n\tdup2(fd, 0);\n\tclose(fd);\n\n\tfd = open(SESSION_OUTPUT, O_RDWR|O_CREAT|O_TRUNC, 0644);\n\tif (fd < 0) {\n\t\tperror(\"failed: open session output\");\n\t\treturn -1;\n\t}\n\n\tdup2(fd, 1);\n\tdup2(fd, 2);\n\tclose(fd);\n\n\tif (mkfifo(SESSION_CONTROL, 0600) && errno != EEXIST) {\n\t\tperror(\"failed: create control fifo\");\n\t\treturn -1;\n\t}\n\n\tif (mkfifo(SESSION_ACK, 0600) && errno != EEXIST) {\n\t\tperror(\"failed: create ack fifo\");\n\t\treturn -1;\n\t}\n\n\tscnprintf(buf, sizeof(buf), \"%s record --control=fifo:%s,%s %s\",\n\t\t  daemon->perf, SESSION_CONTROL, SESSION_ACK, session->run);\n\n\targv = argv_split(buf, &argc);\n\tif (!argv)\n\t\texit(-1);\n\n\texit(execve(daemon->perf, argv, NULL));\n\treturn -1;\n}\n\nstatic pid_t handle_signalfd(struct daemon *daemon)\n{\n\tstruct daemon_session *session;\n\tstruct signalfd_siginfo si;\n\tssize_t err;\n\tint status;\n\tpid_t pid;\n\n\t \n\terr = read(daemon->signal_fd, &si, sizeof(struct signalfd_siginfo));\n\tif (err != sizeof(struct signalfd_siginfo)) {\n\t\tpr_err(\"failed to read signal fd\\n\");\n\t\treturn -1;\n\t}\n\n\tlist_for_each_entry(session, &daemon->sessions, list) {\n\t\tif (session->pid == -1)\n\t\t\tcontinue;\n\n\t\tpid = waitpid(session->pid, &status, WNOHANG);\n\t\tif (pid <= 0)\n\t\t\tcontinue;\n\n\t\tif (WIFEXITED(status)) {\n\t\t\tpr_info(\"session '%s' exited, status=%d\\n\",\n\t\t\t\tsession->name, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status)) {\n\t\t\tpr_info(\"session '%s' killed (signal %d)\\n\",\n\t\t\t\tsession->name, WTERMSIG(status));\n\t\t} else if (WIFSTOPPED(status)) {\n\t\t\tpr_info(\"session '%s' stopped (signal %d)\\n\",\n\t\t\t\tsession->name, WSTOPSIG(status));\n\t\t} else {\n\t\t\tpr_info(\"session '%s' Unexpected status (0x%x)\\n\",\n\t\t\t\tsession->name, status);\n\t\t}\n\n\t\tsession->state = KILL;\n\t\tsession->pid = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int daemon_session__wait(struct daemon_session *session, struct daemon *daemon,\n\t\t\t\tint secs)\n{\n\tstruct pollfd pollfd = {\n\t\t.fd\t= daemon->signal_fd,\n\t\t.events\t= POLLIN,\n\t};\n\ttime_t start;\n\n\tstart = time(NULL);\n\n\tdo {\n\t\tint err = poll(&pollfd, 1, 1000);\n\n\t\tif (err > 0) {\n\t\t\thandle_signalfd(daemon);\n\t\t} else if (err < 0) {\n\t\t\tperror(\"failed: poll\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (start + secs < time(NULL))\n\t\t\treturn -1;\n\t} while (session->pid != -1);\n\n\treturn 0;\n}\n\nstatic bool daemon__has_alive_session(struct daemon *daemon)\n{\n\tstruct daemon_session *session;\n\n\tlist_for_each_entry(session, &daemon->sessions, list) {\n\t\tif (session->pid != -1)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int daemon__wait(struct daemon *daemon, int secs)\n{\n\tstruct pollfd pollfd = {\n\t\t.fd\t= daemon->signal_fd,\n\t\t.events\t= POLLIN,\n\t};\n\ttime_t start;\n\n\tstart = time(NULL);\n\n\tdo {\n\t\tint err = poll(&pollfd, 1, 1000);\n\n\t\tif (err > 0) {\n\t\t\thandle_signalfd(daemon);\n\t\t} else if (err < 0) {\n\t\t\tperror(\"failed: poll\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (start + secs < time(NULL))\n\t\t\treturn -1;\n\t} while (daemon__has_alive_session(daemon));\n\n\treturn 0;\n}\n\nstatic int daemon_session__control(struct daemon_session *session,\n\t\t\t\t   const char *msg, bool do_ack)\n{\n\tstruct pollfd pollfd = { .events = POLLIN, };\n\tchar control_path[PATH_MAX];\n\tchar ack_path[PATH_MAX];\n\tint control, ack = -1, len;\n\tchar buf[20];\n\tint ret = -1;\n\tssize_t err;\n\n\t \n\tscnprintf(control_path, sizeof(control_path), \"%s/%s\",\n\t\t  session->base, SESSION_CONTROL);\n\n\tcontrol = open(control_path, O_WRONLY|O_NONBLOCK);\n\tif (!control)\n\t\treturn -1;\n\n\tif (do_ack) {\n\t\t \n\t\tscnprintf(ack_path, sizeof(ack_path), \"%s/%s\",\n\t\t\t  session->base, SESSION_ACK);\n\n\t\tack = open(ack_path, O_RDONLY, O_NONBLOCK);\n\t\tif (!ack) {\n\t\t\tclose(control);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tlen = strlen(msg);\n\n\terr = writen(control, msg, len);\n\tif (err != len) {\n\t\tpr_err(\"failed: write to control pipe: %d (%s)\\n\",\n\t\t       errno, control_path);\n\t\tgoto out;\n\t}\n\n\tif (!do_ack)\n\t\tgoto out;\n\n\t \n\tpollfd.fd = ack;\n\n\tif (!poll(&pollfd, 1, 2000)) {\n\t\tpr_err(\"failed: control ack timeout\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!(pollfd.revents & POLLIN)) {\n\t\tpr_err(\"failed: did not received an ack\\n\");\n\t\tgoto out;\n\t}\n\n\terr = read(ack, buf, sizeof(buf));\n\tif (err > 0)\n\t\tret = strcmp(buf, \"ack\\n\");\n\telse\n\t\tperror(\"failed: read ack %d\\n\");\n\nout:\n\tif (ack != -1)\n\t\tclose(ack);\n\n\tclose(control);\n\treturn ret;\n}\n\nstatic int setup_server_socket(struct daemon *daemon)\n{\n\tstruct sockaddr_un addr;\n\tchar path[PATH_MAX];\n\tint fd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"socket: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tperror(\"failed: fcntl FD_CLOEXEC\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tscnprintf(path, sizeof(path), \"%s/control\", daemon->base);\n\n\tif (strlen(path) + 1 >= sizeof(addr.sun_path)) {\n\t\tpr_err(\"failed: control path too long '%s'\\n\", path);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\n\tstrlcpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n\tunlink(path);\n\n\tif (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tperror(\"failed: bind\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tif (listen(fd, 1) == -1) {\n\t\tperror(\"failed: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nenum {\n\tCMD_LIST   = 0,\n\tCMD_SIGNAL = 1,\n\tCMD_STOP   = 2,\n\tCMD_PING   = 3,\n\tCMD_MAX,\n};\n\n#define SESSION_MAX 64\n\nunion cmd {\n\tint cmd;\n\n\t \n\tstruct {\n\t\tint\tcmd;\n\t\tint\tverbose;\n\t\tchar\tcsv_sep;\n\t} list;\n\n\t \n\tstruct {\n\t\tint\tcmd;\n\t\tint\tsig;\n\t\tchar\tname[SESSION_MAX];\n\t} signal;\n\n\t \n\tstruct {\n\t\tint\tcmd;\n\t\tchar\tname[SESSION_MAX];\n\t} ping;\n};\n\nenum {\n\tPING_OK\t  = 0,\n\tPING_FAIL = 1,\n\tPING_MAX,\n};\n\nstatic int daemon_session__ping(struct daemon_session *session)\n{\n\treturn daemon_session__control(session, \"ping\", true) ?  PING_FAIL : PING_OK;\n}\n\nstatic int cmd_session_list(struct daemon *daemon, union cmd *cmd, FILE *out)\n{\n\tchar csv_sep = cmd->list.csv_sep;\n\tstruct daemon_session *session;\n\ttime_t curr = time(NULL);\n\n\tif (csv_sep) {\n\t\tfprintf(out, \"%d%c%s%c%s%c%s/%s\",\n\t\t\t \n\t\t\tgetpid(), csv_sep, \"daemon\",\n\t\t\t \n\t\t\tcsv_sep, daemon->base,\n\t\t\t \n\t\t\tcsv_sep, daemon->base, SESSION_OUTPUT);\n\n\t\tfprintf(out, \"%c%s/%s\",\n\t\t\t \n\t\t\tcsv_sep, daemon->base, \"lock\");\n\n\t\tfprintf(out, \"%c%lu\",\n\t\t\t \n\t\t\tcsv_sep, (curr - daemon->start) / 60);\n\n\t\tfprintf(out, \"\\n\");\n\t} else {\n\t\tfprintf(out, \"[%d:daemon] base: %s\\n\", getpid(), daemon->base);\n\t\tif (cmd->list.verbose) {\n\t\t\tfprintf(out, \"  output:  %s/%s\\n\",\n\t\t\t\tdaemon->base, SESSION_OUTPUT);\n\t\t\tfprintf(out, \"  lock:    %s/lock\\n\",\n\t\t\t\tdaemon->base);\n\t\t\tfprintf(out, \"  up:      %lu minutes\\n\",\n\t\t\t\t(curr - daemon->start) / 60);\n\t\t}\n\t}\n\n\tlist_for_each_entry(session, &daemon->sessions, list) {\n\t\tif (csv_sep) {\n\t\t\tfprintf(out, \"%d%c%s%c%s\",\n\t\t\t\t \n\t\t\t\tsession->pid,\n\t\t\t\t \n\t\t\t\tcsv_sep, session->name,\n\t\t\t\t \n\t\t\t\tcsv_sep, session->run);\n\n\t\t\tfprintf(out, \"%c%s%c%s/%s\",\n\t\t\t\t \n\t\t\t\tcsv_sep, session->base,\n\t\t\t\t \n\t\t\t\tcsv_sep, session->base, SESSION_OUTPUT);\n\n\t\t\tfprintf(out, \"%c%s/%s%c%s/%s\",\n\t\t\t\t \n\t\t\t\tcsv_sep, session->base, SESSION_CONTROL,\n\t\t\t\t \n\t\t\t\tcsv_sep, session->base, SESSION_ACK);\n\n\t\t\tfprintf(out, \"%c%lu\",\n\t\t\t\t \n\t\t\t\tcsv_sep, (curr - session->start) / 60);\n\n\t\t\tfprintf(out, \"\\n\");\n\t\t} else {\n\t\t\tfprintf(out, \"[%d:%s] perf record %s\\n\",\n\t\t\t\tsession->pid, session->name, session->run);\n\t\t\tif (!cmd->list.verbose)\n\t\t\t\tcontinue;\n\t\t\tfprintf(out, \"  base:    %s\\n\",\n\t\t\t\tsession->base);\n\t\t\tfprintf(out, \"  output:  %s/%s\\n\",\n\t\t\t\tsession->base, SESSION_OUTPUT);\n\t\t\tfprintf(out, \"  control: %s/%s\\n\",\n\t\t\t\tsession->base, SESSION_CONTROL);\n\t\t\tfprintf(out, \"  ack:     %s/%s\\n\",\n\t\t\t\tsession->base, SESSION_ACK);\n\t\t\tfprintf(out, \"  up:      %lu minutes\\n\",\n\t\t\t\t(curr - session->start) / 60);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int daemon_session__signal(struct daemon_session *session, int sig)\n{\n\tif (session->pid < 0)\n\t\treturn -1;\n\treturn kill(session->pid, sig);\n}\n\nstatic int cmd_session_kill(struct daemon *daemon, union cmd *cmd, FILE *out)\n{\n\tstruct daemon_session *session;\n\tbool all = false;\n\n\tall = !strcmp(cmd->signal.name, \"all\");\n\n\tlist_for_each_entry(session, &daemon->sessions, list) {\n\t\tif (all || !strcmp(cmd->signal.name, session->name)) {\n\t\t\tdaemon_session__signal(session, cmd->signal.sig);\n\t\t\tfprintf(out, \"signal %d sent to session '%s [%d]'\\n\",\n\t\t\t\tcmd->signal.sig, session->name, session->pid);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const char *ping_str[PING_MAX] = {\n\t[PING_OK]   = \"OK\",\n\t[PING_FAIL] = \"FAIL\",\n};\n\nstatic int cmd_session_ping(struct daemon *daemon, union cmd *cmd, FILE *out)\n{\n\tstruct daemon_session *session;\n\tbool all = false, found = false;\n\n\tall = !strcmp(cmd->ping.name, \"all\");\n\n\tlist_for_each_entry(session, &daemon->sessions, list) {\n\t\tif (all || !strcmp(cmd->ping.name, session->name)) {\n\t\t\tint state = daemon_session__ping(session);\n\n\t\t\tfprintf(out, \"%-4s %s\\n\", ping_str[state], session->name);\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tif (!found && !all) {\n\t\tfprintf(out, \"%-4s %s (not found)\\n\",\n\t\t\tping_str[PING_FAIL], cmd->ping.name);\n\t}\n\treturn 0;\n}\n\nstatic int handle_server_socket(struct daemon *daemon, int sock_fd)\n{\n\tint ret = -1, fd;\n\tFILE *out = NULL;\n\tunion cmd cmd;\n\n\tfd = accept(sock_fd, NULL, NULL);\n\tif (fd < 0) {\n\t\tperror(\"failed: accept\");\n\t\treturn -1;\n\t}\n\n\tif (sizeof(cmd) != readn(fd, &cmd, sizeof(cmd))) {\n\t\tperror(\"failed: read\");\n\t\tgoto out;\n\t}\n\n\tout = fdopen(fd, \"w\");\n\tif (!out) {\n\t\tperror(\"failed: fdopen\");\n\t\tgoto out;\n\t}\n\n\tswitch (cmd.cmd) {\n\tcase CMD_LIST:\n\t\tret = cmd_session_list(daemon, &cmd, out);\n\t\tbreak;\n\tcase CMD_SIGNAL:\n\t\tret = cmd_session_kill(daemon, &cmd, out);\n\t\tbreak;\n\tcase CMD_STOP:\n\t\tdone = 1;\n\t\tret = 0;\n\t\tpr_debug(\"perf daemon is exciting\\n\");\n\t\tbreak;\n\tcase CMD_PING:\n\t\tret = cmd_session_ping(daemon, &cmd, out);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfclose(out);\nout:\n\t \n\tif (!out)\n\t\tclose(fd);\n\treturn ret;\n}\n\nstatic int setup_client_socket(struct daemon *daemon)\n{\n\tstruct sockaddr_un addr;\n\tchar path[PATH_MAX];\n\tint fd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n\tif (fd == -1) {\n\t\tperror(\"failed: socket\");\n\t\treturn -1;\n\t}\n\n\tscnprintf(path, sizeof(path), \"%s/control\", daemon->base);\n\n\tif (strlen(path) + 1 >= sizeof(addr.sun_path)) {\n\t\tpr_err(\"failed: control path too long '%s'\\n\", path);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrlcpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n\n\tif (connect(fd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n\t\tperror(\"failed: connect\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic void daemon_session__kill(struct daemon_session *session,\n\t\t\t\t struct daemon *daemon)\n{\n\tint how = 0;\n\n\tdo {\n\t\tswitch (how) {\n\t\tcase 0:\n\t\t\tdaemon_session__control(session, \"stop\", false);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdaemon_session__signal(session, SIGTERM);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdaemon_session__signal(session, SIGKILL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"failed to wait for session %s\\n\",\n\t\t\t       session->name);\n\t\t\treturn;\n\t\t}\n\t\thow++;\n\n\t} while (daemon_session__wait(session, daemon, 10));\n}\n\nstatic void daemon__signal(struct daemon *daemon, int sig)\n{\n\tstruct daemon_session *session;\n\n\tlist_for_each_entry(session, &daemon->sessions, list)\n\t\tdaemon_session__signal(session, sig);\n}\n\nstatic void daemon_session__delete(struct daemon_session *session)\n{\n\tzfree(&session->base);\n\tzfree(&session->name);\n\tzfree(&session->run);\n\tfree(session);\n}\n\nstatic void daemon_session__remove(struct daemon_session *session)\n{\n\tlist_del(&session->list);\n\tdaemon_session__delete(session);\n}\n\nstatic void daemon__stop(struct daemon *daemon)\n{\n\tstruct daemon_session *session;\n\n\tlist_for_each_entry(session, &daemon->sessions, list)\n\t\tdaemon_session__control(session, \"stop\", false);\n}\n\nstatic void daemon__kill(struct daemon *daemon)\n{\n\tint how = 0;\n\n\tdo {\n\t\tswitch (how) {\n\t\tcase 0:\n\t\t\tdaemon__stop(daemon);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdaemon__signal(daemon, SIGTERM);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdaemon__signal(daemon, SIGKILL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"failed to wait for sessions\\n\");\n\t\t\treturn;\n\t\t}\n\t\thow++;\n\n\t} while (daemon__wait(daemon, 10));\n}\n\nstatic void daemon__exit(struct daemon *daemon)\n{\n\tstruct daemon_session *session, *h;\n\n\tlist_for_each_entry_safe(session, h, &daemon->sessions, list)\n\t\tdaemon_session__remove(session);\n\n\tzfree(&daemon->config_real);\n\tzfree(&daemon->config_base);\n\tzfree(&daemon->base);\n}\n\nstatic int daemon__reconfig(struct daemon *daemon)\n{\n\tstruct daemon_session *session, *n;\n\n\tlist_for_each_entry_safe(session, n, &daemon->sessions, list) {\n\t\t \n\t\tif (session->state == OK)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (session->state == KILL) {\n\t\t\tif (session->pid > 0) {\n\t\t\t\tdaemon_session__kill(session, daemon);\n\t\t\t\tpr_info(\"reconfig: session '%s' killed\\n\", session->name);\n\t\t\t}\n\t\t\tdaemon_session__remove(session);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (session->pid > 0) {\n\t\t\tdaemon_session__kill(session, daemon);\n\t\t\tpr_info(\"reconfig: session '%s' killed\\n\", session->name);\n\t\t}\n\t\tif (daemon_session__run(session, daemon))\n\t\t\treturn -1;\n\n\t\tsession->state = OK;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_config_changes(struct daemon *daemon)\n{\n\tchar *basen = strdup(daemon->config_real);\n\tchar *dirn  = strdup(daemon->config_real);\n\tchar *base, *dir;\n\tint fd, wd = -1;\n\n\tif (!dirn || !basen)\n\t\tgoto out;\n\n\tfd = inotify_init1(IN_NONBLOCK|O_CLOEXEC);\n\tif (fd < 0) {\n\t\tperror(\"failed: inotify_init\");\n\t\tgoto out;\n\t}\n\n\tdir = dirname(dirn);\n\tbase = basename(basen);\n\tpr_debug(\"config file: %s, dir: %s\\n\", base, dir);\n\n\twd = inotify_add_watch(fd, dir, IN_CLOSE_WRITE);\n\tif (wd >= 0) {\n\t\tdaemon->config_base = strdup(base);\n\t\tif (!daemon->config_base) {\n\t\t\tclose(fd);\n\t\t\twd = -1;\n\t\t}\n\t} else {\n\t\tperror(\"failed: inotify_add_watch\");\n\t}\n\nout:\n\tfree(basen);\n\tfree(dirn);\n\treturn wd < 0 ? -1 : fd;\n}\n\nstatic bool process_inotify_event(struct daemon *daemon, char *buf, ssize_t len)\n{\n\tchar *p = buf;\n\n\twhile (p < (buf + len)) {\n\t\tstruct inotify_event *event = (struct inotify_event *) p;\n\n\t\t \n\t\tif ((event->mask & IN_CLOSE_WRITE) &&\n\t\t    !(event->mask & IN_ISDIR)) {\n\t\t\tif (!strcmp(event->name, daemon->config_base))\n\t\t\t\treturn true;\n\t\t}\n\t\tp += sizeof(*event) + event->len;\n\t}\n\treturn false;\n}\n\nstatic int handle_config_changes(struct daemon *daemon, int conf_fd,\n\t\t\t\t bool *config_changed)\n{\n\tchar buf[4096];\n\tssize_t len;\n\n\twhile (!(*config_changed)) {\n\t\tlen = read(conf_fd, buf, sizeof(buf));\n\t\tif (len == -1) {\n\t\t\tif (errno != EAGAIN) {\n\t\t\t\tperror(\"failed: read\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t*config_changed = process_inotify_event(daemon, buf, len);\n\t}\n\treturn 0;\n}\n\nstatic int setup_config(struct daemon *daemon)\n{\n\tif (daemon->base_user) {\n\t\tdaemon->base = strdup(daemon->base_user);\n\t\tif (!daemon->base)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (daemon->config) {\n\t\tchar *real = realpath(daemon->config, NULL);\n\n\t\tif (!real) {\n\t\t\tperror(\"failed: realpath\");\n\t\t\treturn -1;\n\t\t}\n\t\tdaemon->config_real = real;\n\t\treturn 0;\n\t}\n\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK))\n\t\tdaemon->config_real = strdup(perf_etc_perfconfig());\n\telse if (perf_config_global() && perf_home_perfconfig())\n\t\tdaemon->config_real = strdup(perf_home_perfconfig());\n\n\treturn daemon->config_real ? 0 : -1;\n}\n\n#ifndef F_TLOCK\n#define F_TLOCK 2\n\nstatic int lockf(int fd, int cmd, off_t len)\n{\n\tif (cmd != F_TLOCK || len != 0)\n\t\treturn -1;\n\n\treturn flock(fd, LOCK_EX | LOCK_NB);\n}\n#endif \n\n \nstatic int check_lock(struct daemon *daemon)\n{\n\tchar path[PATH_MAX];\n\tchar buf[20];\n\tint fd, pid;\n\tssize_t len;\n\n\tscnprintf(path, sizeof(path), \"%s/lock\", daemon->base);\n\n\tfd = open(path, O_RDWR|O_CREAT|O_CLOEXEC, 0640);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (lockf(fd, F_TLOCK, 0) < 0) {\n\t\tfilename__read_int(path, &pid);\n\t\tfprintf(stderr, \"failed: another perf daemon (pid %d) owns %s\\n\",\n\t\t\tpid, daemon->base);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tscnprintf(buf, sizeof(buf), \"%d\", getpid());\n\tlen = strlen(buf);\n\n\tif (write(fd, buf, len) != len) {\n\t\tperror(\"failed: write\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tif (ftruncate(fd, len)) {\n\t\tperror(\"failed: ftruncate\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int go_background(struct daemon *daemon)\n{\n\tint pid, fd;\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn -1;\n\n\tif (pid > 0)\n\t\treturn 1;\n\n\tif (setsid() < 0)\n\t\treturn -1;\n\n\tif (check_lock(daemon))\n\t\treturn -1;\n\n\tumask(0);\n\n\tif (chdir(daemon->base)) {\n\t\tperror(\"failed: chdir\");\n\t\treturn -1;\n\t}\n\n\tfd = open(\"output\", O_RDWR|O_CREAT|O_TRUNC, 0644);\n\tif (fd < 0) {\n\t\tperror(\"failed: open\");\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tperror(\"failed: fcntl FD_CLOEXEC\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\tclose(0);\n\tdup2(fd, 1);\n\tdup2(fd, 2);\n\tclose(fd);\n\n\tdaemon->out = fdopen(1, \"w\");\n\tif (!daemon->out) {\n\t\tclose(1);\n\t\tclose(2);\n\t\treturn -1;\n\t}\n\n\tsetbuf(daemon->out, NULL);\n\treturn 0;\n}\n\nstatic int setup_signalfd(struct daemon *daemon)\n{\n\tsigset_t mask;\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGCHLD);\n\n\tif (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n\t\treturn -1;\n\n\tdaemon->signal_fd = signalfd(-1, &mask, SFD_NONBLOCK|SFD_CLOEXEC);\n\treturn daemon->signal_fd;\n}\n\nstatic int __cmd_start(struct daemon *daemon, struct option parent_options[],\n\t\t       int argc, const char **argv)\n{\n\tbool foreground = false;\n\tstruct option start_options[] = {\n\t\tOPT_BOOLEAN('f', \"foreground\", &foreground, \"stay on console\"),\n\t\tOPT_PARENT(parent_options),\n\t\tOPT_END()\n\t};\n\tint sock_fd = -1, conf_fd = -1, signal_fd = -1;\n\tint sock_pos, file_pos, signal_pos;\n\tstruct fdarray fda;\n\tint err = 0;\n\n\targc = parse_options(argc, argv, start_options, daemon_usage, 0);\n\tif (argc)\n\t\tusage_with_options(daemon_usage, start_options);\n\n\tdaemon->start = time(NULL);\n\n\tif (setup_config(daemon)) {\n\t\tpr_err(\"failed: config not found\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setup_server_config(daemon))\n\t\treturn -1;\n\n\tif (foreground && check_lock(daemon))\n\t\treturn -1;\n\n\tif (!foreground) {\n\t\terr = go_background(daemon);\n\t\tif (err) {\n\t\t\t \n\t\t\tif (err == 1)\n\t\t\t\terr = 0;\n\t\t\tdaemon__exit(daemon);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdebug_set_file(daemon->out);\n\tdebug_set_display_time(true);\n\n\tpr_info(\"daemon started (pid %d)\\n\", getpid());\n\n\tfdarray__init(&fda, 3);\n\n\tsock_fd = setup_server_socket(daemon);\n\tif (sock_fd < 0)\n\t\tgoto out;\n\n\tconf_fd = setup_config_changes(daemon);\n\tif (conf_fd < 0)\n\t\tgoto out;\n\n\tsignal_fd = setup_signalfd(daemon);\n\tif (signal_fd < 0)\n\t\tgoto out;\n\n\tsock_pos = fdarray__add(&fda, sock_fd, POLLIN|POLLERR|POLLHUP, 0);\n\tif (sock_pos < 0)\n\t\tgoto out;\n\n\tfile_pos = fdarray__add(&fda, conf_fd, POLLIN|POLLERR|POLLHUP, 0);\n\tif (file_pos < 0)\n\t\tgoto out;\n\n\tsignal_pos = fdarray__add(&fda, signal_fd, POLLIN|POLLERR|POLLHUP, 0);\n\tif (signal_pos < 0)\n\t\tgoto out;\n\n\tsignal(SIGINT, sig_handler);\n\tsignal(SIGTERM, sig_handler);\n\tsignal(SIGPIPE, SIG_IGN);\n\n\twhile (!done && !err) {\n\t\terr = daemon__reconfig(daemon);\n\n\t\tif (!err && fdarray__poll(&fda, -1)) {\n\t\t\tbool reconfig = false;\n\n\t\t\tif (fda.entries[sock_pos].revents & POLLIN)\n\t\t\t\terr = handle_server_socket(daemon, sock_fd);\n\t\t\tif (fda.entries[file_pos].revents & POLLIN)\n\t\t\t\terr = handle_config_changes(daemon, conf_fd, &reconfig);\n\t\t\tif (fda.entries[signal_pos].revents & POLLIN)\n\t\t\t\terr = handle_signalfd(daemon) < 0;\n\n\t\t\tif (reconfig)\n\t\t\t\terr = setup_server_config(daemon);\n\t\t}\n\t}\n\nout:\n\tfdarray__exit(&fda);\n\n\tdaemon__kill(daemon);\n\tdaemon__exit(daemon);\n\n\tif (sock_fd != -1)\n\t\tclose(sock_fd);\n\tif (conf_fd != -1)\n\t\tclose(conf_fd);\n\tif (signal_fd != -1)\n\t\tclose(signal_fd);\n\n\tpr_info(\"daemon exited\\n\");\n\tfclose(daemon->out);\n\treturn err;\n}\n\nstatic int send_cmd(struct daemon *daemon, union cmd *cmd)\n{\n\tint ret = -1, fd;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tssize_t nread;\n\tFILE *in = NULL;\n\n\tif (setup_client_config(daemon))\n\t\treturn -1;\n\n\tfd = setup_client_socket(daemon);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (sizeof(*cmd) != writen(fd, cmd, sizeof(*cmd))) {\n\t\tperror(\"failed: write\");\n\t\tgoto out;\n\t}\n\n\tin = fdopen(fd, \"r\");\n\tif (!in) {\n\t\tperror(\"failed: fdopen\");\n\t\tgoto out;\n\t}\n\n\twhile ((nread = getline(&line, &len, in)) != -1) {\n\t\tif (fwrite(line, nread, 1, stdout) != 1)\n\t\t\tgoto out_fclose;\n\t\tfflush(stdout);\n\t}\n\n\tret = 0;\nout_fclose:\n\tfclose(in);\n\tfree(line);\nout:\n\t \n\tif (!in)\n\t\tclose(fd);\n\treturn ret;\n}\n\nstatic int send_cmd_list(struct daemon *daemon)\n{\n\tunion cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.list.cmd = CMD_LIST;\n\tcmd.list.verbose = verbose;\n\tcmd.list.csv_sep = daemon->csv_sep ? *daemon->csv_sep : 0;\n\n\treturn send_cmd(daemon, &cmd);\n}\n\nstatic int __cmd_signal(struct daemon *daemon, struct option parent_options[],\n\t\t\tint argc, const char **argv)\n{\n\tconst char *name = \"all\";\n\tstruct option start_options[] = {\n\t\tOPT_STRING(0, \"session\", &name, \"session\",\n\t\t\t\"Sent signal to specific session\"),\n\t\tOPT_PARENT(parent_options),\n\t\tOPT_END()\n\t};\n\tunion cmd cmd;\n\n\targc = parse_options(argc, argv, start_options, daemon_usage, 0);\n\tif (argc)\n\t\tusage_with_options(daemon_usage, start_options);\n\n\tif (setup_config(daemon)) {\n\t\tpr_err(\"failed: config not found\\n\");\n\t\treturn -1;\n\t}\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.signal.cmd = CMD_SIGNAL,\n\tcmd.signal.sig = SIGUSR2;\n\tstrncpy(cmd.signal.name, name, sizeof(cmd.signal.name) - 1);\n\n\treturn send_cmd(daemon, &cmd);\n}\n\nstatic int __cmd_stop(struct daemon *daemon, struct option parent_options[],\n\t\t\tint argc, const char **argv)\n{\n\tstruct option start_options[] = {\n\t\tOPT_PARENT(parent_options),\n\t\tOPT_END()\n\t};\n\tunion cmd cmd;\n\n\targc = parse_options(argc, argv, start_options, daemon_usage, 0);\n\tif (argc)\n\t\tusage_with_options(daemon_usage, start_options);\n\n\tif (setup_config(daemon)) {\n\t\tpr_err(\"failed: config not found\\n\");\n\t\treturn -1;\n\t}\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = CMD_STOP;\n\treturn send_cmd(daemon, &cmd);\n}\n\nstatic int __cmd_ping(struct daemon *daemon, struct option parent_options[],\n\t\t      int argc, const char **argv)\n{\n\tconst char *name = \"all\";\n\tstruct option ping_options[] = {\n\t\tOPT_STRING(0, \"session\", &name, \"session\",\n\t\t\t\"Ping to specific session\"),\n\t\tOPT_PARENT(parent_options),\n\t\tOPT_END()\n\t};\n\tunion cmd cmd;\n\n\targc = parse_options(argc, argv, ping_options, daemon_usage, 0);\n\tif (argc)\n\t\tusage_with_options(daemon_usage, ping_options);\n\n\tif (setup_config(daemon)) {\n\t\tpr_err(\"failed: config not found\\n\");\n\t\treturn -1;\n\t}\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = CMD_PING;\n\tscnprintf(cmd.ping.name, sizeof(cmd.ping.name), \"%s\", name);\n\treturn send_cmd(daemon, &cmd);\n}\n\nstatic char *alloc_perf_exe_path(void)\n{\n\tchar path[PATH_MAX];\n\n\tperf_exe(path, sizeof(path));\n\treturn strdup(path);\n}\n\nint cmd_daemon(int argc, const char **argv)\n{\n\tstruct option daemon_options[] = {\n\t\tOPT_INCR('v', \"verbose\", &verbose, \"be more verbose\"),\n\t\tOPT_STRING(0, \"config\", &__daemon.config,\n\t\t\t\"config file\", \"config file path\"),\n\t\tOPT_STRING(0, \"base\", &__daemon.base_user,\n\t\t\t\"directory\", \"base directory\"),\n\t\tOPT_STRING_OPTARG('x', \"field-separator\", &__daemon.csv_sep,\n\t\t\t\"field separator\", \"print counts with custom separator\", \",\"),\n\t\tOPT_END()\n\t};\n\tint ret = -1;\n\n\t__daemon.perf = alloc_perf_exe_path();\n\tif (!__daemon.perf)\n\t\treturn -ENOMEM;\n\n\t__daemon.out = stdout;\n\n\targc = parse_options(argc, argv, daemon_options, daemon_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tif (argc) {\n\t\tif (!strcmp(argv[0], \"start\"))\n\t\t\tret = __cmd_start(&__daemon, daemon_options, argc, argv);\n\t\telse if (!strcmp(argv[0], \"signal\"))\n\t\t\tret = __cmd_signal(&__daemon, daemon_options, argc, argv);\n\t\telse if (!strcmp(argv[0], \"stop\"))\n\t\t\tret = __cmd_stop(&__daemon, daemon_options, argc, argv);\n\t\telse if (!strcmp(argv[0], \"ping\"))\n\t\t\tret = __cmd_ping(&__daemon, daemon_options, argc, argv);\n\t\telse\n\t\t\tpr_err(\"failed: unknown command '%s'\\n\", argv[0]);\n\t} else {\n\t\tret = setup_config(&__daemon);\n\t\tif (ret)\n\t\t\tpr_err(\"failed: config not found\\n\");\n\t\telse\n\t\t\tret = send_cmd_list(&__daemon);\n\t}\n\tzfree(&__daemon.perf);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}