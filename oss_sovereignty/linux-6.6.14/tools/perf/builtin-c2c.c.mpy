{
  "module_name": "builtin-c2c.c",
  "hash_id": "3a09002cb7cc68ecfb5dcd999da499d2ffff52abdbed4fdb1536d605c937e01d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-c2c.c",
  "human_readable_source": "\n \n#include <errno.h>\n#include <inttypes.h>\n#include <linux/compiler.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/stringify.h>\n#include <linux/zalloc.h>\n#include <asm/bug.h>\n#include <sys/param.h>\n#include \"debug.h\"\n#include \"builtin.h\"\n#include <perf/cpumap.h>\n#include <subcmd/pager.h>\n#include <subcmd/parse-options.h>\n#include \"map_symbol.h\"\n#include \"mem-events.h\"\n#include \"session.h\"\n#include \"hist.h\"\n#include \"sort.h\"\n#include \"tool.h\"\n#include \"cacheline.h\"\n#include \"data.h\"\n#include \"event.h\"\n#include \"evlist.h\"\n#include \"evsel.h\"\n#include \"ui/browsers/hists.h\"\n#include \"thread.h\"\n#include \"mem2node.h\"\n#include \"symbol.h\"\n#include \"ui/ui.h\"\n#include \"ui/progress.h\"\n#include \"pmus.h\"\n#include \"string2.h\"\n#include \"util/util.h\"\n\nstruct c2c_hists {\n\tstruct hists\t\thists;\n\tstruct perf_hpp_list\tlist;\n\tstruct c2c_stats\tstats;\n};\n\nstruct compute_stats {\n\tstruct stats\t\t lcl_hitm;\n\tstruct stats\t\t rmt_hitm;\n\tstruct stats\t\t lcl_peer;\n\tstruct stats\t\t rmt_peer;\n\tstruct stats\t\t load;\n};\n\nstruct c2c_hist_entry {\n\tstruct c2c_hists\t*hists;\n\tstruct c2c_stats\t stats;\n\tunsigned long\t\t*cpuset;\n\tunsigned long\t\t*nodeset;\n\tstruct c2c_stats\t*node_stats;\n\tunsigned int\t\t cacheline_idx;\n\n\tstruct compute_stats\t cstats;\n\n\tunsigned long\t\t paddr;\n\tunsigned long\t\t paddr_cnt;\n\tbool\t\t\t paddr_zero;\n\tchar\t\t\t*nodestr;\n\n\t \n\tstruct hist_entry\the;\n};\n\nstatic char const *coalesce_default = \"iaddr\";\n\nstruct perf_c2c {\n\tstruct perf_tool\ttool;\n\tstruct c2c_hists\thists;\n\tstruct mem2node\t\tmem2node;\n\n\tunsigned long\t\t**nodes;\n\tint\t\t\t nodes_cnt;\n\tint\t\t\t cpus_cnt;\n\tint\t\t\t*cpu2node;\n\tint\t\t\t node_info;\n\n\tbool\t\t\t show_src;\n\tbool\t\t\t show_all;\n\tbool\t\t\t use_stdio;\n\tbool\t\t\t stats_only;\n\tbool\t\t\t symbol_full;\n\tbool\t\t\t stitch_lbr;\n\n\t \n\tstruct c2c_stats\tshared_clines_stats;\n\tint\t\t\tshared_clines;\n\n\tint\t\t\t display;\n\n\tconst char\t\t*coalesce;\n\tchar\t\t\t*cl_sort;\n\tchar\t\t\t*cl_resort;\n\tchar\t\t\t*cl_output;\n};\n\nenum {\n\tDISPLAY_LCL_HITM,\n\tDISPLAY_RMT_HITM,\n\tDISPLAY_TOT_HITM,\n\tDISPLAY_SNP_PEER,\n\tDISPLAY_MAX,\n};\n\nstatic const char *display_str[DISPLAY_MAX] = {\n\t[DISPLAY_LCL_HITM] = \"Local HITMs\",\n\t[DISPLAY_RMT_HITM] = \"Remote HITMs\",\n\t[DISPLAY_TOT_HITM] = \"Total HITMs\",\n\t[DISPLAY_SNP_PEER] = \"Peer Snoop\",\n};\n\nstatic const struct option c2c_options[] = {\n\tOPT_INCR('v', \"verbose\", &verbose, \"be more verbose (show counter open errors, etc)\"),\n\tOPT_END()\n};\n\nstatic struct perf_c2c c2c;\n\nstatic void *c2c_he_zalloc(size_t size)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\n\tc2c_he = zalloc(size + sizeof(*c2c_he));\n\tif (!c2c_he)\n\t\treturn NULL;\n\n\tc2c_he->cpuset = bitmap_zalloc(c2c.cpus_cnt);\n\tif (!c2c_he->cpuset)\n\t\tgoto out_free;\n\n\tc2c_he->nodeset = bitmap_zalloc(c2c.nodes_cnt);\n\tif (!c2c_he->nodeset)\n\t\tgoto out_free;\n\n\tc2c_he->node_stats = zalloc(c2c.nodes_cnt * sizeof(*c2c_he->node_stats));\n\tif (!c2c_he->node_stats)\n\t\tgoto out_free;\n\n\tinit_stats(&c2c_he->cstats.lcl_hitm);\n\tinit_stats(&c2c_he->cstats.rmt_hitm);\n\tinit_stats(&c2c_he->cstats.lcl_peer);\n\tinit_stats(&c2c_he->cstats.rmt_peer);\n\tinit_stats(&c2c_he->cstats.load);\n\n\treturn &c2c_he->he;\n\nout_free:\n\tzfree(&c2c_he->nodeset);\n\tzfree(&c2c_he->cpuset);\n\tfree(c2c_he);\n\treturn NULL;\n}\n\nstatic void c2c_he_free(void *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\tif (c2c_he->hists) {\n\t\thists__delete_entries(&c2c_he->hists->hists);\n\t\tzfree(&c2c_he->hists);\n\t}\n\n\tzfree(&c2c_he->cpuset);\n\tzfree(&c2c_he->nodeset);\n\tzfree(&c2c_he->nodestr);\n\tzfree(&c2c_he->node_stats);\n\tfree(c2c_he);\n}\n\nstatic struct hist_entry_ops c2c_entry_ops = {\n\t.new\t= c2c_he_zalloc,\n\t.free\t= c2c_he_free,\n};\n\nstatic int c2c_hists__init(struct c2c_hists *hists,\n\t\t\t   const char *sort,\n\t\t\t   int nr_header_lines);\n\nstatic struct c2c_hists*\nhe__get_c2c_hists(struct hist_entry *he,\n\t\t  const char *sort,\n\t\t  int nr_header_lines)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tstruct c2c_hists *hists;\n\tint ret;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\tif (c2c_he->hists)\n\t\treturn c2c_he->hists;\n\n\thists = c2c_he->hists = zalloc(sizeof(*hists));\n\tif (!hists)\n\t\treturn NULL;\n\n\tret = c2c_hists__init(hists, sort, nr_header_lines);\n\tif (ret) {\n\t\tfree(hists);\n\t\treturn NULL;\n\t}\n\n\treturn hists;\n}\n\nstatic void c2c_he__set_cpu(struct c2c_hist_entry *c2c_he,\n\t\t\t    struct perf_sample *sample)\n{\n\tif (WARN_ONCE(sample->cpu == (unsigned int) -1,\n\t\t      \"WARNING: no sample cpu value\"))\n\t\treturn;\n\n\t__set_bit(sample->cpu, c2c_he->cpuset);\n}\n\nstatic void c2c_he__set_node(struct c2c_hist_entry *c2c_he,\n\t\t\t     struct perf_sample *sample)\n{\n\tint node;\n\n\tif (!sample->phys_addr) {\n\t\tc2c_he->paddr_zero = true;\n\t\treturn;\n\t}\n\n\tnode = mem2node__node(&c2c.mem2node, sample->phys_addr);\n\tif (WARN_ONCE(node < 0, \"WARNING: failed to find node\\n\"))\n\t\treturn;\n\n\t__set_bit(node, c2c_he->nodeset);\n\n\tif (c2c_he->paddr != sample->phys_addr) {\n\t\tc2c_he->paddr_cnt++;\n\t\tc2c_he->paddr = sample->phys_addr;\n\t}\n}\n\nstatic void compute_stats(struct c2c_hist_entry *c2c_he,\n\t\t\t  struct c2c_stats *stats,\n\t\t\t  u64 weight)\n{\n\tstruct compute_stats *cstats = &c2c_he->cstats;\n\n\tif (stats->rmt_hitm)\n\t\tupdate_stats(&cstats->rmt_hitm, weight);\n\telse if (stats->lcl_hitm)\n\t\tupdate_stats(&cstats->lcl_hitm, weight);\n\telse if (stats->rmt_peer)\n\t\tupdate_stats(&cstats->rmt_peer, weight);\n\telse if (stats->lcl_peer)\n\t\tupdate_stats(&cstats->lcl_peer, weight);\n\telse if (stats->load)\n\t\tupdate_stats(&cstats->load, weight);\n}\n\nstatic int process_sample_event(struct perf_tool *tool __maybe_unused,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct c2c_hists *c2c_hists = &c2c.hists;\n\tstruct c2c_hist_entry *c2c_he;\n\tstruct c2c_stats stats = { .nr_entries = 0, };\n\tstruct hist_entry *he;\n\tstruct addr_location al;\n\tstruct mem_info *mi, *mi_dup;\n\tstruct callchain_cursor *cursor;\n\tint ret;\n\n\taddr_location__init(&al);\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tpr_debug(\"problem processing %d event, skipping it.\\n\",\n\t\t\t event->header.type);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (c2c.stitch_lbr)\n\t\tthread__set_lbr_stitch_enable(al.thread, true);\n\n\tcursor = get_tls_callchain_cursor();\n\tret = sample__resolve_callchain(sample, cursor, NULL,\n\t\t\t\t\tevsel, &al, sysctl_perf_event_max_stack);\n\tif (ret)\n\t\tgoto out;\n\n\tmi = sample__resolve_mem(sample, &al);\n\tif (mi == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tmi_dup = mem_info__get(mi);\n\n\tc2c_decode_stats(&stats, mi);\n\n\the = hists__add_entry_ops(&c2c_hists->hists, &c2c_entry_ops,\n\t\t\t\t  &al, NULL, NULL, mi, NULL,\n\t\t\t\t  sample, true);\n\tif (he == NULL)\n\t\tgoto free_mi;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\tc2c_add_stats(&c2c_he->stats, &stats);\n\tc2c_add_stats(&c2c_hists->stats, &stats);\n\n\tc2c_he__set_cpu(c2c_he, sample);\n\tc2c_he__set_node(c2c_he, sample);\n\n\thists__inc_nr_samples(&c2c_hists->hists, he->filtered);\n\tret = hist_entry__append_callchain(he, sample);\n\n\tif (!ret) {\n\t\t \n\t\tint cpu = sample->cpu == (unsigned int) -1 ? 0 : sample->cpu;\n\t\tint node = c2c.cpu2node[cpu];\n\n\t\tmi = mi_dup;\n\n\t\tc2c_hists = he__get_c2c_hists(he, c2c.cl_sort, 2);\n\t\tif (!c2c_hists)\n\t\t\tgoto free_mi;\n\n\t\the = hists__add_entry_ops(&c2c_hists->hists, &c2c_entry_ops,\n\t\t\t\t\t  &al, NULL, NULL, mi, NULL,\n\t\t\t\t\t  sample, true);\n\t\tif (he == NULL)\n\t\t\tgoto free_mi;\n\n\t\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\t\tc2c_add_stats(&c2c_he->stats, &stats);\n\t\tc2c_add_stats(&c2c_hists->stats, &stats);\n\t\tc2c_add_stats(&c2c_he->node_stats[node], &stats);\n\n\t\tcompute_stats(c2c_he, &stats, sample->weight);\n\n\t\tc2c_he__set_cpu(c2c_he, sample);\n\t\tc2c_he__set_node(c2c_he, sample);\n\n\t\thists__inc_nr_samples(&c2c_hists->hists, he->filtered);\n\t\tret = hist_entry__append_callchain(he, sample);\n\t}\n\nout:\n\taddr_location__exit(&al);\n\treturn ret;\n\nfree_mi:\n\tmem_info__put(mi_dup);\n\tmem_info__put(mi);\n\tret = -ENOMEM;\n\tgoto out;\n}\n\nstatic struct perf_c2c c2c = {\n\t.tool = {\n\t\t.sample\t\t= process_sample_event,\n\t\t.mmap\t\t= perf_event__process_mmap,\n\t\t.mmap2\t\t= perf_event__process_mmap2,\n\t\t.comm\t\t= perf_event__process_comm,\n\t\t.exit\t\t= perf_event__process_exit,\n\t\t.fork\t\t= perf_event__process_fork,\n\t\t.lost\t\t= perf_event__process_lost,\n\t\t.attr\t\t= perf_event__process_attr,\n\t\t.auxtrace_info  = perf_event__process_auxtrace_info,\n\t\t.auxtrace       = perf_event__process_auxtrace,\n\t\t.auxtrace_error = perf_event__process_auxtrace_error,\n\t\t.ordered_events\t= true,\n\t\t.ordering_requires_timestamps = true,\n\t},\n};\n\nstatic const char * const c2c_usage[] = {\n\t\"perf c2c {record|report}\",\n\tNULL\n};\n\nstatic const char * const __usage_report[] = {\n\t\"perf c2c report\",\n\tNULL\n};\n\nstatic const char * const *report_c2c_usage = __usage_report;\n\n#define C2C_HEADER_MAX 2\n\nstruct c2c_header {\n\tstruct {\n\t\tconst char *text;\n\t\tint\t    span;\n\t} line[C2C_HEADER_MAX];\n};\n\nstruct c2c_dimension {\n\tstruct c2c_header\t header;\n\tconst char\t\t*name;\n\tint\t\t\t width;\n\tstruct sort_entry\t*se;\n\n\tint64_t (*cmp)(struct perf_hpp_fmt *fmt,\n\t\t       struct hist_entry *, struct hist_entry *);\n\tint   (*entry)(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he);\n\tint   (*color)(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he);\n};\n\nstruct c2c_fmt {\n\tstruct perf_hpp_fmt\t fmt;\n\tstruct c2c_dimension\t*dim;\n};\n\n#define SYMBOL_WIDTH 30\n\nstatic struct c2c_dimension dim_symbol;\nstatic struct c2c_dimension dim_srcline;\n\nstatic int symbol_width(struct hists *hists, struct sort_entry *se)\n{\n\tint width = hists__col_len(hists, se->se_width_idx);\n\n\tif (!c2c.symbol_full)\n\t\twidth = MIN(width, SYMBOL_WIDTH);\n\n\treturn width;\n}\n\nstatic int c2c_width(struct perf_hpp_fmt *fmt,\n\t\t     struct perf_hpp *hpp __maybe_unused,\n\t\t     struct hists *hists)\n{\n\tstruct c2c_fmt *c2c_fmt;\n\tstruct c2c_dimension *dim;\n\n\tc2c_fmt = container_of(fmt, struct c2c_fmt, fmt);\n\tdim = c2c_fmt->dim;\n\n\tif (dim == &dim_symbol || dim == &dim_srcline)\n\t\treturn symbol_width(hists, dim->se);\n\n\treturn dim->se ? hists__col_len(hists, dim->se->se_width_idx) :\n\t\t\t c2c_fmt->dim->width;\n}\n\nstatic int c2c_header(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t      struct hists *hists, int line, int *span)\n{\n\tstruct perf_hpp_list *hpp_list = hists->hpp_list;\n\tstruct c2c_fmt *c2c_fmt;\n\tstruct c2c_dimension *dim;\n\tconst char *text = NULL;\n\tint width = c2c_width(fmt, hpp, hists);\n\n\tc2c_fmt = container_of(fmt, struct c2c_fmt, fmt);\n\tdim = c2c_fmt->dim;\n\n\tif (dim->se) {\n\t\ttext = dim->header.line[line].text;\n\t\t \n\t\tif (!text && (line == hpp_list->nr_header_lines - 1))\n\t\t\ttext = dim->se->se_header;\n\t} else {\n\t\ttext = dim->header.line[line].text;\n\n\t\tif (*span) {\n\t\t\t(*span)--;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t*span = dim->header.line[line].span;\n\t\t}\n\t}\n\n\tif (text == NULL)\n\t\ttext = \"\";\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, text);\n}\n\n#define HEX_STR(__s, __v)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tscnprintf(__s, sizeof(__s), \"0x%\" PRIx64, __v);\t\\\n\t__s;\t\t\t\t\t\t\\\n})\n\nstatic int64_t\ndcacheline_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t       struct hist_entry *left, struct hist_entry *right)\n{\n\treturn sort__dcacheline_cmp(left, right);\n}\n\nstatic int dcacheline_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t    struct hist_entry *he)\n{\n\tuint64_t addr = 0;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tchar buf[20];\n\n\tif (he->mem_info)\n\t\taddr = cl_address(he->mem_info->daddr.addr, chk_double_cl);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, HEX_STR(buf, addr));\n}\n\nstatic int\ndcacheline_node_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t      struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\tif (WARN_ON_ONCE(!c2c_he->nodestr))\n\t\treturn 0;\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, c2c_he->nodestr);\n}\n\nstatic int\ndcacheline_node_count(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t      struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\treturn scnprintf(hpp->buf, hpp->size, \"%*lu\", width, c2c_he->paddr_cnt);\n}\n\nstatic int offset_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\tstruct hist_entry *he)\n{\n\tuint64_t addr = 0;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tchar buf[20];\n\n\tif (he->mem_info)\n\t\taddr = cl_offset(he->mem_info->daddr.al_addr, chk_double_cl);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, HEX_STR(buf, addr));\n}\n\nstatic int64_t\noffset_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t   struct hist_entry *left, struct hist_entry *right)\n{\n\tuint64_t l = 0, r = 0;\n\n\tif (left->mem_info)\n\t\tl = cl_offset(left->mem_info->daddr.addr, chk_double_cl);\n\n\tif (right->mem_info)\n\t\tr = cl_offset(right->mem_info->daddr.addr, chk_double_cl);\n\n\treturn (int64_t)(r - l);\n}\n\nstatic int\niaddr_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t    struct hist_entry *he)\n{\n\tuint64_t addr = 0;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tchar buf[20];\n\n\tif (he->mem_info)\n\t\taddr = he->mem_info->iaddr.addr;\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, HEX_STR(buf, addr));\n}\n\nstatic int64_t\niaddr_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t  struct hist_entry *left, struct hist_entry *right)\n{\n\treturn sort__iaddr_cmp(left, right);\n}\n\nstatic int\ntot_hitm_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t       struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tunsigned int tot_hitm;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\ttot_hitm = c2c_he->stats.lcl_hitm + c2c_he->stats.rmt_hitm;\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*u\", width, tot_hitm);\n}\n\nstatic int64_t\ntot_hitm_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t     struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct c2c_hist_entry *c2c_left;\n\tstruct c2c_hist_entry *c2c_right;\n\tuint64_t tot_hitm_left;\n\tuint64_t tot_hitm_right;\n\n\tc2c_left  = container_of(left, struct c2c_hist_entry, he);\n\tc2c_right = container_of(right, struct c2c_hist_entry, he);\n\n\ttot_hitm_left  = c2c_left->stats.lcl_hitm + c2c_left->stats.rmt_hitm;\n\ttot_hitm_right = c2c_right->stats.lcl_hitm + c2c_right->stats.rmt_hitm;\n\n\treturn tot_hitm_left - tot_hitm_right;\n}\n\n#define STAT_FN_ENTRY(__f)\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\\\n__f ## _entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\t\\\n\t      struct hist_entry *he)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct c2c_hist_entry *c2c_he;\t\t\t\t\\\n\tint width = c2c_width(fmt, hpp, he->hists);\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\t\\\n\treturn scnprintf(hpp->buf, hpp->size, \"%*u\", width,\t\\\n\t\t\t c2c_he->stats.__f);\t\t\t\\\n}\n\n#define STAT_FN_CMP(__f)\t\t\t\t\t\t\\\nstatic int64_t\t\t\t\t\t\t\t\t\\\n__f ## _cmp(struct perf_hpp_fmt *fmt __maybe_unused,\t\t\t\\\n\t    struct hist_entry *left, struct hist_entry *right)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct c2c_hist_entry *c2c_left, *c2c_right;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tc2c_left  = container_of(left, struct c2c_hist_entry, he);\t\\\n\tc2c_right = container_of(right, struct c2c_hist_entry, he);\t\\\n\treturn (uint64_t) c2c_left->stats.__f -\t\t\t\t\\\n\t       (uint64_t) c2c_right->stats.__f;\t\t\t\t\\\n}\n\n#define STAT_FN(__f)\t\t\\\n\tSTAT_FN_ENTRY(__f)\t\\\n\tSTAT_FN_CMP(__f)\n\nSTAT_FN(rmt_hitm)\nSTAT_FN(lcl_hitm)\nSTAT_FN(rmt_peer)\nSTAT_FN(lcl_peer)\nSTAT_FN(tot_peer)\nSTAT_FN(store)\nSTAT_FN(st_l1hit)\nSTAT_FN(st_l1miss)\nSTAT_FN(st_na)\nSTAT_FN(ld_fbhit)\nSTAT_FN(ld_l1hit)\nSTAT_FN(ld_l2hit)\nSTAT_FN(ld_llchit)\nSTAT_FN(rmt_hit)\n\nstatic uint64_t get_load_llc_misses(struct c2c_stats *stats)\n{\n\treturn stats->lcl_dram +\n\t       stats->rmt_dram +\n\t       stats->rmt_hitm +\n\t       stats->rmt_hit;\n}\n\nstatic uint64_t get_load_cache_hits(struct c2c_stats *stats)\n{\n\treturn stats->ld_fbhit +\n\t       stats->ld_l1hit +\n\t       stats->ld_l2hit +\n\t       stats->ld_llchit +\n\t       stats->lcl_hitm;\n}\n\nstatic uint64_t get_stores(struct c2c_stats *stats)\n{\n\treturn stats->st_l1hit +\n\t       stats->st_l1miss +\n\t       stats->st_na;\n}\n\nstatic uint64_t total_records(struct c2c_stats *stats)\n{\n\treturn get_load_llc_misses(stats) +\n\t       get_load_cache_hits(stats) +\n\t       get_stores(stats);\n}\n\nstatic int\ntot_recs_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\tstruct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tuint64_t tot_recs;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\ttot_recs = total_records(&c2c_he->stats);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*\" PRIu64, width, tot_recs);\n}\n\nstatic int64_t\ntot_recs_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t     struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct c2c_hist_entry *c2c_left;\n\tstruct c2c_hist_entry *c2c_right;\n\tuint64_t tot_recs_left;\n\tuint64_t tot_recs_right;\n\n\tc2c_left  = container_of(left, struct c2c_hist_entry, he);\n\tc2c_right = container_of(right, struct c2c_hist_entry, he);\n\n\ttot_recs_left  = total_records(&c2c_left->stats);\n\ttot_recs_right = total_records(&c2c_right->stats);\n\n\treturn tot_recs_left - tot_recs_right;\n}\n\nstatic uint64_t total_loads(struct c2c_stats *stats)\n{\n\treturn get_load_llc_misses(stats) +\n\t       get_load_cache_hits(stats);\n}\n\nstatic int\ntot_loads_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\tstruct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tuint64_t tot_recs;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\ttot_recs = total_loads(&c2c_he->stats);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*\" PRIu64, width, tot_recs);\n}\n\nstatic int64_t\ntot_loads_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t      struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct c2c_hist_entry *c2c_left;\n\tstruct c2c_hist_entry *c2c_right;\n\tuint64_t tot_recs_left;\n\tuint64_t tot_recs_right;\n\n\tc2c_left  = container_of(left, struct c2c_hist_entry, he);\n\tc2c_right = container_of(right, struct c2c_hist_entry, he);\n\n\ttot_recs_left  = total_loads(&c2c_left->stats);\n\ttot_recs_right = total_loads(&c2c_right->stats);\n\n\treturn tot_recs_left - tot_recs_right;\n}\n\ntypedef double (get_percent_cb)(struct c2c_hist_entry *);\n\nstatic int\npercent_color(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t      struct hist_entry *he, get_percent_cb get_percent)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tdouble per;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\tper = get_percent(c2c_he);\n\n#ifdef HAVE_SLANG_SUPPORT\n\tif (use_browser)\n\t\treturn __hpp__slsmg_color_printf(hpp, \"%*.2f%%\", width - 1, per);\n#endif\n\treturn hpp_color_scnprintf(hpp, \"%*.2f%%\", width - 1, per);\n}\n\nstatic double percent_costly_snoop(struct c2c_hist_entry *c2c_he)\n{\n\tstruct c2c_hists *hists;\n\tstruct c2c_stats *stats;\n\tstruct c2c_stats *total;\n\tint tot = 0, st = 0;\n\tdouble p;\n\n\thists = container_of(c2c_he->he.hists, struct c2c_hists, hists);\n\tstats = &c2c_he->stats;\n\ttotal = &hists->stats;\n\n\tswitch (c2c.display) {\n\tcase DISPLAY_RMT_HITM:\n\t\tst  = stats->rmt_hitm;\n\t\ttot = total->rmt_hitm;\n\t\tbreak;\n\tcase DISPLAY_LCL_HITM:\n\t\tst  = stats->lcl_hitm;\n\t\ttot = total->lcl_hitm;\n\t\tbreak;\n\tcase DISPLAY_TOT_HITM:\n\t\tst  = stats->tot_hitm;\n\t\ttot = total->tot_hitm;\n\t\tbreak;\n\tcase DISPLAY_SNP_PEER:\n\t\tst  = stats->tot_peer;\n\t\ttot = total->tot_peer;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tp = tot ? (double) st / tot : 0;\n\n\treturn 100 * p;\n}\n\n#define PERC_STR(__s, __v)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tscnprintf(__s, sizeof(__s), \"%.2F%%\", __v);\t\\\n\t__s;\t\t\t\t\t\t\\\n})\n\nstatic int\npercent_costly_snoop_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t   struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tchar buf[10];\n\tdouble per;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\tper = percent_costly_snoop(c2c_he);\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int\npercent_costly_snoop_color(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t   struct hist_entry *he)\n{\n\treturn percent_color(fmt, hpp, he, percent_costly_snoop);\n}\n\nstatic int64_t\npercent_costly_snoop_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t struct hist_entry *left, struct hist_entry *right)\n{\n\tstruct c2c_hist_entry *c2c_left;\n\tstruct c2c_hist_entry *c2c_right;\n\tdouble per_left;\n\tdouble per_right;\n\n\tc2c_left  = container_of(left, struct c2c_hist_entry, he);\n\tc2c_right = container_of(right, struct c2c_hist_entry, he);\n\n\tper_left  = percent_costly_snoop(c2c_left);\n\tper_right = percent_costly_snoop(c2c_right);\n\n\treturn per_left - per_right;\n}\n\nstatic struct c2c_stats *he_stats(struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\treturn &c2c_he->stats;\n}\n\nstatic struct c2c_stats *total_stats(struct hist_entry *he)\n{\n\tstruct c2c_hists *hists;\n\n\thists = container_of(he->hists, struct c2c_hists, hists);\n\treturn &hists->stats;\n}\n\nstatic double percent(u32 st, u32 tot)\n{\n\treturn tot ? 100. * (double) st / (double) tot : 0;\n}\n\n#define PERCENT(__h, __f) percent(he_stats(__h)->__f, total_stats(__h)->__f)\n\n#define PERCENT_FN(__f)\t\t\t\t\t\t\t\t\\\nstatic double percent_ ## __f(struct c2c_hist_entry *c2c_he)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct c2c_hists *hists;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\thists = container_of(c2c_he->he.hists, struct c2c_hists, hists);\t\\\n\treturn percent(c2c_he->stats.__f, hists->stats.__f);\t\t\t\\\n}\n\nPERCENT_FN(rmt_hitm)\nPERCENT_FN(lcl_hitm)\nPERCENT_FN(rmt_peer)\nPERCENT_FN(lcl_peer)\nPERCENT_FN(st_l1hit)\nPERCENT_FN(st_l1miss)\nPERCENT_FN(st_na)\n\nstatic int\npercent_rmt_hitm_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tdouble per = PERCENT(he, rmt_hitm);\n\tchar buf[10];\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int\npercent_rmt_hitm_color(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he)\n{\n\treturn percent_color(fmt, hpp, he, percent_rmt_hitm);\n}\n\nstatic int64_t\npercent_rmt_hitm_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t     struct hist_entry *left, struct hist_entry *right)\n{\n\tdouble per_left;\n\tdouble per_right;\n\n\tper_left  = PERCENT(left, rmt_hitm);\n\tper_right = PERCENT(right, rmt_hitm);\n\n\treturn per_left - per_right;\n}\n\nstatic int\npercent_lcl_hitm_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tdouble per = PERCENT(he, lcl_hitm);\n\tchar buf[10];\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int\npercent_lcl_hitm_color(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he)\n{\n\treturn percent_color(fmt, hpp, he, percent_lcl_hitm);\n}\n\nstatic int64_t\npercent_lcl_hitm_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t     struct hist_entry *left, struct hist_entry *right)\n{\n\tdouble per_left;\n\tdouble per_right;\n\n\tper_left  = PERCENT(left, lcl_hitm);\n\tper_right = PERCENT(right, lcl_hitm);\n\n\treturn per_left - per_right;\n}\n\nstatic int\npercent_lcl_peer_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tdouble per = PERCENT(he, lcl_peer);\n\tchar buf[10];\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int\npercent_lcl_peer_color(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he)\n{\n\treturn percent_color(fmt, hpp, he, percent_lcl_peer);\n}\n\nstatic int64_t\npercent_lcl_peer_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t     struct hist_entry *left, struct hist_entry *right)\n{\n\tdouble per_left;\n\tdouble per_right;\n\n\tper_left  = PERCENT(left, lcl_peer);\n\tper_right = PERCENT(right, lcl_peer);\n\n\treturn per_left - per_right;\n}\n\nstatic int\npercent_rmt_peer_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tdouble per = PERCENT(he, rmt_peer);\n\tchar buf[10];\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int\npercent_rmt_peer_color(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t       struct hist_entry *he)\n{\n\treturn percent_color(fmt, hpp, he, percent_rmt_peer);\n}\n\nstatic int64_t\npercent_rmt_peer_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t     struct hist_entry *left, struct hist_entry *right)\n{\n\tdouble per_left;\n\tdouble per_right;\n\n\tper_left  = PERCENT(left, rmt_peer);\n\tper_right = PERCENT(right, rmt_peer);\n\n\treturn per_left - per_right;\n}\n\nstatic int\npercent_stores_l1hit_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t   struct hist_entry *he)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tdouble per = PERCENT(he, st_l1hit);\n\tchar buf[10];\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int\npercent_stores_l1hit_color(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t   struct hist_entry *he)\n{\n\treturn percent_color(fmt, hpp, he, percent_st_l1hit);\n}\n\nstatic int64_t\npercent_stores_l1hit_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\tstruct hist_entry *left, struct hist_entry *right)\n{\n\tdouble per_left;\n\tdouble per_right;\n\n\tper_left  = PERCENT(left, st_l1hit);\n\tper_right = PERCENT(right, st_l1hit);\n\n\treturn per_left - per_right;\n}\n\nstatic int\npercent_stores_l1miss_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t   struct hist_entry *he)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tdouble per = PERCENT(he, st_l1miss);\n\tchar buf[10];\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int\npercent_stores_l1miss_color(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t    struct hist_entry *he)\n{\n\treturn percent_color(fmt, hpp, he, percent_st_l1miss);\n}\n\nstatic int64_t\npercent_stores_l1miss_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t  struct hist_entry *left, struct hist_entry *right)\n{\n\tdouble per_left;\n\tdouble per_right;\n\n\tper_left  = PERCENT(left, st_l1miss);\n\tper_right = PERCENT(right, st_l1miss);\n\n\treturn per_left - per_right;\n}\n\nstatic int\npercent_stores_na_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\tstruct hist_entry *he)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tdouble per = PERCENT(he, st_na);\n\tchar buf[10];\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int\npercent_stores_na_color(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\tstruct hist_entry *he)\n{\n\treturn percent_color(fmt, hpp, he, percent_st_na);\n}\n\nstatic int64_t\npercent_stores_na_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t      struct hist_entry *left, struct hist_entry *right)\n{\n\tdouble per_left;\n\tdouble per_right;\n\n\tper_left  = PERCENT(left, st_na);\n\tper_right = PERCENT(right, st_na);\n\n\treturn per_left - per_right;\n}\n\nSTAT_FN(lcl_dram)\nSTAT_FN(rmt_dram)\n\nstatic int\npid_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t  struct hist_entry *he)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*d\", width, thread__pid(he->thread));\n}\n\nstatic int64_t\npid_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\tstruct hist_entry *left, struct hist_entry *right)\n{\n\treturn thread__pid(left->thread) - thread__pid(right->thread);\n}\n\nstatic int64_t\nempty_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t  struct hist_entry *left __maybe_unused,\n\t  struct hist_entry *right __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int display_metrics(struct perf_hpp *hpp, u32 val, u32 sum)\n{\n\tint ret;\n\n\tif (sum != 0)\n\t\tret = scnprintf(hpp->buf, hpp->size, \"%5.1f%% \",\n\t\t\t\tpercent(val, sum));\n\telse\n\t\tret = scnprintf(hpp->buf, hpp->size, \"%6s \", \"n/a\");\n\n\treturn ret;\n}\n\nstatic int\nnode_entry(struct perf_hpp_fmt *fmt __maybe_unused, struct perf_hpp *hpp,\n\t   struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tbool first = true;\n\tint node;\n\tint ret = 0;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\n\tfor (node = 0; node < c2c.nodes_cnt; node++) {\n\t\tDECLARE_BITMAP(set, c2c.cpus_cnt);\n\n\t\tbitmap_zero(set, c2c.cpus_cnt);\n\t\tbitmap_and(set, c2c_he->cpuset, c2c.nodes[node], c2c.cpus_cnt);\n\n\t\tif (bitmap_empty(set, c2c.cpus_cnt)) {\n\t\t\tif (c2c.node_info == 1) {\n\t\t\t\tret = scnprintf(hpp->buf, hpp->size, \"%21s\", \" \");\n\t\t\t\tadvance_hpp(hpp, ret);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!first) {\n\t\t\tret = scnprintf(hpp->buf, hpp->size, \" \");\n\t\t\tadvance_hpp(hpp, ret);\n\t\t}\n\n\t\tswitch (c2c.node_info) {\n\t\tcase 0:\n\t\t\tret = scnprintf(hpp->buf, hpp->size, \"%2d\", node);\n\t\t\tadvance_hpp(hpp, ret);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t{\n\t\t\tint num = bitmap_weight(set, c2c.cpus_cnt);\n\t\t\tstruct c2c_stats *stats = &c2c_he->node_stats[node];\n\n\t\t\tret = scnprintf(hpp->buf, hpp->size, \"%2d{%2d \", node, num);\n\t\t\tadvance_hpp(hpp, ret);\n\n\t\t\tswitch (c2c.display) {\n\t\t\tcase DISPLAY_RMT_HITM:\n\t\t\t\tret = display_metrics(hpp, stats->rmt_hitm,\n\t\t\t\t\t\t      c2c_he->stats.rmt_hitm);\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY_LCL_HITM:\n\t\t\t\tret = display_metrics(hpp, stats->lcl_hitm,\n\t\t\t\t\t\t      c2c_he->stats.lcl_hitm);\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY_TOT_HITM:\n\t\t\t\tret = display_metrics(hpp, stats->tot_hitm,\n\t\t\t\t\t\t      c2c_he->stats.tot_hitm);\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY_SNP_PEER:\n\t\t\t\tret = display_metrics(hpp, stats->tot_peer,\n\t\t\t\t\t\t      c2c_he->stats.tot_peer);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tadvance_hpp(hpp, ret);\n\n\t\t\tif (c2c_he->stats.store > 0) {\n\t\t\t\tret = scnprintf(hpp->buf, hpp->size, \"%5.1f%%}\",\n\t\t\t\t\t\tpercent(stats->store, c2c_he->stats.store));\n\t\t\t} else {\n\t\t\t\tret = scnprintf(hpp->buf, hpp->size, \"%6s}\", \"n/a\");\n\t\t\t}\n\n\t\t\tadvance_hpp(hpp, ret);\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t\tret = scnprintf(hpp->buf, hpp->size, \"%2d{\", node);\n\t\t\tadvance_hpp(hpp, ret);\n\n\t\t\tret = bitmap_scnprintf(set, c2c.cpus_cnt, hpp->buf, hpp->size);\n\t\t\tadvance_hpp(hpp, ret);\n\n\t\t\tret = scnprintf(hpp->buf, hpp->size, \"}\");\n\t\t\tadvance_hpp(hpp, ret);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tfirst = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmean_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t   struct hist_entry *he, double mean)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tchar buf[10];\n\n\tscnprintf(buf, 10, \"%6.0f\", mean);\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, buf);\n}\n\n#define MEAN_ENTRY(__func, __val)\t\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\t\\\n__func(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp, struct hist_entry *he)\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct c2c_hist_entry *c2c_he;\t\t\t\t\t\t\\\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\t\t\t\\\n\treturn mean_entry(fmt, hpp, he, avg_stats(&c2c_he->cstats.__val));\t\\\n}\n\nMEAN_ENTRY(mean_rmt_entry,  rmt_hitm);\nMEAN_ENTRY(mean_lcl_entry,  lcl_hitm);\nMEAN_ENTRY(mean_load_entry, load);\nMEAN_ENTRY(mean_rmt_peer_entry, rmt_peer);\nMEAN_ENTRY(mean_lcl_peer_entry, lcl_peer);\n\nstatic int\ncpucnt_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t     struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tchar buf[10];\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\n\tscnprintf(buf, 10, \"%d\", bitmap_weight(c2c_he->cpuset, c2c.cpus_cnt));\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, buf);\n}\n\nstatic int\ncl_idx_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t     struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tint width = c2c_width(fmt, hpp, he->hists);\n\tchar buf[10];\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\n\tscnprintf(buf, 10, \"%u\", c2c_he->cacheline_idx);\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, buf);\n}\n\nstatic int\ncl_idx_empty_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t   struct hist_entry *he)\n{\n\tint width = c2c_width(fmt, hpp, he->hists);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, \"\");\n}\n\n#define HEADER_LOW(__h)\t\t\t\\\n\t{\t\t\t\t\\\n\t\t.line[1] = {\t\t\\\n\t\t\t.text = __h,\t\\\n\t\t},\t\t\t\\\n\t}\n\n#define HEADER_BOTH(__h0, __h1)\t\t\\\n\t{\t\t\t\t\\\n\t\t.line[0] = {\t\t\\\n\t\t\t.text = __h0,\t\\\n\t\t},\t\t\t\\\n\t\t.line[1] = {\t\t\\\n\t\t\t.text = __h1,\t\\\n\t\t},\t\t\t\\\n\t}\n\n#define HEADER_SPAN(__h0, __h1, __s)\t\\\n\t{\t\t\t\t\\\n\t\t.line[0] = {\t\t\\\n\t\t\t.text = __h0,\t\\\n\t\t\t.span = __s,\t\\\n\t\t},\t\t\t\\\n\t\t.line[1] = {\t\t\\\n\t\t\t.text = __h1,\t\\\n\t\t},\t\t\t\\\n\t}\n\n#define HEADER_SPAN_LOW(__h)\t\t\\\n\t{\t\t\t\t\\\n\t\t.line[1] = {\t\t\\\n\t\t\t.text = __h,\t\\\n\t\t},\t\t\t\\\n\t}\n\nstatic struct c2c_dimension dim_dcacheline = {\n\t.header\t\t= HEADER_SPAN(\"--- Cacheline ----\", \"Address\", 2),\n\t.name\t\t= \"dcacheline\",\n\t.cmp\t\t= dcacheline_cmp,\n\t.entry\t\t= dcacheline_entry,\n\t.width\t\t= 18,\n};\n\nstatic struct c2c_dimension dim_dcacheline_node = {\n\t.header\t\t= HEADER_LOW(\"Node\"),\n\t.name\t\t= \"dcacheline_node\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= dcacheline_node_entry,\n\t.width\t\t= 4,\n};\n\nstatic struct c2c_dimension dim_dcacheline_count = {\n\t.header\t\t= HEADER_LOW(\"PA cnt\"),\n\t.name\t\t= \"dcacheline_count\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= dcacheline_node_count,\n\t.width\t\t= 6,\n};\n\nstatic struct c2c_header header_offset_tui = HEADER_SPAN(\"-----\", \"Off\", 2);\n\nstatic struct c2c_dimension dim_offset = {\n\t.header\t\t= HEADER_SPAN(\"--- Data address -\", \"Offset\", 2),\n\t.name\t\t= \"offset\",\n\t.cmp\t\t= offset_cmp,\n\t.entry\t\t= offset_entry,\n\t.width\t\t= 18,\n};\n\nstatic struct c2c_dimension dim_offset_node = {\n\t.header\t\t= HEADER_LOW(\"Node\"),\n\t.name\t\t= \"offset_node\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= dcacheline_node_entry,\n\t.width\t\t= 4,\n};\n\nstatic struct c2c_dimension dim_iaddr = {\n\t.header\t\t= HEADER_LOW(\"Code address\"),\n\t.name\t\t= \"iaddr\",\n\t.cmp\t\t= iaddr_cmp,\n\t.entry\t\t= iaddr_entry,\n\t.width\t\t= 18,\n};\n\nstatic struct c2c_dimension dim_tot_hitm = {\n\t.header\t\t= HEADER_SPAN(\"------- Load Hitm -------\", \"Total\", 2),\n\t.name\t\t= \"tot_hitm\",\n\t.cmp\t\t= tot_hitm_cmp,\n\t.entry\t\t= tot_hitm_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_lcl_hitm = {\n\t.header\t\t= HEADER_SPAN_LOW(\"LclHitm\"),\n\t.name\t\t= \"lcl_hitm\",\n\t.cmp\t\t= lcl_hitm_cmp,\n\t.entry\t\t= lcl_hitm_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_rmt_hitm = {\n\t.header\t\t= HEADER_SPAN_LOW(\"RmtHitm\"),\n\t.name\t\t= \"rmt_hitm\",\n\t.cmp\t\t= rmt_hitm_cmp,\n\t.entry\t\t= rmt_hitm_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_tot_peer = {\n\t.header\t\t= HEADER_SPAN(\"------- Load Peer -------\", \"Total\", 2),\n\t.name\t\t= \"tot_peer\",\n\t.cmp\t\t= tot_peer_cmp,\n\t.entry\t\t= tot_peer_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_lcl_peer = {\n\t.header\t\t= HEADER_SPAN_LOW(\"Local\"),\n\t.name\t\t= \"lcl_peer\",\n\t.cmp\t\t= lcl_peer_cmp,\n\t.entry\t\t= lcl_peer_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_rmt_peer = {\n\t.header\t\t= HEADER_SPAN_LOW(\"Remote\"),\n\t.name\t\t= \"rmt_peer\",\n\t.cmp\t\t= rmt_peer_cmp,\n\t.entry\t\t= rmt_peer_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_cl_rmt_hitm = {\n\t.header\t\t= HEADER_SPAN(\"----- HITM -----\", \"Rmt\", 1),\n\t.name\t\t= \"cl_rmt_hitm\",\n\t.cmp\t\t= rmt_hitm_cmp,\n\t.entry\t\t= rmt_hitm_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_cl_lcl_hitm = {\n\t.header\t\t= HEADER_SPAN_LOW(\"Lcl\"),\n\t.name\t\t= \"cl_lcl_hitm\",\n\t.cmp\t\t= lcl_hitm_cmp,\n\t.entry\t\t= lcl_hitm_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_cl_rmt_peer = {\n\t.header\t\t= HEADER_SPAN(\"----- Peer -----\", \"Rmt\", 1),\n\t.name\t\t= \"cl_rmt_peer\",\n\t.cmp\t\t= rmt_peer_cmp,\n\t.entry\t\t= rmt_peer_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_cl_lcl_peer = {\n\t.header\t\t= HEADER_SPAN_LOW(\"Lcl\"),\n\t.name\t\t= \"cl_lcl_peer\",\n\t.cmp\t\t= lcl_peer_cmp,\n\t.entry\t\t= lcl_peer_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_tot_stores = {\n\t.header\t\t= HEADER_BOTH(\"Total\", \"Stores\"),\n\t.name\t\t= \"tot_stores\",\n\t.cmp\t\t= store_cmp,\n\t.entry\t\t= store_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_stores_l1hit = {\n\t.header\t\t= HEADER_SPAN(\"--------- Stores --------\", \"L1Hit\", 2),\n\t.name\t\t= \"stores_l1hit\",\n\t.cmp\t\t= st_l1hit_cmp,\n\t.entry\t\t= st_l1hit_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_stores_l1miss = {\n\t.header\t\t= HEADER_SPAN_LOW(\"L1Miss\"),\n\t.name\t\t= \"stores_l1miss\",\n\t.cmp\t\t= st_l1miss_cmp,\n\t.entry\t\t= st_l1miss_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_stores_na = {\n\t.header\t\t= HEADER_SPAN_LOW(\"N/A\"),\n\t.name\t\t= \"stores_na\",\n\t.cmp\t\t= st_na_cmp,\n\t.entry\t\t= st_na_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_cl_stores_l1hit = {\n\t.header\t\t= HEADER_SPAN(\"------- Store Refs ------\", \"L1 Hit\", 2),\n\t.name\t\t= \"cl_stores_l1hit\",\n\t.cmp\t\t= st_l1hit_cmp,\n\t.entry\t\t= st_l1hit_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_cl_stores_l1miss = {\n\t.header\t\t= HEADER_SPAN_LOW(\"L1 Miss\"),\n\t.name\t\t= \"cl_stores_l1miss\",\n\t.cmp\t\t= st_l1miss_cmp,\n\t.entry\t\t= st_l1miss_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_cl_stores_na = {\n\t.header\t\t= HEADER_SPAN_LOW(\"N/A\"),\n\t.name\t\t= \"cl_stores_na\",\n\t.cmp\t\t= st_na_cmp,\n\t.entry\t\t= st_na_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_ld_fbhit = {\n\t.header\t\t= HEADER_SPAN(\"----- Core Load Hit -----\", \"FB\", 2),\n\t.name\t\t= \"ld_fbhit\",\n\t.cmp\t\t= ld_fbhit_cmp,\n\t.entry\t\t= ld_fbhit_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_ld_l1hit = {\n\t.header\t\t= HEADER_SPAN_LOW(\"L1\"),\n\t.name\t\t= \"ld_l1hit\",\n\t.cmp\t\t= ld_l1hit_cmp,\n\t.entry\t\t= ld_l1hit_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_ld_l2hit = {\n\t.header\t\t= HEADER_SPAN_LOW(\"L2\"),\n\t.name\t\t= \"ld_l2hit\",\n\t.cmp\t\t= ld_l2hit_cmp,\n\t.entry\t\t= ld_l2hit_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_ld_llchit = {\n\t.header\t\t= HEADER_SPAN(\"- LLC Load Hit --\", \"LclHit\", 1),\n\t.name\t\t= \"ld_lclhit\",\n\t.cmp\t\t= ld_llchit_cmp,\n\t.entry\t\t= ld_llchit_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_ld_rmthit = {\n\t.header\t\t= HEADER_SPAN(\"- RMT Load Hit --\", \"RmtHit\", 1),\n\t.name\t\t= \"ld_rmthit\",\n\t.cmp\t\t= rmt_hit_cmp,\n\t.entry\t\t= rmt_hit_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_tot_recs = {\n\t.header\t\t= HEADER_BOTH(\"Total\", \"records\"),\n\t.name\t\t= \"tot_recs\",\n\t.cmp\t\t= tot_recs_cmp,\n\t.entry\t\t= tot_recs_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_tot_loads = {\n\t.header\t\t= HEADER_BOTH(\"Total\", \"Loads\"),\n\t.name\t\t= \"tot_loads\",\n\t.cmp\t\t= tot_loads_cmp,\n\t.entry\t\t= tot_loads_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_header percent_costly_snoop_header[] = {\n\t[DISPLAY_LCL_HITM] = HEADER_BOTH(\"Lcl\", \"Hitm\"),\n\t[DISPLAY_RMT_HITM] = HEADER_BOTH(\"Rmt\", \"Hitm\"),\n\t[DISPLAY_TOT_HITM] = HEADER_BOTH(\"Tot\", \"Hitm\"),\n\t[DISPLAY_SNP_PEER] = HEADER_BOTH(\"Peer\", \"Snoop\"),\n};\n\nstatic struct c2c_dimension dim_percent_costly_snoop = {\n\t.name\t\t= \"percent_costly_snoop\",\n\t.cmp\t\t= percent_costly_snoop_cmp,\n\t.entry\t\t= percent_costly_snoop_entry,\n\t.color\t\t= percent_costly_snoop_color,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_percent_rmt_hitm = {\n\t.header\t\t= HEADER_SPAN(\"----- HITM -----\", \"RmtHitm\", 1),\n\t.name\t\t= \"percent_rmt_hitm\",\n\t.cmp\t\t= percent_rmt_hitm_cmp,\n\t.entry\t\t= percent_rmt_hitm_entry,\n\t.color\t\t= percent_rmt_hitm_color,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_percent_lcl_hitm = {\n\t.header\t\t= HEADER_SPAN_LOW(\"LclHitm\"),\n\t.name\t\t= \"percent_lcl_hitm\",\n\t.cmp\t\t= percent_lcl_hitm_cmp,\n\t.entry\t\t= percent_lcl_hitm_entry,\n\t.color\t\t= percent_lcl_hitm_color,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_percent_rmt_peer = {\n\t.header\t\t= HEADER_SPAN(\"-- Peer Snoop --\", \"Rmt\", 1),\n\t.name\t\t= \"percent_rmt_peer\",\n\t.cmp\t\t= percent_rmt_peer_cmp,\n\t.entry\t\t= percent_rmt_peer_entry,\n\t.color\t\t= percent_rmt_peer_color,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_percent_lcl_peer = {\n\t.header\t\t= HEADER_SPAN_LOW(\"Lcl\"),\n\t.name\t\t= \"percent_lcl_peer\",\n\t.cmp\t\t= percent_lcl_peer_cmp,\n\t.entry\t\t= percent_lcl_peer_entry,\n\t.color\t\t= percent_lcl_peer_color,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_percent_stores_l1hit = {\n\t.header\t\t= HEADER_SPAN(\"------- Store Refs ------\", \"L1 Hit\", 2),\n\t.name\t\t= \"percent_stores_l1hit\",\n\t.cmp\t\t= percent_stores_l1hit_cmp,\n\t.entry\t\t= percent_stores_l1hit_entry,\n\t.color\t\t= percent_stores_l1hit_color,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_percent_stores_l1miss = {\n\t.header\t\t= HEADER_SPAN_LOW(\"L1 Miss\"),\n\t.name\t\t= \"percent_stores_l1miss\",\n\t.cmp\t\t= percent_stores_l1miss_cmp,\n\t.entry\t\t= percent_stores_l1miss_entry,\n\t.color\t\t= percent_stores_l1miss_color,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_percent_stores_na = {\n\t.header\t\t= HEADER_SPAN_LOW(\"N/A\"),\n\t.name\t\t= \"percent_stores_na\",\n\t.cmp\t\t= percent_stores_na_cmp,\n\t.entry\t\t= percent_stores_na_entry,\n\t.color\t\t= percent_stores_na_color,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_dram_lcl = {\n\t.header\t\t= HEADER_SPAN(\"--- Load Dram ----\", \"Lcl\", 1),\n\t.name\t\t= \"dram_lcl\",\n\t.cmp\t\t= lcl_dram_cmp,\n\t.entry\t\t= lcl_dram_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_dram_rmt = {\n\t.header\t\t= HEADER_SPAN_LOW(\"Rmt\"),\n\t.name\t\t= \"dram_rmt\",\n\t.cmp\t\t= rmt_dram_cmp,\n\t.entry\t\t= rmt_dram_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_pid = {\n\t.header\t\t= HEADER_LOW(\"Pid\"),\n\t.name\t\t= \"pid\",\n\t.cmp\t\t= pid_cmp,\n\t.entry\t\t= pid_entry,\n\t.width\t\t= 7,\n};\n\nstatic struct c2c_dimension dim_tid = {\n\t.header\t\t= HEADER_LOW(\"Tid\"),\n\t.name\t\t= \"tid\",\n\t.se\t\t= &sort_thread,\n};\n\nstatic struct c2c_dimension dim_symbol = {\n\t.name\t\t= \"symbol\",\n\t.se\t\t= &sort_sym,\n};\n\nstatic struct c2c_dimension dim_dso = {\n\t.header\t\t= HEADER_BOTH(\"Shared\", \"Object\"),\n\t.name\t\t= \"dso\",\n\t.se\t\t= &sort_dso,\n};\n\nstatic struct c2c_dimension dim_node = {\n\t.name\t\t= \"node\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= node_entry,\n\t.width\t\t= 4,\n};\n\nstatic struct c2c_dimension dim_mean_rmt = {\n\t.header\t\t= HEADER_SPAN(\"---------- cycles ----------\", \"rmt hitm\", 2),\n\t.name\t\t= \"mean_rmt\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= mean_rmt_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_mean_lcl = {\n\t.header\t\t= HEADER_SPAN_LOW(\"lcl hitm\"),\n\t.name\t\t= \"mean_lcl\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= mean_lcl_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_mean_load = {\n\t.header\t\t= HEADER_SPAN_LOW(\"load\"),\n\t.name\t\t= \"mean_load\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= mean_load_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_mean_rmt_peer = {\n\t.header\t\t= HEADER_SPAN(\"---------- cycles ----------\", \"rmt peer\", 2),\n\t.name\t\t= \"mean_rmt_peer\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= mean_rmt_peer_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_mean_lcl_peer = {\n\t.header\t\t= HEADER_SPAN_LOW(\"lcl peer\"),\n\t.name\t\t= \"mean_lcl_peer\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= mean_lcl_peer_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_cpucnt = {\n\t.header\t\t= HEADER_BOTH(\"cpu\", \"cnt\"),\n\t.name\t\t= \"cpucnt\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= cpucnt_entry,\n\t.width\t\t= 8,\n};\n\nstatic struct c2c_dimension dim_srcline = {\n\t.name\t\t= \"cl_srcline\",\n\t.se\t\t= &sort_srcline,\n};\n\nstatic struct c2c_dimension dim_dcacheline_idx = {\n\t.header\t\t= HEADER_LOW(\"Index\"),\n\t.name\t\t= \"cl_idx\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= cl_idx_entry,\n\t.width\t\t= 5,\n};\n\nstatic struct c2c_dimension dim_dcacheline_num = {\n\t.header\t\t= HEADER_LOW(\"Num\"),\n\t.name\t\t= \"cl_num\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= cl_idx_entry,\n\t.width\t\t= 5,\n};\n\nstatic struct c2c_dimension dim_dcacheline_num_empty = {\n\t.header\t\t= HEADER_LOW(\"Num\"),\n\t.name\t\t= \"cl_num_empty\",\n\t.cmp\t\t= empty_cmp,\n\t.entry\t\t= cl_idx_empty_entry,\n\t.width\t\t= 5,\n};\n\nstatic struct c2c_dimension *dimensions[] = {\n\t&dim_dcacheline,\n\t&dim_dcacheline_node,\n\t&dim_dcacheline_count,\n\t&dim_offset,\n\t&dim_offset_node,\n\t&dim_iaddr,\n\t&dim_tot_hitm,\n\t&dim_lcl_hitm,\n\t&dim_rmt_hitm,\n\t&dim_tot_peer,\n\t&dim_lcl_peer,\n\t&dim_rmt_peer,\n\t&dim_cl_lcl_hitm,\n\t&dim_cl_rmt_hitm,\n\t&dim_cl_lcl_peer,\n\t&dim_cl_rmt_peer,\n\t&dim_tot_stores,\n\t&dim_stores_l1hit,\n\t&dim_stores_l1miss,\n\t&dim_stores_na,\n\t&dim_cl_stores_l1hit,\n\t&dim_cl_stores_l1miss,\n\t&dim_cl_stores_na,\n\t&dim_ld_fbhit,\n\t&dim_ld_l1hit,\n\t&dim_ld_l2hit,\n\t&dim_ld_llchit,\n\t&dim_ld_rmthit,\n\t&dim_tot_recs,\n\t&dim_tot_loads,\n\t&dim_percent_costly_snoop,\n\t&dim_percent_rmt_hitm,\n\t&dim_percent_lcl_hitm,\n\t&dim_percent_rmt_peer,\n\t&dim_percent_lcl_peer,\n\t&dim_percent_stores_l1hit,\n\t&dim_percent_stores_l1miss,\n\t&dim_percent_stores_na,\n\t&dim_dram_lcl,\n\t&dim_dram_rmt,\n\t&dim_pid,\n\t&dim_tid,\n\t&dim_symbol,\n\t&dim_dso,\n\t&dim_node,\n\t&dim_mean_rmt,\n\t&dim_mean_lcl,\n\t&dim_mean_rmt_peer,\n\t&dim_mean_lcl_peer,\n\t&dim_mean_load,\n\t&dim_cpucnt,\n\t&dim_srcline,\n\t&dim_dcacheline_idx,\n\t&dim_dcacheline_num,\n\t&dim_dcacheline_num_empty,\n\tNULL,\n};\n\nstatic void fmt_free(struct perf_hpp_fmt *fmt)\n{\n\tstruct c2c_fmt *c2c_fmt;\n\n\tc2c_fmt = container_of(fmt, struct c2c_fmt, fmt);\n\tfree(c2c_fmt);\n}\n\nstatic bool fmt_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)\n{\n\tstruct c2c_fmt *c2c_a = container_of(a, struct c2c_fmt, fmt);\n\tstruct c2c_fmt *c2c_b = container_of(b, struct c2c_fmt, fmt);\n\n\treturn c2c_a->dim == c2c_b->dim;\n}\n\nstatic struct c2c_dimension *get_dimension(const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 0; dimensions[i]; i++) {\n\t\tstruct c2c_dimension *dim = dimensions[i];\n\n\t\tif (!strcmp(dim->name, name))\n\t\t\treturn dim;\n\t}\n\n\treturn NULL;\n}\n\nstatic int c2c_se_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\tstruct hist_entry *he)\n{\n\tstruct c2c_fmt *c2c_fmt = container_of(fmt, struct c2c_fmt, fmt);\n\tstruct c2c_dimension *dim = c2c_fmt->dim;\n\tsize_t len = fmt->user_len;\n\n\tif (!len) {\n\t\tlen = hists__col_len(he->hists, dim->se->se_width_idx);\n\n\t\tif (dim == &dim_symbol || dim == &dim_srcline)\n\t\t\tlen = symbol_width(he->hists, dim->se);\n\t}\n\n\treturn dim->se->se_snprintf(he, hpp->buf, hpp->size, len);\n}\n\nstatic int64_t c2c_se_cmp(struct perf_hpp_fmt *fmt,\n\t\t\t  struct hist_entry *a, struct hist_entry *b)\n{\n\tstruct c2c_fmt *c2c_fmt = container_of(fmt, struct c2c_fmt, fmt);\n\tstruct c2c_dimension *dim = c2c_fmt->dim;\n\n\treturn dim->se->se_cmp(a, b);\n}\n\nstatic int64_t c2c_se_collapse(struct perf_hpp_fmt *fmt,\n\t\t\t       struct hist_entry *a, struct hist_entry *b)\n{\n\tstruct c2c_fmt *c2c_fmt = container_of(fmt, struct c2c_fmt, fmt);\n\tstruct c2c_dimension *dim = c2c_fmt->dim;\n\tint64_t (*collapse_fn)(struct hist_entry *, struct hist_entry *);\n\n\tcollapse_fn = dim->se->se_collapse ?: dim->se->se_cmp;\n\treturn collapse_fn(a, b);\n}\n\nstatic struct c2c_fmt *get_format(const char *name)\n{\n\tstruct c2c_dimension *dim = get_dimension(name);\n\tstruct c2c_fmt *c2c_fmt;\n\tstruct perf_hpp_fmt *fmt;\n\n\tif (!dim)\n\t\treturn NULL;\n\n\tc2c_fmt = zalloc(sizeof(*c2c_fmt));\n\tif (!c2c_fmt)\n\t\treturn NULL;\n\n\tc2c_fmt->dim = dim;\n\n\tfmt = &c2c_fmt->fmt;\n\tINIT_LIST_HEAD(&fmt->list);\n\tINIT_LIST_HEAD(&fmt->sort_list);\n\n\tfmt->cmp\t= dim->se ? c2c_se_cmp   : dim->cmp;\n\tfmt->sort\t= dim->se ? c2c_se_cmp   : dim->cmp;\n\tfmt->color\t= dim->se ? NULL\t : dim->color;\n\tfmt->entry\t= dim->se ? c2c_se_entry : dim->entry;\n\tfmt->header\t= c2c_header;\n\tfmt->width\t= c2c_width;\n\tfmt->collapse\t= dim->se ? c2c_se_collapse : dim->cmp;\n\tfmt->equal\t= fmt_equal;\n\tfmt->free\t= fmt_free;\n\n\treturn c2c_fmt;\n}\n\nstatic int c2c_hists__init_output(struct perf_hpp_list *hpp_list, char *name)\n{\n\tstruct c2c_fmt *c2c_fmt = get_format(name);\n\n\tif (!c2c_fmt) {\n\t\treset_dimensions();\n\t\treturn output_field_add(hpp_list, name);\n\t}\n\n\tperf_hpp_list__column_register(hpp_list, &c2c_fmt->fmt);\n\treturn 0;\n}\n\nstatic int c2c_hists__init_sort(struct perf_hpp_list *hpp_list, char *name)\n{\n\tstruct c2c_fmt *c2c_fmt = get_format(name);\n\tstruct c2c_dimension *dim;\n\n\tif (!c2c_fmt) {\n\t\treset_dimensions();\n\t\treturn sort_dimension__add(hpp_list, name, NULL, 0);\n\t}\n\n\tdim = c2c_fmt->dim;\n\tif (dim == &dim_dso)\n\t\thpp_list->dso = 1;\n\n\tperf_hpp_list__register_sort_field(hpp_list, &c2c_fmt->fmt);\n\treturn 0;\n}\n\n#define PARSE_LIST(_list, _fn)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\tchar *tmp, *tok;\t\t\t\t\t\t\\\n\t\tret = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (!_list)\t\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (tok = strtok_r((char *)_list, \", \", &tmp);\t\t\t\\\n\t\t\t\ttok; tok = strtok_r(NULL, \", \", &tmp)) {\t\\\n\t\t\tret = _fn(hpp_list, tok);\t\t\t\t\\\n\t\t\tif (ret == -EINVAL) {\t\t\t\t\t\\\n\t\t\t\tpr_err(\"Invalid --fields key: `%s'\", tok);\t\\\n\t\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t} else if (ret == -ESRCH) {\t\t\t\t\\\n\t\t\t\tpr_err(\"Unknown --fields key: `%s'\", tok);\t\\\n\t\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int hpp_list__parse(struct perf_hpp_list *hpp_list,\n\t\t\t   const char *output_,\n\t\t\t   const char *sort_)\n{\n\tchar *output = output_ ? strdup(output_) : NULL;\n\tchar *sort   = sort_   ? strdup(sort_) : NULL;\n\tint ret;\n\n\tPARSE_LIST(output, c2c_hists__init_output);\n\tPARSE_LIST(sort,   c2c_hists__init_sort);\n\n\t \n\tperf_hpp__setup_output_field(hpp_list);\n\n\t \n\n#if 0\n\t \n\tperf_hpp__append_sort_keys(&hists->list);\n#endif\n\n\tfree(output);\n\tfree(sort);\n\treturn ret;\n}\n\nstatic int c2c_hists__init(struct c2c_hists *hists,\n\t\t\t   const char *sort,\n\t\t\t   int nr_header_lines)\n{\n\t__hists__init(&hists->hists, &hists->list);\n\n\t \n\tperf_hpp_list__init(&hists->list);\n\n\t \n\thists->list.nr_header_lines = nr_header_lines;\n\n\treturn hpp_list__parse(&hists->list, NULL, sort);\n}\n\nstatic int c2c_hists__reinit(struct c2c_hists *c2c_hists,\n\t\t\t     const char *output,\n\t\t\t     const char *sort)\n{\n\tperf_hpp__reset_output_field(&c2c_hists->list);\n\treturn hpp_list__parse(&c2c_hists->list, output, sort);\n}\n\n#define DISPLAY_LINE_LIMIT  0.001\n\nstatic u8 filter_display(u32 val, u32 sum)\n{\n\tif (sum == 0 || ((double)val / sum) < DISPLAY_LINE_LIMIT)\n\t\treturn HIST_FILTER__C2C;\n\n\treturn 0;\n}\n\nstatic bool he__display(struct hist_entry *he, struct c2c_stats *stats)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\n\tif (c2c.show_all)\n\t\treturn true;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\n\tswitch (c2c.display) {\n\tcase DISPLAY_LCL_HITM:\n\t\the->filtered = filter_display(c2c_he->stats.lcl_hitm,\n\t\t\t\t\t      stats->lcl_hitm);\n\t\tbreak;\n\tcase DISPLAY_RMT_HITM:\n\t\the->filtered = filter_display(c2c_he->stats.rmt_hitm,\n\t\t\t\t\t      stats->rmt_hitm);\n\t\tbreak;\n\tcase DISPLAY_TOT_HITM:\n\t\the->filtered = filter_display(c2c_he->stats.tot_hitm,\n\t\t\t\t\t      stats->tot_hitm);\n\t\tbreak;\n\tcase DISPLAY_SNP_PEER:\n\t\the->filtered = filter_display(c2c_he->stats.tot_peer,\n\t\t\t\t\t      stats->tot_peer);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn he->filtered == 0;\n}\n\nstatic inline bool is_valid_hist_entry(struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tbool has_record = false;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\n\t \n\tif (c2c_he->stats.store)\n\t\treturn true;\n\n\tswitch (c2c.display) {\n\tcase DISPLAY_LCL_HITM:\n\t\thas_record = !!c2c_he->stats.lcl_hitm;\n\t\tbreak;\n\tcase DISPLAY_RMT_HITM:\n\t\thas_record = !!c2c_he->stats.rmt_hitm;\n\t\tbreak;\n\tcase DISPLAY_TOT_HITM:\n\t\thas_record = !!c2c_he->stats.tot_hitm;\n\t\tbreak;\n\tcase DISPLAY_SNP_PEER:\n\t\thas_record = !!c2c_he->stats.tot_peer;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn has_record;\n}\n\nstatic void set_node_width(struct c2c_hist_entry *c2c_he, int len)\n{\n\tstruct c2c_dimension *dim;\n\n\tdim = &c2c.hists == c2c_he->hists ?\n\t      &dim_dcacheline_node : &dim_offset_node;\n\n\tif (len > dim->width)\n\t\tdim->width = len;\n}\n\nstatic int set_nodestr(struct c2c_hist_entry *c2c_he)\n{\n\tchar buf[30];\n\tint len;\n\n\tif (c2c_he->nodestr)\n\t\treturn 0;\n\n\tif (!bitmap_empty(c2c_he->nodeset, c2c.nodes_cnt)) {\n\t\tlen = bitmap_scnprintf(c2c_he->nodeset, c2c.nodes_cnt,\n\t\t\t\t      buf, sizeof(buf));\n\t} else {\n\t\tlen = scnprintf(buf, sizeof(buf), \"N/A\");\n\t}\n\n\tset_node_width(c2c_he, len);\n\tc2c_he->nodestr = strdup(buf);\n\treturn c2c_he->nodestr ? 0 : -ENOMEM;\n}\n\nstatic void calc_width(struct c2c_hist_entry *c2c_he)\n{\n\tstruct c2c_hists *c2c_hists;\n\n\tc2c_hists = container_of(c2c_he->he.hists, struct c2c_hists, hists);\n\thists__calc_col_len(&c2c_hists->hists, &c2c_he->he);\n\tset_nodestr(c2c_he);\n}\n\nstatic int filter_cb(struct hist_entry *he, void *arg __maybe_unused)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\n\tif (c2c.show_src && !he->srcline)\n\t\the->srcline = hist_entry__srcline(he);\n\n\tcalc_width(c2c_he);\n\n\tif (!is_valid_hist_entry(he))\n\t\the->filtered = HIST_FILTER__C2C;\n\n\treturn 0;\n}\n\nstatic int resort_cl_cb(struct hist_entry *he, void *arg __maybe_unused)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tstruct c2c_hists *c2c_hists;\n\tbool display = he__display(he, &c2c.shared_clines_stats);\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\tc2c_hists = c2c_he->hists;\n\n\tif (display && c2c_hists) {\n\t\tstatic unsigned int idx;\n\n\t\tc2c_he->cacheline_idx = idx++;\n\t\tcalc_width(c2c_he);\n\n\t\tc2c_hists__reinit(c2c_hists, c2c.cl_output, c2c.cl_resort);\n\n\t\thists__collapse_resort(&c2c_hists->hists, NULL);\n\t\thists__output_resort_cb(&c2c_hists->hists, NULL, filter_cb);\n\t}\n\n\treturn 0;\n}\n\nstatic struct c2c_header header_node_0 = HEADER_LOW(\"Node\");\nstatic struct c2c_header header_node_1_hitms_stores =\n\t\tHEADER_LOW(\"Node{cpus %hitms %stores}\");\nstatic struct c2c_header header_node_1_peers_stores =\n\t\tHEADER_LOW(\"Node{cpus %peers %stores}\");\nstatic struct c2c_header header_node_2 = HEADER_LOW(\"Node{cpu list}\");\n\nstatic void setup_nodes_header(void)\n{\n\tswitch (c2c.node_info) {\n\tcase 0:\n\t\tdim_node.header = header_node_0;\n\t\tbreak;\n\tcase 1:\n\t\tif (c2c.display == DISPLAY_SNP_PEER)\n\t\t\tdim_node.header = header_node_1_peers_stores;\n\t\telse\n\t\t\tdim_node.header = header_node_1_hitms_stores;\n\t\tbreak;\n\tcase 2:\n\t\tdim_node.header = header_node_2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn;\n}\n\nstatic int setup_nodes(struct perf_session *session)\n{\n\tstruct numa_node *n;\n\tunsigned long **nodes;\n\tint node, idx;\n\tstruct perf_cpu cpu;\n\tint *cpu2node;\n\n\tif (c2c.node_info > 2)\n\t\tc2c.node_info = 2;\n\n\tc2c.nodes_cnt = session->header.env.nr_numa_nodes;\n\tc2c.cpus_cnt  = session->header.env.nr_cpus_avail;\n\n\tn = session->header.env.numa_nodes;\n\tif (!n)\n\t\treturn -EINVAL;\n\n\tnodes = zalloc(sizeof(unsigned long *) * c2c.nodes_cnt);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tc2c.nodes = nodes;\n\n\tcpu2node = zalloc(sizeof(int) * c2c.cpus_cnt);\n\tif (!cpu2node)\n\t\treturn -ENOMEM;\n\n\tfor (idx = 0; idx < c2c.cpus_cnt; idx++)\n\t\tcpu2node[idx] = -1;\n\n\tc2c.cpu2node = cpu2node;\n\n\tfor (node = 0; node < c2c.nodes_cnt; node++) {\n\t\tstruct perf_cpu_map *map = n[node].map;\n\t\tunsigned long *set;\n\n\t\tset = bitmap_zalloc(c2c.cpus_cnt);\n\t\tif (!set)\n\t\t\treturn -ENOMEM;\n\n\t\tnodes[node] = set;\n\n\t\t \n\t\tif (perf_cpu_map__empty(map))\n\t\t\tcontinue;\n\n\t\tperf_cpu_map__for_each_cpu(cpu, idx, map) {\n\t\t\t__set_bit(cpu.cpu, set);\n\n\t\t\tif (WARN_ONCE(cpu2node[cpu.cpu] != -1, \"node/cpu topology bug\"))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcpu2node[cpu.cpu] = node;\n\t\t}\n\t}\n\n\tsetup_nodes_header();\n\treturn 0;\n}\n\n#define HAS_HITMS(__h) ((__h)->stats.lcl_hitm || (__h)->stats.rmt_hitm)\n#define HAS_PEER(__h) ((__h)->stats.lcl_peer || (__h)->stats.rmt_peer)\n\nstatic int resort_shared_cl_cb(struct hist_entry *he, void *arg __maybe_unused)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\n\tif (HAS_HITMS(c2c_he) || HAS_PEER(c2c_he)) {\n\t\tc2c.shared_clines++;\n\t\tc2c_add_stats(&c2c.shared_clines_stats, &c2c_he->stats);\n\t}\n\n\treturn 0;\n}\n\nstatic int hists__iterate_cb(struct hists *hists, hists__resort_cb_t cb)\n{\n\tstruct rb_node *next = rb_first_cached(&hists->entries);\n\tint ret = 0;\n\n\twhile (next) {\n\t\tstruct hist_entry *he;\n\n\t\the = rb_entry(next, struct hist_entry, rb_node);\n\t\tret = cb(he, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tnext = rb_next(&he->rb_node);\n\t}\n\n\treturn ret;\n}\n\nstatic void print_c2c__display_stats(FILE *out)\n{\n\tint llc_misses;\n\tstruct c2c_stats *stats = &c2c.hists.stats;\n\n\tllc_misses = get_load_llc_misses(stats);\n\n\tfprintf(out, \"=================================================\\n\");\n\tfprintf(out, \"            Trace Event Information              \\n\");\n\tfprintf(out, \"=================================================\\n\");\n\tfprintf(out, \"  Total records                     : %10d\\n\", stats->nr_entries);\n\tfprintf(out, \"  Locked Load/Store Operations      : %10d\\n\", stats->locks);\n\tfprintf(out, \"  Load Operations                   : %10d\\n\", stats->load);\n\tfprintf(out, \"  Loads - uncacheable               : %10d\\n\", stats->ld_uncache);\n\tfprintf(out, \"  Loads - IO                        : %10d\\n\", stats->ld_io);\n\tfprintf(out, \"  Loads - Miss                      : %10d\\n\", stats->ld_miss);\n\tfprintf(out, \"  Loads - no mapping                : %10d\\n\", stats->ld_noadrs);\n\tfprintf(out, \"  Load Fill Buffer Hit              : %10d\\n\", stats->ld_fbhit);\n\tfprintf(out, \"  Load L1D hit                      : %10d\\n\", stats->ld_l1hit);\n\tfprintf(out, \"  Load L2D hit                      : %10d\\n\", stats->ld_l2hit);\n\tfprintf(out, \"  Load LLC hit                      : %10d\\n\", stats->ld_llchit + stats->lcl_hitm);\n\tfprintf(out, \"  Load Local HITM                   : %10d\\n\", stats->lcl_hitm);\n\tfprintf(out, \"  Load Remote HITM                  : %10d\\n\", stats->rmt_hitm);\n\tfprintf(out, \"  Load Remote HIT                   : %10d\\n\", stats->rmt_hit);\n\tfprintf(out, \"  Load Local DRAM                   : %10d\\n\", stats->lcl_dram);\n\tfprintf(out, \"  Load Remote DRAM                  : %10d\\n\", stats->rmt_dram);\n\tfprintf(out, \"  Load MESI State Exclusive         : %10d\\n\", stats->ld_excl);\n\tfprintf(out, \"  Load MESI State Shared            : %10d\\n\", stats->ld_shared);\n\tfprintf(out, \"  Load LLC Misses                   : %10d\\n\", llc_misses);\n\tfprintf(out, \"  Load access blocked by data       : %10d\\n\", stats->blk_data);\n\tfprintf(out, \"  Load access blocked by address    : %10d\\n\", stats->blk_addr);\n\tfprintf(out, \"  Load HIT Local Peer               : %10d\\n\", stats->lcl_peer);\n\tfprintf(out, \"  Load HIT Remote Peer              : %10d\\n\", stats->rmt_peer);\n\tfprintf(out, \"  LLC Misses to Local DRAM          : %10.1f%%\\n\", ((double)stats->lcl_dram/(double)llc_misses) * 100.);\n\tfprintf(out, \"  LLC Misses to Remote DRAM         : %10.1f%%\\n\", ((double)stats->rmt_dram/(double)llc_misses) * 100.);\n\tfprintf(out, \"  LLC Misses to Remote cache (HIT)  : %10.1f%%\\n\", ((double)stats->rmt_hit /(double)llc_misses) * 100.);\n\tfprintf(out, \"  LLC Misses to Remote cache (HITM) : %10.1f%%\\n\", ((double)stats->rmt_hitm/(double)llc_misses) * 100.);\n\tfprintf(out, \"  Store Operations                  : %10d\\n\", stats->store);\n\tfprintf(out, \"  Store - uncacheable               : %10d\\n\", stats->st_uncache);\n\tfprintf(out, \"  Store - no mapping                : %10d\\n\", stats->st_noadrs);\n\tfprintf(out, \"  Store L1D Hit                     : %10d\\n\", stats->st_l1hit);\n\tfprintf(out, \"  Store L1D Miss                    : %10d\\n\", stats->st_l1miss);\n\tfprintf(out, \"  Store No available memory level   : %10d\\n\", stats->st_na);\n\tfprintf(out, \"  No Page Map Rejects               : %10d\\n\", stats->nomap);\n\tfprintf(out, \"  Unable to parse data source       : %10d\\n\", stats->noparse);\n}\n\nstatic void print_shared_cacheline_info(FILE *out)\n{\n\tstruct c2c_stats *stats = &c2c.shared_clines_stats;\n\tint hitm_cnt = stats->lcl_hitm + stats->rmt_hitm;\n\n\tfprintf(out, \"=================================================\\n\");\n\tfprintf(out, \"    Global Shared Cache Line Event Information   \\n\");\n\tfprintf(out, \"=================================================\\n\");\n\tfprintf(out, \"  Total Shared Cache Lines          : %10d\\n\", c2c.shared_clines);\n\tfprintf(out, \"  Load HITs on shared lines         : %10d\\n\", stats->load);\n\tfprintf(out, \"  Fill Buffer Hits on shared lines  : %10d\\n\", stats->ld_fbhit);\n\tfprintf(out, \"  L1D hits on shared lines          : %10d\\n\", stats->ld_l1hit);\n\tfprintf(out, \"  L2D hits on shared lines          : %10d\\n\", stats->ld_l2hit);\n\tfprintf(out, \"  LLC hits on shared lines          : %10d\\n\", stats->ld_llchit + stats->lcl_hitm);\n\tfprintf(out, \"  Load hits on peer cache or nodes  : %10d\\n\", stats->lcl_peer + stats->rmt_peer);\n\tfprintf(out, \"  Locked Access on shared lines     : %10d\\n\", stats->locks);\n\tfprintf(out, \"  Blocked Access on shared lines    : %10d\\n\", stats->blk_data + stats->blk_addr);\n\tfprintf(out, \"  Store HITs on shared lines        : %10d\\n\", stats->store);\n\tfprintf(out, \"  Store L1D hits on shared lines    : %10d\\n\", stats->st_l1hit);\n\tfprintf(out, \"  Store No available memory level   : %10d\\n\", stats->st_na);\n\tfprintf(out, \"  Total Merged records              : %10d\\n\", hitm_cnt + stats->store);\n}\n\nstatic void print_cacheline(struct c2c_hists *c2c_hists,\n\t\t\t    struct hist_entry *he_cl,\n\t\t\t    struct perf_hpp_list *hpp_list,\n\t\t\t    FILE *out)\n{\n\tchar bf[1000];\n\tstruct perf_hpp hpp = {\n\t\t.buf            = bf,\n\t\t.size           = 1000,\n\t};\n\tstatic bool once;\n\n\tif (!once) {\n\t\thists__fprintf_headers(&c2c_hists->hists, out);\n\t\tonce = true;\n\t} else {\n\t\tfprintf(out, \"\\n\");\n\t}\n\n\tfprintf(out, \"  ----------------------------------------------------------------------\\n\");\n\t__hist_entry__snprintf(he_cl, &hpp, hpp_list);\n\tfprintf(out, \"%s\\n\", bf);\n\tfprintf(out, \"  ----------------------------------------------------------------------\\n\");\n\n\thists__fprintf(&c2c_hists->hists, false, 0, 0, 0, out, false);\n}\n\nstatic void print_pareto(FILE *out)\n{\n\tstruct perf_hpp_list hpp_list;\n\tstruct rb_node *nd;\n\tint ret;\n\tconst char *cl_output;\n\n\tif (c2c.display != DISPLAY_SNP_PEER)\n\t\tcl_output = \"cl_num,\"\n\t\t\t    \"cl_rmt_hitm,\"\n\t\t\t    \"cl_lcl_hitm,\"\n\t\t\t    \"cl_stores_l1hit,\"\n\t\t\t    \"cl_stores_l1miss,\"\n\t\t\t    \"cl_stores_na,\"\n\t\t\t    \"dcacheline\";\n\telse\n\t\tcl_output = \"cl_num,\"\n\t\t\t    \"cl_rmt_peer,\"\n\t\t\t    \"cl_lcl_peer,\"\n\t\t\t    \"cl_stores_l1hit,\"\n\t\t\t    \"cl_stores_l1miss,\"\n\t\t\t    \"cl_stores_na,\"\n\t\t\t    \"dcacheline\";\n\n\tperf_hpp_list__init(&hpp_list);\n\tret = hpp_list__parse(&hpp_list, cl_output, NULL);\n\n\tif (WARN_ONCE(ret, \"failed to setup sort entries\\n\"))\n\t\treturn;\n\n\tnd = rb_first_cached(&c2c.hists.hists.entries);\n\n\tfor (; nd; nd = rb_next(nd)) {\n\t\tstruct hist_entry *he = rb_entry(nd, struct hist_entry, rb_node);\n\t\tstruct c2c_hist_entry *c2c_he;\n\n\t\tif (he->filtered)\n\t\t\tcontinue;\n\n\t\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\t\tprint_cacheline(c2c_he->hists, he, &hpp_list, out);\n\t}\n}\n\nstatic void print_c2c_info(FILE *out, struct perf_session *session)\n{\n\tstruct evlist *evlist = session->evlist;\n\tstruct evsel *evsel;\n\tbool first = true;\n\n\tfprintf(out, \"=================================================\\n\");\n\tfprintf(out, \"                 c2c details                     \\n\");\n\tfprintf(out, \"=================================================\\n\");\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tfprintf(out, \"%-36s: %s\\n\", first ? \"  Events\" : \"\", evsel__name(evsel));\n\t\tfirst = false;\n\t}\n\tfprintf(out, \"  Cachelines sort on                : %s\\n\",\n\t\tdisplay_str[c2c.display]);\n\tfprintf(out, \"  Cacheline data grouping           : %s\\n\", c2c.cl_sort);\n}\n\nstatic void perf_c2c__hists_fprintf(FILE *out, struct perf_session *session)\n{\n\tsetup_pager();\n\n\tprint_c2c__display_stats(out);\n\tfprintf(out, \"\\n\");\n\tprint_shared_cacheline_info(out);\n\tfprintf(out, \"\\n\");\n\tprint_c2c_info(out, session);\n\n\tif (c2c.stats_only)\n\t\treturn;\n\n\tfprintf(out, \"\\n\");\n\tfprintf(out, \"=================================================\\n\");\n\tfprintf(out, \"           Shared Data Cache Line Table          \\n\");\n\tfprintf(out, \"=================================================\\n\");\n\tfprintf(out, \"#\\n\");\n\n\thists__fprintf(&c2c.hists.hists, true, 0, 0, 0, stdout, true);\n\n\tfprintf(out, \"\\n\");\n\tfprintf(out, \"=================================================\\n\");\n\tfprintf(out, \"      Shared Cache Line Distribution Pareto      \\n\");\n\tfprintf(out, \"=================================================\\n\");\n\tfprintf(out, \"#\\n\");\n\n\tprint_pareto(out);\n}\n\n#ifdef HAVE_SLANG_SUPPORT\nstatic void c2c_browser__update_nr_entries(struct hist_browser *hb)\n{\n\tu64 nr_entries = 0;\n\tstruct rb_node *nd = rb_first_cached(&hb->hists->entries);\n\n\twhile (nd) {\n\t\tstruct hist_entry *he = rb_entry(nd, struct hist_entry, rb_node);\n\n\t\tif (!he->filtered)\n\t\t\tnr_entries++;\n\n\t\tnd = rb_next(nd);\n\t}\n\n\thb->nr_non_filtered_entries = nr_entries;\n}\n\nstruct c2c_cacheline_browser {\n\tstruct hist_browser\t hb;\n\tstruct hist_entry\t*he;\n};\n\nstatic int\nperf_c2c_cacheline_browser__title(struct hist_browser *browser,\n\t\t\t\t  char *bf, size_t size)\n{\n\tstruct c2c_cacheline_browser *cl_browser;\n\tstruct hist_entry *he;\n\tuint64_t addr = 0;\n\n\tcl_browser = container_of(browser, struct c2c_cacheline_browser, hb);\n\the = cl_browser->he;\n\n\tif (he->mem_info)\n\t\taddr = cl_address(he->mem_info->daddr.addr, chk_double_cl);\n\n\tscnprintf(bf, size, \"Cacheline 0x%lx\", addr);\n\treturn 0;\n}\n\nstatic struct c2c_cacheline_browser*\nc2c_cacheline_browser__new(struct hists *hists, struct hist_entry *he)\n{\n\tstruct c2c_cacheline_browser *browser;\n\n\tbrowser = zalloc(sizeof(*browser));\n\tif (browser) {\n\t\thist_browser__init(&browser->hb, hists);\n\t\tbrowser->hb.c2c_filter\t= true;\n\t\tbrowser->hb.title\t= perf_c2c_cacheline_browser__title;\n\t\tbrowser->he\t\t= he;\n\t}\n\n\treturn browser;\n}\n\nstatic int perf_c2c__browse_cacheline(struct hist_entry *he)\n{\n\tstruct c2c_hist_entry *c2c_he;\n\tstruct c2c_hists *c2c_hists;\n\tstruct c2c_cacheline_browser *cl_browser;\n\tstruct hist_browser *browser;\n\tint key = -1;\n\tstatic const char help[] =\n\t\" ENTER         Toggle callchains (if present) \\n\"\n\t\" n             Toggle Node details info \\n\"\n\t\" s             Toggle full length of symbol and source line columns \\n\"\n\t\" q             Return back to cacheline list \\n\";\n\n\tif (!he)\n\t\treturn 0;\n\n\t \n\tc2c.symbol_full = false;\n\n\tc2c_he = container_of(he, struct c2c_hist_entry, he);\n\tc2c_hists = c2c_he->hists;\n\n\tcl_browser = c2c_cacheline_browser__new(&c2c_hists->hists, he);\n\tif (cl_browser == NULL)\n\t\treturn -1;\n\n\tbrowser = &cl_browser->hb;\n\n\t \n\tSLang_reset_tty();\n\tSLang_init_tty(0, 0, 0);\n\n\tc2c_browser__update_nr_entries(browser);\n\n\twhile (1) {\n\t\tkey = hist_browser__run(browser, \"? - help\", true, 0);\n\n\t\tswitch (key) {\n\t\tcase 's':\n\t\t\tc2c.symbol_full = !c2c.symbol_full;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tc2c.node_info = (c2c.node_info + 1) % 3;\n\t\t\tsetup_nodes_header();\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tgoto out;\n\t\tcase '?':\n\t\t\tui_browser__help_window(&browser->b, help);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tfree(cl_browser);\n\treturn 0;\n}\n\nstatic int perf_c2c_browser__title(struct hist_browser *browser,\n\t\t\t\t   char *bf, size_t size)\n{\n\tscnprintf(bf, size,\n\t\t  \"Shared Data Cache Line Table     \"\n\t\t  \"(%lu entries, sorted on %s)\",\n\t\t  browser->nr_non_filtered_entries,\n\t\t  display_str[c2c.display]);\n\treturn 0;\n}\n\nstatic struct hist_browser*\nperf_c2c_browser__new(struct hists *hists)\n{\n\tstruct hist_browser *browser = hist_browser__new(hists);\n\n\tif (browser) {\n\t\tbrowser->title = perf_c2c_browser__title;\n\t\tbrowser->c2c_filter = true;\n\t}\n\n\treturn browser;\n}\n\nstatic int perf_c2c__hists_browse(struct hists *hists)\n{\n\tstruct hist_browser *browser;\n\tint key = -1;\n\tstatic const char help[] =\n\t\" d             Display cacheline details \\n\"\n\t\" ENTER         Toggle callchains (if present) \\n\"\n\t\" q             Quit \\n\";\n\n\tbrowser = perf_c2c_browser__new(hists);\n\tif (browser == NULL)\n\t\treturn -1;\n\n\t \n\tSLang_reset_tty();\n\tSLang_init_tty(0, 0, 0);\n\n\tc2c_browser__update_nr_entries(browser);\n\n\twhile (1) {\n\t\tkey = hist_browser__run(browser, \"? - help\", true, 0);\n\n\t\tswitch (key) {\n\t\tcase 'q':\n\t\t\tgoto out;\n\t\tcase 'd':\n\t\t\tperf_c2c__browse_cacheline(browser->he_selection);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tui_browser__help_window(&browser->b, help);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\thist_browser__delete(browser);\n\treturn 0;\n}\n\nstatic void perf_c2c_display(struct perf_session *session)\n{\n\tif (use_browser == 0)\n\t\tperf_c2c__hists_fprintf(stdout, session);\n\telse\n\t\tperf_c2c__hists_browse(&c2c.hists.hists);\n}\n#else\nstatic void perf_c2c_display(struct perf_session *session)\n{\n\tuse_browser = 0;\n\tperf_c2c__hists_fprintf(stdout, session);\n}\n#endif  \n\nstatic char *fill_line(const char *orig, int len)\n{\n\tint i, j, olen = strlen(orig);\n\tchar *buf;\n\n\tbuf = zalloc(len + 1);\n\tif (!buf)\n\t\treturn NULL;\n\n\tj = len / 2 - olen / 2;\n\n\tfor (i = 0; i < j - 1; i++)\n\t\tbuf[i] = '-';\n\n\tbuf[i++] = ' ';\n\n\tstrcpy(buf + i, orig);\n\n\ti += olen;\n\n\tbuf[i++] = ' ';\n\n\tfor (; i < len; i++)\n\t\tbuf[i] = '-';\n\n\treturn buf;\n}\n\nstatic int ui_quirks(void)\n{\n\tconst char *nodestr = \"Data address\";\n\tchar *buf;\n\n\tif (!c2c.use_stdio) {\n\t\tdim_offset.width  = 5;\n\t\tdim_offset.header = header_offset_tui;\n\t\tnodestr = chk_double_cl ? \"Double-CL\" : \"CL\";\n\t}\n\n\tdim_percent_costly_snoop.header = percent_costly_snoop_header[c2c.display];\n\n\t \n\tbuf = fill_line(chk_double_cl ? \"Double-Cacheline\" : \"Cacheline\",\n\t\t\t\tdim_dcacheline.width +\n\t\t\t\tdim_dcacheline_node.width +\n\t\t\t\tdim_dcacheline_count.width + 4);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdim_dcacheline.header.line[0].text = buf;\n\n\t \n\tbuf = fill_line(nodestr, dim_offset.width +\n\t\t\t         dim_offset_node.width +\n\t\t\t\t dim_dcacheline_count.width + 4);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdim_offset.header.line[0].text = buf;\n\n\treturn 0;\n}\n\n#define CALLCHAIN_DEFAULT_OPT  \"graph,0.5,caller,function,percent\"\n\nconst char callchain_help[] = \"Display call graph (stack chain/backtrace):\\n\\n\"\n\t\t\t\tCALLCHAIN_REPORT_HELP\n\t\t\t\t\"\\n\\t\\t\\t\\tDefault: \" CALLCHAIN_DEFAULT_OPT;\n\nstatic int\nparse_callchain_opt(const struct option *opt, const char *arg, int unset)\n{\n\tstruct callchain_param *callchain = opt->value;\n\n\tcallchain->enabled = !unset;\n\t \n\tif (unset) {\n\t\tsymbol_conf.use_callchain = false;\n\t\tcallchain->mode = CHAIN_NONE;\n\t\treturn 0;\n\t}\n\n\treturn parse_callchain_report_opt(arg);\n}\n\nstatic int setup_callchain(struct evlist *evlist)\n{\n\tu64 sample_type = evlist__combined_sample_type(evlist);\n\tenum perf_call_graph_mode mode = CALLCHAIN_NONE;\n\n\tif ((sample_type & PERF_SAMPLE_REGS_USER) &&\n\t    (sample_type & PERF_SAMPLE_STACK_USER)) {\n\t\tmode = CALLCHAIN_DWARF;\n\t\tdwarf_callchain_users = true;\n\t} else if (sample_type & PERF_SAMPLE_BRANCH_STACK)\n\t\tmode = CALLCHAIN_LBR;\n\telse if (sample_type & PERF_SAMPLE_CALLCHAIN)\n\t\tmode = CALLCHAIN_FP;\n\n\tif (!callchain_param.enabled &&\n\t    callchain_param.mode != CHAIN_NONE &&\n\t    mode != CALLCHAIN_NONE) {\n\t\tsymbol_conf.use_callchain = true;\n\t\tif (callchain_register_param(&callchain_param) < 0) {\n\t\t\tui__error(\"Can't register callchain params.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (c2c.stitch_lbr && (mode != CALLCHAIN_LBR)) {\n\t\tui__warning(\"Can't find LBR callchain. Switch off --stitch-lbr.\\n\"\n\t\t\t    \"Please apply --call-graph lbr when recording.\\n\");\n\t\tc2c.stitch_lbr = false;\n\t}\n\n\tcallchain_param.record_mode = mode;\n\tcallchain_param.min_percent = 0;\n\treturn 0;\n}\n\nstatic int setup_display(const char *str)\n{\n\tconst char *display = str;\n\n\tif (!strcmp(display, \"tot\"))\n\t\tc2c.display = DISPLAY_TOT_HITM;\n\telse if (!strcmp(display, \"rmt\"))\n\t\tc2c.display = DISPLAY_RMT_HITM;\n\telse if (!strcmp(display, \"lcl\"))\n\t\tc2c.display = DISPLAY_LCL_HITM;\n\telse if (!strcmp(display, \"peer\"))\n\t\tc2c.display = DISPLAY_SNP_PEER;\n\telse {\n\t\tpr_err(\"failed: unknown display type: %s\\n\", str);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n#define for_each_token(__tok, __buf, __sep, __tmp)\t\t\\\n\tfor (__tok = strtok_r(__buf, __sep, &__tmp); __tok;\t\\\n\t     __tok = strtok_r(NULL,  __sep, &__tmp))\n\nstatic int build_cl_output(char *cl_sort, bool no_source)\n{\n\tchar *tok, *tmp, *buf = strdup(cl_sort);\n\tbool add_pid   = false;\n\tbool add_tid   = false;\n\tbool add_iaddr = false;\n\tbool add_sym   = false;\n\tbool add_dso   = false;\n\tbool add_src   = false;\n\tint ret = 0;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor_each_token(tok, buf, \",\", tmp) {\n\t\tif (!strcmp(tok, \"tid\")) {\n\t\t\tadd_tid = true;\n\t\t} else if (!strcmp(tok, \"pid\")) {\n\t\t\tadd_pid = true;\n\t\t} else if (!strcmp(tok, \"iaddr\")) {\n\t\t\tadd_iaddr = true;\n\t\t\tadd_sym   = true;\n\t\t\tadd_dso   = true;\n\t\t\tadd_src   = no_source ? false : true;\n\t\t} else if (!strcmp(tok, \"dso\")) {\n\t\t\tadd_dso = true;\n\t\t} else if (strcmp(tok, \"offset\")) {\n\t\t\tpr_err(\"unrecognized sort token: %s\\n\", tok);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (asprintf(&c2c.cl_output,\n\t\t\"%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t\tc2c.use_stdio ? \"cl_num_empty,\" : \"\",\n\t\tc2c.display == DISPLAY_SNP_PEER ? \"percent_rmt_peer,\"\n\t\t\t\t\t\t  \"percent_lcl_peer,\" :\n\t\t\t\t\t\t  \"percent_rmt_hitm,\"\n\t\t\t\t\t\t  \"percent_lcl_hitm,\",\n\t\t\"percent_stores_l1hit,\"\n\t\t\"percent_stores_l1miss,\"\n\t\t\"percent_stores_na,\"\n\t\t\"offset,offset_node,dcacheline_count,\",\n\t\tadd_pid   ? \"pid,\" : \"\",\n\t\tadd_tid   ? \"tid,\" : \"\",\n\t\tadd_iaddr ? \"iaddr,\" : \"\",\n\t\tc2c.display == DISPLAY_SNP_PEER ? \"mean_rmt_peer,\"\n\t\t\t\t\t\t  \"mean_lcl_peer,\" :\n\t\t\t\t\t\t  \"mean_rmt,\"\n\t\t\t\t\t\t  \"mean_lcl,\",\n\t\t\"mean_load,\"\n\t\t\"tot_recs,\"\n\t\t\"cpucnt,\",\n\t\tadd_sym ? \"symbol,\" : \"\",\n\t\tadd_dso ? \"dso,\" : \"\",\n\t\tadd_src ? \"cl_srcline,\" : \"\",\n\t\t\"node\") < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tc2c.show_src = add_src;\nerr:\n\tfree(buf);\n\treturn ret;\n}\n\nstatic int setup_coalesce(const char *coalesce, bool no_source)\n{\n\tconst char *c = coalesce ?: coalesce_default;\n\tconst char *sort_str = NULL;\n\n\tif (asprintf(&c2c.cl_sort, \"offset,%s\", c) < 0)\n\t\treturn -ENOMEM;\n\n\tif (build_cl_output(c2c.cl_sort, no_source))\n\t\treturn -1;\n\n\tif (c2c.display == DISPLAY_TOT_HITM)\n\t\tsort_str = \"tot_hitm\";\n\telse if (c2c.display == DISPLAY_RMT_HITM)\n\t\tsort_str = \"rmt_hitm,lcl_hitm\";\n\telse if (c2c.display == DISPLAY_LCL_HITM)\n\t\tsort_str = \"lcl_hitm,rmt_hitm\";\n\telse if (c2c.display == DISPLAY_SNP_PEER)\n\t\tsort_str = \"tot_peer\";\n\n\tif (asprintf(&c2c.cl_resort, \"offset,%s\", sort_str) < 0)\n\t\treturn -ENOMEM;\n\n\tpr_debug(\"coalesce sort   fields: %s\\n\", c2c.cl_sort);\n\tpr_debug(\"coalesce resort fields: %s\\n\", c2c.cl_resort);\n\tpr_debug(\"coalesce output fields: %s\\n\", c2c.cl_output);\n\treturn 0;\n}\n\nstatic int perf_c2c__report(int argc, const char **argv)\n{\n\tstruct itrace_synth_opts itrace_synth_opts = {\n\t\t.set = true,\n\t\t.mem = true,\t \n\t\t.default_no_sample = true,\n\t};\n\n\tstruct perf_session *session;\n\tstruct ui_progress prog;\n\tstruct perf_data data = {\n\t\t.mode = PERF_DATA_MODE_READ,\n\t};\n\tchar callchain_default_opt[] = CALLCHAIN_DEFAULT_OPT;\n\tconst char *display = NULL;\n\tconst char *coalesce = NULL;\n\tbool no_source = false;\n\tconst struct option options[] = {\n\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_STRING('i', \"input\", &input_name, \"file\",\n\t\t   \"the input file to process\"),\n\tOPT_INCR('N', \"node-info\", &c2c.node_info,\n\t\t \"show extra node info in report (repeat for more info)\"),\n\tOPT_BOOLEAN(0, \"stdio\", &c2c.use_stdio, \"Use the stdio interface\"),\n\tOPT_BOOLEAN(0, \"stats\", &c2c.stats_only,\n\t\t    \"Display only statistic tables (implies --stdio)\"),\n\tOPT_BOOLEAN(0, \"full-symbols\", &c2c.symbol_full,\n\t\t    \"Display full length of symbols\"),\n\tOPT_BOOLEAN(0, \"no-source\", &no_source,\n\t\t    \"Do not display Source Line column\"),\n\tOPT_BOOLEAN(0, \"show-all\", &c2c.show_all,\n\t\t    \"Show all captured HITM lines.\"),\n\tOPT_CALLBACK_DEFAULT('g', \"call-graph\", &callchain_param,\n\t\t\t     \"print_type,threshold[,print_limit],order,sort_key[,branch],value\",\n\t\t\t     callchain_help, &parse_callchain_opt,\n\t\t\t     callchain_default_opt),\n\tOPT_STRING('d', \"display\", &display, \"Switch HITM output type\", \"tot,lcl,rmt,peer\"),\n\tOPT_STRING('c', \"coalesce\", &coalesce, \"coalesce fields\",\n\t\t   \"coalesce fields: pid,tid,iaddr,dso\"),\n\tOPT_BOOLEAN('f', \"force\", &symbol_conf.force, \"don't complain, do it\"),\n\tOPT_BOOLEAN(0, \"stitch-lbr\", &c2c.stitch_lbr,\n\t\t    \"Enable LBR callgraph stitching approach\"),\n\tOPT_BOOLEAN(0, \"double-cl\", &chk_double_cl, \"Detect adjacent cacheline false sharing\"),\n\tOPT_PARENT(c2c_options),\n\tOPT_END()\n\t};\n\tint err = 0;\n\tconst char *output_str, *sort_str = NULL;\n\n\targc = parse_options(argc, argv, options, report_c2c_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\tif (argc)\n\t\tusage_with_options(report_c2c_usage, options);\n\n#ifndef HAVE_SLANG_SUPPORT\n\tc2c.use_stdio = true;\n#endif\n\n\tif (c2c.stats_only)\n\t\tc2c.use_stdio = true;\n\n\terr = symbol__validate_sym_arguments();\n\tif (err)\n\t\tgoto out;\n\n\tif (!input_name || !strlen(input_name))\n\t\tinput_name = \"perf.data\";\n\n\tdata.path  = input_name;\n\tdata.force = symbol_conf.force;\n\n\tsession = perf_session__new(&data, &c2c.tool);\n\tif (IS_ERR(session)) {\n\t\terr = PTR_ERR(session);\n\t\tpr_debug(\"Error creating perf session\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!display) {\n\t\tif (!strcmp(perf_env__arch(&session->header.env), \"arm64\"))\n\t\t\tdisplay = \"peer\";\n\t\telse\n\t\t\tdisplay = \"tot\";\n\t}\n\n\terr = setup_display(display);\n\tif (err)\n\t\tgoto out_session;\n\n\terr = setup_coalesce(coalesce, no_source);\n\tif (err) {\n\t\tpr_debug(\"Failed to initialize hists\\n\");\n\t\tgoto out_session;\n\t}\n\n\terr = c2c_hists__init(&c2c.hists, \"dcacheline\", 2);\n\tif (err) {\n\t\tpr_debug(\"Failed to initialize hists\\n\");\n\t\tgoto out_session;\n\t}\n\n\tsession->itrace_synth_opts = &itrace_synth_opts;\n\n\terr = setup_nodes(session);\n\tif (err) {\n\t\tpr_err(\"Failed setup nodes\\n\");\n\t\tgoto out_session;\n\t}\n\n\terr = mem2node__init(&c2c.mem2node, &session->header.env);\n\tif (err)\n\t\tgoto out_session;\n\n\terr = setup_callchain(session->evlist);\n\tif (err)\n\t\tgoto out_mem2node;\n\n\tif (symbol__init(&session->header.env) < 0)\n\t\tgoto out_mem2node;\n\n\t \n\tif (perf_data__is_pipe(session->data)) {\n\t\tpr_debug(\"No pipe support at the moment.\\n\");\n\t\tgoto out_mem2node;\n\t}\n\n\tif (c2c.use_stdio)\n\t\tuse_browser = 0;\n\telse\n\t\tuse_browser = 1;\n\n\tsetup_browser(false);\n\n\terr = perf_session__process_events(session);\n\tif (err) {\n\t\tpr_err(\"failed to process sample\\n\");\n\t\tgoto out_mem2node;\n\t}\n\n\tif (c2c.display != DISPLAY_SNP_PEER)\n\t\toutput_str = \"cl_idx,\"\n\t\t\t     \"dcacheline,\"\n\t\t\t     \"dcacheline_node,\"\n\t\t\t     \"dcacheline_count,\"\n\t\t\t     \"percent_costly_snoop,\"\n\t\t\t     \"tot_hitm,lcl_hitm,rmt_hitm,\"\n\t\t\t     \"tot_recs,\"\n\t\t\t     \"tot_loads,\"\n\t\t\t     \"tot_stores,\"\n\t\t\t     \"stores_l1hit,stores_l1miss,stores_na,\"\n\t\t\t     \"ld_fbhit,ld_l1hit,ld_l2hit,\"\n\t\t\t     \"ld_lclhit,lcl_hitm,\"\n\t\t\t     \"ld_rmthit,rmt_hitm,\"\n\t\t\t     \"dram_lcl,dram_rmt\";\n\telse\n\t\toutput_str = \"cl_idx,\"\n\t\t\t     \"dcacheline,\"\n\t\t\t     \"dcacheline_node,\"\n\t\t\t     \"dcacheline_count,\"\n\t\t\t     \"percent_costly_snoop,\"\n\t\t\t     \"tot_peer,lcl_peer,rmt_peer,\"\n\t\t\t     \"tot_recs,\"\n\t\t\t     \"tot_loads,\"\n\t\t\t     \"tot_stores,\"\n\t\t\t     \"stores_l1hit,stores_l1miss,stores_na,\"\n\t\t\t     \"ld_fbhit,ld_l1hit,ld_l2hit,\"\n\t\t\t     \"ld_lclhit,lcl_hitm,\"\n\t\t\t     \"ld_rmthit,rmt_hitm,\"\n\t\t\t     \"dram_lcl,dram_rmt\";\n\n\tif (c2c.display == DISPLAY_TOT_HITM)\n\t\tsort_str = \"tot_hitm\";\n\telse if (c2c.display == DISPLAY_RMT_HITM)\n\t\tsort_str = \"rmt_hitm\";\n\telse if (c2c.display == DISPLAY_LCL_HITM)\n\t\tsort_str = \"lcl_hitm\";\n\telse if (c2c.display == DISPLAY_SNP_PEER)\n\t\tsort_str = \"tot_peer\";\n\n\tc2c_hists__reinit(&c2c.hists, output_str, sort_str);\n\n\tui_progress__init(&prog, c2c.hists.hists.nr_entries, \"Sorting...\");\n\n\thists__collapse_resort(&c2c.hists.hists, NULL);\n\thists__output_resort_cb(&c2c.hists.hists, &prog, resort_shared_cl_cb);\n\thists__iterate_cb(&c2c.hists.hists, resort_cl_cb);\n\n\tui_progress__finish();\n\n\tif (ui_quirks()) {\n\t\tpr_err(\"failed to setup UI\\n\");\n\t\tgoto out_mem2node;\n\t}\n\n\tperf_c2c_display(session);\n\nout_mem2node:\n\tmem2node__exit(&c2c.mem2node);\nout_session:\n\tperf_session__delete(session);\nout:\n\treturn err;\n}\n\nstatic int parse_record_events(const struct option *opt,\n\t\t\t       const char *str, int unset __maybe_unused)\n{\n\tbool *event_set = (bool *) opt->value;\n\n\tif (!strcmp(str, \"list\")) {\n\t\tperf_mem_events__list();\n\t\texit(0);\n\t}\n\tif (perf_mem_events__parse(str))\n\t\texit(-1);\n\n\t*event_set = true;\n\treturn 0;\n}\n\n\nstatic const char * const __usage_record[] = {\n\t\"perf c2c record [<options>] [<command>]\",\n\t\"perf c2c record [<options>] -- <command> [<options>]\",\n\tNULL\n};\n\nstatic const char * const *record_mem_usage = __usage_record;\n\nstatic int perf_c2c__record(int argc, const char **argv)\n{\n\tint rec_argc, i = 0, j, rec_tmp_nr = 0;\n\tconst char **rec_argv;\n\tchar **rec_tmp;\n\tint ret;\n\tbool all_user = false, all_kernel = false;\n\tbool event_set = false;\n\tstruct perf_mem_event *e;\n\tstruct option options[] = {\n\tOPT_CALLBACK('e', \"event\", &event_set, \"event\",\n\t\t     \"event selector. Use 'perf c2c record -e list' to list available events\",\n\t\t     parse_record_events),\n\tOPT_BOOLEAN('u', \"all-user\", &all_user, \"collect only user level data\"),\n\tOPT_BOOLEAN('k', \"all-kernel\", &all_kernel, \"collect only kernel level data\"),\n\tOPT_UINTEGER('l', \"ldlat\", &perf_mem_events__loads_ldlat, \"setup mem-loads latency\"),\n\tOPT_PARENT(c2c_options),\n\tOPT_END()\n\t};\n\n\tif (perf_mem_events__init()) {\n\t\tpr_err(\"failed: memory events not supported\\n\");\n\t\treturn -1;\n\t}\n\n\targc = parse_options(argc, argv, options, record_mem_usage,\n\t\t\t     PARSE_OPT_KEEP_UNKNOWN);\n\n\t \n\trec_argc = argc + 11 * perf_pmus__num_mem_pmus();\n\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\tif (!rec_argv)\n\t\treturn -1;\n\n\trec_tmp = calloc(rec_argc + 1, sizeof(char *));\n\tif (!rec_tmp) {\n\t\tfree(rec_argv);\n\t\treturn -1;\n\t}\n\n\trec_argv[i++] = \"record\";\n\n\tif (!event_set) {\n\t\te = perf_mem_events__ptr(PERF_MEM_EVENTS__LOAD_STORE);\n\t\t \n\t\tif (e->tag) {\n\t\t\te->record = true;\n\t\t\trec_argv[i++] = \"-W\";\n\t\t} else {\n\t\t\te = perf_mem_events__ptr(PERF_MEM_EVENTS__LOAD);\n\t\t\te->record = true;\n\n\t\t\te = perf_mem_events__ptr(PERF_MEM_EVENTS__STORE);\n\t\t\te->record = true;\n\t\t}\n\t}\n\n\te = perf_mem_events__ptr(PERF_MEM_EVENTS__LOAD);\n\tif (e->record)\n\t\trec_argv[i++] = \"-W\";\n\n\trec_argv[i++] = \"-d\";\n\trec_argv[i++] = \"--phys-data\";\n\trec_argv[i++] = \"--sample-cpu\";\n\n\tret = perf_mem_events__record_args(rec_argv, &i, rec_tmp, &rec_tmp_nr);\n\tif (ret)\n\t\tgoto out;\n\n\tif (all_user)\n\t\trec_argv[i++] = \"--all-user\";\n\n\tif (all_kernel)\n\t\trec_argv[i++] = \"--all-kernel\";\n\n\tfor (j = 0; j < argc; j++, i++)\n\t\trec_argv[i] = argv[j];\n\n\tif (verbose > 0) {\n\t\tpr_debug(\"calling: \");\n\n\t\tj = 0;\n\n\t\twhile (rec_argv[j]) {\n\t\t\tpr_debug(\"%s \", rec_argv[j]);\n\t\t\tj++;\n\t\t}\n\t\tpr_debug(\"\\n\");\n\t}\n\n\tret = cmd_record(i, rec_argv);\nout:\n\tfor (i = 0; i < rec_tmp_nr; i++)\n\t\tfree(rec_tmp[i]);\n\n\tfree(rec_tmp);\n\tfree(rec_argv);\n\treturn ret;\n}\n\nint cmd_c2c(int argc, const char **argv)\n{\n\targc = parse_options(argc, argv, c2c_options, c2c_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tif (!argc)\n\t\tusage_with_options(c2c_usage, c2c_options);\n\n\tif (strlen(argv[0]) > 2 && strstarts(\"record\", argv[0])) {\n\t\treturn perf_c2c__record(argc, argv);\n\t} else if (strlen(argv[0]) > 2 && strstarts(\"report\", argv[0])) {\n\t\treturn perf_c2c__report(argc, argv);\n\t} else {\n\t\tusage_with_options(c2c_usage, c2c_options);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}