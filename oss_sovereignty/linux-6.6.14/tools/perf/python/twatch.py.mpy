{
  "module_name": "twatch.py",
  "hash_id": "3d5a09751647bb9f3526af683acc829cd159960d88d0acb92e9ac8b3596b5e13",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/python/twatch.py",
  "human_readable_source": "#! /usr/bin/env python\n# SPDX-License-Identifier: GPL-2.0-only\n# -*- python -*-\n# -*- coding: utf-8 -*-\n#   twatch - Experimental use of the perf python interface\n#   Copyright (C) 2011 Arnaldo Carvalho de Melo <acme@redhat.com>\n#\n\nimport perf\n\ndef main(context_switch = 0, thread = -1):\n\tcpus = perf.cpu_map()\n\tthreads = perf.thread_map(thread)\n\tevsel = perf.evsel(type\t  = perf.TYPE_SOFTWARE,\n\t\t\t   config = perf.COUNT_SW_DUMMY,\n\t\t\t   task = 1, comm = 1, mmap = 0, freq = 0,\n\t\t\t   wakeup_events = 1, watermark = 1,\n\t\t\t   sample_id_all = 1, context_switch = context_switch,\n\t\t\t   sample_type = perf.SAMPLE_PERIOD | perf.SAMPLE_TID | perf.SAMPLE_CPU)\n\n\t\"\"\"What we want are just the PERF_RECORD_ lifetime events for threads,\n\t using the default, PERF_TYPE_HARDWARE + PERF_COUNT_HW_CYCLES & freq=1\n\t (the default), makes perf reenable irq_vectors:local_timer_entry, when\n\t disabling nohz, not good for some use cases where all we want is to get\n\t threads comes and goes... So use (perf.TYPE_SOFTWARE, perf_COUNT_SW_DUMMY,\n\t freq=0) instead.\"\"\"\n\n\tevsel.open(cpus = cpus, threads = threads);\n\tevlist = perf.evlist(cpus, threads)\n\tevlist.add(evsel)\n\tevlist.mmap()\n\twhile True:\n\t\tevlist.poll(timeout = -1)\n\t\tfor cpu in cpus:\n\t\t\tevent = evlist.read_on_cpu(cpu)\n\t\t\tif not event:\n\t\t\t\tcontinue\n\t\t\tprint(\"cpu: {0}, pid: {1}, tid: {2} {3}\".format(event.sample_cpu,\n                                                                        event.sample_pid,\n                                                                        event.sample_tid,\n                                                                        event))\n\nif __name__ == '__main__':\n    \"\"\"\n\tTo test the PERF_RECORD_SWITCH record, pick a pid and replace\n\tin the following line.\n\n\tExample output:\n\ncpu: 3, pid: 31463, tid: 31593 { type: context_switch, next_prev_pid: 31463, next_prev_tid: 31593, switch_out: 1 }\ncpu: 1, pid: 31463, tid: 31489 { type: context_switch, next_prev_pid: 31463, next_prev_tid: 31489, switch_out: 1 }\ncpu: 2, pid: 31463, tid: 31496 { type: context_switch, next_prev_pid: 31463, next_prev_tid: 31496, switch_out: 1 }\ncpu: 3, pid: 31463, tid: 31491 { type: context_switch, next_prev_pid: 31463, next_prev_tid: 31491, switch_out: 0 }\n\n\tIt is possible as well to use event.misc & perf.PERF_RECORD_MISC_SWITCH_OUT\n\tto figure out if this is a context switch in or out of the monitored threads.\n\n\tIf bored, please add command line option parsing support for these options :-)\n    \"\"\"\n    # main(context_switch = 1, thread = 31463)\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}