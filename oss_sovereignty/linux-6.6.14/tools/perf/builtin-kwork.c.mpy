{
  "module_name": "builtin-kwork.c",
  "hash_id": "fef1ff70cf900069c2a61da023c2e3671eee6af0b8de65fd4c264eafe5669bbc",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-kwork.c",
  "human_readable_source": "\n \n\n#include \"builtin.h\"\n\n#include \"util/data.h\"\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/header.h\"\n#include \"util/kwork.h\"\n#include \"util/debug.h\"\n#include \"util/session.h\"\n#include \"util/symbol.h\"\n#include \"util/thread.h\"\n#include \"util/string2.h\"\n#include \"util/callchain.h\"\n#include \"util/evsel_fprintf.h\"\n#include \"util/util.h\"\n\n#include <subcmd/pager.h>\n#include <subcmd/parse-options.h>\n#include <traceevent/event-parse.h>\n\n#include <errno.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <linux/err.h>\n#include <linux/time64.h>\n#include <linux/zalloc.h>\n\n \n#define PRINT_CPU_WIDTH 4\n#define PRINT_COUNT_WIDTH 9\n#define PRINT_RUNTIME_WIDTH 10\n#define PRINT_LATENCY_WIDTH 10\n#define PRINT_TIMESTAMP_WIDTH 17\n#define PRINT_KWORK_NAME_WIDTH 30\n#define RPINT_DECIMAL_WIDTH 3\n#define PRINT_BRACKETPAIR_WIDTH 2\n#define PRINT_TIME_UNIT_SEC_WIDTH 2\n#define PRINT_TIME_UNIT_MESC_WIDTH 3\n#define PRINT_RUNTIME_HEADER_WIDTH (PRINT_RUNTIME_WIDTH + PRINT_TIME_UNIT_MESC_WIDTH)\n#define PRINT_LATENCY_HEADER_WIDTH (PRINT_LATENCY_WIDTH + PRINT_TIME_UNIT_MESC_WIDTH)\n#define PRINT_TIMEHIST_CPU_WIDTH (PRINT_CPU_WIDTH + PRINT_BRACKETPAIR_WIDTH)\n#define PRINT_TIMESTAMP_HEADER_WIDTH (PRINT_TIMESTAMP_WIDTH + PRINT_TIME_UNIT_SEC_WIDTH)\n\nstruct sort_dimension {\n\tconst char      *name;\n\tint             (*cmp)(struct kwork_work *l, struct kwork_work *r);\n\tstruct          list_head list;\n};\n\nstatic int id_cmp(struct kwork_work *l, struct kwork_work *r)\n{\n\tif (l->cpu > r->cpu)\n\t\treturn 1;\n\tif (l->cpu < r->cpu)\n\t\treturn -1;\n\n\tif (l->id > r->id)\n\t\treturn 1;\n\tif (l->id < r->id)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int count_cmp(struct kwork_work *l, struct kwork_work *r)\n{\n\tif (l->nr_atoms > r->nr_atoms)\n\t\treturn 1;\n\tif (l->nr_atoms < r->nr_atoms)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int runtime_cmp(struct kwork_work *l, struct kwork_work *r)\n{\n\tif (l->total_runtime > r->total_runtime)\n\t\treturn 1;\n\tif (l->total_runtime < r->total_runtime)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int max_runtime_cmp(struct kwork_work *l, struct kwork_work *r)\n{\n\tif (l->max_runtime > r->max_runtime)\n\t\treturn 1;\n\tif (l->max_runtime < r->max_runtime)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int avg_latency_cmp(struct kwork_work *l, struct kwork_work *r)\n{\n\tu64 avgl, avgr;\n\n\tif (!r->nr_atoms)\n\t\treturn 1;\n\tif (!l->nr_atoms)\n\t\treturn -1;\n\n\tavgl = l->total_latency / l->nr_atoms;\n\tavgr = r->total_latency / r->nr_atoms;\n\n\tif (avgl > avgr)\n\t\treturn 1;\n\tif (avgl < avgr)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int max_latency_cmp(struct kwork_work *l, struct kwork_work *r)\n{\n\tif (l->max_latency > r->max_latency)\n\t\treturn 1;\n\tif (l->max_latency < r->max_latency)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int sort_dimension__add(struct perf_kwork *kwork __maybe_unused,\n\t\t\t       const char *tok, struct list_head *list)\n{\n\tsize_t i;\n\tstatic struct sort_dimension max_sort_dimension = {\n\t\t.name = \"max\",\n\t\t.cmp  = max_runtime_cmp,\n\t};\n\tstatic struct sort_dimension id_sort_dimension = {\n\t\t.name = \"id\",\n\t\t.cmp  = id_cmp,\n\t};\n\tstatic struct sort_dimension runtime_sort_dimension = {\n\t\t.name = \"runtime\",\n\t\t.cmp  = runtime_cmp,\n\t};\n\tstatic struct sort_dimension count_sort_dimension = {\n\t\t.name = \"count\",\n\t\t.cmp  = count_cmp,\n\t};\n\tstatic struct sort_dimension avg_sort_dimension = {\n\t\t.name = \"avg\",\n\t\t.cmp  = avg_latency_cmp,\n\t};\n\tstruct sort_dimension *available_sorts[] = {\n\t\t&id_sort_dimension,\n\t\t&max_sort_dimension,\n\t\t&count_sort_dimension,\n\t\t&runtime_sort_dimension,\n\t\t&avg_sort_dimension,\n\t};\n\n\tif (kwork->report == KWORK_REPORT_LATENCY)\n\t\tmax_sort_dimension.cmp = max_latency_cmp;\n\n\tfor (i = 0; i < ARRAY_SIZE(available_sorts); i++) {\n\t\tif (!strcmp(available_sorts[i]->name, tok)) {\n\t\t\tlist_add_tail(&available_sorts[i]->list, list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic void setup_sorting(struct perf_kwork *kwork,\n\t\t\t  const struct option *options,\n\t\t\t  const char * const usage_msg[])\n{\n\tchar *tmp, *tok, *str = strdup(kwork->sort_order);\n\n\tfor (tok = strtok_r(str, \", \", &tmp);\n\t     tok; tok = strtok_r(NULL, \", \", &tmp)) {\n\t\tif (sort_dimension__add(kwork, tok, &kwork->sort_list) < 0)\n\t\t\tusage_with_options_msg(usage_msg, options,\n\t\t\t\t\t       \"Unknown --sort key: `%s'\", tok);\n\t}\n\n\tpr_debug(\"Sort order: %s\\n\", kwork->sort_order);\n\tfree(str);\n}\n\nstatic struct kwork_atom *atom_new(struct perf_kwork *kwork,\n\t\t\t\t   struct perf_sample *sample)\n{\n\tunsigned long i;\n\tstruct kwork_atom_page *page;\n\tstruct kwork_atom *atom = NULL;\n\n\tlist_for_each_entry(page, &kwork->atom_page_list, list) {\n\t\tif (!bitmap_full(page->bitmap, NR_ATOM_PER_PAGE)) {\n\t\t\ti = find_first_zero_bit(page->bitmap, NR_ATOM_PER_PAGE);\n\t\t\tBUG_ON(i >= NR_ATOM_PER_PAGE);\n\t\t\tatom = &page->atoms[i];\n\t\t\tgoto found_atom;\n\t\t}\n\t}\n\n\t \n\tpage = zalloc(sizeof(*page));\n\tif (page == NULL) {\n\t\tpr_err(\"Failed to zalloc kwork atom page\\n\");\n\t\treturn NULL;\n\t}\n\n\ti = 0;\n\tatom = &page->atoms[0];\n\tlist_add_tail(&page->list, &kwork->atom_page_list);\n\nfound_atom:\n\t__set_bit(i, page->bitmap);\n\tatom->time = sample->time;\n\tatom->prev = NULL;\n\tatom->page_addr = page;\n\tatom->bit_inpage = i;\n\treturn atom;\n}\n\nstatic void atom_free(struct kwork_atom *atom)\n{\n\tif (atom->prev != NULL)\n\t\tatom_free(atom->prev);\n\n\t__clear_bit(atom->bit_inpage,\n\t\t    ((struct kwork_atom_page *)atom->page_addr)->bitmap);\n}\n\nstatic void atom_del(struct kwork_atom *atom)\n{\n\tlist_del(&atom->list);\n\tatom_free(atom);\n}\n\nstatic int work_cmp(struct list_head *list,\n\t\t    struct kwork_work *l, struct kwork_work *r)\n{\n\tint ret = 0;\n\tstruct sort_dimension *sort;\n\n\tBUG_ON(list_empty(list));\n\n\tlist_for_each_entry(sort, list, list) {\n\t\tret = sort->cmp(l, r);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic struct kwork_work *work_search(struct rb_root_cached *root,\n\t\t\t\t      struct kwork_work *key,\n\t\t\t\t      struct list_head *sort_list)\n{\n\tint cmp;\n\tstruct kwork_work *work;\n\tstruct rb_node *node = root->rb_root.rb_node;\n\n\twhile (node) {\n\t\twork = container_of(node, struct kwork_work, node);\n\t\tcmp = work_cmp(sort_list, key, work);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tif (work->name == NULL)\n\t\t\t\twork->name = key->name;\n\t\t\treturn work;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void work_insert(struct rb_root_cached *root,\n\t\t\tstruct kwork_work *key, struct list_head *sort_list)\n{\n\tint cmp;\n\tbool leftmost = true;\n\tstruct kwork_work *cur;\n\tstruct rb_node **new = &(root->rb_root.rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tcur = container_of(*new, struct kwork_work, node);\n\t\tparent = *new;\n\t\tcmp = work_cmp(sort_list, key, cur);\n\n\t\tif (cmp > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse {\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\trb_link_node(&key->node, parent, new);\n\trb_insert_color_cached(&key->node, root, leftmost);\n}\n\nstatic struct kwork_work *work_new(struct kwork_work *key)\n{\n\tint i;\n\tstruct kwork_work *work = zalloc(sizeof(*work));\n\n\tif (work == NULL) {\n\t\tpr_err(\"Failed to zalloc kwork work\\n\");\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < KWORK_TRACE_MAX; i++)\n\t\tINIT_LIST_HEAD(&work->atom_list[i]);\n\n\twork->id = key->id;\n\twork->cpu = key->cpu;\n\twork->name = key->name;\n\twork->class = key->class;\n\treturn work;\n}\n\nstatic struct kwork_work *work_findnew(struct rb_root_cached *root,\n\t\t\t\t       struct kwork_work *key,\n\t\t\t\t       struct list_head *sort_list)\n{\n\tstruct kwork_work *work = work_search(root, key, sort_list);\n\n\tif (work != NULL)\n\t\treturn work;\n\n\twork = work_new(key);\n\tif (work)\n\t\twork_insert(root, work, sort_list);\n\n\treturn work;\n}\n\nstatic void profile_update_timespan(struct perf_kwork *kwork,\n\t\t\t\t    struct perf_sample *sample)\n{\n\tif (!kwork->summary)\n\t\treturn;\n\n\tif ((kwork->timestart == 0) || (kwork->timestart > sample->time))\n\t\tkwork->timestart = sample->time;\n\n\tif (kwork->timeend < sample->time)\n\t\tkwork->timeend = sample->time;\n}\n\nstatic bool profile_event_match(struct perf_kwork *kwork,\n\t\t\t\tstruct kwork_work *work,\n\t\t\t\tstruct perf_sample *sample)\n{\n\tint cpu = work->cpu;\n\tu64 time = sample->time;\n\tstruct perf_time_interval *ptime = &kwork->ptime;\n\n\tif ((kwork->cpu_list != NULL) && !test_bit(cpu, kwork->cpu_bitmap))\n\t\treturn false;\n\n\tif (((ptime->start != 0) && (ptime->start > time)) ||\n\t    ((ptime->end != 0) && (ptime->end < time)))\n\t\treturn false;\n\n\tif ((kwork->profile_name != NULL) &&\n\t    (work->name != NULL) &&\n\t    (strcmp(work->name, kwork->profile_name) != 0))\n\t\treturn false;\n\n\tprofile_update_timespan(kwork, sample);\n\treturn true;\n}\n\nstatic int work_push_atom(struct perf_kwork *kwork,\n\t\t\t  struct kwork_class *class,\n\t\t\t  enum kwork_trace_type src_type,\n\t\t\t  enum kwork_trace_type dst_type,\n\t\t\t  struct evsel *evsel,\n\t\t\t  struct perf_sample *sample,\n\t\t\t  struct machine *machine,\n\t\t\t  struct kwork_work **ret_work)\n{\n\tstruct kwork_atom *atom, *dst_atom;\n\tstruct kwork_work *work, key;\n\n\tBUG_ON(class->work_init == NULL);\n\tclass->work_init(class, &key, evsel, sample, machine);\n\n\tatom = atom_new(kwork, sample);\n\tif (atom == NULL)\n\t\treturn -1;\n\n\twork = work_findnew(&class->work_root, &key, &kwork->cmp_id);\n\tif (work == NULL) {\n\t\tatom_free(atom);\n\t\treturn -1;\n\t}\n\n\tif (!profile_event_match(kwork, work, sample)) {\n\t\tatom_free(atom);\n\t\treturn 0;\n\t}\n\n\tif (dst_type < KWORK_TRACE_MAX) {\n\t\tdst_atom = list_last_entry_or_null(&work->atom_list[dst_type],\n\t\t\t\t\t\t   struct kwork_atom, list);\n\t\tif (dst_atom != NULL) {\n\t\t\tatom->prev = dst_atom;\n\t\t\tlist_del(&dst_atom->list);\n\t\t}\n\t}\n\n\tif (ret_work != NULL)\n\t\t*ret_work = work;\n\n\tlist_add_tail(&atom->list, &work->atom_list[src_type]);\n\n\treturn 0;\n}\n\nstatic struct kwork_atom *work_pop_atom(struct perf_kwork *kwork,\n\t\t\t\t\tstruct kwork_class *class,\n\t\t\t\t\tenum kwork_trace_type src_type,\n\t\t\t\t\tenum kwork_trace_type dst_type,\n\t\t\t\t\tstruct evsel *evsel,\n\t\t\t\t\tstruct perf_sample *sample,\n\t\t\t\t\tstruct machine *machine,\n\t\t\t\t\tstruct kwork_work **ret_work)\n{\n\tstruct kwork_atom *atom, *src_atom;\n\tstruct kwork_work *work, key;\n\n\tBUG_ON(class->work_init == NULL);\n\tclass->work_init(class, &key, evsel, sample, machine);\n\n\twork = work_findnew(&class->work_root, &key, &kwork->cmp_id);\n\tif (ret_work != NULL)\n\t\t*ret_work = work;\n\n\tif (work == NULL)\n\t\treturn NULL;\n\n\tif (!profile_event_match(kwork, work, sample))\n\t\treturn NULL;\n\n\tatom = list_last_entry_or_null(&work->atom_list[dst_type],\n\t\t\t\t       struct kwork_atom, list);\n\tif (atom != NULL)\n\t\treturn atom;\n\n\tsrc_atom = atom_new(kwork, sample);\n\tif (src_atom != NULL)\n\t\tlist_add_tail(&src_atom->list, &work->atom_list[src_type]);\n\telse {\n\t\tif (ret_work != NULL)\n\t\t\t*ret_work = NULL;\n\t}\n\n\treturn NULL;\n}\n\nstatic void report_update_exit_event(struct kwork_work *work,\n\t\t\t\t     struct kwork_atom *atom,\n\t\t\t\t     struct perf_sample *sample)\n{\n\tu64 delta;\n\tu64 exit_time = sample->time;\n\tu64 entry_time = atom->time;\n\n\tif ((entry_time != 0) && (exit_time >= entry_time)) {\n\t\tdelta = exit_time - entry_time;\n\t\tif ((delta > work->max_runtime) ||\n\t\t    (work->max_runtime == 0)) {\n\t\t\twork->max_runtime = delta;\n\t\t\twork->max_runtime_start = entry_time;\n\t\t\twork->max_runtime_end = exit_time;\n\t\t}\n\t\twork->total_runtime += delta;\n\t\twork->nr_atoms++;\n\t}\n}\n\nstatic int report_entry_event(struct perf_kwork *kwork,\n\t\t\t      struct kwork_class *class,\n\t\t\t      struct evsel *evsel,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct machine *machine)\n{\n\treturn work_push_atom(kwork, class, KWORK_TRACE_ENTRY,\n\t\t\t      KWORK_TRACE_MAX, evsel, sample,\n\t\t\t      machine, NULL);\n}\n\nstatic int report_exit_event(struct perf_kwork *kwork,\n\t\t\t     struct kwork_class *class,\n\t\t\t     struct evsel *evsel,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     struct machine *machine)\n{\n\tstruct kwork_atom *atom = NULL;\n\tstruct kwork_work *work = NULL;\n\n\tatom = work_pop_atom(kwork, class, KWORK_TRACE_EXIT,\n\t\t\t     KWORK_TRACE_ENTRY, evsel, sample,\n\t\t\t     machine, &work);\n\tif (work == NULL)\n\t\treturn -1;\n\n\tif (atom != NULL) {\n\t\treport_update_exit_event(work, atom, sample);\n\t\tatom_del(atom);\n\t}\n\n\treturn 0;\n}\n\nstatic void latency_update_entry_event(struct kwork_work *work,\n\t\t\t\t       struct kwork_atom *atom,\n\t\t\t\t       struct perf_sample *sample)\n{\n\tu64 delta;\n\tu64 entry_time = sample->time;\n\tu64 raise_time = atom->time;\n\n\tif ((raise_time != 0) && (entry_time >= raise_time)) {\n\t\tdelta = entry_time - raise_time;\n\t\tif ((delta > work->max_latency) ||\n\t\t    (work->max_latency == 0)) {\n\t\t\twork->max_latency = delta;\n\t\t\twork->max_latency_start = raise_time;\n\t\t\twork->max_latency_end = entry_time;\n\t\t}\n\t\twork->total_latency += delta;\n\t\twork->nr_atoms++;\n\t}\n}\n\nstatic int latency_raise_event(struct perf_kwork *kwork,\n\t\t\t       struct kwork_class *class,\n\t\t\t       struct evsel *evsel,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       struct machine *machine)\n{\n\treturn work_push_atom(kwork, class, KWORK_TRACE_RAISE,\n\t\t\t      KWORK_TRACE_MAX, evsel, sample,\n\t\t\t      machine, NULL);\n}\n\nstatic int latency_entry_event(struct perf_kwork *kwork,\n\t\t\t       struct kwork_class *class,\n\t\t\t       struct evsel *evsel,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       struct machine *machine)\n{\n\tstruct kwork_atom *atom = NULL;\n\tstruct kwork_work *work = NULL;\n\n\tatom = work_pop_atom(kwork, class, KWORK_TRACE_ENTRY,\n\t\t\t     KWORK_TRACE_RAISE, evsel, sample,\n\t\t\t     machine, &work);\n\tif (work == NULL)\n\t\treturn -1;\n\n\tif (atom != NULL) {\n\t\tlatency_update_entry_event(work, atom, sample);\n\t\tatom_del(atom);\n\t}\n\n\treturn 0;\n}\n\nstatic void timehist_save_callchain(struct perf_kwork *kwork,\n\t\t\t\t    struct perf_sample *sample,\n\t\t\t\t    struct evsel *evsel,\n\t\t\t\t    struct machine *machine)\n{\n\tstruct symbol *sym;\n\tstruct thread *thread;\n\tstruct callchain_cursor_node *node;\n\tstruct callchain_cursor *cursor;\n\n\tif (!kwork->show_callchain || sample->callchain == NULL)\n\t\treturn;\n\n\t \n\tthread = machine__findnew_thread(machine, sample->pid, sample->pid);\n\tif (thread == NULL) {\n\t\tpr_debug(\"Failed to get thread for pid %d\\n\", sample->pid);\n\t\treturn;\n\t}\n\n\tcursor = get_tls_callchain_cursor();\n\n\tif (thread__resolve_callchain(thread, cursor, evsel, sample,\n\t\t\t\t      NULL, NULL, kwork->max_stack + 2) != 0) {\n\t\tpr_debug(\"Failed to resolve callchain, skipping\\n\");\n\t\tgoto out_put;\n\t}\n\n\tcallchain_cursor_commit(cursor);\n\n\twhile (true) {\n\t\tnode = callchain_cursor_current(cursor);\n\t\tif (node == NULL)\n\t\t\tbreak;\n\n\t\tsym = node->ms.sym;\n\t\tif (sym) {\n\t\t\tif (!strcmp(sym->name, \"__softirqentry_text_start\") ||\n\t\t\t    !strcmp(sym->name, \"__do_softirq\"))\n\t\t\t\tsym->ignore = 1;\n\t\t}\n\n\t\tcallchain_cursor_advance(cursor);\n\t}\n\nout_put:\n\tthread__put(thread);\n}\n\nstatic void timehist_print_event(struct perf_kwork *kwork,\n\t\t\t\t struct kwork_work *work,\n\t\t\t\t struct kwork_atom *atom,\n\t\t\t\t struct perf_sample *sample,\n\t\t\t\t struct addr_location *al)\n{\n\tchar entrytime[32], exittime[32];\n\tchar kwork_name[PRINT_KWORK_NAME_WIDTH];\n\n\t \n\ttimestamp__scnprintf_usec(atom->time,\n\t\t\t\t  entrytime, sizeof(entrytime));\n\tprintf(\" %*s \", PRINT_TIMESTAMP_WIDTH, entrytime);\n\n\t \n\ttimestamp__scnprintf_usec(sample->time,\n\t\t\t\t  exittime, sizeof(exittime));\n\tprintf(\" %*s \", PRINT_TIMESTAMP_WIDTH, exittime);\n\n\t \n\tprintf(\" [%0*d] \", PRINT_CPU_WIDTH, work->cpu);\n\n\t \n\tif (work->class && work->class->work_name) {\n\t\twork->class->work_name(work, kwork_name,\n\t\t\t\t       PRINT_KWORK_NAME_WIDTH);\n\t\tprintf(\" %-*s \", PRINT_KWORK_NAME_WIDTH, kwork_name);\n\t} else\n\t\tprintf(\" %-*s \", PRINT_KWORK_NAME_WIDTH, \"\");\n\n\t \n\tprintf(\" %*.*f \",\n\t       PRINT_RUNTIME_WIDTH, RPINT_DECIMAL_WIDTH,\n\t       (double)(sample->time - atom->time) / NSEC_PER_MSEC);\n\n\t \n\tif (atom->prev != NULL)\n\t\tprintf(\" %*.*f \", PRINT_LATENCY_WIDTH, RPINT_DECIMAL_WIDTH,\n\t\t       (double)(atom->time - atom->prev->time) / NSEC_PER_MSEC);\n\telse\n\t\tprintf(\" %*s \", PRINT_LATENCY_WIDTH, \" \");\n\n\t \n\tif (kwork->show_callchain) {\n\t\tstruct callchain_cursor *cursor = get_tls_callchain_cursor();\n\n\t\tif (cursor == NULL)\n\t\t\treturn;\n\n\t\tprintf(\" \");\n\n\t\tsample__fprintf_sym(sample, al, 0,\n\t\t\t\t    EVSEL__PRINT_SYM | EVSEL__PRINT_ONELINE |\n\t\t\t\t    EVSEL__PRINT_CALLCHAIN_ARROW |\n\t\t\t\t    EVSEL__PRINT_SKIP_IGNORED,\n\t\t\t\t    cursor, symbol_conf.bt_stop_list,\n\t\t\t\t    stdout);\n\t}\n\n\tprintf(\"\\n\");\n}\n\nstatic int timehist_raise_event(struct perf_kwork *kwork,\n\t\t\t\tstruct kwork_class *class,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct machine *machine)\n{\n\treturn work_push_atom(kwork, class, KWORK_TRACE_RAISE,\n\t\t\t      KWORK_TRACE_MAX, evsel, sample,\n\t\t\t      machine, NULL);\n}\n\nstatic int timehist_entry_event(struct perf_kwork *kwork,\n\t\t\t\tstruct kwork_class *class,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct machine *machine)\n{\n\tint ret;\n\tstruct kwork_work *work = NULL;\n\n\tret = work_push_atom(kwork, class, KWORK_TRACE_ENTRY,\n\t\t\t     KWORK_TRACE_RAISE, evsel, sample,\n\t\t\t     machine, &work);\n\tif (ret)\n\t\treturn ret;\n\n\tif (work != NULL)\n\t\ttimehist_save_callchain(kwork, sample, evsel, machine);\n\n\treturn 0;\n}\n\nstatic int timehist_exit_event(struct perf_kwork *kwork,\n\t\t\t       struct kwork_class *class,\n\t\t\t       struct evsel *evsel,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       struct machine *machine)\n{\n\tstruct kwork_atom *atom = NULL;\n\tstruct kwork_work *work = NULL;\n\tstruct addr_location al;\n\tint ret = 0;\n\n\taddr_location__init(&al);\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tpr_debug(\"Problem processing event, skipping it\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tatom = work_pop_atom(kwork, class, KWORK_TRACE_EXIT,\n\t\t\t     KWORK_TRACE_ENTRY, evsel, sample,\n\t\t\t     machine, &work);\n\tif (work == NULL) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (atom != NULL) {\n\t\twork->nr_atoms++;\n\t\ttimehist_print_event(kwork, work, atom, sample, &al);\n\t\tatom_del(atom);\n\t}\n\nout:\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic struct kwork_class kwork_irq;\nstatic int process_irq_handler_entry_event(struct perf_tool *tool,\n\t\t\t\t\t   struct evsel *evsel,\n\t\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t\t   struct machine *machine)\n{\n\tstruct perf_kwork *kwork = container_of(tool, struct perf_kwork, tool);\n\n\tif (kwork->tp_handler->entry_event)\n\t\treturn kwork->tp_handler->entry_event(kwork, &kwork_irq,\n\t\t\t\t\t\t      evsel, sample, machine);\n\treturn 0;\n}\n\nstatic int process_irq_handler_exit_event(struct perf_tool *tool,\n\t\t\t\t\t  struct evsel *evsel,\n\t\t\t\t\t  struct perf_sample *sample,\n\t\t\t\t\t  struct machine *machine)\n{\n\tstruct perf_kwork *kwork = container_of(tool, struct perf_kwork, tool);\n\n\tif (kwork->tp_handler->exit_event)\n\t\treturn kwork->tp_handler->exit_event(kwork, &kwork_irq,\n\t\t\t\t\t\t     evsel, sample, machine);\n\treturn 0;\n}\n\nconst struct evsel_str_handler irq_tp_handlers[] = {\n\t{ \"irq:irq_handler_entry\", process_irq_handler_entry_event, },\n\t{ \"irq:irq_handler_exit\",  process_irq_handler_exit_event,  },\n};\n\nstatic int irq_class_init(struct kwork_class *class,\n\t\t\t  struct perf_session *session)\n{\n\tif (perf_session__set_tracepoints_handlers(session, irq_tp_handlers)) {\n\t\tpr_err(\"Failed to set irq tracepoints handlers\\n\");\n\t\treturn -1;\n\t}\n\n\tclass->work_root = RB_ROOT_CACHED;\n\treturn 0;\n}\n\nstatic void irq_work_init(struct kwork_class *class,\n\t\t\t  struct kwork_work *work,\n\t\t\t  struct evsel *evsel,\n\t\t\t  struct perf_sample *sample,\n\t\t\t  struct machine *machine __maybe_unused)\n{\n\twork->class = class;\n\twork->cpu = sample->cpu;\n\twork->id = evsel__intval(evsel, sample, \"irq\");\n\twork->name = evsel__strval(evsel, sample, \"name\");\n}\n\nstatic void irq_work_name(struct kwork_work *work, char *buf, int len)\n{\n\tsnprintf(buf, len, \"%s:%\" PRIu64 \"\", work->name, work->id);\n}\n\nstatic struct kwork_class kwork_irq = {\n\t.name           = \"irq\",\n\t.type           = KWORK_CLASS_IRQ,\n\t.nr_tracepoints = 2,\n\t.tp_handlers    = irq_tp_handlers,\n\t.class_init     = irq_class_init,\n\t.work_init      = irq_work_init,\n\t.work_name      = irq_work_name,\n};\n\nstatic struct kwork_class kwork_softirq;\nstatic int process_softirq_raise_event(struct perf_tool *tool,\n\t\t\t\t       struct evsel *evsel,\n\t\t\t\t       struct perf_sample *sample,\n\t\t\t\t       struct machine *machine)\n{\n\tstruct perf_kwork *kwork = container_of(tool, struct perf_kwork, tool);\n\n\tif (kwork->tp_handler->raise_event)\n\t\treturn kwork->tp_handler->raise_event(kwork, &kwork_softirq,\n\t\t\t\t\t\t      evsel, sample, machine);\n\n\treturn 0;\n}\n\nstatic int process_softirq_entry_event(struct perf_tool *tool,\n\t\t\t\t       struct evsel *evsel,\n\t\t\t\t       struct perf_sample *sample,\n\t\t\t\t       struct machine *machine)\n{\n\tstruct perf_kwork *kwork = container_of(tool, struct perf_kwork, tool);\n\n\tif (kwork->tp_handler->entry_event)\n\t\treturn kwork->tp_handler->entry_event(kwork, &kwork_softirq,\n\t\t\t\t\t\t      evsel, sample, machine);\n\n\treturn 0;\n}\n\nstatic int process_softirq_exit_event(struct perf_tool *tool,\n\t\t\t\t      struct evsel *evsel,\n\t\t\t\t      struct perf_sample *sample,\n\t\t\t\t      struct machine *machine)\n{\n\tstruct perf_kwork *kwork = container_of(tool, struct perf_kwork, tool);\n\n\tif (kwork->tp_handler->exit_event)\n\t\treturn kwork->tp_handler->exit_event(kwork, &kwork_softirq,\n\t\t\t\t\t\t     evsel, sample, machine);\n\n\treturn 0;\n}\n\nconst struct evsel_str_handler softirq_tp_handlers[] = {\n\t{ \"irq:softirq_raise\", process_softirq_raise_event, },\n\t{ \"irq:softirq_entry\", process_softirq_entry_event, },\n\t{ \"irq:softirq_exit\",  process_softirq_exit_event,  },\n};\n\nstatic int softirq_class_init(struct kwork_class *class,\n\t\t\t      struct perf_session *session)\n{\n\tif (perf_session__set_tracepoints_handlers(session,\n\t\t\t\t\t\t   softirq_tp_handlers)) {\n\t\tpr_err(\"Failed to set softirq tracepoints handlers\\n\");\n\t\treturn -1;\n\t}\n\n\tclass->work_root = RB_ROOT_CACHED;\n\treturn 0;\n}\n\nstatic char *evsel__softirq_name(struct evsel *evsel, u64 num)\n{\n\tchar *name = NULL;\n\tbool found = false;\n\tstruct tep_print_flag_sym *sym = NULL;\n\tstruct tep_print_arg *args = evsel->tp_format->print_fmt.args;\n\n\tif ((args == NULL) || (args->next == NULL))\n\t\treturn NULL;\n\n\t \n\tfor (sym = args->next->symbol.symbols; sym != NULL; sym = sym->next) {\n\t\tif ((eval_flag(sym->value) == (unsigned long long)num) &&\n\t\t    (strlen(sym->str) != 0)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn NULL;\n\n\tname = strdup(sym->str);\n\tif (name == NULL) {\n\t\tpr_err(\"Failed to copy symbol name\\n\");\n\t\treturn NULL;\n\t}\n\treturn name;\n}\n\nstatic void softirq_work_init(struct kwork_class *class,\n\t\t\t      struct kwork_work *work,\n\t\t\t      struct evsel *evsel,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct machine *machine __maybe_unused)\n{\n\tu64 num = evsel__intval(evsel, sample, \"vec\");\n\n\twork->id = num;\n\twork->class = class;\n\twork->cpu = sample->cpu;\n\twork->name = evsel__softirq_name(evsel, num);\n}\n\nstatic void softirq_work_name(struct kwork_work *work, char *buf, int len)\n{\n\tsnprintf(buf, len, \"(s)%s:%\" PRIu64 \"\", work->name, work->id);\n}\n\nstatic struct kwork_class kwork_softirq = {\n\t.name           = \"softirq\",\n\t.type           = KWORK_CLASS_SOFTIRQ,\n\t.nr_tracepoints = 3,\n\t.tp_handlers    = softirq_tp_handlers,\n\t.class_init     = softirq_class_init,\n\t.work_init      = softirq_work_init,\n\t.work_name      = softirq_work_name,\n};\n\nstatic struct kwork_class kwork_workqueue;\nstatic int process_workqueue_activate_work_event(struct perf_tool *tool,\n\t\t\t\t\t\t struct evsel *evsel,\n\t\t\t\t\t\t struct perf_sample *sample,\n\t\t\t\t\t\t struct machine *machine)\n{\n\tstruct perf_kwork *kwork = container_of(tool, struct perf_kwork, tool);\n\n\tif (kwork->tp_handler->raise_event)\n\t\treturn kwork->tp_handler->raise_event(kwork, &kwork_workqueue,\n\t\t\t\t\t\t    evsel, sample, machine);\n\n\treturn 0;\n}\n\nstatic int process_workqueue_execute_start_event(struct perf_tool *tool,\n\t\t\t\t\t\t struct evsel *evsel,\n\t\t\t\t\t\t struct perf_sample *sample,\n\t\t\t\t\t\t struct machine *machine)\n{\n\tstruct perf_kwork *kwork = container_of(tool, struct perf_kwork, tool);\n\n\tif (kwork->tp_handler->entry_event)\n\t\treturn kwork->tp_handler->entry_event(kwork, &kwork_workqueue,\n\t\t\t\t\t\t    evsel, sample, machine);\n\n\treturn 0;\n}\n\nstatic int process_workqueue_execute_end_event(struct perf_tool *tool,\n\t\t\t\t\t       struct evsel *evsel,\n\t\t\t\t\t       struct perf_sample *sample,\n\t\t\t\t\t       struct machine *machine)\n{\n\tstruct perf_kwork *kwork = container_of(tool, struct perf_kwork, tool);\n\n\tif (kwork->tp_handler->exit_event)\n\t\treturn kwork->tp_handler->exit_event(kwork, &kwork_workqueue,\n\t\t\t\t\t\t   evsel, sample, machine);\n\n\treturn 0;\n}\n\nconst struct evsel_str_handler workqueue_tp_handlers[] = {\n\t{ \"workqueue:workqueue_activate_work\", process_workqueue_activate_work_event, },\n\t{ \"workqueue:workqueue_execute_start\", process_workqueue_execute_start_event, },\n\t{ \"workqueue:workqueue_execute_end\",   process_workqueue_execute_end_event,   },\n};\n\nstatic int workqueue_class_init(struct kwork_class *class,\n\t\t\t\tstruct perf_session *session)\n{\n\tif (perf_session__set_tracepoints_handlers(session,\n\t\t\t\t\t\t   workqueue_tp_handlers)) {\n\t\tpr_err(\"Failed to set workqueue tracepoints handlers\\n\");\n\t\treturn -1;\n\t}\n\n\tclass->work_root = RB_ROOT_CACHED;\n\treturn 0;\n}\n\nstatic void workqueue_work_init(struct kwork_class *class,\n\t\t\t\tstruct kwork_work *work,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct machine *machine)\n{\n\tchar *modp = NULL;\n\tunsigned long long function_addr = evsel__intval(evsel,\n\t\t\t\t\t\t\t sample, \"function\");\n\n\twork->class = class;\n\twork->cpu = sample->cpu;\n\twork->id = evsel__intval(evsel, sample, \"work\");\n\twork->name = function_addr == 0 ? NULL :\n\t\tmachine__resolve_kernel_addr(machine, &function_addr, &modp);\n}\n\nstatic void workqueue_work_name(struct kwork_work *work, char *buf, int len)\n{\n\tif (work->name != NULL)\n\t\tsnprintf(buf, len, \"(w)%s\", work->name);\n\telse\n\t\tsnprintf(buf, len, \"(w)0x%\" PRIx64, work->id);\n}\n\nstatic struct kwork_class kwork_workqueue = {\n\t.name           = \"workqueue\",\n\t.type           = KWORK_CLASS_WORKQUEUE,\n\t.nr_tracepoints = 3,\n\t.tp_handlers    = workqueue_tp_handlers,\n\t.class_init     = workqueue_class_init,\n\t.work_init      = workqueue_work_init,\n\t.work_name      = workqueue_work_name,\n};\n\nstatic struct kwork_class *kwork_class_supported_list[KWORK_CLASS_MAX] = {\n\t[KWORK_CLASS_IRQ]       = &kwork_irq,\n\t[KWORK_CLASS_SOFTIRQ]   = &kwork_softirq,\n\t[KWORK_CLASS_WORKQUEUE] = &kwork_workqueue,\n};\n\nstatic void print_separator(int len)\n{\n\tprintf(\" %.*s\\n\", len, graph_dotted_line);\n}\n\nstatic int report_print_work(struct perf_kwork *kwork, struct kwork_work *work)\n{\n\tint ret = 0;\n\tchar kwork_name[PRINT_KWORK_NAME_WIDTH];\n\tchar max_runtime_start[32], max_runtime_end[32];\n\tchar max_latency_start[32], max_latency_end[32];\n\n\tprintf(\" \");\n\n\t \n\tif (work->class && work->class->work_name) {\n\t\twork->class->work_name(work, kwork_name,\n\t\t\t\t       PRINT_KWORK_NAME_WIDTH);\n\t\tret += printf(\" %-*s |\", PRINT_KWORK_NAME_WIDTH, kwork_name);\n\t} else {\n\t\tret += printf(\" %-*s |\", PRINT_KWORK_NAME_WIDTH, \"\");\n\t}\n\n\t \n\tret += printf(\" %0*d |\", PRINT_CPU_WIDTH, work->cpu);\n\n\t \n\tif (kwork->report == KWORK_REPORT_RUNTIME) {\n\t\tret += printf(\" %*.*f ms |\",\n\t\t\t      PRINT_RUNTIME_WIDTH, RPINT_DECIMAL_WIDTH,\n\t\t\t      (double)work->total_runtime / NSEC_PER_MSEC);\n\t} else if (kwork->report == KWORK_REPORT_LATENCY) { \n\t\tret += printf(\" %*.*f ms |\",\n\t\t\t      PRINT_LATENCY_WIDTH, RPINT_DECIMAL_WIDTH,\n\t\t\t      (double)work->total_latency /\n\t\t\t      work->nr_atoms / NSEC_PER_MSEC);\n\t}\n\n\t \n\tret += printf(\" %*\" PRIu64 \" |\", PRINT_COUNT_WIDTH, work->nr_atoms);\n\n\t \n\tif (kwork->report == KWORK_REPORT_RUNTIME) {\n\t\ttimestamp__scnprintf_usec(work->max_runtime_start,\n\t\t\t\t\t  max_runtime_start,\n\t\t\t\t\t  sizeof(max_runtime_start));\n\t\ttimestamp__scnprintf_usec(work->max_runtime_end,\n\t\t\t\t\t  max_runtime_end,\n\t\t\t\t\t  sizeof(max_runtime_end));\n\t\tret += printf(\" %*.*f ms | %*s s | %*s s |\",\n\t\t\t      PRINT_RUNTIME_WIDTH, RPINT_DECIMAL_WIDTH,\n\t\t\t      (double)work->max_runtime / NSEC_PER_MSEC,\n\t\t\t      PRINT_TIMESTAMP_WIDTH, max_runtime_start,\n\t\t\t      PRINT_TIMESTAMP_WIDTH, max_runtime_end);\n\t}\n\t \n\telse if (kwork->report == KWORK_REPORT_LATENCY) {\n\t\ttimestamp__scnprintf_usec(work->max_latency_start,\n\t\t\t\t\t  max_latency_start,\n\t\t\t\t\t  sizeof(max_latency_start));\n\t\ttimestamp__scnprintf_usec(work->max_latency_end,\n\t\t\t\t\t  max_latency_end,\n\t\t\t\t\t  sizeof(max_latency_end));\n\t\tret += printf(\" %*.*f ms | %*s s | %*s s |\",\n\t\t\t      PRINT_LATENCY_WIDTH, RPINT_DECIMAL_WIDTH,\n\t\t\t      (double)work->max_latency / NSEC_PER_MSEC,\n\t\t\t      PRINT_TIMESTAMP_WIDTH, max_latency_start,\n\t\t\t      PRINT_TIMESTAMP_WIDTH, max_latency_end);\n\t}\n\n\tprintf(\"\\n\");\n\treturn ret;\n}\n\nstatic int report_print_header(struct perf_kwork *kwork)\n{\n\tint ret;\n\n\tprintf(\"\\n \");\n\tret = printf(\" %-*s | %-*s |\",\n\t\t     PRINT_KWORK_NAME_WIDTH, \"Kwork Name\",\n\t\t     PRINT_CPU_WIDTH, \"Cpu\");\n\n\tif (kwork->report == KWORK_REPORT_RUNTIME) {\n\t\tret += printf(\" %-*s |\",\n\t\t\t      PRINT_RUNTIME_HEADER_WIDTH, \"Total Runtime\");\n\t} else if (kwork->report == KWORK_REPORT_LATENCY) {\n\t\tret += printf(\" %-*s |\",\n\t\t\t      PRINT_LATENCY_HEADER_WIDTH, \"Avg delay\");\n\t}\n\n\tret += printf(\" %-*s |\", PRINT_COUNT_WIDTH, \"Count\");\n\n\tif (kwork->report == KWORK_REPORT_RUNTIME) {\n\t\tret += printf(\" %-*s | %-*s | %-*s |\",\n\t\t\t      PRINT_RUNTIME_HEADER_WIDTH, \"Max runtime\",\n\t\t\t      PRINT_TIMESTAMP_HEADER_WIDTH, \"Max runtime start\",\n\t\t\t      PRINT_TIMESTAMP_HEADER_WIDTH, \"Max runtime end\");\n\t} else if (kwork->report == KWORK_REPORT_LATENCY) {\n\t\tret += printf(\" %-*s | %-*s | %-*s |\",\n\t\t\t      PRINT_LATENCY_HEADER_WIDTH, \"Max delay\",\n\t\t\t      PRINT_TIMESTAMP_HEADER_WIDTH, \"Max delay start\",\n\t\t\t      PRINT_TIMESTAMP_HEADER_WIDTH, \"Max delay end\");\n\t}\n\n\tprintf(\"\\n\");\n\tprint_separator(ret);\n\treturn ret;\n}\n\nstatic void timehist_print_header(void)\n{\n\t \n\tprintf(\" %-*s  %-*s  %-*s  %-*s  %-*s  %-*s\\n\",\n\t       PRINT_TIMESTAMP_WIDTH, \"Runtime start\",\n\t       PRINT_TIMESTAMP_WIDTH, \"Runtime end\",\n\t       PRINT_TIMEHIST_CPU_WIDTH, \"Cpu\",\n\t       PRINT_KWORK_NAME_WIDTH, \"Kwork name\",\n\t       PRINT_RUNTIME_WIDTH, \"Runtime\",\n\t       PRINT_RUNTIME_WIDTH, \"Delaytime\");\n\n\t \n\tprintf(\" %-*s  %-*s  %-*s  %-*s  %-*s  %-*s\\n\",\n\t       PRINT_TIMESTAMP_WIDTH, \"\",\n\t       PRINT_TIMESTAMP_WIDTH, \"\",\n\t       PRINT_TIMEHIST_CPU_WIDTH, \"\",\n\t       PRINT_KWORK_NAME_WIDTH, \"(TYPE)NAME:NUM\",\n\t       PRINT_RUNTIME_WIDTH, \"(msec)\",\n\t       PRINT_RUNTIME_WIDTH, \"(msec)\");\n\n\t \n\tprintf(\" %.*s  %.*s  %.*s  %.*s  %.*s  %.*s\\n\",\n\t       PRINT_TIMESTAMP_WIDTH, graph_dotted_line,\n\t       PRINT_TIMESTAMP_WIDTH, graph_dotted_line,\n\t       PRINT_TIMEHIST_CPU_WIDTH, graph_dotted_line,\n\t       PRINT_KWORK_NAME_WIDTH, graph_dotted_line,\n\t       PRINT_RUNTIME_WIDTH, graph_dotted_line,\n\t       PRINT_RUNTIME_WIDTH, graph_dotted_line);\n}\n\nstatic void print_summary(struct perf_kwork *kwork)\n{\n\tu64 time = kwork->timeend - kwork->timestart;\n\n\tprintf(\"  Total count            : %9\" PRIu64 \"\\n\", kwork->all_count);\n\tprintf(\"  Total runtime   (msec) : %9.3f (%.3f%% load average)\\n\",\n\t       (double)kwork->all_runtime / NSEC_PER_MSEC,\n\t       time == 0 ? 0 : (double)kwork->all_runtime / time);\n\tprintf(\"  Total time span (msec) : %9.3f\\n\",\n\t       (double)time / NSEC_PER_MSEC);\n}\n\nstatic unsigned long long nr_list_entry(struct list_head *head)\n{\n\tstruct list_head *pos;\n\tunsigned long long n = 0;\n\n\tlist_for_each(pos, head)\n\t\tn++;\n\n\treturn n;\n}\n\nstatic void print_skipped_events(struct perf_kwork *kwork)\n{\n\tint i;\n\tconst char *const kwork_event_str[] = {\n\t\t[KWORK_TRACE_RAISE] = \"raise\",\n\t\t[KWORK_TRACE_ENTRY] = \"entry\",\n\t\t[KWORK_TRACE_EXIT]  = \"exit\",\n\t};\n\n\tif ((kwork->nr_skipped_events[KWORK_TRACE_MAX] != 0) &&\n\t    (kwork->nr_events != 0)) {\n\t\tprintf(\"  INFO: %.3f%% skipped events (%\" PRIu64 \" including \",\n\t\t       (double)kwork->nr_skipped_events[KWORK_TRACE_MAX] /\n\t\t       (double)kwork->nr_events * 100.0,\n\t\t       kwork->nr_skipped_events[KWORK_TRACE_MAX]);\n\n\t\tfor (i = 0; i < KWORK_TRACE_MAX; i++) {\n\t\t\tprintf(\"%\" PRIu64 \" %s%s\",\n\t\t\t       kwork->nr_skipped_events[i],\n\t\t\t       kwork_event_str[i],\n\t\t\t       (i == KWORK_TRACE_MAX - 1) ? \")\\n\" : \", \");\n\t\t}\n\t}\n\n\tif (verbose > 0)\n\t\tprintf(\"  INFO: use %lld atom pages\\n\",\n\t\t       nr_list_entry(&kwork->atom_page_list));\n}\n\nstatic void print_bad_events(struct perf_kwork *kwork)\n{\n\tif ((kwork->nr_lost_events != 0) && (kwork->nr_events != 0)) {\n\t\tprintf(\"  INFO: %.3f%% lost events (%ld out of %ld, in %ld chunks)\\n\",\n\t\t       (double)kwork->nr_lost_events /\n\t\t       (double)kwork->nr_events * 100.0,\n\t\t       kwork->nr_lost_events, kwork->nr_events,\n\t\t       kwork->nr_lost_chunks);\n\t}\n}\n\nstatic void work_sort(struct perf_kwork *kwork, struct kwork_class *class)\n{\n\tstruct rb_node *node;\n\tstruct kwork_work *data;\n\tstruct rb_root_cached *root = &class->work_root;\n\n\tpr_debug(\"Sorting %s ...\\n\", class->name);\n\tfor (;;) {\n\t\tnode = rb_first_cached(root);\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\trb_erase_cached(node, root);\n\t\tdata = rb_entry(node, struct kwork_work, node);\n\t\twork_insert(&kwork->sorted_work_root,\n\t\t\t       data, &kwork->sort_list);\n\t}\n}\n\nstatic void perf_kwork__sort(struct perf_kwork *kwork)\n{\n\tstruct kwork_class *class;\n\n\tlist_for_each_entry(class, &kwork->class_list, list)\n\t\twork_sort(kwork, class);\n}\n\nstatic int perf_kwork__check_config(struct perf_kwork *kwork,\n\t\t\t\t    struct perf_session *session)\n{\n\tint ret;\n\tstruct evsel *evsel;\n\tstruct kwork_class *class;\n\n\tstatic struct trace_kwork_handler report_ops = {\n\t\t.entry_event = report_entry_event,\n\t\t.exit_event  = report_exit_event,\n\t};\n\tstatic struct trace_kwork_handler latency_ops = {\n\t\t.raise_event = latency_raise_event,\n\t\t.entry_event = latency_entry_event,\n\t};\n\tstatic struct trace_kwork_handler timehist_ops = {\n\t\t.raise_event = timehist_raise_event,\n\t\t.entry_event = timehist_entry_event,\n\t\t.exit_event  = timehist_exit_event,\n\t};\n\n\tswitch (kwork->report) {\n\tcase KWORK_REPORT_RUNTIME:\n\t\tkwork->tp_handler = &report_ops;\n\t\tbreak;\n\tcase KWORK_REPORT_LATENCY:\n\t\tkwork->tp_handler = &latency_ops;\n\t\tbreak;\n\tcase KWORK_REPORT_TIMEHIST:\n\t\tkwork->tp_handler = &timehist_ops;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Invalid report type %d\\n\", kwork->report);\n\t\treturn -1;\n\t}\n\n\tlist_for_each_entry(class, &kwork->class_list, list)\n\t\tif ((class->class_init != NULL) &&\n\t\t    (class->class_init(class, session) != 0))\n\t\t\treturn -1;\n\n\tif (kwork->cpu_list != NULL) {\n\t\tret = perf_session__cpu_bitmap(session,\n\t\t\t\t\t       kwork->cpu_list,\n\t\t\t\t\t       kwork->cpu_bitmap);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Invalid cpu bitmap\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (kwork->time_str != NULL) {\n\t\tret = perf_time__parse_str(&kwork->ptime, kwork->time_str);\n\t\tif (ret != 0) {\n\t\t\tpr_err(\"Invalid time span\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tlist_for_each_entry(evsel, &session->evlist->core.entries, core.node) {\n\t\tif (kwork->show_callchain && !evsel__has_callchain(evsel)) {\n\t\t\tpr_debug(\"Samples do not have callchains\\n\");\n\t\t\tkwork->show_callchain = 0;\n\t\t\tsymbol_conf.use_callchain = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_kwork__read_events(struct perf_kwork *kwork)\n{\n\tint ret = -1;\n\tstruct perf_session *session = NULL;\n\n\tstruct perf_data data = {\n\t\t.path  = input_name,\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t\t.force = kwork->force,\n\t};\n\n\tsession = perf_session__new(&data, &kwork->tool);\n\tif (IS_ERR(session)) {\n\t\tpr_debug(\"Error creating perf session\\n\");\n\t\treturn PTR_ERR(session);\n\t}\n\n\tsymbol__init(&session->header.env);\n\n\tif (perf_kwork__check_config(kwork, session) != 0)\n\t\tgoto out_delete;\n\n\tif (session->tevent.pevent &&\n\t    tep_set_function_resolver(session->tevent.pevent,\n\t\t\t\t      machine__resolve_kernel_addr,\n\t\t\t\t      &session->machines.host) < 0) {\n\t\tpr_err(\"Failed to set libtraceevent function resolver\\n\");\n\t\tgoto out_delete;\n\t}\n\n\tif (kwork->report == KWORK_REPORT_TIMEHIST)\n\t\ttimehist_print_header();\n\n\tret = perf_session__process_events(session);\n\tif (ret) {\n\t\tpr_debug(\"Failed to process events, error %d\\n\", ret);\n\t\tgoto out_delete;\n\t}\n\n\tkwork->nr_events      = session->evlist->stats.nr_events[0];\n\tkwork->nr_lost_events = session->evlist->stats.total_lost;\n\tkwork->nr_lost_chunks = session->evlist->stats.nr_events[PERF_RECORD_LOST];\n\nout_delete:\n\tperf_session__delete(session);\n\treturn ret;\n}\n\nstatic void process_skipped_events(struct perf_kwork *kwork,\n\t\t\t\t   struct kwork_work *work)\n{\n\tint i;\n\tunsigned long long count;\n\n\tfor (i = 0; i < KWORK_TRACE_MAX; i++) {\n\t\tcount = nr_list_entry(&work->atom_list[i]);\n\t\tkwork->nr_skipped_events[i] += count;\n\t\tkwork->nr_skipped_events[KWORK_TRACE_MAX] += count;\n\t}\n}\n\nstruct kwork_work *perf_kwork_add_work(struct perf_kwork *kwork,\n\t\t\t\t       struct kwork_class *class,\n\t\t\t\t       struct kwork_work *key)\n{\n\tstruct kwork_work *work = NULL;\n\n\twork = work_new(key);\n\tif (work == NULL)\n\t\treturn NULL;\n\n\twork_insert(&class->work_root, work, &kwork->cmp_id);\n\treturn work;\n}\n\nstatic void sig_handler(int sig)\n{\n\t \n\tpr_debug(\"Captuer signal %d\\n\", sig);\n}\n\nstatic int perf_kwork__report_bpf(struct perf_kwork *kwork)\n{\n\tint ret;\n\n\tsignal(SIGINT, sig_handler);\n\tsignal(SIGTERM, sig_handler);\n\n\tret = perf_kwork__trace_prepare_bpf(kwork);\n\tif (ret)\n\t\treturn -1;\n\n\tprintf(\"Starting trace, Hit <Ctrl+C> to stop and report\\n\");\n\n\tperf_kwork__trace_start();\n\n\t \n\tpause();\n\n\tperf_kwork__trace_finish();\n\n\tperf_kwork__report_read_bpf(kwork);\n\n\tperf_kwork__report_cleanup_bpf();\n\n\treturn 0;\n}\n\nstatic int perf_kwork__report(struct perf_kwork *kwork)\n{\n\tint ret;\n\tstruct rb_node *next;\n\tstruct kwork_work *work;\n\n\tif (kwork->use_bpf)\n\t\tret = perf_kwork__report_bpf(kwork);\n\telse\n\t\tret = perf_kwork__read_events(kwork);\n\n\tif (ret != 0)\n\t\treturn -1;\n\n\tperf_kwork__sort(kwork);\n\n\tsetup_pager();\n\n\tret = report_print_header(kwork);\n\tnext = rb_first_cached(&kwork->sorted_work_root);\n\twhile (next) {\n\t\twork = rb_entry(next, struct kwork_work, node);\n\t\tprocess_skipped_events(kwork, work);\n\n\t\tif (work->nr_atoms != 0) {\n\t\t\treport_print_work(kwork, work);\n\t\t\tif (kwork->summary) {\n\t\t\t\tkwork->all_runtime += work->total_runtime;\n\t\t\t\tkwork->all_count += work->nr_atoms;\n\t\t\t}\n\t\t}\n\t\tnext = rb_next(next);\n\t}\n\tprint_separator(ret);\n\n\tif (kwork->summary) {\n\t\tprint_summary(kwork);\n\t\tprint_separator(ret);\n\t}\n\n\tprint_bad_events(kwork);\n\tprint_skipped_events(kwork);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\ntypedef int (*tracepoint_handler)(struct perf_tool *tool,\n\t\t\t\t  struct evsel *evsel,\n\t\t\t\t  struct perf_sample *sample,\n\t\t\t\t  struct machine *machine);\n\nstatic int perf_kwork__process_tracepoint_sample(struct perf_tool *tool,\n\t\t\t\t\t\t union perf_event *event __maybe_unused,\n\t\t\t\t\t\t struct perf_sample *sample,\n\t\t\t\t\t\t struct evsel *evsel,\n\t\t\t\t\t\t struct machine *machine)\n{\n\tint err = 0;\n\n\tif (evsel->handler != NULL) {\n\t\ttracepoint_handler f = evsel->handler;\n\n\t\terr = f(tool, evsel, sample, machine);\n\t}\n\n\treturn err;\n}\n\nstatic int perf_kwork__timehist(struct perf_kwork *kwork)\n{\n\t \n\tkwork->tool.comm\t = perf_event__process_comm;\n\tkwork->tool.exit\t = perf_event__process_exit;\n\tkwork->tool.fork\t = perf_event__process_fork;\n\tkwork->tool.attr\t = perf_event__process_attr;\n\tkwork->tool.tracing_data = perf_event__process_tracing_data;\n\tkwork->tool.build_id\t = perf_event__process_build_id;\n\tkwork->tool.ordered_events = true;\n\tkwork->tool.ordering_requires_timestamps = true;\n\tsymbol_conf.use_callchain = kwork->show_callchain;\n\n\tif (symbol__validate_sym_arguments()) {\n\t\tpr_err(\"Failed to validate sym arguments\\n\");\n\t\treturn -1;\n\t}\n\n\tsetup_pager();\n\n\treturn perf_kwork__read_events(kwork);\n}\n\nstatic void setup_event_list(struct perf_kwork *kwork,\n\t\t\t     const struct option *options,\n\t\t\t     const char * const usage_msg[])\n{\n\tint i;\n\tstruct kwork_class *class;\n\tchar *tmp, *tok, *str;\n\n\tif (kwork->event_list_str == NULL)\n\t\tgoto null_event_list_str;\n\n\tstr = strdup(kwork->event_list_str);\n\tfor (tok = strtok_r(str, \", \", &tmp);\n\t     tok; tok = strtok_r(NULL, \", \", &tmp)) {\n\t\tfor (i = 0; i < KWORK_CLASS_MAX; i++) {\n\t\t\tclass = kwork_class_supported_list[i];\n\t\t\tif (strcmp(tok, class->name) == 0) {\n\t\t\t\tlist_add_tail(&class->list, &kwork->class_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == KWORK_CLASS_MAX) {\n\t\t\tusage_with_options_msg(usage_msg, options,\n\t\t\t\t\t       \"Unknown --event key: `%s'\", tok);\n\t\t}\n\t}\n\tfree(str);\n\nnull_event_list_str:\n\t \n\tif (list_empty(&kwork->class_list)) {\n\t\tfor (i = 0; i < KWORK_CLASS_MAX; i++) {\n\t\t\tlist_add_tail(&kwork_class_supported_list[i]->list,\n\t\t\t\t      &kwork->class_list);\n\t\t}\n\t}\n\n\tpr_debug(\"Config event list:\");\n\tlist_for_each_entry(class, &kwork->class_list, list)\n\t\tpr_debug(\" %s\", class->name);\n\tpr_debug(\"\\n\");\n}\n\nstatic int perf_kwork__record(struct perf_kwork *kwork,\n\t\t\t      int argc, const char **argv)\n{\n\tconst char **rec_argv;\n\tunsigned int rec_argc, i, j;\n\tstruct kwork_class *class;\n\n\tconst char *const record_args[] = {\n\t\t\"record\",\n\t\t\"-a\",\n\t\t\"-R\",\n\t\t\"-m\", \"1024\",\n\t\t\"-c\", \"1\",\n\t};\n\n\trec_argc = ARRAY_SIZE(record_args) + argc - 1;\n\n\tlist_for_each_entry(class, &kwork->class_list, list)\n\t\trec_argc += 2 * class->nr_tracepoints;\n\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\tif (rec_argv == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(record_args); i++)\n\t\trec_argv[i] = strdup(record_args[i]);\n\n\tlist_for_each_entry(class, &kwork->class_list, list) {\n\t\tfor (j = 0; j < class->nr_tracepoints; j++) {\n\t\t\trec_argv[i++] = strdup(\"-e\");\n\t\t\trec_argv[i++] = strdup(class->tp_handlers[j].name);\n\t\t}\n\t}\n\n\tfor (j = 1; j < (unsigned int)argc; j++, i++)\n\t\trec_argv[i] = argv[j];\n\n\tBUG_ON(i != rec_argc);\n\n\tpr_debug(\"record comm: \");\n\tfor (j = 0; j < rec_argc; j++)\n\t\tpr_debug(\"%s \", rec_argv[j]);\n\tpr_debug(\"\\n\");\n\n\treturn cmd_record(i, rec_argv);\n}\n\nint cmd_kwork(int argc, const char **argv)\n{\n\tstatic struct perf_kwork kwork = {\n\t\t.class_list          = LIST_HEAD_INIT(kwork.class_list),\n\t\t.tool = {\n\t\t\t.mmap\t\t= perf_event__process_mmap,\n\t\t\t.mmap2\t\t= perf_event__process_mmap2,\n\t\t\t.sample\t\t= perf_kwork__process_tracepoint_sample,\n\t\t\t.ordered_events = true,\n\t\t},\n\t\t.atom_page_list      = LIST_HEAD_INIT(kwork.atom_page_list),\n\t\t.sort_list           = LIST_HEAD_INIT(kwork.sort_list),\n\t\t.cmp_id              = LIST_HEAD_INIT(kwork.cmp_id),\n\t\t.sorted_work_root    = RB_ROOT_CACHED,\n\t\t.tp_handler          = NULL,\n\t\t.profile_name        = NULL,\n\t\t.cpu_list            = NULL,\n\t\t.time_str            = NULL,\n\t\t.force               = false,\n\t\t.event_list_str      = NULL,\n\t\t.summary             = false,\n\t\t.sort_order          = NULL,\n\t\t.show_callchain      = false,\n\t\t.max_stack           = 5,\n\t\t.timestart           = 0,\n\t\t.timeend             = 0,\n\t\t.nr_events           = 0,\n\t\t.nr_lost_chunks      = 0,\n\t\t.nr_lost_events      = 0,\n\t\t.all_runtime         = 0,\n\t\t.all_count           = 0,\n\t\t.nr_skipped_events   = { 0 },\n\t};\n\tstatic const char default_report_sort_order[] = \"runtime, max, count\";\n\tstatic const char default_latency_sort_order[] = \"avg, max, count\";\n\tconst struct option kwork_options[] = {\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t \"be more verbose (show symbol address, etc)\"),\n\tOPT_BOOLEAN('D', \"dump-raw-trace\", &dump_trace,\n\t\t    \"dump raw trace in ASCII\"),\n\tOPT_STRING('k', \"kwork\", &kwork.event_list_str, \"kwork\",\n\t\t   \"list of kwork to profile (irq, softirq, workqueue, etc)\"),\n\tOPT_BOOLEAN('f', \"force\", &kwork.force, \"don't complain, do it\"),\n\tOPT_END()\n\t};\n\tconst struct option report_options[] = {\n\tOPT_STRING('s', \"sort\", &kwork.sort_order, \"key[,key2...]\",\n\t\t   \"sort by key(s): runtime, max, count\"),\n\tOPT_STRING('C', \"cpu\", &kwork.cpu_list, \"cpu\",\n\t\t   \"list of cpus to profile\"),\n\tOPT_STRING('n', \"name\", &kwork.profile_name, \"name\",\n\t\t   \"event name to profile\"),\n\tOPT_STRING(0, \"time\", &kwork.time_str, \"str\",\n\t\t   \"Time span for analysis (start,stop)\"),\n\tOPT_STRING('i', \"input\", &input_name, \"file\",\n\t\t   \"input file name\"),\n\tOPT_BOOLEAN('S', \"with-summary\", &kwork.summary,\n\t\t    \"Show summary with statistics\"),\n#ifdef HAVE_BPF_SKEL\n\tOPT_BOOLEAN('b', \"use-bpf\", &kwork.use_bpf,\n\t\t    \"Use BPF to measure kwork runtime\"),\n#endif\n\tOPT_PARENT(kwork_options)\n\t};\n\tconst struct option latency_options[] = {\n\tOPT_STRING('s', \"sort\", &kwork.sort_order, \"key[,key2...]\",\n\t\t   \"sort by key(s): avg, max, count\"),\n\tOPT_STRING('C', \"cpu\", &kwork.cpu_list, \"cpu\",\n\t\t   \"list of cpus to profile\"),\n\tOPT_STRING('n', \"name\", &kwork.profile_name, \"name\",\n\t\t   \"event name to profile\"),\n\tOPT_STRING(0, \"time\", &kwork.time_str, \"str\",\n\t\t   \"Time span for analysis (start,stop)\"),\n\tOPT_STRING('i', \"input\", &input_name, \"file\",\n\t\t   \"input file name\"),\n#ifdef HAVE_BPF_SKEL\n\tOPT_BOOLEAN('b', \"use-bpf\", &kwork.use_bpf,\n\t\t    \"Use BPF to measure kwork latency\"),\n#endif\n\tOPT_PARENT(kwork_options)\n\t};\n\tconst struct option timehist_options[] = {\n\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_STRING(0, \"kallsyms\", &symbol_conf.kallsyms_name,\n\t\t   \"file\", \"kallsyms pathname\"),\n\tOPT_BOOLEAN('g', \"call-graph\", &kwork.show_callchain,\n\t\t    \"Display call chains if present\"),\n\tOPT_UINTEGER(0, \"max-stack\", &kwork.max_stack,\n\t\t   \"Maximum number of functions to display backtrace.\"),\n\tOPT_STRING(0, \"symfs\", &symbol_conf.symfs, \"directory\",\n\t\t    \"Look for files with symbols relative to this directory\"),\n\tOPT_STRING(0, \"time\", &kwork.time_str, \"str\",\n\t\t   \"Time span for analysis (start,stop)\"),\n\tOPT_STRING('C', \"cpu\", &kwork.cpu_list, \"cpu\",\n\t\t   \"list of cpus to profile\"),\n\tOPT_STRING('n', \"name\", &kwork.profile_name, \"name\",\n\t\t   \"event name to profile\"),\n\tOPT_STRING('i', \"input\", &input_name, \"file\",\n\t\t   \"input file name\"),\n\tOPT_PARENT(kwork_options)\n\t};\n\tconst char *kwork_usage[] = {\n\t\tNULL,\n\t\tNULL\n\t};\n\tconst char * const report_usage[] = {\n\t\t\"perf kwork report [<options>]\",\n\t\tNULL\n\t};\n\tconst char * const latency_usage[] = {\n\t\t\"perf kwork latency [<options>]\",\n\t\tNULL\n\t};\n\tconst char * const timehist_usage[] = {\n\t\t\"perf kwork timehist [<options>]\",\n\t\tNULL\n\t};\n\tconst char *const kwork_subcommands[] = {\n\t\t\"record\", \"report\", \"latency\", \"timehist\", NULL\n\t};\n\n\targc = parse_options_subcommand(argc, argv, kwork_options,\n\t\t\t\t\tkwork_subcommands, kwork_usage,\n\t\t\t\t\tPARSE_OPT_STOP_AT_NON_OPTION);\n\tif (!argc)\n\t\tusage_with_options(kwork_usage, kwork_options);\n\n\tsetup_event_list(&kwork, kwork_options, kwork_usage);\n\tsort_dimension__add(&kwork, \"id\", &kwork.cmp_id);\n\n\tif (strlen(argv[0]) > 2 && strstarts(\"record\", argv[0]))\n\t\treturn perf_kwork__record(&kwork, argc, argv);\n\telse if (strlen(argv[0]) > 2 && strstarts(\"report\", argv[0])) {\n\t\tkwork.sort_order = default_report_sort_order;\n\t\tif (argc > 1) {\n\t\t\targc = parse_options(argc, argv, report_options, report_usage, 0);\n\t\t\tif (argc)\n\t\t\t\tusage_with_options(report_usage, report_options);\n\t\t}\n\t\tkwork.report = KWORK_REPORT_RUNTIME;\n\t\tsetup_sorting(&kwork, report_options, report_usage);\n\t\treturn perf_kwork__report(&kwork);\n\t} else if (strlen(argv[0]) > 2 && strstarts(\"latency\", argv[0])) {\n\t\tkwork.sort_order = default_latency_sort_order;\n\t\tif (argc > 1) {\n\t\t\targc = parse_options(argc, argv, latency_options, latency_usage, 0);\n\t\t\tif (argc)\n\t\t\t\tusage_with_options(latency_usage, latency_options);\n\t\t}\n\t\tkwork.report = KWORK_REPORT_LATENCY;\n\t\tsetup_sorting(&kwork, latency_options, latency_usage);\n\t\treturn perf_kwork__report(&kwork);\n\t} else if (strlen(argv[0]) > 2 && strstarts(\"timehist\", argv[0])) {\n\t\tif (argc > 1) {\n\t\t\targc = parse_options(argc, argv, timehist_options, timehist_usage, 0);\n\t\t\tif (argc)\n\t\t\t\tusage_with_options(timehist_usage, timehist_options);\n\t\t}\n\t\tkwork.report = KWORK_REPORT_TIMEHIST;\n\t\treturn perf_kwork__timehist(&kwork);\n\t} else\n\t\tusage_with_options(kwork_usage, kwork_options);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}