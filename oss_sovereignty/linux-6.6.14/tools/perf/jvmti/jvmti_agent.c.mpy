{
  "module_name": "jvmti_agent.c",
  "hash_id": "c638ec6bd711004ba348290a55459449a31348cf73a8b845b539e70473d0450b",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/jvmti/jvmti_agent.c",
  "human_readable_source": " \n#include <sys/types.h>\n#include <sys/stat.h>  \n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/mman.h>\n#include <syscall.h>  \n#include <err.h>\n#include <linux/kernel.h>\n\n#include \"jvmti_agent.h\"\n#include \"../util/jitdump.h\"\n\n#define JIT_LANG \"java\"\n\nstatic char jit_path[PATH_MAX];\nstatic void *marker_addr;\n\n#ifndef HAVE_GETTID\nstatic inline pid_t gettid(void)\n{\n\treturn (pid_t)syscall(__NR_gettid);\n}\n#endif\n\nstatic int get_e_machine(struct jitheader *hdr)\n{\n\tssize_t sret;\n\tchar id[16];\n\tint fd, ret = -1;\n\tstruct {\n\t\tuint16_t e_type;\n\t\tuint16_t e_machine;\n\t} info;\n\n\tfd = open(\"/proc/self/exe\", O_RDONLY);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tsret = read(fd, id, sizeof(id));\n\tif (sret != sizeof(id))\n\t\tgoto error;\n\n\t \n\tif (id[0] != 0x7f || id[1] != 'E' || id[2] != 'L' || id[3] != 'F')\n\t\tgoto error;\n\n\tsret = read(fd, &info, sizeof(info));\n\tif (sret != sizeof(info))\n\t\tgoto error;\n\n\thdr->elf_mach = info.e_machine;\n\tret = 0;\nerror:\n\tclose(fd);\n\treturn ret;\n}\n\nstatic int use_arch_timestamp;\n\nstatic inline uint64_t\nget_arch_timestamp(void)\n{\n#if defined(__i386__) || defined(__x86_64__)\n\tunsigned int low, high;\n\n\tasm volatile(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n\n\treturn low | ((uint64_t)high) << 32;\n#else\n\treturn 0;\n#endif\n}\n\n#define NSEC_PER_SEC\t1000000000\nstatic int perf_clk_id = CLOCK_MONOTONIC;\n\nstatic inline uint64_t\ntimespec_to_ns(const struct timespec *ts)\n{\n        return ((uint64_t) ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec;\n}\n\nstatic inline uint64_t\nperf_get_timestamp(void)\n{\n\tstruct timespec ts;\n\tint ret;\n\n\tif (use_arch_timestamp)\n\t\treturn get_arch_timestamp();\n\n\tret = clock_gettime(perf_clk_id, &ts);\n\tif (ret)\n\t\treturn 0;\n\n\treturn timespec_to_ns(&ts);\n}\n\nstatic int\ncreate_jit_cache_dir(void)\n{\n\tchar str[32];\n\tchar *base, *p;\n\tstruct tm tm;\n\ttime_t t;\n\tint ret;\n\n\ttime(&t);\n\tlocaltime_r(&t, &tm);\n\n\tbase = getenv(\"JITDUMPDIR\");\n\tif (!base)\n\t\tbase = getenv(\"HOME\");\n\tif (!base)\n\t\tbase = \".\";\n\n\tstrftime(str, sizeof(str), JIT_LANG\"-jit-%Y%m%d\", &tm);\n\n\tret = snprintf(jit_path, PATH_MAX, \"%s/.debug/\", base);\n\tif (ret >= PATH_MAX) {\n\t\twarnx(\"jvmti: cannot generate jit cache dir because %s/.debug/\"\n\t\t\t\" is too long, please check the cwd, JITDUMPDIR, and\"\n\t\t\t\" HOME variables\", base);\n\t\treturn -1;\n\t}\n\tret = mkdir(jit_path, 0755);\n\tif (ret == -1) {\n\t\tif (errno != EEXIST) {\n\t\t\twarn(\"jvmti: cannot create jit cache dir %s\", jit_path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = snprintf(jit_path, PATH_MAX, \"%s/.debug/jit\", base);\n\tif (ret >= PATH_MAX) {\n\t\twarnx(\"jvmti: cannot generate jit cache dir because\"\n\t\t\t\" %s/.debug/jit is too long, please check the cwd,\"\n\t\t\t\" JITDUMPDIR, and HOME variables\", base);\n\t\treturn -1;\n\t}\n\tret = mkdir(jit_path, 0755);\n\tif (ret == -1) {\n\t\tif (errno != EEXIST) {\n\t\t\twarn(\"jvmti: cannot create jit cache dir %s\", jit_path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = snprintf(jit_path, PATH_MAX, \"%s/.debug/jit/%s.XXXXXXXX\", base, str);\n\tif (ret >= PATH_MAX) {\n\t\twarnx(\"jvmti: cannot generate jit cache dir because\"\n\t\t\t\" %s/.debug/jit/%s.XXXXXXXX is too long, please check\"\n\t\t\t\" the cwd, JITDUMPDIR, and HOME variables\",\n\t\t\tbase, str);\n\t\treturn -1;\n\t}\n\tp = mkdtemp(jit_path);\n\tif (p != jit_path) {\n\t\twarn(\"jvmti: cannot create jit cache dir %s\", jit_path);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nperf_open_marker_file(int fd)\n{\n\tlong pgsz;\n\n\tpgsz = sysconf(_SC_PAGESIZE);\n\tif (pgsz == -1)\n\t\treturn -1;\n\n\t \n\tmarker_addr = mmap(NULL, pgsz, PROT_READ|PROT_EXEC, MAP_PRIVATE, fd, 0);\n\treturn (marker_addr == MAP_FAILED) ? -1 : 0;\n}\n\nstatic void\nperf_close_marker_file(void)\n{\n\tlong pgsz;\n\n\tif (!marker_addr)\n\t\treturn;\n\n\tpgsz = sysconf(_SC_PAGESIZE);\n\tif (pgsz == -1)\n\t\treturn;\n\n\tmunmap(marker_addr, pgsz);\n}\n\nstatic void\ninit_arch_timestamp(void)\n{\n\tchar *str = getenv(\"JITDUMP_USE_ARCH_TIMESTAMP\");\n\n\tif (!str || !*str || !strcmp(str, \"0\"))\n\t\treturn;\n\n\tuse_arch_timestamp = 1;\n}\n\nvoid *jvmti_open(void)\n{\n\tchar dump_path[PATH_MAX];\n\tstruct jitheader header;\n\tint fd, ret;\n\tFILE *fp;\n\n\tinit_arch_timestamp();\n\n\t \n\tif (!perf_get_timestamp()) {\n\t\tif (use_arch_timestamp)\n\t\t\twarnx(\"jvmti: arch timestamp not supported\");\n\t\telse\n\t\t\twarnx(\"jvmti: kernel does not support %d clock id\", perf_clk_id);\n\t}\n\n\tmemset(&header, 0, sizeof(header));\n\n\t \n\tif (create_jit_cache_dir() < 0)\n\t\treturn NULL;\n\n\t \n\tret = snprintf(dump_path, PATH_MAX, \"%s/jit-%i.dump\", jit_path, getpid());\n\tif (ret >= PATH_MAX) {\n\t\twarnx(\"jvmti: cannot generate jitdump file full path because\"\n\t\t\t\" %s/jit-%i.dump is too long, please check the cwd,\"\n\t\t\t\" JITDUMPDIR, and HOME variables\", jit_path, getpid());\n\t\treturn NULL;\n\t}\n\n\tfd = open(dump_path, O_CREAT|O_TRUNC|O_RDWR, 0666);\n\tif (fd == -1)\n\t\treturn NULL;\n\n\t \n\tif (perf_open_marker_file(fd)) {\n\t\twarnx(\"jvmti: failed to create marker file\");\n\t\treturn NULL;\n\t}\n\n\tfp = fdopen(fd, \"w+\");\n\tif (!fp) {\n\t\twarn(\"jvmti: cannot create %s\", dump_path);\n\t\tclose(fd);\n\t\tgoto error;\n\t}\n\n\twarnx(\"jvmti: jitdump in %s\", dump_path);\n\n\tif (get_e_machine(&header)) {\n\t\twarn(\"get_e_machine failed\\n\");\n\t\tgoto error;\n\t}\n\n\theader.magic      = JITHEADER_MAGIC;\n\theader.version    = JITHEADER_VERSION;\n\theader.total_size = sizeof(header);\n\theader.pid        = getpid();\n\n\theader.timestamp = perf_get_timestamp();\n\n\tif (use_arch_timestamp)\n\t\theader.flags |= JITDUMP_FLAGS_ARCH_TIMESTAMP;\n\n\tif (!fwrite(&header, sizeof(header), 1, fp)) {\n\t\twarn(\"jvmti: cannot write dumpfile header\");\n\t\tgoto error;\n\t}\n\treturn fp;\nerror:\n\tfclose(fp);\n\treturn NULL;\n}\n\nint\njvmti_close(void *agent)\n{\n\tstruct jr_code_close rec;\n\tFILE *fp = agent;\n\n\tif (!fp) {\n\t\twarnx(\"jvmti: invalid fd in close_agent\");\n\t\treturn -1;\n\t}\n\n\trec.p.id = JIT_CODE_CLOSE;\n\trec.p.total_size = sizeof(rec);\n\n\trec.p.timestamp = perf_get_timestamp();\n\n\tif (!fwrite(&rec, sizeof(rec), 1, fp))\n\t\treturn -1;\n\n\tfclose(fp);\n\n\tfp = NULL;\n\n\tperf_close_marker_file();\n\n\treturn 0;\n}\n\nint\njvmti_write_code(void *agent, char const *sym,\n\tuint64_t vma, void const *code, unsigned int const size)\n{\n\tstatic int code_generation = 1;\n\tstruct jr_code_load rec;\n\tsize_t sym_len;\n\tFILE *fp = agent;\n\tint ret = -1;\n\n\t \n\tif (size == 0)\n\t\treturn 0;\n\n\tif (!fp) {\n\t\twarnx(\"jvmti: invalid fd in write_native_code\");\n\t\treturn -1;\n\t}\n\n\tsym_len = strlen(sym) + 1;\n\n\trec.p.id           = JIT_CODE_LOAD;\n\trec.p.total_size   = sizeof(rec) + sym_len;\n\trec.p.timestamp    = perf_get_timestamp();\n\n\trec.code_size  = size;\n\trec.vma        = vma;\n\trec.code_addr  = vma;\n\trec.pid\t       = getpid();\n\trec.tid\t       = gettid();\n\n\tif (code)\n\t\trec.p.total_size += size;\n\n\t \n\tflockfile(fp);\n\n\t \n\trec.code_index = code_generation++;\n\n\tret = fwrite_unlocked(&rec, sizeof(rec), 1, fp);\n\tfwrite_unlocked(sym, sym_len, 1, fp);\n\n\tif (code)\n\t\tfwrite_unlocked(code, size, 1, fp);\n\n\tfunlockfile(fp);\n\n\tret = 0;\n\n\treturn ret;\n}\n\nint\njvmti_write_debug_info(void *agent, uint64_t code,\n    int nr_lines, jvmti_line_info_t *li,\n    const char * const * file_names)\n{\n\tstruct jr_code_debug_info rec;\n\tsize_t sret, len, size, flen = 0;\n\tuint64_t addr;\n\tFILE *fp = agent;\n\tint i;\n\n\t \n\tif (!nr_lines)\n\t\treturn 0;\n\n\tif (!fp) {\n\t\twarnx(\"jvmti: invalid fd in write_debug_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < nr_lines; ++i) {\n\t    flen += strlen(file_names[i]) + 1;\n\t}\n\n\trec.p.id        = JIT_CODE_DEBUG_INFO;\n\tsize            = sizeof(rec);\n\trec.p.timestamp = perf_get_timestamp();\n\trec.code_addr   = (uint64_t)(uintptr_t)code;\n\trec.nr_entry    = nr_lines;\n\n\t \n\tsize += nr_lines * sizeof(struct debug_entry);\n\tsize += flen;\n\trec.p.total_size = size;\n\n\t \n\tflockfile(fp);\n\n\tsret = fwrite_unlocked(&rec, sizeof(rec), 1, fp);\n\tif (sret != 1)\n\t\tgoto error;\n\n\tfor (i = 0; i < nr_lines; i++) {\n\n\t\taddr = (uint64_t)li[i].pc;\n\t\tlen  = sizeof(addr);\n\t\tsret = fwrite_unlocked(&addr, len, 1, fp);\n\t\tif (sret != 1)\n\t\t\tgoto error;\n\n\t\tlen  = sizeof(li[0].line_number);\n\t\tsret = fwrite_unlocked(&li[i].line_number, len, 1, fp);\n\t\tif (sret != 1)\n\t\t\tgoto error;\n\n\t\tlen  = sizeof(li[0].discrim);\n\t\tsret = fwrite_unlocked(&li[i].discrim, len, 1, fp);\n\t\tif (sret != 1)\n\t\t\tgoto error;\n\n\t\tsret = fwrite_unlocked(file_names[i], strlen(file_names[i]) + 1, 1, fp);\n\t\tif (sret != 1)\n\t\t\tgoto error;\n\t}\n\tfunlockfile(fp);\n\treturn 0;\nerror:\n\tfunlockfile(fp);\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}