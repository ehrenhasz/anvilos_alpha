{
  "module_name": "libjvmti.c",
  "hash_id": "fa81ad5d6d40bf8868a74d82e70c29e360bfdc33f23c11c040843ecaf51e8bec",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/jvmti/libjvmti.c",
  "human_readable_source": "\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <err.h>\n#include <jvmti.h>\n#ifdef HAVE_JVMTI_CMLR\n#include <jvmticmlr.h>\n#endif\n#include <limits.h>\n\n#include \"jvmti_agent.h\"\n\nstatic int has_line_numbers;\nvoid *jvmti_agent;\n\nstatic void print_error(jvmtiEnv *jvmti, const char *msg, jvmtiError ret)\n{\n\tchar *err_msg = NULL;\n\tjvmtiError err;\n\terr = (*jvmti)->GetErrorName(jvmti, ret, &err_msg);\n\tif (err == JVMTI_ERROR_NONE) {\n\t\twarnx(\"%s failed with %s\", msg, err_msg);\n\t\t(*jvmti)->Deallocate(jvmti, (unsigned char *)err_msg);\n\t} else {\n\t\twarnx(\"%s failed with an unknown error %d\", msg, ret);\n\t}\n}\n\n#ifdef HAVE_JVMTI_CMLR\nstatic jvmtiError\ndo_get_line_number(jvmtiEnv *jvmti, void *pc, jmethodID m, jint bci,\n\t\t   jvmti_line_info_t *tab)\n{\n\tjint i, nr_lines = 0;\n\tjvmtiLineNumberEntry *loc_tab = NULL;\n\tjvmtiError ret;\n\tjint src_line = -1;\n\n\tret = (*jvmti)->GetLineNumberTable(jvmti, m, &nr_lines, &loc_tab);\n\tif (ret == JVMTI_ERROR_ABSENT_INFORMATION || ret == JVMTI_ERROR_NATIVE_METHOD) {\n\t\t \n\t\treturn ret;\n\t} else if (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"GetLineNumberTable\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr_lines && loc_tab[i].start_location <= bci; i++) {\n\t\tsrc_line = i;\n\t}\n\n\tif (src_line != -1) {\n\t\ttab->pc = (unsigned long)pc;\n\t\ttab->line_number = loc_tab[src_line].line_number;\n\t\ttab->discrim = 0;  \n\t\ttab->methodID = m;\n\n\t\tret = JVMTI_ERROR_NONE;\n\t} else {\n\t\tret = JVMTI_ERROR_ABSENT_INFORMATION;\n\t}\n\n\t(*jvmti)->Deallocate(jvmti, (unsigned char *)loc_tab);\n\n\treturn ret;\n}\n\nstatic jvmtiError\nget_line_numbers(jvmtiEnv *jvmti, const void *compile_info, jvmti_line_info_t **tab, int *nr_lines)\n{\n\tconst jvmtiCompiledMethodLoadRecordHeader *hdr;\n\tjvmtiCompiledMethodLoadInlineRecord *rec;\n\tPCStackInfo *c;\n\tjint ret;\n\tint nr_total = 0;\n\tint i, lines_total = 0;\n\n\tif (!(tab && nr_lines))\n\t\treturn JVMTI_ERROR_NULL_POINTER;\n\n\t \n\tfor (hdr = compile_info; hdr != NULL; hdr = hdr->next) {\n\t\tif (hdr->kind == JVMTI_CMLR_INLINE_INFO) {\n\t\t\trec = (jvmtiCompiledMethodLoadInlineRecord *)hdr;\n\t\t\tnr_total += rec->numpcs;\n\t\t}\n\t}\n\n\tif (nr_total == 0)\n\t\treturn JVMTI_ERROR_NOT_FOUND;\n\n\t \n\t*tab = malloc(nr_total * sizeof(**tab));\n\tif (!*tab)\n\t\treturn JVMTI_ERROR_OUT_OF_MEMORY;\n\n\tfor (hdr = compile_info; hdr != NULL; hdr = hdr->next) {\n\t\tif (hdr->kind == JVMTI_CMLR_INLINE_INFO) {\n\t\t\trec = (jvmtiCompiledMethodLoadInlineRecord *)hdr;\n\t\t\tfor (i = 0; i < rec->numpcs; i++) {\n\t\t\t\tc = rec->pcinfo + i;\n                                 \n\t\t\t\tret = do_get_line_number(jvmti, c->pc,\n\t\t\t\t\t\t\t c->methods[0],\n\t\t\t\t\t\t\t c->bcis[0],\n\t\t\t\t\t\t\t *tab + lines_total);\n\t\t\t\tif (ret == JVMTI_ERROR_NONE)\n\t\t\t\t\tlines_total++;\n\t\t\t}\n\t\t}\n\t}\n\t*nr_lines = lines_total;\n\treturn JVMTI_ERROR_NONE;\n}\n#else  \n\nstatic jvmtiError\nget_line_numbers(jvmtiEnv *jvmti __maybe_unused, const void *compile_info __maybe_unused,\n\t\t jvmti_line_info_t **tab __maybe_unused, int *nr_lines __maybe_unused)\n{\n\treturn JVMTI_ERROR_NONE;\n}\n#endif  \n\nstatic void\ncopy_class_filename(const char * class_sign, const char * file_name, char * result, size_t max_length)\n{\n\t \n\tif (*class_sign == 'L') {\n\t\tint j, i = 0;\n\t\tchar *p = strrchr(class_sign, '/');\n\t\tif (p) {\n\t\t\t \n\t\t\tfor (i = 0; i < (p - class_sign); i++)\n\t\t\t\tresult[i] = class_sign[i+1];\n\t\t}\n\t\t \n\t\tfor (j = 0; i < (max_length - 1) && file_name && j < strlen(file_name); j++, i++)\n\t\t\tresult[i] = file_name[j];\n\n\t\tresult[i] = '\\0';\n\t} else {\n\t\t \n\t\tstrlcpy(result, file_name, max_length);\n\t}\n}\n\nstatic jvmtiError\nget_source_filename(jvmtiEnv *jvmti, jmethodID methodID, char ** buffer)\n{\n\tjvmtiError ret;\n\tjclass decl_class;\n\tchar *file_name = NULL;\n\tchar *class_sign = NULL;\n\tchar fn[PATH_MAX];\n\tsize_t len;\n\n\tret = (*jvmti)->GetMethodDeclaringClass(jvmti, methodID, &decl_class);\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"GetMethodDeclaringClass\", ret);\n\t\treturn ret;\n\t}\n\n\tret = (*jvmti)->GetSourceFileName(jvmti, decl_class, &file_name);\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"GetSourceFileName\", ret);\n\t\treturn ret;\n\t}\n\n\tret = (*jvmti)->GetClassSignature(jvmti, decl_class, &class_sign, NULL);\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"GetClassSignature\", ret);\n\t\tgoto free_file_name_error;\n\t}\n\n\tcopy_class_filename(class_sign, file_name, fn, PATH_MAX);\n\tlen = strlen(fn);\n\t*buffer = malloc((len + 1) * sizeof(char));\n\tif (!*buffer) {\n\t\tprint_error(jvmti, \"GetClassSignature\", ret);\n\t\tret = JVMTI_ERROR_OUT_OF_MEMORY;\n\t\tgoto free_class_sign_error;\n\t}\n\tstrcpy(*buffer, fn);\n\tret = JVMTI_ERROR_NONE;\n\nfree_class_sign_error:\n\t(*jvmti)->Deallocate(jvmti, (unsigned char *)class_sign);\nfree_file_name_error:\n\t(*jvmti)->Deallocate(jvmti, (unsigned char *)file_name);\n\n\treturn ret;\n}\n\nstatic jvmtiError\nfill_source_filenames(jvmtiEnv *jvmti, int nr_lines,\n\t\t      const jvmti_line_info_t * line_tab,\n\t\t      char ** file_names)\n{\n\tint index;\n\tjvmtiError ret;\n\n\tfor (index = 0; index < nr_lines; ++index) {\n\t\tret = get_source_filename(jvmti, line_tab[index].methodID, &(file_names[index]));\n\t\tif (ret != JVMTI_ERROR_NONE)\n\t\t\treturn ret;\n\t}\n\n\treturn JVMTI_ERROR_NONE;\n}\n\nstatic void JNICALL\ncompiled_method_load_cb(jvmtiEnv *jvmti,\n\t\t\tjmethodID method,\n\t\t\tjint code_size,\n\t\t\tvoid const *code_addr,\n\t\t\tjint map_length,\n\t\t\tjvmtiAddrLocationMap const *map,\n\t\t\tconst void *compile_info)\n{\n\tjvmti_line_info_t *line_tab = NULL;\n\tchar ** line_file_names = NULL;\n\tjclass decl_class;\n\tchar *class_sign = NULL;\n\tchar *func_name = NULL;\n\tchar *func_sign = NULL;\n\tuint64_t addr = (uint64_t)(uintptr_t)code_addr;\n\tjvmtiError ret;\n\tint nr_lines = 0;  \n\tsize_t len;\n\tint output_debug_info = 0;\n\n\tret = (*jvmti)->GetMethodDeclaringClass(jvmti, method,\n\t\t\t\t\t\t&decl_class);\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"GetMethodDeclaringClass\", ret);\n\t\treturn;\n\t}\n\n\tif (has_line_numbers && map && map_length) {\n\t\tret = get_line_numbers(jvmti, compile_info, &line_tab, &nr_lines);\n\t\tif (ret != JVMTI_ERROR_NONE) {\n\t\t\tif (ret != JVMTI_ERROR_NOT_FOUND) {\n\t\t\t\twarnx(\"jvmti: cannot get line table for method\");\n\t\t\t}\n\t\t\tnr_lines = 0;\n\t\t} else if (nr_lines > 0) {\n\t\t\tline_file_names = malloc(sizeof(char*) * nr_lines);\n\t\t\tif (!line_file_names) {\n\t\t\t\twarnx(\"jvmti: cannot allocate space for line table method names\");\n\t\t\t} else {\n\t\t\t\tmemset(line_file_names, 0, sizeof(char*) * nr_lines);\n\t\t\t\tret = fill_source_filenames(jvmti, nr_lines, line_tab, line_file_names);\n\t\t\t\tif (ret != JVMTI_ERROR_NONE) {\n\t\t\t\t\twarnx(\"jvmti: fill_source_filenames failed\");\n\t\t\t\t} else {\n\t\t\t\t\toutput_debug_info = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tret = (*jvmti)->GetClassSignature(jvmti, decl_class,\n\t\t\t\t\t  &class_sign, NULL);\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"GetClassSignature\", ret);\n\t\tgoto error;\n\t}\n\n\tret = (*jvmti)->GetMethodName(jvmti, method, &func_name,\n\t\t\t\t      &func_sign, NULL);\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"GetMethodName\", ret);\n\t\tgoto error;\n\t}\n\n\t \n\tif (output_debug_info)\n\t\tif (jvmti_write_debug_info(jvmti_agent, addr, nr_lines, line_tab, (const char * const *) line_file_names))\n\t\t\twarnx(\"jvmti: write_debug_info() failed\");\n\n\tlen = strlen(func_name) + strlen(class_sign) + strlen(func_sign) + 2;\n\t{\n\t\tchar str[len];\n\t\tsnprintf(str, len, \"%s%s%s\", class_sign, func_name, func_sign);\n\n\t\tif (jvmti_write_code(jvmti_agent, str, addr, code_addr, code_size))\n\t\t\twarnx(\"jvmti: write_code() failed\");\n\t}\nerror:\n\t(*jvmti)->Deallocate(jvmti, (unsigned char *)func_name);\n\t(*jvmti)->Deallocate(jvmti, (unsigned char *)func_sign);\n\t(*jvmti)->Deallocate(jvmti, (unsigned char *)class_sign);\n\tfree(line_tab);\n\twhile (line_file_names && (nr_lines > 0)) {\n\t    if (line_file_names[nr_lines - 1]) {\n\t        free(line_file_names[nr_lines - 1]);\n\t    }\n\t    nr_lines -= 1;\n\t}\n\tfree(line_file_names);\n}\n\nstatic void JNICALL\ncode_generated_cb(jvmtiEnv *jvmti,\n\t\t  char const *name,\n\t\t  void const *code_addr,\n\t\t  jint code_size)\n{\n\tuint64_t addr = (uint64_t)(unsigned long)code_addr;\n\tint ret;\n\n\tret = jvmti_write_code(jvmti_agent, name, addr, code_addr, code_size);\n\tif (ret)\n\t\twarnx(\"jvmti: write_code() failed for code_generated\");\n}\n\nJNIEXPORT jint JNICALL\nAgent_OnLoad(JavaVM *jvm, char *options, void *reserved __maybe_unused)\n{\n\tjvmtiEventCallbacks cb;\n\tjvmtiCapabilities caps1;\n\tjvmtiJlocationFormat format;\n\tjvmtiEnv *jvmti = NULL;\n\tjint ret;\n\n\tjvmti_agent = jvmti_open();\n\tif (!jvmti_agent) {\n\t\twarnx(\"jvmti: open_agent failed\");\n\t\treturn -1;\n\t}\n\n\t \n\tret = (*jvm)->GetEnv(jvm, (void *)&jvmti, JVMTI_VERSION_1);\n\tif (ret != JNI_OK) {\n\t\twarnx(\"jvmti: jvmti version 1 not supported\");\n\t\treturn -1;\n\t}\n\n\t \n\tmemset(&caps1, 0, sizeof(caps1));\n\tcaps1.can_generate_compiled_method_load_events = 1;\n\n\tret = (*jvmti)->AddCapabilities(jvmti, &caps1);\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"AddCapabilities\", ret);\n\t\treturn -1;\n\t}\n\tret = (*jvmti)->GetJLocationFormat(jvmti, &format);\n        if (ret == JVMTI_ERROR_NONE && format == JVMTI_JLOCATION_JVMBCI) {\n                memset(&caps1, 0, sizeof(caps1));\n                caps1.can_get_line_numbers = 1;\n                caps1.can_get_source_file_name = 1;\n\t\tret = (*jvmti)->AddCapabilities(jvmti, &caps1);\n                if (ret == JVMTI_ERROR_NONE)\n                        has_line_numbers = 1;\n        } else if (ret != JVMTI_ERROR_NONE)\n\t\tprint_error(jvmti, \"GetJLocationFormat\", ret);\n\n\n\tmemset(&cb, 0, sizeof(cb));\n\n\tcb.CompiledMethodLoad   = compiled_method_load_cb;\n\tcb.DynamicCodeGenerated = code_generated_cb;\n\n\tret = (*jvmti)->SetEventCallbacks(jvmti, &cb, sizeof(cb));\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"SetEventCallbacks\", ret);\n\t\treturn -1;\n\t}\n\n\tret = (*jvmti)->SetEventNotificationMode(jvmti, JVMTI_ENABLE,\n\t\t\tJVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"SetEventNotificationMode(METHOD_LOAD)\", ret);\n\t\treturn -1;\n\t}\n\n\tret = (*jvmti)->SetEventNotificationMode(jvmti, JVMTI_ENABLE,\n\t\t\tJVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL);\n\tif (ret != JVMTI_ERROR_NONE) {\n\t\tprint_error(jvmti, \"SetEventNotificationMode(CODE_GENERATED)\", ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nJNIEXPORT void JNICALL\nAgent_OnUnload(JavaVM *jvm __maybe_unused)\n{\n\tint ret;\n\n\tret = jvmti_close(jvmti_agent);\n\tif (ret)\n\t\terrx(1, \"Error: op_close_agent()\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}