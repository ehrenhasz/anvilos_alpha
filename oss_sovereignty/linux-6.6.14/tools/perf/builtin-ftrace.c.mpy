{
  "module_name": "builtin-ftrace.c",
  "hash_id": "e02e4788b5f1002fefe27f473b9a08234b70f716ef366e558c9d0a6e6b5d0ec5",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-ftrace.c",
  "human_readable_source": "\n \n\n#include \"builtin.h\"\n\n#include <errno.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <poll.h>\n#include <ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n\n#include \"debug.h\"\n#include <subcmd/pager.h>\n#include <subcmd/parse-options.h>\n#include <api/fs/tracing_path.h>\n#include \"evlist.h\"\n#include \"target.h\"\n#include \"cpumap.h\"\n#include \"thread_map.h\"\n#include \"strfilter.h\"\n#include \"util/cap.h\"\n#include \"util/config.h\"\n#include \"util/ftrace.h\"\n#include \"util/units.h\"\n#include \"util/parse-sublevel-options.h\"\n\n#define DEFAULT_TRACER  \"function_graph\"\n\nstatic volatile sig_atomic_t workload_exec_errno;\nstatic volatile sig_atomic_t done;\n\nstatic void sig_handler(int sig __maybe_unused)\n{\n\tdone = true;\n}\n\n \nstatic void ftrace__workload_exec_failed_signal(int signo __maybe_unused,\n\t\t\t\t\t\tsiginfo_t *info __maybe_unused,\n\t\t\t\t\t\tvoid *ucontext __maybe_unused)\n{\n\tworkload_exec_errno = info->si_value.sival_int;\n\tdone = true;\n}\n\nstatic int __write_tracing_file(const char *name, const char *val, bool append)\n{\n\tchar *file;\n\tint fd, ret = -1;\n\tssize_t size = strlen(val);\n\tint flags = O_WRONLY;\n\tchar errbuf[512];\n\tchar *val_copy;\n\n\tfile = get_tracing_file(name);\n\tif (!file) {\n\t\tpr_debug(\"cannot get tracing file: %s\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (append)\n\t\tflags |= O_APPEND;\n\telse\n\t\tflags |= O_TRUNC;\n\n\tfd = open(file, flags);\n\tif (fd < 0) {\n\t\tpr_debug(\"cannot open tracing file: %s: %s\\n\",\n\t\t\t name, str_error_r(errno, errbuf, sizeof(errbuf)));\n\t\tgoto out;\n\t}\n\n\t \n\tval_copy = strdup(val);\n\tif (!val_copy)\n\t\tgoto out_close;\n\tval_copy[size] = '\\n';\n\n\tif (write(fd, val_copy, size + 1) == size + 1)\n\t\tret = 0;\n\telse\n\t\tpr_debug(\"write '%s' to tracing/%s failed: %s\\n\",\n\t\t\t val, name, str_error_r(errno, errbuf, sizeof(errbuf)));\n\n\tfree(val_copy);\nout_close:\n\tclose(fd);\nout:\n\tput_tracing_file(file);\n\treturn ret;\n}\n\nstatic int write_tracing_file(const char *name, const char *val)\n{\n\treturn __write_tracing_file(name, val, false);\n}\n\nstatic int append_tracing_file(const char *name, const char *val)\n{\n\treturn __write_tracing_file(name, val, true);\n}\n\nstatic int read_tracing_file_to_stdout(const char *name)\n{\n\tchar buf[4096];\n\tchar *file;\n\tint fd;\n\tint ret = -1;\n\n\tfile = get_tracing_file(name);\n\tif (!file) {\n\t\tpr_debug(\"cannot get tracing file: %s\\n\", name);\n\t\treturn -1;\n\t}\n\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t\tpr_debug(\"cannot open tracing file: %s: %s\\n\",\n\t\t\t name, str_error_r(errno, buf, sizeof(buf)));\n\t\tgoto out;\n\t}\n\n\t \n\twhile (true) {\n\t\tint n = read(fd, buf, sizeof(buf));\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\telse if (n < 0)\n\t\t\tgoto out_close;\n\n\t\tif (fwrite(buf, n, 1, stdout) != 1)\n\t\t\tgoto out_close;\n\t}\n\tret = 0;\n\nout_close:\n\tclose(fd);\nout:\n\tput_tracing_file(file);\n\treturn ret;\n}\n\nstatic int read_tracing_file_by_line(const char *name,\n\t\t\t\t     void (*cb)(char *str, void *arg),\n\t\t\t\t     void *cb_arg)\n{\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tchar *file;\n\tFILE *fp;\n\n\tfile = get_tracing_file(name);\n\tif (!file) {\n\t\tpr_debug(\"cannot get tracing file: %s\\n\", name);\n\t\treturn -1;\n\t}\n\n\tfp = fopen(file, \"r\");\n\tif (fp == NULL) {\n\t\tpr_debug(\"cannot open tracing file: %s\\n\", name);\n\t\tput_tracing_file(file);\n\t\treturn -1;\n\t}\n\n\twhile (getline(&line, &len, fp) != -1) {\n\t\tcb(line, cb_arg);\n\t}\n\n\tif (line)\n\t\tfree(line);\n\n\tfclose(fp);\n\tput_tracing_file(file);\n\treturn 0;\n}\n\nstatic int write_tracing_file_int(const char *name, int value)\n{\n\tchar buf[16];\n\n\tsnprintf(buf, sizeof(buf), \"%d\", value);\n\tif (write_tracing_file(name, buf) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int write_tracing_option_file(const char *name, const char *val)\n{\n\tchar *file;\n\tint ret;\n\n\tif (asprintf(&file, \"options/%s\", name) < 0)\n\t\treturn -1;\n\n\tret = __write_tracing_file(file, val, false);\n\tfree(file);\n\treturn ret;\n}\n\nstatic int reset_tracing_cpu(void);\nstatic void reset_tracing_filters(void);\n\nstatic void reset_tracing_options(struct perf_ftrace *ftrace __maybe_unused)\n{\n\twrite_tracing_option_file(\"function-fork\", \"0\");\n\twrite_tracing_option_file(\"func_stack_trace\", \"0\");\n\twrite_tracing_option_file(\"sleep-time\", \"1\");\n\twrite_tracing_option_file(\"funcgraph-irqs\", \"1\");\n\twrite_tracing_option_file(\"funcgraph-proc\", \"0\");\n\twrite_tracing_option_file(\"funcgraph-abstime\", \"0\");\n\twrite_tracing_option_file(\"latency-format\", \"0\");\n\twrite_tracing_option_file(\"irq-info\", \"0\");\n}\n\nstatic int reset_tracing_files(struct perf_ftrace *ftrace __maybe_unused)\n{\n\tif (write_tracing_file(\"tracing_on\", \"0\") < 0)\n\t\treturn -1;\n\n\tif (write_tracing_file(\"current_tracer\", \"nop\") < 0)\n\t\treturn -1;\n\n\tif (write_tracing_file(\"set_ftrace_pid\", \" \") < 0)\n\t\treturn -1;\n\n\tif (reset_tracing_cpu() < 0)\n\t\treturn -1;\n\n\tif (write_tracing_file(\"max_graph_depth\", \"0\") < 0)\n\t\treturn -1;\n\n\tif (write_tracing_file(\"tracing_thresh\", \"0\") < 0)\n\t\treturn -1;\n\n\treset_tracing_filters();\n\treset_tracing_options(ftrace);\n\treturn 0;\n}\n\nstatic int set_tracing_pid(struct perf_ftrace *ftrace)\n{\n\tint i;\n\tchar buf[16];\n\n\tif (target__has_cpu(&ftrace->target))\n\t\treturn 0;\n\n\tfor (i = 0; i < perf_thread_map__nr(ftrace->evlist->core.threads); i++) {\n\t\tscnprintf(buf, sizeof(buf), \"%d\",\n\t\t\t  perf_thread_map__pid(ftrace->evlist->core.threads, i));\n\t\tif (append_tracing_file(\"set_ftrace_pid\", buf) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int set_tracing_cpumask(struct perf_cpu_map *cpumap)\n{\n\tchar *cpumask;\n\tsize_t mask_size;\n\tint ret;\n\tint last_cpu;\n\n\tlast_cpu = perf_cpu_map__cpu(cpumap, perf_cpu_map__nr(cpumap) - 1).cpu;\n\tmask_size = last_cpu / 4 + 2;  \n\tmask_size += last_cpu / 32;  \n\n\tcpumask = malloc(mask_size);\n\tif (cpumask == NULL) {\n\t\tpr_debug(\"failed to allocate cpu mask\\n\");\n\t\treturn -1;\n\t}\n\n\tcpu_map__snprint_mask(cpumap, cpumask, mask_size);\n\n\tret = write_tracing_file(\"tracing_cpumask\", cpumask);\n\n\tfree(cpumask);\n\treturn ret;\n}\n\nstatic int set_tracing_cpu(struct perf_ftrace *ftrace)\n{\n\tstruct perf_cpu_map *cpumap = ftrace->evlist->core.user_requested_cpus;\n\n\tif (!target__has_cpu(&ftrace->target))\n\t\treturn 0;\n\n\treturn set_tracing_cpumask(cpumap);\n}\n\nstatic int set_tracing_func_stack_trace(struct perf_ftrace *ftrace)\n{\n\tif (!ftrace->func_stack_trace)\n\t\treturn 0;\n\n\tif (write_tracing_option_file(\"func_stack_trace\", \"1\") < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int set_tracing_func_irqinfo(struct perf_ftrace *ftrace)\n{\n\tif (!ftrace->func_irq_info)\n\t\treturn 0;\n\n\tif (write_tracing_option_file(\"irq-info\", \"1\") < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int reset_tracing_cpu(void)\n{\n\tstruct perf_cpu_map *cpumap = perf_cpu_map__new(NULL);\n\tint ret;\n\n\tret = set_tracing_cpumask(cpumap);\n\tperf_cpu_map__put(cpumap);\n\treturn ret;\n}\n\nstatic int __set_tracing_filter(const char *filter_file, struct list_head *funcs)\n{\n\tstruct filter_entry *pos;\n\n\tlist_for_each_entry(pos, funcs, list) {\n\t\tif (append_tracing_file(filter_file, pos->name) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_tracing_filters(struct perf_ftrace *ftrace)\n{\n\tint ret;\n\n\tret = __set_tracing_filter(\"set_ftrace_filter\", &ftrace->filters);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __set_tracing_filter(\"set_ftrace_notrace\", &ftrace->notrace);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __set_tracing_filter(\"set_graph_function\", &ftrace->graph_funcs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t__set_tracing_filter(\"set_graph_notrace\", &ftrace->nograph_funcs);\n\n\treturn ret;\n}\n\nstatic void reset_tracing_filters(void)\n{\n\twrite_tracing_file(\"set_ftrace_filter\", \" \");\n\twrite_tracing_file(\"set_ftrace_notrace\", \" \");\n\twrite_tracing_file(\"set_graph_function\", \" \");\n\twrite_tracing_file(\"set_graph_notrace\", \" \");\n}\n\nstatic int set_tracing_depth(struct perf_ftrace *ftrace)\n{\n\tif (ftrace->graph_depth == 0)\n\t\treturn 0;\n\n\tif (ftrace->graph_depth < 0) {\n\t\tpr_err(\"invalid graph depth: %d\\n\", ftrace->graph_depth);\n\t\treturn -1;\n\t}\n\n\tif (write_tracing_file_int(\"max_graph_depth\", ftrace->graph_depth) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int set_tracing_percpu_buffer_size(struct perf_ftrace *ftrace)\n{\n\tint ret;\n\n\tif (ftrace->percpu_buffer_size == 0)\n\t\treturn 0;\n\n\tret = write_tracing_file_int(\"buffer_size_kb\",\n\t\t\t\t     ftrace->percpu_buffer_size / 1024);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int set_tracing_trace_inherit(struct perf_ftrace *ftrace)\n{\n\tif (!ftrace->inherit)\n\t\treturn 0;\n\n\tif (write_tracing_option_file(\"function-fork\", \"1\") < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int set_tracing_sleep_time(struct perf_ftrace *ftrace)\n{\n\tif (!ftrace->graph_nosleep_time)\n\t\treturn 0;\n\n\tif (write_tracing_option_file(\"sleep-time\", \"0\") < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int set_tracing_funcgraph_irqs(struct perf_ftrace *ftrace)\n{\n\tif (!ftrace->graph_noirqs)\n\t\treturn 0;\n\n\tif (write_tracing_option_file(\"funcgraph-irqs\", \"0\") < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int set_tracing_funcgraph_verbose(struct perf_ftrace *ftrace)\n{\n\tif (!ftrace->graph_verbose)\n\t\treturn 0;\n\n\tif (write_tracing_option_file(\"funcgraph-proc\", \"1\") < 0)\n\t\treturn -1;\n\n\tif (write_tracing_option_file(\"funcgraph-abstime\", \"1\") < 0)\n\t\treturn -1;\n\n\tif (write_tracing_option_file(\"latency-format\", \"1\") < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int set_tracing_thresh(struct perf_ftrace *ftrace)\n{\n\tint ret;\n\n\tif (ftrace->graph_thresh == 0)\n\t\treturn 0;\n\n\tret = write_tracing_file_int(\"tracing_thresh\", ftrace->graph_thresh);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int set_tracing_options(struct perf_ftrace *ftrace)\n{\n\tif (set_tracing_pid(ftrace) < 0) {\n\t\tpr_err(\"failed to set ftrace pid\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_cpu(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing cpumask\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_func_stack_trace(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing option func_stack_trace\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_func_irqinfo(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing option irq-info\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_filters(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing filters\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_depth(ftrace) < 0) {\n\t\tpr_err(\"failed to set graph depth\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_percpu_buffer_size(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing per-cpu buffer size\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_trace_inherit(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing option function-fork\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_sleep_time(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing option sleep-time\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_funcgraph_irqs(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing option funcgraph-irqs\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_funcgraph_verbose(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing option funcgraph-proc/funcgraph-abstime\\n\");\n\t\treturn -1;\n\t}\n\n\tif (set_tracing_thresh(ftrace) < 0) {\n\t\tpr_err(\"failed to set tracing thresh\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void select_tracer(struct perf_ftrace *ftrace)\n{\n\tbool graph = !list_empty(&ftrace->graph_funcs) ||\n\t\t     !list_empty(&ftrace->nograph_funcs);\n\tbool func = !list_empty(&ftrace->filters) ||\n\t\t    !list_empty(&ftrace->notrace);\n\n\t \n\tif (graph)\n\t\tftrace->tracer = \"function_graph\";\n\telse if (func)\n\t\tftrace->tracer = \"function\";\n\t \n\n\tpr_debug(\"%s tracer is used\\n\", ftrace->tracer);\n}\n\nstatic int __cmd_ftrace(struct perf_ftrace *ftrace)\n{\n\tchar *trace_file;\n\tint trace_fd;\n\tchar buf[4096];\n\tstruct pollfd pollfd = {\n\t\t.events = POLLIN,\n\t};\n\n\tif (!(perf_cap__capable(CAP_PERFMON) ||\n\t      perf_cap__capable(CAP_SYS_ADMIN))) {\n\t\tpr_err(\"ftrace only works for %s!\\n\",\n#ifdef HAVE_LIBCAP_SUPPORT\n\t\t\"users with the CAP_PERFMON or CAP_SYS_ADMIN capability\"\n#else\n\t\t\"root\"\n#endif\n\t\t);\n\t\treturn -1;\n\t}\n\n\tselect_tracer(ftrace);\n\n\tif (reset_tracing_files(ftrace) < 0) {\n\t\tpr_err(\"failed to reset ftrace\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (write_tracing_file(\"trace\", \"0\") < 0)\n\t\tgoto out;\n\n\tif (set_tracing_options(ftrace) < 0)\n\t\tgoto out_reset;\n\n\tif (write_tracing_file(\"current_tracer\", ftrace->tracer) < 0) {\n\t\tpr_err(\"failed to set current_tracer to %s\\n\", ftrace->tracer);\n\t\tgoto out_reset;\n\t}\n\n\tsetup_pager();\n\n\ttrace_file = get_tracing_file(\"trace_pipe\");\n\tif (!trace_file) {\n\t\tpr_err(\"failed to open trace_pipe\\n\");\n\t\tgoto out_reset;\n\t}\n\n\ttrace_fd = open(trace_file, O_RDONLY);\n\n\tput_tracing_file(trace_file);\n\n\tif (trace_fd < 0) {\n\t\tpr_err(\"failed to open trace_pipe\\n\");\n\t\tgoto out_reset;\n\t}\n\n\tfcntl(trace_fd, F_SETFL, O_NONBLOCK);\n\tpollfd.fd = trace_fd;\n\n\t \n\tread_tracing_file_to_stdout(\"trace\");\n\n\tif (!ftrace->target.initial_delay) {\n\t\tif (write_tracing_file(\"tracing_on\", \"1\") < 0) {\n\t\t\tpr_err(\"can't enable tracing\\n\");\n\t\t\tgoto out_close_fd;\n\t\t}\n\t}\n\n\tevlist__start_workload(ftrace->evlist);\n\n\tif (ftrace->target.initial_delay > 0) {\n\t\tusleep(ftrace->target.initial_delay * 1000);\n\t\tif (write_tracing_file(\"tracing_on\", \"1\") < 0) {\n\t\t\tpr_err(\"can't enable tracing\\n\");\n\t\t\tgoto out_close_fd;\n\t\t}\n\t}\n\n\twhile (!done) {\n\t\tif (poll(&pollfd, 1, -1) < 0)\n\t\t\tbreak;\n\n\t\tif (pollfd.revents & POLLIN) {\n\t\t\tint n = read(trace_fd, buf, sizeof(buf));\n\t\t\tif (n < 0)\n\t\t\t\tbreak;\n\t\t\tif (fwrite(buf, n, 1, stdout) != 1)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tfflush(stdout);\n\t\t}\n\t}\n\n\twrite_tracing_file(\"tracing_on\", \"0\");\n\n\tif (workload_exec_errno) {\n\t\tconst char *emsg = str_error_r(workload_exec_errno, buf, sizeof(buf));\n\t\t \n\t\tfflush(stdout);\n\t\tpr_err(\"workload failed: %s\\n\", emsg);\n\t\tgoto out_close_fd;\n\t}\n\n\t \n\twhile (true) {\n\t\tint n = read(trace_fd, buf, sizeof(buf));\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (fwrite(buf, n, 1, stdout) != 1)\n\t\t\tbreak;\n\t}\n\nout_close_fd:\n\tclose(trace_fd);\nout_reset:\n\treset_tracing_files(ftrace);\nout:\n\treturn (done && !workload_exec_errno) ? 0 : -1;\n}\n\nstatic void make_histogram(int buckets[], char *buf, size_t len, char *linebuf,\n\t\t\t   bool use_nsec)\n{\n\tchar *p, *q;\n\tchar *unit;\n\tdouble num;\n\tint i;\n\n\t \n\tbuf[len] = '\\0';\n\n\t \n\tfor (p = buf; (q = strchr(p, '\\n')) != NULL; p = q + 1) {\n\t\t*q = '\\0';\n\t\t \n\t\tstrcat(linebuf, p);\n\n\t\t \n\t\tif (linebuf[0] == '#')\n\t\t\tgoto next;\n\n\t\t \n\t\tp = strchr(linebuf, ')');\n\t\tif (p == NULL)\n\t\t\tp = linebuf;\n\n\t\twhile (*p && !isdigit(*p) && (*p != '|'))\n\t\t\tp++;\n\n\t\t \n\t\tif (*p == '\\0' || *p == '|')\n\t\t\tgoto next;\n\n\t\tnum = strtod(p, &unit);\n\t\tif (!unit || strncmp(unit, \" us\", 3))\n\t\t\tgoto next;\n\n\t\tif (use_nsec)\n\t\t\tnum *= 1000;\n\n\t\ti = log2(num);\n\t\tif (i < 0)\n\t\t\ti = 0;\n\t\tif (i >= NUM_BUCKET)\n\t\t\ti = NUM_BUCKET - 1;\n\n\t\tbuckets[i]++;\n\nnext:\n\t\t \n\t\tlinebuf[0] = '\\0';\n\t}\n\n\t \n\tstrcat(linebuf, p);\n}\n\nstatic void display_histogram(int buckets[], bool use_nsec)\n{\n\tint i;\n\tint total = 0;\n\tint bar_total = 46;   \n\tchar bar[] = \"###############################################\";\n\tint bar_len;\n\n\tfor (i = 0; i < NUM_BUCKET; i++)\n\t\ttotal += buckets[i];\n\n\tif (total == 0) {\n\t\tprintf(\"No data found\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"# %14s | %10s | %-*s |\\n\",\n\t       \"  DURATION    \", \"COUNT\", bar_total, \"GRAPH\");\n\n\tbar_len = buckets[0] * bar_total / total;\n\tprintf(\"  %4d - %-4d %s | %10d | %.*s%*s |\\n\",\n\t       0, 1, \"us\", buckets[0], bar_len, bar, bar_total - bar_len, \"\");\n\n\tfor (i = 1; i < NUM_BUCKET - 1; i++) {\n\t\tint start = (1 << (i - 1));\n\t\tint stop = 1 << i;\n\t\tconst char *unit = use_nsec ? \"ns\" : \"us\";\n\n\t\tif (start >= 1024) {\n\t\t\tstart >>= 10;\n\t\t\tstop >>= 10;\n\t\t\tunit = use_nsec ? \"us\" : \"ms\";\n\t\t}\n\t\tbar_len = buckets[i] * bar_total / total;\n\t\tprintf(\"  %4d - %-4d %s | %10d | %.*s%*s |\\n\",\n\t\t       start, stop, unit, buckets[i], bar_len, bar,\n\t\t       bar_total - bar_len, \"\");\n\t}\n\n\tbar_len = buckets[NUM_BUCKET - 1] * bar_total / total;\n\tprintf(\"  %4d - %-4s %s | %10d | %.*s%*s |\\n\",\n\t       1, \"...\", use_nsec ? \"ms\" : \" s\", buckets[NUM_BUCKET - 1],\n\t       bar_len, bar, bar_total - bar_len, \"\");\n\n}\n\nstatic int prepare_func_latency(struct perf_ftrace *ftrace)\n{\n\tchar *trace_file;\n\tint fd;\n\n\tif (ftrace->target.use_bpf)\n\t\treturn perf_ftrace__latency_prepare_bpf(ftrace);\n\n\tif (reset_tracing_files(ftrace) < 0) {\n\t\tpr_err(\"failed to reset ftrace\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (write_tracing_file(\"trace\", \"0\") < 0)\n\t\treturn -1;\n\n\tif (set_tracing_options(ftrace) < 0)\n\t\treturn -1;\n\n\t \n\tif (write_tracing_file(\"current_tracer\", \"function_graph\") < 0) {\n\t\tpr_err(\"failed to set current_tracer to function_graph\\n\");\n\t\treturn -1;\n\t}\n\n\ttrace_file = get_tracing_file(\"trace_pipe\");\n\tif (!trace_file) {\n\t\tpr_err(\"failed to open trace_pipe\\n\");\n\t\treturn -1;\n\t}\n\n\tfd = open(trace_file, O_RDONLY);\n\tif (fd < 0)\n\t\tpr_err(\"failed to open trace_pipe\\n\");\n\n\tput_tracing_file(trace_file);\n\treturn fd;\n}\n\nstatic int start_func_latency(struct perf_ftrace *ftrace)\n{\n\tif (ftrace->target.use_bpf)\n\t\treturn perf_ftrace__latency_start_bpf(ftrace);\n\n\tif (write_tracing_file(\"tracing_on\", \"1\") < 0) {\n\t\tpr_err(\"can't enable tracing\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int stop_func_latency(struct perf_ftrace *ftrace)\n{\n\tif (ftrace->target.use_bpf)\n\t\treturn perf_ftrace__latency_stop_bpf(ftrace);\n\n\twrite_tracing_file(\"tracing_on\", \"0\");\n\treturn 0;\n}\n\nstatic int read_func_latency(struct perf_ftrace *ftrace, int buckets[])\n{\n\tif (ftrace->target.use_bpf)\n\t\treturn perf_ftrace__latency_read_bpf(ftrace, buckets);\n\n\treturn 0;\n}\n\nstatic int cleanup_func_latency(struct perf_ftrace *ftrace)\n{\n\tif (ftrace->target.use_bpf)\n\t\treturn perf_ftrace__latency_cleanup_bpf(ftrace);\n\n\treset_tracing_files(ftrace);\n\treturn 0;\n}\n\nstatic int __cmd_latency(struct perf_ftrace *ftrace)\n{\n\tint trace_fd;\n\tchar buf[4096];\n\tchar line[256];\n\tstruct pollfd pollfd = {\n\t\t.events = POLLIN,\n\t};\n\tint buckets[NUM_BUCKET] = { };\n\n\tif (!(perf_cap__capable(CAP_PERFMON) ||\n\t      perf_cap__capable(CAP_SYS_ADMIN))) {\n\t\tpr_err(\"ftrace only works for %s!\\n\",\n#ifdef HAVE_LIBCAP_SUPPORT\n\t\t\"users with the CAP_PERFMON or CAP_SYS_ADMIN capability\"\n#else\n\t\t\"root\"\n#endif\n\t\t);\n\t\treturn -1;\n\t}\n\n\ttrace_fd = prepare_func_latency(ftrace);\n\tif (trace_fd < 0)\n\t\tgoto out;\n\n\tfcntl(trace_fd, F_SETFL, O_NONBLOCK);\n\tpollfd.fd = trace_fd;\n\n\tif (start_func_latency(ftrace) < 0)\n\t\tgoto out;\n\n\tevlist__start_workload(ftrace->evlist);\n\n\tline[0] = '\\0';\n\twhile (!done) {\n\t\tif (poll(&pollfd, 1, -1) < 0)\n\t\t\tbreak;\n\n\t\tif (pollfd.revents & POLLIN) {\n\t\t\tint n = read(trace_fd, buf, sizeof(buf) - 1);\n\t\t\tif (n < 0)\n\t\t\t\tbreak;\n\n\t\t\tmake_histogram(buckets, buf, n, line, ftrace->use_nsec);\n\t\t}\n\t}\n\n\tstop_func_latency(ftrace);\n\n\tif (workload_exec_errno) {\n\t\tconst char *emsg = str_error_r(workload_exec_errno, buf, sizeof(buf));\n\t\tpr_err(\"workload failed: %s\\n\", emsg);\n\t\tgoto out;\n\t}\n\n\t \n\twhile (!ftrace->target.use_bpf) {\n\t\tint n = read(trace_fd, buf, sizeof(buf) - 1);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tmake_histogram(buckets, buf, n, line, ftrace->use_nsec);\n\t}\n\n\tread_func_latency(ftrace, buckets);\n\n\tdisplay_histogram(buckets, ftrace->use_nsec);\n\nout:\n\tclose(trace_fd);\n\tcleanup_func_latency(ftrace);\n\n\treturn (done && !workload_exec_errno) ? 0 : -1;\n}\n\nstatic int perf_ftrace_config(const char *var, const char *value, void *cb)\n{\n\tstruct perf_ftrace *ftrace = cb;\n\n\tif (!strstarts(var, \"ftrace.\"))\n\t\treturn 0;\n\n\tif (strcmp(var, \"ftrace.tracer\"))\n\t\treturn -1;\n\n\tif (!strcmp(value, \"function_graph\") ||\n\t    !strcmp(value, \"function\")) {\n\t\tftrace->tracer = value;\n\t\treturn 0;\n\t}\n\n\tpr_err(\"Please select \\\"function_graph\\\" (default) or \\\"function\\\"\\n\");\n\treturn -1;\n}\n\nstatic void list_function_cb(char *str, void *arg)\n{\n\tstruct strfilter *filter = (struct strfilter *)arg;\n\n\tif (strfilter__compare(filter, str))\n\t\tprintf(\"%s\", str);\n}\n\nstatic int opt_list_avail_functions(const struct option *opt __maybe_unused,\n\t\t\t\t    const char *str, int unset)\n{\n\tstruct strfilter *filter;\n\tconst char *err = NULL;\n\tint ret;\n\n\tif (unset || !str)\n\t\treturn -1;\n\n\tfilter = strfilter__new(str, &err);\n\tif (!filter)\n\t\treturn err ? -EINVAL : -ENOMEM;\n\n\tret = strfilter__or(filter, str, &err);\n\tif (ret == -EINVAL) {\n\t\tpr_err(\"Filter parse error at %td.\\n\", err - str + 1);\n\t\tpr_err(\"Source: \\\"%s\\\"\\n\", str);\n\t\tpr_err(\"         %*c\\n\", (int)(err - str + 1), '^');\n\t\tstrfilter__delete(filter);\n\t\treturn ret;\n\t}\n\n\tret = read_tracing_file_by_line(\"available_filter_functions\",\n\t\t\t\t\tlist_function_cb, filter);\n\tstrfilter__delete(filter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\texit(0);\n}\n\nstatic int parse_filter_func(const struct option *opt, const char *str,\n\t\t\t     int unset __maybe_unused)\n{\n\tstruct list_head *head = opt->value;\n\tstruct filter_entry *entry;\n\n\tentry = malloc(sizeof(*entry) + strlen(str) + 1);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\n\tstrcpy(entry->name, str);\n\tlist_add_tail(&entry->list, head);\n\n\treturn 0;\n}\n\nstatic void delete_filter_func(struct list_head *head)\n{\n\tstruct filter_entry *pos, *tmp;\n\n\tlist_for_each_entry_safe(pos, tmp, head, list) {\n\t\tlist_del_init(&pos->list);\n\t\tfree(pos);\n\t}\n}\n\nstatic int parse_buffer_size(const struct option *opt,\n\t\t\t     const char *str, int unset)\n{\n\tunsigned long *s = (unsigned long *)opt->value;\n\tstatic struct parse_tag tags_size[] = {\n\t\t{ .tag  = 'B', .mult = 1       },\n\t\t{ .tag  = 'K', .mult = 1 << 10 },\n\t\t{ .tag  = 'M', .mult = 1 << 20 },\n\t\t{ .tag  = 'G', .mult = 1 << 30 },\n\t\t{ .tag  = 0 },\n\t};\n\tunsigned long val;\n\n\tif (unset) {\n\t\t*s = 0;\n\t\treturn 0;\n\t}\n\n\tval = parse_tag_value(str, tags_size);\n\tif (val != (unsigned long) -1) {\n\t\tif (val < 1024) {\n\t\t\tpr_err(\"buffer size too small, must larger than 1KB.\");\n\t\t\treturn -1;\n\t\t}\n\t\t*s = val;\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\nstatic int parse_func_tracer_opts(const struct option *opt,\n\t\t\t\t  const char *str, int unset)\n{\n\tint ret;\n\tstruct perf_ftrace *ftrace = (struct perf_ftrace *) opt->value;\n\tstruct sublevel_option func_tracer_opts[] = {\n\t\t{ .name = \"call-graph\",\t.value_ptr = &ftrace->func_stack_trace },\n\t\t{ .name = \"irq-info\",\t.value_ptr = &ftrace->func_irq_info },\n\t\t{ .name = NULL, }\n\t};\n\n\tif (unset)\n\t\treturn 0;\n\n\tret = perf_parse_sublevel_options(str, func_tracer_opts);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int parse_graph_tracer_opts(const struct option *opt,\n\t\t\t\t  const char *str, int unset)\n{\n\tint ret;\n\tstruct perf_ftrace *ftrace = (struct perf_ftrace *) opt->value;\n\tstruct sublevel_option graph_tracer_opts[] = {\n\t\t{ .name = \"nosleep-time\",\t.value_ptr = &ftrace->graph_nosleep_time },\n\t\t{ .name = \"noirqs\",\t\t.value_ptr = &ftrace->graph_noirqs },\n\t\t{ .name = \"verbose\",\t\t.value_ptr = &ftrace->graph_verbose },\n\t\t{ .name = \"thresh\",\t\t.value_ptr = &ftrace->graph_thresh },\n\t\t{ .name = \"depth\",\t\t.value_ptr = &ftrace->graph_depth },\n\t\t{ .name = NULL, }\n\t};\n\n\tif (unset)\n\t\treturn 0;\n\n\tret = perf_parse_sublevel_options(str, graph_tracer_opts);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nenum perf_ftrace_subcommand {\n\tPERF_FTRACE_NONE,\n\tPERF_FTRACE_TRACE,\n\tPERF_FTRACE_LATENCY,\n};\n\nint cmd_ftrace(int argc, const char **argv)\n{\n\tint ret;\n\tint (*cmd_func)(struct perf_ftrace *) = NULL;\n\tstruct perf_ftrace ftrace = {\n\t\t.tracer = DEFAULT_TRACER,\n\t\t.target = { .uid = UINT_MAX, },\n\t};\n\tconst struct option common_options[] = {\n\tOPT_STRING('p', \"pid\", &ftrace.target.pid, \"pid\",\n\t\t   \"Trace on existing process id\"),\n\t \n\tOPT_STRING(0, \"tid\", &ftrace.target.tid, \"tid\",\n\t\t   \"Trace on existing thread id (exclusive to --pid)\"),\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t \"Be more verbose\"),\n\tOPT_BOOLEAN('a', \"all-cpus\", &ftrace.target.system_wide,\n\t\t    \"System-wide collection from all CPUs\"),\n\tOPT_STRING('C', \"cpu\", &ftrace.target.cpu_list, \"cpu\",\n\t\t    \"List of cpus to monitor\"),\n\tOPT_END()\n\t};\n\tconst struct option ftrace_options[] = {\n\tOPT_STRING('t', \"tracer\", &ftrace.tracer, \"tracer\",\n\t\t   \"Tracer to use: function_graph(default) or function\"),\n\tOPT_CALLBACK_DEFAULT('F', \"funcs\", NULL, \"[FILTER]\",\n\t\t\t     \"Show available functions to filter\",\n\t\t\t     opt_list_avail_functions, \"*\"),\n\tOPT_CALLBACK('T', \"trace-funcs\", &ftrace.filters, \"func\",\n\t\t     \"Trace given functions using function tracer\",\n\t\t     parse_filter_func),\n\tOPT_CALLBACK('N', \"notrace-funcs\", &ftrace.notrace, \"func\",\n\t\t     \"Do not trace given functions\", parse_filter_func),\n\tOPT_CALLBACK(0, \"func-opts\", &ftrace, \"options\",\n\t\t     \"Function tracer options, available options: call-graph,irq-info\",\n\t\t     parse_func_tracer_opts),\n\tOPT_CALLBACK('G', \"graph-funcs\", &ftrace.graph_funcs, \"func\",\n\t\t     \"Trace given functions using function_graph tracer\",\n\t\t     parse_filter_func),\n\tOPT_CALLBACK('g', \"nograph-funcs\", &ftrace.nograph_funcs, \"func\",\n\t\t     \"Set nograph filter on given functions\", parse_filter_func),\n\tOPT_CALLBACK(0, \"graph-opts\", &ftrace, \"options\",\n\t\t     \"Graph tracer options, available options: nosleep-time,noirqs,verbose,thresh=<n>,depth=<n>\",\n\t\t     parse_graph_tracer_opts),\n\tOPT_CALLBACK('m', \"buffer-size\", &ftrace.percpu_buffer_size, \"size\",\n\t\t     \"Size of per cpu buffer, needs to use a B, K, M or G suffix.\", parse_buffer_size),\n\tOPT_BOOLEAN(0, \"inherit\", &ftrace.inherit,\n\t\t    \"Trace children processes\"),\n\tOPT_INTEGER('D', \"delay\", &ftrace.target.initial_delay,\n\t\t    \"Number of milliseconds to wait before starting tracing after program start\"),\n\tOPT_PARENT(common_options),\n\t};\n\tconst struct option latency_options[] = {\n\tOPT_CALLBACK('T', \"trace-funcs\", &ftrace.filters, \"func\",\n\t\t     \"Show latency of given function\", parse_filter_func),\n#ifdef HAVE_BPF_SKEL\n\tOPT_BOOLEAN('b', \"use-bpf\", &ftrace.target.use_bpf,\n\t\t    \"Use BPF to measure function latency\"),\n#endif\n\tOPT_BOOLEAN('n', \"use-nsec\", &ftrace.use_nsec,\n\t\t    \"Use nano-second histogram\"),\n\tOPT_PARENT(common_options),\n\t};\n\tconst struct option *options = ftrace_options;\n\n\tconst char * const ftrace_usage[] = {\n\t\t\"perf ftrace [<options>] [<command>]\",\n\t\t\"perf ftrace [<options>] -- [<command>] [<options>]\",\n\t\t\"perf ftrace {trace|latency} [<options>] [<command>]\",\n\t\t\"perf ftrace {trace|latency} [<options>] -- [<command>] [<options>]\",\n\t\tNULL\n\t};\n\tenum perf_ftrace_subcommand subcmd = PERF_FTRACE_NONE;\n\n\tINIT_LIST_HEAD(&ftrace.filters);\n\tINIT_LIST_HEAD(&ftrace.notrace);\n\tINIT_LIST_HEAD(&ftrace.graph_funcs);\n\tINIT_LIST_HEAD(&ftrace.nograph_funcs);\n\n\tsignal(SIGINT, sig_handler);\n\tsignal(SIGUSR1, sig_handler);\n\tsignal(SIGCHLD, sig_handler);\n\tsignal(SIGPIPE, sig_handler);\n\n\tret = perf_config(perf_ftrace_config, &ftrace);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tif (argc > 1) {\n\t\tif (!strcmp(argv[1], \"trace\")) {\n\t\t\tsubcmd = PERF_FTRACE_TRACE;\n\t\t} else if (!strcmp(argv[1], \"latency\")) {\n\t\t\tsubcmd = PERF_FTRACE_LATENCY;\n\t\t\toptions = latency_options;\n\t\t}\n\n\t\tif (subcmd != PERF_FTRACE_NONE) {\n\t\t\targc--;\n\t\t\targv++;\n\t\t}\n\t}\n\t \n\tif (subcmd == PERF_FTRACE_NONE)\n\t\tsubcmd = PERF_FTRACE_TRACE;\n\n\targc = parse_options(argc, argv, options, ftrace_usage,\n\t\t\t    PARSE_OPT_STOP_AT_NON_OPTION);\n\tif (argc < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_delete_filters;\n\t}\n\n\t \n\tif (!argc && target__none(&ftrace.target))\n\t\tftrace.target.system_wide = true;\n\n\tswitch (subcmd) {\n\tcase PERF_FTRACE_TRACE:\n\t\tcmd_func = __cmd_ftrace;\n\t\tbreak;\n\tcase PERF_FTRACE_LATENCY:\n\t\tif (list_empty(&ftrace.filters)) {\n\t\t\tpr_err(\"Should provide a function to measure\\n\");\n\t\t\tparse_options_usage(ftrace_usage, options, \"T\", 1);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_delete_filters;\n\t\t}\n\t\tcmd_func = __cmd_latency;\n\t\tbreak;\n\tcase PERF_FTRACE_NONE:\n\tdefault:\n\t\tpr_err(\"Invalid subcommand\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_delete_filters;\n\t}\n\n\tret = target__validate(&ftrace.target);\n\tif (ret) {\n\t\tchar errbuf[512];\n\n\t\ttarget__strerror(&ftrace.target, ret, errbuf, 512);\n\t\tpr_err(\"%s\\n\", errbuf);\n\t\tgoto out_delete_filters;\n\t}\n\n\tftrace.evlist = evlist__new();\n\tif (ftrace.evlist == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_delete_filters;\n\t}\n\n\tret = evlist__create_maps(ftrace.evlist, &ftrace.target);\n\tif (ret < 0)\n\t\tgoto out_delete_evlist;\n\n\tif (argc) {\n\t\tret = evlist__prepare_workload(ftrace.evlist, &ftrace.target,\n\t\t\t\t\t       argv, false,\n\t\t\t\t\t       ftrace__workload_exec_failed_signal);\n\t\tif (ret < 0)\n\t\t\tgoto out_delete_evlist;\n\t}\n\n\tret = cmd_func(&ftrace);\n\nout_delete_evlist:\n\tevlist__delete(ftrace.evlist);\n\nout_delete_filters:\n\tdelete_filter_func(&ftrace.filters);\n\tdelete_filter_func(&ftrace.notrace);\n\tdelete_filter_func(&ftrace.graph_funcs);\n\tdelete_filter_func(&ftrace.nograph_funcs);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}