{
  "module_name": "builtin-annotate.c",
  "hash_id": "83d4aad258812665825811b1a0c88f0daa6f3e633e9da34b04c2cac5b8888366",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-annotate.c",
  "human_readable_source": "\n \n#include \"builtin.h\"\n\n#include \"util/color.h\"\n#include <linux/list.h>\n#include \"util/cache.h\"\n#include <linux/rbtree.h>\n#include <linux/zalloc.h>\n#include \"util/symbol.h\"\n\n#include \"util/debug.h\"\n\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/annotate.h\"\n#include \"util/event.h\"\n#include <subcmd/parse-options.h>\n#include \"util/parse-events.h\"\n#include \"util/sort.h\"\n#include \"util/hist.h\"\n#include \"util/dso.h\"\n#include \"util/machine.h\"\n#include \"util/map.h\"\n#include \"util/session.h\"\n#include \"util/tool.h\"\n#include \"util/data.h\"\n#include \"arch/common.h\"\n#include \"util/block-range.h\"\n#include \"util/map_symbol.h\"\n#include \"util/branch.h\"\n#include \"util/util.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <linux/bitmap.h>\n#include <linux/err.h>\n\nstruct perf_annotate {\n\tstruct perf_tool tool;\n\tstruct perf_session *session;\n\tstruct annotation_options opts;\n#ifdef HAVE_SLANG_SUPPORT\n\tbool\t   use_tui;\n#endif\n\tbool\t   use_stdio, use_stdio2;\n#ifdef HAVE_GTK2_SUPPORT\n\tbool\t   use_gtk;\n#endif\n\tbool\t   skip_missing;\n\tbool\t   has_br_stack;\n\tbool\t   group_set;\n\tfloat\t   min_percent;\n\tconst char *sym_hist_filter;\n\tconst char *cpu_list;\n\tDECLARE_BITMAP(cpu_bitmap, MAX_NR_CPUS);\n};\n\n \nstatic void process_basic_block(struct addr_map_symbol *start,\n\t\t\t\tstruct addr_map_symbol *end,\n\t\t\t\tstruct branch_flags *flags)\n{\n\tstruct symbol *sym = start->ms.sym;\n\tstruct annotation *notes = sym ? symbol__annotation(sym) : NULL;\n\tstruct block_range_iter iter;\n\tstruct block_range *entry;\n\n\t \n\tif (!start->addr || start->addr > end->addr)\n\t\treturn;\n\n\titer = block_range__create(start->addr, end->addr);\n\tif (!block_range_iter__valid(&iter))\n\t\treturn;\n\n\t \n\tentry = block_range_iter(&iter);\n\tassert(entry->is_target);\n\tentry->entry++;\n\n\tdo {\n\t\tentry = block_range_iter(&iter);\n\n\t\tentry->coverage++;\n\t\tentry->sym = sym;\n\n\t\tif (notes)\n\t\t\tnotes->max_coverage = max(notes->max_coverage, entry->coverage);\n\n\t} while (block_range_iter__next(&iter));\n\n\t \n\tentry = block_range_iter(&iter);\n\tassert(entry->is_branch);\n\tentry->taken++;\n\tif (flags->predicted)\n\t\tentry->pred++;\n}\n\nstatic void process_branch_stack(struct branch_stack *bs, struct addr_location *al,\n\t\t\t\t struct perf_sample *sample)\n{\n\tstruct addr_map_symbol *prev = NULL;\n\tstruct branch_info *bi;\n\tint i;\n\n\tif (!bs || !bs->nr)\n\t\treturn;\n\n\tbi = sample__resolve_bstack(sample, al);\n\tif (!bi)\n\t\treturn;\n\n\tfor (i = bs->nr - 1; i >= 0; i--) {\n\t\t \n\t\tif (prev)\n\t\t\tprocess_basic_block(prev, &bi[i].from, &bi[i].flags);\n\t\tprev = &bi[i].to;\n\t}\n\n\tfree(bi);\n}\n\nstatic int hist_iter__branch_callback(struct hist_entry_iter *iter,\n\t\t\t\t      struct addr_location *al __maybe_unused,\n\t\t\t\t      bool single __maybe_unused,\n\t\t\t\t      void *arg __maybe_unused)\n{\n\tstruct hist_entry *he = iter->he;\n\tstruct branch_info *bi;\n\tstruct perf_sample *sample = iter->sample;\n\tstruct evsel *evsel = iter->evsel;\n\tint err;\n\n\tbi = he->branch_info;\n\terr = addr_map_symbol__inc_samples(&bi->from, sample, evsel);\n\n\tif (err)\n\t\tgoto out;\n\n\terr = addr_map_symbol__inc_samples(&bi->to, sample, evsel);\n\nout:\n\treturn err;\n}\n\nstatic int process_branch_callback(struct evsel *evsel,\n\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t   struct addr_location *al,\n\t\t\t\t   struct perf_annotate *ann,\n\t\t\t\t   struct machine *machine)\n{\n\tstruct hist_entry_iter iter = {\n\t\t.evsel\t\t= evsel,\n\t\t.sample\t\t= sample,\n\t\t.add_entry_cb\t= hist_iter__branch_callback,\n\t\t.hide_unresolved\t= symbol_conf.hide_unresolved,\n\t\t.ops\t\t= &hist_iter_branch,\n\t};\n\tstruct addr_location a;\n\tint ret;\n\n\taddr_location__init(&a);\n\tif (machine__resolve(machine, &a, sample) < 0) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (a.sym == NULL) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (a.map != NULL)\n\t\tmap__dso(a.map)->hit = 1;\n\n\thist__account_cycles(sample->branch_stack, al, sample, false, NULL);\n\n\tret = hist_entry_iter__add(&iter, &a, PERF_MAX_STACK_DEPTH, ann);\nout:\n\taddr_location__exit(&a);\n\treturn ret;\n}\n\nstatic bool has_annotation(struct perf_annotate *ann)\n{\n\treturn ui__has_annotation() || ann->use_stdio2;\n}\n\nstatic int evsel__add_sample(struct evsel *evsel, struct perf_sample *sample,\n\t\t\t     struct addr_location *al, struct perf_annotate *ann,\n\t\t\t     struct machine *machine)\n{\n\tstruct hists *hists = evsel__hists(evsel);\n\tstruct hist_entry *he;\n\tint ret;\n\n\tif ((!ann->has_br_stack || !has_annotation(ann)) &&\n\t    ann->sym_hist_filter != NULL &&\n\t    (al->sym == NULL ||\n\t     strcmp(ann->sym_hist_filter, al->sym->name) != 0)) {\n\t\t \n\t\t \n\t\tif (al->sym != NULL) {\n\t\t\tstruct dso *dso = map__dso(al->map);\n\n\t\t\trb_erase_cached(&al->sym->rb_node, &dso->symbols);\n\t\t\tsymbol__delete(al->sym);\n\t\t\tdso__reset_find_symbol_cache(dso);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tprocess_branch_stack(sample->branch_stack, al, sample);\n\n\tif (ann->has_br_stack && has_annotation(ann))\n\t\treturn process_branch_callback(evsel, sample, al, ann, machine);\n\n\the = hists__add_entry(hists, al, NULL, NULL, NULL, NULL, sample, true);\n\tif (he == NULL)\n\t\treturn -ENOMEM;\n\n\tret = hist_entry__inc_addr_samples(he, sample, evsel, al->addr);\n\thists__inc_nr_samples(hists, true);\n\treturn ret;\n}\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct perf_annotate *ann = container_of(tool, struct perf_annotate, tool);\n\tstruct addr_location al;\n\tint ret = 0;\n\n\taddr_location__init(&al);\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tpr_warning(\"problem processing %d event, skipping it.\\n\",\n\t\t\t   event->header.type);\n\t\tret = -1;\n\t\tgoto out_put;\n\t}\n\n\tif (ann->cpu_list && !test_bit(sample->cpu, ann->cpu_bitmap))\n\t\tgoto out_put;\n\n\tif (!al.filtered &&\n\t    evsel__add_sample(evsel, sample, &al, ann, machine)) {\n\t\tpr_warning(\"problem incrementing symbol count, \"\n\t\t\t   \"skipping event\\n\");\n\t\tret = -1;\n\t}\nout_put:\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic int process_feature_event(struct perf_session *session,\n\t\t\t\t union perf_event *event)\n{\n\tif (event->feat.feat_id < HEADER_LAST_FEATURE)\n\t\treturn perf_event__process_feature(session, event);\n\treturn 0;\n}\n\nstatic int hist_entry__tty_annotate(struct hist_entry *he,\n\t\t\t\t    struct evsel *evsel,\n\t\t\t\t    struct perf_annotate *ann)\n{\n\tif (!ann->use_stdio2)\n\t\treturn symbol__tty_annotate(&he->ms, evsel, &ann->opts);\n\n\treturn symbol__tty_annotate2(&he->ms, evsel, &ann->opts);\n}\n\nstatic void hists__find_annotations(struct hists *hists,\n\t\t\t\t    struct evsel *evsel,\n\t\t\t\t    struct perf_annotate *ann)\n{\n\tstruct rb_node *nd = rb_first_cached(&hists->entries), *next;\n\tint key = K_RIGHT;\n\n\twhile (nd) {\n\t\tstruct hist_entry *he = rb_entry(nd, struct hist_entry, rb_node);\n\t\tstruct annotation *notes;\n\n\t\tif (he->ms.sym == NULL || map__dso(he->ms.map)->annotate_warned)\n\t\t\tgoto find_next;\n\n\t\tif (ann->sym_hist_filter &&\n\t\t    (strcmp(he->ms.sym->name, ann->sym_hist_filter) != 0))\n\t\t\tgoto find_next;\n\n\t\tif (ann->min_percent) {\n\t\t\tfloat percent = 0;\n\t\t\tu64 total = hists__total_period(hists);\n\n\t\t\tif (total)\n\t\t\t\tpercent = 100.0 * he->stat.period / total;\n\n\t\t\tif (percent < ann->min_percent)\n\t\t\t\tgoto find_next;\n\t\t}\n\n\t\tnotes = symbol__annotation(he->ms.sym);\n\t\tif (notes->src == NULL) {\nfind_next:\n\t\t\tif (key == K_LEFT || key == '<')\n\t\t\t\tnd = rb_prev(nd);\n\t\t\telse\n\t\t\t\tnd = rb_next(nd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (use_browser == 2) {\n\t\t\tint ret;\n\t\t\tint (*annotate)(struct hist_entry *he,\n\t\t\t\t\tstruct evsel *evsel,\n\t\t\t\t\tstruct annotation_options *options,\n\t\t\t\t\tstruct hist_browser_timer *hbt);\n\n\t\t\tannotate = dlsym(perf_gtk_handle,\n\t\t\t\t\t \"hist_entry__gtk_annotate\");\n\t\t\tif (annotate == NULL) {\n\t\t\t\tui__error(\"GTK browser not found!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tret = annotate(he, evsel, &ann->opts, NULL);\n\t\t\tif (!ret || !ann->skip_missing)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tnd = rb_next(nd);\n\t\t} else if (use_browser == 1) {\n\t\t\tkey = hist_entry__tui_annotate(he, evsel, NULL, &ann->opts);\n\n\t\t\tswitch (key) {\n\t\t\tcase -1:\n\t\t\t\tif (!ann->skip_missing)\n\t\t\t\t\treturn;\n\t\t\t\t \n\t\t\tcase K_RIGHT:\n\t\t\tcase '>':\n\t\t\t\tnext = rb_next(nd);\n\t\t\t\tbreak;\n\t\t\tcase K_LEFT:\n\t\t\tcase '<':\n\t\t\t\tnext = rb_prev(nd);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (next != NULL)\n\t\t\t\tnd = next;\n\t\t} else {\n\t\t\thist_entry__tty_annotate(he, evsel, ann);\n\t\t\tnd = rb_next(nd);\n\t\t}\n\t}\n}\n\nstatic int __cmd_annotate(struct perf_annotate *ann)\n{\n\tint ret;\n\tstruct perf_session *session = ann->session;\n\tstruct evsel *pos;\n\tu64 total_nr_samples;\n\n\tif (ann->cpu_list) {\n\t\tret = perf_session__cpu_bitmap(session, ann->cpu_list,\n\t\t\t\t\t       ann->cpu_bitmap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (!ann->opts.objdump_path) {\n\t\tret = perf_env__lookup_objdump(&session->header.env,\n\t\t\t\t\t       &ann->opts.objdump_path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = perf_session__process_events(session);\n\tif (ret)\n\t\tgoto out;\n\n\tif (dump_trace) {\n\t\tperf_session__fprintf_nr_events(session, stdout, false);\n\t\tevlist__fprintf_nr_events(session->evlist, stdout, false);\n\t\tgoto out;\n\t}\n\n\tif (verbose > 3)\n\t\tperf_session__fprintf(session, stdout);\n\n\tif (verbose > 2)\n\t\tperf_session__fprintf_dsos(session, stdout);\n\n\ttotal_nr_samples = 0;\n\tevlist__for_each_entry(session->evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\t\tu32 nr_samples = hists->stats.nr_samples;\n\n\t\tif (nr_samples > 0) {\n\t\t\ttotal_nr_samples += nr_samples;\n\t\t\thists__collapse_resort(hists, NULL);\n\t\t\t \n\t\t\tevsel__reset_sample_bit(pos, CALLCHAIN);\n\t\t\tevsel__output_resort(pos, NULL);\n\n\t\t\tif (symbol_conf.event_group && !evsel__is_group_leader(pos))\n\t\t\t\tcontinue;\n\n\t\t\thists__find_annotations(hists, pos, ann);\n\t\t}\n\t}\n\n\tif (total_nr_samples == 0) {\n\t\tui__error(\"The %s data has no samples!\\n\", session->data->path);\n\t\tgoto out;\n\t}\n\n\tif (use_browser == 2) {\n\t\tvoid (*show_annotations)(void);\n\n\t\tshow_annotations = dlsym(perf_gtk_handle,\n\t\t\t\t\t \"perf_gtk__show_annotations\");\n\t\tif (show_annotations == NULL) {\n\t\t\tui__error(\"GTK browser not found!\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tshow_annotations();\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int parse_percent_limit(const struct option *opt, const char *str,\n\t\t\t       int unset __maybe_unused)\n{\n\tstruct perf_annotate *ann = opt->value;\n\tdouble pcnt = strtof(str, NULL);\n\n\tann->min_percent = pcnt;\n\treturn 0;\n}\n\nstatic const char * const annotate_usage[] = {\n\t\"perf annotate [<options>]\",\n\tNULL\n};\n\nint cmd_annotate(int argc, const char **argv)\n{\n\tstruct perf_annotate annotate = {\n\t\t.tool = {\n\t\t\t.sample\t= process_sample_event,\n\t\t\t.mmap\t= perf_event__process_mmap,\n\t\t\t.mmap2\t= perf_event__process_mmap2,\n\t\t\t.comm\t= perf_event__process_comm,\n\t\t\t.exit\t= perf_event__process_exit,\n\t\t\t.fork\t= perf_event__process_fork,\n\t\t\t.namespaces = perf_event__process_namespaces,\n\t\t\t.attr\t= perf_event__process_attr,\n\t\t\t.build_id = perf_event__process_build_id,\n#ifdef HAVE_LIBTRACEEVENT\n\t\t\t.tracing_data   = perf_event__process_tracing_data,\n#endif\n\t\t\t.id_index\t= perf_event__process_id_index,\n\t\t\t.auxtrace_info\t= perf_event__process_auxtrace_info,\n\t\t\t.auxtrace\t= perf_event__process_auxtrace,\n\t\t\t.feature\t= process_feature_event,\n\t\t\t.ordered_events = true,\n\t\t\t.ordering_requires_timestamps = true,\n\t\t},\n\t};\n\tstruct perf_data data = {\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t};\n\tstruct itrace_synth_opts itrace_synth_opts = {\n\t\t.set = 0,\n\t};\n\tconst char *disassembler_style = NULL, *objdump_path = NULL, *addr2line_path = NULL;\n\tstruct option options[] = {\n\tOPT_STRING('i', \"input\", &input_name, \"file\",\n\t\t    \"input file name\"),\n\tOPT_STRING('d', \"dsos\", &symbol_conf.dso_list_str, \"dso[,dso...]\",\n\t\t   \"only consider symbols in these dsos\"),\n\tOPT_STRING('s', \"symbol\", &annotate.sym_hist_filter, \"symbol\",\n\t\t    \"symbol to annotate\"),\n\tOPT_BOOLEAN('f', \"force\", &data.force, \"don't complain, do it\"),\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t    \"be more verbose (show symbol address, etc)\"),\n\tOPT_BOOLEAN('q', \"quiet\", &quiet, \"do now show any warnings or messages\"),\n\tOPT_BOOLEAN('D', \"dump-raw-trace\", &dump_trace,\n\t\t    \"dump raw trace in ASCII\"),\n#ifdef HAVE_GTK2_SUPPORT\n\tOPT_BOOLEAN(0, \"gtk\", &annotate.use_gtk, \"Use the GTK interface\"),\n#endif\n#ifdef HAVE_SLANG_SUPPORT\n\tOPT_BOOLEAN(0, \"tui\", &annotate.use_tui, \"Use the TUI interface\"),\n#endif\n\tOPT_BOOLEAN(0, \"stdio\", &annotate.use_stdio, \"Use the stdio interface\"),\n\tOPT_BOOLEAN(0, \"stdio2\", &annotate.use_stdio2, \"Use the stdio interface\"),\n\tOPT_BOOLEAN(0, \"ignore-vmlinux\", &symbol_conf.ignore_vmlinux,\n                    \"don't load vmlinux even if found\"),\n\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_BOOLEAN('m', \"modules\", &symbol_conf.use_modules,\n\t\t    \"load module symbols - WARNING: use only with -k and LIVE kernel\"),\n\tOPT_BOOLEAN('l', \"print-line\", &annotate.opts.print_lines,\n\t\t    \"print matching source lines (may be slow)\"),\n\tOPT_BOOLEAN('P', \"full-paths\", &annotate.opts.full_path,\n\t\t    \"Don't shorten the displayed pathnames\"),\n\tOPT_BOOLEAN(0, \"skip-missing\", &annotate.skip_missing,\n\t\t    \"Skip symbols that cannot be annotated\"),\n\tOPT_BOOLEAN_SET(0, \"group\", &symbol_conf.event_group,\n\t\t\t&annotate.group_set,\n\t\t\t\"Show event group information together\"),\n\tOPT_STRING('C', \"cpu\", &annotate.cpu_list, \"cpu\", \"list of cpus to profile\"),\n\tOPT_CALLBACK(0, \"symfs\", NULL, \"directory\",\n\t\t     \"Look for files with symbols relative to this directory\",\n\t\t     symbol__config_symfs),\n\tOPT_BOOLEAN(0, \"source\", &annotate.opts.annotate_src,\n\t\t    \"Interleave source code with assembly code (default)\"),\n\tOPT_BOOLEAN(0, \"asm-raw\", &annotate.opts.show_asm_raw,\n\t\t    \"Display raw encoding of assembly instructions (default)\"),\n\tOPT_STRING('M', \"disassembler-style\", &disassembler_style, \"disassembler style\",\n\t\t   \"Specify disassembler style (e.g. -M intel for intel syntax)\"),\n\tOPT_STRING(0, \"prefix\", &annotate.opts.prefix, \"prefix\",\n\t\t    \"Add prefix to source file path names in programs (with --prefix-strip)\"),\n\tOPT_STRING(0, \"prefix-strip\", &annotate.opts.prefix_strip, \"N\",\n\t\t    \"Strip first N entries of source file path name in programs (with --prefix)\"),\n\tOPT_STRING(0, \"objdump\", &objdump_path, \"path\",\n\t\t   \"objdump binary to use for disassembly and annotations\"),\n\tOPT_STRING(0, \"addr2line\", &addr2line_path, \"path\",\n\t\t   \"addr2line binary to use for line numbers\"),\n\tOPT_BOOLEAN(0, \"demangle\", &symbol_conf.demangle,\n\t\t    \"Enable symbol demangling\"),\n\tOPT_BOOLEAN(0, \"demangle-kernel\", &symbol_conf.demangle_kernel,\n\t\t    \"Enable kernel symbol demangling\"),\n\tOPT_BOOLEAN(0, \"group\", &symbol_conf.event_group,\n\t\t    \"Show event group information together\"),\n\tOPT_BOOLEAN(0, \"show-total-period\", &symbol_conf.show_total_period,\n\t\t    \"Show a column with the sum of periods\"),\n\tOPT_BOOLEAN('n', \"show-nr-samples\", &symbol_conf.show_nr_samples,\n\t\t    \"Show a column with the number of samples\"),\n\tOPT_CALLBACK_DEFAULT(0, \"stdio-color\", NULL, \"mode\",\n\t\t\t     \"'always' (default), 'never' or 'auto' only applicable to --stdio mode\",\n\t\t\t     stdio__config_color, \"always\"),\n\tOPT_CALLBACK(0, \"percent-type\", &annotate.opts, \"local-period\",\n\t\t     \"Set percent type local/global-period/hits\",\n\t\t     annotate_parse_percent_type),\n\tOPT_CALLBACK(0, \"percent-limit\", &annotate, \"percent\",\n\t\t     \"Don't show entries under that percent\", parse_percent_limit),\n\tOPT_CALLBACK_OPTARG(0, \"itrace\", &itrace_synth_opts, NULL, \"opts\",\n\t\t\t    \"Instruction Tracing options\\n\" ITRACE_HELP,\n\t\t\t    itrace_parse_synth_opts),\n\n\tOPT_END()\n\t};\n\tint ret;\n\n\tset_option_flag(options, 0, \"show-total-period\", PARSE_OPT_EXCLUSIVE);\n\tset_option_flag(options, 0, \"show-nr-samples\", PARSE_OPT_EXCLUSIVE);\n\n\tannotation_options__init(&annotate.opts);\n\n\tret = hists__init();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tannotation_config__init(&annotate.opts);\n\n\targc = parse_options(argc, argv, options, annotate_usage, 0);\n\tif (argc) {\n\t\t \n\t\tif (argc > 1)\n\t\t\tusage_with_options(annotate_usage, options);\n\n\t\tannotate.sym_hist_filter = argv[0];\n\t}\n\n\tif (disassembler_style) {\n\t\tannotate.opts.disassembler_style = strdup(disassembler_style);\n\t\tif (!annotate.opts.disassembler_style)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (objdump_path) {\n\t\tannotate.opts.objdump_path = strdup(objdump_path);\n\t\tif (!annotate.opts.objdump_path)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (addr2line_path) {\n\t\tsymbol_conf.addr2line_path = strdup(addr2line_path);\n\t\tif (!symbol_conf.addr2line_path)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (annotate_check_args(&annotate.opts) < 0)\n\t\treturn -EINVAL;\n\n#ifdef HAVE_GTK2_SUPPORT\n\tif (symbol_conf.show_nr_samples && annotate.use_gtk) {\n\t\tpr_err(\"--show-nr-samples is not available in --gtk mode at this time\\n\");\n\t\treturn ret;\n\t}\n#endif\n\n\tret = symbol__validate_sym_arguments();\n\tif (ret)\n\t\treturn ret;\n\n\tif (quiet)\n\t\tperf_quiet_option();\n\n\tdata.path = input_name;\n\n\tannotate.session = perf_session__new(&data, &annotate.tool);\n\tif (IS_ERR(annotate.session))\n\t\treturn PTR_ERR(annotate.session);\n\n\tannotate.session->itrace_synth_opts = &itrace_synth_opts;\n\n\tannotate.has_br_stack = perf_header__has_feat(&annotate.session->header,\n\t\t\t\t\t\t      HEADER_BRANCH_STACK);\n\n\tif (annotate.group_set)\n\t\tevlist__force_leader(annotate.session->evlist);\n\n\tret = symbol__annotation_init();\n\tif (ret < 0)\n\t\tgoto out_delete;\n\n\tsymbol_conf.try_vmlinux_path = true;\n\n\tret = symbol__init(&annotate.session->header.env);\n\tif (ret < 0)\n\t\tgoto out_delete;\n\n\tif (annotate.use_stdio || annotate.use_stdio2)\n\t\tuse_browser = 0;\n#ifdef HAVE_SLANG_SUPPORT\n\telse if (annotate.use_tui)\n\t\tuse_browser = 1;\n#endif\n#ifdef HAVE_GTK2_SUPPORT\n\telse if (annotate.use_gtk)\n\t\tuse_browser = 2;\n#endif\n\n\tsetup_browser(true);\n\n\t \n\tsort_order = \"dso,symbol\";\n\n\t \n\tif ((use_browser == 1 || annotate.use_stdio2) && annotate.has_br_stack)\n\t\tsort__mode = SORT_MODE__BRANCH;\n\n\tif (setup_sorting(NULL) < 0)\n\t\tusage_with_options(annotate_usage, options);\n\n\tret = __cmd_annotate(&annotate);\n\nout_delete:\n\t \n#ifndef NDEBUG\n\tperf_session__delete(annotate.session);\n#endif\n\tannotation_options__exit(&annotate.opts);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}