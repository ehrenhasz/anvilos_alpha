{
  "module_name": "builtin-mem.c",
  "hash_id": "3748d5ddc20a8e37acdf874a6558402644f50448dbb9f99040e7f9002a2379d7",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-mem.c",
  "human_readable_source": "\n#include <inttypes.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include \"builtin.h\"\n\n#include <subcmd/parse-options.h>\n#include \"util/auxtrace.h\"\n#include \"util/trace-event.h\"\n#include \"util/tool.h\"\n#include \"util/session.h\"\n#include \"util/data.h\"\n#include \"util/map_symbol.h\"\n#include \"util/mem-events.h\"\n#include \"util/debug.h\"\n#include \"util/dso.h\"\n#include \"util/map.h\"\n#include \"util/symbol.h\"\n#include \"util/pmus.h\"\n#include \"util/sample.h\"\n#include \"util/string2.h\"\n#include \"util/util.h\"\n#include <linux/err.h>\n\n#define MEM_OPERATION_LOAD\t0x1\n#define MEM_OPERATION_STORE\t0x2\n\nstruct perf_mem {\n\tstruct perf_tool\ttool;\n\tchar const\t\t*input_name;\n\tbool\t\t\thide_unresolved;\n\tbool\t\t\tdump_raw;\n\tbool\t\t\tforce;\n\tbool\t\t\tphys_addr;\n\tbool\t\t\tdata_page_size;\n\tint\t\t\toperation;\n\tconst char\t\t*cpu_list;\n\tDECLARE_BITMAP(cpu_bitmap, MAX_NR_CPUS);\n};\n\nstatic int parse_record_events(const struct option *opt,\n\t\t\t       const char *str, int unset __maybe_unused)\n{\n\tstruct perf_mem *mem = *(struct perf_mem **)opt->value;\n\n\tif (!strcmp(str, \"list\")) {\n\t\tperf_mem_events__list();\n\t\texit(0);\n\t}\n\tif (perf_mem_events__parse(str))\n\t\texit(-1);\n\n\tmem->operation = 0;\n\treturn 0;\n}\n\nstatic const char * const __usage[] = {\n\t\"perf mem record [<options>] [<command>]\",\n\t\"perf mem record [<options>] -- <command> [<options>]\",\n\tNULL\n};\n\nstatic const char * const *record_mem_usage = __usage;\n\nstatic int __cmd_record(int argc, const char **argv, struct perf_mem *mem)\n{\n\tint rec_argc, i = 0, j, tmp_nr = 0;\n\tint start, end;\n\tconst char **rec_argv;\n\tchar **rec_tmp;\n\tint ret;\n\tbool all_user = false, all_kernel = false;\n\tstruct perf_mem_event *e;\n\tstruct option options[] = {\n\tOPT_CALLBACK('e', \"event\", &mem, \"event\",\n\t\t     \"event selector. use 'perf mem record -e list' to list available events\",\n\t\t     parse_record_events),\n\tOPT_UINTEGER(0, \"ldlat\", &perf_mem_events__loads_ldlat, \"mem-loads latency\"),\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t \"be more verbose (show counter open errors, etc)\"),\n\tOPT_BOOLEAN('U', \"all-user\", &all_user, \"collect only user level data\"),\n\tOPT_BOOLEAN('K', \"all-kernel\", &all_kernel, \"collect only kernel level data\"),\n\tOPT_END()\n\t};\n\n\tif (perf_mem_events__init()) {\n\t\tpr_err(\"failed: memory events not supported\\n\");\n\t\treturn -1;\n\t}\n\n\targc = parse_options(argc, argv, options, record_mem_usage,\n\t\t\t     PARSE_OPT_KEEP_UNKNOWN);\n\n\t \n\trec_argc = argc + 9 * perf_pmus__num_mem_pmus();\n\n\tif (mem->cpu_list)\n\t\trec_argc += 2;\n\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\tif (!rec_argv)\n\t\treturn -1;\n\n\t \n\trec_tmp = calloc(rec_argc + 1, sizeof(char *));\n\tif (!rec_tmp) {\n\t\tfree(rec_argv);\n\t\treturn -1;\n\t}\n\n\trec_argv[i++] = \"record\";\n\n\te = perf_mem_events__ptr(PERF_MEM_EVENTS__LOAD_STORE);\n\n\t \n\tif (e->tag &&\n\t    (mem->operation & MEM_OPERATION_LOAD) &&\n\t    (mem->operation & MEM_OPERATION_STORE)) {\n\t\te->record = true;\n\t\trec_argv[i++] = \"-W\";\n\t} else {\n\t\tif (mem->operation & MEM_OPERATION_LOAD) {\n\t\t\te = perf_mem_events__ptr(PERF_MEM_EVENTS__LOAD);\n\t\t\te->record = true;\n\t\t}\n\n\t\tif (mem->operation & MEM_OPERATION_STORE) {\n\t\t\te = perf_mem_events__ptr(PERF_MEM_EVENTS__STORE);\n\t\t\te->record = true;\n\t\t}\n\t}\n\n\te = perf_mem_events__ptr(PERF_MEM_EVENTS__LOAD);\n\tif (e->record)\n\t\trec_argv[i++] = \"-W\";\n\n\trec_argv[i++] = \"-d\";\n\n\tif (mem->phys_addr)\n\t\trec_argv[i++] = \"--phys-data\";\n\n\tif (mem->data_page_size)\n\t\trec_argv[i++] = \"--data-page-size\";\n\n\tstart = i;\n\tret = perf_mem_events__record_args(rec_argv, &i, rec_tmp, &tmp_nr);\n\tif (ret)\n\t\tgoto out;\n\tend = i;\n\n\tif (all_user)\n\t\trec_argv[i++] = \"--all-user\";\n\n\tif (all_kernel)\n\t\trec_argv[i++] = \"--all-kernel\";\n\n\tif (mem->cpu_list) {\n\t\trec_argv[i++] = \"-C\";\n\t\trec_argv[i++] = mem->cpu_list;\n\t}\n\n\tfor (j = 0; j < argc; j++, i++)\n\t\trec_argv[i] = argv[j];\n\n\tif (verbose > 0) {\n\t\tpr_debug(\"calling: record \");\n\n\t\tfor (j = start; j < end; j++)\n\t\t\tpr_debug(\"%s \", rec_argv[j]);\n\n\t\tpr_debug(\"\\n\");\n\t}\n\n\tret = cmd_record(i, rec_argv);\nout:\n\tfor (i = 0; i < tmp_nr; i++)\n\t\tfree(rec_tmp[i]);\n\n\tfree(rec_tmp);\n\tfree(rec_argv);\n\treturn ret;\n}\n\nstatic int\ndump_raw_samples(struct perf_tool *tool,\n\t\t union perf_event *event,\n\t\t struct perf_sample *sample,\n\t\t struct machine *machine)\n{\n\tstruct perf_mem *mem = container_of(tool, struct perf_mem, tool);\n\tstruct addr_location al;\n\tconst char *fmt, *field_sep;\n\tchar str[PAGE_SIZE_NAME_LEN];\n\tstruct dso *dso = NULL;\n\n\taddr_location__init(&al);\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tfprintf(stderr, \"problem processing %d event, skipping it.\\n\",\n\t\t\t\tevent->header.type);\n\t\taddr_location__exit(&al);\n\t\treturn -1;\n\t}\n\n\tif (al.filtered || (mem->hide_unresolved && al.sym == NULL))\n\t\tgoto out_put;\n\n\tif (al.map != NULL) {\n\t\tdso = map__dso(al.map);\n\t\tif (dso)\n\t\t\tdso->hit = 1;\n\t}\n\n\tfield_sep = symbol_conf.field_sep;\n\tif (field_sep) {\n\t\tfmt = \"%d%s%d%s0x%\"PRIx64\"%s0x%\"PRIx64\"%s\";\n\t} else {\n\t\tfmt = \"%5d%s%5d%s0x%016\"PRIx64\"%s0x016%\"PRIx64\"%s\";\n\t\tsymbol_conf.field_sep = \" \";\n\t}\n\tprintf(fmt,\n\t\tsample->pid,\n\t\tsymbol_conf.field_sep,\n\t\tsample->tid,\n\t\tsymbol_conf.field_sep,\n\t\tsample->ip,\n\t\tsymbol_conf.field_sep,\n\t\tsample->addr,\n\t\tsymbol_conf.field_sep);\n\n\tif (mem->phys_addr) {\n\t\tprintf(\"0x%016\"PRIx64\"%s\",\n\t\t\tsample->phys_addr,\n\t\t\tsymbol_conf.field_sep);\n\t}\n\n\tif (mem->data_page_size) {\n\t\tprintf(\"%s%s\",\n\t\t\tget_page_size_name(sample->data_page_size, str),\n\t\t\tsymbol_conf.field_sep);\n\t}\n\n\tif (field_sep)\n\t\tfmt = \"%\"PRIu64\"%s0x%\"PRIx64\"%s%s:%s\\n\";\n\telse\n\t\tfmt = \"%5\"PRIu64\"%s0x%06\"PRIx64\"%s%s:%s\\n\";\n\n\tprintf(fmt,\n\t\tsample->weight,\n\t\tsymbol_conf.field_sep,\n\t\tsample->data_src,\n\t\tsymbol_conf.field_sep,\n\t\tdso ? dso->long_name : \"???\",\n\t\tal.sym ? al.sym->name : \"???\");\nout_put:\n\taddr_location__exit(&al);\n\treturn 0;\n}\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel __maybe_unused,\n\t\t\t\tstruct machine *machine)\n{\n\treturn dump_raw_samples(tool, event, sample, machine);\n}\n\nstatic int report_raw_events(struct perf_mem *mem)\n{\n\tstruct itrace_synth_opts itrace_synth_opts = {\n\t\t.set = true,\n\t\t.mem = true,\t \n\t\t.default_no_sample = true,\n\t};\n\n\tstruct perf_data data = {\n\t\t.path  = input_name,\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t\t.force = mem->force,\n\t};\n\tint ret;\n\tstruct perf_session *session = perf_session__new(&data, &mem->tool);\n\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tsession->itrace_synth_opts = &itrace_synth_opts;\n\n\tif (mem->cpu_list) {\n\t\tret = perf_session__cpu_bitmap(session, mem->cpu_list,\n\t\t\t\t\t       mem->cpu_bitmap);\n\t\tif (ret < 0)\n\t\t\tgoto out_delete;\n\t}\n\n\tret = symbol__init(&session->header.env);\n\tif (ret < 0)\n\t\tgoto out_delete;\n\n\tprintf(\"# PID, TID, IP, ADDR, \");\n\n\tif (mem->phys_addr)\n\t\tprintf(\"PHYS ADDR, \");\n\n\tif (mem->data_page_size)\n\t\tprintf(\"DATA PAGE SIZE, \");\n\n\tprintf(\"LOCAL WEIGHT, DSRC, SYMBOL\\n\");\n\n\tret = perf_session__process_events(session);\n\nout_delete:\n\tperf_session__delete(session);\n\treturn ret;\n}\nstatic char *get_sort_order(struct perf_mem *mem)\n{\n\tbool has_extra_options = (mem->phys_addr | mem->data_page_size) ? true : false;\n\tchar sort[128];\n\n\t \n\tif (!(mem->operation & MEM_OPERATION_LOAD)) {\n\t\tstrcpy(sort, \"--sort=mem,sym,dso,symbol_daddr,\"\n\t\t\t     \"dso_daddr,tlb,locked\");\n\t} else if (has_extra_options) {\n\t\tstrcpy(sort, \"--sort=local_weight,mem,sym,dso,symbol_daddr,\"\n\t\t\t     \"dso_daddr,snoop,tlb,locked,blocked\");\n\t} else\n\t\treturn NULL;\n\n\tif (mem->phys_addr)\n\t\tstrcat(sort, \",phys_daddr\");\n\n\tif (mem->data_page_size)\n\t\tstrcat(sort, \",data_page_size\");\n\n\treturn strdup(sort);\n}\n\nstatic int report_events(int argc, const char **argv, struct perf_mem *mem)\n{\n\tconst char **rep_argv;\n\tint ret, i = 0, j, rep_argc;\n\tchar *new_sort_order;\n\n\tif (mem->dump_raw)\n\t\treturn report_raw_events(mem);\n\n\trep_argc = argc + 3;\n\trep_argv = calloc(rep_argc + 1, sizeof(char *));\n\tif (!rep_argv)\n\t\treturn -1;\n\n\trep_argv[i++] = \"report\";\n\trep_argv[i++] = \"--mem-mode\";\n\trep_argv[i++] = \"-n\";  \n\n\tnew_sort_order = get_sort_order(mem);\n\tif (new_sort_order)\n\t\trep_argv[i++] = new_sort_order;\n\n\tfor (j = 1; j < argc; j++, i++)\n\t\trep_argv[i] = argv[j];\n\n\tret = cmd_report(i, rep_argv);\n\tfree(rep_argv);\n\treturn ret;\n}\n\nstruct mem_mode {\n\tconst char *name;\n\tint mode;\n};\n\n#define MEM_OPT(n, m) \\\n\t{ .name = n, .mode = (m) }\n\n#define MEM_END { .name = NULL }\n\nstatic const struct mem_mode mem_modes[]={\n\tMEM_OPT(\"load\", MEM_OPERATION_LOAD),\n\tMEM_OPT(\"store\", MEM_OPERATION_STORE),\n\tMEM_END\n};\n\nstatic int\nparse_mem_ops(const struct option *opt, const char *str, int unset)\n{\n\tint *mode = (int *)opt->value;\n\tconst struct mem_mode *m;\n\tchar *s, *os = NULL, *p;\n\tint ret = -1;\n\n\tif (unset)\n\t\treturn 0;\n\n\t \n\tif (str) {\n\t\t \n\t\ts = os = strdup(str);\n\t\tif (!s)\n\t\t\treturn -1;\n\n\t\t \n\t\t*mode = 0;\n\n\t\tfor (;;) {\n\t\t\tp = strchr(s, ',');\n\t\t\tif (p)\n\t\t\t\t*p = '\\0';\n\n\t\t\tfor (m = mem_modes; m->name; m++) {\n\t\t\t\tif (!strcasecmp(s, m->name))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!m->name) {\n\t\t\t\tfprintf(stderr, \"unknown sampling op %s,\"\n\t\t\t\t\t    \" check man page\\n\", s);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t*mode |= m->mode;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\ts = p + 1;\n\t\t}\n\t}\n\tret = 0;\n\n\tif (*mode == 0)\n\t\t*mode = MEM_OPERATION_LOAD;\nerror:\n\tfree(os);\n\treturn ret;\n}\n\nint cmd_mem(int argc, const char **argv)\n{\n\tstruct stat st;\n\tstruct perf_mem mem = {\n\t\t.tool = {\n\t\t\t.sample\t\t= process_sample_event,\n\t\t\t.mmap\t\t= perf_event__process_mmap,\n\t\t\t.mmap2\t\t= perf_event__process_mmap2,\n\t\t\t.comm\t\t= perf_event__process_comm,\n\t\t\t.lost\t\t= perf_event__process_lost,\n\t\t\t.fork\t\t= perf_event__process_fork,\n\t\t\t.attr\t\t= perf_event__process_attr,\n\t\t\t.build_id\t= perf_event__process_build_id,\n\t\t\t.namespaces\t= perf_event__process_namespaces,\n\t\t\t.auxtrace_info  = perf_event__process_auxtrace_info,\n\t\t\t.auxtrace       = perf_event__process_auxtrace,\n\t\t\t.auxtrace_error = perf_event__process_auxtrace_error,\n\t\t\t.ordered_events\t= true,\n\t\t},\n\t\t.input_name\t\t = \"perf.data\",\n\t\t \n\t\t.operation\t\t = MEM_OPERATION_LOAD | MEM_OPERATION_STORE,\n\t};\n\tconst struct option mem_options[] = {\n\tOPT_CALLBACK('t', \"type\", &mem.operation,\n\t\t   \"type\", \"memory operations(load,store) Default load,store\",\n\t\t    parse_mem_ops),\n\tOPT_BOOLEAN('D', \"dump-raw-samples\", &mem.dump_raw,\n\t\t    \"dump raw samples in ASCII\"),\n\tOPT_BOOLEAN('U', \"hide-unresolved\", &mem.hide_unresolved,\n\t\t    \"Only display entries resolved to a symbol\"),\n\tOPT_STRING('i', \"input\", &input_name, \"file\",\n\t\t   \"input file name\"),\n\tOPT_STRING('C', \"cpu\", &mem.cpu_list, \"cpu\",\n\t\t   \"list of cpus to profile\"),\n\tOPT_STRING_NOEMPTY('x', \"field-separator\", &symbol_conf.field_sep,\n\t\t   \"separator\",\n\t\t   \"separator for columns, no spaces will be added\"\n\t\t   \" between columns '.' is reserved.\"),\n\tOPT_BOOLEAN('f', \"force\", &mem.force, \"don't complain, do it\"),\n\tOPT_BOOLEAN('p', \"phys-data\", &mem.phys_addr, \"Record/Report sample physical addresses\"),\n\tOPT_BOOLEAN(0, \"data-page-size\", &mem.data_page_size, \"Record/Report sample data address page size\"),\n\tOPT_END()\n\t};\n\tconst char *const mem_subcommands[] = { \"record\", \"report\", NULL };\n\tconst char *mem_usage[] = {\n\t\tNULL,\n\t\tNULL\n\t};\n\n\targc = parse_options_subcommand(argc, argv, mem_options, mem_subcommands,\n\t\t\t\t\tmem_usage, PARSE_OPT_KEEP_UNKNOWN);\n\n\tif (!argc || !(strncmp(argv[0], \"rec\", 3) || mem.operation))\n\t\tusage_with_options(mem_usage, mem_options);\n\n\tif (!mem.input_name || !strlen(mem.input_name)) {\n\t\tif (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))\n\t\t\tmem.input_name = \"-\";\n\t\telse\n\t\t\tmem.input_name = \"perf.data\";\n\t}\n\n\tif (strlen(argv[0]) > 2 && strstarts(\"record\", argv[0]))\n\t\treturn __cmd_record(argc, argv, &mem);\n\telse if (strlen(argv[0]) > 2 && strstarts(\"report\", argv[0]))\n\t\treturn report_events(argc, argv, &mem);\n\telse\n\t\tusage_with_options(mem_usage, mem_options);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}