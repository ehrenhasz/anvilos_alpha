{
  "module_name": "builtin-timechart.c",
  "hash_id": "45255b8c5fa4e072be752454bdae6e8ea9fe08a5236d7f87b40204725604de40",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-timechart.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <inttypes.h>\n\n#include \"builtin.h\"\n#include \"util/color.h\"\n#include <linux/list.h>\n#include \"util/evlist.h\" \n#include \"util/evsel.h\"\n#include <linux/kernel.h>\n#include <linux/rbtree.h>\n#include <linux/time64.h>\n#include <linux/zalloc.h>\n#include \"util/symbol.h\"\n#include \"util/thread.h\"\n#include \"util/callchain.h\"\n\n#include \"util/header.h\"\n#include <subcmd/pager.h>\n#include <subcmd/parse-options.h>\n#include \"util/parse-events.h\"\n#include \"util/event.h\"\n#include \"util/session.h\"\n#include \"util/svghelper.h\"\n#include \"util/tool.h\"\n#include \"util/data.h\"\n#include \"util/debug.h\"\n#include \"util/string2.h\"\n#include \"util/tracepoint.h\"\n#include \"util/util.h\"\n#include <linux/err.h>\n#include <traceevent/event-parse.h>\n\n#ifdef LACKS_OPEN_MEMSTREAM_PROTOTYPE\nFILE *open_memstream(char **ptr, size_t *sizeloc);\n#endif\n\n#define SUPPORT_OLD_POWER_EVENTS 1\n#define PWR_EVENT_EXIT -1\n\nstruct per_pid;\nstruct power_event;\nstruct wake_event;\n\nstruct timechart {\n\tstruct perf_tool\ttool;\n\tstruct per_pid\t\t*all_data;\n\tstruct power_event\t*power_events;\n\tstruct wake_event\t*wake_events;\n\tint\t\t\tproc_num;\n\tunsigned int\t\tnumcpus;\n\tu64\t\t\tmin_freq,\t \n\t\t\t\tmax_freq,\t \n\t\t\t\tturbo_frequency,\n\t\t\t\tfirst_time, last_time;\n\tbool\t\t\tpower_only,\n\t\t\t\ttasks_only,\n\t\t\t\twith_backtrace,\n\t\t\t\ttopology;\n\tbool\t\t\tforce;\n\t \n\tbool\t\t\tio_only,\n\t\t\t\tskip_eagain;\n\tu64\t\t\tio_events;\n\tu64\t\t\tmin_time,\n\t\t\t\tmerge_dist;\n};\n\nstruct per_pidcomm;\nstruct cpu_sample;\nstruct io_sample;\n\n \n\nstruct per_pid {\n\tstruct per_pid *next;\n\n\tint\t\tpid;\n\tint\t\tppid;\n\n\tu64\t\tstart_time;\n\tu64\t\tend_time;\n\tu64\t\ttotal_time;\n\tu64\t\ttotal_bytes;\n\tint\t\tdisplay;\n\n\tstruct per_pidcomm *all;\n\tstruct per_pidcomm *current;\n};\n\n\nstruct per_pidcomm {\n\tstruct per_pidcomm *next;\n\n\tu64\t\tstart_time;\n\tu64\t\tend_time;\n\tu64\t\ttotal_time;\n\tu64\t\tmax_bytes;\n\tu64\t\ttotal_bytes;\n\n\tint\t\tY;\n\tint\t\tdisplay;\n\n\tlong\t\tstate;\n\tu64\t\tstate_since;\n\n\tchar\t\t*comm;\n\n\tstruct cpu_sample *samples;\n\tstruct io_sample  *io_samples;\n};\n\nstruct sample_wrapper {\n\tstruct sample_wrapper *next;\n\n\tu64\t\ttimestamp;\n\tunsigned char\tdata[];\n};\n\n#define TYPE_NONE\t0\n#define TYPE_RUNNING\t1\n#define TYPE_WAITING\t2\n#define TYPE_BLOCKED\t3\n\nstruct cpu_sample {\n\tstruct cpu_sample *next;\n\n\tu64 start_time;\n\tu64 end_time;\n\tint type;\n\tint cpu;\n\tconst char *backtrace;\n};\n\nenum {\n\tIOTYPE_READ,\n\tIOTYPE_WRITE,\n\tIOTYPE_SYNC,\n\tIOTYPE_TX,\n\tIOTYPE_RX,\n\tIOTYPE_POLL,\n};\n\nstruct io_sample {\n\tstruct io_sample *next;\n\n\tu64 start_time;\n\tu64 end_time;\n\tu64 bytes;\n\tint type;\n\tint fd;\n\tint err;\n\tint merges;\n};\n\n#define CSTATE 1\n#define PSTATE 2\n\nstruct power_event {\n\tstruct power_event *next;\n\tint type;\n\tint state;\n\tu64 start_time;\n\tu64 end_time;\n\tint cpu;\n};\n\nstruct wake_event {\n\tstruct wake_event *next;\n\tint waker;\n\tint wakee;\n\tu64 time;\n\tconst char *backtrace;\n};\n\nstruct process_filter {\n\tchar\t\t\t*name;\n\tint\t\t\tpid;\n\tstruct process_filter\t*next;\n};\n\nstatic struct process_filter *process_filter;\n\n\nstatic struct per_pid *find_create_pid(struct timechart *tchart, int pid)\n{\n\tstruct per_pid *cursor = tchart->all_data;\n\n\twhile (cursor) {\n\t\tif (cursor->pid == pid)\n\t\t\treturn cursor;\n\t\tcursor = cursor->next;\n\t}\n\tcursor = zalloc(sizeof(*cursor));\n\tassert(cursor != NULL);\n\tcursor->pid = pid;\n\tcursor->next = tchart->all_data;\n\ttchart->all_data = cursor;\n\treturn cursor;\n}\n\nstatic struct per_pidcomm *create_pidcomm(struct per_pid *p)\n{\n\tstruct per_pidcomm *c;\n\n\tc = zalloc(sizeof(*c));\n\tif (!c)\n\t\treturn NULL;\n\tp->current = c;\n\tc->next = p->all;\n\tp->all = c;\n\treturn c;\n}\n\nstatic void pid_set_comm(struct timechart *tchart, int pid, char *comm)\n{\n\tstruct per_pid *p;\n\tstruct per_pidcomm *c;\n\tp = find_create_pid(tchart, pid);\n\tc = p->all;\n\twhile (c) {\n\t\tif (c->comm && strcmp(c->comm, comm) == 0) {\n\t\t\tp->current = c;\n\t\t\treturn;\n\t\t}\n\t\tif (!c->comm) {\n\t\t\tc->comm = strdup(comm);\n\t\t\tp->current = c;\n\t\t\treturn;\n\t\t}\n\t\tc = c->next;\n\t}\n\tc = create_pidcomm(p);\n\tassert(c != NULL);\n\tc->comm = strdup(comm);\n}\n\nstatic void pid_fork(struct timechart *tchart, int pid, int ppid, u64 timestamp)\n{\n\tstruct per_pid *p, *pp;\n\tp = find_create_pid(tchart, pid);\n\tpp = find_create_pid(tchart, ppid);\n\tp->ppid = ppid;\n\tif (pp->current && pp->current->comm && !p->current)\n\t\tpid_set_comm(tchart, pid, pp->current->comm);\n\n\tp->start_time = timestamp;\n\tif (p->current && !p->current->start_time) {\n\t\tp->current->start_time = timestamp;\n\t\tp->current->state_since = timestamp;\n\t}\n}\n\nstatic void pid_exit(struct timechart *tchart, int pid, u64 timestamp)\n{\n\tstruct per_pid *p;\n\tp = find_create_pid(tchart, pid);\n\tp->end_time = timestamp;\n\tif (p->current)\n\t\tp->current->end_time = timestamp;\n}\n\nstatic void pid_put_sample(struct timechart *tchart, int pid, int type,\n\t\t\t   unsigned int cpu, u64 start, u64 end,\n\t\t\t   const char *backtrace)\n{\n\tstruct per_pid *p;\n\tstruct per_pidcomm *c;\n\tstruct cpu_sample *sample;\n\n\tp = find_create_pid(tchart, pid);\n\tc = p->current;\n\tif (!c) {\n\t\tc = create_pidcomm(p);\n\t\tassert(c != NULL);\n\t}\n\n\tsample = zalloc(sizeof(*sample));\n\tassert(sample != NULL);\n\tsample->start_time = start;\n\tsample->end_time = end;\n\tsample->type = type;\n\tsample->next = c->samples;\n\tsample->cpu = cpu;\n\tsample->backtrace = backtrace;\n\tc->samples = sample;\n\n\tif (sample->type == TYPE_RUNNING && end > start && start > 0) {\n\t\tc->total_time += (end-start);\n\t\tp->total_time += (end-start);\n\t}\n\n\tif (c->start_time == 0 || c->start_time > start)\n\t\tc->start_time = start;\n\tif (p->start_time == 0 || p->start_time > start)\n\t\tp->start_time = start;\n}\n\n#define MAX_CPUS 4096\n\nstatic u64 *cpus_cstate_start_times;\nstatic int *cpus_cstate_state;\nstatic u64 *cpus_pstate_start_times;\nstatic u64 *cpus_pstate_state;\n\nstatic int process_comm_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample __maybe_unused,\n\t\t\t      struct machine *machine __maybe_unused)\n{\n\tstruct timechart *tchart = container_of(tool, struct timechart, tool);\n\tpid_set_comm(tchart, event->comm.tid, event->comm.comm);\n\treturn 0;\n}\n\nstatic int process_fork_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample __maybe_unused,\n\t\t\t      struct machine *machine __maybe_unused)\n{\n\tstruct timechart *tchart = container_of(tool, struct timechart, tool);\n\tpid_fork(tchart, event->fork.pid, event->fork.ppid, event->fork.time);\n\treturn 0;\n}\n\nstatic int process_exit_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample __maybe_unused,\n\t\t\t      struct machine *machine __maybe_unused)\n{\n\tstruct timechart *tchart = container_of(tool, struct timechart, tool);\n\tpid_exit(tchart, event->fork.pid, event->fork.time);\n\treturn 0;\n}\n\n#ifdef SUPPORT_OLD_POWER_EVENTS\nstatic int use_old_power_events;\n#endif\n\nstatic void c_state_start(int cpu, u64 timestamp, int state)\n{\n\tcpus_cstate_start_times[cpu] = timestamp;\n\tcpus_cstate_state[cpu] = state;\n}\n\nstatic void c_state_end(struct timechart *tchart, int cpu, u64 timestamp)\n{\n\tstruct power_event *pwr = zalloc(sizeof(*pwr));\n\n\tif (!pwr)\n\t\treturn;\n\n\tpwr->state = cpus_cstate_state[cpu];\n\tpwr->start_time = cpus_cstate_start_times[cpu];\n\tpwr->end_time = timestamp;\n\tpwr->cpu = cpu;\n\tpwr->type = CSTATE;\n\tpwr->next = tchart->power_events;\n\n\ttchart->power_events = pwr;\n}\n\nstatic struct power_event *p_state_end(struct timechart *tchart, int cpu,\n\t\t\t\t\tu64 timestamp)\n{\n\tstruct power_event *pwr = zalloc(sizeof(*pwr));\n\n\tif (!pwr)\n\t\treturn NULL;\n\n\tpwr->state = cpus_pstate_state[cpu];\n\tpwr->start_time = cpus_pstate_start_times[cpu];\n\tpwr->end_time = timestamp;\n\tpwr->cpu = cpu;\n\tpwr->type = PSTATE;\n\tpwr->next = tchart->power_events;\n\tif (!pwr->start_time)\n\t\tpwr->start_time = tchart->first_time;\n\n\ttchart->power_events = pwr;\n\treturn pwr;\n}\n\nstatic void p_state_change(struct timechart *tchart, int cpu, u64 timestamp, u64 new_freq)\n{\n\tstruct power_event *pwr;\n\n\tif (new_freq > 8000000)  \n\t\treturn;\n\n\tpwr = p_state_end(tchart, cpu, timestamp);\n\tif (!pwr)\n\t\treturn;\n\n\tcpus_pstate_state[cpu] = new_freq;\n\tcpus_pstate_start_times[cpu] = timestamp;\n\n\tif ((u64)new_freq > tchart->max_freq)\n\t\ttchart->max_freq = new_freq;\n\n\tif (new_freq < tchart->min_freq || tchart->min_freq == 0)\n\t\ttchart->min_freq = new_freq;\n\n\tif (new_freq == tchart->max_freq - 1000)\n\t\ttchart->turbo_frequency = tchart->max_freq;\n}\n\nstatic void sched_wakeup(struct timechart *tchart, int cpu, u64 timestamp,\n\t\t\t int waker, int wakee, u8 flags, const char *backtrace)\n{\n\tstruct per_pid *p;\n\tstruct wake_event *we = zalloc(sizeof(*we));\n\n\tif (!we)\n\t\treturn;\n\n\twe->time = timestamp;\n\twe->waker = waker;\n\twe->backtrace = backtrace;\n\n\tif ((flags & TRACE_FLAG_HARDIRQ) || (flags & TRACE_FLAG_SOFTIRQ))\n\t\twe->waker = -1;\n\n\twe->wakee = wakee;\n\twe->next = tchart->wake_events;\n\ttchart->wake_events = we;\n\tp = find_create_pid(tchart, we->wakee);\n\n\tif (p && p->current && p->current->state == TYPE_NONE) {\n\t\tp->current->state_since = timestamp;\n\t\tp->current->state = TYPE_WAITING;\n\t}\n\tif (p && p->current && p->current->state == TYPE_BLOCKED) {\n\t\tpid_put_sample(tchart, p->pid, p->current->state, cpu,\n\t\t\t       p->current->state_since, timestamp, NULL);\n\t\tp->current->state_since = timestamp;\n\t\tp->current->state = TYPE_WAITING;\n\t}\n}\n\nstatic void sched_switch(struct timechart *tchart, int cpu, u64 timestamp,\n\t\t\t int prev_pid, int next_pid, u64 prev_state,\n\t\t\t const char *backtrace)\n{\n\tstruct per_pid *p = NULL, *prev_p;\n\n\tprev_p = find_create_pid(tchart, prev_pid);\n\n\tp = find_create_pid(tchart, next_pid);\n\n\tif (prev_p->current && prev_p->current->state != TYPE_NONE)\n\t\tpid_put_sample(tchart, prev_pid, TYPE_RUNNING, cpu,\n\t\t\t       prev_p->current->state_since, timestamp,\n\t\t\t       backtrace);\n\tif (p && p->current) {\n\t\tif (p->current->state != TYPE_NONE)\n\t\t\tpid_put_sample(tchart, next_pid, p->current->state, cpu,\n\t\t\t\t       p->current->state_since, timestamp,\n\t\t\t\t       backtrace);\n\n\t\tp->current->state_since = timestamp;\n\t\tp->current->state = TYPE_RUNNING;\n\t}\n\n\tif (prev_p->current) {\n\t\tprev_p->current->state = TYPE_NONE;\n\t\tprev_p->current->state_since = timestamp;\n\t\tif (prev_state & 2)\n\t\t\tprev_p->current->state = TYPE_BLOCKED;\n\t\tif (prev_state == 0)\n\t\t\tprev_p->current->state = TYPE_WAITING;\n\t}\n}\n\nstatic const char *cat_backtrace(union perf_event *event,\n\t\t\t\t struct perf_sample *sample,\n\t\t\t\t struct machine *machine)\n{\n\tstruct addr_location al;\n\tunsigned int i;\n\tchar *p = NULL;\n\tsize_t p_len;\n\tu8 cpumode = PERF_RECORD_MISC_USER;\n\tstruct ip_callchain *chain = sample->callchain;\n\tFILE *f = open_memstream(&p, &p_len);\n\n\tif (!f) {\n\t\tperror(\"open_memstream error\");\n\t\treturn NULL;\n\t}\n\n\taddr_location__init(&al);\n\tif (!chain)\n\t\tgoto exit;\n\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tfprintf(stderr, \"problem processing %d event, skipping it.\\n\",\n\t\t\tevent->header.type);\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < chain->nr; i++) {\n\t\tu64 ip;\n\t\tstruct addr_location tal;\n\n\t\tif (callchain_param.order == ORDER_CALLEE)\n\t\t\tip = chain->ips[i];\n\t\telse\n\t\t\tip = chain->ips[chain->nr - i - 1];\n\n\t\tif (ip >= PERF_CONTEXT_MAX) {\n\t\t\tswitch (ip) {\n\t\t\tcase PERF_CONTEXT_HV:\n\t\t\t\tcpumode = PERF_RECORD_MISC_HYPERVISOR;\n\t\t\t\tbreak;\n\t\t\tcase PERF_CONTEXT_KERNEL:\n\t\t\t\tcpumode = PERF_RECORD_MISC_KERNEL;\n\t\t\t\tbreak;\n\t\t\tcase PERF_CONTEXT_USER:\n\t\t\t\tcpumode = PERF_RECORD_MISC_USER;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"invalid callchain context: \"\n\t\t\t\t\t \"%\"PRId64\"\\n\", (s64) ip);\n\n\t\t\t\t \n\t\t\t\tzfree(&p);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\taddr_location__init(&tal);\n\t\ttal.filtered = 0;\n\t\tif (thread__find_symbol(al.thread, cpumode, ip, &tal))\n\t\t\tfprintf(f, \"..... %016\" PRIx64 \" %s\\n\", ip, tal.sym->name);\n\t\telse\n\t\t\tfprintf(f, \"..... %016\" PRIx64 \"\\n\", ip);\n\n\t\taddr_location__exit(&tal);\n\t}\nexit:\n\taddr_location__exit(&al);\n\tfclose(f);\n\n\treturn p;\n}\n\ntypedef int (*tracepoint_handler)(struct timechart *tchart,\n\t\t\t\t  struct evsel *evsel,\n\t\t\t\t  struct perf_sample *sample,\n\t\t\t\t  const char *backtrace);\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct timechart *tchart = container_of(tool, struct timechart, tool);\n\n\tif (evsel->core.attr.sample_type & PERF_SAMPLE_TIME) {\n\t\tif (!tchart->first_time || tchart->first_time > sample->time)\n\t\t\ttchart->first_time = sample->time;\n\t\tif (tchart->last_time < sample->time)\n\t\t\ttchart->last_time = sample->time;\n\t}\n\n\tif (evsel->handler != NULL) {\n\t\ttracepoint_handler f = evsel->handler;\n\t\treturn f(tchart, evsel, sample,\n\t\t\t cat_backtrace(event, sample, machine));\n\t}\n\n\treturn 0;\n}\n\nstatic int\nprocess_sample_cpu_idle(struct timechart *tchart __maybe_unused,\n\t\t\tstruct evsel *evsel,\n\t\t\tstruct perf_sample *sample,\n\t\t\tconst char *backtrace __maybe_unused)\n{\n\tu32 state  = evsel__intval(evsel, sample, \"state\");\n\tu32 cpu_id = evsel__intval(evsel, sample, \"cpu_id\");\n\n\tif (state == (u32)PWR_EVENT_EXIT)\n\t\tc_state_end(tchart, cpu_id, sample->time);\n\telse\n\t\tc_state_start(cpu_id, sample->time, state);\n\treturn 0;\n}\n\nstatic int\nprocess_sample_cpu_frequency(struct timechart *tchart,\n\t\t\t     struct evsel *evsel,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     const char *backtrace __maybe_unused)\n{\n\tu32 state  = evsel__intval(evsel, sample, \"state\");\n\tu32 cpu_id = evsel__intval(evsel, sample, \"cpu_id\");\n\n\tp_state_change(tchart, cpu_id, sample->time, state);\n\treturn 0;\n}\n\nstatic int\nprocess_sample_sched_wakeup(struct timechart *tchart,\n\t\t\t    struct evsel *evsel,\n\t\t\t    struct perf_sample *sample,\n\t\t\t    const char *backtrace)\n{\n\tu8 flags  = evsel__intval(evsel, sample, \"common_flags\");\n\tint waker = evsel__intval(evsel, sample, \"common_pid\");\n\tint wakee = evsel__intval(evsel, sample, \"pid\");\n\n\tsched_wakeup(tchart, sample->cpu, sample->time, waker, wakee, flags, backtrace);\n\treturn 0;\n}\n\nstatic int\nprocess_sample_sched_switch(struct timechart *tchart,\n\t\t\t    struct evsel *evsel,\n\t\t\t    struct perf_sample *sample,\n\t\t\t    const char *backtrace)\n{\n\tint prev_pid   = evsel__intval(evsel, sample, \"prev_pid\");\n\tint next_pid   = evsel__intval(evsel, sample, \"next_pid\");\n\tu64 prev_state = evsel__intval(evsel, sample, \"prev_state\");\n\n\tsched_switch(tchart, sample->cpu, sample->time, prev_pid, next_pid,\n\t\t     prev_state, backtrace);\n\treturn 0;\n}\n\n#ifdef SUPPORT_OLD_POWER_EVENTS\nstatic int\nprocess_sample_power_start(struct timechart *tchart __maybe_unused,\n\t\t\t   struct evsel *evsel,\n\t\t\t   struct perf_sample *sample,\n\t\t\t   const char *backtrace __maybe_unused)\n{\n\tu64 cpu_id = evsel__intval(evsel, sample, \"cpu_id\");\n\tu64 value  = evsel__intval(evsel, sample, \"value\");\n\n\tc_state_start(cpu_id, sample->time, value);\n\treturn 0;\n}\n\nstatic int\nprocess_sample_power_end(struct timechart *tchart,\n\t\t\t struct evsel *evsel __maybe_unused,\n\t\t\t struct perf_sample *sample,\n\t\t\t const char *backtrace __maybe_unused)\n{\n\tc_state_end(tchart, sample->cpu, sample->time);\n\treturn 0;\n}\n\nstatic int\nprocess_sample_power_frequency(struct timechart *tchart,\n\t\t\t       struct evsel *evsel,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       const char *backtrace __maybe_unused)\n{\n\tu64 cpu_id = evsel__intval(evsel, sample, \"cpu_id\");\n\tu64 value  = evsel__intval(evsel, sample, \"value\");\n\n\tp_state_change(tchart, cpu_id, sample->time, value);\n\treturn 0;\n}\n#endif  \n\n \nstatic void end_sample_processing(struct timechart *tchart)\n{\n\tu64 cpu;\n\tstruct power_event *pwr;\n\n\tfor (cpu = 0; cpu <= tchart->numcpus; cpu++) {\n\t\t \n#if 0\n\t\tpwr = zalloc(sizeof(*pwr));\n\t\tif (!pwr)\n\t\t\treturn;\n\n\t\tpwr->state = cpus_cstate_state[cpu];\n\t\tpwr->start_time = cpus_cstate_start_times[cpu];\n\t\tpwr->end_time = tchart->last_time;\n\t\tpwr->cpu = cpu;\n\t\tpwr->type = CSTATE;\n\t\tpwr->next = tchart->power_events;\n\n\t\ttchart->power_events = pwr;\n#endif\n\t\t \n\n\t\tpwr = p_state_end(tchart, cpu, tchart->last_time);\n\t\tif (!pwr)\n\t\t\treturn;\n\n\t\tif (!pwr->state)\n\t\t\tpwr->state = tchart->min_freq;\n\t}\n}\n\nstatic int pid_begin_io_sample(struct timechart *tchart, int pid, int type,\n\t\t\t       u64 start, int fd)\n{\n\tstruct per_pid *p = find_create_pid(tchart, pid);\n\tstruct per_pidcomm *c = p->current;\n\tstruct io_sample *sample;\n\tstruct io_sample *prev;\n\n\tif (!c) {\n\t\tc = create_pidcomm(p);\n\t\tif (!c)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tprev = c->io_samples;\n\n\tif (prev && prev->start_time && !prev->end_time) {\n\t\tpr_warning(\"Skip invalid start event: \"\n\t\t\t   \"previous event already started!\\n\");\n\n\t\t \n\t\tc->io_samples = prev->next;\n\t\tfree(prev);\n\t\treturn 0;\n\t}\n\n\tsample = zalloc(sizeof(*sample));\n\tif (!sample)\n\t\treturn -ENOMEM;\n\tsample->start_time = start;\n\tsample->type = type;\n\tsample->fd = fd;\n\tsample->next = c->io_samples;\n\tc->io_samples = sample;\n\n\tif (c->start_time == 0 || c->start_time > start)\n\t\tc->start_time = start;\n\n\treturn 0;\n}\n\nstatic int pid_end_io_sample(struct timechart *tchart, int pid, int type,\n\t\t\t     u64 end, long ret)\n{\n\tstruct per_pid *p = find_create_pid(tchart, pid);\n\tstruct per_pidcomm *c = p->current;\n\tstruct io_sample *sample, *prev;\n\n\tif (!c) {\n\t\tpr_warning(\"Invalid pidcomm!\\n\");\n\t\treturn -1;\n\t}\n\n\tsample = c->io_samples;\n\n\tif (!sample)  \n\t\treturn 0;\n\n\tif (sample->end_time) {\n\t\tpr_warning(\"Skip invalid end event: \"\n\t\t\t   \"previous event already ended!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (sample->type != type) {\n\t\tpr_warning(\"Skip invalid end event: invalid event type!\\n\");\n\t\treturn 0;\n\t}\n\n\tsample->end_time = end;\n\tprev = sample->next;\n\n\t \n\tif (sample->end_time - sample->start_time < tchart->min_time)\n\t\tsample->end_time = sample->start_time + tchart->min_time;\n\tif (prev && sample->start_time < prev->end_time) {\n\t\tif (prev->err)  \n\t\t\tsample->start_time = prev->end_time;\n\t\telse\n\t\t\tprev->end_time = sample->start_time;\n\t}\n\n\tif (ret < 0) {\n\t\tsample->err = ret;\n\t} else if (type == IOTYPE_READ || type == IOTYPE_WRITE ||\n\t\t   type == IOTYPE_TX || type == IOTYPE_RX) {\n\n\t\tif ((u64)ret > c->max_bytes)\n\t\t\tc->max_bytes = ret;\n\n\t\tc->total_bytes += ret;\n\t\tp->total_bytes += ret;\n\t\tsample->bytes = ret;\n\t}\n\n\t \n\tif (prev &&\n\t    prev->type == sample->type &&\n\t    prev->err == sample->err &&\n\t    prev->fd == sample->fd &&\n\t    prev->end_time + tchart->merge_dist >= sample->start_time) {\n\n\t\tsample->bytes += prev->bytes;\n\t\tsample->merges += prev->merges + 1;\n\n\t\tsample->start_time = prev->start_time;\n\t\tsample->next = prev->next;\n\t\tfree(prev);\n\n\t\tif (!sample->err && sample->bytes > c->max_bytes)\n\t\t\tc->max_bytes = sample->bytes;\n\t}\n\n\ttchart->io_events++;\n\n\treturn 0;\n}\n\nstatic int\nprocess_enter_read(struct timechart *tchart,\n\t\t   struct evsel *evsel,\n\t\t   struct perf_sample *sample)\n{\n\tlong fd = evsel__intval(evsel, sample, \"fd\");\n\treturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_READ,\n\t\t\t\t   sample->time, fd);\n}\n\nstatic int\nprocess_exit_read(struct timechart *tchart,\n\t\t  struct evsel *evsel,\n\t\t  struct perf_sample *sample)\n{\n\tlong ret = evsel__intval(evsel, sample, \"ret\");\n\treturn pid_end_io_sample(tchart, sample->tid, IOTYPE_READ,\n\t\t\t\t sample->time, ret);\n}\n\nstatic int\nprocess_enter_write(struct timechart *tchart,\n\t\t    struct evsel *evsel,\n\t\t    struct perf_sample *sample)\n{\n\tlong fd = evsel__intval(evsel, sample, \"fd\");\n\treturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_WRITE,\n\t\t\t\t   sample->time, fd);\n}\n\nstatic int\nprocess_exit_write(struct timechart *tchart,\n\t\t   struct evsel *evsel,\n\t\t   struct perf_sample *sample)\n{\n\tlong ret = evsel__intval(evsel, sample, \"ret\");\n\treturn pid_end_io_sample(tchart, sample->tid, IOTYPE_WRITE,\n\t\t\t\t sample->time, ret);\n}\n\nstatic int\nprocess_enter_sync(struct timechart *tchart,\n\t\t   struct evsel *evsel,\n\t\t   struct perf_sample *sample)\n{\n\tlong fd = evsel__intval(evsel, sample, \"fd\");\n\treturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_SYNC,\n\t\t\t\t   sample->time, fd);\n}\n\nstatic int\nprocess_exit_sync(struct timechart *tchart,\n\t\t  struct evsel *evsel,\n\t\t  struct perf_sample *sample)\n{\n\tlong ret = evsel__intval(evsel, sample, \"ret\");\n\treturn pid_end_io_sample(tchart, sample->tid, IOTYPE_SYNC,\n\t\t\t\t sample->time, ret);\n}\n\nstatic int\nprocess_enter_tx(struct timechart *tchart,\n\t\t struct evsel *evsel,\n\t\t struct perf_sample *sample)\n{\n\tlong fd = evsel__intval(evsel, sample, \"fd\");\n\treturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_TX,\n\t\t\t\t   sample->time, fd);\n}\n\nstatic int\nprocess_exit_tx(struct timechart *tchart,\n\t\tstruct evsel *evsel,\n\t\tstruct perf_sample *sample)\n{\n\tlong ret = evsel__intval(evsel, sample, \"ret\");\n\treturn pid_end_io_sample(tchart, sample->tid, IOTYPE_TX,\n\t\t\t\t sample->time, ret);\n}\n\nstatic int\nprocess_enter_rx(struct timechart *tchart,\n\t\t struct evsel *evsel,\n\t\t struct perf_sample *sample)\n{\n\tlong fd = evsel__intval(evsel, sample, \"fd\");\n\treturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_RX,\n\t\t\t\t   sample->time, fd);\n}\n\nstatic int\nprocess_exit_rx(struct timechart *tchart,\n\t\tstruct evsel *evsel,\n\t\tstruct perf_sample *sample)\n{\n\tlong ret = evsel__intval(evsel, sample, \"ret\");\n\treturn pid_end_io_sample(tchart, sample->tid, IOTYPE_RX,\n\t\t\t\t sample->time, ret);\n}\n\nstatic int\nprocess_enter_poll(struct timechart *tchart,\n\t\t   struct evsel *evsel,\n\t\t   struct perf_sample *sample)\n{\n\tlong fd = evsel__intval(evsel, sample, \"fd\");\n\treturn pid_begin_io_sample(tchart, sample->tid, IOTYPE_POLL,\n\t\t\t\t   sample->time, fd);\n}\n\nstatic int\nprocess_exit_poll(struct timechart *tchart,\n\t\t  struct evsel *evsel,\n\t\t  struct perf_sample *sample)\n{\n\tlong ret = evsel__intval(evsel, sample, \"ret\");\n\treturn pid_end_io_sample(tchart, sample->tid, IOTYPE_POLL,\n\t\t\t\t sample->time, ret);\n}\n\n \nstatic void sort_pids(struct timechart *tchart)\n{\n\tstruct per_pid *new_list, *p, *cursor, *prev;\n\t \n\n\tnew_list = NULL;\n\n\twhile (tchart->all_data) {\n\t\tp = tchart->all_data;\n\t\ttchart->all_data = p->next;\n\t\tp->next = NULL;\n\n\t\tif (new_list == NULL) {\n\t\t\tnew_list = p;\n\t\t\tp->next = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tprev = NULL;\n\t\tcursor = new_list;\n\t\twhile (cursor) {\n\t\t\tif (cursor->ppid > p->ppid ||\n\t\t\t\t(cursor->ppid == p->ppid && cursor->pid > p->pid)) {\n\t\t\t\t \n\t\t\t\tif (prev) {\n\t\t\t\t\tp->next = prev->next;\n\t\t\t\t\tprev->next = p;\n\t\t\t\t\tcursor = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tp->next = new_list;\n\t\t\t\t\tnew_list = p;\n\t\t\t\t\tcursor = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev = cursor;\n\t\t\tcursor = cursor->next;\n\t\t\tif (!cursor)\n\t\t\t\tprev->next = p;\n\t\t}\n\t}\n\ttchart->all_data = new_list;\n}\n\n\nstatic void draw_c_p_states(struct timechart *tchart)\n{\n\tstruct power_event *pwr;\n\tpwr = tchart->power_events;\n\n\t \n\twhile (pwr) {\n\t\tif (pwr->type == CSTATE)\n\t\t\tsvg_cstate(pwr->cpu, pwr->start_time, pwr->end_time, pwr->state);\n\t\tpwr = pwr->next;\n\t}\n\n\tpwr = tchart->power_events;\n\twhile (pwr) {\n\t\tif (pwr->type == PSTATE) {\n\t\t\tif (!pwr->state)\n\t\t\t\tpwr->state = tchart->min_freq;\n\t\t\tsvg_pstate(pwr->cpu, pwr->start_time, pwr->end_time, pwr->state);\n\t\t}\n\t\tpwr = pwr->next;\n\t}\n}\n\nstatic void draw_wakeups(struct timechart *tchart)\n{\n\tstruct wake_event *we;\n\tstruct per_pid *p;\n\tstruct per_pidcomm *c;\n\n\twe = tchart->wake_events;\n\twhile (we) {\n\t\tint from = 0, to = 0;\n\t\tchar *task_from = NULL, *task_to = NULL;\n\n\t\t \n\t\tp = tchart->all_data;\n\t\twhile (p) {\n\t\t\tif (p->pid == we->waker || p->pid == we->wakee) {\n\t\t\t\tc = p->all;\n\t\t\t\twhile (c) {\n\t\t\t\t\tif (c->Y && c->start_time <= we->time && c->end_time >= we->time) {\n\t\t\t\t\t\tif (p->pid == we->waker && !from) {\n\t\t\t\t\t\t\tfrom = c->Y;\n\t\t\t\t\t\t\ttask_from = strdup(c->comm);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p->pid == we->wakee && !to) {\n\t\t\t\t\t\t\tto = c->Y;\n\t\t\t\t\t\t\ttask_to = strdup(c->comm);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc = c->next;\n\t\t\t\t}\n\t\t\t\tc = p->all;\n\t\t\t\twhile (c) {\n\t\t\t\t\tif (p->pid == we->waker && !from) {\n\t\t\t\t\t\tfrom = c->Y;\n\t\t\t\t\t\ttask_from = strdup(c->comm);\n\t\t\t\t\t}\n\t\t\t\t\tif (p->pid == we->wakee && !to) {\n\t\t\t\t\t\tto = c->Y;\n\t\t\t\t\t\ttask_to = strdup(c->comm);\n\t\t\t\t\t}\n\t\t\t\t\tc = c->next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = p->next;\n\t\t}\n\n\t\tif (!task_from) {\n\t\t\ttask_from = malloc(40);\n\t\t\tsprintf(task_from, \"[%i]\", we->waker);\n\t\t}\n\t\tif (!task_to) {\n\t\t\ttask_to = malloc(40);\n\t\t\tsprintf(task_to, \"[%i]\", we->wakee);\n\t\t}\n\n\t\tif (we->waker == -1)\n\t\t\tsvg_interrupt(we->time, to, we->backtrace);\n\t\telse if (from && to && abs(from - to) == 1)\n\t\t\tsvg_wakeline(we->time, from, to, we->backtrace);\n\t\telse\n\t\t\tsvg_partial_wakeline(we->time, from, task_from, to,\n\t\t\t\t\t     task_to, we->backtrace);\n\t\twe = we->next;\n\n\t\tfree(task_from);\n\t\tfree(task_to);\n\t}\n}\n\nstatic void draw_cpu_usage(struct timechart *tchart)\n{\n\tstruct per_pid *p;\n\tstruct per_pidcomm *c;\n\tstruct cpu_sample *sample;\n\tp = tchart->all_data;\n\twhile (p) {\n\t\tc = p->all;\n\t\twhile (c) {\n\t\t\tsample = c->samples;\n\t\t\twhile (sample) {\n\t\t\t\tif (sample->type == TYPE_RUNNING) {\n\t\t\t\t\tsvg_process(sample->cpu,\n\t\t\t\t\t\t    sample->start_time,\n\t\t\t\t\t\t    sample->end_time,\n\t\t\t\t\t\t    p->pid,\n\t\t\t\t\t\t    c->comm,\n\t\t\t\t\t\t    sample->backtrace);\n\t\t\t\t}\n\n\t\t\t\tsample = sample->next;\n\t\t\t}\n\t\t\tc = c->next;\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\nstatic void draw_io_bars(struct timechart *tchart)\n{\n\tconst char *suf;\n\tdouble bytes;\n\tchar comm[256];\n\tstruct per_pid *p;\n\tstruct per_pidcomm *c;\n\tstruct io_sample *sample;\n\tint Y = 1;\n\n\tp = tchart->all_data;\n\twhile (p) {\n\t\tc = p->all;\n\t\twhile (c) {\n\t\t\tif (!c->display) {\n\t\t\t\tc->Y = 0;\n\t\t\t\tc = c->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsvg_box(Y, c->start_time, c->end_time, \"process3\");\n\t\t\tsample = c->io_samples;\n\t\t\tfor (sample = c->io_samples; sample; sample = sample->next) {\n\t\t\t\tdouble h = (double)sample->bytes / c->max_bytes;\n\n\t\t\t\tif (tchart->skip_eagain &&\n\t\t\t\t    sample->err == -EAGAIN)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (sample->err)\n\t\t\t\t\th = 1;\n\n\t\t\t\tif (sample->type == IOTYPE_SYNC)\n\t\t\t\t\tsvg_fbox(Y,\n\t\t\t\t\t\tsample->start_time,\n\t\t\t\t\t\tsample->end_time,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tsample->err ? \"error\" : \"sync\",\n\t\t\t\t\t\tsample->fd,\n\t\t\t\t\t\tsample->err,\n\t\t\t\t\t\tsample->merges);\n\t\t\t\telse if (sample->type == IOTYPE_POLL)\n\t\t\t\t\tsvg_fbox(Y,\n\t\t\t\t\t\tsample->start_time,\n\t\t\t\t\t\tsample->end_time,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tsample->err ? \"error\" : \"poll\",\n\t\t\t\t\t\tsample->fd,\n\t\t\t\t\t\tsample->err,\n\t\t\t\t\t\tsample->merges);\n\t\t\t\telse if (sample->type == IOTYPE_READ)\n\t\t\t\t\tsvg_ubox(Y,\n\t\t\t\t\t\tsample->start_time,\n\t\t\t\t\t\tsample->end_time,\n\t\t\t\t\t\th,\n\t\t\t\t\t\tsample->err ? \"error\" : \"disk\",\n\t\t\t\t\t\tsample->fd,\n\t\t\t\t\t\tsample->err,\n\t\t\t\t\t\tsample->merges);\n\t\t\t\telse if (sample->type == IOTYPE_WRITE)\n\t\t\t\t\tsvg_lbox(Y,\n\t\t\t\t\t\tsample->start_time,\n\t\t\t\t\t\tsample->end_time,\n\t\t\t\t\t\th,\n\t\t\t\t\t\tsample->err ? \"error\" : \"disk\",\n\t\t\t\t\t\tsample->fd,\n\t\t\t\t\t\tsample->err,\n\t\t\t\t\t\tsample->merges);\n\t\t\t\telse if (sample->type == IOTYPE_RX)\n\t\t\t\t\tsvg_ubox(Y,\n\t\t\t\t\t\tsample->start_time,\n\t\t\t\t\t\tsample->end_time,\n\t\t\t\t\t\th,\n\t\t\t\t\t\tsample->err ? \"error\" : \"net\",\n\t\t\t\t\t\tsample->fd,\n\t\t\t\t\t\tsample->err,\n\t\t\t\t\t\tsample->merges);\n\t\t\t\telse if (sample->type == IOTYPE_TX)\n\t\t\t\t\tsvg_lbox(Y,\n\t\t\t\t\t\tsample->start_time,\n\t\t\t\t\t\tsample->end_time,\n\t\t\t\t\t\th,\n\t\t\t\t\t\tsample->err ? \"error\" : \"net\",\n\t\t\t\t\t\tsample->fd,\n\t\t\t\t\t\tsample->err,\n\t\t\t\t\t\tsample->merges);\n\t\t\t}\n\n\t\t\tsuf = \"\";\n\t\t\tbytes = c->total_bytes;\n\t\t\tif (bytes > 1024) {\n\t\t\t\tbytes = bytes / 1024;\n\t\t\t\tsuf = \"K\";\n\t\t\t}\n\t\t\tif (bytes > 1024) {\n\t\t\t\tbytes = bytes / 1024;\n\t\t\t\tsuf = \"M\";\n\t\t\t}\n\t\t\tif (bytes > 1024) {\n\t\t\t\tbytes = bytes / 1024;\n\t\t\t\tsuf = \"G\";\n\t\t\t}\n\n\n\t\t\tsprintf(comm, \"%s:%i (%3.1f %sbytes)\", c->comm ?: \"\", p->pid, bytes, suf);\n\t\t\tsvg_text(Y, c->start_time, comm);\n\n\t\t\tc->Y = Y;\n\t\t\tY++;\n\t\t\tc = c->next;\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\nstatic void draw_process_bars(struct timechart *tchart)\n{\n\tstruct per_pid *p;\n\tstruct per_pidcomm *c;\n\tstruct cpu_sample *sample;\n\tint Y = 0;\n\n\tY = 2 * tchart->numcpus + 2;\n\n\tp = tchart->all_data;\n\twhile (p) {\n\t\tc = p->all;\n\t\twhile (c) {\n\t\t\tif (!c->display) {\n\t\t\t\tc->Y = 0;\n\t\t\t\tc = c->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsvg_box(Y, c->start_time, c->end_time, \"process\");\n\t\t\tsample = c->samples;\n\t\t\twhile (sample) {\n\t\t\t\tif (sample->type == TYPE_RUNNING)\n\t\t\t\t\tsvg_running(Y, sample->cpu,\n\t\t\t\t\t\t    sample->start_time,\n\t\t\t\t\t\t    sample->end_time,\n\t\t\t\t\t\t    sample->backtrace);\n\t\t\t\tif (sample->type == TYPE_BLOCKED)\n\t\t\t\t\tsvg_blocked(Y, sample->cpu,\n\t\t\t\t\t\t    sample->start_time,\n\t\t\t\t\t\t    sample->end_time,\n\t\t\t\t\t\t    sample->backtrace);\n\t\t\t\tif (sample->type == TYPE_WAITING)\n\t\t\t\t\tsvg_waiting(Y, sample->cpu,\n\t\t\t\t\t\t    sample->start_time,\n\t\t\t\t\t\t    sample->end_time,\n\t\t\t\t\t\t    sample->backtrace);\n\t\t\t\tsample = sample->next;\n\t\t\t}\n\n\t\t\tif (c->comm) {\n\t\t\t\tchar comm[256];\n\t\t\t\tif (c->total_time > 5000000000)  \n\t\t\t\t\tsprintf(comm, \"%s:%i (%2.2fs)\", c->comm, p->pid, c->total_time / (double)NSEC_PER_SEC);\n\t\t\t\telse\n\t\t\t\t\tsprintf(comm, \"%s:%i (%3.1fms)\", c->comm, p->pid, c->total_time / (double)NSEC_PER_MSEC);\n\n\t\t\t\tsvg_text(Y, c->start_time, comm);\n\t\t\t}\n\t\t\tc->Y = Y;\n\t\t\tY++;\n\t\t\tc = c->next;\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\nstatic void add_process_filter(const char *string)\n{\n\tint pid = strtoull(string, NULL, 10);\n\tstruct process_filter *filt = malloc(sizeof(*filt));\n\n\tif (!filt)\n\t\treturn;\n\n\tfilt->name = strdup(string);\n\tfilt->pid  = pid;\n\tfilt->next = process_filter;\n\n\tprocess_filter = filt;\n}\n\nstatic int passes_filter(struct per_pid *p, struct per_pidcomm *c)\n{\n\tstruct process_filter *filt;\n\tif (!process_filter)\n\t\treturn 1;\n\n\tfilt = process_filter;\n\twhile (filt) {\n\t\tif (filt->pid && p->pid == filt->pid)\n\t\t\treturn 1;\n\t\tif (strcmp(filt->name, c->comm) == 0)\n\t\t\treturn 1;\n\t\tfilt = filt->next;\n\t}\n\treturn 0;\n}\n\nstatic int determine_display_tasks_filtered(struct timechart *tchart)\n{\n\tstruct per_pid *p;\n\tstruct per_pidcomm *c;\n\tint count = 0;\n\n\tp = tchart->all_data;\n\twhile (p) {\n\t\tp->display = 0;\n\t\tif (p->start_time == 1)\n\t\t\tp->start_time = tchart->first_time;\n\n\t\t \n\t\tif (p->end_time == 0)\n\t\t\tp->end_time = tchart->last_time;\n\n\t\tc = p->all;\n\n\t\twhile (c) {\n\t\t\tc->display = 0;\n\n\t\t\tif (c->start_time == 1)\n\t\t\t\tc->start_time = tchart->first_time;\n\n\t\t\tif (passes_filter(p, c)) {\n\t\t\t\tc->display = 1;\n\t\t\t\tp->display = 1;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tif (c->end_time == 0)\n\t\t\t\tc->end_time = tchart->last_time;\n\n\t\t\tc = c->next;\n\t\t}\n\t\tp = p->next;\n\t}\n\treturn count;\n}\n\nstatic int determine_display_tasks(struct timechart *tchart, u64 threshold)\n{\n\tstruct per_pid *p;\n\tstruct per_pidcomm *c;\n\tint count = 0;\n\n\tp = tchart->all_data;\n\twhile (p) {\n\t\tp->display = 0;\n\t\tif (p->start_time == 1)\n\t\t\tp->start_time = tchart->first_time;\n\n\t\t \n\t\tif (p->end_time == 0)\n\t\t\tp->end_time = tchart->last_time;\n\t\tif (p->total_time >= threshold)\n\t\t\tp->display = 1;\n\n\t\tc = p->all;\n\n\t\twhile (c) {\n\t\t\tc->display = 0;\n\n\t\t\tif (c->start_time == 1)\n\t\t\t\tc->start_time = tchart->first_time;\n\n\t\t\tif (c->total_time >= threshold) {\n\t\t\t\tc->display = 1;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tif (c->end_time == 0)\n\t\t\t\tc->end_time = tchart->last_time;\n\n\t\t\tc = c->next;\n\t\t}\n\t\tp = p->next;\n\t}\n\treturn count;\n}\n\nstatic int determine_display_io_tasks(struct timechart *timechart, u64 threshold)\n{\n\tstruct per_pid *p;\n\tstruct per_pidcomm *c;\n\tint count = 0;\n\n\tp = timechart->all_data;\n\twhile (p) {\n\t\t \n\t\tif (p->end_time == 0)\n\t\t\tp->end_time = timechart->last_time;\n\n\t\tc = p->all;\n\n\t\twhile (c) {\n\t\t\tc->display = 0;\n\n\t\t\tif (c->total_bytes >= threshold) {\n\t\t\t\tc->display = 1;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tif (c->end_time == 0)\n\t\t\t\tc->end_time = timechart->last_time;\n\n\t\t\tc = c->next;\n\t\t}\n\t\tp = p->next;\n\t}\n\treturn count;\n}\n\n#define BYTES_THRESH (1 * 1024 * 1024)\n#define TIME_THRESH 10000000\n\nstatic void write_svg_file(struct timechart *tchart, const char *filename)\n{\n\tu64 i;\n\tint count;\n\tint thresh = tchart->io_events ? BYTES_THRESH : TIME_THRESH;\n\n\tif (tchart->power_only)\n\t\ttchart->proc_num = 0;\n\n\t \n\tdo {\n\t\tif (process_filter)\n\t\t\tcount = determine_display_tasks_filtered(tchart);\n\t\telse if (tchart->io_events)\n\t\t\tcount = determine_display_io_tasks(tchart, thresh);\n\t\telse\n\t\t\tcount = determine_display_tasks(tchart, thresh);\n\t\tthresh /= 10;\n\t} while (!process_filter && thresh && count < tchart->proc_num);\n\n\tif (!tchart->proc_num)\n\t\tcount = 0;\n\n\tif (tchart->io_events) {\n\t\topen_svg(filename, 0, count, tchart->first_time, tchart->last_time);\n\n\t\tsvg_time_grid(0.5);\n\t\tsvg_io_legenda();\n\n\t\tdraw_io_bars(tchart);\n\t} else {\n\t\topen_svg(filename, tchart->numcpus, count, tchart->first_time, tchart->last_time);\n\n\t\tsvg_time_grid(0);\n\n\t\tsvg_legenda();\n\n\t\tfor (i = 0; i < tchart->numcpus; i++)\n\t\t\tsvg_cpu_box(i, tchart->max_freq, tchart->turbo_frequency);\n\n\t\tdraw_cpu_usage(tchart);\n\t\tif (tchart->proc_num)\n\t\t\tdraw_process_bars(tchart);\n\t\tif (!tchart->tasks_only)\n\t\t\tdraw_c_p_states(tchart);\n\t\tif (tchart->proc_num)\n\t\t\tdraw_wakeups(tchart);\n\t}\n\n\tsvg_close();\n}\n\nstatic int process_header(struct perf_file_section *section __maybe_unused,\n\t\t\t  struct perf_header *ph,\n\t\t\t  int feat,\n\t\t\t  int fd __maybe_unused,\n\t\t\t  void *data)\n{\n\tstruct timechart *tchart = data;\n\n\tswitch (feat) {\n\tcase HEADER_NRCPUS:\n\t\ttchart->numcpus = ph->env.nr_cpus_avail;\n\t\tbreak;\n\n\tcase HEADER_CPU_TOPOLOGY:\n\t\tif (!tchart->topology)\n\t\t\tbreak;\n\n\t\tif (svg_build_topology_map(&ph->env))\n\t\t\tfprintf(stderr, \"problem building topology\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __cmd_timechart(struct timechart *tchart, const char *output_name)\n{\n\tconst struct evsel_str_handler power_tracepoints[] = {\n\t\t{ \"power:cpu_idle\",\t\tprocess_sample_cpu_idle },\n\t\t{ \"power:cpu_frequency\",\tprocess_sample_cpu_frequency },\n\t\t{ \"sched:sched_wakeup\",\t\tprocess_sample_sched_wakeup },\n\t\t{ \"sched:sched_switch\",\t\tprocess_sample_sched_switch },\n#ifdef SUPPORT_OLD_POWER_EVENTS\n\t\t{ \"power:power_start\",\t\tprocess_sample_power_start },\n\t\t{ \"power:power_end\",\t\tprocess_sample_power_end },\n\t\t{ \"power:power_frequency\",\tprocess_sample_power_frequency },\n#endif\n\n\t\t{ \"syscalls:sys_enter_read\",\t\tprocess_enter_read },\n\t\t{ \"syscalls:sys_enter_pread64\",\t\tprocess_enter_read },\n\t\t{ \"syscalls:sys_enter_readv\",\t\tprocess_enter_read },\n\t\t{ \"syscalls:sys_enter_preadv\",\t\tprocess_enter_read },\n\t\t{ \"syscalls:sys_enter_write\",\t\tprocess_enter_write },\n\t\t{ \"syscalls:sys_enter_pwrite64\",\tprocess_enter_write },\n\t\t{ \"syscalls:sys_enter_writev\",\t\tprocess_enter_write },\n\t\t{ \"syscalls:sys_enter_pwritev\",\t\tprocess_enter_write },\n\t\t{ \"syscalls:sys_enter_sync\",\t\tprocess_enter_sync },\n\t\t{ \"syscalls:sys_enter_sync_file_range\",\tprocess_enter_sync },\n\t\t{ \"syscalls:sys_enter_fsync\",\t\tprocess_enter_sync },\n\t\t{ \"syscalls:sys_enter_msync\",\t\tprocess_enter_sync },\n\t\t{ \"syscalls:sys_enter_recvfrom\",\tprocess_enter_rx },\n\t\t{ \"syscalls:sys_enter_recvmmsg\",\tprocess_enter_rx },\n\t\t{ \"syscalls:sys_enter_recvmsg\",\t\tprocess_enter_rx },\n\t\t{ \"syscalls:sys_enter_sendto\",\t\tprocess_enter_tx },\n\t\t{ \"syscalls:sys_enter_sendmsg\",\t\tprocess_enter_tx },\n\t\t{ \"syscalls:sys_enter_sendmmsg\",\tprocess_enter_tx },\n\t\t{ \"syscalls:sys_enter_epoll_pwait\",\tprocess_enter_poll },\n\t\t{ \"syscalls:sys_enter_epoll_wait\",\tprocess_enter_poll },\n\t\t{ \"syscalls:sys_enter_poll\",\t\tprocess_enter_poll },\n\t\t{ \"syscalls:sys_enter_ppoll\",\t\tprocess_enter_poll },\n\t\t{ \"syscalls:sys_enter_pselect6\",\tprocess_enter_poll },\n\t\t{ \"syscalls:sys_enter_select\",\t\tprocess_enter_poll },\n\n\t\t{ \"syscalls:sys_exit_read\",\t\tprocess_exit_read },\n\t\t{ \"syscalls:sys_exit_pread64\",\t\tprocess_exit_read },\n\t\t{ \"syscalls:sys_exit_readv\",\t\tprocess_exit_read },\n\t\t{ \"syscalls:sys_exit_preadv\",\t\tprocess_exit_read },\n\t\t{ \"syscalls:sys_exit_write\",\t\tprocess_exit_write },\n\t\t{ \"syscalls:sys_exit_pwrite64\",\t\tprocess_exit_write },\n\t\t{ \"syscalls:sys_exit_writev\",\t\tprocess_exit_write },\n\t\t{ \"syscalls:sys_exit_pwritev\",\t\tprocess_exit_write },\n\t\t{ \"syscalls:sys_exit_sync\",\t\tprocess_exit_sync },\n\t\t{ \"syscalls:sys_exit_sync_file_range\",\tprocess_exit_sync },\n\t\t{ \"syscalls:sys_exit_fsync\",\t\tprocess_exit_sync },\n\t\t{ \"syscalls:sys_exit_msync\",\t\tprocess_exit_sync },\n\t\t{ \"syscalls:sys_exit_recvfrom\",\t\tprocess_exit_rx },\n\t\t{ \"syscalls:sys_exit_recvmmsg\",\t\tprocess_exit_rx },\n\t\t{ \"syscalls:sys_exit_recvmsg\",\t\tprocess_exit_rx },\n\t\t{ \"syscalls:sys_exit_sendto\",\t\tprocess_exit_tx },\n\t\t{ \"syscalls:sys_exit_sendmsg\",\t\tprocess_exit_tx },\n\t\t{ \"syscalls:sys_exit_sendmmsg\",\t\tprocess_exit_tx },\n\t\t{ \"syscalls:sys_exit_epoll_pwait\",\tprocess_exit_poll },\n\t\t{ \"syscalls:sys_exit_epoll_wait\",\tprocess_exit_poll },\n\t\t{ \"syscalls:sys_exit_poll\",\t\tprocess_exit_poll },\n\t\t{ \"syscalls:sys_exit_ppoll\",\t\tprocess_exit_poll },\n\t\t{ \"syscalls:sys_exit_pselect6\",\t\tprocess_exit_poll },\n\t\t{ \"syscalls:sys_exit_select\",\t\tprocess_exit_poll },\n\t};\n\tstruct perf_data data = {\n\t\t.path  = input_name,\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t\t.force = tchart->force,\n\t};\n\n\tstruct perf_session *session = perf_session__new(&data, &tchart->tool);\n\tint ret = -EINVAL;\n\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tsymbol__init(&session->header.env);\n\n\t(void)perf_header__process_sections(&session->header,\n\t\t\t\t\t    perf_data__fd(session->data),\n\t\t\t\t\t    tchart,\n\t\t\t\t\t    process_header);\n\n\tif (!perf_session__has_traces(session, \"timechart record\"))\n\t\tgoto out_delete;\n\n\tif (perf_session__set_tracepoints_handlers(session,\n\t\t\t\t\t\t   power_tracepoints)) {\n\t\tpr_err(\"Initializing session tracepoint handlers failed\\n\");\n\t\tgoto out_delete;\n\t}\n\n\tret = perf_session__process_events(session);\n\tif (ret)\n\t\tgoto out_delete;\n\n\tend_sample_processing(tchart);\n\n\tsort_pids(tchart);\n\n\twrite_svg_file(tchart, output_name);\n\n\tpr_info(\"Written %2.1f seconds of trace to %s.\\n\",\n\t\t(tchart->last_time - tchart->first_time) / (double)NSEC_PER_SEC, output_name);\nout_delete:\n\tperf_session__delete(session);\n\treturn ret;\n}\n\nstatic int timechart__io_record(int argc, const char **argv)\n{\n\tunsigned int rec_argc, i;\n\tconst char **rec_argv;\n\tconst char **p;\n\tchar *filter = NULL;\n\n\tconst char * const common_args[] = {\n\t\t\"record\", \"-a\", \"-R\", \"-c\", \"1\",\n\t};\n\tunsigned int common_args_nr = ARRAY_SIZE(common_args);\n\n\tconst char * const disk_events[] = {\n\t\t\"syscalls:sys_enter_read\",\n\t\t\"syscalls:sys_enter_pread64\",\n\t\t\"syscalls:sys_enter_readv\",\n\t\t\"syscalls:sys_enter_preadv\",\n\t\t\"syscalls:sys_enter_write\",\n\t\t\"syscalls:sys_enter_pwrite64\",\n\t\t\"syscalls:sys_enter_writev\",\n\t\t\"syscalls:sys_enter_pwritev\",\n\t\t\"syscalls:sys_enter_sync\",\n\t\t\"syscalls:sys_enter_sync_file_range\",\n\t\t\"syscalls:sys_enter_fsync\",\n\t\t\"syscalls:sys_enter_msync\",\n\n\t\t\"syscalls:sys_exit_read\",\n\t\t\"syscalls:sys_exit_pread64\",\n\t\t\"syscalls:sys_exit_readv\",\n\t\t\"syscalls:sys_exit_preadv\",\n\t\t\"syscalls:sys_exit_write\",\n\t\t\"syscalls:sys_exit_pwrite64\",\n\t\t\"syscalls:sys_exit_writev\",\n\t\t\"syscalls:sys_exit_pwritev\",\n\t\t\"syscalls:sys_exit_sync\",\n\t\t\"syscalls:sys_exit_sync_file_range\",\n\t\t\"syscalls:sys_exit_fsync\",\n\t\t\"syscalls:sys_exit_msync\",\n\t};\n\tunsigned int disk_events_nr = ARRAY_SIZE(disk_events);\n\n\tconst char * const net_events[] = {\n\t\t\"syscalls:sys_enter_recvfrom\",\n\t\t\"syscalls:sys_enter_recvmmsg\",\n\t\t\"syscalls:sys_enter_recvmsg\",\n\t\t\"syscalls:sys_enter_sendto\",\n\t\t\"syscalls:sys_enter_sendmsg\",\n\t\t\"syscalls:sys_enter_sendmmsg\",\n\n\t\t\"syscalls:sys_exit_recvfrom\",\n\t\t\"syscalls:sys_exit_recvmmsg\",\n\t\t\"syscalls:sys_exit_recvmsg\",\n\t\t\"syscalls:sys_exit_sendto\",\n\t\t\"syscalls:sys_exit_sendmsg\",\n\t\t\"syscalls:sys_exit_sendmmsg\",\n\t};\n\tunsigned int net_events_nr = ARRAY_SIZE(net_events);\n\n\tconst char * const poll_events[] = {\n\t\t\"syscalls:sys_enter_epoll_pwait\",\n\t\t\"syscalls:sys_enter_epoll_wait\",\n\t\t\"syscalls:sys_enter_poll\",\n\t\t\"syscalls:sys_enter_ppoll\",\n\t\t\"syscalls:sys_enter_pselect6\",\n\t\t\"syscalls:sys_enter_select\",\n\n\t\t\"syscalls:sys_exit_epoll_pwait\",\n\t\t\"syscalls:sys_exit_epoll_wait\",\n\t\t\"syscalls:sys_exit_poll\",\n\t\t\"syscalls:sys_exit_ppoll\",\n\t\t\"syscalls:sys_exit_pselect6\",\n\t\t\"syscalls:sys_exit_select\",\n\t};\n\tunsigned int poll_events_nr = ARRAY_SIZE(poll_events);\n\n\trec_argc = common_args_nr +\n\t\tdisk_events_nr * 4 +\n\t\tnet_events_nr * 4 +\n\t\tpoll_events_nr * 4 +\n\t\targc;\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\n\tif (rec_argv == NULL)\n\t\treturn -ENOMEM;\n\n\tif (asprintf(&filter, \"common_pid != %d\", getpid()) < 0) {\n\t\tfree(rec_argv);\n\t\treturn -ENOMEM;\n\t}\n\n\tp = rec_argv;\n\tfor (i = 0; i < common_args_nr; i++)\n\t\t*p++ = strdup(common_args[i]);\n\n\tfor (i = 0; i < disk_events_nr; i++) {\n\t\tif (!is_valid_tracepoint(disk_events[i])) {\n\t\t\trec_argc -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*p++ = \"-e\";\n\t\t*p++ = strdup(disk_events[i]);\n\t\t*p++ = \"--filter\";\n\t\t*p++ = filter;\n\t}\n\tfor (i = 0; i < net_events_nr; i++) {\n\t\tif (!is_valid_tracepoint(net_events[i])) {\n\t\t\trec_argc -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*p++ = \"-e\";\n\t\t*p++ = strdup(net_events[i]);\n\t\t*p++ = \"--filter\";\n\t\t*p++ = filter;\n\t}\n\tfor (i = 0; i < poll_events_nr; i++) {\n\t\tif (!is_valid_tracepoint(poll_events[i])) {\n\t\t\trec_argc -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*p++ = \"-e\";\n\t\t*p++ = strdup(poll_events[i]);\n\t\t*p++ = \"--filter\";\n\t\t*p++ = filter;\n\t}\n\n\tfor (i = 0; i < (unsigned int)argc; i++)\n\t\t*p++ = argv[i];\n\n\treturn cmd_record(rec_argc, rec_argv);\n}\n\n\nstatic int timechart__record(struct timechart *tchart, int argc, const char **argv)\n{\n\tunsigned int rec_argc, i, j;\n\tconst char **rec_argv;\n\tconst char **p;\n\tunsigned int record_elems;\n\n\tconst char * const common_args[] = {\n\t\t\"record\", \"-a\", \"-R\", \"-c\", \"1\",\n\t};\n\tunsigned int common_args_nr = ARRAY_SIZE(common_args);\n\n\tconst char * const backtrace_args[] = {\n\t\t\"-g\",\n\t};\n\tunsigned int backtrace_args_no = ARRAY_SIZE(backtrace_args);\n\n\tconst char * const power_args[] = {\n\t\t\"-e\", \"power:cpu_frequency\",\n\t\t\"-e\", \"power:cpu_idle\",\n\t};\n\tunsigned int power_args_nr = ARRAY_SIZE(power_args);\n\n\tconst char * const old_power_args[] = {\n#ifdef SUPPORT_OLD_POWER_EVENTS\n\t\t\"-e\", \"power:power_start\",\n\t\t\"-e\", \"power:power_end\",\n\t\t\"-e\", \"power:power_frequency\",\n#endif\n\t};\n\tunsigned int old_power_args_nr = ARRAY_SIZE(old_power_args);\n\n\tconst char * const tasks_args[] = {\n\t\t\"-e\", \"sched:sched_wakeup\",\n\t\t\"-e\", \"sched:sched_switch\",\n\t};\n\tunsigned int tasks_args_nr = ARRAY_SIZE(tasks_args);\n\n#ifdef SUPPORT_OLD_POWER_EVENTS\n\tif (!is_valid_tracepoint(\"power:cpu_idle\") &&\n\t    is_valid_tracepoint(\"power:power_start\")) {\n\t\tuse_old_power_events = 1;\n\t\tpower_args_nr = 0;\n\t} else {\n\t\told_power_args_nr = 0;\n\t}\n#endif\n\n\tif (tchart->power_only)\n\t\ttasks_args_nr = 0;\n\n\tif (tchart->tasks_only) {\n\t\tpower_args_nr = 0;\n\t\told_power_args_nr = 0;\n\t}\n\n\tif (!tchart->with_backtrace)\n\t\tbacktrace_args_no = 0;\n\n\trecord_elems = common_args_nr + tasks_args_nr +\n\t\tpower_args_nr + old_power_args_nr + backtrace_args_no;\n\n\trec_argc = record_elems + argc;\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\n\tif (rec_argv == NULL)\n\t\treturn -ENOMEM;\n\n\tp = rec_argv;\n\tfor (i = 0; i < common_args_nr; i++)\n\t\t*p++ = strdup(common_args[i]);\n\n\tfor (i = 0; i < backtrace_args_no; i++)\n\t\t*p++ = strdup(backtrace_args[i]);\n\n\tfor (i = 0; i < tasks_args_nr; i++)\n\t\t*p++ = strdup(tasks_args[i]);\n\n\tfor (i = 0; i < power_args_nr; i++)\n\t\t*p++ = strdup(power_args[i]);\n\n\tfor (i = 0; i < old_power_args_nr; i++)\n\t\t*p++ = strdup(old_power_args[i]);\n\n\tfor (j = 0; j < (unsigned int)argc; j++)\n\t\t*p++ = argv[j];\n\n\treturn cmd_record(rec_argc, rec_argv);\n}\n\nstatic int\nparse_process(const struct option *opt __maybe_unused, const char *arg,\n\t      int __maybe_unused unset)\n{\n\tif (arg)\n\t\tadd_process_filter(arg);\n\treturn 0;\n}\n\nstatic int\nparse_highlight(const struct option *opt __maybe_unused, const char *arg,\n\t\tint __maybe_unused unset)\n{\n\tunsigned long duration = strtoul(arg, NULL, 0);\n\n\tif (svg_highlight || svg_highlight_name)\n\t\treturn -1;\n\n\tif (duration)\n\t\tsvg_highlight = duration;\n\telse\n\t\tsvg_highlight_name = strdup(arg);\n\n\treturn 0;\n}\n\nstatic int\nparse_time(const struct option *opt, const char *arg, int __maybe_unused unset)\n{\n\tchar unit = 'n';\n\tu64 *value = opt->value;\n\n\tif (sscanf(arg, \"%\" PRIu64 \"%cs\", value, &unit) > 0) {\n\t\tswitch (unit) {\n\t\tcase 'm':\n\t\t\t*value *= NSEC_PER_MSEC;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\t*value *= NSEC_PER_USEC;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint cmd_timechart(int argc, const char **argv)\n{\n\tstruct timechart tchart = {\n\t\t.tool = {\n\t\t\t.comm\t\t = process_comm_event,\n\t\t\t.fork\t\t = process_fork_event,\n\t\t\t.exit\t\t = process_exit_event,\n\t\t\t.sample\t\t = process_sample_event,\n\t\t\t.ordered_events\t = true,\n\t\t},\n\t\t.proc_num = 15,\n\t\t.min_time = NSEC_PER_MSEC,\n\t\t.merge_dist = 1000,\n\t};\n\tconst char *output_name = \"output.svg\";\n\tconst struct option timechart_common_options[] = {\n\tOPT_BOOLEAN('P', \"power-only\", &tchart.power_only, \"output power data only\"),\n\tOPT_BOOLEAN('T', \"tasks-only\", &tchart.tasks_only, \"output processes data only\"),\n\tOPT_END()\n\t};\n\tconst struct option timechart_options[] = {\n\tOPT_STRING('i', \"input\", &input_name, \"file\", \"input file name\"),\n\tOPT_STRING('o', \"output\", &output_name, \"file\", \"output file name\"),\n\tOPT_INTEGER('w', \"width\", &svg_page_width, \"page width\"),\n\tOPT_CALLBACK(0, \"highlight\", NULL, \"duration or task name\",\n\t\t      \"highlight tasks. Pass duration in ns or process name.\",\n\t\t       parse_highlight),\n\tOPT_CALLBACK('p', \"process\", NULL, \"process\",\n\t\t      \"process selector. Pass a pid or process name.\",\n\t\t       parse_process),\n\tOPT_CALLBACK(0, \"symfs\", NULL, \"directory\",\n\t\t     \"Look for files with symbols relative to this directory\",\n\t\t     symbol__config_symfs),\n\tOPT_INTEGER('n', \"proc-num\", &tchart.proc_num,\n\t\t    \"min. number of tasks to print\"),\n\tOPT_BOOLEAN('t', \"topology\", &tchart.topology,\n\t\t    \"sort CPUs according to topology\"),\n\tOPT_BOOLEAN(0, \"io-skip-eagain\", &tchart.skip_eagain,\n\t\t    \"skip EAGAIN errors\"),\n\tOPT_CALLBACK(0, \"io-min-time\", &tchart.min_time, \"time\",\n\t\t     \"all IO faster than min-time will visually appear longer\",\n\t\t     parse_time),\n\tOPT_CALLBACK(0, \"io-merge-dist\", &tchart.merge_dist, \"time\",\n\t\t     \"merge events that are merge-dist us apart\",\n\t\t     parse_time),\n\tOPT_BOOLEAN('f', \"force\", &tchart.force, \"don't complain, do it\"),\n\tOPT_PARENT(timechart_common_options),\n\t};\n\tconst char * const timechart_subcommands[] = { \"record\", NULL };\n\tconst char *timechart_usage[] = {\n\t\t\"perf timechart [<options>] {record}\",\n\t\tNULL\n\t};\n\tconst struct option timechart_record_options[] = {\n\tOPT_BOOLEAN('I', \"io-only\", &tchart.io_only,\n\t\t    \"record only IO data\"),\n\tOPT_BOOLEAN('g', \"callchain\", &tchart.with_backtrace, \"record callchain\"),\n\tOPT_PARENT(timechart_common_options),\n\t};\n\tconst char * const timechart_record_usage[] = {\n\t\t\"perf timechart record [<options>]\",\n\t\tNULL\n\t};\n\tint ret;\n\n\tcpus_cstate_start_times = calloc(MAX_CPUS, sizeof(*cpus_cstate_start_times));\n\tif (!cpus_cstate_start_times)\n\t\treturn -ENOMEM;\n\tcpus_cstate_state = calloc(MAX_CPUS, sizeof(*cpus_cstate_state));\n\tif (!cpus_cstate_state) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcpus_pstate_start_times = calloc(MAX_CPUS, sizeof(*cpus_pstate_start_times));\n\tif (!cpus_pstate_start_times) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcpus_pstate_state = calloc(MAX_CPUS, sizeof(*cpus_pstate_state));\n\tif (!cpus_pstate_state) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\targc = parse_options_subcommand(argc, argv, timechart_options, timechart_subcommands,\n\t\t\ttimechart_usage, PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tif (tchart.power_only && tchart.tasks_only) {\n\t\tpr_err(\"-P and -T options cannot be used at the same time.\\n\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (argc && strlen(argv[0]) > 2 && strstarts(\"record\", argv[0])) {\n\t\targc = parse_options(argc, argv, timechart_record_options,\n\t\t\t\t     timechart_record_usage,\n\t\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\t\tif (tchart.power_only && tchart.tasks_only) {\n\t\t\tpr_err(\"-P and -T options cannot be used at the same time.\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (tchart.io_only)\n\t\t\tret = timechart__io_record(argc, argv);\n\t\telse\n\t\t\tret = timechart__record(&tchart, argc, argv);\n\t\tgoto out;\n\t} else if (argc)\n\t\tusage_with_options(timechart_usage, timechart_options);\n\n\tsetup_pager();\n\n\tret = __cmd_timechart(&tchart, output_name);\nout:\n\tzfree(&cpus_cstate_start_times);\n\tzfree(&cpus_cstate_state);\n\tzfree(&cpus_pstate_start_times);\n\tzfree(&cpus_pstate_state);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}