{
  "module_name": "auxtrace.c",
  "hash_id": "5c8b1c1d68e4b103011a42d588b0024d3a16eab29d8df92dc781ae2c7682ab07",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/s390/util/auxtrace.c",
  "human_readable_source": "#include <stdbool.h>\n#include <stdlib.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/zalloc.h>\n\n#include \"../../util/evlist.h\"\n#include \"../../util/auxtrace.h\"\n#include \"../../util/evsel.h\"\n#include \"../../util/record.h\"\n\n#define PERF_EVENT_CPUM_SF\t\t0xB0000  \n#define PERF_EVENT_CPUM_SF_DIAG\t\t0xBD000  \n#define DEFAULT_AUX_PAGES\t\t128\n#define DEFAULT_FREQ\t\t\t4000\n\nstatic void cpumsf_free(struct auxtrace_record *itr)\n{\n\tfree(itr);\n}\n\nstatic size_t cpumsf_info_priv_size(struct auxtrace_record *itr __maybe_unused,\n\t\t\t\t    struct evlist *evlist __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int\ncpumsf_info_fill(struct auxtrace_record *itr __maybe_unused,\n\t\t struct perf_session *session __maybe_unused,\n\t\t struct perf_record_auxtrace_info *auxtrace_info __maybe_unused,\n\t\t size_t priv_size __maybe_unused)\n{\n\tauxtrace_info->type = PERF_AUXTRACE_S390_CPUMSF;\n\treturn 0;\n}\n\nstatic unsigned long\ncpumsf_reference(struct auxtrace_record *itr __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int\ncpumsf_recording_options(struct auxtrace_record *ar __maybe_unused,\n\t\t\t struct evlist *evlist __maybe_unused,\n\t\t\t struct record_opts *opts)\n{\n\tunsigned int factor = 1;\n\tunsigned int pages;\n\n\topts->full_auxtrace = true;\n\n\t \n\tif (!opts->auxtrace_mmap_pages) {\n\t\tif (opts->user_freq != UINT_MAX)\n\t\t\tfactor = (opts->user_freq + DEFAULT_FREQ\n\t\t\t\t  - 1) / DEFAULT_FREQ;\n\t\tpages = DEFAULT_AUX_PAGES * factor;\n\t\topts->auxtrace_mmap_pages = roundup_pow_of_two(pages);\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncpumsf_parse_snapshot_options(struct auxtrace_record *itr __maybe_unused,\n\t\t\t      struct record_opts *opts __maybe_unused,\n\t\t\t      const char *str __maybe_unused)\n{\n\treturn 0;\n}\n\n \nstruct auxtrace_record *auxtrace_record__init(struct evlist *evlist,\n\t\t\t\t\t      int *err)\n{\n\tstruct auxtrace_record *aux;\n\tstruct evsel *pos;\n\tint diagnose = 0;\n\n\t*err = 0;\n\tif (evlist->core.nr_entries == 0)\n\t\treturn NULL;\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tif (pos->core.attr.config == PERF_EVENT_CPUM_SF_DIAG) {\n\t\t\tdiagnose = 1;\n\t\t\tpos->needs_auxtrace_mmap = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!diagnose)\n\t\treturn NULL;\n\n\t \n\taux = zalloc(sizeof(*aux));\n\tif (aux == NULL) {\n\t\t*err = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\taux->parse_snapshot_options = cpumsf_parse_snapshot_options;\n\taux->recording_options = cpumsf_recording_options;\n\taux->info_priv_size = cpumsf_info_priv_size;\n\taux->info_fill = cpumsf_info_fill;\n\taux->free = cpumsf_free;\n\taux->reference = cpumsf_reference;\n\n\treturn aux;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}