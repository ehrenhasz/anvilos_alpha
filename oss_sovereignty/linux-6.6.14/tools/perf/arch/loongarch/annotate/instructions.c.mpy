{
  "module_name": "instructions.c",
  "hash_id": "4bf2a57ae82a296833036bd47d51358ddac8ae6c82396f32470e82a4ff610d4a",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/loongarch/annotate/instructions.c",
  "human_readable_source": "\n \n\nstatic int loongarch_call__parse(struct arch *arch, struct ins_operands *ops, struct map_symbol *ms)\n{\n\tchar *c, *endptr, *tok, *name;\n\tstruct map *map = ms->map;\n\tstruct addr_map_symbol target = {\n\t\t.ms = { .map = map, },\n\t};\n\n\tc = strchr(ops->raw, '#');\n\tif (c++ == NULL)\n\t\treturn -1;\n\n\tops->target.addr = strtoull(c, &endptr, 16);\n\n\tname = strchr(endptr, '<');\n\tname++;\n\n\tif (arch->objdump.skip_functions_char &&\n\t    strchr(name, arch->objdump.skip_functions_char))\n\t\treturn -1;\n\n\ttok = strchr(name, '>');\n\tif (tok == NULL)\n\t\treturn -1;\n\n\t*tok = '\\0';\n\tops->target.name = strdup(name);\n\t*tok = '>';\n\n\tif (ops->target.name == NULL)\n\t\treturn -1;\n\n\ttarget.addr = map__objdump_2mem(map, ops->target.addr);\n\n\tif (maps__find_ams(ms->maps, &target) == 0 &&\n\t    map__rip_2objdump(target.ms.map, map__map_ip(target.ms.map, target.addr)) == ops->target.addr)\n\t\tops->target.sym = target.ms.sym;\n\n\treturn 0;\n}\n\nstatic struct ins_ops loongarch_call_ops = {\n\t.parse\t   = loongarch_call__parse,\n\t.scnprintf = call__scnprintf,\n};\n\nstatic int loongarch_jump__parse(struct arch *arch, struct ins_operands *ops, struct map_symbol *ms)\n{\n\tstruct map *map = ms->map;\n\tstruct symbol *sym = ms->sym;\n\tstruct addr_map_symbol target = {\n\t\t.ms = { .map = map, },\n\t};\n\tconst char *c = strchr(ops->raw, '#');\n\tu64 start, end;\n\n\tops->raw_comment = strchr(ops->raw, arch->objdump.comment_char);\n\tops->raw_func_start = strchr(ops->raw, '<');\n\n\tif (ops->raw_func_start && c > ops->raw_func_start)\n\t\tc = NULL;\n\n\tif (c++ != NULL)\n\t\tops->target.addr = strtoull(c, NULL, 16);\n\telse\n\t\tops->target.addr = strtoull(ops->raw, NULL, 16);\n\n\ttarget.addr = map__objdump_2mem(map, ops->target.addr);\n\tstart = map__unmap_ip(map, sym->start);\n\tend = map__unmap_ip(map, sym->end);\n\n\tops->target.outside = target.addr < start || target.addr > end;\n\n\tif (maps__find_ams(ms->maps, &target) == 0 &&\n\t    map__rip_2objdump(target.ms.map, map__map_ip(target.ms.map, target.addr)) == ops->target.addr)\n\t\tops->target.sym = target.ms.sym;\n\n\tif (!ops->target.outside) {\n\t\tops->target.offset = target.addr - start;\n\t\tops->target.offset_avail = true;\n\t} else {\n\t\tops->target.offset_avail = false;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ins_ops loongarch_jump_ops = {\n\t.parse\t   = loongarch_jump__parse,\n\t.scnprintf = jump__scnprintf,\n};\n\nstatic\nstruct ins_ops *loongarch__associate_ins_ops(struct arch *arch, const char *name)\n{\n\tstruct ins_ops *ops = NULL;\n\n\tif (!strcmp(name, \"bl\"))\n\t\tops = &loongarch_call_ops;\n\telse if (!strcmp(name, \"jirl\"))\n\t\tops = &ret_ops;\n\telse if (!strcmp(name, \"b\") ||\n\t\t !strncmp(name, \"beq\", 3) ||\n\t\t !strncmp(name, \"bne\", 3) ||\n\t\t !strncmp(name, \"blt\", 3) ||\n\t\t !strncmp(name, \"bge\", 3) ||\n\t\t !strncmp(name, \"bltu\", 4) ||\n\t\t !strncmp(name, \"bgeu\", 4))\n\t\tops = &loongarch_jump_ops;\n\telse\n\t\treturn NULL;\n\n\tarch__associate_ins_ops(arch, name, ops);\n\n\treturn ops;\n}\n\nstatic\nint loongarch__annotate_init(struct arch *arch, char *cpuid __maybe_unused)\n{\n\tif (!arch->initialized) {\n\t\tarch->associate_instruction_ops = loongarch__associate_ins_ops;\n\t\tarch->initialized = true;\n\t\tarch->objdump.comment_char = '#';\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}