{
  "module_name": "hisi-ptt.c",
  "hash_id": "197b1ce5958c187ac96ebb463e0d2603256e7370584fc673621c5e591a96bd18",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/arm64/util/hisi-ptt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/zalloc.h>\n#include <time.h>\n\n#include <internal/lib.h> \n#include \"../../../util/auxtrace.h\"\n#include \"../../../util/cpumap.h\"\n#include \"../../../util/debug.h\"\n#include \"../../../util/event.h\"\n#include \"../../../util/evlist.h\"\n#include \"../../../util/evsel.h\"\n#include \"../../../util/hisi-ptt.h\"\n#include \"../../../util/pmu.h\"\n#include \"../../../util/record.h\"\n#include \"../../../util/session.h\"\n#include \"../../../util/tsc.h\"\n\n#define KiB(x) ((x) * 1024)\n#define MiB(x) ((x) * 1024 * 1024)\n\nstruct hisi_ptt_recording {\n\tstruct auxtrace_record\titr;\n\tstruct perf_pmu *hisi_ptt_pmu;\n\tstruct evlist *evlist;\n};\n\nstatic size_t\nhisi_ptt_info_priv_size(struct auxtrace_record *itr __maybe_unused,\n\t\t\tstruct evlist *evlist __maybe_unused)\n{\n\treturn HISI_PTT_AUXTRACE_PRIV_SIZE;\n}\n\nstatic int hisi_ptt_info_fill(struct auxtrace_record *itr,\n\t\t\t      struct perf_session *session,\n\t\t\t      struct perf_record_auxtrace_info *auxtrace_info,\n\t\t\t      size_t priv_size)\n{\n\tstruct hisi_ptt_recording *pttr =\n\t\t\tcontainer_of(itr, struct hisi_ptt_recording, itr);\n\tstruct perf_pmu *hisi_ptt_pmu = pttr->hisi_ptt_pmu;\n\n\tif (priv_size != HISI_PTT_AUXTRACE_PRIV_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!session->evlist->core.nr_mmaps)\n\t\treturn -EINVAL;\n\n\tauxtrace_info->type = PERF_AUXTRACE_HISI_PTT;\n\tauxtrace_info->priv[0] = hisi_ptt_pmu->type;\n\n\treturn 0;\n}\n\nstatic int hisi_ptt_set_auxtrace_mmap_page(struct record_opts *opts)\n{\n\tbool privileged = perf_event_paranoid_check(-1);\n\n\tif (!opts->full_auxtrace)\n\t\treturn 0;\n\n\tif (opts->full_auxtrace && !opts->auxtrace_mmap_pages) {\n\t\tif (privileged) {\n\t\t\topts->auxtrace_mmap_pages = MiB(16) / page_size;\n\t\t} else {\n\t\t\topts->auxtrace_mmap_pages = KiB(128) / page_size;\n\t\t\tif (opts->mmap_pages == UINT_MAX)\n\t\t\t\topts->mmap_pages = KiB(256) / page_size;\n\t\t}\n\t}\n\n\t \n\tif (opts->auxtrace_mmap_pages) {\n\t\tsize_t sz = opts->auxtrace_mmap_pages * (size_t)page_size;\n\t\tsize_t min_sz = KiB(8);\n\n\t\tif (sz < min_sz || !is_power_of_2(sz)) {\n\t\t\tpr_err(\"Invalid mmap size for HISI PTT: must be at least %zuKiB and a power of 2\\n\",\n\t\t\t       min_sz / 1024);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hisi_ptt_recording_options(struct auxtrace_record *itr,\n\t\t\t\t      struct evlist *evlist,\n\t\t\t\t      struct record_opts *opts)\n{\n\tstruct hisi_ptt_recording *pttr =\n\t\t\tcontainer_of(itr, struct hisi_ptt_recording, itr);\n\tstruct perf_pmu *hisi_ptt_pmu = pttr->hisi_ptt_pmu;\n\tstruct evsel *evsel, *hisi_ptt_evsel = NULL;\n\tstruct evsel *tracking_evsel;\n\tint err;\n\n\tpttr->evlist = evlist;\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type == hisi_ptt_pmu->type) {\n\t\t\tif (hisi_ptt_evsel) {\n\t\t\t\tpr_err(\"There may be only one \" HISI_PTT_PMU_NAME \"x event\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tevsel->core.attr.freq = 0;\n\t\t\tevsel->core.attr.sample_period = 1;\n\t\t\tevsel->needs_auxtrace_mmap = true;\n\t\t\thisi_ptt_evsel = evsel;\n\t\t\topts->full_auxtrace = true;\n\t\t}\n\t}\n\n\terr = hisi_ptt_set_auxtrace_mmap_page(opts);\n\tif (err)\n\t\treturn err;\n\t \n\tevlist__to_front(evlist, hisi_ptt_evsel);\n\tevsel__set_sample_bit(hisi_ptt_evsel, TIME);\n\n\t \n\terr = parse_event(evlist, \"dummy:u\");\n\tif (err)\n\t\treturn err;\n\n\ttracking_evsel = evlist__last(evlist);\n\tevlist__set_tracking_event(evlist, tracking_evsel);\n\n\ttracking_evsel->core.attr.freq = 0;\n\ttracking_evsel->core.attr.sample_period = 1;\n\tevsel__set_sample_bit(tracking_evsel, TIME);\n\n\treturn 0;\n}\n\nstatic u64 hisi_ptt_reference(struct auxtrace_record *itr __maybe_unused)\n{\n\treturn rdtsc();\n}\n\nstatic void hisi_ptt_recording_free(struct auxtrace_record *itr)\n{\n\tstruct hisi_ptt_recording *pttr =\n\t\t\tcontainer_of(itr, struct hisi_ptt_recording, itr);\n\n\tfree(pttr);\n}\n\nstruct auxtrace_record *hisi_ptt_recording_init(int *err,\n\t\t\t\t\t\tstruct perf_pmu *hisi_ptt_pmu)\n{\n\tstruct hisi_ptt_recording *pttr;\n\n\tif (!hisi_ptt_pmu) {\n\t\t*err = -ENODEV;\n\t\treturn NULL;\n\t}\n\n\tpttr = zalloc(sizeof(*pttr));\n\tif (!pttr) {\n\t\t*err = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tpttr->hisi_ptt_pmu = hisi_ptt_pmu;\n\tpttr->itr.pmu = hisi_ptt_pmu;\n\tpttr->itr.recording_options = hisi_ptt_recording_options;\n\tpttr->itr.info_priv_size = hisi_ptt_info_priv_size;\n\tpttr->itr.info_fill = hisi_ptt_info_fill;\n\tpttr->itr.free = hisi_ptt_recording_free;\n\tpttr->itr.reference = hisi_ptt_reference;\n\tpttr->itr.read_finish = auxtrace_record__read_finish;\n\tpttr->itr.alignment = 0;\n\n\t*err = 0;\n\treturn &pttr->itr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}