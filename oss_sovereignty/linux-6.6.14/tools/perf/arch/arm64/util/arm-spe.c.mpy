{
  "module_name": "arm-spe.c",
  "hash_id": "c519a09250b84f871a401e123bedbe52a96936c04ce3628f5064d09a27c26368",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/arm64/util/arm-spe.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/zalloc.h>\n#include <time.h>\n\n#include \"../../../util/cpumap.h\"\n#include \"../../../util/event.h\"\n#include \"../../../util/evsel.h\"\n#include \"../../../util/evsel_config.h\"\n#include \"../../../util/evlist.h\"\n#include \"../../../util/session.h\"\n#include <internal/lib.h> \n#include \"../../../util/pmu.h\"\n#include \"../../../util/debug.h\"\n#include \"../../../util/auxtrace.h\"\n#include \"../../../util/record.h\"\n#include \"../../../util/arm-spe.h\"\n#include <tools/libc_compat.h> \n\n#define KiB(x) ((x) * 1024)\n#define MiB(x) ((x) * 1024 * 1024)\n\nstruct arm_spe_recording {\n\tstruct auxtrace_record\t\titr;\n\tstruct perf_pmu\t\t\t*arm_spe_pmu;\n\tstruct evlist\t\t*evlist;\n\tint\t\t\twrapped_cnt;\n\tbool\t\t\t*wrapped;\n};\n\nstatic size_t\narm_spe_info_priv_size(struct auxtrace_record *itr __maybe_unused,\n\t\t       struct evlist *evlist __maybe_unused)\n{\n\treturn ARM_SPE_AUXTRACE_PRIV_SIZE;\n}\n\nstatic int arm_spe_info_fill(struct auxtrace_record *itr,\n\t\t\t     struct perf_session *session,\n\t\t\t     struct perf_record_auxtrace_info *auxtrace_info,\n\t\t\t     size_t priv_size)\n{\n\tstruct arm_spe_recording *sper =\n\t\t\tcontainer_of(itr, struct arm_spe_recording, itr);\n\tstruct perf_pmu *arm_spe_pmu = sper->arm_spe_pmu;\n\n\tif (priv_size != ARM_SPE_AUXTRACE_PRIV_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!session->evlist->core.nr_mmaps)\n\t\treturn -EINVAL;\n\n\tauxtrace_info->type = PERF_AUXTRACE_ARM_SPE;\n\tauxtrace_info->priv[ARM_SPE_PMU_TYPE] = arm_spe_pmu->type;\n\n\treturn 0;\n}\n\nstatic void\narm_spe_snapshot_resolve_auxtrace_defaults(struct record_opts *opts,\n\t\t\t\t\t   bool privileged)\n{\n\t \n\n\t \n\tif (!opts->auxtrace_snapshot_size && !opts->auxtrace_mmap_pages) {\n\t\tif (privileged) {\n\t\t\topts->auxtrace_mmap_pages = MiB(4) / page_size;\n\t\t} else {\n\t\t\topts->auxtrace_mmap_pages = KiB(128) / page_size;\n\t\t\tif (opts->mmap_pages == UINT_MAX)\n\t\t\t\topts->mmap_pages = KiB(256) / page_size;\n\t\t}\n\t} else if (!opts->auxtrace_mmap_pages && !privileged && opts->mmap_pages == UINT_MAX) {\n\t\topts->mmap_pages = KiB(256) / page_size;\n\t}\n\n\t \n\tif (!opts->auxtrace_snapshot_size)\n\t\topts->auxtrace_snapshot_size = opts->auxtrace_mmap_pages * (size_t)page_size;\n\n\t \n\tif (!opts->auxtrace_mmap_pages) {\n\t\tsize_t sz = opts->auxtrace_snapshot_size;\n\n\t\tsz = round_up(sz, page_size) / page_size;\n\t\topts->auxtrace_mmap_pages = roundup_pow_of_two(sz);\n\t}\n}\n\nstatic int arm_spe_recording_options(struct auxtrace_record *itr,\n\t\t\t\t     struct evlist *evlist,\n\t\t\t\t     struct record_opts *opts)\n{\n\tstruct arm_spe_recording *sper =\n\t\t\tcontainer_of(itr, struct arm_spe_recording, itr);\n\tstruct perf_pmu *arm_spe_pmu = sper->arm_spe_pmu;\n\tstruct evsel *evsel, *arm_spe_evsel = NULL;\n\tstruct perf_cpu_map *cpus = evlist->core.user_requested_cpus;\n\tbool privileged = perf_event_paranoid_check(-1);\n\tstruct evsel *tracking_evsel;\n\tint err;\n\tu64 bit;\n\n\tsper->evlist = evlist;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type == arm_spe_pmu->type) {\n\t\t\tif (arm_spe_evsel) {\n\t\t\t\tpr_err(\"There may be only one \" ARM_SPE_PMU_NAME \"x event\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tevsel->core.attr.freq = 0;\n\t\t\tevsel->core.attr.sample_period = arm_spe_pmu->default_config->sample_period;\n\t\t\tevsel->needs_auxtrace_mmap = true;\n\t\t\tarm_spe_evsel = evsel;\n\t\t\topts->full_auxtrace = true;\n\t\t}\n\t}\n\n\tif (!opts->full_auxtrace)\n\t\treturn 0;\n\n\t \n\tif (opts->auxtrace_snapshot_mode) {\n\t\t \n\t\tif (!opts->auxtrace_snapshot_size || !opts->auxtrace_mmap_pages)\n\t\t\tarm_spe_snapshot_resolve_auxtrace_defaults(opts, privileged);\n\n\t\t \n\t\tif (opts->auxtrace_snapshot_size > opts->auxtrace_mmap_pages * (size_t)page_size) {\n\t\t\tpr_err(\"Snapshot size %zu must not be greater than AUX area tracing mmap size %zu\\n\",\n\t\t\t       opts->auxtrace_snapshot_size,\n\t\t\t       opts->auxtrace_mmap_pages * (size_t)page_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!opts->auxtrace_snapshot_size || !opts->auxtrace_mmap_pages) {\n\t\t\tpr_err(\"Failed to calculate default snapshot size and/or AUX area tracing mmap pages\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (!opts->auxtrace_mmap_pages) {\n\t\tif (privileged) {\n\t\t\topts->auxtrace_mmap_pages = MiB(4) / page_size;\n\t\t} else {\n\t\t\topts->auxtrace_mmap_pages = KiB(128) / page_size;\n\t\t\tif (opts->mmap_pages == UINT_MAX)\n\t\t\t\topts->mmap_pages = KiB(256) / page_size;\n\t\t}\n\t}\n\n\t \n\tif (opts->auxtrace_mmap_pages) {\n\t\tsize_t sz = opts->auxtrace_mmap_pages * (size_t)page_size;\n\t\tsize_t min_sz = KiB(8);\n\n\t\tif (sz < min_sz || !is_power_of_2(sz)) {\n\t\t\tpr_err(\"Invalid mmap size for ARM SPE: must be at least %zuKiB and a power of 2\\n\",\n\t\t\t       min_sz / 1024);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (opts->auxtrace_snapshot_mode)\n\t\tpr_debug2(\"%sx snapshot size: %zu\\n\", ARM_SPE_PMU_NAME,\n\t\t\t  opts->auxtrace_snapshot_size);\n\n\t \n\tevlist__to_front(evlist, arm_spe_evsel);\n\n\t \n\tif (!perf_cpu_map__empty(cpus)) {\n\t\tevsel__set_sample_bit(arm_spe_evsel, CPU);\n\t\tevsel__set_config_if_unset(arm_spe_pmu, arm_spe_evsel,\n\t\t\t\t\t   \"ts_enable\", 1);\n\t}\n\n\t \n\tevsel__set_sample_bit(arm_spe_evsel, DATA_SRC);\n\n\t \n\tbit = perf_pmu__format_bits(arm_spe_pmu, \"pa_enable\");\n\tif (arm_spe_evsel->core.attr.config & bit)\n\t\tevsel__set_sample_bit(arm_spe_evsel, PHYS_ADDR);\n\n\t \n\terr = parse_event(evlist, \"dummy:u\");\n\tif (err)\n\t\treturn err;\n\n\ttracking_evsel = evlist__last(evlist);\n\tevlist__set_tracking_event(evlist, tracking_evsel);\n\n\ttracking_evsel->core.attr.freq = 0;\n\ttracking_evsel->core.attr.sample_period = 1;\n\n\t \n\tif (!perf_cpu_map__empty(cpus)) {\n\t\tevsel__set_sample_bit(tracking_evsel, TIME);\n\t\tevsel__set_sample_bit(tracking_evsel, CPU);\n\n\t\t \n\t\tif (!record_opts__no_switch_events(opts))\n\t\t\ttracking_evsel->core.attr.context_switch = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int arm_spe_parse_snapshot_options(struct auxtrace_record *itr __maybe_unused,\n\t\t\t\t\t struct record_opts *opts,\n\t\t\t\t\t const char *str)\n{\n\tunsigned long long snapshot_size = 0;\n\tchar *endptr;\n\n\tif (str) {\n\t\tsnapshot_size = strtoull(str, &endptr, 0);\n\t\tif (*endptr || snapshot_size > SIZE_MAX)\n\t\t\treturn -1;\n\t}\n\n\topts->auxtrace_snapshot_mode = true;\n\topts->auxtrace_snapshot_size = snapshot_size;\n\n\treturn 0;\n}\n\nstatic int arm_spe_snapshot_start(struct auxtrace_record *itr)\n{\n\tstruct arm_spe_recording *ptr =\n\t\t\tcontainer_of(itr, struct arm_spe_recording, itr);\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(ptr->evlist, evsel) {\n\t\tif (evsel->core.attr.type == ptr->arm_spe_pmu->type)\n\t\t\treturn evsel__disable(evsel);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int arm_spe_snapshot_finish(struct auxtrace_record *itr)\n{\n\tstruct arm_spe_recording *ptr =\n\t\t\tcontainer_of(itr, struct arm_spe_recording, itr);\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(ptr->evlist, evsel) {\n\t\tif (evsel->core.attr.type == ptr->arm_spe_pmu->type)\n\t\t\treturn evsel__enable(evsel);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int arm_spe_alloc_wrapped_array(struct arm_spe_recording *ptr, int idx)\n{\n\tbool *wrapped;\n\tint cnt = ptr->wrapped_cnt, new_cnt, i;\n\n\t \n\tif (idx < cnt)\n\t\treturn 0;\n\n\t \n\tnew_cnt = idx + 1;\n\n\t \n\twrapped = reallocarray(ptr->wrapped, new_cnt, sizeof(bool));\n\tif (!wrapped)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = cnt; i < new_cnt; i++)\n\t\twrapped[i] = false;\n\n\tptr->wrapped_cnt = new_cnt;\n\tptr->wrapped = wrapped;\n\n\treturn 0;\n}\n\nstatic bool arm_spe_buffer_has_wrapped(unsigned char *buffer,\n\t\t\t\t      size_t buffer_size, u64 head)\n{\n\tu64 i, watermark;\n\tu64 *buf = (u64 *)buffer;\n\tsize_t buf_size = buffer_size;\n\n\t \n\tif (head >= buffer_size)\n\t\treturn true;\n\n\t \n\twatermark = buf_size - 512;\n\n\t \n\n\t \n\tif (head > watermark)\n\t\twatermark = head;\n\n\t \n\twatermark /= sizeof(u64);\n\tbuf_size /= sizeof(u64);\n\n\t \n\tfor (i = watermark; i < buf_size; i++)\n\t\tif (buf[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int arm_spe_find_snapshot(struct auxtrace_record *itr, int idx,\n\t\t\t\t  struct auxtrace_mmap *mm, unsigned char *data,\n\t\t\t\t  u64 *head, u64 *old)\n{\n\tint err;\n\tbool wrapped;\n\tstruct arm_spe_recording *ptr =\n\t\t\tcontainer_of(itr, struct arm_spe_recording, itr);\n\n\t \n\tif (idx >= ptr->wrapped_cnt) {\n\t\terr = arm_spe_alloc_wrapped_array(ptr, idx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\twrapped = ptr->wrapped[idx];\n\tif (!wrapped && arm_spe_buffer_has_wrapped(data, mm->len, *head)) {\n\t\twrapped = true;\n\t\tptr->wrapped[idx] = true;\n\t}\n\n\tpr_debug3(\"%s: mmap index %d old head %zu new head %zu size %zu\\n\",\n\t\t  __func__, idx, (size_t)*old, (size_t)*head, mm->len);\n\n\t \n\tif (!wrapped)\n\t\treturn 0;\n\n\t \n\tif (*head >= mm->len) {\n\t\t*old = *head - mm->len;\n\t} else {\n\t\t*head += mm->len;\n\t\t*old = *head - mm->len;\n\t}\n\n\treturn 0;\n}\n\nstatic u64 arm_spe_reference(struct auxtrace_record *itr __maybe_unused)\n{\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n\n\treturn ts.tv_sec ^ ts.tv_nsec;\n}\n\nstatic void arm_spe_recording_free(struct auxtrace_record *itr)\n{\n\tstruct arm_spe_recording *sper =\n\t\t\tcontainer_of(itr, struct arm_spe_recording, itr);\n\n\tzfree(&sper->wrapped);\n\tfree(sper);\n}\n\nstruct auxtrace_record *arm_spe_recording_init(int *err,\n\t\t\t\t\t       struct perf_pmu *arm_spe_pmu)\n{\n\tstruct arm_spe_recording *sper;\n\n\tif (!arm_spe_pmu) {\n\t\t*err = -ENODEV;\n\t\treturn NULL;\n\t}\n\n\tsper = zalloc(sizeof(struct arm_spe_recording));\n\tif (!sper) {\n\t\t*err = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tsper->arm_spe_pmu = arm_spe_pmu;\n\tsper->itr.pmu = arm_spe_pmu;\n\tsper->itr.snapshot_start = arm_spe_snapshot_start;\n\tsper->itr.snapshot_finish = arm_spe_snapshot_finish;\n\tsper->itr.find_snapshot = arm_spe_find_snapshot;\n\tsper->itr.parse_snapshot_options = arm_spe_parse_snapshot_options;\n\tsper->itr.recording_options = arm_spe_recording_options;\n\tsper->itr.info_priv_size = arm_spe_info_priv_size;\n\tsper->itr.info_fill = arm_spe_info_fill;\n\tsper->itr.free = arm_spe_recording_free;\n\tsper->itr.reference = arm_spe_reference;\n\tsper->itr.read_finish = auxtrace_record__read_finish;\n\tsper->itr.alignment = 0;\n\n\t*err = 0;\n\treturn &sper->itr;\n}\n\nstruct perf_event_attr\n*arm_spe_pmu_default_config(struct perf_pmu *arm_spe_pmu)\n{\n\tstruct perf_event_attr *attr;\n\n\tattr = zalloc(sizeof(struct perf_event_attr));\n\tif (!attr) {\n\t\tpr_err(\"arm_spe default config cannot allocate a perf_event_attr\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif (perf_pmu__scan_file(arm_spe_pmu, \"caps/min_interval\", \"%llu\",\n\t\t\t\t  &attr->sample_period) != 1) {\n\t\tpr_debug(\"arm_spe driver doesn't advertise a min. interval. Using 4096\\n\");\n\t\tattr->sample_period = 4096;\n\t}\n\n\tarm_spe_pmu->selectable = true;\n\tarm_spe_pmu->is_uncore = false;\n\n\treturn attr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}