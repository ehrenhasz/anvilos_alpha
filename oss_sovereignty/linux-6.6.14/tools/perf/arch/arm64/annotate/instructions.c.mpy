{
  "module_name": "instructions.c",
  "hash_id": "5d7fc469a6ff86c348583bf5da5e3698a25270047521193db754b63c4f8743af",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/arm64/annotate/instructions.c",
  "human_readable_source": "\n#include <linux/compiler.h>\n#include <sys/types.h>\n#include <regex.h>\n#include <stdlib.h>\n\nstruct arm64_annotate {\n\tregex_t call_insn,\n\t\tjump_insn;\n};\n\nstatic int arm64_mov__parse(struct arch *arch __maybe_unused,\n\t\t\t    struct ins_operands *ops,\n\t\t\t    struct map_symbol *ms __maybe_unused)\n{\n\tchar *s = strchr(ops->raw, ','), *target, *endptr;\n\n\tif (s == NULL)\n\t\treturn -1;\n\n\t*s = '\\0';\n\tops->source.raw = strdup(ops->raw);\n\t*s = ',';\n\n\tif (ops->source.raw == NULL)\n\t\treturn -1;\n\n\ttarget = ++s;\n\tops->target.raw = strdup(target);\n\tif (ops->target.raw == NULL)\n\t\tgoto out_free_source;\n\n\tops->target.addr = strtoull(target, &endptr, 16);\n\tif (endptr == target)\n\t\tgoto out_free_target;\n\n\ts = strchr(endptr, '<');\n\tif (s == NULL)\n\t\tgoto out_free_target;\n\tendptr = strchr(s + 1, '>');\n\tif (endptr == NULL)\n\t\tgoto out_free_target;\n\n\t*endptr = '\\0';\n\t*s = ' ';\n\tops->target.name = strdup(s);\n\t*s = '<';\n\t*endptr = '>';\n\tif (ops->target.name == NULL)\n\t\tgoto out_free_target;\n\n\treturn 0;\n\nout_free_target:\n\tzfree(&ops->target.raw);\nout_free_source:\n\tzfree(&ops->source.raw);\n\treturn -1;\n}\n\nstatic int mov__scnprintf(struct ins *ins, char *bf, size_t size,\n\t\t\t  struct ins_operands *ops, int max_ins_name);\n\nstatic struct ins_ops arm64_mov_ops = {\n\t.parse\t   = arm64_mov__parse,\n\t.scnprintf = mov__scnprintf,\n};\n\nstatic struct ins_ops *arm64__associate_instruction_ops(struct arch *arch, const char *name)\n{\n\tstruct arm64_annotate *arm = arch->priv;\n\tstruct ins_ops *ops;\n\tregmatch_t match[2];\n\n\tif (!regexec(&arm->jump_insn, name, 2, match, 0))\n\t\tops = &jump_ops;\n\telse if (!regexec(&arm->call_insn, name, 2, match, 0))\n\t\tops = &call_ops;\n\telse if (!strcmp(name, \"ret\"))\n\t\tops = &ret_ops;\n\telse\n\t\tops = &arm64_mov_ops;\n\n\tarch__associate_ins_ops(arch, name, ops);\n\treturn ops;\n}\n\nstatic int arm64__annotate_init(struct arch *arch, char *cpuid __maybe_unused)\n{\n\tstruct arm64_annotate *arm;\n\tint err;\n\n\tif (arch->initialized)\n\t\treturn 0;\n\n\tarm = zalloc(sizeof(*arm));\n\tif (!arm)\n\t\treturn ENOMEM;\n\n\t \n\terr = regcomp(&arm->call_insn, \"^blr?$\", REG_EXTENDED);\n\tif (err)\n\t\tgoto out_free_arm;\n\t \n\terr = regcomp(&arm->jump_insn, \"^[ct]?br?\\\\.?(cc|cs|eq|ge|gt|hi|hs|le|lo|ls|lt|mi|ne|pl|vc|vs)?n?z?$\",\n\t\t      REG_EXTENDED);\n\tif (err)\n\t\tgoto out_free_call;\n\n\tarch->initialized = true;\n\tarch->priv\t  = arm;\n\tarch->associate_instruction_ops   = arm64__associate_instruction_ops;\n\tarch->objdump.comment_char\t  = '/';\n\tarch->objdump.skip_functions_char = '+';\n\treturn 0;\n\nout_free_call:\n\tregfree(&arm->call_insn);\nout_free_arm:\n\tfree(arm);\n\treturn SYMBOL_ANNOTATE_ERRNO__ARCH_INIT_REGEXP;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}