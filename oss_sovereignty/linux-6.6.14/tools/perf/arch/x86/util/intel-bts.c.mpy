{
  "module_name": "intel-bts.c",
  "hash_id": "6e0b3620022929e49d6c0b63735cb2411f0115bcf5eece941b9195bf7fb00e95",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/x86/util/intel-bts.c",
  "human_readable_source": "\n \n\n#include <errno.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/zalloc.h>\n\n#include \"../../../util/cpumap.h\"\n#include \"../../../util/event.h\"\n#include \"../../../util/evsel.h\"\n#include \"../../../util/evlist.h\"\n#include \"../../../util/mmap.h\"\n#include \"../../../util/session.h\"\n#include \"../../../util/pmus.h\"\n#include \"../../../util/debug.h\"\n#include \"../../../util/record.h\"\n#include \"../../../util/tsc.h\"\n#include \"../../../util/auxtrace.h\"\n#include \"../../../util/intel-bts.h\"\n#include <internal/lib.h> \n\n#define KiB(x) ((x) * 1024)\n#define MiB(x) ((x) * 1024 * 1024)\n#define KiB_MASK(x) (KiB(x) - 1)\n#define MiB_MASK(x) (MiB(x) - 1)\n\nstruct intel_bts_snapshot_ref {\n\tvoid\t*ref_buf;\n\tsize_t\tref_offset;\n\tbool\twrapped;\n};\n\nstruct intel_bts_recording {\n\tstruct auxtrace_record\t\titr;\n\tstruct perf_pmu\t\t\t*intel_bts_pmu;\n\tstruct evlist\t\t*evlist;\n\tbool\t\t\t\tsnapshot_mode;\n\tsize_t\t\t\t\tsnapshot_size;\n\tint\t\t\t\tsnapshot_ref_cnt;\n\tstruct intel_bts_snapshot_ref\t*snapshot_refs;\n};\n\nstruct branch {\n\tu64 from;\n\tu64 to;\n\tu64 misc;\n};\n\nstatic size_t\nintel_bts_info_priv_size(struct auxtrace_record *itr __maybe_unused,\n\t\t\t struct evlist *evlist __maybe_unused)\n{\n\treturn INTEL_BTS_AUXTRACE_PRIV_SIZE;\n}\n\nstatic int intel_bts_info_fill(struct auxtrace_record *itr,\n\t\t\t       struct perf_session *session,\n\t\t\t       struct perf_record_auxtrace_info *auxtrace_info,\n\t\t\t       size_t priv_size)\n{\n\tstruct intel_bts_recording *btsr =\n\t\t\tcontainer_of(itr, struct intel_bts_recording, itr);\n\tstruct perf_pmu *intel_bts_pmu = btsr->intel_bts_pmu;\n\tstruct perf_event_mmap_page *pc;\n\tstruct perf_tsc_conversion tc = { .time_mult = 0, };\n\tbool cap_user_time_zero = false;\n\tint err;\n\n\tif (priv_size != INTEL_BTS_AUXTRACE_PRIV_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!session->evlist->core.nr_mmaps)\n\t\treturn -EINVAL;\n\n\tpc = session->evlist->mmap[0].core.base;\n\tif (pc) {\n\t\terr = perf_read_tsc_conversion(pc, &tc);\n\t\tif (err) {\n\t\t\tif (err != -EOPNOTSUPP)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tcap_user_time_zero = tc.time_mult != 0;\n\t\t}\n\t\tif (!cap_user_time_zero)\n\t\t\tui__warning(\"Intel BTS: TSC not available\\n\");\n\t}\n\n\tauxtrace_info->type = PERF_AUXTRACE_INTEL_BTS;\n\tauxtrace_info->priv[INTEL_BTS_PMU_TYPE] = intel_bts_pmu->type;\n\tauxtrace_info->priv[INTEL_BTS_TIME_SHIFT] = tc.time_shift;\n\tauxtrace_info->priv[INTEL_BTS_TIME_MULT] = tc.time_mult;\n\tauxtrace_info->priv[INTEL_BTS_TIME_ZERO] = tc.time_zero;\n\tauxtrace_info->priv[INTEL_BTS_CAP_USER_TIME_ZERO] = cap_user_time_zero;\n\tauxtrace_info->priv[INTEL_BTS_SNAPSHOT_MODE] = btsr->snapshot_mode;\n\n\treturn 0;\n}\n\nstatic int intel_bts_recording_options(struct auxtrace_record *itr,\n\t\t\t\t       struct evlist *evlist,\n\t\t\t\t       struct record_opts *opts)\n{\n\tstruct intel_bts_recording *btsr =\n\t\t\tcontainer_of(itr, struct intel_bts_recording, itr);\n\tstruct perf_pmu *intel_bts_pmu = btsr->intel_bts_pmu;\n\tstruct evsel *evsel, *intel_bts_evsel = NULL;\n\tconst struct perf_cpu_map *cpus = evlist->core.user_requested_cpus;\n\tbool privileged = perf_event_paranoid_check(-1);\n\n\tif (opts->auxtrace_sample_mode) {\n\t\tpr_err(\"Intel BTS does not support AUX area sampling\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtsr->evlist = evlist;\n\tbtsr->snapshot_mode = opts->auxtrace_snapshot_mode;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type == intel_bts_pmu->type) {\n\t\t\tif (intel_bts_evsel) {\n\t\t\t\tpr_err(\"There may be only one \" INTEL_BTS_PMU_NAME \" event\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tevsel->core.attr.freq = 0;\n\t\t\tevsel->core.attr.sample_period = 1;\n\t\t\tevsel->needs_auxtrace_mmap = true;\n\t\t\tintel_bts_evsel = evsel;\n\t\t\topts->full_auxtrace = true;\n\t\t}\n\t}\n\n\tif (opts->auxtrace_snapshot_mode && !opts->full_auxtrace) {\n\t\tpr_err(\"Snapshot mode (-S option) requires \" INTEL_BTS_PMU_NAME \" PMU event (-e \" INTEL_BTS_PMU_NAME \")\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!opts->full_auxtrace)\n\t\treturn 0;\n\n\tif (opts->full_auxtrace && !perf_cpu_map__empty(cpus)) {\n\t\tpr_err(INTEL_BTS_PMU_NAME \" does not support per-cpu recording\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (opts->auxtrace_snapshot_mode) {\n\t\tif (!opts->auxtrace_snapshot_size && !opts->auxtrace_mmap_pages) {\n\t\t\tif (privileged) {\n\t\t\t\topts->auxtrace_mmap_pages = MiB(4) / page_size;\n\t\t\t} else {\n\t\t\t\topts->auxtrace_mmap_pages = KiB(128) / page_size;\n\t\t\t\tif (opts->mmap_pages == UINT_MAX)\n\t\t\t\t\topts->mmap_pages = KiB(256) / page_size;\n\t\t\t}\n\t\t} else if (!opts->auxtrace_mmap_pages && !privileged &&\n\t\t\t   opts->mmap_pages == UINT_MAX) {\n\t\t\topts->mmap_pages = KiB(256) / page_size;\n\t\t}\n\t\tif (!opts->auxtrace_snapshot_size)\n\t\t\topts->auxtrace_snapshot_size =\n\t\t\t\topts->auxtrace_mmap_pages * (size_t)page_size;\n\t\tif (!opts->auxtrace_mmap_pages) {\n\t\t\tsize_t sz = opts->auxtrace_snapshot_size;\n\n\t\t\tsz = round_up(sz, page_size) / page_size;\n\t\t\topts->auxtrace_mmap_pages = roundup_pow_of_two(sz);\n\t\t}\n\t\tif (opts->auxtrace_snapshot_size >\n\t\t\t\topts->auxtrace_mmap_pages * (size_t)page_size) {\n\t\t\tpr_err(\"Snapshot size %zu must not be greater than AUX area tracing mmap size %zu\\n\",\n\t\t\t       opts->auxtrace_snapshot_size,\n\t\t\t       opts->auxtrace_mmap_pages * (size_t)page_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!opts->auxtrace_snapshot_size || !opts->auxtrace_mmap_pages) {\n\t\t\tpr_err(\"Failed to calculate default snapshot size and/or AUX area tracing mmap pages\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpr_debug2(\"Intel BTS snapshot size: %zu\\n\",\n\t\t\t  opts->auxtrace_snapshot_size);\n\t}\n\n\t \n\tif (opts->full_auxtrace && !opts->auxtrace_mmap_pages) {\n\t\tif (privileged) {\n\t\t\topts->auxtrace_mmap_pages = MiB(4) / page_size;\n\t\t} else {\n\t\t\topts->auxtrace_mmap_pages = KiB(128) / page_size;\n\t\t\tif (opts->mmap_pages == UINT_MAX)\n\t\t\t\topts->mmap_pages = KiB(256) / page_size;\n\t\t}\n\t}\n\n\t \n\tif (opts->auxtrace_mmap_pages) {\n\t\tsize_t sz = opts->auxtrace_mmap_pages * (size_t)page_size;\n\t\tsize_t min_sz;\n\n\t\tif (opts->auxtrace_snapshot_mode)\n\t\t\tmin_sz = KiB(4);\n\t\telse\n\t\t\tmin_sz = KiB(8);\n\n\t\tif (sz < min_sz || !is_power_of_2(sz)) {\n\t\t\tpr_err(\"Invalid mmap size for Intel BTS: must be at least %zuKiB and a power of 2\\n\",\n\t\t\t       min_sz / 1024);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (intel_bts_evsel) {\n\t\t \n\t\tevlist__to_front(evlist, intel_bts_evsel);\n\t\t \n\t\tif (!perf_cpu_map__empty(cpus))\n\t\t\tevsel__set_sample_bit(intel_bts_evsel, CPU);\n\t}\n\n\t \n\tif (opts->full_auxtrace) {\n\t\tstruct evsel *tracking_evsel;\n\t\tint err;\n\n\t\terr = parse_event(evlist, \"dummy:u\");\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttracking_evsel = evlist__last(evlist);\n\n\t\tevlist__set_tracking_event(evlist, tracking_evsel);\n\n\t\ttracking_evsel->core.attr.freq = 0;\n\t\ttracking_evsel->core.attr.sample_period = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_bts_parse_snapshot_options(struct auxtrace_record *itr,\n\t\t\t\t\t    struct record_opts *opts,\n\t\t\t\t\t    const char *str)\n{\n\tstruct intel_bts_recording *btsr =\n\t\t\tcontainer_of(itr, struct intel_bts_recording, itr);\n\tunsigned long long snapshot_size = 0;\n\tchar *endptr;\n\n\tif (str) {\n\t\tsnapshot_size = strtoull(str, &endptr, 0);\n\t\tif (*endptr || snapshot_size > SIZE_MAX)\n\t\t\treturn -1;\n\t}\n\n\topts->auxtrace_snapshot_mode = true;\n\topts->auxtrace_snapshot_size = snapshot_size;\n\n\tbtsr->snapshot_size = snapshot_size;\n\n\treturn 0;\n}\n\nstatic u64 intel_bts_reference(struct auxtrace_record *itr __maybe_unused)\n{\n\treturn rdtsc();\n}\n\nstatic int intel_bts_alloc_snapshot_refs(struct intel_bts_recording *btsr,\n\t\t\t\t\t int idx)\n{\n\tconst size_t sz = sizeof(struct intel_bts_snapshot_ref);\n\tint cnt = btsr->snapshot_ref_cnt, new_cnt = cnt * 2;\n\tstruct intel_bts_snapshot_ref *refs;\n\n\tif (!new_cnt)\n\t\tnew_cnt = 16;\n\n\twhile (new_cnt <= idx)\n\t\tnew_cnt *= 2;\n\n\trefs = calloc(new_cnt, sz);\n\tif (!refs)\n\t\treturn -ENOMEM;\n\n\tmemcpy(refs, btsr->snapshot_refs, cnt * sz);\n\n\tbtsr->snapshot_refs = refs;\n\tbtsr->snapshot_ref_cnt = new_cnt;\n\n\treturn 0;\n}\n\nstatic void intel_bts_free_snapshot_refs(struct intel_bts_recording *btsr)\n{\n\tint i;\n\n\tfor (i = 0; i < btsr->snapshot_ref_cnt; i++)\n\t\tzfree(&btsr->snapshot_refs[i].ref_buf);\n\tzfree(&btsr->snapshot_refs);\n}\n\nstatic void intel_bts_recording_free(struct auxtrace_record *itr)\n{\n\tstruct intel_bts_recording *btsr =\n\t\t\tcontainer_of(itr, struct intel_bts_recording, itr);\n\n\tintel_bts_free_snapshot_refs(btsr);\n\tfree(btsr);\n}\n\nstatic int intel_bts_snapshot_start(struct auxtrace_record *itr)\n{\n\tstruct intel_bts_recording *btsr =\n\t\t\tcontainer_of(itr, struct intel_bts_recording, itr);\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(btsr->evlist, evsel) {\n\t\tif (evsel->core.attr.type == btsr->intel_bts_pmu->type)\n\t\t\treturn evsel__disable(evsel);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int intel_bts_snapshot_finish(struct auxtrace_record *itr)\n{\n\tstruct intel_bts_recording *btsr =\n\t\t\tcontainer_of(itr, struct intel_bts_recording, itr);\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(btsr->evlist, evsel) {\n\t\tif (evsel->core.attr.type == btsr->intel_bts_pmu->type)\n\t\t\treturn evsel__enable(evsel);\n\t}\n\treturn -EINVAL;\n}\n\nstatic bool intel_bts_first_wrap(u64 *data, size_t buf_size)\n{\n\tint i, a, b;\n\n\tb = buf_size >> 3;\n\ta = b - 512;\n\tif (a < 0)\n\t\ta = 0;\n\n\tfor (i = a; i < b; i++) {\n\t\tif (data[i])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int intel_bts_find_snapshot(struct auxtrace_record *itr, int idx,\n\t\t\t\t   struct auxtrace_mmap *mm, unsigned char *data,\n\t\t\t\t   u64 *head, u64 *old)\n{\n\tstruct intel_bts_recording *btsr =\n\t\t\tcontainer_of(itr, struct intel_bts_recording, itr);\n\tbool wrapped;\n\tint err;\n\n\tpr_debug3(\"%s: mmap index %d old head %zu new head %zu\\n\",\n\t\t  __func__, idx, (size_t)*old, (size_t)*head);\n\n\tif (idx >= btsr->snapshot_ref_cnt) {\n\t\terr = intel_bts_alloc_snapshot_refs(btsr, idx);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\twrapped = btsr->snapshot_refs[idx].wrapped;\n\tif (!wrapped && intel_bts_first_wrap((u64 *)data, mm->len)) {\n\t\tbtsr->snapshot_refs[idx].wrapped = true;\n\t\twrapped = true;\n\t}\n\n\t \n\tif (wrapped) {\n\t\t*old = *head;\n\t\t*head += mm->len;\n\t} else {\n\t\tif (mm->mask)\n\t\t\t*old &= mm->mask;\n\t\telse\n\t\t\t*old %= mm->len;\n\t\tif (*old > *head)\n\t\t\t*head += mm->len;\n\t}\n\n\tpr_debug3(\"%s: wrap-around %sdetected, adjusted old head %zu adjusted new head %zu\\n\",\n\t\t  __func__, wrapped ? \"\" : \"not \", (size_t)*old, (size_t)*head);\n\n\treturn 0;\n\nout_err:\n\tpr_err(\"%s: failed, error %d\\n\", __func__, err);\n\treturn err;\n}\n\nstruct auxtrace_record *intel_bts_recording_init(int *err)\n{\n\tstruct perf_pmu *intel_bts_pmu = perf_pmus__find(INTEL_BTS_PMU_NAME);\n\tstruct intel_bts_recording *btsr;\n\n\tif (!intel_bts_pmu)\n\t\treturn NULL;\n\n\tif (setenv(\"JITDUMP_USE_ARCH_TIMESTAMP\", \"1\", 1)) {\n\t\t*err = -errno;\n\t\treturn NULL;\n\t}\n\n\tbtsr = zalloc(sizeof(struct intel_bts_recording));\n\tif (!btsr) {\n\t\t*err = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tbtsr->intel_bts_pmu = intel_bts_pmu;\n\tbtsr->itr.pmu = intel_bts_pmu;\n\tbtsr->itr.recording_options = intel_bts_recording_options;\n\tbtsr->itr.info_priv_size = intel_bts_info_priv_size;\n\tbtsr->itr.info_fill = intel_bts_info_fill;\n\tbtsr->itr.free = intel_bts_recording_free;\n\tbtsr->itr.snapshot_start = intel_bts_snapshot_start;\n\tbtsr->itr.snapshot_finish = intel_bts_snapshot_finish;\n\tbtsr->itr.find_snapshot = intel_bts_find_snapshot;\n\tbtsr->itr.parse_snapshot_options = intel_bts_parse_snapshot_options;\n\tbtsr->itr.reference = intel_bts_reference;\n\tbtsr->itr.read_finish = auxtrace_record__read_finish;\n\tbtsr->itr.alignment = sizeof(struct branch);\n\treturn &btsr->itr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}