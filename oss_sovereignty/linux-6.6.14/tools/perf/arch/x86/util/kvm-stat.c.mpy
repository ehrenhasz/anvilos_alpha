{
  "module_name": "kvm-stat.c",
  "hash_id": "4c858b4c9b48eea21beae7e2fcaf915f8d4589faf33583d21250580bf668e289",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/x86/util/kvm-stat.c",
  "human_readable_source": "\n#include <errno.h>\n#include <string.h>\n#include \"../../../util/kvm-stat.h\"\n#include \"../../../util/evsel.h\"\n#include <asm/svm.h>\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n\ndefine_exit_reasons_table(vmx_exit_reasons, VMX_EXIT_REASONS);\ndefine_exit_reasons_table(svm_exit_reasons, SVM_EXIT_REASONS);\n\nstatic struct kvm_events_ops exit_events = {\n\t.is_begin_event = exit_event_begin,\n\t.is_end_event = exit_event_end,\n\t.decode_key = exit_event_decode_key,\n\t.name = \"VM-EXIT\"\n};\n\nconst char *vcpu_id_str = \"vcpu_id\";\nconst char *kvm_exit_reason = \"exit_reason\";\nconst char *kvm_entry_trace = \"kvm:kvm_entry\";\nconst char *kvm_exit_trace = \"kvm:kvm_exit\";\n\n \nstatic void mmio_event_get_key(struct evsel *evsel, struct perf_sample *sample,\n\t\t\t       struct event_key *key)\n{\n\tkey->key  = evsel__intval(evsel, sample, \"gpa\");\n\tkey->info = evsel__intval(evsel, sample, \"type\");\n}\n\n#define KVM_TRACE_MMIO_READ_UNSATISFIED 0\n#define KVM_TRACE_MMIO_READ 1\n#define KVM_TRACE_MMIO_WRITE 2\n\nstatic bool mmio_event_begin(struct evsel *evsel,\n\t\t\t     struct perf_sample *sample, struct event_key *key)\n{\n\t \n\tif (kvm_exit_event(evsel))\n\t\treturn true;\n\n\t \n\tif (evsel__name_is(evsel, \"kvm:kvm_mmio\") &&\n\t    evsel__intval(evsel, sample, \"type\") == KVM_TRACE_MMIO_WRITE) {\n\t\tmmio_event_get_key(evsel, sample, key);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool mmio_event_end(struct evsel *evsel, struct perf_sample *sample,\n\t\t\t   struct event_key *key)\n{\n\t \n\tif (kvm_entry_event(evsel))\n\t\treturn true;\n\n\t \n\tif (evsel__name_is(evsel, \"kvm:kvm_mmio\") &&\n\t    evsel__intval(evsel, sample, \"type\") == KVM_TRACE_MMIO_READ) {\n\t\tmmio_event_get_key(evsel, sample, key);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void mmio_event_decode_key(struct perf_kvm_stat *kvm __maybe_unused,\n\t\t\t\t  struct event_key *key,\n\t\t\t\t  char *decode)\n{\n\tscnprintf(decode, KVM_EVENT_NAME_LEN, \"%#lx:%s\",\n\t\t  (unsigned long)key->key,\n\t\t  key->info == KVM_TRACE_MMIO_WRITE ? \"W\" : \"R\");\n}\n\nstatic struct kvm_events_ops mmio_events = {\n\t.is_begin_event = mmio_event_begin,\n\t.is_end_event = mmio_event_end,\n\t.decode_key = mmio_event_decode_key,\n\t.name = \"MMIO Access\"\n};\n\n  \nstatic void ioport_event_get_key(struct evsel *evsel,\n\t\t\t\t struct perf_sample *sample,\n\t\t\t\t struct event_key *key)\n{\n\tkey->key  = evsel__intval(evsel, sample, \"port\");\n\tkey->info = evsel__intval(evsel, sample, \"rw\");\n}\n\nstatic bool ioport_event_begin(struct evsel *evsel,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       struct event_key *key)\n{\n\tif (evsel__name_is(evsel, \"kvm:kvm_pio\")) {\n\t\tioport_event_get_key(evsel, sample, key);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool ioport_event_end(struct evsel *evsel,\n\t\t\t     struct perf_sample *sample __maybe_unused,\n\t\t\t     struct event_key *key __maybe_unused)\n{\n\treturn kvm_entry_event(evsel);\n}\n\nstatic void ioport_event_decode_key(struct perf_kvm_stat *kvm __maybe_unused,\n\t\t\t\t    struct event_key *key,\n\t\t\t\t    char *decode)\n{\n\tscnprintf(decode, KVM_EVENT_NAME_LEN, \"%#llx:%s\",\n\t\t  (unsigned long long)key->key,\n\t\t  key->info ? \"POUT\" : \"PIN\");\n}\n\nstatic struct kvm_events_ops ioport_events = {\n\t.is_begin_event = ioport_event_begin,\n\t.is_end_event = ioport_event_end,\n\t.decode_key = ioport_event_decode_key,\n\t.name = \"IO Port Access\"\n};\n\n  \nstatic void msr_event_get_key(struct evsel *evsel,\n\t\t\t\t struct perf_sample *sample,\n\t\t\t\t struct event_key *key)\n{\n\tkey->key  = evsel__intval(evsel, sample, \"ecx\");\n\tkey->info = evsel__intval(evsel, sample, \"write\");\n}\n\nstatic bool msr_event_begin(struct evsel *evsel,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       struct event_key *key)\n{\n\tif (evsel__name_is(evsel, \"kvm:kvm_msr\")) {\n\t\tmsr_event_get_key(evsel, sample, key);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool msr_event_end(struct evsel *evsel,\n\t\t\t     struct perf_sample *sample __maybe_unused,\n\t\t\t     struct event_key *key __maybe_unused)\n{\n\treturn kvm_entry_event(evsel);\n}\n\nstatic void msr_event_decode_key(struct perf_kvm_stat *kvm __maybe_unused,\n\t\t\t\t    struct event_key *key,\n\t\t\t\t    char *decode)\n{\n\tscnprintf(decode, KVM_EVENT_NAME_LEN, \"%#llx:%s\",\n\t\t  (unsigned long long)key->key,\n\t\t  key->info ? \"W\" : \"R\");\n}\n\nstatic struct kvm_events_ops msr_events = {\n\t.is_begin_event = msr_event_begin,\n\t.is_end_event = msr_event_end,\n\t.decode_key = msr_event_decode_key,\n\t.name = \"MSR Access\"\n};\n\nconst char *kvm_events_tp[] = {\n\t\"kvm:kvm_entry\",\n\t\"kvm:kvm_exit\",\n\t\"kvm:kvm_mmio\",\n\t\"kvm:kvm_pio\",\n\t\"kvm:kvm_msr\",\n\tNULL,\n};\n\nstruct kvm_reg_events_ops kvm_reg_events_ops[] = {\n\t{ .name = \"vmexit\", .ops = &exit_events },\n\t{ .name = \"mmio\", .ops = &mmio_events },\n\t{ .name = \"ioport\", .ops = &ioport_events },\n\t{ .name = \"msr\", .ops = &msr_events },\n\t{ NULL, NULL },\n};\n\nconst char * const kvm_skip_events[] = {\n\t\"HLT\",\n\tNULL,\n};\n\nint cpu_isa_init(struct perf_kvm_stat *kvm, const char *cpuid)\n{\n\tif (strstr(cpuid, \"Intel\")) {\n\t\tkvm->exit_reasons = vmx_exit_reasons;\n\t\tkvm->exit_reasons_isa = \"VMX\";\n\t} else if (strstr(cpuid, \"AMD\") || strstr(cpuid, \"Hygon\")) {\n\t\tkvm->exit_reasons = svm_exit_reasons;\n\t\tkvm->exit_reasons_isa = \"SVM\";\n\t} else\n\t\treturn -ENOTSUP;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}