{
  "module_name": "iostat.c",
  "hash_id": "3a8b7eba1e759ed9a869e2afc4f411bc3eeb90a217988975c365f74cea01eeb5",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/x86/util/iostat.c",
  "human_readable_source": "\n \n\n#include <api/fs/fs.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/zalloc.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <regex.h>\n#include \"util/cpumap.h\"\n#include \"util/debug.h\"\n#include \"util/iostat.h\"\n#include \"util/counts.h\"\n#include \"path.h\"\n\n#ifndef MAX_PATH\n#define MAX_PATH 1024\n#endif\n\n#define UNCORE_IIO_PMU_PATH\t\"devices/uncore_iio_%d\"\n#define SYSFS_UNCORE_PMU_PATH\t\"%s/\"UNCORE_IIO_PMU_PATH\n#define PLATFORM_MAPPING_PATH\tUNCORE_IIO_PMU_PATH\"/die%d\"\n\n \nstatic const char * const iostat_metrics[] = {\n\t\"Inbound Read(MB)\",\n\t\"Inbound Write(MB)\",\n\t\"Outbound Read(MB)\",\n\t\"Outbound Write(MB)\",\n};\n\nstatic inline int iostat_metrics_count(void)\n{\n\treturn sizeof(iostat_metrics) / sizeof(char *);\n}\n\nstatic const char *iostat_metric_by_idx(int idx)\n{\n\treturn *(iostat_metrics + idx % iostat_metrics_count());\n}\n\nstruct iio_root_port {\n\tu32 domain;\n\tu8 bus;\n\tu8 die;\n\tu8 pmu_idx;\n\tint idx;\n};\n\nstruct iio_root_ports_list {\n\tstruct iio_root_port **rps;\n\tint nr_entries;\n};\n\nstatic struct iio_root_ports_list *root_ports;\n\nstatic void iio_root_port_show(FILE *output,\n\t\t\t       const struct iio_root_port * const rp)\n{\n\tif (output && rp)\n\t\tfprintf(output, \"S%d-uncore_iio_%d<%04x:%02x>\\n\",\n\t\t\trp->die, rp->pmu_idx, rp->domain, rp->bus);\n}\n\nstatic struct iio_root_port *iio_root_port_new(u32 domain, u8 bus,\n\t\t\t\t\t       u8 die, u8 pmu_idx)\n{\n\tstruct iio_root_port *p = calloc(1, sizeof(*p));\n\n\tif (p) {\n\t\tp->domain = domain;\n\t\tp->bus = bus;\n\t\tp->die = die;\n\t\tp->pmu_idx = pmu_idx;\n\t}\n\treturn p;\n}\n\nstatic void iio_root_ports_list_free(struct iio_root_ports_list *list)\n{\n\tint idx;\n\n\tif (list) {\n\t\tfor (idx = 0; idx < list->nr_entries; idx++)\n\t\t\tzfree(&list->rps[idx]);\n\t\tzfree(&list->rps);\n\t\tfree(list);\n\t}\n}\n\nstatic struct iio_root_port *iio_root_port_find_by_notation(\n\tconst struct iio_root_ports_list * const list, u32 domain, u8 bus)\n{\n\tint idx;\n\tstruct iio_root_port *rp;\n\n\tif (list) {\n\t\tfor (idx = 0; idx < list->nr_entries; idx++) {\n\t\t\trp = list->rps[idx];\n\t\t\tif (rp && rp->domain == domain && rp->bus == bus)\n\t\t\t\treturn rp;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int iio_root_ports_list_insert(struct iio_root_ports_list *list,\n\t\t\t\t      struct iio_root_port * const rp)\n{\n\tstruct iio_root_port **tmp_buf;\n\n\tif (list && rp) {\n\t\trp->idx = list->nr_entries++;\n\t\ttmp_buf = realloc(list->rps,\n\t\t\t\t  list->nr_entries * sizeof(*list->rps));\n\t\tif (!tmp_buf) {\n\t\t\tpr_err(\"Failed to realloc memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\ttmp_buf[rp->idx] = rp;\n\t\tlist->rps = tmp_buf;\n\t}\n\treturn 0;\n}\n\nstatic int iio_mapping(u8 pmu_idx, struct iio_root_ports_list * const list)\n{\n\tchar *buf;\n\tchar path[MAX_PATH];\n\tu32 domain;\n\tu8 bus;\n\tstruct iio_root_port *rp;\n\tsize_t size;\n\tint ret;\n\n\tfor (int die = 0; die < cpu__max_node(); die++) {\n\t\tscnprintf(path, MAX_PATH, PLATFORM_MAPPING_PATH, pmu_idx, die);\n\t\tif (sysfs__read_str(path, &buf, &size) < 0) {\n\t\t\tif (pmu_idx)\n\t\t\t\tgoto out;\n\t\t\tpr_err(\"Mode iostat is not supported\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tret = sscanf(buf, \"%04x:%02hhx\", &domain, &bus);\n\t\tfree(buf);\n\t\tif (ret != 2) {\n\t\t\tpr_err(\"Invalid mapping data: iio_%d; die%d\\n\",\n\t\t\t       pmu_idx, die);\n\t\t\treturn -1;\n\t\t}\n\t\trp = iio_root_port_new(domain, bus, die, pmu_idx);\n\t\tif (!rp || iio_root_ports_list_insert(list, rp)) {\n\t\t\tfree(rp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\nout:\n\treturn 0;\n}\n\nstatic u8 iio_pmu_count(void)\n{\n\tu8 pmu_idx = 0;\n\tchar path[MAX_PATH];\n\tconst char *sysfs = sysfs__mountpoint();\n\n\tif (sysfs) {\n\t\tfor (;; pmu_idx++) {\n\t\t\tsnprintf(path, sizeof(path), SYSFS_UNCORE_PMU_PATH,\n\t\t\t\t sysfs, pmu_idx);\n\t\t\tif (access(path, F_OK) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn pmu_idx;\n}\n\nstatic int iio_root_ports_scan(struct iio_root_ports_list **list)\n{\n\tint ret = -ENOMEM;\n\tstruct iio_root_ports_list *tmp_list;\n\tu8 pmu_count = iio_pmu_count();\n\n\tif (!pmu_count) {\n\t\tpr_err(\"Unsupported uncore pmu configuration\\n\");\n\t\treturn -1;\n\t}\n\n\ttmp_list = calloc(1, sizeof(*tmp_list));\n\tif (!tmp_list)\n\t\tgoto err;\n\n\tfor (u8 pmu_idx = 0; pmu_idx < pmu_count; pmu_idx++) {\n\t\tret = iio_mapping(pmu_idx, tmp_list);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nerr:\n\tif (!ret)\n\t\t*list = tmp_list;\n\telse\n\t\tiio_root_ports_list_free(tmp_list);\n\n\treturn ret;\n}\n\nstatic int iio_root_port_parse_str(u32 *domain, u8 *bus, char *str)\n{\n\tint ret;\n\tregex_t regex;\n\t \n\tregcomp(&regex, \"^([a-f0-9A-F]{1,}):([a-f0-9A-F]{1,2})\", REG_EXTENDED);\n\tret = regexec(&regex, str, 0, NULL, 0);\n\tif (ret || sscanf(str, \"%08x:%02hhx\", domain, bus) != 2)\n\t\tpr_warning(\"Unrecognized root port format: %s\\n\"\n\t\t\t   \"Please use the following format:\\n\"\n\t\t\t   \"\\t [domain]:[bus]\\n\"\n\t\t\t   \"\\t for example: 0000:3d\\n\", str);\n\n\tregfree(&regex);\n\treturn ret;\n}\n\nstatic int iio_root_ports_list_filter(struct iio_root_ports_list **list,\n\t\t\t\t      const char *filter)\n{\n\tchar *tok, *tmp, *filter_copy = NULL;\n\tstruct iio_root_port *rp;\n\tu32 domain;\n\tu8 bus;\n\tint ret = -ENOMEM;\n\tstruct iio_root_ports_list *tmp_list = calloc(1, sizeof(*tmp_list));\n\n\tif (!tmp_list)\n\t\tgoto err;\n\n\tfilter_copy = strdup(filter);\n\tif (!filter_copy)\n\t\tgoto err;\n\n\tfor (tok = strtok_r(filter_copy, \",\", &tmp); tok;\n\t     tok = strtok_r(NULL, \",\", &tmp)) {\n\t\tif (!iio_root_port_parse_str(&domain, &bus, tok)) {\n\t\t\trp = iio_root_port_find_by_notation(*list, domain, bus);\n\t\t\tif (rp) {\n\t\t\t\t(*list)->rps[rp->idx] = NULL;\n\t\t\t\tret = iio_root_ports_list_insert(tmp_list, rp);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree(rp);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t} else if (!iio_root_port_find_by_notation(tmp_list,\n\t\t\t\t\t\t\t\t   domain, bus))\n\t\t\t\tpr_warning(\"Root port %04x:%02x were not found\\n\",\n\t\t\t\t\t   domain, bus);\n\t\t}\n\t}\n\n\tif (tmp_list->nr_entries == 0) {\n\t\tpr_err(\"Requested root ports were not found\\n\");\n\t\tret = -EINVAL;\n\t}\nerr:\n\tiio_root_ports_list_free(*list);\n\tif (ret)\n\t\tiio_root_ports_list_free(tmp_list);\n\telse\n\t\t*list = tmp_list;\n\n\tfree(filter_copy);\n\treturn ret;\n}\n\nstatic int iostat_event_group(struct evlist *evl,\n\t\t\t      struct iio_root_ports_list *list)\n{\n\tint ret;\n\tint idx;\n\tconst char *iostat_cmd_template =\n\t\"{uncore_iio_%x/event=0x83,umask=0x04,ch_mask=0xF,fc_mask=0x07/,\\\n\t  uncore_iio_%x/event=0x83,umask=0x01,ch_mask=0xF,fc_mask=0x07/,\\\n\t  uncore_iio_%x/event=0xc0,umask=0x04,ch_mask=0xF,fc_mask=0x07/,\\\n\t  uncore_iio_%x/event=0xc0,umask=0x01,ch_mask=0xF,fc_mask=0x07/}\";\n\tconst int len_template = strlen(iostat_cmd_template) + 1;\n\tstruct evsel *evsel = NULL;\n\tint metrics_count = iostat_metrics_count();\n\tchar *iostat_cmd = calloc(len_template, 1);\n\n\tif (!iostat_cmd)\n\t\treturn -ENOMEM;\n\n\tfor (idx = 0; idx < list->nr_entries; idx++) {\n\t\tsprintf(iostat_cmd, iostat_cmd_template,\n\t\t\tlist->rps[idx]->pmu_idx, list->rps[idx]->pmu_idx,\n\t\t\tlist->rps[idx]->pmu_idx, list->rps[idx]->pmu_idx);\n\t\tret = parse_event(evl, iostat_cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tevlist__for_each_entry(evl, evsel) {\n\t\tevsel->priv = list->rps[evsel->core.idx / metrics_count];\n\t}\n\tlist->nr_entries = 0;\nerr:\n\tiio_root_ports_list_free(list);\n\tfree(iostat_cmd);\n\treturn ret;\n}\n\nint iostat_prepare(struct evlist *evlist, struct perf_stat_config *config)\n{\n\tif (evlist->core.nr_entries > 0) {\n\t\tpr_warning(\"The -e and -M options are not supported.\"\n\t\t\t   \"All chosen events/metrics will be dropped\\n\");\n\t\tevlist__delete(evlist);\n\t\tevlist = evlist__new();\n\t\tif (!evlist)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tconfig->metric_only = true;\n\tconfig->aggr_mode = AGGR_GLOBAL;\n\n\treturn iostat_event_group(evlist, root_ports);\n}\n\nint iostat_parse(const struct option *opt, const char *str,\n\t\t int unset __maybe_unused)\n{\n\tint ret;\n\tstruct perf_stat_config *config = (struct perf_stat_config *)opt->data;\n\n\tret = iio_root_ports_scan(&root_ports);\n\tif (!ret) {\n\t\tconfig->iostat_run = true;\n\t\tif (!str)\n\t\t\tiostat_mode = IOSTAT_RUN;\n\t\telse if (!strcmp(str, \"list\"))\n\t\t\tiostat_mode = IOSTAT_LIST;\n\t\telse {\n\t\t\tiostat_mode = IOSTAT_RUN;\n\t\t\tret = iio_root_ports_list_filter(&root_ports, str);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid iostat_list(struct evlist *evlist, struct perf_stat_config *config)\n{\n\tstruct evsel *evsel;\n\tstruct iio_root_port *rp = NULL;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (rp != evsel->priv) {\n\t\t\trp = evsel->priv;\n\t\t\tiio_root_port_show(config->output, rp);\n\t\t}\n\t}\n}\n\nvoid iostat_release(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\tstruct iio_root_port *rp = NULL;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (rp != evsel->priv) {\n\t\t\trp = evsel->priv;\n\t\t\tzfree(&evsel->priv);\n\t\t}\n\t}\n}\n\nvoid iostat_prefix(struct evlist *evlist,\n\t\t   struct perf_stat_config *config,\n\t\t   char *prefix, struct timespec *ts)\n{\n\tstruct iio_root_port *rp = evlist->selected->priv;\n\n\tif (rp) {\n\t\tif (ts)\n\t\t\tsprintf(prefix, \"%6lu.%09lu%s%04x:%02x%s\",\n\t\t\t\tts->tv_sec, ts->tv_nsec,\n\t\t\t\tconfig->csv_sep, rp->domain, rp->bus,\n\t\t\t\tconfig->csv_sep);\n\t\telse\n\t\t\tsprintf(prefix, \"%04x:%02x%s\", rp->domain, rp->bus,\n\t\t\t\tconfig->csv_sep);\n\t}\n}\n\nvoid iostat_print_header_prefix(struct perf_stat_config *config)\n{\n\tif (config->csv_output)\n\t\tfputs(\"port,\", config->output);\n\telse if (config->interval)\n\t\tfprintf(config->output, \"#          time    port         \");\n\telse\n\t\tfprintf(config->output, \"   port         \");\n}\n\nvoid iostat_print_metric(struct perf_stat_config *config, struct evsel *evsel,\n\t\t\t struct perf_stat_output_ctx *out)\n{\n\tdouble iostat_value = 0;\n\tu64 prev_count_val = 0;\n\tconst char *iostat_metric = iostat_metric_by_idx(evsel->core.idx);\n\tu8 die = ((struct iio_root_port *)evsel->priv)->die;\n\tstruct perf_counts_values *count = perf_counts(evsel->counts, die, 0);\n\n\tif (count && count->run && count->ena) {\n\t\tif (evsel->prev_raw_counts && !out->force_header) {\n\t\t\tstruct perf_counts_values *prev_count =\n\t\t\t\tperf_counts(evsel->prev_raw_counts, die, 0);\n\n\t\t\tprev_count_val = prev_count->val;\n\t\t\tprev_count->val = count->val;\n\t\t}\n\t\tiostat_value = (count->val - prev_count_val) /\n\t\t\t       ((double) count->run / count->ena);\n\t}\n\tout->print_metric(config, out->ctx, NULL, \"%8.0f\", iostat_metric,\n\t\t\t  iostat_value / (256 * 1024));\n}\n\nvoid iostat_print_counters(struct evlist *evlist,\n\t\t\t   struct perf_stat_config *config, struct timespec *ts,\n\t\t\t   char *prefix, iostat_print_counter_t print_cnt_cb, void *arg)\n{\n\tvoid *perf_device = NULL;\n\tstruct evsel *counter = evlist__first(evlist);\n\n\tevlist__set_selected(evlist, counter);\n\tiostat_prefix(evlist, config, prefix, ts);\n\tfprintf(config->output, \"%s\", prefix);\n\tevlist__for_each_entry(evlist, counter) {\n\t\tperf_device = evlist->selected->priv;\n\t\tif (perf_device && perf_device != counter->priv) {\n\t\t\tevlist__set_selected(evlist, counter);\n\t\t\tiostat_prefix(evlist, config, prefix, ts);\n\t\t\tfprintf(config->output, \"\\n%s\", prefix);\n\t\t}\n\t\tprint_cnt_cb(config, counter, arg);\n\t}\n\tfputc('\\n', config->output);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}