{
  "module_name": "event.c",
  "hash_id": "45a32a21640407df60446f8c7dd424de4a3b92b1c28b4eea91819bb54e49d83c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/x86/util/event.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <stdlib.h>\n\n#include \"../../../util/event.h\"\n#include \"../../../util/synthetic-events.h\"\n#include \"../../../util/machine.h\"\n#include \"../../../util/tool.h\"\n#include \"../../../util/map.h\"\n#include \"../../../util/debug.h\"\n#include \"util/sample.h\"\n\n#if defined(__x86_64__)\n\nint perf_event__synthesize_extra_kmaps(struct perf_tool *tool,\n\t\t\t\t       perf_event__handler_t process,\n\t\t\t\t       struct machine *machine)\n{\n\tint rc = 0;\n\tstruct map_rb_node *pos;\n\tstruct maps *kmaps = machine__kernel_maps(machine);\n\tunion perf_event *event = zalloc(sizeof(event->mmap) +\n\t\t\t\t\t machine->id_hdr_size);\n\n\tif (!event) {\n\t\tpr_debug(\"Not enough memory synthesizing mmap event \"\n\t\t\t \"for extra kernel maps\\n\");\n\t\treturn -1;\n\t}\n\n\tmaps__for_each_entry(kmaps, pos) {\n\t\tstruct kmap *kmap;\n\t\tsize_t size;\n\t\tstruct map *map = pos->map;\n\n\t\tif (!__map__is_extra_kernel_map(map))\n\t\t\tcontinue;\n\n\t\tkmap = map__kmap(map);\n\n\t\tsize = sizeof(event->mmap) - sizeof(event->mmap.filename) +\n\t\t       PERF_ALIGN(strlen(kmap->name) + 1, sizeof(u64)) +\n\t\t       machine->id_hdr_size;\n\n\t\tmemset(event, 0, size);\n\n\t\tevent->mmap.header.type = PERF_RECORD_MMAP;\n\n\t\t \n\t\tif (machine__is_host(machine))\n\t\t\tevent->header.misc = PERF_RECORD_MISC_KERNEL;\n\t\telse\n\t\t\tevent->header.misc = PERF_RECORD_MISC_GUEST_KERNEL;\n\n\t\tevent->mmap.header.size = size;\n\n\t\tevent->mmap.start = map__start(map);\n\t\tevent->mmap.len   = map__size(map);\n\t\tevent->mmap.pgoff = map__pgoff(map);\n\t\tevent->mmap.pid   = machine->pid;\n\n\t\tstrlcpy(event->mmap.filename, kmap->name, PATH_MAX);\n\n\t\tif (perf_tool__process_synth_event(tool, event, machine,\n\t\t\t\t\t\t   process) != 0) {\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(event);\n\treturn rc;\n}\n\n#endif\n\nvoid arch_perf_parse_sample_weight(struct perf_sample *data,\n\t\t\t\t   const __u64 *array, u64 type)\n{\n\tunion perf_sample_weight weight;\n\n\tweight.full = *array;\n\tif (type & PERF_SAMPLE_WEIGHT)\n\t\tdata->weight = weight.full;\n\telse {\n\t\tdata->weight = weight.var1_dw;\n\t\tdata->ins_lat = weight.var2_w;\n\t\tdata->retire_lat = weight.var3_w;\n\t}\n}\n\nvoid arch_perf_synthesize_sample_weight(const struct perf_sample *data,\n\t\t\t\t\t__u64 *array, u64 type)\n{\n\t*array = data->weight;\n\n\tif (type & PERF_SAMPLE_WEIGHT_STRUCT) {\n\t\t*array &= 0xffffffff;\n\t\t*array |= ((u64)data->ins_lat << 32);\n\t\t*array |= ((u64)data->retire_lat << 48);\n\t}\n}\n\nconst char *arch_perf_header_entry(const char *se_header)\n{\n\tif (!strcmp(se_header, \"Local Pipeline Stage Cycle\"))\n\t\treturn \"Local Retire Latency\";\n\telse if (!strcmp(se_header, \"Pipeline Stage Cycle\"))\n\t\treturn \"Retire Latency\";\n\n\treturn se_header;\n}\n\nint arch_support_sort_key(const char *sort_key)\n{\n\tif (!strcmp(sort_key, \"p_stage_cyc\"))\n\t\treturn 1;\n\tif (!strcmp(sort_key, \"local_p_stage_cyc\"))\n\t\treturn 1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}