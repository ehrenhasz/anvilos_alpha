{
  "module_name": "pmu.c",
  "hash_id": "52a0f77f4aa561af6f4c405328598a9bf4e611eef2f0338f4c0e41c76c8647a7",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/x86/util/pmu.c",
  "human_readable_source": "\n#include <string.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <linux/stddef.h>\n#include <linux/perf_event.h>\n#include <linux/zalloc.h>\n#include <api/fs/fs.h>\n#include <errno.h>\n\n#include \"../../../util/intel-pt.h\"\n#include \"../../../util/intel-bts.h\"\n#include \"../../../util/pmu.h\"\n#include \"../../../util/fncache.h\"\n#include \"../../../util/pmus.h\"\n#include \"env.h\"\n\nstruct pmu_alias {\n\tchar *name;\n\tchar *alias;\n\tstruct list_head list;\n};\n\nstatic LIST_HEAD(pmu_alias_name_list);\nstatic bool cached_list;\n\nstruct perf_event_attr *perf_pmu__get_default_config(struct perf_pmu *pmu __maybe_unused)\n{\n#ifdef HAVE_AUXTRACE_SUPPORT\n\tif (!strcmp(pmu->name, INTEL_PT_PMU_NAME)) {\n\t\tpmu->auxtrace = true;\n\t\treturn intel_pt_pmu_default_config(pmu);\n\t}\n\tif (!strcmp(pmu->name, INTEL_BTS_PMU_NAME)) {\n\t\tpmu->auxtrace = true;\n\t\tpmu->selectable = true;\n\t}\n#endif\n\treturn NULL;\n}\n\nstatic void pmu_alias__delete(struct pmu_alias *pmu_alias)\n{\n\tif (!pmu_alias)\n\t\treturn;\n\n\tzfree(&pmu_alias->name);\n\tzfree(&pmu_alias->alias);\n\tfree(pmu_alias);\n}\n\nstatic struct pmu_alias *pmu_alias__new(char *name, char *alias)\n{\n\tstruct pmu_alias *pmu_alias = zalloc(sizeof(*pmu_alias));\n\n\tif (pmu_alias) {\n\t\tpmu_alias->name = strdup(name);\n\t\tif (!pmu_alias->name)\n\t\t\tgoto out_delete;\n\n\t\tpmu_alias->alias = strdup(alias);\n\t\tif (!pmu_alias->alias)\n\t\t\tgoto out_delete;\n\t}\n\treturn pmu_alias;\n\nout_delete:\n\tpmu_alias__delete(pmu_alias);\n\treturn NULL;\n}\n\nstatic int setup_pmu_alias_list(void)\n{\n\tint fd, dirfd;\n\tDIR *dir;\n\tstruct dirent *dent;\n\tstruct pmu_alias *pmu_alias;\n\tchar buf[MAX_PMU_NAME_LEN];\n\tFILE *file;\n\tint ret = -ENOMEM;\n\n\tdirfd = perf_pmu__event_source_devices_fd();\n\tif (dirfd < 0)\n\t\treturn -1;\n\n\tdir = fdopendir(dirfd);\n\tif (!dir)\n\t\treturn -errno;\n\n\twhile ((dent = readdir(dir))) {\n\t\tif (!strcmp(dent->d_name, \".\") ||\n\t\t    !strcmp(dent->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tfd = perf_pmu__pathname_fd(dirfd, dent->d_name, \"alias\", O_RDONLY);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\n\t\tfile = fdopen(fd, \"r\");\n\t\tif (!file)\n\t\t\tcontinue;\n\n\t\tif (!fgets(buf, sizeof(buf), file)) {\n\t\t\tfclose(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfclose(file);\n\n\t\t \n\t\tbuf[strlen(buf) - 1] = 0;\n\n\t\tpmu_alias = pmu_alias__new(dent->d_name, buf);\n\t\tif (!pmu_alias)\n\t\t\tgoto close_dir;\n\n\t\tlist_add_tail(&pmu_alias->list, &pmu_alias_name_list);\n\t}\n\n\tret = 0;\n\nclose_dir:\n\tclosedir(dir);\n\treturn ret;\n}\n\nstatic const char *__pmu_find_real_name(const char *name)\n{\n\tstruct pmu_alias *pmu_alias;\n\n\tlist_for_each_entry(pmu_alias, &pmu_alias_name_list, list) {\n\t\tif (!strcmp(name, pmu_alias->alias))\n\t\t\treturn pmu_alias->name;\n\t}\n\n\treturn name;\n}\n\nconst char *pmu_find_real_name(const char *name)\n{\n\tif (cached_list)\n\t\treturn __pmu_find_real_name(name);\n\n\tsetup_pmu_alias_list();\n\tcached_list = true;\n\n\treturn __pmu_find_real_name(name);\n}\n\nstatic const char *__pmu_find_alias_name(const char *name)\n{\n\tstruct pmu_alias *pmu_alias;\n\n\tlist_for_each_entry(pmu_alias, &pmu_alias_name_list, list) {\n\t\tif (!strcmp(name, pmu_alias->name))\n\t\t\treturn pmu_alias->alias;\n\t}\n\treturn NULL;\n}\n\nconst char *pmu_find_alias_name(const char *name)\n{\n\tif (cached_list)\n\t\treturn __pmu_find_alias_name(name);\n\n\tsetup_pmu_alias_list();\n\tcached_list = true;\n\n\treturn __pmu_find_alias_name(name);\n}\n\nint perf_pmus__num_mem_pmus(void)\n{\n\t \n\tif (x86__is_amd_cpu())\n\t\treturn 1;\n\n\t \n\treturn perf_pmus__num_core_pmus();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}