{
  "module_name": "machine.c",
  "hash_id": "61980060cc5afa04107bf08eddcdcf15b67c2b123ee0ef118a0cb369f5445b07",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/x86/util/machine.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/string.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#include <internal/lib.h> \n#include \"../../../util/machine.h\"\n#include \"../../../util/map.h\"\n#include \"../../../util/symbol.h\"\n#include <linux/ctype.h>\n\n#include <symbol/kallsyms.h>\n\n#if defined(__x86_64__)\n\nstruct extra_kernel_map_info {\n\tint cnt;\n\tint max_cnt;\n\tstruct extra_kernel_map *maps;\n\tbool get_entry_trampolines;\n\tu64 entry_trampoline;\n};\n\nstatic int add_extra_kernel_map(struct extra_kernel_map_info *mi, u64 start,\n\t\t\t\tu64 end, u64 pgoff, const char *name)\n{\n\tif (mi->cnt >= mi->max_cnt) {\n\t\tvoid *buf;\n\t\tsize_t sz;\n\n\t\tmi->max_cnt = mi->max_cnt ? mi->max_cnt * 2 : 32;\n\t\tsz = sizeof(struct extra_kernel_map) * mi->max_cnt;\n\t\tbuf = realloc(mi->maps, sz);\n\t\tif (!buf)\n\t\t\treturn -1;\n\t\tmi->maps = buf;\n\t}\n\n\tmi->maps[mi->cnt].start = start;\n\tmi->maps[mi->cnt].end   = end;\n\tmi->maps[mi->cnt].pgoff = pgoff;\n\tstrlcpy(mi->maps[mi->cnt].name, name, KMAP_NAME_LEN);\n\n\tmi->cnt += 1;\n\n\treturn 0;\n}\n\nstatic int find_extra_kernel_maps(void *arg, const char *name, char type,\n\t\t\t\t  u64 start)\n{\n\tstruct extra_kernel_map_info *mi = arg;\n\n\tif (!mi->entry_trampoline && kallsyms2elf_binding(type) == STB_GLOBAL &&\n\t    !strcmp(name, \"_entry_trampoline\")) {\n\t\tmi->entry_trampoline = start;\n\t\treturn 0;\n\t}\n\n\tif (is_entry_trampoline(name)) {\n\t\tu64 end = start + page_size;\n\n\t\treturn add_extra_kernel_map(mi, start, end, 0, name);\n\t}\n\n\treturn 0;\n}\n\nint machine__create_extra_kernel_maps(struct machine *machine,\n\t\t\t\t      struct dso *kernel)\n{\n\tstruct extra_kernel_map_info mi = { .cnt = 0, };\n\tchar filename[PATH_MAX];\n\tint ret;\n\tint i;\n\n\tmachine__get_kallsyms_filename(machine, filename, PATH_MAX);\n\n\tif (symbol__restricted_filename(filename, \"/proc/kallsyms\"))\n\t\treturn 0;\n\n\tret = kallsyms__parse(filename, &mi, find_extra_kernel_maps);\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (!mi.entry_trampoline)\n\t\tgoto out_free;\n\n\tfor (i = 0; i < mi.cnt; i++) {\n\t\tstruct extra_kernel_map *xm = &mi.maps[i];\n\n\t\txm->pgoff = mi.entry_trampoline;\n\t\tret = machine__create_extra_kernel_map(machine, kernel, xm);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tmachine->trampolines_mapped = mi.cnt;\nout_free:\n\tfree(mi.maps);\n\treturn ret;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}