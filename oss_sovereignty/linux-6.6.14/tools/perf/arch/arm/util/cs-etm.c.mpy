{
  "module_name": "cs-etm.c",
  "hash_id": "7ac2242cbee1e630d8ec68616b7a29584ec11acc82901629256148d432eb1392",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/arm/util/cs-etm.c",
  "human_readable_source": "\n \n\n#include <api/fs/fs.h>\n#include <linux/bits.h>\n#include <linux/bitops.h>\n#include <linux/compiler.h>\n#include <linux/coresight-pmu.h>\n#include <linux/kernel.h>\n#include <linux/log2.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/zalloc.h>\n\n#include \"cs-etm.h\"\n#include \"../../../util/debug.h\"\n#include \"../../../util/record.h\"\n#include \"../../../util/auxtrace.h\"\n#include \"../../../util/cpumap.h\"\n#include \"../../../util/event.h\"\n#include \"../../../util/evlist.h\"\n#include \"../../../util/evsel.h\"\n#include \"../../../util/perf_api_probe.h\"\n#include \"../../../util/evsel_config.h\"\n#include \"../../../util/pmus.h\"\n#include \"../../../util/cs-etm.h\"\n#include <internal/lib.h> \n#include \"../../../util/session.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\nstruct cs_etm_recording {\n\tstruct auxtrace_record\titr;\n\tstruct perf_pmu\t\t*cs_etm_pmu;\n\tstruct evlist\t\t*evlist;\n\tbool\t\t\tsnapshot_mode;\n\tsize_t\t\t\tsnapshot_size;\n};\n\nstatic const char *metadata_etmv3_ro[CS_ETM_PRIV_MAX] = {\n\t[CS_ETM_ETMCCER]\t= \"mgmt/etmccer\",\n\t[CS_ETM_ETMIDR]\t\t= \"mgmt/etmidr\",\n};\n\nstatic const char * const metadata_etmv4_ro[] = {\n\t[CS_ETMV4_TRCIDR0]\t\t= \"trcidr/trcidr0\",\n\t[CS_ETMV4_TRCIDR1]\t\t= \"trcidr/trcidr1\",\n\t[CS_ETMV4_TRCIDR2]\t\t= \"trcidr/trcidr2\",\n\t[CS_ETMV4_TRCIDR8]\t\t= \"trcidr/trcidr8\",\n\t[CS_ETMV4_TRCAUTHSTATUS]\t= \"mgmt/trcauthstatus\",\n\t[CS_ETMV4_TS_SOURCE]\t\t= \"ts_source\",\n};\n\nstatic const char * const metadata_ete_ro[] = {\n\t[CS_ETE_TRCIDR0]\t\t= \"trcidr/trcidr0\",\n\t[CS_ETE_TRCIDR1]\t\t= \"trcidr/trcidr1\",\n\t[CS_ETE_TRCIDR2]\t\t= \"trcidr/trcidr2\",\n\t[CS_ETE_TRCIDR8]\t\t= \"trcidr/trcidr8\",\n\t[CS_ETE_TRCAUTHSTATUS]\t\t= \"mgmt/trcauthstatus\",\n\t[CS_ETE_TRCDEVARCH]\t\t= \"mgmt/trcdevarch\",\n\t[CS_ETE_TS_SOURCE]\t\t= \"ts_source\",\n};\n\nstatic bool cs_etm_is_etmv4(struct auxtrace_record *itr, int cpu);\nstatic bool cs_etm_is_ete(struct auxtrace_record *itr, int cpu);\n\nstatic int cs_etm_validate_context_id(struct auxtrace_record *itr,\n\t\t\t\t      struct evsel *evsel, int cpu)\n{\n\tstruct cs_etm_recording *ptr =\n\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\tchar path[PATH_MAX];\n\tint err;\n\tu32 val;\n\tu64 contextid = evsel->core.attr.config &\n\t\t(perf_pmu__format_bits(cs_etm_pmu, \"contextid\") |\n\t\t perf_pmu__format_bits(cs_etm_pmu, \"contextid1\") |\n\t\t perf_pmu__format_bits(cs_etm_pmu, \"contextid2\"));\n\n\tif (!contextid)\n\t\treturn 0;\n\n\t \n\tif (!cs_etm_is_etmv4(itr, cpu)) {\n\t\tpr_err(\"%s: contextid not supported in ETMv3, disable with %s/contextid=0/\\n\",\n\t\t       CORESIGHT_ETM_PMU_NAME, CORESIGHT_ETM_PMU_NAME);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnprintf(path, PATH_MAX, \"cpu%d/%s\",\n\t\t cpu, metadata_etmv4_ro[CS_ETMV4_TRCIDR2]);\n\terr = perf_pmu__scan_file(cs_etm_pmu, path, \"%x\", &val);\n\n\t \n\tif (err != 1) {\n\t\tpr_err(\"%s: can't read file %s\\n\", CORESIGHT_ETM_PMU_NAME,\n\t\t       path);\n\t\treturn err;\n\t}\n\n\tif (contextid &\n\t    perf_pmu__format_bits(cs_etm_pmu, \"contextid1\")) {\n\t\t \n\t\tif (BMVAL(val, 5, 9) != 0x4) {\n\t\t\tpr_err(\"%s: CONTEXTIDR_EL1 isn't supported, disable with %s/contextid1=0/\\n\",\n\t\t\t       CORESIGHT_ETM_PMU_NAME, CORESIGHT_ETM_PMU_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (contextid &\n\t    perf_pmu__format_bits(cs_etm_pmu, \"contextid2\")) {\n\t\t \n\t\tif (!BMVAL(val, 29, 30) || BMVAL(val, 10, 14) < 4) {\n\t\t\tpr_err(\"%s: CONTEXTIDR_EL2 isn't supported, disable with %s/contextid2=0/\\n\",\n\t\t\t       CORESIGHT_ETM_PMU_NAME, CORESIGHT_ETM_PMU_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cs_etm_validate_timestamp(struct auxtrace_record *itr,\n\t\t\t\t     struct evsel *evsel, int cpu)\n{\n\tstruct cs_etm_recording *ptr =\n\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\tchar path[PATH_MAX];\n\tint err;\n\tu32 val;\n\n\tif (!(evsel->core.attr.config &\n\t      perf_pmu__format_bits(cs_etm_pmu, \"timestamp\")))\n\t\treturn 0;\n\n\tif (!cs_etm_is_etmv4(itr, cpu)) {\n\t\tpr_err(\"%s: timestamp not supported in ETMv3, disable with %s/timestamp=0/\\n\",\n\t\t       CORESIGHT_ETM_PMU_NAME, CORESIGHT_ETM_PMU_NAME);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnprintf(path, PATH_MAX, \"cpu%d/%s\",\n\t\t cpu, metadata_etmv4_ro[CS_ETMV4_TRCIDR0]);\n\terr = perf_pmu__scan_file(cs_etm_pmu, path, \"%x\", &val);\n\n\t \n\tif (err != 1) {\n\t\tpr_err(\"%s: can't read file %s\\n\",\n\t\t       CORESIGHT_ETM_PMU_NAME, path);\n\t\treturn err;\n\t}\n\n\t \n\tval &= GENMASK(28, 24);\n\tif (!val) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cs_etm_validate_config(struct auxtrace_record *itr,\n\t\t\t\t  struct evsel *evsel)\n{\n\tint i, err = -EINVAL;\n\tstruct perf_cpu_map *event_cpus = evsel->evlist->core.user_requested_cpus;\n\tstruct perf_cpu_map *online_cpus = perf_cpu_map__new(NULL);\n\n\t \n\tfor (i = 0; i < cpu__max_cpu().cpu; i++) {\n\t\tstruct perf_cpu cpu = { .cpu = i, };\n\n\t\tif (!perf_cpu_map__has(event_cpus, cpu) ||\n\t\t    !perf_cpu_map__has(online_cpus, cpu))\n\t\t\tcontinue;\n\n\t\terr = cs_etm_validate_context_id(itr, evsel, i);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = cs_etm_validate_timestamp(itr, evsel, i);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\tperf_cpu_map__put(online_cpus);\n\treturn err;\n}\n\nstatic int cs_etm_parse_snapshot_options(struct auxtrace_record *itr,\n\t\t\t\t\t struct record_opts *opts,\n\t\t\t\t\t const char *str)\n{\n\tstruct cs_etm_recording *ptr =\n\t\t\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tunsigned long long snapshot_size = 0;\n\tchar *endptr;\n\n\tif (str) {\n\t\tsnapshot_size = strtoull(str, &endptr, 0);\n\t\tif (*endptr || snapshot_size > SIZE_MAX)\n\t\t\treturn -1;\n\t}\n\n\topts->auxtrace_snapshot_mode = true;\n\topts->auxtrace_snapshot_size = snapshot_size;\n\tptr->snapshot_size = snapshot_size;\n\n\treturn 0;\n}\n\nstatic int cs_etm_set_sink_attr(struct perf_pmu *pmu,\n\t\t\t\tstruct evsel *evsel)\n{\n\tchar msg[BUFSIZ], path[PATH_MAX], *sink;\n\tstruct evsel_config_term *term;\n\tint ret = -EINVAL;\n\tu32 hash;\n\n\tif (evsel->core.attr.config2 & GENMASK(31, 0))\n\t\treturn 0;\n\n\tlist_for_each_entry(term, &evsel->config_terms, list) {\n\t\tif (term->type != EVSEL__CONFIG_TERM_DRV_CFG)\n\t\t\tcontinue;\n\n\t\tsink = term->val.str;\n\t\tsnprintf(path, PATH_MAX, \"sinks/%s\", sink);\n\n\t\tret = perf_pmu__scan_file(pmu, path, \"%x\", &hash);\n\t\tif (ret != 1) {\n\t\t\tif (errno == ENOENT)\n\t\t\t\tpr_err(\"Couldn't find sink \\\"%s\\\" on event %s\\n\"\n\t\t\t\t       \"Missing kernel or device support?\\n\\n\"\n\t\t\t\t       \"Hint: An appropriate sink will be picked automatically if one isn't specified.\\n\",\n\t\t\t\t       sink, evsel__name(evsel));\n\t\t\telse\n\t\t\t\tpr_err(\"Failed to set sink \\\"%s\\\" on event %s with %d (%s)\\n\",\n\t\t\t\t       sink, evsel__name(evsel), errno,\n\t\t\t\t       str_error_r(errno, msg, sizeof(msg)));\n\t\t\treturn ret;\n\t\t}\n\n\t\tevsel->core.attr.config2 |= hash;\n\t\treturn 0;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int cs_etm_recording_options(struct auxtrace_record *itr,\n\t\t\t\t    struct evlist *evlist,\n\t\t\t\t    struct record_opts *opts)\n{\n\tint ret;\n\tstruct cs_etm_recording *ptr =\n\t\t\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\tstruct evsel *evsel, *cs_etm_evsel = NULL;\n\tstruct perf_cpu_map *cpus = evlist->core.user_requested_cpus;\n\tbool privileged = perf_event_paranoid_check(-1);\n\tint err = 0;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type == cs_etm_pmu->type) {\n\t\t\tif (cs_etm_evsel) {\n\t\t\t\tpr_err(\"There may be only one %s event\\n\",\n\t\t\t\t       CORESIGHT_ETM_PMU_NAME);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcs_etm_evsel = evsel;\n\t\t}\n\t}\n\n\t \n\tif (!cs_etm_evsel)\n\t\treturn 0;\n\n\tptr->evlist = evlist;\n\tptr->snapshot_mode = opts->auxtrace_snapshot_mode;\n\n\tif (!record_opts__no_switch_events(opts) &&\n\t    perf_can_record_switch_events())\n\t\topts->record_switch_events = true;\n\n\tcs_etm_evsel->needs_auxtrace_mmap = true;\n\topts->full_auxtrace = true;\n\n\tret = cs_etm_set_sink_attr(cs_etm_pmu, cs_etm_evsel);\n\tif (ret)\n\t\treturn ret;\n\n\tif (opts->use_clockid) {\n\t\tpr_err(\"Cannot use clockid (-k option) with %s\\n\",\n\t\t       CORESIGHT_ETM_PMU_NAME);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (opts->auxtrace_snapshot_mode) {\n\t\t \n\t\tif (!opts->auxtrace_snapshot_size &&\n\t\t    !opts->auxtrace_mmap_pages) {\n\t\t\tif (privileged) {\n\t\t\t\topts->auxtrace_mmap_pages = MiB(4) / page_size;\n\t\t\t} else {\n\t\t\t\topts->auxtrace_mmap_pages =\n\t\t\t\t\t\t\tKiB(128) / page_size;\n\t\t\t\tif (opts->mmap_pages == UINT_MAX)\n\t\t\t\t\topts->mmap_pages = KiB(256) / page_size;\n\t\t\t}\n\t\t} else if (!opts->auxtrace_mmap_pages && !privileged &&\n\t\t\t\t\t\topts->mmap_pages == UINT_MAX) {\n\t\t\topts->mmap_pages = KiB(256) / page_size;\n\t\t}\n\n\t\t \n\t\tif (!opts->auxtrace_snapshot_size) {\n\t\t\topts->auxtrace_snapshot_size =\n\t\t\t\topts->auxtrace_mmap_pages * (size_t)page_size;\n\t\t}\n\n\t\t \n\t\tif (!opts->auxtrace_mmap_pages) {\n\t\t\tsize_t sz = opts->auxtrace_snapshot_size;\n\n\t\t\tsz = round_up(sz, page_size) / page_size;\n\t\t\topts->auxtrace_mmap_pages = roundup_pow_of_two(sz);\n\t\t}\n\n\t\t \n\t\tif (opts->auxtrace_snapshot_size >\n\t\t\t\topts->auxtrace_mmap_pages * (size_t)page_size) {\n\t\t\tpr_err(\"Snapshot size %zu must not be greater than AUX area tracing mmap size %zu\\n\",\n\t\t\t       opts->auxtrace_snapshot_size,\n\t\t\t       opts->auxtrace_mmap_pages * (size_t)page_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!opts->auxtrace_snapshot_size ||\n\t\t    !opts->auxtrace_mmap_pages) {\n\t\t\tpr_err(\"Failed to calculate default snapshot size and/or AUX area tracing mmap pages\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (!opts->auxtrace_mmap_pages) {\n\t\tif (privileged) {\n\t\t\topts->auxtrace_mmap_pages = MiB(4) / page_size;\n\t\t} else {\n\t\t\topts->auxtrace_mmap_pages = KiB(128) / page_size;\n\t\t\tif (opts->mmap_pages == UINT_MAX)\n\t\t\t\topts->mmap_pages = KiB(256) / page_size;\n\t\t}\n\t}\n\n\tif (opts->auxtrace_snapshot_mode)\n\t\tpr_debug2(\"%s snapshot size: %zu\\n\", CORESIGHT_ETM_PMU_NAME,\n\t\t\t  opts->auxtrace_snapshot_size);\n\n\t \n\tevlist__to_front(evlist, cs_etm_evsel);\n\n\t \n\tevsel__set_sample_bit(cs_etm_evsel, CPU);\n\n\t \n\tif (!perf_cpu_map__empty(cpus)) {\n\t\tevsel__set_config_if_unset(cs_etm_pmu, cs_etm_evsel,\n\t\t\t\t\t   \"timestamp\", 1);\n\t\tevsel__set_config_if_unset(cs_etm_pmu, cs_etm_evsel,\n\t\t\t\t\t   \"contextid\", 1);\n\t}\n\n\t \n\terr = parse_event(evlist, \"dummy:u\");\n\tif (err)\n\t\tgoto out;\n\tevsel = evlist__last(evlist);\n\tevlist__set_tracking_event(evlist, evsel);\n\tevsel->core.attr.freq = 0;\n\tevsel->core.attr.sample_period = 1;\n\n\t \n\tif (!perf_cpu_map__empty(cpus))\n\t\tevsel__set_sample_bit(evsel, TIME);\n\n\terr = cs_etm_validate_config(itr, cs_etm_evsel);\nout:\n\treturn err;\n}\n\nstatic u64 cs_etm_get_config(struct auxtrace_record *itr)\n{\n\tu64 config = 0;\n\tstruct cs_etm_recording *ptr =\n\t\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\tstruct evlist *evlist = ptr->evlist;\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.attr.type == cs_etm_pmu->type) {\n\t\t\t \n\t\t\tconfig = evsel->core.attr.config;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn config;\n}\n\n#ifndef BIT\n#define BIT(N) (1UL << (N))\n#endif\n\nstatic u64 cs_etmv4_get_config(struct auxtrace_record *itr)\n{\n\tu64 config = 0;\n\tu64 config_opts = 0;\n\n\t \n\tconfig_opts = cs_etm_get_config(itr);\n\tif (config_opts & BIT(ETM_OPT_CYCACC))\n\t\tconfig |= BIT(ETM4_CFG_BIT_CYCACC);\n\tif (config_opts & BIT(ETM_OPT_CTXTID))\n\t\tconfig |= BIT(ETM4_CFG_BIT_CTXTID);\n\tif (config_opts & BIT(ETM_OPT_TS))\n\t\tconfig |= BIT(ETM4_CFG_BIT_TS);\n\tif (config_opts & BIT(ETM_OPT_RETSTK))\n\t\tconfig |= BIT(ETM4_CFG_BIT_RETSTK);\n\tif (config_opts & BIT(ETM_OPT_CTXTID2))\n\t\tconfig |= BIT(ETM4_CFG_BIT_VMID) |\n\t\t\t  BIT(ETM4_CFG_BIT_VMID_OPT);\n\tif (config_opts & BIT(ETM_OPT_BRANCH_BROADCAST))\n\t\tconfig |= BIT(ETM4_CFG_BIT_BB);\n\n\treturn config;\n}\n\nstatic size_t\ncs_etm_info_priv_size(struct auxtrace_record *itr __maybe_unused,\n\t\t      struct evlist *evlist __maybe_unused)\n{\n\tint i;\n\tint etmv3 = 0, etmv4 = 0, ete = 0;\n\tstruct perf_cpu_map *event_cpus = evlist->core.user_requested_cpus;\n\tstruct perf_cpu_map *online_cpus = perf_cpu_map__new(NULL);\n\n\t \n\tif (!perf_cpu_map__empty(event_cpus)) {\n\t\tfor (i = 0; i < cpu__max_cpu().cpu; i++) {\n\t\t\tstruct perf_cpu cpu = { .cpu = i, };\n\n\t\t\tif (!perf_cpu_map__has(event_cpus, cpu) ||\n\t\t\t    !perf_cpu_map__has(online_cpus, cpu))\n\t\t\t\tcontinue;\n\n\t\t\tif (cs_etm_is_ete(itr, i))\n\t\t\t\tete++;\n\t\t\telse if (cs_etm_is_etmv4(itr, i))\n\t\t\t\tetmv4++;\n\t\t\telse\n\t\t\t\tetmv3++;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < cpu__max_cpu().cpu; i++) {\n\t\t\tstruct perf_cpu cpu = { .cpu = i, };\n\n\t\t\tif (!perf_cpu_map__has(online_cpus, cpu))\n\t\t\t\tcontinue;\n\n\t\t\tif (cs_etm_is_ete(itr, i))\n\t\t\t\tete++;\n\t\t\telse if (cs_etm_is_etmv4(itr, i))\n\t\t\t\tetmv4++;\n\t\t\telse\n\t\t\t\tetmv3++;\n\t\t}\n\t}\n\n\tperf_cpu_map__put(online_cpus);\n\n\treturn (CS_ETM_HEADER_SIZE +\n\t       (ete   * CS_ETE_PRIV_SIZE) +\n\t       (etmv4 * CS_ETMV4_PRIV_SIZE) +\n\t       (etmv3 * CS_ETMV3_PRIV_SIZE));\n}\n\nstatic bool cs_etm_is_etmv4(struct auxtrace_record *itr, int cpu)\n{\n\tbool ret = false;\n\tchar path[PATH_MAX];\n\tint scan;\n\tunsigned int val;\n\tstruct cs_etm_recording *ptr =\n\t\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\n\t \n\tsnprintf(path, PATH_MAX, \"cpu%d/%s\",\n\t\t cpu, metadata_etmv4_ro[CS_ETMV4_TRCIDR0]);\n\tscan = perf_pmu__scan_file(cs_etm_pmu, path, \"%x\", &val);\n\n\t \n\tif (scan == 1)\n\t\tret = true;\n\n\treturn ret;\n}\n\nstatic int cs_etm_get_ro(struct perf_pmu *pmu, int cpu, const char *path)\n{\n\tchar pmu_path[PATH_MAX];\n\tint scan;\n\tunsigned int val = 0;\n\n\t \n\tsnprintf(pmu_path, PATH_MAX, \"cpu%d/%s\", cpu, path);\n\n\tscan = perf_pmu__scan_file(pmu, pmu_path, \"%x\", &val);\n\tif (scan != 1)\n\t\tpr_err(\"%s: error reading: %s\\n\", __func__, pmu_path);\n\n\treturn val;\n}\n\nstatic int cs_etm_get_ro_signed(struct perf_pmu *pmu, int cpu, const char *path)\n{\n\tchar pmu_path[PATH_MAX];\n\tint scan;\n\tint val = 0;\n\n\t \n\tsnprintf(pmu_path, PATH_MAX, \"cpu%d/%s\", cpu, path);\n\n\tscan = perf_pmu__scan_file(pmu, pmu_path, \"%d\", &val);\n\tif (scan != 1)\n\t\tpr_err(\"%s: error reading: %s\\n\", __func__, pmu_path);\n\n\treturn val;\n}\n\nstatic bool cs_etm_pmu_path_exists(struct perf_pmu *pmu, int cpu, const char *path)\n{\n\tchar pmu_path[PATH_MAX];\n\n\t \n\tsnprintf(pmu_path, PATH_MAX, \"cpu%d/%s\", cpu, path);\n\n\treturn perf_pmu__file_exists(pmu, pmu_path);\n}\n\n#define TRCDEVARCH_ARCHPART_SHIFT 0\n#define TRCDEVARCH_ARCHPART_MASK  GENMASK(11, 0)\n#define TRCDEVARCH_ARCHPART(x)    (((x) & TRCDEVARCH_ARCHPART_MASK) >> TRCDEVARCH_ARCHPART_SHIFT)\n\n#define TRCDEVARCH_ARCHVER_SHIFT 12\n#define TRCDEVARCH_ARCHVER_MASK  GENMASK(15, 12)\n#define TRCDEVARCH_ARCHVER(x)    (((x) & TRCDEVARCH_ARCHVER_MASK) >> TRCDEVARCH_ARCHVER_SHIFT)\n\nstatic bool cs_etm_is_ete(struct auxtrace_record *itr, int cpu)\n{\n\tstruct cs_etm_recording *ptr = container_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\tint trcdevarch;\n\n\tif (!cs_etm_pmu_path_exists(cs_etm_pmu, cpu, metadata_ete_ro[CS_ETE_TRCDEVARCH]))\n\t\treturn false;\n\n\ttrcdevarch = cs_etm_get_ro(cs_etm_pmu, cpu, metadata_ete_ro[CS_ETE_TRCDEVARCH]);\n\t \n\treturn TRCDEVARCH_ARCHVER(trcdevarch) == 5 && TRCDEVARCH_ARCHPART(trcdevarch) == 0xA13;\n}\n\nstatic void cs_etm_save_etmv4_header(__u64 data[], struct auxtrace_record *itr, int cpu)\n{\n\tstruct cs_etm_recording *ptr = container_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\n\t \n\tdata[CS_ETMV4_TRCCONFIGR] = cs_etmv4_get_config(itr);\n\t \n\tdata[CS_ETMV4_TRCTRACEIDR] =\n\t\tCORESIGHT_LEGACY_CPU_TRACE_ID(cpu) | CORESIGHT_TRACE_ID_UNUSED_FLAG;\n\n\t \n\tdata[CS_ETMV4_TRCIDR0] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t       metadata_etmv4_ro[CS_ETMV4_TRCIDR0]);\n\tdata[CS_ETMV4_TRCIDR1] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t       metadata_etmv4_ro[CS_ETMV4_TRCIDR1]);\n\tdata[CS_ETMV4_TRCIDR2] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t       metadata_etmv4_ro[CS_ETMV4_TRCIDR2]);\n\tdata[CS_ETMV4_TRCIDR8] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t       metadata_etmv4_ro[CS_ETMV4_TRCIDR8]);\n\tdata[CS_ETMV4_TRCAUTHSTATUS] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t\t     metadata_etmv4_ro[CS_ETMV4_TRCAUTHSTATUS]);\n\n\t \n\tif (cs_etm_pmu_path_exists(cs_etm_pmu, cpu, metadata_etmv4_ro[CS_ETMV4_TS_SOURCE]))\n\t\tdata[CS_ETMV4_TS_SOURCE] = (__u64) cs_etm_get_ro_signed(cs_etm_pmu, cpu,\n\t\t\t\tmetadata_etmv4_ro[CS_ETMV4_TS_SOURCE]);\n\telse {\n\t\tpr_debug3(\"[%03d] pmu file 'ts_source' not found. Fallback to safe value (-1)\\n\",\n\t\t\t  cpu);\n\t\tdata[CS_ETMV4_TS_SOURCE] = (__u64) -1;\n\t}\n}\n\nstatic void cs_etm_save_ete_header(__u64 data[], struct auxtrace_record *itr, int cpu)\n{\n\tstruct cs_etm_recording *ptr = container_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\n\t \n\tdata[CS_ETE_TRCCONFIGR] = cs_etmv4_get_config(itr);\n\t \n\tdata[CS_ETE_TRCTRACEIDR] =\n\t\tCORESIGHT_LEGACY_CPU_TRACE_ID(cpu) | CORESIGHT_TRACE_ID_UNUSED_FLAG;\n\n\t \n\tdata[CS_ETE_TRCIDR0] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t     metadata_ete_ro[CS_ETE_TRCIDR0]);\n\tdata[CS_ETE_TRCIDR1] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t     metadata_ete_ro[CS_ETE_TRCIDR1]);\n\tdata[CS_ETE_TRCIDR2] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t     metadata_ete_ro[CS_ETE_TRCIDR2]);\n\tdata[CS_ETE_TRCIDR8] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t     metadata_ete_ro[CS_ETE_TRCIDR8]);\n\tdata[CS_ETE_TRCAUTHSTATUS] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t\t   metadata_ete_ro[CS_ETE_TRCAUTHSTATUS]);\n\t \n\tdata[CS_ETE_TRCDEVARCH] = cs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t\t\tmetadata_ete_ro[CS_ETE_TRCDEVARCH]);\n\n\t \n\tif (cs_etm_pmu_path_exists(cs_etm_pmu, cpu, metadata_ete_ro[CS_ETE_TS_SOURCE]))\n\t\tdata[CS_ETE_TS_SOURCE] = (__u64) cs_etm_get_ro_signed(cs_etm_pmu, cpu,\n\t\t\t\tmetadata_ete_ro[CS_ETE_TS_SOURCE]);\n\telse {\n\t\tpr_debug3(\"[%03d] pmu file 'ts_source' not found. Fallback to safe value (-1)\\n\",\n\t\t\t  cpu);\n\t\tdata[CS_ETE_TS_SOURCE] = (__u64) -1;\n\t}\n}\n\nstatic void cs_etm_get_metadata(int cpu, u32 *offset,\n\t\t\t\tstruct auxtrace_record *itr,\n\t\t\t\tstruct perf_record_auxtrace_info *info)\n{\n\tu32 increment, nr_trc_params;\n\tu64 magic;\n\tstruct cs_etm_recording *ptr =\n\t\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\n\t \n\tif (cs_etm_is_ete(itr, cpu)) {\n\t\tmagic = __perf_cs_ete_magic;\n\t\tcs_etm_save_ete_header(&info->priv[*offset], itr, cpu);\n\n\t\t \n\t\tincrement = CS_ETE_PRIV_MAX;\n\t\tnr_trc_params = CS_ETE_PRIV_MAX - CS_ETM_COMMON_BLK_MAX_V1;\n\t} else if (cs_etm_is_etmv4(itr, cpu)) {\n\t\tmagic = __perf_cs_etmv4_magic;\n\t\tcs_etm_save_etmv4_header(&info->priv[*offset], itr, cpu);\n\n\t\t \n\t\tincrement = CS_ETMV4_PRIV_MAX;\n\t\tnr_trc_params = CS_ETMV4_PRIV_MAX - CS_ETMV4_TRCCONFIGR;\n\t} else {\n\t\tmagic = __perf_cs_etmv3_magic;\n\t\t \n\t\tinfo->priv[*offset + CS_ETM_ETMCR] = cs_etm_get_config(itr);\n\t\t \n\t\tinfo->priv[*offset + CS_ETM_ETMTRACEIDR] =\n\t\t\tCORESIGHT_LEGACY_CPU_TRACE_ID(cpu) | CORESIGHT_TRACE_ID_UNUSED_FLAG;\n\t\t \n\t\tinfo->priv[*offset + CS_ETM_ETMCCER] =\n\t\t\tcs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t      metadata_etmv3_ro[CS_ETM_ETMCCER]);\n\t\tinfo->priv[*offset + CS_ETM_ETMIDR] =\n\t\t\tcs_etm_get_ro(cs_etm_pmu, cpu,\n\t\t\t\t      metadata_etmv3_ro[CS_ETM_ETMIDR]);\n\n\t\t \n\t\tincrement = CS_ETM_PRIV_MAX;\n\t\tnr_trc_params = CS_ETM_PRIV_MAX - CS_ETM_ETMCR;\n\t}\n\n\t \n\tinfo->priv[*offset + CS_ETM_MAGIC] = magic;\n\tinfo->priv[*offset + CS_ETM_CPU] = cpu;\n\tinfo->priv[*offset + CS_ETM_NR_TRC_PARAMS] = nr_trc_params;\n\t \n\t*offset += increment;\n}\n\nstatic int cs_etm_info_fill(struct auxtrace_record *itr,\n\t\t\t    struct perf_session *session,\n\t\t\t    struct perf_record_auxtrace_info *info,\n\t\t\t    size_t priv_size)\n{\n\tint i;\n\tu32 offset;\n\tu64 nr_cpu, type;\n\tstruct perf_cpu_map *cpu_map;\n\tstruct perf_cpu_map *event_cpus = session->evlist->core.user_requested_cpus;\n\tstruct perf_cpu_map *online_cpus = perf_cpu_map__new(NULL);\n\tstruct cs_etm_recording *ptr =\n\t\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\n\n\tif (priv_size != cs_etm_info_priv_size(itr, session->evlist))\n\t\treturn -EINVAL;\n\n\tif (!session->evlist->core.nr_mmaps)\n\t\treturn -EINVAL;\n\n\t \n\tif (perf_cpu_map__empty(event_cpus)) {\n\t\tcpu_map = online_cpus;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < perf_cpu_map__nr(event_cpus); i++) {\n\t\t\tstruct perf_cpu cpu = { .cpu = i, };\n\n\t\t\tif (perf_cpu_map__has(event_cpus, cpu) &&\n\t\t\t    !perf_cpu_map__has(online_cpus, cpu))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcpu_map = event_cpus;\n\t}\n\n\tnr_cpu = perf_cpu_map__nr(cpu_map);\n\t \n\ttype = cs_etm_pmu->type;\n\n\t \n\tinfo->type = PERF_AUXTRACE_CS_ETM;\n\tinfo->priv[CS_HEADER_VERSION] = CS_HEADER_CURRENT_VERSION;\n\tinfo->priv[CS_PMU_TYPE_CPUS] = type << 32;\n\tinfo->priv[CS_PMU_TYPE_CPUS] |= nr_cpu;\n\tinfo->priv[CS_ETM_SNAPSHOT] = ptr->snapshot_mode;\n\n\toffset = CS_ETM_SNAPSHOT + 1;\n\n\tfor (i = 0; i < cpu__max_cpu().cpu && offset < priv_size; i++) {\n\t\tstruct perf_cpu cpu = { .cpu = i, };\n\n\t\tif (perf_cpu_map__has(cpu_map, cpu))\n\t\t\tcs_etm_get_metadata(i, &offset, itr, info);\n\t}\n\n\tperf_cpu_map__put(online_cpus);\n\n\treturn 0;\n}\n\nstatic int cs_etm_snapshot_start(struct auxtrace_record *itr)\n{\n\tstruct cs_etm_recording *ptr =\n\t\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(ptr->evlist, evsel) {\n\t\tif (evsel->core.attr.type == ptr->cs_etm_pmu->type)\n\t\t\treturn evsel__disable(evsel);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cs_etm_snapshot_finish(struct auxtrace_record *itr)\n{\n\tstruct cs_etm_recording *ptr =\n\t\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(ptr->evlist, evsel) {\n\t\tif (evsel->core.attr.type == ptr->cs_etm_pmu->type)\n\t\t\treturn evsel__enable(evsel);\n\t}\n\treturn -EINVAL;\n}\n\nstatic u64 cs_etm_reference(struct auxtrace_record *itr __maybe_unused)\n{\n\treturn (((u64) rand() <<  0) & 0x00000000FFFFFFFFull) |\n\t\t(((u64) rand() << 32) & 0xFFFFFFFF00000000ull);\n}\n\nstatic void cs_etm_recording_free(struct auxtrace_record *itr)\n{\n\tstruct cs_etm_recording *ptr =\n\t\t\tcontainer_of(itr, struct cs_etm_recording, itr);\n\n\tfree(ptr);\n}\n\nstruct auxtrace_record *cs_etm_record_init(int *err)\n{\n\tstruct perf_pmu *cs_etm_pmu;\n\tstruct cs_etm_recording *ptr;\n\n\tcs_etm_pmu = perf_pmus__find(CORESIGHT_ETM_PMU_NAME);\n\n\tif (!cs_etm_pmu) {\n\t\t*err = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tptr = zalloc(sizeof(struct cs_etm_recording));\n\tif (!ptr) {\n\t\t*err = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tptr->cs_etm_pmu\t\t\t= cs_etm_pmu;\n\tptr->itr.pmu\t\t\t= cs_etm_pmu;\n\tptr->itr.parse_snapshot_options\t= cs_etm_parse_snapshot_options;\n\tptr->itr.recording_options\t= cs_etm_recording_options;\n\tptr->itr.info_priv_size\t\t= cs_etm_info_priv_size;\n\tptr->itr.info_fill\t\t= cs_etm_info_fill;\n\tptr->itr.snapshot_start\t\t= cs_etm_snapshot_start;\n\tptr->itr.snapshot_finish\t= cs_etm_snapshot_finish;\n\tptr->itr.reference\t\t= cs_etm_reference;\n\tptr->itr.free\t\t\t= cs_etm_recording_free;\n\tptr->itr.read_finish\t\t= auxtrace_record__read_finish;\n\n\t*err = 0;\n\treturn &ptr->itr;\nout:\n\treturn NULL;\n}\n\n \nstruct perf_event_attr *\ncs_etm_get_default_config(struct perf_pmu *pmu __maybe_unused)\n{\n\tstruct perf_event_attr *attr;\n\n\tattr = zalloc(sizeof(struct perf_event_attr));\n\tif (!attr)\n\t\treturn NULL;\n\n\tattr->sample_period = 1;\n\n\treturn attr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}