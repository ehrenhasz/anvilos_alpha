{
  "module_name": "auxtrace.c",
  "hash_id": "7fb1133555808b58bcf95c013807bde4ca65e0b2f0b2c1bdcb51298aa7c820c0",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/arm/util/auxtrace.c",
  "human_readable_source": "\n \n\n#include <dirent.h>\n#include <stdbool.h>\n#include <linux/coresight-pmu.h>\n#include <linux/zalloc.h>\n#include <api/fs/fs.h>\n\n#include \"../../../util/auxtrace.h\"\n#include \"../../../util/debug.h\"\n#include \"../../../util/evlist.h\"\n#include \"../../../util/pmu.h\"\n#include \"../../../util/pmus.h\"\n#include \"cs-etm.h\"\n#include \"arm-spe.h\"\n#include \"hisi-ptt.h\"\n\nstatic struct perf_pmu **find_all_arm_spe_pmus(int *nr_spes, int *err)\n{\n\tstruct perf_pmu **arm_spe_pmus = NULL;\n\tint ret, i, nr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\t \n\tchar arm_spe_pmu_name[sizeof(ARM_SPE_PMU_NAME) + 10];\n\n\tarm_spe_pmus = zalloc(sizeof(struct perf_pmu *) * nr_cpus);\n\tif (!arm_spe_pmus) {\n\t\tpr_err(\"spes alloc failed\\n\");\n\t\t*err = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tret = sprintf(arm_spe_pmu_name, \"%s%d\", ARM_SPE_PMU_NAME, i);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"sprintf failed\\n\");\n\t\t\t*err = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tarm_spe_pmus[*nr_spes] = perf_pmus__find(arm_spe_pmu_name);\n\t\tif (arm_spe_pmus[*nr_spes]) {\n\t\t\tpr_debug2(\"%s %d: arm_spe_pmu %d type %d name %s\\n\",\n\t\t\t\t __func__, __LINE__, *nr_spes,\n\t\t\t\t arm_spe_pmus[*nr_spes]->type,\n\t\t\t\t arm_spe_pmus[*nr_spes]->name);\n\t\t\t(*nr_spes)++;\n\t\t}\n\t}\n\n\treturn arm_spe_pmus;\n}\n\nstatic struct perf_pmu **find_all_hisi_ptt_pmus(int *nr_ptts, int *err)\n{\n\tstruct perf_pmu **hisi_ptt_pmus = NULL;\n\tstruct dirent *dent;\n\tchar path[PATH_MAX];\n\tDIR *dir = NULL;\n\tint idx = 0;\n\n\tperf_pmu__event_source_devices_scnprintf(path, sizeof(path));\n\tdir = opendir(path);\n\tif (!dir) {\n\t\tpr_err(\"can't read directory '%s'\\n\", path);\n\t\t*err = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\twhile ((dent = readdir(dir))) {\n\t\tif (strstr(dent->d_name, HISI_PTT_PMU_NAME))\n\t\t\t(*nr_ptts)++;\n\t}\n\n\tif (!(*nr_ptts))\n\t\tgoto out;\n\n\thisi_ptt_pmus = zalloc(sizeof(struct perf_pmu *) * (*nr_ptts));\n\tif (!hisi_ptt_pmus) {\n\t\tpr_err(\"hisi_ptt alloc failed\\n\");\n\t\t*err = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trewinddir(dir);\n\twhile ((dent = readdir(dir))) {\n\t\tif (strstr(dent->d_name, HISI_PTT_PMU_NAME) && idx < *nr_ptts) {\n\t\t\thisi_ptt_pmus[idx] = perf_pmus__find(dent->d_name);\n\t\t\tif (hisi_ptt_pmus[idx])\n\t\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tclosedir(dir);\n\treturn hisi_ptt_pmus;\n}\n\nstatic struct perf_pmu *find_pmu_for_event(struct perf_pmu **pmus,\n\t\t\t\t\t   int pmu_nr, struct evsel *evsel)\n{\n\tint i;\n\n\tif (!pmus)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pmu_nr; i++) {\n\t\tif (evsel->core.attr.type == pmus[i]->type)\n\t\t\treturn pmus[i];\n\t}\n\n\treturn NULL;\n}\n\nstruct auxtrace_record\n*auxtrace_record__init(struct evlist *evlist, int *err)\n{\n\tstruct perf_pmu\t*cs_etm_pmu = NULL;\n\tstruct perf_pmu **arm_spe_pmus = NULL;\n\tstruct perf_pmu **hisi_ptt_pmus = NULL;\n\tstruct evsel *evsel;\n\tstruct perf_pmu *found_etm = NULL;\n\tstruct perf_pmu *found_spe = NULL;\n\tstruct perf_pmu *found_ptt = NULL;\n\tint auxtrace_event_cnt = 0;\n\tint nr_spes = 0;\n\tint nr_ptts = 0;\n\n\tif (!evlist)\n\t\treturn NULL;\n\n\tcs_etm_pmu = perf_pmus__find(CORESIGHT_ETM_PMU_NAME);\n\tarm_spe_pmus = find_all_arm_spe_pmus(&nr_spes, err);\n\thisi_ptt_pmus = find_all_hisi_ptt_pmus(&nr_ptts, err);\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (cs_etm_pmu && !found_etm)\n\t\t\tfound_etm = find_pmu_for_event(&cs_etm_pmu, 1, evsel);\n\n\t\tif (arm_spe_pmus && !found_spe)\n\t\t\tfound_spe = find_pmu_for_event(arm_spe_pmus, nr_spes, evsel);\n\n\t\tif (hisi_ptt_pmus && !found_ptt)\n\t\t\tfound_ptt = find_pmu_for_event(hisi_ptt_pmus, nr_ptts, evsel);\n\t}\n\n\tfree(arm_spe_pmus);\n\tfree(hisi_ptt_pmus);\n\n\tif (found_etm)\n\t\tauxtrace_event_cnt++;\n\n\tif (found_spe)\n\t\tauxtrace_event_cnt++;\n\n\tif (found_ptt)\n\t\tauxtrace_event_cnt++;\n\n\tif (auxtrace_event_cnt > 1) {\n\t\tpr_err(\"Concurrent AUX trace operation not currently supported\\n\");\n\t\t*err = -EOPNOTSUPP;\n\t\treturn NULL;\n\t}\n\n\tif (found_etm)\n\t\treturn cs_etm_record_init(err);\n\n#if defined(__aarch64__)\n\tif (found_spe)\n\t\treturn arm_spe_recording_init(err, found_spe);\n\n\tif (found_ptt)\n\t\treturn hisi_ptt_recording_init(err, found_ptt);\n#endif\n\n\t \n\t*err = 0;\n\treturn NULL;\n}\n\n#if defined(__arm__)\nu64 compat_auxtrace_mmap__read_head(struct auxtrace_mmap *mm)\n{\n\tstruct perf_event_mmap_page *pc = mm->userpg;\n\tu64 result;\n\n\t__asm__ __volatile__(\n\"\tldrd    %0, %H0, [%1]\"\n\t: \"=&r\" (result)\n\t: \"r\" (&pc->aux_head), \"Qo\" (pc->aux_head)\n\t);\n\n\treturn result;\n}\n\nint compat_auxtrace_mmap__write_tail(struct auxtrace_mmap *mm, u64 tail)\n{\n\tstruct perf_event_mmap_page *pc = mm->userpg;\n\n\t \n\tsmp_mb();\n\n\t__asm__ __volatile__(\n\"\tstrd    %2, %H2, [%1]\"\n\t: \"=Qo\" (pc->aux_tail)\n\t: \"r\" (&pc->aux_tail), \"r\" (tail)\n\t);\n\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}