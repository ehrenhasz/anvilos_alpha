{
  "module_name": "sym-handling.c",
  "hash_id": "d4effbc28b01fc26b8fbc371fc6e8e58925fac223adec60f735f046bb6ccb8e2",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/powerpc/util/sym-handling.c",
  "human_readable_source": "\n \n\n#include \"dso.h\"\n#include \"symbol.h\"\n#include \"map.h\"\n#include \"probe-event.h\"\n#include \"probe-file.h\"\n\nint arch__choose_best_symbol(struct symbol *syma,\n\t\t\t     struct symbol *symb __maybe_unused)\n{\n\tchar *sym = syma->name;\n\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n\t \n\tif (*sym == '.')\n\t\tsym++;\n#endif\n\n\t \n\tif (strlen(sym) >= 3 && !strncmp(sym, \"SyS\", 3))\n\t\treturn SYMBOL_B;\n\tif (strlen(sym) >= 10 && !strncmp(sym, \"compat_SyS\", 10))\n\t\treturn SYMBOL_B;\n\n\treturn SYMBOL_A;\n}\n\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n \nint arch__compare_symbol_names(const char *namea, const char *nameb)\n{\n\t \n\tif (*namea == '.')\n\t\tnamea++;\n\tif (*nameb == '.')\n\t\tnameb++;\n\n\treturn strcmp(namea, nameb);\n}\n\nint arch__compare_symbol_names_n(const char *namea, const char *nameb,\n\t\t\t\t unsigned int n)\n{\n\t \n\tif (*namea == '.')\n\t\tnamea++;\n\tif (*nameb == '.')\n\t\tnameb++;\n\n\treturn strncmp(namea, nameb, n);\n}\n\nconst char *arch__normalize_symbol_name(const char *name)\n{\n\t \n\tif (name && *name == '.')\n\t\tname++;\n\treturn name;\n}\n#endif\n\n#if defined(_CALL_ELF) && _CALL_ELF == 2\n\n#ifdef HAVE_LIBELF_SUPPORT\nvoid arch__sym_update(struct symbol *s, GElf_Sym *sym)\n{\n\ts->arch_sym = sym->st_other;\n}\n#endif\n\n#define PPC64LE_LEP_OFFSET\t8\n\nvoid arch__fix_tev_from_maps(struct perf_probe_event *pev,\n\t\t\t     struct probe_trace_event *tev, struct map *map,\n\t\t\t     struct symbol *sym)\n{\n\tint lep_offset;\n\n\t \n\tif (pev->point.offset || !map || !sym)\n\t\treturn;\n\n\t \n\tif (!pev->uprobes && pev->point.retprobe) {\n#ifdef HAVE_LIBELF_SUPPORT\n\t\tif (!kretprobe_offset_is_supported())\n#endif\n\t\t\treturn;\n\t}\n\n\tlep_offset = PPC64_LOCAL_ENTRY_OFFSET(sym->arch_sym);\n\n\tif (map__dso(map)->symtab_type == DSO_BINARY_TYPE__KALLSYMS)\n\t\ttev->point.offset += PPC64LE_LEP_OFFSET;\n\telse if (lep_offset) {\n\t\tif (pev->uprobes)\n\t\t\ttev->point.address += lep_offset;\n\t\telse\n\t\t\ttev->point.offset += lep_offset;\n\t}\n}\n\n#ifdef HAVE_LIBELF_SUPPORT\nvoid arch__post_process_probe_trace_events(struct perf_probe_event *pev,\n\t\t\t\t\t   int ntevs)\n{\n\tstruct probe_trace_event *tev;\n\tstruct map *map;\n\tstruct symbol *sym = NULL;\n\tstruct rb_node *tmp;\n\tint i = 0;\n\n\tmap = get_target_map(pev->target, pev->nsi, pev->uprobes);\n\tif (!map || map__load(map) < 0)\n\t\treturn;\n\n\tfor (i = 0; i < ntevs; i++) {\n\t\ttev = &pev->tevs[i];\n\t\tmap__for_each_symbol(map, sym, tmp) {\n\t\t\tif (map__unmap_ip(map, sym->start) == tev->point.address) {\n\t\t\t\tarch__fix_tev_from_maps(pev, tev, map, sym);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}