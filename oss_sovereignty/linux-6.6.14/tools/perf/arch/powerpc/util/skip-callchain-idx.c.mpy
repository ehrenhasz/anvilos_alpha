{
  "module_name": "skip-callchain-idx.c",
  "hash_id": "378e67d4d386038492e37ddd80b5029bc1596045bee91132d90d7e13f855e27c",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/powerpc/util/skip-callchain-idx.c",
  "human_readable_source": "\n \n#include <inttypes.h>\n#include <dwarf.h>\n#include <elfutils/libdwfl.h>\n\n#include \"util/thread.h\"\n#include \"util/callchain.h\"\n#include \"util/debug.h\"\n#include \"util/dso.h\"\n#include \"util/event.h\" \n#include \"util/map.h\"\n#include \"util/symbol.h\"\n\n \nstatic char *debuginfo_path;\n\nstatic const Dwfl_Callbacks offline_callbacks = {\n\t.debuginfo_path = &debuginfo_path,\n\t.find_debuginfo = dwfl_standard_find_debuginfo,\n\t.section_address = dwfl_offline_section_address,\n};\n\n\n \nstatic int check_return_reg(int ra_regno, Dwarf_Frame *frame)\n{\n\tDwarf_Op ops_mem[3];\n\tDwarf_Op dummy;\n\tDwarf_Op *ops = &dummy;\n\tsize_t nops;\n\tint result;\n\n\tresult = dwarf_frame_register(frame, ra_regno, ops_mem, &ops, &nops);\n\tif (result < 0) {\n\t\tpr_debug(\"dwarf_frame_register() %s\\n\", dwarf_errmsg(-1));\n\t\treturn -1;\n\t}\n\n\t \n\tif ((nops != 0 || ops != NULL) &&\n\t\t!(nops == 1 && ops[0].atom == DW_OP_regx &&\n\t\t\tops[0].number2 == 0 && ops[0].offset == 0))\n\t\treturn 0;\n\n\t \n\tresult = dwarf_frame_cfa(frame, &ops, &nops);\n\tif (result < 0) {\n\t\tpr_debug(\"dwarf_frame_cfa() returns %d, %s\\n\", result,\n\t\t\t\t\tdwarf_errmsg(-1));\n\t\treturn -1;\n\t}\n\n\t \n\tif (nops == 1 && ops[0].atom == DW_OP_bregx && ops[0].number == 1 &&\n\t\t\t\tops[0].number2 == 0)\n\t\treturn 1;\n\n\t \n\treturn 2;\n}\n\n \nstatic Dwarf_Frame *get_eh_frame(Dwfl_Module *mod, Dwarf_Addr pc)\n{\n\tint\t\tresult;\n\tDwarf_Addr\tbias;\n\tDwarf_CFI\t*cfi;\n\tDwarf_Frame\t*frame;\n\n\tcfi = dwfl_module_eh_cfi(mod, &bias);\n\tif (!cfi) {\n\t\tpr_debug(\"%s(): no CFI - %s\\n\", __func__, dwfl_errmsg(-1));\n\t\treturn NULL;\n\t}\n\n\tresult = dwarf_cfi_addrframe(cfi, pc-bias, &frame);\n\tif (result) {\n\t\tpr_debug(\"%s(): %s\\n\", __func__, dwfl_errmsg(-1));\n\t\treturn NULL;\n\t}\n\n\treturn frame;\n}\n\n \nstatic Dwarf_Frame *get_dwarf_frame(Dwfl_Module *mod, Dwarf_Addr pc)\n{\n\tDwarf_CFI       *cfi;\n\tDwarf_Addr      bias;\n\tDwarf_Frame     *frame;\n\tint             result;\n\n\tcfi = dwfl_module_dwarf_cfi(mod, &bias);\n\tif (!cfi) {\n\t\tpr_debug(\"%s(): no CFI - %s\\n\", __func__, dwfl_errmsg(-1));\n\t\treturn NULL;\n\t}\n\n\tresult = dwarf_cfi_addrframe(cfi, pc-bias, &frame);\n\tif (result) {\n\t\tpr_debug(\"%s(): %s\\n\", __func__, dwfl_errmsg(-1));\n\t\treturn NULL;\n\t}\n\n\treturn frame;\n}\n\n \nstatic int check_return_addr(struct dso *dso, u64 map_start, Dwarf_Addr pc)\n{\n\tint\t\trc = -1;\n\tDwfl\t\t*dwfl;\n\tDwfl_Module\t*mod;\n\tDwarf_Frame\t*frame;\n\tint\t\tra_regno;\n\tDwarf_Addr\tstart = pc;\n\tDwarf_Addr\tend = pc;\n\tbool\t\tsignalp;\n\tconst char\t*exec_file = dso->long_name;\n\n\tdwfl = dso->dwfl;\n\n\tif (!dwfl) {\n\t\tdwfl = dwfl_begin(&offline_callbacks);\n\t\tif (!dwfl) {\n\t\t\tpr_debug(\"dwfl_begin() failed: %s\\n\", dwarf_errmsg(-1));\n\t\t\treturn -1;\n\t\t}\n\n\t\tmod = dwfl_report_elf(dwfl, exec_file, exec_file, -1,\n\t\t\t\t\t\tmap_start, false);\n\t\tif (!mod) {\n\t\t\tpr_debug(\"dwfl_report_elf() failed %s\\n\",\n\t\t\t\t\t\tdwarf_errmsg(-1));\n\t\t\t \n\t\t\tdwfl_end(dwfl);\n\t\t\tgoto out;\n\t\t}\n\t\tdso->dwfl = dwfl;\n\t}\n\n\tmod = dwfl_addrmodule(dwfl, pc);\n\tif (!mod) {\n\t\tpr_debug(\"dwfl_addrmodule() failed, %s\\n\", dwarf_errmsg(-1));\n\t\tgoto out;\n\t}\n\n\t \n\tframe = get_eh_frame(mod, pc);\n\tif (!frame) {\n\t\tframe = get_dwarf_frame(mod, pc);\n\t\tif (!frame)\n\t\t\tgoto out;\n\t}\n\n\tra_regno = dwarf_frame_info(frame, &start, &end, &signalp);\n\tif (ra_regno < 0) {\n\t\tpr_debug(\"Return address register unavailable: %s\\n\",\n\t\t\t\tdwarf_errmsg(-1));\n\t\tgoto out;\n\t}\n\n\trc = check_return_reg(ra_regno, frame);\n\nout:\n\treturn rc;\n}\n\n \nint arch_skip_callchain_idx(struct thread *thread, struct ip_callchain *chain)\n{\n\tstruct addr_location al;\n\tstruct dso *dso = NULL;\n\tint rc;\n\tu64 ip;\n\tu64 skip_slot = -1;\n\n\tif (!chain || chain->nr < 3)\n\t\treturn skip_slot;\n\n\taddr_location__init(&al);\n\tip = chain->ips[1];\n\n\tthread__find_symbol(thread, PERF_RECORD_MISC_USER, ip, &al);\n\n\tif (al.map)\n\t\tdso = map__dso(al.map);\n\n\tif (!dso) {\n\t\tpr_debug(\"%\" PRIx64 \" dso is NULL\\n\", ip);\n\t\taddr_location__exit(&al);\n\t\treturn skip_slot;\n\t}\n\n\trc = check_return_addr(dso, map__start(al.map), ip);\n\n\tpr_debug(\"[DSO %s, sym %s, ip 0x%\" PRIx64 \"] rc %d\\n\",\n\t\t\t\tdso->long_name, al.sym->name, ip, rc);\n\n\tif (rc == 0) {\n\t\t \n\t\tskip_slot = 2;\n\t} else if (rc == 2) {\n\t\t \n\t\tskip_slot = 3;\n\t}\n\n\taddr_location__exit(&al);\n\treturn skip_slot;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}