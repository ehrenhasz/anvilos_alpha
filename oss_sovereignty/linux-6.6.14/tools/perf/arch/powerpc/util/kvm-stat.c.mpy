{
  "module_name": "kvm-stat.c",
  "hash_id": "05f601dbfe858f7208aa9dcb74596cb33e137408cf89ca7b742489d796a909f2",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/arch/powerpc/util/kvm-stat.c",
  "human_readable_source": "\n#include <errno.h>\n#include \"util/kvm-stat.h\"\n#include \"util/parse-events.h\"\n#include \"util/debug.h\"\n#include \"util/evsel.h\"\n#include \"util/evlist.h\"\n#include \"util/pmus.h\"\n\n#include \"book3s_hv_exits.h\"\n#include \"book3s_hcalls.h\"\n#include <subcmd/parse-options.h>\n\n#define NR_TPS 4\n\nconst char *vcpu_id_str = \"vcpu_id\";\nconst char *kvm_entry_trace = \"kvm_hv:kvm_guest_enter\";\nconst char *kvm_exit_trace = \"kvm_hv:kvm_guest_exit\";\n\ndefine_exit_reasons_table(hv_exit_reasons, kvm_trace_symbol_exit);\ndefine_exit_reasons_table(hcall_reasons, kvm_trace_symbol_hcall);\n\n \nconst char *ppc_book3s_hv_kvm_tp[] = {\n\t\"kvm_hv:kvm_guest_enter\",\n\t\"kvm_hv:kvm_guest_exit\",\n\t\"kvm_hv:kvm_hcall_enter\",\n\t\"kvm_hv:kvm_hcall_exit\",\n\tNULL,\n};\n\n \nconst char *kvm_events_tp[NR_TPS + 1];\nconst char *kvm_exit_reason;\n\nstatic void hcall_event_get_key(struct evsel *evsel,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct event_key *key)\n{\n\tkey->info = 0;\n\tkey->key = evsel__intval(evsel, sample, \"req\");\n}\n\nstatic const char *get_hcall_exit_reason(u64 exit_code)\n{\n\tstruct exit_reasons_table *tbl = hcall_reasons;\n\n\twhile (tbl->reason != NULL) {\n\t\tif (tbl->exit_code == exit_code)\n\t\t\treturn tbl->reason;\n\t\ttbl++;\n\t}\n\n\tpr_debug(\"Unknown hcall code: %lld\\n\",\n\t       (unsigned long long)exit_code);\n\treturn \"UNKNOWN\";\n}\n\nstatic bool hcall_event_end(struct evsel *evsel,\n\t\t\t    struct perf_sample *sample __maybe_unused,\n\t\t\t    struct event_key *key __maybe_unused)\n{\n\treturn (evsel__name_is(evsel, kvm_events_tp[3]));\n}\n\nstatic bool hcall_event_begin(struct evsel *evsel,\n\t\t\t      struct perf_sample *sample, struct event_key *key)\n{\n\tif (evsel__name_is(evsel, kvm_events_tp[2])) {\n\t\thcall_event_get_key(evsel, sample, key);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nstatic void hcall_event_decode_key(struct perf_kvm_stat *kvm __maybe_unused,\n\t\t\t\t   struct event_key *key,\n\t\t\t\t   char *decode)\n{\n\tconst char *hcall_reason = get_hcall_exit_reason(key->key);\n\n\tscnprintf(decode, KVM_EVENT_NAME_LEN, \"%s\", hcall_reason);\n}\n\nstatic struct kvm_events_ops hcall_events = {\n\t.is_begin_event = hcall_event_begin,\n\t.is_end_event = hcall_event_end,\n\t.decode_key = hcall_event_decode_key,\n\t.name = \"HCALL-EVENT\",\n};\n\nstatic struct kvm_events_ops exit_events = {\n\t.is_begin_event = exit_event_begin,\n\t.is_end_event = exit_event_end,\n\t.decode_key = exit_event_decode_key,\n\t.name = \"VM-EXIT\"\n};\n\nstruct kvm_reg_events_ops kvm_reg_events_ops[] = {\n\t{ .name = \"vmexit\", .ops = &exit_events },\n\t{ .name = \"hcall\", .ops = &hcall_events },\n\t{ NULL, NULL },\n};\n\nconst char * const kvm_skip_events[] = {\n\tNULL,\n};\n\n\nstatic int is_tracepoint_available(const char *str, struct evlist *evlist)\n{\n\tstruct parse_events_error err;\n\tint ret;\n\n\tparse_events_error__init(&err);\n\tret = parse_events(evlist, str, &err);\n\tif (err.str)\n\t\tparse_events_error__print(&err, \"tracepoint\");\n\tparse_events_error__exit(&err);\n\treturn ret;\n}\n\nstatic int ppc__setup_book3s_hv(struct perf_kvm_stat *kvm,\n\t\t\t\tstruct evlist *evlist)\n{\n\tconst char **events_ptr;\n\tint i, nr_tp = 0, err = -1;\n\n\t \n\tfor (events_ptr = ppc_book3s_hv_kvm_tp; *events_ptr; events_ptr++) {\n\t\terr = is_tracepoint_available(*events_ptr, evlist);\n\t\tif (err)\n\t\t\treturn -1;\n\t\tnr_tp++;\n\t}\n\n\tfor (i = 0; i < nr_tp; i++)\n\t\tkvm_events_tp[i] = ppc_book3s_hv_kvm_tp[i];\n\n\tkvm_events_tp[i] = NULL;\n\tkvm_exit_reason = \"trap\";\n\tkvm->exit_reasons = hv_exit_reasons;\n\tkvm->exit_reasons_isa = \"HV\";\n\n\treturn 0;\n}\n\n \nstatic int ppc__setup_kvm_tp(struct perf_kvm_stat *kvm)\n{\n\tstruct evlist *evlist = evlist__new();\n\n\tif (evlist == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\treturn ppc__setup_book3s_hv(kvm, evlist);\n}\n\nint setup_kvm_events_tp(struct perf_kvm_stat *kvm)\n{\n\treturn ppc__setup_kvm_tp(kvm);\n}\n\nint cpu_isa_init(struct perf_kvm_stat *kvm, const char *cpuid __maybe_unused)\n{\n\tint ret;\n\n\tret = ppc__setup_kvm_tp(kvm);\n\tif (ret) {\n\t\tkvm->exit_reasons = NULL;\n\t\tkvm->exit_reasons_isa = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nint kvm_add_default_arch_event(int *argc, const char **argv)\n{\n\tconst char **tmp;\n\tbool event = false;\n\tint i, j = *argc;\n\n\tconst struct option event_options[] = {\n\t\tOPT_BOOLEAN('e', \"event\", &event, NULL),\n\t\tOPT_END()\n\t};\n\n\ttmp = calloc(j + 1, sizeof(char *));\n\tif (!tmp)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < j; i++)\n\t\ttmp[i] = argv[i];\n\n\tparse_options(j, tmp, event_options, NULL, PARSE_OPT_KEEP_UNKNOWN);\n\tif (!event) {\n\t\tif (perf_pmus__have_event(\"trace_imc\", \"trace_cycles\")) {\n\t\t\targv[j++] = strdup(\"-e\");\n\t\t\targv[j++] = strdup(\"trace_imc/trace_cycles/\");\n\t\t\t*argc += 2;\n\t\t} else {\n\t\t\tfree(tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfree(tmp);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}