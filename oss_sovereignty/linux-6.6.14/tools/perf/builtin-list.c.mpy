{
  "module_name": "builtin-list.c",
  "hash_id": "2e8be200ea496c5aee2c69d92da341edf23841679145e9eaae2d047aae75c2ee",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-list.c",
  "human_readable_source": "\n \n#include \"builtin.h\"\n\n#include \"util/print-events.h\"\n#include \"util/pmus.h\"\n#include \"util/pmu.h\"\n#include \"util/debug.h\"\n#include \"util/metricgroup.h\"\n#include \"util/pfm.h\"\n#include \"util/string2.h\"\n#include \"util/strlist.h\"\n#include \"util/strbuf.h\"\n#include <subcmd/pager.h>\n#include <subcmd/parse-options.h>\n#include <linux/zalloc.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n \nstruct print_state {\n\t \n\tchar *pmu_glob;\n\t \n\tchar *event_glob;\n\t \n\tbool name_only;\n\t \n\tbool desc;\n\t \n\tbool long_desc;\n\t \n\tbool deprecated;\n\t \n\tbool detailed;\n\t \n\tbool metrics;\n\t \n\tbool metricgroups;\n\t \n\tchar *last_topic;\n\t \n\tchar *last_metricgroups;\n\t \n\tstruct strlist *visited_metrics;\n};\n\nstatic void default_print_start(void *ps)\n{\n\tstruct print_state *print_state = ps;\n\n\tif (!print_state->name_only && pager_in_use())\n\t\tprintf(\"\\nList of pre-defined events (to be used in -e or -M):\\n\\n\");\n}\n\nstatic void default_print_end(void *print_state __maybe_unused) {}\n\nstatic void wordwrap(const char *s, int start, int max, int corr)\n{\n\tint column = start;\n\tint n;\n\tbool saw_newline = false;\n\n\twhile (*s) {\n\t\tint wlen = strcspn(s, \" \\t\\n\");\n\n\t\tif ((column + wlen >= max && column > start) || saw_newline) {\n\t\t\tprintf(\"\\n%*s\", start, \"\");\n\t\t\tcolumn = start + corr;\n\t\t}\n\t\tn = printf(\"%s%.*s\", column > start ? \" \" : \"\", wlen, s);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tsaw_newline = s[wlen] == '\\n';\n\t\ts += wlen;\n\t\tcolumn += n;\n\t\ts = skip_spaces(s);\n\t}\n}\n\nstatic void default_print_event(void *ps, const char *pmu_name, const char *topic,\n\t\t\t\tconst char *event_name, const char *event_alias,\n\t\t\t\tconst char *scale_unit __maybe_unused,\n\t\t\t\tbool deprecated, const char *event_type_desc,\n\t\t\t\tconst char *desc, const char *long_desc,\n\t\t\t\tconst char *encoding_desc)\n{\n\tstruct print_state *print_state = ps;\n\tint pos;\n\n\tif (deprecated && !print_state->deprecated)\n\t\treturn;\n\n\tif (print_state->pmu_glob && pmu_name && !strglobmatch(pmu_name, print_state->pmu_glob))\n\t\treturn;\n\n\tif (print_state->event_glob &&\n\t    (!event_name || !strglobmatch(event_name, print_state->event_glob)) &&\n\t    (!event_alias || !strglobmatch(event_alias, print_state->event_glob)) &&\n\t    (!topic || !strglobmatch_nocase(topic, print_state->event_glob)))\n\t\treturn;\n\n\tif (print_state->name_only) {\n\t\tif (event_alias && strlen(event_alias))\n\t\t\tprintf(\"%s \", event_alias);\n\t\telse\n\t\t\tprintf(\"%s \", event_name);\n\t\treturn;\n\t}\n\n\tif (strcmp(print_state->last_topic, topic ?: \"\")) {\n\t\tif (topic)\n\t\t\tprintf(\"\\n%s:\\n\", topic);\n\t\tzfree(&print_state->last_topic);\n\t\tprint_state->last_topic = strdup(topic ?: \"\");\n\t}\n\n\tif (event_alias && strlen(event_alias))\n\t\tpos = printf(\"  %s OR %s\", event_name, event_alias);\n\telse\n\t\tpos = printf(\"  %s\", event_name);\n\n\tif (!topic && event_type_desc) {\n\t\tfor (; pos < 53; pos++)\n\t\t\tputchar(' ');\n\t\tprintf(\"[%s]\\n\", event_type_desc);\n\t} else\n\t\tputchar('\\n');\n\n\tif (desc && print_state->desc) {\n\t\tchar *desc_with_unit = NULL;\n\t\tint desc_len = -1;\n\n\t\tif (pmu_name && strcmp(pmu_name, \"default_core\")) {\n\t\t\tdesc_len = strlen(desc);\n\t\t\tdesc_len = asprintf(&desc_with_unit,\n\t\t\t\t\t    desc[desc_len - 1] != '.'\n\t\t\t\t\t      ? \"%s. Unit: %s\" : \"%s Unit: %s\",\n\t\t\t\t\t    desc, pmu_name);\n\t\t}\n\t\tprintf(\"%*s\", 8, \"[\");\n\t\twordwrap(desc_len > 0 ? desc_with_unit : desc, 8, pager_get_columns(), 0);\n\t\tprintf(\"]\\n\");\n\t\tfree(desc_with_unit);\n\t}\n\tlong_desc = long_desc ?: desc;\n\tif (long_desc && print_state->long_desc) {\n\t\tprintf(\"%*s\", 8, \"[\");\n\t\twordwrap(long_desc, 8, pager_get_columns(), 0);\n\t\tprintf(\"]\\n\");\n\t}\n\n\tif (print_state->detailed && encoding_desc) {\n\t\tprintf(\"%*s\", 8, \"\");\n\t\twordwrap(encoding_desc, 8, pager_get_columns(), 0);\n\t\tputchar('\\n');\n\t}\n}\n\nstatic void default_print_metric(void *ps,\n\t\t\t\tconst char *group,\n\t\t\t\tconst char *name,\n\t\t\t\tconst char *desc,\n\t\t\t\tconst char *long_desc,\n\t\t\t\tconst char *expr,\n\t\t\t\tconst char *threshold,\n\t\t\t\tconst char *unit __maybe_unused)\n{\n\tstruct print_state *print_state = ps;\n\n\tif (print_state->event_glob &&\n\t    (!print_state->metrics || !name || !strglobmatch(name, print_state->event_glob)) &&\n\t    (!print_state->metricgroups || !group || !strglobmatch(group, print_state->event_glob)))\n\t\treturn;\n\n\tif (!print_state->name_only && !print_state->last_metricgroups) {\n\t\tif (print_state->metricgroups) {\n\t\t\tprintf(\"\\nMetric Groups:\\n\");\n\t\t\tif (!print_state->metrics)\n\t\t\t\tputchar('\\n');\n\t\t} else {\n\t\t\tprintf(\"\\nMetrics:\\n\\n\");\n\t\t}\n\t}\n\tif (!print_state->last_metricgroups ||\n\t    strcmp(print_state->last_metricgroups, group ?: \"\")) {\n\t\tif (group && print_state->metricgroups) {\n\t\t\tif (print_state->name_only)\n\t\t\t\tprintf(\"%s \", group);\n\t\t\telse if (print_state->metrics) {\n\t\t\t\tconst char *gdesc = describe_metricgroup(group);\n\n\t\t\t\tif (gdesc)\n\t\t\t\t\tprintf(\"\\n%s: [%s]\\n\", group, gdesc);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\n%s:\\n\", group);\n\t\t\t} else\n\t\t\t\tprintf(\"%s\\n\", group);\n\t\t}\n\t\tzfree(&print_state->last_metricgroups);\n\t\tprint_state->last_metricgroups = strdup(group ?: \"\");\n\t}\n\tif (!print_state->metrics)\n\t\treturn;\n\n\tif (print_state->name_only) {\n\t\tif (print_state->metrics &&\n\t\t    !strlist__has_entry(print_state->visited_metrics, name)) {\n\t\t\tprintf(\"%s \", name);\n\t\t\tstrlist__add(print_state->visited_metrics, name);\n\t\t}\n\t\treturn;\n\t}\n\tprintf(\"  %s\\n\", name);\n\n\tif (desc && print_state->desc) {\n\t\tprintf(\"%*s\", 8, \"[\");\n\t\twordwrap(desc, 8, pager_get_columns(), 0);\n\t\tprintf(\"]\\n\");\n\t}\n\tif (long_desc && print_state->long_desc) {\n\t\tprintf(\"%*s\", 8, \"[\");\n\t\twordwrap(long_desc, 8, pager_get_columns(), 0);\n\t\tprintf(\"]\\n\");\n\t}\n\tif (expr && print_state->detailed) {\n\t\tprintf(\"%*s\", 8, \"[\");\n\t\twordwrap(expr, 8, pager_get_columns(), 0);\n\t\tprintf(\"]\\n\");\n\t}\n\tif (threshold && print_state->detailed) {\n\t\tprintf(\"%*s\", 8, \"[\");\n\t\twordwrap(threshold, 8, pager_get_columns(), 0);\n\t\tprintf(\"]\\n\");\n\t}\n}\n\nstruct json_print_state {\n\t \n\tbool need_sep;\n};\n\nstatic void json_print_start(void *print_state __maybe_unused)\n{\n\tprintf(\"[\\n\");\n}\n\nstatic void json_print_end(void *ps)\n{\n\tstruct json_print_state *print_state = ps;\n\n\tprintf(\"%s]\\n\", print_state->need_sep ? \"\\n\" : \"\");\n}\n\nstatic void fix_escape_printf(struct strbuf *buf, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tstrbuf_setlen(buf, 0);\n\tfor (size_t fmt_pos = 0; fmt_pos < strlen(fmt); fmt_pos++) {\n\t\tswitch (fmt[fmt_pos]) {\n\t\tcase '%':\n\t\t\tfmt_pos++;\n\t\t\tswitch (fmt[fmt_pos]) {\n\t\t\tcase 's': {\n\t\t\t\tconst char *s = va_arg(args, const char*);\n\n\t\t\t\tstrbuf_addstr(buf, s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'S': {\n\t\t\t\tconst char *s = va_arg(args, const char*);\n\n\t\t\t\tfor (size_t s_pos = 0; s_pos < strlen(s); s_pos++) {\n\t\t\t\t\tswitch (s[s_pos]) {\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tstrbuf_addstr(buf, \"\\\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tfallthrough;\n\t\t\t\t\tcase '\\\"':\n\t\t\t\t\t\tstrbuf_addch(buf, '\\\\');\n\t\t\t\t\t\tfallthrough;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstrbuf_addch(buf, s[s_pos]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tpr_err(\"Unexpected format character '%c'\\n\", fmt[fmt_pos]);\n\t\t\t\tstrbuf_addch(buf, '%');\n\t\t\t\tstrbuf_addch(buf, fmt[fmt_pos]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrbuf_addch(buf, fmt[fmt_pos]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tva_end(args);\n\tfputs(buf->buf, stdout);\n}\n\nstatic void json_print_event(void *ps, const char *pmu_name, const char *topic,\n\t\t\t     const char *event_name, const char *event_alias,\n\t\t\t     const char *scale_unit,\n\t\t\t     bool deprecated, const char *event_type_desc,\n\t\t\t     const char *desc, const char *long_desc,\n\t\t\t     const char *encoding_desc)\n{\n\tstruct json_print_state *print_state = ps;\n\tbool need_sep = false;\n\tstruct strbuf buf;\n\n\tstrbuf_init(&buf, 0);\n\tprintf(\"%s{\\n\", print_state->need_sep ? \",\\n\" : \"\");\n\tprint_state->need_sep = true;\n\tif (pmu_name) {\n\t\tfix_escape_printf(&buf, \"\\t\\\"Unit\\\": \\\"%S\\\"\", pmu_name);\n\t\tneed_sep = true;\n\t}\n\tif (topic) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"Topic\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\", topic);\n\t\tneed_sep = true;\n\t}\n\tif (event_name) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"EventName\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  event_name);\n\t\tneed_sep = true;\n\t}\n\tif (event_alias && strlen(event_alias)) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"EventAlias\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  event_alias);\n\t\tneed_sep = true;\n\t}\n\tif (scale_unit && strlen(scale_unit)) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"ScaleUnit\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  scale_unit);\n\t\tneed_sep = true;\n\t}\n\tif (event_type_desc) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"EventType\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  event_type_desc);\n\t\tneed_sep = true;\n\t}\n\tif (deprecated) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"Deprecated\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  deprecated ? \"1\" : \"0\");\n\t\tneed_sep = true;\n\t}\n\tif (desc) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"BriefDescription\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  desc);\n\t\tneed_sep = true;\n\t}\n\tif (long_desc) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"PublicDescription\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  long_desc);\n\t\tneed_sep = true;\n\t}\n\tif (encoding_desc) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"Encoding\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  encoding_desc);\n\t\tneed_sep = true;\n\t}\n\tprintf(\"%s}\", need_sep ? \"\\n\" : \"\");\n\tstrbuf_release(&buf);\n}\n\nstatic void json_print_metric(void *ps __maybe_unused, const char *group,\n\t\t\t      const char *name, const char *desc,\n\t\t\t      const char *long_desc, const char *expr,\n\t\t\t      const char *threshold, const char *unit)\n{\n\tstruct json_print_state *print_state = ps;\n\tbool need_sep = false;\n\tstruct strbuf buf;\n\n\tstrbuf_init(&buf, 0);\n\tprintf(\"%s{\\n\", print_state->need_sep ? \",\\n\" : \"\");\n\tprint_state->need_sep = true;\n\tif (group) {\n\t\tfix_escape_printf(&buf, \"\\t\\\"MetricGroup\\\": \\\"%S\\\"\", group);\n\t\tneed_sep = true;\n\t}\n\tif (name) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"MetricName\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\", name);\n\t\tneed_sep = true;\n\t}\n\tif (expr) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"MetricExpr\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\", expr);\n\t\tneed_sep = true;\n\t}\n\tif (threshold) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"MetricThreshold\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  threshold);\n\t\tneed_sep = true;\n\t}\n\tif (unit) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"ScaleUnit\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\", unit);\n\t\tneed_sep = true;\n\t}\n\tif (desc) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"BriefDescription\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  desc);\n\t\tneed_sep = true;\n\t}\n\tif (long_desc) {\n\t\tfix_escape_printf(&buf, \"%s\\t\\\"PublicDescription\\\": \\\"%S\\\"\", need_sep ? \",\\n\" : \"\",\n\t\t\t\t  long_desc);\n\t\tneed_sep = true;\n\t}\n\tprintf(\"%s}\", need_sep ? \"\\n\" : \"\");\n\tstrbuf_release(&buf);\n}\n\nstatic bool json_skip_duplicate_pmus(void *ps __maybe_unused)\n{\n\treturn false;\n}\n\nstatic bool default_skip_duplicate_pmus(void *ps)\n{\n\tstruct print_state *print_state = ps;\n\n\treturn !print_state->long_desc;\n}\n\nint cmd_list(int argc, const char **argv)\n{\n\tint i, ret = 0;\n\tstruct print_state default_ps = {};\n\tstruct print_state json_ps = {};\n\tvoid *ps = &default_ps;\n\tstruct print_callbacks print_cb = {\n\t\t.print_start = default_print_start,\n\t\t.print_end = default_print_end,\n\t\t.print_event = default_print_event,\n\t\t.print_metric = default_print_metric,\n\t\t.skip_duplicate_pmus = default_skip_duplicate_pmus,\n\t};\n\tconst char *cputype = NULL;\n\tconst char *unit_name = NULL;\n\tbool json = false;\n\tstruct option list_options[] = {\n\t\tOPT_BOOLEAN(0, \"raw-dump\", &default_ps.name_only, \"Dump raw events\"),\n\t\tOPT_BOOLEAN('j', \"json\", &json, \"JSON encode events and metrics\"),\n\t\tOPT_BOOLEAN('d', \"desc\", &default_ps.desc,\n\t\t\t    \"Print extra event descriptions. --no-desc to not print.\"),\n\t\tOPT_BOOLEAN('v', \"long-desc\", &default_ps.long_desc,\n\t\t\t    \"Print longer event descriptions.\"),\n\t\tOPT_BOOLEAN(0, \"details\", &default_ps.detailed,\n\t\t\t    \"Print information on the perf event names and expressions used internally by events.\"),\n\t\tOPT_BOOLEAN(0, \"deprecated\", &default_ps.deprecated,\n\t\t\t    \"Print deprecated events.\"),\n\t\tOPT_STRING(0, \"cputype\", &cputype, \"cpu type\",\n\t\t\t   \"Limit PMU or metric printing to the given PMU (e.g. cpu, core or atom).\"),\n\t\tOPT_STRING(0, \"unit\", &unit_name, \"PMU name\",\n\t\t\t   \"Limit PMU or metric printing to the specified PMU.\"),\n\t\tOPT_INCR(0, \"debug\", &verbose,\n\t\t\t     \"Enable debugging output\"),\n\t\tOPT_END()\n\t};\n\tconst char * const list_usage[] = {\n#ifdef HAVE_LIBPFM\n\t\t\"perf list [<options>] [hw|sw|cache|tracepoint|pmu|sdt|metric|metricgroup|event_glob|pfm]\",\n#else\n\t\t\"perf list [<options>] [hw|sw|cache|tracepoint|pmu|sdt|metric|metricgroup|event_glob]\",\n#endif\n\t\tNULL\n\t};\n\n\tset_option_flag(list_options, 0, \"raw-dump\", PARSE_OPT_HIDDEN);\n\t \n\tset_option_flag(list_options, 0, \"cputype\", PARSE_OPT_HIDDEN);\n\n\targc = parse_options(argc, argv, list_options, list_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tsetup_pager();\n\n\tif (!default_ps.name_only)\n\t\tsetup_pager();\n\n\tif (json) {\n\t\tprint_cb = (struct print_callbacks){\n\t\t\t.print_start = json_print_start,\n\t\t\t.print_end = json_print_end,\n\t\t\t.print_event = json_print_event,\n\t\t\t.print_metric = json_print_metric,\n\t\t\t.skip_duplicate_pmus = json_skip_duplicate_pmus,\n\t\t};\n\t\tps = &json_ps;\n\t} else {\n\t\tdefault_ps.desc = !default_ps.long_desc;\n\t\tdefault_ps.last_topic = strdup(\"\");\n\t\tassert(default_ps.last_topic);\n\t\tdefault_ps.visited_metrics = strlist__new(NULL, NULL);\n\t\tassert(default_ps.visited_metrics);\n\t\tif (unit_name)\n\t\t\tdefault_ps.pmu_glob = strdup(unit_name);\n\t\telse if (cputype) {\n\t\t\tconst struct perf_pmu *pmu = perf_pmus__pmu_for_pmu_filter(cputype);\n\n\t\t\tif (!pmu) {\n\t\t\t\tpr_err(\"ERROR: cputype is not supported!\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdefault_ps.pmu_glob = strdup(pmu->name);\n\t\t}\n\t}\n\tprint_cb.print_start(ps);\n\n\tif (argc == 0) {\n\t\tdefault_ps.metrics = true;\n\t\tdefault_ps.metricgroups = true;\n\t\tprint_events(&print_cb, ps);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tchar *sep, *s;\n\n\t\tif (strcmp(argv[i], \"tracepoint\") == 0)\n\t\t\tprint_tracepoint_events(&print_cb, ps);\n\t\telse if (strcmp(argv[i], \"hw\") == 0 ||\n\t\t\t strcmp(argv[i], \"hardware\") == 0)\n\t\t\tprint_symbol_events(&print_cb, ps, PERF_TYPE_HARDWARE,\n\t\t\t\t\tevent_symbols_hw, PERF_COUNT_HW_MAX);\n\t\telse if (strcmp(argv[i], \"sw\") == 0 ||\n\t\t\t strcmp(argv[i], \"software\") == 0) {\n\t\t\tprint_symbol_events(&print_cb, ps, PERF_TYPE_SOFTWARE,\n\t\t\t\t\tevent_symbols_sw, PERF_COUNT_SW_MAX);\n\t\t\tprint_tool_events(&print_cb, ps);\n\t\t} else if (strcmp(argv[i], \"cache\") == 0 ||\n\t\t\t strcmp(argv[i], \"hwcache\") == 0)\n\t\t\tprint_hwcache_events(&print_cb, ps);\n\t\telse if (strcmp(argv[i], \"pmu\") == 0)\n\t\t\tperf_pmus__print_pmu_events(&print_cb, ps);\n\t\telse if (strcmp(argv[i], \"sdt\") == 0)\n\t\t\tprint_sdt_events(&print_cb, ps);\n\t\telse if (strcmp(argv[i], \"metric\") == 0 || strcmp(argv[i], \"metrics\") == 0) {\n\t\t\tdefault_ps.metricgroups = false;\n\t\t\tdefault_ps.metrics = true;\n\t\t\tmetricgroup__print(&print_cb, ps);\n\t\t} else if (strcmp(argv[i], \"metricgroup\") == 0 ||\n\t\t\t   strcmp(argv[i], \"metricgroups\") == 0) {\n\t\t\tdefault_ps.metricgroups = true;\n\t\t\tdefault_ps.metrics = false;\n\t\t\tmetricgroup__print(&print_cb, ps);\n\t\t}\n#ifdef HAVE_LIBPFM\n\t\telse if (strcmp(argv[i], \"pfm\") == 0)\n\t\t\tprint_libpfm_events(&print_cb, ps);\n#endif\n\t\telse if ((sep = strchr(argv[i], ':')) != NULL) {\n\t\t\tchar *old_pmu_glob = default_ps.pmu_glob;\n\n\t\t\tdefault_ps.event_glob = strdup(argv[i]);\n\t\t\tif (!default_ps.event_glob) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tprint_tracepoint_events(&print_cb, ps);\n\t\t\tprint_sdt_events(&print_cb, ps);\n\t\t\tdefault_ps.metrics = true;\n\t\t\tdefault_ps.metricgroups = true;\n\t\t\tmetricgroup__print(&print_cb, ps);\n\t\t\tzfree(&default_ps.event_glob);\n\t\t\tdefault_ps.pmu_glob = old_pmu_glob;\n\t\t} else {\n\t\t\tif (asprintf(&s, \"*%s*\", argv[i]) < 0) {\n\t\t\t\tprintf(\"Critical: Not enough memory! Trying to continue...\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdefault_ps.event_glob = s;\n\t\t\tprint_symbol_events(&print_cb, ps, PERF_TYPE_HARDWARE,\n\t\t\t\t\tevent_symbols_hw, PERF_COUNT_HW_MAX);\n\t\t\tprint_symbol_events(&print_cb, ps, PERF_TYPE_SOFTWARE,\n\t\t\t\t\tevent_symbols_sw, PERF_COUNT_SW_MAX);\n\t\t\tprint_tool_events(&print_cb, ps);\n\t\t\tprint_hwcache_events(&print_cb, ps);\n\t\t\tperf_pmus__print_pmu_events(&print_cb, ps);\n\t\t\tprint_tracepoint_events(&print_cb, ps);\n\t\t\tprint_sdt_events(&print_cb, ps);\n\t\t\tdefault_ps.metrics = true;\n\t\t\tdefault_ps.metricgroups = true;\n\t\t\tmetricgroup__print(&print_cb, ps);\n\t\t\tfree(s);\n\t\t}\n\t}\n\nout:\n\tprint_cb.print_end(ps);\n\tfree(default_ps.pmu_glob);\n\tfree(default_ps.last_topic);\n\tfree(default_ps.last_metricgroups);\n\tstrlist__delete(default_ps.visited_metrics);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}