{
  "module_name": "builtin-help.c",
  "hash_id": "3ac51ba5553f14239db3bba964746d1555698f8065406776e39aeb6745e46bc5",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-help.c",
  "human_readable_source": "\n \n#include \"util/cache.h\"\n#include \"util/config.h\"\n#include \"util/strbuf.h\"\n#include \"builtin.h\"\n#include <subcmd/exec-cmd.h>\n#include \"common-cmds.h\"\n#include <subcmd/parse-options.h>\n#include <subcmd/run-command.h>\n#include <subcmd/help.h>\n#include \"util/debug.h\"\n#include \"util/util.h\"\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic struct man_viewer_list {\n\tstruct man_viewer_list *next;\n\tchar name[0];\n} *man_viewer_list;\n\nstatic struct man_viewer_info_list {\n\tstruct man_viewer_info_list *next;\n\tconst char *info;\n\tchar name[0];\n} *man_viewer_info_list;\n\nenum help_format {\n\tHELP_FORMAT_NONE,\n\tHELP_FORMAT_MAN,\n\tHELP_FORMAT_INFO,\n\tHELP_FORMAT_WEB,\n};\n\nstatic enum help_format parse_help_format(const char *format)\n{\n\tif (!strcmp(format, \"man\"))\n\t\treturn HELP_FORMAT_MAN;\n\tif (!strcmp(format, \"info\"))\n\t\treturn HELP_FORMAT_INFO;\n\tif (!strcmp(format, \"web\") || !strcmp(format, \"html\"))\n\t\treturn HELP_FORMAT_WEB;\n\n\tpr_err(\"unrecognized help format '%s'\", format);\n\treturn HELP_FORMAT_NONE;\n}\n\nstatic const char *get_man_viewer_info(const char *name)\n{\n\tstruct man_viewer_info_list *viewer;\n\n\tfor (viewer = man_viewer_info_list; viewer; viewer = viewer->next) {\n\t\tif (!strcasecmp(name, viewer->name))\n\t\t\treturn viewer->info;\n\t}\n\treturn NULL;\n}\n\nstatic int check_emacsclient_version(void)\n{\n\tstruct strbuf buffer = STRBUF_INIT;\n\tstruct child_process ec_process;\n\tconst char *argv_ec[] = { \"emacsclient\", \"--version\", NULL };\n\tint version;\n\tint ret = -1;\n\n\t \n\tmemset(&ec_process, 0, sizeof(ec_process));\n\tec_process.argv = argv_ec;\n\tec_process.err = -1;\n\tec_process.stdout_to_stderr = 1;\n\tif (start_command(&ec_process)) {\n\t\tfprintf(stderr, \"Failed to start emacsclient.\\n\");\n\t\treturn -1;\n\t}\n\tif (strbuf_read(&buffer, ec_process.err, 20) < 0) {\n\t\tfprintf(stderr, \"Failed to read emacsclient version\\n\");\n\t\tgoto out;\n\t}\n\tclose(ec_process.err);\n\n\t \n\tfinish_command(&ec_process);\n\n\tif (!strstarts(buffer.buf, \"emacsclient\")) {\n\t\tfprintf(stderr, \"Failed to parse emacsclient version.\\n\");\n\t\tgoto out;\n\t}\n\n\tversion = atoi(buffer.buf + strlen(\"emacsclient\"));\n\n\tif (version < 22) {\n\t\tfprintf(stderr,\n\t\t\t\"emacsclient version '%d' too old (< 22).\\n\",\n\t\t\tversion);\n\t} else\n\t\tret = 0;\nout:\n\tstrbuf_release(&buffer);\n\treturn ret;\n}\n\nstatic void exec_failed(const char *cmd)\n{\n\tchar sbuf[STRERR_BUFSIZE];\n\tpr_warning(\"failed to exec '%s': %s\", cmd, str_error_r(errno, sbuf, sizeof(sbuf)));\n}\n\nstatic void exec_woman_emacs(const char *path, const char *page)\n{\n\tif (!check_emacsclient_version()) {\n\t\t \n\t\tchar *man_page;\n\n\t\tif (!path)\n\t\t\tpath = \"emacsclient\";\n\t\tif (asprintf(&man_page, \"(woman \\\"%s\\\")\", page) > 0) {\n\t\t\texeclp(path, \"emacsclient\", \"-e\", man_page, NULL);\n\t\t\tfree(man_page);\n\t\t}\n\t\texec_failed(path);\n\t}\n}\n\nstatic void exec_man_konqueror(const char *path, const char *page)\n{\n\tconst char *display = getenv(\"DISPLAY\");\n\n\tif (display && *display) {\n\t\tchar *man_page;\n\t\tconst char *filename = \"kfmclient\";\n\n\t\t \n\t\tif (path) {\n\t\t\tconst char *file = strrchr(path, '/');\n\t\t\tif (file && !strcmp(file + 1, \"konqueror\")) {\n\t\t\t\tchar *new = strdup(path);\n\t\t\t\tchar *dest = strrchr(new, '/');\n\n\t\t\t\t \n\t\t\t\tstrcpy(dest + 1, \"kfmclient\");\n\t\t\t\tpath = new;\n\t\t\t}\n\t\t\tif (file)\n\t\t\t\tfilename = file;\n\t\t} else\n\t\t\tpath = \"kfmclient\";\n\t\tif (asprintf(&man_page, \"man:%s(1)\", page) > 0) {\n\t\t\texeclp(path, filename, \"newTab\", man_page, NULL);\n\t\t\tfree(man_page);\n\t\t}\n\t\texec_failed(path);\n\t}\n}\n\nstatic void exec_man_man(const char *path, const char *page)\n{\n\tif (!path)\n\t\tpath = \"man\";\n\texeclp(path, \"man\", page, NULL);\n\texec_failed(path);\n}\n\nstatic void exec_man_cmd(const char *cmd, const char *page)\n{\n\tchar *shell_cmd;\n\n\tif (asprintf(&shell_cmd, \"%s %s\", cmd, page) > 0) {\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", shell_cmd, NULL);\n\t\tfree(shell_cmd);\n\t}\n\texec_failed(cmd);\n}\n\nstatic void add_man_viewer(const char *name)\n{\n\tstruct man_viewer_list **p = &man_viewer_list;\n\tsize_t len = strlen(name);\n\n\twhile (*p)\n\t\tp = &((*p)->next);\n\t*p = zalloc(sizeof(**p) + len + 1);\n\tstrcpy((*p)->name, name);\n}\n\nstatic int supported_man_viewer(const char *name, size_t len)\n{\n\treturn (!strncasecmp(\"man\", name, len) ||\n\t\t!strncasecmp(\"woman\", name, len) ||\n\t\t!strncasecmp(\"konqueror\", name, len));\n}\n\nstatic void do_add_man_viewer_info(const char *name,\n\t\t\t\t   size_t len,\n\t\t\t\t   const char *value)\n{\n\tstruct man_viewer_info_list *new = zalloc(sizeof(*new) + len + 1);\n\n\tstrncpy(new->name, name, len);\n\tnew->info = strdup(value);\n\tnew->next = man_viewer_info_list;\n\tman_viewer_info_list = new;\n}\n\nstatic void unsupported_man_viewer(const char *name, const char *var)\n{\n\tpr_warning(\"'%s': path for unsupported man viewer.\\n\"\n\t\t   \"Please consider using 'man.<tool>.%s' instead.\", name, var);\n}\n\nstatic int add_man_viewer_path(const char *name,\n\t\t\t       size_t len,\n\t\t\t       const char *value)\n{\n\tif (supported_man_viewer(name, len))\n\t\tdo_add_man_viewer_info(name, len, value);\n\telse\n\t\tunsupported_man_viewer(name, \"cmd\");\n\n\treturn 0;\n}\n\nstatic int add_man_viewer_cmd(const char *name,\n\t\t\t      size_t len,\n\t\t\t      const char *value)\n{\n\tif (supported_man_viewer(name, len))\n\t\tunsupported_man_viewer(name, \"path\");\n\telse\n\t\tdo_add_man_viewer_info(name, len, value);\n\n\treturn 0;\n}\n\nstatic int add_man_viewer_info(const char *var, const char *value)\n{\n\tconst char *name = var + 4;\n\tconst char *subkey = strrchr(name, '.');\n\n\tif (!subkey) {\n\t\tpr_err(\"Config with no key for man viewer: %s\", name);\n\t\treturn -1;\n\t}\n\n\tif (!strcmp(subkey, \".path\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\treturn add_man_viewer_path(name, subkey - name, value);\n\t}\n\tif (!strcmp(subkey, \".cmd\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\treturn add_man_viewer_cmd(name, subkey - name, value);\n\t}\n\n\tpr_warning(\"'%s': unsupported man viewer sub key.\", subkey);\n\treturn 0;\n}\n\nstatic int perf_help_config(const char *var, const char *value, void *cb)\n{\n\tenum help_format *help_formatp = cb;\n\n\tif (!strcmp(var, \"help.format\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\t*help_formatp = parse_help_format(value);\n\t\tif (*help_formatp == HELP_FORMAT_NONE)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"man.viewer\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tadd_man_viewer(value);\n\t\treturn 0;\n\t}\n\tif (strstarts(var, \"man.\"))\n\t\treturn add_man_viewer_info(var, value);\n\n\treturn 0;\n}\n\nstatic struct cmdnames main_cmds, other_cmds;\n\nvoid list_common_cmds_help(void)\n{\n\tunsigned int i, longest = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(common_cmds); i++) {\n\t\tif (longest < strlen(common_cmds[i].name))\n\t\t\tlongest = strlen(common_cmds[i].name);\n\t}\n\n\tputs(\" The most commonly used perf commands are:\");\n\tfor (i = 0; i < ARRAY_SIZE(common_cmds); i++) {\n\t\tprintf(\"   %-*s   \", longest, common_cmds[i].name);\n\t\tputs(common_cmds[i].help);\n\t}\n}\n\nstatic const char *cmd_to_page(const char *perf_cmd)\n{\n\tchar *s;\n\n\tif (!perf_cmd)\n\t\treturn \"perf\";\n\telse if (strstarts(perf_cmd, \"perf\"))\n\t\treturn perf_cmd;\n\n\treturn asprintf(&s, \"perf-%s\", perf_cmd) < 0 ? NULL : s;\n}\n\nstatic void setup_man_path(void)\n{\n\tchar *new_path;\n\tconst char *old_path = getenv(\"MANPATH\");\n\n\t \n\tif (asprintf(&new_path, \"%s:%s\", system_path(PERF_MAN_PATH), old_path ?: \"\") > 0) {\n\t\tsetenv(\"MANPATH\", new_path, 1);\n\t\tfree(new_path);\n\t} else {\n\t\tpr_err(\"Unable to setup man path\");\n\t}\n}\n\nstatic void exec_viewer(const char *name, const char *page)\n{\n\tconst char *info = get_man_viewer_info(name);\n\n\tif (!strcasecmp(name, \"man\"))\n\t\texec_man_man(info, page);\n\telse if (!strcasecmp(name, \"woman\"))\n\t\texec_woman_emacs(info, page);\n\telse if (!strcasecmp(name, \"konqueror\"))\n\t\texec_man_konqueror(info, page);\n\telse if (info)\n\t\texec_man_cmd(info, page);\n\telse\n\t\tpr_warning(\"'%s': unknown man viewer.\", name);\n}\n\nstatic int show_man_page(const char *perf_cmd)\n{\n\tstruct man_viewer_list *viewer;\n\tconst char *page = cmd_to_page(perf_cmd);\n\tconst char *fallback = getenv(\"PERF_MAN_VIEWER\");\n\n\tsetup_man_path();\n\tfor (viewer = man_viewer_list; viewer; viewer = viewer->next)\n\t\texec_viewer(viewer->name, page);  \n\n\tif (fallback)\n\t\texec_viewer(fallback, page);\n\texec_viewer(\"man\", page);\n\n\tpr_err(\"no man viewer handled the request\");\n\treturn -1;\n}\n\nstatic int show_info_page(const char *perf_cmd)\n{\n\tconst char *page = cmd_to_page(perf_cmd);\n\tsetenv(\"INFOPATH\", system_path(PERF_INFO_PATH), 1);\n\texeclp(\"info\", \"info\", \"perfman\", page, NULL);\n\treturn -1;\n}\n\nstatic int get_html_page_path(char **page_path, const char *page)\n{\n\tstruct stat st;\n\tconst char *html_path = system_path(PERF_HTML_PATH);\n\tchar path[PATH_MAX];\n\n\t \n\tif (stat(mkpath(path, sizeof(path), \"%s/perf.html\", html_path), &st)\n\t    || !S_ISREG(st.st_mode)) {\n\t\tpr_err(\"'%s': not a documentation directory.\", html_path);\n\t\treturn -1;\n\t}\n\n\treturn asprintf(page_path, \"%s/%s.html\", html_path, page);\n}\n\n \n#ifndef open_html\nstatic void open_html(const char *path)\n{\n\texecl_cmd(\"web--browse\", \"-c\", \"help.browser\", path, NULL);\n}\n#endif\n\nstatic int show_html_page(const char *perf_cmd)\n{\n\tconst char *page = cmd_to_page(perf_cmd);\n\tchar *page_path;  \n\n\tif (get_html_page_path(&page_path, page) < 0)\n\t\treturn -1;\n\n\topen_html(page_path);\n\n\treturn 0;\n}\n\nint cmd_help(int argc, const char **argv)\n{\n\tbool show_all = false;\n\tenum help_format help_format = HELP_FORMAT_MAN;\n\tstruct option builtin_help_options[] = {\n\tOPT_BOOLEAN('a', \"all\", &show_all, \"print all available commands\"),\n\tOPT_SET_UINT('m', \"man\", &help_format, \"show man page\", HELP_FORMAT_MAN),\n\tOPT_SET_UINT('w', \"web\", &help_format, \"show manual in web browser\",\n\t\t\tHELP_FORMAT_WEB),\n\tOPT_SET_UINT('i', \"info\", &help_format, \"show info page\",\n\t\t\tHELP_FORMAT_INFO),\n\tOPT_END(),\n\t};\n\tconst char * const builtin_help_subcommands[] = {\n\t\t\"buildid-cache\", \"buildid-list\", \"diff\", \"evlist\", \"help\", \"list\",\n\t\t\"record\", \"report\", \"bench\", \"stat\", \"timechart\", \"top\", \"annotate\",\n\t\t\"script\", \"sched\", \"kallsyms\", \"kmem\", \"lock\", \"kvm\", \"test\", \"inject\", \"mem\", \"data\",\n#ifdef HAVE_LIBELF_SUPPORT\n\t\t\"probe\",\n#endif\n#if defined(HAVE_LIBAUDIT_SUPPORT) || defined(HAVE_SYSCALL_TABLE_SUPPORT)\n\t\t\"trace\",\n#endif\n\tNULL };\n\tconst char *builtin_help_usage[] = {\n\t\t\"perf help [--all] [--man|--web|--info] [command]\",\n\t\tNULL\n\t};\n\tint rc;\n\n\tload_command_list(\"perf-\", &main_cmds, &other_cmds);\n\n\trc = perf_config(perf_help_config, &help_format);\n\tif (rc)\n\t\treturn rc;\n\n\targc = parse_options_subcommand(argc, argv, builtin_help_options,\n\t\t\tbuiltin_help_subcommands, builtin_help_usage, 0);\n\n\tif (show_all) {\n\t\tprintf(\"\\n Usage: %s\\n\\n\", perf_usage_string);\n\t\tlist_commands(\"perf commands\", &main_cmds, &other_cmds);\n\t\tprintf(\" %s\\n\\n\", perf_more_info_string);\n\t\treturn 0;\n\t}\n\n\tif (!argv[0]) {\n\t\tprintf(\"\\n usage: %s\\n\\n\", perf_usage_string);\n\t\tlist_common_cmds_help();\n\t\tprintf(\"\\n %s\\n\\n\", perf_more_info_string);\n\t\treturn 0;\n\t}\n\n\tswitch (help_format) {\n\tcase HELP_FORMAT_MAN:\n\t\trc = show_man_page(argv[0]);\n\t\tbreak;\n\tcase HELP_FORMAT_INFO:\n\t\trc = show_info_page(argv[0]);\n\t\tbreak;\n\tcase HELP_FORMAT_WEB:\n\t\trc = show_html_page(argv[0]);\n\t\tbreak;\n\tcase HELP_FORMAT_NONE:\n\t\t \n\tdefault:\n\t\trc = -1;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}