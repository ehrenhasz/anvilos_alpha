{
  "module_name": "builtin-report.c",
  "hash_id": "36b31aebeda2f4443e57fc0e01a8a7b73a543265480b5068692c53bf5cd50061",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-report.c",
  "human_readable_source": "\n \n#include \"builtin.h\"\n\n#include \"util/config.h\"\n\n#include \"util/annotate.h\"\n#include \"util/color.h\"\n#include \"util/dso.h\"\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <linux/err.h>\n#include <linux/zalloc.h>\n#include \"util/map.h\"\n#include \"util/symbol.h\"\n#include \"util/map_symbol.h\"\n#include \"util/mem-events.h\"\n#include \"util/branch.h\"\n#include \"util/callchain.h\"\n#include \"util/values.h\"\n\n#include \"perf.h\"\n#include \"util/debug.h\"\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/evswitch.h\"\n#include \"util/header.h\"\n#include \"util/session.h\"\n#include \"util/srcline.h\"\n#include \"util/tool.h\"\n\n#include <subcmd/parse-options.h>\n#include <subcmd/exec-cmd.h>\n#include \"util/parse-events.h\"\n\n#include \"util/thread.h\"\n#include \"util/sort.h\"\n#include \"util/hist.h\"\n#include \"util/data.h\"\n#include \"arch/common.h\"\n#include \"util/time-utils.h\"\n#include \"util/auxtrace.h\"\n#include \"util/units.h\"\n#include \"util/util.h\" \n#include \"ui/ui.h\"\n#include \"ui/progress.h\"\n#include \"util/block-info.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <regex.h>\n#include <linux/ctype.h>\n#include <signal.h>\n#include <linux/bitmap.h>\n#include <linux/string.h>\n#include <linux/stringify.h>\n#include <linux/time64.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <linux/mman.h>\n\n#ifdef HAVE_LIBTRACEEVENT\n#include <traceevent/event-parse.h>\n#endif\n\nstruct report {\n\tstruct perf_tool\ttool;\n\tstruct perf_session\t*session;\n\tstruct evswitch\t\tevswitch;\n#ifdef HAVE_SLANG_SUPPORT\n\tbool\t\t\tuse_tui;\n#endif\n#ifdef HAVE_GTK2_SUPPORT\n\tbool\t\t\tuse_gtk;\n#endif\n\tbool\t\t\tuse_stdio;\n\tbool\t\t\tshow_full_info;\n\tbool\t\t\tshow_threads;\n\tbool\t\t\tinverted_callchain;\n\tbool\t\t\tmem_mode;\n\tbool\t\t\tstats_mode;\n\tbool\t\t\ttasks_mode;\n\tbool\t\t\tmmaps_mode;\n\tbool\t\t\theader;\n\tbool\t\t\theader_only;\n\tbool\t\t\tnonany_branch_mode;\n\tbool\t\t\tgroup_set;\n\tbool\t\t\tstitch_lbr;\n\tbool\t\t\tdisable_order;\n\tbool\t\t\tskip_empty;\n\tint\t\t\tmax_stack;\n\tstruct perf_read_values\tshow_threads_values;\n\tstruct annotation_options annotation_opts;\n\tconst char\t\t*pretty_printing_style;\n\tconst char\t\t*cpu_list;\n\tconst char\t\t*symbol_filter_str;\n\tconst char\t\t*time_str;\n\tstruct perf_time_interval *ptime_range;\n\tint\t\t\trange_size;\n\tint\t\t\trange_num;\n\tfloat\t\t\tmin_percent;\n\tu64\t\t\tnr_entries;\n\tu64\t\t\tqueue_size;\n\tu64\t\t\ttotal_cycles;\n\tint\t\t\tsocket_filter;\n\tDECLARE_BITMAP(cpu_bitmap, MAX_NR_CPUS);\n\tstruct branch_type_stat\tbrtype_stat;\n\tbool\t\t\tsymbol_ipc;\n\tbool\t\t\ttotal_cycles_mode;\n\tstruct block_report\t*block_reports;\n\tint\t\t\tnr_block_reports;\n};\n\nstatic int report__config(const char *var, const char *value, void *cb)\n{\n\tstruct report *rep = cb;\n\n\tif (!strcmp(var, \"report.group\")) {\n\t\tsymbol_conf.event_group = perf_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"report.percent-limit\")) {\n\t\tdouble pcnt = strtof(value, NULL);\n\n\t\trep->min_percent = pcnt;\n\t\tcallchain_param.min_percent = pcnt;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"report.children\")) {\n\t\tsymbol_conf.cumulate_callchain = perf_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"report.queue-size\"))\n\t\treturn perf_config_u64(&rep->queue_size, var, value);\n\n\tif (!strcmp(var, \"report.sort_order\")) {\n\t\tdefault_sort_order = strdup(value);\n\t\tif (!default_sort_order) {\n\t\t\tpr_err(\"Not enough memory for report.sort_order\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"report.skip-empty\")) {\n\t\trep->skip_empty = perf_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s variable unknown, ignoring...\", var);\n\treturn 0;\n}\n\nstatic int hist_iter__report_callback(struct hist_entry_iter *iter,\n\t\t\t\t      struct addr_location *al, bool single,\n\t\t\t\t      void *arg)\n{\n\tint err = 0;\n\tstruct report *rep = arg;\n\tstruct hist_entry *he = iter->he;\n\tstruct evsel *evsel = iter->evsel;\n\tstruct perf_sample *sample = iter->sample;\n\tstruct mem_info *mi;\n\tstruct branch_info *bi;\n\n\tif (!ui__has_annotation() && !rep->symbol_ipc)\n\t\treturn 0;\n\n\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\tbi = he->branch_info;\n\t\terr = addr_map_symbol__inc_samples(&bi->from, sample, evsel);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = addr_map_symbol__inc_samples(&bi->to, sample, evsel);\n\n\t} else if (rep->mem_mode) {\n\t\tmi = he->mem_info;\n\t\terr = addr_map_symbol__inc_samples(&mi->daddr, sample, evsel);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = hist_entry__inc_addr_samples(he, sample, evsel, al->addr);\n\n\t} else if (symbol_conf.cumulate_callchain) {\n\t\tif (single)\n\t\t\terr = hist_entry__inc_addr_samples(he, sample, evsel, al->addr);\n\t} else {\n\t\terr = hist_entry__inc_addr_samples(he, sample, evsel, al->addr);\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int hist_iter__branch_callback(struct hist_entry_iter *iter,\n\t\t\t\t      struct addr_location *al __maybe_unused,\n\t\t\t\t      bool single __maybe_unused,\n\t\t\t\t      void *arg)\n{\n\tstruct hist_entry *he = iter->he;\n\tstruct report *rep = arg;\n\tstruct branch_info *bi = he->branch_info;\n\tstruct perf_sample *sample = iter->sample;\n\tstruct evsel *evsel = iter->evsel;\n\tint err;\n\n\tbranch_type_count(&rep->brtype_stat, &bi->flags,\n\t\t\t  bi->from.addr, bi->to.addr);\n\n\tif (!ui__has_annotation() && !rep->symbol_ipc)\n\t\treturn 0;\n\n\terr = addr_map_symbol__inc_samples(&bi->from, sample, evsel);\n\tif (err)\n\t\tgoto out;\n\n\terr = addr_map_symbol__inc_samples(&bi->to, sample, evsel);\n\nout:\n\treturn err;\n}\n\nstatic void setup_forced_leader(struct report *report,\n\t\t\t\tstruct evlist *evlist)\n{\n\tif (report->group_set)\n\t\tevlist__force_leader(evlist);\n}\n\nstatic int process_feature_event(struct perf_session *session,\n\t\t\t\t union perf_event *event)\n{\n\tstruct report *rep = container_of(session->tool, struct report, tool);\n\n\tif (event->feat.feat_id < HEADER_LAST_FEATURE)\n\t\treturn perf_event__process_feature(session, event);\n\n\tif (event->feat.feat_id != HEADER_LAST_FEATURE) {\n\t\tpr_err(\"failed: wrong feature ID: %\" PRI_lu64 \"\\n\",\n\t\t       event->feat.feat_id);\n\t\treturn -1;\n\t} else if (rep->header_only) {\n\t\tsession_done = 1;\n\t}\n\n\t \n\tsetup_forced_leader(rep, session->evlist);\n\treturn 0;\n}\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct report *rep = container_of(tool, struct report, tool);\n\tstruct addr_location al;\n\tstruct hist_entry_iter iter = {\n\t\t.evsel \t\t\t= evsel,\n\t\t.sample \t\t= sample,\n\t\t.hide_unresolved \t= symbol_conf.hide_unresolved,\n\t\t.add_entry_cb \t\t= hist_iter__report_callback,\n\t};\n\tint ret = 0;\n\n\tif (perf_time__ranges_skip_sample(rep->ptime_range, rep->range_num,\n\t\t\t\t\t  sample->time)) {\n\t\treturn 0;\n\t}\n\n\tif (evswitch__discard(&rep->evswitch, evsel))\n\t\treturn 0;\n\n\taddr_location__init(&al);\n\tif (machine__resolve(machine, &al, sample) < 0) {\n\t\tpr_debug(\"problem processing %d event, skipping it.\\n\",\n\t\t\t event->header.type);\n\t\tret = -1;\n\t\tgoto out_put;\n\t}\n\n\tif (rep->stitch_lbr)\n\t\tthread__set_lbr_stitch_enable(al.thread, true);\n\n\tif (symbol_conf.hide_unresolved && al.sym == NULL)\n\t\tgoto out_put;\n\n\tif (rep->cpu_list && !test_bit(sample->cpu, rep->cpu_bitmap))\n\t\tgoto out_put;\n\n\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\t \n\t\tif (!sample->branch_stack)\n\t\t\tgoto out_put;\n\n\t\titer.add_entry_cb = hist_iter__branch_callback;\n\t\titer.ops = &hist_iter_branch;\n\t} else if (rep->mem_mode) {\n\t\titer.ops = &hist_iter_mem;\n\t} else if (symbol_conf.cumulate_callchain) {\n\t\titer.ops = &hist_iter_cumulative;\n\t} else {\n\t\titer.ops = &hist_iter_normal;\n\t}\n\n\tif (al.map != NULL)\n\t\tmap__dso(al.map)->hit = 1;\n\n\tif (ui__has_annotation() || rep->symbol_ipc || rep->total_cycles_mode) {\n\t\thist__account_cycles(sample->branch_stack, &al, sample,\n\t\t\t\t     rep->nonany_branch_mode,\n\t\t\t\t     &rep->total_cycles);\n\t}\n\n\tret = hist_entry_iter__add(&iter, &al, rep->max_stack, rep);\n\tif (ret < 0)\n\t\tpr_debug(\"problem adding hist entry, skipping event\\n\");\nout_put:\n\taddr_location__exit(&al);\n\treturn ret;\n}\n\nstatic int process_read_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample __maybe_unused,\n\t\t\t      struct evsel *evsel,\n\t\t\t      struct machine *machine __maybe_unused)\n{\n\tstruct report *rep = container_of(tool, struct report, tool);\n\n\tif (rep->show_threads) {\n\t\tconst char *name = evsel__name(evsel);\n\t\tint err = perf_read_values_add_value(&rep->show_threads_values,\n\t\t\t\t\t   event->read.pid, event->read.tid,\n\t\t\t\t\t   evsel->core.idx,\n\t\t\t\t\t   name,\n\t\t\t\t\t   event->read.value);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int report__setup_sample_type(struct report *rep)\n{\n\tstruct perf_session *session = rep->session;\n\tu64 sample_type = evlist__combined_sample_type(session->evlist);\n\tbool is_pipe = perf_data__is_pipe(session->data);\n\tstruct evsel *evsel;\n\n\tif (session->itrace_synth_opts->callchain ||\n\t    session->itrace_synth_opts->add_callchain ||\n\t    (!is_pipe &&\n\t     perf_header__has_feat(&session->header, HEADER_AUXTRACE) &&\n\t     !session->itrace_synth_opts->set))\n\t\tsample_type |= PERF_SAMPLE_CALLCHAIN;\n\n\tif (session->itrace_synth_opts->last_branch ||\n\t    session->itrace_synth_opts->add_last_branch)\n\t\tsample_type |= PERF_SAMPLE_BRANCH_STACK;\n\n\tif (!is_pipe && !(sample_type & PERF_SAMPLE_CALLCHAIN)) {\n\t\tif (perf_hpp_list.parent) {\n\t\t\tui__error(\"Selected --sort parent, but no \"\n\t\t\t\t    \"callchain data. Did you call \"\n\t\t\t\t    \"'perf record' without -g?\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (symbol_conf.use_callchain &&\n\t\t\t!symbol_conf.show_branchflag_count) {\n\t\t\tui__error(\"Selected -g or --branch-history.\\n\"\n\t\t\t\t  \"But no callchain or branch data.\\n\"\n\t\t\t\t  \"Did you call 'perf record' without -g or -b?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (!callchain_param.enabled &&\n\t\t   callchain_param.mode != CHAIN_NONE &&\n\t\t   !symbol_conf.use_callchain) {\n\t\t\tsymbol_conf.use_callchain = true;\n\t\t\tif (callchain_register_param(&callchain_param) < 0) {\n\t\t\t\tui__error(\"Can't register callchain params.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t}\n\n\tif (symbol_conf.cumulate_callchain) {\n\t\t \n\t\tif (!(sample_type & PERF_SAMPLE_CALLCHAIN)) {\n\t\t\tsymbol_conf.cumulate_callchain = false;\n\t\t\tperf_hpp__cancel_cumulate();\n\t\t}\n\t}\n\n\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\tif (!is_pipe &&\n\t\t    !(sample_type & PERF_SAMPLE_BRANCH_STACK)) {\n\t\t\tui__error(\"Selected -b but no branch data. \"\n\t\t\t\t  \"Did you call perf record without -b?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (sort__mode == SORT_MODE__MEMORY) {\n\t\t \n\t\tevlist__for_each_entry(session->evlist, evsel) {\n\t\t\tif (strstr(evsel->name, \"arm_spe\") &&\n\t\t\t\t!(sample_type & PERF_SAMPLE_DATA_SRC)) {\n\t\t\t\tevsel->core.attr.sample_type |= PERF_SAMPLE_DATA_SRC;\n\t\t\t\tsample_type |= PERF_SAMPLE_DATA_SRC;\n\t\t\t}\n\t\t}\n\n\t\tif (!is_pipe && !(sample_type & PERF_SAMPLE_DATA_SRC)) {\n\t\t\tui__error(\"Selected --mem-mode but no mem data. \"\n\t\t\t\t  \"Did you call perf record without -d?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcallchain_param_setup(sample_type, perf_env__arch(&rep->session->header.env));\n\n\tif (rep->stitch_lbr && (callchain_param.record_mode != CALLCHAIN_LBR)) {\n\t\tui__warning(\"Can't find LBR callchain. Switch off --stitch-lbr.\\n\"\n\t\t\t    \"Please apply --call-graph lbr when recording.\\n\");\n\t\trep->stitch_lbr = false;\n\t}\n\n\t \n\tif (!(evlist__combined_branch_type(session->evlist) & PERF_SAMPLE_BRANCH_ANY))\n\t\trep->nonany_branch_mode = true;\n\n#if !defined(HAVE_LIBUNWIND_SUPPORT) && !defined(HAVE_DWARF_SUPPORT)\n\tif (dwarf_callchain_users) {\n\t\tui__warning(\"Please install libunwind or libdw \"\n\t\t\t    \"development packages during the perf build.\\n\");\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic void sig_handler(int sig __maybe_unused)\n{\n\tsession_done = 1;\n}\n\nstatic size_t hists__fprintf_nr_sample_events(struct hists *hists, struct report *rep,\n\t\t\t\t\t      const char *evname, FILE *fp)\n{\n\tsize_t ret;\n\tchar unit;\n\tunsigned long nr_samples = hists->stats.nr_samples;\n\tu64 nr_events = hists->stats.total_period;\n\tstruct evsel *evsel = hists_to_evsel(hists);\n\tchar buf[512];\n\tsize_t size = sizeof(buf);\n\tint socked_id = hists->socket_filter;\n\n\tif (quiet)\n\t\treturn 0;\n\n\tif (symbol_conf.filter_relative) {\n\t\tnr_samples = hists->stats.nr_non_filtered_samples;\n\t\tnr_events = hists->stats.total_non_filtered_period;\n\t}\n\n\tif (evsel__is_group_event(evsel)) {\n\t\tstruct evsel *pos;\n\n\t\tevsel__group_desc(evsel, buf, size);\n\t\tevname = buf;\n\n\t\tfor_each_group_member(pos, evsel) {\n\t\t\tconst struct hists *pos_hists = evsel__hists(pos);\n\n\t\t\tif (symbol_conf.filter_relative) {\n\t\t\t\tnr_samples += pos_hists->stats.nr_non_filtered_samples;\n\t\t\t\tnr_events += pos_hists->stats.total_non_filtered_period;\n\t\t\t} else {\n\t\t\t\tnr_samples += pos_hists->stats.nr_samples;\n\t\t\t\tnr_events += pos_hists->stats.total_period;\n\t\t\t}\n\t\t}\n\t}\n\n\tnr_samples = convert_unit(nr_samples, &unit);\n\tret = fprintf(fp, \"# Samples: %lu%c\", nr_samples, unit);\n\tif (evname != NULL) {\n\t\tret += fprintf(fp, \" of event%s '%s'\",\n\t\t\t       evsel->core.nr_members > 1 ? \"s\" : \"\", evname);\n\t}\n\n\tif (rep->time_str)\n\t\tret += fprintf(fp, \" (time slices: %s)\", rep->time_str);\n\n\tif (symbol_conf.show_ref_callgraph && evname && strstr(evname, \"call-graph=no\")) {\n\t\tret += fprintf(fp, \", show reference callgraph\");\n\t}\n\n\tif (rep->mem_mode) {\n\t\tret += fprintf(fp, \"\\n# Total weight : %\" PRIu64, nr_events);\n\t\tret += fprintf(fp, \"\\n# Sort order   : %s\", sort_order ? : default_mem_sort_order);\n\t} else\n\t\tret += fprintf(fp, \"\\n# Event count (approx.): %\" PRIu64, nr_events);\n\n\tif (socked_id > -1)\n\t\tret += fprintf(fp, \"\\n# Processor Socket: %d\", socked_id);\n\n\treturn ret + fprintf(fp, \"\\n#\\n\");\n}\n\nstatic int evlist__tui_block_hists_browse(struct evlist *evlist, struct report *rep)\n{\n\tstruct evsel *pos;\n\tint i = 0, ret;\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tret = report__browse_block_hists(&rep->block_reports[i++].hist,\n\t\t\t\t\t\t rep->min_percent, pos,\n\t\t\t\t\t\t &rep->session->header.env,\n\t\t\t\t\t\t &rep->annotation_opts);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int evlist__tty_browse_hists(struct evlist *evlist, struct report *rep, const char *help)\n{\n\tstruct evsel *pos;\n\tint i = 0;\n\n\tif (!quiet) {\n\t\tfprintf(stdout, \"#\\n# Total Lost Samples: %\" PRIu64 \"\\n#\\n\",\n\t\t\tevlist->stats.total_lost_samples);\n\t}\n\n\tevlist__for_each_entry(evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\t\tconst char *evname = evsel__name(pos);\n\n\t\tif (symbol_conf.event_group && !evsel__is_group_leader(pos))\n\t\t\tcontinue;\n\n\t\tif (rep->skip_empty && !hists->stats.nr_samples)\n\t\t\tcontinue;\n\n\t\thists__fprintf_nr_sample_events(hists, rep, evname, stdout);\n\n\t\tif (rep->total_cycles_mode) {\n\t\t\treport__browse_block_hists(&rep->block_reports[i++].hist,\n\t\t\t\t\t\t   rep->min_percent, pos,\n\t\t\t\t\t\t   NULL, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\thists__fprintf(hists, !quiet, 0, 0, rep->min_percent, stdout,\n\t\t\t       !(symbol_conf.use_callchain ||\n\t\t\t         symbol_conf.show_branchflag_count));\n\t\tfprintf(stdout, \"\\n\\n\");\n\t}\n\n\tif (!quiet)\n\t\tfprintf(stdout, \"#\\n# (%s)\\n#\\n\", help);\n\n\tif (rep->show_threads) {\n\t\tbool style = !strcmp(rep->pretty_printing_style, \"raw\");\n\t\tperf_read_values_display(stdout, &rep->show_threads_values,\n\t\t\t\t\t style);\n\t\tperf_read_values_destroy(&rep->show_threads_values);\n\t}\n\n\tif (sort__mode == SORT_MODE__BRANCH)\n\t\tbranch_type_stat_display(stdout, &rep->brtype_stat);\n\n\treturn 0;\n}\n\nstatic void report__warn_kptr_restrict(const struct report *rep)\n{\n\tstruct map *kernel_map = machine__kernel_map(&rep->session->machines.host);\n\tstruct kmap *kernel_kmap = kernel_map ? map__kmap(kernel_map) : NULL;\n\n\tif (evlist__exclude_kernel(rep->session->evlist))\n\t\treturn;\n\n\tif (kernel_map == NULL ||\n\t     (map__dso(kernel_map)->hit &&\n\t     (kernel_kmap->ref_reloc_sym == NULL ||\n\t      kernel_kmap->ref_reloc_sym->addr == 0))) {\n\t\tconst char *desc =\n\t\t    \"As no suitable kallsyms nor vmlinux was found, kernel samples\\n\"\n\t\t    \"can't be resolved.\";\n\n\t\tif (kernel_map && map__has_symbols(kernel_map)) {\n\t\t\tdesc = \"If some relocation was applied (e.g. \"\n\t\t\t       \"kexec) symbols may be misresolved.\";\n\t\t}\n\n\t\tui__warning(\n\"Kernel address maps (/proc/{kallsyms,modules}) were restricted.\\n\\n\"\n\"Check /proc/sys/kernel/kptr_restrict before running 'perf record'.\\n\\n%s\\n\\n\"\n\"Samples in kernel modules can't be resolved as well.\\n\\n\",\n\t\tdesc);\n\t}\n}\n\nstatic int report__gtk_browse_hists(struct report *rep, const char *help)\n{\n\tint (*hist_browser)(struct evlist *evlist, const char *help,\n\t\t\t    struct hist_browser_timer *timer, float min_pcnt);\n\n\thist_browser = dlsym(perf_gtk_handle, \"evlist__gtk_browse_hists\");\n\n\tif (hist_browser == NULL) {\n\t\tui__error(\"GTK browser not found!\\n\");\n\t\treturn -1;\n\t}\n\n\treturn hist_browser(rep->session->evlist, help, NULL, rep->min_percent);\n}\n\nstatic int report__browse_hists(struct report *rep)\n{\n\tint ret;\n\tstruct perf_session *session = rep->session;\n\tstruct evlist *evlist = session->evlist;\n\tchar *help = NULL, *path = NULL;\n\n\tpath = system_path(TIPDIR);\n\tif (perf_tip(&help, path) || help == NULL) {\n\t\t \n\t\tfree(path);\n\t\tpath = system_path(DOCDIR);\n\t\tif (perf_tip(&help, path) || help == NULL)\n\t\t\thelp = strdup(\"Cannot load tips.txt file, please install perf!\");\n\t}\n\tfree(path);\n\n\tswitch (use_browser) {\n\tcase 1:\n\t\tif (rep->total_cycles_mode) {\n\t\t\tret = evlist__tui_block_hists_browse(evlist, rep);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = evlist__tui_browse_hists(evlist, help, NULL, rep->min_percent,\n\t\t\t\t\t       &session->header.env, true, &rep->annotation_opts);\n\t\t \n\t\tif (ret != K_SWITCH_INPUT_DATA && ret != K_RELOAD)\n\t\t\tret = 0;\n\t\tbreak;\n\tcase 2:\n\t\tret = report__gtk_browse_hists(rep, help);\n\t\tbreak;\n\tdefault:\n\t\tret = evlist__tty_browse_hists(evlist, rep, help);\n\t\tbreak;\n\t}\n\tfree(help);\n\treturn ret;\n}\n\nstatic int report__collapse_hists(struct report *rep)\n{\n\tstruct ui_progress prog;\n\tstruct evsel *pos;\n\tint ret = 0;\n\n\tui_progress__init(&prog, rep->nr_entries, \"Merging related events...\");\n\n\tevlist__for_each_entry(rep->session->evlist, pos) {\n\t\tstruct hists *hists = evsel__hists(pos);\n\n\t\tif (pos->core.idx == 0)\n\t\t\thists->symbol_filter_str = rep->symbol_filter_str;\n\n\t\thists->socket_filter = rep->socket_filter;\n\n\t\tret = hists__collapse_resort(hists, &prog);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (symbol_conf.event_group && !evsel__is_group_leader(pos)) {\n\t\t\tstruct hists *leader_hists = evsel__hists(evsel__leader(pos));\n\n\t\t\thists__match(leader_hists, hists);\n\t\t\thists__link(leader_hists, hists);\n\t\t}\n\t}\n\n\tui_progress__finish();\n\treturn ret;\n}\n\nstatic int hists__resort_cb(struct hist_entry *he, void *arg)\n{\n\tstruct report *rep = arg;\n\tstruct symbol *sym = he->ms.sym;\n\n\tif (rep->symbol_ipc && sym && !sym->annotate2) {\n\t\tstruct evsel *evsel = hists_to_evsel(he->hists);\n\n\t\tsymbol__annotate2(&he->ms, evsel, &rep->annotation_opts, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void report__output_resort(struct report *rep)\n{\n\tstruct ui_progress prog;\n\tstruct evsel *pos;\n\n\tui_progress__init(&prog, rep->nr_entries, \"Sorting events for output...\");\n\n\tevlist__for_each_entry(rep->session->evlist, pos) {\n\t\tevsel__output_resort_cb(pos, &prog, hists__resort_cb, rep);\n\t}\n\n\tui_progress__finish();\n}\n\nstatic int count_sample_event(struct perf_tool *tool __maybe_unused,\n\t\t\t      union perf_event *event __maybe_unused,\n\t\t\t      struct perf_sample *sample __maybe_unused,\n\t\t\t      struct evsel *evsel,\n\t\t\t      struct machine *machine __maybe_unused)\n{\n\tstruct hists *hists = evsel__hists(evsel);\n\n\thists__inc_nr_events(hists);\n\treturn 0;\n}\n\nstatic int count_lost_samples_event(struct perf_tool *tool,\n\t\t\t\t    union perf_event *event,\n\t\t\t\t    struct perf_sample *sample,\n\t\t\t\t    struct machine *machine __maybe_unused)\n{\n\tstruct report *rep = container_of(tool, struct report, tool);\n\tstruct evsel *evsel;\n\n\tevsel = evlist__id2evsel(rep->session->evlist, sample->id);\n\tif (evsel) {\n\t\thists__inc_nr_lost_samples(evsel__hists(evsel),\n\t\t\t\t\t   event->lost_samples.lost);\n\t}\n\treturn 0;\n}\n\nstatic int process_attr(struct perf_tool *tool __maybe_unused,\n\t\t\tunion perf_event *event,\n\t\t\tstruct evlist **pevlist);\n\nstatic void stats_setup(struct report *rep)\n{\n\tmemset(&rep->tool, 0, sizeof(rep->tool));\n\trep->tool.attr = process_attr;\n\trep->tool.sample = count_sample_event;\n\trep->tool.lost_samples = count_lost_samples_event;\n\trep->tool.no_warn = true;\n}\n\nstatic int stats_print(struct report *rep)\n{\n\tstruct perf_session *session = rep->session;\n\n\tperf_session__fprintf_nr_events(session, stdout, rep->skip_empty);\n\tevlist__fprintf_nr_events(session->evlist, stdout, rep->skip_empty);\n\treturn 0;\n}\n\nstatic void tasks_setup(struct report *rep)\n{\n\tmemset(&rep->tool, 0, sizeof(rep->tool));\n\trep->tool.ordered_events = true;\n\tif (rep->mmaps_mode) {\n\t\trep->tool.mmap = perf_event__process_mmap;\n\t\trep->tool.mmap2 = perf_event__process_mmap2;\n\t}\n\trep->tool.attr = process_attr;\n\trep->tool.comm = perf_event__process_comm;\n\trep->tool.exit = perf_event__process_exit;\n\trep->tool.fork = perf_event__process_fork;\n\trep->tool.no_warn = true;\n}\n\nstruct task {\n\tstruct thread\t\t*thread;\n\tstruct list_head\t list;\n\tstruct list_head\t children;\n};\n\nstatic struct task *tasks_list(struct task *task, struct machine *machine)\n{\n\tstruct thread *parent_thread, *thread = task->thread;\n\tstruct task   *parent_task;\n\n\t \n\tif (!list_empty(&task->list))\n\t\treturn NULL;\n\n\t \n\tif (thread__ppid(thread) == -1)\n\t\treturn task;\n\n\tparent_thread = machine__find_thread(machine, -1, thread__ppid(thread));\n\tif (!parent_thread)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tparent_task = thread__priv(parent_thread);\n\tthread__put(parent_thread);\n\tlist_add_tail(&task->list, &parent_task->children);\n\treturn tasks_list(parent_task, machine);\n}\n\nstatic size_t maps__fprintf_task(struct maps *maps, int indent, FILE *fp)\n{\n\tsize_t printed = 0;\n\tstruct map_rb_node *rb_node;\n\n\tmaps__for_each_entry(maps, rb_node) {\n\t\tstruct map *map = rb_node->map;\n\t\tconst struct dso *dso = map__dso(map);\n\t\tu32 prot = map__prot(map);\n\n\t\tprinted += fprintf(fp, \"%*s  %\" PRIx64 \"-%\" PRIx64 \" %c%c%c%c %08\" PRIx64 \" %\" PRIu64 \" %s\\n\",\n\t\t\t\t   indent, \"\", map__start(map), map__end(map),\n\t\t\t\t   prot & PROT_READ ? 'r' : '-',\n\t\t\t\t   prot & PROT_WRITE ? 'w' : '-',\n\t\t\t\t   prot & PROT_EXEC ? 'x' : '-',\n\t\t\t\t   map__flags(map) ? 's' : 'p',\n\t\t\t\t   map__pgoff(map),\n\t\t\t\t   dso->id.ino, dso->name);\n\t}\n\n\treturn printed;\n}\n\nstatic void task__print_level(struct task *task, FILE *fp, int level)\n{\n\tstruct thread *thread = task->thread;\n\tstruct task *child;\n\tint comm_indent = fprintf(fp, \"  %8d %8d %8d |%*s\",\n\t\t\t\t  thread__pid(thread), thread__tid(thread),\n\t\t\t\t  thread__ppid(thread), level, \"\");\n\n\tfprintf(fp, \"%s\\n\", thread__comm_str(thread));\n\n\tmaps__fprintf_task(thread__maps(thread), comm_indent, fp);\n\n\tif (!list_empty(&task->children)) {\n\t\tlist_for_each_entry(child, &task->children, list)\n\t\t\ttask__print_level(child, fp, level + 1);\n\t}\n}\n\nstatic int tasks_print(struct report *rep, FILE *fp)\n{\n\tstruct perf_session *session = rep->session;\n\tstruct machine      *machine = &session->machines.host;\n\tstruct task *tasks, *task;\n\tunsigned int nr = 0, itask = 0, i;\n\tstruct rb_node *nd;\n\tLIST_HEAD(list);\n\n\t \n\n\t \n\tfor (i = 0; i < THREADS__TABLE_SIZE; i++)\n\t\tnr += machine->threads[i].nr;\n\n\ttasks = malloc(sizeof(*tasks) * nr);\n\tif (!tasks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < THREADS__TABLE_SIZE; i++) {\n\t\tstruct threads *threads = &machine->threads[i];\n\n\t\tfor (nd = rb_first_cached(&threads->entries); nd;\n\t\t     nd = rb_next(nd)) {\n\t\t\ttask = tasks + itask++;\n\n\t\t\ttask->thread = rb_entry(nd, struct thread_rb_node, rb_node)->thread;\n\t\t\tINIT_LIST_HEAD(&task->children);\n\t\t\tINIT_LIST_HEAD(&task->list);\n\t\t\tthread__set_priv(task->thread, task);\n\t\t}\n\t}\n\n\t \n\tfor (itask = 0; itask < nr; itask++) {\n\t\ttask = tasks + itask;\n\n\t\tif (!list_empty(&task->list))\n\t\t\tcontinue;\n\n\t\ttask = tasks_list(task, machine);\n\t\tif (IS_ERR(task)) {\n\t\t\tpr_err(\"Error: failed to process tasks\\n\");\n\t\t\tfree(tasks);\n\t\t\treturn PTR_ERR(task);\n\t\t}\n\n\t\tif (task)\n\t\t\tlist_add_tail(&task->list, &list);\n\t}\n\n\tfprintf(fp, \"# %8s %8s %8s  %s\\n\", \"pid\", \"tid\", \"ppid\", \"comm\");\n\n\tlist_for_each_entry(task, &list, list)\n\t\ttask__print_level(task, fp, 0);\n\n\tfree(tasks);\n\treturn 0;\n}\n\nstatic int __cmd_report(struct report *rep)\n{\n\tint ret;\n\tstruct perf_session *session = rep->session;\n\tstruct evsel *pos;\n\tstruct perf_data *data = session->data;\n\n\tsignal(SIGINT, sig_handler);\n\n\tif (rep->cpu_list) {\n\t\tret = perf_session__cpu_bitmap(session, rep->cpu_list,\n\t\t\t\t\t       rep->cpu_bitmap);\n\t\tif (ret) {\n\t\t\tui__error(\"failed to set cpu bitmap\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tsession->itrace_synth_opts->cpu_bitmap = rep->cpu_bitmap;\n\t}\n\n\tif (rep->show_threads) {\n\t\tret = perf_read_values_init(&rep->show_threads_values);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = report__setup_sample_type(rep);\n\tif (ret) {\n\t\t \n\t\treturn ret;\n\t}\n\n\tif (rep->stats_mode)\n\t\tstats_setup(rep);\n\n\tif (rep->tasks_mode)\n\t\ttasks_setup(rep);\n\n\tret = perf_session__process_events(session);\n\tif (ret) {\n\t\tui__error(\"failed to process sample\\n\");\n\t\treturn ret;\n\t}\n\n\tevlist__check_mem_load_aux(session->evlist);\n\n\tif (rep->stats_mode)\n\t\treturn stats_print(rep);\n\n\tif (rep->tasks_mode)\n\t\treturn tasks_print(rep, stdout);\n\n\treport__warn_kptr_restrict(rep);\n\n\tevlist__for_each_entry(session->evlist, pos)\n\t\trep->nr_entries += evsel__hists(pos)->nr_entries;\n\n\tif (use_browser == 0) {\n\t\tif (verbose > 3)\n\t\t\tperf_session__fprintf(session, stdout);\n\n\t\tif (verbose > 2)\n\t\t\tperf_session__fprintf_dsos(session, stdout);\n\n\t\tif (dump_trace) {\n\t\t\tperf_session__fprintf_nr_events(session, stdout,\n\t\t\t\t\t\t\trep->skip_empty);\n\t\t\tevlist__fprintf_nr_events(session->evlist, stdout,\n\t\t\t\t\t\t  rep->skip_empty);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = report__collapse_hists(rep);\n\tif (ret) {\n\t\tui__error(\"failed to process hist entry\\n\");\n\t\treturn ret;\n\t}\n\n\tif (session_done())\n\t\treturn 0;\n\n\t \n\trep->nr_entries = 0;\n\tevlist__for_each_entry(session->evlist, pos)\n\t\trep->nr_entries += evsel__hists(pos)->nr_entries;\n\n\tif (rep->nr_entries == 0) {\n\t\tui__error(\"The %s data has no samples!\\n\", data->path);\n\t\treturn 0;\n\t}\n\n\treport__output_resort(rep);\n\n\tif (rep->total_cycles_mode) {\n\t\tint block_hpps[6] = {\n\t\t\tPERF_HPP_REPORT__BLOCK_TOTAL_CYCLES_PCT,\n\t\t\tPERF_HPP_REPORT__BLOCK_LBR_CYCLES,\n\t\t\tPERF_HPP_REPORT__BLOCK_CYCLES_PCT,\n\t\t\tPERF_HPP_REPORT__BLOCK_AVG_CYCLES,\n\t\t\tPERF_HPP_REPORT__BLOCK_RANGE,\n\t\t\tPERF_HPP_REPORT__BLOCK_DSO,\n\t\t};\n\n\t\trep->block_reports = block_info__create_report(session->evlist,\n\t\t\t\t\t\t\t       rep->total_cycles,\n\t\t\t\t\t\t\t       block_hpps, 6,\n\t\t\t\t\t\t\t       &rep->nr_block_reports);\n\t\tif (!rep->block_reports)\n\t\t\treturn -1;\n\t}\n\n\treturn report__browse_hists(rep);\n}\n\nstatic int\nreport_parse_callchain_opt(const struct option *opt, const char *arg, int unset)\n{\n\tstruct callchain_param *callchain = opt->value;\n\n\tcallchain->enabled = !unset;\n\t \n\tif (unset) {\n\t\tsymbol_conf.use_callchain = false;\n\t\tcallchain->mode = CHAIN_NONE;\n\t\treturn 0;\n\t}\n\n\treturn parse_callchain_report_opt(arg);\n}\n\nstatic int\nparse_time_quantum(const struct option *opt, const char *arg,\n\t\t   int unset __maybe_unused)\n{\n\tunsigned long *time_q = opt->value;\n\tchar *end;\n\n\t*time_q = strtoul(arg, &end, 0);\n\tif (end == arg)\n\t\tgoto parse_err;\n\tif (*time_q == 0) {\n\t\tpr_err(\"time quantum cannot be 0\");\n\t\treturn -1;\n\t}\n\tend = skip_spaces(end);\n\tif (*end == 0)\n\t\treturn 0;\n\tif (!strcmp(end, \"s\")) {\n\t\t*time_q *= NSEC_PER_SEC;\n\t\treturn 0;\n\t}\n\tif (!strcmp(end, \"ms\")) {\n\t\t*time_q *= NSEC_PER_MSEC;\n\t\treturn 0;\n\t}\n\tif (!strcmp(end, \"us\")) {\n\t\t*time_q *= NSEC_PER_USEC;\n\t\treturn 0;\n\t}\n\tif (!strcmp(end, \"ns\"))\n\t\treturn 0;\nparse_err:\n\tpr_err(\"Cannot parse time quantum `%s'\\n\", arg);\n\treturn -1;\n}\n\nint\nreport_parse_ignore_callees_opt(const struct option *opt __maybe_unused,\n\t\t\t\tconst char *arg, int unset __maybe_unused)\n{\n\tif (arg) {\n\t\tint err = regcomp(&ignore_callees_regex, arg, REG_EXTENDED);\n\t\tif (err) {\n\t\t\tchar buf[BUFSIZ];\n\t\t\tregerror(err, &ignore_callees_regex, buf, sizeof(buf));\n\t\t\tpr_err(\"Invalid --ignore-callees regex: %s\\n%s\", arg, buf);\n\t\t\treturn -1;\n\t\t}\n\t\thave_ignore_callees = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nparse_branch_mode(const struct option *opt,\n\t\t  const char *str __maybe_unused, int unset)\n{\n\tint *branch_mode = opt->value;\n\n\t*branch_mode = !unset;\n\treturn 0;\n}\n\nstatic int\nparse_percent_limit(const struct option *opt, const char *str,\n\t\t    int unset __maybe_unused)\n{\n\tstruct report *rep = opt->value;\n\tdouble pcnt = strtof(str, NULL);\n\n\trep->min_percent = pcnt;\n\tcallchain_param.min_percent = pcnt;\n\treturn 0;\n}\n\nstatic int process_attr(struct perf_tool *tool __maybe_unused,\n\t\t\tunion perf_event *event,\n\t\t\tstruct evlist **pevlist)\n{\n\tu64 sample_type;\n\tint err;\n\n\terr = perf_event__process_attr(tool, event, pevlist);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsample_type = evlist__combined_sample_type(*pevlist);\n\tcallchain_param_setup(sample_type, perf_env__arch((*pevlist)->env));\n\treturn 0;\n}\n\nint cmd_report(int argc, const char **argv)\n{\n\tstruct perf_session *session;\n\tstruct itrace_synth_opts itrace_synth_opts = { .set = 0, };\n\tstruct stat st;\n\tbool has_br_stack = false;\n\tint branch_mode = -1;\n\tint last_key = 0;\n\tbool branch_call_mode = false;\n#define CALLCHAIN_DEFAULT_OPT  \"graph,0.5,caller,function,percent\"\n\tstatic const char report_callchain_help[] = \"Display call graph (stack chain/backtrace):\\n\\n\"\n\t\t\t\t\t\t    CALLCHAIN_REPORT_HELP\n\t\t\t\t\t\t    \"\\n\\t\\t\\t\\tDefault: \" CALLCHAIN_DEFAULT_OPT;\n\tchar callchain_default_opt[] = CALLCHAIN_DEFAULT_OPT;\n\tconst char * const report_usage[] = {\n\t\t\"perf report [<options>]\",\n\t\tNULL\n\t};\n\tstruct report report = {\n\t\t.tool = {\n\t\t\t.sample\t\t = process_sample_event,\n\t\t\t.mmap\t\t = perf_event__process_mmap,\n\t\t\t.mmap2\t\t = perf_event__process_mmap2,\n\t\t\t.comm\t\t = perf_event__process_comm,\n\t\t\t.namespaces\t = perf_event__process_namespaces,\n\t\t\t.cgroup\t\t = perf_event__process_cgroup,\n\t\t\t.exit\t\t = perf_event__process_exit,\n\t\t\t.fork\t\t = perf_event__process_fork,\n\t\t\t.lost\t\t = perf_event__process_lost,\n\t\t\t.read\t\t = process_read_event,\n\t\t\t.attr\t\t = process_attr,\n#ifdef HAVE_LIBTRACEEVENT\n\t\t\t.tracing_data\t = perf_event__process_tracing_data,\n#endif\n\t\t\t.build_id\t = perf_event__process_build_id,\n\t\t\t.id_index\t = perf_event__process_id_index,\n\t\t\t.auxtrace_info\t = perf_event__process_auxtrace_info,\n\t\t\t.auxtrace\t = perf_event__process_auxtrace,\n\t\t\t.event_update\t = perf_event__process_event_update,\n\t\t\t.feature\t = process_feature_event,\n\t\t\t.ordered_events\t = true,\n\t\t\t.ordering_requires_timestamps = true,\n\t\t},\n\t\t.max_stack\t\t = PERF_MAX_STACK_DEPTH,\n\t\t.pretty_printing_style\t = \"normal\",\n\t\t.socket_filter\t\t = -1,\n\t\t.skip_empty\t\t = true,\n\t};\n\tchar *sort_order_help = sort_help(\"sort by key(s):\");\n\tchar *field_order_help = sort_help(\"output field(s): overhead period sample \");\n\tconst char *disassembler_style = NULL, *objdump_path = NULL, *addr2line_path = NULL;\n\tconst struct option options[] = {\n\tOPT_STRING('i', \"input\", &input_name, \"file\",\n\t\t    \"input file name\"),\n\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t    \"be more verbose (show symbol address, etc)\"),\n\tOPT_BOOLEAN('q', \"quiet\", &quiet, \"Do not show any warnings or messages\"),\n\tOPT_BOOLEAN('D', \"dump-raw-trace\", &dump_trace,\n\t\t    \"dump raw trace in ASCII\"),\n\tOPT_BOOLEAN(0, \"stats\", &report.stats_mode, \"Display event stats\"),\n\tOPT_BOOLEAN(0, \"tasks\", &report.tasks_mode, \"Display recorded tasks\"),\n\tOPT_BOOLEAN(0, \"mmaps\", &report.mmaps_mode, \"Display recorded tasks memory maps\"),\n\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t   \"file\", \"vmlinux pathname\"),\n\tOPT_BOOLEAN(0, \"ignore-vmlinux\", &symbol_conf.ignore_vmlinux,\n                    \"don't load vmlinux even if found\"),\n\tOPT_STRING(0, \"kallsyms\", &symbol_conf.kallsyms_name,\n\t\t   \"file\", \"kallsyms pathname\"),\n\tOPT_BOOLEAN('f', \"force\", &symbol_conf.force, \"don't complain, do it\"),\n\tOPT_BOOLEAN('m', \"modules\", &symbol_conf.use_modules,\n\t\t    \"load module symbols - WARNING: use only with -k and LIVE kernel\"),\n\tOPT_BOOLEAN('n', \"show-nr-samples\", &symbol_conf.show_nr_samples,\n\t\t    \"Show a column with the number of samples\"),\n\tOPT_BOOLEAN('T', \"threads\", &report.show_threads,\n\t\t    \"Show per-thread event counters\"),\n\tOPT_STRING(0, \"pretty\", &report.pretty_printing_style, \"key\",\n\t\t   \"pretty printing style key: normal raw\"),\n#ifdef HAVE_SLANG_SUPPORT\n\tOPT_BOOLEAN(0, \"tui\", &report.use_tui, \"Use the TUI interface\"),\n#endif\n#ifdef HAVE_GTK2_SUPPORT\n\tOPT_BOOLEAN(0, \"gtk\", &report.use_gtk, \"Use the GTK2 interface\"),\n#endif\n\tOPT_BOOLEAN(0, \"stdio\", &report.use_stdio,\n\t\t    \"Use the stdio interface\"),\n\tOPT_BOOLEAN(0, \"header\", &report.header, \"Show data header.\"),\n\tOPT_BOOLEAN(0, \"header-only\", &report.header_only,\n\t\t    \"Show only data header.\"),\n\tOPT_STRING('s', \"sort\", &sort_order, \"key[,key2...]\",\n\t\t   sort_order_help),\n\tOPT_STRING('F', \"fields\", &field_order, \"key[,keys...]\",\n\t\t   field_order_help),\n\tOPT_BOOLEAN(0, \"show-cpu-utilization\", &symbol_conf.show_cpu_utilization,\n\t\t    \"Show sample percentage for different cpu modes\"),\n\tOPT_BOOLEAN_FLAG(0, \"showcpuutilization\", &symbol_conf.show_cpu_utilization,\n\t\t    \"Show sample percentage for different cpu modes\", PARSE_OPT_HIDDEN),\n\tOPT_STRING('p', \"parent\", &parent_pattern, \"regex\",\n\t\t   \"regex filter to identify parent, see: '--sort parent'\"),\n\tOPT_BOOLEAN('x', \"exclude-other\", &symbol_conf.exclude_other,\n\t\t    \"Only display entries with parent-match\"),\n\tOPT_CALLBACK_DEFAULT('g', \"call-graph\", &callchain_param,\n\t\t\t     \"print_type,threshold[,print_limit],order,sort_key[,branch],value\",\n\t\t\t     report_callchain_help, &report_parse_callchain_opt,\n\t\t\t     callchain_default_opt),\n\tOPT_BOOLEAN(0, \"children\", &symbol_conf.cumulate_callchain,\n\t\t    \"Accumulate callchains of children and show total overhead as well. \"\n\t\t    \"Enabled by default, use --no-children to disable.\"),\n\tOPT_INTEGER(0, \"max-stack\", &report.max_stack,\n\t\t    \"Set the maximum stack depth when parsing the callchain, \"\n\t\t    \"anything beyond the specified depth will be ignored. \"\n\t\t    \"Default: kernel.perf_event_max_stack or \" __stringify(PERF_MAX_STACK_DEPTH)),\n\tOPT_BOOLEAN('G', \"inverted\", &report.inverted_callchain,\n\t\t    \"alias for inverted call graph\"),\n\tOPT_CALLBACK(0, \"ignore-callees\", NULL, \"regex\",\n\t\t   \"ignore callees of these functions in call graphs\",\n\t\t   report_parse_ignore_callees_opt),\n\tOPT_STRING('d', \"dsos\", &symbol_conf.dso_list_str, \"dso[,dso...]\",\n\t\t   \"only consider symbols in these dsos\"),\n\tOPT_STRING('c', \"comms\", &symbol_conf.comm_list_str, \"comm[,comm...]\",\n\t\t   \"only consider symbols in these comms\"),\n\tOPT_STRING(0, \"pid\", &symbol_conf.pid_list_str, \"pid[,pid...]\",\n\t\t   \"only consider symbols in these pids\"),\n\tOPT_STRING(0, \"tid\", &symbol_conf.tid_list_str, \"tid[,tid...]\",\n\t\t   \"only consider symbols in these tids\"),\n\tOPT_STRING('S', \"symbols\", &symbol_conf.sym_list_str, \"symbol[,symbol...]\",\n\t\t   \"only consider these symbols\"),\n\tOPT_STRING(0, \"symbol-filter\", &report.symbol_filter_str, \"filter\",\n\t\t   \"only show symbols that (partially) match with this filter\"),\n\tOPT_STRING('w', \"column-widths\", &symbol_conf.col_width_list_str,\n\t\t   \"width[,width...]\",\n\t\t   \"don't try to adjust column width, use these fixed values\"),\n\tOPT_STRING_NOEMPTY('t', \"field-separator\", &symbol_conf.field_sep, \"separator\",\n\t\t   \"separator for columns, no spaces will be added between \"\n\t\t   \"columns '.' is reserved.\"),\n\tOPT_BOOLEAN('U', \"hide-unresolved\", &symbol_conf.hide_unresolved,\n\t\t    \"Only display entries resolved to a symbol\"),\n\tOPT_CALLBACK(0, \"symfs\", NULL, \"directory\",\n\t\t     \"Look for files with symbols relative to this directory\",\n\t\t     symbol__config_symfs),\n\tOPT_STRING('C', \"cpu\", &report.cpu_list, \"cpu\",\n\t\t   \"list of cpus to profile\"),\n\tOPT_BOOLEAN('I', \"show-info\", &report.show_full_info,\n\t\t    \"Display extended information about perf.data file\"),\n\tOPT_BOOLEAN(0, \"source\", &report.annotation_opts.annotate_src,\n\t\t    \"Interleave source code with assembly code (default)\"),\n\tOPT_BOOLEAN(0, \"asm-raw\", &report.annotation_opts.show_asm_raw,\n\t\t    \"Display raw encoding of assembly instructions (default)\"),\n\tOPT_STRING('M', \"disassembler-style\", &disassembler_style, \"disassembler style\",\n\t\t   \"Specify disassembler style (e.g. -M intel for intel syntax)\"),\n\tOPT_STRING(0, \"prefix\", &report.annotation_opts.prefix, \"prefix\",\n\t\t    \"Add prefix to source file path names in programs (with --prefix-strip)\"),\n\tOPT_STRING(0, \"prefix-strip\", &report.annotation_opts.prefix_strip, \"N\",\n\t\t    \"Strip first N entries of source file path name in programs (with --prefix)\"),\n\tOPT_BOOLEAN(0, \"show-total-period\", &symbol_conf.show_total_period,\n\t\t    \"Show a column with the sum of periods\"),\n\tOPT_BOOLEAN_SET(0, \"group\", &symbol_conf.event_group, &report.group_set,\n\t\t    \"Show event group information together\"),\n\tOPT_INTEGER(0, \"group-sort-idx\", &symbol_conf.group_sort_idx,\n\t\t    \"Sort the output by the event at the index n in group. \"\n\t\t    \"If n is invalid, sort by the first event. \"\n\t\t    \"WARNING: should be used on grouped events.\"),\n\tOPT_CALLBACK_NOOPT('b', \"branch-stack\", &branch_mode, \"\",\n\t\t    \"use branch records for per branch histogram filling\",\n\t\t    parse_branch_mode),\n\tOPT_BOOLEAN(0, \"branch-history\", &branch_call_mode,\n\t\t    \"add last branch records to call history\"),\n\tOPT_STRING(0, \"objdump\", &objdump_path, \"path\",\n\t\t   \"objdump binary to use for disassembly and annotations\"),\n\tOPT_STRING(0, \"addr2line\", &addr2line_path, \"path\",\n\t\t   \"addr2line binary to use for line numbers\"),\n\tOPT_BOOLEAN(0, \"demangle\", &symbol_conf.demangle,\n\t\t    \"Disable symbol demangling\"),\n\tOPT_BOOLEAN(0, \"demangle-kernel\", &symbol_conf.demangle_kernel,\n\t\t    \"Enable kernel symbol demangling\"),\n\tOPT_BOOLEAN(0, \"mem-mode\", &report.mem_mode, \"mem access profile\"),\n\tOPT_INTEGER(0, \"samples\", &symbol_conf.res_sample,\n\t\t    \"Number of samples to save per histogram entry for individual browsing\"),\n\tOPT_CALLBACK(0, \"percent-limit\", &report, \"percent\",\n\t\t     \"Don't show entries under that percent\", parse_percent_limit),\n\tOPT_CALLBACK(0, \"percentage\", NULL, \"relative|absolute\",\n\t\t     \"how to display percentage of filtered entries\", parse_filter_percentage),\n\tOPT_CALLBACK_OPTARG(0, \"itrace\", &itrace_synth_opts, NULL, \"opts\",\n\t\t\t    \"Instruction Tracing options\\n\" ITRACE_HELP,\n\t\t\t    itrace_parse_synth_opts),\n\tOPT_BOOLEAN(0, \"full-source-path\", &srcline_full_filename,\n\t\t\t\"Show full source file name path for source lines\"),\n\tOPT_BOOLEAN(0, \"show-ref-call-graph\", &symbol_conf.show_ref_callgraph,\n\t\t    \"Show callgraph from reference event\"),\n\tOPT_BOOLEAN(0, \"stitch-lbr\", &report.stitch_lbr,\n\t\t    \"Enable LBR callgraph stitching approach\"),\n\tOPT_INTEGER(0, \"socket-filter\", &report.socket_filter,\n\t\t    \"only show processor socket that match with this filter\"),\n\tOPT_BOOLEAN(0, \"raw-trace\", &symbol_conf.raw_trace,\n\t\t    \"Show raw trace event output (do not use print fmt or plugins)\"),\n\tOPT_BOOLEAN(0, \"hierarchy\", &symbol_conf.report_hierarchy,\n\t\t    \"Show entries in a hierarchy\"),\n\tOPT_CALLBACK_DEFAULT(0, \"stdio-color\", NULL, \"mode\",\n\t\t\t     \"'always' (default), 'never' or 'auto' only applicable to --stdio mode\",\n\t\t\t     stdio__config_color, \"always\"),\n\tOPT_STRING(0, \"time\", &report.time_str, \"str\",\n\t\t   \"Time span of interest (start,stop)\"),\n\tOPT_BOOLEAN(0, \"inline\", &symbol_conf.inline_name,\n\t\t    \"Show inline function\"),\n\tOPT_CALLBACK(0, \"percent-type\", &report.annotation_opts, \"local-period\",\n\t\t     \"Set percent type local/global-period/hits\",\n\t\t     annotate_parse_percent_type),\n\tOPT_BOOLEAN(0, \"ns\", &symbol_conf.nanosecs, \"Show times in nanosecs\"),\n\tOPT_CALLBACK(0, \"time-quantum\", &symbol_conf.time_quantum, \"time (ms|us|ns|s)\",\n\t\t     \"Set time quantum for time sort key (default 100ms)\",\n\t\t     parse_time_quantum),\n\tOPTS_EVSWITCH(&report.evswitch),\n\tOPT_BOOLEAN(0, \"total-cycles\", &report.total_cycles_mode,\n\t\t    \"Sort all blocks by 'Sampled Cycles%'\"),\n\tOPT_BOOLEAN(0, \"disable-order\", &report.disable_order,\n\t\t    \"Disable raw trace ordering\"),\n\tOPT_BOOLEAN(0, \"skip-empty\", &report.skip_empty,\n\t\t    \"Do not display empty (or dummy) events in the output\"),\n\tOPT_END()\n\t};\n\tstruct perf_data data = {\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t};\n\tint ret = hists__init();\n\tchar sort_tmp[128];\n\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tannotation_options__init(&report.annotation_opts);\n\n\tret = perf_config(report__config, &report);\n\tif (ret)\n\t\tgoto exit;\n\n\targc = parse_options(argc, argv, options, report_usage, 0);\n\tif (argc) {\n\t\t \n\t\tif (argc > 1)\n\t\t\tusage_with_options(report_usage, options);\n\n\t\treport.symbol_filter_str = argv[0];\n\t}\n\n\tif (disassembler_style) {\n\t\treport.annotation_opts.disassembler_style = strdup(disassembler_style);\n\t\tif (!report.annotation_opts.disassembler_style)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (objdump_path) {\n\t\treport.annotation_opts.objdump_path = strdup(objdump_path);\n\t\tif (!report.annotation_opts.objdump_path)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (addr2line_path) {\n\t\tsymbol_conf.addr2line_path = strdup(addr2line_path);\n\t\tif (!symbol_conf.addr2line_path)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (annotate_check_args(&report.annotation_opts) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (report.mmaps_mode)\n\t\treport.tasks_mode = true;\n\n\tif (dump_trace && report.disable_order)\n\t\treport.tool.ordered_events = false;\n\n\tif (quiet)\n\t\tperf_quiet_option();\n\n\tret = symbol__validate_sym_arguments();\n\tif (ret)\n\t\tgoto exit;\n\n\tif (report.inverted_callchain)\n\t\tcallchain_param.order = ORDER_CALLER;\n\tif (symbol_conf.cumulate_callchain && !callchain_param.order_set)\n\t\tcallchain_param.order = ORDER_CALLER;\n\n\tif ((itrace_synth_opts.callchain || itrace_synth_opts.add_callchain) &&\n\t    (int)itrace_synth_opts.callchain_sz > report.max_stack)\n\t\treport.max_stack = itrace_synth_opts.callchain_sz;\n\n\tif (!input_name || !strlen(input_name)) {\n\t\tif (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))\n\t\t\tinput_name = \"-\";\n\t\telse\n\t\t\tinput_name = \"perf.data\";\n\t}\n\n\tdata.path  = input_name;\n\tdata.force = symbol_conf.force;\n\nrepeat:\n\tsession = perf_session__new(&data, &report.tool);\n\tif (IS_ERR(session)) {\n\t\tret = PTR_ERR(session);\n\t\tgoto exit;\n\t}\n\n\tret = evswitch__init(&report.evswitch, session->evlist, stderr);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (zstd_init(&(session->zstd_data), 0) < 0)\n\t\tpr_warning(\"Decompression initialization failed. Reported data may be incomplete.\\n\");\n\n\tif (report.queue_size) {\n\t\tordered_events__set_alloc_size(&session->ordered_events,\n\t\t\t\t\t       report.queue_size);\n\t}\n\n\tsession->itrace_synth_opts = &itrace_synth_opts;\n\n\treport.session = session;\n\n\thas_br_stack = perf_header__has_feat(&session->header,\n\t\t\t\t\t     HEADER_BRANCH_STACK);\n\tif (evlist__combined_sample_type(session->evlist) & PERF_SAMPLE_STACK_USER)\n\t\thas_br_stack = false;\n\n\tsetup_forced_leader(&report, session->evlist);\n\n\tif (symbol_conf.group_sort_idx && evlist__nr_groups(session->evlist) == 0) {\n\t\tparse_options_usage(NULL, options, \"group-sort-idx\", 0);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (itrace_synth_opts.last_branch || itrace_synth_opts.add_last_branch)\n\t\thas_br_stack = true;\n\n\tif (has_br_stack && branch_call_mode)\n\t\tsymbol_conf.show_branchflag_count = true;\n\n\tmemset(&report.brtype_stat, 0, sizeof(struct branch_type_stat));\n\n\t \n\tif (((branch_mode == -1 && has_br_stack) || branch_mode == 1) &&\n\t    !branch_call_mode) {\n\t\tsort__mode = SORT_MODE__BRANCH;\n\t\tsymbol_conf.cumulate_callchain = false;\n\t}\n\tif (branch_call_mode) {\n\t\tcallchain_param.key = CCKEY_ADDRESS;\n\t\tcallchain_param.branch_callstack = true;\n\t\tsymbol_conf.use_callchain = true;\n\t\tcallchain_register_param(&callchain_param);\n\t\tif (sort_order == NULL)\n\t\t\tsort_order = \"srcline,symbol,dso\";\n\t}\n\n\tif (report.mem_mode) {\n\t\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\t\tpr_err(\"branch and mem mode incompatible\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tsort__mode = SORT_MODE__MEMORY;\n\t\tsymbol_conf.cumulate_callchain = false;\n\t}\n\n\tif (symbol_conf.report_hierarchy) {\n\t\t \n\t\tsymbol_conf.cumulate_callchain = false;\n\n\t\tif (field_order) {\n\t\t\tpr_err(\"Error: --hierarchy and --fields options cannot be used together\\n\");\n\t\t\tparse_options_usage(report_usage, options, \"F\", 1);\n\t\t\tparse_options_usage(NULL, options, \"hierarchy\", 0);\n\t\t\tgoto error;\n\t\t}\n\n\t\tperf_hpp_list.need_collapse = true;\n\t}\n\n\tif (report.use_stdio)\n\t\tuse_browser = 0;\n#ifdef HAVE_SLANG_SUPPORT\n\telse if (report.use_tui)\n\t\tuse_browser = 1;\n#endif\n#ifdef HAVE_GTK2_SUPPORT\n\telse if (report.use_gtk)\n\t\tuse_browser = 2;\n#endif\n\n\t \n\tif (report.header || report.header_only || report.show_threads)\n\t\tuse_browser = 0;\n\tif (report.header || report.header_only)\n\t\treport.tool.show_feat_hdr = SHOW_FEAT_HEADER;\n\tif (report.show_full_info)\n\t\treport.tool.show_feat_hdr = SHOW_FEAT_HEADER_FULL_INFO;\n\tif (report.stats_mode || report.tasks_mode)\n\t\tuse_browser = 0;\n\tif (report.stats_mode && report.tasks_mode) {\n\t\tpr_err(\"Error: --tasks and --mmaps can't be used together with --stats\\n\");\n\t\tgoto error;\n\t}\n\n\tif (report.total_cycles_mode) {\n\t\tif (sort__mode != SORT_MODE__BRANCH)\n\t\t\treport.total_cycles_mode = false;\n\t\telse\n\t\t\tsort_order = NULL;\n\t}\n\n\tif (strcmp(input_name, \"-\") != 0)\n\t\tsetup_browser(true);\n\telse\n\t\tuse_browser = 0;\n\n\tif (sort_order && strstr(sort_order, \"ipc\")) {\n\t\tparse_options_usage(report_usage, options, \"s\", 1);\n\t\tgoto error;\n\t}\n\n\tif (sort_order && strstr(sort_order, \"symbol\")) {\n\t\tif (sort__mode == SORT_MODE__BRANCH) {\n\t\t\tsnprintf(sort_tmp, sizeof(sort_tmp), \"%s,%s\",\n\t\t\t\t sort_order, \"ipc_lbr\");\n\t\t\treport.symbol_ipc = true;\n\t\t} else {\n\t\t\tsnprintf(sort_tmp, sizeof(sort_tmp), \"%s,%s\",\n\t\t\t\t sort_order, \"ipc_null\");\n\t\t}\n\n\t\tsort_order = sort_tmp;\n\t}\n\n\tif ((last_key != K_SWITCH_INPUT_DATA && last_key != K_RELOAD) &&\n\t    (setup_sorting(session->evlist) < 0)) {\n\t\tif (sort_order)\n\t\t\tparse_options_usage(report_usage, options, \"s\", 1);\n\t\tif (field_order)\n\t\t\tparse_options_usage(sort_order ? NULL : report_usage,\n\t\t\t\t\t    options, \"F\", 1);\n\t\tgoto error;\n\t}\n\n\tif ((report.header || report.header_only) && !quiet) {\n\t\tperf_session__fprintf_info(session, stdout,\n\t\t\t\t\t   report.show_full_info);\n\t\tif (report.header_only) {\n\t\t\tif (data.is_pipe) {\n\t\t\t\t \n\t\t\t\tperf_session__process_events(session);\n\t\t\t}\n\t\t\tret = 0;\n\t\t\tgoto error;\n\t\t}\n\t} else if (use_browser == 0 && !quiet &&\n\t\t   !report.stats_mode && !report.tasks_mode) {\n\t\tfputs(\"# To display the perf.data header info, please use --header/--header-only options.\\n#\\n\",\n\t\t      stdout);\n\t}\n\n\t \n\tif (ui__has_annotation() || report.symbol_ipc ||\n\t    report.total_cycles_mode) {\n\t\tret = symbol__annotation_init();\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\t \n\t\tif (verbose > 0) {\n\t\t\t \n\t\t\tsymbol_conf.priv_size += sizeof(u32);\n\t\t}\n\t\tannotation_config__init(&report.annotation_opts);\n\t}\n\n\tif (symbol__init(&session->header.env) < 0)\n\t\tgoto error;\n\n\tif (report.time_str) {\n\t\tret = perf_time__parse_for_ranges(report.time_str, session,\n\t\t\t\t\t\t  &report.ptime_range,\n\t\t\t\t\t\t  &report.range_size,\n\t\t\t\t\t\t  &report.range_num);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\titrace_synth_opts__set_time_range(&itrace_synth_opts,\n\t\t\t\t\t\t  report.ptime_range,\n\t\t\t\t\t\t  report.range_num);\n\t}\n\n#ifdef HAVE_LIBTRACEEVENT\n\tif (session->tevent.pevent &&\n\t    tep_set_function_resolver(session->tevent.pevent,\n\t\t\t\t      machine__resolve_kernel_addr,\n\t\t\t\t      &session->machines.host) < 0) {\n\t\tpr_err(\"%s: failed to set libtraceevent function resolver\\n\",\n\t\t       __func__);\n\t\treturn -1;\n\t}\n#endif\n\tsort__setup_elide(stdout);\n\n\tret = __cmd_report(&report);\n\tif (ret == K_SWITCH_INPUT_DATA || ret == K_RELOAD) {\n\t\tperf_session__delete(session);\n\t\tlast_key = K_SWITCH_INPUT_DATA;\n\t\tgoto repeat;\n\t} else\n\t\tret = 0;\n\nerror:\n\tif (report.ptime_range) {\n\t\titrace_synth_opts__clear_time_range(&itrace_synth_opts);\n\t\tzfree(&report.ptime_range);\n\t}\n\n\tif (report.block_reports) {\n\t\tblock_info__free_report(report.block_reports,\n\t\t\t\t\treport.nr_block_reports);\n\t\treport.block_reports = NULL;\n\t}\n\n\tzstd_fini(&(session->zstd_data));\n\tperf_session__delete(session);\nexit:\n\tannotation_options__exit(&report.annotation_opts);\n\tfree(sort_order_help);\n\tfree(field_order_help);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}