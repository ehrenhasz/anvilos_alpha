{
  "module_name": "builtin-kvm.c",
  "hash_id": "b3e834e5e9dd2b3548642f269f25bc3d5aac71804e678a1c6c7aec6285ee7a55",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-kvm.c",
  "human_readable_source": "\n#include \"builtin.h\"\n#include \"perf.h\"\n\n#include \"util/build-id.h\"\n#include \"util/evsel.h\"\n#include \"util/evlist.h\"\n#include \"util/mmap.h\"\n#include \"util/term.h\"\n#include \"util/symbol.h\"\n#include \"util/thread.h\"\n#include \"util/header.h\"\n#include \"util/session.h\"\n#include \"util/intlist.h\"\n#include <subcmd/pager.h>\n#include <subcmd/parse-options.h>\n#include \"util/trace-event.h\"\n#include \"util/debug.h\"\n#include \"util/tool.h\"\n#include \"util/stat.h\"\n#include \"util/synthetic-events.h\"\n#include \"util/top.h\"\n#include \"util/data.h\"\n#include \"util/ordered-events.h\"\n#include \"util/kvm-stat.h\"\n#include \"util/util.h\"\n#include \"ui/browsers/hists.h\"\n#include \"ui/progress.h\"\n#include \"ui/ui.h\"\n#include \"util/string2.h\"\n\n#include <sys/prctl.h>\n#ifdef HAVE_TIMERFD_SUPPORT\n#include <sys/timerfd.h>\n#endif\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/time64.h>\n#include <linux/zalloc.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <poll.h>\n#include <termios.h>\n#include <semaphore.h>\n#include <signal.h>\n#include <math.h>\n#include <perf/mmap.h>\n\n#if defined(HAVE_KVM_STAT_SUPPORT) && defined(HAVE_LIBTRACEEVENT)\n#define GET_EVENT_KEY(func, field)\t\t\t\t\t\\\nstatic u64 get_event_ ##func(struct kvm_event *event, int vcpu)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (vcpu == -1)\t\t\t\t\t\t\t\\\n\t\treturn event->total.field;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (vcpu >= event->max_vcpu)\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn event->vcpu[vcpu].field;\t\t\t\t\t\\\n}\n\n#define COMPARE_EVENT_KEY(func, field)\t\t\t\t\t\\\nGET_EVENT_KEY(func, field)\t\t\t\t\t\t\\\nstatic int64_t cmp_event_ ## func(struct kvm_event *one,\t\t\\\n\t\t\t      struct kvm_event *two, int vcpu)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn get_event_ ##func(one, vcpu) -\t\t\t\t\\\n\t       get_event_ ##func(two, vcpu);\t\t\t\t\\\n}\n\nCOMPARE_EVENT_KEY(time, time);\nCOMPARE_EVENT_KEY(max, stats.max);\nCOMPARE_EVENT_KEY(min, stats.min);\nCOMPARE_EVENT_KEY(count, stats.n);\nCOMPARE_EVENT_KEY(mean, stats.mean);\n\nstruct kvm_hists {\n\tstruct hists\t\thists;\n\tstruct perf_hpp_list\tlist;\n};\n\nstruct kvm_dimension {\n\tconst char *name;\n\tconst char *header;\n\tint width;\n\tint64_t (*cmp)(struct perf_hpp_fmt *fmt, struct hist_entry *left,\n\t\t       struct hist_entry *right);\n\tint (*entry)(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t     struct hist_entry *he);\n};\n\nstruct kvm_fmt {\n\tstruct perf_hpp_fmt\tfmt;\n\tstruct kvm_dimension\t*dim;\n};\n\nstatic struct kvm_hists kvm_hists;\n\nstatic int64_t ev_name_cmp(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t\t   struct hist_entry *left,\n\t\t\t   struct hist_entry *right)\n{\n\t \n\treturn -strcmp(left->kvm_info->name, right->kvm_info->name);\n}\n\nstatic int fmt_width(struct perf_hpp_fmt *fmt,\n\t\t     struct perf_hpp *hpp __maybe_unused,\n\t\t     struct hists *hists __maybe_unused);\n\nstatic int ev_name_entry(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t struct hist_entry *he)\n{\n\tint width = fmt_width(fmt, hpp, he->hists);\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, he->kvm_info->name);\n}\n\nstatic struct kvm_dimension dim_event = {\n\t.header\t\t= \"Event name\",\n\t.name\t\t= \"ev_name\",\n\t.cmp\t\t= ev_name_cmp,\n\t.entry\t\t= ev_name_entry,\n\t.width\t\t= 40,\n};\n\n#define EV_METRIC_CMP(metric)\t\t\t\t\t\t\\\nstatic int64_t ev_cmp_##metric(struct perf_hpp_fmt *fmt __maybe_unused,\t\\\n\t\t\t       struct hist_entry *left,\t\t\t\\\n\t\t\t       struct hist_entry *right)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct kvm_event *event_left;\t\t\t\t\t\\\n\tstruct kvm_event *event_right;\t\t\t\t\t\\\n\tstruct perf_kvm_stat *perf_kvm;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tevent_left  = container_of(left, struct kvm_event, he);\t\t\\\n\tevent_right = container_of(right, struct kvm_event, he);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tperf_kvm = event_left->perf_kvm;\t\t\t\t\\\n\treturn cmp_event_##metric(event_left, event_right,\t\t\\\n\t\t\t\t  perf_kvm->trace_vcpu);\t\t\\\n}\n\nEV_METRIC_CMP(time)\nEV_METRIC_CMP(count)\nEV_METRIC_CMP(max)\nEV_METRIC_CMP(min)\nEV_METRIC_CMP(mean)\n\n#define EV_METRIC_ENTRY(metric)\t\t\t\t\t\t\\\nstatic int ev_entry_##metric(struct perf_hpp_fmt *fmt,\t\t\t\\\n\t\t\t     struct perf_hpp *hpp,\t\t\t\\\n\t\t\t     struct hist_entry *he)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct kvm_event *event;\t\t\t\t\t\\\n\tint width = fmt_width(fmt, hpp, he->hists);\t\t\t\\\n\tstruct perf_kvm_stat *perf_kvm;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tevent = container_of(he, struct kvm_event, he);\t\t\t\\\n\tperf_kvm = event->perf_kvm;\t\t\t\t\t\\\n\treturn scnprintf(hpp->buf, hpp->size, \"%*lu\", width,\t\t\\\n\t\tget_event_##metric(event, perf_kvm->trace_vcpu));\t\\\n}\n\nEV_METRIC_ENTRY(time)\nEV_METRIC_ENTRY(count)\nEV_METRIC_ENTRY(max)\nEV_METRIC_ENTRY(min)\n\nstatic struct kvm_dimension dim_time = {\n\t.header\t\t= \"Time (ns)\",\n\t.name\t\t= \"time\",\n\t.cmp\t\t= ev_cmp_time,\n\t.entry\t\t= ev_entry_time,\n\t.width\t\t= 12,\n};\n\nstatic struct kvm_dimension dim_count = {\n\t.header\t\t= \"Samples\",\n\t.name\t\t= \"sample\",\n\t.cmp\t\t= ev_cmp_count,\n\t.entry\t\t= ev_entry_count,\n\t.width\t\t= 12,\n};\n\nstatic struct kvm_dimension dim_max_time = {\n\t.header\t\t= \"Max Time (ns)\",\n\t.name\t\t= \"max_t\",\n\t.cmp\t\t= ev_cmp_max,\n\t.entry\t\t= ev_entry_max,\n\t.width\t\t= 14,\n};\n\nstatic struct kvm_dimension dim_min_time = {\n\t.header\t\t= \"Min Time (ns)\",\n\t.name\t\t= \"min_t\",\n\t.cmp\t\t= ev_cmp_min,\n\t.entry\t\t= ev_entry_min,\n\t.width\t\t= 14,\n};\n\nstatic int ev_entry_mean(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t\t struct hist_entry *he)\n{\n\tstruct kvm_event *event;\n\tint width = fmt_width(fmt, hpp, he->hists);\n\tstruct perf_kvm_stat *perf_kvm;\n\n\tevent = container_of(he, struct kvm_event, he);\n\tperf_kvm = event->perf_kvm;\n\treturn scnprintf(hpp->buf, hpp->size, \"%*lu\", width,\n\t\t\t get_event_mean(event, perf_kvm->trace_vcpu));\n}\n\nstatic struct kvm_dimension dim_mean_time = {\n\t.header\t\t= \"Mean Time (ns)\",\n\t.name\t\t= \"mean_t\",\n\t.cmp\t\t= ev_cmp_mean,\n\t.entry\t\t= ev_entry_mean,\n\t.width\t\t= 14,\n};\n\n#define PERC_STR(__s, __v)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tscnprintf(__s, sizeof(__s), \"%.2F%%\", __v);\t\\\n\t__s;\t\t\t\t\t\t\\\n})\n\nstatic double percent(u64 st, u64 tot)\n{\n\treturn tot ? 100. * (double) st / (double) tot : 0;\n}\n\n#define EV_METRIC_PERCENT(metric)\t\t\t\t\t\\\nstatic int ev_percent_##metric(struct hist_entry *he)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct kvm_event *event;\t\t\t\t\t\\\n\tstruct perf_kvm_stat *perf_kvm;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tevent = container_of(he, struct kvm_event, he);\t\t\t\\\n\tperf_kvm = event->perf_kvm;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn percent(get_event_##metric(event, perf_kvm->trace_vcpu),\t\\\n\t\t       perf_kvm->total_##metric);\t\t\t\\\n}\n\nEV_METRIC_PERCENT(time)\nEV_METRIC_PERCENT(count)\n\nstatic int ev_entry_time_precent(struct perf_hpp_fmt *fmt,\n\t\t\t\t struct perf_hpp *hpp,\n\t\t\t\t struct hist_entry *he)\n{\n\tint width = fmt_width(fmt, hpp, he->hists);\n\tdouble per;\n\tchar buf[10];\n\n\tper = ev_percent_time(he);\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int64_t\nev_cmp_time_precent(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t    struct hist_entry *left, struct hist_entry *right)\n{\n\tdouble per_left;\n\tdouble per_right;\n\n\tper_left  = ev_percent_time(left);\n\tper_right = ev_percent_time(right);\n\n\treturn per_left - per_right;\n}\n\nstatic struct kvm_dimension dim_time_percent = {\n\t.header\t\t= \"Time%\",\n\t.name\t\t= \"percent_time\",\n\t.cmp\t\t= ev_cmp_time_precent,\n\t.entry\t\t= ev_entry_time_precent,\n\t.width\t\t= 12,\n};\n\nstatic int ev_entry_count_precent(struct perf_hpp_fmt *fmt,\n\t\t\t\t  struct perf_hpp *hpp,\n\t\t\t\t  struct hist_entry *he)\n{\n\tint width = fmt_width(fmt, hpp, he->hists);\n\tdouble per;\n\tchar buf[10];\n\n\tper = ev_percent_count(he);\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, PERC_STR(buf, per));\n}\n\nstatic int64_t\nev_cmp_count_precent(struct perf_hpp_fmt *fmt __maybe_unused,\n\t\t     struct hist_entry *left, struct hist_entry *right)\n{\n\tdouble per_left;\n\tdouble per_right;\n\n\tper_left  = ev_percent_count(left);\n\tper_right = ev_percent_count(right);\n\n\treturn per_left - per_right;\n}\n\nstatic struct kvm_dimension dim_count_percent = {\n\t.header\t\t= \"Sample%\",\n\t.name\t\t= \"percent_sample\",\n\t.cmp\t\t= ev_cmp_count_precent,\n\t.entry\t\t= ev_entry_count_precent,\n\t.width\t\t= 12,\n};\n\nstatic struct kvm_dimension *dimensions[] = {\n\t&dim_event,\n\t&dim_time,\n\t&dim_time_percent,\n\t&dim_count,\n\t&dim_count_percent,\n\t&dim_max_time,\n\t&dim_min_time,\n\t&dim_mean_time,\n\tNULL,\n};\n\nstatic int fmt_width(struct perf_hpp_fmt *fmt,\n\t\t     struct perf_hpp *hpp __maybe_unused,\n\t\t     struct hists *hists __maybe_unused)\n{\n\tstruct kvm_fmt *kvm_fmt;\n\n\tkvm_fmt = container_of(fmt, struct kvm_fmt, fmt);\n\treturn kvm_fmt->dim->width;\n}\n\nstatic int fmt_header(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\n\t\t      struct hists *hists, int line __maybe_unused,\n\t\t      int *span __maybe_unused)\n{\n\tstruct kvm_fmt *kvm_fmt;\n\tstruct kvm_dimension *dim;\n\tint width = fmt_width(fmt, hpp, hists);\n\n\tkvm_fmt = container_of(fmt, struct kvm_fmt, fmt);\n\tdim = kvm_fmt->dim;\n\n\treturn scnprintf(hpp->buf, hpp->size, \"%*s\", width, dim->header);\n}\n\nstatic bool fmt_equal(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b)\n{\n\tstruct kvm_fmt *kvm_fmt_a = container_of(a, struct kvm_fmt, fmt);\n\tstruct kvm_fmt *kvm_fmt_b = container_of(b, struct kvm_fmt, fmt);\n\n\treturn kvm_fmt_a->dim == kvm_fmt_b->dim;\n}\n\nstatic void fmt_free(struct perf_hpp_fmt *fmt)\n{\n\tstruct kvm_fmt *kvm_fmt;\n\n\tkvm_fmt = container_of(fmt, struct kvm_fmt, fmt);\n\tfree(kvm_fmt);\n}\n\nstatic struct kvm_dimension *get_dimension(const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 0; dimensions[i] != NULL; i++) {\n\t\tif (!strcmp(dimensions[i]->name, name))\n\t\t\treturn dimensions[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct kvm_fmt *get_format(const char *name)\n{\n\tstruct kvm_dimension *dim = get_dimension(name);\n\tstruct kvm_fmt *kvm_fmt;\n\tstruct perf_hpp_fmt *fmt;\n\n\tif (!dim)\n\t\treturn NULL;\n\n\tkvm_fmt = zalloc(sizeof(*kvm_fmt));\n\tif (!kvm_fmt)\n\t\treturn NULL;\n\n\tkvm_fmt->dim = dim;\n\n\tfmt = &kvm_fmt->fmt;\n\tINIT_LIST_HEAD(&fmt->list);\n\tINIT_LIST_HEAD(&fmt->sort_list);\n\tfmt->cmp\t= dim->cmp;\n\tfmt->sort\t= dim->cmp;\n\tfmt->color\t= NULL;\n\tfmt->entry\t= dim->entry;\n\tfmt->header\t= fmt_header;\n\tfmt->width\t= fmt_width;\n\tfmt->collapse\t= dim->cmp;\n\tfmt->equal\t= fmt_equal;\n\tfmt->free\t= fmt_free;\n\n\treturn kvm_fmt;\n}\n\nstatic int kvm_hists__init_output(struct perf_hpp_list *hpp_list, char *name)\n{\n\tstruct kvm_fmt *kvm_fmt = get_format(name);\n\n\tif (!kvm_fmt) {\n\t\tpr_warning(\"Fail to find format for output field %s.\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\tperf_hpp_list__column_register(hpp_list, &kvm_fmt->fmt);\n\treturn 0;\n}\n\nstatic int kvm_hists__init_sort(struct perf_hpp_list *hpp_list, char *name)\n{\n\tstruct kvm_fmt *kvm_fmt = get_format(name);\n\n\tif (!kvm_fmt) {\n\t\tpr_warning(\"Fail to find format for sorting %s.\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\tperf_hpp_list__register_sort_field(hpp_list, &kvm_fmt->fmt);\n\treturn 0;\n}\n\nstatic int kvm_hpp_list__init(char *list,\n\t\t\t      struct perf_hpp_list *hpp_list,\n\t\t\t      int (*fn)(struct perf_hpp_list *hpp_list,\n\t\t\t\t\tchar *name))\n{\n\tchar *tmp, *tok;\n\tint ret;\n\n\tif (!list || !fn)\n\t\treturn 0;\n\n\tfor (tok = strtok_r(list, \", \", &tmp); tok;\n\t     tok = strtok_r(NULL, \", \", &tmp)) {\n\t\tret = fn(hpp_list, tok);\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ret == -EINVAL)\n\t\t\tpr_err(\"Invalid field key: '%s'\", tok);\n\t\telse if (ret == -ESRCH)\n\t\t\tpr_err(\"Unknown field key: '%s'\", tok);\n\t\telse\n\t\t\tpr_err(\"Fail to initialize for field key: '%s'\", tok);\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int kvm_hpp_list__parse(struct perf_hpp_list *hpp_list,\n\t\t\t       const char *output_, const char *sort_)\n{\n\tchar *output = output_ ? strdup(output_) : NULL;\n\tchar *sort = sort_ ? strdup(sort_) : NULL;\n\tint ret;\n\n\tret = kvm_hpp_list__init(output, hpp_list, kvm_hists__init_output);\n\tif (ret)\n\t\tgoto out;\n\n\tret = kvm_hpp_list__init(sort, hpp_list, kvm_hists__init_sort);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tperf_hpp__setup_output_field(hpp_list);\n\n\t \n\tperf_hpp__append_sort_keys(hpp_list);\nout:\n\tfree(output);\n\tfree(sort);\n\treturn ret;\n}\n\nstatic int kvm_hists__init(void)\n{\n\tkvm_hists.list.nr_header_lines = 1;\n\t__hists__init(&kvm_hists.hists, &kvm_hists.list);\n\tperf_hpp_list__init(&kvm_hists.list);\n\treturn kvm_hpp_list__parse(&kvm_hists.list, NULL, \"ev_name\");\n}\n\nstatic int kvm_hists__reinit(const char *output, const char *sort)\n{\n\tperf_hpp__reset_output_field(&kvm_hists.list);\n\treturn kvm_hpp_list__parse(&kvm_hists.list, output, sort);\n}\nstatic void print_result(struct perf_kvm_stat *kvm);\n\n#ifdef HAVE_SLANG_SUPPORT\nstatic void kvm_browser__update_nr_entries(struct hist_browser *hb)\n{\n\tstruct rb_node *nd = rb_first_cached(&hb->hists->entries);\n\tu64 nr_entries = 0;\n\n\tfor (; nd; nd = rb_next(nd)) {\n\t\tstruct hist_entry *he = rb_entry(nd, struct hist_entry,\n\t\t\t\t\t\t rb_node);\n\n\t\tif (!he->filtered)\n\t\t\tnr_entries++;\n\t}\n\n\thb->nr_non_filtered_entries = nr_entries;\n}\n\nstatic int kvm_browser__title(struct hist_browser *browser,\n\t\t\t      char *buf, size_t size)\n{\n\tscnprintf(buf, size, \"KVM event statistics (%lu entries)\",\n\t\t  browser->nr_non_filtered_entries);\n\treturn 0;\n}\n\nstatic struct hist_browser*\nperf_kvm_browser__new(struct hists *hists)\n{\n\tstruct hist_browser *browser = hist_browser__new(hists);\n\n\tif (browser)\n\t\tbrowser->title = kvm_browser__title;\n\n\treturn browser;\n}\n\nstatic int kvm__hists_browse(struct hists *hists)\n{\n\tstruct hist_browser *browser;\n\tint key = -1;\n\n\tbrowser = perf_kvm_browser__new(hists);\n\tif (browser == NULL)\n\t\treturn -1;\n\n\t \n\tSLang_reset_tty();\n\tSLang_init_tty(0, 0, 0);\n\n\tkvm_browser__update_nr_entries(browser);\n\n\twhile (1) {\n\t\tkey = hist_browser__run(browser, \"? - help\", true, 0);\n\n\t\tswitch (key) {\n\t\tcase 'q':\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\thist_browser__delete(browser);\n\treturn 0;\n}\n\nstatic void kvm_display(struct perf_kvm_stat *kvm)\n{\n\tif (!use_browser)\n\t\tprint_result(kvm);\n\telse\n\t\tkvm__hists_browse(&kvm_hists.hists);\n}\n\n#else\n\nstatic void kvm_display(struct perf_kvm_stat *kvm)\n{\n\tuse_browser = 0;\n\tprint_result(kvm);\n}\n\n#endif  \n\n#endif \n\nstatic const char *get_filename_for_perf_kvm(void)\n{\n\tconst char *filename;\n\n\tif (perf_host && !perf_guest)\n\t\tfilename = strdup(\"perf.data.host\");\n\telse if (!perf_host && perf_guest)\n\t\tfilename = strdup(\"perf.data.guest\");\n\telse\n\t\tfilename = strdup(\"perf.data.kvm\");\n\n\treturn filename;\n}\n\n#if defined(HAVE_KVM_STAT_SUPPORT) && defined(HAVE_LIBTRACEEVENT)\n\nvoid exit_event_get_key(struct evsel *evsel,\n\t\t\tstruct perf_sample *sample,\n\t\t\tstruct event_key *key)\n{\n\tkey->info = 0;\n\tkey->key  = evsel__intval(evsel, sample, kvm_exit_reason);\n}\n\nbool kvm_exit_event(struct evsel *evsel)\n{\n\treturn evsel__name_is(evsel, kvm_exit_trace);\n}\n\nbool exit_event_begin(struct evsel *evsel,\n\t\t      struct perf_sample *sample, struct event_key *key)\n{\n\tif (kvm_exit_event(evsel)) {\n\t\texit_event_get_key(evsel, sample, key);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool kvm_entry_event(struct evsel *evsel)\n{\n\treturn evsel__name_is(evsel, kvm_entry_trace);\n}\n\nbool exit_event_end(struct evsel *evsel,\n\t\t    struct perf_sample *sample __maybe_unused,\n\t\t    struct event_key *key __maybe_unused)\n{\n\treturn kvm_entry_event(evsel);\n}\n\nstatic const char *get_exit_reason(struct perf_kvm_stat *kvm,\n\t\t\t\t   struct exit_reasons_table *tbl,\n\t\t\t\t   u64 exit_code)\n{\n\twhile (tbl->reason != NULL) {\n\t\tif (tbl->exit_code == exit_code)\n\t\t\treturn tbl->reason;\n\t\ttbl++;\n\t}\n\n\tpr_err(\"unknown kvm exit code:%lld on %s\\n\",\n\t\t(unsigned long long)exit_code, kvm->exit_reasons_isa);\n\treturn \"UNKNOWN\";\n}\n\nvoid exit_event_decode_key(struct perf_kvm_stat *kvm,\n\t\t\t   struct event_key *key,\n\t\t\t   char *decode)\n{\n\tconst char *exit_reason = get_exit_reason(kvm, key->exit_reasons,\n\t\t\t\t\t\t  key->key);\n\n\tscnprintf(decode, KVM_EVENT_NAME_LEN, \"%s\", exit_reason);\n}\n\nstatic bool register_kvm_events_ops(struct perf_kvm_stat *kvm)\n{\n\tstruct kvm_reg_events_ops *events_ops = kvm_reg_events_ops;\n\n\tfor (events_ops = kvm_reg_events_ops; events_ops->name; events_ops++) {\n\t\tif (!strcmp(events_ops->name, kvm->report_event)) {\n\t\t\tkvm->events_ops = events_ops->ops;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstruct vcpu_event_record {\n\tint vcpu_id;\n\tu64 start_time;\n\tstruct kvm_event *last_event;\n};\n\n#ifdef HAVE_TIMERFD_SUPPORT\nstatic void clear_events_cache_stats(void)\n{\n\tstruct rb_root_cached *root;\n\tstruct rb_node *nd;\n\tstruct kvm_event *event;\n\tint i;\n\n\tif (hists__has(&kvm_hists.hists, need_collapse))\n\t\troot = &kvm_hists.hists.entries_collapsed;\n\telse\n\t\troot = kvm_hists.hists.entries_in;\n\n\tfor (nd = rb_first_cached(root); nd; nd = rb_next(nd)) {\n\t\tstruct hist_entry *he;\n\n\t\the = rb_entry(nd, struct hist_entry, rb_node_in);\n\t\tevent = container_of(he, struct kvm_event, he);\n\n\t\t \n\t\tevent->total.time = 0;\n\t\tinit_stats(&event->total.stats);\n\n\t\tfor (i = 0; i < event->max_vcpu; ++i) {\n\t\t\tevent->vcpu[i].time = 0;\n\t\t\tinit_stats(&event->vcpu[i].stats);\n\t\t}\n\t}\n}\n#endif\n\nstatic bool kvm_event_expand(struct kvm_event *event, int vcpu_id)\n{\n\tint old_max_vcpu = event->max_vcpu;\n\tvoid *prev;\n\n\tif (vcpu_id < event->max_vcpu)\n\t\treturn true;\n\n\twhile (event->max_vcpu <= vcpu_id)\n\t\tevent->max_vcpu += DEFAULT_VCPU_NUM;\n\n\tprev = event->vcpu;\n\tevent->vcpu = realloc(event->vcpu,\n\t\t\t      event->max_vcpu * sizeof(*event->vcpu));\n\tif (!event->vcpu) {\n\t\tfree(prev);\n\t\tpr_err(\"Not enough memory\\n\");\n\t\treturn false;\n\t}\n\n\tmemset(event->vcpu + old_max_vcpu, 0,\n\t       (event->max_vcpu - old_max_vcpu) * sizeof(*event->vcpu));\n\treturn true;\n}\n\nstatic void *kvm_he_zalloc(size_t size)\n{\n\tstruct kvm_event *kvm_ev;\n\n\tkvm_ev = zalloc(size + sizeof(*kvm_ev));\n\tif (!kvm_ev)\n\t\treturn NULL;\n\n\tinit_stats(&kvm_ev->total.stats);\n\thists__inc_nr_samples(&kvm_hists.hists, 0);\n\treturn &kvm_ev->he;\n}\n\nstatic void kvm_he_free(void *he)\n{\n\tstruct kvm_event *kvm_ev;\n\n\tkvm_ev = container_of(he, struct kvm_event, he);\n\tfree(kvm_ev);\n}\n\nstatic struct hist_entry_ops kvm_ev_entry_ops = {\n\t.new\t= kvm_he_zalloc,\n\t.free\t= kvm_he_free,\n};\n\nstatic struct kvm_event *find_create_kvm_event(struct perf_kvm_stat *kvm,\n\t\t\t\t\t       struct event_key *key,\n\t\t\t\t\t       struct perf_sample *sample)\n{\n\tstruct kvm_event *event;\n\tstruct hist_entry *he;\n\tstruct kvm_info *ki;\n\n\tBUG_ON(key->key == INVALID_KEY);\n\n\tki = kvm_info__new();\n\tif (!ki) {\n\t\tpr_err(\"Failed to allocate kvm info\\n\");\n\t\treturn NULL;\n\t}\n\n\tkvm->events_ops->decode_key(kvm, key, ki->name);\n\the = hists__add_entry_ops(&kvm_hists.hists, &kvm_ev_entry_ops,\n\t\t\t\t  &kvm->al, NULL, NULL, NULL, ki, sample, true);\n\tif (he == NULL) {\n\t\tpr_err(\"Failed to allocate hist entry\\n\");\n\t\tfree(ki);\n\t\treturn NULL;\n\t}\n\n\tevent = container_of(he, struct kvm_event, he);\n\tif (!event->perf_kvm) {\n\t\tevent->perf_kvm = kvm;\n\t\tevent->key = *key;\n\t}\n\n\treturn event;\n}\n\nstatic bool handle_begin_event(struct perf_kvm_stat *kvm,\n\t\t\t       struct vcpu_event_record *vcpu_record,\n\t\t\t       struct event_key *key,\n\t\t\t       struct perf_sample *sample)\n{\n\tstruct kvm_event *event = NULL;\n\n\tif (key->key != INVALID_KEY)\n\t\tevent = find_create_kvm_event(kvm, key, sample);\n\n\tvcpu_record->last_event = event;\n\tvcpu_record->start_time = sample->time;\n\treturn true;\n}\n\nstatic void\nkvm_update_event_stats(struct kvm_event_stats *kvm_stats, u64 time_diff)\n{\n\tkvm_stats->time += time_diff;\n\tupdate_stats(&kvm_stats->stats, time_diff);\n}\n\nstatic double kvm_event_rel_stddev(int vcpu_id, struct kvm_event *event)\n{\n\tstruct kvm_event_stats *kvm_stats = &event->total;\n\n\tif (vcpu_id != -1)\n\t\tkvm_stats = &event->vcpu[vcpu_id];\n\n\treturn rel_stddev_stats(stddev_stats(&kvm_stats->stats),\n\t\t\t\tavg_stats(&kvm_stats->stats));\n}\n\nstatic bool update_kvm_event(struct perf_kvm_stat *kvm,\n\t\t\t     struct kvm_event *event, int vcpu_id,\n\t\t\t     u64 time_diff)\n{\n\t \n\tkvm->total_count++;\n\tkvm->total_time += time_diff;\n\n\tif (vcpu_id == -1) {\n\t\tkvm_update_event_stats(&event->total, time_diff);\n\t\treturn true;\n\t}\n\n\tif (!kvm_event_expand(event, vcpu_id))\n\t\treturn false;\n\n\tkvm_update_event_stats(&event->vcpu[vcpu_id], time_diff);\n\treturn true;\n}\n\nstatic bool is_child_event(struct perf_kvm_stat *kvm,\n\t\t\t   struct evsel *evsel,\n\t\t\t   struct perf_sample *sample,\n\t\t\t   struct event_key *key)\n{\n\tstruct child_event_ops *child_ops;\n\n\tchild_ops = kvm->events_ops->child_ops;\n\n\tif (!child_ops)\n\t\treturn false;\n\n\tfor (; child_ops->name; child_ops++) {\n\t\tif (evsel__name_is(evsel, child_ops->name)) {\n\t\t\tchild_ops->get_key(evsel, sample, key);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool handle_child_event(struct perf_kvm_stat *kvm,\n\t\t\t       struct vcpu_event_record *vcpu_record,\n\t\t\t       struct event_key *key,\n\t\t\t       struct perf_sample *sample)\n{\n\tstruct kvm_event *event = NULL;\n\n\tif (key->key != INVALID_KEY)\n\t\tevent = find_create_kvm_event(kvm, key, sample);\n\n\tvcpu_record->last_event = event;\n\n\treturn true;\n}\n\nstatic bool skip_event(const char *event)\n{\n\tconst char * const *skip_events;\n\n\tfor (skip_events = kvm_skip_events; *skip_events; skip_events++)\n\t\tif (!strcmp(event, *skip_events))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool handle_end_event(struct perf_kvm_stat *kvm,\n\t\t\t     struct vcpu_event_record *vcpu_record,\n\t\t\t     struct event_key *key,\n\t\t\t     struct perf_sample *sample)\n{\n\tstruct kvm_event *event;\n\tu64 time_begin, time_diff;\n\tint vcpu;\n\n\tif (kvm->trace_vcpu == -1)\n\t\tvcpu = -1;\n\telse\n\t\tvcpu = vcpu_record->vcpu_id;\n\n\tevent = vcpu_record->last_event;\n\ttime_begin = vcpu_record->start_time;\n\n\t \n\tif (!time_begin)\n\t\treturn true;\n\n\t \n\n\t \n\tif (!event && key->key == INVALID_KEY)\n\t\treturn true;\n\n\tif (!event)\n\t\tevent = find_create_kvm_event(kvm, key, sample);\n\n\tif (!event)\n\t\treturn false;\n\n\tvcpu_record->last_event = NULL;\n\tvcpu_record->start_time = 0;\n\n\t \n\tif (sample->time < time_begin) {\n\t\tpr_debug(\"End time before begin time; skipping event.\\n\");\n\t\treturn true;\n\t}\n\n\ttime_diff = sample->time - time_begin;\n\n\tif (kvm->duration && time_diff > kvm->duration) {\n\t\tchar decode[KVM_EVENT_NAME_LEN];\n\n\t\tkvm->events_ops->decode_key(kvm, &event->key, decode);\n\t\tif (!skip_event(decode)) {\n\t\t\tpr_info(\"%\" PRIu64 \" VM %d, vcpu %d: %s event took %\" PRIu64 \"usec\\n\",\n\t\t\t\t sample->time, sample->pid, vcpu_record->vcpu_id,\n\t\t\t\t decode, time_diff / NSEC_PER_USEC);\n\t\t}\n\t}\n\n\treturn update_kvm_event(kvm, event, vcpu, time_diff);\n}\n\nstatic\nstruct vcpu_event_record *per_vcpu_record(struct thread *thread,\n\t\t\t\t\t  struct evsel *evsel,\n\t\t\t\t\t  struct perf_sample *sample)\n{\n\t \n\tif (!thread__priv(thread) && kvm_entry_event(evsel)) {\n\t\tstruct vcpu_event_record *vcpu_record;\n\n\t\tvcpu_record = zalloc(sizeof(*vcpu_record));\n\t\tif (!vcpu_record) {\n\t\t\tpr_err(\"%s: Not enough memory\\n\", __func__);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tvcpu_record->vcpu_id = evsel__intval(evsel, sample, vcpu_id_str);\n\t\tthread__set_priv(thread, vcpu_record);\n\t}\n\n\treturn thread__priv(thread);\n}\n\nstatic bool handle_kvm_event(struct perf_kvm_stat *kvm,\n\t\t\t     struct thread *thread,\n\t\t\t     struct evsel *evsel,\n\t\t\t     struct perf_sample *sample)\n{\n\tstruct vcpu_event_record *vcpu_record;\n\tstruct event_key key = { .key = INVALID_KEY,\n\t\t\t\t .exit_reasons = kvm->exit_reasons };\n\n\tvcpu_record = per_vcpu_record(thread, evsel, sample);\n\tif (!vcpu_record)\n\t\treturn true;\n\n\t \n\tif ((kvm->trace_vcpu != -1) &&\n\t    (kvm->trace_vcpu != vcpu_record->vcpu_id))\n\t\treturn true;\n\n\tif (kvm->events_ops->is_begin_event(evsel, sample, &key))\n\t\treturn handle_begin_event(kvm, vcpu_record, &key, sample);\n\n\tif (is_child_event(kvm, evsel, sample, &key))\n\t\treturn handle_child_event(kvm, vcpu_record, &key, sample);\n\n\tif (kvm->events_ops->is_end_event(evsel, sample, &key))\n\t\treturn handle_end_event(kvm, vcpu_record, &key, sample);\n\n\treturn true;\n}\n\nstatic bool is_valid_key(struct perf_kvm_stat *kvm)\n{\n\tstatic const char *key_array[] = {\n\t\t\"ev_name\", \"sample\", \"time\", \"max_t\", \"min_t\", \"mean_t\",\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(key_array); i++)\n\t\tif (!strcmp(key_array[i], kvm->sort_key))\n\t\t\treturn true;\n\n\tpr_err(\"Unsupported sort key: %s\\n\", kvm->sort_key);\n\treturn false;\n}\n\nstatic bool event_is_valid(struct kvm_event *event, int vcpu)\n{\n\treturn !!get_event_count(event, vcpu);\n}\n\nstatic int filter_cb(struct hist_entry *he, void *arg __maybe_unused)\n{\n\tstruct kvm_event *event;\n\tstruct perf_kvm_stat *perf_kvm;\n\n\tevent = container_of(he, struct kvm_event, he);\n\tperf_kvm = event->perf_kvm;\n\tif (!event_is_valid(event, perf_kvm->trace_vcpu))\n\t\the->filtered = 1;\n\telse\n\t\the->filtered = 0;\n\treturn 0;\n}\n\nstatic void sort_result(struct perf_kvm_stat *kvm)\n{\n\tstruct ui_progress prog;\n\tconst char *output_columns = \"ev_name,sample,percent_sample,\"\n\t\t\t\t     \"time,percent_time,max_t,min_t,mean_t\";\n\n\tkvm_hists__reinit(output_columns, kvm->sort_key);\n\tui_progress__init(&prog, kvm_hists.hists.nr_entries, \"Sorting...\");\n\thists__collapse_resort(&kvm_hists.hists, NULL);\n\thists__output_resort_cb(&kvm_hists.hists, NULL, filter_cb);\n\tui_progress__finish();\n}\n\nstatic void print_vcpu_info(struct perf_kvm_stat *kvm)\n{\n\tint vcpu = kvm->trace_vcpu;\n\n\tpr_info(\"Analyze events for \");\n\n\tif (kvm->opts.target.system_wide)\n\t\tpr_info(\"all VMs, \");\n\telse if (kvm->opts.target.pid)\n\t\tpr_info(\"pid(s) %s, \", kvm->opts.target.pid);\n\telse\n\t\tpr_info(\"dazed and confused on what is monitored, \");\n\n\tif (vcpu == -1)\n\t\tpr_info(\"all VCPUs:\\n\\n\");\n\telse\n\t\tpr_info(\"VCPU %d:\\n\\n\", vcpu);\n}\n\nstatic void show_timeofday(void)\n{\n\tchar date[64];\n\tstruct timeval tv;\n\tstruct tm ltime;\n\n\tgettimeofday(&tv, NULL);\n\tif (localtime_r(&tv.tv_sec, &ltime)) {\n\t\tstrftime(date, sizeof(date), \"%H:%M:%S\", &ltime);\n\t\tpr_info(\"%s.%06ld\", date, tv.tv_usec);\n\t} else\n\t\tpr_info(\"00:00:00.000000\");\n\n\treturn;\n}\n\nstatic void print_result(struct perf_kvm_stat *kvm)\n{\n\tchar decode[KVM_EVENT_NAME_LEN];\n\tstruct kvm_event *event;\n\tint vcpu = kvm->trace_vcpu;\n\tstruct rb_node *nd;\n\n\tif (kvm->live) {\n\t\tputs(CONSOLE_CLEAR);\n\t\tshow_timeofday();\n\t}\n\n\tpr_info(\"\\n\\n\");\n\tprint_vcpu_info(kvm);\n\tpr_info(\"%*s \", KVM_EVENT_NAME_LEN, kvm->events_ops->name);\n\tpr_info(\"%10s \", \"Samples\");\n\tpr_info(\"%9s \", \"Samples%\");\n\n\tpr_info(\"%9s \", \"Time%\");\n\tpr_info(\"%11s \", \"Min Time\");\n\tpr_info(\"%11s \", \"Max Time\");\n\tpr_info(\"%16s \", \"Avg time\");\n\tpr_info(\"\\n\\n\");\n\n\tfor (nd = rb_first_cached(&kvm_hists.hists.entries); nd; nd = rb_next(nd)) {\n\t\tstruct hist_entry *he;\n\t\tu64 ecount, etime, max, min;\n\n\t\the = rb_entry(nd, struct hist_entry, rb_node);\n\t\tif (he->filtered)\n\t\t\tcontinue;\n\n\t\tevent = container_of(he, struct kvm_event, he);\n\t\tecount = get_event_count(event, vcpu);\n\t\tetime = get_event_time(event, vcpu);\n\t\tmax = get_event_max(event, vcpu);\n\t\tmin = get_event_min(event, vcpu);\n\n\t\tkvm->events_ops->decode_key(kvm, &event->key, decode);\n\t\tpr_info(\"%*s \", KVM_EVENT_NAME_LEN, decode);\n\t\tpr_info(\"%10llu \", (unsigned long long)ecount);\n\t\tpr_info(\"%8.2f%% \", (double)ecount / kvm->total_count * 100);\n\t\tpr_info(\"%8.2f%% \", (double)etime / kvm->total_time * 100);\n\t\tpr_info(\"%9.2fus \", (double)min / NSEC_PER_USEC);\n\t\tpr_info(\"%9.2fus \", (double)max / NSEC_PER_USEC);\n\t\tpr_info(\"%9.2fus ( +-%7.2f%% )\", (double)etime / ecount / NSEC_PER_USEC,\n\t\t\tkvm_event_rel_stddev(vcpu, event));\n\t\tpr_info(\"\\n\");\n\t}\n\n\tpr_info(\"\\nTotal Samples:%\" PRIu64 \", Total events handled time:%.2fus.\\n\\n\",\n\t\tkvm->total_count, kvm->total_time / (double)NSEC_PER_USEC);\n\n\tif (kvm->lost_events)\n\t\tpr_info(\"\\nLost events: %\" PRIu64 \"\\n\\n\", kvm->lost_events);\n}\n\n#if defined(HAVE_TIMERFD_SUPPORT) && defined(HAVE_LIBTRACEEVENT)\nstatic int process_lost_event(struct perf_tool *tool,\n\t\t\t      union perf_event *event __maybe_unused,\n\t\t\t      struct perf_sample *sample __maybe_unused,\n\t\t\t      struct machine *machine __maybe_unused)\n{\n\tstruct perf_kvm_stat *kvm = container_of(tool, struct perf_kvm_stat, tool);\n\n\tkvm->lost_events++;\n\treturn 0;\n}\n#endif\n\nstatic bool skip_sample(struct perf_kvm_stat *kvm,\n\t\t\tstruct perf_sample *sample)\n{\n\tif (kvm->pid_list && intlist__find(kvm->pid_list, sample->pid) == NULL)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int process_sample_event(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct evsel *evsel,\n\t\t\t\tstruct machine *machine)\n{\n\tint err = 0;\n\tstruct thread *thread;\n\tstruct perf_kvm_stat *kvm = container_of(tool, struct perf_kvm_stat,\n\t\t\t\t\t\t tool);\n\n\tif (skip_sample(kvm, sample))\n\t\treturn 0;\n\n\tif (machine__resolve(machine, &kvm->al, sample) < 0) {\n\t\tpr_warning(\"Fail to resolve address location, skip sample.\\n\");\n\t\treturn 0;\n\t}\n\n\tthread = machine__findnew_thread(machine, sample->pid, sample->tid);\n\tif (thread == NULL) {\n\t\tpr_debug(\"problem processing %d event, skipping it.\\n\",\n\t\t\tevent->header.type);\n\t\treturn -1;\n\t}\n\n\tif (!handle_kvm_event(kvm, thread, evsel, sample))\n\t\terr = -1;\n\n\tthread__put(thread);\n\treturn err;\n}\n\nstatic int cpu_isa_config(struct perf_kvm_stat *kvm)\n{\n\tchar buf[128], *cpuid;\n\tint err;\n\n\tif (kvm->live) {\n\t\terr = get_cpuid(buf, sizeof(buf));\n\t\tif (err != 0) {\n\t\t\tpr_err(\"Failed to look up CPU type: %s\\n\",\n\t\t\t       str_error_r(err, buf, sizeof(buf)));\n\t\t\treturn -err;\n\t\t}\n\t\tcpuid = buf;\n\t} else\n\t\tcpuid = kvm->session->header.env.cpuid;\n\n\tif (!cpuid) {\n\t\tpr_err(\"Failed to look up CPU type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = cpu_isa_init(kvm, cpuid);\n\tif (err == -ENOTSUP)\n\t\tpr_err(\"CPU %s is not supported.\\n\", cpuid);\n\n\treturn err;\n}\n\nstatic bool verify_vcpu(int vcpu)\n{\n\tif (vcpu != -1 && vcpu < 0) {\n\t\tpr_err(\"Invalid vcpu:%d.\\n\", vcpu);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n#if defined(HAVE_TIMERFD_SUPPORT) && defined(HAVE_LIBTRACEEVENT)\n \n#define PERF_KVM__MAX_EVENTS_PER_MMAP  25\n\nstatic s64 perf_kvm__mmap_read_idx(struct perf_kvm_stat *kvm, int idx,\n\t\t\t\t   u64 *mmap_time)\n{\n\tstruct evlist *evlist = kvm->evlist;\n\tunion perf_event *event;\n\tstruct mmap *md;\n\tu64 timestamp;\n\ts64 n = 0;\n\tint err;\n\n\t*mmap_time = ULLONG_MAX;\n\tmd = &evlist->mmap[idx];\n\terr = perf_mmap__read_init(&md->core);\n\tif (err < 0)\n\t\treturn (err == -EAGAIN) ? 0 : -1;\n\n\twhile ((event = perf_mmap__read_event(&md->core)) != NULL) {\n\t\terr = evlist__parse_sample_timestamp(evlist, event, &timestamp);\n\t\tif (err) {\n\t\t\tperf_mmap__consume(&md->core);\n\t\t\tpr_err(\"Failed to parse sample\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\terr = perf_session__queue_event(kvm->session, event, timestamp, 0, NULL);\n\t\t \n\t\tperf_mmap__consume(&md->core);\n\n\t\tif (err) {\n\t\t\tpr_err(\"Failed to enqueue sample: %d\\n\", err);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (n == 0)\n\t\t\t*mmap_time = timestamp;\n\n\t\t \n\t\tn++;\n\t\tif (n == PERF_KVM__MAX_EVENTS_PER_MMAP)\n\t\t\tbreak;\n\t}\n\n\tperf_mmap__read_done(&md->core);\n\treturn n;\n}\n\nstatic int perf_kvm__mmap_read(struct perf_kvm_stat *kvm)\n{\n\tint i, err, throttled = 0;\n\ts64 n, ntotal = 0;\n\tu64 flush_time = ULLONG_MAX, mmap_time;\n\n\tfor (i = 0; i < kvm->evlist->core.nr_mmaps; i++) {\n\t\tn = perf_kvm__mmap_read_idx(kvm, i, &mmap_time);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\n\t\t \n\t\tif (mmap_time < flush_time)\n\t\t\tflush_time = mmap_time;\n\n\t\tntotal += n;\n\t\tif (n == PERF_KVM__MAX_EVENTS_PER_MMAP)\n\t\t\tthrottled = 1;\n\t}\n\n\t \n\tif (ntotal) {\n\t\tstruct ordered_events *oe = &kvm->session->ordered_events;\n\n\t\toe->next_flush = flush_time;\n\t\terr = ordered_events__flush(oe, OE_FLUSH__ROUND);\n\t\tif (err) {\n\t\t\tif (kvm->lost_events)\n\t\t\t\tpr_info(\"\\nLost events: %\" PRIu64 \"\\n\\n\",\n\t\t\t\t\tkvm->lost_events);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn throttled;\n}\n\nstatic volatile int done;\n\nstatic void sig_handler(int sig __maybe_unused)\n{\n\tdone = 1;\n}\n\nstatic int perf_kvm__timerfd_create(struct perf_kvm_stat *kvm)\n{\n\tstruct itimerspec new_value;\n\tint rc = -1;\n\n\tkvm->timerfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);\n\tif (kvm->timerfd < 0) {\n\t\tpr_err(\"timerfd_create failed\\n\");\n\t\tgoto out;\n\t}\n\n\tnew_value.it_value.tv_sec = kvm->display_time;\n\tnew_value.it_value.tv_nsec = 0;\n\tnew_value.it_interval.tv_sec = kvm->display_time;\n\tnew_value.it_interval.tv_nsec = 0;\n\n\tif (timerfd_settime(kvm->timerfd, 0, &new_value, NULL) != 0) {\n\t\tpr_err(\"timerfd_settime failed: %d\\n\", errno);\n\t\tclose(kvm->timerfd);\n\t\tgoto out;\n\t}\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic int perf_kvm__handle_timerfd(struct perf_kvm_stat *kvm)\n{\n\tuint64_t c;\n\tint rc;\n\n\trc = read(kvm->timerfd, &c, sizeof(uint64_t));\n\tif (rc < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\n\n\t\tpr_err(\"Failed to read timer fd: %d\\n\", errno);\n\t\treturn -1;\n\t}\n\n\tif (rc != sizeof(uint64_t)) {\n\t\tpr_err(\"Error reading timer fd - invalid size returned\\n\");\n\t\treturn -1;\n\t}\n\n\tif (c != 1)\n\t\tpr_debug(\"Missed timer beats: %\" PRIu64 \"\\n\", c-1);\n\n\t \n\tsort_result(kvm);\n\tprint_result(kvm);\n\n\t \n\tkvm_hists__reinit(NULL, \"ev_name\");\n\n\t \n\tclear_events_cache_stats();\n\tkvm->total_count = 0;\n\tkvm->total_time = 0;\n\tkvm->lost_events = 0;\n\n\treturn 0;\n}\n\nstatic int fd_set_nonblock(int fd)\n{\n\tlong arg = 0;\n\n\targ = fcntl(fd, F_GETFL);\n\tif (arg < 0) {\n\t\tpr_err(\"Failed to get current flags for fd %d\\n\", fd);\n\t\treturn -1;\n\t}\n\n\tif (fcntl(fd, F_SETFL, arg | O_NONBLOCK) < 0) {\n\t\tpr_err(\"Failed to set non-block option on fd %d\\n\", fd);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_kvm__handle_stdin(void)\n{\n\tint c;\n\n\tc = getc(stdin);\n\tif (c == 'q')\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int kvm_events_live_report(struct perf_kvm_stat *kvm)\n{\n\tint nr_stdin, ret, err = -EINVAL;\n\tstruct termios save;\n\n\t \n\tkvm->live = true;\n\n\tret = cpu_isa_config(kvm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!verify_vcpu(kvm->trace_vcpu) ||\n\t    !is_valid_key(kvm) ||\n\t    !register_kvm_events_ops(kvm)) {\n\t\tgoto out;\n\t}\n\n\tset_term_quiet_input(&save);\n\n\tkvm_hists__init();\n\n\tsignal(SIGINT, sig_handler);\n\tsignal(SIGTERM, sig_handler);\n\n\t \n\tif (perf_kvm__timerfd_create(kvm) < 0) {\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tif (evlist__add_pollfd(kvm->evlist, kvm->timerfd) < 0)\n\t\tgoto out;\n\n\tnr_stdin = evlist__add_pollfd(kvm->evlist, fileno(stdin));\n\tif (nr_stdin < 0)\n\t\tgoto out;\n\n\tif (fd_set_nonblock(fileno(stdin)) != 0)\n\t\tgoto out;\n\n\t \n\tevlist__enable(kvm->evlist);\n\n\twhile (!done) {\n\t\tstruct fdarray *fda = &kvm->evlist->core.pollfd;\n\t\tint rc;\n\n\t\trc = perf_kvm__mmap_read(kvm);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\terr = perf_kvm__handle_timerfd(kvm);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (fda->entries[nr_stdin].revents & POLLIN)\n\t\t\tdone = perf_kvm__handle_stdin();\n\n\t\tif (!rc && !done)\n\t\t\terr = evlist__poll(kvm->evlist, 100);\n\t}\n\n\tevlist__disable(kvm->evlist);\n\n\tif (err == 0) {\n\t\tsort_result(kvm);\n\t\tprint_result(kvm);\n\t}\n\nout:\n\thists__delete_entries(&kvm_hists.hists);\n\n\tif (kvm->timerfd >= 0)\n\t\tclose(kvm->timerfd);\n\n\ttcsetattr(0, TCSAFLUSH, &save);\n\treturn err;\n}\n\nstatic int kvm_live_open_events(struct perf_kvm_stat *kvm)\n{\n\tint err, rc = -1;\n\tstruct evsel *pos;\n\tstruct evlist *evlist = kvm->evlist;\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tevlist__config(evlist, &kvm->opts, NULL);\n\n\t \n\tevlist__for_each_entry(evlist, pos) {\n\t\tstruct perf_event_attr *attr = &pos->core.attr;\n\n\t\t \n\t\tevsel__set_sample_bit(pos, TID);\n\t\tevsel__set_sample_bit(pos, TIME);\n\t\tevsel__set_sample_bit(pos, CPU);\n\t\tevsel__set_sample_bit(pos, RAW);\n\t\t \n\t\tevsel__reset_sample_bit(pos, PERIOD);\n\t\tevsel__reset_sample_bit(pos, IP);\n\t\tevsel__reset_sample_bit(pos, CALLCHAIN);\n\t\tevsel__reset_sample_bit(pos, ADDR);\n\t\tevsel__reset_sample_bit(pos, READ);\n\t\tattr->mmap = 0;\n\t\tattr->comm = 0;\n\t\tattr->task = 0;\n\n\t\tattr->sample_period = 1;\n\n\t\tattr->watermark = 0;\n\t\tattr->wakeup_events = 1000;\n\n\t\t \n\t\tattr->disabled = 1;\n\t}\n\n\terr = evlist__open(evlist);\n\tif (err < 0) {\n\t\tprintf(\"Couldn't create the events: %s\\n\",\n\t\t       str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\tgoto out;\n\t}\n\n\tif (evlist__mmap(evlist, kvm->opts.mmap_pages) < 0) {\n\t\tui__error(\"Failed to mmap the events: %s\\n\",\n\t\t\t  str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\tevlist__close(evlist);\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\nout:\n\treturn rc;\n}\n#endif\n\nstatic int read_events(struct perf_kvm_stat *kvm)\n{\n\tint ret;\n\n\tstruct perf_tool eops = {\n\t\t.sample\t\t\t= process_sample_event,\n\t\t.comm\t\t\t= perf_event__process_comm,\n\t\t.namespaces\t\t= perf_event__process_namespaces,\n\t\t.ordered_events\t\t= true,\n\t};\n\tstruct perf_data file = {\n\t\t.path  = kvm->file_name,\n\t\t.mode  = PERF_DATA_MODE_READ,\n\t\t.force = kvm->force,\n\t};\n\n\tkvm->tool = eops;\n\tkvm->session = perf_session__new(&file, &kvm->tool);\n\tif (IS_ERR(kvm->session)) {\n\t\tpr_err(\"Initializing perf session failed\\n\");\n\t\treturn PTR_ERR(kvm->session);\n\t}\n\n\tsymbol__init(&kvm->session->header.env);\n\n\tif (!perf_session__has_traces(kvm->session, \"kvm record\")) {\n\t\tret = -EINVAL;\n\t\tgoto out_delete;\n\t}\n\n\t \n\tret = cpu_isa_config(kvm);\n\tif (ret < 0)\n\t\tgoto out_delete;\n\n\tret = perf_session__process_events(kvm->session);\n\nout_delete:\n\tperf_session__delete(kvm->session);\n\treturn ret;\n}\n\nstatic int parse_target_str(struct perf_kvm_stat *kvm)\n{\n\tif (kvm->opts.target.pid) {\n\t\tkvm->pid_list = intlist__new(kvm->opts.target.pid);\n\t\tif (kvm->pid_list == NULL) {\n\t\t\tpr_err(\"Error parsing process id string\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_events_report_vcpu(struct perf_kvm_stat *kvm)\n{\n\tint ret = -EINVAL;\n\tint vcpu = kvm->trace_vcpu;\n\n\tif (parse_target_str(kvm) != 0)\n\t\tgoto exit;\n\n\tif (!verify_vcpu(vcpu))\n\t\tgoto exit;\n\n\tif (!is_valid_key(kvm))\n\t\tgoto exit;\n\n\tif (!register_kvm_events_ops(kvm))\n\t\tgoto exit;\n\n\tif (kvm->use_stdio) {\n\t\tuse_browser = 0;\n\t\tsetup_pager();\n\t} else {\n\t\tuse_browser = 1;\n\t}\n\n\tsetup_browser(false);\n\n\tkvm_hists__init();\n\n\tret = read_events(kvm);\n\tif (ret)\n\t\tgoto exit;\n\n\tsort_result(kvm);\n\tkvm_display(kvm);\n\nexit:\n\thists__delete_entries(&kvm_hists.hists);\n\treturn ret;\n}\n\n#define STRDUP_FAIL_EXIT(s)\t\t\\\n\t({\tchar *_p;\t\t\\\n\t_p = strdup(s);\t\t\\\n\t\tif (!_p)\t\t\\\n\t\t\treturn -ENOMEM;\t\\\n\t\t_p;\t\t\t\\\n\t})\n\nint __weak setup_kvm_events_tp(struct perf_kvm_stat *kvm __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int\nkvm_events_record(struct perf_kvm_stat *kvm, int argc, const char **argv)\n{\n\tunsigned int rec_argc, i, j, events_tp_size;\n\tconst char **rec_argv;\n\tconst char * const record_args[] = {\n\t\t\"record\",\n\t\t\"-R\",\n\t\t\"-m\", \"1024\",\n\t\t\"-c\", \"1\",\n\t};\n\tconst char * const kvm_stat_record_usage[] = {\n\t\t\"perf kvm stat record [<options>]\",\n\t\tNULL\n\t};\n\tconst char * const *events_tp;\n\tint ret;\n\n\tevents_tp_size = 0;\n\tret = setup_kvm_events_tp(kvm);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to setup the kvm tracepoints\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (events_tp = kvm_events_tp; *events_tp; events_tp++)\n\t\tevents_tp_size++;\n\n\trec_argc = ARRAY_SIZE(record_args) + argc + 2 +\n\t\t   2 * events_tp_size;\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\n\tif (rec_argv == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(record_args); i++)\n\t\trec_argv[i] = STRDUP_FAIL_EXIT(record_args[i]);\n\n\tfor (j = 0; j < events_tp_size; j++) {\n\t\trec_argv[i++] = \"-e\";\n\t\trec_argv[i++] = STRDUP_FAIL_EXIT(kvm_events_tp[j]);\n\t}\n\n\trec_argv[i++] = STRDUP_FAIL_EXIT(\"-o\");\n\trec_argv[i++] = STRDUP_FAIL_EXIT(kvm->file_name);\n\n\tfor (j = 1; j < (unsigned int)argc; j++, i++)\n\t\trec_argv[i] = argv[j];\n\n\tset_option_flag(record_options, 'e', \"event\", PARSE_OPT_HIDDEN);\n\tset_option_flag(record_options, 0, \"filter\", PARSE_OPT_HIDDEN);\n\tset_option_flag(record_options, 'R', \"raw-samples\", PARSE_OPT_HIDDEN);\n\n\tset_option_flag(record_options, 'F', \"freq\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 0, \"group\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'g', NULL, PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 0, \"call-graph\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'd', \"data\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'T', \"timestamp\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'P', \"period\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'n', \"no-samples\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'N', \"no-buildid-cache\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'B', \"no-buildid\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'G', \"cgroup\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'b', \"branch-any\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'j', \"branch-filter\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 'W', \"weight\", PARSE_OPT_DISABLED);\n\tset_option_flag(record_options, 0, \"transaction\", PARSE_OPT_DISABLED);\n\n\trecord_usage = kvm_stat_record_usage;\n\treturn cmd_record(i, rec_argv);\n}\n\nstatic int\nkvm_events_report(struct perf_kvm_stat *kvm, int argc, const char **argv)\n{\n\tconst struct option kvm_events_report_options[] = {\n\t\tOPT_STRING(0, \"event\", &kvm->report_event, \"report event\",\n\t\t\t   \"event for reporting: vmexit, \"\n\t\t\t   \"mmio (x86 only), ioport (x86 only)\"),\n\t\tOPT_INTEGER(0, \"vcpu\", &kvm->trace_vcpu,\n\t\t\t    \"vcpu id to report\"),\n\t\tOPT_STRING('k', \"key\", &kvm->sort_key, \"sort-key\",\n\t\t\t    \"key for sorting: sample(sort by samples number)\"\n\t\t\t    \" time (sort by avg time)\"),\n\t\tOPT_STRING('p', \"pid\", &kvm->opts.target.pid, \"pid\",\n\t\t\t   \"analyze events only for given process id(s)\"),\n\t\tOPT_BOOLEAN('f', \"force\", &kvm->force, \"don't complain, do it\"),\n\t\tOPT_BOOLEAN(0, \"stdio\", &kvm->use_stdio, \"use the stdio interface\"),\n\t\tOPT_END()\n\t};\n\n\tconst char * const kvm_events_report_usage[] = {\n\t\t\"perf kvm stat report [<options>]\",\n\t\tNULL\n\t};\n\n\tif (argc) {\n\t\targc = parse_options(argc, argv,\n\t\t\t\t     kvm_events_report_options,\n\t\t\t\t     kvm_events_report_usage, 0);\n\t\tif (argc)\n\t\t\tusage_with_options(kvm_events_report_usage,\n\t\t\t\t\t   kvm_events_report_options);\n\t}\n\n#ifndef HAVE_SLANG_SUPPORT\n\tkvm->use_stdio = true;\n#endif\n\n\tif (!kvm->opts.target.pid)\n\t\tkvm->opts.target.system_wide = true;\n\n\treturn kvm_events_report_vcpu(kvm);\n}\n\n#if defined(HAVE_TIMERFD_SUPPORT) && defined(HAVE_LIBTRACEEVENT)\nstatic struct evlist *kvm_live_event_list(void)\n{\n\tstruct evlist *evlist;\n\tchar *tp, *name, *sys;\n\tint err = -1;\n\tconst char * const *events_tp;\n\n\tevlist = evlist__new();\n\tif (evlist == NULL)\n\t\treturn NULL;\n\n\tfor (events_tp = kvm_events_tp; *events_tp; events_tp++) {\n\n\t\ttp = strdup(*events_tp);\n\t\tif (tp == NULL)\n\t\t\tgoto out;\n\n\t\t \n\t\tsys = tp;\n\t\tname = strchr(tp, ':');\n\t\tif (name == NULL) {\n\t\t\tpr_err(\"Error parsing %s tracepoint: subsystem delimiter not found\\n\",\n\t\t\t       *events_tp);\n\t\t\tfree(tp);\n\t\t\tgoto out;\n\t\t}\n\t\t*name = '\\0';\n\t\tname++;\n\n\t\tif (evlist__add_newtp(evlist, sys, name, NULL)) {\n\t\t\tpr_err(\"Failed to add %s tracepoint to the list\\n\", *events_tp);\n\t\t\tfree(tp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfree(tp);\n\t}\n\n\terr = 0;\n\nout:\n\tif (err) {\n\t\tevlist__delete(evlist);\n\t\tevlist = NULL;\n\t}\n\n\treturn evlist;\n}\n\nstatic int kvm_events_live(struct perf_kvm_stat *kvm,\n\t\t\t   int argc, const char **argv)\n{\n\tchar errbuf[BUFSIZ];\n\tint err;\n\n\tconst struct option live_options[] = {\n\t\tOPT_STRING('p', \"pid\", &kvm->opts.target.pid, \"pid\",\n\t\t\t\"record events on existing process id\"),\n\t\tOPT_CALLBACK('m', \"mmap-pages\", &kvm->opts.mmap_pages, \"pages\",\n\t\t\t\"number of mmap data pages\", evlist__parse_mmap_pages),\n\t\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t\t\"be more verbose (show counter open errors, etc)\"),\n\t\tOPT_BOOLEAN('a', \"all-cpus\", &kvm->opts.target.system_wide,\n\t\t\t\"system-wide collection from all CPUs\"),\n\t\tOPT_UINTEGER('d', \"display\", &kvm->display_time,\n\t\t\t\"time in seconds between display updates\"),\n\t\tOPT_STRING(0, \"event\", &kvm->report_event, \"report event\",\n\t\t\t\"event for reporting: \"\n\t\t\t\"vmexit, mmio (x86 only), ioport (x86 only)\"),\n\t\tOPT_INTEGER(0, \"vcpu\", &kvm->trace_vcpu,\n\t\t\t\"vcpu id to report\"),\n\t\tOPT_STRING('k', \"key\", &kvm->sort_key, \"sort-key\",\n\t\t\t\"key for sorting: sample(sort by samples number)\"\n\t\t\t\" time (sort by avg time)\"),\n\t\tOPT_U64(0, \"duration\", &kvm->duration,\n\t\t\t\"show events other than\"\n\t\t\t\" HLT (x86 only) or Wait state (s390 only)\"\n\t\t\t\" that take longer than duration usecs\"),\n\t\tOPT_UINTEGER(0, \"proc-map-timeout\", &proc_map_timeout,\n\t\t\t\t\"per thread proc mmap processing timeout in ms\"),\n\t\tOPT_END()\n\t};\n\tconst char * const live_usage[] = {\n\t\t\"perf kvm stat live [<options>]\",\n\t\tNULL\n\t};\n\tstruct perf_data data = {\n\t\t.mode = PERF_DATA_MODE_WRITE,\n\t};\n\n\n\t \n\tkvm->tool.sample = process_sample_event;\n\tkvm->tool.comm   = perf_event__process_comm;\n\tkvm->tool.exit   = perf_event__process_exit;\n\tkvm->tool.fork   = perf_event__process_fork;\n\tkvm->tool.lost   = process_lost_event;\n\tkvm->tool.namespaces  = perf_event__process_namespaces;\n\tkvm->tool.ordered_events = true;\n\tperf_tool__fill_defaults(&kvm->tool);\n\n\t \n\tkvm->display_time = 1;\n\tkvm->opts.user_interval = 1;\n\tkvm->opts.mmap_pages = 512;\n\tkvm->opts.target.uses_mmap = false;\n\tkvm->opts.target.uid_str = NULL;\n\tkvm->opts.target.uid = UINT_MAX;\n\n\tsymbol__init(NULL);\n\tdisable_buildid_cache();\n\n\tuse_browser = 0;\n\n\tif (argc) {\n\t\targc = parse_options(argc, argv, live_options,\n\t\t\t\t     live_usage, 0);\n\t\tif (argc)\n\t\t\tusage_with_options(live_usage, live_options);\n\t}\n\n\tkvm->duration *= NSEC_PER_USEC;    \n\n\t \n\terr = target__validate(&kvm->opts.target);\n\tif (err) {\n\t\ttarget__strerror(&kvm->opts.target, err, errbuf, BUFSIZ);\n\t\tui__warning(\"%s\", errbuf);\n\t}\n\n\tif (target__none(&kvm->opts.target))\n\t\tkvm->opts.target.system_wide = true;\n\n\n\t \n\terr = setup_kvm_events_tp(kvm);\n\tif (err < 0) {\n\t\tpr_err(\"Unable to setup the kvm tracepoints\\n\");\n\t\treturn err;\n\t}\n\n\tkvm->evlist = kvm_live_event_list();\n\tif (kvm->evlist == NULL) {\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tif (evlist__create_maps(kvm->evlist, &kvm->opts.target) < 0)\n\t\tusage_with_options(live_usage, live_options);\n\n\t \n\tkvm->session = perf_session__new(&data, &kvm->tool);\n\tif (IS_ERR(kvm->session)) {\n\t\terr = PTR_ERR(kvm->session);\n\t\tgoto out;\n\t}\n\tkvm->session->evlist = kvm->evlist;\n\tperf_session__set_id_hdr_size(kvm->session);\n\tordered_events__set_copy_on_queue(&kvm->session->ordered_events, true);\n\tmachine__synthesize_threads(&kvm->session->machines.host, &kvm->opts.target,\n\t\t\t\t    kvm->evlist->core.threads, true, false, 1);\n\terr = kvm_live_open_events(kvm);\n\tif (err)\n\t\tgoto out;\n\n\terr = kvm_events_live_report(kvm);\n\nout:\n\tperf_session__delete(kvm->session);\n\tkvm->session = NULL;\n\tevlist__delete(kvm->evlist);\n\n\treturn err;\n}\n#endif\n\nstatic void print_kvm_stat_usage(void)\n{\n\tprintf(\"Usage: perf kvm stat <command>\\n\\n\");\n\n\tprintf(\"# Available commands:\\n\");\n\tprintf(\"\\trecord: record kvm events\\n\");\n\tprintf(\"\\treport: report statistical data of kvm events\\n\");\n\tprintf(\"\\tlive:   live reporting of statistical data of kvm events\\n\");\n\n\tprintf(\"\\nOtherwise, it is the alias of 'perf stat':\\n\");\n}\n\nstatic int kvm_cmd_stat(const char *file_name, int argc, const char **argv)\n{\n\tstruct perf_kvm_stat kvm = {\n\t\t.file_name = file_name,\n\n\t\t.trace_vcpu\t= -1,\n\t\t.report_event\t= \"vmexit\",\n\t\t.sort_key\t= \"sample\",\n\n\t};\n\n\tif (argc == 1) {\n\t\tprint_kvm_stat_usage();\n\t\tgoto perf_stat;\n\t}\n\n\tif (strlen(argv[1]) > 2 && strstarts(\"record\", argv[1]))\n\t\treturn kvm_events_record(&kvm, argc - 1, argv + 1);\n\n\tif (strlen(argv[1]) > 2 && strstarts(\"report\", argv[1]))\n\t\treturn kvm_events_report(&kvm, argc - 1 , argv + 1);\n\n#if defined(HAVE_TIMERFD_SUPPORT) && defined(HAVE_LIBTRACEEVENT)\n\tif (!strncmp(argv[1], \"live\", 4))\n\t\treturn kvm_events_live(&kvm, argc - 1 , argv + 1);\n#endif\n\nperf_stat:\n\treturn cmd_stat(argc, argv);\n}\n#endif  \n\nint __weak kvm_add_default_arch_event(int *argc __maybe_unused,\n\t\t\t\t\tconst char **argv __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int __cmd_record(const char *file_name, int argc, const char **argv)\n{\n\tint rec_argc, i = 0, j, ret;\n\tconst char **rec_argv;\n\n\tret = kvm_add_default_arch_event(&argc, argv);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\trec_argc = argc + 2;\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\trec_argv[i++] = strdup(\"record\");\n\trec_argv[i++] = strdup(\"-o\");\n\trec_argv[i++] = strdup(file_name);\n\tfor (j = 1; j < argc; j++, i++)\n\t\trec_argv[i] = argv[j];\n\n\tBUG_ON(i != rec_argc);\n\n\treturn cmd_record(i, rec_argv);\n}\n\nstatic int __cmd_report(const char *file_name, int argc, const char **argv)\n{\n\tint rec_argc, i = 0, j;\n\tconst char **rec_argv;\n\n\trec_argc = argc + 2;\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\trec_argv[i++] = strdup(\"report\");\n\trec_argv[i++] = strdup(\"-i\");\n\trec_argv[i++] = strdup(file_name);\n\tfor (j = 1; j < argc; j++, i++)\n\t\trec_argv[i] = argv[j];\n\n\tBUG_ON(i != rec_argc);\n\n\treturn cmd_report(i, rec_argv);\n}\n\nstatic int\n__cmd_buildid_list(const char *file_name, int argc, const char **argv)\n{\n\tint rec_argc, i = 0, j;\n\tconst char **rec_argv;\n\n\trec_argc = argc + 2;\n\trec_argv = calloc(rec_argc + 1, sizeof(char *));\n\trec_argv[i++] = strdup(\"buildid-list\");\n\trec_argv[i++] = strdup(\"-i\");\n\trec_argv[i++] = strdup(file_name);\n\tfor (j = 1; j < argc; j++, i++)\n\t\trec_argv[i] = argv[j];\n\n\tBUG_ON(i != rec_argc);\n\n\treturn cmd_buildid_list(i, rec_argv);\n}\n\nint cmd_kvm(int argc, const char **argv)\n{\n\tconst char *file_name = NULL;\n\tconst struct option kvm_options[] = {\n\t\tOPT_STRING('i', \"input\", &file_name, \"file\",\n\t\t\t   \"Input file name\"),\n\t\tOPT_STRING('o', \"output\", &file_name, \"file\",\n\t\t\t   \"Output file name\"),\n\t\tOPT_BOOLEAN(0, \"guest\", &perf_guest,\n\t\t\t    \"Collect guest os data\"),\n\t\tOPT_BOOLEAN(0, \"host\", &perf_host,\n\t\t\t    \"Collect host os data\"),\n\t\tOPT_STRING(0, \"guestmount\", &symbol_conf.guestmount, \"directory\",\n\t\t\t   \"guest mount directory under which every guest os\"\n\t\t\t   \" instance has a subdir\"),\n\t\tOPT_STRING(0, \"guestvmlinux\", &symbol_conf.default_guest_vmlinux_name,\n\t\t\t   \"file\", \"file saving guest os vmlinux\"),\n\t\tOPT_STRING(0, \"guestkallsyms\", &symbol_conf.default_guest_kallsyms,\n\t\t\t   \"file\", \"file saving guest os /proc/kallsyms\"),\n\t\tOPT_STRING(0, \"guestmodules\", &symbol_conf.default_guest_modules,\n\t\t\t   \"file\", \"file saving guest os /proc/modules\"),\n\t\tOPT_BOOLEAN(0, \"guest-code\", &symbol_conf.guest_code,\n\t\t\t    \"Guest code can be found in hypervisor process\"),\n\t\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t\t    \"be more verbose (show counter open errors, etc)\"),\n\t\tOPT_END()\n\t};\n\n\tconst char *const kvm_subcommands[] = { \"top\", \"record\", \"report\", \"diff\",\n\t\t\t\t\t\t\"buildid-list\", \"stat\", NULL };\n\tconst char *kvm_usage[] = { NULL, NULL };\n\n\tperf_host  = 0;\n\tperf_guest = 1;\n\n\targc = parse_options_subcommand(argc, argv, kvm_options, kvm_subcommands, kvm_usage,\n\t\t\t\t\tPARSE_OPT_STOP_AT_NON_OPTION);\n\tif (!argc)\n\t\tusage_with_options(kvm_usage, kvm_options);\n\n\tif (!perf_host)\n\t\tperf_guest = 1;\n\n\tif (!file_name) {\n\t\tfile_name = get_filename_for_perf_kvm();\n\n\t\tif (!file_name) {\n\t\t\tpr_err(\"Failed to allocate memory for filename\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (strlen(argv[0]) > 2 && strstarts(\"record\", argv[0]))\n\t\treturn __cmd_record(file_name, argc, argv);\n\telse if (strlen(argv[0]) > 2 && strstarts(\"report\", argv[0]))\n\t\treturn __cmd_report(file_name, argc, argv);\n\telse if (strlen(argv[0]) > 2 && strstarts(\"diff\", argv[0]))\n\t\treturn cmd_diff(argc, argv);\n\telse if (!strcmp(argv[0], \"top\"))\n\t\treturn cmd_top(argc, argv);\n\telse if (strlen(argv[0]) > 2 && strstarts(\"buildid-list\", argv[0]))\n\t\treturn __cmd_buildid_list(file_name, argc, argv);\n#if defined(HAVE_KVM_STAT_SUPPORT) && defined(HAVE_LIBTRACEEVENT)\n\telse if (strlen(argv[0]) > 2 && strstarts(\"stat\", argv[0]))\n\t\treturn kvm_cmd_stat(file_name, argc, argv);\n#endif\n\telse\n\t\tusage_with_options(kvm_usage, kvm_options);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}