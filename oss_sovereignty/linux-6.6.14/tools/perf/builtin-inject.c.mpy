{
  "module_name": "builtin-inject.c",
  "hash_id": "62aa6827c3c9b5e095787e21cb4487ac8b3606537482f3dc999ed459482f49cf",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/builtin-inject.c",
  "human_readable_source": "\n \n#include \"builtin.h\"\n\n#include \"util/color.h\"\n#include \"util/dso.h\"\n#include \"util/vdso.h\"\n#include \"util/evlist.h\"\n#include \"util/evsel.h\"\n#include \"util/map.h\"\n#include \"util/session.h\"\n#include \"util/tool.h\"\n#include \"util/debug.h\"\n#include \"util/build-id.h\"\n#include \"util/data.h\"\n#include \"util/auxtrace.h\"\n#include \"util/jit.h\"\n#include \"util/string2.h\"\n#include \"util/symbol.h\"\n#include \"util/synthetic-events.h\"\n#include \"util/thread.h\"\n#include \"util/namespaces.h\"\n#include \"util/util.h\"\n#include \"util/tsc.h\"\n\n#include <internal/lib.h>\n\n#include <linux/err.h>\n#include <subcmd/parse-options.h>\n#include <uapi/linux/mman.h>  \n\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <linux/hash.h>\n#include <ctype.h>\n#include <errno.h>\n#include <signal.h>\n#include <inttypes.h>\n\nstruct guest_event {\n\tstruct perf_sample\t\tsample;\n\tunion perf_event\t\t*event;\n\tchar\t\t\t\t*event_buf;\n};\n\nstruct guest_id {\n\t \n\tstruct hlist_node\t\tnode;\n\tu64\t\t\t\tid;\n\tu64\t\t\t\thost_id;\n\tu32\t\t\t\tvcpu;\n};\n\nstruct guest_tid {\n\t \n\tstruct hlist_node\t\tnode;\n\t \n\tu32\t\t\t\ttid;\n\tu32\t\t\t\tvcpu;\n};\n\nstruct guest_vcpu {\n\t \n\tu32\t\t\t\tcpu;\n\t \n\tu32\t\t\t\ttid;\n};\n\nstruct guest_session {\n\tchar\t\t\t\t*perf_data_file;\n\tu32\t\t\t\tmachine_pid;\n\tu64\t\t\t\ttime_offset;\n\tdouble\t\t\t\ttime_scale;\n\tstruct perf_tool\t\ttool;\n\tstruct perf_data\t\tdata;\n\tstruct perf_session\t\t*session;\n\tchar\t\t\t\t*tmp_file_name;\n\tint\t\t\t\ttmp_fd;\n\tstruct perf_tsc_conversion\thost_tc;\n\tstruct perf_tsc_conversion\tguest_tc;\n\tbool\t\t\t\tcopy_kcore_dir;\n\tbool\t\t\t\thave_tc;\n\tbool\t\t\t\tfetched;\n\tbool\t\t\t\tready;\n\tu16\t\t\t\tdflt_id_hdr_size;\n\tu64\t\t\t\tdflt_id;\n\tu64\t\t\t\thighest_id;\n\t \n\tstruct guest_vcpu\t\t*vcpu;\n\tsize_t\t\t\t\tvcpu_cnt;\n\t \n\tstruct hlist_head\t\theads[PERF_EVLIST__HLIST_SIZE];\n\t \n\tstruct hlist_head\t\ttids[PERF_EVLIST__HLIST_SIZE];\n\t \n\tstruct guest_event\t\tev;\n};\n\nstruct perf_inject {\n\tstruct perf_tool\ttool;\n\tstruct perf_session\t*session;\n\tbool\t\t\tbuild_ids;\n\tbool\t\t\tbuild_id_all;\n\tbool\t\t\tsched_stat;\n\tbool\t\t\thave_auxtrace;\n\tbool\t\t\tstrip;\n\tbool\t\t\tjit_mode;\n\tbool\t\t\tin_place_update;\n\tbool\t\t\tin_place_update_dry_run;\n\tbool\t\t\tis_pipe;\n\tbool\t\t\tcopy_kcore_dir;\n\tconst char\t\t*input_name;\n\tstruct perf_data\toutput;\n\tu64\t\t\tbytes_written;\n\tu64\t\t\taux_id;\n\tstruct list_head\tsamples;\n\tstruct itrace_synth_opts itrace_synth_opts;\n\tchar\t\t\t*event_copy;\n\tstruct perf_file_section secs[HEADER_FEAT_BITS];\n\tstruct guest_session\tguest_session;\n\tstruct strlist\t\t*known_build_ids;\n};\n\nstruct event_entry {\n\tstruct list_head node;\n\tu32\t\t tid;\n\tunion perf_event event[];\n};\n\nstatic int dso__inject_build_id(struct dso *dso, struct perf_tool *tool,\n\t\t\t\tstruct machine *machine, u8 cpumode, u32 flags);\n\nstatic int output_bytes(struct perf_inject *inject, void *buf, size_t sz)\n{\n\tssize_t size;\n\n\tsize = perf_data__write(&inject->output, buf, sz);\n\tif (size < 0)\n\t\treturn -errno;\n\n\tinject->bytes_written += size;\n\treturn 0;\n}\n\nstatic int perf_event__repipe_synth(struct perf_tool *tool,\n\t\t\t\t    union perf_event *event)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject,\n\t\t\t\t\t\t  tool);\n\n\treturn output_bytes(inject, event, event->header.size);\n}\n\nstatic int perf_event__repipe_oe_synth(struct perf_tool *tool,\n\t\t\t\t       union perf_event *event,\n\t\t\t\t       struct ordered_events *oe __maybe_unused)\n{\n\treturn perf_event__repipe_synth(tool, event);\n}\n\n#ifdef HAVE_JITDUMP\nstatic int perf_event__drop_oe(struct perf_tool *tool __maybe_unused,\n\t\t\t       union perf_event *event __maybe_unused,\n\t\t\t       struct ordered_events *oe __maybe_unused)\n{\n\treturn 0;\n}\n#endif\n\nstatic int perf_event__repipe_op2_synth(struct perf_session *session,\n\t\t\t\t\tunion perf_event *event)\n{\n\treturn perf_event__repipe_synth(session->tool, event);\n}\n\nstatic int perf_event__repipe_op4_synth(struct perf_session *session,\n\t\t\t\t\tunion perf_event *event,\n\t\t\t\t\tu64 data __maybe_unused,\n\t\t\t\t\tconst char *str __maybe_unused)\n{\n\treturn perf_event__repipe_synth(session->tool, event);\n}\n\nstatic int perf_event__repipe_attr(struct perf_tool *tool,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct evlist **pevlist)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject,\n\t\t\t\t\t\t  tool);\n\tint ret;\n\n\tret = perf_event__process_attr(tool, event, pevlist);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!inject->is_pipe)\n\t\treturn 0;\n\n\treturn perf_event__repipe_synth(tool, event);\n}\n\nstatic int perf_event__repipe_event_update(struct perf_tool *tool,\n\t\t\t\t\t   union perf_event *event,\n\t\t\t\t\t   struct evlist **pevlist __maybe_unused)\n{\n\treturn perf_event__repipe_synth(tool, event);\n}\n\n#ifdef HAVE_AUXTRACE_SUPPORT\n\nstatic int copy_bytes(struct perf_inject *inject, struct perf_data *data, off_t size)\n{\n\tchar buf[4096];\n\tssize_t ssz;\n\tint ret;\n\n\twhile (size > 0) {\n\t\tssz = perf_data__read(data, buf, min(size, (off_t)sizeof(buf)));\n\t\tif (ssz < 0)\n\t\t\treturn -errno;\n\t\tret = output_bytes(inject, buf, ssz);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsize -= ssz;\n\t}\n\n\treturn 0;\n}\n\nstatic s64 perf_event__repipe_auxtrace(struct perf_session *session,\n\t\t\t\t       union perf_event *event)\n{\n\tstruct perf_tool *tool = session->tool;\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject,\n\t\t\t\t\t\t  tool);\n\tint ret;\n\n\tinject->have_auxtrace = true;\n\n\tif (!inject->output.is_pipe) {\n\t\toff_t offset;\n\n\t\toffset = lseek(inject->output.file.fd, 0, SEEK_CUR);\n\t\tif (offset == -1)\n\t\t\treturn -errno;\n\t\tret = auxtrace_index__auxtrace_event(&session->auxtrace_index,\n\t\t\t\t\t\t     event, offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (perf_data__is_pipe(session->data) || !session->one_mmap) {\n\t\tret = output_bytes(inject, event, event->header.size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = copy_bytes(inject, session->data,\n\t\t\t\t event->auxtrace.size);\n\t} else {\n\t\tret = output_bytes(inject, event,\n\t\t\t\t   event->header.size + event->auxtrace.size);\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn event->auxtrace.size;\n}\n\n#else\n\nstatic s64\nperf_event__repipe_auxtrace(struct perf_session *session __maybe_unused,\n\t\t\t    union perf_event *event __maybe_unused)\n{\n\tpr_err(\"AUX area tracing not supported\\n\");\n\treturn -EINVAL;\n}\n\n#endif\n\nstatic int perf_event__repipe(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample __maybe_unused,\n\t\t\t      struct machine *machine __maybe_unused)\n{\n\treturn perf_event__repipe_synth(tool, event);\n}\n\nstatic int perf_event__drop(struct perf_tool *tool __maybe_unused,\n\t\t\t    union perf_event *event __maybe_unused,\n\t\t\t    struct perf_sample *sample __maybe_unused,\n\t\t\t    struct machine *machine __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int perf_event__drop_aux(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event __maybe_unused,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct machine *machine __maybe_unused)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\n\tif (!inject->aux_id)\n\t\tinject->aux_id = sample->id;\n\n\treturn 0;\n}\n\nstatic union perf_event *\nperf_inject__cut_auxtrace_sample(struct perf_inject *inject,\n\t\t\t\t union perf_event *event,\n\t\t\t\t struct perf_sample *sample)\n{\n\tsize_t sz1 = sample->aux_sample.data - (void *)event;\n\tsize_t sz2 = event->header.size - sample->aux_sample.size - sz1;\n\tunion perf_event *ev;\n\n\tif (inject->event_copy == NULL) {\n\t\tinject->event_copy = malloc(PERF_SAMPLE_MAX_SIZE);\n\t\tif (!inject->event_copy)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tev = (union perf_event *)inject->event_copy;\n\tif (sz1 > event->header.size || sz2 > event->header.size ||\n\t    sz1 + sz2 > event->header.size ||\n\t    sz1 < sizeof(struct perf_event_header) + sizeof(u64))\n\t\treturn event;\n\n\tmemcpy(ev, event, sz1);\n\tmemcpy((void *)ev + sz1, (void *)event + event->header.size - sz2, sz2);\n\tev->header.size = sz1 + sz2;\n\t((u64 *)((void *)ev + sz1))[-1] = 0;\n\n\treturn ev;\n}\n\ntypedef int (*inject_handler)(struct perf_tool *tool,\n\t\t\t      union perf_event *event,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct evsel *evsel,\n\t\t\t      struct machine *machine);\n\nstatic int perf_event__repipe_sample(struct perf_tool *tool,\n\t\t\t\t     union perf_event *event,\n\t\t\t\t     struct perf_sample *sample,\n\t\t\t\t     struct evsel *evsel,\n\t\t\t\t     struct machine *machine)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject,\n\t\t\t\t\t\t  tool);\n\n\tif (evsel && evsel->handler) {\n\t\tinject_handler f = evsel->handler;\n\t\treturn f(tool, event, sample, evsel, machine);\n\t}\n\n\tbuild_id__mark_dso_hit(tool, event, sample, evsel, machine);\n\n\tif (inject->itrace_synth_opts.set && sample->aux_sample.size) {\n\t\tevent = perf_inject__cut_auxtrace_sample(inject, event, sample);\n\t\tif (IS_ERR(event))\n\t\t\treturn PTR_ERR(event);\n\t}\n\n\treturn perf_event__repipe_synth(tool, event);\n}\n\nstatic int perf_event__repipe_mmap(struct perf_tool *tool,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t   struct machine *machine)\n{\n\tint err;\n\n\terr = perf_event__process_mmap(tool, event, sample, machine);\n\tperf_event__repipe(tool, event, sample, machine);\n\n\treturn err;\n}\n\n#ifdef HAVE_JITDUMP\nstatic int perf_event__jit_repipe_mmap(struct perf_tool *tool,\n\t\t\t\t       union perf_event *event,\n\t\t\t\t       struct perf_sample *sample,\n\t\t\t\t       struct machine *machine)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\tu64 n = 0;\n\tint ret;\n\n\t \n\tret = jit_process(inject->session, &inject->output, machine,\n\t\t\t  event->mmap.filename, event->mmap.pid, event->mmap.tid, &n);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret) {\n\t\tinject->bytes_written += n;\n\t\treturn 0;\n\t}\n\treturn perf_event__repipe_mmap(tool, event, sample, machine);\n}\n#endif\n\nstatic struct dso *findnew_dso(int pid, int tid, const char *filename,\n\t\t\t       struct dso_id *id, struct machine *machine)\n{\n\tstruct thread *thread;\n\tstruct nsinfo *nsi = NULL;\n\tstruct nsinfo *nnsi;\n\tstruct dso *dso;\n\tbool vdso;\n\n\tthread = machine__findnew_thread(machine, pid, tid);\n\tif (thread == NULL) {\n\t\tpr_err(\"cannot find or create a task %d/%d.\\n\", tid, pid);\n\t\treturn NULL;\n\t}\n\n\tvdso = is_vdso_map(filename);\n\tnsi = nsinfo__get(thread__nsinfo(thread));\n\n\tif (vdso) {\n\t\t \n\t\tnnsi = nsinfo__copy(nsi);\n\t\tif (nnsi) {\n\t\t\tnsinfo__put(nsi);\n\t\t\tnsinfo__clear_need_setns(nnsi);\n\t\t\tnsi = nnsi;\n\t\t}\n\t\tdso = machine__findnew_vdso(machine, thread);\n\t} else {\n\t\tdso = machine__findnew_dso_id(machine, filename, id);\n\t}\n\n\tif (dso) {\n\t\tmutex_lock(&dso->lock);\n\t\tnsinfo__put(dso->nsinfo);\n\t\tdso->nsinfo = nsi;\n\t\tmutex_unlock(&dso->lock);\n\t} else\n\t\tnsinfo__put(nsi);\n\n\tthread__put(thread);\n\treturn dso;\n}\n\nstatic int perf_event__repipe_buildid_mmap(struct perf_tool *tool,\n\t\t\t\t\t   union perf_event *event,\n\t\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t\t   struct machine *machine)\n{\n\tstruct dso *dso;\n\n\tdso = findnew_dso(event->mmap.pid, event->mmap.tid,\n\t\t\t  event->mmap.filename, NULL, machine);\n\n\tif (dso && !dso->hit) {\n\t\tdso->hit = 1;\n\t\tdso__inject_build_id(dso, tool, machine, sample->cpumode, 0);\n\t}\n\tdso__put(dso);\n\n\treturn perf_event__repipe(tool, event, sample, machine);\n}\n\nstatic int perf_event__repipe_mmap2(struct perf_tool *tool,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t   struct machine *machine)\n{\n\tint err;\n\n\terr = perf_event__process_mmap2(tool, event, sample, machine);\n\tperf_event__repipe(tool, event, sample, machine);\n\n\tif (event->header.misc & PERF_RECORD_MISC_MMAP_BUILD_ID) {\n\t\tstruct dso *dso;\n\n\t\tdso = findnew_dso(event->mmap2.pid, event->mmap2.tid,\n\t\t\t\t  event->mmap2.filename, NULL, machine);\n\t\tif (dso) {\n\t\t\t \n\t\t\tdso->hit = 1;\n\t\t}\n\t\tdso__put(dso);\n\t}\n\n\treturn err;\n}\n\n#ifdef HAVE_JITDUMP\nstatic int perf_event__jit_repipe_mmap2(struct perf_tool *tool,\n\t\t\t\t\tunion perf_event *event,\n\t\t\t\t\tstruct perf_sample *sample,\n\t\t\t\t\tstruct machine *machine)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\tu64 n = 0;\n\tint ret;\n\n\t \n\tret = jit_process(inject->session, &inject->output, machine,\n\t\t\t  event->mmap2.filename, event->mmap2.pid, event->mmap2.tid, &n);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret) {\n\t\tinject->bytes_written += n;\n\t\treturn 0;\n\t}\n\treturn perf_event__repipe_mmap2(tool, event, sample, machine);\n}\n#endif\n\nstatic int perf_event__repipe_buildid_mmap2(struct perf_tool *tool,\n\t\t\t\t\t    union perf_event *event,\n\t\t\t\t\t    struct perf_sample *sample,\n\t\t\t\t\t    struct machine *machine)\n{\n\tstruct dso_id dso_id = {\n\t\t.maj = event->mmap2.maj,\n\t\t.min = event->mmap2.min,\n\t\t.ino = event->mmap2.ino,\n\t\t.ino_generation = event->mmap2.ino_generation,\n\t};\n\tstruct dso *dso;\n\n\tif (event->header.misc & PERF_RECORD_MISC_MMAP_BUILD_ID) {\n\t\t \n\t\tdso = findnew_dso(event->mmap2.pid, event->mmap2.tid,\n\t\t\t\t  event->mmap2.filename, NULL, machine);\n\t\tif (dso) {\n\t\t\t \n\t\t\tdso->hit = 1;\n\t\t}\n\t\tdso__put(dso);\n\t\tperf_event__repipe(tool, event, sample, machine);\n\t\treturn 0;\n\t}\n\n\tdso = findnew_dso(event->mmap2.pid, event->mmap2.tid,\n\t\t\t  event->mmap2.filename, &dso_id, machine);\n\n\tif (dso && !dso->hit) {\n\t\tdso->hit = 1;\n\t\tdso__inject_build_id(dso, tool, machine, sample->cpumode,\n\t\t\t\t     event->mmap2.flags);\n\t}\n\tdso__put(dso);\n\n\tperf_event__repipe(tool, event, sample, machine);\n\n\treturn 0;\n}\n\nstatic int perf_event__repipe_fork(struct perf_tool *tool,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t   struct machine *machine)\n{\n\tint err;\n\n\terr = perf_event__process_fork(tool, event, sample, machine);\n\tperf_event__repipe(tool, event, sample, machine);\n\n\treturn err;\n}\n\nstatic int perf_event__repipe_comm(struct perf_tool *tool,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t   struct machine *machine)\n{\n\tint err;\n\n\terr = perf_event__process_comm(tool, event, sample, machine);\n\tperf_event__repipe(tool, event, sample, machine);\n\n\treturn err;\n}\n\nstatic int perf_event__repipe_namespaces(struct perf_tool *tool,\n\t\t\t\t\t union perf_event *event,\n\t\t\t\t\t struct perf_sample *sample,\n\t\t\t\t\t struct machine *machine)\n{\n\tint err = perf_event__process_namespaces(tool, event, sample, machine);\n\n\tperf_event__repipe(tool, event, sample, machine);\n\n\treturn err;\n}\n\nstatic int perf_event__repipe_exit(struct perf_tool *tool,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t   struct machine *machine)\n{\n\tint err;\n\n\terr = perf_event__process_exit(tool, event, sample, machine);\n\tperf_event__repipe(tool, event, sample, machine);\n\n\treturn err;\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic int perf_event__repipe_tracing_data(struct perf_session *session,\n\t\t\t\t\t   union perf_event *event)\n{\n\tperf_event__repipe_synth(session->tool, event);\n\n\treturn perf_event__process_tracing_data(session, event);\n}\n#endif\n\nstatic int dso__read_build_id(struct dso *dso)\n{\n\tstruct nscookie nsc;\n\n\tif (dso->has_build_id)\n\t\treturn 0;\n\n\tmutex_lock(&dso->lock);\n\tnsinfo__mountns_enter(dso->nsinfo, &nsc);\n\tif (filename__read_build_id(dso->long_name, &dso->bid) > 0)\n\t\tdso->has_build_id = true;\n\telse if (dso->nsinfo) {\n\t\tchar *new_name = dso__filename_with_chroot(dso, dso->long_name);\n\n\t\tif (new_name && filename__read_build_id(new_name, &dso->bid) > 0)\n\t\t\tdso->has_build_id = true;\n\t\tfree(new_name);\n\t}\n\tnsinfo__mountns_exit(&nsc);\n\tmutex_unlock(&dso->lock);\n\n\treturn dso->has_build_id ? 0 : -1;\n}\n\nstatic struct strlist *perf_inject__parse_known_build_ids(\n\tconst char *known_build_ids_string)\n{\n\tstruct str_node *pos, *tmp;\n\tstruct strlist *known_build_ids;\n\tint bid_len;\n\n\tknown_build_ids = strlist__new(known_build_ids_string, NULL);\n\tif (known_build_ids == NULL)\n\t\treturn NULL;\n\tstrlist__for_each_entry_safe(pos, tmp, known_build_ids) {\n\t\tconst char *build_id, *dso_name;\n\n\t\tbuild_id = skip_spaces(pos->s);\n\t\tdso_name = strchr(build_id, ' ');\n\t\tif (dso_name == NULL) {\n\t\t\tstrlist__remove(known_build_ids, pos);\n\t\t\tcontinue;\n\t\t}\n\t\tbid_len = dso_name - pos->s;\n\t\tdso_name = skip_spaces(dso_name);\n\t\tif (bid_len % 2 != 0 || bid_len >= SBUILD_ID_SIZE) {\n\t\t\tstrlist__remove(known_build_ids, pos);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int ix = 0; 2 * ix + 1 < bid_len; ++ix) {\n\t\t\tif (!isxdigit(build_id[2 * ix]) ||\n\t\t\t    !isxdigit(build_id[2 * ix + 1])) {\n\t\t\t\tstrlist__remove(known_build_ids, pos);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn known_build_ids;\n}\n\nstatic bool perf_inject__lookup_known_build_id(struct perf_inject *inject,\n\t\t\t\t\t       struct dso *dso)\n{\n\tstruct str_node *pos;\n\tint bid_len;\n\n\tstrlist__for_each_entry(pos, inject->known_build_ids) {\n\t\tconst char *build_id, *dso_name;\n\n\t\tbuild_id = skip_spaces(pos->s);\n\t\tdso_name = strchr(build_id, ' ');\n\t\tbid_len = dso_name - pos->s;\n\t\tdso_name = skip_spaces(dso_name);\n\t\tif (strcmp(dso->long_name, dso_name))\n\t\t\tcontinue;\n\t\tfor (int ix = 0; 2 * ix + 1 < bid_len; ++ix) {\n\t\t\tdso->bid.data[ix] = (hex(build_id[2 * ix]) << 4 |\n\t\t\t\t\t     hex(build_id[2 * ix + 1]));\n\t\t}\n\t\tdso->bid.size = bid_len / 2;\n\t\tdso->has_build_id = 1;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int dso__inject_build_id(struct dso *dso, struct perf_tool *tool,\n\t\t\t\tstruct machine *machine, u8 cpumode, u32 flags)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject,\n\t\t\t\t\t\t  tool);\n\tint err;\n\n\tif (is_anon_memory(dso->long_name) || flags & MAP_HUGETLB)\n\t\treturn 0;\n\tif (is_no_dso_memory(dso->long_name))\n\t\treturn 0;\n\n\tif (inject->known_build_ids != NULL &&\n\t    perf_inject__lookup_known_build_id(inject, dso))\n\t\treturn 1;\n\n\tif (dso__read_build_id(dso) < 0) {\n\t\tpr_debug(\"no build_id found for %s\\n\", dso->long_name);\n\t\treturn -1;\n\t}\n\n\terr = perf_event__synthesize_build_id(tool, dso, cpumode,\n\t\t\t\t\t      perf_event__repipe, machine);\n\tif (err) {\n\t\tpr_err(\"Can't synthesize build_id event for %s\\n\", dso->long_name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint perf_event__inject_buildid(struct perf_tool *tool, union perf_event *event,\n\t\t\t       struct perf_sample *sample,\n\t\t\t       struct evsel *evsel __maybe_unused,\n\t\t\t       struct machine *machine)\n{\n\tstruct addr_location al;\n\tstruct thread *thread;\n\n\taddr_location__init(&al);\n\tthread = machine__findnew_thread(machine, sample->pid, sample->tid);\n\tif (thread == NULL) {\n\t\tpr_err(\"problem processing %d event, skipping it.\\n\",\n\t\t       event->header.type);\n\t\tgoto repipe;\n\t}\n\n\tif (thread__find_map(thread, sample->cpumode, sample->ip, &al)) {\n\t\tstruct dso *dso = map__dso(al.map);\n\n\t\tif (!dso->hit) {\n\t\t\tdso->hit = 1;\n\t\t\tdso__inject_build_id(dso, tool, machine,\n\t\t\t\t\t     sample->cpumode, map__flags(al.map));\n\t\t}\n\t}\n\n\tthread__put(thread);\nrepipe:\n\tperf_event__repipe(tool, event, sample, machine);\n\taddr_location__exit(&al);\n\treturn 0;\n}\n\nstatic int perf_inject__sched_process_exit(struct perf_tool *tool,\n\t\t\t\t\t   union perf_event *event __maybe_unused,\n\t\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t\t   struct evsel *evsel __maybe_unused,\n\t\t\t\t\t   struct machine *machine __maybe_unused)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\tstruct event_entry *ent;\n\n\tlist_for_each_entry(ent, &inject->samples, node) {\n\t\tif (sample->tid == ent->tid) {\n\t\t\tlist_del_init(&ent->node);\n\t\t\tfree(ent);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_inject__sched_switch(struct perf_tool *tool,\n\t\t\t\t     union perf_event *event,\n\t\t\t\t     struct perf_sample *sample,\n\t\t\t\t     struct evsel *evsel,\n\t\t\t\t     struct machine *machine)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\tstruct event_entry *ent;\n\n\tperf_inject__sched_process_exit(tool, event, sample, evsel, machine);\n\n\tent = malloc(event->header.size + sizeof(struct event_entry));\n\tif (ent == NULL) {\n\t\tcolor_fprintf(stderr, PERF_COLOR_RED,\n\t\t\t     \"Not enough memory to process sched switch event!\");\n\t\treturn -1;\n\t}\n\n\tent->tid = sample->tid;\n\tmemcpy(&ent->event, event, event->header.size);\n\tlist_add(&ent->node, &inject->samples);\n\treturn 0;\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic int perf_inject__sched_stat(struct perf_tool *tool,\n\t\t\t\t   union perf_event *event __maybe_unused,\n\t\t\t\t   struct perf_sample *sample,\n\t\t\t\t   struct evsel *evsel,\n\t\t\t\t   struct machine *machine)\n{\n\tstruct event_entry *ent;\n\tunion perf_event *event_sw;\n\tstruct perf_sample sample_sw;\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\tu32 pid = evsel__intval(evsel, sample, \"pid\");\n\n\tlist_for_each_entry(ent, &inject->samples, node) {\n\t\tif (pid == ent->tid)\n\t\t\tgoto found;\n\t}\n\n\treturn 0;\nfound:\n\tevent_sw = &ent->event[0];\n\tevsel__parse_sample(evsel, event_sw, &sample_sw);\n\n\tsample_sw.period = sample->period;\n\tsample_sw.time\t = sample->time;\n\tperf_event__synthesize_sample(event_sw, evsel->core.attr.sample_type,\n\t\t\t\t      evsel->core.attr.read_format, &sample_sw);\n\tbuild_id__mark_dso_hit(tool, event_sw, &sample_sw, evsel, machine);\n\treturn perf_event__repipe(tool, event_sw, &sample_sw, machine);\n}\n#endif\n\nstatic struct guest_vcpu *guest_session__vcpu(struct guest_session *gs, u32 vcpu)\n{\n\tif (realloc_array_as_needed(gs->vcpu, gs->vcpu_cnt, vcpu, NULL))\n\t\treturn NULL;\n\treturn &gs->vcpu[vcpu];\n}\n\nstatic int guest_session__output_bytes(struct guest_session *gs, void *buf, size_t sz)\n{\n\tssize_t ret = writen(gs->tmp_fd, buf, sz);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int guest_session__repipe(struct perf_tool *tool,\n\t\t\t\t union perf_event *event,\n\t\t\t\t struct perf_sample *sample __maybe_unused,\n\t\t\t\t struct machine *machine __maybe_unused)\n{\n\tstruct guest_session *gs = container_of(tool, struct guest_session, tool);\n\n\treturn guest_session__output_bytes(gs, event, event->header.size);\n}\n\nstatic int guest_session__map_tid(struct guest_session *gs, u32 tid, u32 vcpu)\n{\n\tstruct guest_tid *guest_tid = zalloc(sizeof(*guest_tid));\n\tint hash;\n\n\tif (!guest_tid)\n\t\treturn -ENOMEM;\n\n\tguest_tid->tid = tid;\n\tguest_tid->vcpu = vcpu;\n\thash = hash_32(guest_tid->tid, PERF_EVLIST__HLIST_BITS);\n\thlist_add_head(&guest_tid->node, &gs->tids[hash]);\n\n\treturn 0;\n}\n\nstatic int host_peek_vm_comms_cb(struct perf_session *session __maybe_unused,\n\t\t\t\t union perf_event *event,\n\t\t\t\t u64 offset __maybe_unused, void *data)\n{\n\tstruct guest_session *gs = data;\n\tunsigned int vcpu;\n\tstruct guest_vcpu *guest_vcpu;\n\tint ret;\n\n\tif (event->header.type != PERF_RECORD_COMM ||\n\t    event->comm.pid != gs->machine_pid)\n\t\treturn 0;\n\n\t \n\tret = sscanf(event->comm.comm, \"CPU %u/KVM\", &vcpu);\n\tif (ret <= 0)\n\t\treturn ret;\n\tpr_debug(\"Found VCPU: tid %u comm %s vcpu %u\\n\",\n\t\t event->comm.tid, event->comm.comm, vcpu);\n\tif (vcpu > INT_MAX) {\n\t\tpr_err(\"Invalid VCPU %u\\n\", vcpu);\n\t\treturn -EINVAL;\n\t}\n\tguest_vcpu = guest_session__vcpu(gs, vcpu);\n\tif (!guest_vcpu)\n\t\treturn -ENOMEM;\n\tif (guest_vcpu->tid && guest_vcpu->tid != event->comm.tid) {\n\t\tpr_err(\"Fatal error: Two threads found with the same VCPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\tguest_vcpu->tid = event->comm.tid;\n\n\treturn guest_session__map_tid(gs, event->comm.tid, vcpu);\n}\n\nstatic int host_peek_vm_comms(struct perf_session *session, struct guest_session *gs)\n{\n\treturn perf_session__peek_events(session, session->header.data_offset,\n\t\t\t\t\t session->header.data_size,\n\t\t\t\t\t host_peek_vm_comms_cb, gs);\n}\n\nstatic bool evlist__is_id_used(struct evlist *evlist, u64 id)\n{\n\treturn evlist__id2sid(evlist, id);\n}\n\nstatic u64 guest_session__allocate_new_id(struct guest_session *gs, struct evlist *host_evlist)\n{\n\tdo {\n\t\tgs->highest_id += 1;\n\t} while (!gs->highest_id || evlist__is_id_used(host_evlist, gs->highest_id));\n\n\treturn gs->highest_id;\n}\n\nstatic int guest_session__map_id(struct guest_session *gs, u64 id, u64 host_id, u32 vcpu)\n{\n\tstruct guest_id *guest_id = zalloc(sizeof(*guest_id));\n\tint hash;\n\n\tif (!guest_id)\n\t\treturn -ENOMEM;\n\n\tguest_id->id = id;\n\tguest_id->host_id = host_id;\n\tguest_id->vcpu = vcpu;\n\thash = hash_64(guest_id->id, PERF_EVLIST__HLIST_BITS);\n\thlist_add_head(&guest_id->node, &gs->heads[hash]);\n\n\treturn 0;\n}\n\nstatic u64 evlist__find_highest_id(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\tu64 highest_id = 1;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tu32 j;\n\n\t\tfor (j = 0; j < evsel->core.ids; j++) {\n\t\t\tu64 id = evsel->core.id[j];\n\n\t\t\tif (id > highest_id)\n\t\t\t\thighest_id = id;\n\t\t}\n\t}\n\n\treturn highest_id;\n}\n\nstatic int guest_session__map_ids(struct guest_session *gs, struct evlist *host_evlist)\n{\n\tstruct evlist *evlist = gs->session->evlist;\n\tstruct evsel *evsel;\n\tint ret;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tu32 j;\n\n\t\tfor (j = 0; j < evsel->core.ids; j++) {\n\t\t\tstruct perf_sample_id *sid;\n\t\t\tu64 host_id;\n\t\t\tu64 id;\n\n\t\t\tid = evsel->core.id[j];\n\t\t\tsid = evlist__id2sid(evlist, id);\n\t\t\tif (!sid || sid->cpu.cpu == -1)\n\t\t\t\tcontinue;\n\t\t\thost_id = guest_session__allocate_new_id(gs, host_evlist);\n\t\t\tret = guest_session__map_id(gs, id, host_id, sid->cpu.cpu);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct guest_id *guest_session__lookup_id(struct guest_session *gs, u64 id)\n{\n\tstruct hlist_head *head;\n\tstruct guest_id *guest_id;\n\tint hash;\n\n\thash = hash_64(id, PERF_EVLIST__HLIST_BITS);\n\thead = &gs->heads[hash];\n\n\thlist_for_each_entry(guest_id, head, node)\n\t\tif (guest_id->id == id)\n\t\t\treturn guest_id;\n\n\treturn NULL;\n}\n\nstatic int process_attr(struct perf_tool *tool, union perf_event *event,\n\t\t\tstruct perf_sample *sample __maybe_unused,\n\t\t\tstruct machine *machine __maybe_unused)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\n\treturn perf_event__process_attr(tool, event, &inject->session->evlist);\n}\n\nstatic int guest_session__add_attr(struct guest_session *gs, struct evsel *evsel)\n{\n\tstruct perf_inject *inject = container_of(gs, struct perf_inject, guest_session);\n\tstruct perf_event_attr attr = evsel->core.attr;\n\tu64 *id_array;\n\tu32 *vcpu_array;\n\tint ret = -ENOMEM;\n\tu32 i;\n\n\tid_array = calloc(evsel->core.ids, sizeof(*id_array));\n\tif (!id_array)\n\t\treturn -ENOMEM;\n\n\tvcpu_array = calloc(evsel->core.ids, sizeof(*vcpu_array));\n\tif (!vcpu_array)\n\t\tgoto out;\n\n\tfor (i = 0; i < evsel->core.ids; i++) {\n\t\tu64 id = evsel->core.id[i];\n\t\tstruct guest_id *guest_id = guest_session__lookup_id(gs, id);\n\n\t\tif (!guest_id) {\n\t\t\tpr_err(\"Failed to find guest id %\"PRIu64\"\\n\", id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tid_array[i] = guest_id->host_id;\n\t\tvcpu_array[i] = guest_id->vcpu;\n\t}\n\n\tattr.sample_type |= PERF_SAMPLE_IDENTIFIER;\n\tattr.exclude_host = 1;\n\tattr.exclude_guest = 0;\n\n\tret = perf_event__synthesize_attr(&inject->tool, &attr, evsel->core.ids,\n\t\t\t\t\t  id_array, process_attr);\n\tif (ret)\n\t\tpr_err(\"Failed to add guest attr.\\n\");\n\n\tfor (i = 0; i < evsel->core.ids; i++) {\n\t\tstruct perf_sample_id *sid;\n\t\tu32 vcpu = vcpu_array[i];\n\n\t\tsid = evlist__id2sid(inject->session->evlist, id_array[i]);\n\t\t \n\t\tsid->cpu.cpu = -1;\n\t\tsid->tid = gs->vcpu[vcpu].tid;\n\t\tsid->machine_pid = gs->machine_pid;\n\t\tsid->vcpu.cpu = vcpu;\n\t}\nout:\n\tfree(vcpu_array);\n\tfree(id_array);\n\treturn ret;\n}\n\nstatic int guest_session__add_attrs(struct guest_session *gs)\n{\n\tstruct evlist *evlist = gs->session->evlist;\n\tstruct evsel *evsel;\n\tint ret;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tret = guest_session__add_attr(gs, evsel);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int synthesize_id_index(struct perf_inject *inject, size_t new_cnt)\n{\n\tstruct perf_session *session = inject->session;\n\tstruct evlist *evlist = session->evlist;\n\tstruct machine *machine = &session->machines.host;\n\tsize_t from = evlist->core.nr_entries - new_cnt;\n\n\treturn __perf_event__synthesize_id_index(&inject->tool, perf_event__repipe,\n\t\t\t\t\t\t evlist, machine, from);\n}\n\nstatic struct guest_tid *guest_session__lookup_tid(struct guest_session *gs, u32 tid)\n{\n\tstruct hlist_head *head;\n\tstruct guest_tid *guest_tid;\n\tint hash;\n\n\thash = hash_32(tid, PERF_EVLIST__HLIST_BITS);\n\thead = &gs->tids[hash];\n\n\thlist_for_each_entry(guest_tid, head, node)\n\t\tif (guest_tid->tid == tid)\n\t\t\treturn guest_tid;\n\n\treturn NULL;\n}\n\nstatic bool dso__is_in_kernel_space(struct dso *dso)\n{\n\tif (dso__is_vdso(dso))\n\t\treturn false;\n\n\treturn dso__is_kcore(dso) ||\n\t       dso->kernel ||\n\t       is_kernel_module(dso->long_name, PERF_RECORD_MISC_CPUMODE_UNKNOWN);\n}\n\nstatic u64 evlist__first_id(struct evlist *evlist)\n{\n\tstruct evsel *evsel;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (evsel->core.ids)\n\t\t\treturn evsel->core.id[0];\n\t}\n\treturn 0;\n}\n\nstatic int process_build_id(struct perf_tool *tool,\n\t\t\t    union perf_event *event,\n\t\t\t    struct perf_sample *sample __maybe_unused,\n\t\t\t    struct machine *machine __maybe_unused)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\n\treturn perf_event__process_build_id(inject->session, event);\n}\n\nstatic int synthesize_build_id(struct perf_inject *inject, struct dso *dso, pid_t machine_pid)\n{\n\tstruct machine *machine = perf_session__findnew_machine(inject->session, machine_pid);\n\tu8 cpumode = dso__is_in_kernel_space(dso) ?\n\t\t\tPERF_RECORD_MISC_GUEST_KERNEL :\n\t\t\tPERF_RECORD_MISC_GUEST_USER;\n\n\tif (!machine)\n\t\treturn -ENOMEM;\n\n\tdso->hit = 1;\n\n\treturn perf_event__synthesize_build_id(&inject->tool, dso, cpumode,\n\t\t\t\t\t       process_build_id, machine);\n}\n\nstatic int guest_session__add_build_ids(struct guest_session *gs)\n{\n\tstruct perf_inject *inject = container_of(gs, struct perf_inject, guest_session);\n\tstruct machine *machine = &gs->session->machines.host;\n\tstruct dso *dso;\n\tint ret;\n\n\t \n\tperf_header__set_feat(&inject->session->header, HEADER_BUILD_ID);\n\n\tdsos__for_each_with_build_id(dso, &machine->dsos.head) {\n\t\tret = synthesize_build_id(inject, dso, gs->machine_pid);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int guest_session__ksymbol_event(struct perf_tool *tool,\n\t\t\t\t\tunion perf_event *event,\n\t\t\t\t\tstruct perf_sample *sample __maybe_unused,\n\t\t\t\t\tstruct machine *machine __maybe_unused)\n{\n\tstruct guest_session *gs = container_of(tool, struct guest_session, tool);\n\n\t \n\tif (event->ksymbol.ksym_type != PERF_RECORD_KSYMBOL_TYPE_OOL)\n\t\treturn 0;\n\n\treturn guest_session__output_bytes(gs, event, event->header.size);\n}\n\nstatic int guest_session__start(struct guest_session *gs, const char *name, bool force)\n{\n\tchar tmp_file_name[] = \"/tmp/perf-inject-guest_session-XXXXXX\";\n\tstruct perf_session *session;\n\tint ret;\n\n\t \n\tgs->tool.mmap\t\t= guest_session__repipe;\n\tgs->tool.mmap2\t\t= guest_session__repipe;\n\tgs->tool.comm\t\t= guest_session__repipe;\n\tgs->tool.fork\t\t= guest_session__repipe;\n\tgs->tool.exit\t\t= guest_session__repipe;\n\tgs->tool.lost\t\t= guest_session__repipe;\n\tgs->tool.context_switch\t= guest_session__repipe;\n\tgs->tool.ksymbol\t= guest_session__ksymbol_event;\n\tgs->tool.text_poke\t= guest_session__repipe;\n\t \n\tgs->tool.build_id\t= perf_event__process_build_id;\n\t \n\tgs->tool.id_index\t= perf_event__process_id_index;\n\n\tgs->tool.ordered_events\t= true;\n\tgs->tool.ordering_requires_timestamps = true;\n\n\tgs->data.path\t= name;\n\tgs->data.force\t= force;\n\tgs->data.mode\t= PERF_DATA_MODE_READ;\n\n\tsession = perf_session__new(&gs->data, &gs->tool);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\tgs->session = session;\n\n\t \n\tgs->dflt_id_hdr_size = session->machines.host.id_hdr_size;\n\t \n\tgs->dflt_id = evlist__first_id(session->evlist);\n\tif (!gs->dflt_id) {\n\t\tpr_err(\"Guest data has no sample IDs\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tgs->tmp_file_name = strdup(tmp_file_name);\n\tif (!gs->tmp_file_name)\n\t\treturn -ENOMEM;\n\tgs->tmp_fd = mkstemp(gs->tmp_file_name);\n\tif (gs->tmp_fd < 0)\n\t\treturn -errno;\n\n\tif (zstd_init(&gs->session->zstd_data, 0) < 0)\n\t\tpr_warning(\"Guest session decompression initialization failed.\\n\");\n\n\t \n\tret = perf_session__process_events(gs->session);\n\tif (ret)\n\t\treturn ret;\n\n\tif (lseek(gs->tmp_fd, 0, SEEK_SET))\n\t\treturn -errno;\n\n\treturn 0;\n}\n\n \nstatic void free_hlist(struct hlist_head *heads, size_t hlist_sz)\n{\n\tstruct hlist_node *pos, *n;\n\tsize_t i;\n\n\tfor (i = 0; i < hlist_sz; ++i) {\n\t\thlist_for_each_safe(pos, n, &heads[i]) {\n\t\t\thlist_del(pos);\n\t\t\tfree(pos);\n\t\t}\n\t}\n}\n\nstatic void guest_session__exit(struct guest_session *gs)\n{\n\tif (gs->session) {\n\t\tperf_session__delete(gs->session);\n\t\tfree_hlist(gs->heads, PERF_EVLIST__HLIST_SIZE);\n\t\tfree_hlist(gs->tids, PERF_EVLIST__HLIST_SIZE);\n\t}\n\tif (gs->tmp_file_name) {\n\t\tif (gs->tmp_fd >= 0)\n\t\t\tclose(gs->tmp_fd);\n\t\tunlink(gs->tmp_file_name);\n\t\tzfree(&gs->tmp_file_name);\n\t}\n\tzfree(&gs->vcpu);\n\tzfree(&gs->perf_data_file);\n}\n\nstatic void get_tsc_conv(struct perf_tsc_conversion *tc, struct perf_record_time_conv *time_conv)\n{\n\ttc->time_shift\t\t= time_conv->time_shift;\n\ttc->time_mult\t\t= time_conv->time_mult;\n\ttc->time_zero\t\t= time_conv->time_zero;\n\ttc->time_cycles\t\t= time_conv->time_cycles;\n\ttc->time_mask\t\t= time_conv->time_mask;\n\ttc->cap_user_time_zero\t= time_conv->cap_user_time_zero;\n\ttc->cap_user_time_short\t= time_conv->cap_user_time_short;\n}\n\nstatic void guest_session__get_tc(struct guest_session *gs)\n{\n\tstruct perf_inject *inject = container_of(gs, struct perf_inject, guest_session);\n\n\tget_tsc_conv(&gs->host_tc, &inject->session->time_conv);\n\tget_tsc_conv(&gs->guest_tc, &gs->session->time_conv);\n}\n\nstatic void guest_session__convert_time(struct guest_session *gs, u64 guest_time, u64 *host_time)\n{\n\tu64 tsc;\n\n\tif (!guest_time) {\n\t\t*host_time = 0;\n\t\treturn;\n\t}\n\n\tif (gs->guest_tc.cap_user_time_zero)\n\t\ttsc = perf_time_to_tsc(guest_time, &gs->guest_tc);\n\telse\n\t\ttsc = guest_time;\n\n\t \n\ttsc -= gs->time_offset;\n\ttsc /= gs->time_scale;\n\n\tif (gs->host_tc.cap_user_time_zero)\n\t\t*host_time = tsc_to_perf_time(tsc, &gs->host_tc);\n\telse\n\t\t*host_time = tsc;\n}\n\nstatic int guest_session__fetch(struct guest_session *gs)\n{\n\tvoid *buf;\n\tstruct perf_event_header *hdr;\n\tsize_t hdr_sz = sizeof(*hdr);\n\tssize_t ret;\n\n\tbuf = gs->ev.event_buf;\n\tif (!buf) {\n\t\tbuf = malloc(PERF_SAMPLE_MAX_SIZE);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tgs->ev.event_buf = buf;\n\t}\n\thdr = buf;\n\tret = readn(gs->tmp_fd, buf, hdr_sz);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!ret) {\n\t\t \n\t\thdr->size = 0;\n\t\treturn 0;\n\t}\n\n\tbuf += hdr_sz;\n\n\tret = readn(gs->tmp_fd, buf, hdr->size - hdr_sz);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgs->ev.event = (union perf_event *)gs->ev.event_buf;\n\tgs->ev.sample.time = 0;\n\n\tif (hdr->type >= PERF_RECORD_USER_TYPE_START) {\n\t\tpr_err(\"Unexpected type fetching guest event\");\n\t\treturn 0;\n\t}\n\n\tret = evlist__parse_sample(gs->session->evlist, gs->ev.event, &gs->ev.sample);\n\tif (ret) {\n\t\tpr_err(\"Parse failed fetching guest event\");\n\t\treturn ret;\n\t}\n\n\tif (!gs->have_tc) {\n\t\tguest_session__get_tc(gs);\n\t\tgs->have_tc = true;\n\t}\n\n\tguest_session__convert_time(gs, gs->ev.sample.time, &gs->ev.sample.time);\n\n\treturn 0;\n}\n\nstatic int evlist__append_id_sample(struct evlist *evlist, union perf_event *ev,\n\t\t\t\t    const struct perf_sample *sample)\n{\n\tstruct evsel *evsel;\n\tvoid *array;\n\tint ret;\n\n\tevsel = evlist__id2evsel(evlist, sample->id);\n\tarray = ev;\n\n\tif (!evsel) {\n\t\tpr_err(\"No evsel for id %\"PRIu64\"\\n\", sample->id);\n\t\treturn -EINVAL;\n\t}\n\n\tarray += ev->header.size;\n\tret = perf_event__synthesize_id_sample(array, evsel->core.attr.sample_type, sample);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & 7) {\n\t\tpr_err(\"Bad id sample size %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tev->header.size += ret;\n\n\treturn 0;\n}\n\nstatic int guest_session__inject_events(struct guest_session *gs, u64 timestamp)\n{\n\tstruct perf_inject *inject = container_of(gs, struct perf_inject, guest_session);\n\tint ret;\n\n\tif (!gs->ready)\n\t\treturn 0;\n\n\twhile (1) {\n\t\tstruct perf_sample *sample;\n\t\tstruct guest_id *guest_id;\n\t\tunion perf_event *ev;\n\t\tu16 id_hdr_size;\n\t\tu8 cpumode;\n\t\tu64 id;\n\n\t\tif (!gs->fetched) {\n\t\t\tret = guest_session__fetch(gs);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tgs->fetched = true;\n\t\t}\n\n\t\tev = gs->ev.event;\n\t\tsample = &gs->ev.sample;\n\n\t\tif (!ev->header.size)\n\t\t\treturn 0;  \n\n\t\tif (sample->time > timestamp)\n\t\t\treturn 0;\n\n\t\t \n\t\tcpumode = ev->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\n\t\tif (cpumode & PERF_RECORD_MISC_USER)\n\t\t\tcpumode = PERF_RECORD_MISC_GUEST_USER;\n\t\telse\n\t\t\tcpumode = PERF_RECORD_MISC_GUEST_KERNEL;\n\t\tev->header.misc &= ~PERF_RECORD_MISC_CPUMODE_MASK;\n\t\tev->header.misc |= cpumode;\n\n\t\tid = sample->id;\n\t\tif (!id) {\n\t\t\tid = gs->dflt_id;\n\t\t\tid_hdr_size = gs->dflt_id_hdr_size;\n\t\t} else {\n\t\t\tstruct evsel *evsel = evlist__id2evsel(gs->session->evlist, id);\n\n\t\t\tid_hdr_size = evsel__id_hdr_size(evsel);\n\t\t}\n\n\t\tif (id_hdr_size & 7) {\n\t\t\tpr_err(\"Bad id_hdr_size %u\\n\", id_hdr_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ev->header.size & 7) {\n\t\t\tpr_err(\"Bad event size %u\\n\", ev->header.size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tev->header.size -= id_hdr_size;\n\n\t\tif (ev->header.size & 7) {\n\t\t\tpr_err(\"Bad raw event size %u\\n\", ev->header.size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tguest_id = guest_session__lookup_id(gs, id);\n\t\tif (!guest_id) {\n\t\t\tpr_err(\"Guest event with unknown id %llu\\n\",\n\t\t\t       (unsigned long long)id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tsample->id = guest_id->host_id;\n\t\tsample->stream_id = guest_id->host_id;\n\n\t\tif (sample->cpu != (u32)-1) {\n\t\t\tif (sample->cpu >= gs->vcpu_cnt) {\n\t\t\t\tpr_err(\"Guest event with unknown VCPU %u\\n\",\n\t\t\t\t       sample->cpu);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tsample->cpu = gs->vcpu[sample->cpu].cpu;\n\t\t}\n\n\t\t \n\t\tret = evlist__append_id_sample(inject->session->evlist, ev, sample);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ev->header.size & 7) {\n\t\t\tpr_err(\"Bad new event size %u\\n\", ev->header.size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgs->fetched = false;\n\n\t\tret = output_bytes(inject, ev, ev->header.size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n}\n\nstatic int guest_session__flush_events(struct guest_session *gs)\n{\n\treturn guest_session__inject_events(gs, -1);\n}\n\nstatic int host__repipe(struct perf_tool *tool,\n\t\t\tunion perf_event *event,\n\t\t\tstruct perf_sample *sample,\n\t\t\tstruct machine *machine)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\tint ret;\n\n\tret = guest_session__inject_events(&inject->guest_session, sample->time);\n\tif (ret)\n\t\treturn ret;\n\n\treturn perf_event__repipe(tool, event, sample, machine);\n}\n\nstatic int host__finished_init(struct perf_session *session, union perf_event *event)\n{\n\tstruct perf_inject *inject = container_of(session->tool, struct perf_inject, tool);\n\tstruct guest_session *gs = &inject->guest_session;\n\tint ret;\n\n\t \n\tret = host_peek_vm_comms(session, gs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!gs->vcpu_cnt) {\n\t\tpr_err(\"No VCPU threads found for pid %u\\n\", gs->machine_pid);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tgs->highest_id = evlist__find_highest_id(session->evlist);\n\tret = guest_session__map_ids(gs, session->evlist);\n\tif (ret)\n\t\treturn ret;\n\n\tret = guest_session__add_attrs(gs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = synthesize_id_index(inject, gs->session->evlist->core.nr_entries);\n\tif (ret) {\n\t\tpr_err(\"Failed to synthesize id_index\\n\");\n\t\treturn ret;\n\t}\n\n\tret = guest_session__add_build_ids(gs);\n\tif (ret) {\n\t\tpr_err(\"Failed to add guest build IDs\\n\");\n\t\treturn ret;\n\t}\n\n\tgs->ready = true;\n\n\tret = guest_session__inject_events(gs, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn perf_event__repipe_op2_synth(session, event);\n}\n\n \nstatic int host__finished_round(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct ordered_events *oe)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\tint ret = perf_event__process_finished_round(tool, event, oe);\n\tu64 timestamp = ordered_events__last_flush_time(oe);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = guest_session__inject_events(&inject->guest_session, timestamp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn perf_event__repipe_oe_synth(tool, event, oe);\n}\n\nstatic int host__context_switch(struct perf_tool *tool,\n\t\t\t\tunion perf_event *event,\n\t\t\t\tstruct perf_sample *sample,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\n\tbool out = event->header.misc & PERF_RECORD_MISC_SWITCH_OUT;\n\tstruct guest_session *gs = &inject->guest_session;\n\tu32 pid = event->context_switch.next_prev_pid;\n\tu32 tid = event->context_switch.next_prev_tid;\n\tstruct guest_tid *guest_tid;\n\tu32 vcpu;\n\n\tif (out || pid != gs->machine_pid)\n\t\tgoto out;\n\n\tguest_tid = guest_session__lookup_tid(gs, tid);\n\tif (!guest_tid)\n\t\tgoto out;\n\n\tif (sample->cpu == (u32)-1) {\n\t\tpr_err(\"Switch event does not have CPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvcpu = guest_tid->vcpu;\n\tif (vcpu >= gs->vcpu_cnt)\n\t\treturn -EINVAL;\n\n\t \n\tgs->vcpu[vcpu].cpu = sample->cpu;\nout:\n\treturn host__repipe(tool, event, sample, machine);\n}\n\nstatic void sig_handler(int sig __maybe_unused)\n{\n\tsession_done = 1;\n}\n\nstatic int evsel__check_stype(struct evsel *evsel, u64 sample_type, const char *sample_msg)\n{\n\tstruct perf_event_attr *attr = &evsel->core.attr;\n\tconst char *name = evsel__name(evsel);\n\n\tif (!(attr->sample_type & sample_type)) {\n\t\tpr_err(\"Samples for %s event do not have %s attribute set.\",\n\t\t\tname, sample_msg);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int drop_sample(struct perf_tool *tool __maybe_unused,\n\t\t       union perf_event *event __maybe_unused,\n\t\t       struct perf_sample *sample __maybe_unused,\n\t\t       struct evsel *evsel __maybe_unused,\n\t\t       struct machine *machine __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic void strip_init(struct perf_inject *inject)\n{\n\tstruct evlist *evlist = inject->session->evlist;\n\tstruct evsel *evsel;\n\n\tinject->tool.context_switch = perf_event__drop;\n\n\tevlist__for_each_entry(evlist, evsel)\n\t\tevsel->handler = drop_sample;\n}\n\nstatic int parse_vm_time_correlation(const struct option *opt, const char *str, int unset)\n{\n\tstruct perf_inject *inject = opt->value;\n\tconst char *args;\n\tchar *dry_run;\n\n\tif (unset)\n\t\treturn 0;\n\n\tinject->itrace_synth_opts.set = true;\n\tinject->itrace_synth_opts.vm_time_correlation = true;\n\tinject->in_place_update = true;\n\n\tif (!str)\n\t\treturn 0;\n\n\tdry_run = skip_spaces(str);\n\tif (!strncmp(dry_run, \"dry-run\", strlen(\"dry-run\"))) {\n\t\tinject->itrace_synth_opts.vm_tm_corr_dry_run = true;\n\t\tinject->in_place_update_dry_run = true;\n\t\targs = dry_run + strlen(\"dry-run\");\n\t} else {\n\t\targs = str;\n\t}\n\n\tinject->itrace_synth_opts.vm_tm_corr_args = strdup(args);\n\n\treturn inject->itrace_synth_opts.vm_tm_corr_args ? 0 : -ENOMEM;\n}\n\nstatic int parse_guest_data(const struct option *opt, const char *str, int unset)\n{\n\tstruct perf_inject *inject = opt->value;\n\tstruct guest_session *gs = &inject->guest_session;\n\tchar *tok;\n\tchar *s;\n\n\tif (unset)\n\t\treturn 0;\n\n\tif (!str)\n\t\tgoto bad_args;\n\n\ts = strdup(str);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tgs->perf_data_file = strsep(&s, \",\");\n\tif (!gs->perf_data_file)\n\t\tgoto bad_args;\n\n\tgs->copy_kcore_dir = has_kcore_dir(gs->perf_data_file);\n\tif (gs->copy_kcore_dir)\n\t\tinject->output.is_dir = true;\n\n\ttok = strsep(&s, \",\");\n\tif (!tok)\n\t\tgoto bad_args;\n\tgs->machine_pid = strtoul(tok, NULL, 0);\n\tif (!inject->guest_session.machine_pid)\n\t\tgoto bad_args;\n\n\tgs->time_scale = 1;\n\n\ttok = strsep(&s, \",\");\n\tif (!tok)\n\t\tgoto out;\n\tgs->time_offset = strtoull(tok, NULL, 0);\n\n\ttok = strsep(&s, \",\");\n\tif (!tok)\n\t\tgoto out;\n\tgs->time_scale = strtod(tok, NULL);\n\tif (!gs->time_scale)\n\t\tgoto bad_args;\nout:\n\treturn 0;\n\nbad_args:\n\tpr_err(\"--guest-data option requires guest perf.data file name, \"\n\t       \"guest machine PID, and optionally guest timestamp offset, \"\n\t       \"and guest timestamp scale factor, separated by commas.\\n\");\n\treturn -1;\n}\n\nstatic int save_section_info_cb(struct perf_file_section *section,\n\t\t\t\tstruct perf_header *ph __maybe_unused,\n\t\t\t\tint feat, int fd __maybe_unused, void *data)\n{\n\tstruct perf_inject *inject = data;\n\n\tinject->secs[feat] = *section;\n\treturn 0;\n}\n\nstatic int save_section_info(struct perf_inject *inject)\n{\n\tstruct perf_header *header = &inject->session->header;\n\tint fd = perf_data__fd(inject->session->data);\n\n\treturn perf_header__process_sections(header, fd, inject, save_section_info_cb);\n}\n\nstatic bool keep_feat(int feat)\n{\n\tswitch (feat) {\n\t \n\tcase HEADER_TRACING_DATA:\n\tcase HEADER_HOSTNAME:\n\tcase HEADER_OSRELEASE:\n\tcase HEADER_VERSION:\n\tcase HEADER_ARCH:\n\tcase HEADER_NRCPUS:\n\tcase HEADER_CPUDESC:\n\tcase HEADER_CPUID:\n\tcase HEADER_TOTAL_MEM:\n\tcase HEADER_CPU_TOPOLOGY:\n\tcase HEADER_NUMA_TOPOLOGY:\n\tcase HEADER_PMU_MAPPINGS:\n\tcase HEADER_CACHE:\n\tcase HEADER_MEM_TOPOLOGY:\n\tcase HEADER_CLOCKID:\n\tcase HEADER_BPF_PROG_INFO:\n\tcase HEADER_BPF_BTF:\n\tcase HEADER_CPU_PMU_CAPS:\n\tcase HEADER_CLOCK_DATA:\n\tcase HEADER_HYBRID_TOPOLOGY:\n\tcase HEADER_PMU_CAPS:\n\t\treturn true;\n\t \n\tcase HEADER_BUILD_ID:\n\tcase HEADER_CMDLINE:\n\tcase HEADER_EVENT_DESC:\n\tcase HEADER_BRANCH_STACK:\n\tcase HEADER_GROUP_DESC:\n\tcase HEADER_AUXTRACE:\n\tcase HEADER_STAT:\n\tcase HEADER_SAMPLE_TIME:\n\tcase HEADER_DIR_FORMAT:\n\tcase HEADER_COMPRESSED:\n\tdefault:\n\t\treturn false;\n\t};\n}\n\nstatic int read_file(int fd, u64 offs, void *buf, size_t sz)\n{\n\tssize_t ret = preadn(fd, buf, sz, offs);\n\n\tif (ret < 0)\n\t\treturn -errno;\n\tif ((size_t)ret != sz)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int feat_copy(struct perf_inject *inject, int feat, struct feat_writer *fw)\n{\n\tint fd = perf_data__fd(inject->session->data);\n\tu64 offs = inject->secs[feat].offset;\n\tsize_t sz = inject->secs[feat].size;\n\tvoid *buf = malloc(sz);\n\tint ret;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = read_file(fd, offs, buf, sz);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = fw->write(fw, buf, sz);\nout_free:\n\tfree(buf);\n\treturn ret;\n}\n\nstruct inject_fc {\n\tstruct feat_copier fc;\n\tstruct perf_inject *inject;\n};\n\nstatic int feat_copy_cb(struct feat_copier *fc, int feat, struct feat_writer *fw)\n{\n\tstruct inject_fc *inj_fc = container_of(fc, struct inject_fc, fc);\n\tstruct perf_inject *inject = inj_fc->inject;\n\tint ret;\n\n\tif (!inject->secs[feat].offset ||\n\t    !keep_feat(feat))\n\t\treturn 0;\n\n\tret = feat_copy(inject, feat, fw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 1;  \n}\n\nstatic int copy_kcore_dir(struct perf_inject *inject)\n{\n\tchar *cmd;\n\tint ret;\n\n\tret = asprintf(&cmd, \"cp -r -n %s/kcore_dir* %s >/dev/null 2>&1\",\n\t\t       inject->input_name, inject->output.path);\n\tif (ret < 0)\n\t\treturn ret;\n\tpr_debug(\"%s\\n\", cmd);\n\tret = system(cmd);\n\tfree(cmd);\n\treturn ret;\n}\n\nstatic int guest_session__copy_kcore_dir(struct guest_session *gs)\n{\n\tstruct perf_inject *inject = container_of(gs, struct perf_inject, guest_session);\n\tchar *cmd;\n\tint ret;\n\n\tret = asprintf(&cmd, \"cp -r -n %s/kcore_dir %s/kcore_dir__%u >/dev/null 2>&1\",\n\t\t       gs->perf_data_file, inject->output.path, gs->machine_pid);\n\tif (ret < 0)\n\t\treturn ret;\n\tpr_debug(\"%s\\n\", cmd);\n\tret = system(cmd);\n\tfree(cmd);\n\treturn ret;\n}\n\nstatic int output_fd(struct perf_inject *inject)\n{\n\treturn inject->in_place_update ? -1 : perf_data__fd(&inject->output);\n}\n\nstatic int __cmd_inject(struct perf_inject *inject)\n{\n\tint ret = -EINVAL;\n\tstruct guest_session *gs = &inject->guest_session;\n\tstruct perf_session *session = inject->session;\n\tint fd = output_fd(inject);\n\tu64 output_data_offset;\n\n\tsignal(SIGINT, sig_handler);\n\n\tif (inject->build_ids || inject->sched_stat ||\n\t    inject->itrace_synth_opts.set || inject->build_id_all) {\n\t\tinject->tool.mmap\t  = perf_event__repipe_mmap;\n\t\tinject->tool.mmap2\t  = perf_event__repipe_mmap2;\n\t\tinject->tool.fork\t  = perf_event__repipe_fork;\n#ifdef HAVE_LIBTRACEEVENT\n\t\tinject->tool.tracing_data = perf_event__repipe_tracing_data;\n#endif\n\t}\n\n\toutput_data_offset = perf_session__data_offset(session->evlist);\n\n\tif (inject->build_id_all) {\n\t\tinject->tool.mmap\t  = perf_event__repipe_buildid_mmap;\n\t\tinject->tool.mmap2\t  = perf_event__repipe_buildid_mmap2;\n\t} else if (inject->build_ids) {\n\t\tinject->tool.sample = perf_event__inject_buildid;\n\t} else if (inject->sched_stat) {\n\t\tstruct evsel *evsel;\n\n\t\tevlist__for_each_entry(session->evlist, evsel) {\n\t\t\tconst char *name = evsel__name(evsel);\n\n\t\t\tif (!strcmp(name, \"sched:sched_switch\")) {\n\t\t\t\tif (evsel__check_stype(evsel, PERF_SAMPLE_TID, \"TID\"))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tevsel->handler = perf_inject__sched_switch;\n\t\t\t} else if (!strcmp(name, \"sched:sched_process_exit\"))\n\t\t\t\tevsel->handler = perf_inject__sched_process_exit;\n#ifdef HAVE_LIBTRACEEVENT\n\t\t\telse if (!strncmp(name, \"sched:sched_stat_\", 17))\n\t\t\t\tevsel->handler = perf_inject__sched_stat;\n#endif\n\t\t}\n\t} else if (inject->itrace_synth_opts.vm_time_correlation) {\n\t\tsession->itrace_synth_opts = &inject->itrace_synth_opts;\n\t\tmemset(&inject->tool, 0, sizeof(inject->tool));\n\t\tinject->tool.id_index\t    = perf_event__process_id_index;\n\t\tinject->tool.auxtrace_info  = perf_event__process_auxtrace_info;\n\t\tinject->tool.auxtrace\t    = perf_event__process_auxtrace;\n\t\tinject->tool.auxtrace_error = perf_event__process_auxtrace_error;\n\t\tinject->tool.ordered_events = true;\n\t\tinject->tool.ordering_requires_timestamps = true;\n\t} else if (inject->itrace_synth_opts.set) {\n\t\tsession->itrace_synth_opts = &inject->itrace_synth_opts;\n\t\tinject->itrace_synth_opts.inject = true;\n\t\tinject->tool.comm\t    = perf_event__repipe_comm;\n\t\tinject->tool.namespaces\t    = perf_event__repipe_namespaces;\n\t\tinject->tool.exit\t    = perf_event__repipe_exit;\n\t\tinject->tool.id_index\t    = perf_event__process_id_index;\n\t\tinject->tool.auxtrace_info  = perf_event__process_auxtrace_info;\n\t\tinject->tool.auxtrace\t    = perf_event__process_auxtrace;\n\t\tinject->tool.aux\t    = perf_event__drop_aux;\n\t\tinject->tool.itrace_start   = perf_event__drop_aux;\n\t\tinject->tool.aux_output_hw_id = perf_event__drop_aux;\n\t\tinject->tool.ordered_events = true;\n\t\tinject->tool.ordering_requires_timestamps = true;\n\t\t \n\t\toutput_data_offset = roundup(8192 + session->header.data_offset, 4096);\n\t\tif (inject->strip)\n\t\t\tstrip_init(inject);\n\t} else if (gs->perf_data_file) {\n\t\tchar *name = gs->perf_data_file;\n\n\t\t \n\t\tinject->tool.mmap\t\t= host__repipe;\n\t\tinject->tool.mmap2\t\t= host__repipe;\n\t\tinject->tool.comm\t\t= host__repipe;\n\t\tinject->tool.fork\t\t= host__repipe;\n\t\tinject->tool.exit\t\t= host__repipe;\n\t\tinject->tool.lost\t\t= host__repipe;\n\t\tinject->tool.context_switch\t= host__repipe;\n\t\tinject->tool.ksymbol\t\t= host__repipe;\n\t\tinject->tool.text_poke\t\t= host__repipe;\n\t\t \n\t\tinject->tool.finished_init\t= host__finished_init;\n\t\t \n\t\tinject->tool.finished_round\t= host__finished_round,\n\t\t \n\t\tinject->tool.context_switch\t= host__context_switch;\n\t\t \n\t\tinject->tool.ordered_events\t= true;\n\t\tinject->tool.ordering_requires_timestamps = true;\n\t\t \n\t\tret = guest_session__start(gs, name, session->data->force);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to process %s, error %d\\n\", name, ret);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\toutput_data_offset += gs->session->header.data_offset;\n\t\toutput_data_offset = roundup(output_data_offset, 4096);\n\t}\n\n\tif (!inject->itrace_synth_opts.set)\n\t\tauxtrace_index__free(&session->auxtrace_index);\n\n\tif (!inject->is_pipe && !inject->in_place_update)\n\t\tlseek(fd, output_data_offset, SEEK_SET);\n\n\tret = perf_session__process_events(session);\n\tif (ret)\n\t\treturn ret;\n\n\tif (gs->session) {\n\t\t \n\t\tret = guest_session__flush_events(gs);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to flush guest events\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!inject->is_pipe && !inject->in_place_update) {\n\t\tstruct inject_fc inj_fc = {\n\t\t\t.fc.copy = feat_copy_cb,\n\t\t\t.inject = inject,\n\t\t};\n\n\t\tif (inject->build_ids)\n\t\t\tperf_header__set_feat(&session->header,\n\t\t\t\t\t      HEADER_BUILD_ID);\n\t\t \n\t\tif (perf_header__has_feat(&session->header, HEADER_BUILD_ID) &&\n\t\t    inject->have_auxtrace && !inject->itrace_synth_opts.set)\n\t\t\tdsos__hit_all(session);\n\t\t \n\t\tif (inject->itrace_synth_opts.set) {\n\t\t\tperf_header__clear_feat(&session->header,\n\t\t\t\t\t\tHEADER_AUXTRACE);\n\t\t\tif (inject->itrace_synth_opts.last_branch ||\n\t\t\t    inject->itrace_synth_opts.add_last_branch)\n\t\t\t\tperf_header__set_feat(&session->header,\n\t\t\t\t\t\t      HEADER_BRANCH_STACK);\n\t\t}\n\t\tsession->header.data_offset = output_data_offset;\n\t\tsession->header.data_size = inject->bytes_written;\n\t\tperf_session__inject_header(session, session->evlist, fd, &inj_fc.fc);\n\n\t\tif (inject->copy_kcore_dir) {\n\t\t\tret = copy_kcore_dir(inject);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Failed to copy kcore\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (gs->copy_kcore_dir) {\n\t\t\tret = guest_session__copy_kcore_dir(gs);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Failed to copy guest kcore\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint cmd_inject(int argc, const char **argv)\n{\n\tstruct perf_inject inject = {\n\t\t.tool = {\n\t\t\t.sample\t\t= perf_event__repipe_sample,\n\t\t\t.read\t\t= perf_event__repipe_sample,\n\t\t\t.mmap\t\t= perf_event__repipe,\n\t\t\t.mmap2\t\t= perf_event__repipe,\n\t\t\t.comm\t\t= perf_event__repipe,\n\t\t\t.namespaces\t= perf_event__repipe,\n\t\t\t.cgroup\t\t= perf_event__repipe,\n\t\t\t.fork\t\t= perf_event__repipe,\n\t\t\t.exit\t\t= perf_event__repipe,\n\t\t\t.lost\t\t= perf_event__repipe,\n\t\t\t.lost_samples\t= perf_event__repipe,\n\t\t\t.aux\t\t= perf_event__repipe,\n\t\t\t.itrace_start\t= perf_event__repipe,\n\t\t\t.aux_output_hw_id = perf_event__repipe,\n\t\t\t.context_switch\t= perf_event__repipe,\n\t\t\t.throttle\t= perf_event__repipe,\n\t\t\t.unthrottle\t= perf_event__repipe,\n\t\t\t.ksymbol\t= perf_event__repipe,\n\t\t\t.bpf\t\t= perf_event__repipe,\n\t\t\t.text_poke\t= perf_event__repipe,\n\t\t\t.attr\t\t= perf_event__repipe_attr,\n\t\t\t.event_update\t= perf_event__repipe_event_update,\n\t\t\t.tracing_data\t= perf_event__repipe_op2_synth,\n\t\t\t.finished_round\t= perf_event__repipe_oe_synth,\n\t\t\t.build_id\t= perf_event__repipe_op2_synth,\n\t\t\t.id_index\t= perf_event__repipe_op2_synth,\n\t\t\t.auxtrace_info\t= perf_event__repipe_op2_synth,\n\t\t\t.auxtrace_error\t= perf_event__repipe_op2_synth,\n\t\t\t.time_conv\t= perf_event__repipe_op2_synth,\n\t\t\t.thread_map\t= perf_event__repipe_op2_synth,\n\t\t\t.cpu_map\t= perf_event__repipe_op2_synth,\n\t\t\t.stat_config\t= perf_event__repipe_op2_synth,\n\t\t\t.stat\t\t= perf_event__repipe_op2_synth,\n\t\t\t.stat_round\t= perf_event__repipe_op2_synth,\n\t\t\t.feature\t= perf_event__repipe_op2_synth,\n\t\t\t.finished_init\t= perf_event__repipe_op2_synth,\n\t\t\t.compressed\t= perf_event__repipe_op4_synth,\n\t\t\t.auxtrace\t= perf_event__repipe_auxtrace,\n\t\t},\n\t\t.input_name  = \"-\",\n\t\t.samples = LIST_HEAD_INIT(inject.samples),\n\t\t.output = {\n\t\t\t.path = \"-\",\n\t\t\t.mode = PERF_DATA_MODE_WRITE,\n\t\t\t.use_stdio = true,\n\t\t},\n\t};\n\tstruct perf_data data = {\n\t\t.mode = PERF_DATA_MODE_READ,\n\t\t.use_stdio = true,\n\t};\n\tint ret;\n\tbool repipe = true;\n\tconst char *known_build_ids = NULL;\n\n\tstruct option options[] = {\n\t\tOPT_BOOLEAN('b', \"build-ids\", &inject.build_ids,\n\t\t\t    \"Inject build-ids into the output stream\"),\n\t\tOPT_BOOLEAN(0, \"buildid-all\", &inject.build_id_all,\n\t\t\t    \"Inject build-ids of all DSOs into the output stream\"),\n\t\tOPT_STRING(0, \"known-build-ids\", &known_build_ids,\n\t\t\t   \"buildid path [,buildid path...]\",\n\t\t\t   \"build-ids to use for given paths\"),\n\t\tOPT_STRING('i', \"input\", &inject.input_name, \"file\",\n\t\t\t   \"input file name\"),\n\t\tOPT_STRING('o', \"output\", &inject.output.path, \"file\",\n\t\t\t   \"output file name\"),\n\t\tOPT_BOOLEAN('s', \"sched-stat\", &inject.sched_stat,\n\t\t\t    \"Merge sched-stat and sched-switch for getting events \"\n\t\t\t    \"where and how long tasks slept\"),\n#ifdef HAVE_JITDUMP\n\t\tOPT_BOOLEAN('j', \"jit\", &inject.jit_mode, \"merge jitdump files into perf.data file\"),\n#endif\n\t\tOPT_INCR('v', \"verbose\", &verbose,\n\t\t\t \"be more verbose (show build ids, etc)\"),\n\t\tOPT_STRING('k', \"vmlinux\", &symbol_conf.vmlinux_name,\n\t\t\t   \"file\", \"vmlinux pathname\"),\n\t\tOPT_BOOLEAN(0, \"ignore-vmlinux\", &symbol_conf.ignore_vmlinux,\n\t\t\t    \"don't load vmlinux even if found\"),\n\t\tOPT_STRING(0, \"kallsyms\", &symbol_conf.kallsyms_name, \"file\",\n\t\t\t   \"kallsyms pathname\"),\n\t\tOPT_BOOLEAN('f', \"force\", &data.force, \"don't complain, do it\"),\n\t\tOPT_CALLBACK_OPTARG(0, \"itrace\", &inject.itrace_synth_opts,\n\t\t\t\t    NULL, \"opts\", \"Instruction Tracing options\\n\"\n\t\t\t\t    ITRACE_HELP,\n\t\t\t\t    itrace_parse_synth_opts),\n\t\tOPT_BOOLEAN(0, \"strip\", &inject.strip,\n\t\t\t    \"strip non-synthesized events (use with --itrace)\"),\n\t\tOPT_CALLBACK_OPTARG(0, \"vm-time-correlation\", &inject, NULL, \"opts\",\n\t\t\t\t    \"correlate time between VM guests and the host\",\n\t\t\t\t    parse_vm_time_correlation),\n\t\tOPT_CALLBACK_OPTARG(0, \"guest-data\", &inject, NULL, \"opts\",\n\t\t\t\t    \"inject events from a guest perf.data file\",\n\t\t\t\t    parse_guest_data),\n\t\tOPT_STRING(0, \"guestmount\", &symbol_conf.guestmount, \"directory\",\n\t\t\t   \"guest mount directory under which every guest os\"\n\t\t\t   \" instance has a subdir\"),\n\t\tOPT_END()\n\t};\n\tconst char * const inject_usage[] = {\n\t\t\"perf inject [<options>]\",\n\t\tNULL\n\t};\n#ifndef HAVE_JITDUMP\n\tset_option_nobuild(options, 'j', \"jit\", \"NO_LIBELF=1\", true);\n#endif\n\targc = parse_options(argc, argv, options, inject_usage, 0);\n\n\t \n\tif (argc)\n\t\tusage_with_options(inject_usage, options);\n\n\tif (inject.strip && !inject.itrace_synth_opts.set) {\n\t\tpr_err(\"--strip option requires --itrace option\\n\");\n\t\treturn -1;\n\t}\n\n\tif (symbol__validate_sym_arguments())\n\t\treturn -1;\n\n\tif (inject.in_place_update) {\n\t\tif (!strcmp(inject.input_name, \"-\")) {\n\t\t\tpr_err(\"Input file name required for in-place updating\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (strcmp(inject.output.path, \"-\")) {\n\t\t\tpr_err(\"Output file name must not be specified for in-place updating\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!data.force && !inject.in_place_update_dry_run) {\n\t\t\tpr_err(\"The input file would be updated in place, \"\n\t\t\t\t\"the --force option is required.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!inject.in_place_update_dry_run)\n\t\t\tdata.in_place_update = true;\n\t} else {\n\t\tif (strcmp(inject.output.path, \"-\") && !inject.strip &&\n\t\t    has_kcore_dir(inject.input_name)) {\n\t\t\tinject.output.is_dir = true;\n\t\t\tinject.copy_kcore_dir = true;\n\t\t}\n\t\tif (perf_data__open(&inject.output)) {\n\t\t\tperror(\"failed to create output file\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdata.path = inject.input_name;\n\tif (!strcmp(inject.input_name, \"-\") || inject.output.is_pipe) {\n\t\tinject.is_pipe = true;\n\t\t \n\t\tif (strcmp(inject.input_name, \"-\"))\n\t\t\trepipe = false;\n\t}\n\n\tinject.session = __perf_session__new(&data, repipe,\n\t\t\t\t\t     output_fd(&inject),\n\t\t\t\t\t     &inject.tool);\n\tif (IS_ERR(inject.session)) {\n\t\tret = PTR_ERR(inject.session);\n\t\tgoto out_close_output;\n\t}\n\n\tif (zstd_init(&(inject.session->zstd_data), 0) < 0)\n\t\tpr_warning(\"Decompression initialization failed.\\n\");\n\n\t \n\tret = save_section_info(&inject);\n\tif (ret)\n\t\tgoto out_delete;\n\n\tif (!data.is_pipe && inject.output.is_pipe) {\n\t\tret = perf_header__write_pipe(perf_data__fd(&inject.output));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Couldn't write a new pipe header.\\n\");\n\t\t\tgoto out_delete;\n\t\t}\n\n\t\tret = perf_event__synthesize_for_pipe(&inject.tool,\n\t\t\t\t\t\t      inject.session,\n\t\t\t\t\t\t      &inject.output,\n\t\t\t\t\t\t      perf_event__repipe);\n\t\tif (ret < 0)\n\t\t\tgoto out_delete;\n\t}\n\n\tif (inject.build_ids && !inject.build_id_all) {\n\t\t \n\t\tinject.tool.ordered_events = true;\n\t\tinject.tool.ordering_requires_timestamps = true;\n\t\tif (known_build_ids != NULL) {\n\t\t\tinject.known_build_ids =\n\t\t\t\tperf_inject__parse_known_build_ids(known_build_ids);\n\n\t\t\tif (inject.known_build_ids == NULL) {\n\t\t\t\tpr_err(\"Couldn't parse known build ids.\\n\");\n\t\t\t\tgoto out_delete;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (inject.sched_stat) {\n\t\tinject.tool.ordered_events = true;\n\t}\n\n#ifdef HAVE_JITDUMP\n\tif (inject.jit_mode) {\n\t\tinject.tool.mmap2\t   = perf_event__jit_repipe_mmap2;\n\t\tinject.tool.mmap\t   = perf_event__jit_repipe_mmap;\n\t\tinject.tool.ordered_events = true;\n\t\tinject.tool.ordering_requires_timestamps = true;\n\t\t \n\t\tinject.tool.finished_round = perf_event__drop_oe;\n\t}\n#endif\n\tret = symbol__init(&inject.session->header.env);\n\tif (ret < 0)\n\t\tgoto out_delete;\n\n\tret = __cmd_inject(&inject);\n\n\tguest_session__exit(&inject.guest_session);\n\nout_delete:\n\tstrlist__delete(inject.known_build_ids);\n\tzstd_fini(&(inject.session->zstd_data));\n\tperf_session__delete(inject.session);\nout_close_output:\n\tif (!inject.in_place_update)\n\t\tperf_data__close(&inject.output);\n\tfree(inject.itrace_synth_opts.vm_tm_corr_args);\n\tfree(inject.event_copy);\n\tfree(inject.guest_session.ev.event_buf);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}