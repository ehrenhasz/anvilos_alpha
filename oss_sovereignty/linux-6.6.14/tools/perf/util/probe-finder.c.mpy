{
  "module_name": "probe-finder.c",
  "hash_id": "3b5977cd185446d0167f43ecf5b250ebf30648903dafe4dbc209349110a28be4",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/probe-finder.c",
  "human_readable_source": "\n \n\n#include <inttypes.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <dwarf-regs.h>\n\n#include <linux/bitops.h>\n#include <linux/zalloc.h>\n#include \"event.h\"\n#include \"dso.h\"\n#include \"debug.h\"\n#include \"intlist.h\"\n#include \"strbuf.h\"\n#include \"strlist.h\"\n#include \"symbol.h\"\n#include \"probe-finder.h\"\n#include \"probe-file.h\"\n#include \"string2.h\"\n\n#ifdef HAVE_DEBUGINFOD_SUPPORT\n#include <elfutils/debuginfod.h>\n#endif\n\n \n#define MAX_BASIC_TYPE_BITS\t64\n\n \nstatic char *debuginfo_path;\t \n\nstatic const Dwfl_Callbacks offline_callbacks = {\n\t.find_debuginfo = dwfl_standard_find_debuginfo,\n\t.debuginfo_path = &debuginfo_path,\n\n\t.section_address = dwfl_offline_section_address,\n\n\t \n\t.find_elf = dwfl_build_id_find_elf,\n};\n\n \nstatic int debuginfo__init_offline_dwarf(struct debuginfo *dbg,\n\t\t\t\t\t const char *path)\n{\n\tGElf_Addr dummy;\n\tint fd;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tdbg->dwfl = dwfl_begin(&offline_callbacks);\n\tif (!dbg->dwfl)\n\t\tgoto error;\n\n\tdwfl_report_begin(dbg->dwfl);\n\tdbg->mod = dwfl_report_offline(dbg->dwfl, \"\", \"\", fd);\n\tif (!dbg->mod)\n\t\tgoto error;\n\n\tdbg->dbg = dwfl_module_getdwarf(dbg->mod, &dbg->bias);\n\tif (!dbg->dbg)\n\t\tgoto error;\n\n\tdwfl_module_build_id(dbg->mod, &dbg->build_id, &dummy);\n\n\tdwfl_report_end(dbg->dwfl, NULL, NULL);\n\n\treturn 0;\nerror:\n\tif (dbg->dwfl)\n\t\tdwfl_end(dbg->dwfl);\n\telse\n\t\tclose(fd);\n\tmemset(dbg, 0, sizeof(*dbg));\n\n\treturn -ENOENT;\n}\n\nstatic struct debuginfo *__debuginfo__new(const char *path)\n{\n\tstruct debuginfo *dbg = zalloc(sizeof(*dbg));\n\tif (!dbg)\n\t\treturn NULL;\n\n\tif (debuginfo__init_offline_dwarf(dbg, path) < 0)\n\t\tzfree(&dbg);\n\tif (dbg)\n\t\tpr_debug(\"Open Debuginfo file: %s\\n\", path);\n\treturn dbg;\n}\n\nenum dso_binary_type distro_dwarf_types[] = {\n\tDSO_BINARY_TYPE__FEDORA_DEBUGINFO,\n\tDSO_BINARY_TYPE__UBUNTU_DEBUGINFO,\n\tDSO_BINARY_TYPE__OPENEMBEDDED_DEBUGINFO,\n\tDSO_BINARY_TYPE__BUILDID_DEBUGINFO,\n\tDSO_BINARY_TYPE__MIXEDUP_UBUNTU_DEBUGINFO,\n\tDSO_BINARY_TYPE__NOT_FOUND,\n};\n\nstruct debuginfo *debuginfo__new(const char *path)\n{\n\tenum dso_binary_type *type;\n\tchar buf[PATH_MAX], nil = '\\0';\n\tstruct dso *dso;\n\tstruct debuginfo *dinfo = NULL;\n\tstruct build_id bid;\n\n\t \n\tdso = dso__new(path);\n\tif (!dso)\n\t\tgoto out;\n\n\t \n\tif (is_regular_file(path) && filename__read_build_id(path, &bid) > 0)\n\t\tdso__set_build_id(dso, &bid);\n\n\tfor (type = distro_dwarf_types;\n\t     !dinfo && *type != DSO_BINARY_TYPE__NOT_FOUND;\n\t     type++) {\n\t\tif (dso__read_binary_type_filename(dso, *type, &nil,\n\t\t\t\t\t\t   buf, PATH_MAX) < 0)\n\t\t\tcontinue;\n\t\tdinfo = __debuginfo__new(buf);\n\t}\n\tdso__put(dso);\n\nout:\n\t \n\treturn dinfo ? : __debuginfo__new(path);\n}\n\nvoid debuginfo__delete(struct debuginfo *dbg)\n{\n\tif (dbg) {\n\t\tif (dbg->dwfl)\n\t\t\tdwfl_end(dbg->dwfl);\n\t\tfree(dbg);\n\t}\n}\n\n \n\nstatic struct probe_trace_arg_ref *alloc_trace_arg_ref(long offs)\n{\n\tstruct probe_trace_arg_ref *ref;\n\tref = zalloc(sizeof(struct probe_trace_arg_ref));\n\tif (ref != NULL)\n\t\tref->offset = offs;\n\treturn ref;\n}\n\n \nstatic int convert_variable_location(Dwarf_Die *vr_die, Dwarf_Addr addr,\n\t\t\t\t     Dwarf_Op *fb_ops, Dwarf_Die *sp_die,\n\t\t\t\t     unsigned int machine,\n\t\t\t\t     struct probe_trace_arg *tvar)\n{\n\tDwarf_Attribute attr;\n\tDwarf_Addr tmp = 0;\n\tDwarf_Op *op;\n\tsize_t nops;\n\tunsigned int regn;\n\tDwarf_Word offs = 0;\n\tbool ref = false;\n\tconst char *regs;\n\tint ret, ret2 = 0;\n\n\tif (dwarf_attr(vr_die, DW_AT_external, &attr) != NULL)\n\t\tgoto static_var;\n\n\t \n\tif (dwarf_attr(vr_die, DW_AT_const_value, &attr) &&\n\t    immediate_value_is_supported()) {\n\t\tDwarf_Sword snum;\n\n\t\tif (!tvar)\n\t\t\treturn 0;\n\n\t\tdwarf_formsdata(&attr, &snum);\n\t\tret = asprintf(&tvar->value, \"\\\\%ld\", (long)snum);\n\n\t\treturn ret < 0 ? -ENOMEM : 0;\n\t}\n\n\t \n\tif (dwarf_attr(vr_die, DW_AT_location, &attr) == NULL)\n\t\treturn -EINVAL;\t \n\tif (dwarf_getlocation_addr(&attr, addr, &op, &nops, 1) <= 0) {\n\t\tret = dwarf_entrypc(sp_die, &tmp);\n\t\tif (ret)\n\t\t\treturn -ENOENT;\n\n\t\tif (probe_conf.show_location_range &&\n\t\t\t(dwarf_tag(vr_die) == DW_TAG_variable)) {\n\t\t\tret2 = -ERANGE;\n\t\t} else if (addr != tmp ||\n\t\t\tdwarf_tag(vr_die) != DW_TAG_formal_parameter) {\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tret = dwarf_highpc(sp_die, &tmp);\n\t\tif (ret)\n\t\t\treturn -ENOENT;\n\t\t \n\t\tfor (addr += 1; addr <= tmp; addr++) {\n\t\t\tif (dwarf_getlocation_addr(&attr, addr, &op,\n\t\t\t\t\t\t   &nops, 1) > 0)\n\t\t\t\tgoto found;\n\t\t}\n\t\treturn -ENOENT;\n\t}\nfound:\n\tif (nops == 0)\n\t\t \n\t\treturn -ENOENT;\n\n\tif (op->atom == DW_OP_addr) {\nstatic_var:\n\t\tif (!tvar)\n\t\t\treturn ret2;\n\t\t \n\t\tret = strlen(dwarf_diename(vr_die));\n\t\ttvar->value = zalloc(ret + 2);\n\t\tif (tvar->value == NULL)\n\t\t\treturn -ENOMEM;\n\t\tsnprintf(tvar->value, ret + 2, \"@%s\", dwarf_diename(vr_die));\n\t\ttvar->ref = alloc_trace_arg_ref((long)offs);\n\t\tif (tvar->ref == NULL)\n\t\t\treturn -ENOMEM;\n\t\treturn ret2;\n\t}\n\n\t \n\tif (op->atom == DW_OP_fbreg) {\n\t\tif (fb_ops == NULL)\n\t\t\treturn -ENOTSUP;\n\t\tref = true;\n\t\toffs = op->number;\n\t\top = &fb_ops[0];\n\t}\n\n\tif (op->atom >= DW_OP_breg0 && op->atom <= DW_OP_breg31) {\n\t\tregn = op->atom - DW_OP_breg0;\n\t\toffs += op->number;\n\t\tref = true;\n\t} else if (op->atom >= DW_OP_reg0 && op->atom <= DW_OP_reg31) {\n\t\tregn = op->atom - DW_OP_reg0;\n\t} else if (op->atom == DW_OP_bregx) {\n\t\tregn = op->number;\n\t\toffs += op->number2;\n\t\tref = true;\n\t} else if (op->atom == DW_OP_regx) {\n\t\tregn = op->number;\n\t} else {\n\t\tpr_debug(\"DW_OP %x is not supported.\\n\", op->atom);\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (!tvar)\n\t\treturn ret2;\n\n\tregs = get_dwarf_regstr(regn, machine);\n\tif (!regs) {\n\t\t \n\t\tpr_warning(\"Mapping for the register number %u \"\n\t\t\t   \"missing on this architecture.\\n\", regn);\n\t\treturn -ENOTSUP;\n\t}\n\n\ttvar->value = strdup(regs);\n\tif (tvar->value == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ref) {\n\t\ttvar->ref = alloc_trace_arg_ref((long)offs);\n\t\tif (tvar->ref == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn ret2;\n}\n\n#define BYTES_TO_BITS(nb)\t((nb) * BITS_PER_LONG / sizeof(long))\n\nstatic int convert_variable_type(Dwarf_Die *vr_die,\n\t\t\t\t struct probe_trace_arg *tvar,\n\t\t\t\t const char *cast, bool user_access)\n{\n\tstruct probe_trace_arg_ref **ref_ptr = &tvar->ref;\n\tDwarf_Die type;\n\tchar buf[16];\n\tchar sbuf[STRERR_BUFSIZE];\n\tint bsize, boffs, total;\n\tint ret;\n\tchar prefix;\n\n\t \n\tif (cast && strcmp(cast, \"string\") != 0 && strcmp(cast, \"ustring\") &&\n\t    strcmp(cast, \"x\") != 0 &&\n\t    strcmp(cast, \"s\") != 0 && strcmp(cast, \"u\") != 0) {\n\t\t \n\t\t \n\t\ttvar->type = strdup(cast);\n\t\treturn (tvar->type == NULL) ? -ENOMEM : 0;\n\t}\n\n\tbsize = dwarf_bitsize(vr_die);\n\tif (bsize > 0) {\n\t\t \n\t\tboffs = dwarf_bitoffset(vr_die);\n\t\ttotal = dwarf_bytesize(vr_die);\n\t\tif (boffs < 0 || total < 0)\n\t\t\treturn -ENOENT;\n\t\tret = snprintf(buf, 16, \"b%d@%d/%zd\", bsize, boffs,\n\t\t\t\tBYTES_TO_BITS(total));\n\t\tgoto formatted;\n\t}\n\n\tif (die_get_real_type(vr_die, &type) == NULL) {\n\t\tpr_warning(\"Failed to get a type information of %s.\\n\",\n\t\t\t   dwarf_diename(vr_die));\n\t\treturn -ENOENT;\n\t}\n\n\tpr_debug(\"%s type is %s.\\n\",\n\t\t dwarf_diename(vr_die), dwarf_diename(&type));\n\n\tif (cast && (!strcmp(cast, \"string\") || !strcmp(cast, \"ustring\"))) {\n\t\t \n\t\tret = dwarf_tag(&type);\n\t\tif (ret != DW_TAG_pointer_type &&\n\t\t    ret != DW_TAG_array_type) {\n\t\t\tpr_warning(\"Failed to cast into string: \"\n\t\t\t\t   \"%s(%s) is not a pointer nor array.\\n\",\n\t\t\t\t   dwarf_diename(vr_die), dwarf_diename(&type));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (die_get_real_type(&type, &type) == NULL) {\n\t\t\tpr_warning(\"Failed to get a type\"\n\t\t\t\t   \" information.\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (ret == DW_TAG_pointer_type) {\n\t\t\twhile (*ref_ptr)\n\t\t\t\tref_ptr = &(*ref_ptr)->next;\n\t\t\t \n\t\t\t*ref_ptr = zalloc(sizeof(struct probe_trace_arg_ref));\n\t\t\tif (*ref_ptr == NULL) {\n\t\t\t\tpr_warning(\"Out of memory error\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t(*ref_ptr)->user_access = user_access;\n\t\t}\n\t\tif (!die_compare_name(&type, \"char\") &&\n\t\t    !die_compare_name(&type, \"unsigned char\")) {\n\t\t\tpr_warning(\"Failed to cast into string: \"\n\t\t\t\t   \"%s is not (unsigned) char *.\\n\",\n\t\t\t\t   dwarf_diename(vr_die));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttvar->type = strdup(cast);\n\t\treturn (tvar->type == NULL) ? -ENOMEM : 0;\n\t}\n\n\tif (cast && (strcmp(cast, \"u\") == 0))\n\t\tprefix = 'u';\n\telse if (cast && (strcmp(cast, \"s\") == 0))\n\t\tprefix = 's';\n\telse if (cast && (strcmp(cast, \"x\") == 0) &&\n\t\t probe_type_is_available(PROBE_TYPE_X))\n\t\tprefix = 'x';\n\telse\n\t\tprefix = die_is_signed_type(&type) ? 's' :\n\t\t\t probe_type_is_available(PROBE_TYPE_X) ? 'x' : 'u';\n\n\tret = dwarf_bytesize(&type);\n\tif (ret <= 0)\n\t\t \n\t\treturn 0;\n\tret = BYTES_TO_BITS(ret);\n\n\t \n\tif (ret > MAX_BASIC_TYPE_BITS) {\n\t\tpr_info(\"%s exceeds max-bitwidth. Cut down to %d bits.\\n\",\n\t\t\tdwarf_diename(&type), MAX_BASIC_TYPE_BITS);\n\t\tret = MAX_BASIC_TYPE_BITS;\n\t}\n\tret = snprintf(buf, 16, \"%c%d\", prefix, ret);\n\nformatted:\n\tif (ret < 0 || ret >= 16) {\n\t\tif (ret >= 16)\n\t\t\tret = -E2BIG;\n\t\tpr_warning(\"Failed to convert variable type: %s\\n\",\n\t\t\t   str_error_r(-ret, sbuf, sizeof(sbuf)));\n\t\treturn ret;\n\t}\n\ttvar->type = strdup(buf);\n\tif (tvar->type == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int convert_variable_fields(Dwarf_Die *vr_die, const char *varname,\n\t\t\t\t    struct perf_probe_arg_field *field,\n\t\t\t\t    struct probe_trace_arg_ref **ref_ptr,\n\t\t\t\t    Dwarf_Die *die_mem, bool user_access)\n{\n\tstruct probe_trace_arg_ref *ref = *ref_ptr;\n\tDwarf_Die type;\n\tDwarf_Word offs;\n\tint ret, tag;\n\n\tpr_debug(\"converting %s in %s\\n\", field->name, varname);\n\tif (die_get_real_type(vr_die, &type) == NULL) {\n\t\tpr_warning(\"Failed to get the type of %s.\\n\", varname);\n\t\treturn -ENOENT;\n\t}\n\tpr_debug2(\"Var real type: %s (%x)\\n\", dwarf_diename(&type),\n\t\t  (unsigned)dwarf_dieoffset(&type));\n\ttag = dwarf_tag(&type);\n\n\tif (field->name[0] == '[' &&\n\t    (tag == DW_TAG_array_type || tag == DW_TAG_pointer_type)) {\n\t\t \n\t\tmemcpy(die_mem, &type, sizeof(*die_mem));\n\t\t \n\t\tif (die_get_real_type(&type, &type) == NULL) {\n\t\t\tpr_warning(\"Failed to get the type of %s.\\n\", varname);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tpr_debug2(\"Array real type: %s (%x)\\n\", dwarf_diename(&type),\n\t\t\t (unsigned)dwarf_dieoffset(&type));\n\t\tif (tag == DW_TAG_pointer_type) {\n\t\t\tref = zalloc(sizeof(struct probe_trace_arg_ref));\n\t\t\tif (ref == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (*ref_ptr)\n\t\t\t\t(*ref_ptr)->next = ref;\n\t\t\telse\n\t\t\t\t*ref_ptr = ref;\n\t\t}\n\t\tref->offset += dwarf_bytesize(&type) * field->index;\n\t\tref->user_access = user_access;\n\t\tgoto next;\n\t} else if (tag == DW_TAG_pointer_type) {\n\t\t \n\t\tif (!field->ref) {\n\t\t\tpr_err(\"Semantic error: %s must be referred by '->'\\n\",\n\t\t\t       field->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (die_get_real_type(&type, &type) == NULL) {\n\t\t\tpr_warning(\"Failed to get the type of %s.\\n\", varname);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\t \n\t\ttag = dwarf_tag(&type);\n\t\tif (tag != DW_TAG_structure_type && tag != DW_TAG_union_type) {\n\t\t\tpr_warning(\"%s is not a data structure nor a union.\\n\",\n\t\t\t\t   varname);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tref = zalloc(sizeof(struct probe_trace_arg_ref));\n\t\tif (ref == NULL)\n\t\t\treturn -ENOMEM;\n\t\tif (*ref_ptr)\n\t\t\t(*ref_ptr)->next = ref;\n\t\telse\n\t\t\t*ref_ptr = ref;\n\t} else {\n\t\t \n\t\tif (tag != DW_TAG_structure_type && tag != DW_TAG_union_type) {\n\t\t\tpr_warning(\"%s is not a data structure nor a union.\\n\",\n\t\t\t\t   varname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (field->name[0] == '[') {\n\t\t\tpr_err(\"Semantic error: %s is not a pointer\"\n\t\t\t       \" nor array.\\n\", varname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (field->ref && dwarf_diename(vr_die)) {\n\t\t\tpr_err(\"Semantic error: %s must be referred by '.'\\n\",\n\t\t\t       field->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!ref) {\n\t\t\tpr_warning(\"Structure on a register is not \"\n\t\t\t\t   \"supported yet.\\n\");\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t}\n\n\tif (die_find_member(&type, field->name, die_mem) == NULL) {\n\t\tpr_warning(\"%s(type:%s) has no member %s.\\n\", varname,\n\t\t\t   dwarf_diename(&type), field->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (tag == DW_TAG_union_type) {\n\t\toffs = 0;\n\t} else {\n\t\tret = die_get_data_member_location(die_mem, &offs);\n\t\tif (ret < 0) {\n\t\t\tpr_warning(\"Failed to get the offset of %s.\\n\",\n\t\t\t\t   field->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tref->offset += (long)offs;\n\tref->user_access = user_access;\n\n\t \n\tif (!dwarf_diename(die_mem))\n\t\treturn convert_variable_fields(die_mem, varname, field,\n\t\t\t\t\t\t&ref, die_mem, user_access);\n\nnext:\n\t \n\tif (field->next)\n\t\treturn convert_variable_fields(die_mem, field->name,\n\t\t\t\tfield->next, &ref, die_mem, user_access);\n\telse\n\t\treturn 0;\n}\n\nstatic void print_var_not_found(const char *varname)\n{\n\tpr_err(\"Failed to find the location of the '%s' variable at this address.\\n\"\n\t       \" Perhaps it has been optimized out.\\n\"\n\t       \" Use -V with the --range option to show '%s' location range.\\n\",\n\t\tvarname, varname);\n}\n\n \nstatic int convert_variable(Dwarf_Die *vr_die, struct probe_finder *pf)\n{\n\tDwarf_Die die_mem;\n\tint ret;\n\n\tpr_debug(\"Converting variable %s into trace event.\\n\",\n\t\t dwarf_diename(vr_die));\n\n\tret = convert_variable_location(vr_die, pf->addr, pf->fb_ops,\n\t\t\t\t\t&pf->sp_die, pf->machine, pf->tvar);\n\tif (ret == -ENOENT && pf->skip_empty_arg)\n\t\t \n\t\treturn 0;\n\tif (ret == -ENOENT || ret == -EINVAL) {\n\t\tprint_var_not_found(pf->pvar->var);\n\t} else if (ret == -ENOTSUP)\n\t\tpr_err(\"Sorry, we don't support this variable location yet.\\n\");\n\telse if (ret == 0 && pf->pvar->field) {\n\t\tret = convert_variable_fields(vr_die, pf->pvar->var,\n\t\t\t\t\t      pf->pvar->field, &pf->tvar->ref,\n\t\t\t\t\t      &die_mem, pf->pvar->user_access);\n\t\tvr_die = &die_mem;\n\t}\n\tif (ret == 0)\n\t\tret = convert_variable_type(vr_die, pf->tvar, pf->pvar->type,\n\t\t\t\t\t    pf->pvar->user_access);\n\t \n\treturn ret;\n}\n\n \nstatic int find_variable(Dwarf_Die *sc_die, struct probe_finder *pf)\n{\n\tDwarf_Die vr_die;\n\tchar *buf, *ptr;\n\tint ret = 0;\n\n\t \n\tif (!is_c_varname(pf->pvar->var))\n\t\treturn copy_to_probe_trace_arg(pf->tvar, pf->pvar);\n\n\tif (pf->pvar->name)\n\t\tpf->tvar->name = strdup(pf->pvar->name);\n\telse {\n\t\tbuf = synthesize_perf_probe_arg(pf->pvar);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tptr = strchr(buf, ':');\t \n\t\tif (ptr)\n\t\t\t*ptr = '_';\n\t\tpf->tvar->name = buf;\n\t}\n\tif (pf->tvar->name == NULL)\n\t\treturn -ENOMEM;\n\n\tpr_debug(\"Searching '%s' variable in context.\\n\", pf->pvar->var);\n\t \n\tif (!die_find_variable_at(sc_die, pf->pvar->var, pf->addr, &vr_die)) {\n\t\t \n\t\tif (!die_find_variable_at(&pf->cu_die, pf->pvar->var,\n\t\t\t\t\t\t0, &vr_die)) {\n\t\t\tif (pf->skip_empty_arg)\n\t\t\t\treturn 0;\n\t\t\tpr_warning(\"Failed to find '%s' in this function.\\n\",\n\t\t\t\t   pf->pvar->var);\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\n\tif (ret >= 0)\n\t\tret = convert_variable(&vr_die, pf);\n\n\treturn ret;\n}\n\n \nstatic int convert_to_trace_point(Dwarf_Die *sp_die, Dwfl_Module *mod,\n\t\t\t\t  Dwarf_Addr paddr, bool retprobe,\n\t\t\t\t  const char *function,\n\t\t\t\t  struct probe_trace_point *tp)\n{\n\tDwarf_Addr eaddr;\n\tGElf_Sym sym;\n\tconst char *symbol;\n\n\t \n\tif (!dwarf_haspc(sp_die, paddr)) {\n\t\tpr_warning(\"Specified offset is out of %s\\n\",\n\t\t\t   dwarf_diename(sp_die));\n\t\treturn -EINVAL;\n\t}\n\n\tif (dwarf_entrypc(sp_die, &eaddr) == 0) {\n\t\t \n\t\tsymbol = dwarf_diename(sp_die);\n\t} else {\n\t\t \n\t\tsymbol = dwfl_module_addrsym(mod, paddr, &sym, NULL);\n\t\teaddr = sym.st_value;\n\t}\n\tif (!symbol) {\n\t\tpr_warning(\"Failed to find symbol at 0x%lx\\n\",\n\t\t\t   (unsigned long)paddr);\n\t\treturn -ENOENT;\n\t}\n\n\ttp->offset = (unsigned long)(paddr - eaddr);\n\ttp->address = paddr;\n\ttp->symbol = strdup(symbol);\n\tif (!tp->symbol)\n\t\treturn -ENOMEM;\n\n\t \n\tif (retprobe) {\n\t\tif (eaddr != paddr) {\n\t\t\tpr_warning(\"Failed to find \\\"%s%%return\\\",\\n\"\n\t\t\t\t   \" because %s is an inlined function and\"\n\t\t\t\t   \" has no return point.\\n\", function,\n\t\t\t\t   function);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttp->retprobe = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int call_probe_finder(Dwarf_Die *sc_die, struct probe_finder *pf)\n{\n\tDwarf_Attribute fb_attr;\n\tDwarf_Frame *frame = NULL;\n\tsize_t nops;\n\tint ret;\n\n\tif (!sc_die) {\n\t\tpr_err(\"Caller must pass a scope DIE. Program error.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!die_is_func_def(sc_die)) {\n\t\tif (!die_find_realfunc(&pf->cu_die, pf->addr, &pf->sp_die)) {\n\t\t\tif (die_find_tailfunc(&pf->cu_die, pf->addr, &pf->sp_die)) {\n\t\t\t\tpr_warning(\"Ignoring tail call from %s\\n\",\n\t\t\t\t\t\tdwarf_diename(&pf->sp_die));\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tpr_warning(\"Failed to find probe point in any \"\n\t\t\t\t\t   \"functions.\\n\");\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemcpy(&pf->sp_die, sc_die, sizeof(Dwarf_Die));\n\n\t \n\tdwarf_attr(&pf->sp_die, DW_AT_frame_base, &fb_attr);\n\tret = dwarf_getlocation_addr(&fb_attr, pf->addr, &pf->fb_ops, &nops, 1);\n\tif (ret <= 0 || nops == 0) {\n\t\tpf->fb_ops = NULL;\n#if _ELFUTILS_PREREQ(0, 142)\n\t} else if (nops == 1 && pf->fb_ops[0].atom == DW_OP_call_frame_cfa &&\n\t\t   (pf->cfi_eh != NULL || pf->cfi_dbg != NULL)) {\n\t\tif ((dwarf_cfi_addrframe(pf->cfi_eh, pf->addr, &frame) != 0 &&\n\t\t     (dwarf_cfi_addrframe(pf->cfi_dbg, pf->addr, &frame) != 0)) ||\n\t\t    dwarf_frame_cfa(frame, &pf->fb_ops, &nops) != 0) {\n\t\t\tpr_warning(\"Failed to get call frame on 0x%jx\\n\",\n\t\t\t\t   (uintmax_t)pf->addr);\n\t\t\tfree(frame);\n\t\t\treturn -ENOENT;\n\t\t}\n#endif\n\t}\n\n\t \n\tret = pf->callback(sc_die, pf);\n\n\t \n\tfree(frame);\n\tpf->fb_ops = NULL;\n\n\treturn ret;\n}\n\nstruct find_scope_param {\n\tconst char *function;\n\tconst char *file;\n\tint line;\n\tint diff;\n\tDwarf_Die *die_mem;\n\tbool found;\n};\n\nstatic int find_best_scope_cb(Dwarf_Die *fn_die, void *data)\n{\n\tstruct find_scope_param *fsp = data;\n\tconst char *file;\n\tint lno;\n\n\t \n\tif (fsp->file) {\n\t\tfile = die_get_decl_file(fn_die);\n\t\tif (!file || strcmp(fsp->file, file) != 0)\n\t\t\treturn 0;\n\t}\n\t \n\tif (fsp->function) {\n\t\tif (die_match_name(fn_die, fsp->function)) {\n\t\t\tmemcpy(fsp->die_mem, fn_die, sizeof(Dwarf_Die));\n\t\t\tfsp->found = true;\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t \n\t\tdwarf_decl_line(fn_die, &lno);\n\t\tif (lno < fsp->line && fsp->diff > fsp->line - lno) {\n\t\t\t \n\t\t\tfsp->diff = fsp->line - lno;\n\t\t\tmemcpy(fsp->die_mem, fn_die, sizeof(Dwarf_Die));\n\t\t\tfsp->found = true;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int find_inner_scope_cb(Dwarf_Die *fn_die, void *data)\n{\n\tstruct find_scope_param *fsp = data;\n\n\tmemcpy(fsp->die_mem, fn_die, sizeof(Dwarf_Die));\n\tfsp->found = true;\n\treturn 1;\n}\n\n \nstatic Dwarf_Die *find_best_scope(struct probe_finder *pf, Dwarf_Die *die_mem)\n{\n\tstruct find_scope_param fsp = {\n\t\t.function = pf->pev->point.function,\n\t\t.file = pf->fname,\n\t\t.line = pf->lno,\n\t\t.diff = INT_MAX,\n\t\t.die_mem = die_mem,\n\t\t.found = false,\n\t};\n\tint ret;\n\n\tret = cu_walk_functions_at(&pf->cu_die, pf->addr, find_best_scope_cb,\n\t\t\t\t   &fsp);\n\tif (!ret && !fsp.found)\n\t\tcu_walk_functions_at(&pf->cu_die, pf->addr,\n\t\t\t\t     find_inner_scope_cb, &fsp);\n\n\treturn fsp.found ? die_mem : NULL;\n}\n\nstatic int verify_representive_line(struct probe_finder *pf, const char *fname,\n\t\t\t\tint lineno, Dwarf_Addr addr)\n{\n\tconst char *__fname, *__func = NULL;\n\tDwarf_Die die_mem;\n\tint __lineno;\n\n\t \n\tif (cu_find_lineinfo(&pf->cu_die, addr, &__fname, &__lineno) < 0)\n\t\treturn 0;\n\n\tpr_debug2(\"Reversed line: %s:%d\\n\", __fname, __lineno);\n\tif (strcmp(fname, __fname) || lineno == __lineno)\n\t\treturn 0;\n\n\tpr_warning(\"This line is sharing the address with other lines.\\n\");\n\n\tif (pf->pev->point.function) {\n\t\t \n\t\tpf->addr = addr;\n\t\tif (find_best_scope(pf, &die_mem)\n\t\t    && die_match_name(&die_mem, pf->pev->point.function)\n\t\t    && dwarf_decl_line(&die_mem, &lineno) == 0) {\n\t\t\t__func = dwarf_diename(&die_mem);\n\t\t\t__lineno -= lineno;\n\t\t}\n\t}\n\tpr_warning(\"Please try to probe at %s:%d instead.\\n\",\n\t\t   __func ? : __fname, __lineno);\n\n\treturn -ENOENT;\n}\n\nstatic int probe_point_line_walker(const char *fname, int lineno,\n\t\t\t\t   Dwarf_Addr addr, void *data)\n{\n\tstruct probe_finder *pf = data;\n\tDwarf_Die *sc_die, die_mem;\n\tint ret;\n\n\tif (lineno != pf->lno || strtailcmp(fname, pf->fname) != 0)\n\t\treturn 0;\n\n\tif (verify_representive_line(pf, fname, lineno, addr))\n\t\treturn -ENOENT;\n\n\tpf->addr = addr;\n\tsc_die = find_best_scope(pf, &die_mem);\n\tif (!sc_die) {\n\t\tpr_warning(\"Failed to find scope of probe point.\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = call_probe_finder(sc_die, pf);\n\n\t \n\treturn ret < 0 ? ret : 0;\n}\n\n \nstatic int find_probe_point_by_line(struct probe_finder *pf)\n{\n\treturn die_walk_lines(&pf->cu_die, probe_point_line_walker, pf);\n}\n\n \nstatic int find_lazy_match_lines(struct intlist *list,\n\t\t\t\t const char *fname, const char *pat)\n{\n\tFILE *fp;\n\tchar *line = NULL;\n\tsize_t line_len;\n\tssize_t len;\n\tint count = 0, linenum = 1;\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tfp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tpr_warning(\"Failed to open %s: %s\\n\", fname,\n\t\t\t   str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\treturn -errno;\n\t}\n\n\twhile ((len = getline(&line, &line_len, fp)) > 0) {\n\n\t\tif (line[len - 1] == '\\n')\n\t\t\tline[len - 1] = '\\0';\n\n\t\tif (strlazymatch(line, pat)) {\n\t\t\tintlist__add(list, linenum);\n\t\t\tcount++;\n\t\t}\n\t\tlinenum++;\n\t}\n\n\tif (ferror(fp))\n\t\tcount = -errno;\n\tfree(line);\n\tfclose(fp);\n\n\tif (count == 0)\n\t\tpr_debug(\"No matched lines found in %s.\\n\", fname);\n\treturn count;\n}\n\nstatic int probe_point_lazy_walker(const char *fname, int lineno,\n\t\t\t\t   Dwarf_Addr addr, void *data)\n{\n\tstruct probe_finder *pf = data;\n\tDwarf_Die *sc_die, die_mem;\n\tint ret;\n\n\tif (!intlist__has_entry(pf->lcache, lineno) ||\n\t    strtailcmp(fname, pf->fname) != 0)\n\t\treturn 0;\n\n\tpr_debug(\"Probe line found: line:%d addr:0x%llx\\n\",\n\t\t lineno, (unsigned long long)addr);\n\tpf->addr = addr;\n\tpf->lno = lineno;\n\tsc_die = find_best_scope(pf, &die_mem);\n\tif (!sc_die) {\n\t\tpr_warning(\"Failed to find scope of probe point.\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = call_probe_finder(sc_die, pf);\n\n\t \n\treturn ret < 0 ? ret : 0;\n}\n\n \nstatic int find_probe_point_lazy(Dwarf_Die *sp_die, struct probe_finder *pf)\n{\n\tstruct build_id bid;\n\tchar sbuild_id[SBUILD_ID_SIZE] = \"\";\n\tint ret = 0;\n\tchar *fpath;\n\n\tif (intlist__empty(pf->lcache)) {\n\t\tconst char *comp_dir;\n\n\t\tcomp_dir = cu_get_comp_dir(&pf->cu_die);\n\t\tif (pf->dbg->build_id) {\n\t\t\tbuild_id__init(&bid, pf->dbg->build_id, BUILD_ID_SIZE);\n\t\t\tbuild_id__sprintf(&bid, sbuild_id);\n\t\t}\n\t\tret = find_source_path(pf->fname, sbuild_id, comp_dir, &fpath);\n\t\tif (ret < 0) {\n\t\t\tpr_warning(\"Failed to find source file path.\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = find_lazy_match_lines(pf->lcache, fpath,\n\t\t\t\t\t    pf->pev->point.lazy_line);\n\t\tfree(fpath);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t}\n\n\treturn die_walk_lines(sp_die, probe_point_lazy_walker, pf);\n}\n\nstatic void skip_prologue(Dwarf_Die *sp_die, struct probe_finder *pf)\n{\n\tstruct perf_probe_point *pp = &pf->pev->point;\n\n\t \n\tif (!pf->pev->uprobes)\n\t\treturn;\n\n\t \n\tif (die_is_optimized_target(&pf->cu_die))\n\t\treturn;\n\n\t \n\tif (!pf->addr)\n\t\treturn;\n\n\t \n\tif (!pp->function || pp->line || pp->retprobe || pp->lazy_line ||\n\t    pp->offset || pp->abs_address)\n\t\treturn;\n\n\t \n\tif (!perf_probe_with_var(pf->pev))\n\t\treturn;\n\n\tpr_info(\"Target program is compiled without optimization. Skipping prologue.\\n\"\n\t\t\"Probe on address 0x%\" PRIx64 \" to force probing at the function entry.\\n\\n\",\n\t\tpf->addr);\n\n\tdie_skip_prologue(sp_die, &pf->cu_die, &pf->addr);\n}\n\nstatic int probe_point_inline_cb(Dwarf_Die *in_die, void *data)\n{\n\tstruct probe_finder *pf = data;\n\tstruct perf_probe_point *pp = &pf->pev->point;\n\tDwarf_Addr addr;\n\tint ret;\n\n\tif (pp->lazy_line)\n\t\tret = find_probe_point_lazy(in_die, pf);\n\telse {\n\t\t \n\t\tif (die_entrypc(in_die, &addr) != 0) {\n\t\t\tpr_warning(\"Failed to get entry address of %s.\\n\",\n\t\t\t\t   dwarf_diename(in_die));\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (addr == 0) {\n\t\t\tpr_debug(\"%s has no valid entry address. skipped.\\n\",\n\t\t\t\t dwarf_diename(in_die));\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tpf->addr = addr;\n\t\tpf->addr += pp->offset;\n\t\tpr_debug(\"found inline addr: 0x%jx\\n\",\n\t\t\t (uintmax_t)pf->addr);\n\n\t\tret = call_probe_finder(in_die, pf);\n\t}\n\n\treturn ret;\n}\n\n \nstruct dwarf_callback_param {\n\tvoid *data;\n\tint retval;\n};\n\n \nstatic int probe_point_search_cb(Dwarf_Die *sp_die, void *data)\n{\n\tstruct dwarf_callback_param *param = data;\n\tstruct probe_finder *pf = param->data;\n\tstruct perf_probe_point *pp = &pf->pev->point;\n\tconst char *fname;\n\n\t \n\tif (!die_is_func_def(sp_die) ||\n\t    !die_match_name(sp_die, pp->function))\n\t\treturn DWARF_CB_OK;\n\n\t \n\tfname = die_get_decl_file(sp_die);\n\tif (!fname) {\n\t\tpr_warning(\"A function DIE doesn't have decl_line. Maybe broken DWARF?\\n\");\n\t\treturn DWARF_CB_OK;\n\t}\n\tif (pp->file && fname && strtailcmp(pp->file, fname))\n\t\treturn DWARF_CB_OK;\n\n\tpr_debug(\"Matched function: %s [%lx]\\n\", dwarf_diename(sp_die),\n\t\t (unsigned long)dwarf_dieoffset(sp_die));\n\tpf->fname = fname;\n\tif (pp->line) {  \n\t\tdwarf_decl_line(sp_die, &pf->lno);\n\t\tpf->lno += pp->line;\n\t\tparam->retval = find_probe_point_by_line(pf);\n\t} else if (die_is_func_instance(sp_die)) {\n\t\t \n\t\tdie_entrypc(sp_die, &pf->addr);\n\t\t \n\t\tif (pf->addr == 0) {\n\t\t\tpr_debug(\"%s has no entry PC. Skipped\\n\",\n\t\t\t\t dwarf_diename(sp_die));\n\t\t\tparam->retval = 0;\n\t\t \n\t\t} else if (pp->lazy_line)\n\t\t\tparam->retval = find_probe_point_lazy(sp_die, pf);\n\t\telse {\n\t\t\tskip_prologue(sp_die, pf);\n\t\t\tpf->addr += pp->offset;\n\t\t\t \n\t\t\tparam->retval = call_probe_finder(sp_die, pf);\n\t\t}\n\t} else if (!probe_conf.no_inlines) {\n\t\t \n\t\tparam->retval = die_walk_instances(sp_die,\n\t\t\t\t\tprobe_point_inline_cb, (void *)pf);\n\t\t \n\t\tif (param->retval == -ENOENT)\n\t\t\tparam->retval = 0;\n\t}\n\n\t \n\tif (strisglob(pp->function) && param->retval >= 0) {\n\t\tparam->retval = 0;\t \n\t\treturn DWARF_CB_OK;\n\t}\n\n\treturn DWARF_CB_ABORT;  \n}\n\nstatic int find_probe_point_by_func(struct probe_finder *pf)\n{\n\tstruct dwarf_callback_param _param = {.data = (void *)pf,\n\t\t\t\t\t      .retval = 0};\n\tdwarf_getfuncs(&pf->cu_die, probe_point_search_cb, &_param, 0);\n\treturn _param.retval;\n}\n\nstruct pubname_callback_param {\n\tchar *function;\n\tchar *file;\n\tDwarf_Die *cu_die;\n\tDwarf_Die *sp_die;\n\tint found;\n};\n\nstatic int pubname_search_cb(Dwarf *dbg, Dwarf_Global *gl, void *data)\n{\n\tstruct pubname_callback_param *param = data;\n\tconst char *fname;\n\n\tif (dwarf_offdie(dbg, gl->die_offset, param->sp_die)) {\n\t\tif (dwarf_tag(param->sp_die) != DW_TAG_subprogram)\n\t\t\treturn DWARF_CB_OK;\n\n\t\tif (die_match_name(param->sp_die, param->function)) {\n\t\t\tif (!dwarf_offdie(dbg, gl->cu_offset, param->cu_die))\n\t\t\t\treturn DWARF_CB_OK;\n\n\t\t\tif (param->file) {\n\t\t\t\tfname = die_get_decl_file(param->sp_die);\n\t\t\t\tif (!fname || strtailcmp(param->file, fname))\n\t\t\t\t\treturn DWARF_CB_OK;\n\t\t\t}\n\n\t\t\tparam->found = 1;\n\t\t\treturn DWARF_CB_ABORT;\n\t\t}\n\t}\n\n\treturn DWARF_CB_OK;\n}\n\nstatic int debuginfo__find_probe_location(struct debuginfo *dbg,\n\t\t\t\t  struct probe_finder *pf)\n{\n\tstruct perf_probe_point *pp = &pf->pev->point;\n\tDwarf_Off off, noff;\n\tsize_t cuhl;\n\tDwarf_Die *diep;\n\tint ret = 0;\n\n\toff = 0;\n\tpf->lcache = intlist__new(NULL);\n\tif (!pf->lcache)\n\t\treturn -ENOMEM;\n\n\t \n\tif (pp->function && !strisglob(pp->function)) {\n\t\tstruct pubname_callback_param pubname_param = {\n\t\t\t.function = pp->function,\n\t\t\t.file\t  = pp->file,\n\t\t\t.cu_die\t  = &pf->cu_die,\n\t\t\t.sp_die\t  = &pf->sp_die,\n\t\t\t.found\t  = 0,\n\t\t};\n\t\tstruct dwarf_callback_param probe_param = {\n\t\t\t.data = pf,\n\t\t};\n\n\t\tdwarf_getpubnames(dbg->dbg, pubname_search_cb,\n\t\t\t\t  &pubname_param, 0);\n\t\tif (pubname_param.found) {\n\t\t\tret = probe_point_search_cb(&pf->sp_die, &probe_param);\n\t\t\tif (ret)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\t \n\twhile (!dwarf_nextcu(dbg->dbg, off, &noff, &cuhl, NULL, NULL, NULL)) {\n\t\t \n\t\tdiep = dwarf_offdie(dbg->dbg, off + cuhl, &pf->cu_die);\n\t\tif (!diep) {\n\t\t\toff = noff;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (pp->file)\n\t\t\tpf->fname = cu_find_realpath(&pf->cu_die, pp->file);\n\t\telse\n\t\t\tpf->fname = NULL;\n\n\t\tif (!pp->file || pf->fname) {\n\t\t\tif (pp->function)\n\t\t\t\tret = find_probe_point_by_func(pf);\n\t\t\telse if (pp->lazy_line)\n\t\t\t\tret = find_probe_point_lazy(&pf->cu_die, pf);\n\t\t\telse {\n\t\t\t\tpf->lno = pp->line;\n\t\t\t\tret = find_probe_point_by_line(pf);\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\toff = noff;\n\t}\n\nfound:\n\tintlist__delete(pf->lcache);\n\tpf->lcache = NULL;\n\n\treturn ret;\n}\n\n \nstatic int debuginfo__find_probes(struct debuginfo *dbg,\n\t\t\t\t  struct probe_finder *pf)\n{\n\tint ret = 0;\n\tElf *elf;\n\tGElf_Ehdr ehdr;\n\n\tif (pf->cfi_eh || pf->cfi_dbg)\n\t\treturn debuginfo__find_probe_location(dbg, pf);\n\n\t \n\telf = dwarf_getelf(dbg->dbg);\n\tif (elf == NULL)\n\t\treturn -EINVAL;\n\n\tif (gelf_getehdr(elf, &ehdr) == NULL)\n\t\treturn -EINVAL;\n\n\tpf->machine = ehdr.e_machine;\n\n#if _ELFUTILS_PREREQ(0, 142)\n\tdo {\n\t\tGElf_Shdr shdr;\n\n\t\tif (elf_section_by_name(elf, &ehdr, &shdr, \".eh_frame\", NULL) &&\n\t\t    shdr.sh_type == SHT_PROGBITS)\n\t\t\tpf->cfi_eh = dwarf_getcfi_elf(elf);\n\n\t\tpf->cfi_dbg = dwarf_getcfi(dbg->dbg);\n\t} while (0);\n#endif\n\n\tret = debuginfo__find_probe_location(dbg, pf);\n\treturn ret;\n}\n\nstruct local_vars_finder {\n\tstruct probe_finder *pf;\n\tstruct perf_probe_arg *args;\n\tbool vars;\n\tint max_args;\n\tint nargs;\n\tint ret;\n};\n\n \nstatic int copy_variables_cb(Dwarf_Die *die_mem, void *data)\n{\n\tstruct local_vars_finder *vf = data;\n\tstruct probe_finder *pf = vf->pf;\n\tint tag;\n\n\ttag = dwarf_tag(die_mem);\n\tif (tag == DW_TAG_formal_parameter ||\n\t    (tag == DW_TAG_variable && vf->vars)) {\n\t\tif (convert_variable_location(die_mem, vf->pf->addr,\n\t\t\t\t\t      vf->pf->fb_ops, &pf->sp_die,\n\t\t\t\t\t      pf->machine, NULL) == 0) {\n\t\t\tvf->args[vf->nargs].var = (char *)dwarf_diename(die_mem);\n\t\t\tif (vf->args[vf->nargs].var == NULL) {\n\t\t\t\tvf->ret = -ENOMEM;\n\t\t\t\treturn DIE_FIND_CB_END;\n\t\t\t}\n\t\t\tpr_debug(\" %s\", vf->args[vf->nargs].var);\n\t\t\tvf->nargs++;\n\t\t}\n\t}\n\n\tif (dwarf_haspc(die_mem, vf->pf->addr))\n\t\treturn DIE_FIND_CB_CONTINUE;\n\telse\n\t\treturn DIE_FIND_CB_SIBLING;\n}\n\nstatic int expand_probe_args(Dwarf_Die *sc_die, struct probe_finder *pf,\n\t\t\t     struct perf_probe_arg *args)\n{\n\tDwarf_Die die_mem;\n\tint i;\n\tint n = 0;\n\tstruct local_vars_finder vf = {.pf = pf, .args = args, .vars = false,\n\t\t\t\t.max_args = MAX_PROBE_ARGS, .ret = 0};\n\n\tfor (i = 0; i < pf->pev->nargs; i++) {\n\t\t \n\t\tif (strcmp(pf->pev->args[i].var, PROBE_ARG_VARS) == 0)\n\t\t\tvf.vars = true;\n\t\telse if (strcmp(pf->pev->args[i].var, PROBE_ARG_PARAMS) != 0) {\n\t\t\t \n\t\t\targs[n] = pf->pev->args[i];\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\t\tpr_debug(\"Expanding %s into:\", pf->pev->args[i].var);\n\t\tvf.nargs = n;\n\t\t \n\t\tdie_find_child(sc_die, copy_variables_cb, (void *)&vf,\n\t\t\t       &die_mem);\n\t\tpr_debug(\" (%d)\\n\", vf.nargs - n);\n\t\tif (vf.ret < 0)\n\t\t\treturn vf.ret;\n\t\tn = vf.nargs;\n\t}\n\treturn n;\n}\n\nstatic bool trace_event_finder_overlap(struct trace_event_finder *tf)\n{\n\tint i;\n\n\tfor (i = 0; i < tf->ntevs; i++) {\n\t\tif (tf->pf.addr == tf->tevs[i].point.address)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int add_probe_trace_event(Dwarf_Die *sc_die, struct probe_finder *pf)\n{\n\tstruct trace_event_finder *tf =\n\t\t\tcontainer_of(pf, struct trace_event_finder, pf);\n\tstruct perf_probe_point *pp = &pf->pev->point;\n\tstruct probe_trace_event *tev;\n\tstruct perf_probe_arg *args = NULL;\n\tint ret, i;\n\n\t \n\tif (trace_event_finder_overlap(tf))\n\t\treturn 0;\n\n\t \n\tif (tf->ntevs == tf->max_tevs) {\n\t\tpr_warning(\"Too many( > %d) probe point found.\\n\",\n\t\t\t   tf->max_tevs);\n\t\treturn -ERANGE;\n\t}\n\ttev = &tf->tevs[tf->ntevs++];\n\n\t \n\tret = convert_to_trace_point(&pf->sp_die, tf->mod, pf->addr,\n\t\t\t\t     pp->retprobe, pp->function, &tev->point);\n\tif (ret < 0)\n\t\tgoto end;\n\n\ttev->point.realname = strdup(dwarf_diename(sc_die));\n\tif (!tev->point.realname) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tpr_debug(\"Probe point found: %s+%lu\\n\", tev->point.symbol,\n\t\t tev->point.offset);\n\n\t \n\targs = zalloc(sizeof(struct perf_probe_arg) * MAX_PROBE_ARGS);\n\tif (args == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tret = expand_probe_args(sc_die, pf, args);\n\tif (ret < 0)\n\t\tgoto end;\n\n\ttev->nargs = ret;\n\ttev->args = zalloc(sizeof(struct probe_trace_arg) * tev->nargs);\n\tif (tev->args == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\t \n\tfor (i = 0; i < tev->nargs; i++) {\n\t\tpf->pvar = &args[i];\n\t\tpf->tvar = &tev->args[i];\n\t\t \n\t\tret = find_variable(sc_die, pf);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t}\n\nend:\n\tif (ret) {\n\t\tclear_probe_trace_event(tev);\n\t\ttf->ntevs--;\n\t}\n\tfree(args);\n\treturn ret;\n}\n\nstatic int fill_empty_trace_arg(struct perf_probe_event *pev,\n\t\t\t\tstruct probe_trace_event *tevs, int ntevs)\n{\n\tchar **valp;\n\tchar *type;\n\tint i, j, ret;\n\n\tif (!ntevs)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < pev->nargs; i++) {\n\t\ttype = NULL;\n\t\tfor (j = 0; j < ntevs; j++) {\n\t\t\tif (tevs[j].args[i].value) {\n\t\t\t\ttype = tevs[j].args[i].type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == ntevs) {\n\t\t\tprint_var_not_found(pev->args[i].var);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tfor (j = 0; j < ntevs; j++) {\n\t\t\tvalp = &tevs[j].args[i].value;\n\t\t\tif (*valp)\n\t\t\t\tcontinue;\n\n\t\t\tret = asprintf(valp, \"\\\\%lx\", probe_conf.magic_num);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t\t \n\t\t\tif (type) {\n\t\t\t\ttevs[j].args[i].type = strdup(type);\n\t\t\t\tif (!tevs[j].args[i].type)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint debuginfo__find_trace_events(struct debuginfo *dbg,\n\t\t\t\t struct perf_probe_event *pev,\n\t\t\t\t struct probe_trace_event **tevs)\n{\n\tstruct trace_event_finder tf = {\n\t\t\t.pf = {.pev = pev, .dbg = dbg, .callback = add_probe_trace_event},\n\t\t\t.max_tevs = probe_conf.max_probes, .mod = dbg->mod};\n\tint ret, i;\n\n\t \n\t*tevs = zalloc(sizeof(struct probe_trace_event) * tf.max_tevs);\n\tif (*tevs == NULL)\n\t\treturn -ENOMEM;\n\n\ttf.tevs = *tevs;\n\ttf.ntevs = 0;\n\n\tif (pev->nargs != 0 && immediate_value_is_supported())\n\t\ttf.pf.skip_empty_arg = true;\n\n\tret = debuginfo__find_probes(dbg, &tf.pf);\n\tif (ret >= 0 && tf.pf.skip_empty_arg)\n\t\tret = fill_empty_trace_arg(pev, tf.tevs, tf.ntevs);\n\n\tif (ret < 0 || tf.ntevs == 0) {\n\t\tfor (i = 0; i < tf.ntevs; i++)\n\t\t\tclear_probe_trace_event(&tf.tevs[i]);\n\t\tzfree(tevs);\n\t\treturn ret;\n\t}\n\n\treturn (ret < 0) ? ret : tf.ntevs;\n}\n\n \nstatic int collect_variables_cb(Dwarf_Die *die_mem, void *data)\n{\n\tstruct available_var_finder *af = data;\n\tstruct variable_list *vl;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint tag, ret;\n\n\tvl = &af->vls[af->nvls - 1];\n\n\ttag = dwarf_tag(die_mem);\n\tif (tag == DW_TAG_formal_parameter ||\n\t    tag == DW_TAG_variable) {\n\t\tret = convert_variable_location(die_mem, af->pf.addr,\n\t\t\t\t\t\taf->pf.fb_ops, &af->pf.sp_die,\n\t\t\t\t\t\taf->pf.machine, NULL);\n\t\tif (ret == 0 || ret == -ERANGE) {\n\t\t\tint ret2;\n\t\t\tbool externs = !af->child;\n\n\t\t\tif (strbuf_init(&buf, 64) < 0)\n\t\t\t\tgoto error;\n\n\t\t\tif (probe_conf.show_location_range) {\n\t\t\t\tif (!externs)\n\t\t\t\t\tret2 = strbuf_add(&buf,\n\t\t\t\t\t\tret ? \"[INV]\\t\" : \"[VAL]\\t\", 6);\n\t\t\t\telse\n\t\t\t\t\tret2 = strbuf_add(&buf, \"[EXT]\\t\", 6);\n\t\t\t\tif (ret2)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tret2 = die_get_varname(die_mem, &buf);\n\n\t\t\tif (!ret2 && probe_conf.show_location_range &&\n\t\t\t\t!externs) {\n\t\t\t\tif (strbuf_addch(&buf, '\\t') < 0)\n\t\t\t\t\tgoto error;\n\t\t\t\tret2 = die_get_var_range(&af->pf.sp_die,\n\t\t\t\t\t\t\tdie_mem, &buf);\n\t\t\t}\n\n\t\t\tpr_debug(\"Add new var: %s\\n\", buf.buf);\n\t\t\tif (ret2 == 0) {\n\t\t\t\tstrlist__add(vl->vars,\n\t\t\t\t\tstrbuf_detach(&buf, NULL));\n\t\t\t}\n\t\t\tstrbuf_release(&buf);\n\t\t}\n\t}\n\n\tif (af->child && dwarf_haspc(die_mem, af->pf.addr))\n\t\treturn DIE_FIND_CB_CONTINUE;\n\telse\n\t\treturn DIE_FIND_CB_SIBLING;\nerror:\n\tstrbuf_release(&buf);\n\tpr_debug(\"Error in strbuf\\n\");\n\treturn DIE_FIND_CB_END;\n}\n\nstatic bool available_var_finder_overlap(struct available_var_finder *af)\n{\n\tint i;\n\n\tfor (i = 0; i < af->nvls; i++) {\n\t\tif (af->pf.addr == af->vls[i].point.address)\n\t\t\treturn true;\n\t}\n\treturn false;\n\n}\n\n \nstatic int add_available_vars(Dwarf_Die *sc_die, struct probe_finder *pf)\n{\n\tstruct available_var_finder *af =\n\t\t\tcontainer_of(pf, struct available_var_finder, pf);\n\tstruct perf_probe_point *pp = &pf->pev->point;\n\tstruct variable_list *vl;\n\tDwarf_Die die_mem;\n\tint ret;\n\n\t \n\tif (available_var_finder_overlap(af))\n\t\treturn 0;\n\n\t \n\tif (af->nvls == af->max_vls) {\n\t\tpr_warning(\"Too many( > %d) probe point found.\\n\", af->max_vls);\n\t\treturn -ERANGE;\n\t}\n\tvl = &af->vls[af->nvls++];\n\n\t \n\tret = convert_to_trace_point(&pf->sp_die, af->mod, pf->addr,\n\t\t\t\t     pp->retprobe, pp->function, &vl->point);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpr_debug(\"Probe point found: %s+%lu\\n\", vl->point.symbol,\n\t\t vl->point.offset);\n\n\t \n\tvl->vars = strlist__new(NULL, NULL);\n\tif (vl->vars == NULL)\n\t\treturn -ENOMEM;\n\taf->child = true;\n\tdie_find_child(sc_die, collect_variables_cb, (void *)af, &die_mem);\n\n\t \n\tif (!probe_conf.show_ext_vars)\n\t\tgoto out;\n\t \n\taf->child = false;\n\tdie_find_child(&pf->cu_die, collect_variables_cb, (void *)af, &die_mem);\n\nout:\n\tif (strlist__empty(vl->vars)) {\n\t\tstrlist__delete(vl->vars);\n\t\tvl->vars = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nint debuginfo__find_available_vars_at(struct debuginfo *dbg,\n\t\t\t\t      struct perf_probe_event *pev,\n\t\t\t\t      struct variable_list **vls)\n{\n\tstruct available_var_finder af = {\n\t\t\t.pf = {.pev = pev, .dbg = dbg, .callback = add_available_vars},\n\t\t\t.mod = dbg->mod,\n\t\t\t.max_vls = probe_conf.max_probes};\n\tint ret;\n\n\t \n\t*vls = zalloc(sizeof(struct variable_list) * af.max_vls);\n\tif (*vls == NULL)\n\t\treturn -ENOMEM;\n\n\taf.vls = *vls;\n\taf.nvls = 0;\n\n\tret = debuginfo__find_probes(dbg, &af.pf);\n\tif (ret < 0) {\n\t\t \n\t\twhile (af.nvls--) {\n\t\t\tzfree(&af.vls[af.nvls].point.symbol);\n\t\t\tstrlist__delete(af.vls[af.nvls].vars);\n\t\t}\n\t\tzfree(vls);\n\t\treturn ret;\n\t}\n\n\treturn (ret < 0) ? ret : af.nvls;\n}\n\n \nint debuginfo__get_text_offset(struct debuginfo *dbg, Dwarf_Addr *offs,\n\t\t\t\tbool adjust_offset)\n{\n\tint n, i;\n\tElf32_Word shndx;\n\tElf_Scn *scn;\n\tElf *elf;\n\tGElf_Shdr mem, *shdr;\n\tconst char *p;\n\n\telf = dwfl_module_getelf(dbg->mod, &dbg->bias);\n\tif (!elf)\n\t\treturn -EINVAL;\n\n\t \n\tn = dwfl_module_relocations(dbg->mod);\n\tif (n < 0)\n\t\treturn -ENOENT;\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tp = dwfl_module_relocation_info(dbg->mod, i, &shndx);\n\t\tif (strcmp(p, \".text\") == 0) {\n\t\t\t \n\t\t\tscn = elf_getscn(elf, shndx);\n\t\t\tif (!scn)\n\t\t\t\treturn -ENOENT;\n\t\t\tshdr = gelf_getshdr(scn, &mem);\n\t\t\tif (!shdr)\n\t\t\t\treturn -ENOENT;\n\t\t\t*offs = shdr->sh_addr;\n\t\t\tif (adjust_offset)\n\t\t\t\t*offs -= shdr->sh_offset;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint debuginfo__find_probe_point(struct debuginfo *dbg, u64 addr,\n\t\t\t\tstruct perf_probe_point *ppt)\n{\n\tDwarf_Die cudie, spdie, indie;\n\tDwarf_Addr _addr = 0, baseaddr = 0;\n\tconst char *fname = NULL, *func = NULL, *basefunc = NULL, *tmp;\n\tint baseline = 0, lineno = 0, ret = 0;\n\n\t \n\tif (debuginfo__get_text_offset(dbg, &baseaddr, false) == 0)\n\t\taddr += baseaddr;\n\t \n\tif (!dwarf_addrdie(dbg->dbg, (Dwarf_Addr)addr, &cudie)) {\n\t\tpr_warning(\"Failed to find debug information for address %#\" PRIx64 \"\\n\",\n\t\t\t   addr);\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\t \n\tcu_find_lineinfo(&cudie, (Dwarf_Addr)addr, &fname, &lineno);\n\t \n\n\t \n\tif (die_find_realfunc(&cudie, (Dwarf_Addr)addr, &spdie)) {\n\t\t \n\t\tfunc = basefunc = dwarf_diename(&spdie);\n\t\tif (!func ||\n\t\t    die_entrypc(&spdie, &baseaddr) != 0 ||\n\t\t    dwarf_decl_line(&spdie, &baseline) != 0) {\n\t\t\tlineno = 0;\n\t\t\tgoto post;\n\t\t}\n\n\t\tfname = die_get_decl_file(&spdie);\n\t\tif (addr == baseaddr) {\n\t\t\t \n\t\t\tlineno = baseline;\n\t\t\tgoto post;\n\t\t}\n\n\t\t \n\t\twhile (die_find_top_inlinefunc(&spdie, (Dwarf_Addr)addr,\n\t\t\t\t\t\t&indie)) {\n\t\t\t \n\t\t\tif (die_entrypc(&indie, &_addr) == 0 &&\n\t\t\t    _addr == addr) {\n\t\t\t\t \n\t\t\t\tlineno = die_get_call_lineno(&indie);\n\t\t\t\tfname = die_get_call_file(&indie);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttmp = dwarf_diename(&indie);\n\t\t\t\tif (!tmp ||\n\t\t\t\t    dwarf_decl_line(&indie, &baseline) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tfunc = tmp;\n\t\t\t\tspdie = indie;\n\t\t\t}\n\t\t}\n\t\t \n\t\ttmp = die_get_decl_file(&spdie);\n\t\tif (!tmp || (fname && strcmp(tmp, fname) != 0))\n\t\t\tlineno = 0;\n\t}\n\npost:\n\t \n\tif (lineno)\n\t\tppt->line = lineno - baseline;\n\telse if (basefunc) {\n\t\tppt->offset = addr - baseaddr;\n\t\tfunc = basefunc;\n\t}\n\n\t \n\tif (func) {\n\t\tppt->function = strdup(func);\n\t\tif (ppt->function == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto end;\n\t\t}\n\t}\n\tif (fname) {\n\t\tppt->file = strdup(fname);\n\t\tif (ppt->file == NULL) {\n\t\t\tzfree(&ppt->function);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto end;\n\t\t}\n\t}\nend:\n\tif (ret == 0 && (fname || func))\n\t\tret = 1;\t \n\treturn ret;\n}\n\n \nstatic int line_range_add_line(const char *src, unsigned int lineno,\n\t\t\t       struct line_range *lr)\n{\n\t \n\tif (!lr->path) {\n\t\tlr->path = strdup(src);\n\t\tif (lr->path == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn intlist__add(lr->line_list, lineno);\n}\n\nstatic int line_range_walk_cb(const char *fname, int lineno,\n\t\t\t      Dwarf_Addr addr, void *data)\n{\n\tstruct line_finder *lf = data;\n\tconst char *__fname;\n\tint __lineno;\n\tint err;\n\n\tif ((strtailcmp(fname, lf->fname) != 0) ||\n\t    (lf->lno_s > lineno || lf->lno_e < lineno))\n\t\treturn 0;\n\n\t \n\tif (cu_find_lineinfo(&lf->cu_die, addr, &__fname, &__lineno) > 0\n\t    && (lineno != __lineno || strcmp(fname, __fname)))\n\t\treturn 0;\n\n\terr = line_range_add_line(fname, lineno, lf->lr);\n\tif (err < 0 && err != -EEXIST)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int find_line_range_by_line(Dwarf_Die *sp_die, struct line_finder *lf)\n{\n\tint ret;\n\n\tret = die_walk_lines(sp_die ?: &lf->cu_die, line_range_walk_cb, lf);\n\n\t \n\tif (ret >= 0)\n\t\tif (!intlist__empty(lf->lr->line_list))\n\t\t\tret = lf->found = 1;\n\t\telse\n\t\t\tret = 0;\t \n\telse {\n\t\tzfree(&lf->lr->path);\n\t}\n\treturn ret;\n}\n\nstatic int line_range_inline_cb(Dwarf_Die *in_die, void *data)\n{\n\tint ret = find_line_range_by_line(in_die, data);\n\n\t \n\treturn ret < 0 ? ret : 0;\n}\n\n \nstatic int line_range_search_cb(Dwarf_Die *sp_die, void *data)\n{\n\tstruct dwarf_callback_param *param = data;\n\tstruct line_finder *lf = param->data;\n\tstruct line_range *lr = lf->lr;\n\tconst char *fname;\n\n\t \n\tif (lr->file) {\n\t\tfname = die_get_decl_file(sp_die);\n\t\tif (!fname || strtailcmp(lr->file, fname))\n\t\t\treturn DWARF_CB_OK;\n\t}\n\n\tif (die_match_name(sp_die, lr->function) && die_is_func_def(sp_die)) {\n\t\tlf->fname = die_get_decl_file(sp_die);\n\t\tdwarf_decl_line(sp_die, &lr->offset);\n\t\tpr_debug(\"fname: %s, lineno:%d\\n\", lf->fname, lr->offset);\n\t\tlf->lno_s = lr->offset + lr->start;\n\t\tif (lf->lno_s < 0)\t \n\t\t\tlf->lno_s = INT_MAX;\n\t\tlf->lno_e = lr->offset + lr->end;\n\t\tif (lf->lno_e < 0)\t \n\t\t\tlf->lno_e = INT_MAX;\n\t\tpr_debug(\"New line range: %d to %d\\n\", lf->lno_s, lf->lno_e);\n\t\tlr->start = lf->lno_s;\n\t\tlr->end = lf->lno_e;\n\t\tif (!die_is_func_instance(sp_die))\n\t\t\tparam->retval = die_walk_instances(sp_die,\n\t\t\t\t\t\tline_range_inline_cb, lf);\n\t\telse\n\t\t\tparam->retval = find_line_range_by_line(sp_die, lf);\n\t\treturn DWARF_CB_ABORT;\n\t}\n\treturn DWARF_CB_OK;\n}\n\nstatic int find_line_range_by_func(struct line_finder *lf)\n{\n\tstruct dwarf_callback_param param = {.data = (void *)lf, .retval = 0};\n\tdwarf_getfuncs(&lf->cu_die, line_range_search_cb, &param, 0);\n\treturn param.retval;\n}\n\nint debuginfo__find_line_range(struct debuginfo *dbg, struct line_range *lr)\n{\n\tstruct line_finder lf = {.lr = lr, .found = 0};\n\tint ret = 0;\n\tDwarf_Off off = 0, noff;\n\tsize_t cuhl;\n\tDwarf_Die *diep;\n\tconst char *comp_dir;\n\n\t \n\tif (lr->function) {\n\t\tstruct pubname_callback_param pubname_param = {\n\t\t\t.function = lr->function, .file = lr->file,\n\t\t\t.cu_die = &lf.cu_die, .sp_die = &lf.sp_die, .found = 0};\n\t\tstruct dwarf_callback_param line_range_param = {\n\t\t\t.data = (void *)&lf, .retval = 0};\n\n\t\tdwarf_getpubnames(dbg->dbg, pubname_search_cb,\n\t\t\t\t  &pubname_param, 0);\n\t\tif (pubname_param.found) {\n\t\t\tline_range_search_cb(&lf.sp_die, &line_range_param);\n\t\t\tif (lf.found)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\t \n\twhile (!lf.found && ret >= 0) {\n\t\tif (dwarf_nextcu(dbg->dbg, off, &noff, &cuhl,\n\t\t\t\t NULL, NULL, NULL) != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tdiep = dwarf_offdie(dbg->dbg, off + cuhl, &lf.cu_die);\n\t\tif (!diep) {\n\t\t\toff = noff;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (lr->file)\n\t\t\tlf.fname = cu_find_realpath(&lf.cu_die, lr->file);\n\t\telse\n\t\t\tlf.fname = 0;\n\n\t\tif (!lr->file || lf.fname) {\n\t\t\tif (lr->function)\n\t\t\t\tret = find_line_range_by_func(&lf);\n\t\t\telse {\n\t\t\t\tlf.lno_s = lr->start;\n\t\t\t\tlf.lno_e = lr->end;\n\t\t\t\tret = find_line_range_by_line(NULL, &lf);\n\t\t\t}\n\t\t}\n\t\toff = noff;\n\t}\n\nfound:\n\t \n\tif (lf.found) {\n\t\tcomp_dir = cu_get_comp_dir(&lf.cu_die);\n\t\tif (comp_dir) {\n\t\t\tlr->comp_dir = strdup(comp_dir);\n\t\t\tif (!lr->comp_dir)\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t}\n\n\tpr_debug(\"path: %s\\n\", lr->path);\n\treturn (ret < 0) ? ret : lf.found;\n}\n\n#ifdef HAVE_DEBUGINFOD_SUPPORT\n \nstatic int get_source_from_debuginfod(const char *raw_path,\n\t\t\t\tconst char *sbuild_id, char **new_path)\n{\n\tdebuginfod_client *c = debuginfod_begin();\n\tconst char *p = raw_path;\n\tint fd;\n\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\tfd = debuginfod_find_source(c, (const unsigned char *)sbuild_id,\n\t\t\t\t0, p, new_path);\n\tpr_debug(\"Search %s from debuginfod -> %d\\n\", p, fd);\n\tif (fd >= 0)\n\t\tclose(fd);\n\tdebuginfod_end(c);\n\tif (fd < 0) {\n\t\tpr_debug(\"Failed to find %s in debuginfod (%s)\\n\",\n\t\t\traw_path, sbuild_id);\n\t\treturn -ENOENT;\n\t}\n\tpr_debug(\"Got a source %s\\n\", *new_path);\n\n\treturn 0;\n}\n#else\nstatic inline int get_source_from_debuginfod(const char *raw_path __maybe_unused,\n\t\t\t\tconst char *sbuild_id __maybe_unused,\n\t\t\t\tchar **new_path __maybe_unused)\n{\n\treturn -ENOTSUP;\n}\n#endif\n \nint find_source_path(const char *raw_path, const char *sbuild_id,\n\t\tconst char *comp_dir, char **new_path)\n{\n\tconst char *prefix = symbol_conf.source_prefix;\n\n\tif (sbuild_id && !prefix) {\n\t\tif (!get_source_from_debuginfod(raw_path, sbuild_id, new_path))\n\t\t\treturn 0;\n\t}\n\n\tif (!prefix) {\n\t\tif (raw_path[0] != '/' && comp_dir)\n\t\t\t \n\t\t\tprefix = comp_dir;\n\t\telse {\n\t\t\tif (access(raw_path, R_OK) == 0) {\n\t\t\t\t*new_path = strdup(raw_path);\n\t\t\t\treturn *new_path ? 0 : -ENOMEM;\n\t\t\t} else\n\t\t\t\treturn -errno;\n\t\t}\n\t}\n\n\t*new_path = malloc((strlen(prefix) + strlen(raw_path) + 2));\n\tif (!*new_path)\n\t\treturn -ENOMEM;\n\n\tfor (;;) {\n\t\tsprintf(*new_path, \"%s/%s\", prefix, raw_path);\n\n\t\tif (access(*new_path, R_OK) == 0)\n\t\t\treturn 0;\n\n\t\tif (!symbol_conf.source_prefix) {\n\t\t\t \n\t\t\tzfree(new_path);\n\t\t\treturn -errno;\n\t\t}\n\n\t\tswitch (errno) {\n\t\tcase ENAMETOOLONG:\n\t\tcase ENOENT:\n\t\tcase EROFS:\n\t\tcase EFAULT:\n\t\t\traw_path = strchr(++raw_path, '/');\n\t\t\tif (!raw_path) {\n\t\t\t\tzfree(new_path);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tzfree(new_path);\n\t\t\treturn -errno;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}