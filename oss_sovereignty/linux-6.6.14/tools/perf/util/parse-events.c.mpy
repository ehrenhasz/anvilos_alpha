{
  "module_name": "parse-events.c",
  "hash_id": "93164ebda41a5378d16d08920ed0c93b041fac31f0dd8978ecde6e866861af9a",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/parse-events.c",
  "human_readable_source": "\n#include <linux/hw_breakpoint.h>\n#include <linux/err.h>\n#include <linux/list_sort.h>\n#include <linux/zalloc.h>\n#include <dirent.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"term.h\"\n#include \"evlist.h\"\n#include \"evsel.h\"\n#include <subcmd/parse-options.h>\n#include \"parse-events.h\"\n#include \"string2.h\"\n#include \"strbuf.h\"\n#include \"debug.h\"\n#include <api/fs/tracing_path.h>\n#include <perf/cpumap.h>\n#include <util/parse-events-bison.h>\n#include <util/parse-events-flex.h>\n#include \"pmu.h\"\n#include \"pmus.h\"\n#include \"asm/bug.h\"\n#include \"util/parse-branch-options.h\"\n#include \"util/evsel_config.h\"\n#include \"util/event.h\"\n#include \"util/bpf-filter.h\"\n#include \"util/util.h\"\n#include \"tracepoint.h\"\n\n#define MAX_NAME_LEN 100\n\n#ifdef PARSER_DEBUG\nextern int parse_events_debug;\n#endif\nstatic int get_config_terms(struct list_head *head_config,\n\t\t\t    struct list_head *head_terms __maybe_unused);\n\nstruct event_symbol event_symbols_hw[PERF_COUNT_HW_MAX] = {\n\t[PERF_COUNT_HW_CPU_CYCLES] = {\n\t\t.symbol = \"cpu-cycles\",\n\t\t.alias  = \"cycles\",\n\t},\n\t[PERF_COUNT_HW_INSTRUCTIONS] = {\n\t\t.symbol = \"instructions\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_HW_CACHE_REFERENCES] = {\n\t\t.symbol = \"cache-references\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_HW_CACHE_MISSES] = {\n\t\t.symbol = \"cache-misses\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_HW_BRANCH_INSTRUCTIONS] = {\n\t\t.symbol = \"branch-instructions\",\n\t\t.alias  = \"branches\",\n\t},\n\t[PERF_COUNT_HW_BRANCH_MISSES] = {\n\t\t.symbol = \"branch-misses\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_HW_BUS_CYCLES] = {\n\t\t.symbol = \"bus-cycles\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] = {\n\t\t.symbol = \"stalled-cycles-frontend\",\n\t\t.alias  = \"idle-cycles-frontend\",\n\t},\n\t[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] = {\n\t\t.symbol = \"stalled-cycles-backend\",\n\t\t.alias  = \"idle-cycles-backend\",\n\t},\n\t[PERF_COUNT_HW_REF_CPU_CYCLES] = {\n\t\t.symbol = \"ref-cycles\",\n\t\t.alias  = \"\",\n\t},\n};\n\nstruct event_symbol event_symbols_sw[PERF_COUNT_SW_MAX] = {\n\t[PERF_COUNT_SW_CPU_CLOCK] = {\n\t\t.symbol = \"cpu-clock\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_SW_TASK_CLOCK] = {\n\t\t.symbol = \"task-clock\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_SW_PAGE_FAULTS] = {\n\t\t.symbol = \"page-faults\",\n\t\t.alias  = \"faults\",\n\t},\n\t[PERF_COUNT_SW_CONTEXT_SWITCHES] = {\n\t\t.symbol = \"context-switches\",\n\t\t.alias  = \"cs\",\n\t},\n\t[PERF_COUNT_SW_CPU_MIGRATIONS] = {\n\t\t.symbol = \"cpu-migrations\",\n\t\t.alias  = \"migrations\",\n\t},\n\t[PERF_COUNT_SW_PAGE_FAULTS_MIN] = {\n\t\t.symbol = \"minor-faults\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_SW_PAGE_FAULTS_MAJ] = {\n\t\t.symbol = \"major-faults\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_SW_ALIGNMENT_FAULTS] = {\n\t\t.symbol = \"alignment-faults\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_SW_EMULATION_FAULTS] = {\n\t\t.symbol = \"emulation-faults\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_SW_DUMMY] = {\n\t\t.symbol = \"dummy\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_SW_BPF_OUTPUT] = {\n\t\t.symbol = \"bpf-output\",\n\t\t.alias  = \"\",\n\t},\n\t[PERF_COUNT_SW_CGROUP_SWITCHES] = {\n\t\t.symbol = \"cgroup-switches\",\n\t\t.alias  = \"\",\n\t},\n};\n\nconst char *event_type(int type)\n{\n\tswitch (type) {\n\tcase PERF_TYPE_HARDWARE:\n\t\treturn \"hardware\";\n\n\tcase PERF_TYPE_SOFTWARE:\n\t\treturn \"software\";\n\n\tcase PERF_TYPE_TRACEPOINT:\n\t\treturn \"tracepoint\";\n\n\tcase PERF_TYPE_HW_CACHE:\n\t\treturn \"hardware-cache\";\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic char *get_config_str(struct list_head *head_terms, enum parse_events__term_type type_term)\n{\n\tstruct parse_events_term *term;\n\n\tif (!head_terms)\n\t\treturn NULL;\n\n\tlist_for_each_entry(term, head_terms, list)\n\t\tif (term->type_term == type_term)\n\t\t\treturn term->val.str;\n\n\treturn NULL;\n}\n\nstatic char *get_config_metric_id(struct list_head *head_terms)\n{\n\treturn get_config_str(head_terms, PARSE_EVENTS__TERM_TYPE_METRIC_ID);\n}\n\nstatic char *get_config_name(struct list_head *head_terms)\n{\n\treturn get_config_str(head_terms, PARSE_EVENTS__TERM_TYPE_NAME);\n}\n\n \nstatic void fix_raw(struct list_head *config_terms, struct perf_pmu *pmu)\n{\n\tstruct parse_events_term *term;\n\n\tlist_for_each_entry(term, config_terms, list) {\n\t\tu64 num;\n\n\t\tif (term->type_term != PARSE_EVENTS__TERM_TYPE_RAW)\n\t\t\tcontinue;\n\n\t\tif (perf_pmu__have_event(pmu, term->val.str)) {\n\t\t\tzfree(&term->config);\n\t\t\tterm->config = term->val.str;\n\t\t\tterm->type_val = PARSE_EVENTS__TERM_TYPE_NUM;\n\t\t\tterm->type_term = PARSE_EVENTS__TERM_TYPE_USER;\n\t\t\tterm->val.num = 1;\n\t\t\tterm->no_value = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tzfree(&term->config);\n\t\tterm->config = strdup(\"config\");\n\t\terrno = 0;\n\t\tnum = strtoull(term->val.str + 1, NULL, 16);\n\t\tassert(errno == 0);\n\t\tfree(term->val.str);\n\t\tterm->type_val = PARSE_EVENTS__TERM_TYPE_NUM;\n\t\tterm->type_term = PARSE_EVENTS__TERM_TYPE_CONFIG;\n\t\tterm->val.num = num;\n\t\tterm->no_value = false;\n\t}\n}\n\nstatic struct evsel *\n__add_event(struct list_head *list, int *idx,\n\t    struct perf_event_attr *attr,\n\t    bool init_attr,\n\t    const char *name, const char *metric_id, struct perf_pmu *pmu,\n\t    struct list_head *config_terms, bool auto_merge_stats,\n\t    const char *cpu_list)\n{\n\tstruct evsel *evsel;\n\tstruct perf_cpu_map *cpus = pmu ? perf_cpu_map__get(pmu->cpus) :\n\t\t\t       cpu_list ? perf_cpu_map__new(cpu_list) : NULL;\n\n\tif (pmu)\n\t\tperf_pmu__warn_invalid_formats(pmu);\n\n\tif (pmu && (attr->type == PERF_TYPE_RAW || attr->type >= PERF_TYPE_MAX)) {\n\t\tperf_pmu__warn_invalid_config(pmu, attr->config, name,\n\t\t\t\t\t      PERF_PMU_FORMAT_VALUE_CONFIG, \"config\");\n\t\tperf_pmu__warn_invalid_config(pmu, attr->config1, name,\n\t\t\t\t\t      PERF_PMU_FORMAT_VALUE_CONFIG1, \"config1\");\n\t\tperf_pmu__warn_invalid_config(pmu, attr->config2, name,\n\t\t\t\t\t      PERF_PMU_FORMAT_VALUE_CONFIG2, \"config2\");\n\t\tperf_pmu__warn_invalid_config(pmu, attr->config3, name,\n\t\t\t\t\t      PERF_PMU_FORMAT_VALUE_CONFIG3, \"config3\");\n\t}\n\tif (init_attr)\n\t\tevent_attr_init(attr);\n\n\tevsel = evsel__new_idx(attr, *idx);\n\tif (!evsel) {\n\t\tperf_cpu_map__put(cpus);\n\t\treturn NULL;\n\t}\n\n\t(*idx)++;\n\tevsel->core.cpus = cpus;\n\tevsel->core.own_cpus = perf_cpu_map__get(cpus);\n\tevsel->core.requires_cpu = pmu ? pmu->is_uncore : false;\n\tevsel->core.is_pmu_core = pmu ? pmu->is_core : false;\n\tevsel->auto_merge_stats = auto_merge_stats;\n\tevsel->pmu = pmu;\n\tevsel->pmu_name = pmu ? strdup(pmu->name) : NULL;\n\n\tif (name)\n\t\tevsel->name = strdup(name);\n\n\tif (metric_id)\n\t\tevsel->metric_id = strdup(metric_id);\n\n\tif (config_terms)\n\t\tlist_splice_init(config_terms, &evsel->config_terms);\n\n\tif (list)\n\t\tlist_add_tail(&evsel->core.node, list);\n\n\treturn evsel;\n}\n\nstruct evsel *parse_events__add_event(int idx, struct perf_event_attr *attr,\n\t\t\t\t      const char *name, const char *metric_id,\n\t\t\t\t      struct perf_pmu *pmu)\n{\n\treturn __add_event( NULL, &idx, attr,  false, name,\n\t\t\t   metric_id, pmu,  NULL,\n\t\t\t    false,  NULL);\n}\n\nstatic int add_event(struct list_head *list, int *idx,\n\t\t     struct perf_event_attr *attr, const char *name,\n\t\t     const char *metric_id, struct list_head *config_terms)\n{\n\treturn __add_event(list, idx, attr,  true, name, metric_id,\n\t\t\t    NULL, config_terms,\n\t\t\t    false,  NULL) ? 0 : -ENOMEM;\n}\n\nstatic int add_event_tool(struct list_head *list, int *idx,\n\t\t\t  enum perf_tool_event tool_event)\n{\n\tstruct evsel *evsel;\n\tstruct perf_event_attr attr = {\n\t\t.type = PERF_TYPE_SOFTWARE,\n\t\t.config = PERF_COUNT_SW_DUMMY,\n\t};\n\n\tevsel = __add_event(list, idx, &attr,  true,  NULL,\n\t\t\t     NULL,  NULL,\n\t\t\t     NULL,  false,\n\t\t\t     \"0\");\n\tif (!evsel)\n\t\treturn -ENOMEM;\n\tevsel->tool_event = tool_event;\n\tif (tool_event == PERF_TOOL_DURATION_TIME\n\t    || tool_event == PERF_TOOL_USER_TIME\n\t    || tool_event == PERF_TOOL_SYSTEM_TIME) {\n\t\tfree((char *)evsel->unit);\n\t\tevsel->unit = strdup(\"ns\");\n\t}\n\treturn 0;\n}\n\n \nstatic int parse_aliases(const char *str, const char *const names[][EVSEL__MAX_ALIASES], int size,\n\t\t\t int *longest)\n{\n\t*longest = -1;\n\tfor (int i = 0; i < size; i++) {\n\t\tfor (int j = 0; j < EVSEL__MAX_ALIASES && names[i][j]; j++) {\n\t\t\tint n = strlen(names[i][j]);\n\n\t\t\tif (n > *longest && !strncasecmp(str, names[i][j], n))\n\t\t\t\t*longest = n;\n\t\t}\n\t\tif (*longest > 0)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\ntypedef int config_term_func_t(struct perf_event_attr *attr,\n\t\t\t       struct parse_events_term *term,\n\t\t\t       struct parse_events_error *err);\nstatic int config_term_common(struct perf_event_attr *attr,\n\t\t\t      struct parse_events_term *term,\n\t\t\t      struct parse_events_error *err);\nstatic int config_attr(struct perf_event_attr *attr,\n\t\t       struct list_head *head,\n\t\t       struct parse_events_error *err,\n\t\t       config_term_func_t config_term);\n\n \nint parse_events__decode_legacy_cache(const char *name, int extended_pmu_type, __u64 *config)\n{\n\tint len, cache_type = -1, cache_op = -1, cache_result = -1;\n\tconst char *name_end = &name[strlen(name) + 1];\n\tconst char *str = name;\n\n\tcache_type = parse_aliases(str, evsel__hw_cache, PERF_COUNT_HW_CACHE_MAX, &len);\n\tif (cache_type == -1)\n\t\treturn -EINVAL;\n\tstr += len + 1;\n\n\tif (str < name_end) {\n\t\tcache_op = parse_aliases(str, evsel__hw_cache_op,\n\t\t\t\t\tPERF_COUNT_HW_CACHE_OP_MAX, &len);\n\t\tif (cache_op >= 0) {\n\t\t\tif (!evsel__is_cache_op_valid(cache_type, cache_op))\n\t\t\t\treturn -EINVAL;\n\t\t\tstr += len + 1;\n\t\t} else {\n\t\t\tcache_result = parse_aliases(str, evsel__hw_cache_result,\n\t\t\t\t\t\tPERF_COUNT_HW_CACHE_RESULT_MAX, &len);\n\t\t\tif (cache_result >= 0)\n\t\t\t\tstr += len + 1;\n\t\t}\n\t}\n\tif (str < name_end) {\n\t\tif (cache_op < 0) {\n\t\t\tcache_op = parse_aliases(str, evsel__hw_cache_op,\n\t\t\t\t\t\tPERF_COUNT_HW_CACHE_OP_MAX, &len);\n\t\t\tif (cache_op >= 0) {\n\t\t\t\tif (!evsel__is_cache_op_valid(cache_type, cache_op))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (cache_result < 0) {\n\t\t\tcache_result = parse_aliases(str, evsel__hw_cache_result,\n\t\t\t\t\t\tPERF_COUNT_HW_CACHE_RESULT_MAX, &len);\n\t\t}\n\t}\n\n\t \n\tif (cache_op == -1)\n\t\tcache_op = PERF_COUNT_HW_CACHE_OP_READ;\n\n\t \n\tif (cache_result == -1)\n\t\tcache_result = PERF_COUNT_HW_CACHE_RESULT_ACCESS;\n\n\t*config = cache_type | (cache_op << 8) | (cache_result << 16);\n\tif (perf_pmus__supports_extended_type())\n\t\t*config |= (__u64)extended_pmu_type << PERF_PMU_TYPE_SHIFT;\n\treturn 0;\n}\n\n \nbool parse_events__filter_pmu(const struct parse_events_state *parse_state,\n\t\t\t      const struct perf_pmu *pmu)\n{\n\tif (parse_state->pmu_filter == NULL)\n\t\treturn false;\n\n\treturn strcmp(parse_state->pmu_filter, pmu->name) != 0;\n}\n\nint parse_events_add_cache(struct list_head *list, int *idx, const char *name,\n\t\t\t   struct parse_events_state *parse_state,\n\t\t\t   struct list_head *head_config)\n{\n\tstruct perf_pmu *pmu = NULL;\n\tbool found_supported = false;\n\tconst char *config_name = get_config_name(head_config);\n\tconst char *metric_id = get_config_metric_id(head_config);\n\n\t \n\twhile ((pmu = perf_pmus__scan_core(pmu)) != NULL) {\n\t\tLIST_HEAD(config_terms);\n\t\tstruct perf_event_attr attr;\n\t\tint ret;\n\n\t\tif (parse_events__filter_pmu(parse_state, pmu))\n\t\t\tcontinue;\n\n\t\tmemset(&attr, 0, sizeof(attr));\n\t\tattr.type = PERF_TYPE_HW_CACHE;\n\n\t\tret = parse_events__decode_legacy_cache(name, pmu->type, &attr.config);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfound_supported = true;\n\n\t\tif (head_config) {\n\t\t\tif (config_attr(&attr, head_config, parse_state->error, config_term_common))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (get_config_terms(head_config, &config_terms))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (__add_event(list, idx, &attr,  true, config_name ?: name,\n\t\t\t\tmetric_id, pmu, &config_terms,  false,\n\t\t\t\t NULL) == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tfree_config_terms(&config_terms);\n\t}\n\treturn found_supported ? 0 : -EINVAL;\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic void tracepoint_error(struct parse_events_error *e, int err,\n\t\t\t     const char *sys, const char *name, int column)\n{\n\tconst char *str;\n\tchar help[BUFSIZ];\n\n\tif (!e)\n\t\treturn;\n\n\t \n\terr = abs(err);\n\n\tswitch (err) {\n\tcase EACCES:\n\t\tstr = \"can't access trace events\";\n\t\tbreak;\n\tcase ENOENT:\n\t\tstr = \"unknown tracepoint\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"failed to add tracepoint\";\n\t\tbreak;\n\t}\n\n\ttracing_path__strerror_open_tp(err, help, sizeof(help), sys, name);\n\tparse_events_error__handle(e, column, strdup(str), strdup(help));\n}\n\nstatic int add_tracepoint(struct list_head *list, int *idx,\n\t\t\t  const char *sys_name, const char *evt_name,\n\t\t\t  struct parse_events_error *err,\n\t\t\t  struct list_head *head_config, void *loc_)\n{\n\tYYLTYPE *loc = loc_;\n\tstruct evsel *evsel = evsel__newtp_idx(sys_name, evt_name, (*idx)++);\n\n\tif (IS_ERR(evsel)) {\n\t\ttracepoint_error(err, PTR_ERR(evsel), sys_name, evt_name, loc->first_column);\n\t\treturn PTR_ERR(evsel);\n\t}\n\n\tif (head_config) {\n\t\tLIST_HEAD(config_terms);\n\n\t\tif (get_config_terms(head_config, &config_terms))\n\t\t\treturn -ENOMEM;\n\t\tlist_splice(&config_terms, &evsel->config_terms);\n\t}\n\n\tlist_add_tail(&evsel->core.node, list);\n\treturn 0;\n}\n\nstatic int add_tracepoint_multi_event(struct list_head *list, int *idx,\n\t\t\t\t      const char *sys_name, const char *evt_name,\n\t\t\t\t      struct parse_events_error *err,\n\t\t\t\t      struct list_head *head_config, YYLTYPE *loc)\n{\n\tchar *evt_path;\n\tstruct dirent *evt_ent;\n\tDIR *evt_dir;\n\tint ret = 0, found = 0;\n\n\tevt_path = get_events_file(sys_name);\n\tif (!evt_path) {\n\t\ttracepoint_error(err, errno, sys_name, evt_name, loc->first_column);\n\t\treturn -1;\n\t}\n\tevt_dir = opendir(evt_path);\n\tif (!evt_dir) {\n\t\tput_events_file(evt_path);\n\t\ttracepoint_error(err, errno, sys_name, evt_name, loc->first_column);\n\t\treturn -1;\n\t}\n\n\twhile (!ret && (evt_ent = readdir(evt_dir))) {\n\t\tif (!strcmp(evt_ent->d_name, \".\")\n\t\t    || !strcmp(evt_ent->d_name, \"..\")\n\t\t    || !strcmp(evt_ent->d_name, \"enable\")\n\t\t    || !strcmp(evt_ent->d_name, \"filter\"))\n\t\t\tcontinue;\n\n\t\tif (!strglobmatch(evt_ent->d_name, evt_name))\n\t\t\tcontinue;\n\n\t\tfound++;\n\n\t\tret = add_tracepoint(list, idx, sys_name, evt_ent->d_name,\n\t\t\t\t     err, head_config, loc);\n\t}\n\n\tif (!found) {\n\t\ttracepoint_error(err, ENOENT, sys_name, evt_name, loc->first_column);\n\t\tret = -1;\n\t}\n\n\tput_events_file(evt_path);\n\tclosedir(evt_dir);\n\treturn ret;\n}\n\nstatic int add_tracepoint_event(struct list_head *list, int *idx,\n\t\t\t\tconst char *sys_name, const char *evt_name,\n\t\t\t\tstruct parse_events_error *err,\n\t\t\t\tstruct list_head *head_config, YYLTYPE *loc)\n{\n\treturn strpbrk(evt_name, \"*?\") ?\n\t\tadd_tracepoint_multi_event(list, idx, sys_name, evt_name,\n\t\t\t\t\t   err, head_config, loc) :\n\t\tadd_tracepoint(list, idx, sys_name, evt_name,\n\t\t\t       err, head_config, loc);\n}\n\nstatic int add_tracepoint_multi_sys(struct list_head *list, int *idx,\n\t\t\t\t    const char *sys_name, const char *evt_name,\n\t\t\t\t    struct parse_events_error *err,\n\t\t\t\t    struct list_head *head_config, YYLTYPE *loc)\n{\n\tstruct dirent *events_ent;\n\tDIR *events_dir;\n\tint ret = 0;\n\n\tevents_dir = tracing_events__opendir();\n\tif (!events_dir) {\n\t\ttracepoint_error(err, errno, sys_name, evt_name, loc->first_column);\n\t\treturn -1;\n\t}\n\n\twhile (!ret && (events_ent = readdir(events_dir))) {\n\t\tif (!strcmp(events_ent->d_name, \".\")\n\t\t    || !strcmp(events_ent->d_name, \"..\")\n\t\t    || !strcmp(events_ent->d_name, \"enable\")\n\t\t    || !strcmp(events_ent->d_name, \"header_event\")\n\t\t    || !strcmp(events_ent->d_name, \"header_page\"))\n\t\t\tcontinue;\n\n\t\tif (!strglobmatch(events_ent->d_name, sys_name))\n\t\t\tcontinue;\n\n\t\tret = add_tracepoint_event(list, idx, events_ent->d_name,\n\t\t\t\t\t   evt_name, err, head_config, loc);\n\t}\n\n\tclosedir(events_dir);\n\treturn ret;\n}\n#endif  \n\nstatic int\nparse_breakpoint_type(const char *type, struct perf_event_attr *attr)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!type || !type[i])\n\t\t\tbreak;\n\n#define CHECK_SET_TYPE(bit)\t\t\\\ndo {\t\t\t\t\t\\\n\tif (attr->bp_type & bit)\t\\\n\t\treturn -EINVAL;\t\t\\\n\telse\t\t\t\t\\\n\t\tattr->bp_type |= bit;\t\\\n} while (0)\n\n\t\tswitch (type[i]) {\n\t\tcase 'r':\n\t\t\tCHECK_SET_TYPE(HW_BREAKPOINT_R);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tCHECK_SET_TYPE(HW_BREAKPOINT_W);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tCHECK_SET_TYPE(HW_BREAKPOINT_X);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n#undef CHECK_SET_TYPE\n\n\tif (!attr->bp_type)  \n\t\tattr->bp_type = HW_BREAKPOINT_R | HW_BREAKPOINT_W;\n\n\treturn 0;\n}\n\nint parse_events_add_breakpoint(struct parse_events_state *parse_state,\n\t\t\t\tstruct list_head *list,\n\t\t\t\tu64 addr, char *type, u64 len,\n\t\t\t\tstruct list_head *head_config __maybe_unused)\n{\n\tstruct perf_event_attr attr;\n\tLIST_HEAD(config_terms);\n\tconst char *name;\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.bp_addr = addr;\n\n\tif (parse_breakpoint_type(type, &attr))\n\t\treturn -EINVAL;\n\n\t \n\tif (!len) {\n\t\tif (attr.bp_type == HW_BREAKPOINT_X)\n\t\t\tlen = sizeof(long);\n\t\telse\n\t\t\tlen = HW_BREAKPOINT_LEN_4;\n\t}\n\n\tattr.bp_len = len;\n\n\tattr.type = PERF_TYPE_BREAKPOINT;\n\tattr.sample_period = 1;\n\n\tif (head_config) {\n\t\tif (config_attr(&attr, head_config, parse_state->error,\n\t\t\t\tconfig_term_common))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_config_terms(head_config, &config_terms))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = get_config_name(head_config);\n\n\treturn add_event(list, &parse_state->idx, &attr, name,  NULL,\n\t\t\t &config_terms);\n}\n\nstatic int check_type_val(struct parse_events_term *term,\n\t\t\t  struct parse_events_error *err,\n\t\t\t  enum parse_events__term_val_type type)\n{\n\tif (type == term->type_val)\n\t\treturn 0;\n\n\tif (err) {\n\t\tparse_events_error__handle(err, term->err_val,\n\t\t\t\t\ttype == PARSE_EVENTS__TERM_TYPE_NUM\n\t\t\t\t\t? strdup(\"expected numeric value\")\n\t\t\t\t\t: strdup(\"expected string value\"),\n\t\t\t\t\tNULL);\n\t}\n\treturn -EINVAL;\n}\n\nstatic bool config_term_shrinked;\n\nstatic const char *config_term_name(enum parse_events__term_type term_type)\n{\n\t \n\tstatic const char *config_term_names[__PARSE_EVENTS__TERM_TYPE_NR] = {\n\t\t[PARSE_EVENTS__TERM_TYPE_USER]\t\t\t= \"<sysfs term>\",\n\t\t[PARSE_EVENTS__TERM_TYPE_CONFIG]\t\t= \"config\",\n\t\t[PARSE_EVENTS__TERM_TYPE_CONFIG1]\t\t= \"config1\",\n\t\t[PARSE_EVENTS__TERM_TYPE_CONFIG2]\t\t= \"config2\",\n\t\t[PARSE_EVENTS__TERM_TYPE_CONFIG3]\t\t= \"config3\",\n\t\t[PARSE_EVENTS__TERM_TYPE_NAME]\t\t\t= \"name\",\n\t\t[PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD]\t\t= \"period\",\n\t\t[PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ]\t\t= \"freq\",\n\t\t[PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE]\t= \"branch_type\",\n\t\t[PARSE_EVENTS__TERM_TYPE_TIME]\t\t\t= \"time\",\n\t\t[PARSE_EVENTS__TERM_TYPE_CALLGRAPH]\t\t= \"call-graph\",\n\t\t[PARSE_EVENTS__TERM_TYPE_STACKSIZE]\t\t= \"stack-size\",\n\t\t[PARSE_EVENTS__TERM_TYPE_NOINHERIT]\t\t= \"no-inherit\",\n\t\t[PARSE_EVENTS__TERM_TYPE_INHERIT]\t\t= \"inherit\",\n\t\t[PARSE_EVENTS__TERM_TYPE_MAX_STACK]\t\t= \"max-stack\",\n\t\t[PARSE_EVENTS__TERM_TYPE_MAX_EVENTS]\t\t= \"nr\",\n\t\t[PARSE_EVENTS__TERM_TYPE_OVERWRITE]\t\t= \"overwrite\",\n\t\t[PARSE_EVENTS__TERM_TYPE_NOOVERWRITE]\t\t= \"no-overwrite\",\n\t\t[PARSE_EVENTS__TERM_TYPE_DRV_CFG]\t\t= \"driver-config\",\n\t\t[PARSE_EVENTS__TERM_TYPE_PERCORE]\t\t= \"percore\",\n\t\t[PARSE_EVENTS__TERM_TYPE_AUX_OUTPUT]\t\t= \"aux-output\",\n\t\t[PARSE_EVENTS__TERM_TYPE_AUX_SAMPLE_SIZE]\t= \"aux-sample-size\",\n\t\t[PARSE_EVENTS__TERM_TYPE_METRIC_ID]\t\t= \"metric-id\",\n\t\t[PARSE_EVENTS__TERM_TYPE_RAW]                   = \"raw\",\n\t\t[PARSE_EVENTS__TERM_TYPE_LEGACY_CACHE]          = \"legacy-cache\",\n\t\t[PARSE_EVENTS__TERM_TYPE_HARDWARE]              = \"hardware\",\n\t};\n\tif ((unsigned int)term_type >= __PARSE_EVENTS__TERM_TYPE_NR)\n\t\treturn \"unknown term\";\n\n\treturn config_term_names[term_type];\n}\n\nstatic bool\nconfig_term_avail(enum parse_events__term_type term_type, struct parse_events_error *err)\n{\n\tchar *err_str;\n\n\tif (term_type < 0 || term_type >= __PARSE_EVENTS__TERM_TYPE_NR) {\n\t\tparse_events_error__handle(err, -1,\n\t\t\t\t\tstrdup(\"Invalid term_type\"), NULL);\n\t\treturn false;\n\t}\n\tif (!config_term_shrinked)\n\t\treturn true;\n\n\tswitch (term_type) {\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG:\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG1:\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG2:\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG3:\n\tcase PARSE_EVENTS__TERM_TYPE_NAME:\n\tcase PARSE_EVENTS__TERM_TYPE_METRIC_ID:\n\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD:\n\tcase PARSE_EVENTS__TERM_TYPE_PERCORE:\n\t\treturn true;\n\tcase PARSE_EVENTS__TERM_TYPE_USER:\n\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ:\n\tcase PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE:\n\tcase PARSE_EVENTS__TERM_TYPE_TIME:\n\tcase PARSE_EVENTS__TERM_TYPE_CALLGRAPH:\n\tcase PARSE_EVENTS__TERM_TYPE_STACKSIZE:\n\tcase PARSE_EVENTS__TERM_TYPE_NOINHERIT:\n\tcase PARSE_EVENTS__TERM_TYPE_INHERIT:\n\tcase PARSE_EVENTS__TERM_TYPE_MAX_STACK:\n\tcase PARSE_EVENTS__TERM_TYPE_MAX_EVENTS:\n\tcase PARSE_EVENTS__TERM_TYPE_NOOVERWRITE:\n\tcase PARSE_EVENTS__TERM_TYPE_OVERWRITE:\n\tcase PARSE_EVENTS__TERM_TYPE_DRV_CFG:\n\tcase PARSE_EVENTS__TERM_TYPE_AUX_OUTPUT:\n\tcase PARSE_EVENTS__TERM_TYPE_AUX_SAMPLE_SIZE:\n\tcase PARSE_EVENTS__TERM_TYPE_RAW:\n\tcase PARSE_EVENTS__TERM_TYPE_LEGACY_CACHE:\n\tcase PARSE_EVENTS__TERM_TYPE_HARDWARE:\n\tdefault:\n\t\tif (!err)\n\t\t\treturn false;\n\n\t\t \n\t\tif (asprintf(&err_str, \"'%s' is not usable in 'perf stat'\",\n\t\t\t     config_term_name(term_type)) >= 0)\n\t\t\tparse_events_error__handle(err, -1, err_str, NULL);\n\t\treturn false;\n\t}\n}\n\nvoid parse_events__shrink_config_terms(void)\n{\n\tconfig_term_shrinked = true;\n}\n\nstatic int config_term_common(struct perf_event_attr *attr,\n\t\t\t      struct parse_events_term *term,\n\t\t\t      struct parse_events_error *err)\n{\n#define CHECK_TYPE_VAL(type)\t\t\t\t\t\t   \\\ndo {\t\t\t\t\t\t\t\t\t   \\\n\tif (check_type_val(term, err, PARSE_EVENTS__TERM_TYPE_ ## type)) \\\n\t\treturn -EINVAL;\t\t\t\t\t\t   \\\n} while (0)\n\n\tswitch (term->type_term) {\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tattr->config = term->val.num;\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG1:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tattr->config1 = term->val.num;\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG2:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tattr->config2 = term->val.num;\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG3:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tattr->config3 = term->val.num;\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE:\n\t\tCHECK_TYPE_VAL(STR);\n\t\tif (strcmp(term->val.str, \"no\") &&\n\t\t    parse_branch_str(term->val.str,\n\t\t\t\t    &attr->branch_sample_type)) {\n\t\t\tparse_events_error__handle(err, term->err_val,\n\t\t\t\t\tstrdup(\"invalid branch sample type\"),\n\t\t\t\t\tNULL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_TIME:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tif (term->val.num > 1) {\n\t\t\tparse_events_error__handle(err, term->err_val,\n\t\t\t\t\t\tstrdup(\"expected 0 or 1\"),\n\t\t\t\t\t\tNULL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_CALLGRAPH:\n\t\tCHECK_TYPE_VAL(STR);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_STACKSIZE:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_INHERIT:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_NOINHERIT:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_OVERWRITE:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_NOOVERWRITE:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_NAME:\n\t\tCHECK_TYPE_VAL(STR);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_METRIC_ID:\n\t\tCHECK_TYPE_VAL(STR);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_RAW:\n\t\tCHECK_TYPE_VAL(STR);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_MAX_STACK:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_MAX_EVENTS:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_PERCORE:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tif ((unsigned int)term->val.num > 1) {\n\t\t\tparse_events_error__handle(err, term->err_val,\n\t\t\t\t\t\tstrdup(\"expected 0 or 1\"),\n\t\t\t\t\t\tNULL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_AUX_OUTPUT:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_AUX_SAMPLE_SIZE:\n\t\tCHECK_TYPE_VAL(NUM);\n\t\tif (term->val.num > UINT_MAX) {\n\t\t\tparse_events_error__handle(err, term->err_val,\n\t\t\t\t\t\tstrdup(\"too big\"),\n\t\t\t\t\t\tNULL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_DRV_CFG:\n\tcase PARSE_EVENTS__TERM_TYPE_USER:\n\tcase PARSE_EVENTS__TERM_TYPE_LEGACY_CACHE:\n\tcase PARSE_EVENTS__TERM_TYPE_HARDWARE:\n\tdefault:\n\t\tparse_events_error__handle(err, term->err_term,\n\t\t\t\t\tstrdup(config_term_name(term->type_term)),\n\t\t\t\t\tparse_events_formats_error_string(NULL));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!config_term_avail(term->type_term, err))\n\t\treturn -EINVAL;\n\treturn 0;\n#undef CHECK_TYPE_VAL\n}\n\nstatic int config_term_pmu(struct perf_event_attr *attr,\n\t\t\t   struct parse_events_term *term,\n\t\t\t   struct parse_events_error *err)\n{\n\tif (term->type_term == PARSE_EVENTS__TERM_TYPE_LEGACY_CACHE) {\n\t\tconst struct perf_pmu *pmu = perf_pmus__find_by_type(attr->type);\n\n\t\tif (!pmu) {\n\t\t\tchar *err_str;\n\n\t\t\tif (asprintf(&err_str, \"Failed to find PMU for type %d\", attr->type) >= 0)\n\t\t\t\tparse_events_error__handle(err, term->err_term,\n\t\t\t\t\t\t\t   err_str,  NULL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (perf_pmu__supports_legacy_cache(pmu)) {\n\t\t\tattr->type = PERF_TYPE_HW_CACHE;\n\t\t\treturn parse_events__decode_legacy_cache(term->config, pmu->type,\n\t\t\t\t\t\t\t\t &attr->config);\n\t\t} else\n\t\t\tterm->type_term = PARSE_EVENTS__TERM_TYPE_USER;\n\t}\n\tif (term->type_term == PARSE_EVENTS__TERM_TYPE_HARDWARE) {\n\t\tconst struct perf_pmu *pmu = perf_pmus__find_by_type(attr->type);\n\n\t\tif (!pmu) {\n\t\t\tchar *err_str;\n\n\t\t\tif (asprintf(&err_str, \"Failed to find PMU for type %d\", attr->type) >= 0)\n\t\t\t\tparse_events_error__handle(err, term->err_term,\n\t\t\t\t\t\t\t   err_str,  NULL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tattr->type = PERF_TYPE_HARDWARE;\n\t\tattr->config = term->val.num;\n\t\tif (perf_pmus__supports_extended_type())\n\t\t\tattr->config |= (__u64)pmu->type << PERF_PMU_TYPE_SHIFT;\n\t\treturn 0;\n\t}\n\tif (term->type_term == PARSE_EVENTS__TERM_TYPE_USER ||\n\t    term->type_term == PARSE_EVENTS__TERM_TYPE_DRV_CFG) {\n\t\t \n\t\treturn 0;\n\t}\n\treturn config_term_common(attr, term, err);\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nstatic int config_term_tracepoint(struct perf_event_attr *attr,\n\t\t\t\t  struct parse_events_term *term,\n\t\t\t\t  struct parse_events_error *err)\n{\n\tswitch (term->type_term) {\n\tcase PARSE_EVENTS__TERM_TYPE_CALLGRAPH:\n\tcase PARSE_EVENTS__TERM_TYPE_STACKSIZE:\n\tcase PARSE_EVENTS__TERM_TYPE_INHERIT:\n\tcase PARSE_EVENTS__TERM_TYPE_NOINHERIT:\n\tcase PARSE_EVENTS__TERM_TYPE_MAX_STACK:\n\tcase PARSE_EVENTS__TERM_TYPE_MAX_EVENTS:\n\tcase PARSE_EVENTS__TERM_TYPE_OVERWRITE:\n\tcase PARSE_EVENTS__TERM_TYPE_NOOVERWRITE:\n\tcase PARSE_EVENTS__TERM_TYPE_AUX_OUTPUT:\n\tcase PARSE_EVENTS__TERM_TYPE_AUX_SAMPLE_SIZE:\n\t\treturn config_term_common(attr, term, err);\n\tcase PARSE_EVENTS__TERM_TYPE_USER:\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG:\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG1:\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG2:\n\tcase PARSE_EVENTS__TERM_TYPE_CONFIG3:\n\tcase PARSE_EVENTS__TERM_TYPE_NAME:\n\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD:\n\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ:\n\tcase PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE:\n\tcase PARSE_EVENTS__TERM_TYPE_TIME:\n\tcase PARSE_EVENTS__TERM_TYPE_DRV_CFG:\n\tcase PARSE_EVENTS__TERM_TYPE_PERCORE:\n\tcase PARSE_EVENTS__TERM_TYPE_METRIC_ID:\n\tcase PARSE_EVENTS__TERM_TYPE_RAW:\n\tcase PARSE_EVENTS__TERM_TYPE_LEGACY_CACHE:\n\tcase PARSE_EVENTS__TERM_TYPE_HARDWARE:\n\tdefault:\n\t\tif (err) {\n\t\t\tparse_events_error__handle(err, term->err_term,\n\t\t\t\t\t\t   strdup(config_term_name(term->type_term)),\n\t\t\t\tstrdup(\"valid terms: call-graph,stack-size\\n\"));\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int config_attr(struct perf_event_attr *attr,\n\t\t       struct list_head *head,\n\t\t       struct parse_events_error *err,\n\t\t       config_term_func_t config_term)\n{\n\tstruct parse_events_term *term;\n\n\tlist_for_each_entry(term, head, list)\n\t\tif (config_term(attr, term, err))\n\t\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int get_config_terms(struct list_head *head_config,\n\t\t\t    struct list_head *head_terms __maybe_unused)\n{\n#define ADD_CONFIG_TERM(__type, __weak)\t\t\t\t\\\n\tstruct evsel_config_term *__t;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t__t = zalloc(sizeof(*__t));\t\t\t\t\\\n\tif (!__t)\t\t\t\t\t\t\\\n\t\treturn -ENOMEM;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tINIT_LIST_HEAD(&__t->list);\t\t\t\t\\\n\t__t->type       = EVSEL__CONFIG_TERM_ ## __type;\t\\\n\t__t->weak\t= __weak;\t\t\t\t\\\n\tlist_add_tail(&__t->list, head_terms)\n\n#define ADD_CONFIG_TERM_VAL(__type, __name, __val, __weak)\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tADD_CONFIG_TERM(__type, __weak);\t\t\t\\\n\t__t->val.__name = __val;\t\t\t\t\\\n} while (0)\n\n#define ADD_CONFIG_TERM_STR(__type, __val, __weak)\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tADD_CONFIG_TERM(__type, __weak);\t\t\t\\\n\t__t->val.str = strdup(__val);\t\t\t\t\\\n\tif (!__t->val.str) {\t\t\t\t\t\\\n\t\tzfree(&__t);\t\t\t\t\t\\\n\t\treturn -ENOMEM;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t__t->free_str = true;\t\t\t\t\t\\\n} while (0)\n\n\tstruct parse_events_term *term;\n\n\tlist_for_each_entry(term, head_config, list) {\n\t\tswitch (term->type_term) {\n\t\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD:\n\t\t\tADD_CONFIG_TERM_VAL(PERIOD, period, term->val.num, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ:\n\t\t\tADD_CONFIG_TERM_VAL(FREQ, freq, term->val.num, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_TIME:\n\t\t\tADD_CONFIG_TERM_VAL(TIME, time, term->val.num, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_CALLGRAPH:\n\t\t\tADD_CONFIG_TERM_STR(CALLGRAPH, term->val.str, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE:\n\t\t\tADD_CONFIG_TERM_STR(BRANCH, term->val.str, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_STACKSIZE:\n\t\t\tADD_CONFIG_TERM_VAL(STACK_USER, stack_user,\n\t\t\t\t\t    term->val.num, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_INHERIT:\n\t\t\tADD_CONFIG_TERM_VAL(INHERIT, inherit,\n\t\t\t\t\t    term->val.num ? 1 : 0, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_NOINHERIT:\n\t\t\tADD_CONFIG_TERM_VAL(INHERIT, inherit,\n\t\t\t\t\t    term->val.num ? 0 : 1, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_MAX_STACK:\n\t\t\tADD_CONFIG_TERM_VAL(MAX_STACK, max_stack,\n\t\t\t\t\t    term->val.num, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_MAX_EVENTS:\n\t\t\tADD_CONFIG_TERM_VAL(MAX_EVENTS, max_events,\n\t\t\t\t\t    term->val.num, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_OVERWRITE:\n\t\t\tADD_CONFIG_TERM_VAL(OVERWRITE, overwrite,\n\t\t\t\t\t    term->val.num ? 1 : 0, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_NOOVERWRITE:\n\t\t\tADD_CONFIG_TERM_VAL(OVERWRITE, overwrite,\n\t\t\t\t\t    term->val.num ? 0 : 1, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_DRV_CFG:\n\t\t\tADD_CONFIG_TERM_STR(DRV_CFG, term->val.str, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_PERCORE:\n\t\t\tADD_CONFIG_TERM_VAL(PERCORE, percore,\n\t\t\t\t\t    term->val.num ? true : false, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_AUX_OUTPUT:\n\t\t\tADD_CONFIG_TERM_VAL(AUX_OUTPUT, aux_output,\n\t\t\t\t\t    term->val.num ? 1 : 0, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_AUX_SAMPLE_SIZE:\n\t\t\tADD_CONFIG_TERM_VAL(AUX_SAMPLE_SIZE, aux_sample_size,\n\t\t\t\t\t    term->val.num, term->weak);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_USER:\n\t\tcase PARSE_EVENTS__TERM_TYPE_CONFIG:\n\t\tcase PARSE_EVENTS__TERM_TYPE_CONFIG1:\n\t\tcase PARSE_EVENTS__TERM_TYPE_CONFIG2:\n\t\tcase PARSE_EVENTS__TERM_TYPE_CONFIG3:\n\t\tcase PARSE_EVENTS__TERM_TYPE_NAME:\n\t\tcase PARSE_EVENTS__TERM_TYPE_METRIC_ID:\n\t\tcase PARSE_EVENTS__TERM_TYPE_RAW:\n\t\tcase PARSE_EVENTS__TERM_TYPE_LEGACY_CACHE:\n\t\tcase PARSE_EVENTS__TERM_TYPE_HARDWARE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int get_config_chgs(struct perf_pmu *pmu, struct list_head *head_config,\n\t\t\t   struct list_head *head_terms)\n{\n\tstruct parse_events_term *term;\n\tu64 bits = 0;\n\tint type;\n\n\tlist_for_each_entry(term, head_config, list) {\n\t\tswitch (term->type_term) {\n\t\tcase PARSE_EVENTS__TERM_TYPE_USER:\n\t\t\ttype = perf_pmu__format_type(pmu, term->config);\n\t\t\tif (type != PERF_PMU_FORMAT_VALUE_CONFIG)\n\t\t\t\tcontinue;\n\t\t\tbits |= perf_pmu__format_bits(pmu, term->config);\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_CONFIG:\n\t\t\tbits = ~(u64)0;\n\t\t\tbreak;\n\t\tcase PARSE_EVENTS__TERM_TYPE_CONFIG1:\n\t\tcase PARSE_EVENTS__TERM_TYPE_CONFIG2:\n\t\tcase PARSE_EVENTS__TERM_TYPE_CONFIG3:\n\t\tcase PARSE_EVENTS__TERM_TYPE_NAME:\n\t\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD:\n\t\tcase PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ:\n\t\tcase PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE:\n\t\tcase PARSE_EVENTS__TERM_TYPE_TIME:\n\t\tcase PARSE_EVENTS__TERM_TYPE_CALLGRAPH:\n\t\tcase PARSE_EVENTS__TERM_TYPE_STACKSIZE:\n\t\tcase PARSE_EVENTS__TERM_TYPE_NOINHERIT:\n\t\tcase PARSE_EVENTS__TERM_TYPE_INHERIT:\n\t\tcase PARSE_EVENTS__TERM_TYPE_MAX_STACK:\n\t\tcase PARSE_EVENTS__TERM_TYPE_MAX_EVENTS:\n\t\tcase PARSE_EVENTS__TERM_TYPE_NOOVERWRITE:\n\t\tcase PARSE_EVENTS__TERM_TYPE_OVERWRITE:\n\t\tcase PARSE_EVENTS__TERM_TYPE_DRV_CFG:\n\t\tcase PARSE_EVENTS__TERM_TYPE_PERCORE:\n\t\tcase PARSE_EVENTS__TERM_TYPE_AUX_OUTPUT:\n\t\tcase PARSE_EVENTS__TERM_TYPE_AUX_SAMPLE_SIZE:\n\t\tcase PARSE_EVENTS__TERM_TYPE_METRIC_ID:\n\t\tcase PARSE_EVENTS__TERM_TYPE_RAW:\n\t\tcase PARSE_EVENTS__TERM_TYPE_LEGACY_CACHE:\n\t\tcase PARSE_EVENTS__TERM_TYPE_HARDWARE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bits)\n\t\tADD_CONFIG_TERM_VAL(CFG_CHG, cfg_chg, bits, false);\n\n#undef ADD_CONFIG_TERM\n\treturn 0;\n}\n\nint parse_events_add_tracepoint(struct list_head *list, int *idx,\n\t\t\t\tconst char *sys, const char *event,\n\t\t\t\tstruct parse_events_error *err,\n\t\t\t\tstruct list_head *head_config, void *loc_)\n{\n\tYYLTYPE *loc = loc_;\n#ifdef HAVE_LIBTRACEEVENT\n\tif (head_config) {\n\t\tstruct perf_event_attr attr;\n\n\t\tif (config_attr(&attr, head_config, err,\n\t\t\t\tconfig_term_tracepoint))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (strpbrk(sys, \"*?\"))\n\t\treturn add_tracepoint_multi_sys(list, idx, sys, event,\n\t\t\t\t\t\terr, head_config, loc);\n\telse\n\t\treturn add_tracepoint_event(list, idx, sys, event,\n\t\t\t\t\t    err, head_config, loc);\n#else\n\t(void)list;\n\t(void)idx;\n\t(void)sys;\n\t(void)event;\n\t(void)head_config;\n\tparse_events_error__handle(err, loc->first_column, strdup(\"unsupported tracepoint\"),\n\t\t\t\tstrdup(\"libtraceevent is necessary for tracepoint support\"));\n\treturn -1;\n#endif\n}\n\nstatic int __parse_events_add_numeric(struct parse_events_state *parse_state,\n\t\t\t\tstruct list_head *list,\n\t\t\t\tstruct perf_pmu *pmu, u32 type, u32 extended_type,\n\t\t\t\tu64 config, struct list_head *head_config)\n{\n\tstruct perf_event_attr attr;\n\tLIST_HEAD(config_terms);\n\tconst char *name, *metric_id;\n\tint ret;\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.type = type;\n\tattr.config = config;\n\tif (extended_type && (type == PERF_TYPE_HARDWARE || type == PERF_TYPE_HW_CACHE)) {\n\t\tassert(perf_pmus__supports_extended_type());\n\t\tattr.config |= (u64)extended_type << PERF_PMU_TYPE_SHIFT;\n\t}\n\n\tif (head_config) {\n\t\tif (config_attr(&attr, head_config, parse_state->error,\n\t\t\t\tconfig_term_common))\n\t\t\treturn -EINVAL;\n\n\t\tif (get_config_terms(head_config, &config_terms))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = get_config_name(head_config);\n\tmetric_id = get_config_metric_id(head_config);\n\tret = __add_event(list, &parse_state->idx, &attr,  true, name,\n\t\t\tmetric_id, pmu, &config_terms,  false,\n\t\t\t NULL) ? 0 : -ENOMEM;\n\tfree_config_terms(&config_terms);\n\treturn ret;\n}\n\nint parse_events_add_numeric(struct parse_events_state *parse_state,\n\t\t\t     struct list_head *list,\n\t\t\t     u32 type, u64 config,\n\t\t\t     struct list_head *head_config,\n\t\t\t     bool wildcard)\n{\n\tstruct perf_pmu *pmu = NULL;\n\tbool found_supported = false;\n\n\t \n\tif (wildcard && perf_pmus__supports_extended_type()) {\n\t\twhile ((pmu = perf_pmus__scan_core(pmu)) != NULL) {\n\t\t\tint ret;\n\n\t\t\tfound_supported = true;\n\t\t\tif (parse_events__filter_pmu(parse_state, pmu))\n\t\t\t\tcontinue;\n\n\t\t\tret = __parse_events_add_numeric(parse_state, list, pmu,\n\t\t\t\t\t\t\t type, pmu->type,\n\t\t\t\t\t\t\t config, head_config);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (found_supported)\n\t\t\treturn 0;\n\t}\n\treturn __parse_events_add_numeric(parse_state, list, perf_pmus__find_by_type(type),\n\t\t\t\t\ttype,  0, config, head_config);\n}\n\nint parse_events_add_tool(struct parse_events_state *parse_state,\n\t\t\t  struct list_head *list,\n\t\t\t  int tool_event)\n{\n\treturn add_event_tool(list, &parse_state->idx, tool_event);\n}\n\nstatic bool config_term_percore(struct list_head *config_terms)\n{\n\tstruct evsel_config_term *term;\n\n\tlist_for_each_entry(term, config_terms, list) {\n\t\tif (term->type == EVSEL__CONFIG_TERM_PERCORE)\n\t\t\treturn term->val.percore;\n\t}\n\n\treturn false;\n}\n\nint parse_events_add_pmu(struct parse_events_state *parse_state,\n\t\t\t struct list_head *list, const char *name,\n\t\t\t struct list_head *head_config,\n\t\t\t bool auto_merge_stats, void *loc_)\n{\n\tstruct perf_event_attr attr;\n\tstruct perf_pmu_info info;\n\tstruct perf_pmu *pmu;\n\tstruct evsel *evsel;\n\tstruct parse_events_error *err = parse_state->error;\n\tYYLTYPE *loc = loc_;\n\tLIST_HEAD(config_terms);\n\n\tpmu = parse_state->fake_pmu ?: perf_pmus__find(name);\n\n\tif (!pmu) {\n\t\tchar *err_str;\n\n\t\tif (asprintf(&err_str,\n\t\t\t\t\"Cannot find PMU `%s'. Missing kernel support?\",\n\t\t\t\tname) >= 0)\n\t\t\tparse_events_error__handle(err, loc->first_column, err_str, NULL);\n\t\treturn -EINVAL;\n\t}\n\n\tif (verbose > 1) {\n\t\tstruct strbuf sb;\n\n\t\tstrbuf_init(&sb,   0);\n\t\tif (pmu->selectable && !head_config) {\n\t\t\tstrbuf_addf(&sb, \"%s//\", name);\n\t\t} else {\n\t\t\tstrbuf_addf(&sb, \"%s/\", name);\n\t\t\tparse_events_term__to_strbuf(head_config, &sb);\n\t\t\tstrbuf_addch(&sb, '/');\n\t\t}\n\t\tfprintf(stderr, \"Attempt to add: %s\\n\", sb.buf);\n\t\tstrbuf_release(&sb);\n\t}\n\tif (head_config)\n\t\tfix_raw(head_config, pmu);\n\n\tif (pmu->default_config) {\n\t\tmemcpy(&attr, pmu->default_config,\n\t\t       sizeof(struct perf_event_attr));\n\t} else {\n\t\tmemset(&attr, 0, sizeof(attr));\n\t}\n\tattr.type = pmu->type;\n\n\tif (!head_config) {\n\t\tevsel = __add_event(list, &parse_state->idx, &attr,\n\t\t\t\t     true,  NULL,\n\t\t\t\t     NULL, pmu,\n\t\t\t\t     NULL, auto_merge_stats,\n\t\t\t\t     NULL);\n\t\treturn evsel ? 0 : -ENOMEM;\n\t}\n\n\tif (!parse_state->fake_pmu && perf_pmu__check_alias(pmu, head_config, &info, err))\n\t\treturn -EINVAL;\n\n\tif (verbose > 1) {\n\t\tstruct strbuf sb;\n\n\t\tstrbuf_init(&sb,   0);\n\t\tparse_events_term__to_strbuf(head_config, &sb);\n\t\tfprintf(stderr, \"..after resolving event: %s/%s/\\n\", name, sb.buf);\n\t\tstrbuf_release(&sb);\n\t}\n\n\t \n\tif (config_attr(&attr, head_config, parse_state->error, config_term_pmu))\n\t\treturn -EINVAL;\n\n\tif (get_config_terms(head_config, &config_terms))\n\t\treturn -ENOMEM;\n\n\t \n\tif (pmu->default_config && get_config_chgs(pmu, head_config, &config_terms))\n\t\treturn -ENOMEM;\n\n\tif (!parse_state->fake_pmu && perf_pmu__config(pmu, &attr, head_config, parse_state->error)) {\n\t\tfree_config_terms(&config_terms);\n\t\treturn -EINVAL;\n\t}\n\n\tevsel = __add_event(list, &parse_state->idx, &attr,  true,\n\t\t\t    get_config_name(head_config),\n\t\t\t    get_config_metric_id(head_config), pmu,\n\t\t\t    &config_terms, auto_merge_stats,  NULL);\n\tif (!evsel)\n\t\treturn -ENOMEM;\n\n\tif (evsel->name)\n\t\tevsel->use_config_name = true;\n\n\tevsel->percore = config_term_percore(&evsel->config_terms);\n\n\tif (parse_state->fake_pmu)\n\t\treturn 0;\n\n\tfree((char *)evsel->unit);\n\tevsel->unit = strdup(info.unit);\n\tevsel->scale = info.scale;\n\tevsel->per_pkg = info.per_pkg;\n\tevsel->snapshot = info.snapshot;\n\treturn 0;\n}\n\nint parse_events_multi_pmu_add(struct parse_events_state *parse_state,\n\t\t\t       char *str, struct list_head *head,\n\t\t\t       struct list_head **listp, void *loc_)\n{\n\tstruct parse_events_term *term;\n\tstruct list_head *list = NULL;\n\tstruct list_head *orig_head = NULL;\n\tstruct perf_pmu *pmu = NULL;\n\tYYLTYPE *loc = loc_;\n\tint ok = 0;\n\tconst char *config;\n\n\t*listp = NULL;\n\n\tif (!head) {\n\t\thead = malloc(sizeof(struct list_head));\n\t\tif (!head)\n\t\t\tgoto out_err;\n\n\t\tINIT_LIST_HEAD(head);\n\t}\n\tconfig = strdup(str);\n\tif (!config)\n\t\tgoto out_err;\n\n\tif (parse_events_term__num(&term,\n\t\t\t\t   PARSE_EVENTS__TERM_TYPE_USER,\n\t\t\t\t   config,  1,  true,\n\t\t\t\t   loc,  NULL) < 0) {\n\t\tzfree(&config);\n\t\tgoto out_err;\n\t}\n\tlist_add_tail(&term->list, head);\n\n\t \n\tlist = malloc(sizeof(struct list_head));\n\tif (!list)\n\t\tgoto out_err;\n\n\tINIT_LIST_HEAD(list);\n\n\twhile ((pmu = perf_pmus__scan(pmu)) != NULL) {\n\t\tbool auto_merge_stats;\n\n\t\tif (parse_events__filter_pmu(parse_state, pmu))\n\t\t\tcontinue;\n\n\t\tif (!perf_pmu__have_event(pmu, str))\n\t\t\tcontinue;\n\n\t\tauto_merge_stats = perf_pmu__auto_merge_stats(pmu);\n\t\tparse_events_copy_term_list(head, &orig_head);\n\t\tif (!parse_events_add_pmu(parse_state, list, pmu->name,\n\t\t\t\t\t  orig_head, auto_merge_stats, loc)) {\n\t\t\tstruct strbuf sb;\n\n\t\t\tstrbuf_init(&sb,   0);\n\t\t\tparse_events_term__to_strbuf(orig_head, &sb);\n\t\t\tpr_debug(\"%s -> %s/%s/\\n\", str, pmu->name, sb.buf);\n\t\t\tstrbuf_release(&sb);\n\t\t\tok++;\n\t\t}\n\t\tparse_events_terms__delete(orig_head);\n\t}\n\n\tif (parse_state->fake_pmu) {\n\t\tif (!parse_events_add_pmu(parse_state, list, str, head,\n\t\t\t\t\t   true, loc)) {\n\t\t\tstruct strbuf sb;\n\n\t\t\tstrbuf_init(&sb,   0);\n\t\t\tparse_events_term__to_strbuf(head, &sb);\n\t\t\tpr_debug(\"%s -> %s/%s/\\n\", str, \"fake_pmu\", sb.buf);\n\t\t\tstrbuf_release(&sb);\n\t\t\tok++;\n\t\t}\n\t}\n\nout_err:\n\tif (ok)\n\t\t*listp = list;\n\telse\n\t\tfree(list);\n\n\tparse_events_terms__delete(head);\n\treturn ok ? 0 : -1;\n}\n\nint parse_events__modifier_group(struct list_head *list,\n\t\t\t\t char *event_mod)\n{\n\treturn parse_events__modifier_event(list, event_mod, true);\n}\n\nvoid parse_events__set_leader(char *name, struct list_head *list)\n{\n\tstruct evsel *leader;\n\n\tif (list_empty(list)) {\n\t\tWARN_ONCE(true, \"WARNING: failed to set leader: empty list\");\n\t\treturn;\n\t}\n\n\tleader = list_first_entry(list, struct evsel, core.node);\n\t__perf_evlist__set_leader(list, &leader->core);\n\tleader->group_name = name;\n}\n\n \nvoid parse_events_update_lists(struct list_head *list_event,\n\t\t\t       struct list_head *list_all)\n{\n\t \n\tlist_splice_tail(list_event, list_all);\n\tfree(list_event);\n}\n\nstruct event_modifier {\n\tint eu;\n\tint ek;\n\tint eh;\n\tint eH;\n\tint eG;\n\tint eI;\n\tint precise;\n\tint precise_max;\n\tint exclude_GH;\n\tint sample_read;\n\tint pinned;\n\tint weak;\n\tint exclusive;\n\tint bpf_counter;\n};\n\nstatic int get_event_modifier(struct event_modifier *mod, char *str,\n\t\t\t       struct evsel *evsel)\n{\n\tint eu = evsel ? evsel->core.attr.exclude_user : 0;\n\tint ek = evsel ? evsel->core.attr.exclude_kernel : 0;\n\tint eh = evsel ? evsel->core.attr.exclude_hv : 0;\n\tint eH = evsel ? evsel->core.attr.exclude_host : 0;\n\tint eG = evsel ? evsel->core.attr.exclude_guest : 0;\n\tint eI = evsel ? evsel->core.attr.exclude_idle : 0;\n\tint precise = evsel ? evsel->core.attr.precise_ip : 0;\n\tint precise_max = 0;\n\tint sample_read = 0;\n\tint pinned = evsel ? evsel->core.attr.pinned : 0;\n\tint exclusive = evsel ? evsel->core.attr.exclusive : 0;\n\n\tint exclude = eu | ek | eh;\n\tint exclude_GH = evsel ? evsel->exclude_GH : 0;\n\tint weak = 0;\n\tint bpf_counter = 0;\n\n\tmemset(mod, 0, sizeof(*mod));\n\n\twhile (*str) {\n\t\tif (*str == 'u') {\n\t\t\tif (!exclude)\n\t\t\t\texclude = eu = ek = eh = 1;\n\t\t\tif (!exclude_GH && !perf_guest)\n\t\t\t\teG = 1;\n\t\t\teu = 0;\n\t\t} else if (*str == 'k') {\n\t\t\tif (!exclude)\n\t\t\t\texclude = eu = ek = eh = 1;\n\t\t\tek = 0;\n\t\t} else if (*str == 'h') {\n\t\t\tif (!exclude)\n\t\t\t\texclude = eu = ek = eh = 1;\n\t\t\teh = 0;\n\t\t} else if (*str == 'G') {\n\t\t\tif (!exclude_GH)\n\t\t\t\texclude_GH = eG = eH = 1;\n\t\t\teG = 0;\n\t\t} else if (*str == 'H') {\n\t\t\tif (!exclude_GH)\n\t\t\t\texclude_GH = eG = eH = 1;\n\t\t\teH = 0;\n\t\t} else if (*str == 'I') {\n\t\t\teI = 1;\n\t\t} else if (*str == 'p') {\n\t\t\tprecise++;\n\t\t\t \n\t\t\tif (!exclude_GH)\n\t\t\t\teG = 1;\n\t\t} else if (*str == 'P') {\n\t\t\tprecise_max = 1;\n\t\t} else if (*str == 'S') {\n\t\t\tsample_read = 1;\n\t\t} else if (*str == 'D') {\n\t\t\tpinned = 1;\n\t\t} else if (*str == 'e') {\n\t\t\texclusive = 1;\n\t\t} else if (*str == 'W') {\n\t\t\tweak = 1;\n\t\t} else if (*str == 'b') {\n\t\t\tbpf_counter = 1;\n\t\t} else\n\t\t\tbreak;\n\n\t\t++str;\n\t}\n\n\t \n\tif (precise > 3)\n\t\treturn -EINVAL;\n\n\tmod->eu = eu;\n\tmod->ek = ek;\n\tmod->eh = eh;\n\tmod->eH = eH;\n\tmod->eG = eG;\n\tmod->eI = eI;\n\tmod->precise = precise;\n\tmod->precise_max = precise_max;\n\tmod->exclude_GH = exclude_GH;\n\tmod->sample_read = sample_read;\n\tmod->pinned = pinned;\n\tmod->weak = weak;\n\tmod->bpf_counter = bpf_counter;\n\tmod->exclusive = exclusive;\n\n\treturn 0;\n}\n\n \nstatic int check_modifier(char *str)\n{\n\tchar *p = str;\n\n\t \n\tif (strlen(str) > (sizeof(\"ukhGHpppPSDIWeb\") - 1))\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tif (*p != 'p' && strchr(p + 1, *p))\n\t\t\treturn -1;\n\t\tp++;\n\t}\n\n\treturn 0;\n}\n\nint parse_events__modifier_event(struct list_head *list, char *str, bool add)\n{\n\tstruct evsel *evsel;\n\tstruct event_modifier mod;\n\n\tif (str == NULL)\n\t\treturn 0;\n\n\tif (check_modifier(str))\n\t\treturn -EINVAL;\n\n\tif (!add && get_event_modifier(&mod, str, NULL))\n\t\treturn -EINVAL;\n\n\t__evlist__for_each_entry(list, evsel) {\n\t\tif (add && get_event_modifier(&mod, str, evsel))\n\t\t\treturn -EINVAL;\n\n\t\tevsel->core.attr.exclude_user   = mod.eu;\n\t\tevsel->core.attr.exclude_kernel = mod.ek;\n\t\tevsel->core.attr.exclude_hv     = mod.eh;\n\t\tevsel->core.attr.precise_ip     = mod.precise;\n\t\tevsel->core.attr.exclude_host   = mod.eH;\n\t\tevsel->core.attr.exclude_guest  = mod.eG;\n\t\tevsel->core.attr.exclude_idle   = mod.eI;\n\t\tevsel->exclude_GH          = mod.exclude_GH;\n\t\tevsel->sample_read         = mod.sample_read;\n\t\tevsel->precise_max         = mod.precise_max;\n\t\tevsel->weak_group\t   = mod.weak;\n\t\tevsel->bpf_counter\t   = mod.bpf_counter;\n\n\t\tif (evsel__is_group_leader(evsel)) {\n\t\t\tevsel->core.attr.pinned = mod.pinned;\n\t\t\tevsel->core.attr.exclusive = mod.exclusive;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint parse_events_name(struct list_head *list, const char *name)\n{\n\tstruct evsel *evsel;\n\n\t__evlist__for_each_entry(list, evsel) {\n\t\tif (!evsel->name) {\n\t\t\tevsel->name = strdup(name);\n\t\t\tif (!evsel->name)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_events__scanner(const char *str,\n\t\t\t\t FILE *input,\n\t\t\t\t struct parse_events_state *parse_state)\n{\n\tYY_BUFFER_STATE buffer;\n\tvoid *scanner;\n\tint ret;\n\n\tret = parse_events_lex_init_extra(parse_state, &scanner);\n\tif (ret)\n\t\treturn ret;\n\n\tif (str)\n\t\tbuffer = parse_events__scan_string(str, scanner);\n\telse\n\t        parse_events_set_in(input, scanner);\n\n#ifdef PARSER_DEBUG\n\tparse_events_debug = 1;\n\tparse_events_set_debug(1, scanner);\n#endif\n\tret = parse_events_parse(parse_state, scanner);\n\n\tif (str) {\n\t\tparse_events__flush_buffer(buffer, scanner);\n\t\tparse_events__delete_buffer(buffer, scanner);\n\t}\n\tparse_events_lex_destroy(scanner);\n\treturn ret;\n}\n\n \nint parse_events_terms(struct list_head *terms, const char *str, FILE *input)\n{\n\tstruct parse_events_state parse_state = {\n\t\t.terms  = NULL,\n\t\t.stoken = PE_START_TERMS,\n\t};\n\tint ret;\n\n\tret = parse_events__scanner(str, input, &parse_state);\n\n\tif (!ret) {\n\t\tlist_splice(parse_state.terms, terms);\n\t\tzfree(&parse_state.terms);\n\t\treturn 0;\n\t}\n\n\tparse_events_terms__delete(parse_state.terms);\n\treturn ret;\n}\n\nstatic int evsel__compute_group_pmu_name(struct evsel *evsel,\n\t\t\t\t\t  const struct list_head *head)\n{\n\tstruct evsel *leader = evsel__leader(evsel);\n\tstruct evsel *pos;\n\tconst char *group_pmu_name;\n\tstruct perf_pmu *pmu = evsel__find_pmu(evsel);\n\n\tif (!pmu) {\n\t\t \n\t\tpmu = perf_pmus__scan_core(NULL);\n\t}\n\tif (!pmu) {\n\t\tpr_debug(\"No PMU found for '%s'\\n\", evsel__name(evsel));\n\t\treturn -EINVAL;\n\t}\n\tgroup_pmu_name = pmu->name;\n\t \n\tif (perf_pmu__is_software(pmu) || evsel__is_aux_event(leader)) {\n\t\tstruct perf_pmu *leader_pmu = evsel__find_pmu(leader);\n\n\t\tif (!leader_pmu) {\n\t\t\t \n\t\t\tleader_pmu = perf_pmus__scan_core(NULL);\n\t\t}\n\t\t \n\t\tif (leader_pmu && !perf_pmu__is_software(leader_pmu)) {\n\t\t\tgroup_pmu_name = leader_pmu->name;\n\t\t} else if (leader->core.nr_members > 1) {\n\t\t\tlist_for_each_entry(pos, head, core.node) {\n\t\t\t\tstruct perf_pmu *pos_pmu;\n\n\t\t\t\tif (pos == leader || evsel__leader(pos) != leader)\n\t\t\t\t\tcontinue;\n\t\t\t\tpos_pmu = evsel__find_pmu(pos);\n\t\t\t\tif (!pos_pmu) {\n\t\t\t\t\t \n\t\t\t\t\tpos_pmu = perf_pmus__scan_core(NULL);\n\t\t\t\t}\n\t\t\t\tif (pos_pmu && !perf_pmu__is_software(pos_pmu)) {\n\t\t\t\t\tgroup_pmu_name = pos_pmu->name;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\tevsel->group_pmu_name = strdup(group_pmu_name ?: \"fake\");\n\treturn evsel->group_pmu_name ? 0 : -ENOMEM;\n}\n\n__weak int arch_evlist__cmp(const struct evsel *lhs, const struct evsel *rhs)\n{\n\t \n\treturn lhs->core.idx - rhs->core.idx;\n}\n\nstatic int evlist__cmp(void *_fg_idx, const struct list_head *l, const struct list_head *r)\n{\n\tconst struct perf_evsel *lhs_core = container_of(l, struct perf_evsel, node);\n\tconst struct evsel *lhs = container_of(lhs_core, struct evsel, core);\n\tconst struct perf_evsel *rhs_core = container_of(r, struct perf_evsel, node);\n\tconst struct evsel *rhs = container_of(rhs_core, struct evsel, core);\n\tint *force_grouped_idx = _fg_idx;\n\tint lhs_sort_idx, rhs_sort_idx, ret;\n\tconst char *lhs_pmu_name, *rhs_pmu_name;\n\tbool lhs_has_group, rhs_has_group;\n\n\t \n\tif (lhs_core->leader != lhs_core || lhs_core->nr_members > 1) {\n\t\tlhs_has_group = true;\n\t\tlhs_sort_idx = lhs_core->leader->idx;\n\t} else {\n\t\tlhs_has_group = false;\n\t\tlhs_sort_idx = *force_grouped_idx != -1 && arch_evsel__must_be_in_group(lhs)\n\t\t\t? *force_grouped_idx\n\t\t\t: lhs_core->idx;\n\t}\n\tif (rhs_core->leader != rhs_core || rhs_core->nr_members > 1) {\n\t\trhs_has_group = true;\n\t\trhs_sort_idx = rhs_core->leader->idx;\n\t} else {\n\t\trhs_has_group = false;\n\t\trhs_sort_idx = *force_grouped_idx != -1 && arch_evsel__must_be_in_group(rhs)\n\t\t\t? *force_grouped_idx\n\t\t\t: rhs_core->idx;\n\t}\n\n\tif (lhs_sort_idx != rhs_sort_idx)\n\t\treturn lhs_sort_idx - rhs_sort_idx;\n\n\t \n\tif (lhs_has_group && rhs_has_group) {\n\t\tlhs_pmu_name = lhs->group_pmu_name;\n\t\trhs_pmu_name = rhs->group_pmu_name;\n\t\tret = strcmp(lhs_pmu_name, rhs_pmu_name);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn arch_evlist__cmp(lhs, rhs);\n}\n\nstatic int parse_events__sort_events_and_fix_groups(struct list_head *list)\n{\n\tint idx = 0, force_grouped_idx = -1;\n\tstruct evsel *pos, *cur_leader = NULL;\n\tstruct perf_evsel *cur_leaders_grp = NULL;\n\tbool idx_changed = false, cur_leader_force_grouped = false;\n\tint orig_num_leaders = 0, num_leaders = 0;\n\tint ret;\n\n\t \n\tlist_for_each_entry(pos, list, core.node) {\n\t\tconst struct evsel *pos_leader = evsel__leader(pos);\n\n\t\tret = evsel__compute_group_pmu_name(pos, list);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pos == pos_leader)\n\t\t\torig_num_leaders++;\n\n\t\t \n\t\tpos->core.idx = idx++;\n\n\t\t \n\t\tif (force_grouped_idx == -1 && pos == pos_leader && pos->core.nr_members < 2 &&\n\t\t    arch_evsel__must_be_in_group(pos))\n\t\t\tforce_grouped_idx = pos->core.idx;\n\t}\n\n\t \n\tlist_sort(&force_grouped_idx, list, evlist__cmp);\n\n\t \n\tidx = 0;\n\tlist_for_each_entry(pos, list, core.node) {\n\t\tconst struct evsel *pos_leader = evsel__leader(pos);\n\t\tconst char *pos_pmu_name = pos->group_pmu_name;\n\t\tconst char *cur_leader_pmu_name;\n\t\tbool pos_force_grouped = force_grouped_idx != -1 &&\n\t\t\tarch_evsel__must_be_in_group(pos);\n\n\t\t \n\t\tif (pos->core.idx != idx)\n\t\t\tidx_changed = true;\n\t\tpos->core.idx = idx++;\n\t\tpos->core.nr_members = 0;\n\n\t\t \n\t\tif (!cur_leader)\n\t\t\tcur_leader = pos;\n\n\t\tcur_leader_pmu_name = cur_leader->group_pmu_name;\n\t\tif ((cur_leaders_grp != pos->core.leader &&\n\t\t     (!pos_force_grouped || !cur_leader_force_grouped)) ||\n\t\t    strcmp(cur_leader_pmu_name, pos_pmu_name)) {\n\t\t\t \n\t\t\tcur_leader = pos;\n\t\t\t \n\t\t\tcur_leaders_grp = pos->core.leader;\n\t\t\t \n\t\t\tcur_leader_force_grouped = pos_force_grouped;\n\t\t}\n\t\tif (pos_leader != cur_leader) {\n\t\t\t \n\t\t\tevsel__set_leader(pos, cur_leader);\n\t\t}\n\t}\n\tlist_for_each_entry(pos, list, core.node) {\n\t\tstruct evsel *pos_leader = evsel__leader(pos);\n\n\t\tif (pos == pos_leader)\n\t\t\tnum_leaders++;\n\t\tpos_leader->core.nr_members++;\n\t}\n\treturn (idx_changed || num_leaders != orig_num_leaders) ? 1 : 0;\n}\n\nint __parse_events(struct evlist *evlist, const char *str, const char *pmu_filter,\n\t\t   struct parse_events_error *err, struct perf_pmu *fake_pmu,\n\t\t   bool warn_if_reordered)\n{\n\tstruct parse_events_state parse_state = {\n\t\t.list\t  = LIST_HEAD_INIT(parse_state.list),\n\t\t.idx\t  = evlist->core.nr_entries,\n\t\t.error\t  = err,\n\t\t.stoken\t  = PE_START_EVENTS,\n\t\t.fake_pmu = fake_pmu,\n\t\t.pmu_filter = pmu_filter,\n\t\t.match_legacy_cache_terms = true,\n\t};\n\tint ret, ret2;\n\n\tret = parse_events__scanner(str,   NULL, &parse_state);\n\n\tif (!ret && list_empty(&parse_state.list)) {\n\t\tWARN_ONCE(true, \"WARNING: event parser found nothing\\n\");\n\t\treturn -1;\n\t}\n\n\tret2 = parse_events__sort_events_and_fix_groups(&parse_state.list);\n\tif (ret2 < 0)\n\t\treturn ret;\n\n\tif (ret2 && warn_if_reordered && !parse_state.wild_card_pmus)\n\t\tpr_warning(\"WARNING: events were regrouped to match PMUs\\n\");\n\n\t \n\tevlist__splice_list_tail(evlist, &parse_state.list);\n\n\tif (!ret) {\n\t\tstruct evsel *last;\n\n\t\tlast = evlist__last(evlist);\n\t\tlast->cmdline_group_boundary = true;\n\n\t\treturn 0;\n\t}\n\n\t \n\treturn ret;\n}\n\nint parse_event(struct evlist *evlist, const char *str)\n{\n\tstruct parse_events_error err;\n\tint ret;\n\n\tparse_events_error__init(&err);\n\tret = parse_events(evlist, str, &err);\n\tparse_events_error__exit(&err);\n\treturn ret;\n}\n\nvoid parse_events_error__init(struct parse_events_error *err)\n{\n\tbzero(err, sizeof(*err));\n}\n\nvoid parse_events_error__exit(struct parse_events_error *err)\n{\n\tzfree(&err->str);\n\tzfree(&err->help);\n\tzfree(&err->first_str);\n\tzfree(&err->first_help);\n}\n\nvoid parse_events_error__handle(struct parse_events_error *err, int idx,\n\t\t\t\tchar *str, char *help)\n{\n\tif (WARN(!str || !err, \"WARNING: failed to provide error string or struct\\n\"))\n\t\tgoto out_free;\n\tswitch (err->num_errors) {\n\tcase 0:\n\t\terr->idx = idx;\n\t\terr->str = str;\n\t\terr->help = help;\n\t\tbreak;\n\tcase 1:\n\t\terr->first_idx = err->idx;\n\t\terr->idx = idx;\n\t\terr->first_str = err->str;\n\t\terr->str = str;\n\t\terr->first_help = err->help;\n\t\terr->help = help;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Multiple errors dropping message: %s (%s)\\n\",\n\t\t\terr->str, err->help ?: \"<no help>\");\n\t\tfree(err->str);\n\t\terr->str = str;\n\t\tfree(err->help);\n\t\terr->help = help;\n\t\tbreak;\n\t}\n\terr->num_errors++;\n\treturn;\n\nout_free:\n\tfree(str);\n\tfree(help);\n}\n\n#define MAX_WIDTH 1000\nstatic int get_term_width(void)\n{\n\tstruct winsize ws;\n\n\tget_term_dimensions(&ws);\n\treturn ws.ws_col > MAX_WIDTH ? MAX_WIDTH : ws.ws_col;\n}\n\nstatic void __parse_events_error__print(int err_idx, const char *err_str,\n\t\t\t\t\tconst char *err_help, const char *event)\n{\n\tconst char *str = \"invalid or unsupported event: \";\n\tchar _buf[MAX_WIDTH];\n\tchar *buf = (char *) event;\n\tint idx = 0;\n\tif (err_str) {\n\t\t \n\t\tint width       = get_term_width() - 2;\n\t\tint len_event   = strlen(event);\n\t\tint len_str, max_len, cut = 0;\n\n\t\t \n\t\tint max_err_idx = 13;\n\n\t\t \n\t\tstr     = \"event syntax error: \";\n\t\tlen_str = strlen(str);\n\t\tmax_len = width - len_str;\n\n\t\tbuf = _buf;\n\n\t\t \n\t\tif (err_idx > max_err_idx)\n\t\t\tcut = err_idx - max_err_idx;\n\n\t\tstrncpy(buf, event + cut, max_len);\n\n\t\t \n\t\tif (cut)\n\t\t\tbuf[0] = buf[1] = '.';\n\n\t\tif ((len_event - cut) > max_len) {\n\t\t\tbuf[max_len - 1] = buf[max_len - 2] = '.';\n\t\t\tbuf[max_len] = 0;\n\t\t}\n\n\t\tidx = len_str + err_idx - cut;\n\t}\n\n\tfprintf(stderr, \"%s'%s'\\n\", str, buf);\n\tif (idx) {\n\t\tfprintf(stderr, \"%*s\\\\___ %s\\n\", idx + 1, \"\", err_str);\n\t\tif (err_help)\n\t\t\tfprintf(stderr, \"\\n%s\\n\", err_help);\n\t}\n}\n\nvoid parse_events_error__print(struct parse_events_error *err,\n\t\t\t       const char *event)\n{\n\tif (!err->num_errors)\n\t\treturn;\n\n\t__parse_events_error__print(err->idx, err->str, err->help, event);\n\n\tif (err->num_errors > 1) {\n\t\tfputs(\"\\nInitial error:\\n\", stderr);\n\t\t__parse_events_error__print(err->first_idx, err->first_str,\n\t\t\t\t\terr->first_help, event);\n\t}\n}\n\n#undef MAX_WIDTH\n\nint parse_events_option(const struct option *opt, const char *str,\n\t\t\tint unset __maybe_unused)\n{\n\tstruct parse_events_option_args *args = opt->value;\n\tstruct parse_events_error err;\n\tint ret;\n\n\tparse_events_error__init(&err);\n\tret = __parse_events(*args->evlistp, str, args->pmu_filter, &err,\n\t\t\t      NULL,  true);\n\n\tif (ret) {\n\t\tparse_events_error__print(&err, str);\n\t\tfprintf(stderr, \"Run 'perf list' for a list of valid events\\n\");\n\t}\n\tparse_events_error__exit(&err);\n\n\treturn ret;\n}\n\nint parse_events_option_new_evlist(const struct option *opt, const char *str, int unset)\n{\n\tstruct parse_events_option_args *args = opt->value;\n\tint ret;\n\n\tif (*args->evlistp == NULL) {\n\t\t*args->evlistp = evlist__new();\n\n\t\tif (*args->evlistp == NULL) {\n\t\t\tfprintf(stderr, \"Not enough memory to create evlist\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tret = parse_events_option(opt, str, unset);\n\tif (ret) {\n\t\tevlist__delete(*args->evlistp);\n\t\t*args->evlistp = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nforeach_evsel_in_last_glob(struct evlist *evlist,\n\t\t\t   int (*func)(struct evsel *evsel,\n\t\t\t\t       const void *arg),\n\t\t\t   const void *arg)\n{\n\tstruct evsel *last = NULL;\n\tint err;\n\n\t \n\tif (evlist->core.nr_entries > 0)\n\t\tlast = evlist__last(evlist);\n\n\tdo {\n\t\terr = (*func)(last, arg);\n\t\tif (err)\n\t\t\treturn -1;\n\t\tif (!last)\n\t\t\treturn 0;\n\n\t\tif (last->core.node.prev == &evlist->core.entries)\n\t\t\treturn 0;\n\t\tlast = list_entry(last->core.node.prev, struct evsel, core.node);\n\t} while (!last->cmdline_group_boundary);\n\n\treturn 0;\n}\n\nstatic int set_filter(struct evsel *evsel, const void *arg)\n{\n\tconst char *str = arg;\n\tbool found = false;\n\tint nr_addr_filters = 0;\n\tstruct perf_pmu *pmu = NULL;\n\n\tif (evsel == NULL) {\n\t\tfprintf(stderr,\n\t\t\t\"--filter option should follow a -e tracepoint or HW tracer option\\n\");\n\t\treturn -1;\n\t}\n\n\tif (evsel->core.attr.type == PERF_TYPE_TRACEPOINT) {\n\t\tif (evsel__append_tp_filter(evsel, str) < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"not enough memory to hold filter string\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\twhile ((pmu = perf_pmus__scan(pmu)) != NULL)\n\t\tif (pmu->type == evsel->core.attr.type) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (found)\n\t\tperf_pmu__scan_file(pmu, \"nr_addr_filters\",\n\t\t\t\t    \"%d\", &nr_addr_filters);\n\n\tif (!nr_addr_filters)\n\t\treturn perf_bpf_filter__parse(&evsel->bpf_filters, str);\n\n\tif (evsel__append_addr_filter(evsel, str) < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"not enough memory to hold filter string\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint parse_filter(const struct option *opt, const char *str,\n\t\t int unset __maybe_unused)\n{\n\tstruct evlist *evlist = *(struct evlist **)opt->value;\n\n\treturn foreach_evsel_in_last_glob(evlist, set_filter,\n\t\t\t\t\t  (const void *)str);\n}\n\nstatic int add_exclude_perf_filter(struct evsel *evsel,\n\t\t\t\t   const void *arg __maybe_unused)\n{\n\tchar new_filter[64];\n\n\tif (evsel == NULL || evsel->core.attr.type != PERF_TYPE_TRACEPOINT) {\n\t\tfprintf(stderr,\n\t\t\t\"--exclude-perf option should follow a -e tracepoint option\\n\");\n\t\treturn -1;\n\t}\n\n\tsnprintf(new_filter, sizeof(new_filter), \"common_pid != %d\", getpid());\n\n\tif (evsel__append_tp_filter(evsel, new_filter) < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"not enough memory to hold filter string\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint exclude_perf(const struct option *opt,\n\t\t const char *arg __maybe_unused,\n\t\t int unset __maybe_unused)\n{\n\tstruct evlist *evlist = *(struct evlist **)opt->value;\n\n\treturn foreach_evsel_in_last_glob(evlist, add_exclude_perf_filter,\n\t\t\t\t\t  NULL);\n}\n\nint parse_events__is_hardcoded_term(struct parse_events_term *term)\n{\n\treturn term->type_term != PARSE_EVENTS__TERM_TYPE_USER;\n}\n\nstatic int new_term(struct parse_events_term **_term,\n\t\t    struct parse_events_term *temp,\n\t\t    char *str, u64 num)\n{\n\tstruct parse_events_term *term;\n\n\tterm = malloc(sizeof(*term));\n\tif (!term)\n\t\treturn -ENOMEM;\n\n\t*term = *temp;\n\tINIT_LIST_HEAD(&term->list);\n\tterm->weak = false;\n\n\tswitch (term->type_val) {\n\tcase PARSE_EVENTS__TERM_TYPE_NUM:\n\t\tterm->val.num = num;\n\t\tbreak;\n\tcase PARSE_EVENTS__TERM_TYPE_STR:\n\t\tterm->val.str = str;\n\t\tbreak;\n\tdefault:\n\t\tfree(term);\n\t\treturn -EINVAL;\n\t}\n\n\t*_term = term;\n\treturn 0;\n}\n\nint parse_events_term__num(struct parse_events_term **term,\n\t\t\t   enum parse_events__term_type type_term,\n\t\t\t   const char *config, u64 num,\n\t\t\t   bool no_value,\n\t\t\t   void *loc_term_, void *loc_val_)\n{\n\tYYLTYPE *loc_term = loc_term_;\n\tYYLTYPE *loc_val = loc_val_;\n\n\tstruct parse_events_term temp = {\n\t\t.type_val  = PARSE_EVENTS__TERM_TYPE_NUM,\n\t\t.type_term = type_term,\n\t\t.config    = config ? : strdup(config_term_name(type_term)),\n\t\t.no_value  = no_value,\n\t\t.err_term  = loc_term ? loc_term->first_column : 0,\n\t\t.err_val   = loc_val  ? loc_val->first_column  : 0,\n\t};\n\n\treturn new_term(term, &temp,  NULL, num);\n}\n\nint parse_events_term__str(struct parse_events_term **term,\n\t\t\t   enum parse_events__term_type type_term,\n\t\t\t   char *config, char *str,\n\t\t\t   void *loc_term_, void *loc_val_)\n{\n\tYYLTYPE *loc_term = loc_term_;\n\tYYLTYPE *loc_val = loc_val_;\n\n\tstruct parse_events_term temp = {\n\t\t.type_val  = PARSE_EVENTS__TERM_TYPE_STR,\n\t\t.type_term = type_term,\n\t\t.config    = config,\n\t\t.err_term  = loc_term ? loc_term->first_column : 0,\n\t\t.err_val   = loc_val  ? loc_val->first_column  : 0,\n\t};\n\n\treturn new_term(term, &temp, str,  0);\n}\n\nint parse_events_term__term(struct parse_events_term **term,\n\t\t\t    enum parse_events__term_type term_lhs,\n\t\t\t    enum parse_events__term_type term_rhs,\n\t\t\t    void *loc_term, void *loc_val)\n{\n\treturn parse_events_term__str(term, term_lhs, NULL,\n\t\t\t\t      strdup(config_term_name(term_rhs)),\n\t\t\t\t      loc_term, loc_val);\n}\n\nint parse_events_term__clone(struct parse_events_term **new,\n\t\t\t     struct parse_events_term *term)\n{\n\tchar *str;\n\tstruct parse_events_term temp = *term;\n\n\ttemp.used = false;\n\tif (term->config) {\n\t\ttemp.config = strdup(term->config);\n\t\tif (!temp.config)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (term->type_val == PARSE_EVENTS__TERM_TYPE_NUM)\n\t\treturn new_term(new, &temp,  NULL, term->val.num);\n\n\tstr = strdup(term->val.str);\n\tif (!str)\n\t\treturn -ENOMEM;\n\treturn new_term(new, &temp, str,  0);\n}\n\nvoid parse_events_term__delete(struct parse_events_term *term)\n{\n\tif (term->type_val != PARSE_EVENTS__TERM_TYPE_NUM)\n\t\tzfree(&term->val.str);\n\n\tzfree(&term->config);\n\tfree(term);\n}\n\nint parse_events_copy_term_list(struct list_head *old,\n\t\t\t\t struct list_head **new)\n{\n\tstruct parse_events_term *term, *n;\n\tint ret;\n\n\tif (!old) {\n\t\t*new = NULL;\n\t\treturn 0;\n\t}\n\n\t*new = malloc(sizeof(struct list_head));\n\tif (!*new)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(*new);\n\n\tlist_for_each_entry (term, old, list) {\n\t\tret = parse_events_term__clone(&n, term);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlist_add_tail(&n->list, *new);\n\t}\n\treturn 0;\n}\n\nvoid parse_events_terms__purge(struct list_head *terms)\n{\n\tstruct parse_events_term *term, *h;\n\n\tlist_for_each_entry_safe(term, h, terms, list) {\n\t\tlist_del_init(&term->list);\n\t\tparse_events_term__delete(term);\n\t}\n}\n\nvoid parse_events_terms__delete(struct list_head *terms)\n{\n\tif (!terms)\n\t\treturn;\n\tparse_events_terms__purge(terms);\n\tfree(terms);\n}\n\nint parse_events_term__to_strbuf(struct list_head *term_list, struct strbuf *sb)\n{\n\tstruct parse_events_term *term;\n\tbool first = true;\n\n\tif (!term_list)\n\t\treturn 0;\n\n\tlist_for_each_entry(term, term_list, list) {\n\t\tint ret;\n\n\t\tif (!first) {\n\t\t\tret = strbuf_addch(sb, ',');\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tfirst = false;\n\n\t\tif (term->type_val == PARSE_EVENTS__TERM_TYPE_NUM)\n\t\t\tif (term->no_value) {\n\t\t\t\tassert(term->val.num == 1);\n\t\t\t\tret = strbuf_addf(sb, \"%s\", term->config);\n\t\t\t} else\n\t\t\t\tret = strbuf_addf(sb, \"%s=%#\"PRIx64, term->config, term->val.num);\n\t\telse if (term->type_val == PARSE_EVENTS__TERM_TYPE_STR) {\n\t\t\tif (term->config) {\n\t\t\t\tret = strbuf_addf(sb, \"%s=\", term->config);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t} else if ((unsigned int)term->type_term < __PARSE_EVENTS__TERM_TYPE_NR) {\n\t\t\t\tret = strbuf_addf(sb, \"%s=\", config_term_name(term->type_term));\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tassert(!term->no_value);\n\t\t\tret = strbuf_addf(sb, \"%s\", term->val.str);\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nvoid parse_events_evlist_error(struct parse_events_state *parse_state,\n\t\t\t       int idx, const char *str)\n{\n\tif (!parse_state->error)\n\t\treturn;\n\n\tparse_events_error__handle(parse_state->error, idx, strdup(str), NULL);\n}\n\nstatic void config_terms_list(char *buf, size_t buf_sz)\n{\n\tint i;\n\tbool first = true;\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < __PARSE_EVENTS__TERM_TYPE_NR; i++) {\n\t\tconst char *name = config_term_name(i);\n\n\t\tif (!config_term_avail(i, NULL))\n\t\t\tcontinue;\n\t\tif (!name)\n\t\t\tcontinue;\n\t\tif (name[0] == '<')\n\t\t\tcontinue;\n\n\t\tif (strlen(buf) + strlen(name) + 2 >= buf_sz)\n\t\t\treturn;\n\n\t\tif (!first)\n\t\t\tstrcat(buf, \",\");\n\t\telse\n\t\t\tfirst = false;\n\t\tstrcat(buf, name);\n\t}\n}\n\n \nchar *parse_events_formats_error_string(char *additional_terms)\n{\n\tchar *str;\n\t \n\tchar static_terms[__PARSE_EVENTS__TERM_TYPE_NR *\n\t\t\t  (sizeof(\"no-overwrite\") - 1)];\n\n\tconfig_terms_list(static_terms, sizeof(static_terms));\n\t \n\tif (additional_terms) {\n\t\tif (asprintf(&str, \"valid terms: %s,%s\",\n\t\t\t     additional_terms, static_terms) < 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tif (asprintf(&str, \"valid terms: %s\", static_terms) < 0)\n\t\t\tgoto fail;\n\t}\n\treturn str;\n\nfail:\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}