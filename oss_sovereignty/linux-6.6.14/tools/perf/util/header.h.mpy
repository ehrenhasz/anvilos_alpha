{
  "module_name": "header.h",
  "hash_id": "42935de031f63e58e014778a35480d6fee872dc73e95d040fdf9c2b169622843",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/header.h",
  "human_readable_source": " \n#ifndef __PERF_HEADER_H\n#define __PERF_HEADER_H\n\n#include <linux/stddef.h>\n#include <linux/perf_event.h>\n#include <sys/types.h>\n#include <stdio.h> \n#include <stdbool.h>\n#include <linux/bitmap.h>\n#include <linux/types.h>\n#include \"env.h\"\n#include \"pmu.h\"\n\nenum {\n\tHEADER_RESERVED\t\t= 0,\t \n\tHEADER_FIRST_FEATURE\t= 1,\n\tHEADER_TRACING_DATA\t= 1,\n\tHEADER_BUILD_ID,\n\n\tHEADER_HOSTNAME,\n\tHEADER_OSRELEASE,\n\tHEADER_VERSION,\n\tHEADER_ARCH,\n\tHEADER_NRCPUS,\n\tHEADER_CPUDESC,\n\tHEADER_CPUID,\n\tHEADER_TOTAL_MEM,\n\tHEADER_CMDLINE,\n\tHEADER_EVENT_DESC,\n\tHEADER_CPU_TOPOLOGY,\n\tHEADER_NUMA_TOPOLOGY,\n\tHEADER_BRANCH_STACK,\n\tHEADER_PMU_MAPPINGS,\n\tHEADER_GROUP_DESC,\n\tHEADER_AUXTRACE,\n\tHEADER_STAT,\n\tHEADER_CACHE,\n\tHEADER_SAMPLE_TIME,\n\tHEADER_MEM_TOPOLOGY,\n\tHEADER_CLOCKID,\n\tHEADER_DIR_FORMAT,\n\tHEADER_BPF_PROG_INFO,\n\tHEADER_BPF_BTF,\n\tHEADER_COMPRESSED,\n\tHEADER_CPU_PMU_CAPS,\n\tHEADER_CLOCK_DATA,\n\tHEADER_HYBRID_TOPOLOGY,\n\tHEADER_PMU_CAPS,\n\tHEADER_LAST_FEATURE,\n\tHEADER_FEAT_BITS\t= 256,\n};\n\nenum perf_header_version {\n\tPERF_HEADER_VERSION_1,\n\tPERF_HEADER_VERSION_2,\n};\n\nstruct perf_file_section {\n\tu64 offset;\n\tu64 size;\n};\n\nstruct perf_file_header {\n\tu64\t\t\t\tmagic;\n\tu64\t\t\t\tsize;\n\tu64\t\t\t\tattr_size;\n\tstruct perf_file_section\tattrs;\n\tstruct perf_file_section\tdata;\n\t \n\tstruct perf_file_section\tevent_types;\n\tDECLARE_BITMAP(adds_features, HEADER_FEAT_BITS);\n};\n\nstruct perf_pipe_file_header {\n\tu64\t\t\t\tmagic;\n\tu64\t\t\t\tsize;\n};\n\nstruct perf_header;\n\nint perf_file_header__read(struct perf_file_header *header,\n\t\t\t   struct perf_header *ph, int fd);\n\nstruct perf_header {\n\tenum perf_header_version\tversion;\n\tbool\t\t\t\tneeds_swap;\n\tu64\t\t\t\tdata_offset;\n\tu64\t\t\t\tdata_size;\n\tu64\t\t\t\tfeat_offset;\n\tDECLARE_BITMAP(adds_features, HEADER_FEAT_BITS);\n\tstruct perf_env \tenv;\n};\n\nstruct feat_fd {\n\tstruct perf_header *ph;\n\tint\t\t   fd;\n\tvoid\t\t   *buf;\t \n\tssize_t\t\t   offset;\n\tsize_t\t\t   size;\n\tstruct evsel\t   *events;\n};\n\nstruct perf_header_feature_ops {\n\tint\t   (*write)(struct feat_fd *ff, struct evlist *evlist);\n\tvoid\t   (*print)(struct feat_fd *ff, FILE *fp);\n\tint\t   (*process)(struct feat_fd *ff, void *data);\n\tconst char *name;\n\tbool\t   full_only;\n\tbool\t   synthesize;\n};\n\nstruct evlist;\nstruct perf_session;\nstruct perf_tool;\nunion perf_event;\n\nextern const char perf_version_string[];\n\nint perf_session__read_header(struct perf_session *session, int repipe_fd);\nint perf_session__write_header(struct perf_session *session,\n\t\t\t       struct evlist *evlist,\n\t\t\t       int fd, bool at_exit);\nint perf_header__write_pipe(int fd);\n\n \nstruct feat_writer {\n\tint (*write)(struct feat_writer *fw, void *buf, size_t sz);\n};\n\n \nstruct feat_copier {\n\tint (*copy)(struct feat_copier *fc, int feat, struct feat_writer *fw);\n};\n\nint perf_session__inject_header(struct perf_session *session,\n\t\t\t\tstruct evlist *evlist,\n\t\t\t\tint fd,\n\t\t\t\tstruct feat_copier *fc);\n\nsize_t perf_session__data_offset(const struct evlist *evlist);\n\nvoid perf_header__set_feat(struct perf_header *header, int feat);\nvoid perf_header__clear_feat(struct perf_header *header, int feat);\nbool perf_header__has_feat(const struct perf_header *header, int feat);\n\nint perf_header__set_cmdline(int argc, const char **argv);\n\nint perf_header__process_sections(struct perf_header *header, int fd,\n\t\t\t\t  void *data,\n\t\t\t\t  int (*process)(struct perf_file_section *section,\n\t\t\t\t  struct perf_header *ph,\n\t\t\t\t  int feat, int fd, void *data));\n\nint perf_header__fprintf_info(struct perf_session *s, FILE *fp, bool full);\n\nint perf_event__process_feature(struct perf_session *session,\n\t\t\t\tunion perf_event *event);\nint perf_event__process_attr(struct perf_tool *tool, union perf_event *event,\n\t\t\t     struct evlist **pevlist);\nint perf_event__process_event_update(struct perf_tool *tool,\n\t\t\t\t     union perf_event *event,\n\t\t\t\t     struct evlist **pevlist);\nsize_t perf_event__fprintf_event_update(union perf_event *event, FILE *fp);\n#ifdef HAVE_LIBTRACEEVENT\nint perf_event__process_tracing_data(struct perf_session *session,\n\t\t\t\t     union perf_event *event);\n#endif\nint perf_event__process_build_id(struct perf_session *session,\n\t\t\t\t union perf_event *event);\nbool is_perf_magic(u64 magic);\n\n#define NAME_ALIGN 64\n\nstruct feat_fd;\n\nint do_write(struct feat_fd *fd, const void *buf, size_t size);\n\nint write_padded(struct feat_fd *fd, const void *bf,\n\t\t size_t count, size_t count_aligned);\n\n#define MAX_CACHE_LVL 4\n\nint is_cpu_online(unsigned int cpu);\nint build_caches_for_cpu(u32 cpu, struct cpu_cache_level caches[], u32 *cntp);\n\n \nint get_cpuid(char *buffer, size_t sz);\n\nchar *get_cpuid_str(struct perf_pmu *pmu __maybe_unused);\nint strcmp_cpuid_str(const char *s1, const char *s2);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}