{
  "module_name": "auxtrace.h",
  "hash_id": "cceaa6c6062d00668c72c218f5681285a74c018dd01b9449cfc18d5c6b081cd2",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/auxtrace.h",
  "human_readable_source": " \n \n\n#ifndef __PERF_AUXTRACE_H\n#define __PERF_AUXTRACE_H\n\n#include <sys/types.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h> \n#include <linux/list.h>\n#include <linux/perf_event.h>\n#include <linux/types.h>\n#include <perf/cpumap.h>\n#include <asm/bitsperlong.h>\n#include <asm/barrier.h>\n\nunion perf_event;\nstruct perf_session;\nstruct evlist;\nstruct evsel;\nstruct perf_tool;\nstruct mmap;\nstruct perf_sample;\nstruct option;\nstruct record_opts;\nstruct perf_record_auxtrace_error;\nstruct perf_record_auxtrace_info;\nstruct events_stats;\nstruct perf_pmu;\n\nenum auxtrace_error_type {\n       PERF_AUXTRACE_ERROR_ITRACE  = 1,\n       PERF_AUXTRACE_ERROR_MAX\n};\n\n \n#define PERF_AUXTRACE_RECORD_ALIGNMENT 8\n\nenum auxtrace_type {\n\tPERF_AUXTRACE_UNKNOWN,\n\tPERF_AUXTRACE_INTEL_PT,\n\tPERF_AUXTRACE_INTEL_BTS,\n\tPERF_AUXTRACE_CS_ETM,\n\tPERF_AUXTRACE_ARM_SPE,\n\tPERF_AUXTRACE_S390_CPUMSF,\n\tPERF_AUXTRACE_HISI_PTT,\n};\n\nenum itrace_period_type {\n\tPERF_ITRACE_PERIOD_INSTRUCTIONS,\n\tPERF_ITRACE_PERIOD_TICKS,\n\tPERF_ITRACE_PERIOD_NANOSECS,\n};\n\n#define AUXTRACE_ERR_FLG_OVERFLOW\t(1 << ('o' - 'a'))\n#define AUXTRACE_ERR_FLG_DATA_LOST\t(1 << ('l' - 'a'))\n\n#define AUXTRACE_LOG_FLG_ALL_PERF_EVTS\t(1 << ('a' - 'a'))\n#define AUXTRACE_LOG_FLG_ON_ERROR\t(1 << ('e' - 'a'))\n#define AUXTRACE_LOG_FLG_USE_STDOUT\t(1 << ('o' - 'a'))\n\n \nstruct itrace_synth_opts {\n\tbool\t\t\tset;\n\tbool\t\t\tdefault_no_sample;\n\tbool\t\t\tinject;\n\tbool\t\t\tinstructions;\n\tbool\t\t\tcycles;\n\tbool\t\t\tbranches;\n\tbool\t\t\ttransactions;\n\tbool\t\t\tptwrites;\n\tbool\t\t\tpwr_events;\n\tbool\t\t\tother_events;\n\tbool\t\t\tintr_events;\n\tbool\t\t\terrors;\n\tbool\t\t\tdont_decode;\n\tbool\t\t\tlog;\n\tbool\t\t\tcalls;\n\tbool\t\t\treturns;\n\tbool\t\t\tcallchain;\n\tbool\t\t\tadd_callchain;\n\tbool\t\t\tthread_stack;\n\tbool\t\t\tlast_branch;\n\tbool\t\t\tadd_last_branch;\n\tbool\t\t\tapprox_ipc;\n\tbool\t\t\tflc;\n\tbool\t\t\tllc;\n\tbool\t\t\ttlb;\n\tbool\t\t\tremote_access;\n\tbool\t\t\tmem;\n\tbool\t\t\ttimeless_decoding;\n\tbool\t\t\tvm_time_correlation;\n\tbool\t\t\tvm_tm_corr_dry_run;\n\tchar\t\t\t*vm_tm_corr_args;\n\tunsigned int\t\tcallchain_sz;\n\tunsigned int\t\tlast_branch_sz;\n\tunsigned long long\tperiod;\n\tenum itrace_period_type\tperiod_type;\n\tunsigned long\t\tinitial_skip;\n\tunsigned long\t\t*cpu_bitmap;\n\tstruct perf_time_interval *ptime_range;\n\tint\t\t\trange_num;\n\tunsigned int\t\terror_plus_flags;\n\tunsigned int\t\terror_minus_flags;\n\tunsigned int\t\tlog_plus_flags;\n\tunsigned int\t\tlog_minus_flags;\n\tunsigned int\t\tquick;\n\tunsigned int\t\tlog_on_error_size;\n};\n\n \nstruct auxtrace_index_entry {\n\tu64\t\t\tfile_offset;\n\tu64\t\t\tsz;\n};\n\n#define PERF_AUXTRACE_INDEX_ENTRY_COUNT 256\n\n \nstruct auxtrace_index {\n\tstruct list_head\tlist;\n\tsize_t\t\t\tnr;\n\tstruct auxtrace_index_entry entries[PERF_AUXTRACE_INDEX_ENTRY_COUNT];\n};\n\n \nstruct auxtrace {\n\tint (*process_event)(struct perf_session *session,\n\t\t\t     union perf_event *event,\n\t\t\t     struct perf_sample *sample,\n\t\t\t     struct perf_tool *tool);\n\tint (*process_auxtrace_event)(struct perf_session *session,\n\t\t\t\t      union perf_event *event,\n\t\t\t\t      struct perf_tool *tool);\n\tint (*queue_data)(struct perf_session *session,\n\t\t\t  struct perf_sample *sample, union perf_event *event,\n\t\t\t  u64 data_offset);\n\tvoid (*dump_auxtrace_sample)(struct perf_session *session,\n\t\t\t\t     struct perf_sample *sample);\n\tint (*flush_events)(struct perf_session *session,\n\t\t\t    struct perf_tool *tool);\n\tvoid (*free_events)(struct perf_session *session);\n\tvoid (*free)(struct perf_session *session);\n\tbool (*evsel_is_auxtrace)(struct perf_session *session,\n\t\t\t\t  struct evsel *evsel);\n};\n\n \nstruct auxtrace_buffer {\n\tstruct list_head\tlist;\n\tsize_t\t\t\tsize;\n\tpid_t\t\t\tpid;\n\tpid_t\t\t\ttid;\n\tstruct perf_cpu\t\tcpu;\n\tvoid\t\t\t*data;\n\toff_t\t\t\tdata_offset;\n\tvoid\t\t\t*mmap_addr;\n\tsize_t\t\t\tmmap_size;\n\tbool\t\t\tdata_needs_freeing;\n\tbool\t\t\tconsecutive;\n\tu64\t\t\toffset;\n\tu64\t\t\treference;\n\tu64\t\t\tbuffer_nr;\n\tsize_t\t\t\tuse_size;\n\tvoid\t\t\t*use_data;\n};\n\n \nstruct auxtrace_queue {\n\tstruct list_head\thead;\n\tpid_t\t\t\ttid;\n\tint\t\t\tcpu;\n\tbool\t\t\tset;\n\tvoid\t\t\t*priv;\n};\n\n \nstruct auxtrace_queues {\n\tstruct auxtrace_queue\t*queue_array;\n\tunsigned int\t\tnr_queues;\n\tbool\t\t\tnew_data;\n\tbool\t\t\tpopulated;\n\tu64\t\t\tnext_buffer_nr;\n};\n\n \nstruct auxtrace_heap_item {\n\tunsigned int\t\tqueue_nr;\n\tu64\t\t\tordinal;\n};\n\n \nstruct auxtrace_heap {\n\tstruct auxtrace_heap_item\t*heap_array;\n\tunsigned int\t\theap_cnt;\n\tunsigned int\t\theap_sz;\n};\n\n \nstruct auxtrace_mmap {\n\tvoid\t\t*base;\n\tvoid\t\t*userpg;\n\tsize_t\t\tmask;\n\tsize_t\t\tlen;\n\tu64\t\tprev;\n\tint\t\tidx;\n\tpid_t\t\ttid;\n\tint\t\tcpu;\n};\n\n \nstruct auxtrace_mmap_params {\n\tsize_t\t\tmask;\n\toff_t\t\toffset;\n\tsize_t\t\tlen;\n\tint\t\tprot;\n\tint\t\tidx;\n\tpid_t\t\ttid;\n\tbool\t\tmmap_needed;\n\tstruct perf_cpu\tcpu;\n};\n\n \nstruct auxtrace_record {\n\tint (*recording_options)(struct auxtrace_record *itr,\n\t\t\t\t struct evlist *evlist,\n\t\t\t\t struct record_opts *opts);\n\tsize_t (*info_priv_size)(struct auxtrace_record *itr,\n\t\t\t\t struct evlist *evlist);\n\tint (*info_fill)(struct auxtrace_record *itr,\n\t\t\t struct perf_session *session,\n\t\t\t struct perf_record_auxtrace_info *auxtrace_info,\n\t\t\t size_t priv_size);\n\tvoid (*free)(struct auxtrace_record *itr);\n\tint (*snapshot_start)(struct auxtrace_record *itr);\n\tint (*snapshot_finish)(struct auxtrace_record *itr);\n\tint (*find_snapshot)(struct auxtrace_record *itr, int idx,\n\t\t\t     struct auxtrace_mmap *mm, unsigned char *data,\n\t\t\t     u64 *head, u64 *old);\n\tint (*parse_snapshot_options)(struct auxtrace_record *itr,\n\t\t\t\t      struct record_opts *opts,\n\t\t\t\t      const char *str);\n\tu64 (*reference)(struct auxtrace_record *itr);\n\tint (*read_finish)(struct auxtrace_record *itr, int idx);\n\tunsigned int alignment;\n\tunsigned int default_aux_sample_size;\n\tstruct perf_pmu *pmu;\n\tstruct evlist *evlist;\n};\n\n \nstruct addr_filter {\n\tstruct list_head\tlist;\n\tbool\t\t\trange;\n\tbool\t\t\tstart;\n\tconst char\t\t*action;\n\tconst char\t\t*sym_from;\n\tconst char\t\t*sym_to;\n\tint\t\t\tsym_from_idx;\n\tint\t\t\tsym_to_idx;\n\tu64\t\t\taddr;\n\tu64\t\t\tsize;\n\tconst char\t\t*filename;\n\tchar\t\t\t*str;\n};\n\n \nstruct addr_filters {\n\tstruct list_head\thead;\n\tint\t\t\tcnt;\n};\n\nstruct auxtrace_cache;\n\n#ifdef HAVE_AUXTRACE_SUPPORT\n\nu64 compat_auxtrace_mmap__read_head(struct auxtrace_mmap *mm);\nint compat_auxtrace_mmap__write_tail(struct auxtrace_mmap *mm, u64 tail);\n\nstatic inline u64 auxtrace_mmap__read_head(struct auxtrace_mmap *mm,\n\t\t\t\t\t   int kernel_is_64_bit __maybe_unused)\n{\n\tstruct perf_event_mmap_page *pc = mm->userpg;\n\tu64 head;\n\n#if BITS_PER_LONG == 32\n\tif (kernel_is_64_bit)\n\t\treturn compat_auxtrace_mmap__read_head(mm);\n#endif\n\thead = READ_ONCE(pc->aux_head);\n\n\t \n\tsmp_rmb();\n\treturn head;\n}\n\nstatic inline int auxtrace_mmap__write_tail(struct auxtrace_mmap *mm, u64 tail,\n\t\t\t\t\t    int kernel_is_64_bit __maybe_unused)\n{\n\tstruct perf_event_mmap_page *pc = mm->userpg;\n\n#if BITS_PER_LONG == 32\n\tif (kernel_is_64_bit)\n\t\treturn compat_auxtrace_mmap__write_tail(mm, tail);\n#endif\n\t \n\tsmp_mb();\n\tWRITE_ONCE(pc->aux_tail, tail);\n\treturn 0;\n}\n\nint auxtrace_mmap__mmap(struct auxtrace_mmap *mm,\n\t\t\tstruct auxtrace_mmap_params *mp,\n\t\t\tvoid *userpg, int fd);\nvoid auxtrace_mmap__munmap(struct auxtrace_mmap *mm);\nvoid auxtrace_mmap_params__init(struct auxtrace_mmap_params *mp,\n\t\t\t\toff_t auxtrace_offset,\n\t\t\t\tunsigned int auxtrace_pages,\n\t\t\t\tbool auxtrace_overwrite);\nvoid auxtrace_mmap_params__set_idx(struct auxtrace_mmap_params *mp,\n\t\t\t\t   struct evlist *evlist,\n\t\t\t\t   struct evsel *evsel, int idx);\n\ntypedef int (*process_auxtrace_t)(struct perf_tool *tool,\n\t\t\t\t  struct mmap *map,\n\t\t\t\t  union perf_event *event, void *data1,\n\t\t\t\t  size_t len1, void *data2, size_t len2);\n\nint auxtrace_mmap__read(struct mmap *map, struct auxtrace_record *itr,\n\t\t\tstruct perf_tool *tool, process_auxtrace_t fn);\n\nint auxtrace_mmap__read_snapshot(struct mmap *map,\n\t\t\t\t struct auxtrace_record *itr,\n\t\t\t\t struct perf_tool *tool, process_auxtrace_t fn,\n\t\t\t\t size_t snapshot_size);\n\nint auxtrace_queues__init(struct auxtrace_queues *queues);\nint auxtrace_queues__add_event(struct auxtrace_queues *queues,\n\t\t\t       struct perf_session *session,\n\t\t\t       union perf_event *event, off_t data_offset,\n\t\t\t       struct auxtrace_buffer **buffer_ptr);\nstruct auxtrace_queue *\nauxtrace_queues__sample_queue(struct auxtrace_queues *queues,\n\t\t\t      struct perf_sample *sample,\n\t\t\t      struct perf_session *session);\nint auxtrace_queues__add_sample(struct auxtrace_queues *queues,\n\t\t\t\tstruct perf_session *session,\n\t\t\t\tstruct perf_sample *sample, u64 data_offset,\n\t\t\t\tu64 reference);\nvoid auxtrace_queues__free(struct auxtrace_queues *queues);\nint auxtrace_queues__process_index(struct auxtrace_queues *queues,\n\t\t\t\t   struct perf_session *session);\nint auxtrace_queue_data(struct perf_session *session, bool samples,\n\t\t\tbool events);\nstruct auxtrace_buffer *auxtrace_buffer__next(struct auxtrace_queue *queue,\n\t\t\t\t\t      struct auxtrace_buffer *buffer);\nvoid *auxtrace_buffer__get_data_rw(struct auxtrace_buffer *buffer, int fd, bool rw);\nstatic inline void *auxtrace_buffer__get_data(struct auxtrace_buffer *buffer, int fd)\n{\n\treturn auxtrace_buffer__get_data_rw(buffer, fd, false);\n}\nvoid auxtrace_buffer__put_data(struct auxtrace_buffer *buffer);\nvoid auxtrace_buffer__drop_data(struct auxtrace_buffer *buffer);\nvoid auxtrace_buffer__free(struct auxtrace_buffer *buffer);\n\nint auxtrace_heap__add(struct auxtrace_heap *heap, unsigned int queue_nr,\n\t\t       u64 ordinal);\nvoid auxtrace_heap__pop(struct auxtrace_heap *heap);\nvoid auxtrace_heap__free(struct auxtrace_heap *heap);\n\nstruct auxtrace_cache_entry {\n\tstruct hlist_node hash;\n\tu32 key;\n};\n\nstruct auxtrace_cache *auxtrace_cache__new(unsigned int bits, size_t entry_size,\n\t\t\t\t\t   unsigned int limit_percent);\nvoid auxtrace_cache__free(struct auxtrace_cache *auxtrace_cache);\nvoid *auxtrace_cache__alloc_entry(struct auxtrace_cache *c);\nvoid auxtrace_cache__free_entry(struct auxtrace_cache *c, void *entry);\nint auxtrace_cache__add(struct auxtrace_cache *c, u32 key,\n\t\t\tstruct auxtrace_cache_entry *entry);\nvoid auxtrace_cache__remove(struct auxtrace_cache *c, u32 key);\nvoid *auxtrace_cache__lookup(struct auxtrace_cache *c, u32 key);\n\nstruct auxtrace_record *auxtrace_record__init(struct evlist *evlist,\n\t\t\t\t\t      int *err);\n\nint auxtrace_parse_snapshot_options(struct auxtrace_record *itr,\n\t\t\t\t    struct record_opts *opts,\n\t\t\t\t    const char *str);\nint auxtrace_parse_sample_options(struct auxtrace_record *itr,\n\t\t\t\t  struct evlist *evlist,\n\t\t\t\t  struct record_opts *opts, const char *str);\nvoid auxtrace_regroup_aux_output(struct evlist *evlist);\nint auxtrace_record__options(struct auxtrace_record *itr,\n\t\t\t     struct evlist *evlist,\n\t\t\t     struct record_opts *opts);\nsize_t auxtrace_record__info_priv_size(struct auxtrace_record *itr,\n\t\t\t\t       struct evlist *evlist);\nint auxtrace_record__info_fill(struct auxtrace_record *itr,\n\t\t\t       struct perf_session *session,\n\t\t\t       struct perf_record_auxtrace_info *auxtrace_info,\n\t\t\t       size_t priv_size);\nvoid auxtrace_record__free(struct auxtrace_record *itr);\nint auxtrace_record__snapshot_start(struct auxtrace_record *itr);\nint auxtrace_record__snapshot_finish(struct auxtrace_record *itr, bool on_exit);\nint auxtrace_record__find_snapshot(struct auxtrace_record *itr, int idx,\n\t\t\t\t   struct auxtrace_mmap *mm,\n\t\t\t\t   unsigned char *data, u64 *head, u64 *old);\nu64 auxtrace_record__reference(struct auxtrace_record *itr);\nint auxtrace_record__read_finish(struct auxtrace_record *itr, int idx);\n\nint auxtrace_index__auxtrace_event(struct list_head *head, union perf_event *event,\n\t\t\t\t   off_t file_offset);\nint auxtrace_index__write(int fd, struct list_head *head);\nint auxtrace_index__process(int fd, u64 size, struct perf_session *session,\n\t\t\t    bool needs_swap);\nvoid auxtrace_index__free(struct list_head *head);\n\nvoid auxtrace_synth_guest_error(struct perf_record_auxtrace_error *auxtrace_error, int type,\n\t\t\t\tint code, int cpu, pid_t pid, pid_t tid, u64 ip,\n\t\t\t\tconst char *msg, u64 timestamp,\n\t\t\t\tpid_t machine_pid, int vcpu);\nvoid auxtrace_synth_error(struct perf_record_auxtrace_error *auxtrace_error, int type,\n\t\t\t  int code, int cpu, pid_t pid, pid_t tid, u64 ip,\n\t\t\t  const char *msg, u64 timestamp);\n\nint perf_event__process_auxtrace_info(struct perf_session *session,\n\t\t\t\t      union perf_event *event);\ns64 perf_event__process_auxtrace(struct perf_session *session,\n\t\t\t\t union perf_event *event);\nint perf_event__process_auxtrace_error(struct perf_session *session,\n\t\t\t\t       union perf_event *event);\nint itrace_do_parse_synth_opts(struct itrace_synth_opts *synth_opts,\n\t\t\t       const char *str, int unset);\nint itrace_parse_synth_opts(const struct option *opt, const char *str,\n\t\t\t    int unset);\nvoid itrace_synth_opts__set_default(struct itrace_synth_opts *synth_opts,\n\t\t\t\t    bool no_sample);\n\nsize_t perf_event__fprintf_auxtrace_error(union perf_event *event, FILE *fp);\nvoid perf_session__auxtrace_error_inc(struct perf_session *session,\n\t\t\t\t      union perf_event *event);\nvoid events_stats__auxtrace_error_warn(const struct events_stats *stats);\n\nvoid addr_filters__init(struct addr_filters *filts);\nvoid addr_filters__exit(struct addr_filters *filts);\nint addr_filters__parse_bare_filter(struct addr_filters *filts,\n\t\t\t\t    const char *filter);\nint auxtrace_parse_filters(struct evlist *evlist);\n\nint auxtrace__process_event(struct perf_session *session, union perf_event *event,\n\t\t\t    struct perf_sample *sample, struct perf_tool *tool);\nvoid auxtrace__dump_auxtrace_sample(struct perf_session *session,\n\t\t\t\t    struct perf_sample *sample);\nint auxtrace__flush_events(struct perf_session *session, struct perf_tool *tool);\nvoid auxtrace__free_events(struct perf_session *session);\nvoid auxtrace__free(struct perf_session *session);\nbool auxtrace__evsel_is_auxtrace(struct perf_session *session,\n\t\t\t\t struct evsel *evsel);\n\n#define ITRACE_HELP \\\n\"\t\t\t\ti[period]:    \t\tsynthesize instructions events\\n\" \\\n\"\t\t\t\ty[period]:    \t\tsynthesize cycles events (same period as i)\\n\" \\\n\"\t\t\t\tb:\t    \t\tsynthesize branches events (branch misses for Arm SPE)\\n\" \\\n\"\t\t\t\tc:\t    \t\tsynthesize branches events (calls only)\\n\"\t\\\n\"\t\t\t\tr:\t    \t\tsynthesize branches events (returns only)\\n\" \\\n\"\t\t\t\tx:\t    \t\tsynthesize transactions events\\n\"\t\t\\\n\"\t\t\t\tw:\t    \t\tsynthesize ptwrite events\\n\"\t\t\\\n\"\t\t\t\tp:\t    \t\tsynthesize power events\\n\"\t\t\t\\\n\"\t\t\t\to:\t\t\tsynthesize other events recorded due to the use\\n\" \\\n\"\t\t\t\t\t\t\tof aux-output (refer to perf record)\\n\"\t\\\n\"\t\t\t\tI:\t\t\tsynthesize interrupt or similar (asynchronous) events\\n\" \\\n\"\t\t\t\t\t\t\t(e.g. Intel PT Event Trace)\\n\" \\\n\"\t\t\t\te[flags]:\t\tsynthesize error events\\n\" \\\n\"\t\t\t\t\t\t\teach flag must be preceded by + or -\\n\" \\\n\"\t\t\t\t\t\t\terror flags are: o (overflow)\\n\" \\\n\"\t\t\t\t\t\t\t\t\t l (data lost)\\n\" \\\n\"\t\t\t\td[flags]:\t\tcreate a debug log\\n\" \\\n\"\t\t\t\t\t\t\teach flag must be preceded by + or -\\n\" \\\n\"\t\t\t\t\t\t\tlog flags are: a (all perf events)\\n\" \\\n\"\t\t\t\t\t\t\t               o (output to stdout)\\n\" \\\n\"\t\t\t\tf:\t    \t\tsynthesize first level cache events\\n\" \\\n\"\t\t\t\tm:\t    \t\tsynthesize last level cache events\\n\" \\\n\"\t\t\t\tt:\t    \t\tsynthesize TLB events\\n\" \\\n\"\t\t\t\ta:\t    \t\tsynthesize remote access events\\n\" \\\n\"\t\t\t\tg[len]:     \t\tsynthesize a call chain (use with i or x)\\n\" \\\n\"\t\t\t\tG[len]:\t\t\tsynthesize a call chain on existing event records\\n\" \\\n\"\t\t\t\tl[len]:     \t\tsynthesize last branch entries (use with i or x)\\n\" \\\n\"\t\t\t\tL[len]:\t\t\tsynthesize last branch entries on existing event records\\n\" \\\n\"\t\t\t\tsNUMBER:    \t\tskip initial number of events\\n\"\t\t\\\n\"\t\t\t\tq:\t\t\tquicker (less detailed) decoding\\n\" \\\n\"\t\t\t\tA:\t\t\tapproximate IPC\\n\" \\\n\"\t\t\t\tZ:\t\t\tprefer to ignore timestamps (so-called \\\"timeless\\\" decoding)\\n\" \\\n\"\t\t\t\tPERIOD[ns|us|ms|i|t]:   specify period to sample stream\\n\" \\\n\"\t\t\t\tconcatenate multiple options. Default is iybxwpe or cewp\\n\"\n\nstatic inline\nvoid itrace_synth_opts__set_time_range(struct itrace_synth_opts *opts,\n\t\t\t\t       struct perf_time_interval *ptime_range,\n\t\t\t\t       int range_num)\n{\n\topts->ptime_range = ptime_range;\n\topts->range_num = range_num;\n}\n\nstatic inline\nvoid itrace_synth_opts__clear_time_range(struct itrace_synth_opts *opts)\n{\n\topts->ptime_range = NULL;\n\topts->range_num = 0;\n}\n\n#else\n#include \"debug.h\"\n\nstatic inline struct auxtrace_record *\nauxtrace_record__init(struct evlist *evlist __maybe_unused,\n\t\t      int *err)\n{\n\t*err = 0;\n\treturn NULL;\n}\n\nstatic inline\nvoid auxtrace_record__free(struct auxtrace_record *itr __maybe_unused)\n{\n}\n\nstatic inline\nint auxtrace_record__options(struct auxtrace_record *itr __maybe_unused,\n\t\t\t     struct evlist *evlist __maybe_unused,\n\t\t\t     struct record_opts *opts __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline\nint perf_event__process_auxtrace_info(struct perf_session *session __maybe_unused,\n\t\t\t\t      union perf_event *event __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline\ns64 perf_event__process_auxtrace(struct perf_session *session __maybe_unused,\n\t\t\t\t union perf_event *event __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline\nint perf_event__process_auxtrace_error(struct perf_session *session __maybe_unused,\n\t\t\t\t       union perf_event *event __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline\nvoid perf_session__auxtrace_error_inc(struct perf_session *session\n\t\t\t\t      __maybe_unused,\n\t\t\t\t      union perf_event *event\n\t\t\t\t      __maybe_unused)\n{\n}\n\nstatic inline\nvoid events_stats__auxtrace_error_warn(const struct events_stats *stats\n\t\t\t\t       __maybe_unused)\n{\n}\n\nstatic inline\nint itrace_do_parse_synth_opts(struct itrace_synth_opts *synth_opts __maybe_unused,\n\t\t\t       const char *str __maybe_unused, int unset __maybe_unused)\n{\n\tpr_err(\"AUX area tracing not supported\\n\");\n\treturn -EINVAL;\n}\n\nstatic inline\nint itrace_parse_synth_opts(const struct option *opt __maybe_unused,\n\t\t\t    const char *str __maybe_unused,\n\t\t\t    int unset __maybe_unused)\n{\n\tpr_err(\"AUX area tracing not supported\\n\");\n\treturn -EINVAL;\n}\n\nstatic inline\nint auxtrace_parse_snapshot_options(struct auxtrace_record *itr __maybe_unused,\n\t\t\t\t    struct record_opts *opts __maybe_unused,\n\t\t\t\t    const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tpr_err(\"AUX area tracing not supported\\n\");\n\treturn -EINVAL;\n}\n\nstatic inline\nint auxtrace_parse_sample_options(struct auxtrace_record *itr __maybe_unused,\n\t\t\t\t  struct evlist *evlist __maybe_unused,\n\t\t\t\t  struct record_opts *opts __maybe_unused,\n\t\t\t\t  const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tpr_err(\"AUX area tracing not supported\\n\");\n\treturn -EINVAL;\n}\n\nstatic inline\nvoid auxtrace_regroup_aux_output(struct evlist *evlist __maybe_unused)\n{\n}\n\nstatic inline\nint auxtrace__process_event(struct perf_session *session __maybe_unused,\n\t\t\t    union perf_event *event __maybe_unused,\n\t\t\t    struct perf_sample *sample __maybe_unused,\n\t\t\t    struct perf_tool *tool __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline\nvoid auxtrace__dump_auxtrace_sample(struct perf_session *session __maybe_unused,\n\t\t\t\t    struct perf_sample *sample __maybe_unused)\n{\n}\n\nstatic inline\nint auxtrace__flush_events(struct perf_session *session __maybe_unused,\n\t\t\t   struct perf_tool *tool __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic inline\nvoid auxtrace__free_events(struct perf_session *session __maybe_unused)\n{\n}\n\nstatic inline\nvoid auxtrace_cache__free(struct auxtrace_cache *auxtrace_cache __maybe_unused)\n{\n}\n\nstatic inline\nvoid auxtrace__free(struct perf_session *session __maybe_unused)\n{\n}\n\nstatic inline\nint auxtrace_index__write(int fd __maybe_unused,\n\t\t\t  struct list_head *head __maybe_unused)\n{\n\treturn -EINVAL;\n}\n\nstatic inline\nint auxtrace_index__process(int fd __maybe_unused,\n\t\t\t    u64 size __maybe_unused,\n\t\t\t    struct perf_session *session __maybe_unused,\n\t\t\t    bool needs_swap __maybe_unused)\n{\n\treturn -EINVAL;\n}\n\nstatic inline\nvoid auxtrace_index__free(struct list_head *head __maybe_unused)\n{\n}\n\nstatic inline\nbool auxtrace__evsel_is_auxtrace(struct perf_session *session __maybe_unused,\n\t\t\t\t struct evsel *evsel __maybe_unused)\n{\n\treturn false;\n}\n\nstatic inline\nint auxtrace_parse_filters(struct evlist *evlist __maybe_unused)\n{\n\treturn 0;\n}\n\nint auxtrace_mmap__mmap(struct auxtrace_mmap *mm,\n\t\t\tstruct auxtrace_mmap_params *mp,\n\t\t\tvoid *userpg, int fd);\nvoid auxtrace_mmap__munmap(struct auxtrace_mmap *mm);\nvoid auxtrace_mmap_params__init(struct auxtrace_mmap_params *mp,\n\t\t\t\toff_t auxtrace_offset,\n\t\t\t\tunsigned int auxtrace_pages,\n\t\t\t\tbool auxtrace_overwrite);\nvoid auxtrace_mmap_params__set_idx(struct auxtrace_mmap_params *mp,\n\t\t\t\t   struct evlist *evlist,\n\t\t\t\t   struct evsel *evsel, int idx);\n\n#define ITRACE_HELP \"\"\n\nstatic inline\nvoid itrace_synth_opts__set_time_range(struct itrace_synth_opts *opts\n\t\t\t\t       __maybe_unused,\n\t\t\t\t       struct perf_time_interval *ptime_range\n\t\t\t\t       __maybe_unused,\n\t\t\t\t       int range_num __maybe_unused)\n{\n}\n\nstatic inline\nvoid itrace_synth_opts__clear_time_range(struct itrace_synth_opts *opts\n\t\t\t\t\t __maybe_unused)\n{\n}\n\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}