{
  "module_name": "synthetic-events.c",
  "hash_id": "f85d9bbec161504fdb0b33e53c942a3901c4303fe5bba1c21f1212a85f612edc",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/synthetic-events.c",
  "human_readable_source": "\n\n#include \"util/cgroup.h\"\n#include \"util/data.h\"\n#include \"util/debug.h\"\n#include \"util/dso.h\"\n#include \"util/event.h\"\n#include \"util/evlist.h\"\n#include \"util/machine.h\"\n#include \"util/map.h\"\n#include \"util/map_symbol.h\"\n#include \"util/branch.h\"\n#include \"util/memswap.h\"\n#include \"util/namespaces.h\"\n#include \"util/session.h\"\n#include \"util/stat.h\"\n#include \"util/symbol.h\"\n#include \"util/synthetic-events.h\"\n#include \"util/target.h\"\n#include \"util/time-utils.h\"\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <linux/perf_event.h>\n#include <asm/bug.h>\n#include <perf/evsel.h>\n#include <perf/cpumap.h>\n#include <internal/lib.h> \n#include <internal/threadmap.h>\n#include <perf/threadmap.h>\n#include <symbol/kallsyms.h>\n#include <dirent.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n#include <uapi/linux/mman.h>  \n#include <api/fs/fs.h>\n#include <api/io.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define DEFAULT_PROC_MAP_PARSE_TIMEOUT 500\n\nunsigned int proc_map_timeout = DEFAULT_PROC_MAP_PARSE_TIMEOUT;\n\nint perf_tool__process_synth_event(struct perf_tool *tool,\n\t\t\t\t   union perf_event *event,\n\t\t\t\t   struct machine *machine,\n\t\t\t\t   perf_event__handler_t process)\n{\n\tstruct perf_sample synth_sample = {\n\t\t.pid\t   = -1,\n\t\t.tid\t   = -1,\n\t\t.time\t   = -1,\n\t\t.stream_id = -1,\n\t\t.cpu\t   = -1,\n\t\t.period\t   = 1,\n\t\t.cpumode   = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK,\n\t};\n\n\treturn process(tool, event, &synth_sample, machine);\n};\n\n \nstatic int perf_event__get_comm_ids(pid_t pid, pid_t tid, char *comm, size_t len,\n\t\t\t\t    pid_t *tgid, pid_t *ppid, bool *kernel)\n{\n\tchar bf[4096];\n\tint fd;\n\tsize_t size = 0;\n\tssize_t n;\n\tchar *name, *tgids, *ppids, *vmpeak, *threads;\n\n\t*tgid = -1;\n\t*ppid = -1;\n\n\tif (pid)\n\t\tsnprintf(bf, sizeof(bf), \"/proc/%d/task/%d/status\", pid, tid);\n\telse\n\t\tsnprintf(bf, sizeof(bf), \"/proc/%d/status\", tid);\n\n\tfd = open(bf, O_RDONLY);\n\tif (fd < 0) {\n\t\tpr_debug(\"couldn't open %s\\n\", bf);\n\t\treturn -1;\n\t}\n\n\tn = read(fd, bf, sizeof(bf) - 1);\n\tclose(fd);\n\tif (n <= 0) {\n\t\tpr_warning(\"Couldn't get COMM, tigd and ppid for pid %d\\n\",\n\t\t\t   tid);\n\t\treturn -1;\n\t}\n\tbf[n] = '\\0';\n\n\tname = strstr(bf, \"Name:\");\n\ttgids = strstr(name ?: bf, \"Tgid:\");\n\tppids = strstr(tgids ?: bf, \"PPid:\");\n\tvmpeak = strstr(ppids ?: bf, \"VmPeak:\");\n\n\tif (vmpeak)\n\t\tthreads = NULL;\n\telse\n\t\tthreads = strstr(ppids ?: bf, \"Threads:\");\n\n\tif (name) {\n\t\tchar *nl;\n\n\t\tname = skip_spaces(name + 5);   \n\t\tnl = strchr(name, '\\n');\n\t\tif (nl)\n\t\t\t*nl = '\\0';\n\n\t\tsize = strlen(name);\n\t\tif (size >= len)\n\t\t\tsize = len - 1;\n\t\tmemcpy(comm, name, size);\n\t\tcomm[size] = '\\0';\n\t} else {\n\t\tpr_debug(\"Name: string not found for pid %d\\n\", tid);\n\t}\n\n\tif (tgids) {\n\t\ttgids += 5;   \n\t\t*tgid = atoi(tgids);\n\t} else {\n\t\tpr_debug(\"Tgid: string not found for pid %d\\n\", tid);\n\t}\n\n\tif (ppids) {\n\t\tppids += 5;   \n\t\t*ppid = atoi(ppids);\n\t} else {\n\t\tpr_debug(\"PPid: string not found for pid %d\\n\", tid);\n\t}\n\n\tif (!vmpeak && threads)\n\t\t*kernel = true;\n\telse\n\t\t*kernel = false;\n\n\treturn 0;\n}\n\nstatic int perf_event__prepare_comm(union perf_event *event, pid_t pid, pid_t tid,\n\t\t\t\t    struct machine *machine,\n\t\t\t\t    pid_t *tgid, pid_t *ppid, bool *kernel)\n{\n\tsize_t size;\n\n\t*ppid = -1;\n\n\tmemset(&event->comm, 0, sizeof(event->comm));\n\n\tif (machine__is_host(machine)) {\n\t\tif (perf_event__get_comm_ids(pid, tid, event->comm.comm,\n\t\t\t\t\t     sizeof(event->comm.comm),\n\t\t\t\t\t     tgid, ppid, kernel) != 0) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t*tgid = machine->pid;\n\t}\n\n\tif (*tgid < 0)\n\t\treturn -1;\n\n\tevent->comm.pid = *tgid;\n\tevent->comm.header.type = PERF_RECORD_COMM;\n\n\tsize = strlen(event->comm.comm) + 1;\n\tsize = PERF_ALIGN(size, sizeof(u64));\n\tmemset(event->comm.comm + size, 0, machine->id_hdr_size);\n\tevent->comm.header.size = (sizeof(event->comm) -\n\t\t\t\t(sizeof(event->comm.comm) - size) +\n\t\t\t\tmachine->id_hdr_size);\n\tevent->comm.tid = tid;\n\n\treturn 0;\n}\n\npid_t perf_event__synthesize_comm(struct perf_tool *tool,\n\t\t\t\t\t union perf_event *event, pid_t pid,\n\t\t\t\t\t perf_event__handler_t process,\n\t\t\t\t\t struct machine *machine)\n{\n\tpid_t tgid, ppid;\n\tbool kernel_thread;\n\n\tif (perf_event__prepare_comm(event, 0, pid, machine, &tgid, &ppid,\n\t\t\t\t     &kernel_thread) != 0)\n\t\treturn -1;\n\n\tif (perf_tool__process_synth_event(tool, event, machine, process) != 0)\n\t\treturn -1;\n\n\treturn tgid;\n}\n\nstatic void perf_event__get_ns_link_info(pid_t pid, const char *ns,\n\t\t\t\t\t struct perf_ns_link_info *ns_link_info)\n{\n\tstruct stat64 st;\n\tchar proc_ns[128];\n\n\tsprintf(proc_ns, \"/proc/%u/ns/%s\", pid, ns);\n\tif (stat64(proc_ns, &st) == 0) {\n\t\tns_link_info->dev = st.st_dev;\n\t\tns_link_info->ino = st.st_ino;\n\t}\n}\n\nint perf_event__synthesize_namespaces(struct perf_tool *tool,\n\t\t\t\t      union perf_event *event,\n\t\t\t\t      pid_t pid, pid_t tgid,\n\t\t\t\t      perf_event__handler_t process,\n\t\t\t\t      struct machine *machine)\n{\n\tu32 idx;\n\tstruct perf_ns_link_info *ns_link_info;\n\n\tif (!tool || !tool->namespace_events)\n\t\treturn 0;\n\n\tmemset(&event->namespaces, 0, (sizeof(event->namespaces) +\n\t       (NR_NAMESPACES * sizeof(struct perf_ns_link_info)) +\n\t       machine->id_hdr_size));\n\n\tevent->namespaces.pid = tgid;\n\tevent->namespaces.tid = pid;\n\n\tevent->namespaces.nr_namespaces = NR_NAMESPACES;\n\n\tns_link_info = event->namespaces.link_info;\n\n\tfor (idx = 0; idx < event->namespaces.nr_namespaces; idx++)\n\t\tperf_event__get_ns_link_info(pid, perf_ns__name(idx),\n\t\t\t\t\t     &ns_link_info[idx]);\n\n\tevent->namespaces.header.type = PERF_RECORD_NAMESPACES;\n\n\tevent->namespaces.header.size = (sizeof(event->namespaces) +\n\t\t\t(NR_NAMESPACES * sizeof(struct perf_ns_link_info)) +\n\t\t\tmachine->id_hdr_size);\n\n\tif (perf_tool__process_synth_event(tool, event, machine, process) != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int perf_event__synthesize_fork(struct perf_tool *tool,\n\t\t\t\t       union perf_event *event,\n\t\t\t\t       pid_t pid, pid_t tgid, pid_t ppid,\n\t\t\t\t       perf_event__handler_t process,\n\t\t\t\t       struct machine *machine)\n{\n\tmemset(&event->fork, 0, sizeof(event->fork) + machine->id_hdr_size);\n\n\t \n\tif (tgid == pid) {\n\t\tevent->fork.ppid = ppid;\n\t\tevent->fork.ptid = ppid;\n\t} else {\n\t\tevent->fork.ppid = tgid;\n\t\tevent->fork.ptid = tgid;\n\t}\n\tevent->fork.pid  = tgid;\n\tevent->fork.tid  = pid;\n\tevent->fork.header.type = PERF_RECORD_FORK;\n\tevent->fork.header.misc = PERF_RECORD_MISC_FORK_EXEC;\n\n\tevent->fork.header.size = (sizeof(event->fork) + machine->id_hdr_size);\n\n\tif (perf_tool__process_synth_event(tool, event, machine, process) != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic bool read_proc_maps_line(struct io *io, __u64 *start, __u64 *end,\n\t\t\t\tu32 *prot, u32 *flags, __u64 *offset,\n\t\t\t\tu32 *maj, u32 *min,\n\t\t\t\t__u64 *inode,\n\t\t\t\tssize_t pathname_size, char *pathname)\n{\n\t__u64 temp;\n\tint ch;\n\tchar *start_pathname = pathname;\n\n\tif (io__get_hex(io, start) != '-')\n\t\treturn false;\n\tif (io__get_hex(io, end) != ' ')\n\t\treturn false;\n\n\t \n\t*prot = 0;\n\tch = io__get_char(io);\n\tif (ch == 'r')\n\t\t*prot |= PROT_READ;\n\telse if (ch != '-')\n\t\treturn false;\n\tch = io__get_char(io);\n\tif (ch == 'w')\n\t\t*prot |= PROT_WRITE;\n\telse if (ch != '-')\n\t\treturn false;\n\tch = io__get_char(io);\n\tif (ch == 'x')\n\t\t*prot |= PROT_EXEC;\n\telse if (ch != '-')\n\t\treturn false;\n\tch = io__get_char(io);\n\tif (ch == 's')\n\t\t*flags = MAP_SHARED;\n\telse if (ch == 'p')\n\t\t*flags = MAP_PRIVATE;\n\telse\n\t\treturn false;\n\tif (io__get_char(io) != ' ')\n\t\treturn false;\n\n\tif (io__get_hex(io, offset) != ' ')\n\t\treturn false;\n\n\tif (io__get_hex(io, &temp) != ':')\n\t\treturn false;\n\t*maj = temp;\n\tif (io__get_hex(io, &temp) != ' ')\n\t\treturn false;\n\t*min = temp;\n\n\tch = io__get_dec(io, inode);\n\tif (ch != ' ') {\n\t\t*pathname = '\\0';\n\t\treturn ch == '\\n';\n\t}\n\tdo {\n\t\tch = io__get_char(io);\n\t} while (ch == ' ');\n\twhile (true) {\n\t\tif (ch < 0)\n\t\t\treturn false;\n\t\tif (ch == '\\0' || ch == '\\n' ||\n\t\t    (pathname + 1 - start_pathname) >= pathname_size) {\n\t\t\t*pathname = '\\0';\n\t\t\treturn true;\n\t\t}\n\t\t*pathname++ = ch;\n\t\tch = io__get_char(io);\n\t}\n}\n\nstatic void perf_record_mmap2__read_build_id(struct perf_record_mmap2 *event,\n\t\t\t\t\t     struct machine *machine,\n\t\t\t\t\t     bool is_kernel)\n{\n\tstruct build_id bid;\n\tstruct nsinfo *nsi;\n\tstruct nscookie nc;\n\tstruct dso *dso = NULL;\n\tstruct dso_id id;\n\tint rc;\n\n\tif (is_kernel) {\n\t\trc = sysfs__read_build_id(\"/sys/kernel/notes\", &bid);\n\t\tgoto out;\n\t}\n\n\tid.maj = event->maj;\n\tid.min = event->min;\n\tid.ino = event->ino;\n\tid.ino_generation = event->ino_generation;\n\n\tdso = dsos__findnew_id(&machine->dsos, event->filename, &id);\n\tif (dso && dso->has_build_id) {\n\t\tbid = dso->bid;\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tnsi = nsinfo__new(event->pid);\n\tnsinfo__mountns_enter(nsi, &nc);\n\n\trc = filename__read_build_id(event->filename, &bid) > 0 ? 0 : -1;\n\n\tnsinfo__mountns_exit(&nc);\n\tnsinfo__put(nsi);\n\nout:\n\tif (rc == 0) {\n\t\tmemcpy(event->build_id, bid.data, sizeof(bid.data));\n\t\tevent->build_id_size = (u8) bid.size;\n\t\tevent->header.misc |= PERF_RECORD_MISC_MMAP_BUILD_ID;\n\t\tevent->__reserved_1 = 0;\n\t\tevent->__reserved_2 = 0;\n\n\t\tif (dso && !dso->has_build_id)\n\t\t\tdso__set_build_id(dso, &bid);\n\t} else {\n\t\tif (event->filename[0] == '/') {\n\t\t\tpr_debug2(\"Failed to read build ID for %s\\n\",\n\t\t\t\t  event->filename);\n\t\t}\n\t}\n\tdso__put(dso);\n}\n\nint perf_event__synthesize_mmap_events(struct perf_tool *tool,\n\t\t\t\t       union perf_event *event,\n\t\t\t\t       pid_t pid, pid_t tgid,\n\t\t\t\t       perf_event__handler_t process,\n\t\t\t\t       struct machine *machine,\n\t\t\t\t       bool mmap_data)\n{\n\tunsigned long long t;\n\tchar bf[BUFSIZ];\n\tstruct io io;\n\tbool truncation = false;\n\tunsigned long long timeout = proc_map_timeout * 1000000ULL;\n\tint rc = 0;\n\tconst char *hugetlbfs_mnt = hugetlbfs__mountpoint();\n\tint hugetlbfs_mnt_len = hugetlbfs_mnt ? strlen(hugetlbfs_mnt) : 0;\n\n\tif (machine__is_default_guest(machine))\n\t\treturn 0;\n\n\tsnprintf(bf, sizeof(bf), \"%s/proc/%d/task/%d/maps\",\n\t\tmachine->root_dir, pid, pid);\n\n\tio.fd = open(bf, O_RDONLY, 0);\n\tif (io.fd < 0) {\n\t\t \n\t\tpr_debug(\"couldn't open %s\\n\", bf);\n\t\treturn -1;\n\t}\n\tio__init(&io, io.fd, bf, sizeof(bf));\n\n\tevent->header.type = PERF_RECORD_MMAP2;\n\tt = rdclock();\n\n\twhile (!io.eof) {\n\t\tstatic const char anonstr[] = \"//anon\";\n\t\tsize_t size, aligned_size;\n\n\t\t \n\t\tevent->mmap2.filename[0] = '\\0';\n\n\t\t \n\t\tif (!read_proc_maps_line(&io,\n\t\t\t\t\t&event->mmap2.start,\n\t\t\t\t\t&event->mmap2.len,\n\t\t\t\t\t&event->mmap2.prot,\n\t\t\t\t\t&event->mmap2.flags,\n\t\t\t\t\t&event->mmap2.pgoff,\n\t\t\t\t\t&event->mmap2.maj,\n\t\t\t\t\t&event->mmap2.min,\n\t\t\t\t\t&event->mmap2.ino,\n\t\t\t\t\tsizeof(event->mmap2.filename),\n\t\t\t\t\tevent->mmap2.filename))\n\t\t\tcontinue;\n\n\t\tif ((rdclock() - t) > timeout) {\n\t\t\tpr_warning(\"Reading %s/proc/%d/task/%d/maps time out. \"\n\t\t\t\t   \"You may want to increase \"\n\t\t\t\t   \"the time limit by --proc-map-timeout\\n\",\n\t\t\t\t   machine->root_dir, pid, pid);\n\t\t\ttruncation = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tevent->mmap2.ino_generation = 0;\n\n\t\t \n\t\tif (machine__is_host(machine))\n\t\t\tevent->header.misc = PERF_RECORD_MISC_USER;\n\t\telse\n\t\t\tevent->header.misc = PERF_RECORD_MISC_GUEST_USER;\n\n\t\tif ((event->mmap2.prot & PROT_EXEC) == 0) {\n\t\t\tif (!mmap_data || (event->mmap2.prot & PROT_READ) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tevent->header.misc |= PERF_RECORD_MISC_MMAP_DATA;\n\t\t}\n\nout:\n\t\tif (truncation)\n\t\t\tevent->header.misc |= PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT;\n\n\t\tif (!strcmp(event->mmap2.filename, \"\"))\n\t\t\tstrcpy(event->mmap2.filename, anonstr);\n\n\t\tif (hugetlbfs_mnt_len &&\n\t\t    !strncmp(event->mmap2.filename, hugetlbfs_mnt,\n\t\t\t     hugetlbfs_mnt_len)) {\n\t\t\tstrcpy(event->mmap2.filename, anonstr);\n\t\t\tevent->mmap2.flags |= MAP_HUGETLB;\n\t\t}\n\n\t\tsize = strlen(event->mmap2.filename) + 1;\n\t\taligned_size = PERF_ALIGN(size, sizeof(u64));\n\t\tevent->mmap2.len -= event->mmap.start;\n\t\tevent->mmap2.header.size = (sizeof(event->mmap2) -\n\t\t\t\t\t(sizeof(event->mmap2.filename) - aligned_size));\n\t\tmemset(event->mmap2.filename + size, 0, machine->id_hdr_size +\n\t\t\t(aligned_size - size));\n\t\tevent->mmap2.header.size += machine->id_hdr_size;\n\t\tevent->mmap2.pid = tgid;\n\t\tevent->mmap2.tid = pid;\n\n\t\tif (symbol_conf.buildid_mmap2)\n\t\t\tperf_record_mmap2__read_build_id(&event->mmap2, machine, false);\n\n\t\tif (perf_tool__process_synth_event(tool, event, machine, process) != 0) {\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (truncation)\n\t\t\tbreak;\n\t}\n\n\tclose(io.fd);\n\treturn rc;\n}\n\n#ifdef HAVE_FILE_HANDLE\nstatic int perf_event__synthesize_cgroup(struct perf_tool *tool,\n\t\t\t\t\t union perf_event *event,\n\t\t\t\t\t char *path, size_t mount_len,\n\t\t\t\t\t perf_event__handler_t process,\n\t\t\t\t\t struct machine *machine)\n{\n\tsize_t event_size = sizeof(event->cgroup) - sizeof(event->cgroup.path);\n\tsize_t path_len = strlen(path) - mount_len + 1;\n\tstruct {\n\t\tstruct file_handle fh;\n\t\tuint64_t cgroup_id;\n\t} handle;\n\tint mount_id;\n\n\twhile (path_len % sizeof(u64))\n\t\tpath[mount_len + path_len++] = '\\0';\n\n\tmemset(&event->cgroup, 0, event_size);\n\n\tevent->cgroup.header.type = PERF_RECORD_CGROUP;\n\tevent->cgroup.header.size = event_size + path_len + machine->id_hdr_size;\n\n\thandle.fh.handle_bytes = sizeof(handle.cgroup_id);\n\tif (name_to_handle_at(AT_FDCWD, path, &handle.fh, &mount_id, 0) < 0) {\n\t\tpr_debug(\"stat failed: %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\tevent->cgroup.id = handle.cgroup_id;\n\tstrncpy(event->cgroup.path, path + mount_len, path_len);\n\tmemset(event->cgroup.path + path_len, 0, machine->id_hdr_size);\n\n\tif (perf_tool__process_synth_event(tool, event, machine, process) < 0) {\n\t\tpr_debug(\"process synth event failed\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_event__walk_cgroup_tree(struct perf_tool *tool,\n\t\t\t\t\tunion perf_event *event,\n\t\t\t\t\tchar *path, size_t mount_len,\n\t\t\t\t\tperf_event__handler_t process,\n\t\t\t\t\tstruct machine *machine)\n{\n\tsize_t pos = strlen(path);\n\tDIR *d;\n\tstruct dirent *dent;\n\tint ret = 0;\n\n\tif (perf_event__synthesize_cgroup(tool, event, path, mount_len,\n\t\t\t\t\t  process, machine) < 0)\n\t\treturn -1;\n\n\td = opendir(path);\n\tif (d == NULL) {\n\t\tpr_debug(\"failed to open directory: %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\twhile ((dent = readdir(d)) != NULL) {\n\t\tif (dent->d_type != DT_DIR)\n\t\t\tcontinue;\n\t\tif (!strcmp(dent->d_name, \".\") ||\n\t\t    !strcmp(dent->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (strlen(path) + strlen(dent->d_name) + 1 >= PATH_MAX)\n\t\t\tcontinue;\n\n\t\tif (path[pos - 1] != '/')\n\t\t\tstrcat(path, \"/\");\n\t\tstrcat(path, dent->d_name);\n\n\t\tret = perf_event__walk_cgroup_tree(tool, event, path,\n\t\t\t\t\t\t   mount_len, process, machine);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tpath[pos] = '\\0';\n\t}\n\n\tclosedir(d);\n\treturn ret;\n}\n\nint perf_event__synthesize_cgroups(struct perf_tool *tool,\n\t\t\t\t   perf_event__handler_t process,\n\t\t\t\t   struct machine *machine)\n{\n\tunion perf_event event;\n\tchar cgrp_root[PATH_MAX];\n\tsize_t mount_len;   \n\n\tif (!tool || !tool->cgroup_events)\n\t\treturn 0;\n\n\tif (cgroupfs_find_mountpoint(cgrp_root, PATH_MAX, \"perf_event\") < 0) {\n\t\tpr_debug(\"cannot find cgroup mount point\\n\");\n\t\treturn -1;\n\t}\n\n\tmount_len = strlen(cgrp_root);\n\t \n\tstrcat(cgrp_root, \"/\");\n\n\tif (perf_event__walk_cgroup_tree(tool, &event, cgrp_root, mount_len,\n\t\t\t\t\t process, machine) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n#else\nint perf_event__synthesize_cgroups(struct perf_tool *tool __maybe_unused,\n\t\t\t\t   perf_event__handler_t process __maybe_unused,\n\t\t\t\t   struct machine *machine __maybe_unused)\n{\n\treturn -1;\n}\n#endif\n\nint perf_event__synthesize_modules(struct perf_tool *tool, perf_event__handler_t process,\n\t\t\t\t   struct machine *machine)\n{\n\tint rc = 0;\n\tstruct map_rb_node *pos;\n\tstruct maps *maps = machine__kernel_maps(machine);\n\tunion perf_event *event;\n\tsize_t size = symbol_conf.buildid_mmap2 ?\n\t\t\tsizeof(event->mmap2) : sizeof(event->mmap);\n\n\tevent = zalloc(size + machine->id_hdr_size);\n\tif (event == NULL) {\n\t\tpr_debug(\"Not enough memory synthesizing mmap event \"\n\t\t\t \"for kernel modules\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (machine__is_host(machine))\n\t\tevent->header.misc = PERF_RECORD_MISC_KERNEL;\n\telse\n\t\tevent->header.misc = PERF_RECORD_MISC_GUEST_KERNEL;\n\n\tmaps__for_each_entry(maps, pos) {\n\t\tstruct map *map = pos->map;\n\t\tstruct dso *dso;\n\n\t\tif (!__map__is_kmodule(map))\n\t\t\tcontinue;\n\n\t\tdso = map__dso(map);\n\t\tif (symbol_conf.buildid_mmap2) {\n\t\t\tsize = PERF_ALIGN(dso->long_name_len + 1, sizeof(u64));\n\t\t\tevent->mmap2.header.type = PERF_RECORD_MMAP2;\n\t\t\tevent->mmap2.header.size = (sizeof(event->mmap2) -\n\t\t\t\t\t\t(sizeof(event->mmap2.filename) - size));\n\t\t\tmemset(event->mmap2.filename + size, 0, machine->id_hdr_size);\n\t\t\tevent->mmap2.header.size += machine->id_hdr_size;\n\t\t\tevent->mmap2.start = map__start(map);\n\t\t\tevent->mmap2.len   = map__size(map);\n\t\t\tevent->mmap2.pid   = machine->pid;\n\n\t\t\tmemcpy(event->mmap2.filename, dso->long_name, dso->long_name_len + 1);\n\n\t\t\tperf_record_mmap2__read_build_id(&event->mmap2, machine, false);\n\t\t} else {\n\t\t\tsize = PERF_ALIGN(dso->long_name_len + 1, sizeof(u64));\n\t\t\tevent->mmap.header.type = PERF_RECORD_MMAP;\n\t\t\tevent->mmap.header.size = (sizeof(event->mmap) -\n\t\t\t\t\t\t(sizeof(event->mmap.filename) - size));\n\t\t\tmemset(event->mmap.filename + size, 0, machine->id_hdr_size);\n\t\t\tevent->mmap.header.size += machine->id_hdr_size;\n\t\t\tevent->mmap.start = map__start(map);\n\t\t\tevent->mmap.len   = map__size(map);\n\t\t\tevent->mmap.pid   = machine->pid;\n\n\t\t\tmemcpy(event->mmap.filename, dso->long_name, dso->long_name_len + 1);\n\t\t}\n\n\t\tif (perf_tool__process_synth_event(tool, event, machine, process) != 0) {\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(event);\n\treturn rc;\n}\n\nstatic int filter_task(const struct dirent *dirent)\n{\n\treturn isdigit(dirent->d_name[0]);\n}\n\nstatic int __event__synthesize_thread(union perf_event *comm_event,\n\t\t\t\t      union perf_event *mmap_event,\n\t\t\t\t      union perf_event *fork_event,\n\t\t\t\t      union perf_event *namespaces_event,\n\t\t\t\t      pid_t pid, int full, perf_event__handler_t process,\n\t\t\t\t      struct perf_tool *tool, struct machine *machine,\n\t\t\t\t      bool needs_mmap, bool mmap_data)\n{\n\tchar filename[PATH_MAX];\n\tstruct dirent **dirent;\n\tpid_t tgid, ppid;\n\tint rc = 0;\n\tint i, n;\n\n\t \n\tif (!full) {\n\t\ttgid = perf_event__synthesize_comm(tool, comm_event, pid,\n\t\t\t\t\t\t   process, machine);\n\n\t\tif (tgid == -1)\n\t\t\treturn -1;\n\n\t\tif (perf_event__synthesize_namespaces(tool, namespaces_event, pid,\n\t\t\t\t\t\t      tgid, process, machine) < 0)\n\t\t\treturn -1;\n\n\t\t \n\t\tif (pid == tgid && needs_mmap &&\n\t\t    perf_event__synthesize_mmap_events(tool, mmap_event, pid, tgid,\n\t\t\t\t\t\t       process, machine, mmap_data))\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t}\n\n\tif (machine__is_default_guest(machine))\n\t\treturn 0;\n\n\tsnprintf(filename, sizeof(filename), \"%s/proc/%d/task\",\n\t\t machine->root_dir, pid);\n\n\tn = scandir(filename, &dirent, filter_task, NULL);\n\tif (n < 0)\n\t\treturn n;\n\n\tfor (i = 0; i < n; i++) {\n\t\tchar *end;\n\t\tpid_t _pid;\n\t\tbool kernel_thread = false;\n\n\t\t_pid = strtol(dirent[i]->d_name, &end, 10);\n\t\tif (*end)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (perf_event__prepare_comm(comm_event, pid, _pid, machine,\n\t\t\t\t\t     &tgid, &ppid, &kernel_thread) != 0)\n\t\t\tcontinue;\n\n\t\trc = -1;\n\t\tif (perf_event__synthesize_fork(tool, fork_event, _pid, tgid,\n\t\t\t\t\t\tppid, process, machine) < 0)\n\t\t\tbreak;\n\n\t\tif (perf_event__synthesize_namespaces(tool, namespaces_event, _pid,\n\t\t\t\t\t\t      tgid, process, machine) < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (perf_tool__process_synth_event(tool, comm_event, machine, process) != 0)\n\t\t\tbreak;\n\n\t\trc = 0;\n\t\tif (_pid == pid && !kernel_thread && needs_mmap) {\n\t\t\t \n\t\t\trc = perf_event__synthesize_mmap_events(tool, mmap_event, pid, tgid,\n\t\t\t\t\t\tprocess, machine, mmap_data);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t\tzfree(&dirent[i]);\n\tfree(dirent);\n\n\treturn rc;\n}\n\nint perf_event__synthesize_thread_map(struct perf_tool *tool,\n\t\t\t\t      struct perf_thread_map *threads,\n\t\t\t\t      perf_event__handler_t process,\n\t\t\t\t      struct machine *machine,\n\t\t\t\t      bool needs_mmap, bool mmap_data)\n{\n\tunion perf_event *comm_event, *mmap_event, *fork_event;\n\tunion perf_event *namespaces_event;\n\tint err = -1, thread, j;\n\n\tcomm_event = malloc(sizeof(comm_event->comm) + machine->id_hdr_size);\n\tif (comm_event == NULL)\n\t\tgoto out;\n\n\tmmap_event = malloc(sizeof(mmap_event->mmap2) + machine->id_hdr_size);\n\tif (mmap_event == NULL)\n\t\tgoto out_free_comm;\n\n\tfork_event = malloc(sizeof(fork_event->fork) + machine->id_hdr_size);\n\tif (fork_event == NULL)\n\t\tgoto out_free_mmap;\n\n\tnamespaces_event = malloc(sizeof(namespaces_event->namespaces) +\n\t\t\t\t  (NR_NAMESPACES * sizeof(struct perf_ns_link_info)) +\n\t\t\t\t  machine->id_hdr_size);\n\tif (namespaces_event == NULL)\n\t\tgoto out_free_fork;\n\n\terr = 0;\n\tfor (thread = 0; thread < threads->nr; ++thread) {\n\t\tif (__event__synthesize_thread(comm_event, mmap_event,\n\t\t\t\t\t       fork_event, namespaces_event,\n\t\t\t\t\t       perf_thread_map__pid(threads, thread), 0,\n\t\t\t\t\t       process, tool, machine,\n\t\t\t\t\t       needs_mmap, mmap_data)) {\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((int) comm_event->comm.pid != perf_thread_map__pid(threads, thread)) {\n\t\t\tbool need_leader = true;\n\n\t\t\t \n\t\t\tfor (j = 0; j < threads->nr; ++j) {\n\t\t\t\tif ((int) comm_event->comm.pid == perf_thread_map__pid(threads, j)) {\n\t\t\t\t\tneed_leader = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (need_leader &&\n\t\t\t    __event__synthesize_thread(comm_event, mmap_event,\n\t\t\t\t\t\t       fork_event, namespaces_event,\n\t\t\t\t\t\t       comm_event->comm.pid, 0,\n\t\t\t\t\t\t       process, tool, machine,\n\t\t\t\t\t\t       needs_mmap, mmap_data)) {\n\t\t\t\terr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(namespaces_event);\nout_free_fork:\n\tfree(fork_event);\nout_free_mmap:\n\tfree(mmap_event);\nout_free_comm:\n\tfree(comm_event);\nout:\n\treturn err;\n}\n\nstatic int __perf_event__synthesize_threads(struct perf_tool *tool,\n\t\t\t\t\t    perf_event__handler_t process,\n\t\t\t\t\t    struct machine *machine,\n\t\t\t\t\t    bool needs_mmap,\n\t\t\t\t\t    bool mmap_data,\n\t\t\t\t\t    struct dirent **dirent,\n\t\t\t\t\t    int start,\n\t\t\t\t\t    int num)\n{\n\tunion perf_event *comm_event, *mmap_event, *fork_event;\n\tunion perf_event *namespaces_event;\n\tint err = -1;\n\tchar *end;\n\tpid_t pid;\n\tint i;\n\n\tcomm_event = malloc(sizeof(comm_event->comm) + machine->id_hdr_size);\n\tif (comm_event == NULL)\n\t\tgoto out;\n\n\tmmap_event = malloc(sizeof(mmap_event->mmap2) + machine->id_hdr_size);\n\tif (mmap_event == NULL)\n\t\tgoto out_free_comm;\n\n\tfork_event = malloc(sizeof(fork_event->fork) + machine->id_hdr_size);\n\tif (fork_event == NULL)\n\t\tgoto out_free_mmap;\n\n\tnamespaces_event = malloc(sizeof(namespaces_event->namespaces) +\n\t\t\t\t  (NR_NAMESPACES * sizeof(struct perf_ns_link_info)) +\n\t\t\t\t  machine->id_hdr_size);\n\tif (namespaces_event == NULL)\n\t\tgoto out_free_fork;\n\n\tfor (i = start; i < start + num; i++) {\n\t\tif (!isdigit(dirent[i]->d_name[0]))\n\t\t\tcontinue;\n\n\t\tpid = (pid_t)strtol(dirent[i]->d_name, &end, 10);\n\t\t \n\t\tif (*end)\n\t\t\tcontinue;\n\t\t \n\t\t__event__synthesize_thread(comm_event, mmap_event, fork_event,\n\t\t\t\t\t   namespaces_event, pid, 1, process,\n\t\t\t\t\t   tool, machine, needs_mmap, mmap_data);\n\t}\n\terr = 0;\n\n\tfree(namespaces_event);\nout_free_fork:\n\tfree(fork_event);\nout_free_mmap:\n\tfree(mmap_event);\nout_free_comm:\n\tfree(comm_event);\nout:\n\treturn err;\n}\n\nstruct synthesize_threads_arg {\n\tstruct perf_tool *tool;\n\tperf_event__handler_t process;\n\tstruct machine *machine;\n\tbool needs_mmap;\n\tbool mmap_data;\n\tstruct dirent **dirent;\n\tint num;\n\tint start;\n};\n\nstatic void *synthesize_threads_worker(void *arg)\n{\n\tstruct synthesize_threads_arg *args = arg;\n\n\t__perf_event__synthesize_threads(args->tool, args->process,\n\t\t\t\t\t args->machine,\n\t\t\t\t\t args->needs_mmap, args->mmap_data,\n\t\t\t\t\t args->dirent,\n\t\t\t\t\t args->start, args->num);\n\treturn NULL;\n}\n\nint perf_event__synthesize_threads(struct perf_tool *tool,\n\t\t\t\t   perf_event__handler_t process,\n\t\t\t\t   struct machine *machine,\n\t\t\t\t   bool needs_mmap, bool mmap_data,\n\t\t\t\t   unsigned int nr_threads_synthesize)\n{\n\tstruct synthesize_threads_arg *args = NULL;\n\tpthread_t *synthesize_threads = NULL;\n\tchar proc_path[PATH_MAX];\n\tstruct dirent **dirent;\n\tint num_per_thread;\n\tint m, n, i, j;\n\tint thread_nr;\n\tint base = 0;\n\tint err = -1;\n\n\n\tif (machine__is_default_guest(machine))\n\t\treturn 0;\n\n\tsnprintf(proc_path, sizeof(proc_path), \"%s/proc\", machine->root_dir);\n\tn = scandir(proc_path, &dirent, filter_task, NULL);\n\tif (n < 0)\n\t\treturn err;\n\n\tif (nr_threads_synthesize == UINT_MAX)\n\t\tthread_nr = sysconf(_SC_NPROCESSORS_ONLN);\n\telse\n\t\tthread_nr = nr_threads_synthesize;\n\n\tif (thread_nr <= 1) {\n\t\terr = __perf_event__synthesize_threads(tool, process,\n\t\t\t\t\t\t       machine,\n\t\t\t\t\t\t       needs_mmap, mmap_data,\n\t\t\t\t\t\t       dirent, base, n);\n\t\tgoto free_dirent;\n\t}\n\tif (thread_nr > n)\n\t\tthread_nr = n;\n\n\tsynthesize_threads = calloc(sizeof(pthread_t), thread_nr);\n\tif (synthesize_threads == NULL)\n\t\tgoto free_dirent;\n\n\targs = calloc(sizeof(*args), thread_nr);\n\tif (args == NULL)\n\t\tgoto free_threads;\n\n\tnum_per_thread = n / thread_nr;\n\tm = n % thread_nr;\n\tfor (i = 0; i < thread_nr; i++) {\n\t\targs[i].tool = tool;\n\t\targs[i].process = process;\n\t\targs[i].machine = machine;\n\t\targs[i].needs_mmap = needs_mmap;\n\t\targs[i].mmap_data = mmap_data;\n\t\targs[i].dirent = dirent;\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\targs[i].num = num_per_thread + 1;\n\t\targs[i].start = i * args[i].num;\n\t}\n\tif (i != 0)\n\t\tbase = args[i-1].start + args[i-1].num;\n\tfor (j = i; j < thread_nr; j++) {\n\t\targs[j].num = num_per_thread;\n\t\targs[j].start = base + (j - i) * args[i].num;\n\t}\n\n\tfor (i = 0; i < thread_nr; i++) {\n\t\tif (pthread_create(&synthesize_threads[i], NULL,\n\t\t\t\t   synthesize_threads_worker, &args[i]))\n\t\t\tgoto out_join;\n\t}\n\terr = 0;\nout_join:\n\tfor (i = 0; i < thread_nr; i++)\n\t\tpthread_join(synthesize_threads[i], NULL);\n\tfree(args);\nfree_threads:\n\tfree(synthesize_threads);\nfree_dirent:\n\tfor (i = 0; i < n; i++)\n\t\tzfree(&dirent[i]);\n\tfree(dirent);\n\n\treturn err;\n}\n\nint __weak perf_event__synthesize_extra_kmaps(struct perf_tool *tool __maybe_unused,\n\t\t\t\t\t      perf_event__handler_t process __maybe_unused,\n\t\t\t\t\t      struct machine *machine __maybe_unused)\n{\n\treturn 0;\n}\n\nstatic int __perf_event__synthesize_kernel_mmap(struct perf_tool *tool,\n\t\t\t\t\t\tperf_event__handler_t process,\n\t\t\t\t\t\tstruct machine *machine)\n{\n\tunion perf_event *event;\n\tsize_t size = symbol_conf.buildid_mmap2 ?\n\t\t\tsizeof(event->mmap2) : sizeof(event->mmap);\n\tstruct map *map = machine__kernel_map(machine);\n\tstruct kmap *kmap;\n\tint err;\n\n\tif (map == NULL)\n\t\treturn -1;\n\n\tkmap = map__kmap(map);\n\tif (!kmap->ref_reloc_sym)\n\t\treturn -1;\n\n\t \n\tevent = zalloc(size + machine->id_hdr_size);\n\tif (event == NULL) {\n\t\tpr_debug(\"Not enough memory synthesizing mmap event \"\n\t\t\t \"for kernel modules\\n\");\n\t\treturn -1;\n\t}\n\n\tif (machine__is_host(machine)) {\n\t\t \n\t\tevent->header.misc = PERF_RECORD_MISC_KERNEL;\n\t} else {\n\t\tevent->header.misc = PERF_RECORD_MISC_GUEST_KERNEL;\n\t}\n\n\tif (symbol_conf.buildid_mmap2) {\n\t\tsize = snprintf(event->mmap2.filename, sizeof(event->mmap2.filename),\n\t\t\t\t\"%s%s\", machine->mmap_name, kmap->ref_reloc_sym->name) + 1;\n\t\tsize = PERF_ALIGN(size, sizeof(u64));\n\t\tevent->mmap2.header.type = PERF_RECORD_MMAP2;\n\t\tevent->mmap2.header.size = (sizeof(event->mmap2) -\n\t\t\t\t(sizeof(event->mmap2.filename) - size) + machine->id_hdr_size);\n\t\tevent->mmap2.pgoff = kmap->ref_reloc_sym->addr;\n\t\tevent->mmap2.start = map__start(map);\n\t\tevent->mmap2.len   = map__end(map) - event->mmap.start;\n\t\tevent->mmap2.pid   = machine->pid;\n\n\t\tperf_record_mmap2__read_build_id(&event->mmap2, machine, true);\n\t} else {\n\t\tsize = snprintf(event->mmap.filename, sizeof(event->mmap.filename),\n\t\t\t\t\"%s%s\", machine->mmap_name, kmap->ref_reloc_sym->name) + 1;\n\t\tsize = PERF_ALIGN(size, sizeof(u64));\n\t\tevent->mmap.header.type = PERF_RECORD_MMAP;\n\t\tevent->mmap.header.size = (sizeof(event->mmap) -\n\t\t\t\t(sizeof(event->mmap.filename) - size) + machine->id_hdr_size);\n\t\tevent->mmap.pgoff = kmap->ref_reloc_sym->addr;\n\t\tevent->mmap.start = map__start(map);\n\t\tevent->mmap.len   = map__end(map) - event->mmap.start;\n\t\tevent->mmap.pid   = machine->pid;\n\t}\n\n\terr = perf_tool__process_synth_event(tool, event, machine, process);\n\tfree(event);\n\n\treturn err;\n}\n\nint perf_event__synthesize_kernel_mmap(struct perf_tool *tool,\n\t\t\t\t       perf_event__handler_t process,\n\t\t\t\t       struct machine *machine)\n{\n\tint err;\n\n\terr = __perf_event__synthesize_kernel_mmap(tool, process, machine);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn perf_event__synthesize_extra_kmaps(tool, process, machine);\n}\n\nint perf_event__synthesize_thread_map2(struct perf_tool *tool,\n\t\t\t\t      struct perf_thread_map *threads,\n\t\t\t\t      perf_event__handler_t process,\n\t\t\t\t      struct machine *machine)\n{\n\tunion perf_event *event;\n\tint i, err, size;\n\n\tsize  = sizeof(event->thread_map);\n\tsize +=\tthreads->nr * sizeof(event->thread_map.entries[0]);\n\n\tevent = zalloc(size);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->header.type = PERF_RECORD_THREAD_MAP;\n\tevent->header.size = size;\n\tevent->thread_map.nr = threads->nr;\n\n\tfor (i = 0; i < threads->nr; i++) {\n\t\tstruct perf_record_thread_map_entry *entry = &event->thread_map.entries[i];\n\t\tchar *comm = perf_thread_map__comm(threads, i);\n\n\t\tif (!comm)\n\t\t\tcomm = (char *) \"\";\n\n\t\tentry->pid = perf_thread_map__pid(threads, i);\n\t\tstrncpy((char *) &entry->comm, comm, sizeof(entry->comm));\n\t}\n\n\terr = process(tool, event, NULL, machine);\n\n\tfree(event);\n\treturn err;\n}\n\nstruct synthesize_cpu_map_data {\n\tconst struct perf_cpu_map *map;\n\tint nr;\n\tint min_cpu;\n\tint max_cpu;\n\tint has_any_cpu;\n\tint type;\n\tsize_t size;\n\tstruct perf_record_cpu_map_data *data;\n};\n\nstatic void synthesize_cpus(struct synthesize_cpu_map_data *data)\n{\n\tdata->data->type = PERF_CPU_MAP__CPUS;\n\tdata->data->cpus_data.nr = data->nr;\n\tfor (int i = 0; i < data->nr; i++)\n\t\tdata->data->cpus_data.cpu[i] = perf_cpu_map__cpu(data->map, i).cpu;\n}\n\nstatic void synthesize_mask(struct synthesize_cpu_map_data *data)\n{\n\tint idx;\n\tstruct perf_cpu cpu;\n\n\t \n\tdata->data->type = PERF_CPU_MAP__MASK;\n\tdata->data->mask32_data.nr = BITS_TO_U32(data->max_cpu);\n\tdata->data->mask32_data.long_size = 4;\n\n\tperf_cpu_map__for_each_cpu(cpu, idx, data->map) {\n\t\tint bit_word = cpu.cpu / 32;\n\t\tu32 bit_mask = 1U << (cpu.cpu & 31);\n\n\t\tdata->data->mask32_data.mask[bit_word] |= bit_mask;\n\t}\n}\n\nstatic void synthesize_range_cpus(struct synthesize_cpu_map_data *data)\n{\n\tdata->data->type = PERF_CPU_MAP__RANGE_CPUS;\n\tdata->data->range_cpu_data.any_cpu = data->has_any_cpu;\n\tdata->data->range_cpu_data.start_cpu = data->min_cpu;\n\tdata->data->range_cpu_data.end_cpu = data->max_cpu;\n}\n\nstatic void *cpu_map_data__alloc(struct synthesize_cpu_map_data *syn_data,\n\t\t\t\t size_t header_size)\n{\n\tsize_t size_cpus, size_mask;\n\n\tsyn_data->nr = perf_cpu_map__nr(syn_data->map);\n\tsyn_data->has_any_cpu = (perf_cpu_map__cpu(syn_data->map, 0).cpu == -1) ? 1 : 0;\n\n\tsyn_data->min_cpu = perf_cpu_map__cpu(syn_data->map, syn_data->has_any_cpu).cpu;\n\tsyn_data->max_cpu = perf_cpu_map__max(syn_data->map).cpu;\n\tif (syn_data->max_cpu - syn_data->min_cpu + 1 == syn_data->nr - syn_data->has_any_cpu) {\n\t\t \n\t\tassert(sizeof(u16) + sizeof(struct perf_record_range_cpu_map) == sizeof(u64));\n\t\tsyn_data->type = PERF_CPU_MAP__RANGE_CPUS;\n\t\tsyn_data->size = header_size + sizeof(u64);\n\t\treturn zalloc(syn_data->size);\n\t}\n\n\tsize_cpus = sizeof(u16) + sizeof(struct cpu_map_entries) + syn_data->nr * sizeof(u16);\n\t \n\tsize_mask = sizeof(u16) + sizeof(struct perf_record_mask_cpu_map32) +\n\t\tBITS_TO_U32(syn_data->max_cpu) * sizeof(__u32);\n\tif (syn_data->has_any_cpu || size_cpus < size_mask) {\n\t\t \n\t\tsyn_data->type = PERF_CPU_MAP__CPUS;\n\t\tsyn_data->size = header_size + PERF_ALIGN(size_cpus, sizeof(u64));\n\t\treturn zalloc(syn_data->size);\n\t}\n\t \n\tsyn_data->type = PERF_CPU_MAP__MASK;\n\tsyn_data->size = header_size + PERF_ALIGN(size_mask, sizeof(u64));\n\treturn zalloc(syn_data->size);\n}\n\nstatic void cpu_map_data__synthesize(struct synthesize_cpu_map_data *data)\n{\n\tswitch (data->type) {\n\tcase PERF_CPU_MAP__CPUS:\n\t\tsynthesize_cpus(data);\n\t\tbreak;\n\tcase PERF_CPU_MAP__MASK:\n\t\tsynthesize_mask(data);\n\t\tbreak;\n\tcase PERF_CPU_MAP__RANGE_CPUS:\n\t\tsynthesize_range_cpus(data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic struct perf_record_cpu_map *cpu_map_event__new(const struct perf_cpu_map *map)\n{\n\tstruct synthesize_cpu_map_data syn_data = { .map = map };\n\tstruct perf_record_cpu_map *event;\n\n\n\tevent = cpu_map_data__alloc(&syn_data, sizeof(struct perf_event_header));\n\tif (!event)\n\t\treturn NULL;\n\n\tsyn_data.data = &event->data;\n\tevent->header.type = PERF_RECORD_CPU_MAP;\n\tevent->header.size = syn_data.size;\n\tcpu_map_data__synthesize(&syn_data);\n\treturn event;\n}\n\n\nint perf_event__synthesize_cpu_map(struct perf_tool *tool,\n\t\t\t\t   const struct perf_cpu_map *map,\n\t\t\t\t   perf_event__handler_t process,\n\t\t\t\t   struct machine *machine)\n{\n\tstruct perf_record_cpu_map *event;\n\tint err;\n\n\tevent = cpu_map_event__new(map);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\terr = process(tool, (union perf_event *) event, NULL, machine);\n\n\tfree(event);\n\treturn err;\n}\n\nint perf_event__synthesize_stat_config(struct perf_tool *tool,\n\t\t\t\t       struct perf_stat_config *config,\n\t\t\t\t       perf_event__handler_t process,\n\t\t\t\t       struct machine *machine)\n{\n\tstruct perf_record_stat_config *event;\n\tint size, i = 0, err;\n\n\tsize  = sizeof(*event);\n\tsize += (PERF_STAT_CONFIG_TERM__MAX * sizeof(event->data[0]));\n\n\tevent = zalloc(size);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->header.type = PERF_RECORD_STAT_CONFIG;\n\tevent->header.size = size;\n\tevent->nr          = PERF_STAT_CONFIG_TERM__MAX;\n\n#define ADD(__term, __val)\t\t\t\t\t\\\n\tevent->data[i].tag = PERF_STAT_CONFIG_TERM__##__term;\t\\\n\tevent->data[i].val = __val;\t\t\t\t\\\n\ti++;\n\n\tADD(AGGR_MODE,\tconfig->aggr_mode)\n\tADD(INTERVAL,\tconfig->interval)\n\tADD(SCALE,\tconfig->scale)\n\tADD(AGGR_LEVEL,\tconfig->aggr_level)\n\n\tWARN_ONCE(i != PERF_STAT_CONFIG_TERM__MAX,\n\t\t  \"stat config terms unbalanced\\n\");\n#undef ADD\n\n\terr = process(tool, (union perf_event *) event, NULL, machine);\n\n\tfree(event);\n\treturn err;\n}\n\nint perf_event__synthesize_stat(struct perf_tool *tool,\n\t\t\t\tstruct perf_cpu cpu, u32 thread, u64 id,\n\t\t\t\tstruct perf_counts_values *count,\n\t\t\t\tperf_event__handler_t process,\n\t\t\t\tstruct machine *machine)\n{\n\tstruct perf_record_stat event;\n\n\tevent.header.type = PERF_RECORD_STAT;\n\tevent.header.size = sizeof(event);\n\tevent.header.misc = 0;\n\n\tevent.id        = id;\n\tevent.cpu       = cpu.cpu;\n\tevent.thread    = thread;\n\tevent.val       = count->val;\n\tevent.ena       = count->ena;\n\tevent.run       = count->run;\n\n\treturn process(tool, (union perf_event *) &event, NULL, machine);\n}\n\nint perf_event__synthesize_stat_round(struct perf_tool *tool,\n\t\t\t\t      u64 evtime, u64 type,\n\t\t\t\t      perf_event__handler_t process,\n\t\t\t\t      struct machine *machine)\n{\n\tstruct perf_record_stat_round event;\n\n\tevent.header.type = PERF_RECORD_STAT_ROUND;\n\tevent.header.size = sizeof(event);\n\tevent.header.misc = 0;\n\n\tevent.time = evtime;\n\tevent.type = type;\n\n\treturn process(tool, (union perf_event *) &event, NULL, machine);\n}\n\nsize_t perf_event__sample_event_size(const struct perf_sample *sample, u64 type, u64 read_format)\n{\n\tsize_t sz, result = sizeof(struct perf_record_sample);\n\n\tif (type & PERF_SAMPLE_IDENTIFIER)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_IP)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_TID)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_TIME)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_ADDR)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_ID)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_STREAM_ID)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_CPU)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_PERIOD)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_READ) {\n\t\tresult += sizeof(u64);\n\t\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\n\t\t\tresult += sizeof(u64);\n\t\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\n\t\t\tresult += sizeof(u64);\n\t\t \n\t\tif (read_format & PERF_FORMAT_GROUP) {\n\t\t\tsz = sample_read_value_size(read_format);\n\t\t\tresult += sz * sample->read.group.nr;\n\t\t} else {\n\t\t\tresult += sizeof(u64);\n\t\t\tif (read_format & PERF_FORMAT_LOST)\n\t\t\t\tresult += sizeof(u64);\n\t\t}\n\t}\n\n\tif (type & PERF_SAMPLE_CALLCHAIN) {\n\t\tsz = (sample->callchain->nr + 1) * sizeof(u64);\n\t\tresult += sz;\n\t}\n\n\tif (type & PERF_SAMPLE_RAW) {\n\t\tresult += sizeof(u32);\n\t\tresult += sample->raw_size;\n\t}\n\n\tif (type & PERF_SAMPLE_BRANCH_STACK) {\n\t\tsz = sample->branch_stack->nr * sizeof(struct branch_entry);\n\t\t \n\t\tsz += 2 * sizeof(u64);\n\t\tresult += sz;\n\t}\n\n\tif (type & PERF_SAMPLE_REGS_USER) {\n\t\tif (sample->user_regs.abi) {\n\t\t\tresult += sizeof(u64);\n\t\t\tsz = hweight64(sample->user_regs.mask) * sizeof(u64);\n\t\t\tresult += sz;\n\t\t} else {\n\t\t\tresult += sizeof(u64);\n\t\t}\n\t}\n\n\tif (type & PERF_SAMPLE_STACK_USER) {\n\t\tsz = sample->user_stack.size;\n\t\tresult += sizeof(u64);\n\t\tif (sz) {\n\t\t\tresult += sz;\n\t\t\tresult += sizeof(u64);\n\t\t}\n\t}\n\n\tif (type & PERF_SAMPLE_WEIGHT_TYPE)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_DATA_SRC)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_TRANSACTION)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_REGS_INTR) {\n\t\tif (sample->intr_regs.abi) {\n\t\t\tresult += sizeof(u64);\n\t\t\tsz = hweight64(sample->intr_regs.mask) * sizeof(u64);\n\t\t\tresult += sz;\n\t\t} else {\n\t\t\tresult += sizeof(u64);\n\t\t}\n\t}\n\n\tif (type & PERF_SAMPLE_PHYS_ADDR)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_CGROUP)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_DATA_PAGE_SIZE)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_CODE_PAGE_SIZE)\n\t\tresult += sizeof(u64);\n\n\tif (type & PERF_SAMPLE_AUX) {\n\t\tresult += sizeof(u64);\n\t\tresult += sample->aux_sample.size;\n\t}\n\n\treturn result;\n}\n\nvoid __weak arch_perf_synthesize_sample_weight(const struct perf_sample *data,\n\t\t\t\t\t       __u64 *array, u64 type __maybe_unused)\n{\n\t*array = data->weight;\n}\n\nstatic __u64 *copy_read_group_values(__u64 *array, __u64 read_format,\n\t\t\t\t     const struct perf_sample *sample)\n{\n\tsize_t sz = sample_read_value_size(read_format);\n\tstruct sample_read_value *v = sample->read.group.values;\n\n\tsample_read_group__for_each(v, sample->read.group.nr, read_format) {\n\t\t \n\t\tmemcpy(array, v, sz);\n\t\tarray = (void *)array + sz;\n\t}\n\treturn array;\n}\n\nint perf_event__synthesize_sample(union perf_event *event, u64 type, u64 read_format,\n\t\t\t\t  const struct perf_sample *sample)\n{\n\t__u64 *array;\n\tsize_t sz;\n\t \n\tunion u64_swap u;\n\n\tarray = event->sample.array;\n\n\tif (type & PERF_SAMPLE_IDENTIFIER) {\n\t\t*array = sample->id;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_IP) {\n\t\t*array = sample->ip;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_TID) {\n\t\tu.val32[0] = sample->pid;\n\t\tu.val32[1] = sample->tid;\n\t\t*array = u.val64;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_TIME) {\n\t\t*array = sample->time;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_ADDR) {\n\t\t*array = sample->addr;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_ID) {\n\t\t*array = sample->id;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_STREAM_ID) {\n\t\t*array = sample->stream_id;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_CPU) {\n\t\tu.val32[0] = sample->cpu;\n\t\tu.val32[1] = 0;\n\t\t*array = u.val64;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_PERIOD) {\n\t\t*array = sample->period;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_READ) {\n\t\tif (read_format & PERF_FORMAT_GROUP)\n\t\t\t*array = sample->read.group.nr;\n\t\telse\n\t\t\t*array = sample->read.one.value;\n\t\tarray++;\n\n\t\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {\n\t\t\t*array = sample->read.time_enabled;\n\t\t\tarray++;\n\t\t}\n\n\t\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {\n\t\t\t*array = sample->read.time_running;\n\t\t\tarray++;\n\t\t}\n\n\t\t \n\t\tif (read_format & PERF_FORMAT_GROUP) {\n\t\t\tarray = copy_read_group_values(array, read_format,\n\t\t\t\t\t\t       sample);\n\t\t} else {\n\t\t\t*array = sample->read.one.id;\n\t\t\tarray++;\n\n\t\t\tif (read_format & PERF_FORMAT_LOST) {\n\t\t\t\t*array = sample->read.one.lost;\n\t\t\t\tarray++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (type & PERF_SAMPLE_CALLCHAIN) {\n\t\tsz = (sample->callchain->nr + 1) * sizeof(u64);\n\t\tmemcpy(array, sample->callchain, sz);\n\t\tarray = (void *)array + sz;\n\t}\n\n\tif (type & PERF_SAMPLE_RAW) {\n\t\tu.val32[0] = sample->raw_size;\n\t\t*array = u.val64;\n\t\tarray = (void *)array + sizeof(u32);\n\n\t\tmemcpy(array, sample->raw_data, sample->raw_size);\n\t\tarray = (void *)array + sample->raw_size;\n\t}\n\n\tif (type & PERF_SAMPLE_BRANCH_STACK) {\n\t\tsz = sample->branch_stack->nr * sizeof(struct branch_entry);\n\t\t \n\t\tsz += 2 * sizeof(u64);\n\t\tmemcpy(array, sample->branch_stack, sz);\n\t\tarray = (void *)array + sz;\n\t}\n\n\tif (type & PERF_SAMPLE_REGS_USER) {\n\t\tif (sample->user_regs.abi) {\n\t\t\t*array++ = sample->user_regs.abi;\n\t\t\tsz = hweight64(sample->user_regs.mask) * sizeof(u64);\n\t\t\tmemcpy(array, sample->user_regs.regs, sz);\n\t\t\tarray = (void *)array + sz;\n\t\t} else {\n\t\t\t*array++ = 0;\n\t\t}\n\t}\n\n\tif (type & PERF_SAMPLE_STACK_USER) {\n\t\tsz = sample->user_stack.size;\n\t\t*array++ = sz;\n\t\tif (sz) {\n\t\t\tmemcpy(array, sample->user_stack.data, sz);\n\t\t\tarray = (void *)array + sz;\n\t\t\t*array++ = sz;\n\t\t}\n\t}\n\n\tif (type & PERF_SAMPLE_WEIGHT_TYPE) {\n\t\tarch_perf_synthesize_sample_weight(sample, array, type);\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_DATA_SRC) {\n\t\t*array = sample->data_src;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_TRANSACTION) {\n\t\t*array = sample->transaction;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_REGS_INTR) {\n\t\tif (sample->intr_regs.abi) {\n\t\t\t*array++ = sample->intr_regs.abi;\n\t\t\tsz = hweight64(sample->intr_regs.mask) * sizeof(u64);\n\t\t\tmemcpy(array, sample->intr_regs.regs, sz);\n\t\t\tarray = (void *)array + sz;\n\t\t} else {\n\t\t\t*array++ = 0;\n\t\t}\n\t}\n\n\tif (type & PERF_SAMPLE_PHYS_ADDR) {\n\t\t*array = sample->phys_addr;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_CGROUP) {\n\t\t*array = sample->cgroup;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_DATA_PAGE_SIZE) {\n\t\t*array = sample->data_page_size;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_CODE_PAGE_SIZE) {\n\t\t*array = sample->code_page_size;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_AUX) {\n\t\tsz = sample->aux_sample.size;\n\t\t*array++ = sz;\n\t\tmemcpy(array, sample->aux_sample.data, sz);\n\t\tarray = (void *)array + sz;\n\t}\n\n\treturn 0;\n}\n\nint perf_event__synthesize_id_sample(__u64 *array, u64 type, const struct perf_sample *sample)\n{\n\t__u64 *start = array;\n\n\t \n\tunion u64_swap u;\n\n\tif (type & PERF_SAMPLE_TID) {\n\t\tu.val32[0] = sample->pid;\n\t\tu.val32[1] = sample->tid;\n\t\t*array = u.val64;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_TIME) {\n\t\t*array = sample->time;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_ID) {\n\t\t*array = sample->id;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_STREAM_ID) {\n\t\t*array = sample->stream_id;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_CPU) {\n\t\tu.val32[0] = sample->cpu;\n\t\tu.val32[1] = 0;\n\t\t*array = u.val64;\n\t\tarray++;\n\t}\n\n\tif (type & PERF_SAMPLE_IDENTIFIER) {\n\t\t*array = sample->id;\n\t\tarray++;\n\t}\n\n\treturn (void *)array - (void *)start;\n}\n\nint __perf_event__synthesize_id_index(struct perf_tool *tool, perf_event__handler_t process,\n\t\t\t\t      struct evlist *evlist, struct machine *machine, size_t from)\n{\n\tunion perf_event *ev;\n\tstruct evsel *evsel;\n\tsize_t nr = 0, i = 0, sz, max_nr, n, pos;\n\tsize_t e1_sz = sizeof(struct id_index_entry);\n\tsize_t e2_sz = sizeof(struct id_index_entry_2);\n\tsize_t etot_sz = e1_sz + e2_sz;\n\tbool e2_needed = false;\n\tint err;\n\n\tmax_nr = (UINT16_MAX - sizeof(struct perf_record_id_index)) / etot_sz;\n\n\tpos = 0;\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tif (pos++ < from)\n\t\t\tcontinue;\n\t\tnr += evsel->core.ids;\n\t}\n\n\tif (!nr)\n\t\treturn 0;\n\n\tpr_debug2(\"Synthesizing id index\\n\");\n\n\tn = nr > max_nr ? max_nr : nr;\n\tsz = sizeof(struct perf_record_id_index) + n * etot_sz;\n\tev = zalloc(sz);\n\tif (!ev)\n\t\treturn -ENOMEM;\n\n\tsz = sizeof(struct perf_record_id_index) + n * e1_sz;\n\n\tev->id_index.header.type = PERF_RECORD_ID_INDEX;\n\tev->id_index.nr = n;\n\n\tpos = 0;\n\tevlist__for_each_entry(evlist, evsel) {\n\t\tu32 j;\n\n\t\tif (pos++ < from)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < evsel->core.ids; j++, i++) {\n\t\t\tstruct id_index_entry *e;\n\t\t\tstruct id_index_entry_2 *e2;\n\t\t\tstruct perf_sample_id *sid;\n\n\t\t\tif (i >= n) {\n\t\t\t\tev->id_index.header.size = sz + (e2_needed ? n * e2_sz : 0);\n\t\t\t\terr = process(tool, ev, NULL, machine);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_err;\n\t\t\t\tnr -= n;\n\t\t\t\ti = 0;\n\t\t\t\te2_needed = false;\n\t\t\t}\n\n\t\t\te = &ev->id_index.entries[i];\n\n\t\t\te->id = evsel->core.id[j];\n\n\t\t\tsid = evlist__id2sid(evlist, e->id);\n\t\t\tif (!sid) {\n\t\t\t\tfree(ev);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\te->idx = sid->idx;\n\t\t\te->cpu = sid->cpu.cpu;\n\t\t\te->tid = sid->tid;\n\n\t\t\tif (sid->machine_pid)\n\t\t\t\te2_needed = true;\n\n\t\t\te2 = (void *)ev + sz;\n\t\t\te2[i].machine_pid = sid->machine_pid;\n\t\t\te2[i].vcpu        = sid->vcpu.cpu;\n\t\t}\n\t}\n\n\tsz = sizeof(struct perf_record_id_index) + nr * e1_sz;\n\tev->id_index.header.size = sz + (e2_needed ? nr * e2_sz : 0);\n\tev->id_index.nr = nr;\n\n\terr = process(tool, ev, NULL, machine);\nout_err:\n\tfree(ev);\n\n\treturn err;\n}\n\nint perf_event__synthesize_id_index(struct perf_tool *tool, perf_event__handler_t process,\n\t\t\t\t    struct evlist *evlist, struct machine *machine)\n{\n\treturn __perf_event__synthesize_id_index(tool, process, evlist, machine, 0);\n}\n\nint __machine__synthesize_threads(struct machine *machine, struct perf_tool *tool,\n\t\t\t\t  struct target *target, struct perf_thread_map *threads,\n\t\t\t\t  perf_event__handler_t process, bool needs_mmap,\n\t\t\t\t  bool data_mmap, unsigned int nr_threads_synthesize)\n{\n\t \n\tif (!nsinfo__is_in_root_namespace()) {\n\t\tpr_err(\"Perf runs in non-root PID namespace but it tries to \");\n\t\tpr_err(\"gather process info from its parent PID namespace.\\n\");\n\t\tpr_err(\"Please mount the proc file system properly, e.g. \");\n\t\tpr_err(\"add the option '--mount-proc' for unshare command.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (target__has_task(target))\n\t\treturn perf_event__synthesize_thread_map(tool, threads, process, machine,\n\t\t\t\t\t\t\t needs_mmap, data_mmap);\n\telse if (target__has_cpu(target))\n\t\treturn perf_event__synthesize_threads(tool, process, machine,\n\t\t\t\t\t\t      needs_mmap, data_mmap,\n\t\t\t\t\t\t      nr_threads_synthesize);\n\t \n\treturn 0;\n}\n\nint machine__synthesize_threads(struct machine *machine, struct target *target,\n\t\t\t\tstruct perf_thread_map *threads, bool needs_mmap,\n\t\t\t\tbool data_mmap, unsigned int nr_threads_synthesize)\n{\n\treturn __machine__synthesize_threads(machine, NULL, target, threads,\n\t\t\t\t\t     perf_event__process, needs_mmap,\n\t\t\t\t\t     data_mmap, nr_threads_synthesize);\n}\n\nstatic struct perf_record_event_update *event_update_event__new(size_t size, u64 type, u64 id)\n{\n\tstruct perf_record_event_update *ev;\n\n\tsize += sizeof(*ev);\n\tsize  = PERF_ALIGN(size, sizeof(u64));\n\n\tev = zalloc(size);\n\tif (ev) {\n\t\tev->header.type = PERF_RECORD_EVENT_UPDATE;\n\t\tev->header.size = (u16)size;\n\t\tev->type\t= type;\n\t\tev->id\t\t= id;\n\t}\n\treturn ev;\n}\n\nint perf_event__synthesize_event_update_unit(struct perf_tool *tool, struct evsel *evsel,\n\t\t\t\t\t     perf_event__handler_t process)\n{\n\tsize_t size = strlen(evsel->unit);\n\tstruct perf_record_event_update *ev;\n\tint err;\n\n\tev = event_update_event__new(size + 1, PERF_EVENT_UPDATE__UNIT, evsel->core.id[0]);\n\tif (ev == NULL)\n\t\treturn -ENOMEM;\n\n\tstrlcpy(ev->unit, evsel->unit, size + 1);\n\terr = process(tool, (union perf_event *)ev, NULL, NULL);\n\tfree(ev);\n\treturn err;\n}\n\nint perf_event__synthesize_event_update_scale(struct perf_tool *tool, struct evsel *evsel,\n\t\t\t\t\t      perf_event__handler_t process)\n{\n\tstruct perf_record_event_update *ev;\n\tstruct perf_record_event_update_scale *ev_data;\n\tint err;\n\n\tev = event_update_event__new(sizeof(*ev_data), PERF_EVENT_UPDATE__SCALE, evsel->core.id[0]);\n\tif (ev == NULL)\n\t\treturn -ENOMEM;\n\n\tev->scale.scale = evsel->scale;\n\terr = process(tool, (union perf_event *)ev, NULL, NULL);\n\tfree(ev);\n\treturn err;\n}\n\nint perf_event__synthesize_event_update_name(struct perf_tool *tool, struct evsel *evsel,\n\t\t\t\t\t     perf_event__handler_t process)\n{\n\tstruct perf_record_event_update *ev;\n\tsize_t len = strlen(evsel__name(evsel));\n\tint err;\n\n\tev = event_update_event__new(len + 1, PERF_EVENT_UPDATE__NAME, evsel->core.id[0]);\n\tif (ev == NULL)\n\t\treturn -ENOMEM;\n\n\tstrlcpy(ev->name, evsel->name, len + 1);\n\terr = process(tool, (union perf_event *)ev, NULL, NULL);\n\tfree(ev);\n\treturn err;\n}\n\nint perf_event__synthesize_event_update_cpus(struct perf_tool *tool, struct evsel *evsel,\n\t\t\t\t\t     perf_event__handler_t process)\n{\n\tstruct synthesize_cpu_map_data syn_data = { .map = evsel->core.own_cpus };\n\tstruct perf_record_event_update *ev;\n\tint err;\n\n\tev = cpu_map_data__alloc(&syn_data, sizeof(struct perf_event_header) + 2 * sizeof(u64));\n\tif (!ev)\n\t\treturn -ENOMEM;\n\n\tsyn_data.data = &ev->cpus.cpus;\n\tev->header.type = PERF_RECORD_EVENT_UPDATE;\n\tev->header.size = (u16)syn_data.size;\n\tev->type\t= PERF_EVENT_UPDATE__CPUS;\n\tev->id\t\t= evsel->core.id[0];\n\tcpu_map_data__synthesize(&syn_data);\n\n\terr = process(tool, (union perf_event *)ev, NULL, NULL);\n\tfree(ev);\n\treturn err;\n}\n\nint perf_event__synthesize_attrs(struct perf_tool *tool, struct evlist *evlist,\n\t\t\t\t perf_event__handler_t process)\n{\n\tstruct evsel *evsel;\n\tint err = 0;\n\n\tevlist__for_each_entry(evlist, evsel) {\n\t\terr = perf_event__synthesize_attr(tool, &evsel->core.attr, evsel->core.ids,\n\t\t\t\t\t\t  evsel->core.id, process);\n\t\tif (err) {\n\t\t\tpr_debug(\"failed to create perf header attribute\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic bool has_unit(struct evsel *evsel)\n{\n\treturn evsel->unit && *evsel->unit;\n}\n\nstatic bool has_scale(struct evsel *evsel)\n{\n\treturn evsel->scale != 1;\n}\n\nint perf_event__synthesize_extra_attr(struct perf_tool *tool, struct evlist *evsel_list,\n\t\t\t\t      perf_event__handler_t process, bool is_pipe)\n{\n\tstruct evsel *evsel;\n\tint err;\n\n\t \n\tevlist__for_each_entry(evsel_list, evsel) {\n\t\tif (!evsel->supported)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (has_unit(evsel)) {\n\t\t\terr = perf_event__synthesize_event_update_unit(tool, evsel, process);\n\t\t\tif (err < 0) {\n\t\t\t\tpr_err(\"Couldn't synthesize evsel unit.\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tif (has_scale(evsel)) {\n\t\t\terr = perf_event__synthesize_event_update_scale(tool, evsel, process);\n\t\t\tif (err < 0) {\n\t\t\t\tpr_err(\"Couldn't synthesize evsel evsel.\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tif (evsel->core.own_cpus) {\n\t\t\terr = perf_event__synthesize_event_update_cpus(tool, evsel, process);\n\t\t\tif (err < 0) {\n\t\t\t\tpr_err(\"Couldn't synthesize evsel cpus.\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (is_pipe) {\n\t\t\terr = perf_event__synthesize_event_update_name(tool, evsel, process);\n\t\t\tif (err < 0) {\n\t\t\t\tpr_err(\"Couldn't synthesize evsel name.\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint perf_event__synthesize_attr(struct perf_tool *tool, struct perf_event_attr *attr,\n\t\t\t\tu32 ids, u64 *id, perf_event__handler_t process)\n{\n\tunion perf_event *ev;\n\tsize_t size;\n\tint err;\n\n\tsize = sizeof(struct perf_event_attr);\n\tsize = PERF_ALIGN(size, sizeof(u64));\n\tsize += sizeof(struct perf_event_header);\n\tsize += ids * sizeof(u64);\n\n\tev = zalloc(size);\n\n\tif (ev == NULL)\n\t\treturn -ENOMEM;\n\n\tev->attr.attr = *attr;\n\tmemcpy(perf_record_header_attr_id(ev), id, ids * sizeof(u64));\n\n\tev->attr.header.type = PERF_RECORD_HEADER_ATTR;\n\tev->attr.header.size = (u16)size;\n\n\tif (ev->attr.header.size == size)\n\t\terr = process(tool, ev, NULL, NULL);\n\telse\n\t\terr = -E2BIG;\n\n\tfree(ev);\n\n\treturn err;\n}\n\n#ifdef HAVE_LIBTRACEEVENT\nint perf_event__synthesize_tracing_data(struct perf_tool *tool, int fd, struct evlist *evlist,\n\t\t\t\t\tperf_event__handler_t process)\n{\n\tunion perf_event ev;\n\tstruct tracing_data *tdata;\n\tssize_t size = 0, aligned_size = 0, padding;\n\tstruct feat_fd ff;\n\n\t \n\ttdata = tracing_data_get(&evlist->core.entries, fd, true);\n\tif (!tdata)\n\t\treturn -1;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tev.tracing_data.header.type = PERF_RECORD_HEADER_TRACING_DATA;\n\tsize = tdata->size;\n\taligned_size = PERF_ALIGN(size, sizeof(u64));\n\tpadding = aligned_size - size;\n\tev.tracing_data.header.size = sizeof(ev.tracing_data);\n\tev.tracing_data.size = aligned_size;\n\n\tprocess(tool, &ev, NULL, NULL);\n\n\t \n\ttracing_data_put(tdata);\n\n\tff = (struct feat_fd){ .fd = fd };\n\tif (write_padded(&ff, NULL, 0, padding))\n\t\treturn -1;\n\n\treturn aligned_size;\n}\n#endif\n\nint perf_event__synthesize_build_id(struct perf_tool *tool, struct dso *pos, u16 misc,\n\t\t\t\t    perf_event__handler_t process, struct machine *machine)\n{\n\tunion perf_event ev;\n\tsize_t len;\n\n\tif (!pos->hit)\n\t\treturn 0;\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tlen = pos->long_name_len + 1;\n\tlen = PERF_ALIGN(len, NAME_ALIGN);\n\tev.build_id.size = min(pos->bid.size, sizeof(pos->bid.data));\n\tmemcpy(&ev.build_id.build_id, pos->bid.data, ev.build_id.size);\n\tev.build_id.header.type = PERF_RECORD_HEADER_BUILD_ID;\n\tev.build_id.header.misc = misc | PERF_RECORD_MISC_BUILD_ID_SIZE;\n\tev.build_id.pid = machine->pid;\n\tev.build_id.header.size = sizeof(ev.build_id) + len;\n\tmemcpy(&ev.build_id.filename, pos->long_name, pos->long_name_len);\n\n\treturn process(tool, &ev, NULL, machine);\n}\n\nint perf_event__synthesize_stat_events(struct perf_stat_config *config, struct perf_tool *tool,\n\t\t\t\t       struct evlist *evlist, perf_event__handler_t process, bool attrs)\n{\n\tint err;\n\n\tif (attrs) {\n\t\terr = perf_event__synthesize_attrs(tool, evlist, process);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Couldn't synthesize attrs.\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = perf_event__synthesize_extra_attr(tool, evlist, process, attrs);\n\terr = perf_event__synthesize_thread_map2(tool, evlist->core.threads, process, NULL);\n\tif (err < 0) {\n\t\tpr_err(\"Couldn't synthesize thread map.\\n\");\n\t\treturn err;\n\t}\n\n\terr = perf_event__synthesize_cpu_map(tool, evlist->core.user_requested_cpus, process, NULL);\n\tif (err < 0) {\n\t\tpr_err(\"Couldn't synthesize thread map.\\n\");\n\t\treturn err;\n\t}\n\n\terr = perf_event__synthesize_stat_config(tool, config, process, NULL);\n\tif (err < 0) {\n\t\tpr_err(\"Couldn't synthesize config.\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nextern const struct perf_header_feature_ops feat_ops[HEADER_LAST_FEATURE];\n\nint perf_event__synthesize_features(struct perf_tool *tool, struct perf_session *session,\n\t\t\t\t    struct evlist *evlist, perf_event__handler_t process)\n{\n\tstruct perf_header *header = &session->header;\n\tstruct perf_record_header_feature *fe;\n\tstruct feat_fd ff;\n\tsize_t sz, sz_hdr;\n\tint feat, ret;\n\n\tsz_hdr = sizeof(fe->header);\n\tsz = sizeof(union perf_event);\n\t \n\tsz = PERF_ALIGN(sz, page_size);\n\n\tmemset(&ff, 0, sizeof(ff));\n\n\tff.buf = malloc(sz);\n\tif (!ff.buf)\n\t\treturn -ENOMEM;\n\n\tff.size = sz - sz_hdr;\n\tff.ph = &session->header;\n\n\tfor_each_set_bit(feat, header->adds_features, HEADER_FEAT_BITS) {\n\t\tif (!feat_ops[feat].synthesize) {\n\t\t\tpr_debug(\"No record header feature for header :%d\\n\", feat);\n\t\t\tcontinue;\n\t\t}\n\n\t\tff.offset = sizeof(*fe);\n\n\t\tret = feat_ops[feat].write(&ff, evlist);\n\t\tif (ret || ff.offset <= (ssize_t)sizeof(*fe)) {\n\t\t\tpr_debug(\"Error writing feature\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfe = ff.buf;\n\t\tmemset(fe, 0, sizeof(*fe));\n\n\t\tfe->feat_id = feat;\n\t\tfe->header.type = PERF_RECORD_HEADER_FEATURE;\n\t\tfe->header.size = ff.offset;\n\n\t\tret = process(tool, ff.buf, NULL, NULL);\n\t\tif (ret) {\n\t\t\tfree(ff.buf);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfe = ff.buf;\n\tfe->feat_id     = HEADER_LAST_FEATURE;\n\tfe->header.type = PERF_RECORD_HEADER_FEATURE;\n\tfe->header.size = sizeof(*fe);\n\n\tret = process(tool, ff.buf, NULL, NULL);\n\n\tfree(ff.buf);\n\treturn ret;\n}\n\nint perf_event__synthesize_for_pipe(struct perf_tool *tool,\n\t\t\t\t    struct perf_session *session,\n\t\t\t\t    struct perf_data *data,\n\t\t\t\t    perf_event__handler_t process)\n{\n\tint err;\n\tint ret = 0;\n\tstruct evlist *evlist = session->evlist;\n\n\t \n\terr = perf_event__synthesize_attrs(tool, evlist, process);\n\tif (err < 0) {\n\t\tpr_err(\"Couldn't synthesize attrs.\\n\");\n\t\treturn err;\n\t}\n\tret += err;\n\n\terr = perf_event__synthesize_features(tool, session, evlist, process);\n\tif (err < 0) {\n\t\tpr_err(\"Couldn't synthesize features.\\n\");\n\t\treturn err;\n\t}\n\tret += err;\n\n#ifdef HAVE_LIBTRACEEVENT\n\tif (have_tracepoints(&evlist->core.entries)) {\n\t\tint fd = perf_data__fd(data);\n\n\t\t \n\t\terr = perf_event__synthesize_tracing_data(tool,\tfd, evlist,\n\t\t\t\t\t\t\t  process);\n\t\tif (err <= 0) {\n\t\t\tpr_err(\"Couldn't record tracing data.\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tret += err;\n\t}\n#else\n\t(void)data;\n#endif\n\n\treturn ret;\n}\n\nint parse_synth_opt(char *synth)\n{\n\tchar *p, *q;\n\tint ret = 0;\n\n\tif (synth == NULL)\n\t\treturn -1;\n\n\tfor (q = synth; (p = strsep(&q, \",\")); p = q) {\n\t\tif (!strcasecmp(p, \"no\") || !strcasecmp(p, \"none\"))\n\t\t\treturn 0;\n\n\t\tif (!strcasecmp(p, \"all\"))\n\t\t\treturn PERF_SYNTH_ALL;\n\n\t\tif (!strcasecmp(p, \"task\"))\n\t\t\tret |= PERF_SYNTH_TASK;\n\t\telse if (!strcasecmp(p, \"mmap\"))\n\t\t\tret |= PERF_SYNTH_TASK | PERF_SYNTH_MMAP;\n\t\telse if (!strcasecmp(p, \"cgroup\"))\n\t\t\tret |= PERF_SYNTH_CGROUP;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}