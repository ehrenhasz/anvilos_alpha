{
  "module_name": "util.h",
  "hash_id": "c2c37235ec0ce44125641c46712e9642de84761fa4507a7ef55e6d17990cdb47",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/util.h",
  "human_readable_source": " \n#ifndef __PERF_UTIL_H\n#define __PERF_UTIL_H\n\n#define _BSD_SOURCE 1\n \n#define _DEFAULT_SOURCE 1\n\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <linux/compiler.h>\n#include <sys/types.h>\n#ifndef __cplusplus\n#include <internal/cpumap.h>\n#endif\n\nextern const char perf_usage_string[];\nextern const char perf_more_info_string[];\n\nextern const char *input_name;\n\nextern bool perf_host;\nextern bool perf_guest;\n\n \nvoid usage(const char *err) __noreturn;\nvoid die(const char *err, ...) __noreturn __printf(1, 2);\n\nstruct dirent;\nstruct strlist;\n\nint mkdir_p(char *path, mode_t mode);\nint rm_rf(const char *path);\nint rm_rf_perf_data(const char *path);\nstruct strlist *lsdir(const char *name, bool (*filter)(const char *, struct dirent *));\nbool lsdir_no_dot_filter(const char *name, struct dirent *d);\n\nsize_t hex_width(u64 v);\n\nint sysctl__max_stack(void);\n\nbool sysctl__nmi_watchdog_enabled(void);\n\nint fetch_kernel_version(unsigned int *puint,\n\t\t\t char *str, size_t str_sz);\n#define KVER_VERSION(x)\t\t(((x) >> 16) & 0xff)\n#define KVER_PATCHLEVEL(x)\t(((x) >> 8) & 0xff)\n#define KVER_SUBLEVEL(x)\t((x) & 0xff)\n#define KVER_FMT\t\"%d.%d.%d\"\n#define KVER_PARAM(x)\tKVER_VERSION(x), KVER_PATCHLEVEL(x), KVER_SUBLEVEL(x)\n\nint perf_tip(char **strp, const char *dirpath);\n\n#ifndef HAVE_SCHED_GETCPU_SUPPORT\nint sched_getcpu(void);\n#endif\n\nextern bool perf_singlethreaded;\n\nvoid perf_set_singlethreaded(void);\nvoid perf_set_multithreaded(void);\n\nchar *perf_exe(char *buf, int len);\n\n#ifndef O_CLOEXEC\n#ifdef __sparc__\n#define O_CLOEXEC      0x400000\n#elif defined(__alpha__) || defined(__hppa__)\n#define O_CLOEXEC      010000000\n#else\n#define O_CLOEXEC      02000000\n#endif\n#endif\n\nextern bool test_attr__enabled;\nvoid test_attr__ready(void);\nvoid test_attr__init(void);\nstruct perf_event_attr;\nvoid test_attr__open(struct perf_event_attr *attr, pid_t pid, struct perf_cpu cpu,\n\t\t     int fd, int group_fd, unsigned long flags);\n\nstruct perf_debuginfod {\n\tconst char\t*urls;\n\tbool\t\t set;\n};\nvoid perf_debuginfod_setup(struct perf_debuginfod *di);\n\nchar *filename_with_chroot(int pid, const char *filename);\n\nint do_realloc_array_as_needed(void **arr, size_t *arr_sz, size_t x,\n\t\t\t       size_t msz, const void *init_val);\n\n#define realloc_array_as_needed(a, n, x, v) ({\t\t\t\\\n\ttypeof(x) __x = (x);\t\t\t\t\t\\\n\t__x >= (n) ?\t\t\t\t\t\t\\\n\t\tdo_realloc_array_as_needed((void **)&(a),\t\\\n\t\t\t\t\t   &(n),\t\t\\\n\t\t\t\t\t   __x,\t\t\t\\\n\t\t\t\t\t   sizeof(*(a)),\t\\\n\t\t\t\t\t   (const void *)(v)) :\t\\\n\t\t0;\t\t\t\t\t\t\\\n\t})\n\nstatic inline bool host_is_bigendian(void)\n{\n#ifdef __BYTE_ORDER__\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n\treturn false;\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n\treturn true;\n#else\n#error \"Unrecognized __BYTE_ORDER__\"\n#endif\n#else  \n\tunsigned char str[] = { 0x1, 0x2, 0x3, 0x4, 0x0, 0x0, 0x0, 0x0};\n\tunsigned int *ptr;\n\n\tptr = (unsigned int *)(void *)str;\n\treturn *ptr == 0x01020304;\n#endif\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}