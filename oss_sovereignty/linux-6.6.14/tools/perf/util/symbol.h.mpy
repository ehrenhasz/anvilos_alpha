{
  "module_name": "symbol.h",
  "hash_id": "f5e6f78fba4af5074f36ac77bfaf7f004af84317f7e011062f720818df3fea5d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/symbol.h",
  "human_readable_source": " \n#ifndef __PERF_SYMBOL\n#define __PERF_SYMBOL 1\n\n#include <linux/types.h>\n#include <linux/refcount.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <stdio.h>\n#include \"addr_location.h\"\n#include \"path.h\"\n#include \"symbol_conf.h\"\n#include \"spark.h\"\n\n#ifdef HAVE_LIBELF_SUPPORT\n#include <libelf.h>\n#include <gelf.h>\n#endif\n#include <elf.h>\n\nstruct dso;\nstruct map;\nstruct maps;\nstruct option;\nstruct build_id;\n\n \n#ifdef ELF_C_READ_MMAP\n# define PERF_ELF_C_READ_MMAP ELF_C_READ_MMAP\n#else\n# define PERF_ELF_C_READ_MMAP ELF_C_READ\n#endif\n\n#ifdef HAVE_LIBELF_SUPPORT\nElf_Scn *elf_section_by_name(Elf *elf, GElf_Ehdr *ep,\n\t\t\t     GElf_Shdr *shp, const char *name, size_t *idx);\n#endif\n\n \nstruct symbol {\n\tstruct rb_node\trb_node;\n\t \n\tu64\t\tstart;\n\tu64\t\tend;\n\t \n\tu16\t\tnamelen;\n\t \n\tu8\t\ttype:4;\n\t \n\tu8\t\tbinding:4;\n\t \n\tu8\t\tidle:1;\n\t \n\tu8\t\tignore:1;\n\t \n\tu8\t\tinlined:1;\n\t \n\tu8\t\tannotate2:1;\n\t \n\tu8\t\tifunc_alias:1;\n\t \n\tu8\t\tarch_sym;\n\t \n\tchar\t\tname[];\n};\n\nvoid symbol__delete(struct symbol *sym);\nvoid symbols__delete(struct rb_root_cached *symbols);\n\n \n#define symbols__for_each_entry(symbols, pos, nd)\t\t\t\\\n\tfor (nd = rb_first_cached(symbols);\t\t\t\t\t\\\n\t     nd && (pos = rb_entry(nd, struct symbol, rb_node));\t\\\n\t     nd = rb_next(nd))\n\nstatic inline size_t symbol__size(const struct symbol *sym)\n{\n\treturn sym->end - sym->start;\n}\n\nstruct strlist;\nstruct intlist;\n\nstatic inline int __symbol__join_symfs(char *bf, size_t size, const char *path)\n{\n\treturn path__join(bf, size, symbol_conf.symfs, path);\n}\n\n#define symbol__join_symfs(bf, path) __symbol__join_symfs(bf, sizeof(bf), path)\n\nextern int vmlinux_path__nr_entries;\nextern char **vmlinux_path;\n\nstatic inline void *symbol__priv(struct symbol *sym)\n{\n\treturn ((void *)sym) - symbol_conf.priv_size;\n}\n\nstruct ref_reloc_sym {\n\tconst char\t*name;\n\tu64\t\taddr;\n\tu64\t\tunrelocated_addr;\n};\n\nint dso__load(struct dso *dso, struct map *map);\nint dso__load_vmlinux(struct dso *dso, struct map *map,\n\t\t      const char *vmlinux, bool vmlinux_allocated);\nint dso__load_vmlinux_path(struct dso *dso, struct map *map);\nint __dso__load_kallsyms(struct dso *dso, const char *filename, struct map *map,\n\t\t\t bool no_kcore);\nint dso__load_kallsyms(struct dso *dso, const char *filename, struct map *map);\n\nvoid dso__insert_symbol(struct dso *dso,\n\t\t\tstruct symbol *sym);\nvoid dso__delete_symbol(struct dso *dso,\n\t\t\tstruct symbol *sym);\n\nstruct symbol *dso__find_symbol(struct dso *dso, u64 addr);\nstruct symbol *dso__find_symbol_nocache(struct dso *dso, u64 addr);\n\nstruct symbol *dso__next_symbol_by_name(struct dso *dso, size_t *idx);\nstruct symbol *dso__find_symbol_by_name(struct dso *dso, const char *name, size_t *idx);\n\nstruct symbol *dso__first_symbol(struct dso *dso);\nstruct symbol *dso__last_symbol(struct dso *dso);\nstruct symbol *dso__next_symbol(struct symbol *sym);\n\nenum dso_type dso__type_fd(int fd);\n\nint filename__read_build_id(const char *filename, struct build_id *id);\nint sysfs__read_build_id(const char *filename, struct build_id *bid);\nint modules__parse(const char *filename, void *arg,\n\t\t   int (*process_module)(void *arg, const char *name,\n\t\t\t\t\t u64 start, u64 size));\nint filename__read_debuglink(const char *filename, char *debuglink,\n\t\t\t     size_t size);\nbool filename__has_section(const char *filename, const char *sec);\n\nstruct perf_env;\nint symbol__init(struct perf_env *env);\nvoid symbol__exit(void);\nvoid symbol__elf_init(void);\nint symbol__annotation_init(void);\n\nstruct symbol *symbol__new(u64 start, u64 len, u8 binding, u8 type, const char *name);\nsize_t __symbol__fprintf_symname_offs(const struct symbol *sym,\n\t\t\t\t      const struct addr_location *al,\n\t\t\t\t      bool unknown_as_addr,\n\t\t\t\t      bool print_offsets, FILE *fp);\nsize_t symbol__fprintf_symname_offs(const struct symbol *sym,\n\t\t\t\t    const struct addr_location *al, FILE *fp);\nsize_t __symbol__fprintf_symname(const struct symbol *sym,\n\t\t\t\t const struct addr_location *al,\n\t\t\t\t bool unknown_as_addr, FILE *fp);\nsize_t symbol__fprintf_symname(const struct symbol *sym, FILE *fp);\nsize_t symbol__fprintf(struct symbol *sym, FILE *fp);\nbool symbol__restricted_filename(const char *filename,\n\t\t\t\t const char *restricted_filename);\nint symbol__config_symfs(const struct option *opt __maybe_unused,\n\t\t\t const char *dir, int unset __maybe_unused);\n\nstruct symsrc;\n\n#ifdef HAVE_LIBBFD_SUPPORT\nint dso__load_bfd_symbols(struct dso *dso, const char *debugfile);\n#endif\n\nint dso__load_sym(struct dso *dso, struct map *map, struct symsrc *syms_ss,\n\t\t  struct symsrc *runtime_ss, int kmodule);\nint dso__synthesize_plt_symbols(struct dso *dso, struct symsrc *ss);\n\nchar *dso__demangle_sym(struct dso *dso, int kmodule, const char *elf_name);\n\nvoid __symbols__insert(struct rb_root_cached *symbols, struct symbol *sym,\n\t\t       bool kernel);\nvoid symbols__insert(struct rb_root_cached *symbols, struct symbol *sym);\nvoid symbols__fixup_duplicate(struct rb_root_cached *symbols);\nvoid symbols__fixup_end(struct rb_root_cached *symbols, bool is_kallsyms);\nvoid maps__fixup_end(struct maps *maps);\n\ntypedef int (*mapfn_t)(u64 start, u64 len, u64 pgoff, void *data);\nint file__read_maps(int fd, bool exe, mapfn_t mapfn, void *data,\n\t\t    bool *is_64_bit);\n\n#define PERF_KCORE_EXTRACT \"/tmp/perf-kcore-XXXXXX\"\n\nstruct kcore_extract {\n\tchar *kcore_filename;\n\tu64 addr;\n\tu64 offs;\n\tu64 len;\n\tchar extract_filename[sizeof(PERF_KCORE_EXTRACT)];\n\tint fd;\n};\n\nint kcore_extract__create(struct kcore_extract *kce);\nvoid kcore_extract__delete(struct kcore_extract *kce);\n\nint kcore_copy(const char *from_dir, const char *to_dir);\nint compare_proc_modules(const char *from, const char *to);\n\nint setup_list(struct strlist **list, const char *list_str,\n\t       const char *list_name);\nint setup_intlist(struct intlist **list, const char *list_str,\n\t\t  const char *list_name);\n\n#ifdef HAVE_LIBELF_SUPPORT\nbool elf__needs_adjust_symbols(GElf_Ehdr ehdr);\nvoid arch__sym_update(struct symbol *s, GElf_Sym *sym);\n#endif\n\nconst char *arch__normalize_symbol_name(const char *name);\n#define SYMBOL_A 0\n#define SYMBOL_B 1\n\nint arch__compare_symbol_names(const char *namea, const char *nameb);\nint arch__compare_symbol_names_n(const char *namea, const char *nameb,\n\t\t\t\t unsigned int n);\nint arch__choose_best_symbol(struct symbol *syma, struct symbol *symb);\n\nenum symbol_tag_include {\n\tSYMBOL_TAG_INCLUDE__NONE = 0,\n\tSYMBOL_TAG_INCLUDE__DEFAULT_ONLY\n};\n\nint symbol__match_symbol_name(const char *namea, const char *nameb,\n\t\t\t      enum symbol_tag_include includes);\n\n \nstruct sdt_note {\n\tchar *name;\t\t\t \n\tchar *provider;\t\t\t \n\tchar *args;\n\tbool bit32;\t\t\t \n\tunion {\t\t\t\t \n\t\tElf64_Addr a64[3];\n\t\tElf32_Addr a32[3];\n\t} addr;\n\tstruct list_head note_list;\t \n};\n\nint get_sdt_note_list(struct list_head *head, const char *target);\nint cleanup_sdt_note_list(struct list_head *sdt_notes);\nint sdt_notes__get_count(struct list_head *start);\n\n#define SDT_PROBES_SCN \".probes\"\n#define SDT_BASE_SCN \".stapsdt.base\"\n#define SDT_NOTE_SCN  \".note.stapsdt\"\n#define SDT_NOTE_TYPE 3\n#define SDT_NOTE_NAME \"stapsdt\"\n#define NR_ADDR 3\n\nenum {\n\tSDT_NOTE_IDX_LOC = 0,\n\tSDT_NOTE_IDX_BASE,\n\tSDT_NOTE_IDX_REFCTR,\n};\n\nstruct mem_info *mem_info__new(void);\nstruct mem_info *mem_info__get(struct mem_info *mi);\nvoid   mem_info__put(struct mem_info *mi);\n\nstatic inline void __mem_info__zput(struct mem_info **mi)\n{\n\tmem_info__put(*mi);\n\t*mi = NULL;\n}\n\n#define mem_info__zput(mi) __mem_info__zput(&mi)\n\nint symbol__validate_sym_arguments(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}