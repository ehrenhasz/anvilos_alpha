{
  "module_name": "bpf_map.c",
  "hash_id": "fae81d1ad06cf063af25195431af016947ad5dcad7c6b8da55a0161108e603c3",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf_map.c",
  "human_readable_source": "\n\n#include \"util/bpf_map.h\"\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nstatic bool bpf_map__is_per_cpu(enum bpf_map_type type)\n{\n\treturn type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t       type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t       type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t       type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE;\n}\n\nstatic void *bpf_map__alloc_value(const struct bpf_map *map)\n{\n\tif (bpf_map__is_per_cpu(bpf_map__type(map)))\n\t\treturn malloc(round_up(bpf_map__value_size(map), 8) *\n\t\t\t      sysconf(_SC_NPROCESSORS_CONF));\n\n\treturn malloc(bpf_map__value_size(map));\n}\n\nint bpf_map__fprintf(struct bpf_map *map, FILE *fp)\n{\n\tvoid *prev_key = NULL, *key, *value;\n\tint fd = bpf_map__fd(map), err;\n\tint printed = 0;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (!map)\n\t\treturn PTR_ERR(map);\n\n\terr = -ENOMEM;\n\tkey = malloc(bpf_map__key_size(map));\n\tif (key == NULL)\n\t\tgoto out;\n\n\tvalue = bpf_map__alloc_value(map);\n\tif (value == NULL)\n\t\tgoto out_free_key;\n\n\twhile ((err = bpf_map_get_next_key(fd, prev_key, key) == 0)) {\n\t\tint intkey = *(int *)key;\n\n\t\tif (!bpf_map_lookup_elem(fd, key, value)) {\n\t\t\tbool boolval = *(bool *)value;\n\t\t\tif (boolval)\n\t\t\t\tprinted += fprintf(fp, \"[%d] = %d,\\n\", intkey, boolval);\n\t\t} else {\n\t\t\tprinted += fprintf(fp, \"[%d] = ERROR,\\n\", intkey);\n\t\t}\n\n\t\tprev_key = key;\n\t}\n\n\tif (err == ENOENT)\n\t\terr = printed;\n\n\tfree(value);\nout_free_key:\n\tfree(key);\nout:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}