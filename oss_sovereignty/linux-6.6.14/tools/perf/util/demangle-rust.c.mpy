{
  "module_name": "demangle-rust.c",
  "hash_id": "0af70a938c4c7557e49bc69115dbec43839d9a49ed0eaa80a654193b929bd6d4",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/demangle-rust.c",
  "human_readable_source": "\n#include <string.h>\n#include \"debug.h\"\n\n#include \"demangle-rust.h\"\n\n \n\nstatic const char *hash_prefix = \"::h\";\nstatic const size_t hash_prefix_len = 3;\nstatic const size_t hash_len = 16;\n\nstatic bool is_prefixed_hash(const char *start);\nstatic bool looks_like_rust(const char *sym, size_t len);\nstatic bool unescape(const char **in, char **out, const char *seq, char value);\n\n \nbool\nrust_is_mangled(const char *sym)\n{\n\tsize_t len, len_without_hash;\n\n\tif (!sym)\n\t\treturn false;\n\n\tlen = strlen(sym);\n\tif (len <= hash_prefix_len + hash_len)\n\t\t \n\t\treturn false;\n\n\tlen_without_hash = len - (hash_prefix_len + hash_len);\n\tif (!is_prefixed_hash(sym + len_without_hash))\n\t\treturn false;\n\n\treturn looks_like_rust(sym, len_without_hash);\n}\n\n \nstatic bool is_prefixed_hash(const char *str)\n{\n\tconst char *end;\n\tbool seen[16];\n\tsize_t i;\n\tint count;\n\n\tif (strncmp(str, hash_prefix, hash_prefix_len))\n\t\treturn false;\n\tstr += hash_prefix_len;\n\n\tmemset(seen, false, sizeof(seen));\n\tfor (end = str + hash_len; str < end; str++)\n\t\tif (*str >= '0' && *str <= '9')\n\t\t\tseen[*str - '0'] = true;\n\t\telse if (*str >= 'a' && *str <= 'f')\n\t\t\tseen[*str - 'a' + 10] = true;\n\t\telse\n\t\t\treturn false;\n\n\t \n\tcount = 0;\n\tfor (i = 0; i < 16; i++)\n\t\tif (seen[i])\n\t\t\tcount++;\n\n\treturn count >= 5 && count <= 15;\n}\n\nstatic bool looks_like_rust(const char *str, size_t len)\n{\n\tconst char *end = str + len;\n\n\twhile (str < end)\n\t\tswitch (*str) {\n\t\tcase '$':\n\t\t\tif (!strncmp(str, \"$C$\", 3))\n\t\t\t\tstr += 3;\n\t\t\telse if (!strncmp(str, \"$SP$\", 4)\n\t\t\t\t\t|| !strncmp(str, \"$BP$\", 4)\n\t\t\t\t\t|| !strncmp(str, \"$RF$\", 4)\n\t\t\t\t\t|| !strncmp(str, \"$LT$\", 4)\n\t\t\t\t\t|| !strncmp(str, \"$GT$\", 4)\n\t\t\t\t\t|| !strncmp(str, \"$LP$\", 4)\n\t\t\t\t\t|| !strncmp(str, \"$RP$\", 4))\n\t\t\t\tstr += 4;\n\t\t\telse if (!strncmp(str, \"$u20$\", 5)\n\t\t\t\t\t|| !strncmp(str, \"$u27$\", 5)\n\t\t\t\t\t|| !strncmp(str, \"$u5b$\", 5)\n\t\t\t\t\t|| !strncmp(str, \"$u5d$\", 5)\n\t\t\t\t\t|| !strncmp(str, \"$u7e$\", 5))\n\t\t\t\tstr += 5;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\t \n\t\t\tif (!strncmp(str, \"...\", 3))\n\t\t\t\treturn false;\n\t\t\t \n\t\tcase 'a' ... 'z':\n\t\tcase 'A' ... 'Z':\n\t\tcase '0' ... '9':\n\t\tcase '_':\n\t\tcase ':':\n\t\t\tstr++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\n\treturn true;\n}\n\n \nvoid\nrust_demangle_sym(char *sym)\n{\n\tconst char *in;\n\tchar *out;\n\tconst char *end;\n\n\tif (!sym)\n\t\treturn;\n\n\tin = sym;\n\tout = sym;\n\tend = sym + strlen(sym) - (hash_prefix_len + hash_len);\n\n\twhile (in < end)\n\t\tswitch (*in) {\n\t\tcase '$':\n\t\t\tif (!(unescape(&in, &out, \"$C$\", ',')\n\t\t\t\t\t|| unescape(&in, &out, \"$SP$\", '@')\n\t\t\t\t\t|| unescape(&in, &out, \"$BP$\", '*')\n\t\t\t\t\t|| unescape(&in, &out, \"$RF$\", '&')\n\t\t\t\t\t|| unescape(&in, &out, \"$LT$\", '<')\n\t\t\t\t\t|| unescape(&in, &out, \"$GT$\", '>')\n\t\t\t\t\t|| unescape(&in, &out, \"$LP$\", '(')\n\t\t\t\t\t|| unescape(&in, &out, \"$RP$\", ')')\n\t\t\t\t\t|| unescape(&in, &out, \"$u20$\", ' ')\n\t\t\t\t\t|| unescape(&in, &out, \"$u27$\", '\\'')\n\t\t\t\t\t|| unescape(&in, &out, \"$u5b$\", '[')\n\t\t\t\t\t|| unescape(&in, &out, \"$u5d$\", ']')\n\t\t\t\t\t|| unescape(&in, &out, \"$u7e$\", '~'))) {\n\t\t\t\tpr_err(\"demangle-rust: unexpected escape sequence\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '_':\n\t\t\t \n\t\t\tif ((in == sym || in[-1] == ':') && in[1] == '$')\n\t\t\t\tin++;\n\t\t\telse\n\t\t\t\t*out++ = *in++;\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tif (in[1] == '.') {\n\t\t\t\t \n\t\t\t\t*out++ = ':';\n\t\t\t\t*out++ = ':';\n\t\t\t\tin += 2;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*out++ = '-';\n\t\t\t\tin++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a' ... 'z':\n\t\tcase 'A' ... 'Z':\n\t\tcase '0' ... '9':\n\t\tcase ':':\n\t\t\t*out++ = *in++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"demangle-rust: unexpected character '%c' in symbol\\n\",\n\t\t\t\t*in);\n\t\t\tgoto done;\n\t\t}\n\ndone:\n\t*out = '\\0';\n}\n\nstatic bool unescape(const char **in, char **out, const char *seq, char value)\n{\n\tsize_t len = strlen(seq);\n\n\tif (strncmp(*in, seq, len))\n\t\treturn false;\n\n\t**out = value;\n\n\t*in += len;\n\t*out += 1;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}