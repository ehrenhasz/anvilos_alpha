{
  "module_name": "dso.c",
  "hash_id": "92443be2301f81ba5bc03982acfc7932786a92d9d405a82a13055185f2c88b8d",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/dso.c",
  "human_readable_source": "\n#include <asm/bug.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/zalloc.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#ifdef HAVE_LIBBPF_SUPPORT\n#include <bpf/libbpf.h>\n#include \"bpf-event.h\"\n#include \"bpf-utils.h\"\n#endif\n#include \"compress.h\"\n#include \"env.h\"\n#include \"namespaces.h\"\n#include \"path.h\"\n#include \"map.h\"\n#include \"symbol.h\"\n#include \"srcline.h\"\n#include \"dso.h\"\n#include \"dsos.h\"\n#include \"machine.h\"\n#include \"auxtrace.h\"\n#include \"util.h\"  \n#include \"debug.h\"\n#include \"string2.h\"\n#include \"vdso.h\"\n\nstatic const char * const debuglink_paths[] = {\n\t\"%.0s%s\",\n\t\"%s/%s\",\n\t\"%s/.debug/%s\",\n\t\"/usr/lib/debug%s/%s\"\n};\n\nchar dso__symtab_origin(const struct dso *dso)\n{\n\tstatic const char origin[] = {\n\t\t[DSO_BINARY_TYPE__KALLSYMS]\t\t\t= 'k',\n\t\t[DSO_BINARY_TYPE__VMLINUX]\t\t\t= 'v',\n\t\t[DSO_BINARY_TYPE__JAVA_JIT]\t\t\t= 'j',\n\t\t[DSO_BINARY_TYPE__DEBUGLINK]\t\t\t= 'l',\n\t\t[DSO_BINARY_TYPE__BUILD_ID_CACHE]\t\t= 'B',\n\t\t[DSO_BINARY_TYPE__BUILD_ID_CACHE_DEBUGINFO]\t= 'D',\n\t\t[DSO_BINARY_TYPE__FEDORA_DEBUGINFO]\t\t= 'f',\n\t\t[DSO_BINARY_TYPE__UBUNTU_DEBUGINFO]\t\t= 'u',\n\t\t[DSO_BINARY_TYPE__MIXEDUP_UBUNTU_DEBUGINFO]\t= 'x',\n\t\t[DSO_BINARY_TYPE__OPENEMBEDDED_DEBUGINFO]\t= 'o',\n\t\t[DSO_BINARY_TYPE__BUILDID_DEBUGINFO]\t\t= 'b',\n\t\t[DSO_BINARY_TYPE__SYSTEM_PATH_DSO]\t\t= 'd',\n\t\t[DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE]\t\t= 'K',\n\t\t[DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP]\t= 'm',\n\t\t[DSO_BINARY_TYPE__GUEST_KALLSYMS]\t\t= 'g',\n\t\t[DSO_BINARY_TYPE__GUEST_KMODULE]\t\t= 'G',\n\t\t[DSO_BINARY_TYPE__GUEST_KMODULE_COMP]\t\t= 'M',\n\t\t[DSO_BINARY_TYPE__GUEST_VMLINUX]\t\t= 'V',\n\t};\n\n\tif (dso == NULL || dso->symtab_type == DSO_BINARY_TYPE__NOT_FOUND)\n\t\treturn '!';\n\treturn origin[dso->symtab_type];\n}\n\nbool dso__is_object_file(const struct dso *dso)\n{\n\tswitch (dso->binary_type) {\n\tcase DSO_BINARY_TYPE__KALLSYMS:\n\tcase DSO_BINARY_TYPE__GUEST_KALLSYMS:\n\tcase DSO_BINARY_TYPE__JAVA_JIT:\n\tcase DSO_BINARY_TYPE__BPF_PROG_INFO:\n\tcase DSO_BINARY_TYPE__BPF_IMAGE:\n\tcase DSO_BINARY_TYPE__OOL:\n\t\treturn false;\n\tcase DSO_BINARY_TYPE__VMLINUX:\n\tcase DSO_BINARY_TYPE__GUEST_VMLINUX:\n\tcase DSO_BINARY_TYPE__DEBUGLINK:\n\tcase DSO_BINARY_TYPE__BUILD_ID_CACHE:\n\tcase DSO_BINARY_TYPE__BUILD_ID_CACHE_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__FEDORA_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__UBUNTU_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__MIXEDUP_UBUNTU_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__BUILDID_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__SYSTEM_PATH_DSO:\n\tcase DSO_BINARY_TYPE__GUEST_KMODULE:\n\tcase DSO_BINARY_TYPE__GUEST_KMODULE_COMP:\n\tcase DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE:\n\tcase DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP:\n\tcase DSO_BINARY_TYPE__KCORE:\n\tcase DSO_BINARY_TYPE__GUEST_KCORE:\n\tcase DSO_BINARY_TYPE__OPENEMBEDDED_DEBUGINFO:\n\tcase DSO_BINARY_TYPE__NOT_FOUND:\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nint dso__read_binary_type_filename(const struct dso *dso,\n\t\t\t\t   enum dso_binary_type type,\n\t\t\t\t   char *root_dir, char *filename, size_t size)\n{\n\tchar build_id_hex[SBUILD_ID_SIZE];\n\tint ret = 0;\n\tsize_t len;\n\n\tswitch (type) {\n\tcase DSO_BINARY_TYPE__DEBUGLINK:\n\t{\n\t\tconst char *last_slash;\n\t\tchar dso_dir[PATH_MAX];\n\t\tchar symfile[PATH_MAX];\n\t\tunsigned int i;\n\n\t\tlen = __symbol__join_symfs(filename, size, dso->long_name);\n\t\tlast_slash = filename + len;\n\t\twhile (last_slash != filename && *last_slash != '/')\n\t\t\tlast_slash--;\n\n\t\tstrncpy(dso_dir, filename, last_slash - filename);\n\t\tdso_dir[last_slash-filename] = '\\0';\n\n\t\tif (!is_regular_file(filename)) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = filename__read_debuglink(filename, symfile, PATH_MAX);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tret = -1;\n\t\tfor (i = 0; i < ARRAY_SIZE(debuglink_paths); i++) {\n\t\t\tsnprintf(filename, size,\n\t\t\t\t\tdebuglink_paths[i], dso_dir, symfile);\n\t\t\tif (is_regular_file(filename)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase DSO_BINARY_TYPE__BUILD_ID_CACHE:\n\t\tif (dso__build_id_filename(dso, filename, size, false) == NULL)\n\t\t\tret = -1;\n\t\tbreak;\n\n\tcase DSO_BINARY_TYPE__BUILD_ID_CACHE_DEBUGINFO:\n\t\tif (dso__build_id_filename(dso, filename, size, true) == NULL)\n\t\t\tret = -1;\n\t\tbreak;\n\n\tcase DSO_BINARY_TYPE__FEDORA_DEBUGINFO:\n\t\tlen = __symbol__join_symfs(filename, size, \"/usr/lib/debug\");\n\t\tsnprintf(filename + len, size - len, \"%s.debug\", dso->long_name);\n\t\tbreak;\n\n\tcase DSO_BINARY_TYPE__UBUNTU_DEBUGINFO:\n\t\tlen = __symbol__join_symfs(filename, size, \"/usr/lib/debug\");\n\t\tsnprintf(filename + len, size - len, \"%s\", dso->long_name);\n\t\tbreak;\n\n\tcase DSO_BINARY_TYPE__MIXEDUP_UBUNTU_DEBUGINFO:\n\t\t \n\t\tif (strlen(dso->long_name) < 9 ||\n\t\t    strncmp(dso->long_name, \"/usr/lib/\", 9)) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tlen = __symbol__join_symfs(filename, size, \"/usr/lib/debug\");\n\t\tsnprintf(filename + len, size - len, \"%s\", dso->long_name + 4);\n\t\tbreak;\n\n\tcase DSO_BINARY_TYPE__OPENEMBEDDED_DEBUGINFO:\n\t{\n\t\tconst char *last_slash;\n\t\tsize_t dir_size;\n\n\t\tlast_slash = dso->long_name + dso->long_name_len;\n\t\twhile (last_slash != dso->long_name && *last_slash != '/')\n\t\t\tlast_slash--;\n\n\t\tlen = __symbol__join_symfs(filename, size, \"\");\n\t\tdir_size = last_slash - dso->long_name + 2;\n\t\tif (dir_size > (size - len)) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tlen += scnprintf(filename + len, dir_size, \"%s\",  dso->long_name);\n\t\tlen += scnprintf(filename + len , size - len, \".debug%s\",\n\t\t\t\t\t\t\t\tlast_slash);\n\t\tbreak;\n\t}\n\n\tcase DSO_BINARY_TYPE__BUILDID_DEBUGINFO:\n\t\tif (!dso->has_build_id) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuild_id__sprintf(&dso->bid, build_id_hex);\n\t\tlen = __symbol__join_symfs(filename, size, \"/usr/lib/debug/.build-id/\");\n\t\tsnprintf(filename + len, size - len, \"%.2s/%s.debug\",\n\t\t\t build_id_hex, build_id_hex + 2);\n\t\tbreak;\n\n\tcase DSO_BINARY_TYPE__VMLINUX:\n\tcase DSO_BINARY_TYPE__GUEST_VMLINUX:\n\tcase DSO_BINARY_TYPE__SYSTEM_PATH_DSO:\n\t\t__symbol__join_symfs(filename, size, dso->long_name);\n\t\tbreak;\n\n\tcase DSO_BINARY_TYPE__GUEST_KMODULE:\n\tcase DSO_BINARY_TYPE__GUEST_KMODULE_COMP:\n\t\tpath__join3(filename, size, symbol_conf.symfs,\n\t\t\t    root_dir, dso->long_name);\n\t\tbreak;\n\n\tcase DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE:\n\tcase DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP:\n\t\t__symbol__join_symfs(filename, size, dso->long_name);\n\t\tbreak;\n\n\tcase DSO_BINARY_TYPE__KCORE:\n\tcase DSO_BINARY_TYPE__GUEST_KCORE:\n\t\tsnprintf(filename, size, \"%s\", dso->long_name);\n\t\tbreak;\n\n\tdefault:\n\tcase DSO_BINARY_TYPE__KALLSYMS:\n\tcase DSO_BINARY_TYPE__GUEST_KALLSYMS:\n\tcase DSO_BINARY_TYPE__JAVA_JIT:\n\tcase DSO_BINARY_TYPE__BPF_PROG_INFO:\n\tcase DSO_BINARY_TYPE__BPF_IMAGE:\n\tcase DSO_BINARY_TYPE__OOL:\n\tcase DSO_BINARY_TYPE__NOT_FOUND:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nenum {\n\tCOMP_ID__NONE = 0,\n};\n\nstatic const struct {\n\tconst char *fmt;\n\tint (*decompress)(const char *input, int output);\n\tbool (*is_compressed)(const char *input);\n} compressions[] = {\n\t[COMP_ID__NONE] = { .fmt = NULL, },\n#ifdef HAVE_ZLIB_SUPPORT\n\t{ \"gz\", gzip_decompress_to_file, gzip_is_compressed },\n#endif\n#ifdef HAVE_LZMA_SUPPORT\n\t{ \"xz\", lzma_decompress_to_file, lzma_is_compressed },\n#endif\n\t{ NULL, NULL, NULL },\n};\n\nstatic int is_supported_compression(const char *ext)\n{\n\tunsigned i;\n\n\tfor (i = 1; compressions[i].fmt; i++) {\n\t\tif (!strcmp(ext, compressions[i].fmt))\n\t\t\treturn i;\n\t}\n\treturn COMP_ID__NONE;\n}\n\nbool is_kernel_module(const char *pathname, int cpumode)\n{\n\tstruct kmod_path m;\n\tint mode = cpumode & PERF_RECORD_MISC_CPUMODE_MASK;\n\n\tWARN_ONCE(mode != cpumode,\n\t\t  \"Internal error: passing unmasked cpumode (%x) to is_kernel_module\",\n\t\t  cpumode);\n\n\tswitch (mode) {\n\tcase PERF_RECORD_MISC_USER:\n\tcase PERF_RECORD_MISC_HYPERVISOR:\n\tcase PERF_RECORD_MISC_GUEST_USER:\n\t\treturn false;\n\t \n\tdefault:\n\t\tif (kmod_path__parse(&m, pathname)) {\n\t\t\tpr_err(\"Failed to check whether %s is a kernel module or not. Assume it is.\",\n\t\t\t\t\tpathname);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn m.kmod;\n}\n\nbool dso__needs_decompress(struct dso *dso)\n{\n\treturn dso->symtab_type == DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE_COMP ||\n\t\tdso->symtab_type == DSO_BINARY_TYPE__GUEST_KMODULE_COMP;\n}\n\nint filename__decompress(const char *name, char *pathname,\n\t\t\t size_t len, int comp, int *err)\n{\n\tchar tmpbuf[] = KMOD_DECOMP_NAME;\n\tint fd = -1;\n\n\t \n\tif (!compressions[comp].is_compressed(name))\n\t\treturn open(name, O_RDONLY);\n\n\tfd = mkstemp(tmpbuf);\n\tif (fd < 0) {\n\t\t*err = errno;\n\t\treturn -1;\n\t}\n\n\tif (compressions[comp].decompress(name, fd)) {\n\t\t*err = DSO_LOAD_ERRNO__DECOMPRESSION_FAILURE;\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\n\tif (!pathname || (fd < 0))\n\t\tunlink(tmpbuf);\n\n\tif (pathname && (fd >= 0))\n\t\tstrlcpy(pathname, tmpbuf, len);\n\n\treturn fd;\n}\n\nstatic int decompress_kmodule(struct dso *dso, const char *name,\n\t\t\t      char *pathname, size_t len)\n{\n\tif (!dso__needs_decompress(dso))\n\t\treturn -1;\n\n\tif (dso->comp == COMP_ID__NONE)\n\t\treturn -1;\n\n\treturn filename__decompress(name, pathname, len, dso->comp,\n\t\t\t\t    &dso->load_errno);\n}\n\nint dso__decompress_kmodule_fd(struct dso *dso, const char *name)\n{\n\treturn decompress_kmodule(dso, name, NULL, 0);\n}\n\nint dso__decompress_kmodule_path(struct dso *dso, const char *name,\n\t\t\t\t char *pathname, size_t len)\n{\n\tint fd = decompress_kmodule(dso, name, pathname, len);\n\n\tclose(fd);\n\treturn fd >= 0 ? 0 : -1;\n}\n\n \nint __kmod_path__parse(struct kmod_path *m, const char *path,\n\t\t       bool alloc_name)\n{\n\tconst char *name = strrchr(path, '/');\n\tconst char *ext  = strrchr(path, '.');\n\tbool is_simple_name = false;\n\n\tmemset(m, 0x0, sizeof(*m));\n\tname = name ? name + 1 : path;\n\n\t \n\tif (name[0] == '[') {\n\t\tis_simple_name = true;\n\t\tif ((strncmp(name, \"[kernel.kallsyms]\", 17) == 0) ||\n\t\t    (strncmp(name, \"[guest.kernel.kallsyms\", 22) == 0) ||\n\t\t    (strncmp(name, \"[vdso]\", 6) == 0) ||\n\t\t    (strncmp(name, \"[vdso32]\", 8) == 0) ||\n\t\t    (strncmp(name, \"[vdsox32]\", 9) == 0) ||\n\t\t    (strncmp(name, \"[vsyscall]\", 10) == 0)) {\n\t\t\tm->kmod = false;\n\n\t\t} else\n\t\t\tm->kmod = true;\n\t}\n\n\t \n\tif ((ext == NULL) || is_simple_name) {\n\t\tif (alloc_name) {\n\t\t\tm->name = strdup(name);\n\t\t\treturn m->name ? 0 : -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tm->comp = is_supported_compression(ext + 1);\n\tif (m->comp > COMP_ID__NONE)\n\t\text -= 3;\n\n\t \n\tif (ext > name)\n\t\tm->kmod = !strncmp(ext, \".ko\", 3);\n\n\tif (alloc_name) {\n\t\tif (m->kmod) {\n\t\t\tif (asprintf(&m->name, \"[%.*s]\", (int) (ext - name), name) == -1)\n\t\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tif (asprintf(&m->name, \"%s\", name) == -1)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tstrreplace(m->name, '-', '_');\n\t}\n\n\treturn 0;\n}\n\nvoid dso__set_module_info(struct dso *dso, struct kmod_path *m,\n\t\t\t  struct machine *machine)\n{\n\tif (machine__is_host(machine))\n\t\tdso->symtab_type = DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE;\n\telse\n\t\tdso->symtab_type = DSO_BINARY_TYPE__GUEST_KMODULE;\n\n\t \n\tif (m->kmod && m->comp) {\n\t\tdso->symtab_type++;\n\t\tdso->comp = m->comp;\n\t}\n\n\tdso__set_short_name(dso, strdup(m->name), true);\n}\n\n \nstatic LIST_HEAD(dso__data_open);\nstatic long dso__data_open_cnt;\nstatic pthread_mutex_t dso__data_open_lock = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void dso__list_add(struct dso *dso)\n{\n\tlist_add_tail(&dso->data.open_entry, &dso__data_open);\n\tdso__data_open_cnt++;\n}\n\nstatic void dso__list_del(struct dso *dso)\n{\n\tlist_del_init(&dso->data.open_entry);\n\tWARN_ONCE(dso__data_open_cnt <= 0,\n\t\t  \"DSO data fd counter out of bounds.\");\n\tdso__data_open_cnt--;\n}\n\nstatic void close_first_dso(void);\n\nstatic int do_open(char *name)\n{\n\tint fd;\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tdo {\n\t\tfd = open(name, O_RDONLY|O_CLOEXEC);\n\t\tif (fd >= 0)\n\t\t\treturn fd;\n\n\t\tpr_debug(\"dso open failed: %s\\n\",\n\t\t\t str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\tif (!dso__data_open_cnt || errno != EMFILE)\n\t\t\tbreak;\n\n\t\tclose_first_dso();\n\t} while (1);\n\n\treturn -1;\n}\n\nchar *dso__filename_with_chroot(const struct dso *dso, const char *filename)\n{\n\treturn filename_with_chroot(nsinfo__pid(dso->nsinfo), filename);\n}\n\nstatic int __open_dso(struct dso *dso, struct machine *machine)\n{\n\tint fd = -EINVAL;\n\tchar *root_dir = (char *)\"\";\n\tchar *name = malloc(PATH_MAX);\n\tbool decomp = false;\n\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&dso->lock);\n\tif (machine)\n\t\troot_dir = machine->root_dir;\n\n\tif (dso__read_binary_type_filename(dso, dso->binary_type,\n\t\t\t\t\t    root_dir, name, PATH_MAX))\n\t\tgoto out;\n\n\tif (!is_regular_file(name)) {\n\t\tchar *new_name;\n\n\t\tif (errno != ENOENT || dso->nsinfo == NULL)\n\t\t\tgoto out;\n\n\t\tnew_name = dso__filename_with_chroot(dso, name);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\n\t\tfree(name);\n\t\tname = new_name;\n\t}\n\n\tif (dso__needs_decompress(dso)) {\n\t\tchar newpath[KMOD_DECOMP_LEN];\n\t\tsize_t len = sizeof(newpath);\n\n\t\tif (dso__decompress_kmodule_path(dso, name, newpath, len) < 0) {\n\t\t\tfd = -dso->load_errno;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdecomp = true;\n\t\tstrcpy(name, newpath);\n\t}\n\n\tfd = do_open(name);\n\n\tif (decomp)\n\t\tunlink(name);\n\nout:\n\tmutex_unlock(&dso->lock);\n\tfree(name);\n\treturn fd;\n}\n\nstatic void check_data_close(void);\n\n \nstatic int open_dso(struct dso *dso, struct machine *machine)\n{\n\tint fd;\n\tstruct nscookie nsc;\n\n\tif (dso->binary_type != DSO_BINARY_TYPE__BUILD_ID_CACHE) {\n\t\tmutex_lock(&dso->lock);\n\t\tnsinfo__mountns_enter(dso->nsinfo, &nsc);\n\t\tmutex_unlock(&dso->lock);\n\t}\n\tfd = __open_dso(dso, machine);\n\tif (dso->binary_type != DSO_BINARY_TYPE__BUILD_ID_CACHE)\n\t\tnsinfo__mountns_exit(&nsc);\n\n\tif (fd >= 0) {\n\t\tdso__list_add(dso);\n\t\t \n\t\tcheck_data_close();\n\t}\n\n\treturn fd;\n}\n\nstatic void close_data_fd(struct dso *dso)\n{\n\tif (dso->data.fd >= 0) {\n\t\tclose(dso->data.fd);\n\t\tdso->data.fd = -1;\n\t\tdso->data.file_size = 0;\n\t\tdso__list_del(dso);\n\t}\n}\n\n \nstatic void close_dso(struct dso *dso)\n{\n\tclose_data_fd(dso);\n}\n\nstatic void close_first_dso(void)\n{\n\tstruct dso *dso;\n\n\tdso = list_first_entry(&dso__data_open, struct dso, data.open_entry);\n\tclose_dso(dso);\n}\n\nstatic rlim_t get_fd_limit(void)\n{\n\tstruct rlimit l;\n\trlim_t limit = 0;\n\n\t \n\tif (getrlimit(RLIMIT_NOFILE, &l) == 0) {\n\t\tif (l.rlim_cur == RLIM_INFINITY)\n\t\t\tlimit = l.rlim_cur;\n\t\telse\n\t\t\tlimit = l.rlim_cur / 2;\n\t} else {\n\t\tpr_err(\"failed to get fd limit\\n\");\n\t\tlimit = 1;\n\t}\n\n\treturn limit;\n}\n\nstatic rlim_t fd_limit;\n\n \nvoid reset_fd_limit(void)\n{\n\tfd_limit = 0;\n}\n\nstatic bool may_cache_fd(void)\n{\n\tif (!fd_limit)\n\t\tfd_limit = get_fd_limit();\n\n\tif (fd_limit == RLIM_INFINITY)\n\t\treturn true;\n\n\treturn fd_limit > (rlim_t) dso__data_open_cnt;\n}\n\n \nstatic void check_data_close(void)\n{\n\tbool cache_fd = may_cache_fd();\n\n\tif (!cache_fd)\n\t\tclose_first_dso();\n}\n\n \nvoid dso__data_close(struct dso *dso)\n{\n\tpthread_mutex_lock(&dso__data_open_lock);\n\tclose_dso(dso);\n\tpthread_mutex_unlock(&dso__data_open_lock);\n}\n\nstatic void try_to_open_dso(struct dso *dso, struct machine *machine)\n{\n\tenum dso_binary_type binary_type_data[] = {\n\t\tDSO_BINARY_TYPE__BUILD_ID_CACHE,\n\t\tDSO_BINARY_TYPE__SYSTEM_PATH_DSO,\n\t\tDSO_BINARY_TYPE__NOT_FOUND,\n\t};\n\tint i = 0;\n\n\tif (dso->data.fd >= 0)\n\t\treturn;\n\n\tif (dso->binary_type != DSO_BINARY_TYPE__NOT_FOUND) {\n\t\tdso->data.fd = open_dso(dso, machine);\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tdso->binary_type = binary_type_data[i++];\n\n\t\tdso->data.fd = open_dso(dso, machine);\n\t\tif (dso->data.fd >= 0)\n\t\t\tgoto out;\n\n\t} while (dso->binary_type != DSO_BINARY_TYPE__NOT_FOUND);\nout:\n\tif (dso->data.fd >= 0)\n\t\tdso->data.status = DSO_DATA_STATUS_OK;\n\telse\n\t\tdso->data.status = DSO_DATA_STATUS_ERROR;\n}\n\n \nint dso__data_get_fd(struct dso *dso, struct machine *machine)\n{\n\tif (dso->data.status == DSO_DATA_STATUS_ERROR)\n\t\treturn -1;\n\n\tif (pthread_mutex_lock(&dso__data_open_lock) < 0)\n\t\treturn -1;\n\n\ttry_to_open_dso(dso, machine);\n\n\tif (dso->data.fd < 0)\n\t\tpthread_mutex_unlock(&dso__data_open_lock);\n\n\treturn dso->data.fd;\n}\n\nvoid dso__data_put_fd(struct dso *dso __maybe_unused)\n{\n\tpthread_mutex_unlock(&dso__data_open_lock);\n}\n\nbool dso__data_status_seen(struct dso *dso, enum dso_data_status_seen by)\n{\n\tu32 flag = 1 << by;\n\n\tif (dso->data.status_seen & flag)\n\t\treturn true;\n\n\tdso->data.status_seen |= flag;\n\n\treturn false;\n}\n\n#ifdef HAVE_LIBBPF_SUPPORT\nstatic ssize_t bpf_read(struct dso *dso, u64 offset, char *data)\n{\n\tstruct bpf_prog_info_node *node;\n\tssize_t size = DSO__DATA_CACHE_SIZE;\n\tu64 len;\n\tu8 *buf;\n\n\tnode = perf_env__find_bpf_prog_info(dso->bpf_prog.env, dso->bpf_prog.id);\n\tif (!node || !node->info_linear) {\n\t\tdso->data.status = DSO_DATA_STATUS_ERROR;\n\t\treturn -1;\n\t}\n\n\tlen = node->info_linear->info.jited_prog_len;\n\tbuf = (u8 *)(uintptr_t)node->info_linear->info.jited_prog_insns;\n\n\tif (offset >= len)\n\t\treturn -1;\n\n\tsize = (ssize_t)min(len - offset, (u64)size);\n\tmemcpy(data, buf + offset, size);\n\treturn size;\n}\n\nstatic int bpf_size(struct dso *dso)\n{\n\tstruct bpf_prog_info_node *node;\n\n\tnode = perf_env__find_bpf_prog_info(dso->bpf_prog.env, dso->bpf_prog.id);\n\tif (!node || !node->info_linear) {\n\t\tdso->data.status = DSO_DATA_STATUS_ERROR;\n\t\treturn -1;\n\t}\n\n\tdso->data.file_size = node->info_linear->info.jited_prog_len;\n\treturn 0;\n}\n#endif \n\nstatic void\ndso_cache__free(struct dso *dso)\n{\n\tstruct rb_root *root = &dso->data.cache;\n\tstruct rb_node *next = rb_first(root);\n\n\tmutex_lock(&dso->lock);\n\twhile (next) {\n\t\tstruct dso_cache *cache;\n\n\t\tcache = rb_entry(next, struct dso_cache, rb_node);\n\t\tnext = rb_next(&cache->rb_node);\n\t\trb_erase(&cache->rb_node, root);\n\t\tfree(cache);\n\t}\n\tmutex_unlock(&dso->lock);\n}\n\nstatic struct dso_cache *__dso_cache__find(struct dso *dso, u64 offset)\n{\n\tconst struct rb_root *root = &dso->data.cache;\n\tstruct rb_node * const *p = &root->rb_node;\n\tconst struct rb_node *parent = NULL;\n\tstruct dso_cache *cache;\n\n\twhile (*p != NULL) {\n\t\tu64 end;\n\n\t\tparent = *p;\n\t\tcache = rb_entry(parent, struct dso_cache, rb_node);\n\t\tend = cache->offset + DSO__DATA_CACHE_SIZE;\n\n\t\tif (offset < cache->offset)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offset >= end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn cache;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct dso_cache *\ndso_cache__insert(struct dso *dso, struct dso_cache *new)\n{\n\tstruct rb_root *root = &dso->data.cache;\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct dso_cache *cache;\n\tu64 offset = new->offset;\n\n\tmutex_lock(&dso->lock);\n\twhile (*p != NULL) {\n\t\tu64 end;\n\n\t\tparent = *p;\n\t\tcache = rb_entry(parent, struct dso_cache, rb_node);\n\t\tend = cache->offset + DSO__DATA_CACHE_SIZE;\n\n\t\tif (offset < cache->offset)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offset >= end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\trb_link_node(&new->rb_node, parent, p);\n\trb_insert_color(&new->rb_node, root);\n\n\tcache = NULL;\nout:\n\tmutex_unlock(&dso->lock);\n\treturn cache;\n}\n\nstatic ssize_t dso_cache__memcpy(struct dso_cache *cache, u64 offset, u8 *data,\n\t\t\t\t u64 size, bool out)\n{\n\tu64 cache_offset = offset - cache->offset;\n\tu64 cache_size   = min(cache->size - cache_offset, size);\n\n\tif (out)\n\t\tmemcpy(data, cache->data + cache_offset, cache_size);\n\telse\n\t\tmemcpy(cache->data + cache_offset, data, cache_size);\n\treturn cache_size;\n}\n\nstatic ssize_t file_read(struct dso *dso, struct machine *machine,\n\t\t\t u64 offset, char *data)\n{\n\tssize_t ret;\n\n\tpthread_mutex_lock(&dso__data_open_lock);\n\n\t \n\ttry_to_open_dso(dso, machine);\n\n\tif (dso->data.fd < 0) {\n\t\tdso->data.status = DSO_DATA_STATUS_ERROR;\n\t\tret = -errno;\n\t\tgoto out;\n\t}\n\n\tret = pread(dso->data.fd, data, DSO__DATA_CACHE_SIZE, offset);\nout:\n\tpthread_mutex_unlock(&dso__data_open_lock);\n\treturn ret;\n}\n\nstatic struct dso_cache *dso_cache__populate(struct dso *dso,\n\t\t\t\t\t     struct machine *machine,\n\t\t\t\t\t     u64 offset, ssize_t *ret)\n{\n\tu64 cache_offset = offset & DSO__DATA_CACHE_MASK;\n\tstruct dso_cache *cache;\n\tstruct dso_cache *old;\n\n\tcache = zalloc(sizeof(*cache) + DSO__DATA_CACHE_SIZE);\n\tif (!cache) {\n\t\t*ret = -ENOMEM;\n\t\treturn NULL;\n\t}\n#ifdef HAVE_LIBBPF_SUPPORT\n\tif (dso->binary_type == DSO_BINARY_TYPE__BPF_PROG_INFO)\n\t\t*ret = bpf_read(dso, cache_offset, cache->data);\n\telse\n#endif\n\tif (dso->binary_type == DSO_BINARY_TYPE__OOL)\n\t\t*ret = DSO__DATA_CACHE_SIZE;\n\telse\n\t\t*ret = file_read(dso, machine, cache_offset, cache->data);\n\n\tif (*ret <= 0) {\n\t\tfree(cache);\n\t\treturn NULL;\n\t}\n\n\tcache->offset = cache_offset;\n\tcache->size   = *ret;\n\n\told = dso_cache__insert(dso, cache);\n\tif (old) {\n\t\t \n\t\tfree(cache);\n\t\tcache = old;\n\t}\n\n\treturn cache;\n}\n\nstatic struct dso_cache *dso_cache__find(struct dso *dso,\n\t\t\t\t\t struct machine *machine,\n\t\t\t\t\t u64 offset,\n\t\t\t\t\t ssize_t *ret)\n{\n\tstruct dso_cache *cache = __dso_cache__find(dso, offset);\n\n\treturn cache ? cache : dso_cache__populate(dso, machine, offset, ret);\n}\n\nstatic ssize_t dso_cache_io(struct dso *dso, struct machine *machine,\n\t\t\t    u64 offset, u8 *data, ssize_t size, bool out)\n{\n\tstruct dso_cache *cache;\n\tssize_t ret = 0;\n\n\tcache = dso_cache__find(dso, machine, offset, &ret);\n\tif (!cache)\n\t\treturn ret;\n\n\treturn dso_cache__memcpy(cache, offset, data, size, out);\n}\n\n \nstatic ssize_t cached_io(struct dso *dso, struct machine *machine,\n\t\t\t u64 offset, u8 *data, ssize_t size, bool out)\n{\n\tssize_t r = 0;\n\tu8 *p = data;\n\n\tdo {\n\t\tssize_t ret;\n\n\t\tret = dso_cache_io(dso, machine, offset, p, size, out);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tBUG_ON(ret > size);\n\n\t\tr      += ret;\n\t\tp      += ret;\n\t\toffset += ret;\n\t\tsize   -= ret;\n\n\t} while (size);\n\n\treturn r;\n}\n\nstatic int file_size(struct dso *dso, struct machine *machine)\n{\n\tint ret = 0;\n\tstruct stat st;\n\tchar sbuf[STRERR_BUFSIZE];\n\n\tpthread_mutex_lock(&dso__data_open_lock);\n\n\t \n\ttry_to_open_dso(dso, machine);\n\n\tif (dso->data.fd < 0) {\n\t\tret = -errno;\n\t\tdso->data.status = DSO_DATA_STATUS_ERROR;\n\t\tgoto out;\n\t}\n\n\tif (fstat(dso->data.fd, &st) < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"dso cache fstat failed: %s\\n\",\n\t\t       str_error_r(errno, sbuf, sizeof(sbuf)));\n\t\tdso->data.status = DSO_DATA_STATUS_ERROR;\n\t\tgoto out;\n\t}\n\tdso->data.file_size = st.st_size;\n\nout:\n\tpthread_mutex_unlock(&dso__data_open_lock);\n\treturn ret;\n}\n\nint dso__data_file_size(struct dso *dso, struct machine *machine)\n{\n\tif (dso->data.file_size)\n\t\treturn 0;\n\n\tif (dso->data.status == DSO_DATA_STATUS_ERROR)\n\t\treturn -1;\n#ifdef HAVE_LIBBPF_SUPPORT\n\tif (dso->binary_type == DSO_BINARY_TYPE__BPF_PROG_INFO)\n\t\treturn bpf_size(dso);\n#endif\n\treturn file_size(dso, machine);\n}\n\n \noff_t dso__data_size(struct dso *dso, struct machine *machine)\n{\n\tif (dso__data_file_size(dso, machine))\n\t\treturn -1;\n\n\t \n\treturn dso->data.file_size;\n}\n\nstatic ssize_t data_read_write_offset(struct dso *dso, struct machine *machine,\n\t\t\t\t      u64 offset, u8 *data, ssize_t size,\n\t\t\t\t      bool out)\n{\n\tif (dso__data_file_size(dso, machine))\n\t\treturn -1;\n\n\t \n\tif (offset > dso->data.file_size)\n\t\treturn -1;\n\n\tif (offset + size < offset)\n\t\treturn -1;\n\n\treturn cached_io(dso, machine, offset, data, size, out);\n}\n\n \nssize_t dso__data_read_offset(struct dso *dso, struct machine *machine,\n\t\t\t      u64 offset, u8 *data, ssize_t size)\n{\n\tif (dso->data.status == DSO_DATA_STATUS_ERROR)\n\t\treturn -1;\n\n\treturn data_read_write_offset(dso, machine, offset, data, size, true);\n}\n\n \nssize_t dso__data_read_addr(struct dso *dso, struct map *map,\n\t\t\t    struct machine *machine, u64 addr,\n\t\t\t    u8 *data, ssize_t size)\n{\n\tu64 offset = map__map_ip(map, addr);\n\n\treturn dso__data_read_offset(dso, machine, offset, data, size);\n}\n\n \nssize_t dso__data_write_cache_offs(struct dso *dso, struct machine *machine,\n\t\t\t\t   u64 offset, const u8 *data_in, ssize_t size)\n{\n\tu8 *data = (u8 *)data_in;  \n\n\tif (dso->data.status == DSO_DATA_STATUS_ERROR)\n\t\treturn -1;\n\n\treturn data_read_write_offset(dso, machine, offset, data, size, false);\n}\n\n \nssize_t dso__data_write_cache_addr(struct dso *dso, struct map *map,\n\t\t\t\t   struct machine *machine, u64 addr,\n\t\t\t\t   const u8 *data, ssize_t size)\n{\n\tu64 offset = map__map_ip(map, addr);\n\n\treturn dso__data_write_cache_offs(dso, machine, offset, data, size);\n}\n\nstruct map *dso__new_map(const char *name)\n{\n\tstruct map *map = NULL;\n\tstruct dso *dso = dso__new(name);\n\n\tif (dso) {\n\t\tmap = map__new2(0, dso);\n\t\tdso__put(dso);\n\t}\n\n\treturn map;\n}\n\nstruct dso *machine__findnew_kernel(struct machine *machine, const char *name,\n\t\t\t\t    const char *short_name, int dso_type)\n{\n\t \n\tstruct dso *dso = machine__findnew_dso(machine, name);\n\n\t \n\tif (dso != NULL) {\n\t\tdso__set_short_name(dso, short_name, false);\n\t\tdso->kernel = dso_type;\n\t}\n\n\treturn dso;\n}\n\nstatic void dso__set_long_name_id(struct dso *dso, const char *name, struct dso_id *id, bool name_allocated)\n{\n\tstruct rb_root *root = dso->root;\n\n\tif (name == NULL)\n\t\treturn;\n\n\tif (dso->long_name_allocated)\n\t\tfree((char *)dso->long_name);\n\n\tif (root) {\n\t\trb_erase(&dso->rb_node, root);\n\t\t \n\t\tRB_CLEAR_NODE(&dso->rb_node);\n\t\tdso->root = NULL;\n\t}\n\n\tdso->long_name\t\t = name;\n\tdso->long_name_len\t = strlen(name);\n\tdso->long_name_allocated = name_allocated;\n\n\tif (root)\n\t\t__dsos__findnew_link_by_longname_id(root, dso, NULL, id);\n}\n\nvoid dso__set_long_name(struct dso *dso, const char *name, bool name_allocated)\n{\n\tdso__set_long_name_id(dso, name, NULL, name_allocated);\n}\n\nvoid dso__set_short_name(struct dso *dso, const char *name, bool name_allocated)\n{\n\tif (name == NULL)\n\t\treturn;\n\n\tif (dso->short_name_allocated)\n\t\tfree((char *)dso->short_name);\n\n\tdso->short_name\t\t  = name;\n\tdso->short_name_len\t  = strlen(name);\n\tdso->short_name_allocated = name_allocated;\n}\n\nint dso__name_len(const struct dso *dso)\n{\n\tif (!dso)\n\t\treturn strlen(\"[unknown]\");\n\tif (verbose > 0)\n\t\treturn dso->long_name_len;\n\n\treturn dso->short_name_len;\n}\n\nbool dso__loaded(const struct dso *dso)\n{\n\treturn dso->loaded;\n}\n\nbool dso__sorted_by_name(const struct dso *dso)\n{\n\treturn dso->sorted_by_name;\n}\n\nvoid dso__set_sorted_by_name(struct dso *dso)\n{\n\tdso->sorted_by_name = true;\n}\n\nstruct dso *dso__new_id(const char *name, struct dso_id *id)\n{\n\tstruct dso *dso = calloc(1, sizeof(*dso) + strlen(name) + 1);\n\n\tif (dso != NULL) {\n\t\tstrcpy(dso->name, name);\n\t\tif (id)\n\t\t\tdso->id = *id;\n\t\tdso__set_long_name_id(dso, dso->name, id, false);\n\t\tdso__set_short_name(dso, dso->name, false);\n\t\tdso->symbols = RB_ROOT_CACHED;\n\t\tdso->symbol_names = NULL;\n\t\tdso->symbol_names_len = 0;\n\t\tdso->data.cache = RB_ROOT;\n\t\tdso->inlined_nodes = RB_ROOT_CACHED;\n\t\tdso->srclines = RB_ROOT_CACHED;\n\t\tdso->data.fd = -1;\n\t\tdso->data.status = DSO_DATA_STATUS_UNKNOWN;\n\t\tdso->symtab_type = DSO_BINARY_TYPE__NOT_FOUND;\n\t\tdso->binary_type = DSO_BINARY_TYPE__NOT_FOUND;\n\t\tdso->is_64_bit = (sizeof(void *) == 8);\n\t\tdso->loaded = 0;\n\t\tdso->rel = 0;\n\t\tdso->sorted_by_name = 0;\n\t\tdso->has_build_id = 0;\n\t\tdso->has_srcline = 1;\n\t\tdso->a2l_fails = 1;\n\t\tdso->kernel = DSO_SPACE__USER;\n\t\tdso->needs_swap = DSO_SWAP__UNSET;\n\t\tdso->comp = COMP_ID__NONE;\n\t\tRB_CLEAR_NODE(&dso->rb_node);\n\t\tdso->root = NULL;\n\t\tINIT_LIST_HEAD(&dso->node);\n\t\tINIT_LIST_HEAD(&dso->data.open_entry);\n\t\tmutex_init(&dso->lock);\n\t\trefcount_set(&dso->refcnt, 1);\n\t}\n\n\treturn dso;\n}\n\nstruct dso *dso__new(const char *name)\n{\n\treturn dso__new_id(name, NULL);\n}\n\nvoid dso__delete(struct dso *dso)\n{\n\tif (!RB_EMPTY_NODE(&dso->rb_node))\n\t\tpr_err(\"DSO %s is still in rbtree when being deleted!\\n\",\n\t\t       dso->long_name);\n\n\t \n\tinlines__tree_delete(&dso->inlined_nodes);\n\tsrcline__tree_delete(&dso->srclines);\n\tsymbols__delete(&dso->symbols);\n\tdso->symbol_names_len = 0;\n\tzfree(&dso->symbol_names);\n\tif (dso->short_name_allocated) {\n\t\tzfree((char **)&dso->short_name);\n\t\tdso->short_name_allocated = false;\n\t}\n\n\tif (dso->long_name_allocated) {\n\t\tzfree((char **)&dso->long_name);\n\t\tdso->long_name_allocated = false;\n\t}\n\n\tdso__data_close(dso);\n\tauxtrace_cache__free(dso->auxtrace_cache);\n\tdso_cache__free(dso);\n\tdso__free_a2l(dso);\n\tzfree(&dso->symsrc_filename);\n\tnsinfo__zput(dso->nsinfo);\n\tmutex_destroy(&dso->lock);\n\tfree(dso);\n}\n\nstruct dso *dso__get(struct dso *dso)\n{\n\tif (dso)\n\t\trefcount_inc(&dso->refcnt);\n\treturn dso;\n}\n\nvoid dso__put(struct dso *dso)\n{\n\tif (dso && refcount_dec_and_test(&dso->refcnt))\n\t\tdso__delete(dso);\n}\n\nvoid dso__set_build_id(struct dso *dso, struct build_id *bid)\n{\n\tdso->bid = *bid;\n\tdso->has_build_id = 1;\n}\n\nbool dso__build_id_equal(const struct dso *dso, struct build_id *bid)\n{\n\tif (dso->bid.size > bid->size && dso->bid.size == BUILD_ID_SIZE) {\n\t\t \n\t\treturn !memcmp(dso->bid.data, bid->data, bid->size) &&\n\t\t\t!memchr_inv(&dso->bid.data[bid->size], 0,\n\t\t\t\t    dso->bid.size - bid->size);\n\t}\n\n\treturn dso->bid.size == bid->size &&\n\t       memcmp(dso->bid.data, bid->data, dso->bid.size) == 0;\n}\n\nvoid dso__read_running_kernel_build_id(struct dso *dso, struct machine *machine)\n{\n\tchar path[PATH_MAX];\n\n\tif (machine__is_default_guest(machine))\n\t\treturn;\n\tsprintf(path, \"%s/sys/kernel/notes\", machine->root_dir);\n\tif (sysfs__read_build_id(path, &dso->bid) == 0)\n\t\tdso->has_build_id = true;\n}\n\nint dso__kernel_module_get_build_id(struct dso *dso,\n\t\t\t\t    const char *root_dir)\n{\n\tchar filename[PATH_MAX];\n\t \n\tconst char *name = dso->short_name + 1;\n\n\tsnprintf(filename, sizeof(filename),\n\t\t \"%s/sys/module/%.*s/notes/.note.gnu.build-id\",\n\t\t root_dir, (int)strlen(name) - 1, name);\n\n\tif (sysfs__read_build_id(filename, &dso->bid) == 0)\n\t\tdso->has_build_id = true;\n\n\treturn 0;\n}\n\nstatic size_t dso__fprintf_buildid(struct dso *dso, FILE *fp)\n{\n\tchar sbuild_id[SBUILD_ID_SIZE];\n\n\tbuild_id__sprintf(&dso->bid, sbuild_id);\n\treturn fprintf(fp, \"%s\", sbuild_id);\n}\n\nsize_t dso__fprintf(struct dso *dso, FILE *fp)\n{\n\tstruct rb_node *nd;\n\tsize_t ret = fprintf(fp, \"dso: %s (\", dso->short_name);\n\n\tif (dso->short_name != dso->long_name)\n\t\tret += fprintf(fp, \"%s, \", dso->long_name);\n\tret += fprintf(fp, \"%sloaded, \", dso__loaded(dso) ? \"\" : \"NOT \");\n\tret += dso__fprintf_buildid(dso, fp);\n\tret += fprintf(fp, \")\\n\");\n\tfor (nd = rb_first_cached(&dso->symbols); nd; nd = rb_next(nd)) {\n\t\tstruct symbol *pos = rb_entry(nd, struct symbol, rb_node);\n\t\tret += symbol__fprintf(pos, fp);\n\t}\n\n\treturn ret;\n}\n\nenum dso_type dso__type(struct dso *dso, struct machine *machine)\n{\n\tint fd;\n\tenum dso_type type = DSO__TYPE_UNKNOWN;\n\n\tfd = dso__data_get_fd(dso, machine);\n\tif (fd >= 0) {\n\t\ttype = dso__type_fd(fd);\n\t\tdso__data_put_fd(dso);\n\t}\n\n\treturn type;\n}\n\nint dso__strerror_load(struct dso *dso, char *buf, size_t buflen)\n{\n\tint idx, errnum = dso->load_errno;\n\t \n\tstatic const char *dso_load__error_str[] = {\n\t\"Internal tools/perf/ library error\",\n\t\"Invalid ELF file\",\n\t\"Can not read build id\",\n\t\"Mismatching build id\",\n\t\"Decompression failure\",\n\t};\n\n\tBUG_ON(buflen == 0);\n\n\tif (errnum >= 0) {\n\t\tconst char *err = str_error_r(errnum, buf, buflen);\n\n\t\tif (err != buf)\n\t\t\tscnprintf(buf, buflen, \"%s\", err);\n\n\t\treturn 0;\n\t}\n\n\tif (errnum <  __DSO_LOAD_ERRNO__START || errnum >= __DSO_LOAD_ERRNO__END)\n\t\treturn -1;\n\n\tidx = errnum - __DSO_LOAD_ERRNO__START;\n\tscnprintf(buf, buflen, \"%s\", dso_load__error_str[idx]);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}