{
  "module_name": "sample_filter.bpf.c",
  "hash_id": "ca1f5b9433dbf19ffd57ffd2de022027c0fc1144b36886ae6bcdbd783f9980d9",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf_skel/sample_filter.bpf.c",
  "human_readable_source": "\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\n#include \"sample-filter.h\"\n\n \nstruct filters {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, int);\n\t__type(value, struct perf_bpf_filter_entry);\n\t__uint(max_entries, MAX_FILTERS);\n} filters SEC(\".maps\");\n\nint dropped;\n\nvoid *bpf_cast_to_kern_ctx(void *) __ksym;\n\n \nstruct perf_sample_data___new {\n\t__u64 sample_flags;\n} __attribute__((preserve_access_index));\n\n \nunion perf_mem_data_src___new {\n\t__u64 val;\n\tstruct {\n\t\t__u64   mem_op:5,\t \n\t\t\tmem_lvl:14,\t \n\t\t\tmem_snoop:5,\t \n\t\t\tmem_lock:2,\t \n\t\t\tmem_dtlb:7,\t \n\t\t\tmem_lvl_num:4,\t \n\t\t\tmem_remote:1,    \n\t\t\tmem_snoopx:2,\t \n\t\t\tmem_blk:3,\t \n\t\t\tmem_hops:3,\t \n\t\t\tmem_rsvd:18;\n\t};\n};\n\n \nstatic inline __u64 perf_get_sample(struct bpf_perf_event_data_kern *kctx,\n\t\t\t\t    struct perf_bpf_filter_entry *entry)\n{\n\tstruct perf_sample_data___new *data = (void *)kctx->data;\n\n\tif (!bpf_core_field_exists(data->sample_flags) ||\n\t    (data->sample_flags & entry->flags) == 0)\n\t\treturn 0;\n\n\tswitch (entry->flags) {\n\tcase PERF_SAMPLE_IP:\n\t\treturn kctx->data->ip;\n\tcase PERF_SAMPLE_ID:\n\t\treturn kctx->data->id;\n\tcase PERF_SAMPLE_TID:\n\t\tif (entry->part)\n\t\t\treturn kctx->data->tid_entry.pid;\n\t\telse\n\t\t\treturn kctx->data->tid_entry.tid;\n\tcase PERF_SAMPLE_CPU:\n\t\treturn kctx->data->cpu_entry.cpu;\n\tcase PERF_SAMPLE_TIME:\n\t\treturn kctx->data->time;\n\tcase PERF_SAMPLE_ADDR:\n\t\treturn kctx->data->addr;\n\tcase PERF_SAMPLE_PERIOD:\n\t\treturn kctx->data->period;\n\tcase PERF_SAMPLE_TRANSACTION:\n\t\treturn kctx->data->txn;\n\tcase PERF_SAMPLE_WEIGHT_STRUCT:\n\t\tif (entry->part == 1)\n\t\t\treturn kctx->data->weight.var1_dw;\n\t\tif (entry->part == 2)\n\t\t\treturn kctx->data->weight.var2_w;\n\t\tif (entry->part == 3)\n\t\t\treturn kctx->data->weight.var3_w;\n\t\t \n\tcase PERF_SAMPLE_WEIGHT:\n\t\treturn kctx->data->weight.full;\n\tcase PERF_SAMPLE_PHYS_ADDR:\n\t\treturn kctx->data->phys_addr;\n\tcase PERF_SAMPLE_CODE_PAGE_SIZE:\n\t\treturn kctx->data->code_page_size;\n\tcase PERF_SAMPLE_DATA_PAGE_SIZE:\n\t\treturn kctx->data->data_page_size;\n\tcase PERF_SAMPLE_DATA_SRC:\n\t\tif (entry->part == 1)\n\t\t\treturn kctx->data->data_src.mem_op;\n\t\tif (entry->part == 2)\n\t\t\treturn kctx->data->data_src.mem_lvl_num;\n\t\tif (entry->part == 3) {\n\t\t\t__u32 snoop = kctx->data->data_src.mem_snoop;\n\t\t\t__u32 snoopx = kctx->data->data_src.mem_snoopx;\n\n\t\t\treturn (snoopx << 5) | snoop;\n\t\t}\n\t\tif (entry->part == 4)\n\t\t\treturn kctx->data->data_src.mem_remote;\n\t\tif (entry->part == 5)\n\t\t\treturn kctx->data->data_src.mem_lock;\n\t\tif (entry->part == 6)\n\t\t\treturn kctx->data->data_src.mem_dtlb;\n\t\tif (entry->part == 7)\n\t\t\treturn kctx->data->data_src.mem_blk;\n\t\tif (entry->part == 8) {\n\t\t\tunion perf_mem_data_src___new *data = (void *)&kctx->data->data_src;\n\n\t\t\tif (bpf_core_field_exists(data->mem_hops))\n\t\t\t\treturn data->mem_hops;\n\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\treturn kctx->data->data_src.val;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define CHECK_RESULT(data, op, val)\t\t\t\\\n\tif (!(data op val)) {\t\t\t\t\\\n\t\tif (!in_group)\t\t\t\t\\\n\t\t\tgoto drop;\t\t\t\\\n\t} else if (in_group) {\t\t\t\t\\\n\t\tgroup_result = 1;\t\t\t\\\n\t}\n\n \nSEC(\"perf_event\")\nint perf_sample_filter(void *ctx)\n{\n\tstruct bpf_perf_event_data_kern *kctx;\n\tstruct perf_bpf_filter_entry *entry;\n\t__u64 sample_data;\n\tint in_group = 0;\n\tint group_result = 0;\n\tint i;\n\n\tkctx = bpf_cast_to_kern_ctx(ctx);\n\n\tfor (i = 0; i < MAX_FILTERS; i++) {\n\t\tint key = i;  \n\n\t\tentry = bpf_map_lookup_elem(&filters, &key);\n\t\tif (entry == NULL)\n\t\t\tbreak;\n\t\tsample_data = perf_get_sample(kctx, entry);\n\n\t\tswitch (entry->op) {\n\t\tcase PBF_OP_EQ:\n\t\t\tCHECK_RESULT(sample_data, ==, entry->value)\n\t\t\tbreak;\n\t\tcase PBF_OP_NEQ:\n\t\t\tCHECK_RESULT(sample_data, !=, entry->value)\n\t\t\tbreak;\n\t\tcase PBF_OP_GT:\n\t\t\tCHECK_RESULT(sample_data, >, entry->value)\n\t\t\tbreak;\n\t\tcase PBF_OP_GE:\n\t\t\tCHECK_RESULT(sample_data, >=, entry->value)\n\t\t\tbreak;\n\t\tcase PBF_OP_LT:\n\t\t\tCHECK_RESULT(sample_data, <, entry->value)\n\t\t\tbreak;\n\t\tcase PBF_OP_LE:\n\t\t\tCHECK_RESULT(sample_data, <=, entry->value)\n\t\t\tbreak;\n\t\tcase PBF_OP_AND:\n\t\t\tCHECK_RESULT(sample_data, &, entry->value)\n\t\t\tbreak;\n\t\tcase PBF_OP_GROUP_BEGIN:\n\t\t\tin_group = 1;\n\t\t\tgroup_result = 0;\n\t\t\tbreak;\n\t\tcase PBF_OP_GROUP_END:\n\t\t\tif (group_result == 0)\n\t\t\t\tgoto drop;\n\t\t\tin_group = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\treturn 1;\n\ndrop:\n\t__sync_fetch_and_add(&dropped, 1);\n\treturn 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}