{
  "module_name": "off_cpu.bpf.c",
  "hash_id": "9113cf141ea5529f135135bce9cfd81c180b62aecda9f9c81a9de25f37431bf0",
  "original_prompt": "Ingested from linux-6.6.14/tools/perf/util/bpf_skel/off_cpu.bpf.c",
  "human_readable_source": "\n\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\n \n#define PF_KTHREAD   0x00200000   \n\n \n#define TASK_INTERRUPTIBLE\t0x0001\n#define TASK_UNINTERRUPTIBLE\t0x0002\n\n \n#define CLONE_THREAD  0x10000\n\n#define MAX_STACKS   32\n#define MAX_ENTRIES  102400\n\nstruct tstamp_data {\n\t__u32 stack_id;\n\t__u32 state;\n\t__u64 timestamp;\n};\n\nstruct offcpu_key {\n\t__u32 pid;\n\t__u32 tgid;\n\t__u32 stack_id;\n\t__u32 state;\n\t__u64 cgroup_id;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_STACK_TRACE);\n\t__uint(key_size, sizeof(__u32));\n\t__uint(value_size, MAX_STACKS * sizeof(__u64));\n\t__uint(max_entries, MAX_ENTRIES);\n} stacks SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_TASK_STORAGE);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n\t__type(key, int);\n\t__type(value, struct tstamp_data);\n} tstamp SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(key_size, sizeof(struct offcpu_key));\n\t__uint(value_size, sizeof(__u64));\n\t__uint(max_entries, MAX_ENTRIES);\n} off_cpu SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(key_size, sizeof(__u32));\n\t__uint(value_size, sizeof(__u8));\n\t__uint(max_entries, 1);\n} cpu_filter SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(key_size, sizeof(__u32));\n\t__uint(value_size, sizeof(__u8));\n\t__uint(max_entries, 1);\n} task_filter SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__uint(key_size, sizeof(__u64));\n\t__uint(value_size, sizeof(__u8));\n\t__uint(max_entries, 1);\n} cgroup_filter SEC(\".maps\");\n\n \nstruct task_struct___new {\n\tlong __state;\n} __attribute__((preserve_access_index));\n\n \nstruct task_struct___old {\n\tlong state;\n} __attribute__((preserve_access_index));\n\nint enabled = 0;\nint has_cpu = 0;\nint has_task = 0;\nint has_cgroup = 0;\nint uses_tgid = 0;\n\nconst volatile bool has_prev_state = false;\nconst volatile bool needs_cgroup = false;\nconst volatile bool uses_cgroup_v1 = false;\n\nint perf_subsys_id = -1;\n\n \nstatic inline int get_task_state(struct task_struct *t)\n{\n\t \n\tstruct task_struct___new *t_new = (void *)t;\n\n\tif (bpf_core_field_exists(t_new->__state)) {\n\t\treturn BPF_CORE_READ(t_new, __state);\n\t} else {\n\t\t \n\t\tstruct task_struct___old *t_old = (void *)t;\n\n\t\treturn BPF_CORE_READ(t_old, state);\n\t}\n}\n\nstatic inline __u64 get_cgroup_id(struct task_struct *t)\n{\n\tstruct cgroup *cgrp;\n\n\tif (!uses_cgroup_v1)\n\t\treturn BPF_CORE_READ(t, cgroups, dfl_cgrp, kn, id);\n\n\tif (perf_subsys_id == -1) {\n#if __has_builtin(__builtin_preserve_enum_value)\n\t\tperf_subsys_id = bpf_core_enum_value(enum cgroup_subsys_id,\n\t\t\t\t\t\t     perf_event_cgrp_id);\n#else\n\t\tperf_subsys_id = perf_event_cgrp_id;\n#endif\n\t}\n\n\tcgrp = BPF_CORE_READ(t, cgroups, subsys[perf_subsys_id], cgroup);\n\treturn BPF_CORE_READ(cgrp, kn, id);\n}\n\nstatic inline int can_record(struct task_struct *t, int state)\n{\n\t \n\tif (t->flags & PF_KTHREAD)\n\t\treturn 0;\n\n\tif (state != TASK_INTERRUPTIBLE &&\n\t    state != TASK_UNINTERRUPTIBLE)\n\t\treturn 0;\n\n\tif (has_cpu) {\n\t\t__u32 cpu = bpf_get_smp_processor_id();\n\t\t__u8 *ok;\n\n\t\tok = bpf_map_lookup_elem(&cpu_filter, &cpu);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\n\tif (has_task) {\n\t\t__u8 *ok;\n\t\t__u32 pid;\n\n\t\tif (uses_tgid)\n\t\t\tpid = t->tgid;\n\t\telse\n\t\t\tpid = t->pid;\n\n\t\tok = bpf_map_lookup_elem(&task_filter, &pid);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\n\tif (has_cgroup) {\n\t\t__u8 *ok;\n\t\t__u64 cgrp_id = get_cgroup_id(t);\n\n\t\tok = bpf_map_lookup_elem(&cgroup_filter, &cgrp_id);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int off_cpu_stat(u64 *ctx, struct task_struct *prev,\n\t\t\tstruct task_struct *next, int state)\n{\n\t__u64 ts;\n\t__u32 stack_id;\n\tstruct tstamp_data *pelem;\n\n\tts = bpf_ktime_get_ns();\n\n\tif (!can_record(prev, state))\n\t\tgoto next;\n\n\tstack_id = bpf_get_stackid(ctx, &stacks,\n\t\t\t\t   BPF_F_FAST_STACK_CMP | BPF_F_USER_STACK);\n\n\tpelem = bpf_task_storage_get(&tstamp, prev, NULL,\n\t\t\t\t     BPF_LOCAL_STORAGE_GET_F_CREATE);\n\tif (!pelem)\n\t\tgoto next;\n\n\tpelem->timestamp = ts;\n\tpelem->state = state;\n\tpelem->stack_id = stack_id;\n\nnext:\n\tpelem = bpf_task_storage_get(&tstamp, next, NULL, 0);\n\n\tif (pelem && pelem->timestamp) {\n\t\tstruct offcpu_key key = {\n\t\t\t.pid = next->pid,\n\t\t\t.tgid = next->tgid,\n\t\t\t.stack_id = pelem->stack_id,\n\t\t\t.state = pelem->state,\n\t\t\t.cgroup_id = needs_cgroup ? get_cgroup_id(next) : 0,\n\t\t};\n\t\t__u64 delta = ts - pelem->timestamp;\n\t\t__u64 *total;\n\n\t\ttotal = bpf_map_lookup_elem(&off_cpu, &key);\n\t\tif (total)\n\t\t\t*total += delta;\n\t\telse\n\t\t\tbpf_map_update_elem(&off_cpu, &key, &delta, BPF_ANY);\n\n\t\t \n\t\tpelem->timestamp = 0;\n\t}\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/task_newtask\")\nint on_newtask(u64 *ctx)\n{\n\tstruct task_struct *task;\n\tu64 clone_flags;\n\tu32 pid;\n\tu8 val = 1;\n\n\tif (!uses_tgid)\n\t\treturn 0;\n\n\ttask = (struct task_struct *)bpf_get_current_task();\n\n\tpid = BPF_CORE_READ(task, tgid);\n\tif (!bpf_map_lookup_elem(&task_filter, &pid))\n\t\treturn 0;\n\n\ttask = (struct task_struct *)ctx[0];\n\tclone_flags = ctx[1];\n\n\tpid = task->tgid;\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tbpf_map_update_elem(&task_filter, &pid, &val, BPF_NOEXIST);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/sched_switch\")\nint on_switch(u64 *ctx)\n{\n\tstruct task_struct *prev, *next;\n\tint prev_state;\n\n\tif (!enabled)\n\t\treturn 0;\n\n\tprev = (struct task_struct *)ctx[1];\n\tnext = (struct task_struct *)ctx[2];\n\n\tif (has_prev_state)\n\t\tprev_state = (int)ctx[3];\n\telse\n\t\tprev_state = get_task_state(prev);\n\n\treturn off_cpu_stat(ctx, prev, next, prev_state & 0xff);\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}